WEBVTT

00:00:01.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:14.000
사람: 안녕하세요, SwiftUI의 고급 애니메이션을 통해 Wind에 오신 것을 환영합니다.

00:00:14.000 --> 00:00:18.000
저는 SwiftUI 팀의 일원인 팀입니다.

00:00:18.000 --> 00:00:29.000
SwiftUI는 인터럽트 가능한 애니메이션, 믿을 수 있는 모션을 위한 물리학 기반 애니메이션과 함께 앱을 빛나게 하는 강력한 애니메이션 도구 세트와 함께 제공되며, 프레임워크 전반에 걸쳐 깊이 통합되어 있습니다.

00:00:29.000 --> 00:00:35.000
오늘 우리는 앱에서 애니메이션을 한 단계 끌어올릴 수 있는 흥미진진한 새로운 도구에 대해 이야기할 것입니다.

00:00:35.000 --> 00:00:42.000
시작하기 전에, SwiftUI에서 이미 알고 있는 애니메이션 도구를 빠르게 검토해 봅시다.

00:00:42.000 --> 00:00:47.000
다른 세션에서 가장 좋아하는 애완동물에게 투표할 수 있는 이 앱을 본 적이 있을 것입니다.

00:00:47.000 --> 00:00:53.000
이 데모를 단순화하기 위해, 나는 고양이가 분명히 최선의 선택이기 때문에 다른 모든 옵션을 제거했다.

00:00:53.000 --> 00:01:02.000
앱에 애니메이션을 추가하는 것은 "withAnimation"을 사용하거나 "애니메이션" 수정자를 추가하는 것만큼 쉽습니다.

00:01:02.000 --> 00:01:10.000
애플리케이션 상태가 변경된 후, SwiftUI는 이전 상태에서 새 상태로 보간하는 애니메이션을 적용합니다.

00:01:10.000 --> 00:01:20.000
하지만 애니메이션으로, 삶과 마찬가지로, 때때로 당신이 어디에서 왔는지 또는 어디로 가고 있는지에 집중하지 않을 때 가장 보람 있는 경험을 찾을 수 있습니다.

00:01:20.000 --> 00:01:25.000
때때로 당신은 구불구불한 길에서 벗어나 특별한 것을 만들기 위해 여행 자체에 집중해야 합니다.

00:01:25.000 --> 00:01:29.000
그리고 일부 애니메이션은 단순히 이전 상태에서 새로운 상태로 애니메이션화하지 않는다.

00:01:29.000 --> 00:01:36.000
오늘, 저는 복잡하고 다단계 애니메이션을 만들기 위한 몇 가지 강력한 새로운 도구에 대해 이야기할 것입니다.

00:01:36.000 --> 00:01:42.000
두 상태 사이에서 애니메이션을 만드는 대신, 이 애니메이션은 순서대로 일어나는 여러 단계를 정의할 수 있다.

00:01:42.000 --> 00:01:51.000
그리고 그들은 두 가지 상황에서 특히 훌륭합니다: 반복되는 애니메이션, 보기가 보이는 동안 지속적으로 반복됩니다...

00:01:51.000 --> 00:01:56.000
그리고 이벤트가 발생할 때 깜박이는 뷰와 같은 이벤트 기반 애니메이션.

00:01:56.000 --> 00:02:02.000
이 강연에서, 저는 이와 같은 애니메이션을 더욱 쉽게 만들 수 있는 새로운 API 제품군을 소개할 것입니다.

00:02:02.000 --> 00:02:11.000
SwiftUI가 애니메이션을 구성하는 미리 계획된 상태 세트를 자동으로 진행할 수 있는 애니메이션 단계를 소개하는 것으로 시작하겠습니다.

00:02:11.000 --> 00:02:16.000
다음으로, 나는 키프레임으로 애니메이션을 더 발전시키는 방법을 보여줄 것이다.

00:02:16.000 --> 00:02:21.000
그리고 마지막으로, 이 API를 최대한 활용하기 위한 몇 가지 고급 팁과 요령을 보여드리겠습니다.

00:02:21.000 --> 00:02:25.000
내 생각에 우리는 갈 준비가 된 것 같아. 바로 뛰어들자.

00:02:25.000 --> 00:02:29.000
내가 스위프트를 쓰지 않을 때, 나는 트레일 러닝을 하는 것을 좋아한다.

00:02:29.000 --> 00:02:31.000
트레일 경주는 매우 길 수 있다.

00:02:31.000 --> 00:02:41.000
울트라마라톤은 끝내는 데 하루 종일 또는 심지어 며칠이 걸릴 수 있으므로, 저는 다가오는 행사를 계획하고 달리는 동안 중요한 세부 사항을 기억할 수 있도록 앱을 만들고 있습니다.

00:02:41.000 --> 00:02:44.000
당신이 길을 걷고 있을 때 영양은 매우 중요합니다.

00:02:44.000 --> 00:02:49.000
불행히도, 피로가 시작되면서 경주에서 늦게 먹는 것을 잊기 쉬울 수 있다.

00:02:49.000 --> 00:02:53.000
나는 내 앱에 적절한 시간에 식사하라고 상기시켜주는 기능을 추가했다.

00:02:53.000 --> 00:02:58.000
여기, 화면 하단에 있는 알림은 내가 식사 기한이 지났다는 것을 알려주고 있다.

00:02:58.000 --> 00:03:00.000
하지만 문제가 있어.

00:03:00.000 --> 00:03:05.000
나중에 경주에서, 나는 너무 피곤해서 이와 같은 미묘한 지표를 놓칠 수 있다.

00:03:05.000 --> 00:03:11.000
난 정말 실수로 식사를 건너뛰고 싶지 않아, 그래서 이 알림을 돋보이게 하기 위해 몇 가지 동작을 추가할게.

00:03:11.000 --> 00:03:13.000
이 한 가지 관점에 집중합시다.

00:03:13.000 --> 00:03:18.000
우리는 그것을 더 잘 볼 수 있도록 애니메이션 하이라이트 효과를 주고 싶습니다.

00:03:18.000 --> 00:03:23.000
이 보기를 애니메이션화하기 위해, 우리는 ".phaseAnimator" 수정자를 적용할 것이다.

00:03:23.000 --> 00:03:31.000
위상 애니메이터 수정자를 사용할 때, 여러 부분으로 구성된 애니메이션의 개별 단계를 정의하는 일련의 상태를 제공합니다.

00:03:31.000 --> 00:03:35.000
그런 다음 SwiftUI는 이 상태들 사이에서 자동으로 애니메이션화된다.

00:03:35.000 --> 00:03:42.000
이 경우, 우리는 두 상태 사이에서 애니메이션을 할 것입니다: 강조 표시되고 강조 표시되지 않으므로, 우리는 단순히 부울 값을 사용할 수 있습니다.

00:03:42.000 --> 00:03:47.000
다음으로, 우리는 현재 단계에 따라 뷰의 모양을 변경하기 위해 몇 가지 수정자를 적용할 것입니다.

00:03:47.000 --> 00:03:54.000
우리는 불투명도 수정자로 시작할 것입니다: 강조 표시될 때 보기를 완전히 불투명하게 만들고, 그렇지 않으면 50% 투명하게 만들 것입니다.

00:03:54.000 --> 00:03:57.000
그리고 바로, 경치가 움직이기 시작한다.

00:03:57.000 --> 00:04:01.000
SwiftUI가 당신을 대신하여 무엇을 하고 있는지 이야기해 봅시다.

00:04:01.000 --> 00:04:08.000
우리의 관점에서, 우리는 위상 애니메이터 수정자에 두 단계를 제공했다: false와 true.

00:04:08.000 --> 00:04:14.000
보기가 처음 나타나면, 첫 번째 단계가 활성화되어 보기가 50% 투명합니다.

00:04:14.000 --> 00:04:21.000
그런 다음 SwiftUI는 즉시 보기가 완전히 불투명한 다음 단계로의 애니메이션 전환을 시작합니다.

00:04:21.000 --> 00:04:25.000
그런 다음 그 애니메이션이 끝나면, SwiftUI는 다시 발전한다.

00:04:25.000 --> 00:04:29.000
우리는 두 단계밖에 없어서, 처음부터 반복한다.

00:04:29.000 --> 00:04:33.000
이것은 우리의 애니메이션이 두 주 사이를 순환하게 한다.

00:04:33.000 --> 00:04:43.000
물론, 두 단계 이상의 단계와 나중에 시연할 수 있는 추가 보기 수정자를 포함하는 애니메이션을 정의할 수도 있습니다.

00:04:43.000 --> 00:04:46.000
이제 경치가 움직이는 동안, 그 효과는 정말 미묘하다.

00:04:46.000 --> 00:04:51.000
불투명도를 바꾸는 대신, 전경 스타일을 바꿔봅시다.

00:04:51.000 --> 00:04:56.000
우리는 강조 표시될 때 빨간색을 사용할 것이고, 그렇지 않으면 기본 전경 스타일로 되돌아갈 것이다.

00:04:56.000 --> 00:05:01.000
그리고 그건 훨씬 더 눈에 띄어. 하지만 애니메이션은 약간 갑작스럽다.

00:05:01.000 --> 00:05:04.000
기본적으로, SwiftUI는 스프링 애니메이션을 사용한다.

00:05:04.000 --> 00:05:11.000
그리고 스프링은 동적 상태 변화를 처리하는 데 좋지만, 이 경우 우리는 더 부드럽고 일관된 애니메이션을 원합니다.

00:05:11.000 --> 00:05:15.000
우리는 후행 "애니메이션" 폐쇄를 추가하여 애니메이션을 변경할 수 있습니다.

00:05:15.000 --> 00:05:21.000
각 단계에 대해 다른 애니메이션을 사용하고 싶을 경우를 대비하여 애니메이션화되는 단계가 전달됩니다.

00:05:21.000 --> 00:05:28.000
하지만 이 경우, 나는 항상 속도를 늦추기 위해 사용자 지정 지속 시간을 가진 애니메이션에서 같은 편의성을 사용하고 싶다.

00:05:28.000 --> 00:05:37.000
이제, 당신은 사람들이 애니메이션이 끝날 때까지 기다리게 하고 싶지 않기 때문에 대화형 상태 변경을 위해 1초의 지속 시간을 가진 애니메이션을 사용하지 않을 것입니다.

00:05:37.000 --> 00:05:45.000
하지만 이 경우, 우리는 주변 효과를 만들고 있으므로, 내가 그 식사를 놓치면 내 속도처럼 조금 더 느리게 움직여도 괜찮습니다.

00:05:45.000 --> 00:05:54.000
이제 중반 인종 영양의 긴급한 문제를 해결했으므로, 애니메이션 단계를 사용하는 한 가지 방법을 더 살펴봅시다: 이벤트에 의해 트리거되는 애니메이션.

00:05:54.000 --> 00:05:59.000
나는 한동안 내 앱을 작업해왔고, 내 친구들이 어떤 경주를 뛰었는지 볼 수 있는 기능을 추가했다.

00:05:59.000 --> 00:06:01.000
이모티콘은 다른 사람들이 남긴 반응을 보여준다.

00:06:01.000 --> 00:06:05.000
모든 주자는 때때로 스스로에게 묻는다: 내가 왜 이것을 하는가?

00:06:05.000 --> 00:06:08.000
내가 왜 그렇게 많은 마일을 달리기 위해 등록했어?

00:06:08.000 --> 00:06:15.000
그리고 우리 앱이 할 수 있는 최소한의 일은 다른 사람이 경주를 좋아할 때 약간의 흥분을 추가하여 외부 검증의 필요성을 충족시키는 것입니다.

00:06:15.000 --> 00:06:20.000
우리는 누군가가 반응을 추가할 때마다 재생되는 애니메이션을 추가할 것이다.

00:06:20.000 --> 00:06:24.000
우리가 할 첫 번째 일은 애니메이션의 단계를 정의하는 것이다.

00:06:24.000 --> 00:06:30.000
단순히 두 상태 사이를 번갈아 가던 이전 예와 달리, 우리는 더 복잡한 애니메이션을 원한다.

00:06:30.000 --> 00:06:35.000
열거형은 애니메이션의 단계 목록을 정의할 수 있는 좋은 방법이다.

00:06:35.000 --> 00:06:42.000
우리는 세 가지 사례를 추가했습니다: 초기 외관을 위한 사례, 그리고 뷰를 위로 이동하고 뷰를 확장하는 사례.

00:06:42.000 --> 00:06:49.000
뷰 본문을 단순화하기 위해, 우리는 우리가 적용할 다양한 효과를 정의하는 이 열거형에 계산된 속성을 추가할 것이다.

00:06:49.000 --> 00:06:56.000
애니메이션 중에 보기가 올라가고 싶어서, 계산된 수직 오프셋 속성을 추가했습니다.

00:06:56.000 --> 00:07:00.000
각 경우에 대한 올바른 오프셋을 반환하기 위해 열거형을 전환합니다.

00:07:00.000 --> 00:07:07.000
마찬가지로, 나는 뷰의 규모와 전경 스타일을 결정하기 위해 두 개의 추가 계산 속성을 추가했다.

00:07:07.000 --> 00:07:13.000
나는 여기서 구현을 보여주지 않을 것이지만, 그들은 수직 오프셋 속성과 마찬가지로 스위치 문도 사용한다.

00:07:13.000 --> 00:07:17.000
이제, 우리의 관점으로 돌아가서 애니메이션을 추가합시다.

00:07:17.000 --> 00:07:22.000
우리는 phaseAnimator 수정자를 추가하지만, 이번에는 "트리거" 값을 부여합니다.

00:07:22.000 --> 00:07:28.000
우리가 위상 애니메이터 수정자에게 트리거 값을 줄 때, 그것은 당신이 변경을 위해 지정한 값을 관찰합니다.

00:07:28.000 --> 00:07:33.000
그리고 변화가 발생하면, 당신이 지정한 단계를 통해 애니메이션이 시작됩니다.

00:07:33.000 --> 00:07:38.000
위상 유형에서 정의한 계산된 속성을 사용하여 뷰에 수정자를 적용합니다.

00:07:38.000 --> 00:07:41.000
그리고 이 애니메이션은 기술적으로 옳은 일을 하지만, 기분이 좋지 않다.

00:07:41.000 --> 00:07:43.000
그건 좀 부진해.

00:07:43.000 --> 00:07:50.000
우리는 몇 가지 다른 봄 애니메이션을 포함하여 우리가 원하는 효과를 얻기 위해 각 전환에 대한 애니메이션을 사용자 정의할 것입니다.

00:07:50.000 --> 00:07:52.000
그리고 이게 훨씬 더 좋아 보여!

00:07:52.000 --> 00:07:56.000
하지만 우리가 이 애니메이션을 더 발전시키고 싶다면 어떨까요?

00:07:56.000 --> 00:08:08.000
누군가가 트레일에서 50마일 또는 100마일을 마쳤을 때, 우리는 그들이 마땅히 받아야 할 칭찬을 받을 때 그 모든 마일이 그만한 가치가 있다는 것을 의심의 여지가 없는 애니메이션을 주고 싶습니다.

00:08:08.000 --> 00:08:13.000
더 많은 제어가 필요할 때, 또 다른 강력한 도구가 있습니다: 키프레임.

00:08:13.000 --> 00:08:21.000
다음으로, 키프레임을 사용하여 타이밍과 움직임을 완벽하게 제어할 수 있는 복잡하고 조정된 애니메이션을 정의하는 방법을 보여드리겠습니다.

00:08:21.000 --> 00:08:26.000
먼저, 키프레임이 우리가 지금까지 사용한 단계와 어떻게 다른지에 대해 이야기해 봅시다.

00:08:26.000 --> 00:08:30.000
단계는 한 번에 하나씩 당신의 시야에 제공되는 개별 상태를 정의합니다.

00:08:30.000 --> 00:08:41.000
그리고 SwiftUI는 당신이 이미 알고 있는 것과 동일한 애니메이션 유형을 사용하여 그 상태들 사이에서 애니메이션을 작동하며, 이것은 이산 상태로 모델링할 수 있는 애니메이션에 정말 잘 작동합니다.

00:08:41.000 --> 00:08:46.000
상태 전환이 발생하면, 모든 속성이 동시에 애니메이션화됩니다.

00:08:46.000 --> 00:08:50.000
그리고 나서, 그 애니메이션이 끝나면, SwiftUI는 다음 상태로 애니메이션을 만든다.

00:08:50.000 --> 00:08:54.000
그리고 이것은 애니메이션의 모든 단계에서 계속된다.

00:08:54.000 --> 00:08:57.000
하지만 우리가 각 속성을 독립적으로 애니메이션화하고 싶다면 어떨까요?

00:08:57.000 --> 00:09:00.000
그곳이 키프레임이 들어오는 곳이다.

00:09:00.000 --> 00:09:04.000
키프레임을 사용하면 애니메이션 내의 특정 시간에 값을 정의할 수 있습니다.

00:09:04.000 --> 00:09:08.000
증명하기 위해, 나는 회전 효과부터 시작하여 이 보기를 애니메이션화할 것이다.

00:09:08.000 --> 00:09:14.000
여기에 있는 점들은 키프레임을 나타냅니다: 애니메이션 중 각 지점에서 사용할 각도.

00:09:14.000 --> 00:09:23.000
애니메이션이 재생되면, SwiftUI는 이러한 키프레임 사이에 값을 보간하여 뷰에 수정자를 적용하는 데 사용할 수 있습니다.

00:09:23.000 --> 00:09:31.000
그리고 키프레임을 사용하면 각각 고유한 타이밍을 가진 별도의 트랙을 정의하여 동시에 여러 효과를 독립적으로 애니메이션화할 수 있습니다.

00:09:31.000 --> 00:09:36.000
키프레임을 사용하여 SwiftUI에서 수정자를 구동할 수 있기 때문에 이것은 정말 강력합니다.

00:09:36.000 --> 00:09:43.000
이 예에서, 우리는 수직 스트레치, 스케일 및 번역을 포함한 여러 다른 트랙을 구동하기 위해 키프레임을 사용하고 있습니다.

00:09:43.000 --> 00:09:47.000
우리의 관점으로 돌아가서 이것이 코드에서 어떻게 생겼는지 봅시다.

00:09:47.000 --> 00:09:55.000
나는 이미 내가 만들고 싶은 애니메이션에 대한 아이디어를 가지고 있으므로, 나의 첫 번째 단계는 애니메이션을 구동할 속성을 정의하는 것이다.

00:09:55.000 --> 00:10:02.000
이를 위해, 나는 독립적으로 애니메이션될 모든 다른 속성을 포함하는 새로운 구조체를 만들 것이다.

00:10:02.000 --> 00:10:06.000
키프레임은 "애니메이터블" 프로토콜을 준수하는 모든 값을 애니메이션화할 수 있다.

00:10:06.000 --> 00:10:11.000
몇몇 속성이 이제 "애니메이터블"을 준수하는 "더블"을 사용한다는 것을 주목하세요.

00:10:11.000 --> 00:10:19.000
별도의 이산 상태를 모델링하는 단계와 달리, 키프레임은 지정한 유형의 보간 값을 생성합니다.

00:10:19.000 --> 00:10:27.000
애니메이션이 진행되는 동안, SwiftUI는 뷰를 업데이트할 수 있도록 모든 프레임에 이 유형의 값을 제공합니다.

00:10:27.000 --> 00:10:30.000
다음으로, 우리는 키프레임애니메이터 수정자를 추가합니다.

00:10:30.000 --> 00:10:37.000
이 수정자는 우리가 이전에 사용한 위상 애니메이터와 비슷하지만, 키프레임을 받아들인다.

00:10:37.000 --> 00:10:42.000
우리가 초기 값으로 사용할 구조체의 인스턴스를 제공한다는 것을 주목하세요.

00:10:42.000 --> 00:10:47.000
우리가 정의한 키프레임은 이 값에 애니메이션을 적용할 것이다.

00:10:47.000 --> 00:10:52.000
다음으로, 우리는 구조체의 각 속성에 대한 뷰에 수정자를 적용할 것입니다.

00:10:52.000 --> 00:10:55.000
그리고 마지막으로, 우리는 키프레임을 정의하기 시작할 것이다.

00:10:55.000 --> 00:11:01.000
내가 언급했듯이, 키프레임을 사용하면 다른 속성에 대해 다른 키프레임으로 정교한 애니메이션을 만들 수 있습니다.

00:11:01.000 --> 00:11:05.000
이것을 가능하게 하기 위해, 키프레임은 트랙으로 구성되어 있다.

00:11:05.000 --> 00:11:12.000
각 트랙은 애니메이션 중인 유형의 다른 속성을 제어하며, 이는 트랙을 만들 때 제공하는 키 경로로 지정됩니다.

00:11:12.000 --> 00:11:17.000
여기서, 우리는 스케일 속성에 대한 키프레임을 추가하고 있습니다.

00:11:17.000 --> 00:11:23.000
우리는 먼저 선형 키프레임을 추가하고, 초기 스케일 값을 반복하고 0.36초 동안 유지합니다.

00:11:23.000 --> 00:11:33.000
그리고 내가 어떻게 0.36에 정착했는지 궁금하다면, 나는 애니메이션의 느낌을 바꾸기 위해 다른 값을 시도함으로써 그 기간을 찾았고, 그것은 키프레임에 대한 중요한 포인트이다.

00:11:33.000 --> 00:11:37.000
앱에 맞는 애니메이션을 만드는 것은 약간의 실험이 필요할 수 있습니다.

00:11:37.000 --> 00:11:41.000
Xcode의 미리보기는 애니메이션을 미세 조정할 수 있는 좋은 방법이 될 수 있습니다.

00:11:41.000 --> 00:11:44.000
다음으로, 우리는 "SpringKeyframe"을 추가합니다.

00:11:44.000 --> 00:11:48.000
이것은 스프링 함수를 사용하여 목표를 향해 값을 당깁니다.

00:11:48.000 --> 00:11:50.000
그리고 우리는 기간을 지정했습니다.

00:11:50.000 --> 00:11:56.000
설정된 기간을 가진 스프링 키프레임의 경우, 이것은 스프링 함수가 그 기간 동안의 값만 애니메이션화한다는 것을 의미합니다.

00:11:56.000 --> 00:12:00.000
그 후, 보간은 다음 키프레임으로 시작될 것이다.

00:12:00.000 --> 00:12:06.000
마지막으로, 나는 스케일을 1.0으로 되돌리는 또 다른 스프링 키프레임을 추가할 것이다.

00:12:06.000 --> 00:12:10.000
다양한 종류의 키프레임은 값이 보간되는 방식을 제어한다.

00:12:10.000 --> 00:12:14.000
좋아, 우리는 LinearKeyframe과 SpringKeyframe을 봤어.

00:12:14.000 --> 00:12:17.000
실제로 네 가지 유형의 키프레임이 있다.

00:12:17.000 --> 00:12:25.000
나는 그들이 어떻게 다른지 설명할 것이다: 리니어키프레임은 이전 키프레임에서 벡터 공간에서 선형적으로 보간한다.

00:12:25.000 --> 00:12:33.000
스프링키프레임은 이름에서 알 수 있듯이 스프링 함수를 사용하여 이전 키프레임의 목표 값으로 보간합니다.

00:12:33.000 --> 00:12:39.000
큐빅키프레임은 큐빅 베지어 곡선을 사용하여 키프레임 사이를 보간한다.

00:12:39.000 --> 00:12:46.000
여러 입방 키프레임을 순서대로 결합하면, 결과 곡선은 Catmull-Rom 스플라인과 동일합니다.

00:12:46.000 --> 00:12:52.000
그리고 마지막으로, MoveKeyframe은 보간 없이 즉시 값으로 점프한다.

00:12:52.000 --> 00:12:59.000
각 종류의 키프레임은 완전한 제어를 제공하기 위해 사용자 지정을 지원하며, 애니메이션 내에서 다양한 종류의 키프레임을 믹스 앤 매치할 수 있습니다.

00:12:59.000 --> 00:13:06.000
SwiftUI는 애니메이션이 계속 유지되도록 키프레임 사이의 속도를 유지합니다.

00:13:06.000 --> 00:13:12.000
우리의 관점으로 돌아가서, 우리는 다음 트랙을 추가할 준비가 되었습니다.

00:13:12.000 --> 00:13:17.000
여기서, 우리는 수직 번역을 애니메이션화하기 위해 선형 및 스프링 키프레임을 사용했습니다.

00:13:17.000 --> 00:13:21.000
전망이 뛰어오르기 직전에, 그것은 기대감으로 뒤로 당겨진다.

00:13:21.000 --> 00:13:26.000
우리는 그것이 위로 이동하기 전에 시야를 잠시 끌어내리는 스프링 키프레임으로 그것을 모델링했다.

00:13:26.000 --> 00:13:32.000
이것은 좋아 보이지만, 우리는 여전히 애니메이션화할 두 가지 속성이 더 있습니다: 수직 스트레칭과 회전.

00:13:32.000 --> 00:13:37.000
우리는 수직 스트레칭으로 시작할 것이며, 이를 위해 입방 키프레임을 사용할 것이다.

00:13:37.000 --> 00:13:45.000
다시 말하지만, 이것은 제대로 하기 위해 시행착오가 필요할 수 있지만, 키프레임을 사용하여 애니메이션을 모델링하는 다양한 방법을 실험하는 것을 주저하지 마세요.

00:13:45.000 --> 00:13:50.000
스쿼시와 스트레치는 이 애니메이션에 훨씬 더 많은 에너지를 준다.

00:13:50.000 --> 00:13:53.000
마지막으로, 우리는 또한 회전을 애니메이션화할 것이다.

00:13:53.000 --> 00:13:55.000
그리고 이건 멋져 보여.

00:13:55.000 --> 00:13:58.000
그리고 우리가 전에 본 그 곡선들?

00:13:58.000 --> 00:14:01.000
그것들은 우리가 방금 만든 애니메이션의 시각화이다.

00:14:01.000 --> 00:14:04.000
SwiftUI 수정자를 적용하기 위해 추가 트랙을 추가할 수 있습니다.

00:14:04.000 --> 00:14:07.000
나는 다양한 조합을 탐구하는 것을 매우 즐겼다.

00:14:07.000 --> 00:14:11.000
잠시 시간을 내어 키프레임 모델을 검토해 봅시다.

00:14:11.000 --> 00:14:13.000
키프레임은 미리 정의된 애니메이션이다.

00:14:13.000 --> 00:14:19.000
그것은 UI가 유동적이고 상호 작용해야 하는 상황에서 일반 SwiftUI 애니메이션을 대체하지 않는다는 것을 의미합니다.

00:14:19.000 --> 00:14:24.000
대신, 재생할 수 있는 비디오 클립과 같은 키프레임을 생각해 보세요.

00:14:24.000 --> 00:14:27.000
그들은 당신에게 많은 통제력을 주지만, 절충안이 있습니다.

00:14:27.000 --> 00:14:38.000
애니메이션이 어떻게 진행되어야 하는지 정확히 지정하기 때문에, 키프레임 애니메이션은 스프링이 할 수 있는 방식으로 우아하게 리타겟팅할 수 없으므로, 일반적으로 애니메이션 중간에 키프레임을 변경하지 않는 것이 가장 좋습니다.

00:14:38.000 --> 00:14:44.000
키프레임은 정의한 유형의 값을 애니메이션화한 다음 뷰에 수정자를 적용하는 데 사용합니다.

00:14:44.000 --> 00:14:49.000
단일 키프레임 트랙을 사용하여 단일 수정자 또는 다른 수정자의 조합을 구동할 수 있습니다.

00:14:49.000 --> 00:14:51.000
그건 너에게 달렸어.

00:14:51.000 --> 00:15:03.000
그리고 애니메이션은 당신이 정의한 값의 관점에서 발생하기 때문에, 업데이트는 모든 프레임에서 발생하므로, 키프레임 애니메이션을 뷰에 적용하는 동안 값비싼 작업을 수행하지 않아야 합니다.

00:15:03.000 --> 00:15:07.000
마지막으로, 키프레임으로 어떻게 더 많은 것을 할 수 있는지 보여드리겠습니다.

00:15:07.000 --> 00:15:12.000
내 앱에는 각 다리의 경로를 보여주는 경주 지도가 포함되어 있다.

00:15:12.000 --> 00:15:16.000
자동으로 확대하고 코스를 따르는 애니메이션을 추가하고 싶습니다.

00:15:16.000 --> 00:15:22.000
고맙게도, MapKit은 이제 키프레임을 사용하여 카메라를 움직일 수 있게 해준다.

00:15:22.000 --> 00:15:25.000
여기서, 저는 코스를 보여주기 위해 "지도" 보기를 사용하고 있습니다.

00:15:25.000 --> 00:15:31.000
내 견해는 이미 경주의 한 다리를 따라 모든 좌표를 포함하는 모델인 경로를 가지고 있다.

00:15:31.000 --> 00:15:36.000
우리의 투어를 만들기 위해, 우리는 주 재산과 그것을 바꿀 수 있는 버튼을 추가할 것이다.

00:15:36.000 --> 00:15:40.000
마지막으로, 우리는 새로운 "mapCameraKeyframeAnimator" 수정자를 사용합니다.

00:15:40.000 --> 00:15:47.000
우리는 이전 예제에서 하트 아이콘에 사용했던 것처럼 트리거 값을 부여한 다음 키프레임을 추가합니다.

00:15:47.000 --> 00:15:52.000
트리거 값이 바뀔 때마다, 지도는 이러한 키프레임을 사용하여 애니메이션을 만든다.

00:15:52.000 --> 00:15:57.000
키프레임의 최종 값은 애니메이션 끝에 사용되는 카메라 값을 결정합니다.

00:15:57.000 --> 00:16:02.000
마침내, 우리는 버튼을 눌렀고, 투어가 시작된다.

00:16:02.000 --> 00:16:09.000
사용자가 애니메이션을 하는 동안 제스처를 수행하면 애니메이션이 제거되고 사용자는 카메라를 완전히 제어할 수 있습니다.

00:16:09.000 --> 00:16:19.000
중앙 좌표, 방향 및 거리를 독립적으로 애니메이션화함으로써, 우리는 이 과정을 따라 부드럽게 애니메이션화한 다음 조감도를 위해 다시 축소할 수 있습니다.

00:16:19.000 --> 00:16:26.000
마지막으로, 저는 당신이 생각할 수 있는 모든 종류의 효과를 유도하기 위해 키프레임을 수동으로 평가할 수 있는 방법을 보여주고 싶습니다.

00:16:26.000 --> 00:16:29.000
우리는 "keyframeAnimator" 수정자를 보았다.

00:16:29.000 --> 00:16:35.000
수정자 밖에서, "KeyframeTimeline" 유형을 사용하여 키프레임과 트랙 세트를 캡처할 수 있습니다.

00:16:35.000 --> 00:16:43.000
이 유형을 초기 값과 보기 수정자와 마찬가지로 애니메이션을 정의하는 키프레임 트랙으로 초기화합니다.

00:16:43.000 --> 00:16:50.000
KeyframeTimeline은 가장 긴 트랙의 지속 시간과 동일한 지속 시간을 제공하는 API를 제공합니다.

00:16:50.000 --> 00:16:55.000
그리고 애니메이션 범위 내에서 언제든지 값을 계산할 수 있습니다.

00:16:55.000 --> 00:17:02.000
이것은 내가 이전에 보여준 곡선 시각화에 사용한 스위프트 차트로 키프레임을 쉽게 시각화할 수 있게 해준다.

00:17:02.000 --> 00:17:19.000
이것은 또한 키프레임 정의 곡선을 원하는 대로 사용하거나, 키프레임을 다른 API와 창의적으로 결합할 수 있다는 것을 의미합니다. 예를 들어, 지오메트리 프록시를 사용하여 스크롤 위치를 사용하여 키프레임 기반 효과를 제거하거나, "TimelineView"를 사용하여 시간에 따라 업데이트할 수 있습니다.

00:17:19.000 --> 00:17:26.000
그리고 당신이 이것을 언제 사용할지 확실하지 않다면, 괜찮습니다, 그것은 고급 도구이며, 대부분의 개발자들은 보기 수정자를 고수하고 싶어할 것입니다.

00:17:26.000 --> 00:17:33.000
하지만 그것은 빌딩 블록으로 여기에 있으며, 앱에 통합하기 위해 어떤 창의적인 방법을 찾을 수 있는지 보게 되어 기쁩니다.

00:17:33.000 --> 00:17:35.000
그것은 우리의 여행을 완성한다.

00:17:35.000 --> 00:17:38.000
이 새로운 API 제품군을 사용하게 되어 기쁘기를 바랍니다.

00:17:38.000 --> 00:17:42.000
기억하세요: 연결된 애니메이션에 단계를 사용하세요.

00:17:42.000 --> 00:17:48.000
그들은 당신이 이미 알고 있는 모든 기존 애니메이션 유형을 사용하므로, 빠르게 시작하고 실행할 수 있습니다.

00:17:48.000 --> 00:17:53.000
완전한 제어가 필요한 더 복잡한 애니메이션을 위해 키프레임을 사용하세요.

00:17:53.000 --> 00:17:56.000
그리고 마지막으로: 탐험을 즐기세요.

00:17:56.000 --> 00:18:02.000
애니메이션의 세계는 흥미진진하며, 이 새로운 도구가 당신과 당신의 앱을 새로운 곳으로 이끌기를 바랍니다.

00:18:02.000 --> 00:18:04.000
고마워!

00:18:04.000 --> 23:59:59.000
♪ ♪

