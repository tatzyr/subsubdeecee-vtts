WEBVTT

00:00:01.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:18.000
Robert: 안녕하세요, 제 이름은 Robert Kendall-Kuppe이고 오늘은 우리가 "환경 제약"이라고 부르는 새로운 macOS 기능에 대해 이야기할 것입니다.

00:00:18.000 --> 00:00:22.000
기능이 풍부한 Mac 앱은 종종 하나의 프로세스나 파일 이상입니다.

00:00:22.000 --> 00:00:30.000
프레임워크와 라이브러리를 사용하면 앱 전체 또는 다른 개발자의 코드를 재사용할 수 있습니다.

00:00:30.000 --> 00:00:36.000
도우미 도구, 도우미 앱 및 XPC 서비스를 사용하면 공격을 줄이기 위해 작업을 분할할 수 있습니다.

00:00:36.000 --> 00:00:42.000
에이전트 실행, 실행 데몬 및 로그인 항목을 사용하면 백그라운드 또는 사용자 로그인에서 작업을 수행할 수 있습니다.

00:00:42.000 --> 00:00:48.000
그리고 앱 확장 프로그램을 사용하면 다른 앱에서 유용한 기능을 제공할 수 있습니다.

00:00:48.000 --> 00:00:51.000
하지만 당신의 앱은 잠재적으로 적대적인 환경에서 실행됩니다.

00:00:51.000 --> 00:00:58.000
앱 아키텍트들은 소프트웨어와 함께 실행되거나 프레임워크를 사용하는 알려지지 않은 소프트웨어의 잠재적인 영향을 고려해야 한다.

00:00:58.000 --> 00:01:04.000
도우미 도구나 XPC 서비스의 실행으로 공격자가 키체인 데이터에 접근할 수 있나요?

00:01:04.000 --> 00:01:07.000
iCloud 데이터나 다른 특권은 어떤가요?

00:01:07.000 --> 00:01:12.000
예상치 못한 코드가 프로세스에 주입되면 어떻게 될까요?

00:01:12.000 --> 00:01:20.000
실제 부모-자녀 관계와 마찬가지로, 부모 과정은 자녀가 어떻게 행동하는지에 엄청난 영향을 미친다.

00:01:20.000 --> 00:01:27.000
macOS에서, 다른 프로세스를 posix_spawn하는 힘은 부모에게 자식에 대한 거의 모든 입력을 제어할 수 있는 기능을 제공한다.

00:01:27.000 --> 00:01:32.000
부모 프로세스는 또한 시스템 자원에 대한 자녀의 접근을 제한할 수 있다.

00:01:32.000 --> 00:01:42.000
이 수준의 제어는 아이가 예상치 못한 코드를 로드하거나, 예상치 못한 기능을 실행하거나, 프로세스를 공격에 더 취약하게 만드는 방식으로 행동하게 할 수 있다.

00:01:42.000 --> 00:01:48.000
하지만, 부모-자식 관계 외에도, 프로세스는 그들이 생성되는 디스크 레이아웃을 신뢰한다.

00:01:48.000 --> 00:02:05.000
디스크의 파일을 수정할 수 있는 악성 프로세스는 피해자 프로세스에 예상치 못한 데이터를 공급하거나, 피해자 프로세스에서 런타임 보호를 제거하거나, 시스템에서 지속적인 실행을 얻거나, 프로세스의 권한을 훔칠 수 있습니다.

00:02:05.000 --> 00:02:09.000
이러한 모든 위협에 직면하여, macOS는 앱을 보호할 수 있는 도구를 제공합니다.

00:02:09.000 --> 00:02:14.000
특히, 앱이 손상된 경우 영향을 제한하기 위해 앱 샌드박스를 채택할 수 있습니다.

00:02:14.000 --> 00:02:20.000
그리고 런타임에 프로세스의 무결성을 보호하기 위해 강화된 런타임과 라이브러리 유효성 검사를 채택할 수 있습니다.

00:02:20.000 --> 00:02:26.000
게이트키퍼와 공증은 또한 고객 시스템에 알려진 악성 코드가 없는 상태로 유지하는 데 도움을 준다.

00:02:26.000 --> 00:02:34.000
내가 전에 언급한 위협에 대해 생각하면서, 우리는 기존의 보호가 실행 환경이 아닌 실행 프로세스에 초점을 맞추고 있다는 것을 깨달았다.

00:02:34.000 --> 00:02:38.000
그것이 우리가 환경 제약을 도입하는 이유이다.

00:02:38.000 --> 00:02:48.000
환경 제약은 프로세스가 실행될 수 있는 상황과 프로세스에서 코드를 혼합할 수 있는 방법에 대한 새로운 수준의 제어를 제공합니다.

00:02:48.000 --> 00:03:02.000
이 이야기의 나머지 부분에서, 우리는 환경 제약이 macOS의 보안 아키텍처에 어떻게 맞는지, 환경 제약이 어떻게 구조화되는지, 그리고 앱에서 환경 제약을 어떻게 채택할 수 있는지에 대해 논의할 것입니다.

00:03:02.000 --> 00:03:07.000
잠시 뒤로 물러서서 macOS 보안 스택에 대해 이야기해 봅시다.

00:03:07.000 --> 00:03:19.000
기본적으로 macOS는 이러한 모든 기술을 활용하여 부팅 체인을 보호하고, OS의 무결성을 보장하며, 권한 분리를 시행하고, 악성 소프트웨어로부터 사용자를 보호합니다.

00:03:19.000 --> 00:03:25.000
macOS Ventura에서, 우리는 운영 체제 프로세스 간의 관계를 더 잘 보호하기 위해 환경 제약을 사용하기 시작했습니다.

00:03:25.000 --> 00:03:28.000
그들은 OS에 새로운 차원의 보안을 제공한다.

00:03:28.000 --> 00:03:35.000
macOS 소노마에서, 우리는 환경 제약의 사용을 확장하고 앱에서 사용할 수 있도록 열었습니다.

00:03:35.000 --> 00:03:38.000
그래서 환경 제약은 무엇인가요?

00:03:38.000 --> 00:03:47.000
기본적으로, 그것들은 코드가 무엇인지뿐만 아니라 코드가 시스템에서 어떻게 존재하고 실행될 것으로 예상되는지 코드를 설명하는 방법이다.

00:03:47.000 --> 00:03:50.000
macOS에서, 우리는 다양한 목적으로 환경 제약을 사용합니다.

00:03:50.000 --> 00:04:00.000
예를 들어, 프로세스가 신뢰할 수 있는 번들 리소스를 사용하는지 확인하기 위해, 우리는 서명된 시스템 볼륨에서 OS 프로세스를 실행해야 합니다.

00:04:00.000 --> 00:04:10.000
권한 있는 데몬이 예상치 못한 인수나 마하 포트로 실행되지 않도록 하기 위해, 우리는 시스템 데몬이 보호된 launchd.plist를 기반으로만 실행되어야 합니다.

00:04:10.000 --> 00:04:23.000
시스템 앱의 공격 표면을 줄이기 위해 Launch Services에서 애플리케이션으로 실행해야 하며 백그라운드 항목에 대한 사용자 승인에 치아가 있는지 확인하기 위해 환경 제약을 사용하여 변경 사항을 감지합니다.

00:04:23.000 --> 00:04:28.000
이제 네가 묻고 있을지도 몰라. "내 앱이 환경 제약을 채택해야 하나요?"

00:04:28.000 --> 00:04:34.000
나는 환경 제약이 완전히 선택 사항이라는 것을 강조하고 싶지만, 모든 앱의 공격 표면을 줄일 수 있다.

00:04:34.000 --> 00:04:38.000
우리는 이 이야기의 뒷부분에서 좀 더 구체적인 예시 사용 사례에 대해 논의할 것이다.

00:04:38.000 --> 00:04:49.000
하지만 앱에 여러 프로세스가 있거나 다른 개발자 팀이 서명한 코드를 로드하는 경우 환경 제약이 특히 유용할 수 있습니다.

00:04:49.000 --> 00:04:54.000
몇 가지 다른 유형의 환경 제약이 있으므로, 먼저 출시 제약에 대해 이야기해 봅시다.

00:04:54.000 --> 00:05:07.000
실행 제약은 특정 바이너리에 내장되어 있으며 해당 프로세스의 속성, 부모가 될 수 있는 프로세스의 속성 또는 이를 책임질 수 있는 프로세스의 속성을 정의합니다.

00:05:07.000 --> 00:05:14.000
우리는 이러한 속성을 "자기 제약", "부모 프로세스 제약" 및 "책임 있는 프로세스 제약"이라고 부를 것입니다.

00:05:14.000 --> 00:05:18.000
세 가지 모두를 바이너리에 적용하거나 가장 합리적인 것을 선택할 수 있습니다.

00:05:18.000 --> 00:05:26.000
필요한 속성이 충족되지 않으면 실행 제약이 포함된 프로세스가 실행되지 않습니다.

00:05:26.000 --> 00:05:32.000
이제 몇 가지 프로세스 관계를 살펴보고 출시 제약을 사용하여 보호할 수 있는 방법에 대해 이야기해 봅시다.

00:05:32.000 --> 00:05:35.000
먼저 MyDemo.app이 당신의 앱이라고 가정하세요.

00:05:35.000 --> 00:05:41.000
MyDemo.app에서 자체 제약 조건을 설정하여 Launch Services에서 애플리케이션으로 실행하도록 요구할 수 있습니다.

00:05:41.000 --> 00:05:54.000
앱이 XPC 서비스에 대한 연결을 요청할 때, launchd는 XPC 서비스를 생성하고 해당 XPC 서비스의 부모이지만 앱은 해당 XPC 서비스에 대한 "책임"입니다.

00:05:54.000 --> 00:06:04.000
MyXPCDemo.xpc에 책임 있는 프로세스 제약을 설정하여 MyDemo.app만이 책임을 져야 한다는 것을 나타낼 수 있습니다.

00:06:04.000 --> 00:06:13.000
앱이 나중에 NSTask 또는 posix_spawn을 사용하여 도우미를 실행한다면, 그것은 그 도우미의 부모이자 책임입니다.

00:06:13.000 --> 00:06:21.000
MyDemo.app만 부모가 될 수 있도록 MyFirstHelper에서 부모 프로세스 제약 조건을 설정할 수 있습니다.

00:06:21.000 --> 00:06:32.000
그런 다음 첫 번째 도우미 posix_spawns가 두 번째 도우미를 낳는 경우, 첫 번째 도우미는 두 번째 도우미의 부모이지만, 앱은 두 번째 도우미를 담당합니다.

00:06:32.000 --> 00:06:45.000
MySecondHelper의 경우, MyFirstHelper에 의해서만 시작되도록 부모 프로세스 제약 조건을 설정할 수 있으며 MyDemo.app만이 책임을 지도록 책임 있는 프로세스 제약 조건을 설정할 수 있습니다.

00:06:45.000 --> 00:06:51.000
또한 실행 에이전트와 실행 데몬을 위한 launchd plists에서 환경 제약을 지정할 수 있습니다.

00:06:51.000 --> 00:07:01.000
SMAppService API를 사용하여 plist를 등록할 때, OS는 plist를 대신하여 제약 조건을 충족하는 프로세스만 시작되도록 시행합니다.

00:07:01.000 --> 00:07:11.000
이 기능은 앱의 백그라운드 활동에 대한 사용자 승인을 기반으로 악성 코드가 지속적인 실행을 얻지 않도록 하는 데 유용합니다.

00:07:11.000 --> 00:07:17.000
마지막으로, 라이브러리 로드 제약을 사용하여 주소 공간에 로드할 수 있는 코드를 구체적으로 제어할 수 있습니다.

00:07:17.000 --> 00:07:21.000
라이브러리 로드 제약 이전에, 라이브러리 유효성 검사를 채택하거나 채택하지 않을 수 있습니다.

00:07:21.000 --> 00:07:28.000
라이브러리 유효성 검사를 통해 프로세스가 서명한 코드 또는 Apple이 서명한 코드를 로드할 수 있습니다.

00:07:28.000 --> 00:07:38.000
라이브러리 로드 제약을 사용하면 임의 코드가 프로세스에 로드되는 것을 방지하면서 라이브러리 유효성 검사가 허용하는 것보다 덜 제한적인 코드 세트를 설명할 수 있습니다.

00:07:38.000 --> 00:07:48.000
하지만 Apple 서명 코드가 프로세스에서 로드되는 것을 배제할 수 없으며 자신의 코드를 허용하려면 하나 이상의 속성을 지정해야 합니다.

00:07:48.000 --> 00:07:55.000
이제 환경 제약이 무엇이고 어떻게 사용될 수 있는지 알았으니, 어떻게 정의되는지 논의해 봅시다.

00:07:55.000 --> 00:07:59.000
환경 제약은 코드가 충족해야 하는 일련의 조건을 설명한다.

00:07:59.000 --> 00:08:09.000
그것들은 키가 코드에 대해 사실이어야 하는 사실이나 사실이나 술어 간의 필요한 관계를 나타내는 연산자를 나타내는 사전으로 인코딩됩니다.

00:08:09.000 --> 00:08:17.000
최상위 수준에서, 암시적으로, 각 키-값 쌍의 결과는 제약이 충족되는지 여부를 결정하기 위해 함께 AND된다.

00:08:17.000 --> 00:08:23.000
이것들은 사전이기 때문에, 각 키는 사전 수준당 한 번만 나타날 수 있습니다.

00:08:23.000 --> 00:08:26.000
당신이 사용하고 싶은 몇 가지 사실을 살펴봅시다.

00:08:26.000 --> 00:08:31.000
왼쪽에는 관련 환경 제약 키가 있고 오른쪽에는 공동 설계 명령에서 출력됩니다.

00:08:31.000 --> 00:08:40.000
서명 식별자 키를 사용하면 주어진 코드에 고유해야 하지만 해당 코드의 버전 간에 동일하게 유지되는 문자열을 지정할 수 있습니다.

00:08:40.000 --> 00:08:46.000
서명 식별자 키는 공동 디자인 출력의 식별자 필드를 나타냅니다.

00:08:46.000 --> 00:08:57.000
Cdhash 키를 사용하면 허용되어야 하는 코드에 대한 고유한 해시를 지정할 수 있으며, 팀 식별자 키를 사용하면 특정 개발 팀이 서명한 코드를 지정할 수 있습니다.

00:08:57.000 --> 00:09:08.000
사실은 코드의 특정 속성을 나타내지만, 연산자는 논리적으로 사실 집합을 결합하거나 사실에 대한 허용 가능한 값 집합을 정의하는 데 사용될 수 있다.

00:09:08.000 --> 00:09:17.000
예상대로, $and와 $or 연산자를 사용하면 결정된 후 논리적으로 결합될 술어의 사전을 지정할 수 있습니다.

00:09:17.000 --> 00:09:28.000
$and-array 및 $or-array 연산자는 AND 여러 $or 술어 또는 또는 여러 $ 및 술어를 원하는 경우 사전 중첩을 제한하기 위해 존재합니다.

00:09:28.000 --> 00:09:33.000
그리고 마지막으로, $in 연산자를 사용하면 사실을 만족시킬 값 배열을 지정할 수 있습니다.

00:09:33.000 --> 00:09:35.000
이 예시의 제약을 살펴봅시다.

00:09:35.000 --> 00:09:39.000
왼쪽에는 제약의 plist 표현이 있습니다.

00:09:39.000 --> 00:09:44.000
오른쪽에는 XML이 무엇을 의미하는지 보여주는 의사 코드가 있다.

00:09:44.000 --> 00:09:49.000
Plist의 최상위 레벨에는 하나의 키, $or-array가 있다.

00:09:49.000 --> 00:09:51.000
그 값은 세 개의 튜플 배열이다.

00:09:51.000 --> 00:10:10.000
각 튜플에는 해당 연산자가 적용될 연산자와 사전이 포함되어 있으므로, 이 제약 조건은 두 번째 팀 식별자로 서명된 팀 식별자 또는 라이브러리 B 또는 세 번째 팀 식별자로 서명된 라이브러리 C로 서명된 모든 코드를 허용합니다.

00:10:10.000 --> 00:10:16.000
첫 번째 튜플의 경우, 단일 요소이기 때문에, 우리는 $또는 연산자를 사용할 수도 있었다.

00:10:16.000 --> 00:10:21.000
이제 제약을 정의할 수 있으므로, 프로젝트에서 어떻게 채택할 수 있는지 살펴봅시다.

00:10:21.000 --> 00:10:34.000
이 논의의 목적을 위해, 출시 에이전트, 도우미 도구, XPC 서비스를 포함하는 프레임워크 및 다른 개발 팀이 서명한 라이브러리가 포함된 주요 앱을 고려하십시오.

00:10:34.000 --> 00:10:38.000
이제 환경 제약이 완화할 수 있는 몇 가지 잠재적인 문제를 고려해 봅시다.

00:10:38.000 --> 00:10:47.000
아마도 당신은 키체인 데이터에 대한 액세스나 iCloud 컨테이너에 대한 액세스와 같은 도우미 도구에 약간의 권한을 할당했을 것입니다.

00:10:47.000 --> 00:10:53.000
도우미 도구가 다른 것이 아닌 앱에서만 시작할 수 있도록 하고 싶을 수도 있습니다.

00:10:53.000 --> 00:11:00.000
도우미 도구에서 상위 프로세스 제약 조건을 설정하여 앱만 도우미 도구를 실행할 수 있도록 할 수 있습니다.

00:11:00.000 --> 00:11:08.000
이렇게 하려면, 팀 식별자와 메인 앱의 서명 식별자가 필요한 코드 요구 사항 plist 파일을 만드세요.

00:11:08.000 --> 00:11:15.000
그런 다음 "Contraint Parent Process Plist 실행" 설정에서 도우미 도구의 서명 구성에 제약 조건을 추가하십시오.

00:11:15.000 --> 00:11:18.000
좀 더 자세히 살펴보자.

00:11:18.000 --> 00:11:23.000
여기 제가 언급한 속성이 있는 Xcode의 데모 프로젝트가 있습니다.

00:11:23.000 --> 00:11:29.000
MyDemo.app은 주요 앱 대상이며 demohelper는 도우미 도구입니다.

00:11:29.000 --> 00:11:33.000
앱을 실행하자.

00:11:33.000 --> 00:11:42.000
이 버튼을 누르면, 앱은 도우미 도구를 생성한 다음, 도우미 도구는 몇 가지 작업을 하고 앱에 대한 응답을 제공합니다.

00:11:42.000 --> 00:11:52.000
터미널에서 데모헬퍼의 서명을 살펴봅시다.

00:11:52.000 --> 00:12:01.000
우리는 출시 제약이 설정되어 있지 않고 demohelper를 실행할 수 있다는 것을 알 수 있다.

00:12:01.000 --> 00:12:04.000
하지만 그것 좀 봐.

00:12:04.000 --> 00:12:09.000
--Cloud 인수로 demohelper를 실행하면, demohelper는 앱의 iCloud 데이터에 액세스할 수 있습니다.

00:12:09.000 --> 00:12:16.000
우리는 임의의 프로세스가 demohelper를 실행하고 iCloud 데이터를 변경할 수 있기를 원하지 않습니다.

00:12:16.000 --> 00:12:22.000
Xcode로 돌아가서 demohelper에 부모 제약을 설정합시다.

00:12:22.000 --> 00:12:30.000
여기에 메인 앱 MyDemo를 식별하기 위해 이미 채워진 제약 plist 파일이 있습니다.

00:12:30.000 --> 00:12:39.000
서명 구성에 제약 조건을 추가합시다.

00:12:39.000 --> 00:12:45.000
이제 앱을 다시 만들자.

00:12:45.000 --> 00:12:51.000
우리는 앱을 다시 시작할 수 있어...

00:12:51.000 --> 00:12:58.000
그리고 메인 앱은 여전히 도우미를 생성할 수 있다.

00:12:58.000 --> 00:13:00.000
하지만 우리가 터미널로 돌아갈 때...

00:13:00.000 --> 00:13:14.000
우리는 이제 demohelper가 출시 제약을 가지고 있다는 것을 알 수 있다...

00:13:14.000 --> 00:13:18.000
그리고 그것은 더 이상 터미널에서 운영될 수 없다.

00:13:18.000 --> 00:13:26.000
발사 제약 위반으로 인해 발사가 차단되면, 제약이 위반되었다는 것을 보여주는 충돌 보고서가 생성됩니다.

00:13:26.000 --> 00:13:36.000
이제 환경 제약이 완화할 수 있는 몇 가지 문제에 대해 더 이야기해 봅시다.

00:13:36.000 --> 00:13:42.000
XPC 서비스를 사용하여 다른 프로세스 간에 권한을 분리하는 것이 좋습니다.

00:13:42.000 --> 00:13:48.000
하지만 XPC 서비스를 구축할 때, 번들에서 해당 서비스를 추출하고 다른 코드에서 호출할 수 있습니다.

00:13:48.000 --> 00:13:57.000
XPC 서비스에 권한을 할당한 경우, 예상되는 프로세스만 해당 권한에 액세스할 수 있도록 해야 합니다.

00:13:57.000 --> 00:14:04.000
코드만 XPC 서비스에 액세스할 수 있도록 하는 한 가지 방법은 책임 있는 프로세스 실행 제약을 설정하는 것입니다.

00:14:04.000 --> 00:14:15.000
여기서 우리는 XPC 서비스에 액세스할 수 있어야 하는 번들의 각 프로세스에 대한 서명 식별자 목록과 함께 팀이 서명한 코드를 허용하는 실행 제약 plist를 보여줍니다.

00:14:15.000 --> 00:14:22.000
"Launch Constraint Responsible Process Plist" 설정에서 서명 구성에 제약 조건을 추가할 수 있습니다.

00:14:22.000 --> 00:14:24.000
고려해야 할 또 다른 문제.

00:14:24.000 --> 00:14:30.000
macOS Ventura부터 사용자는 앱을 대신하여 설치된 백그라운드 작업을 승인해야 합니다.

00:14:30.000 --> 00:14:34.000
이것은 사용자가 당신의 앱을 대신하여만 일이 일어날 것으로 기대한다는 것을 의미합니다.

00:14:34.000 --> 00:14:42.000
공격자가 plist가 실행할 것으로 예상되는 코드를 대체할 수 있다면, 공격자는 앱을 대신하여 지속적인 백그라운드 실행을 얻을 수 있습니다.

00:14:42.000 --> 00:14:51.000
등록된 plist가 원하는 코드를 실행하는 데만 사용할 수 있도록, SpawnConstraint 키를 사용하여 launchd plist 제약 조건을 설정할 수 있습니다.

00:14:51.000 --> 00:14:56.000
여기서 SpawnConstraint 키가 있는 완전한 launchd plist를 볼 수 있습니다.

00:14:56.000 --> 00:15:02.000
이 제약은 우리 팀과 DemoMenuBar 에이전트를 식별합니다.

00:15:02.000 --> 00:15:04.000
마지막으로, 도서관 로딩에 대해 이야기해 봅시다.

00:15:04.000 --> 00:15:16.000
수정 없이 다른 개발 팀의 라이브러리를 연결할 의무가 있다면, 강화된 런타임으로 앱을 공증 받으려면, 비활성화 라이브러리 검증 자격을 채택해야 합니다.

00:15:16.000 --> 00:15:23.000
불행히도, 그것은 당신의 앱이 이제 당신이 라이브러리를 받은 신뢰할 수 있는 개발자뿐만 아니라 누구나 서명한 코드를 로드할 수 있다는 것을 의미합니다.

00:15:23.000 --> 00:15:27.000
이 문제를 해결하기 위해, 라이브러리 로드 제약을 채택할 수 있습니다.

00:15:27.000 --> 00:15:33.000
여기서 우리는 당신의 팀이나 신뢰할 수 있는 도서관 공급자가 서명한 코드를 로드할 수 있는 제약을 보여줍니다.

00:15:33.000 --> 00:15:40.000
또한 하나 이상의 서명 식별자 사실을 사용하여 특정 라이브러리 또는 라이브러리 세트로 더 제한할 수 있습니다.

00:15:40.000 --> 00:15:51.000
실행 제약과 마찬가지로, 라이브러리 로드 제약은 Xcode 서명 구성에서 "라이브러리 로드 제약 Plist" 설정을 설정하면 프로세스에 로그인됩니다.

00:15:51.000 --> 00:15:53.000
그래서 환경 제약은 어디에서 이용할 수 있나요?

00:15:53.000 --> 00:15:59.000
라이브러리 로드 제약 조건과 실행된 plist 제약 조건은 모든 macOS 버전을 대상으로 하는 앱에 포함될 수 있습니다.

00:15:59.000 --> 00:16:02.000
그것들은 macOS Sonoma에서 시작해서 시행된다.

00:16:02.000 --> 00:16:10.000
macOS 13.3 이상을 대상으로 하는 앱에 실행 제약을 추가할 수 있으며 macOS 13.3부터 시행됩니다.

00:16:10.000 --> 00:16:17.000
환경 제약에서 사용할 수 있는 지원되는 키와 값 세트는 macOS 버전에 따라 변경될 수 있습니다.

00:16:17.000 --> 00:16:21.000
완전한 이용 가능 여부 정보는 문서를 참조하십시오.

00:16:21.000 --> 00:16:30.000
앱의 프로세스 관계, 실행된 plists 및 라이브러리를 살펴보고 환경 제약 조건을 사용하여 앱을 더 안전하게 만들 수 있는지 확인하십시오.

00:16:30.000 --> 00:16:32.000
봐줘서 고마워.

00:16:32.000 --> 23:59:59.000
♪ ♪

