WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:11.000
루베나: 안녕하세요 여러분!

00:00:11.000 --> 00:00:23.000
제 이름은 루베나이며, 코어 데이터 애플리케이션을 코어 데이터와 공존할 수 있는 스위프트 네이티브 지속성 프레임워크인 스위프트데이터로 마이그레이션하는 방법을 공유하게 되어 기쁩니다.

00:00:23.000 --> 00:00:38.000
Core Data에서 SwiftData로 완전히 전환할 준비가 되었는지 또는 SwiftData를 점진적으로 채택하고 Core Data와 공존하고 싶다면 Core Data 앱에 SwiftData를 채택하는 방법에 대한 일반적인 사용 사례를 다룰 것입니다.

00:00:38.000 --> 00:00:46.000
먼저 관리 객체 모델 편집기 어시스턴트를 사용하여 SwiftData 모델 클래스를 생성하는 방법을 살펴보겠습니다.

00:00:46.000 --> 00:00:52.000
그런 다음, 기존 Core Data 애플리케이션에 대한 완전한 SwiftData 채택의 흐름을 시연할 것입니다.

00:00:52.000 --> 00:01:05.000
그리고 마지막으로, SwiftData로의 완전한 전환이 사용 사례에 대한 실현 가능한 해결책이 아닐 수 있는 경우, Core Data와 SwiftData 간의 공존을 소개하겠습니다.

00:01:05.000 --> 00:01:09.000
먼저 모델 클래스를 생성할 수 있는 방법의 흐름을 살펴보겠습니다.

00:01:09.000 --> 00:01:14.000
SwiftData에서는 코드에서 모델을 사용하여 스키마를 설정하는 것으로 전환하고 있습니다.

00:01:14.000 --> 00:01:21.000
이를 수행하는 한 가지 쉬운 방법은 Core Data 관리 객체 모델을 사용하여 SwiftData 모델을 생성하는 것입니다.

00:01:21.000 --> 00:01:25.000
이 전환을 어떻게 하는지 보여드리겠습니다.

00:01:25.000 --> 00:01:32.000
저는 사용자가 다가오는 여행을 위한 일정을 계획하는 데 도움이 되는 SampleTrips라는 핵심 데이터 애플리케이션을 만들었습니다.

00:01:32.000 --> 00:01:38.000
여기 제 데이터와 조직에 대한 정보가 포함된 모델 파일이 있습니다.

00:01:38.000 --> 00:01:52.000
저는 각 여행이 원하는 여행 활동을 나타내는 하나의 해당 생활 숙박 및 버킷리스트 항목이 있도록 조직된 여행, LivingAccommodation 및 BucketListItem을 가지고 있습니다.

00:01:52.000 --> 00:01:57.000
여기서부터, 나는 이 같은 정보를 캡처하는 SwiftData 클래스를 생성할 것이다.

00:01:57.000 --> 00:02:15.000
코어 데이터 관리 객체 모델은 이러한 SwiftData 클래스를 만드는 데 필요하지 않지만, 기존 코어 데이터 모델이 있는 경우, 기존 모델에 이미 가지고 있는 조직을 기반으로 SwiftData 클래스를 생성하는 데 사용할 수 있으며, 이 사용 사례에 대해 시연할 것입니다.

00:02:15.000 --> 00:02:19.000
이를 위해, 저는 관리 객체 모델 편집기 어시스턴트를 살펴갑니다.

00:02:19.000 --> 00:02:30.000
모델 파일을 선택한 후, 메뉴 표시줄로 이동하여 편집기를 선택한 다음 SwiftData 코드 만들기를 클릭합니다.

00:02:30.000 --> 00:02:35.000
이제 나는 세 개의 기존 엔티티에 대한 파일을 생성할 수 있다.

00:02:35.000 --> 00:02:43.000
처음부터 SwiftData 모델을 만드는 것도 새로운 Swift 앱을 만드는 경우 옵션이며, 이 도우미가 필요하지 않습니다.

00:02:43.000 --> 00:02:46.000
여기 제가 방금 만든 파일들이 있습니다.

00:02:46.000 --> 00:03:04.000
스위프트 유형은 모델을 준수해야 하며, 각각은 트리프의 이름, 목적지, 시작 및 종료 날짜, 다른 엔티티, LivingAccommodation 및 BucketListItem과의 관계를 포함하여 엔티티에 대한 정보를 변수로 캡처합니다.

00:03:04.000 --> 00:03:09.000
이제, SwiftData의 완전한 채택 과정을 안내해드리겠습니다.

00:03:09.000 --> 00:03:20.000
애플리케이션을 SwiftData로 완전히 마이그레이션할 때, SwiftData로 Swift 네이티브 언어 기능을 활용하기 위해 Core Data 스택을 SwiftData 스택으로 교체할 수 있습니다.

00:03:20.000 --> 00:03:27.000
이를 통해 데이터를 유지할 수 있는 더 읽기 쉬운 코드뿐만 아니라 일부 기능을 암시적으로 관리할 수 있습니다.

00:03:27.000 --> 00:03:34.000
하지만 이 전환을 하기 전에, 기존 핵심 데이터 모델 설계가 어떻게 구성되어 있는지 고려해야 합니다.

00:03:34.000 --> 00:03:41.000
핵심 데이터 모델 설계는 엔티티와 그 속성 및 관계를 포함한 스키마를 참조합니다.

00:03:41.000 --> 00:03:47.000
핵심 데이터 모델 설계가 SwiftData에서도 지원되는지 확인해야 합니다.

00:03:47.000 --> 00:03:58.000
이것은 Core Data에 정의된 각 엔티티에 대해 SwiftData의 엔티티 이름과 속성과 정확히 일치하는 해당 모델 유형이 있어야 한다는 것을 의미합니다.

00:03:58.000 --> 00:04:04.000
모든 기능이 SwiftData에서 지원되는지 확인하기 위해 모델을 철저히 테스트해야 합니다.

00:04:04.000 --> 00:04:11.000
Core Data 앱의 완전한 SwiftData 채택 프로세스의 몇 가지 하이라이트를 더 자세히 다루겠습니다.

00:04:11.000 --> 00:04:15.000
나는 이전에 내 모델을 캡처하기 위해 이미 스위프트 유형을 생성했다.

00:04:15.000 --> 00:04:25.000
그 파일들이 준비되면, 이전에 사용되었던 코어 데이터 관리 객체 모델 파일을 삭제하고 대신 이 스위프트 파일을 통해 모델을 관리할 수 있습니다.

00:04:25.000 --> 00:04:32.000
또한, 이전에 코어 데이터 스택을 설정하는 데 도움이 된 지속성 파일을 삭제할 수 있습니다.

00:04:32.000 --> 00:04:37.000
이제 SwiftData 스택을 위한 modelContainer를 설정할 수 있습니다.

00:04:37.000 --> 00:04:44.000
modelContainer는 그룹의 모든 창이 동일한 영구 컨테이너에 액세스하도록 구성되도록 하는 수정자입니다.

00:04:44.000 --> 00:04:56.000
여기 TripsApp에 이 컨테이너를 추가함으로써, modelContainer가 환경에서 기본 ModelContext를 만들고 설정하기 때문에 컨테이너와 컨텍스트를 모두 설정하고 있습니다.

00:04:56.000 --> 00:05:01.000
ModelContext는 내 앱 유형의 인스턴스에 대한 변경 사항을 추적하는 데 사용됩니다.

00:05:01.000 --> 00:05:06.000
이 환경 속성을 사용하여 모든 장면이나 보기에서 읽을 수 있습니다.

00:05:06.000 --> 00:05:13.000
SampleTrips를 위한 내 SwiftData 영구 스택이 이제 설정되었지만, 몇 가지 변경 사항이 더 있습니다.

00:05:13.000 --> 00:05:17.000
나는 먼저 물체 창조가 어떻게 작동하는지 보여줄 것이다.

00:05:17.000 --> 00:05:22.000
이전에, 코어 데이터에서, 새로운 여행을 만드는 것은 이와 비슷한 것과 비슷할 것이다.

00:05:22.000 --> 00:05:30.000
나는 속성을 설정하기 전에 관리되는 객체 컨텍스트를 전달하는 Trip의 인스턴스를 만들 것이다.

00:05:30.000 --> 00:05:38.000
SwiftData에서, 나는 이미 비교적 더 읽기 쉬운 이 코드 줄로 트립의 새로운 인스턴스를 만들 수 있다.

00:05:38.000 --> 00:05:45.000
이 새로운 여행을 하면, 나는 그것이 지속되도록 하기 위해 그것을 모델 컨텍스트에 삽입한다.

00:05:45.000 --> 00:05:51.000
이제 내 여행이 지속되고 있기 때문에, 나는 그것을 어떻게 저장할 수 있는지, 그리고 내가 그것에 대한 미래의 변화를 살펴보고 싶다.

00:05:51.000 --> 00:06:00.000
SwiftData에는 가능한 경우 컨텍스트가 변경된 후 UI 수명 주기 이벤트와 타이머에 저장을 트리거하는 암시적 저장 기능이 있습니다.

00:06:00.000 --> 00:06:09.000
따라서 컨텍스트에서 호출되는 Core Data의 명시적 저장을 제거하고, 컨텍스트가 변경될 때 내 데이터를 유지하기 위해 암시적 저장에 의존할 수 있습니다.

00:06:09.000 --> 00:06:12.000
이제, 제 데이터를 어떻게 가져오는지 안내해 드리겠습니다.

00:06:12.000 --> 00:06:22.000
Core Data에서와 같은 가져오기 요청을 사용하는 대신, 쿼리를 사용하여 쿼리에서 여행 배열을 래핑하여 다가오는 여행의 전체 목록을 가져올 수 있습니다.

00:06:22.000 --> 00:06:26.000
이것은 내가 SwiftData 컨테이너에서 트립 객체를 가져올 수 있게 해준다.

00:06:26.000 --> 00:06:30.000
나는 또한 질의에 대한 정렬 순서를 정의하고 있다.

00:06:30.000 --> 00:06:37.000
나는 내 여행 시작 날짜에 따라 앞으로 순서대로 정렬하고 싶어, 다가오는 가장 가까운 여행이 맨 위에 있도록.

00:06:37.000 --> 00:06:42.000
쿼리는 술어와 사전을 포함해야 하는 사용 사례에도 사용될 수 있다.

00:06:42.000 --> 00:06:51.000
이제 Core Data 앱을 SwiftData로 완전히 마이그레이션하는 방법을 알았으니, Core Data와 SwiftData의 공존을 원하는 경우를 안내해드리겠습니다.

00:06:51.000 --> 00:06:59.000
전체 마이그레이션이 항상 실현 가능하거나 실용적이지 않을 수 있으며, 이 경우 SwiftData로의 부분 변환을 고려할 수 있습니다.

00:06:59.000 --> 00:07:08.000
공존은 두 개의 완전히 분리된 영구 스택, 하나의 코어 데이터 스택과 하나의 SwiftData 스택이 동일한 영구 저장소와 대화할 때이다.

00:07:08.000 --> 00:07:16.000
이것은 SwiftData 코드를 추가하기 위해 기존 핵심 데이터 코드를 완전히 다시 작성할 필요가 없다는 것을 의미합니다.

00:07:16.000 --> 00:07:31.000
이 옵션은 이미 Core Data에 일부 데이터가 있거나 SwiftData로 완전히 전환할 수 없는 다른 제약에 직면한 경우 SwiftData를 애플리케이션에 채택할 때 더 많은 유연성을 제공합니다.

00:07:31.000 --> 00:07:36.000
이것이 같은 가게와 대화하기 위해 두 스택을 모두 설정할 수 있는 방법입니다.

00:07:36.000 --> 00:07:46.000
영구 저장소를 로드하기 전에, 두 스택이 동일한 URL에 쓰도록 컨테이너 설명에 대한 영구 저장소 URL을 설정해야 합니다.

00:07:46.000 --> 00:07:50.000
또한, 지속적인 기록 추적을 켜야 합니다.

00:07:50.000 --> 00:07:55.000
SwiftData는 영구적인 기록 추적을 자동으로 켜지만, Core Data는 그렇지 않습니다.

00:07:55.000 --> 00:08:07.000
지속적인 기록을 설정하지 않고 Core Data와 SwiftData가 동일한 응용 프로그램에서 공존할 때 영구 저장소를 열려고 하면 저장소가 읽기 전용 모드로 전환됩니다.

00:08:07.000 --> 00:08:13.000
공존이 당신의 사용 사례에 가장 적합한 선택이라는 것을 알 수 있는 몇 가지 다른 시나리오가 있습니다.

00:08:13.000 --> 00:08:17.000
한 가지 시나리오는 기존 고객과의 역호환성을 허용하는 것이다.

00:08:17.000 --> 00:08:27.000
SwiftData는 iOS 17과 macOS Sonoma에서만 사용할 수 있기 때문에, 현재 Core Data 애플리케이션은 SwiftData로의 전체 전환에 의해 영향을 받을 수 있습니다.

00:08:27.000 --> 00:08:33.000
또는, SwiftData로의 완전한 전환을 어렵게 만드는 자원 제약에 직면할 수 있습니다.

00:08:33.000 --> 00:08:44.000
이러한 경우, SwiftData를 사용하여 새로운 개발을 수행하거나 애플리케이션의 일부만 SwiftData로 변환하여 SwiftData를 부분적으로 통합하는 것이 합리적일 것입니다.

00:08:44.000 --> 00:08:51.000
이 전환을 하기 전에 고려해야 할 핵심 데이터와 스위프트데이터 간의 공존을 위한 몇 가지 요구 사항이 있습니다.

00:08:51.000 --> 00:09:00.000
먼저, 기존 NSManagedObject 기반 엔티티 하위 클래스 또는 SwiftData 클래스가 충돌하지 않도록 네임스페이스여야 합니다.

00:09:00.000 --> 00:09:06.000
이것은 두 개의 클래스가 같은 것으로 불릴 수 없으며, 그 중 적어도 하나는 바뀌어야 한다는 것을 의미한다.

00:09:06.000 --> 00:09:12.000
클래스 이름을 변경하더라도 엔티티 이름은 동일하게 유지된다는 것을 명심하세요.

00:09:12.000 --> 00:09:20.000
예를 들어, 이번에는 Core Data와 SwiftData와 공존하고 싶다는 점을 제외하고는 이전과 같은 SampleTrips 프로젝트가 있습니다.

00:09:20.000 --> 00:09:22.000
두 학급 이름이 충돌한다.

00:09:22.000 --> 00:09:30.000
SwiftData와 Core Data 이름 Trip을 구별하기 위해, 대신 Core Data trip 클래스 이름을 CDTrip으로 변경했습니다.

00:09:30.000 --> 00:09:35.000
관리되는 객체 모델 편집기에서도 이것을 할 수 있습니다.

00:09:35.000 --> 00:09:47.000
또한, 핵심 데이터와 SwiftData 스키마를 동기화해야 합니다. SwiftData 스키마의 새로운 부분은 NSManagedObjectModel로 구체화되어야 하며, 두 스키마는 갈라질 수 없습니다.

00:09:47.000 --> 00:09:52.000
이것은 속성과 관계가 정확히 같은 방식으로 모델에 추가되어야 한다는 것을 의미한다.

00:09:52.000 --> 00:10:02.000
이것은 엔티티 버전 해쉬가 모든 단계와 일치하도록 하기 위한 것입니다. 일치하지 않는 해시는 잠재적으로 마이그레이션을 트리거하고 제거하고 싶지 않은 정보를 삭제할 수 있기 때문입니다.

00:10:02.000 --> 00:10:07.000
마지막으로, 공존을 통합할 때 스키마 버전을 추적해야 합니다.

00:10:07.000 --> 00:10:16.000
여러 버전의 SwiftData 모델로 작업할 때, SwiftData가 차이점을 평가할 수 있도록 변경 사항이 올바르게 표시되는지 확인해야 합니다.

00:10:16.000 --> 00:10:19.000
당신이 이것을 할 수 있는 몇 가지 방법이 있습니다.

00:10:19.000 --> 00:10:25.000
"SwiftData로 스키마 모델링" 대화를 확인하여 버전 스키마를 사용하는 방법을 이해하세요.

00:10:25.000 --> 00:10:32.000
UIKit 또는 AppKit에 의존하는 Swift 앱의 경우, SwiftData를 사용할 수 있는 실행 가능한 옵션이 있습니다.

00:10:32.000 --> 00:10:35.000
첫 번째 접근 방식은 공존 해결책이다.

00:10:35.000 --> 00:10:40.000
UIKit 코드를 Core Data에 바인딩할 수 있으며, SwiftData와 병렬로 작동할 수 있습니다.

00:10:40.000 --> 00:10:48.000
또는, SwiftData 클래스를 Swift 클래스로 취급하고, 대신 UIKit 코드로 Swift 코드를 래핑할 수 있습니다.

00:10:48.000 --> 00:10:49.000
그게 다 내 거야!

00:10:49.000 --> 00:10:56.000
이제 핵심 데이터 애플리케이션을 SwiftData로 완전히 또는 점진적으로 유연하게 마이그레이션할 수 있는 방법을 알아보세요.

00:10:56.000 --> 00:11:02.000
그 동안, 더 깊은 다이빙을 위해 SwiftData에 대한 다른 멋진 이야기를 확인해 보세요.

00:11:02.000 --> 00:11:06.000
나와 함께 해줘서 고마워! 네가 뭘 만들 건지 보게 되어 신나!

00:11:06.000 --> 23:59:59.000
♪ ♪

