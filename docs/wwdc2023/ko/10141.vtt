WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:11.000
이안: 안녕하세요, 여러분.

00:00:11.000 --> 00:00:14.000
저는 이안이고, 앱 스토어 서버 팀의 엔지니어입니다.

00:00:14.000 --> 00:00:23.000
오늘 저는 새로운 기능과 중요한 업데이트를 포함하여 인앱 구매를 위한 서버 API에 대한 흥미로운 업데이트를 공유하겠습니다.

00:00:23.000 --> 00:00:32.000
익숙하지 않다면, 서버에서 인앱 구매를 최대한 활용하는 데 도움이 되는 두 가지 기본 API를 제공합니다.

00:00:32.000 --> 00:00:35.000
첫 번째는 앱 스토어 서버 API이다.

00:00:35.000 --> 00:00:47.000
서버에서 주문형 App Store Server API를 호출하면 앱에서 이루어진 인앱 구매를 효과적으로 관리하는 데 필요한 모든 데이터를 반환합니다.

00:00:47.000 --> 00:00:57.000
API는 인앱 구매 데이터를 검색하고 수정하기 위한 다양한 강력한 엔드포인트를 제공합니다.

00:00:57.000 --> 00:01:03.000
우리가 제공하는 또 다른 주요 API는 App Store 서버 알림 V2입니다.

00:01:03.000 --> 00:01:14.000
App Store 서버 알림 V2를 사용하면, App Store 서버는 앱에서 이루어진 인앱 구매에 대한 업데이트를 서버에 사전에 보냅니다.

00:01:14.000 --> 00:01:22.000
즉, App Store Server API를 폴링할 필요 없이 분 단위로 업데이트를 받을 수 있습니다.

00:01:22.000 --> 00:01:33.000
알림은 구독 갱신, 만료, 환불 등을 포함한 포괄적인 일련의 이벤트를 다룹니다.

00:01:33.000 --> 00:01:43.000
이러한 이벤트를 통해 인앱 구매의 전체 수명 주기를 추적할 수 있으므로 사용자 행동을 더 잘 이해하고 대응할 수 있습니다.

00:01:43.000 --> 00:01:50.000
앱 스토어 서버 API와 앱 스토어 서버 알림 V2는 많은 훌륭한 기능을 공유합니다.

00:01:50.000 --> 00:02:00.000
그들은 둘 다 친숙한 JSON 형식으로 거래 데이터를 제공하며, 데이터는 서명되어 있으므로, 당신은 그것이 Apple에서 왔다고 확신할 수 있습니다.

00:02:00.000 --> 00:02:08.000
또한 두 API를 모두 사용하여 StoreKit 2 또는 원래 StoreKit API를 사용하는 앱을 지원할 수 있습니다.

00:02:08.000 --> 00:02:15.000
그리고 우리는 당신의 피드백을 바탕으로 새로운 기능으로 이러한 API를 적극적으로 지원합니다.

00:02:15.000 --> 00:02:26.000
오늘 저는 App Store Server API와 App Store Server Notifications V2에 대한 최신 업데이트 모음을 발표하게 되어 기쁩니다.

00:02:26.000 --> 00:02:32.000
우리는 새로운 기능이 너무 많아서, 나는 오늘 세션에서 몇 가지만 다룰 시간이 있다.

00:02:32.000 --> 00:02:38.000
이러한 모든 새로운 기능에 대한 자세한 내용은 개발자 문서를 확인하세요.

00:02:38.000 --> 00:02:43.000
이제 이 훌륭한 App Store 서버 업데이트에 대해 자세히 알아봅시다.

00:02:43.000 --> 00:02:46.000
나는 오늘의 업데이트를 세 부분으로 공유할 것이다.

00:02:46.000 --> 00:02:53.000
먼저, 서버에서 거래 작업을 더 쉽게 할 수 있는 몇 가지 새로운 기능을 자세히 설명하겠습니다.

00:02:53.000 --> 00:03:02.000
다음으로, 사용자의 구독 상태를 안정적으로 결정하는 데 도움이 되는 App Store 서버 알림의 개선 사항을 다루겠습니다.

00:03:02.000 --> 00:03:09.000
그리고 마지막으로, 저는 오래된 API에서 마이그레이션하는 것에 대한 중요한 업데이트를 제공할 것입니다.

00:03:09.000 --> 00:03:12.000
거래를 시작합시다.

00:03:12.000 --> 00:03:17.000
거래는 인앱 구매를 위한 핵심 데이터 객체이다.

00:03:17.000 --> 00:03:31.000
그것들은 장치의 인앱 구매를 나타내며 제품 식별자, 유형, 구매일 등과 같은 구매에 대한 중요한 정보를 포함합니다.

00:03:31.000 --> 00:03:38.000
App Store 서버는 JWS로 서명된 JSON 객체를 통한 거래를 나타냅니다.

00:03:38.000 --> 00:03:48.000
이것은 App Store Server API 및 App Store Server Notifications V2에서 볼 수 있는 안전하고 표준화된 형식입니다.

00:03:48.000 --> 00:03:59.000
이러한 서명된 거래를 검색하는 주요 방법은 App Store Server API의 Get Transaction History 엔드포인트를 사용하는 것입니다.

00:03:59.000 --> 00:04:11.000
이 엔드포인트는 앱의 특정 사용자에 대한 전체 거래 내역을 반환하므로 과거부터 현재까지 사용자의 모든 구매를 최신 상태로 유지하는 데 사용할 수 있습니다.

00:04:11.000 --> 00:04:19.000
하지만 때때로, 당신의 서버는 예를 들어 앱에서 서버로의 호출로 인해 이미 거래를 알고 있습니다.

00:04:19.000 --> 00:04:29.000
서버 측에서, 당신은 그 거래를 더 검증하고 그것에 대한 최신 정보를 가지고 있는지 확인하고 싶을 수도 있습니다.

00:04:29.000 --> 00:04:38.000
이전에, 이 사용 사례는 Get Transaction History를 호출하고 일치하는 거래에 대한 응답을 선별해야 했습니다.

00:04:38.000 --> 00:04:44.000
일단 발견되면, 응답의 데이터로 거래 기록을 새로 고칠 수 있습니다.

00:04:44.000 --> 00:04:54.000
이 과정은 특히 사용자의 거래 내역이 여러 페이지에 걸쳐 엔드포인트에 여러 번 호출해야 하는 경우 지루하게 느껴질 수 있습니다.

00:04:54.000 --> 00:05:03.000
그리고 완료된 소모품 거래를 찾고 있다면 거래 내역 가져오기 응답에 나타나지 않기 때문에 작동하지 않습니다.

00:05:03.000 --> 00:05:09.000
이 사용 사례는 단순히 더 구체적인 해결책을 요구한다.

00:05:09.000 --> 00:05:15.000
그래서 오늘, 우리는 이 사용 사례를 직접 다룰 새로운 엔드포인트를 소개합니다.

00:05:15.000 --> 00:05:28.000
새로운 Get Transaction Info 엔드포인트를 사용하면 단일 구매에 대해 서명된 거래 정보를 요청할 수 있으며, 제공하면 transactionId만 있으면 됩니다.

00:05:28.000 --> 00:05:36.000
제품 유형이나 사용자 장치의 거래 완료 상태에 관계없이 모든 transactionId가 지원됩니다.

00:05:36.000 --> 00:05:43.000
맞습니다, 이 엔드포인트에서 완성된 소모품을 가져올 수도 있습니다.

00:05:43.000 --> 00:05:47.000
새로운 엔드포인트가 어떻게 작동하는지 간단히 살펴봅시다.

00:05:47.000 --> 00:05:57.000
경로 매개 변수로 transactionId를 포함하여 App Store 서버의 이 새로운 엔드포인트에 GET 요청을 보낼 것입니다.

00:05:57.000 --> 00:06:03.000
당신은 signedTransactionInfo 문자열이 포함된 응답을 받게 될 것입니다.

00:06:03.000 --> 00:06:13.000
signedTransactionInfo를 디코딩하면, 요청에 제공한 ID에 대한 거래 정보를 볼 수 있습니다.

00:06:13.000 --> 00:06:14.000
그리고 그게 다야.

00:06:14.000 --> 00:06:22.000
새로운 Get Transaction Info 엔드포인트는 매우 간단하지만, 서버에서 거래로 작업할 때 더 큰 유연성을 제공합니다.

00:06:22.000 --> 00:06:26.000
저는 당신이 그것이 다양한 사용 사례에 유용하다는 것을 알게 될 것이라고 생각합니다.

00:06:26.000 --> 00:06:32.000
이제, 유연성이라는 주제를 가지고 그것을 더 확장해 봅시다.

00:06:32.000 --> 00:06:38.000
당신은 App Store Server API의 인기 있는 엔드포인트에 익숙할 것입니다.

00:06:38.000 --> 00:06:44.000
이러한 각 엔드포인트는 경로 매개 변수로 originalTransactionId가 필요합니다.

00:06:44.000 --> 00:06:51.000
이 ID는 당신이 데이터를 요청하거나 보내는 사용자를 서버에 나타냅니다.

00:06:51.000 --> 00:06:55.000
하지만 당신은 항상 원래의 거래 ID를 가지고 있지 않을 수도 있습니다.

00:06:55.000 --> 00:06:59.000
만약 당신이 가진 모든 것이 거래 ID라면 어떨까요?

00:06:59.000 --> 00:07:09.000
originalTransactionId를 검색하기 위해 새로운 Get Transaction Info 엔드포인트로 보낼 수 있지만, 왜 다른 엔드포인트를 호출하기 위해 한 엔드포인트를 호출합니까?

00:07:09.000 --> 00:07:16.000
대신, 오늘부터, 당신은 모든 transactionId로 이 엔드포인트를 호출할 수 있습니다.

00:07:16.000 --> 00:07:21.000
이전과 마찬가지로 요청 경로에 ID를 제공하세요.

00:07:21.000 --> 00:07:28.000
우리는 이 더 큰 유연성으로 App Store Server API의 핵심 엔드포인트를 그 어느 때보다 쉽게 호출할 수 있기를 바랍니다.

00:07:28.000 --> 00:07:36.000
그리고 만약 당신이 이미 originalTransactionIds로 이 엔드포인트를 호출하고 있다면, 걱정하지 마세요, 그들은 계속 작동할 것입니다.

00:07:36.000 --> 00:07:42.000
이제 App Store 서버 알림으로 오는 업데이트로 전환해 봅시다.

00:07:42.000 --> 00:07:52.000
앱이 자동 갱신 구독을 제공하는 경우, 해당 구독의 상태와 시간이 지남에 따라 어떻게 변하는지 추적하는 것이 중요합니다.

00:07:52.000 --> 00:07:57.000
여기서 구독의 다섯 가지 가능한 상태를 볼 수 있습니다.

00:07:57.000 --> 00:08:13.000
App Store Server Notifications V2를 사용하면 이 상태의 변경으로 이어지는 이벤트에 대한 즉각적인 알림을 받게 되므로 적절한 시간에 콘텐츠를 빠르게 활성화 및 비활성화하고 원활한 사용자 경험을 유지할 수 있습니다.

00:08:13.000 --> 00:08:19.000
알림이 구독 상태에 대한 지식을 어떻게 알릴 수 있는지 살펴봅시다.

00:08:19.000 --> 00:08:27.000
많은 알림 이벤트는 유형과 하위 유형을 통해 구독 상태를 직접 나타냅니다.

00:08:27.000 --> 00:08:34.000
예를 들어 INITIAL_BUY 하위 유형이 있는 이 구독 알림을 생각해 보세요.

00:08:34.000 --> 00:08:43.000
이 알림은 제품에 대한 새로운 구독을 나타내므로 구독 상태가 활성임을 알 수 있습니다.

00:08:43.000 --> 00:08:49.000
여기 알림 유형이 만료된 더 간단한 예가 있습니다.

00:08:49.000 --> 00:08:57.000
이것은 관련 구독의 상태가 이제 만료되었음을 분명히 나타냅니다.

00:08:57.000 --> 00:09:02.000
하지만 일부 알림의 경우, 구독 상태가 그렇게 명확하지 않을 수 있습니다.

00:09:02.000 --> 00:09:06.000
이 환불 알림을 예로 들어 보세요.

00:09:06.000 --> 00:09:13.000
이 알림 유형은 앱에서 이루어진 인앱 구매에 대한 환불이 승인될 때 전송됩니다.

00:09:13.000 --> 00:09:21.000
이 알림의 서명된 거래 정보를 확인하면 어떤 구매가 환불되었는지 알 수 있습니다.

00:09:21.000 --> 00:09:31.000
이 경우, 환불은 자동 갱신 구독에 대한 것이므로, 구독 상태 기록을 업데이트하고 싶습니다.

00:09:31.000 --> 00:09:38.000
그 상태가 이제 "취소되었다"고 가정하는 것은 유혹적일 수 있지만, 반드시 그런 것은 아니다.

00:09:38.000 --> 00:09:49.000
동일한 원본 TransactionId로 더 최근의 구독 갱신 구매가 있다면, 구독 상태는 여전히 활성 상태일 수 있습니다.

00:09:49.000 --> 00:09:56.000
만약 그렇다면, 구독 콘텐츠에 대한 접근을 비활성화해서는 안 됩니다.

00:09:56.000 --> 00:10:06.000
이 상황에서, 구독 상태는 단순히 불분명하며, 알림의 데이터만으로는 업데이트하기에 충분하지 않습니다.

00:10:06.000 --> 00:10:08.000
이건 이상적이지 않아.

00:10:08.000 --> 00:10:22.000
구독에 대한 App Store 서버 알림을 받으면 구독의 최신 상태를 명확하게 표시하므로 서버에서 이 중요한 정보를 최신 상태로 유지할 수 있습니다.

00:10:22.000 --> 00:10:30.000
그래서 오늘 우리는 App Store Server Notifications V2의 데이터 객체에 새로운 상태 필드를 도입하고 있습니다.

00:10:30.000 --> 00:10:40.000
이 필드는 앞서 설명한 구독의 다섯 가지 핵심 상태 중 하나를 나타내는 간단한 정수입니다.

00:10:40.000 --> 00:10:46.000
이 새로운 필드는 우리가 자동 갱신 구독을 위해 보내는 모든 알림에 포함될 것입니다.

00:10:46.000 --> 00:10:55.000
이제 App Store Server API의 Get All Subscription Statuses 엔드포인트를 호출하지 않고도 구독 상태를 얻을 수 있습니다.

00:10:55.000 --> 00:11:00.000
이 새로운 분야가 내가 앞서 설명한 시나리오를 어떻게 개선하는지 보자.

00:11:00.000 --> 00:11:12.000
이제 구독에 대한 환불 알림을 받으면, 구독 상태를 이해하기 위해 상태 필드를 확인하기만 하면 됩니다.

00:11:12.000 --> 00:11:18.000
이 경우 1이므로, 관련 구독이 활성이라는 것을 알 수 있습니다.

00:11:18.000 --> 00:11:28.000
새로운 상태 필드는 App Store 서버 알림을 그 어느 때보다 유용하게 만들어 단 한 번도 놓치지 않도록 해야 합니다.

00:11:28.000 --> 00:11:36.000
하지만 서버가 정전을 경험하면, App Store 서버가 알림을 보내기 위해 연락하지 못할 수도 있습니다.

00:11:36.000 --> 00:11:44.000
그것이 우리가 App Store Server API의 Get Notification History 엔드포인트를 제공하는 이유입니다.

00:11:44.000 --> 00:11:55.000
이 엔드포인트를 사용하면 앱에 대해 생성된 App Store 서버에서 지난 6개월 동안 버전 2 알림을 요청할 수 있습니다.

00:11:55.000 --> 00:12:05.000
그렇게 하면 서버에 알려진 정전이 있을 때, 중단 기간 동안 이 엔드포인트를 호출하고 서버가 놓친 알림을 검색할 수 있습니다.

00:12:05.000 --> 00:12:09.000
하지만 일부 사용 사례의 경우, 이 과정은 그다지 효율적이지 않을 수 있다.

00:12:09.000 --> 00:12:18.000
때때로, 당신의 서버는 예를 들어 일시적인 네트워크 문제로 인해 정전 밖에서도 알림을 놓칠 수 있습니다.

00:12:18.000 --> 00:12:30.000
이 상황에서, 엔드포인트를 쿼리할 수 있는 명확한 기간이 없을 수 있으며, 서버가 이미 받은 알림 페이지를 선별할 수 있습니다.

00:12:30.000 --> 00:12:39.000
이 사용 사례를 해결하기 위해, 우리는 "onlyFailures"라는 알림 기록 받기에 새로운 요청 필드를 도입하고 있습니다.

00:12:39.000 --> 00:12:47.000
이 선택적 필드는 서버에 도달하지 못한 알림으로만 반환되는 알림을 제한합니다.

00:12:47.000 --> 00:12:54.000
응답에는 현재 재시도 과정에 있는 알림도 포함될 것이다.

00:12:54.000 --> 00:13:04.000
이제 서버가 아직 보지 않은 알림을 구문 분석하기만 하면 되며, 정전과 가끔 네트워크 문제에서 훨씬 더 빨리 복구할 수 있습니다.

00:13:04.000 --> 00:13:08.000
이 새로운 분야가 어떻게 작동하는지 살펴봅시다.

00:13:08.000 --> 00:13:18.000
알림 기록 가져오기 엔드포인트에 요청을 보내고, 요청 본문에 새 필드인 onlyFailures를 포함합니다.

00:13:18.000 --> 00:13:21.000
여기 답변이 있습니다.

00:13:21.000 --> 00:13:36.000
notificationHistory 배열의 각 항목은 알림을 나타내며, 요청에 새로운 onlyFailures 필드를 포함했기 때문에 여기에 나열된 모든 알림이 서버에 도달하지 못했습니다.

00:13:36.000 --> 00:13:41.000
하나의 알림 항목을 확대해 봅시다.

00:13:41.000 --> 00:13:44.000
여기 서명된 페이로드가 있습니다.

00:13:44.000 --> 00:13:53.000
원래 서버로 전송된 것처럼 이 문자열을 디코딩하여 알림의 내용을 볼 수 있습니다.

00:13:53.000 --> 00:14:01.000
이 알림에 대한 sendAttempts 배열을 살펴보면, 이제 각 전송 시도의 결과를 볼 수 있습니다.

00:14:01.000 --> 00:14:10.000
이 배열은 최대 6개의 항목을 포함할 수 있으며, 초기 전송 시도에는 1개, 재시도에는 최대 5개의 항목이 포함될 수 있습니다.

00:14:10.000 --> 00:14:19.000
여기서 우리는 두 개의 항목만 볼 수 있고, 둘 다 실패했기 때문에, 알림은 여전히 재시도 과정에 있어야 합니다.

00:14:19.000 --> 00:14:29.000
나중에 재시도에 성공하면, onlyFailures 필드를 포함하는 후속 요청에 대해 이 알림이 더 이상 나타나지 않습니다.

00:14:29.000 --> 00:14:32.000
그래서 그것이 새로운 유일한 실패 분야가 작동하는 방식이다.

00:14:32.000 --> 00:14:38.000
나는 그것이 알림 기록을 훨씬 더 유용하게 만든다는 것을 알게 될 것이라고 생각한다.

00:14:38.000 --> 00:14:44.000
마지막으로, 오래된 API에서 마이그레이션하는 것에 대한 중요한 업데이트.

00:14:44.000 --> 00:14:53.000
앱이 한동안 인앱 구매를 제공했다면, verifyReceipt API에 익숙할 것입니다.

00:14:53.000 --> 00:15:01.000
2021년에, 우리는 App Store Server에서 인앱 구매 데이터를 얻는 새로운 방법으로 App Store Server API를 출시했습니다.

00:15:01.000 --> 00:15:06.000
이 두 API를 비교해 봅시다.

00:15:06.000 --> 00:15:15.000
verifyReceipt를 사용하면 원래 버전의 StoreKit을 실행하는 고객으로부터 받은 영수증을 확인하고 디코딩할 수 있습니다.

00:15:15.000 --> 00:15:23.000
App Store Server API를 사용하면 이 세 가지 엔드포인트를 사용하여 영수증 등에서 찾을 수 있는 모든 데이터를 가져올 수 있습니다.

00:15:23.000 --> 00:15:36.000
그리고 App Store Server API는 다른 곳에서는 찾을 수 없는 유용한 데이터와 강력한 기능을 제공하는 다양한 추가 엔드포인트를 제공합니다.

00:15:36.000 --> 00:15:45.000
알림 API로 전환하면서, 우리는 여전히 구형 App Store 서버 알림 V1을 지원합니다.

00:15:45.000 --> 00:15:50.000
하지만 2021년에, 우리는 App Store 서버 알림 V2를 도입했습니다.

00:15:50.000 --> 00:15:54.000
이제 이 API를 비교해 봅시다.

00:15:54.000 --> 00:16:04.000
App Store 서버 알림 V1과 V2는 모두 서버로 직접 전송되는 실시간 인앱 구매 이벤트를 제공합니다.

00:16:04.000 --> 00:16:10.000
하지만 V2는 유형과 하위 유형을 모두 사용하여 이벤트를 정의함으로써 더 큰 명확성을 제공한다.

00:16:10.000 --> 00:16:13.000
그리고 그 차이는 거기서 멈추지 않는다.

00:16:13.000 --> 00:16:29.000
V2는 또한 추가 이벤트에 대한 알림, 테스트 알림을 요청할 수 있는 기능, 알림 기록에 대한 액세스 및 사용자의 구독 상태를 추적하기 위한 새로운 상태 필드를 제공합니다.

00:16:29.000 --> 00:16:43.000
App Store Server API 및 App Store Server Notifications V2를 채택하면 서버에서 앱 내 구매 데이터를 안전하고 효율적으로 관리할 수 있는 다양한 새로운 기능을 잠금 해제할 수 있습니다.

00:16:43.000 --> 00:16:49.000
궁극적으로, 그것은 당신의 고객을 위한 더 나은 인앱 구매 경험을 의미합니다.

00:16:49.000 --> 00:16:56.000
그래서 오늘, 우리는 verifyReceipt와 App Store 서버 알림 V1의 사용 중단을 발표합니다.

00:16:56.000 --> 00:17:04.000
오늘부터, 이 API는 더 이상 사용되지 않는 것으로 간주되며 더 이상 기능 업데이트를 받지 않을 것이다.

00:17:04.000 --> 00:17:11.000
새로운 API의 모든 혜택을 누리려면 지금 마이그레이션 계획을 시작하세요.

00:17:11.000 --> 00:17:16.000
이주에는 몇 가지 짧은 단계가 필요하다.

00:17:16.000 --> 00:17:29.000
verifyReceipt에서 App Store Server API로 마이그레이션하려면, 먼저 앱을 나타내기 위해 JWT에 서명해야 하며, 이는 문서에 설명된 간단한 프로세스입니다.

00:17:29.000 --> 00:17:35.000
App Store Server API를 호출할 때마다, 이 JWT를 헤더로 제공할 것입니다.

00:17:35.000 --> 00:17:40.000
그것은 당신이 요청한 앱 데이터를 소유하고 있다는 것을 증명할 것입니다.

00:17:40.000 --> 00:17:45.000
다음으로, 각 사용자에 대한 transactionId를 저장해야 합니다.

00:17:45.000 --> 00:17:56.000
거래 기록 가져오기 및 모든 구독 상태 가져오기와 같은 핵심 엔드포인트를 호출할 때마다 이 transactionId를 경로 매개 변수로 제공합니다.

00:17:56.000 --> 00:17:58.000
모든 거래 ID는 작동할 것이다.

00:17:58.000 --> 00:18:02.000
만약 당신이 데이터베이스를 유지한다면 당신은 이미 하나를 저장했을 것입니다.

00:18:02.000 --> 00:18:08.000
그렇지 않으면, 각 사용자의 영수증에서 하나를 추출할 수 있습니다.

00:18:08.000 --> 00:18:10.000
그리고 그게 다야.

00:18:10.000 --> 00:18:18.000
그러면 verifyReceipt 등에서 얻는 데 사용한 모든 데이터에 액세스할 수 있습니다.

00:18:18.000 --> 00:18:25.000
App Store 서버 알림 V1에서 V2로의 마이그레이션은 훨씬 더 간단합니다.

00:18:25.000 --> 00:18:30.000
먼저, 새로운 V2 형식을 구문 분석할 서버를 준비하세요.

00:18:30.000 --> 00:18:44.000
이미 App Store Server API를 사용하고 있다면, App Store Server Notifications V2는 동일한 JWS 거래 형식을 사용하기 때문에 이 단계는 간단해야 합니다.

00:18:44.000 --> 00:18:52.000
서버가 준비되면, App Store Connect를 방문하여 기본 설정을 V1에서 V2 알림으로 변경하십시오.

00:18:52.000 --> 00:19:01.000
구현을 테스트하려면, 샌드박스에서만 버전 2 알림을 받는 것으로 시작할 수 있습니다.

00:19:01.000 --> 00:19:08.000
기본 설정을 전환한 후, App Store 서버는 V2 형식으로 새로운 알림을 보내기 시작할 것입니다.

00:19:08.000 --> 00:19:17.000
재시도 과정에서 V1 알림이 있다면, 최대 3일 동안 계속 받을 수 있습니다.

00:19:17.000 --> 00:19:22.000
이주에 대한 더 많은 지원을 위해, 우리는 추가 자원을 사용할 수 있습니다.

00:19:22.000 --> 00:19:35.000
App Store Server API 및 App Store Server Notifications V2는 샌드박스 환경에서 사용할 수 있으므로 프로덕션으로 출시하기 전에 구현을 테스트할 수 있습니다.

00:19:35.000 --> 00:19:48.000
그리고 이번 주에, 우리는 App Store Server API를 호출하고 App Store Server Notifications V2를 구문 분석하기 위한 새로운 오픈 소스 라이브러리인 App Store Server Library를 출시합니다.

00:19:48.000 --> 00:20:01.000
엔드포인트에 쉽게 전화하고, 받은 서명된 데이터를 확인하고, 영수증에서 transactionId를 추출하여 마이그레이션을 더 쉽게 할 수 있습니다.

00:20:01.000 --> 00:20:09.000
올해 WWDC에서 "App Store 서버 라이브러리를 만나세요"라는 제목의 전용 세션을 확인해 보시기 바랍니다.

00:20:09.000 --> 00:20:20.000
그리고 마이그레이션 방법에 대한 더 많은 팁은 "앱 내 구매 통합 및 마이그레이션 탐색"이라는 제목의 WWDC22 세션을 참조하십시오.

00:20:20.000 --> 00:20:24.000
이것으로 이 세션의 앱 스토어 서버 업데이트를 마칩니다.

00:20:24.000 --> 00:20:34.000
오늘 발표한 훌륭한 새로운 기능을 활용하고, 검토할 시간이 없었던 더 많은 기능에 대한 문서를 확인하길 바랍니다.

00:20:34.000 --> 00:20:45.000
모든 기능은 이제 샌드박스와 프로덕션 모두에서 사용할 수 있으므로, 먼저 샌드박스에서 테스트한 다음 준비가 되면 프로덕션 서버로 롤아웃할 수 있습니다.

00:20:45.000 --> 00:20:47.000
그리고 우리는 네 소식을 듣고 싶어.

00:20:47.000 --> 00:20:54.000
App Store 서버에 대한 기능 요청이 있는 경우, Apple의 피드백 어시스턴트를 통해 알려주십시오.

00:20:54.000 --> 00:20:57.000
WWDC23에 함께 해줘서 고마워!

00:20:57.000 --> 23:59:59.000
♪ ♪

