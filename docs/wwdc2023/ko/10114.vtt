WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:13.000
데이비드: 안녕하세요, "Wallet과 Apple Pay의 새로운 기능"에 오신 것을 환영합니다.

00:00:13.000 --> 00:00:15.000
제 이름은 데이비드입니다. 존: 그리고 난 존이야.

00:00:15.000 --> 00:00:22.000
데이비드: 오늘, 우리는 올해 지갑과 애플 페이 경험에 도입할 모든 새로운 기능과 개선 사항에 대해 이야기할 것입니다.

00:00:22.000 --> 00:00:31.000
지갑과 Apple Pay는 다양한 특징과 기능, 바코드 패스, 교통 카드, 자동차 키 등을 포함합니다.

00:00:31.000 --> 00:00:41.000
이것들은 모두 우리 생태계의 중요한 부분이지만, 오늘날의 초점은 세 가지 영역에 있을 것이다: 지불, 주문 추적 및 신원.

00:00:41.000 --> 00:00:44.000
결제부터 시작합시다.

00:00:44.000 --> 00:00:51.000
먼저 Apple Pay에 대해 나중에 이야기하고 플랫폼 내에서 머천다이징 지원을 통합하는 방법에 대해 이야기하겠습니다.

00:00:51.000 --> 00:01:01.000
우리는 사전 승인된 결제에 대한 몇 가지 개선 사항에 대해 이야기한 다음 Apple Pay로 자금 이체를 지원하기 위해 새로운 API를 살펴볼 것입니다.

00:01:01.000 --> 00:01:10.000
Apple Pay Later는 올해 초 미국 고객에게 소개되었으며 사용자가 구매를 네 개의 개별 결제로 나눌 수 있게 해준다.

00:01:10.000 --> 00:01:15.000
그러면 사용자는 지갑 내에서 이러한 구매를 편리하게 추적하고 관리할 수 있습니다.

00:01:15.000 --> 00:01:25.000
Apple Pay Later는 통합이 필요하지 않지만, UI에 포함할 수 있는 전용 머천다이징 뷰를 제공하는 새로운 API를 도입하고 있습니다.

00:01:25.000 --> 00:01:32.000
이 보기를 사용하면 Apple Pay Later에 대한 지원을 나타내며, 고객이 기대할 수 있는 경험에 대해 자세히 설명합니다.

00:01:32.000 --> 00:01:38.000
표시되는 컨텍스트에 더 잘 맞도록 뷰 스타일을 사용자 정의할 수 있습니다.

00:01:38.000 --> 00:01:45.000
사용자가 더 많은 것을 배우기 위해 이 보기를 선택하면, 나중에 Apple Pay가 어떻게 설명되는지 선택할 수 있습니다.

00:01:45.000 --> 00:01:50.000
그리고 이 보기는 앱과 웹 모두에서 개발자가 사용할 수 있습니다.

00:01:50.000 --> 00:02:04.000
머천다이징 뷰는 문맥에 따라 네 가지 디스플레이 스타일로 렌더링될 수 있습니다: Apple Pay Later를 사용하여 구매를 여러 상환으로 분할하는 방법을 간략하게 설명하는 표준 스타일.

00:02:04.000 --> 00:02:09.000
간결한 방식으로 지원을 나타내는 배지 스타일.

00:02:09.000 --> 00:02:14.000
체크아웃 흐름에서 다른 결제 옵션과 함께 배치되도록 설계된 체크아웃 스타일.

00:02:14.000 --> 00:02:18.000
그리고 총 구매 가격과 함께 사용하기 위한 가격 스타일.

00:02:18.000 --> 00:02:23.000
사용자가 이 견해와 상호 작용할 때, 그들에게 더 많은 정보가 제시될 것이다.

00:02:23.000 --> 00:02:28.000
상인으로서, 당신은 두 가지 다른 행동 중에서 선택할 수 있습니다.

00:02:28.000 --> 00:02:37.000
"자세히 알아보기" 작업은 Apple Pay Later의 개요를 제시하고 사용자가 결제 방법으로 선택하면 겪게 될 경험을 설명합니다.

00:02:37.000 --> 00:02:46.000
"계산기" 조치는 여전히 나중에 Apple Pay에 대한 설명을 제시하지만, 사용자가 따라야 할 상환 일정에 중점을 둡니다.

00:02:46.000 --> 00:02:50.000
이 보기를 앱에 통합하는 것을 살펴봅시다.

00:02:50.000 --> 00:02:56.000
먼저, 사용자가 나중에 Apple Pay를 사용할 수 있는지 확인하고 싶을 것입니다.

00:02:56.000 --> 00:03:01.000
PKPayLaterUtilities 내의 유효성 검사 기능을 사용하여 이를 수행할 수 있습니다.

00:03:01.000 --> 00:03:06.000
필요한 로케일뿐만 아니라 거래 금액을 제공해야 합니다.

00:03:06.000 --> 00:03:16.000
사용자가 나중에 Apple Pay를 사용할 수 있는지 여부를 결정하면, 자격 확인에 제공된 것과 동일한 세부 사항으로 PKPayLaterView를 인스턴스화합니다.

00:03:16.000 --> 00:03:24.000
뷰의 스타일과 동작을 사용자 정의하고 싶다면, 각각의 속성을 변경하여 그렇게 할 수 있습니다.

00:03:24.000 --> 00:03:32.000
우리는 또한 SwiftUI 앱 내에서 Apple Pay Later 수락을 표현할 수 있는 편리한 SwiftUI 보기를 제공합니다.

00:03:32.000 --> 00:03:38.000
그것을 사용하려면, PayLaterView를 인스턴스화하여 이전과 동일한 정보를 제공합니다.

00:03:38.000 --> 00:03:43.000
디스플레이 스타일과 동작을 사용자 정의하려면, 적절한 보기 수정자를 사용하세요.

00:03:43.000 --> 00:03:46.000
그리고 그건 그렇게 간단해.

00:03:46.000 --> 00:03:53.000
웹에서 머천다이징 보기를 지원하고 싶다면, 먼저 수행해야 할 몇 가지 설정 단계가 있습니다.

00:03:53.000 --> 00:04:02.000
보기를 표시하기 위한 API는 기존 Apple Pay JavaScript SDK 내에서 제공되지만, 포함할 때 설정해야 할 몇 가지 새로운 속성이 있습니다.

00:04:02.000 --> 00:04:10.000
크로스 오리진 리소스 공유 요청을 지원해야 하는 경우 크로스 오리진 속성을 설정하는 것이 중요합니다.

00:04:10.000 --> 00:04:18.000
비동기 속성을 사용하여 스크립트가 페이지의 로딩 진행 상황과 독립적으로 로드되고 실행되도록 하십시오.

00:04:18.000 --> 00:04:23.000
그리고 마지막으로, JWT는 API에 대한 요청을 인증해야 합니다.

00:04:23.000 --> 00:04:27.000
이 토큰은 Apple 개발자 포털에서 생성할 수 있습니다.

00:04:27.000 --> 00:04:31.000
자바스크립트 SDK를 사용하는 것이 더 간단할 수 없다.

00:04:31.000 --> 00:04:35.000
애플 페이 머천다이징 요소를 사용하여 뷰를 표현하세요.

00:04:35.000 --> 00:04:42.000
금액, 국가 코드, 통화 코드 및 로케일은 필수 필드입니다.

00:04:42.000 --> 00:04:47.000
네이티브 API와 마찬가지로, 필요에 따라 보기의 다른 측면을 사용자 정의할 수도 있습니다.

00:04:47.000 --> 00:04:53.000
다음은 Apple Pay Later 머천다이징 보기를 통합하는 경우 따라야 할 몇 가지 모범 사례입니다.

00:04:53.000 --> 00:04:57.000
앱의 경우, 이 보기를 사용하려면 자격이 필요합니다.

00:04:57.000 --> 00:05:00.000
이것은 애플 개발자 포털에서 얻을 수 있다.

00:05:00.000 --> 00:05:07.000
웹사이트의 경우, 도메인을 등록하고 SDK를 포함할 때 사용할 JWT를 얻는 것을 잊지 마세요.

00:05:07.000 --> 00:05:11.000
이것은 애플 개발자 포털에서도 할 수 있다.

00:05:11.000 --> 00:05:15.000
가능하다면, 헤드 요소 내에서 SDK를 가져오세요.

00:05:15.000 --> 00:05:22.000
이를 통해 가능한 한 빨리 실행할 수 있으므로, 페이지가 완전히 로드되었을 때 머천다이징 보기가 준비됩니다.

00:05:22.000 --> 00:05:28.000
보기의 크기는 필요에 따라 사용자 정의할 수 있지만, 크기 요구 사항을 따라야 합니다.

00:05:28.000 --> 00:05:38.000
그리고 마지막으로, 웹사이트에 제한적인 콘텐츠 보안 정책이 있는 경우, SDK가 도메인에 걸쳐 로드될 수 있도록 권장 지침을 따르십시오.

00:05:38.000 --> 00:05:41.000
그리고 그것은 나중에 Apple Pay를 보는 것이다.

00:05:41.000 --> 00:05:44.000
다음으로, 우리는 사전 승인된 지불에 대해 이야기할 것이다.

00:05:44.000 --> 00:05:49.000
iOS 16에서, 우리는 사전 승인된 결제를 도입했다.

00:05:49.000 --> 00:05:57.000
사용자는 지갑에서 사전 승인된 결제를 보고 관리할 수 있으며, 판매자는 합의된 조건에 따라 사용자에게 청구할 수 있습니다.

00:05:57.000 --> 00:06:02.000
우리는 처음에 반복 결제와 자동 리로드 결제에 대한 지원을 제공했습니다.

00:06:02.000 --> 00:06:04.000
우리는 또한 이제 연기된 지불을 지원합니다.

00:06:04.000 --> 00:06:10.000
세 가지 사전 승인된 결제 유형 모두 앱과 웹에서 사용할 수 있습니다.

00:06:10.000 --> 00:06:17.000
이연 지불을 통해 향후 특정 날짜에 고정 또는 가변 금액을 청구할 수 있습니다.

00:06:17.000 --> 00:06:22.000
무료 취소 마감일이 있다면, 이것을 요청의 일부로 지정할 수도 있습니다.

00:06:22.000 --> 00:06:31.000
지연된 지불이 적합할 수 있는 예로는 고객이 호텔 예약을 하거나 물품을 선주문할 때가 있습니다.

00:06:31.000 --> 00:06:36.000
사전 승인된 결제는 Apple Pay 가맹점 토큰을 활용합니다.

00:06:36.000 --> 00:06:41.000
그것들은 개별 장치가 아닌 사용자의 Apple ID에 연결되어 있다.

00:06:41.000 --> 00:06:47.000
이것은 예를 들어, 사용자가 장치를 업그레이드한다면, 토큰은 여전히 사용하기에 유효하다는 것을 의미합니다.

00:06:47.000 --> 00:06:55.000
이 때문에, 당신은 여전히 토큰을 사용하여 계좌에 청구할 수 있으며, 나중에 지불을 더 신뢰할 수 있게 받을 수 있습니다.

00:06:55.000 --> 00:07:02.000
사전 승인된 결제를 수행할 때, 고객의 결제 카드가 이를 지원하는 경우 가맹점 토큰이 자동으로 발급됩니다.

00:07:02.000 --> 00:07:12.000
결제 카드가 판매자 토큰을 지원하지 않는 경우, 거래는 여전히 진행되지만 개별 장치에 연결된 전통적인 Apple Pay 토큰을 사용합니다.

00:07:12.000 --> 00:07:19.000
Apple Pay 가맹점 토큰에 대해 자세히 알아보려면, 작년 지갑과 Apple Pay의 새로운 기능을 확인하세요.

00:07:19.000 --> 00:07:24.000
그래서 앱 내에서 연기된 결제를 통합하는 방법을 살펴봅시다.

00:07:24.000 --> 00:07:32.000
먼저, 우리는 요금에 대한 설명과 취할 금액을 설명하는 PKDeferredPaymentSummaryItem을 만듭니다.

00:07:32.000 --> 00:07:36.000
당신은 또한 지불이 이루어질 날짜를 정했습니다.

00:07:36.000 --> 00:07:39.000
다음으로, 우리는 PKDeferredPaymentRequest를 만듭니다.

00:07:39.000 --> 00:07:46.000
우리는 지불 관리에 관한 다른 정보와 함께 방금 만든 요약 항목을 제공합니다.

00:07:46.000 --> 00:07:53.000
사용자에게 표시해야 하는 청구 계약이 있는 경우, 이는 연기된 지불 요청에도 설정할 수 있습니다.

00:07:53.000 --> 00:08:00.000
요청을 만들고 구성하면, PKPaymentRequest에 첨부할 수 있습니다.

00:08:00.000 --> 00:08:09.000
우리의 요청에 대한 지불 요약 항목의 경우, 우리는 이전과 동일한 금액과 날짜로 다른 PKDeferredPaymentSummaryItem을 만듭니다.

00:08:09.000 --> 00:08:13.000
하지만 이번에는 상인의 이름을 나타내는 라벨이 있다.

00:08:13.000 --> 00:08:17.000
우리는 요청에 따라 이것을 설정했고, 지불을 위해 제시할 준비가 되었습니다.

00:08:17.000 --> 00:08:28.000
이 예에서 볼 수 있듯이, Apple Pay 결제 시트는 청구 계약과 청구 예상 시점에 대한 정보와 함께 사용자에게 연기된 결제를 제시합니다.

00:08:28.000 --> 00:08:35.000
이제, 무료 취소 날짜를 지정하는 경우 몇 가지 중요한 고려 사항이 있습니다.

00:08:35.000 --> 00:08:43.000
무료 취소 날짜를 제공할 때, 그 시점 이전의 모든 취소는 사용자에게 무료로 이루어질 것이라고 명시하고 있습니다.

00:08:43.000 --> 00:08:49.000
이 때문에, 날짜와 시간 모두 중요한 정보이다.

00:08:49.000 --> 00:08:53.000
취소 정책이 적용되는 시간대를 명시적으로 명시해야 합니다.

00:08:53.000 --> 00:08:56.000
우리는 이것을 지원하기 위해 별도의 재산을 제공했다.

00:08:56.000 --> 00:09:02.000
아래 예시에서, 우리는 시간대가 태평양 표준시라고 명시했다.

00:09:02.000 --> 00:09:07.000
고객의 시간대가 취소 정책의 시간대와 일치하지 않을 수 있기 때문에 이것은 중요합니다.

00:09:07.000 --> 00:09:14.000
예를 들어, 누군가가 영국에 기반을 두고 있을 때, 미국에서 호텔을 예약한다.

00:09:14.000 --> 00:09:19.000
연기된 지불로 작업할 때, 여기에 따라야 할 몇 가지 모범 사례가 있습니다.

00:09:19.000 --> 00:09:30.000
앞서 언급했듯이, 무료 취소 정책을 설명해야 하는 경우, 지연된 지불 요청에 제공된 날짜, 시간 및 시간대를 신중하게 고려하십시오.

00:09:30.000 --> 00:09:36.000
요약 항목에 연기된 지불을 포함시키는 것을 잊지 말고, 적절한 판매자 이름을 설정하세요.

00:09:36.000 --> 00:09:39.000
이것은 당신을 위해 자동으로 이루어지지 않습니다.

00:09:39.000 --> 00:09:44.000
청구 계약을 제공할 때, 짧게 유지하는 것을 잊지 마세요.

00:09:44.000 --> 00:09:53.000
청구 계약 텍스트는 고려해야 할 주요 사실의 요약 역할을 해서는 안 되며 일반적인 청구 또는 법적 계약을 대체해서는 안 됩니다.

00:09:53.000 --> 00:10:03.000
마지막으로, 토큰 알림 URL을 지정하면, 발행된 경우 Apple Pay 판매자 토큰의 수명 주기 이벤트를 최신 상태로 유지할 수 있습니다.

00:10:03.000 --> 00:10:05.000
그리고 그건 연기된 지불이야.

00:10:05.000 --> 00:10:10.000
다음으로, Apple Pay로 자금을 이체하는 새로운 방법을 살펴봅시다.

00:10:10.000 --> 00:10:16.000
전통적으로 Apple Pay로, 결제 시트는 항상 사용자가 계정에 자금을 추가할 수 있었다.

00:10:16.000 --> 00:10:22.000
iOS 17의 새로운 기능, 우리는 Apple Pay로 자금 이체를 도입하고 있습니다.

00:10:22.000 --> 00:10:30.000
이것은 사용자가 지갑의 계정에서 카드로 이체할 수 있는 기능을 제공하여 돈 이동의 수명 주기를 완료합니다.

00:10:30.000 --> 00:10:38.000
이것은 결제와 동일한 안전하고 사적인 Apple Pay 인프라를 사용하므로, 고객은 이미 그 과정에 매우 익숙할 것이다.

00:10:38.000 --> 00:10:46.000
자금 이체가 의미가 있는 예는 고객이 은행 계좌나 저장 가치 계좌에서 자금을 인출할 수 있도록 하는 것이다.

00:10:46.000 --> 00:10:55.000
Apple Pay로 자금 이체를 지원하기 위해, 우리는 자금 이체에 필요한 정보에만 초점을 맞춘 새로운 요청 유형을 만들었습니다.

00:10:55.000 --> 00:11:01.000
그것을 사용하려면, 사용자의 결제 카드로 이체하고 싶은 금액을 정의하기만 하면 됩니다.

00:11:01.000 --> 00:11:06.000
수령인의 연락처 정보가 필요한 경우, 이것들을 요청할 수도 있습니다.

00:11:06.000 --> 00:11:12.000
이전에 PKPaymentRequest를 사용한 적이 있다면, 이 새로운 API는 당신에게 매우 친숙하게 느껴질 것입니다.

00:11:12.000 --> 00:11:21.000
Apple Pay로 자금 이체는 결제와 동일한 인프라에서 작동하기 때문에, Apple Developer 포털 내에서 판매자로 등록해야 합니다.

00:11:21.000 --> 00:11:30.000
상인으로 등록하고 Apple Pay를 사용하도록 설정하는 방법에 대해 자세히 알아보려면, "Apple Pay 및 주문 관리 구현" Tech Talk를 확인하세요.

00:11:30.000 --> 00:11:36.000
Apple Pay로 자금 이체가 어떻게 작동하는지 설명하기 위해, 예를 들어 봅시다.

00:11:36.000 --> 00:11:42.000
그들의 계좌에서 돈을 인출하고 싶어하는 고객인 Andrew가 있다고 가정해 봅시다.

00:11:42.000 --> 00:11:47.000
Apple Pay로 이체 자금을 사용하면 앱 내에서 이체가 트리거됩니다.

00:11:47.000 --> 00:11:51.000
그런 다음 앱은 이체할 금액을 요약한 요청을 생성합니다.

00:11:51.000 --> 00:11:59.000
그런 다음 Andrew는 송금을 자세히 설명하는 Apple Pay 시트를 받게 될 것이며, 그들이 자금을 받을 카드를 선택할 수 있도록 할 것이다.

00:11:59.000 --> 00:12:09.000
앤드류가 전송을 안전하게 인증하면, 암호화된 페이로드가 생성되어 앱으로 반환되어 결제 제공 업체와 처리할 수 있습니다.

00:12:09.000 --> 00:12:13.000
이체가 처리되면, 앱은 결과를 Apple Pay로 반환합니다.

00:12:13.000 --> 00:12:16.000
전송이 성공하면, 그게 다야.

00:12:16.000 --> 00:12:23.000
오류가 발생하면, 앤드류는 통보를 받고 문제를 해결하기 위한 시정 조치를 취할 수 있을 것이다.

00:12:23.000 --> 00:12:30.000
이제 자금 이체가 어떻게 작동하는지에 대한 개요를 보았으니, 앱 내에서 이를 구현하는 방법을 살펴봅시다.

00:12:30.000 --> 00:12:35.000
우리는 먼저 우리가 지원하고 싶은 네트워크와 카드 기능을 결정해야 한다.

00:12:35.000 --> 00:12:41.000
다음으로, 우리는 사용자가 자금 이체를 시작할 수 있는 적격 카드를 가지고 있는지 확인할 것입니다.

00:12:41.000 --> 00:12:45.000
이것은 PKPaymentAuthorizationController를 통해 이루어집니다.

00:12:45.000 --> 00:12:51.000
supportsDisbursements 방법을 사용하여, 우리는 이전에 정의된 네트워크와 카드 기능을 제공합니다.

00:12:51.000 --> 00:12:56.000
이 확인 결과를 사용하여 사용자 인터페이스를 적절하게 조정할 수 있습니다.

00:12:56.000 --> 00:13:00.000
이제 자격을 확인했으므로, 이전 요청을 작성하기 시작할 수 있습니다.

00:13:00.000 --> 00:13:05.000
지불 요청과 마찬가지로, 금액은 요약 항목을 통해 정의됩니다.

00:13:05.000 --> 00:13:08.000
이 경우, 우리는 두 개의 다른 요약 항목을 만듭니다.

00:13:08.000 --> 00:13:12.000
첫 번째는 PKPaymentSummaryItem이다.

00:13:12.000 --> 00:13:15.000
이것은 사용자의 계좌에서 인출되는 금액을 나타냅니다.

00:13:15.000 --> 00:13:21.000
품목과 관련된 라벨이 당신의 사업체 이름이어야 한다는 점에 유의하는 것이 중요합니다.

00:13:21.000 --> 00:13:26.000
두 번째 항목은 새로운 유형의 요약 항목인 PKDisbursementSummaryItem이다.

00:13:26.000 --> 00:13:36.000
당신은 이것들 중 하나를 포함해야 하며, 그것은 항상 수수료, 요금 또는 조정을 제외한 수령인의 지불 카드에 받은 최종 금액을 나타내야 합니다.

00:13:36.000 --> 00:13:45.000
지불의 경우 PKPaymentRequest가 있는 반면, Apple Pay로 자금 이체에 대한 새로운 요청 유형인 PKDisbursementRequest가 있습니다.

00:13:45.000 --> 00:13:50.000
PKDisbursementRequest를 구성하려면, 특정 세부 사항을 지정해야 합니다.

00:13:50.000 --> 00:14:03.000
Apple Pay에 등록할 때 설정한 판매자 식별자, 거래 통화, 비즈니스 지역, 이전에 정의된 네트워크 및 기능이 필요합니다.

00:14:03.000 --> 00:14:06.000
방금 만든 요약 항목도 제공합니다.

00:14:06.000 --> 00:14:12.000
송금 수령인의 연락처 정보가 필요한 경우, 여기에서도 요청할 수 있습니다.

00:14:12.000 --> 00:14:17.000
또한 수령인의 결제 카드가 발급된 지역을 제한할 수 있습니다.

00:14:17.000 --> 00:14:21.000
요청이 구축되면, 우리는 이제 그것을 사용자에게 제시할 수 있습니다.

00:14:21.000 --> 00:14:28.000
우리는 지출 요청으로 PKPaymentAuthorizationController의 인스턴스를 초기화함으로써 이것을 합니다.

00:14:28.000 --> 00:14:33.000
우리는 우리 자신을 대의원으로 설정한 다음, 발표한다.

00:14:33.000 --> 00:14:42.000
여기에서 볼 수 있듯이, 사용자에게 이체를 받고 싶은 결제 카드와 해당 카드로 받을 금액을 선택할 수 있는 옵션이 제공됩니다.

00:14:42.000 --> 00:14:51.000
이제, 사용자가 전송을 안전하게 승인하면, 전송을 처리하기 위해 구현해야 할 몇 가지 대리 콜백이 있습니다.

00:14:51.000 --> 00:14:58.000
Apple Pay로 자금 이체를 처리하기 위해 구현해야 하는 위임 방법은 두 가지뿐입니다.

00:14:58.000 --> 00:15:02.000
첫 번째는 paymentAuthorizationControllerDidFinish입니다.

00:15:02.000 --> 00:15:05.000
이것은 시트가 해제할 준비가 되었을 때 호출될 것이다.

00:15:05.000 --> 00:15:09.000
그것을 해고할 책임은 통화 앱에 있다.

00:15:09.000 --> 00:15:14.000
이 방법을 사용하여 그에 따라 앱의 UI를 변경할 수도 있습니다.

00:15:14.000 --> 00:15:18.000
두 번째로, didAuthorizePayment 위임 방법이다.

00:15:18.000 --> 00:15:26.000
Apple Pay로 자금 이체는 결제와 동일한 인프라를 사용하기 때문에, 처리에 사용할 동일한 유형의 PKPayment 객체를 받게 됩니다.

00:15:26.000 --> 00:15:33.000
여기서 우리는 토큰 처리를 자체 processFundsTransfer 방법으로 추상화했습니다.

00:15:33.000 --> 00:15:40.000
처리 결과에 따라, 당신은 성공 또는 실패를 반환할 것입니다.

00:15:40.000 --> 00:15:46.000
처리 단계에서 오류가 발생하면, 우리는 이것들을 나타내는 일련의 편리한 방법을 제공했습니다.

00:15:46.000 --> 00:15:54.000
제공된 연락처 정보와 관련된 문제가 있을 때 disbursementContactInvalidError를 사용할 수 있습니다.

00:15:54.000 --> 00:16:03.000
결제 프로세서가 사용자의 결제 카드가 자금 이체를 수락할 수 없다고 판단하면, disbursementCardUnsupportedError를 사용할 수 있습니다.

00:16:03.000 --> 00:16:10.000
일부 금융 기관은 자금이 수령인에게 더 빨리 송금될 수 있는 즉각적인 자금 이체를 지원합니다.

00:16:10.000 --> 00:16:14.000
이것들은 또한 Apple Pay로 이체 자금으로 표현될 수 있다.

00:16:14.000 --> 00:16:21.000
서비스에 따라, 이러한 즉각적인 이체에는 때때로 수수료가 포함될 수 있으며, 이는 또한 대표될 수 있다.

00:16:21.000 --> 00:16:26.000
일반적으로, 사용자는 앱 내에서 전송 속도를 선택할 수 있습니다.

00:16:26.000 --> 00:16:32.000
사용자가 즉시 자금을 이체하기로 선택하면, 지원을 요구할 수 있는 기능을 제공하십시오.

00:16:32.000 --> 00:16:40.000
그렇게 할 때, 사용자의 카드 선택은 즉시 전송을 지원하는 것으로 알려진 카드로 제한됩니다.

00:16:40.000 --> 00:16:44.000
그리고 이것이 즉각적인 전송의 모습이다.

00:16:44.000 --> 00:16:52.000
시트는 이전과 매우 비슷해 보이지만, 이제 우리는 사용자가 지불할 수수료뿐만 아니라 전송이 즉각적이라는 사실을 강조합니다.

00:16:52.000 --> 00:16:56.000
이체 금액 또한 수수료를 고려하여 조정되었다.

00:16:56.000 --> 00:17:01.000
이전 전송 요청을 즉시 만드는 방법을 봅시다.

00:17:01.000 --> 00:17:06.000
첫째, 우리는 지원되는 기능 목록에 instantFundsOut을 추가합니다.

00:17:06.000 --> 00:17:13.000
그런 다음 지원 지출 내에서 사용자가 즉시 이체를 지원하는 카드를 가지고 있는지 확인할 수 있습니다.

00:17:13.000 --> 00:17:18.000
그런 다음 그에 따라 전송 방법 옵션과 사용자 인터페이스를 조정할 수 있습니다.

00:17:18.000 --> 00:17:27.000
요약 항목에 관해서는, 우리는 즉시 이체 수수료를 나타내는 전용 항목인 PKInstantFundsOutFeeSummaryItem이 있습니다.

00:17:27.000 --> 00:17:33.000
이 항목으로, 당신은 즉시 이체를 수행하기 위해 청구될 금액을 지정합니다.

00:17:33.000 --> 00:17:38.000
수수료를 부과하지 않더라도, 이 요약 항목은 여전히 필요합니다.

00:17:38.000 --> 00:17:41.000
이 경우, 당신은 0의 양을 설정할 것입니다.

00:17:41.000 --> 00:17:47.000
이 예에서, 우리는 수수료를 부과하고 있기 때문에, 그에 따라 지출 금액을 업데이트해야 합니다.

00:17:47.000 --> 00:17:50.000
이것은 당신을 위해 자동으로 이루어지지 않을 것입니다.

00:17:50.000 --> 00:17:55.000
PKDisbursementRequest를 만드는 것은 이전과 크게 다르지 않다.

00:17:55.000 --> 00:18:01.000
유일한 차이점은 이전에 정의된 기능과 요약 항목을 제공하도록 하는 것입니다.

00:18:01.000 --> 00:18:04.000
그리고 그것이 즉각적인 전송을 나타내는 데 필요한 전부입니다.

00:18:04.000 --> 00:18:10.000
다음은 Apple Pay로 자금 이체를 구현할 때 명심해야 할 몇 가지 모범 사례입니다.

00:18:10.000 --> 00:18:19.000
Apple Pay로 자금 이체는 iOS 및 iPadOS에서만 사용할 수 있으며, macOS 또는 웹에서 사용할 수 없습니다.

00:18:19.000 --> 00:18:29.000
자금 이체를 처리하는 동안 오류가 발생하면, 사용자에게 효과적으로 전달하기 위해 전용 지출 오류 중 하나를 사용하세요.

00:18:29.000 --> 00:18:36.000
첫 번째 요약 항목은 사용자 계정에서 인출될 금액을 나타내야 한다는 점에 유의하는 것이 중요합니다.

00:18:36.000 --> 00:18:40.000
첫 번째 요약 항목의 라벨은 당신의 사업과 일치해야 합니다.

00:18:40.000 --> 00:18:49.000
그리고 마지막 요약 항목은 수수료, 요금 또는 조정을 제외한 사용자의 결제 카드로 받을 금액을 나타내야 합니다.

00:18:49.000 --> 00:18:53.000
그리고 그것이 우리가 오늘 지불과 관련하여 가지고 있는 전부이다.

00:18:53.000 --> 00:18:57.000
트랙을 조금 바꾸려면, 주문 추적에 대해 이야기해 봅시다.

00:18:57.000 --> 00:19:04.000
주문 추적은 사용자가 참여 가맹점과의 주문을 추적할 수 있는 방법으로 iOS 16에 도입되었습니다.

00:19:04.000 --> 00:19:10.000
사용자들의 반응은 환상적이었고, 우리는 주문 추적을 더 좋게 만들기 위해 열심히 노력해 왔습니다.

00:19:10.000 --> 00:19:17.000
우리는 주문을 더 잘 표현하고 전달하기 위해 운영 체제 내의 통합을 어떻게 개선했는지에 대해 이야기할 것입니다.

00:19:17.000 --> 00:19:20.000
그런 다음 주문 추적에 대한 몇 가지 개선 사항을 살펴볼 것입니다.

00:19:20.000 --> 00:19:26.000
그리고 마지막으로, 우리는 지갑에 주문을 추가하는 새로운 방법을 소개하고 있습니다.

00:19:26.000 --> 00:19:37.000
iOS 16.4에서, 우리는 메시지를 통해 주문 공유에 대한 지원을 추가하고, 주문의 인라인 미리보기를 제공하고, 수신자가 지갑 내에서 추적할 수 있는 기능을 추가했습니다.

00:19:37.000 --> 00:19:43.000
우리는 또한 사용자가 한 눈에 주문을 추적할 수 있는 주문 추적 위젯을 도입했습니다.

00:19:43.000 --> 00:19:48.000
사용자는 이미 추가 작업 없이 이러한 새로운 기능의 혜택을 누릴 수 있습니다.

00:19:48.000 --> 00:19:53.000
우리는 지도를 지원하여 iOS 17의 시스템 통합을 계속하고 있습니다.

00:19:53.000 --> 00:20:02.000
사용자가 지정된 픽업 시간과 위치로 주문을 추적하는 경우, 지도는 Siri 제안을 통해 사전에 제안할 것입니다.

00:20:02.000 --> 00:20:08.000
이제 iOS 17에서 주문 추적에 대한 몇 가지 개선 사항을 살펴봅시다.

00:20:08.000 --> 00:20:14.000
택배 및 음식 배달 사용 사례를 더 잘 지원하기 위해, 이제 사용되는 배송 유형을 표시할 수 있습니다.

00:20:14.000 --> 00:20:21.000
새로운 shippingType 속성을 통해 주문이 배송되는지 배송되는지 여부를 선언할 수 있습니다.

00:20:21.000 --> 00:20:27.000
우리는 이제 엔터프라이즈 앱을 포함한 관련 애플리케이션에 대한 더 나은 지원을 제공합니다.

00:20:27.000 --> 00:20:36.000
관련 애플리케이션 식별자를 선언함으로써, 앱과 주문 추적 간의 주문 알림 관리를 개선할 수 있습니다.

00:20:36.000 --> 00:20:45.000
또한, 우리는 사용자 지정 제품 페이지 식별자를 지원하여 지갑 트래픽과 가장 관련이 있는 App Store 제품 페이지에 대한 딥 링크를 가능하게 합니다.

00:20:45.000 --> 00:20:50.000
마지막으로, 우리는 지불 정보를 나타내는 새로운 방법을 소개하고 있습니다.

00:20:50.000 --> 00:20:59.000
주문 패키지는 이제 그것과 관련된 일련의 거래를 지원하며, 각각은 지불 방법 및 금액과 같은 자체 세부 정보를 가지고 있습니다.

00:20:59.000 --> 00:21:04.000
또한 거래에 영수증 파일을 첨부할 수 있으므로, 고객은 지불 기록을 가지고 있습니다.

00:21:04.000 --> 00:21:10.000
이 영수증 파일은 PDF 또는 JPEG 또는 PNG와 같은 이미지일 수 있습니다.

00:21:10.000 --> 00:21:17.000
주문 패키지는 크기가 제한되어 있으므로, 포함된 영수증 파일의 크기를 고려하십시오.

00:21:17.000 --> 00:21:22.000
이제 거래가 구매를 위한 것인지 아니면 환불을 위한 것인지 설명할 수도 있습니다.

00:21:22.000 --> 00:21:27.000
iOS 17을 사용하면 지갑에 주문을 추가하는 것이 그 어느 때보다 쉬워졌습니다.

00:21:27.000 --> 00:21:32.000
이제 주문 확인 이메일과 같은 이메일에 주문 패키지를 첨부할 수 있습니다.

00:21:32.000 --> 00:21:37.000
그러면 사용자는 바로 지갑에 주문을 추가할 수 있을 것이다.

00:21:37.000 --> 00:21:44.000
또한, 앱과 웹사이트 내에 "Apple Wallet으로 추적" 버튼을 추가할 수도 있습니다.

00:21:44.000 --> 00:21:50.000
지갑에 주문 추가를 지원하는 새로운 주문 추적 API를 살펴봅시다.

00:21:50.000 --> 00:21:56.000
이 API는 FinanceKit과 FinanceKitUI라는 두 가지 새로운 프레임워크에 포함되어 있습니다.

00:21:56.000 --> 00:22:02.000
이 두 스위프트 전용 프레임워크를 통해 개발자는 지갑 내에서 주문 데이터를 처리할 수 있습니다.

00:22:02.000 --> 00:22:11.000
주문 정보에 대한 액세스는 FinanceStore의 공유 인스턴스를 통해 이루어지며, 주문 추적 쿼리를 처리하기 위한 중앙 리소스를 제공합니다.

00:22:11.000 --> 00:22:18.000
이 API를 사용하면 주문의 존재와 주문을 추가하거나 업데이트하는 방법을 확인할 수 있습니다.

00:22:18.000 --> 00:22:22.000
기존 주문을 확인하는 방법을 살펴봅시다.

00:22:22.000 --> 00:22:30.000
먼저 FinanceStore에 문의하여 정규화된 주문 식별자가 있는 주문이 포함되어 있는지 확인합니다.

00:22:30.000 --> 00:22:35.000
그러면 당신은 그것이 존재하거나 발견되지 않은 두 개의 응답 중 하나를 받게 될 것입니다.

00:22:35.000 --> 00:22:38.000
그런 다음 앱에서 적절하게 응답할 수 있습니다.

00:22:38.000 --> 00:22:40.000
그건 그것만큼 간단해.

00:22:40.000 --> 00:22:44.000
주문을 추가하거나 업데이트하려면, 두 가지 방법 중 하나로 할 수 있습니다.

00:22:44.000 --> 00:22:48.000
우리는 먼저 당신이 이것을 하기 위해 FinanceKit을 어떻게 사용하는지 보여줄 것입니다.

00:22:48.000 --> 00:22:54.000
먼저 지갑에 추가하려는 서명된 주문 패키지의 데이터 직렬화가 필요합니다.

00:22:54.000 --> 00:22:58.000
그런 다음 이것을 FinanceStore의 저장 주문 방법에 제공합니다.

00:22:58.000 --> 00:23:05.000
이렇게 하면, 주문 내용과 지갑 내에서 추적하고 싶은지 여부를 확인하기 위해 사용자에게 화면이 표시됩니다.

00:23:05.000 --> 00:23:13.000
사용자가 요청을 확인하거나 거부하면, 비동기적으로 결과를 받게 되며, 세 가지 형태를 취할 수 있습니다.

00:23:13.000 --> 00:23:20.000
그들은 지갑에 주문을 추가했거나, 요청을 취소했거나, 새로운 주문이 이미 존재합니다.

00:23:20.000 --> 00:23:24.000
앱이 SwiftUI로 작성된 경우, FinanceKitUI를 사용할 수 있습니다.

00:23:24.000 --> 00:23:32.000
이것은 전용 "Apple Wallet으로 추적" 버튼을 제공하며 주문 추가 결과를 처리할 수 있습니다.

00:23:32.000 --> 00:23:38.000
FinanceKit과 마찬가지로, 먼저 서명된 주문 패키지의 직렬화된 인스턴스가 필요합니다.

00:23:38.000 --> 00:23:42.000
그런 다음 보기에 AddOrderToWalletButton을 포함합니다.

00:23:42.000 --> 00:23:48.000
사용자가 이 버튼을 선택하면, 지갑에 주문을 추가할 수 있는 기능이 제공됩니다.

00:23:48.000 --> 00:23:53.000
그러면 이전과 마찬가지로 세 가지 결과 상태에 응답할 수 있습니다.

00:23:53.000 --> 00:24:00.000
웹에서 주문을 추적하는 고객을 지원하고자 하는 상인을 위해, 우리는 자바스크립트 SDK에서 이 버튼의 버전을 제공합니다.

00:24:00.000 --> 00:24:06.000
이것을 사용하려면, 애플 지갑 버튼을 삽입하고 속성을 사용하여 구성하십시오.

00:24:06.000 --> 00:24:10.000
버튼의 유형은 트랙 순서로 설정되어야 합니다.

00:24:10.000 --> 00:24:18.000
이 버튼을 사용할 때, 추가하려는 서명된 주문 패키지의 위치를 가리키도록 onClick 콜백을 설정하는 것이 중요합니다.

00:24:18.000 --> 00:24:20.000
그리고 그것이 우리가 오늘 주문 추적에 대해 당신을 위해 가지고 있는 것입니다.

00:24:20.000 --> 00:24:25.000
우리는 당신이 당신의 앱과 서비스에 이 새로운 API를 채택하기를 기다릴 수 없습니다.

00:24:25.000 --> 00:24:34.000
그리고 이제 완전히 다른 것을 위해, 우리는 정체성과 관련하여 공유할 몇 가지 흥미로운 업데이트가 있으며, 그것을 위해 존에게 넘겨줄게.

00:24:34.000 --> 00:24:37.000
존: 고마워, 데이비드. 또 안녕.

00:24:37.000 --> 00:24:40.000
저는 애플 페이와 지갑 팀의 엔지니어인 존입니다.

00:24:40.000 --> 00:24:47.000
iOS 17에서 Identity를 위해 추가한 새로운 기능에 대해 이야기하게 되어 매우 기쁩니다.

00:24:47.000 --> 00:24:59.000
우리는 iOS 15.4에서 지갑에 ID를 도입하여 지원되는 미국 주의 사용자가 운전면허증이나 주 ID를 지갑에 추가할 수 있도록 했습니다.

00:24:59.000 --> 00:25:03.000
작년에, 우리는 Verify with Wallet을 도입했다.

00:25:03.000 --> 00:25:13.000
이 API를 통해 기업은 Apple Wallet에 저장된 사용자 ID의 정보를 요청하여 온보딩 및 계정 확인 흐름을 간소화할 수 있습니다.

00:25:13.000 --> 00:25:21.000
올해 iOS 17에서는 iPhone에서 Tap to Present ID를 소개합니다.

00:25:21.000 --> 00:25:31.000
이 API를 사용하면 앱은 iPhone만 사용하여 지갑 또는 기타 모바일 운전면허증의 ID를 원활하고 안전하게 확인할 수 있습니다.

00:25:31.000 --> 00:25:40.000
이것은 우리가 iOS 15.4의 ProximityReader 프레임워크에 추가한 Tap to Pay on iPhone API 위에 구축됩니다.

00:25:40.000 --> 00:25:51.000
iPhone에서 탭하여 결제하면 추가 하드웨어나 결제 단말기 없이도 비접촉식 결제를 받을 수 있는 안전하고 개인적이며 쉬운 방법을 제공합니다.

00:25:51.000 --> 00:25:55.000
이제, 실행 중인 Tap to Present ID를 살펴봅시다.

00:25:55.000 --> 00:26:01.000
내가 Spaceship Rentals에서 일하고 David가 우리에게서 우주선을 빌리고 싶다고 가정해 보자.

00:26:01.000 --> 00:26:10.000
그가 이것을 하려면 최소 21세 이상이어야 하므로, 나는 Tap to Present ID를 사용하여 연령 확인을 수행할 것이다.

00:26:10.000 --> 00:26:15.000
먼저, 우주선 대여 앱은 탭을 호출하여 ID를 제시합니다.

00:26:15.000 --> 00:26:24.000
내 아이폰은 비즈니스 이름, 로고 및 수행 중인 요청 유형, 이 경우 연령 증명을 보여줄 것이다.

00:26:24.000 --> 00:26:29.000
나는 이제 데이비드가 그의 아이폰을 내 근처에 두도록 초대할 것이다.

00:26:29.000 --> 00:26:36.000
데이비드: 이제 제 iPhone에 제가 검토할 수 있는 동의서가 표시됩니다.

00:26:36.000 --> 00:26:43.000
나는 내가 우주선 렌탈에 내 신분증을 제시하고 있다는 것을 알 수 있고, 그들은 내 신분증 사진과 내가 21세 이상인지 여부를 요청하고 있다.

00:26:43.000 --> 00:26:49.000
저는 이 정보를 제시할 의향이 있으므로, 두 번 클릭하고 Face ID로 확인하겠습니다.

00:26:49.000 --> 00:26:56.000
존: 내 아이폰은 이제 데이비드가 제시한 정보를 보여준다.

00:26:56.000 --> 00:27:01.000
나는 그가 그의 신분증 사진과 일치하고 그가 21세 이상이라는 것을 본다.

00:27:01.000 --> 00:27:05.000
그래서 이제 그는 이륙할 준비가 됐어.

00:27:05.000 --> 00:27:10.000
Tap to Present ID API를 사용하여 David의 ID를 성공적으로 확인했습니다.

00:27:10.000 --> 00:27:16.000
이 경험은 실제 신분증을 확인하는 것에 비해 몇 가지 주요 이점을 제공했다.

00:27:16.000 --> 00:27:20.000
먼저, ID 정보 자체가 확인된다.

00:27:20.000 --> 00:27:34.000
변조에 취약한 물리적 ID와 달리, 모바일 운전면허증은 발급 기관에 의해 암호화로 서명되며, iOS는 서명을 확인하므로 응답을 신뢰할 수 있습니다.

00:27:34.000 --> 00:27:38.000
둘째, 그 경험은 무선이고 안전했다.

00:27:38.000 --> 00:27:49.000
데이비드는 그의 아이폰을 나에게 넘겨주거나 잠금을 해제할 필요가 없었고, 데이터는 NFC와 블루투스를 사용하여 안전하게 전송되었다.

00:27:49.000 --> 00:27:53.000
마지막으로, 이것은 신분증을 확인하는 더 사적인 방법이다.

00:27:53.000 --> 00:28:01.000
데이비드는 모든 것이 공유되는 물리적 신분증과 달리 나이를 확인하는 데 필요한 정보만 공유할 필요가 있었다.

00:28:01.000 --> 00:28:06.000
이 API로 수행할 수 있는 요청 유형에 대해 이야기해 봅시다.

00:28:06.000 --> 00:28:08.000
우리는 방금 디스플레이 요청을 시연했다.

00:28:08.000 --> 00:28:13.000
이것은 사람의 이름이나 나이를 확인해야 할 때 적합합니다.

00:28:13.000 --> 00:28:20.000
결과는 시스템 UI에 표시되며, ID 정보는 앱에 반환되지 않습니다.

00:28:20.000 --> 00:28:23.000
API는 또한 데이터 요청을 지원합니다.

00:28:23.000 --> 00:28:35.000
이것들은 주소, 생년월일 및 운전 권한과 같은 더 넓은 문서 요소를 요청할 수 있으며, 결과는 처리하기 위해 앱으로 반환됩니다.

00:28:35.000 --> 00:28:40.000
데이터 요청을 수행하려면, 앱에 추가 자격이 필요합니다.

00:28:40.000 --> 00:28:44.000
자세한 내용은 문서를 확인하세요.

00:28:44.000 --> 00:28:52.000
이제, 디스플레이 요청부터 시작하여 코드에서 이것을 구현하는 방법을 살펴봅시다.

00:28:52.000 --> 00:29:01.000
먼저, MobileDocumentReader의 isSupported 클래스 속성을 사용하여 현재 장치가 이 API를 지원하는지 확인하십시오.

00:29:01.000 --> 00:29:07.000
만약 그렇다면, 리더 객체를 인스턴스화하고 준비 메소드를 호출하세요.

00:29:07.000 --> 00:29:11.000
이것은 MobileDocumentReaderSession 객체를 반환할 것이다.

00:29:11.000 --> 00:29:17.000
다음으로, 확인하려는 요소로 운전면허증 표시 요청을 만드세요.

00:29:17.000 --> 00:29:24.000
여기서, 저는 운전면허증 소지자가 최소 21세 이상인지 확인하고 있습니다.

00:29:24.000 --> 00:29:29.000
그런 다음 세션에서 requestDocument를 호출하여 요청을 전달하세요.

00:29:29.000 --> 00:29:39.000
그런 다음 리더 UI가 표시되며, 먼저 ID 보유자에게 장치를 제시하라는 메시지를 표시한 다음 요청 결과를 표시합니다.

00:29:39.000 --> 00:29:46.000
이것은 디스플레이 요청이기 때문에 requestDocument 메소드에서 아무것도 반환되지 않는다는 것을 명심하세요.

00:29:46.000 --> 00:29:52.000
그리고 단 몇 줄의 코드로, 당신은 앱에 모바일 문서 읽기 기능을 추가했습니다.

00:29:52.000 --> 00:30:00.000
기본적으로, 브랜드의 이름과 로고는 리더 아이폰이나 ID 소지자의 장치에 표시되지 않습니다.

00:30:00.000 --> 00:30:06.000
그러나, 문서 요청 중에 브랜드 정보를 표시하고 싶다면, 할 수 있습니다.

00:30:06.000 --> 00:30:12.000
이것은 Apple Business Register를 통해 몇 줄의 코드로 구성할 수 있습니다.

00:30:12.000 --> 00:30:20.000
문서 요청 중에 브랜드 정보를 표시하려면, 장치를 준비할 때 리더 토큰을 전달해야 합니다.

00:30:20.000 --> 00:30:24.000
서버에서 이 토큰을 만들어야 합니다.

00:30:24.000 --> 00:30:32.000
리더 토큰은 Apple Business Register를 통해 구성한 키 쌍으로 서명된 JWT입니다.

00:30:32.000 --> 00:30:40.000
서버는 브랜드 ID, 키 ID 및 리더 인스턴스 식별자로 리더 토큰을 생성합니다.

00:30:40.000 --> 00:30:50.000
브랜드와 키 ID는 Apple Business Register를 통해 얻을 수 있으며 앱의 모든 인스턴스에서 동일합니다.

00:30:50.000 --> 00:30:55.000
당신의 앱은 당신의 서버에 리더 인스턴스 식별자를 제공할 것입니다.

00:30:55.000 --> 00:31:08.000
코드로 돌아가서, 앱은 MobileDocumentReader의 구성 객체에서 리더 인스턴스 식별자를 가져와 리더 토큰을 대가로 서버로 보냅니다.

00:31:08.000 --> 00:31:13.000
리더 세션을 얻기 위해 이 토큰을 준비 방법으로 전달하세요.

00:31:13.000 --> 00:31:19.000
그런 다음 요청을 만들고 이전과 같이 requestDocument를 호출하세요.

00:31:19.000 --> 00:31:26.000
그리고 이제 당신의 브랜드 이름과 로고는 리더 아이폰과 ID 홀더의 장치 모두에 표시됩니다.

00:31:26.000 --> 00:31:29.000
그리고 그것은 디스플레이 요청을 다룹니다.

00:31:29.000 --> 00:31:37.000
지금까지, 우리는 세션을 준비하고, 문서를 요청하고, 리더 토큰을 사용하여 브랜딩 정보를 표시하는 방법을 살펴보았습니다.

00:31:37.000 --> 00:31:41.000
이제 데이터 요청을 수행하는 방법을 살펴봅시다.

00:31:41.000 --> 00:31:51.000
이러한 요청은 더 넓은 범위의 문서 요소를 지원하며, API는 단순히 표시하는 대신 앱에 결과를 반환합니다.

00:31:51.000 --> 00:31:59.000
이 요청 유형을 사용하려면, 먼저 이전과 마찬가지로 리더 토큰으로 장치를 준비해야 합니다.

00:31:59.000 --> 00:32:11.000
그런 다음 운전면허증 데이터 요청을 생성하고, 요청할 문서 요소와 정보를 보유할 것인지 여부를 지정하십시오.

00:32:11.000 --> 00:32:21.000
Calling requestDocument는 디스플레이 요청과 마찬가지로 리더 UI를 표시하지만, 읽기가 완료되면 UI는 자동으로 해제됩니다.

00:32:21.000 --> 00:32:26.000
그런 다음 응답은 처리하기 위해 앱으로 돌아갑니다.

00:32:26.000 --> 00:32:33.000
그리고 그것은 우리가 ProximityReader 프레임워크에 추가한 흥미진진한 새로운 API인 iPhone의 Tap to Present ID입니다.

00:32:33.000 --> 00:32:36.000
그리고 이제, 데이비드에게 돌아가.

00:32:36.000 --> 00:32:39.000
데이비드: 고마워 존! 그래서 우리는 오늘 무엇을 배웠나요?

00:32:39.000 --> 00:32:45.000
우리는 Apple Pay Later와 새로운 사용 사례에 대한 지원을 통해 결제 개선 사항을 살펴보았습니다.

00:32:45.000 --> 00:32:57.000
주문 추적의 새로운 API를 사용하면 앱과 서비스 내에서 지갑에 주문을 추가할 수 있으며, iPhone에서 Tap to Present ID로 모바일 운전면허증을 확인하는 새로운 방법이 있습니다.

00:32:57.000 --> 00:33:02.000
마무리하기 위해, 만약 당신이 사업체라면, Apple Business Register에 등록하는 것을 고려해 보세요.

00:33:02.000 --> 00:33:06.000
이것은 고객의 지갑과 Apple Pay 경험을 풍요롭게 하는 데 도움이 될 것입니다.

00:33:06.000 --> 00:33:12.000
일년 내내 질문을 하고 도움을 받을 수 있는 Apple Developer 포럼을 방문할 수 있습니다.

00:33:12.000 --> 00:33:16.000
그리고 마지막으로, 피드백이 있다면, 우리는 당신의 의견을 듣고 싶습니다.

00:33:16.000 --> 00:33:19.000
피드백 어시스턴트를 사용하여 이것을 할 수 있습니다.

00:33:19.000 --> 00:33:22.000
그리고 그게 다야. 우리는 당신이 이 세션을 즐겼기를 바랍니다.

00:33:22.000 --> 00:33:23.000
둘 다: 봐줘서 고마워.

00:33:23.000 --> 23:59:59.000
♪ ♪

