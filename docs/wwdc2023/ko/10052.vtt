WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:12.000
아담: 안녕하세요, 저는 아담입니다.

00:00:12.000 --> 00:00:18.000
이 비디오에서, 저는 당신의 앱이 사람들이 캘린더와 EventKit으로 시간을 관리하는 데 어떻게 도움이 될 수 있는지 다룰 것입니다.

00:00:18.000 --> 00:00:26.000
먼저, 앱이 캘린더와 통합되고 관련된 프레임워크에 대한 개요를 제공할 수 있는 몇 가지 방법을 살펴볼 것입니다.

00:00:26.000 --> 00:00:41.000
그런 다음 이러한 프레임워크를 사용하여 이벤트 추가, 전체 액세스로 이벤트 가져오기, 가상 회의 확장 구현과 같은 일반적인 기능을 구현하는 방법에 대한 몇 가지 구체적인 예를 살펴보겠습니다.

00:00:41.000 --> 00:00:48.000
사람들은 시간을 추적하고 미래를 계획하기 위해 달력에 의존하지만, 달력은 하나의 앱 그 이상이다.

00:00:48.000 --> 00:00:58.000
캘린더와 통합할 때 앱이 채울 수 있는 다양한 역할이 있으며, 결합할 때 이러한 다양한 역할은 더 풍부한 캘린더 경험을 제공합니다.

00:00:58.000 --> 00:01:04.000
일부 앱은 예약, 티켓 구매 또는 모임 준비를 지원합니다.

00:01:04.000 --> 00:01:07.000
그들은 이벤트를 추가하여 참여한다.

00:01:07.000 --> 00:01:15.000
일부 앱은 사용자 지정 캘린더 위젯이나 플래너를 위해 이벤트를 표시하여 참여합니다.

00:01:15.000 --> 00:01:18.000
다른 앱들은 양방향으로 기여한다.

00:01:18.000 --> 00:01:24.000
그들은 사람들이 이벤트를 보고 편집함으로써 일정을 관리할 수 있도록 돕는다.

00:01:24.000 --> 00:01:29.000
음성 또는 화상 통화를 지원하는 앱도 참여할 수 있습니다.

00:01:29.000 --> 00:01:39.000
가상 회의 확장 프로그램은 캘린더 앱의 경험을 향상시킬 뿐만 아니라 앱으로 바로 가기를 제공합니다.

00:01:39.000 --> 00:01:44.000
이 모든 것은 시간을 관리하기 위한 응집력 있는 경험을 제공하기 위해 함께 어울린다.

00:01:44.000 --> 00:01:51.000
나중에, 나는 이 각 영역에서 시작하기 위해 몇 가지 구체적인 예를 살펴볼 것이다.

00:01:51.000 --> 00:01:56.000
캘린더와 통합하는 데 사용할 수 있는 두 가지 프레임워크가 있습니다.

00:01:56.000 --> 00:02:00.000
EventKit 프레임워크는 달력 데이터로 직접 작업하는 데 사용됩니다.

00:02:00.000 --> 00:02:09.000
EventKitUI는 앱에 캘린더 UI를 표시하기 위한 뷰 컨트롤러를 제공하는 iOS 및 Mac Catalyst 프레임워크입니다.

00:02:09.000 --> 00:02:13.000
각각을 좀 더 자세히 살펴봅시다...

00:02:13.000 --> 00:02:17.000
EventKit의 몇 가지 기본 유형으로 시작합니다.

00:02:17.000 --> 00:02:22.000
EKEventStore는 당신의 달력 데이터의 주요 연락처입니다.

00:02:22.000 --> 00:02:27.000
이벤트 스토어를 사용하여 액세스를 요청하고 가져오거나 저장합니다.

00:02:27.000 --> 00:02:31.000
당신은 당신의 지원서를 위해 이것들 중 하나만 가지고 있어야 합니다.

00:02:31.000 --> 00:02:40.000
EKEvent 클래스는 특정 이벤트를 나타내며, 제목, 시작 날짜, 종료 날짜 및 위치와 같은 속성을 가지고 있습니다.

00:02:40.000 --> 00:02:46.000
각 이벤트는 EKCalendar 클래스로 표시되는 달력에 속한다.

00:02:46.000 --> 00:02:52.000
달력에는 제목과 색상이 있어 이벤트를 색칠하는 데 유용할 수 있습니다.

00:02:52.000 --> 00:02:58.000
마지막으로, 각 달력 계정은 달력 모음인 EKSource로 표시됩니다.

00:02:58.000 --> 00:03:04.000
소스는 UI에서 달력을 그룹화하는 데 유용합니다.

00:03:04.000 --> 00:03:08.000
EventKit은 달력 데이터와 상호 작용하기 위한 기본 프레임워크이다.

00:03:08.000 --> 00:03:15.000
EventKitUI는 유용한 내장 뷰를 제공하기 위해 EventKit 위에 구축되었습니다.

00:03:15.000 --> 00:03:19.000
EventKitUI가 제공하는 세 개의 뷰 컨트롤러가 있습니다.

00:03:19.000 --> 00:03:24.000
EKEventEditViewController는 이벤트 편집기를 보여줍니다.

00:03:24.000 --> 00:03:30.000
이것을 사용하여 새 이벤트를 추가하거나 기존 이벤트를 변경하세요.

00:03:30.000 --> 00:03:34.000
EKEventViewController는 이벤트 세부 사항을 보여줍니다.

00:03:34.000 --> 00:03:39.000
이것을 사용하여 앱에 기존 이벤트에 대한 정보를 표시하세요.

00:03:39.000 --> 00:03:46.000
그리고 EKCalendarChooser는 달력 목록을 표시하고 단일 선택 또는 다중 선택을 지원합니다.

00:03:46.000 --> 00:03:55.000
이것을 사용하여 사람들이 캘린더를 선택하여 이벤트를 추가하거나 앱에서 볼 수 있는 캘린더를 선택할 수 있습니다.

00:03:55.000 --> 00:04:02.000
캘린더는 비공개이므로, 시스템은 앱이 허가 없이 캘린더 이벤트를 읽거나 쓰는 것을 방지합니다.

00:04:02.000 --> 00:04:12.000
앱이 캘린더에 대해 가질 수 있는 세 가지 수준의 액세스가 있습니다: 액세스 없음, 쓰기 전용 액세스 또는 전체 액세스.

00:04:12.000 --> 00:04:19.000
캘린더 액세스 권한이 없는 앱은 EventKitUI 또는 Siri 이벤트 제안을 사용하여 이벤트를 추가할 수 있습니다.

00:04:19.000 --> 00:04:25.000
쓰기 전용 액세스 권한이 있는 앱은 EventKit을 사용하여 직접 이벤트를 추가할 수 있습니다.

00:04:25.000 --> 00:04:36.000
그리고 전체 액세스 권한이 있는 앱은 기존 이벤트를 가져오거나 수정하고, 기존 캘린더에 액세스하고, 새 캘린더를 만들 수 있습니다.

00:04:36.000 --> 00:04:42.000
캘린더와 통합하는 가장 일반적인 방법 중 하나는 새로운 이벤트를 추가하는 것이다.

00:04:42.000 --> 00:04:46.000
이벤트는 몇 가지 다른 방법으로 달력에 추가할 수 있습니다.

00:04:46.000 --> 00:04:51.000
EventKitUI 또는 Siri 이벤트 제안을 사용하여 한 번에 하나의 이벤트를 추가하세요.

00:04:51.000 --> 00:04:56.000
또는 이벤트를 직접 저장하려면, EventKit을 사용하세요.

00:04:56.000 --> 00:05:02.000
달력에 이벤트를 추가하는 가장 간단한 방법은 EventKitUI가 대부분의 작업을 수행하도록 하는 것입니다.

00:05:02.000 --> 00:05:08.000
이벤트 세부 정보가 채워진 편집기를 보여주기 위해 EKEventEditViewController를 제시하세요.

00:05:08.000 --> 00:05:15.000
이것은 사람들에게 이벤트를 저장할지 여부를 결정하기 전에 달력을 선택하거나 다른 변경을 할 수 있는 기회를 제공한다.

00:05:15.000 --> 00:05:25.000
iOS 17에서 이 UI는 별도의 프로세스에서 실행되며, 이는 캘린더 액세스를 요청할 필요가 없다는 것을 의미합니다.

00:05:25.000 --> 00:05:29.000
EventKitUI로 이벤트를 추가하는 것은 4단계 과정이다.

00:05:29.000 --> 00:05:32.000
먼저, 이벤트 스토어를 만드세요.

00:05:32.000 --> 00:05:36.000
다음으로, 이벤트를 만들고 세부 사항을 입력하십시오.

00:05:36.000 --> 00:05:41.000
그런 다음 이벤트를 편집하도록 구성된 뷰 컨트롤러를 만드세요.

00:05:41.000 --> 00:05:45.000
그리고 마지막으로, 뷰 컨트롤러를 제시하세요.

00:05:45.000 --> 00:05:48.000
몇 가지 코드로 이것을 좀 더 자세히 살펴봅시다.

00:05:48.000 --> 00:05:52.000
이벤트스토어를 만드는 것으로 시작하세요.

00:05:52.000 --> 00:05:56.000
다음으로, 이벤트를 만들고 세부 사항을 입력하십시오.

00:05:56.000 --> 00:06:00.000
여기서 설정한 세부 사항은 편집기 UI에서 사용됩니다.

00:06:00.000 --> 00:06:12.000
편집자가 제시되면, 사람들은 변경할 수 있는 기회를 갖게 되지만, 이상적으로는 추가 버튼을 눌러 확인할 수 있으므로 올바른 세부 사항을 작성하면 시간을 절약할 수 있습니다.

00:06:12.000 --> 00:06:15.000
모든 행사에는 제목이 필요하다.

00:06:15.000 --> 00:06:22.000
제목은 위젯과 알림을 포함한 많은 곳에서 사용되므로, 간단하게 유지하세요.

00:06:22.000 --> 00:06:26.000
가장 중요한 속성은 시작일과 종료일이다.

00:06:26.000 --> 00:06:30.000
날짜 구성 요소를 사용하여 시작 날짜를 만드세요.

00:06:30.000 --> 00:06:36.000
시작 날짜가 있으면, 기간을 추가하여 종료 날짜를 계산하세요.

00:06:36.000 --> 00:06:44.000
날짜 수학을 위해 재단의 달력과 DateComponents 유형을 사용하세요. 그렇지 않으면 일광 절약 시간제에 놀라운 결과를 얻을 수 있습니다.

00:06:44.000 --> 00:06:49.000
여기서 샘플은 우리의 시작 날짜에 두 시간을 더한다.

00:06:49.000 --> 00:06:54.000
이벤트가 특정 시간대에서 일어난다면, 그것도 설정해야 합니다.

00:06:54.000 --> 00:06:59.000
기본 시간대는 현재 시스템 시간대가 될 것이다.

00:06:59.000 --> 00:07:03.000
사람들에게 행사가 어디서 열리는지 알 수 있도록 장소를 설정하세요.

00:07:03.000 --> 00:07:12.000
전체 주소를 포함하거나 MapKit 핸들을 사용하면 지도 제안 및 알림 남기기 시간과 같은 기능을 사용할 수 있습니다.

00:07:12.000 --> 00:07:17.000
마지막으로, 추가 세부 사항을 제공하기 위해 몇 가지 메모를 추가하세요.

00:07:17.000 --> 00:07:23.000
이벤트 속성을 설정하면, 다음 단계는 EKEventEditViewController를 만드는 것입니다.

00:07:23.000 --> 00:07:27.000
이벤트와 이벤트 스토어 속성을 할당하세요.

00:07:27.000 --> 00:07:31.000
편집기에서, 사람들은 이벤트를 추가하거나 취소할 수 있다.

00:07:31.000 --> 00:07:40.000
그들이 이벤트를 추가했는지 알고 싶다면, 위임 속성을 사용하고 EKEventEditViewDelegate 프로토콜을 구현하십시오.

00:07:40.000 --> 00:07:43.000
마지막으로, 편집자를 소개합니다.

00:07:43.000 --> 00:07:47.000
이 시점에서, 그 행사는 아직 달력에 없다.

00:07:47.000 --> 00:07:56.000
추가 버튼을 누르면 저장되고, 취소를 누르면 아무것도 저장하지 않고 편집기가 닫힙니다.

00:07:56.000 --> 00:08:07.000
EventKitUI로 이벤트를 추가하는 더 완전한 예를 보려면, "EventKit 및 EventKitUI를 사용하여 캘린더 액세스" 샘플 코드에서 "DropInLessons" 대상을 확인하세요.

00:08:07.000 --> 00:08:14.000
캘린더에 이벤트를 추가하는 또 다른 방법은 앱에서 예약 시리 이벤트 제안을 사용하는 것입니다.

00:08:14.000 --> 00:08:18.000
Siri 이벤트 제안 API는 인텐트 프레임워크의 일부입니다.

00:08:18.000 --> 00:08:24.000
캘린더 액세스 프롬프트가 필요하지 않으며, 앱에 UI가 표시되지 않습니다.

00:08:24.000 --> 00:08:29.000
대신, 이 이벤트들은 초대장처럼 달력 받은 편지함에 나타날 것이다.

00:08:29.000 --> 00:08:34.000
그런 다음 그것들은 달력에 추가되거나 무시될 수 있다.

00:08:34.000 --> 00:08:47.000
Siri 이벤트 제안은 레스토랑이나 호텔 예약, 항공편이나 렌터카와 같은 여행 예약, 콘서트나 스포츠 이벤트와 같은 티켓 이벤트를 지원합니다.

00:08:47.000 --> 00:08:53.000
예약이 나중에 취소되거나 수정되면, 이벤트를 업데이트할 수 있습니다.

00:08:53.000 --> 00:08:58.000
Siri 이벤트 제안 API를 사용하는 것은 4단계 과정입니다.

00:08:58.000 --> 00:09:02.000
먼저, INReservation을 만드세요.

00:09:02.000 --> 00:09:07.000
그런 다음, 의도와 응답으로 예약을 마무리하세요.

00:09:07.000 --> 00:09:10.000
다음으로, INInteraction을 만드세요.

00:09:10.000 --> 00:09:14.000
마지막으로, 상호 작용을 시스템에 기부하세요.

00:09:14.000 --> 00:09:17.000
샘플 코드에 대해 자세히 알아봅시다.

00:09:17.000 --> 00:09:23.000
예약은 시스템이 그것을 식별하는 데 사용할 고유한 참조를 필요로 한다.

00:09:23.000 --> 00:09:32.000
고유한 어휘 식별자와 음성 문구로 INSpeakableString의 인스턴스를 만들어 참조를 만드세요.

00:09:32.000 --> 00:09:37.000
이 문구는 Siri와 대화할 때 이 예약을 참조하는 데 사용할 수 있습니다.

00:09:37.000 --> 00:09:45.000
INDateComponentsRange를 사용하여 예약 시작 및 종료 시간을 설정하십시오.

00:09:45.000 --> 00:09:51.000
CLPlacemark 유형을 사용하여 이벤트에 위치를 지정하세요.

00:09:51.000 --> 00:09:57.000
그런 다음, INReservation의 하위 클래스 중 하나의 인스턴스를 만들어 모든 것을 합치세요.

00:09:57.000 --> 00:10:03.000
레스토랑 예약은 INRestaurantReservation을 사용하세요.

00:10:03.000 --> 00:10:10.000
이 이니셜라이저에는 표시되지 않은 몇 가지 선택적 인수가 더 있으며, 각 서브클래스에는 고유한 특정 옵션이 있습니다.

00:10:10.000 --> 00:10:15.000
더 알아보려면 문서를 확인하세요.

00:10:15.000 --> 00:10:22.000
다음 단계는 예약 참조와 함께 INGetReservationDetailsIntent를 만드는 것입니다.

00:10:22.000 --> 00:10:31.000
그런 다음 예약 객체로 INGetReservationDetailsIntentResponse를 만드세요.

00:10:31.000 --> 00:10:37.000
다음으로, 의도와 응답으로 INInteraction을 만드세요.

00:10:37.000 --> 00:10:43.000
마지막으로, 상호 작용의 기부 방법을 호출하세요.

00:10:43.000 --> 00:10:49.000
이 예시는 Siri 이벤트 제안으로 할 수 있는 일의 표면만 긁는다.

00:10:49.000 --> 00:10:59.000
Siri 이벤트 제안 만들기에 대한 자세한 내용은 WWDC20의 "Broaden your reach with Siri Event Suggestions" 비디오를 확인하세요.

00:10:59.000 --> 00:11:04.000
EventKitUI 또는 Siri 이벤트 제안은 이벤트를 추가하기 위한 최고의 경험을 제공합니다.

00:11:04.000 --> 00:11:17.000
앱이 사용자 지정 편집 UI를 표시하거나, 동시에 여러 이벤트를 추가하거나, 사용자 상호 작용 없이 캘린더에 이벤트를 추가해야 하는 경우에만 쓰기 전용 액세스를 사용하세요.

00:11:17.000 --> 00:11:29.000
쓰기 전용 액세스를 요청하려면 Info.plist에 NSCalendarsWriteOnlyAccess UsageDescription 키를 포함하여 앱에 액세스가 필요한 이유를 설명하십시오.

00:11:29.000 --> 00:11:32.000
이 문자열은 요청 프롬프트에 표시됩니다.

00:11:32.000 --> 00:11:39.000
여기 샘플 응용 프로그램에 대한 프롬프트가 있습니다: "반복 수업을 선택한 달력에 저장하세요."

00:11:39.000 --> 00:11:43.000
쓰기 전용 접근 또한 몇 가지 제한이 있다.

00:11:43.000 --> 00:11:47.000
예를 한, 사람들은 접근을 허용하지 않기로 선택할 수 있다.

00:11:47.000 --> 00:11:57.000
액세스 권한이 부여되면, 앱은 여전히 동일한 앱에서 추가된 이벤트를 포함하여 캘린더에서 기존 이벤트를 읽을 수 없습니다.

00:11:57.000 --> 00:12:02.000
이 앱은 또한 달력 목록을 읽거나 새 달력을 만들 수 없습니다.

00:12:02.000 --> 00:12:06.000
쓰기 전용 액세스는 iOS 17과 macOS Sonoma의 새로운 기능입니다.

00:12:06.000 --> 00:12:16.000
이것이 기존 앱에 어떤 영향을 미치는지 자세히 알아보려면, "개인 정보 보호의 새로운 기능" 비디오를 확인하세요.

00:12:16.000 --> 00:12:22.000
쓰기 전용 액세스로 새 이벤트를 추가하는 것은 EventKitUI를 사용하여 새 이벤트를 추가하는 것과 비슷해 보일 것이다.

00:12:22.000 --> 00:12:25.000
그것은 똑같이 시작한다: 이벤트 스토어를 만드세요.

00:12:25.000 --> 00:12:29.000
그런 다음 쓰기 전용 액세스를 요청하세요.

00:12:29.000 --> 00:12:34.000
접근이 허용되면, 새 이벤트를 만들고 세부 사항을 입력하십시오.

00:12:34.000 --> 00:12:37.000
마지막으로, 이벤트를 저장하세요.

00:12:37.000 --> 00:12:40.000
좀 더 자세히 확인해 봅시다.

00:12:40.000 --> 00:12:43.000
이벤트 스토어를 만드는 것으로 시작하세요.

00:12:43.000 --> 00:12:50.000
그런 다음, requestWriteOnlyAccessToEvents 메소드를 호출하여 쓰기 전용 액세스를 요청하십시오.

00:12:50.000 --> 00:12:54.000
반환 값은 접근이 허용되었는지 여부를 나타냅니다.

00:12:54.000 --> 00:12:59.000
사람들은 접근을 거부하기로 선택할 수 있으므로, 그것을 우아하게 처리해야 합니다.

00:12:59.000 --> 00:13:11.000
액세스 요청은 사람들이 당신의 앱에 액세스가 필요한 이유를 이해할 때 승인될 가능성이 가장 높기 때문에, 누군가가 그것을 필요로 하는 기능과 처음 상호 작용했을 때 액세스를 요청해야 합니다.

00:13:11.000 --> 00:13:15.000
다음으로, 이벤트를 만들고 세부 사항을 입력하십시오.

00:13:15.000 --> 00:13:18.000
여기에 또 다른 중요한 차이가 있다.

00:13:18.000 --> 00:13:27.000
EventKitUI를 사용할 때, 입력한 세부 사항은 편집기에 표시되며, 입력되지 않은 것은 기본값을 얻습니다.

00:13:27.000 --> 00:13:32.000
EventKit으로 직접 이벤트를 저장할 때, 아무것도 채워지지 않을 것입니다.

00:13:32.000 --> 00:13:35.000
당신이 설정한 것은 저장될 것입니다.

00:13:35.000 --> 00:13:41.000
채워야 하는 몇 가지 속성이 있습니다. 그렇지 않으면 저장이 실패할 것입니다.

00:13:41.000 --> 00:13:44.000
필요한 재산 중 하나는 달력이다.

00:13:44.000 --> 00:13:52.000
이벤트 스토어의 defaultCalendarForNewEvents 속성을 사용하여 설정에서 기본값으로 구성된 캘린더를 사용하세요.

00:13:52.000 --> 00:13:58.000
다른 필수 속성은 제목, 시작 날짜 및 종료 날짜입니다.

00:13:58.000 --> 00:14:05.000
다른 모든 것은 선택 사항이지만, 가능한 한 많이 작성하는 것이 좋다.

00:14:05.000 --> 00:14:12.000
세부 사항이 채워지면, 이벤트 저장소의 저장 방법을 사용하여 이벤트를 저장하세요.

00:14:12.000 --> 00:14:23.000
EventKit으로 이벤트를 추가하는 전체 예를 보려면, "EventKit 및 EventKitUI를 사용하여 캘린더 액세스" 샘플 프로젝트에서 "RepeatingLessons" 대상을 확인하세요.

00:14:23.000 --> 00:14:31.000
캘린더에 이벤트를 추가하려는 앱은 EventKitUI, Siri 이벤트 제안 또는 쓰기 전용 액세스를 사용해야 합니다.

00:14:31.000 --> 00:14:38.000
달력 데이터를 읽어야 하는 극소수의 앱의 경우, 전체 액세스 권한이 있습니다.

00:14:38.000 --> 00:14:48.000
앱에 기존 이벤트를 표시, 업데이트 또는 제거해야 하는 핵심 기능이 있는 경우에만 전체 액세스를 요청하십시오.

00:14:48.000 --> 00:14:57.000
전체 액세스를 요청하려면 Info.plist에 NSCalendars FullAccessUsageDescription 키를 포함하십시오.

00:14:57.000 --> 00:15:00.000
이 문자열은 요청 프롬프트에 표시됩니다.

00:15:00.000 --> 00:15:07.000
달력에는 민감한 정보가 포함되어 있으며, 전체 액세스 프롬프트는 얼마나 많은 데이터가 포함되어 있는지 설명합니다.

00:15:07.000 --> 00:15:12.000
사람들이 앱이 달력을 읽을 수 있도록 허용하는 데는 많은 신뢰가 필요하다.

00:15:12.000 --> 00:15:17.000
사람들이 아직 당신의 앱을 신뢰하지 않는다면, 요청이 거부될 수 있습니다.

00:15:17.000 --> 00:15:28.000
앱의 핵심 경험에 필수적인 경우에만 전체 액세스를 요청하고, 액세스가 필요한 이유가 명확한 경우에만 요청하십시오.

00:15:28.000 --> 00:15:34.000
앱이 핵심 기능에 대한 전체 액세스가 필요한 경우, 이벤트를 가져와야 할 것입니다.

00:15:34.000 --> 00:15:38.000
이렇게 하려면, 먼저 이벤트 스토어를 만드세요.

00:15:38.000 --> 00:15:41.000
다음으로, 전체 액세스를 요청하세요.

00:15:41.000 --> 00:15:44.000
그런 다음, 술어자를 만드세요.

00:15:44.000 --> 00:15:48.000
그리고 마지막으로, 이벤트 스토어에서 이벤트를 가져오세요.

00:15:48.000 --> 00:15:50.000
그것에 대한 코드를 확인해 봅시다.

00:15:50.000 --> 00:15:55.000
다른 예시와 마찬가지로, 이벤트 스토어를 만드는 것부터 시작하세요.

00:15:55.000 --> 00:15:59.000
앱에는 하나의 이벤트 스토어만 있어야 하므로, 이것을 재사용해야 합니다.

00:15:59.000 --> 00:16:05.000
다음으로, requestFullAccessToEvents 메소드를 호출하여 전체 액세스를 요청하세요.

00:16:05.000 --> 00:16:10.000
이것은 프롬프트를 보여주고 접근이 허용되었는지 여부를 반환할 것이다.

00:16:10.000 --> 00:16:15.000
전체 액세스 프롬프트는 더 자주 거부될 것이므로, 반드시 처리해야 합니다.

00:16:15.000 --> 00:16:22.000
전체 액세스 권한이 있으면, 이벤트 저장소의 predicateForEvents 메소드를 호출하여 조건자를 만드세요.

00:16:22.000 --> 00:16:28.000
조건자는 날짜 범위와 선택적 달력 목록으로 가져오고 싶은 이벤트를 설명합니다.

00:16:28.000 --> 00:16:32.000
이 코드는 현재 달의 범위를 사용합니다.

00:16:32.000 --> 00:16:36.000
최고의 성능을 위해 가능한 최단 범위를 사용하세요.

00:16:36.000 --> 00:16:42.000
달력 인수를 0으로 남겨두면, 결과에는 모든 달력의 이벤트가 포함됩니다.

00:16:42.000 --> 00:16:51.000
마지막으로, 일치하는 이벤트 배열을 반환하는 이벤트 저장소의 events(matching:) 메서드에 조건자를 전달하여 이벤트를 가져옵니다.

00:16:51.000 --> 00:16:57.000
이 배열의 이벤트가 반드시 정렬된 것은 아니므로, 필요한 경우 결과를 정렬하세요.

00:16:57.000 --> 00:17:10.000
이벤트 가져오기의 전체 예제를 가지고 놀고 싶다면, "EventKit 및 EventKitUI를 사용하여 캘린더 액세스" 샘플 프로젝트에서 "MonthlyEvents" 대상을 확인하세요.

00:17:10.000 --> 00:17:17.000
iOS 17 및 macOS Sonoma 이전 릴리스를 지원하려면 런타임 가용성 확인을 수행하십시오.

00:17:17.000 --> 00:17:24.000
iOS 17과 macOS Sonoma 이상에서 새로운 requestAccess 메소드를 호출하세요.

00:17:24.000 --> 00:17:30.000
이전 OS에서, 레거시 requestAccess 메소드를 호출하세요.

00:17:30.000 --> 00:17:36.000
iOS 17 또는 macOS Sonoma 이전에 추가 사용 문자열이 필요합니다.

00:17:36.000 --> 00:17:42.000
달력 액세스를 요청하기 위한 NSCalendarsUsageDescription 키를 포함하세요.

00:17:42.000 --> 00:17:54.000
EventKitUI를 사용하는 앱은 EventKitUI가 앱에 대한 연락처 액세스를 요청하기 때문에 NSContactsUsageDescription 키를 포함해야 합니다.

00:17:54.000 --> 00:18:01.000
앱이 액세스를 요청할 때 이 문자열을 놓치면, 충돌할 것이다.

00:18:01.000 --> 00:18:10.000
지금까지 우리는 이벤트를 추가하는 몇 가지 방법과 이벤트를 가져오는 방법을 다루었지만, 이벤트로 작업하는 것이 캘린더와 통합하는 유일한 방법은 아닙니다.

00:18:10.000 --> 00:18:19.000
앱이 음성 또는 화상 통화를 지원하는 경우, 가상 회의 확장 프로그램을 사용하여 사람들이 당신의 통화를 이벤트에 직접 추가할 수 있도록 하세요.

00:18:19.000 --> 00:18:23.000
이 확장을 사용하는 방법에는 두 가지가 있다.

00:18:23.000 --> 00:18:30.000
이벤트에 위치를 추가할 때, 사용자 지정 가상 회의 옵션이 위치 선택기에 나타납니다.

00:18:30.000 --> 00:18:36.000
이 예에는 FaceTime 및 Skype 가상 회의 확장에서 제공하는 옵션이 있습니다.

00:18:36.000 --> 00:18:41.000
이 중 하나를 탭하면 가상 컨퍼런스가 이벤트에 추가됩니다.

00:18:41.000 --> 00:18:48.000
가상 회의가 있는 이벤트는 이벤트 세부 사항에 사용자 지정 참여 옵션을 표시합니다.

00:18:48.000 --> 00:18:53.000
가상 회의 확장을 만드는 것은 몇 단계밖에 걸리지 않는다.

00:18:53.000 --> 00:18:58.000
먼저, Xcode에서 새로운 가상 회의 확장 대상을 만드세요.

00:18:58.000 --> 00:19:03.000
그런 다음, 확장 프로토콜에는 구현할 두 가지 방법이 있다.

00:19:03.000 --> 00:19:16.000
fetchAvailableRoomTypes를 구현하여 사용 가능한 룸 유형을 제공한 다음, fetchVirtualConference를 구현하여 선택한 룸 유형에 대한 가상 회의 객체를 제공합니다.

00:19:16.000 --> 00:19:18.000
예를 들어 봅시다.

00:19:18.000 --> 00:19:23.000
먼저, Xcode에서 가상 컨퍼런스 확장 대상을 만드세요.

00:19:23.000 --> 00:19:29.000
새로운 대상은 EKVirtualConferenceProvider의 스터브 서브클래스를 가질 것이다.

00:19:29.000 --> 00:19:34.000
재정의하는 첫 번째 방법은 fetchAvailableRoomTypes이다.

00:19:34.000 --> 00:19:39.000
객실 유형은 위치 선택기에 표시됩니다.

00:19:39.000 --> 00:19:42.000
각 객실 유형에 대한 제목을 선택하세요.

00:19:42.000 --> 00:19:47.000
이것은 앱 아이콘 옆의 UI에 표시됩니다.

00:19:47.000 --> 00:19:51.000
또한 각 객실 유형에 대한 고유 식별자를 선택하세요.

00:19:51.000 --> 00:19:58.000
식별자는 어떤 방 유형이 선택되어 있는지 내선 번호에 알려주는 데 사용됩니다.

00:19:58.000 --> 00:20:05.000
제목과 식별자를 사용하여 EKVirtualConferenceRoomTypeDescriptor의 인스턴스를 만드세요.

00:20:05.000 --> 00:20:11.000
앱이 여러 객실 유형을 지원한다면, 각각에 대한 인스턴스를 만드세요.

00:20:11.000 --> 00:20:16.000
마지막으로, 다양한 객실 유형을 반환하세요.

00:20:16.000 --> 00:20:20.000
구현할 다음 방법은 fetchVirtualConference이다.

00:20:20.000 --> 00:20:24.000
이것은 객실 유형 중 하나를 선택할 때 호출됩니다.

00:20:24.000 --> 00:20:29.000
식별자 인수는 어떤 방이 선택되었는지 알려줍니다.

00:20:29.000 --> 00:20:37.000
가상 회의에는 캘린더에 가입하는 방법을 알려주는 하나 이상의 URL 설명자가 있습니다.

00:20:37.000 --> 00:20:45.000
열 URL과 선택적 제목으로 EKVirtualConferenceURLDescriptor를 만드세요.

00:20:45.000 --> 00:20:51.000
URL에 유니버설 링크를 사용하여 앱을 직접 열 수 있습니다.

00:20:51.000 --> 00:20:55.000
제목은 여러 가입 옵션을 구별하는 데 도움이 된다.

00:20:55.000 --> 00:21:01.000
여기에 가입할 수 있는 방법은 하나밖에 없기 때문에 필요하지 않습니다.

00:21:01.000 --> 00:21:05.000
세부 사항 문자열에 추가 정보를 제공하십시오.

00:21:05.000 --> 00:21:12.000
이 텍스트는 이벤트 세부 사항 UI의 특별 가상 컨퍼런스 섹션에 포함될 것입니다.

00:21:12.000 --> 00:21:19.000
마지막으로, 이 모든 것을 모아 EKVirtualConferenceDescriptor를 만들고 반환하세요.

00:21:19.000 --> 00:21:23.000
여기 제목은 여러 객실 유형을 구별하는 데 도움이 된다.

00:21:23.000 --> 00:21:30.000
이 예시에는 하나의 방 유형만 있으므로, 제목은 0으로 남습니다.

00:21:30.000 --> 00:21:38.000
이 두 가지 방법만으로, 당신의 앱은 가상 회의를 위한 옵션으로 캘린더 앱의 위치 선택기에 나타날 것입니다.

00:21:38.000 --> 00:21:45.000
이제 캘린더와 통합하는 몇 가지 다른 방법을 다루었으니, 앱이 어떻게 기여할 수 있는지 생각해 보세요.

00:21:45.000 --> 00:21:51.000
EventKitUI 또는 Siri 이벤트 제안을 사용하여 액세스를 요청하지 않고 이벤트를 추가하세요.

00:21:51.000 --> 00:21:58.000
접근을 요청해야 한다면, 필요한 최소한의 접근을 요청하고, 필요할 때만 요청하세요.

00:21:58.000 --> 00:22:04.000
그리고 음성 또는 화상 통화 앱이 있다면, 가상 회의 확장을 구현하세요.

00:22:04.000 --> 00:22:07.000
당신의 앱이 캘린더와 어떻게 통합되는지 빨리 보고 싶어요.

00:22:07.000 --> 00:22:09.000
봐줘서 고마워.

00:22:09.000 --> 23:59:59.000
♪ ♪

