WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:14.000
알렉스: 안녕. 내 이름은 알렉스야. 저는 비디오 엔지니어링 팀에서 왔어요.

00:00:14.000 --> 00:00:21.000
오늘, 제 동료 Antoine과 저는 RoomPlan의 새로운 기능을 당신과 공유할 것입니다.

00:00:21.000 --> 00:00:34.000
RoomPlan은 ARKit으로 구동되는 정교한 기계 학습 알고리즘을 사용하여 벽, 창문, 문, 개구부 및 기타 방을 정의하는 물체를 감지합니다.

00:00:34.000 --> 00:00:42.000
RoomCaptureView API를 사용하면 스캔 경험을 앱에 직접 통합할 수 있습니다.

00:00:42.000 --> 00:00:50.000
스캔이 완료되면, 앱은 결과 3D 모델을 제시하고 USDZ 파일로 내보낼 수 있습니다.

00:00:50.000 --> 00:00:54.000
이 세션에서, 우리는 RoomPlan의 새로운 것에 대해 이야기할 것이다.

00:00:54.000 --> 00:01:02.000
우리는 사용자 지정 ARSession을 사용하여 RoomPlan과 ARKit을 결합하는 새로운 방법으로 시작할 것입니다.

00:01:02.000 --> 00:01:07.000
그런 다음, 우리는 멀티룸 지원에 관심을 돌릴 것입니다.

00:01:07.000 --> 00:01:14.000
우리는 개별 룸 스캔을 하나의 더 큰 구조로 병합하는 새로운 멀티룸 API를 제공합니다.

00:01:14.000 --> 00:01:20.000
다음으로, 우리는 RoomCaptureView에 대한 새로운 VoiceOver 지원을 보여줄 것입니다.

00:01:20.000 --> 00:01:32.000
마지막으로, 우리는 새로운 워크플로우를 가능하게 하기 위해 RoomPlan 표현의 몇 가지 개선 사항과 수출 기능의 향상을 검토할 것입니다.

00:01:32.000 --> 00:01:36.000
커스텀 ARSession 지원부터 시작합시다.

00:01:36.000 --> 00:01:48.000
앞서 언급했듯이, RoomPlan은 스캔 중에 벽, 창문, 문, 개구부 및 기타 물체를 감지하기 위해 ARKit의 정보에 의존하고 있습니다.

00:01:48.000 --> 00:01:53.000
이를 위해, RoomCaptureSession은 기본 ARSession으로 실행됩니다.

00:01:53.000 --> 00:02:02.000
iOS 17의 새로운 기능, RoomPlan은 ARWorldTrackingConfiguration과 함께 사용자 지정 ARSession을 사용할 수 있습니다.

00:02:02.000 --> 00:02:10.000
이것은 동일한 워크플로우 내에서 RoomPlan과 ARKit의 사용을 결합하는 몇 가지 새로운 방법을 허용합니다.

00:02:10.000 --> 00:02:12.000
몇 가지 예를 살펴봅시다.

00:02:12.000 --> 00:02:28.000
사용자 지정 ARSession과 함께 RoomPlan을 사용하는 한 가지 방법은 RoomPlan 결과를 ARKit 장면 지오메트리 및 평면 감지와 결합하여 가상 콘텐츠와 실제 지오메트리 간의 몰입형 상호 작용을 하는 것입니다.

00:02:28.000 --> 00:02:40.000
또한, ARKit의 고품질 이미지 캡처를 사용하여 RoomPlan으로 더 풍부한 부동산 목록을 만들어 공간의 사진 표현을 수집할 수 있습니다.

00:02:40.000 --> 00:02:51.000
그리고 기존 AR 경험의 일부로 RoomPlan을 사용하는 경우, 기존 ARAnchors를 방해하지 않고 RoomPlan의 결과를 결합할 수 있습니다.

00:02:51.000 --> 00:02:56.000
이것들은 사용자 지정 ARSession이 제공할 수 있는 몇 가지 사용 사례일 뿐입니다.

00:02:56.000 --> 00:03:02.000
사용자 지정 ARSession을 RoomPlan에 전달하는 방법을 알아보기 위해 몇 가지 코드를 살펴봅시다.

00:03:02.000 --> 00:03:07.000
여기 이전 RoomPlan의 초기화 및 중지 기능이 있습니다.

00:03:07.000 --> 00:03:12.000
그리고 사용자 지정 ARSession을 init 함수로 전달하는 방법은 다음과 같습니다.

00:03:12.000 --> 00:03:20.000
ARWorldTrackingConfiguration을 사용한 모든 사용자 지정 ARSession은 RoomCaptureSession 내에서 존중됩니다.

00:03:20.000 --> 00:03:29.000
또한, 정지 기능에는 이제 기본 ARSession을 일시 중지할지 여부를 결정하는 새로운 옵션이 포함되어 있습니다.

00:03:29.000 --> 00:03:37.000
RoomCaptureSession이 중지된 후에도 ARSession이 계속 실행되도록 하려면 Boolean을 false로 설정할 수 있습니다.

00:03:37.000 --> 00:03:53.000
다음 섹션에서는 ARSession으로 작업하면 여러 스캔을 하나의 더 큰 구조로 병합하는 것과 같은 새로운 워크플로우가 어떻게 가능한지 볼 것입니다. 멀티룸 지원에 관심을 돌리자.

00:03:53.000 --> 00:03:55.000
멀티룸 지원은 무엇인가요?

00:03:55.000 --> 00:04:02.000
이전 RoomPlan에서는 단일 스캔을 하고 싱글 룸의 3D 모델을 얻을 수 있습니다.

00:04:02.000 --> 00:04:13.000
식당, 주방, 거실, 복도, 침실과 같은 집의 다른 방을 여러 번 스캔했다고 가정해 봅시다.

00:04:13.000 --> 00:04:17.000
만약 당신이 그것들을 병합하고 싶다면, 당신은 몇 가지 도전에 직면하게 될 것입니다.

00:04:17.000 --> 00:04:26.000
첫째, 그들은 모두 그들 자신의 좌표계에 있으며, 이는 세계 좌표의 기원과 방향이 각 방마다 다르다는 것을 의미한다.

00:04:26.000 --> 00:04:37.000
둘째, 수동으로 바느질하더라도, 결국 중복된 벽과 잠재적으로 중복되는 물체를 갖게 될 것입니다.

00:04:37.000 --> 00:04:41.000
먼저 다른 좌표계를 다루자.

00:04:41.000 --> 00:04:47.000
우리가 여기서 달성하고자 하는 것은 모든 스캔을 동일한 좌표계에서 촬영하는 것이다.

00:04:47.000 --> 00:04:52.000
여러 방을 스캔하기 위해 두 가지 접근 방식이 제안된다.

00:04:52.000 --> 00:04:55.000
먼저, 지속적인 ARSession을 사용하세요.

00:04:55.000 --> 00:04:59.000
둘째, ARSession relocalization을 사용하세요.

00:04:59.000 --> 00:05:02.000
지속적인 ARSession을 사용하는 방법을 살펴봅시다.

00:05:02.000 --> 00:05:08.000
이전 RoomPlan에서, RoomCaptureSession이 멈추면, ARSession이 일시 중지됩니다.

00:05:08.000 --> 00:05:12.000
각 스캔은 다른 좌표계를 가지고 있다.

00:05:12.000 --> 00:05:20.000
우리의 새로운 API는 이제 stop 함수에 새로운 인수가 있으며, pauseARSession을 false로 설정할 수 있습니다.

00:05:20.000 --> 00:05:32.000
이를 통해 ARSession은 우리가 마침내 ARSession을 다시 일시 중지하기로 결정할 때까지 다음 스캔을 위해 계속 실행할 수 있습니다.

00:05:32.000 --> 00:05:39.000
이 접근 방식을 사용하여, 우리는 여러 스캔에서 실행되는 동일한 ARSession을 보장할 수 있습니다.

00:05:39.000 --> 00:05:45.000
이것은 우리가 모든 스캔에 대해 하나의 공통 세계 좌표계를 가질 수 있게 해줄 것이다.

00:05:45.000 --> 00:05:49.000
이것이 코드에서 어떻게 작동하는지 봅시다.

00:05:49.000 --> 00:05:55.000
다음은 연속 ARSession으로 RoomCaptureSession을 실행하는 예입니다.

00:05:55.000 --> 00:05:59.000
우리는 RoomCaptureSession.run으로 첫 번째 스캔을 시작합니다.

00:05:59.000 --> 00:06:01.000
그럼, 여기 핵심 부분이 있습니다.

00:06:01.000 --> 00:06:09.000
RoomCaptureSession.stop의 새로운 API를 사용하면 pauseARSession을 false로 설정해야 합니다.

00:06:09.000 --> 00:06:13.000
이것은 다음 스캔을 위해 ARSession을 계속 실행할 것이다.

00:06:13.000 --> 00:06:19.000
그 후, 우리는 두 번째 스캔을 위해 동일한 roomCaptureSession 인스턴스를 사용합니다.

00:06:19.000 --> 00:06:22.000
그런 다음, 우리는 두 번째 스캔을 중단합니다.

00:06:22.000 --> 00:06:29.000
마지막으로, 우리는 같은 좌표계에서 첫 번째와 두 번째 스캔 결과를 얻을 수 있었다.

00:06:29.000 --> 00:06:38.000
동일한 좌표 공간 내에서 개별 방 스캔을 하는 또 다른 방법은 ARSession 재로컬화를 사용하는 것이다.

00:06:38.000 --> 00:06:49.000
이 접근 방식은 다음 날이나 주에 같은 장소로 돌아오는 것과 같이 다른 시간에 개별 방 스캔을 하는 경우에 가장 적합합니다.

00:06:49.000 --> 00:06:52.000
이것이 어떻게 작동하는지 살펴봅시다.

00:06:52.000 --> 00:06:57.000
다시 말하지만, 이것은 싱글 룸의 3D 모델을 얻기 위한 단일 스캔입니다.

00:06:57.000 --> 00:07:07.000
RoomCaptureSession을 중지하고 ARSession을 일시 중지하기 때문에 향후 스캔을 위해 재로컬라이제이 작동하려면 ARWorldMap을 디스크에 저장해야 합니다.

00:07:07.000 --> 00:07:18.000
ARSession이 일시 중지되었을 때 이전 스캔을 계속하려면, 이제 일시 중지된 ARSession에서 ARWorldMap을 로드하여 스캔을 재개할 수 있습니다.

00:07:18.000 --> 00:07:30.000
이 ARWorldMap을 사용하면 이전 스캔 환경에 대해 다시 현지화하여 일련의 스캔이 모두 공통 좌표계를 공유하도록 할 수 있습니다.

00:07:30.000 --> 00:07:36.000
재배치와 함께 스캔 워크플로우를 위한 샘플 코드를 살펴봅시다.

00:07:36.000 --> 00:07:40.000
먼저, 우리는 첫 번째 스캔을 실행한다.

00:07:40.000 --> 00:07:44.000
그런 다음, 우리는 ARSession을 일시 중지하여 첫 번째 스캔을 중지합니다.

00:07:44.000 --> 00:07:52.000
그 후, 재배치가 작동하려면, ARSession이 일시 중지될 때 ARWorldMap을 저장해야 합니다.

00:07:52.000 --> 00:07:57.000
두 번째 스캔을 실행하기 전에, 우리는 이전 ARWorldMap을 복원해야 합니다.

00:07:57.000 --> 00:08:01.000
먼저, 우리는 ARWorldMap을 로드합니다.

00:08:01.000 --> 00:08:07.000
그리고 우리는 로드된 ARWorldMap을 ARWorldTrackingConfiguration에 할당합니다. initialWorldMap.

00:08:07.000 --> 00:08:12.000
그런 다음, 우리는 재배치를 트리거하기 위해 ARSession을 실행합니다.

00:08:12.000 --> 00:08:17.000
재배치가 완료되면, 이전 ARSession이 로드됩니다.

00:08:17.000 --> 00:08:22.000
현재 세계 좌표는 이전 세계 좌표와 일치한다.

00:08:22.000 --> 00:08:24.000
그러면 우리는 두 번째 스캔을 실행할 수 있다.

00:08:24.000 --> 00:08:27.000
마지막으로, 우리는 두 번째 스캔을 중단합니다.

00:08:27.000 --> 00:08:35.000
이 모든 단계를 통해, 첫 번째와 두 번째 스캔 결과는 동일한 3D 세계 좌표에 있습니다.

00:08:35.000 --> 00:08:42.000
우리는 같은 3D 좌표계에서 여러 스캔을 연결하는 두 가지 접근 방식을 보았다.

00:08:42.000 --> 00:08:51.000
다음으로, 우리는 새로운 멀티룸 API를 사용하여 그것들을 하나의 결합된 구조로 병합하는 방법을 살펴볼 것입니다.

00:08:51.000 --> 00:08:57.000
각 스캔에 대해 RoomBuilder API를 실행하여 개별 CapturedRoom을 생성할 수 있습니다.

00:08:57.000 --> 00:09:09.000
이전에 보여준 바와 같이, 지속적인 ARSession과 ARSession 재로컬라이제이션을 통해, 모든 CapturedRooms는 동일한 3D 세계 공간에 있습니다.

00:09:09.000 --> 00:09:14.000
다음은 세 개의 CapturedRooms가 있는 RoomBuilder의 출력입니다.

00:09:14.000 --> 00:09:24.000
이제 우리는 모든 것을 하나의 큰 구조인 CapturedStructure로 병합하기 위해 새로운 병합 API인 StructureBuilder를 제공합니다.

00:09:24.000 --> 00:09:30.000
다음으로, StructureBuilder API의 샘플 코드를 살펴봅시다.

00:09:30.000 --> 00:09:35.000
StructureBuilder API를 사용하여 여러 스캔을 병합하는 방법은 다음과 같습니다.

00:09:35.000 --> 00:09:40.000
먼저, 구성 옵션이 있는 StructureBuilder 인스턴스를 만듭니다.

00:09:40.000 --> 00:09:46.000
그런 다음, 우리는 이전에 스캔한 여러 CapturedRooms를 로드하기 위해 배열을 만듭니다.

00:09:46.000 --> 00:09:54.000
그 후, 우리는 병합된 결과인 CaptureStructure를 얻기 위해 StructureBuilder API를 호출합니다.

00:09:54.000 --> 00:09:59.000
마지막으로, 우리는 캡처된 구조를 USDZ 파일로 내보낼 수 있습니다.

00:09:59.000 --> 00:10:02.000
그리고 여기 CapturedStructure 정의가 있습니다.

00:10:02.000 --> 00:10:06.000
첫째, 그것은 방의 속성을 가지고 있다.

00:10:06.000 --> 00:10:09.000
CapturedRoom 인스턴스의 배열입니다.

00:10:09.000 --> 00:10:18.000
그런 다음, 그것은 병합된 벽, 문, 창문, 개구부 및 물체에 대한 속성을 가지고 있다.

00:10:18.000 --> 00:10:24.000
마지막으로, USDZ 파일로 내보내는 기능이 있습니다.

00:10:24.000 --> 00:10:27.000
멀티룸이 작동하는 것을 봅시다.

00:10:27.000 --> 00:10:37.000
여러 스캔을 StructureBuilder API와 병합하고 USDZ 파일로 내보낼 수 있는 sample.app을 제공합니다.

00:10:37.000 --> 00:10:43.000
우리의 USDZ 파일은 iOS와 macOS 모두에서 미리 볼 수 있습니다.

00:10:43.000 --> 00:10:54.000
USDZ 파일을 블렌더와 같은 디지털 콘텐츠 제작 도구에 로드하여 한 걸음 더 나아갈 수 있습니다.

00:10:54.000 --> 00:11:03.000
우리가 3D 모델에 약간의 미화를 적용한 후, 결과는 훨씬 더 좋아 보일 수 있다.

00:11:03.000 --> 00:11:11.000
마지막으로, 멀티룸 지원으로 최고의 멀티룸 경험을 얻기 위한 몇 가지 고려 사항에 대해 이야기해 봅시다.

00:11:11.000 --> 00:11:23.000
멀티룸은 1~4개의 침실, 거실, 주방 및 식당의 전형적인 설정이 있는 1층 주거용 주택에 가장 적합합니다.

00:11:23.000 --> 00:11:34.000
개별 객실을 스캔하고 병합하기 위해, 최대 총 면적은 2,000평방피트 또는 약 186평방미터를 권장합니다.

00:11:34.000 --> 00:11:47.000
또한, RoomPlan이 선명한 비디오 스트림과 좋은 AR 추적 성능으로 스캔할 수 있도록 50럭스 이상의 좋은 조명을 사용하는 것이 좋습니다.

00:11:47.000 --> 00:11:55.000
이제, 여기 앙투안이 iOS 17의 RoomPlan에 대한 더 많은 개선 사항에 대해 알려줍니다.

00:11:55.000 --> 00:11:56.000
앙투안: 고마워, 알렉스.

00:11:56.000 --> 00:12:00.000
여기서 픽업해서, 접근성에 대해 이야기해 봅시다.

00:12:00.000 --> 00:12:09.000
우리가 렌더링에 대해 이야기할 때, 우리 대부분은 시각적 양식에 대해 생각하지만, 시력이 낮은 사람들에게는 이 양식이 가장 유용한 것과는 거리가 멀다.

00:12:09.000 --> 00:12:18.000
올해 RoomPlan은 VoiceOver가 활성화되었을 때 오디오 피드백을 추가하여 휴대폰이 스캔에 대한 지침을 제공하고 보는 것을 설명할 수 있도록 했습니다.

00:12:18.000 --> 00:12:20.000
VoiceOver: 장치를 이동하여 시작하세요.

00:12:20.000 --> 00:12:22.000
벽의 하단 가장자리에 있는 포인트 카메라.

00:12:22.000 --> 00:12:25.000
벽난로. 벽.

00:12:25.000 --> 00:12:27.000
창문.

00:12:27.000 --> 00:12:32.000
앙투안: 이제 RoomPlan이 방에서 수집할 수 있는 새로운 정보와 그것이 어떻게 렌더링되는지에 대해 이야기해 봅시다.

00:12:32.000 --> 00:12:36.000
룸플랜은 다양한 방을 쉽게 스캔할 수 있게 해준다.

00:12:36.000 --> 00:12:43.000
그러나, 지금까지, 그것은 한정된 방 상황을 정확하게 나타내는 것으로 제한되었다.

00:12:43.000 --> 00:12:55.000
RoomPlan은 이제 기울어진 벽과 곡선 벽뿐만 아니라 식기 세척기, 오븐 또는 싱크대와 같은 오목한 주방 요소를 포함하는 훨씬 더 다양한 객실을 지원합니다.

00:12:55.000 --> 00:13:01.000
RoomPlan은 또한 주어진 범주의 물체의 구성을 감지하기 위해 개선되었다.

00:13:01.000 --> 00:13:11.000
예를 들어, 단일 좌석에서 L자형, 그리고 RoomPlan이 새 버전에서 감지할 간단한 정사각형 소파에 이르기까지 많은 종류의 소파가 있습니다.

00:13:11.000 --> 00:13:20.000
우리가 RoomPlan을 소개했을 때, 우리는 RoomPlan이 스캔할 수 있는 두 가지 요소인 표면과 물체에 대해 이야기했다.

00:13:20.000 --> 00:13:24.000
이제, 우리는 방 안의 영역을 설명하기 위해 새로운 요소를 추가하고 있습니다.

00:13:24.000 --> 00:13:27.000
우리는 그것들을 섹션이라고 부른다.

00:13:27.000 --> 00:13:35.000
벽은 이제 기울어진 벽이나 빔이 있는 벽과 같은 균일하지 않은 벽을 다루기 위해 다각형으로 설명될 수 있다.

00:13:35.000 --> 00:13:40.000
지금까지, 곡선 벽과 창문은 데이터 전용 API의 일부였다.

00:13:40.000 --> 00:13:46.000
이제 RoomCaptureView의 최종 결과는 곡선 벽을 렌더링할 수도 있습니다.

00:13:46.000 --> 00:13:54.000
표면 범주 외에도, 바닥 범주는 다각형으로 설명할 수 있는 또 다른 추가 사항이다.

00:13:54.000 --> 00:14:01.000
객체는 이제 카테고리 내의 다양한 구성을 더 잘 설명할 수 있는 속성을 가지고 있다.

00:14:01.000 --> 00:14:05.000
표면과 물체는 이제 새로운 부모 변수를 가지고 있다.

00:14:05.000 --> 00:14:08.000
그것은 그들의 부모의 식별자를 포함한다.

00:14:08.000 --> 00:14:17.000
예를 들어, 창문의 부모는 벽이고, 의자의 부모는 테이블이 될 수 있으며, 식기 세척기의 부모는 창고가 될 수 있다.

00:14:17.000 --> 00:14:21.000
그 모든 개선 사항을 예시와 함께 자세히 설명합시다.

00:14:21.000 --> 00:14:26.000
각 섹션은 당신의 방이나 집의 다른 영역을 설명합니다.

00:14:26.000 --> 00:14:35.000
섹션에는 거실, 침실, 욕실, 주방, 식당 중 라벨이 있습니다.

00:14:35.000 --> 00:14:41.000
그것은 주어진 층에서 주어진 위치를 가지고 있다.

00:14:41.000 --> 00:14:48.000
균일하지 않은 벽은 다각형 코너 변수를 사용하여 다각형으로 렌더링할 수 있습니다.

00:14:48.000 --> 00:14:56.000
바닥은 이제 스캔하는 동안 직사각형으로 표시되며 스캔이 끝날 때 다각형으로 아름답게 표시됩니다.

00:14:56.000 --> 00:15:01.000
식기 세척기, 오븐, 싱크대의 부모는 이제 렌더링에 새겨져 있다.

00:15:01.000 --> 00:15:06.000
우리가 RoomPlan을 도입했을 때, 카테고리는 객체를 설명하는 데 사용되었다.

00:15:06.000 --> 00:15:10.000
그러나, 이 표현에는 한계가 있었다.

00:15:10.000 --> 00:15:12.000
의자의 예를 들어보자.

00:15:12.000 --> 00:15:21.000
의자, 식당 의자 또는 사무실 의자와 같은 여러 유형의 의자가 이 범주를 나타낼 수 있습니다.

00:15:21.000 --> 00:15:23.000
그들은 모두 다른 목적을 가지고 있다.

00:15:23.000 --> 00:15:29.000
객체를 더 잘 표현하기 위해, 우리는 이제 속성을 추가하고 있다.

00:15:29.000 --> 00:15:35.000
이 예에서, 속성을 사용하여, 우리는 스캔된 것에 대해 더 충실하게 이해하고 있다.

00:15:35.000 --> 00:15:41.000
RoomPlan API에서 속성은 열거형의 다형 배열을 통해 사용할 수 있습니다.

00:15:41.000 --> 00:15:46.000
그러나, 열거형은 속성을 이해하는 가장 좋은 방법은 아니다.

00:15:46.000 --> 00:15:51.000
다음 섹션에서, 우리는 더 매력적인 표현에 도달하기 위한 새로운 방법을 모색할 것이다.

00:15:51.000 --> 00:15:59.000
속성은 스캔 중에 캡처된 다른 새로운 정보와 함께 이제 내보낸 결과에 포함될 수 있습니다.

00:15:59.000 --> 00:16:11.000
우리가 지금 내보낼 수 있는 데이터 종류에는 두 가지 추가 사항이 있습니다: USDZ 노드에서 메타데이터를 다시 찾는 파일과 모델로 내보낸 USDZ를 풍부하게 하는 구조.

00:16:11.000 --> 00:16:19.000
방을 메쉬로 내보낼 때, 우리는 표면과 물체를 위한 노드 트리를 포함하는 USDZ를 만듭니다.

00:16:19.000 --> 00:16:24.000
올해, 우리는 섹션 센터를 포함하는 섹션 그룹을 추가했다.

00:16:24.000 --> 00:16:35.000
그러나, 그렇게 할 때, 우리는 스캔에서 상당한 양의 정보, 예를 들어 벽과 물체의 크기뿐만 아니라 물체 속성을 놓치고 있다.

00:16:35.000 --> 00:16:39.000
이제 방을 내보낼 때 매핑 파일을 만들 수 있습니다.

00:16:39.000 --> 00:16:51.000
USDZ 고유 노드 이름과 식별자로 고유하게 식별되는 CapturedRoom 요소 사이에 브리지를 만드는 String to UUID로 인코딩된 사전입니다.

00:16:51.000 --> 00:16:55.000
RoomPlan API에서 어떻게 전개되는지 봅시다.

00:16:55.000 --> 00:17:08.000
이전 버전의 RoomPlan에서, 방은 두 가지 방법으로 내보낼 수 있습니다: USDZ로, 내보내기 기능을 통해, 그리고 JSON 또는 Plist로 CapturedRoom 구조를 인코딩합니다.

00:17:08.000 --> 00:17:19.000
iOS 17의 새로운 기능에서 메타데이터 URL을 지정하여 내보내기 기능에서 방을 USDZ에 매핑하면 내보낸 두 정보를 연관시킬 수 있습니다.

00:17:19.000 --> 00:17:26.000
이렇게 하면, 스캔한 방을 렌더링할 때, 표면이나 물체에 대한 추가 정보를 쿼리할 수 있습니다.

00:17:26.000 --> 00:17:40.000
새로운 매핑 파일과 함께, 우리는 상자로 표시되었던 객체를 스캔한 속성과 일치하는 모델로 대체하기 위해 모델 제공자를 도입하고 있습니다.

00:17:40.000 --> 00:17:48.000
우리가 여기서 하고 싶은 것은 물체를 3D 모델, 더 구체적으로 URL에 연결하는 것이다.

00:17:48.000 --> 00:17:57.000
이렇게 하면, 우리는 물체를 나타내는 데 사용된 경계 상자를 더 설득력 있고 진실된 렌더링으로 대체할 수 있을 것이다.

00:17:57.000 --> 00:18:03.000
그 목적을 위해, RoomPlan: ModelProvider에서 새로운 구조를 사용할 수 있습니다.

00:18:03.000 --> 00:18:08.000
ModelProvider는 카테고리와 속성 세트를 모델 URL에 매핑합니다.

00:18:08.000 --> 00:18:16.000
카테고리와 속성이 있는 객체에서 ModelProvider에게 해당 모델 URL을 제공하도록 요청할 수 있습니다.

00:18:16.000 --> 00:18:32.000
이제 범주와 속성이 있는 섹션, 표면 및 개체의 모음인 전체 방으로 일반화하면, 내보내기 함수에 지정된 ModelProvider 인스턴스는 3D 모델 URL을 방의 각 개체에 연결할 수 있습니다.

00:18:32.000 --> 00:18:40.000
이제 모델 연결을 처리할 구조가 있으므로, 모델 제공자와 어떻게 협력할 수 있는지 봅시다.

00:18:40.000 --> 00:18:43.000
ModelProvider를 채우는 방법에는 여러 가지가 있다.

00:18:43.000 --> 00:18:50.000
예를 들어, 데이터베이스에서 속성 집합과 일치하는 모델을 가져오거나 기존 카탈로그에 주석을 달 수 있습니다.

00:18:50.000 --> 00:18:56.000
여기서, 우리는 당신만의 작은 자산 카탈로그를 만드는 아주 간단한 예를 안내할 것입니다.

00:18:56.000 --> 00:18:59.000
우리는 네 단계로 카탈로그를 만들고 사용할 것이다.

00:18:59.000 --> 00:19:04.000
먼저, 우리는 RoomPlan이 지원하는 범주와 속성을 분석할 것입니다.

00:19:04.000 --> 00:19:08.000
그런 다음, 우리는 각 카테고리와 속성 세트에 대한 모델을 연결할 것입니다.

00:19:08.000 --> 00:19:12.000
그 후, 우리는 ModelProvider를 인스턴스화할 것이다.

00:19:12.000 --> 00:19:17.000
그리고 마지막으로, 우리는 그것을 우리 방을 수출하는 데 사용할 것이다.

00:19:17.000 --> 00:19:22.000
몇 가지 모델을 사용하여 속성을 발견하고 모델 공급자를 만드는 방법을 봅시다.

00:19:22.000 --> 00:19:26.000
먼저, 우리는 RoomPlan이 지원하는 모든 카테고리를 반복합니다.

00:19:26.000 --> 00:19:30.000
그런 다음, 지원되는 각 카테고리에 대한 폴더를 만듭니다.

00:19:30.000 --> 00:19:33.000
우리는 나중에 각 폴더에 모델을 추가할 수 있습니다.

00:19:33.000 --> 00:19:40.000
그런 다음 각 카테고리에 대해 RoomPlan에서 지원하는 속성 조합을 요청합니다.

00:19:40.000 --> 00:19:44.000
지원되는 각 속성 세트에 대해, 우리는 폴더를 만듭니다.

00:19:44.000 --> 00:19:51.000
각 폴더에서 카테고리 또는 속성 세트에 해당하는 3D 모델을 추가할 수 있습니다.

00:19:51.000 --> 00:19:57.000
이제 카탈로그의 내용이 준비되었으므로, 우리는 그것을 위한 인덱스 파일을 만들어야 합니다.

00:19:57.000 --> 00:20:01.000
다음은 카탈로그 인덱스를 처리할 예시 구조입니다.

00:20:01.000 --> 00:20:07.000
그것은 요소의 배열을 포함하며, 각각은 카테고리 또는 속성 세트를 포함한다.

00:20:07.000 --> 00:20:11.000
각 요소에는 해당 모델의 경로에 대한 참조가 있다.

00:20:11.000 --> 00:20:18.000
이제 우리는 인덱스 파일을 plist로 저장하고 카탈로그를 번들로 저장할 수 있습니다.

00:20:18.000 --> 00:20:29.000
모델이 있는 방을 내보내거나 모델 공급자를 사용하여 객체를 모델과 연관시키고 싶을 때마다, 이제 이 카탈로그 번들을 사용하여 ModelProvider를 생성할 수 있습니다.

00:20:29.000 --> 00:20:45.000
우리가 해야 할 일은 카탈로그 카테고리와 속성을 반복하거나, 해당 모델 URL을 찾고, 속성이 없는 경우 모델 URL을 카테고리에 연결하거나, 모델 URL을 속성 세트에 연결하는 것입니다.

00:20:45.000 --> 00:20:54.000
마지막 단계는 출력 URL, 모델 공급자 인스턴스 및 .model 옵션을 지정하여 내보내기 함수를 호출하는 것입니다.

00:20:54.000 --> 00:21:00.000
그리고 짜잔! 우리가 얻는 것은 당신의 스캔에 해당하는 3D 모델이 있는 USDZ입니다.

00:21:00.000 --> 00:21:12.000
더 나아가기 위해, USDZ를 블렌더와 같은 DCC 도구로 선택적으로 가져와 몇 분 안에 얻을 수 있는 훨씬 더 현실적인 결과를 위해 빛과 그림자를 추가할 수 있습니다.

00:21:12.000 --> 00:21:18.000
설득력 있는 결과를 만들 수 있도록, 우리는 샘플 코드에 미리 채워진 카탈로그를 추가했습니다.

00:21:18.000 --> 00:21:21.000
너에게 돌아가, 알렉스!

00:21:21.000 --> 00:21:22.000
알렉스: 고마워, 앙투안.

00:21:22.000 --> 00:21:25.000
오늘 우리가 공유한 것을 살펴봅시다.

00:21:25.000 --> 00:21:39.000
첫째, 사용자 지정 ARSession 지원은 부동산 목록을 개선하기 위해 스캔과 함께 고품질 이미지와 비디오를 캡처하는 것과 같은 새로운 사용 사례를 가능하게 합니다.

00:21:39.000 --> 00:21:49.000
이제 여러 방을 스캔하고 새로운 StructureBuilder API를 사용하여 집 전체의 병합된 3D 모델을 생성할 수도 있습니다.

00:21:49.000 --> 00:21:59.000
저시력 사용자의 스캔 경험을 개선하기 위해, RoomPlan은 이제 RoomCaptureView를 사용할 때 VoiceOver를 지원합니다.

00:21:59.000 --> 00:22:06.000
RoomPlan의 새로운 개체 속성을 사용하면 스캔한 방을 더 정확하게 나타낼 수 있습니다.

00:22:06.000 --> 00:22:17.000
그리고 마지막으로, 이제 새로운 내보내기 API를 사용하여 사용자 지정 카탈로그에서 해당 스캔된 개체에 3D 모델을 할당할 수 있습니다.

00:22:17.000 --> 00:22:19.000
그것은 iOS 17의 RoomPlan이다.

00:22:19.000 --> 23:59:59.000
우리는 네가 그걸로 뭘 만드는지 빨리 보고 싶어.

