WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:15.000
David: 안녕하세요, 저는 ShazamKit 팀의 엔지니어인 David Ilenwabor입니다.

00:00:15.000 --> 00:00:21.000
ShazamKit은 앱에 오디오 인식을 가져올 수 있는 프레임워크입니다.

00:00:21.000 --> 00:00:29.000
오디오를 Shazam의 방대한 음악 카탈로그와 일치시키거나 사용자 지정 카탈로그를 사용하여 미리 녹음된 오디오와 일치시킬 수 있습니다.

00:00:29.000 --> 00:00:36.000
2022년은 맞춤형 카탈로그 작업을 대규모로 개선한 ShazamKit에 대한 몇 가지 훌륭한 업데이트를 보았다.

00:00:36.000 --> 00:00:52.000
사용자 지정 카탈로그, 더 나은 동기화를 위한 시간 제한 미디어 항목, 두 개의 유사한 사운드 오디오 비트를 구별하기 위한 주파수 왜곡을 사용할 때 무거운 워크플로우를 처리하기 위해 Shazam CLI가 도입되었습니다.

00:00:52.000 --> 00:00:59.000
이것들이 어떻게 작동하는지 아직 익숙하지 않다면, ShazamKit 비디오로 대규모로 사용자 지정 카탈로그 만들기를 확인하세요.

00:00:59.000 --> 00:01:09.000
하지만 간단한 개요를 제공하기 위해, ShazamKit을 사용하면 오디오를 서명이라는 특별한 형식으로 변환하여 일치를 수행할 수 있습니다.

00:01:09.000 --> 00:01:16.000
오디오 버퍼 스트림이나 서명 데이터를 ShazamKit 세션으로 전달할 수 있습니다.

00:01:16.000 --> 00:01:23.000
그런 다음 세션은 서명을 사용하여 Shazam 카탈로그 또는 사용자 지정 카탈로그에서 일치하는 항목을 찾습니다.

00:01:23.000 --> 00:01:31.000
일치가 있는 경우, 세션은 일치의 메타데이터를 나타내는 미디어 항목이 있는 일치 개체를 반환합니다.

00:01:31.000 --> 00:01:35.000
그런 다음 앱에 미디어 항목을 표시할 수 있습니다.

00:01:35.000 --> 00:01:45.000
ShazamKit은 오디오 버퍼 스트림에서 서명을 생성하거나 디스크에 저장할 수 있는 서명 파일을 사용하여 일치를 수행할 수 있습니다.

00:01:45.000 --> 00:01:53.000
서명은 되돌릴 수 없으며, 이는 서명에서 원본 기록을 재구성할 수 없다는 것을 의미합니다.

00:01:53.000 --> 00:01:57.000
이것은 고객의 사생활을 보호합니다.

00:01:57.000 --> 00:02:11.000
카탈로그는 관련 미디어 항목이 있는 서명 그룹이며 쿼리 서명이 카탈로그의 참조 서명의 일부와 충분히 일치할 때 일치가 발생합니다.

00:02:11.000 --> 00:02:18.000
식당에서 재생되는 음악과 같이 쿼리 서명이 시끄러울 때에도 매치가 발생할 수 있습니다.

00:02:18.000 --> 00:02:24.000
이제 그것을 다뤘으니, 올해 ShazamKit의 흥미진진한 새로운 업데이트로 넘어갈 것이다.

00:02:24.000 --> 00:02:37.000
이 세션에서, 저는 ShazamKit으로 오디오를 인식하기 위한 새로운 변경 사항을 살펴본 다음, 흥미진진한 새로운 기능으로 재정의된 Shazam Library API에 대해 이야기할 것입니다.

00:02:37.000 --> 00:02:44.000
마지막으로, ShazamKit으로 더 나은 앱 경험을 만들기 위한 몇 가지 모범 사례를 안내해 드리겠습니다.

00:02:44.000 --> 00:02:51.000
시작하기 전에, 개발자 포털에서 첨부된 샘플 코드 프로젝트를 다운로드하는 것이 좋습니다.

00:02:51.000 --> 00:02:56.000
나는 이 비디오를 통해 이 프로젝트를 활용할 것이다.

00:02:56.000 --> 00:03:00.000
다뤄야 할 게 많으니까, 내가 시작할게.

00:03:00.000 --> 00:03:04.000
우선, 오디오 인식.

00:03:04.000 --> 00:03:11.000
ShazamKit을 사용하여 마이크의 오디오를 인식하는 과정은 다음 단계로 요약할 수 있습니다.

00:03:11.000 --> 00:03:15.000
먼저, 사용자에게 마이크 권한을 요청하세요.

00:03:15.000 --> 00:03:20.000
그런 다음, 권한이 부여된 후 녹음을 시작하세요.

00:03:20.000 --> 00:03:27.000
다음으로, 녹음된 오디오 버퍼를 ShazamKit에 전달하고, 마지막으로 결과를 처리하세요.

00:03:27.000 --> 00:03:32.000
이것을 보여주기 위해, 샘플 프로젝트에서 찾을 수 있는 데모 앱을 만들었습니다.

00:03:32.000 --> 00:03:40.000
나는 춤을 좋아하고, 최신 트렌드를 따라잡기 위해, 노래에 유행하는 댄스 동작을 발견할 수 있도록 앱을 만들었다.

00:03:40.000 --> 00:03:46.000
이 앱은 마이크를 사용하여 오디오를 듣고 작동하며, 댄스 비디오를 찾습니다.

00:03:46.000 --> 00:03:50.000
예를 들어, 나는 Siri에게 노래를 찾는 것을 도와달라고 요청할 수 있다.

00:03:50.000 --> 00:03:56.000
이봐, Siri, Dukes의 "Push It"을 틀어줘.

00:03:56.000 --> 00:03:58.000
Siri: 지금 Dukes의 "Push It"을 재생하고 있어.

00:03:58.000 --> 00:04:02.000
데이비드: 그런 다음, 춤 배우기 버튼을 눌러 녹음을 시작할 수 있습니다.

00:04:02.000 --> 00:04:05.000
♪ ♪

00:04:05.000 --> 00:04:11.000
ShazamKit은 노래를 인식하고 앱은 적절한 댄스 비디오를 검색합니다.

00:04:11.000 --> 00:04:14.000
내가 하나 얻은 것 같아. 흠!

00:04:14.000 --> 00:04:17.000
내 쌍둥이 댄싱 데이브가 나에게 몇 가지 동작을 보여주는 것 같아.

00:04:17.000 --> 00:04:19.000
이거 신나 보여.

00:04:19.000 --> 00:04:22.000
그래서 이것은 어떻게 시행되었나요?

00:04:22.000 --> 00:04:25.000
내가 코드를 안내해 줄게.

00:04:25.000 --> 00:04:30.000
여기 Xcode에서 열린 샘플 프로젝트가 있습니다.

00:04:30.000 --> 00:04:38.000
마이크 액세스를 요청하는 데 사용되는 info.plist 파일에 마이크 사용 설명을 추가했습니다.

00:04:38.000 --> 00:04:43.000
나는 또한 홈 화면과 댄스 비디오 화면을 위한 다양한 SwiftUI 뷰를 가지고 있다.

00:04:43.000 --> 00:04:49.000
그러나, 이 매처 클래스는 오디오 인식의 모든 마법이 일어나는 곳이다.

00:04:49.000 --> 00:04:55.000
초기화 시, 오디오 엔진을 구성하고 설정하는 방법이 있습니다.

00:04:55.000 --> 00:05:03.000
이 방법으로, 나는 PCMbuffers를 받고 오디오 엔진을 준비하기 위해 탭을 설치한다.

00:05:03.000 --> 00:05:08.000
또한, 나는 Learn The Dance 버튼을 탭할 때 불리는 매치 방법이 있다.

00:05:08.000 --> 00:05:17.000
녹음 허가를 요청하고, 이것이 승인되면, 녹음을 시작하기 위해 오디오 엔진의 시작을 요청합니다.

00:05:17.000 --> 00:05:27.000
다음으로, UI 매칭이 시작되었다고 말한 다음, session.results를 호출하고 비동기 일치 결과를 기다립니다.

00:05:27.000 --> 00:05:36.000
결과를 받은 후, 일치하는 경우 일치 개체를 설정하고, 일치하지 않는 경우와 오류 사례를 처리합니다.

00:05:36.000 --> 00:05:43.000
이 수업에는 또한 오디오 엔진을 멈추는 stopRecording 기능이 있습니다.

00:05:43.000 --> 00:05:51.000
이것은 잘 작동하지만, 오디오 버퍼를 받기 전에 오디오 엔진을 구성할 수 있는 설정 코드가 얼마나 많은지 주목하세요.

00:05:51.000 --> 00:05:57.000
특히 오디오 프로그래밍에 익숙하지 않은 경우, 이것은 바로잡는 것이 어려울 수 있습니다.

00:05:57.000 --> 00:06:06.000
그래서, 녹음과 매칭을 더 쉽게 하기 위해, 우리는 SHManagedSession이라는 새로운 API를 도입했습니다.

00:06:06.000 --> 00:06:14.000
관리 세션은 오디오 버퍼를 설정하는 번거로움 없이 자동으로 녹음을 시작합니다.

00:06:14.000 --> 00:06:19.000
이것은 설치하고 사용하는 것을 매우 쉽게 만든다.

00:06:19.000 --> 00:06:22.000
관리 세션을 사용하려면 마이크 권한이 필요합니다.

00:06:22.000 --> 00:06:26.000
이 허가 없이는, 세션은 녹화를 시작할 수 없습니다.

00:06:26.000 --> 00:06:35.000
따라서, 앱의 info.plist 파일에 마이크 사용 설명 항목을 추가하는 것이 중요합니다.

00:06:35.000 --> 00:06:41.000
관리 세션은 사용자에게 마이크 액세스를 요청할 때 이 설명을 사용합니다.

00:06:41.000 --> 00:06:46.000
그렇다면 코드에서 이 API를 어떻게 사용할 수 있나요?

00:06:46.000 --> 00:06:55.000
먼저, SHManagedSession의 인스턴스를 만든 다음, 결과 메소드를 호출하여 결과를 기다릴 수 있습니다.

00:06:55.000 --> 00:07:04.000
이 방법은 일치, NoMatch 또는 오류가 될 수 있는 세 가지 상태가 있는 열거형을 반환합니다.

00:07:04.000 --> 00:07:15.000
다음으로, 일치하는 경우 반환된 미디어 항목을 사용하고 일치하지 않는 경우와 오류 사례를 처리하여 결과를 전환할 수 있습니다.

00:07:15.000 --> 00:07:21.000
그리고 시간이 지남에 따라 많은 결과를 반환할 수 있는 더 긴 녹음 세션을 원한다면 어떨까요?

00:07:21.000 --> 00:07:27.000
음, 저는 managedSession에서 비동기 시퀀스 결과 속성을 사용하여 이것을 할 수 있습니다.

00:07:27.000 --> 00:07:32.000
나는 이전과 마찬가지로 시퀀스에서 받은 각 결과를 사용할 수 있다.

00:07:32.000 --> 00:07:37.000
이것은 내가 오랫동안 오디오를 계속 녹음할 수 있게 해준다.

00:07:37.000 --> 00:07:42.000
마지막으로, managedSession에서 취소를 호출하여 매칭을 중단할 수 있습니다.

00:07:42.000 --> 00:07:47.000
이것은 현재 실행 중인 경기 시도를 취소하고 녹화를 중단합니다.

00:07:47.000 --> 00:07:48.000
그리고 그게 다야.

00:07:48.000 --> 00:07:55.000
관리 세션을 사용하면, 몇 줄의 코드만 기록하기 시작하고 일치 후 결과를 받을 수 있습니다.

00:07:55.000 --> 00:08:01.000
내 앱으로 돌아가서, 나는 managedSession을 사용하도록 Matcher 구현을 업데이트할 것이다.

00:08:01.000 --> 00:08:13.000
SHSession의 모든 인스턴스를 SHManagedSession으로 대체할 수 있습니다.

00:08:13.000 --> 00:08:20.000
그런 다음, 구성 오디오 엔진 방법과 사용법을 삭제할 수 있습니다.

00:08:20.000 --> 00:08:29.000
그리고 매치 방법에서, 녹음 권한을 요청하고 오디오 엔진을 시작하기 위해 호출을 삭제할 수 있습니다.

00:08:29.000 --> 00:08:43.000
마지막으로, stopRecording 메소드에서, managedSession의 취소 메소드를 호출하기만 하면 오디오 엔진을 멈추기 위해 기존 코드를 대체할 수 있습니다.

00:08:43.000 --> 00:08:48.000
이제, 나는 모든 것이 여전히 예상대로 작동하는지 확인하기 위해 앱을 실행할 것이다.

00:08:48.000 --> 00:08:53.000
이봐, Siri, Dukes의 "Push It"을 틀어줘.

00:08:53.000 --> 00:08:55.000
Siri: 여기 Dukes의 "Push It"이 있습니다.

00:08:55.000 --> 00:08:57.000
♪ ♪

00:08:57.000 --> 00:08:58.000
신난다!

00:08:58.000 --> 00:09:06.000
모든 것이 여전히 잘 작동하지만, 이번에는 관리 세션으로 코드가 훨씬 더 좋고 깨끗합니다.

00:09:06.000 --> 00:09:07.000
그게 전부가 아니야.

00:09:07.000 --> 00:09:11.000
관리 세션에 대해 이야기할 것이 훨씬 더 많다.

00:09:11.000 --> 00:09:18.000
사용 사례에 따라, managedSession이 경기 시도를 미리 준비하기를 원할 수 있습니다.

00:09:18.000 --> 00:09:23.000
관리 세션을 준비하면 매칭할 때 세션이 더 잘 반응할 수 있습니다.

00:09:23.000 --> 00:09:32.000
그것은 또한 경기에 필요한 자원을 사전 할당하고, 경기 시도를 예상하여 사전 녹음을 시작한다.

00:09:32.000 --> 00:09:40.000
준비 사용의 이점에 대한 아이디어를 제공하기 위해, 여기에 준비에 전화하지 않고 세션의 행동을 나타내는 타임라인이 있습니다.

00:09:40.000 --> 00:09:53.000
결과를 요청할 때, 세션은 경기 시도를 위한 자원을 할당한 다음, 기록을 시작하고, 마지막으로 일치를 반환합니다.

00:09:53.000 --> 00:10:00.000
그러나, 준비에 전화하면, 세션은 즉시 자원을 사전 할당하고 사전 녹음을 시작합니다.

00:10:00.000 --> 00:10:07.000
그런 다음, 결과를 요청할 때, 세션은 이전보다 더 빨리 일치를 반환합니다.

00:10:07.000 --> 00:10:13.000
코드에서 이것을 하기 위해, 나는 결과를 요청하기 전에 단순히 준비 방법을 호출할 수 있다.

00:10:13.000 --> 00:10:20.000
이 방법을 호출하는 것은 전적으로 당신에게 달려 있으며 ShazamKit은 필요한 경우 당신을 대신하여 호출할 것입니다.

00:10:20.000 --> 00:10:25.000
이제, 당신은 궁금해할 것입니다, "세션의 현재 행동을 어떻게 추적하나요?

00:10:25.000 --> 00:10:33.000
"예를 들어, 긴 실행 세션에서, "녹음하거나 일치하거나 다른 일을 하고 있는지 어떻게 알 수 있나요?"

00:10:33.000 --> 00:10:41.000
이를 돕기 위해, 관리 세션에는 세션의 현재 상태를 나타내는 state라는 속성이 있습니다.

00:10:41.000 --> 00:10:49.000
세 가지 상태는 유휴 상태, 사전 녹음 및 일치이다.

00:10:49.000 --> 00:10:55.000
유휴 상태에서, 세션은 기록하거나 일치 시도를 하지 않는다.

00:10:55.000 --> 00:11:10.000
이것은 세션이 단일 일치 시도를 완료했거나 취소를 호출하거나, 여러 일치를 수행할 때 세션이 비동기 결과 시퀀스를 종료하는 경우입니다.

00:11:10.000 --> 00:11:15.000
사전 녹음은 세션이 준비된 후의 상태를 나타낸다.

00:11:15.000 --> 00:11:23.000
이 상태에서, 매칭에 필요한 모든 자원이 준비되었고 세션은 경기 시도를 위해 사전 녹음되고 있다.

00:11:23.000 --> 00:11:28.000
그런 다음 매칭을 진행하거나 사전 녹음을 취소할 수 있습니다.

00:11:28.000 --> 00:11:34.000
매칭은 세션이 적어도 한 번의 매치 시도를 하고 있음을 나타내는 세 번째 가능한 상태이다.

00:11:34.000 --> 00:11:38.000
이 상태에서 준비 호출은 세션에 의해 무시될 것이다.

00:11:38.000 --> 00:11:45.000
다음은 스위프트UI에서 관리된 세션 상태를 사용하여 보기 동작을 유도하는 방법의 예입니다.

00:11:45.000 --> 00:11:51.000
여기, 데모 앱에서 하위 뷰의 샘플 구현이 있습니다.

00:11:51.000 --> 00:11:58.000
상태가 유휴 상태이거나 일치하는 경우 이 보기에 대해 다른 동작을 구현했습니다.

00:11:58.000 --> 00:12:05.000
현재, 세션의 상태는 유휴 상태이며 텍스트 보기는 음악 듣기로 설정되어 있습니다.

00:12:05.000 --> 00:12:10.000
또한, 나는 그 주가 일치하는지 아닌지 확인하는 조건이 있다.

00:12:10.000 --> 00:12:18.000
만약 그렇다면, 나는 진행 상황을 표시하고, 그렇지 않다면, 춤 배우기 버튼을 표시한다.

00:12:18.000 --> 00:12:24.000
상태가 현재 유휴 상태이기 때문에, 춤 배우기 버튼이 표시됩니다.

00:12:24.000 --> 00:12:31.000
버튼을 탭하면 상태가 일치로 바뀌고 UI가 자동으로 새로 고쳐집니다.

00:12:31.000 --> 00:12:41.000
이번에는 텍스트가 매칭으로 설정되고 매칭이 시작된 이후 진행 상황 보기가 버튼을 대체합니다.

00:12:41.000 --> 00:12:50.000
세션 상태가 변경될 때마다, SwiftUI는 추가 작업 없이 이러한 변경 사항에 응답하기 위해 자동으로 뷰를 새로 고칩니다.

00:12:50.000 --> 00:13:00.000
그리고 이것은 managedSession이 객체가 자동으로 변경 사항을 관찰자에게 전달하도록 하는 새로운 Swift 유형인 Observable을 준수하기 때문입니다.

00:13:00.000 --> 00:13:06.000
따라서 SwiftUI는 managedSession의 상태 변경에 쉽게 대응할 수 있습니다.

00:13:06.000 --> 00:13:12.000
Observable에 대해 자세히 알아보려면, SwiftUI 비디오의 Discover Observation을 확인하세요.

00:13:12.000 --> 00:13:19.000
이제 오디오 인식을 다뤘으니, Shazam 도서관에 대해 이야기하겠습니다.

00:13:19.000 --> 00:13:29.000
2021년에 ShazamKit은 유효한 Shazam ID가 있는 경우 개발자가 Shazam 라이브러리에 일치하는 결과를 작성할 수 있는 API를 제공했습니다.

00:13:29.000 --> 00:13:34.000
이것은 그것이 Shazam 카탈로그의 노래에 해당한다는 것을 의미한다.

00:13:34.000 --> 00:13:42.000
추가된 항목은 설치된 경우 제어 센터 음악 인식 모듈과 Shazam 앱에서 볼 수 있습니다.

00:13:42.000 --> 00:13:45.000
그것은 또한 장치 간에 동기화된다.

00:13:45.000 --> 00:13:59.000
Shazam 라이브러리에 쓰는 데 필요한 특별한 허가는 없지만, 라이브러리에 저장된 모든 노래는 추가한 앱에 기인하기 때문에 고객에게 알리지 않고 콘텐츠를 저장하지 않는 것이 좋습니다.

00:13:59.000 --> 00:14:06.000
여기서, 목록의 두 번째 노래는 ShazamKit Dance Finder 앱에 기인합니다.

00:14:06.000 --> 00:14:13.000
수년에 걸쳐, 이 API의 사용은 다른 사용 사례를 제시했고 몇 가지 단점을 초래했다.

00:14:13.000 --> 00:14:18.000
예를 들어, 자신의 앱에 추가한 항목을 보고 싶다면 어떨까요?

00:14:18.000 --> 00:14:27.000
해결 방법은 처리하기가 지루하고 버그가 발생하기 쉬운 자신의 로컬 스토리지를 관리하는 것입니다.

00:14:27.000 --> 00:14:32.000
이러한 단점 때문에, SHLibrary라고 불리는 새로운 수업이 도입되었다.

00:14:32.000 --> 00:14:40.000
SHLibrary는 이전 SHMediaLibrary 클래스에 비해 더 광범위한 기능을 제공하기 때문에 SHLibrary를 채택하는 것이 좋습니다.

00:14:40.000 --> 00:14:57.000
SHLibrary의 핵심 기능 중 일부는 SHMediaLibrary의 해당 방법과 같은 방식으로 작동하는 Shazam 라이브러리에 미디어 항목을 추가하고, 미디어 항목을 읽고, 라이브러리에서 미디어 항목을 삭제하는 것을 포함합니다.

00:14:57.000 --> 00:15:02.000
앱은 라이브러리에 추가한 것만 읽고 삭제할 수 있습니다.

00:15:02.000 --> 00:15:10.000
읽을 때 반환된 항목은 앱에만 해당되며 전체 라이브러리를 나타내지 않습니다.

00:15:10.000 --> 00:15:16.000
또한, 앱이 추가하지 않은 미디어 항목을 삭제하려고 하면 오류가 발생합니다.

00:15:16.000 --> 00:15:21.000
다음으로, 나는 SHLibrary를 사용하는 방법을 설명할 것이다.

00:15:21.000 --> 00:15:29.000
SHLibrary로 추가하는 것은 기본 라이브러리 객체의 addItems 메소드를 호출하는 것만큼 간단합니다.

00:15:29.000 --> 00:15:33.000
이 방법은 추가할 미디어 항목의 배열을 받아들인다.

00:15:33.000 --> 00:15:36.000
도서관에서 읽는 것도 똑같이 간단하다.

00:15:36.000 --> 00:15:42.000
예를 들어, 라이브러리에서 항목을 읽고 SwiftUI에서 목록 보기를 채우는 방법은 다음과 같습니다.

00:15:42.000 --> 00:15:48.000
라이브러리 객체의 항목 속성을 목록 이니셜라이저로 전달하기만 하면 됩니다.

00:15:48.000 --> 00:15:59.000
SHLibrary는 또한 새로운 Swift Observable 유형을 준수하므로, 변경 사항이 있을 때 SwiftUI 뷰가 자동으로 다시 로드됩니다.

00:15:59.000 --> 00:16:03.000
당신은 또한 UI가 아닌 맥락에서 도서관에서 읽을 수 있습니다.

00:16:03.000 --> 00:16:13.000
예를 들어, 동기화된 Shazams에서 가장 인기 있는 사용자 장르를 검색하고 싶다면, 라이브러리의 현재 항목을 요청할 수 있습니다.

00:16:13.000 --> 00:16:24.000
그런 다음, 이것을 갖게 되면, 항목 배열을 필터링하여 반환된 모든 장르를 얻고, 가장 높은 빈도로 장르를 셀 수 있습니다.

00:16:24.000 --> 00:16:34.000
마지막으로, 라이브러리 객체에서 removeItems를 호출하여 제거할 미디어 항목의 배열을 전달하여 라이브러리에서 항목을 제거할 수 있습니다.

00:16:34.000 --> 00:16:42.000
내 앱으로 돌아가서, 내 라이브러리에 인식된 노래를 추가했기 때문에, 새로운 SHLibrary를 사용하여 이 노래를 읽을 수 있습니다.

00:16:42.000 --> 00:16:49.000
RecentDancesView에는 이니셜라이저에 빈 mediaItems 배열이 포함된 목록이 있습니다.

00:16:49.000 --> 00:16:58.000
내 라이브러리 항목을 자동으로 읽기 위해 빈 배열을 SHLibrary의 항목으로 바꿀 것이다.

00:16:58.000 --> 00:17:02.000
나는 이 변경 사항으로 앱을 실행할 것이다.

00:17:02.000 --> 00:17:09.000
앱이 로드되자마자, 나는 앱이 Shazam 라이브러리에 추가한 노래 목록을 받는다.

00:17:09.000 --> 00:17:16.000
SHLibrary를 사용하면 이 기능을 무료로 사용할 수 있으며, 일치하는 노래의 데이터베이스를 유지할 필요가 없습니다.

00:17:16.000 --> 00:17:24.000
다음으로, 각 행에서 작업을 삭제하기 위해 스와이프를 추가하여 라이브러리에서 노래를 삭제할 수 있습니다.

00:17:24.000 --> 00:17:29.000
행 보기에 스와이프 액션을 추가할 수 있습니다.

00:17:29.000 --> 00:17:42.000
그런 다음 스와이프 버튼을 탭하면, 삭제할 미디어 항목을 전달하여 SHLibrary의 removeItems 방법을 호출할 수 있습니다.

00:17:42.000 --> 00:17:46.000
이제 끝났어, 나는 이 변경 사항으로 앱을 실행할 거야.

00:17:46.000 --> 00:17:49.000
내 아이패드에서도 앱을 열었어.

00:17:49.000 --> 00:17:54.000
iPhone에서 항목을 스와이프하고 삭제 버튼을 탭할 수 있습니다.

00:17:54.000 --> 00:18:00.000
변경 사항은 동기화되고 삭제된 항목도 iPad의 목록에서 제거됩니다.

00:18:00.000 --> 00:18:02.000
이건 놀라워.

00:18:02.000 --> 00:18:16.000
이제 새로운 라이브러리 API를 사용하는 방법과 관리 세션을 사용하여 녹음을 처리하는 방법을 배웠으므로, 몇 가지 모범 사례를 살펴보고 올해 도입된 새로운 기능 중 일부를 사용할 때 몇 가지 팁을 제공하겠습니다.

00:18:16.000 --> 00:18:20.000
SHManagedSession과 SHSession은 밀접한 관련이 있다.

00:18:20.000 --> 00:18:25.000
그들은 비록 다른 방식으로도 거의 같은 것을 성취할 수 있다.

00:18:25.000 --> 00:18:31.000
ShazamKit이 녹음을 처리하도록 하고 싶을 때 managedSession을 사용하세요.

00:18:31.000 --> 00:18:37.000
오디오 버퍼를 생성하고 프레임워크에 전달할 때 SHSession을 사용하세요.

00:18:37.000 --> 00:18:43.000
managedSession을 사용하여 마이크나 AirPods에서 나오는 오디오를 인식하세요.

00:18:43.000 --> 00:18:49.000
마이크에서 오디오 스트리밍만 인식하려면 SHSession을 사용하세요.

00:18:49.000 --> 00:18:54.000
managedSession과 임의의 서명을 일치시키는 것은 지원되지 않습니다.

00:18:54.000 --> 00:19:02.000
따라서, 메모리에 서명 파일이나 로드된 서명 데이터가 있다면, SHSession을 사용하여 일치시키세요.

00:19:02.000 --> 00:19:14.000
마지막으로, managedSsession은 매칭을 위한 오디오 형식을 자동으로 처리하는 반면, SHSession은 여러 PCM 오디오 포맷과 매칭할 수 있습니다.

00:19:14.000 --> 00:19:27.000
SHSession의 오디오 형식에 대해 말하자면, 이전에는 matchStreamingBuffer 방법은 이러한 샘플 속도로 특정 형식 설정과 PCM 오디오 버퍼만 일치시킬 수 있었습니다.

00:19:27.000 --> 00:19:32.000
지원되지 않는 설정이 있는 오디오 버퍼는 NoMatch로 이어졌다.

00:19:32.000 --> 00:19:41.000
이 릴리스에서 SHSession은 이제 다양한 속도로 샘플링된 대부분의 형식 설정으로 PCM 버퍼를 지원합니다.

00:19:41.000 --> 00:19:48.000
이 버퍼를 통과하면 SHSession이 형식 변환을 처리할 것입니다.

00:19:48.000 --> 00:20:04.000
마지막으로, 사용자 지정 카탈로그에서 비슷하게 들리는 두 개 이상의 오디오가 있는 경우, ShazamKit은 이제 여러 참조 서명과 일치하는 쿼리 서명을 전달할 때 사용자 지정 카탈로그의 모든 일치 항목을 반환할 수 있습니다.

00:20:04.000 --> 00:20:12.000
매치는 최고의 매치 품질로 정렬되어 반환되며 원하는 적절한 매치 결과를 필터링할 수 있습니다.

00:20:12.000 --> 00:20:24.000
팁으로, 각각의 메타데이터에서 비슷하게 들리는 참조 서명에 적절하게 주석을 달면 원하는 결과를 구별할 수 있습니다.

00:20:24.000 --> 00:20:27.000
여기 당신이 이것을 어떻게 달성할 수 있는지에 대한 예가 있습니다.

00:20:27.000 --> 00:20:33.000
모든 에피소드가 같은 인트로 사운드를 갖는 텔레비전 쇼가 있다고 가정해 봅시다.

00:20:33.000 --> 00:20:40.000
각 에피소드를 나타내는 참조 서명이 있는 televisionShowCatalog를 생성할 수 있습니다.

00:20:40.000 --> 00:20:51.000
이 카탈로그를 사용하여 세션을 만들 수 있으며, 소개 섹션과 일치할 때 ShazamKit은 각 에피소드의 미디어 항목과 일치하는 결과를 반환합니다.

00:20:51.000 --> 00:21:01.000
그런 다음 mediaItems를 필터링하고 예를 들어 에피소드 2와 같은 특정 에피소드의 mediaItems만 반환할 수 있습니다.

00:21:01.000 --> 00:21:05.000
이것이 적절한 주석이 도움이 되는 방법이다.

00:21:05.000 --> 00:21:14.000
올해 모든 흥미진진한 업데이트를 거쳤으니, 멋진 앱으로 돌아가서 춤을 하나 더 배우려고 시도하는 것으로 결론을 내릴 것입니다.

00:21:14.000 --> 00:21:17.000
나는 내 에어팟으로 바꾸고 노래를 연주할 거야.

00:21:17.000 --> 00:21:25.000
앱에서 관리 세션을 사용하고 있기 때문에, AirPod에서 재생되는 오디오를 듣고 나를 위한 댄스 비디오를 찾을 수 있습니다.

00:21:25.000 --> 00:21:35.000
나는 AirPods의 터치 컨트롤을 눌러 노래를 재생하고 앱이 오디오를 감지할 때까지 기다릴 것이다.

00:21:35.000 --> 00:21:36.000
좋아!

00:21:36.000 --> 00:21:43.000
댄싱 데이브가 몇 가지 아프로비트 동작을 자랑하고 있는 것 같은데, 이 강연 후에 배우기 위해 최선을 다할게.

00:21:43.000 --> 00:21:47.000
나는 네가 이 새로운 업데이트에 대해 우리만큼 흥분하길 바라.

00:21:47.000 --> 00:21:51.000
참여해 주셔서 감사드리며, 멋진 WWDC를 보내세요.

00:21:51.000 --> 23:59:59.000
♪ ♪

