WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:11.000
스펜서: 안녕하세요 여러분.

00:00:11.000 --> 00:00:13.000
제 이름은 스펜서 루슨입니다.

00:00:13.000 --> 00:00:21.000
오늘 저는 지난 몇 년 동안 키보드가 어떻게 변했는지, 그리고 "키보드를 계속 사용할 수 있도록" 앱을 어떻게 디자인할 수 있는지에 대해 말씀드리고자 합니다.

00:00:21.000 --> 00:00:29.000
여러분 모두 아시다시피, 아이폰의 키보드는 원래 2007년에 도입되었으며, 그 이후로 상당히 발전했습니다.

00:00:29.000 --> 00:00:35.000
그것은 이제 많은 다른 언어를 지원하며, 각 언어는 레이아웃에 따라 크기가 다를 수 있습니다.

00:00:35.000 --> 00:00:39.000
그리고 물론, 키보드는 다양한 장치에서도 제공됩니다.

00:00:39.000 --> 00:00:50.000
하지만 키보드가 어떻게 진화했는지와 마찬가지로, 멀티태스킹과 플로팅 키보드와 같은 흥미로운 기능을 추가하여 키보드가 앱의 경계를 초월할 수 있도록 하는 시스템도 진화했다.

00:00:50.000 --> 00:00:56.000
작년에, 우리는 iPad에서 완전히 새로운 수준의 생산성을 발휘하는 Stage Manager를 도입했습니다.

00:00:56.000 --> 00:01:03.000
이제 여러 디스플레이에서 여러 장면이 실행되기 때문에, 하드웨어 키보드와 마우스의 사용은 그 어느 때보다 매력적이다.

00:01:03.000 --> 00:01:14.000
그래서 오늘 우리는 키보드의 재설계로 이 다양한 키보드 시나리오를 가능하게 하는 방법과 그것이 당신의 앱에 어떤 영향을 미칠 수 있는지에 대해 말씀드리고자 합니다.

00:01:14.000 --> 00:01:23.000
우리는 또한 가능한 한 적은 노력으로 키보드와 가능한 한 원활하게 작동하도록 앱을 설계하기 위한 몇 가지 팁과 요령을 공유하고 싶습니다.

00:01:23.000 --> 00:01:29.000
그리고 마지막으로, 우리는 텍스트 입력의 세계에서 몇 가지 흥미진진한 새로운 기능을 소개하고 싶습니다.

00:01:29.000 --> 00:01:32.000
그럼 새로운 아웃 오브 프로세스 키보드에 대해 이야기해 봅시다.

00:01:32.000 --> 00:01:39.000
앱 프로세스에서 키보드를 꺼내면 보안을 개선하고 사용자가 입력하는 개인 정보를 보장할 수 있습니다.

00:01:39.000 --> 00:01:48.000
또한 여러 앱에서 실행되는 여러 인스턴스 대신 하나의 키보드만 있기 때문에 앱과 시스템 전체의 메모리를 확보합니다.

00:01:48.000 --> 00:01:54.000
그리고 이 새로운 아키텍처는 우리가 미래를 위해 설계하고 흥미진진한 새로운 기능을 구현할 수 있게 해준다.

00:01:54.000 --> 00:01:57.000
그래서 그것이 어떻게 작동하는지에 대해 조금 이야기해 봅시다.

00:01:57.000 --> 00:02:03.000
iOS 17 이전에는 키보드의 보기와 논리가 앱 프로세스 내에서 실행되었습니다.

00:02:03.000 --> 00:02:10.000
하지만 iOS 17의 iPhone의 새로운 기능인 키보드는 자체 프로세스로 옮겨졌고, 앱 외부에서 거의 완전히 실행됩니다.

00:02:10.000 --> 00:02:18.000
이 모든 것이 어떻게 작동하는지 보여드리게 되어 기쁩니다. 하지만 먼저 차이점을 볼 수 있도록 그 과정에서 어떻게 작동하는지에 대해 이야기해 봅시다.

00:02:18.000 --> 00:02:31.000
진행 중, 당신의 앱은 터치에 응답하여 becomeFirstResponder를 호출하는 것과 같이 먼저 키보드를 요청할 것이며, 이것은 모든 뷰를 초기화하기 위한 일련의 동기 작업을 시작할 것입니다.

00:02:31.000 --> 00:02:37.000
그것이 완료되면, 시스템은 키보드를 불러올 수 있는 애니메이션을 수행할 것이다.

00:02:37.000 --> 00:02:48.000
그러면 앱은 터치 이벤트가 들어오고 텍스트 삽입이 생성될 때까지 유휴 상태이거나 앱 사이드 작업을 수행합니다.

00:02:48.000 --> 00:02:52.000
과정과 함께, 이것은 이제 조금 다르게 작동한다.

00:02:52.000 --> 00:03:04.000
앱이 키보드를 요청할 때, 예를 들어 becomeFirstResponder를 호출하면, 앱은 몇 가지 초기 계산을 수행한 다음 키보드 프로세스가 UI를 비동기적으로 초기화합니다.

00:03:04.000 --> 00:03:08.000
그런 일이 일어나는 동안, 앱은 유휴 상태이거나 앱 사이드 작업을 수행할 것이다.

00:03:08.000 --> 00:03:14.000
준비가 되면, 키보드를 가져오고 두 프로세스 사이의 애니메이션을 조정할 것이다.

00:03:14.000 --> 00:03:23.000
이제 키보드 UI가 실행되면, 키보드의 범위 내에서 발생하는 모든 터치 이벤트를 기다리고 앱의 텍스트 삽입으로 변환됩니다.

00:03:23.000 --> 00:03:29.000
대부분의 앱의 경우, 이러한 변경 사항은 완전히 투명하며 채택이 필요하지 않습니다.

00:03:29.000 --> 00:03:36.000
하지만, 이 새로운 비동기 접근 방식의 측면은 이제 키보드 전체에 존재하며 타이밍에 약간의 차이를 가져올 수 있다.

00:03:36.000 --> 00:03:46.000
따라서 앱이 텍스트 입력, 선택 변경 또는 기타 텍스트 관련 작업의 타이밍에 특히 민감하다면, 이 새로운 아키텍처를 염두에 두어야 합니다.

00:03:46.000 --> 00:03:56.000
이제 iOS에서 타이핑의 다양성에 대해 조금 이야기했으므로, 앱을 디자인할 때 고려해야 할 비교적 새로운 시나리오에 대해 이야기해 봅시다.

00:03:56.000 --> 00:04:02.000
물론, 우리 모두는 가장 일반적인 사용 사례에 익숙합니다: 키보드가 있는 전체 화면 앱.

00:04:02.000 --> 00:04:15.000
이것은 앱과 키보드가 모두 전체 화면인 비교적 간단한 사용 사례로, 키보드의 높이인 값으로 뷰를 올리는 것만큼 간단하게 키보드를 조정할 수 있습니다.

00:04:15.000 --> 00:04:20.000
그러나, 스테이지 매니저와 함께, 시스템은 그 모델에서 멀어지고 있다.

00:04:20.000 --> 00:04:24.000
고급 멀티태스킹을 통해, 앱이 반드시 전체 화면인 것은 아니다.

00:04:24.000 --> 00:04:30.000
즉, 키보드가 나타나면 앱의 보기를 올바르게 조정하기 위해 특별한 주의를 기울일 필요가 있습니다.

00:04:30.000 --> 00:04:34.000
그것은 키보드의 장면과 앱의 장면이 더 이상 정렬되지 않기 때문이다.

00:04:34.000 --> 00:04:40.000
그리고 컨텍스트에 맞게 앱을 조정하기 위해 몇 가지 추가 변환이 이루어져야 합니다.

00:04:40.000 --> 00:04:51.000
예를 들어, 이 시나리오에서 앱의 조정은 실제로 키보드의 높이인 Y가 아니며, Y'로 표시된 키보드와 앱의 교차점에 따라 조정해야 합니다.

00:04:51.000 --> 00:05:01.000
그리고 이제 화면에 여러 장면이 있을 수 있기 때문에 계산할 수 있는 단일 조정도 없을 수 있으며, 각각 다른 계산과 조정이 필요합니다.

00:05:01.000 --> 00:05:05.000
하드웨어 키보드와 함께 최근에 도입된 시나리오도 있다.

00:05:05.000 --> 00:05:10.000
하드웨어 키보드가 연결되면, 시스템은 화면 중앙에 보조 도구 모음을 표시합니다.

00:05:10.000 --> 00:05:17.000
이 풀 사이즈 툴바가 있을 때, 그것은 키보드의 일부로 작동하므로, 당신의 보기를 조정해야 합니다.

00:05:17.000 --> 00:05:20.000
플릭 제스처를 사용하여, 이 도구 모음도 최소화할 수 있습니다.

00:05:20.000 --> 00:05:29.000
스테이지 매니저 외부에서, 우리는 이 미니 툴바가 키보드의 일부로 작동하지 않고 당신의 견해와 겹치는 기존 동작을 보존하고 있습니다.

00:05:29.000 --> 00:05:34.000
사용자는 도구 모음을 화면 반대편으로 드래그하여 아래의 콘텐츠에 액세스할 수 있습니다.

00:05:34.000 --> 00:05:49.000
그러나 스테이지 관리자에서 미니 도구 모음은 키보드의 일부로 작동하며 사용 사례에 따라 스크롤 오프셋을 업데이트하고 입력 액세서리 보기를 푸시하고 원하는 대로 다른 레이아웃을 조정할 수 있습니다.

00:05:49.000 --> 00:05:57.000
이제, 우리는 여기에 설명해야 할 많은 시나리오와 뉘앙스가 있다는 것을 알고 있지만, 좋은 소식은 올바른 API를 사용하면 시스템이 당신을 위해 대부분의 작업을 수행한다는 것입니다.

00:05:57.000 --> 00:06:00.000
그럼 키보드 레이아웃 가이드에 대해 이야기해 봅시다.

00:06:00.000 --> 00:06:05.000
iOS 15에 도입된 키보드 레이아웃 가이드에 익숙할 것입니다.

00:06:05.000 --> 00:06:11.000
그것은 키보드를 자동으로 조정하는 쉬운 자동 레이아웃 가이드를 제공하며, 우리는 지난 한 해 동안 그것에 추가해 왔습니다.

00:06:11.000 --> 00:06:17.000
사실, 그것은 이제 스포트라이트와 메시지와 같은 복잡한 애플 앱에서 사용되고 있다.

00:06:17.000 --> 00:06:25.000
그것은 당신의 견해와 가이드 사이에 제약을 추가하기 위해 한 줄만큼 간단할 수 있기 때문에 권장되는 접근 방식입니다.

00:06:25.000 --> 00:06:28.000
이제 이것이 당신에게 정확히 무엇을 얻는지에 대해 이야기해 봅시다.

00:06:28.000 --> 00:06:35.000
기존의 기본 동작은 다음과 같습니다: 키보드 레이아웃 가이드는 화면에 있고 도킹될 때 키보드를 따릅니다.

00:06:35.000 --> 00:06:39.000
즉, 키보드가 화면 하단에 닿을 때입니다.

00:06:39.000 --> 00:06:46.000
iPad에 떠 있을 때와 같이 키보드가 도킹되지 않은 경우, 가이드의 높이는 뷰의 하단 안전 영역과 일치할 것이다.

00:06:46.000 --> 00:06:53.000
마지막으로, 가이드는 터치 포인트가 가이드와 교차하면 키보드 해제 제스처를 추적할 것이다.

00:06:53.000 --> 00:07:01.000
당신이 원하는 정확한 동작을 얻기 위해 이것들을 변경할 수 있도록 iOS 17의 사용자 지정 옵션을 확장했다는 것을 알려드리게 되어 기쁩니다.

00:07:01.000 --> 00:07:05.000
이제 UIKeyboardLayoutGuide에는 세 가지 속성이 있습니다.

00:07:05.000 --> 00:07:07.000
먼저, UndockedKeyboard를 따르세요.

00:07:07.000 --> 00:07:13.000
기본적으로, 가이드는 플로팅 키보드나 미니 툴바를 오프스크린 키보드와 동일하게 취급합니다.

00:07:13.000 --> 00:07:21.000
그러나, true로 설정되면, 가이드는 앱 창 위에 있는 한 키보드가 떠 있을 때에도 키보드를 계속 따라갈 것입니다.

00:07:21.000 --> 00:07:24.000
다음은 usesBottomSafe 영역입니다.

00:07:24.000 --> 00:07:29.000
기본적으로, 키보드 레이아웃 가이드는 키보드가 해제될 때 안전 영역의 높이를 추적합니다.

00:07:29.000 --> 00:07:37.000
하지만 false로 설정하면, usesBottomSafeArea는 대신 보기의 하단을 추적하며, 이 경우 화면 하단입니다.

00:07:37.000 --> 00:07:39.000
이게 언제 유용할까?

00:07:39.000 --> 00:07:50.000
음, 이를 통해 키보드가 해제될 때 화면 하단을 덮도록 배경을 확장하고 키보드가 나타날 때 InputAccessoryView와 유사하게 동작하도록 조정할 수 있습니다.

00:07:50.000 --> 00:07:56.000
그리고 사실, 그것은 이 부동산에 대한 정말 흥미로운 사용 사례이므로, 그것이 어떻게 작동할 수 있는지에 대해 이야기해 봅시다.

00:07:56.000 --> 00:08:07.000
다음은 하단 안전 영역 위에 있는 텍스트 필드와 키보드가 해제될 때만 보기 하단까지 확장되는 배경으로 간단한 입력 액세서리와 같은 보기를 얻을 수 있는 코드입니다.

00:08:07.000 --> 00:08:13.000
참고로, 우리는 여기서 수직 제약만 다룰 것입니다. 왜냐하면 그것들은 이 경우에 흥미로운 것들이기 때문입니다.

00:08:13.000 --> 00:08:17.000
먼저, usesBottomSafeArea를 false로 설정해 봅시다.

00:08:17.000 --> 00:08:25.000
그런 다음, 약간의 패딩을 제공하기 위해 둘 사이의 시스템 간격을 사용하여 텍스트 필드의 상단을 배경 상단에 묶어 봅시다.

00:08:25.000 --> 00:08:33.000
다음으로, 적어도 시스템 간격으로 가이드 상단을 텍스트 필드 하단으로 제한하여 텍스트 필드가 항상 키보드 위에 있는지 확인하십시오.

00:08:33.000 --> 00:08:35.000
여기서 중요한 것보다 더 큰 것.

00:08:35.000 --> 00:08:42.000
키보드가 화면 끄면에 있을 때, 텍스트 필드는 하단 안전 영역 삽입물 위에 머물기에 충분한 유연성이 필요할 것이다.

00:08:42.000 --> 00:08:46.000
또한 가이드의 상단 앵커를 배경 하단에 묶자.

00:08:46.000 --> 00:08:54.000
이것은 가이드가 화면 밖에 있을 때 배경이 바닥까지 갈 수 있도록 할 것이지만, 우리가 usesBottomSafeArea를 false로 설정했기 때문입니다.

00:08:54.000 --> 00:08:59.000
마지막으로, 하단 안전 영역을 텍스트 필드 하단과 시스템 간격으로 제한하십시오.

00:08:59.000 --> 00:09:05.000
그리고 다시 말하지만, 우리는 키보드가 나올 때 따라갈 수 있을 만큼 충분히 유연한지 확인하기 위해 여기서 제약보다 더 큰 것을 사용하고 있습니다.

00:09:05.000 --> 00:09:20.000
그리고 그것으로, 당신은 뷰의 맨 아래로 확장되는 배경을 가진 적응형 뷰를 가지고 있지만, 입력 액세서리 뷰와 마찬가지로 키보드 상단의 텍스트 필드 시스템 간격과 키보드 상단의 배경을 유지하도록 조정합니다.

00:09:20.000 --> 00:09:23.000
셋째, 우리는 keyboardDismissPadding이 있다.

00:09:23.000 --> 00:09:27.000
이것은 제스처를 해제하기 위해 스크롤의 매개 변수를 조정합니다.

00:09:27.000 --> 00:09:37.000
과거에 키보드 레이아웃 가이드를 사용하여 InputAccessory와 같은 보기를 만들려고 시도했다면, 터치가 키보드와 교차할 때까지 키보드 해제 제스처가 시작되지 않는다는 것을 알아차렸을 것입니다.

00:09:37.000 --> 00:09:40.000
그것을 고치기 위해 이 새로운 속성을 사용합시다.

00:09:40.000 --> 00:09:47.000
keyboardDismissPadding 속성을 사용하면 키보드 해제 제스처에 응답해야 하는 키보드 위의 패딩을 지정할 수 있습니다.

00:09:47.000 --> 00:09:49.000
이것은 비교적 간단하다.

00:09:49.000 --> 00:09:53.000
원하는 대로 시야의 높이를 잡고 부동산을 설정하기만 하면 됩니다.

00:09:53.000 --> 00:09:55.000
끝났어.

00:09:55.000 --> 00:10:00.000
이제 키보드 해제 제스처는 터치가 당신의 시야와 교차할 때 시작됩니다.

00:10:00.000 --> 00:10:03.000
물론, UIKit은 앱이 만들어진 유일한 프레임워크는 아니다.

00:10:03.000 --> 00:10:05.000
SwiftUI도 있어.

00:10:05.000 --> 00:10:09.000
그리고 다행스럽게도, SwiftUI는 당신을 위해 일반적인 경우를 자동으로 처리합니다.

00:10:09.000 --> 00:10:18.000
SwiftUI를 사용하면 키보드가 안전 영역의 일부로 포함되어 있으며, 키보드가 해제되면 화면 하단의 작은 홈 어포던스를 추적할 수 있습니다.

00:10:18.000 --> 00:10:27.000
키보드가 나타나면, 시스템은 당신을 위해 안전 영역을 애니메이션화하고 조정하여 자동으로 보기의 크기를 조정하므로 작성할 키보드 코드가 전혀 없습니다.

00:10:27.000 --> 00:10:33.000
하지만, 당신의 견해가 원하는 방식으로 크기를 조정하거나 재배치되고 있는지 확인하기 위해 레이아웃에 대한 작업을 해야 할 수도 있습니다.

00:10:33.000 --> 00:10:41.000
SwiftUI에 대한 훌륭한 리소스가 많이 있으며, 제가 나열할 수 있는 것보다 더 많습니다. 이에 대해 자세히 알아보려면 아래 링크된 문서를 살펴보세요.

00:10:41.000 --> 00:10:46.000
이제, 키보드, 키보드 알림을 통합하는 좀 더 수동 방법에 대해 이야기해 봅시다.

00:10:46.000 --> 00:11:02.000
SwiftUI와 키보드 레이아웃 가이드 이전에, 키보드를 애플리케이션에 통합하는 유일한 방법은 willShow, didShow, willHide, didHide와 같은 키보드 알림 세트를 청취한 다음 알림의 프레임과 애니메이션 정보를 기반으로 레이아웃을 수동으로 조정하는 것이었습니다.

00:11:02.000 --> 00:11:08.000
이것들은 여전히 주변에 있지만, 시스템이 당신을 위해 일을 하지 않기 때문에 더 신중한 처리가 필요합니다.

00:11:08.000 --> 00:11:16.000
그리고 스테이지 매니저의 도입으로, 우리는 그 처리에 대해 일반적으로 사용되는 패턴이 더 이상 100% 작동하지 않는다는 것을 알아차렸다.

00:11:16.000 --> 00:11:25.000
이 패턴은 일반적으로 키보드 알림을 받고 키보드 높이에서 원시 값을 직접 사용하는 데 중점을 둡니다.

00:11:25.000 --> 00:11:31.000
이제 우리가 키보드의 높이와 화면에서 앱의 위치가 어떻게 상호 작용하는지에 대한 뉘앙스에 대해 논의했던 것을 기억하십니까?

00:11:31.000 --> 00:11:34.000
이것이 알림과 어떻게 작동하는지 논의해 봅시다.

00:11:34.000 --> 00:11:40.000
각 알림은 화면 좌표에 대한 키보드의 예상 프레임을 지정합니다.

00:11:40.000 --> 00:11:51.000
앱이 전체 화면일 때와 같이 화면의 좌표 공간과 앱의 좌표 공간이 일치하면 알림에 포함된 원시 높이 값으로 인해 예상대로 보기가 조정됩니다.

00:11:51.000 --> 00:11:59.000
그러나, 화면의 좌표 공간과 앱의 좌표 공간이 다를 때, 이 원시 높이 값은 더 이상 보기를 조정할 수 있는 올바른 값이 아닙니다.

00:11:59.000 --> 00:12:04.000
이로 인해 당신의 견해가 너무 높아지고 잘못된 장소에 나타날 수 있습니다.

00:12:04.000 --> 00:12:11.000
다행히도, 일이 다시 원활하게 작동할 수 있도록 알림 처리에 몇 가지 변경 사항이 있습니다.

00:12:11.000 --> 00:12:18.000
iOS 16.1에서 키보드 알림은 해당 UIScreen을 알림의 객체로 포함하기 시작했다.

00:12:18.000 --> 00:12:26.000
먼저, 키보드가 앱과 같은 화면에 나타나는지 확인하기 위해 사용합시다. 그렇지 않으면 조정이 필요하지 않습니다.

00:12:26.000 --> 00:12:31.000
다음으로, 당신의 뷰와 관련된 키보드의 위치를 나타내기 위해 rect를 계산해 봅시다.

00:12:31.000 --> 00:12:43.000
키보드의 예상 끝 프레임, 알림 및 보기에서 제공하는 좌표 공간을 검색한 다음 이를 사용하여 keyboardFrameEnd를 좌표 공간으로 변환하여 이를 수행할 수 있습니다.

00:12:43.000 --> 00:12:53.000
이 새로운 rect를 통해, 우리는 당신의 뷰와 변환된KeyboardFrameEnd의 교차점을 계산하여 당신의 뷰에 필요한 오프셋을 결정할 수 있습니다.

00:12:53.000 --> 00:13:02.000
보기와 키보드가 겹치는 경우, 필요한 오프셋은 이제 보기와 키보드 사이의 교차점의 높이가 될 것입니다.

00:13:02.000 --> 00:13:06.000
그리고 그것으로, 당신은 당신이 원하는 대로 제약이나 레이아웃을 조정할 수 있습니다.

00:13:06.000 --> 00:13:13.000
이제, 새로운 프로세스 아키텍처와 함께, 당신이 알아야 할 알림과 함께 행동에 약간의 변화가 있을 수 있습니다.

00:13:13.000 --> 00:13:15.000
그러니 잠시 시간을 내어 그것에 대해 이야기해 봅시다.

00:13:15.000 --> 00:13:19.000
키보드 프로세스의 수명 주기를 요약한 이 다이어그램을 기억하시나요?

00:13:19.000 --> 00:13:24.000
여기서 "생태를 불러오다"라고 불리는 애니메이션 단계를 확대해 봅시다.

00:13:24.000 --> 00:13:34.000
앱이 키보드를 요청할 때 진행 중인 아키텍처에서 시스템은 키보드 UI를 동기적으로 초기화한 다음 알림을 게시하고 애니메이션을 수행합니다.

00:13:34.000 --> 00:13:46.000
그러나, 새로운 프로세스 아키텍처에서, 앱이 키보드를 요청할 때, 시스템은 키보드 UI를 비동기적으로 초기화한 다음 비동기적으로 알림을 게시하고 애니메이션을 수행합니다.

00:13:46.000 --> 00:14:06.000
이것은 타이밍에 약간의 차이를 도입하므로, 앱이 becomeFirstResponder를 호출하는 일종의 "콜백"으로 알림의 타이밍에 의존하거나, 알림 처리가 지연될 수 있는 메인 스레드에서 중요한 작업을 수행하는 경우, 앱에 영향을 미칠 수 있으므로 이 새로운 모델을 염두에 두어야 합니다.

00:14:06.000 --> 00:14:17.000
이제 사용자가 가능한 한 쉽게 앱에 입력할 수 있도록 이러한 모든 팁과 트릭을 검토했으므로, 텍스트 입력을 더욱 빠르게 만드는 새로운 기능과 API를 소개하게 되어 기쁩니다.

00:14:17.000 --> 00:14:21.000
그리고 그건 인라인 예측이야.

00:14:21.000 --> 00:14:28.000
iOS 17에서 영어 키보드는 이제 텍스트 필드와 인라인으로 다음 몇 단어에 대한 예측을 제공합니다.

00:14:28.000 --> 00:14:35.000
이러한 예측은 장치에서 안전하게 생성되며 집중된 텍스트 필드에 제공된 문맥 정보만 사용합니다.

00:14:35.000 --> 00:14:38.000
이러한 예측을 채택하는 것도 정말 쉽다.

00:14:38.000 --> 00:14:48.000
여기에 UITextInputTraits 프로토콜이 있으며, 보시다시피, 새로운 inlinePredictionType 속성이 추가되었으며, 몇 가지 옵션이 제공됩니다.

00:14:48.000 --> 00:14:58.000
기본적으로 인라인 예측은 대부분의 텍스트 입력 필드에서 활성화되지만, 검색 필드나 비밀번호 필드와 같이 예측이 적절하지 않은 필드에서는 자동으로 비활성화됩니다.

00:14:58.000 --> 00:15:05.000
그리고 물론, 속성을 예 또는 아니오로 명시적으로 설정하여 앱의 동작을 사용자 정의할 수도 있습니다.

00:15:05.000 --> 00:15:09.000
그리고 그것으로, 몇 가지 주요 테이크아웃을 요약해 봅시다.

00:15:09.000 --> 00:15:16.000
기억하세요: 어떻게 나타나든 키보드와 원활하게 작동하도록 앱을 디자인하세요.

00:15:16.000 --> 00:15:21.000
시간에 민감한 코드를 작성할 때 새로운 프로세스 키보드 모델을 염두에 두세요.

00:15:21.000 --> 00:15:26.000
그리고 텍스트 입력을 가속화하는 API를 채택하여 앱의 경험을 개선하세요.

00:15:26.000 --> 00:15:29.000
키보드를 따라와줘서 고마워.

00:15:29.000 --> 23:59:59.000
♪ ♪

