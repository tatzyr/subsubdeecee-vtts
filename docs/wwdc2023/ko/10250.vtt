WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:15.000
다리우스: 안녕하세요, 저는 다리우스입니다. 저는 Xcode Playgrounds 팀의 엔지니어입니다.

00:00:15.000 --> 00:00:23.000
Xcode Playgrounds의 개선이 어떻게 프로젝트의 새로운 기능을 더 쉽게 프로토타입할 수 있는지 보여주고 싶습니다.

00:00:23.000 --> 00:00:28.000
Xcode Playgrounds가 워크플로우를 개선할 수 있는 많은 시나리오가 있습니다.

00:00:28.000 --> 00:00:40.000
우선, 새로운 기능의 프로토타입을 만들거나 코드의 작은 변경을 시도하고 싶을 때마다 프로젝트를 재구축하고 재실행하는 것을 건너뛸 수 있습니다.

00:00:40.000 --> 00:00:51.000
그들은 또한 쇼핑 앱에서 주문 요약을 생성하는 논리와 같이 도달하기 어려운 코드를 훨씬 쉽게 실행할 수 있게 해준다.

00:00:51.000 --> 00:01:01.000
물론, 그러한 코드는 테스트로 검증될 수 있고 검증되어야 하지만, 놀이터는 그것들을 개발하기 위한 훌륭한 출발점이 될 수 있다.

00:01:01.000 --> 00:01:10.000
또한 프로젝트에 새로운 종속성을 도입하기 전에 코드를 시도하기에 완벽한 환경입니다.

00:01:10.000 --> 00:01:14.000
Xcode Playgrounds가 제 프로젝트에서 저를 어떻게 돕고 있는지 보여드리고 싶습니다.

00:01:14.000 --> 00:01:20.000
저는 야생 동물 사진을 찍는 데 도움이 되는 작은 앱을 개발하고 있습니다.

00:01:20.000 --> 00:01:26.000
현재, 내 앱은 내가 이미 발견하고 촬영한 종을 추적하는 데 도움을 준다.

00:01:26.000 --> 00:01:37.000
이제, 저는 이 앱이 실제로 동물을 찾는 야생 동물 사진의 매우 중요한 한 가지 측면에 도움이 되었으면 합니다.

00:01:37.000 --> 00:01:42.000
체크리스트 보기를 위한 새로운 탭을 소개하고 싶습니다.

00:01:42.000 --> 00:01:48.000
나는 이미 그 뷰를 구현하기 시작했고, 이 사용자 인터페이스에 꽤 만족한다.

00:01:48.000 --> 00:01:53.000
각 새에는 내 진행 상황을 추적할 수 있는 체크박스가 있다.

00:01:53.000 --> 00:01:59.000
하지만, 목록에 2,000마리가 넘는 새가 있는 상황에서, 나는 아마 내가 많이 발전하고 있다고 느끼지 않을 것이다.

00:01:59.000 --> 00:02:04.000
이 목록을 조금 좁히는 것이 좋을 것이다.

00:02:04.000 --> 00:02:11.000
그렇게 하려면, 사용자 지정 ChecklistView에서 birdsToShow 계산 속성을 조정해야 합니다.

00:02:11.000 --> 00:02:21.000
현재, 그것은 단순히 북미를 위해 구성된 BirdProvider 유형을 만들고 대륙 전체에서 발견되는 모든 조류 종을 반환합니다.

00:02:21.000 --> 00:02:34.000
잦은 재구축 및 재실행을 피하고 ChecklistView로 이동하여 변경 사항을 보려면 Xcode Playground에서 이 코드를 조정하려고 노력할 것입니다.

00:02:34.000 --> 00:02:40.000
나는 내 프로젝트에 새로운 놀이터를 추가하는 것으로 시작할 것이다.

00:02:40.000 --> 00:02:44.000
이것은 iOS 앱이므로, 저는 iOS 템플릿을 고수할 것입니다.

00:02:44.000 --> 00:02:55.000
필터 바에 "놀이터"를 입력하고 빈 놀이터를 선택하겠습니다.

00:02:55.000 --> 00:03:07.000
이 경우, 나는 아마 몇 가지를 시도하면 놀이터를 없앨 것이므로, 기본 "MyPlayground" 이름을 유지할 수 있다.

00:03:07.000 --> 00:03:15.000
나는 놀이터의 기본 내용을 없앨 것이다.

00:03:15.000 --> 00:03:30.000
더 빨리 반복하기 위해, 하단 막대의 실행 버튼을 길게 클릭할 때 나타나는 메뉴에서 "자동 실행"으로 전환할 것입니다.

00:03:30.000 --> 00:03:36.000
이것은 내가 변경을 멈출 때마다 놀이터가 전체 코드를 자동으로 실행하게 한다.

00:03:36.000 --> 00:03:45.000
프로젝트에 추가된 놀이터에는 기본적으로 두 가지 설정이 활성화되어 있습니다: 활성 계획 구축 및 앱 유형 가져오기.

00:03:45.000 --> 00:03:54.000
그들은 각 놀이터 실행 전에 활성 계획이 구축되고 앱 대상 모듈이 자동으로 가져오도록 할 것이다.

00:03:54.000 --> 00:03:59.000
이렇게 하면 프로젝트 내에서 정의된 유형으로 훨씬 쉽게 작업할 수 있습니다.

00:03:59.000 --> 00:04:05.000
나는 놀이터를 위한 공간을 좀 더 주기 위해 검사관을 닫을 수 있다.

00:04:05.000 --> 00:04:19.000
내 ChecklistView의 birdsToShow 속성에서 본 것처럼 BirdProvider 인스턴스를 선언하는 것으로 시작합시다.

00:04:19.000 --> 00:04:27.000
편집자 오른쪽에 있는 결과 사이드바는 이 선언이 놀이터 결과를 생성했다는 것을 보여준다.

00:04:27.000 --> 00:04:33.000
인라인 결과 토글을 사용하여 더 자세한 내용을 볼 수 있습니다.

00:04:33.000 --> 00:04:43.000
인라인 결과는 두 가지 속성과 함께 이 BirdProvider 인스턴스의 세부 사항을 보여줍니다: 새 배열과 제공된 영역.

00:04:43.000 --> 00:04:58.000
이제 Xcode 15에서 각 행에는 유형에 대한 짧은 요약을 보여주는 유형 정보 라벨이 있으며, 각 행의 툴팁을 사용하여 자세한 내용을 볼 수 있습니다.

00:04:58.000 --> 00:05:10.000
예를 들어, 툴팁은 BirdProvider 유형이 내 앱 모듈에서 왔으며 지역 열거형이 그 구조 내에서 정의되었다는 것을 알려줍니다.

00:05:10.000 --> 00:05:17.000
새들에 대한 자세한 내용을 보려면 배열 행을 확장해 봅시다.

00:05:17.000 --> 00:05:26.000
인라인 결과 보기와 상호 작용하기 시작할 때, Xcode 15는 결과를 생성한 소스 코드를 강조합니다.

00:05:26.000 --> 00:05:31.000
이 경우, 뷰는 birdProvider 상수에 할당된 값을 표시합니다.

00:05:31.000 --> 00:05:37.000
이것은 표시된 값을 훨씬 더 쉽게 이해할 수 있게 해준다.

00:05:37.000 --> 00:05:45.000
배열 요소를 자세히 살펴봅시다.

00:05:45.000 --> 00:05:54.000
우리는 지역과 새 배열 속성에 대한 좋은 요약을 보았지만, 기본적으로 각 새를 나타내는 행은 배열 인덱스에 대해서만 알려줍니다.

00:05:54.000 --> 00:06:00.000
그것은 사용자 지정 새 유형에 정의된 설명이 없기 때문이다.

00:06:00.000 --> 00:06:06.000
우리는 Bird 유형이 CustomStringConvertible 프로토콜을 준수하도록 함으로써 이것을 개선할 수 있습니다.

00:06:06.000 --> 00:06:12.000
여기 놀이터나 소스 디렉토리에 확장 프로그램을 추가할 수 있습니다.

00:06:12.000 --> 00:06:23.000
이 두 옵션 모두 놀이터 범위의 새 유형에만 영향을 미칠 것이며, 디버거와 같이 그들에게 의존하는 다른 곳에서는 멋진 새로운 설명을 얻지 못할 것입니다.

00:06:23.000 --> 00:06:34.000
그것이 내가 버드 유형을 정의하는 파일에 확장자를 추가하는 이유이다.

00:06:34.000 --> 00:06:40.000
새로운 설명 정의와 함께, 각 행은 나에게 새의 공통적이고 과학적인 이름을 보여줘야 한다.

00:06:40.000 --> 00:06:47.000
놀이터로 돌아가서 새로운 설명이 작동하는 것을 봅시다.

00:06:47.000 --> 00:06:53.000
놀이터 실행의 자동 모드에서, 놀이터는 다시 열면 자동으로 다시 실행됩니다.

00:06:53.000 --> 00:07:02.000
설명을 확인하기 위해 새 배열 행을 다시 확장해 봅시다.

00:07:02.000 --> 00:07:04.000
이게 훨씬 나아.

00:07:04.000 --> 00:07:14.000
이제 행을 확장하지 않고 무엇을 나타내는지는 분명하지만, 새 유형의 다른 속성을 살펴봅시다.

00:07:14.000 --> 00:07:26.000
나는 이미 이 새들 중 일부를 발견하고 사진을 찍었고, 그들 중 일부는 이미 이 대서양 퍼핀과 같은 사진 속성을 가지고 있다는 것을 알 수 있다.

00:07:26.000 --> 00:07:41.000
행을 클릭하면, 사진은 새로운 분할 보기 기반 사용자 인터페이스에 표시되며, 미리보기와 함께 개체의 구조를 볼 수 있습니다.

00:07:41.000 --> 00:07:47.000
기본적으로, 행을 클릭할 때 사용자 지정 새 유형에 대한 미리보기가 없습니다.

00:07:47.000 --> 00:07:53.000
나는 모든 종 이름에 익숙하지 않기 때문에, 이미 여기서 사진을 보는 것이 좋을 것이다.

00:07:53.000 --> 00:07:59.000
이를 달성하기 위해 CustomPlaygroundDisplayConvertible 프로토콜을 사용할 수 있습니다.

00:07:59.000 --> 00:08:18.000
프로토콜의 이름에서 알 수 있듯이, 이 적합성은 놀이터 표현에만 영향을 미치므로, 이번에는 놀이터의 소스 디렉토리에 확장을 추가할 것입니다.

00:08:18.000 --> 00:08:29.000
새 유형에 액세스하기 위해 앱 모듈을 가져오고 사진 속성을 playgroundDescription으로 반환하는 간단한 확장을 추가할 것입니다.

00:08:29.000 --> 00:08:34.000
제가 반품 명세서에서 Any에 명시적으로 사진을 캐스팅하고 있다는 것을 주목하세요.

00:08:34.000 --> 00:08:41.000
그것 없이는, 컴파일러는 우리가 선택 사항인 가치에 대한 중요한 정보를 잃고 있다고 경고할 것이다.

00:08:41.000 --> 00:08:53.000
이 경우 Xcode Playgrounds는 playgroundDescription 속성에서 nil을 반환하지 않는 객체에 대한 사용자 지정 설명만 생성하여 옵션을 처리하기 때문에 괜찮습니다.

00:08:53.000 --> 00:09:00.000
새로운 설명을 확인하기 위해 다시 놀이터로 돌아가자.

00:09:00.000 --> 00:09:18.000
Xcode 15에서 CustomPlaygroundDisplayConvertible을 준수하는 유형으로 반환된 playgroundDescription은 개체의 구조를 따라 분할 보기에 표시됩니다.

00:09:18.000 --> 00:09:24.000
이제, 이미 사진을 가지고 있는 새들은 줄을 확장할 필요 없이 빠르게 보여줄 것이다.

00:09:24.000 --> 00:09:31.000
이것은 이 사용자 지정 유형의 대규모 컬렉션으로 작업하는 것을 훨씬 쉽게 만들 것이다.

00:09:31.000 --> 00:09:35.000
하지만 오늘, 저는 아직 사진이 없는 새들에 집중하고 싶습니다.

00:09:35.000 --> 00:09:48.000
이 인라인 결과를 닫고 이미 사진이 있는 모든 새를 걸러내자.

00:09:48.000 --> 00:09:52.000
당신은 그 두 개의 사이드바 주석이 조금 다르게 보인다는 것을 알 수 있습니다.

00:09:52.000 --> 00:09:55.000
그것은 새로운 줄에 여러 표현이 있기 때문이다.

00:09:55.000 --> 00:10:04.000
새 컨트롤을 클릭하여 각 표현식에 대한 친숙한 요약을 볼 수 있습니다.

00:10:04.000 --> 00:10:10.000
인라인 결과 토그 위에 마우스를 올려놓는 것은 소스 코드 범위를 강조한다.

00:10:10.000 --> 00:10:25.000
이것은 배열이 birdsToFind 상수에 할당된 결과이며 true는 필터 함수에 전달된 클로저에 의해 생성된 최신 값임을 분명히 합니다.

00:10:25.000 --> 00:10:33.000
결과 사이드바에 따르면 내가 아직 촬영하지 않은 모든 새의 수는 여전히 1,800마리가 넘으며, 이는 꽤 위협적이다.

00:10:33.000 --> 00:10:41.000
이것이 궁극적으로 목표가 될 수 있지만, 나는 올빼미와 같은 더 작은 무리의 새들에 집중함으로써 그것을 낮추고 싶다.

00:10:41.000 --> 00:10:46.000
6월은 울부짖기 좋은 달이지만, 그것은 또 다른 한두 세션의 주제이다.

00:10:46.000 --> 00:10:57.000
다른 가족의 새들을 걸러내자.

00:10:57.000 --> 00:11:02.000
배열에는 이제 다섯 가지 요소만 있는데, 이는 훨씬 더 고무적이다.

00:11:02.000 --> 00:11:07.000
저는 이 작은 새 그룹과 함께 사용자 지정 ChecklistView를 사용해 보고 싶습니다.

00:11:07.000 --> 00:11:22.000
그렇게 하기 위해, 나는 ChecklistView 인스턴스를 만들고 각 새를 하나씩 추가할 것이다.

00:11:22.000 --> 00:11:27.000
ChecklistView의 인라인 결과를 열어봅시다.

00:11:27.000 --> 00:11:33.000
UIView 서브클래스로서, 이제 스냅샷과 함께 몇 가지 속성을 보여줍니다.

00:11:33.000 --> 00:11:45.000
이제 새로운 분할 보기 기반 사용자 인터페이스를 사용하는 값 기록 모드로 전환할 수 있습니다.

00:11:45.000 --> 00:11:58.000
이것은 내가 각 루프 반복에서 ChecklistView가 어떻게 생겼는지 볼 수 있게 해준다.

00:11:58.000 --> 00:12:06.000
그것은 실제로 한 마리의 새에 대한 헤더에 "새"라고 잘못 적힌 내 견해에 문제를 찾는 데 도움이 되었다.

00:12:06.000 --> 00:12:16.000
새로운 문자열 카탈로그에 정의된 문자열을 조정하여 이 문제를 해결할 수 있어야 합니다.

00:12:16.000 --> 00:12:20.000
첫 번째 행은 내 체크리스트 뷰의 헤더에 사용되는 것 같다.

00:12:20.000 --> 00:12:28.000
컨텍스트 메뉴를 불러와서 Vary By Plural을 선택하겠습니다.

00:12:28.000 --> 00:12:33.000
일단 그렇게 하면, 영향을 받는 행은 상태를 "검토 필요"로 바꾼다.

00:12:33.000 --> 00:12:41.000
나는 이 문자열의 단수 형태를 조정할 것이다.

00:12:41.000 --> 00:12:48.000
새로운 문자열 카탈로그에 대해 자세히 알아보려면, "문자열 카탈로그 찾기" 세션을 확인하세요.

00:12:48.000 --> 00:13:02.000
놀이터로 돌아가서 이 변화와 함께 체크리스트가 어떻게 생겼는지 봅시다.

00:13:02.000 --> 00:13:13.000
헤더는 각 루프 반복에서 올바르게 보인다.

00:13:13.000 --> 00:13:19.000
나는 지금 이 인라인 결과를 닫을 수 있다.

00:13:19.000 --> 00:13:21.000
내 체크리스트뷰를 사용할 준비가 된 것 같아.

00:13:21.000 --> 00:13:30.000
새 목록을 좁히는 데 사용한 코드를 내 프로젝트에 빨리 가져올게.

00:13:30.000 --> 00:13:39.000
이 세 줄을 내 ChecklistView의 birdsToShow 속성에 복사하겠습니다.

00:13:39.000 --> 00:13:57.000
나는 또한 새롭고 훨씬 더 작은 새들과 함께 반환 진술을 추가할 것이다.

00:13:57.000 --> 00:14:02.000
프로젝트를 다시 실행하기 전에, 기능을 하나 더 프로토타입하고 싶습니다.

00:14:02.000 --> 00:14:06.000
내 사용자 지정 체크리스트 보기의 각 행에 공개 표시기가 있다는 것을 알 수 있습니다.

00:14:06.000 --> 00:14:12.000
목록에서 행을 선택하면, 간단한 지도 보기가 열립니다.

00:14:12.000 --> 00:14:20.000
아직 그렇게 유용하지는 않지만, 선택된 새의 가장 최근 목격에 대한 데이터를 가져와서 지도에 보여주고 싶습니다.

00:14:20.000 --> 00:14:27.000
그것을 달성하기 위해, 나는 ChecklistView에서 sightingsToShow(for bird:) 기능을 조정해야 할 것이다.

00:14:27.000 --> 00:14:32.000
그것을 돕기 위해, 나는 이미 내 프로젝트에 하나의 의존성을 추가했다.

00:14:32.000 --> 00:14:41.000
BirdSightings 패키지를 사용하면 사람들이 목격을 보고하는 시민 과학 웹사이트 중 하나에서 데이터를 쉽게 가져올 수 있습니다.

00:14:41.000 --> 00:14:46.000
나는 그 패키지를 사용해 본 적이 없어서, 아직 API에 익숙하지 않다.

00:14:46.000 --> 00:14:57.000
운 좋게도, 그 패키지에는 몇 가지 예를 보여주는 놀이터 형태의 문서가 포함되어 있다.

00:14:57.000 --> 00:15:04.000
이것은 패키지의 고객이 제공된 API를 사용해 볼 수 있는 좋은 방법입니다.

00:15:04.000 --> 00:15:13.000
fetchSightings 함수에 두 가지 인수를 제공해야 할 것 같습니다: 찾아야 할 새의 코드와 둘러볼 위치.

00:15:13.000 --> 00:15:22.000
나는 예상 결과에 대해 더 배우기 위해 이 놀이터를 실행할 수 있다.

00:15:22.000 --> 00:15:37.000
우리 놀이터로 돌아가서 사용해 보자.

00:15:37.000 --> 00:15:44.000
편집자 영역에 더 많은 공간을 주기 위해 네비게이터를 닫을 수 있습니다.

00:15:44.000 --> 00:15:49.000
함수를 호출하기 전에, 두 개의 가져오기 문을 추가해야 합니다.

00:15:49.000 --> 00:16:01.000
좌표와 BirdSighting 프레임워크를 사용하여 API를 사용할 수 있도록 CoreLocation 프레임워크를 가져올 것입니다.

00:16:01.000 --> 00:16:14.000
함수 인수의 경우, 우리는 단순히 목록의 첫 번째 새부터 시작할 수 있습니다.

00:16:14.000 --> 00:16:18.000
우리가 귀가 짧은 올빼미를 찾을 것 같아.

00:16:18.000 --> 00:16:21.000
제가 여기서 강제 포장을 푼다는 것을 주목하세요.

00:16:21.000 --> 00:16:31.000
플레이그라운드 환경에서 오류 처리에 대해 그렇게 많이 걱정할 필요는 없지만, 프로젝트에 코드를 가져올 때 그것을 명심하는 것이 중요합니다.

00:16:31.000 --> 00:16:44.000
위치에 관해서는, 나는 아마 대부분의 시간에 현재 위치를 사용할 것이지만, 특정 좌표를 제공하는 능력은 두 가지에 적합할 것이다: 내 코드를 테스트하고 모든 도로 여행을 계획하는 것이다.

00:16:44.000 --> 00:16:53.000
애플 파크 주변에서 무엇을 찾을 수 있는지 봅시다.

00:16:53.000 --> 00:17:02.000
네트워크 호출을 소개하기 전에, 불필요한 호출을 피할 수 있도록 놀이터 실행의 수동 모드로 전환할 것입니다.

00:17:02.000 --> 00:17:08.000
그러한 요청은 시간이 걸릴 수 있으며, 가능한 한 빨리 새로운 기능을 반복하고 싶습니다.

00:17:08.000 --> 00:17:20.000
그렇게 하기 위해, 나는 다시 한 번 하단 바의 메뉴를 불러와 수동 실행을 선택할 것이다.

00:17:20.000 --> 00:17:25.000
이제, 나는 실행되어야 하는 코드의 부분을 완전히 통제할 수 있다.

00:17:25.000 --> 00:17:33.000
가져오기 코드를 추가해 봅시다.

00:17:33.000 --> 00:17:42.000
소스 편집기 거터의 컨트롤은 그 두 줄을 실행하면 위에서 이미 실행한 모든 줄을 다시 실행하지 않는다는 것을 보여준다.

00:17:42.000 --> 00:17:49.000
새 줄을 실행하고 데이터가 있는지 봅시다.

00:17:49.000 --> 00:17:52.000
운 좋게도, 몇 가지 목격이 있다.

00:17:52.000 --> 00:18:02.000
가장 최근의 첫 번째 것을 살펴봅시다.

00:18:02.000 --> 00:18:07.000
짧은 귀 올빼미가 가장 최근에 창먼 절벽 보호구역에서 목격된 것 같다.

00:18:07.000 --> 00:18:17.000
나는 아직 그 지역의 모든 조류 관찰 핫스팟에 익숙하지 않기 때문에, 내 SightingMapView에서 목격에 대한 데이터를 보는 것이 좋을 것이다.

00:18:17.000 --> 00:18:25.000
가져온 목격 데이터로 초기화해 봅시다.

00:18:25.000 --> 00:18:35.000
지도 뷰와 같은 복잡한 사용자 인터페이스 요소의 경우, 놀이터 라이브 뷰를 사용하여 크고 완전한 대화형 미리보기를 볼 수 있습니다.

00:18:35.000 --> 00:18:44.000
그것을 사용하려면, 먼저 PlaygroundSupport 프레임워크를 가져와야 합니다.

00:18:44.000 --> 00:18:56.000
이제, 저는 라이브 뷰를 설정하고 놀이터를 실행할 준비가 되었습니다.

00:18:56.000 --> 00:19:08.000
파일 상단에 가져오기 문을 추가하여 놀이터의 이미 실행된 부분을 수정했기 때문에 소스 편집기 거터의 컨트롤은 전체 파일을 다시 실행해야 한다고 알려줍니다.

00:19:08.000 --> 00:19:23.000
나는 마지막 실행에서 결과를 잃을 것이지만, 이 경우에는 문제가 되지 않을 것이므로, 나는 계속해서 놀이터를 실행할 것이다.

00:19:23.000 --> 00:19:27.000
나는 애플 파크와 너무 가까운 섬을 기억하지 못한다.

00:19:27.000 --> 00:19:44.000
라이브 뷰는 완전히 인터랙티브하기 때문에, 나는 우리가 어디에 있는지 보기 위해 아이폰 시뮬레이터에서 하는 것처럼 조금 축소할 수 있다.

00:19:44.000 --> 00:19:47.000
우리가 너무 동쪽에 있는 것 같아.

00:19:47.000 --> 00:19:58.000
편집기 옵션에서 라이브 뷰를 닫고 문제가 어디에 도입됐는지 봅시다.

00:19:58.000 --> 00:20:05.000
내 SightingMapView는 mostRecentSighting 상수로 초기화되므로, 그 값을 확인해 봅시다.

00:20:05.000 --> 00:20:16.000
인라인 결과를 여는 대신, 사이드바의 눈 아이콘을 클릭하여 값을 빠르게 살펴볼 수 있습니다.

00:20:16.000 --> 00:20:23.000
Xcode 15에서, 우리는 일부 MapKit 및 CoreLocation 유형의 놀이터 결과를 개선했습니다.

00:20:23.000 --> 00:20:34.000
놀이터는 이제 CLLocationCoordinate2D의 미리보기를 보여줄 수 있으므로, 위치 속성을 살펴봅시다.

00:20:34.000 --> 00:20:40.000
이것은 같은 위치를 가리키는 것 같아서, 이것은 내 SightingMapView로 인한 것이 아닌 것 같다.

00:20:40.000 --> 00:20:50.000
우리는 BirdSightings 패키지에서 잘못된 위치를 얻었기 때문에 패키지의 문제로 인해 발생할 수 있거나, 내가 시작하기 위해 잘못된 위치를 통과했을 수 있습니다.

00:20:50.000 --> 00:20:57.000
후자를 확인해 봅시다.

00:20:57.000 --> 00:21:07.000
이것은 애플 파크와도 가깝지 않은 것 같다.

00:21:07.000 --> 00:21:13.000
우리가 너무 동쪽에 있기 때문에, 나는 이것이 단지 서쪽과 동쪽을 섞는 문제일 수도 있다고 생각한다.

00:21:13.000 --> 00:21:26.000
경도 앞에 빼기 기호를 추가하고 놀이터를 다시 실행하여 이 문제를 해결해 봅시다.

00:21:26.000 --> 00:21:37.000
이제 이곳은 확실히 애플 파크야.

00:21:37.000 --> 00:21:52.000
업데이트된 위치로 놀이터의 나머지 부분을 실행하고 편집기 옵션에서 라이브 뷰를 다시 열어 봅시다.

00:21:52.000 --> 00:21:58.000
그게 더 비슷해.

00:21:58.000 --> 00:22:03.000
이제 나는 코요테 힐스가 새로운 종을 촬영하기에 가장 좋은 장소일지도 모른다는 것을 안다.

00:22:03.000 --> 00:22:12.000
가져오기 코드를 내 ChecklistView로 빨리 가져오자.

00:22:12.000 --> 00:22:21.000
이 세 줄을 sightingsToShow 기능에 복사하겠습니다.

00:22:21.000 --> 00:22:41.000
여기서 항상 하드코딩된 Apple Park 위치를 사용하는 대신, CLLocationManager에서 받은 lastCurrentLocation으로 교체하겠습니다.

00:22:41.000 --> 00:22:49.000
나는 또한 새로운 mostRecentSighting과 함께 반품 명세서를 추가할 것이다.

00:22:49.000 --> 00:23:00.000
마침내 우리의 변화와 함께 프로젝트를 실행할 시간이다.

00:23:00.000 --> 00:23:10.000
우리가 작은 무리의 새들에게 초점을 맞춘 지금 그 체크리스트는 훨씬 더 현실적으로 보인다.

00:23:10.000 --> 00:23:16.000
내가 지금 행을 클릭하면 어떻게 되는지 보자.

00:23:16.000 --> 00:23:17.000
그거 좋네.

00:23:17.000 --> 00:23:22.000
내 앱은 이제 선택된 새에 대한 가장 최근의 관찰을 보여줄 수 있다.

00:23:22.000 --> 00:23:25.000
물론 여전히 개선의 여지가 많다.

00:23:25.000 --> 00:23:34.000
예를 들어, 목격이 백그라운드에서 가져오는 동안 진행률 지표를 보여줘야 하지만, 이것은 훌륭한 출발점이다.

00:23:34.000 --> 00:23:41.000
이 앱은 이미 나에게 많은 도움이 될 것이며, Xcode Playgrounds는 이러한 개선 작업을 훨씬 쉽게 만들었다.

00:23:41.000 --> 00:23:47.000
이 세션에서, 우리는 Xcode Playgrounds를 사용하여 프로젝트의 새로운 기능을 빠르게 프로토타입했습니다.

00:23:47.000 --> 00:23:57.000
우리는 CustomStringConvertible과 CustomPlaygroundDisplayConvertible 프로토콜을 사용하여 사용자 지정 유형의 표현을 사용자 정의했습니다.

00:23:57.000 --> 00:24:02.000
우리는 놀이터 실행 모드를 조정하는 방식이 어떻게 당신의 작업 흐름을 가속화할 수 있는지 보았습니다.

00:24:02.000 --> 00:24:10.000
값 기록 모드를 사용하면 수업이 여러 입력에 어떻게 반응하는지 빠르게 볼 수 있었습니다.

00:24:10.000 --> 00:24:17.000
마지막으로, 우리는 놀이터의 라이브 뷰를 사용하여 복잡한 사용자 인터페이스 요소를 자세히 살펴보았다.

00:24:17.000 --> 23:59:59.000
봐줘서 고마워.

