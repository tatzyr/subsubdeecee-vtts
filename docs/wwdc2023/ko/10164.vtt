WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:14.000
벤: 안녕하세요, "스위프트 5.9의 새로운 기능"에 오신 것을 환영합니다.

00:00:14.000 --> 00:00:19.000
저는 벤이고, 제 동료 더그와 함께 올해 스위프트 언어의 몇 가지 개선 사항을 안내해 드리겠습니다.

00:00:19.000 --> 00:00:40.000
우리는 스위프트의 깨끗한 구문을 사용하여 의미하는 바를 더 쉽게 표현할 수 있는 몇 가지 방법, 프레임워크 작성자가 새로운 API를 더 자연스럽게 사용할 수 있도록 도와주는 몇 가지 강력한 새로운 기능에 대해 이야기할 것이며, 저수준 코드에서 성능과 안전성을 더 잘 제어할 수 있는 몇 가지 새로운 방법을 살펴볼 것입니다.

00:00:40.000 --> 00:00:44.000
하지만 스위프트 오픈 소스 프로젝트에 대해 이야기하는 것으로 시작합시다.

00:00:44.000 --> 00:00:59.000
이것은 스위프트를 위한 훌륭한 업데이트이며, 스위프트 커뮤니티, swift.org에 모인 언어의 기여자 및 사용자가 언어를 발전시키고 새로운 이니셔티브를 지원하기 위해 함께 일하지 않고는 일어날 수 없었을 것입니다.

00:00:59.000 --> 00:01:02.000
스위프트는 언어 진화를 위한 열린 과정을 따른다.

00:01:02.000 --> 00:01:09.000
새로운 기능이나 중요한 행동 변화는 스위프트 포럼에서 공개적으로 제안되고 검토됩니다.

00:01:09.000 --> 00:01:16.000
따라가고 싶다면, 스위프트 웹사이트에서 모든 언어 제안의 대시보드를 찾을 수 있습니다.

00:01:16.000 --> 00:01:20.000
1년 전, 우리는 스위프트 프로젝트 거버넌스의 중요한 구조 조정을 보았다.

00:01:20.000 --> 00:01:30.000
핵심 팀은 스위프트 언어와 표준 도서관 진화를 감독하는 주요 책임을 맡은 언어 운영 그룹의 설립을 발표했다.

00:01:30.000 --> 00:01:38.000
그 이후로, 언어 그룹은 40개의 새로운 언어 제안을 감독했으며, 우리는 오늘 그 중 몇 가지에 대해 이야기할 것이다.

00:01:38.000 --> 00:01:50.000
하지만 때때로, 개별 언어 제안은 10개의 개별 제안을 통해 도입된 스위프트 동시성의 추가와 같은 더 넓은 주제의 일부로 모인다.

00:01:50.000 --> 00:01:57.000
이와 같은 경우, 언어 운영 그룹은 비전 문서를 통해 이러한 제안을 하나로 묶는 새로운 방법을 도입했다.

00:01:57.000 --> 00:02:02.000
이 문서들은 언어에 대한 더 큰 변화를 위한 제안을 제시한다.

00:02:02.000 --> 00:02:13.000
언어 운영 그룹이 처음으로 받아들인 것은 이 이야기의 뒷부분에서 다룰 스위프트 5.9의 새로운 기능인 스위프트 매크로의 비전이었다.

00:02:13.000 --> 00:02:17.000
물론, 언어의 진화는 스위프트 커뮤니티의 작업의 일부일 뿐이다.

00:02:17.000 --> 00:02:20.000
성공적인 언어는 이것보다 훨씬 더 많은 것을 필요로 한다.

00:02:20.000 --> 00:02:27.000
훌륭한 도구, 여러 플랫폼에 대한 강력한 지원, 풍부한 문서가 필요합니다.

00:02:27.000 --> 00:02:35.000
이 분야의 진전을 감독하기 위해, 핵심 팀은 언어 운영 그룹과 평행하게 생태계 운영 그룹을 만들고 있다.

00:02:35.000 --> 00:02:44.000
이 새로운 구조는 최근 Swift.org의 블로그 게시물에 배치되었으며, 곧 이 새로운 그룹의 형성에 대한 추가 발표를 살펴보세요.

00:02:44.000 --> 00:02:52.000
이제 코드에서 자신을 표현하는 더 나은 방법부터 시작하여 올해 스위프트 언어의 변경 사항에 대해 이야기해 봅시다.

00:02:52.000 --> 00:03:07.000
스위프트 5.9에는 아마도 가장 일반적으로 요청되는 언어 향상이 포함되어 있으며, if/else 및 switch 문을 표현식으로 사용할 수 있어 코드를 정리할 수 있는 좋은 방법을 제공합니다.

00:03:07.000 --> 00:03:19.000
예를 들어, 복잡한 조건에 따라 let 변수를 초기화하고 싶다면, 읽기 어려운 복합 삼원 표현식과 같은 트릭에 의존해야 했습니다.

00:03:19.000 --> 00:03:27.000
If 표현을 사용하면 대신 훨씬 더 친숙하고 읽을 수 있는 if 문 체인을 사용할 수 있습니다.

00:03:27.000 --> 00:03:33.000
이것이 도움이 되는 또 다른 장소는 글로벌 변수나 저장된 속성을 초기화하는 경우입니다.

00:03:33.000 --> 00:03:43.000
단일 표현식은 여기서 잘 작동하지만, 조건을 원한다면, 즉시 실행한 클로저로 감싸는 트릭을 사용해야 했습니다.

00:03:43.000 --> 00:03:51.000
이제 if 문이 표현이 될 수 있으므로, 그 혼란을 버리고 더 깔끔한 코드를 남길 수 있습니다.

00:03:51.000 --> 00:04:06.000
SwiftUI와 같은 기능을 구동하는 선언적 구문인 결과 빌더는 최적화된 유형 검사 성능, 코드 완성 및 개선된 오류 메시지를 포함하여 올해 상당한 개선을 보았습니다.

00:04:06.000 --> 00:04:11.000
이 개선은 특히 잘못된 코드에 초점을 맞추었다.

00:04:11.000 --> 00:04:21.000
이전에는 유형 검사기가 많은 가능한 잘못된 경로를 탐색했기 때문에 오류가 있는 결과 빌더 코드가 실패하는 데 오랜 시간이 걸릴 것이다.

00:04:21.000 --> 00:04:31.000
스위프트 5.8부터, 유효하지 않은 코드 유형은 훨씬 더 빨리 확인하며, 유효하지 않은 코드에 대한 오류 메시지는 이제 더 정확합니다.

00:04:31.000 --> 00:04:39.000
예를 들어, 이전에 일부 유효하지 않은 코드는 결과 작성기의 완전히 다른 부분에서 오해의 소지가 있는 오류로 이어질 수 있습니다.

00:04:39.000 --> 00:04:46.000
스위프트 5.7에서, 실수가 실제로 여기에 있을 때, 당신은 이와 같은 오류를 받게 될 것입니다.

00:04:46.000 --> 00:04:53.000
최신 릴리스에서, 당신은 이제 실제 문제를 식별하는 더 정확한 컴파일러 진단을 받게 됩니다.

00:04:53.000 --> 00:05:02.000
다음으로, 제네릭 시스템에 추가하면 매일 사용하는 프레임워크를 어떻게 크게 개선할 수 있는지에 대해 이야기해 봅시다.

00:05:02.000 --> 00:05:06.000
당신이 쓰는 거의 모든 스위프트는 어떤 식으로든 제네릭을 사용하고 있습니다.

00:05:06.000 --> 00:05:13.000
유형 추론을 사용하면 내장된 고급 기능을 이해할 필요 없이 이러한 유형을 사용할 수 있습니다.

00:05:13.000 --> 00:05:22.000
예를 들어, 표준 라이브러리 배열 유형은 제네릭을 사용하여 저장하고 싶은 모든 유형의 데이터와 함께 작동하는 배열을 제공합니다.

00:05:22.000 --> 00:05:27.000
배열을 사용할 때, 요소를 제공하기만 하면 됩니다.

00:05:27.000 --> 00:05:36.000
요소 값에서 추론할 수 있기 때문에 요소 유형에 대한 명시적인 인수를 지정할 필요가 없습니다.

00:05:36.000 --> 00:05:47.000
스위프트의 제네릭 시스템은 당신이 제공하는 구체적인 유형에서 코드가 원활하게 작동하도록 유형 정보를 보존하는 자연 API를 가능하게 합니다.

00:05:47.000 --> 00:05:57.000
다음은 스위프트 컴파일러의 자체 코드베이스에서 영감을 받은 예입니다: 요청 유형을 취하고 강력하게 입력된 값을 생성하도록 평가하는 API.

00:05:57.000 --> 00:06:03.000
따라서 부울 값을 요청하고 부울 결과를 되돌릴 수 있습니다.

00:06:03.000 --> 00:06:12.000
이제, 일부 API는 구체적인 유형뿐만 아니라 당신이 전달하는 인수의 수를 추상화하기를 원합니다.

00:06:12.000 --> 00:06:22.000
따라서 함수는 하나의 요청을 받고 하나의 결과 또는 두 개의 요청을 반환하고 두 개의 결과 또는 세 개의 결과를 반환하고 세 개의 결과를 반환할 수 있습니다.

00:06:22.000 --> 00:06:34.000
이를 지원하기 위해, 제네릭 시스템은 여러 인수 길이를 처리하는 메커니즘과 함께 사용되어야 하므로 통과하는 모든 유형이 나가는 유형과 연결되어야 합니다.

00:06:34.000 --> 00:06:44.000
스위프트 5.9 이전에, 이 패턴을 달성하는 유일한 방법은 API가 지원하는 각 특정 인수 길이에 과부하를 추가하는 것이었다.

00:06:44.000 --> 00:06:47.000
하지만 이 접근 방식에는 한계가 있다.

00:06:47.000 --> 00:06:56.000
그것은 당신이 통과할 수 있는 인수의 수에 인위적인 상한을 강요하여, 너무 많이 통과하면 컴파일러 오류가 발생합니다.

00:06:56.000 --> 00:07:02.000
이 경우, 6개 이상의 인수를 처리할 수 있는 과부하가 없지만, 우리는 7개를 통과했습니다.

00:07:02.000 --> 00:07:12.000
이 오버로드 패턴과 그 한계는 개념적으로 임의의 인수 길이를 처리하는 API에 널리 퍼져 있다.

00:07:12.000 --> 00:07:23.000
스위프트 5.9에서 제네릭 시스템은 인수 길이에 대한 제네릭 추상화를 가능하게 함으로써 이 API 패턴에 대한 일류 지원을 얻고 있다.

00:07:23.000 --> 00:07:30.000
이것은 함께 "포장된" 여러 개별 유형 매개 변수를 나타낼 수 있는 새로운 언어 개념으로 이루어집니다.

00:07:30.000 --> 00:07:35.000
이 새로운 개념은 유형 매개 변수 팩이라고 불린다.

00:07:35.000 --> 00:07:49.000
매개 변수 팩을 사용하여, 현재 각 고정 인수 길이에 대한 개별 오버로드가 있는 API는 단일 함수로 축소될 수 있습니다.

00:07:49.000 --> 00:08:03.000
단일 요청의 결과 유형을 나타내는 단일 유형 매개 변수인 결과를 수락하는 대신, 평가 함수는 이제 각 결과 유형에 대한 별도의 요청을 수락합니다.

00:08:03.000 --> 00:08:13.000
이 함수는 괄호 안의 각 결과 인스턴스를 반환하며, 이는 단일 값 또는 각 값을 포함하는 튜플이 될 것이다.

00:08:13.000 --> 00:08:21.000
평가 함수는 이제 인위적인 제한 없이 모든 인수 길이를 처리합니다.

00:08:21.000 --> 00:08:31.000
유형 추론은 API가 사용하고 있다는 것을 알 필요 없이 매개 변수 팩을 사용하는 API를 자연스럽게 사용할 수 있게 한다.

00:08:31.000 --> 00:08:39.000
이제 많은 인수를 처리할 수 있는 새로운 평가 함수를 호출하는 것은 고정 길이 오버로드를 호출하는 것과 같습니다.

00:08:39.000 --> 00:08:47.000
스위프트는 함수를 호출하는 방법에 따라 총 수와 함께 각 인수의 유형을 추론합니다.

00:08:47.000 --> 00:08:55.000
이와 같은 일반 라이브러리 API를 작성하는 방법에 대해 알아보려면, 매개 변수 팩을 사용하여 API 일반화를 확인하세요.

00:08:55.000 --> 00:09:06.000
자연스러운 방식으로 일반 API를 호출하는 것은 Swift의 기본 설계 목표 중 하나인 간결한 코드를 통한 명확한 표현을 보여줍니다.

00:09:06.000 --> 00:09:14.000
스위프트의 고급 언어 기능은 당신이 의미하는 바를 더 쉽게 말할 수 있는 아름다운 API를 가능하게 합니다.

00:09:14.000 --> 00:09:26.000
배열이나 사전을 통해 제네릭을 사용하거나 SwiftUI에서 UI를 디자인하든, 당신이 작성한 Swift의 첫 번째 줄에서 이러한 고급 언어 기능의 이점을 누릴 수 있습니다.

00:09:26.000 --> 00:09:35.000
스위프트의 점진적 공개 포용은 준비가 되었을 때 고급 기능에 대해 배울 수 있다는 것을 의미합니다.

00:09:35.000 --> 00:09:47.000
스위프트 5.9는 도서관 저자에게 새로운 매크로 시스템을 사용하여 표현 API 디자인을 위한 새로운 도구 상자를 제공함으로써 이 디자인 접근 방식을 한 단계 끌어올립니다.

00:09:47.000 --> 00:09:50.000
여기 더그가 더 말해줄게.

00:09:50.000 --> 00:09:59.000
더그: 매크로를 사용하면 언어 자체의 기능을 확장하여 상용구를 제거하고 스위프트의 표현력을 더 많이 발휘할 수 있습니다.

00:09:59.000 --> 00:10:05.000
조건이 사실인지 확인하는 항상 존재하는 주장 함수를 고려해 봅시다.

00:10:05.000 --> 00:10:14.000
조건이 거짓이면 Assert는 프로그램을 중지할 것이지만, 그런 일이 발생하면 무엇이 잘못되었는지에 대한 정보를 거의 얻지 못하며, 파일과 줄 번호만 얻을 수 있습니다.

00:10:14.000 --> 00:10:18.000
더 자세히 알아보려면 디버거에 로깅을 추가하거나 프로그램을 트랩해야 합니다.

00:10:18.000 --> 00:10:21.000
이것을 개선하려는 시도가 있었다.

00:10:21.000 --> 00:10:29.000
XCTest는 두 값을 별도로 취하는 주장-동등 연산을 제공하므로, 일이 실패할 때, 적어도 동일하지 않은 두 값을 볼 수 있습니다.

00:10:29.000 --> 00:10:32.000
하지만 우리는 여전히 여기서 어떤 가치가 잘못되었는지 모른다.

00:10:32.000 --> 00:10:35.000
A, b, 아니면 맥스의 결과였나요?

00:10:35.000 --> 00:10:40.000
그리고 이 접근 방식은 우리가 주장에서 수행하는 모든 종류의 수표에 대해 실제로 확장되지 않는다.

00:10:40.000 --> 00:10:48.000
원래 주장으로 돌아가면, 소스 코드에는 주장이 실패할 때 로그에서 보고 싶은 정보가 너무 많습니다.

00:10:48.000 --> 00:10:50.000
코드가 뭐였어?

00:10:50.000 --> 00:10:53.000
A, b, c의 값은 무엇인가요?

00:10:53.000 --> 00:10:55.000
맥스는 무엇을 생산했나요?

00:10:55.000 --> 00:11:02.000
우리는 사용자 지정 기능 없이는 스위프트에서 이것을 개선할 수 없었지만, 매크로는 그것을 가능하게 한다.

00:11:02.000 --> 00:11:08.000
이 예에서, "hash-assert" 구문은 "assert"라는 매크로를 확장하고 있다.

00:11:08.000 --> 00:11:17.000
스위프트는 이미 해시 파일, 해시 선택기 및 해시 경고와 같은 동일한 철자를 가진 몇 가지를 가지고 있기 때문에 해시 구문은 친숙해 보일 수 있다.

00:11:17.000 --> 00:11:27.000
주장 매크로는 함수 버전처럼 보이고 느껴지지만, 매크로이기 때문에 주장이 실패할 때 더 풍부한 경험을 제공할 수 있다.

00:11:27.000 --> 00:11:35.000
이제 프로그램은 결과에 기여한 각 값과 함께 실패한 주장에 대한 코드를 보여주고 있다.

00:11:35.000 --> 00:11:44.000
스위프트에서 매크로는 유형이나 함수와 마찬가지로 API이므로, 이를 정의하는 모듈을 가져와서 액세스할 수 있습니다.

00:11:44.000 --> 00:11:49.000
다른 많은 API와 마찬가지로, 매크로는 패키지로 배포됩니다.

00:11:49.000 --> 00:11:58.000
여기 어설션 매크로는 GitHub에서 사용할 수 있는 오픈 소스 스위프트 패키지인 파워 어설션 라이브러리에서 비롯됩니다.

00:11:58.000 --> 00:12:04.000
매크로 패키지를 살펴보면, assert에 대한 매크로 선언을 찾을 수 있습니다.

00:12:04.000 --> 00:12:10.000
그것은 "매크로" 키워드로 도입되었지만, 그렇지 않으면 함수와 매우 비슷해 보인다.

00:12:10.000 --> 00:12:14.000
상태를 확인할 라벨이 지정되지 않은 단일 Bool 매개 변수가 있습니다.

00:12:14.000 --> 00:12:21.000
이 매크로가 값을 생성했다면, 그 결과 유형은 일반적인 화살표 구문으로 작성될 것이다.

00:12:21.000 --> 00:12:25.000
매크로의 사용은 매개 변수에 대해 유형이 확인될 것이다.

00:12:25.000 --> 00:12:39.000
즉, 최대 값을 무언가와 비교하는 것을 잊어버리는 것과 같이 매크로를 사용하는 데 실수를 한다면, 매크로가 확장되기 전에 즉시 유용한 오류 메시지를 받게 될 것입니다.

00:12:39.000 --> 00:12:51.000
이를 통해 매크로는 잘 입력된 입력에서 작동하고 예측 가능한 방식으로 프로그램을 보강하는 코드를 생성하기 때문에 매크로를 사용할 때 스위프트는 훌륭한 개발 경험을 제공할 수 있습니다.

00:12:51.000 --> 00:13:01.000
대부분의 매크로는 문자열을 통해 매크로 구현을 위한 모듈과 유형을 지정하는 "외부 매크로"로 정의됩니다.

00:13:01.000 --> 00:13:08.000
외부 매크로 유형은 컴파일러 플러그인 역할을 하는 별도의 프로그램에 정의됩니다.

00:13:08.000 --> 00:13:13.000
스위프트 컴파일러는 매크로 사용을 위한 소스 코드를 플러그인에 전달한다.

00:13:13.000 --> 00:13:19.000
플러그인은 새로운 소스 코드를 생성한 다음 스위프트 프로그램에 다시 통합됩니다.

00:13:19.000 --> 00:13:27.000
여기서, 매크로는 주장을 개별 값을 캡처하고 소스 코드에 표시되어야 하는 코드로 확장하고 있다.

00:13:27.000 --> 00:13:32.000
당신은 상용구를 직접 쓰고 싶지 않겠지만, 매크로는 당신을 위해 그것을 합니다.

00:13:32.000 --> 00:13:37.000
매크로 선언에는 하나의 추가 정보, 그들의 역할이 있다.

00:13:37.000 --> 00:13:41.000
여기서 주장 매크로는 독립형 표현 매크로이다.

00:13:41.000 --> 00:13:48.000
그것은 "해시" 구문을 사용하고 그 구문에서 직접 작동하여 새로운 코드를 생성하기 때문에 프리스탠딩이라고 불린다.

00:13:48.000 --> 00:13:53.000
그것은 값을 생성할 수 있는 모든 곳에서 사용할 수 있기 때문에 표현 매크로이다.

00:13:53.000 --> 00:13:59.000
새로운 Foundation Predicate API는 표현식 매크로의 좋은 예를 제공한다.

00:13:59.000 --> 00:14:04.000
술어 매크로는 클로저를 사용하여 형식에 안전한 방식으로 술어를 작성할 수 있게 해준다.

00:14:04.000 --> 00:14:14.000
그 결과 술어 값은 Swift 수집 작업 SwiftUI와 SwiftData를 포함한 많은 다른 API와 함께 사용할 수 있습니다.

00:14:14.000 --> 00:14:19.000
매크로 자체는 입력 유형 집합에 대해 일반적이다.

00:14:19.000 --> 00:14:29.000
해당 입력 유형의 값에서 작동하는 함수인 클로저 인수를 받아들이고 부울 결과를 생성합니다. 입력 집합이 일치합니까?

00:14:29.000 --> 00:14:36.000
그리고 매크로는 프로그램의 다른 곳에서 사용할 수 있는 새로운 술어 유형의 인스턴스를 반환합니다.

00:14:36.000 --> 00:14:46.000
하지만 매크로에는 더 많은 것이 있습니다. 왜냐하면 우리가 작성하는 많은 상용구가 우리가 그것에서 파생된 다른 것으로 작성한 코드를 보강해야 하기 때문입니다.

00:14:46.000 --> 00:14:47.000
예를 들어보자.

00:14:47.000 --> 00:14:55.000
나는 상대 경로 또는 절대 경로를 캡처하는 이 경로 열거형과 같이 내 코드에서 열거형을 많이 사용한다는 것을 알게 되었다.

00:14:55.000 --> 00:15:02.000
하지만 나는 종종 컬렉션에서 모든 절대 경로를 필터링하여 특정 사례를 확인해야 한다는 것을 알게 될 것이다.

00:15:02.000 --> 00:15:06.000
물론, 나는 이 isAbsolute check를 계산된 속성으로 쓸 수 있다.

00:15:06.000 --> 00:15:10.000
하지만 조만간, 나는 다른 것을 써야 할 것이다.

00:15:10.000 --> 00:15:14.000
이건 좀 지루해지고 있어.

00:15:14.000 --> 00:15:19.000
매크로는 우리를 위해 상용구를 생성함으로써 여기에 도움이 될 수 있다.

00:15:19.000 --> 00:15:26.000
사례 감지는 속성 래퍼와 동일한 사용자 지정 속성 구문을 사용하여 작성된 첨부된 매크로입니다.

00:15:26.000 --> 00:15:38.000
첨부된 매크로는 그들이 적용하는 선언의 구문을 입력으로 받아들입니다--여기는 열거형 선언 자체입니다-- 그리고 새로운 코드를 생성할 것입니다.

00:15:38.000 --> 00:15:44.000
이 매크로 확장 코드는 컴파일러가 프로그램에 통합하는 일반 스위프트 코드입니다.

00:15:44.000 --> 00:15:53.000
편집기에서 매크로 생성 코드를 검사하고, 디버깅하고, 더 사용자 정의하려면 복사할 수 있습니다.

00:15:53.000 --> 00:16:01.000
첨부된 매크로는 첨부된 선언을 어떻게 보강하는지에 따라 다섯 가지 역할로 분류됩니다.

00:16:01.000 --> 00:16:11.000
우리가 방금 논의한 사례 탐지 매크로는 "멤버" 첨부 매크로로, 유형이나 확장에서 새로운 구성원을 생성한다는 것을 의미합니다.

00:16:11.000 --> 00:16:23.000
피어 매크로는 첨부된 선언과 함께 새로운 선언을 추가하여 비동기 메서드의 완성 핸들러 버전을 만들거나 그 반대의 경우도 마찬가지입니다.

00:16:23.000 --> 00:16:38.000
접근자 매크로는 저장된 속성을 계산된 속성으로 바꿀 수 있으며, 이는 속성 액세스에 대한 특정 작업을 수행하거나 속성 래퍼와 유사하지만 더 유연한 방식으로 실제 저장소를 추상화하는 데 사용할 수 있습니다.

00:16:38.000 --> 00:16:47.000
그리고 첨부된 매크로는 유형의 특정 구성원에 속성을 도입하고 새로운 프로토콜 적합성을 추가할 수 있습니다.

00:16:47.000 --> 00:16:52.000
몇 가지 첨부된 매크로 역할은 유용한 효과를 얻기 위해 함께 구성될 수 있다.

00:16:52.000 --> 00:16:57.000
이것의 한 가지 중요한 예는 관찰이다.

00:16:57.000 --> 00:17:00.000
관찰은 항상 SwiftUI의 일부였다.

00:17:00.000 --> 00:17:16.000
클래스의 속성에 대한 변경 사항을 관찰하려면, 유형을 ObservableObject에 적합하게 하고, 게시된 모든 속성을 표시하고, 보기에서 ObservedObject 속성 래퍼를 사용하기만 하면 됩니다.

00:17:16.000 --> 00:17:22.000
그것은 많은 단계이며, 단계를 놓치는 것은 UI가 예상대로 업데이트되지 않는다는 것을 의미할 수 있다.

00:17:22.000 --> 00:17:27.000
우리는 거시 기반 관찰로 더 잘할 수 있다.

00:17:27.000 --> 00:17:33.000
관찰 가능한 매크로를 클래스에 첨부하면 저장된 모든 속성에 대한 관찰을 제공합니다.

00:17:33.000 --> 00:17:42.000
각 저장된 속성에 주석을 달거나 관찰 가능한 매크로가 모든 것을 처리하기 때문에 그렇지 않으면 어떻게 되는지 걱정할 필요가 없습니다.

00:17:42.000 --> 00:17:48.000
관찰 가능한 매크로는 세 가지 매크로 역할의 구성을 통해 작동한다.

00:17:48.000 --> 00:17:52.000
이 역할들이 어떻게 함께 작동하는지 알아봅시다.

00:17:52.000 --> 00:18:00.000
각 매크로 역할은 사람 클래스가 관찰 가능한 매크로에 의해 증강되는 특정 방식에 해당한다.

00:18:00.000 --> 00:18:05.000
회원 역할은 새로운 속성과 방법을 소개합니다.

00:18:05.000 --> 00:18:18.000
멤버 속성 역할은 관찰된 클래스의 저장된 속성에 @ObservationTracked 매크로를 추가하며, 이는 관찰 이벤트를 트리거하기 위해 getters와 set터로 확장됩니다.

00:18:18.000 --> 00:18:25.000
마지막으로, 적합성 역할은 관찰 가능한 프로토콜에 대한 적합성을 도입한다.

00:18:25.000 --> 00:18:34.000
이것은 많은 코드처럼 보일 수 있지만, 모두 일반적인 스위프트 코드이며, 관찰 가능한 매크로 뒤에 깔끔하게 접혀 있다.

00:18:34.000 --> 00:18:45.000
매크로가 프로그램에 미치는 영향을 더 잘 이해하기 위해 어떻게 확장되는지 봐야 할 때마다, Xcode에서 바로 손끝에 있습니다.

00:18:45.000 --> 00:18:51.000
편집기에서 매크로 확장된 소스 코드를 보려면 "매크로 확장" 작업을 사용하세요.

00:18:51.000 --> 00:19:00.000
매크로 생성 코드 내의 모든 오류 메시지는 자동으로 확장된 코드를 표시하며, 디버거로 들어가고 나갈 수 있습니다.

00:19:00.000 --> 00:19:11.000
스위프트 매크로는 더 표현력 있는 API를 활성화하고 스위프트 코드에서 상용구를 제거하는 새로운 도구를 제공하여 스위프트의 표현력을 잠금 해제하는 데 도움을 줍니다.

00:19:11.000 --> 00:19:20.000
매크로는 입력을 입력하고, 정상적인 스위프트 코드를 생성하고, 프로그램의 정의된 지점에서 통합하므로, 그 효과는 추론하기 쉽습니다.

00:19:20.000 --> 00:19:27.000
그리고 매크로가 무엇을 했는지 이해해야 할 때마다, 확장된 소스 코드는 편집기에 있습니다.

00:19:27.000 --> 00:19:30.000
우리는 방금 매크로의 표면을 긁었다.

00:19:30.000 --> 00:19:37.000
"스위프트 매크로 확장"은 당신이 가져야 할 모든 질문에 답하기 위해 스위프트 매크로의 디자인에 깊이 들어갈 것입니다.

00:19:37.000 --> 00:19:42.000
그리고 "스위프트 매크로 쓰기"로 자신만의 매크로를 직접 구현할 수 있습니다.

00:19:42.000 --> 00:19:46.000
스위프트 커뮤니티가 어떤 새로운 매크로를 만들지 빨리 보고 싶다.

00:19:46.000 --> 00:19:52.000
벤: 처음부터 스위프트는 확장 가능한 언어로 설계되었다.

00:19:52.000 --> 00:20:02.000
스위프트의 디자인은 의식이 낮고 읽고 쓰기 쉬운 명확하고 간결한 코드로 표현력을 강조한다.

00:20:02.000 --> 00:20:17.000
제네릭 및 네이티브 동시성 지원과 같은 Swift의 강력한 기능을 활용하여 SwiftUI 또는 SwiftData와 같은 프레임워크를 사용하면 원하는 결과를 빠르게 얻을 수 있으며, 중요한 것에 집중할 수 있는 더 많은 시간을 할애할 수 있습니다.

00:20:17.000 --> 00:20:23.000
하지만 이러한 높은 수준의 기능에도 불구하고, 스위프트는 또한 효율적이다.

00:20:23.000 --> 00:20:34.000
그것은 기본적으로 컴파일되며, 가비지 수집 대신 값 유형과 참조 계산을 사용하면 낮은 메모리 풋프린트를 달성할 수 있다는 것을 의미합니다.

00:20:34.000 --> 00:20:49.000
이 확장성은 이전에 Objective-C로 가능했던 것보다 더 많은 곳으로 Swift를 C 또는 C++를 사용해야 할 것으로 예상했던 저수준 시스템으로 푸시할 수 있다는 것을 의미합니다.

00:20:49.000 --> 00:20:56.000
이것은 스위프트의 더 명확한 코드와 중요한 안전 보장을 더 많은 장소에 가져오는 것을 의미합니다.

00:20:56.000 --> 00:21:02.000
우리는 최근에 스위프트에서 재단 프레임워크의 재작성 시작을 오픈 소스화했다.

00:21:02.000 --> 00:21:10.000
이 이니셔티브는 Apple과 비Apple 플랫폼 모두에서 재단의 단일 공유 구현으로 이어질 것이다.

00:21:10.000 --> 00:21:16.000
하지만 그것은 또한 스위프트에서 많은 양의 Objective-C와 C 코드를 다시 쓰는 것을 의미했다.

00:21:16.000 --> 00:21:35.000
MacOS 소노마와 iOS 17부터 날짜 및 캘린더와 같은 필수 유형의 새로운 Swift 기반 구현, Locale 및 AttributedString과 같은 서식 및 국제화 필수 요소, JSON 인코딩 및 디코딩의 새로운 Swift 구현이 있습니다.

00:21:35.000 --> 00:21:39.000
그리고 성과의 승리는 중요했다.

00:21:39.000 --> 00:21:53.000
중요한 날짜를 계산하는 달력의 능력은 중간 할당을 피하기 위해 스위프트의 가치 의미를 더 잘 활용할 수 있으며, 그 결과 일부 벤치마크에서 20% 이상 개선될 수 있다.

00:21:53.000 --> 00:22:05.000
FormatStyle을 사용한 날짜 포맷은 또한 몇 가지 주요 성능 업그레이드를 얻었으며, 표준 날짜 및 시간 템플릿을 사용한 포맷 벤치마크에서 150%의 엄청난 개선을 보여주었다.

00:22:05.000 --> 00:22:11.000
더욱 흥미로운 것은 새로운 패키지의 JSON 디코딩 개선이다.

00:22:11.000 --> 00:22:21.000
재단은 JSONDecoder와 JSONEncoder를 위한 새로운 Swift 구현을 가지고 있으며, Objective-C 컬렉션 유형으로의 비용이 많이 드는 왕복을 제거합니다.

00:22:21.000 --> 00:22:29.000
코딩 가능한 유형을 초기화하기 위해 Swift에서 JSON을 구문 분석하는 긴밀한 통합은 성능도 향상시킨다.

00:22:29.000 --> 00:22:36.000
테스트 데이터를 구문 분석하는 벤치마크에서, 새로운 구현은 2~5배 더 빠르다.

00:22:36.000 --> 00:22:48.000
이러한 개선은 이전 Objective-C 구현에서 Swift로의 브리징 비용을 줄이는 것뿐만 아니라 새로운 Swift 기반 구현이 더 빨라지는 데서 비롯되었다.

00:22:48.000 --> 00:22:51.000
한 가지 벤치마크를 예로 들어 봅시다.

00:22:51.000 --> 00:22:59.000
벤투라에서, Objective-C에서 enumerateDates를 호출하는 것은 브리징 비용 때문에 Swift에서 호출하는 것보다 약간 빨랐다.

00:22:59.000 --> 00:23:05.000
MacOS Sonoma에서 Swift에서 동일한 기능을 호출하는 것은 20% 더 빠릅니다.

00:23:05.000 --> 00:23:16.000
그 속도 중 일부는 브리징 비용을 제거하는 데서 비롯되지만, Objective-C에서 호출할 때 볼 수 있듯이 새로운 기능 구현 자체도 더 빠릅니다.

00:23:16.000 --> 00:23:25.000
이 특정 날짜 계산은 지나치게 복잡하지 않기 때문에, 이것은 두 언어 사이의 오버헤드 감소를 볼 수 있는 좋은 방법이다.

00:23:25.000 --> 00:23:35.000
이제, 때때로, 시스템의 낮은 수준에서 작동할 때, 필요한 수준의 성능을 달성하기 위해 더 세밀한 제어가 필요합니다.

00:23:35.000 --> 00:23:43.000
스위프트 5.9는 이러한 수준의 제어를 달성하는 데 도움이 되는 몇 가지 새로운 옵트인 기능을 소개합니다.

00:23:43.000 --> 00:23:53.000
이러한 기능은 소유권의 개념, 즉 코드의 어떤 부분이 애플리케이션을 통과할 때 가치를 "소유"하는지에 초점을 맞추고 있습니다.

00:23:53.000 --> 00:23:59.000
이러한 기능을 언제 사용하고 싶은지 보려면, 먼저 몇 가지 예제 코드를 살펴봅시다.

00:23:59.000 --> 00:24:08.000
여기에는 낮은 수준의 시스템 호출에 더 좋은 스위프트 인터페이스를 제공할 수 있는 파일 설명자를 위한 매우 간단한 래퍼가 있습니다.

00:24:08.000 --> 00:24:12.000
하지만 이 API로 실수를 할 수 있는 몇 가지 쉬운 방법이 여전히 있다.

00:24:12.000 --> 00:24:17.000
예를 들어, 닫기를 호출한 후 파일에 쓰기를 시도할 수 있습니다.

00:24:17.000 --> 00:24:24.000
그리고 유형이 범위를 벗어나기 전에 닫기 메서드를 호출하여 항상 수동으로 닫도록 주의해야 합니다.

00:24:24.000 --> 00:24:27.000
그렇지 않으면, 당신은 자원 유출을 받게 될 것입니다.

00:24:27.000 --> 00:24:35.000
한 가지 해결책은 유형이 범위를 벗어날 때 자동으로 닫는 deinit가 있는 클래스를 만드는 것이다.

00:24:35.000 --> 00:24:48.000
하지만 그것은 추가 메모리 할당을 만드는 것과 같은 다른 단점을 가지고 있는데, 이는 매우 제한된 시스템 컨텍스트를 제외하고는 일반적으로 큰 문제가 아니다.

00:24:48.000 --> 00:24:51.000
수업은 또한 참조 의미론을 가지고 있다.

00:24:51.000 --> 00:25:00.000
의도치 않게 스레드 간에 파일 설명자 유형을 공유하여 경쟁 조건으로 이어지거나 의도치 않게 저장할 수 있습니다.

00:25:00.000 --> 00:25:04.000
하지만 돌아가서 구조체 버전을 살펴봅시다.

00:25:04.000 --> 00:25:09.000
정말로, 이 구조체는 또한 참조 유형처럼 작동한다.

00:25:09.000 --> 00:25:15.000
그것은 열린 파일인 실제 값을 참조하는 정수를 보유하고 있다.

00:25:15.000 --> 00:25:22.000
이 유형의 복사본을 만드는 것은 또한 버그로 이어질 수 있는 방식으로 앱 전체에서 변경 가능한 상태를 의도하지 않게 공유할 수 있습니다.

00:25:22.000 --> 00:25:29.000
당신이 원하는 것은 이 구조체의 복사본을 만들 수 있는 능력을 억제하는 것입니다.

00:25:29.000 --> 00:25:34.000
구조체든 클래스든 스위프트 유형은 기본적으로 복사할 수 있다.

00:25:34.000 --> 00:25:37.000
이것은 대부분의 경우 올바른 선택이다.

00:25:37.000 --> 00:25:51.000
과도한 불필요한 복사본은 때때로 코드의 병목 현상이 될 수 있지만, 그 복사본에 대해 명시해야 하는 컴파일러에 의해 끊임없이 방해받는 것보다 가끔 도구에서 이러한 병목 현상을 찾는 데 시간을 할애하는 것이 좋습니다.

00:25:51.000 --> 00:26:03.000
하지만 때때로 그 암시적 사본은 당신이 원하는 것이 아닙니다. 특히, 값의 복사본을 만들 때 파일 설명자 래퍼와 같은 정확성 문제로 이어질 수 있습니다.

00:26:03.000 --> 00:26:15.000
스위프트 5.9에서는 구조체 및 열거형 선언에 적용할 수 있고 유형을 복사하는 암시적 기능을 억제하는 이 새로운 구문으로 그렇게 할 수 있습니다.

00:26:15.000 --> 00:26:26.000
일단 유형을 복사할 수 없는 경우, 클래스처럼 deinit를 제공할 수 있으며, 이는 유형의 값이 범위를 벗어날 때 실행됩니다.

00:26:26.000 --> 00:26:35.000
복사할 수 없는 유형은 또한 닫기를 호출하고 다른 방법을 사용하는 문제를 해결하는 데 사용될 수 있다.

00:26:35.000 --> 00:26:39.000
가까운 작업은 소비로 표시될 수 있다.

00:26:39.000 --> 00:26:46.000
소비 메소드나 인수를 호출하면 호출한 메소드에 대한 값의 소유권을 포기합니다.

00:26:46.000 --> 00:26:53.000
우리의 유형은 복사할 수 없기 때문에, 소유권을 포기한다는 것은 당신이 더 이상 그 가치를 사용할 수 없다는 것을 의미합니다.

00:26:53.000 --> 00:26:59.000
기본적으로, 스위프트의 메소드는 자아를 포함한 그들의 주장을 차용한다.

00:26:59.000 --> 00:27:12.000
따라서 파일 설명자를 빌려서 버퍼에 쓰는 write 메서드를 호출할 수 있으며, 그 후 값의 소유권이 호출자에게 반환되며, close와 같은 다른 메서드를 호출할 수 있습니다.

00:27:12.000 --> 00:27:21.000
하지만 마감이 차입의 채무 불이행이 아니라 소비로 표시되었기 때문에, 그것은 최종 사용이어야 한다.

00:27:21.000 --> 00:27:32.000
즉, 파일을 먼저 닫은 다음 쓰기와 같은 다른 메서드를 호출하려고 하면 런타임 실패가 아닌 컴파일 시간에 오류 메시지가 표시됩니다.

00:27:32.000 --> 00:27:37.000
컴파일러는 또한 소비 사용이 발생한 곳을 나타낼 것이다.

00:27:37.000 --> 00:27:43.000
복사할 수 없는 유형은 스위프트의 시스템 레벨 프로그래밍을 위한 강력한 새로운 기능이다.

00:27:43.000 --> 00:27:46.000
그들은 여전히 진화의 초기 단계에 있다.

00:27:46.000 --> 00:27:52.000
이후 버전의 스위프트는 일반 코드에서 복사할 수 없는 유형을 확장할 것이다.

00:27:52.000 --> 00:27:58.000
이 작업과 함께 따르는 데 관심이 있다면, 스위프트 포럼에서 적극적으로 논의되고 있습니다.

00:27:58.000 --> 00:28:03.000
더그: 스위프트의 성공의 열쇠는 오브젝티브-C와의 상호 운용성이었다.

00:28:03.000 --> 00:28:14.000
처음부터 개발자들은 기존 코드 베이스에서 Swift 채택을 향한 점진적인 조치를 취할 수 있었고, Swift에서 한 번에 단일 파일이나 모듈을 혼합할 수 있었다.

00:28:14.000 --> 00:28:18.000
하지만 우리는 여러분 중 많은 사람들이 Objective-C로 작성된 코드를 가지고 있지 않다는 것을 알고 있습니다.

00:28:18.000 --> 00:28:25.000
많은 앱은 또한 C++로 구현된 핵심 비즈니스 로직을 가지고 있으며, 인터페이스는 그렇게 쉽지 않았다.

00:28:25.000 --> 00:28:34.000
종종 그것은 Swift에서 Objective-C를 거쳐 C++로, 그리고 다시 돌아가는 추가 수동 브리징 레이어를 추가하는 것을 의미했다.

00:28:34.000 --> 00:28:40.000
스위프트 5.9는 스위프트에서 직접 C++ 유형 및 기능과 상호 작용할 수 있는 기능을 소개합니다.

00:28:40.000 --> 00:28:53.000
C++ 상호 운용성은 Objective-C 상호 운용성이 항상 그랬던 것처럼 작동하며, C++ API를 Swift 코드에서 직접 사용할 수 있는 Swift 등가물에 매핑합니다.

00:28:53.000 --> 00:29:01.000
C++는 클래스, 메소드, 컨테이너와 같은 아이디어에 대한 자체 개념을 가진 큰 언어이다.

00:29:01.000 --> 00:29:07.000
스위프트 컴파일러는 일반적인 C++ 관용구를 이해하므로 많은 유형을 직접 사용할 수 있습니다.

00:29:07.000 --> 00:29:19.000
예를 들어, 이 Person 유형은 C++ 값 유형에서 예상되는 다섯 가지 특수 멤버 함수를 정의합니다: 복사 및 이동 생성자, 할당 연산자 및 소멸자.

00:29:19.000 --> 00:29:26.000
스위프트 컴파일러는 이것을 값 유형으로 취급하고 적시에 올바른 특수 멤버 함수를 자동으로 호출합니다.

00:29:26.000 --> 00:29:34.000
또한, 벡터와 지도와 같은 C++ 컨테이너는 스위프트 컬렉션으로 접근할 수 있다.

00:29:34.000 --> 00:29:42.000
이 모든 것의 결과는 우리가 C++ 함수와 유형을 직접 사용하는 간단한 스위프트 코드를 작성할 수 있다는 것이다.

00:29:42.000 --> 00:29:51.000
우리는 Person 인스턴스의 벡터를 필터링하여 C++ 멤버 함수를 호출하고 데이터 멤버에 직접 액세스할 수 있습니다.

00:29:51.000 --> 00:29:59.000
다른 방향으로, C++의 Swift 코드를 사용하는 것은 Objective-C와 동일한 메커니즘을 기반으로 한다.

00:29:59.000 --> 00:30:06.000
스위프트 컴파일러는 스위프트 API에 대한 C++ 뷰를 포함하는 "생성된 헤더"를 생성할 것이다.

00:30:06.000 --> 00:30:15.000
그러나, Objective-C와 달리, objc 속성으로 주석이 달린 Swift 클래스만 사용하도록 제한할 필요가 없습니다.

00:30:15.000 --> 00:30:26.000
C++는 브리징 오버헤드 없이 대부분의 Swift 유형과 속성, 메서드 및 이니셜라이저를 포함한 전체 API를 직접 사용할 수 있습니다.

00:30:26.000 --> 00:30:30.000
여기서 우리는 C++가 포인트 구조체들을 어떻게 사용할 수 있는지 볼 수 있다.

00:30:30.000 --> 00:30:45.000
생성된 헤더를 포함한 후, C++는 스위프트 이니셜라이저를 호출하여 스위프트 코드 자체를 변경하지 않고 포인트 인스턴스를 만들고, 돌연변이 메서드를 호출하고, 저장된 속성과 계산된 속성 모두에 액세스할 수 있습니다.

00:30:45.000 --> 00:30:53.000
스위프트의 C++ 상호 운용성은 스위프트를 기존 C++ 코드 베이스와 그 어느 때보다 쉽게 통합할 수 있게 해준다.

00:30:53.000 --> 00:31:03.000
많은 C++ 관용구는 종종 자동으로 스위프트로 직접 표현될 수 있지만, 때때로 원하는 의미를 나타내기 위해 몇 가지 주석이 필요하다.

00:31:03.000 --> 00:31:19.000
그리고 Swift API는 C++에서 직접 액세스할 수 있으며 주석이나 코드 변경이 필요하지 않아 C, C++ 및 Objective-C의 혼합을 사용하여 코드 베이스 전반에 걸쳐 Swift를 점진적으로 채택할 수 있습니다.

00:31:19.000 --> 00:31:26.000
C++ 상호 운용성은 C++ 상호 운용성 작업 그룹에 의해 안내되는 진화하는 이야기이다.

00:31:26.000 --> 00:31:34.000
자세한 내용은 "Mix Swift and C++" 토크를 참조하거나 Swift 포럼의 토론에 참여하십시오.

00:31:34.000 --> 00:31:41.000
언어 수준에서의 상호 운용성은 정말 중요하지만, 코드를 작성할 수도 있어야 합니다.

00:31:41.000 --> 00:31:53.000
그리고 Swift를 시작하기 위해 기존 빌드 시스템을 Xcode 또는 Swift Package Manager로 교체해야 하는 것은 많은 양의 코드를 다시 작성하는 것만큼 큰 장벽이 될 수 있습니다.

00:31:53.000 --> 00:31:57.000
그것이 우리가 CMake에서 Swift 지원을 개선하기 위해 CMake 커뮤니티와 협력한 이유입니다.

00:31:57.000 --> 00:32:06.000
Swift를 프로젝트의 언어 중 하나로 선언하고 Swift 파일을 대상에 넣어 Swift 코드를 CMake 빌드에 통합할 수 있습니다.

00:32:06.000 --> 00:32:19.000
더 중요한 것은, 단일 대상 내에서 C++와 Swift를 혼합할 수 있으며, CMake는 각각을 별도로 컴파일하고 두 언어에 대한 모든 적절한 지원 라이브러리와 런타임을 연결할 것입니다.

00:32:19.000 --> 00:32:27.000
즉, 오늘 크로스 플랫폼 C++ 프로젝트에서 스위프트를 채택할 수 있습니다.

00:32:27.000 --> 00:32:40.000
우리는 또한 브리징 및 생성된 헤더 사용을 포함하여 Swift 및 혼합 C++/Swift 대상을 포함하는 CMake 프로젝트가 포함된 샘플 저장소를 제공하여 시작할 수 있도록 돕고 있습니다.

00:32:40.000 --> 00:32:50.000
몇 년 전, 우리는 비동기/대기, 구조화된 동시성 및 배우의 빌딩 블록을 기반으로 새로운 동시성 모델을 Swift에 도입했습니다.

00:32:50.000 --> 00:32:57.000
스위프트의 동시성 모델은 다양한 환경과 라이브러리에 적용할 수 있는 추상적인 모델이다.

00:32:57.000 --> 00:33:03.000
추상적인 모델에는 두 가지 주요 부분이 있다: 과제와 배우.

00:33:03.000 --> 00:33:09.000
작업은 개념적으로 어디에서나 실행할 수 있는 순차적인 작업 단위를 나타낸다.

00:33:09.000 --> 00:33:16.000
프로그램에 "대기"가 있을 때마다 작업을 중단할 수 있으며, 작업이 계속되면 재개할 수 있습니다.

00:33:16.000 --> 00:33:23.000
배우들은 고립된 상태에 대한 상호 배타적인 접근을 제공하는 동기화 메커니즘이다.

00:33:23.000 --> 00:33:29.000
외부에서 배우를 입력하려면 작업을 중단할 수 있기 때문에 "기다림"이 필요합니다.

00:33:29.000 --> 00:33:39.000
작업과 행위자는 추상적인 언어 모델에 통합되지만, 그 모델 내에서는 다른 환경에 맞게 다양한 방식으로 구현될 수 있다.

00:33:39.000 --> 00:33:43.000
작업은 글로벌 동시 풀에서 실행된다.

00:33:43.000 --> 00:33:48.000
글로벌 동시 풀이 어떻게 작업 일정을 잡기로 결정하는지는 환경에 달려 있다.

00:33:48.000 --> 00:33:58.000
애플 플랫폼의 경우, 디스패치 라이브러리는 전체 운영 체제에 최적화된 스케줄링을 제공하며, 각 플랫폼에 대해 광범위하게 조정되었습니다.

00:33:58.000 --> 00:34:04.000
더 제한적인 환경에서, 멀티스레드 스케줄러의 오버헤드는 허용되지 않을 수 있다.

00:34:04.000 --> 00:34:10.000
스위프트의 동시성 모델은 단일 스레드 협력 대기열로 구현된다.

00:34:10.000 --> 00:34:19.000
추상적인 모델이 다양한 런타임 환경에 매핑할 수 있을 만큼 유연하기 때문에 동일한 스위프트 코드는 두 환경 모두에서 작동합니다.

00:34:19.000 --> 00:34:28.000
또한, 콜백 기반 라이브러리와의 상호 운용성은 처음부터 Swift의 비동기/대기 지원에 내장되어 있다.

00:34:28.000 --> 00:34:35.000
withCheckedContinuation 작업을 사용하면 작업을 일시 중지한 다음 나중에 콜백에 대한 응답으로 재개할 수 있습니다.

00:34:35.000 --> 00:34:41.000
이것은 작업을 스스로 관리하는 기존 라이브러리와의 통합을 가능하게 한다.

00:34:41.000 --> 00:34:51.000
스위프트 동시성 런타임에서 액터의 표준 구현은 액터에서 실행할 작업의 잠금이 없는 대기열이지만, 가능한 유일한 구현은 아니다.

00:34:51.000 --> 00:35:00.000
더 제한된 환경에서는 원자가 없을 수도 있고, 대신 스핀록과 같은 다른 동시성 프리미티브를 사용할 수 있다.

00:35:00.000 --> 00:35:09.000
그 환경이 단일 스레드라면, 동기화가 필요하지 않지만, 액터 모델은 상관없이 프로그램에 대한 추상적인 동시성 모델을 유지합니다.

00:35:09.000 --> 00:35:15.000
당신은 여전히 같은 코드를 다중 스레드인 다른 환경으로 가져갈 수 있습니다.

00:35:15.000 --> 00:35:22.000
스위프트 5.9를 사용하면 사용자 지정 액터 실행자는 특정 액터가 자체 동기화 메커니즘을 구현할 수 있습니다.

00:35:22.000 --> 00:35:27.000
이것은 배우들을 더 유연하고 기존 환경에 적응할 수 있게 만든다.

00:35:27.000 --> 00:35:30.000
예를 들어보자.

00:35:30.000 --> 00:35:34.000
여기서 우리는 데이터베이스 연결을 관리하는 배우를 고려합니다.

00:35:34.000 --> 00:35:42.000
스위프트는 이 액터의 저장소에 대한 상호 배타적인 액세스를 보장하므로 데이터베이스에 대한 동시 액세스가 없습니다.

00:35:42.000 --> 00:35:48.000
하지만, 동기화가 이루어지는 특정 방법에 대한 더 많은 통제가 필요하다면 어떨까요?

00:35:48.000 --> 00:35:57.000
예를 들어, 그 대기열이 배우를 채택하지 않은 다른 코드와 공유되기 때문에 데이터베이스 연결에 특정 디스패치 대기열을 사용하고 싶다면 어떨까요?

00:35:57.000 --> 00:36:01.000
맞춤형 배우 집행자와 함께라면, 당신은 할 수 있습니다.

00:36:01.000 --> 00:36:13.000
여기서 우리는 액터에 직렬 디스패치 대기열과 해당 디스패치 대기열에 해당하는 집행자를 생성하는 소유되지 않은 집행자 속성을 구현했습니다.

00:36:13.000 --> 00:36:20.000
이 변경으로, 우리의 액터 인스턴스에 대한 모든 동기화는 그 대기열을 통해 이루어질 것이다.

00:36:20.000 --> 00:36:29.000
배우 외부에서 pruneOldEntries에 대한 호출을 "대기"할 때, 이것은 이제 해당 대기열에서 디스패치 비동기를 수행할 것입니다.

00:36:29.000 --> 00:36:43.000
이를 통해 개별 배우가 동기화를 제공하는 방법을 더 잘 제어할 수 있으며, Objective-C 또는 C++로 작성되었기 때문에 아직 배우를 사용하지 않는 다른 코드와 배우를 동기화할 수 있습니다.

00:36:43.000 --> 00:36:51.000
디스패치 대기열이 새로운 SerialExecutor 프로토콜을 준수하기 때문에 디스패치 대기열을 통한 행위자의 동기화가 가능합니다.

00:36:51.000 --> 00:37:07.000
핵심 작업이 거의 없는 이 프로토콜을 준수하는 새로운 유형을 정의하여 배우와 함께 사용할 수 있는 자체 동기화 메커니즘을 제공할 수 있습니다: 코드가 이미 실행자의 맥락에서 실행되고 있는지 확인합니다.

00:37:07.000 --> 00:37:11.000
예를 들어, 우리는 메인 스레드에서 실행되고 있나요?

00:37:11.000 --> 00:37:18.000
초과 참조 계산 트래픽 없이 접근할 수 있도록 집행자에 대한 소유되지 않은 참조를 추출합니다.

00:37:18.000 --> 00:37:24.000
그리고 집행자 "직업"의 소유권을 갖는 가장 핵심적인 작업인 enqueue.

00:37:24.000 --> 00:37:29.000
작업은 실행자에서 동기적으로 실행되어야 하는 비동기 작업의 일부입니다.

00:37:29.000 --> 00:37:38.000
Enqueue가 호출되는 시점에서, 직렬 실행자에서 실행되는 다른 코드가 없는 시점에서 그 작업을 실행하는 것은 실행자의 책임이다.

00:37:38.000 --> 00:37:45.000
예를 들어, 디스패치 대기열의 대기열은 그 대기열에서 디스패치를 비동기 호출할 것이다.

00:37:45.000 --> 00:37:55.000
Swift Concurrency는 몇 년 동안 사용되어 왔으며, 작업과 배우로 구성된 추상적인 모델은 광범위한 동시 프로그래밍 작업을 다룹니다.

00:37:55.000 --> 00:38:05.000
추상적인 모델 자체는 매우 유연하며, iPhone에서 Apple Watch, 서버 및 그 이상에 이르기까지 다양한 실행 환경에 적응할 수 있습니다.

00:38:05.000 --> 00:38:13.000
또한 아직 Swift Concurrency를 완전히 채택하지 않은 코드와 상호 운용할 수 있도록 핵심 지점에서 사용자 지정을 허용했습니다.

00:38:13.000 --> 00:38:20.000
자세한 내용은 "Behind the Scenes" 강연과 "Beyond the Basics of Structured Concurrency"를 참조하십시오.

00:38:20.000 --> 00:38:29.000
저는 우리가 그것을 보는 데 익숙한 iOS 또는 MacOS 앱과 매우 다른 환경에서 작동하는 Swift에 대한 약간의 사례 연구로 마무리하고 싶습니다.

00:38:29.000 --> 00:38:44.000
FoundationDB는 분산 데이터베이스로, 상품 하드웨어에서 실행되고 MacOS, Linux 및 Windows를 포함한 다양한 플랫폼을 지원하는 매우 큰 키 가치 상점을 위한 확장 가능한 솔루션을 제공합니다.

00:38:44.000 --> 00:38:50.000
FoundationDB는 C++로 작성된 대규모 코드 베이스를 가진 오픈 소스 프로젝트이다.

00:38:50.000 --> 00:39:01.000
이 코드는 매우 비동기적이며, 자체 형태의 분산 액터와 런타임으로 테스트 목적으로 매우 중요한 결정적 시뮬레이션 환경을 제공합니다.

00:39:01.000 --> 00:39:11.000
FoundationDB는 코드 기반을 현대화하려고 했고 Swift가 성능, 안전 및 코드 명확성에 잘 어울린다는 것을 발견했다.

00:39:11.000 --> 00:39:14.000
완전한 재작성은 크고 위험한 노력이 될 것이다.

00:39:14.000 --> 00:39:21.000
대신, 우리는 스위프트의 상호 운용성을 활용하여 기존 코드 베이스에 통합했습니다.

00:39:21.000 --> 00:39:29.000
예를 들어, 여기 FoundationDB의 "마스터 데이터" 액터의 C++ 구현의 일부가 있습니다.

00:39:29.000 --> 00:39:33.000
여기서 많은 일이 일어나고 있으며, 이 모든 C++를 이해할 필요는 없습니다.

00:39:33.000 --> 00:39:38.000
하지만, 저는 코드의 몇 가지 주요 측면을 지적하고 싶습니다.

00:39:38.000 --> 00:39:48.000
첫째, C++에는 비동기/대기가 없기 때문에, FoundationDB는 그것을 에뮬레이트하기 위한 자체 전처리기 같은 접근 방식을 가지고 있다.

00:39:48.000 --> 00:39:56.000
많은 C++ 코드 베이스와 마찬가지로, 그들은 비동기 작업을 관리하기 위해 자체 C++ Future 유형을 구현했다.

00:39:56.000 --> 00:40:01.000
이것들은 요청에 대한 응답을 보내기 위해 명시적인 메시지와 짝을 이룬다.

00:40:01.000 --> 00:40:07.000
기능에서 돌아오는 것과 답장을 보내는 신중한 페어링에 유의하세요.

00:40:07.000 --> 00:40:13.000
마지막으로, FoundationDB에는 메모리를 자동으로 관리하는 데 도움이 되는 자체 참조 계산 스마트 포인터가 있습니다.

00:40:13.000 --> 00:40:20.000
우리는 이 모든 것을 스위프트에서 훨씬 더 깔끔하게 구현할 수 있다.

00:40:20.000 --> 00:40:24.000
그게 더 나아.

00:40:24.000 --> 00:40:28.000
이 함수는 스위프트에서 비동기 함수로 직접 구현될 수 있다.

00:40:28.000 --> 00:40:36.000
우리는 이 요청에 대한 응답을 제공하기 위해 일반 반환 유형과 일반 반환 명세서를 가지고 있으므로, 당신은 절대 동기화되지 않을 수 없습니다.

00:40:36.000 --> 00:40:43.000
우리는 다른 모든 스위프트 비동기 코드와 같은 방식으로 정지 지점을 나타내는 "대기"가 있습니다.

00:40:43.000 --> 00:40:51.000
그리고 이 스위프트 코드는 연속을 사용하여 적응된 C++ 미래 유형과 관련이 있다.

00:40:51.000 --> 00:40:54.000
우리는 여기서 많은 C++ 유형을 사용하고 있다.

00:40:54.000 --> 00:40:59.000
C++의 MasterData 유형은 참조 카운트 스마트 포인터를 사용하고 있었다.

00:40:59.000 --> 00:41:09.000
C++에서 유형에 주석을 달면, 스위프트 컴파일러는 다른 클래스와 마찬가지로 이 유형을 사용할 수 있으며, 참조 수를 자동으로 관리할 수 있습니다.

00:41:09.000 --> 00:41:16.000
요청 및 응답 유형과 같은 다른 유형은 스위프트에서 직접 사용되는 C++ 값 유형입니다.

00:41:16.000 --> 00:41:19.000
그리고 상호 운용성은 양방향으로 간다.

00:41:19.000 --> 00:41:28.000
이 비동기 함수와 실제로 Swift 동시성 모델에 의해 도입된 모든 작업은 FoundationDB의 기존 결정적 런타임에서 실행됩니다.

00:41:28.000 --> 00:41:38.000
그래서 우리는 우리가 원하는 곳에서 스위프트의 이점을 얻을 수 있으며, 기존 C++와 인터페이스하여 점진적으로 채택할 수 있습니다.

00:41:38.000 --> 00:41:41.000
이 세션에서, 우리는 많은 것을 다루었다.

00:41:41.000 --> 00:41:51.000
우리는 더 표현력이 뛰어난 API를 가능하게 하고 더 나은 코드를 더 빨리 작성하는 데 도움이 될 수 있는 매개 변수 팩과 매크로와 같은 기능을 설명했습니다.

00:41:51.000 --> 00:42:01.000
우리는 성능에 민감한 코드에서 Swift를 사용하고 참조 계산 오버헤드 없이 리소스 관리를 제공하기 위해 복사할 수 없는 유형의 도입에 대해 이야기했습니다.

00:42:01.000 --> 00:42:15.000
그런 다음 우리는 Swift에서 C++ API 사용을 지원하고 그 반대의 경우를 지원하는 C++ 상호 운용성에 뛰어들어 Swift의 이점을 더 많은 코드에 더 쉽게 가져올 수 있습니다.

00:42:15.000 --> 00:42:26.000
마지막으로, 우리는 스위프트의 유연한 동시성 모델이 어떻게 장치와 언어의 무수한 환경에 적응하여 동시성을 더 쉽고 안전하게 만들 수 있는지에 대해 이야기했습니다.

00:42:26.000 --> 00:42:41.000
스위프트 5.9의 매개 변수 팩, 매크로, 복사 불가능한 유형 및 기타 모든 언어 향상은 스위프트 에볼루션 프로세스를 통해 공개적으로 설계되고 개발되었으며, 커뮤니티 피드백은 이러한 기능을 형성하는 데 매우 중요했습니다.

00:42:41.000 --> 00:42:54.000
스위프트 5.9는 활발한 디자인 토론, 버그 보고서, 풀 리퀘스트, 교육 콘텐츠 등을 포함하여 스위프트 커뮤니티 전역의 회원들의 수많은 기여의 절정이다.

00:42:54.000 --> 00:42:59.000
스위프트 5.9를 훌륭한 릴리스로 만들어 주셔서 감사합니다.

00:42:59.000 --> 23:59:59.000
♪ ♪

