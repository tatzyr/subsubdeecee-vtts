WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:12.000
마리나: 안녕하세요, WWDC에 오신 것을 환영합니다.

00:00:12.000 --> 00:00:16.000
제 이름은 마리나이고, 나중에 제 동료 매트와 합류할 것입니다.

00:00:16.000 --> 00:00:22.000
우리는 Apple의 현지화 팀 출신이며, 오늘 String Catalogs를 보여드리게 되어 기쁩니다.

00:00:22.000 --> 00:00:26.000
여기 애플에서, 우리는 접근성과 포용성을 굳게 믿습니다.

00:00:26.000 --> 00:00:32.000
앱을 현지화하는 것은 콘텐츠가 전 세계의 더 많은 사람들에게 도달할 수 있도록 하는 한 가지 방법입니다.

00:00:32.000 --> 00:00:43.000
사실, 오늘날 우리는 40개 이상의 언어로 운영 체제를 배송하며 모든 사람이 모국어로 제품을 사용할 수 있도록 이 번호를 지속적으로 확장하고 있습니다.

00:00:43.000 --> 00:00:57.000
우리 팀은 가능한 한 쉽게 현지화할 수 있도록 Xcode의 도구를 제공하기 위해 최선을 다하고 있으며, 오늘 우리는 프로젝트에서 현지화된 콘텐츠를 관리하기 위한 새로운 개선 사항과 워크플로우를 발표하게 되어 기쁩니다.

00:00:57.000 --> 00:01:04.000
이전에는 앱을 현지화하고 싶다면, 문자열과 stringsdict 파일을 유지해야 했습니다.

00:01:04.000 --> 00:01:11.000
이를 위해서는 모든 문자열을 코드와 수동으로 동기화해야 하며, 종종 콘텐츠 현지화를 놓칠 수 있습니다.

00:01:11.000 --> 00:01:15.000
이로 인해 사용자에게 현지화되지 않은 문자열이 발생할 수 있습니다.

00:01:15.000 --> 00:01:23.000
우리의 프로젝트는 수년 동안 이 과정에 의존해 왔지만, Xcode 15에서는 문자열 카탈로그를 도입하고 있습니다.

00:01:23.000 --> 00:01:29.000
시간이 지남에 따라, 이 새로운 형식은 Xcode의 문자열과 stringsdict 파일을 모두 대체할 것이다.

00:01:29.000 --> 00:01:38.000
문자열 카탈로그를 사용하면 모든 문자열을 한 곳에서 쉽게 관리하고 배송 전에 콘텐츠가 완전히 현지화되었다고 확신할 수 있습니다.

00:01:38.000 --> 00:01:41.000
그게 어떻게 작동하는지 보자.

00:01:41.000 --> 00:01:46.000
여기 코드에서, 저는 SwiftUI 컨트롤을 사용하여 뷰를 만들고 콘텐츠를 채우고 있습니다.

00:01:46.000 --> 00:01:50.000
그리고 이것은 문자열 카탈로그입니다.

00:01:50.000 --> 00:01:55.000
방금 내 스위프트 코드에서 본 모든 문자열은 Xcode에 의해 자동으로 추출되었다.

00:01:55.000 --> 00:01:58.000
나는 그것들을 직접 추가할 필요가 없었다.

00:01:58.000 --> 00:02:05.000
나는 브라질에 있는 내 친구들이 이 앱을 사용할 수 있도록 하고 싶어서, 포르투갈어로 번역했다.

00:02:05.000 --> 00:02:10.000
나는 이 뒷마당을 방문한 최근 새들을 보여주는 이 견해를 가지고 있다.

00:02:10.000 --> 00:02:20.000
여기, 뒷마당을 방문한 새들의 실제 수를 보여주고 싶으니, 이 숫자를 나타내는 변수를 추가하겠습니다.

00:02:20.000 --> 00:02:23.000
그리고 여기 미리보기에 있습니다.

00:02:23.000 --> 00:02:25.000
이제 우리는 새들의 수를 볼 수 있다.

00:02:25.000 --> 00:02:34.000
나는 그 프로젝트를 만들고 카탈로그로 돌아갈 것이다.

00:02:34.000 --> 00:02:37.000
그건 쉬웠어. 여기 새로운 끈이 있습니다.

00:02:37.000 --> 00:02:41.000
그리고 우리는 내 번역 진행이 줄어들었다는 것을 알 수 있다.

00:02:41.000 --> 00:02:47.000
문자열 카탈로그는 또한 복잡한 작업을 쉽게 수행할 수 있는 강력한 편집 기능과 함께 제공됩니다.

00:02:47.000 --> 00:02:58.000
예를 들어, 이 문자열에는 탭이라는 단어가 있지만, 이것은 멀티 플랫폼 앱이므로, Mac 장치의 경우 올바른 단어를 사용하는지 확인하고 싶습니다.

00:02:58.000 --> 00:03:05.000
그래서 내 영어 현으로 돌아가서, "더 많은 것을 배우기 위해 탭"이라는 현을 찾을 수 있게 해줘.

00:03:05.000 --> 00:03:07.000
여기 있어.

00:03:07.000 --> 00:03:09.000
내가 마우스 오른쪽 버튼으로 클릭할게.

00:03:09.000 --> 00:03:14.000
선택은 장치에 따라 다릅니다. 맥을 선택하세요.

00:03:14.000 --> 00:03:25.000
그리고 텍스트를 올바르게 조정하세요.

00:03:25.000 --> 00:03:26.000
그리고 그게 다야.

00:03:26.000 --> 00:03:35.000
이제 내가 내 시야로 돌아가서 달리기 목적지를 Mac으로 바꾸면...

00:03:35.000 --> 00:03:39.000
우리는 미리보기를 사용하여 내 작업을 확인할 수 있다.

00:03:39.000 --> 00:03:41.000
그건 쉬웠어.

00:03:41.000 --> 00:03:44.000
문자열 카탈로그로 할 수 있는 일이 너무 많다.

00:03:44.000 --> 00:03:48.000
모든 것이 어떻게 작동하는지 더 자세히 살펴봅시다.

00:03:48.000 --> 00:03:59.000
문자열을 추출할 수 있는 장소부터 시작하여 문자열 카탈로그와 상호 작용하기 위한 Xcode의 기본 편집기를 탐색하고 현지화 내보내기 프로세스를 검토할 것입니다.

00:03:59.000 --> 00:04:07.000
그런 다음 문자열 카탈로그가 어떻게 구축되고 기존 프로젝트에서 어떻게 채택할 수 있는지 살펴보겠습니다.

00:04:07.000 --> 00:04:13.000
우선, 나는 그것을 Matt에게 넘겨서 지역화 가능한 문자열과 그들이 어디에서 왔는지에 대해 논의할 것이다.

00:04:13.000 --> 00:04:14.000
매트: 고마워 마리나!

00:04:14.000 --> 00:04:26.000
현지화 가능한 문자열은 단순히 런타임에 사용자에게 표시되는 텍스트 문자열이므로 앱이 지원하는 모든 언어로 번역되어야 합니다.

00:04:26.000 --> 00:04:36.000
지역화 가능한 문자열에는 네 가지 구성 요소가 있습니다: 키는 문자열의 고유 식별자이며, 종종 문자열 자체와 동일합니다.

00:04:36.000 --> 00:04:41.000
이것은 표시할 적절한 값을 찾기 위해 런타임에 사용될 것이다.

00:04:41.000 --> 00:04:51.000
기본값은 원하는 경우 명시적으로 지정할 수 있지만, 그렇지 않으면 기본 현지화의 키로 돌아갑니다.

00:04:51.000 --> 00:05:00.000
Xcode 14.3은 프로젝트 편집기를 사용하여 프로젝트의 기본 현지화를 변경할 수 있는 기능을 도입했습니다.

00:05:00.000 --> 00:05:05.000
이것은 소스 코드의 문자열이 영어가 아닌 경우에 유용합니다.

00:05:05.000 --> 00:05:14.000
다음으로, 문자열 주석은 사용자 인터페이스에서 문자열이 어디에 어떻게 사용되고 있는지에 대한 번역가 컨텍스트를 제공하는 방법을 제공합니다.

00:05:14.000 --> 00:05:21.000
번역가의 모호함을 해결하기 위해 문자열에 주석을 추가하는 것이 좋습니다.

00:05:21.000 --> 00:05:31.000
마지막으로, 각 지역화 가능한 문자열은 번역이 저장될 하나 이상의 파일에 해당하는 문자열 테이블에 속합니다.

00:05:31.000 --> 00:05:41.000
기본적으로 코드의 문자열은 "로컬라이제이저블" 테이블에 배치되지만, 다른 방법으로 문자열을 구성하려면 사용자 정의할 수 있습니다.

00:05:41.000 --> 00:05:44.000
스트링 테이블을 자세히 살펴봅시다.

00:05:44.000 --> 00:05:58.000
.Strings 파일을 사용하는 기존 응용 프로그램의 경우, 단일 문자열 테이블에는 실제로 지원되는 각 언어의 lproj 디렉토리 내에 .strings와 .stringsdict 파일이 포함되어 있습니다.

00:05:58.000 --> 00:06:03.000
여기에 표시된 모든 파일은 "현지화 가능한" 문자열 테이블을 구성합니다.

00:06:03.000 --> 00:06:11.000
반면에 문자열 카탈로그는 단일 파일에 전체 문자열 테이블을 포함한다.

00:06:11.000 --> 00:06:19.000
여기에는 해당 테이블의 각 지역화 가능한 문자열에 대한 모든 번역과 추가 메타데이터가 포함됩니다.

00:06:19.000 --> 00:06:27.000
문자열을 여러 문자열 테이블로 구성하려면, 여러 문자열 카탈로그를 만들 수 있습니다.

00:06:27.000 --> 00:06:37.000
각 카탈로그에는 앱이 지원하는 모든 언어로 번역된 번역과 함께 해당 테이블에 속한 문자열 키가 있습니다.

00:06:37.000 --> 00:06:45.000
키는 포함된 테이블 내에서 항상 고유하지만, 테이블 전체에서 키가 고유할 필요는 없습니다.

00:06:45.000 --> 00:06:56.000
예를 들어, "WWDC에 오신 것을 환영합니다!" 문자열은 앱 내에서 다른 컨텍스트에 표시될 수 있기 때문에 두 파일 모두에 있습니다.

00:06:56.000 --> 00:07:08.000
마리나가 이전에 언급했듯이, Xcode 15는 문자열 카탈로그를 자동으로 채우고 프로젝트에서 찾을 수 있는 현지화 가능한 문자열과 동기화하기 위해 최선을 다합니다.

00:07:08.000 --> 00:07:13.000
하지만 Xcode는 이러한 현지화 가능한 문자열을 어디에서 찾을 수 있나요?

00:07:13.000 --> 00:07:18.000
음, 현지화 가능한 문자열이 살 수 있는 다양한 장소가 있습니다.

00:07:18.000 --> 00:07:27.000
Xcode는 소스 코드, 인터페이스 빌더 파일, 심지어 문자열 카탈로그에 포함할 정보 목록에서 문자열을 찾을 수 있습니다.

00:07:27.000 --> 00:07:32.000
한동안 앱을 현지화했다면, 이들 중 많은 것들이 친숙하게 느껴질 것입니다.

00:07:32.000 --> 00:07:36.000
그것들 중 몇 개를 좀 더 자세히 살펴봅시다.

00:07:36.000 --> 00:07:38.000
우리는 SwiftUI로 시작할 거야.

00:07:38.000 --> 00:07:49.000
SwiftUI는 뷰 내에서 문자열 리터럴을 지정할 때마다 해당 문자열이 자동으로 현지화 가능한 것으로 간주되기 때문에 현지화를 원활하게 합니다.

00:07:49.000 --> 00:08:01.000
이 모든 문자열은 현지화 가능한 것으로 간주되며 존재하는 경우 Localizable.xcstrings라는 문자열 카탈로그로 추출됩니다.

00:08:01.000 --> 00:08:07.000
이것은 LocalizedStringKey 유형을 받아들이는 모든 매개 변수에 대해 작동합니다.

00:08:07.000 --> 00:08:16.000
SwiftUI 문자열은 텍스트 뷰를 사용하여 주석, 사용자 지정 테이블 이름 또는 문자열 조회를 위한 번들을 지정할 수 있습니다.

00:08:16.000 --> 00:08:23.000
또한 고객을 위해 현지화 가능한 것으로 간주되어야 하는 문자열을 받아들이는 사용자 지정 뷰를 정의할 수 있습니다.

00:08:23.000 --> 00:08:28.000
여기서 LocalizedStringResource를 문자열 유형으로 사용하고 있습니다.

00:08:28.000 --> 00:08:38.000
Xcode가 호출 사이트에서 LocalizedStringResource를 인스턴스화하는 데 사용되는 문자열 리터럴을 볼 때, 문자열이 현지화 가능하다는 것을 알게 될 것이다.

00:08:38.000 --> 00:08:46.000
LocalizedStringResource는 현지화 가능한 문자열을 표현하고 전달하는 데 권장되는 유형입니다.

00:08:46.000 --> 00:08:58.000
문자열 리터럴을 사용하여 초기화를 지원할 뿐만 아니라 주석, 테이블 이름 또는 문자열 키와 다른 기본값을 제공할 수도 있습니다.

00:08:58.000 --> 00:09:03.000
이제 더 일반적으로 스위프트 코드에 관심을 돌리자.

00:09:03.000 --> 00:09:08.000
여기 나중에 제시될 문자열을 포함하는 모델 코드가 있습니다.

00:09:08.000 --> 00:09:18.000
저는 런타임에 사용자에게 표시되는 문자열을 지정하기 위해 String 및 AttributedString의 현지화된 이니셜라이저를 사용하고 있습니다.

00:09:18.000 --> 00:09:25.000
Foundation을 가져온 모든 곳에서 LocalizedStringResource를 직접 사용할 수도 있습니다.

00:09:25.000 --> 00:09:33.000
문자열 카탈로그는 지역화 가능한 Swift 문자열을 추출하기 위해 Swift 컴파일러의 강력한 기술을 사용합니다.

00:09:33.000 --> 00:09:39.000
이러한 이유로, 스위프트 문자열을 추출하기 위해 컴파일러를 사용하는 빌드 설정을 활성화해야 합니다.

00:09:39.000 --> 00:09:44.000
하지만 문자열 카탈로그는 단순한 스위프트 코드에서 문자열을 추출할 수 있다.

00:09:44.000 --> 00:09:49.000
다음은 NSLocalizedString을 사용하는 Objective-C 코드의 예입니다.

00:09:49.000 --> 00:10:03.000
NSLocalizedString 매크로에 포함된 모든 문자열 리터럴은 자동으로 현지화 가능한 것으로 간주되며, 감지할 수 있는 유사한 매크로를 정의할 수도 있습니다.

00:10:03.000 --> 00:10:10.000
CFCopyLocalizedString을 사용하여 C 코드에서도 동일한 개념을 사용할 수 있습니다.

00:10:10.000 --> 00:10:20.000
C 또는 Objective-C에서 사용자 지정 현지화된 문자열 매크로를 지정하려면, 현지화된 문자열 매크로 이름 빌드 설정을 사용하세요.

00:10:20.000 --> 00:10:27.000
이제 이것이 소스 코드에서 어떻게 작동하는지 보았으니, 인터페이스 빌더에서 현지화 가능한 문자열을 살펴봅시다.

00:10:27.000 --> 00:10:32.000
인터페이스 빌더에 지정된 문자열은 자동으로 현지화 가능한 것으로 처리됩니다.

00:10:32.000 --> 00:10:42.000
인스펙터를 사용하여, 번역가에게 그것이 나타날 위치에 대한 컨텍스트를 제공하기 위해 이 문자열에 대한 주석을 지정할 수도 있습니다.

00:10:42.000 --> 00:10:51.000
문자열 카탈로그가 스토리보드 또는 xib와 페어링되면, 인터페이스 빌더의 모든 현지화 가능한 문자열이 카탈로그에 표시됩니다.

00:10:51.000 --> 00:10:58.000
소스 코드와 마찬가지로, Xcode는 프로젝트가 구축될 때마다 카탈로그를 업데이트합니다.

00:10:58.000 --> 00:11:02.000
이 과정은 Info plist 파일에서도 비슷하게 작동합니다.

00:11:02.000 --> 00:11:11.000
이를 위해, InfoPlist.xcstrings 파일을 프로젝트에 추가하고 원하는 대상에 추가하기만 하면 됩니다.

00:11:11.000 --> 00:11:21.000
빌드할 때마다 Xcode는 알려진 현지화 가능한 정보 plist 키 세트를 카탈로그에 추가하며, 필요한 경우 수동으로 더 많은 것을 추가할 수 있습니다.

00:11:21.000 --> 00:11:28.000
마지막으로, Xcode는 올해 앱 단축키 구문이 현지화되는 방식에 대한 몇 가지 큰 개선 사항을 포함하고 있다.

00:11:28.000 --> 00:11:35.000
더 알아보려면, 올해의 강연인 "앱 단축키로 앱을 집중 조명하세요"를 꼭 확인하세요.

00:11:35.000 --> 00:11:45.000
이제 Xcode가 지역화 가능한 문자열을 찾을 수 있는 다양한 장소를 둘러보았으니, 이 문자열이 문자열 카탈로그로 어떻게 가는지에 대해 조금 더 이야기해 봅시다.

00:11:45.000 --> 00:11:52.000
빌드할 때마다, Xcode는 현재 계획과 플랫폼에서 현지화 가능한 문자열을 발견할 것입니다.

00:11:52.000 --> 00:12:02.000
소스 코드의 문자열은 지역화 가능한 문자열의 진실 소스 역할을 하는 반면, 문자열 카탈로그의 소스 문자열은 동기화되어 유지됩니다.

00:12:02.000 --> 00:12:07.000
코드에서 새로운 문자열이 발견되면, Xcode는 그것들을 문자열 카탈로그에 추가할 것입니다.

00:12:07.000 --> 00:12:12.000
이 시점에서, 문자열은 번역될 준비가 되었다.

00:12:12.000 --> 00:12:18.000
앞서 논의했듯이, 지역화 가능한 문자열은 코드에 지정된 기본 소스 값을 가질 수 있습니다.

00:12:18.000 --> 00:12:24.000
이 경우, 카탈로그는 코드의 새로운 값으로 업데이트될 것이다.

00:12:24.000 --> 00:12:29.000
Xcode는 또한 코드에서 문자열을 제거했을 때 발견할 수 있습니다.

00:12:29.000 --> 00:12:34.000
문자열이 아직 번역되지 않았다면, Xcode는 당신을 위해 그것을 제거할 것입니다.

00:12:34.000 --> 00:12:44.000
그러나, 이미 문자열에 대한 번역을 제공한 다음 제거했다면, Xcode는 대신 그대로 두고 Stale로 표시할 것입니다.

00:12:44.000 --> 00:12:48.000
이것은 코드에서 문자열을 더 이상 찾을 수 없음을 나타냅니다.

00:12:48.000 --> 00:12:55.000
더 이상 필요하지 않다는 것을 확인할 수 있다면 문자열과 번역을 삭제할 수 있습니다.

00:12:55.000 --> 00:13:03.000
또는, 인스펙터를 사용하여 Xcode에 특정 문자열을 수동으로 관리하고 싶다고 말할 수 있습니다.

00:13:03.000 --> 00:13:11.000
수동으로 관리되는 문자열은 빌드 후 현지화를 동기화할 때 Xcode에 의해 업데이트되거나 제거되지 않습니다.

00:13:11.000 --> 00:13:19.000
이것은 키가 코드로 동적으로 구성되거나 데이터베이스에서 비롯된 문자열에 유용할 수 있다.

00:13:19.000 --> 00:13:30.000
이제 모든 문자열을 문자열 카탈로그로 추출했으므로, 문자열 카탈로그 편집기가 어떻게 번역을 쉽게 관리할 수 있는지 자세히 살펴봅시다.

00:13:30.000 --> 00:13:39.000
문자열 카탈로그는 앱을 현지화할 때 상태와 번역 진행 상황을 추적하기 위한 일류 지원과 함께 제공됩니다.

00:13:39.000 --> 00:13:45.000
우리는 이미 Xcode가 코드에서 더 이상 찾을 수 없을 때 문자열을 오래된 것으로 표시하는 방법에 대해 이야기했습니다.

00:13:45.000 --> 00:13:49.000
하지만 당신이 알아야 할 세 가지 다른 현지화 상태가 있습니다.

00:13:49.000 --> 00:13:55.000
"신규"는 문자열이 아직 선택한 언어로 번역되지 않았음을 나타냅니다.

00:13:55.000 --> 00:13:58.000
코드에 새 문자열을 추가한 후 이것을 볼 수 있습니다.

00:13:58.000 --> 00:14:07.000
"검토 필요"는 값을 변경해야 할 수도 있기 때문에 문자열이 로컬라이저의 주의가 필요하다는 것을 나타냅니다.

00:14:07.000 --> 00:14:13.000
현재 값을 사용하려면, 상황에 맞는 메뉴에서 "검토된 것으로 표시"를 선택하기만 하면 됩니다.

00:14:13.000 --> 00:14:18.000
이 메뉴를 사용하여 로컬라이저가 검토할 문자열을 표시할 수도 있습니다.

00:14:18.000 --> 00:14:23.000
잘못된 번역에 대한 버그 보고서를 받으면 유용할 수 있습니다.

00:14:23.000 --> 00:14:29.000
마지막으로, 선택한 언어로 번역된 문자열에는 녹색 체크 표시가 표시됩니다.

00:14:29.000 --> 00:14:33.000
이것은 더 이상의 조치가 필요하지 않다는 것을 나타낸다.

00:14:33.000 --> 00:14:39.000
개발자로서, 또 다른 일반적인 현지화 과제는 복수화이다.

00:14:39.000 --> 00:14:47.000
예를 들어, 여기 마리나가 이전에 뒷마당 새에 추가한 문자열이 있으며, 최근 방문객 수를 표시합니다.

00:14:47.000 --> 00:14:55.000
영어로, 우리는 숫자가 하나인지 아니면 다른 숫자인지에 따라 문자열의 문법을 변경해야 할 것이다.

00:14:55.000 --> 00:15:01.000
그러나, 우크라이나어와 같은 언어에서는 고려해야 할 더 많은 사례가 있을 수 있다.

00:15:01.000 --> 00:15:08.000
이 문제를 해결하기 위해, 우리는 전달된 숫자의 값에 따라 문자열을 변경할 수 있는 방법이 필요하다.

00:15:08.000 --> 00:15:15.000
이전에는 많은 언어에 대한 이 문제를 해결하기 위해 stringsdict 파일이 필요했을 것이다.

00:15:15.000 --> 00:15:25.000
이 plist 형식은 올바르게 사용하기 어려울 수 있으며 문자열을 복수화하는 것과 같은 간단한 작업에 상당히 높은 장벽을 도입합니다.

00:15:25.000 --> 00:15:32.000
이제 문자열 카탈로그 편집기에는 문자열 변형 워크플로우에 대한 지원이 내장되어 있습니다.

00:15:32.000 --> 00:15:39.000
문자열의 컨텍스트 메뉴를 공개함으로써, 문자열을 변경할 수 있는 옵션이 제공됩니다.

00:15:39.000 --> 00:15:46.000
그리고 기본 현지화에서 문자열을 변경하면 번역도 자동으로 변경됩니다.

00:15:46.000 --> 00:15:53.000
다음은 두 개의 변수로 복수 변형을 사용해야 하는 문자열의 더 복잡한 예입니다.

00:15:53.000 --> 00:15:57.000
런타임에, 우리는 몇 가지 다른 시나리오로 끝날 수 있다.

00:15:57.000 --> 00:16:10.000
우리는 하나의 뒷마당에 한 마리의 새, 한 개의 뒷마당에 여러 마리의 새, 여러 개의 뒷마당에 여러 마리의 새, 또는 여러 개의 뒷마당이 있음에도 불구하고 한 마리의 새가 있을 수 있습니다.

00:16:10.000 --> 00:16:18.000
각각의 경우에, 숫자를 둘러싼 문자열은 문법적 합의를 유지하기 위해 약간 다르게 번역되어야 한다.

00:16:18.000 --> 00:16:22.000
문자열 카탈로그 편집기는 이것을 쉽게 할 수 있게 해준다.

00:16:22.000 --> 00:16:25.000
여기가 대체가 들어오는 곳이다.

00:16:25.000 --> 00:16:30.000
여기서, 우리는 문자열의 두 인수를 복수형으로 변경했습니다.

00:16:30.000 --> 00:16:37.000
@ 기호로 접두사가 붙은 각 대체는 복수 사례와 그 값의 사전을 저장합니다.

00:16:37.000 --> 00:16:48.000
이 예에는 새 수를 포맷하기 위한 "새" 대체와 뒷마당 수를 포맷하기 위한 "야드" 대체가 포함되어 있습니다.

00:16:48.000 --> 00:16:59.000
런타임에, 여기에 표시된 최상위 문자열이 사용되며, 각 참조된 대체에서 적절한 복수의 경우로 대체됩니다.

00:16:59.000 --> 00:17:10.000
따라서 이 예에서, 이러한 문자열 중 하나라도 생성될 수 있으며, 각 대체에 대해 가능한 복수 사례의 순열을 효과적으로 생성할 수 있다.

00:17:10.000 --> 00:17:18.000
대체는 일반적으로 문자열에 전달된 인수에 해당하며, 종종 문자열 보간을 사용합니다.

00:17:18.000 --> 00:17:29.000
인스펙터에서 Xcode는 숫자에 사용할 인수의 위치와 전달되는 유형의 C 스타일 형식 지정자에 대한 정보를 보여줍니다.

00:17:29.000 --> 00:17:38.000
여기에 표시된 야드 치환은 소스 코드에 사용되는 두 번째 문자열 보간이기 때문에 인수 2에 해당합니다.

00:17:38.000 --> 00:17:48.000
그런 다음 backyards.count의 가치는 우리가 이 대체 내에서 하나 또는 다른 경우를 사용하는지 여부를 결정하는 데 사용될 것이다.

00:17:48.000 --> 00:17:57.000
이런 식으로, 문자열 카탈로그는 이와 같은 고급 사용 사례를 지원하면서 다양한 문자열을 위한 간단한 UI를 제공합니다.

00:17:57.000 --> 00:18:02.000
이제 이 기술들을 실행하기 위해 마리나로 돌아가세요.

00:18:02.000 --> 00:18:03.000
마리나: 고마워, 매트.

00:18:03.000 --> 00:18:09.000
Backyard Birds 앱으로 돌아가서, 문자열 카탈로그 편집기를 사용하면 내가 찾고 있는 문자열을 쉽게 찾을 수 있습니다.

00:18:09.000 --> 00:18:20.000
"배우다"라는 단어가 포함된 모든 문자열을 찾거나 상태별로 정렬하여 상단에서 가장 중요한 상태를 볼 수 있습니다.

00:18:20.000 --> 00:18:26.000
매트가 지적했듯이, 코드에 없지만 앱에 표시될 문자열이 있을 수 있다.

00:18:26.000 --> 00:18:33.000
예를 들어, 저는 제 앱이 앱 구독자를 위해 클라우드에서 오는 특별한 유형의 새를 표시할 수 있다는 것을 알고 있습니다.

00:18:33.000 --> 00:18:46.000
이 경우, 여기서 더하기 버튼을 사용하여 수동 문자열을 정의하고, 키와 주석을 줄 수 있습니다.

00:18:46.000 --> 00:18:52.000
수동으로 관리되는 문자열은 Xcode에 의해 업데이트되거나 제거되지 않는다는 것을 명심하세요.

00:18:52.000 --> 00:19:01.000
Xcode가 코드에서 문자열을 추출하기 시작하려면, 인스펙터를 확장하세요...

00:19:01.000 --> 00:19:05.000
그리고 문자열을 자동으로 관리하도록 설정하세요.

00:19:05.000 --> 00:19:09.000
Xcode는 또한 현지화 진행 상황을 쉽게 추적할 수 있게 해준다.

00:19:09.000 --> 00:19:15.000
각 문자열 옆에는 번역 상태를 나타내는 배지를 볼 수 있습니다.

00:19:15.000 --> 00:19:24.000
문자열이 코드에서 방금 추가되었을 때, 또는 우리가 방금 했던 것처럼 수동으로 추가되었을 때, 당신은 그것이 "신규"로 표시된 것을 보게 될 것입니다. 이는 아직 번역되지 않았다는 것을 의미합니다.

00:19:24.000 --> 00:19:29.000
소스 문자열이 변경될 때마다, 번역은 검토를 위해 표시될 것이다.

00:19:29.000 --> 00:19:36.000
이전에, 나는 이 문자열을 영어로 변경했기 때문에, 기존 번역은 검토를 위해 표시되었다.

00:19:36.000 --> 00:19:44.000
이 문자열이 그대로 괜찮다면, 문자열을 마우스 오른쪽 버튼으로 클릭하고 "검실된 것으로 표시"를 선택할 수 있습니다.

00:19:44.000 --> 00:19:55.000
나는 포르투갈어를 하기 때문에, 이 번역을 업데이트해야 한다는 것을 알고 있다.

00:19:55.000 --> 00:20:02.000
이 변화로, 우리는 여기 사이드바에서 현지화 비율이 올랐다는 것을 볼 수 있다.

00:20:02.000 --> 00:20:09.000
언어가 완전히 현지화되면, 사이드바에 녹색 체크 표시가 표시됩니다.

00:20:09.000 --> 00:20:19.000
Xcode에서 현지화 진행 상황을 추적하고 App Store에 제출하기 전에 앱이 완전히 현지화되었다고 확신할 수 있는 것은 이번이 처음입니다.

00:20:19.000 --> 00:20:23.000
나는 또한 이 앱이 우크라이나어로 현지화되도록 준비하고 싶다.

00:20:23.000 --> 00:20:37.000
더하기 버튼을 누르고 이 목록에서 새로운 언어를 선택하여 문자열 카탈로그 편집기에서 바로 이것을 할 수 있습니다.

00:20:37.000 --> 00:20:43.000
그리고 여기 아직 번역이 없는 내 우크라이나어 카탈로그가 있어.

00:20:43.000 --> 00:20:48.000
이것은 우리가 이전에 추가한 문자열이며, 복수로 변경해야 할 것 같습니다.

00:20:48.000 --> 00:20:52.000
그것을 위해, 영어로 돌아가자.

00:20:52.000 --> 00:20:57.000
이 문자열을 마우스 오른쪽 버튼으로 클릭하고 "복수형으로 변형"을 선택하겠습니다.

00:20:57.000 --> 00:21:06.000
영어의 경우, 나는 복수형과 단수형을 구별해야 한다는 것을 알고 있으므로, 그것을 고치자.

00:21:06.000 --> 00:21:10.000
포르투갈어에서, 복수의 경우는 영어와 같다.

00:21:10.000 --> 00:21:17.000
그러나, 우리가 우크라이나어를 들여다보면, 당신은 나를 위해 다른 복수 사례 세트가 추가되었다는 것을 알 수 있다.

00:21:17.000 --> 00:21:23.000
내 우크라이나어 번역가는 이것으로 무엇을 해야 할지 정확히 알 것이다.

00:21:23.000 --> 00:21:30.000
내 관점에서, 나는 각 뒷마당에 있는 새의 수를 나타내는 또 다른 라벨을 추가하고 싶었다.

00:21:30.000 --> 00:21:35.000
그래서 내가 추가할게...

00:21:35.000 --> 00:21:39.000
건설하다...

00:21:39.000 --> 00:21:43.000
그리고 내 카탈로그로 돌아가.

00:21:43.000 --> 00:21:45.000
그리고 여기 내 카탈로그에 있어.

00:21:45.000 --> 00:21:50.000
나는 또한 문자열을 복수로 바꾸고 싶지만, 그것은 여러 인수를 포함하고 있다.

00:21:50.000 --> 00:21:58.000
이번에는 문자열을 마우스 오른쪽 버튼으로 클릭하고 복수형으로 선택할 때, 어떤 인수를 바꾸고 싶은지 선택할 수 있습니다.

00:21:58.000 --> 00:22:06.000
둘 다 달라지자.

00:22:06.000 --> 00:22:12.000
다음으로, 나는 그들이 런타임에 복수화될 수 있도록 대체를 설정할 것이다.

00:22:12.000 --> 00:22:16.000
그 주장에 동의해야 하는 단어들을 옮기자.

00:22:16.000 --> 00:22:29.000
그래서 "새"를 "새"로 대체하고 "뒷마당"을 "야드"로 대체한다.

00:22:29.000 --> 00:22:38.000
가독성을 위해, 변수가 어떤 인수에 해당하는지 알 수 있도록 대체의 이름을 바꾸고 싶습니다.

00:22:38.000 --> 00:22:40.000
그건 이해하기 더 쉬워.

00:22:40.000 --> 00:22:47.000
이제 Matt는 우크라이나어로 번역하기 위해 문자열을 내보내는 방법을 보여줄 것이다.

00:22:47.000 --> 00:22:48.000
매트: 고마워, 마리나.

00:22:48.000 --> 00:23:02.000
이미 보았듯이, Xcode를 사용하면 문자열 카탈로그에서 직접 번역을 쉽게 제공하고 편집할 수 있지만, 종종 번역가와 협력하여 Xcode 외부에서 앱의 문자열을 현지화해야 합니다.

00:23:02.000 --> 00:23:07.000
이 시나리오에서, Xcode는 현지화 내보내기 옵션을 제공합니다.

00:23:07.000 --> 00:23:15.000
이것은 번역을 위해 보낼 수 있는 각 언어에 대해 하나의 현지화 카탈로그를 생성합니다.

00:23:15.000 --> 00:23:26.000
Xcode 10에서 처음 도입된 현지화 카탈로그는 프로젝트 또는 작업 공간 내의 모든 현지화 가능한 콘텐츠를 포함하는 패키지 형식입니다.

00:23:26.000 --> 00:23:34.000
지금은 모든 지역화 가능한 문자열과 번역이 포함된 내부 XLIFF 파일에 초점을 맞출 것입니다.

00:23:34.000 --> 00:23:42.000
XLIFF는 현지화를 저장하고 전송하기 위한 업계 표준 형식이다.

00:23:42.000 --> 00:23:53.000
당신이나 당신이 유지하는 도구가 XLIFF 파일로 직접 작업한다면, 문자열 카탈로그를 사용하는 프로젝트에 대해 다양한 문자열이 어떻게 표현되는지에 대한 몇 가지 변경 사항을 알고 싶을 것입니다.

00:23:53.000 --> 00:24:00.000
다음은 원래 .stringsdict 파일에 정의된 복수 문자열의 XLIFF 표현의 예입니다.

00:24:00.000 --> 00:24:07.000
여기에 표시된 트랜스 유닛 식별자는 stringsdict plist 형식의 경로 역할을 합니다.

00:24:07.000 --> 00:24:14.000
다양한 문자열이 대신 문자열 카탈로그에서 유래할 때, 그들은 대신 이렇게 보일 것이다.

00:24:14.000 --> 00:24:23.000
그것들은 문자열 키, 구분 기호 시퀀스, 그리고 마지막으로 적으로 구분된 구성 문자열을 포함한다.

00:24:23.000 --> 00:24:36.000
이 구성 문자열은 간단한 복수 지정자, 장치 지정자, 여러 조건의 체인 또는 대체 내부의 복수 사례에 대한 경로가 될 수 있습니다.

00:24:36.000 --> 00:24:47.000
자동화 툴링이 이러한 키를 읽기 쉬워야 할 뿐만 아니라, 인간이 한 눈에 읽고 이해할 수 있도록 설계했습니다.

00:24:47.000 --> 00:24:57.000
번역 도구는 또한 XLIFF의 번역 단위를 원하는 변형 구조로 대체하여 이전에 변경되지 않은 문자열을 변경할 수 있습니다.

00:24:57.000 --> 00:25:02.000
예를 들어, 여기 현재 전혀 다양하지 않은 문자열이 있습니다.

00:25:02.000 --> 00:25:08.000
하지만 포르투갈어로, 저는 특히 Apple Watch에 더 짧은 문자열을 제공하고 싶습니다.

00:25:08.000 --> 00:25:23.000
그 장치를 XLIFF의 device.applewatch 및 device.other 변형으로 교체함으로써, 우리는 다음 수입에서 이 언어에 존재할 변형 구조에 영향을 미칠 수 있습니다.

00:25:23.000 --> 00:25:34.000
현지화를 내보낼 때 XLIFF가 기본적으로 문자열 카탈로그 형식을 사용하도록 하려면, 현지화가 문자열 카탈로그를 선호하도록 설정해야 합니다.

00:25:34.000 --> 00:25:41.000
번역가로부터 번역된 현지화 카탈로그를 받으면, 그것을 프로젝트로 다시 가져올 수 있습니다.

00:25:41.000 --> 00:25:51.000
문자열 카탈로그에서 온 문자열의 경우, 가져온 파일에 지정된 번역이 적절한 문자열 카탈로그에 자동으로 추가됩니다.

00:25:51.000 --> 00:25:54.000
뒷마당 새들에서 이걸 시도해 보자.

00:25:54.000 --> 00:26:05.000
마리나: 저는 포르투갈어를 하기 때문에 이미 앱을 포르투갈어로 번역했지만, 현지화된 콘텐츠를 제공하기 위해 번역가를 위해 우크라이나 현지화 카탈로그를 보내야 합니다.

00:26:05.000 --> 00:26:15.000
제품 메뉴에서 여기를 클릭하고, 현지화 내보내기를 선택하고, 내보내고 싶은 언어를 선택하는 것으로 시작하겠습니다.

00:26:15.000 --> 00:26:18.000
이 경우, 그냥 우크라이나어.

00:26:18.000 --> 00:26:24.000
이제 내보내기를 클릭할 수 있습니다.

00:26:24.000 --> 00:26:29.000
그들이 나에게 번역을 다시 보내면, 나는 그것들을 내 앱으로 가져올 수 있다.

00:26:29.000 --> 00:26:31.000
오, 여기 있어.

00:26:31.000 --> 00:26:52.000
이제 번역이 준비되면, 앱으로 돌아가서, 이번에는 제품 메뉴를 클릭하고, 현지화 가져오기를 선택하고, 우크라이나 현지화 카탈로그를 선택할 것입니다.

00:26:52.000 --> 00:26:58.000
좋아, 모든 게 어떻게 보이는지 보자.

00:26:58.000 --> 00:27:06.000
완벽해, 내 우크라이나어 번역이 제자리에 있고, 이제 내 앱은 두 언어로 완전히 현지화되어 있어.

00:27:06.000 --> 00:27:08.000
포르투갈어로 어떻게 보이는지 보자.

00:27:08.000 --> 00:27:13.000
나는 계획 선택기를 클릭하고 계획 편집을 선택할 것이다.

00:27:13.000 --> 00:27:21.000
옵션에 따라, 앱 언어를 시스템에서 포르투갈어로 변경할 수 있습니다.

00:27:21.000 --> 00:27:37.000
그리고 내가 그 앱을 실행할게.

00:27:37.000 --> 00:27:48.000
좋아, 여기 우리가 작업한 몇 가지 문자열이 있어.

00:27:48.000 --> 00:27:52.000
이제 우리가 번역을 끝냈으니, 넘겨 받아, 매트.

00:27:52.000 --> 00:27:59.000
매트: 이제 우리 앱의 콘텐츠가 완전히 번역되었으니, 빌드 중에 무슨 일이 일어나는지 간략하게 논의해 봅시다.

00:27:59.000 --> 00:28:05.000
문자열 카탈로그는 Xcode 프로젝트 내의 상호 작용을 위해 특별히 설계되었습니다.

00:28:05.000 --> 00:28:11.000
후드 아래의 JSON 파일로서, 그것들은 또한 소스 제어에서 쉽게 디플 수 있어야 한다.

00:28:11.000 --> 00:28:17.000
그런 다음, 빌드 시, 이 파일들은 .strings와 .stringsdict 파일로 컴파일됩니다.

00:28:17.000 --> 00:28:31.000
이러한 파일 형식은 수년 동안 운영 체제에서 지원되어 왔기 때문에, 최소 배포 목표를 업데이트하지 않고도 바로 문자열 카탈로그를 사용할 수 있다고 말하게 되어 기쁩니다.

00:28:31.000 --> 00:28:37.000
또한 코드에서 추출된 소스 문자열이 최종 빌드에 포함되지 않는다는 점도 주목할 가치가 있다.

00:28:37.000 --> 00:28:43.000
이것은 런타임에 표시된 문자열에 영향을 미치지 않고 디스크 공간을 절약해야 합니다.

00:28:43.000 --> 00:28:51.000
이제 이러한 모든 이점을 보았으므로, 마리나는 기존 프로젝트에서 문자열 카탈로그를 시작하는 방법을 보여줄 것입니다.

00:28:51.000 --> 00:28:57.000
마리나: Xcode를 사용하면 기존 프로젝트를 쉽게 마이그레이션하여 문자열 카탈로그를 사용할 수 있습니다.

00:28:57.000 --> 00:28:59.000
그리고 당신은 이것을 당신만의 속도로 할 수 있습니다.

00:28:59.000 --> 00:29:04.000
준비가 되면, 마이그레이션할 문자열 파일과 대상을 선택할 수 있습니다.

00:29:04.000 --> 00:29:09.000
여기 우리가 작년에 현지화한 기존 앱인 FoodTruck이 있습니다.

00:29:09.000 --> 00:29:13.000
여기서 문자열과 stringsdict 파일이 있다는 것을 알 수 있습니다.

00:29:13.000 --> 00:29:21.000
문자열 카탈로그는 레거시 형식과 공존할 수 있으므로, 준비가 되면 현지화 가능한 테이블을 마이그레이션하도록 선택할 수 있습니다.

00:29:21.000 --> 00:29:22.000
지금 하자.

00:29:22.000 --> 00:29:28.000
파일을 마우스 오른쪽 버튼으로 클릭하고 "스트링 카탈로그로 마이그레이션"을 선택하겠습니다.

00:29:28.000 --> 00:29:35.000
Xcode에는 내 프로젝트의 모든 마이그레이션 가능한 파일을 나열하는 내장 마이그레이션 어시스턴트가 포함되어 있습니다.

00:29:35.000 --> 00:29:41.000
여기서 나는 FoodTruck 목표의 일부인 Localizable 테이블을 볼 수 있다.

00:29:41.000 --> 00:29:46.000
나는 지금 이걸 옮길 거야.

00:29:46.000 --> 00:29:51.000
좋아! 마이그레이션 후, Xcode는 문자열을 추출하기 위해 내 프로젝트를 구축할 것이다.

00:29:51.000 --> 00:29:55.000
카탈로그가 빌드 후에 어떻게 보이는지 봅시다.

00:29:55.000 --> 00:30:03.000
여기서 우리는 내 문자열 파일의 모든 문자열과 심지어 stringsdict 파일의 복수가 마이그레이션된 것을 볼 수 있다.

00:30:03.000 --> 00:30:11.000
내 모든 아랍어 번역이 제자리에 있지만, 우리는 여기서 프랑스어의 번역 진행이 100%가 아니라는 것을 알 수 있다.

00:30:11.000 --> 00:30:16.000
문자열 카탈로그는 이미 내 프로젝트에서 현지화되지 않은 문자열을 찾는 데 도움을 주고 있다.

00:30:16.000 --> 00:30:22.000
FoodTruck은 또한 아직 현지화되지 않은 신속한 패키지인 FoodTruckKit을 가지고 있다.

00:30:22.000 --> 00:30:29.000
문자열 카탈로그로 새로운 패키지나 프로젝트를 현지화하는 것은 매우 쉽습니다.

00:30:29.000 --> 00:30:40.000
패키지 매니페스트에 기본 현지화를 추가하고 Swift Tools 버전 5.9를 사용하고 있는지 확인합니다.

00:30:40.000 --> 00:30:51.000
그런 다음 기본 테이블 이름이 "Localizable"인 패키지에 새 문자열 카탈로그를 추가하겠습니다.

00:30:51.000 --> 00:30:56.000
내 프로젝트를 만든 후, 나는 내 패키지 전체에서 모든 문자열을 볼 수 있다.

00:30:56.000 --> 00:31:02.000
새로운 프로젝트나 패키지를 현지화하기 시작하는 것은 매우 쉽다.

00:31:02.000 --> 00:31:11.000
문자열 카탈로그는 Xcode 현지화의 새로운 토대이며 프로젝트의 번역 관리 과정을 단순화합니다.

00:31:11.000 --> 00:31:14.000
우리는 당신이 오늘 기존 문자열을 마이그레이션하여 시작하기를 바랍니다.

00:31:14.000 --> 00:31:21.000
그리고 이전에 앱을 현지화한 적이 없다면, 시작하기가 얼마나 쉬운지 영감을 받기를 바랍니다.

00:31:21.000 --> 00:31:23.000
Obrigada pela companhia hoje.

00:31:23.000 --> 00:31:26.000
우리와 함께 해줘서 고마워, 그리고 행복한 조류 관찰.

00:31:26.000 --> 23:59:59.000
♪ ♪

