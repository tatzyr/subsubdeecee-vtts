WEBVTT

00:00:01.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:15.000
루카: 안녕! 제 이름은 루카이고 SwiftUI 팀의 엔지니어입니다.

00:00:15.000 --> 00:00:24.000
오늘 우리는 새롭고 흥미로운 기능으로 위젯에 생명을 불어넣을 수 있는 방법에 대해 논의할 것입니다.

00:00:24.000 --> 00:00:39.000
위젯은 iOS와 macOS 경험에서 사랑받는 부분이며, 이제 상호 작용과 애니메이션을 통해 훨씬 더 강력합니다.

00:00:39.000 --> 00:00:52.000
상호 작용을 통해 사용자는 위젯의 데이터를 직접 조작하여 앱에서 가장 중요한 작업을 실행할 수 있는 강력한 상호 작용을 만들 수 있습니다.

00:00:52.000 --> 00:01:03.000
그리고 애니메이션은 사용자가 콘텐츠가 어떻게 변했는지, 그리고 그들의 행동의 결과가 무엇인지 알 수 있도록 도와줌으로써 위젯에 생명을 불어넣는다.

00:01:03.000 --> 00:01:09.000
저는 이 모든 새로운 기능에 대해 매우 흥분되니, 시작합시다.

00:01:09.000 --> 00:01:16.000
먼저, 우리는 애니메이션과 위젯을 멋지게 보이게 하는 것이 얼마나 쉬운지 다룰 것입니다.

00:01:16.000 --> 00:01:23.000
그 후, 위젯에 상호 작용을 추가하는 방법을 안내해 드리겠습니다.

00:01:23.000 --> 00:01:25.000
애니메이션부터 시작합시다.

00:01:25.000 --> 00:01:36.000
이 이야기 내내, 우리는 내 친구 Nils가 낮 동안 카페인 섭취량을 추적하기 위해 작업하고 있는 앱을 사용할 것이다.

00:01:36.000 --> 00:01:43.000
그것은 이미 카페인의 총량과 내가 오늘 마신 마지막 음료를 보여주는 위젯을 가지고 있다.

00:01:43.000 --> 00:01:58.000
최신 SDK로 위젯을 다시 컴파일하면, 위젯의 콘텐츠가 변경될 때마다 시스템은 기본 애니메이션으로 항목 간의 전환을 애니메이션화할 것입니다.

00:01:58.000 --> 00:02:10.000
우리는 더 좋아 보이게 하기 위해 여기에 몇 가지 조정을 추가할 것이지만, Xcode에 뛰어들기 전에 애니메이션이 위젯과 어떻게 작동하는지에 대해 간략하게 이야기하겠습니다.

00:02:10.000 --> 00:02:16.000
일반 SwiftUI 앱에서는 상태를 사용하여 보기를 변경합니다.

00:02:16.000 --> 00:02:23.000
그리고 애니메이션은 withAnimation과 같은 수정자를 사용하여 상태 돌연변이에 의해 구동된다.

00:02:23.000 --> 00:02:26.000
하지만 위젯은 약간 다르게 작동한다.

00:02:26.000 --> 00:02:29.000
위젯에는 상태가 없습니다.

00:02:29.000 --> 00:02:38.000
대신, 그들은 특정 시간에 렌더링된 다른 견해에 해당하는 항목으로 만들어진 타임라인을 만든다.

00:02:38.000 --> 00:02:47.000
SwiftUI는 항목 간에 무엇이 동일하고 무엇이 다른지 결정하고, 변경된 부분을 애니메이션화합니다.

00:02:47.000 --> 00:03:05.000
기본적으로 위젯은 암시적 스프링 애니메이션과 다양한 암시적 콘텐츠 전환을 제공하지만, SwiftUI가 즉시 제공하는 모든 전환, 애니메이션 및 콘텐츠 전환 API를 사용하여 위젯의 애니메이션 방식을 사용자 정의할 수 있습니다.

00:03:05.000 --> 00:03:11.000
나는 SwiftUI의 모든 애니메이션 기본이 어떻게 작동하는지에 대해 더 자세히 설명하지 않을 것이다.

00:03:11.000 --> 00:03:37.000
그것을 위해, "스위프트UI 애니메이션 탐험"이라는 환상적인 강연이 있다. 좋아요, Xcode를 열고 몇 가지 조정으로 위젯이 아침 카푸치노의 라떼 아트만큼 화려할 수 있는 방법과 새로운 Xcode Preview API가 이러한 애니메이션을 빠르게 반복하는 데 어떻게 도움이 될 수 있는지 보여줄 시간입니다.

00:03:37.000 --> 00:03:41.000
여기 내 위젯을 구성하는 모든 견해가 있습니다.

00:03:41.000 --> 00:03:53.000
메인 뷰에는 두 가지 뷰가 있는 VStack이 있는데, 첫 번째는 카페인의 총량을 보여주고 두 번째는 내가 오늘 마신 마지막 음료이다.

00:03:53.000 --> 00:04:01.000
위젯의 배경을 정의하기 위해 containerBackground 수정자를 어떻게 사용하는지 주목하세요.

00:04:01.000 --> 00:04:06.000
이를 통해 Mac과 iPad의 지원되는 모든 새로운 위치에 표시할 수 있습니다.

00:04:06.000 --> 00:04:24.000
일반적으로, 위젯 애니메이션을 보려면, 많은 항목이 있고 그 순간이 화면에 나타날 때까지 기다려야 하지만, 그것은 지루할 수 있고 속도를 늦출 수 있지만, 운 좋게도 우리는 올해 도입하는 새로운 미리보기 API로 훌륭한 솔루션을 가지고 있습니다.

00:04:24.000 --> 00:04:35.000
systemSmall에서 위젯에 대한 새로운 미리보기를 정의하고 위젯을 정의하는 유형을 전달할 수 있습니다.

00:04:35.000 --> 00:04:42.000
그리고 이제 앞서 정의한 몇 가지 항목으로 타임라인을 렌더링하는 방법을 지정할 수 있습니다.

00:04:42.000 --> 00:04:50.000
캔버스에서 그것을 할 때, 나는 이제 내 타임라인의 미리보기와 모든 항목이 어떻게 보이는지 볼 수 있다.

00:04:50.000 --> 00:04:52.000
하지만 이것 좀 봐!

00:04:52.000 --> 00:04:59.000
미리보기를 클릭하면, 항목 사이를 전환할 때 위젯이 어떻게 움직이는지 볼 수 있습니다.

00:04:59.000 --> 00:05:01.000
이거 꽤 멋지다!

00:05:01.000 --> 00:05:07.000
그리고 이것은 이 새로운 미리보기 API가 할 수 있는 것의 표면을 긁고 있을 뿐이다.

00:05:07.000 --> 00:05:16.000
이 새로운 강력한 API에 대해 자세히 알아보려면 "Xcode Previews로 프로그래밍 방식 UI 구축" 세션을 확인하세요.

00:05:16.000 --> 00:05:20.000
좋아, 이 애니메이션을 조정하기 시작할 시간이야.

00:05:20.000 --> 00:05:26.000
내가 가장 먼저 하고 싶은 것은 카페인 양에 대한 텍스트로 시작하는 것이다.

00:05:26.000 --> 00:05:34.000
지금 당장은 다음 가치와 교차 페이딩하고 있지만, 나는 정말로 올라가는 가치에 드라마를 더하고 싶다.

00:05:34.000 --> 00:05:44.000
이 경우, 보기는 변경되지 않지만, 텍스트 콘텐츠만 변경되며, 애니메이션으로 콘텐츠 전환을 사용할 수 있습니다.

00:05:44.000 --> 00:05:51.000
그리고 나는 내 카페인의 가치와 함께 숫자 텍스트를 추가하는 것을 선택할 것이다.

00:05:51.000 --> 00:06:02.000
이것은 그들이 바뀔 때 우리가 두드러지게 하고 싶은 중요한 숫자 값을 위해 특별히 만들어진 콘텐츠 전환이다.

00:06:02.000 --> 00:06:05.000
난 그게 멋져 보인다고 생각해!

00:06:05.000 --> 00:06:11.000
이제, 나는 마지막 음료를 보여주는 관점에 집중하고 싶다.

00:06:11.000 --> 00:06:16.000
나는 새로운 음료가 들어오고 있다는 것을 강조하기 위해 전환을 추가하고 싶다.

00:06:16.000 --> 00:06:27.000
제가 가장 먼저 하고 싶은 것은 ID 수정자를 사용하여 이 뷰의 ID를 렌더링하는 특정 로그와 연결하는 것입니다.

00:06:27.000 --> 00:06:35.000
이것은 SwiftUI에게 이 로그가 변경될 때마다, 이것은 새로운 보기이며 우리는 새로운 보기로 전환해야 한다는 것을 알릴 것이다.

00:06:35.000 --> 00:06:41.000
그리고 이제 나는 전환을 지정할 수 있다. 밀어붙이는 게 좋을 것 같아.

00:06:41.000 --> 00:06:43.000
어느 가장자리에서?

00:06:43.000 --> 00:06:49.000
나는 밑바닥부터 좋은 선택이라고 생각해.

00:06:49.000 --> 00:06:57.000
그래, 넌 이미 지금 뭘 해야 할지 알잖아. 미리보기 캔버스로 돌아가세요.

00:06:57.000 --> 00:07:01.000
그리고 응, 나는 밑바닥에서 이 전환이 좋아.

00:07:01.000 --> 00:07:03.000
마지막 조정.

00:07:03.000 --> 00:07:11.000
나는 그렇게 많은 커피를 마실 때 약간 불안해하며, 나는 그것이 이 전환을 위한 애니메이션 곡선에 반영되기를 원한다.

00:07:11.000 --> 00:07:32.000
좋은 점은 일반 SwiftUI 앱과 마찬가지로 애니메이션 수정자를 사용하고 더 짧은 기간의 부드러운 스프링을 선택하고 그 애니메이션을 내 로그 값에 바인딩할 수 있다는 것입니다.

00:07:32.000 --> 00:07:36.000
그리고 이제, 그 애니메이션은 내 카페인과 일치할 것이다.

00:07:36.000 --> 00:07:42.000
나는 우리가 지금 가지고 있는 것에 대해 꽤 기분이 좋아, 그러니 우리의 관심을 상호 작용으로 바꾸자.

00:07:42.000 --> 00:07:48.000
상호 작용을 사용하면 위젯에서 바로 작업을 실행할 수 있습니다!

00:07:48.000 --> 00:07:55.000
Xcode에 뛰어들기 전에, 위젯이 어떻게 작동하는지에 대한 아키텍처에 대해 잠시 논의하고 싶습니다.

00:07:55.000 --> 00:08:02.000
이것은 당신이 상호 작용이 어떻게 작동하는지에 대한 더 나은 정신 모델을 만들 수 있게 해줄 것이다.

00:08:02.000 --> 00:08:12.000
위젯을 만들 때, 시스템에 의해 발견되고 독립적인 프로세스로 실행되는 위젯 확장을 정의합니다.

00:08:12.000 --> 00:08:20.000
위젯은 효과적으로 위젯의 모델인 일련의 항목을 반환하는 타임라인 공급자를 정의합니다.

00:08:20.000 --> 00:08:29.000
위젯이 보이면, 시스템은 위젯 확장 프로세스를 시작하고 타임라인 공급자에게 항목을 요청합니다.

00:08:29.000 --> 00:08:40.000
이러한 항목은 위젯 구성의 일부인 뷰 빌더에 다시 공급되며 이러한 항목을 기반으로 일련의 뷰를 생성하는 데 사용됩니다.

00:08:40.000 --> 00:08:47.000
그 후, 시스템은 이러한 뷰의 표현을 생성하고 디스크에 보관한다.

00:08:47.000 --> 00:08:57.000
특정 항목을 표시할 때가 되면, 시스템은 그 과정에서 위젯의 보관된 표현을 디코딩하고 렌더링합니다.

00:08:57.000 --> 00:09:03.000
잠시 멈추고 이 마지막 요점을 반복하겠습니다.

00:09:03.000 --> 00:09:07.000
보기 코드는 보관 중에만 실행됩니다.

00:09:07.000 --> 00:09:12.000
그 견해의 별도의 표현은 시스템 프로세스에 의해 렌더링된다.

00:09:12.000 --> 00:09:18.000
하지만 당신의 데이터가 정적이지 않다면, 그 항목을 업데이트하고 싶을 수도 있습니다.

00:09:18.000 --> 00:09:28.000
위젯에 표시되는 데이터를 업데이트할 때마다 앱에서 reloadTimelines 기능을 호출하여 그렇게 할 수 있습니다.

00:09:28.000 --> 00:09:37.000
이것은 내가 방금 설명한 과정을 반복하고, 새 항목을 재생성하고, 디스크에 뷰의 새 복사본을 보관할 것이다.

00:09:37.000 --> 00:09:41.000
이 건축물에는 세 가지 중요한 교훈이 있다.

00:09:41.000 --> 00:09:47.000
첫째, 위젯이 보일 때, 코드가 실행되지 않습니다.

00:09:47.000 --> 00:09:56.000
타임라인 항목을 업데이트하여 위젯 콘텐츠를 변경하며, 이는 대화형 위젯에서도 마찬가지입니다.

00:09:56.000 --> 00:10:10.000
일반적으로, 위젯에 대한 업데이트는 최선의 노력으로 이루어지지만, 중요한 것은 상호 작용에서 시작된 재장전이 항상 발생한다는 것입니다.

00:10:10.000 --> 00:10:15.000
이것과 함께, 상호 작용을 추가하는 방법을 살펴봅시다.

00:10:15.000 --> 00:10:25.000
좋은 점은 버튼과 토글과 같이 이미 익숙한 컨트롤을 사용하여 위젯의 일부를 인터랙티브하게 만들 수 있다는 것입니다.

00:10:25.000 --> 00:10:36.000
하지만 위젯은 다른 프로세스에서 렌더링되기 때문에 SwiftUI는 프로세스 공간에서 클로저를 실행하거나 바인딩을 변경하지 않습니다.

00:10:36.000 --> 00:10:45.000
그래서 우리는 위젯 확장에 의해 실행되고 시스템에 의해 호출될 수 있는 행동을 나타내는 방법이 필요하다.

00:10:45.000 --> 00:10:51.000
고맙게도, 이미 이 문제에 대한 해결책이 있다: 앱 인텐트.

00:10:51.000 --> 00:10:58.000
앱 의도를 사용하여 앱의 작업을 단축키 또는 Siri에 노출했을 수도 있습니다.

00:10:58.000 --> 00:11:05.000
그리고 이제, 위젯의 행동을 나타내는 데 동일한 의도를 사용할 수 있습니다.

00:11:05.000 --> 00:11:15.000
핵심적으로, AppIntent는 시스템에서 실행할 수 있는 작업을 코드로 정의할 수 있는 프로토콜입니다.

00:11:15.000 --> 00:11:22.000
예를 들어, 여기서, 저는 할 일 앱에서 할 일 항목을 전환하기 위한 앱 의도를 정의하고 있습니다.

00:11:22.000 --> 00:11:34.000
인텐트에는 여러 매개 변수가 입력과 perform라는 비동기 함수로 정의되며, 여기서 인텐트를 실행할 비즈니스 논리가 있습니다.

00:11:34.000 --> 00:11:52.000
앱 인텐트는 매우 강력하며, 그들에 대해 알아야 할 것이 훨씬 더 많기 때문에, WWDC22와 23의 "Dive into App Intents"와 "Explore enhancements to App Intents" 세션을 확인하십시오.

00:11:52.000 --> 00:12:15.000
그리고 UI에서 바로 앱 인텐트를 실행할 수 있는 기능을 지원하기 위해, SwiftUI와 AppIntents를 모두 가져올 때, 버튼과 토글에 AppIntent를 인수로 받아들이고 이러한 컨트롤이 상호 작용할 때 그 인텐트를 실행하는 새로운 이니셜라이저 제품군이 있습니다.

00:12:15.000 --> 00:12:21.000
인터랙티브 위젯에서는 AppIntent를 사용하는 버튼과 토글만 지원됩니다.

00:12:21.000 --> 00:12:24.000
다른 컨트롤은 작동하지 않을 것이다.

00:12:24.000 --> 00:12:35.000
그리고 물론, 이러한 이니셜라이저는 앱에서도 작동하며, 위젯과 앱 간에 앱 인텐트 로직을 공유할 수 있기 때문에 멋집니다.

00:12:35.000 --> 00:12:41.000
Xcode와 커피 추적기 앱으로 돌아가서 상호 작용을 추가합시다.

00:12:41.000 --> 00:13:00.000
현재, 사용자는 앱을 열어서만 새로운 음료를 기록할 수 있지만, 대화형 위젯이 빛나는 곳은 앱에서 가장 중요한 작업을 표면화하기 위한 가속기이며, 내 앱의 경우, 이것은 확실히 새로운 음료의 로깅입니다.

00:13:00.000 --> 00:13:03.000
그래서 내가 이미 만든 파일에 그것을 추가하자.

00:13:03.000 --> 00:13:11.000
내가 하고 싶은 첫 번째 일은 새로운 음료를 기록하기 위해 AppIntent에 부합하는 유형을 정의하는 것이다.

00:13:11.000 --> 00:13:26.000
우리는 시스템에서 사용할 수 있는 사람이 읽을 수 있는 제목을 부여한 다음, 우리 가게에 에스프레소를 기록하고 빈 의도 결과를 반환하여 수행 요구 사항을 구현할 것입니다.

00:13:26.000 --> 00:13:44.000
제가 당신에게 주목하고 싶은 것은 수행이 비동기 함수이며 로그 작성 작업을 기다리고 있을 때 내가 여기서 하고 있는 것처럼 데이터베이스에 쓰는 것과 같은 비동기 작업을 하는 경우 이를 최대한 활용해야 한다는 것입니다.

00:13:44.000 --> 00:13:56.000
성능이 돌아오자마자, 시스템은 즉시 위젯 타임라인의 재장전을 시작하여 위젯의 콘텐츠를 업데이트할 수 있는 기회를 제공합니다.

00:13:56.000 --> 00:14:07.000
다시 말하지만, 수행에서 돌아오기 전에 업데이트된 위젯을 다시 로드하는 데 필요한 모든 정보를 유지해야 합니다.

00:14:07.000 --> 00:14:15.000
나는 그 음료를 에스프레소로 어렵게 코딩했지만, 물론, 우리는 특정 음료를 기록할 수 있기를 원한다.

00:14:15.000 --> 00:14:24.000
그렇게 하기 위해 우리는 @Parameter 속성 래퍼와 모든 매개 변수를 채우는 이니셜라이저로 저장된 속성을 추가할 수 있습니다.

00:14:24.000 --> 00:14:39.000
주석이 달린 저장된 속성만 유지되고 의도가 위젯 확장에서 수행될 때 사용할 수 있기 때문에 이 속성 래퍼를 사용하는 것이 중요합니다.

00:14:39.000 --> 00:14:48.000
이 의도를 호출하기 위해 버튼을 추가하기 전에, 저는 여기서 앱 의도를 사용하는 중요한 생태계 이점을 강조하고 싶습니다.

00:14:48.000 --> 00:15:02.000
내가 방금 정의한 이 앱 의도는 바로 가기와 Siri에서 사용할 수 있으므로, 여기서 정의하는 투자는 위젯을 넘어 사용자 경험에 배당금을 지불할 것입니다.

00:15:02.000 --> 00:15:06.000
그리고 이제 우리는 위젯에 버튼을 추가할 준비가 되었습니다.

00:15:06.000 --> 00:15:10.000
버튼을 누르고 있는 새로운 뷰를 만들어 봅시다.

00:15:10.000 --> 00:15:18.000
이 관점에서 저는 앱 의도를 취하는 이 버튼 이니셜라이저를 사용하고 있으므로, 방금 정의한 것을 전달할 수 있습니다.

00:15:18.000 --> 00:15:24.000
그리고 스페이서로 나머지 위젯에 이 보기를 추가해 봅시다.

00:15:24.000 --> 00:15:32.000
이제 우리는 모든 것을 갖추고 있습니다. 이것이 구축하고 실행하여 위젯에서 어떻게 작동하는지 봅시다.

00:15:32.000 --> 00:15:43.000
여기에 작은 팁: 실제로 위젯 확장을 위한 대상을 직접 빌드할 수 있으며 Xcode는 홈 화면에 바로 위젯을 설치할 것입니다.

00:15:43.000 --> 00:15:47.000
내 위젯에는 이제 내가 방금 정의한 버튼이 있다.

00:15:47.000 --> 00:15:52.000
내가 그것을 탭하면, 이 마지막 에스프레소 한 잔을 기록할 수 있다.

00:15:52.000 --> 00:16:00.000
하지만 위젯이 가능한 최고의 사용자 경험을 제공할 수 있도록 하고 싶은 추가 변경 사항이 하나 있습니다.

00:16:00.000 --> 00:16:06.000
앱 인텐트 실행이 완료되면, 위젯이 타임라인을 다시 로드하게 됩니다.

00:16:06.000 --> 00:16:12.000
이것은 작업에서 UI의 변화로 이어지는 작은 지연 시간을 도입할 수 있다.

00:16:12.000 --> 00:16:21.000
하지만 이 지연 시간은 Mac의 iPhone 위젯으로 더 두드러질 수 있으므로 우리는 즉시 해결책을 제공하고 있습니다.

00:16:21.000 --> 00:16:31.000
예를 들어, 내 위젯에서 카페인의 총량을 보여주는 값은 업데이트된 항목이 도착할 때까지 업데이트되지 않습니다.

00:16:31.000 --> 00:16:36.000
우리는 invalidatableContent 수정자로 이 보기에 주석을 달 수 있습니다.

00:16:36.000 --> 00:16:40.000
iPhone에서 Mac으로 이 위젯을 추가했습니다.

00:16:40.000 --> 00:16:44.000
버튼을 탭해 봅시다.

00:16:44.000 --> 00:16:54.000
카페인 양을 보여주는 보기는 업데이트가 올 때까지 그 값이 무효화되었음을 나타내는 시스템 효과를 보여준다.

00:16:54.000 --> 00:17:04.000
우리는 방금 버튼이 작동하는 것을 보았고 invalidatableContent 수정자를 사용하면 사용자가 대기 시간에 대한 인식을 개선하는 데 도움을 줄 수 있습니다.

00:17:04.000 --> 00:17:06.000
이 수정자를 현명하게 사용하세요.

00:17:06.000 --> 00:17:11.000
바뀔 수 있는 모든 단일 보기에 주석을 달 필요는 없습니다.

00:17:11.000 --> 00:17:19.000
사용자에게 올바른 기대치를 설정하기 위해 의미 있는 뷰와 함께 이 수정자를 사용해야 합니다.

00:17:19.000 --> 00:17:32.000
토글은 한 걸음 더 나아가 위젯 확장으로의 왕복을 기다릴 필요 없이 상호 작용할 때 프레젠테이션을 낙관적으로 업데이트할 것입니다.

00:17:32.000 --> 00:17:42.000
이것은 두 구성 모두에서 토글 스타일을 미리 렌더링하여 아카이브 시간에 자동으로 수행됩니다.

00:17:42.000 --> 00:17:53.000
자신만의 토글 스타일을 정의하는 경우, 스타일에서 구성 isOn 속성을 확인하고 이를 사용하여 모양을 전환하십시오.

00:17:53.000 --> 00:17:58.000
이것으로 상호 작용과 애니메이션에 대한 개요를 마칩니다.

00:17:58.000 --> 00:18:16.000
애니메이션과 상호 작용을 통해 위젯에 새로운 삶을 불어넣을 수 있는 기회를 갖게 되며, 이제 이 모든 새로운 위치에 있는 위젯을 통해 사용자가 어디에 있든 이 작고 즐거운 상호 작용을 가져올 수 있습니다.

00:18:16.000 --> 00:18:38.000
따라서 새로운 Xcode Preview API를 사용하여 위젯의 애니메이션을 미세 조정하고 앱에서 가장 중요한 작업을 살펴보고 위젯에 표시하여 사용자가 필요할 때 언제 어디서나 강력한 상호 작용을 제공합니다.

00:18:38.000 --> 00:18:39.000
고마워!

00:18:39.000 --> 23:59:59.000
♪ ♪

