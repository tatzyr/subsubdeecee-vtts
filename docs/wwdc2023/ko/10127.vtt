WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:16.000
안녕하세요 여러분, 저는 가우리 조그이고, 여기 애플의 금속 생태계 팀에서 일하고 있습니다.

00:00:16.000 --> 00:00:21.000
메탈을 사용하여 GPU 렌더러를 최적화하는 것에 대해 이야기하게 되어 기쁩니다.

00:00:21.000 --> 00:00:31.000
현대적인 디지털 콘텐츠 제작 애플리케이션과 게임 엔진은 콘텐츠 제작자가 3D 자산에 대한 자료를 대화식으로 만들고 수정할 수 있도록 합니다.

00:00:31.000 --> 00:00:37.000
런타임에 이러한 복잡하고 역동적인 재료를 다루는 몇 가지 일반적인 기술이 있다.

00:00:37.000 --> 00:00:47.000
일부 애플리케이션은 자료를 개별 셰이더로 컴파일하고 다른 애플리케이션은 우버 셰이더 또는 셰이더 가상 머신과 같은 데이터 기반 솔루션을 사용합니다.

00:00:47.000 --> 00:00:51.000
이러한 재료 중심의 워크플로우에는 두 가지 주요 성과 목표가 있다.

00:00:51.000 --> 00:00:57.000
자료 작성은 빠른 반복과 최고의 경험을 위해 반응해야 한다.

00:00:57.000 --> 00:01:05.000
렌더링 성능은 실시간 상호 작용과 효율적인 최종 프레임 렌더링을 위해 가능한 한 좋아야 합니다.

00:01:05.000 --> 00:01:11.000
블렌더 3D의 시연에서, 재료 편집은 반응이 좋다.

00:01:11.000 --> 00:01:21.000
사용자 인터페이스에서 재료 슬라이더를 수정하면, 결과는 셰이더 재컴파일로 인한 말더듬 없이 뷰포트에 즉시 표시됩니다.

00:01:21.000 --> 00:01:34.000
자료가 수정되면, 결과 렌더링 성능은 빠르고 상호 작용하여 콘텐츠 제작자가 작업 결과를 효율적으로 볼 수 있는 기능을 제공합니다.

00:01:34.000 --> 00:01:43.000
애플리케이션에서 반응적이고 성능이 뛰어난 워크플로우를 달성하기 위해, 주요 Metal 기능을 활용하고 Metal 모범 사례를 구현할 수 있습니다.

00:01:43.000 --> 00:01:59.000
메탈은 복잡한 셰이더의 성능을 극대화하여 비동기 컴파일을 활용하여 애플리케이션의 응답성을 유지하고, 동적 연결로 더 빠르게 컴파일하고, 새로운 메탈 컴파일러 옵션으로 컴퓨팅 셰이더를 조정할 수 있습니다.

00:01:59.000 --> 00:02:05.000
셰이더를 최적화하는 것이 성능의 열쇠입니다.

00:02:05.000 --> 00:02:11.000
우버 셰이더는 가능한 모든 재료를 렌더링하는 데 사용할 수 있는 길고 복잡한 셰이더의 예이다.

00:02:11.000 --> 00:02:17.000
이러한 유형의 셰이더는 가능한 조합을 위한 많은 가지를 가지고 있다.

00:02:17.000 --> 00:02:25.000
예술가들이 재료를 만들 때, 재료 매개 변수는 재료 셰이더에 의해 사용되는 금속 버퍼에 저장된다.

00:02:25.000 --> 00:02:35.000
이 버퍼는 매개 변수를 변경할 때 업데이트되지만, 재컴파일은 필요하지 않습니다.

00:02:35.000 --> 00:02:39.000
이 접근 방식은 훌륭한 반응형 저작 경험을 제공한다.

00:02:39.000 --> 00:02:48.000
그러나, 우버 셰이더는 가능한 모든 옵션을 고려해야 하기 때문에 최적이 아니다.

00:02:48.000 --> 00:02:55.000
가장 최적의 셰이더 변형을 만들려면, 기능 상수가 있는 금속 전문화를 사용해야 합니다.

00:02:55.000 --> 00:03:02.000
메탈 셰이더에서 함수 상수를 선언하고 변경될 때 런타임에 값을 설정하기만 하면 됩니다.

00:03:02.000 --> 00:03:09.000
재료 버퍼 내용물은 단순히 셰이더 파이프라인 상태에서 상수가 되며, 동적 분기는 제거됩니다.

00:03:09.000 --> 00:03:13.000
특수 재료는 당신에게 최고의 성능을 제공합니다.

00:03:13.000 --> 00:03:21.000
이것은 블렌더 3D, 원더러와 트리 크리처의 두 가지 일반적인 테스트 자산의 실시간 성능 데이터의 비교입니다.

00:03:21.000 --> 00:03:28.000
첫 번째는 우버 셰이더를 사용하는 장면의 초당 프레임의 기본 성능이다.

00:03:28.000 --> 00:03:34.000
두 번째는 훨씬 더 빠르게 작동하는 기능 상수를 가진 특수 셰이더 접근 방식이다.

00:03:34.000 --> 00:03:45.000
가장 빠른 특수 셰이더 변형을 만들기 위해, 기능 상수를 사용하여 사용하지 않는 기능을 비활성화하고 분기를 제거하십시오.

00:03:45.000 --> 00:03:54.000
우버 셰이더는 기능을 활성화하고 비활성화하기 위해 런타임에 조건부 브랜치를 수행하는 버퍼의 재료 매개 변수를 쿼리합니다.

00:03:54.000 --> 00:03:59.000
함수 상수를 사용하면 재료 기능당 하나의 상수를 선언합니다.

00:03:59.000 --> 00:04:09.000
이제 기능 코드 경로의 동적 브랜치는 함수 상수로 대체되어 사용되지 않는 모든 코드를 제거합니다.

00:04:09.000 --> 00:04:14.000
여기 함수 상수를 사용하는 동일한 우버 셰이더가 있습니다.

00:04:14.000 --> 00:04:20.000
메탈 컴파일러는 이것들을 상수 부울로 접고 사용하지 않는 코드를 제거할 수 있다.

00:04:20.000 --> 00:04:29.000
거짓으로 해결되는 브랜치 표현식은 최적화되어 진정한 브랜치만 남게 됩니다.

00:04:29.000 --> 00:04:34.000
사용하지 않는 모든 제어 흐름이 최적화되어 있다.

00:04:34.000 --> 00:04:40.000
특수 셰이더는 이제 재료 데이터를 쿼리할 필요가 없으며, 훨씬 간단한 제어 흐름을 가지고 있습니다.

00:04:40.000 --> 00:04:48.000
메모리 로드와 브랜치가 제거되어 런타임 성능이 빨라졌습니다.

00:04:48.000 --> 00:04:52.000
기능 전문화는 또한 상수 접힘에 도움이 된다.

00:04:52.000 --> 00:04:58.000
변하지 않는 재료 매개 변수는 상수로 대체됩니다.

00:04:58.000 --> 00:05:03.000
이 예시 자료는 금속 버퍼의 입력 매개 변수 모음을 사용합니다.

00:05:03.000 --> 00:05:09.000
매개 변수는 색상, 무게, 광택 색상 등이 될 수 있다.

00:05:09.000 --> 00:05:16.000
재료 생성 시간에, 이러한 정적 매개 변수는 함수 상수로 대체될 수 있다.

00:05:16.000 --> 00:05:23.000
함수 상수는 버퍼 읽기 없이 가장 최적의 코드를 생성합니다.

00:05:23.000 --> 00:05:30.000
호스트 측에서는 특수 파이프라인 상태를 만들 때 기능 상수 값이 제공됩니다.

00:05:30.000 --> 00:05:37.000
재료 매개 변수 구조는 재료에 대해 일정한 모든 매개 변수를 나타내는 데 사용할 수 있습니다.

00:05:37.000 --> 00:05:44.000
IsGlossy는 광택을 제어하는 부울 재료 기능 플래그의 예이다.

00:05:44.000 --> 00:05:50.000
MaterialColor는 색상을 설명하는 데 사용되는 벡터 매개 변수의 예입니다.

00:05:50.000 --> 00:06:02.000
특수한 파이프라인 상태 객체를 만들려면, MetalFunctionConstantValues 세트를 반복하고 setConstantValue를 사용하여 값을 삽입하십시오.

00:06:02.000 --> 00:06:05.000
그런 다음 평소와 같이 렌더링 파이프라인을 만드세요.

00:06:05.000 --> 00:06:16.000
유일한 차이점은 조각 함수를 만들 때 constantValues와 함께 newFunctionWithName의 변형을 사용한다는 것입니다.

00:06:16.000 --> 00:06:19.000
마지막으로, 파이프라인 상태 객체를 만드세요.

00:06:19.000 --> 00:06:26.000
결과 셰이더는 이 재료의 가장 최적의 성능 변형이다.

00:06:26.000 --> 00:06:35.000
항상 Xcode의 GPU 디버거 성능 섹션을 사용하여 기능 상수 사용의 영향을 확인하십시오.

00:06:35.000 --> 00:06:42.000
원래 우버 셰이더는 많은 수의 ALU 지침과 많은 양의 유출을 보여준다.

00:06:42.000 --> 00:06:46.000
메모리 대기 횟수도 많다.

00:06:46.000 --> 00:06:51.000
전문적인 접근 방식은 ALU와 유출에 즉각적인 구제를 제공한다.

00:06:51.000 --> 00:06:55.000
이것은 데드 코드 제거와 상수 폴딩 때문이다.

00:06:55.000 --> 00:07:01.000
또한, 메모리 대기 횟수는 상당히 적다.

00:07:01.000 --> 00:07:11.000
런타임 셰이더 실행 비용에서 원래 우버 셰이더를 관찰하면서, GPU는 메모리 대기에 상당한 시간을 보내고 있다.

00:07:11.000 --> 00:07:23.000
대조적으로, 전문적인 접근 방식은 메모리 대기에 훨씬 적은 시간을 소비하여 다른 효율성 이점과 함께 더 생산적인 ALU 활용을 가능하게 한다.

00:07:23.000 --> 00:07:31.000
GPU 디버거 타임라인 보기에서 우버 셰이더를 사용하여 재료 패스를 렌더링하는 데 58밀리초가 걸립니다.

00:07:31.000 --> 00:07:36.000
그리고 특수 버전으로 렌더링하는 데 12.5밀리초밖에 걸리지 않습니다.

00:07:36.000 --> 00:07:40.000
그건 꽤 극적인 개선이야.

00:07:40.000 --> 00:07:52.000
재료 전문화에는 런타임 셰이더 컴파일이 필요하며, 이러한 특수 재료가 생성될 때까지 차단하고 기다리면 종종 히치킹이 발생합니다.

00:07:52.000 --> 00:08:06.000
Metal 비동기 컴파일 API를 사용하면 일반 우버 셰이더를 사용하고 백그라운드에서 특수 버전을 생성하면서 사용자 경험을 인터랙티브하고 반응형으로 유지할 수 있습니다.

00:08:06.000 --> 00:08:11.000
비동기 파이프라인 상태 생성을 선택하려면, 완료 핸들러를 제공하십시오.

00:08:11.000 --> 00:08:18.000
이러한 통화는 즉시 반환되므로 사용자 경험을 대화형 및 반응형으로 유지할 수 있습니다.

00:08:18.000 --> 00:08:28.000
특수 파이프라인 상태가 준비되면 완료 핸들러가 호출되며, 즉시 최적의 셰이더로 전환할 수 있습니다.

00:08:28.000 --> 00:08:31.000
이것은 비동기 재료 워크플로우의 다이어그램이다.

00:08:31.000 --> 00:08:38.000
기본적으로, 재료가 아직 전문화되지 않았을 때, 당신은 우버 셰이더를 사용합니다.

00:08:38.000 --> 00:08:44.000
동시에, 메탈은 배경에서 특수 셰이더를 컴파일한다.

00:08:44.000 --> 00:08:51.000
이것이 완료되면, 빠른 특수 재료로 우버 셰이더를 바꿀 수 있습니다.

00:08:51.000 --> 00:08:58.000
런타임 메탈 셰이더 컴파일은 균형 잡힌 수준의 병렬 처리를 제공하도록 설계되었습니다.

00:08:58.000 --> 00:09:08.000
그러나, 최신 콘텐츠 제작 애플리케이션은 다중 재료 편집 워크플로우를 제공해야 하며, 그 결과 많은 셰이더 재컴파일이 발생한다.

00:09:08.000 --> 00:09:16.000
그러한 무거운 저작 요구를 돕기 위해, 당신은 메탈에게 셰이더 컴파일 병렬성을 극대화하도록 요청할 수 있습니다.

00:09:16.000 --> 00:09:24.000
금속 장치는 macOS13.3에서 should-Maximize-Concurrent-Compilation이라는 새로운 속성을 가지고 있다.

00:09:24.000 --> 00:09:30.000
예로 설정하면, 메탈 컴파일러는 CPU 코어를 최대한 활용할 것입니다.

00:09:30.000 --> 00:09:37.000
동시 편집을 극대화하는 것은 다중 재료 저작 워크플로우에 정말 좋습니다.

00:09:37.000 --> 00:09:44.000
추가 컴파일러 작업을 사용할 수 있으므로, 특수 재료 변형을 훨씬 더 빨리 사용할 수 있습니다.

00:09:44.000 --> 00:09:46.000
이 모든 것이 실제로 작동하는 방식입니다.

00:09:46.000 --> 00:09:58.000
재료 매개 변수가 변경되면, 재료의 현재 특수 변형이 무효화되며, 저작 유체를 유지하기 위해 우버 셰이더를 사용하는 것으로 다시 전환됩니다.

00:09:58.000 --> 00:10:07.000
새로운 비동기 작업이 대기 중이며 완료되면 전문 자료가 참여하면 상당한 성능 개선을 관찰할 수 있습니다.

00:10:07.000 --> 00:10:16.000
대부분의 최신 앱은 매우 복잡한 재료를 가지고 있으므로, 특수 변형이 준비되는 데 상당한 시간이 걸릴 수 있습니다.

00:10:16.000 --> 00:10:25.000
Metal의 동적 라이브러리는 유틸리티 기능을 사전 컴파일하고 전체 재료 컴파일 시간을 줄이는 데 사용할 수 있습니다.

00:10:25.000 --> 00:10:31.000
기능 그룹을 별도의 동적 라이브러리로 분할하여 이를 수행할 수 있습니다.

00:10:31.000 --> 00:10:37.000
더 빠른 런타임 컴파일을 위해, 유틸리티 라이브러리는 오프라인으로 사전 컴파일될 수 있다.

00:10:37.000 --> 00:10:43.000
그리고 당신은 런타임에 훨씬 적은 코드를 컴파일하게 됩니다.

00:10:43.000 --> 00:10:47.000
만약 내가 이전 우버 셰이더를 가지고 그것을 딜립으로 나눈다면.

00:10:47.000 --> 00:10:51.000
한 가지 접근 방식은 그것을 일반적인 기능 그룹으로 나누는 것이다.

00:10:51.000 --> 00:10:58.000
이 경우, 하나의 수학 유틸리티 라이브러리와 조명 기능을 위한 다른 라이브러리.

00:10:58.000 --> 00:11:04.000
연결에 기능 기호를 표시하려면, "기본" 가시성을 할당합니다.

00:11:04.000 --> 00:11:12.000
기호는 또한 "숨겨진"에 가시성을 할당하여 외부 프로그램에서 숨길 수 있습니다.

00:11:12.000 --> 00:11:17.000
금속 장치가 동적 라이브러리를 지원하는지 확인할 수 있는 두 가지 속성이 있습니다.

00:11:17.000 --> 00:11:24.000
렌더링 파이프라인의 경우 Metal 장치의 supportsRenderDynamicLibraries 속성을 사용해야 합니다.

00:11:24.000 --> 00:11:30.000
이것은 현재 Apple6 이상의 GPU 제품군이 있는 장치에서 사용할 수 있습니다.

00:11:30.000 --> 00:11:36.000
컴퓨팅 파이프라인의 경우 supportsDynamicLibraries 속성을 쿼리해야 합니다.

00:11:36.000 --> 00:11:43.000
이것은 Apple6 이상과 대부분의 Mac2 GPU 제품군에서 사용할 수 있습니다.

00:11:43.000 --> 00:11:53.000
기존 메탈 라이브러리에서 동적 라이브러리를 만들려면, newDynamicLibrary를 호출하고 메탈 라이브러리로 전달하기만 하면 됩니다.

00:11:53.000 --> 00:12:03.000
URL에서 만들려면, newDynamicLibraryWithURL 메소드를 호출하고 저장된 동적 라이브러리의 경로를 제공하십시오.

00:12:03.000 --> 00:12:08.000
금속 컴파일러 도구 체인을 사용하여 동적 라이브러리를 오프라인으로 미리 컴파일할 수 있습니다.

00:12:08.000 --> 00:12:15.000
런타임에 미리 컴파일된 동적 라이브러리를 로드할 때, 컴파일은 완전히 피할 수 있다.

00:12:15.000 --> 00:12:26.000
연결 단계에서 dylibs를 지정하려면: 파이프라인 설명자의 preloadedLibraries 매개 변수에 Metal Dynamic Library Objects 배열을 전달하십시오.

00:12:26.000 --> 00:12:35.000
다른 셰이더 라이브러리를 컴파일할 때 금속 컴파일 옵션을 통해 이 동적 라이브러리 배열을 제공하는 옵션도 있습니다.

00:12:35.000 --> 00:12:42.000
유틸리티 코드의 많은 부분을 동적 라이브러리로 옮기면 런타임 컴파일이 크게 단축됩니다.

00:12:42.000 --> 00:12:52.000
그리고 마지막으로, 컴파일러 옵션 튜닝은 최종 생산 품질 렌더링에서 경로 추적과 같은 컴퓨팅 사례에 정말 중요합니다.

00:12:52.000 --> 00:12:58.000
그리고 최종 렌더링에서 최고의 성능을 얻을 수 있는 한 가지 추가 금속 기능이 있습니다.

00:12:58.000 --> 00:13:10.000
금속 컴파일러 옵션과 점유 힌트를 사용하면 동적 연결로 작업할 때 이러한 컴퓨팅 커널의 성능을 조정할 수 있습니다.

00:13:10.000 --> 00:13:17.000
모든 GPU 워크로드에는 분석과 평가가 필요한 성능 스윗 스팟이 있다.

00:13:17.000 --> 00:13:26.000
원하는 GPU 점유율을 목표로 하는 Metal API가 있으며, 현재 동적 라이브러리에서도 사용할 수 있습니다.

00:13:26.000 --> 00:13:33.000
이것은 원래 코드나 알고리즘을 변경하지 않고도 기존 워크로드의 성능을 잠금 해제할 수 있습니다.

00:13:33.000 --> 00:13:45.000
성능 특성이 GPU 아키텍처에 따라 다를 수 있기 때문에 장치별로 튜닝을 수행해야 한다는 점은 주목할 가치가 있습니다.

00:13:45.000 --> 00:13:56.000
Metal 컴퓨팅 파이프라인 설명자 속성을 사용하면 Max-Total-Threads-Per-Threadgroup 값을 지정하여 원하는 점유 수준을 표현할 수 있습니다.

00:13:56.000 --> 00:14:02.000
값이 높을수록, 컴파일러가 목표로 하는 점유율이 높아집니다.

00:14:02.000 --> 00:14:13.000
이제 동적 라이브러리를 위한 이 새로운 Metal-Compile-Options 속성을 사용하여 파이프라인 상태 객체가 원하는 점유 수준을 일치시킬 수 있습니다.

00:14:13.000 --> 00:14:24.000
Max-Total-Threads-Per-Threadgroup은 iOS 16.4 및 macOS 13.3의 MetalCompileOptions에서 사용할 수 있습니다.

00:14:24.000 --> 00:14:33.000
이제 최적의 성능을 위해 Metal 동적 라이브러리를 조정하면서 파이프라인 상태 개체가 원하는 점유를 간단히 일치시킬 수 있습니다.

00:14:33.000 --> 00:14:42.000
블렌더 사이클 셰이딩 및 교차 컴퓨팅 커널 성능의 이 그래프는 Max-Total-Threads-Per-Threadgroup 변경의 영향을 보여줍니다.

00:14:42.000 --> 00:14:48.000
그것은 파이프라인 상태 객체와 딜리브에 대해 변경된 유일한 변수였다.

00:14:48.000 --> 00:14:53.000
이 경우, 커널이 최선을 다하는 스윗 스팟이 있다.

00:14:53.000 --> 00:15:03.000
각 워크로드와 장치는 고유하며 Max-Total-Threads-Per-Threadgroup의 최적 값은 커널의 특성에 따라 다릅니다.

00:15:03.000 --> 00:15:10.000
최적의 값이 반드시 GPU가 지원하는 스레드 그룹당 최대 스레드 수는 아닙니다.

00:15:10.000 --> 00:15:16.000
코드에서 사용하고 굽고 싶은 최적의 값을 찾기 위해 커널을 실험하세요.

00:15:16.000 --> 00:15:24.000
여기 블렌더 사이클 셰이딩 커널이 있습니다. 컴파일러 통계는 커널이 매우 복잡하다는 것을 보여줍니다.

00:15:24.000 --> 00:15:28.000
실제 런타임에 영향을 미치는 몇 가지 매개 변수가 있습니다.

00:15:28.000 --> 00:15:34.000
유출의 양, 사용된 레지스터의 수, 그리고 메모리 로드와 같은 다른 작업.

00:15:34.000 --> 00:15:44.000
Max-Total-Threads-Per-Threadgroup을 조정하면 목표 점유율을 변경하고 성능 스윗 스팟을 찾을 수 있습니다.

00:15:44.000 --> 00:15:55.000
스윗 스팟을 찾은 후, 유출은 약간 증가하지만, 전반적인 점유율 증가는 훨씬 더 나은 커널 성능으로 이어졌다.

00:15:55.000 --> 00:16:10.000
블렌더 3D 3.5 내의 사이클 경로 추적기는 이제 금속에 잘 최적화되어 있으며, 오늘 제가 다룬 모든 모범 사례를 사용합니다.

00:16:10.000 --> 00:16:38.000
기능 전문화를 사용하여 크고 복잡한 셰이더의 셰이더 성능을 극대화하고, 비동기 컴파일을 사용하여 백그라운드에서 최적화된 셰이더를 생성하는 동안 애플리케이션의 반응을 유지하고, 런타임에 더 빠른 컴파일을 위한 동적 연결을 활성화하고, 최적의 성능을 얻기 위해 새로운 메탈 컴파일러 옵션으로 컴퓨팅 커널을 조정하십시오.

00:16:38.000 --> 00:16:48.000
Apple GPU의 컴퓨팅 워크로드를 확장하고 Metal에서 더 많은 컴파일 워크플로우를 발견하는 방법을 배울 수 있는 이전 세션을 확인하십시오.

00:16:48.000 --> 00:16:50.000
봐줘서 고마워.

00:16:50.000 --> 23:59:59.000
♪ ♪

