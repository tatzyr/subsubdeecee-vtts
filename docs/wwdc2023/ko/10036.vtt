WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:11.000
앨리슨: 안녕하세요, 여러분.

00:00:11.000 --> 00:00:14.000
제 이름은 앨리슨이고, 저는 접근성 엔지니어입니다.

00:00:14.000 --> 00:00:21.000
오늘 우리는 당신의 앱에 더 쉽게 접근할 수 있는 흥미진진한 새로운 방법에 대해 이야기할 것입니다.

00:00:21.000 --> 00:00:30.000
애플에서 접근성은 모든 사람이 기술에 접근할 자격이 있다고 믿기 때문에 우리가 만드는 모든 것의 필수적인 부분이다.

00:00:30.000 --> 00:00:36.000
우리는 당신이 당신의 앱에 쉽게 접근할 수 있기를 바랍니다.

00:00:36.000 --> 00:00:43.000
지난 한 해 동안, 우리는 모든 사람이 당신의 앱에서 가능한 최고의 경험을 할 수 있도록 여러 가지 개선 사항을 위해 노력해 왔습니다.

00:00:43.000 --> 00:00:50.000
이 세션에서, 우리는 사람들이 새롭고 흥미로운 방식으로 앱과 상호 작용할 수 있는 API를 탐구할 것입니다.

00:00:50.000 --> 00:00:57.000
다음으로, 우리는 SwiftUI 앱에서 콘텐츠에 대한 접근성 비주얼을 개선하는 방법에 대해 논의할 것입니다.

00:00:57.000 --> 00:01:03.000
마지막으로, 우리는 UIKit에서 접근성 속성을 최신 상태로 유지하는 더 나은 방법을 배울 것입니다.

00:01:03.000 --> 00:01:06.000
접근성 향상에 대해 이야기하는 것으로 시작합시다.

00:01:06.000 --> 00:01:09.000
나는 사진 편집 앱 작업을 하고 있다.

00:01:09.000 --> 00:01:15.000
내 앱을 사용하면 라이브러리나 카메라의 사진에 멋진 이미지 수정을 추가할 수 있습니다.

00:01:15.000 --> 00:01:24.000
다른 필터를 적용하거나, 사진 색조 색상을 변경하거나, 앱의 피아노 키보드를 사용하여 이미지와 페어링할 수 있는 사용자 지정 사운드를 만들 수 있습니다.

00:01:24.000 --> 00:01:29.000
앱에 통합할 수 있는 몇 가지 접근성 개선 사항에 대해 논의해 봅시다.

00:01:29.000 --> 00:01:36.000
내 사진 앱의 필터 페이지에는 켜기 및 끄기 상태가 있는 사용자 지정 버튼이 있습니다.

00:01:36.000 --> 00:01:41.000
"필터" 스위치 버튼을 사용하면 이미지 필터를 켜고 끌 수 있습니다.

00:01:41.000 --> 00:01:54.000
시스템은 이 사용자 지정 UI에 대한 올바른 접근성 힌트와 제목을 알지 못하며, 우리는 다른 시스템 토글과 일치하는 접근성 경험을 제공하고 싶습니다.

00:01:54.000 --> 00:01:59.000
이것은 새로운 접근성 특성인 isToggle이 도움이 되는 곳이다.

00:01:59.000 --> 00:02:02.000
우리는 필터 버튼을 나타내는 구조체가 있다.

00:02:02.000 --> 00:02:08.000
구조체의 본문에서, 우리는 누를 때 필터를 전환하는 버튼을 만듭니다.

00:02:08.000 --> 00:02:13.000
버튼의 색상은 필터 상태 변수에 따라 업데이트됩니다.

00:02:13.000 --> 00:02:19.000
우리는 accessibilityAddTraits 수정자의 필터 버튼에 isToggle 특성을 추가할 것입니다.

00:02:19.000 --> 00:02:25.000
isToggle은 적절한 접근성 힌트와 "스위치 버튼" 설명을 제공합니다.

00:02:25.000 --> 00:02:27.000
VoiceOver: 필터, 스위치 버튼.

00:02:27.000 --> 00:02:32.000
설정을 전환하려면 두 번 탭하세요.

00:02:32.000 --> 00:02:35.000
앨리슨: 새로운 토글 특성은 UIKit에서도 사용할 수 있습니다.

00:02:35.000 --> 00:02:40.000
viewDidLoad 방법에서, 우리는 버튼 보기를 설정했다.

00:02:40.000 --> 00:02:48.000
그런 다음, 우리는 .toggleButton을 포함하도록 버튼의 accessibilityTraits 속성을 설정했습니다.

00:02:48.000 --> 00:02:57.000
사진 필터 앱에서 사진 보기가 로드되고 있다는 것을 사람들에게 알리기 위해 사진 탐색 모음 버튼에 새로운 공지를 추가하고 싶습니다.

00:02:57.000 --> 00:03:02.000
접근성 알림은 우리가 이것을 하는 데 도움이 될 수 있는 새로운 API이다.

00:03:02.000 --> 00:03:14.000
접근성 알림은 앱에서 보조 기술을 사용하여 누군가에게 정보를 전달하기 위한 공지를 만드는 통합된 멀티 플랫폼 방법을 제공합니다.

00:03:14.000 --> 00:03:22.000
SwiftUI, UIKit 및 AppKit을 실행하는 앱에 대한 접근성 알림을 만들 수 있습니다.

00:03:22.000 --> 00:03:32.000
AccessibilityNotification을 사용하면 Swift의 기본 방식으로 공지, 레이아웃 변경, 화면 변경 및 페이지 스크롤 알림을 보낼 수 있습니다.

00:03:32.000 --> 00:03:37.000
사진 도구 모음 버튼을 누르면, 공지를 게시하고 싶습니다.

00:03:37.000 --> 00:03:39.000
VoiceOver: 사진, 버튼.

00:03:39.000 --> 00:03:43.000
사진. 사진 보기 불러오는 중.

00:03:43.000 --> 00:03:47.000
앨리슨: 우리는 도구 모음 버튼에 대한 작업에 공지를 게시할 수 있습니다.

00:03:47.000 --> 00:03:57.000
공지를 만들기 위해, "Loading Photos View"를 문자열 매개 변수로 사용하여 AccessibilityNotification.Announcement를 사용할 수 있습니다.

00:03:57.000 --> 00:04:04.000
앱에서, 나는 또한 카메라 내비게이션 바 버튼을 누를 때 세 개의 공지를 만들고 싶다.

00:04:04.000 --> 00:04:11.000
첫 번째 발표인 "오픈 카메라"와 세 번째 발표인 "카메라 액티브"가 가장 중요하다.

00:04:11.000 --> 00:04:15.000
발표를 위해 VoiceOver의 현재 음성 패턴을 살펴봅시다.

00:04:15.000 --> 00:04:20.000
두 번째 발표인 "카메라 로딩"이 "카메라 열기"를 어떻게 방해하는지 주목하세요.

00:04:20.000 --> 00:04:24.000
VoiceOver: 카메라, 버튼.

00:04:24.000 --> 00:04:26.000
끝났어. 오픈--카메라--카메라 활성.

00:04:26.000 --> 00:04:37.000
앨리슨: 이제 SwiftUI와 UIKit에서 발표의 우선 순위를 설정할 수도 있으며, 이를 통해 보조 기술로 대기 중인 발표의 중요성을 설정할 수 있습니다.

00:04:37.000 --> 00:04:44.000
이것은 사람들이 들어야 하는 발표와 제 시간에 말하지 않으면 무시할 수 있는 발표에 대해 더 잘 제어할 수 있게 해준다.

00:04:44.000 --> 00:04:53.000
세 가지 발표 우선 순위 중 하나를 사용하여 이 정보의 중요성을 지정할 수 있습니다: 높음, 기본값 및 낮음.

00:04:53.000 --> 00:05:00.000
우선 순위가 높은 발표는 다른 연설을 방해할 수 있으며 일단 시작되면 중단될 수 없습니다.

00:05:00.000 --> 00:05:07.000
기본 우선 순위 발표는 기존 연설을 중단할 수 있지만 새로운 연설이 시작되면 중단될 수 있습니다.

00:05:07.000 --> 00:05:14.000
새로운 발표가 시작되지 않았다면, 다른 연설이 완료되었을 때 우선 순위가 낮은 발표가 대기하고 발표된다.

00:05:14.000 --> 00:05:20.000
사진 앱에서, 우리는 중단 문자열을 수정하기 위해 발표 우선 순위를 사용할 수 있습니다.

00:05:20.000 --> 00:05:24.000
우리는 귀속된 문자열로 만든 세 가지 발표가 있다.

00:05:24.000 --> 00:05:31.000
SwiftUI에서, 우리는 accessibilitySpeechAnnouncementPriority 문자열 속성에 우선 순위를 설정할 것입니다.

00:05:31.000 --> 00:05:38.000
우리의 두 번째 발표인 "카메라 로딩"은 가장 중요하지 않으므로 우선 순위가 낮습니다.

00:05:38.000 --> 00:05:45.000
마지막 발표인 "카메라 액티브"가 가장 중요하기 때문에, 우리는 그것이 높은 우선순위를 갖기를 바랍니다.

00:05:45.000 --> 00:05:50.000
다음으로, 우리는 접근성 알림에 기인된 문자열을 전달할 것입니다.

00:05:50.000 --> 00:05:57.000
먼저, 우리는 기본 우선순위 발표, 낮은 우선순위, 그리고 높은 우선순위를 발송할 것이다.

00:05:57.000 --> 00:06:07.000
이제 낮은 우선 순위 발표가 기본 우선 순위 발표를 방해하지 않는 반면, 높은 우선 순위 발표는 기본 및 낮은 발표를 방해하는 방법에 주목하십시오.

00:06:07.000 --> 00:06:10.000
VoiceOver: 카메라, 버튼.

00:06:10.000 --> 00:06:13.000
끝났어. 열기 카메라 - 카메라 활성화.

00:06:13.000 --> 00:06:16.000
앨리슨: 우리는 UIKit에서 동일한 발표 순서를 달성할 수 있습니다.

00:06:16.000 --> 00:06:21.000
우리는 발표 우선 순위를 NSAttributedString 키 값 쌍으로 설정했습니다.

00:06:21.000 --> 00:06:31.000
우리는 주요 UIAccessibilitySpeechAttribute AnnouncementPriority를 사용하고 값을 적절한 UIAccessibilityPriority로 설정합니다.

00:06:31.000 --> 00:06:35.000
그런 다음 속성 문자열 이니셜라이저에 속성을 전달합니다.

00:06:35.000 --> 00:06:41.000
앱으로 돌아가면, 사람들이 물리적으로 만지거나 꼬집어 확대 및 축소할 수 있는 이미지 보기가 있습니다.

00:06:41.000 --> 00:06:48.000
보조 기술을 켜면, 이 물리적 터치나 꼬집기 제스처는 달성하기 어려울 수 있다.

00:06:48.000 --> 00:06:55.000
이제 접근성 확대/축소 동작을 통해 사람들은 보조 기술이 활성화되면 UI 요소를 확대 및 축소할 수 있습니다.

00:06:55.000 --> 00:06:58.000
우리는 이미지에 줌 동작을 추가할 것이다.

00:06:58.000 --> 00:07:03.000
이미지는 ZoomingImageView 구조체의 본문에 있습니다.

00:07:03.000 --> 00:07:07.000
우리는 먼저 accessibilityZoomAction 수정자를 추가합니다.

00:07:07.000 --> 00:07:16.000
그런 다음, 줌 동작의 방향에 따라, 우리는 콘텐츠를 확대하거나 축소하고 접근성 알림 공지를 게시할 것입니다.

00:07:16.000 --> 00:07:20.000
이제 이러한 변경 사항으로 VoiceOver의 줌 기능을 살펴봅시다.

00:07:20.000 --> 00:07:22.000
VoiceOver: 이미지 보기 확대/축소, 이미지.

00:07:22.000 --> 00:07:24.000
줌.

00:07:24.000 --> 00:07:27.000
2배 줌. 3배 줌.

00:07:27.000 --> 00:07:30.000
4배 줌. 3배 줌.

00:07:30.000 --> 00:07:33.000
앨리슨: 우리는 또한 UIKit에 줌 특성과 동작을 추가할 수 있습니다.

00:07:33.000 --> 00:07:37.000
우리는 먼저 이미지 뷰를 포함하는 줌 뷰를 만들 것이다.

00:07:37.000 --> 00:07:43.000
다음으로, 우리는 이미지 특성과 함께 줌 뷰에 supportsZoom 특성을 추가할 것입니다.

00:07:43.000 --> 00:07:54.000
그런 다음 accessibilityZoomInAtPoint와 accessibilityZoomOutAtPoint를 구현하며, 각각은 확대/축소 성공 또는 실패를 나타내기 위해 부울을 반환합니다.

00:07:54.000 --> 00:08:01.000
이러한 각 방법에서, 우리는 줌 스케일을 업데이트하고 줌 변경을 나타내기 위해 공지를 게시합니다.

00:08:01.000 --> 00:08:09.000
이미지 필터 앱에서, 우리는 또한 작은 피아노 키를 연주하여 이미지에 추가할 짧은 사운드를 만들 수 있습니다.

00:08:09.000 --> 00:08:13.000
사람들은 키를 사용하여 이미지에 대한 사용자 지정 톤을 만들 수 있습니다.

00:08:13.000 --> 00:08:23.000
내가 톤을 만들려고 할 때 이 소리들로 현재의 보이스오버 경험을 살펴봅시다.

00:08:23.000 --> 00:08:48.000
VoiceOver는 키 라벨을 말하고 요소를 만질 때마다 VoiceOver 활성화 사운드를 재생하여 키를 연속적으로 빠르게 누르기가 어렵습니다.

00:08:48.000 --> 00:08:58.000
일반적으로 VoiceOver는 안전한 탐색 경험을 제공하지만, 때때로 사람들은 앱을 제대로 사용하기 위해 앱과 직접 상호 작용해야 합니다.

00:08:58.000 --> 00:09:05.000
우리 앱의 경우, 사람들이 여분의 음성과 소리 없이 피아노 키를 직접 만질 수 있다면 훨씬 더 좋을 것이다.

00:09:05.000 --> 00:09:13.000
이것은 우리의 관점에서 allowsDirectInteraction이라는 이름의 직접 접촉 특성을 채택하기에 좋은 시기이다.

00:09:13.000 --> 00:09:23.000
접근성 직접 터치 영역을 사용하면 VoiceOver 제스처가 앱으로 직접 전달되는 화면 영역을 지정할 수 있습니다.

00:09:23.000 --> 00:09:30.000
기본 상태에서, VoiceOver는 직접 터치 요소의 내용을 말하고 활성화합니다.

00:09:30.000 --> 00:09:42.000
하지만 우리 앱의 경우, 누군가가 피아노 키를 만질 때 VoiceOver가 침묵하여 피아노 핵심 요소를 먼저 활성화하지 않고도 즉시 소리를 들을 수 있다면 좋을 것입니다.

00:09:42.000 --> 00:09:50.000
allowsDirectInteraction 특성 외에도, 이제 지원될 두 가지 새로운 다이렉트 터치 옵션이 있습니다.

00:09:50.000 --> 00:10:00.000
먼저, 앱이 자체 오디오 피드백을 만들 수 있도록 직접 터치 영역을 터치할 때 VoiceOver가 무음인지 확인하기 위해 silentOnTouch를 지정할 수 있습니다.

00:10:00.000 --> 00:10:11.000
둘째, 직접 터치 영역을 만들기 위해 requiresActivation을 지정할 수 있습니다. 터치 패스스루가 발생하기 전에 요소를 활성화하기 위해 VoiceOver가 필요합니다.

00:10:11.000 --> 00:10:15.000
이것은 KeyboardKeyView의 코드 스니펫입니다.

00:10:15.000 --> 00:10:19.000
각 키는 지정된 소리를 재생하는 직사각형이다.

00:10:19.000 --> 00:10:29.000
VoiceOver가 매번 톤을 통해 말하는 문제를 해결하기 위해, 우리는 버튼이 터치 시 무음으로 설정하도록 직접 터치 옵션을 설정했습니다.

00:10:29.000 --> 00:10:37.000
이제 VoiceOver가 VoiceOver의 음성 간섭 없이 키 버튼에 도달하면 올바른 톤이 재생됩니다.

00:10:37.000 --> 00:10:47.000
우리는 또한 UIKit에 새로운 다이렉트 터치 옵션을 추가할 수 있습니다.

00:10:47.000 --> 00:10:51.000
우리는 키 버튼을 UIButton으로 만들 수 있습니다.

00:10:51.000 --> 00:10:56.000
다음으로, 우리는 allowsDirectInteraction 접근성 특성을 추가할 것이다.

00:10:56.000 --> 00:11:02.000
이 특성은 UIKit에서 접근성 직접 터치 옵션을 설정할 때 필요합니다.

00:11:02.000 --> 00:11:08.000
마지막으로, 우리는 accessibilityDirectTouchOptions를 위한 silentOnTouch 옵션을 추가할 것입니다.

00:11:08.000 --> 00:11:20.000
접근성 토글 특성, 발표 우선 순위, 줌 특성 및 직접 터치 옵션을 사용하면 보조 기술이 SwiftUI 및 UIKit 앱과 상호 작용하는 방식을 더 잘 제어할 수 있습니다.

00:11:20.000 --> 00:11:26.000
다음으로, SwiftUI의 접근성 콘텐츠 모양 종류에 대해 이야기해 봅시다.

00:11:26.000 --> 00:11:34.000
이 종류는 접근성 요소의 경로를 설정하고 화면에서 접근성 요소의 모양을 제어합니다.

00:11:34.000 --> 00:11:40.000
이전에, 상호 작용 콘텐츠 모양 종류는 접근성 모양을 바꾸고 테스트 모양을 쳤다.

00:11:40.000 --> 00:11:49.000
이제 히트 테스트 모양에 영향을 미치지 않고 접근성 콘텐츠의 모양에만 영향을 미치는 접근성 콘텐츠 모양이 있습니다.

00:11:49.000 --> 00:11:58.000
요소가 원과 같은 사용자 지정 모양이 필요할 때, 계산된 접근성 커서 비주얼은 화면의 다른 항목을 방해할 수 있습니다.

00:11:58.000 --> 00:12:05.000
이 예에서, 접근성 경로는 빨간색 원형 콘텐츠와 일치하지 않는 정사각형이다.

00:12:05.000 --> 00:12:16.000
접근성 콘텐츠 모양 종류가 보기에 적용되면, 수정자가 제공한 모양으로 요소의 기본 접근성 지오메트리를 업데이트합니다.

00:12:16.000 --> 00:12:22.000
이를 통해 기존 SwiftUI 모양으로 요소의 경로를 빠르게 업데이트할 수 있습니다.

00:12:22.000 --> 00:12:26.000
나는 원 이미지를 사용하여 원 버튼을 만들었다.

00:12:26.000 --> 00:12:32.000
우리는 빨간색과 일치하도록 프레임과 접근성 라벨을 설정할 수 있습니다.

00:12:32.000 --> 00:12:41.000
마지막으로, 우리는 접근성 유형과 원형을 모양으로 내 보기에 콘텐츠 모양 수정자를 추가할 수 있습니다.

00:12:41.000 --> 00:12:47.000
이제 접근성 경로는 빨간색 버튼의 원형 모양과 올바르게 일치합니다.

00:12:47.000 --> 00:12:55.000
마지막으로, UIKit 접근성, 블록 기반 속성 세터에 추가되는 것에 대해 논의해 봅시다.

00:12:55.000 --> 00:13:03.000
사진 편집 앱에서, 저는 이미지 보기의 접근성 값이 사진이 필터링되었는지 필터링되었는지 여부를 나타내기를 원합니다.

00:13:03.000 --> 00:13:13.000
이제 내 견해에 대한 기본 접근성 속성을 항상 제시된 UI와 일치하도록 유지하는 쉬운 방법이 있습니다.

00:13:13.000 --> 00:13:17.000
나는 접근성 블록 기반 세터로 이것을 할 수 있다.

00:13:17.000 --> 00:13:28.000
새로운 접근성 블록 API를 사용하면 값을 직접 저장하는 대신 속성이 필요할 때마다 평가되는 클로저를 제공할 수 있습니다.

00:13:28.000 --> 00:13:36.000
폐쇄는 보조 기술로 뷰를 참조하거나 접근할 때마다 재평가된다.

00:13:36.000 --> 00:13:41.000
내 뷰 컨트롤러의 viewDidLoad 메소드에서 만든 클로저로 단순화할 수 있습니다.

00:13:41.000 --> 00:13:51.000
우리는 이미지가 필터링되었는지 여부에 따라 값을 업데이트하기 위해 zoomView에서 accessibilityValueBlock 속성을 설정했습니다.

00:13:51.000 --> 00:13:56.000
클로저는 선택적 문자열인 이 속성에 대한 올바른 유형을 반환해야 합니다.

00:13:56.000 --> 00:14:00.000
우리가 유지 주기를 피하기 위해 자아에 대한 약한 참조를 사용하고 있다는 것을 주목하세요.

00:14:00.000 --> 00:14:09.000
블록은 적절한 접근성 속성 정보로 수업을 시작하기 위해 수업 수명 주기의 시작 부분에 추가하는 것이 좋습니다.

00:14:09.000 --> 00:14:13.000
이제 접근성 속성은 유지하기가 훨씬 쉽다.

00:14:13.000 --> 00:14:23.000
누군가가 VoiceOver 커서를 새로운 요소로 이동할 때마다, VoiceOver는 먼저 클로저로 설정된 속성을 찾고 클로저를 재평가합니다.

00:14:23.000 --> 00:14:47.000
사용자 지정 UI를 구축할 때, 토글과 같은 접근성 특성과 직접 터치 상호 작용과 같은 기능을 통합하여 모든 사람의 유용성을 높이는 것을 고려하십시오.

00:14:47.000 --> 00:14:52.000
둘째, SwiftUI의 사용자 지정 모양에 대한 당신의 견해에 대해 생각해 보세요.

00:14:52.000 --> 00:14:59.000
접근성 모양이 UI와 일치하지 않는 경우, 사용자 지정 접근성 모양을 도입하는 것을 고려하십시오.

00:14:59.000 --> 00:15:08.000
그리고 마지막으로, 접근성 속성을 어떻게 설정하고 있는지 평가하고 블록 기반 세터가 앱에서 더 의미가 있는지 식별하는 것이 좋습니다.

00:15:08.000 --> 00:15:12.000
애플에서, 우리는 접근성이 인권이라고 믿는다.

00:15:12.000 --> 00:15:18.000
당신의 도움으로, 우리는 모든 사람의 삶을 향상시키고 힘을 실어주는 기술을 만들 수 있습니다.

00:15:18.000 --> 00:15:30.000
이러한 새로운 API 추가는 보조 기술에 의존하는 사람들을 위해 앱의 유용성을 높일 수 있는 좋은 방법이며, 이 모든 것을 사용하여 놀랍고 접근 가능한 앱을 만드는 것이 좋습니다.

00:15:30.000 --> 23:59:59.000
봐줘서 고마워.

