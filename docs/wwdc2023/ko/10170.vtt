WEBVTT

00:00:01.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:12.000
에반: 안녕, 내 이름은 에반이야.

00:00:12.000 --> 00:00:20.000
오늘날, 우리는 구조화된 동시성의 기초를 넘어, 구조화된 작업이 유용한 행동을 실현하는 것을 단순화할 수 있는 방법을 탐구하고 있다.

00:00:20.000 --> 00:00:33.000
시작하기 전에, 당신이 처음이거나 구조화된 동시성을 검토하고 싶다면, WWDC 2021의 "Explore structured concurrency in Swift"와 "Swift concurrency: Behind the scenes" 세션을 자유롭게 시청하세요.

00:00:33.000 --> 00:00:44.000
오늘, 우리는 작업 계층 구조와 자동 작업 취소, 우선 순위 전파 및 유용한 작업 로컬 가치 행동을 잠금 해제하는 방법을 검토할 것입니다.

00:00:44.000 --> 00:00:48.000
그런 다음 우리는 자원 사용을 관리하는 데 도움이 되는 작업 그룹으로 몇 가지 패턴을 다룰 것입니다.

00:00:48.000 --> 00:00:56.000
마지막으로, 우리는 서버 환경에서 프로파일링 및 추적 작업을 용이하게 하기 위해 이 모든 것이 어떻게 합쳐지는지 살펴볼 것입니다.

00:00:56.000 --> 00:01:13.000
구조화된 동시성을 사용하면 실행이 분기되고 동시에 실행되는 잘 정의된 지점을 사용하여 동시 코드에 대해 추론할 수 있으며, "if"-blocks 및 "for"-loops가 동기 코드에서 제어 흐름이 어떻게 동작하는지 정의하는 방식과 유사합니다.

00:01:13.000 --> 00:01:20.000
동시 실행은 "async let", 작업 그룹을 사용하거나 작업 또는 분리된 작업을 만들 때 트리거됩니다.

00:01:20.000 --> 00:01:26.000
결과는 "대기"로 표시된 정지 지점에서 현재 실행에 다시 합류한다.

00:01:26.000 --> 00:01:28.000
모든 작업이 구조화된 것은 아니다.

00:01:28.000 --> 00:01:37.000
구조화된 작업은 "async let"와 작업 그룹을 사용하여 생성되는 반면, 구조화되지 않은 작업은 Task와 Task.detached를 사용하여 생성됩니다.

00:01:37.000 --> 00:01:48.000
구조화된 작업은 지역 변수와 같이 선언된 범위의 끝까지 살며, 범위를 벗어나면 자동으로 취소되어 작업이 얼마나 오래 지속될지 명확하게 합니다.

00:01:48.000 --> 00:01:51.000
가능할 때마다, 구조화된 작업을 선호한다.

00:01:51.000 --> 00:01:57.000
나중에 논의된 구조화된 동시성의 이점이 구조화되지 않은 작업에 항상 적용되는 것은 아니다.

00:01:57.000 --> 00:02:02.000
코드에 뛰어들기 전에, 구체적인 예를 생각해 봅시다.

00:02:02.000 --> 00:02:05.000
여러 요리사가 수프를 준비하는 주방이 있다고 가정해 봅시다.

00:02:05.000 --> 00:02:08.000
수프 준비는 여러 단계로 구성되어 있다.

00:02:08.000 --> 00:02:16.000
요리사들은 재료를 자르고, 닭고기를 절이고, 국물을 끓이고, 마지막으로 수프가 준비되기 전에 요리해야 한다.

00:02:16.000 --> 00:02:21.000
일부 작업은 병렬로 수행될 수 있지만, 다른 작업은 특정 순서로 수행되어야 한다.

00:02:21.000 --> 00:02:24.000
우리가 이것을 코드로 어떻게 표현할 수 있는지 봅시다.

00:02:24.000 --> 00:02:28.000
지금은, 우리는 makeSoup 기능에 집중할 것이다.

00:02:28.000 --> 00:02:35.000
함수에 동시성을 추가하기 위해 구조화되지 않은 작업을 만들고, 필요할 때 그 값을 기다리는 자신을 발견할 수 있습니다.

00:02:35.000 --> 00:02:43.000
이것은 어떤 작업을 동시에 실행할 수 있고 어떤 작업을 실행할 수 없는지 표현하지만, 이것은 스위프트에서 동시성을 사용하는 권장 방법은 아니다.

00:02:43.000 --> 00:02:47.000
여기 구조화된 동시성을 사용하여 표현된 동일한 기능이 있습니다.

00:02:47.000 --> 00:02:54.000
우리가 만들 수 있는 알려진 수의 자식 작업이 있기 때문에, 우리는 편리한 "async let" 구문을 사용할 수 있습니다.

00:02:54.000 --> 00:02:58.000
이 작업들은 부모 작업과 구조화된 관계를 형성한다.

00:02:58.000 --> 00:03:01.000
우리는 이것이 왜 중요한지에 대해 곧 이야기할 것이다.

00:03:01.000 --> 00:03:04.000
makeSoup은 많은 비동기 함수를 호출한다.

00:03:04.000 --> 00:03:11.000
그 중 하나는 재료 목록을 취하고 작업 그룹을 사용하여 모든 것을 동시에 자르는 "chopIngredients"이다.

00:03:11.000 --> 00:03:16.000
이제 makeSoup에 익숙해졌으니, 작업 계층 구조를 살펴봅시다.

00:03:16.000 --> 00:03:22.000
자식 작업은 컬러 박스로 표시되는 반면, 화살표는 부모 작업에서 자식 작업으로 가리킵니다.

00:03:22.000 --> 00:03:29.000
makeSoup에는 재료를 자르고, 닭고기를 절이고, 국물을 끓이는 세 가지 어린이 과제가 있다.

00:03:29.000 --> 00:03:34.000
chopIngredients는 작업 그룹을 사용하여 각 성분에 대한 자식 작업을 만듭니다.

00:03:34.000 --> 00:03:38.000
만약 우리에게 세 가지 재료가 있다면, 그것도 세 명의 아이를 만들 것이다.

00:03:38.000 --> 00:03:43.000
이 부모-자식 계층 구조는 작업 트리인 트리를 형성한다.

00:03:43.000 --> 00:03:48.000
이제 작업 트리를 도입했으니, 그것이 우리의 코드에 어떻게 도움이 되는지 식별하기 시작합시다.

00:03:48.000 --> 00:03:58.000
작업 취소는 앱이 더 이상 작업의 결과를 필요로 하지 않으며 작업이 중지되고 부분적인 결과를 반환하거나 오류를 발생시켜야 한다는 신호를 보내는 데 사용됩니다.

00:03:58.000 --> 00:04:08.000
우리의 수프 예에서, 우리는 그 고객이 떠나거나, 다른 것을 주문하기로 결정하거나, 마감 시간이라면 수프 주문을 중단하고 싶을 수도 있습니다.

00:04:08.000 --> 00:04:10.000
작업이 취소되는 원인은 무엇인가요?

00:04:10.000 --> 00:04:21.000
구조화된 작업은 범위를 벗어날 때 암시적으로 취소되지만, 작업 그룹에서 "cancelAll"을 호출하여 모든 활성 자식과 향후 자식 작업을 취소할 수 있습니다.

00:04:21.000 --> 00:04:26.000
구조화되지 않은 작업은 "취소" 기능으로 명시적으로 취소됩니다.

00:04:26.000 --> 00:04:32.000
부모 작업을 취소하면 모든 자식 작업이 취소됩니다.

00:04:32.000 --> 00:04:36.000
취소는 협조적이기 때문에, 아동 업무는 즉시 중단되지 않는다.

00:04:36.000 --> 00:04:40.000
그것은 단순히 그 작업에 "isCancelled" 플래그를 설정합니다.

00:04:40.000 --> 00:04:43.000
실제로 취소에 대한 행동은 당신의 코드에서 이루어집니다.

00:04:43.000 --> 00:04:45.000
취소는 경주야.

00:04:45.000 --> 00:04:51.000
확인 전에 작업이 취소되면, "makeSoup"은 "SoupCancellationError"를 던집니다.

00:04:51.000 --> 00:04:58.000
경비원이 실행한 후 작업이 취소되면, 프로그램은 수프 준비를 계속할 것이다.

00:04:58.000 --> 00:05:08.000
부분적인 결과를 반환하는 대신 취소 오류를 발생시킬 경우, 작업이 취소된 경우 "CancellationError"를 발생시키는 "Task.checkCancellation"를 호출할 수 있습니다.

00:05:08.000 --> 00:05:15.000
결과가 여전히 필요한지 확인하기 위해 값비싼 작업을 시작하기 전에 작업 취소 상태를 확인하는 것이 중요합니다.

00:05:15.000 --> 00:05:27.000
취소 확인은 동기식이므로, 취소에 반응해야 하는 비동기식 또는 동기식 기능은 계속하기 전에 작업 취소 상태를 확인해야 합니다.

00:05:27.000 --> 00:05:42.000
"isCancelled" 또는 "checkCancellation"으로 취소를 폴링하는 것은 작업이 실행 중일 때 유용하지만, AsyncSequence를 구현할 때와 같이 작업이 일시 중지되고 코드가 실행되지 않는 동안 취소에 응답해야 할 수도 있습니다.

00:05:42.000 --> 00:05:47.000
이것은 "withTaskCancellationHandler"가 유용한 곳이다.

00:05:47.000 --> 00:05:50.000
교대 근무 기능을 소개해 봅시다.

00:05:50.000 --> 00:05:58.000
요리사는 작업 취소로 인해 교대 근무가 끝날 때까지 주문이 들어오면서 수프를 만들어야 한다.

00:05:58.000 --> 00:06:04.000
하나의 취소 시나리오에서, 비동기 루프는 취소되기 전에 새로운 주문을 받는다.

00:06:04.000 --> 00:06:09.000
"makeSoup" 기능은 우리가 이전에 정의한 대로 취소를 처리하고 오류를 발생시킨다.

00:06:09.000 --> 00:06:16.000
다른 시나리오에서는, 작업이 중단되는 동안 다음 주문을 기다리는 동안 취소가 발생할 수 있습니다.

00:06:16.000 --> 00:06:23.000
이 사건은 작업이 실행되지 않기 때문에 더 흥미롭기 때문에 취소 이벤트에 대해 명시적으로 투표할 수 없습니다.

00:06:23.000 --> 00:06:31.000
대신, 우리는 취소 핸들러를 사용하여 취소 이벤트를 감지하고 비동기 for-loop에서 벗어나야 합니다.

00:06:31.000 --> 00:06:35.000
주문은 AsyncSequence에서 생산된다.

00:06:35.000 --> 00:06:42.000
AsyncSequences는 비동기 "다음" 함수를 정의하는 AsyncIterator에 의해 구동됩니다.

00:06:42.000 --> 00:06:52.000
동기 반복자와 마찬가지로, "다음" 함수는 시퀀스의 다음 요소 또는 nil을 반환하여 우리가 시퀀스의 끝에 있음을 나타냅니다.

00:06:52.000 --> 00:06:59.000
많은 AsyncSequences는 실행 시퀀스를 중지하는 데 사용하는 상태 기계로 구현됩니다.

00:06:59.000 --> 00:07:05.000
여기서 우리의 예에서, "isRunning"이 사실일 때, 시퀀스는 주문을 계속 방출해야 한다.

00:07:05.000 --> 00:07:10.000
작업이 취소되면, 우리는 시퀀스가 완료되었고 종료되어야 한다는 것을 표시해야 합니다.

00:07:10.000 --> 00:07:16.000
우리는 시퀀스 상태 기계에서 "취소" 함수를 동시에 호출하여 이것을 합니다.

00:07:16.000 --> 00:07:28.000
취소 핸들러가 즉시 실행되기 때문에, 상태 기계는 동시에 실행할 수 있는 취소 핸들러와 본체 간에 가변 상태를 공유한다는 점에 유의하십시오.

00:07:28.000 --> 00:07:30.000
우리는 국가 기계를 보호해야 할 것이다.

00:07:30.000 --> 00:07:41.000
행위자는 캡슐화된 상태를 보호하는 데 훌륭하지만, 우리는 상태 기계의 개별 속성을 수정하고 읽고 싶기 때문에 행위자는 이에 적합한 도구가 아닙니다.

00:07:41.000 --> 00:07:49.000
게다가, 우리는 행위자에서 운영이 실행되는 순서를 보장할 수 없으므로, 취소가 먼저 실행되도록 보장할 수 없습니다.

00:07:49.000 --> 00:07:51.000
우리는 뭔가 다른 게 필요할 거야.

00:07:51.000 --> 00:07:58.000
나는 스위프트 아토믹스 패키지의 원자를 사용하기로 결정했지만, 우리는 디스패치 대기열이나 자물쇠를 사용할 수 있다.

00:07:58.000 --> 00:08:10.000
이러한 메커니즘을 통해 공유 상태를 동기화하여 경쟁 조건을 피할 수 있으며, 취소 핸들러에 구조화되지 않은 작업을 도입하지 않고 실행 중인 상태 기계를 취소할 수 있습니다.

00:08:10.000 --> 00:08:14.000
작업 트리는 자동으로 작업 취소 정보를 전파한다.

00:08:14.000 --> 00:08:21.000
취소 토큰과 동기화에 대해 걱정하는 대신, 우리는 스위프트 런타임이 우리를 위해 안전하게 처리할 수 있도록 했다.

00:08:21.000 --> 00:08:31.000
취소는 작업이 실행되는 것을 멈추지 않으며, 작업이 취소되었음을 알리고 가능한 한 빨리 실행을 중단해야 한다는 것을 기억하십시오.

00:08:31.000 --> 00:08:35.000
취소를 확인하는 것은 당신의 코드에 달려 있습니다.

00:08:35.000 --> 00:08:42.000
다음으로, 구조화된 작업 트리가 우선 순위를 전파하고 우선 순위 반전을 피하는 데 어떻게 도움이 되는지 생각해 봅시다.

00:08:42.000 --> 00:08:46.000
첫째, 우선순위는 무엇이며, 우리는 왜 신경을 쓰나요?

00:08:46.000 --> 00:08:51.000
우선 순위는 주어진 작업이 얼마나 긴급한지 시스템에 전달하는 방법입니다.

00:08:51.000 --> 00:08:57.000
버튼 누름에 응답하는 것과 같은 특정 작업은 즉시 실행해야 하며 그렇지 않으면 앱이 정지된 것처럼 보일 것입니다.

00:08:57.000 --> 00:09:04.000
한편, 서버에서 콘텐츠를 미리 가져오는 것과 같은 다른 작업은 아무도 눈치 채 백그라운드에서 실행할 수 있다.

00:09:04.000 --> 00:09:08.000
둘째, 우선 순위 반전은 무엇인가요?

00:09:08.000 --> 00:09:15.000
우선 순위 반전은 우선순위가 높은 작업이 우선순위가 낮은 작업의 결과를 기다리고 있을 때 발생한다.

00:09:15.000 --> 00:09:28.000
기본적으로, 자식 작업은 부모로부터 우선 순위를 상속하므로, makeSoup이 중간 우선 순위의 작업에서 실행되고 있다고 가정하면, 모든 자식 작업도 중간 우선 순위로 실행됩니다.

00:09:28.000 --> 00:09:33.000
수프를 찾으러 우리 식당에 오는 VIP 손님이라고 가정해 봅시다.

00:09:33.000 --> 00:09:37.000
우리는 좋은 리뷰를 받을 수 있도록 그들의 수프에 더 높은 우선 순위를 부여한다.

00:09:37.000 --> 00:09:50.000
그들이 수프를 기다릴 때, 모든 아동 작업의 우선 순위가 확대되어 우선 순위가 높은 작업이 우선 순위가 낮은 작업을 기다리지 않도록 하고 우선 순위 반전을 피한다.

00:09:50.000 --> 00:09:57.000
우선 순위가 높은 작업의 결과를 기다리는 것은 작업 트리의 모든 하위 작업의 우선 순위를 증가시킨다.

00:09:57.000 --> 00:10:07.000
작업 그룹의 다음 결과를 기다리는 것은 다음 작업을 완료할 가능성이 가장 높은 것을 모르기 때문에 그룹의 모든 하위 작업을 에스컬레이션합니다.

00:10:07.000 --> 00:10:16.000
동시성 런타임은 우선 순위 대기열을 사용하여 작업을 예약하므로 우선 순위가 높은 작업은 우선 순위가 낮은 작업 전에 실행되도록 선택됩니다.

00:10:16.000 --> 00:10:20.000
그 작업은 남은 생애 동안 에스컬레이션된 우선순위를 유지한다.

00:10:20.000 --> 00:10:23.000
우선 순위 에스컬레이션을 취소하는 것은 불가능합니다.

00:10:23.000 --> 00:10:31.000
우리는 빠른 수프 배달로 VIP 손님을 효과적으로 만족시켰고 좋은 평가를 받았기 때문에, 우리의 부엌은 이제 인기를 얻기 시작했다.

00:10:31.000 --> 00:10:37.000
우리는 우리의 자원을 효과적으로 사용하고 싶고 우리가 많은 절단 작업을 만들고 있다는 것을 알아차렸다.

00:10:37.000 --> 00:10:43.000
작업 그룹과 동시성을 관리하기 위한 몇 가지 유용한 패턴을 조사해 봅시다.

00:10:43.000 --> 00:10:45.000
우리는 많은 도마를 위한 공간만 있다.

00:10:45.000 --> 00:10:56.000
너무 많은 재료를 동시에 자르면, 다른 작업을 위한 공간이 부족할 것이므로, 동시에 잘게 썬 재료의 수를 제한하고 싶습니다.

00:10:56.000 --> 00:11:03.000
코드로 돌아가서, 우리는 절단 작업을 만드는 루프를 조사하고 싶습니다.

00:11:03.000 --> 00:11:10.000
우리는 각 성분의 원래 루프를 최대 절단 작업 수까지 시작하는 루프로 교체합니다.

00:11:10.000 --> 00:11:18.000
다음으로, 우리는 루프 수집 결과가 이전 작업이 완료될 때마다 새로운 작업을 시작하기를 원합니다.

00:11:18.000 --> 00:11:28.000
새로운 루프는 실행 작업 중 하나가 끝날 때까지 기다리며, 여전히 잘라야 할 재료가 있지만, 다음 재료를 잘라야 할 새로운 작업을 추가합니다.

00:11:28.000 --> 00:11:32.000
패턴을 더 명확하게 보기 위해 이 아이디어를 추출해 봅시다.

00:11:32.000 --> 00:11:37.000
초기 루프는 최대 수의 동시 작업을 생성하여 너무 많이 만들지 않도록 합니다.

00:11:37.000 --> 00:11:42.000
최대 작업 수가 실행되면, 우리는 하나가 끝날 때까지 기다린다.

00:11:42.000 --> 00:11:49.000
그것이 끝나고 우리가 정지 조건에 도달하지 못한 후, 우리는 계속 진행하기 위해 새로운 작업을 만듭니다.

00:11:49.000 --> 00:11:57.000
이것은 이전 작업이 끝날 때까지 새로운 작업을 시작하지 않을 것이기 때문에 그룹의 동시 작업 수를 제한합니다.

00:11:57.000 --> 00:12:04.000
이전에, 우리는 교대로 일하는 요리사들과 그들의 교대 근무가 언제 끝났음을 나타내기 위해 취소를 사용하는 것에 대해 이야기했다.

00:12:04.000 --> 00:12:07.000
이것은 교대 근무를 처리하는 주방 서비스 코드입니다.

00:12:07.000 --> 00:12:11.000
각 요리사는 별도의 작업으로 교대 근무를 시작한다.

00:12:11.000 --> 00:12:14.000
요리사들이 일하면, 우리는 타이머를 시작한다.

00:12:14.000 --> 00:12:18.000
타이머가 끝나면, 우리는 진행 중인 모든 교대 근무를 취소합니다.

00:12:18.000 --> 00:12:23.000
어떤 작업도 값을 반환하지 않는다는 것을 주목하세요.

00:12:23.000 --> 00:12:27.000
Swift 5.9의 새로운 것은 withDiscardingTaskGroup API이다.

00:12:27.000 --> 00:12:32.000
작업 그룹을 폐기하는 것은 완료된 아동 작업의 결과를 붙잡지 않는다.

00:12:32.000 --> 00:12:37.000
작업에서 사용되는 리소스는 작업이 완료된 후 즉시 해제됩니다.

00:12:37.000 --> 00:12:42.000
우리는 폐기 작업 그룹을 사용하기 위해 실행 방법을 변경할 수 있습니다.

00:12:42.000 --> 00:12:48.000
작업 그룹을 폐기하면 자동으로 자녀를 정리하므로 그룹을 명시적으로 취소하고 정리할 필요가 없습니다.

00:12:48.000 --> 00:12:52.000
폐기 작업 그룹에는 또한 자동 형제자매 취소가 있다.

00:12:52.000 --> 00:12:59.000
자식 작업 중 하나라도 오류가 발생하면, 나머지 모든 작업은 자동으로 취소됩니다.

00:12:59.000 --> 00:13:02.000
이것은 여기서 우리의 사용 사례에 이상적이다.

00:13:02.000 --> 00:13:10.000
교대 근무가 끝나면 "TimeToCloseError"를 던질 수 있으며, 모든 요리사의 교대 근무가 자동으로 종료됩니다.

00:13:10.000 --> 00:13:18.000
새로운 폐기 작업 그룹은 결과를 수집해야 하는 일반 작업 그룹과 달리 작업이 완료되면 자동으로 리소스를 해제합니다.

00:13:18.000 --> 00:13:26.000
이것은 요청 스트림을 처리할 때와 같이 아무것도 반환할 필요가 없는 작업이 많을 때 메모리 소비를 줄이는 데 도움이 됩니다.

00:13:26.000 --> 00:13:33.000
어떤 상황에서는 작업 그룹에서 값을 반환하고 싶지만, 동시 작업의 수를 제한하고 싶을 수도 있습니다.

00:13:33.000 --> 00:13:42.000
우리는 한 작업의 완료를 사용하여 다른 작업을 시작하고 작업 폭발을 피하기 위한 일반적인 패턴을 다루었다.

00:13:42.000 --> 00:13:47.000
우리는 그 어느 때보다 더 효율적으로 수프를 만들고 있지만, 여전히 더 확장해야 한다.

00:13:47.000 --> 00:13:49.000
생산을 서버로 옮길 시간이다.

00:13:49.000 --> 00:13:53.000
그것과 함께 처리되는 추적 주문에 대한 도전이 따른다.

00:13:53.000 --> 00:13:56.000
작업 지역 가치는 돕기 위해 여기에 있다.

00:13:56.000 --> 00:14:03.000
작업 로컬 값은 주어진 작업 또는 더 정확하게는 작업 계층 구조와 관련된 데이터 조각이다.

00:14:03.000 --> 00:14:10.000
글로벌 변수와 같지만, 작업 로컬 값에 바인딩된 값은 현재 작업 계층 구조에서만 사용할 수 있습니다.

00:14:10.000 --> 00:14:16.000
작업 로컬 값은 "TaskLocal" 속성 래퍼를 사용하여 정적 속성으로 선언됩니다.

00:14:16.000 --> 00:14:19.000
로컬 작업을 선택 사항으로 만드는 것은 좋은 관행이다.

00:14:19.000 --> 00:14:28.000
값 설정이 없는 모든 작업은 0 선택 사항으로 쉽게 표현되는 기본값을 반환해야 합니다.

00:14:28.000 --> 00:14:32.000
바인딩되지 않은 작업 로컬에는 기본값이 포함되어 있습니다.

00:14:32.000 --> 00:14:39.000
우리의 경우, 우리는 선택적 문자열을 가지고 있으므로, 그것은 0이고 현재 작업과 관련된 요리사가 없습니다.

00:14:39.000 --> 00:14:46.000
작업 로컬 값은 명시적으로 할당할 수 없지만, 특정 범위에 바인딩되어야 합니다.

00:14:46.000 --> 00:14:54.000
바인딩은 범위 기간 동안 지속되며, 범위 끝에 있는 원래 값으로 되돌아갑니다.

00:14:54.000 --> 00:14:59.000
작업 트리로 돌아가서, 각 작업에는 작업 로컬 값에 대한 관련 장소가 있습니다.

00:14:59.000 --> 00:15:05.000
우리는 수프를 만들기 전에 "사쿠라"라는 이름을 "요리" 작업 지역 변수에 묶었다.

00:15:05.000 --> 00:15:08.000
makeSoup만이 바인딩된 가치를 저장한다.

00:15:08.000 --> 00:15:13.000
아이들은 작업 로컬 저장소에 저장된 값이 없다.

00:15:13.000 --> 00:15:21.000
작업 지역 변수에 바인딩된 값을 찾는 것은 우리가 그 값을 가진 작업을 찾을 때까지 각 부모를 재귀적으로 걷는 것을 포함한다.

00:15:21.000 --> 00:15:26.000
값이 바인딩된 작업을 찾으면, 로컬 작업은 그 값을 가정할 것이다.

00:15:26.000 --> 00:15:34.000
부모가 없는 작업으로 표시된 루트에 도달하면, 로컬 작업은 바인딩되지 않았고 원래 기본값을 얻는다.

00:15:34.000 --> 00:15:38.000
스위프트 런타임은 이러한 쿼리를 더 빨리 실행하도록 최적화되어 있습니다.

00:15:38.000 --> 00:15:44.000
나무를 걷는 대신, 우리는 우리가 찾고 있는 열쇠로 작업에 대한 직접적인 참조를 가지고 있다.

00:15:44.000 --> 00:15:51.000
작업 트리의 재귀적 특성은 이전 값을 잃지 않고 값을 섀도잉하는 데 잘 어울린다.

00:15:51.000 --> 00:15:56.000
우리가 수프 만드는 과정의 현재 단계를 추적하고 싶다고 가정해 봅시다.

00:15:56.000 --> 00:16:03.000
우리는 "step" 변수를 "makeSoup"의 "soup"에 바인딩한 다음 "chopIngredients"의 "chop"으로 다시 바인딩할 수 있습니다.

00:16:03.000 --> 00:16:12.000
chopIngredients에 바인딩된 값은 우리가 원래 값을 관찰하는 chopIngredients에서 돌아올 때까지 이전 값을 가릴 것이다.

00:16:12.000 --> 00:16:18.000
비디오 편집 마법의 힘을 통해, 우리는 수프에 대한 수요를 따라잡기 위해 서비스를 클라우드로 옮겼습니다.

00:16:18.000 --> 00:16:23.000
우리는 여전히 같은 수프 만드는 기능을 가지고 있지만, 대신 서버에 있다.

00:16:23.000 --> 00:16:32.000
우리는 그들이 적시에 완료되고 있는지 확인하고 예상치 못한 실패를 모니터링하기 위해 시스템을 통과할 때 주문을 관찰해야 합니다.

00:16:32.000 --> 00:16:41.000
서버 환경은 많은 요청을 동시에 처리하므로, 주어진 주문을 추적할 수 있는 정보를 포함하고 싶습니다.

00:16:41.000 --> 00:16:46.000
손으로 로깅하는 것은 반복적이고 장황하며, 미묘한 버그와 오타로 이어진다.

00:16:46.000 --> 00:16:51.000
오 안 돼, 나는 실수로 주문 ID 대신 전체 주문을 기록했어.

00:16:51.000 --> 00:16:57.000
로깅을 더 신뢰할 수 있게 만들기 위해 작업 로컬 값을 어떻게 사용할 수 있는지 알아봅시다.

00:16:57.000 --> 00:17:08.000
Apple 기기에서는 OSLog API를 직접 계속 사용하고 싶지만, 애플리케이션의 일부가 클라우드로 이동함에 따라 다른 솔루션이 필요합니다.

00:17:08.000 --> 00:17:19.000
SwiftLog는 여러 백업 구현이 있는 로깅 API 패키지로, 서버를 변경하지 않고도 필요에 맞는 로깅 백엔드를 드롭할 수 있습니다.

00:17:19.000 --> 00:17:24.000
MetadataProvider는 SwiftLog 1.5의 새로운 API이다.

00:17:24.000 --> 00:17:34.000
메타데이터 공급자를 구현하면 로깅 논리를 쉽게 추상화하여 관련 값에 대한 일관된 정보를 전송할 수 있습니다.

00:17:34.000 --> 00:17:40.000
메타데이터 제공자는 사전과 같은 구조를 사용하여 이름을 기록되는 값에 매핑합니다.

00:17:40.000 --> 00:17:51.000
우리는 orderID 작업-로컬 변수를 자동으로 기록하고 싶기 때문에, 그것이 정의되었는지 확인하고, 만약 그렇다면, 사전에 추가하세요.

00:17:51.000 --> 00:18:05.000
여러 라이브러리는 라이브러리별 정보를 찾기 위해 자체 메타데이터 공급자를 정의할 수 있으므로, MetadataProvider는 여러 메타데이터 공급자를 단일 객체로 결합하는 "멀티플렉스" 기능을 정의합니다.

00:18:05.000 --> 00:18:14.000
메타데이터 제공자가 생기면, 우리는 그 제공자와 로깅 시스템을 초기화하고, 로깅을 시작할 준비가 되었습니다.

00:18:14.000 --> 00:18:22.000
로그는 메타데이터 공급자에 지정된 정보를 자동으로 포함하므로 로그 메시지에 포함시키는 것에 대해 걱정할 필요가 없습니다.

00:18:22.000 --> 00:18:28.000
로그는 주문 0이 부엌에 들어가고, 우리 요리사가 그 주문을 픽업하는 곳으로 표시됩니다.

00:18:28.000 --> 00:18:37.000
메타데이터 제공자의 값은 로그에 명확하게 나열되어 있어 수프 제조 과정을 통해 주문을 더 쉽게 추적할 수 있습니다.

00:18:37.000 --> 00:18:41.000
작업 로컬 값을 사용하면 작업 계층 구조에 정보를 첨부할 수 있습니다.

00:18:41.000 --> 00:18:48.000
분리된 작업을 제외한 모든 작업은 현재 작업에서 작업 로컬 값을 상속합니다.

00:18:48.000 --> 00:18:59.000
그것들은 주어진 범위에서 특정 작업 트리에 묶여 있으며, 작업 계층 구조를 통해 추가 컨텍스트 정보를 전파할 수 있는 낮은 수준의 빌딩 블록을 제공합니다.

00:18:59.000 --> 00:19:07.000
이제 우리는 동시 분산 시스템을 추적하고 프로파일링하기 위해 제공하는 작업 계층 구조와 도구를 사용할 것입니다.

00:19:07.000 --> 00:19:11.000
애플 플랫폼에서 동시성으로 작업할 때, 인스트루먼트는 당신의 친구입니다.

00:19:11.000 --> 00:19:17.000
Swift Concurrency 도구는 구조화된 작업 간의 관계에 대한 통찰력을 제공합니다.

00:19:17.000 --> 00:19:23.000
자세한 내용은 "스위프트 동시성 시각화 및 최적화" 세션을 확인하세요.

00:19:23.000 --> 00:19:31.000
인스트루먼트는 또한 "인스트루먼트의 HTTP 트래픽 분석" 세션에서 HTTP 트래픽 인스트루먼트를 도입했다.

00:19:31.000 --> 00:19:36.000
HTTP 트래픽 분석기는 로컬에서 발생하는 이벤트에 대한 추적만 보여줍니다.

00:19:36.000 --> 00:19:46.000
프로필은 서버의 응답을 기다리는 동안 회색 상자를 표시하므로 서버의 성능을 개선하는 방법을 이해하기 위해 더 많은 정보가 필요합니다.

00:19:46.000 --> 00:19:50.000
새로운 Swift 분산 추적 패키지를 소개합니다.

00:19:50.000 --> 00:19:54.000
작업 트리는 단일 작업 계층 구조에서 자식 작업을 관리하는 데 적합합니다.

00:19:54.000 --> 00:20:04.000
분산 추적을 사용하면 여러 시스템에서 작업 트리의 이점을 활용하여 성능 특성과 작업 관계에 대한 통찰력을 얻을 수 있습니다.

00:20:04.000 --> 00:20:16.000
Swift Distributed Tracing 패키지에는 OpenTelemetry 프로토콜이 구현되어 있으므로 Zipkin 및 Jaeger와 같은 기존 추적 솔루션은 즉시 작동합니다.

00:20:16.000 --> 00:20:26.000
Swift Distributed Tracing의 목표는 Xcode Instruments의 불투명한 "응답 대기 중"을 서버에서 일어나는 일에 대한 자세한 정보로 채우는 것입니다.

00:20:26.000 --> 00:20:31.000
우리는 어디에 집중해야 하는지 알아내기 위해 서버 코드를 계측해야 할 것이다.

00:20:31.000 --> 00:20:35.000
분산 추적은 로컬 추적 프로세스와 조금 다르다.

00:20:35.000 --> 00:20:43.000
함수당 추적을 얻는 대신, 우리는 "withSpan" API를 사용하여 스팬으로 코드를 계측합니다.

00:20:43.000 --> 00:20:49.000
스팬을 사용하면 추적 시스템에 보고된 코드 영역에 이름을 할당할 수 있습니다.

00:20:49.000 --> 00:20:51.000
스팬은 전체 기능을 커버할 필요가 없다.

00:20:51.000 --> 00:20:56.000
그들은 주어진 기능의 특정 부분에 대한 더 많은 통찰력을 제공할 수 있다.

00:20:56.000 --> 00:21:06.000
withSpan은 추가 추적 ID 및 기타 메타데이터로 작업에 주석을 달며, 추적 시스템이 작업 트리를 단일 추적으로 병합할 수 있도록 합니다.

00:21:06.000 --> 00:21:17.000
추적 시스템에는 작업의 런타임 성능 특성에 대한 정보와 함께 작업 계층 구조에 대한 통찰력을 제공할 수 있는 충분한 정보가 있습니다.

00:21:17.000 --> 00:21:20.000
스팬 이름은 추적 UI에 표시됩니다.

00:21:20.000 --> 00:21:27.000
당신은 그것들을 짧고 설명적으로 유지하여 혼란 없이 특정 범위에 대한 정보를 쉽게 찾을 수 있도록 하고 싶을 것입니다.

00:21:27.000 --> 00:21:36.000
스팬 속성을 사용하여 추가 메타데이터를 첨부할 수 있으므로, 스팬 이름을 주문 ID로 어지럽히지 않아도 됩니다.

00:21:36.000 --> 00:21:51.000
여기서 우리는 스팬 이름을 "#function" 지시어로 대체하여 스팬 이름을 함수 이름으로 자동으로 채우고, 스팬 속성을 사용하여 현재 주문 ID를 트레이서에 보고된 스팬 정보에 첨부했습니다.

00:21:51.000 --> 00:21:56.000
추적 시스템은 보통 주어진 범위를 검사하는 동안 속성을 제시한다.

00:21:56.000 --> 00:22:07.000
대부분의 스팬에는 HTTP 상태 코드, 요청 및 응답 크기, 시작 및 종료 시간 및 기타 메타데이터가 함께 제공되므로 시스템을 통과하는 정보를 더 쉽게 추적할 수 있습니다.

00:22:07.000 --> 00:22:11.000
이전 슬라이드에서 언급했듯이, 당신은 자신만의 속성을 정의할 수 있습니다.

00:22:11.000 --> 00:22:18.000
스팬을 활용하는 방법에 대한 더 많은 예를 보려면, swift-distributed-tracing-extras 저장소를 확인하세요.

00:22:18.000 --> 00:22:26.000
작업이 실패하고 오류가 발생하면, 그 정보도 스팬에 제시되고 추적 시스템에 보고됩니다.

00:22:26.000 --> 00:22:39.000
스팬은 타이밍 정보와 트리의 작업 관계를 모두 포함하기 때문에, 타이밍 레이스로 인한 오류를 추적하고 다른 작업에 어떤 영향을 미치는지 식별하는 데 유용한 방법입니다.

00:22:39.000 --> 00:22:52.000
우리는 추적 시스템과 추적 ID를 사용하여 작업 트리를 재구성하는 방법과 스팬에 자신의 속성을 첨부할 수 있는 방법에 대해 이야기했지만, 아직 분산 시스템으로 작업하기 시작하지 않았습니다.

00:22:52.000 --> 00:22:56.000
추적 시스템의 장점은 더 이상 해야 할 일이 없다는 것이다.

00:22:56.000 --> 00:23:09.000
우리가 주방 서비스에서 절단 서비스를 고려한다면, 그렇지 않으면 동일한 코드를 유지하면, 추적 시스템은 자동으로 추적을 포착하여 분산 시스템의 다른 기계와 연관시킬 것이다.

00:23:09.000 --> 00:23:15.000
추적 보기는 스팬이 다른 기계에서 실행되고 있음을 나타내지만, 그렇지 않으면 동일할 것이다.

00:23:15.000 --> 00:23:26.000
분산 추적은 HTTP 클라이언트, 서버 및 기타 RPC 시스템을 포함하여 시스템의 모든 부분이 추적을 포함할 때 가장 강력합니다.

00:23:26.000 --> 00:23:37.000
스위프트 분산 추적은 작업 트리에 구축된 작업 로컬 값을 활용하여 신뢰할 수 있는 교차 노드 추적을 생성하는 데 필요한 모든 정보를 자동으로 전파합니다.

00:23:37.000 --> 00:23:52.000
구조화된 작업은 동시 시스템의 비밀을 잠금 해제하여 작업을 자동으로 취소하고, 우선 순위 정보를 자동으로 전파하며, 복잡한 분산 워크로드 추적을 용이하게 하는 도구를 제공합니다.

00:23:52.000 --> 00:23:57.000
이 모든 작업은 스위프트의 동시성의 구조화된 특성 때문이다.

00:23:57.000 --> 00:24:05.000
이 세션이 구조화된 동시성에 대해 당신을 흥분시키고, 구조화되지 않은 대안을 사용하기 전에 구조화된 작업에 도달하기를 바랍니다.

00:24:05.000 --> 00:24:06.000
봐줘서 고마워!

00:24:06.000 --> 00:24:11.000
나는 당신이 구조화된 동시성을 사용하여 어떤 다른 유용한 패턴을 생각해 낼지 빨리 보고 싶다.

00:24:11.000 --> 00:24:15.000
음, 수프!

00:24:15.000 --> 23:59:59.000
♪ ♪

