WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:15.000
Pawel Szczerbuk: 안녕하세요, 제 이름은 Pawel Szczerbuk이고 GPU 소프트웨어 엔지니어입니다.

00:00:15.000 --> 00:00:21.000
금속은 레이 트레이싱 애플리케이션을 복잡하고 상세한 장면으로 확장하는 데 도움을 줄 수 있습니다.

00:00:21.000 --> 00:00:30.000
레이 트레이싱은 프로덕션 렌더링에서 이미지 충실도의 기본이며, 게임의 레이 트레이싱은 시각적 품질을 향상시키면서 높은 프레임 속도에 초점을 맞추고 있다.

00:00:30.000 --> 00:00:36.000
디즈니의 모아나 섬 장면의 이 이미지는 금속 광선 추적으로 렌더링되었다.

00:00:36.000 --> 00:00:40.000
오늘 나는 메탈 레이 트레이싱을 사용하는 방법에 대해 이야기할 것이다.

00:00:40.000 --> 00:00:49.000
게임과 프로덕션 렌더러에서 레이 트레이싱을 가속화하는 데 사용할 수 있는 몇 가지 흥미로운 새로운 기능을 강조하겠습니다.

00:00:49.000 --> 00:01:00.000
레이 트레이싱 응용 프로그램은 장면 주위를 튕기는 개별 광선을 시뮬레이션합니다. 금속 레이 트레이싱으로 렌더링하기 위해 첫 번째 단계는 장면 형상을 정의하는 것입니다.

00:01:00.000 --> 00:01:10.000
그런 다음 메탈은 기하학을 포함하고 GPU 가속을 사용하여 교차로를 효율적으로 쿼리할 수 있는 가속 구조를 구축합니다.

00:01:10.000 --> 00:01:15.000
GPU 기능에서, 장면과 교차할 광선을 만드세요.

00:01:15.000 --> 00:01:22.000
셰이더에 섹터 물체를 만들고 광선과 가속 구조를 모두 제공하십시오.

00:01:22.000 --> 00:01:30.000
이것은 픽셀을 음영 처리하거나 더 처리하는 데 필요한 모든 정보와 함께 교차 결과를 반환합니다.

00:01:30.000 --> 00:01:41.000
이 조각들 각각은 함께 작동하여 장면을 만들고, 인스턴싱을 사용하여 시각적 복잡성을 추가하고, 레이 교차를 수행할 수 있습니다.

00:01:41.000 --> 00:01:48.000
그리고 레이 트레이싱 애플리케이션으로 작업하는 데 도움이 되는 몇 가지 놀라운 도구가 있습니다.

00:01:48.000 --> 00:01:52.000
모든 것은 당신의 장면을 만드는 것으로 시작됩니다.

00:01:52.000 --> 00:01:56.000
금속 광선 추적 API는 몇 가지 다른 유형의 기하학을 지원합니다.

00:01:56.000 --> 00:02:02.000
이 모든 기하학은 가속 구조에 저장된다.

00:02:02.000 --> 00:02:09.000
가속 구조는 기하학을 재귀적으로 분할하여 레이 트레이싱 프로세스의 속도를 높인다.

00:02:09.000 --> 00:02:15.000
이것은 광선과 교차하지 않는 기하학을 빠르게 제거할 수 있게 해준다.

00:02:15.000 --> 00:02:20.000
세 단계로 가속 구조를 설정할 수 있습니다.

00:02:20.000 --> 00:02:25.000
실제 기하학을 제공할 가속 구조 설명자를 만드세요.

00:02:25.000 --> 00:02:32.000
설명자가 있으면, 가속 구조를 할당한 다음 구축할 수 있습니다.

00:02:32.000 --> 00:02:38.000
가속 구조 설명자는 하나 이상의 기하학 설명자를 포함한다.

00:02:38.000 --> 00:02:42.000
금속에는 세 가지 유형의 기하학 설명자가 있다.

00:02:42.000 --> 00:02:48.000
삼각형은 우리 모두가 알고 사랑하는 원시인이며, 컴퓨터 그래픽에서 거의 모든 것을 모델링하는 데 사용된다.

00:02:48.000 --> 00:02:58.000
경계 상자 프리미티브는 광선이 둘러싸는 경계 상자에 부딪힐 때 메탈이 호출할 사용자 지정 교차 함수에 의해 완전히 정의됩니다.

00:02:58.000 --> 00:03:00.000
그리고 올해 새로운, 곡선.

00:03:00.000 --> 00:03:05.000
이것들은 머리카락과 모피를 렌더링하는 데 좋습니다.

00:03:05.000 --> 00:03:13.000
삼각형을 사용하여 가속 구조를 만들려면, 개별 기하학 조각에 대한 삼각형 기하학 설명자를 만드세요.

00:03:13.000 --> 00:03:18.000
정점 버퍼, 인덱스 버퍼 및 삼각형 카운트를 제공할 것입니다.

00:03:18.000 --> 00:03:27.000
경계 상자 기하학은 정점 대신 기하학을 둘러싸는 경계 상자를 제공하는 것을 제외하고는 비슷한 방식으로 작동합니다.

00:03:27.000 --> 00:03:35.000
또한, 레이가 바운딩 박스 프리미티브에 부딪힐 때 메탈이 호출할 교차 함수를 제공합니다.

00:03:35.000 --> 00:03:44.000
교차 기능을 설정하는 방법에 대한 자세한 내용은 2020년 "Discover ray tracing with Metal" 토크를 참조하십시오.

00:03:44.000 --> 00:03:51.000
머리카락, 모피, 식물과 같은 기하학은 수천 또는 수백만 개의 원시인을 가질 수 있다.

00:03:51.000 --> 00:03:54.000
이것들은 일반적으로 미세하고 매끄러운 곡선으로 모델링된다.

00:03:54.000 --> 00:04:00.000
이 곡선을 근사하기 위해 삼각형을 사용하는 대신, 금속의 새로운 곡선 프리미티브를 사용할 수 있습니다.

00:04:00.000 --> 00:04:04.000
이 곡선은 카메라가 확대되더라도 매끄럽게 유지될 것이다.

00:04:04.000 --> 00:04:14.000
그리고 삼각형에 비해, 곡선은 더 컴팩트한 메모리 공간을 가지고 있으며 더 빠른 가속 구조 빌드를 가능하게 한다.

00:04:14.000 --> 00:04:19.000
전체 곡선은 일련의 연결된 곡선 세그먼트로 이루어져 있다.

00:04:19.000 --> 00:04:26.000
곡선의 모든 세그먼트는 자체 프리미티브이며, 메탈은 각 세그먼트에 고유한 프리미티브 ID를 할당합니다.

00:04:26.000 --> 00:04:33.000
이러한 각 세그먼트는 곡선의 모양을 제어하는 일련의 제어 지점에 의해 정의된다.

00:04:33.000 --> 00:04:38.000
이러한 제어점은 일련의 기본 함수를 사용하여 보간된다.

00:04:38.000 --> 00:04:44.000
기본 기능에 따라, 각 곡선 세그먼트는 2, 3 또는 4개의 제어점을 가질 수 있다.

00:04:44.000 --> 00:04:55.000
금속은 네 가지 곡선 기본 기능을 제공합니다: Bezier, Catmull-Rom, B-Spline 및 Linear.

00:04:55.000 --> 00:05:01.000
이러한 기본 기능 각각에는 고유한 이점이 있으므로, 사용 사례에 가장 적합한 것을 선택하십시오.

00:05:01.000 --> 00:05:05.000
금속은 또한 제어점 인덱스 버퍼가 필요하다.

00:05:05.000 --> 00:05:12.000
각 곡선 세그먼트에는 세그먼트의 첫 번째 제어점을 나타내는 이 버퍼에 하나의 인덱스가 있습니다.

00:05:12.000 --> 00:05:15.000
예를 들어, 네 개의 제어 지점이 있다고 가정해 봅시다.

00:05:15.000 --> 00:05:23.000
첫 번째 제어점의 인덱스를 사용하여 곡선 세그먼트를 정의하므로 인덱스 버퍼에 0을 추가하십시오.

00:05:23.000 --> 00:05:32.000
이 예제는 Catmull-Rom 기준 함수를 사용하고 있으므로, 실제 곡선 세그먼트는 제어점 1과 2 사이에서만 정의됩니다.

00:05:32.000 --> 00:05:37.000
다른 곡선 세그먼트를 연결하기 위해 해야 할 일은 제어점을 하나 더 추가하는 것입니다.

00:05:37.000 --> 00:05:44.000
이 추가 곡선 세그먼트는 제어점 1부터 4까지 사용하므로 인덱스 버퍼에 1을 추가하십시오.

00:05:44.000 --> 00:05:52.000
이 두 곡선 세그먼트는 인덱스 버퍼 때문에 3개의 제어점을 공유하며, 이는 곡선이 메모리를 절약할 수 있는 이유 중 하나이다.

00:05:52.000 --> 00:05:56.000
곡선을 끝내기 위해 필요한 만큼 이것을 반복하세요.

00:05:56.000 --> 00:06:06.000
새로운 곡선을 시작하려면, 이전 제어점과 겹치지 않는 추가 제어점을 추가하고 해당 인덱스를 인덱스 버퍼에 추가하기만 하면 됩니다.

00:06:06.000 --> 00:06:11.000
지금까지 내가 설명한 곡선은 추상적인 수학적 대상이었다.

00:06:11.000 --> 00:06:16.000
그것들을 렌더링하기 위해, 그들은 일종의 3D 모양을 가져야 한다.

00:06:16.000 --> 00:06:21.000
각 제어점은 또한 곡선의 길이를 따라 보간되는 반경을 가지고 있다.

00:06:21.000 --> 00:06:26.000
기본적으로, 곡선은 3D 원통형 단면으로 렌더링됩니다.

00:06:26.000 --> 00:06:30.000
이것은 클로즈업에서 볼 수 있는 곡선에 좋다.

00:06:30.000 --> 00:06:35.000
멀리서만 볼 수 있는 곡선의 경우, 금속은 또한 평평한 곡선을 지원합니다.

00:06:35.000 --> 00:06:41.000
이것은 완전한 3D 기하학이 필요하지 않을 때마다 성능을 향상시킬 수 있습니다.

00:06:41.000 --> 00:06:48.000
삼각형과 경계 상자와 마찬가지로, 곡선 기하학은 곡선 기하학 설명자로 표현된다.

00:06:48.000 --> 00:06:54.000
제어점, 해당 반경 및 제어점 인덱스가 포함된 버퍼를 부착하세요.

00:06:54.000 --> 00:07:00.000
제어점 버퍼의 제어점 수와 실제 곡선 세그먼트의 수를 설정하세요.

00:07:00.000 --> 00:07:06.000
이것은 인덱스 버퍼의 인덱스 수와 같아야 한다.

00:07:06.000 --> 00:07:08.000
어떤 종류의 곡선을 사용하고 있는지 지정하세요.

00:07:08.000 --> 00:07:14.000
이 예제는 곡선 세그먼트당 4개의 제어점이 있는 둥근 베지어 곡선을 사용합니다.

00:07:14.000 --> 00:07:19.000
그것이 곡선 기하학 설명자를 설정하기 위해 해야 할 전부입니다.

00:07:19.000 --> 00:07:27.000
이제 지오메트리 설명자를 만들었으므로, 가속 구조 설명자를 설정할 수 있습니다.

00:07:27.000 --> 00:07:34.000
삼각형, 경계 상자 및 곡선과 같은 원시 기하학에 원시 가속 구조 설명자를 사용하세요.

00:07:34.000 --> 00:07:39.000
가속 구조 설명자에 기하학 설명자를 추가하세요.

00:07:39.000 --> 00:07:46.000
여러 기하학 설명자를 단일 가속 구조에 추가하여 기하학을 결합할 수 있습니다.

00:07:46.000 --> 00:07:53.000
가속 구조 설명자가 준비되면, 가속 구조에 메모리를 할당할 수 있습니다.

00:07:53.000 --> 00:07:59.000
금속은 이 메모리가 언제 어디서 할당되는지 완벽하게 제어할 수 있게 해준다.

00:07:59.000 --> 00:08:02.000
이것은 두 부분으로 구성된 작업이다.

00:08:02.000 --> 00:08:07.000
먼저 빌드에 필요한 물체의 크기를 계산하세요.

00:08:07.000 --> 00:08:13.000
금속 장치는 가속 구조에 필요한 할당 크기를 계산하는 방법을 제공한다.

00:08:13.000 --> 00:08:24.000
금속 장치에서 직접 가속 구조에 대한 스토리지를 할당할 수 있지만, 힙에서 할당하면 나중에 자원 관리 오버헤드를 줄일 수 있습니다.

00:08:24.000 --> 00:08:32.000
힙에는 금속 장치에서 다른 방법을 사용하여 쿼리할 수 있는 추가 크기와 정렬 요구 사항이 있을 수 있습니다.

00:08:32.000 --> 00:08:38.000
이러한 크기를 사용하면 이제 가속 구조를 저장하기 위해 메모리를 할당할 수 있습니다.

00:08:38.000 --> 00:08:42.000
이 저장소는 MTL 가속 구조 객체로 표현된다.

00:08:42.000 --> 00:08:51.000
이러한 객체 중 하나를 할당하려면, 크기를 전달하여 힙 또는 금속 장치에서 가속 구조 메소드를 호출하십시오.

00:08:51.000 --> 00:08:58.000
당신은 또한 가속 구조를 구축하는 동안 금속이 사용할 스크래치 메모리를 할당할 것입니다.

00:08:58.000 --> 00:09:08.000
이 메모리는 GPU에서만 액세스해야 하기 때문에, 메탈 장치에서 개인 스토리지 모드 버퍼를 할당하여 이 작업을 수행할 수 있습니다.

00:09:08.000 --> 00:09:12.000
이제 당신은 실제로 가속 구조를 구축할 준비가 되었습니다.

00:09:12.000 --> 00:09:18.000
빌드 작업을 예약하면, 메탈은 GPU에서 당신을 위해 가속을 구축할 것입니다.

00:09:18.000 --> 00:09:24.000
가속 구조 명령 인코더를 사용하여 이것을 합니다.

00:09:24.000 --> 00:09:30.000
이 인코더에는 가속 구조를 구축하고 수정하는 데 사용할 수 있는 몇 가지 방법이 있습니다.

00:09:30.000 --> 00:09:37.000
이 경우, 대상 가속 구조, 설명자 및 스크래치 버퍼로 빌드 메소드를 호출하십시오.

00:09:37.000 --> 00:09:45.000
금속은 기하학을 위한 원시적인 가속 구조를 구축할 것이며, 후속 GPU 명령에서 사용할 수 있습니다.

00:09:45.000 --> 00:09:51.000
그것이 원시적인 가속 구조로 장면의 기하학을 표현할 수 있는 방법입니다.

00:09:51.000 --> 00:09:57.000
더 큰 장면으로 확장할 수 있도록, 메탈은 또한 인스턴스 가속 구조를 지원합니다.

00:09:57.000 --> 00:10:07.000
모아나 섬 장면과 같은 복잡하고 상세한 환경을 하나의 원시 가속 구조로 저장하려면 엄청난 양의 메모리가 필요할 것이다.

00:10:07.000 --> 00:10:19.000
하지만 이 복잡한 장면은 수천 그루의 나무, 수백만 개의 나뭇잎 및 기타 물체에 반복적인 구조를 가지고 있으며, 이는 장면을 효율적으로 렌더링하기 위해 악용될 수 있다.

00:10:19.000 --> 00:10:28.000
산, 산호, 나무를 포함한 장면의 모든 독특한 물체는 원시적인 가속 구조로 표현될 수 있다.

00:10:28.000 --> 00:10:34.000
이것들은 전체 장면을 나타내는 인스턴스 가속 구조로 결합될 수 있다.

00:10:34.000 --> 00:10:50.000
따라서 원시 가속 구조는 기하학을 포함하는 반면, 인스턴스 가속 구조는 전체 장면을 구성하기 위해 다른 위치, 크기 및 방향으로 변환된 다른 가속 구조에 대한 참조를 포함한다.

00:10:50.000 --> 00:10:56.000
각 인스턴스에는 장면에서 참조하는 가속 구조를 배치하기 위한 변환 매트릭스가 있다.

00:10:56.000 --> 00:11:03.000
인스턴스 가속 구조를 구축하는 것은 원시 가속 구조를 구축하는 것과 비슷하다.

00:11:03.000 --> 00:11:06.000
당신은 설명자를 만드는 것으로 시작할 것입니다.

00:11:06.000 --> 00:11:18.000
이번에는 기하학 대신 참조하는 가속 구조와 장면에 배치하는 변환 매트릭스와 같은 각 인스턴스에 대한 정보를 포함하는 버퍼를 제공합니다.

00:11:18.000 --> 00:11:27.000
그런 다음 원시적인 가속 구조를 구축하는 것과 같은 방식으로 GPU에 가속 구조를 구축하십시오.

00:11:27.000 --> 00:11:36.000
설명자를 만들려면, MTL 인스턴스 가속 구조 설명자를 구성하고 포함할 인스턴스 수를 설정하십시오.

00:11:36.000 --> 00:11:48.000
그런 다음 인스턴스에서 참조할 수 있는 기본 가속 구조의 배열을 제공하고, 인스턴스 버퍼에 포함될 인스턴스 설명자의 유형을 지정하십시오.

00:11:48.000 --> 00:11:55.000
금속은 사용 사례에 따라 선택할 수 있는 몇 가지 인스턴스 설명자 유형을 제공합니다.

00:11:55.000 --> 00:12:01.000
가속 구조의 인스턴스를 두 단계로 구성할 것입니다.

00:12:01.000 --> 00:12:06.000
먼저, 인스턴스별 데이터를 저장하기 위해 버퍼를 할당하세요.

00:12:06.000 --> 00:12:17.000
이 버퍼의 크기는 인스턴스 수와 각 인스턴스 설명자의 크기에 따라 다르지만, 다른 메탈 버퍼와 마찬가지로 할당됩니다.

00:12:17.000 --> 00:12:23.000
버퍼를 할당하면, 인스턴스 가속 구조 설명자에 할당하세요.

00:12:23.000 --> 00:12:31.000
다음으로 가속 구조의 모든 인스턴스에 대한 정보로 인스턴스 버퍼를 채울 것입니다.

00:12:31.000 --> 00:12:39.000
각 인스턴스에 대해, 설명자를 만들고 이 인스턴스가 참조하는 가속 구조를 지정하십시오.

00:12:39.000 --> 00:12:48.000
인스턴스 가속 구조 설명자에 설정한 배열에 인덱스가 있는 가속 구조를 식별할 것입니다.

00:12:48.000 --> 00:12:59.000
각 인스턴스에는 사용 중인 인스턴스 설명자 유형에 따라 변환 매트릭스, 가시성 마스크 및 기타 속성이 있습니다.

00:12:59.000 --> 00:13:07.000
마지막 단계는 원시 가속 구조와 동일한 과정인 실제 가속 구조를 구축하는 것이다.

00:13:07.000 --> 00:13:10.000
빌드가 CPU에서 실행되기 전의 모든 단계.

00:13:10.000 --> 00:13:17.000
하지만 인스턴스 수가 많으면, 인스턴스 버퍼를 채우는 과정은 컴퓨팅 집약적이 될 수 있다.

00:13:17.000 --> 00:13:27.000
인스턴스 설명자는 일반 금속 버퍼에 저장되기 때문에, GPU에서 이러한 설명자를 작성하여 이 단계를 가속화할 수 있습니다.

00:13:27.000 --> 00:13:38.000
작업을 GPU에 넘기기 전에 가속 구조에 얼마나 많은 인스턴스가 포함될지 아는 한, 이것은 GPU 가속을 위한 좋은 기회입니다.

00:13:38.000 --> 00:13:48.000
하지만 인스턴스 컬링과 같은 것을 하고 싶다면, 설명자에서 최종 인스턴스 수를 설정할 수 있도록 CPU에서 인스턴스를 제거해야 합니다.

00:13:48.000 --> 00:13:55.000
올해 새로운, 새로운 간접 인스턴스 가속 구조 설명자로 GPU에서 이 프로세스를 구동할 수 있습니다.

00:13:55.000 --> 00:14:04.000
이 간접 설명자를 사용하면 인스턴스를 제거하고, 인스턴스 버퍼를 채우고, GPU에서 최종 인스턴스 수를 완전히 설정할 수 있습니다.

00:14:04.000 --> 00:14:12.000
GPU 기반 가속 구조 빌드를 수행하려면, 간접 인스턴스 가속 구조 설명자를 만드세요.

00:14:12.000 --> 00:14:20.000
설명자의 최대 인스턴스 수와 GPU에서 최종 인스턴스 수를 쓸 버퍼를 설정하십시오.

00:14:20.000 --> 00:14:28.000
그런 다음 인스턴스 설명자 버퍼를 설정하기만 하면 GPU에서 인스턴스를 구성할 수 있습니다.

00:14:28.000 --> 00:14:32.000
인스턴스 버퍼에서 다른 유형의 설명자를 사용할 것입니다.

00:14:32.000 --> 00:14:44.000
간접 인스턴스 설명자는 단순히 설명자에 할당하여 인스턴스되는 가속 구조를 식별할 수 있다는 점을 제외하고는 직접 인스턴스 설명자와 유사합니다.

00:14:44.000 --> 00:14:48.000
그것이 당신이 인스턴스 가속 구조를 만드는 방법입니다.

00:14:48.000 --> 00:14:52.000
지금까지, 나는 2단계 인스탠싱 모델에 대해 이야기했다.

00:14:52.000 --> 00:14:59.000
이 모델에서, 모아나 섬 장면의 숲은 수천 개의 다른 나무로 구성되어 있다.

00:14:59.000 --> 00:15:05.000
하지만 우리가 더 깊이 파고들면, 나무 자체는 같은 잎의 많은 복사본이 있는 줄기이다.

00:15:05.000 --> 00:15:11.000
새로운 다단계 인스턴싱 기능을 사용하여 이 구조를 활용할 수 있습니다.

00:15:11.000 --> 00:15:22.000
다단계 인스턴스를 통해 인스턴스 가속 구조는 원시 가속 구조뿐만 아니라 다른 인스턴스 가속 구조도 포함할 수 있다.

00:15:22.000 --> 00:15:37.000
예를 들어, 이 장면에서 야자수는 줄기와 잎의 인스턴스를 포함하는 인스턴스 가속 구조로 표현될 수 있는 반면, 장면 전체는 야자수의 인스턴스를 포함할 수 있다.

00:15:37.000 --> 00:15:43.000
모아나 섬 장면은 다단계 이스탄불의 힘의 좋은 예이다.

00:15:43.000 --> 00:15:53.000
두 단계의 인스턴싱을 사용할 때, 한 장면에 한 유형의 나무를 추가하는 것은 나무 부분의 수백 또는 수천 개의 복사본을 추가하는 것을 의미할 수 있다.

00:15:53.000 --> 00:16:01.000
하지만 다단계 인스턴스를 사용하면 부분의 반복되는 인스턴스로 정의된 복잡한 트리의 인스턴스를 추가할 수 있습니다.

00:16:01.000 --> 00:16:06.000
이것은 모아나 섬 장면에서 수백만 개의 사례를 저장한다.

00:16:06.000 --> 00:16:10.000
하지만 다단계 인스턴싱은 프로덕션 렌더러만을 위한 것이 아니다.

00:16:10.000 --> 00:16:16.000
그것은 또한 게임과 같은 실시간 앱에도 가치가 있다.

00:16:16.000 --> 00:16:22.000
게임은 또한 게임 객체의 인스턴스에서 세계를 구축하는 2단계 가속 구조 패턴을 사용한다.

00:16:22.000 --> 00:16:26.000
그러나, 게임은 프로덕션 렌더러와 다르다.

00:16:26.000 --> 00:16:34.000
프로덕션 렌더러는 객체를 재사용하기 위해 깊은 계층을 사용하지만, 게임은 게임 객체에 대한 긴 인스턴스 목록을 사용합니다.

00:16:34.000 --> 00:16:46.000
게임은 또한 동적 콘텐츠를 위해 각 프레임의 인스턴스 가속 구조를 재구성하며, 높은 인스턴스 수는 재구성을 위한 많은 GPU 시간을 의미합니다.

00:16:46.000 --> 00:16:52.000
그러나 게임에서는 많은 콘텐츠가 정적이며 모든 프레임을 업데이트할 필요가 없습니다.

00:16:52.000 --> 00:17:02.000
세상을 정적 및 동적 가속 구조로 분할하여 가속 구조 업데이트를 변경되는 콘텐츠로만 제한할 수 있습니다.

00:17:02.000 --> 00:17:08.000
이것은 일반적으로 정적 콘텐츠보다 훨씬 적은 동적 콘텐츠만 재구성하는 것을 의미합니다.

00:17:08.000 --> 00:17:18.000
정적 및 동적 콘텐츠의 분할을 적용할 때, 레이 트래버셜의 추가 비용과 계층 구조의 깊이의 균형을 맞추는 것이 중요합니다.

00:17:18.000 --> 00:17:32.000
가속 구조 건물과 레이 트레이싱이 있는 프레임에서 3단계의 인스턴싱을 사용하면 추적 시간에 약간의 영향만으로 빌드 시간을 줄일 수 있으며, 전반적으로 프레임 시간을 줄일 수 있습니다.

00:17:32.000 --> 00:17:38.000
다단계 인스턴스는 메모리 사용량을 줄이고 재구축 속도를 높이는 훌륭한 도구입니다.

00:17:38.000 --> 00:17:42.000
금속 광선 추적 앱을 최적화할 수 있는 다른 방법도 있습니다.

00:17:42.000 --> 00:17:46.000
그 중 하나는 빌드 병렬화이다.

00:17:46.000 --> 00:17:55.000
일반적인 응용 프로그램은 다른 장면과 장면의 다른 부분을 나타내는 많은 가속 구조를 구축하거나 업데이트해야 합니다.

00:17:55.000 --> 00:18:01.000
이러한 빌드를 병렬로 실행하여 시동 시간을 크게 줄일 수 있습니다.

00:18:01.000 --> 00:18:10.000
할 수 있을 때마다, 여러 빌드를 동일한 명령 인코더에 인코딩하여 빌드를 일괄 처리하여 병렬로 실행할 수 있도록 하십시오.

00:18:10.000 --> 00:18:17.000
작업 세트가 메모리에 맞는지 확인하면서 가능한 한 많은 빌드를 병렬화하고 싶을 것입니다.

00:18:17.000 --> 00:18:24.000
또한 가속 구조 구축이 완료된 후에는 스크래치 버퍼가 더 이상 필요하지 않다는 것을 기억하십시오.

00:18:24.000 --> 00:18:32.000
이것은 가속 구조의 한 배치에서 다음 배치로 스크래치 버퍼를 재사용할 수 있다는 것을 의미합니다.

00:18:32.000 --> 00:18:39.000
때때로 가속 구조를 재건하는 데 소요되는 시간을 줄이는 가장 좋은 방법은 재건을 완전히 피하는 것이다.

00:18:39.000 --> 00:18:43.000
이것은 가속 구조 재조정이 들어오는 곳이다.

00:18:43.000 --> 00:18:49.000
메탈이 가속 구조를 만들 때, 근처의 프리미티브를 상자의 계층 구조로 그룹화한다.

00:18:49.000 --> 00:18:58.000
원시인이 움직이면, 그 상자들은 더 이상 장면을 정확하게 나타내지 않으며, 가속 구조를 업데이트해야 합니다.

00:18:58.000 --> 00:19:04.000
하지만 기하학이 약간만 바뀌면, 계층 구조는 여전히 합리적일 수 있다.

00:19:04.000 --> 00:19:16.000
처음부터 새로운 가속 구조를 만드는 대신, 금속은 기하학에서 원시의 새로운 위치를 반영하기 위해 기존 가속 구조를 재장착할 수 있습니다.

00:19:16.000 --> 00:19:21.000
이것은 가속 구조를 처음부터 재건하는 것보다 저렴하다.

00:19:21.000 --> 00:19:25.000
리핏은 빌드 작업과 같은 스크래치 버퍼가 필요하다.

00:19:25.000 --> 00:19:32.000
리핏 스크래치 버퍼의 크기는 가속 구조를 할당하기 위해 이전에 사용한 것과 동일한 구조체에 있습니다.

00:19:32.000 --> 00:19:39.000
수리 작업은 GPU에서 실행되며 가속 구조 명령 인코더로 인코딩됩니다.

00:19:39.000 --> 00:19:44.000
수리는 제자리에서 또는 다른 가속 구조로 작동할 수 있다.

00:19:44.000 --> 00:19:51.000
마지막으로, 압축은 메모리에서 가속 구조의 크기를 줄이는 좋은 방법입니다.

00:19:51.000 --> 00:20:01.000
가속 구조를 처음 만들 때, 메탈은 얼마나 많은 메모리가 필요한지 정확히 알 수 없기 때문에 보수적인 추정치를 만들어야 한다.

00:20:01.000 --> 00:20:08.000
가속 구조를 구축하면, 금속은 그것을 나타내는 데 필요한 최소 크기를 계산할 수 있습니다.

00:20:08.000 --> 00:20:19.000
압축을 사용하면 최소 크기로 새로운 가속 구조를 할당한 다음 GPU를 사용하여 현재 가속 구조에서 새 구조로 복사할 수 있습니다.

00:20:19.000 --> 00:20:24.000
이것은 원시 가속 구조에 특히 가치가 있다.

00:20:24.000 --> 00:20:31.000
압축을 사용하려면, 명령을 인코딩하여 GPU에서 가속 구조의 압축된 크기를 계산하십시오.

00:20:31.000 --> 00:20:38.000
명령을 실행할 때, Metal은 당신이 제공하는 버퍼에 압축된 크기를 쓸 것입니다.

00:20:38.000 --> 00:20:50.000
압축된 크기를 읽으면, 그 크기로 새로운 가속 구조를 할당한 다음 오래된 가속 구조에서 새로운 가속 구조로 "복사 및 압축" 작업을 인코딩할 수 있습니다.

00:20:50.000 --> 00:20:55.000
이 명령 버퍼가 완료되면, 원래 가속 구조를 해제할 수 있습니다.

00:20:55.000 --> 00:21:04.000
메탈 레이 트레이싱 앱 최적화에 대해 자세히 알아보려면, 2022년 "메탈 레이 트레이싱 성능 극대화" 세션을 확인하세요.

00:21:04.000 --> 00:21:14.000
이 섹션에서는 인스탠딩을 설정하고, 새로운 다단계 인스탠딩 기능을 활용하고, 대규모로 인스탠딩을 처리하는 방법에 대해 논의했습니다.

00:21:14.000 --> 00:21:19.000
이제 그 장면과 광선을 교차할 시간이다.

00:21:19.000 --> 00:21:24.000
메탈에서는 명령의 일부로 실행되는 GPU 기능에서 광선을 교차합니다.

00:21:24.000 --> 00:21:35.000
Apple Silicon에서는 컴퓨팅 및 렌더링 명령 모두에서 광선을 교차할 수 있으며, AMD와 Intel에서는 컴퓨팅 명령에서 광선을 교차할 수 있습니다.

00:21:35.000 --> 00:21:41.000
광선을 교차할 준비를 하려면, 명령 인코더에 가속 구조를 바인딩하세요.

00:21:41.000 --> 00:21:47.000
이제 GPU 기능에서 이 가속 구조와 광선을 교차할 수 있습니다.

00:21:47.000 --> 00:21:54.000
가속 구조 매개 변수로 함수를 선언하고, 인터섹터 객체를 만드세요.

00:21:54.000 --> 00:22:00.000
이 인터섹터에서 속성을 설정하여 최상의 성능을 위해 레이 교차로를 구성할 수 있습니다.

00:22:00.000 --> 00:22:12.000
광선을 장면과 교차하려면, 광선을 만들고 인터섹터 물체의 교차 메서드를 호출하여 광선과 가속 구조를 매개 변수로 전달하기만 하면 됩니다.

00:22:12.000 --> 00:22:24.000
이것은 교차하는 원시 광선의 종류, 교차로까지의 거리, 원시의 ID 등과 같이 교차로에 대해 알아야 할 모든 것을 반환합니다.

00:22:24.000 --> 00:22:32.000
삼각형 교차점에 대한 더 많은 정보를 얻으려면, 인터섹터와 "교차 결과" 유형에 "삼각형 데이터" 태그를 추가하세요.

00:22:32.000 --> 00:22:39.000
이것은 교차로 결과에서 삼각형 무게중심 좌표를 사용할 수 있게 한다.

00:22:39.000 --> 00:22:44.000
그것은 원시적인 가속 구조로 교차하는 광선을 다룬다.

00:22:44.000 --> 00:22:50.000
인스턴스 가속 구조와 교차하는 광선은 매우 유사하다.

00:22:50.000 --> 00:23:07.000
원시 가속 구조를 바인딩하는 것과 같은 방식으로 인스턴스 가속 구조를 바인딩하고, useResource 또는 useHeap을 호출하여 GPU에서 인스턴스 가속 구조에서 참조된 가속 구조를 사용할 수 있도록 하십시오.

00:23:07.000 --> 00:23:16.000
레이를 인스턴스 가속 구조와 교차하려면 GPU 기능을 몇 가지만 변경하면 됩니다.

00:23:16.000 --> 00:23:21.000
먼저 가속 구조 유형에 인스턴스 태그를 추가하세요.

00:23:21.000 --> 00:23:27.000
그런 다음 인터섹터와 "교차 결과"에 인스타싱 및 "최대 레벨" 태그를 추가하세요.

00:23:27.000 --> 00:23:34.000
"최대 레벨" 태그는 가속 구조의 인스턴싱 레벨 수를 지정합니다.

00:23:34.000 --> 00:23:42.000
예를 들어, 모아나 섬 장면을 나타내는 가속 구조는 3단계 가속 구조이다.

00:23:42.000 --> 00:23:47.000
첫 번째 수준은 전체 장면을 포함하는 인스턴스 가속 구조이다.

00:23:47.000 --> 00:23:52.000
두 번째 층에는 산호, 나무, 그리고 지형의 사례가 있다.

00:23:52.000 --> 00:23:58.000
세 번째 층에는 잎, 꽃, 줄기와 같은 나무 부분의 사례가 있다.

00:23:58.000 --> 00:24:06.000
광선이 이 장면과 교차할 때, 그것은 프리미티브뿐만 아니라 프리미티브를 포함하는 인스턴스와도 교차한다.

00:24:06.000 --> 00:24:15.000
광선이 이 나무의 잎과 교차하면, 그것은 또한 나무의 인스턴스와 나무의 잎의 인스턴스와 교차한다.

00:24:15.000 --> 00:24:21.000
메탈은 교차된 각 인스턴스의 ID를 기록하여 이를 추적합니다.

00:24:21.000 --> 00:24:32.000
이 경우, 첫 번째 교차 인스턴스는 ID가 6인 트리이고, 두 번째 교차 인스턴스는 ID가 1인 리프입니다.

00:24:32.000 --> 00:24:35.000
광선은 또한 단 하나의 사례만 교차할 수 있다.

00:24:35.000 --> 00:24:42.000
예를 들어, 광선이 지형과 교차한다면, 메탈은 지형 인스턴스의 ID만 기록할 것이다.

00:24:42.000 --> 00:24:50.000
교차된 인스턴스의 수와 교차된 인스턴스의 ID를 교차점 결과에서 찾을 수 있습니다.

00:24:50.000 --> 00:24:57.000
그것이 당신이 광선을 원시 가속 구조 및 인스턴스 가속 구조와 교차할 수 있는 방법입니다.

00:24:57.000 --> 00:25:01.000
곡선 프리미티브를 사용할 때 명심해야 할 몇 가지 사항이 있습니다.

00:25:01.000 --> 00:25:08.000
기본적으로, 메탈은 레이 교차를 수행할 때 곡선 프리미티브를 사용하지 않는다고 가정합니다.

00:25:08.000 --> 00:25:15.000
인터섹터 객체에 기하학 유형을 설정하여 곡선을 사용하고 있다고 메탈에게 말할 수 있습니다.

00:25:15.000 --> 00:25:19.000
기하학 유형을 설정하면, 곡선을 교차할 준비가 된 것입니다.

00:25:19.000 --> 00:25:24.000
이전과 마찬가지로, 교차로 결과에서 교차로에 대한 정보를 찾으세요.

00:25:24.000 --> 00:25:31.000
"곡선 데이터" 태그를 사용하면, 교차 결과에는 곡선 매개 변수도 포함됩니다.

00:25:31.000 --> 00:25:38.000
이것은 광선과 교차하는 곡선을 따라 점을 계산하기 위해 곡선의 기본 함수에 연결할 수 있는 값입니다.

00:25:38.000 --> 00:25:43.000
이 기능들은 금속 음영 언어에서 당신을 위해 구현됩니다.

00:25:43.000 --> 00:25:47.000
금속 셰이딩 언어 사양에서 더 많은 것을 배울 수 있습니다.

00:25:47.000 --> 00:25:52.000
많은 응용 분야에서, 곡선 기하학은 단 한 종류의 곡선으로 표현된다.

00:25:52.000 --> 00:25:59.000
예를 들어, 장면의 모든 곡선은 원형 단면이 있는 입방 베지어 곡선으로 표현될 수 있습니다.

00:25:59.000 --> 00:26:08.000
이 경우, 인터섹터 객체에서 곡선의 속성을 설정하여 장면이 어떤 종류의 곡선을 사용하는지 메탈에게 알 수 있습니다.

00:26:08.000 --> 00:26:12.000
이를 통해 곡선 프리미티브를 사용할 때 최고의 성능을 얻을 수 있습니다.

00:26:12.000 --> 00:26:16.000
그것이 당신이 당신의 장면과 광선을 교차할 수 있는 방법입니다.

00:26:16.000 --> 00:26:22.000
그리고 Xcode를 사용하여 레이 트레이싱 워크로드를 디버깅하고 프로파일링할 수 있습니다.

00:26:22.000 --> 00:26:27.000
디버그하기 어려운 문제를 다룰 때 사용할 수 있는 도구 중 하나는 셰이더 검증입니다.

00:26:27.000 --> 00:26:35.000
셰이더에서 런타임 검사를 수행하고 충돌이나 손상으로 이어질 수 있는 문제를 포착합니다.

00:26:35.000 --> 00:26:41.000
셰이더 검증은 이제 최신 레이 트레이싱 기능을 포함한 모든 금속 API를 다룹니다.

00:26:41.000 --> 00:26:47.000
게다가, 셰이더 검증은 셰이더 컴파일 시간에 미치는 영향을 크게 줄였다.

00:26:47.000 --> 00:26:55.000
이것은 레이 트레이싱 애플리케이션에서 흔히 볼 수 있는 것과 같이 길고 복잡한 셰이더로 작업할 때 매우 유용합니다.

00:26:55.000 --> 00:27:00.000
당신을 도울 수 있는 또 다른 도구는 최첨단 가속 구조 뷰어입니다.

00:27:00.000 --> 00:27:04.000
교차로 테스트에 사용하는 장면을 검사할 수 있습니다.

00:27:04.000 --> 00:27:16.000
가속 구조 뷰어를 열면, 가속 구조의 개별 빌딩 블록을 기하학 프리미티브까지 탐색하기 위한 왼쪽의 윤곽을 얻습니다.

00:27:16.000 --> 00:27:21.000
여기서, 그것은 삼각형 기하학을 구성하는 개별 삼각형을 나열한다.

00:27:21.000 --> 00:27:29.000
오른쪽에는 다양한 강조 모드에서 가속 구조를 검사할 수 있는 뷰포트가 있습니다.

00:27:29.000 --> 00:27:41.000
예를 들어, "Axis-Aligned Bounding Box Traversals" 강조 모드는 더 비싼 교차로 테스트에 해당하는 더 깊은 수준의 횡단이 있는 영역을 시각화할 수 있습니다.

00:27:41.000 --> 00:27:50.000
내가 장면 위로 포인터를 움직일 때, 검사관은 광선이 뾰족한 방향으로 칠 교차로의 수를 업데이트한다.

00:27:50.000 --> 00:27:53.000
또 다른 예는 가속 구조 하이라이트 모드이다.

00:27:53.000 --> 00:27:58.000
이것은 가속 구조를 다른 색상으로 시각화한다.

00:27:58.000 --> 00:28:04.000
가속 구조 뷰어는 새로운 다단계 인스턴싱 기능과 곡선 형상을 지원합니다.

00:28:04.000 --> 00:28:13.000
뷰포트에서 카메라를 움직일 때, 일부 나무의 인스턴스 가속 구조와 일부 단풍의 곡선을 찾을 수 있습니다.

00:28:13.000 --> 00:28:20.000
가속 구조를 식별하기 위해, 뷰포트를 클릭하여 개요에 표시할 수 있습니다.

00:28:20.000 --> 00:28:25.000
이제, 이 야자수 잎의 가속 구조를 자세히 살펴보세요.

00:28:25.000 --> 00:28:30.000
이 가속 구조에서, 손바닥 잎은 곡선으로 구성되어 있다.

00:28:30.000 --> 00:28:36.000
뷰포트를 원시 하이라이트 모드로 변경하여 곡선 세그먼트를 시각화할 수 있습니다.

00:28:36.000 --> 00:28:41.000
곡선 세그먼트를 더 잘 검사하기 위해, 나는 조금 확대할 것이다.

00:28:41.000 --> 00:28:48.000
이전 장면에서 가속 구조를 선택하는 것과 유사하게, 여기서 각 세그먼트를 클릭하여 선택할 수 있습니다.

00:28:48.000 --> 00:28:54.000
레이 트레이싱 워크로드를 검사할 때 사용할 수 있는 또 다른 유용한 도구는 셰이더 디버거입니다.

00:28:54.000 --> 00:28:58.000
이것은 셰이더 코드의 문제를 해결하는 데 도움이 될 수 있습니다.

00:28:58.000 --> 00:29:03.000
여기, 저는 셰이더에서 교차 테스트를 수행하는 컴퓨팅 디스패치에 있습니다.

00:29:03.000 --> 00:29:13.000
셰이더 디버깅을 시작하려면 셰이더 디버깅 버튼을 누르고, 팝오버에서 스레드를 선택한 다음, 디버그 버튼을 클릭할 수 있습니다.

00:29:13.000 --> 00:29:21.000
데이터 수집이 완료되면, 셰이더 실행 중 언제든지 각 변수의 값을 검사할 수 있습니다.

00:29:21.000 --> 00:29:25.000
원시 ID의 값을 자세히 살펴보세요.

00:29:25.000 --> 00:29:31.000
더 많은 디버깅 컨텍스트를 제공하기 위해, 셰이더 디버거는 또한 이웃 스레드의 데이터를 제공합니다.

00:29:31.000 --> 00:29:39.000
여기서, 값 보기 위에 포인터를 올려놓아 동일한 스레드 그룹의 기본 ID를 검사할 수 있습니다.

00:29:39.000 --> 00:29:43.000
성능은 모든 앱의 또 다른 중요한 측면이다.

00:29:43.000 --> 00:29:54.000
프로파일링 타임라인은 레이 트레이싱 워크로드 성능에 대한 개요를 제공하여 다양한 성능 지표를 나란히 검사하고 상호 연관시킬 수 있습니다.

00:29:54.000 --> 00:30:00.000
또한, 워크로드의 모든 파이프라인 상태를 볼 수 있도록 디버그 네비게이터를 변경할 수 있습니다.

00:30:00.000 --> 00:30:08.000
그리고 셰이더 프로파일링 데이터로, 네비게이터는 가장 비싼 파이프라인 상태를 맨 위에 나열합니다.

00:30:08.000 --> 00:30:12.000
파이프라인 상태를 더 확장하면 셰이더 코드가 드러난다.

00:30:12.000 --> 00:30:22.000
셰이더를 연 후, 각 개별 셰이더가 실행 시간을 어디서 어떻게 보내는지에 대한 라인별 셰이더 프로파일링 통찰력을 얻을 수 있습니다.

00:30:22.000 --> 00:30:31.000
사이드바의 파이 차트 위로 포인터를 이동하면, 그 코드 줄의 비용에 대한 더 자세한 내역이 있는 팝오버가 표시됩니다.

00:30:31.000 --> 00:30:42.000
이 도구들은 메탈의 새로운 레이 트레이싱 기능을 모두 지원하며, 메탈 앱에서 작업할 때 훌륭한 디버깅 및 프로파일링 지원을 제공할 수 있습니다.

00:30:42.000 --> 00:31:02.000
메탈 레이 트레이싱은 또한 다음과 같은 더 많은 기능을 지원합니다: 프로덕션 렌더러에서 장면을 애니메이션화하기 위한 원시 및 인스턴스 모션, 사용자 지정 교차 기능, 알파 테스트와 같은 향상으로 레이 교차를 사용자 정의하기 위한, 쿼리 기반 API의 이식성을 위한 교차 쿼리.

00:31:02.000 --> 00:31:10.000
메탈 레이 트레이싱 API, 언어 및 도구는 게임 및 프로덕션 렌더러와 같은 실시간 렌더링 앱을 지원합니다.

00:31:10.000 --> 00:31:19.000
최신 메탈 레이 트레이싱 API를 사용하여 곡선과 같은 기하학을 포함한 원시 가속 구조를 사용하여 장면을 만들 수 있습니다.

00:31:19.000 --> 00:31:28.000
인스턴스화, 특히 새로운 다단계 인스턴스화 기능을 사용하면 더 크고 복잡한 장면으로 확장할 수 있습니다.

00:31:28.000 --> 00:31:33.000
GPU 기능은 메탈 레이 트레이싱 API를 직접 호출할 수 있습니다.

00:31:33.000 --> 00:31:38.000
그리고 마지막으로, Xcode는 앱을 디버깅하고 프로파일링하는 데 도움을 줄 수 있습니다.

00:31:38.000 --> 00:31:48.000
샘플 코드 및 문서뿐만 아니라 이러한 많은 주제를 더 자세히 다룬 이전 레이 트레이싱 회담을 확인하십시오.

00:31:48.000 --> 00:31:50.000
봐줘서 고마워.

00:31:50.000 --> 23:59:59.000
♪ ♪

