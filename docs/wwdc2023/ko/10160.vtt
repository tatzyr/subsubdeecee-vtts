WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:14.000
사람: 안녕하세요, "SwiftUI Performance의 신비화"에 오신 것을 환영합니다.

00:00:14.000 --> 00:00:22.000
SwiftUI를 사용하면 복잡하고 강력한 앱을 쉽게 만들 수 있으며, 목록과 테이블과 같은 다양한 기능과 복잡한 컨트롤을 제공합니다.

00:00:22.000 --> 00:00:28.000
이제 막 시작하고 앱이 그다지 복잡하지 않을 때, 성능 문제는 분명하지 않습니다.

00:00:28.000 --> 00:00:32.000
하지만 앱의 복잡성이 증가함에 따라, 성능이 더 중요해집니다.

00:00:32.000 --> 00:00:39.000
작은 문제는 증폭될 수 있으며, 프로토타입에서 잘 작동하는 코드는 프로덕션에서 잘 작동하지 않을 수 있습니다.

00:00:39.000 --> 00:00:52.000
이 세션은 SwiftUI에서 성능을 위한 정신적 모델을 구축하는 것에 관한 것입니다. 왜냐하면 개발 프로세스의 시작부터 빠른 코드를 작성하는 방법을 이해하면 앱이 더 복잡해짐에 따라 문제가 줄어들기 때문입니다.

00:00:52.000 --> 00:00:56.000
성능 문제를 해결하는 것과 관련된 피드백 루프를 살펴봅시다.

00:00:56.000 --> 00:00:58.000
성능 문제는 증상으로 시작된다.

00:00:58.000 --> 00:01:05.000
아마도 내비게이션 푸시가 느리거나, 애니메이션이 깨지거나, macOS에서 회전하는 대기 커서가 있을 것입니다.

00:01:05.000 --> 00:01:11.000
성능 문제를 식별할 때, 그것을 해결하기 위한 첫 번째 단계는 측정하는 것이다.

00:01:11.000 --> 00:01:16.000
증상이 존재한다는 것을 측정하고 확인하면, 그 원인을 파악하기 위해 노력하세요.

00:01:16.000 --> 00:01:24.000
이것은 종종 사물이 어떻게 작동해야 하는지에 대한 직관이 필요하기 때문에 이 루프의 더 까다로운 단계 중 하나가 될 수 있다.

00:01:24.000 --> 00:01:27.000
앱이 잘못된 가정을 할 때 버그가 발생합니다.

00:01:27.000 --> 00:01:33.000
이 세션은 앱의 가정과 현실 사이의 불일치를 식별하는 데 도움을 주는 것입니다.

00:01:33.000 --> 00:01:37.000
근본 원인을 확인한 후, 최적화를 통해 문제를 해결하세요.

00:01:37.000 --> 00:01:42.000
하지만 성능 문제는 근본 원인을 찾고 코드를 최적화한 후에 끝나지 않습니다.

00:01:42.000 --> 00:01:48.000
문제를 해결할 수 있도록 수정 사항을 다시 측정하고 재확인해야 합니다.

00:01:48.000 --> 00:01:53.000
이것은 모든 버그에 대한 좋은 관행이지만, 성능에 특히 중요하다.

00:01:53.000 --> 00:01:57.000
문제가 해결되었는지 확인한 후, 루프를 끊습니다.

00:01:57.000 --> 00:02:00.000
이 다이어그램은 이 세션을 맥락에 둔다.

00:02:00.000 --> 00:02:06.000
이상적으로, 당신은 이 주기에서 끝나지 않으며, 프로토타이핑할 때 빠른 코드를 작성하여 많은 성능 문제를 피할 수 있습니다.

00:02:06.000 --> 00:02:12.000
그러나, 앱이 더 복잡해짐에 따라 성능 버그가 생기는 것은 불가피합니다.

00:02:12.000 --> 00:02:14.000
그것은 우리 중 최고에게 일어난다.

00:02:14.000 --> 00:02:20.000
그리고 성능 문제가 발생할 때, 선별하고 고칠 수 있는 도구를 최대한 많이 사용하는 것이 좋습니다.

00:02:20.000 --> 00:02:24.000
이 세션은 루프를 더 쉽게 통과하는 것을 목표로 한다.

00:02:24.000 --> 00:02:28.000
이것은 고급 세션이며, 몇 가지 전제 조건이 있습니다.

00:02:28.000 --> 00:02:35.000
암시적 정체성과 명시적 정체성의 차이를 포함하여 SwiftUI 정체성을 간략하게 이해해야 합니다.

00:02:35.000 --> 00:02:41.000
보기 수명과 보기 정체성의 차이를 아는 것도 중요하다.

00:02:41.000 --> 00:02:43.000
이러한 전제 조건이 없다면, 초조해하지 마세요.

00:02:43.000 --> 00:02:49.000
WWDC21의 "Demystify SwiftUI" 세션이 당신을 다루었습니다.

00:02:49.000 --> 00:02:53.000
오늘의 세션은 그 세션이 중단된 곳에서부터 시작된다.

00:02:53.000 --> 00:02:55.000
안건을 검토해 봅시다.

00:02:55.000 --> 00:03:00.000
우리는 종속성에 대한 심층적인 논의로 시작하고 SwiftUI 업데이트 프로세스를 자세히 살펴볼 것입니다.

00:03:00.000 --> 00:03:06.000
다음으로, 업데이트와 SwiftUI가 인터페이스를 업데이트하는 속도를 개선하는 방법에 대한 논의로 넘어가겠습니다.

00:03:06.000 --> 00:03:11.000
그리고 마지막으로, 우리는 목록과 표에서 정체성에 대해 논의할 것이다.

00:03:11.000 --> 00:03:17.000
그 과정에서, 우리는 SwiftUI의 후드 아래를 들여다보고 개발할 때 사용할 몇 가지 팁과 요령을 확인할 것입니다.

00:03:17.000 --> 00:03:26.000
이 세션은 주로 뷰 계층 구조에 대한 느린 업데이트와 관련이 있지만, 앱을 개발할 때 발생할 수 있는 모든 성능 문제를 철저히 살펴보는 것은 아닙니다.

00:03:26.000 --> 00:03:29.000
종속성으로 시작합시다.

00:03:29.000 --> 00:03:35.000
마지막 "Demystify SwiftUI" 세션 이후 몇 년이 지났고, 나는 개를 테마로 한 앱 작업을 놓쳤다.

00:03:35.000 --> 00:03:43.000
그래서 그 세션의 테마를 계속하면서, 나는 내가 가장 좋아하는 털복숭이 친구들을 추적하고 그들과 놀 시간을 설정할 수 있는 새로운 앱을 작업하고 있다.

00:03:43.000 --> 00:03:46.000
여기 전망 중 하나가 있습니다, 모든 개들을 보여주는 테이블입니다.

00:03:46.000 --> 00:03:57.000
이 앱은 또한 iPhone에 표시된 세부 보기를 가지고 있으며, 각 개의 더 큰 그림, 개의 선호도를 보여주며, 플레이할 시간을 설정할 수 있는 버튼을 제공합니다.

00:03:57.000 --> 00:03:59.000
여기 같은 견해에 대한 코드가 있습니다.

00:03:59.000 --> 00:04:05.000
그 뷰는 개를 매개 변수로 받아들이고 또한 그것이 놀이 시간인지 알 수 있는 환경 속성을 가지고 있다.

00:04:05.000 --> 00:04:14.000
이전 Demystify 세션에서 언급했듯이, 이것은 개와 놀이 시간 변수가 보기의 종속성이라는 것을 의미하며, 이 보기를 보여주는 또 다른 방법은 그래프입니다.

00:04:14.000 --> 00:04:18.000
여기 거의 같은 견해를 나타내는 기본 그래프가 있습니다.

00:04:18.000 --> 00:04:21.000
각 화살표는 뷰의 몸을 나타낸다.

00:04:21.000 --> 00:04:23.000
개 전망은 더미를 만든다.

00:04:23.000 --> 00:04:30.000
그리고 스택에는 일부 텍스트, 확장 가능한 개 이미지, 세부 보기 및 버튼과 같은 여러 자식이 있습니다.

00:04:30.000 --> 00:04:38.000
계속해서, 각 뷰에는 자식이 있으며, 그래프는 이미지, 텍스트 또는 색상과 같은 리프 뷰에 도달할 때까지 계속됩니다.

00:04:38.000 --> 00:04:41.000
모든 견해는 궁극적으로 잎 견해로 해결된다.

00:04:41.000 --> 00:04:45.000
SwiftUI에는 많은 리프 뷰가 있으므로, 나는 여기서 그것들을 모두 다루지 않을 것이다.

00:04:45.000 --> 00:04:49.000
더 많은 정보를 위해 문서를 확인하세요.

00:04:49.000 --> 00:04:51.000
앱으로 돌아가자.

00:04:51.000 --> 00:04:55.000
앱을 사용할 때마다, 친구 중 한 명과 놀 때마다 로그인할 수 있습니다.

00:04:55.000 --> 00:05:01.000
나는 방금 여기서 록키와 가져오기를 끝냈기 때문에, 버튼과 이미지를 업데이트하는 앱에 주목했다.

00:05:01.000 --> 00:05:05.000
록키는 꽤 행복해 보이지만, 그는 확실히 너무 피곤해서 지금 놀 수 없다.

00:05:05.000 --> 00:05:09.000
이 데이터가 모델에서 변경되면, SwiftUI는 이 보기를 업데이트합니다.

00:05:09.000 --> 00:05:16.000
그래프로 돌아가서 이 변화가 발생할 때 어떤 일이 일어나는지 살펴봐 업데이트 과정을 깊이 있게 살펴봅시다.

00:05:16.000 --> 00:05:17.000
여기 다시 우리의 그래프가 있습니다.

00:05:17.000 --> 00:05:24.000
이것은 이전 Demystify 세션이 중단한 곳이며, 보기가 그래프를 형성하고 SwiftUI가 코드를 평가할 때 종속성을 살펴본다는 것을 설명합니다.

00:05:24.000 --> 00:05:32.000
확대하여 이러한 종속성이 어디에서 왔는지, 그리고 어떻게 제어할 수 있는지에 대해 더 자세히 살펴봅시다.

00:05:32.000 --> 00:05:37.000
각 자식 뷰는 조상에 의해 생성되는 뷰 값에 의존한다.

00:05:37.000 --> 00:05:39.000
하지만 다른 형태의 의존성도 있다.

00:05:39.000 --> 00:05:42.000
동적 속성은 의존성의 일반적인 원천이기도 하다.

00:05:42.000 --> 00:05:48.000
예를 들어, DogView는 @Environment 속성 래퍼를 사용하여 환경의 재생 시간인지 여부를 읽습니다.

00:05:48.000 --> 00:05:55.000
그러므로, 그것은 부모가 생산한 가치와 환경의 가치 모두에 의존한다.

00:05:55.000 --> 00:06:02.000
X축에서 시간을 시각화하면, 업데이트 프로세스의 첫 번째 단계는 뷰에 대한 새로운 값을 생성하는 것입니다.

00:06:02.000 --> 00:06:09.000
이 값은 개 값과 동적 속성의 초기 값과 같은 뷰의 모든 저장된 속성을 포함합니다.

00:06:09.000 --> 00:06:16.000
다음으로, SwiftUI는 뷰의 모든 동적 속성을 업데이트하여 그래프의 현재 값으로 대체합니다.

00:06:16.000 --> 00:06:21.000
마지막으로, 업데이트된 값으로, 바디는 뷰의 자식을 생산하기 위해 실행된다.

00:06:21.000 --> 00:06:23.000
그래프를 다시 가져오자.

00:06:23.000 --> 00:06:30.000
이 과정은 인터페이스를 업데이트하기 위해 반복되며, 새로운 값이나 다른 변경된 종속성이 있는 보기만 업데이트합니다.

00:06:30.000 --> 00:06:38.000
우리가 록키를 피곤하다고 표시할 때, 우리는 새로운 개를 얻는다-- 미안해, 새로운 개 구조 값, 하지만 여전히 같은 록키야.

00:06:38.000 --> 00:06:43.000
우리의 데이터는 값 유형이기 때문에, 돌연변이가 있을 때 새로운 복사본이 생성됩니다.

00:06:43.000 --> 00:06:49.000
그리고 그 결과 DogView는 스택의 아이들을 업데이트하는 스택을 위한 새로운 콘텐츠를 생성한다.

00:06:49.000 --> 00:06:55.000
저는 여기서 ScalableDogImage에만 집중하고 있지만, 개 가치에 따라 다른 견해가 업데이트될 수 있습니다.

00:06:55.000 --> 00:06:59.000
ScalableDogImage는 결국 새로운 이미지를 생성한다.

00:06:59.000 --> 00:07:04.000
이미지는 리프 뷰이므로, 나머지 작업은 여기에서 SwiftUI에 의해 수행됩니다.

00:07:04.000 --> 00:07:08.000
그런 다음 그 과정이 끝나고, 새로운 렌더링이 생성된다.

00:07:08.000 --> 00:07:11.000
그것이 의존성 그래프를 보는 방법이다.

00:07:11.000 --> 00:07:13.000
이 과정을 개선하기 위한 몇 가지 팁을 살펴봅시다.

00:07:13.000 --> 00:07:17.000
필요한 것으로만 업데이트를 줄이는 것이 중요하다.

00:07:17.000 --> 00:07:22.000
보기가 언제 업데이트되는지 이해하기 위해, SwiftUI에는 printChanges 메소드가 있습니다.

00:07:22.000 --> 00:07:27.000
이를 통해 SwiftUI 그래프 평가자가 뷰의 본문을 호출한 이유를 인쇄할 수 있습니다.

00:07:27.000 --> 00:07:30.000
그것을 사용하는 방법의 예를 살펴봅시다.

00:07:30.000 --> 00:07:34.000
여기 우리는 상태를 포함하는 확장 가능한 개 이미지가 있습니다.

00:07:34.000 --> 00:07:41.000
우리가 이미지를 탭하면, 상태는 그렇게 변한다.

00:07:41.000 --> 00:07:53.000
이미지 보기에만 초점을 맞추고, LLDB 콘솔에서 보기 본문에 중단점을 설정하면 "표현식" LLDB 명령을 사용하여 Self._printChanges를 호출할 수 있습니다.

00:07:53.000 --> 00:08:00.000
printChanges는 SwiftUI가 뷰의 본문을 요청한 이유에 대한 최선의 설명을 제공하는 디버깅 전용 시설입니다.

00:08:00.000 --> 00:08:03.000
이 경우, 그것은 scaleToFill이 바뀌었기 때문이다.

00:08:03.000 --> 00:08:08.000
printChanges를 사용하여 보기에 추가 종속성이 있는지 여부를 이해할 수 있습니다.

00:08:08.000 --> 00:08:13.000
예를 들어, 저는 현재 앱을 실행하고 디버깅을 하고 있으며 이 보기에 추가 종속성이 있는지 확인하고 싶습니다.

00:08:13.000 --> 00:08:19.000
이 뷰의 본문에 printChanges에 대한 호출을 추가하여 뷰의 본문에 액세스할 때마다 인쇄할 수 있습니다.

00:08:19.000 --> 00:08:23.000
그러나, printChanges는 밑줄로 접두사를 붙입니다.

00:08:23.000 --> 00:08:33.000
이 경우, 즉, 항상 존재하는 것이 보장되지 않으며 향후 릴리스에서 제거될 수도 있으므로, 앱 스토어에 이 방법에 대한 호출을 제출하지 마십시오.

00:08:33.000 --> 00:08:35.000
나는 나중에 이 전화를 제거해야 할 것이다.

00:08:35.000 --> 00:08:38.000
그것은 디버깅만을 위한 것이며 런타임 성능에 영향을 미친다.

00:08:38.000 --> 00:08:48.000
내 앱을 다시 실행하고 록키가 가장 좋아하는 간식을 비스킷에서 오이와 같은 다른 것으로 바꾸면, 우리 이미지에서 콘솔에 로그인하는 것을 알 수 있다.

00:08:48.000 --> 00:08:49.000
그것은 "자아"가 바뀌었다고 말한다.

00:08:49.000 --> 00:08:58.000
이것은 뷰 값이 변경되었다는 것을 의미하므로, 확장 가능한 이미지 뷰는 치료에 어느 정도 의존해야 하지만, 실제로는 그럴 필요가 없습니다.

00:08:58.000 --> 00:09:03.000
코드에 초점을 맞추면, 뷰의 값에는 scaleToFill 멤버와 개 속성만 있습니다.

00:09:03.000 --> 00:09:12.000
scaleToFill은 SwiftUI 동적 속성이기 때문에, 변경되었다면 변경 로그에 표시되었을 것이므로, 여기서 "@Self"는 개 값이 변경되었음을 의미합니다.

00:09:12.000 --> 00:09:15.000
하지만 이 견해를 보면, 우리는 이미지에만 관심이 있다.

00:09:15.000 --> 00:09:19.000
그래서 우리는 대신 이미지만 사용하여 이 의존성을 제거할 수 있다.

00:09:19.000 --> 00:09:27.000
그리고 이제, 이미지와 관련이 없는 개의 속성을 변경할 때, 로그가 보이지 않습니다.

00:09:27.000 --> 00:09:29.000
뷰의 종속성은 범위가 빡빡하다.

00:09:29.000 --> 00:09:34.000
이 기술을 따른다면, printChanges 호출을 제거하는 것을 잊지 마세요.

00:09:34.000 --> 00:09:36.000
부모 보기를 일치하도록 업데이트합시다.

00:09:36.000 --> 00:09:38.000
여기 부모 개 보기의 코드가 있습니다.

00:09:38.000 --> 00:09:44.000
ScalableDogImage가 이미지를 찍기 위해 이니셜라이저를 업데이트해야 합니다.

00:09:44.000 --> 00:09:49.000
ScalableDogImage를 추출함으로써, 나는 중요한 것으로만 의존성을 줄였다.

00:09:49.000 --> 00:09:53.000
나는 헤더로도 똑같이 할 수 있고 그것을 자체 보기로 추출할 수 있다.

00:09:53.000 --> 00:09:55.000
이것은 많은 이점이 있다.

00:09:55.000 --> 00:10:01.000
이 코드는 이제 읽기가 더 쉽고, DogHeader의 종속성은 사용 사이트에서 분명합니다.

00:10:01.000 --> 00:10:05.000
이 기술은 작은 전망에 잘 작동하지만, 매우 큰 구조체에 주의하세요.

00:10:05.000 --> 00:10:08.000
모든 의존성이 이렇게 범위화될 자격이 있는 것은 아니다.

00:10:08.000 --> 00:10:11.000
당신은 최선의 판단을 내려야 할 것입니다.

00:10:11.000 --> 00:10:15.000
업데이트가 적다는 것은 앱에서 데이터가 변경될 때 더 나은 성능을 의미합니다.

00:10:15.000 --> 00:10:19.000
우리가 방금 탐구했듯이, 이것을 하는 한 가지 방법은 의존성을 줄이는 것이다.

00:10:19.000 --> 00:10:24.000
그들이 실제로 의존하는 데이터로만 보기 값을 줄이세요.

00:10:24.000 --> 00:10:28.000
또 다른 팁은 의존성을 줄이기 위해 뷰를 추출하는 것이다.

00:10:28.000 --> 00:10:36.000
그리고 마지막으로, 새로운 관찰 가능한 프로토콜은 종속성을 읽은 것으로만 자동으로 제한함으로써 종속성 범위 지정에 도움이 될 수 있다.

00:10:36.000 --> 00:10:41.000
자세한 내용은 "SwiftUI에서 관찰 발견" 세션을 확인하세요.

00:10:41.000 --> 00:10:44.000
그것은 의존성을 보는 방법에 대한 빠른 여행이었다.

00:10:44.000 --> 00:10:46.000
더 빠른 업데이트에 대해 이야기해 봅시다.

00:10:46.000 --> 00:10:51.000
이 섹션에서는 각 SwiftUI 업데이트 비용을 줄이는 방법에 대해 논의할 것입니다.

00:10:51.000 --> 00:10:58.000
느린 SwiftUI 업데이트는 중단 및 히치와 같은 응답성 감소를 포함하여 앱에 많은 부정적인 영향을 미칠 수 있습니다.

00:10:58.000 --> 00:11:04.000
중단은 처음에 나타나는 데 시간이 오래 걸리는 보기와 같이 사용자 상호 작용에 대한 응답 지연이다.

00:11:04.000 --> 00:11:17.000
WWDC2023의 "Analyze Hangs in Instruments" 세션은 SwiftUI 관련 작업으로 인해 중단이 발생할 수 있는지 여부를 식별하는 방법을 포함하여 Instruments를 사용하여 중단을 분석하는 방법에 대해 자세히 설명합니다.

00:11:17.000 --> 00:11:24.000
히치는 스크롤 중 일시 정지 또는 애니메이션의 프레임 건너뛰기와 같은 사용자가 인지할 수 있는 애니메이션 문제입니다.

00:11:24.000 --> 00:11:29.000
특히 SwiftUI에서 중단과 히치의 근본 원인은 종종 관련이 있다.

00:11:29.000 --> 00:11:38.000
시스템 렌더링 루프 작동 방식을 포함한 히치에 대한 자세한 내용은 "UI 애니메이션 히치 및 렌더링 루프 탐색" 기술 토크 비디오를 확인하세요.

00:11:38.000 --> 00:11:42.000
SwiftUI의 중단과 히치 모두 종종 느린 업데이트에서 비롯됩니다.

00:11:42.000 --> 00:11:45.000
이러한 느린 업데이트에는 여러 가지 일반적인 원인이 있다.

00:11:45.000 --> 00:11:52.000
첫 번째는 상태 객체를 할당하고 초기화하거나 상태를 초기화하는 것과 같은 값비싼 동적 속성 인스턴스화이다.

00:11:52.000 --> 00:11:54.000
또 다른 출처는 몸으로 하는 일이다.

00:11:54.000 --> 00:12:00.000
값비싼 문자열 보간이나 데이터 필터링 및 본문 내부의 기타 작업과 같은 작업을 확인하십시오.

00:12:00.000 --> 00:12:04.000
몸 자체가 가능한 한 저렴하다는 것이 중요하다.

00:12:04.000 --> 00:12:06.000
이것들은 모두 상호 연관되어 있다.

00:12:06.000 --> 00:12:12.000
예를 들어, 동적 속성은 뷰의 본문에서 계산될 수 있어, 뷰를 평가하는 데 비용이 많이 든다.

00:12:12.000 --> 00:12:16.000
느린 식별은 또한 뷰의 몸에서 자주 일어난다.

00:12:16.000 --> 00:12:20.000
가져오기 앱에서 예시를 보는 것으로 시작합시다.

00:12:20.000 --> 00:12:26.000
이 예에서, 저는 개 목록을 만드는 데 사용하는 객체가 있는 앱의 루트 뷰를 작업하고 있습니다.

00:12:26.000 --> 00:12:36.000
이 슬라이드의 코드 하이라이트에 따라, 신체의 model.dogs에 액세스하는 것은 객체를 게으르게 인스턴스화하여 개 목록을 가져오는 이니셜라이저로 가져옵니다.

00:12:36.000 --> 00:12:40.000
코드 주석이 말했듯이, 이것은 오랜 시간이 걸릴 수 있다.

00:12:40.000 --> 00:12:43.000
이건 동기식 작업이야.

00:12:43.000 --> 00:12:46.000
이것을 고치는 한 가지 방법은 작업 수정자를 사용하는 것이다.

00:12:46.000 --> 00:12:49.000
우리는 먼저 가져오기 비동기를 만들 것이다.

00:12:49.000 --> 00:12:52.000
나는 여기서 비동기 키워드의 추가만 보여주고 있다.

00:12:52.000 --> 00:12:58.000
다음으로, 작업 수정자에서, 우리는 그것을 기다리면서 개 목록을 비동기적으로 가져올 것이다.

00:12:58.000 --> 00:13:02.000
그렇게 하면, 앱은 값비싼 데이터 로딩 작업이 발생할 때 반응합니다.

00:13:02.000 --> 00:13:06.000
앱에 영향을 미치고 있다는 것을 깨닫지 못할 수도 있는 다른 작업 출처가 있습니다.

00:13:06.000 --> 00:13:13.000
예를 들어, 문자열 보간은 종종 비쌀 수 있으므로, 자주 사용해야 할 문자열을 캐시해야 합니다.

00:13:13.000 --> 00:13:17.000
마찬가지로, 번들에서 가치를 찾는 것은 비쌀 수 있다.

00:13:17.000 --> 00:13:22.000
그리고 물론, 클래스 바운드 유형과 같은 모든 힙 할당은 합산될 수 있다.

00:13:22.000 --> 00:13:24.000
목록과 테이블로 넘어갑시다.

00:13:24.000 --> 00:13:32.000
목록과 테이블은 간단한 레이아웃, 선택 추가, 스와이프 작업, 재정렬 지원 등을 넘어서는 풍부한 기능을 지원합니다.

00:13:32.000 --> 00:13:39.000
이것들은 복잡하고 고급 제어이며, 신원을 이해하는 것은 앱에서 잘 수행되도록 하는 데 중요합니다.

00:13:39.000 --> 00:13:47.000
이 섹션에서는 목록과 표의 신원에 대해 논의하고 이러한 내장 구성 요소에 대한 업데이트 성능을 극대화하는 방법을 설명할 것입니다.

00:13:47.000 --> 00:13:51.000
우리가 이 주제에 뛰어들기 전에, 나는 몇 가지 개선 사항에 대해 언급하고 싶다.

00:13:51.000 --> 00:13:59.000
macOS 소노마와 iOS 17에서 SwiftUI는 필터링 및 스크롤과 같은 경우에 대해 많은 최적화를 제공합니다.

00:13:59.000 --> 00:14:08.000
이러한 개선은 최소한의 노력으로 이루어질 수 있으며, 많은 경우 더 큰 목록과 테이블에 대한 반응성이 크게 향상되고 업데이트될 수 있습니다.

00:14:08.000 --> 00:14:14.000
그러나, 더 나은 성능을 가져오는 목록과 테이블을 구성하는 특정 방법이 있다.

00:14:14.000 --> 00:14:18.000
목록과 테이블은 데이터에 어떤 변화가 일어났는지 알기 위해 식별자를 사용합니다.

00:14:18.000 --> 00:14:22.000
일관성을 위해, 목록과 테이블의 모든 ID는 열심히 수집됩니다.

00:14:22.000 --> 00:14:30.000
따라서 목록과 표 내용에 대한 식별자를 빠르게 생성할 수 있는 것은 더 빠른 로드 및 업데이트 시간으로 직접 변환됩니다.

00:14:30.000 --> 00:14:37.000
ID는 SwiftUI가 보기 수명을 관리하는 데 도움이 되며, 이는 계층 구조에 대한 점진적인 업데이트에 매우 중요합니다.

00:14:37.000 --> 00:14:40.000
정체성의 변화는 견해가 바뀌었다는 것을 의미한다.

00:14:40.000 --> 00:14:43.000
이것은 애니메이션과 공연에 중요하다.

00:14:43.000 --> 00:14:48.000
애니메이션에 대한 자세한 내용은 "SwiftUI 애니메이션의 기초" 세션을 확인하세요.

00:14:48.000 --> 00:14:54.000
식별 성과는 특히 목록과 표에 대해 식별자가 자주 수집되기 때문에 중요하다.

00:14:54.000 --> 00:14:58.000
목록 식별 모델을 살펴봅시다.

00:14:58.000 --> 00:15:00.000
나는 앱의 개 목록에 대해 열심히 일해 왔다.

00:15:00.000 --> 00:15:03.000
나는 한 줄로 시작했어.

00:15:03.000 --> 00:15:07.000
여기 안에 하나의 DogCell이 있는 목록의 코드가 있습니다.

00:15:07.000 --> 00:15:11.000
다음 단계는 ForEach를 사용하여 모든 개를 반복하는 것이다.

00:15:11.000 --> 00:15:18.000
이 예는 간단하지만, 정체성과 직접적인 관련이 있으며, 목록에 ForEach를 추가하는 것은 성과를 평가하는 중요한 시간이다.

00:15:18.000 --> 00:15:23.000
이유를 이해하기 위해, 다음에 ForEach의 일반적인 서명을 살펴봅시다.

00:15:23.000 --> 00:15:26.000
이것은 SwiftUI의 ForEach 서명입니다.

00:15:26.000 --> 00:15:34.000
ForEach는 데이터 모음을 결과 보기 시퀀스에 매핑하여 각 보기에 대한 명시적인 정체성을 생성합니다.

00:15:34.000 --> 00:15:40.000
목록을 사용할 때, 표시할 행의 수와 각 행의 식별자가 무엇인지 파악해야 합니다.

00:15:40.000 --> 00:15:46.000
따라서, 그것은 데이터 수집을 미리 방문하여 각 요소의 ID를 결정합니다.

00:15:46.000 --> 00:15:49.000
콘텐츠 폐쇄는 각 뷰를 생성하기 위해 호출된다.

00:15:49.000 --> 00:15:51.000
행은 주문형으로 생성된다.

00:15:51.000 --> 00:15:56.000
리스트는 아이덴티티와 콘텐츠의 합성을 사용하여 목록 행을 생성합니다.

00:15:56.000 --> 00:16:04.000
주문형으로 생성된 행은 보이는 영역과 사전 가져오기 또는 접근성을 위한 일부 시스템 결정 버퍼와 관련이 있습니다.

00:16:04.000 --> 00:16:07.000
뷰가 스크롤됨에 따라, 더 많은 뷰가 존재하게 된다.

00:16:07.000 --> 00:16:11.000
여기 이 ForEach를 생성하는 코드 스니펫이 있습니다.

00:16:11.000 --> 00:16:18.000
콘텐츠는 내부에서 HStack을 사용하기 때문에 그 자체가 단일 보기인 DogCell이라는 점에 유의하십시오.

00:16:18.000 --> 00:16:22.000
ForEach는 목록에서 사용하는 궁극적인 행 ID를 결정하는 데 매우 중요하다.

00:16:22.000 --> 00:16:25.000
그리고 리스트는 모든 ID를 미리 알아야 한다.

00:16:25.000 --> 00:16:33.000
하지만 콘텐츠가 일정한 수의 행으로 해결되는 경우에만 모든 콘텐츠를 방문하지 않고도 이 작업을 효율적으로 수행할 수 있습니다.

00:16:33.000 --> 00:16:39.000
예를 들어, 공을 가져오는 것을 좋아하는 개들만 보여주기 위해 목록을 리팩토링하고 싶다고 가정해 봅시다.

00:16:39.000 --> 00:16:43.000
이와 같이 조건부 뷰를 사용하여 필터를 추가하는 것은 유혹적일 수 있다.

00:16:43.000 --> 00:16:48.000
여기서, 조회 수는 다양하다. 그건 하나 아니면 0이야.

00:16:48.000 --> 00:16:57.000
이것은 각 요소가 얼마나 많은 뷰를 해결하는지 모르기 때문에 행 식별자를 검색하기 위해 모든 뷰를 구축해야 하는 목록이 발생하기 때문에 나쁘다.

00:16:57.000 --> 00:17:00.000
AnyView를 사용하는 경우에도 마찬가지입니다.

00:17:00.000 --> 00:17:03.000
여기서, 조회수는 이제 완전히 알려지지 않았다.

00:17:03.000 --> 00:17:08.000
그래서 우리는 이전과 같은 문제가 있습니다: 모든 행을 만들어야 합니다.

00:17:08.000 --> 00:17:11.000
필터를 데이터 수집 자체로 옮기면 어떨까요?

00:17:11.000 --> 00:17:22.000
이제 우리는 요소당 일정한 수의 뷰로 돌아왔고, 필요한 것들만 행 내용을 구성하지만, 주의하세요: 여기 인라인 필터는 컬렉션에 대해 선형입니다.

00:17:22.000 --> 00:17:30.000
이것은 프로토타입에서 작동할 수 있지만, 컬렉션이 확장될 때, 이 작업은 빠르게 비싸질 수 있으며, 느린 업데이트로 이어질 수 있다.

00:17:30.000 --> 00:17:32.000
그것을 모델로 옮기는 것이 낫다.

00:17:32.000 --> 00:17:42.000
이제 우리는 두 세계의 최고를 가지고 있습니다: 필터는 캐시되어 있으므로, 이 목록이 구성될 때마다 실행되지 않으며, 요소당 뷰 수는 일정합니다.

00:17:42.000 --> 00:17:46.000
다음은 조회수가 일정하도록 하는 방법에 대한 몇 가지 팁입니다.

00:17:46.000 --> 00:17:55.000
카운트를 보는 이 접근 방식은 목록과 테이블 내의 ForEach의 맥락에서만 관련이 있습니다. 왜냐하면 이러한 구성 요소는 식별자를 미리 수집하기 때문입니다.

00:17:55.000 --> 00:17:59.000
방금 언급했듯이, AnyView와 일방적인 조건을 사용하지 마세요.

00:17:59.000 --> 00:18:08.000
적절한 경우 명시적 스택을 사용할 수도 있지만, listRowBackground와 같은 특정 수정자는 스택이 아닌 스택을 따라가야 한다는 점에 유의하십시오.

00:18:08.000 --> 00:18:12.000
마지막으로, 가능하다면 중첩된 ForEach 구조물을 평평하게 해 보세요.

00:18:12.000 --> 00:18:17.000
그러나, 중첩된 ForEach가 가치 있는 섹션 목록이 될 수 있는 곳이 하나 있다.

00:18:17.000 --> 00:18:20.000
예를 들어 봅시다.

00:18:20.000 --> 00:18:25.000
이 예에서, 나는 각 개가 가장 좋아하는 장난감으로 구분된 개 목록을 가지고 있다.

00:18:25.000 --> 00:18:28.000
저는 ForEach를 사용하여 동적 수의 섹션을 만들고 있습니다.

00:18:28.000 --> 00:18:33.000
그리고 각 섹션에는 ForEach를 중첩하여 동적 수의 행이 있습니다.

00:18:33.000 --> 00:18:43.000
목록은 모든 식별자를 검색해야 하지만, 여기서 섹션을 사용하고 있기 때문에 SwiftUI는 이 구성을 이해하고 목록이 여전히 빠르게 렌더링되도록 합니다.

00:18:43.000 --> 00:18:48.000
동적 섹션은 중첩된 ForEach를 사용할 때의 좋은 예입니다.

00:18:48.000 --> 00:18:58.000
생각해야 할 기본 방정식은 목록의 ForEach로 인한 행 수가 각 요소에 대해 생성된 뷰 수를 곱한 요소의 수와 같다는 것이다.

00:18:58.000 --> 00:19:08.000
요소당 뷰 수가 상수인지 확인해야 하며, 그렇지 않으면 SwiftUI는 행을 식별하기 위해 식별자 외에도 뷰를 구축해야 합니다.

00:19:08.000 --> 00:19:12.000
지금까지 우리는 목록에 대해 이야기했지만, 이 규칙들은 일반적으로 테이블에도 적용된다.

00:19:12.000 --> 00:19:18.000
테이블은 뷰 대신 TableRow를 사용하며, TableRow는 항상 단일 행으로 해결됩니다.

00:19:18.000 --> 00:19:20.000
테이블 예시를 봅시다.

00:19:20.000 --> 00:19:24.000
여기 안에 ForEach가 있는 개 테이블이 있습니다.

00:19:24.000 --> 00:19:32.000
TableRow는 항상 한 줄이기 때문에, 여기에 있는 총 행의 수는 개 컬렉션의 요소 수일 뿐입니다.

00:19:32.000 --> 00:19:45.000
이 구조는 매우 일반적이어서 iOS 17과 macOS Sonoma의 새로운 기능인 SwiftUI는 데이터 수집의 ForEach를 작성하고 대신 테이블 행을 만들 수 있는 간소화된 이니셜라이저를 제공합니다.

00:19:45.000 --> 00:19:52.000
이 이니셜라이저는 새로운 것이지만, 테이블을 사용할 수 있는 모든 이전 운영 체제 버전에 다시 배포됩니다.

00:19:52.000 --> 00:20:00.000
이 구조는 더 간단할 뿐만 아니라, 식별 성능에 도움이 되는 ForEach 콘텐츠에 대해 일정한 수의 행을 시행한다.

00:20:00.000 --> 00:20:04.000
하지만, 내가 새로운 것을 부르고 싶은 의미론적 변화가 있다.

00:20:04.000 --> 00:20:09.000
이와 같은 코드가 있다면, 최신 OS 버전에서 다르게 작동할 수 있습니다.

00:20:09.000 --> 00:20:15.000
이 예에서, 우리는 개 위에 ForEach를 가지고 있으며, 이는 또한 개 한 줄을 만든다.

00:20:15.000 --> 00:20:18.000
하지만, 여기 있는 개들은 어울리지 않는다.

00:20:18.000 --> 00:20:20.000
그 가치는 개의 가장 친한 친구이다.

00:20:20.000 --> 00:20:25.000
iOS 16에서, 각 행은 그 값으로 식별되었다.

00:20:25.000 --> 00:20:29.000
iOS 17에서 이 행동은 성능을 개선하기 위해 바뀌었다.

00:20:29.000 --> 00:20:34.000
그 이유는, 이제 우리는 ForEach를 조사하여 각 테이블 행을 식별할 필요가 없기 때문입니다.

00:20:34.000 --> 00:20:40.000
그래서 이 예시는 이제 TableRow의 값 대신 각 개의 ID를 가지고 있다.

00:20:40.000 --> 00:20:49.000
다시 배포해야 하는 경우, 컬렉션을 매핑하거나 ID 키 경로를 명시적으로 지정하여 이전 동작을 얻을 수 있습니다.

00:20:49.000 --> 00:20:59.000
생각해야 할 기본 방정식은 목록의 ForEach로 인한 행 수가 각 요소에 대해 생성된 뷰 수를 곱한 요소의 수와 같다는 것이다.

00:20:59.000 --> 00:21:04.000
테이블에서, 이것은 비슷하지만, 요소당 TableRows의 수이다.

00:21:04.000 --> 00:21:15.000
우리는 여기서 더 빠른 목록과 테이블을 위한 몇 가지 팁과 요령을 다루었습니다. 즉, 식별자가 저렴하고 ForEach 콘텐츠의 조회 수가 일정하다는 것을 확인해야 합니다.

00:21:15.000 --> 00:21:16.000
우리는 오늘 많은 것을 다루었다.

00:21:16.000 --> 00:21:21.000
우리는 의존성을 이해하고 최적화하기 위해 그래프를 탐구하는 것으로 시작했다.

00:21:21.000 --> 00:21:25.000
그런 다음, 우리는 느린 업데이트와 반응성을 개선하는 방법을 살펴보았다.

00:21:25.000 --> 00:21:29.000
그리고 마지막으로, 우리는 목록과 표와 함께 정체성의 중요성에 대해 논의했다.

00:21:29.000 --> 00:21:38.000
올바른 정신 모델을 사용하면 개발 프로세스의 시작부터 훌륭한 성능을 쉽게 얻을 수 있으므로 앱의 세부 사항에 더 집중할 수 있습니다.

00:21:38.000 --> 00:21:40.000
봐줘서 고마워.

00:21:40.000 --> 23:59:59.000
♪ ♪

