WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:16.000
라스무스: 안녕하세요, 저는 라스무스입니다. 저는 전산 비디오와 함께 일하는 카메라 알고리즘 팀의 엔지니어입니다.

00:00:16.000 --> 00:00:18.000
난 이미 시네마틱 모드가 기대돼.

00:00:18.000 --> 00:00:29.000
그리고 이제 저는 새로운 시네마틱 API를 사용하여 자신의 앱에 시네마틱 모드의 마법을 통합하는 방법을 보여주는 것에 대해 훨씬 더 흥분됩니다.

00:00:29.000 --> 00:00:41.000
이 프레젠테이션에서, 저는 새로운 API를 사용하여 재생 및 편집을 수행하는 샘플 앱을 구축하여 시네마틱 모드의 멋진 기능을 실현하는 데 필요한 단계를 진행할 것입니다.

00:00:41.000 --> 00:00:51.000
하지만 통합에 대해 이야기하기 전에, 먼저 시네마틱 모드가 무엇인지, 어떻게 캡처할 수 있는지, 그리고 캡처 후로 무엇을 할 수 있는지 보여드리겠습니다.

00:00:51.000 --> 00:00:57.000
우리는 아이폰 13에 시네마틱 모드를 도입했고, 그것은 정말 당신의 주머니에 있는 작은 영화 제작진입니다.

00:00:57.000 --> 00:01:16.000
그것은 당신에게 아름다운 얕은 피사계 심도와 자연스러운 초점 폴오프를 가진 카메라, 초점을 변경하여 관심과 내러티브를 지시하는 감독, 그리고 미리 키프레임을 예상하고 초점 지점 간의 부드러운 전환을 만드는 초점 풀러를 제공합니다.

00:01:16.000 --> 00:01:17.000
그래서 시네마틱 모드를 어떻게 캡처하나요?

00:01:17.000 --> 00:01:27.000
iPhone 13 및 14 라인업의 모든 장치의 카메라 앱에서 바로 캡처되며, 녹화할 때 렌더링 미리보기를 제공합니다.

00:01:27.000 --> 00:01:36.000
이것은 당신이 야심찬 인디 영화 제작자이든 캠핑 여행 비디오에 마법의 터치를 더하고 싶든, 매우 쉽게 접근할 수 있게 해준다.

00:01:36.000 --> 00:01:42.000
그리고 내가 영화 제작자가 되는 것을 꿈꿨지만, 나는 내 가족의 시네마틱 모드를 포착하는 것을 좋아한다.

00:01:42.000 --> 00:01:44.000
하지만 마법은 여기서 멈추지 않아.

00:01:44.000 --> 00:01:47.000
시네마틱 모드에는 눈에 보이는 것보다 더 많은 것이 있다.

00:01:47.000 --> 00:01:52.000
캡처 후 꽤 놀라운 비파괴 편집을 할 수 있습니다.

00:01:52.000 --> 00:01:56.000
조리개와 보케의 양을 변경할 수 있습니다.

00:01:56.000 --> 00:02:01.000
그리고 대체 탐지를 사용하여 초점과 내러티브를 리디렉션할 수 있습니다.

00:02:01.000 --> 00:02:10.000
이것은 사진에서 캡처 후 편집을 보여주지만, iMovie, Final Cut Pro 및 Motion과 같은 앱에서도 편집할 수 있습니다.

00:02:10.000 --> 00:02:20.000
그리고 이제 시네마틱 API의 도입으로, 시네마틱 모드 비디오를 사용하여 자신의 놀라운 앱에서 재생하고 편집할 수 있습니다.

00:02:20.000 --> 00:02:29.000
시네마틱 API는 새로운 macOS 소노마, iOS 17, iPadOS 17 및 tvOS 17에서 널리 사용할 수 있습니다.

00:02:29.000 --> 00:02:31.000
그래서 이건 정말 신나.

00:02:31.000 --> 00:02:37.000
먼저 저는 특별한 시네마틱 모드 자산과 데이터 흐름에 대한 몇 가지 기본 사항부터 시작하겠습니다.

00:02:37.000 --> 00:02:46.000
그런 다음 조리개 변경과 같은 간단한 재생 조정으로 시네마틱 모드 자산을 얻고 재생하기 위한 특정 단계를 진행할 것입니다.

00:02:46.000 --> 00:02:56.000
그리고 시네마틱 모드에서 초점을 유도하는 비파괴 편집을 하는 방법과 이러한 편집 변경 사항을 저장하고 로드하는 방법.

00:02:56.000 --> 00:03:04.000
저는 새로운 시네마틱 API 호출 중 일부를 살펴보고 자세한 참조로 사용할 수 있는 샘플 코드 앱을 제공할 것입니다.

00:03:04.000 --> 00:03:09.000
하지만 약속한 대로, 시네마틱 모드에 대한 몇 가지 기본 사항을 설명하는 것으로 시작하겠습니다.

00:03:09.000 --> 00:03:15.000
시네마틱 모드는 실제로 두 개의 파일과 하나에서 다른 곳으로의 데이터 흐름으로 구성되어 있다.

00:03:15.000 --> 00:03:17.000
먼저 렌더링된 자산이 있다.

00:03:17.000 --> 00:03:26.000
이것은 시네마틱 모드 효과가 적용된 구운 파일이며, 일반 퀵타임 영화로 내보내고, 공유하고, 재생할 수 있습니다.

00:03:26.000 --> 00:03:33.000
그리고 렌더링된 자산을 만드는 데 필요한 모든 정보가 있는 특별한 시네마틱 모드 자산이 있습니다.

00:03:33.000 --> 00:03:40.000
조리개를 변경하고 내러티브에 다시 집중하는 것과 같은 비파괴적인 캡처 후 편집을 할 수 있습니다.

00:03:40.000 --> 00:03:48.000
렌더링된 자산을 살펴보고, 약간의 시네마토그래피 101로 샷을 분해하는 것으로 시작합시다.

00:03:48.000 --> 00:03:59.000
오프닝 샷: 우리는 분명히 중요한 스트리트 핸드볼 게임에 들어가고, 주요 주제에 집중함으로써, 우리는 그가 큰 플레이를 할 준비를 할 때 정말 긴장감을 느낀다.

00:03:59.000 --> 00:04:02.000
그는 그의 팀 선수를 확인한다. 그도 준비됐어.

00:04:02.000 --> 00:04:06.000
그에게 집중하는 것은 그가 얼마나 준비가 되었는지를 강조한다.

00:04:06.000 --> 00:04:09.000
우리는 우리의 주요 주제에 다시 집중한다.

00:04:09.000 --> 00:04:14.000
이게 다야; 너는 칼로 긴장을 끊을 수 있어.

00:04:14.000 --> 00:04:19.000
그는 연극을 만들고 그것을 완전히 망치고, 약간의 코믹한 안도감을 설정한다.

00:04:19.000 --> 00:04:28.000
이제 샷 초반에 그에게 집중함으로써 팀 플레이어에 대한 이야기를 바꾸자, 그리고 앞뒤로 가는 대신, 우리는 그에게 초점을 맞추도록 하자.

00:04:28.000 --> 00:04:29.000
나는 그의 생각의 목소리가 될 거야.

00:04:29.000 --> 00:04:33.000
"사랑해, 친구, 하지만 넌 항상 오래 걸려."

00:04:33.000 --> 00:04:38.000
"응, 난 준비됐어, 하지만 기대치는 낮아."

00:04:38.000 --> 00:04:47.000
"정말 시간 낭비야. 브라보." 그래서 이것은 시네마틱 모드에서 제공하는 스토리텔링을 위한 시네마토그래피 도구를 보여주는 아이폰 13에서 촬영되었다.

00:04:47.000 --> 00:04:51.000
그리고 이 렌더링된 자산을 생산하기 위해, 특별한 시네마틱 모드 자산이 있다.

00:04:51.000 --> 00:04:58.000
비파괴적인 캡처 후 편집을 지원하기 위해, 시네마틱 모드 자산에는 실제로 여러 트랙이 있습니다.

00:04:58.000 --> 00:05:03.000
첫 번째는 캡처된 오리지널 퀵타임 영화인 비디오 트랙이다.

00:05:03.000 --> 00:05:14.000
HDR/SDR, 초당 30프레임의 1080p, iPhone 14, 심지어 초당 24, 25, 30프레임의 4K가 될 수 있습니다.

00:05:14.000 --> 00:05:21.000
이 트랙은 일반 비디오로 재생할 수 있지만, 렌더링된 자산에 비해 미학과 스토리텔링이 부족하다.

00:05:21.000 --> 00:05:28.000
긴장감도 없고 코믹한 안도감도 없고, 우리는 그냥 몇몇 사람들이 뒷골목에서 게임을 하는 걸 보고 있어.

00:05:28.000 --> 00:05:35.000
두 번째 트랙에는 같은 장면을 보고 있는 두 대의 카메라에서 본 픽셀 시프트인 격차가 포함되어 있다.

00:05:35.000 --> 00:05:38.000
가까운 물체는 더 멀리 있는 물체보다 더 많이 이동한다.

00:05:38.000 --> 00:05:45.000
한쪽 눈을 감고 다른 쪽 눈을 감고 이것을 직접 테스트할 수 있으며, 물체가 다른 거리에서 어떻게 움직이는지 볼 수 있습니다.

00:05:45.000 --> 00:05:50.000
격차는 초점과 얕은 피사계 심도를 렌더링하는 데 사용된다.

00:05:50.000 --> 00:05:55.000
격차 맵은 비디오 트랙보다 해상도가 낮다.

00:05:55.000 --> 00:06:13.000
채색으로 표시된 트랙은 상대적이고 절대적인 불균형을 포함하며, 이는 초점 불균형에 대한 렌더링 또는 두 초점 불균형 간의 전환과 같은 동일한 지도의 다른 샘플에 대해서만 사용할 수 있음을 의미합니다.

00:06:13.000 --> 00:06:22.000
상대적인 불균형과 큰 깊이 말장난에 대한 통찰력을 위해, 저는 WWDC17, "iPhone 사진의 깊이 포착"을 강력히 추천합니다.

00:06:22.000 --> 00:06:27.000
세 번째 트랙에는 렌더링과 편집을 위한 중요한 메타데이터가 포함되어 있습니다.

00:06:27.000 --> 00:06:29.000
그 트랙은 두 가지로 구성되어 있다.

00:06:29.000 --> 00:06:36.000
첫째, 초점 불균형과 조리개를 f-넘버로 유지하는 렌더링 속성.

00:06:36.000 --> 00:06:38.000
이것들은 렌더링을 구동한다.

00:06:38.000 --> 00:06:46.000
오버레이로 표시된 초점은 시네마틱 엔진에 의해 결정되며, 조리개는 사용자가 선택합니다.

00:06:46.000 --> 00:06:52.000
그리고 모든 자동 장면 감지를 유지하는 시네마틱 스크립트가 있습니다.

00:06:52.000 --> 00:07:02.000
이 장면은 얼굴, 머리, 몸통을 보여주며, 가능하면 시간이 지남에 따라 함께 연결하는 ID로 그룹화됩니다.

00:07:02.000 --> 00:07:08.000
대본은 또한 어떤 탐지에 초점을 맞출지 결정하는 초점 결정을 유지한다.

00:07:08.000 --> 00:07:16.000
초점 결정은 다른 탐지를 따르기 위해 캡처 후 변경될 수 있으며, 따라서 내러티브와 렌더링을 변경할 수 있다.

00:07:16.000 --> 00:07:21.000
이것은 시네마틱 모드 자산에서 렌더링된 자산으로의 데이터 흐름이다.

00:07:21.000 --> 00:07:30.000
방금 언급했듯이, 시네마틱 모드 자산은 렌더링 및 캡처 후 초점 및 조리개 변경에 필요한 모든 정보를 보유하고 있습니다.

00:07:30.000 --> 00:07:37.000
다음은 변경 사항이 비파괴적이며 항상 원본으로 되돌릴 수 있는 선택적 편집입니다.

00:07:37.000 --> 00:07:49.000
편집이 완료되지 않으면, 시네마틱 엔진은 초점 격차를 자동으로 제어하며, 캡처 시간에 사용자가 설정한 조리개는 변경되지 않습니다.

00:07:49.000 --> 00:07:58.000
초점 불균형과 조리개로, 렌더링은 불균형 맵을 사용하여 정확한 초점 폴오프와 함께 얕은 피사계 심도를 적용합니다.

00:07:58.000 --> 00:08:05.000
그리고 마지막으로, 우리는 일반적이고 공유 가능한 퀵타임 영화인 적용된 효과와 함께 렌더링된 자산을 얻는다.

00:08:05.000 --> 00:08:10.000
시네마틱 모드에 대한 더 나은 이해와 함께, 재생 앱 구축을 시작할 때입니다.

00:08:10.000 --> 00:08:16.000
하지만 먼저 우리는 시네마틱 모드 자산을 잡아야 하므로, 그것을 얻기 위해 코드를 살펴봅시다.

00:08:16.000 --> 00:08:21.000
사진 라이브러리에서 시네마틱 모드 자산을 선택하는 것은 꽤 쉽다.

00:08:21.000 --> 00:08:25.000
시네마틱 비디오에 사진 선택기와 필터를 사용하세요.

00:08:25.000 --> 00:08:29.000
피커는 선택한 파일의 로컬 식별자를 얻을 것이다.

00:08:29.000 --> 00:08:43.000
코드와 관련되지 않은 참고로, 아직 시네마틱 모드 자산이 없다면, 렌더링된 자산과 시네마틱 모드 자산을 모두 포함하도록 모든 사진 데이터 옵션을 사용하여 다른 사용자 장치 간에 AirDrop할 수 있습니다.

00:08:43.000 --> 00:08:45.000
코딩으로 돌아가자.

00:08:45.000 --> 00:08:55.000
픽의 자산 식별자를 사용하여, 이제 요청하기 전에 시네마틱 모드 자산에 대한 정보가 있는 사진 자산을 가져올 수 있습니다.

00:08:55.000 --> 00:09:09.000
원래 버전을 얻기 위해 요청 옵션을 설정하고 자산이 iCloud에 있는 경우 네트워크 액세스를 허용한 다음, 마지막으로 시네마틱 모드 자산을 AVAsset으로 요청해야 합니다.

00:09:09.000 --> 00:09:10.000
그리고 이제 흥미진진한 부분으로.

00:09:10.000 --> 00:09:12.000
우리는 시네마틱 모드 자산을 얻었다.

00:09:12.000 --> 00:09:14.000
재생을 통합하자.

00:09:14.000 --> 00:09:24.000
렌더링된 자산은 AVPlayer와 AVPlayerItem을 일반 영화로 사용하여 재생할 수 있으며, 영화 모드 자산 내부의 영화 트랙도 재생할 수 있습니다.

00:09:24.000 --> 00:09:38.000
하지만 시네마틱 모드 자산의 잠재력을 실현하기 위해, 우리는 여러 트랙, 사용자 변경을 처리할 수 있는 사용자 지정 비디오 컴포지터를 추가해야 하며, 마지막으로 시네마틱 렌더러를 호출하여 출력을 구성해야 합니다.

00:09:38.000 --> 00:09:49.000
이 사용자 지정 컴포지터는 썸네일과 오프라인 내보내기에도 사용할 수 있지만, 시네마틱 모드 자산의 재생 및 편집에 사용하는 데 집중합시다.

00:09:49.000 --> 00:10:05.000
저는 시네마틱 API와 관련된 세부 사항만 들어갈 것이므로, 사용자 지정 비디오 컴포지터 클래스와 HDR에 대한 추가 통찰력을 얻으려면 WWDC20, "AVFoundation으로 HDR 비디오 편집 및 재생"을 추천합니다.

00:10:05.000 --> 00:10:08.000
시네마틱 API를 사용하기 시작합시다.

00:10:08.000 --> 00:10:20.000
시네마틱 API는 접두사 CN을 사용하므로, 얕은 피사계 심도를 렌더링할 렌더링 세션을 설정하는 데 필요한 세 가지 API 호출을 발견할 수 있습니다.

00:10:20.000 --> 00:10:24.000
첫 번째 통화는 시네마틱 자산에서 렌더링 속성을 얻는다.

00:10:24.000 --> 00:10:28.000
두 번째는 이러한 속성으로 렌더링 세션을 설정합니다.

00:10:28.000 --> 00:10:34.000
렌더링 세션은 GPU를 사용하므로, 금속 명령 대기열을 제공해야 합니다.

00:10:34.000 --> 00:10:38.000
그리고 마지막 호출은 내보낼 렌더링 품질을 설정합니다.

00:10:38.000 --> 00:10:44.000
품질은 성능과 품질 제약에 따라 미리보기 및 내보내기와 같은 다른 열거형으로 설정할 수 있습니다.

00:10:44.000 --> 00:10:53.000
이것들과 다음 코드 스니펫에서, 나는 핵심 코드에 집중하기 위해 guard let else 오류와 같은 좋은 연습 오류 검사를 제거했다.

00:10:53.000 --> 00:11:01.000
사용자 지정 컴포지터는 출력을 렌더링하는 데 필요한 영화 자산 정보를 포함하는 구성이 필요합니다.

00:11:01.000 --> 00:11:10.000
일반적인 경우, 여러 트랙을 추가하려면 여러 단계가 필요하지만, 다행히도, 우리는 한 단계로 이것을 할 수 있는 쉬운 방법을 제공합니다.

00:11:10.000 --> 00:11:16.000
자산 정보에서 구성에 이르기까지 모든 트랙을 직접 추가할 수 있습니다.

00:11:16.000 --> 00:11:23.000
시네마틱 컴포지션 정보는 시네마틱 자산 정보와 비슷하지만, 컴포지션 트랙을 가리킨다.

00:11:23.000 --> 00:11:27.000
그리고 나서 나는 시네마틱 자산에서 시네마틱 대본을 얻는다.

00:11:27.000 --> 00:11:32.000
시네마틱 스크립트는 모든 탐지와 초점 결정을 담고 있다.

00:11:32.000 --> 00:11:35.000
그리고 나는 나중에 이것에 대해 더 자세히 설명할 것이다.

00:11:35.000 --> 00:11:45.000
사용자 지정 컴포지터를 위해, 렌더링 세션, 자산 트랙이 있는 구성, 시네마틱 스크립트 및 조리개를 f-number로 설정했습니다.

00:11:45.000 --> 00:11:51.000
이 사용자 지정 지침은 렌더링된 영화 콘텐츠를 구성하는 방법을 설명합니다.

00:11:51.000 --> 00:12:06.000
비디오를 재생하려면 비디오 컴포지션이 필요하며, 시네마틱 컴포지션에서 트랙 ID를 추가하고, 효과를 구성하기 위해 렌더러가 호출되는 샘플 사용자 지정 컴포지터를 추가하고, 컴포지션 명령을 추가합니다.

00:12:06.000 --> 00:12:10.000
사용자 지정 컴포지터에서 무슨 일이 일어나는지 자세히 살펴봅시다.

00:12:10.000 --> 00:12:17.000
사용자 지정 컴포지터의 startRequest 함수 안에 시네마틱 API와 관련된 몇 가지 주요 사항이 있습니다.

00:12:17.000 --> 00:12:34.000
시네마틱 컴포지션의 트랙 ID를 사용하여 원본 비디오 트랙, 불균형 트랙, 메타데이터 트랙에서 현재 프레임의 소스 버퍼를 얻고, 마지막으로 렌더링된 출력을 위한 버퍼를 만듭니다.

00:12:34.000 --> 00:12:38.000
이 버퍼는 우리가 편집과 새로운 렌더링을 할 수 있게 해준다.

00:12:38.000 --> 00:12:44.000
메타데이터 버퍼에서 렌더링을 구동하는 렌더링 프레임 속성을 얻을 수 있습니다.

00:12:44.000 --> 00:12:52.000
메타데이터는 불투명한 구조이므로, 나는 CNRenderingSession을 사용하고 프레임 속성을 직접 얻을 것이다.

00:12:52.000 --> 00:13:04.000
프레임 속성을 사용하면 이제 UI 요소의 조리개 변경을 유지하는 지침에 따라 조리개 f-number를 변경하여 선택적 재생을 변경할 수 있습니다.

00:13:04.000 --> 00:13:11.000
초점 격차는 비슷한 방식으로 바뀔 수 있지만, 나중에 감지를 사용하여 장면 중심의 변경으로 돌아갈 것이다.

00:13:11.000 --> 00:13:15.000
이 시점에서, 우리는 재생을 달성하는 데 정말, 정말 가깝다.

00:13:15.000 --> 00:13:23.000
구성된 출력이 GPU에서 렌더링될 수 있도록 렌더링 명령 대기열에서 명령 버퍼를 얻기만 하면 됩니다.

00:13:23.000 --> 00:13:30.000
업데이트된 프레임 속성과 이미지 및 불균형 버퍼를 사용하여 렌더링을 인코딩하세요.

00:13:30.000 --> 00:13:36.000
비디오 컴포지션에 전달될 출력 버퍼에 대한 완료 핸들러를 추가하세요.

00:13:36.000 --> 00:13:38.000
그리고 마지막으로 명령 버퍼를 커밋하세요.

00:13:38.000 --> 00:13:42.000
이제 샘플 앱에서 재생을 시도해 봅시다.

00:13:42.000 --> 00:13:47.000
이제 사진 라이브러리에서 시네마틱 모드 자산을 선택할 수 있습니다.

00:13:47.000 --> 00:13:53.000
그리고 내가 자산을 재생할 때, 그 효과는 실시간으로 적용된다.

00:13:53.000 --> 00:14:04.000
나는 앞뒤로 문지르고 조리개를 변경할 수 있으며, 이는 보케의 양을 바꾼다.

00:14:04.000 --> 00:14:09.000
멈추는 것은 효과를 최소화한다.

00:14:09.000 --> 00:14:11.000
개방은 그것을 증가시킨다.

00:14:11.000 --> 00:14:15.000
어쩌면 이건 너무 과할지도 몰라.

00:14:15.000 --> 00:14:17.000
난 이게 좋아 보인다고 생각해.

00:14:17.000 --> 00:14:22.000
그 앱은 이미 꽤 멋지지만, 다가오는 편집 섹션에서는 더 시원해질 것이다.

00:14:22.000 --> 00:14:27.000
그리고 참고로, 각 부품에 대한 코드는 샘플 앱에서 사용할 수 있습니다.

00:14:27.000 --> 00:14:38.000
이제 시네마틱 스크립트를 변경하여 초점을 변경하여 더 진보되고 비파괴적인 편집을 할 수 있도록 재생 앱과 사용자 지정 비디오 컴포지터를 확장할 것입니다.

00:14:38.000 --> 00:14:53.000
하지만 시네마틱 모드를 위한 사진 앱 편집 환경을 다시 방문하고 물체를 감지하고 어디에 초점을 맞출지 결정함으로써 캡처 중에 자동으로 구동되는 초점을 구체적으로 살펴봅시다.

00:14:53.000 --> 00:15:00.000
이러한 탐지와 결정은 모두 영화 대본에 있으며, 대본은 당신의 내러티브로 변경할 수 있습니다.

00:15:00.000 --> 00:15:09.000
초점 감지는 노란색 사각형으로 표시되며, 타임라인 아래에는 키프레임과 초점 결정 변경 사항이 있습니다.

00:15:09.000 --> 00:15:15.000
이것이 어떻게 작동하는지 더 잘 이해하기 위해, 간단한 예로 시네마틱 스크립트 구조를 분석해 봅시다.

00:15:15.000 --> 00:15:20.000
짧은 시퀀스로 두 개의 시네마틱 스크립트 프레임으로 시작합시다.

00:15:20.000 --> 00:15:26.000
각각은 주어진 시점에 대한 모든 탐지를 유지하며, 이 경우에는 두 번의 탐지만 한다.

00:15:26.000 --> 00:15:34.000
탐지는 얼굴, 머리, 몸통을 함께 그룹화하는 그룹 ID로 시간이 지남에 따라 추적됩니다.

00:15:34.000 --> 00:15:43.000
게다가, 고양이, 개, 공이 감지되고 추적되지만, 여기에는 배우 1과 배우 2의 얼굴이 있습니다.

00:15:43.000 --> 00:15:52.000
자동 기본 결정은 첫 번째 프레임에서 배우 1에 초점을 맞추고, 초점은 새로운 결정이 나올 때까지 이 트랙을 따를 것이다.

00:15:52.000 --> 00:16:01.000
배우 3이 현장에 들어가 새로운 얼굴과 탐지 트랙을 도입한 후에도, 초점은 배우 1에 남아 있다.

00:16:01.000 --> 00:16:09.000
프레임 5에서, 자동 키프레임 이벤트는 결정과 초점을 배우 2로 바꾼다.

00:16:09.000 --> 00:16:16.000
그리고 단 네 프레임 후에, 액터 3은 그녀가 마땅히 받아야 할 집중된 관심을 받지 못한 채 낙담한 출구를 한다.

00:16:16.000 --> 00:16:21.000
나머지 시퀀스 동안 액터 2에 집중한다.

00:16:21.000 --> 00:16:32.000
이러한 자동 기본 결정은 누가 카메라를 마주하는지, 누가 외면하는지, 누가 더 가까이 있는지, 무엇이 흥미로운지와 같은 다양한 매개 변수에 따라 결정됩니다.

00:16:32.000 --> 00:16:36.000
그리고 우리가 좋은 이야기를 만들기 위해 최선을 다하는 동안, 당신은 다른 이야기를 가질 수 있습니다.

00:16:36.000 --> 00:16:39.000
운 좋게도, 결정은 실제로 두 가지 방법으로 바뀔 수 있다.

00:16:39.000 --> 00:16:44.000
첫 번째는 약한 사용자 결정을 추가하는 것이다.

00:16:44.000 --> 00:16:48.000
이것은 그녀가 장면에 들어갈 때 배우 3에 초점을 맞춘다.

00:16:48.000 --> 00:17:01.000
그러나, 약한 결정은 프레임 5에서 발생하는 다음 기본 또는 사용자 결정까지만 트랙을 따르며, 여기서 기본 결정은 나머지 프레임에 대해 액터 2로 초점을 바꾼다.

00:17:01.000 --> 00:17:09.000
그래서 우리가 배우 3에 집중하고 싶다면, 프레임 5에 또 다른 약한 결정을 추가하거나, 더 강한 것을 사용할 수 있다.

00:17:09.000 --> 00:17:13.000
네, 당신은 그것을 추측했을 수도 있습니다, 강력한 사용자 결정입니다.

00:17:13.000 --> 00:17:22.000
강력한 결정은 다음 사용자가 다른 곳에 집중하기로 결정하거나 탐지 트랙이 끝날 때까지 주제에 초점을 맞출 것이다.

00:17:22.000 --> 00:17:28.000
강력한 결정을 추가하면 액터 3에 초점을 맞추고 다음 기본 결정을 무시합니다.

00:17:28.000 --> 00:17:38.000
액터 3의 탐지 트랙이 끝난 후, 초점은 액터 2에 초점을 맞추는 기본 결정으로 되돌아간다.

00:17:38.000 --> 00:17:49.000
의사 결정 계층 구조는 다음과 같이 작동합니다: 기본 결정 위에 사용자 결정, 가능한 경우 사용자 결정이 적용되며, 기본 결정이 격차를 메웁니다.

00:17:49.000 --> 00:17:54.000
그래서 이 예에서처럼, 사용자는 스크립트의 일부만 변경할 수 있습니다.

00:17:54.000 --> 00:18:04.000
그리고 두 결정 모두 탐지 트랙이 끝날 때 기본 결정으로 되돌아가지만, 강력한 결정은 가능한 한 오랫동안 초점 트랙을 유지합니다.

00:18:04.000 --> 00:18:09.000
스크립트를 변경하기 전에, 스크립트 프레임을 얻고 감지 상자를 그려봅시다.

00:18:09.000 --> 00:18:20.000
먼저 비디오 작곡 요청에서 프레임 시간을 잡은 다음, 현재 시점에 대한 시네마틱 스크립트 프레임을 가져와야 합니다.

00:18:20.000 --> 00:18:24.000
이 스크립트 프레임은 초점 감지를 포함한 모든 감지를 보유합니다.

00:18:24.000 --> 00:18:28.000
이제 감지 상자를 그리는 것은 쉽다.

00:18:28.000 --> 00:18:39.000
스크립트의 모든 감지를 반복함으로써, 각 감지 사각형을 가져와 그리기 명령을 사용하여 renderEncoder에 첨부된 텍스처로 그릴 수 있습니다.

00:18:39.000 --> 00:18:42.000
이 예에서, 탐지는 흰색으로 그려져 있다.

00:18:42.000 --> 00:18:48.000
그리고 현재 focusDetection이 무엇인지 강조하기 위해, 그것을 다른 색으로 그려봅시다.

00:18:48.000 --> 00:19:01.000
나는 시네마틱 스크립트 프레임에서 직접 초점 감지를 받고, 해당 직사각형을 얻고, 눈에 띄게 하기 위해 초점 직사각형을 노란색으로 그립니다.

00:19:01.000 --> 00:19:04.000
감지 오버레이가 추가된 재생 앱을 사용해 봅시다.

00:19:04.000 --> 00:19:10.000
이제 새로운 탐지 오버레이를 활성화하여 탐지를 그릴 수 있습니다.

00:19:10.000 --> 00:19:17.000
이 장면은 얼굴, 머리, 몸통을 흰색으로, 초점 감지를 노란색으로 보여준다.

00:19:17.000 --> 00:19:24.000
앱에 의미가 있는 경우에만 탐지의 특정 하위 집합을 표시하도록 오버레이를 사용자 정의할 수 있습니다.

00:19:24.000 --> 00:19:34.000
재생을 시작할 때, 대체 감지가 흰색으로 표시되는 동안 초점을 맞추고 렌더링이 영화를 통해 노란색 초점 감지를 어떻게 따르는지 주목하세요.

00:19:34.000 --> 00:19:40.000
초점을 바꾸기 위해 이러한 대체 탐지를 사용하는 방법을 보여드리겠습니다.

00:19:40.000 --> 00:19:47.000
감지 상자를 그리는 방법을 알게 되면, 실제로 UI 탭 포인트로 스크립트를 변경하는 것은 매우 유사합니다.

00:19:47.000 --> 00:19:59.000
다시 모든 탐지를 반복할 것이며, 탭 포인트가 탐지 내부에 있다면, 해당 탐지 ID를 얻고 새로운 결정을 내릴 것입니다.

00:19:59.000 --> 00:20:02.000
결정 강도는 UI에서 설정할 수 있다.

00:20:02.000 --> 00:20:11.000
샘플 앱에서 약한 것은 한 번의 탭으로 설정되고 강한 것은 두 번 탭으로 설정되지만, UI는 정말 당신에게 달려 있습니다.

00:20:11.000 --> 00:20:18.000
그리고 마침내 나는 이 새로운 사용자 결정을 시네마틱 스크립트에 추가했고, 스크립트가 바뀌었다.

00:20:18.000 --> 00:20:21.000
그래서 업데이트된 스크립트가 어떻게 초점을 맞추는지에 대해 이야기하겠습니다.

00:20:21.000 --> 00:20:29.000
이것을 일반적인 클립 길이로 간주하고 세 가지 결정과 해당 초점 감지 트랙을 살펴봅시다.

00:20:29.000 --> 00:20:34.000
2D 플롯에서 시간과 거리에 따라 초점 트랙을 정렬합시다.

00:20:34.000 --> 00:20:42.000
시네마틱 엔진은 업데이트된 전체 스크립트를 알고 있기 때문에, 미리 원활한 초점 전환을 할 수 있다.

00:20:42.000 --> 00:20:50.000
각 키프레임의 시작 부분에 초점을 맞추기 위해 포커스 랙이 미리 시작하는 이것과 같다.

00:20:50.000 --> 00:21:00.000
그것은 꽤 마법적이며, 세트 마커를 알고 미리 주의를 기울이고 초점을 맞출 수 있는 초점 끌어당기는 사람처럼 작동합니다.

00:21:00.000 --> 00:21:07.000
랙 초점 격차는 업데이트된 시네마틱 스크립트의 프레임에서 직접 접근할 수 있다.

00:21:07.000 --> 00:21:16.000
나는 이미 스크립트 프레임을 추출하는 방법을 보여주었고, 초점에 대한 프레임 속성을 변경하는 것은 조리개를 변경하는 것과 비슷하다.

00:21:16.000 --> 00:21:23.000
업데이트된 스크립트에서 스크립트 프레임을 받으면, 초점 불균형에 대한 프레임 속성을 직접 업데이트할 수 있습니다.

00:21:23.000 --> 00:21:29.000
이것은 업데이트된 스크립트에 따라 렌더러에 따라 원활한 전환으로 초점을 전달할 것이다.

00:21:29.000 --> 00:21:34.000
스크립트를 변경하고 샘플 앱에서 초점을 맞추기 위해 탭을 시도해 봅시다.

00:21:34.000 --> 00:21:41.000
재생 모드에서 편집으로 이동하여, 이제 시네마틱 스크립트를 업데이트할 수 있습니다.

00:21:41.000 --> 00:21:53.000
노란색 점선 상자로 표시된 약한 결정을 얻기 위해 단일 탭하거나 강력한 결정과 단단한 노란색 상자를 얻기 위해 이중 탭하여 초점 결정을 변경할 수 있습니다.

00:21:53.000 --> 00:22:00.000
다른 플레이어를 탭할 때 사용자 입력에 따라 초점과 렌더링이 어떻게 변하는지 볼 수 있습니다.

00:22:00.000 --> 00:22:02.000
난 이게 정말 멋지다고 생각해.

00:22:02.000 --> 00:22:05.000
문질러, 문질러.

00:22:05.000 --> 00:22:08.000
탭, 탭, 탭.

00:22:08.000 --> 00:22:10.000
조리개를 바꾸세요.

00:22:10.000 --> 00:22:15.000
문지르고, 두드리고, 두드리고, 두 번 두드리세요.

00:22:15.000 --> 00:22:19.000
그리고 이제 편집을 완료했으니, 이러한 편집 변경 사항을 어떻게 저장할 수 있나요?

00:22:19.000 --> 00:22:27.000
스크립트 변경 사항은 별도의 데이터 파일에 저장할 수 있으며, 변경 사항을 별도로 저장하면 원본이 변경되지 않습니다.

00:22:27.000 --> 00:22:30.000
그리고 변경 사항은 항상 원본으로 되돌릴 수 있습니다.

00:22:30.000 --> 00:22:41.000
그래서 나는 스크립트 변경 사항을 받고, 변경 사항을 컴팩트한 이진 표현으로 가져오고, 데이터 파일에 변경 사항을 작성합니다.

00:22:41.000 --> 00:22:45.000
시네마틱 API는 데이터 표현을 처리한다.

00:22:45.000 --> 00:22:50.000
그리고 필요에 맞게 다시 로드할 수 있도록 이 데이터를 앱에 저장해야 합니다.

00:22:50.000 --> 00:22:56.000
스크립트 변경 로드는 똑같이 쉬운 세 단계로 이루어집니다.

00:22:56.000 --> 00:23:04.000
데이터 파일에서 이진 데이터를 얻고, 스크립트 변경 사항을 풀고, 변경 사항을 시네마틱 스크립트로 다시 로드합니다.

00:23:04.000 --> 00:23:09.000
변경 사항은 원본 스크립트와 동시에 로드할 수도 있습니다.

00:23:09.000 --> 00:23:14.000
그래서 그것이 우리가 시네마틱 스크립트 변경 사항을 편집하고 렌더링하고 저장하고 로드할 수 있는 방법입니다.

00:23:14.000 --> 00:23:21.000
앞서 언급했듯이, 사용자 지정 비디오 컴포지터는 렌더링된 비디오를 내보내는 데 사용할 수 있습니다.

00:23:21.000 --> 00:23:25.000
그리고 이것들은 사진 라이브러리로 바로 렌더링될 수 있습니다.

00:23:25.000 --> 00:23:29.000
이것은 샘플 코드에서 자세히 다룹니다.

00:23:29.000 --> 00:23:38.000
API에는 자동 감지 없이 물체에 사용할 수 있는 추적기인 CNObjectTracker도 포함되어 있습니다.

00:23:38.000 --> 00:23:45.000
샘플 코드는 탐지 없이 물체를 탭하여 트래커가 어떻게 작동할 수 있는지 다룹니다.

00:23:45.000 --> 00:23:50.000
그리고 추적기는 탐지 트랙을 제공하고 스크립트에 추가할 수 있습니다.

00:23:50.000 --> 00:23:53.000
그리고 이제 좀 더 발전된 가능성으로.

00:23:53.000 --> 00:24:01.000
자신만의 트래커를 제공하여 사용자 지정 추적을 추가하고 스크립트에 자신만의 사용자 지정 탐지 트랙을 추가할 수도 있습니다.

00:24:01.000 --> 00:24:10.000
그리고 프레임당 렌더링 속성을 사용자 지정으로 변경하여 사용자 지정 전환 및 조리개 변경을 허용할 수 있습니다.

00:24:10.000 --> 00:24:15.000
저는 개인적으로 여러분이 시네마틱 모드와 새로운 API로 무엇을 할 수 있는지에 대해 매우 흥분됩니다.

00:24:15.000 --> 00:24:22.000
그리고 그것이 간단한 앱이든 복잡한 편집기이든, 나는 당신이 우리가 생각조차 하지 못한 아이디어를 생각해 낼 수 있다고 확신합니다.

00:24:22.000 --> 00:24:39.000
이것은 재생을 위한 시네마틱 모드 비디오 자산을 재생 조정과 통합하고, 시네마틱 스크립트를 변경하고, 비파괴적인 편집과 새로운 렌더링을 만들기 위해 초점을 맞추고, 이러한 스크립트 변경 사항을 저장하고 로드할 수 있는 새로운 시네마틱 API에 대한 소개였습니다.

00:24:39.000 --> 00:24:42.000
포함된 샘플 앱에서 이것과 더 많은 것을 확인하세요.

00:24:42.000 --> 00:24:46.000
집중해 주셔서 감사합니다, 그리고 행복한 코딩 되세요.

00:24:46.000 --> 23:59:59.000
♪ ♪

