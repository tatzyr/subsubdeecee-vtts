WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:23.000
스콧: 안녕하세요, 저는 가상화 팀의 스콧 미오니스입니다. 오늘은 macOS 소노마의 기능을 통해 가상화로 원활한 경험을 만들 수 있는 방법을 다루겠습니다.

00:00:23.000 --> 00:00:29.000
가상화 프레임워크를 사용하면 가상 머신을 구성, 관리 및 실행할 수 있습니다.

00:00:29.000 --> 00:00:35.000
macOS 소노마에서 가상 맥과 리눅스 가상 머신은 그 어느 때보다 강력하다.

00:00:35.000 --> 00:00:41.000
그것들은 사용하기 쉽고, 새로운 구성 옵션으로, 고도로 사용자 정의할 수 있습니다.

00:00:41.000 --> 00:00:45.000
이것을 가능하게 하는 많은 기능이 있다.

00:00:45.000 --> 00:00:51.000
이 세션에서, 몇 가지 주요 항목과 응용 프로그램에서 그것들을 활용하는 방법을 살펴봅시다.

00:00:51.000 --> 00:00:58.000
첫째, 가상 머신의 새로운 워크플로우와 사용자 경험 개선.

00:00:58.000 --> 00:01:02.000
다음으로, 새로운 스토리지 및 키보드 구성 옵션.

00:01:02.000 --> 00:01:10.000
그리고 마지막으로, 로제타 2가 리눅스 가상 머신에서 x86_64 애플리케이션을 더 빠르게 실행하는 방법.

00:01:10.000 --> 00:01:15.000
가상 머신으로 작업하는 몇 가지 새로운 방법에 대해 알아봅시다.

00:01:15.000 --> 00:01:19.000
우리는 두 가지 강력한 새로운 기능을 살펴볼 것이다.

00:01:19.000 --> 00:01:21.000
첫 번째는 크기 조정 가능한 디스플레이입니다.

00:01:21.000 --> 00:01:28.000
창을 채우기 위해 런타임에 크기를 조정하는 가상 머신을 위한 새로운 디스플레이 옵션.

00:01:28.000 --> 00:01:31.000
그리고 다음으로, 가상 머신을 저장하고 복원하세요.

00:01:31.000 --> 00:01:38.000
나중에 재개할 수 있도록 실행 중인 가상 머신을 디스크에 직렬화하는 메커니즘.

00:01:38.000 --> 00:01:41.000
크기 조정 가능한 디스플레이부터 시작합시다.

00:01:41.000 --> 00:01:46.000
화면 크기는 가상 Mac에서 작업하는 데 큰 부분을 한다.

00:01:46.000 --> 00:01:57.000
크기 조정 가능한 디스플레이를 통해 가상 머신은 창을 채우기 위해 화면 해상도를 동적으로 조정하여 공간을 가장 효율적으로 사용합니다.

00:01:57.000 --> 00:02:00.000
이걸 코드에 넣자.

00:02:00.000 --> 00:02:09.000
자신의 애플리케이션에서 크기 조정 가능한 디스플레이를 사용하려면, 먼저 VZVirtualMachineView를 초기화하십시오.

00:02:09.000 --> 00:02:17.000
디스플레이 크기를 조정할 수 있도록 하려면, 새로운 "automaticallyReconfiguresDisplay" 속성을 true로 설정하세요.

00:02:17.000 --> 00:02:19.000
그리고 그게 다야!

00:02:19.000 --> 00:02:26.000
VZVirtualMachineView의 크기 조정은 이제 가상 머신에 디스플레이 크기를 조정하도록 자동으로 알려줍니다.

00:02:26.000 --> 00:02:33.000
그리고 디스플레이를 고정 상태로 유지하고 싶다면, 이 속성은 기본값으로 유지될 수 있습니다.

00:02:33.000 --> 00:02:38.000
다음으로, 가상 머신을 저장하고 복원하는 것에 대해 논의해 봅시다.

00:02:38.000 --> 00:02:42.000
가상 머신을 멈추는 것은 VM의 전원을 끄는 것을 의미합니다.

00:02:42.000 --> 00:02:46.000
가상 머신을 시작하는 것은 콜드 부팅을 하는 것을 의미한다.

00:02:46.000 --> 00:02:52.000
하지만 Mac에서 작업할 때, 대부분의 응용 프로그램은 작업할 때 진행 상황을 저장합니다.

00:02:52.000 --> 00:02:56.000
가상 머신에서도 동일하게 유지되어야 한다.

00:02:56.000 --> 00:03:02.000
제가 가상 머신을 운영하고 있다고 가정해 봅시다, 그리고 저는 진행 상황을 잃지 않고 그것을 닫고 싶습니다.

00:03:02.000 --> 00:03:09.000
가상 머신을 파일에 저장하고 나중에 다시 실행할 수 있습니다.

00:03:09.000 --> 00:03:13.000
아니면, 내가 내 일을 백업하고 싶다고 가정해 봅시다.

00:03:13.000 --> 00:03:23.000
디스크 및 보조 저장소와 같은 외부 리소스를 복제하여 언제든지 가상 머신을 저장할 수 있습니다.

00:03:23.000 --> 00:03:31.000
그리고 시간을 거슬러 올라가고 싶다면, 가상 머신을 이전 상태로 되감 수 있습니다.

00:03:31.000 --> 00:03:33.000
이 기능으로 많은 것이 가능하다.

00:03:33.000 --> 00:03:37.000
그러니 이제 그것을 실행에 옮기자.

00:03:37.000 --> 00:03:46.000
저는 macOS Sonoma를 실행하고 있으며, 데스크톱에는 가상화 샘플 응용 프로그램에서 macOS Sonoma를 실행하는 가상 Mac이 있습니다.

00:03:46.000 --> 00:03:50.000
그리고 나는 애플 스토어로의 다음 흥미진진한 여행을 위해 조사를 하고 있다.

00:03:50.000 --> 00:03:57.000
물론, 저는 지도가 열려 있고, AirPods에 대한 더 많은 정보를 위해 Apple 웹사이트를 둘러보고 있습니다.

00:03:57.000 --> 00:04:01.000
이제, 나는 가상 머신을 끄지 않고 휴식을 취하고 싶다.

00:04:01.000 --> 00:04:07.000
그래서 나는 애플리케이션을 종료할 때 가상 머신을 저장한다.

00:04:07.000 --> 00:04:17.000
나중에, 나는 애플리케이션을 다시 실행하고, 내 가상 머신은 모든 탭이 열린 상태에서 내가 중단한 곳에서 바로 실행을 재개한다.

00:04:17.000 --> 00:04:22.000
이것을 당신의 애플리케이션에 구축하는 방법을 살펴봅시다.

00:04:22.000 --> 00:04:26.000
가상 머신을 저장하기 전에, 가상 머신을 일시 중지하세요.

00:04:26.000 --> 00:04:32.000
이것은 가상 머신을 실행이 중단된 상태로 안정된 상태로 만든다.

00:04:32.000 --> 00:04:44.000
그런 다음, 가상 머신의 모든 런타임 상태를 포함하는 지정한 URL에 파일을 쓰는 새로운 saveMachineState API를 호출하십시오.

00:04:44.000 --> 00:04:48.000
나중에 계속 실행하는 데 필요한 모든 것.

00:04:48.000 --> 00:04:53.000
디스크 이미지와 같은 외부 리소스는 별도로 복사해야 합니다.

00:04:53.000 --> 00:04:59.000
이제 가상 머신을 저장했으니, 복원해 봅시다.

00:04:59.000 --> 00:05:08.000
가상 머신의 상태를 복원하려면, 동일한 구성에서 새로운 VZVirtualMachine을 만드는 것으로 시작하세요.

00:05:08.000 --> 00:05:23.000
가상 머신을 콜드 부팅하는 가상 머신을 직접 시작하는 대신, 이전에 저장된 파일의 URL을 전달하여 새로운 restoreMachineState API를 호출합니다.

00:05:23.000 --> 00:05:30.000
그리고 이제, 가상 머신은 이전과 정확히 같은 상태에 있다.

00:05:30.000 --> 00:05:34.000
중단된 곳에서 바로 실행을 재개할 수 있습니다.

00:05:34.000 --> 00:05:41.000
이전 저장에서 가상 머신을 복원할 때, 명심해야 할 몇 가지 사항이 있습니다.

00:05:41.000 --> 00:05:46.000
먼저, 저장 파일에는 가상 머신의 데이터가 포함되어 있습니다.

00:05:46.000 --> 00:05:48.000
그건 보호되어야 해.

00:05:48.000 --> 00:05:55.000
이 파일들은 가능한 가장 강력한 보증을 제공하기 위해 암호화된 하드웨어입니다.

00:05:55.000 --> 00:06:02.000
다른 Mac이나 사용자 계정은 다른 사람의 저장 파일을 읽거나 가상 머신을 복원할 수 없습니다.

00:06:02.000 --> 00:06:10.000
또한, 오늘 저장된 파일은 버전화되어 있으므로, 향후 새로운 기능을 추가할 수 있습니다.

00:06:10.000 --> 00:06:21.000
파일 형식이 변경되고 저장 파일을 복원할 수 없는 경우, 프레임워크는 특정 오류 코드를 반환하여 응용 프로그램이 처리할 수 있습니다.

00:06:21.000 --> 00:06:28.000
이런 일이 발생하면, 파일을 버리고, 가상 머신을 재부팅하면, 다시 정상 궤도에 오게 됩니다.

00:06:28.000 --> 00:06:33.000
다음으로, 가상 머신을 구축하는 몇 가지 새로운 방법을 살펴봅시다.

00:06:33.000 --> 00:06:36.000
첫 번째는 네트워크 차단 장치이다.

00:06:36.000 --> 00:06:41.000
이를 통해 저장 장치를 네트워크를 통해 가상 머신에 연결할 수 있습니다.

00:06:41.000 --> 00:06:49.000
다음은 virtio 블록 장치의 대안인 NVMe 컨트롤러 장치에 대한 지원입니다.

00:06:49.000 --> 00:07:00.000
그리고 마지막으로, 글로브 키와 같은 Apple 전용 키를 가상 머신에 직접 매핑하여 가상 Mac에서 더 직관적으로 작업할 수 있는 Mac 키보드.

00:07:00.000 --> 00:07:04.000
네트워크 블록 장치로 시작합시다.

00:07:04.000 --> 00:07:13.000
가상화 프레임워크에서 스토리지는 일반적으로 로컬로 제공되며, 동일한 Mac에서 디스크 이미지를 읽고 씁니다.

00:07:13.000 --> 00:07:21.000
하지만 macOS 소노마에서는 가상화 프레임워크가 서버에서 원격으로 스토리지를 제공할 수 있습니다.

00:07:21.000 --> 00:07:27.000
이것을 허용하는 프로토콜은 네트워크 블록 장치 또는 NBD이다.

00:07:27.000 --> 00:07:30.000
그것이 어떻게 작동하는지 살펴봅시다.

00:07:30.000 --> 00:07:37.000
가상화 프레임워크는 NBD 프로토콜의 클라이언트 측을 구현한다.

00:07:37.000 --> 00:07:47.000
가상 머신이 디스크에 액세스하면, 요청은 동일한 사양을 준수하는 NBD 서버로 전달됩니다.

00:07:47.000 --> 00:07:55.000
I/O가 필요한 모든 것을 한 후, NBD 서버는 데이터로 응답한다.

00:07:55.000 --> 00:08:00.000
이것은 두 가지 이유로 매우 유연하다.

00:08:00.000 --> 00:08:11.000
첫째, 스토리지는 이제 동일한 Mac 또는 네트워크를 통한 원격 서버에 어디에나 상주할 수 있습니다.

00:08:11.000 --> 00:08:25.000
그리고 둘째, 스토리지는 자체 서버에 의해 관리되기 때문에, 사용자 지정 이미지 형식이든 물리적 드라이브이든 필요한 사용자 지정 I/O를 구현할 수 있습니다.

00:08:25.000 --> 00:08:29.000
이 모든 것은 가상 머신에 완전히 투명하게.

00:08:29.000 --> 00:08:32.000
이것을 설정하는 방법을 살펴봅시다.

00:08:32.000 --> 00:08:40.000
가상화 프레임워크 API에는 저장 장치를 초기화하는 데 두 부분이 있다.

00:08:40.000 --> 00:08:43.000
먼저 장치 유형을 선택하세요.

00:08:43.000 --> 00:08:47.000
이것은 가상 머신에 제공되는 인터페이스를 정의한다.

00:08:47.000 --> 00:08:55.000
그런 다음 첨부 파일을 선택하면 Mac에서 데이터가 실제로 표시되는 방식을 선택합니다.

00:08:55.000 --> 00:08:59.000
가상 머신에서는 믹스 앤 매치할 수 있습니다.

00:08:59.000 --> 00:09:09.000
가상화 프레임워크는 virtio 블록 장치와 USB 대용량 저장 장치와 같은 가상 장치를 지원합니다.

00:09:09.000 --> 00:09:25.000
그리고 이러한 장치 중 하나를 사용하면 디스크 이미지에서 데이터를 읽고 쓰는 디스크 이미지 첨부 파일 또는 NBD 서버에서 데이터를 읽고 쓰는 새로운 네트워크 차단 장치 첨부 파일과 같은 첨부 파일을 사용할 수 있습니다.

00:09:25.000 --> 00:09:29.000
이 NBD 첨부 파일을 코드로 설정합시다.

00:09:29.000 --> 00:09:36.000
애플리케이션에서 이것을 사용하려면, 먼저 NBD 서버를 가리키는 URL을 지정하십시오.

00:09:36.000 --> 00:09:42.000
이것은 특정 서버의 특정 디스크를 식별하는 특별한 URL입니다.

00:09:42.000 --> 00:09:48.000
그런 다음 이 URL로 새로운 NBD 스토리지 첨부 파일을 초기화하세요.

00:09:48.000 --> 00:09:52.000
마지막으로, 이 첨부 파일로 저장 장치를 초기화하세요.

00:09:52.000 --> 00:09:56.000
이 예시는 virtio 블록 장치를 사용한다.

00:09:56.000 --> 00:10:02.000
대부분의 사용 사례에서, 이것은 가장 성능이 뛰어난 옵션일 가능성이 높다.

00:10:02.000 --> 00:10:08.000
스토리지가 네트워크를 통해 제공되고 있기 때문에, 언제든지 연결이 끊어질 수 있습니다.

00:10:08.000 --> 00:10:17.000
이런 일이 발생하면 조치를 취하거나, 가상 머신을 일시 중지하거나, 연결을 다시 설정할 수 있습니다.

00:10:17.000 --> 00:10:29.000
이 경우, 연결 상태가 변경될 때 알림을 받을 사용자 지정 대리자 클래스를 첨부할 수 있으므로 필요한 모든 코드를 실행할 수 있습니다.

00:10:29.000 --> 00:10:37.000
가상화 프레임워크의 스토리지 옵션에 추가하는 것은 비휘발성 메모리 익스프레스 또는 NVMe입니다.

00:10:37.000 --> 00:10:48.000
NVMe는 많은 리눅스 커널에서 활성화된 표준화된 기술이며, 응용 프로그램은 더 구체적이므로, 왜 사용하고 싶은지부터 시작합시다.

00:10:48.000 --> 00:10:59.000
대부분의 사용 사례의 경우, virtio 블록 스토리지가 제공하는 반가상화된 인터페이스는 사용하기 가장 쉽고 빠릅니다.

00:10:59.000 --> 00:11:03.000
이것은 확실히 가상 맥의 경우이다.

00:11:03.000 --> 00:11:09.000
하지만 일부 리눅스 가상 머신에는 virtio 드라이버가 없습니다.

00:11:09.000 --> 00:11:14.000
이것들은 가상 환경에서 실행되도록 구축되지 않은 커널일 수 있다.

00:11:14.000 --> 00:11:21.000
이 커널들이 종종 가지고 있는 것은 NVMe 컨트롤러 장치용 드라이버이다.

00:11:21.000 --> 00:11:33.000
macOS Sonoma에서 NVMe 컨트롤러 장치는 가상화 프레임워크에 의해 에뮬레이트되어 가상 머신에서 더 많은 운영 체제를 실행할 수 있습니다.

00:11:33.000 --> 00:11:40.000
NVMe를 구성하려면, 가상 머신을 구축할 때 새로운 장치 유형을 사용하세요.

00:11:40.000 --> 00:11:47.000
NVMe는 리눅스 가상 머신 전용이며, 물론 NBD도 지원합니다.

00:11:47.000 --> 00:11:53.000
그리고 이제, Mac 키보드를 사용하면, Apple 전용 키 누를 가상 Mac에 의해 캡처됩니다.

00:11:53.000 --> 00:12:00.000
즉, 언어 전환이나 가상 Mac에서 이모티콘과 같은 기능을 위해 글로브 키를 사용할 수 있습니다.

00:12:00.000 --> 00:12:04.000
이제 로제타 2에 대해 이야기해 봅시다.

00:12:04.000 --> 00:12:17.000
리눅스 가상 머신의 로제타 2는 macOS에서 사용되는 것과 동일한 기술이며, macOS 소노마에서 성능 개선은 로제타 2가 가상 리눅스 환경에서 훨씬 더 빠르게 실행된다는 것을 의미합니다.

00:12:17.000 --> 00:12:21.000
이것이 어떻게 가능한지 알아봅시다.

00:12:21.000 --> 00:12:35.000
Rosetta 2는 주문형 실행 페이지를 번역하여 전체 x86_64 응용 프로그램을 번역하기 위해 기다려야 하는 것보다 훨씬 빠르게 실행 파일을 실행할 수 있습니다.

00:12:35.000 --> 00:12:45.000
하지만 이것은 또한 애플리케이션이 실행되는 동안 Rosetta 2가 새로운 코드 영역을 번역하기 위해 주기적으로 실행을 중단해야 한다는 것을 의미합니다.

00:12:45.000 --> 00:12:56.000
이 오버헤드는 코드를 처음으로 번역해야 하기 때문에 애플리케이션이 막 실행되기 시작했을 때 가장 두드러질 것이다.

00:12:56.000 --> 00:13:11.000
하지만 내가 같은 라이브러리에 연결되거나 같은 실행 파일을 실행한 다른 응용 프로그램을 실행한다면, Rosetta 2는 그 코드가 이미 번역되었음에도 불구하고 모든 작업을 다시 해야 한다.

00:13:11.000 --> 00:13:15.000
이 문제는 캐싱으로 해결할 수 있다.

00:13:15.000 --> 00:13:32.000
라이브러리나 실행 가능한 바이너리가 번역될 때마다, 로제타 2는 결과를 디스크의 캐시에 저장하고 그것을 필요로 하는 다른 응용 프로그램과 공유하여 불필요한 재번역 오버헤드를 방지합니다.

00:13:32.000 --> 00:13:41.000
macOS 소노마에서 가상화 프레임워크는 새로운 런타임 데몬으로 리눅스 가상 머신에 이러한 최적화를 제공합니다.

00:13:41.000 --> 00:13:46.000
이것을 설정하려면 취해야 할 두 가지 단계가 있습니다.

00:13:46.000 --> 00:13:54.000
먼저, Rosetta 2 런타임과 새로운 캐싱 데몬 간의 통신 채널을 구성하는 새로운 API가 있습니다.

00:13:54.000 --> 00:13:58.000
그런 다음, 가상 머신에서 데몬을 실행해야 합니다.

00:13:58.000 --> 00:14:06.000
로제타 2 런타임과 새로운 데몬은 이제 가상 머신에서 서로 나란히 실행될 것이다.

00:14:06.000 --> 00:14:12.000
두 프로그램은 연결을 설정하기 위해 가상화 프레임워크와 통신한다.

00:14:12.000 --> 00:14:28.000
동적 링커 요청은 캐시를 관리하는 데몬으로 전달되며, 로제타 2 런타임은 데몬에서 직접 사전 번역된 바이너리를 가져와 재번역 오버헤드를 제거합니다.

00:14:28.000 --> 00:14:34.000
컴파일이나 패키지 설치와 같은 무거운 작업에 가장 큰 영향을 미칠 것입니다.

00:14:34.000 --> 00:14:40.000
가상화 프레임워크를 사용하면 애플리케이션에 많은 훌륭한 옵션을 제공할 수 있습니다.

00:14:40.000 --> 00:14:44.000
시작하는 방법에 대해 이야기해 봅시다.

00:14:44.000 --> 00:14:51.000
가상 Mac과 Linux 가상 머신 모두에 크기 조정 가능한 디스플레이를 사용하는 것을 고려해 보세요.

00:14:51.000 --> 00:14:57.000
그것은 한 줄의 코드로 사용자 경험을 크게 향상시킵니다.

00:14:57.000 --> 00:15:11.000
Mac 키보드는 최신 가상 Mac과 원활하게 작동하도록 특별히 설계되었으며, 이 장치로 가상 Mac을 구성하는 것은 사용자 경험을 향상시키는 쉬운 방법입니다.

00:15:11.000 --> 00:15:17.000
이러한 기능 중 일부는 강력한 경험을 구축하는 데 사용할 수 있는 빌딩 블록입니다.

00:15:17.000 --> 00:15:21.000
가상 머신을 저장하는 능력은 한 가지 예이다.

00:15:21.000 --> 00:15:27.000
진행 상황을 되감거나 저장하는 것이 응용 프로그램에 어떻게 맞는지 조사하기 시작하세요.

00:15:27.000 --> 00:15:32.000
그리고 NBD가 제공하는 유연성은 놀랍다.

00:15:32.000 --> 00:15:39.000
NBD는 사용자 지정 IO가 필요한 애플리케이션에 대한 많은 가능성을 열 수 있다.

00:15:39.000 --> 00:15:46.000
이것은 macOS 소노마에서 가상 머신이 할 수 있는 일의 시작에 불과하다.

00:15:46.000 --> 00:15:47.000
고마워.

00:15:47.000 --> 00:15:51.000
가상화 팀은 당신이 무엇을 만드는지 빨리 보고 싶어합니다.

00:15:51.000 --> 23:59:59.000
♪ ♪

