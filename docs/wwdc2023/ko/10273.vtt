WEBVTT

00:00:00.000 --> 00:00:04.000
♪ 부드러운 기악 힙합 ♪

00:00:04.000 --> 00:00:10.000
♪

00:00:10.000 --> 00:00:17.000
안녕하세요, 제 이름은 아만다이고, 저는 RealityKit과 Reality Composer Pro에서 일하는 엔지니어입니다.

00:00:17.000 --> 00:00:25.000
이 세션에서, 우리는 Reality Composer Pro에서 조립한 3D 콘텐츠를 사용하여 공간 경험을 만드는 방법을 배울 것입니다.

00:00:25.000 --> 00:00:32.000
Reality Composer Pro는 공간 컴퓨팅 앱에서 사용할 RealityKit 콘텐츠를 준비하기 위한 개발자 도구입니다.

00:00:32.000 --> 00:00:42.000
이 세션에서, 우리는 동료 에릭과 닐이 세션에서 만든 프로젝트를 계속 반복할 것이며, 코드에서 상호 작용하는 방법을 배울 것입니다.

00:00:42.000 --> 00:00:53.000
아직 세션을 시청하지 않았다면, 편집기 UI와 세션에서 다루는 Reality Composer Pro의 기능을 숙지하는 것이 좋습니다.

00:00:53.000 --> 00:00:59.000
먼저, 우리가 만든 완제품을 살펴보고, 우리가 각 부분을 어떻게 만들었는지 안내해 드리겠습니다.

00:00:59.000 --> 00:01:05.000
우리는 요세미티 국립공원의 지형도를 보고 있다.

00:01:05.000 --> 00:01:12.000
헤드셋에서 그것을 보는 것은 실제로 그곳에 직접 가지 않고는 전에는 불가능했던 광대함을 느끼게 해준다.

00:01:12.000 --> 00:01:20.000
이전 리얼리티 컴포저 프로 세션에서, 에릭은 이 장면을 조립했고, 닐스는 우리가 지형에 사용하고 있는 자료를 만들었다.

00:01:20.000 --> 00:01:25.000
여기서, 우리는 두 개의 다른 캘리포니아 랜드마크 사이를 변형하기 위해 슬라이더를 추가했습니다.

00:01:25.000 --> 00:01:30.000
이제 우리는 로스앤젤레스 해안에서 떨어진 카탈리나 섬을 보고 있다.

00:01:30.000 --> 00:01:39.000
우리는 또한 지도의 다양한 관심 지점에 대해 더 많이 배울 수 있도록 3D 공간에 위치한 2D SwiftUI 버튼을 맴돌고 있습니다.

00:01:39.000 --> 00:01:47.000
이 세션에서, 우리는 경험을 유도하는 데 사용할 수 있도록 Reality Composer Pro에서 이 콘텐츠를 어떻게 배열했는지 살펴볼 것입니다.

00:01:47.000 --> 00:01:55.000
우리가 Reality Composer Pro에서 만든 장면에 영향을 미치도록 이 슬라이더와 관심 지점 버튼을 어떻게 연결했는지 보여줄게.

00:01:55.000 --> 00:02:02.000
우리는 Reality Composer Pro 프로젝트에서 3D 콘텐츠를 프로그래밍 방식으로 로드하는 것으로 시작할 것입니다.

00:02:02.000 --> 00:02:11.000
우리는 RealityKit 구성 요소가 어떻게 작동하는지, 그리고 자체 사용자 지정 구성 요소를 만드는 것을 포함하여 코드에서 어떻게 사용할 수 있는지 살펴볼 것입니다.

00:02:11.000 --> 00:02:22.000
우리는 SwiftUI의 새로운 RealityView API에 대해 배우고 첨부 파일 API를 사용하여 장면에 사용자 인터페이스 요소를 추가하는 방법을 알아볼 것입니다.

00:02:22.000 --> 00:02:27.000
그리고 우리는 Reality Composer Pro에서 설정한 오디오로 작업하는 방법을 배울 것입니다.

00:02:27.000 --> 00:02:37.000
그런 다음, 우리는 셰이더 그래프를 사용하여 만든 사용자 지정 자료를 연결하고 코드에서 요소를 구동하여 Niels가 중단한 곳에서부터 픽업할 것입니다.

00:02:37.000 --> 00:02:40.000
시작하자.

00:02:40.000 --> 00:02:48.000
에릭의 세션에서, 우리는 우리가 원하는 방식으로 배치된 디오라마의 모든 자산을 포함하는 Reality Composer Pro 프로젝트를 만들었습니다.

00:02:48.000 --> 00:02:53.000
상단의 이 탭들은 각각 런타임에 로드할 수 있는 하나의 루트 엔티티를 나타냅니다.

00:02:53.000 --> 00:02:58.000
우리는 한 장면에 많은 것을 넣고 그것을 완전히 조립된 장면으로 취급할 수 있다.

00:02:58.000 --> 00:03:03.000
아니면 우리는 몇 개만 넣고 그 장면을 약간의 재사용 가능한 조립처럼 취급할 수 있다.

00:03:03.000 --> 00:03:05.000
우리는 우리가 원하는 만큼 만들 수 있다.

00:03:05.000 --> 00:03:12.000
런타임에 DioramaAssembled라는 이 장면을 어떻게 로드하는지 봅시다.

00:03:12.000 --> 00:03:20.000
우리는 엔티티의 비동기 이니셜라이저를 사용하여 Reality Composer Pro 패키지의 내용을 가진 엔티티를 만듭니다.

00:03:20.000 --> 00:03:28.000
우리는 문자열 이름을 사용하여 로드할 엔티티를 지정하고, 패키지가 생성하는 번들을 제공합니다.

00:03:28.000 --> 00:03:33.000
그 이름으로 Reality Composer Pro 프로젝트에서 아무것도 찾을 수 없다면 던져질 것이다.

00:03:33.000 --> 00:03:41.000
realityKitContentBundle은 Reality Composer Pro 패키지에서 자동 생성하는 일정한 값입니다.

00:03:41.000 --> 00:03:44.000
이것은 RealityView에서 마무리된다.

00:03:44.000 --> 00:03:48.000
RealityView는 새로운 종류의 SwiftUI 뷰이다.

00:03:48.000 --> 00:03:50.000
그것은 RealityKit에 대한 당신의 앙트레입니다.

00:03:50.000 --> 00:03:54.000
그것은 SwiftUI와 RealityKit의 세계 사이의 다리이다.

00:03:54.000 --> 00:04:00.000
우리는 이 세션의 뒷부분에서 이 RealityView에 대해 더 깊이 탐구할 것이다.

00:04:00.000 --> 00:04:16.000
Reality Composer Pro 프로젝트에 추가하지 않는 Xcode 프로젝트에서 사용하는 USD 자산이 있는 경우, 이러한 자산을 다음과 같이 .rkassets 디렉토리가 있는 Swift 패키지에 넣는 것이 좋습니다.

00:04:16.000 --> 00:04:23.000
Xcode는 .rkassets 폴더를 런타임에 더 빠르게 로드할 수 있는 형식으로 컴파일합니다.

00:04:23.000 --> 00:04:29.000
우리가 방금 로드한 엔티티는 실제로 더 큰 엔티티 계층의 루트이다.

00:04:29.000 --> 00:04:33.000
그것은 아동 실체를 가지고 있고 그들은 차례로 아동 실체를 가지고 있다.

00:04:33.000 --> 00:04:37.000
그것은 우리가 리얼리티 컴포저 프로 장면에서 준비한 모든 것이다.

00:04:37.000 --> 00:04:49.000
계층 구조의 하위 엔티티 중 하나를 다루고 싶다면, Reality Composer Pro에서 이름을 지정할 수 있으며, 런타임에 장면에 그 엔티티를 이름으로 찾도록 요청할 수 있습니다.

00:04:49.000 --> 00:04:55.000
엔티티는 엔티티 컴포넌트 시스템을 의미하는 ECS의 일부이다.

00:04:55.000 --> 00:04:59.000
ECS는 RealityKit과 Reality Composer Pro를 강화하는 것이다.

00:04:59.000 --> 00:05:03.000
한 걸음 물러서서 ECS를 이해합시다.

00:05:03.000 --> 00:05:11.000
ECS는 객체 지향 프로그래밍과 비슷한 유사점을 가지고 있지만 몇 가지 주요 면에서는 다르다.

00:05:11.000 --> 00:05:20.000
객체 지향 프로그래밍 세계에서, 객체는 그 본질을 정의하는 속성인 속성을 가지고 있으며, 자체 기능을 가지고 있다.

00:05:20.000 --> 00:05:25.000
당신은 객체를 정의하는 클래스에 이러한 속성과 함수를 작성합니다.

00:05:25.000 --> 00:05:30.000
ECS 세계에서, 엔티티는 당신이 현장에서 볼 수 있는 모든 것이다.

00:05:30.000 --> 00:05:32.000
그들은 또한 보이지 않을 수 있다.

00:05:32.000 --> 00:05:34.000
하지만 그들은 속성이나 데이터를 보유하지 않는다.

00:05:34.000 --> 00:05:37.000
우리는 대신 데이터를 구성 요소에 넣었다.

00:05:37.000 --> 00:05:48.000
구성 요소는 앱 실행 중에 언제든지 엔티티에 추가하거나 제거할 수 있으며, 이는 엔티티의 특성을 동적으로 변경할 수 있는 방법을 제공합니다.

00:05:48.000 --> 00:05:51.000
시스템은 우리의 행동이 사는 곳이다.

00:05:51.000 --> 00:05:54.000
프레임당 한 번 호출되는 업데이트 기능이 있습니다.

00:05:54.000 --> 00:05:56.000
그것이 당신이 지속적인 논리를 두는 곳입니다.

00:05:56.000 --> 00:06:10.000
시스템에서 특정 구성 요소가 있는 모든 엔티티 또는 구성 요소를 쿼리한 다음 몇 가지 작업을 수행하고 업데이트된 데이터를 해당 구성 요소에 다시 저장합니다.

00:06:10.000 --> 00:06:23.000
ECS에 대한 보다 심층적인 토론을 위해, 2021년의 "Dive into RealityKit 2" 세션과 올해의 "Build 공간 경험 with RealityKit"을 확인하세요.

00:06:23.000 --> 00:06:26.000
이제 구성 요소에 대해 알아봅시다.

00:06:26.000 --> 00:06:38.000
우리는 Reality Composer Pro 프로젝트의 엔티티에 구성 요소를 추가하는 방법을 본 다음, 디오라마에서 위치 마커를 만들기 위한 사용자 지정 구성 요소를 만드는 방법을 배울 것입니다.

00:06:38.000 --> 00:06:48.000
스위프트에서 엔티티에 구성 요소를 추가하려면, entity.components.set()이라고 말하고 구성 요소 값을 제공해야 합니다.

00:06:48.000 --> 00:06:57.000
Reality Composer Pro에서 똑같이 하려면, 뷰포트나 계층 구조에서 원하는 엔티티를 선택하세요.

00:06:57.000 --> 00:07:09.000
그런 다음 인스펙터 패널 하단에서 구성 요소 추가 버튼을 클릭하여 RealityKit의 사용 가능한 모든 구성 요소 목록을 불러옵니다.

00:07:09.000 --> 00:07:16.000
우리는 엔티티에 원하는 만큼 많은 구성 요소를 추가할 수 있으며, 각 유형 중 하나만 추가할 수 있습니다. 그것은 세트입니다.

00:07:16.000 --> 00:07:20.000
또한 이 목록에서 만든 사용자 지정 구성 요소도 볼 수 있습니다.

00:07:20.000 --> 00:07:26.000
Reality Composer Pro를 사용하여 자신만의 사용자 지정 구성 요소를 만드는 방법을 봅시다.

00:07:26.000 --> 00:07:35.000
우리는 당신이 그 장소에 대한 더 많은 정보를 볼 수 있도록 지형의 특정 지점을 가리키고 있는 떠다니는 버튼을 만들 것입니다.

00:07:35.000 --> 00:07:48.000
우리는 코드에서 많은 UI와 기능을 준비할 것이지만, Reality Composer Pro에서 이러한 엔티티를 플로팅 버튼을 보여주고 싶은 위치로 표시하는 방법을 보여주고 싶습니다.

00:07:48.000 --> 00:07:59.000
이를 위해, 우리는 지형 지도 위의 위치에 엔티티를 추가할 것이며, 이는 앱에 플로팅 버튼을 보여주고 싶은 장소임을 의미합니다.

00:07:59.000 --> 00:08:05.000
그런 다음 우리는 각 장소에 대한 정보를 보관하기 위해 관심 지점 구성 요소를 만들 것입니다.

00:08:05.000 --> 00:08:14.000
그런 다음 Xcode에서 PointOfInterestComponent.swift를 열어 편집하고 이름과 설명과 같은 속성을 추가합니다.

00:08:14.000 --> 00:08:24.000
Reality Composer Pro에서, 우리는 각각의 새로운 엔티티에 새로운 PointOfInterestComponent를 추가한 다음, 속성의 값을 채울 것입니다.

00:08:24.000 --> 00:08:30.000
우리의 첫 번째 위치 마커 엔티티인 카탈리나 섬에 있는 리본 비치를 만들어 봅시다.

00:08:30.000 --> 00:08:35.000
우리는 더하기 메뉴를 클릭하고 Transform을 선택하여 새로운 보이지 않는 엔티티를 만듭니다.

00:08:35.000 --> 00:08:44.000
우리는 우리의 실체를 Ribbon_Beach라고 부를 수 있다.

00:08:44.000 --> 00:08:53.000
리본 비치가 실제로 섬에 있는 곳에 이 실체를 두자.

00:08:53.000 --> 00:09:08.000
우리는 구성 요소 추가 버튼을 클릭하지만, 이번에는 우리만의 구성 요소를 만들 것이기 때문에 새 구성 요소를 선택합니다.

00:09:08.000 --> 00:09:14.000
이름을 말하자, PointOfInterest.

00:09:14.000 --> 00:09:26.000
이제 그것은 우리의 다른 구성 요소와 마찬가지로 검사관 패널에 나타난다.

00:09:26.000 --> 00:09:29.000
하지만 이 카운트 재산은 뭐야?

00:09:29.000 --> 00:09:33.000
Xcode에서 새로운 구성 요소를 열어봅시다.

00:09:33.000 --> 00:09:39.000
Xcode에서, 우리는 Reality Composer Pro가 우리를 위해 PointOfInterestComponent.swift를 만들었다는 것을 알 수 있다.

00:09:39.000 --> 00:09:47.000
리얼리티 컴포저 프로 프로젝트는 스위프트 패키지이며, 우리가 방금 생성한 스위프트 코드는 여기 패키지에 있습니다.

00:09:47.000 --> 00:09:54.000
템플릿 코드를 보면, 그것이 카운트 속성이 온 곳이라는 것을 알 수 있다.

00:09:54.000 --> 00:09:57.000
대신 다른 재산을 가지자.

00:09:57.000 --> 00:10:07.000
우리는 각 관심 지점이 어떤 지도와 관련이 있는지 알기를 원하므로 지도를 변경할 때 오래된 관심 지점을 페이드 아웃하고 적절한 지점에서 페이드할 수 있습니다.

00:10:07.000 --> 00:10:11.000
그래서 우리는 열거 속성, var 지역을 추가합니다.

00:10:11.000 --> 00:10:21.000
우리의 열거 지역을 여기에 올리자...

00:10:21.000 --> 00:10:32.000
...그리고 두 가지 사례를 주세요, 왜냐하면 우리는 지금 두 개의 지도만 만들고 있기 때문입니다: 카탈리나와 요세미티.

00:10:32.000 --> 00:10:44.000
그것은 문자열로 직렬화할 수 있다.

00:10:44.000 --> 00:10:52.000
우리는 또한 Reality Composer Pro가 그것을 보고 인스턴스를 직렬화할 수 있도록 Codable 프로토콜을 준수합니다.

00:10:52.000 --> 00:11:00.000
Reality Composer Pro로 돌아가서, 카운트 속성이 사라졌고 우리의 새로운 지역 속성이 나타납니다.

00:11:00.000 --> 00:11:09.000
그것은 우리가 코드에서 초기화한 것이기 때문에 yosemite의 기본값을 가지고 있지만, 이 특정 엔티티에 대해 여기에서 재정의할 수 있습니다.

00:11:09.000 --> 00:11:17.000
우리가 그것을 무시한다면, 이 값은 이 특정 엔티티에만 영향을 미칠 것이다.

00:11:17.000 --> 00:11:24.000
나머지 관심 지점 구성 요소는 우리가 그것들을 재정의하지 않는 한 yosemite의 기본값을 가질 것이다.

00:11:24.000 --> 00:11:30.000
우리는 PointOfInterestComponent를 이 엔티티에 붙이는 마커인 표시자처럼 사용하고 있습니다.

00:11:30.000 --> 00:11:36.000
이 엔티티는 런타임에 SwiftUI 버튼을 넣을 자리 표시자처럼 작동합니다.

00:11:36.000 --> 00:11:42.000
우리는 방금 리본 비치를 추가한 것과 같은 방식으로 다른 카탈리나 섬 관심 지점을 추가합니다.

00:11:42.000 --> 00:11:51.000
앱을 실행하고 새로운 사용자 지정 구성 요소가 무엇을 하는지 봅시다.

00:11:51.000 --> 00:11:53.000
오! 그건 아무것도 안 해.

00:11:53.000 --> 00:11:58.000
그것은 우리가 아직 이러한 관심 지점 구성 요소를 처리하기 위한 코드를 작성하지 않았기 때문입니다.

00:11:58.000 --> 00:12:00.000
그렇게 하자.

00:12:00.000 --> 00:12:05.000
SwiftUI 콘텐츠를 RealityKit 장면에 넣는 새로운 방법이 있습니다.

00:12:05.000 --> 00:12:07.000
이것은 첨부 API라고 불린다.

00:12:07.000 --> 00:12:15.000
우리는 첨부 파일을 PointOfInterestComponent와 결합하여 런타임에 사용자 지정 데이터로 호버링 버튼을 만들 것입니다.

00:12:15.000 --> 00:12:20.000
먼저 이것을 코드로 보고 데이터 흐름을 안내해 드리겠습니다.

00:12:20.000 --> 00:12:23.000
첨부 파일은 RealityView의 일부입니다.

00:12:23.000 --> 00:12:33.000
먼저 RealityView의 구조를 보여주기 위해 단순화된 예제를 살펴보면 SwiftUI 뷰가 RealityKit 장면에 어떻게 들어가는지 볼 수 있습니다.

00:12:33.000 --> 00:12:45.000
우리가 사용할 RealityView 이니셜라이저는 세 가지 매개 변수를 사용합니다: make closure, 업데이트 closure 및 첨부 파일 ViewBuilder.

00:12:45.000 --> 00:12:56.000
이것을 조금 꺼내서, 첨부 파일 보기, 녹색 SwiftUI 버튼을 만들고 RealityKit 장면에 추가하는 최소한의 구현을 추가합시다.

00:12:56.000 --> 00:13:06.000
첨부 파일 ViewBuilder에서, 우리는 일반적인 SwiftUI 보기를 만듭니다; 우리는 보기 수정자와 제스처와 SwiftUI가 우리에게 제공하는 나머지 모든 것을 사용할 수 있습니다.

00:13:06.000 --> 00:13:09.000
우리는 독특한 해시 가능으로 뷰를 태그합니다.

00:13:09.000 --> 00:13:14.000
저는 이 버튼 보기를 물고기 이모티콘으로 태그하기로 선택했습니다.

00:13:14.000 --> 00:13:21.000
나중에, SwiftUI가 업데이트 폐쇄를 호출할 때, 우리의 버튼 보기는 엔티티가 되었다.

00:13:21.000 --> 00:13:29.000
그것은 이 폐쇄에 대한 첨부 파일 매개 변수에 저장되며, 우리는 이전에 준 태그를 사용하여 그것을 낚시합니다.

00:13:29.000 --> 00:13:31.000
그러면 우리는 그것을 다른 실체처럼 취급할 수 있다.

00:13:31.000 --> 00:13:41.000
우리는 그것을 우리 장면의 기존 엔티티의 자식으로 추가하거나, 콘텐츠의 엔티티 컬렉션에서 새로운 최상위 엔티티로 추가할 수 있습니다.

00:13:41.000 --> 00:13:52.000
그리고 그것이 일반 엔티티가 되었기 때문에, 우리는 3D로 원하는 곳에 표시되도록 위치를 설정할 수 있으며, 우리가 원하는 구성 요소도 추가할 수 있습니다.

00:13:52.000 --> 00:13:57.000
RealityView의 한 부분에서 다른 부분으로 데이터가 흐르는 방법은 다음과 같습니다.

00:13:57.000 --> 00:14:01.000
이 RealityView 이니셜라이저의 세 가지 매개 변수를 살펴봅시다.

00:14:01.000 --> 00:14:13.000
첫 번째는 Make로, Reality Composer Pro 번들에서 초기 설정 장면을 엔티티로 로드한 다음 RealityKit 장면에 추가하는 곳입니다.

00:14:13.000 --> 00:14:19.000
두 번째는 업데이트이며, 이는 당신의 견해 상태에 변화가 있을 때 호출될 폐쇄입니다.

00:14:19.000 --> 00:14:29.000
여기서, 구성 요소의 속성, 위치와 같은 엔티티에 대한 것들을 변경할 수 있으며, 심지어 현장에서 엔티티를 추가하거나 제거할 수도 있습니다.

00:14:29.000 --> 00:14:32.000
이 업데이트 클로저는 모든 프레임에서 실행되지 않습니다.

00:14:32.000 --> 00:14:37.000
SwiftUI 뷰 상태가 바뀔 때마다 호출됩니다.

00:14:37.000 --> 00:14:40.000
세 번째는 첨부 파일 ViewBuilder입니다.

00:14:40.000 --> 00:14:46.000
이곳은 RealityKit 장면에 넣을 SwiftUI 뷰를 만들 수 있는 곳입니다.

00:14:46.000 --> 00:14:55.000
SwiftUI 뷰는 첨부 파일 ViewBuilder에서 시작한 다음 첨부 파일 매개 변수의 업데이트 클로저에서 전달됩니다.

00:14:55.000 --> 00:15:04.000
여기서, 첨부 파일 ViewBuilder의 버튼에 제공한 것과 동일한 태그를 사용하는 엔티티가 있는지 첨부 파일 매개 변수에 물어봅니다.

00:15:04.000 --> 00:15:09.000
만약 하나가 있다면, 그것은 당신에게 RealityKit 엔티티를 판매합니다.

00:15:09.000 --> 00:15:19.000
업데이트 클로저에서 3D 위치를 설정하고 RealityKit 장면에 추가하여 원하는 곳 어디에서나 우주에 떠 있는 것을 볼 수 있습니다.

00:15:19.000 --> 00:15:24.000
여기서, 나는 내 버튼 엔티티를 구체 엔티티의 자식으로 추가했다.

00:15:24.000 --> 00:15:28.000
나는 그것을 부모보다 0.2미터 위에 배치했다.

00:15:28.000 --> 00:15:32.000
메이크업 클로저에는 또한 첨부 파일 매개 변수가 있습니다.

00:15:32.000 --> 00:15:41.000
이것은 이 보기가 처음 평가될 때 갈 준비가 된 첨부 파일을 추가하기 위한 것입니다. 왜냐하면 make closure은 한 번만 실행되기 때문입니다.

00:15:41.000 --> 00:15:48.000
이제 RealityView의 일반적인 흐름을 이해했으므로, 업데이트 종료에 더 자세히 들어가 봅시다.

00:15:48.000 --> 00:15:54.000
만들기 및 업데이트 클로저의 매개 변수는 RealityKitContent입니다.

00:15:54.000 --> 00:16:00.000
RealityKit 콘텐츠에 엔티티를 추가하면, 장면에서 최상위 엔티티가 됩니다.

00:16:00.000 --> 00:16:08.000
마찬가지로, 업데이트 기능에서 콘텐츠에 엔티티를 추가하면 장면에서 새로운 최상위 엔티티를 제공합니다.

00:16:08.000 --> 00:16:14.000
Make 폐쇄는 한 번만 호출되지만, 업데이트 폐쇄는 한 번 이상 호출될 것이다.

00:16:14.000 --> 00:16:25.000
업데이트 종료에서 새 엔티티를 만들고 콘텐츠에 추가하면, 원하는 것이 아닐 수도 있는 해당 엔티티의 복사본을 얻을 수 있습니다.

00:16:25.000 --> 00:16:32.000
그것을 방지하기 위해, 한 번만 실행되는 어딘가에서 생성된 콘텐츠에 엔티티만 추가해야 합니다.

00:16:32.000 --> 00:16:37.000
Content.entities에 이미 당신의 엔티티가 포함되어 있는지 확인할 필요가 없습니다.

00:16:37.000 --> 00:16:42.000
세트와 같이 같은 엔티티로 add를 두 번 호출하면 no-op입니다.

00:16:42.000 --> 00:16:49.000
엔티티를 장면의 기존 엔티티에 부모로 삼을 때도 동일합니다. 두 번 추가되지 않습니다.

00:16:49.000 --> 00:16:58.000
첨부 파일 엔티티는 귀하가 생성하지 않습니다. 첨부 파일 ViewBuilder에서 제공하는 각 첨부 파일 보기에 대해 RealityView에 의해 생성됩니다.

00:16:58.000 --> 00:17:05.000
그것은 그것이 이미 있는지 확인하지 않고 업데이트 클로저의 콘텐츠에 추가하는 것이 안전하다는 것을 의미합니다.

00:17:05.000 --> 00:17:13.000
그래서, 그것이 우리가 첨부 파일 ViewBuilder에서 관심 지점을 하드코딩하고 싶다면 첨부 파일 코드를 작성하는 방법이었다.

00:17:13.000 --> 00:17:20.000
하지만 우리는 Reality Composer Pro 프로젝트의 데이터가 경험을 주도하게 하고 싶기 때문에, 더 유연하게 만들어 봅시다.

00:17:20.000 --> 00:17:31.000
그렇게 하면, 디자이너나 프로듀서는 Reality Composer Pro 프로젝트에서 관심 지점을 만들 수 있으며, 우리의 코드는 그들이 추가하는 모든 데이터를 수용할 수 있습니다.

00:17:31.000 --> 00:17:38.000
데이터 중심을 만들기 위해, 우리는 Reality Composer Pro 장면에서 설정한 데이터를 읽을 수 있는 코드가 필요합니다.

00:17:38.000 --> 00:17:42.000
우리는 첨부 파일을 동적으로 만들 것이다.

00:17:42.000 --> 00:17:46.000
높은 수준, 여기 우리가 할 일이 있습니다.

00:17:46.000 --> 00:17:56.000
Reality Composer Pro에서, 우리는 이미 리본 비치의 자리 표시자 엔티티를 설정했으며, 디오라마에서 강조하고 싶은 다른 관심 지점에 대해서도 똑같이 할 것입니다.

00:17:56.000 --> 00:18:02.000
우리는 그들의 이름과 그들이 속한 지도와 같이 각자가 필요로 하는 모든 정보를 작성할 것입니다.

00:18:02.000 --> 00:18:09.000
이제, 코드에서, 우리는 그 엔티티를 쿼리하고 각각에 대해 새로운 SwiftUI 버튼을 만들 것입니다.

00:18:09.000 --> 00:18:20.000
SwiftUI가 컬렉션에 새 버튼을 추가할 때마다 첨부 파일 ViewBuilder를 호출하도록 하기 위해, 이 컬렉션에 @State 속성 래퍼를 추가할 것입니다.

00:18:20.000 --> 00:18:24.000
우리는 그 버튼들을 첨부 파일 ViewBuilder까지 제공할 것입니다.

00:18:24.000 --> 00:18:33.000
그런 다음 마지막으로, RealityView의 업데이트 종료에서, 우리는 버튼을 엔티티로 받고 새로운 버튼 엔티티를 장면에 추가할 것입니다.

00:18:33.000 --> 00:18:39.000
우리는 Reality Composer Pro에서 설정한 마커 엔티티의 자식으로 각각을 추가할 것입니다.

00:18:39.000 --> 00:18:46.000
더 자세한 다이어그램을 통해 이 여섯 단계를 이해한 다음, 코드를 살펴봅시다.

00:18:46.000 --> 00:18:51.000
먼저, 우리는 Reality Composer Pro 장면에 보이지 않는 엔티티를 추가합니다.

00:18:51.000 --> 00:18:58.000
우리는 버튼이 나타나기를 원하는 곳에 x-, y- 및 z-축에 보이지 않는 엔티티를 배치합니다.

00:18:58.000 --> 00:19:04.000
우리는 모든 엔티티가 기본적으로 가지고 있는 변환 구성 요소를 사용하고 있습니다.

00:19:04.000 --> 00:19:09.000
그런 다음 우리는 각각에 PointOfInterestComponent를 추가합니다.

00:19:09.000 --> 00:19:17.000
우리의 코드에서, 우리는 PointOfInterestComponent가 있는 장면의 모든 엔티티를 쿼리하여 이러한 엔티티에 대한 참조를 가져옵니다.

00:19:17.000 --> 00:19:24.000
쿼리는 Reality Composer Pro에서 설정한 세 개의 보이지 않는 엔티티를 반환합니다.

00:19:24.000 --> 00:19:30.000
우리는 각각에 대해 새로운 SwiftUI 뷰를 만들고 컬렉션에 저장합니다.

00:19:30.000 --> 00:19:36.000
버튼을 RealityView에 넣기 위해, 우리는 SwiftUI 보기 업데이트 흐름을 사용할 것입니다.

00:19:36.000 --> 00:19:43.000
이것은 우리 보기의 버튼 모음에 속성 래퍼 @State를 추가하는 것을 의미합니다.

00:19:43.000 --> 00:19:53.000
@State 속성 래퍼는 SwiftUI에게 이 컬렉션에 항목을 추가할 때 SwiftUI가 ImmersiveView에서 보기 업데이트를 트리거해야 한다고 알려줍니다.

00:19:53.000 --> 00:20:00.000
그로 인해 SwiftUI는 첨부 파일 ViewBuilder와 업데이트 종료를 다시 평가할 것입니다.

00:20:00.000 --> 00:20:09.000
RealityView의 첨부 파일 ViewBuilder는 이러한 버튼이 엔티티로 만들어지기를 원한다는 것을 SwiftUI에 선언하는 곳입니다.

00:20:09.000 --> 00:20:16.000
우리의 RealityView의 업데이트 폐쇄는 다음에 호출될 것이며, 우리의 버튼은 엔티티로서 우리에게 전달될 것입니다.

00:20:16.000 --> 00:20:18.000
그들은 이제 더 이상 SwiftUI 뷰가 아니다.

00:20:18.000 --> 00:20:22.000
그것이 우리가 그것들을 엔티티 계층 구조에 추가할 수 있는 이유이다.

00:20:22.000 --> 00:20:30.000
업데이트 종료에서, 우리는 보이지 않는 각 엔티티 위에 떠 있는 장면에 첨부 엔티티를 추가합니다.

00:20:30.000 --> 00:20:35.000
이제 그들은 우리가 디오라마 장면을 볼 때 시각적으로 나타날 것이다.

00:20:35.000 --> 00:20:38.000
이 단계들 각각이 어떻게 이루어지는지 봅시다.

00:20:38.000 --> 00:20:43.000
먼저, 우리는 Reality Composer Pro 장면에서 보이지 않는 실체를 표시합니다.

00:20:43.000 --> 00:20:48.000
우리가 표시한 엔티티를 찾기 위해, 우리는 EntityQuery를 만들 것이다.

00:20:48.000 --> 00:20:53.000
우리는 그것을 사용하여 PointOfInterestComponent가 있는 모든 엔티티를 요청할 것입니다.

00:20:53.000 --> 00:21:03.000
그런 다음 QueryResult를 통해 반복하고 PointOfInterestComponent가 있는 장면의 각 엔티티에 대한 새로운 SwiftUI 뷰를 만들 것입니다.

00:21:03.000 --> 00:21:10.000
우리는 구성 요소에서 얻은 정보, Reality Composer Pro에 입력한 데이터로 채울 것입니다.

00:21:10.000 --> 00:21:15.000
그 견해는 우리의 첨부 파일 중 하나가 될 것이므로, 우리는 그것에 태그를 붙였다.

00:21:15.000 --> 00:21:23.000
이 경우, 우리는 진지해지고 있으므로, 물고기 이모티콘이 아닌 ObjectIdentifier를 사용할 것입니다.

00:21:23.000 --> 00:21:26.000
여기 우리가 SwiftUI 뷰 컬렉션을 만드는 부분이 있습니다.

00:21:26.000 --> 00:21:34.000
RealityView의 첨부 파일 ViewBuilder에 대한 첨부 파일을 제공할 것이기 때문에 첨부 파일 제공자라고 부를 것입니다.

00:21:34.000 --> 00:21:37.000
그런 다음 우리는 첨부 파일 제공자에게 우리의 견해를 저장할 것입니다.

00:21:37.000 --> 00:21:40.000
그 수집 유형을 살펴봅시다.

00:21:40.000 --> 00:21:45.000
AttachmentsProvider에는 보기에 대한 첨부 태그 사전이 있습니다.

00:21:45.000 --> 00:21:52.000
우리는 LearnMoreView 외에 다른 종류의 뷰를 넣을 수 있도록 뷰를 입력하여 지웠다.

00:21:52.000 --> 00:22:03.000
우리는 매번 같은 순서로 튜플 배열(태그와 해당 뷰)을 반환하는 sortedTagViewPairs라는 계산된 속성을 가지고 있습니다.

00:22:03.000 --> 00:22:10.000
그런 다음, 첨부 파일 ViewBuilder에서, 우리는 우리가 만든 첨부 파일 모음을 통해 ForEach를 할 것입니다.

00:22:10.000 --> 00:22:19.000
이것은 SwiftUI에게 우리가 제공한 각 쌍에 대해 하나의 보기를 원한다고 말하며, 우리는 컬렉션에서 우리의 견해를 제공합니다.

00:22:19.000 --> 00:22:31.000
우리는 ObjectIdentifier가 뷰의 첨부 태그와 ForEach 구조의 식별자로 이중 역할을 하도록 하고 있습니다.

00:22:31.000 --> 00:22:37.000
그래서, 왜 우리는 대신 PointOfInterestComponent에 태그 속성을 추가하지 않았나요?

00:22:37.000 --> 00:22:45.000
첨부 태그는 ForEach 구조체와 첨부 메커니즘이 작동하려면 고유해야 합니다.

00:22:45.000 --> 00:22:58.000
그리고 구성 요소를 엔티티에 추가할 때 사용자 지정 구성 요소의 모든 속성이 Reality Composer Pro의 인스펙터 패널에 표시되기 때문에, 이는 첨부 태그도 거기에 표시된다는 것을 의미합니다.

00:22:58.000 --> 00:23:06.000
우리는 Reality Composer Pro에 각 관심 지점을 추가할 때 모든 태그를 일치시키는 것을 기억해야 하는 부담을 주고 싶지 않습니다.

00:23:06.000 --> 00:23:15.000
하지만, 우리에게 편리하게, 엔티티는 식별 가능한 프로토콜을 준수하므로, 자동으로 고유한 식별자를 가지고 있습니다.

00:23:15.000 --> 00:23:25.000
Reality Composer Pro에서 장면을 디자인할 때 미리 알 필요 없이 엔티티에서 런타임에 이 식별자를 얻을 수 있습니다.

00:23:25.000 --> 00:23:36.000
attachmentTag 속성이 Reality Composer Pro에 나타나지 않도록 하기 위해, 우리는 내가 "디자인 타임 대 런타임 구성 요소"라고 부르는 기술을 사용합니다.

00:23:36.000 --> 00:23:51.000
우리는 데이터를 두 개의 다른 구성 요소로 분리할 것입니다. 하나는 Reality Composer Pro에서 배열하고 싶은 디자인 타임 데이터이고 다른 하나는 런타임에 동적으로 동일한 엔티티에 연결할 런타임 데이터입니다.

00:23:51.000 --> 00:23:58.000
이것은 Reality Composer Pro의 Inspector Panel에서 보여주고 싶지 않은 속성을 위한 것입니다.

00:23:58.000 --> 00:24:06.000
그래서 우리는 새로운 구성 요소인 PointOfInterestRuntimeComponent를 정의하고 그 안에 첨부 태그를 옮길 것입니다.

00:24:06.000 --> 00:24:13.000
Reality Composer Pro는 Swift 패키지에서 읽은 내용을 기반으로 구성 요소 UI를 자동으로 구축합니다.

00:24:13.000 --> 00:24:22.000
패키지의 스위프트 코드를 검사하고 장면에서 사용할 수 있는 코딩 가능한 구성 요소를 만듭니다.

00:24:22.000 --> 00:24:24.000
여기서 우리는 네 가지 구성 요소를 보여주고 있다.

00:24:24.000 --> 00:24:37.000
구성 요소 A와 B는 Xcode 프로젝트에 있지만 Reality Composer Pro 패키지 안에 있지 않으므로 Reality Composer Pro의 엔티티에 연결할 수 없습니다.

00:24:37.000 --> 00:24:45.000
구성 요소 C는 패키지 안에 있지만 성문화할 수 없으므로 Reality Composer Pro는 이를 무시할 것이다.

00:24:45.000 --> 00:24:56.000
여기에 표시된 네 가지 구성 요소 중, Swift 패키지 내에 있고 코딩 가능한 구성 요소이기 때문에 Reality Composer Pro의 목록에 Component D만 표시됩니다.

00:24:56.000 --> 00:25:03.000
그것은 우리의 설계 시간 구성 요소이며, 다른 모든 것들은 런타임 구성 요소로 사용될 수 있다.

00:25:03.000 --> 00:25:13.000
디자인 타임 구성 요소는 3D 아티스트와 디자이너가 사용할 ints, 문자열 및 SIMD 값과 같은 더 간단한 데이터를 수용하기 위한 것입니다.

00:25:13.000 --> 00:25:23.000
Reality Composer Pro가 직렬화하지 않는 유형의 사용자 지정 구성 요소에 속성을 추가하면 Xcode 프로젝트에 오류가 표시됩니다.

00:25:23.000 --> 00:25:26.000
이제, 우리 코드로 돌아가자.

00:25:26.000 --> 00:25:39.000
먼저 PointOfInterest 런타임 구성 요소를 엔티티에 추가한 다음 런타임 구성 요소를 사용하여 첨부 엔티티를 디오라마의 해당 관심 지점과 일치시킬 수 있습니다.

00:25:39.000 --> 00:25:42.000
여기가 우리의 런타임 구성 요소가 들어오는 곳입니다.

00:25:42.000 --> 00:25:48.000
우리는 PointOfInterest 엔티티에서 읽고 첨부 뷰를 만드는 부분에 있습니다.

00:25:48.000 --> 00:25:55.000
우리는 모든 설계 시간 구성 요소에 대해 문의했고, 이제 각각에 대해 새로운 해당 런타임 구성 요소를 만들 것입니다.

00:25:55.000 --> 00:26:02.000
우리는 attachmentTag를 런타임 구성 요소에 저장하고, 런타임 구성 요소를 동일한 엔티티에 저장합니다.

00:26:02.000 --> 00:26:06.000
이런 식으로, 디자인 타임 구성 요소는 기호와 같다.

00:26:06.000 --> 00:26:10.000
그것은 우리 앱에 그것을 위해 만들어진 첨부 파일을 원한다고 말한다.

00:26:10.000 --> 00:26:20.000
런타임 구성 요소는 앱 실행 중에 필요한 다른 종류의 데이터를 처리하지만, 디자인 타임 구성 요소에 저장하고 싶지는 않습니다.

00:26:20.000 --> 00:26:26.000
RealityView에서, 우리는 첨부 파일 엔티티가 우리 장면에 나타나는 것을 보기 전에 한 단계 더 있다.

00:26:26.000 --> 00:26:38.000
첨부 파일 ViewBuilder에 SwiftUI 뷰를 제공하면, SwiftUI는 RealityView의 업데이트 종료를 호출하고 첨부 파일을 RealityKit 엔티티로 제공합니다.

00:26:38.000 --> 00:26:47.000
하지만 우리가 그것들을 배치하지 않고 콘텐츠에 추가한다면, 그들은 모두 장면의 시작점, 위치 0, 0, 0에 나타날 것이다.

00:26:47.000 --> 00:26:49.000
그건 우리가 그들을 원하는 곳이 아니야.

00:26:49.000 --> 00:26:53.000
우리는 그들이 지형의 각 관심 지점 위에 뜨기를 원한다.

00:26:53.000 --> 00:27:01.000
우리는 첨부 엔티티를 Reality Composer Pro에서 설정한 보이지 않는 관심 지점 엔티티와 일치시켜야 합니다.

00:27:01.000 --> 00:27:06.000
우리가 보이지 않는 엔티티에 넣은 런타임 구성 요소에는 태그가 있습니다.

00:27:06.000 --> 00:27:12.000
그것이 우리가 어떤 attachmentEntity가 각 관심 지점과 일치하는지 일치시키는 방법입니다.

00:27:12.000 --> 00:27:30.000
우리는 모든 PointOf InterestRuntimeComponents를 쿼리하고, 쿼리에 의해 반환된 각 엔티티에서 런타임 구성 요소를 얻은 다음, 구성 요소의 attachmentTag 속성을 사용하여 첨부 파일 매개 변수에서 업데이트 클로저로 attachmentEntity를 가져옵니다.

00:27:30.000 --> 00:27:37.000
이제 우리는 첨부 엔티티를 콘텐츠에 추가하고 관심 지점보다 0.5미터 위에 배치합니다.

00:27:37.000 --> 00:27:42.000
앱을 다시 실행하고 이것들이 어떻게 생겼는지 봅시다.

00:27:42.000 --> 00:27:44.000
이봐, 그들은 멋져 보여!

00:27:44.000 --> 00:27:50.000
우리는 Reality Composer Pro 프로젝트에 넣은 장소 위에 떠 있는 각 장소 이름을 볼 수 있습니다.

00:27:50.000 --> 00:27:56.000
다음으로 Reality Composer Pro에서 설정한 오디오를 어떻게 재생하는지 알아봅시다.

00:27:56.000 --> 00:28:09.000
Reality Composer Pro에서 오디오를 재생하는 것을 설정하려면, 더하기 버튼을 클릭하고 오디오를 선택한 다음 앰비언트 오디오를 선택하여 오디오 엔티티를 가져올 수 있습니다.

00:28:09.000 --> 00:28:15.000
이것은 AmbientAudioComponent가 있는 정기적인 보이지 않는 엔티티를 만듭니다.

00:28:15.000 --> 00:28:22.000
카탈리나 섬의 바다 소리를 연주하는 데 사용할 것이기 때문에 OceanEmitter의 이름을 짓자.

00:28:22.000 --> 00:28:25.000
장면에도 오디오 파일을 추가해야 합니다.

00:28:25.000 --> 00:28:35.000
우리의 바다 소리를 가져오자.

00:28:35.000 --> 00:28:48.000
인스펙터 패널에서 구성 요소의 미리보기 메뉴에서 사운드를 선택하여 오디오 구성 요소를 미리 볼 수 있지만, 엔티티가 앱에 로드될 때 선택한 사운드가 자동으로 재생되지 않습니다.

00:28:48.000 --> 00:28:55.000
그것을 위해, 우리는 오디오 리소스를 로드하고 재생하라고 말해야 한다.

00:28:55.000 --> 00:29:00.000
이 소리를 재생하기 위해, 우리는 오디오 구성 요소를 넣은 엔티티에 대한 참조를 얻을 것이다.

00:29:00.000 --> 00:29:05.000
우리는 우리의 엔티티를 OceanEmitter로 명명했기 때문에, 그 이름으로 우리의 엔티티를 찾을 것이다.

00:29:05.000 --> 00:29:15.000
우리는 AudioFileResource 이니셜라이저를 사용하여 사운드 파일을 로드하여 장면의 오디오 파일 리소스 prim에 대한 전체 경로를 전달합니다.

00:29:15.000 --> 00:29:20.000
우리는 Reality Composer Pro 프로젝트에 포함된 .usda 파일의 이름을 부여합니다.

00:29:20.000 --> 00:29:27.000
우리의 경우, 그것은 DioramaAssembled.usda라는 이름의 주요 장면이다.

00:29:27.000 --> 00:29:35.000
우리는 이 소리를 재생, 일시 중지 및 중지할 수 있도록 entity.prepareAudio를 호출하여 audioPlaybackController를 만듭니다.

00:29:35.000 --> 00:29:38.000
이제 우리는 그것에 대해 플레이할 준비가 되었다.

00:29:38.000 --> 00:29:41.000
여기 우리 앱에서 재생되는 바다 소리가 있습니다.

00:29:41.000 --> 00:29:56.000
우리 앱의 슬라이더는 두 개의 다른 지형 지도인 요세미티와 카탈리나 섬 사이에서 변형됩니다.

00:29:56.000 --> 00:30:04.000
이제 우리는 우리의 장면에 오디오를 도입했으므로, 우리는 두 개의 오디오 소스 사이에서 크로스페이드할 것이다.

00:30:04.000 --> 00:30:09.000
우리는 해양 이미터 엔티티를 추가한 것과 같은 방식으로 숲 오디오 이미터를 추가합니다.

00:30:09.000 --> 00:30:17.000
슬라이더를 사용하여 지형을 어떻게 변형하고 있는지 살펴보고, 이 전환에 오디오도 포함할 것입니다.

00:30:17.000 --> 00:30:22.000
우리는 셰이더 그래프 자료의 속성을 사용하여 두 지형 사이를 변형할 것입니다.

00:30:22.000 --> 00:30:25.000
우리가 그걸 어떻게 하는지 보자.

00:30:25.000 --> 00:30:33.000
닐스의 세션에서, 그는 리얼리티 컴포저 프로의 셰이더 그래프를 사용하여 이 아름다운 기하학 수정자를 만들었다.

00:30:33.000 --> 00:30:38.000
이제 우리는 그것을 우리의 장면에 연결하고 런타임에 일부 매개 변수를 구동할 수 있습니다.

00:30:38.000 --> 00:30:42.000
우리는 이 셰이더 그래프 자료를 슬라이더와 연결하고 싶습니다.

00:30:42.000 --> 00:30:45.000
그렇게 하려면, 우리는 입력 노드를 홍보해야 한다.

00:30:45.000 --> 00:30:49.000
노드를 Command-클릭하고 Promote를 선택하세요.

00:30:49.000 --> 00:30:55.000
이것은 우리가 런타임에 자료의 이 부분에 데이터를 공급할 계획이라는 것을 프로젝트에 알려준다.

00:30:55.000 --> 00:31:02.000
우리는 이 프로모션된 노드 Progress의 이름을 지정할 것이므로, 런타임에 그 이름으로 처리할 수 있습니다.

00:31:02.000 --> 00:31:06.000
우리는 이제 코드에서 이 값을 동적으로 변경할 수 있다.

00:31:06.000 --> 00:31:10.000
우리는 우리의 자료가 있는 실체에 대한 참조를 얻는다.

00:31:10.000 --> 00:31:16.000
그런 다음 우리는 재료를 수용하는 RealityKit 구성 요소인 ModelComponent를 얻는다.

00:31:16.000 --> 00:31:20.000
ModelComponent에서, 우리는 첫 번째 재료를 얻는다.

00:31:20.000 --> 00:31:22.000
이 특정 실체에는 오직 하나만 있다.

00:31:22.000 --> 00:31:26.000
우리는 그것을 ShaderGraphMaterial로 캐스팅했다.

00:31:26.000 --> 00:31:31.000
이제, 우리는 Progress라는 이름으로 매개 변수에 대한 새로운 값을 설정할 수 있습니다.

00:31:31.000 --> 00:31:39.000
마지막으로, 우리는 재료를 ModelComponent에 다시 저장하고, ModelComponent를 지형 엔티티에 다시 저장합니다.

00:31:39.000 --> 00:31:43.000
이제 우리는 그것을 SwiftUI 슬라이더에 연결할 것입니다.

00:31:43.000 --> 00:31:52.000
슬라이더의 값이 바뀔 때마다, 우리는 0에서 1 범위에 있는 그 값을 잡고 ShaderGraphMaterial에 공급할 것입니다.

00:31:52.000 --> 00:31:59.000
다음으로, 두 지형의 앰비언트 오디오 트랙 사이를 크로스페이드해 봅시다.

00:31:59.000 --> 00:32:11.000
우리는 또한 바다와 숲의 두 오디오 엔티티에 AmbientAudioComponent를 넣었기 때문에, 이득 속성을 사용하여 소리가 얼마나 큰지 조정할 수 있습니다.

00:32:11.000 --> 00:32:19.000
우리는 AmbientAudioComponent가 있는 모든 엔티티 - 이 시점에서 우리의 바다와 숲의 모든 엔티티를 쿼리할 것입니다.

00:32:19.000 --> 00:32:28.000
게다가, 우리는 RegionSpecificComponent라는 또 다른 사용자 지정 구성 요소를 추가하여 한 지역 또는 다른 지역과 함께 가는 엔티티를 표시할 수 있습니다.

00:32:28.000 --> 00:32:36.000
우리는 그것을 변경하고 우리 엔티티에 다시 저장할 것이기 때문에 오디오 컴포넌트의 변경 가능한 복사본을 얻는다.

00:32:36.000 --> 00:32:42.000
우리는 지역과 슬라이더값이 주어져야 하는 이득을 계산하는 함수를 부른다.

00:32:42.000 --> 00:32:50.000
우리는 AmbientAudioComponent에 게인 값을 설정한 다음, 구성 요소를 엔티티에 다시 저장합니다.

00:32:50.000 --> 00:32:52.000
그게 실제로 실행되는지 보자.

00:32:52.000 --> 00:33:08.000
좋아!

00:33:08.000 --> 00:33:18.000
슬라이더를 움직일 때, 우리는 셰이더 그래프 재료가 지형 지도의 기하학을 바꾸는 것을 볼 수 있으며, 숲 소리가 사라지고 바다 소리가 들어오는 것을 들을 수 있습니다.

00:33:18.000 --> 00:33:28.000
우리는 오늘 많은 정보를 다루었다.

00:33:28.000 --> 00:33:29.000
요약하자.

00:33:29.000 --> 00:33:35.000
우리는 Reality Composer Pro 콘텐츠를 Xcode의 앱에 로드하는 방법을 배웠습니다.

00:33:35.000 --> 00:33:40.000
우리는 Reality Composer Pro에서 자신만의 사용자 지정 구성 요소를 만드는 방법을 살펴보았습니다.

00:33:40.000 --> 00:33:46.000
우리는 SwiftUI Attachments API가 어떻게 작동하는지 그리고 그것이 엔티티로서 우리에게 어떻게 전달되는지 탐구했습니다.

00:33:46.000 --> 00:33:50.000
우리는 오디오를 설정하고 그 오디오를 코드로 재생하는 방법을 보았다.

00:33:50.000 --> 00:33:57.000
그리고 마지막으로, 우리는 승진된 물질적 속성을 가지고 코드에서 그것을 구동하는 방법을 보았다.

00:33:57.000 --> 00:34:01.000
이러한 워크플로우는 당신의 공간적 경험에 생명을 불어넣는 데 도움이 될 것입니다.

00:34:01.000 --> 00:34:06.000
나는 당신이 우리의 새로운 플랫폼에서 구축할 모든 놀라운 것들을 보기를 기대합니다.

00:34:06.000 --> 00:34:07.000
고마워.

00:34:07.000 --> 23:59:59.000
♪

