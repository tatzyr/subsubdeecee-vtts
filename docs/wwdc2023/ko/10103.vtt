WEBVTT

00:00:00.000 --> 00:00:11.000
♪ ♪

00:00:11.000 --> 00:00:12.000
로만 에피모프: 안녕하세요, 여러분.

00:00:12.000 --> 00:00:16.000
제 이름은 로만 에피모프이고, 저는 바로 가기 팀의 엔지니어입니다.

00:00:16.000 --> 00:00:23.000
오늘, 저는 앱 인텐트의 흥미진진한 새로운 기능과 개선 사항을 다루며, 더 나은 앱을 만들 수 있도록 도울 것입니다.

00:00:23.000 --> 00:00:26.000
먼저, 나는 위젯으로 시작할 것이다.

00:00:26.000 --> 00:00:31.000
아시다시피, 위젯은 iOS 사용자 경험에서 점점 더 중요한 부분이 되었습니다.

00:00:31.000 --> 00:00:41.000
그리고 이제, 앱 인텐트와 위젯은 상호 작용과 구성을 통해 새로운 경험을 제공하기 위해 원활하게 작동합니다.

00:00:41.000 --> 00:00:45.000
다음으로, 저는 올해 우리가 만든 개발자 경험의 개선으로 넘어갈 것입니다.

00:00:45.000 --> 00:00:53.000
나는 프레임워크 지원과 같은 몇 가지 품질 개선 사항과 정적 추출에 대한 최근의 개선 사항을 다룰 것이다.

00:00:53.000 --> 00:00:59.000
그리고 마지막으로, 저는 앱 인텐트와의 단축키 앱 통합에 대한 업데이트에 뛰어들 것입니다.

00:00:59.000 --> 00:01:05.000
우리는 꽤 꽉 찬 의제를 가지고 있으므로, 위젯에 대한 몇 가지 흥미로운 업데이트로 시작합시다.

00:01:05.000 --> 00:01:09.000
먼저, 위젯 구성에 대해 이야기해 봅시다.

00:01:09.000 --> 00:01:19.000
구성 가능한 위젯을 만들 때, 그 사람이 위젯의 뒷면에서 선택할 수 있는 옵션을 지정할 수 있습니다.

00:01:19.000 --> 00:01:31.000
이러한 옵션을 매개 변수라고 하며, 앱에 Siri 및 단축키에 대한 지원을 추가하는 데 사용하는 것과 동일한 시스템을 사용하여 정의할 수 있습니다: 인텐트.

00:01:31.000 --> 00:01:39.000
위젯의 구성 UI는 해당 의도에 포함된 정렬된 매개 변수 목록을 표시합니다.

00:01:39.000 --> 00:01:46.000
의도에 추가된 각 매개 변수는 위젯 구성 인터페이스에서 행으로 표시됩니다.

00:01:46.000 --> 00:01:53.000
과거에는 의도 정의 파일을 사용하여 Xcode에서 의도를 선언해야 했습니다.

00:01:53.000 --> 00:02:04.000
이제 iOS 17에서는 위젯 확장 코드에서 바로 앱 인텐트를 사용하여 위젯 구성의 스키마를 정의하는 것을 훨씬 더 간단하게 만들었습니다.

00:02:04.000 --> 00:02:17.000
그렇게 하려면, 먼저, 이전에 위젯을 구성하는 데 사용했을 수 있는 IntentConfiguration 대신 AppIntentConfiguration WidgetConfiguration 유형을 사용해야 합니다.

00:02:17.000 --> 00:02:24.000
다음으로, WidgetConfigurationIntent 프로토콜을 준수하는 새로운 유형을 정의하십시오.

00:02:24.000 --> 00:02:33.000
WidgetConfigurationIntent는 앱 인텐트의 하위 프로토콜이며, 위젯 확장 코드에서 직접 준수할 수 있습니다.

00:02:33.000 --> 00:02:41.000
저는 특정 정류장의 다음 예정된 버스의 시간과 경로를 표시하는 버스 일정 앱의 위젯을 작업하고 있습니다.

00:02:41.000 --> 00:02:48.000
이것은 사람들이 전체 앱을 열지 않고도 다음 버스가 언제 도착하는지 빠르게 확인할 수 있게 해준다.

00:02:48.000 --> 00:02:53.000
나는 내 위젯에 대한 구성 의도를 제공하기 위해 앱 인텐트를 사용할 것이다.

00:02:53.000 --> 00:03:18.000
사용자가 다음 버스 위젯을 구성할 수 있도록, 저는 WidgetConfigurationIntent 프로토콜을 준수하고 다음 매개 변수를 포함하는 구조를 정의하는 것으로 시작하겠습니다: 저장된 정류장 목록에서 선택되거나 새로운 정류장, 특정 버스 노선 및 선택한 경로의 이동 방향.

00:03:18.000 --> 00:03:28.000
위젯을 구성하는 데 필요한 매개 변수 정의를 마치면, 각 매개 변수 유형에 대한 동적 옵션을 제공해야 합니다.

00:03:28.000 --> 00:03:35.000
과거에는 별도의 의도 확장을 만드는 데 필요한 매개 변수에 대한 동적 옵션을 제공했습니다.

00:03:35.000 --> 00:03:45.000
앱 인텐트를 사용하면 위젯 확장 내에서 직접 쿼리와 동적 옵션 공급자를 구현하여 더 깨끗하고 효율적인 프로젝트로 이어질 수 있습니다.

00:03:45.000 --> 00:03:52.000
동적 옵션 공급자와 쿼리에 대해 자세히 알아보려면, "Dive into App Intents" 비디오를 확인하는 것이 좋습니다.

00:03:52.000 --> 00:03:57.000
이제, 기존 위젯을 SiriKit에서 App Intents로 마이그레이션하는 것에 대해 이야기해 봅시다.

00:03:57.000 --> 00:04:02.000
기존 위젯 구성을 앱 인텐츠로 마이그레이션하는 것은 쉽습니다.

00:04:02.000 --> 00:04:06.000
사실, 그것은 Xcode에서 한 번의 클릭으로 할 수 있다.

00:04:06.000 --> 00:04:15.000
위젯을 마이그레이션하면 위젯을 앱 인텐트로 변환하기 전에 최신 OS 버전과 이전 버전을 모두 지원할 수 있습니다.

00:04:15.000 --> 00:04:18.000
기존에 구성된 위젯은 계속 작동할 수 있습니다.

00:04:18.000 --> 00:04:25.000
이전 OS 버전을 더 이상 지원할 필요가 없으면, SiriKit 의도 정의 파일을 제거할 수 있습니다.

00:04:25.000 --> 00:04:36.000
마이그레이션하려면, 인텐트 정의 파일에서 SiriKit 위젯 구성 인텐트로 이동하고 앱 인텐트로 변환 버튼을 클릭하세요.

00:04:36.000 --> 00:04:42.000
Xcode는 이전 인텐트 정의와 동등한 앱 인텐트 코드를 생성합니다.

00:04:42.000 --> 00:04:53.000
스키마가 동일하게 유지되도록 해야 합니다. 즉, 모든 앱 인텐트 매개 변수 이름과 유형은 인텐트 정의에 있는 것과 일치해야 합니다.

00:04:53.000 --> 00:04:56.000
앱 의도에 새로운 매개 변수를 자유롭게 추가하세요.

00:04:56.000 --> 00:05:01.000
선택적 매개 변수 또는 기본값이 있는 필수 매개 변수를 추가할 수 있습니다.

00:05:01.000 --> 00:05:11.000
매개 변수가 추가되기 전에 생성된 기존 위젯은 해당 매개 변수에 대한 빈 값을 선택하거나 제공한 경우 기본값을 선택합니다.

00:05:11.000 --> 00:05:22.000
이전 iOS 버전의 사람들을 지원하고 새로운 매개 변수를 사용할 계획이라면, SiriKit Intent 정의 파일을 유지하고 거기에 새로운 매개 변수를 추가해야 합니다.

00:05:22.000 --> 00:05:28.000
고객이 앱을 업데이트할 때마다 위젯이 자동으로 마이그레이션됩니다.

00:05:28.000 --> 00:05:35.000
앱이 그렇게 할 수 있는 기회가 한 번만 있기 때문에 마이그레이션이 원활하게 진행되는지 테스트하는 것이 중요합니다.

00:05:35.000 --> 00:05:41.000
마이그레이션에 대해 자세히 알아보려면, "사용자 지정 의도를 앱 의도로 마이그레이션" 비디오를 시청하는 것이 좋습니다.

00:05:41.000 --> 00:05:45.000
위젯의 상호 작용으로 넘어가세요.

00:05:45.000 --> 00:05:57.000
위젯은 이제 버튼 탭과 토글에 반응하여 사람들이 홈 화면에서 바로 설정을 조정하거나, 미디어를 재생하거나, 앱의 다른 중요한 기능에 액세스할 수 있습니다.

00:05:57.000 --> 00:06:02.000
다음 버스 위젯에서 시간 버튼을 탭할 수 있게 하고 싶습니다.

00:06:02.000 --> 00:06:11.000
사람들이 이 버튼 중 하나를 탭할 때, 나는 내 앱에서 알람을 설정하여 그들이 언제 떠나야 하는지 정확히 알 수 있도록 하고 싶다. 그래서 그들은 버스를 놓치지 않는다!

00:06:11.000 --> 00:06:13.000
내가 그걸 어떻게 할 수 있을까?

00:06:13.000 --> 00:06:21.000
SwiftUI 버튼과 토글은 앱 인텐트를 지원하도록 업데이트되어 위젯에 상호 작용을 쉽게 추가할 수 있습니다.

00:06:21.000 --> 00:06:27.000
이전에 앱 인텐트를 구현했다면, 즉시 익숙해져야 합니다.

00:06:27.000 --> 00:06:32.000
먼저, 나는 앱 인텐트 프로토콜을 준수하는 구조를 정의해야 한다.

00:06:32.000 --> 00:06:43.000
그런 다음, 매개 변수 속성 래퍼로 키 속성에 주석을 달면 작업을 수행하기 위해 관련 정보가 필요하다는 것을 시스템에 알립니다.

00:06:43.000 --> 00:06:48.000
그 후, 나는 실제로 그 작업을 실행할 실행 방법을 구현해야 한다.

00:06:48.000 --> 00:06:56.000
마지막으로, 위젯 보기에서, 나는 단순히 SetAlarm 앱 의도를 버튼과 연관시킨다.

00:06:56.000 --> 00:07:04.000
앱 인텐트와의 SwiftUI 통합은 대화형 위젯뿐만 아니라 일반 SwiftUI 앱에서도 사용할 수 있습니다.

00:07:04.000 --> 00:07:12.000
코드를 앱 인텐트에 통합함으로써, 중복성을 줄이고 앱 전체에서 일관된 동작을 보장할 수 있습니다.

00:07:12.000 --> 00:07:21.000
앱 인텐트는 구성과 대화형 작업의 제공자 역할을 하기 때문에, 단축키에 대한 인텐트 코드를 재사용하는 것은 매우 쉽다.

00:07:21.000 --> 00:07:34.000
예를 들어, ShowNextBus 위젯 구성 의도는 필요할 때 최신 정보를 제공할 수 있는 위젯 구성과 단축키 작업으로 모두 사용할 수 있습니다.

00:07:34.000 --> 00:07:46.000
또한, 위젯에 상호 작용을 추가하는 데 사용한 앱 의도는 사람들이 선호하는 버스 도착 시간에 대한 알람을 설정할 수 있도록 하는 훌륭한 단축키 동작 역할을 합니다.

00:07:46.000 --> 00:07:52.000
위젯 상호 작용에 대해 자세히 알아보려면, "위젯에 생명을 불어넣으세요"를 확인하세요.

00:07:52.000 --> 00:07:59.000
위젯 구성의 기능과 디자인을 향상시킬 수 있는 몇 가지 고급 기술로 넘어갑시다.

00:07:59.000 --> 00:08:04.000
먼저, 동적 옵션과 쿼리의 개선에 대해 이야기해 봅시다.

00:08:04.000 --> 00:08:19.000
동적 옵션은 앱 의도의 매개 변수에 사용 가능한 값을 제공하는 인터페이스이며, DynamicOptionsProvider 또는 EntityQuery 프로토콜 제품군을 준수하여 구현할 수 있습니다.

00:08:19.000 --> 00:08:29.000
경우에 따라, 다른 매개 변수의 값에 기반한 특정 조건이 충족될 때만 사용할 수 있는 옵션을 보여주고 싶을 수도 있습니다.

00:08:29.000 --> 00:08:39.000
예를 들어, 위젯 구성에서 버스 정류장 매개 변수를 기반으로 사용할 수 있는 경로 옵션만 표시하고 싶습니다.

00:08:39.000 --> 00:08:46.000
그렇게 하기 위해, 저는 iOS 17에서 IntentParameterDependency라는 새로운 API를 사용할 수 있습니다.

00:08:46.000 --> 00:08:54.000
DynamicOptionsProvider 또는 쿼리 내에서 인텐트의 매개 변수에 액세스할 수 있는 속성 래퍼입니다.

00:08:54.000 --> 00:09:01.000
이러한 매개 변수를 읽고 이를 사용하여 더 역동적이고 상황에 맞는 옵션을 만들 수 있습니다.

00:09:01.000 --> 00:09:07.000
제 예에서, 저는 사용자가 선택한 버스 정류장으로 필터링된 사용 가능한 버스 노선을 반환합니다.

00:09:07.000 --> 00:09:15.000
IntentParameterDependency는 위젯, 단축키 및 포커스 필터와 같은 모든 환경에서 작동합니다.

00:09:15.000 --> 00:09:22.000
제 예에서, 저는 EntityQuery 프로토콜을 준수하는 BusRouteQuery라는 구조체가 있습니다.

00:09:22.000 --> 00:09:30.000
이 구조체에는 IntentParameterDependency 속성 래퍼로 래핑된 ShowNextBus라는 속성이 있습니다.

00:09:30.000 --> 00:09:39.000
이것은 버스 경로 쿼리가 showNextBus 앱 인텐트, 특히 버스 정류장 매개 변수에 의존한다는 것을 의미합니다.

00:09:39.000 --> 00:09:42.000
제안된 엔티티 방법에 주목하세요.

00:09:42.000 --> 00:09:45.000
제안된 경로 객체의 배열을 반환합니다.

00:09:45.000 --> 00:09:50.000
먼저 showNextBus Intent 속성이 nil이 아닌지 확인합니다.

00:09:50.000 --> 00:09:59.000
그렇다면, 지정된 버스 정류장과 일치하는 경로만 볼 수 있도록 사용 가능한 경로를 필터링합니다.

00:09:59.000 --> 00:10:04.000
IntentParameterDependency는 또한 여러 매개 변수에 의존할 수 있다.

00:10:04.000 --> 00:10:12.000
예를 들어, 내 방향 쿼리에서, 나는 방향 옵션을 제공하기 위해 버스 정류장과 경로 매개 변수 모두에 의존하고 싶다.

00:10:12.000 --> 00:10:18.000
동일한 쿼리 또는 동적 옵션 공급자 내에서 여러 앱 인텐트에 의존할 수도 있습니다.

00:10:18.000 --> 00:10:26.000
내 방향 쿼리는 두 개의 의도에서 매개 변수를 읽습니다: ShowNextBus와 ShowFavoriteRoute.

00:10:26.000 --> 00:10:39.000
IntentParameterDependency 속성 래퍼는 ShowNextBus Intent의 busStop 및 경로 매개 변수에 대한 종속성과 ShowFavoriteRoute Intent의 경로 매개 변수를 지정하는 데 사용됩니다.

00:10:39.000 --> 00:10:50.000
경로 계산 속성은 사용 가능한 것에 따라 showNextBus 또는 showFavoriteRoute의 값을 반환합니다.

00:10:50.000 --> 00:10:54.000
위젯 구성에는 종종 배열 매개 변수가 있다.

00:10:54.000 --> 00:11:00.000
예를 들어, 내가 가장 좋아하는 경로 위젯은 사람이 가장 좋아하는 경로의 버스 일정을 표시할 수 있다.

00:11:00.000 --> 00:11:06.000
그러나, 제한된 화면 공간으로 인해, 사람은 최대 세 개의 경로만 선택할 수 있어야 한다.

00:11:06.000 --> 00:11:09.000
그래서 내가 그걸 어떻게 선언할 수 있을까?

00:11:09.000 --> 00:11:15.000
iOS 17의 새로운 기능, 이제 배열 매개 변수를 정의할 때 크기를 선언할 수 있습니다.

00:11:15.000 --> 00:11:25.000
여기서의 크기는 또한 위젯 패밀리에서 배열 크기로의 매핑을 허용할 수 있습니다. 왜냐하면 때때로 더 큰 위젯은 더 작은 위젯보다 더 많은 항목을 수용할 수 있기 때문입니다.

00:11:25.000 --> 00:11:35.000
위젯 구성 앱 의도와 매개 변수를 정의하면, 이 매개 변수 중 어느 것이 사용자에게 언제 표시되는지 정의하고 싶을 수도 있습니다.

00:11:35.000 --> 00:11:40.000
ParameterSummary는 앱 의도의 매개 변수의 시각적 표현을 정의합니다.

00:11:40.000 --> 00:11:47.000
단축키 편집기, 포커스 필터, 그리고 이제 위젯 구성에서 앱 의도의 모양을 지원합니다.

00:11:47.000 --> 00:11:54.000
매개 변수 요약을 사용하여 어떤 매개 변수가 어떤 조건에서 표시되는지 정의할 수 있습니다.

00:11:54.000 --> 00:12:03.000
위젯의 경우, UI는 먼저 요약 문장의 매개 변수를 표시한 다음 클로저에 나열된 추가 매개 변수를 표시합니다.

00:12:03.000 --> 00:12:13.000
여기서, 문장에는 경로 매개 변수가 포함되어 있으며, 클로저에는 includeWeatherInfo가 있으므로 구성 UI에서 해당 순서로 표시됩니다.

00:12:13.000 --> 00:12:22.000
iOS 17의 새로운 기능, 이제 위젯 패밀리와 함께 When 문을 사용할 수 있으며, 위젯 크기에 따라 위젯 구성을 변경할 수 있습니다.

00:12:22.000 --> 00:12:32.000
예를 들어, 큰 위젯에서만 날씨 정보를 보여주는 토글을 표시하고 싶은데, 다른 크기에는 이 기능이 없습니다.

00:12:32.000 --> 00:12:39.000
그래서 저는 큰 위젯에 대해서만 매개 변수 요약에 includeWeatherInfo 매개 변수를 추가합니다.

00:12:39.000 --> 00:12:45.000
그렇지 않으면, 작은 위젯의 경우, 나는 그것을 추가하지 않을 것이므로, 매개 변수는 숨겨져 있다.

00:12:45.000 --> 00:12:52.000
이제 앱 인텐트를 사용하여 위젯에 대한 구성을 구현했으므로, 사람이 탭하면 어떻게 되는지 어떻게 결정하나요?

00:12:52.000 --> 00:12:57.000
그 사람은 내 위젯의 아무 곳이나 탭할 때마다 내 앱으로 이동합니다.

00:12:57.000 --> 00:13:06.000
위젯 구성에서 선택한 특정 경로에 대한 정보를 보여주는 화면으로 직접 데려가고 싶습니다.

00:13:06.000 --> 00:13:17.000
사람이 위젯을 탭하고 앱이 실행되면, 사용자 활동에서 widgetConfigurationIntent 메소드를 호출하여 관련 구성 의도를 얻을 수 있습니다.

00:13:17.000 --> 00:13:22.000
앱 의도가 있으면, 그에 따라 앱의 UI를 업데이트하는 데 사용할 수 있습니다.

00:13:22.000 --> 00:13:32.000
여기서, 저는 구성 의도에서 콘텐츠를 추출하여 해당 정류장과 경로에 대한 특정 버스 정류장 보기로 앱을 탐색하는 데 사용합니다.

00:13:32.000 --> 00:13:38.000
위젯을 만들 때, 사람들이 스마트 스택에서 적시에 볼 수 있도록 하고 싶을 것입니다.

00:13:38.000 --> 00:13:46.000
그렇게 하려면, iOS와 watchOS의 위젯 제안에 새로운 RelevantContext API를 사용할 수 있습니다.

00:13:46.000 --> 00:14:03.000
이전 INInteraction, INDailyRoutine 및 INRelevantShortcut API에서 영감을 받아, 우리는 더 스위프트 친화적이고 앱 인텐트와 원활하게 작동하도록 새로운 RelevantIntentManager 및 RelevantIntent를 설계했습니다.

00:14:03.000 --> 00:14:08.000
게임 중에 위젯을 표시하고 싶은 스포츠 앱을 상상해 보세요.

00:14:08.000 --> 00:14:14.000
새로운 RelevantContext API를 사용하면 이 의도와 관련 날짜 범위를 지정할 수 있습니다.

00:14:14.000 --> 00:14:27.000
이 관련 날짜 정보를 제공함으로써, 스포츠 앱 위젯은 스마트 스택 내에서 자동으로 제안되어 사람들이 가장 중요할 때 게임 정보에 쉽게 접근할 수 있도록 합니다.

00:14:27.000 --> 00:14:32.000
관련성 API는 또한 시계 합병증을 표면화하는 데 좋습니다.

00:14:32.000 --> 00:14:40.000
watchOS 측면의 관련성에 대해 자세히 알아보려면, "Apple Watch에서 스마트 스택을 위한 위젯을 빌드"를 확인하세요.

00:14:40.000 --> 00:14:47.000
이제 위젯을 다루었으니, iOS 17과 Xcode 15에서 만든 개발자 경험 개선에 대해 자세히 알아봅시다.

00:14:47.000 --> 00:14:50.000
우리는 프레임워크 지원으로 시작할 것이다.

00:14:50.000 --> 00:15:02.000
앱이 메인 앱과 앱 인텐트 확장 모두에서 앱 인텐트를 수행할 수 있는 기능이 필요한 경우, 현재 앱 인텐트 코드를 두 타겟으로 컴파일해야 합니다.

00:15:02.000 --> 00:15:12.000
불행히도, 이 접근 방식은 코드 중복으로 이어지며, 이는 유지 관리 문제를 야기하고 오류나 불일치의 가능성을 증가시킬 수 있다.

00:15:12.000 --> 00:15:20.000
이것은 또한 바이너리 크기를 부풀리게 하며, 이는 앱의 성능과 사람들의 다운로드 시간에 부정적인 영향을 미칠 수 있다.

00:15:20.000 --> 00:15:29.000
iOS 17과 Xcode 15에서 프레임워크는 이제 앱 의도를 직접 노출할 수 있으므로 더 이상 코드를 두 번 컴파일할 필요가 없습니다.

00:15:29.000 --> 00:15:35.000
이제 AppIntentsPackage API를 사용하여 앱에서 종속성을 재귀적으로 가져올 수 있습니다.

00:15:35.000 --> 00:15:45.000
AppIntentsPackage 프로토콜에 따라, 앱과 프레임워크 모두 다른 프레임워크에서 메타데이터를 다시 내보낼 수 있습니다.

00:15:45.000 --> 00:15:50.000
나는 버스 스케줄 앱의 구현을 단순화하기 위해 프레임워크 지원을 사용할 것이다.

00:15:50.000 --> 00:15:58.000
버스 일정을 보기 위한 다양한 앱 인텐트를 제공하는 BusScheduleIntents라는 프레임워크가 있습니다.

00:15:58.000 --> 00:16:03.000
그것은 어떤 의존성 없이 재수출할 수 있게 해준다.

00:16:03.000 --> 00:16:11.000
버스 일정 앱에 대한 사용자 지정 인터페이스 요소를 제공하는 BusScheduleUI라는 또 다른 프레임워크가 있습니다.

00:16:11.000 --> 00:16:17.000
이 프레임워크는 BusScheduleIntents 프레임워크에 의존하고 재수출한다.

00:16:17.000 --> 00:16:23.000
마지막으로, 버스 일정 앱에서 BusScheduleUI 프레임워크를 가져옵니다.

00:16:23.000 --> 00:16:29.000
AppIntentsPackage는 프로토콜이기 때문에, SwiftUI 앱 구조체가 이를 준수하도록 할 수 있습니다.

00:16:29.000 --> 00:16:35.000
버스 스케줄 앱은 BusScheduleUI 프레임워크에 대한 직접적인 의존성을 언급하기만 하면 됩니다.

00:16:35.000 --> 00:16:44.000
이제 ShowSchedule 앱 인텐트를 수행하여 내가 가장 좋아하는 버스 경로를 표시하는 버스 일정 앱 내에서 SwiftUI 버튼을 만들 수 있습니다.

00:16:44.000 --> 00:16:58.000
동일한 앱 인텐트인 ShowSchedule은 단축키 사용자도 사용할 수 있습니다. 즉, 앱을 열지 않고도 좋아하는 버스 노선 일정에 빠르게 액세스할 수 있는 사용자 지정 단축키를 만들 수 있습니다.

00:16:58.000 --> 00:17:05.000
앱 인텐트를 프레임워크로 옮기면 코드베이스를 더 간단하고 간소화하는 데 도움이 됩니다.

00:17:05.000 --> 00:17:17.000
새로운 프레임워크 지원은 앱 인텐트가 있는 위젯을 구축할 때 특히 좋습니다. 앱과 위젯 확장 모두에서 동일한 인텐트에 액세스해야 할 수도 있기 때문입니다.

00:17:17.000 --> 00:17:27.000
앱 인텐트 코드를 더 모듈식으로 유지하기 위한 한 가지 팁: 이제 AppShortcutsProvider를 만들고 앱 인텐트 확장 프로그램에서 앱 단축키를 정의할 수 있습니다.

00:17:27.000 --> 00:17:33.000
이전에는 메인 앱 번들에서 앱 단축키를 완전히 정의해야 했습니다.

00:17:33.000 --> 00:17:38.000
이것은 앱 단축키가 실행될 때 앱이 항상 백그라운드에서 실행된다는 것을 의미합니다.

00:17:38.000 --> 00:17:43.000
이제 앱 인텐트 확장 프로그램에서 앱 단축키를 정의할 수 있습니다.

00:17:43.000 --> 00:17:55.000
앱 인텐트 확장을 전체 메인 앱보다 빠르게 최적화하고 UI, 분석 또는 기타 중요하지 않은 코드를 가져오지 않도록 할 수 있기 때문에 성능에 좋습니다.

00:17:55.000 --> 00:18:01.000
이러한 모든 기능은 Xcode 15에서 만든 정적 메타데이터 추출 향상에 의존합니다.

00:18:01.000 --> 00:18:08.000
그래서 코드가 빌드되는 동안 앱 인텐트 콘텐츠가 어떻게 정적으로 추출되는지에 대해 이야기해 봅시다.

00:18:08.000 --> 00:18:19.000
스위프트 컴파일러는 코드에서 사용할 수 있는 유형에 대한 정보와 앱 인텐트 구현의 유형 수준 및 일부 값 수준 정보를 출력합니다.

00:18:19.000 --> 00:18:33.000
그런 다음 다른 도구는 이 정보를 구문 분석하여 앱 의도, 매개 변수, 엔티티, 쿼리 등을 설명하는 파일이 포함된 빌드된 제품에 Metadata.appIntents 디렉토리를 생성합니다.

00:18:33.000 --> 00:18:38.000
Xcode 15에서 정적 추출 프로세스가 크게 개선되었다.

00:18:38.000 --> 00:18:44.000
그것은 이제 더 빠르고, 더 신뢰할 수 있으며, 그 어느 때보다 더 많은 경우에 작동한다.

00:18:44.000 --> 00:19:02.000
Xcode 15로 앱을 빌드할 때, Xcode가 기대하는 것을 정적으로 추출할 수 없다면, 이제 Xcode 편집기에서 줄 번호와 함께 오류 메시지를 직접 볼 수 있으므로 어디로 가서 문제를 해결해야 할지 알 수 있습니다.

00:19:02.000 --> 00:19:11.000
단축키 통합에 대해 이야기하기 전에, 올해 앱 인텐트에 추가한 두 가지 훌륭한 기능이 더 있습니다.

00:19:11.000 --> 00:19:19.000
먼저, 인텐트가 이전에 백그라운드에서 실행되었더라도 앱에서 인텐트를 계속 실행할 수 있는 기능입니다.

00:19:19.000 --> 00:19:23.000
우리는 이것을 ForegroundContinuableIntent 프로토콜이라고 부른다.

00:19:23.000 --> 00:19:37.000
예를 들어, 다음 버스를 가져오는 내 앱 의도가 잘못된 매개 변수나 연결 문제로 인해 버스 일정을 검색하지 못하면, 그 사람에게 문제를 해결하기 위해 앱에서 계속하도록 요청할 수 있습니다.

00:19:37.000 --> 00:19:43.000
그렇게 하기 위해, 먼저, 나는 내 앱 의도를 ForegroundContinuableIntent 프로토콜에 적용한다.

00:19:43.000 --> 00:19:54.000
ForegroundContinuableIntent 프로토콜은 처음에 백그라운드에서 작업을 시작하지만 전경에서 계속을 요청해야 할 수도 있는 인텐트를 위해 설계되었습니다.

00:19:54.000 --> 00:20:00.000
다음으로, 나는 오류를 반환하는 needsToContinueInForegroundError 메소드를 호출한다.

00:20:00.000 --> 00:20:08.000
내가 그 오류를 던지면, 시스템은 앱 인텐트 수행을 멈추고 사용자에게 전경에서 실행을 계속하도록 요청합니다.

00:20:08.000 --> 00:20:18.000
또한 포그라운드에 들어간 후 앱의 상태를 업데이트하기 위해 메인 스레드에서 실행될 선택적 연속 클로저를 제공할 수 있습니다.

00:20:18.000 --> 00:20:23.000
여기서, 저는 이 클로저를 사용하여 앱을 오류 화면으로 이동하고 있습니다.

00:20:23.000 --> 00:20:33.000
이전 예제와 같이 인텐트 실행을 중지하고 계속하기 위한 작업이 필요할 때 needsToContinueInForegroundError를 사용하세요.

00:20:33.000 --> 00:20:41.000
앱 인텐트를 완전히 중지하는 대신 계속 실행하려면 사용할 수 있는 또 다른 API가 있습니다.

00:20:41.000 --> 00:20:45.000
이 경우, requestToContinueInForeground 메소드를 호출하세요.

00:20:45.000 --> 00:20:56.000
버스 앱이 버스 노선에 유지 보수 문제가 있다는 것을 감지할 때 이것을 사용할 수 있으며, 다른 경로를 선택하기 위해 앱에 사용자 지정 UI를 제시하고 싶습니다.

00:20:56.000 --> 00:21:05.000
그 사람이 경로를 선택하면, 앱에서 업데이트된 경로를 반환하고 앱 인텐트 실행을 계속할 수 있습니다.

00:21:05.000 --> 00:21:12.000
이번에는, 오류를 던지는 대신, 나는 단순히 try and await로 메소드를 호출하고 있다.

00:21:12.000 --> 00:21:18.000
전달된 클로저는 내 성능 내에서 되돌릴 수 있는 값을 반환할 수 있다.

00:21:18.000 --> 00:21:24.000
그것은 내가 사용자로부터 입력을 받은 후 앱 인텐트를 계속 실행할 수 있게 해준다.

00:21:24.000 --> 00:21:32.000
여기서, 저는 사용자가 선택한 대체 경로를 타고 그 경로의 다음 버스를 보여주는 스니펫을 반환합니다.

00:21:32.000 --> 00:21:39.000
요약하자면, 앱 인텐트의 실행을 완전히 중지하고 싶을 때 던지기 방법을 사용하세요.

00:21:39.000 --> 00:21:50.000
그렇지 않으면, 그 사람에게서 결과를 얻고 그것을 사용하여 앱 인텐트의 수행을 완료하려면, requestToContinueInForeground를 사용하고 결과를 기다리세요.

00:21:50.000 --> 00:21:54.000
올해, 우리는 또한 앱 인텐트에 Apple Pay에 대한 지원을 추가했습니다.

00:21:54.000 --> 00:22:00.000
이제 수행 방법 내에서 직접 Apple Pay 거래를 시작할 수 있습니다.

00:22:00.000 --> 00:22:03.000
공연에서 Apple Pay를 사용하는 것은 간단합니다.

00:22:03.000 --> 00:22:10.000
PKPaymentRequest 인스턴스를 만들고 필요한 정보로 구성할 것입니다.

00:22:10.000 --> 00:22:19.000
다음으로, 저는 PKPaymentAuthorizationController를 사용하여 Apple Pay 결제 시트를 제시하고 승인을 처리합니다.

00:22:19.000 --> 00:22:23.000
가드 문은 컨트롤러가 성공적으로 제시되었는지 확인합니다.

00:22:23.000 --> 00:22:27.000
그렇지 않다면, "지불을 처리할 수 없습니다"라는 대화상자를 반환합니다.

00:22:27.000 --> 00:22:31.000
그렇지 않으면, 결제가 성공적으로 처리됩니다.

00:22:31.000 --> 00:22:37.000
마지막으로, 앱 인텐트와 단축키 앱 간의 통합에 대한 몇 가지 업데이트를 살펴봅시다.

00:22:37.000 --> 00:22:42.000
앱 인텐트가 통합된 시스템의 모든 다른 장소부터 시작합시다.

00:22:42.000 --> 00:22:53.000
앱 인텐트는 바로 가기 작업을 구축하는 현대적인 방법이며, 앱 바로 가기를 사용하면 Siri 및 바로 가기 앱으로 앱의 기능을 더 쉽게 발견하고 사용할 수 있습니다.

00:22:53.000 --> 00:22:59.000
포커스 필터와 Apple Watch Ultra의 액션 버튼과도 통합되어 있습니다.

00:22:59.000 --> 00:23:11.000
iOS 17에서 앱 인텐트는 인터랙티브 라이브 활동, 위젯 구성 및 상호 작용, SwiftUI와의 통합 덕분에 훨씬 더 널리 접근할 수 있게 되었다.

00:23:11.000 --> 00:23:17.000
앱 단축키도 성장하여 스포트라이트 최고 히트와 자동화에 대한 지원을 포함했다.

00:23:17.000 --> 00:23:23.000
이러한 모든 통합은 동일한 앱 인텐트 코드를 다양한 방법으로 재사용할 수 있다는 것을 의미합니다.

00:23:23.000 --> 00:23:34.000
앱 인텐트는 이제 주요 시스템 구성 요소에 깊이 통합되어 있기 때문에, 당신이 만든 앱 인텐트가 좋은 시민이 되도록 하는 것이 매우 중요합니다.

00:23:34.000 --> 00:23:42.000
좋은 매개 변수 요약을 제공하는 것은 앱 의도가 시스템 전반에 걸쳐 표면화될 때 멋지게 보이도록 하는 데 중요합니다.

00:23:42.000 --> 00:23:50.000
폴드 아래에 있는 선택적 매개 변수와 함께 문장처럼 읽을 수 있도록 매개 변수 요약을 작성하세요.

00:23:50.000 --> 00:23:57.000
그런 다음 시스템은 상황에 따라 매개 변수 요약에 대한 최적의 시각적 표현을 결정할 것입니다.

00:23:57.000 --> 00:24:11.000
앱 인텐트가 모든 곳에서 잘 작동하는 것이 바람직하지만, 앱이나 대화형 위젯에서 사용할 앱 인텐트를 만들어야 하고 시스템의 다른 부분에서 숨기고 싶은 경우가 있을 수 있습니다.

00:24:11.000 --> 00:24:19.000
예를 들어, 앱 인텐트가 유용한 단축키 동작을 만들지 않는 앱의 로컬 함수를 호출할 때.

00:24:19.000 --> 00:24:24.000
이 경우, 앱 인텐트의 isDiscoverable 속성을 false로 설정할 수 있습니다.

00:24:24.000 --> 00:24:31.000
서버에서 최신 데이터를 검색할 다음 버스 위젯에 새로 고침 버튼을 추가할 것입니다.

00:24:31.000 --> 00:24:35.000
그것은 내 위젯에서 목적을 제공하지만, 유용한 단축키 동작을 만들지는 않는다.

00:24:35.000 --> 00:24:43.000
이 앱 인텐트가 내 대화형 위젯에서만 사용되기를 원하기 때문에, 나는 그것을 위해 isDiscoverable을 false로 설정할 것이다.

00:24:43.000 --> 00:24:49.000
찾을 수 없는 것으로 표시된 앱 의도도 앱 단축키에 참여할 수 없습니다.

00:24:49.000 --> 00:24:54.000
내 앱의 의도는 꽤 빨리 작동하지만, 모든 의도가 작동하는 것은 아니다.

00:24:54.000 --> 00:25:00.000
올해, 우리는 당신이 장기 의도에 대한 진전을 제공할 수 있는 새로운 방법을 도입했습니다.

00:25:00.000 --> 00:25:06.000
진행 상황을 보고하려면, 앱 인텐트가 ProgressReportingIntent 프로토콜을 준수하도록 하세요.

00:25:06.000 --> 00:25:10.000
Perform() 메서드 내에서 제공된 진행 객체에 액세스할 수 있습니다.

00:25:10.000 --> 00:25:19.000
의도 실행이 진행됨에 따라 totalUnitCount를 설정하고 completedUnitCount를 증가시켜 진행 상황을 업데이트하십시오.

00:25:19.000 --> 00:25:24.000
단축키 앱은 이제 앱 인텐트 실행 진행 상황을 자동으로 표시합니다.

00:25:24.000 --> 00:25:28.000
진행 상황 보고를 구현하는 것은 장기간의 의도에 특히 중요하다.

00:25:28.000 --> 00:25:37.000
사람들이 그 피드백을 받는 것은 정말 가치가 있기 때문에, 그들은 의도의 수행이 앞으로 나아가고 있으며, 언제 완료될 수 있는지 알고 있다.

00:25:37.000 --> 00:25:42.000
올해, 우리는 또한 당신의 앱이 찾기 동작과 통합될 수 있는 방법을 개선했습니다.

00:25:42.000 --> 00:25:50.000
단축키 사용자는 메모 찾기와 같은 작업을 통해 특정 기준에 따라 앱 내에서 콘텐츠를 찾을 수 있는 것을 좋아합니다.

00:25:50.000 --> 00:25:58.000
이러한 작업의 출력은 이메일을 보내는 것과 같은 다른 단축키 작업으로 전송되어 많은 강력한 워크플로우를 가능하게 할 수 있습니다.

00:25:58.000 --> 00:26:10.000
iOS 16에서는 EntityPropertyQuery를 구현하여 사용자가 지정할 수 있는 기준을 선언하여 앱에 대한 찾기 작업을 자동으로 얻을 수 있습니다.

00:26:10.000 --> 00:26:17.000
iOS 17부터, 이제 대신 EnumerableEntityQuery 프로토콜을 사용할 수도 있습니다.

00:26:17.000 --> 00:26:21.000
그건 정말 간단하고 입양하기 쉬워.

00:26:21.000 --> 00:26:30.000
EnumerableEntityQuery를 구현하는 것은 allEntities() 메서드에서 엔티티에 대한 가능한 모든 값을 반환하는 것만큼 간단합니다.

00:26:30.000 --> 00:26:36.000
바로 가기와 앱 의도는 거기에서 그것을 가져가서 자동으로 찾기 동작을 생성합니다.

00:26:36.000 --> 00:26:50.000
EnumerableEntityQuery와 EntityPropertyQuery의 차이점은 EntityPropertyQuery를 사용하면 개발자, 기준을 보내고 사용자를 대신하여 검색을 실행한다는 것입니다.

00:26:50.000 --> 00:26:54.000
그것은 당신이 종종 제한된 결과 세트를 반환할 것이라는 것을 의미합니다.

00:26:54.000 --> 00:27:02.000
EnumerableEntityQuery를 사용하면 프레임워크에 가능한 모든 엔티티를 제공하고 단축키가 필터링을 수행합니다.

00:27:02.000 --> 00:27:11.000
모든 엔티티를 반환하기 때문에, EnumerableEntityQuery는 사용하기 정말 간단하지만, 소수의 엔티티에도 최적화되어 있습니다.

00:27:11.000 --> 00:27:20.000
사파리의 탭 그룹과 같은 경우에 잘 작동하지만, 노트 앱의 전형적인 많은 수의 엔티티에는 적합하지 않습니다.

00:27:20.000 --> 00:27:24.000
그것은 또한 많은 메모리를 차지하는 매우 큰 단체에는 적합하지 않다.

00:27:24.000 --> 00:27:34.000
이 경우, EntityPropertyQuery를 사용하면 가능한 모든 엔티티를 한 번에 반환하는 대신 검색을 실행할 수 있습니다.

00:27:34.000 --> 00:27:38.000
마지막으로, IntentDescription에 대한 몇 가지 업데이트에 대해 말씀드리고 싶습니다.

00:27:38.000 --> 00:27:47.000
이것은 사람들이 세부 정보 버튼을 탭하여 작업에 대한 더 많은 정보를 얻을 때 볼 수 있는 단축키 UI를 작성하는 데 사용하는 유형입니다.

00:27:47.000 --> 00:27:52.000
IntentDescription에는 설명 텍스트, 카테고리 이름 및 검색 키워드가 포함됩니다.

00:27:52.000 --> 00:28:04.000
iOS 17에서 의도 설명 유형은 resultValueName이라는 새로운 속성으로 업데이트되었으므로 작업 출력에 대해 더 설명적인 이름을 제공할 수 있습니다.

00:28:04.000 --> 00:28:13.000
여기서, "알림 추가"는 생성되고 반환된 알림에 대한 "새 알림"의 resultValueName을 제공합니다.

00:28:13.000 --> 00:28:22.000
여기서 "알리 알림 추가" 작업이 결과 표시 작업에 연결되면, 결과 표시 작업의 매개 변수는 "새 알림"이라는 이름을 보여줍니다.

00:28:22.000 --> 00:28:27.000
resultValueName을 제공하려면, IntentDescription에서 새 이니셜라이저를 사용하세요.

00:28:27.000 --> 00:28:40.000
iOS 17부터 EntityPropertyQuery 또는 EnumerableEntityQuery 프로토콜을 사용하여 생성된 찾기 작업에 대한 의도 설명을 포함할 수도 있습니다.

00:28:40.000 --> 00:28:46.000
이렇게 하려면, 쿼리 유형 내에서 findIntentDescription 속성을 채택하기만 하면 됩니다.

00:28:46.000 --> 00:28:57.000
categoryName으로 작업을 분류하면 앱에서 지원하는 작업 목록에서 원하는 범주에 생성된 찾기 작업을 표시할 수 있습니다.

00:28:57.000 --> 00:29:05.000
요약하자면, 앱 인텐트는 앱의 기능을 시스템과 사용자에게 노출할 수 있는 좋은 방법입니다.

00:29:05.000 --> 00:29:16.000
사람들이 즉시 사용할 수 있도록 앱 의도를 앱 단축키로 바꾸는 방법에 대해 더 자세히 알아보려면, "앱 단축키로 앱 스포트라이트" 세션을 확인하는 것이 좋습니다.

00:29:16.000 --> 00:29:28.000
올해 앱 인텐트를 사용하면 구성 가능한 대화형 위젯과 라이브 활동을 구축할 수 있으며, 단축키 앱에 더 깊이 통합하여 더욱 원활한 개발자 경험을 제공할 수 있습니다.

00:29:28.000 --> 00:29:34.000
당신의 앱이 어떻게 새로운 앱 인텐트 기술을 활용하여 놀라움과 기쁨을 줄 수 있는지 보게 되어 정말 기쁩니다.

00:29:34.000 --> 00:29:36.000
나와 함께 해줘서 고마워.

00:29:36.000 --> 23:59:59.000
.

