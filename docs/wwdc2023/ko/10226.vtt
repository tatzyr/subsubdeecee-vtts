WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:12.000
네이선: 안녕하세요 여러분. 내 이름은 네이선이야.

00:00:12.000 --> 00:00:15.000
그리고 저는 Xcode 디버거 UI 팀의 엔지니어입니다.

00:00:15.000 --> 00:00:21.000
오늘, Xcode 15에 출시될 새로운 디버그 콘솔을 소개하게 되어 기쁩니다.

00:00:21.000 --> 00:00:25.000
이 세션에서, 디버그 콘솔을 빠르게 안내해 드리겠습니다.

00:00:25.000 --> 00:00:32.000
다음으로, 내 응용 프로그램에서 실제 버그를 진단함으로써 디버그 콘솔이 얼마나 유용할 수 있는지 보여줄 것이다.

00:00:32.000 --> 00:00:36.000
그럼, LLDB에 오는 몇 가지 개선 사항을 소개해 드리겠습니다.

00:00:36.000 --> 00:00:45.000
그리고 마지막으로, 진단 경험을 개선하기 위해 Apple의 통합 로깅 API를 활용하는 방법에 대한 팁을 공유하겠습니다.

00:00:45.000 --> 00:00:49.000
디버그 콘솔의 새로운 기능을 살펴보고 살펴봅시다.

00:00:49.000 --> 00:00:51.000
내 장치에서, 나는 Backyard Birds 앱을 출시했다.

00:00:51.000 --> 00:00:57.000
이 앱은 사용자가 뒷마당을 관리하고 가상 새를 돌볼 수 있게 해준다.

00:00:57.000 --> 00:01:02.000
애플리케이션을 실행한 후, 디버그 콘솔은 많은 로그로 채워졌다.

00:01:02.000 --> 00:01:08.000
즉시, 나는 콘솔이 더 이상 내가 익숙한 메타데이터로 각 로그에 접두사를 붙이지 않는다는 것을 알아차렸다.

00:01:08.000 --> 00:01:13.000
대신, 관심은 개발자가 내가 보기 위해 의도한 기본 메시지에 초점을 맞추고 있다.

00:01:13.000 --> 00:01:26.000
물론, 저는 여전히 이러한 로그와 관련된 추가 정보를 보고 싶을 수도 있으므로, 디버그 콘솔의 왼쪽 하단에 있는 메타데이터 옵션 버튼을 선택하고 현재 필요에 가장 적합한 유형을 선택하여 이를 볼 수 있는 기능을 제공합니다.

00:01:26.000 --> 00:01:33.000
이 경우 나는 유형, 라이브러리, 하위 시스템 및 카테고리를 선택할 것이다.

00:01:33.000 --> 00:01:42.000
이것이 활성화되면, 메타데이터는 콘솔의 각 로그 아래에 배치되며 의도한 출력에서 벗어나지 않도록 더 작고 더 미묘하게 만들어집니다.

00:01:42.000 --> 00:01:45.000
나는 또한 노란색이나 빨간색 배경을 가진 통나무를 발견할 수도 있다.

00:01:45.000 --> 00:01:52.000
이것은 이러한 로그가 더 중요하며 각각 오류와 결함을 나타낸다는 것을 나타낸다.

00:01:52.000 --> 00:02:03.000
모든 로그의 메타데이터를 동시에 보고 싶지 않다면, 콘솔을 사용하면 문제의 로그를 선택한 다음 공백을 눌러 빠르게 살펴봐 단일 로그의 메타데이터를 검사할 수 있습니다.

00:02:03.000 --> 00:02:07.000
이것으로, 사용 가능한 모든 메타데이터를 제공하는 팝업 창이 나타납니다.

00:02:07.000 --> 00:02:14.000
여기에는 원래 로그를 방출한 함수의 이름이 표시되는 호출 사이트와 같은 정보도 포함됩니다.

00:02:14.000 --> 00:02:21.000
이 추가 메타데이터를 보는 것은 훌륭하지만, 새로운 디버그 콘솔이 실제로 빛나는 곳은 필터링 기능에 있습니다.

00:02:21.000 --> 00:02:28.000
콘솔이 내가 신경 쓰지 않는 로그로 채우는 것은 쉽지만, Xcode 15를 사용하면 그 어느 때보다 쉽게 필터링할 수 있습니다.

00:02:28.000 --> 00:02:35.000
이제 콘솔은 복잡하고 토큰화된 필터링을 수행하여 내 필요와 가장 관련이 있는 로그를 쉽게 찾을 수 있다.

00:02:35.000 --> 00:02:40.000
콘솔은 또한 이러한 필터를 만드는 다양한 방법을 제공한다.

00:02:40.000 --> 00:02:46.000
물론, 필터는 이와 같이 필터 바에 직접 입력할 수 있습니다.

00:02:46.000 --> 00:02:55.000
그렇게 하는 동안, 자동 완성 팝오버가 나타나서 내가 입력하려는 필터를 만드는 데 도움을 줄 것이다.

00:02:55.000 --> 00:03:05.000
또한, 필터 메뉴는 특정 유형의 로그에 대한 필터에 대한 빠른 액세스를 제공하여 보고 싶은 유형을 선택할 수 있습니다.

00:03:05.000 --> 00:03:20.000
그리고 마지막으로, 내가 다소 관심이 있는 로그를 두 번째로 클릭할 때, 콘솔은 이와 같이 내 보기에서 특정 로그 세트에 빠르게 초점을 맞추거나 제외하기 위해 유사한 로그를 숨기고 표시하는 옵션을 제공합니다.

00:03:20.000 --> 00:03:29.000
이러한 모든 필터링 방법을 사용하면 내가 가진 모든 출력을 빠르고 효율적으로 잘라낼 수 있으며, 현재 디버깅 요구와 가장 관련이 있는 로그를 찾을 수 있습니다.

00:03:29.000 --> 00:03:35.000
이제, 새로운 디버그 콘솔을 사용하여 내 애플리케이션의 실제 문제를 찾고 해결해 봅시다.

00:03:35.000 --> 00:03:42.000
일부 사용자가 프로필을 업데이트한 후 콘텐츠가 저장되지 않은 것 같다는 보고를 받았습니다.

00:03:42.000 --> 00:03:51.000
좋은 로깅 관행과 새로운 디버그 콘솔의 약간의 도움을 활용하여 이 버그의 원인을 빠르고 쉽게 식별할 수 있는 방법을 알아봅시다.

00:03:51.000 --> 00:03:56.000
먼저, 탭 바에서 계정을 선택하여 문제를 재현하려고 시도하겠습니다.

00:03:56.000 --> 00:04:02.000
이제 내 계정을 편집하기 위해 연필을 선택할 것이다.

00:04:02.000 --> 00:04:08.000
마지막으로, 나는 내 표시 이름을 바꾸려고 노력할 것이다.

00:04:08.000 --> 00:04:16.000
그 후, 효과가 있었던 것 같지만, 페이지를 종료하고 내 계정을 검토하면 변경 사항이 손실되는 것 같습니다.

00:04:16.000 --> 00:04:25.000
이제, 잘못되었을 수 있는 몇 가지 사항이 떠오르지만, 새로운 디버그 콘솔이 이 문제의 근본 원인을 찾기 위해 이 범위를 좁히는 데 어떻게 도움이 될 수 있는지 살펴봅시다.

00:04:25.000 --> 00:04:29.000
이 단계를 수행하는 동안, 디버그 콘솔에서 많은 양의 출력이 생성되었다.

00:04:29.000 --> 00:04:36.000
고맙게도, 새로운 콘솔을 사용하면, 내가 가장 관심 있는 것을 찾기 위해 필터를 설정할 수 있기 때문에 너무 많은 로그를 찾는 것이 항상 좋습니다.

00:04:36.000 --> 00:04:39.000
이 경우, 저는 계정 관리에만 전념하는 몇 가지 카테고리가 있습니다.

00:04:39.000 --> 00:04:49.000
이것들에 집중하기 위해, 필터 필드에 입력하고 팝업에서 카테고리 필터를 선택하여 "계정"을 포함하는 프로젝트의 모든 카테고리를 필터링할 것입니다.

00:04:49.000 --> 00:04:54.000
이것은 이제 내 코드의 계정 관련 부분에서 모든 로깅을 남깁니다.

00:04:54.000 --> 00:04:58.000
이 필터 세트로, 출력은 훨씬 더 관리하기 쉬워진다.

00:04:58.000 --> 00:05:03.000
이 로그 중 일부는 내가 "displayName" 속성을 설정하도록 요청했다는 것을 나타내는 것 같다.

00:05:03.000 --> 00:05:07.000
왜 내 앱이 예상대로 작동하지 않았는지 더 자세히 조사해 봅시다.

00:05:07.000 --> 00:05:18.000
이제, 이 코드가 어디에 있는지 정확히 기억할 수 없기 때문에, 로그 위에 마우스를 올려놓고 오른쪽 하단 모서리에서 소스 위치를 선택하는 데 더 관심이 있습니다...

00:05:18.000 --> 00:05:24.000
Xcode는 로그의 소스로 이동할 것이며, 이 경우 표시 이름을 설정하도록 요청했습니다.

00:05:24.000 --> 00:05:31.000
소스 코드를 검토한 후, 나는 실제로 이 작업을 수행하기 위해 현재 계정의 setDisplayName 함수를 호출하는 것 같다.

00:05:31.000 --> 00:05:38.000
이 문제를 더 깊이 조사하기 위해 계정 정보를 업데이트하는 기능으로 넘어갑시다.

00:05:38.000 --> 00:05:47.000
이 코드를 더 검토한 후, 나는 이러한 변경 사항을 중앙 계정 데이터베이스로 보내는 동안 로컬 계정 캐시를 업데이트하는 것을 잊어버린 것 같다는 것을 발견했다.

00:05:47.000 --> 00:05:56.000
데이터베이스를 업데이트한 후, 다음과 같이 로컬 표시 이름을 새 이름으로 설정해야 합니다.

00:05:56.000 --> 00:05:59.000
내가 그것을 하는 동안, 나는 이메일 주소에 대해 같은 버그를 발견했다.

00:05:59.000 --> 00:06:08.000
고맙게도, 이것은 같은 방식으로 고쳐질 수 있다.

00:06:08.000 --> 00:06:18.000
이제 내 의심을 확인하고 이것이 내 문제를 해결했는지 확인하기 위해 중단점을 설정합시다.

00:06:18.000 --> 00:06:24.000
이제 나는 내 애플리케이션을 다시 만들고 이 위치에서 일시 중지하기 위해 이전 단계를 다시 만들 것이다.

00:06:24.000 --> 00:06:28.000
이 장소에 도착한 후, 나는 내 의심이 옳은지 확인하고 싶다.

00:06:28.000 --> 00:06:40.000
그렇게 하기 위해, 나는 계정의 현재 상태를 "po"하고 내가 기대하는 오래된 데이터를 얻을 수 있는지 확인할 것이다.

00:06:40.000 --> 00:06:44.000
오, 안 돼. 나는 이 물건의 주소만 받은 것 같다.

00:06:44.000 --> 00:06:45.000
음, 그게 왜 그래?

00:06:45.000 --> 00:06:55.000
"Po"는 매우 일반적이지만, 이 클래스에 대한 나만의 사용자 지정 디버그 설명을 선언하지 않았기 때문에 내가 실행하고 싶은 표현의 유형이 아니라는 것이 밝혀졌다.

00:06:55.000 --> 00:07:03.000
사실, 이 경우, 나는 그냥 "p"를 실행하고 싶으니, 지금 그렇게 하도록 해줘.

00:07:03.000 --> 00:07:10.000
이제, 이것이 내가 원했던 것이고, 이것은 데이터베이스를 업데이트함으로써 표시 이름이 혼자 설정되지 않았다는 나의 의심을 확인시켜 준다.

00:07:10.000 --> 00:07:20.000
이제 제가 추가한 줄을 넘어가서 표시 이름이 업데이트되었는지 확인해 봅시다.

00:07:20.000 --> 00:07:22.000
완벽해-내 업데이트가 이 문제를 해결한 것 같아.

00:07:22.000 --> 00:07:25.000
이제 나는 새들에게 먹이를 주는 것으로 돌아갈 수 있다.

00:07:25.000 --> 00:07:33.000
이제 가장 간단한 LLDB 표현을 더 좋게 만든 Xcode 15 내부의 LLDB에 "스텝인"해 봅시다.

00:07:33.000 --> 00:07:38.000
내가 그 버그를 해결했을 때를 생각해보면, 나는 그것이 옳지 않은 곳에서 "po"를 사용하는 것을 발견했다.

00:07:38.000 --> 00:07:48.000
기껏해야, 이것은 표현식을 수행하는 데 더 오래 걸릴 수 있지만, 최악의 경우, 내 경우처럼 CustomStringConvertible을 구현하지 않을 때 단순히 속성의 주소를 돌려줄 수 있다.

00:07:48.000 --> 00:07:52.000
이것은 나를 좌절하게 만들고, 더 나은 선택이 있기를 바라게 만든다.

00:07:52.000 --> 00:07:57.000
그리고 나서 나는 그 부동산에서 "p"를 실행하여 올바른 결과를 얻었다.

00:07:57.000 --> 00:08:05.000
그러나 "표현", "v", "vo", "프레임 변수" 등과 같은 다른 많은 명령이 있습니다.

00:08:05.000 --> 00:08:11.000
이것은 하기 어려울 수 있으므로, 개발자를 돕기 위해, 우리는 Do What I Mean Print를 소개하고 있습니다.

00:08:11.000 --> 00:08:22.000
Do What I Mean Print를 사용하면 단일 명령을 사용하여 코드에서 다양한 표현식을 평가하면서 가능한 가장 빠른 방법으로 결과를 반환하여 시간을 절약할 수 있습니다.

00:08:22.000 --> 00:08:27.000
물론, 변수를 검사할 때마다 이 긴 명령을 입력하고 싶지는 않습니다.

00:08:27.000 --> 00:08:32.000
따라서, 우리는 이제 Do What I Mean Print를 수행하기 위해 이전 "p" 별칭을 교체했습니다.

00:08:32.000 --> 00:08:37.000
이를 통해 대부분의 사용 사례에 대해 단순히 "p"를 실행할 수 있습니다.

00:08:37.000 --> 00:08:45.000
또한, 실제로 변수에 대한 사용자 지정 개체 설명을 인쇄하고 싶을 때, 선택적 개체 설명 플래그와 함께 Do What I Mean Print 명령을 실행할 수 있습니다.

00:08:45.000 --> 00:08:53.000
그러나, 우리는 또한 사용자 지정 객체 설명과 함께 Do What I Mean Print를 수행하기 위해 이전 "po" 별칭을 교체했습니다.

00:08:53.000 --> 00:09:03.000
새로운 Do What I Mean Print 기능을 사용하면 과거에는 의도한 출력을 가장 빠르게 얻기 위해 여러 개의 다른 명령이 필요한 많은 다른 표현식에 대해 두 개의 명령 중 하나를 실행할 수 있습니다.

00:09:03.000 --> 00:09:18.000
마지막으로, 모든 사람이 로깅을 최대한 활용할 수 있도록 하는 방법을 살펴봅시다. 따라서 디버깅 경험을 개선하고 재현하기 어렵거나 사용자가 받은 보고서에 의존할 수 있는 문제를 보다 효과적으로 찾고 해결할 수 있도록 합니다.

00:09:18.000 --> 00:09:25.000
먼저, 표준 I/O는 명령줄 UI를 위한 것이고 OSLog는 디버깅을 위한 것임을 모두에게 상기시킬 것이다.

00:09:25.000 --> 00:09:29.000
따라서, "인쇄"는 프로그램 실행에서 이벤트를 기록하는 데 거의 사용되지 않아야 합니다.

00:09:29.000 --> 00:09:37.000
OSLog를 사용하여 최종 사용자로부터 구조화된 로깅을 얻고 디버그 콘솔에서 구조를 유지하는 것이 훨씬 낫다.

00:09:37.000 --> 00:09:43.000
이제 표준 I/O에서 OSLog로 변환하는 것이 얼마나 쉬운지에 대한 몇 가지 예를 살펴보겠습니다.

00:09:43.000 --> 00:09:47.000
이것은 내가 추가 로깅을 추가하고 싶은 간단한 기능이다.

00:09:47.000 --> 00:09:52.000
수행된 작업과 그 작업을 실행한 결과를 기록하는 것이 좋습니다.

00:09:52.000 --> 00:09:56.000
제가 아는 가장 좋은 방법으로 이것을 추가하기 위해 잠시 시간을 볼게요.

00:09:56.000 --> 00:10:01.000
좋아요--이 코드를 따르는 데 도움이 되는 몇 가지 간단한 "인쇄" 문구를 추가했습니다.

00:10:01.000 --> 00:10:07.000
나는 지금 이 기능에서 내가 하고 있는 작업과 그 결과로 작업이 완료되었을 때 인쇄하고 있다.

00:10:07.000 --> 00:10:13.000
하지만 내 프로젝트 내의 더 많은 장소에 이것을 한 후, 이 모든 출력이 어디에서 오는지 찾기가 어려워졌다.

00:10:13.000 --> 00:10:18.000
이로 인해 나는 많은 사람들이 해야 했던 것처럼 내 인쇄물에 마커를 추가하기 시작했다.

00:10:18.000 --> 00:10:20.000
하지만 이건 손에서 벗어나는 것 같아.

00:10:20.000 --> 00:10:24.000
이 모든 추가 출력을 추가한 후, 그것은 내 콘솔을 더 어수선하게 만들었다.

00:10:24.000 --> 00:10:29.000
추가 작업 없이 이 모든 메타데이터를 얻을 수 있는 더 나은 방법이 있었으면 좋겠어.

00:10:29.000 --> 00:10:32.000
음, OSLog는 내가 필요한 것을 하는 것으로 밝혀졌다.

00:10:32.000 --> 00:10:36.000
이제, 저는 통합 로깅을 활용하기 위해 이 기능을 업데이트하고 싶습니다.

00:10:36.000 --> 00:10:43.000
시작하려면, 먼저 OSLog를 내 프로젝트로 가져온 다음 로그 핸들을 만들 수 있도록 해야 합니다.

00:10:43.000 --> 00:10:48.000
이것은 내가 내 로그가 나타내고 싶은 하위 시스템과 카테고리를 지정하는 곳이다.

00:10:48.000 --> 00:10:57.000
이것들은 디버그 필터링을 더 쉽게 만드는 모든 문자열이 될 수 있지만, 하위 시스템 및 클래스 또는 카테고리의 구성 요소 이름에 번들 식별자를 사용하는 것이 일반적입니다.

00:10:57.000 --> 00:11:07.000
로거를 만들고 나면, 로거 객체에 제공된 함수를 호출하여 로그 수준을 지정하고 표시하고 싶은 메시지를 제공하기만 하면 됩니다.

00:11:07.000 --> 00:11:11.000
이것은 훨씬 더 잘 읽고 장기적으로 훨씬 적은 코드를 초래한다.

00:11:11.000 --> 00:11:16.000
이제 제가 그것을 실행할 때 콘솔에서 이것이 어떻게 보일지 알 수 있게 해주세요.

00:11:16.000 --> 00:11:22.000
이를 위해, 이 모든 메타데이터가 어디에서 올지 검사할 수 있도록 이 로그 중 두 개를 분리합시다.

00:11:22.000 --> 00:11:31.000
로그 출력에서, 활성화된 경우, 바로 아래에 있는 로그에 대해 지정한 추가 메타데이터로 출력하려는 메시지를 찾을 수 있습니다.

00:11:31.000 --> 00:11:37.000
이 메타데이터 중 일부는 메시지와 레벨과 같은 초기 로그를 작성한 위치에서 수집됩니다.

00:11:37.000 --> 00:11:43.000
다른 것들은 하위 시스템 및 카테고리와 같은 반복을 저장하기 위해 로그 핸들을 만들 때 수집됩니다.

00:11:43.000 --> 00:11:44.000
그리고 일부는 백그라운드에서 처리된다.

00:11:44.000 --> 00:11:50.000
여기에는 타임스탬프, 라이브러리 이름, 프로세스 ID, 스레드 ID 및 소스 위치가 포함됩니다.

00:11:50.000 --> 00:11:58.000
이 모든 정보는 필요할 때 큰 도움이 될 수 있지만 필요에 관계없이 모든 로그에 인쇄할 때 많은 공간을 차지합니다.

00:11:58.000 --> 00:12:04.000
고맙게도, 새로운 디버그 콘솔을 사용하면 원하는 것을 제공하기 위해 보기를 사용자 정의할 수 있습니다.

00:12:04.000 --> 00:12:10.000
마지막으로, 로깅을 최대한 활용하려면, 애플리케이션을 구축할 때 이것을 고려하십시오.

00:12:10.000 --> 00:12:24.000
첫째, 항상 응용 프로그램의 다른 구성 요소에 대해 별도의 로그 핸들을 만들어야 하므로 기본 메타데이터에 의미 있는 검색어를 설정하여 응용 프로그램의 섹션과 가장 관련성이 높은 로그를 더 빠르게 찾을 수 있습니다.

00:12:24.000 --> 00:12:32.000
또한, OSLogStore를 활용하여 현장에서 애플리케이션에 문제가 발생할 때 귀중한 진단을 수집하십시오.

00:12:32.000 --> 00:12:35.000
그리고 마지막으로, OSLog는 추적 시설이라는 것을 명심하세요.

00:12:35.000 --> 00:12:42.000
이것은 Instruments와 같은 도구를 사용하여 애플리케이션의 복잡한 성능 분석을 제공할 수 있다는 것을 의미합니다.

00:12:42.000 --> 00:12:50.000
이 예에서, 저는 로깅 프로파일링 템플릿을 사용하여 OSLogs와 표지판을 사용하여 애플리케이션의 성능을 분석하고 있습니다.

00:12:50.000 --> 00:12:56.000
이제, 우리가 방금 검토한 것과 자신의 프로그래밍 경험을 개선하기 위해 할 수 있는 일을 요약해 봅시다.

00:12:56.000 --> 00:13:04.000
먼저, Xcode 15에서 새로운 디버그 콘솔을 탐색해야 하며, 모든 로깅 요구에 대한 수많은 개선 사항을 제공했습니다.

00:13:04.000 --> 00:13:12.000
다음으로, 코드를 표준 I/O에서 OSLog로 마이그레이션하여 새로운 디버그 콘솔이 제공하는 모든 새로운 기능을 제공해야 합니다.

00:13:12.000 --> 00:13:21.000
그런 다음, LLDB의 새로운 Do What I Mean Print 또는 "p" 명령을 시도하고 먼저 가변 검사를 수행할 때 이것을 사용하세요.

00:13:21.000 --> 00:13:32.000
그리고 마지막으로, Apple의 통합 로깅 API에 대한 자세한 내용은 이전 세션인 "로깅을 사용한 성능 측정"과 "스위프트에서 로깅 탐색"을 시청하십시오.

00:13:32.000 --> 23:59:59.000
행복한 로깅, 그리고 봐줘서 고마워.

