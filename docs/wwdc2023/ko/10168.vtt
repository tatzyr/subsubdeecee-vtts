WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:14.000
소피아: 안녕하세요, "파라미터 팩으로 API 일반화"에 오신 것을 환영합니다.

00:00:14.000 --> 00:00:18.000
제 이름은 소피아이고, 저는 스위프트 컴파일러 팀에서 일합니다.

00:00:18.000 --> 00:00:26.000
오늘 저는 스위프트 매개 변수 팩과 일반 프로그래밍으로 새로운 차원의 유연성을 제공하는 방법에 대해 이야기할 것입니다.

00:00:26.000 --> 00:00:30.000
이것은 고급 대화이며, 기존 제네릭 시스템을 기반으로 한다.

00:00:30.000 --> 00:00:37.000
이 주제에 익숙하지 않다면, WWDC22의 "Embrace Swift generics"를 보는 것이 좋습니다.

00:00:37.000 --> 00:00:51.000
오늘, 저는 매개 변수 팩이 해결할 수 있는 문제의 유형, 라이브러리에서 발생할 때 매개 변수 팩에 대해 생각하는 방법을 안내할 것이며, 마지막으로 매개 변수 팩을 활용하는 자체 코드를 구현하는 방법에 대해 자세히 알아보겠습니다.

00:00:51.000 --> 00:00:55.000
매개 변수 팩에 뛰어들기 전에, 그것들이 왜 존재하는지 아는 것이 중요하다.

00:00:55.000 --> 00:01:00.000
그래서 나는 제네릭과 variadics에 대해 조금 이야기하는 것으로 시작할 것이다.

00:01:00.000 --> 00:01:07.000
당신이 쓰는 코드는 기본적으로 두 가지 범주로 구성되어 있습니다: 값과 유형.

00:01:07.000 --> 00:01:13.000
다른 값을 매개 변수로 받아들이는 함수를 작성하여 값을 추상화할 수 있습니다.

00:01:13.000 --> 00:01:25.000
예를 들어 라디안(from:) 함수는 입력으로 학위를 나타내는 이중 값을 받아들이고 출력을 위해 라디안을 나타내는 새로운 이중 값을 반환할 수 있습니다.

00:01:25.000 --> 00:01:31.000
매개 변수에 대해 다양한 유형을 허용하는 일반 코드를 작성하여 유형을 추상화할 수 있습니다.

00:01:31.000 --> 00:01:39.000
예를 들어, 표준 라이브러리 어레이 유형은 당신이 채우고 싶은 모든 형태의 데이터를 보유하도록 설계되었습니다.

00:01:39.000 --> 00:01:47.000
배열의 주어진 인스턴스에 사용할 구체적인 유형의 자리 표시자인 요소 유형 매개 변수가 있습니다.

00:01:47.000 --> 00:01:53.000
두 경우 모두, 구체적인 가치나 구체적인 유형은 추상화에 대한 주장으로 전달된다.

00:01:53.000 --> 00:01:59.000
대부분의 일반 코드는 유형과 값 모두에 대한 추상화이다.

00:01:59.000 --> 00:02:04.000
이것을 탐구하기 위해, 나는 서버에 쿼리를 보내기 위한 코드를 작성할 것이다.

00:02:04.000 --> 00:02:16.000
기본 구현은 일부 페이로드 유형의 요청을 받은 다음, 이를 서버에 쿼리로 전달하고, 마지막으로 페이로드 유형의 서버 응답을 반환합니다.

00:02:16.000 --> 00:02:21.000
이 함수에는 하나의 매개 변수가 있지만, 같은 호출에서 여러 요청을 쿼리하는 것을 지원하고 싶습니다.

00:02:21.000 --> 00:02:27.000
다양한 수의 인수를 가질 수 있는 능력을 위해, 우리는 가변적인 매개 변수를 가지고 있다.

00:02:27.000 --> 00:02:34.000
가변 매개 변수는 함수가 단일 유형의 인수를 유연하게 받아들일 수 있게 해준다.

00:02:34.000 --> 00:02:37.000
하지만 가변적인 매개 변수에는 한계가 있다.

00:02:37.000 --> 00:02:45.000
예를 들어, 주어진 인수를 길이가 인수 수와 같은 튜플에 매핑하고 싶을 수도 있습니다.

00:02:45.000 --> 00:02:52.000
그러나, 가변적인 매개 변수를 사용하면, 인수 길이를 기반으로 하는 반환 유형을 선언할 방법이 없습니다.

00:02:52.000 --> 00:03:04.000
또한 가변 매개 변수가 유형 삭제를 사용하지 않고 다양한 유형을 받아들일 수 있는 방법이 없으므로 각 인수의 특정 정적 유형 정보를 보존할 방법이 없습니다.

00:03:04.000 --> 00:03:14.000
우리가 제네릭 시스템과 가변 매개 변수에서 부족한 것은 유형 정보를 보존하고 인수의 수를 변경할 수 있는 능력이다.

00:03:14.000 --> 00:03:22.000
오늘날, 이것을 하는 유일한 방법은 당신이 지지하는 인수 수의 상한선을 선택하도록 강요하는 과부하를 하는 것이다.

00:03:22.000 --> 00:03:26.000
두 가지 매개 변수가 충분할까요? 아마 아닐 거야.

00:03:26.000 --> 00:03:29.000
최대 세 개의 매개 변수를 처리하는 것이 더 낫다.

00:03:29.000 --> 00:03:31.000
하지만 우리가 네 개를 원한다면?

00:03:31.000 --> 00:03:40.000
이 오버로드 패턴과 그 한계는 개념적으로 다양한 수의 유형 매개 변수를 처리하는 API에 널리 퍼져 있다.

00:03:40.000 --> 00:03:50.000
이 접근 방식은 중복성의 단점을 가지고 있지만, 더 중요한 것은, 지원될 인수의 수에 대한 임의의 상한선을 선택하도록 강요한다는 것이다.

00:03:50.000 --> 00:03:56.000
선택된 한도를 초과하면 추가 인수에 대한 컴파일러 오류가 발생합니다.

00:03:56.000 --> 00:04:00.000
이것은 매개 변수 팩이 해결하는 종류의 문제이다.

00:04:00.000 --> 00:04:08.000
만약 당신이 이 과부하 패턴에 빠지는 것을 발견한다면, 그것은 당신이 매개 변수 팩을 사용하고 싶다는 강력한 신호입니다.

00:04:08.000 --> 00:04:18.000
스위프트 5.9에서 제네릭 시스템은 "파라미터 팩"이라는 새로운 구성으로 인수 길이에 대한 추상화에 대한 일류 지원을 얻고 있다.

00:04:18.000 --> 00:04:24.000
이제 API에서 매개 변수 팩을 볼 때 어떤 의미인지에 대해 이야기할 것입니다.

00:04:24.000 --> 00:04:28.000
코드에서, 대부분의 경우, 당신은 단일 유형이나 값으로 작업합니다.

00:04:28.000 --> 00:04:37.000
매개 변수 팩은 모든 양의 유형이나 값을 저장할 수 있으며 함께 포장하여 함수에 인수로 전달할 수 있습니다.

00:04:37.000 --> 00:04:41.000
개별 유형을 수용하는 팩을 타입 팩이라고 한다.

00:04:41.000 --> 00:04:49.000
예를 들어, Bool, Int 및 String의 세 가지 개별 유형을 수용하는 유형 팩을 가질 수 있습니다.

00:04:49.000 --> 00:04:54.000
개별 가치를 지닌 팩은 가치 팩이라고 불린다.

00:04:54.000 --> 00:05:02.000
예를 들어, 세 가지 개별 값을 보유하는 값 팩을 가질 수 있습니다: true, 숫자 10, 그리고 빈 문자열.

00:05:02.000 --> 00:05:05.000
타입 팩과 밸류 팩은 함께 사용됩니다.

00:05:05.000 --> 00:05:12.000
유형 팩은 가치 팩의 각 개별 가치에 대해 각 개별 유형을 제공합니다.

00:05:12.000 --> 00:05:17.000
해당 유형과 값은 각각의 팩에서 같은 위치에 있다.

00:05:17.000 --> 00:05:22.000
위치 0에서, true 값의 유형은 Bool이다.

00:05:22.000 --> 00:05:27.000
위치 1에서, 정수 리터럴 10의 유형은 Int이다.

00:05:27.000 --> 00:05:32.000
그리고 위치 2에서, 빈 문자열 리터럴의 유형은 문자열이다.

00:05:32.000 --> 00:05:39.000
매개 변수 팩을 사용하면 팩의 모든 개별 요소와 함께 작동하는 하나의 일반 코드를 작성할 수 있습니다.

00:05:39.000 --> 00:05:48.000
이 개념은 스위프트에서 컬렉션을 사용할 때 다른 개별 요소와 함께 작동하는 하나의 코드를 작성하는 데 이미 익숙하기 때문에 친숙하게 들릴 수 있습니다.

00:05:48.000 --> 00:05:51.000
당신이 그러한 코드를 작성하는 방식은 반복을 통해서입니다.

00:05:51.000 --> 00:05:58.000
예를 들어, for-in 루프의 본문은 배열의 각 개별 요소에서 작동합니다.

00:05:58.000 --> 00:06:08.000
매개 변수 팩을 컬렉션과 다르게 만드는 것은 팩의 각 요소가 다른 정적 유형을 가지고 있으며, 유형 수준에서 팩으로 작업할 수 있다는 것입니다.

00:06:08.000 --> 00:06:16.000
일반적으로, 각 괄호 안에 유형 매개 변수를 선언하여 다른 구체적인 유형에서 작동하는 일반 코드를 작성합니다.

00:06:16.000 --> 00:06:24.000
스위프트 5.9에서는 "각각"이라는 키워드로 유형 매개 변수 팩을 선언할 수 있습니다.

00:06:24.000 --> 00:06:31.000
단일 유형 매개 변수를 갖는 대신, 이 함수는 쿼리하려는 각 페이로드 유형을 허용합니다.

00:06:31.000 --> 00:06:34.000
이것은 유형 매개 변수 팩이라고 불린다.

00:06:34.000 --> 00:06:45.000
유형 팩과 값 팩의 이름을 자연스럽게 읽으려면, "각 페이로드"가 아닌 "각 페이로드"와 같은 단일 명명 규칙을 사용하세요.

00:06:45.000 --> 00:06:53.000
매개 변수 팩을 사용하는 일반 코드는 반복 패턴을 사용하여 각 페이로드에서 개별적으로 작동할 수 있습니다.

00:06:53.000 --> 00:07:00.000
반복 패턴은 '반복' 키워드를 사용하여 표현되며, 패턴 유형이라는 유형이 뒤따른다.

00:07:00.000 --> 00:07:05.000
패턴은 팩 요소에 대한 하나 이상의 참조를 포함할 것이다.

00:07:05.000 --> 00:07:12.000
'반복'은 주어진 인수 팩의 모든 요소에 대해 패턴 유형이 반복될 것임을 나타냅니다.

00:07:12.000 --> 00:07:19.000
'각각'은 모든 반복에서 개별 팩 요소로 대체되는 자리 표시자 역할을 한다.

00:07:19.000 --> 00:07:24.000
이 교체품이 Bool, Int 및 String이 포함된 콘크리트 타입 팩에서 어떻게 작동하는지 봅시다.

00:07:24.000 --> 00:07:34.000
패턴은 세 번 반복되며 자리 표시자 '각 페이로드'는 각 반복 중에 팩의 콘크리트 유형으로 대체됩니다.

00:07:34.000 --> 00:07:42.000
결과는 쉼표로 구분된 유형 목록입니다: Bool 요청, Int 요청 및 문자열 요청.

00:07:42.000 --> 00:07:52.000
반복 패턴은 쉼표로 구분된 유형 목록을 생성하기 때문에, 쉼표로 구분된 목록을 자연스럽게 받아들이는 위치에서만 사용할 수 있습니다.

00:07:52.000 --> 00:07:59.000
여기에는 튜플 유형 또는 단일 유형인 괄호로 묶인 유형이 포함됩니다.

00:07:59.000 --> 00:08:07.000
또한, 그것들은 함수 매개 변수 목록에서 사용될 수 있으며, 반복 패턴은 일반적인 인수 목록에서 사용될 수 있다.

00:08:07.000 --> 00:08:16.000
반복 패턴을 함수 매개 변수의 유형으로 사용하면 함수 매개 변수가 값 매개 변수 팩으로 바뀝니다.

00:08:16.000 --> 00:08:27.000
이를 통해 호출자는 임의의 수의 요청 인스턴스를 전달할 수 있으며, 인수 값은 팩으로 수집되어 함수에 전달됩니다.

00:08:27.000 --> 00:08:32.000
그것은 매개 변수 팩의 기본 개념과 사용되는 구문을 다룹니다.

00:08:32.000 --> 00:08:40.000
다음으로, API의 기능을 단순화하고 확장할 수 있는 방법을 보여주기 위해, 쿼리 API로 돌아가 봅시다.

00:08:40.000 --> 00:08:47.000
변수 요청 인수와 해당 반환 유형을 제공하기 위해 여러 일반 오버로드를 추가했습니다.

00:08:47.000 --> 00:08:52.000
각 과부하 선언은 예측 가능한 패턴을 따른다.

00:08:52.000 --> 00:08:58.000
각 오버로드에는 각각 1, 2, 3, 4개의 유형 매개 변수가 있습니다.

00:08:58.000 --> 00:09:04.000
각 오버로드는 각 유형 매개 변수를 매개 변수 목록의 해당 유형에 대한 요청에 매핑합니다.

00:09:04.000 --> 00:09:09.000
그리고 각 오버로드는 반환 유형의 각 유형 매개 변수 목록을 포함합니다.

00:09:09.000 --> 00:09:15.000
매개 변수 팩을 사용하여, 이 4개의 과부하는 단일 함수로 축소될 수 있다.

00:09:15.000 --> 00:09:22.000
먼저 유형 매개 변수 선언, 함수 매개 변수 목록, 그리고 마지막으로 반환 유형을 고려해 봅시다.

00:09:22.000 --> 00:09:27.000
각 유형 매개 변수는 유형 매개 변수 팩으로 축소될 수 있습니다.

00:09:27.000 --> 00:09:33.000
각 개별 요청 매개 변수는 값 매개 변수 팩으로 축소될 수 있습니다.

00:09:33.000 --> 00:09:40.000
그리고 반환 유형은 각 페이로드 유형을 반복하여 구성된 튜플로 축소될 수 있습니다.

00:09:40.000 --> 00:09:44.000
이제 원하는 수의 요청 인수를 처리할 수 있는 하나의 쿼리 함수가 있습니다.

00:09:44.000 --> 00:10:00.000
함수 매개 변수와 반환 유형은 모두 유형 매개 변수 팩 '각 페이로드'의 종속 유형이기 때문에, 함수의 값 매개 변수 팩의 길이는 항상 반환되는 튜플의 요소 수와 일치한다는 것을 알고 있습니다.

00:10:00.000 --> 00:10:10.000
이제 이 API에서 매개 변수 팩을 채택했으므로, 하나의 인수 또는 세 개의 인수 또는 원하는 양으로 이 단일 쿼리 함수를 호출할 수 있습니다.

00:10:10.000 --> 00:10:13.000
매개 변수 팩은 모든 인수 길이를 같은 방식으로 처리합니다.

00:10:13.000 --> 00:10:17.000
세 가지 논쟁으로 통화에 집중합시다.

00:10:17.000 --> 00:10:21.000
구체적인 인수 팩은 콜 사이트의 인수에서 추론된다.

00:10:21.000 --> 00:10:28.000
자리 표시자 '각 페이로드'의 모든 구체적인 유형은 인수 목록에서 유형 팩으로 수집됩니다.

00:10:28.000 --> 00:10:33.000
그리고 콘크리트 유형 팩은 반환 유형을 생산하기 위해 대체된다.

00:10:33.000 --> 00:10:38.000
'각 페이로드'는 매개 변수 목록과 반환 유형에 나타납니다.

00:10:38.000 --> 00:10:48.000
콘크리트 타입 팩 "Int, String, Bool"은 두 곳에서 모두 대체되어 패턴이 세 번 반복된다.

00:10:48.000 --> 00:10:55.000
결국, 실행되는 코드는 유형 팩의 세 가지 유형 모두에 대한 반복과 같다.

00:10:55.000 --> 00:11:00.000
이제 쿼리 API로 돌아가서 매개 변수 팩에 제약 조건을 추가하는 방법을 알아봅시다.

00:11:00.000 --> 00:11:04.000
우리의 쿼리 페이로드가 동등해야 한다고 가정해 봅시다.

00:11:04.000 --> 00:11:15.000
유형 매개 변수 팩 다음에 콜론과 프로토콜 이름 Equatable을 추가함으로써, 페이로드 팩의 모든 요소는 Equatable을 준수해야 합니다.

00:11:15.000 --> 00:11:20.000
더 일반적인 요구 사항은 일반 제네릭과 마찬가지로 '어디' 조항으로 선언될 수 있다.

00:11:20.000 --> 00:11:32.000
매개 변수 팩이 0개 이상의 인수를 포함할 수 있다는 것을 기억하면, 이 서버 쿼리 API는 0 인수를 받아들일 특별한 이유가 없다고 생각할 수 있습니다.

00:11:32.000 --> 00:11:36.000
다행히도, 최소 인수 길이를 요구하는 간단한 기술이 있다.

00:11:36.000 --> 00:11:43.000
이 경우, 나는 그 기능에 할 일을 주기 위해 적어도 하나의 인수를 요구하고 싶다.

00:11:43.000 --> 00:11:53.000
이를 달성하기 위해, 유형 매개 변수 팩 앞에 일반 유형 매개 변수와 값 매개 변수 팩 앞에 해당하는 값 매개 변수를 추가합니다.

00:11:53.000 --> 00:12:01.000
유형 매개 변수 팩에 대한 모든 제약은 새로운 유형 매개 변수에도 적용되어야 하며, 이 예에서는 Equatable에 부합합니다.

00:12:01.000 --> 00:12:05.000
이제 함수 호출자는 적어도 하나의 인수를 제공해야 합니다.

00:12:05.000 --> 00:12:12.000
이 시점에서, 우리는 매개 변수 팩이 해결하는 기초와 API에서 읽는 방법을 다루었습니다.

00:12:12.000 --> 00:12:16.000
다음으로, 매개 변수 팩을 사용하는 코드를 구현하는 방법을 살펴봅시다.

00:12:16.000 --> 00:12:21.000
우리는 매개 변수 팩을 사용하여 서버 쿼리의 구현을 구축할 것입니다.

00:12:21.000 --> 00:12:30.000
쿼리 함수는 모든 개별 요소가 유형 팩의 모든 요소에 대한 요청인 값 팩을 받아들입니다.

00:12:30.000 --> 00:12:39.000
요청 구조체에는 페이로드라는 단일 유형 매개 변수와 페이로드 인스턴스를 반환하는 평가 방법이 있습니다.

00:12:39.000 --> 00:12:44.000
쿼리 함수의 본문은 '항목' 값 팩에서 작동할 것이다.

00:12:44.000 --> 00:12:51.000
쿼리 본문 내에서, 나는 가치 팩의 모든 항목에 대한 평가 메소드를 호출하고 싶다.

00:12:51.000 --> 00:12:54.000
반복 패턴을 사용하여 이것을 표현할 수 있습니다.

00:12:54.000 --> 00:13:01.000
반복 패턴은 유형 수준과 값 수준에서 동일한 구문을 사용하여 표현됩니다.

00:13:01.000 --> 00:13:06.000
값 수준에서, '반복' 키워드 뒤에 패턴 표현식이 따른다.

00:13:06.000 --> 00:13:11.000
패턴 표현은 하나 이상의 가치 팩을 포함할 것이다.

00:13:11.000 --> 00:13:17.000
팩은 포함된 모든 값을 통해 반복되며, 표현식은 값당 한 번 평가됩니다.

00:13:17.000 --> 00:13:25.000
튜플에 포함된 모든 평가 결과 목록을 생성하려면, 패턴 표현식을 괄호로 묶을 수 있습니다.

00:13:25.000 --> 00:13:31.000
함수에 전달된 값 팩이 비어 있다면, 결과는 빈 튜플이 될 것이다.

00:13:31.000 --> 00:13:36.000
값 팩에 단일 요소가 있다면, 결과는 또 다른 단일 값이 될 것이다.

00:13:36.000 --> 00:13:40.000
값 팩에 여러 요소가 있다면, 결과는 튜플이 될 것이다.

00:13:40.000 --> 00:13:41.000
그리고 그게 다야.

00:13:41.000 --> 00:13:52.000
이제, 우리는 결과의 값 팩을 받아들이고, 모든 개별 요청을 평가하고, 모든 요청의 결과를 튜플에서 함께 반환하는 쿼리 함수를 가지고 있습니다.

00:13:52.000 --> 00:13:57.000
이것은 코드에서 매개 변수 팩을 사용하는 방법의 기초입니다.

00:13:57.000 --> 00:14:08.000
이것은 매개 변수 팩이 아닌 여러 오버로드를 사용한 이전 예제보다 훨씬 적은 코드이며, 그 버전에는 구현조차 없었다.

00:14:08.000 --> 00:14:14.000
유지 보수가 더 쉽고, 반복적인 코드 패턴에서 종종 발생하는 오류는 사라졌다.

00:14:14.000 --> 00:14:16.000
이제 좀 더 유연성을 추가해 봅시다.

00:14:16.000 --> 00:14:31.000
쿼리 API가 상태를 저장할 수 있도록 하고, 각 요청 평가가 다른 입력 및 출력 유형을 갖도록 허용하고, 매개 변수 팩 반복 중에 제어 흐름을 관리하기 위해 예제를 리팩토링할 것입니다.

00:14:31.000 --> 00:14:40.000
평가자 구조체 내부의 쿼리 함수를 이동하고 쿼리 메서드에서 평가자 유형으로 유형 매개 변수 팩을 들어 올릴 것입니다.

00:14:40.000 --> 00:14:47.000
평가자 구조체는 요청 팩을 괄호로 묶어 튜플 값으로 만들어 저장된 속성에 저장할 수 있습니다.

00:14:47.000 --> 00:14:57.000
구체적인 페이로드 유형 인수 팩을 감안할 때, '항목' 변수는 단일 요청이거나 모든 요청의 튜플이 될 것이다.

00:14:57.000 --> 00:15:04.000
다음으로, 요청을 구조체에서 출력이라는 관련 유형이 있는 프로토콜로 변경하겠습니다.

00:15:04.000 --> 00:15:09.000
그리고 나는 입력이라는 요청 프로토콜에 또 다른 관련 유형을 추가할 것이다.

00:15:09.000 --> 00:15:15.000
그런 다음 요청의 평가 방법을 업데이트하여 인수를 프로토콜의 입력 유형으로 만들 것입니다.

00:15:15.000 --> 00:15:20.000
이것은 메서드의 반환 유형이 인수 유형과 다를 수 있게 해준다.

00:15:20.000 --> 00:15:40.000
이 후, 나는 평가자를 업데이트하여 모든 페이로드 유형이 요청을 준수하도록 요구하고 그에 따라 '항목' 저장된 속성을 이제 단순히 '각 페이로드' 유형으로 업데이트합니다. 그러나, 이 시점에서, 평가자의 유형 매개 변수 팩의 "페이로드"라는 이름은 실제로 맞지 않는다.

00:15:40.000 --> 00:15:46.000
페이로드는 더 이상 요청에 포함된 것이 아니라 대신 요청 전체를 준수합니다.

00:15:46.000 --> 00:15:53.000
따라서, 우리는 페이로드의 이름을 Request로 변경하고 프로토콜의 이름을 RequestProtocol로 변경할 것입니다.

00:15:53.000 --> 00:16:02.000
쿼리 메서드는 이제 각 요청의 입력 유형의 팩을 수락할 수 있으며, 각 요청의 출력 유형 목록을 반환합니다.

00:16:02.000 --> 00:16:11.000
마지막으로, 쿼리 메소드에 대한 새로운 매개 변수 '입력'은 모든 항목의 평가 메소드에 대한 호출에 전달되어야 합니다.

00:16:11.000 --> 00:16:19.000
이제 우리는 쿼리에 포함하는 데이터 유형과 서버의 응답에서 다른 유형을 반환할 수 있습니다.

00:16:19.000 --> 00:16:30.000
메서드의 값 인수 팩의 길이가 반환되는 값 팩의 길이와 일치한다는 것을 알 수 있습니다. 왜냐하면 그들의 유형은 둘 다 평가자의 유형 팩을 기반으로 하기 때문입니다.

00:16:30.000 --> 00:16:35.000
저장된 속성 '항목'의 인수 길이도 마찬가지입니다.

00:16:35.000 --> 00:16:43.000
매개 변수 팩을 사용하는 것이 반복의 한 형태라는 점을 감안할 때, 반복에서 일찍 종료하고 싶다면 제어 흐름에 대해 궁금해할 수 있습니다.

00:16:43.000 --> 00:16:50.000
아마도 쿼리 모음의 결과는 모든 쿼리가 성공한 경우에만 효력을 발휘해야 할 것이다.

00:16:50.000 --> 00:16:53.000
던지기 오류는 이것을 위해 사용될 수 있다.

00:16:53.000 --> 00:17:03.000
우리의 예에서, 당신은 RequestProtocol의 평가 방법을 던지기 함수로 업데이트하고 평가자의 쿼리 방법의 반환 유형을 선택 사항으로 수정할 수 있습니다.

00:17:03.000 --> 00:17:12.000
쿼리 메서드의 본문을 do-catch 문으로 이동하여 do 절 내에 반환 문을 배치하고 catch 절에서 nil을 반환할 수 있습니다.

00:17:12.000 --> 00:17:20.000
이제 필요한 경우 모든 개별 쿼리의 평가는 모든 쿼리에 대한 반복을 중단할 수 있습니다.

00:17:20.000 --> 00:17:29.000
이 세션에서, 우리는 매개 변수 팩이 일반 코드의 인수 수뿐만 아니라 유형을 추상화할 수 있는 방법에 대해 이야기했습니다.

00:17:29.000 --> 00:17:41.000
우리는 이전에 수많은 과부하가 필요했던 단일 일반 구현을 작성하여 코드의 제한을 단순화하고 제거하기 위해 매개 변수 팩을 사용하는 방법을 살펴보았다.

00:17:41.000 --> 00:17:48.000
마지막으로, 우리는 매개 변수 팩을 활용하면서 서버에 쿼리를 보내는 것을 구현하기 위한 코드를 작성했습니다.

00:17:48.000 --> 00:17:54.000
제네릭에 대해 자세히 알아보려면, WWDC22의 "Embrace Swift generics" 세션을 확인하세요.

00:17:54.000 --> 00:18:03.000
그리고 프로토콜과 유형 삭제에 대해 자세히 알아보려면, WWDC22의 "스위프트에서 프로토콜 인터페이스 설계" 세션을 확인하세요.

00:18:03.000 --> 00:18:13.000
스위프트 매개 변수 팩은 일반적인 일반 패턴을 단순화하는 동시에 일반 코드에서 가능한 것을 확장할 수 있는 강력한 도구입니다.

00:18:13.000 --> 00:18:15.000
우리는 네가 그들과 함께 무엇을 만드는지 빨리 보고 싶어.

00:18:15.000 --> 23:59:59.000
봐줘서 고마워.

