WEBVTT

00:00:00.000 --> 00:00:04.000
♪ 부드러운 기악 힙합 ♪

00:00:04.000 --> 00:00:10.000
♪

00:00:10.000 --> 00:00:12.000
커트 클리프턴: 안녕하세요, 우리와 함께 해주셔서 감사합니다.

00:00:12.000 --> 00:00:16.000
저는 커트이고 SwiftUI 팀의 엔지니어입니다.

00:00:16.000 --> 00:00:17.000
제프 로버트슨: 그리고 저는 제프입니다.

00:00:17.000 --> 00:00:19.000
저는 또한 SwiftUI 팀의 엔지니어입니다.

00:00:19.000 --> 00:00:23.000
우리는 SwiftUI의 새로운 기능을 공유할 수 있는 기회를 갖게 되어 기쁩니다.

00:00:23.000 --> 00:00:29.000
커트: 이제 새로운 플랫폼을 포함하여 더 많은 곳에서 SwiftUI를 사용할 수 있습니다!

00:00:29.000 --> 00:00:36.000
새로운 데이터 흐름 유형은 도메인 모델링을 극적으로 단순화하여 그 어느 때보다 더 많은 전력을 제공합니다.

00:00:36.000 --> 00:00:42.000
인스펙터와 테이블 개선은 데이터를 표시할 수 있는 훌륭한 방법을 제공합니다.

00:00:42.000 --> 00:00:50.000
팀은 애니메이션 API를 증폭하여 앱을 사용하는 사람들에게 훨씬 더 아름다운 경험을 제공할 수 있도록 했습니다.

00:00:50.000 --> 00:01:04.000
프레임워크 전반에 걸쳐, 우리는 강력한 스크롤 뷰 개선, 포커스 및 키보드 입력에 대한 개선, 버튼과 메뉴와 같은 컨트롤의 더 깊은 사용자 정의를 통해 훌륭한 상호 작용을 제공할 수 있는 능력을 향상시켰습니다.

00:01:04.000 --> 00:01:10.000
SwiftUI를 사용할 수 있는 멋진 새로운 장소에 대해 알려드리게 되어 기쁩니다.

00:01:10.000 --> 00:01:22.000
헤드셋과 watchOS 10에서 새로운 위젯과 크로스 프레임워크 통합에 이르기까지, SwiftUI는 앱을 사용하는 사람들을 기쁘게 하는 경험을 만드는 데 도움을 줄 수 있습니다.

00:01:22.000 --> 00:01:38.000
공간 컴퓨팅은 볼륨과 같은 완전히 새로운 3D 기능, 몰입형 공간의 풍부한 경험, 새로운 3D 제스처, 효과 및 레이아웃, RealityKit과의 깊은 통합을 통해 SwiftUI를 대담한 새로운 미래로 가져옵니다.

00:01:38.000 --> 00:01:55.000
제어 센터의 홈 뷰와 같은 핵심 부분부터 TV, 사파리, 프리폼과 같은 친숙한 앱, 키노트의 몰입형 리허설과 같은 완전히 새로운 환경에 이르기까지, SwiftUI는 이러한 사용자 경험의 핵심입니다.

00:01:55.000 --> 00:02:01.000
이 새로운 플랫폼에서, WindowGroup과 같은 친숙한 장면 유형을 사용하여 창을 구성하세요.

00:02:01.000 --> 00:02:08.000
WindowGroup 장면은 유쾌한 깊이에 민감한 3D 컨트롤로 2D 창으로 렌더링됩니다.

00:02:08.000 --> 00:02:17.000
창 내에서 NavigationSplitView 또는 TabView와 같은 일반적인 SwiftUI 컨테이너 중 하나를 선택하십시오.

00:02:17.000 --> 00:02:24.000
이 컨테이너 내에서 다른 플랫폼과 마찬가지로 모든 일반적인 SwiftUI 컨트롤을 사용할 수 있습니다.

00:02:24.000 --> 00:02:29.000
더 깊이를 위해, 당신의 장면에 체적 스타일을 적용하세요.

00:02:29.000 --> 00:02:35.000
볼륨은 경계된 공간에서 보드 게임이나 건축 모델과 같은 3D 경험을 표시합니다.

00:02:35.000 --> 00:02:38.000
그들은 다른 앱과 함께 표시됩니다.

00:02:38.000 --> 00:02:44.000
사람들은 노트에 생각을 기록하거나 Keynote에서 슬라이드를 업데이트하는 동안 당신의 콘텐츠를 사용할 수 있습니다.

00:02:44.000 --> 00:02:49.000
Model3D를 사용하여 정적 모델로 볼륨을 채우세요.

00:02:49.000 --> 00:02:56.000
조명 효과 등을 갖춘 역동적이고 인터랙티브한 모델의 경우, 새로운 RealityView를 사용하세요.

00:02:56.000 --> 00:03:00.000
진정으로 모든 것을 진행하려면, 앱에 ImmersiveSpaces를 추가하세요.

00:03:00.000 --> 00:03:09.000
새로운 ImmersiveSpace 장면 유형을 사용하면 주변 환경에 내장되어 있든 완전히 몰입할 수 있는 몰입형 공간적 경험을 정의할 수 있습니다.

00:03:09.000 --> 00:03:15.000
이 시스템은 사람들이 당신이 만든 세계로 뛰어들 수 있도록 다른 앱을 멀리합니다.

00:03:15.000 --> 00:03:24.000
혼합 몰입 스타일로 ImmersiveSpace를 사용하여 앱을 현실 세계에 연결하여 콘텐츠를 사람들의 환경과 결합하세요.

00:03:24.000 --> 00:03:32.000
앱의 요소를 테이블과 표면에 고정하고, 가상 물체와 효과로 현실 세계를 보강하고 풍부하게 하세요.

00:03:32.000 --> 00:03:37.000
완전한 몰입 스타일로 더 나아가세요.

00:03:37.000 --> 00:03:40.000
당신의 앱이 완벽하게 제어합니다.

00:03:40.000 --> 00:03:47.000
볼륨으로 작동하는 동일한 Model3D와 RealityView를 사용하여 이러한 연결되고 몰입형 경험을 구축하세요.

00:03:47.000 --> 00:03:52.000
이 새로운 플랫폼의 SwiftUI를 사용하면 마법 같은 경험을 만들 수 있습니다.

00:03:52.000 --> 00:03:59.000
이 훌륭한 조합을 계속 탐구하려면 "공간 컴퓨팅을 위한 SwiftUI를 만나세요"를 보세요.

00:03:59.000 --> 00:04:08.000
SwiftUI는 집에서 방을 채우는 경험을 구축하지만, Apple의 가장 휴대성이 뛰어난 디스플레이를 위한 경험을 구축할 수도 있다.

00:04:08.000 --> 00:04:20.000
watchOS 10은 시기적절한 정보를 표시하고, 집중된 콘텐츠를 한 눈에 전달하며, 디스플레이의 모양과 충실도를 기념하는 재설계된 사용자 경험을 제공합니다.

00:04:20.000 --> 00:04:27.000
우리는 이 아름다운 전체 화면 색상과 이미지를 활용하기 위해 플랫폼 전반에 걸쳐 앱을 업데이트했습니다.

00:04:27.000 --> 00:04:34.000
이러한 디자인의 뿌리에는 watchOS 10에 새로 권한을 부여받은 몇 가지 기존 SwiftUI 뷰가 있습니다.

00:04:34.000 --> 00:04:40.000
NavigationSplitView와 NavigationStack은 아름다운 새로운 전환을 얻는다.

00:04:40.000 --> 00:04:45.000
탭뷰는 디지털 크라운에 의해 구동되는 새로운 수직 페이징 스타일을 얻는다.

00:04:45.000 --> 00:04:53.000
SwiftUI는 Apple Watch 앱에도 이 풀 컬러 감각을 가져오는 데 도움이 되는 몇 가지 새로운 API를 소개합니다.

00:04:53.000 --> 00:05:01.000
새로운 컨테이너 배경 수정자를 사용하면 콘텐츠를 푸시하고 팝할 때 움직이는 미묘한 배경 세척을 구성할 수 있습니다.

00:05:01.000 --> 00:05:05.000
watchOS에서 탭 보기에 대한 배경을 구성할 수도 있습니다.

00:05:05.000 --> 00:05:19.000
그리고 새로운 멀티플랫폼 툴바 배치(topBarLeading 및 topBarTrailing)는 기존 bottomBar와 함께 Apple Watch 앱에 이러한 작은 세부 보기를 완벽하게 배치할 수 있습니다.

00:05:19.000 --> 00:05:30.000
이러한 새로운 추가 사항 외에도, 우리는 DatePicker와 목록의 선택을 포함하여 기존 API를 watchOS에 처음으로 가져오게 되어 기쁩니다.

00:05:30.000 --> 00:05:35.000
지금이 이러한 새로운 기능으로 Apple Watch 앱을 연마할 수 있는 좋은 시기입니다.

00:05:35.000 --> 00:05:40.000
그리고 아직 Apple Watch 앱이 없다면, 시작하기에 좋은 시간입니다.

00:05:40.000 --> 00:05:47.000
"watchOS 10용 앱 설계 및 빌드"에서 디자인과 엔지니어링이 어떻게 함께 모여 이러한 경험을 만드는지 알아보세요.

00:05:47.000 --> 00:05:54.000
그런 다음 "watchOS 10용 앱 업데이트"로 이 아이디어를 작업에 적용하세요.

00:05:54.000 --> 00:06:01.000
watchOS 10의 스마트 스택 위젯을 사용하면 앱을 사용하는 사람들이 이동 중에도 정보를 볼 수 있습니다.

00:06:01.000 --> 00:06:08.000
SwiftUI는 다른 새로운 장소와 마찬가지로 위젯이 어디에 있든 위젯의 핵심이다.

00:06:08.000 --> 00:06:15.000
iPadOS 17의 잠금 화면의 위젯은 홈 화면의 위젯을 잘 보완합니다.

00:06:15.000 --> 00:06:21.000
크고 대담한 위젯은 대기 모드가 있는 iPhone 상시표시형 디스플레이에서 빛난다.

00:06:21.000 --> 00:06:27.000
그리고 macOS 소노마의 데스크톱 위젯은 사람들을 매일 최신 상태로 유지합니다.

00:06:27.000 --> 00:06:32.000
위젯은 새로운 장소로 가는 길을 찾았고, 팀은 또한 그들에게 또 다른 트릭을 가르쳤다.

00:06:32.000 --> 00:06:37.000
위젯이 이제 대화형 컨트롤을 지원한다는 것을 공유하게 되어 기쁩니다.

00:06:37.000 --> 00:06:44.000
위젯의 토글과 버튼은 이제 앱 인텐트를 사용하여 자신의 앱 번들에 정의된 코드를 활성화할 수 있습니다.

00:06:44.000 --> 00:06:50.000
그리고 SwiftUI 전환 및 애니메이션 수정자를 사용하여 위젯을 애니메이션화할 수 있습니다.

00:06:50.000 --> 00:06:58.000
이러한 훌륭한 새로운 기능을 시작하려면, "새로운 장소에 위젯을 가져오세요"와 "위젯을 현실로 가져오세요"를 확인하세요.

00:06:58.000 --> 00:07:05.000
새로운 인터랙티브 애니메이션 위젯을 개발하고 다듬기 위해, 당신은 Xcode 미리보기의 힘을 좋아할 것입니다.

00:07:05.000 --> 00:07:12.000
미리보기는 Swift 5.9의 매크로를 활용하여 우아한 새로운 구문을 제공합니다.

00:07:12.000 --> 00:07:19.000
미리보기를 선언하고 구성하고, 위젯 유형을 추가하고, 테스트를 위한 타임라인을 정의하세요.

00:07:19.000 --> 00:07:26.000
Xcode 미리보기는 현재 위젯 상태와 상태 간의 애니메이션을 볼 수 있는 타임라인을 보여줍니다.

00:07:26.000 --> 00:07:31.000
물론, 새로운 미리보기는 정기적인 SwiftUI 보기와 앱에서도 작동합니다.

00:07:31.000 --> 00:07:38.000
그리고 이제 Xcode 내에서 바로 Mac 앱의 미리보기와 상호 작용할 수 있습니다.

00:07:38.000 --> 00:07:48.000
"Xcode Previews로 프로그래밍 방식 UI 구축" 강연을 확인하여 이러한 훌륭한 새로운 도구를 활용하여 앱과 위젯 개발을 가속화하는 방법을 알아보세요.

00:07:48.000 --> 00:07:55.000
프리뷰를 제공하는 매크로 외에도, 스위프트 5.9는 또한 많은 다른 개선 사항을 제공한다.

00:07:55.000 --> 00:08:02.000
"스위프트의 새로운 기능"을 대기열로 서서 스위프트에서 신선한 모든 것에 대한 개요를 얻으세요.

00:08:02.000 --> 00:08:09.000
SwiftUI가 새로운 장소에 오는 또 다른 방법은 다른 Apple 프레임워크에 대한 SwiftUI 전용 확장을 통해서이다.

00:08:09.000 --> 00:08:17.000
몇몇 프레임워크는 새롭거나 개선된 지원을 가져오며, 특히 흥미롭다고 생각하는 몇 가지를 강조하고 싶습니다.

00:08:17.000 --> 00:08:24.000
MapKit은 SwiftUI 코드에서 바로 Apple의 놀라운 매핑 프레임워크의 힘을 제공하는 대규모 업데이트를 제공합니다.

00:08:24.000 --> 00:08:29.000
이러한 훌륭한 기능을 사용하려면 SwiftUI와 MapKit을 가져오기만 하면 됩니다.

00:08:29.000 --> 00:08:31.000
당신의 시야에 지도를 넣으세요.

00:08:31.000 --> 00:08:35.000
사용자 지정 마커, 폴리라인 및 사용자의 위치를 추가하세요.

00:08:35.000 --> 00:08:38.000
사용 가능한 컨트롤을 구성하세요.

00:08:38.000 --> 00:08:45.000
SwiftUI 앱에 놀라운 지도를 추가하는 것에 대한 모든 것을 배우려면, "SwiftUI를 위한 MapKit을 만나보세요" 강연을 확인하세요.

00:08:45.000 --> 00:09:03.000
2학년 시즌에, 스위프트 차트는 스크롤 차트, 선택에 대한 내장 지원, 그리고 사람들이 갈망했던 것을 포함하여 많은 큰 개선을 제공합니다: 새로운 섹터마크가 있는 도넛과 파이 차트.

00:09:03.000 --> 00:09:10.000
이러한 새로운 기능을 자세히 살펴보려면, "스위프트 차트에서 파이 차트와 상호 작용 살펴보기"라는 강연을 확인하세요.

00:09:10.000 --> 00:09:19.000
충성도 높은 고객을 유치하고 유지하는 경험을 구축하기 위해, 당신은 새로운 인앱 구매 및 구독 상점의 용이성과 힘을 좋아할 것입니다.

00:09:19.000 --> 00:09:24.000
맞춤형 마케팅 콘텐츠로 구독 스토어 보기를 제시하세요.

00:09:24.000 --> 00:09:31.000
브랜딩에 맞게 풀블리드 배경을 구성하고 다양한 제어 옵션 중에서 선택하세요.

00:09:31.000 --> 00:09:38.000
"Meet StoreKit for SwiftUI"를 시청하여 인앱 마케팅 게임을 강화하세요.

00:09:38.000 --> 00:09:48.000
새로운 플랫폼과 위젯에서 크로스 프레임워크 통합과 watchOS의 아름다움에 이르기까지, SwiftUI는 Apple 개발자 경험을 계속 발전시키고 있다.

00:09:48.000 --> 00:09:52.000
SwiftUI를 사용할 수 있는 모든 새로운 장소를 보는 것은 흥미롭다, 제프.

00:09:52.000 --> 00:09:57.000
제프: 당연하지! 그리고 우리는 또한 모든 플랫폼에서 작동하는 많은 큰 개선 사항을 가지고 있습니다.

00:09:57.000 --> 00:09:59.000
커트: 정말로!

00:09:59.000 --> 00:10:01.000
제프: 우리는 이러한 개선 사항을 사용하는 앱을 작업해야 합니다.

00:10:01.000 --> 00:10:02.000
커트: 오, 동의해!

00:10:02.000 --> 00:10:05.000
내 아이디어에 대해 더 생각해 본 적 있어?

00:10:05.000 --> 00:10:07.000
제프: 개에 관한 것? 커트: 그래!

00:10:07.000 --> 00:10:11.000
그건 마치 새를 관찰하는 것 같지만 개들을 위한 거야!

00:10:11.000 --> 00:10:14.000
제프: 정말 사람들이 개 관찰 앱을 원한다고 생각하세요?

00:10:14.000 --> 00:10:18.000
커트: 오, 당연하지! 피치 데크는 실질적으로 스스로 글을 쓴다.

00:10:18.000 --> 00:10:23.000
제프: 백만 달러짜리 아이디어가 마련되면, 앱을 구축하기 시작할 때입니다.

00:10:23.000 --> 00:10:32.000
모든 훌륭한 앱은 훌륭한 데이터 모델로 시작하기 때문에, SwiftUI가 앱의 데이터로 작업할 수 있는 훌륭한 새로운 기능 팩을 살펴보는 것부터 시작합시다.

00:10:32.000 --> 00:10:39.000
SwiftUI에 대해 내가 가장 좋아하는 것 중 하나는 내 UI를 앱 상태의 함수로 정의할 수 있는 방법이다.

00:10:39.000 --> 00:10:46.000
SwiftUI로 모델 유형을 정의하는 방법에 대한 가장 큰 업그레이드를 공유하게 되어 기쁩니다: 새로운 관찰 가능한 매크로.

00:10:46.000 --> 00:10:55.000
관찰 가능한 모델을 사용하면 데이터 흐름에 친숙한 SwiftUI 패턴을 사용할 수 있으며, 코드를 더 간결하고 성능 있게 만들 수 있습니다.

00:10:55.000 --> 00:11:01.000
여기 제가 밖에서 만난 개를 나타내는 데이터를 저장하기 위해 설정한 모델 수업이 있습니다.

00:11:01.000 --> 00:11:05.000
이 유형을 관찰 가능한 것으로 만들기 위해, 나는 내 유형에 매크로를 추가할 것이다.

00:11:05.000 --> 00:11:07.000
그게 내가 해야 할 전부야.

00:11:07.000 --> 00:11:12.000
ObservableObject와 달리, 속성을 게시된 것으로 표시할 필요가 없습니다.

00:11:12.000 --> 00:11:18.000
관찰 가능한 모델은 데이터 흐름을 위한 기존 SwiftUI 메커니즘에 쉽게 통합됩니다.

00:11:18.000 --> 00:11:21.000
내 DogCard 보기를 예로 들어 보자.

00:11:21.000 --> 00:11:28.000
보기에서 Observable을 사용할 때, SwiftUI는 당신이 읽은 속성에 대한 종속성을 자동으로 설정합니다.

00:11:28.000 --> 00:11:34.000
또한 읽을 때 속성 래퍼를 사용할 필요가 없으므로, 보기 코드가 더 깨끗합니다.

00:11:34.000 --> 00:11:40.000
그리고 이 견해는 isFavorite 속성을 읽고 있으므로, 그것이 변경되면 재평가될 것이다.

00:11:40.000 --> 00:11:50.000
무효화는 읽은 속성에 대해서만 발생하므로, 불필요한 업데이트를 트리거하지 않고도 중간 뷰를 통해 모델을 전달할 수 있습니다.

00:11:50.000 --> 00:12:01.000
SwiftUI에는 상태와 뷰와의 관계를 정의하기 위한 몇 가지 도구가 포함되어 있으며, 그 중 일부는 ObservableObject와 함께 사용하도록 설계되었습니다.

00:12:01.000 --> 00:12:11.000
Observable을 사용할 때, 이것은 상태 및 환경 동적 속성과 직접 작동하도록 설계되었기 때문에 훨씬 더 간단해집니다.

00:12:11.000 --> 00:12:21.000
읽기 전용 값을 모델링하는 것 외에도, Observables는 새로운 개 목격을 위한 이 양식과 같이 가변 상태를 나타내는 데 자연스럽게 적합합니다.

00:12:21.000 --> 00:12:32.000
모델은 상태 동적 속성을 사용하여 정의되며, 그 속성을 편집하는 양식 요소에 속성에 대한 바인딩을 전달하고 있습니다.

00:12:32.000 --> 00:12:37.000
마지막으로, 관찰 가능한 유형은 환경에 원활하게 통합된다.

00:12:37.000 --> 00:12:44.000
앱 전체의 뷰는 현재 사용자를 가져오는 방법을 원하기 때문에, 루트 뷰 환경에 추가했습니다.

00:12:44.000 --> 00:12:49.000
그런 다음 사용자 프로필 보기는 환경 동적 속성을 사용하여 값을 읽습니다.

00:12:49.000 --> 00:12:54.000
저는 여기서 환경 키로 유형을 사용하고 있지만, 사용자 지정 키도 지원됩니다.

00:12:54.000 --> 00:13:02.000
"SwiftUI로 관찰 발견"을 통해 이 강력한 새로운 도구를 활용하는 방법에 대해 자세히 알아보세요.

00:13:02.000 --> 00:13:06.000
나는 Observable이 내가 명확하고 간결한 코드를 작성할 수 있게 해주는 것을 좋아한다.

00:13:06.000 --> 00:13:16.000
그것은 내 앱의 좋은 시작을 주었지만, 내가 가장 좋아하는 모든 강아지를 놓치지 않도록 내 데이터 모델에 대한 변경 사항이 지속되도록 하고 싶습니다.

00:13:16.000 --> 00:13:20.000
SwiftData는 데이터 모델링 및 관리를 위한 완전히 새로운 프레임워크이다.

00:13:20.000 --> 00:13:24.000
그것은 빠르고 확장 가능하며 SwiftUI와 잘 작동합니다.

00:13:24.000 --> 00:13:31.000
SwiftData 모델은 전적으로 코드로 표현되므로 모든 SwiftUI 앱에 자연스럽게 적합합니다.

00:13:31.000 --> 00:13:37.000
SwiftData의 개 모델 유형을 설정하려면, Observable 사용에서 모델 매크로로 전환할 것입니다.

00:13:37.000 --> 00:13:39.000
이게 내가 해야 할 유일한 변화야.

00:13:39.000 --> 00:13:46.000
SwiftData가 제공하는 지속성 외에도, 모델은 Observable 사용의 모든 이점을 받는다.

00:13:46.000 --> 00:13:48.000
그건 정말 강력해.

00:13:48.000 --> 00:13:54.000
우리의 개 관찰 앱의 메인 화면은 최근에 만난 강아지의 스크롤 스택을 보여줍니다.

00:13:54.000 --> 00:13:58.000
여기서 SwiftData를 사용하는 데 필요한 변경 사항을 살펴봅시다.

00:13:58.000 --> 00:14:04.000
먼저, 앱의 정의에 모델 컨테이너를 추가하고 모델 유형을 제공할 것입니다.

00:14:04.000 --> 00:14:11.000
그런 다음, 내 뷰 코드에서, 나는 새로운 쿼리 동적 속성을 사용하기 위해 개 배열을 바꿀 것이다.

00:14:11.000 --> 00:14:16.000
쿼리를 사용하면 SwiftData에 기본 데이터베이스에서 모델 값을 가져오라고 말할 수 있습니다.

00:14:16.000 --> 00:14:22.000
내가 새로운 개를 발견했을 때처럼 데이터가 바뀌면, 내 견해는 무효화될 것이다.

00:14:22.000 --> 00:14:35.000
쿼리는 대규모 데이터 세트에 대해 매우 효율적이며, 내가 개를 발견한 날짜를 사용하기 위해 정렬 순서를 변경하는 것과 같이 데이터가 반환되는 방식을 사용자 정의할 수 있어 앱에서 더 나은 경험을 할 수 있습니다.

00:14:35.000 --> 00:14:40.000
SwiftData는 또한 macOS와 iOS에 문서의 데이터를 저장하는 데 적합합니다.

00:14:40.000 --> 00:14:52.000
나는 우리 앱을 위한 개 태그 시각적 치료법의 프로토타입을 빠르게 만들고 싶다고 결정했고, 그래서 커트와 우리 디자이너들과 협력하기 위해 이 작은 문서 기반 앱을 만들었다.

00:14:52.000 --> 00:14:58.000
문서 기반 앱은 새로운 이니셜라이저를 사용하여 SwiftData의 모든 기능을 활용할 수 있습니다.

00:14:58.000 --> 00:15:06.000
그런 다음 SwiftUI는 각 문서의 기본 저장소에 SwiftData를 사용하고 모델 컨테이너를 자동으로 설정합니다.

00:15:06.000 --> 00:15:14.000
SwiftData와 SwiftUI와 어떻게 통합되는지에 대해 자세히 알아보려면, "SwiftData를 만나세요"와 "SwiftData로 앱 구축"을 시청하세요.

00:15:14.000 --> 00:15:32.000
SwiftData 지원 외에도, DocumentGroup은 iOS 17 또는 iPadOS 17에서 실행할 때 자동 공유 및 문서 이름 바꾸기 지원뿐만 아니라 도구 모음의 실행 취소 컨트롤과 같은 많은 새로운 플랫폼 어포던스를 얻습니다.

00:15:32.000 --> 00:15:39.000
인스펙터는 현재 선택이나 컨텍스트에 대한 세부 사항을 표시하기 위한 새로운 수정자입니다.

00:15:39.000 --> 00:15:43.000
그것은 당신의 인터페이스에서 뚜렷한 섹션으로 제시됩니다.

00:15:43.000 --> 00:15:47.000
macOS에서 Inspector는 후행 사이드바로 표시됩니다.

00:15:47.000 --> 00:15:50.000
일반 사이즈 클래스의 iPadOS에서도 마찬가지입니다.

00:15:50.000 --> 00:15:55.000
컴팩트 사이즈 클래스에서, 그것은 시트로 나타날 것이다.

00:15:55.000 --> 00:16:02.000
인스펙터의 모든 세부 사항을 밝히려면, "SwiftUI의 검사관: 세부 사항을 발견하세요"를 보세요.

00:16:02.000 --> 00:16:09.000
대화는 iOS 17과 macOS 소노마에서 몇 가지 새로운 사용자 지정 API를 받았다.

00:16:09.000 --> 00:16:18.000
이미지 내보내기 대화상자에 확인 버튼의 라벨 조정과 같은 유용한 정보를 제공하기 위해 새로운 수정자 중 일부를 사용하고 있습니다.

00:16:18.000 --> 00:16:32.000
증가된 심각성은 중요한 확인 대화에 주의를 끄는 데 도움이 되며, 억제 토글을 포함하는 것은 대화가 후속 상호 작용을 위해 나타나서는 안 된다는 선호도를 나타냅니다.

00:16:32.000 --> 00:16:38.000
마지막으로, HelpLink를 추가하는 것은 대화의 목적에 대한 추가 정보에 대한 가이드가 될 수 있습니다.

00:16:38.000 --> 00:16:49.000
목록과 표는 대부분의 앱의 핵심 부분이며, SwiftUI는 iOS 17과 macOS Sonoma에서 미세 조정을 위한 몇 가지 새로운 기능과 API를 가져왔습니다.

00:16:49.000 --> 00:16:53.000
테이블은 열 순서와 가시성의 사용자 지정을 지원합니다.

00:16:53.000 --> 00:17:00.000
SceneStorage 동적 속성과 결합되면, 이러한 환경 설정은 앱 실행에서 유지될 수 있습니다.

00:17:00.000 --> 00:17:09.000
사용자 지정 상태를 나타내는 값을 테이블에 제공하고 각 열에 고유한 안정적인 식별자를 제공합니다.

00:17:09.000 --> 00:17:12.000
테이블은 이제 OutlineGroup의 모든 힘을 가지고 있다.

00:17:12.000 --> 00:17:22.000
이것은 내가 가장 좋아하는 개를 자랑스러운 부모와 그룹화하는 것과 같은 계층 구조에 적합한 대규모 데이터 세트에 적합합니다.

00:17:22.000 --> 00:17:30.000
새로운 DisclosureTableRow를 사용하여 다른 행을 포함하는 행을 나타내고, 평소와 같이 나머지 테이블을 만드세요.

00:17:30.000 --> 00:17:35.000
목록이나 테이블 내의 섹션은 프로그램 확장에 대한 지원을 받았다.

00:17:35.000 --> 00:17:44.000
나는 내 앱의 사이드바에서 위치 섹션을 처음에 축소된 것으로 보여주기 위해 그것을 사용했지만, 여전히 확장을 허용했다.

00:17:44.000 --> 00:17:51.000
새로운 이니셜라이저는 섹션의 현재 확장 상태를 반영하는 값에 바인딩합니다.

00:17:51.000 --> 00:18:01.000
더 작은 데이터 세트의 경우, 테이블은 행 배경과 열 헤더가 표시되는 방법과 같은 몇 가지 새로운 스타일 어포던스를 얻었다.

00:18:01.000 --> 00:18:09.000
그리고 마지막으로, 내 별 등급과 같은 사용자 지정 컨트롤은 새로운 배경 두드러진 환경 속성의 혜택을 받을 것이다.

00:18:09.000 --> 00:18:16.000
배경이 두드러질 때 덜 두드러진 전경 스타일을 사용하면 사용자 지정 컨트롤이 목록에서 집처럼 느껴집니다.

00:18:16.000 --> 00:18:28.000
목록과 테이블의 모양과 느낌을 미세 조정할 수 있는 이것들과 다른 API 외에도, 우리는 특히 대용량 데이터 세트를 다룰 때 성능을 크게 개선했습니다.

00:18:28.000 --> 00:18:37.000
이것과 자신의 SwiftUI 뷰를 최적화할 수 있는 방법에 대해 자세히 알아보려면, "SwiftUI 성능의 신비화"를 확인하세요.

00:18:37.000 --> 00:18:45.000
Observable에서 SwiftData, Inspector 및 테이블 사용자 지정에 이르기까지, 앱에서 데이터로 작업하는 것은 완전히 새로운 경험처럼 느껴집니다.

00:18:45.000 --> 00:18:52.000
커트: 제프가 모은 데이터 모델과 테이블로, 우리는 훌륭한 앱의 뼈대를 가지고 있다.

00:18:52.000 --> 00:18:57.000
저는 특별한 새로운 애니메이션 API를 사용하여 피자즈를 추가하고 싶습니다.

00:18:57.000 --> 00:19:02.000
개 사진 갤러리를 볼 수 있는 Apple TV 앱이 있으면 좋을 것 같아.

00:19:02.000 --> 00:19:07.000
여기 제가 현재 뷰어를 선택하기 위해 작업하고 있는 애니메이션이 있습니다.

00:19:07.000 --> 00:19:11.000
나는 이것을 새로운 키프레임 애니메이터 API로 만들었다.

00:19:11.000 --> 00:19:15.000
키프레임 애니메이터는 여러 속성을 병렬로 애니메이션화할 수 있게 해준다.

00:19:15.000 --> 00:19:23.000
나는 애니메이터에게 애니메이션 가능한 속성과 동일 상태를 포함하는 값을 준다.

00:19:23.000 --> 00:19:26.000
상태 변경은 내 애니메이션을 트리거한다.

00:19:26.000 --> 00:19:34.000
첫 번째 폐쇄에서, 나는 내 로고의 수직 오프셋과 같은 애니메이션 속성에 의해 수정된 뷰를 구축한다.

00:19:34.000 --> 00:19:38.000
두 번째 폐쇄에서, 나는 이러한 속성들이 시간이 지남에 따라 어떻게 변하는지 정의한다.

00:19:38.000 --> 00:19:44.000
예를 들어, 첫 번째 트랙은 내 verticalTranslation 속성의 애니메이션을 정의한다.

00:19:44.000 --> 00:19:50.000
나는 봄 애니메이션을 사용하여 1분기에 내 로고를 30포인트 낮춘다.

00:19:50.000 --> 00:19:54.000
그런 다음 나는 입방 곡선을 사용하여 비글을 도약하고 착륙시킨다.

00:19:54.000 --> 00:19:59.000
마지막으로, 나는 자연스러운 봄 애니메이션으로 이 개를 집으로 데려온다.

00:19:59.000 --> 00:20:03.000
나는 다른 애니메이션 속성에 대한 추가 트랙을 정의한다.

00:20:03.000 --> 00:20:08.000
이 모든 트랙은 이 멋진 애니메이션을 만들기 위해 병렬로 실행된다.

00:20:08.000 --> 00:20:16.000
앱에서 키프레임 애니메이터를 활용하는 방법을 배우려면, "SwiftUI에서 고급 애니메이션을 통해 당신의 길을 따라가세요"를 확인하세요.

00:20:16.000 --> 00:20:21.000
나는 또한 달리고 있을 때 개 목격을 기록하기 위해 Apple Watch 앱을 개발하고 있다.

00:20:21.000 --> 00:20:26.000
지금까지는 꽤 간단하며, 우리의 행복한 아이콘과 목격을 등록할 수 있는 버튼입니다.

00:20:26.000 --> 00:20:29.000
버튼을 탭할 때 이 아이콘을 애니메이션화하고 싶습니다.

00:20:29.000 --> 00:20:33.000
이곳은 위상 애니메이터에게 좋은 장소이다.

00:20:33.000 --> 00:20:36.000
위상 애니메이터는 키프레임 애니메이터보다 간단하다.

00:20:36.000 --> 00:20:41.000
평행 트랙 대신, 그것은 단일 단계의 단계를 밟는다.

00:20:41.000 --> 00:20:46.000
이것은 이전 애니메이션이 끝나면 하나의 애니메이션을 시작할 수 있게 해준다.

00:20:46.000 --> 00:20:52.000
나는 애니메이터에게 일련의 단계를 주고 내 목격 횟수가 바뀔 때마다 애니메이션을 실행하라고 말한다.

00:20:52.000 --> 00:20:59.000
그런 다음 이 첫 번째 폐쇄에서, 나는 현재 단계에 따라 행복한 개의 회전과 규모를 설정했다.

00:20:59.000 --> 00:21:05.000
두 번째 폐쇄는 SwiftUI에게 각 단계로 움직이는 방법을 알려줍니다.

00:21:05.000 --> 00:21:07.000
나는 여기서 멋진 새 봄 애니메이션을 사용하고 있어.

00:21:07.000 --> 00:21:10.000
난 그냥 이 이름들이 좋아.

00:21:10.000 --> 00:21:14.000
쾌활하거나 탄력 있는 애니메이션을 원하지 않는 사람은 누구입니까?

00:21:14.000 --> 00:21:18.000
그리고 내 성장 단계를 위해, 나는 완전히 맞춤형 스프링을 사용하고 있다.

00:21:18.000 --> 00:21:23.000
스프링은 이제 지속되고 튕겨서 더 쉽게 설명할 수 있다.

00:21:23.000 --> 00:21:28.000
SwiftUI 애니메이션을 사용하는 모든 곳에서 이 모든 새로운 스프링을 사용할 수 있습니다.

00:21:28.000 --> 00:21:31.000
봄 애니메이션은 멋지고 자연스러운 느낌을 준다.

00:21:31.000 --> 00:21:37.000
그들은 이전 애니메이션의 속도와 일치하고 현실적인 마찰로 최종 가치에 정착한다.

00:21:37.000 --> 00:21:44.000
그것들은 이제 iOS 17과 정렬된 릴리스에서 또는 그 이후에 구축된 앱의 기본 애니메이션입니다.

00:21:44.000 --> 00:21:50.000
나는 지금 내 애니메이션에 만족하지만, 내가 달리고 있을 때, 햅틱 피드백을 받는 것도 좋을 것이다.

00:21:50.000 --> 00:21:58.000
햅틱 피드백은 주의를 끌고 행동과 사건을 강화하기 위해 탭과 같은 촉각 반응을 제공한다.

00:21:58.000 --> 00:22:03.000
손목을 두드리면 내가 개를 놓치지 않았다는 자신감을 더 얻을 수 있을 것 같아.

00:22:03.000 --> 00:22:07.000
햅틱 피드백은 새로운 감각 피드백 API로 쉽다.

00:22:07.000 --> 00:22:16.000
햅틱 피드백을 재생하기 위해, 저는 감각 피드백 수정자를 첨부하고, 어떤 종류의 피드백을 원하는지 그리고 언제 일어나야 하는지 지정합니다.

00:22:16.000 --> 00:22:21.000
sensoryFeedback 수정자는 햅틱 피드백을 지원하는 모든 플랫폼에서 작동합니다.

00:22:21.000 --> 00:22:30.000
다른 플랫폼은 다른 종류의 피드백을 지원하므로, 휴먼 인터페이스 지침을 확인하여 앱에서 어떤 종류의 피드백이 가장 좋을지 알아보세요.

00:22:30.000 --> 00:22:37.000
나는 또한 새로운 시각 효과 수정자를 사용하여 환영 화면의 애니메이션을 작업하고 있다.

00:22:37.000 --> 00:22:42.000
시각 효과 수정자를 사용하면 위치에 따라 이 개 사진을 업데이트할 수 있습니다.

00:22:42.000 --> 00:22:45.000
그리고 나는 그것을 하기 위해 GeometryReader가 필요하지 않다.

00:22:45.000 --> 00:22:49.000
나는 화면 주위의 초점을 움직이는 작은 시뮬레이션을 가지고 있다.

00:22:49.000 --> 00:22:53.000
이 빨간 점은 내가 초점이 무엇을 의미하는지 보여준다.

00:22:53.000 --> 00:22:58.000
나는 모든 개를 보여주는 이 격자와 좌표 공간을 연관시킨다.

00:22:58.000 --> 00:23:03.000
그런 다음 내 DogCircle 보기 안에, 나는 시각 효과를 추가한다.

00:23:03.000 --> 00:23:07.000
클로저는 내 콘텐츠를 수정하고 지오메트리 프록시를 만든다.

00:23:07.000 --> 00:23:11.000
나는 스케일을 계산하기 위해 지오메트리 프록시를 도우미 방법으로 전달하고 있다.

00:23:11.000 --> 00:23:21.000
기하학 프록시를 사용하여 그리드 뷰의 크기와 그리드 뷰에 대한 단일 개 원의 프레임을 얻을 수 있습니다.

00:23:21.000 --> 00:23:28.000
그것은 내가 어떤 개가 시뮬레이션의 초점에서 얼마나 멀리 떨어져 있는지 계산할 수 있게 해준다, 그래서 나는 집중된 도그고를 확장할 수 있다.

00:23:28.000 --> 00:23:33.000
시각 효과로, 나는 GeometryReader를 사용하지 않고도 이 모든 것을 할 수 있다.

00:23:33.000 --> 00:23:38.000
그리고 그것은 자동으로 다른 크기에 적응한다.

00:23:38.000 --> 00:23:41.000
한 가지 예를 더 공유하고 싶습니다.

00:23:41.000 --> 00:23:46.000
나는 내가 만난 개들에게 좋은 개 메시지를 보내는 기능을 가지고 놀고 있다.

00:23:46.000 --> 00:23:51.000
나는 개를 돋보이게 하기 위해 개 이름을 스타일링하는 것이 재미있을 것이라고 생각했다.

00:23:51.000 --> 00:23:58.000
이제 다른 텍스트 보기에서 바로 전경 스타일로 텍스트를 보간할 수 있기 때문에 이것은 쉽습니다.

00:23:58.000 --> 00:23:59.000
그리고 확인해 봐!

00:23:59.000 --> 00:24:04.000
이 슬라이더를 사용하여 스타일링을 조정할 수 있습니다.

00:24:04.000 --> 00:24:06.000
이제 그게 어떻게 작동해?

00:24:06.000 --> 00:24:08.000
제가 스타일을 정의하는 방법은 다음과 같습니다.

00:24:08.000 --> 00:24:17.000
나는 내 자산 카탈로그의 색상과 함께 스트라이프 간격과 각도를 사용자 지정 금속 셰이더로 전달하고 있다.

00:24:17.000 --> 00:24:31.000
SwiftUI의 새로운 ShaderLibrary를 사용하여, 저는 Metal 셰이더 기능을 Furdinand의 이름으로 줄무늬를 렌더링하는 것과 같은 SwiftUI 모양 스타일로 직접 바꿀 수 있습니다.

00:24:31.000 --> 00:24:41.000
스핀을 위해 메탈 셰이더를 꺼내고 싶다면, 프로젝트에 새 메탈 파일을 추가하고 SwiftUI의 ShaderLibrary를 사용하여 셰이더 함수를 호출하세요.

00:24:41.000 --> 00:24:44.000
이 예시에서 내가 지적하고 싶은 또 다른 것이 있다.

00:24:44.000 --> 00:24:51.000
슬라이더에서 트랙의 끝을 눌렀을 때, 그 기호는 이 만족스러운 바운스를 준다.

00:24:51.000 --> 00:24:55.000
그 효과는 macOS와 iOS의 슬라이더에 내장되어 있다.

00:24:55.000 --> 00:25:01.000
새로운 기호 효과 수정자로 자신의 기호에 추가할 수도 있습니다.

00:25:01.000 --> 00:25:07.000
이 수정자를 적용하여 SF 기호 또는 뷰 계층 구조의 모든 기호를 애니메이션화하세요.

00:25:07.000 --> 00:25:15.000
기호는 펄스와 다양한 색상의 연속 애니메이션을 포함하여 다양한 효과를 지원합니다.

00:25:15.000 --> 00:25:25.000
상태는 스케일로 변경되고, 나타나고 사라지고, 교체하고, 이벤트 알림은 바운스로 바운스합니다.

00:25:25.000 --> 00:25:33.000
"앱에서 기호 애니메이션"을 시청하여 기호 효과를 사용하기 위한 최고의 사람들을 기쁘게 하는 관행에 대해 알아보세요.

00:25:33.000 --> 00:25:37.000
이 예시를 떠나기 전에, 나는 마지막 특징을 지적하고 싶다.

00:25:37.000 --> 00:25:40.000
여기 텍스트의 단위에 주목하세요.

00:25:40.000 --> 00:25:51.000
과거에는 이 효과를 위해 작은 대문자를 사용했을 수도 있지만, 이제는 새로운 textScale 수정자를 내 장치에 적용하여 이 모양을 얻을 수 있다.

00:25:51.000 --> 00:26:01.000
제프와 내가 우리의 앱을 중국 시장에 가져오면, 작은 모자의 개념이 중국어 타이포그래피의 일부가 아니더라도, 단위의 크기가 정확할 것이다.

00:26:01.000 --> 00:26:05.000
우리는 앱이 여러 로케일에서 잘 작동하도록 돕는 또 다른 도구가 있습니다.

00:26:05.000 --> 00:26:09.000
태국어와 같은 일부 언어는 더 큰 문자 형식을 사용한다.

00:26:09.000 --> 00:26:22.000
이러한 언어 중 하나의 텍스트가 영어와 같이 더 짧은 문자 형태의 언어로 현지화된 텍스트에 포함될 때, 더 큰 텍스트는 붐비거나 잘릴 수 있다.

00:26:22.000 --> 00:26:32.000
이것이 문제가 될 수 있다는 것을 알 때 - 예를 들어, 우리의 개 이름이 전 세계적으로 크라우드 소싱된 경우 - 우리는 조판 언어 수정자를 적용할 수 있습니다.

00:26:32.000 --> 00:26:37.000
이것은 SwiftUI가 텍스트에 더 많은 공간이 필요할 수 있다는 것을 알려준다.

00:26:37.000 --> 00:26:46.000
나는 이 새로운 API를 사용하는 것이 너무 재미있지만, 압도적인 사람들을 피하기 위해 애니메이션을 세련되게 선택하는 것이 중요하다.

00:26:46.000 --> 00:26:52.000
SwiftUI 애니메이션의 기본에 대해 알아보려면, "SwiftUI 애니메이션 탐색"을 확인하세요.

00:26:52.000 --> 00:27:01.000
그런 다음 "스프링으로 애니메이션"에서 제이콥은 모든 사람의 장치에서 집처럼 느껴지는 애니메이션을 만드는 데 도움을 줄 것입니다.

00:27:01.000 --> 00:27:05.000
SwiftUI의 새로운 애니메이션 API의 폭은 놀랍다.

00:27:05.000 --> 00:27:07.000
난 여기서 표면만 긁었어.

00:27:07.000 --> 00:27:14.000
애니메이션 완성 핸들러부터 완전히 사용자 지정 애니메이션을 만드는 것까지, 더 많은 것을 발견할 수 있습니다.

00:27:14.000 --> 00:27:18.000
나는 네가 나만큼 이 API를 즐기길 바라.

00:27:18.000 --> 00:27:23.000
제프: 저는 이 모든 새로운 애니메이션과 효과가 우리 앱에 생명을 불어넣는 방법을 좋아합니다.

00:27:23.000 --> 00:27:28.000
이제, 마지막 손질을 위한 새로운 상호 작용 API를 살펴봅시다.

00:27:28.000 --> 00:27:38.000
상호 작용은 훌륭한 앱 경험의 핵심이며, 이것들은 iOS 17과 정렬된 릴리스에 출시되는 업데이트된 API 중 일부에 불과합니다.

00:27:38.000 --> 00:27:45.000
최근에 만난 개들의 내 화면은 마지막 약간의 광택을 주기 위해 약간의 여분의 감각을 사용할 수 있다.

00:27:45.000 --> 00:27:53.000
내 스크롤 뷰의 보이는 영역 안팎으로 전환할 때 내 개 카드에 몇 가지 시각 효과를 추가하고 싶습니다.

00:27:53.000 --> 00:28:00.000
스크롤 전환 수정자는 이전에 환영 화면에 사용된 시각 효과 수정자 Curt와 매우 유사합니다.

00:28:00.000 --> 00:28:04.000
스크롤 보기의 항목에 효과를 적용할 수 있습니다.

00:28:04.000 --> 00:28:13.000
스케일과 불투명도 효과를 사용하면 몇 줄의 추가 코드만으로 내가 원했던 약간의 광택을 얻을 수 있었다.

00:28:13.000 --> 00:28:18.000
나는 또한 내가 가장 좋아하는 개 공원의 횡스크롤 목록을 이 화면에 추가하고 싶다.

00:28:18.000 --> 00:28:22.000
SwiftUI는 내가 이것을 만들 수 있도록 몇 가지 훌륭한 기능을 추가했다.

00:28:22.000 --> 00:28:27.000
내 수직 개 더미 위에, 나는 공원 카드를 위해 수평 더미를 떨어뜨릴 것이다.

00:28:27.000 --> 00:28:38.000
저는 새로운 containerRelativeFrame 수정자를 사용하여 수평 스크롤 뷰의 보이는 크기에 비해 이 공원 카드의 크기를 조정하고 있습니다.

00:28:38.000 --> 00:28:42.000
카운트는 화면을 나눌 청크의 수를 지정합니다.

00:28:42.000 --> 00:28:47.000
스팬은 각 보기가 얼마나 많은 덩어리를 취해야 하는지를 말한다.

00:28:47.000 --> 00:28:52.000
이건 꽤 멋지지만, 내 공원 카드가 제자리에 들어갔으면 좋겠어.

00:28:52.000 --> 00:28:56.000
새로운 scrollTargetLayout 수정자는 그것을 쉽게 만든다.

00:28:56.000 --> 00:29:03.000
나는 그것을 LazyHStack에 추가하고 대상 레이아웃의 보기에 정렬하도록 스크롤 뷰를 수정할 것이다.

00:29:03.000 --> 00:29:08.000
보기 정렬 외에도, 스크롤 뷰는 페이징 동작을 사용하도록 정의할 수도 있습니다.

00:29:08.000 --> 00:29:15.000
그리고 진정한 사용자 지정 경험을 위해, scrollTargetBehavior 프로토콜을 사용하여 자신의 행동을 정의할 수 있습니다.

00:29:15.000 --> 00:29:20.000
나는 또한 내 머트가 스크롤 뷰의 맨 위에 있을 때 약간의 찬사를 받을 자격이 있다고 생각했다.

00:29:20.000 --> 00:29:28.000
새로운 scrollPosition 수정자는 최상위 항목의 ID에 바인딩되며, 스크롤할 때 업데이트됩니다.

00:29:28.000 --> 00:29:31.000
이렇게 하면, 나는 항상 누가 최고의 개인지 안다.

00:29:31.000 --> 00:29:39.000
이 모든 것과 스크롤 뷰의 다른 큰 개선 사항에 대해 자세히 알아보려면, "스크롤 뷰를 넘어서"를 시청하세요.

00:29:39.000 --> 00:29:44.000
이미지는 이제 높은 다이내믹 레인지의 콘텐츠 렌더링을 지원합니다.

00:29:44.000 --> 00:29:53.000
allowedDynamicRange 수정자를 적용함으로써, 우리 앱의 갤러리 화면의 아름다운 이미지를 완전한 충실도로 보여줄 수 있습니다.

00:29:53.000 --> 00:29:58.000
하지만, 이것을 드물게 사용하는 것이 가장 좋으며, 보통 이미지가 혼자 서 있을 때 사용하는 것이 가장 좋습니다.

00:29:58.000 --> 00:30:09.000
SwiftUI로 작성된 앱은 즉시 접근성 기능과 함께 잘 작동하지만, 우리가 도입하는 새로운 접근성 API 중 일부를 사용하면 더 좋게 만들 수 있습니다.

00:30:09.000 --> 00:30:17.000
이 사진의 모험적인 개는 보기에는 너무 멀어서, 확대할 수 있도록 확대 제스처를 적용했습니다.

00:30:17.000 --> 00:30:21.000
나는 또한 내 보기에 새로운 접근성 줌액션 수정자를 추가할 것이다.

00:30:21.000 --> 00:30:29.000
이것은 VoiceOver와 같은 보조 기술이 제스처를 사용하지 않고도 동일한 기능에 접근할 수 있게 해준다.

00:30:29.000 --> 00:30:36.000
나는 행동의 방향에 따라 줌 레벨을 업데이트할 것이고, 그녀가 지금까지 어떤 장난을 했는지 볼 수 있다.

00:30:36.000 --> 00:30:40.000
VoiceOver: 이미지 보기 확대/축소. 이미지.

00:30:40.000 --> 00:30:50.000
제프: Apple 플랫폼의 모든 새로운 접근성 기능에 대해 자세히 알아보려면, "SwiftUI와 UIKit으로 접근 가능한 앱 구축"을 확인하세요.

00:30:50.000 --> 00:30:58.000
색상은 이제 정적 멤버 구문을 사용하여 앱의 자산 카탈로그에 정의된 사용자 지정 색상을 찾는 것을 지원합니다.

00:30:58.000 --> 00:31:04.000
이것은 그것들을 사용할 때 컴파일 타임 안전을 제공하므로, 오타에 시간을 낭비하지 않을 것입니다.

00:31:04.000 --> 00:31:10.000
앞서 보여준 문서 앱의 경우, 도구 모음에 몇 가지 유용한 작업이 포함된 메뉴를 추가했습니다.

00:31:10.000 --> 00:31:21.000
메뉴의 상단 섹션은 항목을 수평 스택의 아이콘으로 보여주는 새로운 compactMenu 스타일의 ControlGroup입니다.

00:31:21.000 --> 00:31:26.000
태그 색상 선택기는 새로운 팔레트 스타일의 피커로 정의됩니다.

00:31:26.000 --> 00:31:37.000
기호 이미지와 함께 이 스타일을 사용하면 메뉴, 특히 라벨의 색조를 사용하여 차별화할 수 있는 메뉴에 훌륭한 시각적 표현을 제공합니다.

00:31:37.000 --> 00:31:45.000
마지막으로, paletteSelectionEffect 수정자를 사용하면 기호 변형을 사용하여 피커에서 선택한 항목을 나타낼 수 있습니다.

00:31:45.000 --> 00:31:52.000
내 메뉴가 제자리에 있으면, 버디의 도그 태그는 이제 그가 가장 좋아하는 색인 테니스 볼 노란색이 될 수 있다.

00:31:52.000 --> 00:31:59.000
테두리 버튼은 이제 원과 둥근 직사각형과 같은 새로운 내장 모양으로 정의할 수 있습니다.

00:31:59.000 --> 00:32:04.000
이 새로운 테두리 모양 스타일은 iOS, watchOS 및 macOS에서 작동합니다.

00:32:04.000 --> 00:32:11.000
macOS와 iOS의 버튼은 이제 팝오버를 여는 편집기의 이 버튼과 같은 드래그 동작에 반응할 수 있습니다.

00:32:11.000 --> 00:32:23.000
새로운 springLoadingBehavior 수정자는 드래그가 일시 중지되거나 macOS에서 강제로 클릭할 때 버튼이 동작을 트리거해야 함을 나타냅니다.

00:32:23.000 --> 00:32:27.000
tvOS의 버튼은 새로운 하이라이트 호버 효과를 잘 활용할 수 있다.

00:32:27.000 --> 00:32:37.000
나는 그것을 갤러리 이미지에 사용하고 내 버튼 라벨의 이미지 부분에 적용하여 플랫폼에서 집처럼 느껴지는 효과를 만들었다.

00:32:37.000 --> 00:32:42.000
이 버튼들은 또한 현재 tvOS에서 사용할 수 있는 테두리 없는 스타일을 사용합니다.

00:32:42.000 --> 00:32:49.000
하드웨어 키보드는 앱의 일반적인 상호 작용에 대한 가속을 제공하는 데 좋습니다.

00:32:49.000 --> 00:32:57.000
하드웨어 키보드를 지원하는 플랫폼의 집중 가능한 보기는 onKeyPress 수정자를 사용하여 키보드 입력에 직접 반응할 수 있습니다.

00:32:57.000 --> 00:33:03.000
수정자는 일치시킬 키 세트와 이벤트에 대해 수행할 작업을 취한다.

00:33:03.000 --> 00:33:10.000
초점 관련 레시피를 채우려면, "집중을 위한 SwiftUI 요리책"을 꼭 보세요.

00:33:10.000 --> 00:33:21.000
스크롤 전환 및 동작에서 버튼 스타일 및 초점 상호 작용에 이르기까지, 이 새로운 API는 풍부한 기능과 뛰어난 스타일을 갖춘 앱을 구축하는 데 도움이 될 수 있습니다.

00:33:21.000 --> 00:33:24.000
커트: 나는 우리가 우리 앱에서 큰 진전을 이루었다고 생각해!

00:33:24.000 --> 00:33:26.000
제프: 그건 확실히 무언가야.

00:33:26.000 --> 00:33:28.000
커트: 이 모든 새로운 API를 사용하는 것은 재미있었다.

00:33:28.000 --> 00:33:30.000
제프: 그건 사실이야.

00:33:30.000 --> 00:33:32.000
커트: SwiftUI에게는 신나는 시간이다.

00:33:32.000 --> 00:33:34.000
새로운 플랫폼이 있어!

00:33:34.000 --> 00:33:38.000
Jeff: 그리고 Observable과 SwiftData의 우아함은 SwiftUI와 매우 잘 작동합니다.

00:33:38.000 --> 00:33:41.000
커트: 애니메이션 개선은 놀랍다.

00:33:41.000 --> 00:33:43.000
제프: 그리고 스크롤 뷰를 잊지 마세요!

00:33:43.000 --> 00:33:49.000
커트: 우리의 놀라운 개발자 커뮤니티가 이 새로운 API로 무엇을 할 수 있는지 보는 것은 항상 스릴입니다.

00:33:49.000 --> 00:33:51.000
제프: 시청해 주셔서 감사합니다, 여러분.

00:33:51.000 --> 00:33:52.000
네 개한테 안부 전해줘!

00:33:52.000 --> 00:33:55.000
커트: 계속 잘 해!

00:33:55.000 --> 23:59:59.000
♪

