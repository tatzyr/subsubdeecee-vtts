WEBVTT

00:00:10.000 --> 00:00:12.000
줄리아: 안녕! 제 이름은 줄리아입니다.

00:00:12.000 --> 00:00:14.000
저는 SwiftUI 엔지니어입니다.

00:00:14.000 --> 00:00:20.000
최근에, 우리는 Swift에서 모델 레이어를 유지하는 새로운 방법인 SwiftData를 도입했습니다.

00:00:20.000 --> 00:00:33.000
오늘 세션에서 SwiftUI 앱에 SwiftData를 원활하게 통합하는 방법을 살펴보겠습니다. 우리는 SwiftData 모델과의 원활한 통합을 가능하게 하는 새로운 SwiftUI 기능에 대해 논의할 것입니다.

00:00:33.000 --> 00:00:38.000
기본 사항을 다루려면, 아직 하지 않았다면 "SwiftData 만나기" 세션을 먼저 보세요.

00:00:38.000 --> 00:00:44.000
SwiftData와 SwiftUI가 어떻게 함께 플레이하는지 보려면, 플래시카드 앱을 만들어 봅시다.

00:00:44.000 --> 00:00:53.000
한동안, 나는 위대한 발명품의 날짜와 저자를 기억하는 데 도움이 될 수 있는 도구를 만들고 싶었고, SwiftData는 이 작업에 완벽하다.

00:00:53.000 --> 00:01:00.000
플래시카드 덱을 유지하는 데 도움이 될 것이므로, 시간이 날 때마다 열고 클릭할 수 있습니다.

00:01:00.000 --> 00:01:08.000
저는 이 앱이 모든 곳에서 작동하기를 원합니다: Mac, iPhone, Watch 및 TV, 그리고 SwiftData가 제 를 지지합니다.

00:01:08.000 --> 00:01:12.000
그것은 모든 플랫폼에서 사용할 수 있다.

00:01:12.000 --> 00:01:14.000
이건 코드와 함께야.

00:01:14.000 --> 00:01:17.000
이 세션 동안, 저는 당신과 함께 앱을 만들 것입니다.

00:01:17.000 --> 00:01:26.000
지금 일시 정지를 누르고, 컴패니언 Xcode 프로젝트를 다운로드하세요: 준비된 시작점과 완성된 아카이브.

00:01:26.000 --> 00:01:31.000
스타터 프로젝트를 열고, ContentView 파일로 가세요.

00:01:31.000 --> 00:01:38.000
이 세션을 통해, 우리는 Mac용 임베디드 인터랙티브 라이브 미리보기인 새로운 Xcode 기능을 활용할 것입니다.

00:01:38.000 --> 00:01:43.000
미리보기 섹션에는 플래시 카드가 있는 그리드가 있습니다.

00:01:43.000 --> 00:01:50.000
카드를 클릭하면 카드를 하나씩 스크롤할 수 있는 보기로 전환됩니다.

00:01:50.000 --> 00:01:53.000
누가 컴파일러를 발명했는지 기억해?

00:01:53.000 --> 00:01:57.000
카드를 클릭하세요. 그것은 뒤집히고 답을 준다!

00:01:57.000 --> 00:02:06.000
앱은 메모리에 저장된 샘플 카드로 채워져 있으며, 앱을 실행하고 새 카드를 추가하면 앱을 닫으면 사라집니다.

00:02:06.000 --> 00:02:09.000
여기가 SwiftData가 들어오는 곳이다.

00:02:09.000 --> 00:02:13.000
우리는 우리가 만든 플래시카드를 유지하기 위해 그것을 사용할 것이다.

00:02:13.000 --> 00:02:24.000
오늘, 우리는 SwiftData를 사용하기 위해 알아야 할 모든 것에 대해 이야기할 것이며, 내가 우리를 위해 준비한 이 할 일 목록에서 한 항목을 차례로 체크할 것입니다.

00:02:24.000 --> 00:02:27.000
당신은 방금 우리가 만들 앱을 만났습니다.

00:02:27.000 --> 00:02:32.000
다음으로, 우리는 스타터 프로젝트와 모델 클래스를 살펴볼 것이다.

00:02:32.000 --> 00:02:40.000
그런 다음, 단계별로 SwiftData를 저장소로 사용하기 위해 변환하고 수정할 것입니다.

00:02:40.000 --> 00:02:56.000
우리는 모델 클래스를 확장하여 SwiftData 모델이 되는 방법, 데이터를 쿼리하고 모델 레이어의 모든 변경 사항에 대한 뷰를 업데이트하는 방법, 모델을 생성 및 저장하고, UI 요소를 편리하게 바인딩하는 방법을 배울 것입니다.

00:02:56.000 --> 00:03:05.000
그리고 결국, 보너스로, SwiftData가 스토리지를 처리할 때 문서 기반 앱을 만드는 것이 얼마나 쉬운지 알게 될 것입니다.

00:03:05.000 --> 00:03:19.000
스타터 프로젝트에서, 나는 시간을 절약하기 위해 단일 플래시 카드, 일부 뷰 및 지원 파일을 나타내는 카드 모델을 정의했다.

00:03:19.000 --> 00:03:25.000
모든 카드는 앞면과 뒷면의 텍스트와 생성 날짜를 저장합니다.

00:03:25.000 --> 00:03:28.000
그건 꽤 전형적인 모델이야.

00:03:28.000 --> 00:03:33.000
SwiftData가 우리를 위해 저장할 수 있도록 업데이트합시다.

00:03:33.000 --> 00:03:36.000
먼저, SwiftData를 이 파일로 가져오세요.

00:03:36.000 --> 00:03:46.000
그리고 다음으로, 우리가 해야 할 주요 변화는 정의에 @Model 매크로를 추가하는 것이다.

00:03:46.000 --> 00:03:50.000
그리고 이제, 그 수업은 SwiftData로 완전히 지속 가능하다.

00:03:50.000 --> 00:03:53.000
더 이상 타이핑하지 마. 그게 다야!

00:03:53.000 --> 00:04:02.000
그리고 더 많은 것: @Model과 함께, 카드는 Observable 프로토콜에 대한 적합성을 얻고, 우리는 ObservableObject 대신 그것을 사용할 것이다.

00:04:02.000 --> 00:04:11.000
관찰 가능한 객체와 @Published 속성 래퍼에 대한 적합성을 제거하십시오.

00:04:11.000 --> 00:04:21.000
우리는 이전에 ObservedObject 적합성을 사용하여 CardEditorView 파일의 UI에서 직접 카드를 편집했습니다.

00:04:21.000 --> 00:04:28.000
여기서 Observable을 채택하기 위해, 우리는 "ObservedObject" 속성 래퍼를 "Bindable"으로 바꿉니다.

00:04:28.000 --> 00:04:35.000
그것은 텍스트 필드가 카드의 앞면에 직접 바인딩될 수 있게 해준다...

00:04:35.000 --> 00:04:37.000
그리고 답장.

00:04:37.000 --> 00:04:39.000
끝났어!

00:04:39.000 --> 00:04:49.000
새로운 관찰 가능한 매크로와 바인딩 가능한 속성 래퍼를 사용하면 이전보다 훨씬 적은 코드로 애플리케이션에서 데이터 흐름을 쉽게 설정할 수 있습니다.

00:04:49.000 --> 00:04:58.000
뷰가 본문에서 관찰 가능한 유형의 속성을 사용하면, 주어진 속성이 변경될 때 자동으로 업데이트됩니다.

00:04:58.000 --> 00:05:05.000
그리고 모델의 가변 상태를 UI 요소에 바인딩하는 것이 그렇게 쉬운 적이 없었습니다!

00:05:05.000 --> 00:05:13.000
WWDC23 세션인 "SwiftUI로 관찰을 발견하세요"를 시청하는 것이 좋습니다.

00:05:13.000 --> 00:05:20.000
Observable이 SwiftData의 유무에 관계없이 데이터 흐름 코드를 어떻게 단순화하는지 놀랄 것입니다.

00:05:20.000 --> 00:05:25.000
그리고 그게 네가 모델에 대해 알아야 할 전부야.

00:05:25.000 --> 00:05:28.000
더 이상은 없어. 그거 얼마나 멋져?

00:05:28.000 --> 00:05:37.000
다음으로, SwiftData에서 모델을 쿼리하고 UI에 표시하려면 ContentView로 전환합시다.

00:05:37.000 --> 00:05:48.000
SampleDeck.contents 대신, 우리는 SwiftData가 가지고 있는 카드를 표시할 것이다.

00:05:48.000 --> 00:06:00.000
그리고 카드 배열을 SwiftData 저장소에 바인딩하기 위해 해야 할 한 가지 변경 사항이 있습니다: @State 속성 래퍼를 @Query로 바꾸세요.

00:06:00.000 --> 00:06:02.000
그게 다야!

00:06:02.000 --> 00:06:09.000
미리보기에서 볼 수 있듯이, 더 이상 표시할 카드가 없습니다. 아마도 우리가 아무것도 저장하지 않았기 때문일 것입니다.

00:06:09.000 --> 00:06:17.000
SwiftData가 관리하는 모델을 UI에 표시하고 싶을 때마다 @Query를 사용하세요.

00:06:17.000 --> 00:06:22.000
@Query는 SwiftData에서 모델을 쿼리하는 새로운 속성 래퍼입니다.

00:06:22.000 --> 00:06:30.000
그것은 또한 @State가 어떻게 하는지와 마찬가지로 모델의 모든 변화에 대해 업데이트된 뷰를 트리거합니다.

00:06:30.000 --> 00:06:35.000
모든 뷰는 필요한 만큼 많은 쿼리된 속성을 가질 수 있다.

00:06:35.000 --> 00:06:44.000
쿼리는 정렬, 정렬, 필터링 및 심지어 애니메이션 변경 사항을 구성할 수 있는 가벼운 구문을 제공합니다.

00:06:44.000 --> 00:06:50.000
후드 아래에서, 그것은 뷰의 모델 컨텍스트를 데이터 소스로 사용한다.

00:06:50.000 --> 00:06:53.000
@Query에 모델 컨텍스트를 어떻게 제공하나요?

00:06:53.000 --> 00:06:57.000
우리는 모델 컨테이너에서 하나를 얻을 것이다.

00:06:57.000 --> 00:07:04.000
SwiftUI는 뷰의 ModelContainer의 편리한 설정을 위해 새로운 뷰와 장면 수정자를 판매합니다.

00:07:04.000 --> 00:07:10.000
SwiftData를 사용하려면, 모든 애플리케이션은 적어도 하나의 ModelContainer를 설정해야 합니다.

00:07:10.000 --> 00:07:17.000
@Query가 사용할 컨텍스트를 포함하여 전체 스토리지 스택을 만듭니다.

00:07:17.000 --> 00:07:27.000
뷰에는 단일 모델 컨테이너가 있지만, 애플리케이션은 다른 뷰 계층에 필요한 만큼의 컨테이너를 만들고 사용할 수 있습니다.

00:07:27.000 --> 00:07:37.000
애플리케이션이 modelContainer를 설정하지 않으면, 창과 생성된 뷰는 SwiftData를 통해 모델을 저장하거나 쿼리할 수 없습니다.

00:07:37.000 --> 00:07:41.000
많은 응용 프로그램에는 단일 모델 컨테이너가 필요하다.

00:07:41.000 --> 00:07:45.000
이 경우, 전체 창 그룹 장면에 대해 설정할 수 있습니다.

00:07:45.000 --> 00:07:53.000
창과 그 보기는 같은 그룹에서 생성된 다른 창뿐만 아니라 컨테이너를 상속받을 것이다.

00:07:53.000 --> 00:07:59.000
이 모든 견해는 하나의 컨테이너에서 쓰고 읽을 것이다.

00:07:59.000 --> 00:08:06.000
일부 앱은 몇 개의 스토리지 스택이 필요하며, 다른 창을 위해 여러 모델 컨테이너를 설정할 수 있습니다.

00:08:06.000 --> 00:08:11.000
SwiftUI는 또한 보기 수준에서 세분화된 설정을 허용합니다.

00:08:11.000 --> 00:08:19.000
같은 창의 다른 보기는 별도의 컨테이너를 가질 수 있으며, 한 컨테이너에 저장하는 것은 다른 컨테이너에 영향을 미치지 않습니다.

00:08:19.000 --> 00:08:24.000
이제, 쿼리에 데이터 소스를 제공하기 위해 modelContainer를 설정해 봅시다.

00:08:24.000 --> 00:08:33.000
나는 앱 정의를 열어...

00:08:33.000 --> 00:08:37.000
그리고 앱 윈도우를 위한 모델 컨테이너를 설정하세요.

00:08:37.000 --> 00:08:47.000
하위 뷰는 뷰 수정자에 나열된 모델 유형만 생성, 읽기, 업데이트 및 삭제할 수 있습니다.

00:08:47.000 --> 00:08:50.000
그리고 우리는 설정을 끝냈어!

00:08:50.000 --> 00:08:56.000
하지만, 저는 한 걸음 더 나아가고 싶습니다: 샘플 데이터로 미리보기를 제공하세요.

00:08:56.000 --> 00:09:01.000
앱에서, 나는 샘플 카드로 인메모리 컨테이너를 정의했다.

00:09:01.000 --> 00:09:08.000
"PreviewSampleData" 파일을 열고 대상에 포함시켜 봅시다.

00:09:08.000 --> 00:09:12.000
이 파일에는 샘플 데이터가 있는 컨테이너의 정의가 포함되어 있습니다.

00:09:12.000 --> 00:09:18.000
나는 샘플 카드로 미리보기를 채우기 위해 ContentView에서 그것을 사용할 것이다.

00:09:18.000 --> 00:09:33.000
이제 @Query에 데이터 소스가 있기 때문에, 미리보기는 카드를 표시합니다!

00:09:33.000 --> 00:09:41.000
그리고 이것은 SwiftData 스택을 준비하고 미리보기를 생성하는 데 필요한 모든 설정입니다.

00:09:41.000 --> 00:09:50.000
다음으로, 저는 SwiftData가 제가 만든 새 카드와 기존 카드에 대한 변경 사항을 추적하고 저장하도록 하고 싶습니다.

00:09:50.000 --> 00:09:55.000
그렇게 하기 위해, 나는 뷰의 모델 컨텍스트를 사용할 것이다.

00:09:55.000 --> 00:10:01.000
모델 컨텍스트에 접근하기 위해, SwiftUI는 새로운 환경 변수를 제공한다.

00:10:01.000 --> 00:10:11.000
모델 컨테이너와 마찬가지로, 각 뷰는 단일 컨텍스트를 가지고 있지만, 일반적으로 애플리케이션은 필요한 만큼 가질 수 있다.

00:10:11.000 --> 00:10:14.000
우리 앱에서, 컨텍스트는 이미 구성되어 있다.

00:10:14.000 --> 00:10:21.000
이 환경 변수는 이전에 모델 컨테이너를 설정할 때 자동으로 채워졌다.

00:10:21.000 --> 00:10:24.000
Xcode로 다시 전환합시다.

00:10:24.000 --> 00:10:33.000
우리는 카드를 저장하고 업데이트하기 위해 modelContext에 접근해야 할 것이다.

00:10:33.000 --> 00:11:03.000
우리는 SwiftData가 우리가 저장하고 싶은 모델을 인식할 수 있도록 모델 컨텍스트에 새로 생성된 카드를 삽입합니다.

00:11:03.000 --> 00:11:13.000
모델을 삽입한 후 "modelContext.save()"를 호출하여 컨텍스트를 저장해야 한다고 생각할 수도 있지만 그렇게 할 필요는 없습니다.

00:11:13.000 --> 00:11:19.000
SwiftData에 대한 좋은 세부 사항은 모델 컨텍스트를 자동 저장한다는 것이다.

00:11:19.000 --> 00:11:24.000
자동 저장은 UI 관련 이벤트와 사용자 입력에 의해 트리거됩니다.

00:11:24.000 --> 00:11:29.000
SwiftData가 우리를 위해 그것을 하기 때문에 우리는 저축에 대해 걱정할 필요가 없습니다.

00:11:29.000 --> 00:11:40.000
예를 들어, SwiftData 저장소를 공유하거나 전송하기 전에 모든 변경 사항이 즉시 유지되도록 하고 싶은 경우는 몇 가지뿐입니다.

00:11:40.000 --> 00:11:44.000
이러한 경우, "save()"를 명시적으로 호출하세요.

00:11:44.000 --> 00:11:50.000
이제 우리 앱이 카드를 저장하고 쿼리할 수 있으니, 하나 만들어 봅시다!

00:11:50.000 --> 00:11:53.000
나는 그 앱을 실행해...

00:11:53.000 --> 00:11:58.000
그리고 더하기 버튼을 눌러 카드를 만드세요.

00:11:58.000 --> 00:12:04.000
우리가 전에 봤던 컴파일러 카드를 추가해 봅시다.

00:12:04.000 --> 00:12:19.000
이제, 앱을 종료하고, 다시 실행하고, 새 카드가 있는지 봅시다.

00:12:19.000 --> 00:12:21.000
그리고 여기 있어!

00:12:21.000 --> 00:12:26.000
이제 당신은 뷰의 모델 컨텍스트에 접근하고 카드를 추가하는 방법을 알고 있습니다.

00:12:26.000 --> 00:12:28.000
끝났어!

00:12:28.000 --> 00:12:31.000
새 창을 열자.

00:12:31.000 --> 00:12:41.000
두 창 모두 동일한 모델 컨테이너를 사용하고 동일한 데이터에 액세스하기 때문에 첫 번째 덱과 동일한 덱을 표시합니다.

00:12:41.000 --> 00:12:48.000
하지만, 앱이 다른 창에서 다른 플래시 카드 덱을 열 수 있다면 좋을 것이다.

00:12:48.000 --> 00:12:53.000
본질적으로, 그것은 내가 모든 덱을 별도의 문서로 취급하고 싶다는 것을 의미한다.

00:12:53.000 --> 00:12:56.000
그러면, 나는 이 문서들을 친구들과 공유할 수 있다.

00:12:56.000 --> 00:13:03.000
문서 기반 앱은 macOS, iOS 및 iPadOS에서 사용되는 개념입니다.

00:13:03.000 --> 00:13:12.000
사용자가 다양한 유형의 문서를 생성, 열기, 보기 또는 편집할 수 있는 특정 유형의 응용 프로그램을 설명합니다.

00:13:12.000 --> 00:13:18.000
모든 문서는 파일이며, 사용자는 이를 저장, 복사 및 공유할 수 있습니다.

00:13:18.000 --> 00:13:26.000
그리고 SwiftUI가 SwiftData 기반 문서 앱을 지원한다는 것을 알려드리게 되어 기쁩니다.

00:13:26.000 --> 00:13:28.000
이 접근 방식을 시도해 봅시다.

00:13:28.000 --> 00:13:32.000
FlashCardApp 파일을 엽니다.

00:13:32.000 --> 00:13:45.000
문서 기반 앱은 iOS와 macOS에 존재하며, 이러한 플랫폼에서는 DocumentGroup 이니셜라이저를 사용하는 것으로 전환할 것입니다.

00:13:45.000 --> 00:14:13.000
나는 모델 유형 Card.self, 콘텐츠 유형, 그리고 뷰 빌더를 전달할 것이다.

00:14:13.000 --> 00:14:20.000
짧은 우회로를 하고 두 번째 매개 변수인 콘텐츠 유형에 대해 더 자세히 이야기해 봅시다!

00:14:20.000 --> 00:14:25.000
SwiftData 문서 기반 앱은 사용자 지정 콘텐츠 유형을 선언해야 합니다.

00:14:25.000 --> 00:14:32.000
각 SwiftData 문서는 고유한 모델 세트로 구축되므로 디스크에 고유한 표현이 있습니다.

00:14:32.000 --> 00:14:40.000
문서의 맥락에서, 콘텐츠 유형을 JPEG와 같은 이진 파일 형식으로 생각할 수 있습니다.

00:14:40.000 --> 00:14:48.000
또 다른 유형의 문서인 패키지는 Xcode 프로젝트와 같이 디스크에 고정된 구조가 있는 디렉토리이다.

00:14:48.000 --> 00:14:53.000
예를 들어, 모든 JPEG 이미지는 동일한 이진 구조를 가지고 있다.

00:14:53.000 --> 00:14:57.000
그렇지 않으면, 사진 편집자들은 그것들을 읽는 방법을 모를 것이다.

00:14:57.000 --> 00:15:03.000
마찬가지로, 모든 Xcode 프로젝트에는 특정 디렉토리와 파일이 포함되어 있습니다.

00:15:03.000 --> 00:15:12.000
사용자가 덱을 열면, 덱 형식과 파일 확장자를 앱과 연결하려면 운영 체제가 필요합니다.

00:15:12.000 --> 00:15:16.000
그것이 우리가 콘텐츠 유형을 선언해야 하는 이유이다.

00:15:16.000 --> 00:15:29.000
SwiftData 문서는 패키지입니다: SwiftData 모델의 일부 속성을 "externalStorage" 속성으로 표시하면 외부에 저장된 모든 항목이 문서 패키지의 일부가 됩니다.

00:15:29.000 --> 00:15:39.000
UTType+FlashCards 파일에는 새로운 콘텐츠 유형에 대한 정의가 있으므로 코드에서 편리하게 사용할 수 있습니다.

00:15:39.000 --> 00:15:52.000
우리는 Info.plist에 같은 정의를 넣을 것이다.

00:15:52.000 --> 00:15:57.000
우리는 운영 체제에 새로운 콘텐츠 유형을 선언하려고 합니다.

00:15:57.000 --> 00:16:05.000
앱에서 만든 카드 덱을 다른 문서와 구별하기 위해 파일 확장자를 지정해야 합니다.

00:16:05.000 --> 00:16:13.000
이 샘플 앱의 경우, 우리는 "샘플덱"을 확장으로 사용할 것입니다.

00:16:13.000 --> 00:16:24.000
나는 또한 플래시 카드 덱과 같은 짧은 설명을 추가할 것이다.

00:16:24.000 --> 00:16:33.000
식별자는 코드에 있는 것과 정확히 같아야 한다.

00:16:33.000 --> 00:16:46.000
SwiftData 문서는 패키지이기 때문에, 우리는 우리의 유형이 com.apple.package를 준수하는지 확인해야 합니다.

00:16:46.000 --> 00:16:51.000
그리고 이제, 우리가 선언한 콘텐츠 유형을 사용합시다.

00:16:51.000 --> 00:16:59.000
앱 정의로 돌아가서 콘텐츠 유형을 DocumentGroup에 전달하고 있습니다.

00:16:59.000 --> 00:17:06.000
뷰 빌더는 똑같아 보인다.

00:17:06.000 --> 00:17:10.000
특히, 우리는 모델 컨테이너를 설치하지 않는다.

00:17:10.000 --> 00:17:16.000
문서 인프라는 각 문서에 대해 하나씩 설정할 것이다.

00:17:16.000 --> 00:17:23.000
응용 프로그램을 실행하고 지금 어떻게 보이는지 봅시다!

00:17:23.000 --> 00:17:27.000
그 앱은 열린 패널로 실행된다.

00:17:27.000 --> 00:17:31.000
문서 기반 애플리케이션의 표준 동작.

00:17:31.000 --> 00:17:38.000
나는 새 문서를 만들고 거기에 카드를 추가할 것이다.

00:17:38.000 --> 00:17:44.000
그 문서에는 이제 저장되지 않은 변경 사항이 있음을 나타내는 도구 모음 자막이 있습니다.

00:17:44.000 --> 00:17:50.000
Command+S를 누르면 저장 대화 상자가 나타납니다.

00:17:50.000 --> 00:17:57.000
덱은 이전에 Info.plist에 넣은 것과 동일한 파일 확장자로 저장됩니다.

00:17:57.000 --> 00:18:06.000
나는 새로운 덱을 저장할 것이고, 여기 내 첫 번째 플래시카드 덱이 데스크톱에 있다.

00:18:06.000 --> 00:18:14.000
Command+N을 눌러 새 덱을 만들거나 Command+O를 눌러 새 덱을 열 수도 있습니다.

00:18:14.000 --> 00:18:22.000
이러한 단축키와 다른 많은 기능, 문서 기반 응용 프로그램은 자동으로 적용됩니다.

00:18:22.000 --> 00:18:28.000
요약하자면, 오늘, 우리는 SwiftUI 앱에서 SwiftData 스토리지를 사용하는 방법을 배웠습니다.

00:18:28.000 --> 00:18:42.000
우리는 새로운 @Model 매크로, @Query 속성 래퍼 및 모델 컨텍스트에 대한 새로운 환경 변수에 대해 이야기했고, SwiftData를 문서의 저장소로 사용하는 것이 얼마나 쉬운지 보았습니다.

00:18:42.000 --> 00:18:46.000
오늘 나와 함께 해줘서 고마워, 그리고 앱을 재미있게 만들어!

00:18:46.000 --> 23:59:59.000
♪ ♪

