WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:14.000
Si: 안녕하세요, 저는 Apple의 Swift on Server 팀의 Si입니다.

00:00:14.000 --> 00:00:20.000
이 비디오에서는 Swift OpenAPI Generator가 서버 API로 작업하는 데 어떻게 도움이 될 수 있는지 보여드리겠습니다.

00:00:20.000 --> 00:00:29.000
iOS 앱을 확장하든 스위프트에서 백엔드 서버를 작성하든, 이 새로운 스위프트 패키지 플러그인은 워크플로우를 간소화하고 코드베이스를 단순화할 수 있습니다.

00:00:29.000 --> 00:00:34.000
올해, 우리는 장치의 데이터로 작업하는 것이 그 어느 때보다 쉬워지는 것을 보았다.

00:00:34.000 --> 00:00:39.000
하지만 때때로 구현하려는 기능에는 서버 구성 요소가 제공하는 동적 콘텐츠가 필요합니다.

00:00:39.000 --> 00:00:44.000
이것은 API를 호출하여 원격 서비스에 네트워크 요청을 하는 것을 의미합니다.

00:00:44.000 --> 00:00:49.000
하지만 올바른 네트워크 요청을 하기 위해서는 고려해야 할 것이 많다.

00:00:49.000 --> 00:00:52.000
서버의 기본 URL은 무엇인가요?

00:00:52.000 --> 00:00:55.000
API 엔드포인트를 구성하는 경로 구성 요소는 무엇인가요?

00:00:55.000 --> 00:00:58.000
어떤 HTTP 방법을 사용해야 하나요?

00:00:58.000 --> 00:01:01.000
그리고 매개 변수를 어떻게 제공해야 하나요?

00:01:01.000 --> 00:01:05.000
이것들은 서버 API를 호출할 때 고려해야 할 몇 가지 질문일 뿐입니다.

00:01:05.000 --> 00:01:09.000
더 많은 관련 API를 위해, 당신은 훨씬 더 많은 것을 고려해야 할 것입니다.

00:01:09.000 --> 00:01:13.000
그래서 당신은 이 질문들에 어떻게 대답하나요?

00:01:13.000 --> 00:01:16.000
대부분의 서비스에는 어떤 형태의 API 문서가 있다.

00:01:16.000 --> 00:01:24.000
하지만 손으로 쓴 문서는 종종 부정확하거나 구식일 수 있으며, 특히 서비스가 빠르게 진화하고 있는 경우 더욱 그렇습니다.

00:01:24.000 --> 00:01:30.000
소스 코드에 접근할 수 있다면, 구현을 보거나 API로 수동으로 실험할 수 있습니다.

00:01:30.000 --> 00:01:35.000
하지만 이것은 서비스 행동에 대한 불완전한 이해로 이어질 수 있다.

00:01:35.000 --> 00:01:39.000
지원 포럼을 검색하거나 다른 기관 지식에 의존할 수 있습니다.

00:01:39.000 --> 00:01:48.000
하지만 가장 선의의 사람들조차도 정보가 부족하거나 일관성 없는 답변을 제공할 수 있으며, 당신이 시작한 것보다 더 많은 질문을 남길 수 있습니다.

00:01:48.000 --> 00:01:52.000
이 자원들은 약간의 도움을 제공하지만, 완전한 그림은 아니다.

00:01:52.000 --> 00:01:58.000
API에 대한 보다 공식적이고 체계적인 설명을 사용하면 모호함을 제거하는 데 도움이 될 수 있습니다.

00:01:58.000 --> 00:02:04.000
HTTP 서비스를 정의하기 위한 개방형 사양인 OpenAPI를 만나보세요.

00:02:04.000 --> 00:02:14.000
OpenAPI는 업계 표준이며, 광범위한 채택과 성숙도는 API로 작업하는 데 도움이 되는 확립된 규칙과 모범 사례가 있음을 의미합니다.

00:02:14.000 --> 00:02:25.000
OpenAPI를 사용하면 YAML 또는 JSON으로 서비스 동작을 문서화할 수 있으며, 이러한 기계 판독 가능 형식을 사용하면 풍부한 툴링 생태계의 이점을 누릴 수 있습니다.

00:02:25.000 --> 00:02:32.000
테스트 생성, 런타임 검증, 상호 운용성 등을 위한 도구가 있습니다.

00:02:32.000 --> 00:02:38.000
OpenAPI가 특히 잘 알려진 한 가지는 대화형 문서를 생성하는 도구이다.

00:02:38.000 --> 00:02:46.000
하지만 OpenAPI의 핵심 동기는 채택자들이 사양 기반 개발을 사용할 수 있도록 하는 코드 생성이다.

00:02:46.000 --> 00:02:48.000
예시 API 엔드포인트를 기억하시나요?

00:02:48.000 --> 00:02:55.000
음, 이 요청을 받으면, 서버는 JSON 객체에 개인화된 인사말을 반환합니다.

00:02:55.000 --> 00:03:02.000
코드 생성을 사용하지 않고 이 API를 호출하기 위해 작성해야 하는 코드를 살펴봅시다.

00:03:02.000 --> 00:03:07.000
먼저, 우리는 구성 요소로 변환하기 위해 서버의 기본 URL을 알아야 합니다.

00:03:07.000 --> 00:03:14.000
그런 다음 경로 구성 요소를 추가하여 API 엔드포인트를 구성하고 매개 변수를 쿼리 항목으로 지정합니다.

00:03:14.000 --> 00:03:21.000
그런 다음 URLRequest를 만들고 URLSession을 사용하여 HTTP 요청을 합니다.

00:03:21.000 --> 00:03:29.000
그런 다음 예상 유형의 응답에 예상 상태 코드와 콘텐츠 유형이 있는지 확인해야 합니다.

00:03:29.000 --> 00:03:37.000
그런 다음 우리는 응답에서 바이트를 디코딩해야 하며, 이는 Decodable을 준수하는 Swift 유형을 정의하고 JSONDecoder를 사용하여 수행됩니다.

00:03:37.000 --> 00:03:42.000
마지막으로, 우리는 응답에서 메시지 속성을 반환합니다.

00:03:42.000 --> 00:03:47.000
이 코드를 작성하는 것은 괜찮지만, 이것은 사소한 API 작업에 대한 단일 요청일 뿐입니다.

00:03:47.000 --> 00:03:54.000
많은 실제 API에는 풍부한 요청 및 응답 유형, 헤더 필드, 매개 변수 등이 있는 수백 개의 작업이 있습니다.

00:03:54.000 --> 00:04:00.000
모든 작업에 대해 이 코드를 작성하는 것은 반복적이고, 장황하며, 오류가 발생하기 쉽다.

00:04:00.000 --> 00:04:05.000
그리고 코드베이스의 이 모든 의식은 앱의 핵심 논리를 손상시킨다.

00:04:05.000 --> 00:04:12.000
OpenAPI를 사용하면 도구를 사용하여 대부분의 코드를 생성할 수 있으므로 사용자가 상호 작용하는 코드에 집중할 수 있습니다.

00:04:12.000 --> 00:04:17.000
우리는 예제 API를 사용하여 OpenAPI 문서를 탐색할 것입니다.

00:04:17.000 --> 00:04:22.000
모든 OpenAPI 문서는 사용 중인 OpenAPI 사양의 버전을 선언합니다.

00:04:22.000 --> 00:04:29.000
이름과 버전, 서버 URL 목록을 포함하여 API에 대한 메타데이터를 제공합니다.

00:04:29.000 --> 00:04:34.000
그런 다음 API를 구성하는 경로와 HTTP 방법을 나열합니다.

00:04:34.000 --> 00:04:41.000
이 API에는 greet 경로에서 GET 메소드의 동작을 정의하는 getGreeting이라는 하나의 작업만 있습니다.

00:04:41.000 --> 00:04:53.000
이 예에서 서버는 항상 OK의 HTTP 상태 코드인 200으로 응답하고 JSON 스키마를 사용하여 정의된 JSON 객체를 반환합니다.

00:04:53.000 --> 00:05:05.000
이 삽화를 위해, 우리는 그것을 단순하게 유지했지만, 작업은 다른 상태 코드와 콘텐츠 유형으로 여러 응답을 가질 수 있으며, 이를 통해 오류가 있을 때 일어나는 일을 포함하여 모든 시나리오를 문서화할 수 있습니다.

00:05:05.000 --> 00:05:11.000
그리고 작업이 매개 변수를 수락한다면, 이것들은 또한 OpenAPI 문서에 포함될 수 있다.

00:05:11.000 --> 00:05:21.000
이 작업은 인사말을 개인화하는 데 사용되는 문자열 값인 "이름"이라는 선택적 쿼리 매개 변수를 지원합니다.

00:05:21.000 --> 00:05:28.000
Swift OpenAPI Generator의 도움으로, 우리는 훨씬 적은 코드로 동일한 API 호출을 할 수 있습니다.

00:05:28.000 --> 00:05:38.000
우리는 형식에 안전한 입력을 사용할 수 있으며 출력 값은 풍부한 열거형 유형이므로 컴파일러는 모든 문서화된 응답과 콘텐츠 유형을 처리하는 데 도움이 될 수 있습니다.

00:05:38.000 --> 00:05:44.000
그리고 응답 본문의 관련 값은 유형에 안전한 속성을 가진 값 유형이다.

00:05:44.000 --> 00:05:57.000
입력 인코딩, 요청, 응답 구문 분석 및 출력 디코딩과 관련된 모든 의식은 모두 생성된 코드에 의해 처리됩니다.

00:05:57.000 --> 00:06:02.000
Swift OpenAPI Generator는 빌드 시 실행되는 Swift 패키지 플러그인입니다.

00:06:02.000 --> 00:06:09.000
즉, 생성된 코드는 항상 OpenAPI 문서와 동기화되며 소스 저장소에 커밋할 필요가 없습니다.

00:06:09.000 --> 00:06:16.000
스위프트 패키지 플러그인에 대해 자세히 알아보려면, "스위프트 패키지 플러그인 만나기"라는 세션을 확인하세요.

00:06:16.000 --> 00:06:21.000
간단한 iOS 앱에서 Swift OpenAPI Generator를 어떻게 사용할 수 있는지 살펴봅시다.

00:06:21.000 --> 00:06:25.000
이를 위해, 우리는 호출할 수 있는 API가 필요할 것이다.

00:06:25.000 --> 00:06:32.000
이 데모에서, 우리는 10개의 고양이 얼굴 이모티콘 중 하나를 무작위로 반환하는 간단한 API를 호출할 것입니다.

00:06:32.000 --> 00:06:41.000
우리는 템플릿 SwiftUI 앱으로 시작하여 샘플 콘텐츠를 큰 이모티콘과 탭할 때마다 서버에서 새 이모티콘을 가져오는 버튼으로 바꿀 것입니다.

00:06:41.000 --> 00:06:54.000
우리는 이미 로컬 호스트에서 듣고 있는 서버를 운영하고 있으며, 컬을 사용하여 터미널에서 쿼리할 수 있습니다.

00:06:54.000 --> 00:06:56.000
이것이 훌륭한 API라는 것은 부인할 수 없다.

00:06:56.000 --> 00:07:00.000
하지만 그것을 더 좋게 만드는 것은 그것이 OpenAPI를 사용하여 정의된다는 것이다.

00:07:00.000 --> 00:07:08.000
이 서비스에 대한 OpenAPI 문서를 보여주기 위해 매우 다른 종류의 고양이를 사용합시다.

00:07:08.000 --> 00:07:16.000
이 API에는 UI를 업데이트하기 위해 앱에서 호출할 getEmoji라는 단일 작업이 있습니다.

00:07:16.000 --> 00:07:20.000
시작하기 위해, 우리는 Xcode로 전환할 것이다.

00:07:20.000 --> 00:07:27.000
이 샘플 iOS 앱에는 SwiftUI를 사용하여 정의된 기본 UI가 있으며, Xcode 미리보기에서 볼 수 있습니다.

00:07:27.000 --> 00:07:33.000
앞으로 몇 분 안에, 우리는 UI 구성 요소를 서버에서 가져올 동적 콘텐츠로 대체할 것입니다.

00:07:33.000 --> 00:07:41.000
그리고 우리는 Swift OpenAPI Generator를 사용하여 API 호출을 하기 위해 손으로 작성해야 하는 코드를 단순화할 것입니다.

00:07:41.000 --> 00:07:45.000
우리는 프로젝트에 필요한 패키지 종속성을 추가하는 것으로 시작할 것입니다.

00:07:45.000 --> 00:07:54.000
그런 다음 코드 생성을 위해 플러그인을 사용하도록 대상을 구성하고 OpenAPI 문서와 플러그인 구성 파일을 대상 소스 디렉토리에 추가할 것입니다.

00:07:54.000 --> 00:08:02.000
프로젝트가 구성되면, UI 구성 요소를 교체하고 생성된 클라이언트 유형을 사용하여 서버에 대한 API 호출을 할 것입니다.

00:08:02.000 --> 00:08:13.000
Swift OpenAPI Generator를 사용하도록 앱을 구성하려면 프로젝트 편집기로 이동하여 패키지 종속성 탭을 선택한 다음 클릭하여 새 종속성을 추가하십시오.

00:08:13.000 --> 00:08:20.000
이 데모를 위해, 우리는 로컬 패키지 컬렉션을 사용하고 있지만, 세션 노트에서 패키지 URL을 찾을 수 있습니다.

00:08:20.000 --> 00:08:31.000
먼저, 패키지 플러그인을 제공하는 swift-openapi-generator에 대한 의존성을 추가할 것입니다.

00:08:31.000 --> 00:08:47.000
그런 다음 생성된 코드에서 사용되는 일반적인 유형과 추상화를 제공하는 swift-openapi-runtime에 대한 종속성을 추가할 것입니다.

00:08:47.000 --> 00:08:55.000
그리고 생성된 코드는 특정 HTTP 클라이언트 라이브러리에 연결되어 있지 않기 때문에, 우리는 사용하고 싶은 라이브러리의 통합 패키지를 선택해야 합니다.

00:08:55.000 --> 00:09:05.000
우리는 iOS 앱을 만들고 있으므로 URLSession 패키지를 사용할 것이지만, 다른 예제와 직접 작성하는 방법에 대한 문서를 확인하세요.

00:09:05.000 --> 00:09:10.000
종속성을 사용하면 OpenAPI Generator 플러그인을 사용하도록 대상을 구성할 수 있습니다.

00:09:10.000 --> 00:09:17.000
대상 설정에서 빌드 단계를 선택하고 "빌드 도구 플러그인 실행"이라는 섹션을 확장하십시오.

00:09:17.000 --> 00:09:25.000
새 플러그인을 추가하려면 클릭하고 목록에서 OpenAPIGenerator를 선택하세요.

00:09:25.000 --> 00:09:43.000
플러그인은 대상 소스 디렉토리에 두 개의 입력 파일을 기대합니다: OpenAPI 문서와 플러그인 구성 파일, 지금 프로젝트에 추가할 것입니다.

00:09:43.000 --> 00:09:50.000
플러그인 구성은 플러그인이 생성해야 하는 코드를 지정하는 간단한 YAML 스키마를 사용하여 작성됩니다.

00:09:50.000 --> 00:09:55.000
이 경우, 우리는 OpenAPI 문서에서 파생된 재사용 가능한 유형인 "유형"을 생성할 것입니다.

00:09:55.000 --> 00:10:01.000
그리고 우리는 또한 모든 HTTP 클라이언트와 API 호출을 하는 데 사용할 수 있는 클라이언트 코드를 생성할 것입니다.

00:10:01.000 --> 00:10:11.000
생성된 코드를 앱에서 사용할 수 있도록 프로젝트를 다시 컴파일하는 ContentView.swift로 다시 전환할 것입니다.

00:10:11.000 --> 00:10:18.000
보안 조치로, 처음 사용할 때 플러그인을 신뢰하라는 요청을 받게 될 것입니다.

00:10:18.000 --> 00:10:28.000
이제 프로젝트를 다시 컴파일했으며, UI 구성 요소를 교체하고 생성된 클라이언트 유형을 사용하여 서버에 대한 API 호출을 하고 보기를 업데이트할 수 있습니다.

00:10:28.000 --> 00:10:34.000
우리는 이모티콘 보기에 새로운 주 속성을 추가하고 자리 표시자 값으로 초기화하는 것으로 시작할 것입니다.

00:10:34.000 --> 00:10:51.000
그런 다음, 우리는 지구 이미지를 이모티콘이 포함된 텍스트 보기로 바꾸고, "Hello, world" 메시지를 버튼으로 바꾸고, 보기의 버튼 스타일을 설정할 것입니다.

00:10:51.000 --> 00:10:56.000
생성된 코드는 API 호출을 하는 데 사용할 수 있는 Client라는 유형을 제공합니다.

00:10:56.000 --> 00:11:02.000
하지만 먼저, 우리는 OpenAPI 런타임과 전송 모듈을 가져와야 합니다.

00:11:02.000 --> 00:11:14.000
이제 클라이언트 속성을 보기에 추가하고 OpenAPI 문서에 정의된 로컬 호스트 서버 URL을 사용하도록 구성하는 이니셜라이저를 추가할 수 있습니다.

00:11:14.000 --> 00:11:28.000
이제 우리는 이 클라이언트를 사용하여 서버에 API를 호출하는 기능을 추가할 것입니다.

00:11:28.000 --> 00:11:32.000
그것이 우리가 API 요청을 하기 위해 손으로 작성해야 하는 모든 코드이다.

00:11:32.000 --> 00:11:35.000
다른 모든 것은 생성된 코드에 의해 처리된다.

00:11:35.000 --> 00:11:44.000
응답은 모든 시나리오를 처리하도록 장려하는 모든 문서화된 응답과 콘텐츠 유형을 모델링하는 유형의 열거형 값입니다.

00:11:44.000 --> 00:11:50.000
그래서 우리는 스위치 문을 사용하여 응답 본문에서 이모티콘을 추출해야 합니다.

00:11:50.000 --> 00:11:51.000
여기 뭔가 빠졌어.

00:11:51.000 --> 00:11:55.000
컴파일러는 우리가 모든 시나리오를 처리하지 않았다고 말했다.

00:11:55.000 --> 00:12:01.000
우리는 Xcode가 누락된 스위치 케이스를 채우도록 할 것이다.

00:12:01.000 --> 00:12:09.000
서버가 OpenAPI 문서에 명시되지 않은 것으로 응답하는 경우, 당신은 여전히 그것을 우아하게 처리할 수 있습니다.

00:12:09.000 --> 00:12:20.000
이 데모를 위해, 우리는 콘솔에 경고를 인쇄하고 이모티콘을 고양이가 아닌 다른 것으로 업데이트할 것입니다.

00:12:20.000 --> 00:12:26.000
이제 우리는 버튼을 탭하면 이 기능을 호출할 수 있습니다.

00:12:26.000 --> 00:12:33.000
그리고 우리는 버튼을 사용하여 새로운 고양이 이모티콘을 가져오고 UI를 업데이트할 수 있습니다.

00:12:33.000 --> 00:12:37.000
새로운 기능이 서버에 추가됨에 따라, API는 진화할 것이다.

00:12:37.000 --> 00:12:45.000
그리고 서버가 OpenAPI를 사용하여 문서화된 경우, Swift OpenAPI Generator를 사용하면 앱의 이러한 새로운 기능을 쉽게 사용할 수 있습니다.

00:12:45.000 --> 00:12:52.000
OpenAPI 문서가 발전함에 따라 앱을 업데이트하는 방법의 예를 살펴보겠습니다.

00:12:52.000 --> 00:13:02.000
이모티콘에 관해서는, 더 많은 것이 더 많기 때문에, 우리는 여러 이모티콘을 가져오는 데 사용할 수 있는 새로운 선택적 쿼리 매개 변수인 카운트를 사용하기 위해 서비스 API를 확장했습니다.

00:13:02.000 --> 00:13:10.000
우리는 고양이 한 마리 대신 고양이 세 마리를 가져오는 다른 버튼으로 앱을 확장할 것입니다.

00:13:10.000 --> 00:13:14.000
먼저, 우리는 OpenAPI 문서에 매개 변수를 추가할 것입니다.

00:13:14.000 --> 00:13:19.000
그리고 프로젝트를 다시 컴파일하면, 앱에서 매개 변수를 사용할 수 있습니다.

00:13:19.000 --> 00:13:24.000
그런 다음 이 매개 변수를 사용하여 API 호출을 하는 새 버튼을 만들 것입니다.

00:13:24.000 --> 00:13:32.000
우리는 OpenAPI 문서에 새로운 매개 변수를 추가하는 것으로 시작할 것입니다.

00:13:32.000 --> 00:13:35.000
이 매개 변수의 이름은 "카운트"입니다.

00:13:35.000 --> 00:13:36.000
그건 선택적 매개 변수야.

00:13:36.000 --> 00:13:41.000
그것은 URL 쿼리의 일부로 제공되며 정수 값입니다.

00:13:41.000 --> 00:13:50.000
ContentView.swift로 돌아가서 updateEmoji 기능을 확장하여 매개 변수도 사용합시다.

00:13:50.000 --> 00:14:01.000
그리고 API 호출을 할 때 이 매개 변수를 사용합시다.

00:14:01.000 --> 00:14:09.000
우리는 버튼을 복제하고 라벨을 "더 많은 고양이"로 바꿀 것입니다.

00:14:09.000 --> 00:14:18.000
이 버튼을 탭하면, 우리는 같은 기능을 호출할 것이지만, 이번에는 세 번으로 셀 것이다.

00:14:18.000 --> 00:14:25.000
이제 미리보기에서, 우리는 "Get cat"를 탭하여 고양이 한 마리를 얻거나 "더 많은 고양이"를 탭하여 세 마리를 얻을 수 있습니다.

00:14:25.000 --> 00:14:33.000
이 모든 시간 동안, 우리는 실제 서버에 요청을 해왔는데, 이는 특히 개발 중에 항상 실용적이거나 바람직하지는 않습니다.

00:14:33.000 --> 00:14:41.000
생성된 클라이언트 유형은 스위프트 프로토콜을 준수하기 때문에, 네트워크 연결이나 전송 라이브러리가 필요하지 않은 모의를 작성하는 것은 쉽습니다.

00:14:41.000 --> 00:14:49.000
생성된 프로토콜의 이름은 APIProtocol이므로, 이 프로토콜을 채택하는 새로운 MockClient 유형을 정의하는 것으로 시작하겠습니다.

00:14:49.000 --> 00:14:58.000
그런 다음 APIProtocol을 준수하는 모든 유형에 대해 일반으로 보기를 업데이트하고 종속성 주입을 지원하기 위해 이니셜라이저를 업데이트할 것입니다.

00:14:58.000 --> 00:15:02.000
그런 다음 Xcode에서 UI를 미리 볼 때 MockClient를 사용할 것입니다.

00:15:02.000 --> 00:15:07.000
우리는 MockClient 유형을 선언하는 것으로 시작할 것이다.

00:15:07.000 --> 00:15:14.000
우리는 이 유형이 APIProtocol을 채택한다고 선언했기 때문에, 컴파일러는 프로토콜 요구 사항을 충족하도록 할 것이다.

00:15:14.000 --> 00:15:20.000
우리는 Xcode가 API 작업에 대한 누락된 핸들러를 추가하도록 할 것이다.

00:15:20.000 --> 00:15:28.000
그리고 우리는 실제 서비스와 구별하기 위해 로봇 이모티콘을 반환하는 비즈니스 논리를 추가할 것입니다.

00:15:28.000 --> 00:15:39.000
이제 우리는 이 프로토콜을 준수하는 유형에 대한 뷰를 제네릭으로 만들고 제네릭 유형 매개 변수를 사용하도록 클라이언트 속성을 업데이트할 수 있습니다.

00:15:39.000 --> 00:15:53.000
클라이언트를 매개 변수로 사용하는 이니셜라이저를 추가하고, 기존 이니셜라이저를 일반 where 절로 업데이트할 것이므로, 클라이언트가 제공되지 않으면 이전과 동일한 것을 사용할 것입니다.

00:15:53.000 --> 00:16:02.000
앱이 실행되면 실제 서버를 계속 사용할 것이지만, 이제 Xcode에서 UI를 미리 볼 때 MockClient를 삽입할 수 있습니다.

00:16:02.000 --> 00:16:13.000
이제 UI 미리보기에서 버튼을 탭하면 고양이 대신 로봇을 얻을 수 있으며 네트워크 연결이나 실행 중인 서버가 필요하지 않습니다.

00:16:13.000 --> 00:16:20.000
모의 클라이언트를 추가할 때까지, 우리의 iOS 앱은 내 로컬 컴퓨터에서 실행되는 실제 서버에 요청을 하고 있었다.

00:16:20.000 --> 00:16:25.000
이 서버는 또한 Swift OpenAPI Generator의 도움으로 Swift로 작성되었습니다.

00:16:25.000 --> 00:16:33.000
서버는 코드 생성을 위해 Swift OpenAPI Generator 패키지 플러그인을 사용하는 간단한 Swift 패키지입니다.

00:16:33.000 --> 00:16:43.000
생성된 서버 코드를 사용하기 위해, 우리는 APIProtocol이라는 생성된 프로토콜을 준수하는 유형을 정의하고 API 운영을 위한 비즈니스 로직만 구현했습니다.

00:16:43.000 --> 00:16:54.000
그리고 서버를 구성하기 위해, 우리는 API 작업에 대한 들어오는 HTTP 요청을 비즈니스 로직을 제공하는 핸들러에 연결하는 생성된 함수인 registerHandlers를 사용했습니다.

00:16:54.000 --> 00:16:58.000
한 번 보자.

00:16:58.000 --> 00:17:04.000
콘솔을 확장하면 데모 iOS 앱의 실제 요청을 볼 수 있습니다.

00:17:04.000 --> 00:17:09.000
그리고 이것은 우리가 서버를 구현하기 위해 손으로 작성해야 했던 모든 스위프트 코드이다.

00:17:09.000 --> 00:17:22.000
이 서비스를 문서화하기 위해 OpenAPI를 사용하는 대신, 우리는 OpenAPI 문서로 시작하여 Swift OpenAPI Generator를 사용하여 API 사양을 구현하는 서버 작성을 단순화했습니다.

00:17:22.000 --> 00:17:30.000
우리는 생성된 APIProtocol을 준수하고 API 운영을 위한 비즈니스 논리만을 제공하는 유형을 정의했습니다.

00:17:30.000 --> 00:17:36.000
그리고 우리는 API 엔드포인트를 위한 HTTP 서버에 방법을 등록하기 위해 생성된 기능을 사용했습니다.

00:17:36.000 --> 00:17:40.000
이 데모에서, 우리는 Swift를 위한 오픈 소스 웹 프레임워크인 Vapor를 사용하고 있습니다.

00:17:40.000 --> 00:17:47.000
하지만 생성된 코드는 Swift OpenAPI Generator를 위한 통합 패키지를 제공하는 모든 웹 프레임워크와 함께 사용할 수 있습니다.

00:17:47.000 --> 00:17:53.000
다른 옵션과 직접 작성할 수 있는 방법에 대한 문서를 확인하세요.

00:17:53.000 --> 00:18:00.000
우리의 주요 기능에서, 우리는 OpenAPI 전송을 만드는 데 사용하는 새로운 Vapor 애플리케이션을 만듭니다.

00:18:00.000 --> 00:18:12.000
그런 다음 핸들러 유형의 인스턴스를 만들고 생성된 registerHandlers 기능을 사용하여 각 API 작업에 대해 HTTP 서버 내에서 라우팅을 설정합니다. 그렇지 않으면 수동으로 해야 합니다.

00:18:12.000 --> 00:18:18.000
마지막으로, 우리는 수동으로 구성한 것과 같은 방식으로 Vapor 앱을 실행합니다.

00:18:18.000 --> 00:18:30.000
스위프트는 서버 개발을 위한 훌륭한 언어이며, 스위프트에서 백엔드 서비스를 작성하는 방법에 대해 더 알고 싶다면, "서버 측 개발을 위해 Xcode 사용"이라는 세션을 확인하세요.

00:18:30.000 --> 00:18:35.000
패키지가 Swift OpenAPI Generator를 사용하도록 어떻게 구성되어 있는지 살펴봅시다.

00:18:35.000 --> 00:18:41.000
서버는 Swift 패키지로 구현되며 Package.swift 파일을 사용하여 정의됩니다.

00:18:41.000 --> 00:18:48.000
이 패키지에는 Swift OpenAPI Generator 플러그인을 사용하는 CatService라는 단일 실행 대상을 가지고 있습니다.

00:18:48.000 --> 00:19:04.000
생성된 서버 코드는 런타임 라이브러리의 일반적인 유형과 추상화에 따라 다르며 통합 패키지를 제공하는 모든 웹 프레임워크와 함께 사용할 수 있으므로 이 대상은 swift-openapi-runtime, swift-openapi-vapor 및 vapor 자체에 의존합니다.

00:19:04.000 --> 00:19:13.000
대상 소스 디렉토리에 데모 iOS 앱에서 사용한 것과 동일한 OpenAPI 문서와 플러그인 구성 파일을 추가했습니다.

00:19:13.000 --> 00:19:17.000
이 목표를 위해, 우리는 유형과 서버 스텁을 생성하고 있다.

00:19:17.000 --> 00:19:24.000
사양 중심 개발이 어떻게 이 서비스에 새로운 기능을 추가하는 것을 더 간단하게 만들 수 있는지 봅시다.

00:19:24.000 --> 00:19:35.000
고양이 이모티콘은 훌륭하지만, 많은 증거가 인터넷이 주로 고양이 비디오 교환을 위해 만들어졌다는 것을 시사하므로, 우리는 그 기능을 서버에 추가할 것입니다.

00:19:35.000 --> 00:19:40.000
사양 중심의 개발을 통해, 새로운 API 작업을 추가하려면 두 단계만 있으면 됩니다.

00:19:40.000 --> 00:19:44.000
먼저, 우리는 OpenAPI 문서에 새로운 작업을 추가합니다.

00:19:44.000 --> 00:19:53.000
그런 다음, 생성된 프로토콜에는 이제 새로운 기능 요구 사항이 있기 때문에, 컴파일러는 우리가 핸들러에 대한 방법을 정의하고 비즈니스 논리를 구현할 것이라고 주장할 것이다.

00:19:53.000 --> 00:20:06.000
시작하기 전에, 우리는 목표를 위해 리소스 폴더에 추가한 고양이 비디오가 필요할 것입니다.

00:20:06.000 --> 00:20:12.000
우리는 OpenAPI 문서로 가서 새로운 작업을 추가할 것이다.

00:20:12.000 --> 00:20:22.000
이 작업은 getClip이라고 불리며 응답 본문에 비디오 데이터가 포함되어 있음을 나타내는 콘텐츠 유형이 있는 이진 응답이 있습니다.

00:20:22.000 --> 00:20:27.000
우리가 패키지를 다시 컴파일하려고 할 때, 그것은 실패할 것이다.

00:20:27.000 --> 00:20:34.000
그것은 우리의 핸들러가 더 이상 생성된 프로토콜을 준수하지 않기 때문입니다. 왜냐하면 그것은 새로운 작업을 위한 기능을 제공하지 않기 때문입니다.

00:20:34.000 --> 00:20:44.000
우리는 Xcode가 우리를 위해 프로토콜 스텁을 채우도록 할 것이며, 비디오 리소스 파일에서 바이트를 읽고 이진 본문과 함께 OK 응답을 반환하는 비즈니스 로직을 제공할 것입니다.

00:20:44.000 --> 00:20:55.000
유형에 안전한 생성된 코드는 이 함수에서 이진 응답 본문만 반환할 수 있습니다. 왜냐하면 그것이 이 작업에 대한 OpenAPI 문서에 명시되어 있기 때문입니다.

00:20:55.000 --> 00:21:00.000
패키지를 다시 컴파일하면 성공할 것이고 서버를 다시 시작할 수 있습니다.

00:21:00.000 --> 00:21:13.000
그리고 사파리로 전환하면, 새로운 API 엔드포인트를 테스트할 수 있습니다.

00:21:13.000 --> 00:21:20.000
그래서 우리는 OpenAPI를 사용하여 서비스를 문서화하는 것이 모호함을 제거하고 사양 기반 개발을 가능하게 하는 데 어떻게 도움이 될 수 있는지 보았습니다.

00:21:20.000 --> 00:21:27.000
Swift OpenAPI Generator가 iOS 앱에서 서버 API 작업을 단순화할 수 있는 방법을 보여주었습니다.

00:21:27.000 --> 00:21:35.000
마지막으로, 우리는 Swift의 언어 기능과 성장하는 Swift-on-server 생태계가 어떻게 백엔드 서비스를 구현하기 위한 훌륭한 선택으로 만드는지 보았습니다.

00:21:35.000 --> 00:21:44.000
그리고 그것이 Swift OpenAPI Generator가 오픈 소스이며 GitHub에서 사용할 수 있는 이유이며, 여기서 더 많은 것을 배우고 프로젝트가 계속 성장함에 따라 프로젝트에 기여할 수 있습니다.

00:21:44.000 --> 00:21:45.000
이 세션을 봐줘서 고마워.

00:21:45.000 --> 23:59:59.000
야옹을 위한 건 그게 다야!

