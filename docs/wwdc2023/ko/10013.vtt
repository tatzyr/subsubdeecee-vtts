WEBVTT

00:00:00.000 --> 00:00:12.000
SwiftUI용 StoreKit에 오신 것을 환영합니다.

00:00:12.000 --> 00:00:15.000
저는 StoreKit 팀의 엔지니어인 Greg입니다.

00:00:15.000 --> 00:00:19.000
인앱 구매 상품화에 대해 이야기해 봅시다.

00:00:19.000 --> 00:00:27.000
머천다이징 인앱 구매는 제품 제공을 제시하고 고객이 구매를 완료할 수 있는 방법을 제공하는 것입니다.

00:00:27.000 --> 00:00:34.000
머천다이징은 당신이 판매하는 제품에 대한 데이터를 얻고 고객의 상태를 얻는 것으로 시작됩니다.

00:00:34.000 --> 00:00:38.000
예를 들어, 고객이 이미 내 비소모성 제품을 소유하고 있나요?

00:00:38.000 --> 00:00:41.000
그들이 내 구독에 가입했나요?

00:00:41.000 --> 00:00:48.000
이 데이터를 결합하여 고객에게 제품을 마케팅하고 제품을 구매하기 위한 상호 작용을 제공하는 인터페이스를 구축합니다.

00:00:48.000 --> 00:00:54.000
이 작은 빨간색 직사각형은 인터페이스를 구축하는 데 들어가는 모든 노력을 과소평가합니다.

00:00:54.000 --> 00:01:00.000
실제로 인터페이스를 구축하는 데는 많은 측면이 있으며, 다양한 분야의 기술이 필요합니다.

00:01:00.000 --> 00:01:03.000
그런 다음, 당신의 고객은 당신의 제품을 구매하기로 선택합니다.

00:01:03.000 --> 00:01:10.000
앱은 구매 API를 사용한 다음 구매 결과로 인터페이스를 업데이트하여 응답해야 합니다.

00:01:10.000 --> 00:01:16.000
앱에 인앱 구매를 추가한 적이 있다면, 머천다이징을 올바르게 하는 것이 중요하다는 것을 알고 있습니다.

00:01:16.000 --> 00:01:22.000
이 모든 단계를 간단하면서도 강력한 관점으로 추상화할 수 있다면 좋지 않을까요?

00:01:22.000 --> 00:01:30.000
이 보기는 모든 일반적인 기능을 처리하고 앱을 만드는 비트를 구성할 수 있는 매개 변수를 취할 수 있습니다.

00:01:30.000 --> 00:01:37.000
음, 머천다이징 UI를 구축하기 위해 StoreKit의 강력한 새로운 API 세트를 소개하게 되어 기쁩니다.

00:01:37.000 --> 00:01:44.000
Xcode 15에서 StoreKit은 이제 선언적인 인앱 구매 UI를 구축하는 데 도움이 되는 SwiftUI 뷰 컬렉션을 제공합니다.

00:01:44.000 --> 00:01:52.000
당신은 당신이 원하는 머천다이징 경험을 선언하기만 하면, 시스템은 당신의 선언을 무대 뒤에서 실행에 옮기게 됩니다.

00:01:52.000 --> 00:02:01.000
StoreView, ProductView 및 SubscriptionStoreView는 그 어느 때보다 빠르게 머천다이징을 시작하고 실행할 수 있는 새로운 뷰입니다.

00:02:01.000 --> 00:02:08.000
이러한 보기는 App Store의 데이터 흐름을 추상화하고 시스템 제공 UI를 표시하여 인앱 구매를 나타냅니다.

00:02:08.000 --> 00:02:16.000
이미 익숙한 SwiftUI API를 사용하여 이러한 보기가 앱과 어떻게 통합되는지 사용자 정의할 수도 있습니다.

00:02:16.000 --> 00:02:29.000
SwiftUI와 마찬가지로, 이러한 새로운 보기는 모든 플랫폼에서 지원되므로, iPhone, iPad, Mac, Apple Watch 및 Apple TV에서 그 어느 때보다 쉽게 인앱 구매를 구매할 수 있습니다.

00:02:29.000 --> 00:02:36.000
깃털 달린 친구들의 무리가 나에게 다가와 뒷마당 새라는 새로운 게임에 인앱 구매를 추가하는 것을 도울 수 있는지 물었다.

00:02:36.000 --> 00:02:41.000
StoreKit의 이러한 새로운 견해로, 물론 나는 "전혀 문제 없다"고 말했다.

00:02:41.000 --> 00:02:45.000
Backyard Birds에서 훌륭한 인앱 구매 경험을 제공할 때 저와 함께 하세요.

00:02:45.000 --> 00:02:49.000
저와 함께 작업하기 위해 샘플 프로젝트를 자유롭게 다운로드하세요.

00:02:49.000 --> 00:02:54.000
우리는 Xcode Previews를 사용하여 SwiftUI 뷰를 빠르게 반복할 것입니다.

00:02:54.000 --> 00:02:59.000
우리가 다룰 것이 너무 많기 때문에, 나는 이미 StoreKit 구성 파일을 설정했다.

00:02:59.000 --> 00:03:05.000
여기에는 StoreKit과 함께 Xcode 미리보기를 사용하는 데 필요한 인앱 구매에 대한 메타데이터가 포함되어 있습니다.

00:03:05.000 --> 00:03:15.000
"StoreKit 테스트의 새로운 기능" 및 "Xcode에서 StoreKit 테스트 소개"와 같이 자신의 앱을 시작하는 데 도움이 되는 몇 가지 훌륭한 세션이 있습니다.

00:03:15.000 --> 00:03:17.000
Xcode로 바로 들어가자.

00:03:17.000 --> 00:03:21.000
뒷마당 새들에서, 우리는 이 영양 펠릿과 같은 프리미엄 새 사료를 팔고 싶다.

00:03:21.000 --> 00:03:26.000
음식을 구매한 후, 우리는 더 많은 배고픈 새 방문객을 끌어들이기 위해 뒷마당에 둘 수 있다.

00:03:26.000 --> 00:03:33.000
이러한 제품을 상품화하기 위해 StoreKit을 어떻게 활용할 수 있는지 알아보기 위해 코드로 넘어갑시다.

00:03:33.000 --> 00:03:39.000
시작하기 위해, 우리는 조류 사료를 상품화하기 위해 BirdFoodShop이라는 뷰를 만들 것입니다.

00:03:39.000 --> 00:03:42.000
나는 이미 이 뷰를 구현하기 위해 파일을 만들었다.

00:03:42.000 --> 00:03:50.000
StoreKit을 사용하여 뷰를 구축하려면, 파일 상단에 StoreKit과 SwiftUI를 모두 가져와야 합니다.

00:03:50.000 --> 00:03:59.000
다음으로, 나는 우리가 가게를 짓는 데 도움이 될 조류 사료 데이터 모델을 얻기 위해 여기에 쿼리를 선언할 것이다.

00:03:59.000 --> 00:04:05.000
머천다이징 보기를 시작하고 실행하는 가장 빠른 방법이기 때문에 앱에 StoreView를 추가하고 있습니다.

00:04:05.000 --> 00:04:18.000
우리는 birdFood 모델에서 얻을 수 있는 StoreKit 구성 파일에서 제품 식별자 모음을 제공해야 합니다.

00:04:18.000 --> 00:04:22.000
이 선언 이후, 이제 우리는 기능하는 머천다이징 관점을 가지고 있다.

00:04:22.000 --> 00:04:28.000
StoreKit은 App Store에서 모든 제품 식별자를 로드하여 우리가 볼 수 있도록 UI로 표시합니다.

00:04:28.000 --> 00:04:37.000
표시 이름, 설명 및 가격은 모두 App Store Connect 또는 StoreKit 구성 파일에서 설정한 것을 사용하는 App Store에서 직접 제공됩니다.

00:04:37.000 --> 00:04:49.000
StoreKit은 만료되거나 시스템이 메모리 압력을 받을 때까지 데이터를 캐싱하고 스크린 타임에서 앱 내 구매가 비활성화되었는지 확인하는 것과 같은 더 미묘하지만 중요한 고려 사항을 처리합니다.

00:04:49.000 --> 00:04:54.000
이전에, 새 디자이너들은 각 새 식품에 대한 장식 아이콘을 보냈다.

00:04:54.000 --> 00:05:04.000
후행 뷰 빌더를 추가하고 아이콘을 나타내는 SwiftUI 뷰를 전달하기만 하면 이러한 아이콘을 스토어 뷰에 추가할 수 있습니다.

00:05:04.000 --> 00:05:10.000
뷰 빌더는 제품 값을 매개 변수로 사용하며, 사용할 아이콘을 결정하는 데 사용할 수 있습니다.

00:05:10.000 --> 00:05:20.000
제품 ID를 가져와서 자산 카탈로그에서 올바른 아이콘을 찾는 도우미 보기를 만들었습니다.

00:05:20.000 --> 00:05:26.000
이것을 여기에 넣으면, 각 제품의 아이콘을 보여주는 미리보기 업데이트를 볼 수 있습니다.

00:05:26.000 --> 00:05:35.000
스토어 뷰는 제품 식별자와 아이콘을 기능적이고 잘 설계된 상점으로 바꾸어 쉽게 시작하고 실행할 수 있도록 도와줍니다.

00:05:35.000 --> 00:05:43.000
스토어 뷰의 강력한 기능은 우리 제품이 다른 플랫폼에 자동으로 조정되기 때문에 이미 iPad, Mac 및 Apple Watch에서 멋지게 보이는 상점이 있다는 것입니다.

00:05:43.000 --> 00:05:57.000
우리 가게를 미리 보기 위해 Xcode의 목표를 Apple Watch로 변경합시다.

00:05:57.000 --> 00:05:58.000
좋아 보인다!

00:05:58.000 --> 00:06:03.000
내 생각에 우리는 Apple Watch에서도 새 사료를 팔 준비가 된 것 같아.

00:06:03.000 --> 00:06:07.000
당신의 제안에 고유한 방식으로 제품을 정리하고 싶은 것이 일반적입니다.

00:06:07.000 --> 00:06:13.000
우리 조류 디자이너 팀은 조류 먹이를 선보일 수 있는 구성을 만들기 위해 열심히 노력해 왔습니다.

00:06:13.000 --> 00:06:20.000
이 구성은 최고의 가치를 두드러지게 표시하고 다른 제품들을 선반으로 정리한다.

00:06:20.000 --> 00:06:28.000
이것은 StoreView로 달성할 수 있는 목록 스타일 레이아웃과 다르지만, StoreKit에서도 우리를 다룹니다.

00:06:28.000 --> 00:06:31.000
더 자세한 레이아웃을 위해, 우리는 새로운 ProductView를 활용할 수 있습니다.

00:06:31.000 --> 00:06:38.000
사실, 우리가 방금 보고 있던 StoreView는 동일한 ProductView를 사용하여 행을 만듭니다.

00:06:38.000 --> 00:06:46.000
새 가게를 위한 컨테이너를 선언하는 것으로 시작합시다.

00:06:46.000 --> 00:06:53.000
저는 이 영양 펠릿 상자를 다른 제품보다 눈에 띄게 선보이고 싶습니다. 왜냐하면 그것이 우리의 최고의 가치이기 때문입니다.

00:06:53.000 --> 00:07:04.000
이를 위해, 나는 영양 펠렛 상자의 ID를 제공하여 ProductView를 선언할 것이다.

00:07:04.000 --> 00:07:09.000
StoreView와 마찬가지로, 후행 폐쇄를 추가하여 장식 아이콘을 추가할 수 있습니다.

00:07:09.000 --> 00:07:16.000
나는 이전부터 우리의 도우미 보기를 재사용할 것이다.

00:07:16.000 --> 00:07:20.000
다음으로, 다른 식품에 대한 섹션을 아래에 추가해 봅시다.

00:07:20.000 --> 00:07:26.000
최고의 가치 뒤에 배경을 두는 것으로 시작하겠습니다...

00:07:26.000 --> 00:07:37.000
그런 다음 선반에 새 먹이를 놓기 위해 만든 또 다른 도우미 보기와 함께 헤더.

00:07:37.000 --> 00:07:50.000
이 선반 도우미 보기 내에서, 우리는 장식 아이콘과 함께 각 조류 식품에 대한 ProductView를 선언할 수 있습니다.

00:07:50.000 --> 00:07:52.000
이 가게 전체를 하나로 묶는 데 마지막으로 필요한 것이 하나 있다.

00:07:52.000 --> 00:08:00.000
우리는 이 영양 펠릿 상자를 고객에게 눈에 띄게 전시하고 싶지만, 조류 디자이너들은 우리가 지금 가지고 있는 것이 더 좋아 보일 수 있다고 생각합니다.

00:08:00.000 --> 00:08:06.000
새들을 달래기 위해, 우리는 새로운 productViewStyle API를 사용하여 영웅 제품의 스타일을 설정할 수 있습니다.

00:08:06.000 --> 00:08:16.000
나는 이것을 돋보이게 하기 위해 큰 스타일을 선택할 것이다.

00:08:16.000 --> 00:08:24.000
단 몇 분 만에, 우리는 StoreKit의 새로운 ProductView를 사용하여 조류 사료를 위한 전문 상점을 지었습니다.

00:08:24.000 --> 00:08:31.000
큰 ProductView 스타일은 하나의 보기 수정자를 추가하여 최고의 가치를 눈에 띄게 표시할 수 있도록 도와줍니다.

00:08:31.000 --> 00:08:35.000
당신의 필요에 맞게 선택할 수 있는 세 가지 표준 스타일이 있습니다.

00:08:35.000 --> 00:08:49.000
컴팩트는 더 작은 공간에서 더 많은 제품을 전시하는 데 도움이 되며, 우리의 새 먹이 선반은 자동으로 레귤러 스타일을 사용하며, 물론 라지 스타일은 눈에 띄는 프레젠테이션에 적합합니다.

00:08:49.000 --> 00:08:58.000
StoreView는 ProductView 인스턴스로 구성되어 있기 때문에, 동일한 productViewStyle 수정자를 사용하여 StoreView의 스타일을 변경할 수 있습니다.

00:08:58.000 --> 00:09:03.000
사용자 지정 스타일을 만들고 ProductView 및 StoreView와 함께 사용할 수도 있습니다.

00:09:03.000 --> 00:09:07.000
계속 있어, 그리고 내가 나중에 세션에서 어떻게 하는지 보여줄게.

00:09:07.000 --> 00:09:13.000
우리는 ProductView를 사용하여 소모품 조류 식품 인앱 구매를 제공할 수 있는 좋은 방법을 만들었습니다.

00:09:13.000 --> 00:09:22.000
비즈니스 새들은 우리가 충분히 멀리 가지 않았다고 생각하며, 그들은 나에게 가장 열렬한 조류 관찰자들을 위해 Backyard Birds Pass라는 구독을 제공하는 임무를 맡았다.

00:09:22.000 --> 00:09:31.000
ProductView 또는 StoreView를 사용하여 구독 UI를 구축할 수 있지만, 새로운 SubscriptionStoreView는 구독을 위해 특별히 제작되었습니다.

00:09:31.000 --> 00:09:34.000
Xcode로 돌아가서 이것을 함께 만들어 봅시다.

00:09:34.000 --> 00:09:44.000
시작하기 위해, StoreKit 구성에서, 저는 세 가지 수준의 서비스를 제공하는 "Backyard Birds Pass" 구독 그룹을 만들었습니다.

00:09:44.000 --> 00:09:48.000
이 그룹 ID를 기록하세요. 우리는 잠시 후에 이게 필요할 거야.

00:09:48.000 --> 00:09:56.000
이전에, 저는 패스 샵을 위한 새 파일을 만들었으니, SubscriptionStoreView로 바로 들어가 봅시다.

00:09:56.000 --> 00:10:04.000
SubscriptionStoreView를 시작하고 실행하는 가장 빠른 방법은 StoreKit 구성 파일 또는 App Store Connect에서 그룹 ID를 제공하는 것입니다.

00:10:04.000 --> 00:10:21.000
이미 그룹에 그룹 ID를 추가했기 때문에, 액세스하기 위해 환경 속성을 선언한 다음 그룹 ID를 제공하여 SubscriptionStoreView를 선언할 수 있습니다.

00:10:21.000 --> 00:10:30.000
StoreView와 ProductView와 마찬가지로, SubscriptionStoreView는 우리를 위해 데이터 흐름을 관리하고 다른 계획 옵션으로 보기를 배치합니다.

00:10:30.000 --> 00:10:37.000
또한 기존 구독자 상태와 고객이 입문 제안을 받을 자격이 있는지 여부를 확인합니다.

00:10:37.000 --> 00:10:44.000
이 자동 모양은 훌륭하지만, 뒷마당 새의 모양과 느낌에 맞게 만들기 위해 사용할 수 있는 몇 가지 강력한 새로운 API가 있습니다.

00:10:44.000 --> 00:10:50.000
예를 들어, 헤더의 마케팅 콘텐츠를 SwiftUI 뷰로 바꿀 수 있습니다.

00:10:50.000 --> 00:10:57.000
나는 이전에 마케팅 콘텐츠 뷰를 만들었기 때문에, 이것을 여기에 내려놓을 것이다.

00:10:57.000 --> 00:11:03.000
우리는 또한 구독 스토어에 컨테이너 배경을 추가하여 시각적으로 더 흥미롭게 만들 수 있습니다.

00:11:03.000 --> 00:11:10.000
우리는 새로운 SwiftUI containerBackground API를 사용할 수 있습니다.

00:11:10.000 --> 00:11:20.000
내가 이것을 구독 스토어의 전체 높이에 배치한 다음 하늘 그라디언트와 구름으로 이전에 만든 뷰를 선언하는 방법을 주목하세요.

00:11:20.000 --> 00:11:26.000
모든 것을 하나로 묶기 위해, 우리는 구독 스토어를 스타일링하기 위해 다른 API를 사용할 수 있습니다.

00:11:26.000 --> 00:11:35.000
기본적으로, 구독 스토어는 구독 컨트롤과 전체 높이 배경 사이에 재료 레이어를 추가합니다.

00:11:35.000 --> 00:11:45.000
배경 스타일 수정자를 사용하여 구독 컨트롤 뒤의 배경을 명확하게 할 수 있습니다.

00:11:45.000 --> 00:11:55.000
이제, 저는 subscriptionStoreButtonLabel을 사용하여 구독 버튼의 멀티라인 레이아웃을 선택할 것입니다.

00:11:55.000 --> 00:12:01.000
구독 버튼이 어떻게 가격과 "무료로 체험"을 모두 포함하는지 주목하세요.

00:12:01.000 --> 00:12:12.000
다음으로, 구독 옵션에 대한 물질적 효과를 선언하기 위해 subscriptionStorePickerItemBackground를 추가하겠습니다.

00:12:12.000 --> 00:12:20.000
여기서, 우리는 구독 계획 옵션을 통해 하늘 그라데이션이 빛나는 것을 볼 수 있습니다.

00:12:20.000 --> 00:12:32.000
마지막으로, 우리의 구독에는 제안 코드가 있기 때문에, 나는 새로운 storeButton 수정자를 사용하여 코드 교환 버튼을 표시로 선언할 것이다.

00:12:32.000 --> 00:12:40.000
이 하나의 보기 수정자로, 우리는 고객이 제안 코드 상환 시트를 열 수 있는 버튼이 있습니다.

00:12:40.000 --> 00:12:45.000
이제, 우리의 구독 보기는 나머지 Backyard Birds의 느낌과 일치합니다.

00:12:45.000 --> 00:12:54.000
이러한 새로운 견해는 앱에 인앱 구매를 추가하는 데 필요한 노력을 크게 줄이지만, 우리가 놓치고 있는 몇 가지 중요한 부분이 있습니다.

00:12:54.000 --> 00:12:59.000
먼저, 우리는 구매 후 실제로 콘텐츠의 잠금을 해제하기 위해 논리를 추가해야 합니다.

00:12:59.000 --> 00:13:07.000
둘째, 누군가가 이미 구독했는지 확인한 다음 SubscriptionStoreView를 표시하는 컨트롤을 숨겨야 합니다.

00:13:07.000 --> 00:13:20.000
StoreKit 뷰는 이미 자동으로 구독한 고객을 처리하지만, 많은 경우 최고의 경험은 기존 고객에게 머천다이징 UI를 제시하지 않기로 선택하는 것입니다.

00:13:20.000 --> 00:13:28.000
StoreKit에는 콘텐츠를 판매하는 것만큼 쉽고 재미있게 이러한 중요한 기능을 구현할 수 있는 새로운 API가 있습니다.

00:13:28.000 --> 00:13:35.000
이러한 API를 시작하기 전에, 이미 비즈니스 로직을 구현했거나, 적어도 스캐폴딩을 갖추고 있어야 합니다.

00:13:35.000 --> 00:13:47.000
업데이트된 거래를 처리하고, 서버와 협력하고, 소모품 자격을 추적하고, UI 코드에 적합한 데이터 모델을 만들고 있는지 확인하십시오.

00:13:47.000 --> 00:13:56.000
비즈니스 로직 구현에 대해 자세히 알아보려면 "Meet StoreKit 2"와 "App Store 서버 API의 새로운 기능"을 확인하는 것이 좋습니다.

00:13:56.000 --> 00:14:01.000
나는 이미 우리의 조류 사업 논리를 BirdBrain이라는 배우에게 구현했다.

00:14:01.000 --> 00:14:04.000
넌 내가 이걸 언급하는 걸 곧 보게 될 거야.

00:14:04.000 --> 00:14:10.000
조류 관찰자들에게 그들이 구매한 소모품 새 사료에 접근할 수 있도록 하는 것부터 시작합시다.

00:14:10.000 --> 00:14:13.000
StoreKit 보기에서 오는 구매를 처리하는 것은 간단합니다.

00:14:13.000 --> 00:14:21.000
onInAppPurchaseCompletion으로 보기를 수정하고 구매가 완료될 때마다 호출하는 기능을 제공합니다.

00:14:21.000 --> 00:14:27.000
이 방법으로 모든 보기를 수정할 수 있으며, 하위 StoreKit 보기가 구매를 완료할 때마다 호출됩니다.

00:14:27.000 --> 00:14:39.000
이 수정자를 BirdFoodShop에 추가합시다.

00:14:39.000 --> 00:14:46.000
수정자는 성공 여부에 관계없이 구매한 제품과 구매 결과를 제공합니다.

00:14:46.000 --> 00:14:55.000
처리를 위해 성공적인 결과를 BirdBrain 배우에게 보내기 위해 이것을 구현합시다.

00:14:55.000 --> 00:15:01.000
이 수정자를 추가함으로써, 우리는 이제 사람들이 구매하는 소모품 새 사료의 잠금을 해제하고 있습니다.

00:15:01.000 --> 00:15:05.000
시뮬레이터에서 이것을 시도해 봅시다.

00:15:05.000 --> 00:15:10.000
나는 뒷마당을 선택하고 보급품을 두드릴 것이다.

00:15:10.000 --> 00:15:19.000
그럼, 나는 영양 알약을 좀 살 거야.

00:15:19.000 --> 00:15:26.000
시트가 해제된 후, 당신은 이제 우리의 공급품 재고에 다섯 개의 영양 펠릿이 있다는 것을 알게 될 것입니다.

00:15:26.000 --> 00:15:34.000
이제, 우리는 영양 펠릿을 놓고 우리의 펠릿이 모든 굶주린 새들을 마당으로 데려올 때 앉을 수 있다.

00:15:34.000 --> 00:15:43.000
onInAppPurchaseCompletion 외에도 StoreKit 뷰에서 이벤트를 처리하는 데 사용할 수 있는 몇 가지 다른 관련 뷰 수정자가 있습니다.

00:15:43.000 --> 00:15:50.000
누군가가 구매 버튼을 트리거할 때 onInAppPurchaseStart를 사용하여 처리할 수 있지만, 구매가 시작되기 전에 처리할 수 있습니다.

00:15:50.000 --> 00:15:56.000
이것은 디밍 컨트롤과 같이 구매가 실행되는 동안 일부 UI 구성 요소를 업데이트하려는 경우 유용합니다.

00:15:56.000 --> 00:16:02.000
당신이 여기에 제공하는 기능은 매개 변수로 구매할 제품을 받습니다.

00:16:02.000 --> 00:16:13.000
이러한 수정자를 사용할 때, 그들이 모든 하위 ProductView, StoreView 또는 SubscriptionStoreView 인스턴스의 이벤트를 처리할 것이라는 것을 아는 것이 중요합니다.

00:16:13.000 --> 00:16:17.000
여러 수정자를 추가하면, 모든 작업이 각 이벤트에 대해 실행됩니다.

00:16:17.000 --> 00:16:21.000
명심하세요, 이 수정자를 사용하는 것은 전적으로 선택 사항입니다.

00:16:21.000 --> 00:16:33.000
기본적으로 StoreKit 뷰의 성공적인 트랜잭션은 Transaction.updates 시퀀스에서 방출되지만, 결과를 직접 처리하기 위해 onInAppPurchaseCompletion을 추가할 수 있는 옵션이 있습니다.

00:16:33.000 --> 00:16:38.000
이 수정자 중 하나에 nil을 전달하여 기본 동작으로 되돌릴 수 있습니다.

00:16:38.000 --> 00:16:43.000
이제, Backyard Birds Pass 구독 처리에 대해 이야기해 봅시다.

00:16:43.000 --> 00:16:50.000
새로운 뷰 API 외에도, StoreKit에는 SwiftUI에서 데이터 종속성을 선언하기 위한 새로운 뷰 수정자가 있습니다.

00:16:50.000 --> 00:16:56.000
먼저, 패스를 쉽게 잠금 해제하는 데 사용할 수 있는 subscriptionStatusTask를 다룰 것입니다.

00:16:56.000 --> 00:17:02.000
구독에 따라 어떤 관점에서든, 우리는 subscriptionStatusTask 수정자를 추가할 수 있습니다.

00:17:02.000 --> 00:17:14.000
뒷마당 그리드부터 시작합시다. 왜냐하면 여기가 우리가 구독 제안 시트를 열 수 있는 버튼을 보여주는 곳이기 때문입니다.

00:17:14.000 --> 00:17:20.000
subscriptionStatusTask 수정자는 우리가 의존하는 구독의 그룹 ID를 취합니다.

00:17:20.000 --> 00:17:25.000
이것은 우리가 이전에 SubscriptionStoreView를 선언했을 때 사용한 것과 동일한 그룹 ID입니다.

00:17:25.000 --> 00:17:36.000
이제, 백야드 그리드가 나타날 때마다, 백그라운드 작업은 구독 상태를 로드한 다음 작업이 완료되면 우리가 제공하는 기능을 호출합니다.

00:17:36.000 --> 00:17:55.000
이 API를 사용하는 가장 좋은 방법은 우리의 경우 BirdBrain 액터인 비즈니스 로직에 상태를 전달한 다음 액터가 데이터를 처리하고 UI 코드에서 작업하기 쉬운 모델 유형을 반환하도록 하는 것입니다.

00:17:55.000 --> 00:18:07.000
나는 이 패스 상태 열거형을 만들었기 때문에, 이것을 할당할 주 재산을 만들 것이다.

00:18:07.000 --> 00:18:18.000
그런 다음, 우리는 누군가가 현재 구독하지 않은 경우에만 구독 제안 카드를 표시하도록 선택할 수 있습니다.

00:18:18.000 --> 00:18:23.000
이러한 빠른 추가를 통해, 우리는 이제 아직 구독하지 않은 조류 관찰자에게만 제안 카드를 보여줄 것입니다.

00:18:23.000 --> 00:18:31.000
StoreKit은 상태가 변경될 때 우리의 기능을 호출할 것이므로, 우리의 견해는 항상 최신 정보를 반영할 것입니다.

00:18:31.000 --> 00:18:44.000
앱 전체에서 동일한 패턴을 사용하여 Backyard Birds Pass 콘텐츠의 잠금을 해제할 수 있으며, onInAppPurchaseCompletion 수정자를 사용하여 성공적인 구독 후 Pass Shop 시트를 자동으로 해제할 수 있습니다.

00:18:44.000 --> 00:18:55.000
나는 이미 이 부분을 일찍 완료했으니, 아이폰 시뮬레이터에서 앱을 실행하고 이 모든 것을 테스트해 봅시다.

00:18:55.000 --> 00:19:02.000
그냥 체크 아웃을 탭하고 무료 체험을 누를게요.

00:19:02.000 --> 00:19:09.000
결제 시트가 나타나고, 구독을 탭한 다음 알림을 해제할 수 있습니다.

00:19:09.000 --> 00:19:15.000
제안 시트가 어떻게 자동으로 무시되고, 제안 카드도 숨겨져 있는지 보세요.

00:19:15.000 --> 00:19:25.000
구독 상태 작업이 상태가 변경될 때마다 기능을 다시 호출하기 때문에 앱의 UI가 항상 최신 상태인지 확인할 수 있습니다.

00:19:25.000 --> 00:19:35.000
우리가 이 주제에 있는 동안, 당신의 앱이 비소모품 또는 비갱신 구독을 제공하는 경우, subscriptionStatusTask만큼 쉽게 자격을 확인할 수 있는 새로운 API가 있습니다.

00:19:35.000 --> 00:19:51.000
currentEntitlementTask 수정자를 사용하여 제품 ID의 현재 권한에 따라 보기를 선언할 수 있으며, 시스템은 비동기적으로 현재 권한을 로드하고 변경될 때마다 현재 권한으로 함수를 호출합니다.

00:19:51.000 --> 00:19:59.000
subscriptionStatusTask와 currentEntitlementTask 모두에 제공하는 기능은 권한 작업 상태를 매개 변수로 사용합니다.

00:19:59.000 --> 00:20:09.000
그렇게 하면, 자격이 여전히 로드되고 있을 때, 로드되지 않을 때, 그리고 자격이 성공적으로 로드되었을 때 사례를 세밀하게 처리하도록 선택할 수 있습니다.

00:20:09.000 --> 00:20:15.000
이 새로운 StoreKit 보기가 Backyard Birds에서 인앱 구매 통합을 간소화하는 데 어떻게 도움이 되는지 다루었습니다.

00:20:15.000 --> 00:20:25.000
이제, 저는 조금 더 깊이 들어가서 SwiftUI를 위한 모든 새로운 StoreKit API로 이러한 견해를 한 단계 더 발전시킬 수 있는 방법을 보여주고 싶습니다.

00:20:25.000 --> 00:20:30.000
먼저, ProductView와 StoreView의 아이콘을 설정하기 위한 더 많은 옵션을 살펴보겠습니다.

00:20:30.000 --> 00:20:34.000
그런 다음, 제품 보기 스타일링에 대해 자세히 알아보겠습니다.

00:20:34.000 --> 00:20:41.000
그 후, StoreView와 SubscriptionStoreView에 공통 기능이 있는 버튼을 추가하는 방법을 다룰 것입니다.

00:20:41.000 --> 00:20:49.000
마지막으로, 구독 스토어 뷰가 브랜드의 모양과 느낌에 맞게 사용할 수 있는 다양한 새로운 API를 살펴보겠습니다.

00:20:49.000 --> 00:20:51.000
장식 아이콘에 들어가자.

00:20:51.000 --> 00:21:00.000
아이콘을 제공할 때, 표준 제품 보기 스타일은 모두 왼쪽에서 볼 수 있는 것과 같이 제품이 로드되는 동안 자리 표시자 아이콘을 표시합니다.

00:21:00.000 --> 00:21:05.000
때때로 자동 아이콘은 실제 아이콘이 될 것으로 예상하는 것과 정확히 맞지 않습니다.

00:21:05.000 --> 00:21:13.000
예를 들어, iPhone에서 자동 자리 표시자는 정사각형이지만, 우리는 Bird Food 제품에 원 아이콘을 사용합니다.

00:21:13.000 --> 00:21:21.000
자리 표시자에 사용할 아이콘으로 ProductView에 두 번째 후행 클로저를 추가하여 이 모양을 쉽게 개선할 수 있습니다.

00:21:21.000 --> 00:21:25.000
이 경우, 나는 방금 자리 표시자를 위한 원을 제공했다.

00:21:25.000 --> 00:21:33.000
App Store Connect에서 App Store 프로모션 이미지를 설정하면, ProductView가 SwiftUI 보기 대신 동일한 이미지를 사용하도록 할 수 있습니다.

00:21:33.000 --> 00:21:38.000
prefersPromotionalIcon 매개 변수를 true로 설정하세요.

00:21:38.000 --> 00:21:45.000
여전히 SwiftUI 보기를 대안으로 제공할 수 있지만, 제품에 프로모션 아이콘이 있는 한 이 보기는 무시됩니다.

00:21:45.000 --> 00:21:56.000
프로모션 아이콘을 설정하는 방법을 알아보려면 "StoreKit 2의 새로운 기능 및 Xcode의 StoreKit 테스트"와 "App Store Connect의 새로운 기능"을 확인하세요.

00:21:56.000 --> 00:22:06.000
App Store의 프로모션 아이콘을 사용하고 싶지 않더라도, SwiftUI에 선언된 아이콘에 대해 멋진 인앱 구매 아이콘 처리를 사용할 수 있습니다.

00:22:06.000 --> 00:22:12.000
이 테두리를 보기에 추가하려면 아이콘에 제공하는 보기에 이 수정자를 추가하세요.

00:22:12.000 --> 00:22:15.000
그것은 모두 제품 보기의 아이콘에 관한 것이다.

00:22:15.000 --> 00:22:22.000
스토어 뷰 아이콘으로 모든 작업을 수행할 수 있는 해당 API가 있다는 것을 명심하세요.

00:22:22.000 --> 00:22:26.000
이제, 제품 보기 스타일링에 대해 이야기해 봅시다.

00:22:26.000 --> 00:22:33.000
세션 초반에, 나는 당신이 맞춤형 제품 보기 스타일을 만들 수 있다고 말했고, 마침내 당신에게 방법을 보여줄 시간입니다.

00:22:33.000 --> 00:22:40.000
제품 보기의 외관, 레이아웃 동작 및 상호 작용은 사용하는 스타일에 의해 완전히 정의됩니다.

00:22:40.000 --> 00:22:48.000
그래서, 당신이 원하는 것에 맞는 표준 스타일을 찾을 수 없다면, 언제든지 자신만의 맞춤형 제품 보기 스타일을 만들 수 있습니다.

00:22:48.000 --> 00:22:55.000
우리가 살펴볼 첫 번째 사례는 표준 스타일로 구성된 사용자 지정 스타일을 만드는 것이므로 처음부터 완전히 시작하지 않습니다.

00:22:55.000 --> 00:23:03.000
예를 들어, 로드하는 동안 제품 보기가 표준 자리 표시자 모양 대신 진행 스피너를 표시하려면 어떻게 해야 하나요?

00:23:03.000 --> 00:23:10.000
사용자 지정 스타일을 만드는 첫 번째 단계는 ProductViewStyle 프로토콜을 준수하는 유형을 만드는 것입니다.

00:23:10.000 --> 00:23:15.000
프로토콜을 구현하기 위한 유일한 요구 사항은 이 makeBody 방법이다.

00:23:15.000 --> 00:23:23.000
makeBody 메소드에 전달된 구성 값에는 우수한 제품 보기를 선언하는 데 필요한 모든 속성이 있습니다.

00:23:23.000 --> 00:23:29.000
예를 들어, 그것은 제품을 적재하는 다른 상태를 다루는 상태 열거를 가지고 있다.

00:23:29.000 --> 00:23:34.000
로딩 모양을 사용자 정의하려면, 로딩 상태에 대한 ProgressView를 선언하기만 하면 됩니다.

00:23:34.000 --> 00:23:44.000
그런 다음 구성을 ProductView 인스턴스로 전달하기만 하면 다른 상태에 대한 표준 ProductView 동작으로 대체할 수 있습니다.

00:23:44.000 --> 00:23:52.000
productViewStyle 수정자에 전달하여 표준 스타일과 같은 방식으로 사용자 지정 스타일을 적용합니다.

00:23:52.000 --> 00:23:58.000
물론, 표준 스타일로 맞춤 스타일을 구성할 필요는 없습니다.

00:23:58.000 --> 00:24:03.000
makeBody 메소드의 다른 뷰를 사용하여 언제든지 스타일을 정의할 수 있습니다.

00:24:03.000 --> 00:24:09.000
작업 상태가 성공하면, 뷰가 나타내는 제품 값에 액세스할 수 있습니다.

00:24:09.000 --> 00:24:14.000
앱이 StoreKit 2를 사용하는 경우 이미 사용했던 것과 동일한 제품 가치입니다.

00:24:14.000 --> 00:24:19.000
제품의 모든 속성을 사용하여 보기를 만들 수 있습니다.

00:24:19.000 --> 00:24:24.000
구성은 또한 장식 아이콘에 접근할 수 있게 해준다.

00:24:24.000 --> 00:24:32.000
구매 버튼을 추가할 때, 제품 값이 아닌 구성 값에 대한 구매 방법을 사용해야 합니다.

00:24:32.000 --> 00:24:47.000
구성에서 방법을 사용하면 기본 구매 옵션이 추가되어 결제 확인 시트가 제품 보기 근처에 표시되도록 하고 onInAppPurchaseCompletion과 같은 반응 수정자를 트리거합니다.

00:24:47.000 --> 00:24:57.000
기억하세요: 사용자 지정 스타일이 처음부터 구축될 때, 이 스타일을 사용하는 제품 뷰의 모양과 동작은 스타일을 구축하기 위해 구성한 뷰와 일치합니다.

00:24:57.000 --> 00:25:10.000
사용자 지정 스타일을 만드는 것은 App Store 데이터 흐름과 같은 제품 보기를 위한 모든 인프라를 활용할 수 있는 좋은 방법이며, 원하는 모양과 행동을 자유롭게 선언할 수 있습니다.

00:25:10.000 --> 00:25:15.000
로딩하는 동안, 우리가 Bird Food Shop을 위해 만든 UI는 각 제품의 자리 표시자 모양을 보여줍니다.

00:25:15.000 --> 00:25:19.000
하지만 우리가 오른쪽에 있는 이 로딩 스피너와 같은 모습을 원한다면 어떨까요?

00:25:19.000 --> 00:25:22.000
이 문제에 대한 해결책은 상태를 높이는 것이다.

00:25:22.000 --> 00:25:25.000
여기서 내 말이 무슨 뜻인지 설명할게.

00:25:25.000 --> 00:25:30.000
이 다이어그램은 우리가 이전에 만든 BirdFoodShop의 계층 구조를 나타낸다.

00:25:30.000 --> 00:25:34.000
BirdFoodShop에는 여러 ProductView 후손이 있다.

00:25:34.000 --> 00:25:42.000
제품 ID로 ProductView를 초기화할 때, 각 보기는 로딩 작업이 비동기적이기 때문에 내부적으로 제품의 상태를 유지합니다.

00:25:42.000 --> 00:25:51.000
제품이 로딩되는 동안 부모 BirdFoodShop이 다른 모습을 보여주는 효과를 만들고 싶다면, 당신의 상태를 부모 BirdFoodShop으로 들어 올려야 합니다.

00:25:51.000 --> 00:26:04.000
부모 BirdFoodShop이 제품의 상태를 관리하면, 데이터가 로드되는 동안 모양을 자유롭게 변경한 다음 ID 대신 사전 로드된 제품 값을 사용하여 ProductView 인스턴스를 만들 수 있습니다.

00:26:04.000 --> 00:26:14.000
우리는 지금까지 제품 ID로 제품 보기를 만드는 것만 다루었지만, 이미 ProductView에 로드한 제품 값을 전달할 수 있다는 것을 아는 것이 중요합니다.

00:26:14.000 --> 00:26:19.000
이로 인해 제품 보기는 로딩을 건너뛰고 머천다이징 보기를 직접 배치합니다.

00:26:19.000 --> 00:26:27.000
당신은 생각할 수도 있습니다: 그것은 모두 멋지지만, 그렇게 하기 위해, 이제 저는 제 자신의 제품 요청과 캐싱 논리를 작성해야 합니다.

00:26:27.000 --> 00:26:38.000
음, StoreKit 뷰의 내부를 뷰 수정자로 노출하고 있다는 것을 알게 되어 기쁠 것이므로, 제품 ID의 메타데이터에 의존하는 모든 뷰를 선언할 수 있습니다.

00:26:38.000 --> 00:26:43.000
StoreKit은 당신을 위해 제품을 로딩하고, 캐싱하고, 최신 상태로 유지하는 것을 처리할 것입니다.

00:26:43.000 --> 00:26:48.000
이렇게 하려면, 새로운 storeProductsTask 수정자를 사용하세요.

00:26:48.000 --> 00:26:56.000
이전에 다루었던 subscriptionStatusTask와 마찬가지로, 당신은 보기에 의존할 수 있는 제품 ID 모음을 전달합니다.

00:26:56.000 --> 00:27:00.000
그런 다음, 비동기 작업의 상태를 처리하는 데 사용할 수 있는 상태 값을 얻을 수 있습니다.

00:27:00.000 --> 00:27:07.000
우리가 방금 사용자 지정 ProductViewStyle 구현을 살펴본 후에 이것은 모두 꽤 친숙하게 느껴질 것이다.

00:27:07.000 --> 00:27:12.000
여기에서, 우리는 로딩에 대한 로딩 뷰를 보여줄 수 있습니다....

00:27:12.000 --> 00:27:21.000
제품을 사용할 수 없는 경우 새로운 ContentUnavailableView를 사용하세요... 아니면 미리 로드된 제품 값으로 BirdFoodShop을 직접 보여주세요.

00:27:21.000 --> 00:27:23.000
그렇게 쉬워.

00:27:23.000 --> 00:27:30.000
쉬운 얘기가 말하자면, 인앱 구매 머천다이징 UI에 포함할 수 있는 몇 가지 유용한 일반적인 행동이 있습니다.

00:27:30.000 --> 00:27:37.000
StoreView와 SubscriptionStoreView를 사용하면 이러한 일반적인 작업을 위한 보조 버튼을 정말 쉽게 추가할 수 있습니다.

00:27:37.000 --> 00:27:44.000
내가 보조 버튼에 대해 이야기할 때, 나는 뷰의 주요 목적을 지원하는 작업을 수행하는 버튼을 의미한다.

00:27:44.000 --> 00:27:53.000
예를 들어, 이 취소 버튼과 코드 교환 버튼은 둘 다 패스 구독에 보조적입니다.

00:27:53.000 --> 00:28:00.000
우리는 이미 이 시트를 처음 만들 때 storeButton 수정자를 사용하여 코드 교환 버튼을 추가하는 것을 보았습니다.

00:28:00.000 --> 00:28:03.000
이 뷰 수정자를 자세히 살펴봅시다.

00:28:03.000 --> 00:28:07.000
여기에 두 매개 변수 각각에 대해 전달할 수 있는 몇 가지 값이 있습니다.

00:28:07.000 --> 00:28:11.000
첫 번째 매개 변수를 사용하면 가시성을 선택할 수 있습니다.

00:28:11.000 --> 00:28:18.000
자동은 모든 버튼의 기본값이며, StoreKit은 상황에 따라 버튼을 표시할지 여부를 선택할 수 있습니다.

00:28:18.000 --> 00:28:23.000
버튼을 명시적으로 표시하거나 숨기도록 선택할 수도 있습니다.

00:28:23.000 --> 00:28:29.000
다음 매개 변수를 사용하면 가시성을 구성할 버튼 종류를 선택할 수 있습니다.

00:28:29.000 --> 00:28:34.000
취소 버튼은 보기를 해제하기 위한 플랫폼에 적합한 버튼을 보여줍니다.

00:28:34.000 --> 00:28:38.000
이 버튼은 StoreView와 SubscriptionStoreView 모두에서 작동합니다.

00:28:38.000 --> 00:28:44.000
취소 버튼의 자동 동작은 보기가 표시될 때마다 표시되는 것입니다.

00:28:44.000 --> 00:28:52.000
오른쪽에, 구독 스토어 보기는 시트로 표시되므로 오른쪽 상단에 취소 버튼이 자동으로 표시됩니다.

00:28:52.000 --> 00:28:58.000
왼쪽에는 보기가 시트로 표시되지 않으므로 취소 버튼이 없습니다.

00:28:58.000 --> 00:29:04.000
물론, 이 동작을 무시하고 표시될 때 취소 버튼을 숨길 수 있습니다.

00:29:04.000 --> 00:29:11.000
취소 버튼을 자신의 취소 버튼으로 교체할 때만 이것을 하고 싶다는 것을 명심하세요.

00:29:11.000 --> 00:29:19.000
프레젠테이션을 해제할 수 있는 명확한 버튼으로 항상 머천다이징 UI를 동반하는 것이 좋습니다.

00:29:19.000 --> 00:29:26.000
취소 버튼과 마찬가지로, 스토어 보기와 구독 스토어 보기 모두 구매 복원 버튼을 표시할 수 있습니다.

00:29:26.000 --> 00:29:35.000
기본적으로 구매 복원 버튼은 항상 숨겨져 있지만, storeButton 수정자를 사용하여 머천다이징 UI에 표시하도록 선택할 수 있습니다.

00:29:35.000 --> 00:29:40.000
다음 세 가지 버튼 종류는 SubscriptionStoreView 전용입니다.

00:29:40.000 --> 00:29:43.000
우리는 이미 redeemCode 버튼에 대해 이야기했습니다.

00:29:43.000 --> 00:29:45.000
다음 버튼 종류는 로그인 버튼입니다.

00:29:45.000 --> 00:29:56.000
구독 서비스를 통해 사람들이 App Store 외부에서 구독할 수 있는 경우, 기존 구독자가 구독에 액세스해야 할 경우를 대비하여 로그인 버튼을 표시하는 것이 좋습니다.

00:29:56.000 --> 00:30:05.000
로그인 버튼에 대해 알아야 할 중요한 점은 새로운 subscriptionStoreSignInAction 수정자를 사용하여 로그인 작업을 선언해야 한다는 것입니다.

00:30:05.000 --> 00:30:11.000
로그인 동작을 설정하면, 로그인 버튼이 자동으로 표시됩니다.

00:30:11.000 --> 00:30:20.000
로그인 버튼은 단순히 subscriptionStoreSignInAction으로 선언한 기능을 호출하므로, 이것을 신호로 사용하여 로그인 흐름을 실행할 수 있습니다.

00:30:20.000 --> 00:30:23.000
검토해야 할 마지막 버튼 종류는 정책이다.

00:30:23.000 --> 00:30:33.000
구독 제안과 함께 서비스 약관 및 개인 정보 보호 정책에 대한 링크를 보여주고 싶을 수도 있으며, SubscriptionStoreView를 사용하면 이를 정말 쉽게 할 수 있습니다.

00:30:33.000 --> 00:30:36.000
일반적으로 정책 버튼은 기본적으로 숨겨져 있다.

00:30:36.000 --> 00:30:43.000
storeButton 수정자로 표시하면 iOS 및 Mac의 구독 컨트롤 위에 표시됩니다.

00:30:43.000 --> 00:30:50.000
이 버튼들은 컨테이너 배경 위에 표시되기 때문에, 기본 스타일은 배경에서 읽을 수 없을 수 있습니다.

00:30:50.000 --> 00:31:00.000
subscriptionStorePolicyForegroundStyle을 사용하여 배경에서 읽을 수 있는 정책 버튼에 사용할 모양 스타일을 설정하십시오.

00:31:00.000 --> 00:31:11.000
storeButton 수정자로 보조 버튼을 구성하면 몇 가지 간단한 선언만으로 머천다이징 UI에 강력한 기능을 추가할 수 있습니다.

00:31:11.000 --> 00:31:18.000
세션 초반에, 우리는 Backyard Birds의 모양과 느낌과 일치하도록 구독 스토어 뷰의 스타일을 구성했습니다.

00:31:18.000 --> 00:31:21.000
이제, 저는 이 스타일의 API를 더 자세히 살펴보고 싶습니다.

00:31:21.000 --> 00:31:25.000
먼저, 제어 스타일을 선택하는 것을 살펴봅시다.

00:31:25.000 --> 00:31:33.000
자동으로, SubscriptionStoreView는 당신이 머천다이징하는 구독의 종류에 따라 제어 스타일을 선택합니다.

00:31:33.000 --> 00:31:40.000
새로운 subscriptionStoreControlStyle 수정자를 사용하여 구독 계획에 사용할 컨트롤 스타일을 선택할 수 있습니다.

00:31:40.000 --> 00:31:46.000
예를 들어, 자동 선택기 대신 계획당 버튼을 선택할 수 있습니다.

00:31:46.000 --> 00:31:50.000
다양한 스타일의 컨트롤에 대해 이야기해 봅시다.

00:31:50.000 --> 00:31:56.000
스타일을 지정하지 않으면, 구독 스토어 보기는 자동으로 컨트롤을 선택합니다.

00:31:56.000 --> 00:32:01.000
iPhone에서, 이것은 여러 요금제 옵션이 있는 구독을 위한 피커 컨트롤입니다.

00:32:01.000 --> 00:32:05.000
피커 컨트롤을 명시적으로 선택할 수도 있습니다.

00:32:05.000 --> 00:32:15.000
iOS와 Mac에는 그림자와 선택 링으로 구독 계획 옵션을 더 눈에 띄게 표시하는 눈에 띄는 선택기 컨트롤이 있습니다.

00:32:15.000 --> 00:32:22.000
마지막으로, 선택기 컨트롤 대신 각 구독 계획에 대한 버튼을 표시하도록 선택할 수 있습니다.

00:32:22.000 --> 00:32:28.000
구독 버튼 주제에는 버튼 라벨을 사용자 정의하는 데 사용할 수 있는 새로운 API가 있습니다.

00:32:28.000 --> 00:32:38.000
기본적으로 SubscriptionStoreView는 작업 문구와 가격 정보가 포함된 구독 버튼을 버튼 위의 캡션으로 표시합니다.

00:32:38.000 --> 00:32:50.000
subscriptionStoreButtonLabel 수정자를 추가하여 버튼 라벨을 멀티라인으로 변경할 수 있으며, 이로 인해 가격 텍스트가 별도의 캡션이 아닌 버튼 라벨에 포함될 수 있습니다.

00:32:50.000 --> 00:32:56.000
버튼 라벨의 레이아웃을 사용자 정의하는 것 외에도 콘텐츠를 사용자 정의할 수도 있습니다.

00:32:56.000 --> 00:33:03.000
예를 들어, 작업 문구 대신 선택한 구독의 표시 이름을 표시하도록 선택할 수 있습니다.

00:33:03.000 --> 00:33:12.000
이와 같이 구성 요소를 함께 연결하여 레이아웃과 콘텐츠 모두로 버튼 라벨 값을 구성할 수도 있습니다.

00:33:12.000 --> 00:33:21.000
버튼 컨트롤은 피커 컨트롤과 동일한 구독 버튼으로 구성되어 있기 때문에, 동일한 수정자를 사용하여 이러한 버튼을 사용자 정의할 수도 있습니다.

00:33:21.000 --> 00:33:25.000
예를 들어, 라벨에 가격만 표시하도록 선택할 수 있습니다.

00:33:25.000 --> 00:33:30.000
이것은 당신의 계획이 모두 같은 서비스이지만 가격대가 다를 때 유용합니다.

00:33:30.000 --> 00:33:38.000
다른 구독 계획은 App Store Connect에서 설정한 표시 이름과 설명을 사용하여 컨트롤을 구축합니다.

00:33:38.000 --> 00:33:44.000
이러한 컨트롤을 더 흥미롭게 만들기 위해, 각 다른 계획에 대한 장식 보기를 추가하도록 선택할 수 있습니다.

00:33:44.000 --> 00:33:51.000
장식 보기를 추가하려면, 구독 스토어에 subscriptionStoreControlIcon 수정자를 추가하기만 하면 됩니다.

00:33:51.000 --> 00:33:54.000
수정자는 뷰 빌더를 취한다.

00:33:54.000 --> 00:34:00.000
그것은 뷰 빌더에 제품 값과 SubscriptionInfo 값을 모두 제공한다.

00:34:00.000 --> 00:34:06.000
이 매개 변수를 사용하면 각 계획에 대해 다른 보기를 제공할 수 있습니다.

00:34:06.000 --> 00:34:11.000
이 아이콘들은 구독 계획에 버튼 제어 스타일을 사용할 때도 작동합니다.

00:34:11.000 --> 00:34:16.000
이제, 구독 스토어 보기에 배경 콘텐츠를 추가하는 것에 대해 좀 더 자세히 살펴봅시다.

00:34:16.000 --> 00:34:26.000
이전에서 요약하려면, containerBackground 수정자로 마케팅 콘텐츠를 수정하여 구독 스토어에 컨테이너 배경을 추가할 수 있습니다.

00:34:26.000 --> 00:34:34.000
이 경우, 우리는 배경에 악센트 색상의 그라디언트를 제공하고 구독 스토어에 배치하도록 선택합니다.

00:34:34.000 --> 00:34:41.000
"SwiftUI의 새로운 기능" 세션에서 새로운 컨테이너 배경 API에 대해 자세히 알아볼 수 있습니다.

00:34:41.000 --> 00:34:45.000
구독 스토어에 사용할 수 있는 몇 가지 배경 배치가 있습니다.

00:34:45.000 --> 00:34:51.000
구독 스토어 배치를 사용하면, 상황에 따라 자동 배치를 선택합니다.

00:34:51.000 --> 00:34:58.000
iOS와 Mac에서는 구독 스토어의 헤더에 배경을 배치할 것을 명시적으로 지정할 수 있습니다.

00:34:58.000 --> 00:35:02.000
이 배치는 당신의 마케팅 콘텐츠 뒤에 있습니다.

00:35:02.000 --> 00:35:09.000
구독 스토어 뷰의 전체 높이 뒤에 배경을 배치하는 전체 높이 배치도 있습니다.

00:35:09.000 --> 00:35:18.000
세션 초반에, 우리는 Get Backyard Birds Pass 시트를 제시하지 않기 위해 구독 상태 작업과 같은 API를 사용하는 방법에 대해 논의했습니다.

00:35:18.000 --> 00:35:29.000
그러나, 기존 구독자에게 구독 스토어 보기를 보여주고 싶은 경우가 있으며, 구독자가 프리미엄 요금제로 업그레이드하도록 장려하고 싶을 때입니다.

00:35:29.000 --> 00:35:41.000
구독자가 현재 프리미엄보다 서비스 수준이 낮은 요금제에 가입되어 있음을 감지하면, 업그레이드를 visibleRelationships 매개 변수로 전달하여 업그레이드 시트를 제시할 수 있습니다.

00:35:41.000 --> 00:35:48.000
이것은 우리가 원하는 구독 관계의 조합일 수 있으며, 누군가가 현재 구독할 때만 영향을 미칩니다.

00:35:48.000 --> 00:35:58.000
그런 다음, 제안을 더 효과적으로 만들기 위해, 우리는 프리미엄 플랜의 이점을 설명하기 위해 마케팅 콘텐츠에 대한 다른 견해를 제공할 수 있습니다.

00:35:58.000 --> 00:36:07.000
subscriptionStatusTask를 사용하여 구독자의 서비스 수준을 추적한 다음, 이 정보를 사용하여 고객에게 어떤 제안을 제시할지 알 수 있습니다.

00:36:07.000 --> 00:36:10.000
그게 내가 오늘 다뤄야 할 전부야.

00:36:10.000 --> 00:36:16.000
앱에 인앱 구매를 추가하기 시작할 때, StoreView를 선언하여 빠르게 시작하고 실행하세요.

00:36:16.000 --> 00:36:20.000
좀 더 맞춤화된 레이아웃을 원한다면, ProductView를 시도해 보세요.

00:36:20.000 --> 00:36:26.000
구독의 경우, SubscriptionStoreView를 선언하여 매력적인 제안을 만들 수 있습니다.

00:36:26.000 --> 00:36:34.000
그리고 다음 단계로 넘어갈 준비가 되면, 새로운 뷰 수정자와 다른 API를 사용해 보세요.

00:36:34.000 --> 00:36:46.000
StoreKit과 SwiftUI를 충분히 얻을 수 없다면, "StoreKit 2의 새로운 기능 및 Xcode의 StoreKit 테스트"와 "SwiftUI의 새로운 기능" 세션을 확인하세요.

00:36:46.000 --> 00:36:50.000
오늘 저와 함께 SwiftUI를 위한 새로운 StoreKit API에 대해 알아봐 주셔서 감사합니다.

00:36:50.000 --> 00:36:52.000
행복한 코딩!

00:36:52.000 --> 23:59:59.000
.

