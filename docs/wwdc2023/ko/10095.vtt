WEBVTT

00:00:00.000 --> 00:00:04.000
♪ 부드러운 기악 힙합 ♪

00:00:04.000 --> 00:00:10.000
♪

00:00:10.000 --> 00:00:14.000
안녕! 저는 이반이고, RealityKit 팀의 엔지니어입니다.

00:00:14.000 --> 00:00:19.000
제 세션에 오신 것을 환영합니다, "공간 컴퓨팅을 위한 렌더링을 살펴보세요."

00:00:19.000 --> 00:00:24.000
RealityKit은 3D 모델을 렌더링, 애니메이션 및 시뮬레이션하기 위한 프레임워크입니다.

00:00:24.000 --> 00:00:31.000
RealityKit의 가장 강력한 정장 중 하나는 콘텐츠에 사실적인 렌더링을 적용하는 것입니다.

00:00:31.000 --> 00:00:45.000
RealityKit의 렌더링 기능을 최대한 활용하고 콘텐츠의 모양을 향상시킬 수 있도록, 공간 컴퓨팅용 앱을 개발하는 동안 명심해야 할 몇 가지 렌더링 고려 사항을 공유하고 싶었습니다.

00:00:45.000 --> 00:00:49.000
우리는 당신의 3D 콘텐츠를 위한 조명과 그림자로 시작할 것입니다.

00:00:49.000 --> 00:00:53.000
그런 다음 우리는 RealityKit 자료의 새로운 것을 배울 것입니다.

00:00:53.000 --> 00:00:59.000
다음으로, 나는 시스템 성능을 크게 향상시키는 래스터화 속도 맵을 소개할 것이다.

00:00:59.000 --> 00:01:06.000
이 최적화와 잘 작동하도록 콘텐츠를 조정하는 방법에 대한 권장 사항을 공유하겠습니다.

00:01:06.000 --> 00:01:14.000
마지막으로, 저는 UI가 항상 선명하도록 보장하는 동적 콘텐츠 스케일링이라는 기술을 소개할 것입니다.

00:01:14.000 --> 00:01:17.000
조명과 그림자부터 시작합시다.

00:01:17.000 --> 00:01:26.000
iOS와 macOS에서 RealityKit에 익숙하다면, 그 지식의 대부분이 공간 경험을 구축하는 데에도 적용된다는 것을 알게 될 것입니다.

00:01:26.000 --> 00:01:32.000
우리는 당신의 콘텐츠를 사실적으로 보이게 하기 위해 RealityKit에 이미지 기반 조명을 도입했습니다.

00:01:32.000 --> 00:01:41.000
이미지 기반 조명 또는 IBL은 현실적인 반사를 생성하기 위해 오른쪽에 있는 것과 같은 질감을 사용합니다.

00:01:41.000 --> 00:01:47.000
그림자는 물체가 서로에 대해 어떻게 배치되는지 이해하는 데 도움을 준다.

00:01:47.000 --> 00:01:54.000
새로운 기능을 살펴보기 전에, 이미지 기반 조명의 구성 요소를 빠르게 살펴봅시다.

00:01:54.000 --> 00:02:10.000
IBL에는 두 가지 주요 구성 요소가 있습니다: ARKit에서 제공하고 방의 물리적 공간에 특화된 환경 프로브 텍스처와 OS와 함께 패키지된 시스템 IBL 텍스처.

00:02:10.000 --> 00:02:17.000
시스템 IBL 텍스처는 어떤 환경에서도 콘텐츠가 멋지게 보이도록 추가 하이라이트를 추가합니다.

00:02:17.000 --> 00:02:23.000
두 구성 요소는 결합된 IBL 질감을 생성하기 위해 함께 추가된다.

00:02:23.000 --> 00:02:29.000
활성 환경이 있다면, 결합된 IBL 텍스처에도 영향을 미칠 것입니다.

00:02:29.000 --> 00:02:36.000
올해 RealityKit은 조명을 사용자 정의하기 위해 시스템 IBL 텍스처를 재정의하는 기능을 추가합니다.

00:02:36.000 --> 00:02:40.000
예를 들어 봅시다.

00:02:40.000 --> 00:02:45.000
이것은 태양계의 전망을 제공하는 "Hello World" 경험이다.

00:02:45.000 --> 00:02:50.000
기본적으로 RealityKit은 시스템 IBL을 사용하여 그것을 밝힐 것이다.

00:02:50.000 --> 00:03:02.000
그러나, 새로운 이미지 기반 조명 구성 요소에 새로운 IBL을 할당하면, 시스템 IBL을 대체하고 주변 몰입 환경을 사용하여 그 물체를 밝힐 것입니다.

00:03:02.000 --> 00:03:05.000
그게 어떻게 됐는지 보여줄게.

00:03:05.000 --> 00:03:08.000
여기서 우리는 먼저 3D 콘텐츠를 로드합니다.

00:03:08.000 --> 00:03:11.000
이 경우, 그것은 위성 모델이다.

00:03:11.000 --> 00:03:15.000
그런 다음 우리는 햇빛이라는 환경 자원을 로드합니다.

00:03:15.000 --> 00:03:21.000
그것은 지구를 둘러싼 태양과 별의 이미지를 포함하고 있다.

00:03:21.000 --> 00:03:30.000
IBL을 설정하려면 모델과 환경 리소스가 모두 필요하므로, 두 로딩 작업이 모두 완료되었는지 확인해 봅시다.

00:03:30.000 --> 00:03:33.000
다음으로, 우리는 ImageBasedLightComponent를 추가합니다.

00:03:33.000 --> 00:03:38.000
그것은 우리가 방금 로드한 환경 자원을 참조한다.

00:03:38.000 --> 00:03:44.000
마지막으로 우리는 ImageBasedLightReceiverComponent를 위성 엔티티에 추가합니다.

00:03:44.000 --> 00:03:51.000
동일한 IBL을 사용하여 조명하기 위해 이러한 수신기 구성 요소를 다른 엔티티에도 추가할 수 있습니다.

00:03:51.000 --> 00:03:56.000
그리고 그것이 RealityKit에서 조명을 사용자 정의하는 것이 얼마나 쉬운지입니다.

00:03:56.000 --> 00:04:01.000
다음으로, 애플리케이션에 그림자를 추가하는 방법을 살펴봅시다.

00:04:01.000 --> 00:04:09.000
이 꽃병과 같은 3D 물체를 떠다니는 비행기 위에 놓는 간단한 예를 생각해 봅시다.

00:04:09.000 --> 00:04:16.000
그림자를 켜지 않으면, 꽃병과 비행기의 상대적인 위치를 이해하기 어려울 수 있다.

00:04:16.000 --> 00:04:25.000
하지만 단순히 RealityKit의 접지 그림자를 추가함으로써, 꽃병이 비행기의 중심 위에 있다는 것이 훨씬 더 명확해진다.

00:04:25.000 --> 00:04:28.000
코드로 이것을 어떻게 하는지 봅시다.

00:04:28.000 --> 00:04:31.000
우리는 꽃병 모델을 로딩하는 것으로 시작합니다.

00:04:31.000 --> 00:04:36.000
여기서, flower_tulip은 우리 프로젝트에서 3D 모델의 이름이다.

00:04:36.000 --> 00:04:40.000
다음으로, 우리는 접지 그림자 구성 요소를 추가합니다.

00:04:40.000 --> 00:04:43.000
castsShadow 플래그를 true로 설정해야 합니다.

00:04:43.000 --> 00:04:45.000
그리고 그게 다야!

00:04:45.000 --> 00:04:48.000
꽃병 개체는 이제 접지 그림자를 던질 것이다.

00:04:48.000 --> 00:04:49.000
간단하지, 그렇지 않아?

00:04:49.000 --> 00:04:56.000
접지 그림자는 물리적 환경의 물체뿐만 아니라 3D 모델 위에 나타난다.

00:04:56.000 --> 00:05:10.000
장면을 조명하고 접지 그림자를 포함하기 위해 사용자 지정 IBL을 사용하면 콘텐츠를 훨씬 더 잘 보이게 할 수 있지만, 재료를 조정하여 물체의 모양을 직접 작업할 수도 있습니다.

00:05:10.000 --> 00:05:17.000
macOS와 iOS에서 사용할 수 있는 대부분의 RealityKit 자료는 xrOS에서도 사용할 수 있습니다.

00:05:17.000 --> 00:05:20.000
그것들을 빨리 검토해 봅시다.

00:05:20.000 --> 00:05:24.000
가장 일반적으로 사용되는 재료는 PhysicallyBasedMaterial이다.

00:05:24.000 --> 00:05:35.000
RealityKit의 PhysicallyBasedMaterial은 조명에 반응하며 플라스틱이나 금속과 같은 다양한 실제 재료를 나타내는 데 사용할 수 있습니다.

00:05:35.000 --> 00:05:41.000
SimpleMaterial은 또한 조명에 반응하지만, 매개 변수의 더 작은 하위 집합을 사용합니다.

00:05:41.000 --> 00:05:45.000
그것은 특히 빠른 실험에 좋다.

00:05:45.000 --> 00:05:48.000
UnlitMaterial은 조명에 반응하지 않는다.

00:05:48.000 --> 00:05:54.000
다시 말해, 그것은 변화하는 조명 조건 하에서 일정한 모습을 유지한다.

00:05:54.000 --> 00:06:03.000
VideoMaterial은 영화 파일을 엔티티의 표면에 매핑할 수 있는 조명이 없는 자료의 변형이다.

00:06:03.000 --> 00:06:10.000
이러한 재료 외에도, RealityKit은 ShaderGraphMaterial이라는 새로운 유형의 재료를 소개합니다.

00:06:10.000 --> 00:06:19.000
Reality Composer Pro에서 새로운 ShaderGraphMaterial을 작성하거나 MaterialX 파일에서 로드할 수 있습니다.

00:06:19.000 --> 00:06:27.000
"Explore Materials in Reality Composer Pro" 세션에서 ShaderGraphMaterial에 대해 자세히 알아볼 수 있습니다.

00:06:27.000 --> 00:06:34.000
이 모든 재료의 색상 출력은 톤 매핑이라는 특별한 단계를 거칩니다.

00:06:34.000 --> 00:06:42.000
톤 매핑은 RealityKit이 재료의 색상 출력에 기본적으로 적용하는 변환입니다.

00:06:42.000 --> 00:06:47.000
그것은 다양한 기술을 사용하여 더 자연스러운 색상을 인식할 수 있게 해준다.

00:06:47.000 --> 00:06:52.000
그러한 기술 중 하나는 하나 이상의 값을 가시 범위로 다시 매핑하는 것이다.

00:06:52.000 --> 00:06:57.000
이것을 예시로 보여드리겠습니다.

00:06:57.000 --> 00:07:01.000
다음은 톤 매핑이 비활성화된 TV의 3D 렌더링입니다.

00:07:01.000 --> 00:07:06.000
나는 디스플레이에 매우 밝은 값을 가진 질감을 할당했다.

00:07:06.000 --> 00:07:14.000
이제, 톤 매핑을 활성화하면, 이 꽃잎과 같은 밝은 영역에서 더 많은 세부 사항을 볼 수 있습니다.

00:07:14.000 --> 00:07:27.000
톤 매핑은 일반적으로 잘 작동하며 아름다운 비주얼을 렌더링합니다. 그러나 일부 사용 사례의 경우, 톤 매핑을 거부해야 하는 개체의 정확한 색상을 표시해야 할 수도 있습니다.

00:07:27.000 --> 00:07:30.000
예를 들어 봅시다.

00:07:30.000 --> 00:07:37.000
여기 신호등과 "Stop", "Wait", "Go"라는 라벨이 있는 세 개의 버튼을 보여주는 간단한 응용 프로그램이 있습니다.

00:07:37.000 --> 00:07:44.000
신호등 자체는 3D 모델이며, 세 개의 버튼은 SwiftUI를 사용하여 추가되었다.

00:07:44.000 --> 00:07:59.000
램프의 색상을 버튼의 색상과 정확하게 맞추기 위해, 조명이 켜지지 않은 재료는 조명 조건과 관계없이 물체의 동일한 일정한 모양을 유지하기 때문에 램프에 조명이 켜지지 않은 재료를 사용할 수 있습니다.

00:07:59.000 --> 00:08:07.000
그러나, 조명이 켜지지 않은 재료의 출력은 여전히 모든 RealityKit 재료에 대해 기본적으로 켜져 있는 톤 매핑의 영향을 받습니다.

00:08:07.000 --> 00:08:16.000
따라서, 동일한 색상이 SwiftUI 버튼과 램프의 재료에 할당되더라도, 그것들은 서로 약간 다르게 보일 수 있습니다.

00:08:16.000 --> 00:08:26.000
당신이 보는 스크린샷은 톤 매핑이 활성화된 상태에서 촬영되었습니다. 램프 재료에 대해 톤 매핑이 비활성화되었을 때 어떻게 생겼는지 보여드리겠습니다.

00:08:26.000 --> 00:08:31.000
램프와 버튼의 색상이 정확하게 일치한다는 것을 알게 될 것입니다.

00:08:31.000 --> 00:08:35.000
램프 소재의 톤 매핑을 한 번 더 전환합시다.

00:08:35.000 --> 00:08:42.000
이것은 톤 매핑이 활성화되어 있고 톤 매핑이 비활성화되어 있습니다.

00:08:42.000 --> 00:08:48.000
코드에서 톤 매핑을 어떻게 전환할 수 있는지 보여주는 코드 샘플을 살펴봅시다.

00:08:48.000 --> 00:08:51.000
우리는 신호등 모델을 로딩하는 것으로 시작합니다.

00:08:51.000 --> 00:08:57.000
여기서, traffic_light는 우리 프로젝트에서 3D 모델의 이름이다.

00:08:57.000 --> 00:09:01.000
다음으로, 우리는 red_light라는 엔티티를 찾습니다.

00:09:01.000 --> 00:09:06.000
이 실체는 신호등의 상단 램프에 해당한다.

00:09:06.000 --> 00:09:10.000
일단 우리가 엔티티를 갖게 되면, 우리는 그것의 모델 구성 요소에 접근한다.

00:09:10.000 --> 00:09:13.000
다음으로, 우리는 새로운 조명되지 않은 재료를 만든다.

00:09:13.000 --> 00:09:21.000
우리는 원하는 색상과 applyPostProcessToneMap이라는 새로운 부울 매개 변수를 모두 전달합니다.

00:09:21.000 --> 00:09:30.000
이 부울 매개 변수는 이 자료에 대한 톤 매핑 변환을 비활성화하기 위해 false로 설정됩니다.

00:09:30.000 --> 00:09:37.000
마지막으로, 우리는 모델 구성 요소의 재료를 교체하고 모델 구성 요소를 엔티티에 다시 할당합니다.

00:09:37.000 --> 00:09:40.000
이것은 세 개의 램프 각각에 대해 이루어진다.

00:09:40.000 --> 00:09:46.000
이제 버튼의 색상과 램프의 색상이 밀접하게 일치해야 합니다.

00:09:46.000 --> 00:09:54.000
applyPostProcessToneMap 플래그는 장면에서 색상의 정확한 표현을 보여주고 싶은 경우에 유용합니다.

00:09:54.000 --> 00:10:01.000
이것은 RealityKit을 사용하여 메뉴나 헤드업 디스플레이와 같은 것을 만들 때 유용할 수 있습니다.

00:10:01.000 --> 00:10:08.000
이 새로운 속성은 Reality Composer Pro의 재료 편집기에도 노출되어 있다.

00:10:08.000 --> 00:10:11.000
이제, 몇 가지 품질 고려 사항을 살펴봅시다.

00:10:11.000 --> 00:10:16.000
우리는 공간 컴퓨팅을 위한 래스터화 속도 지도로 시작할 것이다.

00:10:16.000 --> 00:10:24.000
헤드셋에 사용되는 디스플레이는 고해상도이며, OS는 이 디스플레이를 초당 여러 번 업데이트해야 합니다.

00:10:24.000 --> 00:10:27.000
이걸 시각적으로 설명하겠습니다.

00:10:27.000 --> 00:10:34.000
이미 아시다시피, 헤드셋은 사람의 눈이 보고 있는 곳을 정확히 감지할 수 있습니다.

00:10:34.000 --> 00:10:41.000
여기 사람이 눈을 오른쪽으로 움직인 다음 중앙으로 돌아가는 시뮬레이션된 시나리오가 있습니다.

00:10:41.000 --> 00:10:46.000
노란색 원은 그 사람의 초점의 중심점을 나타낸다.

00:10:46.000 --> 00:10:52.000
그 지점을 둘러싸고 있는 지역은 빛으로 강조되고, 주변은 어두워진다.

00:10:52.000 --> 00:10:59.000
래스터화 속도 맵은 어두워진 지역에서 더 적은 계산이 수행되도록 한다.

00:10:59.000 --> 00:11:06.000
주어진 순간에 강조 표시된 영역이 주변부에 비해 작다는 것을 알 수 있습니다.

00:11:06.000 --> 00:11:12.000
이것은 시스템이 상당한 메모리와 성능 절감을 달성할 수 있게 해준다.

00:11:12.000 --> 00:11:17.000
RealityKit에서, 이 최적화는 자동으로 활성화됩니다.

00:11:17.000 --> 00:11:27.000
시스템 성능을 크게 향상시키지만, 어떤 상황에서는 이 최적화로 잘 작동하도록 콘텐츠를 조정해야 할 수도 있습니다.

00:11:27.000 --> 00:11:35.000
예를 들어, 여기 야자수 잎 자산이 있습니다. 화면 중앙에 놓으면 날카롭고 세밀해 보입니다.

00:11:35.000 --> 00:11:44.000
하지만 물체를 왼쪽으로 옮기고 눈 움직임 시뮬레이션을 다시 적용하면, 야자수 잎에서 깜박이는 것을 관찰할 수 있습니다.

00:11:44.000 --> 00:11:52.000
깜박임은 눈 방향을 나타내는 노란색 원이 화면의 오른쪽 가장자리에 가까울 때 특히 강하다.

00:11:52.000 --> 00:12:06.000
깜박임은 래스터화 속도 맵이 사람이 보고 있는 지점 주변에서 더 높은 디테일을 가능하게 하고, 눈이 멀어질 때 야자수 잎 주변의 픽셀이 더 낮은 디테일로 렌더링되기 때문에 발생합니다.

00:12:06.000 --> 00:12:12.000
이제, 콘텐츠의 몇 가지 매개 변수를 조정하기만 하면 깜박임을 줄일 수 있습니다.

00:12:12.000 --> 00:12:14.000
이것 좀 보자.

00:12:14.000 --> 00:12:21.000
여기 위에 빨간색 와이어프레임 오버레이가 있는 동일한 야자수 잎 자산의 표현이 있습니다.

00:12:21.000 --> 00:12:24.000
당신은 여기에 많은 작은 삼각형이 있다는 것을 알 수 있습니다.

00:12:24.000 --> 00:12:28.000
이 작은 삼각형들은 주변부에서 깜박이는 이유였다.

00:12:28.000 --> 00:12:38.000
우리는 단순히 삼각형을 더 크게 만들고 불투명한 질감에 미세한 디테일을 저장함으로써 깜박임을 줄일 수 있습니다.

00:12:38.000 --> 00:12:43.000
자산을 조정한 후 시뮬레이션이 어떻게 보이는지는 다음과 같습니다.

00:12:43.000 --> 00:12:53.000
RealityKit은 자산이 로드될 때 불투명도 맵의 저해상도 버전을 자동으로 생성하기 때문에 이 3D 모델은 조정 후 더 좋아 보인다.

00:12:53.000 --> 00:13:03.000
저해상도 버전의 텍스처는 렙맵이라고 불리며 GPU가 자동으로 사용하여 더 낮은 디테일 영역의 모양을 개선합니다.

00:13:03.000 --> 00:13:12.000
래스터화 속도 맵에 대한 자세한 내용은 "다른 래스터화 속도로 렌더링" 기사를 참조하십시오.

00:13:12.000 --> 00:13:23.000
래스터화 속도 맵과 마찬가지로, SwiftUI를 사용하여 작성된 콘텐츠의 모양을 자동으로 개선하는 "동적 콘텐츠 스케일링"이라는 또 다른 기술이 있습니다.

00:13:23.000 --> 00:13:26.000
한 번 보자.

00:13:26.000 --> 00:13:31.000
여기 그리드에 배열된 달 목록을 표시하는 응용 프로그램이 있습니다.

00:13:31.000 --> 00:13:36.000
매달은 텍스트 라벨로 표시됩니다.

00:13:36.000 --> 00:13:44.000
눈이 6월을 볼 때, 시스템은 그 지역의 텍스트를 최고 수준의 디테일로 래스터화한다.

00:13:44.000 --> 00:13:55.000
파란색으로 표시된 "6월" 주변 지역은 약간 감소된 세부 수준으로 래스터화될 것이지만, 여전히 전반적으로 높은 품질을 유지합니다.

00:13:55.000 --> 00:14:07.000
그러나 보라색으로 표시된 영역은 인간의 시각 시스템이 주변부의 세부 사항을 더 적게 인식하고 눈에 띄지 않기 때문에 훨씬 낮은 수준의 세부 사항으로 래스터화된다.

00:14:07.000 --> 00:14:17.000
눈이 보고 있는 것을 기반으로 한 다양한 수준의 디테일에서 이러한 종류의 래스터화는 "동적 콘텐츠 스케일링"이라고 불린다.

00:14:17.000 --> 00:14:27.000
이 시스템은 동적 콘텐츠 확장에 의존하여 UI 콘텐츠를 올바른 규모로 그릴 수 있으며 항상 선명하도록 보장합니다.

00:14:27.000 --> 00:14:32.000
동적 콘텐츠 스케일링은 래스터화된 콘텐츠에 대한 메모리의 상대적인 크기에 영향을 미친다.

00:14:32.000 --> 00:14:42.000
즉, 우리의 텍스트 라벨은 눈이 보고 있는 지점에 얼마나 가까이 있는지에 따라 다른 크기로 조정됩니다.

00:14:42.000 --> 00:14:51.000
예를 들어, "6월"이라는 라벨이 가장 크다는 것을 알 수 있습니다 - 가장 큰 해상도와 디테일을 가지고 있습니다.

00:14:51.000 --> 00:14:58.000
그런 다음 8개월의 그룹이 있다 - 1월, 2월, 3월 등 세부 사항이 약간 적다.

00:14:58.000 --> 00:15:06.000
마지막으로, 3개월의 그룹이 있다 - 4월, 8월, 12월 - 눈에서 가장 멀리 떨어져 있다.

00:15:06.000 --> 00:15:11.000
그 마지막 그룹은 메모리에 있는 더 작은 이미지로 표현될 것이다.

00:15:11.000 --> 00:15:16.000
이제, 동적 콘텐츠 확장을 활성화하는 방법을 이해합시다.

00:15:16.000 --> 00:15:23.000
UIKit과 SwiftUI를 사용하는 경우, 애플리케이션은 자동으로 이 기술의 혜택을 받을 것입니다.

00:15:23.000 --> 00:15:30.000
UI를 구축하기 위해 코어 애니메이션 프레임워크에 의존하는 경우, 동적 콘텐츠 확장을 가능하게 하는 새로운 API가 있습니다.

00:15:30.000 --> 00:15:34.000
이 API를 살펴봅시다.

00:15:34.000 --> 00:15:42.000
CALayer wantsDynamicContentScaling의 속성을 true로 설정하여 동적 콘텐츠 스케일링을 활성화할 수 있습니다.

00:15:42.000 --> 00:15:52.000
이 기술은 더 높은 해상도의 래스터화에 의존하므로, 주로 비트맵 기반 콘텐츠와 함께 사용하는 것은 권장되지 않습니다.

00:15:52.000 --> 00:16:01.000
Developer.apple.com에서 동적 콘텐츠 확장에 관한 권장 사항의 전체 목록을 찾을 수 있습니다.

00:16:01.000 --> 00:16:04.000
우리가 배운 모든 것을 요약하겠습니다.

00:16:04.000 --> 00:16:12.000
우리는 RealityKit 애플리케이션에 이미지 기반 조명과 접지 그림자를 추가하는 방법을 살펴보는 것으로 시작했습니다.

00:16:12.000 --> 00:16:19.000
그런 다음 우리는 새로운 ShaderGraphMaterial을 포함하여 공간 경험에 사용할 수 있는 자료를 검토했습니다.

00:16:19.000 --> 00:16:24.000
그리고 우리는 또한 조명이 없는 재료에 대한 톤 매핑을 제어하는 방법을 배웠습니다.

00:16:24.000 --> 00:16:36.000
다음으로 우리는 주변부의 깜박임을 줄이기 위해 3D 모델을 조정하는 방법을 포함하여 래스터화 속도 맵이 공간 컴퓨팅에 어떻게 사용되는지 배웠습니다.

00:16:36.000 --> 00:16:43.000
마지막으로, 우리는 동적 콘텐츠 스케일링이 시스템에서 어떻게 작동하는지, 그리고 그것을 어떻게 활용할 수 있는지 배웠습니다.

00:16:43.000 --> 00:16:51.000
우리는 올해의 출시에 대해 매우 흥분하고 있으며 당신이 xrOS에서 구축한 아름다운 공간 경험을 빨리 보고 싶습니다.

00:16:51.000 --> 23:59:59.000
고마워.

