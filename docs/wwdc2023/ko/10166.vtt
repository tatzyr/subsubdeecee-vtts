WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:13.000
알렉스 호펜: 누가 반복적인 상용구 코드를 쓰는 것을 좋아하나요?

00:00:13.000 --> 00:00:15.000
아무도 안 해!

00:00:15.000 --> 00:00:20.000
그리고 그것이 우리가 스위프트 5.9에서 스위프트 매크로를 도입하는 이유입니다.

00:00:20.000 --> 00:00:29.000
스위프트 매크로를 사용하면 컴파일 시간에 반복적인 코드를 생성할 수 있어 앱의 코드베이스를 더 표현하고 읽기 쉽게 만들 수 있습니다.

00:00:29.000 --> 00:00:36.000
제 이름은 알렉스 호펜이고, 오늘은 당신이 어떻게 자신만의 매크로를 쓸 수 있는지 보여드리겠습니다.

00:00:36.000 --> 00:00:42.000
매크로가 어떻게 작동하는지에 대한 간략한 개요를 제공하는 것으로 시작하겠습니다.

00:00:42.000 --> 00:00:50.000
그 후, 우리는 Xcode로 바로 뛰어들어 첫 번째 매크로를 어떻게 만들 수 있는지 알아볼 것입니다.

00:00:50.000 --> 00:01:05.000
Xcode에서 첫 번째 매크로를 본 후, 우리는 매크로를 사용할 수 있는 더 많은 역할을 탐구할 것이며, 현재 작업 중인 앱의 코드베이스를 단순화하기 위해 매크로를 어떻게 사용했는지 보여드리겠습니다.

00:01:05.000 --> 00:01:15.000
마지막으로, 매크로가 특정 컨텍스트에서 적용되지 않는 경우 오류나 경고를 컴파일러에 다시 전달할 수 있는 방법을 보여드리겠습니다.

00:01:15.000 --> 00:01:17.000
그럼 시작하자.

00:01:17.000 --> 00:01:23.000
여기 1학년 학생들이 산술 기술을 연습하는 데 사용할 수 있는 계산 목록이 있습니다.

00:01:23.000 --> 00:01:31.000
결과는 왼쪽에 정수로, 계산은 튜플의 오른쪽에 문자열 리터럴로 있습니다.

00:01:31.000 --> 00:01:41.000
아무도 결과가 실제로 계산과 일치한다고 보장할 수 없기 때문에 이것이 얼마나 반복적이고, 중복되며, 심지어 오류가 발생하기 쉬운지 주목하세요.

00:01:41.000 --> 00:01:48.000
운 좋게도, 스위프트 5.9를 사용하면 이를 단순화하기 위해 문자열 매크로를 정의할 수 있습니다.

00:01:48.000 --> 00:01:53.000
이 매크로는 또한 Xcode의 템플릿에 포함된 것이다.

00:01:53.000 --> 00:01:58.000
Stringify 매크로는 계산을 단일 매개 변수로만 사용합니다.

00:01:58.000 --> 00:02:07.000
컴파일 타임에 그것은 우리가 전에 본 튜플으로 확장되어 계산과 결과가 일치하는 것을 보장합니다.

00:02:07.000 --> 00:02:09.000
그래서 이건 어떻게 작동해?

00:02:09.000 --> 00:02:13.000
매크로 자체의 정의를 살펴봅시다.

00:02:13.000 --> 00:02:16.000
그것이 기능과 많이 닮았다는 것을 주목하세요.

00:02:16.000 --> 00:02:28.000
Stringify 매크로는 정수를 입력 매개 변수로 받아들이고 결과, 정수 및 계산인 문자열을 포함하는 튜플을 출력합니다.

00:02:28.000 --> 00:02:40.000
매크로 표현식의 인수가 매크로의 매개 변수와 일치하지 않거나 자체적으로 체크를 입력하지 않으면 컴파일러는 매크로 확장을 적용하지 않고 오류를 발생시킵니다.

00:02:40.000 --> 00:02:51.000
예를 들어, 이 매크로에 문자열 리터럴을 전달하면, 컴파일러는 'String'이 예상되는 인수 유형 'Int'로 변환할 수 없다고 불평합니다.

00:02:51.000 --> 00:02:59.000
예를 들어, 이것은 유형 검사 전에 사전 프로세서 단계에서 평가되는 C 매크로와 다릅니다.

00:02:59.000 --> 00:03:08.000
하지만 그것은 우리가 당신의 매크로를 일반화할 수 있는 것과 같이 스위프트 함수에서 알고 사랑하는 모든 힘을 사용할 수 있게 해준다.

00:03:08.000 --> 00:03:14.000
또한 이 매크로는 독립형 표현 매크로 역할로 선언된다는 점에 유의하십시오.

00:03:14.000 --> 00:03:24.000
이것은 표현식을 사용할 수 있는 모든 곳에서 매크로를 사용할 수 있으며, #stringify에서 볼 수 있듯이 해시 문자로 표시된다는 것을 의미합니다.

00:03:24.000 --> 00:03:30.000
다른 종류의 매크로는 선언을 보강할 수 있는 첨부된 매크로이다.

00:03:30.000 --> 00:03:32.000
내가 나중에 그것들을 다룰게.

00:03:32.000 --> 00:03:40.000
모든 인수가 매크로의 매개 변수와 일치하는지 확인한 후, 컴파일러는 매크로 확장을 수행합니다.

00:03:40.000 --> 00:03:47.000
그것이 어떻게 작동하는지 보려면, 단일 매크로 표현식에 집중합시다.

00:03:47.000 --> 00:03:53.000
확장을 수행하기 위해, 각 매크로는 컴파일러 플러그인에서 구현을 정의한다.

00:03:53.000 --> 00:03:59.000
컴파일러는 전체 매크로 표현식의 소스 코드를 해당 플러그인으로 보낼 것이다.

00:03:59.000 --> 00:04:08.000
매크로 플러그인이 하는 첫 번째 일은 매크로의 소스 코드를 SwiftSyntax 트리로 구문 분석하는 것이다.

00:04:08.000 --> 00:04:17.000
이 트리는 매크로의 소스 정확한 구조적 표현이며, 매크로가 작동하는 기초가 될 것이다.

00:04:17.000 --> 00:04:26.000
예를 들어, 우리의 'stringify' 매크로는 트리에서 매크로 확장 표현식 노드로 표시됩니다.

00:04:26.000 --> 00:04:31.000
그 표현은 매크로 이름 'stringify'를 가지고 있다.

00:04:31.000 --> 00:04:38.000
그리고 2와 3에 적용된 접두사 연산자 더하기인 하나의 인수가 필요합니다.

00:04:38.000 --> 00:04:51.000
스위프트 매크로의 정말 강력한 점은 매크로의 구현 자체가 스위프트로 작성된 프로그램이며 원하는 구문 트리로 변환할 수 있다는 것입니다.

00:04:51.000 --> 00:04:56.000
우리의 경우, 그것은 우리가 전에 본 것처럼 튜플을 생성한다.

00:04:56.000 --> 00:05:09.000
그런 다음 생성된 구문 트리를 소스 코드로 다시 직렬화하고 컴파일러로 보내 매크로 표현식을 확장된 코드로 대체합니다.

00:05:09.000 --> 00:05:16.000
정말 멋지지만, 이제 나는 이 모든 것이 실제로 코드에서 어떻게 보이는지 이해하고 싶다.

00:05:16.000 --> 00:05:22.000
Xcode의 새로운 매크로 템플릿은 우리가 방금 본 stringify 매크로를 정의합니다.

00:05:22.000 --> 00:05:31.000
그 템플릿을 살펴보고 매크로의 정의, 확장이 어떻게 작동하는지, 그리고 매크로를 어떻게 테스트할 수 있는지 살펴봅시다.

00:05:31.000 --> 00:05:43.000
템플릿을 만들려면, 파일, 신규, 패키지를 클릭하고, 이제 스위프트 매크로 템플릿을 선택합니다.

00:05:43.000 --> 00:05:55.000
우리의 첫 번째 매크로를 "WWDC"라고 부르자.

00:05:55.000 --> 00:05:58.000
그래서 우리는 템플릿으로 무엇을 얻나요?

00:05:58.000 --> 00:06:05.000
여기서 우리는 이전에 본 것과 비슷한 #stringify 매크로를 호출합니다.

00:06:05.000 --> 00:06:12.000
그것은 매개 변수 "a + b"를 취하고 결과와 그것을 생성한 코드를 반환합니다.

00:06:12.000 --> 00:06:20.000
매크로가 무엇으로 확장되는지 알고 싶다면, 마우스 오른쪽 버튼을 클릭하고 매크로 확장을 선택할 수 있습니다.

00:06:20.000 --> 00:06:23.000
그게 바로 우리가 전에 본 거야.

00:06:23.000 --> 00:06:26.000
하지만 매크로는 어떻게 정의되나요?

00:06:26.000 --> 00:06:32.000
그 정의로 넘어가자.

00:06:32.000 --> 00:06:38.000
여기 우리는 이전 'stringify' 매크로의 약간 일반화된 버전이 있습니다.

00:06:38.000 --> 00:06:47.000
정수를 취하는 대신, 이 매크로는 일반적이며 모든 유형 T를 받을 수 있다.

00:06:47.000 --> 00:06:52.000
매크로는 외부 매크로로 선언된다.

00:06:52.000 --> 00:07:04.000
이것은 컴파일러에게 확장을 수행하려면 WWDCMacros 모듈에서 StringifyMacro 유형을 살펴봐야 한다고 알려줍니다.

00:07:04.000 --> 00:07:07.000
그 유형은 어떻게 정의되나요?

00:07:07.000 --> 00:07:10.000
좀 더 자세히 살펴보자.

00:07:10.000 --> 00:07:20.000
Stringify는 독립형 표현식 매크로로 선언되기 때문에, StringifyMacro 유형은 ExpressionMacro 프로토콜을 준수해야 합니다.

00:07:20.000 --> 00:07:26.000
이 프로토콜에는 한 가지 요구 사항이 있습니다: 확장 기능.

00:07:26.000 --> 00:07:36.000
매크로 표현식 자체의 구문 트리와 컴파일러와 통신하는 데 사용할 수 있는 컨텍스트가 필요합니다.

00:07:36.000 --> 00:07:42.000
그런 다음 확장 함수는 다시 작성된 표현식 구문을 반환합니다.

00:07:42.000 --> 00:07:45.000
그것은 구현에서 무엇을 하나요?

00:07:45.000 --> 00:07:52.000
처음에는 매크로 표현식에 대한 단일 인수를 검색합니다.

00:07:52.000 --> 00:08:05.000
Stringify가 단일 매개 변수를 사용하는 것으로 선언되고 매크로 확장을 적용하기 전에 모든 인수를 입력 확인해야 하기 때문에 이 인수가 존재한다는 것을 알고 있습니다.

00:08:05.000 --> 00:08:10.000
그런 다음 문자열 보간을 사용하여 튜플의 구문 트리를 만듭니다.

00:08:10.000 --> 00:08:20.000
첫 번째 요소는 인수 자체이고 두 번째 요소는 인수의 소스 코드를 포함하는 문자열 리터럴이다.

00:08:20.000 --> 00:08:24.000
그 함수는 여기서 문자열을 반환하지 않는다는 것을 주목하세요.

00:08:24.000 --> 00:08:27.000
그것은 표현식 구문을 반환하고 있다.

00:08:27.000 --> 00:08:34.000
매크로는 자동으로 스위프트 파서를 호출하여 이 리터럴을 구문 트리로 변환합니다.

00:08:34.000 --> 00:08:44.000
그리고 두 번째 인수에 리터럴 보간 스타일을 사용하고 있기 때문에, 리터럴의 내용이 제대로 이스케이프되었는지 확인할 것이다.

00:08:44.000 --> 00:08:46.000
아무도 벌레를 좋아하지 않아.

00:08:46.000 --> 00:08:54.000
하지만 내가 덜 좋아하는 것은 매크로를 확장하여 명시적으로 요청하지 않는 한 볼 수 없는 코드의 버그이다.

00:08:54.000 --> 00:08:58.000
그것이 당신이 매크로가 잘 테스트되었는지 확인하고 싶은 이유입니다.

00:08:58.000 --> 00:09:08.000
매크로는 부작용이 없고 구문 트리의 소스 코드를 비교하기 쉽기 때문에, 그것들을 테스트하는 좋은 방법은 단위 테스트를 작성하는 것이다.

00:09:08.000 --> 00:09:12.000
매크로 템플릿은 이미 하나와 함께 제공됩니다.

00:09:12.000 --> 00:09:23.000
이 테스트 케이스는 SwiftSyntax 패키지의 'assertMacroExpansion' 기능을 사용하여 'stringify' 매크로가 올바르게 확장되는지 확인합니다.

00:09:23.000 --> 00:09:29.000
우리가 전에 본 '#stringify(a + b)' 표현식을 입력으로 사용합니다.

00:09:29.000 --> 00:09:42.000
그리고 매크로가 확장된 후 'a + b'와 문자열 리터럴 'a + b'를 포함하는 튜플을 생성한다고 주장한다.

00:09:42.000 --> 00:09:55.000
테스트 케이스에 매크로를 확장하는 방법을 알려주기 위해, 'StringifyMacro' 유형을 사용하여 매크로 '#stringify'를 확장해야 한다고 지정하는 'testMacros' 매개 변수를 전달합니다.

00:09:55.000 --> 00:10:09.000
앱의 테스트를 이미 실행할 수 있는 것과 같은 방식으로 테스트를 실행하여 실제로 통과하는지 확인해 봅시다.

00:10:09.000 --> 00:10:16.000
시험은 통과했고, 그것으로, 우리는 이미 첫 번째 매크로를 가지고 있다.

00:10:16.000 --> 00:10:20.000
그 안에서, 우리는 그것의 기본적인 빌딩 블록을 보았다.

00:10:20.000 --> 00:10:24.000
매크로 선언은 매크로의 서명을 정의한다.

00:10:24.000 --> 00:10:28.000
그것은 또한 매크로 역할을 선언한다.

00:10:28.000 --> 00:10:31.000
컴파일러 플러그인은 확장을 수행합니다.

00:10:31.000 --> 00:10:39.000
그것은 그 자체로 Swift로 작성되고 SwiftSyntax 트리에서 작동하는 프로그램입니다.

00:10:39.000 --> 00:10:51.000
우리는 또한 매크로가 구문 트리의 결정론적 변환이고 구문 트리의 소스 코드를 비교하기 쉽기 때문에 매우 테스트할 수 있다는 것을 보았다.

00:10:51.000 --> 00:10:56.000
그래서 당신은 "어떤 다른 상황에서 매크로를 사용할 수 있나요?"라고 궁금해 할 수 있습니다.

00:10:56.000 --> 00:11:00.000
우리는 이미 독립된 표현 매크로를 보았다.

00:11:00.000 --> 00:11:07.000
요약하자면, 이 매크로는 해시로 철자되며 전체 매크로 표현식을 다시 쓸 수 있습니다.

00:11:07.000 --> 00:11:14.000
표현 대신 선언으로 확장되는 독립형 선언 역할도 있다.

00:11:14.000 --> 00:11:18.000
다른 종류의 매크로는 첨부된 매크로이다.

00:11:18.000 --> 00:11:25.000
이것들은 속성과 마찬가지로 @로 철자되며, 매크로가 첨부된 선언을 보강할 수 있도록 합니다.

00:11:25.000 --> 00:11:32.000
예를 들어, 첨부된 멤버 매크로는 첨부된 유형의 새로운 멤버를 추가합니다.

00:11:32.000 --> 00:11:40.000
이러한 다른 역할에 대해 더 자세히 알아보려면, 베카가 자세히 살펴보는 "스위프트 매크로 확장"을 보는 것이 좋습니다.

00:11:40.000 --> 00:11:48.000
하지만 현재 작업 중인 앱의 코드베이스를 개선하는 데 도움이 되었기 때문에 첨부된 회원 역할에 집중하고 싶습니다.

00:11:48.000 --> 00:11:57.000
저는 또한 스키 강사이며, 최근에 학생들을 데려가고 싶은 투어를 계획할 수 있는 앱을 개발하고 있습니다.

00:11:57.000 --> 00:12:04.000
스키 강사로서 당신이 절대적으로 피하고 싶은 한 가지는 그들에게 너무 어려운 슬로프에 초보자를 데려가는 것입니다.

00:12:04.000 --> 00:12:08.000
나는 그것을 시행하기 위해 스위프트 유형 시스템을 사용하고 싶다.

00:12:08.000 --> 00:12:20.000
그렇기 때문에, 내가 가장 좋아하는 스키 리조트의 모든 슬로프를 포함하는 슬로프 열거형 외에도, 초보자에게만 적합한 슬로프를 포함하는 EasySlope 유형도 있습니다.

00:12:20.000 --> 00:12:34.000
경사가 실제로 쉽다면, 경사를 쉬운 경사로 변환하는 이니셜라이저와 쉬운 경사를 일반 경사로 다시 변환하는 계산된 속성이 있습니다.

00:12:34.000 --> 00:12:38.000
이것은 훌륭한 유형의 안전을 제공하지만, 정말 반복적이다.

00:12:38.000 --> 00:12:45.000
쉬운 슬로프를 추가하고 싶다면, 슬로프에 추가해야 합니다...

00:12:45.000 --> 00:12:53.000
EasySlope, 이니셜라이저 및 계산된 속성.

00:12:53.000 --> 00:12:56.000
매크로를 사용하여 개선할 수 있는지 봅시다.

00:12:56.000 --> 00:13:03.000
우리가 하고 싶은 것은 이니셜라이저와 계산된 속성을 자동으로 생성하는 것이다.

00:13:03.000 --> 00:13:06.000
우리가 이걸 어떻게 할 수 있을까?

00:13:06.000 --> 00:13:16.000
이니셜라이저와 계산된 속성은 모두 EasySlope 유형의 멤버이므로 첨부된 멤버 매크로를 선언해야 합니다.

00:13:16.000 --> 00:13:23.000
다음으로, 우리는 매크로의 구현을 포함하는 컴파일러 플러그인을 만들 것입니다.

00:13:23.000 --> 00:13:29.000
우리의 매크로가 예상대로 작동하도록 하기 위해, 우리는 그것을 테스트 중심의 방식으로 개발하고 싶습니다.

00:13:29.000 --> 00:13:36.000
따라서, 우리는 그것에 대한 테스트 사례를 작성할 때까지 구현을 비워 둘 것이다.

00:13:36.000 --> 00:13:45.000
테스트 사례에서 매크로의 동작을 정의한 후, 우리는 그 테스트 사례와 일치하도록 구현을 작성할 것이다.

00:13:45.000 --> 00:13:50.000
그리고 마지막으로, 우리는 새로운 매크로를 내 앱에 통합할 것이다.

00:13:50.000 --> 00:13:58.000
모든 것이 잘 진행된다면, 우리는 이니셜라이저를 제거하고 매크로가 우리를 위해 그것을 생성하도록 할 수 있을 것이다.

00:13:58.000 --> 00:14:04.000
매크로를 개발하기 위해, 우리는 이전에 만든 템플릿으로 작업합니다.

00:14:04.000 --> 00:14:09.000
그리고 내 앱에 '#stringify' 매크로가 필요하지 않기 때문에, 나는 이미 그것을 제거했다.

00:14:09.000 --> 00:14:18.000
저는 '@attached(member)' 속성을 사용하여 새로운 첨부된 멤버 매크로를 선언하는 것으로 시작합니다.

00:14:18.000 --> 00:14:24.000
EasySlope는 Slope의 하위 집합이기 때문에 나는 그것을 SlopeSubset이라고 부른다.

00:14:24.000 --> 00:14:30.000
매크로는 또한 그것이 소개하는 구성원의 이름을 정의한다.

00:14:30.000 --> 00:14:34.000
이 데모에서, 저는 당신에게 이니셜라이저를 생성하는 방법을 보여줄 것입니다.

00:14:34.000 --> 00:14:42.000
계산된 속성을 생성하는 것은 매우 유사합니다. 왜냐하면 그것은 또한 모든 경우를 전환하는 스위치 문이기 때문입니다.

00:14:42.000 --> 00:14:50.000
이 선언으로, 우리는 매크로를 정의했지만, 실제로 수행하는 확장을 구현하지 않았다.

00:14:50.000 --> 00:14:58.000
이를 위해, 우리의 매크로는 WWDCMacros 모듈의 SlopeSubsetMacro 유형을 참조합니다.

00:14:58.000 --> 00:15:06.000
우리가 정말 흥미진진한 부분을 계속할 수 있도록 가서 그 유형을 만들어 봅시다: 실제 매크로 구현.

00:15:06.000 --> 00:15:15.000
SlopeSubset을 첨부된 멤버 매크로로 선언했기 때문에, 해당 구현은 MemberMacro 프로토콜을 준수해야 합니다.

00:15:15.000 --> 00:15:24.000
이 프로토콜에는 단일 요구 사항이 있습니다: ExpressionMacro와 유사한 '확장' 기능.

00:15:24.000 --> 00:15:36.000
'확장' 함수는 매크로가 적용되는 선언뿐만 아니라 선언에 매크로를 적용하는 속성을 취합니다.

00:15:36.000 --> 00:15:42.000
우리의 경우, 이것은 EasySlope 열거형 선언이 될 것이다.

00:15:42.000 --> 00:15:50.000
그런 다음 매크로는 그 선언에 추가하고 싶은 모든 새로운 구성원의 목록을 반환합니다.

00:15:50.000 --> 00:16:00.000
나는 이 변화를 즉시 구현하는 것이 매우 유혹적이라는 것을 알고 있지만, 우리는 그것에 대한 테스트 사례를 작성하는 것으로 시작하고 싶다는 데 동의했다.

00:16:00.000 --> 00:16:12.000
그래서 지금은, 새로운 멤버가 추가되어서는 안 된다는 것을 나타내는 빈 배열을 반환합시다.

00:16:12.000 --> 00:16:17.000
마지막으로, 우리는 SlopeSubset을 컴파일러에서 볼 수 있도록 해야 합니다.

00:16:17.000 --> 00:16:26.000
이를 위해, 나는 그것을 여기 아래에 있는 'ProvidingMacros' 재산에 추가한다.

00:16:26.000 --> 00:16:32.000
더 깊이 잠수하기 전에, 나는 우리가 지금까지 가지고 있는 것이 효과가 있는지 확인하고 싶다.

00:16:32.000 --> 00:16:51.000
Xcode에서 매크로를 적용하고 확장된 코드를 볼 수 있지만, 회귀를 도입하지 않도록 매크로를 변경할 때마다 다시 실행할 수 있는 테스트 사례를 작성하는 것을 훨씬 선호합니다.

00:16:51.000 --> 00:17:03.000
템플릿의 테스트 케이스와 마찬가지로, 우리는 매크로의 동작을 확인하기 위해 'assertMacroExpansion' 기능을 사용합니다.

00:17:03.000 --> 00:17:16.000
우리가 테스트하고 싶은 것은 EasySlope 유형에 적용될 때 매크로가 생성하는 것이므로, 우리는 그것을 테스트 케이스의 입력으로 사용합니다.

00:17:16.000 --> 00:17:36.000
그리고 매크로가 아직 아무것도 하지 않기 때문에, 우리는 그것이 속성을 제거하고 새로운 멤버를 추가하지 않을 것으로 예상하므로, 예상되는 확장 코드는 '@SlopeSubset' 없이 입력과 동일합니다.

00:17:36.000 --> 00:17:46.000
마지막으로, 우리는 테스트 케이스에 SlopeSubsetMacro 구현을 사용하여 매크로 SlopeSubset을 확장해야 한다는 것을 알려야 합니다.

00:17:46.000 --> 00:18:04.000
이를 위해, 우리는 매크로 이름을 'testMacros' 사전의 구현 유형에 매핑하고 그 사전을 주장 함수에 전달해야 합니다.

00:18:04.000 --> 00:18:18.000
우리가 지금까지 쓴 것이 실제로 효과가 있는지 확인하기 위해 지금 테스트를 실행해 봅시다.

00:18:18.000 --> 00:18:19.000
그래.

00:18:19.000 --> 00:18:20.000
좋아.

00:18:20.000 --> 00:18:29.000
하지만 우리가 정말로 원하는 것은 매크로가 속성을 제거하는 것이 아니라 실제로 이니셜라이저를 생성하는지 확인하는 것입니다.

00:18:29.000 --> 00:18:42.000
그래서 나는 이전에 손으로 쓴 코드를 테스트 케이스에 복사할 것이다. 왜냐하면 정말로, 그것이 우리가 플러그인이 생성하기를 원하는 것이기 때문이다.

00:18:42.000 --> 00:18:53.000
테스트를 다시 실행하면... ... 매크로가 아직 실제로 이니셜라이저를 생성하지 않기 때문에 실패합니다.

00:18:53.000 --> 00:19:01.000
지금 그걸 바꾸자.

00:19:01.000 --> 00:19:07.000
이니셜라이저는 EasySlopes 열거형에 선언된 모든 열거형 요소를 전환합니다.

00:19:07.000 --> 00:19:15.000
그래서 우리가 해야 할 첫 번째 일은 선언에서 이러한 열거형 요소를 검색하는 것이다.

00:19:15.000 --> 00:19:27.000
열거형 요소는 열거형 선언 내에서만 선언될 수 있기 때문에, 우리는 열거형 선언에 '선언'을 캐스팅하는 것으로 시작합니다.

00:19:27.000 --> 00:19:33.000
매크로가 열거형이 아닌 유형에 첨부되어 있다면, 우리는 오류를 방출해야 한다.

00:19:33.000 --> 00:19:39.000
나중에 하는 것을 잊지 않도록 TODO를 추가했고, 지금은 빈 배열을 반환합니다.

00:19:39.000 --> 00:19:44.000
다음으로, 우리는 열거형이 선언하는 모든 요소를 얻어야 한다.

00:19:44.000 --> 00:19:52.000
그것을 하는 방법을 알아내기 위해, 나는 SwiftSyntax 트리에서 열거형의 구문 구조를 검사하고 싶다.

00:19:52.000 --> 00:20:02.000
매크로의 구현은 일반적인 스위프트 프로그램이기 때문에, Xcode에서 알고 있는 모든 도구를 사용하여 프로그램을 디버깅할 수 있습니다.

00:20:02.000 --> 00:20:17.000
예를 들어, 확장 함수 내부에 중단점을 설정하고 테스트 사례를 실행하여 그 중단점에 도달할 수 있습니다.

00:20:17.000 --> 00:20:25.000
이제 매크로 구현 내에서 디버거가 일시 중지되었고 'enumDecl'은 EasySlopes 열거형입니다.

00:20:25.000 --> 00:20:34.000
'Po enumDecl'을 입력하여 디버거에서 인쇄할 수 있습니다.

00:20:34.000 --> 00:20:38.000
출력을 점검해 봅시다.

00:20:38.000 --> 00:20:46.000
구문 트리의 가장 안쪽 노드는 열거형 요소, 'beginnersParadise' 및 'practiceRun' 슬로프를 나타냅니다.

00:20:46.000 --> 00:20:52.000
그것들을 검색하려면, 우리는 구문 트리에 설명된 구조를 따라야 합니다.

00:20:52.000 --> 00:20:59.000
그 구조를 단계별로 살펴보고 진행하면서 액세스 코드를 작성합시다.

00:20:59.000 --> 00:21:04.000
열거형 선언에는 'memberBlock'이라는 자식이 있다.

00:21:04.000 --> 00:21:09.000
이 멤버 블록은 중괄호와 실제 멤버를 모두 포함한다.

00:21:09.000 --> 00:21:18.000
그래서 회원들에 접근하기 위해, 우리는 'enumDecl.memberBlock.members'로 시작합니다.

00:21:18.000 --> 00:21:23.000
이 멤버들은 선택적 세미콜론뿐만 아니라 실제 선언을 포함한다.

00:21:23.000 --> 00:21:31.000
우리는 선언, 특히 실제로 열거형 사례를 선언하는 선언에 관심이 있다.

00:21:31.000 --> 00:21:38.000
나는 열거형 사례인 모든 회원 선언의 목록을 얻기 위해 컴팩트 맵을 사용하고 있다.

00:21:38.000 --> 00:21:42.000
각 사례 선언은 여러 요소를 선언할 수 있다.

00:21:42.000 --> 00:21:57.000
이것은 별도의 케이스 키워드 후에 새 줄에 각 기울기를 선언하는 대신 'case beginnersParadise, practiceRun'과 같은 줄에 쓸 수 있었기 때문입니다.

00:21:57.000 --> 00:22:03.000
그것들을 모두 검색하기 위해, 우리는 '플랫맵'을 사용할 수 있다.

00:22:03.000 --> 00:22:14.000
그리고 이제 모든 요소를 검색했으므로, 실제로 EasySlope에 추가하고 싶은 이니셜라이저를 구성하기 시작할 수 있습니다.

00:22:14.000 --> 00:22:22.000
이니셜라이저 선언에는 단일 항목이 있습니다: 스위치 표현식.

00:22:22.000 --> 00:22:31.000
이 스위치 표현식은 열거형의 각 요소에 대한 대소문자와 nil을 반환하는 기본 대소문자를 포함합니다.

00:22:31.000 --> 00:22:36.000
우리는 이 모든 것에 대한 구문 노드를 만들어야 한다.

00:22:36.000 --> 00:22:48.000
만들 구문 노드를 찾는 두 가지 좋은 방법은 이전에 했던 것처럼 구문 트리를 인쇄하거나 SwiftSyntax의 문서를 읽는 것입니다.

00:22:48.000 --> 00:22:56.000
우리는 InitializerDeclSyntax를 구성하는 것으로 시작합니다.

00:22:56.000 --> 00:23:07.000
이 유형은 결과 빌더를 사용하여 바디를 만들고 헤더, 즉 'init' 키워드와 모든 매개 변수를 지정하여 구성할 수 있습니다.

00:23:07.000 --> 00:23:17.000
이를 통해 결과 빌더 내부의 for 루프를 사용하여 정확히 필요한 모든 요소를 반복할 수 있습니다.

00:23:17.000 --> 00:23:24.000
난 그냥 우리 테스트 케이스에서 초기화 헤더를 복사했어.

00:23:24.000 --> 00:23:33.000
몸 안에서, 우리는 스위치 표현이 필요하다.

00:23:33.000 --> 00:23:39.000
이 유형에는 헤더와 결과 작성기를 취하는 이니셜라이저도 있습니다.

00:23:39.000 --> 00:23:44.000
다시 사용하자.

00:23:44.000 --> 00:23:54.000
이제 우리는 이전에 수집한 모든 요소를 반복하여 결과 빌더의 힘을 사용할 수 있습니다.

00:23:54.000 --> 00:24:06.000
각 요소에 대해, 우리는 '#stringify'에서 본 것처럼 문자열 보간을 사용하여 구성할 수 있는 새로운 케이스 항목을 만들고 싶습니다.

00:24:06.000 --> 00:24:14.000
우리는 또한 nil을 반환하는 기본 사례를 추가해야 합니다.

00:24:14.000 --> 00:24:22.000
그리고 마지막으로, 우리는 이니셜라이저를 반환할 수 있다.

00:24:22.000 --> 00:24:32.000
우리가 실제로 올바른 이니셜라이저를 생성하고 있는지 확인하기 위해 테스트를 실행해 봅시다.

00:24:32.000 --> 00:24:33.000
우리는 그래.

00:24:33.000 --> 00:24:42.000
그래서 우리는 우리의 매크로가 작동하고 내 앱에서 그것을 사용하기 시작할 수 있다는 것을 알고 있다.

00:24:42.000 --> 00:24:50.000
매크로 패키지를 Xcode 프로젝트에 추가하려면, 마우스 오른쪽 버튼을 클릭하고 "패키지 종속성 추가"를 선택할 수 있습니다.

00:24:50.000 --> 00:25:00.000
이제 우리가 방금 만든 로컬 패키지를 선택할 수 있습니다.

00:25:00.000 --> 00:25:12.000
매크로를 사용하기 위해, 저는 WWDC 대상을 앱의 종속성으로 추가합니다.

00:25:12.000 --> 00:25:23.000
이제 패키지에서 WWDC 모듈을 가져오고 SlopeSubset 매크로를 EasySlope 유형에 적용할 수 있습니다.

00:25:23.000 --> 00:25:35.000
... 우리가 짓는다면...

00:25:35.000 --> 00:25:41.000
... 컴파일러는 손으로 쓴 이니셜라이저가 유효하지 않은 재설명이라고 불평한다.

00:25:41.000 --> 00:25:46.000
그리고 그것은 매크로가 이제 우리를 위해 그것을 생성하기 때문이다.

00:25:46.000 --> 00:25:53.000
그래서 우리는 그냥 그걸 삭제할 수 있어.

00:25:53.000 --> 00:25:56.000
코드를 삭제하는 것은 항상 재미있다. 그치?

00:25:56.000 --> 00:26:06.000
따라서 매크로가 실제로 무엇을 생성했는지 보고 싶다면, SlopeSubset을 마우스 오른쪽 버튼으로 클릭하고 매크로 확장을 클릭할 수 있습니다.

00:26:06.000 --> 00:26:16.000
그리고 매크로가 무엇을 하는지 잊어버렸다면, 옵션을 클릭하여 문서를 읽을 수도 있습니다.

00:26:16.000 --> 00:26:23.000
다음 단계는 계산된 속성을 생성하는 것이지만, 나는 오늘 늦게 그것을 할 것이다.

00:26:23.000 --> 00:26:32.000
매크로를 사용함으로써, 우리는 반복적인 코드를 작성할 필요 없이 EasySlopes의 유형 안전성을 얻을 수 있었다.

00:26:32.000 --> 00:26:35.000
우리가 그걸 어떻게 했어?

00:26:35.000 --> 00:26:39.000
우리는 스위프트 매크로 패키지 템플릿으로 시작했다.

00:26:39.000 --> 00:26:48.000
구문 트리의 구조를 탐구하기 위해, 우리는 매크로의 실행을 중지하고 디버거 내부의 구문 노드를 인쇄했습니다.

00:26:48.000 --> 00:26:56.000
이를 통해 우리는 모든 열거형 요소를 얻기 위해 어떤 속성에 접근해야 하는지 볼 수 있었다.

00:26:56.000 --> 00:27:00.000
그리고 테스트 사례를 사용하여 자체적으로 매크로를 개발하는 것은 정말 쉬웠다.

00:27:00.000 --> 00:27:05.000
우리가 그것을 내 앱에 추가한 후, 그것은 바로 작동했다.

00:27:05.000 --> 00:27:11.000
하지만 매크로가 지원하지 않는 상황에서 사용된다면 어떻게 될까요?

00:27:11.000 --> 00:27:23.000
초보자 스키어를 어려운 슬로프에 데려가고 싶지 않은 것처럼, 매크로가 예상치 못한 확장을 수행하거나 컴파일되지 않는 코드를 생성하게 하고 싶지 않습니다.

00:27:23.000 --> 00:27:37.000
매크로가 지원하지 않는 방식으로 사용되는 경우, 매크로를 디버깅하기 위해 생성된 코드를 읽는 대신 항상 어답터에게 무엇이 잘못되었는지 알려주는 오류 메시지를 방출하십시오.

00:27:37.000 --> 00:27:42.000
그 정신으로, 가서 우리가 코드베이스에 남긴 TODO를 고치자.

00:27:42.000 --> 00:27:51.000
SlopeSubset이 열거형이 아닌 유형에 적용될 때, 매크로는 열거형에만 적용된다는 오류를 방출해야 한다.

00:27:51.000 --> 00:28:01.000
이전과 마찬가지로, 테스트 케이스를 추가하는 것으로 시작합시다.

00:28:01.000 --> 00:28:08.000
이번에는 SlopeSubset 매크로를 구조체에 적용하고 있습니다.

00:28:08.000 --> 00:28:15.000
구조체에 열거형 요소가 없기 때문에, 우리는 매크로가 이니셜라이저를 생성할 것으로 기대하지 않는다.

00:28:15.000 --> 00:28:24.000
대신, 그것은 SlopeSubset이 열거형에만 적용될 수 있다는 것을 알려주는 오류인 진단을 방출해야 한다.

00:28:24.000 --> 00:28:30.000
우리가 이 테스트를 실행한다면...

00:28:30.000 --> 00:28:34.000
...우리가 아직 오류 메시지를 출력하지 않았기 때문에 실패합니다.

00:28:34.000 --> 00:28:41.000
지금 컴파일러 플러그인으로 가서 그렇게 합시다.

00:28:41.000 --> 00:28:48.000
매크로 오류는 스위프트 오류 프로토콜을 준수하는 모든 유형으로 나타낼 수 있습니다.

00:28:48.000 --> 00:29:01.000
SlopeSubset이 열거형이 아닌 유형에 적용되는 경우 오류 메시지를 설명하기 위해 단일 케이스가 있는 열거형을 사용합니다.

00:29:01.000 --> 00:29:12.000
확장 함수에서 오류를 던지면, 매크로 확장을 호출하는 속성에 표시됩니다.

00:29:12.000 --> 00:29:27.000
속성과 다른 위치에 오류 메시지를 표시하거나, 경고를 생성하거나, Xcode에서 Fix-Its를 표시하려면, 컨텍스트 매개 변수에 풍부한 진단을 생성할 수 있는 'addDiagnostic' 방법이 있습니다.

00:29:27.000 --> 00:29:33.000
하지만 이 경우에는 속성에 간단한 오류 메시지를 표시하는 것이 효율적이라고 생각합니다.

00:29:33.000 --> 00:29:43.000
이제, 우리가 모든 것을 제대로 했는지 그리고 우리의 시험이 통과했는지 봅시다.

00:29:43.000 --> 00:29:45.000
좋아, 그들은 그래.

00:29:45.000 --> 00:29:51.000
그렇다면 SlopeSubset을 구조체에 적용하면 Xcode에서 어떻게 보이나요?

00:29:51.000 --> 00:30:02.000
이를 위해, 테스트 케이스를 파일로 복사하겠습니다.

00:30:02.000 --> 00:30:07.000
Xcode는 다른 모든 컴파일 오류와 함께 사용자 지정 오류 메시지를 보여줍니다.

00:30:07.000 --> 00:30:13.000
그것은 내 매크로의 채택자들이 그들이 무엇을 잘못하고 있는지 쉽게 볼 수 있게 해준다.

00:30:13.000 --> 00:30:15.000
그리고 너 뭔지 알아?

00:30:15.000 --> 00:30:24.000
이제 우리는 좋은 오류 처리를 가지고 있으므로, 이 매크로는 슬로프뿐만 아니라 열거형 하위 집합을 지정하는 다른 개발자들에게도 유용할 수 있다고 생각합니다.

00:30:24.000 --> 00:30:29.000
가서 일반화하자.

00:30:29.000 --> 00:30:44.000
지금까지 Slope로 하드 코딩한 열거형의 상위 집합을 지정하기 위해 매크로 선언에 일반 매개 변수를 추가합니다.

00:30:44.000 --> 00:31:03.000
그리고 매크로는 이제 더 이상 슬로프에만 국한되지 않기 때문에, SlopeSubset을 마우스 오른쪽 버튼으로 클릭하고 리팩터, 이름 바꾸기를 선택하여 EnumSubset으로 이름을 바꾸자.

00:31:03.000 --> 00:31:14.000
또한 명령-클릭하여 문자열 리터럴과 주석 내부의 모든 발생의 이름을 바꿀 수 있습니다.

00:31:14.000 --> 00:31:22.000
이제 하드 코딩된 슬로프 유형 대신 일반 매개 변수를 사용하도록 매크로 구현을 조정해야 합니다.

00:31:22.000 --> 00:31:43.000
'enumDecl'과 마찬가지로 디버거 내부의 속성을 인쇄하고 레이아웃을 검사하면, 속성 이름의 'genericArgumentClause'에서 첫 번째 인수의 'argumentType'에 액세스하여 일반 매개 변수를 검색할 수 있다는 것을 알 수 있습니다.

00:31:43.000 --> 00:32:00.000
이제 일반 매개 변수를 검색했으므로 지금까지 하드코딩된 Slope 유형을 변수 'supersetType'로 대체할 수 있습니다.

00:32:00.000 --> 00:32:11.000
이니셜라이저의 매개 변수 이름을 바꾸고, 매크로 구현의 유형 이름을 변경하고, 문서를 업데이트하는 등 몇 가지 변경을 더 해야 합니다.

00:32:11.000 --> 00:32:13.000
그건 나중에 할게.

00:32:13.000 --> 00:32:22.000
대신, 지금은, 우리의 시험이 여전히 통과하고 있는지 확인합시다.

00:32:22.000 --> 00:32:43.000
EnumSubset을 일반으로 만들었기 때문에, EnumSubset 매크로에 일반 매개 변수로 기울기를 전달하여 EasySlope가 Slope의 하위 집합임을 명시적으로 지정해야 합니다.

00:32:43.000 --> 00:32:50.000
시험이 지금 통과되는지 봅시다.

00:32:50.000 --> 00:32:52.000
그들은 그래.

00:32:52.000 --> 00:32:57.000
나는 이 매크로를 다른 사람들에게 스위프트 패키지로 게시하는 것을 정말로 고려해야 한다.

00:32:57.000 --> 00:33:00.000
그래서 그것은 우리가 오늘 다룬 많은 땅이다.

00:33:00.000 --> 00:33:03.000
우리가 겪은 일을 요약해 봅시다.

00:33:03.000 --> 00:33:11.000
매크로를 만들려면, stringify 매크로를 훌륭한 출발점으로 포함하는 매크로 패키지 템플릿으로 시작할 수 있습니다.

00:33:11.000 --> 00:33:21.000
매크로를 개발하는 동안, 매크로가 생성하는 코드가 실제로 유효한지 확인하기 위해 테스트 사례를 작성하는 것이 좋습니다.

00:33:21.000 --> 00:33:33.000
그리고 이렇게 하는 경우, 확장 함수에서 중단점을 설정하고, 테스트를 실행하고, 디버거에서 구문 트리를 인쇄하여 구문 트리의 레이아웃을 검사할 수 있습니다.

00:33:33.000 --> 00:33:45.000
그리고 마지막으로, 매크로가 특정 상황에서 적용되지 않는 경우, 일이 잘못되더라도 매크로가 빛날 수 있도록 항상 사용자 지정 오류 메시지를 보내야 합니다.

00:33:45.000 --> 00:33:50.000
시청해 주셔서 감사합니다, 그리고 저는 당신이 어떤 종류의 매크로를 만들 것인지 보게 되어 기쁩니다.

00:33:50.000 --> 23:59:59.000
♪ ♪

