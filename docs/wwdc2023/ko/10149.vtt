WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:12.000
필립: 안녕하세요, 제 이름은 필립입니다.

00:00:12.000 --> 00:00:18.000
스위프트에서 마법의 새로운 기능을 발표하게 되어 정말 기쁩니다: 관찰.

00:00:18.000 --> 00:00:28.000
이 기능을 사용하면 표준 Swift 구문을 사용하여 모델을 정의하고 해당 유형을 사용하여 UI가 해당 모델의 변경 사항에 응답하도록 할 수 있습니다.

00:00:28.000 --> 00:00:33.000
이것은 SwiftUI로 매끄럽고 직관적으로 개발할 수 있게 해준다.

00:00:33.000 --> 00:00:51.000
오늘 우리는 몇 가지 주제를 다룰 것입니다: 관찰이 무엇인지에 대한 개요, SwiftUI의 속성 래퍼를 언제 사용해야 하는지에 대한 편리한 규칙 세트, 그리고 우리는 관찰 가능한 몇 가지 고급 사용법을 다룰 것입니다.

00:00:51.000 --> 00:01:02.000
그리고 우리는 ObservableObject를 사용하여 새로운 @Observable 매크로로 코드를 업데이트하는 방법에 대한 몇 가지 예를 요약할 것입니다.

00:01:02.000 --> 00:01:07.000
관찰은 속성의 변화를 추적하기 위한 새로운 스위프트 기능이다.

00:01:07.000 --> 00:01:13.000
그것은 일반 스위프트 유형과 함께 작동하며 매크로의 마법으로 변환합니다.

00:01:13.000 --> 00:01:21.000
우리는 종종 데이터 모델 유형을 작성하며, 결국 SwiftUI에서 사용하고 싶은 많은 속성을 가지고 있습니다.

00:01:21.000 --> 00:01:31.000
@Observable을 추가하는 것이 UI가 데이터 모델의 변경 사항에 응답하도록 하는 데 필요한 전부라고 말하면 어떨까요?

00:01:31.000 --> 00:01:37.000
Swift 5.9의 새로운 기능에서는 모델을 그 어느 때보다 간단하게 만들 수 있습니다.

00:01:37.000 --> 00:01:40.000
이것은 스위프트의 새로운 매크로 시스템을 사용한다.

00:01:40.000 --> 00:01:51.000
"@Observable"은 스위프트 컴파일러에게 당신이 쓴 것에서 유형을 관찰할 수 있는 확장된 형태로 변환하도록 지시합니다.

00:01:51.000 --> 00:01:56.000
관찰 가능한 유형을 사용하여 SwiftUI 뷰를 강화할 수 있습니다.

00:01:56.000 --> 00:02:01.000
그리고 놀라운 부분은 그들이 일하기 위해 어떤 종류의 부동산 포장도 필요하지 않다는 것이다.

00:02:01.000 --> 00:02:07.000
우리 도넛 푸드 트럭 앱에서 맛있는 샘플이 좀 있어, 그러니 바로 들어가자.

00:02:07.000 --> 00:02:11.000
여기 도넛을 보여주는 간단한 전망이 있습니다.

00:02:11.000 --> 00:02:18.000
SwiftUI는 바디 호출을 실행할 때 모델이 특정 속성에 액세스한다는 것을 알고 있다.

00:02:18.000 --> 00:02:26.000
이 경우 도넛 메뉴 보기의 본문을 실행할 때 '도넛' 속성에 액세스하는 것을 감지할 수 있습니다.

00:02:26.000 --> 00:02:33.000
본문이 실행되면, SwiftUI는 '관찰 가능한' 유형에서 사용된 속성에 대한 모든 액세스를 추적합니다.

00:02:33.000 --> 00:02:44.000
그런 다음 추적 정보를 사용하여 특정 인스턴스의 속성에 대한 다음 변경 사항이 언제 변경될지 결정합니다.

00:02:44.000 --> 00:02:56.000
여기서, 도넛 추가 버튼을 클릭하여 도넛 배열을 변경하면 도넛 메뉴 보기가 무효화되고 그에 따라 UI가 업데이트됩니다.

00:02:56.000 --> 00:03:08.000
깔끔한 것은, 주문이 추가되면, 그 속성이 뷰의 본문을 실행할 때 결정된 추적된 속성의 일부가 아니기 때문에 뷰가 무효화되지 않는다는 것입니다.

00:03:08.000 --> 00:03:12.000
다음으로 계산된 속성을 사용할 때 어떤 일이 일어나는지 알아봅시다.

00:03:12.000 --> 00:03:16.000
계산된 속성을 추가하는 것은 이전과 같은 규칙을 따른다.

00:03:16.000 --> 00:03:22.000
사용된 속성이 변경되면, UI가 업데이트됩니다.

00:03:22.000 --> 00:03:29.000
새로 추가된 콘텐츠에서, 주문 속성에 액세스하는 모델의 orderCount가 호출됩니다.

00:03:29.000 --> 00:03:41.000
즉, 이 예에서 주문이 변경되면 orderCount가 주문의 속성에 액세스하기 때문에 해당 텍스트가 업데이트됩니다.

00:03:41.000 --> 00:03:47.000
"@Observable" 매크로를 사용하면 관찰을 지원할 수 있도록 유형을 확장합니다.

00:03:47.000 --> 00:03:56.000
이를 통해 SwiftUI는 해당 속성에 대한 액세스를 추적하고 다음 속성이 해당 관찰에서 언제 변경될지 관찰할 수 있습니다.

00:03:56.000 --> 00:04:10.000
그런 것들을 추적하면 UI는 특정 속성이 변경될 때만 뷰의 본문을 다시 계산할 수 있으며, 우리는 그것으로부터 정말 환상적인 성능 개선을 보았습니다.

00:04:10.000 --> 00:04:19.000
매크로에 깊이 들어가고 싶다면, "스위프트 매크로 쓰기"와 "스위프트 매크로에서 확장" 세션을 확인하세요.

00:04:19.000 --> 00:04:25.000
Observable을 사용하면 SwiftUI의 속성 래퍼가 그 어느 때보다 쉬워졌습니다.

00:04:25.000 --> 00:04:32.000
상태, 환경 및 바인딩은 SwiftUI로 작업하기 위한 세 가지 주요 속성 래퍼입니다.

00:04:32.000 --> 00:04:42.000
우리는 이미 SwiftUI로 관찰 가능한 유형과 인터페이스하기 위해 속성 래퍼가 필요하지 않은 경우를 다루었지만, 당신이 하는 경우를 살펴봅시다.

00:04:42.000 --> 00:04:44.000
@State로 시작해.

00:04:44.000 --> 00:04:51.000
뷰가 모델에 자체 상태를 저장해야 할 때, @State 속성을 사용하세요.

00:04:51.000 --> 00:04:58.000
여기 시트 프레젠테이션에 사용되는 관찰 가능한 모델 객체 도넛이 있습니다.

00:04:58.000 --> 00:05:05.000
시트가 제시되면, donutToAdd 상태 변수는 값을 편집 가능한 필드에 바인딩하는 데 사용됩니다.

00:05:05.000 --> 00:05:11.000
"donutToAdd" 속성은 포함된 뷰의 수명에 따라 관리됩니다.

00:05:11.000 --> 00:05:14.000
다음으로, @Environment.

00:05:14.000 --> 00:05:20.000
환경은 가치를 전 세계적으로 접근 가능한 가치로 전파할 수 있게 해준다.

00:05:20.000 --> 00:05:24.000
이것은 많은 곳에서 사물을 공유할 수 있게 해준다.

00:05:24.000 --> 00:05:33.000
관찰 가능한 유형은 그들이 만든 업데이트가 액세스를 기반으로 하기 때문에 여기에서 환상적으로 작동합니다.

00:05:33.000 --> 00:05:41.000
푸드 트럭 메뉴 보기의 본문을 호출할 때, 계정 객체의 속성 사용자 이름에 액세스합니다.

00:05:41.000 --> 00:05:45.000
그래서 사용자 이름이 변경되면, 메뉴 보기가 업데이트됩니다.

00:05:45.000 --> 00:05:50.000
부동산 포장지 제품군의 최신은 '@Bindable'이다.

00:05:50.000 --> 00:05:53.000
바인딩 가능한 속성 래퍼는 정말 가볍다.

00:05:53.000 --> 00:05:58.000
그것이 하는 일은 그 유형에서 바인딩을 만들 수 있도록 하는 것이다.

00:05:58.000 --> 00:06:04.000
바인딩 가능한 포장된 속성에서 바인딩을 얻는 것은 정말 쉽다.

00:06:04.000 --> 00:06:09.000
그 속성에 바인딩을 얻기 위해 $ 구문을 사용하세요.

00:06:09.000 --> 00:06:13.000
대부분의 경우, 이것은 관찰 가능한 유형에 바인딩될 것이다.

00:06:13.000 --> 00:06:18.000
도넛 보기의 경우, 텍스트로 표시된 이름이 있습니다.

00:06:18.000 --> 00:06:22.000
하지만 실제로, 우리는 그 이름을 편집할 수 있기를 원한다.

00:06:22.000 --> 00:06:26.000
그래서 우리는 텍스트 대신 텍스트 필드를 사용할 수 있다.

00:06:26.000 --> 00:06:29.000
그 TextField는 바인딩을 취한다.

00:06:29.000 --> 00:06:39.000
그것은 TextField의 값을 채우기 위해 바인딩에서 읽지만, 사용자가 값을 변경할 때 바인딩에 다시 씁니다.

00:06:39.000 --> 00:06:47.000
도넛에 바인딩을 만들기 위해, 우리가 해야 할 일은 도넛 속성에 '@Bindable' 속성 래퍼를 사용하는 것입니다.

00:06:47.000 --> 00:06:55.000
속성 래퍼 주석을 사용하면 '$donut.name' 구문을 사용할 수 있으며 사용할 때 바인딩을 만들 수 있습니다.

00:06:55.000 --> 00:07:03.000
래퍼를 마무리하기 위해, SwiftUI에서 관찰 가능한 모델을 사용하기 위해 대답해야 할 질문은 세 가지뿐입니다.

00:07:03.000 --> 00:07:07.000
이 모델은 뷰 자체의 상태여야 하나요?

00:07:07.000 --> 00:07:10.000
그렇다면, '@State'를 사용하세요.

00:07:10.000 --> 00:07:15.000
이 모델은 애플리케이션의 글로벌 환경의 일부가 되어야 하나요?

00:07:15.000 --> 00:07:19.000
그렇다면, '@Environment'를 사용하세요.

00:07:19.000 --> 00:07:22.000
이 모델은 바인딩만 필요한가요?

00:07:22.000 --> 00:07:26.000
그렇다면, 새로운 '@Bindable'을 사용하세요.

00:07:26.000 --> 00:07:32.000
그리고 이 질문들 중 어느 것도 예라는 대답이 없다면, 모델을 당신의 관점의 속성으로 사용하세요.

00:07:32.000 --> 00:07:37.000
지금까지, 우리는 당신의 모델에서 저장된 것으로 시작하는 속성을 다루었습니다.

00:07:37.000 --> 00:07:40.000
관찰 가능한 것은 훨씬 더 많은 것을 할 수 있다.

00:07:40.000 --> 00:07:53.000
SwiftUI는 인스턴스당 필드에 대한 액세스를 추적하기 때문에, 배열, 선택 사항 또는 관찰 가능한 모델이 포함된 모든 유형을 사용할 수 있다는 것을 의미합니다.

00:07:53.000 --> 00:07:57.000
도넛 목록 보기에는 도넛 모델의 배열이 있다.

00:07:57.000 --> 00:08:01.000
각 모델 자체는 '@Observable'이다.

00:08:01.000 --> 00:08:14.000
도넛의 이름이 변경되면, SwiftUI는 특정 인스턴스에서 해당 속성에 대한 액세스를 감지하고 뷰를 무효화할 때를 알기 위해 추적합니다.

00:08:14.000 --> 00:08:23.000
그래서 여기서, 랜덤화 버튼을 통해 도넛 이름이 변경되면, 보기는 그에 따라 업데이트됩니다.

00:08:23.000 --> 00:08:27.000
이것은 당신이 원하는 방식으로 모델을 만들 수 있게 해준다.

00:08:27.000 --> 00:08:35.000
관찰되는 모델의 배열이나 다른 관찰 가능한 모델 유형을 포함하는 모델 유형을 가질 수 있습니다.

00:08:35.000 --> 00:08:44.000
일반적인 규칙은 Observable에 대한 것이며, 사용된 속성이 변경되면 보기가 업데이트됩니다.

00:08:44.000 --> 00:08:48.000
그 규칙이 완전히 적용되지 않는 경우가 있다.

00:08:48.000 --> 00:09:00.000
계산된 속성에 저장된 속성이 없는 경우, 관찰과 함께 작동하도록 두 가지 추가 단계를 수행해야 합니다.

00:09:00.000 --> 00:09:09.000
이것은 관찰 가능한 유형의 저장된 속성의 일종의 구성을 통해 관찰될 속성이 변경되지 않을 때만 수행되어야 합니다.

00:09:09.000 --> 00:09:18.000
이 경우, 해야 할 일은 재산이 언제 접근되고 재산이 언제 변경되는지 관찰에 알려주는 것이다.

00:09:18.000 --> 00:09:33.000
이것은 관찰이 일반적으로 속성에 대한 액세스를 합성하는 방법입니다. 여기서 우리는 관찰할 수 없는 위치를 읽고 이름을 저장할 수 있도록 사용자 지정 액세스 포인트를 수동으로 다시 작성했습니다.

00:09:33.000 --> 00:09:44.000
대부분의 경우, 이러한 유형의 수동 케이스는 필요하지 않습니다. 왜냐하면 대부분의 경우, 문제의 모델의 속성은 다른 저장된 속성으로 구성되기 때문입니다.

00:09:44.000 --> 00:09:55.000
하지만 고급 기능이 필요한 드문 경우, 관찰은 충분히 유연하지만 스스로 할 수 있을 만큼 쉽습니다.

00:09:55.000 --> 00:10:04.000
SwiftUI는 이러한 속성에 액세스하여 관찰 가능한 유형을 추적하기 때문에 구성의 변화를 식별할 수 있습니다.

00:10:04.000 --> 00:10:13.000
이것은 계산된 속성이 다른 저장된 속성으로 구성되어 있다면, 관찰이 작동한다는 것을 의미합니다.

00:10:13.000 --> 00:10:25.000
그러나, 그것이 사실이 아닌 몇 가지 경우, 관찰을 직접 사용하여 액세스 및 돌연변이 플래그 호출을 수동으로 추가할 수 있습니다.

00:10:25.000 --> 00:10:35.000
이전에 푸드 트럭 앱에서, 우리는 새로운 @Observable 매크로로 했던 것과 같은 것들을 달성하기 위해 ObservableObject를 사용했습니다.

00:10:35.000 --> 00:10:42.000
오늘 SwiftUI를 사용하는 앱이 있다면, 매우 비슷한 상황에 처할 수 있습니다.

00:10:42.000 --> 00:10:50.000
관찰 가능한 매크로는 코드를 단순화할 수 있으며, 괜찮은 성능 향상도 볼 수 있습니다.

00:10:50.000 --> 00:11:01.000
변경 전에, FoodTruckModel 유형은 ObservableObject 적합성을 가지고 있었고, @Published 속성 래퍼로 표시된 많은 속성을 가지고 있었다.

00:11:01.000 --> 00:11:06.000
@Observable 매크로로 바꾸는 것은 꽤 쉬웠다.

00:11:06.000 --> 00:11:16.000
ObservableObject에 대한 적합성을 제거하고, '@Published'를 제거하고, '@Observable' 매크로로 표시하기만 하면 됩니다.

00:11:16.000 --> 00:11:23.000
견해에 관해서는, 많은 '@ObservedObject'와 '@EnvironmentObject' 속성 래퍼가 있었다.

00:11:23.000 --> 00:11:34.000
'@ObservedObject' 래퍼의 모든 경우, 사라지거나 바인딩만 필요하고 새로운 '@Bindable'로 변경되었습니다.

00:11:34.000 --> 00:11:40.000
'@EnvironmentObject' 래퍼는 단지 '@Environment'로 변형되었다.

00:11:40.000 --> 00:11:48.000
ObservableObject에서 새로운 '@Observable' 매크로로 변경하는 것은 대부분 주석을 삭제하는 것이었다.

00:11:48.000 --> 00:11:57.000
또는 그것들을 세 가지 주요 속성 래퍼로 단순화하기; @State, @Environment, 그리고 @Bindable.

00:11:57.000 --> 00:12:04.000
고려해야 할 옵션이 적기 때문에 새로운 기능을 작성하는 것이 더 쉬워진다.

00:12:04.000 --> 00:12:09.000
관찰은 적절한 수준의 마법을 가지고 있다.

00:12:09.000 --> 00:12:17.000
쉽게 시작할 수 있으며 @Observable 매크로를 사용하여 데이터 모델로 직접 작업할 수 있습니다.

00:12:17.000 --> 00:12:24.000
필요할 때, 고급 사용 사례를 위한 수동 버전을 작성할 수 있습니다.

00:12:24.000 --> 00:12:30.000
새로운 개발을 위해, Observable을 사용하는 것이 시작하는 가장 쉬운 방법이다.

00:12:30.000 --> 00:12:38.000
그리고 기존 애플리케이션의 경우, Observable을 사용하면 새로운 기능을 추가할 때 모델을 단순화하고 성능을 향상시킬 수 있습니다.

00:12:38.000 --> 00:12:44.000
나는 당신이 그것을 시도하고 그 마법을 직접 활용하는 것을 권장합니다.

00:12:44.000 --> 23:59:59.000
♪ ♪

