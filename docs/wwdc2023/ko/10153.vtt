WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:16.000
알라: 안녕하세요, 제 이름은 알라 샤쉬키나이고, 저는 국제화 팀의 엔지니어입니다.

00:00:16.000 --> 00:00:18.000
저는 당신의 언어를 돕기 위해 여기에 있습니다.

00:00:18.000 --> 00:00:22.000
오늘 우리는 문법적 합의의 힘을 열 것이다.

00:00:22.000 --> 00:00:25.000
소프트웨어의 언어는 우리의 일상적인 상호 작용에 영향을 미친다.

00:00:25.000 --> 00:00:28.000
당신의 앱의 단어는 중요합니다.

00:00:28.000 --> 00:00:34.000
소프트웨어에서 언어를 다루는 것은 어려울 수 있으며, 특히 그 언어를 사용하지 않을 때 더욱 그렇습니다.

00:00:34.000 --> 00:00:41.000
2021년에, 우리는 당신의 앱이 문법적 합의를 하는 데 도움이 되는 새로운 API를 파운데이션에 도입했습니다.

00:00:41.000 --> 00:00:56.000
오늘, 저는 문법적으로 더 정확하고, 더 잘 들리고, 더 포괄적인 자연 언어를 통해 앱에 대한 다른 수준의 사용자 경험을 잠금 해제할 수 있는 파운데이션의 새로운 기능을 소개하고 싶습니다.

00:00:56.000 --> 00:00:59.000
그럼 뛰어들자.

00:00:59.000 --> 00:01:04.000
우리는 왜 문법 합의를 다루는 것이 중요하다고 생각하는지에 대한 매우 짧은 요약으로 시작할 것이다.

00:01:04.000 --> 00:01:11.000
2021년부터 지원을 추가한 언어로 다양한 예시를 안내해 드리겠습니다.

00:01:11.000 --> 00:01:17.000
우리는 문법 계약 공간에서 새로운 API에 대해 이야기하고 종속성 계약을 도입할 것이다.

00:01:17.000 --> 00:01:27.000
우리는 한 걸음 더 나아가 앱의 언어를 문법적으로 더 정확하게 만들 뿐만 아니라 더 포괄적으로 만들 수 있도록 어떻게 도울 수 있는지 스스로에게 물었습니다.

00:01:27.000 --> 00:01:32.000
문법은 앱을 만들 때 걱정해야 할 것이 되어서는 안 됩니다.

00:01:32.000 --> 00:01:38.000
우리는 잘 설계된 API가 언어적 복잡성을 완화하고 확장하는 데 도움이 될 수 있다고 믿습니다.

00:01:38.000 --> 00:01:45.000
UI의 풍부하고 문법적으로 올바른 단어는 사용자 경험을 완벽하고 즐겁게 만듭니다.

00:01:45.000 --> 00:01:48.000
다른 언어들은 그들만의 도전을 제시한다.

00:01:48.000 --> 00:01:55.000
이 모든 언어적 복잡성은 우리가 새로운 API를 설계할 때 고려하는 것이다.

00:01:55.000 --> 00:02:01.000
우리의 목표는 그 모든 것을 간단하고 사용하기 쉬운 인터페이스에 포장하는 것이다.

00:02:01.000 --> 00:02:07.000
문법적 합의가 어떻게 다른 언어로 시스템 전체에서 사용자 경험을 향상시키는지 간략하게 검토해 봅시다.

00:02:07.000 --> 00:02:19.000
2021년에 도입된 새로운 API를 사용하면 사용자가 선호하는 주소 용어와 변형 가능한 범위 내의 다른 단어에 따라 변경해야 하는 단어 범위를 지정할 수 있습니다.

00:02:19.000 --> 00:02:29.000
사용자가 여성적인 주소 용어를 선택하면, iPhone은 그녀가 처음으로 휴대폰을 설정할 때 스페인어로 여성스러운 설정으로 그녀를 맞이할 것이다.

00:02:29.000 --> 00:02:32.000
작년에, 세 개의 언어가 스페인어에 합류했다.

00:02:32.000 --> 00:02:39.000
프랑스어를 사용하는 사용자는 주소 용어를 선택할 때 더 개인화된 경험을 즐길 수 있습니다.

00:02:39.000 --> 00:02:46.000
시스템 전체의 소프트웨어는 Notes 앱의 이 예와 마찬가지로 그것을 반영하기 위해 단어를 바꿀 것이다.

00:02:46.000 --> 00:02:50.000
개인화된 문자열은 시스템 경험 전반에 걸쳐 널리 퍼져 있다.

00:02:50.000 --> 00:03:03.000
휴대폰을 설정하거나, 공유 메모로 작업하거나, 캘린더를 관리하는 언어는 여기처럼 이탈리아어 또는 브라질 포르투갈어로 설정에 맞게 적응하고 있습니다.

00:03:03.000 --> 00:03:12.000
올해, 우리는 두 개의 새로운 지역에 문법 합의에 대한 지원을 추가했습니다: 유럽 포르투갈어와 독일어.

00:03:12.000 --> 00:03:17.000
이제 올해 재단의 문법적 합의에 대한 새로운 것에 대해 이야기해 봅시다.

00:03:17.000 --> 00:03:21.000
언어는 복잡하지만, 좋은 API는 그렇지 않다.

00:03:21.000 --> 00:03:26.000
매우 자주, UI의 단어는 다른 단어를 기반으로 형태를 바꿀 필요가 있다.

00:03:26.000 --> 00:03:32.000
당신이 그것을 시각화하는 것을 돕기 위해, 우리의 음식 주문 앱의 예를 보여드리겠습니다.

00:03:32.000 --> 00:03:33.000
이건 스페인어야.

00:03:33.000 --> 00:03:38.000
스페인어에서, 형용사는 그들이 묘사하는 명사와 일치해야 한다.

00:03:38.000 --> 00:03:44.000
여기서, 음식 크기 "pequeño"는 그것이 묘사하는 음식인 "ensalada"와 일치해야 한다.

00:03:44.000 --> 00:03:52.000
이것은 언어의 특정 부분 사이에서 단어 합의가 발생하는 다른 언어에서도 매우 일반적인 사용 사례이다.

00:03:52.000 --> 00:03:57.000
그리고 이 단어들은 UI에서 분리되어 있기 때문에, 이런 종류의 합의를 처리하는 것은 쉽지 않다.

00:03:57.000 --> 00:04:03.000
우리는 이러한 유형의 종속성 계약을 쉽게 수정할 수 있는 새로운 API를 만들었습니다.

00:04:03.000 --> 00:04:08.000
수정은 매우 간단하며 코드 변경이 거의 필요하지 않습니다.

00:04:08.000 --> 00:04:15.000
여기서, 우리는 음식 크기 "pequeño"가 음식 이름인 "ensalada"와 일치하는 문자열을 원합니다.

00:04:15.000 --> 00:04:28.000
올해, 우리는 문법적 합의에 영향을 미치지만 인수처럼 문자열로 포맷되지 않는 객체를 지정할 수 있는 LocalizationOptions, 개념에 새로운 속성을 도입하고 있습니다.

00:04:28.000 --> 00:04:35.000
우리는 이 경우 "ensalada"에 동의하고 싶은 문자열 값에 대해 localizedPhrase 개념을 사용합니다.

00:04:35.000 --> 00:04:42.000
마지막으로, 우리는 agreeWithConcept로 굴절이 필요한 단어에 주석을 달아야 한다.

00:04:42.000 --> 00:04:49.000
여기서 1의 값은 우리가 개념 배열의 첫 번째 객체와 문법적 합의를 요구하고 있다는 것을 의미합니다.

00:04:49.000 --> 00:04:52.000
우리는 1 기반 인덱싱을 사용한다는 점에 유의하십시오.

00:04:52.000 --> 00:05:00.000
agreeWithConcept 속성도 올해 새로운 것이지만, 앱이 구형 장치에서 실행되더라도 사용할 수 있습니다.

00:05:00.000 --> 00:05:04.000
그럴 때, 우리는 단순히 그 속성을 무시할 것이다.

00:05:04.000 --> 00:05:10.000
이제 이러한 변경 사항을 도입했으니, UI를 살펴봅시다.

00:05:10.000 --> 00:05:14.000
"Pequeño"라는 단어가 "pequeña"로 바뀌었다는 것을 관찰하세요.

00:05:14.000 --> 00:05:18.000
이것은 스페인어로 "ensalada"를 설명할 때 사용하는 올바른 형태이다.

00:05:18.000 --> 00:05:25.000
이제 언어 향상이 필요한 다른 곳을 살펴봅시다.

00:05:25.000 --> 00:05:36.000
여기 "우리 샐러드에는 양상추, 치즈, 토마토, 햄이 들어 있습니다"라는 문장에서 스페인어 단어 "nuestro"와 "hecho"는 둘 다 명사 "ensalada"와 일치해야 합니다.

00:05:36.000 --> 00:05:43.000
운 좋게도, 우리는 문자열 내에서 문법적 합의를 용이하게 하기만 하면 되므로, 코드 변경이 필요하지 않습니다.

00:05:43.000 --> 00:05:49.000
먼저, "nuestro"가 inflect 속성으로 주석을 달아 음식에 동의하도록 합시다.

00:05:49.000 --> 00:05:57.000
우리가 인수가 있는 블록에서 inflect 속성을 사용할 때, 모든 단어가 문법적으로 인수와 일치하도록 노력할 것이다.

00:05:57.000 --> 00:06:02.000
하지만, 우리가 반영해야 할 단어가 하나 더 있다, "hecho."

00:06:02.000 --> 00:06:10.000
우리는 모호함을 돕기 위해 inflect 블록을 가능한 한 짧게 유지하려고 노력하므로, inflect로 "hecho"에 주석을 달 수 없습니다: true.

00:06:10.000 --> 00:06:16.000
올해, 우리는 agreeWithArgument라는 또 다른 새로운 속성을 소개합니다.

00:06:16.000 --> 00:06:32.000
음식 이름의 값을 전달하여 코드 베이스를 변경해야 하는 agreeWithConcept와 달리, agreeWithArgument 속성은 코드 변경이 필요하지 않으며 inflect 속성과 합의가 불가능한 쉬운 방법입니다.

00:06:32.000 --> 00:06:40.000
우리는 "hecho"가 문자열의 다른 곳에 있는 주장에 동의해야 한다는 것을 나타내기 위해 agreeWithArgument를 사용할 수 있다.

00:06:40.000 --> 00:06:47.000
여기서, 1의 값은 우리가 그 단어가 문자열의 첫 번째 인수와 일치하기를 원한다는 것을 의미한다.

00:06:47.000 --> 00:06:54.000
이러한 변경 사항으로, UI를 다시 살펴봅시다.

00:06:54.000 --> 00:07:01.000
이제 두 단어 모두 문법적으로 "ensalada"와 일치하도록 포맷되어 있으며, 우리는 현지화에서 완전히 올바른 스페인어를 사용합니다.

00:07:01.000 --> 00:07:06.000
다음으로, 비슷하지만 아직 다른 예를 살펴봅시다.

00:07:06.000 --> 00:07:08.000
이건 프랑스어야.

00:07:08.000 --> 00:07:13.000
프랑스어에서, 시범 형용사는 그들이 묘사하는 명사와 일치해야 한다.

00:07:13.000 --> 00:07:24.000
우리가 agreeWithConcept와 inflect 속성을 적용했기 때문에 크기와 수량 버튼이 이미 스페인어로 고정되어 있다는 것을 주목하세요.

00:07:24.000 --> 00:07:27.000
이 시범 사례를 프랑스어로 수정합시다.

00:07:27.000 --> 00:07:28.000
그 해결책은 정말 쉬워.

00:07:28.000 --> 00:07:36.000
형용사와 인수를 모두 굴절로 감싸세요: 진정한 블록 그리고 엔진이 마법을 부리도록 하세요.

00:07:36.000 --> 00:07:41.000
Et voila, 문법적으로 정확한 음식은 그냥 더 맛있어.

00:07:41.000 --> 00:07:48.000
요약하자면, 의존성 계약은 그들이 의존하는 다른 단어에 따라 단어를 바꿀 수 있게 해준다.

00:07:48.000 --> 00:07:57.000
단어가 같은 문장 내에 존재하지 않는 다른 단어나 구문에 동의하기를 원할 때 agreeWithConcept 속성을 사용하세요.

00:07:57.000 --> 00:08:07.000
단어가 다른 단어나 구문과 일치하기를 원하는 상황에 대해 agreeWithArgument 속성을 사용하세요. 그리고 둘 다 같은 문자열에 있습니다.

00:08:07.000 --> 00:08:12.000
이제 포괄적인 언어를 위한 새로운 API에 대해 이야기해 봅시다.

00:08:12.000 --> 00:08:15.000
Caffé 앱을 다시 살펴봅시다.

00:08:15.000 --> 00:08:20.000
우리가 점심으로 작은 샌드위치와 작은 주스를 골라서 주문했다고 가정해 봅시다.

00:08:20.000 --> 00:08:24.000
우리는 정말 배가 고프기 때문에, 배달 상태를 확인하고 싶습니다.

00:08:24.000 --> 00:08:28.000
토니가 우리 주문을 곧 배달할 것 같아.

00:08:28.000 --> 00:08:33.000
사용자 인터페이스를 현지화할 때, 성 중립적인 언어를 사용하는 것이 좋습니다.

00:08:33.000 --> 00:08:39.000
동시에, UI에서 젠더 언어를 사용하는 것은 더 개인적이고 더 자연스럽게 들린다.

00:08:39.000 --> 00:08:45.000
그와 그의 대명사를 사용하는 토니를 위해 이 문자열을 개인화해 봅시다.

00:08:45.000 --> 00:08:51.000
먼저, 우리는 배달원이 선호하는 주소 용어를 포함하도록 모델을 변경해야 합니다.

00:08:51.000 --> 00:08:58.000
그것을 나타내기 위해, 우리는 올해 새로운 TermOfAddress 유형의 새로운 속성을 추가합니다.

00:08:58.000 --> 00:09:04.000
그런 다음, 우리는 주소 용어를 남성적, 여성적 또는 중립적인 것으로 설정할 수 있습니다.

00:09:04.000 --> 00:09:11.000
우리는 그와 그의 대명사를 사용하여 토니를 언급하고 싶기 때문에, 우리는 남성을 선택한다.

00:09:11.000 --> 00:09:15.000
다음으로, 우리는 대명사가 바뀌어야 하는 문자열에 주석을 달아야 한다.

00:09:15.000 --> 00:09:20.000
그렇게 하기 위해, 우리는 새로운 referentConcept 속성을 사용합니다.

00:09:20.000 --> 00:09:27.000
1의 값은 대명사의 참조가 LocalizationOptions의 첫 번째 개념이어야 함을 나타냅니다.

00:09:27.000 --> 00:09:35.000
당신은 3인칭 인칭 대명사에 referentConcept를 적용할 수 있으며, 엔진은 그것을 무엇으로 대체할지 알아낼 것입니다.

00:09:35.000 --> 00:09:40.000
이제 문자열을 굴절할 때 termsOfAddress 굴절 개념을 전달해 봅시다.

00:09:40.000 --> 00:09:47.000
우리는 문법적 합의를 위해 이전에 했던 것처럼 이것을 LocalizationOptions의 개념 속성에 할당합니다.

00:09:47.000 --> 00:09:52.000
이것이 영어로 된 UI를 어떻게 바꾸는지 봅시다.

00:09:52.000 --> 00:09:57.000
"그들의"과 "그들"이 어떻게 "그"과 "그"로 대체되었는지 주목하세요.

00:09:57.000 --> 00:10:01.000
같은 현지화된 문자열을 사용하여 다른 사람들도 참조할 수 있습니다.

00:10:01.000 --> 00:10:07.000
그녀와 그녀의 대명사를 사용하는 누군가를 지칭하고 싶을 때 여성 용어를 사용하세요.

00:10:07.000 --> 00:10:14.000
그리고 그들과 대명사를 사용하는 누군가를 언급하고 싶을 때 중립적인 주소 용어를 사용하세요.

00:10:14.000 --> 00:10:19.000
또한 현지화된 주소 용어를 사용하여 대명사를 더욱 개인화할 수 있습니다.

00:10:19.000 --> 00:10:26.000
현지화된 주소 용어에서, 이 경우 영어에 적용되는 언어를 지정해야 합니다.

00:10:26.000 --> 00:10:33.000
그리고 새로운 Morphology.Pronoun 유형을 사용하여 사용하고 싶은 모든 대명사 형태를 나열하세요.

00:10:33.000 --> 00:10:37.000
영어로, 우리는 다섯 개의 대명사를 나열해야 한다.

00:10:37.000 --> 00:10:44.000
각 대명사는 대상 언어의 대명사 형태와 언제 사용해야 하는지 설명하는 형태학으로 구성되어 있다.

00:10:44.000 --> 00:10:50.000
대명사 구성에 대한 자세한 지침은 문서를 참조하십시오.

00:10:50.000 --> 00:10:55.000
이 API를 사용하는 것은 앱의 개인화를 향상시키는 좋은 방법입니다.

00:10:55.000 --> 00:11:00.000
우리는 이 기술을 사용하여 iOS의 현지화된 문자열에 사용되는 언어를 조정합니다.

00:11:00.000 --> 00:11:04.000
이제 이 모든 새로운 기능이 데모에서 어떻게 작동하는지 보여드리겠습니다.

00:11:04.000 --> 00:11:08.000
나는 모두가 지금 우리 카페 앱에서 맛있는 음식에 굶주렸으면 좋겠어.

00:11:08.000 --> 00:11:15.000
내가 스페인어로 시작할게.

00:11:15.000 --> 00:11:18.000
메뉴에 뭐가 있는지 보자.

00:11:18.000 --> 00:11:23.000
이번에는 피자를 주문하자.

00:11:23.000 --> 00:11:25.000
여기 우리가 방금 논의한 것과 같은 문법 문제가 있습니다.

00:11:25.000 --> 00:11:30.000
스페인어에서, 결정자와 형용사는 명사와 일치해야 한다.

00:11:30.000 --> 00:11:35.000
두 단어가 서로 일치하도록 하기 위해, 우리는 굴절을 사용할 수 있다: 진정한 속성.

00:11:35.000 --> 00:11:40.000
그러니 이 쉬운 수정을 "nuestro"와 "pizza"라는 단어에 적용해 봅시다.

00:11:40.000 --> 00:11:52.000
먼저, 문자열 카탈로그에서 이 문자열을 찾아봅시다.

00:11:52.000 --> 00:12:02.000
"Nuestro"가 "피자"라는 주장에 동의하도록 하기 위해, 우리는 둘 다 굴절로 묶는다: 진정한 블록.

00:12:02.000 --> 00:12:08.000
다음으로, 같은 문장에서 "피자"와 일치해야 하는 형용사 "hecho"를 수정합시다.

00:12:08.000 --> 00:12:12.000
우리는 여기서 agreeWithArgument 속성을 사용하고 싶습니다.

00:12:12.000 --> 00:12:18.000
우리는 일반적으로 굴절을 유지하려고 노력한다: 진정한 블록은 모호함을 돕기 위해 가능한 한 짧게 한다.

00:12:18.000 --> 00:12:27.000
"Hecho"는 굴절 블록에서 멀리 떨어져 있기 때문에, 이번에는 "agreeWithArgument" 속성을 사용해야 합니다.

00:12:27.000 --> 00:12:35.000
여기서 1의 값은 우리가 "hecho"가 문자열의 첫 번째 인수, 이 경우 "pizza"에 동의하기를 원한다는 것을 나타냅니다.

00:12:35.000 --> 00:12:43.000
우리 앱을 다시 실행하자.

00:12:43.000 --> 00:12:48.000
이제 이것은 스페인어로 훌륭한 현지화 경험처럼 보인다.

00:12:48.000 --> 00:12:55.000
이제 여기서 음식 크기를 수정하기 위해 새로운 agreeWithConcept 속성을 어떻게 사용할 수 있는지 봅시다.

00:12:55.000 --> 00:13:03.000
피자는 여성적이기 때문에, 그것을 묘사하는 형용사는 "페케냐"여야 한다.

00:13:03.000 --> 00:13:07.000
우리는 이미 음식 크기에 대한 현지화된 이름을 정의했습니다.

00:13:07.000 --> 00:13:16.000
계약을 수정하기 위해, 우리는 현지화된 이름을 특정 식품에 동의하는 방법으로 변환하고 싶습니다.

00:13:16.000 --> 00:13:22.000
다음으로, 우리는 SIZE_BUTTON을 포맷할 때 음식 이름을 전달하고 싶습니다.

00:13:22.000 --> 00:13:27.000
여기서, 우리는 현지화 옵션, 개념에 대한 새로운 속성을 정의할 것이다.

00:13:27.000 --> 00:13:35.000
개념은 문법적 굴절에 영향을 미치지만 인수와 같은 방식으로 문자열로 보간되지 않는 객체이다.

00:13:35.000 --> 00:13:45.000
여기서, 우리는 문법적으로 동의하고 싶은 문자열을 삽입하기 위해 localizedPhrase 개념을 사용합니다.

00:13:45.000 --> 00:13:55.000
그리고 우리는 문자열을 초기화할 때 정의된 옵션을 사용하는 것을 기억해야 합니다.

00:13:55.000 --> 00:14:04.000
다음으로, 우리는 스페인어 문자열 카탈로그를 수정하고 싶습니다.

00:14:04.000 --> 00:14:16.000
우리는 이것을 새로운 속성 agreeWithConcept로 주석을 달고 싶습니다.

00:14:16.000 --> 00:14:25.000
여기서 1의 값은 우리가 이 주장이 우리가 현지화 옵션에 전달한 첫 번째 개념에 동의하기를 원한다는 것을 나타냅니다.

00:14:25.000 --> 00:14:35.000
마지막으로, 사용자가 원하는 피자의 크기를 선택하는 FoodSizeView를 새로운 방법으로 업데이트해 봅시다.

00:14:35.000 --> 00:14:41.000
이제 앱을 다시 실행하고 마침내 피자를 주문합시다.

00:14:41.000 --> 00:14:45.000
놀랍게도, 우리의 음식 크기는 여기 피자와 정확하게 일치한다.

00:14:45.000 --> 00:14:49.000
스페인어로 남성적인 샌드위치를 먹어보자.

00:14:49.000 --> 00:14:51.000
이거 멋져 보여.

00:14:51.000 --> 00:15:03.000
이제 영어로 앱을 실행하고, 마지막으로 피자를 주문합시다.

00:15:03.000 --> 00:15:07.000
나는 이번에 큰 것을 선택할 것이다.

00:15:07.000 --> 00:15:12.000
그리고 두 개로 만들자. 왜 안 돼?

00:15:12.000 --> 00:15:15.000
토니가 우리 주문을 곧 배달할 것 같아.

00:15:15.000 --> 00:15:21.000
여기서 성 중립적인 언어는 훌륭하지만, 우리는 토니가 그의 대명사를 그/그/그로 설정했다는 것을 우연히 알게 되었다.

00:15:21.000 --> 00:15:24.000
이것은 우리가 쉽게 고칠 수 있는 것이다.

00:15:24.000 --> 00:15:35.000
그렇게 하기 위해, 배달원이 선호하는TermsofAddress를 포함하도록 모델을 확장합시다.

00:15:35.000 --> 00:15:45.000
그리고 토니의 사례를 확장하고 그가 남성 대명사를 사용하는 것을 선호한다는 것을 나타냅시다.

00:15:45.000 --> 00:15:52.000
다음으로, 우리는 문자열 자체를 바꾸고 싶다.

00:15:52.000 --> 00:15:59.000
여기서, 우리는 배달원의 주소 조건에 따라 "그들"을 대명사로 대체하고 싶습니다.

00:15:59.000 --> 00:16:07.000
이를 위해, 우리는 새로운 referentConcept 속성을 사용합니다.

00:16:07.000 --> 00:16:16.000
여기서 1의 값은 대명사 "they"의 참조자가 LocalizationOptions에서 통과된 첫 번째 개념이어야 한다는 것을 의미합니다.

00:16:16.000 --> 00:16:29.000
우리는 이것을 이 문장의 3인칭 대명사에 적용할 수 있다.

00:16:29.000 --> 00:16:35.000
다음으로, 우리는 LocalizationOptions의 개념으로 termsOfAddress를 전달하고 싶습니다.

00:16:35.000 --> 00:16:43.000
배달 메시지를 위한 현지화 옵션을 초기화해 봅시다.

00:16:43.000 --> 00:16:59.000
여기서, 우리는 또한 문법적 합의에 사용할 수 있는 termsOfAddress를 제공하기 위해 termsOfAddress 개념을 사용할 수 있습니다.

00:16:59.000 --> 00:17:07.000
그리고 마지막으로, 문자열을 초기화할 때 새로운 LocalizationOptions를 사용합시다.

00:17:07.000 --> 00:17:15.000
이제 우리 앱을 다시 실행해 봅시다.

00:17:15.000 --> 00:17:19.000
좋아, 거대한 피자, 두 개.

00:17:19.000 --> 00:17:24.000
셋으로 하자.

00:17:24.000 --> 00:17:30.000
이제 우리가 합의를 적용했으므로, 이것은 훨씬 더 개인적인 것처럼 보인다.

00:17:30.000 --> 00:17:36.000
올해 재단에는 많은 훌륭한 새로운 기능이 있으며, 오늘 앱에서 시도해 볼 준비가 되어 있습니다.

00:17:36.000 --> 00:17:40.000
Inflect: true는 올해 더 많은 언어를 지원합니다.

00:17:40.000 --> 00:17:49.000
우리의 새로운 종속성 계약 API는 동일한 문자열 내에서 또는 심지어 완전히 문맥에서 벗어난 단어에 동의하는 데 도움이 될 것입니다.

00:17:49.000 --> 00:17:58.000
마지막으로, Markdown의 새로운 termsOfAddress 굴절 개념과 referentConcept 속성은 언어를 더 개인화하는 데 도움이 될 것입니다.

00:17:58.000 --> 00:18:02.000
언어 수준의 지원은 저희 문서를 참조하십시오.

00:18:02.000 --> 00:18:04.000
네가 이 새로운 기능들을 좋아하길 바라.

00:18:04.000 --> 00:18:08.000
우리는 그들이 곧 당신의 앱에서 언어를 아름답게 하는 것을 보기를 고대하고 있습니다.

00:18:08.000 --> 00:18:09.000
고마워.

00:18:09.000 --> 00:18:13.000
오, 그리고 내 피자가 도착했어. 고마워, 토니.

00:18:13.000 --> 23:59:59.000
♪ ♪

