WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:11.000
크리스토퍼: 안녕하세요, 환영합니다!

00:00:11.000 --> 00:00:15.000
제 이름은 크리스토퍼이고, 저는 ScreenCaptureKit 팀의 소프트웨어 엔지니어입니다.

00:00:15.000 --> 00:00:24.000
저는 제 동료 나탈리 린제이와 합류할 것이며, 함께 애플리케이션의 화면 캡처 기능을 향상시킬 새로운 기능을 소개할 것입니다.

00:00:24.000 --> 00:00:31.000
ScreenCaptureKit은 애플리케이션의 화면 공유 경험을 만들 수 있도록 macOS 12.3에 도입되었습니다.

00:00:31.000 --> 00:00:43.000
ScreenCaptureKit은 애플리케이션의 요구에 맞는 컨트롤과 함께 공유하고 싶은 콘텐츠를 사용자 정의할 수 있는 API를 제공하며, 모두 스트림에 동적으로 적용할 수 있습니다.

00:00:43.000 --> 00:00:54.000
이 프레임워크는 글로벌 보호 장치를 염두에 두고 디스플레이의 기본 해상도와 프레임 속도까지 올라가는 성능에 중점을 둔 고품질 콘텐츠를 제공합니다.

00:00:54.000 --> 00:00:59.000
올해 ScreenCaptureKit은 새로운 macOS 기능과 통합되는 여러 개발자 API를 제공합니다.

00:00:59.000 --> 00:01:08.000
발표자 오버레이는 사람들이 캡처된 콘텐츠에 자신을 삽입하여 화면 공유와 프레젠테이션을 더 개인적으로 만들 수 있는 기능입니다.

00:01:08.000 --> 00:01:14.000
새로운 화면 공유 선택기를 사용하면 화면 공유에서 캡처한 것에 대한 시스템 차원의 경험을 통합할 수 있습니다.

00:01:14.000 --> 00:01:24.000
마지막으로, 화면 캡처는 라이브 스트림만을 위한 것이 아니며, 올해는 선택한 모든 콘텐츠의 고화질 스크린샷을 캡처할 수 있는 새로운 API가 있습니다.

00:01:24.000 --> 00:01:28.000
사람들은 전 세계에서 매일 서로 상호 작용한다.

00:01:28.000 --> 00:01:32.000
이러한 상호 작용은 우리가 우리의 생각과 아이디어를 공유하고 중요한 문제를 해결하는 곳이다.

00:01:32.000 --> 00:01:35.000
그들은 둘 다 전문적이고 개인적이다.

00:01:35.000 --> 00:01:40.000
이를 위해, 당신의 앱은 발표자 오버레이라는 새로운 비디오 효과와 원활하게 작동할 수 있습니다.

00:01:40.000 --> 00:01:50.000
콘텐츠를 공유할 때, 발표자 오버레이는 공유 콘텐츠 위에 발표자를 포함시켜 발표자의 존재를 높이고, 더 생산적인 원격 통화를 위한 개인적인 터치를 추가합니다.

00:01:50.000 --> 00:02:03.000
작은 오버레이는 고급 세분화 알고리즘 덕분에 발표자를 움직일 수 있는 창에 배치하는 반면, 큰 오버레이는 발표자의 얼굴과 몸을 배경에서 분리한 다음 더 몰입감 있는 효과를 위해 화면 콘텐츠를 계층화합니다.

00:02:03.000 --> 00:02:08.000
발표자 오버레이는 ScreenCaptureKit을 사용하는 모든 응용 프로그램에서 사용할 수 있습니다.

00:02:08.000 --> 00:02:21.000
생성된 모든 SCStream에 대해 ScreenCaptureKit은 화면 공유 선택기에 알리고, 스트림 컨트롤이 있는 라이브 미리보기가 새로운 비디오 메뉴 표시줄 항목에 표시됩니다.

00:02:21.000 --> 00:02:29.000
비디오 메뉴 표시줄은 활성 스트림이 있는 모든 응용 프로그램을 표시하고, 모든 응용 프로그램과 관련된 스트림의 라이브 미리보기를 표시합니다.

00:02:29.000 --> 00:02:36.000
이 메뉴 표시줄에서 스트림 전체 화면 공유 선택기를 표시하여 스트림 콘텐츠를 제어할 수 있습니다.

00:02:36.000 --> 00:02:43.000
이것은 또한 카메라 프레임을 콘텐츠 스트림에 삽입하는 발표자 오버레이가 활성화된 곳이다.

00:02:43.000 --> 00:02:49.000
그리고 이것을 사용하여 화면 공유를 교체하거나 종료하는 것과 같이 스트림을 제어할 수도 있습니다.

00:02:49.000 --> 00:02:55.000
카메라와 마이크 효과를 사용자 정의하기 위한 다른 유용한 기능이 있습니다.

00:02:55.000 --> 00:03:01.000
ScreenCaptureKit과 카메라를 함께 사용하는 모든 응용 프로그램은 이러한 기능이 자동으로 작동합니다.

00:03:01.000 --> 00:03:06.000
현재, 스트림에는 ScreenCaptureKit에서 프로세스로 전송된 콘텐츠 프레임이 있습니다.

00:03:06.000 --> 00:03:15.000
이제, 애플리케이션이 활성 스트림 중에 카메라를 사용하기 시작하면, 프레젠테이션 오버레이는 비디오 메뉴 항목에서 사용할 수 있습니다.

00:03:15.000 --> 00:03:22.000
활성화되면, ScreenCaptureKit은 카메라를 가져가서 응용 프로그램이 이미 실행 중인 선택한 스트림에 렌더링을 적용합니다.

00:03:22.000 --> 00:03:26.000
활성 스트림에서 합성된 프레임을 자동으로 얻을 수 있습니다.

00:03:26.000 --> 00:03:31.000
그래서 발표자 오버레이가 언제 적용되었는지 명확하게 알고 싶다면 어떨까요?

00:03:31.000 --> 00:03:35.000
새로운 스트림을 만들고 자신을 대리인으로 추가하는 것부터 시작합시다.

00:03:35.000 --> 00:03:42.000
그런 다음 SCStream, outputEffectDidStart에서 새로운 대리자 콜백을 구현할 것입니다.

00:03:42.000 --> 00:03:46.000
이것이 발표자 오버레이가 적용되었을 때 알림을 받는 방법입니다.

00:03:46.000 --> 00:03:51.000
알림을 받으면, 효과가 시작되었는지 멈췄는지 확인하고 싶습니다.

00:03:51.000 --> 00:04:00.000
발표자 오버레이는 새로운 macOS 시스템 기능이며, 오버레이가 적용될 때 애플리케이션이 취할 수 있는 몇 가지 고려 사항이 있습니다.

00:04:00.000 --> 00:04:06.000
발표자 오버레이가 켜져 있으면, AVCaptureSession은 일반적인 라이브 카메라 스트림을 보내지 않습니다.

00:04:06.000 --> 00:04:10.000
그것은 당신의 카메라가 오버레이에서 직접 사용될 것이기 때문입니다.

00:04:10.000 --> 00:04:15.000
이 변화를 설명하기 위해 애플리케이션 UI를 업데이트하기에 좋은 시간이 될 것이다.

00:04:15.000 --> 00:04:23.000
예를 들어, 화상 회의 응용 프로그램은 카메라와 혼합되는 공유 콘텐츠를 고려하여 오디오 및 비디오 동기화를 조정하고자 할 수 있습니다.

00:04:23.000 --> 00:04:28.000
더 최적화된 모습을 위해 발표자의 카메라 타일을 숨기고 싶을 수도 있습니다.

00:04:28.000 --> 00:04:35.000
발표자 오버레이는 카메라 및 비디오 기능이므로, 애플리케이션은 더 높은 프레임 속도를 위해 최적화해야 합니다.

00:04:35.000 --> 00:04:47.000
발표자 오버레이 외에도, 새로운 시스템 전체 화면 공유 선택기를 활용할 수 있으며, 이를 통해 애플리케이션이 사람들이 공유하고 싶은 콘텐츠를 선택하는 방법을 중심으로 한 여러 기능과 완전히 통합할 수 있습니다.

00:04:47.000 --> 00:04:51.000
이것들은 당신이 스트림을 만드는 데 사용하는 일반적인 구성입니다.

00:04:51.000 --> 00:04:57.000
현재, 당신은 공유할 수 있는 사용 가능한 모든 화면 콘텐츠를 얻기 위해 SCSharableContent에 전화합니다.

00:04:57.000 --> 00:05:00.000
당신은 그것을 사용하여 SCContentFilter를 만들 것입니다.

00:05:00.000 --> 00:05:05.000
SCContentFilter는 캡처할 것을 결정하는 데 사용할 것입니다.

00:05:05.000 --> 00:05:13.000
현재, 당신은 SCSharableContent에서 그것을 구축하지만, 올해 새로, 당신은 선택기를 통해 콘텐츠 필터를 얻을 수 있을 것입니다.

00:05:13.000 --> 00:05:16.000
피커가 SCContentFilters를 생성하는 두 가지 방법이 있습니다.

00:05:16.000 --> 00:05:20.000
첫째, 원하는 콘텐츠는 시스템 선택기를 통해 공유할 수 있습니다.

00:05:20.000 --> 00:05:25.000
둘째, 콘텐츠는 열려 있는 창에서 바로 선택할 수 있습니다.

00:05:25.000 --> 00:05:30.000
두 경우 모두, 시스템은 당신의 애플리케이션과 SCContentFilter를 공유합니다.

00:05:30.000 --> 00:05:34.000
하지만 새로운 콘텐츠 필터를 애플리케이션에 어떻게 넣나요?

00:05:34.000 --> 00:05:38.000
새로운 API, SCContentSharingPicker를 사용함으로써.

00:05:38.000 --> 00:05:51.000
SCContentSharingPicker는 애플리케이션과 OS 간의 인터페이스 역할을 하며, 새로운 스트림 요청, 새로운 콘텐츠 필터 및 현재 스트림 및 콘텐츠 필터에 대한 업데이트를 애플리케이션에 위임 콜백을 제공합니다.

00:05:51.000 --> 00:06:00.000
SCContentSharingPicker에는 윈도우, 앱 또는 디스플레이를 기반으로 콘텐츠를 선택할 수 있는 시스템 수준의 콘텐츠 선택기가 내장되어 있습니다.

00:06:00.000 --> 00:06:16.000
애플리케이션의 버튼, 새로운 비디오 메뉴 표시줄 또는 창에서 직접 콘텐츠 선택을 시작하든, 애플리케이션은 SCContentSharingPicker를 활용하여 진행 중인 스트림에 대한 활성 선택을 추가, 제거 또는 대체할 수 있습니다.

00:06:16.000 --> 00:06:24.000
또한 애플리케이션이 새 스트림이 언제 요청되는지 알 수 있는 스트림 요청 콜백이 내장되어 있습니다.

00:06:24.000 --> 00:06:31.000
그리고 마지막으로, 시스템 경험이 각 스트림에 어떻게 적용되는지 정의할 수 있는 스트림별 사용자 지정이 함께 제공됩니다.

00:06:31.000 --> 00:06:44.000
SCStream의 필터를 얻기 위한 구조는 이제 SCSharableContent를 사용하는 것에서 SCContentSharingPicker 싱글톤과 함께 시스템 선택기 인터페이스를 사용하여 SCContentFilter를 다시 전달하는 것으로 이동합니다.

00:06:44.000 --> 00:06:50.000
당신의 애플리케이션이 이 새로운 화면 공유 선택기를 활용하는 것이 얼마나 쉬운지 보여드리겠습니다.

00:06:50.000 --> 00:06:58.000
SCContentSharingPicker의 공유 인스턴스로 시작하여 자신을 관찰자로 추가하여 모든 적절한 클래스 콜백을 받을 수 있습니다.

00:06:58.000 --> 00:07:03.000
시스템이 내 피커 인스턴스를 인식하려면, 활성으로 설정하세요.

00:07:03.000 --> 00:07:11.000
일단 활성화되면, 시스템은 당신의 선택기에 대해 알게 될 것이며, 당신의 애플리케이션은 시스템 UI에 포함될 것이며 사람들은 그것과 상호 작용할 수 있을 것입니다.

00:07:11.000 --> 00:07:21.000
당신은 사람들이 피커를 통해 창을 선택할 수 있는 스트림을 만들고 싶기 때문에, 싱글톤 메소드 picker.present를 호출하고 nil과 당신이 제시하고 싶은 피커 스타일을 전달할 것입니다.

00:07:21.000 --> 00:07:28.000
사람들이 UI 버튼을 누르면, 선택기가 표시되어 캡처하고 싶은 창을 선택할 수 있습니다.

00:07:28.000 --> 00:07:34.000
그 콘텐츠가 선택된 후, 새 필터의 관찰자 콜백을 통해 알림을 받게 될 것입니다.

00:07:34.000 --> 00:07:40.000
그리고 이제 이 필터를 사용하여 새 스트림을 만들거나 기존 스트림을 업데이트할 수 있습니다.

00:07:40.000 --> 00:07:43.000
나머지 관찰자 콜백도 똑같이 중요하다.

00:07:43.000 --> 00:07:47.000
피커를 활성화하고 제시하여 다시 설정하세요.

00:07:47.000 --> 00:07:51.000
당신은 또한 당신이 그것을 제시해 달라고 요청했을 때 피커가 실패했는지 알고 싶을 것입니다.

00:07:51.000 --> 00:07:57.000
만약 그것이 실패했다면, 당신은 사람들에게 알리기 위해 신청서에 알림을 게시하고 싶을 것입니다.

00:07:57.000 --> 00:08:06.000
또한, 피커가 제시되었지만 취소된 경우, 콘텐츠가 선택되지 않은 경우, 그에 따라 스트림의 상태를 설정해야 합니다.

00:08:06.000 --> 00:08:13.000
SCContentSharingPicker는 또한 시스템이 스트림별 수준에서 어떻게 동작할지 사용자 정의할 수 있는 방법을 제공합니다.

00:08:13.000 --> 00:08:18.000
SCContentSharingPickerConfiguration은 몇 가지 사용자 지정을 허용합니다.

00:08:18.000 --> 00:08:27.000
AllowedPickingModes는 콘텐츠 필터에 대한 창, 응용 프로그램 및 디스플레이 선택 간에 허용되는 피킹 모드 중 하나를 시스템에 알려줍니다.

00:08:27.000 --> 00:08:35.000
그것은 또한 시스템 경험에 의해 선택될 수 없는 excludedWindowID와 bundleID의 명시적인 선언을 허용합니다.

00:08:35.000 --> 00:08:42.000
사람들이 변경하는 것을 원하지 않는 스트림이 있다면, SCContentSharingPickerConfiguration에는 해당 기능을 적용할 수 있는 속성이 있습니다.

00:08:42.000 --> 00:08:45.000
먼저, 당신은 공유 피커 인스턴스를 받게 될 것입니다.

00:08:45.000 --> 00:08:49.000
자신을 관찰자로 추가하고 피커를 활성화하는 것으로 시작하세요.

00:08:49.000 --> 00:08:52.000
이제, 적절한 구성 설정을 설정하세요.

00:08:52.000 --> 00:08:59.000
이 스트림의 경우, 아마도 당신은 두 개의 특정 응용 프로그램의 선택을 제외하고 싶고 재선택을 허용하고 싶지 않을 것입니다.

00:08:59.000 --> 00:09:07.000
구성이 설정되면, 선택기에서 설정 구성을 호출하여 구성 및 응용 스트림을 전달하십시오.

00:09:07.000 --> 00:09:11.000
이제 피커는 주어진 스트림에 대해 어떻게 행동해야 하는지 정확히 알게 될 것이다.

00:09:11.000 --> 00:09:19.000
또한 각 스트림은 애플리케이션의 요구에 가장 잘 맞는 다른 피커 구성을 가질 수 있다는 점에 유의하십시오.

00:09:19.000 --> 00:09:28.000
요약하자면, 모든 ScreenCaptureKit 스트림은 이제 macOS 경험에 통합되어 모든 애플리케이션이 발표자 오버레이와 같은 새로운 기능을 활용할 수 있습니다.

00:09:28.000 --> 00:09:36.000
그리고 애플리케이션을 새로운 시스템 선택기 UI에 통합하기 위한 새로운 API인 SCContentSharingPicker를 소개했습니다.

00:09:36.000 --> 00:09:44.000
하지만 애플리케이션의 화면 캡처는 단지 라이브 스트림에 관한 것이 아니므로, 이 새로운 스크린샷 API에 대해 더 이야기하기 위해 제 동료인 나탈리에게 전달하고 싶습니다.

00:09:44.000 --> 00:09:45.000
나탈리: 고마워, 크리스토퍼.

00:09:45.000 --> 00:09:52.000
올해 ScreenCaptureKit에는 화면에서 바로 스틸 이미지를 쉽게 잡을 수 있도록 설계된 새로운 API가 있습니다.

00:09:52.000 --> 00:09:57.000
새로운 스크린샷 API는 스크린샷에 ScreenCaptureKit 스트리밍의 이점을 제공합니다.

00:09:57.000 --> 00:10:07.000
앱이나 창별 고급 필터링, 여러 픽셀 형식 및 색상 공간, 커서 가시성과 같은 기타 옵션과 같은 기능을 사용할 수 있습니다.

00:10:07.000 --> 00:10:16.000
이제 친숙한 ScreenCaptureKit 구조를 사용하여 원하는 정확한 화면 콘텐츠의 이미지를 효율적으로 캡처할 수 있습니다.

00:10:16.000 --> 00:10:19.000
새로운 API는 비동기식이다.

00:10:19.000 --> 00:10:25.000
출력 이미지의 경우, CMSampleBuffer 또는 CGImage 형식 중에서 선택할 수 있습니다.

00:10:25.000 --> 00:10:32.000
CMSampleBuffer 옵션에는 추가 픽셀 형식을 사용할 수 있으며, 특정 형식에 관심이 있다면 좋습니다.

00:10:32.000 --> 00:10:38.000
이미 코드에서 CGImage를 사용하고 있다면, 이 형식을 사용하면 통합하기가 더 쉬울 것입니다.

00:10:38.000 --> 00:10:49.000
어느 형식이든, 스크린샷은 ScreenCaptureKit 스트리밍과 거의 모든 구성 옵션을 사용하며 유사한 설정 흐름을 따릅니다.

00:10:49.000 --> 00:10:57.000
CGWindowListCreateImage를 사용하는 경우, ScreenCaptureKit으로의 전환을 더 쉽게 할 수 있는 몇 가지가 있습니다.

00:10:57.000 --> 00:11:06.000
CGWindowList API에 사용할 수 있는 모든 창 이미지 옵션은 ScreenCaptureKit의 SCStreamConfiguration 클래스에서 찾을 수 있습니다.

00:11:06.000 --> 00:11:15.000
특정 창 ID 위의 모든 창을 얻는 것과 같은 창 목록 옵션은 SCShareableContent 내에서 제공됩니다.

00:11:15.000 --> 00:11:25.000
그리고 CGImage 출력 작업에 익숙하다면, 새로운 스크린샷 API는 기존 코드에 쉽게 통합할 수 있는 CGImage 출력 형식을 제공합니다.

00:11:25.000 --> 00:11:35.000
스크린샷을 찍는 것은 ScreenCaptureKit 스트리밍과 비슷한 흐름을 따르지만, SCStream을 만드는 대신 스크린샷 API를 호출할 수 있습니다.

00:11:35.000 --> 00:11:44.000
시작하려면, 스트림을 만드는 것과 마찬가지로, SCShareableContent를 사용하여 원하는 콘텐츠를 얻고 SCContentFilter를 만드세요.

00:11:44.000 --> 00:11:50.000
스크린샷에 원하는 모든 옵션으로 SCStreamConfiguration을 설정하는 것을 잊지 마세요.

00:11:50.000 --> 00:11:57.000
콘텐츠 필터와 스트림 구성이 있으면, 스크린샷 API를 호출하여 전달하세요.

00:11:57.000 --> 00:12:07.000
API는 SCScreenshotManager 클래스의 클래스 메소드이므로 스크린샷을 찍기 위해 SCScreenshotManager 객체를 만들 필요가 없습니다.

00:12:07.000 --> 00:12:14.000
스크린샷 이미지가 준비되면, 선택한 형식으로 비동기적으로 반환됩니다.

00:12:14.000 --> 00:12:20.000
또한 새로운 시스템 선택기를 사용하여 콘텐츠 필터를 만든 다음, 이를 사용하여 스크린샷 API를 호출할 수 있습니다.

00:12:20.000 --> 00:12:27.000
이것은 사람들이 직관적인 방식으로 원하는 콘텐츠를 선택할 수 있는 좋은 방법이 될 것이다.

00:12:27.000 --> 00:12:37.000
스크린샷을 찍을 때, 필요한 것에 따라 선택할 수 있는 두 가지 버전의 API가 있습니다: 하나는 CMSampleBuffer 출력 유형이고 다른 하나는 CGImage 출력 유형입니다.

00:12:37.000 --> 00:12:44.000
그 외에, 두 버전은 같은 방식으로 작동하며 스크린샷을 비동기적으로 반환할 것입니다.

00:12:44.000 --> 00:12:48.000
다음은 스크린샷 API를 사용하는 방법에 대한 코드 예시입니다.

00:12:48.000 --> 00:12:53.000
SCContentFilter와 SCStreamConfiguration을 설정하는 것으로 시작하세요.

00:12:53.000 --> 00:12:59.000
그것들을 준비하면, 스크린샷 API를 호출하고, 돌아올 때까지 기다리면, 스크린샷을 받을 수 있습니다.

00:12:59.000 --> 00:13:02.000
그리고 그것이 ScreenCaptureKit의 새로운 모든 것입니다.

00:13:02.000 --> 00:13:13.000
요약하자면, 시스템 레벨 UI를 사용하여 애플리케이션과 완전히 통합된 화면 공유 경험을 만드는 SCContentFilters를 만드는 새로운 API가 있습니다.

00:13:13.000 --> 00:13:24.000
새로운 발표자 오버레이 비디오 효과는 보다 역동적인 화면 공유 경험을 제공하며, 새로운 스크린샷 API를 사용하면 ScreenCaptureKit의 힘으로 일회성 화면 캡처를 할 수 있습니다.

00:13:24.000 --> 00:13:33.000
ScreenCaptureKit에 대한 자세한 내용은 작년의 세션인 "ScreenCaptureKit을 만나세요"와 "ScreenCaptureKit을 다음 단계로 끌어올리세요"를 확인하세요.

00:13:33.000 --> 23:59:59.000
봐줘서 고마워.

