WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:11.000
안녕하세요, 환영합니다.

00:00:11.000 --> 00:00:18.000
저는 Apple의 GPU, 그래픽 및 디스플레이 소프트웨어 그룹의 엔지니어인 Varun Subramanian입니다.

00:00:18.000 --> 00:00:24.000
이 세션은 고급 게임을 Mac으로 가져오는 3부작 시리즈의 두 번째 부분입니다.

00:00:24.000 --> 00:00:29.000
첫 번째 세션은 게임을 평가하고 "게임 계획을 세우는" 방법을 다룹니다.

00:00:29.000 --> 00:00:48.000
이 세션은 셰이더와 셰이더를 메탈 중간 표현으로 변환하는 새로운 방법과 게임 빌드 시간 동안 GPU 바이너리를 마무리하여 온디바이더 컴파일을 피하는 방법을 포함하여 새로운 메탈 컴파일러 도구로 유연성과 속도를 향상시키는 방법에 중점을 둡니다.

00:00:48.000 --> 00:00:56.000
메탈 컴파일러 툴체인은 게임을 구동하는 셰이더를 컴파일하는 데 도움이 되며 메탈은 이제 그 어느 때보다 쉽게 만듭니다.

00:00:56.000 --> 00:01:04.000
장치에서 Metal IR을 만드는 것은 GPU가 필요한 작업을 수행하기 전에 컴파일 오버헤드를 추가하기 때문에 최적이 아니다.

00:01:04.000 --> 00:01:11.000
Metal은 Metal Shading Language에서 Metal IR을 미리 생성하는 데 필요한 도구를 제공합니다.

00:01:11.000 --> 00:01:15.000
그 금속 IR은 금속 라이브러리의 일부로 저장된다.

00:01:15.000 --> 00:01:22.000
당신은 항상 메탈 컴파일러 툴체인을 사용하여 메탈 라이브러리를 미리 생성하는 것을 목표로 해야 합니다.

00:01:22.000 --> 00:01:27.000
그러나, 다른 API와 셰이딩 언어에서 올 때, 당신은 그것들을 메탈로 가져올 방법이 필요합니다.

00:01:27.000 --> 00:01:32.000
Mac에 새로 온 사람이라면, 이제 메탈 셰이더 컨버터가 있습니다.

00:01:32.000 --> 00:01:43.000
이를 통해 셰이더 파이프라인을 단순화하고 생성된 Metal 라이브러리를 번들에 직접 패키징할 수 있으므로 장치 내 Metal IR 생성을 피할 수 있습니다.

00:01:43.000 --> 00:01:52.000
생성된 메탈 라이브러리는 메탈 컴파일러에서 생성된 라이브러리와 동일하여 변환된 셰이더가 기본적으로 메탈 API와 통합될 수 있도록 합니다.

00:01:52.000 --> 00:01:58.000
새로운 도구를 사용하여 기존 셰이더를 게임과 함께 배송하는 메탈 라이브러리로 변환하세요.

00:01:58.000 --> 00:02:05.000
금속 셰이더 컨버터는 셰이더를 금속으로 변환하는 경험을 개선하기 위한 강력한 기능 세트를 제공합니다.

00:02:05.000 --> 00:02:09.000
그것은 금속 IR을 생산하기 위해 DXIL을 소비한다.

00:02:09.000 --> 00:02:14.000
오픈 소스 DXC 컴파일러 도구와 함께 사용하여 엔드투엔드 셰이더 파이프라인을 구축합니다.

00:02:14.000 --> 00:02:22.000
금속 셰이더 컨버터가 이진 수준에서 변환을 수행하기 때문에 DXIL에서 금속 IR로 변환하는 것은 매우 빠릅니다.

00:02:22.000 --> 00:02:26.000
결과적으로 셰이더 자산 구축 시간을 줄일 수 있습니다.

00:02:26.000 --> 00:02:31.000
또한 Apple GPU의 고급 기능을 활용할 수 있습니다.

00:02:31.000 --> 00:02:41.000
기존 DXIL 셰이더의 모든 전통적이고 현대적인 셰이더 단계를 지원하는 금속 셰이더 컨버터의 풍부한 기능 세트 때문에 이것을 할 수 있습니다.

00:02:41.000 --> 00:02:51.000
금속 셰이더 변환기를 사용하면 테셀레이션 및 지오메트리 셰이더를 포함한 전통적인 그래픽 파이프라인의 셰이더를 금속 라이브러리로 변환할 수 있습니다.

00:02:51.000 --> 00:03:00.000
또한 컴퓨팅 셰이더뿐만 아니라 최근에 도입된 레이 트레이싱 단계와 셰이더, 증폭 및 메쉬 셰이더를 지원합니다.

00:03:00.000 --> 00:03:06.000
이제, 메탈 셰이더 컨버터를 사용하는 방법을 안내해 드리겠습니다.

00:03:06.000 --> 00:03:10.000
명령줄을 통해 셰이더를 변환할 수 있는 두 가지 시나리오가 있습니다.

00:03:10.000 --> 00:03:16.000
터미널을 통해 명령줄 도구를 사용하는 것은 한 번에 하나의 셰이더를 변환하는 좋은 메커니즘이다.

00:03:16.000 --> 00:03:25.000
셰이더가 여러 개 있는 경우, 메탈 셰이더 변환기를 호출하여 여러 셰이더를 자동으로 변환하는 셸 스크립트를 만들 수 있습니다.

00:03:25.000 --> 00:03:29.000
명령줄 도구를 사용하여 셰이더를 변환하는 것은 매우 쉽습니다.

00:03:29.000 --> 00:03:36.000
DXC와 셰이더 컨버터를 설정한 후, HLSL 셰이더를 DXIL로 컴파일하는 것으로 시작하세요.

00:03:36.000 --> 00:03:42.000
DXC는 컴파일할 진입점, 셰이더 유형 및 출력 파일을 지정해야 합니다.

00:03:42.000 --> 00:03:49.000
다음으로, 방금 만든 DXIL 파일에서 셰이더 변환기를 호출하고 만들 출력 금속 라이브러리를 지정하십시오.

00:03:49.000 --> 00:03:58.000
기본적으로 셰이더 변환기는 최신 버전의 macOS용 Metal 라이브러리와 유용한 반사 데이터가 있는 JSON 파일을 생성합니다.

00:03:58.000 --> 00:04:05.000
런타임에, 이 메탈 라이브러리를 메탈 장치에 전달하여 로드하고 파이프라인 상태 객체를 구축합니다.

00:04:05.000 --> 00:04:11.000
명령줄 인터페이스가 작업 흐름에 가장 적합한 선택이 아닐 수 있는 두 가지 다른 시나리오가 있습니다.

00:04:11.000 --> 00:04:18.000
일부 게임 엔진에는 셰이더를 게임별 형식으로 컴파일하고 패키징하는 사용자 지정 자산 빌드 프로그램이 있습니다.

00:04:18.000 --> 00:04:30.000
또한, 어떤 상황에서는, 메탈용 게임을 부트스트랩할 때, 셰이더가 플랫폼에서 얼마나 잘 작동하는지 미리 메탈 라이브러리로 완전히 전환하기 전에 보고 싶을 수도 있습니다.

00:04:30.000 --> 00:04:36.000
이 마지막 두 경우, 금속 셰이더 변환기를 워크플로우에 더 잘 통합할 수 있는 방법이 필요합니다.

00:04:36.000 --> 00:04:41.000
이를 달성하려면, 메탈 셰이더 컨버터 동적 라이브러리를 사용하세요.

00:04:41.000 --> 00:04:47.000
메탈 라이브러리를 생성하는 데 도움이 되는 CLI 도구와 동일한 기능을 모두 노출합니다.

00:04:47.000 --> 00:04:57.000
라이브러리는 순수한 C 인터페이스를 제공하며 CLI와 마찬가지로 macOS와 Windows 모두에서 사용할 수 있으므로 기존 워크플로우에 쉽게 통합할 수 있습니다.

00:04:57.000 --> 00:05:06.000
셰이더를 Metal IR로 변환한 후, 게임에 통합하기 위해 파이프라인 상태를 만들고 자원을 바인딩합니다.

00:05:06.000 --> 00:05:13.000
셰이더에서는 일반적으로 리소스를 글로벌 변수로 정의하고 "등록" 선언을 할당합니다.

00:05:13.000 --> 00:05:22.000
API 측면에서, 당신의 게임은 리소스를 이러한 슬롯에 직접 바인딩하거나, "루트 서명"을 통해 명시적인 메모리 레이아웃을 정의합니다.

00:05:22.000 --> 00:05:28.000
셰이더 컨버터는 금속이 매우 유연한 바인딩 모델을 가지고 있기 때문에 이 모델을 가져오는 데 도움이 될 수 있습니다.

00:05:28.000 --> 00:05:32.000
이 도구는 이러한 자원을 인수 버퍼로 배치한다.

00:05:32.000 --> 00:05:39.000
이 모델에서는 하나의 인수 버퍼를 파이프라인에 직접 바인딩하고 이를 통해 리소스를 참조합니다.

00:05:39.000 --> 00:05:46.000
게임에 가장 잘 맞게 선택할 수 있는 이 "최상위" 인수 버퍼를 위한 두 가지 레이아웃 모드가 있습니다.

00:05:46.000 --> 00:05:53.000
당신이 만들 수 있는 가장 간단한 레이아웃은 셰이더 변환기가 리소스를 차례로 배치하는 자동 레이아웃입니다.

00:05:53.000 --> 00:06:02.000
셰이더를 포함하는 파이프라인 상태를 만들면, 단일 인수 버퍼를 바인딩하고 이를 통해 모든 리소스를 참조합니다.

00:06:02.000 --> 00:06:08.000
또는 셰이더 변환기는 루트 서명과 일치하는 레이아웃을 명시적으로 정의하는 것을 지원합니다.

00:06:08.000 --> 00:06:18.000
게임이 자체 리소스 테이블에 별도의 텍스처와 샘플러를 지정해야 하거나 게임이 바인딩리스 리소스를 사용하는 경우 이 모드를 사용하세요.

00:06:18.000 --> 00:06:27.000
또한 원시 버퍼와 32비트 상수를 이 다이어그램에서 0과 1로 표시된 최상위 인수 버퍼에 직접 삽입할 수 있습니다.

00:06:27.000 --> 00:06:40.000
이제 최상위 인수 버퍼는 CPU와 GPU 간에 공유되는 리소스이므로, 쓸 때 시각적 손상을 일으킬 수 있는 경쟁 조건을 피하기 위해 메모리에 대한 액세스를 조정해야 합니다.

00:06:40.000 --> 00:06:44.000
이 경쟁 조건을 피하기 위해 CPU와 GPU 작업을 직렬화할 필요가 없습니다.

00:06:44.000 --> 00:06:48.000
이것을 피하는 한 가지 방법은 범프 할당자를 사용하는 것이다.

00:06:48.000 --> 00:06:53.000
이것은 각 프레임마다 다른 자원을 하위 할당하는 큰 금속 버퍼가 될 수 있습니다.

00:06:53.000 --> 00:06:58.000
그런 다음 게임이 처리하는 비행 중 각 프레임의 백킹 버퍼를 섀도잉합니다.

00:06:58.000 --> 00:07:03.000
범프 할당자 구현에 대한 자세한 내용은 샘플 코드를 확인하세요.

00:07:03.000 --> 00:07:09.000
최고의 인수 버퍼 관리 관행을 위해, 작년의 바인딩리스 세션과 금속 문서를 확인하세요.

00:07:09.000 --> 00:07:16.000
바인딩 모델은 금속 셰이더 컨버터가 쉐이더를 Mac으로 가져오는 데 도움을 줄 수 있는 유일한 장소가 아닙니다.

00:07:16.000 --> 00:07:21.000
특정 셰이더 단계를 매핑하는 것은 그래픽 API의 차이로 인해 어려울 수 있습니다.

00:07:21.000 --> 00:07:27.000
예를 들어, 전통적인 기하학과 테셀레이션 단계를 활용하는 파이프라인이 있을 수 있습니다.

00:07:27.000 --> 00:07:39.000
메탈은 현대적인 API이며, 다른 그래픽 API의 오래되고 덜 효율적인 단계를 불필요하게 만드는 뷰포트 ID 및 증폭과 같은 기능을 제공합니다.

00:07:39.000 --> 00:07:49.000
그러나, 당신의 게임이 이 이미지에 렌더링된 잔디와 같은 일부 표면을 향상시키는 전통적인 효과를 위해 이러한 파이프라인에 의존할 때, 손으로 변환하는 것은 비용이 많이 듭니다.

00:07:49.000 --> 00:07:58.000
금속 셰이더 컨버터는 현대적이고 효율적인 그래픽 API 구성인 메쉬 셰이더에 매핑하여 이러한 파이프라인을 금속으로 가져올 수 있도록 도와줍니다.

00:07:58.000 --> 00:08:07.000
이 도구는 각 단계를 금속 IR 표현에 매핑하여 이러한 복잡한 파이프라인을 금속으로 쉽게 가져오기 위해 무거운 작업을 수행합니다.

00:08:07.000 --> 00:08:12.000
여기에는 전통적으로 고정된 기능 작동인 테셀레이터가 포함된다.

00:08:12.000 --> 00:08:21.000
이 워크플로우를 지원하기 위해, 올해 메탈은 눈에 보이는 기능을 메쉬 셰이더의 "객체 및 메쉬" 단계에 연결하는 기능을 추가합니다.

00:08:21.000 --> 00:08:31.000
셰이더를 컴파일한 후, 이를 사용하여 "메탈 메쉬 렌더링 파이프라인 설명자"를 만들고 "메탈 렌더링 파이프라인 상태"로 컴파일합니다.

00:08:31.000 --> 00:08:44.000
Metal이 이 파이프라인 상태를 구축하라는 요청을 받으면, 모든 Metal IR을 컴파일하고 연결하여 모든 기능을 단일 파이프라인으로 굽고, 기능 호출 오버헤드를 완전히 피하고 런타임 동안 성능을 극대화합니다.

00:08:44.000 --> 00:08:54.000
추가 기능과 함께 이러한 셰이딩 단계를 포함하는 정교한 렌더링 파이프라인을 구축할 수 있는 금속 가시 기능의 힘과 유연성에 주목하십시오.

00:08:54.000 --> 00:09:01.000
이러한 메쉬 파이프라인을 구축하는 것은 간단하지만, 모든 파이프라인은 정확한 순서로 일련의 단계를 따라야 한다.

00:09:01.000 --> 00:09:05.000
셰이더 컨버터 런타임은 이러한 복잡한 파이프라인을 구축하는 데 도움이 됩니다.

00:09:05.000 --> 00:09:09.000
그것은 심지어 메쉬 셰이딩 작업을 파견하여 드로우 호출을 에뮬레이트한다.

00:09:09.000 --> 00:09:14.000
자세한 내용은 Metal Shader Converter 문서를 참조하십시오.

00:09:14.000 --> 00:09:23.000
이제 셰이더가 메탈에 있고 파이프라인 상태를 실행하고 있으니, 훌륭한 성능과 시각적 정확성을 얻는 데 도움이 되는 몇 가지 팁이 있습니다.

00:09:23.000 --> 00:09:27.000
셰이더 컨버터 참조 금속 자원으로 간접적으로 컴파일된 셰이더.

00:09:27.000 --> 00:09:32.000
자원 거주지를 금속에 표시하려면, 당신은 "useResource"라고 부를 것입니다.

00:09:32.000 --> 00:09:37.000
그러나, useResource는 과도하게 사용될 때 비싼 통화이다.

00:09:37.000 --> 00:09:48.000
복수 useResources를 사용하여 한 번에 여러 리소스를 제공하거나, useHeap을 통해 Metal heaps를 사용하여 단일 통화에서 여러 리소스의 거주를 표시하는 것을 고려하십시오.

00:09:48.000 --> 00:09:57.000
파이프라인 객체는 Metal이 처음으로 컴파일할 때 캐시되어 게임의 후속 실행에서 컴파일 기반 히칭을 자동으로 줄입니다.

00:09:57.000 --> 00:10:00.000
바이너리 아카이브는 또한 여기에서 당신을 도울 수 있습니다.

00:10:00.000 --> 00:10:07.000
GPU에서 더 많은 것을 얻고 더 높은 성능을 위해 Metal IR을 사용자 정의하기 위해 셰이더 컨버터는 옵션을 제공합니다.

00:10:07.000 --> 00:10:17.000
호환성, GPU 제품군, 정점 가져오기 동작, 진입점 명명, 반사 등에 대한 사용자 지정이 있습니다.

00:10:17.000 --> 00:10:21.000
여기 한 가지 추가적인 최적화 기회가 있습니다.

00:10:21.000 --> 00:10:29.000
앞서 셰이더 컨버터가 기존 셰이더 IR에서 "금속 라이브러리"를 생산하는 또 다른 메커니즘으로 금속 컴파일러에 합류한다고 언급했습니다.

00:10:29.000 --> 00:10:34.000
금속은 다양한 그래픽 파이프라인 단계를 공급하기 위해 이것들을 사용한다.

00:10:34.000 --> 00:10:44.000
모든 것이 메탈 IR이기 때문에, 메탈 셰이더 컨버터와 메탈 컴파일러에서 나오는 "메탈 라이브러리"를 단일 앱과 단일 파이프라인에서 믹스 앤 매치할 수 있습니다.

00:10:44.000 --> 00:10:50.000
금속 셰이딩 언어를 사용하면 프로그래밍 가능한 블렌딩과 같은 고유한 기능에 액세스할 수 있습니다.

00:10:50.000 --> 00:10:54.000
이 접근 방식을 사용하여 Apple의 GPU를 최대한 활용하세요.

00:10:54.000 --> 00:10:59.000
타일 셰이딩과 같은 독특한 셰이딩 기능을 활용할 수도 있습니다.

00:10:59.000 --> 00:11:03.000
이것은 당신이 당신의 게임을 메탈로 가져오는 방법에 엄청난 유연성을 부여합니다.

00:11:03.000 --> 00:11:08.000
성능은 중요하지만 게임의 시각적 정확성이 가장 중요합니다.

00:11:08.000 --> 00:11:13.000
HLSL은 텍스처를 한 요소의 배열로 원활하게 처리할 수 있게 해준다.

00:11:13.000 --> 00:11:22.000
이 동작에 의존하는 셰이더를 가져오려면, 텍스처를 텍스처 배열로 만들거나, 텍스처에 "텍스처 배열 뷰"를 만드세요.

00:11:22.000 --> 00:11:28.000
"MetalKit Texture Loader"를 사용하는 경우, 파일을 텍스처 배열로 로드하는 데 도움이 될 수도 있습니다.

00:11:28.000 --> 00:11:42.000
샘플러 객체를 설정하고 이러한 텍스처에서 읽으려면, MTL 샘플러 설명자의 supportsArgumentBuffers 속성을 사용하여 인수 버퍼에서 샘플러를 참조할 계획임을 Metal에 미리 알려야 합니다.

00:11:42.000 --> 00:11:48.000
이제 워크플로우에서 셰이더 변환기를 통합하는 데 익숙해졌으므로, 이를 얻는 방법은 다음과 같습니다.

00:11:48.000 --> 00:11:52.000
Developer.apple.com에서 메탈 셰이더 변환기를 다운로드할 수 있습니다.

00:11:52.000 --> 00:11:57.000
Mac에서 작업하고 있다면, Mac 패키지용 메탈 셰이더 컨버터를 받으세요.

00:11:57.000 --> 00:12:02.000
Windows에서 작업하는 경우, Windows용 Metal Developer Tools 패키지의 일부입니다.

00:12:02.000 --> 00:12:04.000
이 도구의 베타 버전을 지금 사용할 수 있습니다.

00:12:04.000 --> 00:12:12.000
두 패키지 모두 독립형 및 라이브러리 형태의 메탈 셰이더 컨버터와 런타임 컴패니언 헤더가 포함되어 있습니다.

00:12:12.000 --> 00:12:17.000
이제 전체 문서와 Metal C++ 코드 샘플을 사용할 수 있습니다.

00:12:17.000 --> 00:12:25.000
샘플 코드를 사용하여 기하학과 테셀레이션 에뮬레이션, 인스턴스 드로잉 및 컴퓨팅 셰이더를 탐색하십시오.

00:12:25.000 --> 00:12:32.000
셰이더를 게임과 함께 배송하는 메탈 라이브러리로 변환하면 게임 런타임에 라이브러리를 생성하는 것을 피할 수 있습니다.

00:12:32.000 --> 00:12:40.000
GPU 바이너리를 미리 컴파일하는 것으로 수행할 수 있는 한 가지 추가 최적화가 있습니다.

00:12:40.000 --> 00:12:47.000
게임을 만들 때, 셰이더를 여전히 GPU 바이너리로 마무리해야 하는 메탈 라이브러리로 컴파일합니다.

00:12:47.000 --> 00:12:53.000
보통 당신의 게임은 출시 시 이것을 수행하여 로딩 화면이 더 길어집니다.

00:12:53.000 --> 00:13:01.000
런타임에 GPU 바이너리의 마무리를 연기하면, 게임이 필요에 따라 새로운 파이프라인을 컴파일함에 따라 프레임이 떨어질 수 있습니다.

00:13:01.000 --> 00:13:10.000
메탈 GPU 바이너리 컴파일러는 게임 빌드 시간에 셰이더 바이너리를 생성할 수 있도록 하여 이 문제를 해결하는 데 도움을 줄 수 있습니다.

00:13:10.000 --> 00:13:20.000
게임 플레이 중에 셰이더 바이너리를 생성할 필요성을 제거함으로써, 플레이어는 추가 GPU 문제 없이 앱 로드 시간을 줄일 수 있습니다.

00:13:20.000 --> 00:13:29.000
이를 활용하려면, 빌드 타임에 메탈 라이브러리를 메탈 바이너리 아카이브로 마무리하기 위해 워크플로우에 또 다른 단계를 추가할 수 있습니다.

00:13:29.000 --> 00:13:35.000
장치에서 GPU 바이너리 컴파일은 설명자에서 파이프라인 상태를 만들 때 발생합니다.

00:13:35.000 --> 00:13:47.000
이 설명자는 Metal 라이브러리의 기능을 참조할 뿐만 아니라 렌더링 첨부 파일의 색상 형식과 정점 레이아웃 설명자와 같은 다른 중요한 정보를 Metal에 제공합니다.

00:13:47.000 --> 00:13:54.000
GPU 바이너리는 PSO 생성의 일환으로 제시간에 생성된다.

00:13:54.000 --> 00:13:58.000
이진 아카이브를 사용하면 컴파일이 언제 발생하는지 제어할 수 있습니다.

00:13:58.000 --> 00:14:08.000
GPU 바이너리를 미리 생성하려면 기존 Metal Library와 해당 라이브러리를 참조하는 파이프라인 구성 스크립트를 모두 제공합니다.

00:14:08.000 --> 00:14:15.000
그런 다음 둘 다 metal-tt에 제공하여 GPU 바이너리로 바이너리 아카이브를 생성합니다.

00:14:15.000 --> 00:14:22.000
파이프라인 스크립트를 개발하기 위해, Metal API와 유사한 파이프라인 구성으로 JSON 스크립트를 생성합니다.

00:14:22.000 --> 00:14:29.000
이 금속 코드는 렌더링 파이프라인 설명자를 생성하며 JSON과 동등한 표현과 함께 있습니다.

00:14:29.000 --> 00:14:36.000
파이프라인 스크립트의 경우, 메탈 라이브러리 경로와 조각 및 정점 함수 이름을 추가하십시오.

00:14:36.000 --> 00:14:39.000
다른 파이프라인 상태 구성도 지정합니다.

00:14:39.000 --> 00:14:43.000
그게 다야, 이제 네가 사용할 수 있는 메탈 스크립트가 있어.

00:14:43.000 --> 00:14:48.000
Metal의 개발자 문서에서 JSON 스키마에 대한 추가 정보를 찾을 수 있습니다.

00:14:48.000 --> 00:14:53.000
사전 셰이더 컴파일 워크플로우는 파이프라인 스크립트 파일을 생성하도록 조정되지 않을 수 있습니다.

00:14:53.000 --> 00:14:58.000
이러한 경우, 그것들을 생산하는 다른 방법이 있다.

00:14:58.000 --> 00:15:02.000
장치에서 게임을 실행하는 동안 메탈 바이너리 아카이브를 기록할 수 있습니다.

00:15:02.000 --> 00:15:06.000
이 아카이브에는 해당 파이프라인 스크립트가 포함되어 있습니다.

00:15:06.000 --> 00:15:13.000
장치에서 이러한 아카이브를 수집하면, "금속 소스"를 사용하여 임베디드 파이프라인 스크립트를 추출할 수 있습니다.

00:15:13.000 --> 00:15:17.000
그런 다음 추출된 스크립트에서 메탈 라이브러리의 경로를 업데이트합니다.

00:15:17.000 --> 00:15:26.000
자세한 내용은 "GPU 바이너리 빌드"와 "컴파일 워크플로우 발견" 방법에 대한 회담을 참조하십시오.

00:15:26.000 --> 00:15:36.000
GPU 바이너리는 각 GPU에 맞춰져 있기 때문에, "metal-tt"는 장치에 따라 플레이어에게 배포할 수 있는 다양한 버전의 바이너리를 생성합니다.

00:15:36.000 --> 00:15:44.000
Metal-tt는 모든 다른 GPU 바이너리를 Metal 바이너리 아카이브에 깔끔하게 캡슐화하여 이러한 복잡성을 관리할 수 있도록 도와줍니다.

00:15:44.000 --> 00:15:52.000
이렇게 하면, 앱이 바이너리 아카이브를 로드할 때, 메탈은 자동으로 플레이어에게 적합한 바이너리를 선택합니다.

00:15:52.000 --> 00:15:58.000
또한 여러 바이너리 세트를 단일 바이너리 아카이브로 캡슐화할 수 있습니다.

00:15:58.000 --> 00:16:04.000
이제 바이너리 아카이브를 미리 생성할 수 있으니, 여기에 몇 가지 모범 사례가 있습니다.

00:16:04.000 --> 00:16:12.000
플레이어가 미리 컴파일된 GPU 바이너리로 메탈 앱을 실행할 때, 메탈은 필요한 GPU 바이너리를 위해 패키지된 바이너리 아카이브를 검색합니다.

00:16:12.000 --> 00:16:18.000
메탈이 아카이브에서 일치하는 것을 찾지 못하면, 자동으로 장치 내 편집으로 돌아갑니다.

00:16:18.000 --> 00:16:22.000
당신의 앱은 여전히 정확해 보이지만, 이것은 GPU에 대한 제출을 지연시킬 수 있습니다.

00:16:22.000 --> 00:16:30.000
"FailOnBinaryArchiveMiss" 옵션을 사용하여 바이너리 아카이브에 예상되는 파이프라인이 포함되어 있는지 테스트할 수 있습니다.

00:16:30.000 --> 00:16:36.000
금속 파이프라인 상태 객체를 만들 때 FailOnBinaryArchiveMiss 옵션을 쉽게 지정할 수 있습니다.

00:16:36.000 --> 00:16:45.000
바이너리 아카이브가 누락된 경우, 이 옵션을 설정하면, 메탈은 온디바이더 컴파일을 건너뛰고 0 파이프라인 상태를 반환합니다.

00:16:45.000 --> 00:16:51.000
바이너리 아카이브가 모든 대상 장치를 지원할 준비가 되면, 배포할 준비가 된 것입니다.

00:16:51.000 --> 00:16:54.000
모든 플레이어가 최신 OS에 있는 것은 아닙니다.

00:16:54.000 --> 00:17:03.000
모든 사용자가 바이너리 아카이브의 혜택을 누릴 수 있도록, 각 주요 OS 버전에 대한 아카이브를 생성하고 앱에 저장하십시오.

00:17:03.000 --> 00:17:13.000
이를 달성하려면, 플레이어 장치의 OS 버전을 확인하고 파이프라인 설명자와 연결할 적절한 바이너리 아카이브를 선택하십시오.

00:17:13.000 --> 00:17:22.000
플레이어가 OS를 업데이트할 때, 바이너리 아카이브는 순방향 호환성을 위해 재컴파일이 필요할 수 있지만, 메탈은 당신을 보호합니다.

00:17:22.000 --> 00:17:33.000
메탈은 플레이어 장치의 앱 번들에서 패키지되지 않은 바이너리 아카이브를 식별하고 OS 업데이트 또는 게임 설치 후 백그라운드에서 자동으로 업그레이드합니다.

00:17:33.000 --> 00:17:42.000
요약하자면, "금속" 컴파일러와 "금속 셰이더 컨버터"는 게임과 함께 배송할 수 있는 금속 라이브러리를 미리 제작하기 위한 도구입니다.

00:17:42.000 --> 00:17:50.000
MSL 소스를 컴파일할 때 "금속 컴파일러"를 사용하고, 셰이더가 HLSL에 있을 때 "금속 셰이더 컨버터"를 사용하세요.

00:17:50.000 --> 00:17:58.000
Metal-tt를 사용하면 Metal 생태계의 다양한 GPU에 맞게 Metal 라이브러리를 GPU 바이너리로 마무리할 수 있습니다.

00:17:58.000 --> 00:18:05.000
마지막으로, 메탈 소스는 기존 MacOS 게임에서 파이프라인 스크립트를 수집하는 데 도움을 줍니다.

00:18:05.000 --> 00:18:18.000
이러한 도구의 대다수와 나머지 GPU 바이너리 컴파일러 툴체인은 이제 macOS 외에도 Windows를 지원하므로 기존 워크플로우에 그 어느 때보다 쉽게 통합할 수 있습니다.

00:18:18.000 --> 00:18:26.000
마무리: 메탈 셰이더 컨버터는 다른 셰이딩 언어로 개발된 셰이더를 메탈로 가져오는 데 도움이 되는 새로운 도구입니다.

00:18:26.000 --> 00:18:35.000
현재 Windows에서 사용할 수 있는 GPU 바이너리 컴파일러와 툴체인은 Metal 라이브러리를 GPU 바이너리로 마무리할 수 있습니다.

00:18:35.000 --> 00:18:40.000
이 도구들로, 당신은 이제 셰이더를 메탈로 가져오는 데 필요한 모든 것을 갖추고 있습니다.

00:18:40.000 --> 00:18:42.000
아직 당신과 공유할 것이 더 있습니다.

00:18:42.000 --> 00:18:47.000
시리즈의 3부는 고급 금속 응용 프로그램을 최적화하는 데 초점을 맞추고 있다.

00:18:47.000 --> 00:18:48.000
꼭 확인해 봐.

00:18:48.000 --> 00:18:50.000
봐줘서 고마워.

00:18:50.000 --> 23:59:59.000
♪ ♪

