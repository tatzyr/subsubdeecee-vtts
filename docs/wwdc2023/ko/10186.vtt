WEBVTT

00:00:00.000 --> 00:00:11.000
♪ ♪

00:00:11.000 --> 00:00:19.000
데이비드: 안녕하세요, "핵심 데이터의 새로운 기능"에 오신 것을 환영합니다. 제 이름은 David Stites이고, 저는 Core Data 팀의 엔지니어입니다.

00:00:19.000 --> 00:00:33.000
이 세션에서는 앱에서 Core Data 데이터 모델을 더 빠르고 쉽게 설계, 쿼리, 업데이트 및 마이그레이션하는 데 도움이 되는 Core Data의 새로운 기술에 대해 배우게 됩니다.

00:00:33.000 --> 00:00:56.000
가벼운 마이그레이션을 사용할 수 있도록 가장 복잡한 모델 마이그레이션을 "스테이지"하는 방법에 대해 이야기하기 전에 앱의 모델에서 구조화된 데이터를 구성하는 훌륭한 새로운 방법인 복합 속성에 대해 이야기하는 것으로 시작하겠습니다. 그리고 앱의 반응성을 유지하기 위해 모델 마이그레이션을 연기하는 방법을 마무리하겠습니다.

00:00:56.000 --> 00:01:01.000
복합 속성은 새로운 유형의 속성이다.

00:01:01.000 --> 00:01:10.000
복합 속성은 단일 속성 내에서 복잡한 사용자 지정 데이터 유형을 캡슐화할 수 있게 해준다.

00:01:10.000 --> 00:01:23.000
각 복합 속성은 String, Float, Int 및 Data와 같이 이미 익숙한 내장 핵심 데이터 유형의 속성으로 구성됩니다.

00:01:23.000 --> 00:01:34.000
복합 속성은 최상위 복합 속성이 추가 복합 속성을 포함할 수 있도록 서로 중첩될 수 있다.

00:01:34.000 --> 00:01:46.000
Xcode Core Data 모델 편집기가 업데이트되어 모델의 복합 속성을 쉽게 정의하고 관리할 수 있습니다.

00:01:46.000 --> 00:01:55.000
복합 속성은 변형 가능한 유형 속성을 사용하여 내구성 있는 사용자 지정 데이터 유형을 만드는 것에 대한 강력한 대안이다.

00:01:55.000 --> 00:02:00.000
속성의 값을 변환하는 코드를 작성할 필요가 없습니다.

00:02:00.000 --> 00:02:13.000
변환 가능한 속성과 달리, 복합 속성은 복합 속성의 네임스페이스 키 경로로 구성된 NSPredicates로 NSFetchRequests를 허용합니다.

00:02:13.000 --> 00:02:25.000
복합 속성은 평평한 속성의 확산을 캡슐화하는 데 사용될 수 있으며, 이는 더 유지 관리 가능하고 읽기 쉬운 코드로 이어진다.

00:02:25.000 --> 00:02:29.000
복합 속성은 앱의 성능을 향상시키는 데 사용할 수 있습니다.

00:02:29.000 --> 00:02:43.000
데이터 모델이 한 엔티티를 가져오면 거의 항상 다른 엔티티와의 관계에 액세스하는 방식으로 구성된 경우, 해당 관계를 복합 속성을 사용하도록 리팩토링할 수 있습니다.

00:02:43.000 --> 00:02:53.000
첫 번째 엔티티에 복합 속성을 삽입하는 효과는 관계 전반에 걸쳐 객체의 결함을 방지한다는 것이다.

00:02:53.000 --> 00:02:59.000
복합 속성 클래스는 NSCompositeAttributeDescription입니다.

00:02:59.000 --> 00:03:07.000
NSCompositeAttributeDescription의 속성 유형은 NSCompositeAttributeType입니다.

00:03:07.000 --> 00:03:20.000
NSCompositeAttributeDescription 클래스에는 NSAttributeDescription 또는 기타 중첩된 NSCompositeAttributeDescription으로 구성된 배열, 요소가 포함되어 있습니다.

00:03:20.000 --> 00:03:28.000
요소 배열은 NSRelationshipDescription과 같은 다른 유형의 속성 설명을 포함할 수 없습니다.

00:03:28.000 --> 00:03:36.000
유효하지 않은 요소를 설정하려고 하면 NSInvalidArgumentException이 발생합니다.

00:03:36.000 --> 00:03:43.000
데모로 복합 속성을 채택하는 방법을 설명해 드리겠습니다.

00:03:43.000 --> 00:03:46.000
항공기 엔티티와 함께 이 기본 데이터 모델을 고려하세요.

00:03:46.000 --> 00:03:53.000
그것은 변형 가능한 유형인 색상 속성을 포함한 많은 속성을 가지고 있다.

00:03:53.000 --> 00:04:04.000
그 유형의 변압기는 항공기의 1차, 2차 및 3차 색상을 설명하는 형식의 문자열을 저장하고 구문 분석합니다.

00:04:04.000 --> 00:04:14.000
항공기의 페인트 색상을 저장하기 위해 색상 속성을 복합 속성 colorScheme로 대체하여 이 엔티티를 개선할 것입니다.

00:04:14.000 --> 00:04:25.000
colorScheme은 1차, 2차, 3차 요소가 있는 복합 속성이며, 각각은 문자열 속성이다.

00:04:25.000 --> 00:04:33.000
Xcode에서 비행 시간을 추적하는 데 사용하는 앱인 프로젝트를 열 것이다.

00:04:33.000 --> 00:04:42.000
그 앱의 데이터 모델은 내가 방금 이야기한 항공기 엔티티와 몇 개의 다른 엔티티로 구성되어 있다.

00:04:42.000 --> 00:04:51.000
변환을 시작하기 위해, 코어 데이터 모델 편집기에서 colorScheme이라는 새로운 복합 속성을 추가하고 있습니다.

00:04:51.000 --> 00:05:12.000
그 합성 내에서, 나는 1차, 2차, 3차의 세 가지 문자열 속성을 추가하고 있다.

00:05:12.000 --> 00:05:34.000
항공기 엔티티에서, 나는 복합 속성을 추가하고 그 속성의 유형을 colorScheme로 설정할 것이다.

00:05:34.000 --> 00:05:40.000
이제 모델의 작업이 완료되었고, 코드를 업데이트할 시간이다.

00:05:40.000 --> 00:05:52.000
내 항공기 구현에서, 나는 새로운 속성인 @NSManaged var colorScheme을 추가하고 있는데, 그 유형은 문자열 키와 모든 객체가 있는 사전이다.

00:05:52.000 --> 00:06:02.000
코드 전반에 걸쳐 이 복합 속성을 사용하기 때문에, 속성의 이름을 키로 하여 사전 표기법을 사용하여 값에 액세스하고 있습니다.

00:06:02.000 --> 00:06:13.000
여기서, 저는 1차, 2차 및 3차 문자열 키를 사용하여 항공기의 colorScheme 속성을 설정하고 있습니다.

00:06:13.000 --> 00:06:24.000
마찬가지로, NSPredicate로 NSFetchRequest를 구성할 때, 복합 속성의 요소는 네임스페이스 키 경로를 통해 액세스됩니다.

00:06:24.000 --> 00:06:31.000
여기서, colorScheme.primary는 그 속성을 필터링하는 데 사용됩니다.

00:06:31.000 --> 00:06:37.000
애플리케이션이 발전함에 따라, 데이터 모델을 변경해야 할 수도 있다.

00:06:37.000 --> 00:06:46.000
데이터 모델을 업데이트하려면 이러한 변경 사항이 기본 스토리지 스키마에서 구체화되어야 합니다.

00:06:46.000 --> 00:06:55.000
numPassengers 속성이 모델에 추가되면, 해당 저장소를 업데이트해야 합니다.

00:06:55.000 --> 00:07:01.000
스키마 변경을 수행하는 과정을 마이그레이션이라고 한다.

00:07:01.000 --> 00:07:08.000
마이그레이션 후, 변경 사항은 기본 저장소에 완전히 반영됩니다.

00:07:08.000 --> 00:07:15.000
Core Data에는 앱의 데이터 저장소를 현재 데이터 모델로 최신 상태로 유지하는 데 도움이 되는 마이그레이션 도구 세트가 내장되어 있습니다.

00:07:15.000 --> 00:07:29.000
총체적으로, 이 도구들은 "경량 이동"이라고 불린다. 경량 마이그레이션에 대해 자세히 알아보려면, WWDC 2022에서 "앱의 스키마를 발전시키세요"를 시청하세요.

00:07:29.000 --> 00:07:36.000
때때로, 데이터 모델의 결합된 변화는 경량 마이그레이션의 기능을 초과한다.

00:07:36.000 --> 00:07:40.000
이 문제에 대한 해결책은 단계적인 이주이다.

00:07:40.000 --> 00:08:12.000
단계별 마이그레이션 API는 몇 가지 목표를 염두에 두고 설계되었습니다: 부적합한 경량 스키마 변경이 있는 복잡한 데이터 모델을 마이그레이션하고, 마이그레이션 및 마이그레이션 인프라와 관련된 수천 줄의 코드를 잠재적으로 제거하여 앱을 단순화하며, 마이그레이션 프로세스 중에 앱이 다양한 작업을 수행하기 위해 실행 제어를 얻을 수 있는 기회를 제공합니다.

00:08:12.000 --> 00:08:56.000
이 API를 사용하려면, 취해야 할 몇 가지 단계가 있습니다: 모델의 변경 사항이 경량 마이그레이션에 의해 지원되는 작업에 부합하지 않는 경우를 결정하고, 부적합 모델 변경을 경량 마이그레이션에 의해 지원되는 일련의 준수 모델 변경으로 분해하고, 새로운 단계 마이그레이션 API를 사용하여 NSManagedObjectModel의 핵심 데이터의 총 순서를 설명하고, Core Data가 직렬 순서로 처리되지 않은 각 모델을

00:08:56.000 --> 00:09:07.000
마이그레이션 중 특정 시점에서, 해당 마이그레이션과 관련된 필요한 작업을 수행하기 위해 실행 제어가 앱에 제공됩니다.

00:09:07.000 --> 00:09:14.000
모델이 부적합한 경량 변경이 있을 때를 결정하기 위해, 몇 가지 옵션이 있습니다.

00:09:14.000 --> 00:09:23.000
첫 번째 옵션은 스키마 변경 사항을 수동으로 검토하고 각 변경 사항이 경량 마이그레이션에 적합한지 확인하는 것입니다.

00:09:23.000 --> 00:09:39.000
두 번째 옵션은 새로운 모델과 경량 마이그레이션 옵션인 NSMigratePersistentStores AutomaticallyOption 및 NSInferMappingModelAutomaticallyOption을 true로 설정하여 영구 저장소를 여는 것입니다.

00:09:39.000 --> 00:09:48.000
변경 사항이 경량 자격이 아닌 경우, NSPersistentStore IncompatibleVersionHashError를 받게 됩니다.

00:09:48.000 --> 00:09:57.000
마지막 옵션은 NSMappingModel.inferredMappingModel (forSourceModel:destinationModel:)을 사용하는 것입니다.

00:09:57.000 --> 00:10:01.000
이 방법은 Core Data가 만들 수 있다면 추론된 모델을 반환합니다.

00:10:01.000 --> 00:10:05.000
그렇지 않으면, 그것은 0을 반환한다.

00:10:05.000 --> 00:10:14.000
항공기 모델을 다시 고려할 때, 데이터를 이진 형식으로 저장하는 새로운 속성인 flightData가 있습니다.

00:10:14.000 --> 00:10:26.000
기존 데이터와 생성된 항공기와의 관계를 유지하면서 이 모델을 비정상화하고 모든 비행 데이터를 자체 엔티티 유형으로 분리할 필요가 있다고 가정합니다.

00:10:26.000 --> 00:10:33.000
이것은 매우 복잡한 모델 변경이며 그 자체로 가벼운 마이그레이션을 할 수 없습니다.

00:10:33.000 --> 00:10:38.000
이러한 변화는 단계적 이주를 사용하기 위해 분해되어야 한다.

00:10:38.000 --> 00:10:54.000
경량이 아닌 변경을 분해할 때, 목표는 경량 마이그레이션을 받을 수 없는 마이그레이션 작업을 경량 마이그레이션을 받을 수 있는 최소 일련의 마이그레이션으로 변환하는 것입니다.

00:10:54.000 --> 00:11:06.000
도입된 각 모델은 부적합한 변경 사항을 구성하는 경량 마이그레이션 기능 내에 있는 하나 이상의 작업을 가질 것이다.

00:11:06.000 --> 00:11:18.000
그 결과는 각 모델이 가볍고 마이그레이션 가능하지만 부적합 마이그레이션과 동등한 일련의 마이그레이션이다.

00:11:18.000 --> 00:11:24.000
예시로 돌아가서, 나는 원래 모델 ModelV1에 라벨을 붙였다.

00:11:24.000 --> 00:11:34.000
이 모델 마이그레이션은 두 개의 새로운 모델 버전인 ModelV2와 ModelV3를 도입함으로써 분해될 것이다.

00:11:34.000 --> 00:11:44.000
ModelV2에서, 항공기 엔티티는 새로 생성된 FlightData 엔티티의 모음인 flightParameters라는 관계를 얻는다.

00:11:44.000 --> 00:11:52.000
FlightData 엔티티는 이진 유형 속성 데이터와 항공기와의 관계를 가지고 있다.

00:11:52.000 --> 00:12:06.000
기존 데이터를 보존하기 위해, 마이그레이션 단계는 항공기 엔티티의 데이터를 새로운 FlightData 엔티티로 복사하여 항공기와 연관시킬 것이다.

00:12:06.000 --> 00:12:12.000
우리의 최종 모델은 ModelV2에서 만들어진 ModelV3입니다.

00:12:12.000 --> 00:12:24.000
ModelV3에서, 오래된 flightData 속성은 항공기 엔티티에서 삭제되고, 모델은 성공적으로 비정규화되고, 모든 기존 데이터는 보존된다.

00:12:24.000 --> 00:12:30.000
설명된 각 단계는 경량 마이그레이션 기능 내에 있습니다.

00:12:30.000 --> 00:12:53.000
모델의 전체 순서를 설명하기 위해, 핵심 데이터 프레임워크 수준 지원은 다음과 같은 클래스로 구성됩니다: NSStagedMigrationManager, NSCustomMigrationStage, NSLightweightMigrationStage 및 NSManagedObjectModelReference.

00:12:53.000 --> 00:13:09.000
NSStagedMigrationManager 클래스는 NSCustomMigrationStage와 당신이 설명한 보충 NSLightweightMigrationStage의 전체 순서를 캡슐화합니다.

00:13:09.000 --> 00:13:19.000
단계별 마이그레이션 관리자는 또한 마이그레이션 이벤트 루프를 관리하고 NSPersistentContainer를 통해 마이그레이션 저장소에 대한 액세스를 제공합니다.

00:13:19.000 --> 00:13:32.000
관리자는 NSPersistentStoreStagedMigrationManager OptionKey 키를 사용하여 매장 옵션에 추가됩니다.

00:13:32.000 --> 00:13:40.000
마이그레이션 단계는 모델 버전 간에 마이그레이션하기 위한 기초를 형성한다.

00:13:40.000 --> 00:13:53.000
단계별 마이그레이션을 채택할 때, NSCustomMigrationStage 또는 NSLightweightMigrationStage를 사용하여 각 모델 버전을 Core Data에 설명할 것입니다.

00:13:53.000 --> 00:14:04.000
NSLightweightMigrationStage 클래스는 분해가 필요하지 않고 경량 마이그레이션 자격이 있는 일련의 모델을 설명합니다.

00:14:04.000 --> 00:14:08.000
이것은 아마도 당신의 모델의 대부분일 것입니다.

00:14:08.000 --> 00:14:16.000
이러한 경량 마이그레이션 단계는 Core Data에 설명된 모델의 총 순서를 보완하는 데 사용됩니다.

00:14:16.000 --> 00:14:25.000
모든 경량 모델 버전은 하나 이상의 NSLightweightMigrationStage로 표시되어야 합니다.

00:14:25.000 --> 00:14:39.000
당신이 만든 모델의 각 분해된 버전은 NSCustomMigrationStage를 사용하여 표현되며 소스 모델 참조와 대상 모델 참조를 포함합니다.

00:14:39.000 --> 00:14:47.000
NSCustomMigrationStage는 마이그레이션 단계 직전과 직후에 실행되는 옵션 핸들러를 제공합니다.

00:14:47.000 --> 00:14:54.000
이 핸들러는 마이그레이션 과정에서 사용자 지정 코드를 실행할 수 있는 기능을 제공합니다.

00:14:54.000 --> 00:15:00.000
단계별 마이그레이션은 NSManagedObjectModelReference 클래스를 사용합니다.

00:15:00.000 --> 00:15:06.000
이 클래스는 NSManagedObjectModel의 약속을 나타낸다.

00:15:06.000 --> 00:15:10.000
마이그레이션하는 동안, 코어 데이터는 이 약속을 이행할 것이다.

00:15:10.000 --> 00:15:20.000
NSManagedObjectModelReference는 유연하며 다양한 방법으로 만들 수 있습니다.

00:15:20.000 --> 00:15:26.000
모든 NSManagedObjectModelReference는 버전 체크섬으로 초기화되어야 합니다.

00:15:26.000 --> 00:15:31.000
이것은 모델이 실수로 변경되지 않았는지 확인하기 위한 것이다.

00:15:31.000 --> 00:15:39.000
체크섬은 NSManagedObjectModel .versionChecksum 방법을 사용하여 얻을 수 있습니다.

00:15:39.000 --> 00:16:01.000
또는, "데이터 모델 컴파일" 아래의 Xcode 빌드 로그에서 버전 체크섬을 검색할 수 있습니다. "버전 체크섬" 문자열을 검색하세요. 버전 모델의 경우, 체크섬은 NSManagedObjectModel 번들의 VersionInfo.plist에서도 사용할 수 있습니다.

00:16:01.000 --> 00:16:10.000
예시로 돌아가서, 단계별 마이그레이션을 사용하기 위해, 세 가지 모델 각각에 대한 모델 참조를 만드는 것으로 시작하겠습니다.

00:16:10.000 --> 00:16:19.000
모델 이름과 번들 참조를 허용하는 이니셜라이저를 사용하고 있지만, 다른 옵션도 있습니다.

00:16:19.000 --> 00:16:24.000
다음 단계는 필요한 이주 단계를 설명하는 것이다.

00:16:24.000 --> 00:16:35.000
첫 번째 단계는 flightData 속성만 추가했기 때문에, 속성을 추가하는 것은 가벼운 변화이기 때문에 가벼운 단계로 나타낼 수 있다.

00:16:35.000 --> 00:16:47.000
그러나 다음 단계는 모델 변경 사항이 두 가지 모델 버전으로 분해되었기 때문에 사용자 지정 단계가 될 것이며, 기존 데이터를 보존하기 위해 사용자 지정 코드를 실행해야 합니다.

00:16:47.000 --> 00:16:56.000
사용자 지정 마이그레이션 단계는 ModelV2와 ModelV3로 초기화됩니다.

00:16:56.000 --> 00:17:02.000
willMigrateHandler에서, 코드는 flightData가 nil이 아닌 엔티티 행을 가져옵니다.

00:17:02.000 --> 00:17:21.000
마이그레이션 중에 항공기 클래스가 예상대로 존재하지 않을 수 있기 때문에 일반 NSManagedObject 및 NSFetchRequestResult 유형이 항공기 관리 객체 하위 클래스 대신 사용되고 있습니다.

00:17:21.000 --> 00:17:31.000
가져온 각 항공기 엔티티에 대해, 데이터는 FlightData의 새로운 인스턴스로 복사되며, 두 엔티티는 관련되고 지속된다.

00:17:31.000 --> 00:17:41.000
이 마이그레이션 단계의 실행이 끝나면, 저장소 스키마가 최신 모델로 업데이트되고 기존 데이터가 보존됩니다.

00:17:41.000 --> 00:17:53.000
단계별 마이그레이션을 완료하기 위해, 저는 경량 마이그레이션 단계와 사용자 지정 마이그레이션 단계로 NSStagedMigrationManager를 만듭니다.

00:17:53.000 --> 00:18:06.000
NSStagedMigrationManager는 주요 NSPersistentStore StagedMigrationManagerOptionKey와 함께 NSPersistentStoreDescription 옵션에 추가됩니다.

00:18:06.000 --> 00:18:12.000
그런 다음 영구 저장소가 로드되어 마이그레이션 프로세스를 시작하고 저장소 스키마에 영향을 미칩니다.

00:18:12.000 --> 00:18:14.000
그리고 그게 다야.

00:18:14.000 --> 00:18:21.000
Core Data는 필요한 단계를 자동으로 적용하고 저장소 스키마를 마이그레이션합니다.

00:18:21.000 --> 00:18:31.000
일부 경량 마이그레이션에는 앱이 포그라운드에서 제공할 수 없는 추가 런타임이 필요합니다.

00:18:31.000 --> 00:18:38.000
경량 마이그레이션 중에 사용자 데이터를 변환하는 과정은 즉각적이지 않다.

00:18:38.000 --> 00:18:47.000
예를 들어, 마이그레이션이 한 열에서 다른 열로 데이터를 복사하거나 한 테이블을 다른 테이블로 복사하는 경우, 시간이 좀 걸릴 수 있습니다.

00:18:47.000 --> 00:18:56.000
이것은 특히 마이그레이션이 시작 시간에 완료되는 경우 실망스러운 사용자 경험을 초래할 수 있습니다.

00:18:56.000 --> 00:18:59.000
지연된 이주는 이 문제를 해결하는 데 도움이 될 수 있다.

00:18:59.000 --> 00:19:10.000
이 API를 사용하면 나중에 연기된 작업을 완료할 수 있는 기능으로 경량 마이그레이션 중에 수행된 작업의 일부를 연기할 수 있습니다.

00:19:10.000 --> 00:19:31.000
경량 마이그레이션 중에 엔티티에 인덱스를 업데이트하거나 테이블 복사본을 수행한 후 열을 삭제하는 것과 같이 정리가 필요한 마이그레이션 변환이 있는 경우, 리소스가 테이블 변환을 수행할 수 있다고 판단될 때까지 이 테이블 변환이 지연될 수 있습니다.

00:19:31.000 --> 00:19:36.000
경량 마이그레이션은 여전히 동기적이며 정상적으로 발생한다.

00:19:36.000 --> 00:19:39.000
스키마의 정리만 연기된다.

00:19:39.000 --> 00:19:44.000
당신의 앱은 정상적으로 최신 스키마를 사용할 것입니다.

00:19:44.000 --> 00:19:55.000
지연된 마이그레이션을 선택하려면, 스토어 옵션에서 NSPersistentStore DeferredLightweightMigrationOptionKey를 true로 설정하십시오.

00:19:55.000 --> 00:20:06.000
지연된 마이그레이션 API는 macOS Big Sur와 iOS 14까지 런타임 호환성을 가지고 있습니다.

00:20:06.000 --> 00:20:13.000
지연된 마이그레이션은 SQLite 저장소 유형에서만 사용할 수 있습니다.

00:20:13.000 --> 00:20:34.000
지연된 마이그레이션이 유용할 수 있는 몇 가지 예는 다음과 같습니다: 엔티티에서 속성이나 관계 제거, 엔티티 계층 구조가 더 이상 존재하지 않는 관계 변경, 순서에서 순서가 없는 관계 변경.

00:20:34.000 --> 00:20:39.000
지연된 마이그레이션 작업을 완료하려면, 영구 저장소 메타데이터를 확인하세요.

00:20:39.000 --> 00:20:52.000
NSPersistentStore DeferredLightweightMigrationOptionKey 키가 포함되어 있다면, 완료해야 하는 지연 마이그레이션 작업이 있다는 신호입니다.

00:20:52.000 --> 00:21:02.000
지연된 마이그레이션은 NSPersistentStoreCoordinator .finishDeferredLightweightMigration을 호출하여 처리할 수 있습니다.

00:21:02.000 --> 00:21:16.000
앱에서 경량 마이그레이션을 연기하려면, 코디네이터에 영구 저장소를 추가할 때 저장소 옵션에서 NSPersistentStoreDeferred LightweightMigrationOptionKey를 true로 설정하십시오.

00:21:16.000 --> 00:21:25.000
지연된 마이그레이션을 완료하기에 좋은 시기일 때, 상점의 메타데이터를 확인하여 보류 중인 지연 작업이 있는지 확인할 수 있습니다.

00:21:25.000 --> 00:21:37.000
NSPersistentStoreDeferredLightweight MigrationOptionKey가 true로 설정된 경우, finishDeferredLightweightMigration()을 호출하십시오.

00:21:37.000 --> 00:21:43.000
지연된 마이그레이션 작업을 예약하려면, 백그라운드 작업 API를 사용하는 것을 고려하십시오.

00:21:43.000 --> 00:21:51.000
BGProcessingTask는 긴 데이터 업데이트 및 앱 유지 보수와 같은 시간이 많이 걸리는 작업을 위한 것입니다.

00:21:51.000 --> 00:21:55.000
그 시스템은 당신의 작업을 실행하기에 가장 좋은 시간을 결정할 것입니다.

00:21:55.000 --> 00:22:08.000
그러나, 일반적으로 처리 작업은 유휴 상태일 때만 장치에서 실행되며 사용자가 장치를 사용하기 시작하면 백그라운드 처리 작업을 종료합니다.

00:22:08.000 --> 00:22:12.000
지연된 이주와 단계적인 이주를 결합할 수 있다.

00:22:12.000 --> 00:22:22.000
시간이 좀 걸릴 수 있는 일련의 복잡한 마이그레이션이 있다면, 두 API 기능을 모두 활용하는 단계를 설계하는 것을 고려해 보세요.

00:22:22.000 --> 00:22:34.000
모델V3에서 속성 flightData를 제거하는 예제 모델로 돌아가면, 이것은 좋은 지연된 마이그레이션 후보가 될 수 있습니다.

00:22:34.000 --> 00:22:39.000
코어 데이터에는 세 가지 훌륭한 신기술이 있다.

00:22:39.000 --> 00:23:01.000
복합 속성을 사용하여 중첩 가능하고 구조화된 방식으로 사용자 지정 데이터 유형을 캡슐화하고, 모델 변경을 분해하여 단계별 마이그레이션을 사용하여 복잡한 모델 마이그레이션을 수행하고, 지연된 마이그레이션을 사용하여 일부 마이그레이션 작업을 지연시켜 앱의 성능을 향상시키세요.

00:23:01.000 --> 00:23:06.000
세 가지 기술 모두 앱을 개선하기 위해 조화롭게 작동합니다.

00:23:06.000 --> 00:23:11.000
우리 팀은 당신이 이 새로운 기술을 어떻게 사용하는지 듣게 되어 기쁩니다.

00:23:11.000 --> 00:23:15.000
봐줘서 고마워, 그리고 멋진 WWDC 보내.

00:23:15.000 --> 23:59:59.000
♪ ♪

