WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:17.000
Rishi: 안녕하세요, 제 이름은 Rishi Verma입니다. 이 세션에서는 SwiftData의 스키마를 구축하기 위해 모델을 코딩하는 방법을 다룹니다.

00:00:17.000 --> 00:00:28.000
스키마 매크로를 최대한 활용할 수 있는 방법과 앱이 변경됨에 따라 스키마 마이그레이션으로 스키마를 발전시킬 수 있는 방법을 다루는 것으로 시작하겠습니다.

00:00:28.000 --> 00:00:39.000
시작하기 전에, 이 콘텐츠는 해당 비디오에 소개된 개념에 따라 발전할 것이기 때문에 "SwiftData를 만나세요"와 "SwiftData로 앱 구축"을 시청하세요.

00:00:39.000 --> 00:00:45.000
SwiftData는 데이터 모델링 및 관리를 위한 강력한 프레임워크이며 최신 Swift 앱을 향상시킵니다.

00:00:45.000 --> 00:00:57.000
SwiftUI와 마찬가지로, 외부 파일 형식이 없는 코드에 전적으로 초점을 맞추고, Swift의 새로운 매크로 시스템을 사용하여 원활한 API 경험을 만듭니다.

00:00:57.000 --> 00:01:02.000
저는 사용자가 다가오는 여행을 계획할 수 있는 SampleTrips 앱을 개발하고 있습니다.

00:01:02.000 --> 00:01:08.000
각 여행은 이름, 목적지, 시작 및 종료 날짜로 작성되어야 합니다.

00:01:08.000 --> 00:01:15.000
여행은 또한 버킷리스트 항목과 여행자가 머무를 장소에 대한 관계를 포함할 수 있다.

00:01:15.000 --> 00:01:21.000
SwiftData를 추가하는 것은 가져오기를 추가하고 @Model로 여행을 꾸미는 것만큼 간단합니다.

00:01:21.000 --> 00:01:24.000
그게 다야.

00:01:24.000 --> 00:01:30.000
@Model 매크로는 내 Trip 클래스를 PersistentModel에 적합하게 하고 설명 스키마를 생성합니다.

00:01:30.000 --> 00:01:35.000
내 모델을 정의하는 코드는 이제 내 애플리케이션의 스키마에 대한 진실의 원천이다.

00:01:35.000 --> 00:01:41.000
내 여행 모델의 기본 동작은 좋지만, 조금 미세 조정할 수 있다고 생각한다.

00:01:41.000 --> 00:01:49.000
SwiftData의 스키마 매크로를 사용하면 내 앱에서 완벽하게 작동하도록 지속성 경험의 동작을 사용자 정의할 수 있습니다.

00:01:49.000 --> 00:01:55.000
원래 스키마로 앱을 게시했을 때, 나는 각 여행 이름이 고유한지 확인하지 않았다.

00:01:55.000 --> 00:02:00.000
이것은 내가 지금 해결해야 할 같은 이름의 여행 사이에 몇 가지 갈등을 일으켰다.

00:02:00.000 --> 00:02:06.000
이것은 @Attribute 스키마 매크로와 고유한 옵션을 사용하여 수정할 수 있습니다.

00:02:06.000 --> 00:02:16.000
SwiftData는 내 여행 모델에 대한 스키마를 생성할 것이며, 이제 내가 영구적인 백엔드에 저장하는 모든 여행이 고유한 이름을 가질 수 있도록 보장할 것이다.

00:02:16.000 --> 00:02:23.000
그 이름으로 여행이 이미 존재한다면, 영구적인 백엔드가 최신 값으로 업데이트될 것이다.

00:02:23.000 --> 00:02:25.000
이것은 업서트라고 불린다.

00:02:25.000 --> 00:02:28.000
업서트는 삽입물로 시작한다.

00:02:28.000 --> 00:02:34.000
삽입물이 기존 데이터와 충돌하면, 업데이트가 되어 기존 데이터의 속성을 업데이트합니다.

00:02:34.000 --> 00:02:47.000
숫자, 문자열 또는 UUID와 같은 기본 값 유형인 한 다른 속성에도 고유한 제약을 적용할 수 있으며, 일대일 관계를 장식할 수도 있습니다.

00:02:47.000 --> 00:02:49.000
내 스키마는 좀 더 많은 작업이 필요해.

00:02:49.000 --> 00:02:56.000
원래 지정한 시작 날짜와 종료 날짜에서 이 성가신 밑줄을 제거하고 싶습니다.

00:02:56.000 --> 00:03:02.000
변수의 이름을 바꾸면, 이것은 내가 생성된 스키마에서 새로운 속성으로 보일 것이다.

00:03:02.000 --> 00:03:05.000
나는 SwiftData가 이러한 새로운 속성을 만드는 것을 원하지 않는다.

00:03:05.000 --> 00:03:10.000
대신, 나는 기존 데이터를 그대로 보존하고 싶다.

00:03:10.000 --> 00:03:18.000
@Attribute를 사용하여 원래 이름을 속성 이름에 매핑하고 originalName: 매개 변수를 지정하기만 하면 됩니다.

00:03:18.000 --> 00:03:22.000
이것들을 원래 이름에서 매핑하면 데이터 손실을 피할 수 있습니다.

00:03:22.000 --> 00:03:30.000
이것은 또한 내 스키마 업데이트가 SampleTrips 앱의 다음 릴리스를 위한 간단한 마이그레이션이 될 수 있도록 보장합니다.

00:03:30.000 --> 00:03:40.000
그리고 @Attribute 매크로는 큰 데이터를 외부에 저장하고 변환 가능한 지원을 제공하는 것을 포함하여 훨씬 더 많은 것을 할 수 있습니다.

00:03:40.000 --> 00:03:45.000
내 여행은 잘 진행되고 있지만, 지금은 관계를 위해 일하고 싶다.

00:03:45.000 --> 00:03:55.000
내 여행에 새로운 버킷리스트 항목이나 생활 숙박 시설을 추가할 때, SwiftData는 암묵적으로 내 모델 사이의 역을 발견하고 나를 위해 설정할 것이다.

00:03:55.000 --> 00:03:59.000
암시적 역은 주석이 필요하지 않습니다.

00:03:59.000 --> 00:04:01.000
그들은 그냥 일해.

00:04:01.000 --> 00:04:10.000
암시적 역은 여행이 삭제될 때 버킷리스트 항목과 생활 숙박 시설을 무효화하는 기본 삭제 규칙을 사용합니다.

00:04:10.000 --> 00:04:17.000
하지만, 나는 내 버킷리스트 항목과 생활 숙소가 여행과 함께 삭제되기를 원한다.

00:04:17.000 --> 00:04:22.000
캐스케이드 삭제 규칙으로 @Relationship 매크로를 추가하여 쉽게 할 수 있습니다.

00:04:22.000 --> 00:04:28.000
이제 내가 여행을 삭제하면, 그 관계들도 삭제될 것이다.

00:04:28.000 --> 00:04:39.000
그리고 @Relationship 매크로는 originalName 수정자와 대다 관계에서 최소 및 최대 수를 지정하는 기능을 포함하여 훨씬 더 많은 일을 합니다.

00:04:39.000 --> 00:04:43.000
SampleTrips 앱은 잘 형성되고 있지만, 나는 여전히 해야 할 업데이트가 있다.

00:04:43.000 --> 00:04:48.000
이제, 나는 여행을 몇 번이나 보는지 추적할 수 있는 방법을 추가하고 싶다.

00:04:48.000 --> 00:04:52.000
이렇게 하면 내가 휴가를 보내는 것에 대해 얼마나 흥분되는지 가늠할 수 있다.

00:04:52.000 --> 00:04:53.000
기다릴 수 없어!

00:04:53.000 --> 00:05:02.000
그러나 나는 이 뷰 카운트가 SwiftData에 의해 지속되는 것을 원하지 않으며, @Transient 매크로로 쉽게 할 수 있다.

00:05:02.000 --> 00:05:08.000
나는 단순히 @Transient로 내 재산을 꾸미고, 이 특정 재산은 지속되지 않을 것이다.

00:05:08.000 --> 00:05:10.000
그냥 그렇게 쉬워.

00:05:10.000 --> 00:05:14.000
@Transient 매크로는 불필요한 데이터를 지속하지 않도록 도와줍니다.

00:05:14.000 --> 00:05:18.000
일시적인 속성에 대한 기본값을 제공해야 합니다.

00:05:18.000 --> 00:05:23.000
이것은 그들이 SwiftData에서 가져올 때 논리적인 값을 갖도록 한다.

00:05:23.000 --> 00:05:29.000
이러한 스키마 매크로 활용에 대한 자세한 내용은 SwiftData 문서를 확인하세요.

00:05:29.000 --> 00:05:35.000
SampleTrips 앱 스키마는 내가 끈기 경험을 맞춤화하면서 몇 가지 진화를 거쳤다.

00:05:35.000 --> 00:05:39.000
내 앱이 출시부터 출시까지 업데이트를 처리할 수 있도록 해야 합니다.

00:05:39.000 --> 00:05:46.000
그리고 속성을 추가하거나 제거하는 것과 같이 스키마를 변경할 때, 데이터 마이그레이션이 발생합니다.

00:05:46.000 --> 00:05:51.000
이러한 마이그레이션은 까다로운 시나리오가 될 수 있지만, SwiftData는 그것을 쉽게 만든다.

00:05:51.000 --> 00:05:55.000
VersionedSchema와 SchemaMigrationPlan은 당신을 돕기 위해 여기에 있습니다.

00:05:55.000 --> 00:06:05.000
SwiftData 모델의 변경 사항으로 새 버전의 앱을 출시할 준비를 할 때마다, 이전에 출시된 스키마를 캡슐화하는 VersionedSchema를 정의하십시오.

00:06:05.000 --> 00:06:15.000
스키마의 각 별개의 버전은 SwiftData가 그들 사이에 어떤 변화가 일어났는지 알 수 있도록 VersionedSchema로 정의되어야 합니다.

00:06:15.000 --> 00:06:21.000
그런 다음, VersionedSchemas의 총 순서를 사용하여 SchemaMigrationPlan을 만드세요.

00:06:21.000 --> 00:06:26.000
이를 통해 SwiftData는 필요한 마이그레이션을 순서대로 수행할 수 있습니다.

00:06:26.000 --> 00:06:33.000
마이그레이션 계획에서 주문한 스키마를 배치하면, 각 마이그레이션 단계를 정의하기 시작할 수 있습니다.

00:06:33.000 --> 00:06:37.000
당신이 이용할 수 있는 두 가지 유형의 이주 단계가 있습니다.

00:06:37.000 --> 00:06:40.000
첫 번째는 가벼운 이주 단계이다.

00:06:40.000 --> 00:06:47.000
경량 마이그레이션은 다음 앱 출시를 위해 기존 데이터를 마이그레이션하는 데 추가 코드가 필요하지 않습니다.

00:06:47.000 --> 00:06:57.000
내 날짜 속성에 originalName을 추가하거나 내 관계에 대한 삭제 규칙을 지정하는 것과 같은 수정은 가벼운 마이그레이션 자격이 있습니다.

00:06:57.000 --> 00:07:03.000
그러나, 여행의 이름을 독특하게 만드는 것은 가벼운 이주를 할 수 없다.

00:07:03.000 --> 00:07:12.000
나는 그들의 이름이 독특해지기 전에 내 여행의 중복을 제거할 수 있는 이 변화를 위한 사용자 지정 마이그레이션 단계를 만들어야 한다.

00:07:12.000 --> 00:07:18.000
나는 첫 번째 릴리스에서 원본 스키마를 가지고 VersionedSchema에 캡슐화하는 것으로 시작한다.

00:07:18.000 --> 00:07:23.000
나는 이 버전의 스키마 SampleTripsSchemaV1의 이름을 지었다.

00:07:23.000 --> 00:07:28.000
내 버전화된 스키마 각각은 그들이 정의한 모델 클래스를 나열한다.

00:07:28.000 --> 00:07:33.000
내 스키마 버전 2는 여행 이름에 고유성 제약을 추가한 곳이다.

00:07:33.000 --> 00:07:41.000
나는 트립 모델 클래스에 대한 변경 사항을 캡슐화하는 또 다른 버전 스키마를 만든다.

00:07:41.000 --> 00:07:48.000
나는 내 스키마의 버전 3에 대해서도 똑같이 하며, 시작 날짜와 종료 날짜에 대한 이름 변경 사항을 캡처합니다.

00:07:48.000 --> 00:07:56.000
이제 모든 VersionedSchemas를 가지고 있기 때문에, 릴리스에서 릴리스로의 마이그레이션을 처리하는 방법을 설명하기 위해 SchemaMigrationPlan을 구성합니다.

00:07:56.000 --> 00:07:58.000
그건 꽤 간단해.

00:07:58.000 --> 00:08:02.000
저는 제 지원서 스키마의 전체 순서를 제공합니다.

00:08:02.000 --> 00:08:07.000
그런 다음, 나는 어떤 마이그레이션이 가볍거나 사용자 지정인지 주석을 달아야 한다.

00:08:07.000 --> 00:08:14.000
V1에서 V2로의 경우, 데이터를 마이그레이션하기 전에 작업을 수행할 수 있는 사용자 지정 단계가 필요합니다.

00:08:14.000 --> 00:08:20.000
willMigrate 폐쇄에서, 나는 이주가 일어나기 전에 여행을 중복할 수 있다.

00:08:20.000 --> 00:08:28.000
SwiftData는 V1에서 V2로의 마이그레이션이 언제 발생할지 감지하고 나를 위해 이 폐쇄를 수행할 것이다.

00:08:28.000 --> 00:08:34.000
originalName의 다른 마이그레이션은 가볍기 때문에, 그 단계도 추가할 수 있다.

00:08:34.000 --> 00:08:41.000
이제 마이그레이션 계획에 대한 모든 세부 사항을 정의했으므로 마이그레이션을 수행할 때입니다.

00:08:41.000 --> 00:08:47.000
현재 스키마와 마이그레이션 계획으로 ModelContainer를 설정했고, 완료되었습니다.

00:08:47.000 --> 00:08:52.000
내 사용자는 모든 버전에서 최신 릴리스로 업그레이드할 수 있으며, 데이터가 보존되도록 보장했습니다.

00:08:52.000 --> 00:08:58.000
나는 다가오는 휴가를 계획하기 위해 SampleTrips 앱을 빨리 사용하고 싶다.

00:08:58.000 --> 00:09:09.000
스키마 매크로를 활용하여 스키마에 대한 추가 메타데이터를 전달하고, 애플리케이션이 진화함에 따라 VersionedSchema에서 이러한 진화를 캡처하여 앱이 이전 릴리스에서 마이그레이션할 수 있습니다.

00:09:09.000 --> 00:09:15.000
이 다른 회담을 확인해 보세요, 그리고 우리는 여러분 모두가 SwiftData로 만드는 놀라운 것들을 보기를 기대합니다.

00:09:15.000 --> 23:59:59.000
영광이었어.

