WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:15.000
에린: 안녕! 제 이름은 에린이고, 저는 코어모션 팀의 엔지니어입니다.

00:00:15.000 --> 00:00:19.000
코어모션에 대한 멋진 업데이트에 대해 알려드리게 되어 기쁩니다.

00:00:19.000 --> 00:00:24.000
코어모션은 관성 센서의 모션 데이터에 접근하기 위한 중앙 프레임워크 역할을 한다.

00:00:24.000 --> 00:00:29.000
우리의 하드웨어가 발전함에 따라, 모션 정보를 캡처하는 능력도 발전했다.

00:00:29.000 --> 00:00:38.000
충돌 감지, 낙하 감지 및 공간 오디오는 향상된 감지 기능에 의존하는 기능 중 일부일 뿐입니다.

00:00:38.000 --> 00:00:43.000
CoreMotion을 사용하면 자신의 앱에서도 이러한 개선 사항을 활용할 수 있습니다.

00:00:43.000 --> 00:00:55.000
이 세션에서는 모션 데이터와 상호 작용할 수 있는 몇 가지 새로운 방법에 초점을 맞출 것이지만, 새로운 기능에 도달하기 전에 모션 데이터를 생성하는 센서를 빠르게 상기시켜 드리고 싶습니다.

00:00:55.000 --> 00:00:59.000
장치가 움직이는 방식을 포착하는 것은 우리가 그것들을 경험하는 방식의 핵심이다.

00:00:59.000 --> 00:01:06.000
Apple의 많은 장치는 내장 센서를 사용하여 공간을 통한 움직임에 대한 개념을 만드는 데 도움을 준다.

00:01:06.000 --> 00:01:08.000
예를 들어 Apple Watch를 생각해 보세요.

00:01:08.000 --> 00:01:23.000
내장 센서에는 가속도를 측정하는 가속도계, 회전을 측정하는 자이로스코프, 자기장을 측정하는 자력계, 압력을 측정하는 기압계가 있습니다.

00:01:23.000 --> 00:01:28.000
함께, 그들은 장치가 우주에서 어떻게 움직이고 방향을 잡는지 추적하는 데 도움을 준다.

00:01:28.000 --> 00:01:34.000
장치의 움직임에 대한 아이디어를 생성하는 것은 우리가 즐기는 많은 기능의 기본이다.

00:01:34.000 --> 00:01:40.000
여기에는 그날 취한 걸음 수와 운동 중에 얼마나 많은 칼로리를 태웠는지 추적하는 것과 같은 것들이 포함됩니다.

00:01:40.000 --> 00:01:48.000
그것은 우리 하늘의 별을 탐험하는 별 관측 앱과 같이 장치의 방향에 의존하는 경험을 지원합니다.

00:01:48.000 --> 00:01:57.000
자동차 사고를 당했을 때나 넘어졌을 때를 감지하여 우리를 안전하게 지켜주는 기능은 또한 동일한 센서를 사용하여 움직임을 추적하는 데 의존합니다.

00:01:57.000 --> 00:02:04.000
이것들은 가능한 많은 응용 프로그램 중 일부일 뿐이며, 우리는 항상 당신이 CoreMotion을 어떻게 활용하는지 보기를 기대합니다.

00:02:04.000 --> 00:02:19.000
이제 관련된 일부 센서에 대한 간략한 개요를 제공했으므로, AirPods와 같은 오디오 제품에서 모션 데이터를 얻고, 침수 데이터 업데이트를 받고, 마지막으로 더 높은 속도의 센서 데이터를 스트리밍하는 새로운 방법을 검토하겠습니다.

00:02:19.000 --> 00:02:22.000
헤드폰 모션으로 시작합시다.

00:02:22.000 --> 00:02:30.000
얼마 전, 동적 헤드 트래킹이 있는 공간 오디오는 우리가 음악과 영화를 경험하는 방식을 바꿨다.

00:02:30.000 --> 00:02:37.000
동적 머리 추적은 iPhone과 Apple Watch에 있는 것과 동일한 장치 모션 알고리즘에 의존한다.

00:02:37.000 --> 00:02:47.000
몇 년 전에 CMHeadphoneMotionManager가 도입되었을 때, 동적 헤드 추적을 가능하게 한 동일한 데이터를 사용할 수 있게 되었습니다.

00:02:47.000 --> 00:02:57.000
태도, 사용자 가속 및 회전 속도 데이터를 연결된 iOS 또는 iPadOS 장치로 스트리밍하면 머리가 움직이는 방식을 추적할 수 있습니다.

00:02:57.000 --> 00:03:02.000
헤드 트래킹은 게임에서 피트니스 애플리케이션에 이르기까지 많은 멋진 기능을 잠금 해제했다.

00:03:02.000 --> 00:03:08.000
그리고 이제, 올해, CMHeadphoneMotionManager가 macOS에 온다.

00:03:08.000 --> 00:03:10.000
몇 가지 세부 사항을 살펴봅시다.

00:03:10.000 --> 00:03:17.000
CMHeadphoneMotionManager는 iOS와 iPadOS 14에서 처음 제공되었다.

00:03:17.000 --> 00:03:21.000
그리고 올해부터, 그것은 또한 macOS 14에 올 것이다.

00:03:21.000 --> 00:03:35.000
CMHeadphoneMotionManager를 사용하여 AirPods Pro와 같은 동적 헤드 트래킹으로 공간 오디오를 지원하는 오디오 제품에서 연결된 iOS, iPadOS 또는 macOS 장치로 장치 모션을 스트리밍할 수 있습니다.

00:03:35.000 --> 00:03:47.000
iPhone과 Apple Watch에서와 마찬가지로 지원되는 장치에서 스트리밍하는 동안 CMDeviceMotion의 태도, 사용자 가속 및 회전 속도 데이터를 검사하십시오.

00:03:47.000 --> 00:03:59.000
SensorLocation과 같은 CMHeadphoneMotionManager와 관련된 추가 정보는 왼쪽 또는 오른쪽 버드에서 데이터 소스가 어디에 있는지 명확하게 구분하는 데 도움이 됩니다.

00:03:59.000 --> 00:04:05.000
데이터는 원격 장치에서 스트리밍되기 때문에, 언제 연결되어 있는지 이해하는 것이 중요합니다.

00:04:05.000 --> 00:04:11.000
CMHeadphoneMotionManagerDelegate를 사용하면 연결 상태 업데이트를 쉽게 들을 수 있습니다.

00:04:11.000 --> 00:04:14.000
그걸 어떻게 사용하는지 보여줄게.

00:04:14.000 --> 00:04:20.000
연결 상태 업데이트에 응답하기 위해 CMHeadphoneMotionManagerDelegate 프로토콜을 채택하십시오.

00:04:20.000 --> 00:04:27.000
오디오 장치가 iPhone, iPad 또는 Mac과 같은 지원되는 스트리밍 장치에 연결되어 있을 때 데이터를 사용할 수 있습니다.

00:04:27.000 --> 00:04:33.000
자동 귀 감지가 활성화되면, 머리 추적에도 영향을 미치는 이벤트를 받게 됩니다.

00:04:33.000 --> 00:04:39.000
이어폰을 귀에서 빼면 연결이 끊어지는 이벤트가 발생하고, 다시 넣으면 연결 이벤트가 발생할 수 있습니다.

00:04:39.000 --> 00:04:48.000
마찬가지로, 자동 헤드 감지가 활성화되면, 이어 헤드폰을 착용하고 벗으면 이러한 이벤트가 트리거됩니다.

00:04:48.000 --> 00:04:55.000
이러한 이벤트를 듣고 데이터를 스트리밍하기 위해 CMHeadphoneMotionManager를 설정하는 것은 쉽습니다. 어떻게 하는지 보여줄게.

00:04:55.000 --> 00:05:05.000
스트리밍을 시작하기 전에, isDeviceMotionAvailable 속성을 사용하여 확인할 수 있는 장치 모션 데이터를 사용할 수 있는지 확인해야 합니다.

00:05:05.000 --> 00:05:09.000
앞서 말한 연결 이벤트를 받기 위해 대리인을 할당하세요.

00:05:09.000 --> 00:05:11.000
그런 다음, 데이터 스트리밍을 시작하세요.

00:05:11.000 --> 00:05:16.000
CMHeadphoneMotionManager는 데이터를 잡기 위해 푸시와 풀 인터페이스를 모두 노출합니다.

00:05:16.000 --> 00:05:19.000
이 예시에서, 우리는 푸시 인터페이스를 사용할 것이다.

00:05:19.000 --> 00:05:24.000
startDeviceMotionUpdates를 사용하고 작업 대기열과 핸들러를 지정하세요.

00:05:24.000 --> 00:05:29.000
모션 데이터에 접근하고 있기 때문에, 인증이 중요합니다.

00:05:29.000 --> 00:05:38.000
앱 사용자는 Info.plist에 추가한 모션 사용 설명 키를 사용하여 모션 데이터에 대한 앱을 인증하라는 메시지가 표시됩니다.

00:05:38.000 --> 00:05:47.000
authorizationStatus 속성을 확인하여 모션 데이터에 대한 권한이 있는지 확인하고 권한 수준에 관계없이 원활한 경험을 제공할 수 있습니다.

00:05:47.000 --> 00:05:56.000
승인되고 데이터가 스트리밍되기 시작하면, 각 장치 모션 업데이트와 함께 제공된 자세 정보를 사용하여 헤드 포즈를 쉽게 추적할 수 있습니다.

00:05:56.000 --> 00:06:08.000
예를 들어, 우리는 시작 포즈와 같은 참조 태도를 추적하고 곱셈 방법을 사용하여 원래 포즈에 대한 현재 샘플의 상대적인 변화를 편리하게 얻을 수 있습니다.

00:06:08.000 --> 00:06:18.000
자세, 사용자 가속 및 회전 속도 데이터와 함께, 각 장치 모션 업데이트에는 센서 위치 정보가 포함되어 있습니다.

00:06:18.000 --> 00:06:24.000
모션 데이터가 한 번에 하나의 버드에서 당신에게 전달되기 때문에 이것은 중요합니다.

00:06:24.000 --> 00:06:31.000
각 샘플과 함께 전달된 SensorLocation 열거형을 사용하면 어떤 새싹이 데이터를 공급했는지 식별할 수 있습니다.

00:06:31.000 --> 00:06:39.000
데이터를 스트리밍하는 새싹은 자동 귀 감지가 활성화된 경우 인이어 상태를 포함하여 여러 가지에 의해 영향을 받을 수 있습니다.

00:06:39.000 --> 00:06:49.000
예를 들어, 데이터가 오른쪽 이어폰에서 스트리밍되고 있지만 자동 귀 감지가 활성화된 상태에서 귀에서 꺼내면, 왼쪽 이어폰이 데이터 스트림을 인수할 것입니다.

00:06:49.000 --> 00:06:53.000
이것은 더 원활한 헤드 트래킹 경험을 가능하게 한다.

00:06:53.000 --> 00:06:57.000
편리한 머리 추적은 다양한 경험의 문을 열었다.

00:06:57.000 --> 00:07:03.000
팔굽혀펴기의 수를 세거나 자세를 모니터링하는 것과 같은 것들이 그 어느 때보다 쉬워졌습니다.

00:07:03.000 --> 00:07:12.000
그리고 이제 macOS 지원을 통해 헤드 트래킹 지원 오디오 제품에서 더 넓은 범위의 장치로 모션 데이터를 스트리밍할 수 있습니다.

00:07:12.000 --> 00:07:17.000
우리는 당신이 CMHeadphoneMotionManager를 사용하여 만드는 것을 보게 되어 기쁩니다.

00:07:17.000 --> 00:07:22.000
이제, 당신은 당신의 머리가 어떻게 움직이는지 추적하기 위해 압력을 측정할 필요가 없지만, 다른 것은 그렇게 합니다.

00:07:22.000 --> 00:07:31.000
CMWaterSubmersionManager에 대한 멋진 업데이트를 사용하여 수성 활동과 상호 작용할 수 있는 방법에 대해 이야기하려고 합니다.

00:07:31.000 --> 00:07:40.000
스노클링이나 수영과 같은 수성 활동 중에, 물과 침수 상태에 대해 알아야 할 흥미로운 것들이 많이 있습니다.

00:07:40.000 --> 00:07:45.000
당신은 아마 당신이 얼마나 깊고 수온이 얼마인지에 관심이 있을 것입니다.

00:07:45.000 --> 00:07:54.000
물에 잠겼을 때 또는 해안이나 보트로 다시 빠져나왔는지, 그리고 활동 중 표면 기압이 얼마인지 아는 것도 유용합니다.

00:07:54.000 --> 00:08:02.000
내장된 기압계를 사용하여, CMWaterSubmersionManager는 수성 활동 중에 이러한 지표를 추적할 수 있습니다.

00:08:02.000 --> 00:08:04.000
내가 너에게 몇 가지 세부 사항을 알려줄게.

00:08:04.000 --> 00:08:10.000
CMWaterSubmersionManager는 watchOS 9를 실행하는 Apple Watch Ultra에서 사용할 수 있습니다.

00:08:10.000 --> 00:08:18.000
CMWaterSubmersionManagerDelegate를 사용하여 깊이, 온도 및 침수 상태 데이터를 수신하십시오.

00:08:18.000 --> 00:08:29.000
앱에 얕은 깊이와 압력 기능을 추가하고 앱 사용자가 자동 실행 설정을 구성하여 물 기반 활동을 시작할 때 원활한 경험을 얻으십시오.

00:08:29.000 --> 00:08:34.000
CMWaterSubmersionManager를 사용하는 방법을 보여드리겠습니다.

00:08:34.000 --> 00:08:42.000
침수 상태 추적을 시작하려면, 가용성을 확인한 후 CMWaterSubmersionManager를 설정하십시오.

00:08:42.000 --> 00:08:47.000
그런 다음, 침수 상태와 이벤트에 대한 업데이트를 받기 시작할 대리인을 할당하세요.

00:08:47.000 --> 00:08:50.000
그 업데이트를 받는 방법에 대해 조금 이야기해 봅시다.

00:08:50.000 --> 00:08:55.000
CMWaterSubmersionManagerDelegate를 사용하여 업데이트를 받는 것은 간단합니다.

00:08:55.000 --> 00:08:59.000
당신이 받을 수 있는 다양한 유형의 업데이트가 있습니다.

00:08:59.000 --> 00:09:08.000
물에 들어가고 나갈 때와 같은 침수 상태에 대한 업데이트는 CMWaterSubmersionEvent와 함께 didUpdate 방법을 사용하여 전달됩니다.

00:09:08.000 --> 00:09:19.000
앱이 자격이 없거나 지원되지 않는 플랫폼에 있을 때 업데이트를 받으려고 하는 경우와 같이 문제가 있을 때 오류 업데이트를 받게 됩니다.

00:09:19.000 --> 00:09:23.000
수온 업데이트는 CMWaterTemperature를 사용하여 전달됩니다.

00:09:23.000 --> 00:09:30.000
그들은 시계 온도가 물과 같을 때 몇 초가 걸리기 때문에 불확실성의 개념을 가지고 있다.

00:09:30.000 --> 00:09:38.000
그래서, 당신이 처음 물에 잠겼을 때, 불확실성은 더 높아지고 물에서 더 많은 시간을 보내면 수렴하기 시작할 것입니다.

00:09:38.000 --> 00:09:42.000
수온은 물에 잠겼을 때만 사용할 수 있다는 점에 유의하십시오.

00:09:42.000 --> 00:09:50.000
CMWaterSubmersionMeasurement로 깊이, 압력, 표면 압력 및 침수 상태 업데이트를 받을 수 있습니다.

00:09:50.000 --> 00:09:56.000
물에 잠긴 활동 중에, 측정값은 정기적으로 앱으로 전달됩니다.

00:09:56.000 --> 00:10:03.000
깊이와 같은 이 데이터 중 일부는 물에 잠긴 상태에 있을 때만 적용 가능하므로 선택 사항입니다.

00:10:03.000 --> 00:10:07.000
수중 깊이는 특정 깊이 상태에 해당한다.

00:10:07.000 --> 00:10:10.000
그들이 어떻게 매핑되었는지 보여줄게.

00:10:10.000 --> 00:10:14.000
당신이 물에 잠기지 않은 상태에 있을 때, 물 밖으로 나온 상태에서 시작합시다.

00:10:14.000 --> 00:10:18.000
수중 1미터 이상, 당신은 물에 잠긴 얕은 상태에 있습니다.

00:10:18.000 --> 00:10:21.000
1미터를 넘어, 당신은 수중 깊은 상태에 있습니다.

00:10:21.000 --> 00:10:31.000
얕은 깊이와 압력 기능을 사용하면 앱 사용자가 감압병의 위험을 최소화하는 깊이 영역 내에 머물 수 있도록 쉽게 할 수 있습니다.

00:10:31.000 --> 00:10:36.000
그것은 최대 깊이를 6미터로 유지하고, 당신이 그 깊이에 가까울 때 알려줍니다.

00:10:36.000 --> 00:10:41.000
최대 깊이 속성을 사용하여 모니터링 중인 깊이를 확인할 수 있습니다.

00:10:41.000 --> 00:10:45.000
6미터에 접근하면, 접근하는 MaxDepth 상태로 들어갈 것입니다.

00:10:45.000 --> 00:10:49.000
6미터를 넘어, 당신은 과거MaxDepth 상태에 있습니다.

00:10:49.000 --> 00:10:55.000
데이터는 6미터까지 내려가며, 과거 MaxDepth 상태의 불확실성이 있다.

00:10:55.000 --> 00:10:58.000
그 외에도, 당신은 sensorDepthError 상태에 있습니다.

00:10:58.000 --> 00:11:08.000
CMWaterSubmersionManager는 깊이를 영역으로 나누면서 안전과 센서 한계에 중점을 두고 깊이의 변화를 쉽게 모니터링할 수 있습니다.

00:11:08.000 --> 00:11:17.000
최대 6미터 깊이 이상의 사용 사례에 관심이 있다면, 관리 자격에 대한 자세한 내용은 문서를 확인할 수 있습니다.

00:11:17.000 --> 00:11:24.000
어떤 방법을 선택하든, CMWaterSubmersionManager로 수상 스포츠를 위한 훌륭한 경험을 만드는 것이 그 어느 때보다 쉽습니다.

00:11:24.000 --> 00:11:35.000
물 밖에도 많은 스포츠가 있으며, CMB CatchedSensorManager를 사용하여 이러한 활동 중에 고속 모션 데이터를 소비하는 방법을 공유하게 되어 기쁩니다.

00:11:35.000 --> 00:11:37.000
먼저 배경부터 시작합시다.

00:11:37.000 --> 00:11:41.000
모션 데이터가 당신에게 전달되는 몇 가지 방법에 대해 이야기했습니다.

00:11:41.000 --> 00:11:52.000
장치 모션 알고리즘은 내장 가속도계와 자이로스코프의 데이터를 융합하여 Apple Watch와 같은 장치가 우주를 통해 이동하는 방식을 쉽게 추적할 수 있는 방법을 제공합니다.

00:11:52.000 --> 00:12:00.000
샘플별로 앱에 실시간으로 이러한 샘플을 제공하는 CMMotionManager에 익숙할 수 있습니다.

00:12:00.000 --> 00:12:03.000
지원되는 최대 주파수는 100Hz입니다.

00:12:03.000 --> 00:12:13.000
이것은 장치의 즉각적인 태도에 의존하는 UI 구성 요소와 같은 낮은 대기 시간 요구 사항이 있다면 훌륭한 선택이라는 것을 의미합니다.

00:12:13.000 --> 00:12:21.000
이제, 이것은 새로운 CMBatchedSensorManager를 사용하여 고속 데이터를 제공하는 방식과 어떻게 비교됩니까?

00:12:21.000 --> 00:12:28.000
CMBatchedSensorManager는 고정된 일정에 따라 센서 데이터 배치를 제공하여 초당 데이터 배치를 제공합니다.

00:12:28.000 --> 00:12:33.000
이것은 우리가 당신의 앱에 더 낮은 오버헤드로 더 높은 속도의 데이터를 제공할 수 있다는 것을 의미합니다.

00:12:33.000 --> 00:12:41.000
기존 CMMotionManager의 100Hz에 비해 800Hz 가속도계와 200Hz 장치 모션입니다.

00:12:41.000 --> 00:12:50.000
이제, 넘어짐 및 충돌 감지와 같이 우리를 안전하게 지켜주는 기능을 지원하는 동일한 데이터 스트림에 액세스할 수 있습니다.

00:12:50.000 --> 00:12:56.000
데이터가 일괄 처리되기 때문에, CMBatchedSensorManager를 사용할 때 고려해야 할 몇 가지 사항이 있습니다.

00:12:56.000 --> 00:13:07.000
앱에 고속 데이터의 혜택을 받을 수 있지만 매우 빡빡한 대기 시간 요구 사항이 없는 운동 중심 기능이 있다면, CMBatchedSensorManager가 적합합니다.

00:13:07.000 --> 00:13:15.000
나는 얼마나 더 높은 속도의 센서 데이터가 당신에게 전달되는지, 그리고 그것이 우리의 기존 인터페이스 중 일부에서 제공되는 것과 어떻게 비교되는지 살펴보았다.

00:13:15.000 --> 00:13:18.000
그것이 사용될 수 있는 몇 가지 방법을 보여드리겠습니다.

00:13:18.000 --> 00:13:23.000
많은 스포츠는 단기 영향 기반 행사를 중심으로 한다.

00:13:23.000 --> 00:13:30.000
여기에는 골프, 테니스, 야구와 같은 활동이 포함된다.

00:13:30.000 --> 00:13:38.000
이것들에서, 스윙 운동 중에 더 많은 정보를 포착하는 것은 형태를 평가하고 게임을 개선하는 데 중요할 수 있습니다.

00:13:38.000 --> 00:13:43.000
이것은 더 높은 속도의 센서 데이터를 캡처하는 곳이다.

00:13:43.000 --> 00:13:46.000
우리는 이것을 구체적인 예시에 고정함으로써 이익을 얻을 것이다.

00:13:46.000 --> 00:13:48.000
야구 스윙에 집중하자.

00:13:48.000 --> 00:13:51.000
스윙에는 몇 가지 다른 단계가 있다.

00:13:51.000 --> 00:13:58.000
이 그림에서, 우리는 프리스윙 설정, 실제 스윙, 그리고 포스트 임팩트 후속을 볼 수 있다.

00:13:58.000 --> 00:14:02.000
스윙 품질에 대한 중요한 지표는 연락할 시간이다.

00:14:02.000 --> 00:14:09.000
즉, 타자가 방망이의 스윙을 시작할 때와 방망이가 공을 치는 시간 사이에 얼마나 많은 시간이 경과하는지.

00:14:09.000 --> 00:14:13.000
고속 센서 데이터를 사용하여, 우리는 이것을 세 단계로 나눌 수 있다.

00:14:13.000 --> 00:14:19.000
타자의 손목에서, 우리는 x, y, z 방향이 있는 Apple Watch를 볼 수 있다.

00:14:19.000 --> 00:14:26.000
우리는 중력 벡터가 아래를 가리키면서 파란색으로 타자 주위를 움직이는 손목의 경로를 상상할 수 있다.

00:14:26.000 --> 00:14:34.000
접촉 시간을 계산하기 위해, 나는 먼저 800Hz 가속도계를 사용하여 방망이와 공 사이의 충격 지점을 감지할 것이다.

00:14:34.000 --> 00:14:41.000
그런 다음, 나는 200Hz 장치 움직임과 중력을 따라 회전을 사용하여 스윙의 시작을 식별할 것이다.

00:14:41.000 --> 00:14:49.000
마지막으로, 우리는 스윙의 시작부터 접촉 시간이라고 불리는 이 타임스탬프의 차이를 계산할 수 있다.

00:14:49.000 --> 00:14:54.000
우리가 찾고 있는 것을 이해하기 위해 스윙 중에 센서 데이터를 시각화하는 것부터 시작합시다.

00:14:54.000 --> 00:15:01.000
여기서, 나는 한 번의 스윙을 포함하는 1초의 창에 대해 z 방향으로 가속도계 데이터를 플로팅했다.

00:15:01.000 --> 00:15:07.000
나는 0.5초에서 0.6초 사이에 활동의 폭발이 있다는 것을 알 수 있다.

00:15:07.000 --> 00:15:13.000
충격 지점을 감지하는 우리의 알고리즘은 이 관찰을 중심으로 할 것이다.

00:15:13.000 --> 00:15:23.000
상단에 800Hz 가속도계와 하단에 100Hz 가속도계로 스윙 중에 사용할 수 있는 신호 정보의 양을 비교해 봅시다.

00:15:23.000 --> 00:15:33.000
그 관심 섹션에서, 0.5초에서 0.6초 사이에, 우리는 이제 10개가 아닌 80개의 데이터 포인트를 가지고 있으며, 우리에게 무슨 일이 일어나고 있는지에 대한 훨씬 더 세밀한 그림을 제공한다.

00:15:33.000 --> 00:15:38.000
이것은 우리가 영향과 같이 우리가 관심 있는 것들에 집중하는 데 도움을 준다.

00:15:38.000 --> 00:15:43.000
이제, 장치 모션 관점에서 같은 스윙을 살펴봅시다.

00:15:43.000 --> 00:15:47.000
이것은 200Hz에서 중력을 따라 회전 속도를 플로팅한다.

00:15:47.000 --> 00:15:53.000
나는 회전율이 0.3초 정도에 변하기 시작하는 방식으로 스윙이 시작되는 것을 볼 수 있다.

00:15:53.000 --> 00:15:56.000
이것들을 함께 모으자.

00:15:56.000 --> 00:16:07.000
이 플롯이 시간에 따라 정렬됨에 따라, 800Hz 가속도계와 200Hz 장치 움직임의 정보가 접촉 시간을 계산하는 데 어떻게 도움이 되는지 느낄 수 있습니다.

00:16:07.000 --> 00:16:17.000
이제 센서 스트림에 스윙이 어떻게 나타나는지 잘 알게 되었으니, CMBatchedSensorManager를 사용하여 스트리밍 및 데이터 처리를 시작할 수 있습니다.

00:16:17.000 --> 00:16:20.000
먼저, 우리는 이 플랫폼에서 데이터를 사용할 수 있는지 확인하고 싶습니다.

00:16:20.000 --> 00:16:24.000
isAccelerometerSupported를 확인하여 그렇게 할 수 있습니다.

00:16:24.000 --> 00:16:28.000
비슷한 속성을 사용하여 장치 모션 지원을 확인할 수 있습니다.

00:16:28.000 --> 00:16:35.000
Apple Watch Series 8과 Ultra는 고속 가속도계와 장치 동작을 모두 지원합니다.

00:16:35.000 --> 00:16:41.000
이것은 운동 중심의 API이기 때문에, 데이터를 얻으려면 활성 HealthKit 운동 세션이 있어야 합니다.

00:16:41.000 --> 00:16:45.000
HealthKit 운동 세션에 들어가면, 업데이트를 받기 시작할 수 있습니다.

00:16:45.000 --> 00:16:51.000
스위프트 비동기 지원을 통해 센서 데이터 배치를 쉽게 수신하고 각 배치를 처리할 수 있습니다.

00:16:51.000 --> 00:16:58.000
루프를 종료할 조건을 평가해야 합니다. 예를 들어, 운동이 끝난 경우.

00:16:58.000 --> 00:17:04.000
모션 데이터나 지원되지 않는 플랫폼에 대한 권한이 없는 경우 오류가 발생한다는 것을 기억하세요.

00:17:04.000 --> 00:17:08.000
이제, 각 데이터 배치로 내가 하고 싶은 것을 확대해 봅시다.

00:17:08.000 --> 00:17:14.000
각 배치에 대해, 나는 데이터에 대한 알고리즘을 실행하기 위해 피드 함수를 호출할 것이다.

00:17:14.000 --> 00:17:19.000
방망이가 공과 접촉할 때, 나는 z 방향에서 뚜렷한 반응을 볼 것으로 예상한다.

00:17:19.000 --> 00:17:24.000
기억하세요, z축은 시계 크라운에 수직입니다.

00:17:24.000 --> 00:17:28.000
이 잔향은 그 영향의 좋은 근사치이다.

00:17:28.000 --> 00:17:32.000
나는 이것을 염두에 두고 각 가속도계 배치를 처리할 것이다.

00:17:32.000 --> 00:17:38.000
먼저, 나는 접촉 시 힘이 이동함에 따라 고주파 응답을 더 잘 격리하고 싶다.

00:17:38.000 --> 00:17:43.000
이것을 하기 위해, 나는 z 샘플을 fz로 필터링할 것이다.

00:17:43.000 --> 00:17:49.000
필터링된 데이터를 사용하여, 나는 필터링된 신호의 피크로 충격 지점을 근사할 것이다.

00:17:49.000 --> 00:17:54.000
그 샘플과 관련된 인덱스를 impactIndex로 추적합시다.

00:17:54.000 --> 00:18:01.000
필터링된 신호에서 가져온 임팩트 인덱스를 사용하여 원래 데이터 배치에서 임팩트 타임스탬프를 가져올 수 있습니다.

00:18:01.000 --> 00:18:11.000
이것은 접촉 시간을 계산하는 두 번째 단계로 나를 데려온다: 중력을 따라 회전을 사용하여 스윙의 시작을 감지하는 것.

00:18:11.000 --> 00:18:18.000
타자가 스윙을 할 때 Apple Watch의 경로를 상상해 보세요; 공을 만나기 위해 몸 주위의 경로를 따라갈 것입니다.

00:18:18.000 --> 00:18:27.000
그래서 나는 스윙 동안 중력을 따라 0이 아닌 회전률을 볼 수 있고, 스윙 외부의 중력을 따라 0에 가까운 회전률을 볼 것으로 예상한다.

00:18:27.000 --> 00:18:35.000
고주파 장치 모션을 로컬 버퍼로 스트리밍함으로써, 회전 속도 데이터를 사용하여 스윙이 시작된 곳을 식별할 수 있습니다.

00:18:35.000 --> 00:18:39.000
내 컴퓨팅 기능이 어떻게 생겼는지 자세히 살펴봅시다.

00:18:39.000 --> 00:18:46.000
나는 관심 지점을 조사하기 위해 로컬 버퍼를 거꾸로 반복할 것이다: 영향 타임스탬프.

00:18:46.000 --> 00:18:54.000
스윙의 시작이 영향보다 앞서야 한다는 것을 알고 있기 때문에, 버퍼에서 각 샘플을 처리하기 전에 일련의 shouldProcess 검사를 실행할 수 있습니다.

00:18:54.000 --> 00:19:01.000
여기에는 장치 모션 샘플이 충격 시간 이전인지 확인하기 위한 타임스탬프 확인이 포함될 수 있습니다.

00:19:01.000 --> 00:19:04.000
나는 또한 스윙 기간에 경계를 둘 수 있다.

00:19:04.000 --> 00:19:11.000
스윙의 시작이 공과 접촉하기 전에 일정 기간 이상 발생하지 않는다는 것은 말이 된다.

00:19:11.000 --> 00:19:23.000
일련의 초기 검사를 통과한 샘플의 경우, 각 축의 회전 속도와 중력 값의 곱을 합한 computeRotation 함수에서 중력을 따라 회전을 계산합니다.

00:19:23.000 --> 00:19:28.000
중력을 따라 회전이 계산되면, 나는 스윙의 시작을 찾기 시작할 수 있다.

00:19:28.000 --> 00:19:35.000
간단한 스윙 시작 검사는 임계값을 충족하기 위해 중력을 따라 회전 속도의 일관된 실패를 찾을 수 있다.

00:19:35.000 --> 00:19:43.000
중력을 따라 회전율이 그 임계값에 도달하는 것을 보는 것을 멈추면, 나는 그것을 스윙의 시작 시간으로 사용하고 루프에서 나갈 것이다.

00:19:43.000 --> 00:19:47.000
최종 점검으로, 나는 우리가 감지한 스윙을 검증할 것이다.

00:19:47.000 --> 00:19:55.000
여기서, 나는 스윙 동안 중력을 따라 축적된 회전을 보고 그것이 예상 임계값 내에 있는지 확인할 수 있다.

00:19:55.000 --> 00:19:59.000
그리고 그것으로, 나는 내가 감지한 시작 타임스탬프를 반환할 수 있다.

00:19:59.000 --> 00:20:05.000
이것은 나를 마지막 단계인 3단계로 데려가는데, 여기서 나는 이제 연락할 시간을 계산하는 데 필요한 모든 것을 가지고 있다.

00:20:05.000 --> 00:20:08.000
초기 피드 기능으로 돌아가자.

00:20:08.000 --> 00:20:14.000
CMBatchedSensorManager를 사용하여 가속도계와 장치 모션 데이터를 스트리밍하는 것으로 시작했습니다.

00:20:14.000 --> 00:20:20.000
나는 z 방향으로 필터링된 가속도계 데이터를 사용하여 impactTime을 감지했다.

00:20:20.000 --> 00:20:27.000
그런 다음, 나는 중력을 따라 회전 속도를 검사하여 충격 타임스탬프 근처에서 스윙의 시작을 확인했다.

00:20:27.000 --> 00:20:32.000
나는 연락 시간을 계산하기 위해 두 타임스탬프의 차이를 취할 것이다.

00:20:32.000 --> 00:20:37.000
이것은 센서 데이터를 기반으로 기능을 개발할 수 있는 방법의 간단한 예입니다.

00:20:37.000 --> 00:20:43.000
고주파 데이터 스트림의 추가 신호 정보는 다른 많은 조사의 문을 열어준다.

00:20:43.000 --> 00:20:45.000
한 번 보자.

00:20:45.000 --> 00:20:52.000
우리는 이전에 z 방향의 800Hz 가속도계 스트림으로 이 가속도계 데이터 추적을 보았다.

00:20:52.000 --> 00:20:55.000
이제, 두 번째 줄거리를 보세요.

00:20:55.000 --> 00:20:58.000
그것은 꽤 비슷해 보이지만, 완전히 같지는 않다.

00:20:58.000 --> 00:21:04.000
이것은 방망이가 실제로 공과 접촉하지 않은 놓친 스윙의 흔적이다.

00:21:04.000 --> 00:21:13.000
스윙 모션 자체는 둘 다 비슷하지만, 높은 속도의 데이터 스트림이 어떻게 우리에게 이와 같은 차이점에 대한 추가적인 통찰력을 제공하는지 알 수 있습니다.

00:21:13.000 --> 00:21:19.000
당신이 개발한 알고리즘은 이전에는 불가능했던 것들을 탐지하기 위해 이러한 차이점을 활용할 수 있습니다.

00:21:19.000 --> 00:21:25.000
요약하자면, 동일한 장치 모션 알고리즘은 몇 가지 다른 방식으로 데이터를 제공합니다.

00:21:25.000 --> 00:21:32.000
CMMotionManager는 샘플당 최대 100Hz의 데이터를 판매합니다.

00:21:32.000 --> 00:21:42.000
이것은 1초 미만의 척도에서 낮은 대기 시간 요구 사항이 있거나 운동 이외의 모션 기반 기능이 있는 경우 훌륭한 선택입니다.

00:21:42.000 --> 00:21:55.000
새로운 CMBatchedSensorManager는 배치된 일정에 따라 200Hz 장치 모션과 800Hz 가속도계의 캡으로 더 높은 속도로 데이터를 전달하여 초당 데이터 배치를 제공합니다.

00:21:55.000 --> 00:22:00.000
이것은 고속 데이터의 혜택을 받을 수 있는 운동 중심 기능에 유용하다.

00:22:00.000 --> 00:22:03.000
Apple Watch Series 8과 Ultra에서 사용할 수 있습니다.

00:22:03.000 --> 00:22:19.000
CMB CatchedSensorManager를 사용하기 위해 야구 스윙에 집중했지만, 이러한 더 높은 속도의 데이터 스트림은 특히 짧은 기간이나 충격 기반 활동 동안 모든 운동에 대한 Apple Watch의 움직임에 대한 귀중한 통찰력을 제공할 수 있습니다.

00:22:19.000 --> 00:22:25.000
그것은 CMBatchedSensorManager였고, 이것으로 CoreMotion의 새로운 기능에 대한 나의 검토를 마칩니다.

00:22:25.000 --> 00:22:30.000
우리는 헤드폰이든 Apple Watch이든 모션과 상호 작용할 수 있는 좋은 방법이 있습니다.

00:22:30.000 --> 00:22:35.000
모션 데이터를 사용하는 멋진 방법이 많이 있으며, 몇 가지 예만 다루었습니다.

00:22:35.000 --> 00:22:40.000
나는 당신이 그것들을 시험해 보고, 더 많은 정보를 위해 문서를 확인하는 것을 권장합니다.

00:22:40.000 --> 00:22:42.000
우리에게도 피드백을 꼭 주세요.

00:22:42.000 --> 00:22:53.000
모션 데이터가 이동성 측정과 같은 건강 기반 기능으로 어떻게 변환되는지에 대한 예를 보려면, WWDC 2020의 "Beyond Counting Steps" 세션을 확인하세요.

00:22:53.000 --> 00:23:02.000
CMBatchedSensorManager를 활용하기 위한 달리기 운동에 대한 자세한 내용은 "Building custom workouts with WorkoutKit"을 살펴보세요.

00:23:02.000 --> 00:23:07.000
우리는 당신이 모션 데이터를 사용하여 놀라운 새로운 경험을 만드는 방법을 보게 되어 매우 기쁩니다.

00:23:07.000 --> 23:59:59.000
봐줘서 고마워.

