WEBVTT

00:00:00.000 --> 00:00:03.000
♪ 부드러운 기악 힙합 ♪

00:00:03.000 --> 00:00:10.000
♪

00:00:10.000 --> 00:00:14.000
사리나 우: 안녕하세요! 제 이름은 사리나이고, 리얼리티킷 툴 팀의 소프트웨어 엔지니어입니다.

00:00:14.000 --> 00:00:17.000
Harjas Monga: 그리고 저는 프로파일링 도구 엔지니어인 Harjas입니다.

00:00:17.000 --> 00:00:22.000
Sarina: 오늘, Harjas와 저는 Instruments에서 RealityKit Trace 템플릿을 소개할 것입니다.

00:00:22.000 --> 00:00:26.000
이 템플릿이 공간 경험의 성능을 최적화하는 데 어떻게 도움이 될 수 있는지 보여드리겠습니다.

00:00:26.000 --> 00:00:30.000
성능은 공간 컴퓨팅의 사용자 경험에 필수적이다.

00:00:30.000 --> 00:00:43.000
공간 경험을 최적화하는 방법을 배우기 위해, 우리는 이 플랫폼에서 렌더링이 어떻게 작동하는지 간략하게 다루고, Instruments에서 RealityKit Trace 템플릿을 사용하여 프로파일링하는 방법을 보여주고, 콘텐츠를 최적화하는 데 사용할 수 있는 다른 훌륭한 도구를 간략하게 다룰 것입니다.

00:00:43.000 --> 00:00:46.000
이 플랫폼은 독특한 성능 제약을 가지고 있다.

00:00:46.000 --> 00:00:49.000
그것들을 이해하려면, 먼저 렌더링이 어떻게 작동하는지 이해해야 합니다.

00:00:49.000 --> 00:00:56.000
렌더링에는 앱 프로세스, 렌더링 서버 및 컴포지터가 포함됩니다.

00:00:56.000 --> 00:01:01.000
당신의 앱이 이러한 구성 요소와 어떻게 상호 작용하는지는 당신이 만드는 경험의 유형에 달려 있습니다.

00:01:01.000 --> 00:01:07.000
공간 앱을 위해 만들 수 있는 경험의 유형과 그것이 어떻게 렌더링되는지 살펴봅시다.

00:01:07.000 --> 00:01:11.000
플랫폼의 앱은 공유 공간 또는 전체 공간에 들어갈 수 있습니다.

00:01:11.000 --> 00:01:16.000
이것들은 렌더링 방법에 따라 고려해야 할 다른 성능 영향을 미친다.

00:01:16.000 --> 00:01:23.000
여러 앱이 나란히 실행될 때, 그것들은 모두 같은 공간에서 렌더링되며, 이는 우리가 공유 공간이라고 부르는 이유 중 하나이다.

00:01:23.000 --> 00:01:30.000
이것은 렌더링 서버가 다른 앱을 렌더링하기 위해 수행하는 작업에 의해 앱의 성능이 영향을 받을 수 있음을 의미합니다.

00:01:30.000 --> 00:01:36.000
그런 다음 렌더링 서버는 컴포지터와 함께 작동하여 최종 프레임을 생성합니다.

00:01:36.000 --> 00:01:40.000
앱이 전체 공간에 들어가면, 눈에 보이는 다른 모든 앱은 숨겨집니다.

00:01:40.000 --> 00:01:46.000
이것은 앱의 성능이 더 이상 숨겨진 앱의 렌더링 작업의 영향을 받지 않는다는 것을 의미합니다.

00:01:46.000 --> 00:01:52.000
전체 공간에 들어가는 방법에 대해 자세히 알아보려면, "SwiftUI로 창 너머로 이동" 세션을 확인하세요.

00:01:52.000 --> 00:01:57.000
방금 다룬 내용을 바탕으로, 우리는 당신의 앱을 프로파일링하는 두 가지 권장 방법이 있습니다.

00:01:57.000 --> 00:02:06.000
성능 문제를 조사하거나 시스템 전력 영향을 분석할 때마다, 앱이 시스템 성능에 미치는 영향을 이해하기 위해 앱을 개별적으로 프로파일링해야 합니다.

00:02:06.000 --> 00:02:12.000
앱이 다른 앱과 함께 작동할 것으로 예상할 때, 다른 앱으로 앱을 프로파일링해야 합니다.

00:02:12.000 --> 00:02:16.000
이것은 사용자가 당신의 앱을 어떻게 경험할지 이해하는 데 중요합니다.

00:02:16.000 --> 00:02:23.000
RealityKit 추적 템플릿을 사용하여 앱의 성능을 개별적으로 최적화하는 방법을 보여주기 위해 공간 앱을 프로파일링해 봅시다.

00:02:23.000 --> 00:02:28.000
우리는 Hello World에서 일하고 있으며, 성능 문제가 없는지 확인하고 싶습니다.

00:02:28.000 --> 00:02:32.000
사리나: 이것은 SwiftUI 뷰인 앱의 시작 화면입니다.

00:02:32.000 --> 00:02:34.000
이 보기에는 궤도에 있는 물체 버튼이 있습니다.

00:02:34.000 --> 00:02:38.000
우리는 그 버튼을 눌러 지구 궤도를 도는 물체에 대해 더 배울 수 있습니다.

00:02:38.000 --> 00:02:43.000
이 버튼은 지구를 공전하는 다른 물체의 예를 나열하는 새로운 보기를 엽니다.

00:02:43.000 --> 00:02:54.000
이 보기에는 위성, 달, 망원경을 포함한 이러한 물체의 3D 모델이 있다.

00:02:54.000 --> 00:02:57.000
이 보기에는 궤도 보기 버튼도 있습니다.

00:02:57.000 --> 00:03:05.000
우리는 버튼을 탭하여 이것을 탐험할 수 있으며, 이는 지구와 그 주위를 공전하는 위성을 보여주는 몰입형 경험을 열 것이다.

00:03:05.000 --> 00:03:11.000
우리는 이 모델에 대한 상세한 자산을 사용했고, 나는 그들이 이 앱의 성능에 영향을 미치고 있다고 의심한다.

00:03:11.000 --> 00:03:17.000
몰입형 경험에서, 우리는 위성이 지구를 공전할 때 움직이는 경로를 볼 수 있다.

00:03:17.000 --> 00:03:20.000
우리는 심지어 지구를 더 자세히 보기 위해 확장할 수도 있다.

00:03:20.000 --> 00:03:25.000
이 상호 작용은 믿을 수 없을 정도로 고르지 않아서, 나는 여기에 성능 문제가 있다고 생각한다.

00:03:25.000 --> 00:03:29.000
Harjas와 나는 RealityKit Trace 템플릿을 사용하여 그 경험을 프로파일링했다.

00:03:29.000 --> 00:03:30.000
Harjas, 우리에게 안내해 줄 수 있어?

00:03:30.000 --> 00:03:35.000
Harjas: 물론, RealityKit Trace에서 사용할 수 있는 모든 기능을 살펴봅시다.

00:03:35.000 --> 00:03:40.000
RealityKit Trace는 Instruments 15에서 새로운 템플릿으로 사용할 수 있습니다.

00:03:40.000 --> 00:03:44.000
그것은 실제 장치와 시뮬레이터를 프로파일링하는 데 사용될 수 있다.

00:03:44.000 --> 00:03:49.000
가장 정확하고 실행 가능한 정보를 얻으려면, 실제 장치를 프로파일링해야 합니다.

00:03:49.000 --> 00:03:58.000
시뮬레이터에 대해 프로파일링할 때 Mac과 온디바이스 간의 하드웨어 및 소프트웨어 차이로 인해 모든 타이밍 정보가 정확하지는 않습니다.

00:03:58.000 --> 00:04:04.000
하지만 당신은 여전히 빠른 반복과 시간에 기반하지 않은 통계를 개선하기 위해 그것을 사용할 수 있습니다.

00:04:04.000 --> 00:04:08.000
RealityKit 추적 템플릿에는 여러 도구가 포함되어 있습니다.

00:04:08.000 --> 00:04:13.000
당신이 보고 싶은 첫 번째 악기는 RealityKit 프레임 악기입니다.

00:04:13.000 --> 00:04:18.000
이 악기는 장치에 의해 렌더링되는 각 프레임을 추적한다.

00:04:18.000 --> 00:04:23.000
이 프레임을 확대하여 각 프레임이 렌더링하는 데 걸리는 시간을 확인할 수 있습니다.

00:04:23.000 --> 00:04:27.000
이를 통해 프레임의 각 단계를 렌더링하는 데 얼마나 걸렸는지 확인할 수 있습니다.

00:04:27.000 --> 00:04:33.000
이것은 렌더링 파이프라인의 어느 부분이 성능 문제를 일으킬 수 있는지에 대한 높은 수준의 아이디어를 제공합니다.

00:04:33.000 --> 00:04:40.000
원활한 사용자 경험을 달성하기 위해, 당신의 애플리케이션은 초당 90프레임을 달성할 수 있어야 합니다.

00:04:40.000 --> 00:04:43.000
그러나, OS가 항상 90fps를 목표로 하는 것은 아니다.

00:04:43.000 --> 00:04:49.000
표시되는 콘텐츠와 장치가 있는 환경에 가장 적합한 프레임 속도로 렌더링됩니다.

00:04:49.000 --> 00:04:59.000
프레임 속도가 바뀔 수 있기 때문에, 모든 프레임에는 장치가 현재 목표 프레임 속도가 무엇이든 도달할 수 있도록 렌더링을 완료해야 하는 마감일이 있습니다.

00:04:59.000 --> 00:05:12.000
프레임은 세 그룹으로 분류됩니다: 마감일 내에 잘 완료되는 프레임, 마감일 내에 거의 완료되지 않는 프레임, 마감일을 지나서 프레임이 떨어지는 프레임.

00:05:12.000 --> 00:05:17.000
이 분류는 각각 녹색, 주황색, 빨간색으로 구분된다.

00:05:17.000 --> 00:05:23.000
마감일을 지난 프레임은 사용자 경험에 부정적인 영향을 미칠 것이다.

00:05:23.000 --> 00:05:30.000
높은 수준에서 프레임을 축소하고 확인하면, 컬러 코딩을 통해 추적의 문제가 있는 부분을 빠르게 찾을 수 있습니다.

00:05:30.000 --> 00:05:37.000
따라서, 프레임 드롭이 가장 많은 영역으로 성능 조사를 좁힐 수 있습니다.

00:05:37.000 --> 00:05:49.000
개별 프레임 외에도, 이 장비는 시스템이 각 프레임을 렌더링하기 위해 CPU 또는 GPU 작업에 소비하는 평균 시간을 시각화합니다.

00:05:49.000 --> 00:05:53.000
당신이 확인하고 싶은 다음 도구는 RealityKit Metrics 도구입니다.

00:05:53.000 --> 00:05:57.000
최고 수준에서, 그 장비는 감지한 모든 병목 현상을 그린다.

00:05:57.000 --> 00:06:03.000
이러한 병목 현상은 전체 렌더링 파이프라인에서 포괄적인 타이밍 정보를 살펴음으로써 생성된다.

00:06:03.000 --> 00:06:10.000
프레임이 마감일을 초과하는 동시에 발생하는 병목 현상의 우선순위를 정하세요.

00:06:10.000 --> 00:06:18.000
아래의 세부 보기에서, 이러한 RealityKit 병목 현상이 심각성과 유형별로 요약된다는 것을 알 수 있습니다.

00:06:18.000 --> 00:06:26.000
악기가 정확히 어떤 종류의 병목 현상을 발견했는지, 그리고 그것이 당신의 전반적인 성능에 얼마나 영향을 미쳤는지 더 자세히 알아볼 수 있습니다.

00:06:26.000 --> 00:06:36.000
확장된 세부 사항 보기에서, 이 도구는 이러한 병목 현상을 더 진단하는 방법과 이를 완화하기 위해 취할 수 있는 조치에 대한 권장 사항을 제공합니다.

00:06:36.000 --> 00:06:44.000
RealityKit 메트릭 트랙을 확장하면 렌더링 파이프라인의 다양한 구성 요소에서 여러 유형의 메트릭이 표시됩니다.

00:06:44.000 --> 00:06:49.000
이러한 통계는 앱이 제시하는 장면의 전체 복잡성을 이해하는 데 도움이 될 수 있습니다.

00:06:49.000 --> 00:06:57.000
주요 지표 중 일부는 해당 지표에 대한 합리적인 기대치를 알려주는 데 도움이 되는 관련 임계값이 있을 것이다.

00:06:57.000 --> 00:07:05.000
메트릭을 사용하여 병목 현상을 진단하거나 프레임이 마감일에 도달하지 않는 이유를 더 자세히 안내하십시오.

00:07:05.000 --> 00:07:12.000
RealityKit Metrics는 애플리케이션의 RealityKit 시스템을 실행하기 위해 각 프레임에서 얼마나 많은 시간을 소비하는지 시각화할 것이다.

00:07:12.000 --> 00:07:18.000
여기에는 모든 내장 시스템과 애플리케이션이 구현할 수 있는 모든 사용자 지정 시스템이 포함됩니다.

00:07:18.000 --> 00:07:26.000
이 정보는 Time Profiler와 가장 잘 결합되어 RealityKit 시스템 코드를 최적화할 수 있습니다.

00:07:26.000 --> 00:07:38.000
마지막으로, RealityKit Metrics에 표시된 시스템 파워 임팩트 레인을 검토하여 애플리케이션이 훌륭하고 일관된 사용자 경험을 제공하기 위해 작업해야 하는 전력 봉투를 이해하십시오.

00:07:38.000 --> 00:07:43.000
이제 우리가 세계 경험을 밟는 동안 우리가 찍은 흔적을 살펴봅시다.

00:07:43.000 --> 00:07:48.000
앱의 첫 번째 장면은 SwiftUI에서 구현된 시작 화면이었다.

00:07:48.000 --> 00:07:53.000
프레임 악기에는 이 흔적을 통해 꽤 많은 프레임이 떨어집니다.

00:07:53.000 --> 00:07:58.000
이러한 떨어뜨린 프레임은 중요하지 않은 것처럼 보일 수 있지만, 사용자 경험을 손상시킬 수 있다.

00:07:58.000 --> 00:08:04.000
옵션-드래그를 사용하여 더 문제가 있는 영역 중 하나를 확대할 수 있습니다.

00:08:04.000 --> 00:08:15.000
그리고 시간 범위를 조정함으로써, 나는 이 장기 실행 프레임 동안 RealityKit Metrics 장비가 발견한 병목 현상을 확인할 수 있다.

00:08:15.000 --> 00:08:21.000
그 악기는 이 당시 가장 큰 병목 현상이 코어 애니메이션 인코딩이라는 것을 발견했다.

00:08:21.000 --> 00:08:35.000
그래서 저는 RealityKit Metrics Instrument 옆의 펼침 삼각형을 클릭하고 Core Animation이라고 표시된 트랙을 선택하여 찾을 수 있는 Core Animation 통계를 확인할 것입니다.

00:08:35.000 --> 00:08:40.000
이러한 핵심 애니메이션 지표는 이러한 프레임 드롭의 원인이 무엇인지 알려주는 데 도움이 될 수 있습니다.

00:08:40.000 --> 00:08:47.000
이러한 지표를 조사할 때, 그들 중 일부는 지표가 얼마나 심각한지에 대한 맥락을 가지고 있다는 것을 알게 될 것이다.

00:08:47.000 --> 00:08:50.000
타임라인에서, 이것은 컬러 코딩에 반영된다.

00:08:50.000 --> 00:08:55.000
이것은 이러한 주요 지표에 대한 합리적인 임계값이 무엇인지 안내하기 위한 것입니다.

00:08:55.000 --> 00:09:03.000
타임라인 시각화를 바탕으로, 애플리케이션이 오프스크린 준비 수에 대한 권장 임계값을 초과하고 있다는 것은 분명하다.

00:09:03.000 --> 00:09:13.000
하단의 요약은 여기서 준비되는 오프스크린의 평균 수가 180개라는 것을 보여주며, 이는 꽤 높은 평균이다.

00:09:13.000 --> 00:09:18.000
핵심 애니메이션 통계를 고려할 때, 명심해야 할 세 가지 유형의 작업이 있습니다.

00:09:18.000 --> 00:09:23.000
첫째, 투명성과 흐림 효과는 시스템에 매우 비용이 많이 드는 작업이다.

00:09:23.000 --> 00:09:29.000
사용자에게 가장 큰 영향을 줄 때 이러한 효과를 사용하고, 그렇지 않으면 아껴서 사용하세요.

00:09:29.000 --> 00:09:37.000
렌더링 패스의 수는 코어 애니메이션이 전체 이미지에 대해 개별적으로 렌더링해야 하는 레이어 수에 따라 결정됩니다.

00:09:37.000 --> 00:09:40.000
그리고 마지막으로, 오프스크린 패스가 있다.

00:09:40.000 --> 00:09:47.000
그래서 이름에서 알 수 있듯이, 오프스크린 패스는 디스플레이가 아닌 오프스크린으로 렌더링되는 렌더링 패스입니다.

00:09:47.000 --> 00:09:56.000
오프스크린 패스는 현재 하고 있는 일을 일시 중지하고 사용자에게 표시되지 않는 작업을 하기 위해 렌더링 패스가 필요합니다.

00:09:56.000 --> 00:10:02.000
그러나, 일반 렌더링 패스를 계속하려면 오프스크린 패스의 출력이 필요합니다.

00:10:02.000 --> 00:10:06.000
오프스크린 패스는 특히 공간 앱에 영향을 미친다.

00:10:06.000 --> 00:10:19.000
다른 앱 플랫폼과 달리, 이 플랫폼은 모든 단일 프레임이 사용자의 머리 움직임과 같은 환경 요인을 고려해야 하기 때문에 공간 앱을 지속적으로 렌더링합니다.

00:10:19.000 --> 00:10:26.000
따라서 정적 UI는 시스템의 목표 프레임 속도로 렌더링할 수 있을 만큼 충분히 효율적이어야 합니다.

00:10:26.000 --> 00:10:35.000
오프스크린 패스를 유발할 수 있는 네 가지 주요 유형의 작업이 있습니다: 그림자, 마스킹, 둥근 직사각형 및 시각 효과.

00:10:35.000 --> 00:10:43.000
오프스크린 패스에 대해 자세히 알아보려면, "렌더 단계에서 히치를 신비화하고 제거"에 대한 기술 강연을 시청하세요.

00:10:43.000 --> 00:10:50.000
오프스크린 패스가 많았기 때문에, 나는 무엇이 그들을 일으킬 수 있었는지 찾기 위해 이 보기에 대한 SwiftUI 코드를 확인할 것이다.

00:10:50.000 --> 00:10:54.000
SwiftUI 코드에서, 이 보기는 마스킹이나 시각 효과를 수행하지 않습니다.

00:10:54.000 --> 00:10:57.000
하지만 그림자가 적용되는 사례가 있다.

00:10:57.000 --> 00:11:02.000
예를 들어, SwiftUI View 항목에서 그림자는 여러 버튼에 적용되고 있다.

00:11:02.000 --> 00:11:07.000
그림자는 특히 투명성과 결합될 때 특히 비용이 많이 드는 작업이다.

00:11:07.000 --> 00:11:13.000
그림자는 유용한 UI 관용구이지만, 공간 앱의 경우 사용자에게 상당한 영향을 줄 때 사용해야 합니다.

00:11:13.000 --> 00:11:18.000
나는 이 그림자를 비활성화하고 새로운 흔적을 살펴볼 것이다.

00:11:18.000 --> 00:11:30.000
그림자가 비활성화된 상태에서 RealityKit Frames Instrument에는 프레임 문제가 거의 없으며 RealityKit Metrics는 오프스크린 패스가 4배 감소했다고 보고합니다.

00:11:30.000 --> 00:11:34.000
이제, 우리가 월드 앱에서 본 다음 장면은 궤도에 있는 물체였다.

00:11:34.000 --> 00:11:41.000
나는 최적화할 수 있는 것이 있는지 확인하기 위해 그 장면의 흔적을 열 것이다.

00:11:41.000 --> 00:11:48.000
프레임 악기에는 많은 병목 현상이 있는 흔적 전체에 걸쳐 떨어진 프레임이 산란되어 있다.

00:11:48.000 --> 00:11:55.000
RealityKit Metrics의 세부 보기는 이러한 병목 현상에 대한 요약을 제공합니다.

00:11:55.000 --> 00:12:00.000
요약하자면, 이러한 병목 현상의 대부분은 GPU 워크 스톨과 관련이 있다.

00:12:00.000 --> 00:12:08.000
가장 자주 보고되는 병목 현상 유형은 GPU 스톨이기 때문에, 나는 다시 RealityKit Metrics를 확장할 것이다.

00:12:08.000 --> 00:12:14.000
하지만 이번에는 3D 렌더링 트랙을 사용하여 조사할 것이다.

00:12:14.000 --> 00:12:21.000
나는 프레임 드롭이 많은 트레이스 영역을 선택할 것이다.

00:12:21.000 --> 00:12:31.000
이 시간 선택에서, 3D 렌더링 메트릭은 삼각형과 정점 수가 권장 임계값을 훨씬 초과한다고 보고합니다.

00:12:31.000 --> 00:12:39.000
다음으로, 나는 프레임 드롭이 거의 많지 않은 흔적 영역을 강조할 것이다.

00:12:39.000 --> 00:12:46.000
그리고 렌더링 메트릭에 따르면, 삼각형과 정점 수는 권장 임계값 내에 있다.

00:12:46.000 --> 00:12:52.000
이것은 앱이 현장에서 사용하는 자산의 수와 품질을 실제로 평가해야 한다는 것을 의미합니다.

00:12:52.000 --> 00:13:01.000
자산 렌더링을 최적화할 때, 먼저 삼각형, 정점을 확인하고 RealityKit Metrics의 3D 렌더링 그룹에서 호출을 그립니다.

00:13:01.000 --> 00:13:06.000
이러한 메트릭을 최적화하려면, 가능하면 간단한 모양 메쉬를 사용하세요.

00:13:06.000 --> 00:13:11.000
동일한 메쉬로 자산을 활용할 때 인스턴스를 활용하세요.

00:13:11.000 --> 00:13:22.000
3D 콘텐츠를 조립, 편집 및 미리 볼 수 있는 새로운 개발자 도구인 Reality Composer Pro의 통계를 사용하여 자산의 복잡성을 확인하세요.

00:13:22.000 --> 00:13:27.000
그 콘텐츠는 나중에 Xcode 프로젝트에서 직접 코드를 통해 액세스할 수 있습니다.

00:13:27.000 --> 00:13:34.000
이 도구와 훌륭한 자산을 만드는 방법에 대해 자세히 알아보려면, "Meet Reality Composer Pro" 세션을 확인하세요.

00:13:34.000 --> 00:13:41.000
나는 계속해서 내가 사용하고 있던 자산을 더 적은 다각형을 사용하고 새로운 흔적을 포착한 자산과 교환했다.

00:13:41.000 --> 00:13:47.000
이 추적에서, Frames Instrument는 모든 프레임이 마감일을 맞추고 있다고 보고한다.

00:13:47.000 --> 00:13:57.000
그리고 3D 렌더링 통계를 다시 확인하면, 삼각형과 정점 수가 상당히 감소했다고 보고합니다.

00:13:57.000 --> 00:14:02.000
이 자산들은 더 적은 다각형을 사용했지만, 경험의 질에는 손실이 없었다.

00:14:02.000 --> 00:14:06.000
다음 흔적은 우리가 지구 모델과 상호 작용할 때이다.

00:14:06.000 --> 00:14:10.000
이 장면에서, 지구의 크기를 조정하는 것은 사실 꽤 불안했다.

00:14:10.000 --> 00:14:18.000
RealityKit Metrics는 시스템 파워 임팩트 레인이 상당한 시간 동안 매우 높았다고 보고했다.

00:14:18.000 --> 00:14:25.000
이것은 애플리케이션의 일부가 매우 비효율적이며 사용자 경험에 영향을 미칠 수 있음을 나타냅니다.

00:14:25.000 --> 00:14:33.000
장치의 시스템 전력 영향을 가능한 한 많은 시간 동안 공칭 상태로 유지하면서 애플리케이션이 잘 작동하도록 목표로 해야 합니다.

00:14:33.000 --> 00:14:42.000
시스템 전력 영향을 줄이기 위해 프로파일링할 때, 항상 애플리케이션과 독립적으로 프로파일링하여 가장 실행 가능한 정보를 얻을 수 있도록 하십시오.

00:14:42.000 --> 00:14:46.000
몇 가지 접근 방식을 사용하여 시스템 전력 영향을 낮출 수 있습니다.

00:14:46.000 --> 00:14:51.000
먼저, RealityKit Metrics의 통계가 기대치 내에 있는지 확인하세요.

00:14:51.000 --> 00:15:00.000
이것들이 기대를 초과한다면, 그 장치는 부드러운 경험을 제공하기 위해 오랜 시간 동안 더 높은 전력 상태에서 작동할 수 있다.

00:15:00.000 --> 00:15:04.000
다음으로, CPU와 GPU가 무엇을 하고 있는지 확인하세요.

00:15:04.000 --> 00:15:11.000
CPU의 경우, 타임 프로파일러가 고전력 드로우 영역에서 높은 CPU 사용량을 보고하는지 확인하십시오.

00:15:11.000 --> 00:15:17.000
그리고 만약 그렇다면, Time Profiler를 사용하여 CPU 바운드 코드를 최적화하세요.

00:15:17.000 --> 00:15:20.000
GPU의 경우, 성능 상태가 있습니다.

00:15:20.000 --> 00:15:25.000
GPU가 최대 단계에 있을 때, 그것은 상당한 양의 전력을 끌어낸다.

00:15:25.000 --> 00:15:33.000
이 경우, 우리는 GPU에서 어떤 작업이 수행되고 있는지 확인하기 위해 Instruments의 Metal System Trace 템플릿을 사용해야 합니다.

00:15:33.000 --> 00:15:37.000
그렇게 하면, 우리는 무엇이 최적화될 수 있는지 이해할 수 있다.

00:15:37.000 --> 00:15:52.000
추적으로 돌아가서, Time Profiler는 이 지역에서 CPU 사용량이 평균 100%였으며, 대부분의 시간 동안 GPU 성능 상태가 최소였다고 알려줍니다.

00:15:52.000 --> 00:15:57.000
시간 프로파일러를 사용하면 높은 CPU 사용량의 원인을 확인할 수 있습니다.

00:15:57.000 --> 00:16:00.000
가장 무거운 스택 추적은 확장된 세부 사항 보기에 있다.

00:16:00.000 --> 00:16:08.000
이것은 통화 트리에서 코드의 가장 비싼 부분을 빠르게 찾을 수 있기 때문에 시간 프로파일러의 매우 유용한 기능입니다.

00:16:08.000 --> 00:16:15.000
이 프레임을 보면, Entity.makeModel이 많은 CPU 시간을 사용하고 있는 것으로 보인다.

00:16:15.000 --> 00:16:20.000
다음 프레임은 Entity.generateCollisionShapes를 호출하는 것이다.

00:16:20.000 --> 00:16:30.000
따라서, 성능 문제는 끊임없이 모델과 충돌 모양을 생성함으로써 발생하는 것으로 보이며, 이는 비용이 많이 드는 작업이다.

00:16:30.000 --> 00:16:34.000
나는 이것에 대해 무엇을 할 수 있는지 보기 위해 Xcode를 열 것이다.

00:16:34.000 --> 00:16:42.000
이것은 호출 트리가 보여준 많은 CPU 시간이 걸리는 Entity.makeModel 함수 호출입니다.

00:16:42.000 --> 00:16:49.000
이것은 makeGlobe 함수 내에서 호출되고 있다.

00:16:49.000 --> 00:16:54.000
makeGlobe 기능을 Control-클릭하여 누가 호출하는지 확인할 수 있습니다.

00:16:54.000 --> 00:16:58.000
그것은 Orbit SwiftUI 뷰 본문에서 호출되고 있다.

00:16:58.000 --> 00:17:05.000
이것은 뷰 바디를 매우 빠르게 계산해야 하기 때문에 피해야 하는 안티패턴이다.

00:17:05.000 --> 00:17:17.000
스위프트UI 뷰의 본문에서 모델 로딩이나 다른 값비싼 작업을 피해야 합니다. 뷰 상태가 바뀔 때마다 모든 값비싼 작업을 다시 계산해야 하기 때문입니다.

00:17:17.000 --> 00:17:23.000
그래서, 내가 할 일은 뷰 바디에서 이 전화를 제거하는 것이다.

00:17:23.000 --> 00:17:29.000
다음으로, ViewModel에서, 나는 지구 엔티티의 재사용 가능한 버전을 추가할 것이다.

00:17:29.000 --> 00:17:36.000
그리고 마지막으로, 나는 Orbit View에서 재사용 가능한 지구 개체를 사용할 것이다.

00:17:36.000 --> 00:17:43.000
이제, 뷰 본문이 재계산될 때, 앱은 같은 모델을 다시 로드하는 데 시간을 낭비하지 않습니다.

00:17:43.000 --> 00:17:50.000
우리가 수정한 후의 흔적을 보면, 전력 영향은 명목상의 상태로 되돌아간다.

00:17:50.000 --> 00:17:56.000
그리고 타임 프로파일러는 CPU 사용량이 100%에서 10%로 떨어졌다고 보고했다.

00:17:56.000 --> 00:18:04.000
이러한 모든 최적화 후에, 보고된 병목 현상이 거의 없으며, 거의 모든 프레임이 마감일을 맞추고 있으며, 전력은 기대 범위 내에 있다.

00:18:04.000 --> 00:18:09.000
이제, 월드 앱은 이 플랫폼에 잘 최적화된 앱이다.

00:18:09.000 --> 00:18:23.000
이제 우리는 오프스크린 패스의 수를 줄이고, 높은 다각형 자산을 합리적인 자산으로 대체하고, CPU와 전력 사용량을 낮췄기 때문에, 우리는 이 앱의 최적화된 버전을 살펴볼 것입니다.

00:18:23.000 --> 00:18:30.000
시작 화면은 멋져 보이고, 그림자가 사용자 경험에 많은 것을 추가하지 않았기 때문에, 이것은 좋은 최적화였다.

00:18:30.000 --> 00:18:33.000
다음으로, 궤도에 있는 물체를 열어 봅시다.

00:18:33.000 --> 00:18:38.000
우리가 다각형이 적은 자산을 사용하고 있음에도 불구하고, 이 모델들은 멋져 보인다.

00:18:38.000 --> 00:18:41.000
그래서 그 추가적인 세부 사항은 단지 자원을 낭비하고 있었다.

00:18:41.000 --> 00:18:47.000
그리고 마지막으로, 우리는 지구 모델을 다시 열고 크기를 조정해 볼 것이다.

00:18:47.000 --> 00:18:53.000
이제 이 상호 작용은 버터처럼 매끄럽다.

00:18:53.000 --> 00:18:59.000
그것은 RealityKit Trace를 사용하여 이 새로운 플랫폼에 맞게 앱을 최적화하는 방법에 대한 간략한 개요였습니다.

00:18:59.000 --> 00:19:03.000
이봐, 사리나, 개발자들이 사용할 수 있는 다른 도구는 뭐야?

00:19:03.000 --> 00:19:07.000
사리나: 공간 컴퓨팅을 위해 앱을 최적화하는 데 도움이 되는 몇 가지 도구가 있습니다.

00:19:07.000 --> 00:19:15.000
SwiftUI 콘텐츠를 최적화하기 위해 Instruments 앱에는 SwiftUI, Core Animation 및 중단을 분석하기 위한 도메인별 도구가 있습니다.

00:19:15.000 --> 00:19:20.000
"Analyze hangs with Instruments" 세션에서 Hangs 악기에 대해 자세히 알아볼 수 있습니다.

00:19:20.000 --> 00:19:24.000
또한 3D 자산 기반 콘텐츠를 최적화하는 데 사용할 수 있는 몇 가지 도구가 있습니다.

00:19:24.000 --> 00:19:32.000
시간 프로파일러 도구는 자산을 로드하는 데 많은 시간을 할애할 때와 같이 앱이 가장 많은 시간을 소비하는 영역을 찾는 데 도움을 줄 수 있습니다.

00:19:32.000 --> 00:19:38.000
RealityKit Metrics Instrument는 장면에 너무 많은 자산이나 너무 복잡한 자산이 있을 때 진단하는 데 도움을 줄 수 있습니다.

00:19:38.000 --> 00:19:44.000
마지막으로, Reality Composer Pro를 사용하여 장면을 조립할 때 자산의 복잡성을 확인할 수도 있습니다.

00:19:44.000 --> 00:19:49.000
리얼리티 컴포저 프로에 대해 더 알아보려면, "현실 컴포저 프로를 만나세요" 세션을 보세요.

00:19:49.000 --> 00:19:55.000
앱에서 Metal을 사용하는 경우, 가장 유용한 도구는 Instruments의 Metal System Trace 템플릿입니다.

00:19:55.000 --> 00:20:01.000
이 템플릿에는 GPU 타임라인, GPU 카운터 및 GPU 성능 상태와 같은 주요 지표가 있습니다.

00:20:01.000 --> 00:20:10.000
이 템플릿과 금속 콘텐츠 프로파일링을 위한 기타 도구에 대해 자세히 알아보려면, "금속 디버깅, 프로파일링 및 자산 생성 도구 발견" 세션을 확인하세요.

00:20:10.000 --> 00:20:13.000
요약하자면, 성능은 이 플랫폼에 필수적이다.

00:20:13.000 --> 00:20:17.000
앱은 최상의 사용자 경험을 제공하기 위해 잘 최적화되어야 합니다.

00:20:17.000 --> 00:20:22.000
RealityKit 추적 템플릿을 사용하여 앱에서 성능 병목 현상을 찾을 수 있습니다.

00:20:22.000 --> 00:20:29.000
다른 악기로 능동적으로 프로파일링하고 Reality Composer Pro에서 콘텐츠를 확인하면 성능 문제를 찾고 해결하는 데 도움이 될 수 있습니다.

00:20:29.000 --> 00:20:36.000
RealityKit Trace 템플릿을 사용하여 앱을 최적화하는 방법에 대한 자세한 내용은 개발자 문서를 확인하십시오.

00:20:36.000 --> 00:20:44.000
그리고 이 플랫폼의 성능을 더 잘 이해하려면, "공간 컴퓨팅을 위한 앱 파워와 성능 최적화" 세션을 시청하세요.

00:20:44.000 --> 00:20:48.000
흔적이 무엇이든 간에 공간 컴퓨팅 앱을 최적화하는 것을 즐기세요.

00:20:48.000 --> 00:20:49.000
Harjas: 봐줘서 고마워.

00:20:49.000 --> 23:59:59.000
♪

