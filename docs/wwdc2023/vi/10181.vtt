WEBVTT

00:00:00.000 --> 00:00:13.000
Xin chào! Tên tôi là Jackson.

00:00:13.000 --> 00:00:14.000
Và tôi là David.

00:00:14.000 --> 00:00:21.000
Trong phiên này, tôi sẽ cung cấp một số thông tin cơ bản về hình ảnh HDR và các tiêu chuẩn được xuất bản gần đây trong lĩnh vực này.

00:00:21.000 --> 00:00:27.000
Sau đó, tôi sẽ đề cập đến cách hỗ trợ những hình ảnh này trong một ứng dụng sử dụng các API mới và hiện có.

00:00:27.000 --> 00:00:37.000
David sẽ đi sâu vào chi tiết về việc xử lý đường ống hình ảnh HDR và tôi sẽ kết thúc với một số chủ đề nâng cao hơn xung quanh việc hiển thị nội dung dải động cao.

00:00:37.000 --> 00:00:40.000
Hãy đi sâu vào cách hoạt động của HDR.

00:00:40.000 --> 00:00:47.000
Trong thế giới vật chất, con người có thể cảm nhận được một phạm vi ánh sáng khổng lồ, nhờ khả năng thích nghi của mắt chúng ta.

00:00:47.000 --> 00:00:54.000
Ngược lại, một dải động tiêu chuẩn điển hình, hoặc SDR, màn hình chỉ có thể tạo ra một dải ánh sáng hạn chế.

00:00:54.000 --> 00:01:01.000
Điều này có nghĩa là khi một hình ảnh của một cảnh được chụp, phạm vi rộng của các mức ánh sáng phải được nén bằng cách nào đó vào phạm vi SDR nhỏ hơn.

00:01:01.000 --> 00:01:08.000
Với dải động cao, hoặc màn hình HDR, bạn có thể hiển thị phạm vi mức ánh sáng lớn hơn nhiều mà không cần phải nén chúng.

00:01:08.000 --> 00:01:14.000
Điều này cho phép bạn hiển thị những hình ảnh trông giống như cảnh gốc hơn và sáng hơn và sống động hơn.

00:01:14.000 --> 00:01:23.000
Chúng tôi đã có khả năng chụp dải động cao trong nhiều năm, nhưng trước đây, bạn sẽ phải lấy phạm vi chụp đó và nén nó vào phạm vi hiển thị SDR.

00:01:23.000 --> 00:01:29.000
Bây giờ, khi hiển thị trên màn hình HDR, bạn có thể hiển thị cảnh giống như ban đầu.

00:01:29.000 --> 00:01:37.000
Ví dụ, trong hình ảnh mặt trời mọc trên cảnh tuyết này, có những khu vực rơi vào một loạt các mức độ ánh sáng trong thế giới thực.

00:01:37.000 --> 00:01:41.000
Trên màn hình SDR, bạn chỉ có thể thể hiện chính xác một phần của cảnh.

00:01:41.000 --> 00:01:48.000
Với màn hình HDR, bạn có thể thể hiện nhiều cảnh hơn mà không ảnh hưởng đến độ tương phản.

00:01:48.000 --> 00:01:54.000
Vì vậy, có một màn hình với phạm vi HDR cho phép chúng tôi hiển thị các phần của cảnh sáng hơn so với SDR trắng sáng nhất.

00:01:54.000 --> 00:01:58.000
Điều này thường được gọi là khoảng không.

00:01:58.000 --> 00:02:02.000
Trong mô hình này, màu trắng tham chiếu là màu trắng sáng nhất mà màn hình SDR sẽ tạo ra.

00:02:02.000 --> 00:02:05.000
Bất cứ thứ gì trên điểm đó đều là khoảng không.

00:02:05.000 --> 00:02:15.000
Trong các cuộc nói chuyện trước đây, chúng tôi đã giới thiệu Dải động mở rộng, hoặc EDR, để tương tác với nội dung có thể được hiển thị trong khoảng không của màn hình có khả năng HDR.

00:02:15.000 --> 00:02:22.000
Trong mô hình EDR, màu trắng tham chiếu là 1.0 và đỉnh là giá trị tối đa mà màn hình có thể biểu diễn.

00:02:22.000 --> 00:02:29.000
Các API HDR mà tôi giới thiệu hôm nay sử dụng EDR để triển khai một đường ống hoàn chỉnh hơn cho nội dung dải động cao.

00:02:29.000 --> 00:02:35.000
Nếu bạn muốn tìm hiểu thêm về EDR, hãy xem bài nói chuyện "Khám phá kết xuất HDR với EDR".

00:02:35.000 --> 00:02:37.000
Đây là một ví dụ về HDR đang hoạt động.

00:02:37.000 --> 00:02:44.000
Hình ảnh SDR này của một người ngồi trước cửa sổ trông đẹp khi màu trắng của tờ giấy trong cuốn sách nằm ngay dưới màu trắng tham chiếu.

00:02:44.000 --> 00:02:49.000
Bất cứ thứ gì sáng hơn, chẳng hạn như cửa sổ, đều bị lăn ra hoặc cắt bớt.

00:02:49.000 --> 00:02:57.000
Tuy nhiên, khi bạn có thể hiển thị hình ảnh ở chế độ HDR, bạn có thể hiển thị nhiều chi tiết hơn trong các điểm nổi bật và giữ độ tương phản đáng tin cậy hơn trên toàn cảnh.

00:02:57.000 --> 00:03:01.000
Đây là lợi ích bạn có thể nhận được từ việc hỗ trợ HDR.

00:03:01.000 --> 00:03:10.000
Vậy tại sao lại hỗ trợ hình ảnh HDR? Nếu bạn đang xây dựng một ứng dụng mà nội dung do người dùng tạo hoặc cung cấp là quan trọng, hỗ trợ HDR sẽ làm cho trải nghiệm đó thậm chí còn tốt hơn.

00:03:10.000 --> 00:03:22.000
Hỗ trợ HDR có sẵn trên hầu hết các nền tảng của Apple và chúng tôi đã giới thiệu các API này để đảm bảo rằng bạn có thể tận dụng tối đa phần cứng hiển thị đáng kinh ngạc của Apple.

00:03:22.000 --> 00:03:35.000
Một lý do quan trọng khác để xem xét hỗ trợ HDR ngay bây giờ là Apple đã làm việc với Tổ chức Tiêu chuẩn Quốc tế, thông qua Ủy ban Kỹ thuật Nhiếp ảnh, để xuất bản một thông số kỹ thuật mới cho hình ảnh HDR trong năm nay.

00:03:35.000 --> 00:03:46.000
Thông số kỹ thuật này, TS22028-5, cung cấp một cấu trúc để mã hóa nội dung HDR thành các định dạng hình ảnh tĩnh hiện có mà không ảnh hưởng đến chất lượng.

00:03:46.000 --> 00:03:58.000
Tôi sẽ đề cập đến các hình ảnh HDR tuân theo thông số kỹ thuật ISO này là "ISO HDR" để tránh nhầm lẫn với các dạng HDR khác như video HDR, chụp hoặc hiển thị.

00:03:58.000 --> 00:04:08.000
Nhớ lại tỷ lệ của chúng tôi từ các hình ảnh SDR điển hình trước đó, bao gồm sRGB và Display P3, xác định màu đen và trắng là 0,2 và 80 candelas trên mỗi mét bình phương.

00:04:08.000 --> 00:04:16.000
ISO HDR, trong khi đó, định nghĩa màu đen và màu trắng tham chiếu mặc định lần lượt là 0,0005 và 203.

00:04:16.000 --> 00:04:20.000
Mọi thứ trên 203 đều là khoảng không.

00:04:20.000 --> 00:04:23.000
Vậy có gì trong những tệp hình ảnh mới này?

00:04:23.000 --> 00:04:31.000
Thông số kỹ thuật yêu cầu Hybrid Log-Gamma, HLG, hoặc Perceptual Quantizer, PQ, làm hàm truyền mã hóa.

00:04:31.000 --> 00:04:36.000
Chúng có chức năng tương tự như các đường cong gamma được sử dụng trong hình ảnh SDR.

00:04:36.000 --> 00:04:40.000
Các màu cơ bản cho các tệp ISO HDR là các màu cơ bản BT.2020.

00:04:40.000 --> 00:04:45.000
Đây là một không gian màu gam màu rộng, cho đến nay chỉ được sử dụng phổ biến trong video.

00:04:45.000 --> 00:04:50.000
Để tránh các vấn đề với dải, hình ảnh HDR được yêu cầu phải từ 10 bit trở lên cho mỗi thành phần.

00:04:50.000 --> 00:05:02.000
Điều này có nghĩa là một số định dạng, như HEIF, có thể mã hóa HDR, nhưng một số định dạng khác, như JPEG truyền thống, không thể tuân thủ 22028-5, vì chúng chỉ hỗ trợ 8 bit cho mỗi thành phần.

00:05:02.000 --> 00:05:08.000
Và đối với siêu dữ liệu bắt buộc, cả hồ sơ ICC truyền thống và thẻ CICP đều hợp lệ.

00:05:08.000 --> 00:05:12.000
Cùng với nhau, những yêu cầu này xác định các tệp ISO HDR mới.

00:05:12.000 --> 00:05:18.000
Có một số trường siêu dữ liệu tùy chọn bổ sung được liên kết với các tệp ISO HDR có thể liên quan đến bạn.

00:05:18.000 --> 00:05:25.000
Thẻ môi trường tham chiếu xác định các điều kiện môi trường xung quanh cho điều kiện tham chiếu nội dung.

00:05:25.000 --> 00:05:29.000
Độ sáng trắng khuếch tán xác định vị trí của màu trắng tham chiếu cho nội dung này.

00:05:29.000 --> 00:05:33.000
Mặc định là 203 mà tôi đã đề cập trước đó.

00:05:33.000 --> 00:05:36.000
Thẻ được giới thiệu theo cảnh có thể được sử dụng khi HLG là đường cong chuyển.

00:05:36.000 --> 00:05:40.000
Nó xác định xem nội dung hình ảnh là cảnh hay hiển thị được đề cập.

00:05:40.000 --> 00:05:44.000
Giá trị mặc định cho thẻ này được hiển thị được giới thiệu.

00:05:44.000 --> 00:05:52.000
Các thẻ âm lượng màu làm chủ và nội dung là phổ biến đối với video HDR hiện có và xác định thông tin về các dải màu có trong hình ảnh.

00:05:52.000 --> 00:05:59.000
Cuối cùng, thẻ mức độ ánh sáng nội dung cung cấp thông tin về mức độ ánh sáng của cảnh trong hình ảnh.

00:05:59.000 --> 00:06:04.000
Để biết thêm thông tin về ISO HDR, hãy xem thông số kỹ thuật trên trang web ISO.

00:06:04.000 --> 00:06:13.000
Ngoài ISO HDR, lần đầu tiên tôi rất vui được nói với bạn cách truy cập phiên bản hình ảnh tốt nhất được chụp trên iPhone.

00:06:13.000 --> 00:06:22.000
Kể từ năm 2020, hàng nghìn tỷ hình ảnh iPhone đã được chụp bằng dữ liệu bổ sung cho phép chúng tôi tái tạo lại biểu diễn HDR từ hình ảnh SDR.

00:06:22.000 --> 00:06:27.000
Tôi gọi loại HDR này là "Gain Map HDR."

00:06:27.000 --> 00:06:41.000
Hôm nay, David và tôi sẽ chỉ cho bạn các API mới để truy cập biểu diễn HDR này trong ứng dụng của bạn, cung cấp cho bạn tùy chọn hiển thị hình ảnh HDR đáng kinh ngạc từ bất kỳ thế hệ nào của Gain Map HDR đã có trong thư viện Ảnh của bạn.

00:06:41.000 --> 00:06:46.000
Bây giờ hãy nói về cách sử dụng các API mới này để kết hợp hình ảnh HDR vào một ứng dụng.

00:06:46.000 --> 00:06:51.000
Các API mà tôi sẽ chỉ cho bạn có sẵn trong SwiftUI, UIKit và AppKit.

00:06:51.000 --> 00:06:54.000
Hãy cùng xem SwiftUI và UIKit API.

00:06:54.000 --> 00:07:00.000
Trong ví dụ này, tôi có một tệp hình ảnh ISO HDR có thể truy cập qua URL và tôi muốn hiển thị nó.

00:07:00.000 --> 00:07:09.000
Tất cả những gì tôi phải làm là tạo một UIImage và cung cấp nó cho Chế độ xem hình ảnh cùng với công cụ sửa đổi DynamicRange mới được phép để kích hoạt dải động cao.

00:07:09.000 --> 00:07:12.000
Thật đơn giản.

00:07:12.000 --> 00:07:21.000
Tương tự, trong ứng dụng UIKit, bạn có thể đặt thuộc tính UIImageView mới "preferredImageDynamicRange" và thì đấy, một kết quả HDR.

00:07:21.000 --> 00:07:26.000
Các thuộc tính dải động bao gồm ba tùy chọn về cách xử lý nội dung HDR.

00:07:26.000 --> 00:07:31.000
Các thuộc tính này hoạt động trên chế độ xem SwiftUI Image, UIImage và NSImage.

00:07:31.000 --> 00:07:44.000
Tùy chọn cao cho phép hệ thống biết rằng bạn muốn hiển thị nội dung dải động cao và cho phép chúng tôi thực hiện việc ánh xạ nội dung đó lên màn hình hiện tại, bao gồm cập nhật khi trạng thái hiển thị thay đổi.

00:07:44.000 --> 00:07:50.000
Lưu ý rằng nếu hình ảnh không phải là HDR, bạn sẽ có được trải nghiệm chính xác giống như khi không có cờ dynamicRange.

00:07:50.000 --> 00:07:54.000
Bạn có thể sử dụng các tùy chọn này một cách an toàn với nội dung không phải HDR.

00:07:54.000 --> 00:08:01.000
Tùy chọn tiêu chuẩn vô hiệu hóa kết xuất dải động cao và thay vào đó hiển thị tất cả nội dung dưới dạng SDR.

00:08:01.000 --> 00:08:05.000
Điều này có nghĩa là nội dung ánh xạ giai điệu bên ngoài phạm vi SDR.

00:08:05.000 --> 00:08:11.000
Đây cũng là cách hình ảnh sẽ được hiển thị trên màn hình không có khả năng HDR.

00:08:11.000 --> 00:08:18.000
Cuối cùng, tùy chọn constrainedHigh nên được sử dụng khi bạn muốn hiển thị một số HDR nhưng không phải là toàn bộ nội dung.

00:08:18.000 --> 00:08:22.000
Tại sao bạn chỉ muốn hiển thị một số HDR, không phải tất cả?

00:08:22.000 --> 00:08:25.000
Chà, có một vài lý do có thể xảy ra.

00:08:25.000 --> 00:08:29.000
Trong ví dụ này, tôi có chế độ xem Stack chứa hình thu nhỏ của nhiều hình ảnh.

00:08:29.000 --> 00:08:32.000
Một số trong những hình ảnh này là HDR, và một số thì không.

00:08:32.000 --> 00:08:36.000
Nếu tôi sử dụng tùy chọn DynamicRange cao, đây là những gì bạn sẽ nhận được.

00:08:36.000 --> 00:08:44.000
Một số hình ảnh rất sáng và HDR, nhưng hình ảnh SDR thì không và bây giờ trông buồn tẻ, thậm chí có thể không hoạt động.

00:08:44.000 --> 00:08:47.000
Bây giờ hãy sử dụng tùy chọn constrainedHigh.

00:08:47.000 --> 00:08:53.000
Bằng cách giới hạn khoảng trống mà nội dung HDR được phép sử dụng, tôi làm cho dải phim trông nhất quán hơn nhiều.

00:08:53.000 --> 00:09:00.000
Bạn vẫn có thể phân biệt hình ảnh HDR với hình ảnh SDR, nhưng tôi không còn gặp vấn đề gì khi hình ảnh SDR trông có màu xám hoặc không hoạt động.

00:09:00.000 --> 00:09:12.000
Một lý do khác khiến bạn có thể muốn sử dụng constrainedHigh hoặc tiêu chuẩn cho một chế độ xem hình ảnh cụ thể là nội dung HDR đôi khi có thể rất sáng và bạn có thể không muốn nó thu hút sự chú ý từ các khía cạnh khác của ứng dụng.

00:09:12.000 --> 00:09:24.000
Ví dụ, đây là một hình ảnh nhỏ hơn, khi được hiển thị với HDR đầy đủ, trông giống như phần quan trọng nhất của ứng dụng nhưng đang thu hút sự chú ý khỏi các điều khiển và thông tin quan trọng.

00:09:24.000 --> 00:09:30.000
Trước khi tôi tiếp tục, bạn có thể nhận thấy rằng không có lựa chọn nào ở đây không liên quan đến việc ánh xạ tông màu cho hình ảnh.

00:09:30.000 --> 00:09:40.000
Nếu bạn đang ở trong tình huống không muốn hệ điều hành thực hiện ánh xạ âm thanh cho mình, bạn sẽ cần sử dụng API cấp thấp hơn mà tôi sẽ thảo luận sau trong phiên này.

00:09:40.000 --> 00:09:48.000
Một khía cạnh quan trọng của HDR cần lưu ý là nó yêu cầu một đường ống không kẹp hoặc làm suy giảm dữ liệu HDR.

00:09:48.000 --> 00:09:55.000
Các API mà chúng ta thảo luận hôm nay đều được hỗ trợ đầy đủ, nhưng các API bị phản đối có thể không có đường ống HDR an toàn.

00:09:55.000 --> 00:10:05.000
Ví dụ: nếu bạn đang thay đổi kích thước hình ảnh bằng cách sử dụng UIGraphicsBeginImageContextWithOptions bị phản đối, bạn sẽ mất HDR và màu gam màu rộng.

00:10:05.000 --> 00:10:10.000
Điều này nên tránh khi tạo một ứng dụng có khả năng HDR.

00:10:10.000 --> 00:10:16.000
Nếu bạn đang cố gắng tạo hình thu nhỏ, UIKit đã giới thiệu API hình thu nhỏ trên UIImage trong iOS 15.

00:10:16.000 --> 00:10:21.000
Nếu bạn không cần kiểm soát kích thước chính xác, đây là cách được đề xuất để có được hình thu nhỏ HDR.

00:10:21.000 --> 00:10:29.000
Nếu bạn cần kiểm soát nhiều hơn hoặc cần hỗ trợ trước iOS 15, UIKit cung cấp UIGraphicsImageRenderer.

00:10:29.000 --> 00:10:37.000
Bằng cách sử dụng imageRendererFormat, UIKit biết cách xây dựng trình kết xuất sẽ không làm mất thông tin HDR trong hình ảnh khi vẽ lại nó.

00:10:37.000 --> 00:10:42.000
Chúng ta hãy xem xét một cách phổ biến để đưa dữ liệu hình ảnh vào một ứng dụng.

00:10:42.000 --> 00:10:46.000
PhotoKit cung cấp giao diện cho một ứng dụng để truy cập thư viện Ảnh.

00:10:46.000 --> 00:10:52.000
Trong ứng dụng của mình, tôi đã thêm Trình chọn ảnh vào chế độ xem chính của mình, giúp dễ dàng truy cập các hình ảnh do người dùng chọn.

00:10:52.000 --> 00:11:04.000
Bởi vì PhotosPicker có thể cố gắng chuyển mã hình ảnh sang định dạng không giữ lại dữ liệu HDR, tôi sẽ sử dụng chính sách mã hóa "hiện tại" và loại khớp "hình ảnh" chung.

00:11:04.000 --> 00:11:10.000
Để biết thêm thông tin về cách hoạt động của Trình chọn ảnh, hãy xem phiên "Nhúng trình chọn ảnh vào ứng dụng của bạn".

00:11:10.000 --> 00:11:20.000
Với hình ảnh ISO HDR, tôi có thể tạo UIImage từ DataRepresentation và sử dụng nó trực tiếp với bất kỳ chế độ xem hình ảnh nào của tôi mà không cần thêm mã.

00:11:20.000 --> 00:11:28.000
Nếu tôi cũng đang hỗ trợ Gain Map HDR, tôi có thể sử dụng UIImageReader mới để có được biểu diễn HDR khi nó có sẵn.

00:11:28.000 --> 00:11:36.000
API này sẽ trả về biểu diễn HDR theo mặc định khi trên màn hình HDR và phiên bản SDR khác.

00:11:36.000 --> 00:11:42.000
Các API mà chúng ta đã thảo luận cho đến nay không phụ thuộc vào một hình ảnh là HDR hoặc biết rằng một hình ảnh là HDR.

00:11:42.000 --> 00:11:49.000
Nhớ lại rằng khi bạn cho chế độ xem hình ảnh biết rằng nó sẽ hiển thị dải động cao, không thành vấn đề nếu hình ảnh đó là HDR.

00:11:49.000 --> 00:11:55.000
Tuy nhiên, bạn có thể có một đường ống hoặc ứng dụng muốn xác định xem một hình ảnh có phải là HDR hay không.

00:11:55.000 --> 00:12:02.000
Với UIKit, bạn có thể kiểm tra thuộc tính isHighDynamicRange để xác định xem nội dung có tương thích với ISO HDR hay không.

00:12:02.000 --> 00:12:08.000
Với AppKit, CoreGraphics và CoreImage, bạn sẽ cần kiểm tra CGColorSpace của hình ảnh.

00:12:08.000 --> 00:12:17.000
Hàm CGColorSpaceUsesITUR_2100TF trả về true cho hình ảnh ISO HDR.

00:12:17.000 --> 00:12:20.000
Hình ảnh HDR có thể sử dụng nhiều khoảng không.

00:12:20.000 --> 00:12:25.000
Ví dụ, iPhone hiện tại tạo ra hình ảnh sử dụng khoảng không lên đến 8 lần.

00:12:25.000 --> 00:12:30.000
Tuy nhiên, chỉ một số màn hình có thể hiển thị HDR và không phải tất cả các màn hình HDR đều giống nhau.

00:12:30.000 --> 00:12:45.000
iPhone 14 có thể hiển thị các điểm nổi bật HDR sáng hơn tới 8 lần so với màu trắng tham chiếu, trong khi iPad Pro 12.9" và MacBook Pro có thể hiển thị tối đa 16 lần và Màn hình Pro XDR có thể hiển thị tới 400 lần.

00:12:45.000 --> 00:12:47.000
Hầu hết các màn hình Apple khác có thể hiển thị tối đa 2 lần khoảng không.

00:12:47.000 --> 00:12:51.000
Tuy nhiên, điều này có thể không đủ cho hầu hết nội dung HDR.

00:12:51.000 --> 00:12:56.000
Ngoài ra còn có các màn hình ngoài với khả năng HDR được hỗ trợ.

00:12:56.000 --> 00:13:06.000
Không có danh sách đầy đủ các màn hình này có sẵn; tuy nhiên, có một API để bạn xác định khả năng hiển thị mà ứng dụng của bạn hiện đang hiển thị.

00:13:06.000 --> 00:13:20.000
Bạn có thể truy vấn YRHeadroom tiềm năng trên iOS và iPad OS và maximumPotentialExtendedDynamicRange- ColorComponentValue trên macOS để xác định khả năng hiển thị mà ứng dụng của bạn đang xuất hiện.

00:13:20.000 --> 00:13:26.000
Trước khi chúng ta chuyển sang các chủ đề nâng cao hơn, hãy nói về thời điểm hiển thị HDR có ý nghĩa.

00:13:26.000 --> 00:13:33.000
Như tôi đã thảo luận, HDR trông rất tuyệt và bạn nên cân nhắc bao gồm hỗ trợ cho nó khi hiển thị hình ảnh là một phần chính trong ứng dụng của bạn.

00:13:33.000 --> 00:13:36.000
Nhưng đôi khi nó có thể gây mất tập trung.

00:13:36.000 --> 00:13:43.000
Vì vậy, nếu bạn không nghĩ rằng bạn cần thêm pop mà HDR có thể cung cấp cho bạn, hãy cân nhắc sử dụng các tùy chọn constrainedHigh hoặc standard.

00:13:43.000 --> 00:13:44.000
Hãy tóm tắt lại.

00:13:44.000 --> 00:13:57.000
Bây giờ bạn đã biết cách xác định hình ảnh ISO HDR, hiển thị hình ảnh HDR, truy cập ISO HDR và Gain Map HDR từ Thư viện ảnh và cách xác định xem màn hình của bạn có phải là HDR hay không.

00:13:57.000 --> 00:14:02.000
Bây giờ David sẽ hướng dẫn bạn đọc, viết và thao tác với hình ảnh HDR.

00:14:02.000 --> 00:14:29.000
Cảm ơn bạn, Jackson. Khi làm việc với hình ảnh HDR, có một vài thao tác phổ biến mà ứng dụng của bạn có thể hỗ trợ: đọc hình ảnh ISO HDR hoặc Gain Map HDR từ tệp hoặc dữ liệu vào bộ nhớ; sửa đổi hình ảnh trong bộ nhớ trong khi vẫn giữ lại nội dung HDR; chuyển đổi từ lớp hình ảnh này sang lớp hình ảnh khác mà không làm mất HDR; và cuối cùng

00:14:29.000 --> 00:14:36.000
Một đặc tính quan trọng của đường ống hình ảnh HDR chức năng là các đối tượng hình ảnh có không gian màu liên quan.

00:14:36.000 --> 00:14:42.000
Ví dụ, cả hai đối tượng CGImage và CIImage đều sử dụng API CGColorSpace cho việc này.

00:14:42.000 --> 00:14:54.000
Hình ảnh có thể có nhiều không gian màu được hỗ trợ, nhưng hình ảnh ISO HDR sẽ có CGColorSpace là ITUR 2100 HLG hoặc PQ.

00:14:54.000 --> 00:14:58.000
Với ý nghĩ đó, hãy bắt đầu với cách đọc hình ảnh ISO HDR.

00:14:58.000 --> 00:15:04.000
UIImage và NSImage hiện tự động hỗ trợ đọc hình ảnh ISO HDR.

00:15:04.000 --> 00:15:14.000
ColorSync, cơ sở hạ tầng quản lý màu sắc của Apple, sẽ xử lý các cấu hình HDR ICC và cung cấp các đối tượng hình ảnh phù hợp để hiển thị.

00:15:14.000 --> 00:15:25.000
Khi đọc hình ảnh Gain Map HDR, bạn có thể yêu cầu biểu diễn HDR bằng cách tạo cấu hình UIImageReader thích Dải động cao.

00:15:25.000 --> 00:15:29.000
Lưu ý rằng hành vi mới này chỉ ảnh hưởng đến hình ảnh Gain Map HDR.

00:15:29.000 --> 00:15:37.000
Cũng giống như với NSImage và UIImage, Core Image tự động hỗ trợ đọc các tệp ISO HDR.

00:15:37.000 --> 00:15:41.000
Tất cả những gì bạn cần làm là sử dụng CIImage contentsOfURL API.

00:15:41.000 --> 00:15:52.000
Đối tượng CIImage kết quả sẽ tự động chứa công thức chính xác để chuyển đổi từ không gian màu của tệp sang không gian làm việc phạm vi mở rộng Core Image.

00:15:52.000 --> 00:15:58.000
Bạn có thể kiểm tra công thức của đối tượng hình ảnh bằng cách sử dụng tính năng QuickLook của Xcode khi gỡ lỗi mã của bạn.

00:15:58.000 --> 00:16:07.000
Trong ví dụ này, cửa sổ bật lên QuickLook cho thấy hình ảnh được chuyển đổi từ không gian màu PQ ISO HDR.

00:16:07.000 --> 00:16:12.000
Mã của bạn cũng có thể lấy thuộc tính .colorspace để kiểm tra không gian màu của tệp.

00:16:12.000 --> 00:16:19.000
Đây có thể là không gian màu SDR, chẳng hạn như sRGB hoặc Display P3, hoặc không gian màu HDR.

00:16:19.000 --> 00:16:33.000
Nếu bạn thích sử dụng CoreGraphics API, thì bạn có thể có được hành vi tương đương bằng cách sử dụng CGImageSourceCreateImageAtIndex với khóa decodeRequest mới được đặt thành decodeToHDR.

00:16:33.000 --> 00:16:39.000
Vài phút trước, Jackson đã mô tả lý do tại sao bạn có thể muốn giới hạn hình ảnh HDR ở SDR.

00:16:39.000 --> 00:16:48.000
Tương tự, các ứng dụng sử dụng Core Image có thể muốn ghi đè hỗ trợ HDR tự động của nó để đảm bảo hình ảnh được ánh xạ tông màu sang SDR.

00:16:48.000 --> 00:16:54.000
Điều này có thể hữu ích khi bạn muốn tránh sử dụng HDR cho một số tình huống nhất định, chẳng hạn như phát hiện tính năng.

00:16:54.000 --> 00:17:03.000
Để kích hoạt điều này, bạn chỉ cần cung cấp tùy chọn toneMapHDRtoSDR khi tạo CIImage.

00:17:03.000 --> 00:17:14.000
Trong trường hợp này, đối tượng CIImage được trả về sẽ chứa một bước công thức ánh xạ tông màu nguồn HDR vào phạm vi SDR trước khi bất kỳ hoạt động nào khác được áp dụng.

00:17:14.000 --> 00:17:20.000
Lưu ý rằng tùy chọn này chỉ có hiệu ứng nếu hình ảnh có không gian màu HDR.

00:17:20.000 --> 00:17:28.000
CIImage kết quả sẽ trông giống như chỉ định rằng chế độ xem hình ảnh nên sử dụng tùy chọn dynamicRange.standard.

00:17:28.000 --> 00:17:38.000
Ngoài ra, điều này có hành vi tương đương với việc sử dụng CGImageSourceCreateImageAtIndex với decodeRequest được đặt thành decodeToSDR.

00:17:38.000 --> 00:17:50.000
Theo truyền thống, hình ảnh Gain Map HDR sẽ hiển thị dải động đầy đủ trong ứng dụng Ảnh, nhưng chỉ có biểu diễn SDR có sẵn cho các API như Core Image và ImageIO.

00:17:50.000 --> 00:18:00.000
Tôi thực sự vui mừng được mô tả API mới sẽ cho phép ứng dụng của bạn truy cập đầy đủ các hình ảnh Gain Map HDR.

00:18:00.000 --> 00:18:02.000
API siêu đơn giản để sử dụng.

00:18:02.000 --> 00:18:08.000
Chỉ cần cung cấp tùy chọn expandToHDR khi khởi tạo CIImage.

00:18:08.000 --> 00:18:19.000
Trong trường hợp này, đối tượng CIImage được trả về sẽ chứa một công thức kết hợp hình ảnh chính với bản đồ khuếch đại để tạo ra hình ảnh HDR.

00:18:19.000 --> 00:18:27.000
Thuộc tính .colorspace của hình ảnh sẽ là không gian màu HDR khi thư viện ảnh chứa dữ liệu bản đồ khuếch đại bổ sung để hỗ trợ điều này.

00:18:27.000 --> 00:18:37.000
Hành vi này tương đương với việc sử dụng CGImageSourceCreateImageAtIndex với khóa decodeRequest được đặt thành decodeToHDR.

00:18:37.000 --> 00:18:44.000
Các tùy chọn này cũng sẽ hoạt động với các tệp RAW, mà bây giờ tôi sẽ nói chi tiết hơn.

00:18:44.000 --> 00:18:52.000
Hình ảnh ProRAW từ iPhone và hình ảnh RAW từ máy ảnh là một định dạng hình ảnh linh hoạt mang lại khả năng kiểm soát sáng tạo đáng kể cho nhiếp ảnh gia.

00:18:52.000 --> 00:18:57.000
Điều này bao gồm khả năng kết xuất các phần của cảnh thành khoảng không HDR.

00:18:57.000 --> 00:19:04.000
Nhiều định dạng RAW chứa nhiều dải động và chỉ cần được xử lý thành một dạng không bị ràng buộc.

00:19:04.000 --> 00:19:06.000
Hãy để tôi mô tả cách thức hoạt động của nó.

00:19:06.000 --> 00:19:15.000
Đầu tiên, nếu ứng dụng của bạn chỉ muốn hiển thị SDR mặc định tìm kiếm tệp RAW, hãy tạo một hình ảnh từ URL như bình thường.

00:19:15.000 --> 00:19:24.000
Nhưng nếu ứng dụng của bạn chỉ muốn hiển thị giao diện kết xuất HDR mặc định, tất cả những gì bạn cần làm là thêm tùy chọn expandToHDR mới.

00:19:24.000 --> 00:19:33.000
Tuy nhiên, nếu ứng dụng của bạn muốn mở khóa toàn bộ chức năng của RAW, thì mã của bạn sẽ tạo CIRAWFilter từ URL.

00:19:33.000 --> 00:19:39.000
Nếu bạn chỉ yêu cầu bộ lọc đó cho hình ảnh đầu ra của nó, bạn sẽ nhận được một CIImage với giao diện mặc định.

00:19:39.000 --> 00:19:45.000
Nhưng ưu điểm chính của API này là bộ lọc có thể dễ dàng sửa đổi.

00:19:45.000 --> 00:19:52.000
Mỗi phiên bản CIRAWFilter có một số thuộc tính mà ứng dụng của bạn có thể thay đổi để thay đổi hình ảnh đầu ra.

00:19:52.000 --> 00:20:03.000
Các thuộc tính này được mô tả rõ ràng trong phiên "Chụp và xử lý hình ảnh ProRAW", nhưng hãy xem lại một thuộc tính đặc biệt liên quan đến cuộc thảo luận HDR này.

00:20:03.000 --> 00:20:09.000
Lượng dải động cho hình ảnh RAW có thể được điều chỉnh thành bất kỳ giá trị nào từ 0 đến 1.

00:20:09.000 --> 00:20:17.000
Thuộc tính extendedDynamicRangeAmount tương tự như các điều khiển viewDynamicRange mà Jackson đã mô tả trước đó.

00:20:17.000 --> 00:20:23.000
Giá trị mặc định của thuộc tính này là 0, điều này chỉ ra rằng hình ảnh đầu ra phải là SDR.

00:20:23.000 --> 00:20:31.000
Giá trị tối đa của thuộc tính này là 1, điều này chỉ ra rằng hình ảnh đầu ra nên sử dụng hầu hết khoảng trống có trong tệp.

00:20:31.000 --> 00:20:35.000
Điều đó kết thúc các cách khác nhau để đọc hình ảnh ISO HDR.

00:20:35.000 --> 00:20:41.000
Tiếp theo, hãy thảo luận về một số đề xuất về cách sửa đổi hình ảnh HDR.

00:20:41.000 --> 00:20:52.000
Core Image cung cấp một API mạnh mẽ và linh hoạt để làm việc với hình ảnh HDR vì nó chứa hơn 150 bộ lọc tích hợp hỗ trợ HDR.

00:20:52.000 --> 00:20:58.000
Tất cả các bộ lọc này có thể tạo hoặc xử lý hình ảnh có chứa nội dung HDR.

00:20:58.000 --> 00:21:10.000
Tất cả các bộ lọc này chỉ hoạt động vì không gian màu làm việc của Core Image không bị kẹp và tuyến tính, cho phép các giá trị RGB nằm ngoài phạm vi 0 đến 1.

00:21:10.000 --> 00:21:15.000
Khi bạn phát triển ứng dụng của mình, bạn có thể kiểm tra xem một bộ lọc nhất định có hỗ trợ HDR hay không.

00:21:15.000 --> 00:21:27.000
Để làm điều này, bạn tạo một phiên bản của bộ lọc, sau đó hỏi các thuộc tính của bộ lọc cho các danh mục của nó và sau đó kiểm tra xem mảng có chứa dải động cao của danh mục hay không.

00:21:27.000 --> 00:21:37.000
Vui lòng xem phiên "Hiển thị nội dung EDR với Core Image, Metal và SwiftUI" để biết thêm thông tin về các bộ lọc CI tích hợp và hạt nhân CI tùy chỉnh.

00:21:37.000 --> 00:21:41.000
Tiếp theo, hãy thảo luận về việc viết một hình ảnh HDR vào tệp ISO HDR.

00:21:41.000 --> 00:21:47.000
Thông thường, ứng dụng của bạn sẽ muốn ghi các đối tượng hình ảnh trong bộ nhớ vào một biểu diễn tệp mới.

00:21:47.000 --> 00:21:55.000
Theo truyền thống, sử dụng UIImage, jpegData và pngData API sẽ lưu hình ảnh SDR chính xác 8 bit.

00:21:55.000 --> 00:22:06.000
Mới trong năm nay, UIImage có thể tự động ghi hình ảnh ISO HDR bằng định dạng PNG 16 bit hoặc HEIF 10 bit khi một đối tượng chứa nội dung HDR.

00:22:06.000 --> 00:22:13.000
Nó cũng sẽ chuyển đổi sang ISO HDR nếu hình ảnh gốc là hình ảnh Gain Map HDR.

00:22:13.000 --> 00:22:26.000
Tương tự, Core Image có thể viết tệp HDR PNG khi bạn chỉ định không gian màu HDR và gọi writePNGRepresentationOfImage yêu cầu định dạng RGBA16.

00:22:26.000 --> 00:22:38.000
Hoặc Core Image có thể viết tệp HDR TIFF khi bạn chỉ định không gian màu HDR và gọi writeTIFFRepresentationOfImage yêu cầu định dạng RGBA16.

00:22:38.000 --> 00:22:45.000
Lưu ý rằng cả PNG và TIFF đều sử dụng nén không mất dữ liệu và sẽ dẫn đến kích thước tệp lớn hơn nhiều.

00:22:45.000 --> 00:22:54.000
Kết quả là, cách tốt nhất là viết một tệp HEIF bằng cách sử dụng writeHEIF10RepresentationOfImage và chỉ định một không gian màu HDR.

00:22:54.000 --> 00:23:02.000
Có thể có những trường hợp bạn cần chuyển đổi từ lớp khung này sang lớp khung khác hoặc không gian màu này sang không gian màu khác.

00:23:02.000 --> 00:23:12.000
Quá trình chuyển đổi giữa các lớp hình ảnh UIImage, CIImage, CGImage, IOSurface và CVPixelBuffer phần lớn vẫn giữ nguyên.

00:23:12.000 --> 00:23:18.000
Điều đó nói rằng, đây là một vài điều cần chú ý khi làm việc với đường ống HDR.

00:23:18.000 --> 00:23:23.000
Trước tiên hãy thảo luận về việc chuyển đổi sang các đối tượng IOSurface hoặc CVPixelBuffer.

00:23:23.000 --> 00:23:29.000
Loại hình ảnh này hữu ích vì, ví dụ, nó có thể được sử dụng làm nội dung của CALayer.

00:23:29.000 --> 00:23:34.000
Ngoài ra, nó có thể chứa các hình ảnh được lấy mẫu phụ hai mặt phẳng, rất hiệu quả về bộ nhớ.

00:23:34.000 --> 00:23:41.000
Trước khi bạn sử dụng CVPixelBuffer, hãy chắc chắn tuyên bố rằng nó có nội dung tương thích ISO HDR.

00:23:41.000 --> 00:23:48.000
Bước đầu tiên là tạo bộ đệm pixel với định dạng thích hợp như phạm vi đầy đủ hai mặt phẳng 10-bit.

00:23:48.000 --> 00:23:57.000
Trong khi bạn đang ở đó, để có hiệu suất tốt nhất, hãy đảm bảo chỉ định rằng bộ đệm phải được hỗ trợ bề mặt bằng cách cung cấp IOSurfacePropertiesKey.

00:23:57.000 --> 00:24:05.000
Tiếp theo, hãy đảm bảo thêm tệp đính kèm vào CVPixelBuffer để hệ thống biết rằng nó chứa các thuộc tính không gian màu tương thích ISO HDR.

00:24:05.000 --> 00:24:09.000
Một khi bạn có CVPixelBuffer, việc chuyển đổi nó thành CIImage là rất nhỏ.

00:24:09.000 --> 00:24:13.000
Chỉ cần gọi CIImage với CVPixelBuffer API.

00:24:13.000 --> 00:24:21.000
Và bạn có thể chuyển đổi từ CIImage sang CVPixelBuffer bằng cách sử dụng CIContext để kết xuất vào bộ đệm.

00:24:21.000 --> 00:24:29.000
Tiếp tục, có một số tình huống mà ứng dụng của bạn có thể muốn chuyển đổi giữa Core Image và CGImageRef API.

00:24:29.000 --> 00:24:43.000
Nếu bạn muốn chuyển đổi này để bảo tồn nội dung HDR, bạn nên chọn không gian màu HDR và yêu cầu định dạng pixel sâu như định dạng RGBA16 hoặc RGBAh.

00:24:43.000 --> 00:24:50.000
Và mới trong năm nay, CoreImage đã thêm định dạng RGB10, sâu nhưng sử dụng một nửa bộ nhớ.

00:24:50.000 --> 00:24:58.000
Chuyển đổi CIImage sang CGImage rất thuận tiện, vì CGImages được hỗ trợ trong nhiều API khác nhau.

00:24:58.000 --> 00:25:03.000
Nhưng hãy lưu ý rằng làm như vậy không được khuyến khích để có hiệu suất kết xuất tương tác tốt nhất của người dùng.

00:25:03.000 --> 00:25:13.000
Để có hiệu suất nhanh nhất, tốt nhất là kết xuất CoreImage trực tiếp lên MTKView hoặc thông qua PixelBuffer đến CALayer.

00:25:13.000 --> 00:25:21.000
Nói về CALayers, hãy quay lại Jackson để tìm hiểu thêm về các API cấp thấp hơn mà bạn có thể cần cho quy trình làm việc phức tạp hơn.

00:25:21.000 --> 00:25:22.000
Cảm ơn, David!

00:25:22.000 --> 00:25:30.000
CALayers là một công cụ mạnh mẽ khi bạn cần hiệu suất kết xuất tốt nhất hoặc kiểm soát nhiều hơn cách nội dung của bạn được tổng hợp vào ứng dụng của bạn.

00:25:30.000 --> 00:25:37.000
Để bật kết xuất HDR trên CALayers, bây giờ bạn có thể đặt thuộc tính wantsExtendedDynamicRangeContent.

00:25:37.000 --> 00:25:44.000
Điều này tương tự như tài sản được CAMetalLayers sử dụng để cho phép hiển thị nội dung trong khoảng không của màn hình của bạn.

00:25:44.000 --> 00:25:54.000
Sự khác biệt chính giữa hai phương pháp này là thuộc tính CALayer cho phép ánh xạ tông màu của nội dung lớp, trong khi CAMetalLayer thì không. Điều này có nghĩa là gì trong thực tế?

00:25:54.000 --> 00:25:58.000
Hình ảnh và cốt truyện này hiển thị nội dung với khoảng trống gấp 10 lần.

00:25:58.000 --> 00:26:04.000
Khi nó được hiển thị trên màn hình có sẵn ít nhất 10 lần khoảng không, cả hai lớp đều hoạt động giống hệt nhau.

00:26:04.000 --> 00:26:09.000
Bây giờ hãy giả sử rằng màn hình chỉ có khoảng không gấp 5 lần.

00:26:09.000 --> 00:26:19.000
Trong trường hợp CAMetalLayer, dữ liệu hình ảnh trên 5 lần sẽ được kẹp vào những gì màn hình có thể hiển thị, dẫn đến sự gián đoạn rõ nét trong hình ảnh.

00:26:19.000 --> 00:26:23.000
Trong trường hợp CALayer, hình ảnh sẽ được ánh xạ tông màu để tránh sự gián đoạn đó.

00:26:23.000 --> 00:26:29.000
Thuật toán ánh xạ tông màu chính xác được sử dụng phụ thuộc vào đường cong truyền được sử dụng với hình ảnh đó.

00:26:29.000 --> 00:26:36.000
Để biết thêm thông tin về các thuật toán này, bạn có thể tham khảo các tiêu chuẩn ITU cho HLG và PQ.

00:26:36.000 --> 00:26:46.000
CALayers cung cấp một cách nhanh chóng và đơn giản để đưa nội dung HDR lên màn hình, trong khi CAMetalLayers cho phép bạn tự do tạo đường ống ánh xạ tông màu của riêng mình.

00:26:46.000 --> 00:26:51.000
Để trực tiếp sử dụng CALayer để hiển thị HDR, bạn phải sử dụng một trong những lớp có sẵn này.

00:26:51.000 --> 00:27:01.000
Một đối tượng thuộc loại CGImage, CVPixelBuffer hoặc IOSurface được gắn thẻ thích hợp là ISO HDR sẽ được CALayer hiển thị và ánh xạ tông màu.

00:27:01.000 --> 00:27:09.000
Nếu bạn muốn sử dụng CALayer trực tiếp và không sử dụng một trong các lớp này, bạn có thể sử dụng một trong các phương pháp mà David đã mô tả để chuyển đổi sang chúng.

00:27:09.000 --> 00:27:14.000
Khi làm việc với quy trình làm việc HDR, điều quan trọng là phải sử dụng các định dạng pixel chính xác.

00:27:14.000 --> 00:27:18.000
Các định dạng pixel này an toàn để sử dụng khi xử lý dữ liệu HDR.

00:27:18.000 --> 00:27:22.000
Các định dạng float 16 và 32-bit luôn hỗ trợ dải động cao.

00:27:22.000 --> 00:27:29.000
Các định dạng số nguyên 16-bit cũng sẽ hoạt động để hỗ trợ nội dung HDR ở các định dạng tệp và ngữ cảnh thích hợp.

00:27:29.000 --> 00:27:34.000
Cuối cùng, có các định dạng pixel 10-bit mà bạn có thể sử dụng khi bộ nhớ và kích thước tệp quan trọng.

00:27:34.000 --> 00:27:39.000
Đây là độ sâu bit mặc định cho hầu hết các hình ảnh ISO HDR được nén.

00:27:39.000 --> 00:27:44.000
Ngoài ra còn có cờ CoreGraphics khi tạo CGImage có thể được sử dụng cho nội dung HDR.

00:27:44.000 --> 00:27:50.000
Giống như danh sách trước, bạn có thể sử dụng float, half float, 16-bit integer và 10-bit RGB.

00:27:50.000 --> 00:27:56.000
Một chủ đề quan trọng cuối cùng khi giới thiệu chức năng mới như thế này là khả năng tương thích ngược.

00:27:56.000 --> 00:28:01.000
Bạn có thể làm gì để hỗ trợ các phiên bản iOS và macOS cũ hơn khi xử lý hình ảnh HDR?

00:28:01.000 --> 00:28:09.000
Đối với hình ảnh ISO HDR, CoreImage cung cấp tùy chọn toneMapHDRtoSDR để chuyển đổi HDR sang SDR.

00:28:09.000 --> 00:28:18.000
Tương tự, khi kết xuất bằng CoreGraphics CGContext, bạn có thể nhắm mục tiêu SDR CGColorspace và hình ảnh sẽ được ánh xạ tông màu đến không gian đó.

00:28:18.000 --> 00:28:24.000
Đối với Gain Map HDR, hãy sử dụng kiểm tra phiên bản để chuyển sang cổng khi các tùy chọn expandToHDR mới được sử dụng.

00:28:24.000 --> 00:28:30.000
Khi các tùy chọn này bị bỏ qua, phiên bản SDR của tệp sẽ luôn được tải thay vì phiên bản HDR.

00:28:30.000 --> 00:28:44.000
Để kết thúc, chúng tôi đã giới thiệu các API mới để đọc, viết và hiển thị hình ảnh HDR, chỉ cho bạn cách truy cập các biểu diễn Gain Map HDR và cung cấp cho bạn các API để làm việc với một đường ống hoàn toàn có khả năng HDR.

00:28:44.000 --> 00:28:48.000
Chúng tôi nóng lòng muốn xem những điều tuyệt vời mà bạn tạo ra với HDR!

00:28:48.000 --> 00:28:50.000
Cùng nhau: Cảm ơn vì đã xem!

00:28:50.000 --> 23:59:59.000
.

