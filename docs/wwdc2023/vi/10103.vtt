WEBVTT

00:00:00.000 --> 00:00:11.000
♪ ♪

00:00:11.000 --> 00:00:12.000
Roman Efimov: Xin chào mọi người.

00:00:12.000 --> 00:00:16.000
Tên tôi là Roman Efimov, và tôi là một Kỹ sư trong nhóm Phím tắt.

00:00:16.000 --> 00:00:23.000
Hôm nay, tôi sẽ đề cập đến một số tính năng và cải tiến mới thú vị trong App Intents, giúp bạn tạo ra các ứng dụng tốt hơn nữa.

00:00:23.000 --> 00:00:26.000
Đầu tiên, tôi sẽ bắt đầu với các vật dụng.

00:00:26.000 --> 00:00:31.000
Như bạn đã biết, các tiện ích đã trở thành một phần ngày càng quan trọng trong trải nghiệm người dùng iOS.

00:00:31.000 --> 00:00:41.000
Và bây giờ, App Intents và widgets hoạt động liền mạch với nhau để cung cấp trải nghiệm mới thông qua tính tương tác và cấu hình.

00:00:41.000 --> 00:00:45.000
Tiếp theo, tôi sẽ chuyển sang những cải tiến về trải nghiệm của nhà phát triển mà chúng tôi đã thực hiện trong năm nay.

00:00:45.000 --> 00:00:53.000
Tôi sẽ đề cập đến một số cải tiến chất lượng, chẳng hạn như hỗ trợ khung, cũng như một số cải tiến gần đây đối với trích xuất tĩnh.

00:00:53.000 --> 00:00:59.000
Và cuối cùng, tôi sẽ đi sâu vào các bản cập nhật cho tích hợp ứng dụng Phím tắt với Ý định ứng dụng.

00:00:59.000 --> 00:01:05.000
Chúng tôi có một chương trình nghị sự khá dày đặc, vì vậy hãy bắt đầu với một vài cập nhật thú vị cho các tiện ích.

00:01:05.000 --> 00:01:09.000
Đầu tiên, hãy nói về cấu hình tiện ích.

00:01:09.000 --> 00:01:19.000
Khi bạn tạo một tiện ích có thể cấu hình, bạn có thể chỉ định các tùy chọn mà bạn muốn người đó có thể chọn ở mặt sau của tiện ích.

00:01:19.000 --> 00:01:31.000
Các tùy chọn này được gọi là tham số và bạn có thể xác định chúng bằng cách sử dụng cùng một hệ thống mà bạn sử dụng để thêm hỗ trợ cho Siri và Phím tắt vào ứng dụng của mình: Ý định.

00:01:31.000 --> 00:01:39.000
Giao diện người dùng cấu hình của một tiện ích hiển thị một danh sách có thứ tự các tham số được bao gồm trong Ý định tương ứng.

00:01:39.000 --> 00:01:46.000
Mỗi tham số được thêm vào Ý định được trình bày dưới dạng một hàng trong giao diện cấu hình tiện ích.

00:01:46.000 --> 00:01:53.000
Trước đây, bạn phải khai báo Ý định của mình trong Xcode bằng cách sử dụng Tệp Định nghĩa Ý định.

00:01:53.000 --> 00:02:04.000
Bây giờ trong iOS 17, chúng tôi đã làm cho việc xác định lược đồ cấu hình tiện ích của bạn trở nên đơn giản hơn bằng cách sử dụng App Intents ngay trong mã tiện ích mở rộng Widget của bạn.

00:02:04.000 --> 00:02:17.000
Để làm điều đó, trước tiên, bạn sẽ cần bắt đầu sử dụng loại AppIntentConfiguration WidgetConfiguration thay vì IntentConfiguration mà bạn có thể đã sử dụng trước đó để định cấu hình tiện ích của mình.

00:02:17.000 --> 00:02:24.000
Tiếp theo, xác định một loại mới phù hợp với giao thức WidgetConfigurationIntent.

00:02:24.000 --> 00:02:33.000
WidgetConfigurationIntent là một giao thức phụ của App Intent và bạn có thể tuân thủ nó trực tiếp trong mã Widget Extension của mình.

00:02:33.000 --> 00:02:41.000
Tôi đang làm việc trên một tiện ích cho ứng dụng lịch trình xe buýt của mình hiển thị thời gian và tuyến đường của chuyến xe buýt được lên lịch tiếp theo cho một điểm dừng cụ thể.

00:02:41.000 --> 00:02:48.000
Điều này sẽ cho phép mọi người nhanh chóng kiểm tra khi nào xe buýt tiếp theo đến mà không cần phải mở ứng dụng đầy đủ.

00:02:48.000 --> 00:02:53.000
Tôi sẽ sử dụng App Intents để cung cấp Ý định cấu hình cho tiện ích của mình.

00:02:53.000 --> 00:03:18.000
Để cho phép người dùng định cấu hình tiện ích Xe buýt Tiếp theo của tôi, tôi sẽ bắt đầu bằng cách xác định một cấu trúc phù hợp với giao thức WidgetConfigurationIntent và bao gồm các thông số sau: Điểm dừng xe buýt, được chọn từ danh sách các điểm dừng đã lưu hoặc bằng cách tìm kiếm một điểm dừng mới, Tuyến xe buýt cụ thể và Hướng di

00:03:18.000 --> 00:03:28.000
Khi tôi hoàn thành việc xác định các tham số cần thiết để định cấu hình tiện ích của mình, tôi sẽ cần cung cấp các tùy chọn động cho từng loại tham số.

00:03:28.000 --> 00:03:35.000
Trong quá khứ, việc cung cấp các tùy chọn động cho một tham số được yêu cầu tạo ra một phần mở rộng Intents riêng biệt.

00:03:35.000 --> 00:03:45.000
Với App Intents, tôi có thể triển khai các truy vấn và nhà cung cấp tùy chọn động trực tiếp trong tiện ích mở rộng tiện ích của mình, dẫn đến một dự án sạch hơn và hiệu quả hơn.

00:03:45.000 --> 00:03:52.000
Để tìm hiểu thêm về các nhà cung cấp tùy chọn động và truy vấn, tôi khuyên bạn nên xem video "Đi sâu vào ý định ứng dụng".

00:03:52.000 --> 00:03:57.000
Bây giờ, hãy nói về việc di chuyển các tiện ích hiện có của bạn từ SiriKit sang App Intents.

00:03:57.000 --> 00:04:02.000
Di chuyển cấu hình tiện ích hiện tại của bạn sang App Intents thật dễ dàng.

00:04:02.000 --> 00:04:06.000
Trên thực tế, nó có thể được thực hiện chỉ với một cú nhấp chuột trong Xcode.

00:04:06.000 --> 00:04:15.000
Di chuyển tiện ích của bạn cho phép bạn hỗ trợ cả phiên bản hệ điều hành mới nhất và các phiên bản trước đó trước khi bạn có thể chuyển đổi Tiện ích của mình sang Ý định ứng dụng.

00:04:15.000 --> 00:04:18.000
Các tiện ích được cấu hình hiện có có thể tiếp tục hoạt động.

00:04:18.000 --> 00:04:25.000
Khi bạn không còn cần hỗ trợ các phiên bản hệ điều hành trước đó, bạn có thể xóa tệp định nghĩa SiriKit Intent của mình.

00:04:25.000 --> 00:04:36.000
Để di chuyển, hãy điều hướng đến tiện ích SiriKit của bạn Cấu hình Ý định trong tệp định nghĩa Ý định của bạn và nhấp vào nút Chuyển đổi thành Ý định Ứng dụng.

00:04:36.000 --> 00:04:42.000
Xcode sẽ tạo ra mã App Intents tương đương với định nghĩa Intent cũ của bạn.

00:04:42.000 --> 00:04:53.000
Bạn sẽ cần đảm bảo rằng lược đồ vẫn giữ nguyên, có nghĩa là tất cả các tên và loại tham số Ý định Ứng dụng phải khớp với những gì bạn có trong định nghĩa Ý định của mình.

00:04:53.000 --> 00:04:56.000
Vui lòng thêm các thông số mới vào Ý định ứng dụng của bạn.

00:04:56.000 --> 00:05:01.000
Bạn có thể thêm một tham số tùy chọn hoặc thậm chí một tham số bắt buộc có giá trị mặc định.

00:05:01.000 --> 00:05:11.000
Các tiện ích hiện có, được tạo trước khi tham số được thêm vào, sẽ nhận một giá trị trống cho tham số đó hoặc một giá trị mặc định nếu bạn đã cung cấp.

00:05:11.000 --> 00:05:22.000
Nếu bạn có kế hoạch hỗ trợ mọi người trên các phiên bản iOS trước đó và để họ sử dụng tham số mới đó, thì bạn sẽ cần duy trì tệp định nghĩa SiriKit Intent của mình và thêm tham số mới đó vào đó.

00:05:22.000 --> 00:05:28.000
Bất cứ khi nào khách hàng cập nhật ứng dụng của bạn, tiện ích của họ sẽ được tự động di chuyển.

00:05:28.000 --> 00:05:35.000
Điều quan trọng là phải kiểm tra xem quá trình di chuyển diễn ra suôn sẻ hay chưa, vì ứng dụng của bạn sẽ chỉ có một cơ hội để làm như vậy.

00:05:35.000 --> 00:05:41.000
Để tìm hiểu thêm về di chuyển, tôi khuyến khích bạn xem video "Di chuyển ý định tùy chỉnh sang ý định ứng dụng".

00:05:41.000 --> 00:05:45.000
Chuyển sang tính tương tác trong các tiện ích.

00:05:45.000 --> 00:05:57.000
Các tiện ích hiện có thể phản ứng với các nút nhấn và chuyển đổi, cho phép mọi người điều chỉnh cài đặt, phát phương tiện hoặc truy cập bất kỳ chức năng quan trọng nào khác từ ứng dụng của bạn ngay từ màn hình chính của họ.

00:05:57.000 --> 00:06:02.000
Trong tiện ích Xe buýt Tiếp theo của tôi, tôi muốn làm cho các nút thời gian có thể chạm vào được.

00:06:02.000 --> 00:06:11.000
Khi mọi người nhấn vào một trong những nút này, tôi muốn đặt báo thức trong ứng dụng của mình, đảm bảo rằng họ biết chính xác khi nào nên rời đi, để họ không lỡ chuyến xe buýt của mình!

00:06:11.000 --> 00:06:13.000
Làm thế nào tôi có thể làm điều đó?

00:06:13.000 --> 00:06:21.000
Các nút và nút chuyển đổi SwiftUI đã được cập nhật để hỗ trợ Ý định ứng dụng, giúp dễ dàng thêm tính tương tác vào các tiện ích.

00:06:21.000 --> 00:06:27.000
Nếu bạn đã triển khai một App Intent trước đó, bạn sẽ ngay lập tức làm quen với nó.

00:06:27.000 --> 00:06:32.000
Đầu tiên, tôi sẽ cần xác định một cấu trúc phù hợp với giao thức App Intent.

00:06:32.000 --> 00:06:43.000
Sau đó, chú thích bất kỳ thuộc tính chính nào bằng trình bao bọc thuộc tính Tham số để cho hệ thống biết tôi cần thông tin liên quan để thực hiện hành động.

00:06:43.000 --> 00:06:48.000
Sau đó, tôi cần thực hiện phương pháp thực hiện sẽ thực hiện hành động.

00:06:48.000 --> 00:06:56.000
Cuối cùng, trong chế độ xem Widget của mình, tôi chỉ cần liên kết Ý định ứng dụng SetAlarm của mình với một nút.

00:06:56.000 --> 00:07:04.000
Tích hợp SwiftUI với App Intents không chỉ có sẵn cho các tiện ích tương tác mà còn cho các ứng dụng SwiftUI thông thường.

00:07:04.000 --> 00:07:12.000
Bằng cách hợp nhất mã vào App Intents, bạn có thể giảm dự phòng và đảm bảo hành vi nhất quán trên ứng dụng của mình.

00:07:12.000 --> 00:07:21.000
Vì App Intents vừa đóng vai trò là cấu hình vừa là nhà cung cấp các hành động tương tác, nên việc sử dụng lại mã Ý định cho Phím tắt khá dễ dàng.

00:07:21.000 --> 00:07:34.000
Ví dụ: Ý định cấu hình tiện ích ShowNextBus của tôi có thể được sử dụng như cả cấu hình tiện ích và hành động Phím tắt có thể cung cấp cho tôi thông tin cập nhật khi tôi cần.

00:07:34.000 --> 00:07:46.000
Ngoài ra, Ý định ứng dụng mà tôi đã sử dụng để thêm tính tương tác vào tiện ích của mình cũng đóng vai trò như một hành động Phím tắt tuyệt vời, cho phép mọi người đặt báo thức cho thời gian đến xe buýt ưa thích của họ.

00:07:46.000 --> 00:07:52.000
Để tìm hiểu thêm về Widget Interactivity, hãy xem "Đưa tiện ích của bạn vào cuộc sống".

00:07:52.000 --> 00:07:59.000
Hãy chuyển sang một số kỹ thuật nâng cao có thể nâng cao chức năng và thiết kế cấu hình Widget của bạn.

00:07:59.000 --> 00:08:04.000
Đầu tiên, hãy nói về những cải tiến đối với các tùy chọn và truy vấn Động.

00:08:04.000 --> 00:08:19.000
Các tùy chọn động là một giao diện để cung cấp các giá trị có sẵn cho một tham số của Ý định ứng dụng của bạn và nó có thể được triển khai bằng cách tuân thủ DynamicOptionsProvider hoặc họ giao thức EntityQuery.

00:08:19.000 --> 00:08:29.000
Trong một số trường hợp, bạn có thể muốn hiển thị các tùy chọn chỉ khả dụng khi một điều kiện nhất định dựa trên giá trị của một tham số khác được đáp ứng.

00:08:29.000 --> 00:08:39.000
Ví dụ, trong cấu hình tiện ích của tôi, tôi chỉ muốn hiển thị các tùy chọn tuyến đường có sẵn dựa trên tham số Bus Stop.

00:08:39.000 --> 00:08:46.000
Để làm điều đó, tôi có thể sử dụng một API mới trong iOS 17 được gọi là IntentParameterDependency.

00:08:46.000 --> 00:08:54.000
Nó là một trình bao bọc thuộc tính cho phép bạn truy cập các tham số từ Ý định của mình, trong DynamicOptionsProvider hoặc Query.

00:08:54.000 --> 00:09:01.000
Bạn có thể đọc các thông số này và sử dụng chúng để tạo ra các tùy chọn năng động và nhận biết ngữ cảnh hơn.

00:09:01.000 --> 00:09:07.000
Trong ví dụ của tôi, tôi trả lại các tuyến xe buýt có sẵn được lọc bởi trạm xe buýt đã chọn của người dùng.

00:09:07.000 --> 00:09:15.000
IntentParameterDependency hoạt động trong tất cả các môi trường, chẳng hạn như Widgets, Shortcuts và Focus Filters.

00:09:15.000 --> 00:09:22.000
Trong ví dụ của tôi, tôi có một cấu trúc được gọi là BusRouteQuery phù hợp với giao thức EntityQuery.

00:09:22.000 --> 00:09:30.000
Cấu trúc này có một thuộc tính được gọi là ShowNextBus, được bao bọc bằng trình bao bọc thuộc tính IntentParameterDependency.

00:09:30.000 --> 00:09:39.000
Điều này có nghĩa là truy vấn Tuyến xe buýt có sự phụ thuộc vào Ý định ứng dụng showNextBus, đặc biệt là tham số điểm dừng xe buýt.

00:09:39.000 --> 00:09:42.000
Lưu ý phương pháp Thực thể được đề xuất.

00:09:42.000 --> 00:09:45.000
Nó trả về một mảng các đối tượng Tuyến đường được đề xuất.

00:09:45.000 --> 00:09:50.000
Trước tiên, nó kiểm tra xem thuộc tính showNextBus Intent có phải là non-nil hay không.

00:09:50.000 --> 00:09:59.000
Nếu vậy, nó lọc các tuyến đường có sẵn để người đó sẽ chỉ nhìn thấy các tuyến đường phù hợp với trạm xe buýt được chỉ định của họ.

00:09:59.000 --> 00:10:04.000
IntentParameterDependency cũng có thể phụ thuộc vào nhiều tham số.

00:10:04.000 --> 00:10:12.000
Ví dụ, trong truy vấn hướng của tôi, tôi muốn dựa vào cả thông số điểm dừng xe buýt và tuyến đường để cung cấp các tùy chọn hướng.

00:10:12.000 --> 00:10:18.000
Bạn cũng có thể phụ thuộc vào nhiều Ý định ứng dụng trong cùng một truy vấn hoặc nhà cung cấp tùy chọn động.

00:10:18.000 --> 00:10:26.000
Truy vấn hướng của tôi đọc các tham số từ hai Ý định: ShowNextBus và ShowFavoriteRoute.

00:10:26.000 --> 00:10:39.000
Trình bao bọc thuộc tính IntentParameterDependency được sử dụng để chỉ định các phụ thuộc trên busStop và các tham số tuyến đường cho ShowNextBus Intent và tham số tuyến đường cho ShowFavoriteRoute Intent.

00:10:39.000 --> 00:10:50.000
Thuộc tính được tính toán tuyến đường trả về giá trị từ showNextBus hoặc showFavoriteRoute, tùy thuộc vào cái nào có sẵn.

00:10:50.000 --> 00:10:54.000
Cấu hình tiện ích thường có các tham số mảng.

00:10:54.000 --> 00:11:00.000
Ví dụ, tiện ích Tuyến đường Yêu thích của tôi có thể hiển thị lịch trình xe buýt cho các tuyến đường yêu thích của một người.

00:11:00.000 --> 00:11:06.000
Tuy nhiên, do không gian màn hình hạn chế, một người chỉ có thể chọn tối đa ba tuyến đường.

00:11:06.000 --> 00:11:09.000
Vậy làm thế nào tôi có thể tuyên bố điều đó?

00:11:09.000 --> 00:11:15.000
Mới trong iOS 17, bây giờ bạn có thể khai báo kích thước khi xác định tham số Mảng.

00:11:15.000 --> 00:11:25.000
Kích thước ở đây cũng có thể chấp nhận ánh xạ từ họ tiện ích đến kích thước mảng vì đôi khi các tiện ích lớn hơn có thể chứa nhiều mục hơn các mục nhỏ hơn.

00:11:25.000 --> 00:11:35.000
Khi tôi đã xác định Ý định Ứng dụng Cấu hình Tiện ích của mình và các tham số của nó, tôi có thể muốn xác định tham số nào trong số này được hiển thị cho người dùng và khi nào.

00:11:35.000 --> 00:11:40.000
ParameterSummary xác định biểu diễn trực quan các tham số của App Intent.

00:11:40.000 --> 00:11:47.000
Nó hỗ trợ sự xuất hiện của Ý định ứng dụng của bạn trong trình chỉnh sửa Phím tắt, Bộ lọc tiêu điểm và bây giờ trong Cấu hình tiện ích.

00:11:47.000 --> 00:11:54.000
Bạn có thể sử dụng tóm tắt tham số để xác định tham số nào được hiển thị và trong điều kiện nào.

00:11:54.000 --> 00:12:03.000
Đối với Widgets, giao diện người dùng trước tiên sẽ hiển thị các tham số trong câu Tóm tắt và sau đó là bất kỳ tham số bổ sung nào được liệt kê trong phần đóng.

00:12:03.000 --> 00:12:13.000
Ở đây, câu chứa tham số tuyến đường và việc đóng đã bao gồmWeatherInfo, vì vậy chúng được hiển thị theo thứ tự đó trong giao diện người dùng cấu hình.

00:12:13.000 --> 00:12:22.000
Mới trong iOS 17, bây giờ bạn có thể sử dụng câu lệnh When với họ tiện ích, cho phép cấu hình tiện ích của bạn thay đổi dựa trên kích thước tiện ích.

00:12:22.000 --> 00:12:32.000
Ví dụ, tôi muốn hiển thị nút chuyển đổi chỉ hiển thị thông tin thời tiết trong các tiện ích lớn, trong khi các kích thước khác sẽ không có khả năng này.

00:12:32.000 --> 00:12:39.000
Vì vậy, tôi thêm tham số includeWeatherInfo vào Tóm tắt Tham số, chỉ dành cho các tiện ích lớn.

00:12:39.000 --> 00:12:45.000
Nếu không, đối với các tiện ích nhỏ, tôi sẽ không thêm nó, vì vậy tham số bị ẩn.

00:12:45.000 --> 00:12:52.000
Bây giờ tôi đã triển khai cấu hình cho tiện ích của mình bằng cách sử dụng App Intents, làm cách nào để xác định điều gì sẽ xảy ra khi người đó nhấn vào nó?

00:12:52.000 --> 00:12:57.000
Người đó được đưa đến ứng dụng của tôi bất cứ khi nào họ nhấn vào bất kỳ đâu trong tiện ích của tôi.

00:12:57.000 --> 00:13:06.000
Tôi muốn đưa họ trực tiếp đến màn hình hiển thị thông tin về tuyến đường cụ thể mà họ đã chọn trong cấu hình tiện ích của họ.

00:13:06.000 --> 00:13:17.000
Khi một người nhấn vào tiện ích của bạn và ứng dụng của bạn được khởi chạy, bạn có thể nhận được Ý định cấu hình liên quan bằng cách gọi phương thức widgetConfigurationIntent trên hoạt động của người dùng.

00:13:17.000 --> 00:13:22.000
Khi bạn có Ý định ứng dụng, bạn có thể sử dụng nó để cập nhật giao diện người dùng ứng dụng của mình cho phù hợp.

00:13:22.000 --> 00:13:32.000
Ở đây, tôi trích xuất nội dung từ Ý định cấu hình của mình và sử dụng nó để điều hướng ứng dụng của mình đến chế độ xem điểm dừng xe buýt cụ thể cho điểm dừng và tuyến đường tương ứng.

00:13:32.000 --> 00:13:38.000
Khi bạn xây dựng một tiện ích, bạn sẽ muốn đảm bảo mọi người nhìn thấy nó vào đúng thời điểm trong Smart Stacks của họ.

00:13:38.000 --> 00:13:46.000
Để làm điều đó, bạn có thể sử dụng các API RelevantContext mới cho các đề xuất Widget trên iOS và watchOS.

00:13:46.000 --> 00:14:03.000
Lấy cảm hứng từ các API INInteraction, INDailyRoutine và INRelevantShortcut trước đây, chúng tôi đã thiết kế RelevantIntentManager và RelevantIntent mới, để thân thiện với Swift hơn và hoạt động liền mạch với App Intents.

00:14:03.000 --> 00:14:08.000
Hãy tưởng tượng một ứng dụng thể thao muốn hiển thị tiện ích của nó trong các trò chơi.

00:14:08.000 --> 00:14:14.000
Với RelevantContext API mới, bạn có thể chỉ định Ý định này và phạm vi ngày có liên quan của nó.

00:14:14.000 --> 00:14:27.000
Bằng cách cung cấp thông tin ngày liên quan này, tiện ích ứng dụng thể thao sẽ tự động được đề xuất trong Smart Stack, đảm bảo rằng mọi người có thể dễ dàng truy cập thông tin trò chơi khi nó quan trọng nhất.

00:14:27.000 --> 00:14:32.000
Các API liên quan cũng rất tuyệt vời để làm nổi bật các biến chứng đồng hồ của bạn.

00:14:32.000 --> 00:14:40.000
Để tìm hiểu thêm về khía cạnh liên quan của watchOS, hãy xem "Xây dựng các tiện ích cho Ngăn xếp thông minh trên Apple Watch."

00:14:40.000 --> 00:14:47.000
Bây giờ chúng tôi đã đề cập đến Widgets, hãy đi sâu vào những cải tiến về trải nghiệm của nhà phát triển mà chúng tôi đã thực hiện trong iOS 17 và Xcode 15.

00:14:47.000 --> 00:14:50.000
Chúng ta sẽ bắt đầu với Hỗ trợ Khung.

00:14:50.000 --> 00:15:02.000
Nếu ứng dụng của bạn yêu cầu khả năng thực hiện Ý định ứng dụng từ cả ứng dụng chính và tiện ích mở rộng Ý định ứng dụng, hiện tại bạn cần biên dịch mã Ý định ứng dụng của mình thành cả hai mục tiêu.

00:15:02.000 --> 00:15:12.000
Thật không may, cách tiếp cận này dẫn đến sự trùng lặp mã, có thể gây ra các vấn đề bảo trì và tăng khả năng xảy ra lỗi hoặc không nhất quán.

00:15:12.000 --> 00:15:20.000
Điều này cũng làm tăng kích thước nhị phân, điều này có thể tác động tiêu cực đến hiệu suất của ứng dụng và thời gian tải xuống cho mọi người.

00:15:20.000 --> 00:15:29.000
Trong iOS 17 và Xcode 15, các khung hiện có thể hiển thị Trực tiếp Ý định Ứng dụng, vì vậy không cần phải biên dịch mã của bạn hai lần nữa.

00:15:29.000 --> 00:15:35.000
Bây giờ bạn có thể sử dụng AppIntentsPackage APIs để nhập đệ quy các phụ thuộc vào ứng dụng của mình.

00:15:35.000 --> 00:15:45.000
Bằng cách tuân thủ các loại với giao thức AppIntentsPackage, cả ứng dụng và khuôn khổ của bạn đều có thể xuất lại siêu dữ liệu từ các khuôn khổ khác.

00:15:45.000 --> 00:15:50.000
Tôi sẽ sử dụng hỗ trợ khung để đơn giản hóa việc triển khai ứng dụng Bus Schedule của mình.

00:15:50.000 --> 00:15:58.000
Tôi có một khuôn khổ gọi là BusScheduleIntents cung cấp nhiều Ý định ứng dụng khác nhau để xem lịch trình xe buýt.

00:15:58.000 --> 00:16:03.000
Nó tự cung cấp để tái xuất mà không có bất kỳ sự phụ thuộc nào.

00:16:03.000 --> 00:16:11.000
Tôi có một khuôn khổ khác gọi là BusScheduleUI cung cấp các yếu tố giao diện tùy chỉnh cho ứng dụng Bus Schedule.

00:16:11.000 --> 00:16:17.000
Khung này phụ thuộc và tái xuất khung BusScheduleIntents.

00:16:17.000 --> 00:16:23.000
Cuối cùng, tôi nhập khung BusScheduleUI từ ứng dụng Bus Schedule của mình.

00:16:23.000 --> 00:16:29.000
Vì AppIntentsPackage là một giao thức, tôi có thể làm cho cấu trúc Ứng dụng SwiftUI của mình phù hợp với nó.

00:16:29.000 --> 00:16:35.000
Ứng dụng Bus Schedule chỉ cần đề cập đến sự phụ thuộc trực tiếp của nó vào khung BusScheduleUI.

00:16:35.000 --> 00:16:44.000
Bây giờ tôi có thể tạo một nút SwiftUI trong ứng dụng Bus Schedule của mình để hiển thị tuyến xe buýt yêu thích của tôi bằng cách thực hiện Ý định ứng dụng ShowSchedule.

00:16:44.000 --> 00:16:58.000
Ý định ứng dụng tương tự, ShowSchedule, cũng có sẵn cho người dùng Phím tắt, điều đó có nghĩa là họ có thể tạo Phím tắt tùy chỉnh để nhanh chóng truy cập lịch trình tuyến xe buýt yêu thích của mình mà không cần mở ứng dụng.

00:16:58.000 --> 00:17:05.000
Di chuyển Ý định Ứng dụng của bạn vào Khung giúp làm cho cơ sở mã của bạn đơn giản và hợp lý hơn.

00:17:05.000 --> 00:17:17.000
Hỗ trợ khung mới đặc biệt tuyệt vời khi xây dựng Widgets với App Intents, vì bạn có thể cần truy cập cùng một Intents từ cả ứng dụng và tiện ích mở rộng Widget của mình.

00:17:17.000 --> 00:17:27.000
Một mẹo nữa để giữ cho mã App Intents của bạn mô-đun hơn: bây giờ bạn có thể tạo AppShortcutsProvider và xác định App Shortcuts trong các tiện ích mở rộng App Intents của mình.

00:17:27.000 --> 00:17:33.000
Trước đây, bạn phải xác định các Phím tắt Ứng dụng của mình hoàn toàn trong gói ứng dụng chính của mình.

00:17:33.000 --> 00:17:38.000
Điều này có nghĩa là ứng dụng của bạn luôn được khởi chạy ở chế độ nền khi một Phím tắt Ứng dụng được chạy.

00:17:38.000 --> 00:17:43.000
Bây giờ bạn có thể xác định Phím tắt Ứng dụng của mình trong tiện ích mở rộng Ý định Ứng dụng.

00:17:43.000 --> 00:17:55.000
Điều này rất tốt cho hiệu suất vì bạn có thể tối ưu hóa tiện ích mở rộng App Intents của mình để xuất hiện nhanh hơn toàn bộ ứng dụng chính của mình và tránh đưa lên giao diện người dùng, phân tích hoặc mã không quan trọng khác.

00:17:55.000 --> 00:18:01.000
Tất cả các tính năng này đều dựa trên các cải tiến trích xuất siêu dữ liệu tĩnh mà chúng tôi đã thực hiện trong Xcode 15.

00:18:01.000 --> 00:18:08.000
Vì vậy, hãy nói về cách nội dung App Intents được trích xuất tĩnh trong khi mã của bạn được xây dựng.

00:18:08.000 --> 00:18:19.000
Trình biên dịch Swift xuất ra thông tin về các loại có sẵn trong mã của bạn, cũng như cấp loại và một số thông tin cấp giá trị từ việc triển khai App Intents của bạn.

00:18:19.000 --> 00:18:33.000
Một công cụ khác sau đó phân tích thông tin này để tạo thư mục Metadata.appIntents trong sản phẩm đã xây dựng của bạn, chứa các tệp mô tả Ý định ứng dụng, tham số, thực thể, truy vấn của bạn và hơn thế nữa.

00:18:33.000 --> 00:18:38.000
Trong Xcode 15, quá trình trích xuất tĩnh đã được cải thiện đáng kể.

00:18:38.000 --> 00:18:44.000
Bây giờ nó nhanh hơn, đáng tin cậy hơn và hoạt động trong nhiều trường hợp hơn bao giờ hết.

00:18:44.000 --> 00:19:02.000
Khi xây dựng ứng dụng của bạn với Xcode 15, nếu Xcode không thể trích xuất tĩnh thứ gì đó mà nó mong đợi, bây giờ bạn sẽ thấy thông báo lỗi trực tiếp trong trình chỉnh sửa Xcode, cùng với số dòng, vì vậy bạn biết phải đi đâu và khắc phục sự cố.

00:19:02.000 --> 00:19:11.000
Trước khi chúng ta nói về tích hợp Phím tắt, có thêm hai khả năng tuyệt vời mà chúng tôi đã thêm vào Ý định ứng dụng trong năm nay đáng được đề cập.

00:19:11.000 --> 00:19:19.000
Đầu tiên, là khả năng tiếp tục thực thi Ý định trong ứng dụng của bạn, ngay cả khi Ý định đó trước đó đã chạy trong nền.

00:19:19.000 --> 00:19:23.000
Chúng tôi gọi đây là giao thức ForegroundContinuableIntent.

00:19:23.000 --> 00:19:37.000
Ví dụ: nếu Ý định ứng dụng của tôi tìm nạp bus tiếp theo không truy xuất được lịch trình xe buýt do các thông số không hợp lệ hoặc sự cố kết nối, tôi có thể yêu cầu người đó tiếp tục trong ứng dụng để giải quyết vấn đề.

00:19:37.000 --> 00:19:43.000
Để làm điều đó, trước tiên, tôi tuân thủ Ý định ứng dụng của mình với giao thức ForegroundContinuableIntent.

00:19:43.000 --> 00:19:54.000
Giao thức ForegroundContinuableIntent được thiết kế cho Intents ban đầu bắt đầu công việc của họ ở chế độ nền nhưng có thể cần yêu cầu tiếp tục ở phía trước.

00:19:54.000 --> 00:20:00.000
Tiếp theo, tôi gọi phương thức needsToContinueInForegroundError, phương thức này trả về lỗi cho tôi.

00:20:00.000 --> 00:20:08.000
Khi tôi ném lỗi đó, hệ thống sẽ ngừng thực hiện Ý định ứng dụng và yêu cầu người dùng tiếp tục thực thi ở phía trước.

00:20:08.000 --> 00:20:18.000
Tôi cũng có thể cung cấp một đóng tiếp tục tùy chọn sẽ được thực hiện trên chuỗi chính để cập nhật trạng thái ứng dụng của tôi sau khi nó xuất hiện ở phía trước.

00:20:18.000 --> 00:20:23.000
Ở đây, tôi đang sử dụng đóng cửa này để điều hướng ứng dụng của mình đến màn hình lỗi.

00:20:23.000 --> 00:20:33.000
Sử dụng needsToContinueInForegroundError khi bạn muốn dừng việc thực thi Intent và yêu cầu hành động để tiếp tục, như trong ví dụ trước.

00:20:33.000 --> 00:20:41.000
Chúng tôi có một API khác mà bạn có thể sử dụng nếu bạn muốn tiếp tục thực hiện Ý định ứng dụng, thay vì dừng nó hoàn toàn.

00:20:41.000 --> 00:20:45.000
Đối với trường hợp đó, hãy gọi phương thức requestToContinueInForeground.

00:20:45.000 --> 00:20:56.000
Tôi có thể sử dụng cái này khi ứng dụng xe buýt phát hiện ra rằng tuyến xe buýt đang gặp sự cố bảo trì và tôi muốn trình bày giao diện người dùng tùy chỉnh trong ứng dụng của mình để chọn tuyến đường thay thế.

00:20:56.000 --> 00:21:05.000
Khi người đó đã chọn tuyến đường, tôi có thể trả lại tuyến đường đã cập nhật đó từ ứng dụng của mình và tiếp tục thực thi Ý định ứng dụng.

00:21:05.000 --> 00:21:12.000
Lần này, thay vì ném lỗi, tôi chỉ đơn giản gọi một phương thức bằng cách thử và chờ đợi.

00:21:12.000 --> 00:21:18.000
Việc đóng cửa được thông qua có thể trả về một giá trị mà tôi có thể lấy lại trong biểu diễn của mình.

00:21:18.000 --> 00:21:24.000
Điều đó cho phép tôi tiếp tục thực hiện Ý định ứng dụng sau khi nhận được đầu vào từ người dùng.

00:21:24.000 --> 00:21:32.000
Ở đây, tôi đi tuyến đường thay thế mà người dùng đã chọn và trả lại một đoạn mã hiển thị xe buýt tiếp theo cho tuyến đường đó.

00:21:32.000 --> 00:21:39.000
Tóm lại, hãy sử dụng phương pháp ném khi bạn muốn dừng hoàn toàn việc thực thi Ý định ứng dụng.

00:21:39.000 --> 00:21:50.000
Nếu không, nếu bạn muốn nhận kết quả từ người đó và sử dụng nó để hoàn thành việc thực hiện Ý định ứng dụng, hãy sử dụng requestToContinueInForeground và chờ kết quả của nó.

00:21:50.000 --> 00:21:54.000
Năm nay, chúng tôi cũng đã thêm hỗ trợ cho Apple Pay vào App Intents.

00:21:54.000 --> 00:22:00.000
Bây giờ bạn có thể bắt đầu giao dịch Apple Pay trực tiếp trong phương thức thực hiện của mình.

00:22:00.000 --> 00:22:03.000
Sử dụng Apple Pay trong hoạt động của bạn rất đơn giản.

00:22:03.000 --> 00:22:10.000
Tôi sẽ tạo một phiên bản PKPaymentRequest và định cấu hình nó với thông tin cần thiết.

00:22:10.000 --> 00:22:19.000
Tiếp theo, tôi sử dụng PKPaymentAuthorizationController để trình bày bảng thanh toán Apple Pay và xử lý ủy quyền.

00:22:19.000 --> 00:22:23.000
Một tuyên bố bảo vệ kiểm tra xem bộ điều khiển có được trình bày thành công hay không.

00:22:23.000 --> 00:22:27.000
Nếu không, tôi sẽ trả lại một hộp thoại với "Không thể xử lý thanh toán."

00:22:27.000 --> 00:22:31.000
Nếu không, thanh toán sẽ được xử lý thành công.

00:22:31.000 --> 00:22:37.000
Cuối cùng, hãy cùng tìm hiểu một vài bản cập nhật để tích hợp giữa App Intents và ứng dụng Shortcuts.

00:22:37.000 --> 00:22:42.000
Hãy bắt đầu với tất cả các vị trí khác nhau trong hệ thống nơi App Intents được tích hợp.

00:22:42.000 --> 00:22:53.000
App Intents là một cách hiện đại để xây dựng các hành động Phím tắt và Phím tắt Ứng dụng giúp bạn dễ dàng khám phá và sử dụng chức năng ứng dụng của mình với Siri và ứng dụng Phím tắt.

00:22:53.000 --> 00:22:59.000
Ngoài ra còn có tích hợp với Bộ lọc Tiêu điểm và nút Hành động trên Apple Watch Ultra.

00:22:59.000 --> 00:23:11.000
Trong iOS 17, App Intents thậm chí còn trở nên dễ tiếp cận hơn nhờ tích hợp với Hoạt động Trực tiếp Tương tác, Cấu hình Tiện ích và Tương tác, và SwiftUI.

00:23:11.000 --> 00:23:17.000
Phím tắt ứng dụng cũng đã phát triển, bao gồm hỗ trợ cho Spotlight Top Hits và Automations.

00:23:17.000 --> 00:23:23.000
Tất cả các tích hợp này có nghĩa là cùng một mã App Intents có thể được sử dụng lại theo nhiều cách khác nhau.

00:23:23.000 --> 00:23:34.000
Vì App Intents hiện được tích hợp sâu vào các thành phần hệ thống chính, điều rất quan trọng là phải đảm bảo rằng App Intents bạn tạo là những công dân tốt.

00:23:34.000 --> 00:23:42.000
Cung cấp một bản tóm tắt thông số tốt là rất quan trọng để đảm bảo rằng Ý định ứng dụng của bạn trông tuyệt vời khi chúng được hiển thị trên toàn hệ thống.

00:23:42.000 --> 00:23:50.000
Viết tóm tắt tham số của bạn để chúng đọc như một câu, với các tham số tùy chọn được giấu bên dưới nếp gấp.

00:23:50.000 --> 00:23:57.000
Hệ thống sau đó sẽ xác định biểu diễn trực quan tối ưu cho bản tóm tắt tham số của bạn dựa trên ngữ cảnh.

00:23:57.000 --> 00:24:11.000
Mặc dù Ý định ứng dụng của bạn mong muốn hoạt động tốt ở mọi nơi, nhưng có thể có những trường hợp bạn cần tạo Ý định ứng dụng để sử dụng trong ứng dụng của mình hoặc trong tiện ích tương tác và bạn muốn ẩn chúng khỏi các phần khác của hệ thống.

00:24:11.000 --> 00:24:19.000
Ví dụ, khi một App Intent gọi một hàm cục bộ trong ứng dụng của bạn mà sẽ không thực hiện một hành động Phím tắt hữu ích.

00:24:19.000 --> 00:24:24.000
Trong trường hợp đó, bạn có thể đặt thuộc tính isDiscoverable trên App Intent của mình thành sai.

00:24:24.000 --> 00:24:31.000
Tôi sẽ thêm một nút làm mới vào tiện ích Xe buýt Tiếp theo của mình để truy xuất dữ liệu mới nhất từ máy chủ.

00:24:31.000 --> 00:24:35.000
Mặc dù nó phục vụ một mục đích trong tiện ích của tôi, nhưng nó không tạo ra một hành động Phím tắt hữu ích.

00:24:35.000 --> 00:24:43.000
Vì tôi chỉ muốn Ý định ứng dụng này được sử dụng từ tiện ích tương tác của mình, tôi sẽ đặt isDiscoverable thành false cho nó.

00:24:43.000 --> 00:24:49.000
Lưu ý rằng App Intents được đánh dấu là không thể phát hiện được cũng không thể tham gia vào Phím tắt ứng dụng.

00:24:49.000 --> 00:24:54.000
Ý định trong ứng dụng của tôi hoạt động khá nhanh, nhưng không phải tất cả Ý định đều hoạt động.

00:24:54.000 --> 00:25:00.000
Năm nay, chúng tôi đã giới thiệu một cách mới để bạn cung cấp tiến độ cho các Ý định lâu dài.

00:25:00.000 --> 00:25:06.000
Để báo cáo tiến độ, chỉ cần làm cho Ý định ứng dụng của bạn phù hợp với giao thức ProgressReportingIntent.

00:25:06.000 --> 00:25:10.000
Bên trong phương thức perform(), bạn có thể truy cập đối tượng tiến trình được cung cấp.

00:25:10.000 --> 00:25:19.000
Cập nhật tiến độ bằng cách đặt totalUnitCount và tăngUnitCount đã hoàn thành khi việc thực hiện Ý định của bạn tiến triển.

00:25:19.000 --> 00:25:24.000
Ứng dụng Phím tắt bây giờ sẽ tự động hiển thị tiến trình thực hiện Ý định Ứng dụng của bạn.

00:25:24.000 --> 00:25:28.000
Thực hiện báo cáo tiến độ đặc biệt quan trọng đối với các Ý định lâu dài.

00:25:28.000 --> 00:25:37.000
Mọi người thực sự có giá trị khi có phản hồi đó, vì vậy họ biết việc thực hiện Ý định đang tiến lên phía trước và khi nào nó có thể hoàn thành.

00:25:37.000 --> 00:25:42.000
Năm nay, chúng tôi cũng đã cải thiện cách ứng dụng của bạn có thể tích hợp với các hành động Tìm kiếm.

00:25:42.000 --> 00:25:50.000
Người dùng phím tắt thích có thể tìm thấy nội dung trong ứng dụng của bạn theo các tiêu chí cụ thể, với các hành động như Tìm Ghi chú.

00:25:50.000 --> 00:25:58.000
Đầu ra của các hành động này có thể được gửi đến các hành động Phím tắt khác, như gửi email, cho phép nhiều quy trình làm việc mạnh mẽ.

00:25:58.000 --> 00:26:10.000
Trong iOS 16, bạn có thể tự động nhận được hành động Tìm kiếm cho ứng dụng của mình bằng cách triển khai EntityPropertyQuery, khai báo các tiêu chí bạn muốn người dùng có thể chỉ định.

00:26:10.000 --> 00:26:17.000
Bắt đầu với iOS 17, bây giờ bạn cũng có thể sử dụng giao thức EnumerableEntityQuery thay thế.

00:26:17.000 --> 00:26:21.000
Nó thực sự đơn giản và dễ nhận nuôi.

00:26:21.000 --> 00:26:30.000
Việc triển khai EnumerableEntityQuery đơn giản như trả về tất cả các giá trị có thể có cho thực thể của bạn trong phương thức allEntities().

00:26:30.000 --> 00:26:36.000
Các phím tắt và Ý định ứng dụng lấy nó từ đó, tự động tạo ra các hành động tìm kiếm.

00:26:36.000 --> 00:26:50.000
Sự khác biệt giữa EnumerableEntityQuery và EntityPropertyQuery là với EntityPropertyQuery, chúng tôi gửi cho bạn, nhà phát triển, tiêu chí và bạn chạy tìm kiếm thay mặt cho người dùng.

00:26:50.000 --> 00:26:54.000
Điều đó có nghĩa là bạn thường sẽ trả về một bộ kết quả giới hạn.

00:26:54.000 --> 00:27:02.000
Với EnumerableEntityQuery, bạn cung cấp cho khuôn khổ tất cả các thực thể có thể và Phím tắt thực hiện việc lọc.

00:27:02.000 --> 00:27:11.000
Bởi vì nó trả về tất cả các thực thể, EnumerableEntityQuery thực sự đơn giản để sử dụng, nhưng nó cũng được tối ưu hóa cho một số lượng nhỏ các thực thể.

00:27:11.000 --> 00:27:20.000
Nó hoạt động tốt cho các trường hợp, chẳng hạn như Nhóm Tab của Safari, nhưng không phù hợp với một số lượng lớn các thực thể, điều này sẽ là điển hình cho ứng dụng Ghi chú.

00:27:20.000 --> 00:27:24.000
Nó cũng không phù hợp với các thực thể rất lớn chiếm nhiều bộ nhớ.

00:27:24.000 --> 00:27:34.000
Trong trường hợp này, hãy sử dụng EntityPropertyQuery để bạn có thể chạy tìm kiếm ở cuối của mình, thay vì trả về tất cả các thực thể có thể cùng một lúc.

00:27:34.000 --> 00:27:38.000
Cuối cùng, tôi muốn nói với bạn về một số cập nhật cho IntentDescription.

00:27:38.000 --> 00:27:47.000
Đây là loại bạn sử dụng để điền vào giao diện người dùng Phím tắt mà mọi người nhìn thấy khi nhấn vào nút chi tiết để biết thêm thông tin về hành động của bạn.

00:27:47.000 --> 00:27:52.000
IntentDescription bao gồm văn bản mô tả, tên danh mục và từ khóa tìm kiếm.

00:27:52.000 --> 00:28:04.000
Trong iOS 17, loại Mô tả Ý định đã được cập nhật với một thuộc tính mới được gọi là resultValueName, vì vậy bạn có thể cung cấp tên mô tả nhiều hơn cho đầu ra của hành động của mình.

00:28:04.000 --> 00:28:13.000
Ở đây, "Thêm lời nhắc" cung cấp resultValueName của "New Reminder" cho lời nhắc mà nó đã tạo và trả về.

00:28:13.000 --> 00:28:22.000
Khi hành động "Thêm lời nhắc" ở đây được kết nối với Hành động Hiển thị kết quả, tham số trong hành động Hiển thị kết quả hiển thị tên đó: "Nhắc nhở mới".

00:28:22.000 --> 00:28:27.000
Để cung cấp resultValueName, chỉ cần sử dụng trình khởi tạo mới trên IntentDescription.

00:28:27.000 --> 00:28:40.000
Bắt đầu với iOS 17, bạn cũng có thể bao gồm mô tả Ý định cho các hành động Tìm của mình được tạo bằng cách sử dụng các giao thức EntityPropertyQuery hoặc EnumerableEntityQuery.

00:28:40.000 --> 00:28:46.000
Để làm điều này, chỉ cần áp dụng thuộc tính findIntentDescription trong các loại truy vấn của bạn.

00:28:46.000 --> 00:28:57.000
Nếu bạn phân loại hành động của mình bằng categoryName, điều này sẽ cho phép bạn hiển thị các hành động Tìm kiếm được tạo trong danh mục mong muốn của bạn trong danh sách các hành động được ứng dụng của bạn hỗ trợ.

00:28:57.000 --> 00:29:05.000
Tóm lại, Ý định ứng dụng là một cách tuyệt vời để hiển thị chức năng của ứng dụng của bạn cho hệ thống và cho người dùng của bạn.

00:29:05.000 --> 00:29:16.000
Để tìm hiểu thêm về cách bạn có thể biến Ý định ứng dụng của mình thành Phím tắt ứng dụng để mọi người có thể sử dụng chúng ngay lập tức, tôi khuyên bạn nên xem phiên "Điểm sáng ứng dụng của bạn với Phím tắt ứng dụng".

00:29:16.000 --> 00:29:28.000
Năm nay, App Intents cho phép bạn xây dựng các tiện ích tương tác và hoạt động trực tiếp, có thể định cấu hình, đồng thời cung cấp trải nghiệm nhà phát triển mượt mà hơn, với sự tích hợp sâu hơn vào ứng dụng Phím tắt.

00:29:28.000 --> 00:29:34.000
Tôi thực sự hào hứng khi thấy các ứng dụng của bạn có thể tận dụng các công nghệ App Intents mới như thế nào để gây bất ngờ và thích thú.

00:29:34.000 --> 00:29:36.000
Cảm ơn vì đã tham gia cùng tôi.

00:29:36.000 --> 23:59:59.000
.

