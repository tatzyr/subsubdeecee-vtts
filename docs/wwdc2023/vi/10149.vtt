WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:12.000
Philippe: Xin chào, tên tôi là Philippe.

00:00:12.000 --> 00:00:18.000
Tôi thực sự vui mừng được giới thiệu một tính năng mới kỳ diệu trong Swift: Quan sát.

00:00:18.000 --> 00:00:28.000
Tính năng này cho phép bạn xác định các mô hình của mình bằng cú pháp Swift tiêu chuẩn và sử dụng các loại đó để giao diện người dùng phản hồi các thay đổi đối với mô hình đó.

00:00:28.000 --> 00:00:33.000
Điều này làm cho việc phát triển với SwiftUI trở nên liền mạch và trực quan.

00:00:33.000 --> 00:00:51.000
Hôm nay chúng tôi sẽ đề cập đến một vài chủ đề: Tổng quan về Quan sát là gì, một bộ quy tắc tiện dụng về thời điểm sử dụng trình bao bọc thuộc tính từ SwiftUI, sau đó chúng tôi sẽ đề cập đến một số cách sử dụng nâng cao hơn của có thể quan sát được.

00:00:51.000 --> 00:01:02.000
Và chúng ta sẽ kết thúc với một số ví dụ về cách cập nhật mã từ việc sử dụng ObservableObject lên macro @Observable mới.

00:01:02.000 --> 00:01:07.000
Quan sát là một tính năng Swift mới để theo dõi các thay đổi đối với các thuộc tính.

00:01:07.000 --> 00:01:13.000
Nó hoạt động với các loại Swift bình thường và biến đổi chúng với phép thuật của macro.

00:01:13.000 --> 00:01:21.000
Chúng tôi thường viết các kiểu mô hình dữ liệu và chúng có một số thuộc tính mà cuối cùng, chúng tôi sẽ muốn sử dụng trong SwiftUI.

00:01:21.000 --> 00:01:31.000
Điều gì sẽ xảy ra nếu tôi nói với bạn rằng việc thêm @Observable là tất cả những gì bạn cần để làm cho giao diện người dùng phản hồi với những thay đổi trong mô hình dữ liệu của bạn?

00:01:31.000 --> 00:01:37.000
Mới trong Swift 5.9 bạn có thể tạo ra các mô hình đơn giản hơn bao giờ hết.

00:01:37.000 --> 00:01:40.000
Cái này sử dụng hệ thống macro mới trong Swift.

00:01:40.000 --> 00:01:51.000
"@Observable" yêu cầu trình biên dịch Swift chuyển đổi mã của bạn từ những gì bạn đã viết sang một dạng mở rộng giúp loại có thể được quan sát.

00:01:51.000 --> 00:01:56.000
Bạn có thể sử dụng các loại có thể quan sát được để cung cấp năng lượng cho chế độ xem SwiftUI của mình.

00:01:56.000 --> 00:02:01.000
Và điều tuyệt vời là họ không cần bất kỳ loại trình bao bọc tài sản nào để hoạt động.

00:02:01.000 --> 00:02:07.000
Tôi có một số mẫu ngon từ ứng dụng xe bán đồ ăn bánh rán của chúng tôi, vì vậy chúng ta hãy đi sâu vào ngay.

00:02:07.000 --> 00:02:11.000
Ở đây chúng tôi có một cái nhìn đơn giản cho thấy bánh rán.

00:02:11.000 --> 00:02:18.000
SwiftUI biết rằng mô hình truy cập các thuộc tính cụ thể khi thực hiện cuộc gọi nội dung.

00:02:18.000 --> 00:02:26.000
Trong trường hợp này, nó có thể phát hiện ra rằng thuộc tính 'donuts' được truy cập khi thực hiện phần thân của chế độ xem menu bánh rán.

00:02:26.000 --> 00:02:33.000
Khi nội dung được thực thi, SwiftUI theo dõi tất cả quyền truy cập vào các thuộc tính được sử dụng từ các loại 'Có thể quan sát được'.

00:02:33.000 --> 00:02:44.000
Sau đó, nó lấy thông tin theo dõi đó và sử dụng nó để xác định khi nào thay đổi tiếp theo đối với bất kỳ thuộc tính nào trên các trường hợp cụ thể đó sẽ thay đổi.

00:02:44.000 --> 00:02:56.000
Ở đây, nếu chúng ta thay đổi mảng bánh rán bằng cách nhấp vào nút thêm bánh rán, nó sẽ làm mất hiệu lực chế độ xem menu bánh rán và giao diện người dùng được cập nhật tương ứng.

00:02:56.000 --> 00:03:08.000
Điều gọn gàng là nếu, giả sử một thứ tự được thêm vào, chế độ xem sẽ không bị vô hiệu vì thuộc tính đó không phải là một phần của các thuộc tính được theo dõi mà nó đã xác định khi thực hiện nội dung của chế độ xem.

00:03:08.000 --> 00:03:12.000
Hãy trình bày tiếp theo những gì xảy ra khi bạn sử dụng một thuộc tính được tính toán.

00:03:12.000 --> 00:03:16.000
Thêm vào một thuộc tính được tính toán tuân theo các quy tắc tương tự như trước đây.

00:03:16.000 --> 00:03:22.000
Khi một thuộc tính được sử dụng thay đổi, giao diện người dùng sẽ cập nhật.

00:03:22.000 --> 00:03:29.000
Trong nội dung mới được thêm vào, orderCount của mô hình được gọi, truy cập thuộc tính đơn hàng.

00:03:29.000 --> 00:03:41.000
Vì vậy, điều đó có nghĩa là, trong ví dụ này nếu đơn đặt hàng thay đổi, văn bản đó sẽ được cập nhật vì orderCount truy cập thuộc tính của đơn đặt hàng.

00:03:41.000 --> 00:03:47.000
Sử dụng macro "@Observable" sẽ mở rộng các loại của bạn để chúng có thể hỗ trợ Quan sát.

00:03:47.000 --> 00:03:56.000
Điều này cho phép SwiftUI theo dõi quyền truy cập vào các thuộc tính đó và quan sát khi nào thuộc tính tiếp theo sẽ thay đổi khỏi Quan sát đó.

00:03:56.000 --> 00:04:10.000
Theo dõi những thứ như vậy cho phép giao diện người dùng của bạn chỉ tính toán lại nội dung của các chế độ xem khi các thuộc tính cụ thể đó thay đổi, điều mà chúng tôi đã thấy một số cải tiến hiệu suất thực sự tuyệt vời từ đó.

00:04:10.000 --> 00:04:19.000
Nếu bạn muốn đi sâu vào macro, hãy đảm bảo kiểm tra các phiên "Viết macro Swift" và "Mở rộng trên macro Swift".

00:04:19.000 --> 00:04:25.000
Với Observable, các trình bao bọc thuộc tính cho SwiftUI thậm chí còn dễ dàng hơn bao giờ hết.

00:04:25.000 --> 00:04:32.000
Trạng thái, môi trường và ràng buộc là ba trình bao bọc thuộc tính chính để làm việc với SwiftUI.

00:04:32.000 --> 00:04:42.000
Chúng tôi đã đề cập đến trường hợp bạn không cần bất kỳ trình bao bọc thuộc tính nào để giao tiếp với các loại có thể quan sát được với SwiftUI, nhưng hãy đi sâu vào các trường hợp mà bạn làm.

00:04:42.000 --> 00:04:44.000
Bắt đầu với @State.

00:04:44.000 --> 00:04:51.000
Khi chế độ xem cần có trạng thái riêng được lưu trữ trong một mô hình, hãy sử dụng thuộc tính @State.

00:04:51.000 --> 00:04:58.000
Ở đây chúng tôi có đối tượng mô hình có thể quan sát được Donut đang được sử dụng trong bản trình bày trang tính.

00:04:58.000 --> 00:05:05.000
Khi trang tính được trình bày, biến trạng thái donutToAdd được sử dụng để liên kết các giá trị với các trường có thể chỉnh sửa.

00:05:05.000 --> 00:05:11.000
Thuộc tính "donutToAdd" được quản lý bởi thời gian tồn tại của chế độ xem mà nó chứa trong đó.

00:05:11.000 --> 00:05:14.000
Tiếp theo, @Environment.

00:05:14.000 --> 00:05:20.000
Môi trường cho phép các giá trị được truyền bá dưới dạng các giá trị có thể truy cập trên toàn cầu.

00:05:20.000 --> 00:05:24.000
Điều này cho phép mọi thứ được chia sẻ ở nhiều nơi.

00:05:24.000 --> 00:05:33.000
Các loại có thể quan sát được hoạt động tuyệt vời ở đây vì các bản cập nhật do chúng tạo ra dựa trên quyền truy cập.

00:05:33.000 --> 00:05:41.000
Khi gọi nội dung của chế độ xem menu xe tải thực phẩm, tên người dùng thuộc tính của đối tượng tài khoản được truy cập.

00:05:41.000 --> 00:05:45.000
Vì vậy, khi Tên người dùng sẽ thay đổi, chế độ xem menu sẽ cập nhật.

00:05:45.000 --> 00:05:50.000
Sản phẩm mới nhất của gia đình giấy gói tài sản là “@Bindable”.

00:05:50.000 --> 00:05:53.000
Trình bao bọc tài sản có thể liên kết thực sự nhẹ.

00:05:53.000 --> 00:05:58.000
Tất cả những gì nó làm là cho phép các ràng buộc được tạo ra từ loại đó.

00:05:58.000 --> 00:06:04.000
Lấy ràng buộc ra khỏi một tài sản được bọc có thể ràng buộc thực sự dễ dàng.

00:06:04.000 --> 00:06:09.000
Chỉ cần sử dụng cú pháp $ để có được sự ràng buộc với thuộc tính đó.

00:06:09.000 --> 00:06:13.000
Thông thường, đây sẽ là ràng buộc với các loại có thể quan sát được.

00:06:13.000 --> 00:06:18.000
Đối với chế độ xem bánh rán, chúng tôi có tên được hiển thị cùng với Văn bản.

00:06:18.000 --> 00:06:22.000
Nhưng trên thực tế, chúng tôi muốn có thể chỉnh sửa cái tên đó.

00:06:22.000 --> 00:06:26.000
Vì vậy, thay vì Văn bản, chúng ta có thể sử dụng TextField.

00:06:26.000 --> 00:06:29.000
TextField đó có một ràng buộc.

00:06:29.000 --> 00:06:39.000
Nó đọc từ ràng buộc để điền vào giá trị của TextField, nhưng nó cũng ghi lại vào ràng buộc khi người dùng thay đổi giá trị.

00:06:39.000 --> 00:06:47.000
Để tạo ràng buộc với bánh rán, tất cả những gì chúng ta cần làm là sử dụng trình bao bọc thuộc tính '@Bindable' trên thuộc tính bánh rán.

00:06:47.000 --> 00:06:55.000
Chú thích trình bao bọc thuộc tính cho phép chúng tôi sử dụng cú pháp '$donut.name' và tạo liên kết khi được sử dụng.

00:06:55.000 --> 00:07:03.000
Để kết thúc các trình bao bọc, chỉ có ba câu hỏi bạn cần trả lời để sử dụng các mô hình có thể quan sát được trong SwiftUI.

00:07:03.000 --> 00:07:07.000
Mô hình này có cần phải là trạng thái của chính chế độ xem không?

00:07:07.000 --> 00:07:10.000
Nếu vậy, hãy sử dụng “@State”.

00:07:10.000 --> 00:07:15.000
Mô hình này có cần phải là một phần của môi trường toàn cầu của ứng dụng không?

00:07:15.000 --> 00:07:19.000
Nếu vậy, hãy sử dụng “@Môi trường”.

00:07:19.000 --> 00:07:22.000
Có phải mô hình này chỉ cần ràng buộc?

00:07:22.000 --> 00:07:26.000
Nếu vậy, hãy sử dụng '@Bindable' mới.

00:07:26.000 --> 00:07:32.000
Và nếu không có câu hỏi nào trong số này có câu trả lời là có, chỉ cần sử dụng mô hình làm thuộc tính trong quan điểm của bạn.

00:07:32.000 --> 00:07:37.000
Cho đến nay, chúng tôi đã đề cập đến các thuộc tính bắt đầu trong mô hình của bạn như được lưu trữ.

00:07:37.000 --> 00:07:40.000
Có thể quan sát được có thể làm được nhiều hơn thế.

00:07:40.000 --> 00:07:53.000
Bởi vì SwiftUI theo dõi quyền truy cập vào các trường cho mỗi trường hợp, điều đó có nghĩa là bạn có thể sử dụng mảng, tùy chọn hoặc cho vấn đề đó, bất kỳ loại nào có chứa các mô hình có thể quan sát được của bạn.

00:07:53.000 --> 00:07:57.000
Chế độ xem danh sách bánh rán có một loạt các mô hình bánh rán.

00:07:57.000 --> 00:08:01.000
Bản thân mỗi mô hình là “@Có thể quan sát được”.

00:08:01.000 --> 00:08:14.000
Khi bất kỳ tên nào của những chiếc bánh rán đó thay đổi, SwiftUI sẽ phát hiện quyền truy cập vào thuộc tính đó trên phiên bản cụ thể đó và theo dõi nó để biết khi nào nên vô hiệu hóa chế độ xem.

00:08:14.000 --> 00:08:23.000
Vì vậy, ở đây, khi tên bánh rán được thay đổi thông qua nút ngẫu nhiên hóa, chế độ xem sẽ cập nhật tương ứng.

00:08:23.000 --> 00:08:27.000
Điều này cho phép bạn xây dựng các mô hình của mình theo cách bạn muốn.

00:08:27.000 --> 00:08:35.000
Bạn có thể có các mảng mô hình đang được quan sát, hoặc thậm chí các loại mô hình có chứa các loại mô hình có thể quan sát được khác.

00:08:35.000 --> 00:08:44.000
Nguyên tắc chung dành cho Observable, nếu một thuộc tính được sử dụng thay đổi, chế độ xem sẽ cập nhật.

00:08:44.000 --> 00:08:48.000
Có một trường hợp quy tắc đó không được áp dụng đầy đủ.

00:08:48.000 --> 00:09:00.000
Nếu một thuộc tính được tính toán không có bất kỳ thuộc tính được lưu trữ nào mà nó bao gồm, thì cần phải thực hiện thêm hai bước để làm cho nó hoạt động với Quan sát.

00:09:00.000 --> 00:09:09.000
Điều này chỉ cần được thực hiện khi thuộc tính sẽ được quan sát không bị thay đổi thông qua một số loại thành phần của các thuộc tính được lưu trữ trong loại có thể quan sát được.

00:09:09.000 --> 00:09:18.000
Trong trường hợp này, tất cả những gì cần làm là cho Quan sát biết khi nào tài sản được truy cập và khi nào tài sản thay đổi.

00:09:18.000 --> 00:09:33.000
Đây là cách Observation tổng hợp quyền truy cập vào các thuộc tính một cách bình thường, ngoại trừ ở đây chúng tôi đã viết lại các điểm truy cập tùy chỉnh đó theo cách thủ công để vị trí không thể quan sát được có thể được đọc và lưu trữ tên.

00:09:33.000 --> 00:09:44.000
Hầu hết thời gian, các loại trường hợp thủ công này là không cần thiết, bởi vì hầu hết thời gian, các thuộc tính của các mô hình được đề cập được cấu tạo từ các thuộc tính được lưu trữ khác.

00:09:44.000 --> 00:09:55.000
Nhưng trong những trường hợp hiếm hoi mà bạn cần khả năng tiên tiến đó, Quan sát đủ linh hoạt nhưng đủ dễ dàng để tự mình thực hiện.

00:09:55.000 --> 00:10:04.000
SwiftUI có thể xác định những thay đổi trong bố cục vì nó theo dõi các loại có thể quan sát được bằng cách truy cập vào các thuộc tính đó.

00:10:04.000 --> 00:10:13.000
Điều này có nghĩa là nếu một thuộc tính được tính toán được cấu tạo từ các thuộc tính được lưu trữ khác, thì Quan sát sẽ chỉ hoạt động.

00:10:13.000 --> 00:10:25.000
Tuy nhiên, trong một vài trường hợp điều đó không đúng, bạn có thể sử dụng Quan sát trực tiếp để thêm thủ công các cuộc gọi đó vào cờ truy cập và đột biến.

00:10:25.000 --> 00:10:35.000
Trước đây trong ứng dụng Food Truck, chúng tôi đã sử dụng ObservableObject để đạt được một số điều tương tự như chúng tôi đã làm với macro @Observable mới.

00:10:35.000 --> 00:10:42.000
Nếu bạn có một ứng dụng sử dụng SwiftUI ngày hôm nay, bạn có thể đang ở trong một tình huống rất giống nhau.

00:10:42.000 --> 00:10:50.000
Macro Observable có thể đơn giản hóa mã của bạn và rất có thể, bạn cũng có thể thấy hiệu suất tăng lên tốt.

00:10:50.000 --> 00:11:01.000
Trước khi thay đổi, loại FoodTruckModel có sự phù hợp ObservableObject và nó có một số thuộc tính được đánh dấu bằng trình bao bọc thuộc tính @Published.

00:11:01.000 --> 00:11:06.000
Việc chuyển sang macro @Observable khá dễ dàng.

00:11:06.000 --> 00:11:16.000
Tất cả những gì chúng tôi cần làm là xóa sự phù hợp với ObservableObject, xóa '@Published' và đánh dấu nó bằng macro '@Observable'.

00:11:16.000 --> 00:11:23.000
Khi nói đến các chế độ xem, có một số trình bao bọc thuộc tính '@ObservedObject' và '@EnvironmentObject'.

00:11:23.000 --> 00:11:34.000
Trong tất cả các trường hợp của trình bao bọc '@ObservedObject', hoặc biến mất hoặc chỉ cần các ràng buộc và thay đổi thành '@Bindable' mới.

00:11:34.000 --> 00:11:40.000
Các trình bao bọc '@EnvironmentObject' đã được chuyển đổi thành chỉ '@Environment'.

00:11:40.000 --> 00:11:48.000
Thay đổi từ ObservableObject sang macro '@Observable' mới chủ yếu chỉ là xóa các chú thích.

00:11:48.000 --> 00:11:57.000
Hoặc đơn giản hóa chúng thành ba trình bao bọc thuộc tính chính; @State, @Environment và @Bindable.

00:11:57.000 --> 00:12:04.000
Điều này làm cho việc viết các tính năng mới dễ suy luận hơn vì có ít lựa chọn hơn cần được xem xét.

00:12:04.000 --> 00:12:09.000
Quan sát có mức độ ma thuật phù hợp.

00:12:09.000 --> 00:12:17.000
Nó cho phép bạn bắt đầu dễ dàng và cho phép bạn làm việc trực tiếp với các mô hình dữ liệu của mình bằng cách sử dụng macro @Observable.

00:12:17.000 --> 00:12:24.000
Khi bạn cần, nó cho phép bạn viết các phiên bản thủ công cho các trường hợp sử dụng nâng cao.

00:12:24.000 --> 00:12:30.000
Đối với sự phát triển mới, sử dụng Observable là cách dễ nhất để bắt đầu.

00:12:30.000 --> 00:12:38.000
Và đối với các ứng dụng hiện có, sử dụng Observable có thể đơn giản hóa các mô hình của bạn và cải thiện hiệu suất khi thêm các tính năng mới.

00:12:38.000 --> 00:12:44.000
Tôi khuyến khích bạn thử nó và tự khai thác phép thuật đó.

00:12:44.000 --> 23:59:59.000
♪ ♪

