WEBVTT

00:00:01.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:18.000
Robert: Xin chào Tên tôi là Robert Kendall-Kuppe và hôm nay tôi sẽ nói chuyện với bạn về một tính năng macOS mới mà chúng tôi gọi là "những hạn chế về môi trường".

00:00:18.000 --> 00:00:22.000
Các ứng dụng Mac giàu tính năng thường không chỉ là một quy trình hoặc tệp.

00:00:22.000 --> 00:00:30.000
Các khung và thư viện cho phép bạn sử dụng lại mã trên các ứng dụng của mình hoặc từ các nhà phát triển khác.

00:00:30.000 --> 00:00:36.000
Các công cụ trợ giúp, ứng dụng trợ giúp và dịch vụ XPC cho phép bạn phân chia công việc để giảm bề mặt tấn công.

00:00:36.000 --> 00:00:42.000
Khởi chạy các tác nhân, khởi chạy trình nền và các mục đăng nhập cho phép bạn thực hiện công việc trong nền hoặc khi đăng nhập người dùng.

00:00:42.000 --> 00:00:48.000
Và các tiện ích mở rộng ứng dụng cho phép bạn cung cấp chức năng hữu ích trong các ứng dụng khác.

00:00:48.000 --> 00:00:51.000
Nhưng các ứng dụng của bạn chạy trong một môi trường có khả năng thù địch.

00:00:51.000 --> 00:00:58.000
Các kiến trúc sư ứng dụng cần xem xét các tác động tiềm tàng của phần mềm chưa biết chạy cùng với phần mềm của họ hoặc sử dụng các khuôn khổ của họ.

00:00:58.000 --> 00:01:04.000
Việc thực thi công cụ trợ giúp hoặc dịch vụ XPC của bạn có thể cung cấp cho kẻ tấn công quyền truy cập vào dữ liệu chuỗi khóa của bạn không?

00:01:04.000 --> 00:01:07.000
Còn dữ liệu iCloud của bạn hoặc một số đặc quyền khác thì sao?

00:01:07.000 --> 00:01:12.000
Điều gì có thể xảy ra nếu mã bất ngờ được đưa vào quy trình của bạn?

00:01:12.000 --> 00:01:20.000
Cũng giống như trong các mối quan hệ cha mẹ-con cái thực sự, các quy trình cha mẹ có ảnh hưởng rất lớn đến cách con cư xử.

00:01:20.000 --> 00:01:27.000
Trên macOS, sức mạnh để posix_spawn một quy trình khác mang lại cho cha mẹ khả năng kiểm soát gần như tất cả đầu vào cho con.

00:01:27.000 --> 00:01:32.000
Quá trình phụ huynh cũng có thể hạn chế quyền truy cập của trẻ vào tài nguyên hệ thống.

00:01:32.000 --> 00:01:42.000
Mức độ kiểm soát này có thể khiến đứa trẻ tải mã bất ngờ, chạy các tính năng không mong muốn hoặc hoạt động theo những cách khiến quá trình dễ bị tấn công hơn.

00:01:42.000 --> 00:01:48.000
Tuy nhiên, ngoài mối quan hệ cha-con, các quy trình đặt niềm tin vào bố cục đĩa mà chúng sinh ra.

00:01:48.000 --> 00:02:05.000
Các quy trình độc hại có thể sửa đổi các tệp trên đĩa có thể cung cấp dữ liệu không mong muốn cho quy trình nạn nhân, xóa các biện pháp bảo vệ thời gian chạy khỏi quy trình nạn nhân, thực thi liên tục trên hệ thống hoặc đánh cắp các đặc quyền của quy trình.

00:02:05.000 --> 00:02:09.000
Đối mặt với tất cả những mối đe dọa đó, macOS cung cấp cho bạn các công cụ để bảo mật các ứng dụng của bạn.

00:02:09.000 --> 00:02:14.000
Đặc biệt, bạn có thể áp dụng Hộp cát ứng dụng để hạn chế tác động nếu ứng dụng của bạn bị xâm phạm.

00:02:14.000 --> 00:02:20.000
Và bạn có thể áp dụng Hardened Runtime và xác thực thư viện để bảo vệ tính toàn vẹn của các quy trình của bạn trong thời gian chạy.

00:02:20.000 --> 00:02:26.000
Gatekeeper và Notarization cũng giúp giữ cho hệ thống khách hàng không có mã độc đã biết.

00:02:26.000 --> 00:02:34.000
Suy nghĩ về các mối đe dọa mà tôi đã đề cập trước đây, chúng tôi nhận ra rằng các biện pháp bảo vệ hiện tại của chúng tôi tập trung vào các quy trình đang chạy hơn là môi trường thực thi của chúng.

00:02:34.000 --> 00:02:38.000
Đó là lý do tại sao chúng tôi giới thiệu những hạn chế về môi trường.

00:02:38.000 --> 00:02:48.000
Các ràng buộc về môi trường cung cấp cho bạn một cấp độ kiểm soát mới đối với các trường hợp mà các quy trình của bạn có thể chạy và các cách bạn có thể trộn mã trong một quy trình.

00:02:48.000 --> 00:03:02.000
Trong phần còn lại của bài nói chuyện này, chúng ta sẽ thảo luận về cách các ràng buộc môi trường phù hợp với kiến trúc bảo mật của macOS, cách các ràng buộc môi trường được cấu trúc và cách bạn có thể áp dụng các ràng buộc môi trường trong ứng dụng của mình.

00:03:02.000 --> 00:03:07.000
Hãy lùi lại một chút và nói về ngăn xếp bảo mật macOS.

00:03:07.000 --> 00:03:19.000
Theo mặc định, macOS tận dụng tất cả các công nghệ này để bảo mật chuỗi khởi động, đảm bảo tính toàn vẹn của hệ điều hành, thực thi tách đặc quyền và bảo vệ người dùng khỏi phần mềm độc hại.

00:03:19.000 --> 00:03:25.000
Trong macOS Ventura, chúng tôi bắt đầu sử dụng các ràng buộc môi trường để bảo vệ tốt hơn các mối quan hệ giữa các quy trình hệ điều hành.

00:03:25.000 --> 00:03:28.000
Họ cung cấp một chiều hướng bảo mật mới cho hệ điều hành.

00:03:28.000 --> 00:03:35.000
Trong macOS Sonoma, chúng tôi đã mở rộng việc sử dụng các ràng buộc môi trường và mở chúng ra để bạn sử dụng trong các ứng dụng của mình.

00:03:35.000 --> 00:03:38.000
Vậy những hạn chế về môi trường là gì?

00:03:38.000 --> 00:03:47.000
Về cơ bản, chúng là một cách để mô tả mã, không chỉ mã là gì, mà còn là cách mã được kỳ vọng sẽ tồn tại và chạy trên hệ thống.

00:03:47.000 --> 00:03:50.000
Trong macOS, chúng tôi sử dụng các ràng buộc môi trường cho nhiều mục đích khác nhau.

00:03:50.000 --> 00:04:00.000
Ví dụ, để giúp đảm bảo các quy trình đang sử dụng tài nguyên gói đáng tin cậy, chúng tôi yêu cầu các quy trình hệ điều hành chạy từ Khối lượng hệ thống đã ký.

00:04:00.000 --> 00:04:10.000
Để đảm bảo rằng các trình nền đặc quyền không chạy với các đối số bất ngờ hoặc cổng Mach, chúng tôi yêu cầu các trình nền hệ thống chỉ được chạy dựa trên launchd.plist được bảo vệ của chúng.

00:04:10.000 --> 00:04:23.000
Để giảm bề mặt tấn công của các ứng dụng hệ thống, chúng tôi yêu cầu chúng được chạy từ Dịch vụ Khởi chạy dưới dạng ứng dụng và để đảm bảo rằng sự chấp thuận của người dùng đối với các mục nền có răng, chúng tôi sử dụng các ràng buộc môi trường để phát hiện các thay đổi.

00:04:23.000 --> 00:04:28.000
Bây giờ bạn có thể đang hỏi. "Ứng dụng của tôi có cần áp dụng các ràng buộc về môi trường không?

00:04:28.000 --> 00:04:34.000
Tôi muốn nhấn mạnh rằng các ràng buộc môi trường là hoàn toàn tùy chọn, nhưng chúng có thể làm giảm bề mặt tấn công của bất kỳ ứng dụng nào.

00:04:34.000 --> 00:04:38.000
Chúng ta sẽ thảo luận về một số trường hợp sử dụng ví dụ cụ thể hơn sau trong buổi nói chuyện này.

00:04:38.000 --> 00:04:49.000
Tuy nhiên, tôi sẽ lưu ý rằng các ràng buộc môi trường có thể đặc biệt hữu ích nếu ứng dụng của bạn có nhiều quy trình hoặc tải mã được ký bởi các nhóm nhà phát triển khác nhau.

00:04:49.000 --> 00:04:54.000
Có một vài loại ràng buộc môi trường khác nhau, vì vậy trước tiên hãy nói về các ràng buộc khởi chạy.

00:04:54.000 --> 00:05:07.000
Các ràng buộc khởi chạy được nhúng vào một tệp nhị phân cụ thể và xác định các thuộc tính của quy trình đó, các thuộc tính của các quy trình có thể là cha mẹ của nó hoặc các thuộc tính của các quy trình có thể chịu trách nhiệm về nó.

00:05:07.000 --> 00:05:14.000
Chúng tôi sẽ gọi các thuộc tính này là "tự ràng buộc", "hạn chế quy trình mẹ" và "hạn chế quy trình có trách nhiệm".

00:05:14.000 --> 00:05:18.000
Bạn có thể áp dụng cả ba vào nhị phân của mình hoặc chọn những cái có ý nghĩa nhất.

00:05:18.000 --> 00:05:26.000
Một quy trình có ràng buộc khởi chạy nhúng sẽ không chạy nếu bất kỳ thuộc tính được yêu cầu nào không được thỏa mãn.

00:05:26.000 --> 00:05:32.000
Bây giờ chúng ta hãy xem qua một số mối quan hệ quy trình và nói về cách bạn có thể sử dụng các ràng buộc khởi chạy để bảo mật chúng.

00:05:32.000 --> 00:05:35.000
Đầu tiên hãy giả sử rằng MyDemo.app là ứng dụng của bạn.

00:05:35.000 --> 00:05:41.000
Bạn có thể đặt tự ràng buộc trên ứng dụng MyDemo.app của tôi để yêu cầu nó khởi chạy dưới dạng ứng dụng từ Dịch vụ Khởi chạy.

00:05:41.000 --> 00:05:54.000
Khi ứng dụng của bạn yêu cầu kết nối với dịch vụ XPC của bạn, launchd sẽ sinh ra dịch vụ XPC và là cha mẹ của dịch vụ XPC đó nhưng ứng dụng của bạn "chịu trách nhiệm" cho dịch vụ XPC đó.

00:05:54.000 --> 00:06:04.000
Bạn có thể đặt một ràng buộc quy trình có trách nhiệm trên MyXPCDemo.xpc để chỉ ra rằng chỉ MyDemo.app mới phải chịu trách nhiệm về nó.

00:06:04.000 --> 00:06:13.000
Nếu ứng dụng của bạn sau này sử dụng NSTask hoặc posix_spawn để khởi chạy trình trợ giúp, thì nó vừa là cha mẹ vừa chịu trách nhiệm về trình trợ giúp đó.

00:06:13.000 --> 00:06:21.000
Bạn có thể đặt ràng buộc quy trình mẹ trên MyFirstHelper để yêu cầu chỉ MyDemo.app mới có thể là cha mẹ của nó.

00:06:21.000 --> 00:06:32.000
Sau đó, nếu người trợ giúp đầu tiên posix_spawns người trợ giúp thứ hai, người trợ giúp đầu tiên là cha mẹ của người trợ giúp thứ hai, nhưng ứng dụng chịu trách nhiệm cho người trợ giúp thứ hai.

00:06:32.000 --> 00:06:45.000
Đối với MySecondHelper, bạn có thể đặt ràng buộc quy trình mẹ để yêu cầu nó chỉ được khởi chạy bởi MyFirstHelper và bạn có thể đặt ràng buộc quy trình có trách nhiệm để yêu cầu chỉ MyDemo.app chịu trách nhiệm về nó.

00:06:45.000 --> 00:06:51.000
Bạn cũng có thể chỉ định một ràng buộc môi trường trong danh sách đã khởi chạy của mình cho các tác nhân khởi chạy và trình nền khởi chạy.

00:06:51.000 --> 00:07:01.000
Khi bạn đăng ký plist của mình bằng cách sử dụng SMAppService API, hệ điều hành sẽ thực thi rằng chỉ một quy trình đáp ứng ràng buộc sẽ được khởi chạy thay mặt cho plist của bạn.

00:07:01.000 --> 00:07:11.000
Tính năng này rất hữu ích để đảm bảo rằng mã độc không được thực thi liên tục dựa trên sự chấp thuận của người dùng đối với các hoạt động nền của ứng dụng của bạn.

00:07:11.000 --> 00:07:17.000
Cuối cùng, bạn có thể sử dụng các ràng buộc tải thư viện để kiểm soát cụ thể mã có thể tải trong không gian địa chỉ của bạn.

00:07:17.000 --> 00:07:21.000
Trước khi hạn chế tải thư viện, bạn có thể áp dụng xác thực thư viện hoặc không.

00:07:21.000 --> 00:07:28.000
Xác thực thư viện cho phép quy trình của bạn tải mã mà bạn đã ký hoặc mã được Apple ký.

00:07:28.000 --> 00:07:38.000
Với các ràng buộc tải thư viện, bạn có thể mô tả một bộ mã ít hạn chế hơn so với xác thực thư viện sẽ cho phép trong khi ngăn mã tùy ý được tải vào quy trình của bạn.

00:07:38.000 --> 00:07:48.000
Tuy nhiên, lưu ý rằng bạn không thể loại trừ mã do Apple ký khỏi việc tải trong quy trình của mình và bạn cần chỉ định một hoặc nhiều thuộc tính để cho phép mã của riêng bạn.

00:07:48.000 --> 00:07:55.000
Bây giờ bạn đã biết những hạn chế về môi trường là gì và chúng có thể được sử dụng như thế nào, hãy thảo luận về cách chúng được xác định.

00:07:55.000 --> 00:07:59.000
Các ràng buộc về môi trường mô tả một tập hợp các điều kiện mà mã phải đáp ứng.

00:07:59.000 --> 00:08:09.000
Chúng được mã hóa dưới dạng từ điển trong đó các khóa đại diện cho các sự kiện phải đúng về mã hoặc toán tử chỉ ra mối quan hệ bắt buộc giữa các sự kiện hoặc vị ngữ.

00:08:09.000 --> 00:08:17.000
Ở cấp cao nhất, ngầm, kết quả của mỗi cặp khóa-giá trị được ANDed cùng nhau để quyết định xem ràng buộc có được thỏa mãn hay không.

00:08:17.000 --> 00:08:23.000
Lưu ý rằng vì đây là từ điển, mỗi khóa chỉ có thể xuất hiện một lần cho mỗi cấp độ từ điển.

00:08:23.000 --> 00:08:26.000
Hãy cùng xem một số sự thật mà bạn có thể muốn sử dụng.

00:08:26.000 --> 00:08:31.000
Bên trái là các phím ràng buộc môi trường có liên quan và bên phải là đầu ra từ lệnh đồng thiết kế.

00:08:31.000 --> 00:08:40.000
Khóa ký-định danh cho phép bạn chỉ định một chuỗi phải là duy nhất cho một đoạn mã nhất định, nhưng vẫn giữ nguyên trên các phiên bản của mã đó.

00:08:40.000 --> 00:08:46.000
Khóa ký-định danh đề cập đến trường định danh trong đầu ra đồng thiết kế.

00:08:46.000 --> 00:08:57.000
Khóa cdhash cho phép bạn chỉ định một hàm băm duy nhất cho mã nên được cho phép và khóa nhận dạng nhóm cho phép bạn chỉ định mã được ký bởi một nhóm phát triển cụ thể.

00:08:57.000 --> 00:09:08.000
Trong khi các sự kiện chỉ ra các thuộc tính cụ thể của mã, các toán tử có thể được sử dụng để kết hợp hợp lý các tập hợp các sự kiện hoặc để xác định các tập hợp các giá trị chấp nhận được cho các sự kiện.

00:09:08.000 --> 00:09:17.000
Như bạn có thể mong đợi, toán tử $and và $or cho phép bạn chỉ định từ điển của các vị ngữ sẽ được kết hợp một cách hợp lý sau khi chúng được quyết định.

00:09:17.000 --> 00:09:28.000
Các toán tử $and-array và $or-array tồn tại để giới hạn việc lồng từ điển trong trường hợp bạn có thể muốn AND nhiều vị ngữ $ hoặc hoặc HOẶC nhiều $and vị ngữ.

00:09:28.000 --> 00:09:33.000
Và cuối cùng, toán tử $in cho phép bạn chỉ định một mảng các giá trị sẽ đáp ứng một thực tế.

00:09:33.000 --> 00:09:35.000
Hãy xem qua ràng buộc ví dụ này.

00:09:35.000 --> 00:09:39.000
Ở bên trái, chúng tôi có một đại diện plist của ràng buộc.

00:09:39.000 --> 00:09:44.000
Ở bên phải là mã giả hiển thị ý nghĩa của XML.

00:09:44.000 --> 00:09:49.000
Ở cấp cao nhất của plist, có một phím, $ hoặc mảng.

00:09:49.000 --> 00:09:51.000
Giá trị là một mảng gồm ba bộ.

00:09:51.000 --> 00:10:10.000
Mỗi bộ chứa một toán tử và một từ điển mà toán tử đó sẽ được áp dụng, vì vậy điều đó có nghĩa là ràng buộc này cho phép tất cả mã được ký bởi mã định danh nhóm của bạn hoặc thư viện B được ký bởi mã định danh nhóm thứ hai hoặc thư viện C được ký bởi mã định danh nhóm thứ ba.

00:10:10.000 --> 00:10:16.000
Đối với bộ đầu tiên, vì nó là một phần tử duy nhất, chúng ta cũng có thể đã sử dụng toán tử $ hoặc.

00:10:16.000 --> 00:10:21.000
Bây giờ chúng ta có thể xác định các ràng buộc, hãy xem cách bạn có thể áp dụng chúng trong dự án của mình.

00:10:21.000 --> 00:10:34.000
Với mục đích của cuộc thảo luận này, hãy xem xét một ứng dụng chính có chứa tác nhân khởi chạy, công cụ trợ giúp, khuôn khổ bao gồm dịch vụ XPC và thư viện được ký bởi một nhóm phát triển khác.

00:10:34.000 --> 00:10:38.000
Bây giờ hãy xem xét một số vấn đề tiềm ẩn mà các hạn chế về môi trường có thể giảm thiểu.

00:10:38.000 --> 00:10:47.000
Có lẽ bạn đã chỉ định một số đặc quyền cho một công cụ trợ giúp, như quyền truy cập vào dữ liệu chuỗi khóa hoặc quyền truy cập vào vùng chứa iCloud của bạn.

00:10:47.000 --> 00:10:53.000
Bạn có thể muốn đảm bảo rằng công cụ trợ giúp chỉ có thể được khởi chạy bởi ứng dụng của bạn chứ không phải bất kỳ thứ gì khác.

00:10:53.000 --> 00:11:00.000
Bạn có thể đảm bảo rằng chỉ có ứng dụng của bạn mới có thể khởi chạy công cụ trợ giúp của bạn bằng cách đặt ràng buộc quy trình mẹ trên công cụ trợ giúp.

00:11:00.000 --> 00:11:08.000
Để làm điều này, hãy tạo một tệp plist yêu cầu mã yêu cầu mã định danh nhóm của bạn và mã định danh ký của ứng dụng chính của bạn.

00:11:08.000 --> 00:11:15.000
Sau đó thêm ràng buộc vào cấu hình ký của công cụ trợ giúp của bạn trong cài đặt "Khởi chạy Plist Quy trình Phụ huynh Ràng buộc".

00:11:15.000 --> 00:11:18.000
Chúng ta hãy xem xét kỹ hơn.

00:11:18.000 --> 00:11:23.000
Ở đây tôi có một dự án demo trong Xcode với các thuộc tính mà tôi đã đề cập.

00:11:23.000 --> 00:11:29.000
MyDemo.app là mục tiêu ứng dụng chính và demohelper là một công cụ trợ giúp.

00:11:29.000 --> 00:11:33.000
Hãy khởi chạy ứng dụng.

00:11:33.000 --> 00:11:42.000
Khi tôi nhấn nút này, ứng dụng sẽ tạo ra công cụ trợ giúp, sau đó công cụ trợ giúp thực hiện một số công việc và cung cấp phản hồi cho ứng dụng.

00:11:42.000 --> 00:11:52.000
Hãy xem chữ ký của demohelper trong Terminal.

00:11:52.000 --> 00:12:01.000
Chúng ta có thể thấy rằng nó không có ràng buộc khởi chạy nào được đặt ra và chúng ta có thể chạy demohelper.

00:12:01.000 --> 00:12:04.000
Nhưng hãy nhìn vào đó.

00:12:04.000 --> 00:12:09.000
Nếu chúng ta chạy demohelper với đối số --cloud, thì demohelper có thể truy cập dữ liệu iCloud của ứng dụng.

00:12:09.000 --> 00:12:16.000
Chúng tôi không muốn một quy trình tùy ý có thể chạy demohelper và thay đổi dữ liệu iCloud của chúng tôi.

00:12:16.000 --> 00:12:22.000
Hãy quay lại Xcode và đặt ràng buộc cha mẹ trên demohelper.

00:12:22.000 --> 00:12:30.000
Ở đây tôi có một tệp plist ràng buộc đã được điền để xác định ứng dụng chính MyDemo.

00:12:30.000 --> 00:12:39.000
Hãy thêm ràng buộc vào cấu hình ký kết của chúng tôi.

00:12:39.000 --> 00:12:45.000
Bây giờ hãy xây dựng lại ứng dụng.

00:12:45.000 --> 00:12:51.000
Chúng ta có thể khởi chạy lại ứng dụng...

00:12:51.000 --> 00:12:58.000
Và ứng dụng chính vẫn có thể sinh ra người trợ giúp.

00:12:58.000 --> 00:13:00.000
Nhưng khi chúng ta quay trở lại Terminal...

00:13:00.000 --> 00:13:14.000
Chúng ta có thể thấy rằng bây giờ demohelper có một ràng buộc khởi chạy...

00:13:14.000 --> 00:13:18.000
Và nó không còn có thể chạy từ Terminal nữa.

00:13:18.000 --> 00:13:26.000
Khi một lần khởi chạy bị chặn vì vi phạm ràng buộc khởi chạy, một báo cáo sự cố được tạo ra cho thấy rằng ràng buộc đã bị vi phạm.

00:13:26.000 --> 00:13:36.000
Bây giờ hãy nói về một vài vấn đề nữa mà những hạn chế về môi trường có thể giảm thiểu.

00:13:36.000 --> 00:13:42.000
Chúng tôi khuyến khích bạn sử dụng các dịch vụ XPC để tách các đặc quyền giữa các quy trình khác nhau.

00:13:42.000 --> 00:13:48.000
Nhưng khi bạn xây dựng các dịch vụ XPC, có thể trích xuất các dịch vụ đó từ gói của bạn và gọi chúng từ mã khác.

00:13:48.000 --> 00:13:57.000
Nếu bạn đã chỉ định một số đặc quyền cho dịch vụ XPC của mình, bạn cần đảm bảo rằng chỉ các quy trình dự kiến mới có thể có quyền truy cập vào đặc quyền đó.

00:13:57.000 --> 00:14:04.000
Một cách để đảm bảo rằng chỉ mã của bạn mới có thể truy cập dịch vụ XPC đó là đặt ràng buộc khởi chạy quy trình có trách nhiệm.

00:14:04.000 --> 00:14:15.000
Ở đây chúng tôi hiển thị một plist ràng buộc khởi chạy cho phép mã được nhóm của bạn ký với danh sách các số nhận dạng ký cho từng quy trình trong gói có thể truy cập dịch vụ XPC.

00:14:15.000 --> 00:14:22.000
Bạn có thể thêm ràng buộc vào cấu hình ký của mình trong cài đặt "Khởi chạy Plist quy trình có trách nhiệm ràng buộc".

00:14:22.000 --> 00:14:24.000
Một vấn đề khác cần xem xét.

00:14:24.000 --> 00:14:30.000
Bắt đầu từ macOS Ventura, người dùng được yêu cầu phê duyệt các tác vụ nền được cài đặt thay mặt cho ứng dụng của bạn.

00:14:30.000 --> 00:14:34.000
Điều này có nghĩa là người dùng mong đợi rằng công việc chỉ diễn ra thay mặt cho ứng dụng của bạn.

00:14:34.000 --> 00:14:42.000
Nếu kẻ tấn công có thể thay thế mã mà plist của bạn mong đợi chạy, kẻ tấn công có thể được thực thi nền liên tục thay mặt cho ứng dụng của bạn.

00:14:42.000 --> 00:14:51.000
Để đảm bảo rằng plist đã đăng ký của bạn chỉ có thể được sử dụng để chạy mã mà bạn mong đợi, bạn có thể đặt ràng buộc plist đã khởi chạy bằng khóa SpawnConstraint.

00:14:51.000 --> 00:14:56.000
Tại đây bạn có thể thấy một plist đã khởi chạy hoàn chỉnh với khóa SpawnConstraint.

00:14:56.000 --> 00:15:02.000
Ràng buộc này xác định nhóm của chúng tôi và đại lý DemoMenuBar.

00:15:02.000 --> 00:15:04.000
Cuối cùng, hãy nói về việc tải thư viện.

00:15:04.000 --> 00:15:16.000
Nếu bạn có nghĩa vụ liên kết một thư viện từ một nhóm phát triển khác mà không cần sửa đổi, thì để ứng dụng của bạn được công chứng với thời gian chạy cứng, bạn sẽ phải áp dụng quyền xác thực thư viện vô hiệu hóa.

00:15:16.000 --> 00:15:23.000
Thật không may, điều đó có nghĩa là ứng dụng của bạn hiện có thể tải mã có chữ ký của bất kỳ ai, không chỉ nhà phát triển đáng tin cậy mà bạn nhận được thư viện.

00:15:23.000 --> 00:15:27.000
Để giải quyết vấn đề này, bạn có thể áp dụng ràng buộc tải thư viện.

00:15:27.000 --> 00:15:33.000
Ở đây chúng tôi hiển thị một ràng buộc sẽ cho phép bạn tải bất kỳ mã nào được ký bởi nhóm của bạn hoặc nhà cung cấp thư viện đáng tin cậy.

00:15:33.000 --> 00:15:40.000
Bạn cũng có thể hạn chế điều này hơn nữa đối với một thư viện hoặc tập hợp thư viện cụ thể bằng cách sử dụng một hoặc nhiều sự kiện nhận dạng ký tên.

00:15:40.000 --> 00:15:51.000
Như với các ràng buộc khởi chạy, các ràng buộc tải thư viện được đăng nhập vào quy trình của bạn khi bạn đặt cài đặt "Danh sách ràng buộc tải thư viện" trong cấu hình ký Xcode của mình.

00:15:51.000 --> 00:15:53.000
Vậy những hạn chế về môi trường có sẵn ở đâu?

00:15:53.000 --> 00:15:59.000
Các ràng buộc tải thư viện và các ràng buộc plist đã khởi chạy có thể được bao gồm trong các ứng dụng nhắm mục tiêu đến bất kỳ phiên bản macOS nào.

00:15:59.000 --> 00:16:02.000
Chúng được thực thi bắt đầu từ macOS Sonoma.

00:16:02.000 --> 00:16:10.000
Các ràng buộc khởi chạy có thể được thêm vào các ứng dụng nhắm mục tiêu macOS 13.3 trở lên và chúng được thực thi bắt đầu từ macOS 13.3.

00:16:10.000 --> 00:16:17.000
Lưu ý rằng bộ khóa và giá trị được hỗ trợ có thể được sử dụng trong các ràng buộc môi trường có thể thay đổi trên các phiên bản macOS.

00:16:17.000 --> 00:16:21.000
Tham khảo tài liệu để biết thông tin đầy đủ về tình trạng sẵn có.

00:16:21.000 --> 00:16:30.000
Hãy xem các mối quan hệ quy trình, danh sách đã khởi chạy và thư viện trong ứng dụng của bạn để xem liệu bạn có thể sử dụng các ràng buộc về môi trường để làm cho ứng dụng của mình an toàn hơn hay không.

00:16:30.000 --> 00:16:32.000
Cảm ơn vì đã xem.

00:16:32.000 --> 23:59:59.000
♪ ♪

