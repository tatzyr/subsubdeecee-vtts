WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:15.000
David: Xin chào, tôi là David Ilenwabor, một Kỹ sư trong nhóm ShazamKit.

00:00:15.000 --> 00:00:21.000
ShazamKit là một khuôn khổ cho phép bạn mang lại nhận dạng âm thanh cho các ứng dụng của mình.

00:00:21.000 --> 00:00:29.000
Bạn có thể kết hợp âm thanh với danh mục âm nhạc rộng lớn của Shazam hoặc kết hợp với âm thanh được ghi sẵn của riêng bạn bằng cách sử dụng danh mục tùy chỉnh.

00:00:29.000 --> 00:00:36.000
Năm 2022 đã chứng kiến một số cập nhật tuyệt vời cho ShazamKit đã cải thiện hoạt động với các danh mục tùy chỉnh trên quy mô lớn.

00:00:36.000 --> 00:00:52.000
Đã có sự ra đời của Shazam CLI để xử lý quy trình làm việc nặng nề khi sử dụng danh mục tùy chỉnh, các mục phương tiện bị giới hạn thời gian để đồng bộ hóa tốt hơn và sai lệch tần số để phân biệt giữa hai bit âm thanh tương tự nhau.

00:00:52.000 --> 00:00:59.000
Nếu bạn chưa quen thuộc với cách hoạt động của những thứ này, hãy xem Tạo danh mục Tùy chỉnh ở quy mô lớn với video ShazamKit.

00:00:59.000 --> 00:01:09.000
Nhưng để cung cấp một cái nhìn tổng quan nhanh chóng, ShazamKit cho phép bạn thực hiện kết hợp bằng cách chuyển đổi âm thanh sang một định dạng đặc biệt được gọi là Chữ ký.

00:01:09.000 --> 00:01:16.000
Bạn có thể chuyển một luồng bộ đệm âm thanh hoặc dữ liệu chữ ký vào phiên ShazamKit.

00:01:16.000 --> 00:01:23.000
Phiên sau đó sử dụng chữ ký để tìm kết quả phù hợp trong Danh mục Shazam hoặc Danh mục Tùy chỉnh.

00:01:23.000 --> 00:01:31.000
Nếu có một trận đấu, phiên sẽ trả về một đối tượng trận đấu với các mục phương tiện đại diện cho siêu dữ liệu của trận đấu.

00:01:31.000 --> 00:01:35.000
Sau đó, bạn có thể hiển thị các mục phương tiện trong ứng dụng của mình.

00:01:35.000 --> 00:01:45.000
ShazamKit có thể thực hiện kết hợp bằng cách tạo chữ ký từ luồng bộ đệm âm thanh hoặc sử dụng tệp chữ ký có thể được lưu trữ trên đĩa.

00:01:45.000 --> 00:01:53.000
Chữ ký không thể đảo ngược, điều đó có nghĩa là không thể tái tạo lại bản ghi gốc từ chữ ký.

00:01:53.000 --> 00:01:57.000
Điều này bảo vệ quyền riêng tư của khách hàng của chúng tôi.

00:01:57.000 --> 00:02:11.000
Danh mục là một nhóm chữ ký với các mục phương tiện liên quan của chúng và kết quả khớp xảy ra khi chữ ký truy vấn khớp đủ với một phần của chữ ký tham chiếu trong danh mục.

00:02:11.000 --> 00:02:18.000
Các trận đấu có thể xảy ra ngay cả khi chữ ký truy vấn ồn ào, chẳng hạn như nhạc đang phát trong nhà hàng.

00:02:18.000 --> 00:02:24.000
Bây giờ tôi đã đề cập đến điều đó, tôi sẽ chuyển sang các bản cập nhật mới thú vị trong ShazamKit trong năm nay.

00:02:24.000 --> 00:02:37.000
Trong phiên này, tôi sẽ trải qua những thay đổi mới để nhận dạng âm thanh với ShazamKit, sau đó tôi sẽ nói về API Thư viện Shazam, đã được xác định lại với chức năng mới thú vị.

00:02:37.000 --> 00:02:44.000
Cuối cùng, tôi sẽ đưa bạn qua một số phương pháp hay nhất để tạo trải nghiệm ứng dụng tốt hơn với ShazamKit.

00:02:44.000 --> 00:02:51.000
Trước khi tôi bắt đầu, tôi đề nghị bạn tải xuống dự án mã mẫu đính kèm trên cổng thông tin dành cho nhà phát triển.

00:02:51.000 --> 00:02:56.000
Tôi sẽ tận dụng dự án này trong suốt video này.

00:02:56.000 --> 00:03:00.000
Có rất nhiều thứ để giải quyết, vì vậy tôi sẽ bắt đầu.

00:03:00.000 --> 00:03:04.000
Trước hết, nhận dạng âm thanh.

00:03:04.000 --> 00:03:11.000
Quá trình sử dụng ShazamKit để nhận dạng âm thanh từ micrô có thể được tóm tắt trong các bước sau.

00:03:11.000 --> 00:03:15.000
Đầu tiên, yêu cầu quyền micrô từ người dùng.

00:03:15.000 --> 00:03:20.000
Sau đó, bắt đầu ghi âm sau khi quyền đã được cấp.

00:03:20.000 --> 00:03:27.000
Tiếp theo, chuyển bộ đệm âm thanh đã ghi vào ShazamKit và cuối cùng, xử lý kết quả.

00:03:27.000 --> 00:03:32.000
Để chứng minh điều này, tôi đã xây dựng một ứng dụng demo mà bạn có thể tìm thấy trong dự án mẫu.

00:03:32.000 --> 00:03:40.000
Tôi thích khiêu vũ, và để theo kịp các xu hướng mới nhất, tôi đã xây dựng một ứng dụng để giúp tôi khám phá các bước nhảy thịnh hành cho một bài hát.

00:03:40.000 --> 00:03:46.000
Ứng dụng hoạt động bằng cách nghe âm thanh bằng micrô và tiến hành tìm video khiêu vũ.

00:03:46.000 --> 00:03:50.000
Vì vậy, ví dụ, tôi có thể nhờ Siri giúp tôi tìm một bài hát.

00:03:50.000 --> 00:03:56.000
Này, Siri, chơi "Push It" của Dukes.

00:03:56.000 --> 00:03:58.000
Siri: Đang phát "Push It" của Dukes.

00:03:58.000 --> 00:04:02.000
David: Sau đó, tôi có thể nhấn vào nút Learn The Dance để bắt đầu ghi âm.

00:04:02.000 --> 00:04:05.000
♪ ♪

00:04:05.000 --> 00:04:11.000
ShazamKit nhận ra bài hát và ứng dụng tìm kiếm một video khiêu vũ thích hợp đi kèm với nó.

00:04:11.000 --> 00:04:14.000
Có vẻ như tôi có một cái. Hừm!

00:04:14.000 --> 00:04:17.000
Có vẻ như anh em sinh đôi Dancing Dave của tôi đang chỉ cho tôi một số động tác.

00:04:17.000 --> 00:04:19.000
Điều này có vẻ thú vị.

00:04:19.000 --> 00:04:22.000
Vậy điều này được thực hiện như thế nào?

00:04:22.000 --> 00:04:25.000
Để tôi đưa bạn qua mã.

00:04:25.000 --> 00:04:30.000
Ở đây tôi có dự án mẫu được mở trong Xcode.

00:04:30.000 --> 00:04:38.000
Tôi đã thêm mô tả sử dụng micrô vào tệp info.plist của mình được sử dụng để yêu cầu quyền truy cập micrô.

00:04:38.000 --> 00:04:43.000
Tôi cũng có một loạt các chế độ xem SwiftUI cho màn hình chính và màn hình video khiêu vũ.

00:04:43.000 --> 00:04:49.000
Tuy nhiên, lớp Matcher này là nơi xảy ra tất cả sự kỳ diệu của nhận dạng âm thanh.

00:04:49.000 --> 00:04:55.000
Khi khởi tạo, tôi có một phương pháp để cấu hình và thiết lập công cụ âm thanh.

00:04:55.000 --> 00:05:03.000
Trong phương pháp này, tôi cài đặt một cú chạm để nhận PCMbuffers và chuẩn bị công cụ âm thanh.

00:05:03.000 --> 00:05:08.000
Ngoài ra, tôi có một phương pháp kết hợp được gọi khi tôi nhấn vào nút Learn The Dance.

00:05:08.000 --> 00:05:17.000
Tôi yêu cầu quyền ghi âm và nếu điều này được cấp, tôi gọi start trên công cụ âm thanh để bắt đầu ghi âm.

00:05:17.000 --> 00:05:27.000
Tiếp theo, tôi nói rằng việc khớp giao diện người dùng đã bắt đầu, sau đó tôi gọi session.results và đợi một chuỗi kết quả kết quả kết hợp không đồng bộ.

00:05:27.000 --> 00:05:36.000
Sau khi nhận được kết quả, tôi đặt đối tượng khớp nếu nó khớp và tôi xử lý các trường hợp không khớp và lỗi.

00:05:36.000 --> 00:05:43.000
Lớp này cũng có chức năng stopRecording trong đó tôi dừng công cụ âm thanh.

00:05:43.000 --> 00:05:51.000
Điều này hoạt động tốt, nhưng hãy chú ý cách tôi có rất nhiều mã thiết lập để định cấu hình công cụ âm thanh trước khi tôi có thể nhận bộ đệm âm thanh.

00:05:51.000 --> 00:05:57.000
Điều này có thể là một thách thức để làm đúng, đặc biệt nếu bạn không quen với lập trình âm thanh.

00:05:57.000 --> 00:06:06.000
Và vì vậy, để ghi và kết hợp dễ dàng hơn, chúng tôi đã giới thiệu một API mới có tên SHManagedSession.

00:06:06.000 --> 00:06:14.000
Phiên được quản lý tự động đảm nhận việc bắt đầu ghi âm cho bạn mà không gặp rắc rối khi thiết lập bộ đệm âm thanh.

00:06:14.000 --> 00:06:19.000
Điều này làm cho nó rất dễ cài đặt và sử dụng.

00:06:19.000 --> 00:06:22.000
Cần có sự cho phép của micrô để sử dụng Phiên được quản lý.

00:06:22.000 --> 00:06:26.000
Nếu không có sự cho phép này, phiên không thể bắt đầu ghi âm.

00:06:26.000 --> 00:06:35.000
Do đó, điều quan trọng là bạn thêm mục mô tả sử dụng Micrô vào tệp info.plist của ứng dụng của bạn.

00:06:35.000 --> 00:06:41.000
Phiên được quản lý sẽ sử dụng mô tả này khi yêu cầu quyền truy cập micrô từ người dùng.

00:06:41.000 --> 00:06:46.000
Vậy làm thế nào tôi có thể sử dụng API này trong mã?

00:06:46.000 --> 00:06:55.000
Đầu tiên, tôi sẽ tạo một phiên bản của SHManagedSession, sau đó tôi có thể đợi kết quả bằng cách gọi phương thức kết quả.

00:06:55.000 --> 00:07:04.000
Phương thức này trả về một enum có ba trạng thái có thể là khớp, NoMatch hoặc lỗi.

00:07:04.000 --> 00:07:15.000
Tiếp theo, tôi có thể chuyển đổi kết quả, sử dụng các mục phương tiện được trả về trong trường hợp khớp và xử lý các trường hợp không khớp và lỗi.

00:07:15.000 --> 00:07:21.000
Và điều gì sẽ xảy ra nếu tôi muốn có một phiên ghi âm dài hơn có thể trả về nhiều kết quả theo thời gian?

00:07:21.000 --> 00:07:27.000
Chà, tôi có thể làm điều này bằng cách sử dụng thuộc tính kết quả chuỗi không đồng bộ trên managedSession.

00:07:27.000 --> 00:07:32.000
Tôi có thể sử dụng từng kết quả nhận được từ chuỗi giống như trước đây.

00:07:32.000 --> 00:07:37.000
Điều này đảm bảo tôi có thể tiếp tục ghi âm thanh trong thời gian dài.

00:07:37.000 --> 00:07:42.000
Cuối cùng, tôi có thể ngừng khớp bằng cách gọi hủy trên managedSession.

00:07:42.000 --> 00:07:47.000
Điều này hủy bỏ mọi nỗ lực trận đấu hiện đang chạy và dừng ghi âm.

00:07:47.000 --> 00:07:48.000
Và thế là xong.

00:07:48.000 --> 00:07:55.000
Với Phiên được quản lý, chỉ cần một vài dòng mã để bắt đầu ghi và nhận kết quả sau khi khớp.

00:07:55.000 --> 00:08:01.000
Quay trở lại ứng dụng của mình, tôi sẽ cập nhật triển khai Matcher để sử dụng managedSession.

00:08:01.000 --> 00:08:13.000
Tôi có thể thay thế tất cả các trường hợp của SHSession bằng SHManagedSession.

00:08:13.000 --> 00:08:20.000
Sau đó, tôi có thể xóa phương pháp cấu hình công cụ âm thanh và cách sử dụng nó.

00:08:20.000 --> 00:08:29.000
Và trong phương pháp khớp, tôi có thể xóa các cuộc gọi để yêu cầu quyền ghi âm và khởi động công cụ âm thanh.

00:08:29.000 --> 00:08:43.000
Cuối cùng, trong phương pháp stopRecording, tôi có thể thay thế mã hiện có để dừng công cụ âm thanh chỉ bằng một cuộc gọi đến phương thức hủy của managedSession.

00:08:43.000 --> 00:08:48.000
Bây giờ, tôi sẽ chạy ứng dụng để đảm bảo mọi thứ vẫn hoạt động như mong đợi.

00:08:48.000 --> 00:08:53.000
Này, Siri, chơi "Push It" của Dukes.

00:08:53.000 --> 00:08:55.000
Siri: Đây là "Push It" của Dukes.

00:08:55.000 --> 00:08:57.000
♪ ♪

00:08:57.000 --> 00:08:58.000
Thật thú vị!

00:08:58.000 --> 00:09:06.000
Mọi thứ vẫn hoạt động tốt, nhưng lần này, mã thậm chí còn tốt hơn và sạch hơn với Phiên được quản lý.

00:09:06.000 --> 00:09:07.000
Đó không phải là tất cả.

00:09:07.000 --> 00:09:11.000
Thậm chí còn có nhiều điều hơn để Quản lý Phiên để nói về.

00:09:11.000 --> 00:09:18.000
Tùy thuộc vào trường hợp sử dụng của bạn, bạn có thể muốn managedSession chuẩn bị trước cho một nỗ lực trận đấu.

00:09:18.000 --> 00:09:23.000
Chuẩn bị một Phiên được Quản lý làm cho phiên phản hồi nhanh hơn khi khớp.

00:09:23.000 --> 00:09:32.000
Nó cũng phân bổ trước các nguồn lực cần thiết cho một trận đấu và, nó bắt đầu ghi âm trước với dự đoán về một nỗ lực trận đấu.

00:09:32.000 --> 00:09:40.000
Để cung cấp cho bạn ý tưởng về lợi ích của việc sử dụng chuẩn bị, đây là dòng thời gian đại diện cho hành vi của phiên mà không cần gọi chuẩn bị.

00:09:40.000 --> 00:09:53.000
Khi bạn yêu cầu kết quả, phiên phân bổ tài nguyên cho nỗ lực trận đấu, sau đó bắt đầu ghi âm, cuối cùng, nó trả về một trận đấu.

00:09:53.000 --> 00:10:00.000
Tuy nhiên, khi bạn gọi chuẩn bị, phiên ngay lập tức phân bổ trước các tài nguyên và bắt đầu ghi âm trước.

00:10:00.000 --> 00:10:07.000
Sau đó, khi bạn yêu cầu kết quả, phiên trả về một trận đấu nhanh hơn trước.

00:10:07.000 --> 00:10:13.000
Để làm điều này bằng mã, tôi có thể chỉ cần gọi phương thức chuẩn bị trước khi yêu cầu kết quả.

00:10:13.000 --> 00:10:20.000
Việc gọi phương thức này hoàn toàn tùy thuộc vào bạn và ShazamKit sẽ thay mặt bạn gọi nếu cần thiết.

00:10:20.000 --> 00:10:25.000
Bây giờ, bạn có thể tự hỏi, "Làm cách nào để theo dõi hành vi hiện tại của phiên?

00:10:25.000 --> 00:10:33.000
"Ví dụ, trong một phiên chạy dài, "làm thế nào để tôi biết nó đang ghi âm hoặc kết hợp hoặc làm điều gì đó khác?"

00:10:33.000 --> 00:10:41.000
Để giải quyết vấn đề này, Phiên được quản lý có một thuộc tính được gọi là trạng thái đại diện cho trạng thái hiện tại của phiên.

00:10:41.000 --> 00:10:49.000
Ba trạng thái là nhàn rỗi, ghi âm trước và khớp.

00:10:49.000 --> 00:10:55.000
Ở trạng thái nhàn rỗi, phiên không ghi âm cũng như không thực hiện nỗ lực trận đấu.

00:10:55.000 --> 00:11:10.000
Đây là trường hợp nếu phiên vừa hoàn thành một lần thử khớp duy nhất hoặc bạn gọi hủy, hoặc phiên kết thúc chuỗi kết quả không đồng bộ khi thực hiện nhiều kết quả.

00:11:10.000 --> 00:11:15.000
Ghi âm trước đại diện cho trạng thái sau khi phiên đã được chuẩn bị.

00:11:15.000 --> 00:11:23.000
Ở trạng thái này, tất cả các tài nguyên cần thiết để kết hợp đã sẵn sàng và phiên đang được ghi lại trước cho một nỗ lực kết hợp.

00:11:23.000 --> 00:11:28.000
Sau đó bạn có thể tiến hành khớp hoặc hủy ghi âm trước.

00:11:28.000 --> 00:11:34.000
Phù hợp là trạng thái có thể thứ ba cho thấy phiên đang thực hiện ít nhất một lần thử kết hợp.

00:11:34.000 --> 00:11:38.000
Cuộc gọi chuẩn bị ở trạng thái này sẽ bị bỏ qua bởi phiên họp.

00:11:38.000 --> 00:11:45.000
Đây là một ví dụ về cách trạng thái managedSession có thể được sử dụng trong SwiftUI để thúc đẩy hành vi xem.

00:11:45.000 --> 00:11:51.000
Ở đây, tôi có triển khai mẫu của chế độ xem phụ từ ứng dụng demo.

00:11:51.000 --> 00:11:58.000
Tôi đã thực hiện các hành vi khác nhau cho chế độ xem này nếu trạng thái không hoạt động hoặc phù hợp.

00:11:58.000 --> 00:12:05.000
Hiện tại, trạng thái của phiên không hoạt động và chế độ xem văn bản được đặt thành Nghe nhạc.

00:12:05.000 --> 00:12:10.000
Ngoài ra, tôi có một điều kiện kiểm tra xem trạng thái có khớp hay không.

00:12:10.000 --> 00:12:18.000
Nếu có, tôi sẽ hiển thị chế độ xem tiến trình và nếu không, tôi sẽ hiển thị nút Tìm hiểu Khiêu vũ.

00:12:18.000 --> 00:12:24.000
Vì trạng thái hiện không hoạt động, nút Tìm hiểu Khiêu vũ được hiển thị.

00:12:24.000 --> 00:12:31.000
Khi tôi nhấn vào nút, trạng thái thay đổi thành khớp và giao diện người dùng của tôi sẽ tự động làm mới.

00:12:31.000 --> 00:12:41.000
Lần này văn bản được đặt thành Khớp và chế độ xem tiến trình sẽ thay thế nút kể từ khi quá trình khớp đã bắt đầu.

00:12:41.000 --> 00:12:50.000
Bất cứ khi nào trạng thái của phiên thay đổi, SwiftUI sẽ tự động làm mới chế độ xem của bạn để phản hồi những thay đổi đó mà không cần làm thêm bất kỳ công việc nào.

00:12:50.000 --> 00:13:00.000
Và điều này là do managedSession phù hợp với Observable, đây là một loại Swift mới giúp các đối tượng tự động truyền đạt các thay đổi của họ cho người quan sát.

00:13:00.000 --> 00:13:06.000
Do đó, SwiftUI có thể dễ dàng phản hồi bất kỳ thay đổi trạng thái nào của managedSession.

00:13:06.000 --> 00:13:12.000
Để tìm hiểu thêm về Observable, hãy xem video Khám phá Quan sát SwiftUI.

00:13:12.000 --> 00:13:19.000
Bây giờ tôi đã đề cập đến nhận dạng âm thanh, tôi sẽ nói về thư viện Shazam.

00:13:19.000 --> 00:13:29.000
Vào năm 2021, ShazamKit đã cung cấp một API cho phép các nhà phát triển viết kết quả khớp với Thư viện Shazam, miễn là nó có ID Shazam hợp lệ.

00:13:29.000 --> 00:13:34.000
Điều này có nghĩa là nó tương ứng với một bài hát trong Danh mục Shazam.

00:13:34.000 --> 00:13:42.000
Mục được thêm vào hiển thị trong mô-đun Nhận dạng Âm nhạc Trung tâm Điều khiển và ứng dụng Shazam nếu được cài đặt.

00:13:42.000 --> 00:13:45.000
Nó cũng được đồng bộ hóa trên các thiết bị.

00:13:45.000 --> 00:13:59.000
Không cần sự cho phép đặc biệt để ghi vào thư viện Shazam, nhưng tôi khuyên bạn nên tránh lưu trữ nội dung trong đó mà không làm cho khách hàng biết, vì tất cả các bài hát được lưu trong thư viện sẽ được quy cho ứng dụng đã thêm chúng.

00:13:59.000 --> 00:14:06.000
Ở đây, bài hát thứ hai trong danh sách được quy cho ứng dụng ShazamKit Dance Finder.

00:14:06.000 --> 00:14:13.000
Trong những năm qua, việc sử dụng API này đã trình bày các trường hợp sử dụng khác nhau và dẫn đến một số nhược điểm.

00:14:13.000 --> 00:14:18.000
Ví dụ, điều gì sẽ xảy ra nếu bạn muốn xem các mục bạn đã thêm vào ứng dụng của riêng mình?

00:14:18.000 --> 00:14:27.000
Giải pháp cần thiết sẽ là quản lý bộ nhớ cục bộ của riêng bạn có thể tẻ nhạt để xử lý và dễ bị lỗi.

00:14:27.000 --> 00:14:32.000
Vì những nhược điểm này, một lớp học mới đã được giới thiệu có tên là SHLibrary.

00:14:32.000 --> 00:14:40.000
Tôi khuyên bạn nên áp dụng SHLibrary, vì nó cung cấp các tính năng mở rộng hơn so với lớp SHMediaLibrary trước đó.

00:14:40.000 --> 00:14:57.000
Một số tính năng cốt lõi của SHLibrary bao gồm thêm các mục phương tiện vào Thư viện Shazam, hoạt động giống như phương pháp tương ứng trong SHMediaLibrary; đọc các mục phương tiện; và xóa các mục phương tiện khỏi thư viện.

00:14:57.000 --> 00:15:02.000
Lưu ý rằng ứng dụng của bạn chỉ có thể đọc và xóa những gì nó đã thêm vào thư viện.

00:15:02.000 --> 00:15:10.000
Các mục được trả lại khi bạn đọc dành riêng cho ứng dụng của bạn và không đại diện cho toàn bộ thư viện.

00:15:10.000 --> 00:15:16.000
Ngoài ra, cố gắng xóa một mục phương tiện mà ứng dụng của bạn chưa thêm vào sẽ gây ra lỗi.

00:15:16.000 --> 00:15:21.000
Tiếp theo, tôi sẽ giải thích cách sử dụng SHLibrary.

00:15:21.000 --> 00:15:29.000
Thêm với SHLibrary cũng đơn giản như gọi phương thức addItems của đối tượng thư viện mặc định.

00:15:29.000 --> 00:15:33.000
Phương pháp này lấy một loạt các mục phương tiện được thêm vào.

00:15:33.000 --> 00:15:36.000
Đọc từ thư viện cũng đơn giản không kém.

00:15:36.000 --> 00:15:42.000
Ví dụ, đây là cách bạn có thể đọc các mục từ thư viện và điền chế độ xem Danh sách vào SwiftUI.

00:15:42.000 --> 00:15:48.000
Bạn chỉ cần chuyển thuộc tính mục của đối tượng thư viện vào trình khởi tạo danh sách.

00:15:48.000 --> 00:15:59.000
SHLibrary cũng phù hợp với loại Swift Observable mới, do đó, chế độ xem SwiftUI của bạn sẽ tự động tải lại khi có thay đổi.

00:15:59.000 --> 00:16:03.000
Bạn cũng có thể đọc từ thư viện trong ngữ cảnh không phải giao diện người dùng.

00:16:03.000 --> 00:16:13.000
Ví dụ: nếu tôi muốn truy xuất thể loại phổ biến nhất của người dùng từ Shazams được đồng bộ hóa của họ, tôi có thể yêu cầu các mục hiện tại của thư viện.

00:16:13.000 --> 00:16:24.000
Sau đó, một khi tôi có cái này, tôi có thể lọc qua mảng các mục để có được tất cả các thể loại được trả về và đếm thể loại có tần suất cao nhất.

00:16:24.000 --> 00:16:34.000
Cuối cùng, tôi có thể xóa các mục khỏi thư viện bằng cách gọi removeItems trên đối tượng thư viện, chuyển vào mảng các mục phương tiện cần xóa.

00:16:34.000 --> 00:16:42.000
Quay trở lại ứng dụng của mình, vì tôi đã thêm các bài hát được nhận dạng vào thư viện của mình, tôi có thể sử dụng SHLibrary mới để đọc những bài hát này.

00:16:42.000 --> 00:16:49.000
Trong RecentDancesView, tôi có một Danh sách chứa một mảng trống của mediaItems trong trình khởi tạo.

00:16:49.000 --> 00:16:58.000
Tôi sẽ thay thế mảng trống bằng các mục từ SHLibrary để tự động đọc các mục thư viện của tôi.

00:16:58.000 --> 00:17:02.000
Tôi sẽ chạy ứng dụng với những thay đổi này.

00:17:02.000 --> 00:17:09.000
Ngay sau khi ứng dụng tải, tôi nhận được danh sách các bài hát mà ứng dụng đã thêm vào Thư viện Shazam.

00:17:09.000 --> 00:17:16.000
Với SHLibrary, tôi nhận được chức năng này miễn phí và tôi không cần duy trì cơ sở dữ liệu các bài hát phù hợp.

00:17:16.000 --> 00:17:24.000
Tiếp theo, tôi sẽ thêm thao tác Vuốt để xóa trên mỗi hàng, vì vậy tôi có thể xóa một bài hát khỏi thư viện.

00:17:24.000 --> 00:17:29.000
Tôi có thể thêm swipeAction vào chế độ xem hàng.

00:17:29.000 --> 00:17:42.000
Sau đó, khi nhấn nút vuốt, tôi có thể gọi phương thức removeItems của SHLibrary, chuyển vào mục phương tiện sẽ bị xóa.

00:17:42.000 --> 00:17:46.000
Bây giờ đã xong, tôi sẽ chạy ứng dụng với những thay đổi này.

00:17:46.000 --> 00:17:49.000
Tôi cũng đã mở ứng dụng trên iPad của mình.

00:17:49.000 --> 00:17:54.000
Tôi có thể vuốt vào một mục trên iPhone của mình và nhấn vào nút xóa.

00:17:54.000 --> 00:18:00.000
Các thay đổi được đồng bộ hóa và mục đã xóa cũng bị xóa khỏi danh sách trên iPad.

00:18:00.000 --> 00:18:02.000
Điều này thật tuyệt vời.

00:18:02.000 --> 00:18:16.000
Bây giờ bạn đã học được cách sử dụng API thư viện mới và cách bạn có thể sử dụng Phiên được quản lý để xử lý ghi âm, tôi sẽ hướng dẫn bạn một số phương pháp hay nhất và đưa ra một số mẹo khi sử dụng một số tính năng mới được giới thiệu trong năm nay.

00:18:16.000 --> 00:18:20.000
SHManagedSession và SHSession có liên quan chặt chẽ với nhau.

00:18:20.000 --> 00:18:25.000
Họ có thể đạt được gần như cùng một điều, mặc dù theo những cách khác nhau.

00:18:25.000 --> 00:18:31.000
Sử dụng managedSession khi bạn muốn để ShazamKit xử lý bản ghi cho bạn.

00:18:31.000 --> 00:18:37.000
Sử dụng SHSession khi bạn đang tạo bộ đệm âm thanh và chuyển chúng vào khung.

00:18:37.000 --> 00:18:43.000
Sử dụng managedSession để nhận dạng âm thanh phát ra từ micrô hoặc AirPod.

00:18:43.000 --> 00:18:49.000
Sử dụng SHSession khi bạn chỉ muốn nhận ra âm thanh phát trực tuyến từ micrô.

00:18:49.000 --> 00:18:54.000
Việc khớp chữ ký tùy ý với managedSession không được hỗ trợ.

00:18:54.000 --> 00:19:02.000
Do đó, nếu bạn có tệp chữ ký hoặc dữ liệu chữ ký được tải trong bộ nhớ, hãy sử dụng SHSession để khớp với nó.

00:19:02.000 --> 00:19:14.000
Cuối cùng, managedSsession tự động xử lý các định dạng âm thanh để kết hợp, trong khi SHSession cho phép kết hợp với nhiều định dạng âm thanh PCM.

00:19:14.000 --> 00:19:27.000
Nói về các định dạng âm thanh trong SHSession, trước đây, phương pháp matchStreamingBuffer chỉ cho phép khớp bộ đệm âm thanh PCM với các cài đặt định dạng cụ thể ở các tốc độ mẫu này.

00:19:27.000 --> 00:19:32.000
Bộ đệm âm thanh với các cài đặt không được hỗ trợ dẫn đến NoMatch.

00:19:32.000 --> 00:19:41.000
Với bản phát hành này, SHSession hiện hỗ trợ bộ đệm PCM với hầu hết các cài đặt định dạng, được lấy mẫu ở một loạt các mức giá.

00:19:41.000 --> 00:19:48.000
Bạn có thể chuyển các bộ đệm này và SHSession sẽ xử lý việc chuyển đổi định dạng cho bạn.

00:19:48.000 --> 00:20:04.000
Cuối cùng, nếu bạn có hai hoặc nhiều bit âm thanh nghe giống nhau trong một danh mục tùy chỉnh, ShazamKit hiện có thể trả về tất cả các kết quả phù hợp từ danh mục tùy chỉnh khi bạn chuyển chữ ký truy vấn khớp với nhiều chữ ký tham chiếu.

00:20:04.000 --> 00:20:12.000
Các trận đấu được trả về, được sắp xếp theo chất lượng trận đấu tốt nhất và bạn có thể lọc cho kết quả trận đấu phù hợp mà bạn muốn.

00:20:12.000 --> 00:20:24.000
Như một mẹo, chú thích đúng các chữ ký tham chiếu nghe giống nhau trong siêu dữ liệu tương ứng của chúng, vì vậy bạn có thể phân biệt giữa kết quả bạn muốn.

00:20:24.000 --> 00:20:27.000
Đây là một ví dụ về cách bạn có thể đạt được điều này.

00:20:27.000 --> 00:20:33.000
Giả sử tôi có một chương trình truyền hình trong đó mỗi tập phim đều có âm thanh giới thiệu giống nhau.

00:20:33.000 --> 00:20:40.000
Tôi có thể tạo một TVShowCatalog với chữ ký tham khảo đại diện cho mỗi tập.

00:20:40.000 --> 00:20:51.000
Tôi có thể tạo một phiên bằng cách sử dụng danh mục này và khi khớp với phần giới thiệu, ShazamKit sẽ trả về kết quả khớp với mediaItems của mỗi tập.

00:20:51.000 --> 00:21:01.000
Sau đó, tôi có thể lọc qua mediaItems và chỉ trả lại mediaItems cho một tập cụ thể, ví dụ như Tập 2.

00:21:01.000 --> 00:21:05.000
Đây là cách chú thích thích hợp giúp ích.

00:21:05.000 --> 00:21:14.000
Bây giờ tôi đã trải qua tất cả các bản cập nhật thú vị trong năm nay, tôi sẽ kết thúc bằng cách chuyển trở lại ứng dụng tuyệt vời của mình và cố gắng học thêm một điệu nhảy nữa.

00:21:14.000 --> 00:21:17.000
Tôi sẽ chuyển sang AirPods của mình và phát một bài hát.

00:21:17.000 --> 00:21:25.000
Vì tôi đang sử dụng Managed Session trong ứng dụng, nó có thể nghe âm thanh đang phát trong AirPod và tìm một video khiêu vũ cho tôi.

00:21:25.000 --> 00:21:35.000
Tôi sẽ nhấn vào điều khiển cảm ứng của AirPods để phát một bài hát và đợi ứng dụng phát hiện âm thanh.

00:21:35.000 --> 00:21:36.000
Ngọt ngào!

00:21:36.000 --> 00:21:43.000
Có vẻ như Dancing Dave đang thể hiện một vài động tác Afrobeat, mà tôi sẽ cố gắng hết sức để học sau buổi nói chuyện này.

00:21:43.000 --> 00:21:47.000
Tôi hy vọng bạn cũng hào hứng như chúng tôi với những cập nhật mới này.

00:21:47.000 --> 00:21:51.000
Cảm ơn bạn đã tham gia, và chúc bạn có một WWDC tuyệt vời.

00:21:51.000 --> 23:59:59.000
♪ ♪

