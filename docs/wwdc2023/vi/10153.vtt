WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:16.000
Alla: Xin chào, tên tôi là Alla Shashkina, và tôi là một kỹ sư trong nhóm Quốc tế hóa.

00:00:16.000 --> 00:00:18.000
Tôi ở đây để giúp bạn về ngôn ngữ.

00:00:18.000 --> 00:00:22.000
Hôm nay chúng ta sẽ mở khóa sức mạnh của thỏa thuận ngữ pháp.

00:00:22.000 --> 00:00:25.000
Ngôn ngữ trong phần mềm tác động đến sự tương tác hàng ngày của chúng ta với nó.

00:00:25.000 --> 00:00:28.000
Các từ trong ứng dụng của bạn rất quan trọng.

00:00:28.000 --> 00:00:34.000
Xử lý ngôn ngữ trong phần mềm có thể khó khăn, đặc biệt là khi bạn không nói ngôn ngữ đó.

00:00:34.000 --> 00:00:41.000
Vào năm 2021, chúng tôi đã giới thiệu các API mới trong Foundation giúp các ứng dụng của bạn có thỏa thuận ngữ pháp.

00:00:41.000 --> 00:00:56.000
Hôm nay, tôi muốn giới thiệu các tính năng mới trong Foundation sẽ mở khóa một mức độ trải nghiệm người dùng khác cho các ứng dụng của bạn thông qua ngôn ngữ tự nhiên chính xác hơn về mặt ngữ pháp, âm thanh tốt hơn và toàn diện hơn.

00:00:56.000 --> 00:00:59.000
Vậy chúng ta hãy đi sâu vào.

00:00:59.000 --> 00:01:04.000
Chúng ta sẽ bắt đầu với một bản tóm tắt rất ngắn về lý do tại sao chúng ta nghĩ rằng việc xử lý thỏa thuận ngữ pháp là quan trọng.

00:01:04.000 --> 00:01:11.000
Chúng tôi sẽ hướng dẫn bạn các ví dụ khác nhau bằng các ngôn ngữ mà chúng tôi đã thêm hỗ trợ kể từ năm 2021.

00:01:11.000 --> 00:01:17.000
Chúng ta sẽ nói về các API mới trong không gian thỏa thuận ngữ pháp và giới thiệu thỏa thuận phụ thuộc.

00:01:17.000 --> 00:01:27.000
Chúng tôi đã tiến thêm một bước nữa và tự hỏi mình, làm thế nào chúng tôi có thể giúp bạn làm cho ngôn ngữ trong ứng dụng của bạn không chỉ đúng ngữ pháp hơn mà còn toàn diện hơn?

00:01:27.000 --> 00:01:32.000
Ngữ pháp không nên là thứ bạn nên lo lắng khi xây dựng ứng dụng của mình.

00:01:32.000 --> 00:01:38.000
Chúng tôi tin rằng các API được thiết kế tốt có thể giúp giảm bớt sự phức tạp về ngôn ngữ và giúp bạn mở rộng quy mô.

00:01:38.000 --> 00:01:45.000
Các từ phong phú và đúng ngữ pháp trong giao diện người dùng của bạn làm cho trải nghiệm người dùng trở nên hoàn hảo và thú vị.

00:01:45.000 --> 00:01:48.000
Các ngôn ngữ khác nhau đưa ra những thách thức riêng của chúng.

00:01:48.000 --> 00:01:55.000
Tất cả sự phức tạp về ngôn ngữ này là những gì chúng tôi xem xét khi thiết kế các API mới.

00:01:55.000 --> 00:02:01.000
Mục tiêu của chúng tôi là đóng gói tất cả những thứ đó vào các giao diện đơn giản, dễ sử dụng.

00:02:01.000 --> 00:02:07.000
Hãy xem xét ngắn gọn cách thỏa thuận ngữ pháp nâng cao trải nghiệm người dùng trên toàn hệ thống bằng các ngôn ngữ khác nhau.

00:02:07.000 --> 00:02:19.000
Các API mới được giới thiệu vào năm 2021 cho phép bạn chỉ định một loạt các từ cần thay đổi dựa trên thuật ngữ địa chỉ ưa thích của người dùng, cũng như các từ khác trong phạm vi có thể thay đổi.

00:02:19.000 --> 00:02:29.000
Nếu người dùng chọn một thuật ngữ địa chỉ nữ tính, iPhone sẽ chào đón cô ấy trong một khung cảnh nữ tính bằng tiếng Tây Ban Nha khi cô ấy thiết lập điện thoại lần đầu tiên.

00:02:29.000 --> 00:02:32.000
Năm ngoái, ba ngôn ngữ nữa đã tham gia tiếng Tây Ban Nha.

00:02:32.000 --> 00:02:39.000
Người dùng nói tiếng Pháp tận hưởng trải nghiệm được cá nhân hóa hơn khi họ chọn điều khoản địa chỉ của mình.

00:02:39.000 --> 00:02:46.000
Phần mềm trong toàn hệ thống sẽ thay đổi các từ để phản ánh điều đó, giống như ví dụ này trong ứng dụng Ghi chú.

00:02:46.000 --> 00:02:50.000
Các chuỗi được cá nhân hóa phổ biến trên toàn bộ trải nghiệm hệ thống.

00:02:50.000 --> 00:03:03.000
Thiết lập điện thoại của bạn, làm việc với Ghi chú được chia sẻ hoặc quản lý Lịch của bạn, ngôn ngữ đang điều chỉnh để phù hợp với cài đặt của bạn, giống như ở đây, bằng tiếng Ý hoặc tiếng Bồ Đào Nha Brazil.

00:03:03.000 --> 00:03:12.000
Năm nay, chúng tôi đã thêm hỗ trợ cho thỏa thuận ngữ pháp cho hai ngôn ngữ mới: tiếng Bồ Đào Nha châu Âu và tiếng Đức.

00:03:12.000 --> 00:03:17.000
Bây giờ hãy nói về những gì mới trong thỏa thuận ngữ pháp trong Foundation năm nay.

00:03:17.000 --> 00:03:21.000
Ngôn ngữ phức tạp, nhưng API tốt thì không.

00:03:21.000 --> 00:03:26.000
Rất thường xuyên, các từ trong giao diện người dùng cần thay đổi hình thức của chúng dựa trên một từ khác.

00:03:26.000 --> 00:03:32.000
Để giúp bạn hình dung nó, hãy để tôi hướng dẫn bạn một ví dụ từ ứng dụng đặt đồ ăn của chúng tôi.

00:03:32.000 --> 00:03:33.000
Đây là tiếng Tây Ban Nha.

00:03:33.000 --> 00:03:38.000
Trong tiếng Tây Ban Nha, tính từ cần đồng ý với danh từ mà chúng mô tả.

00:03:38.000 --> 00:03:44.000
Ở đây, kích thước thức ăn "pequeño" cần phải phù hợp với thực phẩm mà nó mô tả, "ensalada."

00:03:44.000 --> 00:03:52.000
Đây cũng là một trường hợp sử dụng rất phổ biến trong các ngôn ngữ khác, nơi thỏa thuận từ xảy ra giữa một số phần nhất định của bài phát biểu.

00:03:52.000 --> 00:03:57.000
Và vì những từ này được tách ra trong giao diện người dùng, việc xử lý loại thỏa thuận này không hề dễ dàng.

00:03:57.000 --> 00:04:03.000
Chúng tôi đã tạo ra một API mới giúp khắc phục loại thỏa thuận phụ thuộc này một cách dễ dàng.

00:04:03.000 --> 00:04:08.000
Việc sửa chữa rất đơn giản và yêu cầu rất ít thay đổi mã.

00:04:08.000 --> 00:04:15.000
Ở đây, chúng tôi muốn một chuỗi chứa kích thước thực phẩm, "pequeño", đồng ý với tên thực phẩm, "ensalada."

00:04:15.000 --> 00:04:28.000
Năm nay, chúng tôi sẽ giới thiệu một thuộc tính mới cho LocalizationOptions, các khái niệm, cho phép chúng tôi chỉ định các đối tượng ảnh hưởng đến thỏa thuận ngữ pháp, nhưng không được định dạng thành các chuỗi như các đối số.

00:04:28.000 --> 00:04:35.000
Chúng tôi sử dụng khái niệm localizedPhrase cho một giá trị chuỗi mà chúng tôi muốn đồng ý, trong trường hợp này, "ensalada."

00:04:35.000 --> 00:04:42.000
Cuối cùng, chúng ta cần chú thích từ cần uốn cong với agreeWithConcept.

00:04:42.000 --> 00:04:49.000
Giá trị 1 ở đây có nghĩa là chúng tôi đang yêu cầu sự đồng ý về ngữ pháp với đối tượng đầu tiên trong mảng khái niệm.

00:04:49.000 --> 00:04:52.000
Lưu ý rằng chúng tôi sử dụng lập chỉ mục dựa trên 1.

00:04:52.000 --> 00:05:00.000
Thuộc tính agreeWithConcept cũng mới trong năm nay, nhưng bạn có thể sử dụng nó ngay cả khi ứng dụng của bạn chạy trên các thiết bị cũ hơn.

00:05:00.000 --> 00:05:04.000
Khi đó là trường hợp, chúng tôi sẽ đơn giản bỏ qua thuộc tính.

00:05:04.000 --> 00:05:10.000
Bây giờ chúng tôi đã giới thiệu những thay đổi này, hãy xem giao diện người dùng của chúng tôi.

00:05:10.000 --> 00:05:14.000
Quan sát rằng từ "pequeño" đã đổi thành "pequeña."

00:05:14.000 --> 00:05:18.000
Đây là hình thức chính xác để sử dụng khi mô tả "ensalada" bằng tiếng Tây Ban Nha.

00:05:18.000 --> 00:05:25.000
Bây giờ chúng ta hãy nhìn vào những nơi khác mà chúng ta cần cải tiến ngôn ngữ.

00:05:25.000 --> 00:05:36.000
Ở đây trong câu "Salad của chúng tôi chứa rau diếp, pho mát, cà chua và giăm bông", các từ tiếng Tây Ban Nha "nuestro" và "hecho" đều cần phải đồng ý với danh từ "ensalada".

00:05:36.000 --> 00:05:43.000
May mắn thay, chúng tôi chỉ cần tạo điều kiện thuận lợi cho thỏa thuận ngữ pháp trong chuỗi, vì vậy chúng tôi không cần bất kỳ thay đổi mã nào.

00:05:43.000 --> 00:05:49.000
Đầu tiên, hãy làm cho "nuestro" đồng ý với thức ăn bằng cách chú thích nó với thuộc tính inflect.

00:05:49.000 --> 00:05:57.000
Khi chúng ta sử dụng thuộc tính biến tố trên một khối có đối số, nó sẽ cố gắng làm cho mọi từ đồng ý về mặt ngữ pháp với đối số.

00:05:57.000 --> 00:06:02.000
Tuy nhiên, có một từ nữa chúng ta cần thay đổi, "hecho."

00:06:02.000 --> 00:06:10.000
Chúng tôi cố gắng giữ các khối biến tố càng ngắn càng tốt để giúp giải quyết sự mơ hồ, vì vậy chúng tôi không thể chú thích "hecho" bằng inflect: true.

00:06:10.000 --> 00:06:16.000
Năm nay, chúng tôi sẽ giới thiệu một thuộc tính mới khác được gọi là agreeWithArgument.

00:06:16.000 --> 00:06:32.000
Không giống như agreeWithConcept, nơi bạn cần thực hiện các thay đổi đối với cơ sở mã bằng cách chuyển giá trị của tên thực phẩm, thuộc tính agreeWithArgument không yêu cầu bất kỳ thay đổi mã nào và là một cách dễ dàng để tạo điều kiện cho việc thỏa thuận không thể thực hiện được với thuộc tính inflect.

00:06:32.000 --> 00:06:40.000
Chúng ta có thể sử dụng agreeWithArgument để chỉ ra rằng "hecho" nên đồng ý với một lập luận ở nơi khác trong chuỗi.

00:06:40.000 --> 00:06:47.000
Ở đây, giá trị 1 có nghĩa là chúng tôi muốn từ đó đồng ý với đối số đầu tiên trong chuỗi.

00:06:47.000 --> 00:06:54.000
Với những thay đổi này được thực hiện, chúng ta hãy xem lại giao diện người dùng.

00:06:54.000 --> 00:07:01.000
Bây giờ cả hai từ đều được định dạng để đồng ý về mặt ngữ pháp với "ensalada" và chúng tôi sử dụng tiếng Tây Ban Nha hoàn toàn chính xác trong bản địa hóa của mình.

00:07:01.000 --> 00:07:06.000
Tiếp theo, hãy xem xét một ví dụ tương tự nhưng vẫn khác.

00:07:06.000 --> 00:07:08.000
Đây là tiếng Pháp.

00:07:08.000 --> 00:07:13.000
Trong tiếng Pháp, tính từ biểu thị cần phải đồng ý với danh từ mà chúng mô tả.

00:07:13.000 --> 00:07:24.000
Lưu ý rằng các kích thước, cũng như nút có số lượng, đã được cố định cho tiếng Tây Ban Nha vì chúng tôi đã áp dụng các thuộc tính agreeWithConcept và inflect.

00:07:24.000 --> 00:07:27.000
Hãy khắc phục trường hợp trình diễn này bằng tiếng Pháp.

00:07:27.000 --> 00:07:28.000
Việc sửa chữa thực sự dễ dàng.

00:07:28.000 --> 00:07:36.000
Bọc cả tính từ và đối số bằng một biến tố: khối thực và để Công cụ thực hiện phép thuật của nó.

00:07:36.000 --> 00:07:41.000
Et thì đấy, thức ăn đúng ngữ pháp chỉ ngon hơn.

00:07:41.000 --> 00:07:48.000
Tóm lại, thỏa thuận phụ thuộc có thể thay đổi các từ dựa trên các từ khác mà chúng phụ thuộc vào.

00:07:48.000 --> 00:07:57.000
Sử dụng thuộc tính agreeWithConcept khi bạn muốn một từ đồng ý với một từ hoặc cụm từ khác không tồn tại trong cùng một câu.

00:07:57.000 --> 00:08:07.000
Sử dụng thuộc tính agreeWithArgument cho các tình huống mà bạn muốn một từ đồng ý với một từ hoặc cụm từ khác và cả hai đều nằm trong cùng một chuỗi.

00:08:07.000 --> 00:08:12.000
Bây giờ hãy nói về các API mới cho ngôn ngữ hòa nhập.

00:08:12.000 --> 00:08:15.000
Hãy cùng xem lại ứng dụng Caffé của chúng tôi.

00:08:15.000 --> 00:08:20.000
Giả sử, chúng tôi đã chọn một chiếc bánh sandwich nhỏ và một ít nước trái cây cho bữa trưa của mình và đặt hàng.

00:08:20.000 --> 00:08:24.000
Vì chúng tôi thực sự đói, chúng tôi muốn kiểm tra tình trạng giao hàng của mình.

00:08:24.000 --> 00:08:28.000
Có vẻ như Tony sẽ sớm giao đơn đặt hàng của chúng tôi.

00:08:28.000 --> 00:08:33.000
Khi bản địa hóa giao diện người dùng, bạn nên sử dụng ngôn ngữ trung lập về giới tính.

00:08:33.000 --> 00:08:39.000
Đồng thời, việc sử dụng ngôn ngữ giới tính trong giao diện người dùng mang lại cảm giác cá nhân hơn và nghe có vẻ tự nhiên hơn.

00:08:39.000 --> 00:08:45.000
Hãy cố gắng cá nhân hóa chuỗi này cho Tony, người sử dụng đại từ he và him.

00:08:45.000 --> 00:08:51.000
Đầu tiên, chúng ta cần thay đổi mô hình cho người giao hàng để bao gồm thời hạn địa chỉ ưa thích của họ.

00:08:51.000 --> 00:08:58.000
Để thể hiện điều đó, chúng tôi thêm một thuộc tính mới thuộc loại TermOfAddress, mới trong năm nay.

00:08:58.000 --> 00:09:04.000
Sau đó, chúng ta có thể đặt thuật ngữ địa chỉ thành bất kỳ nam tính, nữ tính hoặc trung lập nào.

00:09:04.000 --> 00:09:11.000
Vì chúng tôi muốn đề cập đến Tony bằng cách sử dụng đại từ anh ấy và anh ấy, chúng tôi chọn nam tính.

00:09:11.000 --> 00:09:15.000
Tiếp theo, chúng ta cần chú thích các chuỗi mà đại từ cần thay đổi.

00:09:15.000 --> 00:09:20.000
Để làm điều đó, chúng tôi sử dụng thuộc tính referentConcept mới.

00:09:20.000 --> 00:09:27.000
Giá trị 1 chỉ ra rằng tham chiếu của đại từ phải là khái niệm đầu tiên trong LocalizationOptions.

00:09:27.000 --> 00:09:35.000
Bạn có thể áp dụng referentConcept cho bất kỳ đại từ nhân xưng ngôi thứ ba nào và công cụ sẽ tìm ra thứ để thay thế nó.

00:09:35.000 --> 00:09:40.000
Bây giờ hãy chuyển một khái niệm biến tố termsOfAddress khi biến đổi chuỗi.

00:09:40.000 --> 00:09:47.000
Chúng tôi gán điều này cho thuộc tính khái niệm của LocalizationOptions, giống như chúng tôi đã làm trước đó cho thỏa thuận ngữ pháp.

00:09:47.000 --> 00:09:52.000
Hãy xem điều này thay đổi giao diện người dùng của chúng ta bằng tiếng Anh như thế nào.

00:09:52.000 --> 00:09:57.000
Chú ý cách "của họ" và "họ" đã được thay thế bằng "của anh ấy" và "anh ấy."

00:09:57.000 --> 00:10:01.000
Bạn cũng có thể sử dụng cùng một chuỗi bản địa hóa để chỉ những người khác.

00:10:01.000 --> 00:10:07.000
Sử dụng một thuật ngữ địa chỉ nữ tính khi bạn muốn đề cập đến ai đó sử dụng she và đại từ của cô ấy.

00:10:07.000 --> 00:10:14.000
Và sử dụng một thuật ngữ địa chỉ trung lập khi bạn muốn đề cập đến ai đó sử dụng đại từ họ và họ.

00:10:14.000 --> 00:10:19.000
Bạn cũng có thể cá nhân hóa hơn nữa đại từ bằng cách sử dụng thuật ngữ địa chỉ được bản địa hóa.

00:10:19.000 --> 00:10:26.000
Trong một thuật ngữ địa chỉ được bản địa hóa, bạn phải chỉ định ngôn ngữ mà nó áp dụng, trong trường hợp này là tiếng Anh.

00:10:26.000 --> 00:10:33.000
Và liệt kê tất cả các dạng đại từ mà bạn muốn sử dụng bằng cách sử dụng loại Morphology.Pronoun mới.

00:10:33.000 --> 00:10:37.000
Trong tiếng Anh, chúng ta phải liệt kê năm đại từ.

00:10:37.000 --> 00:10:44.000
Mỗi đại từ bao gồm dạng đại từ trong ngôn ngữ đích và một Hình thái học mô tả khi nào nó nên được sử dụng.

00:10:44.000 --> 00:10:50.000
Vui lòng tham khảo tài liệu của chúng tôi để biết hướng dẫn chi tiết về cách xây dựng đại từ.

00:10:50.000 --> 00:10:55.000
Sử dụng API này là một cách tuyệt vời để nâng cao tính năng cá nhân hóa ứng dụng của bạn.

00:10:55.000 --> 00:11:00.000
Chúng tôi sử dụng kỹ thuật này để điều chỉnh ngôn ngữ được sử dụng trong các chuỗi được bản địa hóa trong iOS.

00:11:00.000 --> 00:11:04.000
Bây giờ hãy để tôi chỉ ra cách tất cả các tính năng mới này đang hoạt động trực tiếp trong một bản demo.

00:11:04.000 --> 00:11:08.000
Tôi hy vọng mọi người đang đói một số món ăn ngon từ ứng dụng Caffè của chúng tôi ngay bây giờ.

00:11:08.000 --> 00:11:15.000
Hãy để tôi khởi chạy nó bằng tiếng Tây Ban Nha.

00:11:15.000 --> 00:11:18.000
Hãy xem có gì trong thực đơn.

00:11:18.000 --> 00:11:23.000
Lần này chúng ta hãy gọi một chiếc bánh pizza.

00:11:23.000 --> 00:11:25.000
Đây là cùng một vấn đề ngữ pháp mà chúng ta vừa thảo luận.

00:11:25.000 --> 00:11:30.000
Trong tiếng Tây Ban Nha, các yếu tố quyết định và tính từ cần phải đồng ý với danh từ.

00:11:30.000 --> 00:11:35.000
Để làm cho hai từ đồng ý với nhau, chúng ta có thể sử dụng inflect: thuộc tính đúng.

00:11:35.000 --> 00:11:40.000
Vì vậy, hãy áp dụng cách khắc phục dễ dàng này cho các từ "nuestro" và "pizza".

00:11:40.000 --> 00:11:52.000
Đầu tiên, hãy xác định vị trí chuỗi này trong Danh mục Chuỗi của chúng tôi.

00:11:52.000 --> 00:12:02.000
Để làm cho "nuestro" đồng ý với lập luận "pizza", chúng tôi đặt cả hai trong một biến tố: khối thực sự.

00:12:02.000 --> 00:12:08.000
Tiếp theo, chúng ta cũng hãy sửa tính từ "hecho" cần đồng ý với "pizza" trong cùng một câu.

00:12:08.000 --> 00:12:12.000
Chúng tôi muốn sử dụng thuộc tính agreeWithArgument ở đây.

00:12:12.000 --> 00:12:18.000
Chúng tôi thường cố gắng giữ sự thay đổi: khối thực sự càng ngắn càng tốt để giúp đỡ với sự mơ hồ.

00:12:18.000 --> 00:12:27.000
Bởi vì "hecho" cách xa khối biến tố, lần này chúng ta cần sử dụng thuộc tính "agreeWithArgument".

00:12:27.000 --> 00:12:35.000
Giá trị của 1 ở đây chỉ ra rằng chúng tôi muốn "hecho" đồng ý với đối số đầu tiên trong chuỗi, trong trường hợp này là "pizza."

00:12:35.000 --> 00:12:43.000
Hãy chạy lại ứng dụng của chúng ta.

00:12:43.000 --> 00:12:48.000
Bây giờ điều này trông giống như một trải nghiệm bản địa hóa tuyệt vời bằng tiếng Tây Ban Nha.

00:12:48.000 --> 00:12:55.000
Bây giờ hãy xem cách chúng ta có thể sử dụng thuộc tính agreeWithConcept mới để sửa kích thước thực phẩm tại đây.

00:12:55.000 --> 00:13:03.000
Vì pizza là nữ tính, tính từ mô tả nó nên là "pequeña".

00:13:03.000 --> 00:13:07.000
Chúng tôi đã xác định Tên bản địa hóa cho kích cỡ thực phẩm.

00:13:07.000 --> 00:13:16.000
Để sửa thỏa thuận, chúng tôi muốn chuyển đổi localizedNames thành một phương thức phù hợp với mặt hàng thực phẩm cụ thể.

00:13:16.000 --> 00:13:22.000
Tiếp theo, chúng tôi muốn chuyển tên thực phẩm khi định dạng SIZE_BUTTON.

00:13:22.000 --> 00:13:27.000
Ở đây, chúng tôi sẽ xác định thuộc tính mới cho LocalizationOptions, khái niệm.

00:13:27.000 --> 00:13:35.000
Các khái niệm là các đối tượng ảnh hưởng đến biến tố ngữ pháp nhưng không được nội suy thành các chuỗi theo cách của các đối số.

00:13:35.000 --> 00:13:45.000
Ở đây, chúng tôi sử dụng khái niệm localizedPhrase để chèn chuỗi mà chúng tôi muốn đồng ý về mặt ngữ pháp.

00:13:45.000 --> 00:13:55.000
Và chúng ta nên nhớ sử dụng các tùy chọn, được xác định khi khởi tạo chuỗi.

00:13:55.000 --> 00:14:04.000
Tiếp theo, chúng tôi muốn sửa đổi danh mục chuỗi tiếng Tây Ban Nha của mình.

00:14:04.000 --> 00:14:16.000
Chúng tôi muốn chú thích điều này với thuộc tính mới agreeWithConcept.

00:14:16.000 --> 00:14:25.000
Ở đây giá trị của 1 chỉ ra rằng chúng tôi muốn đối số này đồng ý với khái niệm đầu tiên mà chúng tôi đã chuyển cho LocalizationOptions.

00:14:25.000 --> 00:14:35.000
Cuối cùng, hãy cập nhật FoodSizeView, nơi người dùng chọn kích thước của chiếc bánh pizza họ muốn, với phương pháp mới.

00:14:35.000 --> 00:14:41.000
Bây giờ hãy chạy lại ứng dụng của chúng tôi và cuối cùng gọi pizza.

00:14:41.000 --> 00:14:45.000
Thật tuyệt vời, kích thước thức ăn của chúng tôi hoàn đồng ý với bánh pizza ở đây.

00:14:45.000 --> 00:14:49.000
Hãy thử bánh sandwich, món nam tính trong tiếng Tây Ban Nha.

00:14:49.000 --> 00:14:51.000
Cái này trông thật tuyệt.

00:14:51.000 --> 00:15:03.000
Bây giờ hãy khởi chạy ứng dụng của chúng tôi bằng tiếng Anh và cuối cùng đặt hàng một chiếc bánh pizza.

00:15:03.000 --> 00:15:07.000
Lần này tôi sẽ chọn một cái lớn.

00:15:07.000 --> 00:15:12.000
Và hãy làm cho nó hai. Tại sao không?

00:15:12.000 --> 00:15:15.000
Có vẻ như Tony sẽ sớm giao đơn hàng của chúng tôi.

00:15:15.000 --> 00:15:21.000
Ngôn ngữ trung lập về giới tính ở đây rất tuyệt, nhưng chúng ta tình cờ biết rằng Tony đã đặt đại từ của mình là anh ấy/anh ấy/của anh ấy.

00:15:21.000 --> 00:15:24.000
Đây là thứ mà chúng ta có thể dễ dàng sửa chữa.

00:15:24.000 --> 00:15:35.000
Để làm điều đó, hãy mở rộng mô hình cho người giao hàng để bao gồm các Điều khoản của Địa chỉ ưa thích.

00:15:35.000 --> 00:15:45.000
Và hãy mở rộng ví dụ của chúng ta về Tony và chỉ ra rằng anh ấy thích sử dụng đại từ nam tính hơn.

00:15:45.000 --> 00:15:52.000
Tiếp theo, chúng tôi muốn thay đổi chính chuỗi.

00:15:52.000 --> 00:15:59.000
Ở đây, chúng tôi muốn thay thế "họ" bằng đại từ tùy thuộc vào điều khoản Địa chỉ của người giao hàng.

00:15:59.000 --> 00:16:07.000
Để làm điều này, chúng tôi sử dụng thuộc tính referentConcept mới.

00:16:07.000 --> 00:16:16.000
Ở đây giá trị của 1 có nghĩa là tham chiếu của đại từ "họ" phải là khái niệm đầu tiên được truyền trong LocalizationOptions.

00:16:16.000 --> 00:16:29.000
Chúng ta có thể áp dụng điều này cho bất kỳ đại từ nhân xưng ngôi thứ ba nào trong câu này.

00:16:29.000 --> 00:16:35.000
Tiếp theo, chúng tôi muốn chuyển các điều khoản của địa chỉ như một khái niệm trong LocalizationOptions.

00:16:35.000 --> 00:16:43.000
Hãy khởi tạo LocalizationOptions cho deliveryMessage.

00:16:43.000 --> 00:16:59.000
Ở đây, chúng tôi cũng có thể sử dụng khái niệm termsOfAddress để cung cấp termsOfAddress mà chúng tôi có thể sử dụng cho thỏa thuận ngữ pháp.

00:16:59.000 --> 00:17:07.000
Và cuối cùng, hãy sử dụng LocalizationOptions mới khi chúng ta khởi tạo chuỗi.

00:17:07.000 --> 00:17:15.000
Bây giờ hãy thử chạy lại ứng dụng của chúng tôi.

00:17:15.000 --> 00:17:19.000
Được rồi, những chiếc pizza khổng lồ, hai.

00:17:19.000 --> 00:17:24.000
Hãy làm cho nó ba.

00:17:24.000 --> 00:17:30.000
Bây giờ chúng tôi đã áp dụng thỏa thuận, điều này trông mang tính cá nhân hơn rất nhiều.

00:17:30.000 --> 00:17:36.000
Có rất nhiều tính năng mới tuyệt vời trong Foundation năm nay và chúng đã sẵn sàng để bạn thử trong các ứng dụng của mình ngay hôm nay.

00:17:36.000 --> 00:17:40.000
Inflect: true hỗ trợ nhiều ngôn ngữ hơn trong năm nay.

00:17:40.000 --> 00:17:49.000
API thỏa thuận phụ thuộc mới của chúng tôi sẽ giúp bạn đồng ý các từ trong cùng một chuỗi hoặc thậm chí hoàn toàn nằm ngoài ngữ cảnh.

00:17:49.000 --> 00:17:58.000
Cuối cùng, khái niệm biến tố termsOfAddress mới và các thuộc tính referentConcept trong Markdown sẽ giúp ngôn ngữ của bạn được cá nhân hóa hơn.

00:17:58.000 --> 00:18:02.000
Vui lòng tham khảo tài liệu của chúng tôi để được hỗ trợ cấp độ ngôn ngữ.

00:18:02.000 --> 00:18:04.000
Tôi hy vọng bạn sẽ thích những tính năng mới này.

00:18:04.000 --> 00:18:08.000
Chúng tôi rất mong sớm được thấy họ làm đẹp ngôn ngữ trong ứng dụng của bạn.

00:18:08.000 --> 00:18:09.000
Cảm ơn bạn.

00:18:09.000 --> 00:18:13.000
Ồ, và bánh pizza của tôi đã đến. Cảm ơn bạn, Tony.

00:18:13.000 --> 23:59:59.000
♪ ♪

