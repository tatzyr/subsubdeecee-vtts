WEBVTT

00:00:00.000 --> 00:00:11.000
♪ ♪

00:00:11.000 --> 00:00:19.000
David: Xin chào, và chào mừng đến với "Có gì mới trong Dữ liệu cốt lõi." Tên tôi là David Stites, và tôi là một kỹ sư trong nhóm Core Data.

00:00:19.000 --> 00:00:33.000
Trong phiên này, bạn sẽ tìm hiểu về các công nghệ mới trong Dữ liệu cốt lõi sẽ giúp bạn thiết kế, truy vấn, cập nhật và di chuyển mô hình dữ liệu cốt lõi trong ứng dụng của mình một cách nhanh chóng và dễ dàng hơn.

00:00:33.000 --> 00:00:56.000
Tôi sẽ bắt đầu bằng cách nói về các thuộc tính tổng hợp, một cách mới tuyệt vời để sắp xếp dữ liệu có cấu trúc trong mô hình ứng dụng của bạn, trước khi nói về cách "giai đoạn" di chuyển mô hình phức tạp nhất của bạn để bạn có thể sử dụng di chuyển nhẹ và tôi sẽ kết thúc với cách trì hoãn di chuyển mô hình của bạn để giữ

00:00:56.000 --> 00:01:01.000
Thuộc tính tổng hợp là một loại thuộc tính mới.

00:01:01.000 --> 00:01:10.000
Các thuộc tính tổng hợp cho phép đóng gói các kiểu dữ liệu phức tạp và tùy chỉnh trong một thuộc tính duy nhất.

00:01:10.000 --> 00:01:23.000
Mỗi thuộc tính tổng hợp bao gồm các thuộc tính của các loại Dữ liệu Cốt lõi tích hợp mà bạn đã quen thuộc, chẳng hạn như Chuỗi, Float, Int và Dữ liệu.

00:01:23.000 --> 00:01:34.000
Các thuộc tính tổng hợp có thể được lồng vào nhau để thuộc tính tổng hợp cấp cao nhất có thể chứa các thuộc tính tổng hợp bổ sung.

00:01:34.000 --> 00:01:46.000
Trình chỉnh sửa mô hình Dữ liệu Lõi Xcode đã được cập nhật để giúp dễ dàng xác định và quản lý các thuộc tính tổng hợp của mô hình của bạn.

00:01:46.000 --> 00:01:55.000
Các thuộc tính tổng hợp là một sự thay thế hấp dẫn cho việc sử dụng các thuộc tính loại có thể chuyển đổi để tạo ra các loại dữ liệu tùy chỉnh bền vững.

00:01:55.000 --> 00:02:00.000
Không cần phải viết mã để biến đổi giá trị của thuộc tính.

00:02:00.000 --> 00:02:13.000
Không giống như các thuộc tính có thể chuyển đổi, các thuộc tính tổng hợp cho phép NSFetchRequests với NSPredicates được cấu hình với các đường dẫn khóa không gian tên của thuộc tính tổng hợp.

00:02:13.000 --> 00:02:25.000
Các thuộc tính tổng hợp có thể được sử dụng để gói gọn sự gia tăng của các thuộc tính phẳng, dẫn đến mã dễ bảo trì và dễ đọc hơn.

00:02:25.000 --> 00:02:29.000
Các thuộc tính tổng hợp có thể được sử dụng để cải thiện hiệu suất của ứng dụng của bạn.

00:02:29.000 --> 00:02:43.000
Nếu mô hình dữ liệu của bạn được cấu tạo theo cách mà việc tìm nạp một thực thể hầu như luôn dẫn đến việc truy cập mối quan hệ với một thực thể khác, bạn có thể tái cấu trúc mối quan hệ đó thành sử dụng các thuộc tính tổng hợp.

00:02:43.000 --> 00:02:53.000
Hiệu quả của việc nhúng một thuộc tính tổng hợp vào thực thể đầu tiên là nó ngăn ngừa lỗi trong các đối tượng trong mối quan hệ.

00:02:53.000 --> 00:02:59.000
Lớp thuộc tính tổng hợp là NSCompositeAttributeDescription.

00:02:59.000 --> 00:03:07.000
Loại thuộc tính cho NSCompositeAttributeDescription là NSCompositeAttributeType.

00:03:07.000 --> 00:03:20.000
Lớp NSCompositeAttributeDescription chứa một mảng, các phần tử, bao gồm NSAttributeDescription hoặc NSCompositeAttributeDescription lồng nhau khác.

00:03:20.000 --> 00:03:28.000
Mảng phần tử không thể chứa các loại mô tả thuộc tính khác, chẳng hạn như NSRelationshipDescription.

00:03:28.000 --> 00:03:36.000
Cố gắng thiết lập các phần tử không hợp lệ sẽ dẫn đến NSInvalidArgumentException.

00:03:36.000 --> 00:03:43.000
Tôi sẽ mô tả cho bạn cách áp dụng các thuộc tính tổng hợp với bản demo.

00:03:43.000 --> 00:03:46.000
Hãy xem xét mô hình dữ liệu cơ bản này với một thực thể Máy bay.

00:03:46.000 --> 00:03:53.000
Nó có một số thuộc tính, bao gồm một thuộc tính màu sắc, là một loại có thể biến đổi.

00:03:53.000 --> 00:04:04.000
Máy biến áp cho loại đó lưu trữ và phân tích cú pháp một chuỗi được định dạng mô tả các màu chính, phụ và thứ ba của máy bay.

00:04:04.000 --> 00:04:14.000
Tôi sẽ cải thiện thực thể này bằng cách thay thế thuộc tính màu sắc bằng thuộc tính tổng hợp colorScheme để lưu trữ màu sơn của máy bay.

00:04:14.000 --> 00:04:25.000
colorScheme là một thuộc tính tổng hợp với các phần tử: Tiểu học, phụ và đại học, mỗi phần tử là một thuộc tính Chuỗi.

00:04:25.000 --> 00:04:33.000
Trong Xcode, tôi sẽ mở một dự án là một ứng dụng tôi sử dụng để theo dõi thời gian bay của mình.

00:04:33.000 --> 00:04:42.000
Mô hình dữ liệu cho ứng dụng đó được cấu hình với thực thể Máy bay mà tôi vừa nói đến, cũng như một vài thực thể khác.

00:04:42.000 --> 00:04:51.000
Để bắt đầu chuyển đổi, trong trình chỉnh sửa mô hình Dữ liệu Cốt lõi, tôi đang thêm một thuộc tính tổng hợp mới có tên colorScheme.

00:04:51.000 --> 00:05:12.000
Trong tổng hợp đó, tôi đang thêm ba thuộc tính chuỗi, chính, phụ và đại học.

00:05:12.000 --> 00:05:34.000
Trong thực thể Máy bay, tôi sẽ thêm thuộc tính tổng hợp và đặt loại thuộc tính đó thành colorScheme.

00:05:34.000 --> 00:05:40.000
Công việc trong mô hình hiện đã hoàn tất và đã đến lúc cập nhật mã.

00:05:40.000 --> 00:05:52.000
Trong quá mục Triển khai Máy bay của mình, tôi đang thêm một thuộc tính mới, @NSManaged var colorScheme, có loại là Từ điển có khóa Chuỗi và Bất kỳ đối tượng nào.

00:05:52.000 --> 00:06:02.000
Khi tôi sử dụng thuộc tính tổng hợp này trong suốt mã, tôi đang truy cập các giá trị bằng ký hiệu từ điển, với tên của thuộc tính làm khóa.

00:06:02.000 --> 00:06:13.000
Ở đây, tôi đang thiết lập thuộc tính colorScheme của máy bay bằng cách sử dụng các phím String chính, phụ và đại học.

00:06:13.000 --> 00:06:24.000
Tương tự, khi tôi định cấu hình NSFetchRequest với NSPredicate, các phần tử của thuộc tính tổng hợp được truy cập thông qua đường dẫn khóa không gian tên.

00:06:24.000 --> 00:06:31.000
Ở đây, colorScheme.primary được sử dụng để lọc trên thuộc tính đó.

00:06:31.000 --> 00:06:37.000
Khi một ứng dụng phát triển, có thể cần phải thay đổi mô hình dữ liệu.

00:06:37.000 --> 00:06:46.000
Việc cập nhật mô hình dữ liệu yêu cầu những thay đổi đó được hiện thực hóa trong lược đồ lưu trữ cơ bản.

00:06:46.000 --> 00:06:55.000
Nếu thuộc tính numPassengers được thêm vào mô hình, bộ nhớ tương ứng phải được cập nhật.

00:06:55.000 --> 00:07:01.000
Quá trình thực hiện thay đổi lược đồ được gọi là di chuyển.

00:07:01.000 --> 00:07:08.000
Sau khi di chuyển, những thay đổi được phản ánh đầy đủ trong bộ nhớ cơ bản.

00:07:08.000 --> 00:07:15.000
Core Data có bộ công cụ di chuyển tích hợp để giúp cập nhật bộ nhớ dữ liệu của ứng dụng với mô hình dữ liệu hiện tại.

00:07:15.000 --> 00:07:29.000
Nói chung, những công cụ này được gọi là "di cư nhẹ". Để tìm hiểu thêm về di chuyển nhẹ, hãy xem "Tiến hóa lược đồ ứng dụng của bạn" từ WWDC 2022.

00:07:29.000 --> 00:07:36.000
Đôi khi, những thay đổi kết hợp đối với mô hình dữ liệu vượt quá khả năng di chuyển nhẹ.

00:07:36.000 --> 00:07:40.000
Giải pháp cho vấn đề này là di chuyển theo giai đoạn.

00:07:40.000 --> 00:08:12.000
API di chuyển theo giai đoạn được thiết kế với một vài mục tiêu: Giúp bạn di chuyển các mô hình dữ liệu phức tạp có các thay đổi lược đồ nhẹ không phù hợp, đơn giản hóa ứng dụng của bạn bằng cách có khả năng xóa hàng nghìn dòng mã liên quan đến di chuyển và cơ sở hạ tầng di chuyển và cung cấp cơ hội cho ứng dụng của bạn có quyền kiểm soát

00:08:12.000 --> 00:08:56.000
Để sử dụng API này, có một số bước bạn sẽ cần thực hiện: Xác định khi nào các thay đổi đối với mô hình của bạn không phù hợp với các hoạt động được hỗ trợ bởi di chuyển nhẹ, phân tách các thay đổi mô hình không phù hợp thành một loạt các thay đổi mô hình phù hợp được hỗ trợ bởi di chuyển nhẹ, mô tả tổng thứ tự của NSMan

00:08:56.000 --> 00:09:07.000
Tại một số thời điểm nhất định trong quá trình di chuyển, quyền kiểm soát thực thi sẽ được cung cấp cho ứng dụng của bạn để thực hiện bất kỳ tác vụ cần thiết nào liên quan đến quá trình di chuyển đó.

00:09:07.000 --> 00:09:14.000
Để xác định khi nào mô hình của bạn có những thay đổi nhẹ không phù hợp, bạn có một số tùy chọn.

00:09:14.000 --> 00:09:23.000
Tùy chọn đầu tiên là xem lại các thay đổi lược đồ theo cách thủ công và đảm bảo mỗi thay đổi đều đủ điều kiện để di chuyển nhẹ.

00:09:23.000 --> 00:09:39.000
Tùy chọn thứ hai là cố gắng mở cửa hàng liên tục với mô hình mới và các tùy chọn di chuyển nhẹ, NSMigratePersistentStores AutomaticallyOption và NSInferMappingModelAutomaticallyOption được đặt thành true.

00:09:39.000 --> 00:09:48.000
Nếu các thay đổi không đủ điều kiện nhẹ, bạn sẽ nhận được NSPersistentStore IncompatibleVersionHashError.

00:09:48.000 --> 00:09:57.000
Lựa chọn cuối cùng là sử dụng NSMappingModel.inferredMappingModel (forSourceModel:destinationModel:).

00:09:57.000 --> 00:10:01.000
Phương thức này trả về mô hình suy ra nếu Core Data có thể tạo ra nó.

00:10:01.000 --> 00:10:05.000
Nếu không, nó trả về số không.

00:10:05.000 --> 00:10:14.000
Xem xét mô hình Máy bay một lần nữa, nó có một thuộc tính mới, flightData, lưu trữ dữ liệu ở định dạng nhị phân.

00:10:14.000 --> 00:10:26.000
Giả sử cần phải phi chuẩn hóa mô hình này và tách tất cả dữ liệu chuyến bay thành loại thực thể riêng của nó, tất cả trong khi vẫn giữ bất kỳ dữ liệu hiện có nào và mối quan hệ với máy bay mà nó được tạo ra.

00:10:26.000 --> 00:10:33.000
Đây là một thay đổi mô hình rất phức tạp và bản thân nó không đủ điều kiện để di chuyển nhẹ.

00:10:33.000 --> 00:10:38.000
Những thay đổi này cần được phân tách để sử dụng di chuyển theo giai đoạn.

00:10:38.000 --> 00:10:54.000
Khi phân tích các thay đổi không nhẹ, mục tiêu là chuyển đổi các tác vụ di chuyển không đủ điều kiện để di chuyển nhẹ thành một chuỗi di chuyển tối thiểu đủ điều kiện để di chuyển nhẹ.

00:10:54.000 --> 00:11:06.000
Mỗi mô hình được giới thiệu sẽ có một hoặc nhiều hoạt động nằm trong khả năng di chuyển nhẹ tạo nên những thay đổi không phù hợp.

00:11:06.000 --> 00:11:18.000
Kết quả là một loạt các di chuyển trong đó mỗi mô hình có thể di chuyển nhẹ nhưng tương đương với di chuyển không phù hợp.

00:11:18.000 --> 00:11:24.000
Quay trở lại ví dụ, tôi đã gắn nhãn mô hình ban đầu ModelV1.

00:11:24.000 --> 00:11:34.000
Việc di chuyển mô hình này sẽ được phân tách bằng cách giới thiệu hai phiên bản mô hình mới, ModelV2 và ModelV3.

00:11:34.000 --> 00:11:44.000
Trong ModelV2, thực thể Máy bay có được một mối quan hệ được gọi là flightParameters, đây là một tập hợp các thực thể FlightData mới được tạo ra.

00:11:44.000 --> 00:11:52.000
Thực thể FlightData có dữ liệu thuộc tính loại nhị phân và mối quan hệ với Máy bay.

00:11:52.000 --> 00:12:06.000
Để bảo toàn dữ liệu hiện có, giai đoạn di chuyển sẽ sao chép dữ liệu từ thực thể Máy bay sang các thực thể FlightData mới và liên kết chúng với Máy bay.

00:12:06.000 --> 00:12:12.000
Mô hình cuối cùng của chúng tôi là ModelV3, được tạo ra từ ModelV2.

00:12:12.000 --> 00:12:24.000
Trong ModelV3, thuộc tính flightData cũ bị xóa khỏi thực thể Máy bay và mô hình được phi chuẩn hóa thành công và tất cả dữ liệu hiện có được bảo toàn.

00:12:24.000 --> 00:12:30.000
Mỗi bước được mô tả đều nằm trong khả năng di chuyển nhẹ.

00:12:30.000 --> 00:12:53.000
Để mô tả tổng thứ tự của các mô hình, hỗ trợ cấp khung Dữ liệu Cốt lõi bao gồm các lớp sau: NSStagedMigrationManager, NSCustomMigrationStage, NSLightweightMigrationStage và NSManagedObjectModelReference.

00:12:53.000 --> 00:13:09.000
Lớp NSStagedMigrationManager gói gọn tổng thứ tự của NSCustomMigrationStage và NSLightweightMigrationStage bổ sung do bạn mô tả.

00:13:09.000 --> 00:13:19.000
Trình quản lý di chuyển theo giai đoạn cũng quản lý vòng lặp sự kiện di chuyển và cung cấp quyền truy cập vào cửa hàng di chuyển thông qua NSPersistentContainer.

00:13:19.000 --> 00:13:32.000
Người quản lý được thêm vào các tùy chọn cửa hàng bằng cách sử dụng khóa NSPersistentStoreStagedMigrationManager OptionKey.

00:13:32.000 --> 00:13:40.000
Các giai đoạn di chuyển tạo thành cơ sở để di chuyển giữa các phiên bản của một mô hình.

00:13:40.000 --> 00:13:53.000
Khi bạn áp dụng di chuyển theo giai đoạn, bạn sẽ mô tả từng phiên bản mô hình thành Core Data bằng cách sử dụng NSCustomMigrationStage hoặc NSLightweightMigrationStage.

00:13:53.000 --> 00:14:04.000
Lớp NSLightweightMigrationStage mô tả một loạt các mô hình không yêu cầu phân tách và đủ điều kiện di chuyển nhẹ.

00:14:04.000 --> 00:14:08.000
Đây có thể sẽ là phần lớn các mô hình của bạn.

00:14:08.000 --> 00:14:16.000
Các giai đoạn di chuyển nhẹ này được sử dụng để bổ sung tổng thứ tự của các mô hình được mô tả cho Dữ liệu cốt lõi.

00:14:16.000 --> 00:14:25.000
Tất cả các phiên bản mô hình nhẹ phải được thể hiện trong một hoặc nhiều NSLightweightMigrationStage's.

00:14:25.000 --> 00:14:39.000
Mỗi phiên bản đã phân tách của mô hình bạn tạo sẽ được biểu diễn bằng NSCustomMigrationStage và chứa tham chiếu mô hình nguồn và tham chiếu mô hình đích.

00:14:39.000 --> 00:14:47.000
NSCustomMigrationStage cung cấp các trình xử lý tùy chọn chạy ngay trước và sau giai đoạn di chuyển.

00:14:47.000 --> 00:14:54.000
Những trình xử lý này cung cấp cho bạn khả năng chạy mã tùy chỉnh trong quá trình di chuyển.

00:14:54.000 --> 00:15:00.000
Di chuyển theo giai đoạn sử dụng lớp NSManagedObjectModelReference.

00:15:00.000 --> 00:15:06.000
Lớp này đại diện cho lời hứa của NSManagedObjectModel.

00:15:06.000 --> 00:15:10.000
Trong quá trình di chuyển, Core Data sẽ thực hiện lời hứa này.

00:15:10.000 --> 00:15:20.000
NSManagedObjectModelReference linh hoạt và có thể được tạo theo nhiều cách khác nhau.

00:15:20.000 --> 00:15:26.000
Mọi NSManagedObjectModelReference cần được khởi tạo với tổng kiểm tra phiên bản.

00:15:26.000 --> 00:15:31.000
Điều này là để xác nhận mô hình đã không vô tình thay đổi.

00:15:31.000 --> 00:15:39.000
Tổng kiểm tra có thể thu được bằng cách sử dụng phương thức NSManagedObjectModel .versionChecksum.

00:15:39.000 --> 00:16:01.000
Ngoài ra, bạn có thể truy xuất tổng kiểm tra phiên bản từ nhật ký xây dựng Xcode trong "Mô hình dữ liệu biên dịch". Tìm kiếm chuỗi "tổng kiểm tra phiên bản". Đối với các mô hình có phiên bản, tổng kiểm tra cũng có sẵn trong VersionInfo.plist của gói NSManagedObjectModel.

00:16:01.000 --> 00:16:10.000
Quay trở lại ví dụ, để bắt đầu sử dụng di chuyển theo giai đoạn, tôi sẽ bắt đầu bằng cách tạo các tham chiếu mô hình cho mỗi trong ba mô hình.

00:16:10.000 --> 00:16:19.000
Tôi đang sử dụng trình khởi tạo chấp nhận tên mô hình và tham chiếu gói, nhưng cũng có các tùy chọn khác.

00:16:19.000 --> 00:16:24.000
Bước tiếp theo là mô tả các giai đoạn di chuyển cần thiết.

00:16:24.000 --> 00:16:35.000
Vì giai đoạn đầu tiên chỉ thêm thuộc tính flightData, có thể được biểu diễn trong giai đoạn nhẹ, vì việc thêm thuộc tính là một thay đổi nhẹ.

00:16:35.000 --> 00:16:47.000
Tuy nhiên, giai đoạn tiếp theo sẽ là giai đoạn tùy chỉnh vì các thay đổi mô hình đã được phân tách thành hai phiên bản mô hình và chúng tôi cần chạy mã tùy chỉnh để bảo toàn dữ liệu hiện có.

00:16:47.000 --> 00:16:56.000
Giai đoạn di chuyển tùy chỉnh được khởi tạo với ModelV2 và ModelV3.

00:16:56.000 --> 00:17:02.000
Trong willMigrateHandler, mã tìm nạp các hàng thực thể trong đó flightData không phải là số không.

00:17:02.000 --> 00:17:21.000
Các loại NSManagedObject và NSFetchRequestResult chung đang được sử dụng thay vì lớp con đối tượng được quản lý bởi Máy bay do thực tế là lớp Máy bay có thể không tồn tại như mong đợi trong quá trình di chuyển.

00:17:21.000 --> 00:17:31.000
Đối với mỗi thực thể Máy bay được tìm nạp, dữ liệu được sao chép vào một phiên bản mới của FlightData và hai thực thể có liên quan và tồn tại.

00:17:31.000 --> 00:17:41.000
Khi kết thúc quá trình thực hiện giai đoạn di chuyển này, lược đồ cửa hàng được cập nhật lên mô hình mới nhất và dữ liệu hiện có đã được giữ nguyên.

00:17:41.000 --> 00:17:53.000
Để hoàn thành việc di chuyển theo giai đoạn, tôi tạo một NSStagedMigrationManager với giai đoạn di chuyển nhẹ và giai đoạn di chuyển tùy chỉnh.

00:17:53.000 --> 00:18:06.000
NSStagedMigrationManager được thêm vào các tùy chọn NSPersistentStoreDescription với khóa NSPersistentStore StagedMigrationManagerOptionKey.

00:18:06.000 --> 00:18:12.000
Các cửa hàng liên tục sau đó được tải để bắt đầu quá trình di chuyển và ảnh hưởng đến lược đồ cửa hàng.

00:18:12.000 --> 00:18:14.000
Và thế là xong.

00:18:14.000 --> 00:18:21.000
Dữ liệu cốt lõi sẽ tự động áp dụng các giai đoạn cần thiết và di chuyển lược đồ cửa hàng.

00:18:21.000 --> 00:18:31.000
Một số di chuyển nhẹ yêu cầu thời gian chạy bổ sung mà ứng dụng của bạn có thể không cung cấp ở phía trước.

00:18:31.000 --> 00:18:38.000
Quá trình chuyển đổi dữ liệu người dùng trong quá trình di chuyển nhẹ không phải là tức thời.

00:18:38.000 --> 00:18:47.000
Ví dụ, nếu việc di chuyển liên quan đến việc sao chép dữ liệu từ cột này sang cột khác hoặc bảng này sang bảng khác, có thể mất một thời gian.

00:18:47.000 --> 00:18:56.000
Điều này có thể dẫn đến trải nghiệm người dùng khó chịu, đặc biệt nếu việc di chuyển được thực hiện tại thời điểm khởi chạy.

00:18:56.000 --> 00:18:59.000
Di chuyển hoãn lại có thể giúp bạn giải quyết vấn đề này.

00:18:59.000 --> 00:19:10.000
API này sẽ cho phép bạn trì hoãn một số công việc được thực hiện trong quá trình di chuyển nhẹ với khả năng hoàn thành công việc bị trì hoãn vào một ngày sau đó.

00:19:10.000 --> 00:19:31.000
Trong quá trình di chuyển nhẹ, nếu một thực thể có chuyển đổi di chuyển yêu cầu dọn dẹp, chẳng hạn như cập nhật chỉ mục hoặc thả một cột sau khi thực hiện sao chép bảng, chuyển đổi bảng này có thể bị trì hoãn cho đến khi bạn cho rằng các tài nguyên có sẵn để thực hiện chuyển đổi bảng.

00:19:31.000 --> 00:19:36.000
Sự di chuyển nhẹ vẫn đồng bộ và xảy ra bình thường.

00:19:36.000 --> 00:19:39.000
Chỉ có việc dọn dẹp lược đồ được hoãn lại.

00:19:39.000 --> 00:19:44.000
Ứng dụng của bạn sẽ sử dụng lược đồ mới nhất như bình thường.

00:19:44.000 --> 00:19:55.000
Để chọn tham gia di chuyển hoãn lại, hãy đặt NSPersistentStore DeferredLightweightMigrationOptionKey trong các tùy chọn cửa hàng thành true.

00:19:55.000 --> 00:20:06.000
API di chuyển bị trì hoãn có khả năng tương thích thời gian chạy trở lại macOS Big Sur và iOS 14.

00:20:06.000 --> 00:20:13.000
Di chuyển hoãn chỉ khả dụng cho các loại cửa hàng SQLite.

00:20:13.000 --> 00:20:34.000
Một số ví dụ về nơi di chuyển hoãn có thể hữu ích bao gồm: Xóa các thuộc tính hoặc mối quan hệ khỏi một thực thể, thay đổi các mối quan hệ trong đó hệ thống phân cấp thực thể không còn tồn tại và thay đổi các mối quan hệ từ được sắp xếp thành không có thứ tự.

00:20:34.000 --> 00:20:39.000
Để hoàn thành các tác vụ di chuyển bị trì hoãn, hãy kiểm tra siêu dữ liệu lưu trữ liên tục.

00:20:39.000 --> 00:20:52.000
Nếu nó chứa khóa NSPersistentStore DeferredLightweightMigrationOptionKey, đó là tín hiệu cho bạn rằng có công việc di chuyển hoãn cần được hoàn thành.

00:20:52.000 --> 00:21:02.000
Việc di chuyển bị trì hoãn có thể được xử lý bằng cách gọi NSPersistentStoreCoordinator .finishDeferredLightweightMigration.

00:21:02.000 --> 00:21:16.000
Để trì hoãn bất kỳ việc di chuyển nhẹ nào trong ứng dụng của bạn, hãy đặt NSPersistentStoreDeferred LightweightMigrationOptionKey thành true trong các tùy chọn cửa hàng của bạn khi thêm cửa hàng liên tục vào điều phối viên.

00:21:16.000 --> 00:21:25.000
Khi đây là thời điểm tốt để hoàn thành việc di chuyển hoãn lại, bạn có thể kiểm tra xem liệu có công việc hoãn lại đang chờ xử lý hay không bằng cách kiểm tra siêu dữ liệu cho cửa hàng.

00:21:25.000 --> 00:21:37.000
Nếu NSPersistentStoreDeferredLightweight MigrationOptionKey được đặt thành true, thì hãy gọi finishDeferredLightweightMigration().

00:21:37.000 --> 00:21:43.000
Để lên lịch các tác vụ di chuyển bị trì hoãn của bạn, hãy cân nhắc sử dụng API Nhiệm vụ Nền.

00:21:43.000 --> 00:21:51.000
BGProcessingTask dành cho các hoạt động tốn thời gian như cập nhật dữ liệu lâu dài và bảo trì ứng dụng.

00:21:51.000 --> 00:21:55.000
Hệ thống sẽ xác định thời điểm tốt nhất để thực hiện nhiệm vụ của bạn.

00:21:55.000 --> 00:22:08.000
Tuy nhiên, nói chung các tác vụ xử lý chỉ chạy trên thiết bị khi nó không hoạt động và sẽ chấm dứt bất kỳ tác vụ xử lý nền nào khi người dùng bắt đầu sử dụng thiết bị.

00:22:08.000 --> 00:22:12.000
Di chuyển hoãn lại và theo giai đoạn có thể được kết hợp.

00:22:12.000 --> 00:22:22.000
Nếu bạn có một tập hợp các di chuyển phức tạp có thể mất một lúc, hãy cân nhắc thiết kế các giai đoạn tận dụng cả hai khả năng của API.

00:22:22.000 --> 00:22:34.000
Quay trở lại mô hình ví dụ, trong ModelV3, nơi chúng tôi xóa thuộc tính flightData, điều này có thể tạo ra một ứng cử viên di chuyển hoãn lại tốt.

00:22:34.000 --> 00:22:39.000
Có ba công nghệ mới tuyệt vời trong Core Data.

00:22:39.000 --> 00:23:01.000
Đóng gói các loại dữ liệu tùy chỉnh của bạn theo cách lồng nhau, có cấu trúc bằng cách sử dụng các thuộc tính tổng hợp, thực hiện di chuyển mô hình phức tạp bằng cách di chuyển theo giai đoạn bằng cách phân tách các thay đổi mô hình của bạn và tăng tốc hiệu suất ứng dụng của bạn bằng cách trì hoãn một số công việc di chuyển bằng cách sử dụng di chuyển hoãn

00:23:01.000 --> 00:23:06.000
Cả ba công nghệ đều hoạt động hài hòa để cải thiện ứng dụng của bạn.

00:23:06.000 --> 00:23:11.000
Nhóm của chúng tôi rất vui khi biết cách bạn sử dụng những công nghệ mới này.

00:23:11.000 --> 00:23:15.000
Cảm ơn vì đã xem, và chúc bạn có một WWDC tuyệt vời.

00:23:15.000 --> 23:59:59.000
♪ ♪

