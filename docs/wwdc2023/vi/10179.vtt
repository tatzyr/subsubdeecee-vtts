WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:15.000
Erin: Xin chào! Tên tôi là Erin, và tôi là một Kỹ sư trong nhóm CoreMotion.

00:00:15.000 --> 00:00:19.000
Tôi rất vui được kể cho bạn nghe về một số cập nhật thú vị cho CoreMotion.

00:00:19.000 --> 00:00:24.000
CoreMotion đóng vai trò là khuôn khổ trung tâm để truy cập dữ liệu chuyển động từ các cảm biến quán tính.

00:00:24.000 --> 00:00:29.000
Khi phần cứng của chúng tôi đã tiến bộ, khả năng nắm bắt thông tin chuyển động của chúng tôi cũng vậy.

00:00:29.000 --> 00:00:38.000
Phát hiện va chạm, phát hiện té ngã và âm thanh không gian chỉ là một số tính năng dựa trên khả năng cảm biến được cải thiện.

00:00:38.000 --> 00:00:43.000
Với CoreMotion, bạn cũng có thể tận dụng những cải tiến này trong các ứng dụng của riêng mình.

00:00:43.000 --> 00:00:55.000
Trong phần này, tôi sẽ tập trung vào một số cách mới hơn mà bạn có thể tương tác với dữ liệu chuyển động, nhưng trước khi tôi tìm hiểu những gì mới, tôi muốn nhắc nhở bạn nhanh về các cảm biến tạo ra dữ liệu chuyển động.

00:00:55.000 --> 00:00:59.000
Nắm bắt cách một thiết bị di chuyển là trọng tâm của cách chúng ta trải nghiệm chúng.

00:00:59.000 --> 00:01:06.000
Nhiều thiết bị của Apple sử dụng cảm biến tích hợp để giúp tạo ra khái niệm về chuyển động của chúng trong không gian.

00:01:06.000 --> 00:01:08.000
Lấy Apple Watch làm ví dụ.

00:01:08.000 --> 00:01:23.000
Các cảm biến tích hợp của nó bao gồm gia tốc kế, đo gia tốc, con quay hồi chuyển, đo vòng quay, từ kế, đo từ trường và phong vũ biểu, đo áp suất.

00:01:23.000 --> 00:01:28.000
Cùng nhau, chúng giúp theo dõi cách thiết bị di chuyển và định hướng trong không gian.

00:01:28.000 --> 00:01:34.000
Tạo ra ý tưởng về chuyển động của thiết bị là nền tảng cho nhiều tính năng mà chúng tôi thích.

00:01:34.000 --> 00:01:40.000
Chúng bao gồm những thứ như theo dõi số bước bạn đã thực hiện ngày hôm đó và lượng calo bạn đã đốt cháy trong quá trình tập luyện.

00:01:40.000 --> 00:01:48.000
Nó hỗ trợ các trải nghiệm dựa trên hướng của thiết bị, như với ứng dụng ngắm sao để khám phá các vì sao trên bầu trời của chúng ta.

00:01:48.000 --> 00:01:57.000
Các tính năng giúp chúng ta an toàn bằng cách phát hiện khi bạn gặp tai nạn xe hơi hoặc khi bạn bị ngã, cũng dựa vào việc theo dõi chuyển động bằng cách sử dụng các cảm biến tương tự.

00:01:57.000 --> 00:02:04.000
Đây chỉ là một số trong nhiều ứng dụng có thể thực hiện được và chúng tôi luôn mong muốn được xem cách bạn tận dụng CoreMotion.

00:02:04.000 --> 00:02:19.000
Bây giờ tôi đã cung cấp cho bạn một cái nhìn tổng quan ngắn gọn về một số cảm biến có liên quan, tôi sẽ xem xét việc lấy dữ liệu chuyển động từ các sản phẩm âm thanh như AirPods, cập nhật dữ liệu ngâm nước và cuối cùng là một cách mới để truyền dữ liệu cảm biến tốc độ cao hơn.

00:02:19.000 --> 00:02:22.000
Hãy bắt đầu với chuyển động của tai nghe.

00:02:22.000 --> 00:02:30.000
Cách đây không lâu, âm thanh không gian với tính năng theo dõi đầu động đã thay đổi cách chúng ta trải nghiệm âm nhạc và phim ảnh.

00:02:30.000 --> 00:02:37.000
Theo dõi đầu động dựa trên cùng một thuật toán chuyển động của thiết bị tồn tại trên iPhone và Apple Watch.

00:02:37.000 --> 00:02:47.000
Khi CMHeadphoneMotionManager được giới thiệu cách đây vài năm, cùng một dữ liệu giúp bạn có thể theo dõi đầu động.

00:02:47.000 --> 00:02:57.000
Bằng cách phát trực tuyến thái độ, tăng tốc của người dùng và dữ liệu tốc độ quay sang thiết bị iOS hoặc iPadOS được kết nối, bạn có thể theo dõi cách đầu mình di chuyển.

00:02:57.000 --> 00:03:02.000
Theo dõi đầu đã mở khóa rất nhiều tính năng thú vị, từ chơi game đến các ứng dụng thể dục.

00:03:02.000 --> 00:03:08.000
Và bây giờ, năm nay, CMHeadphoneMotionManager đang đến với macOS.

00:03:08.000 --> 00:03:10.000
Hãy xem qua một số chi tiết.

00:03:10.000 --> 00:03:17.000
CMHeadphoneMotionManager lần đầu tiên được cung cấp trong iOS và iPadOS 14.

00:03:17.000 --> 00:03:21.000
Và bắt đầu từ năm nay, nó cũng sẽ đến với macOS 14.

00:03:21.000 --> 00:03:35.000
Bạn có thể sử dụng CMHeadphoneMotionManager để truyền chuyển động của thiết bị từ các sản phẩm âm thanh hỗ trợ âm thanh không gian với tính năng theo dõi đầu động, như AirPods Pro, đến thiết bị iOS, iPadOS hoặc macOS được kết nối.

00:03:35.000 --> 00:03:47.000
Kiểm tra CMDeviceMotion để biết thái độ, khả năng tăng tốc của người dùng và dữ liệu tốc độ quay trong quá trình phát trực tuyến từ các thiết bị được hỗ trợ, giống như bạn làm trên iPhone và Apple Watch.

00:03:47.000 --> 00:03:59.000
Lưu ý thông tin bổ sung cụ thể cho CMHeadphoneMotionManager, như SensorLocation, giúp xác định nguồn dữ liệu ở đâu, cho dù đó là từ chồi trái hay bên phải.

00:03:59.000 --> 00:04:05.000
Bởi vì dữ liệu được truyền từ một thiết bị từ xa, điều quan trọng là phải hiểu khi nào nó được kết nối.

00:04:05.000 --> 00:04:11.000
CMHeadphoneMotionManagerDelegate giúp bạn dễ dàng nghe các bản cập nhật trạng thái kết nối.

00:04:11.000 --> 00:04:14.000
Để tôi chỉ cho bạn cách sử dụng nó.

00:04:14.000 --> 00:04:20.000
Áp dụng giao thức CMHeadphoneMotionManagerDelegate để phản hồi các bản cập nhật trạng thái kết nối.

00:04:20.000 --> 00:04:27.000
Dữ liệu có sẵn khi thiết bị âm thanh được kết nối với thiết bị phát trực tuyến được hỗ trợ, như iPhone, iPad hoặc Mac.

00:04:27.000 --> 00:04:33.000
Nếu tính năng Phát hiện tai tự động được bật, bạn cũng sẽ nhận được các sự kiện ảnh hưởng đến việc theo dõi đầu.

00:04:33.000 --> 00:04:39.000
Bạn sẽ nhận được một sự kiện ngắt kết nối khi các chồi được lấy ra khỏi tai và một sự kiện kết nối khi chúng được đưa trở lại.

00:04:39.000 --> 00:04:48.000
Tương tự, nếu tính năng phát hiện đầu tự động được bật, việc đeo và tháo tai nghe qua tai sẽ kích hoạt những sự kiện này.

00:04:48.000 --> 00:04:55.000
Thiết lập CMHeadphoneMotionManager để lắng nghe những sự kiện này và truyền dữ liệu thật dễ dàng. Để tôi chỉ cho bạn cách làm.

00:04:55.000 --> 00:05:05.000
Trước khi bắt đầu phát trực tuyến, bạn sẽ muốn đảm bảo rằng dữ liệu chuyển động của thiết bị có sẵn, có thể được kiểm tra bằng thuộc tính isDeviceMotionAvailable.

00:05:05.000 --> 00:05:09.000
Chỉ định một đại biểu để nhận các sự kiện kết nối mà tôi đã nói trước đó.

00:05:09.000 --> 00:05:11.000
Sau đó, bắt đầu phát trực tuyến dữ liệu.

00:05:11.000 --> 00:05:16.000
CMHeadphoneMotionManager hiển thị cả giao diện đẩy và kéo để lấy dữ liệu.

00:05:16.000 --> 00:05:19.000
Trong ví dụ này, chúng ta sẽ sử dụng giao diện đẩy.

00:05:19.000 --> 00:05:24.000
Sử dụng startDeviceMotionUpdates và chỉ định một hàng đợi và trình xử lý hoạt động.

00:05:24.000 --> 00:05:29.000
Bởi vì bạn đang truy cập dữ liệu chuyển động, ủy quyền rất quan trọng.

00:05:29.000 --> 00:05:38.000
Người dùng ứng dụng của bạn được nhắc ủy quyền cho ứng dụng của bạn cho dữ liệu chuyển động bằng cách sử dụng phím Mô tả Sử dụng Chuyển động mà bạn thêm vào Info.plist của mình.

00:05:38.000 --> 00:05:47.000
Bạn có thể kiểm tra thuộc tính authorizationStatus để xác nhận xem bạn đã được ủy quyền cho dữ liệu chuyển động hay chưa và cung cấp trải nghiệm liền mạch bất kể mức độ cho phép.

00:05:47.000 --> 00:05:56.000
Khi bạn được ủy quyền và dữ liệu bắt đầu phát trực tuyến, việc theo dõi tư thế đầu rất dễ dàng bằng cách sử dụng thông tin thái độ được cung cấp với mỗi bản cập nhật chuyển động của thiết bị.

00:05:56.000 --> 00:06:08.000
Ví dụ, chúng ta có thể theo dõi thái độ tham chiếu khi bắt đầu Đặt và sử dụng phương pháp nhân để thuận tiện có được sự thay đổi tương đối của mẫu hiện tại đối với tư thế ban đầu đó.

00:06:08.000 --> 00:06:18.000
Cùng với thái độ, gia tốc của người dùng và dữ liệu tốc độ quay, mỗi bản cập nhật chuyển động của thiết bị chứa thông tin vị trí cảm biến.

00:06:18.000 --> 00:06:24.000
Điều này rất quan trọng vì dữ liệu chuyển động được gửi đến bạn từ một chồi tại một thời điểm.

00:06:24.000 --> 00:06:31.000
Danh sách SensorLocation được phân phối cùng với mỗi mẫu cho phép bạn xác định chồi nào có nguồn gốc từ dữ liệu.

00:06:31.000 --> 00:06:39.000
Chồi phát trực tuyến dữ liệu có thể bị ảnh hưởng bởi một số thứ, bao gồm cả trạng thái trong tai nếu tính năng Phát hiện tai tự động được bật.

00:06:39.000 --> 00:06:49.000
Ví dụ, nếu dữ liệu đang phát trực tuyến từ chồi phải của tôi nhưng tôi lấy nó ra khỏi tai khi bật tính năng Phát hiện tai tự động, thì chồi trái của tôi sẽ tiếp quản luồng dữ liệu.

00:06:49.000 --> 00:06:53.000
Điều này cho phép trải nghiệm theo dõi đầu liền mạch hơn.

00:06:53.000 --> 00:06:57.000
Theo dõi đầu thuận tiện đã mở ra cánh cửa cho rất nhiều trải nghiệm khác nhau.

00:06:57.000 --> 00:07:03.000
Những thứ như đếm số lần chống đẩy bạn đã làm hoặc theo dõi tư thế đã trở nên dễ dàng hơn bao giờ hết.

00:07:03.000 --> 00:07:12.000
Và bây giờ, với sự hỗ trợ của macOS, bạn có thể truyền dữ liệu chuyển động từ các sản phẩm âm thanh hỗ trợ theo dõi đầu đến phạm vi thiết bị thậm chí còn rộng hơn.

00:07:12.000 --> 00:07:17.000
Chúng tôi rất vui khi thấy những gì bạn xây dựng bằng cách sử dụng CMHeadphoneMotionManager.

00:07:17.000 --> 00:07:22.000
Bây giờ, bạn không cần phải đo áp lực để theo dõi cách đầu bạn di chuyển, nhưng một cái gì đó khác thì có.

00:07:22.000 --> 00:07:31.000
Tôi sẽ nói về những cách bạn có thể tương tác với các hoạt động dựa trên nước bằng cách sử dụng một số cập nhật thú vị cho CMWaterSubmersionManager.

00:07:31.000 --> 00:07:40.000
Trong các hoạt động dưới nước như lặn với ống thở hoặc bơi lội, có rất nhiều điều thú vị cần biết về nước và trạng thái ngâm nước của bạn.

00:07:40.000 --> 00:07:45.000
Bạn có thể quan tâm đến độ sâu của bạn và nhiệt độ nước là bao nhiêu.

00:07:45.000 --> 00:07:54.000
Nó cũng hữu ích để biết khi nào bạn bị ngập nước hoặc nếu bạn đã thoát nước trở lại bờ hoặc một chiếc thuyền, và áp suất không khí bề mặt trong quá trình hoạt động của bạn là bao nhiêu.

00:07:54.000 --> 00:08:02.000
Sử dụng phong vũ biểu tích hợp, CMWaterSubmersionManager có thể theo dõi các chỉ số này cho bạn trong các hoạt động dựa trên nước của bạn.

00:08:02.000 --> 00:08:04.000
Để tôi cung cấp cho bạn một số chi tiết.

00:08:04.000 --> 00:08:10.000
CMWaterSubmersionManager có sẵn trên Apple Watch Ultra chạy watchOS 9.

00:08:10.000 --> 00:08:18.000
Sử dụng CMWaterSubmersionManagerDelegate để lắng nghe dữ liệu về độ sâu, nhiệt độ và trạng thái chìm.

00:08:18.000 --> 00:08:29.000
Đảm bảo thêm khả năng Độ sâu và Áp lực Nông vào ứng dụng của bạn và có được trải nghiệm liền mạch khi người dùng ứng dụng của bạn bắt đầu các hoạt động trên nước của họ bằng cách định cấu hình cài đặt Tự động Khởi chạy.

00:08:29.000 --> 00:08:34.000
Hãy để tôi chỉ cho bạn cách bắt đầu sử dụng CMWaterSubmersionManager.

00:08:34.000 --> 00:08:42.000
Để bắt đầu theo dõi trạng thái ngập nước, hãy thiết lập CMWaterSubmersionManager sau khi kiểm tra tính khả dụng.

00:08:42.000 --> 00:08:47.000
Sau đó, chỉ định một đại biểu để bắt đầu nhận thông tin cập nhật về trạng thái chìm và các sự kiện.

00:08:47.000 --> 00:08:50.000
Hãy nói một chút về cách nhận những cập nhật đó.

00:08:50.000 --> 00:08:55.000
Nhận cập nhật rất đơn giản bằng cách sử dụng CMWaterSubmersionManagerDelegate.

00:08:55.000 --> 00:08:59.000
Có một số loại cập nhật khác nhau mà bạn có thể nhận được.

00:08:59.000 --> 00:09:08.000
Các cập nhật cho trạng thái chìm, như khi bạn vào và ra khỏi nước, được phân phối bằng phương pháp didUpdate với CMWaterSubmersionEvent.

00:09:08.000 --> 00:09:19.000
Bạn sẽ nhận được lỗi cập nhật xảy ra khi có sự cố, chẳng hạn như nếu bạn cố gắng nhận bản cập nhật khi ứng dụng của bạn thiếu quyền hoặc đang ở trên nền tảng không được hỗ trợ.

00:09:19.000 --> 00:09:23.000
Cập nhật nhiệt độ nước được cung cấp bằng CMWaterTemperature.

00:09:23.000 --> 00:09:30.000
Chúng đi kèm với một khái niệm về sự không chắc chắn, vì phải mất vài giây để nhiệt độ đồng hồ cân bằng với nước.

00:09:30.000 --> 00:09:38.000
Vì vậy, khi bạn lần đầu tiên bị nhấn chìm, sự không chắc chắn sẽ cao hơn và sau đó bắt đầu hội tụ khi bạn đã dành nhiều thời gian hơn trong nước.

00:09:38.000 --> 00:09:42.000
Lưu ý rằng nhiệt độ nước chỉ có sẵn khi ngập nước.

00:09:42.000 --> 00:09:50.000
Bạn sẽ nhận được các cập nhật về độ sâu, áp suất, áp suất bề mặt và trạng thái chìm với CMWaterSubmersionMeasurement.

00:09:50.000 --> 00:09:56.000
Trong quá trình hoạt động chìm của bạn, các phép đo được chuyển đến ứng dụng của bạn đều đặn.

00:09:56.000 --> 00:10:03.000
Lưu ý rằng một số dữ liệu này, như độ sâu, chỉ áp dụng khi bạn ở trạng thái chìm, vì vậy đây là tùy chọn.

00:10:03.000 --> 00:10:07.000
Độ sâu dưới nước tương ứng với các trạng thái độ sâu nhất định.

00:10:07.000 --> 00:10:10.000
Hãy để tôi chỉ cho bạn cách chúng được lập bản đồ.

00:10:10.000 --> 00:10:14.000
Hãy bắt đầu với trạng thái ra khỏi nước, khi bạn ở trạng thái không chìm.

00:10:14.000 --> 00:10:18.000
Trên 1 mét dưới nước, bạn đang ở trạng thái Shallow chìm.

00:10:18.000 --> 00:10:21.000
Vượt quá 1 mét, bạn đang ở trạng thái chìm sâu.

00:10:21.000 --> 00:10:31.000
Với khả năng Độ sâu và Áp suất Nông, thật dễ dàng để đảm bảo người dùng ứng dụng của bạn ở trong vùng sâu để giảm thiểu nguy cơ bệnh giải nén.

00:10:31.000 --> 00:10:36.000
Nó giữ độ sâu tối đa ở mức 6 mét và cho bạn biết khi nào bạn ở gần độ sâu đó.

00:10:36.000 --> 00:10:41.000
Bạn có thể sử dụng thuộc tính độ sâu tối đa để kiểm tra độ sâu đang được theo dõi.

00:10:41.000 --> 00:10:45.000
Khi bạn đến gần 6 mét, bạn sẽ bước vào trạng thái MaxDepth đang đến gần.

00:10:45.000 --> 00:10:49.000
Vượt quá 6 mét, bạn đang ở trạng thái MaximumDepth trong quá khứ.

00:10:49.000 --> 00:10:55.000
Dữ liệu được treo xuống 6 mét, cộng với một số điều không chắc chắn ở trạng thái MaxDepth trong quá khứ.

00:10:55.000 --> 00:10:58.000
Ngoài ra, bạn đang ở trạng thái sensorDepthError.

00:10:58.000 --> 00:11:08.000
Bằng cách chia độ sâu thành các vùng, CMWaterSubmersionManager giúp dễ dàng theo dõi những thay đổi về độ sâu với trọng tâm là giới hạn an toàn và cảm biến.

00:11:08.000 --> 00:11:17.000
Nếu bạn quan tâm đến các trường hợp sử dụng vượt quá độ sâu tối đa 6 mét, bạn có thể xem tài liệu để biết thêm thông tin về quyền được quản lý.

00:11:17.000 --> 00:11:24.000
Cho dù bạn chọn cách nào, việc tạo ra những trải nghiệm tuyệt vời cho các môn thể thao dưới nước dễ dàng hơn bao giờ hết với CMWaterSubmersionManager.

00:11:24.000 --> 00:11:35.000
Tuy nhiên, cũng có rất nhiều môn thể thao ngoài nước và tôi rất vui được chia sẻ cách sử dụng dữ liệu chuyển động tốc độ cao trong các hoạt động này bằng cách sử dụng CMBatchedSensorManager.

00:11:35.000 --> 00:11:37.000
Trước tiên hãy bắt đầu với một số thông tin cơ bản.

00:11:37.000 --> 00:11:41.000
Tôi đã nói qua một số cách dữ liệu chuyển động được gửi đến bạn.

00:11:41.000 --> 00:11:52.000
Các thuật toán chuyển động của thiết bị kết hợp dữ liệu từ gia tốc kế và con quay hồi chuyển tích hợp để cung cấp một cách dễ dàng để theo dõi cách một thiết bị, như Apple Watch, đang di chuyển trong không gian.

00:11:52.000 --> 00:12:00.000
Bạn có thể quen thuộc với CMMotionManager, công ty cung cấp các mẫu này trên cơ sở mỗi mẫu cho ứng dụng của bạn trong thời gian thực.

00:12:00.000 --> 00:12:03.000
Tần số được hỗ trợ tối đa là 100 Hz.

00:12:03.000 --> 00:12:13.000
Điều này có nghĩa là nó là một lựa chọn tuyệt vời nếu bạn có yêu cầu độ trễ thấp, chẳng hạn như các thành phần giao diện người dùng dựa trên thái độ tức thời của thiết bị.

00:12:13.000 --> 00:12:21.000
Bây giờ, điều này so sánh như thế nào với cách chúng tôi cung cấp dữ liệu tốc độ cao bằng cách sử dụng CMBatchedSensorManager mới?

00:12:21.000 --> 00:12:28.000
CMBatchedSensorManager cung cấp các lô dữ liệu cảm biến theo một lịch trình cố định, cung cấp một lô dữ liệu mỗi giây.

00:12:28.000 --> 00:12:33.000
Điều này có nghĩa là chúng tôi có thể cung cấp dữ liệu tốc độ cao hơn với chi phí thấp hơn cho ứng dụng của bạn.

00:12:33.000 --> 00:12:41.000
Đó là gia tốc kế 800 Hz và chuyển động thiết bị 200 Hz, so với 100 Hz với CMMotionManager hiện có.

00:12:41.000 --> 00:12:50.000
Giờ đây, bạn có thể truy cập một số luồng dữ liệu tương tự cung cấp năng lượng cho các tính năng giúp chúng tôi an toàn, như phát hiện va chạm và va chạm.

00:12:50.000 --> 00:12:56.000
Bởi vì dữ liệu được phân lô, có một số điều cần xem xét khi nghĩ về việc sử dụng CMBatchedSensorManager.

00:12:56.000 --> 00:13:07.000
Nếu ứng dụng của bạn có các tính năng tập trung vào tập luyện có thể hưởng lợi từ dữ liệu tốc độ cao, nhưng không có yêu cầu độ trễ rất chặt chẽ, thì CMBatchedSensorManager rất phù hợp.

00:13:07.000 --> 00:13:15.000
Tôi đã xem qua cách dữ liệu cảm biến tốc độ cao hơn được phân phối cho bạn và cách nó so sánh với những gì được cung cấp bởi một số giao diện hiện có của chúng tôi.

00:13:15.000 --> 00:13:18.000
Hãy để tôi chỉ cho bạn một số cách nó có thể được sử dụng.

00:13:18.000 --> 00:13:23.000
Nhiều môn thể thao tập trung vào các sự kiện dựa trên tác động trong thời gian ngắn.

00:13:23.000 --> 00:13:30.000
Điều này bao gồm các hoạt động như chơi gôn, quần vợt và bóng chày, chỉ nêu một vài ví dụ.

00:13:30.000 --> 00:13:38.000
Trong những điều này, việc nắm bắt nhiều thông tin hơn trong chuyển động xoay vòng đó có thể rất quan trọng để đánh giá hình thức và cải thiện trò chơi của bạn.

00:13:38.000 --> 00:13:43.000
Đây là nơi thu thập dữ liệu cảm biến tốc độ cao hơn phát huy tác dụng.

00:13:43.000 --> 00:13:46.000
Chúng tôi sẽ được hưởng lợi bằng cách neo điều này trong một ví dụ cụ thể.

00:13:46.000 --> 00:13:48.000
Hãy tập trung vào một cú swing bóng chày.

00:13:48.000 --> 00:13:51.000
Xích đu có một vài giai đoạn khác nhau.

00:13:51.000 --> 00:13:58.000
Trong hình này, chúng ta có thể thấy thiết lập trước khi xoay, xoay thực tế, sau đó là theo dõi sau tác động.

00:13:58.000 --> 00:14:02.000
Một thước đo quan trọng cho chất lượng xoay là thời gian để liên hệ.

00:14:02.000 --> 00:14:09.000
Nói cách khác, bao nhiêu thời gian trôi qua giữa thời điểm người đánh bóng bắt đầu vung gậy và thời gian người đánh bóng.

00:14:09.000 --> 00:14:13.000
Sử dụng dữ liệu cảm biến tốc độ cao, chúng ta có thể chia nó thành ba bước.

00:14:13.000 --> 00:14:19.000
Trên cổ tay của người đánh bóng, chúng ta có thể thấy Apple Watch với các hướng x, y và z.

00:14:19.000 --> 00:14:26.000
Chúng ta có thể tưởng tượng đường đi của cổ tay khi nó di chuyển xung quanh bột màu xanh lam, với vectơ trọng lực hướng xuống.

00:14:26.000 --> 00:14:34.000
Để tính toán thời gian tiếp xúc, trước tiên tôi sẽ phát hiện điểm va chạm giữa gậy và quả bóng bằng gia tốc kế 800 Hz.

00:14:34.000 --> 00:14:41.000
Sau đó, tôi sẽ xác định sự bắt đầu của cú swing bằng cách sử dụng vòng quay dọc theo trọng lực với chuyển động của thiết bị 200 Hz.

00:14:41.000 --> 00:14:49.000
Cuối cùng, chúng ta có thể tính toán sự khác biệt giữa các dấu thời gian này, từ khi bắt đầu xoay đến tác động, được gọi là thời gian để tiếp xúc.

00:14:49.000 --> 00:14:54.000
Hãy bắt đầu bằng cách trực quan hóa dữ liệu cảm biến trong quá trình xoay để hiểu được những gì chúng ta đang tìm kiếm.

00:14:54.000 --> 00:15:01.000
Ở đây, tôi đã vẽ biểu đồ dữ liệu gia tốc kế theo hướng z cho một cửa sổ một giây chứa một cú xoay.

00:15:01.000 --> 00:15:07.000
Tôi có thể thấy rằng từ 0,5 đến 0,6 giây có một sự bùng nổ của hoạt động.

00:15:07.000 --> 00:15:13.000
Thuật toán của chúng tôi để phát hiện điểm va chạm sẽ xoay quanh quan sát này.

00:15:13.000 --> 00:15:23.000
Hãy so sánh lượng thông tin tín hiệu có sẵn trong quá trình xoay, với gia tốc kế 800 Hz ở trên và gia tốc kế 100 Hz ở dưới cùng.

00:15:23.000 --> 00:15:33.000
Trong phần quan tâm đó, từ 0,5 đến 0,6 giây, bây giờ chúng ta có 80 điểm dữ liệu thay vì 10, cho chúng ta một bức tranh chi tiết hơn nhiều về những gì đang diễn ra.

00:15:33.000 --> 00:15:38.000
Điều này giúp chúng tôi tập trung vào những thứ chúng tôi quan tâm, như tác động.

00:15:38.000 --> 00:15:43.000
Bây giờ, hãy nhìn vào cùng một cú swing từ góc độ chuyển động của thiết bị.

00:15:43.000 --> 00:15:47.000
Điều này vẽ biểu đồ tốc độ quay dọc theo trọng lực ở 200 Hz.

00:15:47.000 --> 00:15:53.000
Tôi có thể thấy sự dao động bắt đầu bằng cách tốc độ quay bắt đầu thay đổi vào khoảng 0,3 giây.

00:15:53.000 --> 00:15:56.000
Hãy ghép những thứ này lại với nhau.

00:15:56.000 --> 00:16:07.000
Với những biểu đồ này được căn chỉnh theo thời gian, tôi có thể cảm nhận được thông tin trong gia tốc kế 800 Hz và chuyển động của thiết bị 200 Hz giúp tôi tính toán thời gian liên lạc như thế nào.

00:16:07.000 --> 00:16:17.000
Bây giờ tôi đã có ý tưởng tốt về cách xoay hiển thị trong các luồng cảm biến, tôi có thể sử dụng CMBatchedSensorManager để bắt đầu phát trực tuyến và xử lý dữ liệu.

00:16:17.000 --> 00:16:20.000
Đầu tiên, chúng tôi muốn xác nhận dữ liệu có sẵn trên nền tảng này.

00:16:20.000 --> 00:16:24.000
Bạn có thể làm như vậy bằng cách kiểm tra isAccelerometerSupported.

00:16:24.000 --> 00:16:28.000
Bạn có thể kiểm tra hỗ trợ chuyển động của thiết bị bằng cách sử dụng một thuộc tính tương tự.

00:16:28.000 --> 00:16:35.000
Apple Watch Series 8 và Ultra hỗ trợ cả gia tốc kế tốc độ cao và chuyển động của thiết bị.

00:16:35.000 --> 00:16:41.000
Bởi vì đây là một API tập trung vào tập luyện, bạn cần có một buổi tập luyện HealthKit đang hoạt động để lấy dữ liệu.

00:16:41.000 --> 00:16:45.000
Khi bạn đang ở trong một buổi Tập luyện HealthKit, bạn có thể bắt đầu nhận thông tin cập nhật.

00:16:45.000 --> 00:16:51.000
Với sự hỗ trợ không đồng bộ Swift, thật dễ dàng để nhận các lô dữ liệu cảm biến và xử lý từng lô.

00:16:51.000 --> 00:16:58.000
Hãy chắc chắn rằng bạn đánh giá các điều kiện để thoát khỏi vòng lặp; ví dụ, nếu bài tập đã kết thúc.

00:16:58.000 --> 00:17:04.000
Hãy nhớ rằng các lỗi sẽ xuất hiện nếu chúng tôi không được phép cho dữ liệu chuyển động hoặc trên một nền tảng không được hỗ trợ.

00:17:04.000 --> 00:17:08.000
Bây giờ, hãy phóng to những gì tôi muốn làm với mỗi lô dữ liệu.

00:17:08.000 --> 00:17:14.000
Đối với mỗi lô, tôi sẽ gọi một hàm nguồn cấp dữ liệu để chạy thuật toán của mình trên dữ liệu.

00:17:14.000 --> 00:17:19.000
Khi con dơi tiếp xúc với quả bóng, tôi hy vọng sẽ thấy một phản ứng rõ rệt theo hướng z.

00:17:19.000 --> 00:17:24.000
Hãy nhớ rằng, trục z vuông góc với vương miện đồng hồ.

00:17:24.000 --> 00:17:28.000
Sự vang dội này là một xấp xỉ tốt của tác động.

00:17:28.000 --> 00:17:32.000
Tôi sẽ xử lý từng lô gia tốc kế với ý nghĩ này.

00:17:32.000 --> 00:17:38.000
Đầu tiên, tôi muốn cách ly tốt hơn đáp ứng tần số cao hơn khi lực bị dịch chuyển khi tiếp xúc.

00:17:38.000 --> 00:17:43.000
Để làm điều này, tôi sẽ lọc các mẫu z dưới dạng fz.

00:17:43.000 --> 00:17:49.000
Sử dụng dữ liệu được lọc, tôi sẽ ước tính điểm va chạm là đỉnh của tín hiệu được lọc.

00:17:49.000 --> 00:17:54.000
Hãy theo dõi chỉ số liên quan đến mẫu đó dưới dạng impactIndex.

00:17:54.000 --> 00:18:01.000
Sử dụng impactIndex được rút ra từ tín hiệu được lọc, tôi có thể lấy dấu thời gian tác động từ lô dữ liệu ban đầu.

00:18:01.000 --> 00:18:11.000
Điều này đưa tôi đến bước thứ hai trên con đường tính toán thời gian tiếp xúc: phát hiện sự bắt đầu của cú swing bằng cách sử dụng vòng quay dọc theo trọng lực.

00:18:11.000 --> 00:18:18.000
Hãy tưởng tượng con đường của Apple Watch khi người đánh bóng thực hiện một cú swing; nó sẽ đi theo một con đường xung quanh cơ thể để gặp quả bóng.

00:18:18.000 --> 00:18:27.000
Vì vậy, tôi hy vọng sẽ thấy tốc độ quay không bằng không dọc theo trọng lực trong quá trình xoay và tốc độ quay gần bằng không dọc theo trọng lực bên ngoài xích đu.

00:18:27.000 --> 00:18:35.000
Bằng cách truyền chuyển động của thiết bị tần số cao vào bộ đệm cục bộ, tôi có thể sử dụng dữ liệu tốc độ quay để xác định nơi bắt đầu dao động.

00:18:35.000 --> 00:18:39.000
Chúng ta hãy xem xét kỹ hơn hàm tính toán của tôi trông như thế nào.

00:18:39.000 --> 00:18:46.000
Tôi sẽ lặp lại qua bộ đệm cục bộ của mình ngược lại để điều tra xung quanh điểm quan tâm: dấu thời gian tác động.

00:18:46.000 --> 00:18:54.000
Vì tôi biết việc bắt đầu cú swing phải đi trước tác động, tôi có thể chạy một loạt các kiểm tra shouldProcess trước khi xử lý từng mẫu trong bộ đệm.

00:18:54.000 --> 00:19:01.000
Điều này có thể bao gồm kiểm tra dấu thời gian để xác nhận mẫu chuyển động của thiết bị là từ trước thời gian va chạm.

00:19:01.000 --> 00:19:04.000
Tôi cũng có thể đặt giới hạn về thời lượng xoay.

00:19:04.000 --> 00:19:11.000
Điều hợp lý là việc bắt đầu cú swing không xảy ra quá một khoảng thời gian nhất định trước khi nó tiếp xúc với quả bóng.

00:19:11.000 --> 00:19:23.000
Đối với các mẫu vượt qua loạt kiểm tra ban đầu của tôi, tôi tính toán vòng quay dọc theo trọng lực trong hàm computeRotation của mình, hàm này tổng hợp tích của tốc độ quay và giá trị trọng lực của mỗi trục.

00:19:23.000 --> 00:19:28.000
Với vòng quay dọc theo trọng lực được tính toán, tôi có thể bắt đầu tìm kiếm sự khởi đầu của cú swing.

00:19:28.000 --> 00:19:35.000
Một kiểm tra bắt đầu xoay đơn giản có thể tìm kiếm sự thất bại nhất quán của tốc độ quay dọc theo trọng lực để đáp ứng giá trị ngưỡng.

00:19:35.000 --> 00:19:43.000
Khi tôi ngừng nhìn thấy tốc độ quay dọc theo trọng lực đáp ứng ngưỡng đó, tôi sẽ sử dụng nó làm thời gian bắt đầu của cú swing và thoát ra khỏi vòng lặp.

00:19:43.000 --> 00:19:47.000
Như một kiểm tra cuối cùng, tôi sẽ xác nhận cú swing mà chúng tôi đã phát hiện.

00:19:47.000 --> 00:19:55.000
Ở đây, tôi có thể xem xét vòng quay tích lũy dọc theo trọng lực trong quá trình xoay và xác nhận nó nằm trong ngưỡng dự kiến.

00:19:55.000 --> 00:19:59.000
Và với điều đó, tôi có thể trả lại dấu thời gian bắt đầu mà tôi đã phát hiện.

00:19:59.000 --> 00:20:05.000
Điều này đưa tôi đến bước cuối cùng, bước 3, nơi bây giờ tôi có mọi thứ tôi cần để tính toán thời gian liên hệ.

00:20:05.000 --> 00:20:08.000
Hãy quay lại chức năng nguồn cấp dữ liệu ban đầu của chúng ta.

00:20:08.000 --> 00:20:14.000
Sử dụng CMBatchedSensorManager, tôi bắt đầu bằng cách phát trực tuyến gia tốc kế và dữ liệu chuyển động của thiết bị.

00:20:14.000 --> 00:20:20.000
Tôi đã phát hiện impactTime bằng cách sử dụng dữ liệu gia tốc kế được lọc theo hướng z.

00:20:20.000 --> 00:20:27.000
Sau đó, tôi đã xác định được sự bắt đầu của cú swing gần dấu thời gian va chạm đó bằng cách kiểm tra tốc độ quay dọc theo trọng lực.

00:20:27.000 --> 00:20:32.000
Tôi sẽ lấy sự khác biệt giữa hai dấu thời gian để tính thời gian liên lạc.

00:20:32.000 --> 00:20:37.000
Đây là một ví dụ đơn giản về cách bạn có thể phát triển các tính năng dựa trên dữ liệu cảm biến.

00:20:37.000 --> 00:20:43.000
Thông tin tín hiệu bổ sung trong các luồng dữ liệu tần số cao hơn cũng mở ra cánh cửa cho rất nhiều cuộc điều tra khác.

00:20:43.000 --> 00:20:45.000
Hãy cùng xem nào.

00:20:45.000 --> 00:20:52.000
Chúng tôi đã thấy dấu vết dữ liệu gia tốc kế này trước đó với dòng gia tốc kế 800 Hz theo hướng z.

00:20:52.000 --> 00:20:55.000
Bây giờ, hãy nhìn vào cốt truyện thứ hai.

00:20:55.000 --> 00:20:58.000
Nó trông khá giống nhau, nhưng nó không hoàn toàn giống nhau.

00:20:58.000 --> 00:21:04.000
Đây là dấu vết từ một cú đánh bị bỏ lỡ, nơi con dơi không thực sự tiếp xúc với quả bóng.

00:21:04.000 --> 00:21:13.000
Mặc dù bản thân chuyển động xoay tương tự nhau cho cả hai, bạn có thể thấy các luồng dữ liệu tốc độ cao cung cấp cho chúng ta cái nhìn sâu sắc hơn về sự khác biệt như thế này như thế nào.

00:21:13.000 --> 00:21:19.000
Các thuật toán bạn phát triển có thể tận dụng những khác biệt này để phát hiện những điều không thể thực hiện trước đây.

00:21:19.000 --> 00:21:25.000
Tóm lại, các thuật toán chuyển động của cùng một thiết bị cung cấp dữ liệu cho bạn theo một vài cách khác nhau.

00:21:25.000 --> 00:21:32.000
CMMotionManager định vị dữ liệu ở mức tối đa 100 Hz trên cơ sở mỗi mẫu.

00:21:32.000 --> 00:21:42.000
Điều này làm cho nó trở thành một lựa chọn tuyệt vời nếu bạn có yêu cầu độ trễ thấp trên thang điểm dưới giây hoặc có các tính năng dựa trên chuyển động bên ngoài các bài tập.

00:21:42.000 --> 00:21:55.000
CMBatchedSensorManager mới cung cấp dữ liệu với tốc độ cao hơn, với giới hạn chuyển động thiết bị 200 Hz và gia tốc kế 800 Hz theo lịch trình theo lô, cung cấp một lô dữ liệu mỗi giây.

00:21:55.000 --> 00:22:00.000
Điều này làm cho nó hữu ích cho các tính năng tập luyện tập có thể được hưởng lợi từ dữ liệu tốc độ cao.

00:22:00.000 --> 00:22:03.000
Nó có sẵn trên Apple Watch Series 8 và Ultra.

00:22:03.000 --> 00:22:19.000
Mặc dù tôi tập trung vào một cú swing bóng chày để sử dụng CMBatchedSensorManager, những luồng dữ liệu tốc độ cao hơn này có thể cung cấp cái nhìn sâu sắc có giá trị về chuyển động của Apple Watch cho tất cả các bài tập, đặc biệt là trong thời gian ngắn hoặc các hoạt động dựa trên tác động.

00:22:19.000 --> 00:22:25.000
Đó là CMBatchedSensorManager, và điều này kết thúc đánh giá của tôi về những gì mới với CoreMotion.

00:22:25.000 --> 00:22:30.000
Chúng tôi có những cách tuyệt vời để tương tác với chuyển động, cho dù đó là trên tai nghe hay Apple Watch.

00:22:30.000 --> 00:22:35.000
Có rất nhiều cách thú vị để sử dụng dữ liệu chuyển động và tôi chỉ đề cập đến một vài ví dụ.

00:22:35.000 --> 00:22:40.000
Tôi khuyến khích bạn dùng thử chúng và kiểm tra tài liệu để biết thêm thông tin.

00:22:40.000 --> 00:22:42.000
Đảm bảo cũng cung cấp phản hồi cho chúng tôi.

00:22:42.000 --> 00:22:53.000
Để biết ví dụ về cách dữ liệu chuyển động được chuyển thành các tính năng dựa trên sức khỏe, như đo lường tính di động, hãy xem phiên "Vượt quá các bước đếm" từ WWDC 2020.

00:22:53.000 --> 00:23:02.000
Để biết thêm thông tin về các bài tập chạy bộ để tận dụng lợi thế của CMBatchedSensorManager, hãy xem "Xây dựng các bài tập tùy chỉnh với WorkoutKit."

00:23:02.000 --> 00:23:07.000
Chúng tôi rất vui khi thấy cách bạn sử dụng dữ liệu chuyển động để tạo ra những trải nghiệm mới tuyệt vời.

00:23:07.000 --> 23:59:59.000
Cảm ơn bạn đã xem.

