WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:17.000
Rishi: Xin chào, tên tôi là Rishi Verma, và phiên này bao gồm cách mã hóa các mô hình của bạn để xây dựng lược đồ cho SwiftData.

00:00:17.000 --> 00:00:28.000
Tôi sẽ bắt đầu bằng cách đề cập đến cách bạn có thể sử dụng các macro lược đồ với tiềm năng tối đa của chúng và cách bạn có thể phát triển lược đồ của mình với việc di chuyển lược đồ khi ứng dụng của bạn thay đổi.

00:00:28.000 --> 00:00:39.000
Trước khi bắt đầu, vui lòng xem "Gặp gỡ SwiftData" và "Xây dựng ứng dụng với SwiftData", vì nội dung này sẽ phát triển dựa trên các khái niệm được giới thiệu trong các video đó.

00:00:39.000 --> 00:00:45.000
SwiftData là một khuôn khổ mạnh mẽ để mô hình hóa và quản lý dữ liệu và nâng cao ứng dụng Swift hiện đại của bạn.

00:00:45.000 --> 00:00:57.000
Giống như SwiftUI, nó tập trung hoàn toàn vào mã, không có định dạng tệp bên ngoài và sử dụng hệ thống macro mới của Swift để tạo ra trải nghiệm API liền mạch.

00:00:57.000 --> 00:01:02.000
Tôi đang làm việc trên ứng dụng SampleTrips, cho phép người dùng lên kế hoạch cho một số chuyến đi sắp tới.

00:01:02.000 --> 00:01:08.000
Mỗi chuyến đi sẽ được tạo ra với một cái tên, một điểm đến, cũng như ngày bắt đầu và ngày kết thúc.

00:01:08.000 --> 00:01:15.000
Một chuyến đi cũng có thể chứa các mối quan hệ cho các mục trong danh sách nhóm và nơi khách du lịch sẽ ở lại.

00:01:15.000 --> 00:01:21.000
Thêm SwiftData cũng đơn giản như thêm nhập và trang trí Chuyến đi với @Model.

00:01:21.000 --> 00:01:24.000
Thế là xong.

00:01:24.000 --> 00:01:30.000
Macro @Model phù hợp với lớp Trip của tôi với PersistentModel và tạo ra một lược đồ mô tả.

00:01:30.000 --> 00:01:35.000
Mã xác định mô hình của tôi bây giờ là nguồn gốc của sự thật cho lược đồ ứng dụng của tôi.

00:01:35.000 --> 00:01:41.000
Hành vi mặc định của mô hình chuyến đi của tôi là tốt, nhưng tôi nghĩ tôi có thể tinh chỉnh nó một chút.

00:01:41.000 --> 00:01:49.000
Các macro lược đồ của SwiftData cho phép tôi tùy chỉnh hành vi của trải nghiệm bền bỉ để hoạt động hoàn hảo cho ứng dụng của mình.

00:01:49.000 --> 00:01:55.000
Khi tôi xuất bản ứng dụng của mình với lược đồ ban đầu, tôi không đảm bảo mỗi tên chuyến đi là duy nhất.

00:01:55.000 --> 00:02:00.000
Điều này đã gây ra một vài xung đột giữa các chuyến đi cùng tên mà bây giờ tôi cần giải quyết.

00:02:00.000 --> 00:02:06.000
Điều này có thể được khắc phục bằng macro lược đồ @Attribute và sử dụng tùy chọn duy nhất.

00:02:06.000 --> 00:02:16.000
SwiftData sẽ tạo ra một lược đồ cho mô hình chuyến đi của tôi, giờ đây đảm bảo bất kỳ chuyến đi nào mà tôi lưu vào back end liên tục sẽ có một tên duy nhất.

00:02:16.000 --> 00:02:23.000
Nếu một chuyến đi đã tồn tại với tên đó, thì back end liên tục sẽ cập nhật lên các giá trị mới nhất.

00:02:23.000 --> 00:02:25.000
Điều này được gọi là upsert.

00:02:25.000 --> 00:02:28.000
Một upsert bắt đầu như một phần chèn.

00:02:28.000 --> 00:02:34.000
Nếu phần chèn va chạm với dữ liệu hiện có, nó sẽ trở thành bản cập nhật và cập nhật các thuộc tính của dữ liệu hiện có.

00:02:34.000 --> 00:02:47.000
Tôi cũng có thể áp dụng các ràng buộc duy nhất trên các thuộc tính khác, miễn là chúng là các loại giá trị nguyên thủy như số, chuỗi hoặc UUID, hoặc thậm chí tôi có thể trang trí mối quan hệ 1-1.

00:02:47.000 --> 00:02:49.000
Lược đồ của tôi cần thêm một chút công việc.

00:02:49.000 --> 00:02:56.000
Tôi muốn loại bỏ những dấu gạch dưới phiền phức này khỏi ngày bắt đầu và ngày kết thúc mà tôi đã chỉ định ban đầu.

00:02:56.000 --> 00:03:02.000
Nếu tôi chỉ đổi tên các biến, đây sẽ được coi là một thuộc tính mới trong lược đồ được tạo của tôi.

00:03:02.000 --> 00:03:05.000
Tôi không muốn SwiftData tạo ra những thuộc tính mới này.

00:03:05.000 --> 00:03:10.000
Thay vào đó, tôi muốn giữ nguyên dữ liệu hiện có.

00:03:10.000 --> 00:03:18.000
Tôi có thể làm như vậy bằng cách đơn giản ánh xạ tên gốc đến tên thuộc tính bằng cách sử dụng @Attribute và chỉ định tham số originalName:.

00:03:18.000 --> 00:03:22.000
Bằng cách ánh xạ những thứ này từ tên gốc, tôi có thể tránh mất dữ liệu.

00:03:22.000 --> 00:03:30.000
Điều này cũng đảm bảo bản cập nhật lược đồ của tôi sẽ là một quá trình di chuyển đơn giản cho bản phát hành tiếp theo của ứng dụng SampleTrips.

00:03:30.000 --> 00:03:40.000
Và macro @Attribute có thể làm được nhiều hơn thế, bao gồm lưu trữ dữ liệu lớn bên ngoài và cung cấp hỗ trợ cho các khả năng chuyển đổi.

00:03:40.000 --> 00:03:45.000
Các chuyến đi của tôi đang hình thành tốt đẹp, nhưng bây giờ tôi muốn làm việc trên các mối quan hệ.

00:03:45.000 --> 00:03:55.000
Khi tôi thêm một mục danh sách nhóm mới hoặc chỗ ở vào chuyến đi của mình, SwiftData sẽ ngầm khám phá các nghịch đảo giữa các mô hình của tôi và đặt chúng cho tôi.

00:03:55.000 --> 00:03:59.000
Nghịch đảo ngầm không yêu cầu bất kỳ chú thích nào.

00:03:59.000 --> 00:04:01.000
Họ chỉ làm việc.

00:04:01.000 --> 00:04:10.000
Nghịch đảo ngầm sử dụng quy tắc xóa mặc định sẽ vô hiệu hóa các mục trong danh sách nhóm và thuộc tính chỗ ở khi chuyến đi bị xóa.

00:04:10.000 --> 00:04:17.000
Tuy nhiên, tôi muốn các mục trong danh sách nhóm và chỗ ở của mình bị xóa cùng với chuyến đi.

00:04:17.000 --> 00:04:22.000
Tôi có thể dễ dàng làm điều đó bằng cách thêm macro @Relationship với quy tắc xóa theo tầng.

00:04:22.000 --> 00:04:28.000
Bây giờ khi tôi xóa chuyến đi của mình, nó cũng sẽ xóa những mối quan hệ đó.

00:04:28.000 --> 00:04:39.000
Và macro @Relationship làm được nhiều việc hơn thế, bao gồm công cụ sửa đổi originalName và khả năng chỉ định số lượng tối thiểu và tối đa trên mối quan hệ nhiều người.

00:04:39.000 --> 00:04:43.000
Ứng dụng SampleTrips đang hình thành tốt, nhưng tôi vẫn còn một bản cập nhật cần làm.

00:04:43.000 --> 00:04:48.000
Bây giờ, tôi muốn thêm một cách để theo dõi số lần tôi xem một chuyến đi.

00:04:48.000 --> 00:04:52.000
Bằng cách này tôi có thể đánh giá mức độ phấn khích của tôi khi đi nghỉ.

00:04:52.000 --> 00:04:53.000
Tôi không thể chờ đợi!

00:04:53.000 --> 00:05:02.000
Tuy nhiên, tôi không muốn SwiftData duy trì số lượt xem này và tôi có thể dễ dàng làm điều đó với macro @Transient.

00:05:02.000 --> 00:05:08.000
Tôi chỉ đơn giản là trang trí tài sản của mình bằng @Transient, và tài sản cụ thể này sẽ không được duy trì.

00:05:08.000 --> 00:05:10.000
Nó thật dễ dàng.

00:05:10.000 --> 00:05:14.000
Macro @Transient giúp bạn tránh tồn tại dữ liệu không cần thiết.

00:05:14.000 --> 00:05:18.000
Đảm bảo rằng bạn cung cấp một giá trị mặc định cho các thuộc tính tạm thời.

00:05:18.000 --> 00:05:23.000
Điều này đảm bảo chúng có các giá trị logic khi được tìm nạp từ SwiftData.

00:05:23.000 --> 00:05:29.000
Để biết thêm thông tin về việc sử dụng các macro lược đồ này, hãy xem tài liệu SwiftData.

00:05:29.000 --> 00:05:35.000
Lược đồ ứng dụng SampleTrips đã trải qua một số tiến hóa khi tôi điều chỉnh trải nghiệm bền bỉ.

00:05:35.000 --> 00:05:39.000
Tôi cần đảm bảo rằng ứng dụng của tôi có thể xử lý các bản cập nhật đó từ khi phát hành đến khi phát hành.

00:05:39.000 --> 00:05:46.000
Và khi bạn thực hiện thay đổi đối với lược đồ của mình, như thêm hoặc xóa một thuộc tính, việc di chuyển dữ liệu sẽ xảy ra.

00:05:46.000 --> 00:05:51.000
Những di chuyển này có thể là những tình huống khó khăn, nhưng SwiftData làm cho nó dễ dàng.

00:05:51.000 --> 00:05:55.000
VersionedSchema và SchemaMigrationPlan ở đây để giúp bạn điều đó.

00:05:55.000 --> 00:06:05.000
Bất cứ khi nào bạn chuẩn bị phát hành phiên bản mới của ứng dụng với những thay đổi đối với mô hình SwiftData của bạn, hãy xác định VersionedSchema gói gọn lược đồ đã phát hành trước đó của bạn.

00:06:05.000 --> 00:06:15.000
Mỗi phiên bản riêng biệt của lược đồ của bạn nên được định nghĩa là VersionedSchema để SwiftData biết những thay đổi nào đã xảy ra giữa chúng.

00:06:15.000 --> 00:06:21.000
Sau đó, sử dụng tổng thứ tự VersionedSchemas của bạn để tạo SchemaMigrationPlan.

00:06:21.000 --> 00:06:26.000
Điều này sẽ cho phép SwiftData thực hiện các thao tác di chuyển cần thiết theo thứ tự.

00:06:26.000 --> 00:06:33.000
Khi bạn đã đặt ra các lược đồ đã đặt hàng của mình trong kế hoạch di chuyển, bạn có thể bắt đầu xác định từng giai đoạn di chuyển.

00:06:33.000 --> 00:06:37.000
Có hai loại giai đoạn di chuyển khác nhau có sẵn cho bạn.

00:06:37.000 --> 00:06:40.000
Đầu tiên là một giai đoạn di chuyển nhẹ.

00:06:40.000 --> 00:06:47.000
Di chuyển nhẹ không yêu cầu bất kỳ mã bổ sung nào để di chuyển dữ liệu hiện có cho bản phát hành ứng dụng tiếp theo của tôi.

00:06:47.000 --> 00:06:57.000
Các sửa đổi như thêm originalName vào thuộc tính ngày của tôi hoặc chỉ định các quy tắc xóa trên các mối quan hệ của tôi đủ điều kiện di chuyển nhẹ.

00:06:57.000 --> 00:07:03.000
Tuy nhiên, việc đặt tên cho một chuyến đi trở nên độc đáo không đủ điều kiện để di chuyển nhẹ.

00:07:03.000 --> 00:07:12.000
Tôi cần tạo một giai đoạn di chuyển tùy chỉnh cho sự thay đổi này, trong đó tôi có thể sao chép các chuyến đi của mình, trước khi tên của chúng được làm duy nhất.

00:07:12.000 --> 00:07:18.000
Tôi bắt đầu bằng cách lấy lược đồ gốc từ bản phát hành đầu tiên của mình và gói gọn nó trong VersionedSchema.

00:07:18.000 --> 00:07:23.000
Tôi đặt tên cho lược đồ phiên bản này là SampleTripsSchemaV1.

00:07:23.000 --> 00:07:28.000
Mỗi lược đồ phiên bản của tôi liệt kê các lớp mô hình mà chúng xác định.

00:07:28.000 --> 00:07:33.000
Phiên bản 2 của lược đồ của tôi là nơi tôi đã thêm ràng buộc tính độc đáo vào tên chuyến đi.

00:07:33.000 --> 00:07:41.000
Tôi tạo một lược đồ có phiên bản khác cũng gói gọn những thay đổi tôi đã thực hiện đối với lớp mô hình Trip.

00:07:41.000 --> 00:07:48.000
Tôi cũng làm như vậy đối với phiên bản 3 của lược đồ của mình, nắm bắt các thay đổi tên được thực hiện để bắt đầu và ngày kết thúc.

00:07:48.000 --> 00:07:56.000
Bây giờ tôi đã có tất cả các VersionedSchemas của mình, tôi xây dựng SchemaMigrationPlan để mô tả cách xử lý việc di chuyển từ bản phát hành này sang bản phát hành khác.

00:07:56.000 --> 00:07:58.000
Nó khá đơn giản.

00:07:58.000 --> 00:08:02.000
Tôi chỉ cung cấp tổng thứ tự của các lược đồ ứng dụng của tôi.

00:08:02.000 --> 00:08:07.000
Sau đó, tôi cần chú thích di chuyển nào là nhẹ hoặc tùy chỉnh.

00:08:07.000 --> 00:08:14.000
Đối với V1 đến V2, tôi cần một giai đoạn tùy chỉnh nơi tôi có thể thực hiện một thao tác trước khi dữ liệu được di chuyển.

00:08:14.000 --> 00:08:20.000
Trong việc đóng cửa willMigrate, tôi có thể hủy trùng lặp các chuyến đi của mình trước khi quá trình di chuyển xảy ra.

00:08:20.000 --> 00:08:28.000
SwiftData sẽ phát hiện khi nào việc di chuyển từ V1 sang V2 sẽ xảy ra và sẽ thực hiện việc đóng cửa này cho tôi.

00:08:28.000 --> 00:08:34.000
Việc di chuyển khác cho originalName rất nhẹ, vì vậy tôi cũng có thể thêm giai đoạn đó vào.

00:08:34.000 --> 00:08:41.000
Bây giờ tôi đã xác định tất cả các chi tiết về kế hoạch di chuyển của mình, đã đến lúc thực hiện di chuyển.

00:08:41.000 --> 00:08:47.000
Tôi thiết lập ModelContainer của mình với lược đồ hiện tại và kế hoạch di chuyển, và tôi đã hoàn tất.

00:08:47.000 --> 00:08:52.000
Người dùng của tôi có thể nâng cấp từ bất kỳ phiên bản nào lên bản phát hành mới nhất và tôi đã đảm bảo dữ liệu sẽ được giữ nguyên.

00:08:52.000 --> 00:08:58.000
Tôi nóng lòng muốn sử dụng ứng dụng SampleTrips để lên kế hoạch cho kỳ nghỉ sắp tới của mình.

00:08:58.000 --> 00:09:09.000
Khai thác các macro lược đồ để truyền tải siêu dữ liệu bổ sung cho lược đồ của bạn và khi ứng dụng của bạn phát triển, hãy nắm bắt những tiến hóa đó trong VersionedSchema để ứng dụng của bạn có thể di chuyển từ bất kỳ bản phát hành nào trước đó.

00:09:09.000 --> 00:09:15.000
Hãy xem những cuộc nói chuyện khác này và chúng tôi mong muốn được thấy những điều tuyệt vời mà tất cả các bạn thực hiện với SwiftData.

00:09:15.000 --> 23:59:59.000
Đó là một vinh dự.

