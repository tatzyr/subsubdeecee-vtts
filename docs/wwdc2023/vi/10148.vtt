WEBVTT

00:00:00.000 --> 00:00:04.000
♪ Hip-hop nhạc cụ êm dịu ♪

00:00:04.000 --> 00:00:10.000
♪

00:00:10.000 --> 00:00:12.000
Curt Clifton: Xin chào và cảm ơn vì đã tham gia cùng chúng tôi.

00:00:12.000 --> 00:00:16.000
Tôi là Curt và tôi là một kỹ sư trong nhóm SwiftUI.

00:00:16.000 --> 00:00:17.000
Jeff Robertson: Và Tôi Là Jeff.

00:00:17.000 --> 00:00:19.000
Tôi cũng là một kỹ sư trong nhóm SwiftUI.

00:00:19.000 --> 00:00:23.000
Chúng tôi rất vui khi có cơ hội chia sẻ những gì mới trong SwiftUI.

00:00:23.000 --> 00:00:29.000
Curt: Bây giờ bạn có thể sử dụng SwiftUI ở nhiều nơi hơn, bao gồm cả một nền tảng hoàn toàn mới!

00:00:29.000 --> 00:00:36.000
Các loại luồng dữ liệu mới đơn giản hóa đáng kể việc mô hình hóa miền của bạn, cung cấp nhiều năng lượng hơn bao giờ hết.

00:00:36.000 --> 00:00:42.000
Thanh tra, cộng với các cải tiến Bảng, cung cấp những cách tuyệt vời để hiển thị dữ liệu của bạn.

00:00:42.000 --> 00:00:50.000
Nhóm đã tăng cường các API hoạt hình của chúng tôi, cho phép bạn tạo ra những trải nghiệm đẹp hơn nữa cho những người sử dụng ứng dụng của bạn.

00:00:50.000 --> 00:01:04.000
Trên khuôn khổ, chúng tôi đã nâng cao khả năng của bạn để cung cấp các tương tác tuyệt vời, với các cải tiến chế độ xem cuộn mạnh mẽ, tinh chỉnh để lấy nét và nhập bàn phím, và tùy chỉnh sâu hơn các điều khiển như nút và menu.

00:01:04.000 --> 00:01:10.000
Tôi rất vui được kể cho bạn nghe về một số địa điểm mới tuyệt vời để sử dụng SwiftUI.

00:01:10.000 --> 00:01:22.000
Từ tai nghe và watchOS 10 đến các tiện ích mới và tích hợp đa khung hình, SwiftUI có thể giúp bạn tạo ra những trải nghiệm làm hài lòng những người sử dụng ứng dụng của bạn.

00:01:22.000 --> 00:01:38.000
Điện toán không gian đưa SwiftUI vào một tương lai mới táo bạo với các khả năng 3D hoàn toàn mới như khối lượng; trải nghiệm phong phú với không gian nhập vai; cử chỉ, hiệu ứng và bố cục 3D mới; và tích hợp sâu với RealityKit.

00:01:38.000 --> 00:01:55.000
Từ các phần cốt lõi như Chế độ xem tại nhà trong Trung tâm điều khiển đến các ứng dụng quen thuộc như TV, Safari và Freeform; đến các môi trường hoàn toàn mới như các buổi diễn tập nhập vai trong Keynote; SwiftUI là trung tâm của những trải nghiệm người dùng này.

00:01:55.000 --> 00:02:01.000
Trên nền tảng mới này, xây dựng các cửa sổ bằng cách sử dụng các loại cảnh quen thuộc như WindowGroup.

00:02:01.000 --> 00:02:08.000
Các cảnh WindowGroup hiển thị dưới dạng cửa sổ 2D, với các điều khiển 3D nhạy cảm với độ sâu thú vị.

00:02:08.000 --> 00:02:17.000
Trong một cửa sổ, chọn một trong các vùng chứa SwiftUI thông thường, như NavigationSplitView hoặc TabView.

00:02:17.000 --> 00:02:24.000
Trong các vùng chứa này, bạn có thể sử dụng tất cả các điều khiển SwiftUI thông thường giống như trên các nền tảng khác.

00:02:24.000 --> 00:02:29.000
Để có chiều sâu hơn nữa, hãy áp dụng phong cách thể tích cho cảnh của bạn.

00:02:29.000 --> 00:02:35.000
Khối lượng hiển thị trải nghiệm 3D - như trò chơi trên bàn cờ hoặc mô hình kiến trúc - trong một không gian giới hạn.

00:02:35.000 --> 00:02:38.000
Chúng hiển thị cùng với các ứng dụng khác.

00:02:38.000 --> 00:02:44.000
Mọi người có thể sử dụng nội dung của bạn trong khi họ ghi lại những suy nghĩ trong Ghi chú hoặc cập nhật các trang trình bày trong Keynote.

00:02:44.000 --> 00:02:49.000
Điền vào một tập sách bằng một mô hình tĩnh bằng cách sử dụng Model3D.

00:02:49.000 --> 00:02:56.000
Đối với các mô hình năng động, tương tác với hiệu ứng ánh sáng và hơn thế nữa, hãy sử dụng RealityView mới.

00:02:56.000 --> 00:03:00.000
Để thực sự tham gia tất cả, hãy thêm ImmersiveSpaces vào ứng dụng của bạn.

00:03:00.000 --> 00:03:09.000
Loại cảnh ImmersiveSpace mới cho phép bạn xác định trải nghiệm không gian, nhập vai, cho dù được nhúng vào môi trường xung quanh hay đắm chìm hoàn toàn.

00:03:09.000 --> 00:03:15.000
Hệ thống loại bỏ các ứng dụng khác cho phép mọi người đi sâu vào thế giới mà bạn đã tạo ra.

00:03:15.000 --> 00:03:24.000
Sử dụng ImmersiveSpace với phong cách đắm chìm hỗn hợp để kết nối ứng dụng của bạn với thế giới thực, kết hợp nội dung của bạn với môi trường xung quanh mọi người.

00:03:24.000 --> 00:03:32.000
Neo các yếu tố của ứng dụng của bạn vào bảng và bề mặt, đồng thời tăng cường và làm phong phú thêm thế giới thực với các đối tượng và hiệu ứng ảo.

00:03:32.000 --> 00:03:37.000
Đi xa hơn với phong cách đắm chìm hoàn toàn.

00:03:37.000 --> 00:03:40.000
Ứng dụng của bạn có toàn quyền kiểm soát.

00:03:40.000 --> 00:03:47.000
Xây dựng những trải nghiệm kết nối và nhập vai này bằng cách sử dụng cùng một Model3D và RealityView hoạt động theo khối lượng lớn.

00:03:47.000 --> 00:03:52.000
SwiftUI trên nền tảng mới này cho phép bạn tạo ra những trải nghiệm kỳ diệu.

00:03:52.000 --> 00:03:59.000
Xem "Gặp gỡ SwiftUI để tính toán không gian" để tiếp tục khám phá sự kết hợp tuyệt vời này.

00:03:59.000 --> 00:04:08.000
SwiftUI đang ở nhà xây dựng trải nghiệm lấp đầy phòng, nhưng nó cũng có thể xây dựng trải nghiệm cho các màn hình di động nhất của Apple.

00:04:08.000 --> 00:04:20.000
watchOS 10 mang đến trải nghiệm người dùng được thiết kế lại hiển thị thông tin kịp thời, truyền tải nội dung tập trung trong nháy mắt và tôn vinh hình dạng và độ trung thực của màn hình.

00:04:20.000 --> 00:04:27.000
Chúng tôi đã cập nhật các ứng dụng trên nền tảng để tận dụng màu sắc và hình ảnh toàn màn hình tuyệt đẹp này.

00:04:27.000 --> 00:04:34.000
Gốc rễ của các thiết kế này là một số chế độ xem SwiftUI hiện có, mới được trao quyền cho watchOS 10.

00:04:34.000 --> 00:04:40.000
NavigationSplitView và NavigationStack nhận được những chuyển tiếp mới tuyệt đẹp.

00:04:40.000 --> 00:04:45.000
TabView có một phong cách phân trang dọc mới được điều khiển bởi Digital Crown.

00:04:45.000 --> 00:04:53.000
SwiftUI giới thiệu một số API mới để giúp bạn mang lại sự tinh tế đầy màu sắc này cho các ứng dụng Apple Watch của mình.

00:04:53.000 --> 00:05:01.000
Công cụ sửa đổi nền container mới cho phép bạn định cấu hình các lần rửa nền tinh tế này hoạt ảnh khi bạn đẩy và bật nội dung.

00:05:01.000 --> 00:05:05.000
Bạn cũng có thể định cấu hình nền cho chế độ xem tab trên watchOS.

00:05:05.000 --> 00:05:19.000
Và các vị trí thanh công cụ đa nền tảng mới - topBarLeading và topBarTrailing, cùng với bottomBar hiện có - cho phép bạn đặt hoàn hảo các chế độ xem chi tiết nhỏ này trong các ứng dụng Apple Watch của mình.

00:05:19.000 --> 00:05:30.000
Bên cạnh những bổ sung mới này, chúng tôi vui mừng mang một số API hiện có lên watchOS lần đầu tiên, bao gồm DatePicker và lựa chọn trong Danh sách.

00:05:30.000 --> 00:05:35.000
Bây giờ là thời điểm tuyệt vời để đánh bóng các ứng dụng Apple Watch của bạn với những khả năng mới này.

00:05:35.000 --> 00:05:40.000
Và nếu bạn chưa có ứng dụng Apple Watch, đây là thời điểm tuyệt vời để bắt đầu.

00:05:40.000 --> 00:05:47.000
Tìm hiểu cách thiết kế và kỹ thuật kết hợp với nhau để tạo ra những trải nghiệm này trong "Thiết kế và xây dựng ứng dụng cho watchOS 10."

00:05:47.000 --> 00:05:54.000
Sau đó áp dụng những ý tưởng này vào công việc của bạn với "Cập nhật ứng dụng của bạn cho watchOS 10."

00:05:54.000 --> 00:06:01.000
Các tiện ích cho Smart Stack trên watchOS 10 cho phép những người sử dụng ứng dụng của bạn xem thông tin của họ khi đang di chuyển.

00:06:01.000 --> 00:06:08.000
SwiftUI là cốt lõi của các tiện ích ở bất cứ nơi nào chúng xuất hiện, giống như những địa điểm mới khác này.

00:06:08.000 --> 00:06:15.000
Các tiện ích trên Màn hình khóa trên iPadOS 17 là một sự bổ sung tuyệt vời cho các tiện ích trên Màn hình chính.

00:06:15.000 --> 00:06:21.000
Các tiện ích lớn, táo bạo tỏa sáng trên màn hình Luôn Bật của iPhone với Chế độ Chờ.

00:06:21.000 --> 00:06:27.000
Và các tiện ích máy tính để bàn trên macOS Sonoma giúp mọi người cập nhật hàng ngày.

00:06:27.000 --> 00:06:32.000
Widgets đã tìm được đường đến những địa điểm mới và nhóm cũng đã dạy họ một mẹo khác.

00:06:32.000 --> 00:06:37.000
Tôi rất vui được chia sẻ rằng các tiện ích hiện hỗ trợ các điều khiển tương tác.

00:06:37.000 --> 00:06:44.000
Chuyển đổi và Nút trong Widgets hiện có thể kích hoạt mã được xác định trong gói ứng dụng của riêng bạn bằng cách sử dụng App Intents.

00:06:44.000 --> 00:06:50.000
Và bạn có thể tạo hiệu ứng động cho các tiện ích của mình bằng cách sử dụng công cụ sửa đổi hoạt hình và chuyển tiếp SwiftUI.

00:06:50.000 --> 00:06:58.000
Để bắt đầu với những khả năng mới tuyệt vời này, hãy xem "Mang vật dụng đến những nơi mới" và "Đưa vật dụng vào cuộc sống".

00:06:58.000 --> 00:07:05.000
Để phát triển và tinh chỉnh các tiện ích hoạt hình tương tác mới của bạn, bạn sẽ thích sức mạnh của Bản xem trước Xcode.

00:07:05.000 --> 00:07:12.000
Các bản xem trước tận dụng các macro trong Swift 5.9 để cung cấp một cú pháp mới thanh lịch.

00:07:12.000 --> 00:07:19.000
Khai báo và định cấu hình Xem trước, thêm loại tiện ích và xác định dòng thời gian để thử nghiệm.

00:07:19.000 --> 00:07:26.000
Bản xem trước Xcode hiển thị trạng thái tiện ích hiện tại và dòng thời gian cho phép bạn xem hình ảnh động giữa các trạng thái.

00:07:26.000 --> 00:07:31.000
Tất nhiên, các bản xem trước mới cũng hoạt động với các chế độ xem và ứng dụng SwiftUI thông thường.

00:07:31.000 --> 00:07:38.000
Và bây giờ bạn có thể tương tác với các bản xem trước của các ứng dụng Mac ngay bên trong Xcode.

00:07:38.000 --> 00:07:48.000
Hãy xem bài nói chuyện "Xây dựng giao diện người dùng có lập trình với Bản xem trước Xcode" để tìm hiểu cách tận dụng các công cụ mới tuyệt vời này để tăng tốc độ phát triển ứng dụng và tiện ích của bạn.

00:07:48.000 --> 00:07:55.000
Bên cạnh các macro xem trước sức mạnh, Swift 5.9 cũng mang đến một loạt các cải tiến khác.

00:07:55.000 --> 00:08:02.000
Nhận tổng quan về tất cả những gì mới trong Swift bằng cách xếp hàng "Có gì mới trong Swift".

00:08:02.000 --> 00:08:09.000
Một cách khác để SwiftUI đến những nơi mới là thông qua các tiện ích mở rộng dành riêng cho SwiftUI cho các khuôn khổ khác của Apple.

00:08:09.000 --> 00:08:17.000
Một số khuôn khổ mang lại sự hỗ trợ mới hoặc được cải thiện và tôi muốn làm nổi bật một số điều mà tôi nghĩ là đặc biệt thú vị.

00:08:17.000 --> 00:08:24.000
MapKit cung cấp một bản cập nhật lớn cung cấp cho bạn sức mạnh của khung bản đồ tuyệt vời của Apple ngay trong mã SwiftUI của bạn.

00:08:24.000 --> 00:08:29.000
Chỉ cần nhập SwiftUI và MapKit để sử dụng các tính năng tuyệt vời này.

00:08:29.000 --> 00:08:31.000
Đặt một bản đồ trong tầm nhìn của bạn.

00:08:31.000 --> 00:08:35.000
Thêm các điểm đánh dấu tùy chỉnh, polylines và vị trí của người dùng.

00:08:35.000 --> 00:08:38.000
Định cấu hình các điều khiển có sẵn.

00:08:38.000 --> 00:08:45.000
Để tìm hiểu tất cả về việc thêm các bản đồ tuyệt vời vào ứng dụng SwiftUI của bạn, hãy xem buổi nói chuyện "Gặp gỡ MapKit cho SwiftUI".

00:08:45.000 --> 00:09:03.000
Trong mùa thứ hai, Swift Charts mang đến một loạt các cải tiến tuyệt vời, bao gồm biểu đồ cuộn, hỗ trợ tích hợp cho việc lựa chọn và điều mà tôi biết mọi người đã khao khát: biểu đồ bánh rán và hình tròn với SectorMark mới.

00:09:03.000 --> 00:09:10.000
Để tìm hiểu các tính năng mới này, hãy xem bài nói chuyện "Khám phá biểu đồ hình tròn và tính tương tác trong Biểu đồ Swift."

00:09:10.000 --> 00:09:19.000
Để xây dựng trải nghiệm thu hút và giữ chân khách hàng trung thành, bạn sẽ thích sự dễ dàng và sức mạnh của các cửa hàng đăng ký và mua hàng trong ứng dụng mới.

00:09:19.000 --> 00:09:24.000
Trình bày chế độ xem cửa hàng đăng ký với nội dung tiếp thị tùy chỉnh của bạn.

00:09:24.000 --> 00:09:31.000
Định cấu hình nền đầy đủ để phù hợp với thương hiệu của bạn và chọn từ nhiều tùy chọn kiểm soát khác nhau.

00:09:31.000 --> 00:09:38.000
Xem "Gặp gỡ StoreKit cho SwiftUI" để tăng sức mạnh cho trò chơi tiếp thị trong ứng dụng của bạn.

00:09:38.000 --> 00:09:48.000
Từ các nền tảng và tiện ích mới, đến tích hợp khung chéo và vẻ đẹp của watchOS, SwiftUI tiếp tục thúc đẩy trải nghiệm của nhà phát triển Apple về phía trước.

00:09:48.000 --> 00:09:52.000
Thật thú vị khi thấy tất cả các địa điểm mới để sử dụng SwiftUI, Jeff.

00:09:52.000 --> 00:09:57.000
Jeff: Chắc chắn rồi! Và chúng tôi cũng có rất nhiều cải tiến tuyệt vời hoạt động trên tất cả các nền tảng của chúng tôi.

00:09:57.000 --> 00:09:59.000
Curt: Thật vậy!

00:09:59.000 --> 00:10:01.000
Jeff: Chúng ta nên làm việc trên một ứng dụng sử dụng những cải tiến này.

00:10:01.000 --> 00:10:02.000
Curt: Ồ, đồng ý!

00:10:02.000 --> 00:10:05.000
Bạn đã nghĩ gì thêm về ý tưởng của tôi chưa?

00:10:05.000 --> 00:10:07.000
Jeff: Cái về chó? Curt: Vâng!

00:10:07.000 --> 00:10:11.000
Nó giống như ngắm chim nhưng dành cho chó!

00:10:11.000 --> 00:10:14.000
Jeff: Bạn có thực sự nghĩ rằng mọi người muốn có một ứng dụng xem chó không?

00:10:14.000 --> 00:10:18.000
Curt: Ồ, chắc chắn rồi! Bộ bài thuyết trình thực tế tự viết.

00:10:18.000 --> 00:10:23.000
Jeff: Với ý tưởng triệu đô của chúng tôi, đã đến lúc bắt đầu xây dựng ứng dụng của chúng tôi.

00:10:23.000 --> 00:10:32.000
Vì mọi ứng dụng tuyệt vời đều bắt đầu với một mô hình dữ liệu tuyệt vời, hãy bắt đầu bằng cách xem xét gói các tính năng mới tuyệt vời mà SwiftUI có để làm việc với dữ liệu ứng dụng của chúng tôi.

00:10:32.000 --> 00:10:39.000
Một trong những điều yêu thích của tôi về SwiftUI là cách nó cho phép tôi xác định giao diện người dùng của mình như một chức năng của trạng thái ứng dụng của tôi.

00:10:39.000 --> 00:10:46.000
Tôi rất vui khi chia sẻ bản nâng cấp lớn nhất về cách bạn xác định các loại mô hình của mình với SwiftUI: macro Observable mới.

00:10:46.000 --> 00:10:55.000
Các mô hình có thể quan sát được cho phép bạn sử dụng các mẫu SwiftUI quen thuộc cho luồng dữ liệu, đồng thời làm cho mã của bạn ngắn gọn và hiệu quả hơn.

00:10:55.000 --> 00:11:01.000
Đây là lớp mô hình mà tôi đã thiết lập để lưu trữ dữ liệu đại diện cho những chú chó mà tôi đã gặp khi ra ngoài.

00:11:01.000 --> 00:11:05.000
Để làm cho loại này có thể quan sát được, tôi sẽ thêm macro vào loại của mình.

00:11:05.000 --> 00:11:07.000
Đó là tất cả những gì tôi cần làm.

00:11:07.000 --> 00:11:12.000
Không giống như ObservableObject, không cần đánh dấu các thuộc tính là Đã xuất bản.

00:11:12.000 --> 00:11:18.000
Các mô hình có thể quan sát dễ dàng tích hợp vào các cơ chế SwiftUI hiện có cho luồng dữ liệu.

00:11:18.000 --> 00:11:21.000
Hãy sử dụng chế độ xem DogCard của tôi làm ví dụ.

00:11:21.000 --> 00:11:28.000
Khi sử dụng Observable trong Chế độ xem của bạn, SwiftUI sẽ tự động thiết lập các phụ thuộc vào các thuộc tính bạn đã đọc.

00:11:28.000 --> 00:11:34.000
Cũng không cần sử dụng trình bao bọc thuộc tính khi đọc, vì vậy mã chế độ xem của bạn sạch hơn.

00:11:34.000 --> 00:11:40.000
Và quan điểm này đang đọc tài sản isFavorite, vì vậy khi điều đó thay đổi, nó sẽ được đánh giá lại.

00:11:40.000 --> 00:11:50.000
Việc vô hiệu hóa chỉ xảy ra đối với các thuộc tính được đọc, vì vậy bạn có thể chuyển mô hình của mình qua các chế độ xem trung gian mà không cần kích hoạt bất kỳ cập nhật không cần thiết nào.

00:11:50.000 --> 00:12:01.000
SwiftUI bao gồm một số công cụ để xác định trạng thái của bạn và mối quan hệ của nó với quan điểm của bạn, một số trong đó được thiết kế để sử dụng với ObservableObject.

00:12:01.000 --> 00:12:11.000
Khi sử dụng Observable, điều này thậm chí còn trở nên đơn giản hơn vì nó được thiết kế để hoạt động trực tiếp với các thuộc tính động của Trạng thái và Môi trường.

00:12:11.000 --> 00:12:21.000
Ngoài việc mô hình hóa các giá trị chỉ đọc, Observables cũng phù hợp tự nhiên để thể hiện trạng thái có thể thay đổi, như trên biểu mẫu này để nhìn thấy một con chó mới.

00:12:21.000 --> 00:12:32.000
Mô hình được xác định bằng cách sử dụng thuộc tính động Trạng thái và tôi đang chuyển các liên kết đến các thuộc tính của nó cho các phần tử biểu mẫu chịu trách nhiệm chỉnh sửa thuộc tính đó.

00:12:32.000 --> 00:12:37.000
Cuối cùng, các loại có thể quan sát được tích hợp liền mạch vào môi trường.

00:12:37.000 --> 00:12:44.000
Vì các chế độ xem trong ứng dụng của chúng tôi muốn có một cách để tìm nạp người dùng hiện tại, tôi đã thêm nó vào môi trường của chế độ xem gốc của mình.

00:12:44.000 --> 00:12:49.000
Chế độ xem hồ sơ người dùng sau đó đọc giá trị bằng cách sử dụng thuộc tính động Môi trường.

00:12:49.000 --> 00:12:54.000
Tôi đang sử dụng loại làm khóa môi trường ở đây, nhưng các khóa tùy chỉnh cũng được hỗ trợ.

00:12:54.000 --> 00:13:02.000
Hãy chắc chắn nắm bắt "Khám phá quan sát với SwiftUI" để tìm hiểu thêm về cách bạn có thể tận dụng công cụ mới mạnh mẽ này.

00:13:02.000 --> 00:13:06.000
Tôi thích cách Observable cho phép tôi viết mã rõ ràng và súc tích.

00:13:06.000 --> 00:13:16.000
Nó đã cho tôi một khởi đầu tuyệt vời cho ứng dụng của mình, nhưng tôi thực sự muốn đảm bảo rằng mọi thay đổi đối với mô hình dữ liệu của tôi vẫn tồn tại, để tôi không bao giờ mất dấu tất cả những chú chó con yêu thích của mình.

00:13:16.000 --> 00:13:20.000
SwiftData là một khuôn khổ hoàn toàn mới để mô hình hóa và quản lý dữ liệu.

00:13:20.000 --> 00:13:24.000
Nó nhanh và có thể mở rộng và hoạt động tốt với SwiftUI.

00:13:24.000 --> 00:13:31.000
Các mô hình SwiftData được thể hiện hoàn toàn bằng mã của chúng, khiến chúng phù hợp tự nhiên với bất kỳ ứng dụng SwiftUI nào.

00:13:31.000 --> 00:13:37.000
Để thiết lập loại mô hình Chó của tôi cho SwiftData, tôi sẽ chuyển từ sử dụng Observable sang macro Mô hình.

00:13:37.000 --> 00:13:39.000
Đây là thay đổi duy nhất tôi cần thực hiện.

00:13:39.000 --> 00:13:46.000
Ngoài sự kiên trì được cung cấp bởi SwiftData, các mô hình cũng nhận được tất cả các lợi ích của việc sử dụng Observable.

00:13:46.000 --> 00:13:48.000
Nó thực sự mạnh mẽ.

00:13:48.000 --> 00:13:54.000
Màn hình chính của ứng dụng xem chó của chúng tôi hiển thị một chồng cuộn các doggos đã gặp gần đây.

00:13:54.000 --> 00:13:58.000
Hãy cùng xem qua những thay đổi cần thiết để sử dụng SwiftData tại đây.

00:13:58.000 --> 00:14:04.000
Đầu tiên, tôi sẽ thêm một vùng chứa mô hình vào định nghĩa ứng dụng của mình và cung cấp cho nó loại mô hình của tôi.

00:14:04.000 --> 00:14:11.000
Sau đó, trong mã xem của tôi, tôi sẽ chuyển mảng chó của mình sang sử dụng thuộc tính động Truy vấn mới.

00:14:11.000 --> 00:14:16.000
Sử dụng Truy vấn sẽ yêu cầu SwiftData tìm nạp các giá trị mô hình từ cơ sở dữ liệu cơ bản.

00:14:16.000 --> 00:14:22.000
Khi dữ liệu thay đổi, như khi tôi phát hiện ra một con chó mới, chế độ xem của tôi sẽ bị vô hiệu.

00:14:22.000 --> 00:14:35.000
Truy vấn cực kỳ hiệu quả đối với các tập dữ liệu lớn và cho phép tùy chỉnh cách dữ liệu được trả về, chẳng hạn như thay đổi thứ tự sắp xếp để sử dụng ngày tôi phát hiện ra con chó, điều này giúp trải nghiệm tốt hơn trong ứng dụng.

00:14:35.000 --> 00:14:40.000
SwiftData cũng hoạt động tốt để lưu trữ dữ liệu của tài liệu trên macOS và iOS.

00:14:40.000 --> 00:14:52.000
Tôi quyết định tôi muốn có một cách nhanh chóng để tạo mẫu một số phương pháp điều trị trực quan thẻ chó cho ứng dụng của chúng tôi, vì vậy tôi đã xây dựng ứng dụng dựa trên tài liệu nhỏ này để cộng tác với Curt và các nhà thiết kế của chúng tôi.

00:14:52.000 --> 00:14:58.000
Các ứng dụng dựa trên tài liệu có thể tận dụng tất cả các chức năng của SwiftData bằng cách sử dụng trình khởi tạo mới.

00:14:58.000 --> 00:15:06.000
SwiftUI sau đó sẽ sử dụng SwiftData để lưu trữ cơ bản của mỗi tài liệu, cũng như tự động thiết lập một vùng chứa mô hình.

00:15:06.000 --> 00:15:14.000
Để tìm hiểu thêm về SwiftData và cách nó tích hợp với SwiftUI, vui lòng xem "Gặp gỡ SwiftData" và "Xây dựng ứng dụng với SwiftData".

00:15:14.000 --> 00:15:32.000
Ngoài hỗ trợ SwiftData, DocumentGroup cũng có được một số khả năng nền tảng mới khi chạy trên iOS 17 hoặc iPadOS 17, chẳng hạn như chia sẻ tự động và hỗ trợ đổi tên tài liệu, cũng như hoàn tác các điều khiển trên thanh công cụ.

00:15:32.000 --> 00:15:39.000
Thanh tra là một công cụ sửa đổi mới để hiển thị chi tiết về lựa chọn hoặc ngữ cảnh hiện tại.

00:15:39.000 --> 00:15:43.000
Nó được trình bày như một phần riêng biệt trong giao diện của bạn.

00:15:43.000 --> 00:15:47.000
Trên macOS, Thanh tra trình bày dưới dạng thanh bên cuối.

00:15:47.000 --> 00:15:50.000
Cũng như trên iPadOS trong một lớp kích thước thông thường.

00:15:50.000 --> 00:15:55.000
Trong các lớp kích thước nhỏ gọn, nó sẽ thể hiện dưới dạng một tờ giấy.

00:15:55.000 --> 00:16:02.000
Để khám phá tất cả các chi tiết trên Thanh tra, hãy xem "Thanh tra viên trong SwiftUI: khám phá các chi tiết."

00:16:02.000 --> 00:16:09.000
Các hộp thoại đã được cung cấp một số API tùy chỉnh mới trong iOS 17 và macOS Sonoma.

00:16:09.000 --> 00:16:18.000
Tôi đang sử dụng một số công cụ sửa đổi mới để cung cấp cho hộp thoại xuất hình ảnh của mình một số thông tin hữu ích, như điều chỉnh nhãn của nút xác nhận.

00:16:18.000 --> 00:16:32.000
Mức độ nghiêm trọng tăng lên giúp thu hút sự chú ý đến các hộp thoại xác nhận quan trọng và bao gồm nút chuyển đổi ức chế cho thấy sở thích rằng hộp thoại không nên xuất hiện cho các tương tác tiếp theo.

00:16:32.000 --> 00:16:38.000
Cuối cùng, thêm một Liên kết Trợ giúp có thể là một hướng dẫn để biết thêm thông tin về mục đích của hộp thoại.

00:16:38.000 --> 00:16:49.000
Danh sách và bảng là một phần quan trọng của hầu hết các ứng dụng và SwiftUI đã mang đến một số tính năng và API mới để tinh chỉnh chúng trong iOS 17 và macOS Sonoma.

00:16:49.000 --> 00:16:53.000
Các bảng hỗ trợ tùy chỉnh thứ tự cột và khả năng hiển thị của chúng.

00:16:53.000 --> 00:17:00.000
Khi kết hợp với thuộc tính động SceneStorage, các tùy chọn này có thể được duy trì trong suốt quá trình chạy ứng dụng của bạn.

00:17:00.000 --> 00:17:09.000
Bạn cung cấp cho bảng một giá trị đại diện cho trạng thái tùy chỉnh và cung cấp cho mỗi cột một mã định danh ổn định duy nhất.

00:17:09.000 --> 00:17:12.000
Các bảng bây giờ cũng có tất cả sức mạnh của OutlineGroup được tích hợp sẵn.

00:17:12.000 --> 00:17:22.000
Điều này thật tuyệt vời cho các bộ dữ liệu lớn cho vay một cấu trúc phân cấp, như cái này nhóm một số con chó yêu thích của tôi với cha mẹ đáng tự hào của chúng.

00:17:22.000 --> 00:17:30.000
Chỉ cần sử dụng DisclosureTableRow mới để biểu diễn các hàng có chứa các hàng khác và xây dựng phần còn lại của bảng của bạn như bình thường.

00:17:30.000 --> 00:17:35.000
Các phần trong danh sách hoặc bảng đã nhận được hỗ trợ cho việc mở rộng theo chương trình.

00:17:35.000 --> 00:17:44.000
Tôi đã sử dụng nó ở đây trong thanh bên của ứng dụng của mình để hiển thị phần vị trí bị thu gọn ban đầu, nhưng trong khi vẫn cho phép mở rộng.

00:17:44.000 --> 00:17:51.000
Trình khởi tạo mới có liên kết với một giá trị phản ánh trạng thái mở rộng hiện tại của phần.

00:17:51.000 --> 00:18:01.000
Đối với các tập dữ liệu nhỏ hơn, các bảng cũng đã đạt được một số khả năng tạo kiểu mới, chẳng hạn như cách hiển thị nền hàng và tiêu đề cột.

00:18:01.000 --> 00:18:09.000
Và cuối cùng, các điều khiển tùy chỉnh như xếp hạng sao của tôi cũng sẽ được hưởng lợi từ thuộc tính môi trường nổi bật nền mới.

00:18:09.000 --> 00:18:16.000
Sử dụng kiểu tiền cảnh ít nổi bật hơn khi nền nổi bật cho phép điều khiển tùy chỉnh của tôi cảm thấy như ở nhà trong danh sách.

00:18:16.000 --> 00:18:28.000
Ngoài những API này và các API khác cho phép bạn tinh chỉnh giao diện của danh sách và bảng, chúng tôi cũng đã thực hiện những cải tiến lớn đối với hiệu suất, đặc biệt là khi xử lý các tập dữ liệu lớn.

00:18:28.000 --> 00:18:37.000
Để tìm hiểu thêm về điều này và các cách bạn có thể tối ưu hóa chế độ xem SwiftUI của riêng mình, hãy xem "Demystify SwiftUI performance".

00:18:37.000 --> 00:18:45.000
Từ Observable đến SwiftData đến Inspector và các tùy chỉnh bảng, làm việc với dữ liệu trong ứng dụng của bạn giống như một trải nghiệm hoàn toàn mới.

00:18:45.000 --> 00:18:52.000
Curt: Với mô hình dữ liệu và bảng mà Jeff đã tổng hợp với nhau, chúng ta có cốt lõi của một ứng dụng tuyệt vời.

00:18:52.000 --> 00:18:57.000
Tôi muốn thêm một số pizazz bằng cách sử dụng các API hoạt hình mới phi thường.

00:18:57.000 --> 00:19:02.000
Tôi nghĩ sẽ thật tuyệt nếu có một ứng dụng Apple TV để xem một bộ sưu tập ảnh về chó.

00:19:02.000 --> 00:19:07.000
Đây là một hình ảnh động mà tôi đang làm để chọn người xem hiện tại.

00:19:07.000 --> 00:19:11.000
Tôi đã xây dựng cái này với Keyframe Animator API mới.

00:19:11.000 --> 00:19:15.000
Các nhà làm phim hoạt hình khung hình chính cho phép tôi tạo hiệu ứng động song song cho nhiều thuộc tính.

00:19:15.000 --> 00:19:23.000
Tôi cung cấp cho người làm phim hoạt hình một giá trị chứa các thuộc tính có thể hoạt hình và một phần của trạng thái tương đương.

00:19:23.000 --> 00:19:26.000
Những thay đổi đối với trạng thái kích hoạt hình ảnh động của tôi.

00:19:26.000 --> 00:19:34.000
Trong lần đóng đầu tiên, tôi xây dựng một chế độ xem, được sửa đổi bởi các thuộc tính hoạt hình của tôi, như độ lệch dọc của logo của tôi.

00:19:34.000 --> 00:19:38.000
Trong lần đóng thứ hai, tôi xác định các thuộc tính này thay đổi như thế nào theo thời gian.

00:19:38.000 --> 00:19:44.000
Ví dụ, bản nhạc đầu tiên xác định hình ảnh động của thuộc tính Dịch dọc của tôi.

00:19:44.000 --> 00:19:50.000
Tôi kéo logo của mình xuống 30 điểm trong quý đầu tiên giây bằng cách sử dụng hình ảnh động mùa xuân.

00:19:50.000 --> 00:19:54.000
Sau đó, tôi thực hiện cú nhảy Beagle của mình và hạ cánh bằng cách sử dụng một đường cong hình khối.

00:19:54.000 --> 00:19:59.000
Cuối cùng, tôi mang chú chó này về nhà với hình ảnh động mùa xuân tự nhiên.

00:19:59.000 --> 00:20:03.000
Tôi xác định các bản nhạc bổ sung cho các thuộc tính hoạt hình khác của mình.

00:20:03.000 --> 00:20:08.000
Tất cả các bản nhạc này chạy song song để tạo ra hình ảnh động thú vị này.

00:20:08.000 --> 00:20:16.000
Để tìm hiểu cách tận dụng các nhà làm phim hoạt hình khung hình chính trong ứng dụng của bạn, hãy xem "Gióa theo cách của bạn thông qua các hình ảnh động nâng cao trong SwiftUI."

00:20:16.000 --> 00:20:21.000
Tôi cũng đang làm việc trên một ứng dụng Apple Watch để ghi lại những lần nhìn thấy chó khi tôi ra ngoài chạy.

00:20:21.000 --> 00:20:26.000
Nó khá đơn giản cho đến nay, chỉ là biểu tượng hạnh phúc của chúng tôi và một nút để đăng ký nhìn thấy.

00:20:26.000 --> 00:20:29.000
Tôi muốn tạo hiệu ứng động cho biểu tượng này khi tôi nhấn vào nút.

00:20:29.000 --> 00:20:33.000
Đây là một nơi tốt cho một nhà làm phim hoạt hình giai đoạn.

00:20:33.000 --> 00:20:36.000
Trình làm phim hoạt hình pha đơn giản hơn trình làm phim hoạt hình khung hình chính.

00:20:36.000 --> 00:20:41.000
Thay vì các bản nhạc song song, nó bước qua một chuỗi các giai đoạn duy nhất.

00:20:41.000 --> 00:20:46.000
Điều này cho phép tôi bắt đầu một hoạt hình khi hoạt hình trước đó kết thúc.

00:20:46.000 --> 00:20:52.000
Tôi cung cấp cho nhà làm phim hoạt hình một chuỗi các giai đoạn và bảo nó chạy hoạt hình của tôi bất cứ khi nào số lần nhìn thấy của tôi thay đổi.

00:20:52.000 --> 00:20:59.000
Sau đó, trong lần đóng cửa đầu tiên này, tôi đặt vòng quay và tỷ lệ của chú chó hạnh phúc của mình dựa trên giai đoạn hiện tại.

00:20:59.000 --> 00:21:05.000
Đóng cửa thứ hai cho SwiftUI biết cách tạo hiệu ứng động trong từng giai đoạn.

00:21:05.000 --> 00:21:07.000
Tôi đang sử dụng một số hình ảnh động mùa xuân mới thú vị ở đây.

00:21:07.000 --> 00:21:10.000
Tôi chỉ thích những cái tên này.

00:21:10.000 --> 00:21:14.000
Ai mà không muốn một hình ảnh động linh hoạt hay bồng bềnh?

00:21:14.000 --> 00:21:18.000
Và đối với giai đoạn phát triển của tôi, tôi đang sử dụng một mùa xuân hoàn toàn tùy chỉnh.

00:21:18.000 --> 00:21:23.000
Lò xo bây giờ mất một khoảng thời gian và nảy lên, làm cho chúng dễ mô tả hơn.

00:21:23.000 --> 00:21:28.000
Bạn có thể sử dụng tất cả các lò xo mới này ở mọi nơi có hoạt ảnh SwiftUI.

00:21:28.000 --> 00:21:31.000
Hình ảnh động mùa xuân có cảm giác tự nhiên, đẹp đẽ.

00:21:31.000 --> 00:21:37.000
Chúng khớp với vận tốc của bất kỳ hình ảnh động nào trước đó và ổn định giá trị cuối cùng của chúng với ma sát thực tế.

00:21:37.000 --> 00:21:44.000
Bây giờ chúng là hình ảnh động mặc định cho các ứng dụng được xây dựng trên hoặc sau iOS 17 và các bản phát hành được căn chỉnh.

00:21:44.000 --> 00:21:50.000
Bây giờ tôi hài lòng với hình ảnh động của mình, nhưng khi tôi ra ngoài chạy, sẽ thật tuyệt nếu nhận được một số phản hồi xúc giác.

00:21:50.000 --> 00:21:58.000
Phản hồi xúc giác cung cấp phản ứng xúc giác, chẳng hạn như chạm, để thu hút sự chú ý và củng cố các hành động và sự kiện.

00:21:58.000 --> 00:22:03.000
Tôi nghĩ rằng một cú chạm vào cổ tay sẽ giúp tôi tự tin hơn rằng tôi đã không bỏ lỡ một con chó.

00:22:03.000 --> 00:22:07.000
Phản hồi xúc giác thật dễ dàng với API phản hồi cảm giác mới.

00:22:07.000 --> 00:22:16.000
Để phát phản hồi xúc giác, tôi chỉ cần đính kèm công cụ sửa đổi cảm biến phản hồi, chỉ định loại phản hồi tôi muốn và khi nào nó sẽ xảy ra.

00:22:16.000 --> 00:22:21.000
Công cụ sửa đổi cảm biến phản hồi hoạt động trên tất cả các nền tảng hỗ trợ phản hồi xúc giác.

00:22:21.000 --> 00:22:30.000
Các nền tảng khác nhau hỗ trợ các loại phản hồi khác nhau, vì vậy hãy xem Nguyên tắc Giao diện Con người để tìm hiểu loại phản hồi nào sẽ tốt nhất trong ứng dụng của bạn.

00:22:30.000 --> 00:22:37.000
Tôi cũng đang làm việc trên một hình ảnh động cho màn hình chào mừng, sử dụng công cụ sửa đổi hiệu ứng hình ảnh mới.

00:22:37.000 --> 00:22:42.000
Công cụ sửa đổi hiệu ứng hình ảnh cho phép tôi cập nhật những bức ảnh chó này dựa trên vị trí của chúng.

00:22:42.000 --> 00:22:45.000
Và tôi không cần GeometryReader để làm điều đó.

00:22:45.000 --> 00:22:49.000
Tôi có một mô phỏng nhỏ di chuyển tiêu điểm xung quanh màn hình.

00:22:49.000 --> 00:22:53.000
Chấm đỏ này cho thấy ý tôi khi nói đến tiêu điểm.

00:22:53.000 --> 00:22:58.000
Tôi liên kết một không gian tọa độ với lưới này hiển thị tất cả những con chó.

00:22:58.000 --> 00:23:03.000
Sau đó, bên trong chế độ xem DogCircle của tôi, tôi thêm một hiệu ứng hình ảnh.

00:23:03.000 --> 00:23:07.000
Việc đóng cửa khiến nội dung của tôi sửa đổi và một proxy hình học.

00:23:07.000 --> 00:23:11.000
Tôi đang chuyển proxy hình học sang một phương pháp trợ giúp để tính toán tỷ lệ.

00:23:11.000 --> 00:23:21.000
Tôi có thể sử dụng proxy hình học để lấy kích thước chế độ xem lưới của mình và khung của một vòng tròn chó duy nhất so với chế độ xem lưới của tôi.

00:23:21.000 --> 00:23:28.000
Điều đó cho phép tôi tính toán khoảng cách của bất kỳ con chó nào so với tiêu điểm của mô phỏng, vì vậy tôi có thể mở rộng quy mô các con chó tập trung.

00:23:28.000 --> 00:23:33.000
Với hiệu ứng hình ảnh, tôi có thể làm tất cả những điều này mà không cần sử dụng GeometryReader.

00:23:33.000 --> 00:23:38.000
Và nó tự động thích nghi với các kích cỡ khác nhau.

00:23:38.000 --> 00:23:41.000
Tôi muốn chia sẻ thêm một ví dụ nữa.

00:23:41.000 --> 00:23:46.000
Tôi đã chơi với một tính năng để gửi tin nhắn chó tốt cho những người của những con chó mà tôi đã gặp.

00:23:46.000 --> 00:23:51.000
Tôi nghĩ sẽ rất thú vị khi tạo kiểu cho tên của chú chó để làm cho nó nổi bật.

00:23:51.000 --> 00:23:58.000
Điều này thật dễ dàng bây giờ khi tôi có thể nội suy văn bản với kiểu tiền cảnh ngay bên trong một chế độ xem văn bản khác.

00:23:58.000 --> 00:23:59.000
Và kiểm tra nó!

00:23:59.000 --> 00:24:04.000
Tôi có thể điều chỉnh kiểu dáng bằng cách sử dụng các thanh trượt này.

00:24:04.000 --> 00:24:06.000
Bây giờ nó hoạt động như thế nào?

00:24:06.000 --> 00:24:08.000
Đây là cách tôi định nghĩa phong cách.

00:24:08.000 --> 00:24:17.000
Tôi đang chuyển khoảng cách sọc và góc của mình, cùng với một màu từ danh mục tài sản của tôi, sang một bộ đổ bóng kim loại tùy chỉnh.

00:24:17.000 --> 00:24:31.000
Sử dụng Thư viện đổ bóng mới của SwiftUI, tôi có thể biến các chức năng đổ bóng kim loại trực tiếp thành các kiểu hình dạng SwiftUI, như kiểu này hiển thị các sọc trong tên của Furdinand.

00:24:31.000 --> 00:24:41.000
Nếu bạn muốn lấy bộ đổ bóng Metal ra để quay, chỉ cần thêm tệp Metal mới vào dự án của bạn và gọi hàm đổ bóng của bạn bằng ShaderLibrary trong SwiftUI.

00:24:41.000 --> 00:24:44.000
Có một điều khác trong ví dụ này mà tôi muốn chỉ ra.

00:24:44.000 --> 00:24:51.000
Lưu ý khi tôi nhấn vào cuối các bản nhạc trên thanh trượt, biểu tượng sẽ cho điểm nảy thỏa mãn này.

00:24:51.000 --> 00:24:55.000
Hiệu ứng đó được tích hợp vào Slider trên macOS và iOS.

00:24:55.000 --> 00:25:01.000
Bạn cũng có thể thêm nó vào biểu tượng của riêng mình bằng công cụ sửa đổi hiệu ứng biểu tượng mới.

00:25:01.000 --> 00:25:07.000
Chỉ cần áp dụng công cụ sửa đổi này để tạo hiệu ứng động cho Biểu tượng SF hoặc tất cả các biểu tượng trong hệ thống phân cấp chế độ xem.

00:25:07.000 --> 00:25:15.000
Các biểu tượng hỗ trợ nhiều hiệu ứng khác nhau, bao gồm hoạt ảnh liên tục với xung và màu sắc thay đổi.

00:25:15.000 --> 00:25:25.000
Trạng thái thay đổi theo tỷ lệ, xuất hiện và biến mất, và thay thế, và thông báo sự kiện với sự trả lại.

00:25:25.000 --> 00:25:33.000
Xem "Tác động các biểu tượng trong ứng dụng của bạn" để tìm hiểu về các phương pháp làm hài lòng mọi người tốt nhất để sử dụng các hiệu ứng biểu tượng.

00:25:33.000 --> 00:25:37.000
Trước khi rời khỏi ví dụ này, tôi muốn chỉ ra một tính năng cuối cùng.

00:25:37.000 --> 00:25:40.000
Chú ý các đơn vị trên văn bản ở đây.

00:25:40.000 --> 00:25:51.000
Trước đây tôi có thể đã sử dụng chữ hoa nhỏ cho hiệu ứng này, nhưng bây giờ tôi có thể có được giao diện này bằng cách áp dụng công cụ sửa đổi textScale mới cho các đơn vị của mình.

00:25:51.000 --> 00:26:01.000
Nếu Jeff và tôi mang ứng dụng của chúng tôi đến thị trường Trung Quốc, các đơn vị sẽ có kích thước chính xác, mặc dù khái niệm viết hoa nhỏ không phải là một phần của kiểu chữ bằng tiếng Trung.

00:26:01.000 --> 00:26:05.000
Chúng tôi có một công cụ khác để giúp các ứng dụng hoạt động tốt ở nhiều ngôn ngữ.

00:26:05.000 --> 00:26:09.000
Một số ngôn ngữ, như tiếng Thái, sử dụng các dạng chữ cái cao hơn.

00:26:09.000 --> 00:26:22.000
Khi văn bản từ một trong những ngôn ngữ này được nhúng vào văn bản được bản địa hóa bằng ngôn ngữ có dạng chữ cái ngắn hơn, như tiếng Anh, văn bản cao hơn có thể bị đông đúc hoặc cắt bớt.

00:26:22.000 --> 00:26:32.000
Khi chúng tôi biết rằng đây có thể là một vấn đề - ví dụ, nếu tên chó của chúng tôi có nguồn gốc từ đám đông trên toàn cầu - chúng tôi có thể áp dụng công cụ sửa đổi typesettingLanguage.

00:26:32.000 --> 00:26:37.000
Điều này cho SwiftUI biết rằng văn bản có thể cần thêm dung lượng.

00:26:37.000 --> 00:26:46.000
Tôi đang rất vui khi sử dụng các API mới này, nhưng điều quan trọng là phải chọn hình ảnh động một cách trang nhã để tránh áp đảo mọi người.

00:26:46.000 --> 00:26:52.000
Để tìm hiểu về các nguyên tắc cơ bản của hoạt hình trong SwiftUI, hãy xem "Khám phá hoạt hình SwiftUI".

00:26:52.000 --> 00:27:01.000
Sau đó, trong "Animate with springs", Jacob sẽ giúp bạn xây dựng các hình ảnh động mang lại cảm giác như ở nhà trên thiết bị của mọi người.

00:27:01.000 --> 00:27:05.000
Bề rộng của các API hoạt hình mới trong SwiftUI thật tuyệt vời.

00:27:05.000 --> 00:27:07.000
Tôi chỉ làm xước bề mặt ở đây.

00:27:07.000 --> 00:27:14.000
Thậm chí còn có nhiều điều để khám phá, từ trình xử lý hoàn thành hoạt ảnh đến xây dựng hoạt ảnh hoàn toàn tùy chỉnh.

00:27:14.000 --> 00:27:18.000
Tôi hy vọng bạn thích những API này nhiều như tôi.

00:27:18.000 --> 00:27:23.000
Jeff: Tôi thích cách tất cả những hình ảnh động và hiệu ứng mới này thực sự làm cho ứng dụng của chúng ta trở nên sống động.

00:27:23.000 --> 00:27:28.000
Bây giờ, chúng ta hãy xem xét một số API tương tác mới để có những bước cuối cùng.

00:27:28.000 --> 00:27:38.000
Tương tác là trung tâm của bất kỳ trải nghiệm ứng dụng tuyệt vời nào và đây chỉ là một vài trong số các API được cập nhật đến với iOS 17 và các bản phát hành phù hợp.

00:27:38.000 --> 00:27:45.000
Màn hình của tôi về những chú chó gặp gần đây có thể sử dụng thêm một chút tinh tế để đánh bóng nó một chút cuối cùng.

00:27:45.000 --> 00:27:53.000
Tôi muốn thêm một số hiệu ứng hình ảnh vào thẻ chó của mình khi chúng chuyển vào và ra khỏi khu vực có thể nhìn thấy trong chế độ xem cuộn của tôi.

00:27:53.000 --> 00:28:00.000
Công cụ sửa đổi chuyển tiếp cuộn rất giống với công cụ sửa đổi hiệu ứng hình ảnh Curt đã sử dụng trước đó cho màn hình chào mừng.

00:28:00.000 --> 00:28:04.000
Nó cho phép bạn áp dụng các hiệu ứng cho các mục trong chế độ xem cuộn của mình.

00:28:04.000 --> 00:28:13.000
Sử dụng các hiệu ứng tỷ lệ và độ mờ đục đã mang lại cho tôi một chút đánh bóng mà tôi muốn, chỉ với một vài dòng mã bổ sung.

00:28:13.000 --> 00:28:18.000
Tôi cũng muốn thêm một danh sách cuộn bên các công viên chó yêu thích của tôi vào màn hình này.

00:28:18.000 --> 00:28:22.000
SwiftUI đã thêm một số tính năng tuyệt vời để cho phép tôi xây dựng cái này.

00:28:22.000 --> 00:28:27.000
Phía trên chồng chó thẳng đứng của tôi, tôi sẽ thả vào một chồng ngang cho các thẻ công viên.

00:28:27.000 --> 00:28:38.000
Tôi đang sử dụng công cụ sửa đổi containerRelativeFrame mới để định cỡ các thẻ công viên này so với kích thước hiển thị của chế độ xem cuộn ngang.

00:28:38.000 --> 00:28:42.000
Số lượng xác định có bao nhiêu đoạn để chia màn hình thành.

00:28:42.000 --> 00:28:47.000
Khoảng thời gian cho biết mỗi lượt xem nên thực hiện bao nhiêu đoạn trong số đó.

00:28:47.000 --> 00:28:52.000
Điều này khá tuyệt, nhưng tôi muốn thẻ công viên của mình được gắn vào vị trí.

00:28:52.000 --> 00:28:56.000
Công cụ sửa đổi scrollTargetLayout mới giúp điều đó trở nên dễ dàng.

00:28:56.000 --> 00:29:03.000
Tôi sẽ thêm nó vào LazyHStack và sửa đổi chế độ xem cuộn để căn chỉnh theo chế độ xem trong bố cục được nhắm mục tiêu.

00:29:03.000 --> 00:29:08.000
Ngoài việc căn chỉnh chế độ xem, chế độ xem cuộn cũng có thể được xác định để sử dụng hành vi phân trang.

00:29:08.000 --> 00:29:15.000
Và để có trải nghiệm thực sự tùy chỉnh, bạn có thể xác định hành vi của riêng mình bằng giao thức scrollTargetBehavior.

00:29:15.000 --> 00:29:20.000
Tôi cũng nghĩ rằng mutts của tôi sẽ xứng đáng nhận được một chút giải thưởng khi chúng ở trên cùng của chế độ xem cuộn.

00:29:20.000 --> 00:29:28.000
Công cụ sửa đổi scrollPosition mới có liên kết với ID của mục trên cùng và nó được cập nhật khi tôi cuộn.

00:29:28.000 --> 00:29:31.000
Bằng cách này, tôi luôn biết ai là con chó hàng đầu.

00:29:31.000 --> 00:29:39.000
Để tìm hiểu thêm về tất cả những điều này và những cải tiến tuyệt vời khác đối với Chế độ xem cuộn, hãy nhớ xem "Ngoài chế độ xem cuộn".

00:29:39.000 --> 00:29:44.000
Hình ảnh hiện hỗ trợ kết xuất nội dung với dải động cao.

00:29:44.000 --> 00:29:53.000
Bằng cách áp dụng công cụ sửa đổi allowedDynamicRange, những hình ảnh đẹp trong màn hình thư viện của ứng dụng của chúng tôi có thể được hiển thị với độ trung thực đầy đủ của chúng.

00:29:53.000 --> 00:29:58.000
Tuy nhiên, tốt nhất là sử dụng cái này một cách tiết kiệm và thường là khi hình ảnh đứng một mình.

00:29:58.000 --> 00:30:09.000
Các ứng dụng được viết bằng SwiftUI hoạt động tốt với các tính năng trợ năng ngay lập tức, nhưng bạn có thể làm cho chúng tốt hơn với một số API trợ năng mới mà chúng tôi đang giới thiệu.

00:30:09.000 --> 00:30:17.000
Chú chó phiêu lưu trong bức ảnh này hơi quá xa để có thể nhìn thấy, vì vậy tôi đã áp dụng cử chỉ phóng đại để cho phép phóng to.

00:30:17.000 --> 00:30:21.000
Tôi cũng sẽ thêm công cụ sửa đổi accessibilityZoomAction mới vào chế độ xem của mình.

00:30:21.000 --> 00:30:29.000
Điều này cho phép các công nghệ hỗ trợ như VoiceOver truy cập cùng một chức năng mà không cần sử dụng cử chỉ.

00:30:29.000 --> 00:30:36.000
Tôi sẽ chỉ cập nhật mức thu phóng tùy thuộc vào hướng của hành động và tôi có thể thấy cô ấy đã làm trò nghịch ngợm nào cho đến bây giờ.

00:30:36.000 --> 00:30:40.000
VoiceOver: Phóng to chế độ xem hình ảnh. Hình ảnh.

00:30:40.000 --> 00:30:50.000
Jeff: Để tìm hiểu thêm về tất cả các chức năng trợ năng mới trên các nền tảng của Apple, hãy nhớ xem "Xây dựng các ứng dụng có thể truy cập bằng SwiftUI và UIKit."

00:30:50.000 --> 00:30:58.000
Color hiện hỗ trợ sử dụng cú pháp thành viên tĩnh để tra cứu các màu tùy chỉnh được xác định trong danh mục nội dung ứng dụng của bạn.

00:30:58.000 --> 00:31:04.000
Điều này mang lại sự an toàn cho thời gian biên dịch khi sử dụng chúng, vì vậy bạn sẽ không bao giờ mất thời gian cho lỗi đánh máy.

00:31:04.000 --> 00:31:10.000
Đối với ứng dụng tài liệu mà tôi đã hiển thị trước đó, tôi đã thêm một menu chứa một số hành động hữu ích vào thanh công cụ.

00:31:10.000 --> 00:31:21.000
Phần trên cùng của menu là ControlGroup với phong cách compactMenu mới, hiển thị các mục của nó dưới dạng biểu tượng trong một ngăn xếp ngang.

00:31:21.000 --> 00:31:26.000
Bộ chọn màu thẻ được định nghĩa là bộ chọn với kiểu bảng màu mới.

00:31:26.000 --> 00:31:37.000
Sử dụng phong cách này trong buổi hòa nhạc với hình ảnh biểu tượng mang lại sự thể hiện trực quan tuyệt vời trong các menu, đặc biệt là một phong cách như thế này, nơi tôi có thể sử dụng tông màu của nhãn để phân biệt chúng.

00:31:37.000 --> 00:31:45.000
Cuối cùng, công cụ sửa đổi paletteSelectionEffect cho phép tôi sử dụng một biến thể biểu tượng để đại diện cho mục đã chọn trong bộ chọn.

00:31:45.000 --> 00:31:52.000
Với thực đơn của tôi tại chỗ, thẻ chó của Buddy giờ đây có thể có màu yêu thích của anh ấy, màu vàng bóng tennis.

00:31:52.000 --> 00:31:59.000
Các nút viền bây giờ có thể được xác định với các hình dạng tích hợp mới, chẳng hạn như hình tròn và hình chữ nhật tròn.

00:31:59.000 --> 00:32:04.000
Những kiểu hình dạng đường viền mới này hoạt động trên iOS, watchOS và macOS.

00:32:04.000 --> 00:32:11.000
Các nút trên macOS và iOS hiện có thể phản ứng với các hành động kéo, như nút này trong trình chỉnh sửa của tôi mở cửa sổ bật lên.

00:32:11.000 --> 00:32:23.000
Công cụ sửa đổi springLoadingBehavior mới chỉ ra rằng một nút sẽ kích hoạt hành động của nó khi một đoạn kéo tạm dừng trên nó hoặc khi buộc nhấp vào nó trên macOS.

00:32:23.000 --> 00:32:27.000
Các nút trên tvOS có thể tận dụng tuyệt vời hiệu ứng di chuột nổi bật mới.

00:32:27.000 --> 00:32:37.000
Tôi đã sử dụng nó trên các hình ảnh thư viện của chúng tôi và chỉ áp dụng nó vào phần hình ảnh trên nhãn nút của tôi, để tạo ra một hiệu ứng cảm giác như ở nhà trên nền tảng.

00:32:37.000 --> 00:32:42.000
Các nút này cũng sử dụng kiểu không viền, hiện đã có trên tvOS.

00:32:42.000 --> 00:32:49.000
Bàn phím phần cứng rất tuyệt vời để cung cấp chất tăng tốc cho các tương tác phổ biến trong ứng dụng của bạn.

00:32:49.000 --> 00:32:57.000
Các chế độ xem có thể tập trung trên các nền tảng có hỗ trợ bàn phím phần cứng có thể sử dụng công cụ sửa đổi onKeyPress để phản ứng trực tiếp với bất kỳ đầu vào bàn phím nào.

00:32:57.000 --> 00:33:03.000
Công cụ sửa đổi lấy một bộ phím để khớp và một hành động để thực hiện cho sự kiện.

00:33:03.000 --> 00:33:10.000
Để bạn có được đầy đủ các công thức nấu ăn liên quan đến trọng tâm, hãy nhớ xem "Sách dạy nấu ăn SwiftUI để tập trung".

00:33:10.000 --> 00:33:21.000
Từ quá trình chuyển đổi và hành vi cuộn, đến kiểu nút và tương tác tập trung, các API mới này có thể giúp bạn xây dựng các ứng dụng với chức năng phong phú và phong cách nổi bật.

00:33:21.000 --> 00:33:24.000
Curt: Tôi nghĩ chúng tôi đã đạt được tiến bộ lớn trên ứng dụng của mình!

00:33:24.000 --> 00:33:26.000
Jeff: Nó chắc chắn là một cái gì đó.

00:33:26.000 --> 00:33:28.000
Curt: Thật thú vị khi sử dụng tất cả các API mới này.

00:33:28.000 --> 00:33:30.000
Jeff: Điều đó là sự thật.

00:33:30.000 --> 00:33:32.000
Curt: Đây là khoảng thời gian thú vị cho SwiftUI.

00:33:32.000 --> 00:33:34.000
Có một nền tảng hoàn toàn mới!

00:33:34.000 --> 00:33:38.000
Jeff: Và sự sang trọng của Observable và SwiftData hoạt động rất tốt với SwiftUI.

00:33:38.000 --> 00:33:41.000
Curt: Những cải tiến hoạt hình thật tuyệt vời.

00:33:41.000 --> 00:33:43.000
Jeff: Và đừng quên chế độ xem cuộn!

00:33:43.000 --> 00:33:49.000
Curt: Luôn luôn hồi hộp khi thấy cộng đồng nhà phát triển tuyệt vời của chúng tôi có thể làm gì với các API mới này.

00:33:49.000 --> 00:33:51.000
Jeff: Cảm ơn vì đã xem, mọi người.

00:33:51.000 --> 00:33:52.000
Nói xin chào với con chó của bạn cho tôi!

00:33:52.000 --> 00:33:55.000
Curt: Tiếp tục làm việc tuyệt vời!

00:33:55.000 --> 23:59:59.000
♪

