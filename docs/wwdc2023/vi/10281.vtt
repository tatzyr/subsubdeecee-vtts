WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:11.000
Spencer: Xin chào mọi người.

00:00:11.000 --> 00:00:13.000
Tên tôi là Spencer Lewson.

00:00:13.000 --> 00:00:21.000
Hôm nay tôi muốn nói với bạn về cách bàn phím đã thay đổi trong vài năm qua và cách bạn có thể thiết kế ứng dụng của mình để "tiếp tục với bàn phím".

00:00:21.000 --> 00:00:29.000
Như các bạn đã biết, bàn phím của iPhone ban đầu được giới thiệu vào năm 2007, và nó đã phát triển đáng kể kể từ đó.

00:00:29.000 --> 00:00:35.000
Bây giờ nó hỗ trợ nhiều ngôn ngữ khác nhau, mỗi ngôn ngữ có thể có kích thước khác nhau cho bố cục của chúng.

00:00:35.000 --> 00:00:39.000
Và tất nhiên, bàn phím cũng có trên nhiều thiết bị khác nhau.

00:00:39.000 --> 00:00:50.000
Nhưng cũng giống như cách bàn phím đã phát triển, hệ thống cũng vậy, đã bổ sung các tính năng thú vị như đa nhiệm và bàn phím nổi, cho phép bàn phím vượt qua giới hạn của ứng dụng.

00:00:50.000 --> 00:00:56.000
Năm ngoái, chúng tôi đã giới thiệu Trình quản lý giai đoạn, mở ra một cấp độ năng suất hoàn toàn mới trên iPad.

00:00:56.000 --> 00:01:03.000
Giờ đây với nhiều cảnh chạy trên nhiều màn hình, việc sử dụng bàn phím và chuột phần cứng giờ đây hấp dẫn hơn bao giờ hết.

00:01:03.000 --> 00:01:14.000
Vì vậy, đó là lý do tại sao hôm nay chúng tôi muốn nói với bạn về cách chúng tôi thực hiện nhiều kịch bản bàn phím khác nhau này với kiến trúc lại bàn phím và điều đó có thể ảnh hưởng đến ứng dụng của bạn như thế nào.

00:01:14.000 --> 00:01:23.000
Chúng tôi cũng muốn chia sẻ một số mẹo và thủ thuật để thiết kế ứng dụng của bạn hoạt động liền mạch nhất có thể với bàn phím, với ít nỗ lực nhất có thể.

00:01:23.000 --> 00:01:29.000
Và cuối cùng, chúng tôi muốn giới thiệu một số khả năng mới thú vị trong thế giới nhập văn bản.

00:01:29.000 --> 00:01:32.000
Vì vậy, hãy nói về bàn phím ngoài quy trình mới.

00:01:32.000 --> 00:01:39.000
Đưa bàn phím ra khỏi quy trình ứng dụng của bạn cho phép chúng tôi cải thiện bảo mật và đảm bảo quyền riêng tư của những gì người dùng nhập.

00:01:39.000 --> 00:01:48.000
Nó cũng giải phóng bộ nhớ trong các ứng dụng của bạn và trên toàn hệ thống, vì hiện chỉ có một bàn phím, thay vì nhiều phiên bản chạy trong nhiều ứng dụng.

00:01:48.000 --> 00:01:54.000
Và kiến trúc mới này cho phép chúng tôi thiết kế cho tương lai và triển khai các chức năng mới thú vị.

00:01:54.000 --> 00:01:57.000
Vì vậy, hãy nói một chút về cách nó hoạt động.

00:01:57.000 --> 00:02:03.000
Trước iOS 17, chế độ xem và logic của bàn phím đã được thực hiện trong quy trình ứng dụng của bạn.

00:02:03.000 --> 00:02:10.000
Nhưng mới trên iPhone trên iOS 17, bàn phím đã được chuyển sang quy trình riêng của nó, chạy gần như hoàn toàn bên ngoài ứng dụng của bạn.

00:02:10.000 --> 00:02:18.000
Tôi rất vui được chỉ cho bạn cách tất cả những điều này hoạt động, nhưng trước tiên hãy nói về cách nó hoạt động trong quá trình để chúng ta có thể thấy sự khác biệt.

00:02:18.000 --> 00:02:31.000
Trong quá trình, ứng dụng của bạn trước tiên sẽ yêu cầu bàn phím, chẳng hạn như bằng cách gọi becomeFirstResponder để đáp ứng với một cú chạm và điều này sẽ khởi động một loạt các phần công việc đồng bộ để khởi tạo tất cả các chế độ xem.

00:02:31.000 --> 00:02:37.000
Sau khi hoàn thành, hệ thống sẽ thực hiện các hình ảnh động để hiển thị bàn phím.

00:02:37.000 --> 00:02:48.000
Ứng dụng của bạn sau đó sẽ không hoạt động hoặc thực hiện bất kỳ công việc bên ứng dụng nào cho đến khi một sự kiện cảm ứng xuất hiện và tạo chèn văn bản.

00:02:48.000 --> 00:02:52.000
Nếu không có quy trình, điều này bây giờ hoạt động hơi khác một chút.

00:02:52.000 --> 00:03:04.000
Khi ứng dụng của bạn yêu cầu bàn phím, một lần nữa, chẳng hạn như bằng cách gọi becomeFirstResponder, ứng dụng của bạn sẽ thực hiện một số tính toán ban đầu và sau đó quá trình bàn phím sẽ khởi tạo giao diện người dùng của nó một cách không đồng bộ.

00:03:04.000 --> 00:03:08.000
Trong khi điều đó xảy ra, ứng dụng sẽ không hoạt động hoặc thực hiện công việc bên ứng dụng.

00:03:08.000 --> 00:03:14.000
Khi nó đã sẵn sàng, nó sẽ hiển thị bàn phím và phối hợp các hình ảnh động giữa hai quy trình.

00:03:14.000 --> 00:03:23.000
Bây giờ giao diện người dùng bàn phím đã hoạt động, nó sẽ chờ bất kỳ sự kiện cảm ứng nào xảy ra trong giới hạn của bàn phím và chuyển đổi chúng thành chèn văn bản cho ứng dụng của bạn.

00:03:23.000 --> 00:03:29.000
Đối với phần lớn các ứng dụng, những thay đổi này hoàn toàn minh bạch và không yêu cầu bạn chấp nhận.

00:03:29.000 --> 00:03:36.000
Mặc dù vậy, các khía cạnh của cách tiếp cận không đồng bộ mới này hiện tồn tại trong toàn bộ bàn phím và có thể tạo ra một số khác biệt nhỏ về thời gian.

00:03:36.000 --> 00:03:46.000
Vì vậy, nếu ứng dụng của bạn đặc biệt nhạy cảm với thời gian nhập văn bản, thay đổi lựa chọn hoặc bất kỳ hoạt động liên quan đến văn bản nào khác, bạn nên ghi nhớ kiến trúc mới này.

00:03:46.000 --> 00:03:56.000
Vì vậy, bây giờ chúng ta đã nói một chút về sự đa dạng của việc gõ trên iOS, hãy nói về một số kịch bản tương đối mới cần giải thích khi thiết kế ứng dụng của bạn.

00:03:56.000 --> 00:04:02.000
Tất nhiên, tất cả chúng ta đều quen thuộc với trường hợp sử dụng phổ biến nhất: một ứng dụng toàn màn hình với bàn phím.

00:04:02.000 --> 00:04:15.000
Đây là một trường hợp sử dụng tương đối đơn giản trong đó ứng dụng của bạn và bàn phím đều toàn màn hình, giúp việc điều chỉnh bàn phím đơn giản như di chuyển lên chế độ xem của bạn bằng một giá trị xảy ra là chiều cao của bàn phím.

00:04:15.000 --> 00:04:20.000
Tuy nhiên, với Trình quản lý sân khấu, hệ thống đang rời khỏi mô hình đó.

00:04:20.000 --> 00:04:24.000
Với đa nhiệm nâng cao, các ứng dụng không nhất thiết phải toàn màn hình.

00:04:24.000 --> 00:04:30.000
Điều đó có nghĩa là khi bàn phím xuất hiện, cần phải đặc biệt cẩn thận để điều chỉnh chế độ xem của ứng dụng một cách chính xác.

00:04:30.000 --> 00:04:34.000
Đó là bởi vì cảnh của bàn phím và cảnh của ứng dụng không còn xếp hàng nữa.

00:04:34.000 --> 00:04:40.000
Và một số chuyển đổi bổ sung cần phải diễn ra để điều chỉnh ứng dụng phù hợp với ngữ cảnh của nó.

00:04:40.000 --> 00:04:51.000
Ví dụ, trong trường hợp này, điều chỉnh của ứng dụng không thực sự là Y, chiều cao của bàn phím, nó cần điều chỉnh bằng giao điểm của bàn phím và ứng dụng của bạn, được hiển thị là Y'.

00:04:51.000 --> 00:05:01.000
Và bây giờ thậm chí có thể không có một điều chỉnh nào để tính toán, vì bạn có thể có nhiều cảnh trên màn hình, mỗi cảnh có các tính toán và điều chỉnh khác nhau cần thiết.

00:05:01.000 --> 00:05:05.000
Ngoài ra còn có một số kịch bản được giới thiệu gần đây với bàn phím phần cứng.

00:05:05.000 --> 00:05:10.000
Khi bàn phím phần cứng được gắn vào, hệ thống sẽ hiển thị một thanh công cụ trợ lý ở giữa màn hình.

00:05:10.000 --> 00:05:17.000
Khi thanh công cụ kích thước đầy đủ này có mặt, nó hoạt động như một phần của bàn phím, vì vậy chế độ xem của bạn nên được điều chỉnh theo cách của nó.

00:05:17.000 --> 00:05:20.000
Sử dụng cử chỉ vuốt, thanh công cụ này cũng có thể được thu nhỏ.

00:05:20.000 --> 00:05:29.000
Khi ở bên ngoài Trình quản lý sân khấu, chúng tôi đang duy trì hành vi hiện có trong đó thanh công cụ nhỏ này không hoạt động như một phần của bàn phím và sẽ chồng chéo chế độ xem của bạn.

00:05:29.000 --> 00:05:34.000
Người dùng có thể truy cập nội dung bên dưới bằng cách kéo thanh công cụ sang phía bên kia của màn hình.

00:05:34.000 --> 00:05:49.000
Tuy nhiên, khi ở trong Trình quản lý sân khấu, thanh công cụ nhỏ hoạt động như một phần của bàn phím và tùy thuộc vào trường hợp sử dụng của bạn, bạn có thể chọn cập nhật độ lệch cuộn và đẩy lên chế độ xem phụ kiện đầu vào và thực hiện bất kỳ điều chỉnh bố cục nào khác theo ý muốn.

00:05:49.000 --> 00:05:57.000
Bây giờ, chúng tôi biết rằng có rất nhiều kịch bản và sắc thái cần giải thích ở đây, nhưng tin tốt là với các API phù hợp, hệ thống thực hiện hầu hết công việc cho bạn.

00:05:57.000 --> 00:06:00.000
Vậy hãy nói về hướng dẫn bố cục bàn phím.

00:06:00.000 --> 00:06:05.000
Bạn có thể quen thuộc với hướng dẫn bố cục bàn phím đã được giới thiệu trong iOS 15.

00:06:05.000 --> 00:06:11.000
Nó cung cấp một hướng dẫn bố cục tự động dễ dàng tự động điều chỉnh cho bàn phím và chúng tôi đã thêm vào nó trong năm qua.

00:06:11.000 --> 00:06:17.000
Trên thực tế, nó hiện được sử dụng bởi một số ứng dụng phức tạp của Apple, chẳng hạn như Spotlight và Messages.

00:06:17.000 --> 00:06:25.000
Đó là cách tiếp cận được đề xuất bởi vì việc áp dụng có thể đơn giản như một dòng để thêm một ràng buộc giữa quan điểm của bạn và hướng dẫn.

00:06:25.000 --> 00:06:28.000
Bây giờ hãy nói về chính xác những gì điều này mang lại cho bạn.

00:06:28.000 --> 00:06:35.000
Hành vi mặc định hiện tại như sau: hướng dẫn bố cục bàn phím theo bàn phím khi nó ở trên màn hình và được gắn vào đế.

00:06:35.000 --> 00:06:39.000
Điều đó có nghĩa là, khi bàn phím chạm vào cuối màn hình.

00:06:39.000 --> 00:06:46.000
Nếu bàn phím không được gắn vào đế, chẳng hạn như khi nó nổi trên iPad, chiều cao của hướng dẫn sẽ khớp với khu vực an toàn dưới cùng của chế độ xem.

00:06:46.000 --> 00:06:53.000
Cuối cùng, hướng dẫn sẽ theo dõi bất kỳ cử chỉ loại bỏ bàn phím nào khi điểm tiếp xúc giao với hướng dẫn.

00:06:53.000 --> 00:07:01.000
Tôi rất vui được nói với bạn rằng chúng tôi đã mở rộng các tùy chọn tùy chỉnh trong iOS 17 để cho phép bạn thay đổi những tùy chọn này để có được hành vi chính xác mà bạn muốn.

00:07:01.000 --> 00:07:05.000
Hiện tại có ba thuộc tính trên UIKeyboardLayoutGuide.

00:07:05.000 --> 00:07:07.000
Đầu tiên, theo dõi UndockedKeyboard.

00:07:07.000 --> 00:07:13.000
Theo mặc định, hướng dẫn sẽ xử lý bàn phím nổi hoặc thanh công cụ mini giống như bàn phím ngoài màn hình.

00:07:13.000 --> 00:07:21.000
Tuy nhiên, khi được đặt thành true, hướng dẫn sẽ tiếp tục theo dõi bàn phím ngay cả khi nó đang nổi, miễn là nó ở trên cửa sổ ứng dụng của bạn.

00:07:21.000 --> 00:07:24.000
Tiếp theo là sử dụng khu vực an toàn dưới cùng.

00:07:24.000 --> 00:07:29.000
Theo mặc định, hướng dẫn bố cục bàn phím sẽ theo dõi chiều cao của khu vực an toàn khi bàn phím bị loại bỏ.

00:07:29.000 --> 00:07:37.000
Nhưng khi được đặt thành sai, usesBottomSafeArea thay vào đó sẽ theo dõi phần dưới cùng của chế độ xem, trong trường hợp này là phần dưới cùng của màn hình.

00:07:37.000 --> 00:07:39.000
Khi nào điều này có thể hữu ích?

00:07:39.000 --> 00:07:50.000
Chà, điều này sẽ cho phép bạn mở rộng nền của mình để che phần dưới cùng của màn hình khi bàn phím bị loại bỏ và cũng có thể điều chỉnh khi bàn phím được đưa lên, hoạt động tương tự như InputAccessoryView.

00:07:50.000 --> 00:07:56.000
Và thực ra, đó là một trường hợp sử dụng thực sự thú vị cho tài sản này, vì vậy hãy nói về cách nó có thể hoạt động.

00:07:56.000 --> 00:08:07.000
Đây là mã để có được chế độ xem giống như phụ kiện đầu vào đơn giản đó với trường văn bản nằm phía trên khu vực an toàn dưới cùng và phông nền chỉ kéo dài đến cuối chế độ xem khi bàn phím bị loại bỏ.

00:08:07.000 --> 00:08:13.000
Lưu ý, chúng tôi sẽ chỉ xử lý các ràng buộc theo chiều dọc ở đây, bởi vì chúng là những ràng buộc thú vị trong trường hợp này.

00:08:13.000 --> 00:08:17.000
Đầu tiên, hãy đặt usesBottomSafeArea thành false.

00:08:17.000 --> 00:08:25.000
Sau đó, hãy buộc phần trên cùng của trường văn bản lên trên cùng của phông nền, sử dụng khoảng cách hệ thống giữa hai cái, chỉ để tạo cho nó một chút đệm.

00:08:25.000 --> 00:08:33.000
Tiếp theo, đảm bảo trường văn bản luôn ở phía trên bàn phím bằng cách giới hạn phần trên cùng của hướng dẫn ở dưới cùng của trường văn bản, với ít nhất khoảng cách hệ thống.

00:08:33.000 --> 00:08:35.000
Điều quan trọng ở đây càng lớn.

00:08:35.000 --> 00:08:42.000
Khi bàn phím ở ngoài màn hình, trường văn bản sẽ cần đủ tính linh hoạt để ở trên các khu vực an toàn phía dưới.

00:08:42.000 --> 00:08:46.000
Chúng ta cũng hãy buộc mỏ neo trên cùng của hướng dẫn vào dưới cùng của phông nền.

00:08:46.000 --> 00:08:54.000
Điều này sẽ đảm bảo phông nền đi đến tận cùng khi hướng dẫn ở ngoài màn hình, nhưng chỉ vì chúng tôi đã đặt usesBottomSafeArea thành false.

00:08:54.000 --> 00:08:59.000
Cuối cùng, hạn chế vùng an toàn dưới cùng ở dưới cùng của trường văn bản, cộng với khoảng cách hệ thống.

00:08:59.000 --> 00:09:05.000
Và một lần nữa, chúng tôi đang sử dụng các ràng buộc lớn hơn ở đây để đảm bảo rằng nó đủ linh hoạt để theo dõi bàn phím khi nó xuất hiện.

00:09:05.000 --> 00:09:20.000
Và với điều đó, bạn có một chế độ xem thích ứng có phông nền kéo dài đến cuối chế độ xem, nhưng điều chỉnh để giữ khoảng cách hệ thống trường văn bản phía trên bàn phím và phông nền ở đầu bàn phím, giống như chế độ xem phụ kiện đầu vào có thể.

00:09:20.000 --> 00:09:23.000
Thứ ba, chúng tôi có bàn phím DismissPadding.

00:09:23.000 --> 00:09:27.000
Điều này điều chỉnh các thông số của cuộn để loại bỏ cử chỉ.

00:09:27.000 --> 00:09:37.000
Nếu bạn đã cố gắng tạo chế độ xem giống như InputAccessory trong quá khứ bằng cách sử dụng Hướng dẫn Bố cục Bàn phím, bạn có thể nhận thấy rằng cử chỉ loại bỏ bàn phím không bắt đầu cho đến khi chạm giao với bàn phím.

00:09:37.000 --> 00:09:40.000
Hãy sử dụng thuộc tính mới này để sửa nó.

00:09:40.000 --> 00:09:47.000
Thuộc tính keyboardDismissPadding cho phép bạn chỉ định phần đệm phía trên bàn phím sẽ phản hồi với cử chỉ loại bỏ bàn phím.

00:09:47.000 --> 00:09:49.000
Điều này tương đối đơn giản.

00:09:49.000 --> 00:09:53.000
Chỉ cần lấy chiều cao tầm nhìn của bạn theo cách bạn muốn và đặt tài sản.

00:09:53.000 --> 00:09:55.000
Xong rồi.

00:09:55.000 --> 00:10:00.000
Bây giờ cử chỉ loại bỏ bàn phím bắt đầu khi cảm ứng giao với chế độ xem của bạn.

00:10:00.000 --> 00:10:03.000
Tất nhiên, UIKit không phải là khuôn khổ duy nhất mà các ứng dụng được xây dựng.

00:10:03.000 --> 00:10:05.000
Ngoài ra còn có SwiftUI.

00:10:05.000 --> 00:10:09.000
Và may mắn thay, SwiftUI tự động xử lý các trường hợp phổ biến cho bạn.

00:10:09.000 --> 00:10:18.000
Với SwiftUI, bàn phím được bao gồm như một phần của khu vực an toàn, khi bàn phím bị loại bỏ, sẽ theo dõi khả năng chi trả nhà nhỏ ở cuối màn hình.

00:10:18.000 --> 00:10:27.000
Khi bàn phím được đưa lên, hệ thống sẽ tạo hiệu ứng động và điều chỉnh vùng an toàn cho bạn, tự động thay đổi kích thước chế độ xem của bạn, vì vậy thực sự không có bất kỳ mã bàn phím nào để viết.

00:10:27.000 --> 00:10:33.000
Mặc dù vậy, bạn có thể cần thực hiện một số công việc trên bố cục của mình để đảm bảo rằng chế độ xem của bạn đang thay đổi kích thước hoặc định vị lại theo cách bạn muốn.

00:10:33.000 --> 00:10:41.000
Có rất nhiều tài nguyên tuyệt vời về SwiftUI, nhiều hơn những gì tôi có thể liệt kê - vì vậy để tìm hiểu thêm về điều này, hãy xem tài liệu được liên kết bên dưới.

00:10:41.000 --> 00:10:46.000
Bây giờ, hãy nói về một cách thủ công hơn để tích hợp bàn phím, thông báo bàn phím.

00:10:46.000 --> 00:11:02.000
Trước SwiftUI và hướng dẫn bố cục bàn phím, cách duy nhất để tích hợp bàn phím của bạn vào ứng dụng của bạn là nghe một bộ thông báo bàn phím - willShow, didShow, willHide, didHide - và sau đó điều chỉnh bố cục của bạn theo cách thủ công dựa trên khung và thông tin hoạt ảnh trong thông báo.

00:11:02.000 --> 00:11:08.000
Những thứ này vẫn còn xung quanh, nhưng chúng yêu cầu xử lý cẩn thận hơn, vì hệ thống không thực hiện công việc cho bạn.

00:11:08.000 --> 00:11:16.000
Và với sự ra đời của Trình quản lý sân khấu, chúng tôi đã nhận thấy sự gia tăng của một mẫu thường được sử dụng cho việc xử lý đó không còn hoạt động 100% thời gian.

00:11:16.000 --> 00:11:25.000
Mẫu này thường tập trung vào việc nhận thông báo bàn phím và sử dụng trực tiếp giá trị thô từ chiều cao của bàn phím.

00:11:25.000 --> 00:11:31.000
Bây giờ hãy nhớ trước đó khi chúng ta thảo luận về sắc thái chiều cao của bàn phím và vị trí ứng dụng của bạn trên màn hình tương tác như thế nào?

00:11:31.000 --> 00:11:34.000
Hãy thảo luận về cách thức hoạt động của nó với các thông báo.

00:11:34.000 --> 00:11:40.000
Mỗi thông báo chỉ định khung dự kiến của bàn phím so với tọa độ màn hình.

00:11:40.000 --> 00:11:51.000
Nếu không gian tọa độ của màn hình và không gian tọa độ của ứng dụng của bạn khớp, chẳng hạn như khi ứng dụng ở chế độ toàn màn hình, giá trị chiều cao thô có trong thông báo sẽ tình cờ dẫn đến việc chế độ xem của bạn điều chỉnh như mong đợi.

00:11:51.000 --> 00:11:59.000
Tuy nhiên, khi không gian tọa độ của màn hình và không gian tọa độ của ứng dụng của bạn khác nhau, giá trị chiều cao thô này sẽ không còn là giá trị chính xác để điều chỉnh chế độ xem của bạn nữa.

00:11:59.000 --> 00:12:04.000
Điều này có thể dẫn đến việc quan điểm của bạn bị đẩy quá cao và xuất hiện không đúng chỗ.

00:12:04.000 --> 00:12:11.000
May mắn thay, có một vài thay đổi có thể được thực hiện đối với việc xử lý thông báo của bạn để mọi thứ hoạt động trơn tru trở lại.

00:12:11.000 --> 00:12:18.000
Trong iOS 16.1, các thông báo trên bàn phím bắt đầu bao gồm UIScreen tương ứng làm đối tượng của thông báo.

00:12:18.000 --> 00:12:26.000
Đầu tiên, hãy sử dụng nó để kiểm tra xem bàn phím có xuất hiện trên cùng một màn hình với ứng dụng của chúng tôi hay không, nếu không sẽ không cần điều chỉnh.

00:12:26.000 --> 00:12:31.000
Tiếp theo, hãy tính toán một rect để thể hiện vị trí của bàn phím so với chế độ xem của bạn.

00:12:31.000 --> 00:12:43.000
Chúng tôi có thể làm điều này bằng cách truy xuất khung cuối dự kiến của bàn phím, không gian tọa độ được cung cấp bởi thông báo và chế độ xem của bạn, sau đó sử dụng chúng để chuyển đổi keyboardFrameEnd thành không gian tọa độ của bạn.

00:12:43.000 --> 00:12:53.000
Với rect mới này, chúng tôi có thể xác định độ lệch cần thiết cho chế độ xem của bạn bằng cách tính toán giao điểm của chế độ xem của bạn và KeyboardFrameEnd được chuyển đổi.

00:12:53.000 --> 00:13:02.000
Nếu chế độ xem của bạn và bàn phím chồng chéo lên nhau, độ lệch cần thiết bây giờ sẽ là chiều cao của giao điểm giữa chế độ xem của bạn và bàn phím.

00:13:02.000 --> 00:13:06.000
Và với điều đó, bạn có thể điều chỉnh các ràng buộc hoặc bố cục của mình theo cách bạn muốn.

00:13:06.000 --> 00:13:13.000
Bây giờ, với kiến trúc ngoài quy trình mới, có thể có một số thay đổi nhỏ trong hành vi với các thông báo mà bạn nên biết.

00:13:13.000 --> 00:13:15.000
Vì vậy, hãy dành một chút thời gian để nói về điều đó.

00:13:15.000 --> 00:13:19.000
Bạn có nhớ sơ đồ này phác thảo vòng đời của quy trình bàn phím không?

00:13:19.000 --> 00:13:24.000
Hãy phóng to giai đoạn hoạt hình ở đây được gọi là "mang lại hoạt hình".

00:13:24.000 --> 00:13:34.000
Trong kiến trúc Đang xử lý khi ứng dụng của bạn yêu cầu bàn phím, hệ thống sẽ khởi tạo đồng bộ giao diện người dùng bàn phím và sau đó đăng thông báo và thực hiện hoạt ảnh.

00:13:34.000 --> 00:13:46.000
Tuy nhiên, trong kiến trúc ngoài quy trình mới, khi ứng dụng của bạn yêu cầu bàn phím, hệ thống sẽ khởi tạo không đồng bộ giao diện người dùng bàn phím và sau đó đăng thông báo không đồng bộ và thực hiện hoạt ảnh.

00:13:46.000 --> 00:14:06.000
Điều này giới thiệu một số khác biệt nhỏ về thời gian, vì vậy nếu ứng dụng của bạn dựa vào thời gian của các thông báo như một số loại "gọi lại" từ việc gọi trở thành FirstResponder hoặc có thể thực hiện công việc quan trọng trên luồng chính có thể khiến việc xử lý thông báo bị trì hoãn, bạn nên ghi nhớ mô hình mới này, vì nó

00:14:06.000 --> 00:14:17.000
Bây giờ chúng tôi đã xem xét tất cả các mẹo và thủ thuật này để cho phép người dùng nhập vào ứng dụng của bạn dễ dàng nhất có thể, chúng tôi rất vui mừng được giới thiệu một tính năng và API mới giúp việc nhập văn bản nhanh hơn.

00:14:17.000 --> 00:14:21.000
Và đó là những dự đoán nội tuyến.

00:14:21.000 --> 00:14:28.000
Trong iOS 17, bàn phím tiếng Anh giờ đây sẽ cung cấp dự đoán cho vài từ tiếp theo của bạn ngay trong trường văn bản.

00:14:28.000 --> 00:14:35.000
Những dự đoán này được tạo an toàn trên thiết bị và chỉ sử dụng thông tin theo ngữ cảnh được cung cấp trong trường văn bản tập trung.

00:14:35.000 --> 00:14:38.000
Áp dụng những dự đoán này cũng thực sự dễ dàng.

00:14:38.000 --> 00:14:48.000
Ở đây chúng tôi có giao thức UITextInputTraits và như bạn có thể thấy, một thuộc tính inlinePredictionType mới đã được thêm vào và nó đi kèm với một vài tùy chọn.

00:14:48.000 --> 00:14:58.000
Theo mặc định, dự đoán nội tuyến sẽ hoạt động trong hầu hết các trường nhập văn bản, nhưng sẽ tự động bị vô hiệu hóa trong các trường mà dự đoán không phù hợp, chẳng hạn như trường tìm kiếm hoặc trường mật khẩu.

00:14:58.000 --> 00:15:05.000
Và tất nhiên, bạn cũng có thể tùy chỉnh hành vi trong ứng dụng của mình bằng cách đặt rõ ràng thuộc tính thành có hoặc không.

00:15:05.000 --> 00:15:09.000
Và với điều đó, hãy tóm tắt lại một số điều quan trọng.

00:15:09.000 --> 00:15:16.000
Hãy nhớ: Thiết kế ứng dụng của bạn để hoạt động liền mạch với bàn phím, bất kể nó xuất hiện như thế nào.

00:15:16.000 --> 00:15:21.000
Hãy ghi nhớ mô hình bàn phím ngoài quy trình mới khi viết mã nhạy cảm với thời gian.

00:15:21.000 --> 00:15:26.000
Và cải thiện trải nghiệm ứng dụng của bạn bằng cách áp dụng các API giúp tăng tốc độ nhập văn bản.

00:15:26.000 --> 00:15:29.000
Cảm ơn vì đã theo kịp bàn phím.

00:15:29.000 --> 23:59:59.000
♪ ♪

