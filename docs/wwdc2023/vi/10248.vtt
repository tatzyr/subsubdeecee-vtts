WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:13.000
Joachim Kurz: Chào mừng đến với "Phân tích treo bằng nhạc cụ."

00:00:13.000 --> 00:00:17.000
Tên tôi là Joachim, và tôi là một kỹ sư làm việc trong nhóm Nhạc cụ.

00:00:17.000 --> 00:00:20.000
Hôm nay, chúng tôi muốn xem xét kỹ hơn về Hangs.

00:00:20.000 --> 00:00:26.000
Đầu tiên, tôi sẽ cung cấp cho bạn một cái nhìn tổng quan về hang là gì, và để làm như vậy, chúng ta sẽ cần nói về nhận thức của con người.

00:00:26.000 --> 00:00:34.000
Sau đó, tôi sẽ nói ngắn gọn về vòng lặp xử lý sự kiện và kết xuất, vì nó tạo thành cơ sở để hiểu cách treo được gây ra.

00:00:34.000 --> 00:00:46.000
Được trang bị kiến thức lý thuyết này, chúng ta sẽ nhảy vào Dụng cụ và xem xét ba ví dụ treo khác nhau: treo chủ đề chính bận rộn, treo không đồng bộ và treo chủ đề chính bị chặn.

00:00:46.000 --> 00:00:55.000
Đối với mỗi thứ này, tôi sẽ chỉ cho bạn cách nhận ra chúng, những gì cần tìm khi phân tích chúng và cách biết khi nào nên thêm các công cụ khác vào tài liệu của bạn để tìm hiểu thêm.

00:00:55.000 --> 00:01:01.000
Trước khi chúng ta bắt đầu: đối với một phần của phiên này, thật hữu ích khi làm quen với Dụng cụ.

00:01:01.000 --> 00:01:05.000
Nếu bạn đã từng lập hồ sơ ứng dụng với Instruments, bạn nên sử dụng.

00:01:05.000 --> 00:01:14.000
Nếu không, hãy xem phiên 2019 của chúng tôi, "Bắt đầu với các công cụ." Khi xử lý treo: thường có ba bước.

00:01:14.000 --> 00:01:24.000
Bạn tìm thấy một cái treo, sau đó bạn phân tích một cái treo để hiểu nó xảy ra như thế nào, và sau đó bạn sửa nó, (và xác minh nó thực sự đã được sửa).

00:01:24.000 --> 00:01:32.000
Hôm nay chúng tôi sẽ cho rằng bạn đã tìm thấy một hang và tập trung vào phần phân tích, cũng như thảo luận về một số bản sửa lỗi.

00:01:32.000 --> 00:01:40.000
Nếu bạn muốn biết thêm về việc tìm kiếm hangs, hãy xem phiên của chúng tôi, "Theo dõi hangs với Xcode và phát hiện trên thiết bị" từ WWDC22.

00:01:40.000 --> 00:01:52.000
Nó bao gồm tất cả các công cụ của chúng tôi để tìm treo, bao gồm: Dụng cụ, Phát hiện treo trên thiết bị, mà bạn có thể bật trong cài đặt Nhà phát triển iOS và Trình tổ chức Xcode.

00:01:52.000 --> 00:01:56.000
Hôm nay, chúng tôi sẽ sử dụng Dụng cụ để phân tích một hang mà chúng tôi đã tìm thấy.

00:01:56.000 --> 00:02:03.000
Để hiểu rõ hơn về treo, hãy nói về nhận thức của con người và bật đèn lên.

00:02:03.000 --> 00:02:06.000
Chúng ta cần một bóng đèn và một dây cáp.

00:02:06.000 --> 00:02:08.000
À, tốt hơn nhiều.

00:02:08.000 --> 00:02:12.000
Giống như một chiếc đèn, nó bật lên khi tôi cắm cáp.

00:02:12.000 --> 00:02:17.000
Và khi tôi kéo nó ra một lần nữa, nó tắt. Ngay lập tức.

00:02:17.000 --> 00:02:19.000
Nhưng nếu có sự chậm trễ thì sao?

00:02:19.000 --> 00:02:22.000
Tôi cắm nó vào.

00:02:22.000 --> 00:02:24.000
Và ở đây phải mất một chút thời gian để bật lên.

00:02:24.000 --> 00:02:29.000
Thậm chí còn kỳ lạ hơn, điều tương tự cũng xảy ra khi tôi rút cáp ra một lần nữa.

00:02:29.000 --> 00:02:35.000
Độ trễ giữa cáp được cắm vào và đèn bật chỉ là 500 mili giây.

00:02:35.000 --> 00:02:39.000
Nhưng nó đã khiến bạn tự hỏi chuyện gì đang xảy ra bên trong chiếc hộp này.

00:02:39.000 --> 00:02:43.000
Cảm giác không ổn khi đèn không bật và tắt trực tiếp.

00:02:43.000 --> 00:02:48.000
Tuy nhiên, trong một số trường hợp khác, độ trễ 500 mili giây có thể ổn.

00:02:48.000 --> 00:02:52.000
Loại chậm trễ nào có thể chấp nhận được tùy thuộc vào hoàn cảnh.

00:02:52.000 --> 00:02:58.000
Giả sử bạn tình cờ nghe được một cuộc trò chuyện như thế này: "Rùa giao tiếp như thế nào?"

00:02:58.000 --> 00:03:00.000
"Điện thoại vỏ.

00:03:00.000 --> 00:03:06.000
Ở đây, chúng tôi đã có độ trễ một giây giữa câu hỏi và câu trả lời.

00:03:06.000 --> 00:03:08.000
Và điều đó cảm thấy hoàn toàn tự nhiên.

00:03:08.000 --> 00:03:15.000
Nhưng điều này không xảy ra: Tại sao vậy?

00:03:15.000 --> 00:03:24.000
Cuộc trò chuyện giữa con rùa và con kỳ lân là một sự tương tác theo phong cách yêu cầu-phản hồi, nhưng cắm đèn trực tiếp thao tác với một vật thể thực.

00:03:24.000 --> 00:03:26.000
Các đối tượng thực phản ứng ngay lập tức.

00:03:26.000 --> 00:03:30.000
Nếu chúng ta mô phỏng một thứ có thật, nó cũng cần phản ứng ngay lập tức.

00:03:30.000 --> 00:03:34.000
Nếu không, nó sẽ phá vỡ ảo ảnh.

00:03:34.000 --> 00:03:42.000
Bạn không có vấn đề gì với việc tôi tuyên bố rằng tôi có một chiếc đèn thực sự ở đây khi không có độ trễ giữa cáp được cắm và đèn bật.

00:03:42.000 --> 00:03:51.000
Nhưng khi có một sự chậm trễ đáng kể, bộ não của bạn đột nhiên nói, "Chờ một chút, đó không phải là cách thức hoạt động của thứ này."

00:03:51.000 --> 00:03:54.000
Nhưng tức thì nhanh như thế nào?

00:03:54.000 --> 00:03:58.000
Sự chậm trễ nào đủ nhỏ để chúng ta không nhận ra?

00:03:58.000 --> 00:04:03.000
Đây là đường cơ sở của chúng tôi mà không có sự chậm trễ.

00:04:03.000 --> 00:04:08.000
100 ms thì sao?

00:04:08.000 --> 00:04:15.000
Đối với tôi, có cảm giác như tôi nhận thấy một sự chậm trễ nhỏ trong việc bật nó lên, nhưng không phải khi tắt nó đi, và chỉ khi tôi nhìn kỹ.

00:04:15.000 --> 00:04:18.000
Trải nghiệm của bạn có thể khác.

00:04:18.000 --> 00:04:21.000
100 ms phần nào là ngưỡng.

00:04:21.000 --> 00:04:25.000
Sự chậm trễ nhỏ hơn đáng kể không thực sự có thể cảm nhận được nữa.

00:04:25.000 --> 00:04:31.000
Hãy thử 250 ms.

00:04:31.000 --> 00:04:34.000
250 ms không còn cảm thấy tức thì nữa.

00:04:34.000 --> 00:04:40.000
Nó không chậm, nhưng sự chậm trễ chắc chắn là đáng chú ý.

00:04:40.000 --> 00:04:44.000
Những loại ngưỡng nhận thức này cũng thông báo cho báo cáo treo của chúng tôi.

00:04:44.000 --> 00:04:51.000
Độ trễ dưới khoảng 100 ms cho một tương tác rời rạc, như nhấn vào một nút, thường sẽ cảm thấy tức thì.

00:04:51.000 --> 00:04:57.000
Có một số trường hợp đặc biệt mà bạn có thể muốn đi ngay cả dưới mức đó, nhưng đó là một mục tiêu tốt để nhắm đến.

00:04:57.000 --> 00:05:01.000
Trên hết, nó phụ thuộc vào hoàn cảnh.

00:05:01.000 --> 00:05:05.000
Cho đến 250 ms, bạn có thể thoát khỏi nó.

00:05:05.000 --> 00:05:09.000
Lâu hơn thế và nó trở nên đáng chú ý, ít nhất là trong tiềm thức.

00:05:09.000 --> 00:05:15.000
Đó là một thang đo liên tục, nhưng trên 250 ms, nó chắc chắn không còn cảm thấy tức thì nữa.

00:05:15.000 --> 00:05:25.000
Vì vậy, hầu hết các công cụ của chúng tôi bắt đầu báo cáo treo theo mặc định bắt đầu từ 250 ms, nhưng chúng tôi gọi những "hang vi mô" này vì chúng rất dễ bỏ qua.

00:05:25.000 --> 00:05:30.000
Tùy thuộc vào ngữ cảnh, những thứ đó có thể ổn, nhưng thường thì không.

00:05:30.000 --> 00:05:34.000
Mọi thứ trên 500 ms chúng tôi coi là một hang thích hợp.

00:05:34.000 --> 00:05:43.000
Dựa trên điều này, chúng ta có thể sử dụng đại khái các ngưỡng này: Nếu bạn muốn thứ gì đó cảm thấy tức thì, hãy nhắm đến độ trễ 100 ms hoặc ít hơn.

00:05:43.000 --> 00:05:50.000
Nếu bạn có tương tác kiểu yêu cầu-phản hồi, 500 ms mà không có bất kỳ phản hồi bổ sung nào có thể ổn.

00:05:50.000 --> 00:05:53.000
Nhưng thực ra, chúng ta thường có cả hai trong một tương tác.

00:05:53.000 --> 00:05:56.000
Hãy xem xét một ví dụ.

00:05:56.000 --> 00:06:02.000
Tôi vừa viết xong email này cho tất cả các đồng nghiệp đã giúp chuẩn bị phiên này và tôi đã sẵn sàng gửi nó.

00:06:02.000 --> 00:06:11.000
Tôi di chuyển chuột qua nút Gửi và nhấp vào nút đó và một lát sau, cửa sổ email hoạt hình để cho biết nó đang được gửi.

00:06:11.000 --> 00:06:15.000
Điều đã xảy ra ở đây là bạn thực sự đã thấy hai điều xảy ra.

00:06:15.000 --> 00:06:24.000
Đầu tiên, nút được tô sáng, sau đó có độ trễ nhỏ 500 ms, sau đó là cửa sổ email hoạt hình.

00:06:24.000 --> 00:06:29.000
Nhưng sự chậm trễ này cảm thấy ổn vì chúng tôi đã biết yêu cầu của mình đã được nhận do nút tô sáng.

00:06:29.000 --> 00:06:37.000
Chúng tôi coi nút này là một thứ "thực" và chúng tôi hy vọng nó sẽ cập nhật trong thời gian "thực", ngay lập tức.

00:06:37.000 --> 00:06:44.000
Vì vậy, đối với các yếu tố giao diện người dùng thực tế trong giao diện của chúng tôi, chúng tôi thường muốn nhắm đến bản cập nhật "tức thì" này.

00:06:44.000 --> 00:06:50.000
Để cho phép các yếu tố giao diện người dùng của chúng tôi phản ứng "ngay lập tức", điều quan trọng là phải giữ cho luồng chính không hoạt động không phải giao diện người dùng.

00:06:50.000 --> 00:07:02.000
Để xem tại sao lại như vậy, chúng ta hãy xem xét kỹ hơn vòng lặp xử lý và kết xuất sự kiện để xem các sự kiện được xử lý như thế nào trên nền tảng Apple và cách đầu vào của người dùng dẫn đến cập nhật màn hình.

00:07:02.000 --> 00:07:05.000
Tại một thời điểm nào đó, ai đó sẽ tương tác với thiết bị.

00:07:05.000 --> 00:07:08.000
Chúng tôi không kiểm soát được khi điều đó xảy ra.

00:07:08.000 --> 00:07:14.000
Đầu tiên, thường có một số phần cứng liên quan, như chuột hoặc màn hình cảm ứng.

00:07:14.000 --> 00:07:18.000
Nó phát hiện sự tương tác, tạo ra một sự kiện và gửi nó đến hệ điều hành.

00:07:18.000 --> 00:07:26.000
Hệ điều hành tìm ra quy trình nào cần xử lý sự kiện và chuyển tiếp nó đến quy trình đó, ví dụ, ứng dụng của bạn.

00:07:26.000 --> 00:07:31.000
Trong ứng dụng, trách nhiệm của chuỗi chính của ứng dụng là xử lý các sự kiện.

00:07:31.000 --> 00:07:34.000
Đây là nơi hầu hết mã giao diện người dùng của bạn chạy.

00:07:34.000 --> 00:07:36.000
Nó đưa ra quyết định cách cập nhật giao diện người dùng.

00:07:36.000 --> 00:07:45.000
Sau đó, bản cập nhật giao diện người dùng này được gửi đến máy chủ kết xuất, đây là một quy trình riêng biệt chịu trách nhiệm tổng hợp các lớp giao diện người dùng riêng lẻ và kết xuất khung tiếp theo.

00:07:45.000 --> 00:07:53.000
Cuối cùng, trình điều khiển hiển thị chọn bitmap được chuẩn bị bởi máy chủ kết xuất và cập nhật các pixel trên màn hình cho phù hợp.

00:07:53.000 --> 00:08:03.000
Nếu bạn muốn biết thêm về cách thức hoạt động của nó, chúng tôi sẽ đề cập đến điều này trong tài liệu trong phần "Cải thiện khả năng phản hồi của ứng dụng". Đối với chúng tôi, cái nhìn tổng quan sơ bộ này đủ để hiểu chuyện gì đang xảy ra.

00:08:03.000 --> 00:08:10.000
Bây giờ, khi một sự kiện khác xảy ra trong thời gian này, nó thường có thể được xử lý song song.

00:08:10.000 --> 00:08:17.000
Nhưng, nếu chúng ta nhìn vào cách một sự kiện duy nhất đi qua đường ống, chúng ta vẫn cần xem xét tất cả các bước theo trình tự.

00:08:17.000 --> 00:08:26.000
Các bước xử lý sự kiện trước khi chúng tôi đến chuỗi chính và các bước hiển thị kết xuất và cập nhật SAU thường khá dễ đoán trong thời lượng của chúng.

00:08:26.000 --> 00:08:40.000
Khi chúng ta gặp phải sự chậm trễ đáng kể trong tương tác, hầu như luôn luôn là do phần trên luồng chính mất quá nhiều thời gian hoặc vì một cái gì đó khác vẫn đang thực hiện trên luồng chính khi sự kiện đến nên chúng ta cần đợi nó kết thúc trước khi sự kiện có thể được xử lý.

00:08:40.000 --> 00:08:53.000
Cho rằng mọi bản cập nhật cho phần tử giao diện người dùng cần một chút thời gian trên luồng chính và chúng tôi muốn các bản cập nhật này diễn ra trong vòng 100 ms để cảm thấy thực tế, lý tưởng nhất là không có công việc nào trên luồng chính sẽ mất nhiều thời gian hơn 100 ms.

00:08:53.000 --> 00:08:56.000
Nếu bạn có thể nhanh hơn, thậm chí còn tốt hơn.

00:08:56.000 --> 00:09:04.000
Lưu ý rằng công việc kéo dài trên luồng chính cũng có thể gây ra trở ngại và các ngưỡng thấp hơn được áp dụng để tránh trở ngại.

00:09:04.000 --> 00:09:12.000
Bạn có thể tìm thêm thông tin chi tiết về các trở ngại trong Tech Talk của chúng tôi "Khám phá các trở ngại hoạt hình giao diện người dùng và vòng lặp kết xuất" và tài liệu của chúng tôi về "Cải thiện khả năng phản hồi của ứng dụng".

00:09:12.000 --> 00:09:15.000
Hôm nay, chúng tôi tập trung vào hangs.

00:09:15.000 --> 00:09:21.000
Một trong những đồng nghiệp của tôi vừa tìm thấy một trong những ứng dụng của chúng tôi, Backyard Birds, trong khi làm việc trên một tính năng mới.

00:09:21.000 --> 00:09:31.000
Hãy lập hồ sơ ứng dụng với Instruments.

00:09:31.000 --> 00:09:34.000
Tôi có dự án Xcode với ứng dụng ở đây.

00:09:34.000 --> 00:09:47.000
Tất cả những gì tôi cần làm để lập hồ sơ ứng dụng trong Công cụ là nhấp vào menu Sản phẩm và sau đó Hồ sơ và sau đó Xcode sẽ xây dựng ứng dụng và cài đặt nó trên thiết bị, nhưng không khởi chạy nó.

00:09:47.000 --> 00:09:55.000
Xcode cũng sẽ mở Công cụ và định cấu hình để nhắm mục tiêu cùng một ứng dụng và thiết bị đã được định cấu hình trong Xcode.

00:09:55.000 --> 00:10:07.000
Trong trình chọn mẫu của Instruments, tôi sẽ chọn mẫu Time Profiler, đây thường là điểm khởi đầu tốt nếu bạn chưa biết mình đang tìm kiếm gì và muốn hiểu rõ hơn về những gì ứng dụng của mình đang làm.

00:10:07.000 --> 00:10:11.000
Điều này tạo ra một tài liệu Công cụ mới từ mẫu Time Profiler.

00:10:11.000 --> 00:10:20.000
Trong số những tài liệu khác, tài liệu mới này chứa công cụ Time Profiler và công cụ Hangs, cả hai đều sẽ hữu ích cho phân tích của chúng tôi.

00:10:20.000 --> 00:10:24.000
Tôi nhấp vào nút Ghi âm ở trên cùng bên trái của thanh công cụ để bắt đầu ghi âm.

00:10:24.000 --> 00:10:30.000
Các công cụ khởi chạy ứng dụng được cấu hình và bắt đầu thu thập dữ liệu.

00:10:30.000 --> 00:10:32.000
Vì vậy, ở đây tôi có ứng dụng Backyard Birds.

00:10:32.000 --> 00:10:36.000
Tôi nhấn vào khu vườn đầu tiên để đi đến chế độ xem chi tiết.

00:10:36.000 --> 00:10:44.000
Khi tôi nhấn vào nút "Chọn nền" trong giây lát, một tờ dưới cùng sẽ xuất hiện, hiển thị cho tôi một lựa chọn các hình nền để lựa chọn.

00:10:44.000 --> 00:10:48.000
Hãy để tôi làm điều đó ngay bây giờ.

00:10:48.000 --> 00:10:50.000
Nút được nhấn nhưng có vẻ bị kẹt.

00:10:50.000 --> 00:10:53.000
Phải mất khá nhiều thời gian để tờ giấy xuất hiện.

00:10:53.000 --> 00:10:57.000
Một sự treo cổ nghiêm trọng.

00:10:57.000 --> 00:10:59.000
Các nhạc cụ đã ghi lại tất cả những điều này.

00:10:59.000 --> 00:11:04.000
Tôi sẽ dừng ghi âm bằng cách nhấp vào nút Dừng trên thanh công cụ.

00:11:04.000 --> 00:11:06.000
Các dụng cụ cũng đã phát hiện ra sự treo cổ.

00:11:06.000 --> 00:11:11.000
Nó đo thời gian treo và gắn nhãn các khoảng tương ứng theo mức độ nghiêm trọng.

00:11:11.000 --> 00:11:15.000
Trong trường hợp này, Instruments cho chúng ta thấy một "Severe Hang" đã xảy ra.

00:11:15.000 --> 00:11:20.000
Điều này cũng phù hợp với những gì chúng tôi đang trải qua khi sử dụng ứng dụng.

00:11:20.000 --> 00:11:26.000
Các thiết bị đã phát hiện ra một sợi chính không phản hồi và đánh dấu khoảng tương ứng là một lỗ treo tiềm năng.

00:11:26.000 --> 00:11:29.000
Trong trường hợp của chúng tôi, một vụ treo cổ đã thực sự xảy ra.

00:11:29.000 --> 00:11:32.000
Có hai trường hợp chính cho một luồng chính không phản hồi.

00:11:32.000 --> 00:11:37.000
Trường hợp đơn giản nhất là chủ đề chính đơn giản là vẫn đang bận làm công việc khác.

00:11:37.000 --> 00:11:41.000
Trong trường hợp này, luồng chính sẽ hiển thị một loạt các hoạt động của CPU.

00:11:41.000 --> 00:11:44.000
Trường hợp khác là chủ đề chính bị chặn.

00:11:44.000 --> 00:11:49.000
Điều này thường là do chủ đề chính đang chờ đợi một số công việc khác được thực hiện ở nơi khác.

00:11:49.000 --> 00:11:54.000
Khi luồng bị chặn, sẽ có rất ít hoặc không có hoạt động CPU trên luồng chính.

00:11:54.000 --> 00:11:59.000
Trường hợp nào bạn đã xác định bước nào bạn nên thực hiện tiếp theo để xác định điều gì đang xảy ra.

00:11:59.000 --> 00:12:02.000
Quay lại Instruments, chúng ta sẽ cần tìm Chủ đề chính.

00:12:02.000 --> 00:12:07.000
Bản nhạc cuối cùng trong tài liệu hiển thị bản nhạc cho quy trình mục tiêu của chúng tôi.

00:12:07.000 --> 00:12:12.000
Nó có một chỉ báo tiết lộ nhỏ ở bên trái để chỉ ra rằng có các dấu vết phụ.

00:12:12.000 --> 00:12:17.000
Tôi nhấp vào nó để hiển thị một bản nhạc riêng biệt cho từng chủ đề trong quy trình.

00:12:17.000 --> 00:12:20.000
Sau đó, tôi sẽ chọn bản nhạc Chủ đề Chính ở đây.

00:12:20.000 --> 00:12:31.000
Điều này cũng cập nhật khu vực chi tiết để hiển thị chế độ xem Hồ sơ, hiển thị cho chúng ta cây cuộc gọi của tất cả các chức năng được thực hiện trên luồng chính trong toàn bộ thời gian ghi.

00:12:31.000 --> 00:12:40.000
Nhưng chúng tôi chỉ quan tâm đến những gì đã xảy ra trong quá trình treo, vì vậy tôi nhấp vào thứ cấp vào khoảng thời gian treo trong dòng thời gian để hiển thị menu ngữ cảnh.

00:12:40.000 --> 00:12:51.000
Tôi có thể chọn Đặt Phạm vi Kiểm tra ở đây, nhưng thay vào đó tôi cũng sẽ giữ phím tùy chọn để lấy Đặt Phạm vi Kiểm tra và Thu phóng.

00:12:51.000 --> 00:12:57.000
Điều này phóng to phạm vi của khoảng thời gian và lọc dữ liệu được hiển thị trong chế độ xem chi tiết đến phạm vi thời gian đã chọn.

00:12:57.000 --> 00:13:08.000
Mặc dù mức sử dụng CPU không phải là 100% trong toàn bộ khoảng thời gian treo, nhưng nó vẫn khá cao, với mức sử dụng CPU từ 60% đến 90% hầu hết thời gian.

00:13:08.000 --> 00:13:11.000
Đây rõ ràng là trường hợp của một chủ đề chính bận rộn.

00:13:11.000 --> 00:13:15.000
Hãy cùng tìm hiểu xem tất cả CPU này hoạt động là gì.

00:13:15.000 --> 00:13:18.000
Chúng ta có thể xem xét kỹ hơn tất cả các nút khác nhau trong cây cuộc gọi ngay bây giờ.

00:13:18.000 --> 00:13:24.000
Nhưng có một bản tóm tắt tuyệt vời ở phía bên phải: chế độ xem dấu vết ngăn xếp nặng nhất.

00:13:24.000 --> 00:13:31.000
Khi tôi nhấp vào một khung trong chế độ xem theo dõi ngăn xếp nặng nhất, chế độ xem cây cuộc gọi sẽ cập nhật để hiển thị nút này.

00:13:31.000 --> 00:13:38.000
Điều này cũng cho chúng ta thấy rằng cuộc gọi phương thức này đã khá sâu trong cây cuộc gọi.

00:13:38.000 --> 00:13:48.000
Dấu vết ngăn xếp nặng nhất theo mặc định ẩn các lệnh gọi hàm tiếp theo không bắt nguồn từ mã nguồn của bạn để dễ dàng xem mã nguồn của bạn có liên quan đến đâu.

00:13:48.000 --> 00:13:58.000
Chúng ta có thể áp dụng một bộ lọc tương tự cho chế độ xem cây cuộc gọi bằng cách nhấp vào nút Cây cuộc gọi ở thanh dưới cùng và bật hộp kiểm Ẩn Thư viện Hệ thống.

00:13:58.000 --> 00:14:04.000
Điều này sẽ lọc ra tất cả các chức năng từ các thư viện hệ thống và giúp việc tập trung vào mã của chúng tôi dễ dàng hơn.

00:14:04.000 --> 00:14:12.000
Chế độ xem cây cuộc gọi cho chúng ta thấy rằng hầu như tất cả các dấu vết ngược của chúng ta đều chứa cuộc gọi "BackgroundThumbnailView.body.getter".

00:14:12.000 --> 00:14:16.000
Có vẻ như chúng ta nên làm cho cơ thể mình nhanh hơn, phải không?

00:14:16.000 --> 00:14:18.000
Không hoàn toàn!

00:14:18.000 --> 00:14:22.000
Vì vậy, chúng tôi biết rằng chúng tôi có một trường hợp luồng chính bận rộn, có nghĩa là CPU đang làm rất nhiều việc.

00:14:22.000 --> 00:14:26.000
Chúng tôi cũng đã tìm ra một phương pháp sử dụng rất nhiều thời gian CPU.

00:14:26.000 --> 00:14:28.000
Nhưng bây giờ có hai trường hợp khác nhau.

00:14:28.000 --> 00:14:34.000
Chúng ta có thể dành rất nhiều thời gian CPU cho phương pháp này vì bản thân phương thức này chạy trong một thời gian dài.

00:14:34.000 --> 00:14:40.000
Nhưng nó cũng có thể là nó chỉ được gọi rất nhiều lần, đó là lý do tại sao nó xuất hiện ở đây.

00:14:40.000 --> 00:14:46.000
Cách chúng ta nên giảm công việc trên chủ đề chính phụ thuộc vào trường hợp chúng ta có.

00:14:46.000 --> 00:14:49.000
Một ngăn xếp cuộc gọi điển hình được cấu trúc như thế này.

00:14:49.000 --> 00:14:58.000
Có một cuộc gọi từ hàm chính, gọi ra một số khung giao diện người dùng và một loạt các thứ khác, và sau đó, tại một số điểm, mã của bạn được gọi.

00:14:58.000 --> 00:15:08.000
Nếu hàm này chỉ được gọi một lần và một lần gọi mất nhiều thời gian, như hàm Rùa của chúng ta ở đây, thì chúng ta muốn xem nó gọi gì.

00:15:08.000 --> 00:15:14.000
Có lẽ nó làm rất nhiều việc. Sau đó chúng ta có thể làm ít hơn.

00:15:14.000 --> 00:15:21.000
Nhưng cũng có thể là phương pháp mà chúng tôi đang điều tra được gọi rất nhiều lần, như Unicorn ở đây.

00:15:21.000 --> 00:15:26.000
Và sau đó, tất nhiên, công việc nó làm cũng được thực hiện lặp đi lặp lại.

00:15:26.000 --> 00:15:36.000
Điều này thường là do có một số người gọi gọi hàm, Unicorn, rất nhiều lần - ví dụ, từ một vòng lặp.

00:15:36.000 --> 00:15:47.000
Thay vì tối ưu hóa những gì chức năng tập trung, Unicorn ở đây, làm, có thể có lợi hơn khi điều tra cách chúng ta có thể gọi nó ít thường xuyên hơn.

00:15:47.000 --> 00:15:51.000
Điều đó có nghĩa là hướng chúng ta cần xem xét tiếp theo phụ thuộc vào trường hợp chúng ta có.

00:15:51.000 --> 00:15:57.000
Đối với một chức năng tồn tại lâu dài, như trường hợp Rùa của chúng tôi, chúng tôi muốn xem xét việc triển khai và các cuộc gọi của nó.

00:15:57.000 --> 00:15:59.000
Chúng ta cần nhìn xa hơn.

00:15:59.000 --> 00:16:10.000
Tuy nhiên, nếu một hàm được gọi nhiều lần, như Unicorn, sẽ có lợi hơn khi nhìn vào những gì đang gọi nó và xác định xem liệu chúng ta có thể làm như vậy ít thường xuyên hơn hay không.

00:16:10.000 --> 00:16:12.000
Chúng ta cần nhìn xa hơn.

00:16:12.000 --> 00:16:16.000
Nhưng Time Profiler không thể cho chúng tôi biết chúng tôi có trường hợp nào.

00:16:16.000 --> 00:16:20.000
Giả sử các cuộc gọi đến Unicorn and Turtle xảy ra ngay sau đó.

00:16:20.000 --> 00:16:26.000
Time Profiler thu thập dữ liệu bằng cách kiểm tra những gì đang chạy trên CPU đều đặn.

00:16:26.000 --> 00:16:31.000
Và đối với mỗi mẫu, nó kiểm tra chức năng nào hiện đang chạy trên CPU.

00:16:31.000 --> 00:16:37.000
Đối với ví dụ này, chúng tôi sẽ nhận được cả Rùa và Kỳ lân bốn lần.

00:16:37.000 --> 00:16:45.000
Nhưng cũng có thể đây là một con Rùa rất nhanh, và Kỳ lân mất nhiều thời gian hơn, hoặc các kết hợp khác.

00:16:45.000 --> 00:16:50.000
Tất cả các tình huống này sẽ tạo ra cùng một dữ liệu trong Time Profiler.

00:16:50.000 --> 00:16:55.000
Để đo thời gian thực thi của một hàm cụ thể, hãy sử dụng os_signposts.

00:16:55.000 --> 00:17:01.000
Chúng tôi đã nói về cách làm như vậy trong phiên năm 2019 của chúng tôi, "Bắt đầu với các công cụ".

00:17:01.000 --> 00:17:06.000
Ngoài ra còn có các công cụ chuyên dụng cho các công nghệ khác nhau có thể cho bạn biết chính xác những gì đang xảy ra.

00:17:06.000 --> 00:17:10.000
Một trong số đó là nhạc cụ cơ thể SwiftUI View.

00:17:10.000 --> 00:17:15.000
Để thêm nhạc cụ cơ thể SwiftUI, tôi nhấp vào nút dấu cộng ở trên cùng bên phải của thanh công cụ.

00:17:15.000 --> 00:17:17.000
Điều này cho thấy thư viện Nhạc cụ.

00:17:17.000 --> 00:17:21.000
Đây là danh sách tất cả các nhạc cụ mà ứng dụng Dụng cụ phải cung cấp.

00:17:21.000 --> 00:17:22.000
Có rất nhiều.

00:17:22.000 --> 00:17:25.000
Bạn thậm chí có thể viết các nhạc cụ tùy chỉnh của riêng mình.

00:17:25.000 --> 00:17:30.000
Tôi sẽ nhập "SwiftUI" vào trường lọc và hai nhạc cụ sẽ hiển thị.

00:17:30.000 --> 00:17:36.000
Tôi sẽ chọn nhạc cụ "Xem nội dung" và kéo nó vào cửa sổ tài liệu để thêm nó.

00:17:36.000 --> 00:17:43.000
Bây giờ, vì công cụ này không có trong tài liệu khi chúng tôi ghi lại lần cuối, nó không có dữ liệu để hiển thị.

00:17:43.000 --> 00:17:47.000
Nhưng không vấn đề gì. Chúng tôi sẽ ghi lại lần nữa.

00:17:47.000 --> 00:17:50.000
Để tiết kiệm thời gian, tôi đã làm điều đó rồi.

00:17:50.000 --> 00:17:58.000
Sau khi tôi ghi lại bằng nhạc cụ SwiftUI View Body trong tài liệu, bản nhạc View Body cũng hiển thị một số dữ liệu ngay bây giờ.

00:17:58.000 --> 00:18:01.000
Có rất nhiều khoảng thời gian trong bản nhạc cơ thể chế độ xem SwiftUI.

00:18:01.000 --> 00:18:06.000
Nó hơi chật chội, vì vậy tôi nhấn Ctrl+Plus để tăng chiều cao của nó.

00:18:06.000 --> 00:18:11.000
SwiftUI View Body theo dõi nhóm các khoảng thời gian theo thư viện mà chúng được triển khai.

00:18:11.000 --> 00:18:14.000
Mỗi khoảng thời gian là một lần thực hiện nội dung chế độ xem.

00:18:14.000 --> 00:18:20.000
Hãy phóng to hang của chúng ta một lần nữa.

00:18:20.000 --> 00:18:27.000
Trong làn đường thứ hai, có rất nhiều khoảng màu cam được gắn nhãn "BackgroundThumbnailView".

00:18:27.000 --> 00:18:32.000
Điều này cho chúng ta biết chính xác có bao nhiêu vụ hành quyết cơ thể và mỗi lần mất bao lâu.

00:18:32.000 --> 00:18:39.000
Màu cam chỉ ra rằng thời gian chạy của việc thực hiện cơ thể cụ thể đó mất nhiều thời gian hơn một chút so với những gì chúng tôi đang hướng tới với SwiftUI.

00:18:39.000 --> 00:18:42.000
Nhưng vấn đề lớn hơn dường như là có bao nhiêu khoảng thời gian.

00:18:42.000 --> 00:18:47.000
Trong chế độ xem chi tiết, có một bản tóm tắt về tất cả các khoảng thời gian cơ thể.

00:18:47.000 --> 00:18:54.000
Bằng cách nhấp vào chỉ báo tiết lộ bên cạnh Backyard Birds, tôi có thể tiết lộ các loại chế độ xem riêng lẻ trong Backyard Birds.

00:18:54.000 --> 00:19:07.000
Điều này cho tôi thấy rằng phần thân của BackgroundThumbnailView đã được thực hiện 70 lần với thời lượng trung bình khoảng 50 mili giây, dẫn đến tổng thời lượng hơn ba giây.

00:19:07.000 --> 00:19:10.000
Điều này giải thích gần như tất cả thời gian treo của chúng tôi.

00:19:10.000 --> 00:19:16.000
Nhưng 70 lần có vẻ quá đáng khi chúng ta chỉ cần hiển thị sáu hình ảnh ở phía trước.

00:19:16.000 --> 00:19:26.000
Đây là trường hợp cơ thể nên được gọi ít thường xuyên hơn, vì vậy chúng ta cần xem xét những người gọi cơ thể của chúng ta để tìm hiểu lý do tại sao nó được gọi như vậy thường xuyên và xem cách giảm bớt nó.

00:19:26.000 --> 00:19:40.000
Để dễ dàng điều hướng đến mã có liên quan, tôi chọn lại theo dõi luồng chính, nhấp chuột thứ cấp vào nút BackgroundThumbnailView.body.getter trong cây cuộc gọi để hiển thị menu ngữ cảnh và chọn "Tham khảo trong Xcode".

00:19:40.000 --> 00:19:44.000
Điều này mở ra việc triển khai cơ thể của chúng tôi ngay trong Xcode.

00:19:44.000 --> 00:19:55.000
Hãy cùng tìm hiểu xem chế độ xem này được sử dụng như thế nào bằng cách nhấp vào loại thứ cấp và chọn "Tìm", "Tìm biểu tượng đã chọn trong không gian làm việc".

00:19:55.000 --> 00:20:04.000
Kết quả đầu tiên trong Find navigator đã là những gì chúng tôi đang tìm kiếm.

00:20:04.000 --> 00:20:14.000
Ở đây, "BackgroundThumbnailView" của chúng tôi được sử dụng bên trong ForEach bên trong GridRow bên trong một ForEach khác bên trong Grid.

00:20:14.000 --> 00:20:23.000
Grid háo hức tính toán toàn bộ nội dung của nó khi nó được tạo, vì vậy nó sẽ tính toán tất cả các hình thu nhỏ nền mặc dù chúng ta chỉ cần một số ít đầu tiên.

00:20:23.000 --> 00:20:27.000
Nhưng có một giải pháp thay thế: LazyVGrid.

00:20:27.000 --> 00:20:32.000
Nó chỉ tính toán nhiều chế độ xem khi cần thiết để lấp đầy một màn hình.

00:20:32.000 --> 00:20:42.000
Rất nhiều lượt xem trong SwiftUI có các biến thể lười biếng, chỉ tính toán nhiều chế độ xem khi cần thiết và đây thường có thể là một cách dễ dàng để thực hiện ít công việc hơn.

00:20:42.000 --> 00:20:47.000
Tuy nhiên, các biến thể háo hức sử dụng ít bộ nhớ hơn nhiều khi chúng cần hiển thị cùng một nội dung.

00:20:47.000 --> 00:20:56.000
Sử dụng các biến thể háo hức thông thường theo mặc định và chuyển sang các biến thể lười biếng khi bạn thấy vấn đề về hiệu suất liên quan đến việc trả trước quá nhiều công việc.

00:20:56.000 --> 00:21:07.000
Phiên WWDC của chúng tôi từ WWDC 2020 về "Các phụ đề, lưới và phác thảo trong SwiftUI" giới thiệu các biến thể lười biếng này và mô tả chúng chi tiết hơn.

00:21:07.000 --> 00:21:10.000
Hãy lập hồ sơ mã cập nhật này.

00:21:10.000 --> 00:21:18.000
Tôi bắt đầu ghi âm và tái tạo hang của chúng tôi bằng cách nhấn lại vào nút Chọn Nền.

00:21:18.000 --> 00:21:20.000
Bây giờ, điều này tốt hơn nhiều.

00:21:20.000 --> 00:21:23.000
Vẫn còn một chút chậm trễ, nhưng gần như không tệ như trước.

00:21:23.000 --> 00:21:25.000
Các công cụ xác nhận điều này.

00:21:25.000 --> 00:21:29.000
Việc treo mà chúng tôi ghi lại bây giờ mất ít hơn 400 mili giây.

00:21:29.000 --> 00:21:33.000
Đó là một sự treo vi mô.

00:21:33.000 --> 00:21:42.000
Bản nhạc "View Body" cũng cho chúng ta thấy rằng bây giờ chúng ta chỉ có tám lần thực hiện nội dung BackgroundThumbnail, phù hợp với mong đợi của chúng ta.

00:21:42.000 --> 00:21:44.000
Có lẽ điều này là đủ tốt.

00:21:44.000 --> 00:21:46.000
Microhang không đáng chú ý lắm.

00:21:46.000 --> 00:21:57.000
Hãy đảm bảo rằng nó cũng hoạt động tốt trên các loại thiết bị khác bằng cách lập hồ sơ Backyard Birds trên iPad.

00:21:57.000 --> 00:22:00.000
Ở đây, tôi đang chạy Backyard Birds trên iPad.

00:22:00.000 --> 00:22:03.000
Tôi đã ở trong chế độ xem chi tiết.

00:22:03.000 --> 00:22:09.000
Tôi nhấn vào nút "Chọn nền" và phải mất nhiều thời gian để trang tính xuất hiện.

00:22:09.000 --> 00:22:12.000
Một khi nó xuất hiện, chúng ta có thể hiểu tại sao.

00:22:12.000 --> 00:22:17.000
Hiện tại có nhiều hình thu nhỏ hơn vì màn hình của chúng tôi lớn hơn và có nhiều không gian hơn.

00:22:17.000 --> 00:22:22.000
Các nhạc cụ cũng đã ghi lại sự treo cổ này.

00:22:22.000 --> 00:22:30.000
Tập trung phạm vi kiểm tra vào khoảng thời gian treo của chúng tôi, chúng tôi sẽ thấy nhiều nội dung BackgroundThumbnailView hơn.

00:22:30.000 --> 00:22:31.000
Nó có ý nghĩa.

00:22:31.000 --> 00:22:37.000
Bây giờ chúng ta cần hiển thị khoảng 40 trong số chúng cho toàn màn hình khi nhiều cái phù hợp hơn trên màn hình.

00:22:37.000 --> 00:22:45.000
Vì vậy, cùng một mã hoạt động hầu như OK trên iPhone nhưng chậm trên iPad, đơn giản vì màn hình lớn hơn.

00:22:45.000 --> 00:22:48.000
Đây là một trong những lý do tại sao bạn cũng nên sửa micro hangs.

00:22:48.000 --> 00:22:55.000
Những gì bạn có thể thấy là treo vi mô trong quá trình thử nghiệm tại bàn làm việc của mình có thể là một sự treo lớn đối với một số người dùng của bạn trong các điều kiện khác nhau.

00:22:55.000 --> 00:23:03.000
Bây giờ chúng tôi chỉ hiển thị nhiều chế độ xem như chúng tôi cần để lấp đầy màn hình, vì vậy chúng tôi đã cạn kiệt tiềm năng tối ưu hóa của mình về mặt gọi điều này ít thường xuyên hơn.

00:23:03.000 --> 00:23:08.000
Hãy cùng tìm hiểu xem chúng ta có thể làm gì để giúp mỗi cá nhân thực hiện nhanh hơn.

00:23:08.000 --> 00:23:16.000
Tôi sẽ đặt phạm vi kiểm tra thành một khoảng thời gian BackgroundThumbnailView duy nhất và chuyển trở lại theo dõi "Chủ đề chính".

00:23:16.000 --> 00:23:26.000
Các công cụ hiển thị getter cơ thể chế độ xem của chúng tôi trong chế độ xem backtrace nặng nhất và cho thấy rằng nó gọi getter thuộc tính "BackyardBackground.thumbnail".

00:23:26.000 --> 00:23:31.000
Đây là đối tượng mô hình cung cấp hình ảnh thu nhỏ để hiển thị trong chế độ xem của chúng tôi.

00:23:31.000 --> 00:23:38.000
Trình nhận hình thu nhỏ này gọi là "UIImage imageByPreparingThumbnailOfSize:".

00:23:38.000 --> 00:23:41.000
Vì vậy, chúng tôi dường như đang tính toán một hình thu nhỏ một cách nhanh chóng ở đây.

00:23:41.000 --> 00:23:46.000
Điều đó có thể mất một chút thời gian. Trong trường hợp này, khoảng 150 mili giây.

00:23:46.000 --> 00:23:51.000
Đây là công việc chúng ta nên làm trong nền và không làm cho chủ đề chính bận rộn.

00:23:51.000 --> 00:23:58.000
Để hiểu rõ hơn về những thay đổi mà chúng ta có thể thực hiện, tôi muốn xem xét bối cảnh cách gọi của getter hình thu nhỏ.

00:23:58.000 --> 00:24:07.000
Tôi nhấp thứ hai vào khung "BackgroundThumbnailView.body.getter" trong chế độ xem theo dõi ngăn xếp nặng nhất và chọn "Mở trong Trình xem Nguồn".

00:24:07.000 --> 00:24:21.000
Điều này thay thế chế độ xem cây cuộc gọi bằng trình xem nguồn hiển thị việc triển khai trình lấy cơ thể của chúng tôi và chú thích các dòng triển khai bằng các mẫu Time Profiler để hiển thị nơi mã của chúng tôi đã dành bao nhiêu thời gian.

00:24:21.000 --> 00:24:28.000
Việc triển khai cơ thể của chúng tôi thực sự đơn giản ở đây; nó chỉ tạo ra một chế độ xem Hình ảnh mới với hình thu nhỏ được trả về bởi nền.

00:24:28.000 --> 00:24:32.000
Nhưng cuộc gọi thu nhỏ này mất nhiều thời gian.

00:24:32.000 --> 00:24:34.000
Tôi có một ý tưởng làm thế nào để viết nó khác đi.

00:24:34.000 --> 00:24:42.000
Để chuyển đến Xcode, tôi nhấp vào nút menu ở trên cùng bên phải và chọn "Mở tệp trong Xcode".

00:24:42.000 --> 00:24:46.000
Như trước đây, điều này hiển thị mã nguồn của chúng tôi trong Xcode, sẵn sàng thực hiện các thay đổi.

00:24:46.000 --> 00:24:53.000
Những gì tôi muốn làm bây giờ là tải hình thu nhỏ trong nền và trong khi tải đang diễn ra, hãy hiển thị chỉ báo tiến độ.

00:24:53.000 --> 00:25:00.000
Đầu tiên, chúng ta cần một biến trạng thái để giữ hình thu nhỏ đã tải.

00:25:00.000 --> 00:25:09.000
Sau đó, trong phần thân, nếu chúng ta đã tải hình ảnh, chúng ta sẽ sử dụng nó trong chế độ xem Hình ảnh.

00:25:09.000 --> 00:25:14.000
Nếu không, chúng tôi sẽ hiển thị chế độ xem tiến độ.

00:25:14.000 --> 00:25:18.000
Bây giờ tất cả những gì còn lại là tải hình thu nhỏ thực tế.

00:25:18.000 --> 00:25:21.000
Chúng tôi muốn bắt đầu tải nó khi chế độ xem của chúng tôi xuất hiện.

00:25:21.000 --> 00:25:27.000
Đó là mục đích của công cụ sửa đổi ".task".

00:25:27.000 --> 00:25:36.000
Khi xuất hiện, SwiftUI sẽ bắt đầu một nhiệm vụ cho chúng tôi sẽ gọi trình nhận "hình thu nhỏ" và gán kết quả cho "hình ảnh" của chúng tôi, điều này sẽ cập nhật chế độ xem của chúng tôi.

00:25:36.000 --> 00:25:38.000
Hãy thử nó đi!

00:25:38.000 --> 00:25:44.000
Vì vậy, ở đây, với tính năng ghi nhạc cụ, tôi nhấn vào nút "Chọn nền" và trang tính xuất hiện ngay!

00:25:44.000 --> 00:25:45.000
Tuyệt vời!

00:25:45.000 --> 00:25:49.000
Chúng tôi đã thấy các chỉ số tiến độ của mình và vài giây sau, hình thu nhỏ của chúng tôi đã được hiển thị.

00:25:49.000 --> 00:25:53.000
Điều này đã hiệu quả. Tuyệt vời!

00:25:53.000 --> 00:25:58.000
Nhưng khoan đã, Instruments vẫn đang hiển thị một khoảng thời gian dài gần hai giây.

00:25:58.000 --> 00:26:01.000
Điều đã xảy ra ở đây là việc treo cổ xảy ra muộn hơn một chút bây giờ.

00:26:01.000 --> 00:26:05.000
Hãy để tôi chỉ cho bạn nơi nó xảy ra trong ứng dụng Backyard Birds.

00:26:05.000 --> 00:26:06.000
Tôi đã xem chi tiết rồi.

00:26:06.000 --> 00:26:14.000
Trong giây lát, tôi sẽ nhấn vào nút "Chọn nền" một lần nữa và sau đó tôi sẽ cố gắng loại bỏ trang tính ngay sau đó bằng cách nhấn vào nút Xong.

00:26:14.000 --> 00:26:19.000
Được rồi, "Chọn nền" và "Xong".

00:26:19.000 --> 00:26:24.000
Tôi đã nhấn nhiều lần, nhưng trong khi quá trình tải đang diễn ra, các thao tác của tôi đã bị bỏ qua.

00:26:24.000 --> 00:26:27.000
Đây là hang mà Instruments đã nói với chúng tôi.

00:26:27.000 --> 00:26:30.000
Nó xảy ra sau khi trang tính được hiển thị.

00:26:30.000 --> 00:26:33.000
Đây là một kiểu treo hơi khác một chút.

00:26:33.000 --> 00:26:38.000
Chúng tôi đã nói về sự khác biệt giữa chủ đề chính đang bận hoặc bị chặn.

00:26:38.000 --> 00:26:44.000
Có một cách khác để xem xét các vụ treo cổ; chúng gây ra bởi cái gì và khi nào chúng xảy ra.

00:26:44.000 --> 00:26:50.000
Chúng tôi gọi những cái treo đồng bộ và không đồng bộ này.

00:26:50.000 --> 00:26:52.000
Ở đây, chúng tôi có chủ đề chính đang làm một số công việc.

00:26:52.000 --> 00:26:59.000
Nếu, khi một sự kiện xuất hiện, phải mất nhiều thời gian để xử lý sự kiện đó, thì đó là một sự cố.

00:26:59.000 --> 00:27:06.000
Giả sử chúng tôi kiểm soát được điều đó và đảm bảo các sự kiện của chúng tôi được xử lý nhanh chóng.

00:27:06.000 --> 00:27:14.000
Nhưng có lẽ chúng tôi chỉ trì hoãn một số công việc cần hoàn thành sau này trên chủ đề chính, hoặc một số công việc chủ đề chính khác xảy ra, và sau đó một sự kiện xảy ra.

00:27:14.000 --> 00:27:19.000
Sau đó, sự kiện đó phải đợi công việc trước đó được hoàn thành trước khi nó có thể được xử lý.

00:27:19.000 --> 00:27:26.000
Sau đó, điều này vẫn gây ra sự cố treo, mặc dù mã cho từng sự kiện riêng lẻ xử lý kết thúc nhanh chóng.

00:27:26.000 --> 00:27:34.000
Cách phát hiện treo hoạt động trên nền tảng của chúng tôi là nó xem xét tất cả các mục công việc trên luồng chính và kiểm tra xem chúng có quá dài hay không.

00:27:34.000 --> 00:27:38.000
Nếu vậy, nó đánh dấu họ là một sự treo cổ tiềm năng.

00:27:38.000 --> 00:27:49.000
Và nó làm điều đó bất kể có đầu vào của người dùng hay không vì đầu vào của người dùng có thể đến bất cứ lúc nào và sau đó chúng tôi sẽ có một sự cố thực sự.

00:27:49.000 --> 00:28:00.000
Điều này có nghĩa là phát hiện treo cũng phát hiện các trường hợp không đồng bộ hoặc bị trì hoãn này, nhưng nó chỉ đo lường độ trễ tiềm ẩn, không phải độ trễ thực sự đã trải qua.

00:28:00.000 --> 00:28:12.000
Chúng tôi gọi treo không đồng bộ là không đồng bộ vì chúng thường được gây ra bởi công việc "dispatch_async" trên hàng đợi chính hoặc bởi tác vụ Swift Concurrency chạy không đồng bộ trên diễn viên chính.

00:28:12.000 --> 00:28:16.000
Nhưng chúng có thể được gây ra bởi bất cứ điều gì gây ra công việc trên chủ đề chính.

00:28:16.000 --> 00:28:18.000
Lần treo đầu tiên chúng tôi thấy là treo đồng bộ.

00:28:18.000 --> 00:28:26.000
Chúng tôi đã nhấn vào một nút, lần nhấn nút đó gây ra công việc kéo dài, vì vậy kết quả được hiển thị muộn.

00:28:26.000 --> 00:28:30.000
Lần treo gần đây nhất này là một lần treo không đồng bộ hoặc bị trì hoãn.

00:28:30.000 --> 00:28:35.000
Nhấn vào nút Xong không thực sự gây ra bất kỳ công việc tốn kém nào.

00:28:35.000 --> 00:28:40.000
Nhưng vẫn có công việc trên luồng chính ngăn không cho vòi được xử lý.

00:28:40.000 --> 00:28:49.000
Vì vậy, trong khi ai đó sử dụng ứng dụng thậm chí có thể không nhận thấy nếu họ không tương tác với ứng dụng trong thời gian này, chúng ta vẫn nên khắc phục những trường hợp này, trong trường hợp họ làm vậy.

00:28:49.000 --> 00:28:50.000
Hãy làm điều đó ngay bây giờ.

00:28:50.000 --> 00:28:56.000
Vì vậy, ở đây tôi đã trở lại Công cụ và tôi đã đặt phạm vi lựa chọn thành treo và phóng to không đồng bộ của chúng tôi.

00:28:56.000 --> 00:29:04.000
Trong chế độ xem tóm tắt của bản nhạc cơ thể chế độ xem, Instruments cho chúng ta thấy rằng hiện đã có 75 cuộc gọi đến trình lấy cơ thể của BackgroundThumbnailView của chúng tôi.

00:29:04.000 --> 00:29:09.000
Điều này là do hầu hết các getter cơ thể hình thu nhỏ được thực hiện hai lần.

00:29:09.000 --> 00:29:14.000
SwiftUI tạo ra 40 chế độ xem với các chỉ báo tiến độ để lấp đầy lưới.

00:29:14.000 --> 00:29:28.000
Nhưng sau đó chỉ có 35 thực sự được hiển thị và đối với 35 người đó, chúng tôi bắt đầu tải hình ảnh và một khi hình ảnh được tải, chế độ xem sẽ cập nhật và nội dung được gọi lại, cho chúng tôi tổng cộng 75 lần thực hiện nhận cơ thể.

00:29:28.000 --> 00:29:34.000
Ngay cả tất cả tổng cộng 75 người lấy cơ thể cũng mất ít hơn một phần nghìn giây.

00:29:34.000 --> 00:29:37.000
Vì vậy, những người nhận được cơ thể của chúng ta bây giờ đang nhanh chóng. Phần đó đã hoạt động.

00:29:37.000 --> 00:29:39.000
Nhưng chúng tôi vẫn còn hàng.

00:29:39.000 --> 00:29:49.000
Tôi sẽ chọn lại bản nhạc "Chủ đề chính" và trong chế độ xem stacktrace nặng nhất, Instruments cho chúng ta thấy rằng đó vẫn là trình lấy hình thu nhỏ mất nhiều thời gian trên chủ đề chính.

00:29:49.000 --> 00:29:57.000
Lần này, nó được gọi bằng cách đóng cửa bên trong "BackgroundThumbnailView.body.getter" của chúng tôi, không phải là người nhận cơ thể trực tiếp.

00:29:57.000 --> 00:30:02.000
Tôi nhấp đúp vào nó, đây là một phím tắt để mở trình xem nguồn.

00:30:02.000 --> 00:30:08.000
Bây giờ đây chính xác là mã mà chúng tôi dự kiến sẽ thực thi trong nền do đang đóng công cụ sửa đổi nhiệm vụ.

00:30:08.000 --> 00:30:14.000
Mã này nên chạy vào lúc này, nhưng nó không nên chạy trên luồng chính.

00:30:14.000 --> 00:30:23.000
Đối với các vấn đề như thế này, trong đó các tác vụ Swift Concurrency không thực hiện theo cách bạn mong đợi, chúng tôi có một công cụ hữu ích khác: công cụ Swift Concurrency Tasks.

00:30:23.000 --> 00:30:28.000
Tôi đã ghi lại hành vi tương tự với công cụ tác vụ Swift Concurrency được thêm vào.

00:30:28.000 --> 00:30:38.000
Công cụ Swift Tasks thêm một bản nhạc tóm tắt vào tài liệu nhưng điều thú vị hơn đối với trường hợp của chúng tôi là dữ liệu mà nó đóng góp cho mỗi bản nhạc luồng.

00:30:38.000 --> 00:30:44.000
Ở đây, trong bản nhạc chủ đề chính, có một biểu đồ mới từ công cụ Swift Tasks.

00:30:44.000 --> 00:30:47.000
Một bản nhạc duy nhất có thể hiển thị nhiều biểu đồ.

00:30:47.000 --> 00:30:53.000
Bằng cách nhấp vào mũi tên nhỏ hướng xuống trong tiêu đề theo dõi luồng, tôi có thể định cấu hình biểu đồ nào sẽ hiển thị.

00:30:53.000 --> 00:31:03.000
Tôi có thể chọn một biểu đồ khác, như biểu đồ Sử dụng CPU của Time Profiler hoặc giữ phím Command trong khi nhấp để chọn nhiều.

00:31:03.000 --> 00:31:10.000
Vì vậy, bây giờ các Công cụ đang hiển thị cả Biểu đồ Sử dụng CPU và Nhiệm vụ Nhanh cho luồng này cùng nhau.

00:31:10.000 --> 00:31:14.000
Tôi sẽ phóng to khoảng thời gian treo của chúng ta một lần nữa.

00:31:14.000 --> 00:31:22.000
Làn đường "Nhiệm vụ nhanh" hiện hiển thị rõ ràng rằng có một loạt các thực thi nhiệm vụ trên luồng chính.

00:31:22.000 --> 00:31:34.000
Đặt phạm vi kiểm tra thành một trong số chúng và kiểm tra dấu vết ngăn xếp nặng nhất trong chế độ xem Hồ sơ xác nhận rằng nhiệm vụ này đang kết thúc công việc tính toán hình thu nhỏ của chúng tôi.

00:31:34.000 --> 00:31:37.000
Vì vậy, công việc này được gói gọn trong một nhiệm vụ như chúng tôi muốn.

00:31:37.000 --> 00:31:42.000
Nhưng nhiệm vụ đang được thực hiện trên chủ đề chính, điều này thật bất ngờ.

00:31:42.000 --> 00:31:44.000
Hãy để tôi giải thích chuyện gì đang xảy ra ở đây.

00:31:44.000 --> 00:31:50.000
Đầu tiên, getter nội dung kế thừa chú thích @MainActor từ giao thức View của SwiftUI.

00:31:50.000 --> 00:32:00.000
Bởi vì "body" được chú thích là "@MainActor" trong giao thức "View", khi chúng tôi triển khai nó, body getter cũng được chú thích ngầm là @MainActor.

00:32:00.000 --> 00:32:08.000
Thứ hai, việc đóng cửa của công cụ sửa đổi ".task" được chú thích để kế thừa sự cô lập của diễn viên trong bối cảnh xung quanh.

00:32:08.000 --> 00:32:14.000
Vì vậy, bởi vì người nhận cơ thể bị cô lập với MainActor, việc đóng nhiệm vụ cũng sẽ như vậy.

00:32:14.000 --> 00:32:28.000
Vì vậy, tất cả mã chạy trong lần đóng này sẽ chạy trên diễn viên chính theo mặc định và vì getter "hình thu nhỏ" là đồng bộ, giờ đây nó chạy đồng bộ trên luồng chính.

00:32:28.000 --> 00:32:34.000
Nhiệm vụ đồng thời Swift, theo mặc định, kế thừa sự cô lập của diễn viên trong bối cảnh xung quanh.

00:32:34.000 --> 00:32:38.000
Hành vi tương tự cũng đúng với công cụ sửa đổi .task của SwiftUI.

00:32:38.000 --> 00:32:41.000
Có hai cách để thoát khỏi diễn viên chính.

00:32:41.000 --> 00:32:49.000
Gọi không đồng bộ một hàm không bị ràng buộc với diễn viên chính cho phép tác vụ tắt tác nhân chính.

00:32:49.000 --> 00:32:52.000
Có thể có những trường hợp điều này không khả thi.

00:32:52.000 --> 00:33:07.000
Sau đó, bạn có thể tách nhiệm vụ khỏi bối cảnh diễn viên xung quanh một cách rõ ràng bằng cách sử dụng "Task.detached", nhưng đó là một cách tiếp cận nặng tay và việc tạo một nhiệm vụ riêng biệt tốn kém hơn là chỉ đơn giản là đình chỉ một nhiệm vụ hiện có.

00:33:07.000 --> 00:33:20.000
SwiftUI cũng sẽ tự động hủy nhiệm vụ được tạo thông qua công cụ sửa đổi tác vụ khi chế độ xem tương ứng biến mất, nhưng việc hủy bỏ này sẽ không lan truyền sang một tác vụ phi cấu trúc mới, như Task.detached.

00:33:20.000 --> 00:33:30.000
Để tìm hiểu thêm, hãy xem "Trực quan hóa và tối ưu hóa đồng thời Swift" từ WWDC22 và tài liệu của chúng tôi về cải thiện khả năng phản hồi của ứng dụng.

00:33:30.000 --> 00:33:40.000
Bởi vì trong trường hợp của chúng tôi, chúng tôi đã ở trong một ngữ cảnh không đồng bộ và thật dễ dàng để làm cho hàm hình thu nhỏ không bị cô lập và không đồng bộ, chúng tôi sẽ chọn tùy chọn một.

00:33:40.000 --> 00:33:43.000
Ở đây, chúng tôi có mã tải hình thu nhỏ của mình.

00:33:43.000 --> 00:33:56.000
Vấn đề là nhiệm vụ này sẽ thực hiện trên diễn viên chính do kế thừa sự cô lập diễn viên chính của getter cơ thể và vì getter hình thu nhỏ là đồng bộ, nó cũng sẽ ở trên diễn viên chính.

00:33:56.000 --> 00:33:57.000
Việc sửa chữa rất đơn giản.

00:33:57.000 --> 00:34:10.000
Chúng tôi chuyển đến định nghĩa của getter hình thu nhỏ, chúng tôi làm cho getter không đồng bộ, sau đó chúng tôi quay lại cấu trúc chế độ xem của mình...

00:34:10.000 --> 00:34:16.000
Và bởi vì getter của chúng tôi hiện không đồng bộ, chúng tôi cần thêm await ở phía trước nó.

00:34:16.000 --> 00:34:22.000
Điều này sẽ cho phép getter "hình thu nhỏ" thực thi trên nhóm luồng đồng thời của Swift Concurrency thay vì luồng chính.

00:34:22.000 --> 00:34:24.000
Hãy thử nó.

00:34:24.000 --> 00:34:28.000
Tôi đang ở chế độ xem chi tiết một lần nữa và nhấn vào "Chọn nền".

00:34:28.000 --> 00:34:30.000
Ồ. Điều đó thật nhanh!

00:34:30.000 --> 00:34:34.000
Không chỉ không có treo, mà còn có vẻ như tải tổng thể nhanh hơn.

00:34:34.000 --> 00:34:37.000
Tôi hầu như không thấy quan điểm tiến độ.

00:34:37.000 --> 00:34:40.000
Các công cụ xác nhận bây giờ không có treo.

00:34:40.000 --> 00:34:43.000
Có một số mức sử dụng CPU cao ngay tại đây.

00:34:43.000 --> 00:34:46.000
Hãy để tôi phóng to điều đó.

00:34:46.000 --> 00:34:49.000
Đây là nơi tải hình thu nhỏ bây giờ xảy ra.

00:34:49.000 --> 00:34:56.000
Kiểm tra luồng chính, chúng tôi có thể xác nhận rằng tất cả các khoảng nhiệm vụ trên luồng chính hiện rất ngắn.

00:34:56.000 --> 00:35:08.000
Cuộn xuống các bản nhạc luồng khác cho thấy rằng các tác vụ Swift của chúng tôi hiện đang thực hiện song song trên các luồng khác thay vì tuần tự, điều này giúp sử dụng tốt hơn nhiều CPU đa lõi của chúng tôi.

00:35:08.000 --> 00:35:15.000
Điều này cho phép chúng tôi tính toán tất cả các hình thu nhỏ trong vài trăm mili giây thay vì gần 1,5 giây.

00:35:15.000 --> 00:35:21.000
Và trong suốt thời gian này, chủ đề chính vẫn phản hồi, vì vậy chúng tôi đã sửa lỗi này ngay bây giờ.

00:35:21.000 --> 00:35:31.000
Bây giờ chúng tôi đã điều tra và sửa chữa một luồng chính không phản hồi do luồng chính bị bận, mà chúng tôi có thể xác định bằng luồng chính bằng cách sử dụng nhiều CPU trong quá trình treo.

00:35:31.000 --> 00:35:47.000
Chúng tôi cũng đã trải nghiệm cách treo có thể đồng bộ khi nó xảy ra trực tiếp như một phần của tương tác người dùng hoặc không đồng bộ, trong đó công việc đã được lên lịch trên luồng chính trước đó khiến một sự kiện đến được xử lý muộn và cách Công cụ có thể phát hiện cả hai trường hợp.

00:35:47.000 --> 00:35:57.000
Và chúng tôi đã khắc phục sự cố treo bằng cách làm ít công việc hơn và bằng cách làm các công việc khác, chúng tôi không thể làm ít hơn trong nền và chỉ quay lại chuỗi chính để cập nhật giao diện người dùng.

00:35:57.000 --> 00:36:05.000
Nhưng có một trường hợp chúng tôi chưa xem xét, một luồng chính bị chặn, trong trường hợp đó luồng chính sẽ sử dụng rất ít CPU.

00:36:05.000 --> 00:36:12.000
Các kích thước khác áp dụng cho một luồng chính bị chặn theo cùng một cách, nhưng các Công cụ khác là cần thiết để phân tích trường hợp như vậy.

00:36:12.000 --> 00:36:15.000
Hãy xem xét một ví dụ ngay bây giờ.

00:36:15.000 --> 00:36:18.000
Ở đây tôi có một tệp theo dõi từ một hang khác.

00:36:18.000 --> 00:36:23.000
Tôi đã phóng to hang rồi. Đó là một cái dài; vài giây.

00:36:23.000 --> 00:36:32.000
Trong bản nhạc "Chủ đề chính", biểu đồ Sử dụng CPU cho chúng ta thấy rằng có một số cách sử dụng CPU ban đầu, nhưng sau đó, không có gì.

00:36:32.000 --> 00:36:35.000
Đây là một trường hợp rõ ràng của một chủ đề chính bị chặn.

00:36:35.000 --> 00:36:41.000
Chúng tôi đã nói về cách Time Profiler thu thập dữ liệu của nó bằng cách lấy mẫu những gì đang chạy trên CPU.

00:36:41.000 --> 00:36:48.000
Khi chúng tôi phóng to, biểu đồ Sử dụng CPU thậm chí còn hiển thị các mẫu riêng lẻ.

00:36:48.000 --> 00:36:53.000
Vì vậy, mỗi điểm đánh dấu này ở đây là một mẫu mà Time Profiler đã lấy.

00:36:53.000 --> 00:36:59.000
Có một vài mẫu nữa ở bên phải, nhưng sau đó không có gì.

00:36:59.000 --> 00:37:07.000
Nhưng khi tôi chọn một khoảng thời gian không có mẫu, Time Profiler không thể cho chúng tôi biết chuyện gì đang xảy ra, vì nó không ghi lại bất kỳ dữ liệu nào trong thời gian này.

00:37:07.000 --> 00:37:12.000
Vì vậy, chúng ta cần một công cụ khác: công cụ Thread States.

00:37:12.000 --> 00:37:16.000
Giống như các nhạc cụ khác trước đây, bạn có thể thêm nó từ thư viện Nhạc cụ.

00:37:16.000 --> 00:37:22.000
Tôi đã thu âm lại cùng một lần nữa, lần này với nhạc cụ "Thread State Trace" được thêm vào.

00:37:22.000 --> 00:37:24.000
Hiện tại có một bản nhạc mới cho nhạc cụ này.

00:37:24.000 --> 00:37:31.000
Nhưng giống như công cụ "Swift Concurrency", dữ liệu thú vị đối với chúng tôi thực sự nằm trong các bản nhạc "chủ đề".

00:37:31.000 --> 00:37:39.000
Vì vậy, có khoảng thời gian "bị chặn" thực sự dài ở đây trong chuỗi chính, hơn sáu giây, điều này giải thích hầu hết thời lượng treo của chúng tôi.

00:37:39.000 --> 00:37:49.000
Khi tôi nhấp vào giữa nó, con trỏ thời gian của Instruments di chuyển đến đó, con trỏ này cũng cập nhật chế độ xem Tường thuật trong khu vực chi tiết để hiển thị mục nhập cho trạng thái bị chặn này.

00:37:49.000 --> 00:37:57.000
Quan điểm tường thuật cho chúng ta biết câu chuyện của chủ đề; nó đang làm gì, khi nào và tại sao.

00:37:57.000 --> 00:38:08.000
Trong thời gian đã chọn, nó cho chúng ta biết rằng luồng đã bị chặn trong 6,64 giây và nó đã bị chặn vì nó đang gọi mach_msg2_trap, một cuộc gọi hệ thống.

00:38:08.000 --> 00:38:11.000
Ở bên phải, lại có một chế độ xem ngược.

00:38:11.000 --> 00:38:15.000
Nhưng dấu vết ngược này không phải là dấu vết ngược nặng nhất-- nó không phải là một tập hợp nào đó.

00:38:15.000 --> 00:38:22.000
Đó là dấu vết ngược chính xác của cuộc gọi hệ thống mach_msg2_trap đã khiến luồng bị chặn.

00:38:22.000 --> 00:38:28.000
Cuộc gọi hàm được hiển thị dưới dạng nút lá ở dưới cùng và ngăn xếp cuộc gọi của nó được hiển thị ở trên.

00:38:28.000 --> 00:38:48.000
Ngăn xếp cuộc gọi cho chúng ta biết rằng cuộc gọi hệ thống xảy ra do kết quả của việc phân bổ Mô hình ML, do đó xảy ra do phân bổ một đối tượng thuộc loại "Dịch vụ tô màu", được gọi là một phần của thuộc tính singleton được gọi là "chia sẻ" trên dịch vụ tô màu đó, đến lượt nó, được gọi bằng cách đóng trong trình nhận

00:38:48.000 --> 00:38:55.000
Nếu chúng ta nhấp đúp vào đóng cửa đó, chúng ta sẽ chuyển đến Trình xem Nguồn một lần nữa và có thể tìm thấy mã nơi điều này được gọi.

00:38:55.000 --> 00:38:57.000
Dòng này trông vô hại, phải không?

00:38:57.000 --> 00:39:01.000
Chúng ta hãy xem xét kỹ hơn.

00:39:01.000 --> 00:39:07.000
Chúng tôi đang truy cập thuộc tính được chia sẻ của ColorizingService và lưu trữ nó trong một biến cục bộ.

00:39:07.000 --> 00:39:19.000
Ngoại trừ nó không vô hại vì thuộc tính được chia sẻ tạo phiên bản ColorizingService được chia sẻ lần đầu tiên nó được truy cập và đến lượt nó, khởi động toàn bộ máy móc tải mô hình, chặn luồng.

00:39:19.000 --> 00:39:26.000
Vì vậy, bạn có thể bị cám dỗ để nói, "Hãy di chuyển cái này vào bên trong phần không đồng bộ sau khi 'chờ đợi'."

00:39:26.000 --> 00:39:30.000
Tuy nhiên, ngược lại trực giác, điều này không giải quyết được vấn đề.

00:39:30.000 --> 00:39:35.000
Từ khóa "chờ" chỉ áp dụng cho các lệnh gọi hàm không đồng bộ trong mã tiếp theo.

00:39:35.000 --> 00:39:40.000
Trong ví dụ của chúng tôi, hàm "tô màu" là "không đồng bộ".

00:39:40.000 --> 00:39:43.000
Nhưng tài sản "chia sẻ" thì không.

00:39:43.000 --> 00:39:51.000
Bởi vì nó là một thuộc tính cho phép tĩnh, nó sẽ được khởi tạo một cách lười biếng ngay lần đầu tiên nó được truy cập và điều đó xảy ra đồng bộ.

00:39:51.000 --> 00:39:57.000
Từ khóa await không thay đổi điều đó, vì vậy cuộc gọi đồng bộ vẫn sẽ xảy ra trên chuỗi chính.

00:39:57.000 --> 00:40:06.000
Chúng ta có thể khắc phục điều này giống như cách chúng ta đã làm trong ví dụ trước của mình, bằng cách làm cho tài sản được chia sẻ trở nên "không đồng bộ" để thoát khỏi diễn viên chính.

00:40:06.000 --> 00:40:13.000
Điều này nói chung là OK khi bạn đang chờ đợi công việc thay mặt cho chủ đề của mình ở nơi khác, nơi tiến độ chuyển tiếp được thực hiện.

00:40:13.000 --> 00:40:18.000
Tuy nhiên, một lý do phổ biến khác cho các chủ đề bị chặn là khóa hoặc semaphores.

00:40:18.000 --> 00:40:30.000
Để biết các phương pháp hay nhất cần ghi nhớ và những điều cần tránh khi sử dụng khóa và semaphores với Swift concurrency, hãy xem phiên của chúng tôi "Swift concurrency: Behind the scenes" từ WWDC 21.

00:40:30.000 --> 00:40:35.000
Trước khi chúng ta kết thúc, tôi muốn nói về một trường hợp khác liên quan đến các chủ đề chính bị chặn.

00:40:35.000 --> 00:40:38.000
Đây là dấu vết mà chúng tôi đã xem xét một lúc trước.

00:40:38.000 --> 00:40:42.000
Bên phải là hang mà chúng tôi vừa điều tra với chủ đề chính bị chặn.

00:40:42.000 --> 00:40:51.000
Nhưng ở bên trái của nó, có một số trường hợp khác mà luồng chính bị chặn trong nhiều giây, nhưng Instruments không gắn cờ đây là một lỗ treo tiềm năng.

00:40:51.000 --> 00:40:55.000
Ở đây, chủ đề chính chỉ đang ngủ vì không có đầu vào của người dùng.

00:40:55.000 --> 00:41:04.000
Từ quan điểm của hệ điều hành, nó bị chặn, nhưng nó chỉ tiết kiệm tài nguyên bằng cách không chạy khi không có gì để làm.

00:41:04.000 --> 00:41:08.000
Ngay khi đầu vào đến, nó sẽ thức dậy và xử lý nó.

00:41:08.000 --> 00:41:17.000
Vì vậy, để xác định xem luồng bị chặn có phải là vấn đề phản hồi hay không, hãy tìm đến công cụ Hangs, không phải công cụ trạng thái luồng.

00:41:17.000 --> 00:41:20.000
Vì vậy, một chủ đề chính bị chặn không ngụ ý một chủ đề chính không phản hồi.

00:41:20.000 --> 00:41:26.000
Tương tự, Mức sử dụng CPU cao cũng không ngụ ý rằng luồng chính không phản hồi.

00:41:26.000 --> 00:41:33.000
Nhưng nếu chủ đề chính không phản hồi, điều đó có nghĩa là nó đã bị chặn hoặc chủ đề chính đang bận.

00:41:33.000 --> 00:41:42.000
Phát hiện treo của chúng tôi tính đến tất cả các chi tiết này và sẽ chỉ gắn nhãn các khoảng thời gian mà luồng chính thực sự không phản hồi và hiển thị chúng là các lỗ treo tiềm năng.

00:41:42.000 --> 00:41:53.000
Nếu bạn chỉ nhớ một điều từ phiên này, hãy để nó là: bất cứ công việc nào bạn đang làm trên luồng chính, nó sẽ được thực hiện trong vòng chưa đầy 100 mili giây để giải phóng luồng chính để xử lý lại sự kiện.

00:41:53.000 --> 00:41:56.000
Càng ngắn, càng tốt.

00:41:56.000 --> 00:42:00.000
Để phân tích chi tiết, Instruments là người bạn tốt nhất của bạn.

00:42:00.000 --> 00:42:09.000
Hãy nhớ sự phân biệt giữa luồng chính bận và luồng chính bị chặn và hãy nhớ rằng việc treo cũng có thể được gây ra bởi công việc không đồng bộ trên luồng chính.

00:42:09.000 --> 00:42:14.000
Để sửa lỗi treo, bạn muốn làm ít công việc hơn hoặc chuyển công việc sang nền.

00:42:14.000 --> 00:42:17.000
Đôi khi, thậm chí cả hai.

00:42:17.000 --> 00:42:22.000
Và làm ít công việc hơn thường chỉ có nghĩa là sử dụng API phù hợp cho công việc.

00:42:22.000 --> 00:42:27.000
Nói chung, hãy đo lường trước và kiểm tra xem có thực sự treo hay không trước khi tối ưu hóa.

00:42:27.000 --> 00:42:33.000
Chắc chắn có một số phương pháp hay nhất, nhưng mã đồng thời và không đồng bộ cũng khó gỡ lỗi hơn nhiều.

00:42:33.000 --> 00:42:40.000
Bạn sẽ thường ngạc nhiên bởi tất cả những thứ thực sự rất nhanh và những gì thực sự kết thúc là chậm.

00:42:40.000 --> 00:42:43.000
Hãy vui vẻ tìm kiếm, phân tích và sửa chữa tất cả các hàng treo của bạn.

00:42:43.000 --> 00:42:45.000
Cảm ơn bạn đã xem.

00:42:45.000 --> 23:59:59.000
♪ ♪

