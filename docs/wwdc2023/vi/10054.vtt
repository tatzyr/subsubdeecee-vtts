WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:15.000
Aasim: Xin chào, tôi là Aasim Kandrikar, và sau đó, tôi sẽ được tham gia bởi Raleigh Ledet.

00:00:15.000 --> 00:00:17.000
Cả hai chúng tôi đều là Kỹ sư trong nhóm AppKit.

00:00:17.000 --> 00:00:23.000
Trong video này, chúng ta sẽ nói về "Có gì mới trong AppKit" trong macOS Sonoma.

00:00:23.000 --> 00:01:00.000
Chúng tôi sẽ đề cập đến một loạt các chủ đề, bắt đầu với các tính năng mới và cải tiến API cho Điều khiển AppKit, cải tiến các menu được cung cấp bởi triển khai hoàn toàn mới, thay đổi cách kích hoạt ứng dụng hoạt động trên macOS, tinh chỉnh đồ họa và các tính năng mới cho hình ảnh và biểu tượng, trải nghiệm nhập văn bản mới và cải tiến

00:01:00.000 --> 00:01:06.000
macOS Sonoma bao gồm một số tính năng mới thú vị và các cải tiến API cho các điều khiển AppKit.

00:01:06.000 --> 00:01:16.000
NSTableView và NSOutlineView cung cấp rất nhiều chức năng ngay lập tức, khiến nó trở thành một yếu tố quan trọng trong việc thiết kế các ứng dụng Mac tuyệt vời bằng AppKit.

00:01:16.000 --> 00:01:21.000
Trong macOS Sonoma, có API mới để trình bày các menu tùy chỉnh cột.

00:01:21.000 --> 00:01:26.000
Trình đơn cho phép người dùng chuyển đổi khả năng hiển thị các cột trong bảng của bạn.

00:01:26.000 --> 00:01:36.000
Trước đây, điều này sẽ yêu cầu triển khai tùy chỉnh để tạo và trình bày menu này, nhưng bây giờ bạn có thể thêm cái này chỉ trong ba dòng mã.

00:01:36.000 --> 00:01:41.000
Áp dụng phương thức đại diện mới tableView userCanChangeVisibilityOf.

00:01:41.000 --> 00:01:52.000
Chỉ định cột nào người dùng có thể ẩn và AppKit sẽ xử lý phần còn lại, bao gồm bản địa hóa menu và khôi phục trạng thái cột ẩn khi khởi chạy lại.

00:01:52.000 --> 00:01:57.000
Loại Tiến độ từ Nền tảng đại diện cho công việc mà ứng dụng của bạn thực hiện.

00:01:57.000 --> 00:02:03.000
Bạn có thể đang sử dụng điều này trong các ứng dụng của mình để thể hiện quá trình tải xuống đang diễn ra hoặc hình ảnh đang được xử lý.

00:02:03.000 --> 00:02:10.000
Trong macOS Sonoma, bây giờ bạn có thể sử dụng loại Progress từ Foundation với NSProgressIndicator.

00:02:10.000 --> 00:02:21.000
Chỉ định tiến độ cho thuộc tính tiến độ quan sát mới và chỉ báo tiến độ sẽ tự động cập nhật giá trị của nó khi tiến độ thay đổi, ngay cả trên các luồng nền.

00:02:21.000 --> 00:02:28.000
API kiểu viền nút đã được cập nhật, bắt đầu với kiểu viền hoàn toàn mới, tự động.

00:02:28.000 --> 00:02:37.000
Kiểu viền này sẽ thích ứng với kiểu phù hợp nhất tùy thuộc vào nội dung của nút và vị trí của nó trong hệ thống phân cấp chế độ xem.

00:02:37.000 --> 00:02:42.000
Ví dụ, khi nút ở trong cửa sổ, nó sẽ chọn kiểu nút nhấn.

00:02:42.000 --> 00:02:46.000
Khi nút được đặt trên thanh công cụ, nó sẽ chọn kiểu thanh công cụ.

00:02:46.000 --> 00:02:51.000
Đối với nội dung cao, nút sẽ chọn kiểu nút nhấn linh hoạt.

00:02:51.000 --> 00:02:59.000
Kiểu viền tự động hiện là kiểu viền mặc định cho tất cả các trình khởi tạo nút.

00:02:59.000 --> 00:03:07.000
Các tên kiểu viền hiện có đã được cập nhật từ mô tả về ngoại hình của chúng sang tên hiện đại dựa trên cách sử dụng ngữ nghĩa của chúng.

00:03:07.000 --> 00:03:17.000
Ví dụ, nút "Dõm" được đặt tên trước đây bây giờ là nút "Thanh phụ kiện", cho thấy kiểu viền này được sử dụng phổ biến nhất trong Thanh phụ kiện.

00:03:17.000 --> 00:03:20.000
Các kiểu viền không khuyến khích hiện đã bị phản đối.

00:03:20.000 --> 00:03:25.000
Các biện pháp không dùng nữa hiện đề cập đến các kiểu viền thay thế với cách sử dụng ngữ nghĩa rõ ràng.

00:03:25.000 --> 00:03:29.000
Chúng tôi đã giới thiệu một loại chế độ xem phân chia hoàn toàn mới, thanh tra viên.

00:03:29.000 --> 00:03:38.000
Thanh tra là một mục chế độ xem phân chia theo dõi hiển thị thông tin theo ngữ cảnh về nội dung hiện đang được chọn trong tài liệu.

00:03:38.000 --> 00:03:45.000
Tương tự như thanh bên, các thanh tra viên sử dụng chiều cao đầy đủ của cửa sổ khi mặt nạ xem nội dung kích thước đầy đủ được đặt.

00:03:45.000 --> 00:03:49.000
Các thanh tra viên mới triển khai lại macOS Big Sur.

00:03:49.000 --> 00:03:53.000
Thêm một trình kiểm tra vào ứng dụng của bạn rất đơn giản.

00:03:53.000 --> 00:03:59.000
Đầu tiên, tạo một mục chế độ xem phân chia mới bằng cách sử dụng trình khởi tạo inspectorWithViewController mới.

00:03:59.000 --> 00:04:05.000
Sau đó, thêm splitViewItem mới vào bộ điều khiển chế độ xem phân chia hiện tại của bạn.

00:04:05.000 --> 00:04:11.000
Tiếp theo, cập nhật đại diện thanh công cụ của bạn để bao gồm mục thanh công cụ thanh tra chuyển đổi mới.

00:04:11.000 --> 00:04:18.000
Bạn thường muốn mục thanh tra chuyển đổi được đặt trên thanh tra ở cạnh sau của cửa sổ.

00:04:18.000 --> 00:04:26.000
Để làm như vậy, hãy thêm dải phân cách theo dõi thanh tra mới và một không gian linh hoạt trước mục thanh tra chuyển đổi của bạn.

00:04:26.000 --> 00:04:29.000
Chúng tôi đã mang lại một số cải tiến cho NSPopover.

00:04:29.000 --> 00:04:34.000
Đầu tiên, chúng tôi đã thêm hỗ trợ cho việc neo các cửa sổ bật lên từ các mục trên thanh công cụ.

00:04:34.000 --> 00:04:41.000
Chúng tôi cũng đã thêm một cách để hỗ trợ nội dung cửa sổ bật lên kích thước đầy đủ, vì vậy lượt xem của bạn lấp đầy toàn bộ giới hạn cửa sổ bật lên.

00:04:41.000 --> 00:04:43.000
Tôi sẽ bắt đầu với việc neo thanh công cụ.

00:04:43.000 --> 00:04:48.000
Có một phương pháp mới để trình bày cửa sổ bật lên của bạn liên quan đến một mục thanh công cụ.

00:04:48.000 --> 00:04:56.000
Khi mục thanh công cụ nằm trong menu tràn, cửa sổ bật lên xuất hiện duyên dáng được neo vào chevron tràn.

00:04:56.000 --> 00:05:01.000
Tiếp theo, nội dung cửa sổ bật lên bây giờ có thể mở rộng vào chevron cửa sổ bật lên.

00:05:01.000 --> 00:05:06.000
Nếu bạn có một cửa sổ bật lên với chế độ xem tiêu đề nền màu, nó có thể trông giống như thế này.

00:05:06.000 --> 00:05:11.000
Lưu ý rằng màu sắc trong nền tiêu đề không mở rộng vào chevron bật lên.

00:05:11.000 --> 00:05:19.000
Để mở rộng nội dung cửa sổ bật lên vào khu vực chevron, hãy đặt thuộc tính hasFullSizeContent mới thành true.

00:05:19.000 --> 00:05:26.000
Sử dụng khu vực an toàn trực tiếp để bố trí nội dung không nên bị che khuất bên trong cửa sổ bật lên.

00:05:26.000 --> 00:05:31.000
Và bây giờ tôi sẽ chuyển nó cho Raleigh để nói về những thay đổi thú vị đối với Menus.

00:05:31.000 --> 00:05:32.000
Raleigh: Cảm Ơn Aasim.

00:05:32.000 --> 00:05:35.000
Các menu đã được viết lại để sử dụng đầy đủ Cocoa.

00:05:35.000 --> 00:05:41.000
Điều này làm giảm lượng khí thải carbon của AppKit bằng cách giảm đáng kể việc sử dụng bộ nhớ và CPU.

00:05:41.000 --> 00:05:45.000
Nó cũng cho phép các tính năng mới.

00:05:45.000 --> 00:05:52.000
Cụ thể, tôi sẽ đề cập đến tiêu đề phần, menu bảng màu, hành vi lựa chọn mới và huy hiệu.

00:05:52.000 --> 00:05:59.000
Những tính năng này mở ra những cơ hội mới và sẽ giảm lượng mã bạn cần viết.

00:05:59.000 --> 00:06:06.000
Tiêu đề phần là một bổ sung mới hỗ trợ truyền đạt các nhóm trong menu của bạn và có thể được tạo bằng một dòng mã duy nhất.

00:06:06.000 --> 00:06:13.000
Sử dụng chức năng lớp mới, sectionHeader(title:) để tạo một cái và thêm nó vào menu, giống như bất kỳ mục menu nào khác.

00:06:13.000 --> 00:06:20.000
Trong ví dụ này, ba phần menu được tạo ra, mỗi phần có tiêu đề phần và hai mục.

00:06:20.000 --> 00:06:27.000
Các menu bảng màu là một tính năng mới thú vị cho phép bạn xây dựng các menu trong đó các mục được sắp xếp theo một chuỗi nằm ngang.

00:06:27.000 --> 00:06:31.000
Ví dụ, bộ chọn màu đơn giản này.

00:06:31.000 --> 00:06:37.000
Bạn có thể biến bất kỳ menu nào thành menu bảng màu bằng cách đặt presentationStyle của menu thành .palette.

00:06:37.000 --> 00:06:40.000
Đối với mỗi mục menu, hãy đặt hình ảnh của nó.

00:06:40.000 --> 00:06:46.000
Đối với hình ảnh mẫu, AppKit sẽ tự động thêm tông màu lựa chọn thích hợp.

00:06:46.000 --> 00:06:50.000
Ngoài ra, bạn có thể đặt offStateImage và onStateImage.

00:06:50.000 --> 00:06:55.000
onStateImage được sử dụng để chỉ ra lựa chọn.

00:06:55.000 --> 00:06:58.000
Có một vài chế độ lựa chọn mà bạn có thể chọn.

00:06:58.000 --> 00:07:05.000
.selectAny chuyển đổi trạng thái của các mục menu riêng lẻ, nhưng sẽ không thay đổi trạng thái của các mục khác trong nhóm.

00:07:05.000 --> 00:07:13.000
.selectOne sẽ đặt trạng thái của mục menu đã chọn thành bật trong khi tắt trạng thái của các thành viên khác trong nhóm.

00:07:13.000 --> 00:07:20.000
Bạn cũng có thể lấy hoặc đặt mục nào ở trạng thái bật thông qua thuộc tính selectedItems.

00:07:20.000 --> 00:07:28.000
Lưu ý: Chế độ lựa chọn và Mục đã chọn hoạt động bằng cách tổ chức các mục menu có cùng cặp mục tiêu/hành động thành một nhóm logic.

00:07:28.000 --> 00:07:37.000
Khi tạo thủ công các mục menu bảng màu, hãy cung cấp cho mỗi mục cùng một cặp mục tiêu/hành động để tận dụng lợi thế của chế độ lựa chọn mới và hành vi của các mục đã chọn.

00:07:37.000 --> 00:07:42.000
Và đây là một mẹo: Kỹ thuật này không giới hạn ở các menu bảng màu.

00:07:42.000 --> 00:07:48.000
Nó cũng hoạt động cho các mục menu có cùng cặp mục tiêu/hành động trong các menu thông thường.

00:07:48.000 --> 00:07:53.000
NSMenu cũng cung cấp một chức năng tiện lợi để tạo các menu bảng màu phổ biến.

00:07:53.000 --> 00:07:58.000
Mảng màu xác định số lượng các mục bảng màu và tông màu của chúng.

00:07:58.000 --> 00:08:03.000
Tiêu đề được sử dụng cho khả năng tiếp cận, vì vậy hãy đảm bảo rằng bạn thêm chúng.

00:08:03.000 --> 00:08:07.000
Tham số mẫu tùy chọn chỉ định hình ảnh mẫu nào sẽ sử dụng để pha màu.

00:08:07.000 --> 00:08:12.000
Ví dụ, hình ảnh biểu tượng cờ được sử dụng ở đây.

00:08:12.000 --> 00:08:18.000
Nếu bạn không chỉ định một mẫu, thì AppKit sẽ mặc định điền vào các vòng tròn.

00:08:18.000 --> 00:08:21.000
Ngoài ra còn có một tham số đóng tùy chọn.

00:08:21.000 --> 00:08:26.000
Việc đóng cửa này được gọi bất cứ khi nào người dùng chuyển đổi một mục menu trong bảng màu.

00:08:26.000 --> 00:08:28.000
Thực đơn được chuyển đến phần đóng.

00:08:28.000 --> 00:08:35.000
Từ đó, bạn có thể nhận được một mảng các mục menu ở trạng thái bật với thuộc tính selectedItems.

00:08:35.000 --> 00:08:39.000
Các mục trong thực đơn hiện có thể được gắn huy hiệu theo nhiều cách khác nhau.

00:08:39.000 --> 00:08:44.000
Bạn có thể sử dụng một chuỗi đơn giản hoặc chỉ đếm.

00:08:44.000 --> 00:08:50.000
Ngoài ra còn có ba huy hiệu đếm chuyên biệt: Vật phẩm mới, cảnh báo và cập nhật.

00:08:50.000 --> 00:08:55.000
Khi bạn sử dụng một trong những huy hiệu này, AppKit sẽ tự động thêm văn bản thích hợp.

00:08:55.000 --> 00:08:59.000
Hơn nữa, AppKit cũng sẽ bản địa hóa văn bản đúng cách.

00:08:59.000 --> 00:09:01.000
Trong ví dụ này, tiếng Nhật.

00:09:01.000 --> 00:09:10.000
Tuy nhiên, lưu ý rằng bạn vẫn chịu trách nhiệm bản địa hóa chính mục menu và biến thể huy hiệu chuỗi chung.

00:09:10.000 --> 00:09:19.000
Đó là việc triển khai menu hoàn toàn mới: cải thiện hiệu suất, huy hiệu, bảng màu và tiêu đề phần.

00:09:19.000 --> 00:09:23.000
Trong macOS Sonoma, chúng tôi đã giới thiệu Kích hoạt Ứng dụng Hợp tác.

00:09:23.000 --> 00:09:33.000
Kích hoạt ứng dụng hợp tác làm giảm các công tắc ứng dụng bất ngờ, ví dụ, chuyển đổi ứng dụng trong khi bạn đang gõ.

00:09:33.000 --> 00:09:36.000
Có hai phần để kích hoạt ứng dụng hợp tác.

00:09:36.000 --> 00:09:40.000
Kích hoạt bây giờ là một yêu cầu, trái ngược với một lệnh.

00:09:40.000 --> 00:09:47.000
Hệ thống xem xét bối cảnh rộng hơn về những gì người dùng đang làm để quyết định xem yêu cầu kích hoạt có phù hợp hay không.

00:09:47.000 --> 00:09:55.000
API năng suất mới cho phép một ứng dụng ảnh hưởng đến bối cảnh của một yêu cầu kích hoạt trong tương lai.

00:09:55.000 --> 00:10:01.000
Bây giờ kích hoạt là một yêu cầu, tham số và tùy chọn bỏ qua OtherApps bị bỏ qua.

00:10:01.000 --> 00:10:10.000
Như vậy, trong macOS Sonoma, chức năng activate(ignoringOtherApps:) và tùy chọn activateIgnoringOtherApps đều bị phản đối.

00:10:10.000 --> 00:10:17.000
Thay thế chúng bằng các API kích hoạt mới cho NSApplication và NSRunningApplication.

00:10:17.000 --> 00:10:22.000
Chỉ có ứng dụng đang hoạt động mới có thể ảnh hưởng đến ngữ cảnh kích hoạt.

00:10:22.000 --> 00:10:28.000
Nó làm như vậy bằng cách nhường cho một ứng dụng mục tiêu rõ ràng trước khi ứng dụng mục tiêu được kích hoạt.

00:10:28.000 --> 00:10:37.000
Sau đó, khi ứng dụng mục tiêu yêu cầu kích hoạt, hệ thống sẽ sử dụng năng suất như một phần của ngữ cảnh khi đưa ra quyết định.

00:10:37.000 --> 00:10:43.000
Nếu yêu cầu được tôn trọng, ứng dụng đang hoạt động sẽ hủy kích hoạt và ứng dụng đích sẽ kích hoạt.

00:10:43.000 --> 00:10:47.000
Nếu không, ứng dụng đang hoạt động vẫn hoạt động.

00:10:47.000 --> 00:10:54.000
NSWorkspace tự động xử lý việc này cho bạn khi mở URL hoặc ứng dụng.

00:10:54.000 --> 00:11:04.000
Trong các trường hợp khác, để kích hoạt thủ công sang một ứng dụng khác, yieldActivation đến NSRunningApplication đích hoặc mã định danh gói.

00:11:04.000 --> 00:11:12.000
Hệ thống sẽ sử dụng ngữ cảnh năng suất khi ứng dụng mục tiêu yêu cầu tự kích hoạt hoặc được kích hoạt thay mặt cho nó.

00:11:12.000 --> 00:11:16.000
Đó là hành vi kích hoạt ứng dụng hợp tác mới.

00:11:16.000 --> 00:11:23.000
Chúng tôi cũng đã thực hiện một số thay đổi quan trọng và thêm API mới vào đồ họa và bản vẽ trong macOS Sonoma.

00:11:23.000 --> 00:11:28.000
Bây giờ bạn có thể tạo CGPaths từ NSBezierPaths và ngược lại.

00:11:28.000 --> 00:11:34.000
NSBezierPath có được trình khởi tạo init(cgPath:) mới và thuộc tính cgPath.

00:11:34.000 --> 00:11:40.000
Việc khởi tạo, cài đặt hoặc nhận cgPath luôn dẫn đến một bản sao của đường dẫn.

00:11:40.000 --> 00:11:47.000
Các đột biến khác của NSBezierPath không được phản ánh trong các trường hợp CGPath gốc hoặc bản sao chép.

00:11:47.000 --> 00:11:50.000
Đó là, chúng không phải là cầu nối miễn phí.

00:11:50.000 --> 00:12:00.000
Sự bổ sung này tạo ra việc sử dụng NSBezierPath với CGPath API, chẳng hạn như thuộc tính đường dẫn trên CAShapeLayer, một dòng mã duy nhất.

00:12:00.000 --> 00:12:04.000
Bây giờ bạn có thể tạo một đối tượng CADisplayLink trên macOS.

00:12:04.000 --> 00:12:08.000
Đây là cùng một CADisplayLink mà bạn có thể quen thuộc từ iOS.

00:12:08.000 --> 00:12:17.000
Đối với những người không quen thuộc với CADisplayLink, nó là một đối tượng hẹn giờ cho phép ứng dụng của bạn đồng bộ hóa bản vẽ của nó với tốc độ làm mới của màn hình.

00:12:17.000 --> 00:12:25.000
Một đối tượng liên kết hiển thị được khởi tạo trực tiếp được đồng bộ hóa với màn hình chính, nhưng macOS không giới hạn ở một màn hình duy nhất.

00:12:25.000 --> 00:12:37.000
Do đó, trên macOS, bạn có thể lấy đối tượng liên kết hiển thị trực tiếp từ NSView, NSWindow hoặc NSScreen với các chức năng displayLink(target:selector:) mới của họ.

00:12:37.000 --> 00:12:47.000
Cách tiếp cận tốt nhất là lấy một đối tượng CADisplayLink trực tiếp từ phần tử có thể áp dụng cụ thể nhất, thường là chế độ xem.

00:12:47.000 --> 00:13:02.000
Điều này là do, khi được tạo từ chế độ xem hoặc cửa sổ, CADisplayLink sẽ tự động theo dõi bất kỳ màn hình hoặc chế độ xem cửa sổ nào khi nó di chuyển xung quanh màn hình nền, bao gồm cả việc tự treo khi không hiển thị.

00:13:02.000 --> 00:13:21.000
Trong lớp con chế độ xem này, khi startAnimating được gọi, với hai dòng mã, nó tạo ra một đối tượng DisplayLink để gọi hàm stepAnimation của nó, được đồng bộ hóa với bất kỳ màn hình nào mà chế độ xem đang bật và thêm displayLink vào vòng lặp chạy chính cho các chế độ phổ biến.

00:13:21.000 --> 00:13:29.000
Khi hoạt ảnh hoàn tất, nó sẽ vô hiệu hóa để dừng liên kết hiển thị và xóa nó khỏi tất cả các chế độ runloop đã đăng ký.

00:13:29.000 --> 00:13:35.000
NSColor hiện cung cấp năm màu hệ thống mới để lấp đầy các hình nền.

00:13:35.000 --> 00:13:40.000
Các màu tô cung cấp mức độ nhấn mạnh khác nhau cho các hình dạng có kích thước khác nhau.

00:13:40.000 --> 00:13:50.000
Các hình dạng nhỏ hơn trên tỷ lệ của rãnh trượt hoặc nền thanh tiến trình sử dụng mức độ nhấn mạnh cao hơn để nổi bật, chẳng hạn như điền hệ thống hoặc điền hệ thống phụ.

00:13:50.000 --> 00:13:59.000
Các hình dạng lớn hơn, như hộp nhóm và nền phông chữ thích mức độ nhấn mạnh tinh tế hơn, chẳng hạn như lấp đầy hệ thống bậc bốn hoặc ngũ phân.

00:13:59.000 --> 00:14:08.000
Những màu tô này rất năng động, vì vậy chúng tự động thích ứng với các giao diện khác nhau, bao gồm Tăng độ tương phản và Chế độ tối.

00:14:08.000 --> 00:14:18.000
Nếu bạn đang xây dựng các yếu tố giao diện người dùng tùy chỉnh, những màu tô mới này là một cách thuận tiện để phù hợp với thiết kế hệ thống và hỗ trợ khả năng tiếp cận.

00:14:18.000 --> 00:14:22.000
NSViews cắt nội dung bản vẽ của họ vào giới hạn của họ.

00:14:22.000 --> 00:14:31.000
Điều đó đôi khi dẫn đến việc bản vẽ không hiển thị theo cách bạn muốn, như phần dưới cùng của glyph tiếng Hindi này trong cửa sổ cảnh báo FreeForm.

00:14:31.000 --> 00:14:42.000
Những nơi phổ biến mà điều này có thể xảy ra là với kết xuất phông chữ, bóng tối hoặc các điểm nhấn chế độ xem phụ khác, như huy hiệu hoặc ngọn lửa trên mặt hàng "nóng" đó để bán.

00:14:42.000 --> 00:14:44.000
Có nhiều cách để giải quyết vấn đề này.

00:14:44.000 --> 00:14:49.000
Ví dụ, nhúng các chế độ xem kết hợp như anh chị em trong một chế độ xem lớn hơn.

00:14:49.000 --> 00:14:52.000
Tuy nhiên, mỗi kỹ thuật đều có những nhược điểm riêng.

00:14:52.000 --> 00:15:01.000
Trong trường hợp này, việc kết hợp chế độ xem kèm theo với một nút trong ngăn xếp ngang đơn giản sẽ không sắp xếp các dòng cơ sở của văn bản theo mặc định.

00:15:01.000 --> 00:15:05.000
Và bây giờ bạn có một vấn đề khác cần giải quyết.

00:15:05.000 --> 00:15:07.000
Có một cách tốt hơn.

00:15:07.000 --> 00:15:15.000
Khi được liên kết trên macOS Sonoma, hầu hết NSViews không còn cắt vào giới hạn của chúng theo mặc định.

00:15:15.000 --> 00:15:20.000
Thử nghiệm lượt truy cập vẫn không thay đổi và được xác định bởi hình dạng của chế độ xem.

00:15:20.000 --> 00:15:23.000
Tất nhiên, bạn có thể ghi đè hitTest để thay đổi điều này.

00:15:23.000 --> 00:15:30.000
Bây giờ một chế độ xem có thể vẽ bên ngoài giới hạn của nó, visibleRect được tính toán của nó cũng có thể mở rộng qua giới hạn của nó.

00:15:30.000 --> 00:15:35.000
Xem lại bất kỳ mã nào sử dụng visibleRect và điều chỉnh cho phù hợp.

00:15:35.000 --> 00:15:39.000
Điều này cũng ảnh hưởng đến tham số dirtyRect của hàm vẽ.

00:15:39.000 --> 00:15:45.000
Cụ thể, dirtyRect không bị ràng buộc bởi giới hạn của chế độ xem.

00:15:45.000 --> 00:15:50.000
AppKit có quyền vượt qua một dirtyRect lớn hơn giới hạn của chế độ xem.

00:15:50.000 --> 00:15:56.000
AppKit cũng có quyền chia nhỏ bản vẽ thành nhiều hình chữ nhật tùy thích.

00:15:56.000 --> 00:16:05.000
Điều này có ý nghĩa đối với bạn là bạn nên sử dụng dirtyRect để quyết định vẽ gì, chứ không phải vẽ ở đâu.

00:16:05.000 --> 00:16:09.000
Đây là một ví dụ về kết quả vẽ bất ngờ có thể xảy ra.

00:16:09.000 --> 00:16:19.000
Bản vẽ ghi đè này lấp đầy màu nền được truyền trong dirtyRect, khiến màu tô tràn ra ngoài giới hạn của chế độ xem, bao phủ giao diện người dùng khác trong cửa sổ.

00:16:19.000 --> 00:16:24.000
Chế độ xem không sử dụng dirtyRect để vẽ khung.

00:16:24.000 --> 00:16:33.000
Tương tự như vậy, việc lấp đầy nền của nó phải lấp đầy chính xác những gì thiết kế của bạn yêu cầu, không hơn không kém.

00:16:33.000 --> 00:16:36.000
Vẽ bên ngoài dirtyRect luôn an toàn.

00:16:36.000 --> 00:16:44.000
Lợi ích hiệu suất của dirtyRect xảy ra khi được sử dụng để quyết định phần nào trong dữ liệu của bạn mà bạn có thể tránh vẽ trong đường chuyền này.

00:16:44.000 --> 00:16:50.000
Có lẽ việc tính toán đường nét của tên tôi theo phong cách lạ mắt này rất tốn kém.

00:16:50.000 --> 00:16:58.000
Nếu dirtyRect chỉ là góc nhỏ này, nó sẽ không giao nhau với khung văn bản, vì vậy chế độ xem có thể tránh được những tính toán tốn kém đó.

00:16:58.000 --> 00:17:14.000
Vẽ nền và khung vẫn được yêu cầu, nhưng, điền vào toàn bộ giới hạn và vẽ toàn bộ khung trong đường chuyền này sẽ không ảnh hưởng đến các phần khác đã được vẽ của chế độ xem vì AppKit kẹp bản vẽ vào dirtyRect.

00:17:14.000 --> 00:17:21.000
Thuộc tính NSView .clipsToBounds mới có sẵn cho đến OS X Mavericks 10.9.

00:17:21.000 --> 00:17:26.000
Nhưng lưu ý, trên các hệ điều hành cũ hơn, tắt .clipsToBounds có thể có một số cạnh thô.

00:17:26.000 --> 00:17:28.000
Kiểm tra tương ứng.

00:17:28.000 --> 00:17:33.000
Hầu hết các chế độ xem sẽ hoạt động tốt với cả bật và tắt.

00:17:33.000 --> 00:17:37.000
Một số chế độ xem vùng chứa đưa ra quyết định rõ ràng của riêng họ.

00:17:37.000 --> 00:17:40.000
NSClipView, đúng với tên gọi của nó, hoạt động theo cách này.

00:17:40.000 --> 00:17:48.000
Có thể có những trường hợp cụ thể mà bạn không đồng ý với hành vi cắt xén mặc định của chế độ xem và cần thay đổi nó một cách có chọn lọc.

00:17:48.000 --> 00:17:55.000
Xem xét trên cơ sở từng trường hợp xem lượt xem nào của riêng bạn yêu cầu giá trị clipsToBounds rõ ràng.

00:17:55.000 --> 00:17:59.000
Sự lựa chọn đúng đắn là sự lựa chọn hiện thực hóa tầm nhìn của bạn cho ứng dụng của bạn.

00:17:59.000 --> 00:18:03.000
Bây giờ quay lại Aasim để nói về hình ảnh.

00:18:03.000 --> 00:18:04.000
Aasim: Cảm Ơn Raleigh.

00:18:04.000 --> 00:18:08.000
Biểu tượng là một phần thiết yếu trong việc thiết kế ứng dụng của bạn.

00:18:08.000 --> 00:18:13.000
Trong macOS Sonoma, các biểu tượng đạt được chức năng hoàn toàn mới, hiệu ứng biểu tượng.

00:18:13.000 --> 00:18:25.000
Với các hiệu ứng biểu tượng, các biểu tượng của bạn giờ đây có thể có các hiệu ứng như nảy, chuyển tiếp thay thế và hoạt ảnh xung.

00:18:25.000 --> 00:18:32.000
Hiệu ứng biểu tượng là cách tuyệt vời để nhấn mạnh một hành động đã xảy ra hoặc thay đổi trạng thái trong ứng dụng của bạn.

00:18:32.000 --> 00:18:35.000
Thêm một hiệu ứng biểu tượng rất đơn giản.

00:18:35.000 --> 00:18:40.000
Đầu tiên, đặt thuộc tính hình ảnh của imageView thành hình ảnh biểu tượng.

00:18:40.000 --> 00:18:46.000
Sau đó, khi bạn muốn hiệu ứng, chỉ cần gọi addSymbolEffect vào chế độ xem hình ảnh.

00:18:46.000 --> 00:18:52.000
Lưu ý rằng điều này sẽ chỉ hoạt động nếu NSImageView của bạn sử dụng hình ảnh biểu tượng.

00:18:52.000 --> 00:18:59.000
Để biết thêm thông tin về việc sử dụng các hiệu ứng biểu tượng, hãy xem video "Tác động các biểu tượng trong ứng dụng của bạn".

00:18:59.000 --> 00:19:06.000
Trong macOS Ventura, chúng tôi đã giới thiệu hỗ trợ cho Biểu tượng SF để tự động thích ứng với ngôn ngữ hiện tại của người dùng.

00:19:06.000 --> 00:19:13.000
Bây giờ trong macOS Sonoma, hình ảnh và biểu tượng danh mục tài sản của bạn có cùng khả năng đó.

00:19:13.000 --> 00:19:19.000
Giống như Biểu tượng SF trong macOS Ventura, chúng tuân theo ngôn ngữ hệ thống theo mặc định.

00:19:19.000 --> 00:19:24.000
Sử dụng phương pháp ngôn ngữ hình ảnh để có được một hình ảnh với một ngôn ngữ cố định.

00:19:24.000 --> 00:19:30.000
Tiếp theo, tôi sẽ nói về nội dung Dải động cao, hay viết tắt là HDR.

00:19:30.000 --> 00:19:35.000
Nội dung HDR có thể thể hiện mức độ ánh sáng vượt xa nội dung tiêu chuẩn.

00:19:35.000 --> 00:19:48.000
macOS đã hỗ trợ dải động mở rộng cho một số bản phát hành, cho phép bạn tận dụng tối đa các màn hình như Liquid Retina XDR trong Macbook Pros và Pro Display XDR.

00:19:48.000 --> 00:19:56.000
macOS Sonoma giúp hiển thị nội dung HDR trong ứng dụng của bạn dễ dàng hơn bao giờ hết với NSImageView nhận được hỗ trợ cho nội dung HDR.

00:19:56.000 --> 00:20:04.000
Hình ảnh chứa nội dung HDR bây giờ sẽ được hiển thị ở chế độ HDR trên phần cứng có khả năng Dải động mở rộng.

00:20:04.000 --> 00:20:12.000
Để hiển thị nội dung HDR trong dải động tiêu chuẩn, hãy sử dụng thuộc tính ImageDynamicRange ưa thích để ghi đè.

00:20:12.000 --> 00:20:19.000
Để biết thêm thông tin về việc áp dụng API này, hãy xem video "Hỗ trợ hình ảnh HDR trong ứng dụng của bạn".

00:20:19.000 --> 00:20:28.000
Bắt đầu từ Xcode 15, hình ảnh và màu sắc trong Danh mục tài sản của bạn sẽ tự động được phản ánh vào mã của bạn dưới dạng các thuộc tính tĩnh trên NSImage và NSColor.

00:20:28.000 --> 00:20:34.000
Điều này cho phép bạn sử dụng ký hiệu chấm sạch để truy cập hình ảnh thay vì khởi tạo nó bằng một chuỗi.

00:20:34.000 --> 00:20:40.000
Các hình ảnh không phải là tùy chọn, vì vậy bạn cũng có thể loại bỏ bất kỳ lực mở gói hoặc kiểm tra bảo vệ nào.

00:20:40.000 --> 00:20:54.000
Nếu bạn sửa đổi Danh mục tài sản để xóa hoặc đổi tên hình ảnh, trình biên dịch sẽ phát hiện bất kỳ sự không phù hợp nào với mã của bạn và tạo ra lỗi khi xây dựng ứng dụng của bạn, điều này cho phép bạn sửa nó ngay lập tức, thay vì bắt nó sau này trong thời gian chạy.

00:20:54.000 --> 00:21:02.000
macOS Sonoma giới thiệu những thay đổi đáng kể đối với trải nghiệm đánh máy và cải tiến bố cục văn bản bằng các ngôn ngữ không phải tiếng Anh.

00:21:02.000 --> 00:21:15.000
Nó bắt đầu với một chỉ báo chèn hoàn toàn mới thích ứng với màu nhấn hiện tại và để lại ánh sáng rực rỡ khi bạn đọc chính tả văn bản.

00:21:15.000 --> 00:21:25.000
Tiếp theo, bây giờ có một phụ kiện con trỏ bên dưới chỉ báo chèn hiển thị thông tin chính, như chế độ nhập, trạng thái đọc chính tả và trạng thái khóa mũ.

00:21:25.000 --> 00:21:36.000
Phụ kiện theo dõi vị trí chèn hiện tại và sẽ được ghim vào cuối tài liệu nếu vị trí chèn nằm ngoài chế độ xem hiển thị.

00:21:36.000 --> 00:21:40.000
Các ứng dụng sử dụng chế độ xem văn bản AppKit tiêu chuẩn sẽ tự động nhận được điều này.

00:21:40.000 --> 00:21:45.000
Nếu bạn có chế độ xem văn bản tùy chỉnh, chúng tôi có API mới mà bạn có thể áp dụng.

00:21:45.000 --> 00:21:51.000
Bạn có thể thay thế bản vẽ chỉ báo chèn văn bản tùy chỉnh của mình bằng chế độ xem NSTextInsertionIndicator.

00:21:51.000 --> 00:21:59.000
Thêm chế độ xem này dưới dạng chế độ xem phụ trên chế độ xem văn bản tùy chỉnh của bạn và bạn sẽ nhận được chỉ báo chèn mới nhất quán trên hệ điều hành.

00:21:59.000 --> 00:22:05.000
Lưu ý rằng bạn sẽ chịu trách nhiệm cập nhật khung của chỉ báo chèn và liệu nó có hiển thị hay không.

00:22:05.000 --> 00:22:11.000
Cập nhật thuộc tính displayMode thành ẩn khi chế độ xem văn bản của bạn từ bỏ phản hồi đầu tiên để ẩn chỉ báo.

00:22:11.000 --> 00:22:17.000
MacOS Sonoma có một số cải tiến về bố cục văn bản cho các ngôn ngữ không phải tiếng Anh.

00:22:17.000 --> 00:22:27.000
Một điểm nổi bật quan trọng là những thay đổi mà chúng tôi đã thực hiện để gói và gạch nối, vì một số ngôn ngữ yêu cầu các quy tắc khác nhau để ngắt dòng, tùy thuộc vào ngữ cảnh văn bản.

00:22:27.000 --> 00:22:37.000
Ví dụ, trong cách sắp chữ truyền thống cho tiếng Hàn, nội dung văn bản có thể có dấu ngắt dòng ở giữa từ, nhưng văn bản tiêu đề sẽ chỉ quấn ở ranh giới từ.

00:22:37.000 --> 00:22:41.000
Phá vỡ các từ trong tiêu đề có thể cảm thấy chói tai trong tiếng Hàn.

00:22:41.000 --> 00:22:46.000
Trong tờ này từ Maps, từ tiếng Hàn có nghĩa là "thời gian" được chia thành hai dòng.

00:22:46.000 --> 00:22:52.000
macOS Sonoma bây giờ sẽ thực hiện ngắt dòng khác nhau tùy thuộc vào phông chữ kiểu văn bản được sử dụng.

00:22:52.000 --> 00:22:58.000
Trong tiếng Hàn, các kiểu văn bản tiêu đề và Tiêu đề như trong trang tính này sẽ không bao bọc ở ranh giới từ.

00:22:58.000 --> 00:23:03.000
Trong khi kiểu văn bản nội dung có thể bị ngắt dòng trong các từ nếu thích hợp.

00:23:03.000 --> 00:23:04.000
Đây là một ví dụ khác.

00:23:04.000 --> 00:23:14.000
Trong bố cục hẹp, một số từ tiếng Đức có thể dài hơn toàn bộ chiều rộng dòng, điều này có thể khiến các ký tự riêng lẻ tràn sang dòng tiếp theo.

00:23:14.000 --> 00:23:16.000
Gói này không lý tưởng.

00:23:16.000 --> 00:23:23.000
Nó trông không cân bằng, và có một thành phần của từ - được gọi là hình thái - đang được phân chia theo các dòng.

00:23:23.000 --> 00:23:33.000
Trong macOS Sonoma, nếu bạn có trường văn bản tiêu đề bị vô hiệu hóa dấu gạch nối, macOS sẽ tự động gạch nối văn bản ở ranh giới hình thái thay vì gói ký tự.

00:23:33.000 --> 00:23:37.000
Bố cục kết quả cân bằng hơn và dễ đọc hơn.

00:23:37.000 --> 00:23:42.000
Đây là thời điểm tuyệt vời để áp dụng các kiểu văn bản trong ứng dụng của bạn.

00:23:42.000 --> 00:23:51.000
Trong macOS Sonoma, AppKit đã được cập nhật để giúp dễ dàng áp dụng các tính năng Swift đầu tiên như Swift đồng thời và có thể chuyển nhượng.

00:23:51.000 --> 00:23:59.000
SwiftUI cũng đã được cập nhật để cho phép bạn sử dụng chế độ xem SwiftUI và công cụ sửa đổi ở nhiều nơi hơn trong ứng dụng AppKit của bạn.

00:23:59.000 --> 00:24:04.000
Phần lớn các lớp AppKit bị giới hạn trong chuỗi chính.

00:24:04.000 --> 00:24:10.000
Trong Swift concurrency, các lớp này được đánh dấu là tác nhân chính để tạo ra các lỗi trình biên dịch thích hợp.

00:24:10.000 --> 00:24:18.000
Tuy nhiên, có một số lớp nhất định trong AppKit như NSColor và NSShadow có thể được truy cập an toàn bên ngoài chuỗi chính.

00:24:18.000 --> 00:24:28.000
Trong macOS Sonoma, các lớp này phù hợp với giao thức Sendable, điều này chỉ ra rằng chúng có thể được chuyển tự do qua các ranh giới diễn viên.

00:24:28.000 --> 00:24:34.000
Transferable là một giao thức Swift để mô tả cách các đối tượng có thể được tuần tự hóa và hủy nối tiếp.

00:24:34.000 --> 00:24:39.000
Điều này cung cấp các tính năng như Kéo và Thả và Chia sẻ trong SwiftUI.

00:24:39.000 --> 00:24:46.000
Trong macOS Sonoma NSImage, NSColor và NSSound phù hợp với giao thức Transferable.

00:24:46.000 --> 00:24:53.000
Điều này giúp các ứng dụng AppKit dễ dàng áp dụng các tính năng như Kéo và Thả hoặc Chia sẻ trong Chế độ xem SwiftUI.

00:24:53.000 --> 00:25:00.000
Trong macOS Ventura 13.3, chúng tôi đã giới thiệu một trình bao bọc thuộc tính mới cho NSViewController, ViewLoading.

00:25:00.000 --> 00:25:04.000
Sử dụng ViewLoading trên các thuộc tính được khởi tạo trong loadView.

00:25:04.000 --> 00:25:11.000
Nếu các thuộc tính này trước đây là tùy chọn, bạn có thể xóa tùy chọn và bất kỳ kiểm tra liên quan nào.

00:25:11.000 --> 00:25:16.000
Bộ điều khiển chế độ xem sẽ đảm bảo rằng thuộc tính được khởi tạo bằng cách gọi loadViewIfNeeded.

00:25:16.000 --> 00:25:23.000
Một trình bao bọc tài sản tương tự, WindowLoading, cũng có sẵn cho các tài sản trên NSWindowController.

00:25:23.000 --> 00:25:29.000
Với Xcode 15, giờ đây bạn có thể sử dụng Bản xem trước để hiển thị chế độ xem AppKit và bộ điều khiển chế độ xem của mình.

00:25:29.000 --> 00:25:35.000
Sử dụng macro Xem trước mới, cung cấp tên và trả lại chế độ xem hoặc bộ điều khiển chế độ xem của bạn.

00:25:35.000 --> 00:25:39.000
Bản xem trước sẽ luôn được cập nhật khi bạn thực hiện các thay đổi đối với mã của mình.

00:25:39.000 --> 00:25:47.000
Xem video "Xây dựng giao diện người dùng có lập trình với Bản xem trước Xcode" để biết thêm thông tin.

00:25:47.000 --> 00:25:54.000
NSHostingView và NSHostingController là một cách tuyệt vời để dần dần áp dụng SwiftUI vào ứng dụng AppKit của bạn.

00:25:54.000 --> 00:26:00.000
Trong macOS Sonoma, có một số tính năng mới cho phép bạn áp dụng SwiftUI ở nhiều nơi hơn.

00:26:00.000 --> 00:26:05.000
Các công cụ sửa đổi SwiftUI như thanh công cụ và tiêu đề điều hướng hiện hoạt động trên NSWindows.

00:26:05.000 --> 00:26:13.000
Nếu hostingView là contentView của cửa sổ, SwiftUI sẽ tự động kết nối tất cả các công cụ sửa đổi cảnh có sẵn với NSWindow của bạn.

00:26:13.000 --> 00:26:20.000
Để kiểm soát nhiều hơn, có một thuộc tính mới trên NSHostingView và NSHostingController, sceneBridgingOptions.

00:26:20.000 --> 00:26:27.000
Sử dụng điều này, bạn có thể nêu rõ những thuộc tính nào nên được bắc cầu từ chế độ xem SwiftUI của bạn đến NSWindow.

00:26:27.000 --> 00:26:31.000
Đó chỉ là một số tính năng mới cho AppKit trong macOS Sonoma.

00:26:31.000 --> 00:26:32.000
Tiếp theo là gì?

00:26:32.000 --> 00:26:42.000
Đầu tiên, biên dịch các ứng dụng của bạn bằng cách sử dụng macOS Sonoma SDK và kiểm tra nó để đảm bảo rằng những thay đổi đối với việc cắt và kích hoạt không gây ra bất kỳ tác dụng phụ không mong muốn nào.

00:26:42.000 --> 00:26:50.000
Tiếp theo, áp dụng API điều khiển mới, như trình kiểm tra chiều cao đầy đủ mới và API tùy chỉnh cột bảng mới.

00:26:50.000 --> 00:26:55.000
Cập nhật thiết kế ứng dụng của bạn để tận dụng các hiệu ứng biểu tượng trong macOS Sonoma.

00:26:55.000 --> 00:27:05.000
Và cuối cùng, sử dụng các bổ sung AppKit tập trung vào Swift mới, như Transferable và cải tiến cho NSHostingView, để áp dụng SwiftUI ở nhiều nơi hơn trong ứng dụng của bạn.

00:27:05.000 --> 00:27:07.000
Cảm ơn rất nhiều vì đã xem.

00:27:07.000 --> 00:27:10.000
Chúng tôi hy vọng bạn thích tất cả các tính năng mới của macOS Sonoma!

00:27:10.000 --> 23:59:59.000
♪ ♪

