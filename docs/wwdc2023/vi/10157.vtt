WEBVTT

00:00:01.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:14.000
Người: Xin chào, và chào mừng bạn đến với Wind theo cách của bạn thông qua các hình ảnh động nâng cao trong SwiftUI.

00:00:14.000 --> 00:00:18.000
Tôi là Tim, một thành viên của nhóm SwiftUI.

00:00:18.000 --> 00:00:29.000
SwiftUI đi kèm với một bộ công cụ hoạt hình mạnh mẽ giúp ứng dụng của bạn tỏa sáng, với các hình ảnh động có thể ngắt, dựa trên vật lý cho chuyển động đáng tin cậy và được tích hợp sâu trong toàn bộ khuôn khổ.

00:00:29.000 --> 00:00:35.000
Hôm nay chúng ta sẽ nói về một số công cụ mới thú vị cho phép bạn đưa hoạt ảnh trong ứng dụng của mình lên một tầm cao mới.

00:00:35.000 --> 00:00:42.000
Trước khi chúng ta bắt đầu, hãy xem lại nhanh các công cụ hoạt hình mà bạn đã biết trong SwiftUI.

00:00:42.000 --> 00:00:47.000
Bạn có thể đã thấy ứng dụng này cho phép bạn bình chọn cho loại thú cưng yêu thích của mình trong các phiên khác.

00:00:47.000 --> 00:00:53.000
Để đơn giản hóa bản demo này, tôi đã tiếp tục và loại bỏ tất cả các tùy chọn khác, bởi vì mèo rõ ràng là lựa chọn tốt nhất.

00:00:53.000 --> 00:01:02.000
Thêm hoạt ảnh vào ứng dụng của bạn dễ dàng như sử dụng "withAnimation" hoặc thêm công cụ sửa đổi "hoạt hình", mang lại cho bạn hành vi tuyệt vời ngay lập tức.

00:01:02.000 --> 00:01:10.000
Sau khi trạng thái ứng dụng của bạn thay đổi, SwiftUI áp dụng các hình ảnh động nội suy từ trạng thái trước đó sang trạng thái mới.

00:01:10.000 --> 00:01:20.000
Nhưng với hoạt hình, cũng như với cuộc sống, đôi khi những trải nghiệm bổ ích nhất được tìm thấy khi bạn không quá tập trung vào nơi bạn đến hoặc nơi bạn sẽ đến.

00:01:20.000 --> 00:01:25.000
Đôi khi bạn phải thoát khỏi con đường bị đánh đập và tập trung vào chính cuộc hành trình để tạo ra điều gì đó đặc biệt.

00:01:25.000 --> 00:01:29.000
Và một số hình ảnh động không chỉ đơn giản là hoạt hình từ trạng thái trước đó sang trạng thái mới.

00:01:29.000 --> 00:01:36.000
Hôm nay, tôi sẽ nói về một số công cụ mới mạnh mẽ để xây dựng các hình ảnh động phức tạp, nhiều bước.

00:01:36.000 --> 00:01:42.000
Thay vì tạo hoạt ảnh giữa hai trạng thái, những hình ảnh động này có thể xác định nhiều bước xảy ra theo trình tự.

00:01:42.000 --> 00:01:51.000
Và chúng đặc biệt tuyệt vời trong hai tình huống: hoạt ảnh lặp lại, vòng lặp liên tục trong khi chế độ xem có thể nhìn thấy...

00:01:51.000 --> 00:01:56.000
Và các hình ảnh động do sự kiện điều khiển, chẳng hạn như chế độ xem xung khi một sự kiện xảy ra.

00:01:56.000 --> 00:02:02.000
Trong buổi nói chuyện này, tôi sẽ giới thiệu một họ API mới giúp các hình ảnh động như thế này thậm chí còn dễ xây dựng hơn.

00:02:02.000 --> 00:02:11.000
Tôi sẽ bắt đầu bằng cách giới thiệu cho bạn các giai đoạn hoạt hình, cho phép SwiftUI tự động chuyển qua một tập hợp các trạng thái được lên kế hoạch trước tạo nên hoạt ảnh của bạn.

00:02:11.000 --> 00:02:16.000
Tiếp theo, tôi sẽ trình bày cách đưa hình ảnh động đi xa hơn nữa với các khung hình chính.

00:02:16.000 --> 00:02:21.000
Và cuối cùng, tôi sẽ chỉ ra một số mẹo và thủ thuật nâng cao để tận dụng tối đa API này.

00:02:21.000 --> 00:02:25.000
Tôi nghĩ chúng ta đã sẵn sàng để đi. Hãy nhảy ngay vào.

00:02:25.000 --> 00:02:29.000
Khi tôi không viết Swift, tôi thích chạy đường mòn.

00:02:29.000 --> 00:02:31.000
Các cuộc đua đường mòn có thể rất dài.

00:02:31.000 --> 00:02:41.000
Ultramarathons có thể mất cả ngày, hoặc thậm chí nhiều ngày để hoàn thành, vì vậy tôi đã xây dựng một ứng dụng để lên kế hoạch cho các sự kiện sắp tới và giúp tôi nhớ các chi tiết quan trọng trong quá trình chạy.

00:02:41.000 --> 00:02:44.000
Dinh dưỡng cực kỳ quan trọng khi bạn đang trên đường mòn.

00:02:44.000 --> 00:02:49.000
Thật không may, có thể dễ dàng quên ăn muộn trong một cuộc đua khi kiệt sức bắt đầu.

00:02:49.000 --> 00:02:53.000
Tôi đã thêm một tính năng vào ứng dụng của mình để nhắc nhở tôi ăn vào đúng thời điểm.

00:02:53.000 --> 00:02:58.000
Ở đây, lời nhắc ở cuối màn hình cho tôi biết rằng tôi đã quá hạn cho một bữa ăn.

00:02:58.000 --> 00:03:00.000
Nhưng có một vấn đề.

00:03:00.000 --> 00:03:05.000
Sau đó trong một cuộc đua, tôi có thể mệt mỏi đến mức tôi có thể bỏ lỡ một chỉ báo tinh tế như thế này.

00:03:05.000 --> 00:03:11.000
Tôi thực sự không muốn vô tình bỏ bữa, vì vậy tôi sẽ thêm một số chuyển động để làm cho lời nhắc này nổi bật.

00:03:11.000 --> 00:03:13.000
Hãy tập trung vào một góc nhìn này.

00:03:13.000 --> 00:03:18.000
Chúng tôi muốn tạo cho nó một hiệu ứng nổi bật hoạt hình để làm cho nó hiển thị rõ hơn.

00:03:18.000 --> 00:03:23.000
Để làm cho chế độ xem này hoạt hình, chúng tôi sẽ áp dụng công cụ sửa đổi ".phaseAnimator".

00:03:23.000 --> 00:03:31.000
Khi bạn sử dụng công cụ sửa đổi hoạt hình pha, bạn cung cấp một chuỗi các trạng thái xác định các bước riêng lẻ trong hoạt ảnh nhiều phần.

00:03:31.000 --> 00:03:35.000
SwiftUI sau đó tự động tạo hiệu ứng động giữa các trạng thái này.

00:03:35.000 --> 00:03:42.000
Trong trường hợp này, chúng ta sẽ chỉ tạo hiệu ứng động giữa hai trạng thái: được tô sáng và không được tô sáng, vì vậy chúng ta có thể chỉ cần sử dụng các giá trị boolean.

00:03:42.000 --> 00:03:47.000
Tiếp theo, chúng tôi sẽ áp dụng một số công cụ sửa đổi để thay đổi giao diện của chế độ xem tùy thuộc vào giai đoạn hiện tại.

00:03:47.000 --> 00:03:54.000
Chúng ta sẽ bắt đầu với một công cụ sửa đổi độ mờ: chúng ta sẽ làm cho chế độ xem hoàn toàn mờ đục khi được tô sáng và 50% trong suốt nếu không.

00:03:54.000 --> 00:03:57.000
Và ngay lập tức, khung cảnh bắt đầu hoạt hình.

00:03:57.000 --> 00:04:01.000
Hãy nói về những gì SwiftUI đang làm thay mặt bạn.

00:04:01.000 --> 00:04:08.000
Theo quan điểm của chúng tôi, chúng tôi đã cung cấp hai giai đoạn cho công cụ sửa đổi hoạt hình pha: sai và đúng.

00:04:08.000 --> 00:04:14.000
Khi chế độ xem xuất hiện lần đầu tiên, giai đoạn đầu tiên đang hoạt động, khiến chế độ xem trong suốt 50%.

00:04:14.000 --> 00:04:21.000
SwiftUI sau đó ngay lập tức bắt đầu quá trình chuyển đổi hoạt hình sang giai đoạn tiếp theo, nơi chế độ xem hoàn toàn mờ đục.

00:04:21.000 --> 00:04:25.000
Sau đó, khi hoạt hình đó kết thúc, SwiftUI lại tiến bộ.

00:04:25.000 --> 00:04:29.000
Chúng tôi chỉ có hai giai đoạn, vì vậy chúng tôi lặp lại từ đầu.

00:04:29.000 --> 00:04:33.000
Điều này khiến hoạt ảnh của chúng tôi quay vòng giữa hai trạng thái.

00:04:33.000 --> 00:04:43.000
Tất nhiên, bạn cũng có thể xác định các hình ảnh động bao gồm nhiều hơn hai giai đoạn và bất kỳ số lượng công cụ sửa đổi chế độ xem bổ sung nào mà tôi sẽ trình bày sau.

00:04:43.000 --> 00:04:46.000
Bây giờ trong khi chế độ xem đang hoạt hình, hiệu ứng thực sự tinh tế.

00:04:46.000 --> 00:04:51.000
Thay vì thay đổi độ mờ đục, hãy thử thay đổi phong cách tiền cảnh.

00:04:51.000 --> 00:04:56.000
Chúng tôi sẽ sử dụng màu đỏ khi được đánh dấu, và nếu không thì quay trở lại phong cách tiền cảnh chính.

00:04:56.000 --> 00:05:01.000
Và điều đó dễ thấy hơn nhiều. Tuy nhiên, các hình ảnh động hơi đột ngột.

00:05:01.000 --> 00:05:04.000
Theo mặc định, SwiftUI sử dụng hoạt ảnh mùa xuân.

00:05:04.000 --> 00:05:11.000
Và trong khi lò xo rất tuyệt vời để xử lý các thay đổi trạng thái động, trong trường hợp này chúng tôi muốn một hình ảnh động mượt mà hơn, nhất quán hơn.

00:05:11.000 --> 00:05:15.000
Chúng ta có thể thay đổi hình ảnh động bằng cách thêm phần đóng "hoạt hình" theo sau.

00:05:15.000 --> 00:05:21.000
Giai đoạn đang được hoạt hình được chuyển vào, trong trường hợp chúng tôi muốn sử dụng một hoạt hình khác nhau cho mỗi giai đoạn.

00:05:21.000 --> 00:05:28.000
Nhưng trong trường hợp này, tôi luôn muốn sử dụng cùng một hình ảnh động dễ dàng với thời lượng tùy chỉnh, để làm chậm mọi thứ.

00:05:28.000 --> 00:05:37.000
Bây giờ, bạn thường sẽ không sử dụng một hình ảnh động có thời lượng đầy đủ một giây để thay đổi trạng thái tương tác bởi vì bạn sẽ không muốn khiến mọi người đợi một hình ảnh động kết thúc.

00:05:37.000 --> 00:05:45.000
Nhưng trong trường hợp này, chúng tôi đang xây dựng một hiệu ứng môi trường xung quanh, vì vậy mọi thứ có thể di chuyển chậm hơn một chút, giống như tốc độ của tôi nếu tôi bỏ lỡ bữa ăn đó.

00:05:45.000 --> 00:05:54.000
Bây giờ chúng ta đã giải quyết được vấn đề cấp bách về dinh dưỡng giữa cuộc đua, hãy xem xét thêm một cách để sử dụng các giai đoạn hoạt hình: hoạt ảnh động được kích hoạt bởi các sự kiện.

00:05:54.000 --> 00:05:59.000
Tôi đã làm việc trên ứng dụng của mình được một thời gian và tôi đã thêm khả năng xem bạn bè của tôi đã chạy cuộc đua nào.

00:05:59.000 --> 00:06:01.000
Biểu tượng cảm xúc cho thấy phản ứng do những người khác để lại.

00:06:01.000 --> 00:06:05.000
Mọi vận động viên đôi khi đều tự hỏi: tại sao tôi làm điều này?

00:06:05.000 --> 00:06:08.000
Tại sao tôi lại đăng ký để chạy nhiều dặm như vậy?

00:06:08.000 --> 00:06:15.000
Và điều tối thiểu mà ứng dụng của chúng tôi có thể làm là đáp ứng nhu cầu xác thực bên ngoài bằng cách thêm một số hứng thú khi người khác thích một cuộc đua.

00:06:15.000 --> 00:06:20.000
Chúng tôi sẽ thêm một hình ảnh động phát mỗi khi ai đó thêm phản ứng.

00:06:20.000 --> 00:06:24.000
Điều đầu tiên chúng tôi sẽ làm là xác định các giai đoạn hoạt hình của chúng tôi.

00:06:24.000 --> 00:06:30.000
Không giống như trong ví dụ trước chỉ đơn giản là xen kẽ giữa hai trạng thái, chúng tôi muốn một hình ảnh động phức tạp hơn.

00:06:30.000 --> 00:06:35.000
Enum là một cách tuyệt vời để xác định danh sách các bước cho hoạt ảnh.

00:06:35.000 --> 00:06:42.000
Chúng tôi đã thêm ba trường hợp: một trường hợp cho sự xuất hiện ban đầu, sau đó là các trường hợp để di chuyển chế độ xem lên và tăng quy mô chế độ xem.

00:06:42.000 --> 00:06:49.000
Để đơn giản hóa nội dung chế độ xem của chúng tôi, chúng tôi sẽ thêm các thuộc tính được tính toán vào liệt kê này để xác định các hiệu ứng khác nhau mà chúng tôi sẽ áp dụng.

00:06:49.000 --> 00:06:56.000
Tôi muốn chế độ xem nhảy lên trong quá trình hoạt hình, vì vậy tôi đã thêm một thuộc tính bù dọc được tính toán.

00:06:56.000 --> 00:07:00.000
Tôi chuyển qua liệt kê để trả về độ lệch bên phải cho từng trường hợp.

00:07:00.000 --> 00:07:07.000
Tương tự như vậy, tôi đã thêm hai thuộc tính được tính toán bổ sung để xác định tỷ lệ và kiểu tiền cảnh của chế độ xem.

00:07:07.000 --> 00:07:13.000
Tôi sẽ không hiển thị các triển khai ở đây, nhưng chúng cũng sử dụng câu lệnh chuyển đổi, giống như thuộc tính bù dọc.

00:07:13.000 --> 00:07:17.000
Bây giờ, hãy quay lại chế độ xem của chúng tôi và thêm hình ảnh động.

00:07:17.000 --> 00:07:22.000
Chúng tôi thêm công cụ sửa đổi phaseAnimator, nhưng lần này, chúng tôi cho nó một giá trị "kích hoạt".

00:07:22.000 --> 00:07:28.000
Khi chúng tôi cung cấp cho công cụ sửa đổi hoạt hình pha một giá trị kích hoạt, nó sẽ quan sát giá trị mà bạn chỉ định cho các thay đổi.

00:07:28.000 --> 00:07:33.000
Và khi một sự thay đổi xảy ra, nó bắt đầu hoạt hình thông qua các giai đoạn mà bạn chỉ định.

00:07:33.000 --> 00:07:38.000
Sử dụng các thuộc tính được tính toán mà chúng tôi đã xác định trên loại pha, chúng tôi áp dụng các công cụ sửa đổi cho chế độ xem.

00:07:38.000 --> 00:07:41.000
Và hoạt hình này về mặt kỹ thuật làm điều đúng đắn, nhưng nó không cảm thấy tuyệt vời.

00:07:41.000 --> 00:07:43.000
Nó hơi chậm chạp.

00:07:43.000 --> 00:07:50.000
Chúng tôi sẽ tùy chỉnh hình ảnh động cho mỗi quá trình chuyển đổi để có được hiệu ứng mà chúng tôi muốn, bao gồm một vài hình ảnh động mùa xuân khác nhau.

00:07:50.000 --> 00:07:52.000
Và cái này trông đẹp hơn nhiều!

00:07:52.000 --> 00:07:56.000
Nhưng nếu chúng ta muốn đưa hoạt hình này đi xa hơn nữa thì sao?

00:07:56.000 --> 00:08:08.000
Khi ai đó đã hoàn thành 50 hoặc 100 dặm trên đường mòn, chúng tôi muốn cung cấp cho họ một hình ảnh động không còn nghi ngờ gì nữa rằng tất cả những dặm đó đều đáng giá khi họ nhận được một số danh tiếng xứng đáng.

00:08:08.000 --> 00:08:13.000
Khi bạn cần kiểm soát nhiều hơn, có một công cụ mạnh mẽ khác: khung hình chính.

00:08:13.000 --> 00:08:21.000
Tiếp theo, tôi sẽ chỉ cho bạn cách sử dụng các khung hình chính để xác định các hình ảnh động phức tạp, phối hợp với toàn quyền kiểm soát thời gian và chuyển động.

00:08:21.000 --> 00:08:26.000
Đầu tiên, hãy nói về việc các khung hình chính khác với các giai đoạn mà chúng ta đã sử dụng cho đến nay như thế nào.

00:08:26.000 --> 00:08:30.000
Các giai đoạn xác định các trạng thái rời rạc được cung cấp cho chế độ xem của bạn từng trạng thái một.

00:08:30.000 --> 00:08:41.000
Và SwiftUI hoạt hình giữa các trạng thái đó, sử dụng các loại hoạt hình giống nhau mà bạn đã biết và điều này hoạt động thực sự tốt đối với các hình ảnh động có thể được mô hình hóa dưới dạng các trạng thái rời rạc.

00:08:41.000 --> 00:08:46.000
Khi quá trình chuyển đổi trạng thái xảy ra, tất cả các thuộc tính đều hoạt hình cùng một lúc.

00:08:46.000 --> 00:08:50.000
Và sau đó, khi hoạt ảnh đó kết thúc, SwiftUI sẽ chuyển sang trạng thái tiếp theo.

00:08:50.000 --> 00:08:54.000
Và điều này tiếp tục trên tất cả các giai đoạn của hoạt hình.

00:08:54.000 --> 00:08:57.000
Nhưng nếu chúng ta muốn tạo hiệu ứng động độc lập cho từng tài sản thì sao?

00:08:57.000 --> 00:09:00.000
Đó là nơi các khung hình chính xuất hiện.

00:09:00.000 --> 00:09:04.000
Khung hình chính cho phép bạn xác định các giá trị tại các thời điểm cụ thể trong một hình ảnh động.

00:09:04.000 --> 00:09:08.000
Để chứng minh, tôi sẽ tạo hiệu ứng động cho chế độ xem này, bắt đầu bằng hiệu ứng xoay.

00:09:08.000 --> 00:09:14.000
Các dấu chấm ở đây biểu thị các khung hình chính: các góc để sử dụng tại mỗi điểm trong quá trình hoạt hình.

00:09:14.000 --> 00:09:23.000
Khi hoạt ảnh phát lại, SwiftUI nội suy các giá trị ở giữa các khung hình chính này, sau đó chúng ta có thể sử dụng để áp dụng các công cụ sửa đổi cho chế độ xem.

00:09:23.000 --> 00:09:31.000
Và các khung hình chính cho phép bạn tạo hiệu ứng động độc lập nhiều hiệu ứng cùng một lúc bằng cách xác định các bản nhạc riêng biệt, mỗi bản nhạc có thời gian riêng.

00:09:31.000 --> 00:09:36.000
Điều này thực sự mạnh mẽ, bởi vì bạn có thể sử dụng khung hình chính để điều khiển bất kỳ công cụ sửa đổi nào trong SwiftUI.

00:09:36.000 --> 00:09:43.000
Trong ví dụ này, chúng tôi đang sử dụng khung hình chính để điều khiển một số bản nhạc khác, bao gồm kéo dài dọc, tỷ lệ và dịch.

00:09:43.000 --> 00:09:47.000
Hãy quay lại quan điểm của chúng ta và xem điều này trông như thế nào trong mã.

00:09:47.000 --> 00:09:55.000
Tôi đã có ý tưởng về hình ảnh động mà tôi muốn xây dựng, vì vậy bước đầu tiên của tôi là xác định các thuộc tính sẽ điều khiển hoạt ảnh.

00:09:55.000 --> 00:10:02.000
Để làm điều này, tôi sẽ tạo một cấu trúc mới chứa tất cả các thuộc tính khác nhau sẽ được hoạt hình độc lập.

00:10:02.000 --> 00:10:06.000
Các khung hình chính có thể tạo hiệu ứng động cho bất kỳ giá trị nào phù hợp với giao thức "Animatable".

00:10:06.000 --> 00:10:11.000
Lưu ý rằng một số thuộc tính sử dụng "Double", hiện phù hợp với "Animatable".

00:10:11.000 --> 00:10:19.000
Không giống như các giai đoạn, trong đó bạn mô hình hóa các trạng thái riêng biệt, rời rạc, các khung hình chính tạo ra các giá trị nội suy của loại mà bạn chỉ định.

00:10:19.000 --> 00:10:27.000
Trong khi một hình ảnh động đang được tiến hành, SwiftUI sẽ cung cấp cho bạn một giá trị của loại này trên mọi khung hình để bạn có thể cập nhật chế độ xem.

00:10:27.000 --> 00:10:30.000
Tiếp theo, chúng tôi thêm công cụ sửa đổi keyframeAnimator.

00:10:30.000 --> 00:10:37.000
Công cụ sửa đổi này tương tự như trình làm phim hoạt hình pha mà chúng tôi đã sử dụng trước đó, nhưng chấp nhận các khung hình chính.

00:10:37.000 --> 00:10:42.000
Lưu ý rằng chúng tôi cung cấp một ví dụ về cấu trúc của chúng tôi để sử dụng làm giá trị ban đầu.

00:10:42.000 --> 00:10:47.000
Các khung hình chính mà chúng tôi xác định sẽ áp dụng hoạt ảnh lên giá trị này.

00:10:47.000 --> 00:10:52.000
Tiếp theo, chúng tôi sẽ áp dụng các công cụ sửa đổi cho chế độ xem của mình cho từng thuộc tính trên cấu trúc.

00:10:52.000 --> 00:10:55.000
Và cuối cùng, chúng ta sẽ bắt đầu xác định các khung hình chính.

00:10:55.000 --> 00:11:01.000
Như tôi đã đề cập, các khung hình chính cho phép bạn xây dựng các hình ảnh động tinh vi với các khung hình chính khác nhau cho các thuộc tính khác nhau.

00:11:01.000 --> 00:11:05.000
Để thực hiện điều này, các khung hình chính được sắp xếp thành các bản nhạc.

00:11:05.000 --> 00:11:12.000
Mỗi bản nhạc kiểm soát một thuộc tính khác nhau thuộc loại mà bạn đang tạo hoạt ảnh, được chỉ định bởi đường dẫn chính mà bạn cung cấp khi tạo bản nhạc.

00:11:12.000 --> 00:11:17.000
Ở đây, chúng tôi đang thêm các khung hình chính cho thuộc tính tỷ lệ.

00:11:17.000 --> 00:11:23.000
Đầu tiên chúng tôi thêm một khung hình chính tuyến tính, lặp lại giá trị tỷ lệ ban đầu và giữ nó trong 0,36 giây.

00:11:23.000 --> 00:11:33.000
Và nếu bạn đang tự hỏi làm thế nào tôi ổn định ở mức 0,36, tôi đã tìm thấy khoảng thời gian đó bằng cách thử các giá trị khác nhau để thay đổi cảm giác của hình ảnh động và đó là một điểm quan trọng về khung hình chính.

00:11:33.000 --> 00:11:37.000
Tạo một hình ảnh động phù hợp với ứng dụng của bạn có thể cần một số thử nghiệm.

00:11:37.000 --> 00:11:41.000
Xem trước trong Xcode có thể là một cách tuyệt vời để tinh chỉnh hoạt ảnh của bạn.

00:11:41.000 --> 00:11:44.000
Tiếp theo, chúng tôi thêm một "SpringKeyframe."

00:11:44.000 --> 00:11:48.000
Điều này sử dụng chức năng lò xo để kéo giá trị về phía mục tiêu.

00:11:48.000 --> 00:11:50.000
Và chúng tôi đã chỉ định một khoảng thời gian.

00:11:50.000 --> 00:11:56.000
Đối với khung hình chính lò xo có thời lượng đã đặt, điều này có nghĩa là hàm lò xo sẽ chỉ tạo hiệu ứng động cho giá trị trong khoảng thời gian đó.

00:11:56.000 --> 00:12:00.000
Sau đó, phép nội suy sẽ bắt đầu đến khung hình chính tiếp theo.

00:12:00.000 --> 00:12:06.000
Cuối cùng, tôi sẽ thêm một khung hình chính mùa xuân khác làm sinh động thang đo trở lại 1.0.

00:12:06.000 --> 00:12:10.000
Các loại khung hình chính khác nhau kiểm soát cách các giá trị được nội suy.

00:12:10.000 --> 00:12:14.000
Được rồi, chúng ta đã thấy LinearKeyframe và SpringKeyframe.

00:12:14.000 --> 00:12:17.000
Thực tế có bốn loại khung hình chính khác nhau.

00:12:17.000 --> 00:12:25.000
Tôi sẽ giải thích chúng khác nhau như thế nào: LinearKeyframe nội suy tuyến tính trong không gian vectơ so với khung hình chính trước đó.

00:12:25.000 --> 00:12:33.000
SpringKeyframe, như tên gọi của nó, sử dụng hàm lò xo để nội suy với giá trị mục tiêu từ khung hình chính trước đó.

00:12:33.000 --> 00:12:39.000
CubicKeyframe sử dụng một đường cong Bézier hình khối để nội suy giữa các khung hình chính.

00:12:39.000 --> 00:12:46.000
Nếu bạn kết hợp nhiều khung hình chính bậc ba theo trình tự, đường cong kết quả tương đương với spline Catmull-Rom.

00:12:46.000 --> 00:12:52.000
Và cuối cùng, MoveKeyframe ngay lập tức nhảy đến một giá trị mà không cần nội suy.

00:12:52.000 --> 00:12:59.000
Mỗi loại khung hình chính hỗ trợ tùy chỉnh để cung cấp cho bạn toàn quyền kiểm soát và bạn có thể kết hợp các loại khung hình chính khác nhau trong một hình ảnh động.

00:12:59.000 --> 00:13:06.000
SwiftUI duy trì vận tốc giữa các khung hình chính để đảm bảo hoạt ảnh của bạn vẫn liên tục.

00:13:06.000 --> 00:13:12.000
Quay trở lại quan điểm của chúng tôi, chúng tôi đã sẵn sàng để thêm bản nhạc tiếp theo.

00:13:12.000 --> 00:13:17.000
Ở đây, chúng tôi đã sử dụng các khung hình chính tuyến tính và lò xo để tạo hiệu ứng động cho bản dịch dọc.

00:13:17.000 --> 00:13:21.000
Ngay trước khi tầm nhìn nhảy lên, nó kéo lại trong dự đoán.

00:13:21.000 --> 00:13:26.000
Chúng tôi đã mô hình hóa điều đó với một khung hình chính lò xo kéo tầm nhìn xuống một thời gian ngắn trước khi nó di chuyển lên.

00:13:26.000 --> 00:13:32.000
Điều này có vẻ tốt, nhưng chúng tôi vẫn có thêm hai thuộc tính để tạo hiệu ứng động: kéo dài theo chiều dọc và xoay.

00:13:32.000 --> 00:13:37.000
Chúng ta sẽ bắt đầu với sự kéo dài theo chiều dọc, và đối với điều này, chúng ta sẽ sử dụng các khung hình chính hình khối.

00:13:37.000 --> 00:13:45.000
Một lần nữa, điều này có thể mất một số thử nghiệm và sai sót để làm đúng, nhưng đừng ngần ngại thử nghiệm các cách khác nhau để mô hình hóa hoạt ảnh bằng cách sử dụng khung hình chính.

00:13:45.000 --> 00:13:50.000
Bí đao và kéo dài thực sự mang lại cho hình ảnh động này nhiều năng lượng hơn.

00:13:50.000 --> 00:13:53.000
Cuối cùng, chúng tôi cũng sẽ tạo hiệu ứng động cho vòng quay.

00:13:53.000 --> 00:13:55.000
Và điều này trông thật tuyệt.

00:13:55.000 --> 00:13:58.000
Và những đường cong mà chúng ta đã thấy trước đó?

00:13:58.000 --> 00:14:01.000
Đó là một hình ảnh trực quan về hoạt hình mà chúng tôi vừa xây dựng.

00:14:01.000 --> 00:14:04.000
Bạn có thể thêm các bản nhạc bổ sung để áp dụng bất kỳ công cụ sửa đổi SwiftUI nào.

00:14:04.000 --> 00:14:07.000
Tôi đã có rất nhiều niềm vui khi khám phá các kết hợp khác nhau.

00:14:07.000 --> 00:14:11.000
Hãy dành một chút thời gian để xem lại mô hình của các khung hình chính.

00:14:11.000 --> 00:14:13.000
Khung hình chính là những hình ảnh động được xác định trước.

00:14:13.000 --> 00:14:19.000
Điều đó có nghĩa là chúng không thể thay thế cho các hình ảnh động SwiftUI thông thường trong các tình huống mà giao diện người dùng phải linh hoạt và tương tác.

00:14:19.000 --> 00:14:24.000
Thay vào đó, hãy nghĩ về các khung hình chính như các video clip có thể phát được.

00:14:24.000 --> 00:14:27.000
Họ cho bạn rất nhiều quyền kiểm soát, nhưng có một sự đánh đổi.

00:14:27.000 --> 00:14:38.000
Bởi vì bạn chỉ định chính xác cách hoạt ảnh sẽ tiến triển, hoạt ảnh khung hình chính không thể nhắm mục tiêu lại một cách duyên dáng theo cách mà lò xo có thể, vì vậy tốt nhất là tránh thay đổi khung hình chính giữa hoạt hình.

00:14:38.000 --> 00:14:44.000
Các khung hình chính tạo hiệu ứng động cho một giá trị của loại mà bạn xác định, sau đó bạn sử dụng để áp dụng các công cụ sửa đổi cho chế độ xem.

00:14:44.000 --> 00:14:49.000
Bạn có thể sử dụng một rãnh khung hình chính duy nhất để điều khiển một công cụ sửa đổi duy nhất hoặc kết hợp các công cụ sửa đổi khác nhau.

00:14:49.000 --> 00:14:51.000
Tùy thuộc vào bạn.

00:14:51.000 --> 00:15:03.000
Và bởi vì hoạt ảnh xảy ra theo giá trị mà bạn xác định, các bản cập nhật xảy ra trên mọi khung hình, vì vậy bạn nên tránh thực hiện bất kỳ thao tác tốn kém nào trong khi áp dụng hoạt ảnh khung hình chính cho chế độ xem.

00:15:03.000 --> 00:15:07.000
Cuối cùng, tôi sẽ chứng minh cách bạn có thể làm được nhiều hơn với các khung hình chính.

00:15:07.000 --> 00:15:12.000
Ứng dụng của tôi bao gồm một bản đồ cuộc đua, hiển thị tuyến đường mà mỗi chặng đi.

00:15:12.000 --> 00:15:16.000
Tôi muốn thêm một hình ảnh động tự động phóng to và theo dõi khóa học.

00:15:16.000 --> 00:15:22.000
Rất may, MapKit hiện cho phép tôi sử dụng khung hình chính để di chuyển máy ảnh.

00:15:22.000 --> 00:15:25.000
Ở đây, tôi đang sử dụng chế độ xem "Bản đồ" để hiển thị khóa học.

00:15:25.000 --> 00:15:31.000
Quan điểm của tôi đã có một tuyến đường, đó là một mô hình chứa tất cả các tọa độ dọc theo một chặng của cuộc đua.

00:15:31.000 --> 00:15:36.000
Để xây dựng chuyến tham quan của chúng tôi, chúng tôi sẽ thêm một tài sản nhà nước và một nút để thay đổi nó.

00:15:36.000 --> 00:15:40.000
Cuối cùng, chúng tôi sử dụng công cụ sửa đổi "mapCameraKeyframeAnimator" mới.

00:15:40.000 --> 00:15:47.000
Chúng tôi cung cấp cho nó giá trị kích hoạt, sau đó thêm các khung hình chính, giống như chúng tôi đã sử dụng cho biểu tượng trái tim trong ví dụ trước.

00:15:47.000 --> 00:15:52.000
Mỗi khi giá trị kích hoạt thay đổi, bản đồ sẽ sử dụng các khung hình chính này để tạo hiệu ứng động.

00:15:52.000 --> 00:15:57.000
Giá trị cuối cùng của các khung hình chính xác định giá trị máy ảnh được sử dụng ở cuối hoạt ảnh.

00:15:57.000 --> 00:16:02.000
Cuối cùng, chúng tôi nhấn nút, và chuyến tham quan bắt đầu.

00:16:02.000 --> 00:16:09.000
Nếu người dùng thực hiện một cử chỉ trong khi tạo hoạt ảnh, hình ảnh động sẽ bị xóa và người dùng sẽ có toàn quyền kiểm soát máy ảnh.

00:16:09.000 --> 00:16:19.000
Bằng cách tạo hiệu ứng động độc lập cho tọa độ trung tâm, tiêu đề và khoảng cách, chúng tôi có thể tạo hiệu ứng động mượt mà dọc theo khóa học này sau đó thu nhỏ lại để xem toàn cảnh.

00:16:19.000 --> 00:16:26.000
Cuối cùng, tôi muốn chứng minh cách các khung hình chính có thể được đánh giá thủ công để thúc đẩy bất kỳ loại hiệu ứng nào mà bạn có thể nghĩ đến.

00:16:26.000 --> 00:16:29.000
Chúng tôi đã thấy công cụ sửa đổi "keyframeAnimator".

00:16:29.000 --> 00:16:35.000
Bên ngoài công cụ sửa đổi, bạn có thể sử dụng loại "KeyframeTimeline" để chụp một tập hợp các khung hình chính và bản nhạc.

00:16:35.000 --> 00:16:43.000
Bạn khởi tạo loại này với giá trị ban đầu và các bản nhạc khung hình chính xác định hoạt ảnh của bạn, giống như với công cụ sửa đổi chế độ xem.

00:16:43.000 --> 00:16:50.000
KeyframeTimeline cung cấp API cung cấp cho bạn thời lượng, tương đương với thời lượng của bản nhạc dài nhất.

00:16:50.000 --> 00:16:55.000
Và bạn có thể tính toán các giá trị cho bất kỳ lúc nào trong phạm vi của hình ảnh động.

00:16:55.000 --> 00:17:02.000
Điều này giúp dễ dàng hình dung các khung hình chính với Biểu đồ Swift, mà tôi đã sử dụng cho các hình ảnh trực quan hóa đường cong mà tôi đã hiển thị trước đó.

00:17:02.000 --> 00:17:19.000
Điều này cũng có nghĩa là bạn có thể sử dụng các đường cong do khung hình chính xác định theo cách bạn muốn hoặc kết hợp khung hình chính một cách sáng tạo với các API khác, ví dụ: với proxy hình học để xóa các hiệu ứng điều khiển khung hình chính bằng vị trí cuộn hoặc với "TimelineView" để cập nhật dựa trên thời gian.

00:17:19.000 --> 00:17:26.000
Và nếu bạn không chắc chắn khi nào bạn sẽ sử dụng cái này, không sao, đó là một công cụ nâng cao và hầu hết các nhà phát triển sẽ muốn gắn bó với công cụ sửa đổi chế độ xem.

00:17:26.000 --> 00:17:33.000
Nhưng nó ở đây như một khối xây dựng và tôi rất vui khi thấy những cách sáng tạo mà bạn tìm thấy để tích hợp nó vào ứng dụng của mình.

00:17:33.000 --> 00:17:35.000
Điều đó hoàn thành hành trình của chúng tôi.

00:17:35.000 --> 00:17:38.000
Tôi hy vọng bạn hào hứng khi sử dụng dòng API mới này.

00:17:38.000 --> 00:17:42.000
Hãy nhớ rằng: sử dụng các giai đoạn cho các hình ảnh động được xâu chuỗi.

00:17:42.000 --> 00:17:48.000
Họ sử dụng tất cả các loại hoạt hình hiện có mà bạn đã biết, vì vậy bạn có thể bắt đầu và chạy nhanh chóng.

00:17:48.000 --> 00:17:53.000
Sử dụng khung hình chính cho các hình ảnh động phức tạp hơn, nơi bạn cần kiểm soát hoàn toàn.

00:17:53.000 --> 00:17:56.000
Và cuối cùng: hãy vui vẻ khám phá.

00:17:56.000 --> 00:18:02.000
Thế giới hoạt hình thật thú vị, và tôi hy vọng những công cụ mới này sẽ dẫn bạn và ứng dụng của bạn đến một nơi nào đó mới.

00:18:02.000 --> 00:18:04.000
Cảm ơn!

00:18:04.000 --> 23:59:59.000
♪ ♪

