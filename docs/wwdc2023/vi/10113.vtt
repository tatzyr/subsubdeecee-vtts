WEBVTT

00:00:00.000 --> 00:00:04.000
♪ Hip-hop nhạc cụ êm dịu ♪

00:00:04.000 --> 00:00:10.000
♪

00:00:10.000 --> 00:00:13.000
Xin chào, tên tôi là Mark, và tôi là một kỹ sư SwiftUI.

00:00:13.000 --> 00:00:20.000
Tôi rất hân hạnh được mời bạn vào một cuộc hành trình ra khỏi máy bay và vào vũ trụ bằng SwiftUI.

00:00:20.000 --> 00:00:35.000
Để chứng minh cách SwiftUI hoạt động trong một chiều hướng mới và để cho thấy cách SwiftUI và RealityKit hoạt động cùng nhau trong hệ thống để cho phép trải nghiệm đáng kinh ngạc, chúng ta sẽ nói về một số ít API cung cấp năng lượng cho một ứng dụng mẫu mà chúng tôi đã xây dựng có tên là World.

00:00:35.000 --> 00:00:53.000
World thể hiện một số hình thức khác nhau mà các ứng dụng có thể thực hiện trên hệ thống, từ cửa sổ quen thuộc đến khối lượng mới, cho phép trải nghiệm 3D giới hạn đến toàn bộ không gian, cho phép hiển thị nội dung ảo không giới hạn.

00:00:53.000 --> 00:01:15.000
Mặc dù hầu hết các API mà chúng ta sẽ thảo luận trong buổi nói chuyện này cho dù bạn chỉ thêm một chút 3D vào ứng dụng cửa sổ 2D chủ yếu của mình hay tạo trải nghiệm 3D nhập vai tận dụng toàn bộ không gian, chúng tôi sẽ tập trung vào việc sử dụng Volumes làm vùng chứa vì chúng cung cấp một cách tuyệt vời để khám phá lĩnh vực 3

00:01:15.000 --> 00:01:26.000
Để tìm hiểu thêm về các vùng chứa khác cho nội dung SwiftUI, vui lòng tham khảo cuộc nói chuyện "Nâng cao ứng dụng có cửa sổ của bạn cho điện toán không gian" và cuộc nói chuyện "Vượt ra ngoài cửa sổ với SwiftUI".

00:01:26.000 --> 00:01:45.000
Khi chúng tôi đề cập đến những điều cơ bản về khối lượng, chúng tôi sẽ thảo luận về cách bạn có thể tạo và định vị nội dung 3D với chế độ xem và bố cục thể tích, cách tích hợp chế độ xem SwiftUI vào Chế độ xem thực tế mới và cuối cùng là cách kết hợp mọi thứ lại với nhau bằng cử chỉ 3D.

00:01:45.000 --> 00:01:56.000
Nhưng trước khi chúng ta vượt lên chính mình, hãy nói về khối lượng là gì và cách chúng có thể giúp chúng ta thực hiện bước đầu tiên vào lĩnh vực 3D.

00:01:56.000 --> 00:02:00.000
Thế giới sử dụng khối lượng để nhấn mạnh nội dung 3D của nó.

00:02:00.000 --> 00:02:03.000
Cảnh này không có cửa sổ kính chính.

00:02:03.000 --> 00:02:09.000
Thay vào đó, nó đặt nội dung 3D của nó trực tiếp vào cảnh với một bảng điều khiển ở phía trước.

00:02:09.000 --> 00:02:14.000
Nhưng nội dung 3D là ngôi sao của chương trình ở đây.

00:02:14.000 --> 00:02:17.000
Khối lượng cung cấp cho bạn một thùng chứa tỷ lệ cố định.

00:02:17.000 --> 00:02:26.000
Không giống như các cửa sổ tự động chia tỷ lệ dựa trên khoảng cách chúng được đặt từ bạn, khối lượng duy trì cùng kích thước ở bất kỳ khoảng cách nào.

00:02:26.000 --> 00:02:33.000
Khối lượng được căn chỉnh theo chiều ngang và hỗ trợ xem từ mọi góc độ.

00:02:33.000 --> 00:02:43.000
Âm lượng là một cách tuyệt vời để hiển thị nội dung 3D trong ứng dụng của bạn mà không chiếm toàn bộ không gian và việc tạo một nội dung cực kỳ đơn giản.

00:02:43.000 --> 00:02:52.000
Tất cả những gì bạn phải làm là sử dụng kiểu cửa sổ thể tích mới khi tạo một cảnh mới, chẳng hạn như nhóm cửa sổ và bạn sẽ tự động nhận được tất cả các tính năng này.

00:02:52.000 --> 00:02:57.000
Bây giờ chúng ta đã thiết lập khối lượng của mình, hãy lấy một số nội dung bên trong nó.

00:02:57.000 --> 00:03:14.000
Để giúp chúng tôi làm điều đó, RealityKit cung cấp một API mới được gọi là Model3D, một chế độ xem SwiftUI giúp tải các tài sản 3D phong phú, chẳng hạn như USDZ, đồng thời cung cấp các giai đoạn để xử lý các phần khác nhau của vòng đời tải tài sản trở nên đơn giản.

00:03:14.000 --> 00:03:18.000
Hãy nghĩ về Model3D như một đối tác của AsyncImage.

00:03:18.000 --> 00:03:24.000
Nó xử lý tất cả công việc tải hình học phức tạp trong khi vẫn giữ cho ứng dụng của bạn chạy trơn tru.

00:03:24.000 --> 00:03:30.000
Hãy sử dụng Model3D để hiển thị một trong những mô hình khác từ ứng dụng Thế giới, mặt trăng.

00:03:30.000 --> 00:03:38.000
Bây giờ, tôi đã thêm tệp moon USDZ vào dự án của mình và tôi có thể chuyển tên đó cho trình khởi tạo Model3D.

00:03:38.000 --> 00:03:42.000
Bây giờ chúng ta có thể xử lý giai đoạn của mô hình.

00:03:42.000 --> 00:03:44.000
Bây giờ, đây không phải là giai đoạn của mặt trăng.

00:03:44.000 --> 00:03:52.000
Nó thực sự chỉ ra trạng thái tải của tài sản và nó có một vài trạng thái khác nhau mà chúng ta có thể chuyển đổi.

00:03:52.000 --> 00:04:00.000
Trước khi mô hình được tải, tôi có thể hiển thị một số văn bản hoặc một phần giao diện người dùng khác cho người dùng biết nội dung chưa sẵn sàng.

00:04:00.000 --> 00:04:05.000
Tôi sẽ sử dụng chế độ xem tiến độ ở đây.

00:04:05.000 --> 00:04:14.000
Nếu mô hình không tải được, tôi có thể hiển thị thông báo lỗi bằng cách sử dụng mô tả được bản địa hóa từ lỗi.

00:04:14.000 --> 00:04:22.000
Và nếu mô hình thành công, tôi có thể sử dụng nó trong giao diện người dùng của mình.

00:04:22.000 --> 00:04:32.000
Tương tự như hình ảnh, tôi cần sử dụng công cụ sửa đổi kích thước để thông báo cho hệ thống bố cục rằng mô hình có thể được thay đổi kích thước theo không gian có sẵn của nó.

00:04:32.000 --> 00:04:41.000
Và tôi muốn mô hình phù hợp với không gian có sẵn của nó, vì vậy tôi sẽ sử dụng công cụ sửa đổi scaledToFit.

00:04:41.000 --> 00:04:45.000
Bây giờ tôi có một mặt trăng tải không đồng bộ trong ứng dụng của tôi.

00:04:45.000 --> 00:04:49.000
Hãy tiếp tục xây dựng ví dụ này để khám phá thêm chức năng 3D trong SwiftUI.

00:04:49.000 --> 00:04:54.000
Hãy kiểm tra một số mô hình khác xuất hiện trong ứng dụng Thế giới.

00:04:54.000 --> 00:04:57.000
Tôi muốn hiển thị tất cả chúng cùng một lúc trong một loại màn hình.

00:04:57.000 --> 00:05:03.000
Chúng tôi có thể sử dụng lại MoonView mà chúng tôi vừa viết để xử lý việc hiển thị bất kỳ tệp USDZ nào.

00:05:03.000 --> 00:05:07.000
Hãy đổi tên nó.

00:05:07.000 --> 00:05:11.000
Và chuyển tên của tệp USDZ để tải.

00:05:11.000 --> 00:05:14.000
Bây giờ tôi có thể thay thế chuỗi Moon được mã hóa cứng.

00:05:14.000 --> 00:05:19.000
Bây giờ hãy tạo một cấu trúc dữ liệu để biểu diễn một thiên thể.

00:05:19.000 --> 00:05:23.000
Tôi sẽ cho mỗi người một cái tên và một kích cỡ.

00:05:23.000 --> 00:05:30.000
Tôi sẽ liệt kê một vài vật thể khác nhau mà tôi có trong dự án của mình: Trái đất, Mặt trăng và mặt trời.

00:05:30.000 --> 00:05:35.000
Bây giờ tôi có thể hiển thị từng đối tượng trong một HStack với một ForEach.

00:05:35.000 --> 00:05:43.000
Đối với mỗi đối tượng, tôi có thể sử dụng CelestialObjectView mới mà chúng tôi vừa tạo bằng cách sử dụng tên của đối tượng.

00:05:43.000 --> 00:05:53.000
Hãy thay đổi kích thước của từng mô hình bằng cách sử dụng công cụ sửa đổi khung bằng cách sử dụng kích thước đối tượng.

00:05:53.000 --> 00:05:58.000
Các mô hình của chúng tôi trông tuyệt vời từ phía trước, nhưng hãy nhớ rằng chúng tôi đang ở dạng 3D.

00:05:58.000 --> 00:06:07.000
Một sự thay đổi về phối cảnh cho thấy rằng các vật thể của chúng ta được căn chỉnh mặt sau, như thể các hộp giới hạn của chúng phẳng với một mặt phẳng phía sau cả ba chúng.

00:06:07.000 --> 00:06:11.000
Đây là căn chỉnh mặc định cho nội dung 3D trong SwiftUI.

00:06:11.000 --> 00:06:18.000
Nếu chúng ta muốn thay đổi điều đó, chúng ta có thể chỉ định căn chỉnh độ sâu để sử dụng trong công cụ sửa đổi độ sâu khung như vậy.

00:06:18.000 --> 00:06:27.000
Tôi có thể chuyển kích thước của đối tượng để sử dụng cho độ sâu và chỉ định rằng tôi muốn các mô hình mặt trước được căn chỉnh thay vì mặt sau.

00:06:27.000 --> 00:06:34.000
Bây giờ tất cả các góc nhìn đều có mặt trước được căn chỉnh thay thế.

00:06:34.000 --> 00:06:36.000
Bây giờ tôi muốn dán nhãn cho mỗi đối tượng.

00:06:36.000 --> 00:06:41.000
Tôi có thể làm điều đó bằng cách cho mỗi Model3D một lớp phủ.

00:06:41.000 --> 00:06:50.000
Bên trong tôi sẽ tạo một nhãn văn bản với hiệu ứng nền thủy tinh để đảm bảo nó luôn có thể đọc được.

00:06:50.000 --> 00:07:00.000
Tôi cũng sẽ làm cho các nhãn này được căn chỉnh vào cuối mô hình, vì vậy tôi không chặn nội dung.

00:07:00.000 --> 00:07:04.000
Màn hình hiển thị trông tuyệt vời cho đến nay, nhưng nó cảm thấy hơi tĩnh.

00:07:04.000 --> 00:07:09.000
Cuối cùng, hãy khám phá một số bổ sung mới của SwiftUI cho các hiệu ứng hình học.

00:07:09.000 --> 00:07:17.000
Tôi có thể sử dụng TimelineView để tạo hiệu ứng động cho sự thay đổi về thời gian.

00:07:17.000 --> 00:07:22.000
Bây giờ tôi sẽ đưa ra quan điểm của chúng tôi một số vòng quay bằng cách sử dụng Rotation3DEffect mới.

00:07:22.000 --> 00:07:31.000
Tôi sẽ làm một cái và cho nó một góc dựa trên ngày hiện tại với hệ số tỷ lệ.

00:07:31.000 --> 00:07:36.000
Và tôi sẽ để các vật thể quay xung quanh trục y.

00:07:36.000 --> 00:07:40.000
Và cứ như vậy, chúng ta có những đồ vật của mình quay.

00:07:40.000 --> 00:07:45.000
Model3D rất tuyệt vời để tải và hiển thị các nội dung đơn giản trong hệ thống phân cấp chế độ xem của bạn.

00:07:45.000 --> 00:07:56.000
Nhưng đối với các mô hình, cảnh hoặc trải nghiệm 3D liên quan nhiều hơn, RealityView là điểm khởi đầu của SwiftUI để giải phóng sức mạnh của RealityKit trong ứng dụng của bạn.

00:07:56.000 --> 00:08:05.000
Và thực sự, ứng dụng Thế giới sử dụng RealityView để chia nhỏ các hình ảnh trực quan phức tạp hơn của nó bằng cách sử dụng hệ thống RealityKit Entity-Component.

00:08:05.000 --> 00:08:14.000
Điều này cho phép kết xuất các mô hình riêng lẻ, cũng như các hiệu ứng kết xuất nâng cao như ánh sáng và đường dẫn quỹ đạo.

00:08:14.000 --> 00:08:20.000
Nhờ RealityView mới, SwiftUI và RealityKit đi đôi với nhau trên nền tảng.

00:08:20.000 --> 00:08:31.000
Để biết thêm thông tin về RealityView và nhiều tính năng RealityKit mới hơn, vui lòng xem "Xây dựng trải nghiệm không gian với RealityKit" và "Nâng cao ứng dụng điện toán không gian của bạn với RealityKit."

00:08:31.000 --> 00:08:39.000
Hiện tại, hãy nói về cách bạn có thể tận dụng tối đa SwiftUI trong RealityView của mình bằng cách sử dụng API tệp đính kèm mới.

00:08:39.000 --> 00:08:46.000
Tệp đính kèm cho phép bạn ghép nối chế độ xem SwiftUI được gắn thẻ với một thực thể mà bạn có thể sử dụng bên trong Chế độ xem thực tế của mình.

00:08:46.000 --> 00:08:56.000
Tệp đính kèm rất phù hợp để thêm chú thích hoặc chỉnh sửa khả năng chi trả liên quan đến các thực thể cụ thể.

00:08:56.000 --> 00:09:02.000
Nếu bạn đã sử dụng Canvas API trong SwiftUI, các tệp đính kèm có thể sẽ cảm thấy quen thuộc.

00:09:02.000 --> 00:09:07.000
Sự khác biệt chính với tệp đính kèm là chúng là chế độ xem trực tiếp, không chỉ là ảnh chụp nhanh.

00:09:07.000 --> 00:09:13.000
Điều này có nghĩa là họ có thể phản ứng với các thay đổi trạng thái, chạy hoạt ảnh và xử lý các cử chỉ.

00:09:13.000 --> 00:09:22.000
Hãy cùng khám phá các tệp đính kèm bên trong ứng dụng Thế giới bằng cách thêm một số chức năng bổ sung cho phép tôi đặt một số điểm đánh dấu theo dõi các địa điểm yêu thích của tôi trên khắp thế giới.

00:09:22.000 --> 00:09:31.000
Trong chế độ xem Trái đất, tôi đã tạo một số trạng thái theo dõi một mảng một số địa điểm yêu thích của tôi, mỗi địa điểm có tên và vị trí.

00:09:31.000 --> 00:09:36.000
Đối với mỗi nơi, tôi có thể tạo một số văn bản với tên của nó.

00:09:36.000 --> 00:09:41.000
Và tôi có thể tạo cho nó một hiệu ứng nền thủy tinh để nó luôn dễ đọc.

00:09:41.000 --> 00:09:47.000
Và bây giờ tôi sẽ đưa cho nó một thẻ để tôi có thể tham khảo nó sau này trong RealityView của mình.

00:09:47.000 --> 00:09:55.000
Thẻ này có thể là bất kỳ giá trị có thể băm nào, nhưng tôi sẽ sử dụng một mã định danh duy nhất mà tôi đã thêm cho mỗi địa điểm.

00:09:55.000 --> 00:10:01.000
Bây giờ tôi có thể tra cứu một thực thể lưu trữ mỗi chế độ xem tệp đính kèm bằng cách sử dụng thẻ tôi đã chỉ định.

00:10:01.000 --> 00:10:20.000
Tôi có thể thêm thực thể này vào nội dung RealityView của mình.

00:10:20.000 --> 00:10:26.000
Và sau đó tôi có thể sử dụng chức năng lookAt để định vị và định hướng nhãn dọc theo bề mặt quả địa cầu.

00:10:26.000 --> 00:10:39.000
Bây giờ chúng tôi có một vài địa điểm thú vị được xác định chính xác.

00:10:39.000 --> 00:10:43.000
Nhưng chúng ta đừng quá gắn bó với ứng dụng này.

00:10:43.000 --> 00:10:47.000
Tôi có thêm một số ý tưởng về cách chúng ta có thể đưa nó lên cấp độ tiếp theo.

00:10:47.000 --> 00:10:55.000
Vì vậy, bây giờ chúng tôi đã biết cách định vị nội dung 3D và tận dụng tối đa SwiftUI bên trong RealityView bằng cách sử dụng tệp đính kèm.

00:10:55.000 --> 00:10:59.000
Bây giờ hãy nói về cách tương tác với tất cả nội dung này.

00:10:59.000 --> 00:11:07.000
Nền tảng đưa các cử chỉ bạn đã quen thuộc vào chiều không gian thứ ba với sự hỗ trợ cho tay và mắt, cũng như cơ chế bàn di chuột mới.

00:11:07.000 --> 00:11:12.000
Hãy sử dụng những khả năng mới này để mở rộng tiến trình của chúng ta trên ứng dụng Thế giới.

00:11:12.000 --> 00:11:16.000
Chúng tôi có một điều khá tốt với phần mở rộng "Địa điểm yêu thích" của chúng tôi.

00:11:16.000 --> 00:11:21.000
Tuy nhiên, tôi không nghĩ rằng tôi hài lòng với số lượng địa điểm mà chúng tôi đã vạch ra.

00:11:21.000 --> 00:11:26.000
Hãy tạo ra một cách để thêm một số hơn bằng cách sử dụng cử chỉ chạm trên toàn cầu.

00:11:26.000 --> 00:11:32.000
Tuy nhiên, trước khi chúng ta nhảy vào điều đó, hãy nói về cách định cấu hình một thực thể cho đầu vào.

00:11:32.000 --> 00:11:36.000
Giả sử chúng tôi đang cấu hình RealityView với nội dung của mình.

00:11:36.000 --> 00:11:41.000
Ở đây tôi đã thêm một mô hình Trái Đất.

00:11:41.000 --> 00:11:47.000
Một hệ thống phân cấp thực thể cần một InputTargetComponent để nhận đầu vào bên trong RealityView.

00:11:47.000 --> 00:11:56.000
Nếu thành phần được thêm vào một thực thể, tất cả con cháu của thực thể đó cũng có thể nhận được đầu vào trừ khi có quy định khác.

00:11:56.000 --> 00:12:03.000
Trong RealityKit, CollisionComponent được sử dụng để xác định hình dạng của vùng tương tác của một thực thể.

00:12:03.000 --> 00:12:09.000
Hãy sử dụng một hình cầu cho mô hình Trái đất để chúng ta có thể có được một điểm tương tác chính xác trên bề mặt của nó.

00:12:09.000 --> 00:12:15.000
Đây là tất cả những gì chúng ta cần để cho phép thực thể của chúng ta xử lý các cử chỉ SwiftUI bên trong RealityView.

00:12:15.000 --> 00:12:23.000
Tại thời điểm này, tôi có thể thêm SpatialTapGesture vào RealityView của mình.

00:12:23.000 --> 00:12:35.000
Nhưng để làm cho việc sử dụng cử chỉ SwiftUI với nội dung RealityKit của bạn trở nên dễ dàng hơn, chúng tôi đã thêm một công cụ sửa đổi cử chỉ mới có tên targetedToEntity mà tôi có thể sử dụng để nhắm mục tiêu cụ thể vào earthEntity của mình.

00:12:35.000 --> 00:12:46.000
Nếu việc nhấn không xảy ra trên thực thể này hoặc một trong những hậu duệ của nó, cử chỉ sẽ thất bại.

00:12:46.000 --> 00:12:48.000
Bây giờ hãy xử lý giá trị cử chỉ.

00:12:48.000 --> 00:12:59.000
SpatialTapGesture có thuộc tính location3D mới, cho phép chúng tôi có được một điểm nhấn chính xác trên bề mặt địa cầu.

00:12:59.000 --> 00:13:11.000
Vị trí 3D nằm trong không gian tọa độ SwiftUI cục bộ của RealityView tính bằng điểm, không phải mét.

00:13:11.000 --> 00:13:19.000
Để tìm ra nơi chúng tôi muốn đặt nhãn mới của mình, chúng tôi sẽ cần chuyển đổi vị trí thành cảnh của RealityView.

00:13:19.000 --> 00:13:27.000
Công cụ sửa đổi targetedToEntity làm cho điều này cực kỳ dễ dàng bằng cách thêm vào một số trình trợ giúp chuyển đổi không gian tọa độ vào chính giá trị của cử chỉ.

00:13:27.000 --> 00:13:33.000
Chúng ta có thể sử dụng nó để chuyển đổi từ không gian cục bộ SwiftUI sang không gian tọa độ của cảnh.

00:13:33.000 --> 00:13:38.000
Cuối cùng, tôi có thể thêm dữ liệu cho địa điểm mới bằng cách sử dụng vị trí mà chúng tôi vừa tính toán.

00:13:38.000 --> 00:13:59.000
Tôi cũng sẽ mở rộng vị trí chỉ một chút để các nhãn nổi lên trên bề mặt Trái đất một chút.

00:13:59.000 --> 00:14:04.000
Bây giờ chúng ta có một cách để thêm nhiều địa điểm yêu thích hơn vào toàn cầu chỉ với một cú chạm.

00:14:04.000 --> 00:14:09.000
Nhưng bây giờ chúng ta có một vấn đề: chúng ta cần khám phá nhiều địa điểm hơn!

00:14:09.000 --> 00:14:14.000
Để làm điều đó, hãy phóng một vệ tinh có thể giúp chúng ta chọn ra nhiều điểm thú vị hơn trên khắp thế giới.

00:14:14.000 --> 00:14:23.000
Một cách để thêm mô hình vệ tinh vào địa cầu của chúng ta là tải mô hình bằng RealityKit, nhưng hãy sử dụng một số kỹ thuật khác mà chúng ta đã học được.

00:14:23.000 --> 00:14:29.000
Tôi có thể thêm Model3D làm tệp đính kèm.

00:14:29.000 --> 00:14:37.000
Việc chỉ định khung giúp thay đổi kích thước mô hình vệ tinh thành kích thước hợp lý trở nên cực kỳ dễ dàng.

00:14:37.000 --> 00:14:45.000
Tôi cũng sẽ đưa cho mô hình của mình một thẻ để tôi có thể tham khảo nó trong RealityView của mình.

00:14:45.000 --> 00:14:53.000
Cũng giống như với các nhãn, tôi cần thêm mô hình của mình vào RealityView.

00:14:53.000 --> 00:15:01.000
Bây giờ, hãy xác định một cử chỉ trả về một biến đổi 3D sẽ cho phép chúng ta xác định tỷ lệ, chuyển động quay và vị trí của vệ tinh của chúng ta.

00:15:01.000 --> 00:15:13.000
Tôi sẽ bắt đầu với việc kéo bằng cách sử dụng DragGesture.

00:15:13.000 --> 00:15:19.000
Để chuyển đổi từ cử chỉ kéo sang chuyển đổi, tôi sẽ sử dụng bản đồ.

00:15:19.000 --> 00:15:24.000
DragGesture có một số thuộc tính mới để xử lý thao tác trong 3D.

00:15:24.000 --> 00:15:30.000
Chúng ta có thể sử dụng thuộc tính translation3D mới của DragGesture để biết mức độ kéo đã di chuyển kể từ khi nó bắt đầu.

00:15:30.000 --> 00:15:38.000
Bây giờ tôi sẽ tạo ra sự biến đổi.

00:15:38.000 --> 00:15:44.000
Tôi có thể chuyển bản dịch sang trình khởi tạo và trả lại nó từ bản đồ.

00:15:44.000 --> 00:15:52.000
Bây giờ tôi có thể sử dụng cử chỉ thao tác của chúng tôi mà chúng tôi vừa viết để biến đổi vệ tinh của tôi.

00:15:52.000 --> 00:15:57.000
Tôi sẽ sử dụng công cụ sửa đổi cập nhật để theo dõi khi cử chỉ đang hoạt động.

00:15:57.000 --> 00:16:15.000
Tôi có thể sử dụng trạng thái này để thu nhỏ tất cả các nhãn của chúng ta trong quá trình tương tác để chúng không chặn tầm nhìn của chúng ta về Trái đất.

00:16:15.000 --> 00:16:25.000
Điều quan trọng là sử dụng cập nhật để theo dõi bất kỳ trạng thái cử chỉ tạm thời nào mà tôi có vì nó đảm bảo rằng trạng thái cử chỉ của tôi sẽ tự động được đặt lại nếu cử chỉ không thành công.

00:16:25.000 --> 00:16:33.000
Khi giá trị cử chỉ của tôi thay đổi, tôi có thể đặt biến đổi mới của trạng thái và sau đó sử dụng công cụ sửa đổi bù để định vị mô hình vệ tinh.

00:16:33.000 --> 00:16:41.000
Tôi cũng sẽ tạo hiệu ứng động cho các thay đổi đối với biến đổi bằng cách sử dụng hoạt ảnh lò xo, để khi chúng ta buông vệ tinh ra, nó sẽ tạo hiệu ứng động trở lại vị trí ban đầu.

00:16:41.000 --> 00:16:49.000
Bây giờ chúng ta có thể kéo vệ tinh xung quanh.

00:16:49.000 --> 00:16:53.000
Đây là một khởi đầu tuyệt vời, nhưng chúng ta cần xem điều này chi tiết hơn.

00:16:53.000 --> 00:16:57.000
Bây giờ chúng ta đã kết nối mọi thứ, hãy thêm vào một số hành động mở rộng quy mô.

00:16:57.000 --> 00:17:05.000
Đối với điều này, tôi thêm một MagnifyGesture nhận dạng đồng thời với lực kéo.

00:17:05.000 --> 00:17:19.000
Tôi cũng sẽ thêm RotateGesture3D mới, có thể đo vòng quay 3D không bị ràng buộc của bàn tay người dùng.

00:17:19.000 --> 00:17:26.000
Tôi sẽ cắm những giá trị mới này vào biến đổi của chúng tôi, và cuối cùng tôi cần cập nhật vòng quay và quy mô của thực thể.

00:17:26.000 --> 00:17:47.000
Tôi sẽ sử dụng rotation3DEffect và scaleEffect cho việc này.

00:17:47.000 --> 00:17:54.000
Và chúng ta đã có nó!

00:17:54.000 --> 00:17:59.000
Bây giờ chúng ta có thể tự do kéo, chia tỷ lệ và xoay thực thể vệ tinh của mình.

00:17:59.000 --> 00:18:02.000
Vệ tinh của chúng tôi có vẻ như đã sẵn sàng cho chuyến đi.

00:18:02.000 --> 00:18:14.000
Các cử chỉ mà chúng tôi đã thêm hoạt động với tất cả các thiết bị và chế độ đầu vào mà bạn mong đợi, bao gồm tương tác trực tiếp với tay, chụm gián tiếp, bàn di chuột và các tính năng trợ năng.

00:18:14.000 --> 00:18:24.000
Sử dụng các cử chỉ SwiftUI quen thuộc, cùng với công cụ sửa đổi targetedToEntity mới, bạn có thể nhanh chóng xây dựng các tương tác trong các hệ thống phân cấp thực thể phức tạp.

00:18:24.000 --> 00:18:33.000
Bây giờ chúng tôi đã sẵn sàng khám phá hành tinh với vệ tinh của mình, nhưng bây giờ là lúc để bạn khám phá các khả năng 3D mới của SwiftUI trong các ứng dụng của mình.

00:18:33.000 --> 00:18:41.000
Các loại cảnh mới như khối lượng và không gian đầy đủ cho phép bạn xem xét một ứng dụng có thể là gì theo tất cả các cách mới.

00:18:41.000 --> 00:18:55.000
Bố cục mạnh mẽ và hệ thống kết xuất trong SwiftUI đã được mở rộng để làm cho SwiftUI không chỉ là một cách mạnh mẽ để xây dựng ứng dụng trên iOS, macOS, tvOS và watchOS, mà còn trên nền tảng hoàn toàn mới này.

00:18:55.000 --> 00:19:03.000
API tệp đính kèm mới mở ra những cơ hội mới đáng kinh ngạc để tích hợp chế độ xem SwiftUI vào các cảnh 3D.

00:19:03.000 --> 00:19:13.000
Và cuối cùng chúng tôi đã khám phá cách đặt những câu chuyện bạn kể cho mọi người ngay trong lòng bàn tay của họ, sử dụng những cử chỉ quen thuộc và mạnh mẽ trong SwiftUI.

00:19:13.000 --> 00:19:19.000
Nhờ SwiftUI và RealityKit, bạn có một hành trình thú vị phía trước vượt ra ngoài giới hạn của máy bay 2D.

00:19:19.000 --> 00:19:21.000
Và chúng ta chỉ mới bắt đầu.

00:19:21.000 --> 00:19:23.000
Chào mừng đến với nền tảng!

00:19:23.000 --> 23:59:59.000
♪

