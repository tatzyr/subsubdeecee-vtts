WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:14.000
Si: Xin chào, tôi là Si từ nhóm Swift on Server tại Apple.

00:00:14.000 --> 00:00:20.000
Trong video này, tôi sẽ chỉ cho bạn cách Swift OpenAPI Generator có thể giúp bạn làm việc với các API máy chủ.

00:00:20.000 --> 00:00:29.000
Cho dù mở rộng ứng dụng iOS hay viết máy chủ phụ trợ trong Swift, trình cắm gói Swift mới này có thể hợp lý hóa quy trình làm việc của bạn và đơn giản hóa cơ sở mã của bạn.

00:00:29.000 --> 00:00:34.000
Năm nay, chúng tôi đã thấy việc làm việc với dữ liệu trên thiết bị trở nên dễ dàng hơn bao giờ hết.

00:00:34.000 --> 00:00:39.000
Nhưng đôi khi tính năng bạn muốn triển khai sẽ yêu cầu nội dung động được cung cấp bởi một thành phần máy chủ.

00:00:39.000 --> 00:00:44.000
Điều này có nghĩa là thực hiện các yêu cầu mạng đến một dịch vụ từ xa, gọi API của nó.

00:00:44.000 --> 00:00:49.000
Nhưng để đưa ra yêu cầu mạng phù hợp, có rất nhiều điều cần xem xét.

00:00:49.000 --> 00:00:52.000
URL cơ sở của máy chủ là gì?

00:00:52.000 --> 00:00:55.000
Những thành phần đường dẫn nào tạo nên điểm cuối API?

00:00:55.000 --> 00:00:58.000
Bạn nên sử dụng phương thức HTTP nào?

00:00:58.000 --> 00:01:01.000
Và bạn nên cung cấp các thông số như thế nào?

00:01:01.000 --> 00:01:05.000
Đây chỉ là một số câu hỏi cần xem xét khi gọi API máy chủ.

00:01:05.000 --> 00:01:09.000
Đối với các API liên quan nhiều hơn, bạn sẽ cần xem xét nhiều hơn nữa.

00:01:09.000 --> 00:01:13.000
Vậy bạn trả lời những câu hỏi này như thế nào?

00:01:13.000 --> 00:01:16.000
Hầu hết các dịch vụ đều có một số dạng tài liệu API.

00:01:16.000 --> 00:01:24.000
Nhưng tài liệu viết tay thường có thể không chính xác hoặc lỗi thời, đặc biệt nếu dịch vụ đang phát triển nhanh chóng.

00:01:24.000 --> 00:01:30.000
Nếu bạn có quyền truy cập vào mã nguồn, bạn có thể xem xét việc triển khai hoặc bạn có thể thử nghiệm thủ công với API.

00:01:30.000 --> 00:01:35.000
Nhưng điều này có thể dẫn đến sự hiểu biết không đầy đủ về hành vi dịch vụ.

00:01:35.000 --> 00:01:39.000
Bạn có thể tìm kiếm các diễn đàn hỗ trợ hoặc dựa vào kiến thức tổ chức khác.

00:01:39.000 --> 00:01:48.000
Nhưng ngay cả những cá nhân có ý tốt nhất cũng có thể thiếu hiểu biết hoặc cung cấp câu trả lời không nhất quán, để lại cho bạn nhiều câu hỏi hơn bạn bắt đầu.

00:01:48.000 --> 00:01:52.000
Mặc dù những tài nguyên này cung cấp một số trợ giúp, nhưng nó không phải là một bức tranh hoàn chỉnh.

00:01:52.000 --> 00:01:58.000
Sử dụng mô tả chính thức và có cấu trúc hơn về API có thể giúp loại bỏ sự mơ hồ.

00:01:58.000 --> 00:02:04.000
Gặp gỡ OpenAPI, một đặc tả mở để xác định các dịch vụ HTTP.

00:02:04.000 --> 00:02:14.000
OpenAPI là một tiêu chuẩn công nghiệp, và việc áp dụng và trưởng thành rộng rãi của nó có nghĩa là có các quy ước và phương pháp hay nhất đã được thiết lập để giúp bạn làm việc với API.

00:02:14.000 --> 00:02:25.000
Với OpenAPI, bạn ghi lại hành vi dịch vụ trong YAML hoặc JSON và các định dạng có thể đọc được bằng máy này cho phép bạn hưởng lợi từ một hệ sinh thái công cụ phong phú.

00:02:25.000 --> 00:02:32.000
Có các công cụ để tạo thử nghiệm, xác thực thời gian chạy, khả năng tương tác và hơn thế nữa.

00:02:32.000 --> 00:02:38.000
Một điều mà OpenAPI đặc biệt được biết đến là công cụ để tạo tài liệu tương tác.

00:02:38.000 --> 00:02:46.000
Nhưng động lực cốt lõi của OpenAPI là tạo mã cho phép người chấp nhận sử dụng phát triển dựa trên thông số kỹ thuật.

00:02:46.000 --> 00:02:48.000
Bạn có nhớ điểm cuối API ví dụ của chúng tôi không?

00:02:48.000 --> 00:02:55.000
Chà, khi nhận được yêu cầu này, máy chủ sẽ trả về lời chào được cá nhân hóa trong một đối tượng JSON.

00:02:55.000 --> 00:03:02.000
Chúng ta hãy xem mã chúng ta cần viết để gọi API này, mà không cần sử dụng tạo mã.

00:03:02.000 --> 00:03:07.000
Đầu tiên, chúng ta cần biết URL cơ sở của máy chủ để chuyển đổi thành các thành phần của nó.

00:03:07.000 --> 00:03:14.000
Sau đó, chúng tôi nối thêm thành phần đường dẫn để xây dựng điểm cuối API và chỉ định tham số làm mục truy vấn.

00:03:14.000 --> 00:03:21.000
Sau đó, chúng tôi xây dựng một URLRequest và sử dụng URLSession để thực hiện yêu cầu HTTP.

00:03:21.000 --> 00:03:29.000
Sau đó, chúng ta phải xác thực các phản hồi của loại dự kiến có mã trạng thái dự kiến và loại nội dung.

00:03:29.000 --> 00:03:37.000
Sau đó, chúng ta phải giải mã các byte từ phản hồi, điều mà chúng ta thực hiện bằng cách xác định một loại Swift phù hợp với Decodable và sử dụng JSONDecoder.

00:03:37.000 --> 00:03:42.000
Cuối cùng, chúng tôi trả lại thuộc tính tin nhắn từ phản hồi.

00:03:42.000 --> 00:03:47.000
Viết mã này là tốt, nhưng đây chỉ là một yêu cầu duy nhất cho một hoạt động API tầm thường.

00:03:47.000 --> 00:03:54.000
Nhiều API trong thế giới thực có hàng trăm hoạt động, với các loại yêu cầu và phản hồi phong phú, trường tiêu đề, tham số và hơn thế nữa.

00:03:54.000 --> 00:04:00.000
Viết mã này cho mọi thao tác trở nên lặp đi lặp lại, dài dòng và dễ bị lỗi.

00:04:00.000 --> 00:04:05.000
Và tất cả các buổi lễ này trong cơ sở mã của bạn làm giảm logic cốt lõi của ứng dụng của bạn.

00:04:05.000 --> 00:04:12.000
Với OpenAPI, bạn có thể sử dụng công cụ để tạo hầu hết mã này để bạn có thể tập trung vào mã mà người dùng của bạn tương tác.

00:04:12.000 --> 00:04:17.000
Chúng tôi sẽ sử dụng API ví dụ của mình để khám phá tài liệu OpenAPI.

00:04:17.000 --> 00:04:22.000
Mọi tài liệu OpenAPI đều khai báo phiên bản của đặc tả OpenAPI mà nó đang sử dụng.

00:04:22.000 --> 00:04:29.000
Nó cung cấp siêu dữ liệu về API, bao gồm tên và phiên bản của nó và danh sách các URL máy chủ.

00:04:29.000 --> 00:04:34.000
Sau đó, nó liệt kê các đường dẫn và phương thức HTTP tạo nên API.

00:04:34.000 --> 00:04:41.000
API này chỉ có một thao tác, được đặt tên là getGreeting, xác định hành vi cho phương thức GET trên đường chào hỏi.

00:04:41.000 --> 00:04:53.000
Trong ví dụ này, máy chủ luôn phản hồi với 200, đó là mã trạng thái HTTP cho OK và trả về một đối tượng JSON, được xác định bằng Lược đồ JSON.

00:04:53.000 --> 00:05:05.000
Đối với hình minh họa này, chúng tôi đã giữ nó đơn giản, nhưng các hoạt động có thể có nhiều phản hồi, với các mã trạng thái và loại nội dung khác nhau, cho phép bạn ghi lại tất cả các tình huống, bao gồm cả những gì xảy ra khi có lỗi.

00:05:05.000 --> 00:05:11.000
Và nếu thao tác chấp nhận các tham số, chúng cũng có thể được đưa vào tài liệu OpenAPI.

00:05:11.000 --> 00:05:21.000
Thao tác này hỗ trợ một tham số truy vấn tùy chọn được gọi là "name", một giá trị chuỗi được sử dụng để cá nhân hóa lời chào.

00:05:21.000 --> 00:05:28.000
Với sự trợ giúp của Swift OpenAPI Generator, chúng ta có thể thực hiện cùng một lệnh gọi API với ít mã hơn nhiều.

00:05:28.000 --> 00:05:38.000
Chúng tôi có thể sử dụng đầu vào an toàn loại và các giá trị đầu ra là các loại enum phong phú để trình biên dịch có thể giúp chúng tôi đảm bảo chúng tôi xử lý mọi phản hồi được ghi lại và loại nội dung.

00:05:38.000 --> 00:05:44.000
Và giá trị liên quan trong nội dung phản hồi là một loại giá trị với các thuộc tính an toàn kiểu.

00:05:44.000 --> 00:05:57.000
Tất cả các buổi lễ liên quan đến việc mã hóa đầu vào, thực hiện yêu cầu, phân tích cú pháp phản hồi và giải mã đầu ra đều được xử lý bởi mã được tạo.

00:05:57.000 --> 00:06:02.000
Swift OpenAPI Generator là một trình cắm Swift Package chạy tại thời điểm xây dựng.

00:06:02.000 --> 00:06:09.000
Điều này có nghĩa là mã được tạo luôn đồng bộ với tài liệu OpenAPI và không cần phải cam kết với kho lưu trữ nguồn của bạn.

00:06:09.000 --> 00:06:16.000
Để tìm hiểu thêm về các trình cắm gói Swift, hãy xem phiên có tên "Gặp gỡ các plugin gói Swift".

00:06:16.000 --> 00:06:21.000
Hãy cùng xem cách chúng ta có thể sử dụng Swift OpenAPI Generator trong một ứng dụng iOS đơn giản.

00:06:21.000 --> 00:06:25.000
Đối với điều này, chúng tôi sẽ cần một API mà chúng tôi có thể gọi.

00:06:25.000 --> 00:06:32.000
Trong bản demo này, chúng tôi sẽ gọi một API đơn giản trả về một trong mười biểu tượng cảm xúc khuôn mặt mèo một cách ngẫu nhiên.

00:06:32.000 --> 00:06:41.000
Chúng ta sẽ bắt đầu với ứng dụng SwiftUI mẫu và thay thế nội dung mẫu bằng một biểu tượng cảm xúc lớn và một nút tìm nạp một cái mới từ máy chủ trên mỗi lần nhấn.

00:06:41.000 --> 00:06:54.000
Chúng tôi đã có một máy chủ đang chạy, lắng nghe trên localhost, mà chúng tôi có thể truy vấn từ Terminal bằng curl.

00:06:54.000 --> 00:06:56.000
Không thể phủ nhận rằng đây là một API tuyệt vời.

00:06:56.000 --> 00:07:00.000
Nhưng điều làm cho nó thậm chí còn tốt hơn là nó được xác định bằng OpenAPI.

00:07:00.000 --> 00:07:08.000
Hãy sử dụng một loại mèo rất khác để hiển thị tài liệu OpenAPI cho dịch vụ này.

00:07:08.000 --> 00:07:16.000
API này có một thao tác duy nhất có tên getEmoji mà chúng tôi sẽ gọi từ ứng dụng của mình để cập nhật giao diện người dùng.

00:07:16.000 --> 00:07:20.000
Để bắt đầu, chúng ta sẽ chuyển sang Xcode.

00:07:20.000 --> 00:07:27.000
Ứng dụng iOS mẫu này có giao diện người dùng cơ bản, được xác định bằng SwiftUI, mà chúng ta có thể thấy trong bản xem trước Xcode.

00:07:27.000 --> 00:07:33.000
Trong vài phút tới, chúng tôi sẽ thay thế các thành phần giao diện người dùng bằng nội dung động, mà chúng tôi sẽ tìm nạp từ máy chủ.

00:07:33.000 --> 00:07:41.000
Và chúng tôi sẽ sử dụng Swift OpenAPI Generator để đơn giản hóa mã mà chúng tôi phải viết bằng tay để thực hiện các lệnh gọi API.

00:07:41.000 --> 00:07:45.000
Chúng tôi sẽ bắt đầu bằng cách thêm các phụ thuộc gói bắt buộc vào dự án của chúng tôi.

00:07:45.000 --> 00:07:54.000
Sau đó, chúng tôi sẽ định cấu hình mục tiêu của mình để sử dụng plugin để tạo mã và thêm tài liệu OpenAPI và tệp cấu hình trình cắm vào thư mục nguồn mục tiêu của chúng tôi.

00:07:54.000 --> 00:08:02.000
Khi dự án được cấu hình, chúng tôi sẽ thay thế các thành phần giao diện người dùng và sử dụng loại Khách hàng được tạo để thực hiện các lệnh gọi API đến máy chủ.

00:08:02.000 --> 00:08:13.000
Để định cấu hình ứng dụng của bạn để sử dụng Trình tạo Swift OpenAPI, hãy điều hướng đến Trình chỉnh sửa dự án, chọn tab Phụ thuộc gói và nhấp để thêm phụ thuộc mới.

00:08:13.000 --> 00:08:20.000
Đối với bản demo này, chúng tôi đang sử dụng bộ sưu tập gói cục bộ, nhưng bạn có thể tìm thấy URL gói trong ghi chú phiên.

00:08:20.000 --> 00:08:31.000
Đầu tiên, chúng tôi sẽ thêm sự phụ thuộc vào trình tạo swift-openapi, cung cấp trình cắm gói.

00:08:31.000 --> 00:08:47.000
Sau đó, chúng tôi sẽ thêm sự phụ thuộc vào swift-openapi-runtime, cung cấp các loại và trừu tượng phổ biến được sử dụng bởi mã được tạo.

00:08:47.000 --> 00:08:55.000
Và bởi vì mã được tạo không bị ràng buộc với bất kỳ thư viện máy khách HTTP cụ thể nào, chúng tôi cần chọn một gói tích hợp cho thư viện mà chúng tôi muốn sử dụng.

00:08:55.000 --> 00:09:05.000
Chúng tôi đang xây dựng một ứng dụng iOS, vì vậy chúng tôi sẽ sử dụng gói URLSession, nhưng hãy xem tài liệu để biết các ví dụ khác và cách viết của riêng bạn.

00:09:05.000 --> 00:09:10.000
Với các phụ thuộc tại chỗ, chúng ta có thể định cấu hình mục tiêu để sử dụng plugin OpenAPI Generator.

00:09:10.000 --> 00:09:17.000
Trong Cài đặt Mục tiêu, chọn Giai đoạn Xây dựng và mở rộng phần có tên "Chạy Trình cắm Công cụ Xây dựng".

00:09:17.000 --> 00:09:25.000
Nhấp để thêm một trình cắm mới và chọn OpenAPIGenerator từ danh sách.

00:09:25.000 --> 00:09:43.000
Trình cắm mong đợi hai tệp đầu vào trong thư mục nguồn đích của bạn: tài liệu OpenAPI và tệp cấu hình trình cắm, mà tôi sẽ thêm vào dự án ngay bây giờ.

00:09:43.000 --> 00:09:50.000
Cấu hình trình cắm được viết bằng lược đồ YAML đơn giản chỉ định mã mà trình cắm sẽ tạo.

00:09:50.000 --> 00:09:55.000
Trong trường hợp này, chúng tôi sẽ tạo ra "các loại", là các loại có thể tái sử dụng có nguồn gốc từ tài liệu OpenAPI.

00:09:55.000 --> 00:10:01.000
Và chúng tôi cũng sẽ tạo mã máy khách, có thể được sử dụng để thực hiện các cuộc gọi API với bất kỳ máy khách HTTP nào.

00:10:01.000 --> 00:10:11.000
Chúng tôi sẽ chuyển trở lại ContentView.swift, điều này sẽ biên dịch lại dự án của chúng tôi để mã được tạo sẵn sàng để sử dụng trong ứng dụng của chúng tôi.

00:10:11.000 --> 00:10:18.000
Như một biện pháp bảo mật, bạn sẽ được yêu cầu tin tưởng trình cắm ngay lần đầu tiên bạn sử dụng nó.

00:10:18.000 --> 00:10:28.000
Bây giờ chúng tôi đã biên dịch lại dự án, chúng tôi có thể thay thế các thành phần giao diện người dùng và sử dụng loại Khách hàng được tạo để thực hiện các lệnh gọi API đến máy chủ và cập nhật chế độ xem.

00:10:28.000 --> 00:10:34.000
Chúng tôi sẽ bắt đầu bằng cách thêm một thuộc tính trạng thái mới vào chế độ xem cho biểu tượng cảm xúc của chúng tôi và khởi tạo nó với giá trị giữ chỗ.

00:10:34.000 --> 00:10:51.000
Sau đó, chúng tôi sẽ thay thế hình ảnh quả địa cầu bằng chế độ xem Văn bản chứa biểu tượng cảm xúc, thay thế thông báo "Xin chào, thế giới" bằng một nút và đặt kiểu nút cho chế độ xem của chúng tôi.

00:10:51.000 --> 00:10:56.000
Mã được tạo cung cấp một loại, được đặt tên là Khách hàng, mà bạn có thể sử dụng để thực hiện các lệnh gọi API.

00:10:56.000 --> 00:11:02.000
Nhưng trước tiên, chúng ta cần nhập thời gian chạy OpenAPI và các mô-đun vận chuyển.

00:11:02.000 --> 00:11:14.000
Bây giờ chúng ta có thể thêm một thuộc tính khách hàng vào chế độ xem của mình và một trình khởi tạo cấu hình nó để sử dụng URL máy chủ localhost, được xác định trong tài liệu OpenAPI.

00:11:14.000 --> 00:11:28.000
Bây giờ chúng ta sẽ thêm một hàm thực hiện lệnh gọi API đến máy chủ bằng máy khách này.

00:11:28.000 --> 00:11:32.000
Đó là tất cả mã chúng ta cần viết bằng tay để thực hiện yêu cầu API.

00:11:32.000 --> 00:11:35.000
Mọi thứ khác đều được xử lý bởi mã được tạo.

00:11:35.000 --> 00:11:44.000
Phản hồi là một giá trị liệt kê của một loại mô hình hóa tất cả các phản hồi được ghi lại và các loại nội dung khuyến khích chúng tôi xử lý tất cả các tình huống.

00:11:44.000 --> 00:11:50.000
Vì vậy, chúng ta cần trích xuất biểu tượng cảm xúc từ nội dung phản hồi bằng cách sử dụng câu lệnh chuyển đổi.

00:11:50.000 --> 00:11:51.000
Có gì đó còn thiếu ở đây.

00:11:51.000 --> 00:11:55.000
Trình biên dịch đã nói với chúng tôi rằng chúng tôi chưa xử lý mọi tình huống.

00:11:55.000 --> 00:12:01.000
Chúng tôi sẽ để Xcode điền vào trường hợp công tắc bị thiếu.

00:12:01.000 --> 00:12:09.000
Trong trường hợp máy chủ phản hồi bằng thứ gì đó không được chỉ định trong tài liệu OpenAPI của nó, bạn vẫn có cơ hội xử lý điều đó một cách duyên dáng.

00:12:09.000 --> 00:12:20.000
Đối với bản demo này, chúng tôi sẽ in cảnh báo lên bảng điều khiển và cập nhật biểu tượng cảm xúc của chúng tôi thành một thứ khác ngoài một con mèo.

00:12:20.000 --> 00:12:26.000
Bây giờ chúng ta có thể gọi hàm này khi nhấn nút của chúng ta.

00:12:26.000 --> 00:12:33.000
Và chúng ta có thể sử dụng nút của mình để tìm nạp biểu tượng cảm xúc mèo mới và cập nhật giao diện người dùng của mình.

00:12:33.000 --> 00:12:37.000
Khi các tính năng mới được thêm vào máy chủ, API của nó sẽ phát triển.

00:12:37.000 --> 00:12:45.000
Và nếu máy chủ được ghi lại bằng OpenAPI, thì Swift OpenAPI Generator giúp việc sử dụng các tính năng mới này từ ứng dụng của bạn trở nên đơn giản.

00:12:45.000 --> 00:12:52.000
Hãy xem qua một ví dụ về cách cập nhật ứng dụng khi tài liệu OpenAPI phát triển.

00:12:52.000 --> 00:13:02.000
Khi nói đến biểu tượng cảm xúc, nhiều hơn là nhiều hơn, vì vậy chúng tôi đã mở rộng API dịch vụ để lấy tham số truy vấn tùy chọn mới, đếm, có thể được sử dụng để tìm nạp nhiều biểu tượng cảm xúc.

00:13:02.000 --> 00:13:10.000
Chúng tôi sẽ mở rộng ứng dụng của mình bằng một nút khác tìm nạp ba con mèo thay vì một con.

00:13:10.000 --> 00:13:14.000
Đầu tiên, chúng ta sẽ thêm một tham số vào tài liệu OpenAPI.

00:13:14.000 --> 00:13:19.000
Và một khi chúng tôi biên dịch lại dự án, tham số sẽ có sẵn để sử dụng trong ứng dụng.

00:13:19.000 --> 00:13:24.000
Sau đó, chúng tôi sẽ tạo một nút mới thực hiện lệnh gọi API bằng cách sử dụng tham số này.

00:13:24.000 --> 00:13:32.000
Chúng ta sẽ bắt đầu bằng cách thêm tham số mới vào tài liệu OpenAPI.

00:13:32.000 --> 00:13:35.000
Tham số này được đặt tên là "đếm".

00:13:35.000 --> 00:13:36.000
Đó là một tham số tùy chọn.

00:13:36.000 --> 00:13:41.000
Nó được cung cấp như một phần của truy vấn URL và là một giá trị nguyên.

00:13:41.000 --> 00:13:50.000
Hãy quay trở lại ContentView.swift và mở rộng chức năng updateEmoji để lấy một tham số.

00:13:50.000 --> 00:14:01.000
Và hãy sử dụng tham số này khi thực hiện lệnh gọi API.

00:14:01.000 --> 00:14:09.000
Chúng tôi sẽ sao chép nút và thay đổi nhãn thành "Thêm mèo".

00:14:09.000 --> 00:14:18.000
Khi nút này được nhấn, chúng ta sẽ gọi cùng một hàm, nhưng lần này với số lượng là ba.

00:14:18.000 --> 00:14:25.000
Bây giờ trong bản xem trước, chúng ta có thể nhấn vào "Nhận mèo" để lấy một con mèo hoặc "Thêm mèo" để lấy ba con.

00:14:25.000 --> 00:14:33.000
Trong suốt thời gian này, chúng tôi đã đưa ra các yêu cầu đối với một máy chủ thực sự, điều này không phải lúc nào cũng thực tế hoặc mong muốn, đặc biệt là trong quá trình phát triển.

00:14:33.000 --> 00:14:41.000
Bởi vì loại Khách hàng được tạo phù hợp với giao thức Swift, chúng tôi dễ dàng viết một mô phỏng không yêu cầu kết nối mạng hoặc thư viện vận chuyển.

00:14:41.000 --> 00:14:49.000
Giao thức được tạo có tên là APIProtocol, vì vậy chúng ta sẽ bắt đầu bằng cách xác định một loại MockClient mới áp dụng giao thức này.

00:14:49.000 --> 00:14:58.000
Sau đó, chúng tôi sẽ cập nhật chế độ xem của mình để chung chung đối với bất kỳ loại nào phù hợp với APIProtocol và cập nhật các trình khởi tạo để hỗ trợ tiêm phụ thuộc.

00:14:58.000 --> 00:15:02.000
Sau đó, chúng tôi sẽ sử dụng MockClient khi xem trước giao diện người dùng trong Xcode.

00:15:02.000 --> 00:15:07.000
Chúng tôi sẽ bắt đầu bằng cách khai báo loại MockClient của chúng tôi.

00:15:07.000 --> 00:15:14.000
Bởi vì chúng tôi đã tuyên bố rằng loại này áp dụng APIProtocol, trình biên dịch sẽ đảm bảo nó đáp ứng các yêu cầu giao thức.

00:15:14.000 --> 00:15:20.000
Chúng tôi sẽ để Xcode thêm trình xử lý bị thiếu cho hoạt động API.

00:15:20.000 --> 00:15:28.000
Và chúng tôi sẽ thêm logic kinh doanh, trả về biểu tượng cảm xúc robot, để phân biệt nó với dịch vụ thực.

00:15:28.000 --> 00:15:39.000
Bây giờ chúng ta có thể làm cho chế độ xem của mình chung chung trên các loại phù hợp với giao thức này và cập nhật thuộc tính máy khách để sử dụng tham số loại chung.

00:15:39.000 --> 00:15:53.000
Chúng tôi sẽ thêm một trình khởi tạo, lấy một khách hàng làm tham số và chúng tôi sẽ cập nhật trình khởi tạo hiện có với một mệnh đề where chung, vì vậy nếu không có khách hàng nào được cung cấp, chúng tôi sẽ sử dụng cùng một ứng dụng như trước đây.

00:15:53.000 --> 00:16:02.000
Khi ứng dụng của chúng tôi được khởi chạy, nó sẽ tiếp tục sử dụng máy chủ thực, nhưng bây giờ chúng tôi có thể tiêm MockClient khi xem trước giao diện người dùng trong Xcode.

00:16:02.000 --> 00:16:13.000
Bây giờ khi chúng tôi nhấn vào các nút của mình trong bản xem trước giao diện người dùng, chúng tôi sẽ nhận được rô bốt thay vì mèo và sẽ không yêu cầu kết nối mạng hoặc máy chủ đang chạy.

00:16:13.000 --> 00:16:20.000
Cho đến khi chúng tôi thêm ứng dụng khách giả, ứng dụng iOS của chúng tôi đã thực hiện các yêu cầu đến một máy chủ thực đang chạy trên máy cục bộ của tôi.

00:16:20.000 --> 00:16:25.000
Máy chủ này cũng được viết bằng Swift với sự trợ giúp của Swift OpenAPI Generator.

00:16:25.000 --> 00:16:33.000
Máy chủ là một gói Swift đơn giản, sử dụng trình cắm gói Swift OpenAPI Generator để tạo mã.

00:16:33.000 --> 00:16:43.000
Để sử dụng mã máy chủ được tạo, chúng tôi đã xác định một loại phù hợp với giao thức được tạo có tên APIProtocol và chỉ triển khai logic kinh doanh cho các hoạt động API của chúng tôi.

00:16:43.000 --> 00:16:54.000
Và để cấu hình máy chủ, chúng tôi đã sử dụng một hàm được tạo, registerHandlers, kết nối các yêu cầu HTTP đến cho các hoạt động API với các trình xử lý của chúng tôi cung cấp logic kinh doanh.

00:16:54.000 --> 00:16:58.000
Hãy cùng xem nào.

00:16:58.000 --> 00:17:04.000
Nếu chúng tôi mở rộng bảng điều khiển, chúng tôi có thể thấy các yêu cầu thực tế từ ứng dụng iOS demo của chúng tôi.

00:17:04.000 --> 00:17:09.000
Và đây là tất cả mã Swift mà chúng tôi cần viết bằng tay để triển khai máy chủ.

00:17:09.000 --> 00:17:22.000
Thay vì sử dụng OpenAPI để chỉ ghi lại dịch vụ này, chúng tôi đã bắt đầu với tài liệu OpenAPI và sử dụng Swift OpenAPI Generator để đơn giản hóa việc viết một máy chủ triển khai đặc tả API.

00:17:22.000 --> 00:17:30.000
Chúng tôi đã xác định một loại phù hợp với Giao thức API được tạo và chỉ cung cấp logic kinh doanh cho các hoạt động API của chúng tôi.

00:17:30.000 --> 00:17:36.000
Và chúng tôi đã sử dụng một hàm được tạo, để đăng ký các phương thức của nó với máy chủ HTTP cho các điểm cuối API.

00:17:36.000 --> 00:17:40.000
Trong bản demo này, chúng tôi đang sử dụng Vapor, một khung web mã nguồn mở cho Swift.

00:17:40.000 --> 00:17:47.000
Nhưng mã được tạo có thể được sử dụng với bất kỳ khung web nào cung cấp gói tích hợp cho Swift OpenAPI Generator.

00:17:47.000 --> 00:17:53.000
Kiểm tra tài liệu để biết các tùy chọn khác và cách bạn có thể tự viết.

00:17:53.000 --> 00:18:00.000
Trong chức năng chính của chúng tôi, chúng tôi tạo ra một ứng dụng Vapor mới, mà chúng tôi sử dụng để tạo ra một phương tiện vận chuyển OpenAPI.

00:18:00.000 --> 00:18:12.000
Sau đó, chúng tôi tạo một phiên bản của loại trình xử lý của mình và sử dụng chức năng registerHandlers được tạo để thiết lập định tuyến trong máy chủ HTTP cho từng hoạt động API của chúng tôi, điều mà nếu không chúng tôi sẽ phải thực hiện thủ công.

00:18:12.000 --> 00:18:18.000
Cuối cùng, chúng tôi chạy ứng dụng Vapor, giống như cách chúng tôi đã định cấu hình nó theo cách thủ công.

00:18:18.000 --> 00:18:30.000
Swift là một ngôn ngữ tuyệt vời để phát triển máy chủ và nếu bạn muốn tìm hiểu thêm về cách viết các dịch vụ phụ trợ trong Swift, hãy xem phiên có tên "Sử dụng Xcode để phát triển phía máy chủ".

00:18:30.000 --> 00:18:35.000
Chúng ta hãy xem cách gói được cấu hình để sử dụng Swift OpenAPI Generator.

00:18:35.000 --> 00:18:41.000
Máy chủ được triển khai như một gói Swift và được xác định bằng cách sử dụng tệp Package.swift.

00:18:41.000 --> 00:18:48.000
Gói này có một mục tiêu thực thi duy nhất, được gọi là CatService, sử dụng plugin Swift OpenAPI Generator.

00:18:48.000 --> 00:19:04.000
Mã máy chủ được tạo phụ thuộc vào các loại và trừu tượng phổ biến từ thư viện thời gian chạy và có thể được sử dụng với bất kỳ khung web nào cung cấp gói tích hợp, vì vậy mục tiêu này phụ thuộc vào swift-openapi-runtime, swift-openapi-vapor và chính vapor.

00:19:04.000 --> 00:19:13.000
Trong thư mục nguồn đích, chúng tôi đã thêm tài liệu OpenAPI, cùng một tài liệu mà chúng tôi đã sử dụng trong ứng dụng iOS demo của mình và tệp cấu hình trình cắm thêm.

00:19:13.000 --> 00:19:17.000
Đối với mục tiêu này, chúng tôi đang tạo ra các loại và cuống máy chủ.

00:19:17.000 --> 00:19:24.000
Hãy xem cách phát triển dựa trên thông số kỹ thuật có thể giúp việc thêm các tính năng mới vào dịch vụ này trở nên đơn giản hơn.

00:19:24.000 --> 00:19:35.000
Biểu tượng cảm xúc mèo rất tuyệt, nhưng rất nhiều bằng chứng cho thấy internet chủ yếu được xây dựng để trao đổi video về mèo, vì vậy chúng tôi sẽ thêm tính năng đó vào máy chủ của mình.

00:19:35.000 --> 00:19:40.000
Với sự phát triển dựa trên thông số kỹ thuật, việc thêm một hoạt động API mới chỉ cần hai bước.

00:19:40.000 --> 00:19:44.000
Đầu tiên, chúng tôi thêm thao tác mới vào tài liệu OpenAPI.

00:19:44.000 --> 00:19:53.000
Sau đó, vì giao thức được tạo hiện có yêu cầu chức năng mới, trình biên dịch sẽ nhấn mạnh rằng chúng tôi xác định một phương thức trên trình xử lý của mình và triển khai logic kinh doanh.

00:19:53.000 --> 00:20:06.000
Trước khi chúng ta bắt đầu, chúng ta sẽ cần một video về mèo, mà tôi đã thêm vào thư mục Tài nguyên cho mục tiêu của chúng ta.

00:20:06.000 --> 00:20:12.000
Chúng ta sẽ đi đến tài liệu OpenAPI và thêm thao tác mới.

00:20:12.000 --> 00:20:22.000
Thao tác này được gọi là getClip và có phản hồi nhị phân với loại nội dung cho biết nội dung phản hồi chứa dữ liệu video.

00:20:22.000 --> 00:20:27.000
Khi chúng tôi cố gắng biên dịch lại gói của mình, nó sẽ thất bại.

00:20:27.000 --> 00:20:34.000
Đó là bởi vì trình xử lý của chúng tôi không còn phù hợp với giao thức được tạo, bởi vì nó không cung cấp chức năng cho hoạt động mới.

00:20:34.000 --> 00:20:44.000
Chúng tôi sẽ để Xcode điền vào sơ khai giao thức cho chúng tôi và chúng tôi sẽ cung cấp logic kinh doanh, đọc các byte từ tệp tài nguyên video và trả về phản hồi OK, với nội dung nhị phân.

00:20:44.000 --> 00:20:55.000
Lưu ý rằng mã được tạo an toàn kiểu chỉ cho phép trả về nội dung phản hồi nhị phân từ hàm này, bởi vì đó là những gì được chỉ định trong tài liệu OpenAPI cho thao tác này.

00:20:55.000 --> 00:21:00.000
Khi chúng tôi biên dịch lại gói của mình, nó sẽ thành công và chúng tôi có thể khởi chạy lại máy chủ của mình.

00:21:00.000 --> 00:21:13.000
Và nếu chúng ta chuyển sang Safari, chúng ta có thể kiểm tra điểm cuối API mới của mình.

00:21:13.000 --> 00:21:20.000
Vì vậy, chúng tôi đã thấy cách các dịch vụ ghi lại bằng OpenAPI có thể giúp loại bỏ sự mơ hồ và cho phép phát triển dựa trên thông số kỹ thuật.

00:21:20.000 --> 00:21:27.000
Chúng tôi đã chỉ ra cách Swift OpenAPI Generator có thể đơn giản hóa việc làm việc với các API máy chủ trong ứng dụng iOS của bạn.

00:21:27.000 --> 00:21:35.000
Cuối cùng, chúng ta đã thấy các tính năng ngôn ngữ của Swift và hệ sinh thái Swift-on-server đang phát triển khiến nó trở thành một lựa chọn tuyệt vời để triển khai các dịch vụ phụ trợ như thế nào.

00:21:35.000 --> 00:21:44.000
Và đó là lý do tại sao Swift OpenAPI Generator là mã nguồn mở và có sẵn trên GitHub, nơi bạn có thể tìm hiểu thêm và thậm chí đóng góp cho dự án khi nó tiếp tục phát triển.

00:21:44.000 --> 00:21:45.000
Cảm ơn vì đã xem phiên này.

00:21:45.000 --> 23:59:59.000
Đó là tất cả cho meo meo!

