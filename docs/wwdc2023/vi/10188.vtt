WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:14.000
Tim: Xin chào, tôi là Tim, tôi là một kỹ sư trong nhóm CloudKit.

00:00:14.000 --> 00:00:19.000
Đồng nghiệp của tôi Aamer và tôi ở đây để nói về một CloudKit API mới có tên là CKSyncEngine.

00:00:19.000 --> 00:00:23.000
CKSyncEngine được thiết kế để giúp đồng bộ hóa dữ liệu giữa thiết bị và đám mây.

00:00:23.000 --> 00:00:27.000
Đầu tiên, tôi sẽ nói về trạng thái đồng bộ hóa với CloudKit trên nền tảng Apple.

00:00:27.000 --> 00:00:32.000
Tiếp theo, tôi sẽ đưa ra một cái nhìn tổng quan về CKSyncEngine là gì và nó hoạt động như thế nào.

00:00:32.000 --> 00:00:37.000
Sau đó, bạn sẽ tìm hiểu về cách bắt đầu với CKSyncEngine trong dự án của riêng bạn.

00:00:37.000 --> 00:00:42.000
Khi bạn đã thiết lập xong, bạn sẽ học cách sử dụng công cụ đồng bộ hóa để đồng bộ hóa dữ liệu trên các thiết bị.

00:00:42.000 --> 00:00:48.000
Cuối cùng, bạn sẽ tìm hiểu về các phương pháp hay nhất để kiểm tra và gỡ lỗi tích hợp của bạn với CKSyncEngine.

00:00:48.000 --> 00:00:54.000
Đầu tiên, trạng thái đồng bộ hóa với CloudKit.

00:00:54.000 --> 00:00:57.000
Khi bạn xây dựng một ứng dụng mới, mọi người chỉ mong đợi dữ liệu của họ đồng bộ hóa.

00:00:57.000 --> 00:01:02.000
Họ làm một cái gì đó trên iPhone của họ, và khi họ mở máy Mac của họ, họ mong đợi nó cũng ở đó.

00:01:02.000 --> 00:01:05.000
Nhìn từ bên ngoài, điều này trông giống như phép thuật.

00:01:05.000 --> 00:01:09.000
Dữ liệu của họ ở một nơi, và sau đó nó ở khắp mọi nơi.

00:01:09.000 --> 00:01:11.000
Đối với bạn và tôi, nó không dễ dàng như vậy.

00:01:11.000 --> 00:01:16.000
Bản thân CloudKit không quá phức tạp, nhưng việc đồng bộ hóa nói chung rất khó.

00:01:16.000 --> 00:01:21.000
Khi bạn đưa nhiều thiết bị vào kịch bản, có rất nhiều điều có thể xảy ra.

00:01:21.000 --> 00:01:25.000
Vì vậy, bạn có thể tạo mã đồng bộ hóa của mình càng đơn giản thì càng tốt.

00:01:25.000 --> 00:01:29.000
Và cách tốt nhất để đơn giản hóa mã đồng bộ hóa của bạn là viết càng ít càng tốt.

00:01:29.000 --> 00:01:37.000
Rất may, bạn có một số lựa chọn API tuyệt vời để đồng bộ hóa với CloudKit và những API này thực hiện rất nhiều công việc nặng nhọc cho bạn.

00:01:37.000 --> 00:01:43.000
Nếu bạn muốn một giải pháp full-stack bao gồm sự kiên trì cục bộ, bạn có thể sử dụng NSPersistentCloudKitContainer.

00:01:43.000 --> 00:01:49.000
Nếu bạn muốn mang lại sự kiên trì cục bộ của riêng mình, bạn có thể sử dụng API CKSyncEngine mới.

00:01:49.000 --> 00:01:54.000
Nếu bạn vẫn nghĩ rằng bạn cần kiểm soát chi tiết hơn, bạn có thể sử dụng CKDatabase và CKOperations.

00:01:54.000 --> 00:02:00.000
Nhưng nếu bạn muốn đồng bộ hóa với CloudKit, và nếu bạn không sử dụng NSPersistentCloudKitContainer, bạn nên sử dụng CKSyncEngine.

00:02:00.000 --> 00:02:10.000
Đồng bộ hóa liên quan đến nhiều bộ phận chuyển động và sử dụng API cấp cao hơn như CKSyncEngine có thể giúp giảm độ phức tạp và cải thiện trải nghiệm đồng bộ hóa ứng dụng của bạn.

00:02:10.000 --> 00:02:20.000
Về cốt lõi, đồng bộ hóa chủ yếu chỉ là gửi các thay đổi từ một thiết bị và tìm nạp chúng trên một thiết bị khác, chuyển đổi sang và từ các bản ghi CloudKit khi cần thiết.

00:02:20.000 --> 00:02:24.000
Điều đó khá dễ thực hiện một mình, nhưng còn nhiều hơn thế nữa.

00:02:24.000 --> 00:02:36.000
Bạn cần tìm hiểu về tất cả các hoạt động và lỗi khác nhau, theo dõi điều kiện hệ thống, lắng nghe các thay đổi tài khoản, xử lý thông báo đẩy, quản lý đăng ký của bạn, theo dõi một loạt trạng thái và hơn thế nữa.

00:02:36.000 --> 00:02:41.000
Khi bạn sử dụng CKSyncEngine, lượng mã đồng bộ hóa bạn phải viết trở nên nhỏ hơn và tập trung hơn nhiều.

00:02:41.000 --> 00:02:47.000
Bạn chỉ phải xử lý những thứ cụ thể cho ứng dụng của mình và công cụ đồng bộ xử lý phần còn lại.

00:02:47.000 --> 00:02:56.000
Để viết một công cụ đồng bộ hóa thích hợp, bạn có thể cần vài nghìn dòng mã, và sau đó tăng gấp đôi số lượng đó trong các bài kiểm tra của bạn.

00:02:56.000 --> 00:03:03.000
Tôi thực sự đã nghe một tin đồn rằng NSPersistentCloudKitContainer được hỗ trợ bởi hơn 70.000 dòng thử nghiệm.

00:03:03.000 --> 00:03:09.000
CKSyncEngine cũng có khá nhiều bài kiểm tra, và đó là vì nó xử lý rất nhiều thứ này cho bạn.

00:03:09.000 --> 00:03:13.000
Vậy CKSyncEngine API mới này là gì?

00:03:13.000 --> 00:03:17.000
CKSyncEngine gói gọn logic chung để đồng bộ hóa với cơ sở dữ liệu CloudKit.

00:03:17.000 --> 00:03:23.000
Nó nhằm mục đích cung cấp một API thuận tiện, đồng thời mang lại sự linh hoạt khi cần thiết.

00:03:23.000 --> 00:03:28.000
Nó được thiết kế để đáp ứng nhu cầu của hầu hết các ứng dụng mà nếu không sẽ viết công cụ đồng bộ hóa tùy chỉnh của riêng chúng.

00:03:28.000 --> 00:03:35.000
Nói chung, nếu bạn đang muốn đồng bộ hóa dữ liệu riêng tư hoặc được chia sẻ của ứng dụng, CKSyncEngine là một lựa chọn tuyệt vời.

00:03:35.000 --> 00:03:42.000
Mô hình dữ liệu bạn sử dụng với công cụ đồng bộ hóa bao gồm các bản ghi và vùng, là cùng loại dữ liệu được sử dụng trong phần còn lại của CloudKit.

00:03:42.000 --> 00:03:47.000
Bạn có thể truy cập bất kỳ dữ liệu nào trong số này bằng cách sử dụng bất kỳ API CloudKit hiện có nào.

00:03:47.000 --> 00:03:53.000
Bởi vì điều này, nếu bạn đã có một triển khai đồng bộ hóa CloudKit hiện có, CKSyncEngine cũng có thể đồng bộ hóa với điều đó.

00:03:53.000 --> 00:04:00.000
Công cụ đồng bộ hóa đang được sử dụng bởi một số ứng dụng và dịch vụ trên toàn hệ thống, bao gồm cả ứng dụng Freeform.

00:04:00.000 --> 00:04:06.000
Một ví dụ khác là NSUbiquitousKeyValueStore, được viết lại trên công cụ đồng bộ hóa.

00:04:06.000 --> 00:04:09.000
Đây là một ví dụ điển hình về trường hợp sử dụng tương thích ngược.

00:04:09.000 --> 00:04:15.000
Trong các hệ điều hành mới hơn, nó sử dụng công cụ đồng bộ hóa, nhưng nó vẫn đồng bộ hóa với các phiên bản trước.

00:04:15.000 --> 00:04:21.000
Vì vậy, nếu bạn đã có triển khai đồng bộ hóa CloudKit tùy chỉnh, thì bạn có tùy chọn chuyển sang CKSyncEngine.

00:04:21.000 --> 00:04:27.000
Nếu lợi ích nghe có vẻ đủ hấp dẫn, bạn nên cân nhắc chuyển đổi, nhưng nó không bắt buộc.

00:04:27.000 --> 00:04:31.000
Đôi khi, thật tuyệt khi chỉ có ít mã hơn để duy trì.

00:04:31.000 --> 00:04:35.000
Bạn cũng sẽ có thể hưởng lợi bất cứ khi nào CKSyncEngine có một cải tiến mới.

00:04:35.000 --> 00:04:43.000
Khi nền tảng phát triển, công cụ đồng bộ hóa cũng sẽ phát triển, giúp đồng bộ hóa dễ dàng và hiệu quả hơn khi thời gian trôi qua.

00:04:43.000 --> 00:04:47.000
Bạn cũng có thể hưởng lợi từ bề mặt API nhỏ hơn của CKSyncEngine.

00:04:47.000 --> 00:04:51.000
Điều này cho phép bạn tập trung vào mô hình dữ liệu và trường hợp sử dụng cụ thể của ứng dụng.

00:04:51.000 --> 00:04:58.000
Nếu bạn đang cân nhắc sử dụng CKSyncEngine, nhưng bạn có một số nhu cầu cụ thể mà nó không hỗ trợ, bạn luôn có thể tự xây dựng nếu muốn.

00:04:58.000 --> 00:05:05.000
Tuy nhiên, nếu bạn nghĩ rằng nhu cầu của mình có thể được thỏa mãn bởi một tính năng mới trong CKSyncEngine, hãy cân nhắc gửi phản hồi cùng với trường hợp sử dụng của bạn.

00:05:05.000 --> 00:05:11.000
Rốt cuộc, một số ý tưởng tốt nhất cho công cụ đồng bộ hóa đã đến từ các nhà phát triển như bạn.

00:05:11.000 --> 00:05:14.000
Vậy công cụ đồng bộ hóa thực sự hoạt động như thế nào?

00:05:14.000 --> 00:05:19.000
Nói chung, công cụ đồng bộ hóa hoạt động như một đường dẫn dữ liệu giữa ứng dụng của bạn và máy chủ CloudKit.

00:05:19.000 --> 00:05:23.000
Ứng dụng của bạn giao tiếp với công cụ đồng bộ hóa về các bản ghi và vùng.

00:05:23.000 --> 00:05:27.000
Khi có những thay đổi cần lưu, ứng dụng của bạn sẽ cung cấp chúng cho công cụ đồng bộ hóa.

00:05:27.000 --> 00:05:31.000
Khi nó tìm nạp những thay đổi này trên một thiết bị khác, nó sẽ cung cấp chúng cho ứng dụng của bạn.

00:05:31.000 --> 00:05:36.000
Điều đó nói rằng, khi công cụ đồng bộ hóa có việc phải làm, nó không phải lúc nào cũng làm điều đó ngay lập tức.

00:05:36.000 --> 00:05:40.000
Nếu nó cần giao tiếp với máy chủ, trước tiên nó sẽ tham khảo ý kiến của bộ lập lịch tác vụ hệ thống.

00:05:40.000 --> 00:05:47.000
Đây là cùng một bộ lập lịch được sử dụng trên hệ điều hành để quản lý tác vụ nền và nó đảm bảo rằng thiết bị đã sẵn sàng để đồng bộ hóa.

00:05:47.000 --> 00:05:52.000
Khi thiết bị đã sẵn sàng, bộ lập lịch sẽ chạy tác vụ và công cụ đồng bộ hóa sẽ nói chuyện với máy chủ.

00:05:52.000 --> 00:05:56.000
Đây là quy trình hoạt động cơ bản cho động cơ đồng bộ hóa.

00:05:56.000 --> 00:06:01.000
Cụ thể hơn, nó trông như thế nào khi công cụ đồng bộ hóa gửi các thay đổi đến máy chủ?

00:06:01.000 --> 00:06:04.000
Đầu tiên, ai đó thực hiện sửa đổi dữ liệu.

00:06:04.000 --> 00:06:09.000
Có thể họ đã gõ một cái gì đó hoặc họ bật công tắc hoặc xóa một đối tượng.

00:06:09.000 --> 00:06:13.000
Sau đó, ứng dụng của bạn thông báo cho công cụ đồng bộ hóa rằng có một thay đổi đang chờ xử lý để gửi đến máy chủ.

00:06:13.000 --> 00:06:17.000
Điều này cho phép công cụ đồng bộ hóa biết rằng nó có việc phải làm.

00:06:17.000 --> 00:06:20.000
Tiếp theo, công cụ đồng bộ hóa gửi một nhiệm vụ đến bộ lập lịch.

00:06:20.000 --> 00:06:24.000
Khi thiết bị đã sẵn sàng, bộ lập lịch sẽ chạy tác vụ.

00:06:24.000 --> 00:06:29.000
Khi tác vụ chạy, công cụ đồng bộ hóa bắt đầu quá trình gửi các thay đổi đến máy chủ.

00:06:29.000 --> 00:06:33.000
Để làm điều đó, nó yêu cầu ứng dụng của bạn gửi hàng loạt thay đổi tiếp theo.

00:06:33.000 --> 00:06:38.000
Nếu ai đó thực hiện một sửa đổi duy nhất, bạn có thể chỉ có một thay đổi đang chờ xử lý.

00:06:38.000 --> 00:06:45.000
Tuy nhiên, nếu ai đó nhập một cơ sở dữ liệu khổng lồ về dữ liệu mới, bạn có thể có hàng trăm hoặc hàng nghìn thay đổi.

00:06:45.000 --> 00:06:51.000
Vì có giới hạn về số lượng có thể được gửi đến máy chủ trong một yêu cầu duy nhất, công cụ đồng bộ hóa yêu cầu những thay đổi này theo lô.

00:06:51.000 --> 00:06:57.000
Điều này cũng giúp giảm chi phí bộ nhớ bằng cách không đưa bất kỳ bản ghi nào vào bộ nhớ cho đến khi chúng thực sự cần thiết.

00:06:57.000 --> 00:07:01.000
Sau khi bạn cung cấp lô tiếp theo, công cụ đồng bộ sẽ gửi nó đến máy chủ.

00:07:01.000 --> 00:07:08.000
Máy chủ phản hồi với kết quả của hoạt động, bao gồm bất kỳ thông tin nào về sự thành công hay thất bại của những thay đổi này.

00:07:08.000 --> 00:07:12.000
Khi yêu cầu kết thúc, công cụ đồng bộ sẽ gọi lại ứng dụng của bạn với kết quả.

00:07:12.000 --> 00:07:17.000
Đây là cơ hội của bạn để phản ứng với sự thành công hay thất bại của hoạt động.

00:07:17.000 --> 00:07:24.000
Nếu bạn có thêm bất kỳ thay đổi nào đang chờ xử lý, công cụ đồng bộ hóa sẽ tiếp tục yêu cầu các lô cho đến khi không còn gì để gửi.

00:07:24.000 --> 00:07:29.000
Bây giờ một thiết bị đã gửi một số dữ liệu đến máy chủ, các thiết bị khác sẽ tìm nạp dữ liệu đó.

00:07:29.000 --> 00:07:36.000
Khi máy chủ nhận được một thay đổi mới, nó sẽ gửi thông báo đẩy đến các thiết bị khác có quyền truy cập vào dữ liệu đó.

00:07:36.000 --> 00:07:40.000
CKSyncEngine tự động lắng nghe những thông báo đẩy này trong ứng dụng của bạn.

00:07:40.000 --> 00:07:44.000
Khi nó nhận được thông báo, nó sẽ gửi một nhiệm vụ đến bộ lập lịch.

00:07:44.000 --> 00:07:49.000
Khi tác vụ lập lịch chạy, công cụ đồng bộ sẽ tìm nạp từ máy chủ.

00:07:49.000 --> 00:07:52.000
Khi nó tìm nạp các thay đổi mới, nó sẽ cung cấp chúng cho ứng dụng của bạn.

00:07:52.000 --> 00:07:56.000
Đây là cơ hội của bạn để duy trì những thay đổi này cục bộ và hiển thị chúng trong giao diện người dùng.

00:07:56.000 --> 00:08:00.000
Và đó là quy trình hoạt động cơ bản khi sử dụng công cụ đồng bộ hóa.

00:08:00.000 --> 00:08:04.000
Một điểm chung của tất cả các luồng này là bộ lập lịch hệ thống.

00:08:04.000 --> 00:08:08.000
Nói chung, CKSyncEngine sẽ tham khảo ý kiến người lập lịch trước khi làm bất cứ điều gì.

00:08:08.000 --> 00:08:13.000
Đây là cách nó có thể tự động đồng bộ hóa thay mặt bạn.

00:08:13.000 --> 00:08:19.000
Bộ lập lịch giám sát các điều kiện hệ thống như kết nối mạng, mức pin, mức sử dụng tài nguyên và hơn thế nữa.

00:08:19.000 --> 00:08:24.000
Nó đảm bảo thiết bị đã đáp ứng mọi điều kiện tiên quyết trước khi cố gắng đồng bộ hóa.

00:08:24.000 --> 00:08:31.000
Bằng cách tôn trọng bộ lập lịch, công cụ đồng bộ hóa có thể đảm bảo sự cân bằng hợp lý giữa trải nghiệm người dùng và tài nguyên thiết bị.

00:08:31.000 --> 00:08:36.000
Trong điều kiện bình thường, đồng bộ hóa sẽ khá nhanh, thường là trong vòng vài giây hoặc lâu hơn.

00:08:36.000 --> 00:08:43.000
Tuy nhiên, nếu không có kết nối mạng hoặc nếu pin của thiết bị yếu, thì quá trình đồng bộ hóa có thể bị trì hoãn hoặc trì hoãn.

00:08:43.000 --> 00:08:51.000
Nếu thiết bị bị tải nặng, bạn không muốn cơ chế đồng bộ hóa của mình can thiệp vào các tác vụ khẩn cấp khác trong ứng dụng của bạn.

00:08:51.000 --> 00:08:58.000
Bằng cách dựa vào lịch trình tự động của công cụ đồng bộ hóa, bạn có thể tự tin rằng bạn sẽ đồng bộ hóa khi bạn nên, chứ không phải khi bạn không nên.

00:08:58.000 --> 00:09:01.000
Nó không chỉ hiệu quả hơn mà còn dễ sử dụng hơn.

00:09:01.000 --> 00:09:06.000
Nếu bạn không phải lo lắng về thời điểm đồng bộ hóa, bạn có thể tập trung vào mọi thứ khác.

00:09:06.000 --> 00:09:11.000
Điều đó nói rằng, có những trường hợp sử dụng hợp pháp để thực hiện đồng bộ hóa theo cách thủ công.

00:09:11.000 --> 00:09:14.000
Bạn có thể có giao diện người dùng kéo để làm mới tìm nạp ngay lập tức.

00:09:14.000 --> 00:09:20.000
Hoặc bạn có thể có một nút để sao lưu ngay bây giờ để ngay lập tức gửi bất kỳ thay đổi đang chờ xử lý nào đến máy chủ.

00:09:20.000 --> 00:09:24.000
Đồng bộ hóa thủ công cũng có thể hữu ích khi viết các bài kiểm tra tự động.

00:09:24.000 --> 00:09:31.000
Nó có thể giúp bạn mô phỏng các kịch bản đồng bộ hóa cụ thể trên nhiều thiết bị nơi bạn cần kiểm soát thứ tự của các sự kiện.

00:09:31.000 --> 00:09:34.000
Nói chung, chúng tôi khuyên bạn nên dựa vào lịch trình đồng bộ hóa tự động.

00:09:34.000 --> 00:09:41.000
Tuy nhiên, chúng tôi hiểu rằng có những trường hợp sử dụng hợp lệ để đồng bộ hóa thủ công và công cụ đồng bộ hóa có API để làm điều đó khi cần thiết.

00:09:41.000 --> 00:09:46.000
Và bây giờ, Aamer sẽ nói về cách bắt đầu sử dụng CKSyncEngine.

00:09:46.000 --> 00:09:49.000
Aamer: Cảm ơn vì lời giới thiệu đó, Tim.

00:09:49.000 --> 00:09:50.000
Tên tôi là Aamer.

00:09:50.000 --> 00:09:53.000
Tôi là một kỹ sư trong nhóm CloudKit Client.

00:09:53.000 --> 00:09:57.000
Bây giờ tôi sẽ đề cập đến việc bắt đầu với CKSyncEngine.

00:09:57.000 --> 00:10:03.000
Trước khi bạn sử dụng CKSyncEngine, có một vài điều bạn cần làm để thiết lập dự án của mình.

00:10:03.000 --> 00:10:10.000
Những yêu cầu này giống nhau cho dù bạn đang sử dụng CKSyncEngine hay xây dựng triển khai CloudKit tùy chỉnh của riêng mình.

00:10:10.000 --> 00:10:19.000
Đầu tiên, bạn sẽ cần kiến thức cơ bản về các loại dữ liệu cơ bản của CloudKit, CKRecord và CKRecordZone.

00:10:19.000 --> 00:10:29.000
API công cụ đồng bộ hóa xử lý rất nhiều về bản ghi và khu vực, vì vậy bạn nên hiểu chúng là gì trước khi đi sâu vào.

00:10:29.000 --> 00:10:35.000
Tiếp theo, bạn sẽ cần kích hoạt khả năng CloudKit cho dự án của mình trong Xcode.

00:10:35.000 --> 00:10:46.000
Cuối cùng, vì công cụ đồng bộ hóa dựa vào thông báo đẩy để cập nhật, bạn cũng sẽ cần bật khả năng thông báo từ xa.

00:10:46.000 --> 00:10:51.000
Khi bạn có tất cả những thứ đó, bạn đã sẵn sàng khởi tạo công cụ đồng bộ hóa của mình.

00:10:51.000 --> 00:10:56.000
Bạn nên khởi tạo CKSyncEngine của mình ngay sau khi ứng dụng của bạn khởi chạy.

00:10:56.000 --> 00:11:05.000
Khi bạn khởi tạo công cụ đồng bộ hóa của mình, nó sẽ tự động bắt đầu lắng nghe thông báo đẩy và các tác vụ lập lịch trong nền.

00:11:05.000 --> 00:11:15.000
Những thông báo và nhiệm vụ này có thể xảy ra bất cứ lúc nào và công cụ đồng bộ hóa cần được khởi tạo để xử lý chúng.

00:11:15.000 --> 00:11:24.000
Phương tiện giao tiếp chính giữa ứng dụng của bạn và CKSyncEngine là thông qua một giao thức gọi là CKSyncEngineDelegate.

00:11:24.000 --> 00:11:31.000
Khi khởi tạo công cụ đồng bộ hóa của bạn, bạn sẽ cần cung cấp một đối tượng phù hợp với giao thức này.

00:11:31.000 --> 00:11:38.000
Để hoạt động bình thường và hiệu quả, công cụ đồng bộ hóa theo dõi một số trạng thái bên trong.

00:11:38.000 --> 00:11:44.000
Bạn cũng sẽ cần cung cấp phiên bản cuối cùng được biết đến của trạng thái động cơ đồng bộ hóa.

00:11:44.000 --> 00:11:54.000
Trong khi thực hiện các thao tác đồng bộ hóa, đôi khi nó sẽ cung cấp cho đại diện của bạn một phiên bản cập nhật của trạng thái này dưới dạng sự kiện cập nhật trạng thái.

00:11:54.000 --> 00:12:00.000
Bất cứ khi nào công cụ đồng bộ cung cấp cho bạn tuần tự hóa trạng thái mới, bạn nên duy trì nó cục bộ.

00:12:00.000 --> 00:12:08.000
Bằng cách này, bạn có thể cung cấp nó vào lần khởi chạy quy trình tiếp theo và bạn khởi tạo công cụ đồng bộ hóa của mình.

00:12:08.000 --> 00:12:14.000
Để giúp hiểu điều này, tôi sẽ giải thích nó bằng cách sử dụng một vài ví dụ mã.

00:12:14.000 --> 00:12:20.000
Để khởi tạo một công cụ đồng bộ hóa, bạn sẽ chuyển một đối tượng cấu hình.

00:12:20.000 --> 00:12:29.000
Trong cấu hình, bạn sẽ cần cung cấp cơ sở dữ liệu mà bạn muốn đồng bộ hóa, phiên bản cuối cùng được biết đến của trạng thái công cụ đồng bộ hóa và đại diện của bạn.

00:12:29.000 --> 00:12:35.000
Một trong những chức năng trong giao thức đại diện là chức năng xử lý sự kiện.

00:12:35.000 --> 00:12:42.000
Chức năng này là cách công cụ đồng bộ thông báo cho ứng dụng của bạn về các sự kiện khác nhau xảy ra trong quá trình hoạt động đồng bộ hóa bình thường.

00:12:42.000 --> 00:12:51.000
Ví dụ, nó sẽ đăng các sự kiện khi tìm nạp dữ liệu mới từ máy chủ hoặc khi tài khoản thay đổi.

00:12:51.000 --> 00:12:55.000
Một trong những sự kiện này là sự kiện cập nhật trạng thái.

00:12:55.000 --> 00:13:04.000
Khi công cụ đồng bộ cập nhật trạng thái bên trong của nó hoặc khi bạn tự cập nhật trạng thái, công cụ đồng bộ sẽ đăng một sự kiện cập nhật trạng thái.

00:13:04.000 --> 00:13:11.000
Để đáp lại sự kiện này, bạn nên duy trì cục bộ phiên bản tuần tự mới này của trạng thái.

00:13:11.000 --> 00:13:17.000
Trong ví dụ, bạn sẽ sử dụng tuần tự hóa trạng thái này vào lần tới khi bạn khởi tạo công cụ đồng bộ hóa của mình.

00:13:17.000 --> 00:13:23.000
Bây giờ nền tảng đã được thiết lập, tôi sẽ đề cập đến việc đồng bộ hóa với công cụ đồng bộ hóa.

00:13:23.000 --> 00:13:28.000
Có một vài bước đơn giản cho phép bạn gửi các thay đổi đến máy chủ.

00:13:28.000 --> 00:13:36.000
Đầu tiên, thêm các thay đổi vùng bản ghi đang chờ xử lý của bạn và các thay đổi cơ sở dữ liệu đang chờ xử lý vào trạng thái công cụ đồng bộ hóa.

00:13:36.000 --> 00:13:41.000
Điều này sẽ cảnh báo công cụ đồng bộ hóa rằng nó nên lên lịch đồng bộ hóa.

00:13:41.000 --> 00:13:48.000
Công cụ đồng bộ hóa sẽ đảm bảo tính nhất quán và sao chép những thay đổi này.

00:13:48.000 --> 00:13:54.000
Tiếp theo, triển khai phương thức đại diện nextRecordZoneChangeBatch.

00:13:54.000 --> 00:14:00.000
Công cụ đồng bộ hóa sẽ gọi điều này để nhận đợt thay đổi vùng ghi tiếp theo để gửi đến máy chủ.

00:14:00.000 --> 00:14:07.000
Cuối cùng, xử lý các sự kiện sentDatabaseChanges và sentRecordZoneChanges.

00:14:07.000 --> 00:14:13.000
Những sự kiện này sẽ được đăng khi các thay đổi được gửi đến máy chủ.

00:14:13.000 --> 00:14:17.000
Đây là một ví dụ về việc gửi các thay đổi đến máy chủ.

00:14:17.000 --> 00:14:22.000
Ứng dụng này chỉnh sửa dữ liệu và muốn đồng bộ hóa các thay đổi bản ghi mới.

00:14:22.000 --> 00:14:31.000
Để làm điều này, bạn sẽ nói với công cụ đồng bộ hóa rằng bạn cần lưu bản ghi đó bằng cách thêm thay đổi vùng bản ghi đang chờ xử lý vào trạng thái công cụ đồng bộ hóa.

00:14:31.000 --> 00:14:38.000
Khi công cụ đồng bộ hóa đã sẵn sàng để đồng bộ hóa bản ghi, nó sẽ gọi phương thức đại diện nextRecordZoneChangeBatch.

00:14:38.000 --> 00:14:44.000
Tại đây bạn sẽ trả lại lô thay đổi tiếp theo để gửi đến máy chủ.

00:14:44.000 --> 00:14:52.000
Bạn khởi tạo RecordZoneChangeBatch bằng cách cung cấp danh sách các thay đổi đang chờ xử lý và nhà cung cấp bản ghi.

00:14:52.000 --> 00:15:03.000
Danh sách các thay đổi đang chờ xử lý chứa các recordID cần lưu hoặc xóa và nhà cung cấp bản ghi sẽ ánh xạ các ID đó vào các bản ghi khi quá trình đồng bộ hóa thực tế xảy ra.

00:15:03.000 --> 00:15:07.000
Đây là cách ứng dụng của bạn có thể tìm nạp các thay đổi từ máy chủ.

00:15:07.000 --> 00:15:13.000
Công cụ đồng bộ hóa tự động tìm nạp các thay đổi cho bạn từ máy chủ.

00:15:13.000 --> 00:15:21.000
Khi nó xảy ra, nó sẽ đăng các sự kiện fetchedDatabaseChanges và fetchedRecordZoneChanges.

00:15:21.000 --> 00:15:29.000
Tùy thuộc vào trường hợp sử dụng của bạn, bạn có thể muốn nghe các sự kiện willFetchChanges và didFetchChanges.

00:15:29.000 --> 00:15:39.000
Ví dụ, việc xử lý các sự kiện này có thể hữu ích nếu bạn muốn thực hiện bất kỳ tác vụ thiết lập hoặc dọn dẹp nào trước hoặc sau khi tìm nạp các thay đổi.

00:15:39.000 --> 00:15:44.000
Đây là một ví dụ trong đó ứng dụng của chúng tôi tìm nạp các thay đổi từ máy chủ.

00:15:44.000 --> 00:15:51.000
Khi công cụ đồng bộ tìm nạp các thay đổi trong vùng bản ghi, nó sẽ đăng sự kiện fetchedRecordZoneChanges.

00:15:51.000 --> 00:15:58.000
Sự kiện này chứa các sửa đổi và xóa được thực hiện bởi một thiết bị khác.

00:15:58.000 --> 00:16:04.000
Khi nghe điều này, bạn nên kiểm tra các sửa đổi đã tìm nạp và xóa đã tìm nạp.

00:16:04.000 --> 00:16:09.000
Khi bạn nhận được các sửa đổi, bạn nên duy trì dữ liệu cục bộ.

00:16:09.000 --> 00:16:15.000
Khi bạn nhận được việc xóa, bạn nên xóa dữ liệu cục bộ.

00:16:15.000 --> 00:16:21.000
Tìm nạp các thay đổi cơ sở dữ liệu hoạt động rất giống nhau và có thể được xử lý với cùng một cách tiếp cận.

00:16:21.000 --> 00:16:24.000
Xử lý lỗi có thể khó khăn.

00:16:24.000 --> 00:16:26.000
Công cụ đồng bộ cũng giúp ích cho việc này.

00:16:26.000 --> 00:16:35.000
Công cụ đồng bộ hóa tự động xử lý các lỗi tạm thời như sự cố mạng, điều chỉnh và sự cố tài khoản.

00:16:35.000 --> 00:16:41.000
Công cụ đồng bộ hóa sẽ tự động thử lại công việc bị ảnh hưởng bởi những lỗi này.

00:16:41.000 --> 00:16:45.000
Đối với các lỗi khác, ứng dụng của bạn sẽ cần xử lý chúng.

00:16:45.000 --> 00:16:51.000
Khi bạn đã giải quyết được những lỗi đó, bạn nên lên lịch lại công việc nếu cần thiết.

00:16:51.000 --> 00:16:57.000
Đây là một ví dụ về việc xử lý lỗi khi gửi thay đổi vùng bản ghi.

00:16:57.000 --> 00:17:06.000
Khi sự kiện sentRecordZoneChanges được đăng, bạn nên kiểm tra failedRecordSaves để xem có bất kỳ bản ghi nào không lưu được không.

00:17:06.000 --> 00:17:10.000
serverRecordChanged chỉ ra rằng bản ghi đã thay đổi trên máy chủ.

00:17:10.000 --> 00:17:16.000
Điều này có nghĩa là một thiết bị khác đã lưu một phiên bản mới mà ứng dụng chưa tìm nạp.

00:17:16.000 --> 00:17:21.000
Bạn nên giải quyết xung đột và lên lịch lại công việc.

00:17:21.000 --> 00:17:26.000
zoneNotFound chỉ ra rằng vùng chưa tồn tại trên máy chủ.

00:17:26.000 --> 00:17:32.000
Để giải quyết vấn đề này, bạn có thể cần tạo khu vực và sau đó lên lịch lại công việc.

00:17:32.000 --> 00:17:38.000
Công cụ đồng bộ hóa sẽ luôn cố gắng lưu các vùng trước, và sau đó ghi lại.

00:17:38.000 --> 00:17:49.000
networkFailure, networkUnavailable, serviceUnavailable, và requestRateLimited là những ví dụ về lỗi tạm thời mà công cụ đồng bộ hóa sẽ xử lý cho bạn.

00:17:49.000 --> 00:17:56.000
Bạn vẫn sẽ nhận được những lỗi này cho nhận thức của mình nhưng bạn không cần phải hành động để đáp lại chúng.

00:17:56.000 --> 00:18:03.000
Công cụ đồng bộ hóa sẽ tự động thử lại những lỗi này khi điều kiện hệ thống cho phép.

00:18:03.000 --> 00:18:07.000
Một điều khác mà công cụ đồng bộ hóa giúp đỡ là thay đổi tài khoản.

00:18:07.000 --> 00:18:11.000
Thay đổi tài khoản iCloud có thể xảy ra bất cứ lúc nào trên thiết bị.

00:18:11.000 --> 00:18:16.000
Công cụ đồng bộ hóa giúp bạn quản lý và phản ứng với những thứ này.

00:18:16.000 --> 00:18:28.000
Công cụ đồng bộ lắng nghe các thay đổi và sẽ thông báo cho bạn bằng cách sử dụng sự kiện Thay đổi tài khoản để cho biết đăng nhập, đăng xuất hoặc tài khoản đã chuyển đổi.

00:18:28.000 --> 00:18:34.000
Đơn đăng ký của bạn nên chuẩn bị cho sự thay đổi tùy thuộc vào loại.

00:18:34.000 --> 00:18:42.000
Công cụ đồng bộ hóa sẽ không bắt đầu đồng bộ hóa với iCloud cho đến khi có tài khoản trên thiết bị.

00:18:42.000 --> 00:18:49.000
Bạn có thể khởi tạo công cụ đồng bộ hóa bất cứ lúc nào và nó sẽ tự động cập nhật cho bạn khi có thay đổi tài khoản.

00:18:49.000 --> 00:18:54.000
Chia sẻ dữ liệu với những người dùng khác là một phần quan trọng của CloudKit.

00:18:54.000 --> 00:18:58.000
Động cơ đồng bộ hóa cũng giúp cuộc sống ở đây dễ dàng hơn.

00:18:58.000 --> 00:19:03.000
Công cụ đồng bộ hóa hoạt động với cơ sở dữ liệu được chia sẻ CloudKit.

00:19:03.000 --> 00:19:08.000
Bạn chỉ cần tạo một công cụ đồng bộ hóa cho mỗi cơ sở dữ liệu mà ứng dụng của bạn sẽ hoạt động.

00:19:08.000 --> 00:19:16.000
Ví dụ, bạn có thể tạo một công cụ đồng bộ hóa cho cơ sở dữ liệu riêng tư và một công cụ đồng bộ hóa khác cho cơ sở dữ liệu được chia sẻ.

00:19:16.000 --> 00:19:24.000
Để tìm hiểu thêm về việc chia sẻ với CloudKit, hãy xem Cuộc nói chuyện công nghệ "Tối đa việc chia sẻ trên CloudKit".

00:19:24.000 --> 00:19:27.000
Điều đó bao gồm việc sử dụng CKSyncEngine.

00:19:27.000 --> 00:19:32.000
Bây giờ tôi sẽ đề cập đến cách kiểm tra khi sử dụng nó.

00:19:32.000 --> 00:19:38.000
Kiểm tra tự động là cách tốt nhất để đảm bảo sự ổn định trong cơ sở mã của bạn trong khi phát triển nhanh chóng.

00:19:38.000 --> 00:19:48.000
Sử dụng công cụ đồng bộ hóa, bạn có thể mô phỏng luồng người dùng từ thiết bị đến thiết bị bằng cách sử dụng nhiều phiên bản CKSyncEngine.

00:19:48.000 --> 00:19:52.000
Bạn nên mô phỏng các trường hợp cạnh mà ứng dụng của bạn có thể gặp phải.

00:19:52.000 --> 00:20:00.000
Để làm điều này, bạn có thể can thiệp vào luồng động cơ đồng bộ hóa bằng cách đặt tự động Đồng bộ hóa thành sai.

00:20:00.000 --> 00:20:07.000
Đây là một trường hợp thử nghiệm mô phỏng xung đột dữ liệu giữa hai thiết bị và máy chủ.

00:20:07.000 --> 00:20:13.000
Mục đích của bài kiểm tra này là mô phỏng toàn bộ luồng mà người dùng sẽ thực hiện khi làm việc với nhiều thiết bị.

00:20:13.000 --> 00:20:18.000
Nó cũng xác nhận giải quyết xung đột.

00:20:18.000 --> 00:20:24.000
Đầu tiên, mô phỏng hai thiết bị sử dụng MySyncManager.

00:20:24.000 --> 00:20:30.000
Trong ví dụ này, MySyncManager tạo ra một cơ sở dữ liệu cục bộ và công cụ đồng bộ hóa.

00:20:30.000 --> 00:20:37.000
Thiết bị A đặt giá trị thành A và gửi các thay đổi của nó đến máy chủ.

00:20:37.000 --> 00:20:44.000
Trước khi thiết bị B tìm nạp các thay đổi từ máy chủ, chúng tôi cũng sẽ yêu cầu nó gửi các thay đổi đến máy chủ.

00:20:44.000 --> 00:20:51.000
Vì thiết bị A được lưu vào máy chủ trước, việc lưu thiết bị B dự kiến sẽ thất bại.

00:20:51.000 --> 00:20:59.000
Điều này sẽ dẫn đến lỗi thay đổi bản ghi máy chủ, lỗi này sẽ thực hiện mã giải quyết xung đột cục bộ.

00:20:59.000 --> 00:21:11.000
Mẫu này hy vọng giải quyết xung đột sẽ ưu tiên dữ liệu từ máy chủ, vì vậy giá trị mới trên thiết bị B sẽ là giá trị được gửi đến máy chủ gần đây nhất từ thiết bị A.

00:21:11.000 --> 00:21:17.000
Dưới đây là một vài điểm chính có thể giúp tăng tốc độ kiểm tra và gỡ lỗi.

00:21:17.000 --> 00:21:25.000
Hiểu được chuỗi sự kiện trên mỗi thiết bị sẽ giúp xác định chính xác vị trí mà ứng dụng của bạn có thể gặp sự cố.

00:21:25.000 --> 00:21:34.000
Ghi nhật ký càng nhiều càng tốt khi phát triển sẽ giúp theo dõi các luồng này và so sánh nhật ký trên nhiều thiết bị.

00:21:34.000 --> 00:21:43.000
CloudKit sẽ ghi lại từng sự kiện mà bạn nhận được, nhưng bạn cũng nên ghi lại các hành động xung quanh chúng trong ứng dụng của mình.

00:21:43.000 --> 00:21:55.000
Ghi nhật ký ID bản ghi và ID vùng có thể giúp gỡ lỗi dữ liệu nào đang chảy giữa công cụ đồng bộ hóa, máy chủ và các thiết bị khác mà bạn có thể đang đồng bộ hóa.

00:21:55.000 --> 00:22:03.000
Viết các bài kiểm tra mô phỏng từng luồng người dùng của bạn sẽ giúp duy trì sự ổn định khi bạn phát triển cơ sở mã của mình.

00:22:03.000 --> 00:22:07.000
Nhìn vào dấu thời gian khi ghép câu đố lại với nhau.

00:22:07.000 --> 00:22:13.000
Bạn có thể chỉ có một vài thao tác đồng bộ đang diễn ra hoặc bạn có thể có nhiều thao tác trong một thời gian ngắn.

00:22:13.000 --> 00:22:19.000
Đảm bảo bạn đang truy tìm đúng thiết bị là chìa khóa để gỡ lỗi giữa nhiều thiết bị.

00:22:19.000 --> 00:22:28.000
Các bước này sẽ giúp tạo và duy trì một ứng dụng đáng tin cậy, lâu dài bằng CKSyncEngine.

00:22:28.000 --> 00:22:31.000
Điều đó kết thúc cuộc nói chuyện của chúng tôi trên CKSyncEngine.

00:22:31.000 --> 00:22:36.000
Hãy xem mã mẫu công cụ đồng bộ hóa để xem ví dụ hoạt động đầy đủ trong một ứng dụng.

00:22:36.000 --> 00:22:41.000
Để tìm hiểu sâu hơn, hãy xem tài liệu CKSyncEngine của chúng tôi.

00:22:41.000 --> 00:22:47.000
Nếu bạn có bất kỳ đề xuất nào để cải thiện công cụ đồng bộ hóa, vui lòng gửi phản hồi cho nhóm CloudKit.

00:22:47.000 --> 00:22:51.000
Chúng tôi rất vui khi thấy những gì bạn tạo ra với nó.

00:22:51.000 --> 00:22:55.000
Cảm ơn vì đã xem. Chúc một WWDC tuyệt vời!

00:22:55.000 --> 23:59:59.000
♪ ♪

