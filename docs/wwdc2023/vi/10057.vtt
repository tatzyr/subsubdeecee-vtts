WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:13.000
Tyler: Chào mừng đến với "Giải phóng Hệ thống Đặc điểm UIKit."

00:00:13.000 --> 00:00:23.000
Tôi là Tyler Fox, một kỹ sư khung giao diện người dùng và tôi rất vui được nói với bạn về một số tính năng UIKit mới đáng kinh ngạc mà bạn có thể tận dụng trong iOS 17.

00:00:23.000 --> 00:00:28.000
Để bắt đầu, tôi sẽ xem xét các nguyên tắc cơ bản về hệ thống đặc điểm trong UIKit.

00:00:28.000 --> 00:00:46.000
Sau đó, tôi sẽ hướng dẫn bạn các tính năng và khả năng mới, bao gồm khả năng xác định các đặc điểm tùy chỉnh để thêm dữ liệu của riêng bạn vào UITraitCollection, các cách dễ dàng hơn để áp dụng ghi đè đặc điểm trong hệ thống phân cấp ứng dụng của bạn và các cách linh hoạt hơn để xử lý khi các đặc điểm thay đổi.

00:00:46.000 --> 00:00:57.000
Cuối cùng, tôi sẽ giải thích cách bạn có thể kết nối các đặc điểm UIKit với các khóa môi trường SwiftUI để chuyển dữ liệu liền mạch giữa các thành phần UIKit và SwiftUI trong ứng dụng của bạn.

00:00:57.000 --> 00:01:00.000
Đã đến lúc xem lại một số nguyên tắc cơ bản.

00:01:00.000 --> 00:01:08.000
Đặc điểm là những mẩu dữ liệu độc lập mà hệ thống tự động truyền đến mọi bộ điều khiển chế độ xem và chế độ xem trong ứng dụng của bạn.

00:01:08.000 --> 00:01:18.000
UIKit cung cấp nhiều đặc điểm hệ thống tích hợp, chẳng hạn như kiểu giao diện người dùng, lớp kích thước ngang và danh mục kích thước nội dung ưa thích.

00:01:18.000 --> 00:01:23.000
Trong iOS 17, bạn cũng có thể xác định các đặc điểm tùy chỉnh của riêng mình.

00:01:23.000 --> 00:01:30.000
Điều này mở ra một cách mới mạnh mẽ để bạn cung cấp dữ liệu cho bộ điều khiển chế độ xem và chế độ xem của ứng dụng.

00:01:30.000 --> 00:01:34.000
Tôi sẽ cho bạn biết tất cả về các đặc điểm tùy chỉnh một lát sau.

00:01:34.000 --> 00:01:39.000
Cách chính mà bạn làm việc với các đặc điểm trong UIKit là sử dụng các bộ sưu tập đặc điểm.

00:01:39.000 --> 00:01:44.000
Một bộ sưu tập đặc điểm chứa các đặc điểm và giá trị liên quan của chúng.

00:01:44.000 --> 00:01:50.000
Có một số API mới trong iOS 17 giúp làm việc với các bộ sưu tập đặc điểm dễ dàng hơn.

00:01:50.000 --> 00:01:54.000
Đầu tiên, có một trình khởi tạo mới cần đóng cửa.

00:01:54.000 --> 00:02:01.000
Bên trong đóng cửa đó, bạn nhận được một vùng chứa các đặc điểm có thể thay đổi mà bạn có thể đặt các giá trị thành.

00:02:01.000 --> 00:02:08.000
Vùng chứa có thể thay đổi này phù hợp với một giao thức mới có tên UIMutableTraits.

00:02:08.000 --> 00:02:15.000
Bên trong phần đóng, tôi đặt thành ngữ giao diện người dùng thành điện thoại và lớp kích thước ngang thành thông thường.

00:02:15.000 --> 00:02:26.000
Khi việc đóng kết thúc việc thực thi, trình khởi tạo sẽ trả về một phiên bản UITraitCollection bất biến chứa tất cả các giá trị đặc điểm mà tôi đã đặt bên trong việc đóng.

00:02:26.000 --> 00:02:37.000
Ngoài ra còn có một phương thức modifyingTraits mới cho phép bạn tạo một phiên bản mới bằng cách sửa đổi các giá trị từ bộ sưu tập đặc điểm ban đầu bên trong đóng cửa.

00:02:37.000 --> 00:02:46.000
Ở đây tôi đã thay đổi lớp kích thước ngang thành nhỏ gọn và tôi đã điền một giá trị tối cho kiểu giao diện người dùng.

00:02:46.000 --> 00:02:55.000
Vì tôi chưa thay đổi thành ngữ giao diện người dùng, nó vẫn bằng điện thoại từ bộ sưu tập đặc điểm ban đầu của tôi.

00:02:55.000 --> 00:03:03.000
Mặc dù bạn có thể tạo các bộ sưu tập đặc điểm của riêng mình như thế này, nhưng hầu hết thời gian bạn có được các bộ sưu tập đặc điểm từ môi trường đặc điểm.

00:03:03.000 --> 00:03:11.000
Môi trường đặc điểm trong ứng dụng của bạn là cảnh cửa sổ, cửa sổ, bộ điều khiển bản trình bày, bộ điều khiển chế độ xem và chế độ xem.

00:03:11.000 --> 00:03:20.000
Mỗi môi trường đặc điểm này đều có bộ sưu tập đặc điểm riêng và mỗi bộ sưu tập đặc điểm có thể chứa các giá trị khác nhau.

00:03:20.000 --> 00:03:27.000
Môi trường đặc điểm được kết nối trong hệ thống phân cấp đặc điểm, đó là cách các đặc điểm chảy qua ứng dụng của bạn.

00:03:27.000 --> 00:03:36.000
Đây là một ví dụ về cấu trúc cây của hệ thống phân cấp đặc điểm, từ mỗi cảnh cửa sổ cho đến các bộ điều khiển và chế độ xem riêng lẻ.

00:03:36.000 --> 00:03:41.000
Mỗi môi trường đặc điểm kế thừa các giá trị đặc điểm từ môi trường mẹ của nó.

00:03:41.000 --> 00:03:47.000
Luôn sử dụng bộ sưu tập đặc điểm của môi trường đặc điểm cụ thể nhất có thể.

00:03:47.000 --> 00:03:55.000
Tôi sẽ đi sâu hơn vào cách các đặc điểm chảy qua bộ điều khiển chế độ xem và chế độ xem.

00:03:55.000 --> 00:04:00.000
Đây là một ví dụ về bộ điều khiển chế độ xem mẹ, chứa bộ điều khiển chế độ xem con.

00:04:00.000 --> 00:04:04.000
Đường đứt nét đại diện cho hệ thống phân cấp bộ điều khiển chế độ xem.

00:04:04.000 --> 00:04:11.000
Bộ điều khiển mẹ sở hữu một chế độ xem và đường liền nét kết nối chúng đại diện cho mối quan hệ của chúng.

00:04:11.000 --> 00:04:19.000
Chế độ xem mẹ có một chế độ xem con và đường đứt nét xuyên qua chế độ xem đại diện cho hệ thống phân cấp chế độ xem.

00:04:19.000 --> 00:04:25.000
Cuối cùng, chế độ xem của bộ điều khiển con là chế độ xem phụ của chế độ xem giữa đó.

00:04:25.000 --> 00:04:33.000
Đầu tiên tôi sẽ giải thích cách các đặc điểm chảy qua bộ điều khiển chế độ xem và chế độ xem trước iOS 17.

00:04:33.000 --> 00:04:38.000
Bộ điều khiển chế độ xem các đặc điểm được thừa hưởng trực tiếp từ bộ điều khiển chế độ xem mẹ của chúng.

00:04:38.000 --> 00:04:45.000
Và các chế độ xem thuộc sở hữu của bộ điều khiển chế độ xem thừa hưởng các đặc điểm của họ trực tiếp từ bộ điều khiển chế độ xem của họ.

00:04:45.000 --> 00:04:52.000
Cuối cùng, các chế độ xem không có bộ điều khiển chế độ xem thừa hưởng các đặc điểm trực tiếp từ chế độ xem của chúng.

00:04:52.000 --> 00:04:59.000
Hành vi này có nghĩa là dòng chảy của các đặc điểm trong hệ thống phân cấp chế độ xem dừng lại ở mỗi chế độ xem thuộc sở hữu của bộ điều khiển chế độ xem.

00:04:59.000 --> 00:05:07.000
Ví dụ, một giá trị đặc điểm từ chế độ xem của bộ điều khiển mẹ sẽ chỉ được kế thừa bởi chế độ xem phụ trực tiếp của nó.

00:05:07.000 --> 00:05:15.000
Chế độ xem của bộ điều khiển con sẽ không nhận được giá trị đó, mặc dù nó là chế độ xem con trong hệ thống phân cấp chế độ xem bên dưới các chế độ xem đó.

00:05:15.000 --> 00:05:18.000
Hành vi này có thể gây ngạc nhiên.

00:05:18.000 --> 00:05:27.000
Trong iOS 17, chúng tôi đã loại bỏ vấn đề này bằng cách thống nhất hệ thống phân cấp đặc điểm cho bộ điều khiển chế độ xem và chế độ xem.

00:05:27.000 --> 00:05:35.000
Bộ điều khiển chế độ xem hiện kế thừa bộ sưu tập đặc điểm của họ từ chế độ xem của chế độ xem, thay vì trực tiếp từ bộ điều khiển chế độ xem mẹ của chúng.

00:05:35.000 --> 00:05:42.000
Điều này tạo ra một dòng chảy tuyến tính đơn giản của các đặc điểm thông qua bộ điều khiển chế độ xem và chế độ xem.

00:05:42.000 --> 00:05:50.000
Lưu ý cách bộ điều khiển chế độ xem vẫn kế thừa các đặc điểm từ bộ điều khiển chế độ xem mẹ của chúng, nó chỉ xảy ra gián tiếp thông qua các chế độ xem ở giữa chúng.

00:05:50.000 --> 00:06:02.000
Bởi vì các bộ điều khiển chế độ xem hiện kế thừa các đặc điểm của họ từ hệ thống phân cấp chế độ xem, chế độ xem của bộ điều khiển chế độ xem phải nằm trong hệ thống phân cấp để bộ điều khiển chế độ xem nhận được các đặc điểm cập nhật.

00:06:02.000 --> 00:06:12.000
Kết quả là, nếu bạn truy cập bộ sưu tập đặc điểm của bộ điều khiển chế độ xem trước khi chế độ xem của nó được thêm vào hệ thống phân cấp, bộ điều khiển chế độ xem sẽ không có các giá trị cập nhật cho các đặc điểm của nó.

00:06:12.000 --> 00:06:23.000
Nơi phổ biến nhất mà bạn có thể tìm thấy mã bị ảnh hưởng là bên trong viewWillAppear, vì nó luôn được gọi trước khi chế độ xem được thêm vào hệ thống phân cấp.

00:06:23.000 --> 00:06:29.000
Có một cuộc gọi lại mới có tên viewIsAppearing mà bạn có thể sử dụng thay thế.

00:06:29.000 --> 00:06:40.000
viewIsAppearing được gọi sau viewWillAppear khi chế độ xem đã được thêm vào hệ thống phân cấp và cả bộ điều khiển chế độ xem và chế độ xem đều có bộ sưu tập đặc điểm cập nhật.

00:06:40.000 --> 00:06:47.000
viewIsAppearing là một sự thay thế thả vào cho gần như tất cả các trường hợp mà bạn đang sử dụng viewWillAppear hôm nay.

00:06:47.000 --> 00:06:54.000
Và phần hay nhất là phương pháp mới này triển khai lại cho iOS 13.

00:06:54.000 --> 00:07:03.000
Xem "Có gì mới trong UIKit" để tìm hiểu thêm về cuộc gọi lại mới này và cách nó phù hợp với vòng đời của bộ điều khiển chế độ xem.

00:07:03.000 --> 00:07:09.000
iOS 17 cũng cải thiện tính nhất quán và hiệu suất để cập nhật đặc điểm chế độ xem.

00:07:09.000 --> 00:07:13.000
Lượt xem chỉ cập nhật bộ sưu tập đặc điểm của họ khi họ ở trong hệ thống phân cấp.

00:07:13.000 --> 00:07:20.000
Và một khi ở trong hệ thống phân cấp, mỗi chế độ xem chỉ cập nhật bộ sưu tập đặc điểm của nó ngay lập tức trước khi nó thực hiện bố cục.

00:07:20.000 --> 00:07:24.000
Cách thực hành tốt nhất là sử dụng các đặc điểm trong quá trình bố trí.

00:07:24.000 --> 00:07:31.000
Đối với chế độ xem, điều đó có nghĩa là sử dụng traitCollection từ bên trong phương thức layoutSubviews.

00:07:31.000 --> 00:07:43.000
Hãy nhớ rằng layoutSubviews chạy lại bất cứ lúc nào setNeedsLayout được gọi trên chế độ xem, vì vậy việc triển khai của bạn sẽ tránh trùng lặp công việc nếu được gọi nhiều lần.

00:07:43.000 --> 00:07:48.000
Các đặc điểm tùy chỉnh là một tính năng mới mạnh mẽ trong iOS 17.

00:07:48.000 --> 00:07:54.000
Chúng mở ra một cách hoàn toàn mới để bạn cung cấp dữ liệu cho bộ điều khiển chế độ xem và chế độ xem của mình.

00:07:54.000 --> 00:08:02.000
Khi bạn làm việc với dữ liệu trong ứng dụng của mình, hãy xem xét những điều sau đây để giúp bạn quyết định khi nào nên xác định một đặc điểm tùy chỉnh mới.

00:08:02.000 --> 00:08:13.000
Đặc điểm là một lựa chọn tuyệt vời khi bạn cần truyền dữ liệu đến nhiều trẻ em, chẳng hạn như từ bộ điều khiển chế độ xem mẹ đến nhiều bộ điều khiển chế độ xem con hoặc từ chế độ xem trên đến tất cả các chế độ xem con của nó.

00:08:13.000 --> 00:08:22.000
Bạn cũng có thể sử dụng các đặc điểm để truyền dữ liệu đến các thành phần khác có thể được lồng sâu nhiều lớp, nơi bạn không có kết nối trực tiếp với chúng.

00:08:22.000 --> 00:08:35.000
Bởi vì các đặc điểm được kế thừa thông qua hệ thống phân cấp, chúng có thể cung cấp bối cảnh cho quan điểm của bạn và bộ điều khiển chế độ xem về môi trường của chúng, chẳng hạn như cung cấp thông tin về bộ điều khiển chế độ xem chứa.

00:08:35.000 --> 00:08:40.000
Mặc dù hệ thống đặc điểm rất mạnh, nhưng việc sử dụng nó để truyền dữ liệu không miễn phí.

00:08:40.000 --> 00:08:48.000
Để có hiệu suất tốt nhất, hãy sử dụng các đặc điểm khi chúng tăng thêm giá trị, nhưng tránh sử dụng các đặc điểm khi bạn có thể dễ dàng truyền dữ liệu trực tiếp.

00:08:48.000 --> 00:08:52.000
Bây giờ bạn đã sẵn sàng để xác định đặc điểm tùy chỉnh đầu tiên của mình.

00:08:52.000 --> 00:09:02.000
Hãy tưởng tượng rằng tôi có màn hình Cài đặt trong ứng dụng của mình và tôi muốn triển khai một đặc điểm cho biết liệu chế độ xem có được chứa bên trong bộ điều khiển chế độ xem Cài đặt của tôi hay không.

00:09:02.000 --> 00:09:06.000
Tôi có thể xác định một đặc điểm tùy chỉnh chỉ với một vài dòng mã.

00:09:06.000 --> 00:09:12.000
Để bắt đầu, tôi khai báo một cấu trúc mới và tuân thủ giao thức UITraitDefinition.

00:09:12.000 --> 00:09:17.000
Tôi triển khai một thuộc tính tĩnh bắt buộc, defaultValue.

00:09:17.000 --> 00:09:21.000
Đây là giá trị mặc định cho đặc điểm khi không có giá trị nào được đặt.

00:09:21.000 --> 00:09:28.000
Mỗi định nghĩa đặc điểm có một loại giá trị liên quan, được suy ra từ Giá trị mặc định.

00:09:28.000 --> 00:09:37.000
Trong trường hợp này, vì tôi đang gán Giá trị mặc định là sai, loại giá trị của đặc điểm này được suy ra là Bool.

00:09:37.000 --> 00:09:45.000
Nếu bạn đã từng xác định khóa môi trường tùy chỉnh trong SwiftUI trước đây, điều này sẽ cảm thấy rất quen thuộc.

00:09:45.000 --> 00:09:52.000
Khi bạn đã xác định được một đặc điểm, bạn có thể sử dụng nó ngay lập tức với các API mới trên UITraitCollection và UIMutableTraits.

00:09:52.000 --> 00:09:58.000
Bạn có thể nghĩ về đặc điểm như một chìa khóa mà bạn sử dụng để lấy và đặt các giá trị.

00:09:58.000 --> 00:10:08.000
Bên trong trình khởi tạo UITraitCollection mới, tôi có thể đặt giá trị cho đặc điểm của mình bằng cách sử dụng toán tử chỉ số trên UIMutableTraits.

00:10:08.000 --> 00:10:15.000
Và sau đó tôi có thể đọc lại giá trị cho đặc điểm bằng cách sử dụng toán tử chỉ số trên UITraitCollection.

00:10:15.000 --> 00:10:24.000
Thêm hai tiện ích mở rộng đơn giản sẽ cho phép tôi truy cập đặc điểm này bằng cú pháp thuộc tính tiêu chuẩn, giống như tất cả các đặc điểm của hệ thống.

00:10:24.000 --> 00:10:31.000
Ở đây tôi đã khai báo một thuộc tính chỉ đọc trong một phần mở rộng của lớp UITraitCollection bất biến.

00:10:31.000 --> 00:10:38.000
Và sau đó tôi đã khai báo một thuộc tính đọc-ghi trong một phần mở rộng của giao thức UIMutableTraits.

00:10:38.000 --> 00:10:46.000
Bây giờ tôi đã thêm các tiện ích mở rộng rất đơn giản này, tôi có thể sử dụng cú pháp thuộc tính tiêu chuẩn để truy cập đặc điểm của mình ở mọi nơi.

00:10:46.000 --> 00:10:52.000
Luôn viết các tiện ích mở rộng này khi bạn xác định các đặc điểm tùy chỉnh của riêng mình.

00:10:52.000 --> 00:10:55.000
Tôi có một ý tưởng cho một đặc điểm tùy chỉnh khác.

00:10:55.000 --> 00:10:59.000
Hãy tưởng tượng tôi đang xây dựng hỗ trợ cho các chủ đề màu tùy chỉnh trong ứng dụng của mình.

00:10:59.000 --> 00:11:08.000
Tôi có một enum tên là MyAppTheme đại diện cho bốn chủ đề màu sắc khác nhau mà ứng dụng của tôi hỗ trợ.

00:11:08.000 --> 00:11:15.000
Điều đầu tiên tôi sẽ làm là khai báo một cấu trúc mới phù hợp với giao thức UITraitDefinition.

00:11:15.000 --> 00:11:20.000
Tôi sẽ sử dụng chủ đề tiêu chuẩn làm giá trị mặc định cho đặc điểm này.

00:11:20.000 --> 00:11:34.000
Vì tôi dự định sử dụng đặc điểm chủ đề mới này trong các màu động tùy chỉnh của ứng dụng của mình, tôi chỉ ra rằng đặc điểm này ảnh hưởng đến giao diện màu sắc và hệ thống sẽ tự động vẽ lại chế độ xem khi đặc điểm này thay đổi.

00:11:34.000 --> 00:11:43.000
Các đặc điểm ảnh hưởng đến ngoại hình màu sắc đắt hơn nhiều, vì vậy hãy sử dụng điều này một cách tiết kiệm và chỉ cho những đặc điểm thay đổi không thường xuyên.

00:11:43.000 --> 00:11:48.000
Các đặc điểm cũng có tên, được sử dụng cho những thứ như in đặc điểm trong trình gỡ lỗi.

00:11:48.000 --> 00:11:59.000
Theo mặc định, nó sẽ sử dụng tên của chính loại đặc điểm, nhưng tôi có thể đặt cho nó một cái tên ngắn hơn, như "Chủ đề". Và cuối cùng, tôi có thể cung cấp một chuỗi nhận dạng.

00:11:59.000 --> 00:12:04.000
Mã định danh làm cho đặc điểm đủ điều kiện cho các tính năng bổ sung như mã hóa.

00:12:04.000 --> 00:12:12.000
Sử dụng định dạng DNS ngược để đảm bảo số nhận dạng của mỗi đặc điểm là duy nhất trên toàn cầu trong ứng dụng của bạn.

00:12:12.000 --> 00:12:25.000
Tôi muốn có thể sử dụng cú pháp thuộc tính thông thường để đặt và lấy đặc điểm này, vì vậy tôi sẽ mở rộng UITraitCollection và UIMutableTraits để khai báo một thuộc tính, giống như tôi đã làm trước đây trong ví dụ trước.

00:12:25.000 --> 00:12:29.000
Và đó là tất cả những gì tôi cần làm để thực hiện một đặc điểm chủ đề tùy chỉnh.

00:12:29.000 --> 00:12:32.000
Bây giờ tôi có thể bắt đầu sử dụng đặc điểm mới này.

00:12:32.000 --> 00:12:40.000
Ví dụ, đây là cách xác định màu động tùy chỉnh thay đổi giao diện của nó dựa trên chủ đề.

00:12:40.000 --> 00:12:45.000
Tôi tạo một UIColor mới bằng cách sử dụng trình khởi tạo nhà cung cấp động.

00:12:45.000 --> 00:12:54.000
Bên trong phần đóng, tôi sử dụng chủ đề của bộ sưu tập đặc điểm được chuyển vào để xác định màu nào sẽ trả lại.

00:12:54.000 --> 00:12:58.000
Bây giờ tôi có thể đặt màu nền tùy chỉnh này thành chế độ xem.

00:12:58.000 --> 00:13:08.000
Bởi vì tôi đã chỉ ra rằng đặc điểm này ảnh hưởng đến giao diện màu sắc khi tôi xác định nó, bất kỳ chế độ xem nào sử dụng màu nền tùy chỉnh này sẽ tự động cập nhật khi chủ đề thay đổi.

00:13:08.000 --> 00:13:16.000
Khi xác định một đặc điểm, điều quan trọng nhất cần xem xét là kiểu dữ liệu liên quan của các giá trị của đặc điểm đó.

00:13:16.000 --> 00:13:21.000
Các đặc điểm tốt nhất được xây dựng xung quanh các loại giá trị, bao gồm các cấu trúc và liệt kê đơn giản.

00:13:21.000 --> 00:13:26.000
Tránh các đặc điểm dựa trên các lớp học trong Swift.

00:13:26.000 --> 00:13:35.000
Các kiểu dữ liệu hiệu quả nhất cho các đặc điểm là Bool, Int và Double, hoặc một enum sử dụng giá trị thô Int.

00:13:35.000 --> 00:13:38.000
Enums là một trong những kiểu dữ liệu hữu ích nhất cho các đặc điểm.

00:13:38.000 --> 00:13:47.000
Chỉ cần đảm bảo chỉ định rõ ràng Int là kiểu dữ liệu thô của enum để đạt hiệu quả tối đa.

00:13:47.000 --> 00:13:54.000
Bất kỳ loại dữ liệu cấu trúc tùy chỉnh nào mà bạn sử dụng làm giá trị đặc điểm phải có cách triển khai hiệu quả giao thức Equatable.

00:13:54.000 --> 00:14:05.000
Hệ thống sẽ so sánh các giá trị đặc điểm thường xuyên để xác định khi nào các đặc điểm đã thay đổi, vì vậy chức năng ngang bằng của bạn phải càng nhanh càng tốt.

00:14:05.000 --> 00:14:12.000
Đối với những người bạn có ứng dụng sử dụng Objective-C, chức năng hệ thống đặc điểm mới cũng có sẵn ở đó.

00:14:12.000 --> 00:14:17.000
API cho các đặc điểm tùy chỉnh khác nhau trong Swift và Objective-C.

00:14:17.000 --> 00:14:26.000
Tuy nhiên, bạn có thể xác định một đặc điểm tùy chỉnh trong Swift và một trong Objective-C, và cả hai đều trỏ đến cùng một dữ liệu cơ bản.

00:14:26.000 --> 00:14:32.000
Tham khảo tài liệu để biết thêm chi tiết và cân nhắc đặc biệt.

00:14:32.000 --> 00:14:39.000
Khi bạn đã xác định một đặc điểm tùy chỉnh, bước tiếp theo là điền một số dữ liệu cho nó vào hệ thống phân cấp đặc điểm của ứng dụng của bạn.

00:14:39.000 --> 00:14:45.000
Ghi đè đặc điểm là cơ chế bạn sử dụng để sửa đổi dữ liệu trong hệ thống phân cấp đặc điểm.

00:14:45.000 --> 00:14:50.000
Trong iOS 17, việc áp dụng ghi đè đặc điểm trở nên dễ dàng hơn bao giờ hết.

00:14:50.000 --> 00:15:01.000
Có một thuộc tính traitOverrides mới trên mỗi lớp môi trường đặc điểm, bao gồm cảnh cửa sổ, cửa sổ, chế độ xem, bộ điều khiển chế độ xem và bộ điều khiển bản trình bày.

00:15:01.000 --> 00:15:10.000
Quay trở lại hình minh họa của hệ thống phân cấp đặc điểm, ghi đè đặc điểm thay đổi giá trị cho các đặc điểm ở bất kỳ vị trí nào trong cây này.

00:15:10.000 --> 00:15:21.000
Khi bạn áp dụng ghi đè đặc điểm cho một trong các môi trường đặc điểm trong hệ thống phân cấp này, nó sẽ sửa đổi giá trị cho đặc điểm đó trong bộ sưu tập đặc điểm của đối tượng đó và tất cả các hậu duệ của nó.

00:15:21.000 --> 00:15:29.000
Lấy môi trường đặc điểm cha mẹ và con cái từ hệ thống phân cấp đặc điểm, đây là cách ghi đè đặc điểm ảnh hưởng đến cả hai.

00:15:29.000 --> 00:15:34.000
Ghi đè đặc điểm được áp dụng cho cha mẹ ảnh hưởng đến bộ sưu tập đặc điểm của cha mẹ.

00:15:34.000 --> 00:15:40.000
Và sau đó các giá trị từ bộ sưu tập đặc điểm của cha mẹ được thừa hưởng cho đứa trẻ.

00:15:40.000 --> 00:15:48.000
Cuối cùng, ghi đè đặc điểm của đứa trẻ được áp dụng cho các giá trị mà nó được thừa hưởng để tạo ra bộ sưu tập đặc điểm của riêng nó.

00:15:48.000 --> 00:15:54.000
Hãy nghĩ về ghi đè đặc điểm là đầu vào tùy chọn và bộ sưu tập đặc điểm là đầu ra.

00:15:54.000 --> 00:15:58.000
Bất kỳ đặc điểm nào không ghi đè sẽ kế thừa từ cha mẹ.

00:15:58.000 --> 00:16:04.000
Tôi sẽ xem qua một ví dụ về việc sử dụng ghi đè đặc điểm để thay đổi chủ đề màu sắc cho các phần cụ thể của ứng dụng của tôi.

00:16:04.000 --> 00:16:09.000
Ở bên phải, tôi có một minh họa về hệ thống phân cấp đặc điểm của ứng dụng của tôi.

00:16:09.000 --> 00:16:20.000
Ban đầu, tôi chưa áp dụng bất kỳ ghi đè nào để điền giá trị cho đặc điểm chủ đề của mình, vì vậy tất cả các bộ sưu tập đặc điểm này đều có giá trị mặc định, đó là chủ đề tiêu chuẩn.

00:16:20.000 --> 00:16:27.000
Tôi sẽ bắt đầu bằng cách áp dụng ghi đè đặc điểm cho thư mục gốc của hệ thống phân cấp này trên cảnh cửa sổ.

00:16:27.000 --> 00:16:34.000
Thuộc tính traitOverrides tận dụng giao thức UIMutableTraits để cho phép bạn dễ dàng đặt các giá trị đặc điểm.

00:16:34.000 --> 00:16:44.000
Do đó, bạn có thể đặt các giá trị ghi đè cho các đặc điểm tùy chỉnh với cú pháp thuộc tính tiêu chuẩn bằng cách sử dụng tiện ích mở rộng cho UIMutableTraits mà tôi đã giải thích trước đó.

00:16:44.000 --> 00:16:57.000
Bằng cách đặt chủ đề thành màu phấn trên các ghi đè đặc điểm của cảnh cửa sổ, tất cả các cửa sổ, bộ điều khiển chế độ xem và chế độ xem bên trong cảnh cửa sổ đó hiện kế thừa giá trị màu phấn trong bộ sưu tập đặc điểm của chúng.

00:16:57.000 --> 00:17:06.000
Vì vậy, bằng cách đặt chủ đề ở một nơi ở gốc của hệ thống phân cấp, tôi đã thay đổi giá trị cơ sở được truyền đến mọi thứ trong hệ thống phân cấp đó.

00:17:06.000 --> 00:17:15.000
Ví dụ, tôi có thể đọc chủ đề từ bộ sưu tập đặc điểm của bất kỳ bộ điều khiển chế độ xem nào bên trong cảnh cửa sổ đó và lấy lại màu phấn.

00:17:15.000 --> 00:17:25.000
Sau đó, tôi có thể sử dụng thuộc tính traitOverrides trên chế độ xem sâu hơn trong hệ thống phân cấp để sửa đổi chủ đề cho chế độ xem đó và bất kỳ thứ gì bên dưới nó.

00:17:25.000 --> 00:17:30.000
Ở đây tôi đang thiết lập một đặc điểm chủ đề đơn sắc ghi đè cho chế độ xem này.

00:17:30.000 --> 00:17:38.000
Vì vậy, giá trị đơn sắc này là những gì được kế thừa bởi chế độ xem con của nó, ghi đè lên giá trị pastel từ cao hơn trong hệ thống phân cấp.

00:17:38.000 --> 00:17:43.000
Bạn có thể không thấy những thay đổi đối với ghi đè đặc điểm được phản ánh ngay lập tức trong bộ sưu tập đặc điểm.

00:17:43.000 --> 00:17:57.000
Ví dụ, vì các chế độ xem cập nhật bộ sưu tập đặc điểm của chúng ngay trước khi bố cục, các sửa đổi đối với ghi đè đặc điểm của chế độ xem không được phản ánh trong bộ sưu tập đặc điểm của nó cho đến ngay trước khi nó chạy layoutSubviews.

00:17:57.000 --> 00:18:04.000
Thuộc tính traitOverrides cũng cho phép bạn kiểm tra xem các ghi đè có được áp dụng hay không và loại bỏ hoàn toàn các ghi đè.

00:18:04.000 --> 00:18:15.000
Đây là một ví dụ về việc chuyển đổi ghi đè bằng cách sử dụng phương thức chứa để kiểm tra xem ghi đè có tồn tại hay không và phương pháp xóa để xóa hoàn toàn ghi đè.

00:18:15.000 --> 00:18:25.000
Mỗi lần phương pháp này được gọi, nó sẽ xóa ghi đè hiện có hoặc áp dụng ghi đè chủ đề mới khi chưa có.

00:18:25.000 --> 00:18:29.000
Ghi đè đặc điểm là một cơ chế đầu vào để thiết lập các giá trị.

00:18:29.000 --> 00:18:34.000
Để đọc các giá trị đặc điểm, luôn sử dụng thuộc tính traitCollection.

00:18:34.000 --> 00:18:41.000
Đọc từ traitOverrides khi không có ghi đè nào được đặt sẽ tạo ra một ngoại lệ.

00:18:41.000 --> 00:18:45.000
Dưới đây là một số cân nhắc về hiệu suất cần ghi nhớ khi bạn sử dụng ghi đè đặc điểm.

00:18:45.000 --> 00:18:55.000
Đầu tiên, mỗi ghi đè đặc điểm có một chi phí nhỏ, vì vậy chỉ đặt ghi đè đặc điểm ở những nơi bạn cần chúng và tránh đặt ghi đè đặc điểm không được sử dụng.

00:18:55.000 --> 00:19:03.000
Và mỗi khi bạn thay đổi ghi đè đặc điểm, hệ thống cần cập nhật bộ sưu tập đặc điểm của bất kỳ hậu duệ nào trong hệ thống phân cấp.

00:19:03.000 --> 00:19:08.000
Do đó, hãy giảm thiểu số lần bạn thay đổi ghi đè đặc điểm.

00:19:08.000 --> 00:19:17.000
Cuối cùng, các ghi đè đặc điểm được áp dụng gần gốc của hệ thống phân cấp, chẳng hạn như trên cảnh cửa sổ hoặc cửa sổ, ảnh hưởng đến mọi thứ bên dưới chúng.

00:19:17.000 --> 00:19:24.000
Điều này rất hữu ích và có nhiều trường hợp sử dụng tuyệt vời để áp dụng ghi đè đặc điểm cho cảnh cửa sổ hoặc cửa sổ.

00:19:24.000 --> 00:19:37.000
Tuy nhiên, khi một đặc điểm chỉ ảnh hưởng đến một vài chế độ xem sâu trong hệ thống phân cấp, thì thay vào đó hãy áp dụng ghi đè đặc điểm cho tổ tiên chung gần nhất của các chế độ xem đó, chẳng hạn như chế độ xem chung hoặc bộ điều khiển chế độ xem.

00:19:37.000 --> 00:19:47.000
Bằng cách đó, bạn không phải trả chi phí truyền bá đặc điểm cho toàn bộ hệ thống phân cấp của mình khi chỉ một phần nhỏ của hệ thống phân cấp sử dụng dữ liệu đó.

00:19:47.000 --> 00:19:56.000
Bây giờ bạn đã biết cách xác định các đặc điểm và điền dữ liệu cho chúng vào hệ thống phân cấp, bạn cần xử lý khi chúng thay đổi giá trị.

00:19:56.000 --> 00:20:00.000
traitCollectionDidChange bị phản đối trong iOS 17.

00:20:00.000 --> 00:20:11.000
Khi bạn triển khai traitCollectionDidChange, hệ thống không biết bạn thực sự quan tâm đến những đặc điểm nào, vì vậy nó phải gọi phương thức đó mỗi khi bất kỳ đặc điểm nào thay đổi giá trị.

00:20:11.000 --> 00:20:18.000
Tuy nhiên, hầu hết các lớp học chỉ sử dụng một số đặc điểm và không quan tâm đến những thay đổi đối với bất kỳ lớp nào khác.

00:20:18.000 --> 00:20:25.000
Đây là lý do tại sao traitCollectionDidChange không mở rộng quy mô khi bạn thêm ngày càng nhiều đặc điểm tùy chỉnh.

00:20:25.000 --> 00:20:33.000
Thay vào đó, có các API đăng ký đặc điểm mới linh hoạt hơn và cải thiện hiệu suất.

00:20:33.000 --> 00:20:40.000
Bằng cách đăng ký thay đổi các đặc điểm cụ thể, hệ thống biết chính xác bạn phụ thuộc vào đặc điểm nào.

00:20:40.000 --> 00:20:46.000
Các API mới cho phép bạn nhận các cuộc gọi lại bằng cách sử dụng mẫu hành động mục tiêu hoặc đóng cửa.

00:20:46.000 --> 00:20:54.000
Và bởi vì bạn không còn cần phải ghi đè một phương thức trong lớp con của mình nữa, giờ đây thật dễ dàng để quan sát những thay đổi đặc điểm từ bất cứ đâu.

00:20:54.000 --> 00:21:00.000
Tôi sẽ bắt đầu bằng cách giải thích cách cập nhật triển khai hiện có của traitCollectionDidChange.

00:21:00.000 --> 00:21:02.000
Đây là cách triển khai hiện tại của tôi.

00:21:02.000 --> 00:21:12.000
Lưu ý cách tôi kiểm tra xem đặc điểm horizontalSizeClass có thay đổi hay không trước khi gọi updateViews, vì phương thức đó chỉ dựa vào một đặc điểm này.

00:21:12.000 --> 00:21:24.000
Nếu bạn cần tiếp tục sử dụng traitCollectionDidChange vì bạn đang triển khai ứng dụng của mình cho các phiên bản iOS cũ hơn, hãy đảm bảo rằng việc triển khai của bạn sẽ kiểm tra xem các đặc điểm cụ thể mà bạn quan tâm có thay đổi hay không.

00:21:24.000 --> 00:21:31.000
Bây giờ tôi sẽ thay thế việc triển khai này bằng các phương thức đăng ký đặc điểm mới trong iOS 17.

00:21:31.000 --> 00:21:33.000
Tôi sẽ bắt đầu với phương pháp dựa trên đóng cửa.

00:21:33.000 --> 00:21:39.000
Tôi gọi registerForTraitChanges và chuyển một loạt các đặc điểm để đăng ký.

00:21:39.000 --> 00:21:46.000
Có các biểu tượng UITrait mới cho tất cả các đặc điểm của hệ thống, chẳng hạn như biểu tượng này cho lớp kích thước ngang.

00:21:46.000 --> 00:21:52.000
Sau đó, tôi vượt qua một kết thúc được gọi là khi những đặc điểm cụ thể đó thay đổi.

00:21:52.000 --> 00:22:00.000
Việc đóng cửa không được yêu cầu thay đổi bất kỳ đặc điểm nào khác, vì vậy không cần phải so sánh các giá trị đặc điểm cũ và mới ở đây.

00:22:00.000 --> 00:22:05.000
Đối tượng có các đặc điểm đã thay đổi được chuyển làm tham số đầu tiên để đóng.

00:22:05.000 --> 00:22:11.000
Sử dụng tham số này để bạn không phải nắm bắt một tham chiếu yếu đến đối tượng đó.

00:22:11.000 --> 00:22:19.000
Khi bạn đăng ký thay đổi đặc điểm về bản thân, hãy luôn viết "bản thân: Bản thân" tại đây.

00:22:19.000 --> 00:22:24.000
Bạn cũng có thể quan sát sự thay đổi đặc điểm cho một môi trường đặc điểm khác.

00:22:24.000 --> 00:22:33.000
Ở đây tôi đang đăng ký thay đổi hai đặc điểm, lớp kích thước ngang và đặc điểm tùy chỉnh ContainedInSettings mà tôi đã xác định trước đó.

00:22:33.000 --> 00:22:39.000
Việc đóng cửa thực hiện khi một trong hai đặc điểm này thay đổi ở chế độ xem khác này.

00:22:39.000 --> 00:22:47.000
Tôi viết loại chế độ xem mà tôi đang đăng ký làm tham số đầu tiên của việc đóng cửa.

00:22:47.000 --> 00:22:51.000
Đây là một ví dụ về phương pháp dựa trên hành động mục tiêu mới.

00:22:51.000 --> 00:23:00.000
Gọi registerForTraitChanges và chuyển một loạt các đặc điểm để đăng ký cũng như phương pháp mục tiêu và hành động để kêu gọi các thay đổi.

00:23:00.000 --> 00:23:02.000
Tham số mục tiêu là tùy chọn.

00:23:02.000 --> 00:23:08.000
Nếu bạn bỏ qua nó, mục tiêu sẽ là cùng một đối tượng mà registerForTraitChanges được gọi.

00:23:08.000 --> 00:23:11.000
Trong trường hợp này, đó là bản thân.

00:23:11.000 --> 00:23:17.000
Như với phương pháp đóng, bạn cũng có thể đăng ký các thay đổi trên các môi trường đặc điểm khác.

00:23:17.000 --> 00:23:26.000
Ở đây tôi đang đăng ký thay đổi đặc điểm ở chế độ xem khác, nhưng thiết lập lệnh gọi đến một phương thức trên handleTraitChange tự đặt tên.

00:23:26.000 --> 00:23:36.000
Khi đăng ký thay đổi đặc điểm bằng cách sử dụng hành động mục tiêu, phương thức hành động của bạn có thể có không, một hoặc hai tham số.

00:23:36.000 --> 00:23:40.000
Tham số đầu tiên luôn là đối tượng có đặc điểm đang thay đổi.

00:23:40.000 --> 00:23:44.000
Sử dụng tham số này để lấy traitCollection mới.

00:23:44.000 --> 00:23:52.000
Tham số thứ hai sẽ luôn là bộ sưu tập đặc điểm trước đó cho đối tượng đó trước khi thay đổi.

00:23:52.000 --> 00:24:00.000
Ngoài việc đăng ký các đặc điểm riêng lẻ, bạn cũng có thể đăng ký bằng cách sử dụng các bộ đặc điểm hệ thống ngữ nghĩa mới.

00:24:00.000 --> 00:24:10.000
Ví dụ, có systemTraitsAffectingColorAppearance, trả về bất kỳ đặc điểm hệ thống nào có thể ảnh hưởng đến cách phân giải màu động của hệ thống.

00:24:10.000 --> 00:24:20.000
Ngoài ra còn có systemTraitsAffectingImageLookup, trả về tập hợp con các đặc điểm hệ thống được xem xét khi bạn tải một hình ảnh bằng UIImage (có tên:).

00:24:20.000 --> 00:24:28.000
Chuyển trực tiếp một trong các bộ này sang registerForTraitChanges để thực hiện vô hiệu hóa tùy chỉnh.

00:24:28.000 --> 00:24:34.000
Đăng ký được tự động dọn dẹp khi bạn sử dụng các phương pháp mới để đăng ký thay đổi đặc điểm.

00:24:34.000 --> 00:24:43.000
Nếu bạn có trường hợp sử dụng nâng cao, bạn có thể hủy đăng ký thủ công bằng cách sử dụng mã thông báo được trả về bởi mỗi phương thức đăng ký.

00:24:43.000 --> 00:24:51.000
Nhưng những trường hợp này rất hiếm, vì vậy nói chung bạn chỉ nên bỏ qua giá trị trả về khi bạn gọi registerForTraitChanges.

00:24:51.000 --> 00:24:56.000
Khi bạn áp dụng API đăng ký đặc điểm mới, có hai phương pháp hay nhất cần ghi nhớ.

00:24:56.000 --> 00:25:04.000
Đầu tiên, chỉ đăng ký các đặc điểm mà bạn thực sự phụ thuộc vào để bạn không thực hiện công việc khi các đặc điểm không liên quan thay đổi giá trị.

00:25:04.000 --> 00:25:10.000
Cuối cùng, cố gắng vô hiệu hóa để đáp ứng với những thay đổi đặc điểm mà không cần cập nhật ngay lập tức.

00:25:10.000 --> 00:25:19.000
Ví dụ: nếu bạn sử dụng các đặc điểm bên trong phương thức layoutSubviews của lớp con view, hãy gọi setNeedsLayout để vô hiệu hóa thay đổi đặc điểm.

00:25:19.000 --> 00:25:25.000
Điều này lên lịch xem để nhận layoutSubviews, nhưng không thực hiện cập nhật ngay lập tức.

00:25:25.000 --> 00:25:37.000
Giờ đây, bạn có thể truyền dữ liệu của riêng mình bằng cách sử dụng hệ thống đặc điểm trong UIKit, nó mở ra một cách hoàn toàn mới để bạn chuyển dữ liệu liền mạch giữa các thành phần UIKit và SwiftUI trong ứng dụng của mình.

00:25:37.000 --> 00:25:43.000
Các đặc điểm tùy chỉnh trong UIKit rất giống với các khóa môi trường tùy chỉnh trong SwiftUI.

00:25:43.000 --> 00:25:48.000
Bạn có thể kết nối chúng để truy cập cùng một dữ liệu từ cả UIKit và SwiftUI.

00:25:48.000 --> 00:25:59.000
Cho dù bạn đang nhúng các thành phần SwiftUI vào bên trong UIKit hay các thành phần UIKit bên trong SwiftUI, dữ liệu cầu nối sẽ chuyển liền mạch giữa chúng.

00:25:59.000 --> 00:26:08.000
Bạn có thể đọc và ghi vào cùng một dữ liệu cơ bản bằng cách sử dụng API đặc điểm trong mã UIKit và API môi trường trong mã SwiftUI của bạn.

00:26:08.000 --> 00:26:19.000
Thật dễ dàng để lấy đặc điểm chủ đề màu mới mà tôi đã xác định cho mã UIKit của ứng dụng và kết nối nó với khóa môi trường tương ứng trong SwiftUI.

00:26:19.000 --> 00:26:33.000
Giả sử tôi có một đặc điểm tùy chỉnh trong UIKit và một khóa môi trường tùy chỉnh trong SwiftUI đại diện cho cùng một dữ liệu, tất cả những gì tôi cần làm để kết nối chúng là thêm sự phù hợp với giao thức UITraitBridgedEnvironmentKey.

00:26:33.000 --> 00:26:46.000
Để làm điều này, tôi thực hiện một phương thức để đọc đặc điểm từ UIKit và trả lại giá trị cho SwiftUI và một phương pháp để viết giá trị môi trường SwiftUI cho đặc điểm UIKit.

00:26:46.000 --> 00:26:59.000
Và bây giờ cả đặc điểm UIKit và khóa môi trường SwiftUI đều truy cập lưu trữ hợp nhất, vì vậy tôi có thể đọc hoặc ghi vào cùng một dữ liệu từ các thành phần được viết bằng một trong hai khuôn khổ.

00:26:59.000 --> 00:27:04.000
Đây là một ví dụ về cách tôi có thể sử dụng đặc điểm cầu nối và khóa môi trường.

00:27:04.000 --> 00:27:12.000
Ở thư mục gốc của ứng dụng của tôi, tôi áp dụng ghi đè đặc điểm cho đặc điểm chủ đề lên cảnh cửa sổ UIKit.

00:27:12.000 --> 00:27:18.000
Điều này truyền giá trị chủ đề đơn sắc đến mọi thứ chứa bên trong cảnh cửa sổ đó.

00:27:18.000 --> 00:27:24.000
Sau đó, sâu hơn bên trong cửa sổ trong cảnh cửa sổ đó, tôi có chế độ xem bộ sưu tập UIKit.

00:27:24.000 --> 00:27:34.000
Chế độ xem bộ sưu tập này chứa các ô, được cấu hình bằng UIHostingConfiguration, để hiển thị chế độ xem SwiftUI trong mỗi ô.

00:27:34.000 --> 00:27:44.000
Bên trong SwiftUI CellView, tôi có một thuộc tính có tên là "theme", sử dụng trình bao bọc thuộc tính Môi trường để đọc giá trị từ môi trường SwiftUI.

00:27:44.000 --> 00:27:51.000
Giá trị trong môi trường tương ứng với cùng một giá trị cho đặc điểm bắc cầu trong UIKit.

00:27:51.000 --> 00:27:58.000
Và cuối cùng, tôi sử dụng thuộc tính chủ đề để kiểm soát màu sắc của văn bản bên trong chế độ xem SwiftUI này.

00:27:58.000 --> 00:28:14.000
Bởi vì SwiftUI tự động theo dõi các phụ thuộc dữ liệu, nếu đặc điểm chủ đề ghi đè lên trên cảnh cửa sổ UIKit thay đổi sang một giá trị khác, chế độ xem ô SwiftUI của tôi sẽ tự động cập nhật để phản ánh chủ đề mới.

00:28:14.000 --> 00:28:17.000
Cầu nối cũng hoạt động theo hướng khác.

00:28:17.000 --> 00:28:22.000
Ở đây tôi có chế độ xem SwiftUI hiển thị cài đặt ứng dụng của tôi.

00:28:22.000 --> 00:28:30.000
Tôi sử dụng công cụ sửa đổi môi trường để đặt chủ đề tiêu chuẩn, điều này sẽ áp dụng cho mọi thứ trong bộ điều khiển cài đặt.

00:28:30.000 --> 00:28:35.000
Điều này về mặt khái niệm tương đương với việc áp dụng ghi đè đặc điểm trong UIKit.

00:28:35.000 --> 00:28:50.000
Sau đó, trong bộ điều khiển chế độ xem Cài đặt dựa trên UIKit chứa bên trong UIViewControllerRepresentable, tôi đọc giá trị chủ đề từ đặc điểm bắc cầu và sử dụng nó để cập nhật tiêu đề được hiển thị cho bộ điều khiển chế độ xem này.

00:28:50.000 --> 00:28:58.000
Đây là cách dễ dàng truy cập dữ liệu liền mạch bằng cách sử dụng các đặc điểm UIKit bắc cầu và các khóa môi trường SwiftUI.

00:28:58.000 --> 00:29:10.000
Bây giờ bạn đã tìm hiểu về các tính năng mới mạnh mẽ này, hãy đến và tìm các địa điểm trong ứng dụng của bạn, nơi bạn có thể tận dụng hệ thống đặc điểm để tự động truyền dữ liệu bằng cách xác định các đặc điểm tùy chỉnh của riêng bạn.

00:29:10.000 --> 00:29:17.000
Tiếp theo, áp dụng thuộc tính traitOverrides mới để dễ dàng sửa đổi dữ liệu trong hệ thống phân cấp đặc điểm.

00:29:17.000 --> 00:29:25.000
Và sau đó sử dụng các API đăng ký đặc điểm linh hoạt hơn để tạo ra sự phụ thuộc chính xác vào các đặc điểm chính xác mà bạn sử dụng.

00:29:25.000 --> 00:29:36.000
Cuối cùng, kết nối các đặc điểm UIKit tùy chỉnh của bạn với các khóa môi trường SwiftUI tùy chỉnh để dữ liệu của bạn chuyển liền mạch giữa các thành phần UIKit và SwiftUI trong ứng dụng của bạn.

00:29:36.000 --> 00:29:41.000
Bây giờ tùy thuộc vào bạn để giải phóng sức mạnh của các đặc điểm.

00:29:41.000 --> 00:29:43.000
Cảm ơn vì đã xem.

00:29:43.000 --> 23:59:59.000
♪ ♪

