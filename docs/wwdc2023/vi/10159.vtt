WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:14.000
Harry: Xin chào, tôi là Harry, một kỹ sư trong nhóm SwiftUI.

00:00:14.000 --> 00:00:21.000
Chào mừng bạn đến với Beyond Scroll Views, nơi tôi sẽ nói về một số cải tiến mới đối với chế độ xem cuộn trong SwiftUI.

00:00:21.000 --> 00:00:27.000
Những thứ mà thiết bị của chúng tôi muốn làm hiếm khi có thể được chứa trong kích thước màn hình cố định của chúng.

00:00:27.000 --> 00:00:31.000
Một cách họ xử lý sự phức tạp này là giới thiệu cuộn.

00:00:31.000 --> 00:00:34.000
Điều này cho phép họ hiển thị cho chúng ta mọi thứ không vừa với màn hình.

00:00:34.000 --> 00:00:40.000
SwiftUI cung cấp một vài thành phần khác nhau cho phép bạn tích hợp cuộn vào các ứng dụng của riêng mình.

00:00:40.000 --> 00:00:43.000
Hôm nay, tôi sẽ nói về một trong những thành phần đó.

00:00:43.000 --> 00:00:44.000
Chế độ xem cuộn.

00:00:44.000 --> 00:00:49.000
ScrollView là một khối xây dựng cho phép nội dung của bạn cuộn.

00:00:49.000 --> 00:00:54.000
Chế độ xem cuộn có các trục xác định các hướng mà chúng có thể cuộn được.

00:00:54.000 --> 00:00:56.000
Chế độ xem cuộn có nội dung.

00:00:56.000 --> 00:01:05.000
Khi nội dung đó vượt quá kích thước của ScrollView, một số nội dung đó sẽ bị cắt và mọi người sẽ cần cuộn để hiển thị nó.

00:01:05.000 --> 00:01:14.000
Chế độ xem cuộn đảm bảo rằng nội dung được đặt trong khu vực an toàn bằng cách phân giải khu vực an toàn thành các lề vượt trội hơn nội dung của nó.

00:01:14.000 --> 00:01:18.000
ScrollView đánh giá nội dung của nó một cách háo hức theo mặc định.

00:01:18.000 --> 00:01:23.000
Bạn có thể thay đổi hành vi này bằng cách sử dụng một ngăn xếp lười biếng.

00:01:23.000 --> 00:01:29.000
Vị trí chính xác của nơi ScrollView được cuộn trong nội dung được gọi là độ lệch nội dung.

00:01:29.000 --> 00:01:34.000
SwiftUI đã cung cấp ScrollViewReader API như một cách để kiểm soát độ lệch nội dung.

00:01:34.000 --> 00:01:42.000
Năm nay, SwiftUI đang giới thiệu nhiều cách hơn để vừa ảnh hưởng vừa phản ứng với độ lệch nội dung được quản lý bởi ScrollView.

00:01:42.000 --> 00:01:48.000
Trong buổi nói chuyện này, tôi sẽ bắt đầu bằng cách thảo luận về các cách để tác động đến lề của ScrollView và cách chúng liên quan đến các khu vực an toàn.

00:01:48.000 --> 00:01:54.000
Sau đó tôi sẽ nói về việc quản lý độ lệch nội dung của ScrollView thông qua các mục tiêu cuộn và vị trí cuộn.

00:01:54.000 --> 00:02:00.000
Cuối cùng, tôi sẽ giới thiệu cách bạn có thể thêm một số sự tinh tế thực sự vào ứng dụng của mình với chuyển tiếp cuộn.

00:02:00.000 --> 00:02:07.000
Kể từ khi tôi bắt đầu tạo ứng dụng Colors của mình, người dùng của tôi đã thực sự thích hiển thị cho tôi một số kết hợp màu sắc yêu thích của họ.

00:02:07.000 --> 00:02:12.000
Tôi muốn giới thiệu một số kết hợp này để những người khác có thể thưởng thức chúng.

00:02:12.000 --> 00:02:16.000
Để làm điều này, tôi đã làm việc để thêm tính năng thư viện vào ứng dụng Màu sắc của mình.

00:02:16.000 --> 00:02:19.000
Tôi đã đạt được một số tiến bộ trong việc triển khai phòng trưng bày của mình.

00:02:19.000 --> 00:02:27.000
Trong suốt buổi nói chuyện này, tôi sẽ đánh bóng cả tiêu đề và nội dung của phần nổi bật trong thư viện của mình.

00:02:27.000 --> 00:02:31.000
Trong thư viện của tôi, tôi có một ScrollView ngang bao bọc một ngăn xếp lười biếng.

00:02:31.000 --> 00:02:35.000
Đầu tiên tôi sẽ làm cho khung cảnh này trông đẹp hơn một chút với một số lề.

00:02:35.000 --> 00:02:46.000
Bản năng đầu tiên của bạn có thể là thêm một số phần đệm vào ScrollView và điều này sẽ chèn ScrollView, nhưng lưu ý rằng bây giờ nội dung của nó bị cắt khi cuộn.

00:02:46.000 --> 00:02:53.000
Thay vì cài đặt ScrollView, tôi muốn mở rộng lề nội dung của ScrollView.

00:02:53.000 --> 00:02:56.000
Tôi có thể làm điều đó với công cụ sửa đổi đệm khu vực an toàn mới.

00:02:56.000 --> 00:03:03.000
Điều này hoạt động giống như công cụ sửa đổi đệm thông thường, nhưng thay vì đệm nội dung, nó thêm đệm vào khu vực an toàn.

00:03:03.000 --> 00:03:08.000
Bây giờ ScrollView của tôi mở rộng toàn bộ chiều rộng, cho phép mục tiếp theo nhìn ra ngoài.

00:03:08.000 --> 00:03:15.000
Trước khi tôi đi xa hơn, tôi sẽ nói một chút về các khu vực an toàn liên quan đến ScrollView.

00:03:15.000 --> 00:03:19.000
Các khu vực an toàn thường đến từ thiết bị mà ứng dụng của bạn đang chạy.

00:03:19.000 --> 00:03:24.000
Cũng có thể đến từ các API như đệm khu vực an toàn hoặc công cụ sửa đổi bên trong khu vực an toàn.

00:03:24.000 --> 00:03:30.000
ScrollView giải quyết khu vực an toàn vào lề mà nó áp dụng cho nội dung của nó.

00:03:30.000 --> 00:03:39.000
Điều này bao gồm nội dung bạn chịu trách nhiệm, nhưng cũng có nội dung bổ sung mà ScrollView chịu trách nhiệm như các chỉ báo cuộn.

00:03:39.000 --> 00:03:48.000
Điều này có nghĩa là không thể định cấu hình các cài đặt khác nhau cho các loại nội dung khác nhau bằng cách sửa đổi khu vực an toàn.

00:03:48.000 --> 00:03:53.000
Nếu bạn muốn áp dụng các nội dung khác nhau, bạn có thể sử dụng API contentMargins mới.

00:03:53.000 --> 00:03:59.000
API này cho phép bạn chèn nội dung của ScrollView riêng biệt với các chỉ báo cuộn.

00:03:59.000 --> 00:04:03.000
Hoặc chèn các chỉ số riêng biệt với nội dung.

00:04:03.000 --> 00:04:10.000
Quay trở lại thư viện của mình, tôi sẽ cập nhật công cụ sửa đổi đệm khu vực an toàn của mình để sử dụng API lề nội dung.

00:04:10.000 --> 00:04:20.000
Bây giờ quan điểm của tôi đã được áp dụng một chút lề, một trong những điều tôi muốn làm là kiểm soát nội dung bù đắp mà ScrollView sẽ cuộn đến khi ai đó nhấc ngón tay lên.

00:04:20.000 --> 00:04:31.000
Theo mặc định, ScrollView sử dụng tốc độ giảm tốc tiêu chuẩn cùng với vận tốc của cuộn để tính toán độ lệch nội dung mục tiêu mà cuộn sẽ kết thúc tại.

00:04:31.000 --> 00:04:36.000
Nó không tính đến những thứ như kích thước của ScrollView hoặc nội dung của nó.

00:04:36.000 --> 00:04:38.000
Nhưng đôi khi những thứ đó quan trọng.

00:04:38.000 --> 00:04:46.000
Mới trong SwiftUI, bạn có thể thay đổi cách ScrollView tính toán độ lệch nội dung mục tiêu này bằng công cụ sửa đổi scrollTargetBehavior.

00:04:46.000 --> 00:04:52.000
Công cụ sửa đổi này có một loại phù hợp với giao thức scrollTargetBehavior.

00:04:52.000 --> 00:04:56.000
Ở đây tôi đã chỉ định hành vi phân trang.

00:04:56.000 --> 00:04:59.000
Bây giờ ScrollView của tôi vuốt từng trang một.

00:04:59.000 --> 00:05:01.000
Hành vi phân trang rất đặc biệt.

00:05:01.000 --> 00:05:08.000
Nó có tốc độ giảm tốc tùy chỉnh và chọn nơi cuộn dựa trên kích thước chứa của chính ScrollView.

00:05:08.000 --> 00:05:14.000
Điều này hoạt động tốt cho iOS, nhưng trở nên hơi nhiều trên màn hình lớn hơn của iPadOS.

00:05:14.000 --> 00:05:21.000
Thay vì căn chỉnh theo kích thước chứa của ScrollView, tôi muốn căn chỉnh theo các chế độ xem riêng lẻ.

00:05:21.000 --> 00:05:29.000
Hành vi căn chỉnh chế độ xem căn chỉnh ScrollView với chế độ xem, vì vậy ScrollView cần biết chế độ xem nào nên xem xét để căn chỉnh.

00:05:29.000 --> 00:05:38.000
Những chế độ xem này được gọi là mục tiêu cuộn và có một họ công cụ sửa đổi mới cho phép tôi chỉ định chế độ xem nào là mục tiêu cuộn.

00:05:38.000 --> 00:05:46.000
Ở đây tôi sẽ sử dụng công cụ sửa đổi bố cục mục tiêu cuộn để mỗi chế độ xem anh hùng trong ngăn xếp lười biếng được coi là mục tiêu cuộn.

00:05:46.000 --> 00:05:52.000
Bạn cũng có thể đánh dấu các chế độ xem riêng lẻ là mục tiêu bằng cách sử dụng công cụ sửa đổi mục tiêu cuộn.

00:05:52.000 --> 00:05:57.000
Nhưng khi sử dụng các ngăn xếp lười biếng, điều quan trọng là sử dụng công cụ sửa đổi bố cục mục tiêu cuộn.

00:05:57.000 --> 00:06:01.000
Các chế độ xem bên ngoài khu vực có thể nhìn thấy vẫn chưa được tạo.

00:06:01.000 --> 00:06:10.000
Tuy nhiên, bố cục biết nó sẽ tạo ra những chế độ xem nào, vì vậy nó có thể đảm bảo ScrollView cuộn đến đúng vị trí.

00:06:10.000 --> 00:06:14.000
Bây giờ ScrollView của tôi trông đẹp hơn rất nhiều trên iPad.

00:06:14.000 --> 00:06:19.000
Các hành vi phân trang và xem được căn chỉnh được xây dựng dựa trên giao thức ScrollTargetBehavior mới.

00:06:19.000 --> 00:06:32.000
Mặc dù SwiftUI cung cấp các hành vi phổ biến này cho bạn, nhưng nó cũng cho phép bạn tuân thủ các loại của riêng mình với giao thức này và thực hiện hành vi tùy chỉnh của riêng bạn, giống như bạn sẽ áp dụng giao thức bố cục được giới thiệu trước đó.

00:06:32.000 --> 00:06:39.000
Tuân thủ các loại của riêng bạn với ScrollTargetBehavior bằng cách triển khai một phương pháp bắt buộc: updateTarget.

00:06:39.000 --> 00:06:48.000
SwiftUI gọi phương thức này khi tính toán nơi cuộn sẽ kết thúc, nhưng cũng trong các ngữ cảnh khác như khi ScrollView thay đổi kích thước.

00:06:48.000 --> 00:06:50.000
Tùy chỉnh hành vi thật dễ dàng.

00:06:50.000 --> 00:07:02.000
Ở đây nếu mục tiêu ở gần đầu ScrollView và cuộn được vuốt lên, tôi sẽ thích cuộn đến đầu chính xác của ScrollView bằng cách sửa đổi mục tiêu được cung cấp.

00:07:02.000 --> 00:07:08.000
Điều này sẽ dẫn đến việc ScrollView chọn một độ lệch nội dung khác làm điểm cuối của cuộn.

00:07:08.000 --> 00:07:15.000
Và đó là tất cả những gì cần thiết để chèn mã tùy chỉnh của riêng tôi để ảnh hưởng đến nơi ScrollView chọn cuộn.

00:07:15.000 --> 00:07:16.000
Hãy quay lại chế độ xem phòng trưng bày của tôi.

00:07:16.000 --> 00:07:18.000
Tôi muốn nói về bố cục.

00:07:18.000 --> 00:07:24.000
Lưu ý rằng chế độ xem anh hùng của tôi có kích thước liên quan đến chiều rộng tổng thể của thiết bị.

00:07:24.000 --> 00:07:29.000
Và nếu chúng ta nhìn vào iPad, hai chế độ xem vừa khít với chiều rộng của thiết bị.

00:07:29.000 --> 00:07:40.000
Trước đây bạn sẽ phải sử dụng GeometryReader để thực hiện điều này, nhưng năm nay SwiftUI làm cho điều này dễ dàng hơn nhiều với một API mới được gọi là công cụ sửa đổi containerRelativeFrame.

00:07:40.000 --> 00:07:44.000
Tôi sẽ chỉ cho bạn cách chế độ xem anh hùng của tôi sử dụng API này.

00:07:44.000 --> 00:07:51.000
Tôi sẽ bắt đầu với một chồng chế độ xem màu, cùng với công cụ sửa đổi khung chỉ định chiều cao cố định.

00:07:51.000 --> 00:07:54.000
Tôi sẽ thêm công cụ sửa đổi containerRelativeFrame vào chế độ xem của mình.

00:07:54.000 --> 00:08:01.000
Ở đây tôi chỉ định trục ngang, cho phép chế độ xem chỉ chiếm chiều rộng của vùng chứa của nó.

00:08:01.000 --> 00:08:10.000
Trong trường hợp của tôi, vùng chứa sẽ là ScrollView xung quanh, nhưng nó cũng có thể là cột gần nhất của chế độ xem phân chia điều hướng hoặc cửa sổ ứng dụng của bạn.

00:08:10.000 --> 00:08:15.000
Khi chiều rộng vùng chứa của tôi thay đổi, kích thước chế độ xem của tôi sẽ tự động cập nhật.

00:08:15.000 --> 00:08:21.000
Tôi có thể tạo bố cục giống như lưới của các chế độ xem này bằng cách cung cấp số lượng và khoảng cách.

00:08:21.000 --> 00:08:28.000
Tôi có thể điều kiện hóa số lượng dựa trên sizeClass nằm ngang để có hai cột trên iPad và một cột trên điện thoại.

00:08:28.000 --> 00:08:38.000
Điều tuyệt vời hơn nữa là tôi có thể loại bỏ các điều kiện hệ điều hành vì thuộc tính môi trường sizeClass nằm ngang hiện có sẵn trên tất cả các nền tảng.

00:08:38.000 --> 00:08:48.000
Cuối cùng, tôi sẽ sử dụng công cụ sửa đổi aspectRatio để có chiều cao so với chiều rộng, thay vì mã hóa cứng chiều cao cố định.

00:08:48.000 --> 00:08:51.000
Vì vậy, tôi đã hoàn thành bố cục và hành vi cuộn của thư viện của mình.

00:08:51.000 --> 00:08:54.000
Có một số thay đổi khác mà tôi muốn thực hiện.

00:08:54.000 --> 00:08:57.000
Một điều bạn sẽ nhận thấy là các chỉ báo cuộn.

00:08:57.000 --> 00:09:00.000
Tôi muốn loại bỏ những thứ đó.

00:09:00.000 --> 00:09:05.000
Tôi có thể sử dụng scrollIndicators API hiện có để thực hiện việc này.

00:09:05.000 --> 00:09:10.000
Điều này trông thật tuyệt khi vuốt ngón tay của tôi trên iPad, nhưng tôi thường sử dụng thư viện của mình trên máy Mac.

00:09:10.000 --> 00:09:19.000
Và trên máy Mac, tôi có thể không thể dễ dàng thực hiện cử chỉ vuốt ngang như khi sử dụng chuột hoặc các thiết bị đầu vào khác.

00:09:19.000 --> 00:09:25.000
Và khi tôi kết nối một con chuột, các chỉ báo sẽ hiển thị, mặc dù tôi đã yêu cầu chúng được ẩn.

00:09:25.000 --> 00:09:29.000
Sử dụng chuột có thể khiến việc cuộn trở nên khó khăn hoặc không thể thực hiện được nếu không có các chỉ báo cuộn.

00:09:29.000 --> 00:09:43.000
Vì lý do này, hành vi mặc định của công cụ sửa đổi scrollIndicators là ẩn các chỉ báo khi sử dụng các thiết bị đầu vào linh hoạt hơn, như bàn di chuột, nhưng cho phép các chỉ báo hiển thị khi kết nối chuột.

00:09:43.000 --> 00:09:50.000
Bạn có thể cung cấp giá trị không bao giờ cho công cụ sửa đổi scrollIndicators để luôn ẩn các chỉ báo bất kể thiết bị đầu vào.

00:09:50.000 --> 00:09:54.000
Nhưng ứng dụng của tôi vẫn cần hỗ trợ những người sử dụng chuột.

00:09:54.000 --> 00:09:58.000
Vì vậy, tôi sẽ cần cung cấp một phương tiện thay thế để cuộn thư viện của mình cho họ.

00:09:58.000 --> 00:10:07.000
Thay vì chỉ báo cuộn, tôi sẽ hiển thị một số chế độ xem cho phép người dùng cuộn đến chế độ xem trước đó hoặc chế độ xem tiếp theo chỉ bằng một cú nhấp chuột.

00:10:07.000 --> 00:10:11.000
Để bắt đầu xây dựng nó, hãy dọn dẹp ScrollView của tôi một chút.

00:10:11.000 --> 00:10:15.000
Tôi sẽ di chuyển ScrollView của mình sang VStack với chế độ xem tiêu đề của mình.

00:10:15.000 --> 00:10:19.000
Bây giờ tôi sẽ tập trung vào chế độ xem tiêu đề.

00:10:19.000 --> 00:10:22.000
Tôi sẽ thêm một số chế độ xem mái chèo tùy chỉnh vào chế độ xem tiêu đề.

00:10:22.000 --> 00:10:30.000
Trong các phiên bản trước của SwiftUI, tôi sẽ tiếp cận ScrollViewReader để chuyển sang mái chèo của mình và cuộn đến chế độ xem thích hợp.

00:10:30.000 --> 00:10:34.000
Tuy nhiên, tính mới trong SwiftUI là công cụ sửa đổi scrollPosition.

00:10:34.000 --> 00:10:38.000
Công cụ sửa đổi này liên kết một liên kết với một trạng thái bao bọc một mã định danh.

00:10:38.000 --> 00:10:45.000
Tôi sẽ chuyển nó cho công cụ sửa đổi scrollPosition của mình mà ScrollView sẽ đọc từ và đến chế độ xem tiêu đề của tôi.

00:10:45.000 --> 00:10:51.000
Trong các mái chèo của chế độ xem tiêu đề của tôi, tôi có thể viết vào ràng buộc giống như bất kỳ phần nào khác của trạng thái.

00:10:51.000 --> 00:10:56.000
Khi ràng buộc được ghi vào, ScrollView sẽ cuộn đến chế độ xem có ID đó.

00:10:56.000 --> 00:11:09.000
Cũng giống như chế độ xem được căn chỉnh ScrollTargetBehavior, công cụ sửa đổi vị trí cuộn sử dụng công cụ sửa đổi bố cục mục tiêu cuộn để biết chế độ xem nào cần xem xét để truy vấn các giá trị nhận dạng của chúng.

00:11:09.000 --> 00:11:15.000
Công cụ sửa đổi vị trí cuộn cũng cho phép tôi biết danh tính của chế độ xem hiện đang được cuộn.

00:11:15.000 --> 00:11:22.000
Vì vậy, tôi có thể thêm vào chế độ xem tiêu đề của mình một số văn bản hiển thị giá trị của hình ảnh anh hùng hiện đang được cuộn.

00:11:22.000 --> 00:11:27.000
Khi chế độ xem hàng đầu nhất trong ScrollView của tôi thay đổi, ràng buộc sẽ tự động cập nhật.

00:11:27.000 --> 00:11:30.000
Bây giờ người dùng chuột của tôi có thể cuộn qua thư viện của tôi.

00:11:30.000 --> 00:11:33.000
Có một chút đánh bóng cuối cùng mà tôi muốn thêm vào chế độ xem này.

00:11:33.000 --> 00:11:43.000
Cũng giống như việc biết chế độ xem nào hiện đang được cuộn, đôi khi tôi muốn thay đổi chế độ xem một cách trực quan dựa trên vị trí của nó trong ScrollView.

00:11:43.000 --> 00:11:48.000
Có một API mới được gọi là ScrollTransitions trong SwiftUI giúp việc này thực sự dễ dàng.

00:11:48.000 --> 00:11:52.000
ScrollTransition rất giống một quá trình chuyển đổi bình thường.

00:11:52.000 --> 00:11:58.000
Quá trình chuyển đổi mô tả những thay đổi mà một chế độ xem nên trải qua khi nó xuất hiện hoặc biến mất.

00:11:58.000 --> 00:12:04.000
Khi một chế độ xem đã xuất hiện, nó đang trong giai đoạn nhận dạng mà không nên áp dụng các tùy chỉnh.

00:12:04.000 --> 00:12:17.000
ScrollTransition mô tả một tập hợp các thay đổi tương tự như một quá trình chuyển đổi nhưng thay vào đó áp dụng chúng khi chế độ xem đi vào vùng hiển thị của ScrollView và sau đó rời khỏi vùng hiển thị.

00:12:17.000 --> 00:12:24.000
Theo mặc định, khi chế độ xem nằm ở trung tâm của vùng hiển thị, nó đang trong giai đoạn nhận dạng của ScrollTransition.

00:12:24.000 --> 00:12:27.000
Hãy nhìn vào điều này trong bối cảnh quan điểm anh hùng của tôi.

00:12:27.000 --> 00:12:33.000
Tôi sẽ dọn dẹp cái này một chút để tập trung vào ScrollTransitions.

00:12:33.000 --> 00:12:38.000
Khi chế độ xem đến gần các cạnh của ScrollView, tôi muốn nó thu nhỏ kích thước một chút.

00:12:38.000 --> 00:12:42.000
Tôi sẽ bắt đầu bằng cách thêm công cụ sửa đổi scrollTransition.

00:12:42.000 --> 00:12:50.000
API này lấy nội dung và một giai đoạn và cho phép bạn chỉ định các thay đổi trực quan đối với nội dung dựa trên giai đoạn.

00:12:50.000 --> 00:12:57.000
Ở đây tôi sẽ chỉ định giảm tỷ lệ khi chế độ xem không ở giai đoạn nhận dạng của nó.

00:12:57.000 --> 00:12:59.000
Trông thật tuyệt!

00:12:59.000 --> 00:13:04.000
ScrollTransitions hoạt động với một giao thức mới được gọi là VisualEffect.

00:13:04.000 --> 00:13:12.000
Giao thức này cung cấp một tập hợp các tùy chỉnh để xem nội dung an toàn để sử dụng làm chức năng bố cục như độ lệch nội dung của ScrollView.

00:13:12.000 --> 00:13:15.000
Nhiều người trong số họ có thể trông quen thuộc với bạn.

00:13:15.000 --> 00:13:18.000
Bạn đã biết về hiệu ứng thang đo.

00:13:18.000 --> 00:13:24.000
Bạn cũng có thể tùy chỉnh vòng quay hoặc độ lệch giống như bạn làm với các công cụ sửa đổi chế độ xem.

00:13:24.000 --> 00:13:30.000
Tuy nhiên, không phải tất cả các công cụ sửa đổi chế độ xem đều có thể được sử dụng một cách an toàn bên trong scrollTransition.

00:13:30.000 --> 00:13:35.000
Ví dụ, tùy chỉnh phông chữ không được hỗ trợ và sẽ không được xây dựng.

00:13:35.000 --> 00:13:42.000
Bất cứ điều gì sẽ thay đổi kích thước nội dung tổng thể của ScrollView đều không thể được sử dụng trong công cụ sửa đổi scrollTransition.

00:13:42.000 --> 00:13:47.000
Chà, chúng tôi đã đề cập rất nhiều nên hãy xem lại nhanh.

00:13:47.000 --> 00:13:53.000
Chúng tôi đã nói về sự khác biệt giữa các khu vực an toàn và nội dungMargins và mối quan hệ của chúng với ScrollViews.

00:13:53.000 --> 00:14:05.000
Tôi đã chỉ cho bạn cách bạn có thể sử dụng phân trang và xem scrollTargetBehaviors được căn chỉnh để ảnh hưởng đến cách ScrollView hoạt động và cách bạn có thể viết các tuân thủ của riêng mình với giao thức scrollTargetBehavior.

00:14:05.000 --> 00:14:14.000
Bạn đã tìm hiểu về việc tạo bố cục liên quan đến vùng chứa của họ dễ dàng hơn bao nhiêu bằng cách sử dụng công cụ sửa đổi containerRelativeFrame.

00:14:14.000 --> 00:14:24.000
Tôi đã kết nối với trạng thái của ScrollView bằng cách sử dụng công cụ sửa đổi scrollPosition, cho phép tôi vừa cuộn theo chương trình vừa được thông báo về chế độ xem nào hiện đang được cuộn.

00:14:24.000 --> 00:14:31.000
Và cuối cùng, tôi đã tạo ra các hiệu ứng hình ảnh dựa trên độ lệch nội dung của ScrollView của tôi với scrollTransition API.

00:14:31.000 --> 00:14:34.000
Tôi hy vọng bạn thích tìm hiểu về những cải tiến này đối với ScrollViews.

00:14:34.000 --> 00:14:37.000
Cảm ơn, và chúc bạn có một WWDC tuyệt vời.

00:14:37.000 --> 23:59:59.000
♪ ♪

