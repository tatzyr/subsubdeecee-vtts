WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:14.000
Jeff: Xin chào, tôi là Jeff, một kỹ sư trong nhóm Hoạt động Trực tiếp.

00:00:14.000 --> 00:00:20.000
Tôi rất vui khi có thể chia sẻ với bạn cập nhật Hoạt động Trực tiếp với các thông báo đẩy.

00:00:20.000 --> 00:00:26.000
Hoạt động trực tiếp là một cách tuyệt vời để hiển thị thông tin thoáng qua cho ai đó về một hoạt động đang diễn ra.

00:00:26.000 --> 00:00:32.000
ActivityKit cho phép ứng dụng của bạn bắt đầu, cập nhật và kết thúc Hoạt động Trực tiếp.

00:00:32.000 --> 00:00:40.000
Sau đó, bằng cách sử dụng WidgetKit và SwiftUI, bạn có thể xây dựng giao diện người dùng hiển thị thông tin cho người dùng.

00:00:40.000 --> 00:00:45.000
Nếu bạn muốn tìm hiểu thêm về những công nghệ này, hãy xem phiên "Meet ActivityKit" của Can.

00:00:45.000 --> 00:00:54.000
Trong phiên "Gặp gỡ ActivityKit", Có thể thêm Hoạt động Trực tiếp mới vào Emoji Rangers để hiển thị trạng thái cuộc phiêu lưu của một anh hùng.

00:00:54.000 --> 00:00:58.000
Nhưng tôi nghĩ sẽ vui hơn nếu anh hùng có một số người bạn đồng hành.

00:00:58.000 --> 00:01:05.000
Vì vậy, tôi muốn thêm một tính năng mới cho phép nhiều người dùng thành lập các bữa tiệc với các anh hùng của họ và đưa họ vào các cuộc phiêu lưu cùng nhau.

00:01:05.000 --> 00:01:13.000
Để cung cấp trải nghiệm người dùng tốt nhất, tôi sẽ cập nhật Hoạt động Trực tiếp để hiển thị các sự kiện cho tất cả các anh hùng trong bữa tiệc.

00:01:13.000 --> 00:01:21.000
Để đạt được điều này, tôi sẽ giới thiệu một máy chủ để theo dõi cuộc phiêu lưu, thay vì thực hiện nó trên thiết bị.

00:01:21.000 --> 00:01:25.000
Máy chủ sẽ chịu trách nhiệm cập nhật các Hoạt động Trực tiếp.

00:01:25.000 --> 00:01:32.000
Và vì các tính toán được thực hiện trên máy chủ, ứng dụng sẽ không cần thời gian chạy tiền cảnh để cập nhật Hoạt động Trực tiếp.

00:01:32.000 --> 00:01:36.000
Điều này sẽ làm giảm mức độ ảnh hưởng đến thời lượng pin của người dùng.

00:01:36.000 --> 00:01:42.000
Tôi nghĩ cập nhật Hoạt động Trực tiếp với thông báo đẩy ActivityKit là một cách tuyệt vời để triển khai tính năng này.

00:01:42.000 --> 00:01:51.000
Trong phiên này, điều đầu tiên tôi sẽ đề cập đến là sự chuẩn bị bạn cần thực hiện để cho phép cập nhật Hoạt động Trực tiếp của mình với các bản cập nhật đẩy.

00:01:51.000 --> 00:01:56.000
Sau đó, tôi sẽ đưa bạn qua việc gửi bản cập nhật đẩy đầu tiên từ máy tính của bạn.

00:01:56.000 --> 00:02:03.000
Thứ ba, chúng tôi sẽ thảo luận về sự khác biệt giữa các ưu tiên cập nhật và cách cảnh báo người dùng của bạn.

00:02:03.000 --> 00:02:11.000
Cuối cùng, tôi sẽ trải qua các cải tiến bổ sung mà bạn có thể thực hiện cho các bản cập nhật đẩy của mình để đưa chúng lên cấp độ tiếp theo.

00:02:11.000 --> 00:02:13.000
Hãy bắt đầu với việc chuẩn bị.

00:02:13.000 --> 00:02:23.000
Trước khi bạn bắt đầu cập nhật Hoạt động Trực tiếp của mình với các bản cập nhật đẩy, thật hữu ích khi hiểu cách ứng dụng và máy chủ của bạn tương tác với dịch vụ Thông báo Đẩy của Apple.

00:02:23.000 --> 00:02:26.000
Tất cả bắt đầu với ứng dụng của bạn.

00:02:26.000 --> 00:02:35.000
Khi một Hoạt động Trực tiếp mới được bắt đầu, ActivityKit sẽ nhận được mã thông báo đẩy từ dịch vụ Thông báo Đẩy của Apple hay viết tắt là APN.

00:02:35.000 --> 00:02:41.000
Mã thông báo đẩy này là duy nhất cho mỗi Hoạt động Trực tiếp mà bạn yêu cầu.

00:02:41.000 --> 00:02:47.000
Đó là lý do tại sao ứng dụng của bạn cần gửi nó đến máy chủ của bạn trước khi nó có thể bắt đầu gửi các bản cập nhật đẩy.

00:02:47.000 --> 00:02:54.000
Sau đó, bất cứ khi nào bạn cần cập nhật Hoạt động Trực tiếp, máy chủ của bạn sẽ gửi yêu cầu đẩy bằng mã thông báo đến APNs.

00:02:54.000 --> 00:03:04.000
Cuối cùng, APN sẽ gửi tải trọng đến thiết bị và nó sẽ đánh thức tiện ích mở rộng tiện ích của bạn để hiển thị giao diện người dùng.

00:03:04.000 --> 00:03:09.000
Để hỗ trợ tính năng mới này, APNs đã giới thiệu một loại đẩy liveactivity mới.

00:03:09.000 --> 00:03:15.000
Loại đẩy này chỉ có sẵn cho các máy chủ có kết nối dựa trên mã thông báo với APN.

00:03:15.000 --> 00:03:23.000
Để tìm hiểu thêm về việc gửi yêu cầu đẩy, hãy tham khảo tài liệu "Gửi yêu cầu thông báo đến APNs".

00:03:23.000 --> 00:03:30.000
Để biết thêm thông tin về các kết nối dựa trên mã thông báo, hãy tham khảo "Thiết lập kết nối dựa trên mã thông báo với APN."

00:03:30.000 --> 00:03:37.000
Bước tiếp theo là sửa đổi ứng dụng của bạn để các Hoạt động Trực tiếp của bạn được định cấu hình để nhận các bản cập nhật đẩy.

00:03:37.000 --> 00:03:39.000
Trong Xcode, đi đến mục tiêu ứng dụng của bạn.

00:03:39.000 --> 00:03:45.000
Trong tab "Đăng nhập &amp; Khả năng", thêm khả năng thông báo đẩy.

00:03:45.000 --> 00:03:51.000
Điều này sẽ cho phép ActivityKit yêu cầu mã thông báo đẩy thay mặt cho ứng dụng của bạn.

00:03:51.000 --> 00:03:53.000
Bây giờ tôi sẽ đi sâu vào mã.

00:03:53.000 --> 00:03:59.000
Đây là đoạn mã trong Emoji Rangers yêu cầu Hoạt động Trực tiếp.

00:03:59.000 --> 00:04:04.000
Tôi cung cấp cho phương thức yêu cầu Hoạt động các thuộc tính của cuộc phiêu lưu và trạng thái nội dung ban đầu.

00:04:04.000 --> 00:04:12.000
Để hỗ trợ nhận các bản cập nhật đẩy, hãy thêm tham số pushType vào phương thức và đặt giá trị của nó thành "mã thông báo".

00:04:12.000 --> 00:04:19.000
Điều này sẽ cho ActivityKit biết để yêu cầu mã thông báo đẩy cho Hoạt động Trực tiếp của bạn khi nó được tạo.

00:04:19.000 --> 00:04:24.000
Khi hoạt động đã được tạo, ứng dụng của bạn cần gửi mã thông báo đẩy đến máy chủ của bạn.

00:04:24.000 --> 00:04:30.000
Có một thuộc tính pushToken trên loại Hoạt động sẽ cho phép bạn truy cập mã thông báo đẩy một cách đồng bộ.

00:04:30.000 --> 00:04:35.000
Tuy nhiên, đừng truy cập nó ngay lập tức sau khi tạo hoạt động.

00:04:35.000 --> 00:04:38.000
Giá trị bạn nhận được sẽ bằng không trong hầu hết thời gian.

00:04:38.000 --> 00:04:42.000
Điều này là do yêu cầu mã thông báo đẩy là một quá trình không đồng bộ.

00:04:42.000 --> 00:04:48.000
Ngoài ra, hệ thống có thể cập nhật mã thông báo đẩy trong suốt vòng đời của hoạt động.

00:04:48.000 --> 00:04:52.000
Vì vậy, ứng dụng của bạn cần xử lý điều đó cho phù hợp.

00:04:52.000 --> 00:04:57.000
Cách để xử lý đúng mã thông báo đẩy là trước tiên tạo một Nhiệm vụ không đồng bộ.

00:04:57.000 --> 00:05:04.000
Sau đó bắt đầu một vòng lặp chờ đợi quan sát các giá trị từ chuỗi không đồng bộ pushTokenUpdates của hoạt động.

00:05:04.000 --> 00:05:10.000
Mã bên trong vòng lặp for sẽ được thực thi bất cứ khi nào có mã thông báo đẩy mới cho Hoạt động Trực tiếp.

00:05:10.000 --> 00:05:19.000
Điều quan trọng là sử dụng vòng lặp không đồng bộ ở đây vì nó sẽ có thể xử lý không chỉ mã thông báo đẩy đầu tiên mà còn các bản cập nhật mã thông báo đẩy tiếp theo.

00:05:19.000 --> 00:05:24.000
Khi bạn nhận được mã thông báo, hãy chuyển đổi nó thành chuỗi thập lục phân và đăng nhập vào bảng điều khiển gỡ lỗi.

00:05:24.000 --> 00:05:28.000
Điều này sẽ có ích trong quá trình thử nghiệm trong phần tiếp theo.

00:05:28.000 --> 00:05:35.000
Sau đó, cuối cùng, gửi mã thông báo đẩy đến máy chủ của bạn cùng với bất kỳ dữ liệu nào khác được yêu cầu cho ứng dụng của bạn.

00:05:35.000 --> 00:05:42.000
Mã thông báo đẩy là duy nhất cho mỗi hoạt động, vì vậy điều quan trọng là phải theo dõi chúng cho mỗi Hoạt động Trực tiếp mà người dùng bắt đầu.

00:05:42.000 --> 00:05:51.000
Ngoài ra, khi hệ thống yêu cầu mã thông báo đẩy mới cho một hoạt động hiện có, ứng dụng của bạn sẽ được cung cấp thời gian chạy tiền cảnh để xử lý nó cho phù hợp.

00:05:51.000 --> 00:05:59.000
Điều quan trọng là gửi mã thông báo đẩy mới đến máy chủ của bạn và vô hiệu hóa mã thông báo cũ, vì vậy các bản cập nhật đẩy tiếp theo sẽ được gửi chính xác.

00:05:59.000 --> 00:06:04.000
Bây giờ việc chuẩn bị đã hoàn tất, đã đến lúc gửi bản cập nhật đẩy đầu tiên của bạn.

00:06:04.000 --> 00:06:10.000
Để gửi bản cập nhật đẩy, bạn phải gửi yêu cầu HTTP đến APNs.

00:06:10.000 --> 00:06:16.000
Yêu cầu bao gồm hai phần, tiêu đề APNs và tải trọng APNs.

00:06:16.000 --> 00:06:21.000
Có ba tiêu đề bạn cần cung cấp ngoài các tiêu đề HTTP thông thường.

00:06:21.000 --> 00:06:27.000
Đầu tiên là apns-push-type. Giá trị là hoạt động sống động.

00:06:27.000 --> 00:06:36.000
Tiếp theo là apns-topic, là ID gói ứng dụng của bạn, tiếp theo là .push-type.liveactivity.

00:06:36.000 --> 00:06:42.000
Thứ ba là apns-priority, có thể là giá trị 5 hoặc 10.

00:06:42.000 --> 00:06:48.000
5 chỉ ra rằng yêu cầu đẩy này là mức độ ưu tiên thấp, trong khi 10 chỉ ra mức độ ưu tiên cao.

00:06:48.000 --> 00:06:54.000
Tôi sẽ sử dụng mức độ ưu tiên cao trong quá trình thử nghiệm vì nó làm cho Hoạt động Trực tiếp cập nhật ngay lập tức.

00:06:54.000 --> 00:06:58.000
Đối với tải trọng APN đầu tiên, bạn sẽ gửi một tải bao gồm ba trường.

00:06:58.000 --> 00:07:05.000
Đầu tiên là "dấu thời gian", là khoảng thời gian tính bằng giây kể từ năm 1970.

00:07:05.000 --> 00:07:10.000
Hệ thống sử dụng dấu thời gian để đảm bảo nó luôn hiển thị trạng thái nội dung mới nhất.

00:07:10.000 --> 00:07:12.000
Thứ hai là "sự kiện."

00:07:12.000 --> 00:07:15.000
Đó là hành động bạn muốn thực hiện trong Hoạt động Trực tiếp.

00:07:15.000 --> 00:07:18.000
Giá trị của nó là "cập nhật" hoặc "kết thúc".

00:07:18.000 --> 00:07:21.000
Nó nên được đặt thành "cập nhật" cho yêu cầu APNs ban đầu này.

00:07:21.000 --> 00:07:24.000
Trường thứ ba là "trạng thái nội dung".

00:07:24.000 --> 00:07:29.000
Đây là đối tượng JSON có thể được giải mã thành loại trạng thái nội dung hoạt động của bạn.

00:07:29.000 --> 00:07:36.000
Để đảm bảo bạn có được trạng thái nội dung ở định dạng chính xác, bạn có thể sử dụng loại JSONEncoder của Foundation từ bên trong ứng dụng của mình.

00:07:36.000 --> 00:07:40.000
Ở đây, tôi tạo một ví dụ về Trạng thái Nội dung của Hoạt động Trực tiếp.

00:07:40.000 --> 00:07:43.000
Sau đó tôi khởi tạo một JSONEncoder.

00:07:43.000 --> 00:07:50.000
Cuối cùng, tôi mã hóa trạng thái nội dung thành dữ liệu JSON và ghi lại biểu diễn chuỗi của nó vào bảng điều khiển.

00:07:50.000 --> 00:07:54.000
Đầu ra JSON này với các phím vỏ lạc đà trông giống như những gì tôi mong đợi.

00:07:54.000 --> 00:08:01.000
Trạng thái nội dung JSON của bạn sẽ luôn được giải mã bằng cách sử dụng JSONDecoder với các chiến lược giải mã mặc định.

00:08:01.000 --> 00:08:07.000
Vì vậy, khi mã hóa trạng thái nội dung của bạn, đừng đặt bất kỳ chiến lược mã hóa tùy chỉnh nào.

00:08:07.000 --> 00:08:12.000
Nếu không, JSON của bạn sẽ không khớp và hệ thống sẽ không cập nhật Hoạt động Trực tiếp của bạn.

00:08:12.000 --> 00:08:18.000
Bây giờ bạn đã biết những gì được yêu cầu trong yêu cầu đẩy, bước tiếp theo là kiểm tra việc gửi một yêu cầu.

00:08:18.000 --> 00:08:22.000
Tôi là một fan hâm mộ lớn của việc có thể lặp lại nhanh chóng trong quá trình phát triển.

00:08:22.000 --> 00:08:28.000
Vì vậy, tôi thích kiểm tra thông báo đẩy Hoạt động Trực tiếp mà không cần sửa đổi máy chủ của mình.

00:08:28.000 --> 00:08:33.000
Tôi có thể đạt được điều này bằng cách gửi yêu cầu đẩy đến APNs trực tiếp từ thiết bị đầu cuối của tôi.

00:08:33.000 --> 00:08:40.000
Để thiết lập dòng lệnh của bạn để thực hiện việc này, hãy tham khảo bài viết "Gửi thông báo đẩy bằng các công cụ dòng lệnh".

00:08:40.000 --> 00:08:46.000
Đảm bảo rằng bạn đang làm theo hướng dẫn trong phần có tên "Gửi thông báo đẩy bằng mã thông báo".

00:08:46.000 --> 00:08:52.000
Bạn có thể nhanh chóng xác minh rằng bạn đã thiết lập mọi thứ một cách chính xác bằng cách in biến mã thông báo xác thực.

00:08:52.000 --> 00:08:56.000
Thông tin tiếp theo bạn cần là mã thông báo đẩy.

00:08:56.000 --> 00:09:00.000
Trong phần trước, tôi đã thêm mã để ghi lại mã thông báo đẩy vào bảng điều khiển.

00:09:00.000 --> 00:09:03.000
Vì vậy, đó là nơi tôi sẽ lấy nó từ.

00:09:03.000 --> 00:09:08.000
Nếu bạn có cách tiếp cận tương tự, hãy tiếp tục và triển khai ứng dụng của bạn lên thiết bị và bắt đầu Hoạt động Trực tiếp của bạn.

00:09:08.000 --> 00:09:12.000
Ứng dụng của bạn sẽ ghi lại mã thông báo đẩy ngay sau khi hoạt động bắt đầu.

00:09:12.000 --> 00:09:18.000
Sao chép mã thông báo đẩy và đặt nó làm biến mã thông báo đẩy hoạt động trong thiết bị đầu cuối của bạn.

00:09:18.000 --> 00:09:22.000
Để gửi yêu cầu APNs, bạn sẽ thực hiện một lệnh curl.

00:09:22.000 --> 00:09:25.000
Đây là một cái mà tôi đã xây dựng cho Hoạt động Trực tiếp phiêu lưu.

00:09:25.000 --> 00:09:31.000
Tiêu đề "apns-topic" được đặt thành ID gói của ứng dụng theo sau là hậu tố loại đẩy.

00:09:31.000 --> 00:09:35.000
Sau đó, tiêu đề "apns-push-type" được đặt thành liveactivity.

00:09:35.000 --> 00:09:41.000
Thứ ba, "apns-priority" được đặt thành 10, vì vậy yêu cầu của tôi sẽ được gửi ngay lập tức.

00:09:41.000 --> 00:09:49.000
Tiêu đề HTTP cuối cùng, "ủy quyền", được đặt thành "người mang" theo sau là biến mã thông báo xác thực.

00:09:49.000 --> 00:09:53.000
Đối với dữ liệu, nó chứa toàn bộ tải trọng APNs.

00:09:53.000 --> 00:10:00.000
Tôi đang sử dụng lệnh ngày tháng để tự động tạo dấu thời gian để đảm bảo con số chính xác đến giây.

00:10:00.000 --> 00:10:04.000
Cuối cùng, đối với URL, hãy đảm bảo rằng bạn đang sử dụng HTTP2.

00:10:04.000 --> 00:10:11.000
Và ở cuối URL, tôi tham khảo biến mã thông báo đẩy hoạt động được thiết lập ở bước trước.

00:10:11.000 --> 00:10:12.000
Và thế là xong.

00:10:12.000 --> 00:10:19.000
Khi bạn thực hiện lệnh curl này, Live Activity của bạn sẽ được cập nhật với trạng thái nội dung mới được cung cấp trong tải trọng.

00:10:19.000 --> 00:10:25.000
Đôi khi, bạn có thể thấy các tình huống mà Hoạt động Trực tiếp của bạn không cập nhật khi bạn mong đợi.

00:10:25.000 --> 00:10:30.000
Điều đầu tiên cần đảm bảo là không có phản hồi lỗi khi thực hiện lệnh curl.

00:10:30.000 --> 00:10:36.000
Một lỗi có thể chỉ ra một trường không chính xác trong yêu cầu hoặc đã xảy ra sự cố khi thiết lập môi trường của bạn.

00:10:36.000 --> 00:10:47.000
Nếu APNs trả về phản hồi thành công, nhưng Hoạt động Trực tiếp của bạn vẫn không cập nhật, thì bạn có thể sử dụng ứng dụng Bảng điều khiển để xem nhật ký thiết bị và cố gắng phân loại vấn đề.

00:10:47.000 --> 00:10:54.000
Các quy trình có thể có nhật ký liên quan là liveactivitiesd, apsd và chronod.

00:10:54.000 --> 00:11:04.000
Khi bạn hài lòng với cách hoạt động trực tiếp của mình được cập nhật với thông báo đẩy, sẽ đến lúc bạn sửa đổi máy chủ của mình để bắt đầu gửi các bản cập nhật đẩy thực sự.

00:11:04.000 --> 00:11:11.000
Và điều đó đưa tôi đến một phần quan trọng trong việc thiết kế trải nghiệm người dùng, mức độ ưu tiên và cảnh báo của bạn.

00:11:11.000 --> 00:11:18.000
Để đảm bảo trải nghiệm người dùng tốt nhất, điều quan trọng là bạn phải chọn mức độ ưu tiên đẩy chính xác cho mỗi bản cập nhật.

00:11:18.000 --> 00:11:23.000
Ưu tiên bạn nên luôn cân nhắc sử dụng trước tiên là ưu tiên thấp.

00:11:23.000 --> 00:11:29.000
Các bản cập nhật ưu tiên thấp được cung cấp một cách cơ hội, điều này làm giảm tác động đến thời lượng pin của người dùng.

00:11:29.000 --> 00:11:35.000
Tuy nhiên, điều này có nghĩa là Hoạt động Trực tiếp có thể không được cập nhật ngay lập tức khi yêu cầu đẩy được gửi đi.

00:11:35.000 --> 00:11:40.000
Vì vậy, bạn nên sử dụng mức độ ưu tiên thấp cho các bản cập nhật ít nhạy cảm hơn về thời gian.

00:11:40.000 --> 00:11:49.000
Đối với Hoạt động Trực tiếp phiêu lưu của tôi, các cập nhật như tìm kiếm chiến lợi phẩm phổ biến hoặc anh hùng chữa lành một vài điểm máu không đòi hỏi sự chú ý ngay lập tức của người dùng.

00:11:49.000 --> 00:11:53.000
Đó là lý do tại sao họ là những ứng cử viên tuyệt vời cho việc sử dụng các bản cập nhật có mức độ ưu tiên thấp.

00:11:53.000 --> 00:12:00.000
Một lợi ích khác của việc sử dụng mức độ ưu tiên thấp là không có giới hạn về số lượng bản cập nhật bạn có thể gửi.

00:12:00.000 --> 00:12:06.000
Để tận dụng điều này, bạn nên sử dụng mức độ ưu tiên thấp cho phần lớn các bản cập nhật Hoạt động Trực tiếp của mình.

00:12:06.000 --> 00:12:15.000
Mặt khác, một số bản cập nhật nhất định đòi hỏi sự chú ý ngay lập tức của người dùng, chẳng hạn như khi một anh hùng bị hạ gục hoặc khi một con trùm chính bị đánh bại.

00:12:15.000 --> 00:12:19.000
Trong những trường hợp này, tôi sẽ chọn các bản cập nhật ưu tiên cao.

00:12:19.000 --> 00:12:22.000
Các bản cập nhật ưu tiên cao được gửi ngay lập tức.

00:12:22.000 --> 00:12:25.000
Đó là lý do tại sao chúng hoàn hảo cho các bản cập nhật nhạy cảm về thời gian.

00:12:25.000 --> 00:12:32.000
Tuy nhiên, do tác động của chúng đến thời lượng pin của người dùng, hệ thống áp đặt ngân sách tùy thuộc vào tình trạng thiết bị.

00:12:32.000 --> 00:12:40.000
Nếu ứng dụng của bạn vượt quá ngân sách, hệ thống sẽ điều chỉnh các bản cập nhật đẩy của bạn và nó sẽ ảnh hưởng đáng kể đến trải nghiệm người dùng của bạn.

00:12:40.000 --> 00:12:47.000
Bạn biết rõ nhất về ứng dụng của mình, vì vậy điều quan trọng là bạn phải cân nhắc cẩn thận mức độ ưu tiên nào bạn nên sử dụng cho bản cập nhật nào.

00:12:47.000 --> 00:12:55.000
Trong Emoji Rangers, tôi đang giới thiệu một kiểu phiêu lưu đặc biệt, nơi cả nhóm chiến đấu với từng con trùm chính.

00:12:55.000 --> 00:13:05.000
Để cung cấp trải nghiệm người dùng tốt nhất cho Hoạt động Trực tiếp chuyên sâu này, tôi cần máy chủ gửi các lần đẩy ưu tiên cao thường xuyên để cập nhật.

00:13:05.000 --> 00:13:11.000
Để hỗ trợ điều này, tôi sẽ bật tính năng cập nhật thường xuyên Hoạt động Trực tiếp cho ứng dụng.

00:13:11.000 --> 00:13:19.000
Bật tính năng này sẽ cho phép ứng dụng của tôi nhận được ngân sách cập nhật cao hơn, vì vậy các bản cập nhật Hoạt động Trực tiếp của tôi ít có khả năng bị điều chỉnh hơn.

00:13:19.000 --> 00:13:30.000
Để áp dụng tính năng này, tất cả những gì tôi phải làm là thêm một khóa mới vào danh sách Thông tin có tên NSSupportsLiveActivitiesFrequentUpdates và đặt giá trị của nó thành CÓ.

00:13:30.000 --> 00:13:36.000
Người dùng có thể vô hiệu hóa cập nhật thường xuyên độc lập với Hoạt động Trực tiếp trong Cài đặt.

00:13:36.000 --> 00:13:45.000
Vì vậy, bạn có thể phát hiện trạng thái của tính năng cập nhật thường xuyên bằng cách truy cập thuộc tính ActivityAuthorizationInfo frequentPushesEnabled.

00:13:45.000 --> 00:13:55.000
Máy chủ của bạn nên điều chỉnh tần suất cập nhật của nó theo giá trị này, vì vậy hãy đảm bảo rằng bạn đang gửi nó đến máy chủ của mình trước khi nó bắt đầu gửi các bản cập nhật đẩy.

00:13:55.000 --> 00:13:59.000
Bạn chỉ cần kiểm tra giá trị này một lần sau khi một hoạt động đã bắt đầu.

00:13:59.000 --> 00:14:09.000
Nếu giá trị này thay đổi, hệ thống sẽ kết thúc tất cả các hoạt động đang diễn ra, vì vậy máy chủ của bạn không cần phải lo lắng về việc các bản cập nhật thường xuyên bị chuyển đổi trong suốt vòng đời của hoạt động.

00:14:09.000 --> 00:14:21.000
Trong hoạt động trực tiếp phiêu lưu, khi một anh hùng bị hạ gục, ngoài việc cập nhật ngay lập tức, tôi cũng muốn thu hút sự chú ý của người dùng, để họ có thể nhanh chóng vào ứng dụng và sử dụng một lọ thuốc chữa bệnh.

00:14:21.000 --> 00:14:28.000
Để làm điều này, tôi sẽ thêm một đối tượng "cảnh báo" bổ sung với ba trường vào tải trọng.

00:14:28.000 --> 00:14:32.000
"Tiêu đề" sẽ là tiêu đề của thông báo.

00:14:32.000 --> 00:14:36.000
"Cơ thể" sẽ là một thông điệp ngắn về bản cập nhật.

00:14:36.000 --> 00:14:40.000
"Âm thanh" sẽ cho biết âm thanh được phát khi cảnh báo được kích hoạt.

00:14:40.000 --> 00:14:51.000
Emoji Rangers có hỗ trợ nhiều ngôn ngữ, vì vậy chỉ gửi cảnh báo bằng tiếng Anh là không lý tưởng, nhưng việc xử lý bản địa hóa trên máy chủ của tôi rất khó khăn.

00:14:51.000 --> 00:14:56.000
Rất may, có một cách khác để đặt các trường "tiêu đề" và "cơ thể" của đối tượng cảnh báo.

00:14:56.000 --> 00:15:02.000
Thay vì truyền một chuỗi, tôi có thể đặt nó làm đối tượng chuỗi được bản địa hóa.

00:15:02.000 --> 00:15:08.000
Trường "loc-key" sẽ là khóa bản địa hóa có thể được tìm thấy trong các tệp bản địa hóa ứng dụng của bạn.

00:15:08.000 --> 00:15:14.000
Trường "loc-args" sẽ là một danh sách các giá trị sẽ được chèn vào chuỗi cục bộ.

00:15:14.000 --> 00:15:19.000
Bây giờ thiết bị sẽ tự động bản địa hóa thông báo của bạn tùy thuộc vào ngôn ngữ của người dùng.

00:15:19.000 --> 00:15:25.000
Để thêm dấu ấn cuối cùng vào cảnh báo, tôi muốn thêm âm thanh tùy chỉnh cho các bản cập nhật khác nhau.

00:15:25.000 --> 00:15:31.000
Để đạt được điều này, trước tiên, tôi cần thêm các tệp âm thanh vào mục tiêu ứng dụng của mình làm tài nguyên.

00:15:31.000 --> 00:15:36.000
Sau đó đặt trường "âm thanh" của đối tượng cảnh báo thành tên tệp âm thanh của tôi.

00:15:36.000 --> 00:15:39.000
Và thế là xong. Bây giờ cảnh báo của tôi trông và nghe rất tuyệt.

00:15:39.000 --> 00:15:45.000
Bây giờ tôi sẽ thực hiện các cải tiến để thực sự đánh bóng trải nghiệm người dùng Live Activity.

00:15:45.000 --> 00:15:52.000
Khi cuộc phiêu lưu kết thúc, tôi muốn kết thúc Hoạt động Trực tiếp và loại bỏ nó sau một khoảng thời gian nhất định.

00:15:52.000 --> 00:15:56.000
Tôi sẽ làm điều này bằng cách gửi một tải trọng đẩy với sự kiện được thiết lập để kết thúc.

00:15:56.000 --> 00:16:03.000
Tôi cung cấp "ngày sa thải" tùy chỉnh vì tôi muốn kiểm soát khi nào Hoạt động Trực tiếp nên được xóa khỏi màn hình khóa.

00:16:03.000 --> 00:16:07.000
Bạn có thể bỏ qua trường này để hệ thống quyết định khi nào nên loại bỏ Hoạt động Trực tiếp của bạn.

00:16:07.000 --> 00:16:13.000
Giá trị cho "ngày sa thải" phải là khoảng thời gian tính bằng giây kể từ năm 1970.

00:16:13.000 --> 00:16:18.000
Tôi cũng đang cung cấp trạng thái nội dung cuối cùng để cung cấp bản cập nhật cuối cùng cho Hoạt động Trực tiếp.

00:16:18.000 --> 00:16:27.000
Đây cũng là tùy chọn và nếu bị bỏ qua, hoạt động sẽ tiếp tục hiển thị trạng thái nội dung trước đó cho đến khi nó bị loại bỏ.

00:16:27.000 --> 00:16:31.000
Đôi khi, thiết bị của người dùng có thể không nhận được thông báo đẩy.

00:16:31.000 --> 00:16:36.000
Và Cuộc phiêu lưu Hoạt động Trực tiếp có thể vẫn đang hiển thị giá trị sức khỏe lỗi thời.

00:16:36.000 --> 00:16:44.000
Trong những tình huống này, tôi muốn cảnh báo người dùng trong giao diện người dùng Hoạt động Trực tiếp rằng nó có thể đang hiển thị thông tin không chính xác.

00:16:44.000 --> 00:16:48.000
Để đạt được điều này, tôi thêm một trường "stale-date" vào tải trọng.

00:16:48.000 --> 00:16:53.000
Hệ thống sẽ sử dụng ngày này để quyết định khi nào hiển thị chế độ xem cũ của bạn.

00:16:53.000 --> 00:16:59.000
Tôi có thể cung cấp chế độ xem cũ của mình từ Cấu hình Hoạt động được khai báo trong tiện ích mở rộng.

00:16:59.000 --> 00:17:07.000
Tất cả những gì tôi phải làm là làm cho chế độ xem của mình phản ứng với giá trị của thuộc tính isStale trên ActivityViewContext.

00:17:07.000 --> 00:17:13.000
Khi có nhiều Hoạt động Trực tiếp phiêu lưu cùng một lúc, tôi muốn đảm bảo rằng chúng được sắp xếp chính xác trên Màn hình Khóa.

00:17:13.000 --> 00:17:19.000
Những cái có cập nhật quan trọng hơn nên ở gần đầu và cái quan trọng nhất nên ở Đảo Động.

00:17:19.000 --> 00:17:23.000
Tôi có thể sắp xếp điều này bằng cách cung cấp trường "điểm liên quan" tùy chọn.

00:17:23.000 --> 00:17:27.000
Con số cao hơn cho thấy mức độ liên quan cao hơn.

00:17:27.000 --> 00:17:33.000
Bây giờ bạn đã biết cách cập nhật Hoạt động Trực tiếp của mình bằng thông báo đẩy, đã đến lúc thêm nó vào ứng dụng của bạn.

00:17:33.000 --> 00:17:40.000
Điều đầu tiên cần làm là định cấu hình máy chủ và ứng dụng của bạn để hỗ trợ thông báo đẩy ActivityKit.

00:17:40.000 --> 00:17:45.000
Sau đó kiểm tra việc gửi các bản cập nhật đẩy từ thiết bị đầu cuối của bạn để lặp lại một cách nhanh chóng.

00:17:45.000 --> 00:17:50.000
Khi bạn hài lòng với điều đó, hãy bắt đầu triển khai hỗ trợ từ đầu đến cuối trên máy chủ của bạn.

00:17:50.000 --> 00:17:57.000
Trong khi đó, bạn nên ghi nhớ trải nghiệm người dùng của mình, sử dụng các ưu tiên thích hợp và cảnh báo người dùng nếu cần thiết.

00:17:57.000 --> 00:18:01.000
Tôi hy vọng bạn thích tìm hiểu về các Hoạt động Trực tiếp với tôi.

00:18:01.000 --> 00:18:10.000
Tôi nóng lòng muốn xem tất cả những ý tưởng sáng tạo mà bạn sẽ mang đến Dynamic Island và Lock Screen.

00:18:10.000 --> 00:18:12.000
Cảm ơn vì đã xem.

00:18:12.000 --> 23:59:59.000
♪ ♪

