WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:11.000
Nivash: Xin chào mọi người.

00:00:11.000 --> 00:00:16.000
Tôi là Nivash Raaja Karukankaatur Murugasamy, một Kỹ sư trong nhóm Khung Vị trí Cốt lõi.

00:00:16.000 --> 00:00:19.000
Chào mừng đến với bài nói chuyện của tôi về Core Location Monitor.

00:00:19.000 --> 00:00:23.000
Tôi thực sự hào hứng khi nói về API CLMonitor mới của chúng tôi.

00:00:23.000 --> 00:00:31.000
Nó cho phép bạn viết logic giám sát đơn giản nhưng mạnh mẽ chỉ với vài dòng mã trong Swift.

00:00:31.000 --> 00:00:36.000
Bạn chỉ cần tạo một màn hình, thêm điều kiện và chờ đợi các sự kiện.

00:00:36.000 --> 00:00:39.000
Nó đây rồi. Xin chào, CLMonitor!

00:00:39.000 --> 00:00:43.000
Hãy đi vào chi tiết của CLMonitor API.

00:00:43.000 --> 00:00:54.000
Tôi sẽ bắt đầu với tổng quan về CLMonitor API, cách đơn giản nhưng mạnh mẽ mới của chúng tôi để giám sát vị trí hoặc đèn hiệu của người dùng.

00:00:54.000 --> 00:01:02.000
Sau đó, tôi sẽ cho bạn biết về các loại điều kiện bạn có thể theo dõi và cách bạn có thể thêm hoặc xóa chúng.

00:01:02.000 --> 00:01:10.000
Sau đó, tôi sẽ xem xét các hồ sơ giám sát, những gì chúng chứa và cách bạn có thể truy cập chúng trong vòng đời ứng dụng của mình.

00:01:10.000 --> 00:01:17.000
Tiếp theo là các bước bạn sẽ cần thực hiện trong ứng dụng của mình nếu bất kỳ điều kiện nào được giám sát gặp phải sự kiện.

00:01:17.000 --> 00:01:25.000
Và cuối cùng, tôi sẽ kết thúc với một số yêu cầu và đề xuất sẽ giúp bạn khi sử dụng CLMonitor.

00:01:25.000 --> 00:01:33.000
Đầu tiên, chúng ta hãy xem màn hình là gì và cách bạn có thể tạo một màn hình để giám sát.

00:01:33.000 --> 00:01:39.000
CLMonitor là một diễn viên Swift cấp cao nhất và mỗi phiên bản CLMonitor hoạt động như một cổng để giám sát.

00:01:39.000 --> 00:01:45.000
Vì nó là một diễn viên, nó giúp bạn thoát khỏi chi phí đồng bộ hóa luồng và nhiệm vụ.

00:01:45.000 --> 00:01:53.000
Vì vậy, việc truy cập nội dung của CLMonitor hoặc thêm hoặc xóa một điều kiện bất cứ lúc nào chỉ cần được chờ đợi.

00:01:53.000 --> 00:01:58.000
Để tạo một màn hình, bạn gọi phương thức init của màn hình bằng một chuỗi chữ và số.

00:01:58.000 --> 00:02:03.000
Nếu không có màn hình nào trước đó tồn tại với tên đó, một màn hình mới sẽ được tạo.

00:02:03.000 --> 00:02:06.000
Nếu không, cái hiện tại sẽ được mở.

00:02:06.000 --> 00:02:10.000
Dù bằng cách nào, phiên bản màn hình sẽ được trả về.

00:02:10.000 --> 00:02:16.000
Lưu ý rằng chỉ có một phiên bản có tên đã cho có thể được mở bất cứ lúc nào.

00:02:16.000 --> 00:02:20.000
Thực thể đang được giám sát được gọi là một điều kiện.

00:02:20.000 --> 00:02:28.000
Bạn có thể thêm một điều kiện vào phiên bản CLMonitor để giám sát và liên kết nó với một mã định danh bằng cách sử dụng phương thức thêm.

00:02:28.000 --> 00:02:30.000
Mã định danh là một chuỗi chữ và số.

00:02:30.000 --> 00:02:39.000
Ví dụ, "Làm việc" trong ví dụ này xác định duy nhất bản ghi của một điều kiện được thỏa mãn khi người dùng đang làm việc.

00:02:39.000 --> 00:02:47.000
Đối tượng bản ghi và nội dung của nó sẽ có thể truy cập được bằng mã định danh này và điều kiện sẽ được theo dõi cho đến khi nó bị xóa.

00:02:47.000 --> 00:02:52.000
Bạn có thể xóa điều kiện khỏi giám sát bằng cách gọi xóa với cùng một mã định danh.

00:02:52.000 --> 00:02:56.000
Loại bỏ một điều kiện cũng sẽ loại bỏ bản ghi tương ứng.

00:02:56.000 --> 00:03:07.000
Bây giờ bạn đã biết cách tạo một phiên bản màn hình và cách nó liên quan đến các điều kiện, chúng ta hãy xem xét các loại điều kiện có sẵn và cách bạn có thể tạo một và thêm nó để giám sát.

00:03:07.000 --> 00:03:11.000
Có hai loại điều kiện được hỗ trợ trong iOS.

00:03:11.000 --> 00:03:14.000
Đầu tiên, Điều kiện Địa lý Thông tư.

00:03:14.000 --> 00:03:19.000
Điều kiện địa lý tròn được xác định bởi một trung tâm và một bán kính.

00:03:19.000 --> 00:03:24.000
Trung tâm xác định vị trí địa lý của điều kiện.

00:03:24.000 --> 00:03:29.000
Bán kính xác định khu vực mà theo đó điều kiện sẽ được coi là thỏa mãn.

00:03:29.000 --> 00:03:34.000
Bất cứ nơi nào bên ngoài khu vực đó, chúng tôi sẽ báo cáo tình trạng này là không hài lòng.

00:03:34.000 --> 00:03:39.000
Điều này tương tự như CLCircularRegion trong iOS 16 và các bản phát hành trước đó.

00:03:39.000 --> 00:03:46.000
Bạn xác định một trung tâm bằng cách xây dựng CLLocationCoordinate2D với vĩ độ và kinh độ quan tâm.

00:03:46.000 --> 00:03:54.000
Sau đó, bạn tạo Điều kiện Địa lý Thông tư với tâm đó và bán kính quan tâm.

00:03:54.000 --> 00:03:59.000
Loại điều kiện khác được hỗ trợ trong iOS là BeaconIdentityCondition.

00:03:59.000 --> 00:04:09.000
BeaconIdentityCondition tương tự như CLBeaconIdentityConstraint hoặc CLBeaconRegion mà bạn có thể đã sử dụng trong iOS 16 và các bản phát hành trước đó.

00:04:09.000 --> 00:04:25.000
Nếu công ty của bạn có nhiều trang web ở các địa điểm khác nhau, bạn có thể triển khai đèn hiệu để phát hiện trong ứng dụng của mình nếu người dùng ở bất kỳ một trong các trang web của bạn, hoặc tại một trang web cụ thể, hoặc thậm chí tại một phần cụ thể của một trang web cụ thể.

00:04:25.000 --> 00:04:31.000
Hãy xem xét các quán cà phê của Apple như một ví dụ đơn giản, có sẵn trong các văn phòng tại nhiều địa điểm.

00:04:31.000 --> 00:04:37.000
Hãy xem đèn hiệu có thể được triển khai hiệu quả như thế nào để kích hoạt hành vi dựa trên vị trí trong một ứng dụng được liên kết.

00:04:37.000 --> 00:04:47.000
Và khi chúng ta tiếp tục, tôi sẽ nói về cách ứng dụng đó có thể giám sát các đèn hiệu này bằng cách sử dụng các hương vị khác nhau của BeaconIdentityCondition trong các tình huống khác nhau.

00:04:47.000 --> 00:04:51.000
Chúng ta hãy xem xét ngắn gọn điều gì định nghĩa một ngọn hải đăng.

00:04:51.000 --> 00:04:56.000
Nó chứa một chuỗi UUID, một số chính và một số thứ.

00:04:56.000 --> 00:05:06.000
Với BeaconIdentityCondition, bạn có thể giám sát một đèn hiệu cụ thể bằng cách chỉ định cả ba: UUID, major và minor.

00:05:06.000 --> 00:05:16.000
Hoặc bạn có thể ký tự đại diện để khớp với bất kỳ đèn hiệu đơn lẻ nào từ một nhóm đèn hiệu bằng cách chỉ định chỉ định UUID và chính, hoặc chỉ UUID một mình.

00:05:16.000 --> 00:05:23.000
Khi bạn để trẻ vị thành niên hoặc thứ và thứ không xác định, một đèn hiệu với bất kỳ giá trị nào cho các thuộc tính đó có thể khớp.

00:05:23.000 --> 00:05:25.000
Hãy xem cách chúng ta có thể sử dụng điều này trong ví dụ của mình.

00:05:25.000 --> 00:05:32.000
Chúng tôi có thể triển khai đèn hiệu tại các địa điểm quán cà phê này với tất cả đều có cùng UUID.

00:05:32.000 --> 00:05:38.000
Và, trong ứng dụng, một BeaconIdentityCondition có thể được tạo ra để giám sát UUID này.

00:05:38.000 --> 00:05:45.000
Sau đó, nếu người dùng đến gần một trong những đèn hiệu này, điều kiện sẽ trở nên hài lòng.

00:05:45.000 --> 00:05:49.000
Nếu không, nó sẽ được xác định là không hài lòng.

00:05:49.000 --> 00:05:57.000
Trong mã, bạn có thể làm điều này bằng cách gọi phương thức init chỉ định UUID.

00:05:57.000 --> 00:06:05.000
Bây giờ chúng tôi đã triển khai đèn hiệu tại các vị trí được yêu cầu, bạn có thể quan tâm để phát hiện xem người dùng có đang ở một trong các địa điểm cụ thể hay không.

00:06:05.000 --> 00:06:11.000
Trong trường hợp này, hãy xem cách theo dõi xem người dùng có đang ở trang Apple Park hay không.

00:06:11.000 --> 00:06:17.000
Để đạt được điều này, các đèn hiệu được triển khai tại mỗi địa điểm sẽ phải chia sẻ một số chính duy nhất.

00:06:17.000 --> 00:06:25.000
Sau đó, trong ứng dụng của bạn, bạn có thể theo dõi BeaconIdentityCondition với UUID chính và tổng thể đó.

00:06:25.000 --> 00:06:36.000
Trạng thái của điều kiện sẽ chỉ được xác định là thỏa mãn khi thiết bị ở vị trí mà đèn hiệu khớp với cả UUID và các giá trị chính.

00:06:36.000 --> 00:06:39.000
Nó sẽ vẫn không hài lòng ở các trang web khác.

00:06:39.000 --> 00:06:50.000
Trong mã, bạn có thể tạo BeaconIdentityCondition bằng cách gọi phương thức init chỉ định UUID và major.

00:06:50.000 --> 00:06:54.000
Bây giờ bạn đã biết cách giám sát tất cả các trang web hoặc một trang web cụ thể.

00:06:54.000 --> 00:07:01.000
Nhưng bạn cũng có thể theo dõi một phần cụ thể trong một trang web cụ thể.

00:07:01.000 --> 00:07:10.000
Điều này có thể đạt được bằng cách triển khai đèn hiệu ở các địa điểm khác nhau - giả sử, các trạm ẩm thực - trong mỗi địa điểm với các giá trị nhỏ tương ứng.

00:07:10.000 --> 00:07:19.000
Trong ứng dụng của bạn, bạn có thể theo dõi BeaconIdentityCondition cho một giá trị nhỏ cụ thể cùng với UUID và major.

00:07:19.000 --> 00:07:27.000
Một điều kiện như vậy sẽ chỉ được thỏa mãn khi đèn hiệu với UUID thứ cũng như UUID và chính tổng thể được phát hiện.

00:07:27.000 --> 00:07:38.000
Trong mã, điều này có nghĩa là tạo BeaconIdentityCondition bằng cách chuyển UUID, major và minor.

00:07:38.000 --> 00:07:43.000
Khi tạo BeaconIdentityCondition, hãy sử dụng phương pháp init phù hợp với nhu cầu của bạn.

00:07:43.000 --> 00:07:53.000
Được rồi, bây giờ bạn đã biết cách tạo ra các loại và hương vị khác nhau của tình trạng, chúng ta hãy xem cách bạn có thể thêm chúng để theo dõi.

00:07:53.000 --> 00:08:01.000
Bạn có thể thêm một điều kiện để giám sát bằng cách gọi phương thức thêm với một chuỗi chữ và số được gọi là định danh trên phiên bản CLMonitor của bạn.

00:08:01.000 --> 00:08:05.000
Điều kiện sẽ được liên kết với mã định danh.

00:08:05.000 --> 00:08:13.000
Nếu một điều kiện đã được theo dõi với mã định danh đã cho, nó sẽ được thay thế bằng điều kiện mới được truyền vào.

00:08:13.000 --> 00:08:20.000
Khi bạn thêm một điều kiện, trạng thái ban đầu của nó sẽ không được biết cho đến khi được xác định bởi Vị trí cốt lõi.

00:08:20.000 --> 00:08:26.000
Có thể có những trường hợp bạn nhận thức được trạng thái hiện tại của điều kiện trước khi bạn thêm nó.

00:08:26.000 --> 00:08:33.000
Trong những trường hợp đó, bạn có thể ghi đè trạng thái ban đầu mặc định bằng cách chuyển trạng thái khi thêm để theo dõi.

00:08:33.000 --> 00:08:43.000
Trong ví dụ này, hãy giả sử rằng ứng dụng của bạn suy luận rằng bạn không ở trang Apple Park và do đó hy vọng điều kiện sẽ không được thỏa mãn.

00:08:43.000 --> 00:08:46.000
Bạn có thể thêm "giả sử: .không hài lòng" vào cuộc gọi của mình.

00:08:46.000 --> 00:08:50.000
Sau đó, việc giám sát sẽ bắt đầu với trạng thái được đặt thành không hài lòng.

00:08:50.000 --> 00:08:52.000
Nhưng đừng lo lắng.

00:08:52.000 --> 00:08:58.000
Nếu giả định của bạn về trạng thái là sai, Core Location sẽ cung cấp cho bạn trạng thái chính xác sau khi nó được xác định.

00:08:58.000 --> 00:09:07.000
Để xóa một điều kiện khỏi giám sát, bạn có thể gọi phương thức xóa với mã định danh đã được thông qua khi điều kiện được thêm vào.

00:09:07.000 --> 00:09:14.000
Bây giờ bạn đã biết điều kiện là gì, loại nào được hỗ trợ và cách thêm hoặc xóa điều kiện khỏi giám sát.

00:09:14.000 --> 00:09:23.000
Hãy xem xét chi tiết nội dung của bản ghi và cách bạn có thể lấy bản ghi hoặc tất cả bản ghi trong màn hình để kiểm tra bất cứ lúc nào.

00:09:23.000 --> 00:09:34.000
Nếu bạn có thể nhớ lại từ trang chiếu trước đó, khi bạn thêm một điều kiện để giám sát, Core Location sẽ tạo một bản ghi và thêm điều kiện vào bản ghi đó.

00:09:34.000 --> 00:09:42.000
Ngoài điều kiện, một bản ghi chứa một đối tượng khác được gọi là sự kiện.

00:09:42.000 --> 00:09:57.000
Sự kiện chứa trạng thái đại diện cho trạng thái quan sát hiện tại của điều kiện, cho dù hài lòng, không hài lòng hay không xác định, và ngày và giờ mà điều kiện gặp phải trạng thái.

00:09:57.000 --> 00:10:03.000
Bây giờ bạn có thể tự hỏi tại sao có một trường hợp điều kiện khác trong sự kiện này.

00:10:03.000 --> 00:10:05.000
Đây được gọi là sự tinh chỉnh.

00:10:05.000 --> 00:10:07.000
Nó dùng để làm gì?

00:10:07.000 --> 00:10:21.000
Nếu bạn có thể nhớ lại từ BeaconIdentityCondition, ứng dụng của bạn có thể giám sát chỉ UUID, hoặc UUID và major, hoặc UUID cùng với major và minor.

00:10:21.000 --> 00:10:30.000
Nếu một điều kiện với ký tự đại diện chính và phụ được thỏa mãn, sự kiện đó sẽ được cung cấp với sự tinh chỉnh được điền vào.

00:10:30.000 --> 00:10:37.000
Điều kiện tinh chỉnh đó sẽ mang UUID nhưng cũng là thông tin chính và nhỏ của đèn hiệu quan sát được.

00:10:37.000 --> 00:10:43.000
Sau đó, một khi điều kiện trở nên không được thỏa mãn, việc tinh chỉnh sẽ được đặt lại thành số không.

00:10:43.000 --> 00:10:52.000
Có thể có nhiều trường hợp bản ghi với mỗi bản ghi được giải quyết duy nhất bởi mã định danh được truyền vào khi điều kiện được thêm vào.

00:10:52.000 --> 00:11:00.000
Tất cả các bản ghi của màn hình của bạn, liên kết các điều kiện với lastEvents và số nhận dạng, được lưu trữ với ứng dụng của bạn.

00:11:00.000 --> 00:11:06.000
Điều này cho phép bạn truy vấn các điều kiện và trạng thái tương ứng của chúng như được quan sát lần cuối bất cứ lúc nào.

00:11:06.000 --> 00:11:09.000
Hãy xem nó trông như thế nào trong mã.

00:11:09.000 --> 00:11:15.000
Để truy xuất một bản ghi được liên kết với một điều kiện, bạn có thể gọi phương thức bản ghi với mã định danh của nó.

00:11:15.000 --> 00:11:20.000
Nếu không có điều kiện nào được theo dõi với mã định danh bạn đã vượt qua, số không sẽ được trả về.

00:11:20.000 --> 00:11:26.000
Sau đó, bạn có thể lấy điều kiện được giám sát cơ bản bằng cách truy cập thuộc tính điều kiện.

00:11:26.000 --> 00:11:35.000
Và bạn có thể nhận được lastEvent được gửi đến ứng dụng của mình cho điều kiện đó bằng cách truy cập thuộc tính lastEvent.

00:11:35.000 --> 00:11:42.000
Sau đó, từ sự kiện, bạn có thể nhận được trạng thái, ngày tháng và sự tinh chỉnh được quan sát gần đây nhất.

00:11:42.000 --> 00:11:45.000
Bây giờ bạn đã biết cách truy xuất một bản ghi.

00:11:45.000 --> 00:11:47.000
Làm thế nào để bạn có được tất cả các hồ sơ giám sát?

00:11:47.000 --> 00:11:51.000
Bạn có cần theo dõi tất cả các số nhận dạng không?

00:11:51.000 --> 00:11:53.000
Chà, bạn không cần phải làm vậy.

00:11:53.000 --> 00:11:58.000
Chúng tôi duy trì danh sách cho bạn trong thuộc tính nhận dạng trên màn hình của bạn.

00:11:58.000 --> 00:12:04.000
Bạn có thể dễ dàng lặp lại nó để truy xuất từng bản ghi và nội dung của nó.

00:12:04.000 --> 00:12:12.000
Bây giờ bạn đã biết cách truy cập nội dung của bản ghi, hãy xem cách sử dụng các sự kiện khi các thay đổi xảy ra.

00:12:12.000 --> 00:12:17.000
Mã để nhận một sự kiện có thể được thực hiện bằng cách sử dụng một vòng lặp đơn giản được gói trong một Nhiệm vụ.

00:12:17.000 --> 00:12:33.000
Khi Core Location quan sát một trạng thái cho một điều kiện được giám sát khác với trạng thái được báo cáo trong Sự kiện cuối cùng, thì Core Location sẽ cung cấp một sự kiện mới thông qua thuộc tính trình tự không đồng bộ sự kiện trên màn hình của bạn để tiếp tục vòng lặp đang chờ.

00:12:33.000 --> 00:12:40.000
Đối tượng sự kiện được phân phối mang đến cho bạn trạng thái mới và số nhận dạng của điều kiện bị ảnh hưởng.

00:12:40.000 --> 00:12:51.000
Hoặc, trong khi xử lý sự kiện mới, bạn cũng có thể sử dụng mã định danh để lấy bản ghi và Sự kiện cuối cùng cho điều kiện đó.

00:12:51.000 --> 00:12:56.000
Chúng ta có thể sử dụng thông tin đó để có thêm bối cảnh về những gì đã xảy ra bây giờ.

00:12:56.000 --> 00:12:57.000
Nó đây rồi!

00:12:57.000 --> 00:13:01.000
Chương trình chào hỏi đơn giản của chúng tôi đã hoàn tất.

00:13:01.000 --> 00:13:08.000
Bây giờ bạn đã biết CLMonitor hoạt động như thế nào, tôi có một số lời khuyên về cách sử dụng nó tốt nhất.

00:13:08.000 --> 00:13:11.000
Hãy bắt đầu với ba yêu cầu chính.

00:13:11.000 --> 00:13:24.000
Đầu tiên, bạn có thể có nhiều màn hình với các tên khác nhau để xử lý các điều kiện khác nhau, nhưng bạn chỉ phải khởi tạo một màn hình tại một tên nhất định.

00:13:24.000 --> 00:13:35.000
Bởi vì CLMonitor duy trì trạng thái của các điều kiện mà nó đang theo dõi, việc cố gắng khởi tạo một điều kiện khác có cùng tên có thể dẫn đến hành vi không mong muốn.

00:13:35.000 --> 00:13:45.000
Thứ hai, bởi vì các sự kiện có thể đến không thể đoán trước, tốt nhất là luôn có một Nhiệm vụ đang chờ trên chuỗi sự kiện của màn hình của bạn.

00:13:45.000 --> 00:13:51.000
Một sự kiện chỉ có thể trở thành Sự kiện cuối cùng của một số bản ghi sau khi bạn đã xử lý nó.

00:13:51.000 --> 00:13:59.000
Vì vậy, nếu một điều kiện thay đổi trạng thái trong khi bạn không chờ đợi các sự kiện, màn hình của bạn sẽ không phản ánh trạng thái mới cho đến khi bạn thực hiện.

00:13:59.000 --> 00:14:11.000
Cuối cùng, nếu ứng dụng của bạn đã bị chấm dứt, khi bất kỳ điều kiện được giám sát nào gặp phải sự kiện, Core Location sẽ khởi chạy ứng dụng của bạn ở chế độ nền miễn là nó được phép nhận vị trí người dùng.

00:14:11.000 --> 00:14:21.000
Điều đó có nghĩa là ứng dụng của bạn cần khởi tạo lại màn hình và chờ đợi các sự kiện bất cứ khi nào nó được khởi chạy nếu nó vẫn quan tâm đến trạng thái của các điều kiện mà nó đang theo dõi.

00:14:21.000 --> 00:14:29.000
Một cách để làm điều này là nghe cuộc gọi lại đại diện ứng dụng didFinishLaunchingWithOptions.

00:14:29.000 --> 00:14:36.000
Vì API mới dẫn đến hành vi khởi chạy, tôi thực sự khuyên bạn chỉ nên sử dụng CLMonitor từ ứng dụng của mình.

00:14:36.000 --> 00:14:47.000
Thay vào đó, việc sử dụng nó trong các tiện ích hoặc trình cắm sẽ khởi chạy ứng dụng của bạn và làm phức tạp việc đảm bảo rằng chỉ có một màn hình tồn tại cho một tên nhất định tại một thời điểm.

00:14:47.000 --> 00:15:12.000
Cuối cùng, tôi đã đề cập đến điều này trước đó: các điều kiện và trạng thái của chúng vẫn tồn tại và các sự kiện được tạo ra khi CLMonitor quan sát thấy sự thay đổi trạng thái trong một trong các điều kiện mà nó đang theo dõi, vì vậy tôi thực sự khuyên bạn nên xem các trạng thái đó vì CLMonitor đại diện cho chúng thay vì duy trì

00:15:12.000 --> 00:15:20.000
Điều đó nói rằng, một số ứng dụng, chẳng hạn như trực quan hóa SwiftUI, có thể yêu cầu giữ một biểu diễn riêng biệt.

00:15:20.000 --> 00:15:27.000
Nếu bạn cần làm điều đó, hãy dành đại diện đó cho SwiftUI và không sử dụng nó để lý luận về các sự kiện dự kiến.

00:15:27.000 --> 00:15:30.000
Vậy đó là CLMonitor!

00:15:30.000 --> 00:15:32.000
Tôi thực sự hào hứng với API mới của chúng tôi.

00:15:32.000 --> 00:15:34.000
Hãy thử nó!

00:15:34.000 --> 00:15:37.000
Chúng tôi hy vọng nó sẽ cải thiện đáng kể trải nghiệm giám sát của bạn.

00:15:37.000 --> 00:15:40.000
Chúng tôi rất muốn nghe phản hồi của bạn.

00:15:40.000 --> 00:15:44.000
Chúng tôi cũng có một ứng dụng mẫu thể hiện CLMonitor đang hoạt động.

00:15:44.000 --> 00:15:47.000
Nó có sẵn trong phần tài nguyên của video này.

00:15:47.000 --> 00:15:50.000
Tải xuống và dùng thử.

00:15:50.000 --> 00:15:55.000
Cuối cùng, kiểm tra phiên của đồng nghiệp Siraj của tôi về cập nhật vị trí.

00:15:55.000 --> 23:59:59.000
Cảm ơn vì đã xem!

