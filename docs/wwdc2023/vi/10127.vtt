WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:16.000
Xin chào mọi người, tôi là Gauri Jog, và tôi làm việc trong nhóm Hệ sinh thái kim loại ở đây tại Apple.

00:00:16.000 --> 00:00:21.000
Tôi rất vui được nói chuyện với bạn về việc tối ưu hóa trình kết xuất GPU bằng Metal.

00:00:21.000 --> 00:00:31.000
Các ứng dụng và công cụ trò chơi tạo nội dung kỹ thuật số hiện đại trao quyền cho người sáng tạo nội dung tương tác tạo và sửa đổi tài liệu cho tài sản 3D của họ.

00:00:31.000 --> 00:00:37.000
Có một số kỹ thuật phổ biến để xử lý các vật liệu phức tạp và năng động này trong thời gian chạy.

00:00:37.000 --> 00:00:47.000
Một số ứng dụng biên dịch tài liệu thành các bộ đổ bóng riêng lẻ và những ứng dụng khác sử dụng các giải pháp dựa trên dữ liệu như bộ đổ bóng uber hoặc máy ảo đổ bóng.

00:00:47.000 --> 00:00:51.000
Những quy trình làm việc lấy vật liệu làm trung tâm này có hai mục tiêu hiệu suất chính.

00:00:51.000 --> 00:00:57.000
Tác giả của tài liệu phải đáp ứng nhanh chóng và trải nghiệm tốt nhất.

00:00:57.000 --> 00:01:05.000
Hiệu suất kết xuất phải tốt nhất có thể cho tính tương tác thời gian thực và kết xuất khung hình cuối cùng hiệu quả.

00:01:05.000 --> 00:01:11.000
Trong bản trình diễn Blender 3D này, chỉnh sửa tài liệu đáp ứng.

00:01:11.000 --> 00:01:21.000
Khi bạn sửa đổi thanh trượt vật liệu trong giao diện người dùng, kết quả sẽ được hiển thị ngay lập tức trong khung nhìn mà không bị giật do biên dịch lại đổ bóng.

00:01:21.000 --> 00:01:34.000
Sau khi tài liệu được sửa đổi, hiệu suất kết xuất kết quả sẽ nhanh chóng và tương tác, mang đến cho người sáng tạo nội dung khả năng xem hiệu quả kết quả công việc của họ.

00:01:34.000 --> 00:01:43.000
Để đạt được quy trình làm việc đáp ứng và hiệu quả trong ứng dụng của bạn, bạn có thể tận dụng các tính năng chính của Metal và triển khai các phương pháp hay nhất của Metal.

00:01:43.000 --> 00:01:59.000
Metal có thể giúp bạn tối đa hóa hiệu suất của các bộ đổ bóng phức tạp tận dụng biên dịch không đồng bộ để giữ cho ứng dụng đáp ứng, biên dịch nhanh hơn với liên kết động và điều chỉnh bộ đổ bóng tính toán của bạn với các tùy chọn trình biên dịch Metal mới.

00:01:59.000 --> 00:02:05.000
Tối ưu hóa bộ đổ bóng của bạn là chìa khóa cho hiệu suất.

00:02:05.000 --> 00:02:11.000
Bộ đổ bóng uber là một ví dụ về bộ đổ bóng dài và phức tạp có thể được sử dụng để hiển thị bất kỳ vật liệu nào có thể.

00:02:11.000 --> 00:02:17.000
Những loại đổ bóng này có rất nhiều nhánh cho bất kỳ sự kết hợp nào có thể.

00:02:17.000 --> 00:02:25.000
Khi các nghệ sĩ tạo ra vật liệu, các thông số vật liệu được lưu trữ trong bộ đệm Kim loại, được sử dụng bởi bộ đổ bóng vật liệu.

00:02:25.000 --> 00:02:35.000
Bộ đệm này được cập nhật khi bạn thay đổi các tham số, nhưng không cần biên dịch lại.

00:02:35.000 --> 00:02:39.000
Cách tiếp cận này cung cấp trải nghiệm tác giả đáp ứng tuyệt vời.

00:02:39.000 --> 00:02:48.000
Tuy nhiên, bộ đổ bóng uber không phải là tối ưu vì chúng phải tính đến tất cả các tùy chọn có thể.

00:02:48.000 --> 00:02:55.000
Để tạo ra biến thể đổ bóng tối ưu nhất, bạn nên sử dụng chuyên môn hóa kim loại với các hằng số hàm.

00:02:55.000 --> 00:03:02.000
Chỉ cần khai báo các hằng số hàm trong bộ đổ bóng kim loại của bạn và đặt giá trị của chúng trong thời gian chạy khi chúng được thay đổi.

00:03:02.000 --> 00:03:09.000
Nội dung bộ đệm vật liệu chỉ đơn giản là trở thành hằng số trong trạng thái đường ống đổ bóng của bạn, phân nhánh động được loại bỏ.

00:03:09.000 --> 00:03:13.000
Các vật liệu chuyên dụng mang lại cho bạn hiệu suất cao nhất.

00:03:13.000 --> 00:03:21.000
Đây là so sánh dữ liệu hiệu suất thời gian thực từ hai tài sản thử nghiệm phổ biến trong Blender 3D, Wanderer và Tree Creature.

00:03:21.000 --> 00:03:28.000
Đầu tiên là hiệu suất cơ bản trong khung hình trên giây của các cảnh bằng cách sử dụng bộ đổ bóng uber.

00:03:28.000 --> 00:03:34.000
Thứ hai là cách tiếp cận đổ bóng chuyên biệt với các hằng số hàm hoạt động nhanh hơn nhiều.

00:03:34.000 --> 00:03:45.000
Để tạo ra biến thể đổ bóng chuyên dụng nhanh nhất, hãy sử dụng hằng số chức năng để vô hiệu hóa các tính năng không sử dụng và loại bỏ sự phân nhánh.

00:03:45.000 --> 00:03:54.000
Bộ đổ bóng uber sẽ truy vấn các tham số vật liệu từ bộ đệm thực hiện các nhánh có điều kiện trong thời gian chạy để bật và tắt các tính năng.

00:03:54.000 --> 00:03:59.000
Với các hằng số hàm, bạn khai báo một hằng số cho mỗi tính năng vật liệu.

00:03:59.000 --> 00:04:09.000
Bây giờ nhánh động cho đường dẫn mã tính năng được thay thế bằng hằng số hàm, loại bỏ tất cả mã không sử dụng.

00:04:09.000 --> 00:04:14.000
Đây là cùng một trình đổ bóng uber hiện đang sử dụng hằng số hàm.

00:04:14.000 --> 00:04:20.000
Trình biên dịch Metal có thể gấp chúng dưới dạng booleans liên tục và xóa mã không sử dụng.

00:04:20.000 --> 00:04:29.000
Các biểu thức nhánh giải quyết thành sai sẽ được tối ưu hóa, chỉ để lại các nhánh thực.

00:04:29.000 --> 00:04:34.000
Tất cả các luồng điều khiển không sử dụng đều được tối ưu hóa.

00:04:34.000 --> 00:04:40.000
Bộ đổ bóng chuyên dụng hiện không cần truy vấn dữ liệu vật liệu, có luồng điều khiển đơn giản hơn nhiều.

00:04:40.000 --> 00:04:48.000
Tải bộ nhớ và các nhánh đã bị loại bỏ dẫn đến hiệu suất thời gian chạy nhanh hơn.

00:04:48.000 --> 00:04:52.000
Chuyên môn hóa chức năng cũng giúp gấp các hằng số.

00:04:52.000 --> 00:04:58.000
Các thông số vật liệu không thay đổi được thay thế bằng các hằng số.

00:04:58.000 --> 00:05:03.000
Vật liệu ví dụ này sử dụng một tập hợp các thông số đầu vào từ bộ đệm Kim loại.

00:05:03.000 --> 00:05:09.000
Các thông số có thể là màu sắc, trọng lượng, màu sáng và nhiều hơn nữa.

00:05:09.000 --> 00:05:16.000
Tại thời điểm tạo vật liệu, các tham số tĩnh này có thể được thay thế bằng các hằng số hàm.

00:05:16.000 --> 00:05:23.000
Các hằng số hàm tạo ra mã tối ưu nhất mà không cần đọc bộ đệm.

00:05:23.000 --> 00:05:30.000
Ở phía máy chủ, các giá trị hằng số hàm được cung cấp khi tạo trạng thái đường ống chuyên biệt.

00:05:30.000 --> 00:05:37.000
Cấu trúc MaterialParameter có thể được sử dụng để biểu diễn tất cả các tham số không đổi cho một vật liệu.

00:05:37.000 --> 00:05:44.000
IsGlossy là một ví dụ về tính năng vật liệu boolean cờ kiểm soát độ bóng.

00:05:44.000 --> 00:05:50.000
MaterialColor là một ví dụ về tham số vectơ được sử dụng để mô tả màu sắc.

00:05:50.000 --> 00:06:02.000
Để tạo một Đối tượng Trạng thái Đường ống chuyên dụng, hãy lặp lại bộ MetalFunctionConstantValues và chèn các giá trị bằng cách sử dụng setConstantValue.

00:06:02.000 --> 00:06:05.000
Sau đó chỉ cần tạo một Render Pipeline như bình thường.

00:06:05.000 --> 00:06:16.000
Sự khác biệt duy nhất là khi tạo hàm phân đoạn, bạn sẽ sử dụng biến thể của newFunctionWithName với constantValues.

00:06:16.000 --> 00:06:19.000
Cuối cùng, tạo Đối tượng Trạng thái Đường ống của bạn.

00:06:19.000 --> 00:06:26.000
Bộ đổ bóng kết quả là biến thể hoạt động tối ưu nhất của vật liệu này.

00:06:26.000 --> 00:06:35.000
Luôn sử dụng phần Hiệu suất gỡ lỗi GPU của Xcode để xác nhận tác động của việc sử dụng hằng số hàm.

00:06:35.000 --> 00:06:42.000
Bộ đổ bóng uber ban đầu cho thấy một số lượng lớn các hướng dẫn ALU và một lượng lớn sự cố tràn.

00:06:42.000 --> 00:06:46.000
Số lần chờ bộ nhớ cũng rất lớn.

00:06:46.000 --> 00:06:51.000
Cách tiếp cận chuyên biệt giúp giảm đau ngay lập tức cho ALU và sự cố tràn dầu.

00:06:51.000 --> 00:06:55.000
Điều này là do loại bỏ mã chết và gấp các hằng số.

00:06:55.000 --> 00:07:01.000
Ngoài ra, số lần chờ bộ nhớ nhỏ hơn đáng kể.

00:07:01.000 --> 00:07:11.000
Quan sát bộ đổ bóng uber ban đầu trong chi phí thực thi bộ đổ bóng thời gian chạy, GPU đang dành thời gian đáng kể để chờ bộ nhớ.

00:07:11.000 --> 00:07:23.000
Ngược lại, cách tiếp cận chuyên biệt dành ít thời gian hơn cho việc chờ đợi bộ nhớ, cho phép sử dụng ALU hiệu quả hơn, cùng với các lợi ích hiệu quả khác.

00:07:23.000 --> 00:07:31.000
Trong chế độ xem dòng thời gian Trình gỡ lỗi GPU, phải mất 58 mili giây để hiển thị vật liệu vượt qua bằng cách sử dụng đổ bóng uber.

00:07:31.000 --> 00:07:36.000
Và chỉ 12,5 mili giây để kết xuất với các phiên bản chuyên biệt.

00:07:36.000 --> 00:07:40.000
Đó là một sự cải tiến khá đáng kể.

00:07:40.000 --> 00:07:52.000
Chuyên môn hóa vật liệu yêu cầu biên dịch đổ bóng thời gian chạy và điều này thường sẽ dẫn đến việc quá giang nếu bạn chặn và đợi các tài liệu chuyên biệt này được tạo.

00:07:52.000 --> 00:08:06.000
Các API biên dịch không đồng bộ Metal cho phép bạn sử dụng các bộ đổ bóng uber chung và giữ cho trải nghiệm người dùng tương tác và đáp ứng trong khi tạo các phiên bản chuyên biệt trong nền.

00:08:06.000 --> 00:08:11.000
Để chọn tham gia tạo trạng thái đường ống không đồng bộ, hãy cung cấp trình xử lý hoàn thành.

00:08:11.000 --> 00:08:18.000
Những cuộc gọi này sẽ quay lại ngay lập tức cho phép bạn giữ cho trải nghiệm người dùng tương tác và đáp ứng.

00:08:18.000 --> 00:08:28.000
Trình xử lý hoàn thành sẽ được gọi khi trạng thái đường ống chuyên dụng sẵn sàng và bạn có thể chuyển sang bộ đổ bóng tối ưu ngay lập tức.

00:08:28.000 --> 00:08:31.000
Đây là sơ đồ của quy trình làm việc vật liệu không đồng bộ.

00:08:31.000 --> 00:08:38.000
Theo mặc định, khi vật liệu chưa được chuyên biệt hóa, bạn sử dụng bộ đổ bóng uber của mình.

00:08:38.000 --> 00:08:44.000
Đồng thời, Metal biên dịch bộ đổ bóng chuyên dụng trong nền.

00:08:44.000 --> 00:08:51.000
Sau khi hoàn thành việc này, bạn có thể chuyển bộ đổ bóng uber cho vật liệu chuyên dụng nhanh chóng.

00:08:51.000 --> 00:08:58.000
Bộ sưu tập Runtime Metal shaders được thiết kế để cung cấp mức độ song song cân bằng.

00:08:58.000 --> 00:09:08.000
Tuy nhiên, các ứng dụng tạo nội dung hiện đại cần cung cấp quy trình chỉnh sửa đa vật liệu, dẫn đến nhiều lần biên dịch lại đổ bóng.

00:09:08.000 --> 00:09:16.000
Để giúp đỡ nhu cầu tác giả nặng nề như vậy, bạn có thể muốn yêu cầu Metal tối đa hóa tính song song biên dịch đổ bóng.

00:09:16.000 --> 00:09:24.000
Thiết bị kim loại có một thuộc tính mới trong macOS13.3 được gọi là should-Maximize-Concurrent-Compilation.

00:09:24.000 --> 00:09:30.000
Khi bạn đặt nó thành Có, trình biên dịch Metal sẽ tận dụng tốt nhất các lõi CPU của bạn.

00:09:30.000 --> 00:09:37.000
Tối đa hóa biên dịch đồng thời thực sự tuyệt vời cho quy trình làm việc của tác giả đa tài liệu.

00:09:37.000 --> 00:09:44.000
Với các công việc biên dịch bổ sung có sẵn, các biến thể vật liệu chuyên biệt có sẵn sớm hơn nhiều.

00:09:44.000 --> 00:09:46.000
Đây là cách tất cả hoạt động trong thực tế.

00:09:46.000 --> 00:09:58.000
Khi các thông số vật liệu được thay đổi, các biến thể chuyên biệt hiện tại của vật liệu bị vô hiệu hóa, có một công tắc quay trở lại sử dụng bộ đổ bóng uber để giữ cho chất lỏng tác giả.

00:09:58.000 --> 00:10:07.000
Một công việc không đồng bộ mới được xếp hàng đợi và khi hoàn thành, bạn có thể quan sát thấy sự cải thiện hiệu suất đáng kể sau khi tài liệu chuyên dụng được tham gia.

00:10:07.000 --> 00:10:16.000
Hầu hết các ứng dụng hiện đại đều có các vật liệu cực kỳ phức tạp, vì vậy có thể mất một khoảng thời gian đáng kể để một biến thể chuyên dụng sẵn sàng.

00:10:16.000 --> 00:10:25.000
Các thư viện động trong Metal có thể được sử dụng để biên dịch trước các chức năng tiện ích và giảm thời gian biên dịch tài liệu tổng thể.

00:10:25.000 --> 00:10:31.000
Bạn làm điều này bằng cách chia các nhóm chức năng thành các thư viện động riêng biệt.

00:10:31.000 --> 00:10:37.000
Để biên dịch thời gian chạy nhanh hơn, các thư viện tiện ích có thể được biên dịch trước ngoại tuyến.

00:10:37.000 --> 00:10:43.000
Và cuối cùng bạn biên dịch ít mã hơn nhiều trong thời gian chạy.

00:10:43.000 --> 00:10:47.000
Nếu tôi lấy bộ đổ bóng uber trước đó và chia nó thành các dylibs.

00:10:47.000 --> 00:10:51.000
Một cách tiếp cận là chia nó theo các nhóm chức năng chung.

00:10:51.000 --> 00:10:58.000
Trong trường hợp này, một thư viện tiện ích toán học và một thư viện khác cho các chức năng chiếu sáng.

00:10:58.000 --> 00:11:04.000
Để làm cho các ký hiệu hàm hiển thị cho liên kết, bạn chỉ định khả năng hiển thị "mặc định".

00:11:04.000 --> 00:11:12.000
Các biểu tượng cũng có thể bị ẩn khỏi các chương trình bên ngoài bằng cách gán khả năng hiển thị cho "ẩn".

00:11:12.000 --> 00:11:17.000
Có hai thuộc tính để kiểm tra xem thiết bị Metal của bạn có hỗ trợ các thư viện động hay không.

00:11:17.000 --> 00:11:24.000
Đối với các đường ống kết xuất, bạn nên sử dụng thuộc tính supportsRenderDynamicLibraries của thiết bị Metal.

00:11:24.000 --> 00:11:30.000
Điều này hiện có sẵn trên các thiết bị có dòng GPU Apple6 trở lên.

00:11:30.000 --> 00:11:36.000
Đối với các đường ống tính toán, bạn nên truy vấn thuộc tính supportsDynamicLibraries.

00:11:36.000 --> 00:11:43.000
Cái này có sẵn trên Apple6 trở lên và cho hầu hết các dòng GPU Mac2.

00:11:43.000 --> 00:11:53.000
Để tạo một thư viện động từ một thư viện Metal hiện có, chỉ cần gọi newDynamicLibrary và chuyển nó thành thư viện Metal.

00:11:53.000 --> 00:12:03.000
Để tạo từ URL, hãy gọi phương thức newDynamicLibraryWithURL và cung cấp đường dẫn đến thư viện động được lưu trữ.

00:12:03.000 --> 00:12:08.000
Bạn có thể biên dịch trước các thư viện động ngoại tuyến bằng cách sử dụng chuỗi công cụ biên dịch kim loại.

00:12:08.000 --> 00:12:15.000
Khi tải các thư viện động được biên dịch trước trong thời gian chạy, việc biên dịch hoàn toàn tránh được.

00:12:15.000 --> 00:12:26.000
Để chỉ định dylibs trong giai đoạn liên kết: chuyển một mảng các Đối tượng Thư viện Động Kim loại vào các tham số Thư viện được tải sẵn trên bộ mô tả đường ống.

00:12:26.000 --> 00:12:35.000
Ngoài ra còn có tùy chọn cung cấp mảng thư viện động này thông qua Tùy chọn biên dịch kim loại khi biên dịch các thư viện đổ bóng khác.

00:12:35.000 --> 00:12:42.000
Di chuyển các phần lớn mã tiện ích vào các thư viện động rút ngắn đáng kể thời gian chạy biên dịch.

00:12:42.000 --> 00:12:52.000
Và cuối cùng, việc điều chỉnh các tùy chọn trình biên dịch thực sự quan trọng đối với các trường hợp tính toán như truy tìm đường dẫn trong kết xuất chất lượng sản xuất cuối cùng.

00:12:52.000 --> 00:12:58.000
Và có một tính năng Metal bổ sung để tận dụng tối đa hiệu suất trong kết xuất cuối cùng của bạn.

00:12:58.000 --> 00:13:10.000
Các tùy chọn trình biên dịch kim loại và gợi ý chiếm chỗ, cho phép bạn điều chỉnh hiệu suất của bất kỳ hạt nhân tính toán nào trong số này một cách cụ thể khi làm việc với liên kết động.

00:13:10.000 --> 00:13:17.000
Mọi khối lượng công việc GPU đều có một điểm ngọt ngào về hiệu suất cần phân tích và đánh giá.

00:13:17.000 --> 00:13:26.000
Có một Metal API để nhắm mục tiêu công suất GPU mong muốn, hiện cũng có sẵn cho các thư viện động.

00:13:26.000 --> 00:13:33.000
Điều này có thể mở khóa hiệu suất cho khối lượng công việc hiện có mà không cần thay đổi mã hoặc thuật toán gốc.

00:13:33.000 --> 00:13:45.000
Điều đáng chú ý là bất kỳ điều chỉnh nào cũng cần được thực hiện trên mỗi thiết bị vì các đặc tính hiệu suất có thể khác nhau tùy thuộc vào kiến trúc GPU.

00:13:45.000 --> 00:13:56.000
Thuộc tính mô tả đường ống tính toán Metal cho phép bạn thể hiện mức chiếm dụng mong muốn bằng cách chỉ định giá trị Max-Total-Threads-Per-Threadgroup.

00:13:56.000 --> 00:14:02.000
Giá trị càng cao, bạn gợi ý trình biên dịch càng nhắm đến công suất cao.

00:14:02.000 --> 00:14:13.000
Bây giờ, sử dụng thuộc tính Metal-Compile-Options mới này cho các thư viện động, bạn có thể khớp với mức độ lấp đầy mong muốn của đối tượng trạng thái đường ống.

00:14:13.000 --> 00:14:24.000
Max-Total-Threads-Per-Threadgroup có sẵn cho MetalCompileOptions trong iOS 16.4 và macOS 13.3.

00:14:24.000 --> 00:14:33.000
Bây giờ bạn có thể chỉ cần kết hợp công suất mong muốn của Pipeline State Object trong khi điều chỉnh các thư viện động Metal để có hiệu suất tối ưu.

00:14:33.000 --> 00:14:42.000
Biểu đồ này của hiệu suất hạt nhân tính toán giao điểm và đổ bóng của Blender Cycles cho thấy tác động của việc thay đổi Max-Total-Threads-Per-Threadgroup.

00:14:42.000 --> 00:14:48.000
Đó là biến duy nhất được thay đổi cho đối tượng trạng thái đường ống và dylibs.

00:14:48.000 --> 00:14:53.000
Trong trường hợp này, có một điểm ngọt ngào nơi hạt nhân hoạt động tốt nhất.

00:14:53.000 --> 00:15:03.000
Mỗi khối lượng công việc và thiết bị là duy nhất và giá trị tối ưu của Max-Total-Threads-Per-Threadgroup khác nhau tùy thuộc vào bản chất của hạt nhân.

00:15:03.000 --> 00:15:10.000
Giá trị tối ưu không phải lúc nào cũng nhất thiết phải là số lượng luồng tối đa trên mỗi nhóm luồng mà GPU hỗ trợ.

00:15:10.000 --> 00:15:16.000
Thử nghiệm với hạt nhân của bạn để tìm giá trị tối ưu mà bạn muốn sử dụng và nướng trong mã.

00:15:16.000 --> 00:15:24.000
Đây là hạt nhân tô bóng Blender Cycles, số liệu thống kê trình biên dịch chứng minh rằng hạt nhân rất phức tạp.

00:15:24.000 --> 00:15:28.000
Có một số thông số ảnh hưởng đến thời gian chạy thực tế.

00:15:28.000 --> 00:15:34.000
Lượng tràn, số lượng thanh ghi được sử dụng và các hoạt động khác như tải bộ nhớ.

00:15:34.000 --> 00:15:44.000
Bằng cách điều chỉnh Max-Total-Threads-Per-Threadgroup, bạn có thể thay đổi công suất mục tiêu và tìm thấy điểm ngọt ngào về hiệu suất đó.

00:15:44.000 --> 00:15:55.000
Sau khi tìm thấy điểm ngọt ngào, sự cố tràn tăng lên một chút, nhưng tăng công suất lấp đầy tổng thể đã dẫn đến hiệu suất hạt nhân tốt hơn đáng kể.

00:15:55.000 --> 00:16:10.000
Trình theo dõi đường dẫn Cycles trong Blender 3D 3.5 hiện đã được tối ưu hóa tốt cho Metal và nó sử dụng tất cả các phương pháp hay nhất mà tôi đã đề cập ngày hôm nay.

00:16:10.000 --> 00:16:38.000
Hãy nhớ tối đa hóa hiệu suất đổ bóng của các bộ đổ bóng lớn và phức tạp bằng cách sử dụng chuyên môn hóa chức năng, sử dụng biên dịch không đồng bộ để giữ cho ứng dụng đáp ứng dụng trong khi tạo các bộ đổ bóng được tối ưu hóa trong nền, cho phép liên kết động để biên dịch nhanh hơn trong thời gian chạy và điều chỉnh hạt nhân tính toán của bạn

00:16:38.000 --> 00:16:48.000
Hãy chắc chắn kiểm tra các phiên trước, nơi bạn có thể học cách mở rộng quy mô khối lượng công việc tính toán cho GPU của Apple và khám phá thêm quy trình biên dịch trong Metal.

00:16:48.000 --> 00:16:50.000
Cảm ơn bạn đã xem.

00:16:50.000 --> 23:59:59.000
♪ ♪

