WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:14.000
Người: Xin chào, và chào mừng đến với "Demystify SwiftUI Performance."

00:00:14.000 --> 00:00:22.000
SwiftUI giúp dễ dàng xây dựng các ứng dụng phức tạp, mạnh mẽ, cung cấp một tập hợp lớn các tính năng và các điều khiển phức tạp như danh sách và bảng.

00:00:22.000 --> 00:00:28.000
Khi bạn mới bắt đầu và ứng dụng của bạn không phức tạp lắm, các vấn đề về hiệu suất không rõ ràng.

00:00:28.000 --> 00:00:32.000
Nhưng khi sự phức tạp của ứng dụng của bạn tăng lên, hiệu suất trở nên quan trọng hơn.

00:00:32.000 --> 00:00:39.000
Các vấn đề nhỏ có thể được khuếch đại và mã hoạt động tốt cho nguyên mẫu có thể không hoạt động tốt trong sản xuất.

00:00:39.000 --> 00:00:52.000
Phiên này là tất cả về việc xây dựng một mô hình tinh thần cho hiệu suất trong SwiftUI bởi vì nếu bạn hiểu cách viết mã nhanh ngay từ đầu quá trình phát triển, bạn sẽ gặp ít vấn đề hơn khi ứng dụng của bạn trở nên phức tạp hơn.

00:00:52.000 --> 00:00:56.000
Hãy kiểm tra vòng phản hồi liên quan đến việc giải quyết vấn đề hiệu suất.

00:00:56.000 --> 00:00:58.000
Các vấn đề về hiệu suất bắt đầu bằng một triệu chứng.

00:00:58.000 --> 00:01:05.000
Có lẽ có một cú đẩy điều hướng chậm, một hình ảnh động bị hỏng hoặc bạn đang nhìn thấy con trỏ chờ quay trên macOS.

00:01:05.000 --> 00:01:11.000
Khi bạn xác định được một vấn đề về hiệu suất, bước đầu tiên để giải quyết nó là đo lường.

00:01:11.000 --> 00:01:16.000
Khi bạn đã đo lường và xác minh rằng triệu chứng tồn tại, hãy xác định nguyên nhân của nó.

00:01:16.000 --> 00:01:24.000
Đây thường có thể là một trong những giai đoạn phức tạp hơn của vòng lặp này bởi vì nó đòi hỏi trực giác về cách mọi thứ được cho là hoạt động.

00:01:24.000 --> 00:01:27.000
Lỗi phát sinh khi ứng dụng của bạn có giả định không chính xác.

00:01:27.000 --> 00:01:33.000
Phiên này nhằm giúp bạn xác định sự không phù hợp giữa các giả định và thực tế của ứng dụng của bạn.

00:01:33.000 --> 00:01:37.000
Sau khi xác định nguyên nhân gốc rễ, hãy khắc phục sự cố thông qua tối ưu hóa.

00:01:37.000 --> 00:01:42.000
Nhưng các vấn đề về hiệu suất không kết thúc sau khi bạn đã tìm ra nguyên nhân gốc rễ và tối ưu hóa mã của mình.

00:01:42.000 --> 00:01:48.000
Bạn cần đo lại và xác minh lại bất kỳ bản sửa lỗi nào bạn thực hiện để đảm bảo rằng nó giải quyết được vấn đề.

00:01:48.000 --> 00:01:53.000
Đây là một phương pháp hay cho tất cả các lỗi, nhưng nó đặc biệt quan trọng đối với hiệu suất.

00:01:53.000 --> 00:01:57.000
Sau khi bạn đã xác minh rằng vấn đề đã được giải quyết, bạn phá vỡ vòng lặp.

00:01:57.000 --> 00:02:00.000
Sơ đồ này đặt phiên này vào ngữ cảnh.

00:02:00.000 --> 00:02:06.000
Lý tưởng nhất, bạn không bao giờ kết thúc trong chu kỳ này và bạn có thể tránh được nhiều vấn đề về hiệu suất bằng cách viết mã nhanh khi tạo mẫu.

00:02:06.000 --> 00:02:12.000
Tuy nhiên, không thể tránh khỏi rằng, khi ứng dụng của bạn trở nên phức tạp hơn, bạn sẽ gặp phải lỗi hiệu suất.

00:02:12.000 --> 00:02:14.000
Nó xảy ra với những người giỏi nhất trong chúng ta.

00:02:14.000 --> 00:02:20.000
Và khi bạn gặp phải các vấn đề về hiệu suất, thật tốt khi có nhiều công cụ theo ý của bạn để phân loại và khắc phục chúng.

00:02:20.000 --> 00:02:24.000
Phiên này nhằm mục đích giúp việc vượt qua vòng lặp dễ dàng hơn.

00:02:24.000 --> 00:02:28.000
Đây là một phiên nâng cao, và có một số điều kiện tiên quyết.

00:02:28.000 --> 00:02:35.000
Bạn nên hiểu sơ lược về danh tính SwiftUI, bao gồm sự khác biệt giữa danh tính ngầm và danh tính rõ ràng.

00:02:35.000 --> 00:02:41.000
Điều quan trọng là phải biết sự khác biệt giữa tuổi thọ quan điểm và bản sắc quan điểm.

00:02:41.000 --> 00:02:43.000
Nếu bạn không có những điều kiện tiên quyết này, đừng lo lắng.

00:02:43.000 --> 00:02:49.000
Phiên "Demystify SwiftUI" từ WWDC21 đã giúp bạn.

00:02:49.000 --> 00:02:53.000
Phiên hôm nay tiếp tục nơi mà phiên đó đã dừng lại.

00:02:53.000 --> 00:02:55.000
Hãy xem qua chương trình nghị sự.

00:02:55.000 --> 00:03:00.000
Chúng ta sẽ bắt đầu với một cuộc thảo luận chuyên sâu về các phụ thuộc và khám phá quy trình cập nhật SwiftUI một cách chi tiết.

00:03:00.000 --> 00:03:06.000
Tiếp theo, chúng ta sẽ chuyển sang thảo luận về các bản cập nhật và cách cải thiện tốc độ SwiftUI cập nhật giao diện của bạn.

00:03:06.000 --> 00:03:11.000
Và cuối cùng, nhưng chắc chắn không kém phần quan trọng, chúng ta sẽ thảo luận về danh tính trong danh sách và bảng.

00:03:11.000 --> 00:03:17.000
Trên đường đi, chúng ta sẽ xem qua SwiftUI và xem một số mẹo và thủ thuật để sử dụng khi phát triển.

00:03:17.000 --> 00:03:26.000
Phiên này chủ yếu liên quan đến việc cập nhật chậm vào hệ thống phân cấp chế độ xem, nhưng hoàn toàn không phải là một cái nhìn toàn diện về tất cả các vấn đề về hiệu suất mà bạn có thể gặp phải khi phát triển một ứng dụng.

00:03:26.000 --> 00:03:29.000
Hãy bắt đầu với Phụ thuộc.

00:03:29.000 --> 00:03:35.000
Đã vài năm kể từ phiên "Demystify SwiftUI" cuối cùng và tôi đã bỏ lỡ việc làm việc trên các ứng dụng theo chủ đề chó.

00:03:35.000 --> 00:03:43.000
Vì vậy, tiếp tục chủ đề từ phiên đó, tôi đã làm việc trên một ứng dụng mới cho phép tôi theo dõi những người bạn lông lá yêu thích của mình và thiết lập thời gian để chơi với họ.

00:03:43.000 --> 00:03:46.000
Đây là một trong những khung cảnh, một bảng hiển thị tất cả những con chó.

00:03:46.000 --> 00:03:57.000
Ứng dụng cũng có chế độ xem chi tiết, được hiển thị ở đây trên iPhone, hiển thị hình ảnh lớn hơn về từng con chó, sở thích của con chó và cung cấp một nút để thiết lập thời gian chơi.

00:03:57.000 --> 00:03:59.000
Đây là mã cho cùng một chế độ xem đó.

00:03:59.000 --> 00:04:05.000
Chế độ xem lấy một con chó làm tham số và cũng có một thuộc tính môi trường để biết liệu đó có phải là thời gian chơi hay không.

00:04:05.000 --> 00:04:14.000
Như đã đề cập trong phiên Demystify trước đó, điều này có nghĩa là con chó và các biến thời gian chơi là phụ thuộc của chế độ xem và một cách khác để hiển thị chế độ xem này là dưới dạng biểu đồ.

00:04:14.000 --> 00:04:18.000
Đây là một biểu đồ cơ bản đại diện cho cùng một chế độ xem.

00:04:18.000 --> 00:04:21.000
Mỗi mũi tên đại diện cho phần thân của một khung cảnh.

00:04:21.000 --> 00:04:23.000
Chế độ xem chó tạo ra một ngăn xếp.

00:04:23.000 --> 00:04:30.000
Và ngăn xếp có nhiều con, như một số văn bản, hình ảnh con chó có thể mở rộng, chế độ xem chi tiết và nút.

00:04:30.000 --> 00:04:38.000
Tiếp tục, mỗi chế độ xem đó đều có con và biểu đồ tiếp tục cho đến khi đạt đến chế độ xem lá, như hình ảnh, văn bản hoặc màu sắc.

00:04:38.000 --> 00:04:41.000
Tất cả các quan điểm cuối cùng đều giải quyết thành một cái nhìn lá.

00:04:41.000 --> 00:04:45.000
Có rất nhiều lượt xem lá trong SwiftUI, vì vậy tôi sẽ không bao gồm tất cả chúng ở đây.

00:04:45.000 --> 00:04:49.000
Kiểm tra tài liệu để biết thêm thông tin.

00:04:49.000 --> 00:04:51.000
Hãy quay lại ứng dụng.

00:04:51.000 --> 00:04:55.000
Bất cứ khi nào tôi sử dụng ứng dụng, tôi có thể đăng nhập bất cứ khi nào tôi chơi với một trong những người bạn của mình.

00:04:55.000 --> 00:05:01.000
Tôi vừa chơi xong trò tìm nạp với Rocky ở đây, vì vậy tôi đã lưu ý điều đó trong ứng dụng, ứng dụng này cập nhật nút và hình ảnh.

00:05:01.000 --> 00:05:05.000
Rocky trông khá hạnh phúc, nhưng anh ấy chắc chắn quá mệt mỏi để chơi bây giờ.

00:05:05.000 --> 00:05:09.000
Khi dữ liệu này thay đổi trong mô hình, SwiftUI sẽ cập nhật chế độ xem này.

00:05:09.000 --> 00:05:16.000
Hãy cùng khám phá quá trình cập nhật chuyên sâu bằng cách quay lại biểu đồ và xem điều gì sẽ xảy ra khi thay đổi này xảy ra.

00:05:16.000 --> 00:05:17.000
Đây là biểu đồ của chúng tôi một lần nữa.

00:05:17.000 --> 00:05:24.000
Đây là nơi phiên Demystify trước đó dừng lại, giải thích rằng các chế độ xem tạo thành một biểu đồ và SwiftUI xem xét các phụ thuộc khi đánh giá mã của bạn.

00:05:24.000 --> 00:05:32.000
Hãy phóng to và cung cấp cái nhìn sâu sắc hơn về nguồn gốc của những phụ thuộc đó và cách bạn có thể kiểm soát chúng.

00:05:32.000 --> 00:05:37.000
Mỗi chế độ xem con phụ thuộc vào giá trị chế độ xem được tạo ra bởi tổ tiên của nó.

00:05:37.000 --> 00:05:39.000
Nhưng cũng có những hình thức phụ thuộc khác.

00:05:39.000 --> 00:05:42.000
Các thuộc tính động cũng là một nguồn phụ thuộc phổ biến.

00:05:42.000 --> 00:05:48.000
Ví dụ, DogView đọc liệu đó có phải là thời gian phát từ môi trường hay không bằng cách sử dụng trình bao bọc thuộc tính @Environment.

00:05:48.000 --> 00:05:55.000
Do đó, nó phụ thuộc cả vào giá trị do cha mẹ tạo ra và giá trị từ môi trường.

00:05:55.000 --> 00:06:02.000
Nếu chúng ta hình dung thời gian trên trục X, bước đầu tiên trong quá trình cập nhật là tạo ra một giá trị mới cho chế độ xem.

00:06:02.000 --> 00:06:09.000
Giá trị này bao gồm tất cả các thuộc tính được lưu trữ của chế độ xem, như giá trị chó và giá trị ban đầu của thuộc tính động.

00:06:09.000 --> 00:06:16.000
Tiếp theo, SwiftUI cập nhật tất cả các thuộc tính động của chế độ xem, thay thế các giá trị của chúng bằng các giá trị hiện tại từ biểu đồ.

00:06:16.000 --> 00:06:21.000
Cuối cùng, với giá trị cập nhật, cơ thể chạy để tạo ra con cái của chế độ xem.

00:06:21.000 --> 00:06:23.000
Hãy mang biểu đồ vào một lần nữa.

00:06:23.000 --> 00:06:30.000
Quá trình này hoàn trả để cập nhật giao diện, chỉ cập nhật những chế độ xem có giá trị mới hoặc các phụ thuộc đã thay đổi khác.

00:06:30.000 --> 00:06:38.000
Khi chúng tôi đánh dấu Rocky là mệt mỏi, chúng tôi nhận được một con chó mới - xin lỗi, một giá trị cấu trúc con chó mới, nhưng nó vẫn giữ nguyên Rocky.

00:06:38.000 --> 00:06:43.000
Bởi vì dữ liệu của chúng tôi là một loại giá trị, một bản sao mới của nó được tạo ra khi nó bị đột biến.

00:06:43.000 --> 00:06:49.000
Và điều đó dẫn đến việc DogView tạo ra nội dung mới cho ngăn xếp, Cập nhật con của ngăn xếp.

00:06:49.000 --> 00:06:55.000
Tôi chỉ tập trung vào ScalableDogImage ở đây, nhưng các chế độ xem khác có thể cập nhật nếu chúng phụ thuộc vào giá trị của chó.

00:06:55.000 --> 00:06:59.000
ScalableDogImage cuối cùng tạo ra một hình ảnh mới.

00:06:59.000 --> 00:07:04.000
Hình ảnh là chế độ xem lá, vì vậy phần còn lại của công việc được SwiftUI thực hiện từ đây.

00:07:04.000 --> 00:07:08.000
Quá trình sau đó kết thúc, và một kết xuất mới được tạo ra.

00:07:08.000 --> 00:07:11.000
Đó là cách nhìn vào biểu đồ phụ thuộc.

00:07:11.000 --> 00:07:13.000
Hãy xem qua một số mẹo để cải thiện quy trình này.

00:07:13.000 --> 00:07:17.000
Điều quan trọng là phải giảm các bản cập nhật xuống chỉ những cập nhật cần thiết.

00:07:17.000 --> 00:07:22.000
Để hiểu khi nào chế độ xem được cập nhật, SwiftUI có phương thức printChanges.

00:07:22.000 --> 00:07:27.000
Điều này cho phép bạn in ra lý do tại sao trình đánh giá biểu đồ SwiftUI gọi vào phần thân của chế độ xem.

00:07:27.000 --> 00:07:30.000
Hãy xem qua một ví dụ về cách sử dụng nó.

00:07:30.000 --> 00:07:34.000
Ở đây chúng tôi có hình ảnh con chó có thể mở rộng của chúng tôi, chứa một phần của trạng thái.

00:07:34.000 --> 00:07:41.000
Khi chúng ta nhấn vào hình ảnh, trạng thái sẽ thay đổi như vậy.

00:07:41.000 --> 00:07:53.000
Chỉ tập trung vào chế độ xem hình ảnh, nếu chúng ta đặt điểm dừng trong phần thân chế độ xem của mình, từ bảng điều khiển LLDB, chúng ta có thể gọi Self._printChanges bằng cách sử dụng lệnh LLDB "biểu thức".

00:07:53.000 --> 00:08:00.000
printChanges là một cơ sở chỉ gỡ lỗi đưa ra lời giải thích nỗ lực nhất về lý do tại sao SwiftUI yêu cầu nội dung của chế độ xem.

00:08:00.000 --> 00:08:03.000
Trong trường hợp này, đó là vì scaleToFill đã thay đổi.

00:08:03.000 --> 00:08:08.000
Bạn có thể sử dụng printChanges để hiểu liệu một chế độ xem có thể có thêm phụ thuộc hay không.

00:08:08.000 --> 00:08:13.000
Ví dụ, tôi hiện đang chạy ứng dụng của mình và gỡ lỗi và muốn xem liệu chế độ xem này có phụ thuộc thêm hay không.

00:08:13.000 --> 00:08:19.000
Tôi có thể thêm một cuộc gọi để inThay đổi vào nội dung của chế độ xem này để in mỗi khi nội dung của chế độ xem được truy cập.

00:08:19.000 --> 00:08:23.000
Tuy nhiên, lưu ý rằng printChanges có tiền tố là dấu gạch dưới.

00:08:23.000 --> 00:08:33.000
Trong trường hợp này, điều đó có nghĩa là, nó không bao giờ được đảm bảo luôn tồn tại và thậm chí có thể bị xóa trong bản phát hành trong tương lai, vì vậy đừng bao giờ gửi cuộc gọi đến phương thức này đến cửa hàng ứng dụng.

00:08:33.000 --> 00:08:35.000
Tôi sẽ cần xóa cuộc gọi này sau.

00:08:35.000 --> 00:08:38.000
Nó chỉ có nghĩa là để gỡ lỗi và có tác động đến hiệu suất thời gian chạy.

00:08:38.000 --> 00:08:48.000
Nếu tôi chạy lại ứng dụng của mình và thay đổi món ăn yêu thích của Rocky, chẳng hạn như từ bánh quy sang thứ khác, chẳng hạn như dưa chuột, tôi sẽ nhận thấy nhật ký vào bảng điều khiển từ hình ảnh của chúng tôi.

00:08:48.000 --> 00:08:49.000
Nó nói rằng "bản thân" đã thay đổi.

00:08:49.000 --> 00:08:58.000
Điều này có nghĩa là giá trị chế độ xem đã thay đổi, vì vậy chế độ xem hình ảnh có thể mở rộng phải có một số phụ thuộc vào điều trị, nhưng nó không thực sự cần thiết.

00:08:58.000 --> 00:09:03.000
Tập trung vào mã, giá trị của chế độ xem chỉ có thành viên scaleToFill và thuộc tính chó.

00:09:03.000 --> 00:09:12.000
Vì scaleToFill là một thuộc tính động SwiftUI, nó sẽ hiển thị trong nhật ký thay đổi nếu nó đã thay đổi, vì vậy "@Self" ở đây có nghĩa là giá trị con chó đã thay đổi.

00:09:12.000 --> 00:09:15.000
Nhưng nhìn vào khung cảnh này, chúng tôi chỉ quan tâm đến hình ảnh.

00:09:15.000 --> 00:09:19.000
Vì vậy, chúng ta có thể loại bỏ sự phụ thuộc này bằng cách thay vào đó chỉ sử dụng hình ảnh.

00:09:19.000 --> 00:09:27.000
Và bây giờ, khi tôi thay đổi tài sản của con chó không liên quan đến hình ảnh, tôi không thấy nhật ký.

00:09:27.000 --> 00:09:29.000
Các phụ thuộc của chế độ xem có phạm vi chặt chẽ.

00:09:29.000 --> 00:09:34.000
Nếu bạn làm theo kỹ thuật này, đừng quên xóa lệnh gọi printChanges.

00:09:34.000 --> 00:09:36.000
Hãy cập nhật chế độ xem phụ huynh để khớp.

00:09:36.000 --> 00:09:38.000
Đây là mã cho chế độ xem chó mẹ.

00:09:38.000 --> 00:09:44.000
Tôi cần cập nhật trình khởi tạo cho ScalableDogImage để chụp ảnh, như vậy.

00:09:44.000 --> 00:09:49.000
Bằng cách trích xuất ScalableDogImage ra, tôi đã giảm các phụ thuộc xuống chỉ còn những phụ thuộc quan trọng.

00:09:49.000 --> 00:09:53.000
Tôi cũng có thể làm tương tự với tiêu đề và trích xuất nó theo chế độ xem riêng của nó.

00:09:53.000 --> 00:09:55.000
Điều này có một số lợi ích.

00:09:55.000 --> 00:10:01.000
Mã này bây giờ dễ đọc hơn và các phụ thuộc của DogHeader rõ ràng tại trang web sử dụng của nó.

00:10:01.000 --> 00:10:05.000
Kỹ thuật này hoạt động tốt cho tầm nhìn nhỏ hơn, nhưng hãy cẩn thận với các cấu trúc rất lớn.

00:10:05.000 --> 00:10:08.000
Không phải mọi sự phụ thuộc đều xứng đáng được mở rộng phạm vi như thế này.

00:10:08.000 --> 00:10:11.000
Bạn sẽ cần sử dụng phán đoán tốt nhất của mình.

00:10:11.000 --> 00:10:15.000
Ít cập nhật hơn có nghĩa là hiệu suất tốt hơn khi dữ liệu thay đổi trong ứng dụng của bạn.

00:10:15.000 --> 00:10:19.000
Như chúng ta vừa khám phá, một cách để làm điều này là giảm sự phụ thuộc.

00:10:19.000 --> 00:10:24.000
Hãy thử giảm giá trị chế độ xem xuống chỉ còn dữ liệu mà chúng thực sự phụ thuộc vào.

00:10:24.000 --> 00:10:28.000
Một mẹo khác là trích xuất các chế độ xem để giảm sự phụ thuộc.

00:10:28.000 --> 00:10:36.000
Và cuối cùng, giao thức Observable mới cũng có thể giúp xác định phạm vi phụ thuộc bằng cách tự động giới hạn các phụ thuộc chỉ những gì được đọc.

00:10:36.000 --> 00:10:41.000
Kiểm tra phiên "Khám phá Quan sát trong SwiftUI" để biết thêm thông tin.

00:10:41.000 --> 00:10:44.000
Đó chỉ là một chuyến tham quan nhanh về cách nhìn vào các phụ thuộc.

00:10:44.000 --> 00:10:46.000
Hãy tiếp tục nói về những cập nhật nhanh hơn.

00:10:46.000 --> 00:10:51.000
Trong phần này, chúng ta sẽ thảo luận về cách giảm chi phí cho mỗi bản cập nhật SwiftUI.

00:10:51.000 --> 00:10:58.000
Các bản cập nhật SwiftUI chậm có thể có một số tác động tiêu cực đến ứng dụng của bạn, bao gồm giảm khả năng phản hồi, chẳng hạn như treo và quá giang.

00:10:58.000 --> 00:11:04.000
Treo là sự chậm trễ trong việc phản hồi tương tác của người dùng, giống như một chế độ xem mất nhiều thời gian để xuất hiện ban đầu.

00:11:04.000 --> 00:11:17.000
Phiên "Phân tích treo trong dụng cụ" từ WWDC2023 đi vào chi tiết về cách sử dụng Dụng cụ để phân tích treo, bao gồm cách xác định xem treo có thể do công việc liên quan đến SwiftUI gây ra hay không.

00:11:17.000 --> 00:11:24.000
Quá giang là một vấn đề hoạt hình có thể cảm nhận được của người dùng, chẳng hạn như tạm dừng trong khi cuộn hoặc bỏ qua các khung hình hoạt hình.

00:11:24.000 --> 00:11:29.000
Nguyên nhân gốc rễ của treo và quá giang, đặc biệt là trong SwiftUI, thường có liên quan.

00:11:29.000 --> 00:11:38.000
Để biết thêm thông tin về các trở ngại, bao gồm cách hoạt động của vòng lặp kết xuất hệ thống, hãy xem video thảo luận công nghệ "Khám phá các quá giang hoạt hình giao diện người dùng và vòng lặp kết xuất".

00:11:38.000 --> 00:11:42.000
Cả hai lần treo và quá giang trong SwiftUI thường bắt nguồn từ một bản cập nhật chậm.

00:11:42.000 --> 00:11:45.000
Những cập nhật chậm này có một số nguyên nhân phổ biến.

00:11:45.000 --> 00:11:52.000
Đầu tiên là khởi tạo Thuộc tính Động tốn kém, chẳng hạn như phân bổ và khởi tạo một đối tượng trạng thái hoặc khởi tạo trạng thái.

00:11:52.000 --> 00:11:54.000
Một nguồn khác là công việc được thực hiện trong cơ thể.

00:11:54.000 --> 00:12:00.000
Đảm bảo kiểm tra nội suy chuỗi đắt tiền hoặc các hoạt động như lọc dữ liệu và các công việc khác bên trong cơ thể.

00:12:00.000 --> 00:12:04.000
Điều quan trọng là bản thân cơ thể phải rẻ nhất có thể.

00:12:04.000 --> 00:12:06.000
Tất cả đều liên quan đến nhau.

00:12:06.000 --> 00:12:12.000
Ví dụ, một thuộc tính động có thể được tính toán từ phần thân của chế độ xem, khiến chế độ xem trở nên tốn kém để đánh giá.

00:12:12.000 --> 00:12:16.000
Nhận dạng chậm cũng thường xuyên xảy ra trong cơ thể của chế độ xem.

00:12:16.000 --> 00:12:20.000
Hãy bắt đầu bằng cách xem một ví dụ từ ứng dụng tìm nạp.

00:12:20.000 --> 00:12:26.000
Trong ví dụ này, tôi đã làm việc trên chế độ xem gốc của ứng dụng, có một đối tượng mà tôi sử dụng để tạo danh sách chó.

00:12:26.000 --> 00:12:36.000
Theo dõi mã nổi bật trên trang chiếu này, truy cập model.dogs trong cơ thể lười biếng khởi tạo đối tượng, điều này đưa chúng ta đến trình khởi tạo, tìm nạp danh sách những con chó.

00:12:36.000 --> 00:12:40.000
Như nhận xét mã đã nói, việc này có thể mất nhiều thời gian.

00:12:40.000 --> 00:12:43.000
Đây là công việc đồng bộ.

00:12:43.000 --> 00:12:46.000
Một cách để khắc phục điều này là sử dụng công cụ sửa đổi nhiệm vụ.

00:12:46.000 --> 00:12:49.000
Đầu tiên chúng ta sẽ làm cho việc tìm nạp không đồng bộ.

00:12:49.000 --> 00:12:52.000
Tôi chỉ hiển thị việc bổ sung từ khóa không đồng bộ ở đây.

00:12:52.000 --> 00:12:58.000
Tiếp theo, trong công cụ sửa đổi nhiệm vụ, chúng tôi sẽ tìm nạp không đồng bộ danh sách chó bằng cách chờ nó.

00:12:58.000 --> 00:13:02.000
Bằng cách đó, ứng dụng sẽ phản hồi nhanh khi hoạt động tải dữ liệu đắt tiền xảy ra.

00:13:02.000 --> 00:13:06.000
Có những nguồn công việc khác mà bạn có thể không nhận ra đang ảnh hưởng đến ứng dụng của mình.

00:13:06.000 --> 00:13:13.000
Ví dụ, nội suy chuỗi thường có thể tốn kém, vì vậy hãy đảm bảo lưu trữ bất kỳ chuỗi nào bạn có thể cần sử dụng thường xuyên.

00:13:13.000 --> 00:13:17.000
Tương tự, việc tra cứu các giá trị từ các gói có thể tốn kém.

00:13:17.000 --> 00:13:22.000
Và tất nhiên, bất kỳ phân bổ đống nào, chẳng hạn như cho loại ràng buộc lớp, đều có thể cộng lại.

00:13:22.000 --> 00:13:24.000
Hãy chuyển sang danh sách và bảng.

00:13:24.000 --> 00:13:32.000
Danh sách và Bảng hỗ trợ các tính năng phong phú ngoài bố cục đơn giản, thêm lựa chọn, thao tác vuốt, sắp xếp lại hỗ trợ và hơn thế nữa.

00:13:32.000 --> 00:13:39.000
Đây là những điều khiển phức tạp, nâng cao và hiểu danh tính là rất quan trọng để đảm bảo chúng hoạt động tốt trong ứng dụng của bạn.

00:13:39.000 --> 00:13:47.000
Trong phần này, tôi sẽ thảo luận về danh tính trong danh sách và bảng và làm sáng tỏ cách tối đa hóa hiệu suất cập nhật cho các thành phần tích hợp này.

00:13:47.000 --> 00:13:51.000
Trước khi chúng ta đi sâu vào chủ đề này, tôi muốn đề cập đến một số cải tiến.

00:13:51.000 --> 00:13:59.000
Trong macOS Sonoma và iOS 17, SwiftUI có một số tối ưu hóa cho các trường hợp như lọc và cuộn.

00:13:59.000 --> 00:14:08.000
Những cải tiến này có thể được thực hiện với nỗ lực tối thiểu từ phía bạn, và trong nhiều trường hợp, có thể dẫn đến thời gian tải và cập nhật phản hồi nhanh hơn đáng kể cho các danh sách và bảng lớn hơn.

00:14:08.000 --> 00:14:14.000
Tuy nhiên, có một số cách nhất định để xây dựng danh sách và bảng dẫn đến hiệu suất tốt hơn.

00:14:14.000 --> 00:14:18.000
Danh sách và Bảng sử dụng số nhận dạng để biết những thay đổi nào đã xảy ra với dữ liệu.

00:14:18.000 --> 00:14:22.000
Để nhất quán, tất cả các ID của Danh sách và Bảng được thu thập một cách háo hức.

00:14:22.000 --> 00:14:30.000
Do đó, có thể nhanh chóng tạo số nhận dạng cho danh sách và nội dung bảng của bạn trực tiếp chuyển thành thời gian tải và cập nhật nhanh hơn.

00:14:30.000 --> 00:14:37.000
Identity giúp SwiftUI quản lý thời gian tồn tại của chế độ xem, điều này rất quan trọng để cập nhật gia tăng hệ thống phân cấp của bạn.

00:14:37.000 --> 00:14:40.000
Thay đổi danh tính có nghĩa là chế độ xem đã thay đổi.

00:14:40.000 --> 00:14:43.000
Điều này rất quan trọng đối với hoạt hình và hiệu suất.

00:14:43.000 --> 00:14:48.000
Để biết thêm thông tin về hoạt ảnh, hãy xem phiên "Nguyên tắc cơ bản của hoạt ảnh SwiftUI".

00:14:48.000 --> 00:14:54.000
Hiệu suất nhận dạng rất quan trọng vì số nhận dạng được thu thập thường xuyên, đặc biệt là cho các danh sách và bảng.

00:14:54.000 --> 00:14:58.000
Hãy xem qua mô hình nhận dạng danh sách.

00:14:58.000 --> 00:15:00.000
Tôi đã làm việc chăm chỉ trong danh sách những con chó trong ứng dụng.

00:15:00.000 --> 00:15:03.000
Tôi đã bắt đầu chỉ với một hàng duy nhất.

00:15:03.000 --> 00:15:07.000
Đây là mã cho danh sách, với một DogCell duy nhất bên trong.

00:15:07.000 --> 00:15:11.000
Bước tiếp theo là sử dụng ForEach để lặp lại tất cả những con chó.

00:15:11.000 --> 00:15:18.000
Ví dụ này rất đơn giản, nhưng nó liên quan trực tiếp đến danh tính và việc thêm ForEach vào Danh sách là thời điểm quan trọng để đánh giá hiệu suất.

00:15:18.000 --> 00:15:23.000
Để hiểu tại sao, hãy xem chữ ký chung của ForEach tiếp theo.

00:15:23.000 --> 00:15:26.000
Đây là chữ ký cho ForEach từ SwiftUI.

00:15:26.000 --> 00:15:34.000
ForEach ánh xạ một tập hợp dữ liệu vào một chuỗi các chế độ xem kết quả, tạo ra danh tính rõ ràng cho mỗi chế độ xem của nó.

00:15:34.000 --> 00:15:40.000
Khi bạn sử dụng Danh sách, nó cần tìm ra có bao nhiêu hàng để hiển thị, cũng như số nhận dạng cho mỗi hàng là gì.

00:15:40.000 --> 00:15:46.000
Do đó, nó truy cập bộ sưu tập dữ liệu ở phía trước, xác định ID của từng phần tử.

00:15:46.000 --> 00:15:49.000
Việc đóng nội dung được gọi để tạo ra mỗi chế độ xem.

00:15:49.000 --> 00:15:51.000
Các hàng được tạo theo yêu cầu.

00:15:51.000 --> 00:15:56.000
Danh sách sử dụng kết hợp danh tính và nội dung để tạo ra một hàng danh sách.

00:15:56.000 --> 00:16:04.000
Các hàng được tạo theo yêu cầu tương quan với khu vực hiển thị, cộng với một số bộ đệm do hệ thống xác định để tìm nạp trước hoặc khả năng truy cập.

00:16:04.000 --> 00:16:07.000
Khi chế độ xem được cuộn, nhiều chế độ xem sẽ tồn tại.

00:16:07.000 --> 00:16:11.000
Đây là đoạn mã sản xuất ForEach này.

00:16:11.000 --> 00:16:18.000
Lưu ý ở đây rằng nội dung chỉ là DogCell, bản thân nó là chế độ xem duy nhất, bởi vì nó sử dụng HStack bên trong.

00:16:18.000 --> 00:16:22.000
ForEach rất quan trọng trong việc xác định ID hàng cuối cùng được sử dụng bởi Danh sách.

00:16:22.000 --> 00:16:25.000
Và List cần biết trước tất cả các ID của nó.

00:16:25.000 --> 00:16:33.000
Nhưng nó chỉ có thể làm điều này một cách hiệu quả mà không cần truy cập tất cả nội dung nếu nội dung phân giải thành một số hàng không đổi.

00:16:33.000 --> 00:16:39.000
Ví dụ, giả sử chúng tôi muốn cấu trúc lại danh sách của mình để chỉ cho những con chó thích nhặt bóng.

00:16:39.000 --> 00:16:43.000
Có thể rất hấp dẫn khi thêm bộ lọc bằng cách sử dụng chế độ xem có điều kiện, như thế này.

00:16:43.000 --> 00:16:48.000
Ở đây, số lượt xem có thể thay đổi. Nó là một hoặc không.

00:16:48.000 --> 00:16:57.000
Điều này thật tệ vì nó dẫn đến danh sách cần xây dựng tất cả các chế độ xem để truy xuất số nhận dạng hàng vì nó không biết mỗi phần tử phân giải thành bao nhiêu lượt xem.

00:16:57.000 --> 00:17:00.000
Điều tương tự cũng đúng nếu bạn sử dụng AnyView.

00:17:00.000 --> 00:17:03.000
Ở đây, số lượt xem bây giờ hoàn toàn không rõ.

00:17:03.000 --> 00:17:08.000
Vì vậy, chúng tôi có cùng một vấn đề như trước đây: Tất cả các hàng phải được tạo.

00:17:08.000 --> 00:17:11.000
Điều gì sẽ xảy ra nếu chúng ta di chuyển bộ lọc vào chính bộ sưu tập dữ liệu?

00:17:11.000 --> 00:17:22.000
Bây giờ chúng ta quay trở lại số lượt xem không đổi trên mỗi phần tử và chỉ những chế độ cần thiết mới được xây dựng nội dung hàng của chúng, nhưng hãy cẩn thận: Bộ lọc nội tuyến ở đây là tuyến tính trên bộ sưu tập.

00:17:22.000 --> 00:17:30.000
Điều này có thể hoạt động trong một nguyên mẫu, nhưng khi bộ sưu tập mở rộng quy mô, hoạt động này có thể nhanh chóng trở nên tốn kém, dẫn đến cập nhật chậm.

00:17:30.000 --> 00:17:32.000
Tốt hơn là chuyển nó ra mô hình.

00:17:32.000 --> 00:17:42.000
Bây giờ chúng ta có những điều tốt nhất của cả hai thế giới: Bộ lọc được lưu trong bộ nhớ cache, vì vậy nó sẽ không chạy mỗi khi danh sách này được xây dựng và số lượt xem trên mỗi phần tử là không đổi.

00:17:42.000 --> 00:17:46.000
Dưới đây là một vài mẹo để đảm bảo số lượt xem của bạn không đổi.

00:17:46.000 --> 00:17:55.000
Lưu ý rằng cách tiếp cận này để xem số lượng chỉ có liên quan trong ngữ cảnh của ForEach trong Danh sách và Bảng vì các thành phần đó thu thập số nhận dạng của chúng trước.

00:17:55.000 --> 00:17:59.000
Như tôi vừa đề cập, tránh sử dụng AnyView và các điều kiện lệch lạc.

00:17:59.000 --> 00:18:08.000
Bạn cũng có thể sử dụng một ngăn xếp rõ ràng khi thích hợp, nhưng lưu ý rằng một số công cụ sửa đổi nhất định như listRowBackground cần phải theo dõi ngăn xếp chứ không phải bên trong nó.

00:18:08.000 --> 00:18:12.000
Cuối cùng, hãy cố gắng làm phẳng các công trình ForEach lồng nhau nếu bạn có thể.

00:18:12.000 --> 00:18:17.000
Tuy nhiên, có một nơi mà ForEach lồng nhau có thể có giá trị, danh sách được phân đoạn.

00:18:17.000 --> 00:18:20.000
Hãy xem xét một ví dụ.

00:18:20.000 --> 00:18:25.000
Trong ví dụ này, tôi có một danh sách những con chó được phân chia theo đồ chơi yêu thích của mỗi con chó.

00:18:25.000 --> 00:18:28.000
Tôi đang sử dụng ForEach để tạo ra một số phần động.

00:18:28.000 --> 00:18:33.000
Và mỗi phần có một số hàng động bên trong nó bằng cách lồng một ForEach.

00:18:33.000 --> 00:18:43.000
Danh sách sẽ cần truy xuất tất cả các số nhận dạng, nhưng vì chúng tôi đang sử dụng các phần ở đây, SwiftUI hiểu cấu trúc này và đảm bảo danh sách vẫn hiển thị nhanh.

00:18:43.000 --> 00:18:48.000
Các phần động là một ví dụ điển hình khi sử dụng ForEach lồng nhau được khuyến nghị.

00:18:48.000 --> 00:18:58.000
Phương trình cơ bản cần suy nghĩ là số lượng hàng kết quả từ ForEach trong Danh sách bằng số phần tử nhân với số lượt xem được tạo ra cho mỗi phần tử.

00:18:58.000 --> 00:19:08.000
Bạn cần đảm bảo số lượt xem trên mỗi phần tử là không đổi, hoặc SwiftUI phải xây dựng các lượt xem ngoài các số nhận dạng để xác định các hàng.

00:19:08.000 --> 00:19:12.000
Cho đến nay chúng ta đã nói về Danh sách, nhưng những quy tắc này cũng thường áp dụng cho Bảng.

00:19:12.000 --> 00:19:18.000
Table sử dụng TableRow thay vì chế độ xem và TableRow luôn phân giải thành một hàng duy nhất.

00:19:18.000 --> 00:19:20.000
Hãy nhìn vào một ví dụ Bảng.

00:19:20.000 --> 00:19:24.000
Ở đây tôi có bàn cho chó, có một ForEach bên trong.

00:19:24.000 --> 00:19:32.000
Bởi vì TableRow luôn là một hàng duy nhất, tổng số hàng ở đây chỉ là số phần tử trong bộ sưu tập chó.

00:19:32.000 --> 00:19:45.000
Cấu trúc này phổ biến đến mức, mới trong iOS 17 và macOS Sonoma, SwiftUI cung cấp trình khởi tạo hợp lý cho phép bạn chỉ cần viết ForEach bộ sưu tập dữ liệu của mình và thay mặt bạn tạo các hàng bảng.

00:19:45.000 --> 00:19:52.000
Mặc dù trình khởi tạo này là mới, nhưng nó triển khai lại cho tất cả các phiên bản hệ điều hành trước đó nơi Table có sẵn.

00:19:52.000 --> 00:20:00.000
Cấu trúc này không chỉ đơn giản hơn mà còn thực thi số lượng hàng không đổi cho nội dung ForEach, giúp hiệu suất nhận dạng.

00:20:00.000 --> 00:20:04.000
Tuy nhiên, có một sự thay đổi ngữ nghĩa mà tôi muốn gọi là mới.

00:20:04.000 --> 00:20:09.000
Nếu bạn có mã như thế này, nó có thể hoạt động khác trong các phiên bản hệ điều hành mới nhất.

00:20:09.000 --> 00:20:15.000
Trong ví dụ này, chúng tôi có một con chó ForEach over, nó cũng tạo ra một hàng chó.

00:20:15.000 --> 00:20:18.000
Tuy nhiên, những con chó ở đây không phù hợp.

00:20:18.000 --> 00:20:20.000
Những giá trị là người bạn tốt nhất của chú chó.

00:20:20.000 --> 00:20:25.000
Trong iOS 16, mỗi hàng được xác định bởi giá trị của nó.

00:20:25.000 --> 00:20:29.000
Trong iOS 17, hành vi này đã thay đổi để cải thiện hiệu suất.

00:20:29.000 --> 00:20:34.000
Lý do là, bây giờ chúng ta không cần xác định từng hàng bảng bằng cách nhìn vào ForEach.

00:20:34.000 --> 00:20:40.000
Vì vậy, ví dụ này bây giờ có ID của mỗi con chó, thay vì giá trị của TableRow.

00:20:40.000 --> 00:20:49.000
Nếu bạn cần triển khai lại, bạn có thể lấy hành vi cũ bằng cách ánh xạ qua bộ sưu tập của mình hoặc bằng cách chỉ định rõ ràng đường dẫn khóa ID.

00:20:49.000 --> 00:20:59.000
Phương trình cơ bản cần suy nghĩ là số lượng hàng kết quả từ ForEach trong Danh sách bằng số phần tử nhân với số lượt xem được tạo ra cho mỗi phần tử.

00:20:59.000 --> 00:21:04.000
Trong Bảng, điều này tương tự, nhưng đó là số lượng TableRows trên mỗi phần tử.

00:21:04.000 --> 00:21:15.000
Chúng tôi đã đề cập đến một số mẹo và thủ thuật để có danh sách và bảng nhanh hơn ở đây, cụ thể là bạn nên đảm bảo số nhận dạng rẻ để tạo và số lượt xem trong ForEach nội dung là không đổi.

00:21:15.000 --> 00:21:16.000
Hôm nay chúng tôi đã đề cập rất nhiều.

00:21:16.000 --> 00:21:21.000
Chúng tôi bắt đầu với việc khám phá biểu đồ để hiểu các phụ thuộc và tối ưu hóa chúng.

00:21:21.000 --> 00:21:25.000
Sau đó, chúng tôi đã xem xét các bản cập nhật chậm và cách cải thiện khả năng phản hồi.

00:21:25.000 --> 00:21:29.000
Và cuối cùng, chúng tôi đã thảo luận về tầm quan trọng của danh tính với Danh sách và Bảng.

00:21:29.000 --> 00:21:38.000
Với các mô hình tinh thần phù hợp, bạn có thể dễ dàng có hiệu suất tuyệt vời ngay từ khi bắt đầu quá trình phát triển, điều này cho phép bạn tập trung nhiều hơn vào các chi tiết của ứng dụng của mình.

00:21:38.000 --> 00:21:40.000
Cảm ơn vì đã xem.

00:21:40.000 --> 23:59:59.000
♪ ♪

