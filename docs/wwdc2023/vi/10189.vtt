WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:11.000
Luvena: Chào mọi người!

00:00:11.000 --> 00:00:23.000
Tên tôi là Luvena, và tôi rất vui được chia sẻ với bạn cách bạn có thể di chuyển ứng dụng Dữ liệu cốt lõi của mình sang SwiftData, khuôn khổ kiên trì gốc Swift có thể cùng tồn tại với Dữ liệu cốt lõi.

00:00:23.000 --> 00:00:38.000
Tôi sẽ đề cập đến các trường hợp sử dụng phổ biến về cách bạn có thể áp dụng SwiftData cho ứng dụng Core Data của mình, cho dù bạn đã sẵn sàng cho quá trình chuyển đổi hoàn toàn từ Core Data sang SwiftData hay nếu bạn muốn áp dụng SwiftData từng bước và cùng tồn tại với Core Data.

00:00:38.000 --> 00:00:46.000
Đầu tiên tôi sẽ hướng dẫn cách bạn có thể tạo các Lớp Mô hình SwiftData bằng cách sử dụng trợ lý Trình chỉnh sửa Mô hình Đối tượng được Quản lý.

00:00:46.000 --> 00:00:52.000
Sau đó, tôi sẽ chứng minh quy trình áp dụng SwiftData hoàn chỉnh cho một ứng dụng Dữ liệu Cốt lõi hiện có.

00:00:52.000 --> 00:01:05.000
Và cuối cùng, tôi sẽ giới thiệu cho bạn sự cùng tồn tại giữa Core Data và SwiftData, trong trường hợp chuyển đổi hoàn toàn sang SwiftData có thể không phải là giải pháp khả thi cho trường hợp sử dụng của bạn.

00:01:05.000 --> 00:01:09.000
Trước tiên hãy để tôi đi qua quy trình làm thế nào bạn có thể tạo ra các lớp mô hình.

00:01:09.000 --> 00:01:14.000
Trong SwiftData, bạn đang chuyển sang sử dụng các mô hình trong mã để thiết lập lược đồ của mình.

00:01:14.000 --> 00:01:21.000
Một cách dễ dàng để làm điều này là sử dụng mô hình đối tượng được quản lý Dữ liệu cốt lõi của bạn để giúp tạo ra các mô hình SwiftData của bạn.

00:01:21.000 --> 00:01:25.000
Hãy để tôi chỉ cho bạn cách thực hiện quá trình chuyển đổi này.

00:01:25.000 --> 00:01:32.000
Tôi đã tạo một ứng dụng Dữ liệu cốt lõi ở đây được gọi là SampleTrips, giúp người dùng lên kế hoạch hành trình của họ cho các chuyến đi sắp tới.

00:01:32.000 --> 00:01:38.000
Đây là tệp mô hình, chứa thông tin về dữ liệu của tôi và tổ chức của nó.

00:01:38.000 --> 00:01:52.000
Tôi có các thực thể Trip, LivingAccommodation và BucketListItem, được tổ chức sao cho mỗi chuyến đi có một chỗ ở tương ứng và các mục danh sách nhóm đại diện cho các hoạt động chuyến đi mong muốn.

00:01:52.000 --> 00:01:57.000
Từ đây, tôi sẽ tạo các lớp SwiftData nắm bắt thông tin tương tự.

00:01:57.000 --> 00:02:15.000
Mặc dù mô hình đối tượng được quản lý Dữ liệu cốt lõi không cần thiết để tạo các lớp SwiftData này, nhưng nếu tôi có mô hình Dữ liệu cốt lõi đã có từ trước, tôi có thể sử dụng mô hình đó để giúp tạo các lớp SwiftData dựa trên tổ chức mà tôi đã có trong mô hình đã có từ trước của mình, mà tôi sẽ chứng minh cho trường hợp

00:02:15.000 --> 00:02:19.000
Để làm điều này, tôi thông qua trợ lý Trình chỉnh sửa mô hình đối tượng được quản lý của chúng tôi.

00:02:19.000 --> 00:02:30.000
Sau khi chọn tệp mô hình của mình, tôi điều hướng đến thanh menu, chọn Trình chỉnh sửa và nhấp vào Tạo mã SwiftData.

00:02:30.000 --> 00:02:35.000
Bây giờ tôi có thể tạo tệp cho ba thực thể đã tồn tại từ trước của mình.

00:02:35.000 --> 00:02:43.000
Tạo các mô hình SwiftData từ đầu cũng là một lựa chọn trong trường hợp tạo một ứng dụng Swift mới và sẽ không yêu cầu trợ lý này.

00:02:43.000 --> 00:02:46.000
Đây là những tệp tôi vừa tạo.

00:02:46.000 --> 00:03:04.000
Các loại Swift của bạn phải phù hợp với Mô hình và mỗi loại nắm bắt thông tin cho thực thể dưới dạng các biến, bao gồm các thuộc tính của nó, đối với Trip là tên, điểm đến và ngày bắt đầu và ngày kết thúc, và mối quan hệ của nó với các thực thể khác, LivingAccommodation và BucketListItem.

00:03:04.000 --> 00:03:09.000
Bây giờ, hãy để tôi đưa bạn qua quy trình áp dụng hoàn chỉnh cho SwiftData.

00:03:09.000 --> 00:03:20.000
Khi di chuyển hoàn toàn ứng dụng của bạn sang SwiftData, bạn đang thay thế ngăn xếp Dữ liệu Cốt lõi của mình bằng ngăn xếp SwiftData để khai thác các tính năng ngôn ngữ mẹ đẻ Swift với SwiftData.

00:03:20.000 --> 00:03:27.000
Điều này cho phép mã dễ đọc hơn để duy trì dữ liệu của bạn, cũng như ngầm quản lý một số tính năng.

00:03:27.000 --> 00:03:34.000
Tuy nhiên, trước khi thực hiện quá trình chuyển đổi này, bạn nên xem xét các thiết kế mô hình dữ liệu cốt lõi đã có từ trước của mình được cấu trúc như thế nào.

00:03:34.000 --> 00:03:41.000
Các thiết kế mô hình Dữ liệu Cốt lõi của bạn đề cập đến lược đồ của bạn, bao gồm các thực thể và các thuộc tính và mối quan hệ của chúng.

00:03:41.000 --> 00:03:47.000
Bạn cần đảm bảo rằng các thiết kế mô hình Dữ liệu Cốt lõi của bạn cũng được hỗ trợ trong SwiftData.

00:03:47.000 --> 00:03:58.000
Điều này có nghĩa là đối với mỗi thực thể được xác định trong Dữ liệu cốt lõi, cần phải có một loại mô hình tương ứng với các kết quả khớp chính xác cho tên và thuộc tính thực thể trong SwiftData.

00:03:58.000 --> 00:04:04.000
Đảm bảo rằng bạn kiểm tra kỹ lưỡng các mô hình của mình để xác minh rằng tất cả các tính năng đều được hỗ trợ trong SwiftData.

00:04:04.000 --> 00:04:11.000
Hãy để tôi đề cập đến một số điểm nổi bật của quy trình áp dụng SwiftData hoàn chỉnh từ ứng dụng Core Data chi tiết hơn.

00:04:11.000 --> 00:04:15.000
Tôi đã tạo các loại Swift để nắm bắt mô hình của mình trước đó.

00:04:15.000 --> 00:04:25.000
Khi tôi đã chuẩn bị sẵn các tệp đó, tôi có thể xóa tệp mô hình đối tượng được quản lý Dữ liệu cốt lõi đã được sử dụng trước đó và thay vào đó quản lý mô hình thông qua các tệp Swift này.

00:04:25.000 --> 00:04:32.000
Ngoài ra, tôi có thể xóa tệp Persistence mà trước đây đã giúp thiết lập ngăn xếp Dữ liệu Cốt lõi.

00:04:32.000 --> 00:04:37.000
Bây giờ tôi có thể thiết lập modelContainer cho ngăn xếp SwiftData của mình.

00:04:37.000 --> 00:04:44.000
modelContainer là một công cụ sửa đổi đảm bảo rằng tất cả các cửa sổ trong nhóm được cấu hình để truy cập cùng một vùng chứa liên tục.

00:04:44.000 --> 00:04:56.000
Bằng cách thêm vùng chứa này vào đây trong TripsApp, tôi đang thiết lập cả vùng chứa và ngữ cảnh của mình, vì modelContainer cũng tạo và đặt ModelContext mặc định trong môi trường.

00:04:56.000 --> 00:05:01.000
ModelContext được sử dụng để theo dõi các thay đổi đối với các trường hợp của các loại ứng dụng của tôi.

00:05:01.000 --> 00:05:06.000
Nó có thể được đọc từ bên trong bất kỳ cảnh hoặc chế độ xem nào bằng cách sử dụng thuộc tính môi trường này.

00:05:06.000 --> 00:05:13.000
Ngăn xếp liên tục SwiftData của tôi cho SampleTrips hiện đã được thiết lập, nhưng có một vài thay đổi nữa cần phải xảy ra.

00:05:13.000 --> 00:05:17.000
Đầu tiên tôi sẽ chứng minh cách tạo đối tượng hoạt động.

00:05:17.000 --> 00:05:22.000
Trước đây, trong Core Data, việc tạo ra một Chuyến đi mới sẽ giống như thế này.

00:05:22.000 --> 00:05:30.000
Tôi sẽ tạo một ví dụ của Trip, chuyển trong ngữ cảnh đối tượng được quản lý, trước khi thiết lập các thuộc tính của nó.

00:05:30.000 --> 00:05:38.000
Trong SwiftData, tôi có thể tạo một phiên bản mới của Trip với dòng mã này, dòng mã này đã tương đối dễ đọc hơn.

00:05:38.000 --> 00:05:45.000
Khi tôi có chuyến đi mới này, tôi chèn nó vào bối cảnh mô hình để đảm bảo rằng nó được duy trì.

00:05:45.000 --> 00:05:51.000
Bây giờ chuyến đi của tôi đang được duy trì, tôi muốn xem cách tôi có thể lưu nó và bất kỳ thay đổi nào trong tương lai mà tôi thực hiện đối với nó.

00:05:51.000 --> 00:06:00.000
SwiftData có tính năng lưu ngầm kích hoạt lưu trên các sự kiện vòng đời giao diện người dùng và trên bộ hẹn giờ sau khi ngữ cảnh được thay đổi nếu có thể.

00:06:00.000 --> 00:06:09.000
Do đó, tôi có thể xóa bản lưu rõ ràng của Core Data được gọi trên ngữ cảnh và dựa vào các bản lưu ngầm để duy trì dữ liệu của mình khi ngữ cảnh thay đổi.

00:06:09.000 --> 00:06:12.000
Bây giờ, hãy để tôi đưa bạn qua cách tôi tìm nạp dữ liệu của mình.

00:06:12.000 --> 00:06:22.000
Thay vì sử dụng yêu cầu tìm nạp như tôi đã có trong Dữ liệu cốt lõi, tôi có thể sử dụng Truy vấn để tìm nạp danh sách đầy đủ các chuyến đi sắp tới bằng cách gói một loạt các chuyến đi trong Truy vấn.

00:06:22.000 --> 00:06:26.000
Điều này cho phép tôi tìm nạp các đối tượng Trip đó từ vùng chứa SwiftData.

00:06:26.000 --> 00:06:30.000
Tôi cũng đang xác định thứ tự sắp xếp cho truy vấn.

00:06:30.000 --> 00:06:37.000
Tôi muốn sắp xếp nó theo ngày bắt đầu chuyến đi của mình theo thứ tự chuyển tiếp, sao cho chuyến đi sắp tới gần nhất nằm ở trên cùng.

00:06:37.000 --> 00:06:42.000
Truy vấn cũng có thể được sử dụng cho các trường hợp sử dụng cần bao gồm một vị ngữ.

00:06:42.000 --> 00:06:51.000
Bây giờ bạn đã biết cách di chuyển hoàn toàn ứng dụng Core Data của mình sang SwiftData, hãy để tôi đưa bạn qua trường hợp bạn muốn cùng tồn tại giữa Core Data và SwiftData.

00:06:51.000 --> 00:06:59.000
Việc di chuyển toàn bộ có thể không phải lúc nào cũng khả thi hoặc thực tế, trong trường hợp đó bạn có thể xem xét chuyển đổi một phần sang SwiftData.

00:06:59.000 --> 00:07:08.000
Cùng tồn tại là khi có hai ngăn xếp liên tục hoàn toàn riêng biệt, một ngăn xếp Dữ liệu Cốt lõi và một ngăn xếp SwiftData, nói chuyện với cùng một kho lưu trữ liên tục.

00:07:08.000 --> 00:07:16.000
Điều này có nghĩa là không cần phải viết lại hoàn toàn mã Dữ liệu Cốt lõi hiện có để có thể bắt đầu thêm mã SwiftData.

00:07:16.000 --> 00:07:31.000
Tùy chọn này cung cấp cho bạn sự linh hoạt hơn khi áp dụng SwiftData vào ứng dụng của mình, cho dù bạn có thể đã có một số dữ liệu trong Core Data hay nếu bạn chỉ đơn giản là phải đối mặt với những hạn chế khác không cho phép bạn chuyển hoàn toàn sang SwiftData.

00:07:31.000 --> 00:07:36.000
Đây là cách bạn có thể thiết lập cả hai ngăn xếp để nói chuyện với cùng một cửa hàng.

00:07:36.000 --> 00:07:46.000
Trước khi tải cửa hàng liên tục, bạn cần đặt URL cửa hàng liên tục cho mô tả vùng chứa để đảm bảo rằng cả hai ngăn xếp đang ghi vào cùng một URL.

00:07:46.000 --> 00:07:50.000
Ngoài ra, bạn cần bật tính năng theo dõi lịch sử liên tục.

00:07:50.000 --> 00:07:55.000
Trong khi SwiftData tự động bật theo dõi lịch sử liên tục, Core Data thì không.

00:07:55.000 --> 00:08:07.000
Nếu bạn cố gắng mở một cửa hàng liên tục khi bạn có cả Core Data và SwiftData cùng tồn tại trong cùng một ứng dụng mà không đặt lịch sử liên tục, cửa hàng của bạn sẽ được đưa vào chế độ chỉ đọc.

00:08:07.000 --> 00:08:13.000
Có một vài tình huống khác nhau mà bạn sẽ thấy cùng tồn tại là lựa chọn tốt nhất cho trường hợp sử dụng của mình.

00:08:13.000 --> 00:08:17.000
Một kịch bản là cho phép tương thích ngược với các khách hàng hiện tại.

00:08:17.000 --> 00:08:27.000
Bởi vì SwiftData chỉ khả dụng trong iOS 17 và macOS Sonoma, các ứng dụng Core Data hiện tại của bạn có thể bị ảnh hưởng bởi việc chuyển đổi hoàn toàn sang SwiftData.

00:08:27.000 --> 00:08:33.000
Ngoài ra, bạn có thể phải đối mặt với những hạn chế về tài nguyên khiến việc chuyển đổi hoàn toàn sang SwiftData trở nên khó khăn.

00:08:33.000 --> 00:08:44.000
Trong những trường hợp này, sẽ rất hợp lý nếu kết hợp SwiftData một phần bằng cách thực hiện phát triển mới bằng SwiftData hoặc chỉ chuyển đổi các phần ứng dụng của bạn sang SwiftData.

00:08:44.000 --> 00:08:51.000
Có một vài yêu cầu để cùng tồn tại giữa Core Data và SwiftData mà bạn nên cân nhắc trước khi thực hiện quá trình chuyển đổi này.

00:08:51.000 --> 00:09:00.000
Đầu tiên, bạn phải có các lớp con thực thể dựa trên NSManagedObject có sẵn trong không gian tên hoặc các lớp SwiftData sao cho chúng không va chạm.

00:09:00.000 --> 00:09:06.000
Điều này có nghĩa là không có hai lớp nào có thể được gọi là cùng một thứ, và ít nhất một trong số chúng cần phải thay đổi.

00:09:06.000 --> 00:09:12.000
Hãy nhớ rằng mặc dù bạn đang thay đổi tên lớp, tên thực thể vẫn giữ nguyên.

00:09:12.000 --> 00:09:20.000
Ví dụ, ở đây tôi có cùng một dự án SampleTrips từ trước đó, ngoại trừ lần này tôi muốn cùng tồn tại với Core Data và SwiftData.

00:09:20.000 --> 00:09:22.000
Hai tên lớp xung đột.

00:09:22.000 --> 00:09:30.000
Để phân biệt giữa cả tên SwiftData và Core Data Trip, thay vào đó tôi đã thay đổi tên lớp Core Data trip thành CDTrip.

00:09:30.000 --> 00:09:35.000
Bạn cũng có thể làm điều này trong trình chỉnh sửa mô hình đối tượng được quản lý.

00:09:35.000 --> 00:09:47.000
Ngoài ra, bạn sẽ cần giữ cho các lược đồ Dữ liệu Cốt lõi và SwiftData đồng bộ. Các phần mới của lược đồ SwiftData phải được hiện thực hóa dưới dạng NSManagedObjectModel và hai lược đồ không thể phân kỳ.

00:09:47.000 --> 00:09:52.000
Điều này có nghĩa là các thuộc tính và mối quan hệ phải được thêm vào các mô hình theo cùng một cách chính xác.

00:09:52.000 --> 00:10:02.000
Điều này là để các hàm băm phiên bản thực thể khớp với từng bước của con đường đi, vì các hàm băm không khớp có khả năng kích hoạt di chuyển và xóa thông tin mà bạn không muốn xóa.

00:10:02.000 --> 00:10:07.000
Cuối cùng, bạn cần theo dõi các phiên bản lược đồ khi kết hợp cùng tồn tại.

00:10:07.000 --> 00:10:16.000
Khi làm việc với nhiều phiên bản của mô hình SwiftData, bạn phải đảm bảo rằng các thay đổi được thể hiện chính xác để SwiftData có thể đánh giá sự khác biệt.

00:10:16.000 --> 00:10:19.000
Có một vài cách bạn có thể làm điều này.

00:10:19.000 --> 00:10:25.000
Kiểm tra cuộc nói chuyện "Mô hình hóa lược đồ của bạn với SwiftData" để hiểu cách sử dụng lược đồ có phiên bản.

00:10:25.000 --> 00:10:32.000
Đối với các ứng dụng Swift của bạn dựa trên UIKit hoặc AppKit, vẫn có các tùy chọn khả thi để bạn sử dụng SwiftData.

00:10:32.000 --> 00:10:35.000
Cách tiếp cận đầu tiên là giải pháp cùng tồn tại.

00:10:35.000 --> 00:10:40.000
Bạn có thể liên kết mã UIKit của mình với Core Data và nó có thể hoạt động song song với SwiftData.

00:10:40.000 --> 00:10:48.000
Ngoài ra, bạn có thể coi các lớp SwiftData của mình là các lớp Swift và thay vào đó bọc mã Swift của bạn bằng mã UIKit.

00:10:48.000 --> 00:10:49.000
Đó là tất cả từ tôi!

00:10:49.000 --> 00:10:56.000
Bây giờ hãy đi và khám phá cách bạn có thể linh hoạt di chuyển ứng dụng Dữ liệu cốt lõi của mình sang SwiftData, toàn bộ hoặc từng bước.

00:10:56.000 --> 00:11:02.000
Trong thời gian chờ đợi, hãy xem những cuộc nói chuyện thú vị khác về SwiftData để tìm hiểu sâu hơn.

00:11:02.000 --> 00:11:06.000
Cảm ơn vì đã tham gia cùng tôi! Tôi rất hào hứng để xem những gì bạn sẽ xây dựng!

00:11:06.000 --> 23:59:59.000
♪ ♪

