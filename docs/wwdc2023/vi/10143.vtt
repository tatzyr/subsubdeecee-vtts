WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:15.000
Dave: Xin chào, tôi là Dave Wendland, một người ủng hộ nhà phát triển cho nhóm Thương mại Cửa hàng Ứng dụng của chúng tôi.

00:00:15.000 --> 00:00:34.000
Đồng nghiệp Alex của tôi và tôi sẽ thảo luận về Thư viện Máy chủ App Store mới và cách tập hợp các chức năng của nó sẽ cho phép máy chủ của bạn sử dụng một loạt các khả năng từ việc tạo JWT cho API Máy chủ App Store để di chuyển ra khỏi điểm cuối verifyReceipt để xác thực mua hàng.

00:00:34.000 --> 00:00:40.000
Khi chúng ta nhìn lại, App Store ra mắt vào năm 2008 khi các ứng dụng miễn phí hoặc trả phí.

00:00:40.000 --> 00:00:49.000
Ngay sau đó, chúng tôi đã thêm các giao dịch mua trong ứng dụng và kể từ đó, cộng đồng nhà phát triển đã phát triển về quy mô và độ phức tạp trên toàn cầu.

00:00:49.000 --> 00:00:59.000
App Store tiếp tục tung ra các bản cập nhật cho các nhà phát triển và khách hàng để hỗ trợ hệ sinh thái ứng dụng di động toàn cầu và năng động.

00:00:59.000 --> 00:01:10.000
Vào năm 2021, chúng tôi đã phát hành kỷ nguyên tiếp theo của các công cụ StoreKit với Khung StoreKit được cải tiến, API Máy chủ App Store và Thông báo Máy chủ App Store v2.

00:01:10.000 --> 00:01:16.000
Với nhiều cập nhật hơn vào năm 2022 và một lần nữa trong năm nay tại WWDC 2023.

00:01:16.000 --> 00:01:22.000
Những công cụ này cung cấp các giao dịch và trạng thái ở định dạng JWS đã ký.

00:01:22.000 --> 00:01:29.000
Và chúng được thiết kế để cung cấp cho các nhà phát triển thông tin mạnh mẽ, phía máy khách và phía máy chủ.

00:01:29.000 --> 00:01:33.000
Bộ API này đã truyền cảm hứng cho Thư viện Máy chủ App Store.

00:01:33.000 --> 00:01:46.000
Chúng tôi tự hào chia sẻ rằng thư viện này cung cấp một bộ chức năng, điều này sẽ giúp cộng đồng nhà phát triển của chúng tôi dễ dàng áp dụng và tích hợp các API mới nhất hiện có và trong tương lai.

00:01:46.000 --> 00:01:59.000
Khởi chạy beta thư viện hỗ trợ bốn ngôn ngữ: Swift, Java, Node và Python, mang đến cho bạn sự linh hoạt để chọn ngôn ngữ hỗ trợ tốt nhất cho phần phụ trợ và chuyên môn của bạn.

00:01:59.000 --> 00:02:07.000
Thư viện máy chủ App Store cho từng ngôn ngữ có sẵn trên GitHub và chúng tôi mong nhận được phản hồi và đóng góp của bạn.

00:02:07.000 --> 00:02:13.000
Tôi đã chia nhỏ những gì thư viện cung cấp thành bốn khả năng chính.

00:02:13.000 --> 00:02:18.000
Khả năng đầu tiên và mạnh mẽ nhất là với App Store Server API.

00:02:18.000 --> 00:02:26.000
Bằng cách hợp lý hóa việc tạo JWT, bạn có thể sử dụng bất kỳ điểm nào trong số hàng chục điểm cuối khác nhau mà App Store Server API cung cấp.

00:02:26.000 --> 00:02:39.000
Tiếp theo là khả năng cốt lõi để xác minh dữ liệu đã ký JWS, vì vậy bạn có thể đảm bảo các giao dịch và thông báo máy chủ của mình đã được Apple tạo và ký.

00:02:39.000 --> 00:02:43.000
Tiếp theo là tiện ích giao dịch biên lai trích xuất.

00:02:43.000 --> 00:02:48.000
Công cụ đơn giản này trích xuất số nhận dạng giao dịch từ biên lai ứng dụng.

00:02:48.000 --> 00:03:00.000
Làm điều này có thể làm giảm bớt nhu cầu của bạn để sử dụng điểm cuối verifyReceipt và cho phép bạn di chuyển sang API Máy chủ App Store để xác thực mua hàng và các khả năng bổ sung.

00:03:00.000 --> 00:03:05.000
Điều này cung cấp một con đường rõ ràng để hỗ trợ các phiên bản ứng dụng hiện tại và kế thừa của bạn.

00:03:05.000 --> 00:03:11.000
Cuối cùng, là tiện ích để tạo chữ ký ưu đãi khuyến mại đăng ký.

00:03:11.000 --> 00:03:18.000
Tiện ích này thực hiện việc ký kết và tạo ưu đãi của bạn bằng cách sử dụng khóa riêng tư mua hàng trong ứng dụng của bạn.

00:03:18.000 --> 00:03:27.000
Nếu bạn không quen thuộc với các ưu đãi khuyến mại đăng ký, hãy tìm hiểu thêm trong phiên của chúng tôi có tiêu đề "Các phương pháp hay nhất về ưu đãi đăng ký".

00:03:27.000 --> 00:03:31.000
Bây giờ hãy đi sâu vào ba trong số các chức năng thư viện cốt lõi đó.

00:03:31.000 --> 00:03:38.000
App Store Server API, xác minh dữ liệu đã ký và chuyển sang App Store Server API.

00:03:38.000 --> 00:03:42.000
Hãy bắt đầu với App Store Server API.

00:03:42.000 --> 00:03:48.000
Nền tảng của API Máy chủ là điểm cuối Nhận Lịch sử Giao dịch.

00:03:48.000 --> 00:03:56.000
Chỉ cần sử dụng ID giao dịch, API này cung cấp lịch sử giao dịch mua hàng trong ứng dụng hoàn chỉnh của khách hàng.

00:03:56.000 --> 00:03:59.000
Và nó thậm chí còn có nhiều khả năng hơn điểm cuối này.

00:03:59.000 --> 00:04:07.000
API này có hàng tá điểm cuối, tất cả đều yêu cầu một hình thức xác thực, Mã thông báo web JSON.

00:04:07.000 --> 00:04:15.000
Tạo JWT của bạn là một bước quan trọng và nếu bạn không quen thuộc với quy trình này, đó là nơi thư viện xuất hiện.

00:04:15.000 --> 00:04:22.000
Đến Alex để chứng minh việc thiết lập thư viện để sử dụng với App Store Server API.

00:04:22.000 --> 00:04:25.000
Alex: Xin chào, tôi là Alex Baker, một kỹ sư máy chủ App Store.

00:04:25.000 --> 00:04:32.000
Tôi sẽ trình bày cách bắt đầu với Thư viện Máy chủ App Store và cách bạn có thể sử dụng nó để gọi API Máy chủ App Store.

00:04:32.000 --> 00:04:42.000
Bản demo này sẽ hướng dẫn việc thu thập các phần thông tin cần thiết để định cấu hình Thư viện Máy chủ App Store, sau đó hiển thị một ví dụ về việc tạo ứng dụng khách API và gọi API.

00:04:42.000 --> 00:04:49.000
Tôi đang bắt đầu trong App Store Connect để lấy thông tin Tôi sẽ cần sử dụng App Store Server API với thư viện.

00:04:49.000 --> 00:04:54.000
Đi tới mô-đun Người dùng và Truy cập...

00:04:54.000 --> 00:04:59.000
Sau đó là tab Keys, sau đó là tùy chọn Mua trong ứng dụng.

00:04:59.000 --> 00:05:01.000
Có một vài thông tin hữu ích ở đây.

00:05:01.000 --> 00:05:04.000
Đầu tiên, ID nhà phát hành.

00:05:04.000 --> 00:05:07.000
Tiếp theo, tôi sẽ tạo một khóa riêng tư mới.

00:05:07.000 --> 00:05:12.000
Tôi sẽ đặt tên cho nó, sau đó nhấp vào Tạo.

00:05:12.000 --> 00:05:19.000
Tạo khóa cung cấp hai phần thông tin: ID khóa và tùy chọn tải xuống khóa riêng tư.

00:05:19.000 --> 00:05:22.000
Chỉ có thể tải xuống một lần.

00:05:22.000 --> 00:05:28.000
Chuyển sang trang web cơ sở hạ tầng Khóa công khai của Apple, tập trung vào phần Chứng chỉ gốc của Apple ở phía trên bên trái.

00:05:28.000 --> 00:05:34.000
Tải xuống chứng chỉ gốc.

00:05:34.000 --> 00:05:38.000
Đây là một dự án Java đơn giản sử dụng hệ thống xây dựng Gradle.

00:05:38.000 --> 00:05:44.000
Đầu tiên, thêm sự phụ thuộc vào Thư viện Máy chủ App Store.

00:05:44.000 --> 00:05:53.000
Chuyển sang lớp ExampleApp, đây là các phần thông tin tôi có được trước đó, issuerId, keyId và khóa riêng tư.

00:05:53.000 --> 00:06:05.000
Ngoài ra, lưu trữ bundleId của ứng dụng-- trong bản trình diễn này, tôi đang sử dụng sandbox-- và lưu trữ giá trị enum thích hợp.

00:06:05.000 --> 00:06:10.000
Sử dụng những mẩu thông tin này, khởi tạo một AppStoreServerAPIClient.

00:06:10.000 --> 00:06:21.000
Với khách hàng này, hãy gọi điểm cuối Yêu cầu Thông báo Kiểm tra, yêu cầu máy chủ App Store gửi thông báo với loại TEST đến URL bạn đã định cấu hình trong App Store Connect.

00:06:21.000 --> 00:06:24.000
Cuối cùng, in mã thông báo kiểm tra.

00:06:24.000 --> 00:06:35.000
Chạy cái này, chúng ta sẽ thấy testNotificationToken được in, và, như mong đợi, chúng ta thấy mã thông báo này.

00:06:35.000 --> 00:06:42.000
Điều này đã chứng minh cách sử dụng thư viện Máy chủ App Store để đơn giản hóa việc sử dụng API Máy chủ App Store và thông tin bạn cần từ App Store Connect.

00:06:42.000 --> 00:06:44.000
Bây giờ trở lại với Dave.

00:06:44.000 --> 00:06:45.000
Dave: Cảm ơn bạn, Alex.

00:06:45.000 --> 00:06:54.000
Bản demo đó thực sự minh họa thư viện này giúp bạn thiết lập và tạo JWT nhanh như thế nào để sử dụng với Server API.

00:06:54.000 --> 00:07:02.000
Thư viện này sẽ có tác động có ý nghĩa trong việc giảm thời gian triển khai của bạn khi áp dụng API của chúng tôi.

00:07:02.000 --> 00:07:09.000
Mặc dù việc sử dụng thư viện rất hữu ích và đơn giản, nhưng không có gì quan trọng hơn việc lưu trữ khóa riêng tư mua hàng trong ứng dụng của bạn một cách an toàn.

00:07:09.000 --> 00:07:16.000
Và nếu bạn từng nghĩ rằng khóa của mình đã bị xâm phạm, hãy tạo một khóa mới trong App Store Connect bất cứ lúc nào.

00:07:16.000 --> 00:07:22.000
Khi bạn bắt đầu phát triển, chúng tôi khuyên bạn nên bắt đầu với các giao dịch hộp cát và TestFlight.

00:07:22.000 --> 00:07:29.000
Và cuối cùng, hãy chắc chắn kiểm tra thường xuyên để cập nhật các cơ quan cấp chứng chỉ gốc của Apple.

00:07:29.000 --> 00:07:36.000
Bây giờ hãy thảo luận về lý do tại sao xác minh dữ liệu đã ký là một hành động nền tảng cho doanh nghiệp của bạn với các giao dịch mua trong ứng dụng.

00:07:36.000 --> 00:07:40.000
Đầu tiên hãy thảo luận về dữ liệu đã ký chứa những gì và tại sao nó lại quan trọng.

00:07:40.000 --> 00:07:56.000
Dữ liệu đã ký StoreKit có nghĩa là nó được tạo và ký bởi App Store ở định dạng Chữ ký web JSON và chứa dữ liệu về việc mua ứng dụng, mua hàng trong ứng dụng, sự kiện của khách hàng và trạng thái đăng ký của khách hàng.

00:07:56.000 --> 00:08:03.000
Hai tải trọng dữ liệu đã ký phổ biến nhất là Giao dịch JWS và Thông tin gia hạn JWS.

00:08:03.000 --> 00:08:11.000
Sau đó, appTransaction chứa thông tin chi tiết về phiên bản ứng dụng ban đầu được mua và phiên bản hiện đang được cài đặt trên thiết bị.

00:08:11.000 --> 00:08:25.000
Và sau đó chúng tôi có Thông báo Máy chủ App Store V2, bản thân thông báo là dữ liệu đã ký và bổ sung có thể chứa Giao dịch JWS và Thông tin Gia hạn JWS.

00:08:25.000 --> 00:08:38.000
Và như một lời nhắc nhở, bạn sẽ chỉ tìm thấy dữ liệu đã ký JWS này trong StoreKit 2 trên iOS 15 trở lên và trong App Store Server API và App Store Server Notifications v2.

00:08:38.000 --> 00:08:57.000
Bạn nên xác minh dữ liệu đã ký JWS sau bất kỳ sự kiện nào sau đây: Khi phân phối hoặc mở khóa nội dung trên thiết bị hoặc khi máy chủ của bạn đã nhận được dữ liệu đã ký, cho dù đó là từ ứng dụng của riêng bạn, máy chủ khác hoặc thông báo máy chủ App Store.

00:08:57.000 --> 00:09:01.000
Và cuối cùng, khi bạn nhận được phản hồi từ API máy chủ App Store.

00:09:01.000 --> 00:09:09.000
Đây là Alex để giới thiệu cách xác minh dữ liệu đã ký JWS và cách thư viện xử lý việc này cho bạn.

00:09:09.000 --> 00:09:13.000
Alex: Trong phần này, tôi sẽ chỉ ra cách xác minh dữ liệu đã ký từ App Store.

00:09:13.000 --> 00:09:17.000
Tôi sẽ mô tả quá trình xác minh mà bạn cần thực hiện.

00:09:17.000 --> 00:09:24.000
Sau đó, chúng ta sẽ hướng dẫn cách lớp SignedDataVerifier của Thư viện Máy chủ App Store có thể thực hiện quy trình này cho bạn.

00:09:24.000 --> 00:09:34.000
Tôi muốn nhấn mạnh rằng việc sử dụng các công cụ như Thư viện Máy chủ App Store rất được khuyến khích khi bạn không quen thuộc với RFC và các giao thức đằng sau các hoạt động mà tôi sắp mô tả.

00:09:34.000 --> 00:09:36.000
Đây là một số dữ liệu đã ký từ App Store.

00:09:36.000 --> 00:09:38.000
Có vẻ như có rất nhiều thứ đang diễn ra ở đây.

00:09:38.000 --> 00:09:42.000
Mã màu tiết lộ có ba phần.

00:09:42.000 --> 00:09:46.000
Mỗi phần được phân tách bằng một dấu chấm và được mã hóa URL Base64.

00:09:46.000 --> 00:09:49.000
Phần đầu tiên và lớn nhất là tiêu đề.

00:09:49.000 --> 00:09:55.000
Sau khi được giải mã, tiêu đề là một cấu trúc JSON với các trường được xác định bởi đặc tả JWS.

00:09:55.000 --> 00:10:03.000
Trong trường hợp này, tiêu đề của chúng tôi chỉ có hai trường: Đầu tiên, thuật toán, luôn là ES256.

00:10:03.000 --> 00:10:05.000
Tiếp theo là một trường được gọi là x5c.

00:10:05.000 --> 00:10:11.000
Đây là một mảng các chứng chỉ được sử dụng để tính toán khóa công khai dự kiến đã ký JWS.

00:10:11.000 --> 00:10:14.000
Hãy xem lại quy trình xây dựng chuỗi chứng chỉ.

00:10:14.000 --> 00:10:17.000
Chứng chỉ đầu tiên trong mảng là chứng chỉ lá.

00:10:17.000 --> 00:10:21.000
Khóa công khai của chứng chỉ này đã ký JWS.

00:10:21.000 --> 00:10:30.000
Để xác minh chứng chỉ này là từ Apple, hãy xây dựng một chuỗi tin cậy trở lại một nguồn đáng tin cậy đã biết, trong trường hợp này, một cơ quan cấp chứng chỉ gốc của Apple.

00:10:30.000 --> 00:10:36.000
Chứng chỉ tiếp theo trong mảng là cơ quan cấp chứng chỉ trung gian Quan hệ Nhà phát triển Toàn cầu của Apple.

00:10:36.000 --> 00:10:42.000
Hãy nghĩ về điều này như một phiên bản chuyên biệt hơn của Cơ quan cấp chứng chỉ gốc Apple tập trung vào các nhà phát triển.

00:10:42.000 --> 00:10:49.000
Chứng chỉ cuối cùng trong chuỗi là cơ quan cấp chứng chỉ gốc của Apple để chúng tôi hiểu cơ quan Apple nào bắt nguồn từ chuỗi này.

00:10:49.000 --> 00:10:58.000
Nhắc nhở, điều quan trọng là phải xác minh chứng chỉ khớp chính xác với chứng chỉ gốc mà chúng tôi đã nhận được trước đây từ trang web Cơ sở hạ tầng khóa công khai của Apple.

00:10:58.000 --> 00:11:03.000
Bước đầu tiên là xác minh rằng mỗi chứng chỉ được ký bởi chứng chỉ trước đó trong chuỗi.

00:11:03.000 --> 00:11:10.000
Sau đó thực hiện các bước xác minh bổ sung, như đảm bảo mỗi chứng chỉ có ngày hợp lệ, được định dạng đúng, v.v.

00:11:10.000 --> 00:11:21.000
Tiếp theo, xác nhận rằng các chứng chỉ này là từ Apple và mục đích của chúng là ký dữ liệu App Store, trái ngược với trường hợp sử dụng không liên quan, sẽ không hợp lệ để ký dữ liệu App Store.

00:11:21.000 --> 00:11:30.000
Để xác minh chứng chỉ lá, hãy xác nhận mục đích của nó bằng cách kiểm tra sự hiện diện của mã định danh đối tượng, hoặc OID, cho Mac App Store Receipt Signing.

00:11:30.000 --> 00:11:36.000
Đối với chứng chỉ trung cấp, hãy kiểm tra xem cơ quan trung gian OID cho Quan hệ Nhà phát triển Toàn cầu của Apple.

00:11:36.000 --> 00:11:45.000
Cuối cùng, như đã nêu trước đây, hãy đảm bảo cơ quan cấp chứng chỉ gốc là một trong những chứng chỉ bạn đã lưu trữ với tư cách là Cơ quan cấp chứng chỉ gốc của Apple.

00:11:45.000 --> 00:11:52.000
Bây giờ chúng ta hãy thực sự giải mã chứng chỉ lá và quan sát cách kiểm tra các giá trị này.

00:11:52.000 --> 00:12:01.000
Đây là phần mở rộng X.509 v3 của chứng chỉ được tạo ra bởi lệnh OpenSSL x509.

00:12:01.000 --> 00:12:09.000
Ở dưới cùng là OID được liệt kê trên trang chiếu trước, cho biết mục đích của chứng chỉ là ký biên lai App Store.

00:12:09.000 --> 00:12:14.000
Tuy nhiên, có một số trường bổ sung quan trọng cần kiểm tra.

00:12:14.000 --> 00:12:23.000
Ở đây chúng ta thấy phần truy cập thông tin có thẩm quyền, cung cấp thông tin về tổ chức phát hành và quan trọng là cung cấp thông tin để kiểm tra xem chứng chỉ có bị thu hồi hay không.

00:12:23.000 --> 00:12:27.000
Sử dụng Giao thức Trạng thái Chứng chỉ Trực tuyến, hoặc OCSP.

00:12:27.000 --> 00:12:31.000
Kiểm tra xem chứng chỉ đã bị thu hồi chưa trước khi tiến hành quá trình xác minh.

00:12:31.000 --> 00:12:38.000
Quy trình và quy trình mật mã để làm như vậy được xác định trong RFC 6960.

00:12:38.000 --> 00:12:44.000
Sau khi xác minh chuỗi chứng chỉ, hãy kiểm tra JWS được ký bởi khóa công khai của chứng chỉ lá.

00:12:44.000 --> 00:12:58.000
Lấy chứng chỉ lá từ trước, trích xuất khóa công khai của chứng chỉ lá, lấy khóa và JWS gốc, và chuyển chúng đến chức năng xác minh chữ ký JWS.

00:12:58.000 --> 00:13:03.000
Chức năng xác minh kiểm tra xem dữ liệu có được ký bởi khóa công khai hay không và giải mã tải trọng.

00:13:03.000 --> 00:13:08.000
Quá trình gần như đã hoàn tất, nhưng có một bước xác minh bổ sung.

00:13:08.000 --> 00:13:12.000
Đây là Thông báo KIỂM TRA Máy chủ App Store được giải mã.

00:13:12.000 --> 00:13:15.000
Các bước trước đó đã xác minh dữ liệu đến từ App Store.

00:13:15.000 --> 00:13:22.000
Tuy nhiên, hãy kiểm tra xem thông báo có được nhắm mục tiêu vào ứng dụng và môi trường chính xác của bạn hay không.

00:13:22.000 --> 00:13:29.000
Kiểm tra appAppleId và bundleId để xác nhận thông báo được nhắm mục tiêu cho ứng dụng chính xác của bạn.

00:13:29.000 --> 00:13:33.000
Kiểm tra môi trường phù hợp với môi trường mong đợi.

00:13:33.000 --> 00:13:41.000
Cũng giống như các bước khác trong quy trình xác minh, thư viện Máy chủ App Store cũng kiểm tra những bước này khi thực hiện xác minh.

00:13:41.000 --> 00:13:45.000
Điều đó hoàn thành quá trình xác minh dữ liệu đã ký từ App Store.

00:13:45.000 --> 00:13:52.000
Tiếp theo, tôi sẽ mở rộng dự án của mình từ trước đó để xác minh dữ liệu đã ký bằng cách sử dụng lớp SignedDataVerifier có trong Thư viện Máy chủ App Store.

00:13:52.000 --> 00:13:57.000
Lớp SignedDataVerifier thực hiện các bước xác minh đã đề cập trước đó.

00:13:57.000 --> 00:14:03.000
Trong bản demo này, tôi sẽ nhận được thông báo kiểm tra mà tôi đã yêu cầu trước đó, sau đó xác thực và giải mã thông báo đã ký.

00:14:03.000 --> 00:14:08.000
Có một sự chậm trễ nhỏ giữa việc yêu cầu thông báo kiểm tra và thông báo được nhận trên máy chủ của tôi.

00:14:08.000 --> 00:14:12.000
Do đó, hãy thêm độ trễ năm giây.

00:14:12.000 --> 00:14:19.000
Tiếp theo, hãy gọi điểm cuối Nhận Trạng thái Thông báo Kiểm tra bằng cách sử dụng mã thông báo testNotification thu được trước đó.

00:14:19.000 --> 00:14:23.000
Cuối cùng, in một vài ký tự đầu tiên của thông báo để xác nhận thành công.

00:14:23.000 --> 00:14:30.000
Điểm cuối Nhận Trạng thái Thông báo Kiểm tra trả về kết quả của nỗ lực gửi, cũng như tải trọng thông báo.

00:14:30.000 --> 00:14:37.000
Sự khởi đầu của tải trọng đó là những gì chúng ta nên thấy.

00:14:37.000 --> 00:14:41.000
Đúng như dự đoán, tôi thấy một vài ký tự đầu tiên của thông báo.

00:14:41.000 --> 00:14:44.000
Tiếp tục, tạo ra một trình xác minh dữ liệu đã ký.

00:14:44.000 --> 00:14:52.000
Điều này đòi hỏi ba phần thông tin, bắt đầu với danh sách các cơ quan cấp chứng chỉ Apple Root.

00:14:52.000 --> 00:14:56.000
Các chứng chỉ tôi đã tải xuống trước đó hiện đang nằm trong thư mục tài nguyên.

00:14:56.000 --> 00:15:00.000
Nhập chứng chỉ gốc vào một Bộ.

00:15:00.000 --> 00:15:04.000
Vì tôi đang sử dụng hộp cát, tôi không yêu cầu ID Apple ứng dụng.

00:15:04.000 --> 00:15:08.000
Thay vào đó hãy chuyển null trong hộp cát.

00:15:08.000 --> 00:15:11.000
Cuối cùng, có nên thực hiện kiểm tra thu hồi hay không.

00:15:11.000 --> 00:15:16.000
Bởi vì thông báo vừa được nhận, onlineChecks phải đúng.

00:15:16.000 --> 00:15:22.000
Đối với các thông báo nhận được vài tháng hoặc nhiều năm trước, điều này phải sai vì chứng chỉ có thể đã hết hạn.

00:15:22.000 --> 00:15:26.000
Chuyển các trường này vào Trình xác minh dữ liệu đã ký mới.

00:15:26.000 --> 00:15:37.000
Sau đó, chuyển thông báo nhận được trước đó, in kết quả và sau đó chạy chương trình.

00:15:37.000 --> 00:15:41.000
Khi chương trình hoàn tất, chương trình sẽ hiển thị thông báo đã được xác minh và giải mã.

00:15:41.000 --> 00:15:51.000
Vì đây là thông báo kiểm tra, đây sẽ có một loại KIỂM TRA và mã định danh gói của ứng dụng trong tải trọng, cùng với một vài trường khác.

00:15:51.000 --> 00:15:56.000
Đúng như dự đoán, tôi thấy một thông báo được giải mã thuộc loại TEST.

00:15:56.000 --> 00:16:00.000
Tôi đã mở rộng bản demo trước đây của chúng tôi để trình diễn đối tượng SignedDataVerifier.

00:16:00.000 --> 00:16:03.000
Đây là Dave để xem xét một số phương pháp hay nhất.

00:16:03.000 --> 00:16:17.000
Dave: Chà, điều đó thực sự minh họa tất cả các bước cần thiết để xác minh dữ liệu đã ký và cách thư viện có thể xử lý sự phức tạp đó cho bạn, vì vậy hãy đảm bảo sử dụng SignedDataVerifier để xác thực phía máy chủ của bạn.

00:16:17.000 --> 00:16:29.000
Một lời nhắc nhở quan trọng: khi bạn xác minh dữ liệu, bạn vẫn cần xác nhận số nhận dạng ứng dụng và sản phẩm để đảm bảo bạn đang cấp hoặc thu hồi các giao dịch mua cho đúng ứng dụng hoặc dịch vụ.

00:16:29.000 --> 00:16:40.000
Cuối cùng, khi chứng chỉ hết hạn và có thể bị thu hồi, đừng mã hóa cứng bất kỳ chứng chỉ, phía máy khách hoặc phía máy chủ nào và luôn xác nhận rằng chúng đang hoạt động.

00:16:40.000 --> 00:16:52.000
Bây giờ chúng tôi sẽ xem xét một tiện ích máy chủ App Store khác để hỗ trợ di chuyển xác thực biên lai ứng dụng phía máy chủ của bạn ra khỏi điểm cuối verifyReceipt và chuyển sang API Máy chủ App Store.

00:16:52.000 --> 00:17:01.000
Thư viện Máy chủ App Store cung cấp một tiện ích để hỗ trợ cụ thể cho việc di chuyển này và đảm bảo không có ứng dụng nào bị bỏ lại phía sau.

00:17:01.000 --> 00:17:07.000
Khi cân nhắc chuyển sang App Store Server API, có nhiều lý do để ưu tiên công việc này trong lộ trình của bạn.

00:17:07.000 --> 00:17:18.000
API hỗ trợ xác thực mua hàng và chứa các điểm cuối bổ sung hữu ích cho hỗ trợ khách hàng, xoa dịu và thử nghiệm Thông báo Máy chủ App Store V2.

00:17:18.000 --> 00:17:32.000
Khi chúng tôi tiếp tục cập nhật và phát hành các thuộc tính mới, chúng sẽ chỉ được phát hành với dữ liệu đã ký JWS, được hỗ trợ bởi StoreKit 2, App Store Server API và App Store Server Notifications V2.

00:17:32.000 --> 00:17:40.000
Một lợi ích bổ sung, dữ liệu duy nhất bạn cần ghi lại, là ID giao dịch gốc hoặc ID giao dịch.

00:17:40.000 --> 00:17:45.000
Bạn không còn cần lưu biên lai được mã hóa base64 trong hệ thống tài khoản của mình nữa.

00:17:45.000 --> 00:17:53.000
Và với việc tiếp tục đầu tư vào các API mới nhất, chúng tôi đã thông báo rằng điểm cuối verifyReceipt hiện không được chấp nhận.

00:17:53.000 --> 00:18:01.000
Để tìm hiểu thêm, hãy xem phiên "Có gì mới trong API máy chủ App Store" để cập nhật và hướng dẫn chi tiết.

00:18:01.000 --> 00:18:06.000
Bây giờ đây là Alex để chia sẻ cách thư viện máy chủ App Store sẽ hỗ trợ việc di chuyển của bạn.

00:18:06.000 --> 00:18:07.000
Alex?

00:18:07.000 --> 00:18:08.000
Alex: Cảm ơn, Dave.

00:18:08.000 --> 00:18:12.000
Bây giờ chúng ta hãy xem qua sơ đồ quy trình cho Biên lai ứng dụng.

00:18:12.000 --> 00:18:25.000
Mặc dù StoreKit 2 và App Store Server API là những công cụ tuyệt vời để sử dụng, nhưng điều quan trọng là phải hỗ trợ khách hàng trên các thiết bị cũ hơn hoặc người dùng chưa cập nhật gần đây và chỉ có Biên lai ứng dụng mới có thể được cung cấp cho máy chủ của bạn.

00:18:25.000 --> 00:18:34.000
Tôi sẽ chỉ ra cách các thiết bị này đã được hỗ trợ trước đây và sau đó là cách bạn có thể tiếp tục hỗ trợ các khách hàng này sau khi xác minhReceipt không sử dụng.

00:18:34.000 --> 00:18:38.000
Đầu tiên, thiết bị gửi biên lai đến máy chủ của bạn.

00:18:38.000 --> 00:18:46.000
Trong mô hình cũ, máy chủ của bạn chuyển biên lai này để xác minh Biên lai và sau đó nhận biên lai được giải mã.

00:18:46.000 --> 00:18:55.000
Phản hồi chứa một originalTransactionId, được chuyển đến điểm cuối Get Transaction History trong App Store Server API.

00:18:55.000 --> 00:19:00.000
Máy chủ App Store trả về các giao dịch đã ký mà bạn sử dụng để cung cấp dịch vụ cho khách hàng.

00:19:00.000 --> 00:19:05.000
Bây giờ verifyReceipt đã bị phản đối, hãy thay thế phần này.

00:19:05.000 --> 00:19:10.000
Tiện ích biên lai trong Thư viện Máy chủ App Store trích xuất trực tiếp ID giao dịch từ biên lai.

00:19:10.000 --> 00:19:16.000
Bạn chuyển ID giao dịch đến App Store Server API, loại bỏ nhu cầu thực hiện hai chuyến khứ hồi.

00:19:16.000 --> 00:19:19.000
Sau đó, lưu trữ bản sửa đổi từ điểm cuối.

00:19:19.000 --> 00:19:24.000
Điều này loại bỏ sự cần thiết phải phân tích lại toàn bộ lịch sử mỗi lần.

00:19:24.000 --> 00:19:41.000
Bởi vì giá trị được trích xuất từ biên lai ứng dụng có thể là ID giao dịch gốc hoặc không, chúng tôi rất vui mừng thông báo rằng nhiều điểm cuối của chúng tôi, bao gồm điểm cuối Nhận Lịch sử Giao dịch, hiện hỗ trợ bất kỳ ID giao dịch nào làm tham số, không chỉ ID giao dịch gốc.

00:19:41.000 --> 00:19:49.000
Bây giờ tôi sẽ chứng minh việc trích xuất ID giao dịch để sử dụng với điểm cuối Nhận Lịch sử Giao dịch bằng Thư viện Máy chủ App Store.

00:19:49.000 --> 00:19:56.000
Ở đây tôi sẽ lấy biên lai ứng dụng, trích xuất ID giao dịch và gọi điểm cuối Nhận Lịch sử Giao dịch bằng ID.

00:19:56.000 --> 00:19:58.000
Đầu tiên, Biên lai Ứng dụng.

00:19:58.000 --> 00:20:03.000
Bạn có thể nhận Biên lai Ứng dụng từ thiết bị hoặc Thông báo Máy chủ App Store V1.

00:20:03.000 --> 00:20:05.000
Tôi đã có một cái ở đây rồi.

00:20:05.000 --> 00:20:09.000
Tiếp theo, tạo một phiên bản của lớp ReceiptUtility.

00:20:09.000 --> 00:20:15.000
Để trích xuất ID giao dịch, hãy gọi ID giao dịch trích xuất từ phương thức nhận ứng dụng.

00:20:15.000 --> 00:20:17.000
Không phải tất cả các biên lai sẽ có ID giao dịch.

00:20:17.000 --> 00:20:20.000
Có thể người dùng không có bất kỳ giao dịch mua nào.

00:20:20.000 --> 00:20:24.000
Do đó, hãy thêm một kiểm tra rỗng.

00:20:24.000 --> 00:20:34.000
Để cung cấp thêm chiều sâu cho vấn đề này, hãy tưởng tượng chúng tôi muốn lấy thông tin về hàng tiêu dùng gần đây nhất cho người dùng này và loại trừ hàng tiêu dùng bị thu hồi.

00:20:34.000 --> 00:20:49.000
Tạo một đối tượng Yêu cầu Lịch sử Giao dịch, chỉ định rằng chỉ muốn là các sản phẩm thuộc loại CONSUMABLE để loại trừ các giao dịch bị thu hồi và dữ liệu phải được trả về theo thứ tự giảm dần.

00:20:49.000 --> 00:20:55.000
Chúng tôi cần hai đối tượng trợ giúp, một biến phản hồi và một danh sách các giao dịch.

00:20:55.000 --> 00:21:00.000
A do while lặp các trang thông qua các phản hồi từ điểm cuối lịch sử giao dịch.

00:21:00.000 --> 00:21:06.000
Nếu đây không phải là yêu cầu đầu tiên, hãy tìm mã thông báo sửa đổi từ phản hồi trước đó để tiếp tục phân trang qua dữ liệu.

00:21:06.000 --> 00:21:16.000
Sau đó, gọi điểm cuối Nhận Lịch sử Giao dịch với ID giao dịch từ biên lai ứng dụng, đối tượng yêu cầu và bản sửa đổi.

00:21:16.000 --> 00:21:21.000
Cuối cùng, thêm tất cả các giao dịch từ phản hồi vào danh sách giao dịch.

00:21:21.000 --> 00:21:27.000
Lặp lại quá trình này cho đến khi trường hasMore sai trong phản hồi.

00:21:27.000 --> 00:21:36.000
In ra các giao dịch để xem kết quả.

00:21:36.000 --> 00:21:41.000
Ở đây tôi thấy một danh sách các giao dịch được trả về từ API.

00:21:41.000 --> 00:21:46.000
Có thể được giải mã bằng cách sử dụng SignedDataVerifier từ bản demo trước đó.

00:21:46.000 --> 00:21:51.000
Cảm ơn vì đã tham gia cuộc trình diễn cuối cùng của chúng tôi đã chỉ ra cách bạn có thể sử dụng Biên lai ứng dụng với API Máy chủ App Store.

00:21:51.000 --> 00:21:53.000
Quay lại với Dave để kết thúc chúng tôi.

00:21:53.000 --> 00:22:04.000
Dave: Tôi thực sự hào hứng với thư viện Máy chủ App Store mới và tôi thấy những khả năng này giúp bạn dễ dàng áp dụng API của chúng tôi và chuyển sang API Máy chủ App Store.

00:22:04.000 --> 00:22:09.000
Đây là ảnh chụp màn hình của kho lưu trữ App Store Server API Java trên Github.

00:22:09.000 --> 00:22:17.000
Trên trang này, bạn có thể tìm thấy các liên kết đến tài liệu của chúng tôi, gửi yêu cầu kéo và tìm các ví dụ về cách sử dụng thư viện.

00:22:17.000 --> 00:22:24.000
Bạn có thể tải xuống thư viện Máy chủ App Store BETA sớm và bắt đầu lên kế hoạch áp dụng API Máy chủ App Store.

00:22:24.000 --> 00:22:27.000
Chúng tôi mong nhận được phản hồi và yêu cầu tính năng của bạn.

00:22:27.000 --> 00:22:31.000
Vui lòng liên hệ với chúng tôi tại Trợ lý Phản hồi và trên Github.

00:22:31.000 --> 00:22:32.000
Cảm ơn bạn.

00:22:32.000 --> 23:59:59.000
♪ ♪

