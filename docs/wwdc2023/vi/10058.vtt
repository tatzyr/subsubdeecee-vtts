WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:17.000
James: Xin chào. Tôi là James Magahern từ UIKit, và tôi sẽ là người hướng dẫn bạn về những điều mới mẻ với các tương tác văn bản và văn bản.

00:00:17.000 --> 00:00:20.000
Văn bản đóng một vai trò quan trọng trong mọi ứng dụng.

00:00:20.000 --> 00:00:24.000
Đó là cách chính để tiêu thụ thông tin và giao tiếp.

00:00:24.000 --> 00:00:33.000
Bây giờ chúng tôi đang cung cấp cho bạn nhiều công cụ hơn để tạo ra trải nghiệm văn bản mạnh mẽ trong ứng dụng của bạn, cho dù bạn đang bắt đầu lại từ đầu hay từ trừu tượng cấp cao.

00:00:33.000 --> 00:00:56.000
Tôi sẽ xem xét một loạt các cải tiến tuyệt vời để tạo trải nghiệm văn bản và cách tận dụng chúng trong ứng dụng của bạn, bao gồm một số thay đổi đối với giao diện người dùng lựa chọn hệ thống, thêm các hành động và menu mục văn bản vào UITextViews, danh sách và dấu đầu dòng trong TextKit 2, giao diện người dùng đọc chính tả

00:00:56.000 --> 00:00:59.000
Chúng ta sẽ bắt đầu bằng cách nói về một số thay đổi đối với giao diện người dùng lựa chọn.

00:00:59.000 --> 00:01:04.000
Mới trên tất cả các nền tảng của chúng tôi là một con trỏ văn bản được thiết kế lại hoàn toàn.

00:01:04.000 --> 00:01:19.000
Bây giờ chúng tôi hiển thị một bộ chuyển đổi tương tác, nội tuyến khi thay đổi ngôn ngữ đầu vào, xử lý lựa chọn tiện dụng hơn khi thực hiện lựa chọn phạm vi và chúng tôi cũng có một hình thái sáng hoàn toàn mới để giúp dễ dàng đặt con trỏ vào phần thân văn bản lớn hơn.

00:01:19.000 --> 00:01:27.000
Nếu ứng dụng của bạn đang sử dụng UITextViews hoặc UITextFields, thì bạn sẽ tự động nhận được tất cả giao diện người dùng mới này.

00:01:27.000 --> 00:01:33.000
Ngoài ra, chúng tôi đảm bảo rằng khách hàng của UITextInteraction cũng nhận được giao diện người dùng lựa chọn mới.

00:01:33.000 --> 00:01:46.000
Tuy nhiên, nếu bạn có giao diện người dùng tùy chỉnh cao để hiển thị văn bản, có thể khó theo kịp những thay đổi này trong việc triển khai của riêng bạn, đặc biệt nếu bạn không thể áp dụng UITextInteraction.

00:01:46.000 --> 00:01:57.000
Đó là lý do tại sao trong iOS 17, chúng tôi đã thêm UITextSelectionDisplayInteraction, chỉ cung cấp giao diện người dùng lựa chọn mà không có các cử chỉ đi kèm với UITextInteraction.

00:01:57.000 --> 00:02:04.000
UITextSelectionDisplayInteraction là một loại UIInteraction mới có thể được cài đặt trên bất kỳ UIView nào.

00:02:04.000 --> 00:02:16.000
Bạn cũng phải cung cấp một đối tượng triển khai giao thức UITextInput, xác định các phương thức khác nhau cho tương tác để có được trạng thái lựa chọn từ chế độ xem của bạn.

00:02:16.000 --> 00:02:28.000
UITextSelectionDisplayInteraction sau đó sẽ thực hiện tất cả các công việc nặng nhọc cho bạn, cung cấp chế độ xem con trỏ và các phụ kiện con trỏ, cũng như các tay cầm đánh dấu và lựa chọn phạm vi.

00:02:28.000 --> 00:02:33.000
Tất cả các chế độ xem này cũng có thể thay thế được, vì vậy bạn có thể tùy chỉnh hành vi nếu cần.

00:02:33.000 --> 00:02:36.000
Đây là một cái nhìn nhanh về một ví dụ về cách thực hiện điều này trong mã.

00:02:36.000 --> 00:02:46.000
Đầu tiên, tạo một tương tác hiển thị lựa chọn và cung cấp cho nó đối tượng tài liệu của bạn để triển khai giao thức UITextInput.

00:02:46.000 --> 00:02:50.000
Điều này có thể giống với quan điểm của bạn, nếu có.

00:02:50.000 --> 00:02:56.000
Tiếp theo, chỉ cần thêm tương tác vào chế độ xem bạn muốn hiển thị giao diện người dùng lựa chọn bên trong.

00:02:56.000 --> 00:03:01.000
Đây có thể là chế độ xem vùng chứa hoặc chế độ xem hiển thị tài liệu của bạn.

00:03:01.000 --> 00:03:13.000
Bất cứ khi nào trạng thái lựa chọn thay đổi, chỉ cần đảm bảo gọi setNeedsSelectionUpdate về tương tác và tương tác sẽ đảm nhận việc cập nhật tất cả các chế độ xem để phản ánh trạng thái lựa chọn mới của bạn.

00:03:13.000 --> 00:03:19.000
Ngoài UITextSelectionDisplayInteraction, chúng tôi cũng đã thêm một API mới để hiển thị hình thái sáng.

00:03:19.000 --> 00:03:27.000
Nó có thể được sử dụng trên bất kỳ chế độ xem nào và UITextSelectionDisplayInteraction hoặc UITextInput không bắt buộc phải sử dụng nó.

00:03:27.000 --> 00:03:35.000
Bạn nên sử dụng công cụ nhận dạng cử chỉ, chẳng hạn như UIPanGestureRecognizer, để điều khiển các bản cập nhật của loupe.

00:03:35.000 --> 00:03:38.000
Đây là cách quản lý phiên loupe trong mã.

00:03:38.000 --> 00:03:47.000
Khi sử dụng công cụ nhận dạng cử chỉ xoay, trong cuộc gọi lại, hãy lấy vị trí của cử chỉ và tiện ích lựa chọn, trong trường hợp này là chế độ xem con trỏ.

00:03:47.000 --> 00:04:00.000
Tiếp theo, nếu cử chỉ đang bắt đầu, hãy tạo một UITextLoupeSession mới bằng cách gọi begin(at:), cung cấp vị trí bắt đầu của loupe, tiện ích lựa chọn và không gian tọa độ.

00:04:00.000 --> 00:04:08.000
Sau đó, khi cử chỉ di chuyển xung quanh, hãy gọi move(to:) trên phiên loupe hiện có để cập nhật vị trí của nó.

00:04:08.000 --> 00:04:15.000
Cuối cùng, khi công cụ nhận dạng cử chỉ kết thúc, hãy đảm bảo gọi vô hiệu hóa trong phiên loupe để loại bỏ nó.

00:04:15.000 --> 00:04:22.000
Tiếp theo, tôi muốn xem qua các hành động của mục văn bản và cách bạn có thể sử dụng chúng để hiển thị các menu bên trong chế độ xem văn bản.

00:04:22.000 --> 00:04:31.000
Các tương tác mục văn bản trong UITextView giờ đây có thể tùy chỉnh nhiều hơn bằng cách sử dụng các API mới trên UITextViewDelegate.

00:04:31.000 --> 00:04:41.000
Những bổ sung mới này cho phép sửa đổi hành động chính cho các mục văn bản hoặc trình bày một menu như menu ứng cử viên được hiển thị ở đây trong ứng dụng Dịch.

00:04:41.000 --> 00:04:53.000
Trước đây, UITextView cho phép các nhà phát triển vô hiệu hóa các tương tác mục thông qua shouldInteractWith APIs trên UITextViewDelegate cho các liên kết và tệp đính kèm.

00:04:53.000 --> 00:05:00.000
Trong iOS 17, giờ đây bạn có khả năng tùy chỉnh tương tác mục cho các mục văn bản trong chế độ xem văn bản.

00:05:00.000 --> 00:05:09.000
UITextViewDelegate đã đạt được các phương pháp mới để tùy chỉnh cả hành động chính hoặc cung cấp menu cho các mục văn bản cụ thể.

00:05:09.000 --> 00:05:16.000
Đây là đánh giá nhanh về các mục văn bản thực sự là gì và cách chúng tích hợp với ứng dụng của bạn.

00:05:16.000 --> 00:05:21.000
Các mục văn bản đại diện cho nội dung hỗ trợ tương tác mục.

00:05:21.000 --> 00:05:32.000
Điều này bao gồm các tệp đính kèm văn bản, được đại diện bởi NSTextAttachment và các liên kết, được đại diện bởi NSLinkAttributeName.

00:05:32.000 --> 00:05:38.000
UITextItem hiện cũng hỗ trợ gắn thẻ các dải văn bản tùy chỉnh để tương tác.

00:05:38.000 --> 00:05:47.000
Để gắn thẻ một phạm vi tương tác, hãy sử dụng UITextItemTagAttributeName trên chuỗi được gán đại diện cho phạm vi văn bản bạn muốn thực hiện tương tác.

00:05:47.000 --> 00:05:56.000
Với các API mới này, giờ đây có thể thay đổi hành vi nhấn hoặc menu mặc định khi một mục văn bản được tương tác.

00:05:56.000 --> 00:06:07.000
Ví dụ, bạn có thể muốn chuyển hướng các liên kết đã biết đến các chế độ xem hiện có trong ứng dụng hoặc thêm các menu tùy chỉnh vào các phần của văn bản.

00:06:07.000 --> 00:06:18.000
Để tiếp tục ngăn chặn hoặc vô hiệu hóa hành động hoặc menu chính, chỉ cần trả về nil cho các phương thức đại diện menuConfiguration hoặc primaryAction.

00:06:18.000 --> 00:06:27.000
Đây là một ví dụ mã nhỏ minh họa cách hiển thị menu để phản hồi người dùng nhấn vào liên kết bên trong UITextView của bạn.

00:06:27.000 --> 00:06:38.000
Chỉ cần triển khai menuConfigurationFor:defaultMenu: phương thức từ UITextViewDelegate và trả về cấu hình menu chứa menu bạn muốn hiển thị.

00:06:38.000 --> 00:06:46.000
Bạn cũng có thể cung cấp bản xem trước như một phần của cấu hình menu để hiển thị nội tuyến với phần còn lại của menu ngữ cảnh.

00:06:46.000 --> 00:06:50.000
Danh sách và hỗ trợ dấu đầu dòng cũng đã được thêm vào TextKit 2.

00:06:50.000 --> 00:06:53.000
Tôi sẽ xem xét cách bạn có thể tận dụng điều này trong đơn đăng ký của mình.

00:06:53.000 --> 00:07:02.000
Ngoài việc hỗ trợ nhiều loại mục dấu đầu dòng khác nhau, thứ tự chữ số La Mã, bảng chữ cái và thập phân cũng được hỗ trợ.

00:07:02.000 --> 00:07:12.000
Mỗi cái sẽ tự động được bản địa hóa dựa trên ngôn ngữ được cấu hình của thiết bị hoặc ứng dụng, vì vậy việc quốc tế hóa trên toàn thế giới được tích hợp ngay.

00:07:12.000 --> 00:07:17.000
Đây là một ví dụ nhanh về cách bạn có thể bắt đầu với danh sách văn bản bằng cách sử dụng các chuỗi được gán.

00:07:17.000 --> 00:07:25.000
Sử dụng thuộc tính textLists trên NSParagraphStyle để xác định đoạn nào có danh sách có thứ tự được áp dụng cho nó.

00:07:25.000 --> 00:07:36.000
Hệ thống sẽ tự động đánh số các mục dựa trên các ký tự kết thúc dòng như dòng mới và UITextView sẽ tự động truyền bá kiểu đoạn văn dựa trên các thuộc tính nhập.

00:07:36.000 --> 00:07:41.000
Có một số thay đổi lớn trong cách đọc chính tả hoạt động trên macOS Sonoma.

00:07:41.000 --> 00:07:46.000
Chúng tôi có một số API mới để giúp bạn đảm bảo các yếu tố văn bản tùy chỉnh của bạn hoạt động tốt với thiết kế mới.

00:07:46.000 --> 00:07:52.000
Đây là cách chỉ báo đọc chính tả mới hoạt động trên macOS 14.

00:07:52.000 --> 00:08:01.000
Giống như trên iOS, đọc chính tả có hiệu ứng phát sáng khi nói và chỉ báo micrô xuất hiện khi nghỉ ngơi.

00:08:01.000 --> 00:08:12.000
Lưu ý rằng sau khi cuộn, chỉ báo bên cạnh con trỏ sẽ dính vào cạnh của chế độ xem cuộn và cung cấp một nút để trở về vị trí hiện tại trong tài liệu.

00:08:12.000 --> 00:08:19.000
Nếu bạn đang sử dụng điều khiển văn bản tiêu chuẩn trong AppKit như NSTextView, bạn sẽ nhận được hành vi này ngay lập tức.

00:08:19.000 --> 00:08:28.000
Nếu ứng dụng của bạn cung cấp một triển khai tùy chỉnh để hiển thị điểm chèn, có một chút công việc bạn sẽ cần làm để hỗ trợ hành vi mới này.

00:08:28.000 --> 00:08:38.000
Tương tự như UITextSelectionDisplayInteraction cho iOS, hiện có một API mới cho macOS cũng cho phép bạn duy trì sự nhất quán với giao diện người dùng lựa chọn của hệ thống.

00:08:38.000 --> 00:08:51.000
Thay vì vẽ con trỏ của riêng bạn, hãy sử dụng NSTextInsertionIndicator, đây là một lớp con NSView có thể tùy chỉnh mà bạn có thể đặt bên trong chế độ xem tài liệu của mình để chỉ ra vị trí con trỏ.

00:08:51.000 --> 00:08:53.000
Sự xuất hiện của nó có thể tùy chỉnh.

00:08:53.000 --> 00:08:56.000
Bạn có thể thay đổi màu sắc và kích thước.

00:08:56.000 --> 00:09:00.000
Theo mặc định, nó sẽ theo màu nhấn hiện tại.

00:09:00.000 --> 00:09:03.000
Nó làm cho việc hỗ trợ các hiệu ứng đọc chính tả thực sự dễ dàng.

00:09:03.000 --> 00:09:09.000
Chỉ có một chút cấu hình cần thiết để cho phép hệ thống chèn các chế độ xem thích hợp vào hệ thống phân cấp của bạn.

00:09:09.000 --> 00:09:15.000
Đây là cách bắt đầu sử dụng NSTextInsertionIndicator trên macOS.

00:09:15.000 --> 00:09:24.000
Chỉ cần tạo chế độ xem NSTextInsertionIndicator và thêm nó dưới dạng chế độ xem phụ cho bất kỳ chế độ xem nào đang hiển thị nội dung tài liệu của bạn.

00:09:24.000 --> 00:09:32.000
Khi bạn đã làm điều đó, hãy đặt effectsViewInserter thành một khối chèn các chế độ xem do hệ thống của bạn cung cấp vào hệ thống phân cấp chế độ xem tài liệu của bạn.

00:09:32.000 --> 00:09:41.000
Hệ thống sẽ tự động đảm nhận việc định vị các chế độ xem hiệu ứng và đảm bảo chúng được cập nhật khi chỉ báo chèn di chuyển xung quanh.

00:09:41.000 --> 00:09:50.000
Khi chế độ xem văn bản tùy chỉnh của bạn từ bỏ trạng thái người trả lời, hãy đảm bảo ẩn con trỏ bằng cách đặt Chế độ hiển thị thành ẩn.

00:09:50.000 --> 00:09:59.000
Khi văn bản được chèn vào, các bản cập nhật cho khung sẽ tự động được hoạt hình với hiệu ứng phát sáng nếu đọc chính tả được sử dụng làm nguồn đầu vào.

00:09:59.000 --> 00:10:07.000
Nếu bạn cần tắt hiệu ứng phát sáng, hãy xóa tùy chọn showEffectsView khỏi automaticModeOptions.

00:10:07.000 --> 00:10:17.000
Khi người dùng thay đổi chế độ nhập, chế độ xem hiệu ứng được hiển thị bên dưới con trỏ trong văn bản ngang để hiển thị giao diện người dùng lựa chọn ngôn ngữ.

00:10:17.000 --> 00:10:26.000
Nếu bạn cần ghi đè vị trí của giao diện người dùng này, bạn có thể chỉ định preferredTextAccessoryPlacement trong việc triển khai NSTextInputClient của bạn.

00:10:26.000 --> 00:10:31.000
Hệ thống kiểm tra giá trị của tài sản này để xác định nơi vẽ các phụ kiện.

00:10:31.000 --> 00:10:46.000
Khi con trỏ văn bản được cuộn ra khỏi màn hình trong khi đọc chính tả, hệ thống cũng sẽ hiển thị một chỉ báo cuộn đi để chỉ ra vị trí tương đối của con trỏ và cung cấp khả năng quay lại điểm đọc chính tả.

00:10:46.000 --> 00:10:58.000
Để đảm bảo hành vi này được hỗ trợ trong chế độ xem văn bản tùy chỉnh của bạn, hãy đảm bảo áp dụng NSTextInputClient và triển khai các thuộc tính selectionRect và documentVisibleRect.

00:10:58.000 --> 00:11:08.000
Thông báo cho hệ thống về việc cuộn bắt đầu và kết thúc bằng cách gọi textInputClientWillStartScrollingOrZooming và willEndScrollingOrZooming.

00:11:08.000 --> 00:11:15.000
Đảm bảo ứng dụng của bạn hoạt động tốt ở mọi ngôn ngữ là rất quan trọng để cung cấp trải nghiệm văn bản nổi bật.

00:11:15.000 --> 00:11:22.000
Chúng tôi đã thực hiện một số thay đổi quan trọng đối với các điều khiển văn bản tiêu chuẩn, nâng cao khả năng đọc và công thái học của chúng trên nhiều ngôn ngữ hơn.

00:11:22.000 --> 00:11:30.000
Hỗ trợ kiểu động trong các ứng dụng của bạn sẽ giúp cải thiện bố cục giao diện người dùng của bạn bằng mọi ngôn ngữ.

00:11:30.000 --> 00:11:42.000
Một điều quan trọng cần xem xét khi bố trí các yếu tố văn bản trong ứng dụng của bạn là thực tế là nhiều ngôn ngữ có thể có chiều cao dòng thay đổi ngoài hướng bố cục và kiểu phông chữ.

00:11:42.000 --> 00:11:49.000
Một vấn đề phổ biến gặp phải khi xử lý độ cao dòng thay đổi giữa các ngôn ngữ là vấn đề văn bản được cắt bớt.

00:11:49.000 --> 00:11:59.000
Điều này không chỉ trông tệ mà còn có thể ảnh hưởng đáng kể đến khả năng đọc và cản trở đáng kể trải nghiệm người dùng tổng thể của ứng dụng của bạn.

00:11:59.000 --> 00:12:04.000
Những vấn đề này có thể khó nhận thấy, đặc biệt nếu bạn không thể kiểm tra ứng dụng của mình bằng mọi ngôn ngữ.

00:12:04.000 --> 00:12:13.000
Chúng tôi đã thực hiện một số cải tiến đối với các phần tử văn bản tiêu chuẩn, như UITextField và UILabel, để tự động giải quyết vấn đề này trong hầu hết các trường hợp.

00:12:13.000 --> 00:12:21.000
Tuy nhiên, có một số phương pháp hay nhất mà bạn vẫn nên đảm bảo tuân theo để đảm bảo hệ thống có thể ngăn chặn việc cắt các yếu tố này.

00:12:21.000 --> 00:12:33.000
Để ngăn chặn những vấn đề cắt xén phổ biến này, tất cả các nền tảng của chúng tôi giờ đây sẽ tự động điều chỉnh chiều cao dòng trong UILabel hoặc UITextField để phù hợp với các ngôn ngữ có chiều cao dòng động cao.

00:12:33.000 --> 00:12:37.000
Hành vi mới này chỉ diễn ra trong những trường hợp cụ thể.

00:12:37.000 --> 00:12:43.000
Đầu tiên, hãy nhớ rằng chiều cao dòng hiện phụ thuộc vào ngôn ngữ ưa thích được định cấu hình của thiết bị.

00:12:43.000 --> 00:12:57.000
Thứ hai, điều chỉnh này ảnh hưởng đến toàn bộ giao diện người dùng, tăng chiều cao dòng cho tất cả các phần tử văn bản, ngay cả những phần tử hiển thị tập lệnh có chiều cao dòng cố định, như tiếng Anh, thường không yêu cầu thêm dung lượng.

00:12:57.000 --> 00:13:02.000
Đây là cố ý để đảm bảo tính nhất quán trực quan trên tất cả các yếu tố văn bản.

00:13:02.000 --> 00:13:08.000
Cuối cùng, điều chỉnh tự động này chỉ áp dụng cho các phần tử văn bản sử dụng kiểu văn bản.

00:13:08.000 --> 00:13:12.000
Phông chữ tùy chỉnh sẽ tiếp tục sử dụng chiều cao dòng cố định của chúng.

00:13:12.000 --> 00:13:17.000
Hành vi này không hoàn toàn mới, vì nó đã có hiệu lực đối với một số bản phát hành.

00:13:17.000 --> 00:13:26.000
Tuy nhiên, trong iOS 17, nó năng động hơn nhiều và việc điều chỉnh chính xác phụ thuộc vào cả kiểu văn bản và ngôn ngữ được sử dụng.

00:13:26.000 --> 00:13:37.000
Để tận dụng hành vi này, hãy áp dụng Kiểu văn bản bằng cách tạo UIFont một cách rõ ràng bằng phương thức preferredFont(forTextStyle:) và gán nó cho một phần tử văn bản, như UILabel.

00:13:37.000 --> 00:13:41.000
Tiếp theo, tránh cài đặt clipsToBounds trên các phần tử văn bản.

00:13:41.000 --> 00:13:48.000
Những người lên và xuống dốc cho các ngôn ngữ như tiếng Thái và tiếng Hindi thường sẽ nhô ra ngoài giới hạn chiều cao dòng.

00:13:48.000 --> 00:13:59.000
Điều này thường được chấp nhận trong hầu hết các bố cục, vì thường có thêm không gian xung quanh các phần tử lân cận, nhưng điều đó có nghĩa là cài đặt clipsToBounds sẽ dẫn đến các phần tử văn bản đó bị cắt bớt.

00:13:59.000 --> 00:14:06.000
UIKit cũng đã được cập nhật để ngăn chặn việc sử dụng không cần thiết cài đặt này mà trước đó nó đã được bật theo mặc định.

00:14:06.000 --> 00:14:16.000
Cuối cùng, đảm bảo rằng giao diện người dùng của bạn phản hồi với những thay đổi về chiều cao và tất cả các điều khiển khác vẫn được căn chỉnh, vì các yếu tố văn bản hiện có thể phát triển theo chiều dọc.

00:14:16.000 --> 00:14:24.000
Chúng tôi cũng đã thực hiện những cải tiến đáng kể đối với hành vi ngắt dòng cho các ngôn ngữ như tiếng Trung, tiếng Đức, tiếng Nhật và tiếng Hàn.

00:14:24.000 --> 00:14:32.000
Những cải tiến này áp dụng các quy tắc khác nhau dựa trên loại kiểu văn bản bạn đang sử dụng trong giao diện người dùng của mình và ngôn ngữ nào đang được hiển thị.

00:14:32.000 --> 00:14:39.000
Ví dụ, trước đây, một từ trong văn bản tiếng Hàn có thể đã được phân chia giữa các dòng.

00:14:39.000 --> 00:14:47.000
Giờ đây UIKit ngăn chặn việc tách như vậy cho các kiểu văn bản tiêu đề, đảm bảo trải nghiệm đọc liền mạch hơn.

00:14:47.000 --> 00:14:53.000
Để hưởng lợi từ hành vi mới này trong ứng dụng của bạn, hãy áp dụng Kiểu văn bản tương tự.

00:14:53.000 --> 00:15:00.000
Vì vậy, đó là mọi thứ bạn cần biết để tạo ra trải nghiệm văn bản mạnh mẽ trong ứng dụng của mình trên iOS 17.

00:15:00.000 --> 00:15:09.000
Nếu bạn đang sử dụng chế độ xem văn bản tùy chỉnh trong ứng dụng của mình, hãy đảm bảo sử dụng giao diện người dùng lựa chọn hệ thống để tận dụng tất cả các tính năng mới trong hệ điều hành.

00:15:09.000 --> 00:15:15.000
Sử dụng các mục văn bản để tạo ra các tương tác tốt hơn với các liên kết trong chế độ xem văn bản của bạn.

00:15:15.000 --> 00:15:21.000
Tận dụng các tính năng mới mạnh mẽ của TextKit 2 để cung cấp trải nghiệm chỉnh sửa văn bản phong phú hơn.

00:15:21.000 --> 00:15:31.000
Và áp dụng Kiểu văn bản trong các yếu tố văn bản chung để đảm bảo trải nghiệm người dùng tuyệt vời cho mọi người, bất kể ngôn ngữ hoặc kích thước văn bản ưa thích.

00:15:31.000 --> 00:15:32.000
Đó là tất cả cho bây giờ.

00:15:32.000 --> 00:15:34.000
Cảm ơn vì đã xem.

00:15:34.000 --> 00:15:37.000
Hãy chắc chắn đánh giá năm sao và để lại bình luận bên dưới.

00:15:37.000 --> 23:59:59.000
♪ ♪

