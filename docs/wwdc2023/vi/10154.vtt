WEBVTT

00:00:10.000 --> 00:00:12.000
Julia: Xin chào! Tên tôi là Julia.

00:00:12.000 --> 00:00:14.000
Tôi là một Kỹ sư SwiftUI.

00:00:14.000 --> 00:00:20.000
Gần đây, chúng tôi đã giới thiệu SwiftData, một cách mới để duy trì lớp mô hình của bạn trong Swift.

00:00:20.000 --> 00:00:33.000
Trong phiên hôm nay, hãy xem cách tích hợp liền mạch SwiftData trong ứng dụng SwiftUI. Chúng ta sẽ thảo luận về các tính năng SwiftUI mới cho phép tích hợp trơn tru với các mô hình SwiftData.

00:00:33.000 --> 00:00:38.000
Để đề cập đến những điều cơ bản của bạn, hãy xem phiên "Gặp gỡ SwiftData" trước nếu bạn chưa có.

00:00:38.000 --> 00:00:44.000
Để xem SwiftData và SwiftUI chơi cùng nhau như thế nào, hãy xây dựng một ứng dụng flashcards.

00:00:44.000 --> 00:00:53.000
Trong một thời gian, tôi đã muốn tạo ra một công cụ có thể giúp tôi nhớ ngày tháng và tác giả của những phát minh tuyệt vời, và SwiftData hoàn hảo cho nhiệm vụ này.

00:00:53.000 --> 00:01:00.000
Nó sẽ giúp duy trì các bộ bài flashcard, vì vậy tôi có thể mở và nhấp qua chúng bất cứ khi nào tôi có một phút.

00:01:00.000 --> 00:01:08.000
Tôi muốn ứng dụng này hoạt động ở mọi nơi: trên Mac, iPhone, Đồng hồ và TV, và SwiftData hỗ trợ tôi.

00:01:08.000 --> 00:01:12.000
Nó có sẵn trên tất cả các nền tảng.

00:01:12.000 --> 00:01:14.000
Đây là một mã-cùng.

00:01:14.000 --> 00:01:17.000
Trong phiên này, tôi sẽ xây dựng một ứng dụng với bạn.

00:01:17.000 --> 00:01:26.000
Nhấn tạm dừng ngay bây giờ và tải xuống các dự án Xcode đồng hành: một kho lưu trữ với điểm bắt đầu đã chuẩn bị và điểm đã hoàn thành.

00:01:26.000 --> 00:01:31.000
Mở dự án khởi động và chuyển đến tệp ContentView.

00:01:31.000 --> 00:01:38.000
Trong suốt phiên này, chúng tôi sẽ tận dụng một tính năng Xcode mới, Bản xem trước trực tiếp tương tác được nhúng cho Mac.

00:01:38.000 --> 00:01:43.000
Trong phần Xem trước, có một lưới với một số thẻ nhớ.

00:01:43.000 --> 00:01:50.000
Một cú nhấp chuột vào bất kỳ thẻ nào chuyển sang chế độ xem nơi chúng ta có thể cuộn từng thẻ một.

00:01:50.000 --> 00:01:53.000
Bạn có nhớ ai đã phát minh ra trình biên dịch không?

00:01:53.000 --> 00:01:57.000
Nhấp vào thẻ. Nó lật và đưa ra câu trả lời!

00:01:57.000 --> 00:02:06.000
Ứng dụng được điền với các thẻ mẫu được lưu trữ trong bộ nhớ và nếu chúng tôi chạy ứng dụng và thêm các thẻ mới, chúng sẽ biến mất khi chúng tôi đóng ứng dụng.

00:02:06.000 --> 00:02:09.000
Đây là nơi SwiftData xuất hiện.

00:02:09.000 --> 00:02:13.000
Chúng tôi sẽ sử dụng nó để duy trì các thẻ ghi nhớ mà chúng tôi tạo ra.

00:02:13.000 --> 00:02:24.000
Hôm nay, chúng ta sẽ nói về mọi thứ bạn cần biết để bắt đầu sử dụng SwiftData, kiểm tra hết mục này đến mục khác trong danh sách việc cần làm này mà tôi đã tổng hợp cho chúng tôi.

00:02:24.000 --> 00:02:27.000
Bạn vừa gặp ứng dụng mà chúng tôi sẽ xây dựng.

00:02:27.000 --> 00:02:32.000
Tiếp theo, chúng ta sẽ xem xét dự án khởi động và lớp mô hình của nó.

00:02:32.000 --> 00:02:40.000
Sau đó, từng bước một, chúng tôi sẽ chuyển đổi và sửa đổi nó để sử dụng SwiftData làm nơi lưu trữ.

00:02:40.000 --> 00:02:56.000
Chúng ta sẽ học cách mở rộng lớp mô hình để trở thành mô hình SwiftData, cách truy vấn dữ liệu và cập nhật chế độ xem trên mọi thay đổi trong lớp mô hình, tạo và lưu mô hình và liên kết các phần tử giao diện người dùng với chúng một cách thuận tiện.

00:02:56.000 --> 00:03:05.000
Và cuối cùng, như một phần thưởng, chúng ta sẽ thấy việc tạo một ứng dụng dựa trên tài liệu dễ dàng như thế nào khi SwiftData đảm nhận việc lưu trữ.

00:03:05.000 --> 00:03:19.000
Trong dự án khởi động, tôi đã xác định một mô hình Thẻ đại diện cho một thẻ flash duy nhất, một số chế độ xem và các tệp hỗ trợ để tiết kiệm thời gian của chúng tôi.

00:03:19.000 --> 00:03:25.000
Mỗi thẻ lưu trữ văn bản cho mặt trước và mặt sau và ngày tạo.

00:03:25.000 --> 00:03:28.000
Nó là một mô hình khá điển hình.

00:03:28.000 --> 00:03:33.000
Hãy cập nhật nó để SwiftData có thể lưu trữ nó cho chúng tôi.

00:03:33.000 --> 00:03:36.000
Đầu tiên, nhập SwiftData vào tệp này.

00:03:36.000 --> 00:03:46.000
Và tiếp theo, thay đổi chính mà chúng ta cần thực hiện là thêm macro @Model vào định nghĩa.

00:03:46.000 --> 00:03:50.000
Và bây giờ, lớp học hoàn toàn có thể tồn tại với SwiftData.

00:03:50.000 --> 00:03:53.000
Không đánh máy nữa. Thế là xong!

00:03:53.000 --> 00:04:02.000
Và thậm chí nhiều hơn: với @Model, Thẻ có được sự phù hợp với giao thức Observable và chúng tôi sẽ sử dụng nó thay vì ObservableObject.

00:04:02.000 --> 00:04:11.000
Loại bỏ sự phù hợp với đối tượng Observable cũng như các trình bao bọc thuộc tính @Published.

00:04:11.000 --> 00:04:21.000
Trước đây chúng tôi đã sử dụng tuân thủ ObservedObject để chỉnh sửa thẻ trực tiếp từ giao diện người dùng trong tệp CardEditorView.

00:04:21.000 --> 00:04:28.000
Để áp dụng Observable ở đây, chúng tôi thay thế trình bao bọc thuộc tính "ObservedObject" bằng "Bindable".

00:04:28.000 --> 00:04:35.000
Nó cho phép các trường văn bản liên kết trực tiếp với mặt trước của thẻ...

00:04:35.000 --> 00:04:37.000
Và văn bản ngược.

00:04:37.000 --> 00:04:39.000
Xong rồi!

00:04:39.000 --> 00:04:49.000
Trình bao bọc thuộc tính Observable macro và Bindable mới cho phép dễ dàng thiết lập luồng dữ liệu trong một ứng dụng với ít mã hơn trước.

00:04:49.000 --> 00:04:58.000
Khi một Chế độ xem sử dụng một thuộc tính thuộc loại Observable trong phần thân của nó, nó sẽ được cập nhật tự động khi thuộc tính đã cho thay đổi.

00:04:58.000 --> 00:05:05.000
Và chưa bao giờ dễ dàng đến thế để liên kết trạng thái có thể thay đổi của mô hình với các phần tử giao diện người dùng!

00:05:05.000 --> 00:05:13.000
Tôi khuyến khích bạn xem phiên WWDC23, "Khám phá Quan sát với SwiftUI."

00:05:13.000 --> 00:05:20.000
Bạn sẽ ngạc nhiên về cách Observable đơn giản hóa mã luồng dữ liệu có hoặc không có SwiftData.

00:05:20.000 --> 00:05:25.000
Và đó là tất cả những gì bạn cần biết về các mô hình.

00:05:25.000 --> 00:05:28.000
Không có gì hơn. Điều đó tuyệt làm sao?

00:05:28.000 --> 00:05:37.000
Tiếp theo, để truy vấn các mô hình từ SwiftData và hiển thị chúng trong giao diện người dùng, hãy chuyển sang ContentView.

00:05:37.000 --> 00:05:48.000
Thay vì SampleDeck.contents, chúng tôi sẽ hiển thị các thẻ mà SwiftData có.

00:05:48.000 --> 00:06:00.000
Và có một thay đổi duy nhất mà tôi cần thực hiện để liên kết mảng thẻ với bộ lưu trữ SwiftData: thay thế trình bao bọc thuộc tính @State bằng @Query.

00:06:00.000 --> 00:06:02.000
Thế là xong!

00:06:02.000 --> 00:06:09.000
Như chúng ta có thể thấy trong bản xem trước, không còn thẻ nào để hiển thị nữa, có lẽ vì chúng tôi chưa lưu bất kỳ thẻ nào.

00:06:09.000 --> 00:06:17.000
Sử dụng @Query bất cứ khi nào bạn muốn hiển thị các mô hình, được quản lý bởi SwiftData, trong giao diện người dùng.

00:06:17.000 --> 00:06:22.000
@Query là một trình bao bọc thuộc tính mới truy vấn các mô hình từ SwiftData.

00:06:22.000 --> 00:06:30.000
Nó cũng kích hoạt chế độ xem được cập nhật trên mọi thay đổi của các mô hình, tương tự như cách @State sẽ làm điều đó.

00:06:30.000 --> 00:06:35.000
Mỗi chế độ xem có thể có bao nhiêu thuộc tính được truy vấn tùy thích.

00:06:35.000 --> 00:06:44.000
Truy vấn cung cấp cú pháp nhẹ để định cấu hình sắp xếp, sắp xếp, lọc và thậm chí tạo hoạt ảnh cho các thay đổi.

00:06:44.000 --> 00:06:50.000
Dưới mui xe, nó sử dụng bối cảnh mô hình của chế độ xem làm nguồn dữ liệu.

00:06:50.000 --> 00:06:53.000
Làm thế nào để chúng tôi cung cấp @Query một bối cảnh mô hình?

00:06:53.000 --> 00:06:57.000
Chúng tôi sẽ lấy một cái từ một thùng chứa mô hình.

00:06:57.000 --> 00:07:04.000
SwiftUI cung cấp một công cụ sửa đổi chế độ xem và cảnh mới để thiết lập thuận tiện ModelContainer của chế độ xem.

00:07:04.000 --> 00:07:10.000
Để sử dụng SwiftData, bất kỳ ứng dụng nào cũng phải thiết lập ít nhất một ModelContainer.

00:07:10.000 --> 00:07:17.000
Nó tạo ra toàn bộ ngăn xếp lưu trữ, bao gồm cả ngữ cảnh mà @Query sẽ sử dụng.

00:07:17.000 --> 00:07:27.000
Một chế độ xem có một vùng chứa mô hình duy nhất, nhưng một ứng dụng có thể tạo và sử dụng bao nhiêu vùng chứa tùy thích cho các hệ thống phân cấp chế độ xem khác nhau.

00:07:27.000 --> 00:07:37.000
Nếu ứng dụng không thiết lập modelContainer của nó, các cửa sổ và chế độ xem mà nó tạo ra không thể lưu hoặc truy vấn các mô hình thông qua SwiftData.

00:07:37.000 --> 00:07:41.000
Nhiều ứng dụng cần một bộ chứa mô hình duy nhất.

00:07:41.000 --> 00:07:45.000
Trong trường hợp này, bạn có thể thiết lập nó cho toàn bộ cảnh nhóm cửa sổ.

00:07:45.000 --> 00:07:53.000
Cửa sổ và chế độ xem của nó sẽ kế thừa vùng chứa, cũng như bất kỳ cửa sổ nào khác được tạo từ cùng một nhóm.

00:07:53.000 --> 00:07:59.000
Tất cả các chế độ xem này sẽ được viết và đọc từ một vùng chứa duy nhất.

00:07:59.000 --> 00:08:06.000
Một số ứng dụng cần một vài ngăn xếp lưu trữ và chúng có thể thiết lập một số vùng chứa mô hình cho các cửa sổ khác nhau.

00:08:06.000 --> 00:08:11.000
SwiftUI cũng cho phép thiết lập chi tiết ở cấp độ xem.

00:08:11.000 --> 00:08:19.000
Các chế độ xem khác nhau trong cùng một cửa sổ có thể có các vùng chứa riêng biệt và việc lưu trong một vùng chứa sẽ không ảnh hưởng đến vùng chứa khác.

00:08:19.000 --> 00:08:24.000
Bây giờ, hãy thiết lập modelContainer để cung cấp Truy vấn một nguồn dữ liệu.

00:08:24.000 --> 00:08:33.000
Tôi mở định nghĩa ứng dụng...

00:08:33.000 --> 00:08:37.000
Và thiết lập một vùng chứa mô hình cho các cửa sổ của ứng dụng.

00:08:37.000 --> 00:08:47.000
Lưu ý rằng các chế độ xem phụ chỉ có thể tạo, đọc, cập nhật và xóa các loại mô hình được liệt kê trong công cụ sửa đổi chế độ xem.

00:08:47.000 --> 00:08:50.000
Và chúng tôi đã hoàn thành việc thiết lập!

00:08:50.000 --> 00:08:56.000
Mặc dù vậy, tôi muốn thực hiện thêm một bước nữa: cung cấp các bản xem trước của tôi với dữ liệu mẫu.

00:08:56.000 --> 00:09:01.000
Trong ứng dụng, tôi đã xác định một thùng chứa trong bộ nhớ với các thẻ mẫu.

00:09:01.000 --> 00:09:08.000
Hãy mở tệp "PreviewSampleData" và đưa nó vào mục tiêu.

00:09:08.000 --> 00:09:12.000
Tệp này chứa định nghĩa của một vùng chứa với dữ liệu mẫu.

00:09:12.000 --> 00:09:18.000
Tôi sẽ sử dụng nó trong ContentView để điền vào bản xem trước của mình bằng các thẻ mẫu.

00:09:18.000 --> 00:09:33.000
Bây giờ @Query có nguồn dữ liệu, bản xem trước sẽ hiển thị các thẻ!

00:09:33.000 --> 00:09:41.000
Và đây là tất cả các thiết lập được yêu cầu để sẵn sàng ngăn xếp SwiftData và tạo bản xem trước.

00:09:41.000 --> 00:09:50.000
Tiếp theo, tôi muốn đảm bảo rằng SwiftData theo dõi và lưu các thẻ mới mà tôi tạo, cũng như các thay đổi được thực hiện đối với các thẻ hiện có.

00:09:50.000 --> 00:09:55.000
Để làm điều đó, tôi sẽ sử dụng bối cảnh mô hình của chế độ xem.

00:09:55.000 --> 00:10:01.000
Để truy cập bối cảnh mô hình, SwiftUI cung cấp một biến môi trường mới.

00:10:01.000 --> 00:10:11.000
Tương tự như vùng chứa mô hình, mỗi chế độ xem có một ngữ cảnh duy nhất, nhưng một ứng dụng, nói chung, có thể có bao nhiêu tùy thích.

00:10:11.000 --> 00:10:14.000
Trong ứng dụng của chúng tôi, ngữ cảnh đã được định cấu hình.

00:10:14.000 --> 00:10:21.000
Biến môi trường này được điền tự động khi chúng tôi đặt vùng chứa mô hình trước đó.

00:10:21.000 --> 00:10:24.000
Hãy chuyển trở lại Xcode.

00:10:24.000 --> 00:10:33.000
Chúng tôi sẽ cần truy cập modelContext để lưu và cập nhật các thẻ.

00:10:33.000 --> 00:11:03.000
Chúng tôi chèn thẻ mới được tạo vào ngữ cảnh mô hình để SwiftData nhận thức được mô hình mà chúng tôi muốn lưu trữ.

00:11:03.000 --> 00:11:13.000
Bạn có thể nghĩ rằng sau khi chèn mô hình, bạn cần lưu ngữ cảnh, gọi "modelContext.save()," nhưng bạn không cần phải làm điều đó.

00:11:13.000 --> 00:11:19.000
Một chi tiết hay về SwiftData là nó tự động lưu bối cảnh mô hình.

00:11:19.000 --> 00:11:24.000
Việc lưu tự động được kích hoạt bởi các sự kiện liên quan đến giao diện người dùng và đầu vào của người dùng.

00:11:24.000 --> 00:11:29.000
Chúng tôi không cần phải lo lắng về việc tiết kiệm vì SwiftData làm điều đó cho chúng tôi.

00:11:29.000 --> 00:11:40.000
Chỉ có một vài trường hợp khi bạn muốn đảm bảo rằng tất cả các thay đổi được duy trì ngay lập tức, ví dụ, trước khi chia sẻ bộ nhớ SwiftData hoặc gửi nó qua.

00:11:40.000 --> 00:11:44.000
Trong những trường hợp này, hãy gọi "lưu()" một cách rõ ràng.

00:11:44.000 --> 00:11:50.000
Bây giờ ứng dụng của chúng tôi có thể lưu và truy vấn các thẻ, hãy tạo một thẻ!

00:11:50.000 --> 00:11:53.000
Tôi chạy ứng dụng...

00:11:53.000 --> 00:11:58.000
Và nhấn nút dấu cộng để tạo một thẻ.

00:11:58.000 --> 00:12:04.000
Hãy thêm thẻ Trình biên dịch mà chúng ta đã thấy trước đây.

00:12:04.000 --> 00:12:19.000
Bây giờ, hãy thoát khỏi ứng dụng, khởi chạy lại và xem thẻ mới của chúng ta có ở đó không.

00:12:19.000 --> 00:12:21.000
Và nó đây rồi!

00:12:21.000 --> 00:12:26.000
Bây giờ bạn đã biết cách truy cập bối cảnh mô hình của chế độ xem và thêm thẻ.

00:12:26.000 --> 00:12:28.000
Xong rồi!

00:12:28.000 --> 00:12:31.000
Hãy mở một cửa sổ mới.

00:12:31.000 --> 00:12:41.000
Nó hiển thị cùng một bộ bài như bộ đầu tiên, điều này có ý nghĩa, vì cả hai cửa sổ đều sử dụng cùng một vùng chứa mô hình và truy cập cùng một dữ liệu.

00:12:41.000 --> 00:12:48.000
Tuy nhiên, sẽ thật tuyệt nếu ứng dụng có thể mở các bộ thẻ flash khác nhau trong các cửa sổ khác nhau.

00:12:48.000 --> 00:12:53.000
Về cơ bản, nó có nghĩa là tôi muốn coi mỗi bộ bài như một tài liệu riêng biệt.

00:12:53.000 --> 00:12:56.000
Sau đó, tôi có thể chia sẻ những tài liệu này với bạn bè.

00:12:56.000 --> 00:13:03.000
Các ứng dụng dựa trên tài liệu là một khái niệm được sử dụng trên macOS, iOS và iPadOS.

00:13:03.000 --> 00:13:12.000
Nó mô tả các loại ứng dụng nhất định cho phép người dùng tạo, mở, xem hoặc chỉnh sửa các loại tài liệu khác nhau.

00:13:12.000 --> 00:13:18.000
Mỗi tài liệu là một tệp và người dùng có thể lưu trữ, sao chép và chia sẻ chúng.

00:13:18.000 --> 00:13:26.000
Và tôi rất vui được cho bạn biết rằng SwiftUI hỗ trợ các ứng dụng tài liệu được hỗ trợ bởi SwiftData.

00:13:26.000 --> 00:13:28.000
Hãy thử cách tiếp cận này.

00:13:28.000 --> 00:13:32.000
Tôi mở tệp FlashCardApp.

00:13:32.000 --> 00:13:45.000
Các ứng dụng dựa trên tài liệu tồn tại trên iOS và macOS, và trên các nền tảng này, chúng tôi sẽ chuyển sang sử dụng trình khởi tạo DocumentGroup.

00:13:45.000 --> 00:14:13.000
Tôi sẽ chuyển loại mô hình Card.self, loại nội dung và trình tạo chế độ xem.

00:14:13.000 --> 00:14:20.000
Hãy đi đường vòng ngắn và nói về tham số thứ hai, loại nội dung, chi tiết hơn!

00:14:20.000 --> 00:14:25.000
Các ứng dụng dựa trên Tài liệu SwiftData cần khai báo các loại nội dung tùy chỉnh.

00:14:25.000 --> 00:14:32.000
Mỗi tài liệu SwiftData được xây dựng từ một tập hợp các mô hình duy nhất và do đó có một biểu diễn duy nhất trên đĩa.

00:14:32.000 --> 00:14:40.000
Trong bối cảnh của các tài liệu, bạn có thể nghĩ về một loại nội dung như một định dạng tệp nhị phân, như JPEG.

00:14:40.000 --> 00:14:48.000
Một loại tài liệu khác, một gói, là một thư mục có cấu trúc cố định trên đĩa, giống như một dự án Xcode.

00:14:48.000 --> 00:14:53.000
Ví dụ, tất cả các hình ảnh JPEG đều có cùng cấu trúc nhị phân.

00:14:53.000 --> 00:14:57.000
Nếu không, các biên tập viên ảnh sẽ không biết cách đọc chúng.

00:14:57.000 --> 00:15:03.000
Tương tự, tất cả các dự án Xcode đều chứa các thư mục và tệp nhất định.

00:15:03.000 --> 00:15:12.000
Khi người dùng mở bộ bài, chúng tôi cần hệ điều hành để liên kết định dạng bộ bài và phần mở rộng tệp với ứng dụng của chúng tôi.

00:15:12.000 --> 00:15:16.000
Đó là lý do tại sao chúng ta cần khai báo loại nội dung.

00:15:16.000 --> 00:15:29.000
Tài liệu SwiftData là các gói: nếu bạn đánh dấu một số thuộc tính của mô hình SwiftData bằng thuộc tính "externalStorage", tất cả các mục được lưu trữ bên ngoài sẽ là một phần của gói tài liệu.

00:15:29.000 --> 00:15:39.000
Trong tệp UTType+FlashCards, tôi có định nghĩa về loại nội dung mới, vì vậy chúng tôi có thể sử dụng nó một cách thuận tiện trong mã.

00:15:39.000 --> 00:15:52.000
Chúng tôi sẽ đưa định nghĩa tương tự vào Info.plist.

00:15:52.000 --> 00:15:57.000
Chúng tôi sắp khai báo một loại nội dung mới trong hệ điều hành.

00:15:57.000 --> 00:16:05.000
Chúng tôi cần chỉ định phần mở rộng tệp để giúp phân biệt các bộ bài do ứng dụng của chúng tôi tạo ra với bất kỳ tài liệu nào khác.

00:16:05.000 --> 00:16:13.000
Đối với ứng dụng mẫu này, chúng tôi sẽ sử dụng "sampledeck" làm tiện ích mở rộng.

00:16:13.000 --> 00:16:24.000
Tôi cũng sẽ thêm một mô tả ngắn, như Flash Cards Deck.

00:16:24.000 --> 00:16:33.000
Mã định danh phải giống hệt với mã trong mã.

00:16:33.000 --> 00:16:46.000
Bởi vì tài liệu SwiftData là các gói, chúng tôi phải đảm bảo loại của chúng tôi phù hợp với com.apple.package.

00:16:46.000 --> 00:16:51.000
Và bây giờ, hãy sử dụng loại nội dung mà chúng tôi đã khai báo.

00:16:51.000 --> 00:16:59.000
Tôi đang quay lại định nghĩa ứng dụng và chuyển loại nội dung cho DocumentGroup.

00:16:59.000 --> 00:17:06.000
Trình tạo chế độ xem trông giống hệt nhau.

00:17:06.000 --> 00:17:10.000
Đáng chú ý, chúng tôi không thiết lập thùng chứa mô hình.

00:17:10.000 --> 00:17:16.000
Cơ sở hạ tầng tài liệu sẽ thiết lập một cho mỗi tài liệu.

00:17:16.000 --> 00:17:23.000
Hãy chạy ứng dụng và xem nó trông như thế nào ngay bây giờ!

00:17:23.000 --> 00:17:27.000
Ứng dụng khởi chạy với bảng điều khiển mở.

00:17:27.000 --> 00:17:31.000
Hành vi tiêu chuẩn cho các ứng dụng dựa trên Tài liệu.

00:17:31.000 --> 00:17:38.000
Tôi sẽ tạo một tài liệu mới và thêm một thẻ ở đó.

00:17:38.000 --> 00:17:44.000
Tài liệu hiện có phụ đề thanh công cụ cho biết rằng nó có những thay đổi chưa được lưu.

00:17:44.000 --> 00:17:50.000
Tôi nhấn Command+S, và hộp thoại lưu xuất hiện.

00:17:50.000 --> 00:17:57.000
Lưu ý rằng bộ bài sẽ được lưu với cùng phần mở rộng tệp mà chúng tôi đã đưa vào Info.plist trước đó.

00:17:57.000 --> 00:18:06.000
Tôi sẽ lưu bộ bài mới, và đây rồi, bộ bài flashcards đầu tiên của tôi, trên Máy tính để bàn.

00:18:06.000 --> 00:18:14.000
Tôi cũng có thể nhấn Command+N để tạo một bộ bài mới, hoặc Command+O để mở một bộ bài.

00:18:14.000 --> 00:18:22.000
Các phím tắt này, cũng như nhiều tính năng khác, các ứng dụng dựa trên Tài liệu sẽ tự động nhận được.

00:18:22.000 --> 00:18:28.000
Tóm lại, hôm nay, chúng ta đã học cách sử dụng lưu trữ SwiftData trong các ứng dụng SwiftUI.

00:18:28.000 --> 00:18:42.000
Chúng tôi đã nói về macro @Model mới, trình bao bọc thuộc tính @Query và biến Môi trường mới cho ngữ cảnh mô hình và thấy việc sử dụng SwiftData làm bộ lưu trữ cho tài liệu của bạn dễ dàng như thế nào.

00:18:42.000 --> 00:18:46.000
Cảm ơn vì đã tham gia cùng tôi hôm nay, và vui vẻ xây dựng các ứng dụng!

00:18:46.000 --> 23:59:59.000
♪ ♪

