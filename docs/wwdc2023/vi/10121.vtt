WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:14.000
Jen: Xin chào, tôi là Jen Simmons, một nhà truyền giáo Safari và WebKit ở đây tại Apple.

00:00:14.000 --> 00:00:16.000
Đó là một năm tuyệt vời cho WebKit.

00:00:16.000 --> 00:00:28.000
Chúng tôi đã vận chuyển hơn 140 công nghệ web mới trong nhiều bản phát hành của Safari trong suốt năm nay và chúng tôi có thêm vài chục công nghệ web mới vào mùa thu này.

00:00:28.000 --> 00:00:35.000
Có quá nhiều, không có cách nào chúng tôi có thể bao quát tất cả, vì vậy chúng tôi quyết định tập trung vào CSS.

00:00:35.000 --> 00:01:01.000
Trong phiên này, chúng ta sẽ xem xét một số tính năng mới thú vị nhất trong CSS, bao gồm các khả năng hoàn toàn mới với bố cục, cả thế hệ công cụ màu sắc tận dụng tối đa các màn hình tuyệt vời ngày nay, những cách hiệu quả để giải quyết các vấn đề khó khăn với các lớp giả mới và CSS cho phép bạn đưa kiểu chữ của mình lên một

00:01:01.000 --> 00:01:10.000
Tôi sẽ chia sẻ những thứ đã được vận chuyển, những thứ sẽ được vận chuyển trong Safari 17 và những thứ chúng tôi đang làm cho tương lai.

00:01:10.000 --> 00:01:15.000
Để thấy tương lai hôm nay, hãy tải xuống Bản xem trước Công nghệ Safari.

00:01:15.000 --> 00:01:18.000
Ở đó bạn sẽ tìm thấy Bố cục Masonry.

00:01:18.000 --> 00:01:22.000
Trong nhiều năm, đây là một mẫu bố cục phổ biến trên web.

00:01:22.000 --> 00:01:25.000
Đó là một cách tuyệt vời để đóng gói nội dung có kích cỡ khác nhau.

00:01:25.000 --> 00:01:43.000
Bạn có thể hoàn thành bố cục với hình dạng này bằng cách sử dụng CSS Multicolumn, nếu không sao thì thứ tự nội dung bắt đầu ở cột đầu tiên, chảy xuống bên dưới khung nhìn, quay trở lại đầu cột thứ hai, chảy xuống nó, sau đó chuyển sang cột thứ ba, v.v.

00:01:43.000 --> 00:01:45.000
Nếu điều này phù hợp với dự án của bạn, thật tuyệt.

00:01:45.000 --> 00:01:49.000
CSS Multicolumn là một cơ chế bố cục đã có trong các trình duyệt trong nhiều thập kỷ.

00:01:49.000 --> 00:01:52.000
Nhưng thường thì điều này không hiệu quả.

00:01:52.000 --> 00:02:02.000
Thay vào đó, các nhà thiết kế muốn nội dung của họ chảy qua trang, đặt từng mục vào bất kỳ cột nào đặt nó càng gần đầu càng tốt.

00:02:02.000 --> 00:02:08.000
Điều này đặc biệt cần thiết khi nhiều nội dung được tải ở phía dưới khi người dùng cuộn.

00:02:08.000 --> 00:02:12.000
Vì vậy, các trang web đã phải sử dụng JavaScript để thực hiện điều này.

00:02:12.000 --> 00:02:17.000
Nhưng JavaScript ở bố cục chậm hơn CSS, và nó dễ vỡ hơn.

00:02:17.000 --> 00:02:19.000
Viết mã khó hơn.

00:02:19.000 --> 00:02:23.000
Bố cục thực sự thuộc về CSS.

00:02:23.000 --> 00:02:31.000
Một đề xuất tạo Masonry như một phần của CSS Grid đã được bắt đầu vài năm trước và được triển khai trong Firefox như một thử nghiệm đằng sau một lá cờ.

00:02:31.000 --> 00:02:43.000
Chúng tôi tin tưởng vào ý tưởng này và chúng tôi muốn thấy nó xuất hiện trên web, vì vậy bây giờ nó có trong Bản xem trước công nghệ Safari - theo mặc định - nơi bạn có thể dùng thử, cho chúng tôi biết suy nghĩ của bạn và giúp chúng tôi tiến lên phía trước.

00:02:43.000 --> 00:02:44.000
Đây là một ví dụ.

00:02:44.000 --> 00:02:49.000
Tôi đã tạo bố cục Masonry điển hình này với rất ít CSS.

00:02:49.000 --> 00:03:00.000
Hiển thị: lưới giúp chúng ta bắt đầu và các cột mẫu lưới cung cấp cho chúng ta các cột linh hoạt tự động tăng số lượng khi có nhiều không gian hơn.

00:03:00.000 --> 00:03:09.000
Sau đó, grid-template-rows: masonry đóng gói các mục thành một mẫu Masonry theo hướng hàng chỉ với một dòng mã.

00:03:09.000 --> 00:03:12.000
Làm cho phần này của CSS Grid mang lại cho chúng ta sự linh hoạt to lớn.

00:03:12.000 --> 00:03:33.000
Bạn có thể định nghĩa Masonry trong một chiều và sử dụng sức mạnh của Grid để làm bất cứ điều gì bạn muốn ở chiều khác, như làm cho các cột có kích thước khác nhau với các đơn vị fr hoặc làm cho cột đầu tiên có chiều rộng cố định, trong khi phần giữa linh hoạt bằng cách sử dụng đơn vị fr và cột thứ ba được làm linh hoạt với giá trị

00:03:33.000 --> 00:03:39.000
Kết hợp Masonry với Grid tạo ra một cơ chế mạnh hơn nhiều so với thư viện JavaScript phổ biến.

00:03:39.000 --> 00:03:41.000
Đây vẫn là một công việc đang được tiến hành.

00:03:41.000 --> 00:03:51.000
Cần thảo luận thêm trong Nhóm làm việc CSS, nơi các nhà sản xuất trình duyệt và những người khác cùng nhau đồng ý về con đường phía trước, bao gồm cả công việc để đảm bảo rằng nó hoàn toàn có thể truy cập được.

00:03:51.000 --> 00:03:55.000
Chúng tôi mong muốn được vận chuyển Masonry trong Safari khi nó đã sẵn sàng.

00:03:55.000 --> 00:03:58.000
Cái gì đã sẵn sàng để được vận chuyển trong các trình duyệt ngày hôm nay?

00:03:58.000 --> 00:03:59.000
Cắt lề.

00:03:59.000 --> 00:04:06.000
Thuộc tính margin-trim mới giúp dễ dàng loại bỏ lề khỏi các phần tử đẩy lên chống lại vùng chứa của chúng.

00:04:06.000 --> 00:04:08.000
Để tôi giải thích.

00:04:08.000 --> 00:04:12.000
Hãy tưởng tượng chúng ta có một tiêu đề và ba đoạn văn.

00:04:12.000 --> 00:04:20.000
Tất cả chúng đều có lề trên và lề dưới, cung cấp không gian giữa chúng, cũng như không gian bên trên và dưới toàn bộ nhóm.

00:04:20.000 --> 00:04:26.000
Ngoài ra còn có phần đệm được áp dụng cho vùng chứa, phần tử bài viết với một lớp thẻ.

00:04:26.000 --> 00:04:38.000
Lề phía trên tiêu đề và phần đệm trên cùng trên vùng chứa được cộng lại với nhau để xác định có bao nhiêu khoảng trống giữa cạnh trên của hộp và dòng văn bản đầu tiên đó.

00:04:38.000 --> 00:04:40.000
Tương tự ở phía dưới.

00:04:40.000 --> 00:04:50.000
Lề bên dưới đoạn cuối cùng được thêm vào phần đệm dưới cùng trên vùng chứa, có thể thêm nhiều khoảng trắng hơn dự định.

00:04:50.000 --> 00:04:58.000
Thay vào đó, những gì chúng tôi muốn là chỉ có phần đệm ở trên và dưới và không có bất kỳ lề nào liên quan.

00:04:58.000 --> 00:05:01.000
Điều này sẽ cho chúng ta nhiều không gian đồng đều hơn xung quanh chiếc hộp.

00:05:01.000 --> 00:05:06.000
Những gì chúng ta cần là một cách để loại bỏ bất kỳ lợi nhuận nào đẩy lên thùng chứa.

00:05:06.000 --> 00:05:18.000
Có lẽ bạn đã cố gắng xử lý điều này bằng cách loại bỏ thủ công lề trên cùng khỏi tiêu đề và lề dưới cùng khỏi đoạn cuối và, tốt, hy vọng điều tốt nhất.

00:05:18.000 --> 00:05:20.000
Nhưng sau đó nội dung bất ngờ xuất hiện.

00:05:20.000 --> 00:05:29.000
Có thể một ví dụ khác bắt đầu bằng h3 và không ai viết mã đó, hoặc ai đó dán h2 ở giữa và nó thiếu lề trên cùng của nó.

00:05:29.000 --> 00:05:31.000
Cắt lề cho chúng ta một giải pháp tốt hơn.

00:05:31.000 --> 00:05:39.000
Thay vào đó, bạn có thể yêu cầu chính xác những gì bạn muốn bằng cách áp dụng margin-trim: block cho vùng chứa.

00:05:39.000 --> 00:05:43.000
Chúng tôi đã thêm hỗ trợ cho margin-trim trong Safari 16.4.

00:05:43.000 --> 00:05:47.000
Bạn cũng có thể sử dụng margin-trim: inline để cắt lề theo hướng nội tuyến.

00:05:47.000 --> 00:05:49.000
Đó là cắt lề.

00:05:49.000 --> 00:05:53.000
Nó chỉ đơn giản là giải quyết một nhu cầu chung một cách mạnh mẽ hơn.

00:05:53.000 --> 00:06:00.000
CSS cho bố cục đã thực sự trưởng thành trong sáu năm qua kể từ khi CSS Grid ra đời vào tháng 3 năm 2017.

00:06:00.000 --> 00:06:04.000
Bố cục ngày nay là một cải tiến triệt để so với những gì chúng tôi đã làm một thập kỷ trước.

00:06:04.000 --> 00:06:16.000
Trong cùng một khoảng thời gian, đã có một bước nhảy vọt triệt để khác mà các nhà thiết kế và phát triển web không được chú ý một chút: một bước nhảy vọt về màu sắc.

00:06:16.000 --> 00:06:20.000
Thế giới đầy màu sắc, đặc biệt là bên ngoài.

00:06:20.000 --> 00:06:25.000
Dải động, độ bão hòa, tất cả các sắc thái và khả năng.

00:06:25.000 --> 00:06:32.000
Hãy tưởng tượng sơ đồ này đại diện cho mọi màu sắc mà mắt người có thể nhìn thấy.

00:06:32.000 --> 00:06:41.000
Một dòng xung quanh một tập hợp con của các màu này cho thấy những gì có thể được thể hiện trong sRGB, gam màu mặc định trên web, đã phục vụ tốt cho chúng ta.

00:06:41.000 --> 00:06:51.000
Nó chắc chắn tốt hơn những gì chúng tôi đã sử dụng vào những năm 90, nhưng sẽ thật tuyệt nếu vượt qua những hạn chế của sRGB và truyền tải nhiều phổ hình ảnh hơn.

00:06:51.000 --> 00:06:54.000
Màu P3 làm được điều đó.

00:06:54.000 --> 00:07:06.000
Apple bắt đầu hỗ trợ màn hình P3 gam rộng trên phần cứng và phần mềm của chúng tôi hơn bảy năm trước, đầu tiên trên iMac vào cuối năm 2015, sau đó là iPad và iPhone, bắt đầu với iPhone 7.

00:07:06.000 --> 00:07:13.000
Gam màu P3 có khả năng hiển thị nhiều màu hơn 50% so với sRGB.

00:07:13.000 --> 00:07:15.000
Màn hình hiển thị trên các thiết bị hiện đại thật tuyệt vời.

00:07:15.000 --> 00:07:21.000
Tất cả những thứ này đều hỗ trợ gam màu rộng P3 với màu sáng hơn và độ bão hòa sâu hơn.

00:07:21.000 --> 00:07:26.000
Và đã quá lâu rồi để thiết kế web tận dụng tối đa.

00:07:26.000 --> 00:07:37.000
Có một truy vấn phương tiện trong CSS để kiểm tra hỗ trợ gam màu, khi bạn cần một cách để chỉ định CSS có điều kiện, tùy thuộc vào những gì phần cứng và phần mềm của người dùng có thể làm.

00:07:37.000 --> 00:07:44.000
Chúng tôi đã vận chuyển hỗ trợ cho Color Gamut Media Query vào năm 2016, trong Safari 10.0.

00:07:44.000 --> 00:07:57.000
Khi nói đến việc chọn một màu, tất nhiên, có nhiều cách để làm điều đó; màu được đặt tên, giá trị thập lục phân, hàm RGB, có màu đỏ, xanh lá cây và xanh dương.

00:07:57.000 --> 00:08:05.000
HSL, cho màu sắc, độ bão hòa và độ sáng, và HWB, với màu sắc, độ trắng và độ đen của nó.

00:08:05.000 --> 00:08:10.000
Tất cả những cách mô hình hóa màu sắc này đều có khả năng tạo ra cùng một kết quả.

00:08:10.000 --> 00:08:14.000
Tất cả các mô hình này đều bị giới hạn trong gam màu sRGB.

00:08:14.000 --> 00:08:21.000
Không thể đại diện cho các màu chỉ tồn tại trong P3 nếu bạn sử dụng các mô hình màu này.

00:08:21.000 --> 00:08:26.000
Do đó, có bốn cái mới hiện được xác định trong CSS.

00:08:26.000 --> 00:08:30.000
LCH, OKLCH, LAB, và OKLAB.

00:08:30.000 --> 00:08:38.000
Các mô hình này có thể đại diện cho màu sắc trong bất kỳ gam màu nào, bao gồm Display P3 hoặc bất kỳ gam màu nào khác có thể xuất hiện trên web trong tương lai.

00:08:38.000 --> 00:08:41.000
Chúng được định nghĩa với ba giá trị mỗi giá trị.

00:08:41.000 --> 00:08:57.000
Trong cả bốn, "L" đại diện cho Lightness LCH và OKLCH cũng lấy các giá trị cho Chroma, hoặc mức độ mãnh liệt của màu đó, và đối với Hue, hoặc vị trí của nó trên quang phổ màu.

00:08:57.000 --> 00:09:12.000
LAB và OKLAB khai báo một giá trị dọc theo trục A --- hoặc trong đó màu dọc theo trục chạy từ xanh lá cây đến đỏ --- và trục B - hoặc nó có màu xanh lam đến vàng như thế nào.

00:09:12.000 --> 00:09:19.000
Bạn có thể tạo màu với LCH, OKLCH, LAB và OKLAB bằng cách sử dụng các chức năng mới cho mỗi chức năng.

00:09:19.000 --> 00:09:29.000
Nếu một trình duyệt đã thêm hỗ trợ cho P3, thì các chức năng này có thể đại diện cho các màu chỉ tồn tại trong P3 cũng như các màu trong sRGB.

00:09:29.000 --> 00:09:34.000
Chúng tôi đã vận chuyển hỗ trợ cho các chức năng này trong Safari 15.0 và 15.4.

00:09:34.000 --> 00:09:40.000
Chrome, Edge và Firefox đang bổ sung hỗ trợ trong năm nay, nhờ vào dự án Interop 2023.

00:09:40.000 --> 00:09:47.000
Bạn cũng có thể xác định một màu với hàm color() và chỉ định gam màu nào sẽ sử dụng.

00:09:47.000 --> 00:09:54.000
Hàm màu nhận các giá trị bằng đỏ, xanh lá cây và xanh dương, cộng với alpha, sau một dấu gạch chéo.

00:09:54.000 --> 00:10:01.000
Nhưng màu nào 100% màu xanh lá cây tạo ra, ví dụ, phụ thuộc vào gam màu.

00:10:01.000 --> 00:10:10.000
Lần đầu tiên chúng tôi vận chuyển khả năng tạo màu P3 trong CSS thông qua việc sử dụng chức năng màu này trong Safari 10.1, hơn sáu năm trước.

00:10:10.000 --> 00:10:18.000
Với sự ra đời của các gam màu và mô hình màu này, Nhóm làm việc CSS đã xác định các công cụ bổ sung tận dụng sức mạnh của chúng.

00:10:18.000 --> 00:10:23.000
Các tiêu chuẩn web của họ cuối cùng đã đủ trưởng thành để chúng tôi vận chuyển các công cụ này trong năm nay.

00:10:23.000 --> 00:10:28.000
Bạn đã bao giờ muốn xác định một màu trong CSS, trong khi đề cập đến một màu khác chưa?

00:10:28.000 --> 00:10:32.000
Có thể làm những việc tương tự trong bộ tiền xử lý trong một thời gian.

00:10:32.000 --> 00:10:36.000
Bây giờ, cú pháp màu tương đối cho phép bạn làm điều đó.

00:10:36.000 --> 00:10:42.000
Cũng giống như nhiều cách để xác định màu sắc, bạn bắt đầu với một trong các hàm màu.

00:10:42.000 --> 00:10:50.000
Điều này xác định mô hình màu nào được sử dụng để thực hiện các phép tính toán học liên quan đến việc tạo ra màu mới.

00:10:50.000 --> 00:10:55.000
Tiếp theo, nêu rõ màu hiện có mà bạn muốn bắt đầu.

00:10:55.000 --> 00:11:00.000
Sau đó lấy các kênh từ chức năng và thao tác chúng.

00:11:00.000 --> 00:11:11.000
Trong ví dụ đầu tiên, các kênh R, G và B được để yên, trong khi / 0.7 yêu cầu trình duyệt cung cấp cho màu này độ mờ là 70%.

00:11:11.000 --> 00:11:25.000
Trong ví dụ thứ hai trong LAB, tôi đã yêu cầu trình duyệt tính L chia cho 2, điều này cắt giảm độ sáng làm đôi và làm cho màu tối hơn, trong khi chỉ để các kênh A và B.

00:11:25.000 --> 00:11:37.000
Và trong ví dụ thứ ba, trong OKLCH, tôi sẽ để các kênh L và H một mình, trong khi cắt C, sắc độ, một phần ba, làm cạn kiệt cường độ ra khỏi màu sắc.

00:11:37.000 --> 00:11:46.000
Cú pháp màu tương đối giúp xác định toàn bộ bảng màu nhanh chóng, tiện dụng khi tạo hệ thống thiết kế.

00:11:46.000 --> 00:11:50.000
Các mô hình màu mới cũng cải thiện cách chúng ta có thể xác định độ dốc.

00:11:50.000 --> 00:11:55.000
Đây là một gradient tuyến tính đơn giản chuyển từ trắng sang xanh lam.

00:11:55.000 --> 00:12:01.000
Trong nhiều năm, các loại gradient này luôn được tính toán bằng cách sử dụng không gian màu sRGB.

00:12:01.000 --> 00:12:09.000
Bây giờ, bắt đầu từ Safari 16.2, chúng ta có thể nói rõ ràng rằng chúng ta muốn gradient được tính toán trong sRGB, nếu đó là những gì chúng ta muốn.

00:12:09.000 --> 00:12:12.000
Hoặc chúng ta có thể thay đổi không gian màu sắc.

00:12:12.000 --> 00:12:21.000
sRGB-linear tương tự như sRGB, nhưng làm mịn quá trình chuyển đổi giữa các màu theo kiểu tuyến tính hơn.

00:12:21.000 --> 00:12:26.000
Nhưng bạn có thể nhận thấy rằng cả hai điều này đều chuyển đổi qua tông màu tím.

00:12:26.000 --> 00:12:34.000
Nếu chúng ta chuyển sang OKLAB, các màu được tính toán ở giữa sẽ có nhiều màu xanh lam hơn và có lẽ đó là những gì chúng ta muốn.

00:12:34.000 --> 00:12:39.000
LCH tình cờ tạo ra kết quả tương tự, mặc dù không giống nhau.

00:12:39.000 --> 00:12:44.000
OKLCH chuyển đổi qua quang phổ màu vàng, xanh lá cây và xanh mòng két.

00:12:44.000 --> 00:12:48.000
LAB tình cờ có màu tím hơn nhiều.

00:12:48.000 --> 00:12:53.000
Hoặc chúng ta có thể sử dụng HSL hoặc HWB nếu chúng ta thích những kết quả này.

00:12:53.000 --> 00:12:57.000
Nó thực sự phụ thuộc vào dự án và hiệu ứng thiết kế mà chúng tôi muốn.

00:12:57.000 --> 00:13:02.000
Không ai trong số này là đúng hay sai. Không ai trong số họ là tốt nhất.

00:13:02.000 --> 00:13:04.000
Nó phụ thuộc.

00:13:04.000 --> 00:13:06.000
Có rất nhiều lựa chọn mới để xác định độ dốc.

00:13:06.000 --> 00:13:09.000
Chuyển đổi không gian màu có tác động rất lớn.

00:13:09.000 --> 00:13:12.000
Điều này cũng áp dụng cho những thay đổi về màu sắc.

00:13:12.000 --> 00:13:16.000
Không gian màu ảnh hưởng đến phép nội suy của những gì xảy ra ở giữa.

00:13:16.000 --> 00:13:19.000
Tác động tương tự cũng được áp dụng khi trộn các màu với nhau.

00:13:19.000 --> 00:13:23.000
Vâng, bây giờ bạn có thể trộn màu sắc trong CSS.

00:13:23.000 --> 00:13:27.000
Bắt đầu từ Safari 16.2, có một chức năng trộn màu mới.

00:13:27.000 --> 00:13:35.000
Bạn liệt kê hai màu để trộn và chỉ định không gian màu nào sẽ sử dụng, và trình duyệt kết hợp chúng lại với nhau.

00:13:35.000 --> 00:13:40.000
Bạn có thể nhận ra màu xanh tía này từ giữa gradient.

00:13:40.000 --> 00:13:45.000
Thay vào đó, chúng ta có thể chuyển sang bất kỳ không gian màu nào khác mà chúng ta đã xem xét để sử dụng với gradient.

00:13:45.000 --> 00:13:50.000
Tất cả những điều này tạo ra những kết quả khác nhau.

00:13:50.000 --> 00:13:57.000
Theo mặc định, sự pha trộn màu sắc tạo ra màu mới từ 50% màu này và 50% màu kia.

00:13:57.000 --> 00:14:03.000
Nhưng bạn có thể thay đổi nó thành bất kỳ tỷ lệ nào bạn muốn, 80/20 hoặc 30/70.

00:14:03.000 --> 00:14:09.000
Bạn cũng có thể đặt hai số thành tổng cộng nhỏ hơn 100%, điều này làm cho màu sắc trong mờ.

00:14:09.000 --> 00:14:18.000
Ở đây, tôi đã đặt màu trắng thành 30% và màu xanh lam thành 30%, tạo cho màu kết quả độ mờ đục là 60%.

00:14:18.000 --> 00:14:24.000
Bạn thậm chí có thể sử dụng từ khóa currentcolor để trộn màu văn bản hiện tại với bất cứ thứ gì bạn muốn.

00:14:24.000 --> 00:14:32.000
Trong trường hợp này, tôi đang trộn màu liên kết xanh đậm với 40% màu trắng để tạo ra màu xanh lục nhạt hơn để sử dụng với màu di chuột.

00:14:32.000 --> 00:14:34.000
Có rất nhiều thứ ở đây.

00:14:34.000 --> 00:14:55.000
Gam màu P3, các mô hình và chức năng màu mới, khả năng thay đổi không gian màu cho độ dốc và hoạt ảnh, những cách mới để xác định màu sắc bằng cách thay đổi các kênh của màu hiện có hoặc thông qua pha trộn - có rất nhiều tiềm năng ở đây khi nói đến việc tận dụng màu sắc trong các thiết kế của chúng tôi cho web.

00:14:55.000 --> 00:14:58.000
Một điều cuối cùng cần biết về hỗ trợ cho màu P3.

00:14:58.000 --> 00:15:21.000
Trình duyệt không chỉ cần hỗ trợ một số tính năng nhất định trong CSS hoặc JavaScript sử dụng màu P3, và tất nhiên, hệ điều hành và màn hình của người dùng cần hỗ trợ nó, mà trình duyệt cũng cần hỗ trợ kết xuất trong P3 cho từng phần cụ thể của trang web, trong các phần khác nhau của DOM.

00:15:21.000 --> 00:15:27.000
Bạn sẽ muốn kiểm tra chi tiết cho từng trình duyệt trước khi cho rằng nó hoạt động phổ biến.

00:15:27.000 --> 00:15:31.000
Hãy để tôi cung cấp cho bạn thông tin cập nhật về P3 trong Safari.

00:15:31.000 --> 00:15:36.000
Chúng tôi đã vận chuyển hỗ trợ cho hình ảnh trong P3 bảy năm trước trong Safari 10.0.

00:15:36.000 --> 00:15:42.000
Trong Safari 10.1, chúng tôi đã thêm hỗ trợ tổng thể cho P3 cho hầu hết các trang web.

00:15:42.000 --> 00:15:46.000
Trong Safari 15.2, chúng tôi đã thêm hỗ trợ bên trong phần tử Canvas.

00:15:46.000 --> 00:15:55.000
Và trong Safari 16.4, chúng tôi đã thêm hỗ trợ cho P3 trong WebGL Canvas thông qua việc sử dụng drawingBufferColorSpace.

00:15:55.000 --> 00:16:09.000
Đối với các công cụ dành cho nhà phát triển, trong Safari 13.1, chúng tôi đã vận chuyển một bộ chọn màu trong Trình kiểm tra web giúp dễ dàng tìm thấy các màu chỉ có sẵn trong P3 hoặc chuyển đổi màu từ mô hình màu này sang mô hình màu khác.

00:16:09.000 --> 00:16:15.000
Và trong Safari 15.2, chúng tôi đã thêm hỗ trợ cho P3 vào tab đồ họa Trình kiểm tra web.

00:16:15.000 --> 00:16:17.000
Chúng tôi vẫn còn một chút việc phải làm.

00:16:17.000 --> 00:16:25.000
Đầu tiên, để mở rộng hỗ trợ bên trong WebGL Canvas để bao gồm việc sử dụng unpackColorSpace.

00:16:25.000 --> 00:16:32.000
Và để thêm hỗ trợ cho P3 trong các bộ lọc SVG, điều mà chúng tôi vẫn chưa thực hiện, bởi vì vẫn còn cuộc tranh luận đang diễn ra về tiêu chuẩn web.

00:16:32.000 --> 00:16:38.000
Hiện tại, nếu bạn áp dụng Bộ lọc SVG, màu sắc sẽ được làm phẳng thành sRGB trong mọi trình duyệt.

00:16:38.000 --> 00:16:46.000
Đây thực sự là một thời điểm thú vị để suy nghĩ lại về màu sắc trên web, đặc biệt là vì rất nhiều tính năng này cuối cùng sẽ có sẵn trên các trình duyệt.

00:16:46.000 --> 00:16:55.000
Những tiến bộ trong CSS không chỉ thay đổi những gì có thể thiết kế mà còn giúp việc mã hóa các thiết kế đó dễ dàng hơn.

00:16:55.000 --> 00:17:05.000
Các lớp giả :user-valid và :user-invalid cung cấp một cách để tạo kiểu biểu mẫu tùy thuộc vào việc người dùng có điền chính xác vào trường hay không.

00:17:05.000 --> 00:17:11.000
Trong nhiều năm, các lớp giả :hợp lệ và :không hợp lệ có vẻ như chúng thực sự hữu ích.

00:17:11.000 --> 00:17:15.000
Tôi muốn tạo kiểu cho trường biểu mẫu này để cảnh báo người dùng khi họ mắc lỗi.

00:17:15.000 --> 00:17:20.000
Vì vậy, tôi sẽ thử :lớp giả không hợp lệ để chọn một đầu vào không hợp lệ.

00:17:20.000 --> 00:17:24.000
Với :có đầu vào:không hợp lệ, tôi sẽ nhắm mục tiêu nhãn.

00:17:24.000 --> 00:17:31.000
Và với ::trước phần tử giả, tôi sẽ chèn "x", vì vậy giao tiếp không chỉ phụ thuộc vào màu sắc.

00:17:31.000 --> 00:17:33.000
Hãy nhìn vào kết quả.

00:17:33.000 --> 00:17:38.000
Khi ai đó bắt đầu-- vâng, điều đó không tuyệt vời.

00:17:38.000 --> 00:17:45.000
Ngay khi người dùng bắt đầu nhập, trình duyệt sẽ đánh dấu nó không hợp lệ vì nó chưa phải là địa chỉ email hợp lệ.

00:17:45.000 --> 00:17:54.000
Bởi vì: dấu hiệu không hợp lệ nhập sai trước khi người dùng có cơ hội làm đúng, các nhà phát triển đã sử dụng JavaScript cho việc này thay thế.

00:17:54.000 --> 00:17:57.000
Người dùng hợp lệ và người dùng không hợp lệ khắc phục sự cố này.

00:17:57.000 --> 00:18:05.000
Họ sử dụng một thuật toán phức tạp hơn để xác định khi nào một trường biểu mẫu được coi là hợp lệ hoặc không hợp lệ.

00:18:05.000 --> 00:18:07.000
Chúng tôi đã vận chuyển nó trong Safari 16.5.

00:18:07.000 --> 00:18:10.000
Bây giờ chúng ta có thể thấy kết quả được cải thiện.

00:18:10.000 --> 00:18:14.000
Không có cảnh báo màu đỏ nếu họ có nếu họ đã làm đúng.

00:18:14.000 --> 00:18:22.000
Và nếu ai đó điền vào trường không chính xác, các cảnh báo màu đỏ sẽ xuất hiện sau khi họ rời khỏi trường, khi chúng tôi muốn cảnh báo họ quay lại và sửa nó.

00:18:22.000 --> 00:18:29.000
Như bạn có thể thấy, :user-invalid đặc biệt mạnh mẽ khi nó được kết hợp với :has().

00:18:29.000 --> 00:18:36.000
Trên thực tế, năm nay chúng tôi đã tăng sức mạnh của :has() bằng cách làm cho nó hoạt động với nhiều lớp giả hơn nữa.

00:18:36.000 --> 00:18:43.000
:Has(:lang()) cho phép tạo kiểu cho bất cứ thứ gì trên trang tùy thuộc vào sự hiện diện của một ngôn ngữ cụ thể.

00:18:43.000 --> 00:18:51.000
Và :has() hỗ trợ cho các lớp giả phương tiện cung cấp kiểu dáng có điều kiện tùy thuộc vào trạng thái phát lại âm thanh và video.

00:18:51.000 --> 00:18:57.000
Lớp giả :dir lấp đầy một khoảng trống khi nói đến hướng ngôn ngữ hỗ trợ.

00:18:57.000 --> 00:19:05.000
Tùy thuộc vào ngôn ngữ đang được sắp chữ, văn bản có thể chảy từ trái sang phải hoặc từ phải sang trái.

00:19:05.000 --> 00:19:09.000
Cái này thường được viết tắt là LTR và RTL.

00:19:09.000 --> 00:19:20.000
Ngày nay, CSS ngày càng có nhiều thuộc tính logic, cho phép bạn tham khảo phần bắt đầu và kết thúc của luồng văn bản, thay vì trái hoặc phải.

00:19:20.000 --> 00:19:31.000
Ví dụ, sử dụng margin-inline-start và margin-inline-end, thay vì margin-left và margin-right, để dễ dàng viết CSS hoạt động cho mọi ngôn ngữ.

00:19:31.000 --> 00:19:35.000
Nhưng không phải mọi thứ trong thiết kế của bạn đều có thể được xử lý bằng cách sử dụng các thuộc tính logic.

00:19:35.000 --> 00:19:40.000
Đây là nơi mà lớp giả hướng đi mới có thể hữu ích.

00:19:40.000 --> 00:19:45.000
Ở đây, tôi có một biểu tượng mà tôi muốn chuyển đổi tùy thuộc vào hướng của văn bản.

00:19:45.000 --> 00:19:54.000
Khi tiêu đề có hướng LTR, tôi sẽ xoay SVG theo một chiều và khi tiêu đề là RTL, tôi sẽ xoay nó theo cách khác.

00:19:54.000 --> 00:20:01.000
Đây là một kỹ thuật đơn giản hơn nhiều so với những gì đã được sử dụng trong quá khứ để hỗ trợ nhiều hướng ngôn ngữ.

00:20:01.000 --> 00:20:09.000
:User-valid và không hợp lệ, bổ sung vào :has(), và lớp giả :dir đều giúp việc viết mã mạnh mẽ và ngắn gọn dễ dàng hơn.

00:20:09.000 --> 00:20:18.000
Năm nay cũng mang đến một số tính năng giúp bạn có thể tinh chỉnh các chi tiết trong kiểu chữ của mình đến độ hoàn hảo tuyệt đối.

00:20:18.000 --> 00:20:22.000
Hãy bắt đầu với một cái nhìn vào các đơn vị chiều cao dòng mới.

00:20:22.000 --> 00:20:28.000
Trong CSS, chúng ta có nhiều loại đơn vị khác nhau mà chúng ta có thể sử dụng để xác định độ dài.

00:20:28.000 --> 00:20:39.000
Một số đơn vị có liên quan đến kích thước khung nhìn, như svh và lvh, hoặc liên quan đến kích thước của thùng chứa, như cqb và cqi.

00:20:39.000 --> 00:20:43.000
Các đơn vị khác có liên quan đến kích thước trong kiểu chữ.

00:20:43.000 --> 00:20:46.000
Một ex bằng x-chiều cao của phông chữ.

00:20:46.000 --> 00:20:53.000
Một ch, đối với ký tự, khớp với kích thước nội tuyến của ký tự 0 trong phông chữ.

00:20:53.000 --> 00:21:07.000
Và một ic là kích thước nội tuyến của một ký tự ý thức hệ trong các tập lệnh CJK - kích thước nội tuyến là chiều rộng ở chế độ viết ngang hoặc chiều cao ở chế độ viết dọc.

00:21:07.000 --> 00:21:11.000
Các đơn vị này đã được hỗ trợ trong các trình duyệt trong một thời gian.

00:21:11.000 --> 00:21:22.000
Chà, có một đơn vị mới cũng liên quan đến kích thước trong kiểu chữ của bạn: đơn vị lh, cho chiều cao dòng và rlh cho chiều cao dòng gốc.

00:21:22.000 --> 00:21:28.000
Các đơn vị này cho phép chúng tôi kết nối bất cứ thứ gì trong bố cục của mình với lượng không gian giữa các dòng.

00:21:28.000 --> 00:21:35.000
Ví dụ, tôi đặt chiều cao dòng thành 1.4 trên phần tử HTML gốc.

00:21:35.000 --> 00:21:41.000
Sau đó, tôi đặt một phần đệm 2rlh trên phần tử phần, thẻ trắng này.

00:21:41.000 --> 00:21:48.000
Sau đó, tôi đặt tiêu đề và lề đoạn văn theo hướng khối thành 1rlh.

00:21:48.000 --> 00:21:56.000
Bây giờ có chính xác nhiều khoảng trống giữa các dòng văn bản như thể có văn bản ở đó thay vì khoảng trắng.

00:21:56.000 --> 00:22:00.000
Điều đó thiết lập những gì được biết đến trong kiểu chữ là nhịp điệu dọc.

00:22:00.000 --> 00:22:19.000
Các đơn vị chiều cao dòng không ngăn chặn các tình huống có thể phá vỡ nhịp điệu dọc, nhưng chúng mang đến một công cụ cực kỳ đơn giản trên web giúp chúng ta tiến gần hơn đến việc mở khóa truyền thống đánh máy lâu đời này, cho phép chúng ta tạo ra một kết nối mật thiết giữa kiểu và khoảng trắng xung quanh loại.

00:22:19.000 --> 00:22:25.000
Có rất nhiều thách thức trong việc đánh bóng kiểu chữ kỹ thuật số trên web theo tiêu chuẩn cao của kiểu chữ truyền thống.

00:22:25.000 --> 00:22:29.000
Một trong số này liên quan đến kích thước phông chữ.

00:22:29.000 --> 00:22:34.000
Nếu bạn là một nhà thiết kế web, có khả năng bạn đang cẩn thận lựa chọn họ phông chữ và kích thước phông chữ của mình.

00:22:34.000 --> 00:22:40.000
Nhưng phông chữ bạn muốn có thể không tải xuống hoặc nó có thể không có sẵn trên hệ điều hành của người dùng.

00:22:40.000 --> 00:22:48.000
Đó là lý do tại sao cách tốt nhất là khai báo một chồng phông chữ trong họ phông chữ để cung cấp kế hoạch dự phòng cho trình duyệt.

00:22:48.000 --> 00:22:54.000
Phông chữ đầu tiên được tìm thấy là phông chữ được sử dụng.

00:22:54.000 --> 00:23:03.000
Tương tự, phông chữ lớn như thế nào xuất hiện trực quan ở một kích thước cụ thể không phải là thứ mà nhà phát triển web có thể kiểm soát.

00:23:03.000 --> 00:23:08.000
Đây là SF Hello ở bên trái, và Baskerville ở bên phải.

00:23:08.000 --> 00:23:17.000
Chúng được sắp chữ để có cùng kích thước, nhưng SF Hello trông lớn hơn nhiều vì nó lấp đầy nhiều không gian hơn bên trong hộp dòng của nó.

00:23:17.000 --> 00:23:20.000
Nó có chiều cao x lớn hơn.

00:23:20.000 --> 00:23:26.000
Sự khác biệt này được gây ra bởi các lựa chọn được thực hiện khi các tệp phông chữ được tạo.

00:23:26.000 --> 00:23:38.000
Ở đây, tôi có một ví dụ trong đó tôi đang sắp chữ một bài viết với kích thước phông chữ: 1.4rem và tôi đang xác định một ngăn xếp phông chữ đơn giản cho bất kỳ mã nào bên trong bài viết đó.

00:23:38.000 --> 00:23:42.000
Bạn có thể thấy mã trông nhỏ hơn văn bản đoạn văn như thế nào.

00:23:42.000 --> 00:23:45.000
Nó đặc biệt đáng chú ý nếu bạn so sánh Fs.

00:23:45.000 --> 00:23:51.000
Nếu mã rơi trở lại không gian đơn, thì nó trông lớn hơn văn bản đoạn văn.

00:23:51.000 --> 00:24:11.000
Chúng tôi có thể cố gắng bù đắp bằng cách điều chỉnh kích thước phông chữ để mã bằng 120% kích thước phông chữ bài viết, thậm chí có thể vượt quá kích thước khi Courier được sử dụng, nhưng nếu trình duyệt rơi trở lại không gian đơn, thì mã thậm chí còn lớn hơn văn bản đoạn văn.

00:24:11.000 --> 00:24:17.000
Những gì chúng ta cần là một cách để nói với trình duyệt, "Vui lòng chỉ làm cho hai phông chữ này trông giống như chúng có cùng kích thước" và để nó tìm ra cách thực hiện.

00:24:17.000 --> 00:24:20.000
Đó chính xác là những gì điều chỉnh kích thước phông chữ.

00:24:20.000 --> 00:24:25.000
Nó điều chỉnh kích thước phông chữ trông như thế nào để tạo ra sự nhất quán trực quan.

00:24:25.000 --> 00:24:37.000
Tôi đã thêm một dòng CSS-- font-size-adjust: 0.47-- và bây giờ mã sắp chữ của tôi phù hợp trực quan với văn bản đoạn văn, ngay cả đối với cả hai phông chữ trong ngăn xếp.

00:24:37.000 --> 00:24:42.000
Nhưng tại sao lại là 0.47? Con số này có nghĩa là gì?

00:24:42.000 --> 00:24:49.000
Đối với bất kỳ phông chữ Latin nào bạn có thể sử dụng trên web, có một tỷ lệ giữa kích thước phông chữ và chiều cao x của nó.

00:24:49.000 --> 00:24:54.000
Tỷ lệ đó hơi tùy ý, nhưng thường thì nó khoảng 50%.

00:24:54.000 --> 00:25:14.000
Bằng cách áp dụng font-size-adjust: 0.47 cho phần tử bài viết, tôi thực sự yêu cầu trình duyệt thay đổi kích thước mọi phông chữ bên trong bài viết-- phông chữ đoạn văn, phông chữ mã, bất kể phông chữ nào được sử dụng từ một trong hai ngăn xếp - vì vậy chiều cao x của mỗi phông chữ luôn bằng 47% kích thước phông chữ

00:25:14.000 --> 00:25:23.000
Tôi đã chọn 0.47 vì đó là điều khiến Iowan Old Style trông giống như khi không cần điều chỉnh kích thước phông chữ được áp dụng.

00:25:23.000 --> 00:25:30.000
Chúng tôi đã vận chuyển hỗ trợ cho các khả năng cơ bản này của việc điều chỉnh kích thước phông chữ trong Safari 16.4.

00:25:30.000 --> 00:25:35.000
Trong Safari 17, chúng tôi đang bổ sung hỗ trợ cho các khả năng nâng cao hơn.

00:25:35.000 --> 00:25:44.000
Sẽ không tốt hơn nếu bạn không phải theo dõi một con số kỳ diệu như 0.47 để thử và làm cho mọi phông chữ phù hợp với phông chữ chính của bạn?

00:25:44.000 --> 00:25:50.000
Giá trị từ phông chữ cho phép bạn yêu cầu trình duyệt chỉ cần tìm ra tất cả.

00:25:50.000 --> 00:25:59.000
Cũng trong Safari 17, chúng tôi đang thêm hỗ trợ cho cú pháp hai giá trị, cho phép bạn chỉ định số liệu nào nên được sử dụng khi tạo tính nhất quán về kích thước.

00:25:59.000 --> 00:26:11.000
Theo mặc định, đó là chiều cao cũ, nhưng thay vào đó bạn có thể sử dụng chiều cao giới hạn, chiều rộng ch, chiều rộng ic hoặc chiều cao ic.

00:26:11.000 --> 00:26:21.000
Safari 17 cũng bổ sung hỗ trợ cho bộ mô tả điều chỉnh kích thước, cho phép bạn thực hiện một loại điều chỉnh tương tự khi bạn thiết lập phông chữ với quy tắc @font-face.

00:26:21.000 --> 00:26:23.000
Đó là điều chỉnh kích thước phông chữ.

00:26:23.000 --> 00:26:29.000
Nó cho phép bạn kiểm soát nhiều hơn một chút đối với thứ gì đó không thể dễ dàng kiểm soát chỉ với kích thước phông chữ.

00:26:29.000 --> 00:26:39.000
Nhưng ngay cả với các đơn vị chiều cao dòng mới và khả năng điều chỉnh kích thước hình ảnh của loại của bạn, vẫn có những thứ có thể tạo ra sự không đồng đều khó chịu trong kích thước hộp dòng của bạn.

00:26:39.000 --> 00:26:42.000
Chúng tôi đang nghiên cứu một vài giải pháp cho vấn đề này.

00:26:42.000 --> 00:26:45.000
Cắt hộp văn bản là một trong số đó.

00:26:45.000 --> 00:26:49.000
Theo một số cách, text-box-trim tương tự như margin-trim.

00:26:49.000 --> 00:26:56.000
Cả hai đều cho phép bạn cắt bỏ khoảng trắng không mong muốn, nhưng trong trường hợp này, trên một hộp văn bản.

00:26:56.000 --> 00:26:59.000
Bạn đã bao giờ vật lộn để có được thứ gì đó xếp hàng theo chiều dọc trên web chưa?

00:26:59.000 --> 00:27:03.000
Tên này không được căn giữa theo chiều dọc.

00:27:03.000 --> 00:27:06.000
Có lẽ sẽ rõ ràng hơn nếu tôi vẽ một đường thẳng qua giữa.

00:27:06.000 --> 00:27:10.000
Văn bản trực quan thấp hơn trung tâm.

00:27:10.000 --> 00:27:13.000
Điều này xảy ra mọi lúc trên web.

00:27:13.000 --> 00:27:15.000
Nhưng tại sao?

00:27:15.000 --> 00:27:19.000
Chà, thực ra hộp văn bản được căn giữa theo chiều dọc.

00:27:19.000 --> 00:27:24.000
Nhưng các glyphs đang nằm thấp hơn bên trong chiếc hộp này.

00:27:24.000 --> 00:27:29.000
Có thêm khoảng trống bên trên và bên dưới các chữ cái được dành riêng bởi phông chữ.

00:27:29.000 --> 00:27:39.000
Lượng không gian thừa ở trên và bên dưới không giống nhau vì phông chữ không cần nhiều bên dưới như ở trên và điều đó làm mất tâm theo chiều dọc.

00:27:39.000 --> 00:27:42.000
Không gian thừa này cực kỳ quan trọng.

00:27:42.000 --> 00:27:46.000
Nó dành riêng cho dấu trọng âm, dấu nguyên âm, và nhiều hơn nữa.

00:27:46.000 --> 00:27:49.000
Nhưng nó có thể loại bỏ bố cục đánh máy trên web.

00:27:49.000 --> 00:27:58.000
Text-box-trim cung cấp cho chúng ta một cách để cắt bỏ không gian bổ sung này cho mục đích bố trí trong khi vẫn hiển thị toàn bộ tất cả các glyphs.

00:27:58.000 --> 00:28:00.000
Điều này không chỉ giúp ích cho việc căn giữa theo chiều dọc.

00:28:00.000 --> 00:28:11.000
Đây là một ví dụ trong đó không gian bổ sung dành riêng cho phông chữ trên chiều cao nắp khiến không thể dễ dàng có được phần trên cùng của tiêu đề thẳng hàng với phần trên cùng của hình ảnh.

00:28:11.000 --> 00:28:17.000
Bằng cách cắt giảm không gian thừa, việc sắp xếp mọi thứ trở nên dễ dàng.

00:28:17.000 --> 00:28:19.000
Đây là tất cả một công việc đang được tiến hành.

00:28:19.000 --> 00:28:23.000
Tên thuộc tính đã thay đổi từ leading-trim thành text-box-trim.

00:28:23.000 --> 00:28:33.000
Kể từ Bản xem trước Công nghệ Safari 171, mã bạn thấy trên màn hình là cách nó hoạt động, nhưng đừng quá gắn bó với những chi tiết này.

00:28:33.000 --> 00:28:36.000
Chúng tôi hy vọng nó sẽ tiếp tục thay đổi.

00:28:36.000 --> 00:28:38.000
Có lẽ nó sẽ trở nên như thế này.

00:28:38.000 --> 00:28:42.000
Hãy dùng thử nó trong Safari Technology Preview và cho chúng tôi biết suy nghĩ của bạn.

00:28:42.000 --> 00:28:49.000
Phản hồi ban đầu từ các nhà thiết kế và phát triển web như bạn là cách CSS trở nên tốt nhất có thể.

00:28:49.000 --> 00:28:58.000
Trong khi đó, đây là thứ có hỗ trợ tuyệt vời trên các trình duyệt và sẽ sớm đến với Safari 17, Phong cách Counter.

00:28:58.000 --> 00:29:12.000
Có lẽ bạn đã rất quen thuộc với các danh sách có thứ tự trong HTML, trong đó việc sử dụng CSS cung cấp một cơ chế dễ dàng để thay đổi hệ thống đánh số nào được sử dụng.

00:29:12.000 --> 00:29:16.000
Ở đây tôi đang áp dụng kiểu danh sách: devanagari.

00:29:16.000 --> 00:29:26.000
Có hàng tá hệ thống đánh số được xác định trước khác nhau có thể được áp dụng với một dòng CSS, bao gồm nhiều ngôn ngữ trên khắp thế giới.

00:29:26.000 --> 00:29:28.000
Nhưng không phải tất cả.

00:29:28.000 --> 00:29:30.000
Còn Serbo-croatian thì sao?

00:29:30.000 --> 00:29:36.000
Nếu tôi chỉ định kiểu danh sách: upper-serbo-croatian, tôi chỉ nhận được các số Ả Rập phương Tây mặc định.

00:29:36.000 --> 00:29:38.000
Đây là nơi Counter Styles xuất hiện.

00:29:38.000 --> 00:29:42.000
Tôi có thể xác định một hệ thống đánh số, tương tự như cách trình duyệt thực hiện nó.

00:29:42.000 --> 00:29:49.000
@Counter-style, sau đó là cái tên tôi muốn đặt cho nó, sau đó tôi xác định phẩm chất của phong cách.

00:29:49.000 --> 00:29:55.000
Trong trường hợp này, cài đặt hệ thống thành chữ cái và liệt kê các ký hiệu.

00:29:55.000 --> 00:30:05.000
Nhóm công tác quốc tế hóa W3C đã xuất bản một tài liệu về Phong cách truy cập làm sẵn bao gồm hàng trăm nền văn hóa trên khắp thế giới.

00:30:05.000 --> 00:30:15.000
Chúng tôi đã tăng số lượng ngôn ngữ được WebKit hỗ trợ và mở một cuộc thảo luận tại Nhóm làm việc CSS về việc tất cả các trình duyệt cung cấp hỗ trợ cho tất cả những điều này.

00:30:15.000 --> 00:30:22.000
Nhưng cho đến khi điều đó xảy ra, bạn có thể sao chép các đoạn mã từ tài liệu này và dán chúng vào mã của bạn.

00:30:22.000 --> 00:30:26.000
Bạn cũng có thể tạo kiểu cho các bộ đếm danh sách trở thành một cái gì đó hoàn toàn tùy chỉnh.

00:30:26.000 --> 00:30:32.000
Tôi đã tạo kiểu cho danh sách này để đếm các mục ở dạng nhị phân, với tối thiểu bốn chữ số.

00:30:32.000 --> 00:30:36.000
Và cái này để quay vòng một bộ biểu tượng cảm xúc lặp đi lặp lại.

00:30:36.000 --> 00:30:41.000
Bộ đếm CSS cũng có thể được sử dụng để đánh số nội dung khác trên trang, bên cạnh danh sách.

00:30:41.000 --> 00:30:46.000
Giống như các tiêu đề bắt đầu mỗi phần trong một tài liệu dài.

00:30:46.000 --> 00:30:47.000
Đây là một ví dụ.

00:30:47.000 --> 00:30:52.000
Tôi có ba tiêu đề H2, chỉ với các từ cho mỗi tiêu đề.

00:30:52.000 --> 00:30:56.000
Trong CSS, tôi tạo một bộ đếm bằng cách khai báo đặt lại bộ đếm.

00:30:56.000 --> 00:31:01.000
Tôi đã đặt tên nó là "đánh số" và tôi đã đặt nó để bắt đầu đếm sau số không.

00:31:01.000 --> 00:31:09.000
Sau đó, sử dụng :trước phần tử giả, tôi bảo trình duyệt tăng bộ đếm và hiển thị nó trong nội dung.

00:31:09.000 --> 00:31:16.000
Theo mặc định, bộ đếm sử dụng các số Ả Rập phương Tây--1, 2, 3-- nhưng chúng ta có thể thay đổi điều đó.

00:31:16.000 --> 00:31:20.000
Cũng giống như trước đây, tôi có thể tạo kiểu cho quầy thành bất cứ thứ gì tôi muốn.

00:31:20.000 --> 00:31:23.000
Đó là cách tạo và tạo kiểu cho bộ đếm.

00:31:23.000 --> 00:31:29.000
Nhưng đó không phải là tất cả những gì chúng tôi đang làm trong năm nay để giúp bạn đưa kiểu chữ của mình lên một tầm cao mới.

00:31:29.000 --> 00:31:33.000
Trên thực tế, sẽ có rất nhiều CSS sắp ra mắt trong năm nay.

00:31:33.000 --> 00:31:48.000
Trong Safari 16.2, chúng tôi cũng đã vận chuyển hỗ trợ căn chỉnh đường cơ sở cuối cùng cho Grid và Flexbox, cộng với một số chức năng bên trong font-variant-alternates và @font-feature-values để hỗ trợ thêm các tính năng Open Type.

00:31:48.000 --> 00:31:58.000
Safari 16.4 cũng đã thêm hỗ trợ cho cú pháp phạm vi Truy vấn Phương tiện và logic boolean, @property và hơn thế nữa.

00:31:58.000 --> 00:32:03.000
Safari 16.5 cũng đã thêm hỗ trợ cho CSS Nesting.

00:32:03.000 --> 00:32:16.000
Và trong Safari 17, chúng tôi cũng đang thêm tính năng phát hiện công nghệ phông chữ và định dạng phông chữ, chứa kích thước nội tại, chuyển đổi văn bản: kana có chiều rộng đầy đủ và kích thước đầy đủ và hơn thế nữa.

00:32:16.000 --> 00:32:28.000
Chúng tôi muốn gửi lời cảm ơn sâu sắc đến tất cả những người đã lưu trữ các vấn đề, ping chúng tôi trên phương tiện truyền thông xã hội hoặc viết các bài đăng trên blog để cho chúng tôi biết công nghệ web nào bạn cần triển khai hoặc cải thiện nhất.

00:32:28.000 --> 00:32:33.000
Chúng tôi đang lắng nghe, và đầu vào của bạn có tác động.

00:32:33.000 --> 00:32:35.000
Vui lòng cho chúng tôi biết bạn cần gì nữa.

00:32:35.000 --> 00:32:43.000
Bạn có thể gửi báo cáo lỗi và yêu cầu tính năng cho công nghệ web tại bugs.webkit.org‚ trình theo dõi sự cố cho WebKit.

00:32:43.000 --> 00:32:54.000
Các vấn đề về giao diện của Safari hoặc bất cứ điều gì về iOS, iPadOS và macOS, hãy gửi chúng tại feedbackassistant.apple.com.

00:32:54.000 --> 00:32:59.000
Đảm bảo rằng bạn có thông tin mới nhất về những gì được hỗ trợ trong Safari.

00:32:59.000 --> 00:33:05.000
Chúng tôi thường nghe từ các nhà phát triển yêu cầu chúng tôi triển khai thứ gì đó đã thực sự được vận chuyển.

00:33:05.000 --> 00:33:08.000
Caniuse là một nguồn tài nguyên tuyệt vời cho việc này.

00:33:08.000 --> 00:33:23.000
Bạn cũng có thể cập nhật tin tức mới nhất trên webkit.org, nơi bạn sẽ tìm thấy các bài viết chuyên sâu về từng bản phát hành của Safari, ghi chú phát hành cho Bản xem trước công nghệ Safari, tài liệu mở rộng về Trình kiểm tra web và hơn thế nữa.

00:33:23.000 --> 00:33:27.000
Tải xuống Bản xem trước Công nghệ Safari để cập nhật những gì sắp tới trong tương lai.

00:33:27.000 --> 00:33:33.000
Nó được cập nhật khoảng hai tuần một lần, vì vậy nó có những bổ sung mới nhất cho WebKit.

00:33:33.000 --> 00:33:41.000
Safari Technology Preview cũng có tất cả các tính năng mới đã sẵn sàng để được xem trước theo mặc định.

00:33:41.000 --> 00:34:17.000
Hoặc bạn có thể bật và tắt các tính năng trong ngăn Cờ tính năng mới trong Cài đặt Safari, bắt đầu từ Safari 17, bạn có thể truy cập từ Menu Phát triển được thiết kế lại hoàn toàn, với quyền truy cập nhanh để kết nối Trình kiểm tra web trên máy Mac của bạn với các trang web và ứng dụng web trên iPhone, iPad hoặc các thiết bị khác, bao gồm không

00:34:17.000 --> 00:34:24.000
Xem "Khám phá lại các tính năng của nhà phát triển Safari" tại WWDC23 để tìm hiểu về tất cả.

00:34:24.000 --> 00:34:26.000
Các ứng dụng web đang đến với Mac.

00:34:26.000 --> 00:34:31.000
Thêm vào đó, chúng tôi đã đóng gói một năm đầy đủ các cải tiến cho các ứng dụng web trên iPhone và iPad.

00:34:31.000 --> 00:34:34.000
"Có gì mới trong các ứng dụng web" bao gồm tất cả.

00:34:34.000 --> 00:34:46.000
Và tìm hiểu về các định dạng hình ảnh mới đến với Safari và WebKit, bao gồm JPEG XL, và tất cả về API Nguồn Phương tiện được Quản lý mới trong "Khám phá các định dạng phương tiện cho web."

00:34:46.000 --> 00:34:53.000
Chúng tôi rất vui mừng về việc có bao nhiêu công nghệ web mới đang được vận chuyển trong WebKit và Safari trong năm nay và chúng tôi hy vọng bạn cũng vậy.

00:34:53.000 --> 00:34:56.000
Và chúng tôi nóng lòng muốn xem bạn làm gì với tất cả.

00:34:56.000 --> 23:59:59.000
Cảm ơn vì đã xem.

