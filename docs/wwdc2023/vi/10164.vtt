WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:14.000
Ben: Xin chào, và chào mừng đến với "Có gì mới trong Swift 5.9."

00:00:14.000 --> 00:00:19.000
Tôi là Ben, và cùng với đồng nghiệp Doug của tôi, chúng tôi sẽ đưa bạn qua một số cải tiến đối với ngôn ngữ Swift trong năm nay.

00:00:19.000 --> 00:00:40.000
Chúng ta sẽ nói về một số cách dễ dàng hơn để diễn đạt ý của bạn bằng cách sử dụng cú pháp sạch của Swift, một số tính năng mới mạnh mẽ giúp các tác giả khung làm cho API mới của họ tự nhiên hơn để sử dụng và chúng ta sẽ xem xét một số cách mới để kiểm soát nhiều hơn hiệu suất và an toàn trong mã cấp thấp.

00:00:40.000 --> 00:00:44.000
Nhưng hãy bắt đầu bằng cách nói về dự án mã nguồn mở Swift.

00:00:44.000 --> 00:00:59.000
Đây là một bản cập nhật tuyệt vời cho Swift và nó không thể xảy ra nếu không có cộng đồng Swift, những người đóng góp và người dùng ngôn ngữ tập trung tại swift.org, làm việc cùng nhau để phát triển ngôn ngữ và hỗ trợ các sáng kiến mới.

00:00:59.000 --> 00:01:02.000
Swift tuân theo một quá trình mở cho sự tiến hóa ngôn ngữ.

00:01:02.000 --> 00:01:09.000
Các tính năng mới hoặc thay đổi hành vi quan trọng được đề xuất và xem xét mở trên các diễn đàn Swift.

00:01:09.000 --> 00:01:16.000
Nếu bạn muốn theo dõi, bạn có thể tìm thấy bảng điều khiển của tất cả các đề xuất ngôn ngữ trên trang web Swift.

00:01:16.000 --> 00:01:20.000
Một năm trước, chúng tôi đã chứng kiến sự tái cấu trúc đáng kể của quản trị Dự án Swift.

00:01:20.000 --> 00:01:30.000
Nhóm nòng cốt đã công bố thành lập Nhóm Chỉ đạo Ngôn ngữ, chịu trách nhiệm chính trong việc giám sát sự phát triển ngôn ngữ Swift và thư viện tiêu chuẩn.

00:01:30.000 --> 00:01:38.000
Kể từ đó, nhóm ngôn ngữ đã giám sát 40 đề xuất ngôn ngữ mới và chúng ta sẽ nói về một số trong số đó ngày hôm nay.

00:01:38.000 --> 00:01:50.000
Nhưng đôi khi, các đề xuất ngôn ngữ riêng lẻ kết hợp với nhau như một phần của chủ đề rộng hơn, như việc bổ sung Swift đồng thời, được giới thiệu thông qua mười đề xuất riêng biệt.

00:01:50.000 --> 00:01:57.000
Đối với những trường hợp như thế này, nhóm chỉ đạo ngôn ngữ đã giới thiệu một cách mới để gắn kết các đề xuất này lại với nhau, thông qua các tài liệu tầm nhìn.

00:01:57.000 --> 00:02:02.000
Những tài liệu này đưa ra một đề xuất cho những thay đổi lớn hơn đối với ngôn ngữ.

00:02:02.000 --> 00:02:13.000
Cái đầu tiên được nhóm chỉ đạo ngôn ngữ chấp nhận là tầm nhìn về macro Swift, một tính năng mới trong Swift 5.9 mà chúng ta sẽ đề cập sau trong buổi nói chuyện này.

00:02:13.000 --> 00:02:17.000
Tất nhiên, sự phát triển của ngôn ngữ chỉ là một phần công việc của cộng đồng Swift.

00:02:17.000 --> 00:02:20.000
Một ngôn ngữ thành công cần nhiều hơn thế này.

00:02:20.000 --> 00:02:27.000
Nó cần công cụ tuyệt vời, hỗ trợ mạnh mẽ cho nhiều nền tảng và tài liệu phong phú.

00:02:27.000 --> 00:02:35.000
Để giám sát sự tiến bộ trong lĩnh vực này, nhóm cốt lõi đang tạo ra một nhóm chỉ đạo hệ sinh thái song song với nhóm chỉ đạo ngôn ngữ.

00:02:35.000 --> 00:02:44.000
Cấu trúc mới này gần đây đã được trình bày trong một bài đăng trên blog trên Swift.org, để tìm kiếm các thông báo thêm về việc thành lập nhóm mới này sớm.

00:02:44.000 --> 00:02:52.000
Bây giờ hãy nói về những thay đổi đối với ngôn ngữ Swift trong năm nay, bắt đầu với những cách tốt hơn để thể hiện bản thân trong mã của bạn.

00:02:52.000 --> 00:03:07.000
Swift 5.9 bao gồm những gì có lẽ là cải tiến ngôn ngữ được yêu cầu phổ biến nhất của chúng tôi, cho phép các câu lệnh if/else và switch được sử dụng làm biểu thức, cung cấp một cách hay để dọn dẹp mã của bạn.

00:03:07.000 --> 00:03:19.000
Ví dụ, nếu bạn muốn khởi tạo một biến let dựa trên một số điều kiện phức tạp, bạn phải dùng đến các thủ thuật, như biểu thức bậc ba ghép khó đọc này.

00:03:19.000 --> 00:03:27.000
Thay vào đó, các biểu thức If cho phép bạn sử dụng một chuỗi câu lệnh if quen thuộc và dễ đọc hơn nhiều.

00:03:27.000 --> 00:03:33.000
Một nơi khác mà điều này hữu ích là nếu bạn đang khởi tạo một biến toàn cục hoặc một thuộc tính được lưu trữ.

00:03:33.000 --> 00:03:43.000
Các biểu thức đơn hoạt động tốt ở đây, nhưng nếu bạn muốn một điều kiện, bạn phải sử dụng thủ thuật gói nó trong một phần đóng mà sau đó bạn đã thực hiện ngay lập tức.

00:03:43.000 --> 00:03:51.000
Bây giờ một câu lệnh if có thể là một biểu thức, bạn có thể bỏ sự lộn xộn đó, để lại cho bạn mã gọn gàng hơn.

00:03:51.000 --> 00:04:06.000
Trình tạo kết quả, cú pháp khai báo thúc đẩy các tính năng như SwiftUI, đã chứng kiến những cải tiến đáng kể trong năm nay, bao gồm hiệu suất kiểm tra loại được tối ưu hóa, hoàn thành mã và thông báo lỗi được cải thiện.

00:04:06.000 --> 00:04:11.000
Cải tiến này đặc biệt tập trung vào mã không hợp lệ.

00:04:11.000 --> 00:04:21.000
Trước đây, mã trình tạo kết quả có lỗi sẽ mất nhiều thời gian để thất bại, vì trình kiểm tra kiểu đã khám phá nhiều đường dẫn không hợp lệ có thể xảy ra.

00:04:21.000 --> 00:04:31.000
Kể từ Swift 5.8, loại mã không hợp lệ kiểm tra nhanh hơn nhiều và thông báo lỗi trên mã không hợp lệ giờ đây chính xác hơn.

00:04:31.000 --> 00:04:39.000
Ví dụ, trước đây, một số mã không hợp lệ có thể dẫn đến lỗi gây hiểu lầm trong một phần hoàn toàn khác của trình tạo kết quả.

00:04:39.000 --> 00:04:46.000
Trong Swift 5.7, bạn sẽ nhận được một lỗi như thế này, khi lỗi thực sự nằm ở đây.

00:04:46.000 --> 00:04:53.000
Trong bản phát hành mới nhất, bây giờ bạn nhận được chẩn đoán trình biên dịch chính xác hơn để xác định vấn đề thực sự.

00:04:53.000 --> 00:05:02.000
Tiếp theo, hãy nói về cách bổ sung vào hệ thống generics sẽ cho phép một số cải tiến tuyệt vời cho các khuôn khổ bạn sử dụng hàng ngày.

00:05:02.000 --> 00:05:06.000
Hầu như tất cả Swift bạn viết đều sử dụng thuốc generic theo một cách nào đó.

00:05:06.000 --> 00:05:13.000
Suy luận kiểu cho phép sử dụng các loại này mà không cần hiểu các khả năng nâng cao mà chúng được xây dựng.

00:05:13.000 --> 00:05:22.000
Ví dụ, loại mảng thư viện tiêu chuẩn sử dụng generics để cung cấp một mảng hoạt động với bất kỳ loại dữ liệu nào mà bạn có thể muốn lưu trữ.

00:05:22.000 --> 00:05:27.000
Khi bạn sử dụng một mảng, tất cả những gì bạn cần làm là cung cấp các phần tử.

00:05:27.000 --> 00:05:36.000
Không cần chỉ định một đối số rõ ràng cho loại phần tử vì nó có thể được suy ra từ các giá trị phần tử.

00:05:36.000 --> 00:05:47.000
Hệ thống generics của Swift cho phép các API tự nhiên bảo toàn thông tin loại để mã của bạn hoạt động liền mạch trên các loại cụ thể mà bạn cung cấp.

00:05:47.000 --> 00:05:57.000
Đây là một ví dụ lấy cảm hứng từ cơ sở mã riêng của trình biên dịch Swift: Một API lấy một loại yêu cầu và đánh giá nó để tạo ra một giá trị được nhập mạnh.

00:05:57.000 --> 00:06:03.000
Vì vậy, bạn có thể yêu cầu giá trị Boolean và nhận lại kết quả Boolean.

00:06:03.000 --> 00:06:12.000
Bây giờ, một số API muốn trừu tượng hóa không chỉ trên các loại cụ thể, mà còn cả số lượng đối số mà bạn chuyển vào.

00:06:12.000 --> 00:06:22.000
Vì vậy, một hàm có thể nhận một yêu cầu và trả về một hoặc hai kết quả yêu cầu và trả về hai hoặc ba kết quả và trả về ba kết quả.

00:06:22.000 --> 00:06:34.000
Để hỗ trợ điều này, hệ thống generics phải được sử dụng cùng với một cơ chế để xử lý nhiều độ dài đối số để tất cả các loại mà bạn chuyển vào được liên kết với các loại mà bạn nhận được.

00:06:34.000 --> 00:06:44.000
Trước Swift 5.9, cách duy nhất để thực hiện mẫu này là thêm quá tải cho từng độ dài đối số cụ thể mà API hỗ trợ.

00:06:44.000 --> 00:06:47.000
Nhưng cách tiếp cận này có những hạn chế.

00:06:47.000 --> 00:06:56.000
Nó buộc giới hạn trên nhân tạo về số lượng đối số bạn có thể vượt qua, dẫn đến lỗi trình biên dịch nếu bạn vượt qua quá nhiều.

00:06:56.000 --> 00:07:02.000
Trong trường hợp này, không có quá tải nào có thể xử lý nhiều hơn sáu đối số, nhưng chúng tôi đã vượt qua bảy.

00:07:02.000 --> 00:07:12.000
Mô hình quá tải này và những hạn chế của nó phổ biến trên các API xử lý về mặt khái niệm độ dài đối số tùy ý.

00:07:12.000 --> 00:07:23.000
Trong Swift 5.9, hệ thống generics đang nhận được sự hỗ trợ hạng nhất cho mẫu API này bằng cách cho phép trừu tượng hóa chung trên độ dài đối số.

00:07:23.000 --> 00:07:30.000
Điều này được thực hiện với một khái niệm ngôn ngữ mới có thể đại diện cho nhiều tham số loại riêng lẻ được "đóng gói" cùng nhau.

00:07:30.000 --> 00:07:35.000
Khái niệm mới này được gọi là gói tham số kiểu.

00:07:35.000 --> 00:07:49.000
Sử dụng các gói tham số, các API hiện có quá tải riêng lẻ cho mỗi độ dài đối số cố định có thể được thu gọn thành một hàm duy nhất.

00:07:49.000 --> 00:08:03.000
Thay vì chấp nhận một tham số loại duy nhất, Kết quả, đại diện cho loại kết quả của một yêu cầu duy nhất, hàm đánh giá hiện chấp nhận một yêu cầu riêng biệt trên mỗi loại Kết quả.

00:08:03.000 --> 00:08:13.000
Hàm trả về mỗi trường hợp kết quả trong ngoặc đơn, sẽ là một giá trị duy nhất hoặc một bộ chứa mỗi giá trị.

00:08:13.000 --> 00:08:21.000
Hàm đánh giá hiện xử lý tất cả độ dài đối số mà không có giới hạn nhân tạo.

00:08:21.000 --> 00:08:31.000
Suy luận kiểu làm cho API sử dụng các gói tham số tự nhiên để sử dụng mà không cần biết rằng API đang sử dụng chúng.

00:08:31.000 --> 00:08:39.000
Gọi hàm đánh giá mới của chúng tôi hiện có thể xử lý bất kỳ số lượng đối số nào, trông giống như gọi quá tải có độ dài cố định.

00:08:39.000 --> 00:08:47.000
Swift suy ra loại của mỗi đối số cùng với tổng số dựa trên cách bạn gọi hàm.

00:08:47.000 --> 00:08:55.000
Để tìm hiểu về cách viết các API thư viện chung như thế này, hãy xem Generalize APIs bằng cách sử dụng các gói tham số.

00:08:55.000 --> 00:09:06.000
Gọi các API chung một cách tự nhiên thể hiện một trong những mục tiêu thiết kế cơ bản của Swift, thể hiện rõ ràng thông qua mã ngắn gọn.

00:09:06.000 --> 00:09:14.000
Các tính năng ngôn ngữ nâng cao của Swift cho phép các API đẹp mắt giúp bạn dễ dàng nói ra ý của mình hơn.

00:09:14.000 --> 00:09:26.000
Bạn được hưởng lợi từ các tính năng ngôn ngữ nâng cao này ngay từ những dòng đầu tiên của Swift mà bạn từng viết, cho dù đó là sử dụng chung chung thông qua mảng hoặc từ điển hay thiết kế giao diện người dùng trong SwiftUI.

00:09:26.000 --> 00:09:35.000
Việc Swift nắm bắt tiết lộ tiến bộ có nghĩa là bạn có thể tìm hiểu về các tính năng nâng cao hơn khi bạn sẵn sàng.

00:09:35.000 --> 00:09:47.000
Swift 5.9 đưa cách tiếp cận thiết kế này lên một tầm cao mới bằng cách cung cấp cho các tác giả thư viện một hộp công cụ mới để thiết kế API biểu cảm bằng cách sử dụng một hệ thống vĩ mô mới.

00:09:47.000 --> 00:09:50.000
Đây là Doug để cho bạn biết thêm.

00:09:50.000 --> 00:09:59.000
Doug: Với macro, bạn có thể mở rộng khả năng của chính ngôn ngữ, loại bỏ bản mẫu và mở khóa nhiều sức mạnh biểu cảm của Swift hơn.

00:09:59.000 --> 00:10:05.000
Hãy xem xét hàm khẳng định luôn hiện diện, kiểm tra xem một điều kiện có đúng hay không.

00:10:05.000 --> 00:10:14.000
Assert sẽ dừng chương trình nếu điều kiện sai, nhưng khi điều đó xảy ra, bạn sẽ nhận được rất ít thông tin về những gì đã xảy ra, chỉ có tệp và số dòng.

00:10:14.000 --> 00:10:18.000
Bạn sẽ cần thêm một số ghi nhật ký hoặc bẫy chương trình trong trình gỡ lỗi để tìm hiểu thêm.

00:10:18.000 --> 00:10:21.000
Đã có những nỗ lực để cải thiện điều này.

00:10:21.000 --> 00:10:29.000
XCTest cung cấp một phép toán khẳng định bằng nhau lấy hai giá trị riêng biệt, vì vậy khi mọi thứ thất bại, ít nhất bạn có thể thấy hai giá trị không bằng nhau.

00:10:29.000 --> 00:10:32.000
Nhưng chúng tôi vẫn không biết giá trị nào sai ở đây.

00:10:32.000 --> 00:10:35.000
Đó là a, b, hay kết quả của max?

00:10:35.000 --> 00:10:40.000
Và cách tiếp cận này thực sự không mở rộng quy mô cho tất cả các loại kiểm tra mà chúng tôi thực hiện trong các khẳng định.

00:10:40.000 --> 00:10:48.000
Nếu chúng ta quay lại khẳng định ban đầu, có rất nhiều thông tin ở đây trong mã nguồn mà chúng ta muốn thấy trong nhật ký khi khẳng định của chúng ta không thành công.

00:10:48.000 --> 00:10:50.000
Mã là gì?

00:10:50.000 --> 00:10:53.000
Các giá trị của a, và b, và c là gì?

00:10:53.000 --> 00:10:55.000
Max đã sản xuất cái gì?

00:10:55.000 --> 00:11:02.000
Chúng tôi không thể cải thiện điều này trong Swift trước đây nếu không có một số tính năng tùy chỉnh, nhưng macro làm cho nó có thể.

00:11:02.000 --> 00:11:08.000
Trong ví dụ này, cú pháp "hash-assert" đang mở rộng macro được gọi là "assert".

00:11:08.000 --> 00:11:17.000
Cú pháp băm có thể trông quen thuộc vì Swift đã có một vài thứ với cùng cách viết này, như tệp băm, bộ chọn băm và cảnh báo băm.

00:11:17.000 --> 00:11:27.000
Macro khẳng định trông và cảm thấy giống như phiên bản chức năng, nhưng vì nó là một macro, nó có thể cung cấp trải nghiệm phong phú hơn khi khẳng định không thành công.

00:11:27.000 --> 00:11:35.000
Bây giờ chương trình đang hiển thị mã cho xác nhận không thành công, cùng với từng giá trị đã đóng góp vào kết quả.

00:11:35.000 --> 00:11:44.000
Trong Swift, macro là API, giống như các loại hoặc hàm, vì vậy bạn truy cập chúng bằng cách nhập mô-đun xác định chúng.

00:11:44.000 --> 00:11:49.000
Giống như nhiều API khác, macro được phân phối dưới dạng các gói.

00:11:49.000 --> 00:11:58.000
Macro khẳng định ở đây đến từ thư viện khẳng định sức mạnh, một gói Swift mã nguồn mở có sẵn trên GitHub.

00:11:58.000 --> 00:12:04.000
Nếu bạn nhìn vào gói macro, bạn sẽ tìm thấy một khai báo macro để khẳng định.

00:12:04.000 --> 00:12:10.000
Nó được giới thiệu với từ khóa "macro", nhưng nếu không, nó trông rất giống một hàm.

00:12:10.000 --> 00:12:14.000
Có một tham số Bool không được gắn nhãn duy nhất cho điều kiện được kiểm tra.

00:12:14.000 --> 00:12:21.000
Nếu macro này tạo ra một giá trị, loại kết quả đó sẽ được viết bằng cú pháp mũi tên thông thường.

00:12:21.000 --> 00:12:25.000
Việc sử dụng macro sẽ được kiểm tra kiểu dựa trên các tham số.

00:12:25.000 --> 00:12:39.000
Điều đó có nghĩa là, nếu bạn mắc lỗi khi sử dụng macro, chẳng hạn như quên so sánh giá trị tối đa với thứ gì đó, bạn sẽ nhận được thông báo lỗi hữu ích ngay lập tức, trước khi macro được mở rộng.

00:12:39.000 --> 00:12:51.000
Điều này cho phép Swift cung cấp trải nghiệm phát triển tuyệt vời khi sử dụng macro vì macro hoạt động trên các đầu vào được nhập tốt và tạo mã giúp tăng cường chương trình của bạn theo những cách có thể dự đoán được.

00:12:51.000 --> 00:13:01.000
Hầu hết các macro được định nghĩa là "các macro bên ngoài", chỉ định mô-đun và loại để triển khai macro thông qua các chuỗi.

00:13:01.000 --> 00:13:08.000
Các loại macro bên ngoài được xác định trong các chương trình riêng biệt hoạt động như các plugin trình biên dịch.

00:13:08.000 --> 00:13:13.000
Trình biên dịch Swift chuyển mã nguồn để sử dụng macro cho plugin.

00:13:13.000 --> 00:13:19.000
Plugin tạo ra mã nguồn mới, sau đó được tích hợp lại vào chương trình Swift.

00:13:19.000 --> 00:13:27.000
Ở đây, macro đang mở rộng xác nhận thành mã nắm bắt các giá trị riêng lẻ và nơi chúng sẽ được hiển thị trong mã nguồn.

00:13:27.000 --> 00:13:32.000
Bạn sẽ không muốn tự viết bản mẫu, nhưng macro sẽ làm điều đó cho bạn.

00:13:32.000 --> 00:13:37.000
Khai báo vĩ mô có một phần thông tin bổ sung, vai trò của chúng.

00:13:37.000 --> 00:13:41.000
Macro khẳng định ở đây là một macro biểu thức độc lập.

00:13:41.000 --> 00:13:48.000
Nó được gọi là độc lập vì nó sử dụng cú pháp "hash" và hoạt động trực tiếp trên cú pháp đó để tạo ra mã mới.

00:13:48.000 --> 00:13:53.000
Nó là một biểu thức vĩ mô bởi vì nó có thể được sử dụng ở bất cứ nơi nào mà người ta có thể tạo ra một giá trị.

00:13:53.000 --> 00:13:59.000
Các API Foundation Predicate mới cung cấp một ví dụ tuyệt vời về macro biểu thức.

00:13:59.000 --> 00:14:04.000
Vĩ mô vị ngữ cho phép người ta viết vị ngữ theo cách an toàn kiểu bằng cách sử dụng các đóng.

00:14:04.000 --> 00:14:14.000
Các giá trị vị ngữ kết quả sau đó có thể được sử dụng với một số API khác, bao gồm các hoạt động thu thập Swift SwiftUI và SwiftData.

00:14:14.000 --> 00:14:19.000
Bản thân macro là chung chung so với tập hợp các loại đầu vào.

00:14:19.000 --> 00:14:29.000
Nó chấp nhận một đối số đóng là một hàm hoạt động trên các giá trị của các loại đầu vào đó và tạo ra kết quả Boolean, tập hợp các đầu vào có khớp hay không?

00:14:29.000 --> 00:14:36.000
Và macro trả về một thể hiện của loại Vị ngữ mới, có thể được sử dụng ở nơi khác trong chương trình.

00:14:36.000 --> 00:14:46.000
Nhưng có nhiều macro hơn vì rất nhiều bản mẫu mà chúng tôi cuối cùng viết là vì chúng tôi cần tăng cường mã mà chúng tôi đã viết với thứ khác có nguồn gốc từ nó.

00:14:46.000 --> 00:14:47.000
Hãy lấy một ví dụ.

00:14:47.000 --> 00:14:55.000
Tôi thấy rằng tôi sử dụng enums rất nhiều trong mã của riêng mình, như Enum Đường dẫn này nắm bắt các đường dẫn tương đối hoặc tuyệt đối.

00:14:55.000 --> 00:15:02.000
Nhưng tôi thường thấy mình cần kiểm tra một trường hợp cụ thể, giả sử, bằng cách lọc tất cả các đường dẫn tuyệt đối từ một bộ sưu tập.

00:15:02.000 --> 00:15:06.000
Tất nhiên, tôi có thể viết đây là Kiểm tra tuyệt đối như một thuộc tính được tính toán.

00:15:06.000 --> 00:15:10.000
Nhưng sớm hay muộn, tôi sẽ phải viết một cái khác.

00:15:10.000 --> 00:15:14.000
Điều này đang trở nên hơi tẻ nhạt.

00:15:14.000 --> 00:15:19.000
Macros có thể giúp ích ở đây bằng cách tạo ra bản mẫu cho chúng tôi.

00:15:19.000 --> 00:15:26.000
Phát hiện trường hợp là một macro đính kèm, được viết bằng cách sử dụng cú pháp thuộc tính tùy chỉnh giống như trình bao bọc thuộc tính.

00:15:26.000 --> 00:15:38.000
Các macro đính kèm lấy cú pháp của khai báo mà chúng áp dụng làm đầu vào - đây là chính khai báo enum - và sẽ tạo mã mới.

00:15:38.000 --> 00:15:44.000
Mã mở rộng vĩ mô này là mã Swift bình thường, mà trình biên dịch tích hợp vào chương trình của bạn.

00:15:44.000 --> 00:15:53.000
Bạn có thể kiểm tra mã được tạo vĩ mô trong trình chỉnh sửa của mình, gỡ lỗi vào nó, sao chép nó nếu bạn muốn tùy chỉnh nó hơn nữa, v.v.

00:15:53.000 --> 00:16:01.000
Các macro đính kèm được phân thành năm vai trò khác nhau dựa trên cách chúng tăng cường tuyên bố mà chúng được đính kèm.

00:16:01.000 --> 00:16:11.000
Macro phát hiện trường hợp mà chúng ta vừa thảo luận là macro đính kèm "thành viên", có nghĩa là nó tạo ra các thành viên mới trong một loại hoặc tiện ích mở rộng.

00:16:11.000 --> 00:16:23.000
Các macro ngang hàng thêm các khai báo mới cùng với khai báo mà chúng được đính kèm, ví dụ, để tạo phiên bản xử lý hoàn thành của một phương thức không đồng bộ hoặc ngược lại.

00:16:23.000 --> 00:16:38.000
Các macro truy cập có thể biến một thuộc tính được lưu trữ thành một thuộc tính được tính toán, có thể được sử dụng để thực hiện các hành động cụ thể về quyền truy cập thuộc tính hoặc trừu tượng hóa lưu trữ thực tế theo cách tương tự, nhưng linh hoạt hơn các trình bao bọc thuộc tính.

00:16:38.000 --> 00:16:47.000
Và các macro đính kèm có thể giới thiệu các thuộc tính cho các thành viên cụ thể của một loại, cũng như thêm các tuân thủ giao thức mới.

00:16:47.000 --> 00:16:52.000
Một số vai trò vĩ mô đính kèm có thể được cấu tạo cùng nhau để đạt được các hiệu ứng hữu ích.

00:16:52.000 --> 00:16:57.000
Một ví dụ quan trọng về điều này là với sự quan sát.

00:16:57.000 --> 00:17:00.000
Quan sát luôn là một phần của SwiftUI.

00:17:00.000 --> 00:17:16.000
Để có thể quan sát các thay đổi đối với các thuộc tính của một lớp, người ta chỉ cần làm cho loại phù hợp với ObservableObject và đánh dấu mọi thuộc tính tại-Published và sử dụng trình bao bọc thuộc tính ObservedObject trong chế độ xem của bạn.

00:17:16.000 --> 00:17:22.000
Đó là một loạt các bước và việc bỏ lỡ một bước có thể có nghĩa là giao diện người dùng không cập nhật như mong đợi.

00:17:22.000 --> 00:17:27.000
Chúng ta có thể làm tốt hơn với quan sát dựa trên vĩ mô.

00:17:27.000 --> 00:17:33.000
Gắn macro Observable vào một lớp cung cấp sự quan sát cho tất cả các thuộc tính được lưu trữ của nó.

00:17:33.000 --> 00:17:42.000
Không cần phải chú thích từng thuộc tính được lưu trữ hoặc lo lắng về những gì sẽ xảy ra nếu bạn không làm vậy vì macro Observable xử lý tất cả.

00:17:42.000 --> 00:17:48.000
Vĩ mô có thể quan sát được hoạt động thông qua thành phần của ba vai trò vĩ mô.

00:17:48.000 --> 00:17:52.000
Hãy đi sâu vào cách những vai trò này hoạt động cùng nhau.

00:17:52.000 --> 00:18:00.000
Mỗi vai trò vĩ mô tương ứng với một cách cụ thể trong đó lớp Person được tăng cường bởi macro Observable.

00:18:00.000 --> 00:18:05.000
Vai trò thành viên giới thiệu các thuộc tính và phương pháp mới.

00:18:05.000 --> 00:18:18.000
Vai trò thuộc tính thành viên sẽ thêm macro @ObservationTracked vào các thuộc tính được lưu trữ của lớp quan sát được, từ đó mở rộng thành getters và setters để kích hoạt các sự kiện quan sát.

00:18:18.000 --> 00:18:25.000
Cuối cùng, vai trò phù hợp giới thiệu sự phù hợp với giao thức Observable.

00:18:25.000 --> 00:18:34.000
Điều này có thể trông giống như rất nhiều mã, nhưng tất cả chỉ là mã Swift bình thường và nó được gấp gọn gàng phía sau macro Observable.

00:18:34.000 --> 00:18:45.000
Bất cứ khi nào bạn cần xem bất kỳ macro nào mở rộng như thế nào để hiểu rõ hơn về ảnh hưởng của nó đối với chương trình của bạn, nó sẽ nằm ngay trong tầm tay bạn trong Xcode.

00:18:45.000 --> 00:18:51.000
Sử dụng hành động "Mở rộng Macro" để xem mã nguồn mở rộng vĩ mô trong trình chỉnh sửa của bạn.

00:18:51.000 --> 00:19:00.000
Bất kỳ thông báo lỗi nào trong mã được tạo vĩ mô sẽ tự động hiển thị mã mở rộng và bạn có thể bước vào và ra khỏi nó bằng trình gỡ lỗi của mình.

00:19:00.000 --> 00:19:11.000
Các macro Swift cung cấp một công cụ mới để cho phép các API biểu cảm hơn và loại bỏ bản mẫu khỏi mã Swift của bạn, giúp mở khóa sức mạnh biểu cảm của Swift.

00:19:11.000 --> 00:19:20.000
Kiểu macro - kiểm tra đầu vào của chúng, tạo mã Swift bình thường và tích hợp tại các điểm xác định trong chương trình của bạn, vì vậy hiệu ứng của chúng rất dễ suy luận.

00:19:20.000 --> 00:19:27.000
Và bất cứ khi nào bạn cần hiểu macro đã làm gì, mã nguồn mở rộng của nó sẽ ở ngay trong trình chỉnh sửa của bạn.

00:19:27.000 --> 00:19:30.000
Chúng tôi vừa làm xước bề mặt của macro.

00:19:30.000 --> 00:19:37.000
"Mở rộng trên macro Swift" sẽ đi sâu vào thiết kế của macro Swift để trả lời tất cả những câu hỏi mà bạn phải có.

00:19:37.000 --> 00:19:42.000
Và bạn có thể thực hành triển khai macro của riêng mình với "Write Swift macros".

00:19:42.000 --> 00:19:46.000
Tôi nóng lòng muốn xem cộng đồng Swift sẽ xây dựng những macro mới nào.

00:19:46.000 --> 00:19:52.000
Ben: Ngay từ đầu, Swift đã được thiết kế để trở thành một ngôn ngữ có thể mở rộng.

00:19:52.000 --> 00:20:02.000
Thiết kế của Swift nhấn mạnh tính biểu cảm với mã rõ ràng và súc tích, ít nghi lễ và dễ đọc và viết.

00:20:02.000 --> 00:20:17.000
Bằng cách tận dụng các tính năng mạnh mẽ của Swift, như generics và hỗ trợ đồng thời gốc, các khuôn khổ như SwiftUI hoặc SwiftData cho phép bạn nhanh chóng đạt được kết quả bạn muốn, giúp bạn có nhiều thời gian hơn để tập trung vào những gì quan trọng.

00:20:17.000 --> 00:20:23.000
Mặc dù có những khả năng cấp cao này, Swift cũng hiệu quả.

00:20:23.000 --> 00:20:34.000
Nó biên dịch nguyên bản và việc sử dụng các loại giá trị và đếm tham chiếu thay vì thu gom rác có nghĩa là nó có thể đạt được dấu chân bộ nhớ thấp.

00:20:34.000 --> 00:20:49.000
Khả năng mở rộng này có nghĩa là chúng tôi có thể đẩy Swift đến nhiều nơi hơn so với trước đây có thể với Objective-C, đến các hệ thống cấp thấp, nơi trước đây bạn có thể mong đợi phải sử dụng C hoặc C++.

00:20:49.000 --> 00:20:56.000
Điều này có nghĩa là mang mã rõ ràng hơn của Swift và đảm bảo an toàn quan trọng đến nhiều nơi hơn.

00:20:56.000 --> 00:21:02.000
Gần đây chúng tôi đã mở nguồn bắt đầu viết lại khung Foundation trong Swift.

00:21:02.000 --> 00:21:10.000
Sáng kiến này sẽ dẫn đến một triển khai chung duy nhất của Foundation trên cả nền tảng Apple và không phải của Apple.

00:21:10.000 --> 00:21:16.000
Nhưng nó cũng có nghĩa là viết lại một lượng lớn mã Objective-C và C trong Swift.

00:21:16.000 --> 00:21:35.000
Kể từ MacOS Sonoma và iOS 17, có các triển khai mới được hỗ trợ bởi Swift của các loại thiết yếu như Ngày và Lịch, các yếu tố cần thiết về định dạng và quốc tế hóa như Locale và AttributedString, và triển khai Swift mới của mã hóa và giải mã JSON.

00:21:35.000 --> 00:21:39.000
Và những chiến thắng về hiệu suất rất đáng kể.

00:21:39.000 --> 00:21:53.000
Khả năng tính toán các ngày quan trọng của lịch có thể tận dụng tốt hơn ngữ nghĩa giá trị của Swift để tránh phân bổ trung gian, dẫn đến cải thiện hơn 20% trong một số điểm chuẩn.

00:21:53.000 --> 00:22:05.000
Định dạng ngày sử dụng FormatStyle cũng đã đạt được một số nâng cấp hiệu suất lớn, cho thấy sự cải thiện lớn 150% trong điểm chuẩn định dạng với mẫu ngày và giờ tiêu chuẩn.

00:22:05.000 --> 00:22:11.000
Thú vị hơn nữa là những cải tiến để giải mã JSON trong gói mới.

00:22:11.000 --> 00:22:21.000
Foundation có triển khai Swift hoàn toàn mới cho JSONDecoder và JSONEncoder, loại bỏ các chuyến đi khứ hồi tốn kém đến và đi từ các loại bộ sưu tập Objective-C.

00:22:21.000 --> 00:22:29.000
Sự tích hợp chặt chẽ của phân tích cú pháp JSON trong Swift để khởi tạo các loại Codable cũng cải thiện hiệu suất.

00:22:29.000 --> 00:22:36.000
Trong điểm chuẩn phân tích cú pháp dữ liệu kiểm tra, việc triển khai mới nhanh hơn từ hai đến năm lần.

00:22:36.000 --> 00:22:48.000
Những cải tiến này đến từ việc giảm chi phí bắc cầu từ việc triển khai Objective-C cũ sang Swift, mà còn do việc triển khai dựa trên Swift mới nhanh hơn.

00:22:48.000 --> 00:22:51.000
Hãy xem xét một điểm chuẩn làm ví dụ.

00:22:51.000 --> 00:22:59.000
Ở Ventura, việc gọi enumerateDates từ Objective-C nhanh hơn một chút so với gọi nó từ Swift vì chi phí bắc cầu.

00:22:59.000 --> 00:23:05.000
Trong MacOS Sonoma, việc gọi chức năng tương tự từ Swift nhanh hơn 20%.

00:23:05.000 --> 00:23:16.000
Một số tốc độ tăng đó đến từ việc loại bỏ chi phí bắc cầu, nhưng bản thân việc triển khai chức năng mới cũng nhanh hơn, như đã thấy khi gọi nó từ Objective-C.

00:23:16.000 --> 00:23:25.000
Việc tính toán ngày cụ thể này không quá phức tạp, vì vậy đây là một cách tuyệt vời để xem việc giảm chi phí giữa hai ngôn ngữ.

00:23:25.000 --> 00:23:35.000
Bây giờ, đôi khi, khi bạn đang hoạt động ở các cấp thấp hơn của hệ thống, bạn cần kiểm soát chi tiết hơn để đạt được mức hiệu suất cần thiết.

00:23:35.000 --> 00:23:43.000
Swift 5.9 giới thiệu một số khả năng chọn tham gia mới giúp bạn đạt được mức độ kiểm soát này.

00:23:43.000 --> 00:23:53.000
Những khả năng này tập trung vào khái niệm quyền sở hữu, nghĩa là phần nào của mã "sở hữu" một giá trị khi nó truyền qua ứng dụng của bạn.

00:23:53.000 --> 00:23:59.000
Để xem khi nào bạn có thể muốn sử dụng các tính năng này, trước tiên chúng ta hãy xem xét một số mã ví dụ.

00:23:59.000 --> 00:24:08.000
Ở đây chúng tôi có một trình bao bọc rất đơn giản cho một bộ mô tả tệp cho phép chúng tôi cung cấp các cuộc gọi hệ thống cấp thấp một giao diện Swift đẹp hơn.

00:24:08.000 --> 00:24:12.000
Nhưng vẫn còn một số cách dễ dàng để mắc lỗi với API này.

00:24:12.000 --> 00:24:17.000
Ví dụ, bạn có thể thử ghi vào tệp sau khi bạn đã gọi đóng.

00:24:17.000 --> 00:24:24.000
Và bạn phải cẩn thận để luôn đóng nó theo cách thủ công bằng cách gọi phương thức đóng trước khi loại đó đi ra khỏi phạm vi.

00:24:24.000 --> 00:24:27.000
Nếu không, bạn sẽ bị rò rỉ tài nguyên.

00:24:27.000 --> 00:24:35.000
Một giải pháp sẽ là biến nó thành một lớp với một deinit tự động đóng nó khi loại đó nằm ngoài phạm vi.

00:24:35.000 --> 00:24:48.000
Nhưng điều đó có những nhược điểm khác nhau, như phân bổ bộ nhớ bổ sung, thường không phải là vấn đề lớn, ngoại trừ trong một số bối cảnh hệ thống rất hạn chế.

00:24:48.000 --> 00:24:51.000
Các lớp học cũng có ngữ nghĩa tham chiếu.

00:24:51.000 --> 00:25:00.000
Bạn có thể vô tình chia sẻ một loại mô tả tệp trên các luồng, dẫn đến điều kiện cuộc đua hoặc vô tình lưu trữ nó.

00:25:00.000 --> 00:25:04.000
Nhưng chúng ta hãy quay lại và nhìn vào phiên bản cấu trúc.

00:25:04.000 --> 00:25:09.000
Thực sự, cấu trúc này cũng hoạt động giống như một loại tham chiếu.

00:25:09.000 --> 00:25:15.000
Nó chứa một số nguyên tham chiếu đến giá trị thực, đó là một tệp đang mở.

00:25:15.000 --> 00:25:22.000
Tạo một bản sao thuộc loại này cũng có thể dẫn đến việc chia sẻ trạng thái có thể thay đổi không chủ ý trên ứng dụng của bạn theo những cách có thể dẫn đến lỗi.

00:25:22.000 --> 00:25:29.000
Những gì bạn muốn là ngăn chặn khả năng tạo một bản sao của cấu trúc này.

00:25:29.000 --> 00:25:34.000
Các loại Swift, dù là cấu trúc hay lớp, đều có thể sao chép theo mặc định.

00:25:34.000 --> 00:25:37.000
Đây là sự lựa chọn đúng đắn hầu hết thời gian.

00:25:37.000 --> 00:25:51.000
Mặc dù các bản sao không cần thiết quá mức đôi khi có thể là nút cổ chai trong mã của bạn, nhưng tốt hơn là thỉnh thoảng nên dành thời gian tìm những nút thắt cổ chai đó trong các công cụ hơn là liên tục bị làm phiền bởi trình biên dịch yêu cầu bạn phải rõ ràng về những bản sao đó.

00:25:51.000 --> 00:26:03.000
Nhưng đôi khi bản sao ngầm đó không phải là những gì bạn muốn - đặc biệt, khi tạo bản sao của một giá trị có thể dẫn đến các vấn đề về tính chính xác, như với trình bao bọc mô tả tệp của chúng tôi.

00:26:03.000 --> 00:26:15.000
Trong Swift 5.9, bạn có thể làm điều đó với cú pháp mới này có thể được áp dụng cho các khai báo cấu trúc và liệt kê và ngăn chặn khả năng ngầm để sao chép một loại.

00:26:15.000 --> 00:26:26.000
Khi một kiểu không thể sao chép được, bạn có thể cung cấp cho nó một deinit, giống như bạn có thể là một lớp, sẽ chạy khi một giá trị của kiểu đó nằm ngoài phạm vi.

00:26:26.000 --> 00:26:35.000
Các loại không thể sao chép cũng có thể được sử dụng để giải quyết vấn đề gọi đóng và sau đó sử dụng các phương pháp khác.

00:26:35.000 --> 00:26:39.000
Hoạt động đóng có thể được đánh dấu là tiêu thụ.

00:26:39.000 --> 00:26:46.000
Gọi một phương thức hoặc đối số tiêu thụ từ bỏ quyền sở hữu một giá trị cho phương thức bạn đã gọi.

00:26:46.000 --> 00:26:53.000
Vì loại của chúng tôi không thể sao chép được, từ bỏ quyền sở hữu có nghĩa là bạn không thể sử dụng giá trị nữa.

00:26:53.000 --> 00:26:59.000
Theo mặc định, các phương thức trong Swift mượn các đối số của chúng, bao gồm cả bản thân.

00:26:59.000 --> 00:27:12.000
Vì vậy, bạn có thể gọi phương thức ghi, mượn bộ mô tả tệp, sử dụng nó để ghi vào bộ đệm và sau đó, quyền sở hữu giá trị trả về cho người gọi và bạn có thể gọi một phương thức khác, như đóng.

00:27:12.000 --> 00:27:21.000
Nhưng vì đóng cửa đã được đánh dấu là tiêu thụ, không phải là mặc định của việc vay, nó phải là mục đích sử dụng cuối cùng của nó.

00:27:21.000 --> 00:27:32.000
Điều này có nghĩa là, nếu bạn đóng tệp trước và sau đó cố gắng gọi một phương thức khác, như ghi, bạn sẽ nhận được thông báo lỗi tại thời điểm biên dịch, thay vì lỗi thời gian chạy.

00:27:32.000 --> 00:27:37.000
Trình biên dịch cũng sẽ chỉ ra nơi sử dụng tiêu thụ xảy ra.

00:27:37.000 --> 00:27:43.000
Các loại không thể sao chép là một tính năng mới mạnh mẽ cho lập trình cấp hệ thống trong Swift.

00:27:43.000 --> 00:27:46.000
Chúng vẫn đang ở giai đoạn đầu trong quá trình tiến hóa của chúng.

00:27:46.000 --> 00:27:52.000
Các phiên bản sau của Swift sẽ mở rộng trên các loại không thể sao chép trong mã chung.

00:27:52.000 --> 00:27:58.000
Nếu bạn quan tâm đến việc theo dõi cùng với công việc này, nó đang được thảo luận tích cực trên các diễn đàn Swift.

00:27:58.000 --> 00:28:03.000
Doug: Chìa khóa thành công của Swift là khả năng tương tác với Objective-C.

00:28:03.000 --> 00:28:14.000
Ngay từ đầu, các nhà phát triển đã có thể thực hiện các bước gia tăng để áp dụng Swift trong các cơ sở mã hiện có của họ, trộn vào Swift một tệp hoặc mô-đun tại một thời điểm.

00:28:14.000 --> 00:28:18.000
Nhưng chúng tôi biết rất nhiều bạn không chỉ có mã được viết bằng Objective-C.

00:28:18.000 --> 00:28:25.000
Nhiều ứng dụng cũng có logic kinh doanh cốt lõi được triển khai trong C++ và việc giao tiếp với điều đó không hề dễ dàng như vậy.

00:28:25.000 --> 00:28:34.000
Thường thì nó có nghĩa là thêm một lớp bắc cầu thủ công bổ sung, đi từ Swift, qua Objective-C, và sau đó vào C++, và tất cả các con đường trở lại.

00:28:34.000 --> 00:28:40.000
Swift 5.9 giới thiệu khả năng tương tác với các loại và hàm C++ trực tiếp từ Swift.

00:28:40.000 --> 00:28:53.000
Khả năng tương tác C++ hoạt động giống như khả năng tương tác Objective-C luôn có, ánh xạ các API C++ vào các tương đương Swift của chúng mà bạn có thể sử dụng trực tiếp từ mã Swift.

00:28:53.000 --> 00:29:01.000
C++ là một ngôn ngữ lớn với các khái niệm riêng về các ý tưởng như lớp, phương thức, vùng chứa, v.v.

00:29:01.000 --> 00:29:07.000
Trình biên dịch Swift hiểu các thành ngữ C++ phổ biến, vì vậy nhiều loại có thể được sử dụng trực tiếp.

00:29:07.000 --> 00:29:19.000
Ví dụ, kiểu Người này xác định năm hàm thành viên đặc biệt được mong đợi của loại giá trị C++: Sao chép và di chuyển hàm tạo, toán tử gán và trình hủy.

00:29:19.000 --> 00:29:26.000
Trình biên dịch Swift coi đây là một loại giá trị và sẽ tự động gọi đúng hàm thành viên đặc biệt vào đúng thời điểm.

00:29:26.000 --> 00:29:34.000
Ngoài ra, các thùng chứa C++ như vectơ và bản đồ có thể truy cập được dưới dạng bộ sưu tập Swift.

00:29:34.000 --> 00:29:42.000
Kết quả của tất cả những điều này là chúng ta có thể viết mã Swift đơn giản sử dụng trực tiếp các hàm và loại C++.

00:29:42.000 --> 00:29:51.000
Chúng ta có thể lọc qua vectơ của các phiên bản Person, gọi các hàm thành viên C++ và truy cập trực tiếp vào các thành viên dữ liệu.

00:29:51.000 --> 00:29:59.000
Theo hướng khác, việc sử dụng mã Swift từ C++ dựa trên cơ chế tương tự như với Objective-C.

00:29:59.000 --> 00:30:06.000
Trình biên dịch Swift sẽ tạo ra một "tiêu đề được tạo" có chứa chế độ xem C++ trên các API Swift.

00:30:06.000 --> 00:30:15.000
Tuy nhiên, không giống như Objective-C, bạn không cần hạn chế bản thân chỉ sử dụng các lớp Swift được chú thích bằng thuộc tính objc.

00:30:15.000 --> 00:30:26.000
C++ có thể trực tiếp sử dụng hầu hết các loại Swift và các API đầy đủ của chúng, bao gồm các thuộc tính, phương thức và trình khởi tạo, mà không cần bất kỳ chi phí bắc cầu nào.

00:30:26.000 --> 00:30:30.000
Ở đây chúng ta có thể thấy cách C++ có thể sử dụng cấu trúc Điểm của chúng ta.

00:30:30.000 --> 00:30:45.000
Sau khi bao gồm tiêu đề được tạo, C++ có thể gọi trình khởi tạo Swift để tạo các phiên bản Point, gọi các phương thức đột biến và truy cập cả thuộc tính được lưu trữ và tính toán, tất cả mà không có bất kỳ thay đổi nào đối với chính mã Swift.

00:30:45.000 --> 00:30:53.000
Khả năng tương tác C++ của Swift giúp tích hợp Swift với các cơ sở mã C++ hiện có trở nên dễ dàng hơn bao giờ hết.

00:30:53.000 --> 00:31:03.000
Nhiều thành ngữ C++ có thể được thể hiện trực tiếp bằng Swift, thường là tự động, nhưng đôi khi yêu cầu một số chú thích để chỉ ra ngữ nghĩa mong muốn.

00:31:03.000 --> 00:31:19.000
Và Swift APIs có thể được truy cập trực tiếp từ C++, không yêu cầu chú thích hoặc thay đổi mã, giúp bạn có thể áp dụng Swift từng bước trong toàn bộ cơ sở mã bằng cách sử dụng bất kỳ sự kết hợp nào của C, C++ và Objective-C.

00:31:19.000 --> 00:31:26.000
Khả năng tương tác C++ là một câu chuyện đang phát triển, được hướng dẫn bởi nhóm làm việc khả năng tương tác C++.

00:31:26.000 --> 00:31:34.000
Để biết thêm thông tin, vui lòng xem bài nói chuyện "Trộn Swift và C++", hoặc tham gia cùng chúng tôi trong cuộc thảo luận trên diễn đàn Swift.

00:31:34.000 --> 00:31:41.000
Khả năng tương tác ở cấp độ ngôn ngữ thực sự quan trọng, nhưng bạn cũng phải có khả năng xây dựng mã của mình.

00:31:41.000 --> 00:31:53.000
Và việc phải thay thế hệ thống xây dựng hiện tại của bạn bằng Xcode hoặc Trình quản lý gói Swift để thậm chí bắt đầu với Swift có thể là một rào cản lớn như viết lại một lượng lớn mã.

00:31:53.000 --> 00:31:57.000
Đó là lý do tại sao chúng tôi làm việc với cộng đồng CMake để cải thiện hỗ trợ Swift trong CMake.

00:31:57.000 --> 00:32:06.000
Bạn có thể tích hợp mã Swift vào bản dựng CMake của mình bằng cách khai báo Swift là một trong những ngôn ngữ cho dự án và đưa các tệp Swift vào mục tiêu.

00:32:06.000 --> 00:32:19.000
Quan trọng hơn, bạn có thể kết hợp C++ và Swift trong một mục tiêu duy nhất và CMake sẽ đảm bảo biên dịch từng thư riêng biệt và liên kết tất cả các thư viện hỗ trợ và thời gian chạy thích hợp cho cả hai ngôn ngữ.

00:32:19.000 --> 00:32:27.000
Điều này có nghĩa là bạn có thể bắt đầu áp dụng Swift trong các dự án C++ đa nền tảng của mình ngay hôm nay, từng tệp hoặc nhắm mục tiêu theo mục tiêu.

00:32:27.000 --> 00:32:40.000
Chúng tôi cũng đang cung cấp một kho lưu trữ mẫu với các dự án CMake chứa Swift và các mục tiêu C++/Swift hỗn hợp, bao gồm cả việc sử dụng các tiêu đề bắc cầu và được tạo, để giúp bạn bắt đầu.

00:32:40.000 --> 00:32:50.000
Một vài năm trước, chúng tôi đã giới thiệu một mô hình đồng thời mới vào Swift dựa trên các khối xây dựng của async/await, đồng thời có cấu trúc và các tác nhân.

00:32:50.000 --> 00:32:57.000
Mô hình đồng thời của Swift là một mô hình trừu tượng, có thể được điều chỉnh cho các môi trường và thư viện khác nhau.

00:32:57.000 --> 00:33:03.000
Mô hình trừu tượng có hai phần chính: Nhiệm vụ và diễn viên.

00:33:03.000 --> 00:33:09.000
Các nhiệm vụ đại diện cho một đơn vị công việc tuần tự có thể chạy về mặt khái niệm ở bất cứ đâu.

00:33:09.000 --> 00:33:16.000
Các nhiệm vụ có thể bị đình chỉ bất cứ khi nào có "chờ đợi" trong chương trình, và sau đó tiếp tục khi nhiệm vụ có thể tiếp tục.

00:33:16.000 --> 00:33:23.000
Các tác nhân là một cơ chế đồng bộ hóa cung cấp quyền truy cập độc quyền lẫn nhau vào trạng thái biệt lập.

00:33:23.000 --> 00:33:29.000
Bước vào một diễn viên từ bên ngoài yêu cầu "chờ đợi" vì nó có thể tạm dừng nhiệm vụ.

00:33:29.000 --> 00:33:39.000
Các nhiệm vụ và tác nhân được tích hợp vào mô hình ngôn ngữ trừu tượng, nhưng trong mô hình đó, chúng có thể được thực hiện theo nhiều cách khác nhau để phù hợp với các môi trường khác nhau.

00:33:39.000 --> 00:33:43.000
Các nhiệm vụ được thực hiện trên nhóm đồng thời toàn cầu.

00:33:43.000 --> 00:33:48.000
Làm thế nào mà nhóm đồng thời toàn cầu quyết định lên lịch làm việc tùy thuộc vào môi trường.

00:33:48.000 --> 00:33:58.000
Đối với các nền tảng của Apple, thư viện Dispatch cung cấp lịch trình được tối ưu hóa cho toàn bộ hệ điều hành và đã được điều chỉnh rộng rãi cho từng nền tảng.

00:33:58.000 --> 00:34:04.000
Trong các môi trường hạn chế hơn, chi phí của bộ lập lịch đa luồng có thể không được chấp nhận.

00:34:04.000 --> 00:34:10.000
Ở đó mô hình đồng thời của Swift được triển khai với một hàng đợi hợp tác đơn luồng.

00:34:10.000 --> 00:34:19.000
Cùng một mã Swift hoạt động trong cả hai môi trường vì mô hình trừu tượng đủ linh hoạt để ánh xạ đến các môi trường thời gian chạy đa dạng.

00:34:19.000 --> 00:34:28.000
Ngoài ra, khả năng tương tác với các thư viện dựa trên cuộc gọi lại đã được tích hợp vào hỗ trợ không đồng bộ/chờ đợi của Swift ngay từ đầu.

00:34:28.000 --> 00:34:35.000
Các hoạt động withCheckedContinuation cho phép người ta tạm dừng một nhiệm vụ và sau đó tiếp tục nó sau đó để phản hồi cuộc gọi lại.

00:34:35.000 --> 00:34:41.000
Điều này cho phép tích hợp với các thư viện hiện có tự quản lý các nhiệm vụ.

00:34:41.000 --> 00:34:51.000
Việc triển khai tiêu chuẩn của các tác nhân trong thời gian chạy đồng thời Swift là một hàng đợi các tác vụ không cần khóa để thực hiện trên tác nhân, nhưng nó không phải là cách triển khai khả thi duy nhất.

00:34:51.000 --> 00:35:00.000
Trong một môi trường hạn chế hơn, người ta có thể không có nguyên tử, và thay vào đó có thể sử dụng một nguyên thủy đồng thời khác như spinlocks.

00:35:00.000 --> 00:35:09.000
Nếu môi trường đó là đơn luồng, không cần đồng bộ hóa, nhưng mô hình diễn viên vẫn duy trì mô hình đồng thời trừu tượng cho chương trình bất kể.

00:35:09.000 --> 00:35:15.000
Bạn vẫn có thể mang cùng một mã đó đến một môi trường khác có nhiều luồng.

00:35:15.000 --> 00:35:22.000
Với Swift 5.9, các trình thực thi diễn viên tùy chỉnh cho phép một diễn viên cụ thể thực hiện cơ chế đồng bộ hóa của riêng nó.

00:35:22.000 --> 00:35:27.000
Điều này làm cho các diễn viên linh hoạt hơn và thích nghi với môi trường hiện có.

00:35:27.000 --> 00:35:30.000
Hãy lấy một ví dụ.

00:35:30.000 --> 00:35:34.000
Ở đây chúng tôi xem xét một diễn viên quản lý kết nối cơ sở dữ liệu.

00:35:34.000 --> 00:35:42.000
Swift đảm bảo quyền truy cập độc quyền lẫn nhau vào bộ nhớ của tác nhân này, vì vậy sẽ không có bất kỳ quyền truy cập đồng thời nào vào cơ sở dữ liệu.

00:35:42.000 --> 00:35:48.000
Tuy nhiên, điều gì sẽ xảy ra nếu bạn cần kiểm soát nhiều hơn đối với cách thức cụ thể mà đồng bộ hóa được thực hiện?

00:35:48.000 --> 00:35:57.000
Ví dụ, điều gì sẽ xảy ra nếu bạn muốn sử dụng một hàng đợi điều phối cụ thể cho kết nối cơ sở dữ liệu của mình, có lẽ vì hàng đợi đó được chia sẻ với mã khác chưa áp dụng các tác nhân?

00:35:57.000 --> 00:36:01.000
Với những người thực thi diễn viên tùy chỉnh, bạn có thể.

00:36:01.000 --> 00:36:13.000
Ở đây chúng tôi đã thêm một hàng đợi điều phối nối tiếp cho tác nhân của chúng tôi và triển khai thuộc tính người thực thi không thuộc sở hữu tạo ra người thực thi tương ứng với hàng đợi điều phối đó.

00:36:13.000 --> 00:36:20.000
Với sự thay đổi này, tất cả sự đồng bộ hóa cho các trường hợp diễn viên của chúng tôi sẽ xảy ra thông qua hàng đợi đó.

00:36:20.000 --> 00:36:29.000
Khi bạn "chờ đợi" cuộc gọi cắt tỉaOldEntries từ bên ngoài diễn viên, điều này bây giờ sẽ thực hiện một công văn không đồng bộ trên hàng đợi tương ứng.

00:36:29.000 --> 00:36:43.000
Điều này cho phép bạn kiểm soát nhiều hơn cách các diễn viên riêng lẻ cung cấp đồng bộ hóa và thậm chí cho phép bạn đồng bộ hóa một diễn viên với mã khác chưa sử dụng diễn viên, có lẽ vì nó được viết bằng Objective-C hoặc C++.

00:36:43.000 --> 00:36:51.000
Việc đồng bộ hóa các tác nhân thông qua hàng đợi điều phối được thực hiện bởi vì hàng đợi điều phối phù hợp với giao thức SerialExecutor mới.

00:36:51.000 --> 00:37:07.000
Bạn có thể cung cấp cơ chế đồng bộ hóa của riêng mình để sử dụng với các tác nhân bằng cách xác định một loại mới phù hợp với giao thức này chỉ có một vài thao tác cốt lõi: Kiểm tra xem mã đã được thực thi trong ngữ cảnh của người thực thi hay chưa.

00:37:07.000 --> 00:37:11.000
Ví dụ, chúng ta có đang chạy trên luồng chính không?

00:37:11.000 --> 00:37:18.000
Trích xuất một tham chiếu không thuộc sở hữu cho người thực thi để cho phép truy cập vào nó mà không cần lưu lượng truy cập đếm tham chiếu dư thừa.

00:37:18.000 --> 00:37:24.000
Và hoạt động cốt lõi nhất, enqueue, có quyền sở hữu một "công việc" thực thi.

00:37:24.000 --> 00:37:29.000
Một công việc là một phần của nhiệm vụ không đồng bộ cần chạy đồng bộ trên người thực thi.

00:37:29.000 --> 00:37:38.000
Tại thời điểm mà enqueue được gọi, người thực thi có trách nhiệm chạy công việc đó tại một thời điểm nào đó khi không có mã nào khác chạy trên trình thực thi nối tiếp.

00:37:38.000 --> 00:37:45.000
Ví dụ, enqueue cho một hàng đợi công văn sẽ gọi công văn không đồng bộ trên hàng đợi đó.

00:37:45.000 --> 00:37:55.000
Swift Concurrency đã được sử dụng trong vài năm nay và mô hình trừu tượng của nó bao gồm các tác vụ và diễn viên bao gồm một loạt các tác vụ lập trình đồng thời.

00:37:55.000 --> 00:38:05.000
Bản thân mô hình trừu tượng khá linh hoạt, giúp nó thích ứng với các môi trường thực thi khác nhau, từ iPhone đến Đồng hồ Apple, đến máy chủ và hơn thế nữa.

00:38:05.000 --> 00:38:13.000
Nó cũng cho phép tùy chỉnh tại các điểm chính để cho phép nó tương tác với mã chưa áp dụng đầy đủ Swift Concurrency.

00:38:13.000 --> 00:38:20.000
Để biết thêm thông tin, vui lòng xem bài nói chuyện "Hậu trường" của chúng tôi, cũng như "Ngoài những điều cơ bản về Đồng thời có cấu trúc."

00:38:20.000 --> 00:38:29.000
Tôi muốn kết thúc với một nghiên cứu điển hình về Swift hoạt động trong một môi trường rất khác với các ứng dụng iOS hoặc MacOS nơi chúng ta đã quen nhìn thấy nó.

00:38:29.000 --> 00:38:44.000
FoundationDB là một cơ sở dữ liệu phân tán, cung cấp một giải pháp có thể mở rộng cho các kho lưu trữ khóa-giá trị rất lớn chạy trên phần cứng hàng hóa và hỗ trợ nhiều nền tảng khác nhau, bao gồm MacOS, Linux và Windows.

00:38:44.000 --> 00:38:50.000
FoundationDB là một dự án mã nguồn mở với cơ sở mã lớn được viết bằng C++.

00:38:50.000 --> 00:39:01.000
Mã không đồng bộ nhiều, với dạng tác nhân phân tán và thời gian chạy riêng cung cấp một môi trường mô phỏng xác định cực kỳ quan trọng cho mục đích thử nghiệm.

00:39:01.000 --> 00:39:11.000
FoundationDB đang tìm cách hiện đại hóa cơ sở mã của họ và nhận thấy Swift phù hợp với hiệu suất, độ an toàn và độ rõ ràng của mã.

00:39:11.000 --> 00:39:14.000
Viết lại hoàn toàn sẽ là một nỗ lực lớn, đầy rủi ro.

00:39:14.000 --> 00:39:21.000
Thay vào đó, chúng tôi tận dụng khả năng tương tác của Swift để tích hợp vào cơ sở mã hiện có.

00:39:21.000 --> 00:39:29.000
Ví dụ, đây là một phần của việc triển khai C++ của diễn viên "dữ liệu chính" của FoundationDB.

00:39:29.000 --> 00:39:33.000
Có rất nhiều điều đang diễn ra ở đây, và bạn không cần phải hiểu tất cả C++ này.

00:39:33.000 --> 00:39:38.000
Tuy nhiên, tôi muốn chỉ ra một vài khía cạnh chính của mã.

00:39:38.000 --> 00:39:48.000
Đầu tiên, C++ không có async/await, vì vậy FoundationDB có cách tiếp cận giống như bộ tiền xử lý của riêng họ để mô phỏng nó.

00:39:48.000 --> 00:39:56.000
Giống như nhiều cơ sở mã C++, họ đã triển khai loại C++ Future của riêng mình để quản lý các tác vụ không đồng bộ.

00:39:56.000 --> 00:40:01.000
Chúng kết hợp với tin nhắn rõ ràng để gửi phản hồi cho các yêu cầu.

00:40:01.000 --> 00:40:07.000
Lưu ý việc ghép nối cẩn thận việc gửi câu trả lời với việc trả về từ chức năng.

00:40:07.000 --> 00:40:13.000
Cuối cùng, FoundationDB có các con trỏ thông minh đếm tham chiếu của riêng mình để giúp quản lý bộ nhớ tự động.

00:40:13.000 --> 00:40:20.000
Chúng ta có thể thực hiện toàn bộ điều này một cách sạch sẽ hơn nhiều trong Swift.

00:40:20.000 --> 00:40:24.000
Điều đó tốt hơn.

00:40:24.000 --> 00:40:28.000
Chức năng này có thể được triển khai trực tiếp như một chức năng không đồng bộ trong Swift.

00:40:28.000 --> 00:40:36.000
Chúng tôi có một loại trả về bình thường và các câu lệnh trả về bình thường để cung cấp phản hồi cho yêu cầu này, vì vậy bạn không bao giờ có thể không đồng bộ.

00:40:36.000 --> 00:40:43.000
Chúng tôi có một "chờ đợi" để chỉ ra điểm tạm ngưng theo cách tương tự như tất cả các mã Swift không đồng bộ khác.

00:40:43.000 --> 00:40:51.000
Và mã Swift này liên kết với loại Tương lai C++ được điều chỉnh bằng cách sử dụng tiếp tục.

00:40:51.000 --> 00:40:54.000
Chúng tôi đang sử dụng một số loại C++ ở đây.

00:40:54.000 --> 00:40:59.000
Kiểu MasterData trong C++ đang sử dụng một con trỏ thông minh đếm tham chiếu.

00:40:59.000 --> 00:41:09.000
Bằng cách chú thích loại trong C++, trình biên dịch Swift có thể sử dụng loại này giống như bất kỳ lớp nào khác, tự động quản lý số lượng tham chiếu cho chúng tôi.

00:41:09.000 --> 00:41:16.000
Các loại khác, chẳng hạn như các loại yêu cầu và trả lời, là các loại giá trị C++ đang được sử dụng trực tiếp trong Swift.

00:41:16.000 --> 00:41:19.000
Và khả năng tương tác đi theo cả hai cách.

00:41:19.000 --> 00:41:28.000
Chức năng không đồng bộ này, và thực sự, tất cả các công việc được giới thiệu bởi mô hình đồng thời Swift, chạy trên thời gian chạy xác định hiện có của FoundationDB.

00:41:28.000 --> 00:41:38.000
Vì vậy, chúng tôi có thể nhận được lợi ích của Swift ở nơi chúng tôi muốn, giao tiếp với C++ hiện có để cho phép áp dụng dần dần trong suốt.

00:41:38.000 --> 00:41:41.000
Trong phiên này, chúng tôi đã bao quát rất nhiều nền tảng.

00:41:41.000 --> 00:41:51.000
Chúng tôi đã mô tả các tính năng như gói tham số và macro cho phép các API biểu cảm hơn và có thể giúp bạn viết mã tốt hơn nhanh hơn.

00:41:51.000 --> 00:42:01.000
Chúng tôi đã nói về việc sử dụng Swift trong mã nhạy cảm với hiệu suất và giới thiệu các loại không thể sao chép để cung cấp quản lý tài nguyên mà không cần chi phí đếm tham chiếu.

00:42:01.000 --> 00:42:15.000
Sau đó, chúng tôi đi sâu vào khả năng tương tác C++, cung cấp hỗ trợ cho việc sử dụng API C++ trong Swift và ngược lại, giúp mang lại lợi ích của Swift cho nhiều mã của bạn dễ dàng hơn.

00:42:15.000 --> 00:42:26.000
Cuối cùng, chúng tôi đã nói về cách mô hình đồng thời linh hoạt của Swift có thể thích ứng với vô số môi trường trên các thiết bị và ngôn ngữ để giúp đồng thời dễ dàng và an toàn hơn.

00:42:26.000 --> 00:42:41.000
Các gói thông số, macro, các loại không thể sao chép và tất cả các cải tiến ngôn ngữ khác trong Swift 5.9 đã được thiết kế và phát triển công khai thông qua quy trình Swift Evolution và phản hồi của cộng đồng rất quan trọng trong việc định hình các tính năng này.

00:42:41.000 --> 00:42:54.000
Swift 5.9 là đỉnh cao của vô số đóng góp từ các thành viên trong cộng đồng Swift, bao gồm các cuộc thảo luận thiết kế tích cực, báo cáo lỗi, yêu cầu kéo, nội dung giáo dục và hơn thế nữa.

00:42:54.000 --> 00:42:59.000
Cảm ơn bạn đã biến Swift 5.9 thành bản phát hành tuyệt vời.

00:42:59.000 --> 23:59:59.000
♪ ♪

