WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:14.000
カイル：こんにちは、私はKyleです。SwiftUIチームのメンバーです。

00:00:14.000 --> 00:00:18.000
アニメーションは、現代のアプリデザインの重要な要素です。

00:00:18.000 --> 00:00:24.000
上品に適用すると、UIに明快さと生命の両方をもたらすことができます。

00:00:24.000 --> 00:00:31.000
アプリにアニメーションを簡単に追加することは、SwiftUIの開発を始めたとき、私たちの中核的な動機の1つでした。

00:00:31.000 --> 00:00:35.000
SwiftUIがそのように形作られている大きな理由です。

00:00:35.000 --> 00:00:45.000
このセッションは、SwiftUIの強力なアニメーション機能と、それらがどのように連携して印象的な視覚効果を生み出すかの概要です。

00:00:45.000 --> 00:01:03.000
SwiftUIがビューのレンダリングを更新し、Animatableを使用してアニメーション化するものを決定し、アニメーションを使用して時間の経過とともに値を補間し、トランザクションを使用して現在の更新のコンテキストを伝播する方法について説明します。

00:01:03.000 --> 00:01:12.000
近年、私の同僚の間で、誰が最高の毛皮を作るか、またはそれほど毛皮ではない仲間を作るかについて議論がありました。

00:01:12.000 --> 00:01:18.000
合意に達することができるかどうか気になったので、世論調査を行うためのアプリを作りました。

00:01:18.000 --> 00:01:21.000
各ペットに投票するボタンがあります。

00:01:21.000 --> 00:01:28.000
タップすると、投票数が変更され、アバターがスライドして現在の順位を反映します。

00:01:28.000 --> 00:01:34.000
前回の世論調査では、適切なように、猫が1位になりましたが、狭かっただけです。

00:01:34.000 --> 00:01:41.000
この次の投票を純粋に偶然に任せるには賭け金が高すぎるので、新しい機能を追加します。

00:01:41.000 --> 00:01:49.000
タップすると、私が選んだアバターは、適切なペットに投票するように人々を後押しするためにスケールアップします。

00:01:49.000 --> 00:01:52.000
そして、もう一度タップして縮小することができます。

00:01:52.000 --> 00:01:58.000
これはすでにかなりうまく機能していますが、アニメーションの方がずっと良いでしょう。

00:01:58.000 --> 00:02:08.000
それを追加する前に、SwiftUIがビューのレンダリングをどのように更新するかをトレースして、ビューの更新の解剖学をよりよく理解します。

00:02:08.000 --> 00:02:14.000
この演習では、孤立してペットのアバタービューに焦点を当てます。

00:02:14.000 --> 00:02:20.000
SwiftUIは、この選択された状態変数のように、ビューの依存関係を追跡します。

00:02:20.000 --> 00:02:26.000
タップのようなイベントが入ってくると、更新トランザクションが開かれます。

00:02:26.000 --> 00:02:40.000
依存関係のいずれかが変更された場合、ビューは無効になり、トランザクションの終了時に、フレームワークはレンダリングを更新するために新しい値を生成するためにボディを呼び出します。

00:02:40.000 --> 00:02:49.000
このビューの本体は、タップジェスチャー、スケール効果、画像で構成されています。

00:02:49.000 --> 00:02:58.000
舞台裏では、SwiftUIは、ビューとそのデータの寿命を管理する長寿命の依存関係グラフを維持しています。

00:02:58.000 --> 00:03:04.000
属性と呼ばれるこのグラフの各ノードは、UIのきめ細かい部分にマップされます。

00:03:04.000 --> 00:03:11.000
選択した状態がtrueに変更されると、これらのダウンストリーム属性のそれぞれの値が古くなりました。

00:03:11.000 --> 00:03:22.000
新しいビュー値を一度に1層ずつラッピングすることで更新されます。

00:03:22.000 --> 00:03:30.000
対応するグラフ属性が更新されると、ビューの本文値は破棄されます。

00:03:30.000 --> 00:03:36.000
最後に、グラフはあなたに代わって描画コマンドを発行してレンダリングを更新します。

00:03:36.000 --> 00:03:43.000
属性の寿命を視覚化するために、グラフだけを拡大します。

00:03:43.000 --> 00:03:46.000
属性は初期値で生まれます。

00:03:46.000 --> 00:03:50.000
イベントが入り、更新トランザクションが開きます。

00:03:50.000 --> 00:03:53.000
上流の依存関係が変わります。

00:03:53.000 --> 00:03:55.000
フレームワークはボディを呼び出します。

00:03:55.000 --> 00:03:58.000
属性の値が更新されます。

00:03:58.000 --> 00:04:00.000
取引は終了します。

00:04:00.000 --> 00:04:08.000
このようにして、グラフ内の各属性の現在の値は時間の経過とともに進化します。

00:04:08.000 --> 00:04:10.000
だから、それはビューの更新の解剖学です。

00:04:10.000 --> 00:04:13.000
では、アニメーションを追加します。

00:04:13.000 --> 00:04:23.000
状態変更を中心にアニメーションでラップすると、タップジェスチャーのクロージャが起動すると、トランザクションのアニメーションが設定されます。

00:04:23.000 --> 00:04:29.000
次に、選択がトグルされ、下流の属性が無効になります。

00:04:29.000 --> 00:04:36.000
以前と同様に、ボディは新しい属性値を提供するために呼び出されます。

00:04:36.000 --> 00:04:37.000
そして、これが面白くなるところです。

00:04:37.000 --> 00:04:43.000
scaleEffectは特別な属性であり、「animatable属性」です。

00:04:43.000 --> 00:04:51.000
Animatable属性の値が変更されると、トランザクションにアニメーションが設定されているかどうかをチェックします。

00:04:51.000 --> 00:05:00.000
もしそうなら、コピーを作り、アニメーションを使用して、時間が経つにつれて古い値から新しい値に補間します。

00:05:00.000 --> 00:05:06.000
scaleEffect animatable属性を拡大して、これがどのように展開されるかを調べます。

00:05:06.000 --> 00:05:13.000
最初に気づくべきことは、アニメーション可能な属性は概念的にモデル値とプレゼンテーション値の両方を持っているということです。

00:05:13.000 --> 00:05:16.000
今、彼らは同じです。

00:05:16.000 --> 00:05:22.000
その後、イベントが入り、トランザクションが開かれ、今回はアニメーションで開かれます。

00:05:22.000 --> 00:05:28.000
状態が変更され、bodyが呼び出されて古い属性値が更新されます。

00:05:28.000 --> 00:05:37.000
値が変更されたため、属性はアニメーションのローカルコピーを作り、現在のプレゼンテーション値を計算します。

00:05:37.000 --> 00:05:47.000
SwiftUIは、属性グラフに実行中のアニメーションが含まれている場合を知っており、適切なアニメーション可能な属性を呼び込んで次のフレームを生成します。

00:05:47.000 --> 00:05:52.000
scaleEffectのような組み込みのアニメーション可能な属性の場合、SwiftUIは非常に効率的です。

00:05:52.000 --> 00:05:59.000
ビューコードを呼び出すことなく、メインスレッドからこの作業を行うことができます。

00:05:59.000 --> 00:06:02.000
これが動作中のアニメーションです。

00:06:02.000 --> 00:06:05.000
いいね。

00:06:05.000 --> 00:06:14.000
誰かが「アニメーション」という言葉を使うとき、彼らはおそらくビューが時間の経過とともに変化する方法の全体的な視覚体験を指しているでしょう。

00:06:14.000 --> 00:06:22.000
これまでに取り上げたことは、SwiftUIでは、全体的な視覚体験に貢献する2つの直交側面があるということです。

00:06:22.000 --> 00:06:33.000
scaleEffectのようなアニメーション可能な属性は、アニメーション化されるデータを決定し、アニメーションはそのデータが時間の経過とともにどのように変化するかを決定します。

00:06:33.000 --> 00:06:40.000
アニメーション化するものを決定するAnimatableから始めて、これらのそれぞれを順番に深く掘り下げます。

00:06:40.000 --> 00:06:46.000
SwiftUIは、Animatableプロトコルに準拠したすべてのビューのanimatable属性を構築します。

00:06:46.000 --> 00:06:53.000
唯一の要件は、ビューがアニメーション化したいデータの読み取り書き込みベクトルを定義することです。

00:06:53.000 --> 00:06:57.000
データはVectorArithmeticに準拠している必要があります。

00:06:57.000 --> 00:07:03.000
VectorArithmeticは、数学のクラスのベクトルの教科書の定義と一致します。

00:07:03.000 --> 00:07:08.000
ベクトル加算とスカラー乗算をサポートしています。

00:07:08.000 --> 00:07:12.000
錆びているか、ベクトルに精通していない場合は、落胆しないでください。

00:07:12.000 --> 00:07:23.000
ベクトルは基本的に固定長の数字のリストであり、SwiftUIアニメーションの場合、ベクトルを扱う目的は、主にそのリストの長さを抽象化することです。

00:07:23.000 --> 00:07:36.000
たとえば、CGFloatとDoubleは1次元ベクトルであり、CGPointとCGSizeは2次元ベクトルを定義し、CGRectは4次元ベクトルを定義します。

00:07:36.000 --> 00:07:45.000
ベクトルを扱うことで、SwiftUIは単一の汎用実装でこれらすべてのタイプなどをアニメーション化することができます。

00:07:45.000 --> 00:07:53.000
これまでのところ、シンプルにするために、私はスケールエフェクトを1次元スケールファクターであるかのように表現しました。

00:07:53.000 --> 00:07:58.000
1次元スケールエフェクトのアニメーション可能な適合性は簡単です。

00:07:58.000 --> 00:08:02.000
そのanimatableDataは単なるCGFloatです。

00:08:02.000 --> 00:08:13.000
実際には、scaleEffectを使用すると、変換の幅、高さ、および相対的なアンカーポイントを個別に設定できます。

00:08:13.000 --> 00:08:26.000
したがって、scaleEffectは実際にアニメーション可能なデータの4次元ベクトル、幅と高さのスケールのCGSizeを定義し、相対アンカーのUnitPointとペアになっています。

00:08:26.000 --> 00:08:31.000
AnimatablePairは、2つのベクトルを1つの大きなベクトルに融合させます。

00:08:31.000 --> 00:08:34.000
それはパブリックタイプで、あなたも使うことができます。

00:08:34.000 --> 00:08:40.000
あなた自身の見解の1つをAnimatableに適合させている場合、それは役に立つかもしれません。

00:08:40.000 --> 00:08:52.000
scaleEffectは、SwiftUIに組み込まれている多くのアニメーション可能な視覚効果の1つにすぎないため、ほとんどの場合、Animatableは直接使用する必要があるAPIではありません。

00:08:52.000 --> 00:09:00.000
しかし、まれに、高度なユースケースでは、あなた自身の見解の1つをAnimatableに適合させる必要があります。

00:09:00.000 --> 00:09:08.000
カスタムRadialLayoutを使用して円の弧に沿ってサブビューを分散するペットのポディウムビューを考えてみましょう。

00:09:08.000 --> 00:09:17.000
デフォルトでは、アニメーション内のオフセット角度を変更すると、ペットのアバターが直線に沿って新しい位置にアニメーション化されます。

00:09:17.000 --> 00:09:24.000
ペットが近道を取り、円の内部に不法侵入していることに注目してください。

00:09:24.000 --> 00:09:27.000
それは私が望んでいることではありません。

00:09:27.000 --> 00:09:32.000
代わりに、私のアバターを円の周囲に沿ってアニメーション化したい。

00:09:32.000 --> 00:09:42.000
Podiumをアニメーション化可能に適合させ、オフセット角度をアニメーション化可能なデータとして使用することで、この効果を得ることができます。

00:09:42.000 --> 00:09:46.000
なぜこれがそのような異なる効果をもたらすのですか?

00:09:46.000 --> 00:09:58.000
説明するために、直線に沿ってアバターをアニメーション化するデフォルトの動作から始めて、ポディウムビューの各バージョンのアニメーションアップデートを順を追って説明します。

00:09:58.000 --> 00:10:04.000
表彰台の体はRadialLayoutと3つのアバターで構成されています。

00:10:04.000 --> 00:10:14.000
トランザクションが開くと、オフセット角度が変更された場合、ボディが呼び出され、古いダウンストリーム属性値が更新されます。

00:10:14.000 --> 00:10:19.000
次に、レイアウトが実行され、各サブビューの位置が更新されます。

00:10:19.000 --> 00:10:24.000
したがって、これはデフォルトバージョンのアニメーションアップデートのようなものです。

00:10:24.000 --> 00:10:35.000
アクティブなアニメーション可能なデータは、カルテシアン座標空間に補間するビュー位置CGPointであり、各アバターが直線に沿って移動することを意味します。

00:10:35.000 --> 00:10:48.000
カスタムバージョンでは、PodiumをAnimatableに適合させると、そのボディがアクティブanitable属性になり、オフセット角度をanimatableデータとして変更されます。

00:10:48.000 --> 00:10:52.000
その結果、各アバターはどのように円弧に沿って移動しますか?

00:10:52.000 --> 00:11:04.000
このカスタムバージョンでは、アニメーションのすべてのフレームに対して、ボディは新しいオフセット角度でSwiftUIによって呼び出され、レイアウトが再実行されます。

00:11:04.000 --> 00:11:15.000
これは非常に強力で、時には、カスタムレイアウトや描画コードをアニメーション化しているときのように、それはあなたがしようとしている効果を達成する唯一の方法かもしれません。

00:11:15.000 --> 00:11:26.000
カスタムアニメーションの適合性は、アニメーションのすべてのフレームでボディを実行するため、組み込みの効果よりもアニメーションにはるかに高価になる可能性があることに注意してください。

00:11:26.000 --> 00:11:34.000
したがって、組み込みエフェクトを使用する効果を達成できない場合にのみ、このツールを使用してください。

00:11:34.000 --> 00:11:41.000
次に、アニメーション、時間の経過とともにアニメーション可能なデータを補間する一般的なアルゴリズムについて説明します。

00:11:41.000 --> 00:11:49.000
以前、withAnimationで状態の変化をラップして、ペットアバタービューにアニメーションを追加しました。

00:11:49.000 --> 00:11:58.000
弾力のあるスプリングのような明示的なアニメーションを渡すことで、これをカスタマイズできます。

00:11:58.000 --> 00:12:02.000
SwiftUIには、たくさんの強力なアニメーションが組み込まれています。

00:12:02.000 --> 00:12:16.000
それらは大まかに3つのバケットに分類できます。タイミングカーブアニメーション、スプリングアニメーション、および基本アニメーションを変更する高次アニメーションです。

00:12:16.000 --> 00:12:22.000
タイミングカーブアニメーションは、おそらくあなたが最もよく知っているアニメーションのカテゴリです。

00:12:22.000 --> 00:12:27.000
例えば、easeInOutはタイミングカーブアニメーションです。

00:12:27.000 --> 00:12:34.000
すべてのタイミングカーブアニメーションは、アニメーションの速度と持続時間を定義する曲線を取ります。

00:12:34.000 --> 00:12:39.000
タイミング曲線は、ベジェ制御ポイントを使用して作成できます。

00:12:39.000 --> 00:12:47.000
開始と終了のコントロールポイントを調整することで、アニメーションの初期速度と最終速度を変更します。

00:12:47.000 --> 00:12:58.000
UnitCurveタイプは、スタンドアロンを使用して、0から1の間の相対的な点で値と速度を計算できます。

00:12:58.000 --> 00:13:15.000
SwiftUIには、リニア、イージーイン、イージーアウト、イージーインアウトなど、多くのタイミングカーブプリセットが組み込まれています。

00:13:15.000 --> 00:13:22.000
すべてのタイミングカーブアニメーションは、カスタム期間を指定することもできます。

00:13:22.000 --> 00:13:31.000
アニメーションの次のカテゴリであるスプリングは、スプリングシミュレーションを実行して、特定の時点での値を決定します。

00:13:31.000 --> 00:13:39.000
質量、剛性、減衰など、スプリングを指定する伝統的な方法に精通しているかもしれません。

00:13:39.000 --> 00:13:45.000
しかし、私たちはこれらの方法が特に直感的であることを発見したことがないので、私たちは新しい方法を発明しました。

00:13:45.000 --> 00:13:52.000
アニメーションの知覚された持続時間と、スプリングの弾力性を指定するだけです。

00:13:52.000 --> 00:13:56.000
それははるかに親しみやすいです。

00:13:56.000 --> 00:14:07.000
UnitCurveと同様に、スプリングタイプはスタンドアロンで使用して、特定の時間におけるスプリングの値と速度を計算できます。

00:14:07.000 --> 00:14:23.000
SwiftUIには、バウンスのないスムース、少量のバウンス、大量のバウンスを持つバウンシーの3つのスプリングプリセットが組み込まれています。

00:14:23.000 --> 00:14:33.000
春のアニメーションをパラメータ化するのが不快な場合、これらのプリセットは、気分の良いものを得るための信頼できる方法です。

00:14:33.000 --> 00:14:40.000
各プリセットを調整して、持続時間を調整したり、弾力性を微調整したりすることもできます。

00:14:40.000 --> 00:14:50.000
速度を維持し、自然に休むことで、UIに有機的な感触を与えるため、春のアニメーションを使用することを強くお勧めします。

00:14:50.000 --> 00:15:04.000
実際、私たちは春のアニメーションの利点について非常に強く感じているので、iOS 17と整列されたリリースで裸のアニメーションを使用すると、スムーズな春を新しいデフォルトにしました。

00:15:04.000 --> 00:15:09.000
アニメーションの最後のカテゴリ、より高い順序は、基本アニメーションを変更します。

00:15:09.000 --> 00:15:13.000
彼らはそれを遅くしたり、スピードアップしたりすることができます。

00:15:13.000 --> 00:15:17.000
基本アニメーションが始まる前に遅延を追加できます。

00:15:17.000 --> 00:15:27.000
そして、彼らはベースアニメーションを何回でも繰り返すことができ、オプションでフォワードプレイとリバースプレイの間で切り替えることができます。

00:15:27.000 --> 00:15:34.000
そして今、私たちはアニメーションの全く新しいカテゴリを導入しています:カスタムアニメーション。

00:15:34.000 --> 00:15:44.000
CustomAnimationプロトコルを使用すると、SwiftUIに組み込まれているすべてのアニメーションを実装するために使用するのと同じ低レベルの汎用エントリポイントにアクセスできます。

00:15:44.000 --> 00:15:53.000
CustomAnimationプロトコルには、animate、shouldMerge、速度の3つの要件があります。

00:15:53.000 --> 00:15:55.000
アニメーションに焦点を当てることから始めます。

00:15:55.000 --> 00:15:59.000
shouldMergeと速度はオプションの要件です。

00:15:59.000 --> 00:16:02.000
後で彼らに戻ります。

00:16:02.000 --> 00:16:16.000
Animateは、アニメーション化するためのベクトル、アニメーションが始まってから経過した時間、および追加のアニメーション状態を含むコンテキストに渡されます。

00:16:16.000 --> 00:16:22.000
Animateはアニメーションの現在の値を返します。アニメーションが終了した場合はnilを返します。

00:16:22.000 --> 00:16:25.000
この値ベクトルはどこから来たのですか?

00:16:25.000 --> 00:16:28.000
それはビューのアニメーション可能なデータから来ています。

00:16:28.000 --> 00:16:32.000
ペットアバタービューでは、それがスケール効果です。

00:16:32.000 --> 00:16:41.000
scaleEffectのアニメーション可能なデータは、2次元の幅と高さのスケールを含む4次元ベクトルであることを思い出してください。

00:16:41.000 --> 00:16:51.000
アバターを選択すると、1×1のスケールファクターから1.5×1.5のスケールファクターにアニメーション化されます。

00:16:51.000 --> 00:17:02.000
ベクトル加算とスカラー乗算操作により、SwiftUIはこれら2つのベクトルを互いに減算して、それらの間のデルタを計算することができます。

00:17:02.000 --> 00:17:06.000
このデルタは実際にアニメーション化されているものです。

00:17:06.000 --> 00:17:18.000
これは、実際には、scaleEffect animatable属性で実行されているアニメーションは、1から1.5ではなく、0から0.5に補間していることを意味します。

00:17:18.000 --> 00:17:22.000
とりわけ、これにより、アニメーションメソッドを実装するのがより便利になります。

00:17:22.000 --> 00:17:25.000
お見せしましょう。

00:17:25.000 --> 00:17:33.000
補間する期間によって設定された線形タイミング曲線アニメーションを実装します。

00:17:33.000 --> 00:17:38.000
アニメーションは、アニメーション化するためにデルタベクトルを渡されたことを思い出してください。

00:17:38.000 --> 00:17:45.000
スカラー乗算を使用して、経過した期間の割合でベクトルをスケーリングできます。

00:17:45.000 --> 00:17:52.000
そして、完全な期間が経過したら、アニメーションが終了し、削除できることを示すためにnilを返します。

00:17:52.000 --> 00:17:54.000
それでおそれ。

00:17:54.000 --> 00:18:01.000
そして、この実装は一般的であるため、任意の数の次元のアニメーション可能なデータで動作します。

00:18:01.000 --> 00:18:11.000
それが、AnimatableとAnimationが連携して、UIに表示される印象的な視覚効果を生み出す方法です。

00:18:11.000 --> 00:18:18.000
次に、CustomAnimationの2つのオプション要件に戻ります：shouldMergeと速度。

00:18:18.000 --> 00:18:20.000
それらは何のためですか?

00:18:20.000 --> 00:18:25.000
あなたがscaleEffect animatable属性であることを一瞬想像してみてください。

00:18:25.000 --> 00:18:37.000
ユーザーがタップダウンし、トランザクションが開き、値が変更され、アニメーションのローカルコピーを作成し、デルタベクトルを喜んでアニメーション化し始めます。

00:18:37.000 --> 00:18:40.000
すべてがうまくいっています。

00:18:40.000 --> 00:18:45.000
つまり、アニメーションが終了する前に厄介なユーザーが再びタップするまでです。

00:18:45.000 --> 00:18:48.000
何をされていますか？

00:18:48.000 --> 00:18:52.000
新しいアニメーションを設定し、shouldMergeを呼び出します。

00:18:52.000 --> 00:19:04.000
デフォルトの実装はfalseを返します--これはタイミングカーブアニメーションが行うことです--その場合、両方のアニメーションが一緒に実行され、その結果はシステムによって結合されます。

00:19:04.000 --> 00:19:09.000
これは、SwiftUIアニメーションがデルタベクトルの観点から扱うもう一つの理由です。

00:19:09.000 --> 00:19:16.000
複数のアニメーションが実行されているときに、正しい結合されたプレゼンテーション値を簡単に計算できます。

00:19:16.000 --> 00:19:21.000
しかし、タイミングカーブアニメーションではなく、春のアニメーションを選んだらどうなりますか?

00:19:21.000 --> 00:19:28.000
春のアニメーションは、trueを返し、以前のアニメーションの状態を組み込むためにshouldMergeをオーバーライドします。

00:19:28.000 --> 00:19:39.000
これにより、速度を維持し、タイミング曲線アニメーションのように、付加的に組み合わせるよりも自然に感じることができる新しい値にリターゲットすることができます。

00:19:39.000 --> 00:19:42.000
そして、それがこの最終的な速度要件のためのものです。

00:19:42.000 --> 00:19:49.000
それを実装すると、実行中のアニメーションが新しいアニメーションとマージされたときにベロシティを維持できます。

00:19:49.000 --> 00:19:57.000
そこで、ベロシティの実装を追加して、線形タイミング曲線アニメーションを終了します。

00:19:57.000 --> 00:20:05.000
この講演では、UIの特定の更新に対して実行される一連の作業を参照するために、「トランザクション」という用語を使用しました。

00:20:05.000 --> 00:20:13.000
SwiftUIコードでは、トランザクションは関連する強力なデータフロー構造とAPIのファミリも指します。

00:20:13.000 --> 00:20:23.000
あなたはすでに環境と環境設定に精通しているかもしれません、辞書SwiftUIはそれぞれ暗黙的にビュー階層を上下に渡します。

00:20:23.000 --> 00:20:24.000
取引は似ています。

00:20:24.000 --> 00:20:34.000
これは、SwiftUIが現在の更新、特にアニメーションのすべてのコンテキストを暗黙的に伝播するために使用する辞書です。

00:20:34.000 --> 00:20:41.000
アニメーション可能な属性が現在のアニメーションをどのように読み取るかについての私の以前の説明は少し曖昧でした。

00:20:41.000 --> 00:20:45.000
だから、私はアバタービューの別のアニメーションアップデートをトレースするつもりです。

00:20:45.000 --> 00:20:48.000
今回は、もっと具体的にします。

00:20:48.000 --> 00:20:57.000
タップジェスチャークロージャが起動すると、withAnimationはルートトランザクション辞書にアニメーションを設定します。

00:20:57.000 --> 00:21:01.000
ボディは属性値を更新するために呼び出されます。

00:21:01.000 --> 00:21:05.000
トランザクション辞書は、属性グラフ全体に伝播されます。

00:21:05.000 --> 00:21:11.000
アニメーション可能な属性に達すると、属性はアニメーションが設定されているかどうかをチェックします。

00:21:11.000 --> 00:21:16.000
そして、もしそうなら、それはそのプレゼンテーション価値を高めるためにコピーを作ります。

00:21:16.000 --> 00:21:24.000
トランザクションは特定の更新にのみ関連しているため、古い属性が更新されると破棄されます。

00:21:24.000 --> 00:21:38.000
トランザクション辞書内のビュー階層にアニメーションを流すと、アニメーションがビューにいつ、どのように適用されるかを制御するための多くの強力なAPIが可能になります。

00:21:38.000 --> 00:21:44.000
現在、ペットアバタービューはタップでのみ選択できます。

00:21:44.000 --> 00:21:47.000
選択した状態変数をバインディングに変更します。

00:21:47.000 --> 00:21:51.000
そうすれば、プログラムで選択することもできます。

00:21:51.000 --> 00:21:56.000
しかし、ビュープロパティへのプログラマティックな変更をアニメーション化するにはどうすればよいですか?

00:21:56.000 --> 00:22:06.000
トランザクション修飾子を使用して、トランザクション辞書内のビュー階層を流れるアニメーションにアクセスできます。

00:22:06.000 --> 00:22:20.000
この修飾子内からアニメーションを設定すると、ボディが呼び出されるたびに、トランザクションにアニメーションや別のアニメーションがなくても、属性はアニメーションを上書きします。

00:22:20.000 --> 00:22:27.000
そして、スケール効果に達すると、このアニメーションはスケール係数を補間するために使用されます。

00:22:27.000 --> 00:22:30.000
かなりかっこいい。

00:22:30.000 --> 00:22:32.000
しかし、このパターンには問題があります。

00:22:32.000 --> 00:22:42.000
SwiftUIがビューを更新するたびに、すべての子孫のアニメーションを無差別に上書きすると、偶発的なアニメーションにつながる可能性があります。

00:22:42.000 --> 00:22:49.000
代わりに、このようなユースケースでは、SwiftUIはアニメーションビュー修飾子を提供します。

00:22:49.000 --> 00:22:55.000
追加の値の引数が必要なため、効果をより正確にスコープできます。

00:22:55.000 --> 00:23:01.000
値が変更された場合にのみ、トランザクションにアニメーションが書き込まれます。

00:23:01.000 --> 00:23:10.000
それが接続されているので、このwithAnimationは何も達成していないので、削除できます。

00:23:10.000 --> 00:23:19.000
アニメーションビュー修飾子は、ビューのさまざまな部分に異なるアニメーションを適用したい状況のための強力なツールでもあります。

00:23:19.000 --> 00:23:27.000
たとえば、ペットのアバターには影がありますが、シンプルさのために例からこれまで省略しました。

00:23:27.000 --> 00:23:36.000
アバターが背景の上に上昇しているという錯覚を強調するためにアバターを選択すると、影の半径が増加します。

00:23:36.000 --> 00:23:43.000
遊んだ後、シャドウのアニメーションをスケール効果よりも抑えたいと決めました。

00:23:43.000 --> 00:23:50.000
これを達成するために、scaleEffectとシャドウの間に別のアニメーションビュー修飾子を挿入できます。

00:23:50.000 --> 00:23:58.000
今、トランザクションはスケール効果をアニメーション化するための弾力のある春を拾います。

00:23:58.000 --> 00:24:05.000
そして、影の半径をアニメーション化するために、より微妙な滑らかなスプリングを拾います。

00:24:05.000 --> 00:24:14.000
アニメーション修飾子は値が変更された場合にのみアクティブであるため、偶発的なアニメーションの確率は大幅に低下します。

00:24:14.000 --> 00:24:26.000
しかし、アバターの画像が選択したのと同じトランザクションでたまたま変更された場合、コンテンツの移行のために影の滑らかな春のアニメーションを継承していたでしょう。

00:24:26.000 --> 00:24:28.000
これは長引く価値のあるポイントです。

00:24:28.000 --> 00:24:35.000
このアニメーションビュー修飾子は、サブ階層全体が制御下にあるリーフコンポーネントでうまく機能します。

00:24:35.000 --> 00:24:44.000
しかし、任意の子コンテンツを含む非リーフコンポーネントの場合、偶発的なアニメーションが発生する可能性がはるかに高くなります。

00:24:44.000 --> 00:24:55.000
たとえば、ペットとは関係のない別のアプリでアバターを再利用したい場合は、任意の子コンテンツを受け入れることで、より一般的なものにすることができます。

00:24:55.000 --> 00:25:04.000
このシナリオでは、変更を選択したときに、子コンテンツも変更されないという保証はあまりありません。

00:25:04.000 --> 00:25:07.000
これにより、偶発的なアニメーションが発生する可能性があります。

00:25:07.000 --> 00:25:09.000
おっと。

00:25:09.000 --> 00:25:10.000
良いニュースです。

00:25:10.000 --> 00:25:16.000
このようなユースケース用に特別に設計されたアニメーションビュー修飾子の新しいバージョンがあります。

00:25:16.000 --> 00:25:24.000
アニメーションを、ボディクロージャで指定されたアニメーション可能な属性に絞り込みます。

00:25:24.000 --> 00:25:25.000
これがその仕組みです。

00:25:25.000 --> 00:25:30.000
トランザクションにアニメーションがないと想像してみてください。

00:25:30.000 --> 00:25:39.000
トランザクションがアニメーションビュー修飾子の属性に達すると、指定されたアニメーションが入力されたコピーが作成されます。

00:25:39.000 --> 00:25:45.000
コピーは下流に伝播されますが、スコープされたアニメーション可能な属性にのみ伝播されます。

00:25:45.000 --> 00:25:54.000
作業が完了すると、コピーは破棄され、元のトランザクションは中断したところから再開されます。

00:25:54.000 --> 00:26:09.000
したがって、トランザクションが子コンテンツに到達すると、元のトランザクションは中間アニメーションビュー修飾子の影響を受けないため、偶発的なアニメーションのリスクはありません。

00:26:09.000 --> 00:26:14.000
SwiftUIの最初のバージョン以降、限られたトランザクションAPIが利用可能になりました。

00:26:14.000 --> 00:26:27.000
現在、カスタムトランザクションキーを定義する機能を導入しているので、トランザクション辞書を活用して、独自の更新固有のデータを暗黙的に伝播することができます。

00:26:27.000 --> 00:26:34.000
カスタム環境キーを宣言したことがある場合は、カスタムトランザクションキーを宣言することはよく知られています。

00:26:34.000 --> 00:26:40.000
パターンは、TransactionKeyプロトコルに準拠した一意の型を作成することです。

00:26:40.000 --> 00:26:43.000
唯一の要件は、defaultValueを提供することです。

00:26:43.000 --> 00:26:53.000
次に、キーを使用してトランザクション辞書から読み書きするトランザクションの拡張として計算されたプロパティを宣言します。

00:26:53.000 --> 00:27:00.000
ここでは、指定された更新に対して、アバターがタップされたかどうかを追跡するためのブールキーを定義しました。

00:27:00.000 --> 00:27:04.000
その価値に基づいて、どのアニメーションを使用するかを決めます。

00:27:04.000 --> 00:27:11.000
アバターがインタラクティブに選択された場合は、より活気のあるスプリングを使用してスケールアップまたはスケールダウンします。

00:27:11.000 --> 00:27:17.000
しかし、アバターがプログラムで選択された場合は、より落ち着いたスプリングを使用してスケーリングします。

00:27:17.000 --> 00:27:25.000
状態変更を中心にwithTransactionをラップすることで、指定された更新のトランザクション辞書で値を設定できます。

00:27:25.000 --> 00:27:26.000
これは見覚えがあるはずです。

00:27:26.000 --> 00:27:32.000
withAnimationは、withTransactionの薄いラッパーです。

00:27:32.000 --> 00:27:40.000
withTransactionに渡される引数は、トランザクションの計算されたプロパティと設定する値へのキーパスです。

00:27:40.000 --> 00:27:48.000
トランザクションは、すべての更新の最後に破棄されるため、SwiftUIの暗黙のデータフロー構造の中で一意です。

00:27:48.000 --> 00:27:58.000
これは、現在の更新に明示的に設定されない限り、トランザクション辞書のすべての値は、そのキーのデフォルト値に戻ることを意味します。

00:27:58.000 --> 00:28:07.000
アバタービューでは、タップジェスチャーのクロージャが起動すると、現在の更新に対してavatarTappedがtrueに設定されます。

00:28:07.000 --> 00:28:16.000
トランザクションには、アニメーションキーのデフォルト値（nil）も含まれています。

00:28:16.000 --> 00:28:23.000
トランザクションは、トランザクション修飾子に到達するまで、ビュー階層全体に伝播します。

00:28:23.000 --> 00:28:32.000
ここでは、アバタービューはavatarTappedを読み取り、その値に基づいて適切なアニメーションを設定します...

00:28:32.000 --> 00:28:39.000
これはビュー階層を伝播します。

00:28:39.000 --> 00:28:46.000
これはかなりうまく機能しますが、以前と同じように、偶発的なアニメーションが発生する可能性があります。

00:28:46.000 --> 00:28:54.000
トランザクションの変更をきめ細かく制御するために、トランザクション修飾子の2つの新しいバリアントを導入しています。

00:28:54.000 --> 00:28:58.000
1つは、値引数を使用してスコープすることができます。

00:28:58.000 --> 00:29:03.000
もう1つは、ボディクロージャで定義されたサブ階層にスコープすることができます。

00:29:03.000 --> 00:29:09.000
これらのバリアントは、先に説明したスコープ付きアニメーションビュー修飾子を反映しています。

00:29:09.000 --> 00:29:19.000
このセッションでは、SwiftUIの強力なアニメーションプリミティブ、アニメーション、アニメーション、トランザクションについて説明しました。

00:29:19.000 --> 00:29:23.000
次のステップとして、2つの関連セッションをチェックすることをお勧めします。

00:29:23.000 --> 00:29:31.000
「Animate with springs」は、アプリで春のアニメーションを効果的に使用する理由と方法について、より多くのガイダンスを提供します。

00:29:31.000 --> 00:29:41.000
そして、「SwiftUIで高度なアニメーションを駆け抜ける」は、マルチステップアニメーションを構築するための強力な新しいツールを紹介します。

00:29:41.000 --> 00:29:50.000
このコンテンツにより、SwiftUIアニメーションの仕組みをよりよく理解し、アプリでアニメーションをより巧みに活用できることを願っています。

00:29:50.000 --> 00:29:52.000
ありがとう。

00:29:52.000 --> 23:59:59.000
♪ ♪

