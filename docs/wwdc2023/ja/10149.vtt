WEBVTT

00:00:00.000 -> 00:00:10.000
♪ ♪

00:00:10.000 -> 00:00:12.000
フィリップ：こんにちは、私の名前はフィリップです。

00:00:12.000 -> 00:00:18.000
Swift: Observationで魔法の新機能を発表できることを本当に嬉しく思います。

00:00:18.000 -> 00:00:28.000
この機能を使用すると、標準のSwift構文を使用してモデルを定義し、それらのタイプを使用してUIがそのモデルの変更に応答させることができます。

00:00:28.000 -> 00:00:33.000
これにより、SwiftUIでの開発がシームレスで直感的になります。

00:00:33.000 -> 00:00:51.000
今日はいくつかのトピックを取り上げます。観察の概要、SwiftUIのプロパティラッパーを使用するタイミングに関する一連の便利なルール、次に、観測可能なより高度な使用法のいくつかを取り上げます。

00:00:51.000 -> 00:01:02.000
そして、ObservableObjectの使用から新しい@Observableマクロにコードを更新する方法に関するいくつかの例で締めくくります。

00:01:02.000 -> 00:01:07.000
オブザベーションは、プロパティの変更を追跡するための新しいSwift機能です。

00:01:07.000 -> 00:01:13.000
それは通常のSwiftタイプで動作し、マクロの魔法でそれらを変換します。

00:01:13.000 -> 00:01:21.000
私たちはしばしばデータモデルタイプを書き、それらは最終的にSwiftUIで使用したいと思う多くのプロパティを持っています。

00:01:21.000 -> 00:01:31.000
データモデルの変更にUIを応答させるために必要なのは、@Observableを追加するだけだと言ったらどうなりますか？

00:01:31.000 -> 00:01:37.000
Swift 5.9の新機能により、モデルをこれまで以上にシンプルにすることができます。

00:01:37.000 -> 00:01:40.000
これは、Swiftの新しいマクロシステムを使用します。

00:01:40.000 -> 00:01:51.000
「@Observable」は、Swiftコンパイラに、あなたが書いたものから、タイプを観察できるようにする拡張形式にコードを変換するように指示します。

00:01:51.000 -> 00:01:56.000
観察可能なタイプを使用して、SwiftUIビューを強化できます。

00:01:56.000 -> 00:02:01.000
そして、驚くべき部分は、彼らが働くためにプロパティラッパーの任意の種類を必要としないということです。

00:02:01.000 -> 00:02:07.000
ドーナツフードトラックアプリからおいしいサンプルをいくつか持っているので、すぐに飛び込みましょう。

00:02:07.000 -> 00:02:11.000
ここでは、ドーナツを示す簡単なビューがあります。

00:02:11.000 -> 00:02:18.000
SwiftUIは、ボディコールを実行するときにモデルが特定のプロパティにアクセスすることを知っています。

00:02:18.000 -> 00:02:26.000
この場合、ドーナツメニュービューの本体を実行するときに、プロパティ「ドーナツ」がアクセスされたことを検出できます。

00:02:26.000 -> 00:02:33.000
bodyが実行されると、SwiftUIは「Observable」タイプから使用されるプロパティへのすべてのアクセスを追跡します。

00:02:33.000 -> 00:02:44.000
次に、その追跡情報を取り、それを使用して、それらの特定のインスタンスのこれらのプロパティの次の変更がいつ変更されるかを判断します。

00:02:44.000 -> 00:02:56.000
ここでは、ドーナツの追加ボタンをクリックしてドーナツ配列を変更すると、ドーナツメニュービューが無効になり、それに応じてUIが更新されます。

00:02:56.000 -> 00:03:08.000
きちんとしているのは、注文が追加された場合、そのプロパティはビューの本文の実行時に決定された追跡されたプロパティの一部ではないため、ビューは無効にならないということです。

00:03:08.000 -> 00:03:12.000
次に、計算されたプロパティを使用すると何が起こるかを取り上げましょう。

00:03:12.000 -> 00:03:16.000
計算されたプロパティを追加すると、以前と同じルールに従います。

00:03:16.000 -> 00:03:22.000
使用されるプロパティが変更されると、UIが更新されます。

00:03:22.000 -> 00:03:29.000
新しく追加されたコンテンツでは、モデルのorderCountが呼び出され、ordersプロパティにアクセスします。

00:03:29.000 -> 00:03:41.000
つまり、この例では、注文が変更された場合、orderCountが注文のプロパティにアクセスするため、そのテキストが更新されます。

00:03:41.000 -> 00:03:47.000
「@Observable」マクロを使用すると、オブザベーションをサポートできるようにタイプが拡張されます。

00:03:47.000 -> 00:03:56.000
これにより、SwiftUIはこれらのプロパティへのアクセスを追跡し、次のプロパティがそのオブザベーションからいつ変更されるかを観察できます。

00:03:56.000 -> 00:04:10.000
そのようなものを追跡すると、UIはそれらの特定のプロパティが変更されたときにのみビューの本体を再計算し、そこから本当に素晴らしいパフォーマンスの改善が見られました。

00:04:10.000 -> 00:04:19.000
マクロを深く掘り下げたい場合は、「Write Swiftマクロ」と「Expand on Swiftマクロ」セッションをチェックしてください。

00:04:19.000 -> 00:04:25.000
Observableを使用すると、SwiftUIのプロパティラッパーがこれまで以上に簡単になります。

00:04:25.000 -> 00:04:32.000
状態、環境、およびバインド可能は、SwiftUIを操作するための3つの主要なプロパティラッパーです。

00:04:32.000 -> 00:04:42.000
SwiftUIで観測可能なタイプとインタフェースするためにプロパティラッパーを必要としないケースはすでに説明しましたが、そのケースを掘り下げてみましょう。

00:04:42.000 -> 00:04:44.000
@Stateから始めます。

00:04:44.000 -> 00:04:51.000
ビューが独自の状態をモデルに格納する必要がある場合は、@Stateプロパティを使用します。

00:04:51.000 -> 00:04:58.000
ここでは、シートプレゼンテーションで使用されている観測可能なモデルオブジェクトドーナツがあります。

00:04:58.000 -> 00:05:05.000
シートが表示されると、donutToAdd状態変数が編集可能なフィールドに値をバインドするために使用されます。

00:05:05.000 -> 00:05:11.000
「donutToAdd」プロパティは、含まれているビューの寿命によって管理されます。

00:05:11.000 -> 00:05:14.000
次は@Environmentです。

00:05:14.000 -> 00:05:20.000
環境では、値をグローバルにアクセス可能な値として伝播させることができます。

00:05:20.000 -> 00:05:24.000
これにより、多くの場所で物事を共有できます。

00:05:24.000 -> 00:05:33.000
観察可能なタイプは、それらによって作成された更新はアクセスに基づいているため、ここでは素晴らしく機能します。

00:05:33.000 -> 00:05:41.000
フードトラックメニュービューの本体を呼び出すと、アカウントオブジェクトのプロパティuserNameがアクセスされます。

00:05:41.000 -> 00:05:45.000
したがって、ユーザー名が変更されると、メニュービューが更新されます。

00:05:45.000 -> 00:05:50.000
不動産ラッパーファミリーの最新作は「@Bindable」です。

00:05:50.000 -> 00:05:53.000
バインド可能なプロパティラッパーは本当に軽量です。

00:05:53.000 -> 00:05:58.000
そのタイプからバインディングを作成できるようにするだけです。

00:05:58.000 -> 00:06:04.000
バインド可能なラップされたプロパティからバインディングを取得するのは本当に簡単です。

00:06:04.000 -> 00:06:09.000
$構文を使用して、そのプロパティへのバインディングを取得するだけです。

00:06:09.000 -> 00:06:13.000
ほとんどの場合、これは観測可能な型へのバインディングになります。

00:06:13.000 -> 00:06:18.000
ドーナツビューでは、名前がテキストで表示されます。

00:06:18.000 -> 00:06:22.000
しかし、実際には、私たちはその名前を編集できるようにしたいと思っています。

00:06:22.000 -> 00:06:26.000
したがって、テキストの代わりに、テキストフィールドを使用できます。

00:06:26.000 -> 00:06:29.000
そのTextFieldはバインディングを取ります。

00:06:29.000 -> 00:06:39.000
バインディングから読み込んでTextFieldの値を入力しますが、ユーザーが値を変更したときにバインディングに書き戻します。

00:06:39.000 -> 00:06:47.000
ドーナツにバインディングするには、ドーナツプロパティの「@Bindable」プロパティラッパーを使用するだけです。

00:06:47.000 -> 00:06:55.000
プロパティラッパーアノテーションを使用すると、「$donut.name」構文を使用し、使用時にバインディングを作成できます。

00:06:55.000 -> 00:07:03.000
ラッパーを締めくくるために、SwiftUIで観測可能なモデルを使用するために必要な質問は3つだけです。

00:07:03.000 -> 00:07:07.000
このモデルはビュー自体の状態である必要がありますか?

00:07:07.000 -> 00:07:10.000
もしそうなら、「@State」を使ってください。

00:07:10.000 -> 00:07:15.000
このモデルは、アプリケーションのグローバル環境の一部である必要がありますか?

00:07:15.000 -> 00:07:19.000
もしそうなら、「@Environment」を使ってください。

00:07:19.000 -> 00:07:22.000
このモデルにはバインディングだけが必要ですか?

00:07:22.000 -> 00:07:26.000
その場合は、新しい「@Bindable」を使用してください。

00:07:26.000 -> 00:07:32.000
そして、これらの質問のどれも「はい」という答えがない場合は、モデルをビューのプロパティとして使用してください。

00:07:32.000 -> 00:07:37.000
これまでのところ、保存されているモデルで始まるプロパティを取り上げました。

00:07:37.000 -> 00:07:40.000
Observableはもっと多くのことができます。

00:07:40.000 -> 00:07:53.000
SwiftUIはインスタンスごとにフィールドへのアクセスを追跡するため、配列、オプション、またはそのことについては、観測可能なモデルを含む任意のタイプを使用できることを意味します。

00:07:53.000 -> 00:07:57.000
ドーナツリストビューには、ドーナツモデルの配列があります。

00:07:57.000 -> 00:08:01.000
各モデル自体は「@Observable」です。

00:08:01.000 -> 00:08:14.000
これらのドーナツの名前のいずれかが変更されると、SwiftUIはその特定のインスタンスでそのプロパティへのアクセスを検出し、ビューを無効にするタイミングを知るために追跡します。

00:08:14.000 -> 00:08:23.000
したがって、ランダム化ボタンでドーナツ名が変更されると、ビューはそれに応じて更新されます。

00:08:23.000 -> 00:08:27.000
これにより、モデルを好きなように構築できます。

00:08:27.000 -> 00:08:35.000
観察されるモデルの配列、または他の観測可能なモデルタイプを含むモデルタイプを持つこともできます。

00:08:35.000 -> 00:08:44.000
一般的なルールはObservableの場合で、使用されるプロパティが変更されると、ビューが更新されます。

00:08:44.000 -> 00:08:48.000
その規則が完全に適用されないケースがあります。

00:08:48.000 -> 00:09:00.000
計算されたプロパティに保存されたプロパティがない場合は、オブザベーションで機能させるために2つの追加手順を実行する必要があります。

00:09:00.000 -> 00:09:09.000
これは、観察されるプロパティが、観測可能なタイプの格納されたプロパティの何らかの構成によって変更されない場合にのみ行う必要があります。

00:09:09.000 -> 00:09:18.000
この場合、必要なのは、プロパティがいつアクセスされ、プロパティが変更されたときにオブザベーションに伝えることだけです。

00:09:18.000 -> 00:09:33.000
これは、Observationがプロパティへのアクセスを正常に合成する方法ですが、ここでは、観測不可能な場所を読み取ることができ、名前を保存できるように、これらのカスタムアクセスポイントを手動で書き換えました。

00:09:33.000 -> 00:09:44.000
ほとんどの場合、これらのタイプの手動ケースは必要ありません。なぜなら、ほとんどの場合、問題のモデルのプロパティは他の保存されたプロパティから構成されるからです。

00:09:44.000 -> 00:09:55.000
しかし、その高度な機能を必要とするまれなケースでは、観察は十分に柔軟ですが、自分で行うのに十分簡単です。

00:09:55.000 -> 00:10:04.000
SwiftUIは、これらのプロパティへのアクセスによって観測可能な型を追跡するため、コンポジションの変化を識別できます。

00:10:04.000 -> 00:10:13.000
これは、計算されたプロパティが他の保存されたプロパティから構成されている場合、オブザベーションが機能することを意味します。

00:10:13.000 -> 00:10:25.000
ただし、それが真実ではないいくつかのケースでは、直接観察を使用して、アクセスと突然変異にフラグを立てるためにこれらの呼び出しを手動で追加することができます。

00:10:25.000 -> 00:10:35.000
以前はフードトラックアプリで、ObservableObjectを使用して、新しい@Observableマクロで行ったのと同じことをいくつか達成しました。

00:10:35.000 -> 00:10:42.000
今日SwiftUIを使用するアプリがあれば、非常によく似た状況にあるかもしれません。

00:10:42.000 -> 00:10:50.000
観測可能なマクロはコードを簡素化することができ、おそらく、あなたもまともなパフォーマンスの向上を見るかもしれません。

00:10:50.000 -> 00:11:01.000
変更前は、FoodTruckModelタイプにはObservableObjectコンフォーマンスがあり、@Publishedプロパティラッパーでマークされた多くのプロパティがありました。

00:11:01.000 -> 00:11:06.000
@Observableマクロへの切り替えはかなり簡単でした。

00:11:06.000 -> 00:11:16.000
私たちがする必要があるのは、ObservableObjectへの適合性を削除し、「@Published」を削除し、「@Observable」マクロでマークすることだけです。

00:11:16.000 -> 00:11:23.000
ビューに関しては、「@ObservedObject」と「@EnvironmentObject」のプロパティラッパーがいくつかありました。

00:11:23.000 -> 00:11:34.000
「@ObservedObject」ラッパーのすべてのケースで、消えたか、バインディングだけを必要とし、新しい「@Bindable」に変更しました。

00:11:34.000 -> 00:11:40.000
「@EnvironmentObject」ラッパーは、単に「@Environment」に変身しました。

00:11:40.000 -> 00:11:48.000
ObservableObjectから新しい「@Observable」マクロへの変更は、ほとんどが注釈を削除するだけでした。

00:11:48.000 -> 00:11:57.000
または、@State、@Environment、@Bindableの3つの主要なプロパティラッパーに簡素化します。

00:11:57.000 -> 00:12:04.000
これにより、考慮すべきオプションが少ないため、新機能を書くことを推論しやすくなります。

00:12:04.000 -> 00:12:09.000
観察はちょうど良いレベルの魔法を持っています。

00:12:09.000 -> 00:12:17.000
簡単に始めることができ、@Observableマクロを使用してデータモデルを直接操作できます。

00:12:17.000 -> 00:12:24.000
必要なときに、高度なユースケースのマニュアルバージョンを書くことができます。

00:12:24.000 -> 00:12:30.000
新しい開発では、Observableを使用することが最も簡単な方法です。

00:12:30.000 -> 00:12:38.000
また、既存のアプリケーションでは、Observableを使用すると、モデルを簡素化し、新しい機能を追加する際のパフォーマンスを向上させることができます。

00:12:38.000 -> 00:12:44.000
試してみて、その魔法を自分で利用することをお勧めします。

00:12:44.000 -> 23:59:59.000
♪ ♪

