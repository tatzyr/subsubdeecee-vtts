WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:11.000
ルベナ:みなさん、こんにちは!

00:00:11.000 --> 00:00:23.000
私の名前はLuvenaです。Core DataアプリケーションをCore Dataと共存できるSwiftネイティブ永続性フレームワークであるSwiftDataに移行する方法を皆さんと共有できることを嬉しく思います。

00:00:23.000 --> 00:00:38.000
Core DataからSwiftDataへの完全な移行の準備ができているかどうか、またはSwiftDataを段階的に採用してCore Dataと共存したいかどうか、Core DataアプリにSwiftDataを採用する方法の一般的なユースケースについて説明します。

00:00:38.000 --> 00:00:46.000
まず、マネージドオブジェクトモデルエディタアシスタントを使用してSwiftDataモデルクラスを生成する方法を説明します。

00:00:46.000 --> 00:00:52.000
次に、既存のCore Dataアプリケーションの完全なSwiftData採用の流れを実演します。

00:00:52.000 --> 00:01:05.000
そして最後に、SwiftDataへの完全な移行がユースケースにとって実現可能な解決策ではない可能性がある場合に備えて、Core DataとSwiftDataの共存を紹介します。

00:01:05.000 --> 00:01:09.000
まず、モデルクラスを生成する方法の流れを見てみましょう。

00:01:09.000 --> 00:01:14.000
SwiftDataでは、スキーマを設定するためにコードでモデルを使用することに移行しています。

00:01:14.000 --> 00:01:21.000
これを行う簡単な方法の1つは、Core Data管理オブジェクトモデルを使用してSwiftDataモデルを生成することです。

00:01:21.000 --> 00:01:25.000
この移行を行う方法をお見せしましょう。

00:01:25.000 --> 00:01:32.000
私はここでSampleTripsと呼ばれるコアデータアプリケーションを作成しました。これは、ユーザーが今後の旅行の旅程を計画するのに役立ちます。

00:01:32.000 --> 00:01:38.000
これは、私のデータとその組織に関する情報を含むモデルファイルです。

00:01:38.000 --> 00:01:52.000
私はエンティティTrip、LivingAccommodation、およびBucketListItemを持っており、各旅行が希望する旅行活動を表す1つの対応する生活宿泊施設とバケットリストアイテムを持つように整理されています。

00:01:52.000 --> 00:01:57.000
ここから、この同じ情報をキャプチャするSwiftDataクラスを生成します。

00:01:57.000 --> 00:02:15.000
これらのSwiftDataクラスを作成するには、Core Data管理オブジェクトモデルは必要ありませんが、既存のCore Dataモデルがある場合は、既存のモデルにすでに持っている組織に基づいてSwiftDataクラスを生成するために使用できます。このユースケースで実演します。

00:02:15.000 --> 00:02:19.000
これを行うには、マネージドオブジェクトモデルエディタアシスタントを通過します。

00:02:19.000 --> 00:02:30.000
モデルファイルを選択した後、メニューバーに移動し、[エディタ]を選択し、[SwiftDataコードの作成]をクリックします。

00:02:30.000 --> 00:02:35.000
これで、既存の3つのエンティティのファイルを生成できます。

00:02:35.000 --> 00:02:43.000
SwiftDataモデルをゼロから作成することも、新しいSwiftアプリを作成する場合のオプションであり、このアシスタントは必要ありません。

00:02:43.000 --> 00:02:46.000
これは私が作成したばかりのファイルです。

00:02:46.000 --> 00:03:04.000
Swiftタイプはモデルに準拠する必要があり、それぞれがエンティティの情報を変数としてキャプチャします。その属性は、Tripの名前、宛先、開始日と終了日、他のエンティティとの関係、LivingAccommodationとBucketListItemです。

00:03:04.000 --> 00:03:09.000
では、SwiftDataの完全な採用プロセスを紹介しましょう。

00:03:09.000 --> 00:03:20.000
アプリケーションをSwiftDataに完全に移行する場合、SwiftDataでSwiftネイティブ言語機能を活用するために、Core DataスタックをSwiftDataスタックに置き換えます。

00:03:20.000 --> 00:03:27.000
これにより、データを永続化するためのより読みやすいコードが可能になり、一部の機能を暗黙的に管理できます。

00:03:27.000 --> 00:03:34.000
ただし、この移行を行う前に、既存のコアデータモデル設計がどのように構成されているかを検討する必要があります。

00:03:34.000 --> 00:03:41.000
コアデータモデルの設計は、エンティティとそのプロパティと関係を含むスキーマを参照します。

00:03:41.000 --> 00:03:47.000
コアデータモデルの設計がSwiftDataでもサポートされていることを確認する必要があります。

00:03:47.000 --> 00:03:58.000
これは、コアデータで定義された各エンティティについて、SwiftDataのエンティティ名とプロパティの完全一致を持つ対応するモデルタイプが必要であることを意味します。

00:03:58.000 --> 00:04:04.000
モデルを徹底的にテストして、すべての機能がSwiftDataでサポートされていることを確認してください。

00:04:04.000 --> 00:04:11.000
Core Dataアプリからの完全なSwiftData採用プロセスのハイライトをもう少し詳しく説明しましょう。

00:04:11.000 --> 00:04:15.000
私はすでに以前にモデルをキャプチャするためにSwiftタイプを生成しました。

00:04:15.000 --> 00:04:25.000
これらのファイルの準備ができたら、以前に使用されていたCore Data管理オブジェクトモデルファイルを削除し、代わりにこれらのSwiftファイルを使用してモデルを管理できます。

00:04:25.000 --> 00:04:32.000
さらに、以前にCore Dataスタックの設定に役立ったPersistenceファイルを削除することもできます。

00:04:32.000 --> 00:04:37.000
これで、SwiftDataスタックのmodelContainerを設定できます。

00:04:37.000 --> 00:04:44.000
modelContainerは、グループ内のすべてのウィンドウが同じ永続コンテナにアクセスするように構成されていることを保証する修飾子です。

00:04:44.000 --> 00:04:56.000
このコンテナをTripsAppに追加することで、modelContainerも環境にデフォルトのModelContextを作成して設定するため、コンテナとコンテキストの両方を設定しています。

00:04:56.000 --> 00:05:01.000
ModelContextは、アプリのタイプのインスタンスへの変更を追跡するために使用されます。

00:05:01.000 --> 00:05:06.000
この環境プロパティを使用して、任意のシーンまたはビュー内から読み取ることができます。

00:05:06.000 --> 00:05:13.000
SampleTrips用のSwiftData永続スタックが設定されましたが、さらにいくつかの変更が必要です。

00:05:13.000 --> 00:05:17.000
まず、オブジェクトの作成がどのように機能するかを実演します。

00:05:17.000 --> 00:05:22.000
以前は、コアデータでは、新しい旅行を作成すると、このようなものに似ていました。

00:05:22.000 --> 00:05:30.000
属性を設定する前に、管理対象オブジェクトコンテキストを渡すTripのインスタンスを作成します。

00:05:30.000 --> 00:05:38.000
SwiftDataでは、すでに比較的読みやすいこのコード行でTripの新しいインスタンスを作成できます。

00:05:38.000 --> 00:05:45.000
この新しい旅行をしたら、それをモデルコンテキストに挿入して、それが持続していることを確認します。

00:05:45.000 --> 00:05:51.000
私の旅行が持続している今、私はそれを保存する方法と私がそれに加える将来の変更を見てみたいと思います。

00:05:51.000 --> 00:06:00.000
SwiftDataには、可能であればコンテキストが変更された後のUIライフサイクルイベントとタイマーのセーブをトリガーする暗黙の保存機能があります。

00:06:00.000 --> 00:06:09.000
したがって、コンテキストで呼び出されるCore Dataの明示的な保存を削除し、コンテキストが変更されたときにデータを永続化するために暗黙の保存に頼ることができます。

00:06:09.000 --> 00:06:12.000
では、データを取得する方法を説明します。

00:06:12.000 --> 00:06:22.000
コアデータで持っていたようなフェッチ要求を使用する代わりに、クエリを使用して、クエリで旅行の配列をラップすることで、今後の旅行の完全なリストを取得できます。

00:06:22.000 --> 00:06:26.000
これにより、SwiftDataコンテナからこれらのTripオブジェクトを取得できます。

00:06:26.000 --> 00:06:30.000
また、クエリのソート順を定義しています。

00:06:30.000 --> 00:06:37.000
最も近い今後の旅行が一番上になるように、旅行の開始日を順に並べ替えたいです。

00:06:37.000 --> 00:06:42.000
クエリは、述語を含める必要があるユースケースにも使用できます。

00:06:42.000 --> 00:06:51.000
Core DataアプリをSwiftDataに完全に移行する方法がわかったので、Core DataとSwiftDataの共存をしたいケースを案内します。

00:06:51.000 --> 00:06:59.000
完全な移行は必ずしも実現可能または実用的では限りません。その場合、SwiftDataへの部分的な変換を検討できます。

00:06:59.000 --> 00:07:08.000
共存とは、2つの完全に別々の永続スタック、1つのCore Dataスタックと1つのSwiftDataスタックがあり、同じ永続ストアと通信することです。

00:07:08.000 --> 00:07:16.000
これは、SwiftDataコードの追加を開始するために、既存のコアデータコードを完全に書き換える必要がないことを意味します。

00:07:16.000 --> 00:07:31.000
このオプションは、SwiftDataをアプリケーションに採用する際に、Core Dataにすでにデータがある場合でも、SwiftDataに完全に移行できない他の制約に直面している場合でも、より柔軟性を提供します。

00:07:31.000 --> 00:07:36.000
これは、同じストアと話すように両方のスタックを設定する方法です。

00:07:36.000 --> 00:07:46.000
永続ストアをロードする前に、コンテナの説明の永続ストアURLを設定して、両方のスタックが同じURLに書き込まれていることを確認する必要があります。

00:07:46.000 --> 00:07:50.000
さらに、永続的な履歴追跡をオンにする必要があります。

00:07:50.000 --> 00:07:55.000
SwiftDataは自動的に永続的な履歴追跡をオンにしますが、Core Dataはオンにしません。

00:07:55.000 --> 00:08:07.000
永続的な履歴を設定せずに、同じアプリケーションでCore DataとSwiftDataの両方が共存しているときに永続的なストアを開こうとすると、ストアは読み取り専用モードになります。

00:08:07.000 --> 00:08:13.000
共存がユースケースに最適な選択肢であると感じるシナリオがいくつかあります。

00:08:13.000 --> 00:08:17.000
1つのシナリオは、既存のクライアントとの下位互換性を可能にすることです。

00:08:17.000 --> 00:08:27.000
SwiftDataはiOS 17とmacOS Sonomaでのみ利用可能であるため、現在のCore DataアプリケーションはSwiftDataへのフルスイッチによって影響を受ける可能性があります。

00:08:27.000 --> 00:08:33.000
あるいは、SwiftDataへの完全な変換を困難にするリソースの制約に直面しているかもしれません。

00:08:33.000 --> 00:08:44.000
このような場合、SwiftDataを使用して新しい開発を行うか、アプリケーションの一部のみをSwiftDataに変換することで、SwiftDataを部分的に組み込むことは理にかなっています。

00:08:44.000 --> 00:08:51.000
この移行を行う前に考慮すべき、Core DataとSwiftDataを共存するためのいくつかの要件があります。

00:08:51.000 --> 00:09:00.000
まず、既存のNSManagedObjectベースのエンティティサブクラスまたはSwiftDataクラスが衝突しないように名前空間にする必要があります。

00:09:00.000 --> 00:09:06.000
これは、2つのクラスを同じものと呼ぶことができず、少なくとも1つを変更する必要があることを意味します。

00:09:06.000 --> 00:09:12.000
クラス名を変更しても、エンティティ名は同じままであることを覚えておいてください。

00:09:12.000 --> 00:09:20.000
たとえば、ここでは以前と同じSampleTripsプロジェクトがありますが、今回はCore DataとSwiftDataと共存したいです。

00:09:20.000 --> 00:09:22.000
2つのクラス名が衝突する。

00:09:22.000 --> 00:09:30.000
SwiftDataとCore Data名Tripの両方を区別するために、代わりにCore Dataトリップクラス名をCDTripに変更しました。

00:09:30.000 --> 00:09:35.000
マネージドオブジェクトモデルエディタでもこれを行うことができます。

00:09:35.000 --> 00:09:47.000
さらに、Core DataとSwiftDataスキーマを同期させる必要があります。SwiftDataスキーマの新しい部分はNSManagedObjectModelとして具体化する必要があり、2つのスキーマは分岐できません。

00:09:47.000 --> 00:09:52.000
これは、プロパティと関係をまったく同じ方法でモデルに追加する必要があることを意味します。

00:09:52.000 --> 00:10:02.000
これは、不一致のハッシュが移行を引き起こし、削除したくない情報を削除する可能性があるため、エンティティバージョンのハッシュがすべてのステップに一致するようにするためです。

00:10:02.000 --> 00:10:07.000
最後に、共存を組み込むときにスキーマバージョンを追跡する必要があります。

00:10:07.000 --> 00:10:16.000
複数のバージョンのSwiftDataモデルを操作する場合は、SwiftDataが違いを評価できるように、変更が正しく表現されていることを確認する必要があります。

00:10:16.000 --> 00:10:19.000
これを行う方法はいくつかあります。 これを行うにはいくつかあります。

00:10:19.000 --> 00:10:25.000
「SwiftDataでスキーマをモデル化」トークをチェックして、バージョン管理されたスキーマの使い方を理解してください。

00:10:25.000 --> 00:10:32.000
UIKitまたはAppKitに依存するSwiftアプリには、SwiftDataを使用するための実行可能なオプションがまだあります。

00:10:32.000 --> 00:10:35.000
最初のアプローチは共存の解決策です。

00:10:35.000 --> 00:10:40.000
UIKitコードをCore Dataにバインドすることができ、SwiftDataと並行して動作する可能性があります。

00:10:40.000 --> 00:10:48.000
あるいは、SwiftDataクラスをSwiftクラスとして扱い、代わりにUIKitコードでSwiftコードをラップすることもできます。

00:10:48.000 --> 00:10:49.000
それはすべて私からです!

00:10:49.000 --> 00:10:56.000
次に、Core Dataアプリケーションを完全または段階的にSwiftDataに柔軟に移行する方法を発見してください。

00:10:56.000 --> 00:11:02.000
それまでの間、SwiftDataに関するこれらの他のクールな話をチェックして、より深く掘り下げてください。

00:11:02.000 --> 00:11:06.000
参加してくれてありがとう!私はあなたが何を作るかを見るのが楽しみです!

00:11:06.000 --> 23:59:59.000
♪ ♪

