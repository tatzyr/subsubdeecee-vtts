WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:15.000
Aasim：こんにちは、私はAasim Kandrikarです。後でRaleigh Ledetが参加します。

00:00:15.000 --> 00:00:17.000
私たちは両方ともAppKitチームのエンジニアです。

00:00:17.000 --> 00:00:23.000
このビデオでは、macOS Sonomaの「AppKitの新機能」について説明します。

00:00:23.000 --> 00:01:00.000
AppKitコントロールの新機能とAPI強化、まったく新しい実装によるメニューの改善、macOSでのアプリのアクティベーションの仕組みの変更、グラフィックの改良と画像とシンボルの新機能、新しいテキスト入力体験、英語以外の言語のテキストレイアウトの改善、SwiftとSwiftUIでの作業の改善など、幅広いトピックを取り上げます。

00:01:00.000 --> 00:01:06.000
macOS Sonomaには、AppKitコントロールにいくつかのエキサイティングな新機能とAPIの改良が含まれています。

00:01:06.000 --> 00:01:16.000
NSTableViewとNSOutlineViewは、箱から出してすぐに使用できる多くの機能を提供し、AppKitを使用して優れたMacアプリを設計する上で重要な要素となっています。

00:01:16.000 --> 00:01:21.000
macOS Sonomaでは、列のカスタマイズメニューを表示する新しいAPIがあります。

00:01:21.000 --> 00:01:26.000
メニューを使用すると、ユーザーはテーブル内の列の可視性を切り替えることができます。

00:01:26.000 --> 00:01:36.000
以前は、このメニューを作成して表示するためにカスタム実装が必要でしたが、今ではわずか3行のコードでこれを追加できます。

00:01:36.000 --> 00:01:41.000
新しいデリゲートメソッドtableView userCanChangeVisibilityOfを採用します。

00:01:41.000 --> 00:01:52.000
ユーザーが非表示にできる列を指定すると、AppKitはメニューのローカライズや再起動時に非表示の列の状態を復元するなど、残りを処理します。

00:01:52.000 --> 00:01:57.000
FoundationのProgressタイプは、アプリケーションが実行する作業を表します。

00:01:57.000 --> 00:02:03.000
アプリでこれを使用して、進行中のダウンロードや処理中の画像を表すことができます。

00:02:03.000 --> 00:02:10.000
macOS Sonomaでは、NSProgressIndicatorでFoundationのProgressタイプを使用できるようになりました。

00:02:10.000 --> 00:02:21.000
新しい observedProgressプロパティに進行状況を割り当てると、進行状況インジケーターは、バックグラウンドスレッドでも、進行状況の変化に応じて自動的に値が更新されます。

00:02:21.000 --> 00:02:28.000
ボタンベゼルスタイルAPIが更新され、まったく新しいベゼルスタイルから始まり、自動です。

00:02:28.000 --> 00:02:37.000
このベゼルスタイルは、ボタンの内容とビュー階層のどこにあるかに応じて、最も適切なスタイルに適応します。

00:02:37.000 --> 00:02:42.000
たとえば、ボタンがウィンドウにある場合、プッシュボタンのスタイルを選択します。

00:02:42.000 --> 00:02:46.000
ボタンがツールバーに配置されると、ツールバーのスタイルが選択されます。

00:02:46.000 --> 00:02:51.000
背の高いコンテンツの場合、ボタンは柔軟なプッシュボタンスタイルを選択します。

00:02:51.000 --> 00:02:59.000
自動ベゼルスタイルは、すべてのボタン初期化子のデフォルトのベゼルスタイルになりました。

00:02:59.000 --> 00:03:07.000
既存のベゼルスタイル名は、その意味的な使用法に基づいて、外観の説明から現代的な名前に更新されました。

00:03:07.000 --> 00:03:17.000
たとえば、以前は「埋め込み」という名前のボタンは「アクセサリーバー」ボタンになり、このベゼルスタイルがアクセサリーバーで最も一般的に使用されていることを示しています。

00:03:17.000 --> 00:03:20.000
落胆したベゼルスタイルは非推奨になりました。

00:03:20.000 --> 00:03:25.000
非推奨は、明確なセマンティック使用法を持つ代替ベゼルスタイルを参照するようになりました。

00:03:25.000 --> 00:03:29.000
私たちは、まったく新しいスプリットビュータイプ、検査官を導入しました。

00:03:29.000 --> 00:03:38.000
インスペクタは、ドキュメントで現在選択されているコンテンツに関するコンテキスト情報を表示する末尾の分割ビュー項目です。

00:03:38.000 --> 00:03:45.000
サイドバーと同様に、インスペクタはフルサイズのコンテンツビューマスクが設定されている場合、ウィンドウの全高値を使用します。

00:03:45.000 --> 00:03:49.000
新しい検査官はmacOS Big Surに再び展開します。

00:03:49.000 --> 00:03:53.000
アプリにインスペクタを追加するのは簡単です。

00:03:53.000 --> 00:03:59.000
まず、新しいinspectorWithViewController初期化子を使用して、新しい分割ビュー項目を作成します。

00:03:59.000 --> 00:04:05.000
次に、新しいsplitViewItemを既存のスプリットビューコントローラーに追加します。

00:04:05.000 --> 00:04:11.000
次に、ツールバーデリゲートを更新して、新しいトグルインスペクタツールバー項目を含めます。

00:04:11.000 --> 00:04:18.000
一般的に、トグルインスペクタ項目をウィンドウの後縁のインスペクタの上に配置したい。

00:04:18.000 --> 00:04:26.000
これを行うには、トグルインスペクタアイテムの前に、新しいインスペクタ追跡セパレータと柔軟なスペースを追加します。

00:04:26.000 --> 00:04:29.000
NSPopoverにいくつかの改善をもたらしました。

00:04:29.000 --> 00:04:34.000
まず、ツールバー項目からポップオーバーをアンカーするサポートを追加しました。

00:04:34.000 --> 00:04:41.000
また、フルサイズのポップオーバーコンテンツをサポートする方法も追加したので、あなたのビューはポップオーバーの境界全体を埋めます。

00:04:41.000 --> 00:04:43.000
ツールバーのアンカーから始めます。

00:04:43.000 --> 00:04:48.000
ツールバー項目を基準にしてポップオーバーを表示する新しい方法があります。

00:04:48.000 --> 00:04:56.000
ツールバー項目がオーバーフローメニューにある場合、ポップオーバーはオーバーフローシェブロンに固定されて優雅に表示されます。

00:04:56.000 --> 00:05:01.000
次に、ポップオーバーコンテンツがポップオーバーシェブロンに拡張できるようになりました。

00:05:01.000 --> 00:05:06.000
色付きの背景ヘッダービューのポップオーバーがあれば、こんな感じだったかもしれません。

00:05:06.000 --> 00:05:11.000
ヘッダーの背景の色はポップオーバーシェブロンに拡張されないことに注意してください。

00:05:11.000 --> 00:05:19.000
ポップオーバーコンテンツをシェブロン領域に拡張するには、新しいhasFullSizeContentプロパティをtrueに設定します。

00:05:19.000 --> 00:05:26.000
セーフエリアrectを使用して、ポップオーバー内で隠すべきではないコンテンツをレイアウトします。

00:05:26.000 --> 00:05:31.000
そして今、私はそれをローリーに渡して、メニューのエキサイティングな変更について話します。

00:05:31.000 --> 00:05:32.000
ローリー:ありがとう、アーシム。

00:05:32.000 --> 00:05:35.000
メニューはCocoaを完全に使用するために書き直されました。

00:05:35.000 --> 00:05:41.000
これにより、メモリとCPU使用率を大幅に削減することで、AppKitの二酸化炭素排出量が削減されます。

00:05:41.000 --> 00:05:45.000
また、新機能も有効にします。

00:05:45.000 --> 00:05:52.000
具体的には、セクションヘッダー、パレットメニュー、新しい選択動作、バッジについて説明します。

00:05:52.000 --> 00:05:59.000
これらの機能は、新しい機会を開き、書く必要があるコードの量を減らします。

00:05:59.000 --> 00:06:06.000
セクションヘッダーは、メニューでグループを伝えるのに役立つ新しい追加であり、1行のコードで作成できます。

00:06:06.000 --> 00:06:13.000
新しいクラス関数、sectionHeader(title:)を使用して作成し、他のメニュー項目と同様にメニューに追加します。

00:06:13.000 --> 00:06:20.000
この例では、3つのメニューセクションが作成され、それぞれにセクションヘッダーと2つの項目があります。

00:06:20.000 --> 00:06:27.000
パレットメニューは、アイテムが水平シリーズでレイアウトされているメニューを構築できるエキサイティングな新機能です。

00:06:27.000 --> 00:06:31.000
例えば、このシンプルなカラーピッカー。

00:06:31.000 --> 00:06:37.000
メニューのpresentationStyleを.paletteに設定することで、任意のメニューをパレットメニューに変えることができます。

00:06:37.000 --> 00:06:40.000
メニュー項目ごとに、その画像を設定します。

00:06:40.000 --> 00:06:46.000
テンプレート画像の場合、AppKitは自動的に適切な選択色合いを追加します。

00:06:46.000 --> 00:06:50.000
または、offStateImageとonStateImageを設定することもできます。

00:06:50.000 --> 00:06:55.000
onStateImageは、選択を示すために使用されます。

00:06:55.000 --> 00:06:58.000
選択できる選択モードがいくつかあります。

00:06:58.000 --> 00:07:05.000
.selectAnyは個々のメニュー項目の状態を切り替えますが、グループ内の他の項目の状態は変更されません。

00:07:05.000 --> 00:07:13.000
.selectOneは、グループの他のメンバーの状態をオフに設定しながら、選択したメニュー項目の状態をオンに設定します。

00:07:13.000 --> 00:07:20.000
selectedItems プロパティを使用して、どのアイテムがオン状態にあるかを取得または設定することもできます。

00:07:20.000 --> 00:07:28.000
注: selectionMode と selectedItems は、同じターゲット/アクションのペアを持つメニュー項目を論理グループに整理することで機能します。

00:07:28.000 --> 00:07:37.000
パレットメニュー項目を手動で作成する場合は、新しいselectionModeとselectedItemsの動作を利用するために、各項目に同じターゲット/アクションペアを与えます。

00:07:37.000 --> 00:07:42.000
そして、ここにヒントがあります:このテクニックはパレットメニューに限定されません。

00:07:42.000 --> 00:07:48.000
また、通常のメニューで同じターゲット/アクションペアを持つメニュー項目にも機能します。

00:07:48.000 --> 00:07:53.000
NSMenuは、一般的なパレットメニューを作成するための便利な機能も提供します。

00:07:53.000 --> 00:07:58.000
色の配列は、パレットアイテムの数とその色合いを決定します。

00:07:58.000 --> 00:08:03.000
タイトルはアクセシビリティに使用されるので、必ず追加してください。

00:08:03.000 --> 00:08:07.000
オプションのテンプレートパラメータは、着色に使用するテンプレート画像を指定します。

00:08:07.000 --> 00:08:12.000
例えば、ここで使われている旗のシンボル画像。

00:08:12.000 --> 00:08:18.000
テンプレートを指定しない場合、AppKitはデフォルトで塗りつぶされた円になります。

00:08:18.000 --> 00:08:21.000
オプションのクロージャパラメータもあります。

00:08:21.000 --> 00:08:26.000
このクロージャは、ユーザーがパレットのメニュー項目を切り替えるときはいつでも呼び出されます。

00:08:26.000 --> 00:08:28.000
メニューは閉鎖に渡されます。

00:08:28.000 --> 00:08:35.000
そこから、selectedItemsプロパティを使用して、on状態のメニュー項目の配列を取得できます。

00:08:35.000 --> 00:08:39.000
メニュー項目は、さまざまな方法でバッジを付けできるようになりました。

00:08:39.000 --> 00:08:44.000
単純な文字列を使用するか、カウントのみを使用できます。

00:08:44.000 --> 00:08:50.000
また、新しいアイテム、アラート、アップデートの3つの特殊なカウントバッジもあります。

00:08:50.000 --> 00:08:55.000
これらのバッジの1つを使用すると、AppKitは自動的に適切なテキストを追加します。

00:08:55.000 --> 00:08:59.000
さらに、AppKitはテキストも適切にローカライズします。

00:08:59.000 --> 00:09:01.000
この例では、日本語。

00:09:01.000 --> 00:09:10.000
ただし、メニュー項目自体と一般的な文字列バッジバリアントをローカライズする責任があることに注意してください。

00:09:10.000 --> 00:09:19.000
これは、パフォーマンス、バッジ、パレット、セクションヘッダーの改善など、まったく新しいメニューの実装です。

00:09:19.000 --> 00:09:23.000
macOS Sonomaでは、Cooperative App Activationを導入しました。

00:09:23.000 --> 00:09:33.000
協力的なアプリのアクティベーションは、入力中のアプリスイッチなど、予期しないアプリケーションスイッチを減らします。

00:09:33.000 --> 00:09:36.000
協力的なアプリのアクティベーションには2つの部分があります。

00:09:36.000 --> 00:09:40.000
アクティベートは、コマンドとは対照的に、リクエストになりました。

00:09:40.000 --> 00:09:47.000
システムは、アクティベーション要求が適切かどうかを判断するために、ユーザーが行っていることのより広い文脈を考慮します。

00:09:47.000 --> 00:09:55.000
新しいイールドAPIにより、アプリケーションは将来のアクティベーションリクエストのコンテキストに影響を与えることができます。

00:09:55.000 --> 00:10:01.000
これでアクティベーションはリクエストなので、無視OtherApps パラメータとオプションは無視されます。

00:10:01.000 --> 00:10:10.000
そのため、macOS Sonomaでは、activate(ignoringOtherApps:)機能とactivateIgnoringOtherAppsオプションはどちらも非推奨です。

00:10:10.000 --> 00:10:17.000
NSApplicationとNSRunningApplicationの新しいアクティベートAPIに置き換えてください。

00:10:17.000 --> 00:10:22.000
アクティブなアプリケーションのみがアクティベートコンテキストに影響を与えることができます。

00:10:22.000 --> 00:10:28.000
これは、ターゲットアプリケーションがアクティブ化される前に、明示的なターゲットアプリケーションに屈することによって行います。

00:10:28.000 --> 00:10:37.000
次に、ターゲットアプリケーションがアクティベーションを要求すると、システムは決定を下す際にコンテキストの一部として歩留まりを使用します。

00:10:37.000 --> 00:10:43.000
リクエストが尊重されると、アクティブなアプリが無効になり、ターゲットアプリがアクティブになります。

00:10:43.000 --> 00:10:47.000
それ以外の場合、アクティブなアプリはアクティブなままです。

00:10:47.000 --> 00:10:54.000
NSWorkspaceは、URLやアプリケーションを開くときに自動的にこれを処理します。

00:10:54.000 --> 00:11:04.000
他のケースでは、別のアプリケーションに手動でアクティベーションを手渡すには、ターゲットNSRunningApplicationまたはバンドル識別子にyieldActivationします。

00:11:04.000 --> 00:11:12.000
システムは、ターゲットアプリがアクティベーションを要求するとき、またはそれに代わってアクティベートされたときに、イールドコンテキストを使用します。

00:11:12.000 --> 00:11:16.000
それが新しい協力的なアプリのアクティベーション行動です。

00:11:16.000 --> 00:11:23.000
また、いくつかの重要な変更を加え、macOS Sonomaのグラフィックと描画に新しいAPIを追加しました。

00:11:23.000 --> 00:11:28.000
NSBezierPathsからCGPathsを作成できるようになり、その逆も同様です。

00:11:28.000 --> 00:11:34.000
NSBezierPathは、新しいinit(cgPath:)初期化子とcgPathプロパティを取得します。

00:11:34.000 --> 00:11:40.000
cgPath でイニシッティング、設定、または取得すると、常にパスのコピーが作成されます。

00:11:40.000 --> 00:11:47.000
NSBezierPathのさらなる突然変異は、オリジナルまたはコピーのCGPathインスタンスに反映されません。

00:11:47.000 --> 00:11:50.000
つまり、それらはフリーダイヤルブリッジではありません。

00:11:50.000 --> 00:12:00.000
この追加により、1行のコードであるCAShapeLayerのpathプロパティなど、CGPath APIでNSBezierPathを使用できます。

00:12:00.000 --> 00:12:04.000
macOSでCADisplayLinkオブジェクトを作成できるようになりました。

00:12:04.000 --> 00:12:08.000
これは、あなたがiOSからよく知っているかもしれないのと同じCADisplayLinkです。

00:12:08.000 --> 00:12:17.000
CADisplayLinkに精通していない人にとっては、アプリが図面をディスプレイのリフレッシュレートに同期させることを可能にするタイマーオブジェクトです。

00:12:17.000 --> 00:12:25.000
直接初期化されたディスプレイリンクオブジェクトはメインディスプレイと同期されますが、macOSは単一のディスプレイに限定されません。

00:12:25.000 --> 00:12:37.000
したがって、macOSでは、新しいdisplayLink(target:selector:)機能を使用して、NSView、NSWindow、またはNSScreenから直接ディスプレイリンクオブジェクトを取得できます。

00:12:37.000 --> 00:12:47.000
最善のアプローチは、最も特定の適用可能な要素、通常はビューから直接CADisplayLinkオブジェクトを取得することです。

00:12:47.000 --> 00:13:02.000
これは、ビューまたはウィンドウから作成すると、CADisplayLinkは、ディスプレイにないときに自分自身を一時停止するなど、デスクトップ上を移動するウィンドウのディスプレイまたはビューを自動的に追跡するためです。

00:13:02.000 --> 00:13:21.000
このビューサブクラスでは、2行のコードでstartAnimatingが呼び出されると、stepAnimation関数を呼び出すDisplayLinkオブジェクトを作成し、ビューがオンになっているディスプレイに同期し、共通モードのメインランループにdisplayLinkを追加します。

00:13:21.000 --> 00:13:29.000
アニメーションが完了すると、無効化を呼び出して表示リンクを停止し、登録されたすべてのランループモードから削除します。

00:13:29.000 --> 00:13:35.000
NSColorは現在、背景形状を埋めるための5つの新しいシステムカラーを提供しています。

00:13:35.000 --> 00:13:40.000
塗りつぶし色は、さまざまなサイズの形状にさまざまなレベルの重点を提供します。

00:13:40.000 --> 00:13:50.000
スライダートラックやプログレスバーの背景のスケールの小さな図形は、システムフィルやセカンダリシステムフィルなど、より高いレベルの強調を使用して目立ちます。

00:13:50.000 --> 00:13:59.000
グループボックスやフォントの背景などの大きな図形は、四元数や五分システムの塗りつぶしなど、より微妙なレベルの強調を好みます。

00:13:59.000 --> 00:14:08.000
これらの塗りつぶし色は動的なので、コントラストの増加やダークモードなど、さまざまな外観に自動的に適応します。

00:14:08.000 --> 00:14:18.000
カスタムUI要素を構築している場合、これらの新しい塗りつぶし色は、システム設計に適合し、アクセシビリティをサポートする便利な方法です。

00:14:18.000 --> 00:14:22.000
NSViewsは、描画内容を限界までクリップします。

00:14:22.000 --> 00:14:31.000
それは時々、FreeFormアラートウィンドウのこのヒンディー語グリフの下部のように、あなたが望むように表示しない描画につながります。

00:14:31.000 --> 00:14:42.000
これが起こりうる一般的な場所は、フォントレンダリング、シャドウ、またはその他のサブビューのアクセント、販売用の「ホット」アイテムのバッジや炎などです。

00:14:42.000 --> 00:14:44.000
これを解決する方法があります。

00:14:44.000 --> 00:14:49.000
たとえば、結合されたビューをより大きなビューに兄弟として埋め込みます。

00:14:49.000 --> 00:14:52.000
しかし、それぞれのテクニックには独自の欠点があります。

00:14:52.000 --> 00:15:01.000
この場合、囲むビューと単純な水平スタックのボタンを組み合わせると、デフォルトではテキストのベースラインが並べられません。

00:15:01.000 --> 00:15:05.000
そして今、あなたは解決すべき別の問題があります。

00:15:05.000 --> 00:15:07.000
もっといい方法があります。

00:15:07.000 --> 00:15:15.000
macOS Sonomaでリンクすると、ほとんどのNSViewはデフォルトで境界にクリップされなくなりました。

00:15:15.000 --> 00:15:20.000
ヒットテストは変更されず、ビューのジオメトリによって決定されます。

00:15:20.000 --> 00:15:23.000
もちろん、hitTestをオーバーライドしてこれを変更できます。

00:15:23.000 --> 00:15:30.000
ビューがその境界の外に描画される可能性があるので、その計算されたvisibleRectもその境界を超えて拡張する可能性があります。

00:15:30.000 --> 00:15:35.000
visibleRectを使用するコードを確認し、それに応じて調整します。

00:15:35.000 --> 00:15:39.000
これは、ドロー関数のdirtyRectパラメータにも影響します。

00:15:39.000 --> 00:15:45.000
具体的には、dirtyRectはビューの境界に制約されません。

00:15:45.000 --> 00:15:50.000
AppKitは、ビューの境界よりも大きいdirtyRectを渡す権利を留保します。

00:15:50.000 --> 00:15:56.000
AppKitはまた、図面を必要な数の長方形に細分化する権利を留保します。

00:15:56.000 --> 00:16:05.000
これがあなたにとって意味することは、dirtyRectを使用して、どこに描くかではなく、何を描くかを決める必要があるということです。

00:16:05.000 --> 00:16:09.000
これは、発生する可能性のある予期しない描画結果の例です。

00:16:09.000 --> 00:16:19.000
このドローオーバーライドは、dirtyRectで渡されたものを背景色で塗りつぶし、塗りつぶしがビューの境界の外にこぼれ、ウィンドウ内の他のUIをカバーします。

00:16:19.000 --> 00:16:24.000
ビューは、フレームを描画するためにdirtyRectを使用していません。

00:16:24.000 --> 00:16:33.000
同様に、その背景の塗りつぶしは、あなたのデザインが必要とするものを正確に塗りつぶす必要があります。

00:16:33.000 --> 00:16:36.000
dirtyRectの外に絵を描くことは常に安全です。

00:16:36.000 --> 00:16:44.000
dirtyRectのパフォーマンスの利点は、このパスで描画を避けることができるデータのどの部分を決定するために使用されるときに発生します。

00:16:44.000 --> 00:16:50.000
おそらく、この派手なスタイルで私の名前のストロークパスを計算するのは高価です。

00:16:50.000 --> 00:16:58.000
dirtyRectがこの小さなコーナーであれば、テキストフレームと交差しないので、ビューはそれらの高価な計算を避けることができます。

00:16:58.000 --> 00:17:14.000
背景とフレームの描画はまだ必要ですが、境界全体を満たし、このパスでフレーム全体を描くことは、AppKitが図面をdirtyRectにクリップするため、ビューの他のすでに描画された部分には影響しません。

00:17:14.000 --> 00:17:21.000
新しいNSView .clipsToBoundsプロパティは、OS X Mavericks 10.9までさかのぼって利用できます。

00:17:21.000 --> 00:17:26.000
しかし、古いOSでは、.clipsToBoundsをオフにすると、いくつかの粗いエッジがある可能性があることに注意してください。

00:17:26.000 --> 00:17:28.000
それに応じてテストしてください。

00:17:28.000 --> 00:17:33.000
ほとんどのビューは、クリッピングのオンとオフの両方で問題なく動作します。

00:17:33.000 --> 00:17:37.000
一部のコンテナビューは、独自の明示的な決定を下します。

00:17:37.000 --> 00:17:40.000
NSClipViewは、その名前に忠実で、このように動作します。

00:17:40.000 --> 00:17:48.000
ビューのデフォルトのクリッピング動作に同意し、選択的に変更する必要がある特定の場合があります。

00:17:48.000 --> 00:17:55.000
あなた自身のビューのどれが明示的なclipsToBounds値を必要とするかをケースバイケースで検討してください。

00:17:55.000 --> 00:17:59.000
正しい選択は、あなたのアプリのビジョンを実現するものです。

00:17:59.000 --> 00:18:03.000
さて、画像について話すためにアーシムに戻ります。

00:18:03.000 --> 00:18:04.000
アーシム:ありがとう、ローリー。

00:18:04.000 --> 00:18:08.000
シンボルは、アプリの設計に不可欠な部分です。

00:18:08.000 --> 00:18:13.000
macOS Sonomaでは、シンボルはまったく新しい機能、シンボル効果を得ます。

00:18:13.000 --> 00:18:25.000
シンボル効果を使用すると、シンボルはバウンス、置換トランジション、パルスアニメーションなどの効果を持つことができます。

00:18:25.000 --> 00:18:32.000
シンボル効果は、アプリで発生したアクションや状態の変化を強調する素晴らしい方法です。

00:18:32.000 --> 00:18:35.000
シンボル効果の追加は簡単です。

00:18:35.000 --> 00:18:40.000
まず、imageViewの画像プロパティをシンボル画像に設定します。

00:18:40.000 --> 00:18:46.000
次に、エフェクトが必要な場合は、画像ビューにaddSymbolEffectを呼び出すだけです。

00:18:46.000 --> 00:18:52.000
これは、NSImageViewがシンボル画像を使用している場合にのみ機能することに注意してください。

00:18:52.000 --> 00:18:59.000
シンボルエフェクトの使用の詳細については、「アプリでシンボルをアニメーション化する」ビデオをご覧ください。

00:18:59.000 --> 00:19:06.000
macOS Venturaでは、ユーザーの現在のロケールに自動的に適応するためのSFシンボルのサポートを導入しました。

00:19:06.000 --> 00:19:13.000
macOS Sonomaでは、アセットカタログの画像とシンボルが同じ機能を取得します。

00:19:13.000 --> 00:19:19.000
macOS VenturaのSFシンボルと同様に、デフォルトではシステムロケールに従います。

00:19:19.000 --> 00:19:24.000
画像ロケールメソッドを使用して、固定ロケールで画像を取得します。

00:19:24.000 --> 00:19:30.000
次に、ハイダイナミックレンジのコンテンツ、略してHDRについて話します。

00:19:30.000 --> 00:19:35.000
HDRコンテンツは、標準コンテンツをはるかに超える光レベルを表現できます。

00:19:35.000 --> 00:19:48.000
macOSはいくつかのリリースで拡張ダイナミックレンジをサポートしており、Macbook ProのLiquid Retina XDRやPro Display XDRなどのディスプレイを最大限に活用できます。

00:19:48.000 --> 00:19:56.000
macOS Sonomaは、NSImageViewがHDRコンテンツをサポートすることで、アプリにHDRコンテンツをこれまで以上に簡単に表示できるようにします。

00:19:56.000 --> 00:20:04.000
HDRコンテンツを含む画像は、拡張ダイナミックレンジ対応ハードウェアでHDRで表示されるようになりました。

00:20:04.000 --> 00:20:12.000
標準のダイナミックレンジでHDRコンテンツを表示するには、preferredImageDynamicRangeプロパティを使用してオーバーライドします。

00:20:12.000 --> 00:20:19.000
このAPIの採用の詳細については、「アプリでHDR画像をサポートする」ビデオをご覧ください。

00:20:19.000 --> 00:20:28.000
Xcode 15以降、アセットカタログの画像と色は、NSImageとNSColorの静的プロパティとして自動的にコードに反映されます。

00:20:28.000 --> 00:20:34.000
これにより、文字列で初期化するのではなく、クリーンなドット表記を使用して画像にアクセスできます。

00:20:34.000 --> 00:20:40.000
画像はオプションではないので、強制的なアンラッピングやガードチェックを削除することもできます。

00:20:40.000 --> 00:20:54.000
アセットカタログを変更して画像を削除または名前を変更すると、コンパイラはコードとの不一致をキャッチし、アプリの構築時にエラーが発生し、後で実行時にキャッチするのではなく、すぐに修正することができます。

00:20:54.000 --> 00:21:02.000
macOS Sonomaでは、タイピング体験が大幅に変更され、英語以外の言語のテキストレイアウトが改善されました。

00:21:02.000 --> 00:21:15.000
それは、現在のアクセントカラーに適応する真新しい挿入インジケーターから始まり、テキストを口述する際に後続の輝きを残します。

00:21:15.000 --> 00:21:25.000
次に、挿入インジケーターの下にカーソルアクセサリがあり、入力モード、ディクテーション状態、caps lock状態などの重要な情報が表示されます。

00:21:25.000 --> 00:21:36.000
アクセサリは現在の挿入位置を追跡し、挿入位置が可視ビューの外にある場合、ドキュメントの下部に固定されます。

00:21:36.000 --> 00:21:40.000
標準のAppKitテキストビューを使用するアプリは、これを自動的に取得します。

00:21:40.000 --> 00:21:45.000
カスタムテキストビューをお持ちの場合は、採用できる新しいAPIがあります。

00:21:45.000 --> 00:21:51.000
カスタムテキスト挿入インジケータの描画をNSTextInsertionIndicatorビューに置き換えることができます。

00:21:51.000 --> 00:21:59.000
このビューをカスタムテキストビューのサブビューとして追加すると、OS全体で一貫性のある新しい挿入インジケーターが表示されます。

00:21:59.000 --> 00:22:05.000
挿入インジケーターのフレームの更新と、それが表示されているかどうかを担当することに注意してください。

00:22:05.000 --> 00:22:11.000
テキストビューがファーストレスポンダーを辞任したときにdisplayModeプロパティを非表示に更新してインジケーターを非表示にします。

00:22:11.000 --> 00:22:17.000
MacOS Sonomaは、英語以外の言語のテキストレイアウトにいくつかの改善が施されています。

00:22:17.000 --> 00:22:27.000
重要なハイライトは、テキストコンテキストに応じて改行に異なるルールを必要とする言語によって、ラッピングとハイフネーションのために行った変更です。

00:22:27.000 --> 00:22:37.000
たとえば、韓国語の伝統的な組版では、本文テキストは単語の真ん中に改行があるかもしれませんが、タイトルテキストは単語の境界でのみラップされます。

00:22:37.000 --> 00:22:41.000
タイトルの単語を壊すと、韓国語で耳障りに感じることがあります。

00:22:41.000 --> 00:22:46.000
マップのこのシートでは、韓国語の「時間」は2行に分かれています。

00:22:46.000 --> 00:22:52.000
macOS Sonomaは、使用するテキストスタイルのフォントに応じて異なる改行を実行するようになりました。

00:22:52.000 --> 00:22:58.000
韓国語では、このシートのようなタイトルと見出しのテキストスタイルは、単語の境界でラップされません。

00:22:58.000 --> 00:23:03.000
必要に応じて、本文テキストスタイルは単語内に改行がある場合があります。

00:23:03.000 --> 00:23:04.000
これは別の例です。

00:23:04.000 --> 00:23:14.000
狭いレイアウトでは、一部のドイツ語の単語は行幅全体よりも長くなる可能性があり、個々の文字が次の行にこぼれる可能性があります。

00:23:14.000 --> 00:23:16.000
このラッピングは理想的ではありません。

00:23:16.000 --> 00:23:23.000
それは不均衡に見え、形態素と呼ばれる単語の構成要素があり、それは行に分割されています。

00:23:23.000 --> 00:23:33.000
macOS Sonomaでは、ハイフネーションが無効になっているタイトルテキストフィールドがある場合、macOSは文字の折り返しではなく、形態素の境界でテキストを自動的にハイフネーションします。

00:23:33.000 --> 00:23:37.000
結果として得られるレイアウトは、よりバランスが取れており、読みやすくなっています。

00:23:37.000 --> 00:23:42.000
これは、アプリでテキストスタイルを採用するのに最適な時期です。

00:23:42.000 --> 00:23:51.000
macOS Sonomaでは、AppKitが更新され、Swiftの並行性や譲渡可能などのSwiftファースト機能の採用が容易になりました。

00:23:51.000 --> 00:23:59.000
SwiftUIも更新され、AppKitアプリのより多くの場所でSwiftUIビューと修飾子を使用できるようになります。

00:23:59.000 --> 00:24:04.000
AppKitクラスの大半はメインスレッドに制限されています。

00:24:04.000 --> 00:24:10.000
Swiftの並行性では、これらのクラスは適切なコンパイラエラーを生成するためのメインアクターとしてマークされます。

00:24:10.000 --> 00:24:18.000
ただし、AppKitには、NSColorやNSShadowなど、メインスレッドの外で安全にアクセスできる特定のクラスがあります。

00:24:18.000 --> 00:24:28.000
macOS Sonomaでは、これらのクラスはSendableプロトコルに準拠しており、アクターの境界を越えて自由に転送できることを示します。

00:24:28.000 --> 00:24:34.000
Transferableは、オブジェクトをシリアライズおよびデシリアライズする方法を説明するSwiftプロトコルです。

00:24:34.000 --> 00:24:39.000
これは、SwiftUIでのドラッグ&amp;ドロップや共有などの機能を強化します。

00:24:39.000 --> 00:24:46.000
macOS Sonoma NSImageでは、NSColor、およびNSSoundはTransferableプロトコルに準拠しています。

00:24:46.000 --> 00:24:53.000
これにより、AppKitアプリはSwiftUIビューでのドラッグ&amp;ドロップや共有などの機能を簡単に採用できます。

00:24:53.000 --> 00:25:00.000
macOS Ventura 13.3では、NSViewControllerの新しいプロパティラッパー、ViewLoadingを導入しました。

00:25:00.000 --> 00:25:04.000
loadViewで初期化されたプロパティでViewLoadingを使用します。

00:25:04.000 --> 00:25:11.000
これらのプロパティが以前にオプションだった場合は、オプションと関連するチェックを削除できます。

00:25:11.000 --> 00:25:16.000
ビューコントローラーは、loadViewIfNeededを呼び出すことで、プロパティが初期化されていることを確認します。

00:25:16.000 --> 00:25:23.000
同様のプロパティラッパーであるWindowLoadingは、NSWindowControllerのプロパティでも使用できます。

00:25:23.000 --> 00:25:29.000
Xcode 15では、プレビューを使用してAppKitビューとビューコントローラーを表示できるようになりました。

00:25:29.000 --> 00:25:35.000
新しいプレビューマクロを使用し、名前を指定し、ビューまたはビューコントローラーを返します。

00:25:35.000 --> 00:25:39.000
コードを変更すると、プレビューは最新の状態に保たれます。

00:25:39.000 --> 00:25:47.000
詳細については、「XcodeプレビューでプログラマティックUIを構築する」ビデオをご覧ください。

00:25:47.000 --> 00:25:54.000
NSHostingViewとNSHostingControllerは、AppKitアプリにSwiftUIを段階的に採用する素晴らしい方法です。

00:25:54.000 --> 00:26:00.000
macOS Sonomaには、より多くの場所でSwiftUIを採用できる新機能がいくつかあります。

00:26:00.000 --> 00:26:05.000
ツールバーやナビゲーションタイトルなどのSwiftUI修飾子がNSWindowsで動作するようになりました。

00:26:05.000 --> 00:26:13.000
hostingViewがウィンドウのcontentViewの場合、SwiftUIは利用可能なすべてのシーン修飾子を自動的にNSWindowにブリッジします。

00:26:13.000 --> 00:26:20.000
より多くの制御のために、NSHostingViewとNSHostingControllerに新しいプロパティ、sceneBridgingOptionsがあります。

00:26:20.000 --> 00:26:27.000
これを使用すると、SwiftUIビューからNSWindowにブリッジする必要があるプロパティを明示的に述べることができます。

00:26:27.000 --> 00:26:31.000
これは、macOS SonomaのAppKitの新機能のほんの一部です。

00:26:31.000 --> 00:26:32.000
次は何ですか?

00:26:32.000 --> 00:26:42.000
まず、macOS Sonoma SDKを使用してアプリをコンパイルし、それを監査して、クリッピングとアクティベーションの変更が望ましくない副作用を引き起こさないことを確認します。

00:26:42.000 --> 00:26:50.000
次に、新しいフルハイトインスペクタや新しいテーブル列のカスタマイズAPIなど、新しいコントロールAPIを採用します。

00:26:50.000 --> 00:26:55.000
macOS Sonomaのシンボル効果を利用するために、アプリのデザインを更新してください。

00:26:55.000 --> 00:27:05.000
そして最後に、TransferableやNSHostingViewの改善など、新しいSwiftに焦点を当てたAppKitの追加を使用して、アプリのより多くの場所でSwiftUIを採用します。

00:27:05.000 --> 00:27:07.000
見てくれてありがとう。

00:27:07.000 --> 00:27:10.000
macOS Sonomaのすべての新機能をお楽しみください!

00:27:10.000 --> 23:59:59.000
♪ ♪

