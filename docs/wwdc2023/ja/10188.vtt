WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:14.000
ティム：こんにちは、私はティムです。CloudKitチームのエンジニアです。

00:00:14.000 --> 00:00:19.000
同僚のAamerと私は、CKSyncEngineと呼ばれる新しいCloudKit APIについて話すためにここにいます。

00:00:19.000 --> 00:00:23.000
CKSyncEngineは、デバイスとクラウド間でデータを同期するのに役立つように設計されています。

00:00:23.000 --> 00:00:27.000
まず、AppleプラットフォームでのCloudKitへの同期の状態について説明します。

00:00:27.000 --> 00:00:32.000
次に、CKSyncEngineとは何か、どのように機能するかの概要を説明します。

00:00:32.000 --> 00:00:37.000
その後、自分のプロジェクトでCKSyncEngineを使い始める方法について学びます。

00:00:37.000 --> 00:00:42.000
設定が完了したら、同期エンジンを使用してデバイス間でデータを同期する方法を学びます。

00:00:42.000 --> 00:00:48.000
最後に、CKSyncEngineとの統合をテストおよびデバッグするためのベストプラクティスについて学びます。

00:00:48.000 --> 00:00:54.000
まず、CloudKitへの同期の状態。

00:00:54.000 --> 00:00:57.000
新しいアプリを構築するとき、人々は自分のデータが同期することを期待するだけです。

00:00:57.000 --> 00:01:02.000
彼らはiPhoneで何かを作り、Macを開くと、それもそこにあることを期待しています。

00:01:02.000 --> 00:01:05.000
外から見ると、これは魔法のように見えます。

00:01:05.000 --> 00:01:09.000
彼らのデータは1か所にあり、どこにでもある。

00:01:09.000 --> 00:01:11.000
あなたと私にとって、それはそれほど簡単ではありません。

00:01:11.000 --> 00:01:16.000
CloudKit自体はそれほど複雑ではありませんが、一般的に同期は難しいです。

00:01:16.000 --> 00:01:21.000
複数のデバイスをシナリオに持ち込むと、うまくいかないことがたくさんあります。

00:01:21.000 --> 00:01:25.000
したがって、同期コードをシンプルにすればするほど良いです。

00:01:25.000 --> 00:01:29.000
そして、同期コードを簡素化する最善の方法は、できるだけ少なく書くことです。

00:01:29.000 --> 00:01:37.000
ありがたいことに、CloudKitと同期するためのいくつかの素晴らしいAPIの選択肢があり、これらのAPIはあなたのために多くの重労働をします。

00:01:37.000 --> 00:01:43.000
ローカル永続性を含むフルスタックソリューションが必要な場合は、NSPersistentCloudKitContainerを使用できます。

00:01:43.000 --> 00:01:49.000
独自のローカル永続性を持参したい場合は、新しいCKSyncEngine APIを使用できます。

00:01:49.000 --> 00:01:54.000
それでもよりきめ細かな制御が必要だと思われる場合は、CKDatabaseとCKOperationsを使用できます。

00:01:54.000 --> 00:02:00.000
しかし、CloudKitと同期したい場合、NSPersistentCloudKitContainerを使用していない場合は、CKSyncEngineを使用する必要があります。

00:02:00.000 --> 00:02:10.000
同期には多くの可動部分が含まれており、CKSyncEngineのようなより高いレベルのAPIを使用すると、複雑さを軽減し、アプリの同期体験を向上させるのに役立ちます。

00:02:10.000 --> 00:02:20.000
そのコアでは、同期は主に、あるデバイスから変更を送信し、別のデバイスで取得し、必要に応じてCloudKitレコードとの間で変換することです。

00:02:20.000 --> 00:02:24.000
それは単独で行うのはかなり簡単ですが、それ以上のものがあります。

00:02:24.000 --> 00:02:36.000
すべての異なる操作とエラーについて学び、システムの状態を監視し、アカウントの変更をリッスンし、プッシュ通知を処理し、サブスクリプションを管理し、多くの状態を追跡する必要があります。

00:02:36.000 --> 00:02:41.000
CKSyncEngineを使用すると、書かなければならない同期コードの量がはるかに小さくなり、より集中的になります。

00:02:41.000 --> 00:02:47.000
アプリに固有のものを処理するだけで、同期エンジンが残りを処理します。

00:02:47.000 --> 00:02:56.000
適切な同期エンジンを書くには、おそらく数千行のコードが必要で、テストでその量を2倍にする必要があります。

00:02:56.000 --> 00:03:03.000
私は実際にNSPersistentCloudKitContainerが70,000行以上のテストに裏打ちされているという噂を聞きました。

00:03:03.000 --> 00:03:09.000
CKSyncEngineにもかなりの数のテストがあり、それはあなたのためにこのようなものの多くを処理するからです。

00:03:09.000 --> 00:03:13.000
では、この新しいCKSyncEngine APIとは何ですか?

00:03:13.000 --> 00:03:17.000
CKSyncEngineは、CloudKitデータベースと同期するための一般的なロジックをカプセル化します。

00:03:17.000 --> 00:03:23.000
必要に応じて柔軟性を与えながら、便利なAPIを提供することを目的としています。

00:03:23.000 --> 00:03:28.000
独自のカスタム同期エンジンを作成するほとんどのアプリのニーズを満たすように設計されています。

00:03:28.000 --> 00:03:35.000
一般的に、アプリのプライベートデータや共有データを同期したい場合、CKSyncEngineは素晴らしい選択です。

00:03:35.000 --> 00:03:42.000
同期エンジンで使用するデータモデルは、CloudKitの残りの部分で使用されるデータと同じタイプのレコードとゾーンで構成されています。

00:03:42.000 --> 00:03:47.000
既存のCloudKit APIを使用して、このデータにアクセスできます。

00:03:47.000 --> 00:03:53.000
このため、既存のCloudKit同期実装がすでにある場合、CKSyncEngineもそれと同期できます。

00:03:53.000 --> 00:04:00.000
同期エンジンは、Freeformアプリを含むシステム全体のいくつかのアプリやサービスで使用されています。

00:04:00.000 --> 00:04:06.000
もう1つの例は、同期エンジンの上に書き換えられたNSUbiquitousKeyValueStoreです。

00:04:06.000 --> 00:04:09.000
これは、下位互換性のあるユースケースの良い例です。

00:04:09.000 --> 00:04:15.000
新しいOSでは同期エンジンを使用しますが、以前のバージョンと同期します。

00:04:15.000 --> 00:04:21.000
したがって、すでにカスタムCloudKit同期実装がある場合は、CKSyncEngineに切り替えるオプションがあります。

00:04:21.000 --> 00:04:27.000
利点が十分に魅力的に聞こえる場合は、切り替えを検討する必要がありますが、必須ではありません。

00:04:27.000 --> 00:04:31.000
時には、維持するコードが少ないのはいいことです。

00:04:31.000 --> 00:04:35.000
また、CKSyncEngineが新しい機能強化を受けるたびに恩恵を受けることができます。

00:04:35.000 --> 00:04:43.000
プラットフォームが進化するにつれて、同期エンジンも進化し、時間が経つにつれて同期がより簡単かつ効率的になります。

00:04:43.000 --> 00:04:47.000
また、CKSyncEngineのより小さなAPIサーフェスの恩恵を受けるかもしれません。

00:04:47.000 --> 00:04:51.000
これにより、アプリの特定のデータモデルとユースケースに集中できます。

00:04:51.000 --> 00:04:58.000
CKSyncEngineの使用を検討しているが、サポートしていない特定のニーズがある場合は、必要に応じていつでも独自のニーズを構築できます。

00:04:58.000 --> 00:05:05.000
ただし、CKSyncEngineの新機能によってニーズが満たされると思われる場合は、ユースケースにフィードバックを提出することを検討してください。

00:05:05.000 --> 00:05:11.000
結局のところ、同期エンジンの最高のアイデアのいくつかは、あなたのような開発者から来ています。

00:05:11.000 --> 00:05:14.000
では、同期エンジンは実際にどのように機能しますか?

00:05:14.000 --> 00:05:19.000
一般的に、同期エンジンはアプリとCloudKitサーバー間のデータの導管として機能します。

00:05:19.000 --> 00:05:23.000
アプリは、レコードとゾーンの観点から同期エンジンと通信します。

00:05:23.000 --> 00:05:27.000
保存する変更がある場合、アプリはそれらを同期エンジンに提供します。

00:05:27.000 --> 00:05:31.000
これらの変更を別のデバイスでフェッチすると、アプリに渡されます。

00:05:31.000 --> 00:05:36.000
そうは言っても、同期エンジンがやるべき仕事があるとき、それは必ずしもすぐにそれを行うとは限りません。

00:05:36.000 --> 00:05:40.000
サーバーと通信する必要がある場合は、まずシステムタスクスケジューラに相談します。

00:05:40.000 --> 00:05:47.000
これは、バックグラウンドタスク管理のためにOS全体で使用されているのと同じスケジューラであり、デバイスが同期する準備ができていることを確認します。

00:05:47.000 --> 00:05:52.000
デバイスの準備が整うと、スケジューラはタスクを実行し、同期エンジンはサーバーと通信します。

00:05:52.000 --> 00:05:56.000
これは、同期エンジンの基本的な操作フローです。

00:05:56.000 --> 00:06:01.000
具体的には、同期エンジンがサーバーに変更を送信すると、どのように見えますか?

00:06:01.000 --> 00:06:04.000
まず、誰かがデータに変更を加えます。

00:06:04.000 --> 00:06:09.000
たぶん、彼らは何かを入力したり、スイッチを切り替えたり、オブジェクトを削除したりしました。

00:06:09.000 --> 00:06:13.000
その後、アプリはサーバーに送信する保留中の変更があることを同期エンジンに伝えます。

00:06:13.000 --> 00:06:17.000
これにより、同期エンジンにはやるべき仕事があることを知らせます。

00:06:17.000 --> 00:06:20.000
次に、同期エンジンはスケジューラにタスクを送信します。

00:06:20.000 --> 00:06:24.000
デバイスの準備ができたら、スケジューラがタスクを実行します。

00:06:24.000 --> 00:06:29.000
タスクが実行されると、同期エンジンはサーバーに変更を送信するプロセスを開始します。

00:06:29.000 --> 00:06:33.000
そのために、送信する変更の次のバッチをアプリに要求します。

00:06:33.000 --> 00:06:38.000
誰かが1つの変更を行った場合、保留中の変更は1つしかないかもしれません。

00:06:38.000 --> 00:06:45.000
しかし、誰かが新しいデータの巨大なデータベースをインポートすると、何百、何千もの変更があるかもしれません。

00:06:45.000 --> 00:06:51.000
1回のリクエストでサーバーに送信できる量に制限があるため、同期エンジンはこれらの変更をバッチで要求します。

00:06:51.000 --> 00:06:57.000
これは、実際に必要になるまでレコードをメモリに持ち込まないようにすることで、メモリのオーバーヘッドを減らすのにも役立ちます。

00:06:57.000 --> 00:07:01.000
次のバッチを提供すると、同期エンジンはそれをサーバーに送信します。

00:07:01.000 --> 00:07:08.000
サーバーは、これらの変更の成功または失敗に関する情報を含め、操作の結果に応答します。

00:07:08.000 --> 00:07:12.000
リクエストが終了すると、同期エンジンは結果をアプリで呼び戻します。

00:07:12.000 --> 00:07:17.000
これは、操作の成功または失敗に反応する機会です。

00:07:17.000 --> 00:07:24.000
これ以上保留中の変更がある場合、同期エンジンは送信するものがなくなるまでバッチを要求し続けます。

00:07:24.000 --> 00:07:29.000
1つのデバイスがサーバーにデータを送信したので、他のデバイスはそのデータを取得します。

00:07:29.000 --> 00:07:36.000
サーバーが新しい変更を受信すると、そのデータにアクセスできる他のデバイスにプッシュ通知を送信します。

00:07:36.000 --> 00:07:40.000
CKSyncEngineは、アプリでこれらのプッシュ通知を自動的にリッスンします。

00:07:40.000 --> 00:07:44.000
通知を受け取ると、タスクをスケジューラに送信します。

00:07:44.000 --> 00:07:49.000
スケジューラタスクが実行されると、同期エンジンはサーバーからフェッチします。

00:07:49.000 --> 00:07:52.000
新しい変更を取得すると、アプリにそれらが提供されます。

00:07:52.000 --> 00:07:56.000
これは、これらの変更をローカルに保持し、UIに表示するチャンスです。

00:07:56.000 --> 00:08:00.000
そして、それが同期エンジンを使用するときの基本的な操作の流れです。

00:08:00.000 --> 00:08:04.000
これらのフローに共通していることの1つは、システムスケジューラです。

00:08:04.000 --> 00:08:08.000
一般的に、CKSyncEngineは何かをする前にスケジューラに相談します。

00:08:08.000 --> 00:08:13.000
これは、あなたに代わって自動的に同期する方法です。

00:08:13.000 --> 00:08:19.000
スケジューラは、ネットワーク接続、バッテリー残量、リソース使用量などのシステム状態を監視します。

00:08:19.000 --> 00:08:24.000
同期を試みる前に、デバイスが前提条件条件を満たしていることを確認します。

00:08:24.000 --> 00:08:31.000
スケジューラを尊重することで、同期エンジンはユーザーエクスペリエンスとデバイスリソースの適切なバランスを確保することができます。

00:08:31.000 --> 00:08:36.000
通常の状況では、同期はかなり速く、通常は数秒かそこら以内になります。

00:08:36.000 --> 00:08:43.000
ただし、ネットワーク接続がない場合、またはデバイスのバッテリー残量が少ない場合は、同期が遅延または延期される可能性があります。

00:08:43.000 --> 00:08:51.000
デバイスが負荷が高い場合は、同期メカニズムがアプリ内の他のより緊急なタスクに干渉したくありません。

00:08:51.000 --> 00:08:58.000
同期エンジンの自動スケジューリングに頼ることで、すべきでない時ではなく、すべき時に同期することを確信できます。

00:08:58.000 --> 00:09:01.000
より効率的であるだけでなく、より使いやすいです。

00:09:01.000 --> 00:09:06.000
いつ同期するかを心配する必要がなければ、他のすべてに集中できます。

00:09:06.000 --> 00:09:11.000
とはいえ、同期を手動で実行するための正当なユースケースがあります。

00:09:11.000 --> 00:09:14.000
すぐにフェッチするプルツーリフレッシュUIがあるかもしれません。

00:09:14.000 --> 00:09:20.000
または、保留中の変更をサーバーにすぐに送信するバックアップボタンがあるかもしれません。

00:09:20.000 --> 00:09:24.000
手動同期は、自動テストを書くときにも役立ちます。

00:09:24.000 --> 00:09:31.000
イベントの順序を制御する必要がある複数のデバイス間で特定の同期シナリオをシミュレートするのに役立ちます。

00:09:31.000 --> 00:09:34.000
一般的に、自動同期スケジューリングに頼ることをお勧めします。

00:09:34.000 --> 00:09:41.000
しかし、手動同期には有効なユースケースがあり、同期エンジンには必要に応じてそれを行うためのAPIがあることを理解しています。

00:09:41.000 --> 00:09:46.000
そして今、AamerはCKSyncEngineの使用を開始する方法について話します。

00:09:46.000 --> 00:09:49.000
Aamer: 紹介してくれてありがとう、ティム。

00:09:49.000 --> 00:09:50.000
私の名前はAamerです。

00:09:50.000 --> 00:09:53.000
私はCloudKitクライアントチームのエンジニアです。

00:09:53.000 --> 00:09:57.000
CKSyncEngineを使い始めることについて説明します。

00:09:57.000 --> 00:10:03.000
CKSyncEngineを使用する前に、プロジェクトを設定するために行う必要があることがいくつかあります。

00:10:03.000 --> 00:10:10.000
これらの要件は、CKSyncEngineを使用している場合でも、独自のカスタムCloudKit実装を構築している場合でも、同じです。

00:10:10.000 --> 00:10:19.000
まず、CloudKitの基本的なデータタイプであるCKRecordとCKRecordZoneの基本的な知識が必要です。

00:10:19.000 --> 00:10:29.000
同期エンジンAPIは、レコードとゾーンの面で多くを扱うので、飛び込む前にそれらが何であるかを理解する必要があります。

00:10:29.000 --> 00:10:35.000
次に、XcodeでプロジェクトのCloudKit機能を有効にする必要があります。

00:10:35.000 --> 00:10:46.000
最後に、同期エンジンは最新の状態に保つためにプッシュ通知に依存しているため、リモート通知機能も有効にする必要があります。

00:10:46.000 --> 00:10:51.000
そのすべてを手に入れたら、同期エンジンを初期化する準備が整いました。

00:10:51.000 --> 00:10:56.000
アプリの起動後すぐにCKSyncEngineを初期化する必要があります。

00:10:56.000 --> 00:11:05.000
同期エンジンを初期化すると、バックグラウンドでプッシュ通知とスケジューラタスクのリスニングが自動的に開始されます。

00:11:05.000 --> 00:11:15.000
これらの通知とタスクはいつでも発生する可能性があり、それらを処理するために同期エンジンを初期化する必要があります。

00:11:15.000 --> 00:11:24.000
アプリとCKSyncEngineの間の主な通信手段は、CKSyncEngineDelegateと呼ばれるプロトコルです。

00:11:24.000 --> 00:11:31.000
同期エンジンを初期化するときは、このプロトコルに準拠したオブジェクトを提供する必要があります。

00:11:31.000 --> 00:11:38.000
適切かつ効率的に機能するために、同期エンジンはいくつかの内部状態を追跡します。

00:11:38.000 --> 00:11:44.000
また、同期エンジンの状態の最後の既知のバージョンも提供する必要があります。

00:11:44.000 --> 00:11:54.000
同期操作の実行中に、状態更新イベントの形でこの状態の更新バージョンをデリゲートに渡すことがあります。

00:11:54.000 --> 00:12:00.000
同期エンジンが新しい状態のシリアル化を提供するときはいつでも、それをローカルに保持する必要があります。

00:12:00.000 --> 00:12:08.000
このようにして、次回プロセスが起動し、同期エンジンを初期化するときに提供できます。

00:12:08.000 --> 00:12:14.000
これを理解するために、いくつかのコード例を使って説明します。

00:12:14.000 --> 00:12:20.000
同期エンジンを初期化するには、設定オブジェクトを渡します。

00:12:20.000 --> 00:12:29.000
設定では、同期するデータベース、同期エンジン状態の最後の既知のバージョン、およびデリゲートを提供する必要があります。

00:12:29.000 --> 00:12:35.000
デリゲートプロトコルの機能の1つは、ハンドルイベント関数です。

00:12:35.000 --> 00:12:42.000
この機能は、同期エンジンが通常の同期操作中に発生するさまざまなイベントについてアプリに通知する方法です。

00:12:42.000 --> 00:12:51.000
たとえば、サーバーから新しいデータを取得したとき、またはアカウントが変更されたときにイベントを投稿します。

00:12:51.000 --> 00:12:55.000
これらのイベントの1つは、状態更新イベントです。

00:12:55.000 --> 00:13:04.000
同期エンジンが内部状態を更新するとき、または自分で状態を更新すると、同期エンジンは状態更新イベントを投稿します。

00:13:04.000 --> 00:13:11.000
このイベントに対応して、この新しいシリアル化されたバージョンの状態をローカルに保持する必要があります。

00:13:11.000 --> 00:13:17.000
この例では、次回同期エンジンを初期化するときに、この状態のシリアル化を使用します。

00:13:17.000 --> 00:13:23.000
基礎が設定されたので、同期エンジンとの同期について説明します。

00:13:23.000 --> 00:13:28.000
サーバーに変更を送信できる簡単な手順がいくつかあります。

00:13:28.000 --> 00:13:36.000
まず、保留中のレコードゾーンの変更と保留中のデータベースの変更を同期エンジンの状態に追加します。

00:13:36.000 --> 00:13:41.000
これは、同期をスケジュールする必要があることを同期エンジンに警告します。

00:13:41.000 --> 00:13:48.000
同期エンジンは一貫性を確保し、これらの変更を重複排除します。

00:13:48.000 --> 00:13:54.000
次に、デリゲートメソッドnextRecordZoneChangeBatchを実装します。

00:13:54.000 --> 00:14:00.000
同期エンジンはこれを呼び出して、次のレコードゾーンの変更をサーバーに送信します。

00:14:00.000 --> 00:14:07.000
最後に、sonsDDatabaseChangesとsandRecordZoneChangesのイベントを処理します。

00:14:07.000 --> 00:14:13.000
これらのイベントは、変更がサーバーに送信されると投稿されます。

00:14:13.000 --> 00:14:17.000
以下は、サーバーに変更を送信する例です。

00:14:17.000 --> 00:14:22.000
このアプリケーションはデータを編集し、新しいレコードの変更を同期したいと考えています。

00:14:22.000 --> 00:14:31.000
これを行うには、同期エンジンの状態に保留中のレコードゾーンの変更を追加して、そのレコードを保存する必要があることを同期エンジンに伝えます。

00:14:31.000 --> 00:14:38.000
同期エンジンがレコードを同期する準備ができたら、デリゲートメソッドnextRecordZoneChangeBatchを呼び出します。

00:14:38.000 --> 00:14:44.000
ここでは、サーバーに送信する変更の次のバッチを返します。

00:14:44.000 --> 00:14:52.000
保留中の変更のリストとレコードプロバイダーを提供することで、RecordZoneChangeBatchを初期化します。

00:14:52.000 --> 00:15:03.000
保留中の変更のリストには、保存または削除するレコードIDと、実際の同期が発生したときにそれらのIDをレコードにマッピングするレコードプロバイダーが含まれています。

00:15:03.000 --> 00:15:07.000
アプリケーションがサーバーから変更を取得する方法は次のとおりです。

00:15:07.000 --> 00:15:13.000
同期エンジンは、サーバーから自動的に変更を取得します。

00:15:13.000 --> 00:15:21.000
その場合、イベント fetchedDatabaseChanges と fetchedRecordZoneChanges が投稿されます。

00:15:21.000 --> 00:15:29.000
ユースケースによっては、willFetchChangesとdidFetchChangesのイベントをリッスンしたい場合があります。

00:15:29.000 --> 00:15:39.000
たとえば、これらのイベントを渡すと、変更を取得する前または後にセットアップまたはクリーンアップタスクを実行する場合に便利です。

00:15:39.000 --> 00:15:44.000
これは、アプリがサーバーから変更を取得する例です。

00:15:44.000 --> 00:15:51.000
同期エンジンがレコードゾーン内で変更を取得すると、fetchedRecordZoneChangesイベントが投稿されます。

00:15:51.000 --> 00:15:58.000
このイベントには、別のデバイスによって実行された変更と削除が含まれています。

00:15:58.000 --> 00:16:04.000
これを聞くときは、フェッチされた変更とフェッチされた削除を確認する必要があります。

00:16:04.000 --> 00:16:09.000
変更を受け取ったら、データをローカルに保持する必要があります。

00:16:09.000 --> 00:16:15.000
削除を受け取ったら、ローカルでデータを削除する必要があります。

00:16:15.000 --> 00:16:21.000
データベースの変更の取得は非常に同様に機能し、同じアプローチで処理できます。

00:16:21.000 --> 00:16:24.000
エラーの処理は難しい場合があります。

00:16:24.000 --> 00:16:26.000
同期エンジンもこれに役立ちます。

00:16:26.000 --> 00:16:35.000
同期エンジンは、ネットワークの問題、スロットリング、アカウントの問題などの一時的なエラーを自動的に処理します。

00:16:35.000 --> 00:16:41.000
同期エンジンは、これらのエラーの影響を受ける作業を自動的に再試行します。

00:16:41.000 --> 00:16:45.000
他のエラーについては、アプリがそれらを処理する必要があります。

00:16:45.000 --> 00:16:51.000
これらのエラーを解決したら、必要に応じて作業のスケジュールを変更する必要があります。

00:16:51.000 --> 00:16:57.000
これは、レコードゾーンの変更を送信する際のエラーハンドリングの例です。

00:16:57.000 --> 00:17:06.000
sentRecordZoneChangesイベントが投稿されたら、failedRecordSavesをチェックして、保存に失敗したレコードがあるかどうかを確認する必要があります。

00:17:06.000 --> 00:17:10.000
serverRecordChangedは、レコードがサーバー上で変更されたことを示します。

00:17:10.000 --> 00:17:16.000
これは、別のデバイスがアプリケーションがまだ取得していない新しいバージョンを保存したことを意味します。

00:17:16.000 --> 00:17:21.000
競合を解決し、作業のスケジュールを変更する必要があります。

00:17:21.000 --> 00:17:26.000
zoneNotFoundは、ゾーンがサーバーにまだ存在しないことを示します。

00:17:26.000 --> 00:17:32.000
これを解決するには、ゾーンを作成し、作業のスケジュールを変更する必要があるかもしれません。

00:17:32.000 --> 00:17:38.000
同期エンジンは常に最初にゾーンを保存し、次に記録しようとします。

00:17:38.000 --> 00:17:49.000
networkFailure、networkUnavailable、serviceUnavailable、およびrequestRateLimitedは、同期エンジンが処理する一時的なエラーの例です。

00:17:49.000 --> 00:17:56.000
あなたはまだあなたの認識のためにこれらのエラーを受け取りますが、それらに応じて行動を起こす必要はありません。

00:17:56.000 --> 00:18:03.000
システム条件が許せば、同期エンジンは自動的にこれらのエラーを再試行します。

00:18:03.000 --> 00:18:07.000
同期エンジンが役立つもう1つのことは、アカウントの変更です。

00:18:07.000 --> 00:18:11.000
iCloudアカウントの変更は、デバイス上でいつでも発生する可能性があります。

00:18:11.000 --> 00:18:16.000
同期エンジンは、これらを管理し、反応するのに役立ちます。

00:18:16.000 --> 00:18:28.000
同期エンジンは変更をリッスンし、accountChangeイベントを使用して、サインイン、サインアウト、またはアカウントが切り替えられたことを示します。

00:18:28.000 --> 00:18:34.000
申請書は、タイプに応じて変更に備える必要があります。

00:18:34.000 --> 00:18:42.000
デバイスにアカウントが存在するまで、同期エンジンはiCloudとの同期を開始しません。

00:18:42.000 --> 00:18:49.000
同期エンジンはいつでも初期化でき、アカウントの変更があると自動的に更新されます。

00:18:49.000 --> 00:18:54.000
他のユーザーとデータを共有することは、CloudKitの重要な部分です。

00:18:54.000 --> 00:18:58.000
同期エンジンはここでも生活を楽にします。

00:18:58.000 --> 00:19:03.000
同期エンジンはCloudKit共有データベースで動作します。

00:19:03.000 --> 00:19:08.000
アプリケーションが動作するデータベースごとに同期エンジンを作成するだけです。

00:19:08.000 --> 00:19:16.000
たとえば、プライベートデータベースの同期エンジンと、共有データベースの別の同期エンジンを作成できます。

00:19:16.000 --> 00:19:24.000
CloudKitとの共有の詳細については、「CloudKit共有を最大限に活用する」テックトークをチェックしてください。

00:19:24.000 --> 00:19:27.000
それはCKSyncEngineの使用をカバーしています。

00:19:27.000 --> 00:19:32.000
今、私はそれを使用するときにテストする方法について説明します。

00:19:32.000 --> 00:19:38.000
自動テストは、急速に発展しながらコードベースの安定性を確保するための最良の方法です。

00:19:38.000 --> 00:19:48.000
同期エンジンを使用すると、複数のCKSyncEngineインスタンスを使用してデバイス間ユーザーフローをシミュレートできます。

00:19:48.000 --> 00:19:52.000
アプリが遭遇する可能性のあるエッジケースをシミュレートする必要があります。

00:19:52.000 --> 00:20:00.000
これを行うには、automaticSyncをfalseに設定することで、同期エンジンフローに介入できます。

00:20:00.000 --> 00:20:07.000
これは、2つのデバイスとサーバー間のデータ競合をシミュレートするテストケースです。

00:20:07.000 --> 00:20:13.000
このテストの目的は、複数のデバイスで作業するときにユーザーが取るフルフローをシミュレートすることです。

00:20:13.000 --> 00:20:18.000
また、紛争解決を検証します。

00:20:18.000 --> 00:20:24.000
まず、MySyncManagerを使用して2つのデバイスをシミュレートします。

00:20:24.000 --> 00:20:30.000
この例では、MySyncManagerはローカルデータベースと同期エンジンを作成します。

00:20:30.000 --> 00:20:37.000
デバイスAは値をAに設定し、その変更をサーバーに送信します。

00:20:37.000 --> 00:20:44.000
デバイスBがサーバーから変更を取得する前に、その変更もサーバーに送信するように依頼します。

00:20:44.000 --> 00:20:51.000
デバイスAが最初にサーバーに保存されたため、デバイスBの保存は失敗すると予想されます。

00:20:51.000 --> 00:20:59.000
これにより、サーバーレコードの変更エラーが発生し、ローカル競合解決コードが実行されます。

00:20:59.000 --> 00:21:11.000
このサンプルは、競合解決がサーバーからのデータを好むことを期待しているため、デバイスBの新しい値は、デバイスAからサーバーに最近送信された値になります。

00:21:11.000 --> 00:21:17.000
テストとデバッグをスピードアップするのに役立つ重要なポイントをいくつか紹介します。

00:21:17.000 --> 00:21:25.000
各デバイス上の一連のイベントを理解することは、フローのどこにアプリケーションに問題がある可能性があるかを特定するのに役立ちます。

00:21:25.000 --> 00:21:34.000
開発時に可能な限りロギングすることは、これらのフローを追跡し、複数のデバイス間でログを比較するのに役立ちます。

00:21:34.000 --> 00:21:43.000
CloudKitは受信した各イベントをログに記録しますが、それらを取り巻くアクションもアプリケーションに記録する必要があります。

00:21:43.000 --> 00:21:55.000
レコードIDとゾーンIDのロギングは、同期エンジン、サーバー、および同期している可能性のある他のデバイス間で流れているデータをデバッグするのに役立ちます。

00:21:55.000 --> 00:22:03.000
各ユーザーフローをシミュレートするテストを書くことは、コードベースを成長させるにつれて安定性を維持するのに役立ちます。

00:22:03.000 --> 00:22:07.000
パズルをつなぎ合わせるときは、タイムスタンプを見てください。

00:22:07.000 --> 00:22:13.000
同期操作は数回しか行われていないか、短時間で多くの同期操作が行われる可能性があります。

00:22:13.000 --> 00:22:19.000
正しいものをトレースしていることを確認することは、複数のデバイス間でデバッグするための鍵です。

00:22:19.000 --> 00:22:28.000
これらのステップは、CKSyncEngineを使用して信頼性が高く、長持ちするアプリケーションを作成し、維持するのに役立ちます。

00:22:28.000 --> 00:22:31.000
これで、CKSyncEngineに関する講演は終了です。

00:22:31.000 --> 00:22:36.000
同期エンジンのサンプルコードを見て、アプリの完全な作業例を確認してください。

00:22:36.000 --> 00:22:41.000
より深く掘り下げるには、CKSyncEngineのドキュメントをご覧ください。

00:22:41.000 --> 00:22:47.000
同期エンジンを改善するための提案がある場合は、CloudKitチームにフィードバックを提出してください。

00:22:47.000 --> 00:22:51.000
私たちはあなたがそれで作るものを見ることに興奮しています。

00:22:51.000 --> 00:22:55.000
見てくれてありがとう。素晴らしいWWDCを！

00:22:55.000 --> 23:59:59.000
♪ ♪

