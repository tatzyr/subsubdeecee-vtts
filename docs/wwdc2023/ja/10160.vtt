WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:14.000
人物：こんにちは、「Demystify SwiftUI Performance」へようこそ。

00:00:14.000 --> 00:00:22.000
SwiftUIを使用すると、複雑で強力なアプリを簡単に構築でき、リストやテーブルなどの多数の機能と複雑なコントロールを提供します。

00:00:22.000 --> 00:00:28.000
始めたばかりで、アプリがあまり複雑ではない場合、パフォーマンスの問題はそれほど明白ではありません。

00:00:28.000 --> 00:00:32.000
しかし、アプリの複雑さが増すにつれて、パフォーマンスがより重要になります。

00:00:32.000 --> 00:00:39.000
小さな問題は増幅される可能性があり、プロトタイプでうまく機能するコードは本番ではうまく機能しないかもしれません。

00:00:39.000 --> 00:00:52.000
このセッションは、SwiftUIでのパフォーマンスのためのメンタルモデルを構築することです。なぜなら、開発プロセスの最初から高速コードを書く方法を理解していれば、アプリがより複雑になるにつれて問題が少なくなるからです。

00:00:52.000 --> 00:00:56.000
パフォーマンスの問題に対処するためのフィードバックループを調べてみましょう。

00:00:56.000 --> 00:00:58.000
パフォーマンスの問題は症状から始まります。

00:00:58.000 --> 00:01:05.000
おそらく、遅いナビゲーションプッシュ、壊れたアニメーション、またはmacOSで回転する待機カーソルが表示されている可能性があります。

00:01:05.000 --> 00:01:11.000
パフォーマンスの問題を特定するとき、それに対処するための最初のステップは測定することです。

00:01:11.000 --> 00:01:16.000
症状が存在することを測定および確認したら、その原因の特定に取り組みます。

00:01:16.000 --> 00:01:24.000
これは、物事がどのように機能するかについての直感を必要とするため、このループのトリッキーな段階の1つになることがよくあります。

00:01:24.000 --> 00:01:27.000
アプリが誤った仮定をしていると、バグが発生します。

00:01:27.000 --> 00:01:33.000
このセッションでは、アプリの仮定と現実の不一致を特定するのに役立ちます。

00:01:33.000 --> 00:01:37.000
根本原因を特定した後、最適化を通じて問題を解決します。

00:01:37.000 --> 00:01:42.000
しかし、パフォーマンスの問題は、根本原因を見つけてコードを最適化した後に終わらない。

00:01:42.000 --> 00:01:48.000
問題が解決していることを確認するために、修正を再測定し、再確認する必要があります。

00:01:48.000 --> 00:01:53.000
これはすべてのバグにとって良い習慣ですが、パフォーマンスにとって特に重要です。

00:01:53.000 --> 00:01:57.000
問題が解決したことを確認したら、ループを壊します。

00:01:57.000 --> 00:02:00.000
この図は、このセッションを文脈に置きます。

00:02:00.000 --> 00:02:06.000
理想的には、このサイクルで終わることはなく、プロトタイピング時に高速なコードを書くことで、多くのパフォーマンスの問題を回避できます。

00:02:06.000 --> 00:02:12.000
しかし、アプリがより複雑になるにつれて、パフォーマンスのバグになってしまうことは避けられません。

00:02:12.000 --> 00:02:14.000
それは私たちの最高に起こります。

00:02:14.000 --> 00:02:20.000
そして、パフォーマンスの問題に遭遇した場合、それらをトリアージして修正するために、できるだけ多くのツールを自由に使うのは良いことです。

00:02:20.000 --> 00:02:24.000
このセッションは、ループを簡単に通過することを目的としています。

00:02:24.000 --> 00:02:28.000
これは高度なセッションであり、いくつかの前提条件があります。

00:02:28.000 --> 00:02:35.000
暗黙のアイデンティティと明示的なアイデンティティの違いを含め、SwiftUIのアイデンティティを大まかに理解する必要があります。

00:02:35.000 --> 00:02:41.000
また、ビューの有効期間とビューのアイデンティティの区別を知ることも重要です。

00:02:41.000 --> 00:02:43.000
これらの前提条件がない場合は、心配しないでください。 心配しないでください。

00:02:43.000 --> 00:02:49.000
WWDC21の「Demystify SwiftUI」セッションをカバーしました。

00:02:49.000 --> 00:02:53.000
今日のセッションは、そのセッションが中断したところから再開します。

00:02:53.000 --> 00:02:55.000
議題を確認しましょう。

00:02:55.000 --> 00:03:00.000
依存関係の詳細な議論から始め、SwiftUIの更新プロセスを詳細に検討します。

00:03:00.000 --> 00:03:06.000
次に、アップデートの議論と、SwiftUIがインターフェイスを更新する速度を向上させる方法に進みます。

00:03:06.000 --> 00:03:11.000
最後になりましたが、リストと表でアイデンティティについて話し合います。

00:03:11.000 --> 00:03:17.000
その過程で、SwiftUIのボンネットの下を覗いて、開発時に使ういくつかのヒントやコツをチェックします。

00:03:17.000 --> 00:03:26.000
このセッションは、主にビュー階層の遅い更新に関係していますが、アプリを開発する際に発生する可能性のあるすべてのパフォーマンスの問題を徹底的に調べることではありません。

00:03:26.000 --> 00:03:29.000
依存関係から始めましょう。

00:03:29.000 --> 00:03:35.000
前回の「Demystify SwiftUI」セッションから数年が経ちましたが、犬をテーマにしたアプリに取り組むのを逃しました。

00:03:35.000 --> 00:03:43.000
だから、そのセッションのテーマを継続して、私はお気に入りの毛皮のような友人を追跡し、彼らと遊ぶ時間を設定できる新しいアプリに取り組んできました。

00:03:43.000 --> 00:03:46.000
これは景色の1つで、すべての犬を示すテーブルです。

00:03:46.000 --> 00:03:57.000
このアプリには、iPhoneでここに表示されている詳細ビューもあり、各犬の全体像、犬の好みを表示し、プレイする時間を設定するためのボタンを提供します。

00:03:57.000 --> 00:03:59.000
これが同じビューのコードです。

00:03:59.000 --> 00:04:05.000
ビューはパラメータとして犬を取り込み、それがプレイ時間であるかどうかを知るための環境プロパティも持っています。

00:04:05.000 --> 00:04:14.000
前回のDemystifyセッションで述べたように、これは犬とプレイ時間変数がビューの依存関係であることを意味し、このビューを表示する別の方法はグラフです。

00:04:14.000 --> 00:04:18.000
これは、ほぼ同じビューを表す基本的なグラフです。

00:04:18.000 --> 00:04:21.000
各矢印はビューの本体を表します。

00:04:21.000 --> 00:04:23.000
ドッグビューはスタックを生成します。

00:04:23.000 --> 00:04:30.000
そして、スタックには、いくつかのテキスト、スケーラブルな犬の画像、詳細ビュー、ボタンなど、複数の子があります。

00:04:30.000 --> 00:04:38.000
続けると、これらのビューのそれぞれに子があり、グラフは画像、テキスト、色などのリーフビューに達するまで続きます。

00:04:38.000 --> 00:04:41.000
すべてのビューは最終的にリーフビューに解決されます。

00:04:41.000 --> 00:04:45.000
SwiftUIには多くのリーフビューがあるので、ここではそれらすべてをカバーするわけではありません。

00:04:45.000 --> 00:04:49.000
詳細については、ドキュメントを確認してください。

00:04:49.000 --> 00:04:51.000
アプリに戻りましょう。

00:04:51.000 --> 00:04:55.000
アプリを使っているときはいつでも、友達と遊ぶときはいつでもログインできます。

00:04:55.000 --> 00:05:01.000
私はここでロッキーとフェッチをプレイし終えたばかりなので、ボタンと画像を更新するアプリでそれをメモしました。

00:05:01.000 --> 00:05:05.000
ロッキーはかなり幸せそうに見えますが、彼は間違いなく疲れすぎて今は遊べません。

00:05:05.000 --> 00:05:09.000
このデータがモデルで変更されると、SwiftUIはこのビューを更新します。

00:05:09.000 --> 00:05:16.000
グラフに戻り、この変更が発生したときに何が起こるかを見て、更新プロセスを詳しく見てみましょう。

00:05:16.000 --> 00:05:17.000
これがまた私たちのグラフです。

00:05:17.000 --> 00:05:24.000
これは、以前のDemystifyセッションが中断した場所であり、ビューがグラフを形成し、SwiftUIがコードを評価する際に依存関係を調べることを説明します。

00:05:24.000 --> 00:05:32.000
ズームインして、これらの依存関係がどこから来て、どのように制御できるかをより詳しく見てみましょう。

00:05:32.000 --> 00:05:37.000
各子ビューは、その祖先によって生成されるビュー値に依存します。

00:05:37.000 --> 00:05:39.000
しかし、他の形態の依存関係もあります。

00:05:39.000 --> 00:05:42.000
動的プロパティは、依存関係の一般的なソースでもあります。

00:05:42.000 --> 00:05:48.000
たとえば、DogViewは、@Environmentプロパティラッパーを使用して、環境からの再生時間かどうかを読み取ります。

00:05:48.000 --> 00:05:55.000
したがって、それは親によって生成された値と環境からの値の両方に依存します。

00:05:55.000 --> 00:06:02.000
X軸で時間を視覚化する場合、更新プロセスの最初のステップは、ビューの新しい値を生成することです。

00:06:02.000 --> 00:06:09.000
この値は、dog 値や動的プロパティの初期値など、ビューのすべての保存されたプロパティを網羅します。

00:06:09.000 --> 00:06:16.000
次に、SwiftUIはビューのすべての動的プロパティを更新し、その値をグラフの現在の値に置き換えます。

00:06:16.000 --> 00:06:21.000
最後に、更新された値で、ボディはビューの子を生成するために実行されます。

00:06:21.000 --> 00:06:23.000
グラフをもう一度持ち込んでみましょう。

00:06:23.000 --> 00:06:30.000
このプロセスは、インターフェイスを更新するために再帰し、新しい値またはその他の変更された依存関係を持つビューのみを更新します。

00:06:30.000 --> 00:06:38.000
ロッキーを疲れたとしてマークすると、私たちは新しい犬を手に入れます-申し訳ありませんが、新しい犬の構造値ですが、それはまだ同じロッキーです。

00:06:38.000 --> 00:06:43.000
私たちのデータは値型であるため、変異すると新しいコピーが作成されます。

00:06:43.000 --> 00:06:49.000
その結果、DogViewはスタックの新しいコンテンツを生成し、スタックの子を更新します。

00:06:49.000 --> 00:06:55.000
ここではScalableDogImageのみに焦点を当てていますが、犬の値に依存する場合、他のビューが更新される可能性があります。

00:06:55.000 --> 00:06:59.000
ScalableDogImageは、最終的に新しい画像を生成します。

00:06:59.000 --> 00:07:04.000
画像はリーフビューなので、残りの作業はここからSwiftUIによって行われます。

00:07:04.000 --> 00:07:08.000
その後、プロセスが終了し、新しいレンダリングが生成されます。

00:07:08.000 --> 00:07:11.000
それが依存関係グラフの見方です。

00:07:11.000 --> 00:07:13.000
このプロセスを改善するためのヒントをいくつか見てみましょう。

00:07:13.000 --> 00:07:17.000
更新を必要なものだけに減らすことが重要です。

00:07:17.000 --> 00:07:22.000
ビューがいつ更新されるかを理解するために、SwiftUIにはprintChangesメソッドがあります。

00:07:22.000 --> 00:07:27.000
これにより、SwiftUIグラフ評価者がビューの本文に呼び出された理由を印刷できます。

00:07:27.000 --> 00:07:30.000
使い方の例を見ていきましょう。 

00:07:30.000 --> 00:07:34.000
ここには、状態の一部を含むスケーラブルな犬の画像があります。

00:07:34.000 --> 00:07:41.000
画像をタップすると、状態がこのように変化します。

00:07:41.000 --> 00:07:53.000
画像ビューのみに焦点を当て、LLDBコンソールからビューの本体にブレークポイントを設定すると、「式」LLDBコマンドを使用してSelf._printChangesを呼び出すことができます。

00:07:53.000 --> 00:08:00.000
printChangesは、SwiftUIがビューの本文を要求した理由を最善を尽くして説明するデバッグのみの機能です。

00:08:00.000 --> 00:08:03.000
この場合、scaleToFillが変更されたためです。

00:08:03.000 --> 00:08:08.000
printChangesを使用して、ビューに余分な依存関係があるかどうかを理解できます。

00:08:08.000 --> 00:08:13.000
たとえば、現在アプリとデバッグを実行しており、このビューに余分な依存関係があるかどうかを確認したいと考えています。

00:08:13.000 --> 00:08:19.000
このビューの本文にprintChangesへの呼び出しを追加して、ビューの本文にアクセスするたびに印刷できます。

00:08:19.000 --> 00:08:23.000
ただし、printChangesにはアンダースコアが先頭に付きます。

00:08:23.000 --> 00:08:33.000
この場合、つまり、常に存在することは保証されることはなく、将来のリリースで削除される可能性があるため、このメソッドへの呼び出しをアプリストアに送信しないでください。

00:08:33.000 --> 00:08:35.000
後でこの電話を削除する必要があります。

00:08:35.000 --> 00:08:38.000
これはデバッグのみを目的としており、ランタイムのパフォーマンスに影響します。

00:08:38.000 --> 00:08:48.000
アプリを再実行し、ロッキーのお気に入りのおやつ、例えばビスケットからキュウリのような他のものに変更すると、私たちの画像からコンソールのログに気づきます。

00:08:48.000 --> 00:08:49.000
「自己」が変わったと書かれています。

00:08:49.000 --> 00:08:58.000
これは、ビュー値が変更されたことを意味するため、スケーラブルな画像ビューは治療にある程度依存する必要がありますが、実際にはする必要はありません。

00:08:58.000 --> 00:09:03.000
コードに焦点を当てると、ビューの値にはscaleToFillメンバーとdogプロパティしかありません。

00:09:03.000 --> 00:09:12.000
scaleToFillはSwiftUIの動的プロパティであるため、変更された場合は変更ログに表示されていたため、ここでの「@Self」は犬の値が変更されたことを意味します。

00:09:12.000 --> 00:09:15.000
しかし、このビューを見ると、私たちはイメージだけを気にします。

00:09:15.000 --> 00:09:19.000
したがって、代わりに画像のみを使用することで、この依存関係を排除することができます。

00:09:19.000 --> 00:09:27.000
そして今、画像に関係のない犬のプロパティを変更すると、ログが表示されません。

00:09:27.000 --> 00:09:29.000
ビューの依存関係は厳密にスコープされています。

00:09:29.000 --> 00:09:34.000
このテクニックに従う場合は、printChangesの呼び出しを削除することを忘れないでください。

00:09:34.000 --> 00:09:36.000
一致するように親ビューを更新しましょう。

00:09:36.000 --> 00:09:38.000
これが親犬のビューのコードです。

00:09:38.000 --> 00:09:44.000
画像を取り込むために、ScalableDogImageの初期化子を更新する必要があります。

00:09:44.000 --> 00:09:49.000
ScalableDogImageを抽出することで、依存関係を重要なものだけに減らしました。

00:09:49.000 --> 00:09:53.000
ヘッダーでも同じことを行い、独自のビューに抽出できます。

00:09:53.000 --> 00:09:55.000
これには多くの利点があります。

00:09:55.000 --> 00:10:01.000
このコードは読みやすくなり、DogHeaderの依存関係は使用サイトで明らかです。

00:10:01.000 --> 00:10:05.000
このテクニックは小さなビューに最適ですが、非常に大きな構造体には注意してください。

00:10:05.000 --> 00:10:08.000
すべての依存関係がこのようにスコープされるに値するわけではありません。

00:10:08.000 --> 00:10:11.000
最善の判断を下す必要があります。

00:10:11.000 --> 00:10:15.000
アップデートが少ないと、アプリのデータが変更されたときのパフォーマンスが向上します。

00:10:15.000 --> 00:10:19.000
先ほど検討したように、これを行う1つの方法は、依存関係を減らすことです。

00:10:19.000 --> 00:10:24.000
ビューの値を、実際に依存しているデータのみに減らしてみてください。

00:10:24.000 --> 00:10:28.000
もう1つのヒントは、依存関係を減らすためにビューを抽出することです。

00:10:28.000 --> 00:10:36.000
そして最後に、新しいObservableプロトコルは、依存関係を読み取りのみに自動的に制限することで、依存関係のスコーピングにも役立ちます。

00:10:36.000 --> 00:10:41.000
詳細については、「SwiftUIで観察を発見する」セッションをチェックしてください。

00:10:41.000 --> 00:10:44.000
それは、依存関係を見る方法の簡単なツアーでした。

00:10:44.000 --> 00:10:46.000
より迅速な更新について話しましょう。

00:10:46.000 --> 00:10:51.000
このセクションでは、各SwiftUIアップデートのコストを削減する方法について説明します。

00:10:51.000 --> 00:10:58.000
SwiftUIの更新が遅いと、ハングやヒッチなどの応答性の低下など、アプリに多くの悪影響を及ぼす可能性があります。

00:10:58.000 --> 00:11:04.000
ハングは、最初に表示されるのに長い時間がかかるビューのように、ユーザーインタラクションへの応答の遅延です。

00:11:04.000 --> 00:11:17.000
WWDC2023の「Instrumentsのハングを分析する」セッションでは、SwiftUI関連の作業によってハングが原因である可能性があるかどうかを特定する方法など、Instrumentsを使用してハングを分析する方法について詳しく説明します。

00:11:17.000 --> 00:11:24.000
ヒッチは、スクロール中の一時停止やアニメーションのフレームのスキップなど、ユーザーが知覚できるアニメーションの問題です。

00:11:24.000 --> 00:11:29.000
特にSwiftUIでは、ハングやヒッチの根本原因はしばしば関連しています。

00:11:29.000 --> 00:11:38.000
システムレンダリングループの仕組みなど、ヒッチの詳細については、「UIアニメーションヒッチとレンダリングループを探索する」テックトークビデオをご覧ください。

00:11:38.000 --> 00:11:42.000
SwiftUIの両方のハングとヒッチは、多くの場合、遅いアップデートに起因します。

00:11:42.000 --> 00:11:45.000
これらの遅い更新には、いくつかの一般的な原因があります。

00:11:45.000 --> 00:11:52.000
1つ目は、状態オブジェクトの割り当てと初期化、状態の初期化など、高価な動的プロパティのインスタンス化です。

00:11:52.000 --> 00:11:54.000
もう一つの情報源は、体で行われた仕事です。

00:11:54.000 --> 00:12:00.000
高価な文字列補間や、データフィルタリングなどの操作や体内内のその他の作業を必ず確認してください。

00:12:00.000 --> 00:12:04.000
体自体ができるだけ安いことが重要です。

00:12:04.000 --> 00:12:06.000
これらはすべて相互に関連しています。

00:12:06.000 --> 00:12:12.000
たとえば、動的プロパティはビューの本体から計算できるため、ビューは評価に費用がかかります。

00:12:12.000 --> 00:12:16.000
遅い識別は、ビューの体内でも頻繁に発生します。

00:12:16.000 --> 00:12:20.000
フェッチアプリの例を見ることから始めましょう。

00:12:20.000 --> 00:12:26.000
この例では、犬のリストを作成するために使用するオブジェクトを持つアプリのルートビューに取り組んできました。

00:12:26.000 --> 00:12:36.000
このスライドのコードハイライトに続いて、ボディ内のmodel.dogsにアクセスすると、オブジェクトが遅延してインスタンス化し、犬のリストを取得する初期化子が表示されます。

00:12:36.000 --> 00:12:40.000
コードコメントが言うように、これには長い時間がかかる可能性があります。

00:12:40.000 --> 00:12:43.000
これは同期作業です。

00:12:43.000 --> 00:12:46.000
これを修正する1つの方法は、タスク修飾子を使用することです。

00:12:46.000 --> 00:12:49.000
まず、フェッチを非同期にします。

00:12:49.000 --> 00:12:52.000
ここでは、非同期キーワードの追加を表示しているだけです。

00:12:52.000 --> 00:12:58.000
次に、タスク修飾子で、ドッグリストを待機して非同期に取得します。

00:12:58.000 --> 00:13:02.000
そうすれば、高価なデータ読み込み操作が発生したとき、アプリは応答します。

00:13:02.000 --> 00:13:06.000
あなたのアプリに影響を与えていることに気づいていないかもしれない他の仕事のソースがあります。

00:13:06.000 --> 00:13:13.000
たとえば、文字列の補間はしばしば高価になる可能性があるため、頻繁に使用する必要がある可能性のある文字列をキャッシュするようにしてください。

00:13:13.000 --> 00:13:17.000
同様に、バンドルから値を調べることは高価になる可能性があります。

00:13:17.000 --> 00:13:22.000
そしてもちろん、クラスに縛られたタイプなど、ヒープの割り当ては加算できます。

00:13:22.000 --> 00:13:24.000
リストとテーブルに移りましょう。

00:13:24.000 --> 00:13:32.000
リストとテーブルは、シンプルなレイアウト、選択の追加、スワイプアクション、並べ替えのサポートなどを超えた豊富な機能をサポートしています。

00:13:32.000 --> 00:13:39.000
これらは複雑で高度なコントロールであり、アイデンティティを理解することは、アプリでうまく機能するために不可欠です。

00:13:39.000 --> 00:13:47.000
このセクションでは、リストと表のアイデンティティについて議論し、これらの組み込みコンポーネントの更新パフォーマンスを最大化する方法をわかりやすく説明します。

00:13:47.000 --> 00:13:51.000
このテーマに飛び込む前に、いくつかの改善点に触れたいと思います。

00:13:51.000 --> 00:13:59.000
macOS SonomaとiOS 17では、SwiftUIには、フィルタリングやスクロールなどのケースのために、多くの最適化があります。

00:13:59.000 --> 00:14:08.000
これらの改善は、あなたの側で最小限の労力で可能であり、多くの場合、より大きなリストやテーブルの負荷と更新時間が大幅に向上する可能性があります。

00:14:08.000 --> 00:14:14.000
ただし、パフォーマンスを向上させるリストとテーブルを構築するには、特定の方法があります。

00:14:14.000 --> 00:14:18.000
リストとテーブルは識別子を使用して、データにどのような変更が発生したかを知る。

00:14:18.000 --> 00:14:22.000
一貫性を保つために、リストとテーブルのすべてのIDが熱心に収集されます。

00:14:22.000 --> 00:14:30.000
したがって、リストとテーブルの内容の識別子をすばやく生成できるため、読み込みと更新時間が短縮されます。

00:14:30.000 --> 00:14:37.000
アイデンティティは、SwiftUIがビューの寿命を管理するのに役立ちます。これは、階層の増分更新に不可欠です。

00:14:37.000 --> 00:14:40.000
アイデンティティの変更は、ビューが変更されたことを意味します。

00:14:40.000 --> 00:14:43.000
これはアニメーションとパフォーマンスにとって重要です。

00:14:43.000 --> 00:14:48.000
アニメーションの詳細については、「SwiftUIアニメーションの基礎」セッションをご覧ください。

00:14:48.000 --> 00:14:54.000
特にリストやテーブルの場合、識別子が頻繁に収集されるため、識別性能は重要です。

00:14:54.000 --> 00:14:58.000
リスト識別モデルを見てみましょう。

00:14:58.000 --> 00:15:00.000
私はアプリの犬のリストで一生懸命取り組んできました。

00:15:00.000 --> 00:15:03.000
私はたった1列から始めました。

00:15:03.000 --> 00:15:07.000
これがリストのコードで、中にDogCellが1つ入っています。

00:15:07.000 --> 00:15:11.000
次のステップは、ForEachを使用してすべての犬を反復することです。

00:15:11.000 --> 00:15:18.000
この例は簡単ですが、アイデンティティに直接関係しており、リストにForEachを追加することはパフォーマンスを評価する重要な時期です。

00:15:18.000 --> 00:15:23.000
その理由を理解するために、次にForEachの一般的な署名を見てみましょう。

00:15:23.000 --> 00:15:26.000
これはSwiftUIのForEachの署名です。

00:15:26.000 --> 00:15:34.000
ForEachは、データのコレクションを結果のビューのシーケンスにマッピングし、各ビューの明示的なアイデンティティを生成します。

00:15:34.000 --> 00:15:40.000
Listを使用する場合は、表示する行の数と、各行の識別子を把握する必要があります。

00:15:40.000 --> 00:15:46.000
したがって、事前にデータ収集を訪問し、各要素のIDを決定します。

00:15:46.000 --> 00:15:49.000
コンテンツクロージャは、各ビューを生成するために呼び出されます。

00:15:49.000 --> 00:15:51.000
行はオンデマンドで作成されます。

00:15:51.000 --> 00:15:56.000
リストは、アイデンティティとコンテンツの合成を使用してリスト行を生成します。

00:15:56.000 --> 00:16:04.000
オンデマンドで作成された行は、可視領域と相関し、プリフェッチまたはアクセシビリティのためのいくつかのシステム決定バッファと相関します。

00:16:04.000 --> 00:16:07.000
ビューがスクロールされると、より多くのビューが現存します。

00:16:07.000 --> 00:16:11.000
これがこのForEachを生成するコードスニペットです。

00:16:11.000 --> 00:16:18.000
ここでは、内部にHStackを使用しているため、コンテンツは単なるDogCellであり、それ自体が単一のビューであることに注意してください。

00:16:18.000 --> 00:16:22.000
ForEachは、リストで使用される究極の行IDを決定する上で非常に重要です。

00:16:22.000 --> 00:16:25.000
そして、リストはすべてのIDを事前に知る必要があります。

00:16:25.000 --> 00:16:33.000
しかし、コンテンツが一定の行数に解決した場合にのみ、すべてのコンテンツにアクセスしずに効率的にこれを行うことができます。

00:16:33.000 --> 00:16:39.000
例として、ボールを取りたい犬だけを表示するようにリストをリファクタリングしたいとしましょう。

00:16:39.000 --> 00:16:43.000
このような条件付きビューを使用してフィルターを追加するのは魅力的かもしれません。

00:16:43.000 --> 00:16:48.000
ここでは、ビューの数は可変です。1かゼロのどちらかです。

00:16:48.000 --> 00:16:57.000
これは、各要素がいくつのビューに解決されるかわからないため、行識別子を取得するためにすべてのビューを構築する必要があるため、悪いです。

00:16:57.000 --> 00:17:00.000
AnyViewを使用する場合も同様です。

00:17:00.000 --> 00:17:03.000
ここでは、ビュー数は現在完全に不明です。

00:17:03.000 --> 00:17:08.000
したがって、以前と同じ問題があります。すべての行を作成する必要があります。

00:17:08.000 --> 00:17:11.000
フィルターをデータ収集自体に移動したらどうなりますか?

00:17:11.000 --> 00:17:22.000
これで、要素ごとの一定数のビューに戻り、必要なビューのみが行の内容を構築していますが、注意してください。ここのインラインフィルタは、コレクションの上に線形です。

00:17:22.000 --> 00:17:30.000
これはプロトタイプで機能するかもしれませんが、コレクションがスケールすると、この操作はすぐに高価になり、更新が遅くなる可能性があります。

00:17:30.000 --> 00:17:32.000
モデルに移動した方が良いです。 

00:17:32.000 --> 00:17:42.000
今、私たちは両方の長所を持っています。フィルターはキャッシュされているため、このリストが構築されるたびに実行されず、要素ごとのビュー数は一定です。

00:17:42.000 --> 00:17:46.000
ビュー数が一定であることを確認するためのヒントをいくつか紹介します。

00:17:46.000 --> 00:17:55.000
カウントを表示するこのアプローチは、これらのコンポーネントが事前に識別子を収集するため、リストとテーブル内のForEachのコンテキストでのみ関連していることに注意してください。

00:17:55.000 --> 00:17:59.000
先ほど述べたように、AnyViewと偏った条件の使用は避けてください。

00:17:59.000 --> 00:18:08.000
必要に応じて明示的なスタックを使用することもできますが、listRowBackgroundのような特定の修飾子は、スタック内ではなくスタックの後に行く必要があることに注意してください。

00:18:08.000 --> 00:18:12.000
最後に、可能であれば、ネストされたForEach構造を平らにしてみてください。

00:18:12.000 --> 00:18:17.000
ただし、ネストされたForEachが貴重なセクションリストになる場所が1つあります。

00:18:17.000 --> 00:18:20.000
例を見てみましょう。 例を見てみましょう。

00:18:20.000 --> 00:18:25.000
この例では、各犬のお気に入りのおもちゃで区切られた犬のリストがあります。

00:18:25.000 --> 00:18:28.000
ForEachを使用して、動的な数のセクションを作成しています。

00:18:28.000 --> 00:18:33.000
そして、各セクションには、ForEachをネストすることで、その中に動的な数の行があります。

00:18:33.000 --> 00:18:43.000
リストはすべての識別子を取得する必要がありますが、ここではセクションを使用しているため、SwiftUIはこの構成を理解し、リストがまだレンダリングが速いことを保証します。

00:18:43.000 --> 00:18:48.000
動的セクションは、ネストされたForEachを使用する場合の良い例です。

00:18:48.000 --> 00:18:58.000
考えるべき基本的な方程式は、リスト内のForEachから生じる行数は、各要素に対して生成されたビューの数を乗じた要素の数に等しいということです。

00:18:58.000 --> 00:19:08.000
要素ごとのビュー数が定数であることを確認する必要があります。または、SwiftUIは行を識別するために識別子に加えてビューを構築する必要があります。

00:19:08.000 --> 00:19:12.000
これまでのところ、リストについて話しましたが、これらのルールは一般的にテーブルにも適用されます。

00:19:12.000 --> 00:19:18.000
Tableはビューの代わりにTableRowを使用し、TableRowは常に単一の行に解決されます。

00:19:18.000 --> 00:19:20.000
表の例を見てみましょう。 

00:19:20.000 --> 00:19:24.000
ここには、中にForEachがある犬のテーブルがあります。

00:19:24.000 --> 00:19:32.000
TableRowは常に1行であるため、ここでの合計行数は、犬コレクションの要素の数にすぎません。

00:19:32.000 --> 00:19:45.000
この構造は非常に一般的であるため、iOS 17とmacOS Sonomaで新しく、SwiftUIは、単にあなたのデータ収集のForEachを作成し、あなたに代わってテーブル行を作成できる合理化された初期化子を提供します。

00:19:45.000 --> 00:19:52.000
この初期化子は新しいですが、テーブルが利用可能な以前のすべてのオペレーティングシステムバージョンに再展開されます。

00:19:52.000 --> 00:20:00.000
この構造はシンプルであるだけでなく、ForEachコンテンツに一定数の行を強制し、識別パフォーマンスに役立ちます。

00:20:00.000 --> 00:20:04.000
しかし、私が呼び出したい意味的な変化があり、それは新しいものです。

00:20:04.000 --> 00:20:09.000
このようなコードがある場合、最新のOSバージョンでは動作が異なる場合があります。

00:20:09.000 --> 00:20:15.000
この例では、犬の上にForEachがあり、犬の列も作成します。

00:20:15.000 --> 00:20:18.000
しかし、ここの犬は一致しません。

00:20:18.000 --> 00:20:20.000
価値観は犬の親友です。

00:20:20.000 --> 00:20:25.000
iOS 16では、各行がその値で識別されました。

00:20:25.000 --> 00:20:29.000
iOS 17では、この動作はパフォーマンスを向上させるために変化しました。

00:20:29.000 --> 00:20:34.000
その理由は、ForEachを調べて各テーブル行を識別する必要がないからです。

00:20:34.000 --> 00:20:40.000
したがって、この例では、TableRowの値ではなく、各犬のIDがあります。

00:20:40.000 --> 00:20:49.000
バックデプロイが必要な場合は、コレクションにマッピングするか、IDキーパスを明示的に指定することで、古い動作を取得できます。

00:20:49.000 --> 00:20:59.000
考えるべき基本的な方程式は、リスト内のForEachから生じる行数は、各要素に対して生成されたビューの数を乗じた要素の数に等しいということです。

00:20:59.000 --> 00:21:04.000
テーブルでは、これは似ていますが、要素ごとのTableRowsの数です。

00:21:04.000 --> 00:21:15.000
ここでは、より高速なリストとテーブルのためのいくつかのヒントとコツを取り上げました。つまり、識別子が安価に作成でき、ForEachコンテンツのビュー数が一定であることを確認する必要があります。

00:21:15.000 --> 00:21:16.000
今日は多くのことを取り上げました。

00:21:16.000 --> 00:21:21.000
依存関係を理解し、最適化するためにグラフを探索することから始めました。

00:21:21.000 --> 00:21:25.000
次に、遅い更新と応答性を向上させる方法を調べました。

00:21:25.000 --> 00:21:29.000
そして最後に、リストとテーブルでアイデンティティの重要性について話し合いました。

00:21:29.000 --> 00:21:38.000
適切なメンタルモデルを使用すると、開発プロセスの最初から簡単に優れたパフォーマンスを発揮できるため、アプリの詳細に集中できます。

00:21:38.000 --> 00:21:40.000
見てくれてありがとう。

00:21:40.000 --> 23:59:59.000
♪ ♪

