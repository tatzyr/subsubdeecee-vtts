WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:14.000
ジェン：こんにちは、私はアップルのSafariとWebKitのエバンジェリスト、ジェン・シモンズです。

00:00:14.000 --> 00:00:16.000
WebKitにとって素晴らしい年でした。

00:00:16.000 --> 00:00:28.000
今年中にSafariの複数のリリースですでに140以上の新しいウェブ技術を出荷しており、この秋にはさらに数十の新しいウェブ技術が登場します。

00:00:28.000 --> 00:00:35.000
たくさんあるので、すべてをカバーする方法がないので、CSSに焦点を当てることにしました。

00:00:35.000 --> 00:01:01.000
このセッションでは、レイアウトのまったく新しい可能性、今日の素晴らしいディスプレイを最大限に活用する全世代のカラーツール、新しい疑似クラスのトリッキーな問題を解決する生産的な方法、タイポグラフィを次のレベルに引き上げるCSSなど、CSSの最もエキサイティングな新機能のいくつかを見ていきます。

00:01:01.000 --> 00:01:10.000
すでに出荷されたもの、Safari 17で出荷されるもの、そして将来のために取り組んでいることを共有します。

00:01:10.000 --> 00:01:15.000
今日の未来を見るには、Safari Technology Previewをダウンロードしてください。

00:01:15.000 --> 00:01:18.000
そこには石積みのレイアウトがあります。

00:01:18.000 --> 00:01:22.000
何年もの間、これはウェブ上で人気のあるレイアウトパターンでした。

00:01:22.000 --> 00:01:25.000
さまざまなサイズのコンテンツをパックするのに最適な方法です。

00:01:25.000 --> 00:01:43.000
CSS Multicolumnを使用して、この図形でレイアウトを達成できます。コンテンツの順序が最初の列から始まり、ビューポートの下を流れ、2番目の列の一番上に戻り、下に流れ、次に3番目の列に進みます。

00:01:43.000 --> 00:01:45.000
これがあなたのプロジェクトでうまくいくなら、素晴らしいです。

00:01:45.000 --> 00:01:49.000
CSS Multicolumnは、何十年もブラウザにあったレイアウトメカニズムです。

00:01:49.000 --> 00:01:52.000
しかし、多くの場合、これは機能しません。

00:01:52.000 --> 00:02:02.000
代わりに、デザイナーはコンテンツをページ全体に流れ、各アイテムをできるだけトップに近い列に配置します。

00:02:02.000 --> 00:02:08.000
これは、ユーザーがスクロールするときにより多くのコンテンツが下部に読み込まれる場合に特に必要です。

00:02:08.000 --> 00:02:12.000
そのため、ウェブサイトはこれを達成するためにJavaScriptを使用しなければなりませんでした。

00:02:12.000 --> 00:02:17.000
しかし、JavaScriptはCSSよりもレイアウトが遅く、より脆弱です。

00:02:17.000 --> 00:02:19.000
コーディングが難しい。

00:02:19.000 --> 00:02:23.000
レイアウトは本当にCSSに属しています。

00:02:23.000 --> 00:02:31.000
CSSグリッドの一部として石積みを作成する提案は、数年前に開始され、フラグの背後にある実験としてFirefoxで実装されました。

00:02:31.000 --> 00:02:43.000
私たちはこのアイデアを信じており、それがウェブに出てくるのを見たいので、今はSafari Technology Previewにあります--デフォルトでは--あなたはそれを試してみることができ、あなたの考えを教えてください、そして私たちがそれを前進させるのを手伝ってください。

00:02:43.000 --> 00:02:44.000
ここに例があります。

00:02:44.000 --> 00:02:49.000
私は非常に少ないCSSでこの典型的な石積みレイアウトを作成しました。

00:02:49.000 --> 00:03:00.000
表示：グリッドが開始し、グリッドテンプレート列は、より多くのスペースが利用可能になったときに自動的に数を増やす柔軟な列を提供します。

00:03:00.000 --> 00:03:09.000
次に、grid-template-rows:石積みは、わずか1行のコードで行方向の石積みパターンにアイテムをパックします。

00:03:09.000 --> 00:03:12.000
CSSグリッドのこの部分を作ることは、私たちに途方もない柔軟性を与えます。

00:03:12.000 --> 00:03:33.000
ある次元で石積みを定義し、グリッドの力を使用して、fr単位で列を異なるサイズにしたり、最初の列を固定幅にしたりするなど、他の次元でやりたいことを何でも行うことができますが、中央はfr単位を使用して柔軟で、3番目はminmax値で柔軟になります。

00:03:33.000 --> 00:03:39.000
MasonryとGridを組み合わせることで、人気のあるJavaScriptライブラリよりもはるかに強力なメカニズムになります。

00:03:39.000 --> 00:03:41.000
これはすべてまだ進行中の作業です。

00:03:41.000 --> 00:03:51.000
CSSワーキンググループでは、ブラウザメーカーなどが集まり、完全にアクセス可能であることを確認する作業を含め、今後の道筋に合意するために、より多くの議論が必要です。

00:03:51.000 --> 00:03:55.000
準備ができたら、サファリで石積みを出荷することを楽しみにしています。

00:03:55.000 --> 00:03:58.000
今日、ブラウザで出荷される準備はできていますか?

00:03:58.000 --> 00:03:59.000
マージントリム。

00:03:59.000 --> 00:04:06.000
新しいマージントリムプロパティを使用すると、コンテナに押し上げる要素からマージンを簡単に削除できます。

00:04:06.000 --> 00:04:08.000
説明させてください。

00:04:08.000 --> 00:04:12.000
見出しと3つの段落があると想像してみてください。

00:04:12.000 --> 00:04:20.000
それらはすべて上部と下部の余白があり、それらの間にスペースと、グループ全体の上下のスペースがあります。

00:04:20.000 --> 00:04:26.000
カードのクラスを持つ記事要素であるコンテナに適用されるパディングもあります。

00:04:26.000 --> 00:04:38.000
見出しの上の余白とコンテナの上部のパディングが一緒に追加され、ボックスの上端とテキストの最初の行の間にどれだけのスペースがあるかが決定されます。

00:04:38.000 --> 00:04:40.000
底でも同じです。

00:04:40.000 --> 00:04:50.000
最後の段落の下のマージンは、コンテナの下部パディングに追加され、おそらく意図したよりも多くの空白が追加されます。

00:04:50.000 --> 00:04:58.000
代わりに私たちが望むのは、上部と下部にパディングのみを持ち、マージンを伴わないことです。

00:04:58.000 --> 00:05:01.000
これにより、箱の周りにより均一なスペースが得られます。

00:05:01.000 --> 00:05:06.000
必要なのは、コンテナに押し付けるマージンを排除する方法です。

00:05:06.000 --> 00:05:18.000
あなたはおそらく、見出しから上のマージンを手動で削除し、最後の段落から下のマージンを手動で削除し、最善を期待して、これを処理しようとしました。

00:05:18.000 --> 00:05:20.000
しかし、その後、予期しないコンテンツが表示されます。

00:05:20.000 --> 00:05:29.000
たぶん、別のインスタンスはh3で始まり、誰もそのコードを書かなかったか、誰かがh2を真ん中に貼り付けて、トップマージンが欠けています。

00:05:29.000 --> 00:05:31.000
マージントリムは、より良い解決策を提供します。

00:05:31.000 --> 00:05:39.000
代わりに、コンテナにmargin-trim: blockを適用することで、欲しいものを正確に尋ねることができます。

00:05:39.000 --> 00:05:43.000
Safari 16.4でマージントリムのサポートを追加しました。

00:05:43.000 --> 00:05:47.000
Margin-trim: inlineを使用して、インライン方向にマージンをトリミングすることもできます。

00:05:47.000 --> 00:05:49.000
それはマージントリムです。

00:05:49.000 --> 00:05:53.000
それは単に、より堅牢な方法で共通のニーズを解決します。

00:05:53.000 --> 00:06:00.000
レイアウト用のCSSは、2017年3月のCSSグリッドの登場以来、過去6年間で本当に成熟しています。

00:06:00.000 --> 00:06:04.000
今日のレイアウトは、10年前よりも根本的に改善されています。

00:06:04.000 --> 00:06:16.000
同じ期間に、ウェブデザイナーや開発者によって少し気づかれていない別の急進的な飛躍がありました:色の飛躍。

00:06:16.000 --> 00:06:20.000
世界は、特に外は色彩に満ちています。

00:06:20.000 --> 00:06:25.000
ダイナミックレンジ、彩度、すべてのニュアンスと可能性。

00:06:25.000 --> 00:06:32.000
この図が人間の目が見るかもしれないすべての色を表していると想像してみてください。

00:06:32.000 --> 00:06:41.000
これらの色のサブセットの周りの線は、ウェブ上のデフォルトの色域であるsRGBで表現できるものを示しています。

00:06:41.000 --> 00:06:51.000
それは確かに私たちが90年代に使用したものよりも優れていますが、sRGBの限界を超えて、より多くの視覚スペクトルを伝えるのは素晴らしいことです。

00:06:51.000 --> 00:06:54.000
P3カラーはまさにそれを行います。

00:06:54.000 --> 00:07:06.000
Appleは、7年以上前にハードウェアとソフトウェアで広域ディスプレイP3のサポートを開始しました。最初は2015年後半にiMacで、次にiPad、iPhone 7からiPhoneで始まりました。

00:07:06.000 --> 00:07:13.000
P3色域は、sRGBよりも50%多くの色を表示できます。

00:07:13.000 --> 00:07:15.000
現代のデバイスのディスプレイは素晴らしいです。

00:07:15.000 --> 00:07:21.000
これらはすべて、より明るい色とより深い彩度を持つ広色域P3をサポートしています。

00:07:21.000 --> 00:07:26.000
そして、ウェブデザインを最大限に活用するのは長い過去のことです。

00:07:26.000 --> 00:07:37.000
ユーザーのハードウェアとソフトウェアでできることに応じて、条件付きでCSSを指定する方法が必要な場合は、色域サポートをテストするためのメディアクエリがあります。

00:07:37.000 --> 00:07:44.000
2016年にSafari 10.0でColor Gamut Media Queryのサポートを出荷しました。

00:07:44.000 --> 00:07:57.000
色を選ぶことになると、もちろん、多くの方法があります。名前付き色、16進値、赤、緑、青で考えるRGB関数。

00:07:57.000 --> 00:08:05.000
色相、彩度、軽さのためのHSL、そしてその色相、白さ、黒さを持つHWB。

00:08:05.000 --> 00:08:10.000
色をモデリングするこれらの方法はすべて、同じ結果を生み出すことができます。

00:08:10.000 --> 00:08:14.000
これらのモデルはすべてsRGB色域に制限されています。

00:08:14.000 --> 00:08:21.000
これらのカラーモデルを使用する場合、P3にのみ存在する色を表現することは不可能です。

00:08:21.000 --> 00:08:26.000
そのため、CSSで定義されている新しいものが4つあります。

00:08:26.000 --> 00:08:30.000
LCH、OKLCH、LAB、OKLAB。

00:08:30.000 --> 00:08:38.000
これらのモデルは、ディスプレイP3、または将来ウェブに出てくる可能性のあるその他の色域を含むあらゆる色域で色を表すことができます。

00:08:38.000 --> 00:08:41.000
それらはそれぞれ3つの値で定義されています。

00:08:41.000 --> 00:08:57.000
4つすべてで、「L」は明度LCHを表し、OKLCHはまた、クロマ、またはその色がどれほど強いか、色相、または色スペクトルのどこにあるかの値を取ります。

00:08:57.000 --> 00:09:12.000
LABとOKLABは、A軸に沿った値、または色が緑から赤への軸に沿った値とB軸、または青から黄色までの値を宣言します。

00:09:12.000 --> 00:09:19.000
それぞれに新しい機能を使用して、LCH、OKLCH、LAB、OKLABで色を作成できます。

00:09:19.000 --> 00:09:29.000
ブラウザがP3のサポートを追加した場合、これらの機能はP3にのみ存在する色とsRGB内の色を表すことができます。

00:09:29.000 --> 00:09:34.000
Safari 15.0と15.4でこれらの機能のサポートを出荷しました。

00:09:34.000 --> 00:09:40.000
Chrome、Edge、Firefoxは、Interop 2023プロジェクトのおかげで、今年サポートを追加しています。

00:09:40.000 --> 00:09:47.000
Color() 関数で色を定義し、使用する色域を指定することもできます。

00:09:47.000 --> 00:09:54.000
カラー関数は、スラッシュの後に赤、緑、青、プラスアルファの値を取ります。

00:09:54.000 --> 00:10:01.000
しかし、例えば、100%緑がどのような色を生み出すかは、色域によって異なります。

00:10:01.000 --> 00:10:10.000
6年以上前にSafari 10.1でこのカラー機能を使用して、CSSでP3カラーを作成する機能を最初に出荷しました。

00:10:10.000 --> 00:10:18.000
これらの色域とカラーモデルの出現により、CSSワーキンググループは、その力を利用する追加のツールを定義しました。

00:10:18.000 --> 00:10:23.000
彼らのウェブ標準は、今年これらのツールを出荷するのに十分なほど成熟しました。

00:10:23.000 --> 00:10:28.000
別の色を参照しながら、CSSで色を定義したいと思ったことはありますか?

00:10:28.000 --> 00:10:32.000
しばらくの間、プリプロセッサで同様のことをすることが可能でした。

00:10:32.000 --> 00:10:36.000
さて、相対的な色の構文では、まさにそれを行うことができます。

00:10:36.000 --> 00:10:42.000
色を定義する多くの方法と同様に、カラー関数の1つから始めます。

00:10:42.000 --> 00:10:50.000
これにより、新しい色の作成に関連する数学的計算を行うためにどのカラーモデルが使用されるかが決まります。

00:10:50.000 --> 00:10:55.000
次に、どの既存の色から始めたいかを述べます。

00:10:55.000 --> 00:11:00.000
次に、機能からチャンネルを取り出し、それらを操作します。

00:11:00.000 --> 00:11:11.000
最初の例では、R、G、およびBチャンネルは放置されていますが、/ 0.7はこの色に70%の不透明度を与えるようにブラウザに指示します。

00:11:11.000 --> 00:11:25.000
LABの2番目の例では、ブラウザにLを2で割って計算するように指示しました。これは、AとBのチャンネルをそのままにして、明るさを半分にカットし、色を暗くします。

00:11:25.000 --> 00:11:37.000
そして、3番目の例では、OKLCHでは、LチャンネルとHチャンネルをそのままにして、C、クロマを3分の1でカットし、色の強度を排出します。

00:11:37.000 --> 00:11:46.000
相対色の構文は、デザインのシステムを作成するときに便利な、色のパレット全体を定義する作業を迅速にします。

00:11:46.000 --> 00:11:50.000
新しいカラーモデルは、グラデーションを定義する方法も改善します。

00:11:50.000 --> 00:11:55.000
これは、白から青になる単純な線形グラデーションです。

00:11:55.000 --> 00:12:01.000
何年もの間、これらの種類のグラデーションは常にsRGB色空間を使用して計算されていました。

00:12:01.000 --> 00:12:09.000
さて、Safari 16.2から、グラデーションをsRGBで計算したいと明示的に述べることができます。

00:12:09.000 --> 00:12:12.000
または、色空間を変更することもできます。

00:12:12.000 --> 00:12:21.000
sRGB-linearはsRGBに似ていますが、色間の遷移をより直線的な方法で滑らかにします。

00:12:21.000 --> 00:12:26.000
しかし、これらの両方が紫色の色調に移行していることに気付くかもしれません。

00:12:26.000 --> 00:12:34.000
OKLABに切り替えると、真ん中で計算された色ははるかに青く、おそらくそれが私たちが好むものです。

00:12:34.000 --> 00:12:39.000
LCHはたまたま同様の結果を生み出しますが、同一ではありません。

00:12:39.000 --> 00:12:44.000
OKLCHは、黄色、緑、ティールのスペクトルを介して遷移します。

00:12:44.000 --> 00:12:48.000
LABはたまたまはるかに紫色です。

00:12:48.000 --> 00:12:53.000
または、これらの結果が気に入ったら、HSLまたはHWBを使用できます。

00:12:53.000 --> 00:12:57.000
それは本当にプロジェクトと私たちが望むデザイン効果に依存します。

00:12:57.000 --> 00:13:02.000
これらのどれも正しくも間違ってもいません。どれも最高ではありません。

00:13:02.000 --> 00:13:04.000
場合によります。

00:13:04.000 --> 00:13:06.000
グラデーションを定義するための新しいオプションがたくさんあります。

00:13:06.000 --> 00:13:09.000
色空間の切り替えは大きな影響を与えます。

00:13:09.000 --> 00:13:12.000
これは、色の変化をアニメーション化するのにも当てはまります。

00:13:12.000 --> 00:13:16.000
色空間は、その間に起こることの補間に影響を与えます。

00:13:16.000 --> 00:13:19.000
色を混ぜ合わせるときにも同じ影響が当てはまります。

00:13:19.000 --> 00:13:23.000
はい、CSSで色を混ぜることができます。

00:13:23.000 --> 00:13:27.000
Safari 16.2から、新しいカラーミックス機能があります。

00:13:27.000 --> 00:13:35.000
混合する2つの色をリストし、使用する色空間を指定し、ブラウザはそれらを一緒に混合します。

00:13:35.000 --> 00:13:40.000
グラデーションの真ん中から、この紫がかった青がわかるかもしれません。

00:13:40.000 --> 00:13:45.000
代わりに、グラデーションで使用するために検討した他の色空間のいずれかに切り替えることができます。

00:13:45.000 --> 00:13:50.000
これらはすべて異なる結果を生み出します。

00:13:50.000 --> 00:13:57.000
デフォルトでは、カラーミックスは1つの色の50%と他の色の50%から新しい色を作ります。

00:13:57.000 --> 00:14:03.000
しかし、80/20、または30/70の任意の比率に変更できます。

00:14:03.000 --> 00:14:09.000
また、2つの数字を合計100%未満に設定できるため、色が半透明になります。

00:14:09.000 --> 00:14:18.000
ここでは、白を30%、青を30%に設定し、結果の色の不透明度を60%にしました。

00:14:18.000 --> 00:14:24.000
Currentcolorキーワードを使用して、現在のテキストの色を好きなものと混ぜることもできます。

00:14:24.000 --> 00:14:32.000
この場合、濃い緑色のリンク色と40%の白を混ぜて、ホバー色で使用する明るい緑色を作成します。

00:14:32.000 --> 00:14:34.000
ここにはたくさんあります。

00:14:34.000 --> 00:14:55.000
P3色域、新しいカラーモデルと機能、グラデーションやアニメーションのカラースペースを変更する機能、既存の色のチャンネルを変更したり、ミキシングしたりして色を定義する新しい方法 - ウェブ用のデザインで色を活用することに関しては、ここには多くの可能性があります。

00:14:55.000 --> 00:14:58.000
P3カラーのサポートについて知っておくべき最後のこと。

00:14:58.000 --> 00:15:21.000
ブラウザは、P3色を使用するCSSまたはJavaScriptの特定の機能をサポートする必要があるだけでなく、もちろん、ユーザーのオペレーティングシステムとディスプレイがそれをサポートする必要があるだけでなく、ブラウザは、DOMの異なる部分で、Webページの各特定の部分のP3でのレンダリングをサポートする必要があります。

00:15:21.000 --> 00:15:27.000
普遍的に機能すると仮定する前に、各ブラウザの詳細を確認したいと思うでしょう。

00:15:27.000 --> 00:15:31.000
SafariでP3の最新情報をお伝えします。

00:15:31.000 --> 00:15:36.000
7年前にSafari 10.0でP3の画像のサポートを出荷しました。

00:15:36.000 --> 00:15:42.000
Safari 10.1では、ほとんどのWebページにP3の全体的なサポートを追加しました。

00:15:42.000 --> 00:15:46.000
Safari 15.2では、Canvas要素内にサポートを追加しました。

00:15:46.000 --> 00:15:55.000
また、Safari 16.4では、drawingBufferColorSpaceを使用してWebGL CanvasでP3のサポートを追加しました。

00:15:55.000 --> 00:16:09.000
開発者ツールに関しては、Safari 13.1では、P3でのみ利用可能な色を簡単に見つけたり、あるカラーモデルから別のカラーモデルに色を変換したりできるWeb Inspectorのカラーピッカーを出荷しました。

00:16:09.000 --> 00:16:15.000
また、Safari 15.2では、WebインスペクタのグラフィックスタブにP3のサポートを追加しました。

00:16:15.000 --> 00:16:17.000
私たちはまだもう少しやるべきことがあります。

00:16:17.000 --> 00:16:25.000
まず、WebGL Canvas内でのサポートを拡張し、unpackColorSpaceの使用を含めます。

00:16:25.000 --> 00:16:32.000
また、Web標準に関する議論がまだ続いているため、まだ行っていないSVGフィルタにP3のサポートを追加します。

00:16:32.000 --> 00:16:38.000
今のところ、SVGフィルターを適用すると、すべてのブラウザで色がsRGBに平坦化されます。

00:16:38.000 --> 00:16:46.000
特にこれらの機能の多くが最終的にブラウザで利用可能になるので、ウェブ上の色を再考するのは本当にエキサイティングな時期です。

00:16:46.000 --> 00:16:55.000
CSSの進歩は、デザインの可能性を変えるだけでなく、それらのデザインのコーディングも容易になります。

00:16:55.000 --> 00:17:05.000
:User-valid および :user-invalid 疑似クラスは、ユーザーがフィールドに正しく入力したかどうかに応じて、フォームのスタイル設定方法を提供します。

00:17:05.000 --> 00:17:11.000
何年もの間、:validと:invalidの疑似クラスは本当に役立つように見えました。

00:17:11.000 --> 00:17:15.000
このフォームフィールドのスタイルを設定して、ユーザーが間違いを犯したときに警告したい。

00:17:15.000 --> 00:17:20.000
だから、無効な入力を選択するために:invalid擬似クラスを試してみます。

00:17:20.000 --> 00:17:24.000
:Has input:invalidで、ラベルをターゲットにします。

00:17:24.000 --> 00:17:31.000
そして、::before擬似要素で「x」を挿入するので、コミュニケーションは色だけに依存しません。

00:17:31.000 --> 00:17:33.000
結果を見てみましょう。-結果を見てみましょう。

00:17:33.000 --> 00:17:38.000
誰かが始めたら--ええ、それは素晴らしいことではありません。

00:17:38.000 --> 00:17:45.000
ユーザーが入力を開始するとすぐに、ブラウザはまだ有効なメールアドレスではないため、無効とマークします。

00:17:45.000 --> 00:17:54.000
ユーザーがそれを正しくする機会を得る前に:invalidは入力を間違ってマークするので、開発者は代わりにJavaScriptを使用しています。

00:17:54.000 --> 00:17:57.000
User-validとuser-invalidは、この問題を解決します。

00:17:57.000 --> 00:18:05.000
より複雑なアルゴリズムを使用して、フォームフィールドが有効または無効と見なされるタイミングを判断します。

00:18:05.000 --> 00:18:07.000
Safari 16.5で出荷しました。

00:18:07.000 --> 00:18:10.000
今、私たちは改善された結果を見ることができます。

00:18:10.000 --> 00:18:14.000
彼らがそれを正しく持っているなら、赤い警告はありません。

00:18:14.000 --> 00:18:22.000
そして、誰かがフィールドに誤って記入した場合、私たちが戻って修正するように警告したいときに、彼らがフィールドを去った後に赤い警告が表示されます。

00:18:22.000 --> 00:18:29.000
ご覧のとおり、:user-invalidは:has()と組み合わせると特に強力です。

00:18:29.000 --> 00:18:36.000
実際、今年は、さらに多くの疑似クラスで動作させることで、:has() の力を高めました。

00:18:36.000 --> 00:18:43.000
:Has(:lang()) を使用すると、特定の言語の存在に応じて、ページ上の何かをスタイル設定できます。

00:18:43.000 --> 00:18:51.000
そして、メディア疑似クラスの:has()サポートは、オーディオとビデオの再生の状態に応じて条件付きスタイリングを提供します。

00:18:51.000 --> 00:18:57.000
:Dir擬似クラスは、言語方向のサポートに関してはギャップを埋めます。

00:18:57.000 --> 00:19:05.000
タイプセットされる言語に応じて、テキストは左から右へ、または右から左に流れることがあります。

00:19:05.000 --> 00:19:09.000
これはしばしばLTRとRTLと略されます。

00:19:09.000 --> 00:19:20.000
最近では、CSSにはますます論理的な特性があり、左または右ではなく、テキストフローの開始と終了を参照することができます。

00:19:20.000 --> 00:19:31.000
たとえば、margin-leftとmargin-rightの代わりにmargin-inline-startとmargin-inline-endを使用して、すべての言語で動作するCSSを簡単に記述します。

00:19:31.000 --> 00:19:35.000
しかし、設計のすべてが論理的なプロパティを使用して処理できるわけではありません。

00:19:35.000 --> 00:19:40.000
これは、新しい方向の疑似クラスが役立つ場所です。

00:19:40.000 --> 00:19:45.000
ここには、テキストの方向に応じて変換したいアイコンがあります。

00:19:45.000 --> 00:19:54.000
ヘッダーにLTRの方向がある場合、SVGを一方向に回転させ、ヘッダーがRTLの場合、他の方向に回転させます。

00:19:54.000 --> 00:20:01.000
これは、複数の言語の方向性をサポートするために過去に使用されたものよりもはるかに単純なテクニックです。

00:20:01.000 --> 00:20:09.000
:User-validと無効、:has()への追加、および:dir擬似クラスはすべて、堅牢で簡潔なコードを書くことを容易にします。

00:20:09.000 --> 00:20:18.000
今年はまた、あなたのタイポグラフィの詳細を絶対的な完璧に洗練することを可能にするいくつかの機能をもたらします。

00:20:18.000 --> 00:20:22.000
まず、新しいラインハイトユニットを見てみましょう。

00:20:22.000 --> 00:20:28.000
CSSでは、長さを定義するために使用できる多くの異なる種類の単位があります。

00:20:28.000 --> 00:20:39.000
一部のユニットは、svhやlvhなどのビューポートサイズに対して相対的であるか、cqbやcqiなどのコンテナのサイズに対して相対的です。

00:20:39.000 --> 00:20:43.000
他のユニットは、タイポグラフィのサイズに相対的です。

00:20:43.000 --> 00:20:46.000
1つのexはフォントのxの高さに等しい。

00:20:46.000 --> 00:20:53.000
文字の1つのchは、フォント内のゼロ文字のインラインサイズに一致します。

00:20:53.000 --> 00:21:07.000
そして、1つのICは、CJKスクリプトの表意文字のインラインサイズです。インラインサイズは、水平書き込みモードでは幅、垂直書き込みモードでは高さです。

00:21:07.000 --> 00:21:11.000
これらのユニットはしばらくの間、ブラウザでサポートされています。

00:21:11.000 --> 00:21:22.000
さて、タイポグラフィのサイズにも相対的な新しいユニットがあります。ラインの高さのlhユニット、ルートラインの高さのrlhです。

00:21:22.000 --> 00:21:28.000
これらのユニットを使用すると、レイアウト内のあらゆるものを行間のスペースの量に接続できます。

00:21:28.000 --> 00:21:35.000
たとえば、ルートHTML要素で行の高さを1.4に設定しました。

00:21:35.000 --> 00:21:41.000
次に、セクション要素、この白いカードに2rlhのパディングを入れました。

00:21:41.000 --> 00:21:48.000
次に、見出しと段落の余白をブロック方向に1rlhに設定します。

00:21:48.000 --> 00:21:56.000
今、テキストの行の間には、スペースの代わりにテキストがあるのと同じくらいのスペースがあります。

00:21:56.000 --> 00:22:00.000
それは、タイポグラフィで垂直リズムとして知られているものを設定します。

00:22:00.000 --> 00:22:19.000
ラインの高さの単位は、垂直リズムを乱す可能性のある状況を防ぐことはできませんが、この長年のタイポグラフィの伝統を解き放つことにはるかに近づける信じられないほどシンプルなツールをウェブにもたらし、タイプとタイプの周りの空白の間に親密な接続を作成することができます。

00:22:19.000 --> 00:22:25.000
ウェブ上のデジタルタイポグラフィを伝統的な組版の高水準に磨くには、多くの課題があります。

00:22:25.000 --> 00:22:29.000
これらのうちの1つはフォントサイジングに関係しています。

00:22:29.000 --> 00:22:34.000
ウェブデザイナーであれば、フォントファミリーとフォントサイズを慎重に選択している可能性があります。

00:22:34.000 --> 00:22:40.000
しかし、必要なフォントはダウンロードされないか、ユーザーのオペレーティングシステムで利用できない可能性があります。

00:22:40.000 --> 00:22:48.000
そのため、ブラウザにフォールバックプランを提供するために、フォントファミリのフォントのスタックを宣言するのがベストプラクティスです。

00:22:48.000 --> 00:22:54.000
最初に見つかったフォントは、使用されるフォントです。

00:22:54.000 --> 00:23:03.000
同様に、フォントが特定のサイズで視覚的に表示される大きさは、ウェブ開発者が制御できるものではありません。

00:23:03.000 --> 00:23:08.000
左側にSFハロー、右側にバスカビルがあります。

00:23:08.000 --> 00:23:17.000
それらはまったく同じサイズにタイプセットされていますが、SF Helloはラインボックス内のより多くのスペースを埋めるため、はるかに大きく見えます。

00:23:17.000 --> 00:23:20.000
それはより大きなxの高さを持っています。

00:23:20.000 --> 00:23:26.000
この違いは、フォントファイルが作成されたときに行われた選択によって引き起こされます。

00:23:26.000 --> 00:23:38.000
ここでは、フォントサイズ：1.4remで記事をタイプセットしている例があり、その記事内にあるコードのシンプルなフォントスタックを定義しています。

00:23:38.000 --> 00:23:42.000
コードが段落テキストよりも小さく見えることがわかります。

00:23:42.000 --> 00:23:45.000
Fsを比較すると特に目立ちます。

00:23:45.000 --> 00:23:51.000
コードがモノスペースに戻ると、段落テキストよりも大きく見えます。

00:23:51.000 --> 00:24:11.000
コードのフォントサイズを記事のフォントサイズの120%に調整することで補償を試みることができます。これは、Courierが使用されているときにサイズを均等化するかもしれませんが、ブラウザがモノスペースにフォールバックすると、コードは段落テキストよりもさらに大きくなります。

00:24:11.000 --> 00:24:17.000
必要なのは、ブラウザに「この2つのフォントを同じサイズのように見せてください」と伝える方法です。

00:24:17.000 --> 00:24:20.000
それはまさにfont-size-adjustが行うことです。

00:24:20.000 --> 00:24:25.000
フォントの大きさを調整して、視覚的な一貫性を作り出します。

00:24:25.000 --> 00:24:37.000
私はCSSの1行を追加しました-- font-size-adjust: 0.47--そして今、私のタイプセットコードは、スタック内の両方のフォントでも、段落テキストと視覚的に一致しています。

00:24:37.000 --> 00:24:42.000
しかし、なぜ0.47?この数字はどういう意味ですか?

00:24:42.000 --> 00:24:49.000
ウェブで使用できるラテン語のフォントには、フォントのサイズとxの高さの比率があります。

00:24:49.000 --> 00:24:54.000
その比率は少し恣意的ですが、通常は約50%です。

00:24:54.000 --> 00:25:14.000
Font-size-adjust: 0.47を記事要素に適用することで、私は実際に記事内のすべてのフォントのサイズを変更するようにブラウザに指示しています - 段落フォント、コードフォント、どちらのスタックからどのフォントを使用しても - それぞれのxの高さは常に指定されたフォントサイズの47%です。

00:25:14.000 --> 00:25:23.000
私が0.47を選んだのは、フォントサイズ調整を適用せずにアイオワンオールドスタイルを同じように見せたからです。

00:25:23.000 --> 00:25:30.000
Safari 16.4でフォントサイズ調整のこれらの基本的な機能のサポートを出荷しました。

00:25:30.000 --> 00:25:35.000
Safari 17では、より高度な機能のサポートを追加しています。

00:25:35.000 --> 00:25:44.000
すべてのフォントをメインフォントに一致させるために、0.47のようなマジックナンバーを追跡する必要がなかった方が良いのではないでしょうか?

00:25:44.000 --> 00:25:50.000
From-fontの値を使用すると、ブラウザにすべてを把握するように指示できます。

00:25:50.000 --> 00:25:59.000
また、Safari 17では、サイズの一貫性を作成するときにどのメトリックを使用するかを指定できる2つの値構文のサポートを追加しています。

00:25:59.000 --> 00:26:11.000
デフォルトではex-heightですが、代わりにcap-height、ch-width、ic-width、またはic-heightを使用できます。

00:26:11.000 --> 00:26:21.000
Safari 17では、サイズ調整記述子のサポートも追加されています。これにより、@font-faceルールでフォントを設定するときに同様の調整を行うことができます。

00:26:21.000 --> 00:26:23.000
それはフォントサイズ調整です。

00:26:23.000 --> 00:26:29.000
フォントサイズだけでは簡単に制御できないものをもう少し制御できます。

00:26:29.000 --> 00:26:39.000
しかし、新しいラインの高さの単位と、あなたのタイプの視覚的なサイズを調整する機能があっても、あなたのラインボックスのサイズに不安定な凹凸を作り出すことができるものがまだあります。

00:26:39.000 --> 00:26:42.000
私たちはこの問題に対するいくつかの解決策に取り組んでいます。

00:26:42.000 --> 00:26:45.000
テキストボックスのトリムもその1つです。

00:26:45.000 --> 00:26:49.000
いくつかの点で、text-box-trimはmargin-trimに似ています。

00:26:49.000 --> 00:26:56.000
どちらも不要な空白をトリミングできますが、この場合はテキストボックスにあります。

00:26:56.000 --> 00:26:59.000
ウェブ上で垂直に並べるものを手に入れるのに苦労したことはありますか？

00:26:59.000 --> 00:27:03.000
この名前は垂直方向が中心ではありません。

00:27:03.000 --> 00:27:06.000
真ん中に線を引くと、もっとはっきりするかもしれません。

00:27:06.000 --> 00:27:10.000
テキストは視覚的に中心よりも低い。

00:27:10.000 --> 00:27:13.000
これはウェブ上で常に起こります。

00:27:13.000 --> 00:27:15.000
でも、どうして？

00:27:15.000 --> 00:27:19.000
さて、実際にはテキストボックスは垂直中央に配置されています。

00:27:19.000 --> 00:27:24.000
しかし、グリフはこの箱の奥にあります。

00:27:24.000 --> 00:27:29.000
フォントで予約されている文字の上下に余分なスペースがあります。

00:27:29.000 --> 00:27:39.000
フォントは上ほど下を必要とせず、垂直方向のセンタリングが外れているため、上と下の余分なスペースの量は同じではありません。

00:27:39.000 --> 00:27:42.000
この余分なスペースは非常に重要です。

00:27:42.000 --> 00:27:46.000
アクセントマーク、母音マークなどのために予約されています。

00:27:46.000 --> 00:27:49.000
しかし、それはウェブ上のタイポグラフィレイアウトを捨てることができます。

00:27:49.000 --> 00:27:58.000
テキストボックストリムは、すべてのグリフ全体を表示しながら、レイアウトの目的でこの余分なスペースをトリミングする方法を提供します。

00:27:58.000 --> 00:28:00.000
これは垂直センタリングに役立つだけではありません。

00:28:00.000 --> 00:28:11.000
キャップの高さより上のフォント用に予約された余分なスペースにより、見出しの上部を画像の上部に簡単に合わせることができない例を次に示します。

00:28:11.000 --> 00:28:17.000
余分なスペースをトリミングすることで、物事を並べるのが簡単になります。

00:28:17.000 --> 00:28:19.000
これはすべて進行中の作業です。

00:28:19.000 --> 00:28:23.000
プロパティ名はすでに先頭トリムからテキストボックストリムに変更されています。

00:28:23.000 --> 00:28:33.000
Safari Technology Preview 171の時点で、画面に表示されるコードは、その仕組みですが、これらの詳細にあまり執着しないでください。

00:28:33.000 --> 00:28:36.000
私たちはそれが変化し続けることを期待しています。

00:28:36.000 --> 00:28:38.000
おそらく、それはこのようになるでしょう。

00:28:38.000 --> 00:28:42.000
Safari Technology Previewで試してみて、ご意見をお聞かせください。

00:28:42.000 --> 00:28:49.000
あなたのようなウェブデザイナーや開発者からの初期のフィードバックは、CSSが最高のものになる方法です。

00:28:49.000 --> 00:28:58.000
一方、ブラウザ間で優れたサポートがあり、まもなくSafari 17、カウンタースタイルに来ます。

00:28:58.000 --> 00:29:12.000
あなたはおそらくHTMLの順序付きリストに精通しており、CSSを使用すると、どの番号付けシステムを使用するかを変更するための簡単なメカニズムが提供されます。

00:29:12.000 --> 00:29:16.000
ここで私はリストスタイルを適用しています:デーヴァナーガリー。

00:29:16.000 --> 00:29:26.000
1行のCSSで適用できる数十種類の事前定義されたナンスシステムがあり、世界中の多くの言語をカバーしています。

00:29:26.000 --> 00:29:28.000
しかし、すべてではありません。

00:29:28.000 --> 00:29:30.000
セルビア・クロアチア人はどうですか?

00:29:30.000 --> 00:29:36.000
List-style: upper-serbo-croatianを指定すると、デフォルトの西部のアラビア数字が表示されます。

00:29:36.000 --> 00:29:38.000
ここでカウンタースタイルの出番です。

00:29:38.000 --> 00:29:42.000
ブラウザのやり方と同じように、ナンスリングシステムを定義できます。

00:29:42.000 --> 00:29:49.000
@Counter-style、それから私がそれを与えたい名前、それから私はスタイルの資質を定義します。

00:29:49.000 --> 00:29:55.000
この場合、システムをアルファベットに設定し、記号を一覧表示します。

00:29:55.000 --> 00:30:05.000
W3C国際化ワーキンググループは、世界中の何百もの文化をカバーする既製のカウンタースタイルの文書を公開しました。

00:30:05.000 --> 00:30:15.000
WebKitでサポートされている言語の数を増やし、CSSワーキンググループで、すべてのブラウザがこれらすべてのサポートを出荷することについて議論を開きました。

00:30:15.000 --> 00:30:22.000
しかし、それが起こるまで、このドキュメントからコードスニペットをコピーしてコードに貼り付けることができます。

00:30:22.000 --> 00:30:26.000
リストカウンタをスタイル設定して、完全にカスタムにすることもできます。

00:30:26.000 --> 00:30:32.000
このリストは、最低4桁のバイナリでアイテムを数えるようにスタイル設定しました。

00:30:32.000 --> 00:30:36.000
そして、これは絵文字のセットを何度も何度も循環させるものです。

00:30:36.000 --> 00:30:41.000
CSSカウンタは、リスト以外のページ上の他のコンテンツに番号を設定するためにも使用できます。

00:30:41.000 --> 00:30:46.000
長い文書の各セクションで始まる見出しのように。

00:30:46.000 --> 00:30:47.000
ここに例があります。

00:30:47.000 --> 00:30:52.000
H2の見出しが3つあり、見出しごとに単語だけです。

00:30:52.000 --> 00:30:56.000
CSSでは、counter-resetを宣言してカウンタを作成します。

00:30:56.000 --> 00:31:01.000
私はそれを「ナンブニング」と名付け、ゼロの後にカウントを開始するように設定しました。

00:31:01.000 --> 00:31:09.000
次に、:before pseudo-elementを使用して、ブラウザにカウンタをインクリメントしてコンテンツに表示するように指示します。

00:31:09.000 --> 00:31:16.000
デフォルトでは、カウンターは西部のアラビア数字--1、2、3-を使用しますが、それを変更できます。

00:31:16.000 --> 00:31:20.000
以前と同じように、私は欲しいものになるようにカウンターをスタイリングすることができます。

00:31:20.000 --> 00:31:23.000
それがカウンターの作成とスタイルの作り方です。

00:31:23.000 --> 00:31:29.000
しかし、タイポグラフィを次のレベルに引き上げるために、今年やっているのはそれがすべてではありません。

00:31:29.000 --> 00:31:33.000
実際、今年はさらに多くのCSSが登場します。

00:31:33.000 --> 00:31:48.000
Safari 16.2では、Open Type機能をさらにサポートするために、GridとFlexboxの最後のベースラインアライメントのサポートに加えて、font-variant-alternatesと@font-feature-values内のいくつかの機能も提供しました。

00:31:48.000 --> 00:31:58.000
Safari 16.4では、Media Queriesの範囲構文とブール論理、@propertyなどのサポートも追加されました。

00:31:58.000 --> 00:32:03.000
Safari 16.5では、CSSネスティングのサポートも追加されました。

00:32:03.000 --> 00:32:16.000
また、Safari 17では、フォント技術とフォントフォーマットの機能検出、インテンシニックサイズ、テキストトランスフォーム：全幅とフルサイズカナなどを追加しています。

00:32:16.000 --> 00:32:28.000
問題を提出したり、ソーシャルメディアで私たちにpingをしたり、どのウェブテクノロジーを最も実装または改善する必要があるかを知らせるためにブログ記事を書いたりするすべての人に心から感謝したいと思います。

00:32:28.000 --> 00:32:33.000
私たちは耳を傾けており、あなたの意見は影響を与えます。

00:32:33.000 --> 00:32:35.000
他に何が必要か教えてください。

00:32:35.000 --> 00:32:43.000
WebKitの問題トラッカーであるbugs.webkit.orgで、Webテクノロジーのバグレポートと機能リクエストを提出できます。

00:32:43.000 --> 00:32:54.000
Safariのインターフェースに関する問題、またはiOS、iPadOS、macOSに関する問題は、feedbackassistant.apple.comに提出してください。

00:32:54.000 --> 00:32:59.000
Safariでサポートされているものに関する最新情報を持っていることを確認してください。

00:32:59.000 --> 00:33:05.000
開発者から、実際にすでに出荷されているものを実装するように求められるのをよく耳にします。

00:33:05.000 --> 00:33:08.000
Caniuseはこれのための素晴らしいリソースです。

00:33:08.000 --> 00:33:23.000
また、webkit.orgの最新ニュースを入手することもできます。ここでは、Safariの各リリースに関する詳細な記事、Safari Technology Previewのリリースノート、Web Inspectorに関する広範なドキュメントなどを見つけることができます。

00:33:23.000 --> 00:33:27.000
Safari Technology Previewをダウンロードして、今後の予定に追いついてください。

00:33:27.000 --> 00:33:33.000
約2週間ごとに更新されるため、WebKitに最新のものが追加されています。

00:33:33.000 --> 00:33:41.000
Safari Technology Previewには、デフォルトでプレビューする準備ができているすべての新機能もあります。

00:33:41.000 --> 00:34:17.000
または、Safari設定の新しい機能フラグペインで機能のオンとオフを切り替えることができます。Safari 17から、完全に再設計された開発メニューからアクセスできます。これは、MacのWebインスペクタをiPhone、iPad、またはその他のデバイスのウェブサイトやWebアプリにワイヤレスで接続するためのクイックアクセス、または手元にないデバイスでテストします。無料のデバイスシミュレータをダウンロードし、開発メニューから、または再設計された

00:34:17.000 --> 00:34:24.000
WWDC23で「Safari開発者機能の再発見」を見て、すべてについて学んでください。

00:34:24.000 --> 00:34:26.000
ウェブアプリがMacにやってくる。

00:34:26.000 --> 00:34:31.000
さらに、今年はiPhoneとiPadのウェブアプリの改善にぎっしり詰まりました。

00:34:31.000 --> 00:34:34.000
「ウェブアプリの新機能」は、すべてをカバーしています。

00:34:34.000 --> 00:34:46.000
また、JPEG XLを含むSafariやWebKitに搭載される新しい画像フォーマットと、「ウェブ用のメディアフォーマットを探索する」の新しいマネージドメディアソースAPIについて学びます。

00:34:46.000 --> 00:34:53.000
私たちは、今年WebKitとSafariでどれだけの新しいウェブ技術が出荷されているかに興奮しており、あなたもそうであることを願っています。

00:34:53.000 --> 00:34:56.000
そして、私たちはあなたがそれで何を作るかを見るのが待ちきれません。

00:34:56.000 --> 23:59:59.000
見てくれてありがとう。

