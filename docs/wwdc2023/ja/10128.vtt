WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:15.000
Pawel Szczerbuk: こんにちは、私の名前はPawel Szczerbukで、GPUソフトウェアエンジニアです。

00:00:15.000 --> 00:00:21.000
Metalは、レイトレーシングアプリケーションを複雑で詳細なシーンに拡張するのに役立ちます。

00:00:21.000 --> 00:00:30.000
レイトレーシングはプロダクションレンダリングにおける画像の忠実度の基本であり、ゲームのレイトレーシングは視覚品質を向上させながら高いフレームレートに焦点を当てています。

00:00:30.000 --> 00:00:36.000
ディズニーのモアナアイランドシーンのこの画像は、メタルレイトレーシングでレンダリングされました。

00:00:36.000 --> 00:00:40.000
今日は、メタルレイトレーシングの使い方について話します。

00:00:40.000 --> 00:00:49.000
ゲームやプロダクションレンダラーでレイトレーシングを加速するために使用できるエキサイティングな新機能を強調します。

00:00:49.000 --> 00:01:00.000
レイトレーシングアプリケーションは、シーンの周りに跳ね返る個々の光線をシミュレートします。メタルレイトレーシングでレンダリングするには、最初のステップはシーンジオメトリを定義することです。

00:01:00.000 --> 00:01:10.000
次に、Metalはジオメトリを含む加速構造を構築し、GPUアクセラレーションを使用して交差点を効率的に照会できます。

00:01:10.000 --> 00:01:15.000
GPU関数で、シーンと交差する光線を作成します。

00:01:15.000 --> 00:01:22.000
シェーダーにインターセクターオブジェクトを作成し、光線と加速度構造の両方を提供します。

00:01:22.000 --> 00:01:30.000
これにより、ピクセルをシェーディングするか、さらに処理するために必要なすべての情報を含む交差結果が返されます。

00:01:30.000 --> 00:01:41.000
これらの各ピースが連携して、シーンを構築し、インスタンシングを使用して視覚的な複雑さを追加し、レイ交差を実行できるようにします。

00:01:41.000 --> 00:01:48.000
そして、レイトレーシングアプリケーションで作業するのに役立つ素晴らしいツールがいくつかあります。

00:01:48.000 --> 00:01:52.000
すべてはあなたのシーンを構築することから始まります。

00:01:52.000 --> 00:01:56.000
メタルレイトレーシングAPIは、いくつかの異なるタイプのジオメトリをサポートしています。

00:01:56.000 --> 00:02:02.000
このジオメトリはすべて加速度構造に格納されています。

00:02:02.000 --> 00:02:09.000
加速度構造は、ジオメトリを再帰的に分割することにより、レイトレーシングプロセスを高速化します。

00:02:09.000 --> 00:02:15.000
これにより、光線と交差しないジオメトリをすばやく排除できます。

00:02:15.000 --> 00:02:20.000
3つのステップで加速構造を設定できます。

00:02:20.000 --> 00:02:25.000
実際のジオメトリを提供する加速度構造記述子を作成します。

00:02:25.000 --> 00:02:32.000
記述子を取得したら、加速度構造を割り当ててから構築できます。

00:02:32.000 --> 00:02:38.000
加速度構造記述子には、1つ以上のジオメトリ記述子が含まれています。

00:02:38.000 --> 00:02:42.000
メタルには3種類のジオメトリ記述子があります。

00:02:42.000 --> 00:02:48.000
三角形は、私たち全員が知っていて愛しているプリミティブであり、コンピュータグラフィックスでほとんどすべてをモデル化するために使用されます。

00:02:48.000 --> 00:02:58.000
バウンディングボックスプリミティブは、レイが囲むバウンディングボックスに当たったときにMetalが呼び出すカスタム交差関数によって完全に定義されます。

00:02:58.000 --> 00:03:00.000
そして今年は新しい、曲線。

00:03:00.000 --> 00:03:05.000
これらは髪や毛皮をレンダリングするのに最適です。

00:03:05.000 --> 00:03:13.000
三角形を使用して加速度構造を作成するには、個々のジオメトリの三角形ジオメトリ記述子を作成します。

00:03:13.000 --> 00:03:18.000
頂点バッファ、インデックスバッファ、および三角形カウントを提供します。

00:03:18.000 --> 00:03:27.000
バウンディングボックスのジオメトリも同様に機能しますが、頂点の代わりに、ジオメトリを囲むバウンディングボックスを提供します。

00:03:27.000 --> 00:03:35.000
さらに、レイがバウンディングボックスプリミティブに当たったときにMetalが呼び出す交差関数を提供します。

00:03:35.000 --> 00:03:44.000
交差機能の設定方法の詳細については、2020年の「金属でレイトレーシングを発見する」トークを参照してください。

00:03:44.000 --> 00:03:51.000
髪、毛皮、植生などの幾何学は、数千または数百万のプリミティブを持つことができます。

00:03:51.000 --> 00:03:54.000
これらは通常、微細で滑らかな曲線としてモデル化されています。

00:03:54.000 --> 00:04:00.000
三角形を使用してこれらの曲線を近似する代わりに、Metalの新しい曲線プリミティブを使用できます。

00:04:00.000 --> 00:04:04.000
これらの曲線は、カメラがズームインしても滑らかなままです。

00:04:04.000 --> 00:04:14.000
そして、三角形と比較して、曲線はよりコンパクトなメモリフットプリントを持ち、より高速な加速構造の構築を可能にします。

00:04:14.000 --> 00:04:19.000
フルカーブは、一連の接続されたカーブセグメントで構成されています。

00:04:19.000 --> 00:04:26.000
曲線上のすべてのセグメントは独自のプリミティブであり、Metalは各セグメントに一意のプリミティブIDを割り当てます。

00:04:26.000 --> 00:04:33.000
これらの各セグメントは、曲線の形状を制御する一連の制御ポイントによって定義されます。

00:04:33.000 --> 00:04:38.000
これらの制御点は、一連の基本関数を使用して補間されます。

00:04:38.000 --> 00:04:44.000
基底関数に応じて、各曲線セグメントは2、3、または4つのコントロールポイントを持つことができます。

00:04:44.000 --> 00:04:55.000
Metalは、Bezier、Catmull-Rom、B-Spline、Linearの4つの異なる曲線基底関数を提供します。

00:04:55.000 --> 00:05:01.000
これらの基本機能にはそれぞれ独自の利点がありますので、ユースケースに最適なものを選択してください。

00:05:01.000 --> 00:05:05.000
金属には、コントロールポイントインデックスバッファも必要です。

00:05:05.000 --> 00:05:12.000
各曲線セグメントには、セグメントの最初のコントロールポイントを表すこのバッファに1つのインデックスがあります。

00:05:12.000 --> 00:05:15.000
たとえば、4つのコントロールポイントがあるとします。

00:05:15.000 --> 00:05:23.000
最初のコントロールポイントのインデックスを使用して曲線セグメントを定義するので、インデックスバッファにゼロを追加します。

00:05:23.000 --> 00:05:32.000
この例では、Catmull-Rom基底関数を使用しているため、実際の曲線セグメントはコントロールポイント1と2の間でのみ定義されます。

00:05:32.000 --> 00:05:37.000
別のカーブセグメントを接続するために必要なのは、もう1つのコントロールポイントを追加することだけです。

00:05:37.000 --> 00:05:44.000
この追加の曲線セグメントは、コントロールポイント1から4を使用するので、インデックスバッファに1を追加します。

00:05:44.000 --> 00:05:52.000
これらの2つの曲線セグメントは、インデックスバッファのために3つのコントロールポイントを共有しています。これは、曲線がメモリを節約できる理由の1つです。

00:05:52.000 --> 00:05:56.000
カーブを完成させるには、これを何度でも繰り返します。

00:05:56.000 --> 00:06:06.000
新しい曲線を開始するには、以前のコントロールポイントと重複しない追加のコントロールポイントを追加し、対応するインデックスをインデックスバッファに追加するだけです。

00:06:06.000 --> 00:06:11.000
これまでのところ、私が説明した曲線は抽象的な数学的オブジェクトでした。

00:06:11.000 --> 00:06:16.000
それらをレンダリングするには、何らかの3D形状が必要です。

00:06:16.000 --> 00:06:21.000
各制御点には、曲線の長さに沿って補間される半径もあります。

00:06:21.000 --> 00:06:26.000
デフォルトでは、曲線は3D円筒断面でレンダリングされます。

00:06:26.000 --> 00:06:30.000
これは、クローズアップから見える曲線に最適です。

00:06:30.000 --> 00:06:35.000
遠くからしか見られない曲線の場合、金属は平らな曲線もサポートします。

00:06:35.000 --> 00:06:41.000
これにより、完全な3Dジオメトリを必要としないときはいつでもパフォーマンスを向上させることができます。

00:06:41.000 --> 00:06:48.000
三角形や境界ボックスと同様に、曲線ジオメトリは曲線ジオメトリ記述子で表されます。

00:06:48.000 --> 00:06:54.000
コントロールポイント、対応する半径、およびコントロールポイントインデックスを含むバッファを取り付けます。

00:06:54.000 --> 00:07:00.000
コントロールポイントバッファ内のコントロールポイントの数と、実際のカーブセグメントの数を設定します。

00:07:00.000 --> 00:07:06.000
これは、インデックスバッファ内のインデックスの数と同じである必要があります。

00:07:06.000 --> 00:07:08.000
使用している曲線の種類を指定します。

00:07:08.000 --> 00:07:14.000
この例では、曲線セグメントごとに4つの制御点を持つ丸いベジェ曲線を使用しています。

00:07:14.000 --> 00:07:19.000
カーブジオメトリ記述子を設定するために必要なのはそれだけです。

00:07:19.000 --> 00:07:27.000
ジオメトリ記述子を作成したので、加速度構造記述子を設定できます。

00:07:27.000 --> 00:07:34.000
三角形、境界ボックス、曲線などのプリミティブジオメトリには、プリミティブ加速度構造記述子を使用します。

00:07:34.000 --> 00:07:39.000
加速度構造記述子にジオメトリ記述子を追加します。

00:07:39.000 --> 00:07:46.000
複数のジオメトリ記述子を単一の加速度構造に追加して、ジオメトリを組み合わせることができます。

00:07:46.000 --> 00:07:53.000
加速度構造記述子の準備ができたら、加速度構造にメモリを割り当てることができます。

00:07:53.000 --> 00:07:59.000
メタルを使用すると、このメモリがいつ、どこに割り当てられるかを完全に制御できます。

00:07:59.000 --> 00:08:02.000
これは2部構成の操作です。

00:08:02.000 --> 00:08:07.000
まず、ビルドに必要なオブジェクトのサイズを計算します。

00:08:07.000 --> 00:08:13.000
金属装置は、加速構造に必要な割り当てサイズを計算する方法を提供します。

00:08:13.000 --> 00:08:24.000
金属デバイスから直接加速構造のストレージを割り当てることは可能ですが、ヒープから割り当てると、後でリソース管理のオーバーヘッドを削減できます。

00:08:24.000 --> 00:08:32.000
ヒープには追加のサイズとアライメント要件があり、Metalデバイスで別の方法を使用してクエリできます。

00:08:32.000 --> 00:08:38.000
これらのサイズを使用すると、加速度構造を格納するためにメモリを割り当てることができます。

00:08:38.000 --> 00:08:42.000
このストレージは、MTL Acceleration Structureオブジェクトで表されます。

00:08:42.000 --> 00:08:51.000
これらのオブジェクトの1つを割り当てるには、ヒープまたはメタルデバイスでmake Acceleration Structureメソッドを呼び出し、サイズを渡します。

00:08:51.000 --> 00:08:58.000
また、加速構造を構築する際にMetalが使用するスクラッチメモリも割り当てます。

00:08:58.000 --> 00:09:08.000
このメモリはGPUのみがアクセスする必要があるため、Metalデバイスからプライベートストレージモードバッファを割り当てることでこれを行うことができます。

00:09:08.000 --> 00:09:12.000
これで、実際に加速構造を構築する準備が整いました。

00:09:12.000 --> 00:09:18.000
ビルド操作をスケジュールすると、MetalがGPUでアクセラレーションを構築します。

00:09:18.000 --> 00:09:24.000
これを行うには、加速構造コマンドエンコーダを使用します。

00:09:24.000 --> 00:09:30.000
このエンコーダには、加速構造を構築および変更するために使用できるいくつかの方法があります。

00:09:30.000 --> 00:09:37.000
この場合、宛先加速構造、記述子、およびスクラッチバッファを使用してビルドメソッドを呼び出します。

00:09:37.000 --> 00:09:45.000
Metalはジオメトリの原始的な加速構造を構築し、その後のGPUコマンドで使用できるようになります。

00:09:45.000 --> 00:09:51.000
それが、シーンのジオメトリを原始的な加速度構造で表現する方法です。

00:09:51.000 --> 00:09:57.000
より大きなシーンにスケーリングできるように、Metalはインスタンスアクセラレーション構造もサポートしています。

00:09:57.000 --> 00:10:07.000
モアナ島のシーンのような複雑で詳細な環境を単一の原始的な加速構造に格納するには、膨大な量のメモリが必要です。

00:10:07.000 --> 00:10:19.000
しかし、この複雑なシーンは、何千もの木、何百万もの葉、その他のオブジェクトに反復的な構造を持ち、シーンを効率的にレンダリングするために悪用することができます。

00:10:19.000 --> 00:10:28.000
山、サンゴ、木など、シーン内のすべてのユニークなオブジェクトは、原始的な加速構造として表現できます。

00:10:28.000 --> 00:10:34.000
これらは、シーン全体を表すインスタンスアクセラレーション構造に組み合わせることができます。

00:10:34.000 --> 00:10:50.000
したがって、原始的な加速度構造にはジオメトリが含まれていますが、インスタンス加速度構造には、完全なシーンを構成するために異なる位置、サイズ、および向きに変換された他の加速度構造への参照が含まれています。

00:10:50.000 --> 00:10:56.000
各インスタンスには、シーンで参照する加速度構造を配置するための変換マトリックスがあります。

00:10:56.000 --> 00:11:03.000
インスタンス加速構造を構築することは、原始的な加速構造を構築するのと似ています。

00:11:03.000 --> 00:11:06.000
記述子を作成することから始めます。

00:11:06.000 --> 00:11:18.000
今回は、ジオメトリの代わりに、参照する加速度構造や、それをシーンに配置する変換行列など、各インスタンスに関する情報を含むバッファを提供します。

00:11:18.000 --> 00:11:27.000
次に、原始的な加速構造を構築するのと同じ方法で、GPUに加速構造を構築します。

00:11:27.000 --> 00:11:36.000
記述子を作成するには、MTLインスタンスアクセラレーション構造記述子を構築し、含まれるインスタンスの数を設定します。

00:11:36.000 --> 00:11:48.000
次に、インスタンスによって参照できるプリミティブアクセラレーション構造の配列を提供し、インスタンスバッファに含まれるインスタンス記述子のタイプを指定します。

00:11:48.000 --> 00:11:55.000
Metalは、ユースケースに応じて選択できるいくつかのインスタンス記述子タイプを提供しています。

00:11:55.000 --> 00:12:01.000
アクセラレーション構造のインスタンスを2つのステップで設定します。

00:12:01.000 --> 00:12:06.000
まず、インスタンスごとのデータを格納するためのバッファを割り当てます。

00:12:06.000 --> 00:12:17.000
このバッファのサイズは、インスタンスの数と各インスタンス記述子のサイズによって異なりますが、他のメタルバッファと同様に割り当てられます。

00:12:17.000 --> 00:12:23.000
バッファを割り当てたら、インスタンスアクセラレーション構造記述子に割り当てます。

00:12:23.000 --> 00:12:31.000
次に、アクセラレーション構造内のすべてのインスタンスに関する情報をインスタンスバッファに塗りつぶします。

00:12:31.000 --> 00:12:39.000
インスタンスごとに、記述子を作成し、このインスタンスが参照する加速度構造を指定します。

00:12:39.000 --> 00:12:48.000
インスタンス加速度構造記述子に設定した配列にインデックスで加速度構造を識別します。

00:12:48.000 --> 00:12:59.000
各インスタンスには、使用しているインスタンス記述子のタイプに応じて、変換マトリックス、可視性マスク、およびその他のプロパティもあります。

00:12:59.000 --> 00:13:07.000
最後のステップは、原始的な加速構造と同じプロセスである実際の加速構造を構築することです。

00:13:07.000 --> 00:13:10.000
ビルドがCPUで実行できる前のすべてのステップ。

00:13:10.000 --> 00:13:17.000
しかし、インスタンスの数が多い場合、インスタンスバッファを記入するプロセスは計算集約的になる可能性があります。

00:13:17.000 --> 00:13:27.000
インスタンス記述子は通常のMetalバッファに格納されているため、GPUからこれらの記述子に入力することで、このステップを加速できます。

00:13:27.000 --> 00:13:38.000
GPUに作業を渡す前に、アクセラレーション構造にいくつのインスタンスが含まれるかを知っていれば、これはGPUアクセラレーションにとって絶好の機会です。

00:13:38.000 --> 00:13:48.000
しかし、インスタンスカリングのようなものをしたい場合は、記述子で最終的なインスタンス数を設定できるように、CPU上のインスタンスをキュールする必要があります。

00:13:48.000 --> 00:13:55.000
今年の新機能では、新しい間接インスタンスアクセラレーション構造記述子を使用して、GPUでこのプロセスを駆動できます。

00:13:55.000 --> 00:14:04.000
この間接記述子を使用すると、インスタンスを淘汰し、インスタンスバッファを埋め、最終的なインスタンス数をGPUに完全に設定できます。

00:14:04.000 --> 00:14:12.000
GPU駆動のアクセラレーション構造ビルドを実行するには、間接インスタンスアクセラレーション構造記述子を作成します。

00:14:12.000 --> 00:14:20.000
記述子の最大インスタンス数と、GPUから最終的なインスタンス数を書き込むバッファを設定します。

00:14:20.000 --> 00:14:28.000
次に、インスタンス記述子バッファを設定するだけで、GPUでインスタンスの設定を開始する準備が整いました。

00:14:28.000 --> 00:14:32.000
インスタンスバッファでは、異なるタイプの記述子を使用します。

00:14:32.000 --> 00:14:44.000
間接インスタンス記述子は、直接インスタンス記述子に似ていますが、記述子に割り当てるだけでインスタンス化構造を識別できます。

00:14:44.000 --> 00:14:48.000
それが、インスタンスアクセラレーション構造を構築する方法です。

00:14:48.000 --> 00:14:52.000
これまでのところ、私は2レベルのインスタンス化モデルについて話しました。

00:14:52.000 --> 00:14:59.000
このモデルでは、モアナ島のシーンの森は、さまざまな木の何千ものインスタンスで構成されています。

00:14:59.000 --> 00:15:05.000
しかし、より深く掘り下げると、木自体は同じ葉の多くのコピーを持つ幹です。

00:15:05.000 --> 00:15:11.000
新しいマルチレベルインスタンス機能を使用して、この構造を活用できます。

00:15:11.000 --> 00:15:22.000
マルチレベルのインスタンス化により、インスタンス加速構造には、原始的な加速構造だけでなく、他のインスタンス加速構造も含めることができます。

00:15:22.000 --> 00:15:37.000
たとえば、このシーンでは、ヤシの木は幹と葉のインスタンスを含むインスタンス加速構造として表現できますが、シーン全体にヤシの木のインスタンスを含めることができます。

00:15:37.000 --> 00:15:43.000
モアナ島のシーンは、マルチレベルインスタンシングの力の素晴らしい例です。

00:15:43.000 --> 00:15:53.000
2つのレベルのインスタンスを使用する場合、シーンに1種類のツリーを追加すると、ツリーの部分の数百または数千のコピーを追加する可能性があります。

00:15:53.000 --> 00:16:01.000
しかし、マルチレベルのインスタンス化では、その部分の繰り返しインスタンスで定義された複雑なツリーのインスタンスを追加できます。

00:16:01.000 --> 00:16:06.000
これにより、モアナ島のシーン全体で何百万ものインスタンスが節約されます。

00:16:06.000 --> 00:16:10.000
しかし、マルチレベルのインスタンス化は、プロダクションレンダラーだけのものではありません。

00:16:10.000 --> 00:16:16.000
また、ゲームのようなリアルタイムアプリにも価値があります。

00:16:16.000 --> 00:16:22.000
ゲームはまた、2レベルの加速構造パターンを使用し、ゲームオブジェクトのインスタンスから世界を構築します。

00:16:22.000 --> 00:16:26.000
しかし、ゲームはプロダクションレンダラーとは異なります。

00:16:26.000 --> 00:16:34.000
プロダクションレンダラーはオブジェクトを再利用するために深い階層を使用しますが、ゲームはゲームオブジェクトのインスタンスの長いリストを使用します。

00:16:34.000 --> 00:16:46.000
ゲームはまた、動的コンテンツの各フレームのインスタンスアクセラレーション構造を再構築し、高いインスタンス数は再構築のための多くのGPU時間を意味します。

00:16:46.000 --> 00:16:52.000
しかし、ゲームでは、多くのコンテンツは静的であり、すべてのフレームを更新する必要はありません。

00:16:52.000 --> 00:17:02.000
世界を静的および動的加速構造に分割して、加速構造の更新を変更したコンテンツのみに制限することができます。

00:17:02.000 --> 00:17:08.000
これは、通常、静的コンテンツよりもはるかに少ない動的コンテンツを再構築することを意味します。

00:17:08.000 --> 00:17:18.000
この静的コンテンツと動的コンテンツの分割を適用する場合、階層の深さとレイトラバーサルの追加コストのバランスをとることが重要です。

00:17:18.000 --> 00:17:32.000
加速構造の建物とレイトレーシングを備えたフレームでは、3つのレベルのインスタンス化を使用すると、トレース時間にわずかな影響だけでビルド時間を短縮でき、全体的にフレーム時間を短縮できます。

00:17:32.000 --> 00:17:38.000
マルチレベルのインスタンス化は、メモリ使用量を削減し、再構築をスピードアップするための優れたツールです。

00:17:38.000 --> 00:17:42.000
また、メタルレイトレーシングアプリを最適化する他の方法もあります。

00:17:42.000 --> 00:17:46.000
そのうちの1つは、並列化の構築です。

00:17:46.000 --> 00:17:55.000
典型的なアプリケーションは、さまざまなシーンやシーンのさまざまな部分を表す多くのアクセラレーション構造を構築または更新する必要があります。

00:17:55.000 --> 00:18:01.000
これらのビルドを並行して実行することで、起動時間を大幅に短縮できます。

00:18:01.000 --> 00:18:10.000
可能な限り、複数のビルドを同じコマンドエンコーダにエンコードして、並行して実行できるように、ビルドをバッチ処理してください。

00:18:10.000 --> 00:18:17.000
作業セットがメモリに収まるようにしながら、できるだけ多くのビルドを並列化したいと思うでしょう。

00:18:17.000 --> 00:18:24.000
また、加速構造の構築が完了すると、スクラッチバッファは不要になることを忘れないでください。

00:18:24.000 --> 00:18:32.000
これは、アクセラレーション構造ビルドの1つのバッチから次のバッチにスクラッチバッファを再利用できることを意味します。

00:18:32.000 --> 00:18:39.000
時には、加速構造の再構築に費やす時間を短縮する最善の方法は、再構築を完全に避けることです。

00:18:39.000 --> 00:18:43.000
ここで加速構造のリフィッティングの出番です。

00:18:43.000 --> 00:18:49.000
Metalが加速構造を構築すると、近くのプリミティブをボックスの階層にグループ化します。

00:18:49.000 --> 00:18:58.000
プリミティブが移動すると、これらのボックスはシーンを正確に表さなくなり、加速構造を更新する必要があります。

00:18:58.000 --> 00:19:04.000
しかし、ジオメトリがわずかにしか変わらない場合でも、階層は合理的かもしれません。

00:19:04.000 --> 00:19:16.000
新しい加速構造をゼロから構築する代わりに、Metalは既存の加速構造を改造して、ジオメトリのプリミティブの新しい位置を反映することができます。

00:19:16.000 --> 00:19:21.000
これは、加速構造をゼロから再構築するよりも安いです。

00:19:21.000 --> 00:19:25.000
Refitには、ビルド操作のようなスクラッチバッファが必要です。

00:19:25.000 --> 00:19:32.000
リフィットスクラッチバッファのサイズは、以前に加速度構造を割り当てるために使用したのと同じ構造体にあります。

00:19:32.000 --> 00:19:39.000
リフィット操作はGPU上で実行され、アクセラレーション構造コマンドエンコーダでエンコードされます。

00:19:39.000 --> 00:19:44.000
修理は、その場で、または別の加速構造で動作することができます。

00:19:44.000 --> 00:19:51.000
最後に、圧縮はメモリ内の加速度構造のサイズを小さくする素晴らしい方法です。

00:19:51.000 --> 00:20:01.000
最初に加速構造を構築するとき、Metalは必要なメモリ量を正確に知ることができないので、保守的な見積もりを行う必要があります。

00:20:01.000 --> 00:20:08.000
加速構造を構築したら、金属はそれを表現するために必要な最小サイズを計算できます。

00:20:08.000 --> 00:20:19.000
圧縮を使用すると、最小サイズで新しい加速構造を割り当て、GPUを使用して現在の加速構造から新しい加速構造にコピーできます。

00:20:19.000 --> 00:20:24.000
これは、原始的な加速構造にとって特に貴重です。

00:20:24.000 --> 00:20:31.000
圧縮を使用するには、コマンドをエンコードして、GPU上の加速構造の圧縮されたサイズを計算します。

00:20:31.000 --> 00:20:38.000
コマンドを実行すると、Metalはあなたが提供するバッファに圧縮されたサイズを書き込みます。

00:20:38.000 --> 00:20:50.000
圧縮されたサイズを読んだら、そのサイズで新しい加速構造を割り当て、古いものから新しい加速構造への「コピーとコンパクト」操作をエンコードすることができます。

00:20:50.000 --> 00:20:55.000
このコマンドバッファが完了したら、元の加速構造を解放できます。

00:20:55.000 --> 00:21:04.000
メタルレイトレーシングアプリの最適化の詳細については、2022年の「メタルレイトレーシングパフォーマンスの最大化」セッションをご覧ください。

00:21:04.000 --> 00:21:14.000
このセクションでは、インスタンス化を設定し、新しいマルチレベルインスタンス化機能を活用し、インスタンス化を大規模に処理する方法について説明します。

00:21:14.000 --> 00:21:19.000
今、光線をシーンと交差させる時が来ました。

00:21:19.000 --> 00:21:24.000
Metalでは、コマンドの一部として実行されるGPU関数で光線を交差させます。

00:21:24.000 --> 00:21:35.000
Apple Siliconでは、計算コマンドとレンダリングコマンドの両方で光線を交差させることができ、AMDとIntelでは計算コマンドで光線を交差させることができます。

00:21:35.000 --> 00:21:41.000
光線を交差させる準備をするには、加速構造をコマンドエンコーダにバインドします。

00:21:41.000 --> 00:21:47.000
これで、GPU機能でこの加速構造と光線を交差させることができます。

00:21:47.000 --> 00:21:54.000
加速度構造パラメータで関数を宣言し、セクター間オブジェクトを作成します。

00:21:54.000 --> 00:22:00.000
このインターセクターにプロパティを設定して、最高のパフォーマンスのためにレイ交差を設定できます。

00:22:00.000 --> 00:22:12.000
光線とシーンを交差させるには、光線を作成し、インターセクターオブジェクトの交差メソッドを呼び出すだけで、光線と加速度構造をパラメータとして渡します。

00:22:12.000 --> 00:22:24.000
これは、交差する光線のプリミティブの種類、交差点までの距離、プリミティブのIDなど、交差点について知る必要があるすべてを返します。

00:22:24.000 --> 00:22:32.000
三角形の交点に関する詳細情報を取得するには、インターセクタータイプと「交差結果」タイプに「三角形データ」タグを追加します。

00:22:32.000 --> 00:22:39.000
これにより、三角形の重心座標が交差結果で利用可能になります。

00:22:39.000 --> 00:22:44.000
それは、原始的な加速構造と交差する光線をカバーしています。

00:22:44.000 --> 00:22:50.000
交差する光線とインスタンス加速度構造は非常によく似ています。

00:22:50.000 --> 00:23:07.000
インスタンスアクセラレーション構造を、プリミティブアクセラレーション構造をバインドするのと同じ方法でバインドし、useResourceまたはuseHeapを呼び出すようにして、インスタンスアクセラレーション構造で参照されるアクセラレーション構造をGPUで使用できるようにします。

00:23:07.000 --> 00:23:16.000
レイとインスタンスアクセラレーション構造と交差するには、GPU機能にいくつかの変更を加えるだけで済みます。

00:23:16.000 --> 00:23:21.000
まず、加速度構造タイプにインスタンスタグを追加します。

00:23:21.000 --> 00:23:27.000
次に、インスタンシングタグと「最大レベル」タグをインターセクターと「インターセクション結果」に追加します。

00:23:27.000 --> 00:23:34.000
「最大レベル」タグは、加速構造のインスタンス化レベルの数を指定します。

00:23:34.000 --> 00:23:42.000
例えば、モアナ島のシーンを表す加速構造は、3段階の加速構造です。

00:23:42.000 --> 00:23:47.000
最初のレベルは、シーン全体を含むインスタンスアクセラレーション構造です。

00:23:47.000 --> 00:23:52.000
2番目のレベルには、サンゴ、木、地形の例があります。

00:23:52.000 --> 00:23:58.000
3番目のレベルには、葉、花、幹などの木の部分の例があります。

00:23:58.000 --> 00:24:06.000
光線がこのシーンと交差すると、プリミティブだけでなく、プリミティブを含むインスタンスも交差します。

00:24:06.000 --> 00:24:15.000
光線がこの木の葉と交差する場合、木のインスタンスと木の葉のインスタンスも交差します。

00:24:15.000 --> 00:24:21.000
メタルは、交差する各インスタンスのIDを記録することで、これを追跡します。

00:24:21.000 --> 00:24:32.000
この場合、最初の交差するインスタンスはIDが6のツリーで、2番目の交差するインスタンスはIDが1のリーフです。

00:24:32.000 --> 00:24:35.000
光線は1つのインスタンスだけと交差することもできる。

00:24:35.000 --> 00:24:42.000
たとえば、レイが地形と交差する場合、Metalは地形インスタンスのIDのみを記録します。

00:24:42.000 --> 00:24:50.000
交差したインスタンスの数と交差したインスタンスのIDは、交差結果で確認できます。

00:24:50.000 --> 00:24:57.000
それが、原始的な加速構造やインスタンス加速構造と光線を交差させる方法です。

00:24:57.000 --> 00:25:01.000
曲線プリミティブを使用する際に留意すべき点がいくつかあります。

00:25:01.000 --> 00:25:08.000
デフォルトでは、Metalは、レイ交差を実行するときに曲線プリミティブを使用していないことを前提としています。

00:25:08.000 --> 00:25:15.000
インターセクターオブジェクトにジオメトリタイプを設定することで、曲線を使用していることをMetalに伝えることができます。

00:25:15.000 --> 00:25:19.000
ジオメトリタイプを設定したら、曲線を交差させる準備が整いました。

00:25:19.000 --> 00:25:24.000
以前と同様に、交差点結果の交差点に関する情報を見つけます。

00:25:24.000 --> 00:25:31.000
「曲線データ」タグを使用すると、交差結果には曲線パラメータも含まれます。

00:25:31.000 --> 00:25:38.000
これは、曲線の基底関数に差し込んで、光線と交差する曲線に沿った点を計算できる値です。

00:25:38.000 --> 00:25:43.000
これらの機能は、メタルシェーディング言語で実装されています。

00:25:43.000 --> 00:25:47.000
メタルシェーディング言語の仕様で詳細を学ぶことができます。

00:25:47.000 --> 00:25:52.000
多くのアプリケーションでは、曲線ジオメトリは1種類の曲線で表されます。

00:25:52.000 --> 00:25:59.000
たとえば、シーン内のすべての曲線は、円形の断面を持つ立方体ベジエ曲線として表現される場合があります。

00:25:59.000 --> 00:26:08.000
この場合、セクター間オブジェクトに曲線のプロパティを設定することで、シーンが使用する曲線の種類をMetalに伝えることができます。

00:26:08.000 --> 00:26:12.000
これにより、カーブプリミティブを使用する際に最高のパフォーマンスを得ることができます。

00:26:12.000 --> 00:26:16.000
それがあなたのシーンと光線を交差させる方法です。

00:26:16.000 --> 00:26:22.000
また、Xcodeを使用して、レイトレーシングワークロードをデバッグおよびプロファイルすることができます。

00:26:22.000 --> 00:26:27.000
デバッグが難しい問題に対処する際に使用できるツールの1つは、シェーダーバリデーションです。

00:26:27.000 --> 00:26:35.000
シェーダーでランタイムチェックを実行し、クラッシュや破損につながる可能性のある問題をキャッチします。

00:26:35.000 --> 00:26:41.000
シェーダー検証は、最新のレイトレーシング機能を含むすべてのMetal APIをカバーするようになりました。

00:26:41.000 --> 00:26:47.000
さらに、シェーダー検証により、シェーダーのコンパイル時間への影響が大幅に減少しました。

00:26:47.000 --> 00:26:55.000
これは、レイトレーシングアプリケーションで一般的に見られるような、長くて複雑なシェーダーで作業しているときに非常に役立ちます。

00:26:55.000 --> 00:27:00.000
あなたを助けることができるもう1つのツールは、最先端の加速構造ビューアです。

00:27:00.000 --> 00:27:04.000
これにより、交差点テストに使用するシーンを検査できます。

00:27:04.000 --> 00:27:16.000
加速構造ビューアを開くと、加速構造の個々のビルディングブロックをジオメトリプリミティブまでナビゲートするためのアウトラインが左側にあります。

00:27:16.000 --> 00:27:21.000
ここでは、三角形のジオメトリを構成する個々の三角形をリストします。

00:27:21.000 --> 00:27:29.000
右側にはビューポートがあり、さまざまなハイライトモードで加速構造を検査できます。

00:27:29.000 --> 00:27:41.000
たとえば、「Axis-Aligned Bounding Box Traversals」ハイライトモードは、より高価な交差点テストに対応する、より深いレベルのトラバーサルを持つ領域を視覚化できます。

00:27:41.000 --> 00:27:50.000
シーンの上にポインタを移動すると、インスペクターは光線が尖った方向に当たる交差点の数を更新します。

00:27:50.000 --> 00:27:53.000
もう1つの例は、加速構造のハイライトモードです。

00:27:53.000 --> 00:27:58.000
これは、加速構造をさまざまな色で視覚化します。

00:27:58.000 --> 00:28:04.000
加速構造ビューアは、新しいマルチレベルインスタンシング機能と曲線ジオメトリをサポートしています。

00:28:04.000 --> 00:28:13.000
ビューポートでカメラを動かすと、いくつかの木のインスタンス加速構造といくつかの葉の曲線を見つけることができます。

00:28:13.000 --> 00:28:20.000
加速度構造を識別するには、ビューポートをクリックしてアウトラインに表示できます。

00:28:20.000 --> 00:28:25.000
さて、これらのヤシの葉の加速構造を詳しく見てみましょう。

00:28:25.000 --> 00:28:30.000
この加速構造では、ヤシの葉は曲線で構成されています。

00:28:30.000 --> 00:28:36.000
ビューポートをプリミティブハイライトモードに変更して、カーブセグメントを視覚化できます。

00:28:36.000 --> 00:28:41.000
カーブセグメントをよりよく検査するために、少しズームインします。

00:28:41.000 --> 00:28:48.000
先ほどのシーンで加速構造を選択するのと同様に、ここでは、クリックして各セグメントを選択できます。

00:28:48.000 --> 00:28:54.000
レイトレーシングワークロードを調べる際のもう1つの便利なツールは、シェーダーデバッガーです。

00:28:54.000 --> 00:28:58.000
これは、シェーダーコードの問題のトラブルシューティングに役立ちます。

00:28:58.000 --> 00:29:03.000
ここでは、シェーダーで交差テストを実行するコンピューティングディスパッチにいます。

00:29:03.000 --> 00:29:13.000
シェーダーのデバッグを開始するには、シェーダーデバッグボタンを押し、ポップオーバーでスレッドを選択し、デバッグボタンをクリックします。

00:29:13.000 --> 00:29:21.000
データの収集が完了したら、シェーダー実行中の任意の時点で各変数の値を調べることができます。

00:29:21.000 --> 00:29:25.000
プリミティブIDの値を詳しく見てみましょう。

00:29:25.000 --> 00:29:31.000
より多くのデバッグコンテキストを提供するために、Shader Debuggerは近隣のスレッドからのデータも提供します。

00:29:31.000 --> 00:29:39.000
ここでは、値ビューにポインタを合わせると、同じスレッドグループのプリミティブIDを検査できます。

00:29:39.000 --> 00:29:43.000
パフォーマンスは、あらゆるアプリのもう1つの重要な側面です。

00:29:43.000 --> 00:29:54.000
プロファイリングタイムラインは、レイトレーシングワークロードのパフォーマンスの概要を提供し、さまざまなパフォーマンスメトリックを並べて検査して関連付けることができます。

00:29:54.000 --> 00:30:00.000
さらに、デバッグナビゲーターを変更して、ワークロード内のすべてのパイプライン状態を表示できます。

00:30:00.000 --> 00:30:08.000
また、シェーダープロファイリングデータを使用すると、ナビゲーターは最も高価なパイプラインの状態を上部に一覧表示します。

00:30:08.000 --> 00:30:12.000
パイプライン状態をさらに拡張すると、シェーダーコードが明らかになります。

00:30:12.000 --> 00:30:22.000
シェーダーを開いた後、個々のシェーダーが実行時間をどこでどのように費やすかについて、行ごとのシェーダープロファイリングの洞察を得ることができます。

00:30:22.000 --> 00:30:31.000
サイドバーのパイチャートの上にポインタを移動すると、そのコード行のコストのより詳細な内訳を含むポップオーバーが表示されます。

00:30:31.000 --> 00:30:42.000
これらのツールは、Metalの新しいレイトレーシング機能をすべてサポートし、Metalアプリで作業しているときに優れたデバッグとプロファイリングの補助を提供できます。

00:30:42.000 --> 00:31:02.000
メタルレイトレーシングは、プロダクションレンダラーでシーンをアニメーション化するためのプリミティブおよびインスタンスモーション、カスタム交差機能、アルファテストなどの機能強化によるレイ交差のカスタマイズ、クエリベースのAPIからの移植性のための交差クエリなど、さらに多くの機能もサポートしています。

00:31:02.000 --> 00:31:10.000
Metal Ray Tracing API、Language、Toolsは、ゲームやプロダクションレンダラーなどのリアルタイムレンダリングアプリをサポートしています。

00:31:10.000 --> 00:31:19.000
最新のメタルレイトレーシングAPIを使用して、曲線のようなジオメトリを含む原始的な加速構造を使用してシーンを構築できます。

00:31:19.000 --> 00:31:28.000
インスタンス化、特に新しいマルチレベルのインスタンス化機能により、より大きく、より複雑なシーンに拡張できます。

00:31:28.000 --> 00:31:33.000
GPU関数は、Metal Ray Tracing APIを直接呼び出すことができます。

00:31:33.000 --> 00:31:38.000
そして最後に、Xcodeはアプリのデバッグとプロファイリングに役立ちます。

00:31:38.000 --> 00:31:48.000
これらのトピックの多くと、サンプルコードとドキュメントをより詳細に取り上げた以前のレイトレーシングトークを必ずチェックしてください。

00:31:48.000 --> 00:31:50.000
見てくれてありがとう。

00:31:50.000 --> 23:59:59.000
♪ ♪

