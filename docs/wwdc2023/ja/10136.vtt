WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:11.000
クリストファー:こんにちは、ようこそ!

00:00:11.000 --> 00:00:15.000
私の名前はクリストファーで、ScreenCaptureKitチームのソフトウェアエンジニアです。

00:00:15.000 --> 00:00:24.000
同僚のナタリー・リンゼイが参加し、アプリケーションのスクリーンキャプチャ機能を強化する新機能を紹介します。

00:00:24.000 --> 00:00:31.000
ScreenCaptureKitは、アプリケーションの画面共有体験を作成するために、macOS 12.3で導入されました。

00:00:31.000 --> 00:00:43.000
ScreenCaptureKitは、共有したいコンテンツをカスタマイズできるAPIと、アプリケーションのニーズに合ったコントロールを提供し、そのすべてをストリームに動的に適用できます。

00:00:43.000 --> 00:00:54.000
このフレームワークは、グローバルなセーフガードでプライバシーを念頭に置きながら、ディスプレイのネイティブ解像度とフレームレートまでのパフォーマンスに焦点を当てた高品質のコンテンツを提供します。

00:00:54.000 --> 00:00:59.000
今年、ScreenCaptureKitは、新しいmacOS機能と統合するいくつかの開発者APIを提供します。

00:00:59.000 --> 00:01:08.000
プレゼンターオーバーレイは、キャプチャされたコンテンツに自分自身を埋め込むことで、画面共有やプレゼンテーションをより個人的なものにできる機能です。

00:01:08.000 --> 00:01:14.000
新しい画面共有ピッカーを使用すると、画面共有でキャプチャした内容にシステム全体のエクスペリエンスを統合できます。

00:01:14.000 --> 00:01:24.000
最後に、スクリーンキャプチャはライブストリームだけでなく、今年は、選択したコンテンツの高解像度スクリーンショットをキャプチャできる新しいAPIがあります。

00:01:24.000 --> 00:01:28.000
人々は世界中で毎日交流しています。

00:01:28.000 --> 00:01:32.000
これらの相互作用は、私たちの考えやアイデアを共有し、重要な問題を解決する場所です。

00:01:32.000 --> 00:01:35.000
彼らはプロフェッショナルで個人的です。

00:01:35.000 --> 00:01:40.000
この目的のために、あなたのアプリはプレゼンターオーバーレイと呼ばれる新しいビデオエフェクトでシームレスに動作することができます。

00:01:40.000 --> 00:01:50.000
コンテンツを共有するとき、プレゼンターオーバーレイは、共有コンテンツの上にプレゼンターを含めることでプレゼンターの存在感を高め、より生産的なリモートコールのための個人的なタッチを追加します。

00:01:50.000 --> 00:02:03.000
小さなオーバーレイは、高度なセグメンテーションアルゴリズムのおかげで、プレゼンターを可動ウィンドウに配置し、大きなオーバーレイはプレゼンターの顔と体を背景から分離し、より没入感のある効果のためにそれらの間に画面コンテンツを重ねます。

00:02:03.000 --> 00:02:08.000
プレゼンターオーバーレイは、ScreenCaptureKitを使用するすべてのアプリケーションで利用できます。

00:02:08.000 --> 00:02:21.000
作成されたSCStreamごとに、ScreenCaptureKitは画面共有ピッカーに通知し、ストリームのコントロールを含むライブプレビューが新しいビデオメニューバー項目に表示されます。

00:02:21.000 --> 00:02:29.000
ビデオメニューバーには、アクティブなストリームを持つすべてのアプリケーションが表示され、任意のアプリケーションに関連付けられたストリームのライブプレビューが表示されます。

00:02:29.000 --> 00:02:36.000
このメニューバーから、ストリーム全体の画面共有ピッカーを表示することで、ストリームコンテンツを制御できます。

00:02:36.000 --> 00:02:43.000
これは、プレゼンターオーバーレイが有効になっている場所でもあり、カメラフレームをコンテンツストリームに埋め込みます。

00:02:43.000 --> 00:02:49.000
また、これを使用して、画面共有を置き換えたり終了したりするなど、ストリームを制御することもできます。

00:02:49.000 --> 00:02:55.000
ここには、カメラとマイクの効果をカスタマイズするための他の便利な機能があります。

00:02:55.000 --> 00:03:01.000
ScreenCaptureKitとカメラを一緒に使用するすべてのアプリケーションは、これらの機能を自動的に機能させます。

00:03:01.000 --> 00:03:06.000
現在、ストリームにはScreenCaptureKitからプロセスに送信されたコンテンツフレームがあります。

00:03:06.000 --> 00:03:15.000
これで、アプリケーションがアクティブなストリーム中にカメラの使用を開始すると、プレゼンターオーバーレイがビデオメニュー項目で利用可能になります。

00:03:15.000 --> 00:03:22.000
有効にすると、ScreenCaptureKitはカメラを取り、アプリケーションがすでに実行されている選択したストリームにレンダリングを適用します。

00:03:22.000 --> 00:03:26.000
アクティブなストリームから合成フレームが自動的に取得されます。

00:03:26.000 --> 00:03:31.000
では、プレゼンターオーバーレイがいつ適用されたかを明示的に知りたい場合はどうなりますか?

00:03:31.000 --> 00:03:35.000
新しいストリームを作成し、自己をデリゲートとして追加することから始めましょう。

00:03:35.000 --> 00:03:42.000
次に、SCStream、outputEffectDidStartに新しいデリゲートコールバックを実装します。

00:03:42.000 --> 00:03:46.000
これは、プレゼンターオーバーレイが適用されたときに通知される方法です。

00:03:46.000 --> 00:03:51.000
通知されたら、効果が開始されたか停止したかを確認したいと思う。

00:03:51.000 --> 00:04:00.000
プレゼンターオーバーレイは、新しいmacOSシステム機能であり、オーバーレイが適用されたときにアプリケーションが取りたいと思ういくつかの考慮事項があります。

00:04:00.000 --> 00:04:06.000
プレゼンターオーバーレイをオンにすると、AVCaptureSessionは一般的なライブカメラストリームを送信しません。

00:04:06.000 --> 00:04:10.000
それは、あなたのカメラがオーバーレイで直接使用されるからです。

00:04:10.000 --> 00:04:15.000
これは、この変更を考慮してアプリケーションUIを更新する絶好の機会です。

00:04:15.000 --> 00:04:23.000
たとえば、ビデオ会議アプリケーションは、共有コンテンツがカメラと混在していることを考慮して、オーディオとビデオの同期を調整したい場合があります。

00:04:23.000 --> 00:04:28.000
また、より最適化された外観のために、プレゼンターのカメラタイルを非表示にすることもできます。

00:04:28.000 --> 00:04:35.000
プレゼンターオーバーレイはカメラとビデオ機能なので、アプリケーションはより高いフレームレートのために最適化する必要があります。

00:04:35.000 --> 00:04:47.000
プレゼンターオーバーレイに加えて、新しいシステム全体の画面共有ピッカーを利用することもできます。これにより、アプリケーションは、ユーザーが共有したいコンテンツを選択する方法を中心としたいくつかの機能と完全に統合できます。

00:04:47.000 --> 00:04:51.000
これらは、ストリームの作成に使用する一般的な構造です。

00:04:51.000 --> 00:04:57.000
現在、SCSharableContentに電話して、共有できる利用可能なすべての画面コンテンツを取得します。

00:04:57.000 --> 00:05:00.000
それを使用してSCContentFilterを作成します。

00:05:00.000 --> 00:05:05.000
SCContentFilterは、キャプチャするものを決定するために使用するものです。

00:05:05.000 --> 00:05:13.000
現在、あなたはそれをSCSharableContentから構築していますが、今年はピッカーを通じてコンテンツフィルターを取得できます。

00:05:13.000 --> 00:05:16.000
ピッカーがSCContentFiltersを生成するには2つの方法があります。

00:05:16.000 --> 00:05:20.000
まず、目的のコンテンツはシステムピッカーを通じて共有できます。

00:05:20.000 --> 00:05:25.000
第二に、コンテンツは開いているウィンドウから直接選択できます。

00:05:25.000 --> 00:05:30.000
どちらの場合も、システムはSCContentFilterをアプリケーションと共有します。

00:05:30.000 --> 00:05:34.000
しかし、どのようにして新しいコンテンツフィルターをアプリケーションに取り込むのですか?

00:05:34.000 --> 00:05:38.000
新しいAPI、SCContentSharingPickerを使用することで。

00:05:38.000 --> 00:05:51.000
SCContentSharingPickerは、アプリケーションとOSの間のインターフェイスとして機能し、新しいストリームリクエスト、新しいコンテンツフィルタ、現在のストリームとコンテンツフィルタの更新をアプリケーションにデリゲートコールバックします。

00:05:51.000 --> 00:06:00.000
SCContentSharingPickerには、ウィンドウ、アプリ、さらにはディスプレイに基づいてコンテンツを選択できるシステムレベルのコンテンツピッカーが組み込まれています。

00:06:00.000 --> 00:06:16.000
アプリケーションのボタン、新しいビデオメニューバー、またはウィンドウから直接コンテンツの選択を開始するかどうかにかかわらず、アプリケーションはSCContentSharingPickerを利用して、進行中のストリームのアクティブな選択を追加、削除、または置き換えることができます。

00:06:16.000 --> 00:06:24.000
また、新しいストリームがいつ要求されるかをアプリケーションが知ることができるストリームリクエストコールバックも組み込まれています。

00:06:24.000 --> 00:06:31.000
そして最後に、ストリームごとのカスタマイズが付属しており、システムエクスペリエンスが各ストリームにどのように適用されるかを定義できます。

00:06:31.000 --> 00:06:44.000
SCStreamのフィルタを取得するための構造は、SCSharableContentの使用から、SCContentSharingPickerシングルトンを使用したシステムピッカーインターフェイスを使用してSCContentFilterを渡すようになりました。

00:06:44.000 --> 00:06:50.000
アプリケーションがこの新しい画面共有ピッカーを利用するのがいかに簡単かをお見せしましょう。

00:06:50.000 --> 00:06:58.000
SCContentSharingPickerの共有インスタンスから始めて、selfをオブザーバーとして追加して、すべての適切なクラスコールバックを取得できます。

00:06:58.000 --> 00:07:03.000
システムが私のピッカーインスタンスを認識するには、アクティブに設定します。

00:07:03.000 --> 00:07:11.000
アクティブになると、システムはピッカーについて知り、アプリケーションはシステムUIに含まれ、人々はそれと対話できるようになります。

00:07:11.000 --> 00:07:21.000
人々がピッカーを介してウィンドウを選択できるストリームを作成したいので、singletonメソッドpicker.presentを呼び出し、nilと提示したいピッカーのスタイルをパスします。

00:07:21.000 --> 00:07:28.000
ユーザーがUIボタンを押すと、ピッカーが表示され、キャプチャしたいウィンドウを選択できます。

00:07:28.000 --> 00:07:34.000
そのコンテンツが選択されると、新しいフィルタのオブザーバーコールバックを介して通知されます。

00:07:34.000 --> 00:07:40.000
そして、新しいストリームを作成したり、このフィルターを使用して既存のストリームを更新したりできるようになりました。

00:07:40.000 --> 00:07:43.000
残りのオブザーバーコールバックも同様に重要です。

00:07:43.000 --> 00:07:47.000
ピッカーをアクティブにして提示することで、ピッカーを再度設定します。

00:07:47.000 --> 00:07:51.000
また、提示を依頼したときにピッカーが失敗したかどうかも知りたいでしょう。

00:07:51.000 --> 00:07:57.000
失敗した場合は、アプリケーションに通知を投稿して人々に通知する必要があります。

00:07:57.000 --> 00:08:06.000
また、ピッカーが提示されたがキャンセルされた場合、つまりコンテンツが選択されなかった場合は、それに応じてストリームの状態を設定する必要があります。

00:08:06.000 --> 00:08:13.000
SCContentSharingPickerには、ストリームごとのレベルでシステムがどのように動作するかをカスタマイズできるメソッドも付属しています。

00:08:13.000 --> 00:08:18.000
SCContentSharingPickerConfigurationでは、いくつかのカスタマイズが可能です。

00:08:18.000 --> 00:08:27.000
AllowedPickingModesは、ウィンドウ、アプリケーション、およびコンテンツフィルタの表示選択の間でどのピッキングモードが許可されているかをシステムに伝えます。

00:08:27.000 --> 00:08:35.000
また、システムエクスペリエンスで選択できない除外WindowIDとbundleIDの明示的な宣言も可能です。

00:08:35.000 --> 00:08:42.000
ユーザーが変更したくないストリームがある場合、SCContentSharingPickerConfigurationにはその機能を強制できるプロパティがあります。

00:08:42.000 --> 00:08:45.000
まず、共有ピッカーインスタンスを取得します。

00:08:45.000 --> 00:08:49.000
自己をオブザーバーとして追加し、ピッカーをアクティブに設定することから始めます。

00:08:49.000 --> 00:08:52.000
次に、適切な構成設定を設定します。

00:08:52.000 --> 00:08:59.000
このストリームでは、2つの特定のアプリケーションの選択を除外し、再選択を許可したくないかもしれません。

00:08:59.000 --> 00:09:07.000
設定が設定されたら、ピッカーで設定設定を呼び出し、設定とアプリケーティブストリームを渡します。

00:09:07.000 --> 00:09:11.000
これで、ピッカーは特定のストリームに対してどのように振る舞うかを正確に知ることができます。

00:09:11.000 --> 00:09:19.000
また、各ストリームは、アプリケーションのニーズに合わせて異なるピッカー構成を持つ可能性があることに注意してください。

00:09:19.000 --> 00:09:28.000
要約すると、すべてのScreenCaptureKitストリームがmacOSエクスペリエンスに統合され、どのアプリケーションでもプレゼンターオーバーレイなどの新機能を活用できるようになりました。

00:09:28.000 --> 00:09:36.000
そして、アプリケーションを新しいシステムピッカーUIに統合するための新しいAPIであるSCContentSharingPickerを紹介しました。

00:09:36.000 --> 00:09:44.000
しかし、アプリケーションでの画面キャプチャはライブストリームだけではないので、この新しいスクリーンショットAPIについてもっと話すために、同僚のナタリーに渡したいと思います。

00:09:44.000 --> 00:09:45.000
ナタリー:ありがとう、クリストファー。

00:09:45.000 --> 00:09:52.000
今年は、ScreenCaptureKitに新しいAPIがあり、画面から静止画を簡単に取得できるように設計されています。

00:09:52.000 --> 00:09:57.000
新しいスクリーンショットAPIは、スクリーンショットにScreenCaptureKitストリーミングの利点をもたらします。

00:09:57.000 --> 00:10:07.000
アプリやウィンドウによる高度なフィルタリング、複数のピクセルフォーマットや色空間、カーソルの可視性などの他のオプションなどの機能が利用できます。

00:10:07.000 --> 00:10:16.000
これで、使い慣れたScreenCaptureKit構造を使用して、必要な正確な画面コンテンツの画像を効率的に取得できるようになります。

00:10:16.000 --> 00:10:19.000
新しいAPIは非同期です。

00:10:19.000 --> 00:10:25.000
出力画像では、CMSampleBufferまたはCGImage形式から選択できます。

00:10:25.000 --> 00:10:32.000
CMSampleBufferオプションには、追加のピクセルフォーマットが利用可能で、特定のフォーマットに興味がある場合に最適です。

00:10:32.000 --> 00:10:38.000
コードでCGImageをすでに使用している場合は、この形式を使用すると統合が容易になります。

00:10:38.000 --> 00:10:49.000
どちらのフォーマットでも、スクリーンショットはScreenCaptureKitストリーミングとほぼ同じ構成オプションを使用し、同様のセットアップフローに従います。

00:10:49.000 --> 00:10:57.000
CGWindowListCreateImageを使用している場合、ScreenCaptureKitへの移行を容易にするものがいくつかあります。

00:10:57.000 --> 00:11:06.000
CGWindowList APIで利用可能なすべてのウィンドウ画像オプションは、ScreenCaptureKitのSCStreamConfigurationクラス内にあります。

00:11:06.000 --> 00:11:15.000
特定のウィンドウID上のすべてのウィンドウを取得するなど、ウィンドウリストのオプションは、SCShareableContent内で提供されます。

00:11:15.000 --> 00:11:25.000
また、CGImage出力での作業に慣れている場合、新しいスクリーンショットAPIは、既存のコードに簡単に統合できるCGImage出力形式を提供します。

00:11:25.000 --> 00:11:35.000
スクリーンショットを撮ることは、ScreenCaptureKitストリーミングと同様のフローに従いますが、SCStreamを作成する代わりに、スクリーンショットAPIを呼び出します。

00:11:35.000 --> 00:11:44.000
まず、ストリームの作成と同様に、SCShareableContentを使用して目的のコンテンツを取得し、SCContentFilterを作成します。

00:11:44.000 --> 00:11:50.000
スクリーンショットにすべてのオプションを使用してSCStreamConfigurationを設定することを忘れないでください。

00:11:50.000 --> 00:11:57.000
コンテンツフィルタとストリーム設定が完了したら、スクリーンショットAPIを呼び出すと、それらを渡します。

00:11:57.000 --> 00:12:07.000
APIはSCScreenshotManagerクラスのクラスメソッドであるため、スクリーンショットを撮るためにSCScreenshotManagerオブジェクトを作成する必要はありません。

00:12:07.000 --> 00:12:14.000
スクリーンショット画像の準備ができたら、選択した形式で非同期に返されます。

00:12:14.000 --> 00:12:20.000
また、新しいシステムピッカーを使用してコンテンツフィルタを作成し、それを使用してスクリーンショットAPIを呼び出すこともできます。

00:12:20.000 --> 00:12:27.000
これは、人々が直感的な方法で必要なコンテンツを選択できるようにする素晴らしい方法です。

00:12:27.000 --> 00:12:37.000
スクリーンショットを撮るときは、必要なものに応じて、APIの2つのバージョンから選択できます。1つはCMSampleBuffer出力タイプ用、もう1つはCGImage出力タイプ用です。

00:12:37.000 --> 00:12:44.000
それ以外は、2つのバージョンは同じように動作し、スクリーンショットを非同期に返します。

00:12:44.000 --> 00:12:48.000
以下は、スクリーンショットAPIの使用方法のコード例です。

00:12:48.000 --> 00:12:53.000
SCContentFilterとSCStreamConfigurationを設定することから始めます。

00:12:53.000 --> 00:12:59.000
それらの準備ができたら、スクリーンショットAPIを呼び出すことができ、それが戻ってくるのを待つと、スクリーンショットを取得します。

00:12:59.000 --> 00:13:02.000
そして、それがScreenCaptureKitの新機能のすべてです。

00:13:02.000 --> 00:13:13.000
要約すると、システムレベルのUIを使用してアプリケーションと完全に統合された画面共有エクスペリエンスを作成するSCContentFiltersを作成する新しいAPIがあります。

00:13:13.000 --> 00:13:24.000
新しいプレゼンターオーバーレイビデオエフェクトは、よりダイナミックな画面共有体験を提供し、新しいスクリーンショットAPIを使用すると、ScreenCaptureKitの力で1回限りのスクリーンキャプチャを取得できます。

00:13:24.000 --> 00:13:33.000
ScreenCaptureKitの詳細については、昨年のセッション「Meet ScreenCaptureKit」と「ScreenCaptureKitを次のレベルに引き上げる」を必ずチェックしてください。

00:13:33.000 --> 23:59:59.000
見てくれてありがとう。

