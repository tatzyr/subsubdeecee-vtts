WEBVTT

00:00:00.000 -> 00:00:10.000
♪ ♪

00:00:10.000 -> 00:00:16.000
アラ：こんにちは、私の名前はアラ・シャシュキナで、国際化チームのエンジニアです。

00:00:16.000 -> 00:00:18.000
私はあなたの言語を手伝うためにここにいます。

00:00:18.000 -> 00:00:22.000
今日、私たちは文法的合意の力を解き放ちます。

00:00:22.000 -> 00:00:25.000
ソフトウェアの言語は、それとの日常的な相互作用に影響を与えます。

00:00:25.000 -> 00:00:28.000
アプリの単語は重要です。

00:00:28.000 -> 00:00:34.000
ソフトウェアで言語を扱うことは、特にその言語を話さない場合、難しい場合があります。

00:00:34.000 -> 00:00:41.000
2021年には、アプリの文法的合意に役立つ新しいAPIをFoundationに導入しました。

00:00:41.000 -> 00:00:56.000
今日は、文法的により正しく、より良い響き、より包括的な自然言語を通じて、アプリの異なるレベルのユーザーエクスペリエンスのロックを解除するFoundationの新機能を紹介したいと思います。

00:00:56.000 -> 00:00:59.000
では、飛び込みましょう。

00:00:59.000 -> 00:01:04.000
文法的な合意を扱うことが重要であると考える理由の非常に短い要約から始めます。

00:01:04.000 -> 00:01:11.000
2021年以降にサポートを追加した言語で、さまざまな例を紹介します。

00:01:11.000 -> 00:01:17.000
文法的な合意空間で新しいAPIについて話し、依存関係合意を導入します。

00:01:17.000 -> 00:01:27.000
私たちはさらに一歩進んで、アプリの言語をより文法的に正しいだけでなく、より包括的にするにはどうすればよいかと自問しました。

00:01:27.000 -> 00:01:32.000
文法は、アプリを構築するときに心配すべきものではありません。

00:01:32.000 -> 00:01:38.000
私たちは、うまく設計されたAPIが言語の複雑さを緩和し、拡張に役立つと信じています。

00:01:38.000 -> 00:01:45.000
UIの豊かで文法的に正しい単語は、ユーザーエクスペリエンスを完璧で楽しいものにします。

00:01:45.000 -> 00:01:48.000
異なる言語は、独自の課題を提示します。

00:01:48.000 -> 00:01:55.000
この言語の複雑さはすべて、新しいAPIを設計する際に考慮するものです。

00:01:55.000 -> 00:02:01.000
私たちの目標は、そのすべてをシンプルで使いやすいインターフェースに詰め込むことです。

00:02:01.000 -> 00:02:07.000
文法的合意がさまざまな言語でシステム全体のユーザーエクスペリエンスをどのように向上させるかを簡単に見てみましょう。

00:02:07.000 -> 00:02:19.000
2021年に導入された新しいAPIでは、ユーザーの優先アドレス用語と、屈折可能な範囲内の他の単語に基づいて変更する必要がある単語の範囲を指定できます。

00:02:19.000 -> 00:02:29.000
ユーザーが女性的な住所用語を選択した場合、iPhoneは彼女が初めて電話を設定するときにスペイン語で女性的な設定で彼女に挨拶します。

00:02:29.000 -> 00:02:32.000
昨年、さらに3つの言語がスペイン語に加わりました。

00:02:32.000 -> 00:02:39.000
フランス語を話すユーザーは、住所の用語を選択すると、よりパーソナライズされた体験を楽しむことができます。

00:02:39.000 -> 00:02:46.000
システム全体のソフトウェアは、Notesアプリのこの例のように、それを反映するように単語を変更します。

00:02:46.000 -> 00:02:50.000
パーソナライズされた文字列は、システムエクスペリエンス全体に浸透しています。

00:02:50.000 -> 00:03:03.000
電話の設定、共有メモの操作、またはカレンダーの管理、言語は、イタリア語またはブラジルポルトガル語で、ここと同じように、あなたの設定に合わせて適応しています。

00:03:03.000 -> 00:03:12.000
今年は、ヨーロッパのポルトガル語とドイツ語の2つの新しいロケールに文法合意のサポートを追加しました。

00:03:12.000 -> 00:03:17.000
さて、今年の財団の文法合意の新機能について話しましょう。

00:03:17.000 -> 00:03:21.000
言語は複雑ですが、優れたAPIはそうではありません。

00:03:21.000 -> 00:03:26.000
多くの場合、UI内の単語は別の単語に基づいて形式を変更する必要があります。

00:03:26.000 -> 00:03:32.000
あなたがそれを視覚化するのを助けるために、私たちの食品注文アプリの例をご案内しましょう。

00:03:32.000 -> 00:03:33.000
これはスペイン語です。

00:03:33.000 -> 00:03:38.000
スペイン語では、形容詞は彼らが説明する名詞と一致する必要があります。

00:03:38.000 -> 00:03:44.000
ここでは、食品サイズ「pequeño」は、それが「ensalada」と説明する食品と一致する必要があります。

00:03:44.000 -> 00:03:52.000
これは、スピーチの特定の部分間で単語の一致が起こる他の言語でも非常に一般的なユースケースです。

00:03:52.000 -> 00:03:57.000
そして、これらの単語はUIで分離されているため、この種の契約を処理するのは簡単ではありません。

00:03:57.000 -> 00:04:03.000
このタイプの依存関係契約を簡単に修正する新しいAPIを作成しました。

00:04:03.000 -> 00:04:08.000
修正は非常に簡単で、コードの変更はほとんど必要ありません。

00:04:08.000 -> 00:04:15.000
ここでは、食品名「ensalada」と一致するために、食品サイズ「pequeño」を含む文字列が欲しい。

00:04:15.000 -> 00:04:28.000
今年は、LocalizationOptionsの概念に新しいプロパティを導入します。これにより、文法的合意に影響を与えるオブジェクトを指定できますが、引数のように文字列にフォーマットされていません。

00:04:28.000 -> 00:04:35.000
同意したい文字列値、この場合は「ensalada」にlocalizedPhraseの概念を使用します。

00:04:35.000 -> 00:04:42.000
最後に、conceptWithConceptで抑揚が必要な単語に注釈を付ける必要があります。

00:04:42.000 -> 00:04:49.000
ここでの値1は、概念配列の最初のオブジェクトとの文法的な合意を求めていることを意味します。

00:04:49.000 -> 00:04:52.000
1ベースのインデックス作成を使用することに注意してください。

00:04:52.000 -> 00:05:00.000
agreeWithConcept属性は今年も新しいですが、アプリが古いデバイスで実行されていても使用できます。

00:05:00.000 -> 00:05:04.000
その場合は、単に属性を無視します。

00:05:04.000 -> 00:05:10.000
これらの変更を導入したので、UIを見てみましょう。 では、UIを見てみましょう。

00:05:10.000 -> 00:05:14.000
「Pequeño」という言葉が「pequeña」に変わったことを観察してください。

00:05:14.000 -> 00:05:18.000
これは、スペイン語で「ensalada」を記述するときに使用する正しい形式です。

00:05:18.000 -> 00:05:25.000
それでは、言語の強化が必要な他の場所を見てみましょう。

00:05:25.000 -> 00:05:36.000
「私たちのサラダにはレタス、チーズ、トマト、ハムが含まれています」という文では、スペイン語の「nuestro」と「hecho」はどちらも名詞「ensalada」と一致する必要があります。

00:05:36.000 -> 00:05:43.000
幸いなことに、文字列内で文法的な合意を促進するだけでよいので、コードの変更は必要ありません。

00:05:43.000 -> 00:05:49.000
まず、inflect属性で注釈を付けて、「ニュエストロ」を食べ物に同意させましょう。

00:05:49.000 -> 00:05:57.000
引数を持つブロックでinflect属性を使用すると、すべての単語が文法的に引数と一致するようにします。

00:05:57.000 -> 00:06:02.000
しかし、「ヘチョ」という、私たちが屈折する必要があるもう1つの単語があります。

00:06:02.000 -> 00:06:10.000
曖昧さを助けるために、屈折ブロックをできるだけ短く保つようにしているので、屈折で「hecho」に注釈を付けることはできません: true。

00:06:10.000 -> 00:06:16.000
今年は、agreeWithArgumentという別の新しい属性を導入します。

00:06:16.000 -> 00:06:32.000
食品名の値を渡すことによってコードベースを変更する必要があるagreeWithConceptとは異なり、agreeWithArgument属性はコードの変更を必要とせず、inflect属性との合意を容易にする簡単な方法です。

00:06:32.000 -> 00:06:40.000
agreeWithArgumentを使用して、「hecho」が文字列内の他の場所にある引数に同意する必要があることを示すことができます。

00:06:40.000 -> 00:06:47.000
ここで、値1は、単語が文字列の最初の引数と一致するようにしたいことを意味します。

00:06:47.000 -> 00:06:54.000
これらの変更を加えたら、UIをもう一度見てみましょう。

00:06:54.000 -> 00:07:01.000
現在、両方の単語は「ensalada」と文法的に一致するようにフォーマットされており、ローカリゼーションで完全に正しいスペイン語を使用しています。

00:07:01.000 -> 00:07:06.000
次に、似ているが、まだ異なる例を見てみましょう。

00:07:06.000 -> 00:07:08.000
これはフランス語です。

00:07:08.000 -> 00:07:13.000
フランス語では、指示形容詞は、彼らが説明する名詞と一致する必要があります。

00:07:13.000 -> 00:07:24.000
agreeWithConceptとinflect属性を適用したため、サイズと数量のボタンはすでにスペイン語で固定されていることに注意してください。

00:07:24.000 -> 00:07:27.000
この実証的なケースをフランス語で修正しましょう。

00:07:27.000 -> 00:07:28.000
修正は本当に簡単です。

00:07:28.000 -> 00:07:36.000
形容詞と引数の両方を屈折：真のブロックでラップし、エンジンに魔法をかけさせます。

00:07:36.000 -> 00:07:41.000
出来上がり、文法的に正しい食べ物はちょうどより良い味がします。

00:07:41.000 -> 00:07:48.000
要約すると、依存関係契約は、彼らが依存する他の単語に基づいて単語を変更することを可能にします。

00:07:48.000 -> 00:07:57.000
単語が同じ文内に存在しない別の単語やフレーズに同意したい場合は、agreeWithConcept属性を使用します。

00:07:57.000 -> 00:08:07.000
単語が別の単語やフレーズに同意し、両方が同じ文字列にある場合は、adincreeWithArgument属性を使用します。

00:08:07.000 -> 00:08:12.000
それでは、インクルーシブ言語の新しいAPIについて話しましょう。

00:08:12.000 -> 00:08:15.000
カフェアプリをもう一度見てみましょう。 

00:08:15.000 -> 00:08:20.000
昼食に小さなサンドイッチと小さなジュースを選んで注文したとしましょう。

00:08:20.000 -> 00:08:24.000
私たちは本当にお腹が空いているので、配達状況を確認したいです。

00:08:24.000 -> 00:08:28.000
トニーはすぐに私たちの注文を配達するようです。

00:08:28.000 -> 00:08:33.000
ユーザーインターフェイスをローカライズするときは、ジェンダーニュートラルな言語を使用することをお勧めします。

00:08:33.000 -> 00:08:39.000
同時に、UIでジェンダー言語を使用することは、より個人的に感じられ、より自然に聞こえます。

00:08:39.000 -> 00:08:45.000
彼と彼の代名詞を使うトニーのために、この文字列をパーソナライズしてみましょう。

00:08:45.000 -> 00:08:51.000
まず、配達人のモデルを変更して、希望する住所期間を含める必要があります。

00:08:51.000 -> 00:08:58.000
それを表すために、今年新しいTermOfAddressタイプの新しいプロパティを追加します。

00:08:58.000 -> 00:09:04.000
次に、住所の用語を男性的、女性的、または中立のいずれかに設定できます。

00:09:04.000 -> 00:09:11.000
私たちはトニーに彼と彼の代名詞を使いたいので、男性を選びます。

00:09:11.000 -> 00:09:15.000
次に、代名詞を変更する必要がある文字列に注釈を付ける必要があります。

00:09:15.000 -> 00:09:20.000
これを行うには、新しい referentConcept 属性を使用します。

00:09:20.000 -> 00:09:27.000
値1は、代名詞の参照がLocalizationOptionsの最初の概念であるべきであることを示します。

00:09:27.000 -> 00:09:35.000
任意の三人称人称代名詞にreferentConceptを適用することができ、エンジンはそれを何に置き換えるかを把握します。

00:09:35.000 -> 00:09:40.000
それでは、文字列を反転させるときに、termsOfAddressの抑揚概念を渡しましょう。

00:09:40.000 -> 00:09:47.000
文法的な合意のために以前に行ったように、これをLocalizationOptionsの概念プロパティに割り当てます。

00:09:47.000 -> 00:09:52.000
これで英語のUIがどのように変わるか見てみましょう。

00:09:52.000 -> 00:09:57.000
「彼ら」と「彼ら」がどのように「彼」と「彼」に置き換えられたかに注目してください。

00:09:57.000 -> 00:10:01.000
同じローカライズされた文字列を使用して、他の人を参照することもできます。

00:10:01.000 -> 00:10:07.000
彼女と彼女の代名詞を使う人を参照したい場合は、女性用語のアドレスを使用してください。

00:10:07.000 -> 00:10:14.000
そして、彼らとそれらの代名詞を使用して誰かを参照したい場合は、中立的なアドレス用語を使用してください。

00:10:14.000 -> 00:10:19.000
ローカライズされた住所用語を使用して、代名詞をさらにパーソナライズすることもできます。

00:10:19.000 -> 00:10:26.000
ローカライズされた住所用語では、適用される言語、この場合は英語を指定する必要があります。

00:10:26.000 -> 00:10:33.000
そして、新しいMorphology.Pronounタイプを使用して使用したいすべての代名詞形式をリストします。

00:10:33.000 -> 00:10:37.000
英語では、5つの代名詞をリストアップする必要があります。

00:10:37.000 -> 00:10:44.000
各代名詞は、ターゲット言語の代名詞形式と、いつ使用すべきかを記述する形態で構成されています。

00:10:44.000 -> 00:10:50.000
代名詞の構築に関する詳細な手順については、ドキュメントを参照してください。

00:10:50.000 -> 00:10:55.000
このAPIを使用することは、アプリのパーソナライゼーションを強化する素晴らしい方法です。

00:10:55.000 -> 00:11:00.000
このテクニックを使用して、iOSのローカライズされた文字列で使用される言語を調整します。

00:11:00.000 -> 00:11:04.000
それでは、これらすべての新機能がデモでライブでどのように機能しているかをお見せしましょう。

00:11:04.000 -> 00:11:08.000
みんなが今、私たちのカフェアプリからおいしい食べ物に飢えていることを願っています。

00:11:08.000 -> 00:11:15.000
スペイン語で起動させてください。

00:11:15.000 -> 00:11:18.000
メニューに何があるか見てみましょう。

00:11:18.000 -> 00:11:23.000
今回はピザを注文しましょう。

00:11:23.000 -> 00:11:25.000
これは先ほど説明したのと同じ文法の問題です。

00:11:25.000 -> 00:11:30.000
スペイン語では、決定語と形容詞は名詞と一致する必要があります。

00:11:30.000 -> 00:11:35.000
2つの単語を互いに一致させるために、inflect:真の属性を使用できます。

00:11:35.000 -> 00:11:40.000
では、この簡単な修正を「ヌエストロ」と「ピザ」という言葉に適用しましょう。

00:11:40.000 -> 00:11:52.000
まず、この文字列を文字列カタログで見つけましょう。

00:11:52.000 -> 00:12:02.000
「Nuestro」を「ピザ」という議論に一致させるために、両方を屈折:真のブロックで囲みます。

00:12:02.000 -> 00:12:08.000
次に、同じ文で「ピザ」に同意する必要がある形容詞「hecho」も修正しましょう。

00:12:08.000 -> 00:12:12.000
ここでは、agreeWithArgument属性を使用したいと考えています。

00:12:12.000 -> 00:12:18.000
私たちは一般的に、曖昧さを助けるために、屈折:真のブロックをできるだけ短く保つようにしています。

00:12:18.000 -> 00:12:27.000
「hecho」は屈折ブロックから離れているため、今回は「agreeWithArgument」属性を使用する必要があります。

00:12:27.000 -> 00:12:35.000
ここでの1の値は、「hecho」が文字列の最初の引数、この場合は「pizza」に同意したいことを示しています。

00:12:35.000 -> 00:12:43.000
アプリをもう一度実行しましょう。

00:12:43.000 -> 00:12:48.000
さて、これはスペイン語での素晴らしいローカリゼーション体験のように見えます。

00:12:48.000 -> 00:12:55.000
それでは、新しいagreeWithConcept属性を使用して、ここで食品のサイズを修正する方法を見てみましょう。

00:12:55.000 -> 00:13:03.000
ピザは女性的なので、それを説明する形容詞は「pequeña」であるべきです。

00:13:03.000 -> 00:13:07.000
私たちはすでに食品サイズのローカライズされた名前を定義しました。

00:13:07.000 -> 00:13:16.000
契約を修正するために、localizedNamesを特定の食品と一致する方法に変換したいと考えています。

00:13:16.000 -> 00:13:22.000
次に、SIZE_BUTTONをフォーマットするときに食品名を渡します。

00:13:22.000 -> 00:13:27.000
ここでは、LocalizationOptions、コンセプトに新しいプロパティを定義します。

00:13:27.000 -> 00:13:35.000
概念は、文法的抑揚に影響を与えるオブジェクトですが、引数のように文字列に補間されません。

00:13:35.000 -> 00:13:45.000
ここでは、localizedPhraseの概念を使用して、文法的に同意したい文字列を挿入します。

00:13:45.000 -> 00:13:55.000
そして、文字列を初期化するときに定義されるオプションを使用することを忘れないでください。

00:13:55.000 -> 00:14:04.000
次に、スペイン語の文字列カタログを変更したいと思います。

00:14:04.000 -> 00:14:16.000
新しい属性agreeWithConceptでこれに注釈を付けたい。

00:14:16.000 -> 00:14:25.000
ここで1の値は、この引数がLocalizationOptionsに渡した最初の概念に同意したいことを示しています。

00:14:25.000 -> 00:14:35.000
最後に、ユーザーが必要なピザのサイズを選択するFoodSizeViewを新しい方法で更新しましょう。

00:14:35.000 -> 00:14:41.000
では、アプリをもう一度実行して、最後にピザを注文しましょう。

00:14:41.000 -> 00:14:45.000
驚くべきことに、私たちの食べ物のサイズはここのピザと正しく一致しています。

00:14:45.000 -> 00:14:49.000
スペイン語で男性的なサンドイッチを試してみましょう。

00:14:49.000 -> 00:14:51.000
これは素晴らしく見えます。

00:14:51.000 -> 00:15:03.000
では、英語でアプリを起動して、最後にピザを注文しましょう。

00:15:03.000 -> 00:15:07.000
今回は巨大なものを選びます。 

00:15:07.000 -> 00:15:12.000
そして、それを2つにしましょう。なぜですか？

00:15:12.000 -> 00:15:15.000
トニーはすぐに私たちの注文を配達するようです。

00:15:15.000 -> 00:15:21.000
ここでのジェンダーニュートラルな言語は素晴らしいですが、私たちはたまたまトニーが彼の代名詞を彼/彼/彼に設定したことを知っています。

00:15:21.000 -> 00:15:24.000
これは私たちが簡単に修正できるものです。

00:15:24.000 -> 00:15:35.000
そのために、配達人のモデルを拡張して、preferredTermsofAddressを含めましょう。

00:15:35.000 -> 00:15:45.000
そして、トニーのインスタンスを拡張し、彼が男性代名詞を使用することを好むことを示しましょう。

00:15:45.000 -> 00:15:52.000
次に、文字列自体を変更します。

00:15:52.000 -> 00:15:59.000
ここでは、配達人の用語に応じて「彼ら」を代名詞に置き換えたいと思います。

00:15:59.000 -> 00:16:07.000
これを行うには、新しい referentConcept 属性を使用します。

00:16:07.000 -> 00:16:16.000
ここで1の値は、代名詞「they」の参照元がLocalizationOptionsで渡された最初の概念でなければならないことを意味します。

00:16:16.000 -> 00:16:29.000
これは、この文の任意の三人称人称代名詞に適用できます。

00:16:29.000 -> 00:16:35.000
次に、LocalizationOptionsの概念としてtermsOfAddressを渡したいと思います。

00:16:35.000 -> 00:16:43.000
deliveryMessageのローカリゼーションオプションを初期化しましょう。

00:16:43.000 -> 00:16:59.000
ここでは、termsOfAddressの概念を使用して、文法的な合意に使用できるtermsOfAddressを提供することもできます。

00:16:59.000 -> 00:17:07.000
そして最後に、文字列を初期化するときに新しいLocalizationOptionsを使用しましょう。

00:17:07.000 -> 00:17:15.000
では、もう一度アプリを実行してみましょう。

00:17:15.000 -> 00:17:19.000
オーケー、巨大なピザ、2つ。

00:17:19.000 -> 00:17:24.000
3つにしましょう。

00:17:24.000 -> 00:17:30.000
契約を適用したので、これははるかに個人的に見えます。

00:17:30.000 -> 00:17:36.000
今年はFoundationに多くの素晴らしい新機能があり、今日あなたのアプリで試す準備ができています。

00:17:36.000 -> 00:17:40.000
Inflect: trueは今年さらに多くの言語をサポートしています。

00:17:40.000 -> 00:17:49.000
私たちの新しい依存関係契約APIは、同じ文字列内、または完全に文脈外の単語に同意するのに役立ちます。

00:17:49.000 -> 00:17:58.000
最後に、Markdownの新しいtermsOfAddress抑揚コンセプトとrefentConcept属性は、言語をよりパーソナライズするのに役立ちます。

00:17:58.000 -> 00:18:02.000
言語レベルのサポートについては、ドキュメントを参照してください。

00:18:02.000 -> 00:18:04.000
これらの新機能を気に入っていただければ幸いです。

00:18:04.000 -> 00:18:08.000
私たちは、彼らがすぐにあなたのアプリの言語を美しくするのを見るのを楽しみにしています。

00:18:08.000 -> 00:18:09.000
ありがとうございます。

00:18:09.000 -> 00:18:13.000
ああ、私のピザが届きました。ありがとう、トニー。

00:18:13.000 -> 23:59:59.000
♪ ♪

