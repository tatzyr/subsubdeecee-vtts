WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:15.000
ニック・ジレット：こんにちは、私はAppleのSwiftDataチームのエンジニア、ニック・ジレットです。

00:00:15.000 --> 00:00:24.000
このセッションでは、この豊かで強力な新しいフレームワークを活用するために、SwiftDataで構築されたアプリケーションがどのように進化するかを詳細に検討します。

00:00:24.000 --> 00:00:29.000
まず、アプリケーションで永続性を設定する方法を調べます。

00:00:29.000 --> 00:00:36.000
次に、ModelContextを使用して変更を追跡し、永続化する方法について説明します。

00:00:36.000 --> 00:00:42.000
最後に、コード内のオブジェクトを操作するときにSwiftDataを最大限に活用する方法を調べます。

00:00:42.000 --> 00:00:51.000
このセッションは、「Meet Swift Data」と「Model your Schema with SwiftData」で導入された概念とAPIに基づいて構築されていることに注意したいと思います。

00:00:51.000 --> 00:00:56.000
このセッションを続ける前に、これらのセッションを確認することを強くお勧めします。

00:00:56.000 --> 00:01:08.000
この講演では、SwiftDataでアプリケーションを構築するのがいかに簡単かを実証するために、今年構築した新しいサンプルアプリケーション、SampleTripsを参照します。

00:01:08.000 --> 00:01:14.000
SampleTripsを使用すると、いつ、どこで旅行したいかについてのアイデアを簡単に整理できます。

00:01:14.000 --> 00:01:24.000
SwiftDataはまた、ユーザーがアプリケーションを切り替えたときの取り消しや自動保存などの標準的なプラットフォームプラクティスを簡単に実装できるようにします。

00:01:24.000 --> 00:01:29.000
SwiftDataは、Swiftを使用するアプリケーションでデータを永続化する新しい方法です。

00:01:29.000 --> 00:01:35.000
クラスや構造体など、コードですでに使用しているタイプで動作するように設計されています。

00:01:35.000 --> 00:01:44.000
この概念の中核には、新しいマクロ@Modelで説明されているモデルがあり、永続化したいタイプについてSwiftDataに伝えます。

00:01:44.000 --> 00:01:48.000
これはSampleTripsアプリケーションのトリップクラスです。

00:01:48.000 --> 00:01:56.000
旅行に関する情報と、SampleTripsで使用される他のオブジェクトへの参照をキャプチャするためのいくつかのプロパティがあります。

00:01:56.000 --> 00:02:08.000
私たちは、私がここで持っているように、通常永続性なしで書くコードと、永続性を持って書かなければならないコードとの間に最小限の距離を提供するようにSwiftDataを設計しました。

00:02:08.000 --> 00:02:20.000
ほんの少しの変更で、この旅行は私が持続したいモデルであることをSwiftDataに伝え、BucketListItemとLivingAccommodationsとの関係がどのように振る舞うべきかを説明しました。

00:02:20.000 --> 00:02:27.000
可能であれば、SwiftDataは、書き込むコードから使用する構造を自動的に推測します。

00:02:27.000 --> 00:02:36.000
しかし、SwiftDataは、データの保存方法を正確に説明するのに役立つ強力なカスタマイズセットも提供しています。

00:02:36.000 --> 00:02:42.000
「SwiftDataでスキーマをモデル化」では、モデルの力についてすべて学ぶことができます。

00:02:42.000 --> 00:02:48.000
Tripクラスへのこれらの注釈により、SwiftDataで2つの重要な役割を果たすことができます。

00:02:48.000 --> 00:02:59.000
1つ目は、スキーマと呼ばれるアプリケーションのオブジェクトグラフを記述することであり、2つ目は、Tripクラスがコードを書くことができるインターフェイスになることです。

00:02:59.000 --> 00:03:16.000
この二重性、両方の部分を再生する能力は、@Modelマクロで注釈付けされたクラスをSwiftDataを使用するアプリケーションの中心的な連絡先にし、これらの役割のそれぞれをサポートするための整列されたAPIコンセプトがあります。

00:03:16.000 --> 00:03:23.000
スキーマは、データの永続化方法を記述するために、ModelContainerと呼ばれるクラスに適用されます。

00:03:23.000 --> 00:03:30.000
ModelContainerはスキーマを消費して、Modelクラスのインスタンスを保持できるデータベースを生成します。

00:03:30.000 --> 00:03:41.000
コードでModelクラスのインスタンスを操作する場合、これらのインスタンスはメモリ内の状態を追跡および管理するModelContextにリンクされます。

00:03:41.000 --> 00:03:54.000
この二元性はSwiftDataの中核であり、このセクションでは、持続性の構造とそれがModelContainerでどのように機能するかを説明するために、モデルの最初の役割を詳しく見ていきます。

00:03:54.000 --> 00:04:01.000
ModelContainerは、データがデバイスにどのように保存されるか、または保持されるかを説明する場所です。

00:04:01.000 --> 00:04:07.000
ModelContainerは、スキーマとその永続性の間の架け橋と考えることができます。

00:04:07.000 --> 00:04:21.000
メモリ内かディスクかなど、オブジェクトがどのように保存されるかに関する説明が、バージョン管理、移行、グラフ分離などのストレージの運用および進化的セマンティクスを満たす場所です。

00:04:21.000 --> 00:04:25.000
スキーマでコンテナをインスタンス化するのは簡単です。

00:04:25.000 --> 00:04:31.000
私は私が作業したいタイプだけを提供することができ、SwiftDataは私のためにスキーマの残りの部分を把握します。

00:04:31.000 --> 00:04:41.000
たとえば、Tripクラスは他のモデルタイプに関連しているため、単一のタイプしか渡していないにもかかわらず、ModelContainerは実際にこのスキーマを推測します。

00:04:41.000 --> 00:04:53.000
ModelContainerには、ModelConfigurationと呼ばれるクラスを使用してますます複雑な構成を可能にするために、コードとともに成長するように設計された他の多くの強力な初期化子があります。

00:04:53.000 --> 00:04:57.000
ModelConfigurationは、スキーマの永続性を記述します。

00:04:57.000 --> 00:05:04.000
一時的なデータのメモリや永続的なデータのディスクなど、データが保存されている場所を制御します。

00:05:04.000 --> 00:05:16.000
ModelConfigurationは、選択した特定のファイルURLを使用するか、グループコンテナエンタイトルメントなどのアプリケーションのエンタイトルメントを使用して自動的に生成できます。

00:05:16.000 --> 00:05:25.000
この設定では、永続ファイルを読み取り専用モードでロードし、機密データやテンプレートデータへの書き込みを防ぐ必要があることも説明できます。

00:05:25.000 --> 00:05:34.000
そして最後に、複数のCloudKitコンテナを使用するアプリケーションは、スキーマのModelConfigurationの一部として指定できます。

00:05:34.000 --> 00:05:41.000
新しいPersonとAddressクラスを使用して、SampleTripsに連絡先情報を追加したいと想像してみましょう。

00:05:41.000 --> 00:05:47.000
まず、使用するすべてのタイプを含む合計スキーマが宣言されます。

00:05:47.000 --> 00:05:56.000
次に、Trip、BucketListItem、およびLivingAccommodationsモデルを含むSampleTripsデータの構成が宣言されます。

00:05:56.000 --> 00:06:09.000
この特定のオブジェクトグラフのデータを保存するために使用するファイルのURLと、SampleTripsデータをCloudKitに同期するときに使用するCloudKitコンテナのコンテナ識別子を宣言します。

00:06:09.000 --> 00:06:23.000
次に、人とアドレスを持つ新しいスキーマのモデルは、このデータをTripsグラフから分離するために、一意のファイルURLとCloudKitコンテナ識別子を使用して独自の構成で宣言されます。

00:06:23.000 --> 00:06:30.000
最後に、スキーマと構成を組み合わせてModelContainerを形成します。

00:06:30.000 --> 00:06:39.000
ModelConfigurationの力により、どんなに複雑であっても、アプリケーションの永続性要件を簡単に説明できます。

00:06:39.000 --> 00:06:49.000
SwiftUIアプリケーションは、手でコンテナをインスタンス化することに加えて、新しいmodelContainer修飾子を使用して、作業したいコンテナを作成できます。

00:06:49.000 --> 00:07:02.000
modelContainer修飾子は、アプリケーション内の任意のビューまたはシーンに追加でき、シンプルなものから強力なものまで、そしてその間のすべてでModelContainersをサポートします。

00:07:02.000 --> 00:07:08.000
このセクションでは、ModelContainerを使用してスキーマと永続性を組み合わせる方法を調べました。

00:07:08.000 --> 00:07:13.000
これまで以上に強力な機能とオブジェクトグラフを構築するにつれて、アプリケーションとともに成長します。

00:07:13.000 --> 00:07:20.000
そして、ModelConfigurationを使用して強力な永続性機能のロックを解除する方法を実証しました。

00:07:20.000 --> 00:07:31.000
「Meet SwiftData」で学んだように、ModelとModelContextは、ユーザーインターフェイスの書き込みやモデルオブジェクトの操作時に最も頻繁に使用される概念の2つです。

00:07:31.000 --> 00:07:40.000
このセクションでは、ModelContextがどのように変更を追跡し、ModelContainerを通じて編集を永続化するかを深く掘り下げます。

00:07:40.000 --> 00:07:49.000
ビューまたはシーンコードでmodelContainer修飾子を使用すると、特定の方法でアプリケーションの環境を準備します。

00:07:49.000 --> 00:07:54.000
修飾子は、環境内の新しいmodelContextキーをコンテナのmainContextにバインドします。

00:07:54.000 --> 00:08:04.000
主なコンテキストは、シーンやビューでModelObjectsを操作するための特別なMainActorアライメントモデルコンテキストです。

00:08:04.000 --> 00:08:18.000
環境からモデルコンテキストを使用することで、ビューコードはここでクエリで使用されるコンテキストに簡単にアクセスできるため、ここで削除などのアクションを実行できます。

00:08:18.000 --> 00:08:24.000
したがって、モデルのコンテキストは使いやすくアクセスしやすいですが、実際には何をしますか?

00:08:24.000 --> 00:08:30.000
ModelContextは、アプリケーションが管理するデータに対するビューと考えることができます。

00:08:30.000 --> 00:08:34.000
作業したいデータは、使用されるモデルコンテキストにフェッチされます。

00:08:34.000 --> 00:08:43.000
SampleTripsでは、今後のトリップビューがリストのデータをロードすると、各トリップオブジェクトがメインコンテキストにフェッチされます。

00:08:43.000 --> 00:08:49.000
旅行が編集された場合、その変更はモデルコンテキストによってスナップショットとして記録されます。

00:08:49.000 --> 00:09:02.000
新しいトリップの挿入や既存のトリップの削除など、他の変更が行われると、コンテキストは「context.save（）」を呼び出すまで、これらの変更に関する状態を追跡し、維持します。

00:09:02.000 --> 00:09:14.000
これは、削除されたトリップがリストに表示されなくなったとしても、その削除がsaveを呼び出すことによって持続するまで、ModelContextにまだ存在することを意味します。

00:09:14.000 --> 00:09:20.000
saveが呼び出されると、コンテキストはModelContainerへの変更を永続化し、その状態をクリアします。

00:09:20.000 --> 00:09:28.000
リストに表示するなど、コンテキスト内のオブジェクトをまだ参照している場合は、完了するまでコンテキストに存在します。

00:09:28.000 --> 00:09:32.000
その時点で、彼らは解放され、文脈は空になります。

00:09:32.000 --> 00:09:37.000
ModelContextは、バインドされているModelContainerと連携して動作します。

00:09:37.000 --> 00:09:43.000
ビューでフェッチしたオブジェクトを追跡し、保存が実行されたときに変更を伝播します。

00:09:43.000 --> 00:09:51.000
ModelContextは、必要に応じてキャッシュされた状態をクリアするためのロールバックやリセットなどの機能もサポートしています。

00:09:51.000 --> 00:09:58.000
これは、取り消しや自動保存などのプラットフォーム機能をサポートするのに理想的な場所です。

00:09:58.000 --> 00:10:09.000
SwiftUIアプリケーションでは、modelContainer修飾子には、ウィンドウの取り消しマネージャをコンテナのmainContextにバインドするこのisUndoEnabled引数があります。

00:10:09.000 --> 00:10:21.000
つまり、メインコンテキストで変更が行われると、3本指のスワイプやシェイクなどのシステムジェスチャーを使用して、追加のコードなしで変更を元に戻したり、やり直したりできます。

00:10:21.000 --> 00:10:28.000
ModelContextは、モデルオブジェクトに変更が加えられると、取り消しとやり直しのアクションを自動的に登録します。

00:10:28.000 --> 00:10:37.000
modelContainer修飾子は、通常、ウィンドウまたはウィンドウグループの一部としてシステムによって提供される環境のundoManagerを使用します。

00:10:37.000 --> 00:10:45.000
このため、3本指のスワイプやシェイクなどのシステムジェスチャーは、アプリケーションで自動的に機能します。

00:10:45.000 --> 00:10:50.000
ModelContextでサポートされているもう1つの標準システム機能は、自動保存です。

00:10:50.000 --> 00:10:59.000
自動保存を有効にすると、モデルコンテキストは、フォアグラウンドやバックグラウンドに入るアプリケーションなどのシステムイベントに応答して保存されます。

00:10:59.000 --> 00:11:05.000
メインコンテキストは、アプリケーションが使用されるときに定期的に保存されます。

00:11:05.000 --> 00:11:15.000
自動保存はアプリケーションでデフォルトで有効になっており、modelContainer修飾子のisAutosaveEnabled引数を使用して必要に応じて無効にすることができます。

00:11:15.000 --> 00:11:19.000
手作業で作成されたモデルコンテキストでは、自動保存が無効になっています。

00:11:19.000 --> 00:11:27.000
「Meet SwiftData」では、アプリケーションでModelContextを操作する方法と、SwiftUIとの組み合わせについて多くのことを学びました。

00:11:27.000 --> 00:11:33.000
しかし、アプリケーションがモデルオブジェクトを操作する必要があるのは、ユーザーインターフェイスだけではありません。

00:11:33.000 --> 00:11:42.000
このセクションでは、SwiftDataが強力でスケーラブルなコードの作成をこれまで以上に簡単かつ安全にする方法について説明します。

00:11:42.000 --> 00:11:55.000
バックグラウンドキューのデータ操作、リモートサーバーやその他の永続性メカニズムとの同期、バッチ処理などのタスクは、セットやグラフで頻繁にモデルオブジェクトで動作します。

00:11:55.000 --> 00:12:02.000
これらのタスクの多くは、ModelContextのフェッチメソッドを介して作業するオブジェクトのセットを取得することから始まります。

00:12:02.000 --> 00:12:11.000
この例では、TripモデルのFetchDescriptorは、trips配列がTripオブジェクトのコレクションであることをSwiftに伝えます。

00:12:11.000 --> 00:12:16.000
心配するキャスティングや複雑な結果タプルはありません。

00:12:16.000 --> 00:12:21.000
FetchDescriptorを使用すると、新しい述語マクロを使用して複雑なクエリを簡単に作成できます。

00:12:21.000 --> 00:12:26.000
例えば、特定のホテルに滞在することを含むすべての旅行は何ですか?

00:12:26.000 --> 00:12:31.000
または、どの旅行にまだ予約が必要なアクティビティがありますか？

00:12:31.000 --> 00:12:39.000
SwiftDataでは、サブクエリと結合をサポートする複雑なクエリはすべて純粋なスウィフトで記述できます。

00:12:39.000 --> 00:12:48.000
Predicateは作成したモデルを使用し、SwiftDataはこれらのモデルから生成されたスキーマを使用して、これらの述語をデータベースクエリに変換します。

00:12:48.000 --> 00:12:59.000
FetchDescriptorは、新しいFoundation Predicateマクロのパワーとスキーマを組み合わせて、コンパイラが検証したクエリを初めてAppleプラットフォーム上の永続性にもたらします。

00:12:59.000 --> 00:13:10.000
FetchDescriptorやSortDescriptorなどの関連クラスは、ジェネリックを使用して結果型を形成し、使用できるモデルのプロパティについてコンパイラに伝えます。

00:13:10.000 --> 00:13:19.000
オフセットやリミット、フォールトやプリフェッチのパラメータなど、あなたが知り、愛するようになった多くのチューニングオプションがあります。

00:13:19.000 --> 00:13:25.000
このすべてのパワーは、ModelContextの新しい列挙関数に結合されます。

00:13:25.000 --> 00:13:37.000
単一のコールサイトでプラットフォームのベストプラクティスをカプセル化することで、バッチトラバーサルと列挙の厄介なパターンを暗黙的に効率的にするのに役立つように設計されています。

00:13:37.000 --> 00:13:45.000
Enumerateは、単純なものから強力なものまで、複雑さに関係なく、FetchDescriptorsでうまく機能します。

00:13:45.000 --> 00:13:51.000
Enumerateは、バッチ処理や突然変異ガードなどのトラバーサルのプラットフォームのベストプラクティスを自動的に実装します。

00:13:51.000 --> 00:13:56.000
これらは、特定のユースケースのニーズに合わせてカスタマイズ可能です。

00:13:56.000 --> 00:14:01.000
たとえば、列挙するバッチサイズは、デフォルトを5,000オブジェクトに使用します。

00:14:01.000 --> 00:14:09.000
しかし、メモリの成長を犠牲にして、トラバーサル中のI / O操作を減らすために10,000に変更することができます。

00:14:09.000 --> 00:14:18.000
画像、ムービー、またはその他の大きなデータブロブを含むような、より重いオブジェクトグラフは、より小さなバッチサイズを使用することを選択できます。

00:14:18.000 --> 00:14:24.000
バッチサイズを小さくすると、メモリの成長は減少しますが、列挙中にI/Oが増加します。

00:14:24.000 --> 00:14:28.000
Enumerateには、デフォルトで突然変異ガードも含まれています。

00:14:28.000 --> 00:14:36.000
大規模なトラバーサルのパフォーマンスの問題の最も頻繁な原因の1つは、列挙中にコンテキストに閉じ込められる突然変異です。

00:14:36.000 --> 00:14:54.000
allowEscapingMutationsは、これが意図的であることを列挙に伝えます。設定されていない場合、列挙を実行するModelContextが汚れていることを発見した場合、列挙はスローされ、すでにトラバースされたオブジェクトを解放するのを防ぎます。

00:14:54.000 --> 00:15:01.000
このセッションでは、スキーマとモデル構成を使用して強力な永続性構成を作成する方法を学びました。

00:15:01.000 --> 00:15:10.000
また、ModelContainerとModelContextで取り消しややり直しなどの標準的なシステムプラクティスを採用するのがいかに簡単かを学びました。

00:15:10.000 --> 00:15:20.000
そして、今日SwiftDataを使用して、FetchDescriptor、predicate、enumerateを使用して、これまでにないほど安全でパフォーマンスの高いコードをプロジェクトに書き込むことができます。

00:15:20.000 --> 00:15:26.000
今後数ヶ月から数年の間に、この新しいフレームワークで可能なことの限界を押し広げる方法を見るのが待ちきれません。

00:15:26.000 --> 23:59:59.000
見てくれてありがとう、そして幸せなコーディング。

