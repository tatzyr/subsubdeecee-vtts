WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:15.000
ジャスティン：こんにちは！私の名前はジャスティンで、写真チームの一員です。

00:00:15.000 --> 00:00:22.000
今日は、システムフォトピッカーの新しい改善と、アプリで使用できるすべての素晴らしい新しいAPIについてお連れします。

00:00:22.000 --> 00:00:26.000
iOS 14で再設計されたピッカーUIを導入しました。

00:00:26.000 --> 00:00:30.000
検索やズーム可能なグリッドなど、多くの素晴らしい機能を備えています。

00:00:30.000 --> 00:00:35.000
さらに良いことに、それを使用するためにフォトライブラリへのアクセスをリクエストする必要はありません。

00:00:35.000 --> 00:00:41.000
可能な限り、カスタムピッカーをシステムピッカーに置き換えることをお勧めします。

00:00:41.000 --> 00:00:44.000
APIも本当に使いやすいです。

00:00:44.000 --> 00:00:51.000
わずか数行のコードで、ピッカーを表示し、ユーザーが選択した画像を受け取ることができます。

00:00:51.000 --> 00:00:56.000
昨年の「フォトピッカーの新機能」セッションでは、新しいAPIについて深く話しました。

00:00:56.000 --> 00:01:07.000
このセッションでは、アプリにシステムピッカーを埋め込むために活用できる新しいAPIに焦点を当て、写真ピッキング体験をよりシームレスにします。

00:01:07.000 --> 00:01:19.000
後で、新しいオプションメニューと、HDR写真、HDRビデオ、シネマティックモードビデオをサポートしたい場合のベストプラクティスについても説明します。

00:01:19.000 --> 00:01:25.000
しかし、飛び込む前に、ピッカーのアクセスモデルを簡単に要約しましょう。

00:01:25.000 --> 00:01:28.000
これはあなたがさっき見たピッカーです。

00:01:28.000 --> 00:01:34.000
アプリで実行されているように見えますが、実際にはアプリの上にレンダリングされた別のプロセスで実行されています。

00:01:34.000 --> 00:01:41.000
アプリはピッカーに直接アクセスできず、ピッカーコンテンツのスクリーンショットを撮ることさえできません。

00:01:41.000 --> 00:01:47.000
ユーザーが実際に選択したものだけがアプリに返されます。

00:01:47.000 --> 00:01:54.000
今年は、プロセス外のピッカーにより多くの構成オプションを導入します。

00:01:54.000 --> 00:02:04.000
新しい「.photosPickerDisabledCapabilities」修飾子を使用すると、特定のピッカー機能を無効にできるため、独自のバージョンを実装できます。

00:02:04.000 --> 00:02:11.000
たとえば、選択アクションを無効にすると、「キャンセル」ボタンと「追加」ボタンを非表示にすることができます。

00:02:11.000 --> 00:02:24.000
新しい「.photosPickerAccessoryVisibility」修飾子を使用すると、ナビゲーションバーやツールバーなどのピッカーコンテンツの周りのアクセサリUIを非表示にすることができます。

00:02:24.000 --> 00:02:32.000
「.frame」や「.padding」などの標準のSwiftUI修飾子を使用して、ピッカーのサイズと位置を指定することもできます。

00:02:32.000 --> 00:02:40.000
「「追加」ボタンが非表示になっている場合、私のアプリはどのようにして複数選択モードでユーザーが選択したアセットを受け取ることができますか?」と疑問に思うかもしれません。

00:02:40.000 --> 00:02:47.000
選択動作を「.continuous」に設定して、ライブ選択の更新を受信できるようになりました。

00:02:47.000 --> 00:02:59.000
そして最後に、新しい「.photosPickerStyle(.inline)」修飾子を使用して、別のシートとして表示するのではなく、アプリにピッカーを埋め込むことができます。

00:02:59.000 --> 00:03:05.000
ピッカーが埋め込まれていても、別のプロセスでレンダリングされます。

00:03:05.000 --> 00:03:13.000
一部のユーザーは、アプリがライブラリへのアクセスを要求せずにすべての写真を表示するのを見ると心配するかもしれません。

00:03:13.000 --> 00:03:25.000
アプリを使用するときにユーザーが安全に感じられるようにしたいので、埋め込みピッカーが初めて表示されると、アプリが選択した写真にしかアクセスできないことを説明するオンボーディングUIが自動的に表示されます。

00:03:25.000 --> 00:03:31.000
写真のプライバシーバッジは、ピッカーが非公開でプロセス外であることを示します。

00:03:31.000 --> 00:03:39.000
アプリがすでにフルサイズピッカーを表示している場合は、ユーザーがiOS 17にアップグレードすると、却下可能なバナーが表示されます。

00:03:39.000 --> 00:03:45.000
プライバシー設定UIも更新され、より詳細な説明が記載されています。

00:03:45.000 --> 00:03:50.000
さらに、ライブラリのアクセス許可プロンプトにいくつかの変更を加えました。

00:03:50.000 --> 00:03:56.000
これらの変更の詳細については、「プライバシーの新機能」セッションをご覧ください。

00:03:56.000 --> 00:04:00.000
さて、実際のAPIに戻りましょう。

00:04:00.000 --> 00:04:06.000
まず彼らのユースケースを詳しく確認してから、各APIを詳しく説明します。

00:04:06.000 --> 00:04:12.000
プロセス外のピッカーを埋め込みたい場合は、「.photosPickerStyle」修飾子を使用してください。

00:04:12.000 --> 00:04:19.000
ピッカーの周りに独自のUIを配置するには、「.photosPickerAccessoryVisibility」を使用します。

00:04:19.000 --> 00:04:26.000
また、指定されたエッジの周りのアクセサリを制御できるオプションの引数もあります。

00:04:26.000 --> 00:04:30.000
デフォルト値はすべてのエッジです。

00:04:30.000 --> 00:04:37.000
いくつかのピッカー機能の独自の代替品を実装したい場合は、「.photosPicker DisabledCapabilities」修飾子を使用してください。

00:04:37.000 --> 00:04:48.000
最後に、選択の更新をリアルタイムで調整または応答する必要がある場合は、「selectionBehavior」が「.continuous」に設定されていることを確認してください。

00:04:48.000 --> 00:04:52.000
では、正確には何がアクセサリーと見なされますか?

00:04:52.000 --> 00:05:00.000
iOSでは、一番上のアクセサリはナビゲーションバーで、一番下のアクセサリはツールバーです。

00:05:00.000 --> 00:05:07.000
iPadOSとmacOSでは、主要なアクセサリは、表示されているときのサイドバーです。

00:05:07.000 --> 00:05:12.000
上部と下部のアクセサリーは、iOSが持っているものと似ています。

00:05:12.000 --> 00:05:23.000
次に、無効にできるピッカー機能と、それらがピッカーUIにどのように影響するかを説明します。

00:05:23.000 --> 00:05:28.000
検索機能が無効になっている場合、検索バーは非表示になります。

00:05:28.000 --> 00:05:34.000
コレクションナビゲーションが無効になっている場合、アルバムタブは非表示になります。

00:05:34.000 --> 00:05:39.000
iPadOSとmacOSでは、サイドバーも非表示になります。

00:05:39.000 --> 00:05:47.000
ステージングエリアが無効になっている場合、ツールバーボタンはステータスラベルに置き換えられます。

00:05:47.000 --> 00:05:56.000
連続選択せずに選択アクションを無効にした場合、「キャンセル」ボタンのみが非表示になり、「追加」ボタンは引き続き表示されます。

00:05:56.000 --> 00:06:01.000
そうしないと、アプリはユーザー選択を受信できなくなります。

00:06:01.000 --> 00:06:08.000
選択動作を「.continuous」に設定すると、両方のボタンが非表示になります。

00:06:08.000 --> 00:06:11.000
では、新しいピッカースタイルを見てみましょう。

00:06:11.000 --> 00:06:19.000
「.Presentation」スタイルと「.inline」スタイルに加えて、ピッカーは別の「.compact」スタイルもサポートしています。

00:06:19.000 --> 00:06:23.000
これはデフォルトの「.presentation」スタイルです。

00:06:23.000 --> 00:06:28.000
これは、すべてのアクセサリーが隠されている「.inline」スタイルです。

00:06:28.000 --> 00:06:31.000
そして、これは「.コンパクト」スタイルです。

00:06:31.000 --> 00:06:39.000
単一行ピッカーを使用すると、利用可能な垂直スペースが深刻に制約されているより多くの場所に埋め込むことができます。

00:06:39.000 --> 00:06:43.000
デモですべてをつなげる時が来ました。

00:06:43.000 --> 00:06:48.000
私はすでにテキストの説明で画像に注釈を付けることができるシンプルなアプリを作りました。

00:06:48.000 --> 00:06:52.000
今何ができるかをお見せしましょう。

00:06:52.000 --> 00:07:02.000
ピッカーをモーダルシートとして表示し、いくつかの画像を選択し、いくつかの説明を追加することができます。

00:07:02.000 --> 00:07:07.000
デモでは、「写真を選択」ボタンを埋め込みピッカーに置き換えたいです。

00:07:07.000 --> 00:07:15.000
「.photosPickerStyle(.inline)」修飾子を追加して試してみます。

00:07:15.000 --> 00:07:27.000
うまくいきますが、まだ良く見えません。

00:07:27.000 --> 00:07:38.000
リストを更新するには「追加」ボタンをタップする必要があり、ピッカーのサイズが変更された場合、ツールバーはデバイスの下端まで拡張されません。

00:07:38.000 --> 00:07:39.000
でも、心配しないでください。

00:07:39.000 --> 00:07:43.000
ほんの少しの微調整で、それははるかに良く見えることができます。

00:07:43.000 --> 00:07:55.000
まず、ピッカーは安全なエリアの挿入を優雅に処理できるため、「.ignoresSafeArea」修飾子を使用して、ピッカーが画面の下端まで展開できます。

00:07:55.000 --> 00:08:03.000
次に、ピッカーで写真を選択するとすぐにリストを更新できることを確認します。

00:08:03.000 --> 00:08:07.000
実際、変更するのはとても簡単です。

00:08:07.000 --> 00:08:13.000
選択動作を「.continuous」に設定することは、私がする必要があるすべてです。

00:08:13.000 --> 00:08:20.000
リストがライブ更新されたので、ナビゲーションバーのボタンをもう保持する必要はありません。

00:08:20.000 --> 00:08:32.000
「.photosPicker DisabledCapabilities」修飾子を使用して削除できます。

00:08:32.000 --> 00:08:34.000
ピッカーは完全に機能しています。

00:08:34.000 --> 00:08:39.000
しかし、ピッカーも素敵に見えるようにしたいです。

00:08:39.000 --> 00:08:43.000
ナビゲーションバーとツールバーを非表示にすべきだと思います。

00:08:43.000 --> 00:08:47.000
私はまた、ピッカーに固定された高さを与えたいです。

00:08:47.000 --> 00:08:59.000
「.photosPicker AccessoryVisibility」修飾子を使用して、バーを非表示にし、他のSwiftUIビューと同様にピッカーの高さを調整できます。

00:08:59.000 --> 00:09:17.000
今、それは素晴らしく見えます。

00:09:17.000 --> 00:09:23.000
ほんの数分以内に、新しい埋め込みピッカーを表示するようにアプリを更新しました。

00:09:23.000 --> 00:09:27.000
実際のデバイスでテストできるように、ビルドして実行します。

00:09:27.000 --> 00:09:32.000
ズーム可能なグリッドを使用して、選択したい写真にすばやく移動できます。

00:09:32.000 --> 00:09:36.000
選択した写真は自動的に私のアプリに表示されます。

00:09:36.000 --> 00:09:44.000
私のアプリの写真ピッキング体験は、新しい埋め込みピッカーで大幅に改善されました。

00:09:44.000 --> 00:09:46.000
デモはそれだけです。

00:09:46.000 --> 00:09:56.000
私はデモでiPhoneを使用していましたが、同じAPIがiOS、iPadOS、macOSで利用可能です。

00:09:56.000 --> 00:10:02.000
SwiftUIに加えて、同じAPIがUIKitとAppKitアプリでも利用可能です。

00:10:02.000 --> 00:10:06.000
UIKitとAppKit APIを見てみましょう。

00:10:06.000 --> 00:10:12.000
埋め込みピッカーは、同じPHPickerConfiguration APIを介して利用できます。

00:10:12.000 --> 00:10:18.000
「選択」を「.continuous」に設定して、連続選択動作をオプトインできるようになりました。

00:10:18.000 --> 00:10:24.000
「モード」を「.compact」に設定して、ピッカーを1行のレイアウトに設定することもできます。

00:10:24.000 --> 00:10:37.000
「edgesWithoutContentMargins」を使用してナビゲーションバーなどのアクセサリを非表示にし、「disabledCapabilities」を使用して特定のピッカー機能を無効にすることができます。

00:10:37.000 --> 00:10:49.000
「.photosPickerStyle(.inline)」修飾子を使用してピッカーを埋め込むことができるSwiftUI APIとは異なり、コンテナコントローラーに子ビューコントローラーとして追加する必要があります。

00:10:49.000 --> 00:10:57.000
ピッカーのフレームを手動で設定するか、自動レイアウト制約を使用してピッカービューのサイズと配置を行うことができます。

00:10:57.000 --> 00:11:04.000
サブビューを追加した後、追加されたことをピッカーに通知するだけです。

00:11:04.000 --> 00:11:12.000
新しい「PHPickerConfiguration.Update」APIを使用すると、ユーザーに表示されている間にピッカーを更新できます。

00:11:12.000 --> 00:11:21.000
既存の「deselectAsset」および「moveAsset」APIを使用して、選択したアセットの選択を解除または並べ替えることもできます。

00:11:21.000 --> 00:11:28.000
次に、新しいオプションメニューと、それがアプリにどのように影響するかについて説明します。

00:11:28.000 --> 00:11:34.000
新しいオプションメニューを使用すると、ユーザーはアプリと共有できるものをより詳細に制御できます。

00:11:34.000 --> 00:11:47.000
デフォルトでは、すべての画像メタデータが含まれていますが、ユーザーは選択した写真から場所などの機密性の高いメタデータを削除できるようになりました。

00:11:47.000 --> 00:11:56.000
「PhotosPicker」と「Transferable」APIを使用している場合は、新しいオプションメニューをサポートするために採用作業を行う必要はありません。

00:11:56.000 --> 00:12:03.000
同様に、「PHPickerViewController」APIを使用している場合、採用作業は必要ありません。

00:12:03.000 --> 00:12:12.000
オプションメニューは、レガシー「UIImagePickerController」APIを使用するアプリ、または完全なライブラリアクセスを持つアプリではサポートされません。

00:12:12.000 --> 00:12:16.000
さて、それはオプションメニューです。

00:12:16.000 --> 00:12:25.000
次に、システムピッカーを使用する場合、HDR画像、HDRビデオ、シネマティックモードビデオをサポートする方法について説明します。

00:12:25.000 --> 00:12:32.000
ピッカーは、デフォルトでは、JPEGなどの互換性のあるフォーマットにアセットを自動的にトランスコードすることがあります。

00:12:32.000 --> 00:12:39.000
ただし、トランスコードされた資産には、元の資産に含まれるすべての情報が含まれていない場合があります。

00:12:39.000 --> 00:12:44.000
したがって、HDRコンテンツを受信したい場合は、自動トランスコーディングを避けるのが最善です。

00:12:44.000 --> 00:12:55.000
「.Current」エンコーディングポリシーを使用し、「.image」や「.movie」などの一般的なコンテンツタイプを要求することで、元の形式で写真やビデオを取得できます。

00:12:55.000 --> 00:13:04.000
「.Jpeg」などの特定のコンテンツタイプをリクエストすると、エンコーディングポリシーが「.current」に設定されていても、アセットがトランスコードされる可能性があります。

00:13:04.000 --> 00:13:10.000
HDRのサポートの追加の詳細については、今年の「アプリでHDR画像をサポートする」セッションをご覧ください。

00:13:10.000 --> 00:13:16.000
以下は、元の形式で画像を受け取るコード例です。

00:13:16.000 --> 00:13:24.000
「preferredItemEncoding」が「.current」に設定され、「importedContentType」が「.image」に設定されていることがわかります。

00:13:24.000 --> 00:13:32.000
シネマティックモードのビデオが選択されている場合、ピッカーはレンダリングされたバージョンを提供し、すべての深度効果が焼き込まれます。

00:13:32.000 --> 00:13:40.000
すべての決定ポイントを取得したい場合は、フォトライブラリへのアクセスを要求し、代わりにPhotoKitを使用してビデオを取得する必要があります。

00:13:40.000 --> 00:13:48.000
シネマティックモードのビデオの詳細については、「アプリでシネマティックモードのビデオをサポート」セッションをご覧ください。

00:13:48.000 --> 00:13:56.000
最後に、新しい組み込みピッカーは多くの柔軟性をもたらし、私はあなたがそれで何ができるかを見るのが待ちきれません。

00:13:56.000 --> 00:14:06.000
オプションメニューでは、ユーザーは何を共有するかをより詳細に制御できるため、本当に必要でない限り、フォトライブラリへのアクセスを要求しないでください。

00:14:06.000 --> 00:14:08.000
ありがとう、そしてハッピーコーディング!

00:14:08.000 --> 23:59:59.000
♪ ♪

