WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:12.000
アダム:こんにちは、私はアダムです。

00:00:12.000 --> 00:00:18.000
このビデオでは、あなたのアプリがカレンダーとEventKitで時間を管理するのにどのように役立つかについて説明します。

00:00:18.000 --> 00:00:26.000
まず、アプリがカレンダーと統合できるいくつかの方法を確認し、関連するフレームワークの概要を説明します。

00:00:26.000 --> 00:00:41.000
次に、これらのフレームワークを使用して、イベントの追加、フルアクセスによるイベントの取得、仮想会議拡張の実装など、共通の機能を実装する方法の具体的な例を説明します。

00:00:41.000 --> 00:00:48.000
人々は自分の時間を追跡し、将来の計画を立てるためにカレンダーに頼っていますが、カレンダーは1つのアプリ以上のものです。

00:00:48.000 --> 00:00:58.000
カレンダーと統合するときにアプリが満たすことができるさまざまな役割があり、まとめると、これらの異なる役割はより豊かなカレンダー体験を提供します。

00:00:58.000 --> 00:01:04.000
一部のアプリは、予約、チケットの購入、またはミートアップの手配をサポートしています。

00:01:04.000 --> 00:01:07.000
彼らはイベントを追加して参加します。

00:01:07.000 --> 00:01:15.000
一部のアプリは、カスタムカレンダーウィジェットやプランナーのために、イベントを表示して参加します。

00:01:15.000 --> 00:01:18.000
他のアプリは両方向で貢献します。

00:01:18.000 --> 00:01:24.000
彼らは、イベントを表示および編集することで、人々がスケジュールを管理するのに役立ちます。

00:01:24.000 --> 00:01:29.000
音声通話やビデオ通話をサポートするアプリも参加できます。

00:01:29.000 --> 00:01:39.000
仮想会議の拡張機能は、カレンダーアプリのエクスペリエンスを向上させるだけでなく、アプリへのショートカットも提供します。

00:01:39.000 --> 00:01:44.000
これらすべてが一緒にフィットし、時間を管理するためのまとまりのある経験を提供します。

00:01:44.000 --> 00:01:51.000
後で、これらの各分野で始めるために、いくつかの具体的な例を見ていきます。

00:01:51.000 --> 00:01:56.000
カレンダーと統合するために使用できるフレームワークは2つあります。

00:01:56.000 --> 00:02:00.000
EventKitフレームワークは、カレンダーデータを直接操作するために使用されます。

00:02:00.000 --> 00:02:09.000
EventKitUIは、アプリにカレンダーUIを表示するためのビューコントローラーを提供するiOSとMacのCatalystフレームワークです。

00:02:09.000 --> 00:02:13.000
それぞれを詳しく見てみましょう...

00:02:13.000 --> 00:02:17.000
EventKitの基本的なタイプのいくつかから始めます。

00:02:17.000 --> 00:02:22.000
EKEventStoreは、カレンダーデータの主な連絡先です。

00:02:22.000 --> 00:02:27.000
イベントストアを使用してアクセスを要求し、取得または保存します。

00:02:27.000 --> 00:02:31.000
申請にはこれらのうちの1つだけが必要です。

00:02:31.000 --> 00:02:40.000
EKEventクラスは特定のイベントを表し、タイトル、開始日、終了日、場所などのプロパティがあります。

00:02:40.000 --> 00:02:46.000
各イベントは、EKCalendarクラスで表されるカレンダーに属します。

00:02:46.000 --> 00:02:52.000
カレンダーにはタイトルと色があり、イベントの色付けに役立ちます。

00:02:52.000 --> 00:02:58.000
最後に、各カレンダーアカウントは、カレンダーのコレクションであるEKSourceで表されます。

00:02:58.000 --> 00:03:04.000
ソースは、UIでカレンダーをグループ化するのに便利です。

00:03:04.000 --> 00:03:08.000
EventKitは、カレンダーデータと対話するための基本的なフレームワークです。

00:03:08.000 --> 00:03:15.000
EventKitUIは、いくつかの便利な組み込みビューを提供するために、EventKitの上に構築されています。

00:03:15.000 --> 00:03:19.000
EventKitUIが提供する3つのビューコントローラーがあります。

00:03:19.000 --> 00:03:24.000
EKEventEditViewControllerはイベントエディタを表示します。

00:03:24.000 --> 00:03:30.000
これを使用して、新しいイベントを追加したり、既存のイベントを変更したりします。

00:03:30.000 --> 00:03:34.000
EKEventViewControllerはイベントの詳細を表示します。

00:03:34.000 --> 00:03:39.000
これを使用して、既存のイベントに関する情報をアプリに表示します。

00:03:39.000 --> 00:03:46.000
また、EKCalendarChooserはカレンダーリストを表示し、単一選択または複数選択のいずれかをサポートします。

00:03:46.000 --> 00:03:55.000
これを使用して、イベントを追加するカレンダーを選択したり、アプリで表示するカレンダーを選択したりできます。

00:03:55.000 --> 00:04:02.000
カレンダーは非公開なので、システムはアプリが許可なくカレンダーイベントを読んだり書いたりするのを防ぎます。

00:04:02.000 --> 00:04:12.000
アプリがカレンダーに持つことができるアクセスには、アクセスなし、書き込み専用アクセス、またはフルアクセスの3つのレベルがあります。

00:04:12.000 --> 00:04:19.000
カレンダーにアクセスできないアプリは、EventKitUIまたはSiriイベントの提案を使用してイベントを追加できます。

00:04:19.000 --> 00:04:25.000
書き込み専用アクセスのアプリは、EventKitを使用して直接イベントを追加できます。

00:04:25.000 --> 00:04:36.000
また、フルアクセスのアプリは、既存のイベントを取得または変更したり、既存のカレンダーにアクセスしたり、新しいカレンダーを作成したりできます。

00:04:36.000 --> 00:04:42.000
カレンダーと統合する最も一般的な方法の1つは、新しいイベントを追加することです。

00:04:42.000 --> 00:04:46.000
イベントは、いくつかの異なる方法でカレンダーに追加できます。

00:04:46.000 --> 00:04:51.000
EventKitUIまたはSiriイベント提案を使用して、一度に1つのイベントを追加します。

00:04:51.000 --> 00:04:56.000
または、イベントを直接保存するには、EventKitを使用してください。

00:04:56.000 --> 00:05:02.000
カレンダーにイベントを追加する最も簡単な方法は、EventKitUIにほとんどの作業をさせることです。

00:05:02.000 --> 00:05:08.000
EKEventEditViewControllerを提示して、イベントの詳細が記入されたエディタを表示します。

00:05:08.000 --> 00:05:15.000
これにより、イベントを保存するかどうかを決定する前に、カレンダーを選択したり、その他の変更を加えたりする機会が得られます。

00:05:15.000 --> 00:05:25.000
iOS 17では、このUIは別のプロセスで実行されるため、カレンダーへのアクセスをリクエストする必要はありません。

00:05:25.000 --> 00:05:29.000
EventKitUIでイベントを追加するのは4段階のプロセスです。

00:05:29.000 --> 00:05:32.000
まず、イベントストアを作成します。

00:05:32.000 --> 00:05:36.000
次に、イベントを作成し、詳細を入力します。

00:05:36.000 --> 00:05:41.000
次に、イベントを編集するように設定されたビューコントローラーを作成します。

00:05:41.000 --> 00:05:45.000
そして最後に、ビューコントローラーを提示します。

00:05:45.000 --> 00:05:48.000
いくつかのコードでこれをより詳細に説明しましょう。

00:05:48.000 --> 00:05:52.000
イベントストアを作成することから始めます。

00:05:52.000 --> 00:05:56.000
次に、イベントを作成し、詳細を入力します。

00:05:56.000 --> 00:06:00.000
ここで設定した詳細は、エディタUIで使用されます。

00:06:00.000 --> 00:06:12.000
エディタが表示されると、人々は変更を加える機会がありますが、理想的には、追加ボタンをタップして確認できるため、適切な詳細を入力すると時間を節約できます。

00:06:12.000 --> 00:06:15.000
すべてのイベントにはタイトルが必要です。

00:06:15.000 --> 00:06:22.000
タイトルはウィジェットや通知を含む多くの場所で使用されているため、シンプルにしてください。

00:06:22.000 --> 00:06:26.000
最も重要なプロパティは、開始日と終了日です。

00:06:26.000 --> 00:06:30.000
日付コンポーネントを使用して開始日を作ります。

00:06:30.000 --> 00:06:36.000
開始日が決まったら、期間を加えて終了日を計算します。

00:06:36.000 --> 00:06:44.000
日付計算にFoundationのカレンダーとDateComponentsタイプを使用すると、夏時間の周りに驚くべき結果が得られます。

00:06:44.000 --> 00:06:49.000
ここで、サンプルは開始日に2時間を追加します。

00:06:49.000 --> 00:06:54.000
イベントが特定のタイムゾーンで行われる場合は、それも必ず設定してください。

00:06:54.000 --> 00:06:59.000
デフォルトのタイムゾーンは、現在のシステムタイムゾーンになります。

00:06:59.000 --> 00:07:03.000
イベントがどこで行われるかを人々に知らせる場所を設定します。

00:07:03.000 --> 00:07:12.000
完全なアドレスを含めるか、MapKitハンドルを使用すると、マップの提案やアラートを残す時間などの機能が有効になります。

00:07:12.000 --> 00:07:17.000
最後に、いくつかの詳細を提供するためにいくつかのメモを追加します。

00:07:17.000 --> 00:07:23.000
イベントプロパティを設定したら、次のステップはEKEventEditViewControllerを作成することです。

00:07:23.000 --> 00:07:27.000
イベントストアとイベントストアのプロパティを割り当てます。

00:07:27.000 --> 00:07:31.000
エディタでは、イベントを追加したり、キャンセルしたりできます。

00:07:31.000 --> 00:07:40.000
イベントを追加したかどうかを知りたい場合は、デリゲートプロパティを使用し、EKEventEditViewDelegateプロトコルを実装します。

00:07:40.000 --> 00:07:43.000
最後に、編集者を提示してください。

00:07:43.000 --> 00:07:47.000
現時点では、イベントはまだカレンダーに入っていません。

00:07:47.000 --> 00:07:56.000
追加ボタンをタップすると保存され、キャンセルをタップすると何も保存せずにエディタが閉じられます。

00:07:56.000 --> 00:08:07.000
EventKitUIでイベントを追加するより完全な例については、「EventKitとEventKitUIを使用してカレンダーにアクセスする」サンプルコードの「DropInLessons」ターゲットをチェックしてください。

00:08:07.000 --> 00:08:14.000
カレンダーにイベントを追加するもう1つの方法は、アプリでの予約にSiriイベントの提案を使用することです。

00:08:14.000 --> 00:08:18.000
Siri Event Suggestions APIは、Intents Frameworkの一部です。

00:08:18.000 --> 00:08:24.000
カレンダーアクセスのプロンプトを必要とせず、アプリにUIも表示されません。

00:08:24.000 --> 00:08:29.000
代わりに、これらのイベントは招待状のようにカレンダーの受信トレイに表示されます。

00:08:29.000 --> 00:08:34.000
その後、カレンダーに追加するか、無視することができます。

00:08:34.000 --> 00:08:47.000
Siriイベントの提案は、レストランやホテルの予約、フライトやレンタカーなどの旅行予約、コンサートやスポーツイベントなどのチケット付きイベントをサポートします。

00:08:47.000 --> 00:08:53.000
予約が後でキャンセルまたは変更された場合、イベントを更新できます。

00:08:53.000 --> 00:08:58.000
Siri Event Suggestions APIの使用は4段階のプロセスです。

00:08:58.000 --> 00:09:02.000
まず、INReservationを作成します。

00:09:02.000 --> 00:09:07.000
次に、意図と応答で予約をラップします。

00:09:07.000 --> 00:09:10.000
次に、INInteractionを作成します。

00:09:10.000 --> 00:09:14.000
最後に、インタラクションをシステムに寄付します。

00:09:14.000 --> 00:09:17.000
サンプルコードに飛び込みましょう。

00:09:17.000 --> 00:09:23.000
予約には、システムがそれを識別するために使用する一意の参照が必要です。

00:09:23.000 --> 00:09:32.000
一意の語彙識別子と話し言葉のフレーズを持つINSpeakableStringのインスタンスを作成して、その参照を作成します。

00:09:32.000 --> 00:09:37.000
このフレーズは、Siriと話すときにこの予約を参照するために使用できます。

00:09:37.000 --> 00:09:45.000
INDateComponentsRangeを使用して、予約の開始時刻と終了時刻を設定します。

00:09:45.000 --> 00:09:51.000
CLPlacemarkタイプを使用して、イベントに場所を指定します。

00:09:51.000 --> 00:09:57.000
次に、INReservationのサブクラスの1つのインスタンスを作成して、それをすべてまとめます。

00:09:57.000 --> 00:10:03.000
レストランの予約には、INRestaurantReservationを使用してください。

00:10:03.000 --> 00:10:10.000
この初期化子には、表示されないいくつかのオプションの引数があり、各サブクラスには独自の特定のオプションがあります。

00:10:10.000 --> 00:10:15.000
詳細については、ドキュメントを確認してください。

00:10:15.000 --> 00:10:22.000
次のステップは、予約参照でINGetReservationDetailsIntentを作成することです。

00:10:22.000 --> 00:10:31.000
次に、予約オブジェクトでINGetReservationDetailsIntentResponseを作成します。

00:10:31.000 --> 00:10:37.000
次に、意図と応答でINInteractionを作成します。

00:10:37.000 --> 00:10:43.000
最後に、インタラクションの寄付方法を呼び出します。

00:10:43.000 --> 00:10:49.000
この例は、Siriイベントの提案でできることの表面を引っ掻くだけです。

00:10:49.000 --> 00:10:59.000
Siriイベント提案の作成の詳細については、WWDC20の「Siriイベント提案でリーチを広げる」ビデオをご覧ください。

00:10:59.000 --> 00:11:04.000
EventKitUIまたはSiriイベントの提案は、イベントを追加するための最良の体験を提供します。

00:11:04.000 --> 00:11:17.000
アプリがカスタム編集UIを表示したり、同時に複数のイベントを追加したり、ユーザーとの対話なしでカレンダーにイベントを追加したりする必要がある場合にのみ、書き込み専用アクセスを使用してください。

00:11:17.000 --> 00:11:29.000
書き込み専用アクセスをリクエストするには、Info.plistにNSCalendarsWriteOnlyAccess UsageDescriptionキーを記載して、アプリがアクセスを必要とする理由を説明します。

00:11:29.000 --> 00:11:32.000
この文字列はリクエストプロンプトに表示されます。

00:11:32.000 --> 00:11:39.000
サンプルアプリケーションのプロンプトは次のとおりです。「繰り返しレッスンを選択したカレンダーに保存します。」

00:11:39.000 --> 00:11:43.000
書き込み専用アクセスにもいくつかの制限があります。

00:11:43.000 --> 00:11:47.000
一つには、人々はアクセスを許可しないことを選択するかもしれません。

00:11:47.000 --> 00:11:57.000
アクセスが許可されている場合、アプリは、同じアプリによって追加されたイベントを含め、カレンダーから既存のイベントを読み取ることができません。

00:11:57.000 --> 00:12:02.000
アプリはまた、カレンダーリストを読んだり、新しいカレンダーを作成したりすることはできません。

00:12:02.000 --> 00:12:06.000
書き込み専用アクセスは、iOS 17とmacOS Sonomaで新しく追加されたものです。

00:12:06.000 --> 00:12:16.000
これが既存のアプリにどのように影響するかの詳細については、「プライバシーの新機能」ビデオをご覧ください。

00:12:16.000 --> 00:12:22.000
書き込み専用アクセスで新しいイベントを追加すると、EventKitUIを使用して新しいイベントを追加するのと似ています。

00:12:22.000 --> 00:12:25.000
それは同じように始まります: イベントストアを作成します。

00:12:25.000 --> 00:12:29.000
次に、書き込み専用アクセスを要求します。

00:12:29.000 --> 00:12:34.000
アクセスが許可されている場合は、新しいイベントを作成し、詳細を入力します。

00:12:34.000 --> 00:12:37.000
最後に、イベントを保存します。

00:12:37.000 --> 00:12:40.000
それをもっと詳しく調べてみましょう。

00:12:40.000 --> 00:12:43.000
イベントストアを作成することから始めます。

00:12:43.000 --> 00:12:50.000
次に、requestWriteOnlyAccessToEventsメソッドを呼び出して、書き込み専用アクセスを要求します。

00:12:50.000 --> 00:12:54.000
戻り値は、アクセスが許可されたかどうかを示します。

00:12:54.000 --> 00:12:59.000
人々はアクセスを拒否することを選ぶことができるので、それを優雅に処理してください。

00:12:59.000 --> 00:13:11.000
アクセス要求は、アプリがアクセスを必要とする理由を人々が理解したときに承認される可能性が最も高いので、誰かが最初にそれを必要とする機能と対話したときにアクセスを要求する必要があります。

00:13:11.000 --> 00:13:15.000
次に、イベントを作成し、詳細を入力します。

00:13:15.000 --> 00:13:18.000
ここにはもう一つの重要な違いがあります。

00:13:18.000 --> 00:13:27.000
EventKitUIを使用すると、入力した詳細がエディタに表示され、入力されていないものはデフォルト値になります。

00:13:27.000 --> 00:13:32.000
EventKitで直接イベントを保存すると、何も入力されなくなります。

00:13:32.000 --> 00:13:35.000
あなたが設定したものは、保存されるものです。

00:13:35.000 --> 00:13:41.000
入力する必要があるプロパティがいくつかあります。そうしないと、保存が失敗します。

00:13:41.000 --> 00:13:44.000
必要なプロパティの1つはカレンダーです。

00:13:44.000 --> 00:13:52.000
イベントストアのdefaultCalendarForNewEventsプロパティを使用して、設定でデフォルトとして設定されたカレンダーを使用します。

00:13:52.000 --> 00:13:58.000
その他の必要なプロパティは、タイトル、開始日、終了日です。

00:13:58.000 --> 00:14:05.000
それ以外はすべてオプションですが、できるだけ記入するのが良いです。

00:14:05.000 --> 00:14:12.000
詳細が入力されたら、イベントストアの保存方法を使用してイベントを保存します。

00:14:12.000 --> 00:14:23.000
EventKitでイベントを追加する完全な例を見るには、「EventKitとEventKitUIを使用してカレンダーにアクセスする」サンプルプロジェクトの「RepeatingLessons」ターゲットをチェックしてください。

00:14:23.000 --> 00:14:31.000
カレンダーにイベントを追加したいアプリは、EventKitUI、Siriイベントの提案、または書き込み専用アクセスを使用する必要があります。

00:14:31.000 --> 00:14:38.000
カレンダーデータを読む必要があるごく少数のアプリには、フルアクセスがあります。

00:14:38.000 --> 00:14:48.000
アプリに既存のイベントの表示、更新、または削除が必要なコア機能がある場合にのみ、フルアクセスをリクエストしてください。

00:14:48.000 --> 00:14:57.000
フルアクセスをリクエストするには、Info.plistにNSCalendars FullAccessUsageDescriptionキーを含めてください。

00:14:57.000 --> 00:15:00.000
この文字列はリクエストプロンプトに表示されます。

00:15:00.000 --> 00:15:07.000
カレンダーには機密情報が含まれており、フルアクセスのプロンプトには、含まれているデータ量が記載されています。

00:15:07.000 --> 00:15:12.000
アプリがカレンダーを読むことを許可するには、多くの信頼が必要です。

00:15:12.000 --> 00:15:17.000
人々がまだあなたのアプリを信頼していない場合、リクエストは拒否される可能性があります。

00:15:17.000 --> 00:15:28.000
アプリのコアエクスペリエンスに不可欠な場合にのみフルアクセスを要求し、アクセスが必要な理由が明確になったときにのみ要求してください。

00:15:28.000 --> 00:15:34.000
アプリがコア機能のフルアクセスが必要な場合は、おそらくイベントを取得する必要があります。

00:15:34.000 --> 00:15:38.000
これを行うには、まずイベントストアを作成します。

00:15:38.000 --> 00:15:41.000
次に、フルアクセスをリクエストします。

00:15:41.000 --> 00:15:44.000
次に、述語を作成します。

00:15:44.000 --> 00:15:48.000
そして最後に、イベントストアからイベントを取得します。

00:15:48.000 --> 00:15:50.000
そのコードをチェックしてみましょう。 

00:15:50.000 --> 00:15:55.000
他の例と同様に、イベントストアを作成することから始めます。

00:15:55.000 --> 00:15:59.000
アプリにはイベントストアが1つしかないので、必ずこれを再利用してください。

00:15:59.000 --> 00:16:05.000
次に、requestFullAccessToEventsメソッドを呼び出してフルアクセスを要求します。

00:16:05.000 --> 00:16:10.000
これにより、プロンプトが表示され、アクセスが許可されたかどうかが返されます。

00:16:10.000 --> 00:16:15.000
フルアクセスプロンプトはより頻繁に拒否されるので、必ず処理してください。

00:16:15.000 --> 00:16:22.000
フルアクセスができたら、イベントストアのpredicateForEventsメソッドを呼び出して述語を作成します。

00:16:22.000 --> 00:16:28.000
述語は、日付範囲とオプションのカレンダーリストでフェッチするイベントを記述します。

00:16:28.000 --> 00:16:32.000
このコードは、現在の月の範囲を使用します。

00:16:32.000 --> 00:16:36.000
最高のパフォーマンスのために、可能な限り最短範囲を使用してください。

00:16:36.000 --> 00:16:42.000
カレンダーの引数がnilのままの場合、結果にはすべてのカレンダーのイベントが含まれます。

00:16:42.000 --> 00:16:51.000
最後に、一致するイベントの配列を返すイベントストアのevents(matching:)メソッドに述語を渡すことで、イベントを取得します。

00:16:51.000 --> 00:16:57.000
この配列のイベントは必ずしも順序付けられていないので、必要に応じて結果を並べ替えてください。

00:16:57.000 --> 00:17:10.000
イベントの取得の完全な例で遊びたい場合は、「EventKitとEventKitUIを使用してカレンダーにアクセスする」サンプルプロジェクトの「MonthlyEvents」ターゲットをチェックしてください。

00:17:10.000 --> 00:17:17.000
iOS 17とmacOS Sonomaより前のリリースをサポートするには、ランタイムの可用性チェックを実行します。

00:17:17.000 --> 00:17:24.000
iOS 17とmacOS Sonoma以降の新しいrequestAccessメソッドを呼び出します。

00:17:24.000 --> 00:17:30.000
以前のOSでは、レガシーrequestAccessメソッドを呼び出します。

00:17:30.000 --> 00:17:36.000
iOS 17またはmacOS Sonomaの前には、追加の使用文字列が必要です。

00:17:36.000 --> 00:17:42.000
カレンダーへのアクセスを要求するためのNSCalendarsUsageDescriptionキーを含めます。

00:17:42.000 --> 00:17:54.000
EventKitUIを使用するアプリには、EventKitUIがアプリの連絡先アクセスを要求するため、NSContactsUsageDescriptionキーも含める必要があります。

00:17:54.000 --> 00:18:01.000
アクセスを要求するときにアプリにこれらの文字列が欠落している場合、クラッシュします。

00:18:01.000 --> 00:18:10.000
これまでのところ、イベントを追加する方法とイベントの取得方法についていくつか説明しましたが、イベントを扱うことはカレンダーと統合する唯一の方法ではありません。

00:18:10.000 --> 00:18:19.000
アプリが音声通話またはビデオ通話をサポートしている場合は、仮想会議拡張機能を使用して、通話をイベントに直接追加できるようにします。

00:18:19.000 --> 00:18:23.000
これらの拡張機能を使用するには2つの方法があります。

00:18:23.000 --> 00:18:30.000
イベントに場所を追加すると、カスタム仮想会議オプションが場所ピッカーに表示されます。

00:18:30.000 --> 00:18:36.000
この例には、FaceTimeとSkypeの仮想会議の拡張機能によって提供されるオプションがあります。

00:18:36.000 --> 00:18:41.000
これらのいずれかをタップすると、その仮想会議がイベントに追加されます。

00:18:41.000 --> 00:18:48.000
仮想会議があるイベントには、イベントの詳細にカスタム参加オプションが表示されます。

00:18:48.000 --> 00:18:53.000
仮想会議の拡張には、ほんの数ステップで実行できます。

00:18:53.000 --> 00:18:58.000
まず、Xcodeで新しい仮想会議拡張ターゲットを作成します。

00:18:58.000 --> 00:19:03.000
次に、拡張プロトコルには実装する2つの方法があります。

00:19:03.000 --> 00:19:16.000
fetchAvailableRoomTypesを実装して利用可能なルームタイプを提供し、fetchVirtualConferenceを実装して、選択したルームタイプの仮想会議オブジェクトを提供します。

00:19:16.000 --> 00:19:18.000
例を見てみましょう。 例を見てみましょう。

00:19:18.000 --> 00:19:23.000
まず、Xcodeで仮想会議の拡張ターゲットを作成します。

00:19:23.000 --> 00:19:29.000
新しいターゲットには、EKVirtualConferenceProviderのスタブされたサブクラスがあります。

00:19:29.000 --> 00:19:34.000
オーバーライドする最初の方法は、fetchAvailableRoomTypesです。

00:19:34.000 --> 00:19:39.000
部屋タイプはロケーションピッカーに表示されます。

00:19:39.000 --> 00:19:42.000
各部屋タイプのタイトルを選択してください。

00:19:42.000 --> 00:19:47.000
これは、アプリアイコンの横にあるUIに表示されます。

00:19:47.000 --> 00:19:51.000
また、各部屋タイプの一意の識別子を選択します。

00:19:51.000 --> 00:19:58.000
この識別子は、どの部屋タイプが選択されたかを拡張機能に知らせるために使用されます。

00:19:58.000 --> 00:20:05.000
タイトルと識別子を使用して、EKVirtualConferenceRoomTypeDescriptorのインスタンスを作成します。

00:20:05.000 --> 00:20:11.000
アプリが複数の部屋タイプをサポートしている場合は、それぞれにインスタンスを作成してください。

00:20:11.000 --> 00:20:16.000
最後に、部屋タイプの配列を返します。

00:20:16.000 --> 00:20:20.000
次に実装する方法はfetchVirtualConferenceです。

00:20:20.000 --> 00:20:24.000
これは、部屋タイプの1つが選択されたときに呼び出されます。

00:20:24.000 --> 00:20:29.000
識別子引数は、どの部屋が選択されたかを示します。

00:20:29.000 --> 00:20:37.000
仮想会議には、カレンダーに参加方法を伝える1つ以上のURL記述子があります。

00:20:37.000 --> 00:20:45.000
開くURLとオプションのタイトルを持つEKVirtualConferenceURLDescriptorを作成します。

00:20:45.000 --> 00:20:51.000
URLにユニバーサルリンクを使用して、アプリを直接開くことができます。

00:20:51.000 --> 00:20:55.000
タイトルは、複数の参加オプションを区別するのに役立ちます。

00:20:55.000 --> 00:21:01.000
参加する方法は1つしかないので、ここでは必要ありません。

00:21:01.000 --> 00:21:05.000
詳細文字列に追加情報を入力します。

00:21:05.000 --> 00:21:12.000
このテキストは、イベント詳細UIの特別な仮想会議セクションに含まれます。

00:21:12.000 --> 00:21:19.000
最後に、これらすべてをまとめて、EKVirtualConferenceDescriptorを作成して返します。

00:21:19.000 --> 00:21:23.000
ここのタイトルは、複数の部屋タイプを区別するのに役立ちます。

00:21:23.000 --> 00:21:30.000
この例には1つの部屋タイプしかないので、タイトルはゼロのままです。

00:21:30.000 --> 00:21:38.000
これら2つの方法だけで、アプリは仮想会議のオプションとしてカレンダーアプリのロケーションピッカーに表示されます。

00:21:38.000 --> 00:21:45.000
カレンダーと統合するいくつかの異なる方法を取り上げたので、アプリがどのように貢献できるかを考えてください。

00:21:45.000 --> 00:21:51.000
EventKitUIまたはSiriイベントの提案を使用して、アクセスを要求せずにイベントを追加します。

00:21:51.000 --> 00:21:58.000
アクセスをリクエストする必要がある場合は、必要な最小限のアクセスをリクエストし、必要な場合にのみリクエストしてください。

00:21:58.000 --> 00:22:04.000
また、音声またはビデオ通話アプリをお持ちの場合は、仮想会議拡張機能を実装してください。

00:22:04.000 --> 00:22:07.000
あなたのアプリがカレンダーとどのように統合されるかを見るのが待ちきれません。

00:22:07.000 --> 00:22:09.000
見てくれてありがとう。

00:22:09.000 --> 23:59:59.000
♪ ♪

