WEBVTT

00:00:00.000 --> 00:00:11.000
♪ ♪

00:00:11.000 --> 00:00:12.000
ローマン・エフィモフ:みなさん、こんにちは。

00:00:12.000 --> 00:00:16.000
私の名前はローマン・エフィモフで、ショートカットチームのエンジニアです。

00:00:16.000 --> 00:00:23.000
今日は、App Intentsのエキサイティングな新機能と機能強化を取り上げ、さらに優れたアプリを作成するお手伝いをします。

00:00:23.000 --> 00:00:26.000
まず、ウィジェットから始めます。

00:00:26.000 --> 00:00:31.000
ご存知のように、ウィジェットはiOSのユーザーエクスペリエンスのますます重要な部分になっています。

00:00:31.000 --> 00:00:41.000
そして今、アプリのインテントとウィジェットはシームレスに連携し、インタラクティブ性と構成を通じて新しい体験を提供します。

00:00:41.000 --> 00:00:45.000
次に、今年行った開発者体験の改善に移ります。

00:00:45.000 --> 00:00:53.000
フレームワークのサポートや、静的抽出の最近の強化など、いくつかの品質改善について説明します。

00:00:53.000 --> 00:00:59.000
そして最後に、App Intentsとのショートカットアプリの統合のアップデートに飛び込みます。

00:00:59.000 --> 00:01:05.000
私たちはかなりぎっしり詰まった議題を持っているので、ウィジェットのエキサイティングなアップデートから始めましょう。

00:01:05.000 --> 00:01:09.000
まず、ウィジェットの設定について話しましょう。

00:01:09.000 --> 00:01:19.000
設定可能なウィジェットを作成するときに、ウィジェットの裏側でその人が選択できるようにするオプションを指定できます。

00:01:19.000 --> 00:01:31.000
これらのオプションはパラメータと呼ばれ、アプリにSiriとショートカットのサポートを追加するために使用するのと同じシステムを使用してそれらを定義できます: 意図。

00:01:31.000 --> 00:01:39.000
ウィジェットの設定UIは、対応するインテントに含まれるパラメータの順序付きリストを表示します。

00:01:39.000 --> 00:01:46.000
インテントに追加された各パラメータは、ウィジェット設定インターフェイスで行として表示されます。

00:01:46.000 --> 00:01:53.000
以前は、インテント定義ファイルを使用してXcodeでインテントを宣言する必要がありました。

00:01:53.000 --> 00:02:04.000
iOS 17では、ウィジェット拡張コードでApp Intentsを使用して、ウィジェットの設定のスキーマを定義することをさらに簡単にしました。

00:02:04.000 --> 00:02:17.000
これを行うには、まず、以前にウィジェットの設定に使用した可能性のあるIntentConfigurationの代わりに、AppIntentConfiguration WidgetConfigurationタイプの使用を開始する必要があります。

00:02:17.000 --> 00:02:24.000
次に、WidgetConfigurationIntentプロトコルに準拠した新しいタイプを定義します。

00:02:24.000 --> 00:02:33.000
WidgetConfigurationIntentはApp Intentのサブプロトコルであり、Widget Extensionコードで直接準拠できます。

00:02:33.000 --> 00:02:41.000
私は、特定の停留所の次の定期バスの時間とルートを表示するバススケジュールアプリのウィジェットに取り組んできました。

00:02:41.000 --> 00:02:48.000
これにより、完全なアプリを開くことなく、次のバスがいつ到着するかをすばやく確認できます。

00:02:48.000 --> 00:02:53.000
App Intentsを使用して、ウィジェットの設定Intentを提供します。

00:02:53.000 --> 00:03:18.000
ユーザーが次のバスウィジェットを設定できるようにするには、WidgetConfigurationIntentプロトコルに準拠し、次のパラメータを含む構造体を定義することから始めます。保存された停留所のリストから選択されたバス停、または新しい停留所、特定のバスルート、および選択したルートの移動方向を検索します。

00:03:18.000 --> 00:03:28.000
ウィジェットの設定に必要なパラメータの定義が完了したら、各パラメータタイプに動的オプションを提供する必要があります。

00:03:28.000 --> 00:03:35.000
以前は、パラメータの動的オプションを提供するには、別のインテント拡張を作成する必要がありました。

00:03:35.000 --> 00:03:45.000
App Intentsを使用すると、ウィジェット拡張機能内で直接クエリと動的オプションプロバイダーを実装でき、よりクリーンで効率的なプロジェクトにつながります。

00:03:45.000 --> 00:03:52.000
動的オプションプロバイダーとクエリの詳細については、「Dive into App Intents」ビデオをチェックすることをお勧めします。

00:03:52.000 --> 00:03:57.000
では、既存のウィジェットをSiriKitからApp Intentsに移行することについて話しましょう。

00:03:57.000 --> 00:04:02.000
既存のウィジェット設定をApp Intentsに移行するのは簡単です。

00:04:02.000 --> 00:04:06.000
実際、Xcodeでワンクリックで行うことができます。

00:04:06.000 --> 00:04:15.000
ウィジェットを移行すると、ウィジェットをアプリインテントに変換する前に、最新のOSバージョンと以前のバージョンの両方をサポートできます。

00:04:15.000 --> 00:04:18.000
既存の設定済みのウィジェットは引き続き動作できます。

00:04:18.000 --> 00:04:25.000
以前のOSバージョンをサポートする必要がなくなったら、SiriKit Intent定義ファイルを削除できます。

00:04:25.000 --> 00:04:36.000
移行するには、Intent定義ファイル内のSiriKitウィジェット設定Intentに移動し、[App Intentに変換]ボタンをクリックします。

00:04:36.000 --> 00:04:42.000
Xcodeは、古いIntent定義と同等のApp Intentsコードを生成します。

00:04:42.000 --> 00:04:53.000
スキーマが同じであることを確認する必要があります。つまり、すべてのApp Intentパラメータ名とタイプは、Intent定義にあるものと一致する必要があります。

00:04:53.000 --> 00:04:56.000
App Intentに新しいパラメータを自由に追加してください。

00:04:56.000 --> 00:05:01.000
オプションのパラメータ、またはデフォルト値を持つ必須のパラメータを追加することもできます。

00:05:01.000 --> 00:05:11.000
パラメータが追加される前に作成された既存のウィジェットは、そのパラメータの空の値、または指定した場合はデフォルト値を選択します。

00:05:11.000 --> 00:05:22.000
以前のiOSバージョンで人々をサポートし、その新しいパラメータを使用させる予定がある場合は、SiriKit Intent定義ファイルを維持し、そこに新しいパラメータを追加する必要があります。

00:05:22.000 --> 00:05:28.000
顧客がアプリを更新するたびに、ウィジェットは自動的に移行されます。

00:05:28.000 --> 00:05:35.000
アプリには1回しか機会がないため、移行がスムーズに進むことをテストすることが重要です。

00:05:35.000 --> 00:05:41.000
移行の詳細については、「カスタムインテントをアプリのインテントに移行する」ビデオを見ることをお勧めします。

00:05:41.000 --> 00:05:45.000
ウィジェットのインタラクティブ性に移ります。

00:05:45.000 --> 00:05:57.000
ウィジェットはボタンのタップやトグルに反応し、ホーム画面から直接設定を調整したり、メディアを再生したり、アプリからその他の重要な機能にアクセスしたりできるようになりました。

00:05:57.000 --> 00:06:02.000
ネクストバスウィジェットでは、タイムボタンをタップ可能にしたいと思います。

00:06:02.000 --> 00:06:11.000
人々がこれらのボタンの1つをタップすると、アプリでアラームを設定して、いつ出発すべきかを正確に把握して、バスに乗り遅れないようにしたい!

00:06:11.000 --> 00:06:13.000
どうや 

00:06:13.000 --> 00:06:21.000
SwiftUIボタンとトグルは、アプリのインテントをサポートするように更新され、ウィジェットにインタラクティブ性を簡単に追加できます。

00:06:21.000 --> 00:06:27.000
以前にアプリインテントを実装した場合は、すぐにそれに慣れているはずです。

00:06:27.000 --> 00:06:32.000
まず、App Intentプロトコルに準拠した構造体を定義する必要があります。

00:06:32.000 --> 00:06:43.000
次に、パラメータプロパティラッパーでキープロパティに注釈を付けて、アクションを実行するために関連情報が必要であることをシステムに知らせます。

00:06:43.000 --> 00:06:48.000
その後、実際にアクションを実行する実行メソッドを実装する必要があります。

00:06:48.000 --> 00:06:56.000
最後に、ウィジェットビューでは、SetAlarmアプリの意図をボタンに関連付けるだけです。

00:06:56.000 --> 00:07:04.000
SwiftUIとApp Intentsの統合は、インタラクティブなウィジェットだけでなく、通常のSwiftUIアプリでも利用できます。

00:07:04.000 --> 00:07:12.000
コードをApp Intentsに統合することで、冗長性を減らし、アプリ全体で一貫した動作を確保できます。

00:07:12.000 --> 00:07:21.000
アプリインテントは、構成とインタラクティブアクションのプロバイダーの両方として機能するため、ショートカットのインテントコードを再利用するのは非常に簡単です。

00:07:21.000 --> 00:07:34.000
たとえば、ShowNextBusウィジェット構成インテントは、ウィジェット構成とショートカットアクションの両方として使用でき、必要なときに最新情報を提供できます。

00:07:34.000 --> 00:07:46.000
さらに、ウィジェットにインタラクティブ性を追加するために使用したアプリインテントは、優れたショートカットアクションとしても機能し、人々が好みのバス到着時刻のアラームを設定できるようにします。

00:07:46.000 --> 00:07:52.000
ウィジェットのインタラクティブ性の詳細については、「ウィジェットに命を吹き込みます」をチェックしてください。

00:07:52.000 --> 00:07:59.000
ウィジェット設定の機能とデザインを強化できるいくつかの高度なテクニックに移りましょう。

00:07:59.000 --> 00:08:04.000
まず、動的オプションとクエリの強化について話しましょう。

00:08:04.000 --> 00:08:19.000
動的オプションは、App Intentのパラメータに利用可能な値を提供するためのインターフェイスであり、DynamicOptionsProviderまたはEntityQueryプロトコルファミリに準拠することで実装できます。

00:08:19.000 --> 00:08:29.000
場合によっては、別のパラメータの値に基づく特定の条件が満たされた場合にのみ利用可能なオプションを表示したい場合があります。

00:08:29.000 --> 00:08:39.000
たとえば、ウィジェットの設定では、バス停パラメータに基づいて利用可能なルートオプションのみを表示したいと考えています。

00:08:39.000 --> 00:08:46.000
これを行うには、iOS 17でIntentParameterDependencyと呼ばれる新しいAPIを使用できます。

00:08:46.000 --> 00:08:54.000
これは、DynamicOptionsProviderまたはクエリ内で、インテントからパラメータにアクセスできるプロパティラッパーです。

00:08:54.000 --> 00:09:01.000
これらのパラメータを読み取り、それらを使用して、より動的でコンテキストを意識したオプションを作成できます。

00:09:01.000 --> 00:09:07.000
私の例では、ユーザーが選択したバス停でフィルタリングされた利用可能なバス路線を返します。

00:09:07.000 --> 00:09:15.000
IntentParameterDependencyは、ウィジェット、ショートカット、フォーカスフィルターなど、すべての環境で機能します。

00:09:15.000 --> 00:09:22.000
私の例では、EntityQueryプロトコルに準拠したBusRouteQueryという構造体があります。

00:09:22.000 --> 00:09:30.000
この構造体には、IntentParameterDependencyプロパティラッパーでラップされたShowNextBusというプロパティがあります。

00:09:30.000 --> 00:09:39.000
これは、バスルートクエリがshowNextBus App Intent、特にバス停パラメータに依存していることを意味します。

00:09:39.000 --> 00:09:42.000
suggestedEntitiesメソッドに注目してください。

00:09:42.000 --> 00:09:45.000
提案されたルートオブジェクトの配列を返します。

00:09:45.000 --> 00:09:50.000
まず、showNextBus Intentプロパティが非nilであるかどうかをチェックします。

00:09:50.000 --> 00:09:59.000
その場合は、利用可能なルートをフィルタリングして、指定されたバス停に一致するルートのみが表示されます。

00:09:59.000 --> 00:10:04.000
IntentParameterDependencyは、複数のパラメータに依存することもできます。

00:10:04.000 --> 00:10:12.000
たとえば、方向クエリでは、バス停とルートパラメータの両方を使用して方向オプションを提供したいと考えています。

00:10:12.000 --> 00:10:18.000
また、同じクエリまたは動的オプションプロバイダー内の複数のアプリインテントに依存することもできます。

00:10:18.000 --> 00:10:26.000
私の方向クエリは、ShowNextBusとShowFavoriteRouteの2つのインテントからパラメータを読み取ります。

00:10:26.000 --> 00:10:39.000
IntentParameterDependency プロパティ ラッパーは、ShowNextBus Intent の busStop パラメータとルート パラメータ、および ShowFavoriteRoute Intent の route パラメータの依存関係を指定するために使用されます。

00:10:39.000 --> 00:10:50.000
ルート計算プロパティは、どちらが利用可能かに応じて、showNextBusまたはshowFavoriteRouteのいずれかから値を返します。

00:10:50.000 --> 00:10:54.000
ウィジェットの設定には、多くの場合、配列パラメータがあります。

00:10:54.000 --> 00:11:00.000
たとえば、私のお気に入りのルートウィジェットは、人のお気に入りのルートのバススケジュールを表示できます。

00:11:00.000 --> 00:11:06.000
ただし、画面スペースが限られているため、最大3つのルートしか選択できないはずです。

00:11:06.000 --> 00:11:09.000
では、どうすればそれを宣言できますか?

00:11:09.000 --> 00:11:15.000
iOS 17の新機能で、Arrayパラメータを定義するときにサイズを宣言できるようになりました。

00:11:15.000 --> 00:11:25.000
ここのサイズは、大きなウィジェットが小さなウィジェットよりも多くのアイテムを収容できる場合があるため、ウィジェットファミリからアレイサイズへのマッピングを受け入れることもできます。

00:11:25.000 --> 00:11:35.000
ウィジェット設定アプリの意図とそのパラメータを定義したら、これらのパラメータのどれがいつユーザーに表示されるかを定義したいと思うかもしれません。

00:11:35.000 --> 00:11:40.000
ParameterSummaryは、App Intentのパラメータの視覚的表現を定義します。

00:11:40.000 --> 00:11:47.000
ショートカットエディタ、フォーカスフィルター、およびウィジェット設定でアプリインテントの外観を強化します。

00:11:47.000 --> 00:11:54.000
パラメータサマリーを使用して、どのパラメータが表示され、どの条件で表示されるかを定義できます。

00:11:54.000 --> 00:12:03.000
ウィジェットの場合、UIは最初に要約文のパラメータを表示し、次にクロージャにリストされている追加のパラメータを表示します。

00:12:03.000 --> 00:12:13.000
ここでは、文にはルートパラメータが含まれており、クロージャにはincludeWeatherInfoが含まれているため、設定UIでその順序で表示されます。

00:12:13.000 --> 00:12:22.000
iOS 17の新機能で、ウィジェットファミリでWhenステートメントを使用できるようになりました。ウィジェットのサイズに基づいてウィジェットの設定を変更できます。

00:12:22.000 --> 00:12:32.000
たとえば、大きなウィジェットでのみ気象情報を表示するトグルを表示したいのですが、他のサイズにはこの機能はありません。

00:12:32.000 --> 00:12:39.000
そこで、大きなウィジェットに対してのみ、パラメータサマリーにincludeWeatherInfoパラメータを追加します。

00:12:39.000 --> 00:12:45.000
そうでなければ、小さなウィジェットの場合は追加しないので、パラメータは非表示になります。

00:12:45.000 --> 00:12:52.000
App Intentsを使用してウィジェットの設定を実装したので、その人がそれをタップしたときに何が起こるかを判断するにはどうすればよいですか?

00:12:52.000 --> 00:12:57.000
その人は、私のウィジェットのどこかをタップするたびに、私のアプリに連れて行かれます。

00:12:57.000 --> 00:13:06.000
ウィジェットの設定で選択した特定のルートに関する情報を表示する画面に直接移動したいと思います。

00:13:06.000 --> 00:13:17.000
ユーザーがウィジェットをタップしてアプリを起動すると、ユーザーアクティビティでwidgetConfigurationIntentメソッドを呼び出すことで、関連する設定Intentを取得できます。

00:13:17.000 --> 00:13:22.000
アプリインテントを取得したら、それを使用してアプリのUIを適宜更新できます。

00:13:22.000 --> 00:13:32.000
ここでは、Configuration Intentからコンテンツを抽出し、それを使用して、対応する停留所とルートの特定のバス停ビューにアプリをナビゲートします。

00:13:32.000 --> 00:13:38.000
ウィジェットを構築するときは、人々がスマートスタックで適切なタイミングでそれを見るようにしたいと思うでしょう。

00:13:38.000 --> 00:13:46.000
これを行うには、iOSとwatchOSのウィジェットの提案に新しいRelevantContext APIを使用できます。

00:13:46.000 --> 00:14:03.000
以前のINInteraction、INDailyRoutine、およびINRelevantShortcut APIからインスピレーションを得て、よりスウィフトフレンドリーで、アプリインテントとシームレスに連携するように、新しいRelevantIntentManagerとRelevantIntentを設計しました。

00:14:03.000 --> 00:14:08.000
ゲーム中にウィジェットを浮上させたいスポーツアプリを想像してみてください。

00:14:08.000 --> 00:14:14.000
新しいRelevantContext APIを使用すると、このインテントと関連する日付範囲を指定できます。

00:14:14.000 --> 00:14:27.000
この関連する日付情報を提供することで、スポーツアプリウィジェットはスマートスタック内で自動的に提案され、人々が最も重要なときにゲーム情報に簡単にアクセスできるようにします。

00:14:27.000 --> 00:14:32.000
関連性APIは、時計のコンプリケーションを浮上させるのにも最適です。

00:14:32.000 --> 00:14:40.000
watchOSの関連性の詳細については、「Apple Watchでスマートスタック用のウィジェットを構築する」をチェックしてください。

00:14:40.000 --> 00:14:47.000
ウィジェットを取り上げたので、iOS 17とXcode 15で行った開発者体験の改善に飛び込みましょう。

00:14:47.000 --> 00:14:50.000
フレームワークサポートから始めます。

00:14:50.000 --> 00:15:02.000
アプリがメインアプリとApp Intents拡張機能の両方からApp Intentsを実行する機能が必要な場合は、現在、App Intentコードを両方のターゲットにコンパイルする必要があります。

00:15:02.000 --> 00:15:12.000
残念ながら、このアプローチはコードの重複につながり、メンテナンスの問題が発生し、エラーや矛盾の可能性を高める可能性があります。

00:15:12.000 --> 00:15:20.000
これはまた、バイナリサイズを肥大化し、アプリのパフォーマンスと人々のダウンロード時間に悪影響を及ぼす可能性があります。

00:15:20.000 --> 00:15:29.000
iOS 17とXcode 15では、フレームワークがアプリの意図を直接公開できるようになったので、コードを2回コンパイルする必要はもうありません。

00:15:29.000 --> 00:15:35.000
AppIntentsPackage APIを使用して、アプリ内の依存関係を再帰的にインポートできるようになりました。

00:15:35.000 --> 00:15:45.000
AppIntentsPackageプロトコルにタイプを適合させることで、アプリとフレームワークの両方が他のフレームワークからメタデータを再エクスポートできます。

00:15:45.000 --> 00:15:50.000
フレームワークサポートを使用して、バススケジュールアプリの実装を簡素化します。

00:15:50.000 --> 00:15:58.000
バススケジュールを表示するためのさまざまなアプリインテントを提供するBusScheduleIntentsというフレームワークがあります。

00:15:58.000 --> 00:16:03.000
依存関係なく再輸出できるようになります。

00:16:03.000 --> 00:16:11.000
私は、バススケジュールアプリのカスタムインターフェイス要素を提供するBusScheduleUIと呼ばれる別のフレームワークを持っています。

00:16:11.000 --> 00:16:17.000
このフレームワークは、BusScheduleIntentsフレームワークに依存し、再エクスポートします。

00:16:17.000 --> 00:16:23.000
最後に、バススケジュールアプリからBusScheduleUIフレームワークをインポートします。

00:16:23.000 --> 00:16:29.000
AppIntentsPackageはプロトコルなので、SwiftUIアプリの構造体にそれを適合させることができます。

00:16:29.000 --> 00:16:35.000
バススケジュールアプリは、BusScheduleUIフレームワークへの直接的な依存について言及するだけで済みます。

00:16:35.000 --> 00:16:44.000
ShowSchedule App Intentを実行することで、お気に入りのバスルートを表示するSwiftUIボタンをバススケジュールアプリ内に作成できるようになりました。

00:16:44.000 --> 00:16:58.000
同じアプリインテントであるShowScheduleは、ショートカットユーザーも利用できます。つまり、カスタムショートカットを作成して、アプリを開かずにお気に入りのバス路線のスケジュールにすばやくアクセスできます。

00:16:58.000 --> 00:17:05.000
アプリインテントをフレームワークに移動すると、コードベースがよりシンプルで合理化されます。

00:17:05.000 --> 00:17:17.000
新しいフレームワークのサポートは、アプリとウィジェット拡張機能の両方から同じインテントにアクセスする必要がある可能性があるため、アプリインテントでウィジェットを構築する場合に特に素晴らしいです。

00:17:17.000 --> 00:17:27.000
App Intentsコードをよりモジュラーに保つためのもう1つのヒント：AppShortcutsProviderを作成し、App Intents拡張機能でApp Shortcutsを定義できるようになりました。

00:17:27.000 --> 00:17:33.000
以前は、メインのアプリバンドルでアプリのショートカットを完全に定義する必要がありました。

00:17:33.000 --> 00:17:38.000
これは、アプリショートカットが実行されているときに、アプリが常にバックグラウンドで起動されることを意味します。

00:17:38.000 --> 00:17:43.000
これで、App Intents拡張機能でApp Shortcutsを定義できます。

00:17:43.000 --> 00:17:55.000
これは、メインアプリ全体よりも高速にApp Intents拡張機能を最適化し、UI、分析、またはその他の重要でないコードの起動を避けることができるため、パフォーマンスに最適です。

00:17:55.000 --> 00:18:01.000
これらの機能はすべて、Xcode 15で行った静的メタデータ抽出の強化に依存しています。

00:18:01.000 --> 00:18:08.000
それでは、コードが構築されている間、App Intentsのコンテンツがどのように静的に抽出されるかについて話しましょう。

00:18:08.000 --> 00:18:19.000
Swiftコンパイラは、コードで利用可能な型に関する情報と、App Intentsの実装から型レベルと値レベルの情報を出力します。

00:18:19.000 --> 00:18:33.000
別のツールは、この情報を解析して、ビルド製品にMetadata.appIntentsディレクトリを生成します。これには、アプリの意図、パラメータ、エンティティ、クエリなどを記述するファイルが含まれています。

00:18:33.000 --> 00:18:38.000
Xcode 15では、静的抽出プロセスが大幅に改善されました。

00:18:38.000 --> 00:18:44.000
今ではより速く、より信頼性が高く、これまで以上に多くのケースで機能します。

00:18:44.000 --> 00:19:02.000
Xcode 15でアプリを構築する場合、Xcodeが期待するものを静的に抽出できない場合は、行番号とともにXcodeエディタに直接エラーメッセージが表示されるので、どこに行って問題を解決すべきかがわかります。

00:19:02.000 --> 00:19:11.000
ショートカットの統合について話す前に、今年App Intentsに追加した2つの素晴らしい能力があり、言及する価値があります。

00:19:11.000 --> 00:19:19.000
まず、そのインテントが以前にバックグラウンドで実行されていたとしても、アプリでインテントの実行を継続する機能です。

00:19:19.000 --> 00:19:23.000
私たちはこれをForegroundContinuableIntentプロトコルと呼んでいます。

00:19:23.000 --> 00:19:37.000
たとえば、次のバスを取得するアプリインテントが、無効なパラメータや接続の問題のためにバススケジュールを取得できない場合、問題を解決するためにアプリで続行するように依頼することができます。

00:19:37.000 --> 00:19:43.000
そのために、まず、App IntentをForegroundContinuableIntentプロトコルに適合させます。

00:19:43.000 --> 00:19:54.000
ForegroundContinuableIntentプロトコルは、最初にバックグラウンドで作業を開始するが、フォアグラウンドで継続を要求する必要がある可能性のあるインテント向けに設計されています。

00:19:54.000 --> 00:20:00.000
次に、needsToContinueInForegroundErrorメソッドを呼び出すと、エラーが返されます。

00:20:00.000 --> 00:20:08.000
そのエラーをスローすると、システムはApp Intentの実行を停止し、フォアグラウンドで実行を続行するようユーザーに求めます。

00:20:08.000 --> 00:20:18.000
また、フォアグラウンドに入った後にアプリの状態を更新するために、メインスレッドで実行されるオプションの継続クロージャを提供することもできます。

00:20:18.000 --> 00:20:23.000
ここでは、このクロージャを使用して、アプリをエラー画面に移動しています。

00:20:23.000 --> 00:20:33.000
前の例のように、インテントの実行を停止し、続行するアクションを要求する場合は、needsToContinueInForegroundErrorを使用します。

00:20:33.000 --> 00:20:41.000
アプリインテントを完全に停止するのではなく、引き続き実行したい場合は、使用できる別のAPIがあります。

00:20:41.000 --> 00:20:45.000
その場合は、requestToContinueInForegroundメソッドを呼び出します。

00:20:45.000 --> 00:20:56.000
バスアプリがバスルートにメンテナンスの問題があることを検出し、アプリでカスタムUIを表示して代替ルートを選択したいときに、これを使用するかもしれません。

00:20:56.000 --> 00:21:05.000
人がルートを選択したら、アプリからその更新されたルートを返し、アプリインテントの実行を続けることができます。

00:21:05.000 --> 00:21:12.000
今回は、エラーをスローする代わりに、単にtry and awaitでメソッドを呼び出しています。

00:21:12.000 --> 00:21:18.000
渡されたクロージャは値を返すことができ、私はそれを私のパフォーマンス内に戻すことができます。

00:21:18.000 --> 00:21:24.000
これにより、ユーザーから入力を得た後、アプリインテントの実行を続けることができます。

00:21:24.000 --> 00:21:32.000
ここでは、ユーザーが選択した代替ルートを取り、そのルートの次のバスを示すスニペットを返します。

00:21:32.000 --> 00:21:39.000
要約すると、App Intentの実行を完全に停止したい場合は、スローメソッドを使用します。

00:21:39.000 --> 00:21:50.000
それ以外の場合は、その人から結果を取得し、それを使用してApp Intentの実行を完了したい場合は、requestToContinueInForegroundを使用して結果を待ちます。

00:21:50.000 --> 00:21:54.000
今年は、App IntentsにApple Payのサポートも追加しました。

00:21:54.000 --> 00:22:00.000
実行方法内で直接Apple Payトランザクションを開始できるようになりました。

00:22:00.000 --> 00:22:03.000
パフォーマンスでApple Payを使うのは簡単です。

00:22:03.000 --> 00:22:10.000
PKPaymentRequestインスタンスを作成し、必要な情報で設定します。

00:22:10.000 --> 00:22:19.000
次に、PKPaymentAuthorizationControllerを使用してApple Payの支払いシートを提示し、承認を処理します。

00:22:19.000 --> 00:22:23.000
ガードステートメントは、コントローラーが正常に提示されたかどうかを確認します。

00:22:23.000 --> 00:22:27.000
そうでない場合は、「支払いを処理できません」というダイアログを返します。

00:22:27.000 --> 00:22:31.000
そうでなければ、支払いは正常に処理されます。

00:22:31.000 --> 00:22:37.000
最後に、App IntentsとShortcutsアプリの統合に関するいくつかのアップデートを掘り下げてみましょう。

00:22:37.000 --> 00:22:42.000
アプリインテントが統合されているシステム内のさまざまな場所から始めましょう。

00:22:42.000 --> 00:22:53.000
App Intentsは、ショートカットアクションを構築するための最新の方法であり、App Shortcutsを使用すると、Siriとショートカットアプリでアプリの機能を簡単に見つけて使用できます。

00:22:53.000 --> 00:22:59.000
Apple Watch Ultraのフォーカスフィルターやアクションボタンとの統合もあります。

00:22:59.000 --> 00:23:11.000
iOS 17では、インタラクティブライブアクティビティ、ウィジェットの設定とインタラクティブ性、SwiftUIとの統合により、アプリインテントはさらに広くアクセスできるようになりました。

00:23:11.000 --> 00:23:17.000
アプリのショートカットも成長し、Spotlight Top HitsとAutomationsのサポートも含まれています。

00:23:17.000 --> 00:23:23.000
これらの統合はすべて、同じApp Intentsコードをさまざまな方法で再利用できることを意味します。

00:23:23.000 --> 00:23:34.000
アプリインテントは現在、主要なシステムコンポーネントに深く統合されているため、作成したアプリインテントが善良な市民であることを確認することが非常に重要です。

00:23:34.000 --> 00:23:42.000
優れたパラメータサマリーを提供することは、アプリインテントがシステム全体で表面化したときに見栄えを良くするために不可欠です。

00:23:42.000 --> 00:23:50.000
折り畳みの下に隠されたオプションのパラメータで、文のように読むようにパラメータの要約を書いてください。

00:23:50.000 --> 00:23:57.000
その後、システムは、コンテキストに基づいてパラメータサマリーの最適な視覚的表現を決定します。

00:23:57.000 --> 00:24:11.000
アプリインテントがどこでもうまく機能することが望ましいですが、アプリ内またはインタラクティブなウィジェットで使用するためにアプリインテントを作成する必要があり、システムの他の部分からそれらを非表示にしたい場合があります。

00:24:11.000 --> 00:24:19.000
たとえば、アプリインテントがアプリ内のローカル関数を呼び出すと、便利なショートカットアクションは実行されません。

00:24:19.000 --> 00:24:24.000
その場合、App IntentのisDiscoverableプロパティをfalseに設定できます。

00:24:24.000 --> 00:24:31.000
サーバーから最新のデータを取得するNext Busウィジェットに更新ボタンを追加します。

00:24:31.000 --> 00:24:35.000
それは私のウィジェットの目的を果たしますが、便利なショートカットアクションにはなりません。

00:24:35.000 --> 00:24:43.000
このアプリインテントをインタラクティブウィジェットからのみ使用したいので、isDiscoverableをfalseに設定します。

00:24:43.000 --> 00:24:49.000
検出不能とマークされたアプリインテントは、アプリショートカットにも参加できないことに注意してください。

00:24:49.000 --> 00:24:54.000
私のアプリのインテントはかなり迅速に実行されますが、すべてのインテントが実行されるわけではありません。

00:24:54.000 --> 00:25:00.000
今年は、長期的な意図に進歩を提供する新しい方法を導入しました。

00:25:00.000 --> 00:25:06.000
進捗状況を報告するには、App IntentをProgressReportingIntentプロトコルに準拠させるだけです。

00:25:06.000 --> 00:25:10.000
Perform() メソッド内では、提供された進捗オブジェクトにアクセスできます。

00:25:10.000 --> 00:25:19.000
totalUnitCountを設定し、Intentの実行が進むにつれてcompletementUnitCountをインクリメントして、進行状況を更新します。

00:25:19.000 --> 00:25:24.000
ショートカットアプリは、App Intentの実行の進行状況を自動的に表示するようになりました。

00:25:24.000 --> 00:25:28.000
進捗報告の実施は、長期にわたる意図にとって特に重要です。

00:25:28.000 --> 00:25:37.000
人々がそのフィードバックを持つことは本当に貴重なので、彼らは意図のパフォーマンスが前進し、それがいつ完了するかを知っています。

00:25:37.000 --> 00:25:42.000
今年は、アプリが検索アクションと統合する方法も改善しました。

00:25:42.000 --> 00:25:50.000
ショートカットユーザーは、メモを見つけるなどのアクションで、特定の基準でアプリ内のコンテンツを見つけることができるのが大好きです。

00:25:50.000 --> 00:25:58.000
これらのアクションの出力は、電子メールの送信など、他のショートカットアクションに送信でき、多くの強力なワークフローが可能になります。

00:25:58.000 --> 00:26:10.000
iOS 16では、EntityPropertyQueryを実装し、ユーザーが指定できる基準を宣言することで、アプリの検索アクションを自動的に取得できます。

00:26:10.000 --> 00:26:17.000
iOS 17以降、代わりにEnumerableEntityQueryプロトコルを使用することもできます。

00:26:17.000 --> 00:26:21.000
それは本当にシンプルで採用が簡単です。

00:26:21.000 --> 00:26:30.000
EnumerableEntityQueryの実装は、allEntities()メソッドでエンティティのすべての可能な値を返すのと同じくらい簡単です。

00:26:30.000 --> 00:26:36.000
ショートカットとアプリインテントはそこからそれを取り、自動的に検索アクションを生成します。

00:26:36.000 --> 00:26:50.000
EnumerableEntityQueryとEntityPropertyQueryの違いは、EntityPropertyQueryを使用すると、開発者、基準を送信し、ユーザーに代わって検索を実行することです。

00:26:50.000 --> 00:26:54.000
つまり、多くの場合、限られた一連の結果を返すことになります。

00:26:54.000 --> 00:27:02.000
EnumerableEntityQueryを使用すると、フレームワークにすべての可能なエンティティを与え、ショートカットがフィルタリングを行います。

00:27:02.000 --> 00:27:11.000
すべてのエンティティを返すため、EnumerableEntityQueryは本当に使いやすいですが、少数のエンティティにも最適化されています。

00:27:11.000 --> 00:27:20.000
Safariのタブグループなどのケースではうまく機能しますが、Notesアプリに典型的な多数のエンティティには適していません。

00:27:20.000 --> 00:27:24.000
また、多くのメモリを消費する非常に大きなエンティティには適していません。

00:27:24.000 --> 00:27:34.000
この場合、EntityPropertyQueryを使用して、すべての可能なエンティティを一度に返すのではなく、あなたの側で検索を実行できます。

00:27:34.000 --> 00:27:38.000
最後に、IntentDescriptionのアップデートについてお伝えしたいと思います。

00:27:38.000 --> 00:27:47.000
これは、アクションに関する詳細情報を取得するために詳細ボタンをタップしたときに人々が見るショートカットUIに記入するために使用するタイプです。

00:27:47.000 --> 00:27:52.000
IntentDescriptionには、説明テキスト、カテゴリ名、検索キーワードが含まれます。

00:27:52.000 --> 00:28:04.000
iOS 17では、Intent DescriptionタイプがresultValueNameという新しいプロパティで更新されたため、アクションの出力に対してよりわかりやすい名前を指定できます。

00:28:04.000 --> 00:28:13.000
ここで、「リマインダーを追加」は、作成して返されたリマインダーの「新しいリマインダー」の結果ValueNameを提供します。

00:28:13.000 --> 00:28:22.000
ここでの「リマインダーを追加」アクションが結果表示アクションに接続されている場合、結果表示アクションのパラメータには「新しいリマインダー」という名前が表示されます。

00:28:22.000 --> 00:28:27.000
resultValueNameを提供するには、IntentDescriptionで新しい初期化子を使用するだけです。

00:28:27.000 --> 00:28:40.000
iOS 17以降では、EntityPropertyQueryまたはEnumerableEntityQueryプロトコルを使用して生成された検索アクションのインテントの説明を含めることもできます。

00:28:40.000 --> 00:28:46.000
これを行うには、クエリタイプ内でfindIntentDescriptionプロパティを採用するだけです。

00:28:46.000 --> 00:28:57.000
アクションをcategoryNameで分類すると、アプリでサポートされているアクションのリストで、生成された検索アクションを目的のカテゴリの下に表示できます。

00:28:57.000 --> 00:29:05.000
要約すると、アプリインテントは、アプリの機能をシステムとユーザーに公開する素晴らしい方法です。

00:29:05.000 --> 00:29:16.000
アプリのインテントをアプリのショートカットに変えて、人々がすぐに使用できるようにする方法についてさらに学ぶには、「アプリのショートカットでアプリをスポットライトする」セッションをチェックすることをお勧めします。

00:29:16.000 --> 00:29:28.000
今年、App Intentsを使用すると、設定可能でインタラクティブなウィジェットとライブアクティビティを構築し、ショートカットアプリへのより深い統合により、さらにスムーズな開発者体験を提供します。

00:29:28.000 --> 00:29:34.000
あなたのアプリが新しいApp Intentsテクノロジーをどのように活用して驚きと喜びを喜ばせるかを見て、本当に興奮しています。

00:29:34.000 --> 00:29:36.000
参加してくれてありがとう。

00:29:36.000 --> 23:59:59.000
。

