WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:12.000
Siraj:みなさん、こんにちは。

00:00:12.000 --> 00:00:16.000
私の名前はSirajで、CoreLocationのエンジニアです。

00:00:16.000 --> 00:00:24.000
「Discover Streamlined Location Updates」に参加していただきありがとうございます。ここでは、場所を取得するための新しいCoreLocation APIについて話します。

00:00:24.000 --> 00:00:27.000
始めましょう。

00:00:27.000 --> 00:00:33.000
位置情報の更新を取得するのは、この1行のコードを書くのと同じくらい簡単です。

00:00:33.000 --> 00:00:35.000
なんてかっこいい！そうじゃないの？

00:00:35.000 --> 00:00:43.000
これは私たちの新しいSwiftネイティブAPIで、場所の更新を取得するための最新の迅速な並行性をすぐにサポートしています。

00:00:43.000 --> 00:00:45.000
では、深く掘り下げてみましょう。

00:00:45.000 --> 00:00:57.000
新しいCLLocationUpdate APIの構造を詳しく説明し、このAPIを使用して位置情報の更新を取得する方法について説明します。

00:00:57.000 --> 00:01:03.000
次に、バックグラウンドで位置情報の更新を取得するために何をする必要があるかを調べます。

00:01:03.000 --> 00:01:08.000
続いて、更新を自動的に一時停止して再開する方法が続きます。

00:01:08.000 --> 00:01:15.000
最後に、このAPIを通じて更新されるアプリのライフサイクルを説明して締めくくります。

00:01:15.000 --> 00:01:19.000
CLocationUpdate APIの構造を探りましょう。

00:01:19.000 --> 00:01:30.000
Updatesと呼ばれるAsyncSequenceを返す静的関数liveUpdatesを持つ新しいクラスCLLocationUpdateを導入しています。

00:01:30.000 --> 00:01:49.000
for/try/awaitを使用して直接反復して、CLLocationUpdateタイプの要素を生成し、CLLocationタイプの場所と、自動、一時停止、再開を管理するためのブールフラグisStationaryを生成します。

00:01:49.000 --> 00:01:56.000
liveUpdatesは、LiveConfiguration列挙型の選択的な引数も消費します。

00:01:56.000 --> 00:02:03.000
では、コードのウォークスルーを行い、この新しいAPIを使用して更新を取得する方法を見てみましょう。

00:02:03.000 --> 00:02:08.000
フォアグラウンドから位置情報の更新を開始する基本的なアプリを構築しましょう。

00:02:08.000 --> 00:02:11.000
最初にCoreLocationをインポートします。

00:02:11.000 --> 00:02:22.000
次に、CLLocationUpdateクラスによって提供される静的ファクトリ関数liveUpdatesを呼び出して、Updates AsyncSequenceを取得します。

00:02:22.000 --> 00:02:30.000
これは、for/try/awaitを使用して直接反復して、クロージャでCLLocationUpdateを取得できます。

00:02:30.000 --> 00:02:35.000
そして、その場所のプロパティにアクセスして場所を取得します。

00:02:35.000 --> 00:02:39.000
さて、この時点で私たちのアップデートが始まりました。

00:02:39.000 --> 00:02:42.000
私たちがそれを止めなければならない場合はどうですか?

00:02:42.000 --> 00:02:45.000
停止は、forループから壊れるのと同じくらい簡単です。

00:02:45.000 --> 00:02:48.000
isStationaryを覚えていますか？

00:02:48.000 --> 00:02:56.000
このisStationaryがtrueであると報告されたら、forループから抜け出し、自動的に更新を停止しましょう。

00:02:56.000 --> 00:03:00.000
明示的な開始メッセージと停止メッセージはもう必要ありません。

00:03:00.000 --> 00:03:06.000
CLLocationUpdate APIによって返されたAsyncSequenceを見てみましょう。

00:03:06.000 --> 00:03:17.000
要素の検索、選択、除外など、AsyncSequenceでできるすべての強力なことも、この更新シーケンスで実行できます。

00:03:17.000 --> 00:03:25.000
この例では、AsyncSequenceで最初のフィルターを直接使用する方法を説明します。

00:03:25.000 --> 00:03:31.000
ボンネットの下で更新が開始され、各要素の位置が速度がチェックされます。

00:03:31.000 --> 00:03:41.000
速度が200を超えるアップデートが見つかるとすぐに、その最初の要素が返され、操作が完了します。

00:03:41.000 --> 00:03:46.000
最初のマッチが見つかると、更新は自動的に停止します。

00:03:46.000 --> 00:03:48.000
しかし、あなたはここでのスピードに気づきましたか?

00:03:48.000 --> 00:03:54.000
これは毎秒200メートルなので、およそ時速約447マイルです。

00:03:54.000 --> 00:03:56.000
それは速すぎますよね?

00:03:56.000 --> 00:04:12.000
したがって、一致が見つかるまで実行がスタックするため、これらのフィルターを使用する際には注意する必要があります。また、水平精度に基づいて場所をフィルタリングするためにこれを使用しようとする場合は、さらに注意する必要があります。

00:04:12.000 --> 00:04:21.000
さて、これは、liveUpdatesの設定を指定していない更新を取得するための前のスライドのサンプルコードです。

00:04:21.000 --> 00:04:26.000
したがって、それらはデフォルトの設定で自動的に設定されます。

00:04:26.000 --> 00:04:30.000
しかし、liveUpdates APIは明示的な設定を取ることができます。

00:04:30.000 --> 00:04:36.000
この設定は、このAPIの一部として導入する新しい列挙型です。

00:04:36.000 --> 00:04:41.000
この列挙型のメンバーとその用途を見てみましょう。 

00:04:41.000 --> 00:04:50.000
LiveConfiguration列挙型は、アプリが更新を開始するために選択できる、事前に焼かれた設定のコレクションです。

00:04:50.000 --> 00:04:59.000
デフォルト、automotiveNavigation、otherNavigation、fitness、airborneをメンバーとしています。

00:04:59.000 --> 00:05:14.000
アプリがすでに既存のロケーション更新APIで特定のCLActivityTypeを使用している場合は、新しいAPIを採用しながら、同じロケーションエクスペリエンスを持つ対応するLiveConfigurationメンバーを選択できます。

00:05:14.000 --> 00:05:25.000
しかし、特定のアクティビティタイプが必要ない場合は、デフォルトの設定で更新を開始するか、設定をまったく指定しないでください。

00:05:25.000 --> 00:05:29.000
では、この「更新」AsyncSequenceは何をもたらしますか?

00:05:29.000 --> 00:05:35.000
反復すると、CLLocationUpdateタイプのオブジェクトが表示されます。

00:05:35.000 --> 00:05:39.000
CLLocationタイプのオプションの場所が含まれています。

00:05:39.000 --> 00:05:45.000
利用可能な場所がない場合は、場所がnilとしてマークされたアップデートを配信します。

00:05:45.000 --> 00:05:54.000
また、位置更新の自動一時停止/再開を管理するブールプロパティisStationaryも含まれています。

00:05:54.000 --> 00:05:59.000
さて、フォアグラウンドからアップデートを取得する方法を取り上げました。

00:05:59.000 --> 00:06:04.000
では、アプリがバックグラウンドで実行されているときにアップデートを取得する方法について話しましょう。

00:06:04.000 --> 00:06:10.000
LiveActivityは、バックグラウンドの場所の更新を有効にするための最良の方法です。

00:06:10.000 --> 00:06:17.000
LiveActivityがアクティブなままである限り、アプリは他の追加設定なしでアップデートを受け取ることができます。

00:06:17.000 --> 00:06:21.000
しかし、あなたのアプリにまだLiveActivityがなくても心配しないでください。

00:06:21.000 --> 00:06:24.000
これは、新しいAPIを採用するためのブロッカーにはなりません。

00:06:24.000 --> 00:06:29.000
代わりに、CLBackgroundActivitySessionを使用できます。

00:06:29.000 --> 00:06:32.000
それがどのように機能するかを探りましょう。

00:06:32.000 --> 00:06:43.000
あなた方の多くは、使用中に許可されたアプリがバックグラウンドで更新を取得するときに表示されるこの青い背景位置インジケータにすでに精通しているかもしれません。

00:06:43.000 --> 00:06:51.000
CLBackgroundActivitySessionは同じインジケーターを使用して、アプリにバックグラウンド位置情報機能を提供します。

00:06:51.000 --> 00:06:59.000
これは、バックグラウンドで使用されている位置情報サービスに関するユーザーの可視性を維持することによって行います。

00:06:59.000 --> 00:07:08.000
また、可視性が維持されているため、アプリを効果的に使用できるため、バックグラウンドからでも場所にアクセスできます。

00:07:08.000 --> 00:07:13.000
CLBackgroundActivitySessionは、アプリ全体の承認をサポートしています。

00:07:13.000 --> 00:07:23.000
そのため、アプリはバックグラウンドで更新を受信するだけでなく、CLMonitorを使用してイベントを監視することもできます。

00:07:23.000 --> 00:07:28.000
BackgroundActivitySessionは、更新の開始に依存しません。

00:07:28.000 --> 00:07:37.000
セッションを作成するだけで、アプリがバックグラウンドにあるときにインジケーターが表示され、必要に応じてアップデートやイベントを受け取ることができます。

00:07:37.000 --> 00:07:43.000
CLBackgroundActivitySessionを使用するには、インスタンス化して保持する必要があります。

00:07:43.000 --> 00:07:54.000
オブジェクトの割り当て解除により、アプリのバックグラウンドロケーションへのアクセスが終了する可能性のあるセッションが自動的に無効になるため、保留部分には注意してください。

00:07:54.000 --> 00:08:03.000
BackgroundActivitySessionを効果的に機能させるには、アプリがUIBackgroundModes配列に位置情報を持つ必要があります。

00:08:03.000 --> 00:08:13.000
未処理のセッションがない場合は、フォアグラウンドから新しいセッションを開始する必要がありますが、バックグラウンドから既存のセッションに再参加できます。

00:08:13.000 --> 00:08:18.000
簡単なコードウォークスルーを行い、backgroundActivitySessionの使い方を見てみましょう。

00:08:18.000 --> 00:08:24.000
これは、前のセクションと同じ「アップデートの入手方法」のコードスライドです。

00:08:24.000 --> 00:08:32.000
更新を開始する前に、CLBackgroundActivitySessionオブジェクトをインスタンス化して、新しいセッションを開始する必要があります。

00:08:32.000 --> 00:08:39.000
セッションをself.backgroundActivityに割り当てていることに注意してください。self.backgroundActivityはプロパティであり、ローカル変数ではありません。

00:08:39.000 --> 00:08:53.000
そして、ローカル変数を使用した場合、それがスコープ外になると、それが保持するオブジェクトが割り当て解除され、セッションが無効になり、アプリの場所へのアクセスが終了する可能性があるため、これは重要です。

00:08:53.000 --> 00:09:02.000
次に、セッションを終了したい場合は、無効なメッセージを送信するか、オブジェクトを破棄することで行うことができます。

00:09:02.000 --> 00:09:10.000
そのため、アプリはLiveActivityまたはCLBackgroundActivitySessionを通じて、バックグラウンドでアップデートを取得できます。

00:09:10.000 --> 00:09:19.000
それでは、この新しいAPIが自動的に更新を一時停止して再開することで、バッテリー寿命にどのように貢献するかを見てみましょう。

00:09:19.000 --> 00:09:24.000
ユーザーが移動している間、アプリがアップデートを受信していると仮定しましょう。

00:09:24.000 --> 00:09:28.000
しかし、1日に複数回、デバイスは静止します。

00:09:28.000 --> 00:09:34.000
たとえば、ユーザーがオフィスに到着すると、デバイスを机の上に置いておくことがあります。

00:09:34.000 --> 00:09:40.000
このような状況では、私たちはあなたのアプリに同じ場所を何度も与えるでしょう。

00:09:40.000 --> 00:09:44.000
代わりに、更新を一時停止することで、ここで電力効率を高めることができます。

00:09:44.000 --> 00:09:50.000
これは、処理する冗長な場所を与えないことで、アプリもロードします。

00:09:50.000 --> 00:10:01.000
したがって、デバイスが十分な時間静止状態になると、CLLocationUpdate APIはこれを認識し、自動一時停止をトリガーします。

00:10:01.000 --> 00:10:08.000
一時停止がトリガーされると、nil以外の場所とtrueとしてマークされたisStationaryフラグで更新を送信します。

00:10:08.000 --> 00:10:15.000
これは、ユーザーが場所が利用できなくなるのではなく、移動をやめたことを知る方法です。

00:10:15.000 --> 00:10:22.000
その後、デバイスが非静止状態になると、ユーザーの操作なしで更新が自動的に再開されます。

00:10:22.000 --> 00:10:31.000
この再開アップデートでは、FalseとマークされたisStationaryを送信し、アプリへのアップデートの配信を継続します。

00:10:31.000 --> 00:10:39.000
したがって、アプリがバックグラウンドにある間に自動的に更新を一時停止して再開することは、そのライフサイクルに影響を与えます。

00:10:39.000 --> 00:10:51.000
バックグラウンドで実行中にアプリが受けるさまざまなライフサイクルフェーズと、バックグラウンド更新の継続性を維持するためにどのようなアクションを取る必要があるかを見てみましょう。

00:10:51.000 --> 00:11:01.000
フォアグラウンドで実行し、更新を受信している間のアプリは、フォアグラウンド実行からバックグラウンド実行に移行し、その逆も同様です。

00:11:01.000 --> 00:11:09.000
しかし、この新しいAPIでは、アプリがバックグラウンド実行状態から一時停止状態に移行する場合があります。

00:11:09.000 --> 00:11:14.000
これは、配信する更新がない場合に発生する可能性があります。

00:11:14.000 --> 00:11:23.000
たとえば、自動一時停止のため、静止したデバイスのため、または位置情報サービスが位置情報の修正を計算できないためです。

00:11:23.000 --> 00:11:25.000
でも、心配しないで！

00:11:25.000 --> 00:11:29.000
CLLocationUpdateは、アプリを一時停止状態のままにするつもりはありません。

00:11:29.000 --> 00:11:44.000
代わりに、自動履歴書が開始されたか、場所が利用可能になったため、更新が利用可能になるとすぐに、アプリの一時停止を解除し、バックグラウンド実行状態に戻します。

00:11:44.000 --> 00:11:52.000
アプリが一時停止状態から再開された場合、バックグラウンドで更新を継続するためのアクションは必要ありません。

00:11:52.000 --> 00:11:54.000
一時停止は唯一の州ではありません。

00:11:54.000 --> 00:11:59.000
アプリが終了状態に移行できる可能性があります。

00:11:59.000 --> 00:12:02.000
そして、この移行はいくつかの方法で起こる可能性があります。

00:12:02.000 --> 00:12:04.000
それらを通り抜けましょう。

00:12:04.000 --> 00:12:15.000
まず、アプリのクラッシュ、またはリソースが制限されているときのユーザー終了またはシステム終了によるバックグラウンド実行から直接。

00:12:15.000 --> 00:12:25.000
第二に、アプリは、ユーザークローズまたはリソースの制約により、一時停止状態からでも終了状態に移行できます。

00:12:25.000 --> 00:12:27.000
しかし、私たちはあなたに良いニュースがあります。

00:12:27.000 --> 00:12:34.000
当社のAPIは、ほとんどの場合、終了してまったく実行されていない場合でも、アプリを回復できます。

00:12:34.000 --> 00:12:55.000
バックグラウンドで起動することで、位置情報の更新が利用可能になり次第、アプリを回復します。これにより、アプリが終了からバックグラウンド実行に移行しますが、起動後、バックグラウンド位置情報セッションを継続できるように、いくつかの手順を実行する必要があります。

00:12:55.000 --> 00:13:08.000
liveUpdatesを呼び出して更新を再開する必要があり、アプリが以前にバックグラウンドアクティビティセッションを使用していた場合は、CLBackgroundActivitySessionを再作成する必要があります。

00:13:08.000 --> 00:13:17.000
私が言ったことを覚えておいてください、あなたはバックグラウンドから既存のCLBackgroundActivitySessionに再参加することができますが、新しいものを始めることはできませんか?

00:13:17.000 --> 00:13:20.000
それについてもう少し説明があります。

00:13:20.000 --> 00:13:23.000
再作成したばかりのバックグラウンドアクティビティセッションオブジェクト?

00:13:23.000 --> 00:13:26.000
それは新しいセッションの始まりではありません。

00:13:26.000 --> 00:13:29.000
新しいセッションオブジェクトを作成したばかりです。

00:13:29.000 --> 00:13:44.000
さて、アプリは終了する前にすでにセッションを開始しているため、このレクリエーションにより、アプリはバックグラウンドから既存のセッションに再参加することができ、アプリはバックグラウンド位置情報の更新を継続できます。

00:13:44.000 --> 00:13:54.000
さて、バックグラウンドアプリの起動を受信した後、ライブアップデートとバックグラウンドアクティビティセッションをどのように再作成するかについて話し合いました。

00:13:54.000 --> 00:14:00.000
レクリエーションに関連して、注意すべきことはほとんどありません。

00:14:00.000 --> 00:14:06.000
アプリは、バックグラウンドアプリの起動を受信するとすぐにレクリエーションを実行する必要があります。

00:14:06.000 --> 00:14:13.000
これらのオブジェクトのレクリエーションは、アプリがバックグラウンド起動を受信したときに実行される場所に配置します。

00:14:13.000 --> 00:14:25.000
サンプルアプリの場合、アプリの起動が完了すると呼び出されるUIApplicationDelegateのdidFinishLaunchingWithOptionsにレクリエーションを配置しました。

00:14:25.000 --> 00:14:26.000
わかった！

00:14:26.000 --> 00:14:32.000
これは、採用が簡素化され、バッテリー性能が向上した新しいロケーションアップデートAPIです。

00:14:32.000 --> 00:14:37.000
今年からすべてのプラットフォームで利用可能になります。

00:14:37.000 --> 00:14:46.000
アプリでCLLocationUpdateを試して、フィードバックアシスタントを通じて貴重なフィードバックを提供することを強くお勧めします。

00:14:46.000 --> 00:14:54.000
また、この新しいAPIの使用方法を紹介するサンプルアプリもあり、リソースセクションからダウンロードできます。

00:14:54.000 --> 00:15:01.000
CLLocationUpdateのApple Developerドキュメントは、APIの詳細も入手できます。

00:15:01.000 --> 00:15:10.000
また、今年追加するCore Location Monitoring APIをカバーする「Meet Core Location Monitor」セッションを見ることをお勧めします。

00:15:10.000 --> 00:15:14.000
それは「合理化された場所の更新を発見する」に関する私の側からのすべてです。

00:15:14.000 --> 00:15:16.000
見てくれてありがとう!

00:15:16.000 --> 23:59:59.000
♪ ♪

