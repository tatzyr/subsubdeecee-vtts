WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:11.000
こんにちは、ようこそ。

00:00:11.000 --> 00:00:18.000
私はAppleのGPU、グラフィックス、ディスプレイソフトウェアグループのエンジニアであるVarun Subramanianです。

00:00:18.000 --> 00:00:24.000
このセッションは、ハイエンドゲームをMacに持ち込むための3部構成のシリーズの第2部です。

00:00:24.000 --> 00:00:29.000
最初のセッションでは、ゲームを評価し、「ゲームプランを作成する」方法について説明します。

00:00:29.000 --> 00:00:48.000
このセッションでは、シェーダーと、シェーダーをMetal中間表現に変換する新しい方法や、ゲームのビルド時間中にGPUバイナリを確定してデバイス上のコンパイルを回避する方法など、新しいMetalコンパイラツールのいくつかを使用して柔軟性と速度を向上させる方法に焦点を当てます。

00:00:48.000 --> 00:00:56.000
メタルコンパイラツールチェーンは、ゲームを強化するシェーダーをコンパイルするのに役立ち、メタルはそれをこれまで以上に簡単にします。

00:00:56.000 --> 00:01:04.000
デバイス上のMetal IRの作成は、GPUが必要な作業を行う前にコンパイルオーバーヘッドを追加するため、最適ではありません。

00:01:04.000 --> 00:01:11.000
Metalは、事前にMetal Shading LanguageからMetal IRを生成するために必要なツールを提供します。

00:01:11.000 --> 00:01:15.000
その金属IRは金属ライブラリの一部として保存されています。

00:01:15.000 --> 00:01:22.000
事前にMetalコンパイラツールチェーンを使用して、常にMetalライブラリを生成することを目指す必要があります。

00:01:22.000 --> 00:01:27.000
ただし、別のAPIとシェーディング言語から来る場合は、それらをMetalに取得する方法が必要です。

00:01:27.000 --> 00:01:32.000
Macに新しく来た人なら、メタルシェーダーコンバーターがあります。

00:01:32.000 --> 00:01:43.000
これにより、シェーダーパイプラインが簡素化され、生成されたMetalライブラリをバンドルに直接パッケージ化できるため、デバイス上のMetal IRの生成を回避できます。

00:01:43.000 --> 00:01:52.000
生成されたMetalライブラリは、Metalコンパイラから生成されたものと同じで、変換されたシェーダーをMetal APIとネイティブに統合できます。

00:01:52.000 --> 00:01:58.000
新しいツールを使用して、既存のシェーダーをMetalライブラリに変換し、ゲームに同梱します。

00:01:58.000 --> 00:02:05.000
Metal Shader Converterは、シェーダーをMetalに変換するエクスペリエンスを向上させるための堅牢な機能セットを提供します。

00:02:05.000 --> 00:02:09.000
金属IRを生産するためにDXILを消費します。

00:02:09.000 --> 00:02:14.000
オープンソースのDXCコンパイラツールと一緒に使用して、エンドツーエンドのシェーダーパイプラインを構築します。

00:02:14.000 --> 00:02:22.000
メタルシェーダーコンバータがバイナリレベルで変換を実行するため、DXILからメタルIRへの変換は非常に高速です。

00:02:22.000 --> 00:02:26.000
その結果、シェーダーアセットのビルド時間が短縮されます。

00:02:26.000 --> 00:02:31.000
また、Apple GPUの高度な機能を活用することもできます。

00:02:31.000 --> 00:02:41.000
既存のDXILシェーダーのすべての伝統的および現代的なシェーダーステージをサポートするメタルシェーダーコンバータの豊富な機能セットのためにこれを行うことができます。

00:02:41.000 --> 00:02:51.000
メタルシェーダーコンバーターを使用すると、テッセレーションやジオメトリシェーダーを含む従来のグラフィックパイプラインのシェーダーをメタルライブラリに変換できます。

00:02:51.000 --> 00:03:00.000
また、コンピューティングシェーダーだけでなく、最近導入されたレイトレーシングステージとシェーダー、増幅とメッシュシェーダーもサポートしています。

00:03:00.000 --> 00:03:06.000
では、メタルシェーダーコンバーターの使い方を説明します。

00:03:06.000 --> 00:03:10.000
コマンドラインでシェーダーを変換したいシナリオは2つあります。

00:03:10.000 --> 00:03:16.000
ターミナル経由でコマンドラインツールを使用することは、一度に1つのシェーダーを変換する良いメカニズムです。

00:03:16.000 --> 00:03:25.000
複数のシェーダーがある場合は、メタルシェーダーコンバータを呼び出して複数のシェーダーを自動的に変換するシェルスクリプトを作成できます。

00:03:25.000 --> 00:03:29.000
コマンドラインツールを使用してシェーダーを変換するのはとても簡単です。

00:03:29.000 --> 00:03:36.000
DXCとシェーダーコンバータを設定したら、HLSLシェーダーをDXILにコンパイルすることから始めます。

00:03:36.000 --> 00:03:42.000
DXCでは、コンパイルするエントリポイント、シェーダーのタイプ、および出力ファイルを指定する必要があります。

00:03:42.000 --> 00:03:49.000
次に、作成したDXILファイルでシェーダーコンバータを呼び出し、作成する出力Metalライブラリを指定します。

00:03:49.000 --> 00:03:58.000
デフォルトでは、シェーダーコンバーターは最新バージョンのmacOS用のMetalライブラリと、便利な反射データを含むJSONファイルを生成します。

00:03:58.000 --> 00:04:05.000
実行時に、このMetalライブラリをMetalデバイスに渡してロードし、パイプライン状態オブジェクトを構築します。

00:04:05.000 --> 00:04:11.000
コマンドラインインターフェイスがワークフローにとって最良の選択ではないかもしれない他の2つのシナリオがあります。

00:04:11.000 --> 00:04:18.000
一部のゲームエンジンには、シェーダーをコンパイルしてゲーム固有の形式にパッケージ化するカスタムアセットビルドプログラムがあります。

00:04:18.000 --> 00:04:30.000
また、状況によっては、Metalのゲームをブートストラップする際に、事前にMetalライブラリに完全に転換する前に、シェーダーがプラットフォームでどれだけうまく機能しているかを確認したいと思うかもしれません。

00:04:30.000 --> 00:04:36.000
これらの最後の2つのケースでは、メタルシェーダーコンバータをワークフローによりよく統合する方法が必要です。

00:04:36.000 --> 00:04:41.000
これを実現するには、メタルシェーダーコンバータのダイナミックライブラリを使用します。

00:04:41.000 --> 00:04:47.000
CLIツールと同じ機能をすべて公開し、Metalライブラリの生成を支援します。

00:04:47.000 --> 00:04:57.000
ライブラリは純粋なCインターフェイスを提供し、CLIと同様に、macOSとWindowsの両方で利用できるため、既存のワークフローに簡単に統合できます。

00:04:57.000 --> 00:05:06.000
シェーダーをMetal IRに変換した後、それらをゲームに統合するために、パイプライン状態を作成し、リソースをそれらにバインドします。

00:05:06.000 --> 00:05:13.000
シェーダーでは、通常、リソースをグローバル変数として定義し、それらに「登録」宣言を割り当てます。

00:05:13.000 --> 00:05:22.000
API側から、ゲームはリソースをこれらのスロットに直接バインドするか、「ルートシグネチャ」を介して明示的なメモリレイアウトを定義します。

00:05:22.000 --> 00:05:28.000
メタルは非常に柔軟なバインディングモデルを持っているので、シェーダーコンバータは、このモデルを持ち込むのに役立ちます。

00:05:28.000 --> 00:05:32.000
このツールは、これらのリソースを引数バッファにレイアウトします。

00:05:32.000 --> 00:05:39.000
このモデルでは、1つの引数バッファをパイプラインに直接バインドし、それを介してリソースを参照します。

00:05:39.000 --> 00:05:46.000
この「トップレベル」の引数バッファには、ゲームに最も合うように選択できる2つのレイアウトモードがあります。

00:05:46.000 --> 00:05:53.000
作成できる最も簡単なレイアウトは、シェーダーコンバーターがリソースを次々に配置する自動レイアウトです。

00:05:53.000 --> 00:06:02.000
シェーダーを含むパイプライン状態を作成したら、単一の引数バッファをバインドし、それを介してすべてのリソースを参照します。

00:06:02.000 --> 00:06:08.000
あるいは、シェーダーコンバーターは、ルート署名に一致するレイアウトを明示的に定義することをサポートします。

00:06:08.000 --> 00:06:18.000
ゲームが別々のテクスチャとサンプラーを独自のリソーステーブルに指定する必要がある場合、またはゲームがバインドレスリソースを使用する場合は、このモードを使用します。

00:06:18.000 --> 00:06:27.000
また、生のバッファと32ビット定数を、この図で0と1として表示されているトップレベルの引数バッファに直接埋め込むこともできます。

00:06:27.000 --> 00:06:40.000
現在、トップレベルの引数バッファは、CPUとGPUの間で共有されるリソースであるため、書き込み中に、視覚的な破損を引き起こす可能性のある競合状態を避けるために、メモリへのアクセスを調整する必要があります。

00:06:40.000 --> 00:06:44.000
この競合状態を避けるために、CPUとGPUの作業をシリアル化する必要はありません。

00:06:44.000 --> 00:06:48.000
これを回避する1つの方法は、バンプアロケータを使用することです。

00:06:48.000 --> 00:06:53.000
これは、フレームごとに異なるリソースをサブ割り当てする大きなメタルバッファーにすることができます。

00:06:53.000 --> 00:06:58.000
次に、ゲームが処理する飛行中の各フレームのバッキングバッファをシャドウイングします。

00:06:58.000 --> 00:07:03.000
バンプアロケータの実装の詳細については、サンプルコードをご覧ください。

00:07:03.000 --> 00:07:09.000
最良の引数バッファ管理プラクティスについては、昨年のバインドレスセッションとMetalドキュメントをチェックしてください。

00:07:09.000 --> 00:07:16.000
バインディングモデルは、メタルシェーダーコンバーターがシェーダーをMacに持ち込むのに役立つ唯一の場所ではありません。

00:07:16.000 --> 00:07:21.000
特定のシェーダーステージのマッピングは、グラフィックAPIの違いにより難しい場合があります。

00:07:21.000 --> 00:07:27.000
たとえば、従来のジオメトリとテッセレーションステージを活用するパイプラインがあるかもしれません。

00:07:27.000 --> 00:07:39.000
Metalは最新のAPIであり、他のグラフィックスAPIからの古くて効率の低いステージを不要にするビューポートIDや増幅などの機能を提供します。

00:07:39.000 --> 00:07:49.000
しかし、あなたのゲームがこの画像でレンダリングされた草のようないくつかの表面を強化する伝統的な効果のためにこれらのパイプラインに依存している場合、それらを手で変換することはコストがかかります。

00:07:49.000 --> 00:07:58.000
メタルシェーダーコンバータは、モダンでより効率的なグラフィックAPI構造であるメッシュシェーダーにマッピングすることで、これらのパイプラインをメタルに持ち込むのに役立ちます。

00:07:58.000 --> 00:08:07.000
このツールは、各ステージをMetal IR表現にマッピングすることで、これらの複雑なパイプラインを簡単にMetalに持ち込むために重い作業を行います。

00:08:07.000 --> 00:08:12.000
これには、伝統的に固定機能操作であるテッセレーターが含まれます。

00:08:12.000 --> 00:08:21.000
このワークフローをサポートするために、今年Metalは目に見える機能をメッシュシェーダーの「オブジェクトとメッシュ」ステージにリンクする機能を追加します。

00:08:21.000 --> 00:08:31.000
シェーダーをコンパイルしたら、それらを使用して「Metal Mesh RenderPipeline Descriptor」を構築し、「Metal Render Pipeline状態」にコンパイルします。

00:08:31.000 --> 00:08:44.000
Metalは、このパイプライン状態を構築する要求を受信すると、すべてのMetal IRをコンパイルしてリンクし、すべての機能を単一のパイプラインに焼き込み、関数呼び出しのオーバーヘッドを完全に回避し、実行時のパフォーマンスを最大化します。

00:08:44.000 --> 00:08:54.000
補足機能でこれらのシェーディングステージを含むこの精巧なレンダリングパイプラインを構築できるMetal可視機能のパワーと柔軟性に注目してください。

00:08:54.000 --> 00:09:01.000
これらのメッシュパイプラインの構築は簡単ですが、すべてのパイプラインは正確な順序で一連の手順に従わなければなりません。

00:09:01.000 --> 00:09:05.000
シェーダーコンバータのランタイムは、これらの複雑なパイプラインを構築するのに役立ちます。

00:09:05.000 --> 00:09:09.000
メッシュシェーディング作業をディスパッチすることで、ドローコールをエミュレートします。

00:09:09.000 --> 00:09:14.000
詳細については、Metal Shader Converterのドキュメントを参照してください。

00:09:14.000 --> 00:09:23.000
シェーダーがMetal上にあり、パイプラインの状態を実行している今、優れたパフォーマンスと視覚的な正確性を得るのに役立つヒントをいくつか紹介します。

00:09:23.000 --> 00:09:27.000
シェーダーコンバータ参照金属リソース間接的にコンパイルされたシェーダー。

00:09:27.000 --> 00:09:32.000
リソースレジデンシーをMetalにフラグを付けるには、「useResource」と呼びます。

00:09:32.000 --> 00:09:37.000
ただし、useResourceは、過剰に使用すると高価な通話です。

00:09:37.000 --> 00:09:48.000
複数のuseResourcesを使用して、一度に複数のリソースを提供するか、useHeapを介してMetalヒープを使用して、1回の呼び出しで複数のリソースのレジデンシーにフラグを付けることを検討してください。

00:09:48.000 --> 00:09:57.000
パイプラインオブジェクトは、Metalが初めてコンパイルしたときにキャッシュされ、ゲームのその後の実行時にコンパイルベースのヒッチングが自動的に減少します。

00:09:57.000 --> 00:10:00.000
バイナリアーカイブもここであなたを助けることができます。

00:10:00.000 --> 00:10:07.000
GPUをさらに得、より高いパフォーマンスのためにMetal IRをカスタマイズするために、シェーダーコンバータはオプションを提供します。

00:10:07.000 --> 00:10:17.000
互換性、GPUファミリ、頂点フェッチ動作、エントリポイントの命名、反射などのカスタマイズがあります。

00:10:17.000 --> 00:10:21.000
ここに1つの追加の最適化の機会があります。

00:10:21.000 --> 00:10:29.000
先ほど、シェーダーコンバータは、既存のシェーダーIRから「メタルライブラリ」を生成する別のメカニズムとしてメタルコンパイラに参加すると述べました。

00:10:29.000 --> 00:10:34.000
金属はこれらを使用して、さまざまなグラフィックパイプラインのステージを供給します。

00:10:34.000 --> 00:10:44.000
すべてがメタルIRであるため、メタルシェーダーコンバータとメタルコンパイラからの「メタルライブラリ」を1つのアプリ、さらには1つのパイプラインで組み合わせることができます。

00:10:44.000 --> 00:10:50.000
メタルシェーディング言語では、プログラム可能なブレンドなどのユニークな機能にもアクセスできます。

00:10:50.000 --> 00:10:54.000
このアプローチを使用して、AppleのGPUを最大限に活用してください。

00:10:54.000 --> 00:10:59.000
タイルシェーディングなどのユニークなシェーディング機能を利用することもできます。

00:10:59.000 --> 00:11:03.000
これにより、ゲームをメタルに持ち込む方法に大きな柔軟性が得られます。

00:11:03.000 --> 00:11:08.000
パフォーマンスは重要ですが、ゲームの視覚的な正確性が最も重要です。

00:11:08.000 --> 00:11:13.000
HLSLを使用すると、テクスチャを1つの要素の配列としてシームレスに処理できます。

00:11:13.000 --> 00:11:22.000
この動作に依存するシェーダーを持ち込むには、テクスチャをテクスチャ配列として作成するか、テクスチャに「テクスチャ配列ビュー」を作成します。

00:11:22.000 --> 00:11:28.000
「MetalKit Texture Loader」を使用している場合は、ファイルをテクスチャ配列として読み込むのにも役立ちます。

00:11:28.000 --> 00:11:42.000
サンプラーオブジェクトを設定し、これらのテクスチャから読み取るには、MTLサンプラー記述子のプロパティsupportsArgumentBuffersを使用して、引数バッファでサンプラーを参照する予定であることを事前にMetalに知らせてください。

00:11:42.000 --> 00:11:48.000
ワークフローでのシェーダーコンバーターの統合に精通したので、入手方法は次のとおりです。

00:11:48.000 --> 00:11:52.000
メタルシェーダーコンバーターはdeveloper.apple.comからダウンロードできます。

00:11:52.000 --> 00:11:57.000
Macで作業している場合は、Macパッケージ用のメタルシェーダーコンバーターを入手してください。

00:11:57.000 --> 00:12:02.000
Windowsで作業している場合は、Metal Developer Tools for Windowsパッケージの一部です。

00:12:02.000 --> 00:12:04.000
このツールのベータ版は現在入手可能です。

00:12:04.000 --> 00:12:12.000
どちらのパッケージにも、スタンドアロンおよびライブラリ形式のメタルシェーダーコンバータと、ランタイムコンパニオンヘッダーが含まれています。

00:12:12.000 --> 00:12:17.000
完全なドキュメントとMetal C++コードのサンプルが利用可能になりました。

00:12:17.000 --> 00:12:25.000
サンプルコードを使用して、ジオメトリとテッセレーションエミュレーション、インスタンスドローイング、およびコンピューティングシェーダーを探索します。

00:12:25.000 --> 00:12:32.000
シェーダーをゲームに同梱するメタルライブラリに変換すると、ゲームランタイムでこれらのライブラリの生成を避けることができます。

00:12:32.000 --> 00:12:40.000
実行できる追加の最適化が1つあります。それは、GPUバイナリを事前にコンパイルすることです。

00:12:40.000 --> 00:12:47.000
ゲームを構築するときは、シェーダーをMetalライブラリにコンパイルし、まだGPUバイナリにファイナライズする必要があります。

00:12:47.000 --> 00:12:53.000
通常、あなたのゲームは起動時にこれを行うため、読み込み画面が長くなります。

00:12:53.000 --> 00:13:01.000
実行時にGPUバイナリの完成を延期すると、ゲームがオンデマンドで新しいパイプラインをコンパイルするため、フレームがドロップされる可能性があります。

00:13:01.000 --> 00:13:10.000
Metal GPUバイナリコンパイラは、ゲームビルド時にシェーダーバイナリを生成できるようにすることで、これを解決するのに役立ちます。

00:13:10.000 --> 00:13:20.000
ゲームプレイ中にシェーダーバイナリを生成する必要性を取り除くことで、プレイヤーは追加のGPUヒッチが発生することなく、アプリの読み込み時間を短縮することで利益を得ることができます。

00:13:20.000 --> 00:13:29.000
これを利用するには、ワークフローに別のステップを追加して、ビルド時にMetalライブラリをMetalバイナリアーカイブに完成させることができます。

00:13:29.000 --> 00:13:35.000
デバイス上のGPUバイナリコンパイルは、記述子からパイプライン状態を作成するときに発生します。

00:13:35.000 --> 00:13:47.000
この記述子は、Metalライブラリから関数を参照するだけでなく、レンダリング添付ファイルの色形式や頂点レイアウト記述子など、Metalに他の重要な情報も提供します。

00:13:47.000 --> 00:13:54.000
GPUバイナリは、PSO作成の一部としてちょうど間リーに生成されます。

00:13:54.000 --> 00:13:58.000
バイナリアーカイブを使用すると、そのコンパイルがいつ行われるかを制御できます。

00:13:58.000 --> 00:14:08.000
GPUバイナリを事前に作成するには、既存のメタルライブラリと、それらのライブラリを参照するパイプライン構成スクリプトの両方を提供します。

00:14:08.000 --> 00:14:15.000
次に、両方をmetal-ttに提供し、GPUバイナリでバイナリアーカイブを生成します。

00:14:15.000 --> 00:14:22.000
パイプラインスクリプトを開発するには、Metal APIに似たパイプライン構成のJSONスクリプトを作成します。

00:14:22.000 --> 00:14:29.000
このMetalコードは、レンダリングパイプライン記述子を生成し、そのJSONと同等の表現です。

00:14:29.000 --> 00:14:36.000
パイプラインスクリプトには、Metalライブラリパスとそのフラグメントと頂点関数名を追加します。

00:14:36.000 --> 00:14:39.000
また、他のパイプライン状態の設定も指定します。

00:14:39.000 --> 00:14:43.000
それでおそれ、あなたは今、あなたが使用できるメタルスクリプトを持っています。

00:14:43.000 --> 00:14:48.000
JSONスキーマに関する追加情報は、Metalの開発者ドキュメントで見つけることができます。

00:14:48.000 --> 00:14:53.000
事前のシェーダーコンパイルワークフローは、パイプラインスクリプトファイルを生成するように調整されていない可能性があります。

00:14:53.000 --> 00:14:58.000
これらのケースでは、それらを生産する別の方法があります。

00:14:58.000 --> 00:15:02.000
デバイスでゲームを実行している間、メタルバイナリアーカイブを記録できます。

00:15:02.000 --> 00:15:06.000
これらのアーカイブには、対応するパイプラインスクリプトが含まれています。

00:15:06.000 --> 00:15:13.000
デバイスからこれらのアーカイブを収集する場合は、「メタルソース」を使用して、埋め込まれたパイプラインスクリプトを抽出できます。

00:15:13.000 --> 00:15:17.000
次に、抽出されたスクリプトでMetalライブラリへのパスを更新します。

00:15:17.000 --> 00:15:26.000
詳細については、「GPUバイナリの構築」と「コンパイルワークフローの発見」に関する講演を参照してください。

00:15:26.000 --> 00:15:36.000
GPUバイナリは各GPUに合わせて調整されているため、「metal-tt」は、デバイスに基づいてプレイヤーに配布するための異なるバージョンのバイナリを生成します。

00:15:36.000 --> 00:15:44.000
Metal-ttは、すべての異なるGPUバイナリをMetalバイナリアーカイブにきれいにカプセル化することで、この複雑さを管理するのに役立ちます。

00:15:44.000 --> 00:15:52.000
このようにして、アプリがそのバイナリアーカイブをロードすると、Metalは自動的にプレイヤーに適したバイナリを選択します。

00:15:52.000 --> 00:15:58.000
複数のバイナリセットを1つのバイナリアーカイブにカプセル化することもできます。

00:15:58.000 --> 00:16:04.000
バイナリアーカイブを事前に作成できるようになったので、ここにいくつかのベストプラクティスがあります。

00:16:04.000 --> 00:16:12.000
プレイヤーが事前にコンパイルされたGPUバイナリでMetalアプリを実行すると、Metalはパッケージ化されたバイナリアーカイブで必要なGPUバイナリを検索します。

00:16:12.000 --> 00:16:18.000
メタルがアーカイブで一致しない場合、自動的にデバイス上のコンパイルにフォールバックします。

00:16:18.000 --> 00:16:22.000
アプリはまだ正しく見えますが、GPUへの提出が遅れる可能性があります。

00:16:22.000 --> 00:16:30.000
「FailOnBinaryArchiveMiss」オプションを使用して、バイナリアーカイブに期待するパイプラインが含まれているかどうかをテストできます。

00:16:30.000 --> 00:16:36.000
Metalパイプライン状態オブジェクトを作成するときに、FailOnBinaryArchiveMissオプションを簡単に指定できます。

00:16:36.000 --> 00:16:45.000
バイナリアーカイブミスの場合、このオプションを設定すると、Metalはデバイス上のコンパイルをスキップし、nilパイプライン状態を返します。

00:16:45.000 --> 00:16:51.000
バイナリアーカイブがすべてのターゲットデバイスをサポートする準備ができたら、展開の準備が整いました。

00:16:51.000 --> 00:16:54.000
すべてのプレイヤーが最新のOSを使用しているわけではありません。

00:16:54.000 --> 00:17:03.000
すべてのユーザーがバイナリアーカイブの恩恵を受けるように、主要なOSバージョンごとにアーカイブを生成し、アプリに保存します。

00:17:03.000 --> 00:17:13.000
これを達成するには、プレイヤーのデバイスのOSバージョンを確認し、パイプライン記述子に関連付ける適切なバイナリアーカイブを選択します。

00:17:13.000 --> 00:17:22.000
プレイヤーがOSを更新すると、バイナリアーカイブは前方互換性のために再コンパイルが必要になる場合がありますが、Metalはあなたをカバーしています。

00:17:22.000 --> 00:17:33.000
Metalは、プレイヤーのデバイス上のアプリバンドル内のパッケージ化されていないバイナリアーカイブを識別し、OSの更新またはゲームのインストール後にバックグラウンドで自動的にアップグレードします。

00:17:33.000 --> 00:17:42.000
要約すると、「メタル」コンパイラと「メタルシェーダーコンバーター」は、ゲームと一緒に出荷できるメタルライブラリを事前に作成するための頼りになるツールです。

00:17:42.000 --> 00:17:50.000
MSLソースをコンパイルするときは「metal compiler」を使用し、シェーダーがHLSLにあるときは「metal-shaderconverter」を使用します。

00:17:50.000 --> 00:17:58.000
metal-ttを使用すると、MetalエコシステムのさまざまなGPUに合わせたMetalライブラリをGPUバイナリにファイナライズできます。

00:17:58.000 --> 00:18:05.000
最後に、金属ソースは、既存のMacOSゲームからパイプラインスクリプトを収穫するのに役立ちます。

00:18:05.000 --> 00:18:18.000
これらのツールの大部分は、残りのGPUバイナリコンパイラツールチェーンと同様に、macOSに加えてWindowsをサポートしているため、既存のワークフローにこれまで以上に簡単に統合できます。

00:18:18.000 --> 00:18:26.000
まとめ：Metal Shader Converterは、別のシェーディング言語で開発されたシェーダーをMetalに持ち込むのに役立つ新しいツールです。

00:18:26.000 --> 00:18:35.000
Windowsで利用可能になったGPUバイナリコンパイラとそのツールチェーンは、MetalライブラリをGPUバイナリに仕上げることができます。

00:18:35.000 --> 00:18:40.000
これらのツールを使用すると、シェーダーをメタルに持ち込むために必要なものがすべて揃っています。

00:18:40.000 --> 00:18:42.000
あなたと共有することはまだたくさんあります。

00:18:42.000 --> 00:18:47.000
シリーズのパート3は、ハイエンドの金属アプリケーションの最適化に焦点を当てています。

00:18:47.000 --> 00:18:48.000
必ずチェックしてください。

00:18:48.000 --> 00:18:50.000
見てくれてありがとう。

00:18:50.000 --> 23:59:59.000
♪ ♪

