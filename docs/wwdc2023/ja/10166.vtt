WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:13.000
アレックス・ホッペン:誰が反復的な定型コードを書くのが好きですか?

00:00:13.000 --> 00:00:15.000
誰もしない！

00:00:15.000 --> 00:00:20.000
だからこそ、Swift 5.9ではSwiftマクロを導入しています。

00:00:20.000 --> 00:00:29.000
Swiftマクロを使用すると、コンパイル時にその繰り返しコードを生成できるため、アプリのコードベースがより表現力豊かで読みやすくなります。

00:00:29.000 --> 00:00:36.000
私の名前はアレックス・ホッペンです。今日は、自分のマクロを書く方法を紹介します。

00:00:36.000 --> 00:00:42.000
まず、マクロの仕組みの概要をお伝えします。

00:00:42.000 --> 00:00:50.000
その後、Xcodeに直接ジャンプして、最初のマクロを作成する方法を確認します。

00:00:50.000 --> 00:01:05.000
Xcodeで最初のマクロを見たので、マクロを使用できるより多くの役割を探求し、現在取り組んでいるアプリのコードベースを簡素化するためにマクロをどのように使用したかを紹介します。

00:01:05.000 --> 00:01:15.000
最後に、特定のコンテキストで適用されない場合、マクロがエラーや警告をコンパイラに通信する方法を紹介します。

00:01:15.000 --> 00:01:17.000
では、始めましょう。

00:01:17.000 --> 00:01:23.000
ここでは、1年生が算術スキルを練習するために使用できる計算のリストがあります。

00:01:23.000 --> 00:01:31.000
結果は左側に整数として、計算はタプルの右側に文字列リテラルとしてあります。

00:01:31.000 --> 00:01:41.000
結果が実際に計算と一致することを誰も保証できないので、これが反復的で、冗長で、さらにはエラーになりやすいことに注目してください。

00:01:41.000 --> 00:01:48.000
幸いなことに、Swift 5.9では、これを簡素化するために文字列化マクロを定義できます。

00:01:48.000 --> 00:01:53.000
このマクロは、たまたまXcodeのテンプレートに含まれているマクロでもあります。

00:01:53.000 --> 00:01:58.000
Stringifyマクロは、計算を単一のパラメータとしてのみ取ります。

00:01:58.000 --> 00:02:07.000
コンパイル時に、以前に見たタプルに拡張され、計算と結果が一致することを保証します。

00:02:07.000 --> 00:02:09.000
では、これはどのように機能しますか?

00:02:09.000 --> 00:02:13.000
マクロ自体の定義を見てみましょう。 マクロ自体の定義を見てみましょう。

00:02:13.000 --> 00:02:16.000
関数によく似ていることに注目してください。

00:02:16.000 --> 00:02:28.000
Stringifyマクロは、入力パラメータとして整数を受け取り、結果、整数、および計算文字列を含むタプルを出力します。

00:02:28.000 --> 00:02:40.000
マクロ式の引数がマクロのパラメータと一致しない場合、または自分でチェックをタイプしない場合、コンパイラはマクロ展開を適用せずにエラーを発行します。

00:02:40.000 --> 00:02:51.000
たとえば、このマクロに文字列リテラルを渡すと、コンパイラは「String」が期待される引数型「Int」に変換できないと訴えます。

00:02:51.000 --> 00:02:59.000
これは、たとえば、タイプチェック前のプリプロセッサ段階で評価されるCマクロとは異なります。

00:02:59.000 --> 00:03:08.000
しかし、マクロをジェネリックにできるなど、Swift関数からあなたが知っていて愛しているすべての力を使うことができます。

00:03:08.000 --> 00:03:14.000
また、このマクロは自立式マクロの役割で宣言されていることに注意してください。

00:03:14.000 --> 00:03:24.000
これは、式を使用できる場所であればどこでもマクロを使用できることを意味し、#stringifyで見られるように、ハッシュ文字で示されます。

00:03:24.000 --> 00:03:30.000
他の種類のマクロは、宣言を拡張できるアタッチされたマクロです。

00:03:30.000 --> 00:03:32.000
それらを後でカバーします。

00:03:32.000 --> 00:03:40.000
すべての引数がマクロのパラメータと一致することを確認した後、コンパイラはマクロ展開を実行します。

00:03:40.000 --> 00:03:47.000
それがどのように機能するかを見るために、単一のマクロ式に焦点を当てましょう。

00:03:47.000 --> 00:03:53.000
拡張を実行するために、各マクロはコンパイラプラグインでの実装を定義します。

00:03:53.000 --> 00:03:59.000
コンパイラは、マクロ式全体のソースコードをそのプラグインに送信します。

00:03:59.000 --> 00:04:08.000
マクロプラグインが最初に行うことは、マクロのソースコードをSwiftSyntaxツリーに解析することです。

00:04:08.000 --> 00:04:17.000
このツリーは、マクロのソースの正確な構造表現であり、マクロが動作する基礎になります。

00:04:17.000 --> 00:04:26.000
たとえば、「stringify」マクロは、マクロ展開式ノードとしてツリーで表されます。

00:04:26.000 --> 00:04:31.000
その式にはマクロ名「stringify」があります。

00:04:31.000 --> 00:04:38.000
そして、2と3に適用される中置演算子プラスである単一の引数が必要です。

00:04:38.000 --> 00:04:51.000
Swiftマクロの本当に強力なのは、マクロの実装自体がSwiftで書かれたプログラムであり、必要な構文ツリーへの変換を実行できることです。

00:04:51.000 --> 00:04:56.000
私たちの場合、前に見たようなタプルを生成します。

00:04:56.000 --> 00:05:09.000
その後、生成された構文ツリーを再びソースコードにシリアライズし、コンパイラに送信し、マクロ式を拡張コードに置き換えます。

00:05:09.000 --> 00:05:16.000
それは本当にクールですが、今、私はこれらすべてが実際にコードでどのように見えるかを理解したいです。

00:05:16.000 --> 00:05:22.000
Xcodeの新しいマクロテンプレートは、先ほど見たstringifyマクロを定義します。

00:05:22.000 --> 00:05:31.000
そのテンプレートを見て、マクロの定義、拡張の仕組み、マクロのテスト方法を探りましょう。

00:05:31.000 --> 00:05:43.000
テンプレートを作成するには、[ファイル]、[新規]、[パッケージ]をクリックし、Swiftマクロテンプレートを選択します。

00:05:43.000 --> 00:05:55.000
最初のマクロを「WWDC」と呼びましょう。

00:05:55.000 --> 00:05:58.000
では、テンプレートで何を得るのですか?

00:05:58.000 --> 00:06:05.000
ここでは、以前に見たものと同様に、#stringifyマクロの呼び出しがあります。

00:06:05.000 --> 00:06:12.000
パラメータ「a + b」を受け取り、結果とそれを生成したコードを返します。

00:06:12.000 --> 00:06:20.000
マクロが何に展開されるのかを知りたい場合は、マクロを右クリックして[マクロを展開] を選択できます。

00:06:20.000 --> 00:06:23.000
それはまさに私たちが前に見たものです。

00:06:23.000 --> 00:06:26.000
しかし、マクロはどのように定義されていますか?

00:06:26.000 --> 00:06:32.000
その定義にジャンプしましょう。

00:06:32.000 --> 00:06:38.000
ここでは、以前の「stringify」マクロのわずかに一般化されたバージョンがあります。

00:06:38.000 --> 00:06:47.000
整数を取る代わりに、このマクロは一般的であり、任意のタイプTを受け取ることができます。

00:06:47.000 --> 00:06:52.000
マクロは外部マクロとして宣言されています。

00:06:52.000 --> 00:07:04.000
これは、拡張を実行するには、WWDCMacrosモジュールのStringifyMacroタイプを調べる必要があることをコンパイラに伝えます。

00:07:04.000 --> 00:07:07.000
そのタイプはどのように定義されていますか?

00:07:07.000 --> 00:07:10.000
詳しく見てみましょう。そしてもっと詳しく見てみましょう

00:07:10.000 --> 00:07:20.000
stringifyは自立式マクロとして宣言されているため、StringifyMacroタイプはExpressionMacroプロトコルに準拠する必要があります。

00:07:20.000 --> 00:07:26.000
このプロトコルには、拡張機能という単一の要件があります。

00:07:26.000 --> 00:07:36.000
マクロ式自体の構文ツリーと、コンパイラとの通信に使用できるコンテキストを取ります。

00:07:36.000 --> 00:07:42.000
その後、展開関数は書き換えられた式構文を返します。

00:07:42.000 --> 00:07:45.000
それは実装で何をしますか?

00:07:45.000 --> 00:07:52.000
最初は、単一の引数をマクロ式に取得します。

00:07:52.000 --> 00:08:05.000
Stringifyは単一のパラメータを取ると宣言され、マクロ展開を適用する前にすべての引数をタイプチェックする必要があるため、この引数が存在することを知っています。

00:08:05.000 --> 00:08:10.000
次に、文字列補間を使用してタプルの構文ツリーを作成します。

00:08:10.000 --> 00:08:20.000
最初の要素は引数自体で、2番目の要素は引数のソースコードを含む文字列リテラルです。

00:08:20.000 --> 00:08:24.000
関数がここで文字列を返していないことに注意してください。

00:08:24.000 --> 00:08:27.000
式構文を返しています。

00:08:27.000 --> 00:08:34.000
マクロは自動的にSwiftパーサーを呼び出して、このリテラルを構文ツリーに変換します。

00:08:34.000 --> 00:08:44.000
また、2番目の引数にリテラル補間スタイルを使用しているため、リテラルの内容が適切にエスケープされていることを確認します。

00:08:44.000 --> 00:08:46.000
虫が好きな人はいない。

00:08:46.000 --> 00:08:54.000
しかし、私がさらに好きなのは、マクロを展開して明示的に要求しない限り、見られないコードのバグです。

00:08:54.000 --> 00:08:58.000
そのため、マクロが十分にテストされていることを確認したいのです。

00:08:58.000 --> 00:09:08.000
マクロには副作用がなく、構文ツリーのソースコードは比較しやすいので、それらをテストする素晴らしい方法は単体テストを書くことです。

00:09:08.000 --> 00:09:12.000
マクロテンプレートにはすでに1つが付属しています。

00:09:12.000 --> 00:09:23.000
このテストケースでは、SwiftSyntaxパッケージの「assertMacroExpansion」関数を使用して、「stringify」マクロが正しく展開されることを確認します。

00:09:23.000 --> 00:09:29.000
入力として、以前に見た「#stringify(a + b)」式を取ります。

00:09:29.000 --> 00:09:42.000
そして、マクロが展開された後、「a + b」と文字列リテラル「a + b」を含むタプルが生成されると主張します。

00:09:42.000 --> 00:09:55.000
マクロを拡張する方法をテストケースに伝えるために、マクロ「#stringify」を「StringifyMacro」タイプを使用して展開することを指定する「testMacros」パラメータを渡します。

00:09:55.000 --> 00:10:09.000
アプリのテストをすでに実行しているのと同じ方法でテストを実行して、実際に合格したかどうかを確認しましょう。

00:10:09.000 --> 00:10:16.000
テストに合格し、それで、私たちはすでに最初のマクロを持っています。

00:10:16.000 --> 00:10:20.000
その中で、私たちはその基本的な構成要素を見ました。

00:10:20.000 --> 00:10:24.000
マクロ宣言は、マクロの署名を定義します。

00:10:24.000 --> 00:10:28.000
また、マクロの役割も宣言します。

00:10:28.000 --> 00:10:31.000
コンパイラプラグインは拡張を実行します。

00:10:31.000 --> 00:10:39.000
これは、それ自体がSwiftで書かれ、SwiftSyntaxツリーで動作するプログラムです。

00:10:39.000 --> 00:10:51.000
また、マクロは構文ツリーの決定論的変換であり、構文ツリーのソースコードは比較しやすいため、非常にテスト可能であることがわかりました。

00:10:51.000 --> 00:10:56.000
だから、「他にどのような状況でマクロを使用できますか?」と疑問に思うかもしれません。

00:10:56.000 --> 00:11:00.000
私たちはすでに自立式のマクロを見てきました。

00:11:00.000 --> 00:11:07.000
要約すると、このマクロはハッシュで綴られ、マクロ式全体を書き換えることができます。

00:11:07.000 --> 00:11:14.000
式の代わりに宣言に拡張する自立宣言の役割もあります。

00:11:14.000 --> 00:11:18.000
他の種類のマクロはアタッチされたマクロです。

00:11:18.000 --> 00:11:25.000
これらは、属性と同じように@で綴られ、マクロが添付されている宣言を拡張できるようにします。

00:11:25.000 --> 00:11:32.000
たとえば、アタッチされたメンバーマクロは、アタッチされたタイプの新しいメンバーを追加します。

00:11:32.000 --> 00:11:40.000
これらの他の役割の詳細については、ベッカがそれらを非常に詳細に説明する「Expand on Swiftマクロ」を見ることを強くお勧めします。

00:11:40.000 --> 00:11:48.000
しかし、現在取り組んでいるアプリのコードベースを改善するのに役立ったので、添付のメンバーの役割に集中したいと思います。

00:11:48.000 --> 00:11:57.000
私はスキーインストラクターでもあり、最近、生徒を連れて行きたいツアーを計画できるアプリに取り組んでいます。

00:11:57.000 --> 00:12:04.000
スキーインストラクターとして絶対に避けたいことの1つは、初心者を難しすぎるゲレンデに連れて行くことです。

00:12:04.000 --> 00:12:08.000
それを強制するためにSwift型システムを使いたい。

00:12:08.000 --> 00:12:20.000
そのため、私のお気に入りのスキーリゾートのすべてのゲレンデを含むスロープ列挙型に加えて、初心者に適したゲレンデのみを含むEasySlopeタイプもあります。

00:12:20.000 --> 00:12:34.000
勾配が本当に簡単な場合は、勾配を簡単な勾配に変換する初期化子と、簡単な勾配を一般的な勾配に戻すための計算されたプロパティがあります。

00:12:34.000 --> 00:12:38.000
これは素晴らしいタイプの安全性を提供しますが、それは本当に反復的です。

00:12:38.000 --> 00:12:45.000
簡単なスロープを追加したい場合は、スロープに追加する必要があります...

00:12:45.000 --> 00:12:53.000
EasySlope、初期化子、および計算されたプロパティ。

00:12:53.000 --> 00:12:56.000
マクロを使って物事を改善できるかどうか見てみましょう。

00:12:56.000 --> 00:13:03.000
私たちがやりたいことは、初期化子と計算されたプロパティを自動的に生成することです。

00:13:03.000 --> 00:13:06.000
どうすればこれができますか?

00:13:06.000 --> 00:13:16.000
イニシャライザと計算されたプロパティの両方がEasySlopeタイプのメンバーであるため、添付されたメンバーマクロを宣言する必要があります。

00:13:16.000 --> 00:13:23.000
次に、マクロの実装を含むコンパイラプラグインを作成します。

00:13:23.000 --> 00:13:29.000
マクロが期待どおりに動作することを確認するために、テスト駆動の方法で開発したいと考えています。

00:13:29.000 --> 00:13:36.000
したがって、テストケースを書くまで、その実装を空のままにします。

00:13:36.000 --> 00:13:45.000
テストケースでマクロの動作を定義した後、そのテストケースと一致するように実装を書きます。

00:13:45.000 --> 00:13:50.000
そして最後に、新しいマクロを私のアプリに統合します。

00:13:50.000 --> 00:13:58.000
すべてがうまくいけば、初期化子を削除し、マクロに生成してもらうことができます。

00:13:58.000 --> 00:14:04.000
マクロを開発するには、先ほど作成したテンプレートで作業します。

00:14:04.000 --> 00:14:09.000
そして、私のアプリに「#stringify」マクロは本当に必要ないので、私はすでにそれを削除しました。

00:14:09.000 --> 00:14:18.000
「@Attached(member)」属性を使用して、新しい添付メンバーマクロを宣言することから始めます。

00:14:18.000 --> 00:14:24.000
EasySlopeはSlopeのサブセットなので、私はそれをSlopeSubsetと呼んでいます。

00:14:24.000 --> 00:14:30.000
マクロは、導入するメンバーの名前も定義します。

00:14:30.000 --> 00:14:34.000
このデモでは、初期化子を生成する方法を紹介します。

00:14:34.000 --> 00:14:42.000
計算されたプロパティの生成は、すべてのケースを切り替える単なるスイッチステートメントであるため、非常によく似ています。

00:14:42.000 --> 00:14:50.000
この宣言では、マクロを定義しましたが、実際に実行する展開を実装していません。

00:14:50.000 --> 00:14:58.000
このため、マクロは WWDCMacros モジュールの SlopeSubsetMacro タイプを参照します。

00:14:58.000 --> 00:15:06.000
本当にエキサイティングな部分である実際のマクロ実装を続けることができるように、そのタイプを作成しましょう。

00:15:06.000 --> 00:15:15.000
SlopeSubsetをアタッチされたメンバーマクロとして宣言したため、対応する実装はMemberMacroプロトコルに準拠する必要があります。

00:15:15.000 --> 00:15:24.000
このプロトコルには、ExpressionMacroに似た「拡張」関数という単一の要件があります。

00:15:24.000 --> 00:15:36.000
「拡張」関数は、マクロを宣言に適用する属性と、マクロが適用される宣言を取ります。

00:15:36.000 --> 00:15:42.000
私たちの場合、これはEasySlope列挙宣言になります。

00:15:42.000 --> 00:15:50.000
次に、マクロは、その宣言に追加したいすべての新しいメンバーのリストを返します。

00:15:50.000 --> 00:16:00.000
この変換をすぐに実装し始めるのは非常に魅力的であることは知っていますが、テストケースを書くことから始めたいことに同意しました。

00:16:00.000 --> 00:16:12.000
今のところ、新しいメンバーを追加すべきではないことを示す空の配列を返しましょう。

00:16:12.000 --> 00:16:17.000
最後に、SlopeSubsetをコンパイラに表示する必要があります。

00:16:17.000 --> 00:16:26.000
このために、私はここで「providingMacros」プロパティに追加します。

00:16:26.000 --> 00:16:32.000
もっと深く掘り下げる前に、私たちがこれまでに持っているものがうまくいくことを確認したいです。

00:16:32.000 --> 00:16:51.000
Xcodeでマクロを適用して拡張されたコードを見てみることができますが、回帰を導入していないことを確認するために、マクロに変更を加えるたびに再実行できるテストケースを書くことを好みます。

00:16:51.000 --> 00:17:03.000
テンプレートのテストケースと同様に、「assertMacroExpansion」関数を使用してマクロの動作を検証します。

00:17:03.000 --> 00:17:16.000
テストしたいのは、EasySlopeタイプに適用したときにマクロが生成するものなので、それをテストケースの入力として使用します。

00:17:16.000 --> 00:17:36.000
そして、マクロはまだ何もしていないので、属性を削除し、新しいメンバーを追加しないことを期待しているので、期待される拡張コードは「@SlopeSubset」なしで入力と同じです。

00:17:36.000 --> 00:17:46.000
最後に、SlopeSubsetMacroの実装を使用してマクロSlopeSubsetを拡張する必要があることをテストケースに知らせる必要があります。

00:17:46.000 --> 00:18:04.000
そのために、マクロ名を「testMacros」辞書の実装タイプにマッピングし、その辞書をアサーション関数に渡す必要があります。

00:18:04.000 --> 00:18:18.000
これまでに書いたことが実際に機能することを確認するために、今テストを実行しましょう。

00:18:18.000 --> 00:18:19.000
そうです。

00:18:19.000 --> 00:18:20.000
すごい。

00:18:20.000 --> 00:18:29.000
しかし、私たちが本当に欲しいのは、属性を削除するだけでなく、マクロが実際に初期化子を生成することを確認することです。

00:18:29.000 --> 00:18:42.000
だから、以前に手書きで書いたコードをテストケースにコピーします。なぜなら、本当に、それがプラグインに生成してほしいものだからです。

00:18:42.000 --> 00:18:53.000
もう一度テストを実行すると、マクロがまだ初期化子を生成していないため、失敗します。

00:18:53.000 --> 00:19:01.000
今すぐそれを変えましょう。

00:19:01.000 --> 00:19:07.000
初期化子は、EasySlopes列挙型で宣言されたすべての列挙要素を切り替えます。

00:19:07.000 --> 00:19:15.000
したがって、最初にする必要があるのは、宣言からこれらの列挙要素を取得することです。

00:19:15.000 --> 00:19:27.000
列挙要素は列挙宣言内でのみ宣言できるため、列挙宣言に「宣言」をキャストすることから始めます。

00:19:27.000 --> 00:19:33.000
マクロが列挙型ではない型にアタッチされている場合は、エラーを発するはずです。

00:19:33.000 --> 00:19:39.000
後で行うことを忘れないようにTODOを追加し、今のところ空の配列を返します。

00:19:39.000 --> 00:19:44.000
次に、列挙型が宣言するすべての要素を取得する必要があります。

00:19:44.000 --> 00:19:52.000
その方法を理解するために、SwiftSyntaxツリーの列挙型の構文構造を調べたいと思います。

00:19:52.000 --> 00:20:02.000
マクロの実装は普通のSwiftプログラムなので、Xcodeから知っているすべてのツールを使ってプログラムをデバッグできます。

00:20:02.000 --> 00:20:17.000
たとえば、拡張関数内にブレークポイントを設定し、テストケースを実行してそのブレークポイントにヒットすることができます。

00:20:17.000 --> 00:20:25.000
マクロの実装内でデバッガが一時停止され、「enumDecl」はEasySlopes列挙型です。

00:20:25.000 --> 00:20:34.000
「Po enumDecl」と入力すると、デバッガに印刷できます。

00:20:34.000 --> 00:20:38.000
出力を調べてみましょう。

00:20:38.000 --> 00:20:46.000
構文ツリーの最も内側のノードは、列挙要素、「beginnersParadise」、および「practiceRun」の斜面を表します。

00:20:46.000 --> 00:20:52.000
それらを取得するには、構文ツリーで概説されている構造に従う必要があります。

00:20:52.000 --> 00:20:59.000
その構造を段階的に説明し、アクセスコードを書きましょう。

00:20:59.000 --> 00:21:04.000
列挙型宣言には「memberBlock」という子があります。

00:21:04.000 --> 00:21:09.000
このメンバーブロックには、中括弧と実際のメンバーの両方が含まれています。

00:21:09.000 --> 00:21:18.000
したがって、メンバーにアクセスするには、「enumDecl.memberBlock.members」から始めます。

00:21:18.000 --> 00:21:23.000
これらのメンバーには、実際の宣言とオプションのセミコロンが含まれています。

00:21:23.000 --> 00:21:31.000
私たちは宣言、特に実際に列挙ケースを宣言する宣言に興味があります。

00:21:31.000 --> 00:21:38.000
コンパクトマップを使用して、列挙ケースであるすべてのメンバー宣言のリストを取得しています。

00:21:38.000 --> 00:21:42.000
各ケース宣言は、複数の要素を宣言できます。

00:21:42.000 --> 00:21:57.000
これは、別々のケースキーワードの後に新しい行に各スロープを宣言する代わりに、「ケースビギナーズパラダイス、練習ラン」と同じ行に書くことができたからです。

00:21:57.000 --> 00:22:03.000
それらすべてを取得するには、「フラットマップ」を使用できます。

00:22:03.000 --> 00:22:14.000
そして、すべての要素を取得したので、実際にEasySlopeに追加したい初期化子の構築を開始できます。

00:22:14.000 --> 00:22:22.000
イニシャライザ宣言には単一の項目があります:スイッチ式。

00:22:22.000 --> 00:22:31.000
このスイッチ式には、列挙型内の各要素のケースと、nilを返すデフォルトのケースが含まれています。

00:22:31.000 --> 00:22:36.000
これらすべてに対して構文ノードを作成する必要があります。

00:22:36.000 --> 00:22:48.000
作成する構文ノードを見つける2つの優れた方法は、以前のように構文ツリーを印刷するか、SwiftSyntaxのドキュメントを読むことです。

00:22:48.000 --> 00:22:56.000
InitializerDeclSyntaxを構築することから始めます。

00:22:56.000 --> 00:23:07.000
このタイプは、結果ビルダーを使用してボディを構築し、ヘッダー、つまり「init」キーワードとすべてのパラメータを指定することで構築できます。

00:23:07.000 --> 00:23:17.000
これにより、結果ビルダー内のforループを使用して、必要なすべての要素を反復することができます。

00:23:17.000 --> 00:23:24.000
テストケースからinitヘッダーをコピーするだけです。

00:23:24.000 --> 00:23:33.000
体内では、スイッチ表現が必要です。

00:23:33.000 --> 00:23:39.000
このタイプには、ヘッダーと結果ビルダーを取る初期化子もあります。

00:23:39.000 --> 00:23:44.000
もう一度使いましょう。

00:23:44.000 --> 00:23:54.000
これで、以前に収集したすべての要素を反復することで、結果ビルダーの力を使うことができます。

00:23:54.000 --> 00:24:06.000
各要素について、「#stringify」で見たように、文字列補間を使用して構築できる新しいケースアイテムを作成します。

00:24:06.000 --> 00:24:14.000
また、nilを返すデフォルトのケースを追加する必要があります。

00:24:14.000 --> 00:24:22.000
そして最後に、初期化子を返すことができます。

00:24:22.000 --> 00:24:32.000
テストを実行して、実際に正しい初期化子を生成しているかどうかを確認します。

00:24:32.000 --> 00:24:33.000
私たちはそうです。

00:24:33.000 --> 00:24:42.000
だから、私たちはマクロが機能し、私のアプリでそれを使い始めることができることを知っています。

00:24:42.000 --> 00:24:50.000
マクロパッケージをXcodeプロジェクトに追加するには、それを右クリックして「パッケージの依存関係を追加」を選択します。

00:24:50.000 --> 00:25:00.000
作成したばかりのローカルパッケージを選択できるようになりました。

00:25:00.000 --> 00:25:12.000
マクロを使用できるように、WWDCターゲットをアプリの依存関係として追加します。

00:25:12.000 --> 00:25:23.000
パッケージからWWDCモジュールをインポートし、SlopeSubsetマクロをEasySlopeタイプに適用できるようになりました。

00:25:23.000 --> 00:25:35.000
...もし私たちが建てるなら...

00:25:35.000 --> 00:25:41.000
...コンパイラは、手書きの初期化子が無効な再宣言であると不平を言います。

00:25:41.000 --> 00:25:46.000
そして、それはマクロが今私たちのためにそれを生成するからです。

00:25:46.000 --> 00:25:53.000
だから、私たちはそれを削除することができます。

00:25:53.000 --> 00:25:56.000
コードを削除するのはいつも楽しいです。でしょ？

00:25:56.000 --> 00:26:06.000
したがって、マクロが実際に生成したものを見たい場合は、SlopeSubsetを右クリックし、[マクロを展開]をクリックします。

00:26:06.000 --> 00:26:16.000
また、マクロが何をするかを忘れた場合は、Optionキーを押しながらクリックしてドキュメントを読むこともできます。

00:26:16.000 --> 00:26:23.000
次のステップは、計算されたプロパティも生成することですが、今日は後で行います。

00:26:23.000 --> 00:26:32.000
マクロを使用することで、反復的なコードを書くことなく、EasySlopesのタイプの安全性を得ることができました。

00:26:32.000 --> 00:26:35.000
どうやってやったの？

00:26:35.000 --> 00:26:39.000
私たちはSwiftマクロパッケージテンプレートから始めました。

00:26:39.000 --> 00:26:48.000
構文ツリーの構造を調べるために、マクロの実行を停止し、デバッガ内に構文ノードを印刷しました。

00:26:48.000 --> 00:26:56.000
これにより、すべての列挙要素を取得するためにどのプロパティにアクセスする必要があるかを見ることができました。

00:26:56.000 --> 00:27:00.000
そして、テストケースを使用して自分でマクロを開発するのは本当に簡単でした。

00:27:00.000 --> 00:27:05.000
アプリに追加した後、すぐに機能しました。

00:27:05.000 --> 00:27:11.000
しかし、マクロがサポートしていない状況で使用された場合はどうなりますか?

00:27:11.000 --> 00:27:23.000
初心者のスキーヤーを困難な斜面に連れて行きたくないのと同じように、マクロに予期しない展開を実行させたり、コンパイルされないコードを生成させたりしたくありません。

00:27:23.000 --> 00:27:37.000
マクロがサポートしていない方法で使用されている場合は、生成されたコードを読んでマクロをデバッグさせるのではなく、何が間違っているかを養子縁組者に知らせるエラーメッセージを常に送信します。

00:27:37.000 --> 00:27:42.000
その精神で、コードベースに残したTODOを修正しましょう。

00:27:42.000 --> 00:27:51.000
SlopeSubsetが列挙型ではない型に適用されると、マクロは列挙型にのみ適用可能であるというエラーを発するはずです。

00:27:51.000 --> 00:28:01.000
以前と同じように、テストケースを追加することから始めましょう。

00:28:01.000 --> 00:28:08.000
今回は、SlopeSubsetマクロを構造体に適用します。

00:28:08.000 --> 00:28:15.000
構造体には列挙要素がないため、マクロが初期化子を生成するとは期待していません。

00:28:15.000 --> 00:28:24.000
代わりに、SlopeSubsetは列挙型にのみ適用できることを知らせるエラーである診断を発行する必要があります。

00:28:24.000 --> 00:28:30.000
このテストを実行すると...

00:28:30.000 --> 00:28:34.000
...まだエラーメッセージを出力していないため、失敗します。

00:28:34.000 --> 00:28:41.000
さあ、コンパイラプラグインに行きましょう。

00:28:41.000 --> 00:28:48.000
マクロエラーは、Swift Errorプロトコルに準拠した任意のタイプで表すことができます。

00:28:48.000 --> 00:29:01.000
SlopeSubsetが列挙型ではない型に適用される場合、エラーメッセージを記述するために、単一のケースを持つ列挙型を使用します。

00:29:01.000 --> 00:29:12.000
展開関数からエラーをスローすると、マクロ展開を呼び出す属性に表示されます。

00:29:12.000 --> 00:29:27.000
属性とは異なる場所にエラーメッセージを表示したり、警告を生成したり、XcodeでFix-Itsを表示したりする場合は、コンテキストパラメータに「addDiagnostic」メソッドがあり、豊富な診断を生成できます。

00:29:27.000 --> 00:29:33.000
しかし、この場合、属性に単純なエラーメッセージを表示するのが効率的だと思います。

00:29:33.000 --> 00:29:43.000
さて、私たちがすべて正しいことをしたかどうか、そしてテストに合格したかどうかを見てみましょう。

00:29:43.000 --> 00:29:45.000
素晴らしい、彼らはそうします。

00:29:45.000 --> 00:29:51.000
では、SlopeSubsetを構造体に適用すると、Xcodeではどのように見えますか?

00:29:51.000 --> 00:30:02.000
このために、テストケースをファイルにコピーさせてください。

00:30:02.000 --> 00:30:07.000
Xcodeは、他のすべてのコンパイルエラーとインラインでカスタムエラーメッセージを表示します。

00:30:07.000 --> 00:30:13.000
これにより、私のマクロの採用者は、彼らが何が間違っているのかを簡単に確認できます。

00:30:13.000 --> 00:30:15.000
そして、あなたは何を知っていますか?

00:30:15.000 --> 00:30:24.000
エラー処理が良好になったので、このマクロは、スロープだけでなく、列挙型サブセットを指定する他の開発者にも役立つかもしれないと思います。

00:30:24.000 --> 00:30:29.000
それを一般化しに行きましょう。

00:30:29.000 --> 00:30:44.000
これまでスロープとしてハードコードされている列挙型のスーパーセットを指定するには、マクロ宣言に汎用パラメータを追加します。

00:30:44.000 --> 00:31:03.000
また、マクロはスロープに固有ではなくなったため、SlopeSubsetを右クリックしてRefactor、Renameを選択してEnumSubsetに名前を変更しましょう。

00:31:03.000 --> 00:31:14.000
また、コマンドキーを押しながらクリックすることで、文字列リテラルとコメント内のすべての出現の名前を変更することもできます。

00:31:14.000 --> 00:31:22.000
ハードコードされたSlopesタイプではなく、一般的なパラメータを使用するようにマクロ実装を調整する必要があります。

00:31:22.000 --> 00:31:43.000
「enumDecl」と同様に、デバッガ内に属性を印刷してレイアウトを調べると、属性の名前の「genericArgumentClause」の最初の引数の「argumentType」にアクセスすることで、汎用パラメータを取得できることがわかります。

00:31:43.000 --> 00:32:00.000
ジェネリックパラメータを取得したので、これまでハードコードされたスロープタイプを変数「supersetType」に置き換えることができます。

00:32:00.000 --> 00:32:11.000
イニシャライザのパラメータの名前の変更、マクロ実装の型名の変更、ドキュメントの更新など、さらにいくつかの変更を加える必要があります。

00:32:11.000 --> 00:32:13.000
後でやります。

00:32:13.000 --> 00:32:22.000
代わりに、今のところ、私たちのテストがまだ合格していることを確認しましょう。

00:32:22.000 --> 00:32:43.000
EnumSubsetをジェネリックにしたので、EnumSubsetマクロに汎用パラメータとしてスロープを渡すことで、EasySlopeがスロープのサブセットであることを明示的に指定する必要があります。

00:32:43.000 --> 00:32:50.000
テストが今合格しているかどうか見てみましょう。

00:32:50.000 --> 00:32:52.000
彼らはそうです。

00:32:52.000 --> 00:32:57.000
このマクロをSwiftパッケージとして他の人に公開することを本当に検討すべきです。

00:32:57.000 --> 00:33:00.000
だから、それは私たちが今日カバーした多くの分野です。

00:33:00.000 --> 00:33:03.000
私たちが経験したことを要約しましょう。

00:33:03.000 --> 00:33:11.000
マクロを作成するには、素晴らしい出発点としてstringifyマクロを含むマクロパッケージテンプレートから始めることができます。

00:33:11.000 --> 00:33:21.000
マクロを開発する際には、マクロが生成するコードが実際に有効であることを確認するために、テストケースを書くことを強くお勧めします。

00:33:21.000 --> 00:33:33.000
また、これを行う場合は、拡張関数にブレークポイントを設定し、テストを実行し、デバッガに構文ツリーを印刷することで、構文ツリーのレイアウトを検査できます。

00:33:33.000 --> 00:33:45.000
そして最後に、特定の状況でマクロが適用されない場合は、物事がうまくいかなくてもマクロが輝くように、常にカスタムエラーメッセージを発行する必要があります。

00:33:45.000 --> 00:33:50.000
見てくれてありがとう、そして私はあなたがどのようなマクロを作成するかを見て興奮しています。

00:33:50.000 --> 23:59:59.000
♪ ♪

