WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:13.000
ヨアヒム・クルツ：「楽器でハングアップを分析する」へようこそ。

00:00:13.000 --> 00:00:17.000
私の名前はヨアヒムで、インスツルメンツチームで働くエンジニアです。

00:00:17.000 --> 00:00:20.000
今日は、Hangsを詳しく見てみたい。

00:00:20.000 --> 00:00:26.000
まず、ハングとは何かの概要を説明します。そうするには、人間の知覚について話す必要があります。

00:00:26.000 --> 00:00:34.000
次に、ハングがどのように引き起こされるかを理解するための基礎を形成するため、イベント処理とレンダリングループについて簡単に説明します。

00:00:34.000 --> 00:00:46.000
この理論的な知識を武器に、Instrumentsに飛び込んで、ビジーなメインスレッドハング、非同期ハング、ブロックされたメインスレッドハングの3つの異なるハング例を見ていきます。

00:00:46.000 --> 00:00:55.000
これらのそれぞれについて、それらを認識する方法、それらを分析するときに何を探すべきか、そして詳細を学ぶためにドキュメントに他の機器を追加するタイミングを知る方法を紹介します。

00:00:55.000 --> 00:01:01.000
始める前に：このセッションの一部では、Instrumentsにいくらか精通しておくと便利です。

00:01:01.000 --> 00:01:05.000
Instrumentsでアプリケーションをプロファイリングしたことがあるなら、行っても大丈夫です。

00:01:05.000 --> 00:01:14.000
それ以外の場合は、2019年のセッション「Instrumentsを使い始める」をチェックしてください。ハングアップを扱う場合：通常3つのステップがあります。

00:01:14.000 --> 00:01:24.000
ハングを見つけ、ハングを分析してそれがどのように起こるかを理解し、それを修正します(そして、それが実際に修正されていることを確認します)。

00:01:24.000 --> 00:01:32.000
今日は、あなたがすでにハングを見つけたと仮定し、分析部分に焦点を当て、いくつかの修正について議論します。

00:01:32.000 --> 00:01:40.000
ハングの検索についてもっと知りたい場合は、WWDC22のセッション「Xcodeとデバイス上の検出によるトラックダウンハング」をご覧ください。

00:01:40.000 --> 00:01:52.000
インストゥルメント、iOS開発者設定で有効にできるオンデバイスハング検出、Xcodeオーガナイザーなど、ハングを見つけるためのすべてのツールをカバーしています。

00:01:52.000 --> 00:01:56.000
今日は、インスツルメンツを使って、すでに見つけたハングを分析します。

00:01:56.000 --> 00:02:03.000
ハングアップをよりよく理解するために、人間の知覚について話し、光をつけましょう。

00:02:03.000 --> 00:02:06.000
電球とケーブルが必要です。

00:02:06.000 --> 00:02:08.000
ああ、はるかに良い。

00:02:08.000 --> 00:02:12.000
ランプのように、ケーブルを差し込むと電源が入りました。

00:02:12.000 --> 00:02:17.000
そして、私が再びそれを引き抜くと、それは停止します。即座に。

00:02:17.000 --> 00:02:19.000
しかし、もし遅延があった場合はどうなりますか?

00:02:19.000 --> 00:02:22.000
プラグを差し込みます。

00:02:22.000 --> 00:02:24.000
そして、ここで電源を入れるのに少し時間がかかりました。

00:02:24.000 --> 00:02:29.000
さらに奇妙なことに、ケーブルを再び引き抜くときにも同じことが起こります。

00:02:29.000 --> 00:02:35.000
ケーブルが差し込まれてライトが点灯するまでの遅延はわずか500ミリ秒でした。

00:02:35.000 --> 00:02:39.000
しかし、それはすでにこの箱の中で何が起こっているのか疑問に思います。

00:02:39.000 --> 00:02:43.000
ランプが直接オン/オフしないのは正しいとは感じません。

00:02:43.000 --> 00:02:48.000
しかし、他の状況では、500ミリ秒の遅延は大丈夫かもしれません。

00:02:48.000 --> 00:02:52.000
どのような遅延が許容されるかは、状況によって異なります。

00:02:52.000 --> 00:02:58.000
「カメはどのようにコミュニケーションをとるのか」というような会話を耳にしたとしましょう。

00:02:58.000 --> 00:03:00.000
「シェルフォン」

00:03:00.000 --> 00:03:06.000
ここでは、質問と回答の間に1秒の遅れがありました。

00:03:06.000 --> 00:03:08.000
そして、それは完全に自然に感じました。

00:03:08.000 --> 00:03:15.000
しかし、これはそうではありません:それはなぜですか?

00:03:15.000 --> 00:03:24.000
カメとユニコーンの会話は、要求と応答スタイルの相互作用ですが、ランプを差し込むことは実際のオブジェクトを直接操作します。

00:03:24.000 --> 00:03:26.000
実際の物体は即座に反応します。

00:03:26.000 --> 00:03:30.000
実在のものをシミュレートすると、即座に反応する必要があります。

00:03:30.000 --> 00:03:34.000
そうでなければ、それは幻想を破ります。

00:03:34.000 --> 00:03:42.000
ケーブルが差し込まれてライトが点灯することの間に遅延がなかったときに、私がここに実際のランプを持っていると主張することに問題はありませんでした。

00:03:42.000 --> 00:03:51.000
しかし、大幅な遅延があると、あなたの脳は突然「ちょっと待ってください、それはこのようなものの仕組みではありません」と言います。

00:03:51.000 --> 00:03:54.000
しかし、インスタントはどれくらい速いですか?

00:03:54.000 --> 00:03:58.000
私たちが気づかないほど小さな遅延は何ですか?

00:03:58.000 --> 00:04:03.000
これが遅延のないベースラインです。

00:04:03.000 --> 00:04:08.000
100ミリ秒はどうですか？

00:04:08.000 --> 00:04:15.000
私にとっては、電源を入れるのに少し遅れがあることに気づいたように感じましたが、電源を切るときではなく、よく見るとだけです。

00:04:15.000 --> 00:04:18.000
あなたの経験は違うかもしれません。

00:04:18.000 --> 00:04:21.000
100ミリ秒はややしきい値です。

00:04:21.000 --> 00:04:25.000
大幅に小さな遅延は、もはや実際には知覚できません。

00:04:25.000 --> 00:04:31.000
250ミリ秒を試してみましょう。

00:04:31.000 --> 00:04:34.000
250ミリ秒はもはやインスタントを感じません。

00:04:34.000 --> 00:04:40.000
遅くはありませんが、遅延は間違いなく目立ちます。

00:04:40.000 --> 00:04:44.000
この種の知覚しきい値は、ハングレポートにも通知します。

00:04:44.000 --> 00:04:51.000
ボタンをタップするなど、離散的なインタラクションで約100ミリ秒未満の遅延は、通常、瞬時に感じられます。

00:04:51.000 --> 00:04:57.000
その下でも行きたいかもしれない特別なケースがいくつかありますが、それは目指すべき良い目標です。

00:04:57.000 --> 00:05:01.000
その上、それは状況によります。

00:05:01.000 --> 00:05:05.000
250ミリ秒まで、あなたはそれを逃れるかもしれません。

00:05:05.000 --> 00:05:09.000
それよりも長く、少なくとも無意識のうちに顕著になります。

00:05:09.000 --> 00:05:15.000
それは連続的なスケールですが、250ミリ秒を超えると、確かにもう瞬時に感じません。

00:05:15.000 --> 00:05:25.000
したがって、ほとんどのツールはデフォルトで250ミリ秒からハングを報告し始めますが、無視しやすいため、これらを「マイクロハング」と呼びます。

00:05:25.000 --> 00:05:30.000
文脈によっては、それらは大丈夫かもしれませんが、多くの場合そうではありません。

00:05:30.000 --> 00:05:34.000
500ミリ秒を超えるものはすべて、適切なハングを検討します。

00:05:34.000 --> 00:05:43.000
これに基づいて、これらのしきい値を大まかに使用できます。何かを瞬時に感じたい場合は、100ミリ秒以下の遅延を目指します。

00:05:43.000 --> 00:05:50.000
リクエストとレスポンススタイルのインタラクションがある場合は、追加のフィードバックなしで500ミリ秒で大丈夫かもしれません。

00:05:50.000 --> 00:05:53.000
しかし、実際には、私たちはしばしば相互作用で両方を持っています。

00:05:53.000 --> 00:05:56.000
例を見てみましょう。 例を見てみましょう。

00:05:56.000 --> 00:06:02.000
このセッションの準備を手伝ってくれたすべての同僚にこのメールを書き終えたばかりで、それを送る準備ができています。

00:06:02.000 --> 00:06:11.000
マウスを[送信]ボタンに移動してクリックすると、しばらくすると、メールウィンドウがアニメーション表示され、送信中であることを示します。

00:06:11.000 --> 00:06:15.000
ここで起こったことは、あなたが実際に2つのことが起こっているのを見たということです。

00:06:15.000 --> 00:06:24.000
まず、ボタンが強調表示され、次に500ミリ秒の小さな遅延があり、次に電子メールウィンドウがアニメーション化されました。

00:06:24.000 --> 00:06:29.000
しかし、ボタンの強調表示のためにリクエストが受信されたことをすでに知っていたので、この遅延は問題なく感じました。

00:06:29.000 --> 00:06:37.000
私たちはボタンを「本物」のものとして扱い、即座に「現実の」時間で更新されることを期待しています。

00:06:37.000 --> 00:06:44.000
したがって、インターフェイスの実際のUI要素については、通常、この「インスタント」アップデートを目指したいと考えています。

00:06:44.000 --> 00:06:50.000
UI要素が「即座に」反応できるようにするには、メインスレッドをUI以外の作業から解放することが不可欠です。

00:06:50.000 --> 00:07:02.000
その理由を知るために、イベントの処理とレンダリングループを詳しく見て、Appleプラットフォームでイベントがどのように処理され、ユーザーの入力がどのように画面の更新につながるかを見てみましょう。

00:07:02.000 --> 00:07:05.000
ある時点で、誰かがデバイスと対話します。

00:07:05.000 --> 00:07:08.000
私たちはそれがいつ起こるかをコントロールできません。

00:07:08.000 --> 00:07:14.000
まず、通常、マウスやタッチスクリーンなどのハードウェアが関係しています。

00:07:14.000 --> 00:07:18.000
インタラクションを検出し、イベントを作成し、オペレーティングシステムに送信します。

00:07:18.000 --> 00:07:26.000
オペレーティングシステムは、イベントを処理する必要があるプロセスを把握し、アプリなど、そのプロセスに転送します。

00:07:26.000 --> 00:07:31.000
アプリでは、イベントを処理するのはアプリのメインスレッドの責任です。

00:07:31.000 --> 00:07:34.000
これは、ほとんどのUIコードが実行される場所です。

00:07:34.000 --> 00:07:36.000
UIの更新方法を決定します。

00:07:36.000 --> 00:07:45.000
その後、このUIアップデートは、個々のUIレイヤーを合成し、次のフレームをレンダリングする別のプロセスであるレンダリングサーバーに送信されます。

00:07:45.000 --> 00:07:53.000
最後に、ディスプレイドライバは、レンダリングサーバーによって準備されたビットマップをピックアップし、それに応じて画面上のピクセルを更新します。

00:07:53.000 --> 00:08:03.000
これがどのように機能するかについてもっと知りたい場合は、「アプリの応答性の向上」のドキュメントで説明します。私たちにとって、この大まかな概要は、何が起こっているのかを理解するのに十分です。

00:08:03.000 --> 00:08:10.000
さて、この間に別のイベントが発生すると、通常は並行して処理できます。

00:08:10.000 --> 00:08:17.000
しかし、単一のイベントがパイプラインをどのように通過するかを見ると、すべてのステップを順番に確認する必要があります。

00:08:17.000 --> 00:08:26.000
メインスレッドにたどり着く前のイベント処理ステップと、レンダリングと更新の表示ステップは、通常、その期間がかなり予測可能です。

00:08:26.000 --> 00:08:40.000
インタラクションの大幅な遅延が発生した場合、ほとんどの場合、メインスレッドの部分に時間がかかりすぎたか、イベントが届いたときにメインスレッドでまだ何かが実行されているため、イベントが処理される前に終了するのを待つ必要があります。

00:08:40.000 --> 00:08:53.000
UI要素へのすべての更新がメインスレッドで時間を必要とし、これらの更新が100ミリ秒以内に行われることを考えると、理想的には、メインスレッドでの作業に100ミリ秒以上はかからないはずです。

00:08:53.000 --> 00:08:56.000
あなたがより速く、さらに良くなることができれば。

00:08:56.000 --> 00:09:04.000
メインスレッドでの長時間の作業もヒッチを引き起こす可能性があり、ヒッチを避けるためにより低いしきい値が適用されることに注意してください。

00:09:04.000 --> 00:09:12.000
ヒッチの詳細については、テックトーク「UIアニメーションヒッチとレンダリングループの探索」と「アプリの応答性の向上」に関するドキュメントをご覧ください。

00:09:12.000 --> 00:09:15.000
今日、私たちはハングアップに焦点を当てています。

00:09:15.000 --> 00:09:21.000
私の同僚の一人は、新機能に取り組んでいる間、私たちのアプリの1つであるBackyard Birdsでハングしているのを見つけました。

00:09:21.000 --> 00:09:31.000
インスツルメンツでアプリをプロファイリングしましょう。

00:09:31.000 --> 00:09:34.000
ここにアプリ付きのXcodeプロジェクトがあります。

00:09:34.000 --> 00:09:47.000
Instrumentsでアプリをプロファイリングするために必要なのは、製品メニューをクリックしてからプロファイリングするだけで、Xcodeがアプリを構築してデバイスにインストールしますが、起動しません。

00:09:47.000 --> 00:09:55.000
Xcodeはまた、Instrumentsを開き、Xcodeで設定されたのと同じアプリとデバイスをターゲットにするように設定します。

00:09:55.000 --> 00:10:07.000
Instrumentsのテンプレートセレクタでは、タイムプロファイラテンプレートを選択します。これは、探しているものをまだわからず、アプリが何をしているのかをよりよく理解したい場合は、しばしば良い出発点です。

00:10:07.000 --> 00:10:11.000
これにより、タイムプロファイラテンプレートから新しいインスツルメンツドキュメントが作成されます。

00:10:11.000 --> 00:10:20.000
とりわけ、この新しい文書にはタイムプロファイラー機器とハングス機器が含まれており、どちらも分析に役立ちます。

00:10:20.000 --> 00:10:24.000
ツールバーの左上にある録画ボタンをクリックして録画を開始します。

00:10:24.000 --> 00:10:30.000
インスツルメントは、設定されたアプリケーションを起動し、データのキャプチャを開始します。

00:10:30.000 --> 00:10:32.000
だから、ここにBackyard Birdsアプリがあります。

00:10:32.000 --> 00:10:36.000
最初の庭をタップすると、詳細ビューに移動します。

00:10:36.000 --> 00:10:44.000
すぐに「背景を選択」ボタンをタップすると、一番下のシートが表示され、選択できる背景画像の選択が表示されます。

00:10:44.000 --> 00:10:48.000
今それをやらせてください。

00:10:48.000 --> 00:10:50.000
ボタンは押されていますが、詰まっているようです。

00:10:50.000 --> 00:10:53.000
シートが表示されるまでにかなり時間がかかりました。

00:10:53.000 --> 00:10:57.000
厳しいハング。

00:10:57.000 --> 00:10:59.000
インスツルメンツはこれらすべてを記録しています。

00:10:59.000 --> 00:11:04.000
ツールバーの停止ボタンをクリックして録音を停止します。

00:11:04.000 --> 00:11:06.000
楽器もハングを検出しました。

00:11:06.000 --> 00:11:11.000
ハング持続時間を測定し、重大度に応じて対応する間隔にラベルを付けます。

00:11:11.000 --> 00:11:15.000
この場合、インスツルメンツは私たちに「深刻なハング」が起こったことを示しています。

00:11:15.000 --> 00:11:20.000
これは、アプリの使用中に経験していることにも当てはまります。

00:11:20.000 --> 00:11:26.000
機器は応答しないメインスレッドを検出し、対応する間隔を潜在的なハングとしてマークします。

00:11:26.000 --> 00:11:29.000
私たちの場合、確かにハングが発生しました。

00:11:29.000 --> 00:11:32.000
応答しないメインスレッドには、主に2つのケースがあります。

00:11:32.000 --> 00:11:37.000
最も単純なケースは、メインスレッドがまだ他の仕事をするのに忙しいということです。

00:11:37.000 --> 00:11:41.000
この場合、メインスレッドには大量のCPUアクティビティが表示されます。

00:11:41.000 --> 00:11:44.000
もう1つのケースは、メインスレッドがブロックされていることです。

00:11:44.000 --> 00:11:49.000
これは通常、メインスレッドが他の場所で他の作業が行われるのを待っているためです。

00:11:49.000 --> 00:11:54.000
スレッドがブロックされると、メインスレッドにCPUアクティビティがほとんどまたはまったくありません。

00:11:54.000 --> 00:11:59.000
どのケースが、何が起こっているのかを判断するために次にどのステップを踏むべきかを決定します。

00:11:59.000 --> 00:12:02.000
インスツルメンツに戻って、メインスレッドを見つける必要があります。

00:12:02.000 --> 00:12:07.000
ドキュメントの最後のトラックは、ターゲットプロセスのトラックを示しています。

00:12:07.000 --> 00:12:12.000
サブトラックがあることを示すために、左側に小さな開示インジケーターがあります。

00:12:12.000 --> 00:12:17.000
クリックすると、プロセス内のスレッドごとに個別のトラックが表示されます。

00:12:17.000 --> 00:12:20.000
次に、ここでメインスレッドトラックを選択します。

00:12:20.000 --> 00:12:31.000
これにより、詳細領域が更新され、プロファイルビューが表示され、記録時間中にメインスレッドで実行されたすべての関数のコールツリーが表示されます。

00:12:31.000 --> 00:12:40.000
しかし、ハング中に起こったことにしか興味がないので、タイムラインのハング間隔をセカンダリクリックしてコンテキストメニューを表示します。

00:12:40.000 --> 00:12:51.000
ここで検査範囲の設定を選択できますが、オプションキーも長押しして、代わりに検査範囲の設定とズームを取得します。

00:12:51.000 --> 00:12:57.000
これにより、間隔の範囲にズームインし、詳細ビューに表示されるデータを選択した時間範囲にフィルタリングします。

00:12:57.000 --> 00:13:08.000
CPU使用率はハング間隔全体で100%ではありませんが、それでもかなり高く、ほとんどの場合、60%から90%のCPU使用率です。

00:13:08.000 --> 00:13:11.000
これは明らかに忙しいメインスレッドの場合です。

00:13:11.000 --> 00:13:15.000
このCPU作業が何であるかを調べてみましょう。

00:13:15.000 --> 00:13:18.000
これで、コールツリー内のすべての異なるノードを詳しく調べることができます。

00:13:18.000 --> 00:13:24.000
しかし、右側には素晴らしい要約があります:最も重いスタックトレースビュー。

00:13:24.000 --> 00:13:31.000
最も重いスタックトレースビューのフレームをクリックすると、コールツリービューが更新され、このノードが表示されます。

00:13:31.000 --> 00:13:38.000
これはまた、このメソッド呼び出しがすでに呼び出しツリーのかなり深いことを示しています。

00:13:38.000 --> 00:13:48.000
デフォルトでは、最も重いスタックトレースは、ソースコードに由来しない後続の関数呼び出しを隠し、ソースコードが関与している場所を簡単に確認できます。

00:13:48.000 --> 00:13:58.000
下部バーの[コールツリー]ボタンをクリックし、[システムライブラリを隠す]チェックボックスを有効にすることで、コールツリービューに同様のフィルタを適用できます。

00:13:58.000 --> 00:14:04.000
これにより、システムライブラリからすべての機能がフィルタリングされ、コードに集中しやすくなります。

00:14:04.000 --> 00:14:12.000
コールツリービューは、ほぼすべてのバックトレースに「BackgroundThumbnailView.body.getter」コールが含まれていることを示しています。

00:14:12.000 --> 00:14:16.000
体のゲッターを速くする必要があるように見えますよね?

00:14:16.000 --> 00:14:18.000
そうでもない！

00:14:18.000 --> 00:14:22.000
したがって、メインスレッドのケースが忙しいことはわかっています。つまり、CPUは多くの作業を行っています。

00:14:22.000 --> 00:14:26.000
また、多くのCPU時間を費やす方法も見つけました。

00:14:26.000 --> 00:14:28.000
しかし、今は2つの異なるケースがあります。

00:14:28.000 --> 00:14:34.000
メソッド自体が長時間実行されるため、このメソッドでは多くのCPU時間を費やす可能性があります。

00:14:34.000 --> 00:14:40.000
しかし、それは何度も呼ばれているだけかもしれません、それがここに現れる理由です。

00:14:40.000 --> 00:14:46.000
メインスレッドの作業をどのように減らすべきかは、どのケースがあるかによって異なります。

00:14:46.000 --> 00:14:49.000
典型的なコールスタックはこのように構成されています。

00:14:49.000 --> 00:14:58.000
メイン関数からの呼び出しがあり、いくつかのUIフレームワークやその他のものを呼び出し、ある時点でコードが呼び出されます。

00:14:58.000 --> 00:15:08.000
この関数が一度だけ呼び出され、その1つの呼び出しが長い時間がかかる場合、ここのタートル関数のように、それが呼び出すものを見てみたい。

00:15:08.000 --> 00:15:14.000
たぶん、それは多くの仕事をします。そうすれば、私たちはそれをより少なくできるかもしれません。

00:15:14.000 --> 00:15:21.000
しかし、私たちが調査している方法は、ここのユニコーンのように何度も呼ばれている可能性もあります。

00:15:21.000 --> 00:15:26.000
そしてもちろん、それが行う作業も何度も何度も行われます。

00:15:26.000 --> 00:15:36.000
これは通常、関数Unicornを何度も呼び出す発信者がいるためです。たとえば、ループから。

00:15:36.000 --> 00:15:47.000
ここのユニコーンに焦点を当てた機能を最適化するのではなく、それをあまり頻繁に呼ぶ方法を調査する方が有益かもしれません。

00:15:47.000 --> 00:15:51.000
つまり、次に見るべき方向は、私たちが持っているケースに依存するということです。

00:15:51.000 --> 00:15:57.000
タートルケースのような長期的な機能については、その実装とその呼び出し先を見てみたい。

00:15:57.000 --> 00:15:59.000
私たちはさらに下を見る必要があります。

00:15:59.000 --> 00:16:10.000
しかし、ユニコーンのように関数が何度も呼び出された場合、それを呼んでいるものを見て、そうしない頻度でできるかどうかを判断する方が有益です。

00:16:10.000 --> 00:16:12.000
私たちはさらに上に目を向ける必要があります。

00:16:12.000 --> 00:16:16.000
しかし、タイムプロファイラは、どのケースを持っているかを教えてくれません。

00:16:16.000 --> 00:16:20.000
ユニコーンとタートルへの電話が次々に起こったと仮定しましょう。

00:16:20.000 --> 00:16:26.000
タイムプロファイラは、CPUで実行されているものを定期的にチェックしてデータを収集します。

00:16:26.000 --> 00:16:31.000
また、サンプルごとに、どの機能が現在CPUで実行されているかをチェックします。

00:16:31.000 --> 00:16:37.000
この例では、タートルとユニコーンの両方を4回取得します。

00:16:37.000 --> 00:16:45.000
しかし、これは非常に速いタートルであり、ユニコーンははるかに時間がかかる、または他の組み合わせである可能性もあります。

00:16:45.000 --> 00:16:50.000
これらのシナリオはすべて、タイムプロファイラで同じデータを作成します。

00:16:50.000 --> 00:16:55.000
特定の関数の実行時間を測定するには、os_signpostsを使用します。

00:16:55.000 --> 00:17:01.000
2019年のセッション「Instrumentsを使い始める」で、その方法について話しました。

00:17:01.000 --> 00:17:06.000
また、何が起こっているのかを正確に伝えることができるさまざまな技術に特化した機器もあります。

00:17:06.000 --> 00:17:10.000
そのうちの1つは、SwiftUI Viewボディインストゥルメントです。

00:17:10.000 --> 00:17:15.000
SwiftUIボディインストゥルメントを追加するには、ツールバーの右上にあるプラスボタンをクリックします。

00:17:15.000 --> 00:17:17.000
これはインストゥルメントライブラリを示しています。

00:17:17.000 --> 00:17:21.000
これは、インスツルメンツアプリケーションが提供しなければならないすべての機器のリストです。

00:17:21.000 --> 00:17:22.000
たくさんあります。

00:17:22.000 --> 00:17:25.000
独自のカスタム楽器を書くこともできます。

00:17:25.000 --> 00:17:30.000
フィルターフィールドに「SwiftUI」と入力すると、2つの楽器が表示されます。

00:17:30.000 --> 00:17:36.000
「本文を表示」インストゥルメントを選択し、ドキュメントウィンドウにドラッグして追加します。

00:17:36.000 --> 00:17:43.000
さて、この機器は最後に記録したときにドキュメントになかったため、表示するデータがありません。

00:17:43.000 --> 00:17:47.000
でも問題ありません。もう一度録音します。

00:17:47.000 --> 00:17:50.000
時間を節約するために、私はすでにそれをしました。

00:17:50.000 --> 00:17:58.000
ドキュメントのSwiftUI View Bodyインストゥルメントで録音した後、View Bodyトラックにもいくつかのデータが表示されます。

00:17:58.000 --> 00:18:01.000
SwiftUIビューボディトラックには多くの間隔があります。

00:18:01.000 --> 00:18:06.000
少し窮屈なので、Ctrl+Plusを押して高さを上げます。

00:18:06.000 --> 00:18:11.000
SwiftUI View Bodyトラックは、実装されているライブラリによって間隔をグループ化します。

00:18:11.000 --> 00:18:14.000
各インターバルは1つのビューボディ実行です。

00:18:14.000 --> 00:18:20.000
もう一度ハングアップしましょう。

00:18:20.000 --> 00:18:27.000
2番目の車線には、すべて「BackgroundThumbnailView」というラベルの付いたオレンジ色の間隔がたくさんあります。

00:18:27.000 --> 00:18:32.000
これは、いくつのボディ処刑があったか、それぞれにどれくらいの時間がかかったかを正確に教えてくれます。

00:18:32.000 --> 00:18:39.000
オレンジ色は、その特定のボディ実行の実行時間が、SwiftUIで目指しているものよりも少し時間がかかったことを示しています。

00:18:39.000 --> 00:18:42.000
しかし、より大きな問題は、間隔がいくつあるかのようです。

00:18:42.000 --> 00:18:47.000
詳細ビューには、すべてのボディ間隔の要約があります。

00:18:47.000 --> 00:18:54.000
Backyard Birdsの横にある開示インジケーターをクリックすると、Backyard Birdsの個々のビュータイプを表示できます。

00:18:54.000 --> 00:19:07.000
これは、BackgroundThumbnailViewのボディが平均持続時間約50ミリ秒で70回実行され、合計持続時間が3秒以上になったことを示しています。

00:19:07.000 --> 00:19:10.000
これは、私たちのハング期間のほとんどすべてを説明しています。

00:19:10.000 --> 00:19:16.000
しかし、前もって6つの画像を表示するだけで、70倍は過剰に思えます。

00:19:16.000 --> 00:19:26.000
これは、体があまり頻繁に呼ばれるべきケースなので、なぜこれが頻繁に呼ばれるのかを調べ、それを減らす方法を調べるために、私たちのボディゲッターの発信者を見る必要があります。

00:19:26.000 --> 00:19:40.000
関連するコードに簡単に移動するには、メインスレッドトラックを再度選択し、コールツリーのBackgroundThumbnailView.body.getterノードをセカンダリクリックしてコンテキストメニューを表示し、「Xcodeで表示」を選択します。

00:19:40.000 --> 00:19:44.000
これにより、Xcodeで本体の実装が開きます。

00:19:44.000 --> 00:19:55.000
タイプをセカンダリクリックして「検索」、「ワークスペースで選択したシンボルを検索」を選択して、このビューがどのように使用されるかを調べてみましょう。

00:19:55.000 --> 00:20:04.000
検索ナビゲーターの最初の結果は、すでに私たちが探しているものです。

00:20:04.000 --> 00:20:14.000
ここでは、「BackgroundThumbnailView」は、グリッド内の別のForEach内のGridRow内のForEach内で使用されます。

00:20:14.000 --> 00:20:23.000
グリッドは、作成時にコンテンツ全体を熱心に計算するので、最初のいくつかしか必要でなくても、すべての背景のサムネイルを計算します。

00:20:23.000 --> 00:20:27.000
しかし、代替案があります:LazyVGrid。

00:20:27.000 --> 00:20:32.000
1つの画面を埋めるために必要なビューの数だけを計算します。

00:20:32.000 --> 00:20:42.000
SwiftUIの多くのビューには、必要な数のビューしか計算しない怠惰なバリアントがあり、これは多くの場合、より少ない作業を行う簡単な方法になります。

00:20:42.000 --> 00:20:47.000
しかし、熱心なバリアントは、同じコンテンツをレンダリングする必要があるときにはるかに少ないメモリを使用します。

00:20:47.000 --> 00:20:56.000
デフォルトで通常の熱心なバリアントを使用し、事前に作業が多すぎることに関連するパフォーマンスの問題を見つけた場合は、怠惰なバリアントに切り替えます。

00:20:56.000 --> 00:21:07.000
「SwiftUIのスタック、グリッド、アウトライン」に関するWWDC 2020のWWDCセッションでは、これらの怠惰なバリアントを紹介し、より詳細に説明しています。

00:21:07.000 --> 00:21:10.000
この更新されたコードをプロファイリングしましょう。

00:21:10.000 --> 00:21:18.000
もう一度「背景を選択」ボタンをタップして、録音を開始し、ハングを再現します。

00:21:18.000 --> 00:21:20.000
さて、これははるかに良いです。

00:21:20.000 --> 00:21:23.000
まだ少し遅れがありましたが、以前ほど悪くはありません。

00:21:23.000 --> 00:21:25.000
楽器はこれを確認します。

00:21:25.000 --> 00:21:29.000
私たちが記録したハングは400ミリ秒未満でした。

00:21:29.000 --> 00:21:33.000
それはマイクロハングです。

00:21:33.000 --> 00:21:42.000
「View Body」トラックはまた、私たちの期待に合った8つのBackgroundThumbnailボディ実行しか得られないことを示しています。

00:21:42.000 --> 00:21:44.000
たぶんこれで十分です。

00:21:44.000 --> 00:21:46.000
マイクロハングはあまり目立たない。

00:21:46.000 --> 00:21:57.000
iPadでBackyard Birdsをプロファイリングすることで、他のデバイスタイプでもうまく機能することを確認しましょう。

00:21:57.000 --> 00:22:00.000
ここで、私はiPadでBackyard Birdsを走らせています。

00:22:00.000 --> 00:22:03.000
私はすでに詳細ビューにいます。

00:22:03.000 --> 00:22:09.000
「背景を選択」ボタンをタップすると、シートが表示されるまでに長い時間がかかります。

00:22:09.000 --> 00:22:12.000
それが現れたら、その理由がわかります。

00:22:12.000 --> 00:22:17.000
画面が大きくなり、スペースが多いため、サムネイルが増えました。

00:22:17.000 --> 00:22:22.000
楽器もこのハングを記録した。

00:22:22.000 --> 00:22:30.000
検査範囲をハング間隔に焦点を合わせると、より多くのBackgroundThumbnailViewボディが再び表示されます。

00:22:30.000 --> 00:22:31.000
それは理にかなっています。

00:22:31.000 --> 00:22:37.000
今、私たちはより多くの多くが画面に収まるように、フルスクリーンのためにそれらの約40をレンダリングする必要があります。

00:22:37.000 --> 00:22:45.000
したがって、同じコードはiPhoneではほとんど問題ありませんでしたが、画面が大きかったという理由だけで、iPadでは遅くなりました。

00:22:45.000 --> 00:22:48.000
これは、マイクロハングも修正する必要がある理由の1つです。

00:22:48.000 --> 00:22:55.000
デスクでのテスト中にマイクロハングとして見るものは、さまざまな条件下で一部のユーザーにとって大きなハングになるかもしれません。

00:22:55.000 --> 00:23:03.000
私たちは今、画面を埋めるために必要な数のビューしかレンダリングしないので、これをあまり頻繁に呼び出すという点で最適化の可能性を使い果たしました。

00:23:03.000 --> 00:23:08.000
個々の実行をより速くするために何ができるかを見つけましょう。

00:23:08.000 --> 00:23:16.000
検査範囲を単一のBackgroundThumbnailView間隔に設定し、「メインスレッド」トラックに切り替えます。

00:23:16.000 --> 00:23:26.000
楽器は、最も重いバックトレースビューでビューボディゲッターを示し、「BackyardBackground.thumbnail」プロパティゲッターと呼ばれることを示しています。

00:23:26.000 --> 00:23:31.000
これは、ビューに表示するサムネイル画像を提供するモデルオブジェクトです。

00:23:31.000 --> 00:23:38.000
このサムネイルゲッターは「UIImage imageByPreparingThumbnailOfSize:」と呼びます。

00:23:38.000 --> 00:23:41.000
だから、私たちはここでその場でサムネイルを計算しているようです。

00:23:41.000 --> 00:23:46.000
それには時間がかかることがあります。この場合、約150ミリ秒。

00:23:46.000 --> 00:23:51.000
これは、メインスレッドを忙しくさせないように、むしろバックグラウンドで行うべき作業です。

00:23:51.000 --> 00:23:58.000
どのような変更を加えることができるかをよりよく理解するために、サムネイルゲッターがどのように呼ばれるかを文脈で見てみたい。

00:23:58.000 --> 00:24:07.000
最も重いスタックトレースビューの「BackgroundThumbnailView.body.getter」フレームをセカンダリクリックし、「ソースビューアで開く」を選択します。

00:24:07.000 --> 00:24:21.000
これは、コールツリービューをソースビューアに置き換え、ボディゲッターの実装を表示し、タイムプロファイラサンプルで実装の行に注釈を付けて、コードがどのくらいの時間を費やしたかを示します。

00:24:21.000 --> 00:24:28.000
私たちの体の実装はここで本当に簡単です。背景から返されたサムネイルで新しい画像ビューを作るだけです。

00:24:28.000 --> 00:24:32.000
しかし、このサムネイルコールには長い時間がかかります。

00:24:32.000 --> 00:24:34.000
私はそれを違う方法で書く方法のアイデアがあります。

00:24:34.000 --> 00:24:42.000
Xcodeにジャンプするには、右上のメニューボタンをクリックし、「Xcodeでファイルを開く」を選択します。

00:24:42.000 --> 00:24:46.000
以前と同様に、これはXcodeのソースコードを示し、変更を加える準備ができています。

00:24:46.000 --> 00:24:53.000
今やりたいことは、サムネイルをバックグラウンドでロードし、ロード中に進行状況インジケーターを表示することです。

00:24:53.000 --> 00:25:00.000
まず、ロードされたサムネイルを保持するための状態変数が必要です。

00:25:00.000 --> 00:25:09.000
次に、本文で、ロードされた画像がすでにある場合は、画像ビューで使用します。

00:25:09.000 --> 00:25:14.000
それ以外の場合は、進捗ビューを表示します。

00:25:14.000 --> 00:25:18.000
今残っているのは、実際のサムネイルを読み込むことだけです。

00:25:18.000 --> 00:25:21.000
ビューが表示されたら、読み込みを開始したいです。

00:25:21.000 --> 00:25:27.000
それが「.task」修飾子のためです。

00:25:27.000 --> 00:25:36.000
登場すると、SwiftUIは「サムネイル」ゲッターを呼び出すタスクを開始し、結果を「画像」に割り当て、ビューを更新します。

00:25:36.000 --> 00:25:38.000
やってみよう！

00:25:38.000 --> 00:25:44.000
だから、ここで、楽器の録音で、「背景を選択」ボタンをタップすると、シートがすぐに出てきます!

00:25:44.000 --> 00:25:45.000
すごい！

00:25:45.000 --> 00:25:49.000
進捗指標を見て、数秒後にサムネイルが表示されました。

00:25:49.000 --> 00:25:53.000
これはうまくいった。いいね！

00:25:53.000 --> 00:25:58.000
しかし、待って、楽器はまだほぼ2秒のハングを示しています。

00:25:58.000 --> 00:26:01.000
ここで起こったことは、ハングが少し遅れて起こるということです。

00:26:01.000 --> 00:26:05.000
裏庭の鳥アプリでどこで起こるかをお見せしましょう。

00:26:05.000 --> 00:26:06.000
私はすでに詳細ビューにいます。

00:26:06.000 --> 00:26:14.000
しばらくしたら、「背景を選択」ボタンをもう一度タップし、完了ボタンをタップしてすぐにシートを閉じようとします。

00:26:14.000 --> 00:26:19.000
OK、「背景を選択」と「完了」。

00:26:19.000 --> 00:26:24.000
私は何度もタップしましたが、読み込みが行われている間、私のタップは無視されました。

00:26:24.000 --> 00:26:27.000
これはインスツルメンツが私たちに語ったハングです。

00:26:27.000 --> 00:26:30.000
シートが表示された後に発生します。

00:26:30.000 --> 00:26:33.000
これは少し違うタイプのハングです。

00:26:33.000 --> 00:26:38.000
メインスレッドがビジーであるかブロックされているかの違いについてはすでに話しました。

00:26:38.000 --> 00:26:44.000
ハングを見る別の方法があります。それらが何によって引き起こされるのか、いつ発生するのか。

00:26:44.000 --> 00:26:50.000
私たちはこれらを同期および非同期ハングと呼びます。

00:26:50.000 --> 00:26:52.000
ここでは、いくつかの作業を行うメインスレッドがあります。

00:26:52.000 --> 00:26:59.000
イベントが入ってくると、そのイベントを処理するのに長い時間がかかる場合、それはハングです。

00:26:59.000 --> 00:27:06.000
それをコントロールし、イベントが迅速に処理されるようにしましょう。

00:27:06.000 --> 00:27:14.000
しかし、おそらく、メインスレッドで後で行われる作業を遅らせたり、他のメインスレッド作業が発生したりして、イベントが入ってくるかもしれません。

00:27:14.000 --> 00:27:19.000
その後、そのイベントは、処理する前に、以前の作業が完了するのを待たなければなりません。

00:27:19.000 --> 00:27:26.000
その後、個々のイベント処理のコードがすぐに終了しても、これはハングを引き起こします。

00:27:26.000 --> 00:27:34.000
私たちのプラットフォームでハング検出が機能する方法は、メインスレッド上のすべての作業項目を見て、それらが長すぎるかどうかを確認することです。

00:27:34.000 --> 00:27:38.000
もしそうなら、それは潜在的なハングとしてそれらをマークします。

00:27:38.000 --> 00:27:49.000
そして、ユーザー入力があったかどうかに関係なく、ユーザー入力はいつでも入ってくる可能性があり、実際のハングが発生する可能性があるため、それを行います。

00:27:49.000 --> 00:28:00.000
これは、ハング検出がこれらの非同期または遅延ケースも検出することを意味しますが、実際に経験した遅延ではなく、潜在的な遅延のみを測定します。

00:28:00.000 --> 00:28:12.000
非同期ハングを非同期と呼びます。これは、多くの場合、メインキューでの「dispatch_async」作業、またはメインアクターで非同期に実行されるSwift Concurrencyタスクによって引き起こされるためです。

00:28:12.000 --> 00:28:16.000
しかし、それらはメインスレッドでの作業を引き起こすものによって引き起こされる可能性があります。

00:28:16.000 --> 00:28:18.000
私たちが最初に見たハングは同期ハングでした。

00:28:18.000 --> 00:28:26.000
ボタンをタップすると、そのボタンをタップすると長時間作業が発生するため、結果が遅れて表示されます。

00:28:26.000 --> 00:28:30.000
この最新のハングは、非同期または遅延ハングです。

00:28:30.000 --> 00:28:35.000
完了ボタンをタップしても、実際には高価な作業自体は引き起こされません。

00:28:35.000 --> 00:28:40.000
しかし、タップが処理されるのを防ぐメインスレッドにはまだ作業がありました。

00:28:40.000 --> 00:28:49.000
したがって、アプリを使用している人は、この期間中にアプリと対話しない場合に気付かないかもしれませんが、万が一に備えて、これらのケースを修正する必要があります。

00:28:49.000 --> 00:28:50.000
今それをやりましょう。

00:28:50.000 --> 00:28:56.000
だから、ここで私はInstrumentsに戻り、すでに選択範囲を非同期ハングに設定し、ズームインしました。

00:28:56.000 --> 00:29:04.000
ビューボディトラックのサマリービューで、Instrumentsは、BackgroundThumbnailViewのボディゲッターに75回の呼び出しがあったことを示しています。

00:29:04.000 --> 00:29:09.000
これは、ほとんどのサムネイルボディゲッターが2回実行されるためです。

00:29:09.000 --> 00:29:14.000
SwiftUIは、グリッドを埋めるための進捗インジケータで40のビューを作成します。

00:29:14.000 --> 00:29:28.000
しかし、実際には35のみが表示され、それらの35については、画像の読み込みを開始し、画像が読み込まれると、ビューが更新され、ボディが再び呼び出され、合計75のボディゲッターの実行が与えられます。

00:29:28.000 --> 00:29:34.000
合計で75人のボディゲッター全員でさえ、1ミリ秒未満しかかかりませんでした。

00:29:34.000 --> 00:29:37.000
だから、私たちのボディゲッターは今速いです。その部分はうまくいった。

00:29:37.000 --> 00:29:39.000
しかし、私たちにはまだハングがあります。

00:29:39.000 --> 00:29:49.000
「メインスレッド」トラックをもう一度選択し、最も重いスタックトレースビューで、インスツルメンツはそれがまだメインスレッドで長い時間がかかるサムネイルゲッターであることを示しています。

00:29:49.000 --> 00:29:57.000
今回は、ボディゲッターではなく、「BackgroundThumbnailView.body.getter」内のクロージャによって呼び出されます。

00:29:57.000 --> 00:30:02.000
私はそれをダブルクリックします。これは、ソースビューアを開くためのショートカットです。

00:30:02.000 --> 00:30:08.000
さて、これはまさに、タスク修飾子のクロージャにあるため、バックグラウンドで実行すると予想されるコードです。

00:30:08.000 --> 00:30:14.000
このコードはこの時点で実行する必要がありますが、メインスレッドでは実行しないでください。

00:30:14.000 --> 00:30:23.000
このような問題では、Swift並行性タスクが期待どおりに実行されない場合は、別の便利なツールがあります。Swift並行性タスクツールです。

00:30:23.000 --> 00:30:28.000
私はすでにSwift並行性タスクインストゥルメントを追加して同じ動作を記録しました。

00:30:28.000 --> 00:30:38.000
Swift Tasksインストゥルメントは、ドキュメントにサマリートラックを追加しますが、私たちのケースにとってより興味深いのは、各スレッドトラックに貢献するデータです。

00:30:38.000 --> 00:30:44.000
ここでは、メインスレッドトラックに、Swift Tasksインストゥルメントからの新しいグラフがあります。

00:30:44.000 --> 00:30:47.000
1つのトラックに複数のグラフを表示できます。

00:30:47.000 --> 00:30:53.000
スレッドトラックヘッダーの小さな下向き矢印をクリックすると、表示するグラフを設定できます。

00:30:53.000 --> 00:31:03.000
タイムプロファイラーのCPU使用率グラフのような別のグラフを選択するか、Commandキーを押しながらクリックして複数を選択できます。

00:31:03.000 --> 00:31:10.000
だから今、Instrumentsは、このスレッドのCPU使用率とSwiftタスクグラフの両方を一緒に表示しています。

00:31:10.000 --> 00:31:14.000
もう一度ハング間隔にズームインします。

00:31:14.000 --> 00:31:22.000
「スウィフトタスク」レーンは、メインスレッドに多数のタスク実行があることを明確に表示するようになりました。

00:31:22.000 --> 00:31:34.000
検査範囲をそのうちの1つに設定し、プロファイルビューで最も重いスタックトレースをチェックすると、このタスクがサムネイル計算作業をラップしていることを確認します。

00:31:34.000 --> 00:31:37.000
だから、この仕事は私たちが望んでいたようなタスクに正しくラップされています。

00:31:37.000 --> 00:31:42.000
しかし、タスクはメインスレッドで実行されており、これは予想外です。

00:31:42.000 --> 00:31:44.000
ここで何が起こっているのか説明しましょう。 

00:31:44.000 --> 00:31:50.000
まず、ボディゲッターはSwiftUIのViewプロトコルから@MainActorアノテーションを継承します。

00:31:50.000 --> 00:32:00.000
「body」は「View」プロトコルで「@MainActor」として注釈が付けられているため、実装すると、body getterも@MainActorとして暗黙的に注釈が付けられます。

00:32:00.000 --> 00:32:08.000
第二に、「.task」修飾子のクロージャは、周囲のコンテキストのアクター分離を継承するために注釈付けされます。

00:32:08.000 --> 00:32:14.000
したがって、ボディゲッターはMainActorに隔離されているため、タスクの閉鎖も同様になります。

00:32:14.000 --> 00:32:28.000
したがって、このクロージャで実行されているすべてのコードは、デフォルトでメインアクターで実行され、「サムネイル」ゲッターは同期しているため、メインスレッドで同期的に実行されます。

00:32:28.000 --> 00:32:34.000
Swift並行性タスクは、デフォルトでは、周囲のコンテキストのアクター分離を継承します。

00:32:34.000 --> 00:32:38.000
同じ動作がSwiftUIの.task修飾子にも当てはまります。

00:32:38.000 --> 00:32:41.000
主役から離れるには2つの方法があります。

00:32:41.000 --> 00:32:49.000
メインアクターにバインドされていない関数を非同期に呼び出すと、タスクがメインアクターからオフになります。

00:32:49.000 --> 00:32:52.000
これが実現不可能な場合があるかもしれません。

00:32:52.000 --> 00:33:07.000
次に、「Task.detached」を使用して、周囲のアクターコンテキストからタスクを明示的に切り離すことができますが、これは重いアプローチであり、別のタスクを作成することは、既存のタスクを一時停止するよりも高価です。

00:33:07.000 --> 00:33:20.000
SwiftUIは、対応するビューが消えると、タスク修飾子を介して作成されたタスクを自動的にキャンセルしますが、このキャンセルはTask.detachedのような新しい非構造化タスクに伝播しません。

00:33:20.000 --> 00:33:30.000
詳細については、WWDC22の「Swift並行性の視覚化と最適化」と、アプリの応答性の向上に関するドキュメントをご覧ください。

00:33:30.000 --> 00:33:40.000
私たちの場合、私たちはすでに非同期のコンテキストにあり、サムネイル関数を非分離して非同期にするのは簡単なので、オプション1を選択します。

00:33:40.000 --> 00:33:43.000
ここに、サムネイルの読み込みコードがあります。

00:33:43.000 --> 00:33:56.000
問題は、ボディゲッターのメインアクター分離を継承するため、このタスクがメインアクターで実行され、サムネイルゲッターが同期しているため、メインアクターにもとどまることです。

00:33:56.000 --> 00:33:57.000
修正は簡単です。

00:33:57.000 --> 00:34:10.000
サムネイルゲッターの定義にジャンプし、ゲッターを非同期にしてから、ビュー構造体に戻ります...

00:34:10.000 --> 00:34:16.000
そして、私たちのゲッターは現在非同期であるため、その前に待機を追加する必要があります。

00:34:16.000 --> 00:34:22.000
これにより、「サムネイル」ゲッターは、メインスレッドではなく、Swift Concurrencyの同時スレッドプールで実行できるはずです。

00:34:22.000 --> 00:34:24.000
やってみよう。

00:34:24.000 --> 00:34:28.000
再び詳細ビューに移動し、「背景を選択」をタップします。

00:34:28.000 --> 00:34:30.000
うわー。速かった！

00:34:30.000 --> 00:34:34.000
ハングがなかっただけでなく、全体的な読み込みが速かったようにも見えました。

00:34:34.000 --> 00:34:37.000
進捗の見方をほとんど見なかった。

00:34:37.000 --> 00:34:40.000
楽器は、今ハングがなかったことを確認します。

00:34:40.000 --> 00:34:43.000
ここには高いCPU使用率があります。

00:34:43.000 --> 00:34:46.000
それをズームインさせてください。

00:34:46.000 --> 00:34:49.000
これは、サムネイルの読み込みが今行われている場所です。

00:34:49.000 --> 00:34:56.000
メインスレッドをチェックすると、メインスレッドのすべてのタスク間隔が非常に短いことが確認できます。

00:34:56.000 --> 00:35:08.000
他のスレッドトラックまでスクロールすると、Swiftタスクが順番に実行されるのではなく、他のスレッドで並行して実行されていることがわかり、マルチコアCPUをはるかにうまく活用できます。

00:35:08.000 --> 00:35:15.000
これにより、ほぼ1.5秒ではなく、数百ミリ秒ですべてのサムネイルを計算できます。

00:35:15.000 --> 00:35:21.000
そして、この間ずっと、メインスレッドは応答性を維持しているので、私たちは今これを永久に修正しました。

00:35:21.000 --> 00:35:31.000
私たちは今、メインスレッドがビジーであることによって引き起こされた応答しないメインスレッドを調査し、修正しました。これは、ハング中に多くのCPUを使用してメインスレッドで識別することができました。

00:35:31.000 --> 00:35:47.000
また、ユーザーインタラクションまたは非同期の一部として直接発生するときにハングが同期になる方法、以前にメインスレッドでスケジュールされた作業により、着信イベントが遅れて処理され、Instrumentsが両方のケースを検出する方法も経験しました。

00:35:47.000 --> 00:35:57.000
そして、作業を少なくして、他の作業をすることで、バックグラウンドではあまりできず、メインスレッドに戻ってUIを更新するだけで、ハングアップを修正しました。

00:35:57.000 --> 00:36:05.000
しかし、私たちがまだ見ていないケースが1つあります。ブロックされたメインスレッドです。その場合、メインスレッドはCPUをほとんど使用しません。

00:36:05.000 --> 00:36:12.000
他の次元はブロックされたメインスレッドにも同じように適用されますが、そのようなケースを分析するには他の機器が必要です。

00:36:12.000 --> 00:36:15.000
では、例を見てみましょう。

00:36:15.000 --> 00:36:18.000
ここに別のハングからのトレースファイルがあります。

00:36:18.000 --> 00:36:23.000
私はすでにハングにズームインしました。それは長いものです。数秒。

00:36:23.000 --> 00:36:32.000
「メインスレッド」トラックでは、CPU使用率グラフは、初期CPU使用率があることを示していますが、その後は何もありません。

00:36:32.000 --> 00:36:35.000
これは、ブロックされたメインスレッドの明確なケースです。

00:36:35.000 --> 00:36:41.000
タイムプロファイラがCPUで実行されているものをサンプリングしてデータを収集する方法について話しました。

00:36:41.000 --> 00:36:48.000
ズームインすると、CPU使用率グラフには個々のサンプルも表示されます。

00:36:48.000 --> 00:36:53.000
したがって、これらのマーカーのそれぞれは、タイムプロファイラが取ったサンプルです。

00:36:53.000 --> 00:36:59.000
右側にはさらにいくつかのサンプルがありますが、何もありません。

00:36:59.000 --> 00:37:07.000
しかし、サンプルのない時間範囲を選択すると、タイムプロファイラは、この間にデータを記録しなかったため、何が起こっているのかを伝えることができません。

00:37:07.000 --> 00:37:12.000
そのため、別のツールであるスレッドステート機器が必要です。

00:37:12.000 --> 00:37:16.000
以前の他の楽器と同様に、楽器ライブラリから追加できます。

00:37:16.000 --> 00:37:22.000
今回は「スレッドステートトレース」機器を追加して、すでに同じハングを再び録音しました。

00:37:22.000 --> 00:37:24.000
今、この楽器のための新しいトラックがあります。

00:37:24.000 --> 00:37:31.000
しかし、「Swift Concurrency」機器のように、私たちにとって興味深いデータは実際には「スレッド」トラックにあります。

00:37:31.000 --> 00:37:39.000
だから、メインスレッドには6秒以上のこの本当に長い「ブロックされた」間隔があり、これは私たちのハング時間のほとんどを説明しています。

00:37:39.000 --> 00:37:49.000
真ん中をクリックすると、Instrumentsのタイムカーソルがそこに移動し、詳細領域のナラティブビューも更新され、このブロック状態のエントリが表示されます。

00:37:49.000 --> 00:37:57.000
物語の見解は、スレッドの物語を教えてくれます。それが何をしていたのか、いつ、なぜ。

00:37:57.000 --> 00:38:08.000
選択した時間では、スレッドが6.64秒間ブロックされ、syscallであるmach_msg2_trapを呼び出していたためにブロックされたことがわかります。

00:38:08.000 --> 00:38:11.000
右側には、再びバックトレースビューがあります。

00:38:11.000 --> 00:38:15.000
しかし、このバックトレースは最も重いバックトレースではありません-それはいくつかの集約ではありません。

00:38:15.000 --> 00:38:22.000
スレッドがブロックされたのは、mach_msg2_trap syscallの正確なバックトレースです。

00:38:22.000 --> 00:38:28.000
関数呼び出しは下部にリーフノードとして表示され、そのコールスタックは上に表示されます。

00:38:28.000 --> 00:38:48.000
コールスタックは、システムコールがMLModelを割り当てた結果として発生したことを示しています。これは、そのカラー化サービスで「共有」と呼ばれるシングルトンプロパティの一部として呼び出されたタイプ「ColorizingService」のオブジェクトを割り当てたために発生し、ボディゲッターのクロージャによって呼び出されました。

00:38:48.000 --> 00:38:55.000
そのクロージャをダブルクリックすると、再びソースビューアにジャンプし、これが呼び出されたコードを見つけることができます。

00:38:55.000 --> 00:38:57.000
このラインは無害に見えますよね?

00:38:57.000 --> 00:39:01.000
詳しく見てみましょう。 

00:39:01.000 --> 00:39:07.000
ColorizingServiceの共有プロパティにアクセスし、ローカル変数に保存しています。

00:39:07.000 --> 00:39:19.000
ただし、共有プロパティは、初めてアクセスされたときに共有ColorizingServiceインスタンスを作成し、スレッドをブロックするモデルローディング機械全体をキックオフするため、無害ではありません。

00:39:19.000 --> 00:39:26.000
だから、「待つ」の後にこれを非同期部分の中に移動させましょう」と言いたくなるかもしれません。

00:39:26.000 --> 00:39:30.000
しかし、直感に反して、これは問題を解決しません。

00:39:30.000 --> 00:39:35.000
「Await」キーワードは、後続のコードの非同期関数呼び出しにのみ適用されます。

00:39:35.000 --> 00:39:40.000
この例では、「colorize」関数は「async」です。

00:39:40.000 --> 00:39:43.000
しかし、「共有」財産はそうではありません。

00:39:43.000 --> 00:39:51.000
静的letプロパティであるため、初めてアクセスされたときに遅延して初期化され、それは同期的に行われます。

00:39:51.000 --> 00:39:57.000
Awaitキーワードは変更されないため、同期呼び出しはメインスレッドで引き続き発生します。

00:39:57.000 --> 00:40:06.000
共有プロパティを「非同期」にすることで、前の例と同じようにこれを修正して、メインアクターから降りることができます。

00:40:06.000 --> 00:40:13.000
これは一般的に、前方の進捗状況が達成される他の場所でスレッドに代わって作業を待っているときにOKです。

00:40:13.000 --> 00:40:18.000
しかし、ブロックされたスレッドのもう1つの一般的な理由は、ロックまたはセマフォです。

00:40:18.000 --> 00:40:30.000
ベストプラクティスを心に留めておくべきことと、Swift並行性でロックとセマフォを使用する際の避けるべきことについては、WWDC 21のセッション「Swift並行性：舞台裏」をご覧ください。

00:40:30.000 --> 00:40:35.000
締めくくる前に、ブロックされたメインスレッドに関連するもう1つのケースについて話したいと思います。

00:40:35.000 --> 00:40:38.000
これが私たちが先ほど見た痕跡です。

00:40:38.000 --> 00:40:42.000
右側は、ブロックされたメインスレッドで調査したハングです。

00:40:42.000 --> 00:40:51.000
しかし、その左側には、メインスレッドが数秒間ブロックされる他のケースがいくつかありますが、Instrumentsはこれを潜在的なハングとしてフラグを立てません。

00:40:51.000 --> 00:40:55.000
ここでは、ユーザー入力がなかったため、メインスレッドはちょうどスリープ状態です。

00:40:55.000 --> 00:41:04.000
オペレーティングシステムの観点から見ると、それはブロックされていますが、何もすることがないときに実行しないことでリソースを節約しているだけです。

00:41:04.000 --> 00:41:08.000
入力が入ってくるとすぐに、それは目を覚まし、それを処理します。

00:41:08.000 --> 00:41:17.000
したがって、ブロックされたスレッドが応答性の問題であるかどうかを判断するには、スレッド状態のインストゥルメントではなく、ハングストゥルメントを見てください。

00:41:17.000 --> 00:41:20.000
したがって、ブロックされたメインスレッドは、応答しないメインスレッドを意味するものではありません。

00:41:20.000 --> 00:41:26.000
同様に、高いCPU使用率も、メインスレッドが応答しないことを意味するものではありません。

00:41:26.000 --> 00:41:33.000
しかし、メインスレッドが応答しない場合、それはブロックされたか、メインスレッドがビジーだったことを意味します。

00:41:33.000 --> 00:41:42.000
当社のハング検出は、これらすべての詳細を考慮に入れ、メインスレッドが実際に応答しなかった間隔にのみラベルを付け、潜在的なハングとして表示します。

00:41:42.000 --> 00:41:53.000
このセッションから1つだけ覚えている場合は、メインスレッドで行っている作業が何であれ、イベント処理のためにメインスレッドを解放するために100ミリ秒未満で完了する必要があります。

00:41:53.000 --> 00:41:56.000
短ければ短いほど良い。

00:41:56.000 --> 00:42:00.000
ハングを詳細に分析するために、インスツルメンツはあなたの親友です。

00:42:00.000 --> 00:42:09.000
ビジーメインスレッドとブロックされたメインスレッドの区別を覚えておいてください。また、ハングはメインスレッドの非同期作業によって引き起こされる可能性があることを忘れないでください。

00:42:09.000 --> 00:42:14.000
ハングを修正するには、作業を減らすか、作業をバックグラウンドに移動したいと考えています。

00:42:14.000 --> 00:42:17.000
時には、両方でさえも。

00:42:17.000 --> 00:42:22.000
そして、多くの場合、より少ない仕事をするということは、その仕事に適したAPIを使用することを意味します。

00:42:22.000 --> 00:42:27.000
一般的に、最適化する前に、最初に測定し、実際にハングがあるかどうかを確認してください。

00:42:27.000 --> 00:42:33.000
確かにいくつかのベストプラクティスがありますが、並行および非同期コードもデバッグがはるかに困難です。

00:42:33.000 --> 00:42:40.000
あなたはしばしば、実際に非常に速く、実際に遅くなるすべてのものに驚くでしょう。

00:42:40.000 --> 00:42:43.000
すべてのハングを見つけて、分析して、修正して楽しんでください。

00:42:43.000 --> 00:42:45.000
ご覧いただきありがとうございます。

00:42:45.000 --> 23:59:59.000
♪ ♪

