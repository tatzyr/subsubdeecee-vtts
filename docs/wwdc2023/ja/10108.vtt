WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:13.000
ジャレッド：こんにちは、「バックグラウンドアセットの新機能」へようこそ。

00:00:13.000 --> 00:00:16.000
私の名前はジャレッドで、アップルのソフトウェアエンジニアです。

00:00:16.000 --> 00:00:21.000
背景資産で今年の新しいことをすべてあなたと共有することを本当に楽しみにしています。

00:00:21.000 --> 00:00:23.000
さて、私たちのチームは昨年、いくつかのことを変えました。

00:00:23.000 --> 00:00:27.000
ただし、バックグラウンドアセットが導入された私の前のセッションをチェックすることをお勧めします。

00:00:27.000 --> 00:00:31.000
そこには、この新しいセッションが構築する多くの詳細な情報があります。

00:00:31.000 --> 00:00:38.000
このセッションでは、バックグラウンドアセットの概要と、それをアプリに採用すべき理由を説明することから始めます。

00:00:38.000 --> 00:00:45.000
次に、私たちのチームがあなたと共有することに本当に興奮している全く新しい機能を含むバックグラウンドアセットの今年の新機能について話し合います。

00:00:45.000 --> 00:00:55.000
次に、自分でダウンロードできるバックグラウンドアセットのサンプル実装を順を追って説明し、この技術を採用することでアプリのユーザーエクスペリエンスを大幅に向上させる方法を紹介します。

00:00:55.000 --> 00:01:00.000
次に、アプリ拡張機能のデバッグとそのエントリポイントのシミュレーションに関するガイダンスを提供します。

00:01:00.000 --> 00:01:05.000
オーケー！バックグラウンドアセットの簡単な要約を見てみましょう。

00:01:05.000 --> 00:01:08.000
バックグラウンドアセットの背後にある主な目標の1つは、待つことを防ぐことです。

00:01:08.000 --> 00:01:14.000
ユーザーが体験したい最後のことは、アプリを起動し、大量のダウンロードが完了するのを待たなければならないことです。

00:01:14.000 --> 00:01:20.000
バックグラウンドアセットは、そのフレームワークと関連するアプリ拡張機能を組み合わせてこの問題を解決します。

00:01:20.000 --> 00:01:26.000
この新技術は、macOS Venturaの最初のリリースと同時にiOS 16.1で導入されました。

00:01:26.000 --> 00:01:33.000
CDNプロバイダーまたは管理するサーバーを使用して、アプリの追加コンテンツをダウンロードする機能をサポートしています。

00:01:33.000 --> 00:01:42.000
たとえば、このコンテンツは、最初のアプリのインストール時、アプリの更新時、またはユーザーがアプリを使用していないときに定期的にバックグラウンドで取得される場合があります。

00:01:42.000 --> 00:01:50.000
ペアリングされたアプリ拡張機能を通じて、アプリがユーザーによってアクティブに使用されていないときに実行されるコードを書くことができます。

00:01:50.000 --> 00:01:58.000
この技術は現在、macOS、iOS、iPadOSでサポートされているため、お気に入りのプラットフォームですでに利用可能です。

00:01:58.000 --> 00:02:04.000
バックグラウンドアセットの使用に関する最良の部分の1つは、ユーザーがアプリを起動する前に拡張機能を実行できることです。

00:02:04.000 --> 00:02:09.000
これは、アプリがApp Storeからインストールされた瞬間にアセットの取得を開始する方法を提供します。

00:02:09.000 --> 00:02:13.000
拡張機能は、バックグラウンドでシステムによって定期的に起動されることもあります。

00:02:13.000 --> 00:02:19.000
これは、ユーザーがアプリを起動したときに、新規または更新されたアセットが存在することを確認するためです。

00:02:19.000 --> 00:02:23.000
この拡張機能は、アプリが実行されていないときにダウンロードにサービスを提供するためにも使用されます。

00:02:23.000 --> 00:02:30.000
たとえば、ファイルのダウンロードが完了すると、ファイルを最終目的地に移動できるように拡張子が起動します。

00:02:30.000 --> 00:02:34.000
覚えておくべきことは、拡張機能のランタイムが限られているということです。

00:02:34.000 --> 00:02:38.000
これは、ユーザーのデバイスが電力とパフォーマンスに最適化されていることを確認するためです。

00:02:38.000 --> 00:02:41.000
これについてすぐに詳しく説明します。

00:02:41.000 --> 00:02:47.000
また、バックグラウンドアセットで使用するために開発したアプリ拡張機能が、特殊なサンドボックスに配置されていることを知っておくことも重要です。

00:02:47.000 --> 00:02:52.000
これは、拡張機能がバックグラウンドアセットを介してコンテンツを管理するためにのみ使用されていることを確認するためです。

00:02:52.000 --> 00:02:59.000
サンドボックス内で機能やAPIが利用できない場合は、フィードバックアシスタントを通じてお問い合わせください。

00:02:59.000 --> 00:03:06.000
先ほど、アプリの拡張機能は、アプリのインストール、アプリのアップデート、および定期的にバックグラウンドで3つのシステムイベント中に呼び出されると述べました。

00:03:06.000 --> 00:03:10.000
このライフサイクルがどのように管理されているかを見てみましょう。

00:03:10.000 --> 00:03:17.000
拡張機能のライフサイクルは、App Storeがデバイスにアプリをインストールまたは更新したときに始まります。

00:03:17.000 --> 00:03:22.000
その後、バックグラウンドアセットシステムサービスが通知され、アプリの起動を防ぎます。

00:03:22.000 --> 00:03:28.000
その後、システムはアプリバンドルを検査し、BAManifestURLキーのInfo.plistを読み取ります。

00:03:28.000 --> 00:03:36.000
システムは、そのキーで参照されるマニフェストのダウンロードを開始し、ダウンロードの進捗状況をApp Storeに報告します。

00:03:36.000 --> 00:03:44.000
マニフェストがダウンロードされると、システムは特定のインストールまたは更新イベントのコンテンツリクエストを発行して拡張機能をスリープ解除します。

00:03:44.000 --> 00:03:48.000
コンテンツリクエストには、ダウンロードしたマニフェストへのパスが含まれています。

00:03:48.000 --> 00:03:55.000
拡張機能は、マニフェストを使用して、URL、ファイルサイズ、およびダウンロードをスケジュールするアセットを決定する必要があります。

00:03:55.000 --> 00:04:02.000
その後、拡張機能がダウンロードする必要があるアセットを決定したら、それらのダウンロードをBADownloadsのセットとして返します。

00:04:02.000 --> 00:04:09.000
その後、システムはアプリの拡張機能を一時停止するか、時には終了して、デバイスの電力とパフォーマンスを節約します。

00:04:09.000 --> 00:04:16.000
その後、ダウンロードが開始され、拡張機能は完了後すぐに通知されます。

00:04:16.000 --> 00:04:23.000
定期的なコンテンツ要求は、アプリのインストールイベントとほぼ同じですが、唯一の重要な違いは、デバイスがイベントがいつ発生するかを決定することです。

00:04:23.000 --> 00:04:28.000
デバイスは、ユーザーがデバイスをどのように使用しているかに基づいてこの決定を下します。

00:04:28.000 --> 00:04:35.000
低電力モード、バックグラウンドアプリの更新、またはアプリの起動頻度などの重要な要素はすべて考慮されます。

00:04:35.000 --> 00:04:42.000
さて、もう少し深く掘り下げて、エクステンションが定期的に実行されるときに寄与する要因を見てみましょう。

00:04:42.000 --> 00:04:50.000
私たちはデバイスの全体的なパフォーマンスと電力使用量を非常に気にかけているため、バックグラウンドアセットは拡張機能のランタイムに制限を設けています。

00:04:50.000 --> 00:04:54.000
これには、拡張機能のメモリ使用量の強制が含まれます。

00:04:54.000 --> 00:04:59.000
拡張機能が数メガバイトのメモリを超えると、システムによって終了される可能性があります。

00:04:59.000 --> 00:05:10.000
したがって、デバイスのストレージによってバックアップされたメモリマップされたデータはこの制限にカウントされないため、拡張機能が読み取る必要がある大きなファイルのメモリマッピングを検討することをお勧めします。

00:05:10.000 --> 00:05:15.000
アプリが最初にインストールされると、1日あたり数分のランタイムのデフォルト割り当てが提供されます。

00:05:15.000 --> 00:05:21.000
これはあまり聞こえないかもしれませんが、適切に設計された拡張機能では、これは長い道のりを行くことができます。

00:05:21.000 --> 00:05:24.000
ランタイムはアプリの使用状況によっても変わります。

00:05:24.000 --> 00:05:29.000
アプリがしばらく起動されていない場合、システムは拡張機能の起動を抑制し始める可能性があります。

00:05:29.000 --> 00:05:38.000
たとえば、めったに使用されないアプリでは、ランタイムがより厳しく制限される可能性がありますが、一般的に使用されるアプリには追加のランタイムが与えられる場合があります。

00:05:38.000 --> 00:05:44.000
BADownloaderExtensionプロトコルは、アプリ拡張機能へのエントリポイントとして使用される機能を定義します。

00:05:44.000 --> 00:05:50.000
ランタイムは、関数がシステムによって呼び出されたときにカウントされ始め、その関数がスコープを終了したときにカウントされなくなります。

00:05:50.000 --> 00:05:57.000
関数がスコープを終了するか、拡張機能のランタイムが使い果たされると、システムは拡張機能を一時停止または終了する可能性があります。

00:05:57.000 --> 00:06:00.000
すぐに例を挙げます。

00:06:00.000 --> 00:06:04.000
ただし、拡張機能のランタイムを制御する関数スコープには1つの例外があります。

00:06:04.000 --> 00:06:13.000
非同期排他的制御APIが呼び出された場合、その完了ハンドラが呼び出されて返されるまで、拡張機能は実行され続けます。

00:06:13.000 --> 00:06:17.000
拡張機能のランタイムがユーザーによって制御される方法はいくつかあります。

00:06:17.000 --> 00:06:28.000
たとえば、デバイスが低電力モードの場合、またはバックグラウンドアプリの更新が無効になっている場合、それがグローバルであろうと特定のアプリであろうと、拡張機能は決して実行されなくなります。

00:06:28.000 --> 00:06:32.000
以前、拡張ランタイムが関数スコープに基づいてどのように決定されるかについて言及しました。

00:06:32.000 --> 00:06:37.000
それがどのように機能するかをよりよく理解するために、例を見てみましょう。

00:06:37.000 --> 00:06:42.000
このコードは、バックグラウンドダウンロードにサービスを提供する拡張機能のインターフェースを表しています。

00:06:42.000 --> 00:06:47.000
BADownloaderExtensionプロトコルは、システムが拡張機能に呼び出す機能を定義します。

00:06:47.000 --> 00:06:52.000
それでは、このプロトコルに準拠するために必要な機能の1つを追加しましょう。

00:06:52.000 --> 00:06:57.000
「リクエストのダウンロード」機能は、拡張機能への主要なエントリポイントの1つです。

00:06:57.000 --> 00:07:05.000
そのBAContentRequestは、アプリのインストール中、アプリの更新中、またはバックグラウンドでの定期的なチェックの一部として呼び出されるかどうかを定義します。

00:07:05.000 --> 00:07:11.000
manifestURL引数は、拡張機能が呼び出される前にダウンロードされたローカルファイルへのパスを提供します。

00:07:11.000 --> 00:07:19.000
マニフェストファイルは、現在ダウンロードされているものと、サーバーで利用可能なダウンロードを比較するために一般的に使用されます。

00:07:19.000 --> 00:07:24.000
関数定義の戻り値タイプには、BADownloadタイプに準拠した一連のダウンロードオブジェクトが必要です。

00:07:24.000 --> 00:07:32.000
これは、この関数の要求に応答するには、関数がスコープを終了する前にダウンロードする必要があるコンテンツを同期的に返す必要があることを意味します。

00:07:32.000 --> 00:07:37.000
しかし、この考案された例では、parseManifestという関数を呼び出すとしましょう。

00:07:37.000 --> 00:07:44.000
この関数は、ダウンロードしたマニフェストを読み取り、ダウンロードする必要があるBADownloadオブジェクトを返します。

00:07:44.000 --> 00:07:51.000
ただし、parseManifest関数の実装が不十分で、ダウンロードの解析と構築に30分かかるとしましょう。

00:07:51.000 --> 00:07:57.000
これは、拡張機能のランタイムを大幅に超過し、拡張機能は終了します。

00:07:57.000 --> 00:08:07.000
拡張機能のランタイムは、「リクエストのダウンロード」関数が呼び出された瞬間から、スコープを終了して返されるまで計算されることを覚えておくことが重要です。

00:08:07.000 --> 00:08:11.000
別の問題のある例を見てみましょう。

00:08:11.000 --> 00:08:18.000
BADownloaderExtensionプロトコル機能のいずれかがスコープを終了するたびに、拡張が一時停止されてから終了する可能性があります。

00:08:18.000 --> 00:08:24.000
プロトコルはどの機能も突然変異として定義しておらず、これには正当な理由があることに気づくでしょう。

00:08:24.000 --> 00:08:30.000
拡張機能が終了すると、インスタンス変数やインメモリ状態は保存されません。

00:08:30.000 --> 00:08:35.000
拡張機能が何らかの状態を維持する必要がある場合は、その状態をディスクにシリアライズする必要があります。

00:08:35.000 --> 00:08:42.000
次に、ダウンロードを管理するために拡張機能とアプリの両方から使用するAPIについて話しましょう。

00:08:42.000 --> 00:08:47.000
フレームワーク内のダウンロードマネージャは、バックグラウンドアセットシステムサービスと通信する主な方法です。

00:08:47.000 --> 00:08:51.000
マネージャーは、アプリ全体で使用できるシングルトンオブジェクトです。

00:08:51.000 --> 00:08:58.000
マネージャーを使用すると、バックグラウンドでアセットのダウンロードをスケジュールし、すでにスケジュールされているダウンロードをフォアグラウンドにプロモートできます。

00:08:58.000 --> 00:09:07.000
ダウンロードマネージャーから、アプリが起動する前に拡張機能によってスケジュールされていた可能性がある、現在飛行中のダウンロードを管理することもできます。

00:09:07.000 --> 00:09:16.000
また、アプリと関連する拡張機能の両方が同時に同様の操作を実行していないことを確認するために使用できる同期メカニズムもあります。

00:09:16.000 --> 00:09:25.000
ダウンロードマネージャーについて最後に持ち出したいのは、BADownloaderExtensionプロトコルと同様に、ダウンロードに関するコールバックを受信するためのデリゲートがあることです。

00:09:25.000 --> 00:09:31.000
BADownloadManagerにデリゲートを登録すると、拡張機能の代わりにそれらのコールバックが届きます。

00:09:31.000 --> 00:09:36.000
これは、アプリが実行中にダウンロードを管理する方法を提供するので便利です。

00:09:36.000 --> 00:09:44.000
ダウンロードの管理方法について簡単に復習したので、すでにユーザーのデバイスにファイルがインストールされているときに、それらのファイルを管理する方法について話しましょう。

00:09:44.000 --> 00:09:52.000
バックグラウンドアセットでダウンロードしたファイルはパージ可能とマークされています。つまり、システムは重大な状況下でそれらを削除する可能性があります。

00:09:52.000 --> 00:09:58.000
システムのセキュリティアップデート、またはユーザーが子供の最初のステップのビデオをキャプチャする必要があるかどうかを考えてください。

00:09:58.000 --> 00:10:05.000
ただし、ダウンロードしたアセットを変更または拡張した場合、それらのファイルはシステムによって追跡されないため、パージできません。

00:10:05.000 --> 00:10:10.000
資産を変更したり、そこからデータを抽出したりする方法について慎重に考える必要があります。

00:10:10.000 --> 00:10:19.000
ダウンロードしたアセットを誤って管理すると、ユーザーのデバイスのバックアップのサイズを大きくしたり、重要なセキュリティアップデートがダウンロードされないようにしたりする可能性があります。

00:10:19.000 --> 00:10:23.000
したがって、ダウンロードしたアセットをキャッシュディレクトリに保存してみてください。

00:10:23.000 --> 00:10:28.000
そうすれば、システムは、そうすることが重要なときにそれらをパージできることを知っています。

00:10:28.000 --> 00:10:35.000
これで、これらすべてがどのように機能するかを完全に要約したので、バックグラウンドアセットで今年の新機能を見てみましょう。

00:10:35.000 --> 00:10:43.000
今年初め、アプリのインストールまたは更新中にコンテンツを取得する方法を提供する必須ダウンロードを導入しました。

00:10:43.000 --> 00:10:49.000
これは、ダウンロードがiOSのホーム画面、macOS Launchpad、およびApp Storeに完全に統合されていることを意味します。

00:10:49.000 --> 00:10:57.000
エンドユーザーにとって、アセットのダウンロードは、アプリがまだApp Storeからダウンロードされているかのように表示されます。

00:10:57.000 --> 00:11:03.000
これはまた、必須ダウンロードが飛行中である間、ユーザーがアプリを起動できないことを意味します。

00:11:03.000 --> 00:11:06.000
ユーザーができることは、インストールをキャンセルまたは一時停止することだけです。

00:11:06.000 --> 00:11:13.000
一時停止がサポートされているため、再開ができるように、サーバーはHTTP範囲をサポートする必要があります。

00:11:13.000 --> 00:11:18.000
必須ダウンロードはアプリのインストール中に発生するため、必須ではないダウンロードよりも優先されます。

00:11:18.000 --> 00:11:21.000
見てみましょう。 

00:11:21.000 --> 00:11:25.000
すべては、App StoreまたはTestFlightからアプリが要求されたときに始まります。

00:11:25.000 --> 00:11:33.000
アプリのInfo.plistに必須のアセットキーが含まれている場合、進捗状況がデバイスに設定され、このフローを通過します。

00:11:33.000 --> 00:11:45.000
アプリがダウンロードされてインストールされると、システムはコンテンツのリクエストを発行して拡張機能をウェイクします。これには、アプリのインストール、アプリのアップデート、または定期的なフェッチのリクエストが含まれます。

00:11:45.000 --> 00:11:50.000
この間、マニフェストをダウンロードするために認証チャレンジが送信される場合があります。

00:11:50.000 --> 00:11:55.000
その後、あなたの拡張機能は、本質的なダウンロードと非本質的なダウンロードの組み合わせを返送します。

00:11:55.000 --> 00:12:04.000
補足として、この機能が戻るまで、アプリのダウンロードの進行状況がユーザーにフリーズして表示されるため、拡張機能がダウンロードをすばやく返すことが重要です。

00:12:04.000 --> 00:12:10.000
拡張機能がダウンロードを提供した瞬間、必須としてマークされたダウンロードはすぐに開始されます。

00:12:10.000 --> 00:12:16.000
この間、エクステンションも追加の認証チャレンジを受ける可能性があります。

00:12:16.000 --> 00:12:23.000
すべての必須ダウンロードが完了すると、システムは拡張機能を終了し、アプリはユーザーによって起動可能になります。

00:12:23.000 --> 00:12:27.000
その後、拡張機能は、成功したダウンロードと失敗した可能性のあるダウンロードのバッチを受け取ります。

00:12:27.000 --> 00:12:34.000
ダウンロードに失敗した場合は、BADownloadManagerを使用して不要として再キューに入れることができます。

00:12:34.000 --> 00:12:42.000
拡張機能が必須ダウンロードの完了メッセージを受信しているため、システムはすぐに非必須資産のダウンロードを開始します。

00:12:42.000 --> 00:12:47.000
必須でないダウンロードは、ダウンロードが完了すると拡張機能に送信されます。

00:12:47.000 --> 00:12:55.000
それでは、iOSホーム画面のApp Storeのインストールの進捗状況に不可欠なダウンロードがどのように統合されているかを見てみましょう。

00:12:55.000 --> 00:13:07.000
進捗インジケーターの割合は、基本アプリのダウンロードにかかる時間、インストールにかかる時間、続いて重要な資産のダウンロードに必要な時間に分類されます。

00:13:07.000 --> 00:13:15.000
アプリのInfo.plistで定義された新しいBAEssentialDownloadAllowanceキーは、最初の全体的な進捗インジケータを設定するために使用されます。

00:13:15.000 --> 00:13:27.000
次に、contentForRequestが拡張機能に呼び出され、拡張機能がダウンロードを返すと、各必須ダウンロードのファイルサイズが一緒に追加され、実際にダウンロードされている量が決定されます。

00:13:27.000 --> 00:13:35.000
ダウンロードをスケジュールする金額が必須ダウンロード許容量よりも大幅に少ない場合、進行状況インジケータはかなり速く動く可能性があります。

00:13:35.000 --> 00:13:42.000
ユーザーの円滑な進行を確実にするために、実際にダウンロードされているものに近い必須ダウンロード許容量を得ることを目指すべきです。

00:13:42.000 --> 00:13:47.000
私たちが議論したことはすべて、ユーザーによって無効にされる可能性があることを覚えておくことが重要です。

00:13:47.000 --> 00:13:51.000
App Storeの設定ペインには、アプリ内コンテンツを無効にするためのセクションがあります。

00:13:51.000 --> 00:14:01.000
これはバックグラウンドアセット全体を無効にしませんが、ユーザーがアプリを起動する前に、重要なアセットのダウンロードと拡張機能の実行を防ぎます。

00:14:01.000 --> 00:14:07.000
したがって、不可欠な資産をまさにそれと考えることが重要です。不可欠ですが、アプリを起動するための要件ではありません。

00:14:07.000 --> 00:14:15.000
したがって、アプリが起動されたときに、必須資産がまだデバイス上にないフローを処理することが重要です。

00:14:15.000 --> 00:14:22.000
エッセンシャルアセットを使用する機能は、実際には春の初めにiOS 16.4とmacOS Ventura 13.3の一部として導入されました。

00:14:22.000 --> 00:14:28.000
新しいAPIは非常に最小限で、既存の拡張機能に簡単に追加する必要があります。

00:14:28.000 --> 00:14:35.000
必須ダウンロードをサポートするために作成された最初のAPIは、実際にはBAURLDownloadの新しい初期化子でした。

00:14:35.000 --> 00:14:39.000
この機能をサポートするために特別に追加した2つの新しい引数があります。

00:14:39.000 --> 00:14:49.000
本質的な議論は、その名前が示すように、ダウンロードを必須としてマークする必要があるかどうかを指定し、本質的な手段はアプリの全体的なダウンロードとインストールの進捗状況に貢献することを意味します。

00:14:49.000 --> 00:14:53.000
ファイルサイズの引数は、ダウンロードされるアセットのサイズです。

00:14:53.000 --> 00:14:57.000
重要なダウンロードを作成するときは、ファイルサイズが正確でなければなりません。

00:14:57.000 --> 00:15:03.000
ユーザーのデバイスにアプリのインストールの進行状況が正しく表示されるように、この情報が必要です。

00:15:03.000 --> 00:15:11.000
バックグラウンドアセットがダウンロードしたファイルがここで提供されたファイルサイズと一致しない場合、ダウンロードが必須としてマークされている場合、ダウンロードは失敗します。

00:15:11.000 --> 00:15:22.000
拡張子がファイルのサイズがわからない場合は、拡張子が起動する前に拡張子に提供されるBAManifestURLにファイルサイズを含める必要があります。

00:15:22.000 --> 00:15:29.000
導入された別のAPIは、ダウンロードの非本質的な表現を作成するための簡単なワンライナーを提供します。

00:15:29.000 --> 00:15:36.000
必須ダウンロードはcontentForRequest関数でのみキューに入れられるため、このAPIは多くの場合に役立ちます。

00:15:36.000 --> 00:15:45.000
たとえば、ネットワークの問題やファイルが一時的に利用できなくなったため、必須ダウンロードの取得に失敗したとします。

00:15:45.000 --> 00:15:53.000
さて、拡張機能内のバックグラウンドダウンロード失敗関数では、そのダウンロードの不要な表現を簡単に作成し、それを再キューに入れることができます。

00:15:53.000 --> 00:16:00.000
その後、ダウンロードはバックグラウンドで開始され、拡張機能またはアプリが完了すると通知されます。

00:16:00.000 --> 00:16:06.000
それでは、アプリのInfo.plistに存在する必要がある必要なキーのいくつかを見てみましょう。

00:16:06.000 --> 00:16:09.000
昨年のセッションでは、これらの各キーを詳細に説明しました。

00:16:09.000 --> 00:16:13.000
より詳細な説明をご希望の場合は、その講演をチェックすることをお勧めします。

00:16:13.000 --> 00:16:23.000
これらのキーは、バックグラウンドアセットフレームワークを使用するだけでなく、アプリをApp Storeに提出するためにも必要であることを覚えておくことが重要です。

00:16:23.000 --> 00:16:31.000
今年は、重要な資産をサポートするために必要な2つの新しいキーがあります。BAEssentialDownloadAllowanceとBAEssentialMaxInstallSizeです。

00:16:31.000 --> 00:16:40.000
必須ダウンロード許容量はバイト単位で表され、すべての必須資産の合計がダウンロードに要する金額の上限を定義します。

00:16:40.000 --> 00:16:49.000
ユーザーがアプリをインストールしたときにダウンロードの進行がスムーズになるように、この番号をキューに入れる必須アセットのサイズにできるだけ近づけることが重要です。

00:16:49.000 --> 00:16:56.000
もう1つの新しいキーであるBAEssentialMaxInstallSizeは、ユーザーのデバイスに抽出されたアセットの最大サイズを表します。

00:16:56.000 --> 00:17:03.000
この数字は、重要な資産がインストールされた後、アプリが使用するストレージの量をユーザーに伝える方法として、App Storeに表示されます。

00:17:03.000 --> 00:17:07.000
これは、重要な資産のために追加した新しいAPIをほぼ要約しています。

00:17:07.000 --> 00:17:12.000
先ほど見たように、既存のアプリに不可欠なアセットサポートを追加することは、最小限のコード変更で行うことができます。

00:17:12.000 --> 00:17:13.000
それは本当に簡単です。 

00:17:13.000 --> 00:17:15.000
さて、楽しい部分のために。

00:17:15.000 --> 00:17:20.000
URLSessionを使用する既存のアプリをバックグラウンドアセットの使用に拡張する方法を見てみましょう。

00:17:20.000 --> 00:17:28.000
今日お見せするアプリは、これと同じようにWWDCセッションをダウンロードし、オフラインで視聴できるようにデバイスに保存します。

00:17:28.000 --> 00:17:32.000
現在、ビデオがダウンロードされる前にアプリを起動する必要があります。

00:17:32.000 --> 00:17:39.000
バックグラウンドアセットを採用することで、アプリが起動する前にビデオがすでにダウンロードされていることで、この待ち時間をなくすことができます。

00:17:39.000 --> 00:17:41.000
見てみましょう。 

00:17:41.000 --> 00:17:45.000
これが私たちが今日構築するアプリです。

00:17:45.000 --> 00:17:49.000
起動した瞬間に、セッションがすぐにダウンロードされ始めることに気づくでしょう。

00:17:49.000 --> 00:17:56.000
このアプリの現在の仕組みは、WWDCセッションのリストを含むサーバーからのマニフェストのダウンロードです。

00:17:56.000 --> 00:18:02.000
マニフェストがフェッチされた後、セッションはダウンロードを開始し、タップすると表示可能になります。

00:18:02.000 --> 00:18:07.000
このプロジェクトにバックグラウンドアセットを採用するために必要なものを見てみましょう。

00:18:07.000 --> 00:18:14.000
バックグラウンドアセットAPIの使用を開始する前に、最初に追加するのは、先ほど説明した最初のInfo.plistキーです。

00:18:14.000 --> 00:18:18.000
これらのキーは、アプリバンドルのInfo.plistファイルに存在する必要があります。

00:18:18.000 --> 00:18:23.000
次に行う必要があるのは、バックグラウンドダウンロード拡張機能を追加してアプリに埋め込むことです。

00:18:23.000 --> 00:18:28.000
拡張機能のバンドル識別子にアプリのバンドル識別子が先頭に付けられていることを確認する必要があります。

00:18:28.000 --> 00:18:38.000
また、アプリグループとは、拡張機能がダウンロードしたアセットをアプリと共有する方法であるため、アプリとその拡張機能の両方が共通のアプリグループにあることを確認する必要があります。

00:18:38.000 --> 00:18:43.000
最後に確認したいのは、アプリとその拡張機能の両方がチーム識別子で署名されていることです。

00:18:43.000 --> 00:18:48.000
これらのステップを邪魔にならないようにして、バックグラウンドアセットの採用を開始できます。

00:18:48.000 --> 00:18:52.000
目の前には、先ほど見たアプリのXcodeプロジェクトがあります。

00:18:52.000 --> 00:18:57.000
私はすでにダウンロード拡張機能を作成し、アプリに埋め込みました。

00:18:57.000 --> 00:19:00.000
また、必要なInfo.plistキーも追加しました。

00:19:00.000 --> 00:19:07.000
そのすべてを邪魔にならないように、SessionManagerに移動することから始めましょう。

00:19:07.000 --> 00:19:12.000
このプロジェクトのSessionManagerは現在、URLSessionを使用して最新のダウンロードを取得しています。

00:19:12.000 --> 00:19:15.000
URLSessionは素晴らしいAPIです。

00:19:15.000 --> 00:19:18.000
マニフェストを取得するためにアプリ内で引き続き使用します。

00:19:18.000 --> 00:19:22.000
ただし、バックグラウンドアセットを使用して実際のセッションを取得するように移行します。

00:19:22.000 --> 00:19:31.000
これは、アプリが起動時にフォアグラウンドに作成しようとしている拡張機能によって、バックグラウンドでスケジュールされたアセットを宣伝できるようにするためのものです。

00:19:31.000 --> 00:19:38.000
まず、バックグラウンドアセットフレームワークモジュールをインポートすることから始めます。

00:19:38.000 --> 00:19:44.000
その後、下にスクロールして、URLSessionに関連付けられた変数を削除します。

00:19:44.000 --> 00:19:49.000
次に、「ダウンロードの開始」方法に移動します。

00:19:49.000 --> 00:19:54.000
ご覧のとおり、既存のコードは、URLSessionダウンロードタスクによってダウンロードするセッションを追跡していました。

00:19:54.000 --> 00:19:58.000
これはもう必要ないので、削除しましょう。

00:19:58.000 --> 00:20:01.000
ここで物事が面白くなり始めます。

00:20:01.000 --> 00:20:06.000
バックグラウンドアセットで作業するときは、拡張機能とアプリが同時に実行されている可能性について考えることが重要です。

00:20:06.000 --> 00:20:16.000
これをほぼ楽な方法で調整するには、withExclusiveControlを使用して、他のプロセスとの相互排除を必要とする作業がそうできることを保証する必要があります。

00:20:16.000 --> 00:20:21.000
今、それを追加しましょう。

00:20:21.000 --> 00:20:24.000
わかるように、このAPIは非同期でエスケープです。

00:20:24.000 --> 00:20:32.000
拡張機能がこのAPIも使用している場合、クロージャ内でスケジュールされた作業は、拡張機能から独立して実行されることが保証されます。

00:20:32.000 --> 00:20:36.000
すぐに拡張機能を実装しますが、今のところはアプリに集中しましょう。

00:20:36.000 --> 00:20:43.000
相互に排他的なコンテキストで実行されていることを知っているので、現在飛行中のダウンロードがあるかどうか、ダウンロードマネージャーに聞いてみましょう。

00:20:43.000 --> 00:20:47.000
拡張機能がすでにスケジュールされている場合、ダウンロードを再スケジュールする理由はありません。

00:20:47.000 --> 00:20:55.000
しかし、私たちができることの1つは、既存のダウンロードを見つけたら、それをフォアグラウンドに宣伝できることです。

00:20:55.000 --> 00:21:01.000
ダウンロードをフォアグラウンドに宣伝すると、ダウンロードが終了するまでにかかる時間を大幅に短縮できます。

00:21:01.000 --> 00:21:06.000
ユーザーは現在アプリを使用しているため、できるだけ早くダウンロードを取得する絶好の機会です。

00:21:06.000 --> 00:21:07.000
ユーザーはそれを見たいと思うかもしれません。

00:21:07.000 --> 00:21:12.000
ダウンロードがまだ存在しない場合は、作成します。

00:21:12.000 --> 00:21:19.000
その後、ダウンロードを作成したばかりか、拡張機能が作成したかにかかわらず、フォアグラウンドで開始します。

00:21:19.000 --> 00:21:27.000
バックグラウンドからフォアグラウンドにダウンロードを宣伝しても、ダウンロードが再起動することはなく、そのトランジションで中断したところから再開されるだけです。

00:21:27.000 --> 00:21:39.000
リストの次のことは、BADownloadManagerDelegateを実装することですが、その前に、古いURLSessionDelegateを削除します。

00:21:39.000 --> 00:21:45.000
古いデリゲートがなくなったので、バックグラウンドアセットデリゲートを作成しましょう。

00:21:45.000 --> 00:21:51.000
セッションマネージャーはデリゲートに準拠しているため、これらのメッセージを実際に受信するために配線されていることが重要です。

00:21:51.000 --> 00:21:57.000
だから私はイニシャライザに行き、今それを配線します。

00:21:57.000 --> 00:22:02.000
BADownloadManagerはシステムスケジューラに直接接続するので、シングルトンオブジェクトです。

00:22:02.000 --> 00:22:09.000
このデリゲートをダウンロードマネージャーに添付すると、アプリが現在実行されている場合、アプリは拡張機能を介してメッセージを受信します。

00:22:09.000 --> 00:22:15.000
では、実装する必要がある機能に戻りましょう。

00:22:15.000 --> 00:22:20.000
このアプリには、実装するデリゲートプロトコルに3つの特定の機能があります。

00:22:20.000 --> 00:22:28.000
1つ目は進捗処理です。今すぐそれを実行しましょう。

00:22:28.000 --> 00:22:36.000
UIの進捗状況を盲目的に更新する前に、進捗状況メッセージを受信しているダウンロードが、マニフェストが現在追跡しているものであることを確認します。

00:22:36.000 --> 00:22:44.000
ダウンロードが追跡されている場合は、進捗状況をSwiftUIに直接送信するアプリ内のヘルパー機能であるupdateDownloadProgressを呼び出します。

00:22:44.000 --> 00:22:50.000
次に、ダウンロードが終了したときに何が起こるかを実装します。

00:22:50.000 --> 00:22:55.000
それはほぼ同じ方法で始まります。これは、予想されるダウンロードのみを処理していることを確認することです。

00:22:55.000 --> 00:23:04.000
次に、replaceItemAtは、バックグラウンドアセットが私たちに与えた一時的な場所から最終的な場所にオブジェクトを移動するために使用されます。

00:23:04.000 --> 00:23:10.000
デバイスのスペースが少なくなると、システムがファイルを追跡してパージするため、ここで移動操作を使用することが重要です。

00:23:10.000 --> 00:23:17.000
したがって、アプリがファイルが欠落しているかどうかを常にチェックし、必要に応じて再フェッチすることを確認する必要があります。

00:23:17.000 --> 00:23:25.000
ここで最後に起こることは、タスクがMainActorに対して生成され、状態がダウンロード済みとしてマークされ、アプリがセッションのサムネイルの取得を開始することです。

00:23:25.000 --> 00:23:28.000
さて、すべてのダウンロードが成功すると言いたいです。

00:23:28.000 --> 00:23:36.000
しかし、不幸な真実は、サーバーにそのリソースがなくなったからであろうと、ネットワークの問題があるからであろうと、失敗する可能性があるということです。

00:23:36.000 --> 00:23:44.000
バックグラウンドアセットは再試行し、ネットワーク接続の問題を待ちますが、特定の時点を過ぎると、ファイルが進行中ではないことを知っておく必要があります。

00:23:44.000 --> 00:23:50.000
もう一つ覚えておくべきことは、ネットワーク接続に問題がある場合、フォアグラウンドに昇格されたダウンロードはほぼ即座に失敗するということです。

00:23:50.000 --> 00:23:52.000
ダウンロードに失敗したとき、私たちのアプリがする必要があることはあまりありません。

00:23:52.000 --> 00:24:05.000
UIを表示したり、スケジュールを変更したりできますが、この例では、問題があったことをログに記録しましょう。

00:24:05.000 --> 00:24:14.000
デリゲートが完全に実装されたので、アプリを再起動して、どのように見えるか見てみましょう。

00:24:14.000 --> 00:24:19.000
まあ、驚くことではありませんが、それは同じように見えます、そしてそれは私たちがここで本当に見たかったものです。

00:24:19.000 --> 00:24:23.000
URLSessionの代わりにバックグラウンドアセットを追加するのはとても簡単です。

00:24:23.000 --> 00:24:28.000
次にお見せするのは、バックグラウンドダウンロードを処理するためのアプリ拡張機能を実装する方法です。

00:24:28.000 --> 00:24:38.000
このアプリ拡張機能を追加することは、アプリがインストールまたは更新される前にバックグラウンドアセットを活用してコンテンツを取得する方法であり、重要な資産をキューイングするためのサポートを提供します。

00:24:38.000 --> 00:24:43.000
本質的に、拡張機能は、アプリが実行されていない間にダウンロードをスケジュールする責任があります。

00:24:43.000 --> 00:24:46.000
見てみましょう。 

00:24:46.000 --> 00:24:52.000
ここでは、バックグラウンドアセットに関連する拡張機能内のメッセージを受信するバックグラウンドダウンロードハンドラです。

00:24:52.000 --> 00:25:00.000
拡張機能から、私が最初に行うことは、拡張機能の実行中にConsole.appから確認できるようにロガーを作成することです。

00:25:00.000 --> 00:25:07.000
次に、BADownloaderExtensionプロトコルの一部であるcontentForRequest関数を実装します。

00:25:07.000 --> 00:25:13.000
この拡張機能が最初に行うことは、拡張機能が起動される前に事前にダウンロードされたマニフェストを解析することです。

00:25:13.000 --> 00:25:20.000
ダウンロードされたマニフェストが何らかの形で無効な場合、拡張機能はダウンロードをキューに入れないように設定されます。

00:25:20.000 --> 00:25:25.000
拡張機能がマニフェストが有効であることを知ったら、アトミックにアプリグループに保存されます。

00:25:25.000 --> 00:25:32.000
これは、アプリと拡張機能がローカルでマニフェストの最新バージョンを持ち、後で参照できるようにすることです。

00:25:32.000 --> 00:25:37.000
この保存はアトミックで行われるため、withExclusiveControlを使用する必要はありません。

00:25:37.000 --> 00:25:43.000
その後、拡張機能は、拡張機能がスケジュールされるシステムに戻るダウンロードオブジェクトの可変セットを作成します。

00:25:43.000 --> 00:25:49.000
先に説明したように、必須ダウンロードはアプリのインストールまたはアプリのアップデート中にのみサポートされています。

00:25:49.000 --> 00:25:56.000
次に、リモートのすべてのセッションのマニフェストを反復します。これは、この文脈では、それらがダウンロードされていないことを意味します。

00:25:56.000 --> 00:26:01.000
その後、スケジュールする必要があるダウンロードごとにBAURLDownloadオブジェクトが作成されます。

00:26:01.000 --> 00:26:17.000
ダウンロードには、一意の識別子、URLRequest、ダウンロードを必須としてフェッチする必要があるかどうかの注釈、そのファイルサイズ、アセットがダウンロードされるアプリグループ、およびスケジューラが最初に開始するダウンロードを制御する相対的な優先順位が与えられます。

00:26:17.000 --> 00:26:25.000
覚えておくべき重要なことの1つは、必須としてマークされたダウンロードには正確なファイルサイズがなければならないということです。そうしないと、ダウンロードは失敗としてマークされます。

00:26:25.000 --> 00:26:31.000
これは、iOSのホーム画面、macOS Launchpad、App Storeでのスムーズな進行をサポートするためです。

00:26:31.000 --> 00:26:37.000
ダウンロードのキューイングをサポートしたので、成功したダウンロードの処理を見てみましょう。

00:26:37.000 --> 00:26:43.000
アプリが実行されていない場合、またはアプリにBADownloadManagerにデリゲートが割り当てられていない場合、拡張機能はダウンロードを処理します。

00:26:43.000 --> 00:26:50.000
ダウンロード完了ハンドラで最初に実装することは、非同期に排他的な制御を取得することです。

00:26:50.000 --> 00:26:56.000
排他的な制御の取得は非同期であるため、拡張子が私たちに販売した一時ファイルにしがみつく必要があります。

00:26:56.000 --> 00:27:03.000
ご覧のとおり、私はこの関数の範囲よりも長生きする一時的な場所にファイルを移動することで、これを達成しています。

00:27:03.000 --> 00:27:09.000
また、拡張機能がダウンロードする一時的なファイルが常にクリーンアップされるように、Swift deferを追加します。

00:27:09.000 --> 00:27:15.000
システムはファイルを削除しますが、自分で管理するのがベストプラクティスです。

00:27:15.000 --> 00:27:19.000
次に、アプリグループからマニフェストをロードし、その有効性を確認します。

00:27:19.000 --> 00:27:27.000
その後、拡張機能は、処理されているダウンロードされた識別子がマニフェストで期待されるセッションと一致していることを確認します。

00:27:27.000 --> 00:27:34.000
その後、拡張子はそのファイルを一時的な場所からアプリグループ内の最終目的地に移動します。

00:27:34.000 --> 00:27:41.000
その後、LocalSessionは、セッションが適切な場所にダウンロードされたことをすばやく検証するために構築されます。

00:27:41.000 --> 00:27:46.000
最後に処理するのは、ダウンロードの失敗です。

00:27:46.000 --> 00:27:53.000
一般的に忘れられている重要なことは、BAManifestURLがダウンロードに失敗した場合、拡張機能が実際にそれについて通知されることです。

00:27:53.000 --> 00:27:55.000
そのタイプはBAURLDownloadを継承しています。

00:27:55.000 --> 00:27:58.000
しかし、それは正確な内部タイプではありません。

00:27:58.000 --> 00:28:04.000
したがって、拡張機能は、BAURLDownloadオブジェクトのみを扱うようにフィルタリングします。

00:28:04.000 --> 00:28:12.000
重要な資産はフォアグラウンドでダウンロードされるため、これらのダウンロードはアプリのインストールの進行状況に影響を与えるため、ネットワーク接続を数秒待つだけです。

00:28:12.000 --> 00:28:19.000
したがって、失敗した場合は、必須のダウンロードを必須ではないものとして再エンキューに入れることをお勧めします。

00:28:19.000 --> 00:28:25.000
必須ダウンロードを簡単に非必須に変換できる方法の1つは、新しいremoverEssential（）関数を使用することです。

00:28:25.000 --> 00:28:28.000
その関数は不要なコピーを返します。

00:28:28.000 --> 00:28:32.000
次に、そのコピーをBADownloadManagerのscheduleDownload機能に配布します。

00:28:32.000 --> 00:28:35.000
その後、システムは適切なタイミングでダウンロードを取得します。

00:28:35.000 --> 00:28:45.000
私たちのアプリとその拡張機能は完全にバックグラウンドアセットを採用したので、特定のセッションが必須としてダウンロードされたことを示すUIを追加しましょう。

00:28:45.000 --> 00:28:52.000
重要なのは、アプリのインストールとアプリのアップデートが、アセットが完全にダウンロードされるまでアプリの起動を禁止することを意味することを忘れないでください。

00:28:52.000 --> 00:29:02.000
ただし、起動がブロックされているアプリは、App StoreまたはTestFlightからのインストール中にのみ発生するため、インジケーターが存在することは、これを目に見えて認識する良い方法です。

00:29:02.000 --> 00:29:08.000
このインジケーターは、VideoSelectorビュー内のSwiftUIに実装されます。

00:29:08.000 --> 00:29:13.000
セッションがマニフェストで必須としてマークされている場合、ナビゲーションビューに緑色の円が描画されます。

00:29:13.000 --> 00:29:16.000
そして、それがすべてです。

00:29:16.000 --> 00:29:23.000
バックグラウンドアセットの実装がいかに簡単かがわかったので、拡張機能のデバッグとそのエントリポイントのシミュレーションを見てみましょう。

00:29:23.000 --> 00:29:29.000
先に説明したように、拡張機能はアプリのインストール中、アプリのアップデート中、または定期的にバックグラウンドで起動します。

00:29:29.000 --> 00:29:38.000
アプリのインストールはApp Storeによって制御され、定期的なイベントはデバイスによって制御されるため、デバッグするために拡張機能を強制的に起動する方法が必要になります。

00:29:38.000 --> 00:29:46.000
幸いなことに、私たちのチームはXcodeに同梱されているツールを作成しました。これは、拡張機能を起動し、そのエントリポイントをシミュレートするために使用できます。

00:29:46.000 --> 00:29:52.000
このツールはターミナルからアクセスでき、xcrun backgroundassets-debugと入力することで起動できます。

00:29:52.000 --> 00:29:56.000
ヘルプ情報とそれに付随するマニュアルページもあります。

00:29:56.000 --> 00:30:03.000
backgroundassets-debugを使用する場合は、さまざまな種類のBAContentRequestsをトリガーする機能を提供するシミュレーション引数を渡します。

00:30:03.000 --> 00:30:11.000
これらのシミュレーションメッセージのいずれかがデバイスに送信されると、拡張機能のランタイムがリセットされ、デバッグが容易になります。

00:30:11.000 --> 00:30:16.000
Backgroundassets-debugは、複数のデバイスのサポートなど、多数の機能を提供します。

00:30:16.000 --> 00:30:21.000
デバイスがMacとペアリングされている限り、拡張機能をシミュレートするために使用できます。

00:30:21.000 --> 00:30:28.000
これらのコマンドは、デバイスをUSB経由でMacにテザリングする必要がないように、BluetoothまたはWi-Fi経由で送信できます。

00:30:28.000 --> 00:30:35.000
最後に、デバイスがbackgroundassets-debugによってトリガーされたシミュレーションイベントを尊重するには、開発者モードをオンにする必要があります。

00:30:35.000 --> 00:30:41.000
これは、デバイスの設定アプリ内のプライバシーとセキュリティセクションから簡単に有効にすることができます。

00:30:41.000 --> 00:30:47.000
それでは、先ほど構築したデモアプリでbackgroundassets-debugツールを使用することを見てみましょう。

00:30:47.000 --> 00:30:49.000
私たちはターミナルにいます。

00:30:49.000 --> 00:30:53.000
XcodeはこのMacにインストールされているので、先に進んで接続されたデバイスをリストアップします。

00:30:53.000 --> 00:30:58.000
現在、接続されているデバイスが1つしかなく、それはたまたま私のiPhoneであることがわかります。

00:30:58.000 --> 00:31:03.000
シミュレートすることを選択したデバイスのUUIDをコピーしたいと思うでしょう。

00:31:03.000 --> 00:31:09.000
提供された引数では、デバイスのUUIDがアプリのバンドル識別子とともに存在していることがわかります。

00:31:09.000 --> 00:31:13.000
App-install引数と混在したシミュレーション引数を使用してツールを呼び出します。

00:31:13.000 --> 00:31:19.000
これにより、アプリ拡張機能は、最初のアプリインストールイベント中に起動されているかのように起動します。

00:31:19.000 --> 00:31:24.000
Enterキーを押したので、ツールはアプリのインストールイベントがデバイスに送信されたことを通知します。

00:31:24.000 --> 00:31:30.000
アプリを起動して、それがどのように見えるか見てみましょう。

00:31:30.000 --> 00:31:33.000
ご覧のとおり、すべてのセッションビデオはダウンロードのためにキューにされています。

00:31:33.000 --> 00:31:36.000
私が話しているように、それらのいくつかはすでにダウンロードを終えています。

00:31:36.000 --> 00:31:39.000
そして、それは行動中のバックグラウンド資産です。

00:31:39.000 --> 00:31:45.000
あなたが私のような人なら、あなたはおそらくすでにあなたのアプリでの待ち時間を減らすための多くの潜在的な方法について考え始めているでしょう。

00:31:45.000 --> 00:31:51.000
アプリ拡張機能をデバッグする方法をお見せしたので、覚えておくべき重要なことをいくつか見てみましょう。

00:31:51.000 --> 00:31:56.000
エッセンシャルアセットはアプリでダウンロードし、アプリのインストールの進行に貢献します。

00:31:56.000 --> 00:32:04.000
したがって、これらのタイプのアセットは、拡張機能内のBAContentRequestインストールまたは更新イベント中にのみスケジュール可能です。

00:32:04.000 --> 00:32:10.000
拡張機能によってキューにされた必須ダウンロードが失敗した場合、アプリは最終的に起動可能になります。

00:32:10.000 --> 00:32:18.000
これらの資産が必要な場合は、拡張機能内または最初のアプリの起動時に、必須ダウンロードを必須ではないものとして再キューに入れる必要があります。

00:32:18.000 --> 00:32:26.000
必須としてマークされていないダウンロードは、アプリがインストールまたは更新された後にダウンロードされ、バックグラウンドダウンロードの優先順位を受け取ります。

00:32:26.000 --> 00:32:30.000
また、拡張機能はメモリ使用量によって制限されていることを覚えておくことも重要です。

00:32:30.000 --> 00:32:35.000
したがって、拡張機能をデバッグして、書き込むコードがメモリのしきい値をはるかに下回っていることを確認してください。

00:32:35.000 --> 00:32:41.000
拡張機能が過剰なメモリを使用している場合、デバッグ中にメモリ例外でクラッシュすることに気づくでしょう。

00:32:41.000 --> 00:32:49.000
アプリのインストールまたはアプリの更新コンテンツリクエスト中に拡張機能がクラッシュした場合、アプリはすぐに起動可能になります。

00:32:49.000 --> 00:32:54.000
そして最後に、ダウンロードしたアセットを適切に管理することで、アプリを善良な市民にすることを忘れないでください。

00:32:54.000 --> 00:32:59.000
これらの資産を管理する1つの方法は、アプリのキャッシュディレクトリに配置することです。

00:32:59.000 --> 00:33:01.000
だから、それが私たちがバックグラウンドアセットのために今年持っているものです。

00:33:01.000 --> 00:33:06.000
このセッションから取り除くべきものがあれば、それはあなたのアプリでの待ち時間を排除することです。

00:33:06.000 --> 00:33:12.000
待ち時間を排除する1つの方法は、バックグラウンドアセットを採用し、新しい必須アセット機能を使用することです。

00:33:12.000 --> 00:33:16.000
アプリをApp Storeに提出する前に、必ずTestFlightを利用してください。

00:33:16.000 --> 00:33:22.000
TestFlightを使用すると、重要なアセットがアプリでダウンロードされたときにどのように見えるかを確認できます。

00:33:22.000 --> 00:33:29.000
ご質問がある場合は、開発者ドキュメントをチェックして、Apple Developer Forumsにお気軽にお問い合わせください。

00:33:29.000 --> 00:33:32.000
また、フィードバックアシスタントを利用することをお勧めします。

00:33:32.000 --> 00:33:38.000
私たちのチームはバックグラウンドアセットを常に改善しており、あなたがそれをアプリに採用することを楽しみにしています。

00:33:38.000 --> 00:33:44.000
ああ、まだしていない場合は、バックグラウンドアセットが導入された以前のセッションをチェックすることをお勧めします。

00:33:44.000 --> 00:33:47.000
そこにはたくさんの追加情報があります。

00:33:47.000 --> 00:33:49.000
そして、今日は参加してくれてありがとう。

00:33:49.000 --> 23:59:59.000
アップルのみんなを代表して、見てくれてありがとう。

