WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:14.000
ベン：こんにちは、「Swift 5.9の新機能」へようこそ。

00:00:14.000 --> 00:00:19.000
私はベンです。同僚のダグと一緒に、今年はスウィフト言語の改善点をいくつかお連れします。

00:00:19.000 --> 00:00:40.000
Swiftのクリーンな構文を使用して意味をより簡単に表現できるいくつかの方法、フレームワーク作成者が新しいAPIをより自然に使用できるようにするための強力な新機能、および低レベルのコードでパフォーマンスと安全性をより詳細に制御するためのいくつかの新しい方法について説明します。

00:00:40.000 --> 00:00:44.000
しかし、Swiftオープンソースプロジェクトについて話すことから始めましょう。

00:00:44.000 --> 00:00:59.000
これはSwiftにとって素晴らしいアップデートであり、Swiftコミュニティ、swift.orgに集まる言語の貢献者とユーザーが言語を進化させ、新しいイニシアチブをサポートするために協力していなければ実現できませんでした。

00:00:59.000 --> 00:01:02.000
スウィフトは、言語進化のためのオープンなプロセスに従います。

00:01:02.000 --> 00:01:09.000
新機能や重要な行動の変化は、Swiftフォーラムのオープンで提案され、レビューされます。

00:01:09.000 --> 00:01:16.000
フォローしたい場合は、Swiftのウェブサイトですべての言語提案のダッシュボードを見つけることができます。

00:01:16.000 --> 00:01:20.000
1年前、私たちはスウィフトプロジェクトのガバナンスの大幅な再編を見ました。

00:01:20.000 --> 00:01:30.000
コアチームは、Swift言語と標準ライブラリの進化を監督する主な責任を負った言語運営グループの設立を発表しました。

00:01:30.000 --> 00:01:38.000
それ以来、言語グループは40の新しい言語提案を監督しており、今日はそのうちのいくつかについて話します。

00:01:38.000 --> 00:01:50.000
しかし、時には、個々の言語の提案は、10の別々の提案を通じて導入されたSwift並行性の追加など、より広いテーマの一部としてまとめられています。

00:01:50.000 --> 00:01:57.000
このような場合、言語運営グループは、ビジョン文書を通じて、これらの提案を結びつける新しい方法を導入しました。

00:01:57.000 --> 00:02:02.000
これらの文書は、言語のより大きな変更のための提案を示しています。

00:02:02.000 --> 00:02:13.000
言語運営グループに最初に受け入れられたのは、この講演の後半で取り上げるSwift 5.9の新機能であるSwiftマクロのビジョンでした。

00:02:13.000 --> 00:02:17.000
もちろん、言語の進化はスウィフトコミュニティの仕事の一部にすぎません。

00:02:17.000 --> 00:02:20.000
成功した言語には、これよりもはるかに多くのものが必要です。

00:02:20.000 --> 00:02:27.000
優れたツール、複数のプラットフォームに対する堅牢なサポート、豊富なドキュメントが必要です。

00:02:27.000 --> 00:02:35.000
この分野の進捗状況を監督するために、コアチームは言語ステアリンググループと並行してエコシステムステアリンググループを作成しています。

00:02:35.000 --> 00:02:44.000
この新しい構造は、最近、Swift.orgのブログ記事でレイアウトされました。この新しいグループの形成に関するさらなる発表については、すぐに探してください。

00:02:44.000 --> 00:02:52.000
それでは、コードで自分を表現するより良い方法から始めて、今年のSwift言語の変更について話しましょう。

00:02:52.000 --> 00:03:07.000
Swift 5.9には、おそらく最も一般的に要求される言語強化が含まれており、if/elseとswitchステートメントを式として使用でき、コードをクリーンアップする良い方法を提供します。

00:03:07.000 --> 00:03:19.000
たとえば、いくつかの複雑な条件に基づいてlet変数を初期化したい場合は、この読みにくい複合三項式のようなトリックに頼る必要がありました。

00:03:19.000 --> 00:03:27.000
If式では、代わりに、より身近で読みやすいifステートメントのチェーンを使用できます。

00:03:27.000 --> 00:03:33.000
これが役立つもう1つの場所は、グローバル変数またはストアドプロパティを初期化する場合です。

00:03:33.000 --> 00:03:43.000
単一の式はここではうまく機能しますが、条件が欲しい場合は、すぐに実行したクロージャでそれをラップするトリックを使用する必要がありました。

00:03:43.000 --> 00:03:51.000
Ifステートメントが式になることができるようになったので、その混乱を落とすだけで、よりきちんとしたコードを残すことができます。

00:03:51.000 --> 00:04:06.000
SwiftUIのような機能を推進する宣言型構文である結果ビルダーは、今年、最適化された型チェックのパフォーマンス、コード補完、エラーメッセージの改善など、大幅な改善が見られました。

00:04:06.000 --> 00:04:11.000
この改善は、特に無効なコードに焦点を当てていました。

00:04:11.000 --> 00:04:21.000
以前は、タイプチェッカーが多くの可能な無効なパスを調査したため、エラーのある結果ビルダーコードは失敗するのに長い時間がかかりました。

00:04:21.000 --> 00:04:31.000
Swift 5.8以降、無効なコードタイプのチェックがはるかに速くなり、無効なコードのエラーメッセージがより正確になりました。

00:04:31.000 --> 00:04:39.000
たとえば、以前は、一部の無効なコードは、結果ビルダーのまったく異なる部分で誤解を招くエラーにつながる可能性があります。

00:04:39.000 --> 00:04:46.000
Swift 5.7では、間違いが実際にここにあるとき、このようなエラーが表示されます。

00:04:46.000 --> 00:04:53.000
最新のリリースでは、実際の問題を特定するより正確なコンパイラ診断を受け取ります。

00:04:53.000 --> 00:05:02.000
次に、ジェネリックシステムへの追加により、毎日使用するフレームワークがどのように大幅に改善されるかについて話しましょう。

00:05:02.000 --> 00:05:06.000
あなたが書くほとんどすべてのSwiftは、何らかの形でジェネリックを使用しています。

00:05:06.000 --> 00:05:13.000
型推論を使用すると、構築された高度な機能を理解することなく、これらの型を使用できます。

00:05:13.000 --> 00:05:22.000
たとえば、標準ライブラリ配列タイプは、ジェネリックを使用して、保存したい任意のタイプのデータで動作する配列を提供します。

00:05:22.000 --> 00:05:27.000
配列を使用する場合、必要なのは要素を提供することだけです。

00:05:27.000 --> 00:05:36.000
要素値から推測できるため、要素タイプの明示的な引数を指定する必要はありません。

00:05:36.000 --> 00:05:47.000
Swiftのジェネリックシステムは、あなたが提供する具体的なタイプでコードがシームレスに動作するように、タイプ情報を保持する自然なAPIを可能にします。

00:05:47.000 --> 00:05:57.000
Swiftコンパイラ独自のコードベースに触発された例を次に示します。リクエストタイプを取り、それを評価して強く型付けされた値を生成するAPIです。

00:05:57.000 --> 00:06:03.000
したがって、ブール値を要求し、ブール値の結果を取り戻すことができます。

00:06:03.000 --> 00:06:12.000
現在、一部のAPIは、具体的なタイプだけでなく、渡す引数の数も抽象化したいと考えています。

00:06:12.000 --> 00:06:22.000
したがって、関数は1つの要求を取り、1つの結果または2つの要求を返し、2つの結果を返すか、3つの結果を返すか、3つの結果を返す可能性があります。

00:06:22.000 --> 00:06:34.000
これをサポートするには、ジェネリックシステムは、渡したすべてのタイプが取得したタイプにリンクされるように、複数の引数の長さを処理するメカニズムと一緒に使用する必要があります。

00:06:34.000 --> 00:06:44.000
Swift 5.9以前は、このパターンを達成する唯一の方法は、APIがサポートする特定の引数の長さごとにオーバーロードを追加することでした。

00:06:44.000 --> 00:06:47.000
しかし、このアプローチには限界があります。

00:06:47.000 --> 00:06:56.000
渡すことができる引数の数に人為的な上限を強制し、合格が多すぎるとコンパイラエラーが発生します。

00:06:56.000 --> 00:07:02.000
この場合、6つ以上の引数を処理できるオーバーロードはありませんが、7つに合格しました。

00:07:02.000 --> 00:07:12.000
このオーバーロードパターンとその制限は、概念的に任意の引数の長さを処理するAPI全体に浸透しています。

00:07:12.000 --> 00:07:23.000
Swift 5.9では、ジェネリックシステムは、引数の長さに対するジェネリック抽象化を有効にすることで、このAPIパターンのファーストクラスのサポートを得ています。

00:07:23.000 --> 00:07:30.000
これは、一緒に「パック」されている複数の個々のタイプパラメータを表すことができる新しい言語概念で行われます。

00:07:30.000 --> 00:07:35.000
この新しい概念は、型パラメータパックと呼ばれます。

00:07:35.000 --> 00:07:49.000
パラメータパックを使用すると、現在固定引数長ごとに個別のオーバーロードを持つAPIを1つの関数に折りたたむことができます。

00:07:49.000 --> 00:08:03.000
単一の要求の結果タイプを表す単一の型パラメータResultを受け入れる代わりに、評価関数は各結果タイプに対して個別の要求を受け入れるようになりました。

00:08:03.000 --> 00:08:13.000
この関数は、括弧内の各結果インスタンスを返します。これは、単一の値または各値を含むタプルのいずれかになります。

00:08:13.000 --> 00:08:21.000
評価関数は、人工的な制限なしですべての引数の長さを処理するようになりました。

00:08:21.000 --> 00:08:31.000
型推論は、APIがそれらを使用していることを知ることなく、パラメータパックを使用するAPIを自然に使用できるようにします。

00:08:31.000 --> 00:08:39.000
任意の数の引数を処理できる新しい評価関数を呼び出すことは、固定長のオーバーロードを呼び出すのと似ています。

00:08:39.000 --> 00:08:47.000
Swiftは、関数の呼び出し方法に基づいて、各引数のタイプと総数を推測します。

00:08:47.000 --> 00:08:55.000
このような汎用ライブラリAPIの書き方については、パラメータパックを使用してAPIを一般化してください。

00:08:55.000 --> 00:09:06.000
一般的なAPIを自然な方法で呼び出すことは、Swiftの基本的な設計目標の1つであり、簡潔なコードによる明確な表現を示しています。

00:09:06.000 --> 00:09:14.000
Swiftの高度な言語機能は、あなたの言いたいことをより簡単に言うことができる美しいAPIを可能にします。

00:09:14.000 --> 00:09:26.000
配列や辞書を介してジェネリックを使用するか、SwiftUIでUIを設計するかどうかにかかわらず、これまでに書いたSwiftの最初の行からこれらの高度な言語機能の恩恵を受けることができます。

00:09:26.000 --> 00:09:35.000
スウィフトの漸進的な開示の受け入れは、準備ができたら、より高度な機能について学ぶことができることを意味します。

00:09:35.000 --> 00:09:47.000
Swift 5.9は、新しいマクロシステムを使用して、ライブラリ作成者に表現力豊かなAPI設計のための新しいツールボックスを提供することで、このデザインアプローチを次のレベルに引き上げます。

00:09:47.000 --> 00:09:50.000
ダグがあなたにもっと話します。

00:09:50.000 --> 00:09:59.000
ダグ：マクロを使用すると、言語自体の機能を拡張し、定型文を排除し、Swiftの表現力をさらに解き放つことができます。

00:09:59.000 --> 00:10:05.000
条件が真であるかどうかをチェックする常に存在するアサート関数を考えてみましょう。

00:10:05.000 --> 00:10:14.000
条件が偽の場合、アサートはプログラムを停止しますが、それが起こると、何がうまくいかなかったのかについての情報はほとんど得られません。ファイルと行番号だけです。

00:10:14.000 --> 00:10:18.000
詳細については、ロギングを追加するか、デバッガにプログラムをトラップする必要があります。

00:10:18.000 --> 00:10:21.000
これを改善する試みがありました。

00:10:21.000 --> 00:10:29.000
XCTestは、2つの値を別々に取るアサート等しい操作を提供するので、物事が失敗した場合、少なくとも等しくない2つの値を見ることができます。

00:10:29.000 --> 00:10:32.000
しかし、ここでどの価値が間違っているのかはまだわかりません。

00:10:32.000 --> 00:10:35.000
それはa、b、それともマックスの結果でしたか?

00:10:35.000 --> 00:10:40.000
そして、このアプローチは、アサートで実行するあらゆる種類のチェックに対して本当に拡張されません。

00:10:40.000 --> 00:10:48.000
元のアサーションに戻ると、ソースコードには非常に多くの情報があり、アサーションが失敗したときにログで見たいです。

00:10:48.000 --> 00:10:50.000
コードは何でしたか?

00:10:50.000 --> 00:10:53.000
A、b、cの値は何ですか?

00:10:53.000 --> 00:10:55.000
マックスは何を生産しましたか?

00:10:55.000 --> 00:11:02.000
以前はカスタム機能がなければ、Swiftでこれを改善できませんでしたが、マクロはそれを可能にします。

00:11:02.000 --> 00:11:08.000
この例では、「hash-assert」構文は「assert」と呼ばれるマクロを拡張しています。

00:11:08.000 --> 00:11:17.000
ハッシュ構文は、Swiftがすでにハッシュファイル、ハッシュセレクタ、ハッシュ警告など、この同じスペルを持ついくつかのものを持っているので、見覚えがあるかもしれません。

00:11:17.000 --> 00:11:27.000
アサートマクロは関数バージョンのように見えますが、マクロであるため、アサーションが失敗したときにより豊かな体験を提供できます。

00:11:27.000 --> 00:11:35.000
現在、プログラムは、結果に貢献した各値とともに、失敗したアサーションのコードを表示しています。

00:11:35.000 --> 00:11:44.000
Swiftでは、マクロは型や関数と同じようにAPIであるため、それらを定義するモジュールをインポートしてアクセスできます。

00:11:44.000 --> 00:11:49.000
他の多くのAPIと同様に、マクロはパッケージとして配布されます。

00:11:49.000 --> 00:11:58.000
ここでのアサートマクロは、GitHubで利用可能なオープンソースのSwiftパッケージであるpower assertsライブラリから来ています。

00:11:58.000 --> 00:12:04.000
マクロパッケージを調べると、アサートのマクロ宣言が見つかります。

00:12:04.000 --> 00:12:10.000
「マクロ」キーワードで導入されますが、それ以外は関数によく似ています。

00:12:10.000 --> 00:12:14.000
チェックする条件には、ラベルのないブールパラメータが1つあります。

00:12:14.000 --> 00:12:21.000
このマクロが値を生成した場合、その結果型は通常の矢印構文で書かれます。

00:12:21.000 --> 00:12:25.000
マクロの使用は、パラメータに対してタイプチェックされます。

00:12:25.000 --> 00:12:39.000
つまり、最大値を何かと比較するのを忘れるなど、マクロの使用を間違えた場合、マクロが展開される前に、すぐに有用なエラーメッセージが表示されます。

00:12:39.000 --> 00:12:51.000
これにより、マクロは適切に型付けされた入力で動作し、予測可能な方法でプログラムを拡張するコードを生成するため、Swiftはマクロを使用する際に優れた開発体験を提供することができます。

00:12:51.000 --> 00:13:01.000
ほとんどのマクロは「外部マクロ」として定義され、文字列を介してマクロ実装のモジュールとタイプを指定します。

00:13:01.000 --> 00:13:08.000
外部マクロタイプは、コンパイラプラグインとして機能する別々のプログラムで定義されています。

00:13:08.000 --> 00:13:13.000
Swiftコンパイラは、マクロを使用するためのソースコードをプラグインに渡します。

00:13:13.000 --> 00:13:19.000
プラグインは新しいソースコードを生成し、それがSwiftプログラムに統合されます。

00:13:19.000 --> 00:13:27.000
ここでは、マクロはアサーションを個々の値をキャプチャし、ソースコードのどこに表示すべきかに拡張しています。

00:13:27.000 --> 00:13:32.000
あなたは自分でボイラープレートを書きたくないでしょうが、マクロはあなたのためにそれを行います。

00:13:32.000 --> 00:13:37.000
マクロ宣言には、その役割という1つの追加情報があります。

00:13:37.000 --> 00:13:41.000
ここでのアサートマクロは、独立した式マクロです。

00:13:41.000 --> 00:13:48.000
「ハッシュ」構文を使用し、その構文で直接動作して新しいコードを生成するため、フリースタンディングと呼ばれています。

00:13:48.000 --> 00:13:53.000
これは、値を生成することができる場所ならどこでも使用できるため、式マクロです。

00:13:53.000 --> 00:13:59.000
新しいFoundation Predicate APIは、式マクロの素晴らしい例を提供します。

00:13:59.000 --> 00:14:04.000
述語マクロを使用すると、クロージャを使用して型安全な方法で述語を書くことができます。

00:14:04.000 --> 00:14:14.000
結果の述語値は、Swiftコレクション操作SwiftUIやSwiftDataなど、他の多くのAPIで使用できます。

00:14:14.000 --> 00:14:19.000
マクロ自体は、入力タイプのセットに対して一般的です。

00:14:19.000 --> 00:14:29.000
これらの入力型の値で動作する関数であるクロージャ引数を受け入れ、ブール結果を生成しますが、入力のセットは一致しますか？

00:14:29.000 --> 00:14:36.000
そして、マクロは、プログラムの他の場所で使用できる新しい述語型のインスタンスを返します。

00:14:36.000 --> 00:14:46.000
しかし、マクロにはもっと多くのものがあります。なぜなら、私たちが最終的に書くことになる定型文の多くは、そこから派生した他のもので書いたコードを拡張する必要があるからです。

00:14:46.000 --> 00:14:47.000
例を挙げてみましょう。

00:14:47.000 --> 00:14:55.000
相対パスまたは絶対パスをキャプチャするこのパス列挙型のように、自分のコードで列挙型を頻繁に使用していることがわかります。

00:14:55.000 --> 00:15:02.000
しかし、コレクションからすべての絶対パスをフィルタリングすることで、特定のケースを確認する必要があることがよくあります。

00:15:02.000 --> 00:15:06.000
もちろん、このisAbsoluteチェックを計算されたプロパティとして書くことができます。

00:15:06.000 --> 00:15:10.000
しかし、遅かれ早かれ、私は別のものを書かなければならないでしょう。

00:15:10.000 --> 00:15:14.000
これは少し退屈になってきています。

00:15:14.000 --> 00:15:19.000
マクロは、私たちのためにボイラープレートを生成することによって、ここで助けることができます。

00:15:19.000 --> 00:15:26.000
ケース検出は、プロパティラッパーと同じカスタム属性構文を使用して書かれた添付マクロです。

00:15:26.000 --> 00:15:38.000
添付されたマクロは、適用される宣言の構文を入力として取り、ここでは列挙型宣言自体であり、新しいコードを生成します。

00:15:38.000 --> 00:15:44.000
このマクロ拡張コードは、コンパイラがプログラムに統合する通常のSwiftコードです。

00:15:44.000 --> 00:15:53.000
エディタでマクロで生成されたコードを検査したり、デバッグしたり、さらにカスタマイズしたい場合はコピーしたりできます。

00:15:53.000 --> 00:16:01.000
添付されたマクロは、添付されている宣言をどのように増強するかに基づいて、5つの異なる役割に分類されます。

00:16:01.000 --> 00:16:11.000
先ほど説明したケース検出マクロは、「メンバー」アタッチマクロです。つまり、タイプまたは拡張で新しいメンバーを作成します。

00:16:11.000 --> 00:16:23.000
ピアマクロは、アシンクロメソッドの完了ハンドラーバージョンを作成するなど、添付されている宣言と一緒に新しい宣言を追加します。

00:16:23.000 --> 00:16:38.000
アクセサマクロは、保存されたプロパティを計算されたプロパティに変換し、プロパティアクセスに関する特定のアクションを実行したり、プロパティラッパーと同様の方法で実際のストレージを抽象化したりするために使用できますが、プロパティラッパーよりも柔軟です。

00:16:38.000 --> 00:16:47.000
また、添付されたマクロは、タイプの特定のメンバーに属性を導入したり、新しいプロトコルの適合性を追加したりできます。

00:16:47.000 --> 00:16:52.000
有用な効果を達成するために、いくつかの添付されたマクロロールを一緒に構成することができます。

00:16:52.000 --> 00:16:57.000
これの重要な例の1つは観察です。

00:16:57.000 --> 00:17:00.000
観察は常にSwiftUIの一部でした。

00:17:00.000 --> 00:17:16.000
クラスのプロパティの変更を観察できるようにするには、タイプをObservableObjectに準拠させ、すべてのプロパティを[公開済み]にマークし、ビューで ObservedObjectプロパティラッパーを使用するだけです。

00:17:16.000 --> 00:17:22.000
それはたくさんのステップであり、ステップを欠落とすると、UIが期待どおりに更新されない可能性があります。

00:17:22.000 --> 00:17:27.000
マクロベースの観察でもっとうまくやれる。

00:17:27.000 --> 00:17:33.000
Observableマクロをクラスにアタッチすると、その保存されたすべてのプロパティのオブザベーションが提供されます。

00:17:33.000 --> 00:17:42.000
保存された各プロパティに注釈を付けたり、Observableマクロがすべてを処理するため、そうでない場合に何が起こるかを心配する必要はありません。

00:17:42.000 --> 00:17:48.000
観測可能なマクロは、3つのマクロロールの構成を通じて機能します。

00:17:48.000 --> 00:17:52.000
これらの役割がどのように連携するかを掘り下げてみましょう。

00:17:52.000 --> 00:18:00.000
各マクロロールは、PersonクラスがObservableマクロによって拡張される特定の方法に対応します。

00:18:00.000 --> 00:18:05.000
メンバーの役割は、新しいプロパティとメソッドを導入します。

00:18:05.000 --> 00:18:18.000
メンバー属性ロールは、観測されたクラスの保存されたプロパティに@ObservationTrackedマクロを追加し、ゲッターとセッターに拡張して観測イベントをトリガーします。

00:18:18.000 --> 00:18:25.000
最後に、適合性の役割は、Observableプロトコルへの適合性を導入します。

00:18:25.000 --> 00:18:34.000
これは多くのコードのように見えるかもしれませんが、それはすべて通常のSwiftコードであり、Observableマクロの後ろにきれいに折り畳まれています。

00:18:34.000 --> 00:18:45.000
プログラムへの影響をよりよく理解するためにマクロがどのように展開するかを確認する必要があるときはいつでも、Xcodeの指先にあります。

00:18:45.000 --> 00:18:51.000
「マクロを展開」アクションを使用して、エディタでマクロ展開されたソースコードを確認します。

00:18:51.000 --> 00:19:00.000
マクロで生成されたコード内のエラーメッセージは自動的に展開されたコードを表示し、デバッガでそれに出入りすることができます。

00:19:00.000 --> 00:19:11.000
Swiftマクロは、より表現力豊かなAPIを可能にし、Swiftコードから定型文を排除するための新しいツールを提供し、Swiftの表現力を引き出すのに役立ちます。

00:19:11.000 --> 00:19:20.000
マクロは入力をタイプチェックし、通常のSwiftコードを生成し、プログラムの定義されたポイントで統合するので、その効果は簡単に推論できます。

00:19:20.000 --> 00:19:27.000
そして、マクロが何をしたかを理解する必要があるときはいつでも、その拡張されたソースコードはエディタにあります。

00:19:27.000 --> 00:19:30.000
マクロの表面を引っ掻いたところです。

00:19:30.000 --> 00:19:37.000
「Expand on Swiftマクロ」は、あなたが持っている必要があるすべての質問に答えるために、Swiftマクロの設計を深く掘り下げます。

00:19:37.000 --> 00:19:42.000
また、「Write Swiftマクロ」を使用して、独自のマクロを実際に実装できます。

00:19:42.000 --> 00:19:46.000
Swiftコミュニティがどのような新しいマクロを構築するかを見るのが待ちきれません。

00:19:46.000 --> 00:19:52.000
ベン：最初から、Swiftはスケーラブルな言語になるように設計されていました。

00:19:52.000 --> 00:20:02.000
スウィフトのデザインは、儀式が少なく、読み書きが簡単な明確で簡潔なコードで表現力を強調しています。

00:20:02.000 --> 00:20:17.000
ジェネリックやネイティブ並行性サポートなどのSwiftの強力な機能を活用することで、SwiftUIやSwiftDataなどのフレームワークにより、必要な結果をすばやく達成でき、重要なことに集中する時間を増やすことができます。

00:20:17.000 --> 00:20:23.000
しかし、これらの高レベルの機能にもかかわらず、Swiftも効率的です。

00:20:23.000 --> 00:20:34.000
ネイティブにコンパイルされ、ガベージコレクションの代わりに値タイプと参照カウントを使用することで、低いメモリフットプリントを達成できることを意味します。

00:20:34.000 --> 00:20:49.000
このスケーラビリティは、SwiftをObjective-Cで以前よりも多くの場所に、以前はCまたはC ++を使用する必要があると予想されていた低レベルのシステムにプッシュできることを意味します。

00:20:49.000 --> 00:20:56.000
これは、Swiftのより明確なコードと重要な安全保証をより多くの場所にもたらすことを意味します。

00:20:56.000 --> 00:21:02.000
私たちは最近、SwiftでFoundationフレームワークの書き換えの開始をオープンソース化しました。

00:21:02.000 --> 00:21:10.000
このイニシアチブは、AppleプラットフォームとApple以外のプラットフォームの両方でFoundationの単一の共有実装につながります。

00:21:10.000 --> 00:21:16.000
しかし、それはまた、Swiftで大量のObjective-CとCコードを書き換えることを意味しました。

00:21:16.000 --> 00:21:35.000
MacOS SonomaとiOS 17では、日付やカレンダーなどの必須タイプの新しいSwiftバックアップ実装、ロケールやAttributedStringなどの書式設定と国際化の必須要素、JSONエンコーディングとデコードの新しいSwift実装があります。

00:21:35.000 --> 00:21:39.000
そして、パフォーマンスの勝利は重要でした。

00:21:39.000 --> 00:21:53.000
重要な日付を計算するカレンダーの能力は、Swiftの値セマンティクスをよりよく活用して中間割り当てを回避し、一部のベンチマークで20%以上の改善をもたらします。

00:21:53.000 --> 00:22:05.000
FormatStyleを使用した日付書式設定も大幅に改善され、標準的な日付と時刻のテンプレートを使用した書式設定のベンチマークが大幅に150%向上しました。

00:22:05.000 --> 00:22:11.000
さらにエキサイティングなのは、新しいパッケージでのJSONデコードの改善です。

00:22:11.000 --> 00:22:21.000
Foundationには、JSONDecoderとJSONEncoder用のまったく新しいSwift実装があり、Objective-Cコレクションタイプとの間のコストのかかるラウンドトリップを排除します。

00:22:21.000 --> 00:22:29.000
Codable型を初期化するためのSwiftでのJSONの解析の緊密な統合により、パフォーマンスも向上します。

00:22:29.000 --> 00:22:36.000
テストデータを解析するベンチマークでは、新しい実装は2倍から5倍高速です。

00:22:36.000 --> 00:22:48.000
これらの改善は、古いObjective-C実装からSwiftへのブリッジングコストを削減するだけでなく、新しいSwiftベースの実装が高速になることによっても実現されました。

00:22:48.000 --> 00:22:51.000
例として1つのベンチマークを見てみましょう。

00:22:51.000 --> 00:22:59.000
ベンチュラでは、ブリッジングコストのため、Objective-CからenumerateDatesを呼び出すよりもわずかに速かった。

00:22:59.000 --> 00:23:05.000
MacOS Sonomaでは、Swiftから同じ機能を呼び出す方が20%高速です。

00:23:05.000 --> 00:23:16.000
そのスピードアップの一部は、ブリッジングコストを排除することから来ていますが、Objective-Cから呼び出すときに見られるように、新しい関数の実装自体も高速です。

00:23:16.000 --> 00:23:25.000
この特定の日付の計算は過度に複雑ではないので、これは2つの言語間のオーバーヘッドの減少を見るのに最適な方法です。

00:23:25.000 --> 00:23:35.000
さて、システムの下位レベルで動作している場合、必要なレベルのパフォーマンスを達成するために、よりきめ細かな制御が必要になることがあります。

00:23:35.000 --> 00:23:43.000
Swift 5.9では、このレベルのコントロールを達成するのに役立つ新しいオプトイン機能が導入されています。

00:23:43.000 --> 00:23:53.000
これらの機能は、所有権の概念、つまり、コードのどの部分がアプリケーションの周りを通過する際に値を「所有」するかに焦点を当てています。

00:23:53.000 --> 00:23:59.000
これらの機能をいつ使用したいかを確認するには、まずコードの例を見てみましょう。

00:23:59.000 --> 00:24:08.000
ここでは、低レベルのシステムコールにより素敵なSwiftインターフェイスを与えることを可能にするファイル記述子のための非常にシンプルなラッパーがあります。

00:24:08.000 --> 00:24:12.000
しかし、このAPIで間違いを犯す簡単な方法はまだいくつかあります。

00:24:12.000 --> 00:24:17.000
たとえば、closeを呼び出した後にファイルに書き込もうとします。

00:24:17.000 --> 00:24:24.000
また、タイプがスコープ外になる前にcloseメソッドを呼び出すことで、常に手動で閉じるように注意する必要があります。

00:24:24.000 --> 00:24:27.000
さもなければ、リソースがリークされます。

00:24:27.000 --> 00:24:35.000
1つの解決策は、タイプがスコープ外になったときに自動的に閉じるdeinitを持つクラスにすることです。

00:24:35.000 --> 00:24:48.000
しかし、追加のメモリ割り当てを行うなど、さまざまな欠点がありますが、これは通常、非常に制約されたシステムコンテキストを除いて、大きな問題ではありません。

00:24:48.000 --> 00:24:51.000
クラスには参照セマンティクスもあります。

00:24:51.000 --> 00:25:00.000
意図せずにファイル記述子タイプをスレッド間で共有したり、競合状態になったり、意図せずに保存したりする可能性があります。

00:25:00.000 --> 00:25:04.000
しかし、戻って構造体のバージョンを見てみましょう。

00:25:04.000 --> 00:25:09.000
本当に、この構造体も参照型のように振る舞います。

00:25:09.000 --> 00:25:15.000
これは、開いているファイルである真の値を参照する整数を保持します。

00:25:15.000 --> 00:25:22.000
このタイプのコピーを作成すると、バグにつながる可能性のある方法で、アプリ全体で変更可能な状態を意図せずに共有することもできます。

00:25:22.000 --> 00:25:29.000
あなたが欲しいのは、この構造体のコピーを作成する能力を抑制することです。

00:25:29.000 --> 00:25:34.000
構造体であろうとクラスであろうと、Swift型はデフォルトでコピー可能です。

00:25:34.000 --> 00:25:37.000
これはほとんどの場合正しい選択です。 ほとんどの場合。

00:25:37.000 --> 00:25:51.000
過剰な不要なコピーは、コードのボトルネックになることがありますが、それらのコピーについて明示する必要があるコンパイラに常に悩まされるよりも、時折楽器でそれらのボトルネックを見つけるのに時間を費やす方が良いです。

00:25:51.000 --> 00:26:03.000
しかし、暗黙のコピーはあなたが望むものではないことがあります。特に、値のコピーを作成すると、ファイル記述子ラッパーのように、正確性の問題につながる可能性があります。

00:26:03.000 --> 00:26:15.000
Swift 5.9では、構造体と列挙型宣言に適用でき、型をコピーする暗黙の機能を抑制するこの新しい構文でそれを行うことができます。

00:26:15.000 --> 00:26:26.000
タイプがコピーできなくなったら、クラスのように、タイプの値がスコープ外になったときに実行されるデイニットを与えることができます。

00:26:26.000 --> 00:26:35.000
コピー不可能なタイプは、closeを呼び出し、他のメソッドを使用する問題を解決するためにも使用できます。

00:26:35.000 --> 00:26:39.000
クローズ操作は消費としてマークすることができます。

00:26:39.000 --> 00:26:46.000
消費メソッドまたは引数を呼び出すと、呼び出すメソッドに値の所有権が与えられます。

00:26:46.000 --> 00:26:53.000
私たちのタイプはコピーできないので、所有権を放棄することは、もはや値を使用できないことを意味します。

00:26:53.000 --> 00:26:59.000
デフォルトでは、Swiftのメソッドはselfを含む引数を借ります。

00:26:59.000 --> 00:27:12.000
したがって、ファイル記述子を借りてバッファに書き出すwriteメソッドを呼び出すことができ、その後、値の所有権が呼び出し元に戻り、closeのような別のメソッドを呼び出すことができます。

00:27:12.000 --> 00:27:21.000
しかし、クローズは借入のデフォルトではなく、消費としてマークされているので、それは最終的な使用でなければなりません。

00:27:21.000 --> 00:27:32.000
つまり、最初にファイルを閉じてから、writeなどの別のメソッドを呼び出そうとすると、実行時の失敗ではなく、コンパイル時にエラーメッセージが表示されます。

00:27:32.000 --> 00:27:37.000
コンパイラは、消費使用が発生した場所も示します。

00:27:37.000 --> 00:27:43.000
コピー不可能なタイプは、Swiftでのシステムレベルのプログラミングのための強力な新機能です。

00:27:43.000 --> 00:27:46.000
彼らはまだ進化の初期段階にいます。

00:27:46.000 --> 00:27:52.000
後のバージョンのSwiftは、ジェネリックコードでコピー不可能なタイプを拡張します。

00:27:52.000 --> 00:27:58.000
この作品と一緒にフォローすることに興味があるなら、Swiftフォーラムで積極的に議論されています。

00:27:58.000 --> 00:28:03.000
ダグ：Swiftの成功の鍵は、Objective-Cとの相互運用性です。

00:28:03.000 --> 00:28:14.000
最初から、開発者は既存のコードベースでSwiftの採用に向けて段階的なステップを踏むことができ、Swiftで一度に単一のファイルまたはモジュールをミックスすることができました。

00:28:14.000 --> 00:28:18.000
しかし、私たちはあなたの多くがObjective-Cで書かれたコードだけではないことを知っています。

00:28:18.000 --> 00:28:25.000
多くのアプリには、C ++で実装されたコアビジネスロジックもあり、それへのインターフェースはそれほど簡単ではありませんでした。

00:28:25.000 --> 00:28:34.000
多くの場合、SwiftからObjective-Cを経て、C ++、そしてずっと戻って、追加の手動ブリッジングレイヤーを追加することを意味しました。

00:28:34.000 --> 00:28:40.000
Swift 5.9では、Swiftから直接C++の型や関数と対話する機能が導入されています。

00:28:40.000 --> 00:28:53.000
C ++の相互運用性は、Objective-Cの相互運用性が常に持っているように機能し、C++ APIをSwiftコードから直接使用できる同等のSwiftにマッピングします。

00:28:53.000 --> 00:29:01.000
C++は、クラス、メソッド、コンテナなどのアイデアの独自の概念を持つ大きな言語です。

00:29:01.000 --> 00:29:07.000
Swiftコンパイラは一般的なC++イディオムを理解しているため、多くのタイプを直接使用できます。

00:29:07.000 --> 00:29:19.000
たとえば、この Person 型は、C++ 値型に期待される 5 つの特別なメンバー関数を定義します。コンストラクタのコピーと移動、代入演算子、およびデストラクタ。

00:29:19.000 --> 00:29:26.000
Swiftコンパイラはこれを値型として扱い、適切なタイミングで適切な特別なメンバー関数を自動的に呼び出します。

00:29:26.000 --> 00:29:34.000
さらに、ベクトルやマップなどのC++コンテナは、Swiftコレクションとしてアクセスできます。

00:29:34.000 --> 00:29:42.000
その結果、C++の関数と型を直接使用する簡単なSwiftコードを書くことができます。

00:29:42.000 --> 00:29:51.000
Personインスタンスのベクトルをフィルタリングし、C++メンバー関数を呼び出し、データメンバーに直接アクセスできます。

00:29:51.000 --> 00:29:59.000
一方、C++のSwiftコードの使用は、Objective-Cと同じメカニズムに基づいています。

00:29:59.000 --> 00:30:06.000
Swiftコンパイラは、Swift APIのC++ビューを含む「生成ヘッダー」を生成します。

00:30:06.000 --> 00:30:15.000
ただし、Objective-Cとは異なり、objc属性で注釈付けされたSwiftクラスのみを使用することを制限する必要はありません。

00:30:15.000 --> 00:30:26.000
C ++は、ブリッジオーバーヘッドなしで、ほとんどのSwiftタイプと、プロパティ、メソッド、初期化子を含む完全なAPIを直接使用できます。

00:30:26.000 --> 00:30:30.000
ここでは、C++がポイント構造体をどのように活用できるかを確認できます。

00:30:30.000 --> 00:30:45.000
生成されたヘッダーを含めた後、C ++はSwiftの初期化子を呼び出して、Swiftコード自体を変更することなく、ポイントインスタンスを作成し、ミューテーションメソッドを呼び出し、保存されたプロパティと計算されたプロパティの両方にアクセスできます。

00:30:45.000 --> 00:30:53.000
SwiftのC++相互運用性により、Swiftを既存のC++コードベースと統合することがこれまで以上に簡単になります。

00:30:53.000 --> 00:31:03.000
多くのC ++イディオムは、しばしば自動的にSwiftで直接表現できますが、時折、目的のセマンティクスを示すためにいくつかの注釈を必要とします。

00:31:03.000 --> 00:31:19.000
また、Swift APIはC ++から直接アクセスでき、注釈やコードの変更は必要なく、C、C ++、Objective-Cの任意の組み合わせを使用して、コードベース全体でSwiftを段階的に採用することができます。

00:31:19.000 --> 00:31:26.000
C++の相互運用性は、C++の相互運用性ワークグループによって導かれる進化する物語です。

00:31:26.000 --> 00:31:34.000
詳細については、「SwiftとC++のミックス」トークを参照するか、Swiftフォーラムのディスカッションに参加してください。

00:31:34.000 --> 00:31:41.000
言語レベルでの相互運用性は本当に重要ですが、コードも構築できる必要があります。

00:31:41.000 --> 00:31:53.000
また、Swiftを使い始めるために、既存のビルドシステムをXcodeまたはSwift Package Managerに置き換えなければならないことは、大量のコードを書き換えるのと同じくらい大きな障壁になる可能性があります。

00:31:53.000 --> 00:31:57.000
そのため、CMakeコミュニティと協力して、CMakeのSwiftサポートを改善しました。

00:31:57.000 --> 00:32:06.000
Swiftをプロジェクトの言語の1つとして宣言し、Swiftファイルをターゲットに入れることで、SwiftコードをCMakeビルドに統合できます。

00:32:06.000 --> 00:32:19.000
さらに重要なことに、C ++とSwiftを1つのターゲット内で混在させることができ、CMakeはそれぞれを別々にコンパイルし、両方の言語の適切なサポートライブラリとランタイムをすべてリンクします。

00:32:19.000 --> 00:32:27.000
これは、今日、クロスプラットフォームのC ++プロジェクトで、ファイルごとに、またはターゲットごとにSwiftを採用し始めることができることを意味します。

00:32:27.000 --> 00:32:40.000
また、ブリッジングと生成されたヘッダーの使用など、Swiftと混合C++/Swiftターゲットを含むCMakeプロジェクトを含むサンプルリポジトリも提供しています。

00:32:40.000 --> 00:32:50.000
数年前、async/await、構造化並行性、およびアクターの構成要素に基づいて、新しい並行性モデルをSwiftに導入しました。

00:32:50.000 --> 00:32:57.000
Swiftの並行性モデルは抽象的なモデルであり、さまざまな環境やライブラリに適応できます。

00:32:57.000 --> 00:33:03.000
抽象的なモデルには、タスクと俳優の2つの主要な部分があります。

00:33:03.000 --> 00:33:09.000
タスクは、概念的にどこでも実行できる作業の連続した単位を表します。

00:33:09.000 --> 00:33:16.000
プログラムに「待機」があるときはいつでもタスクを一時停止し、タスクが続行できたら再開できます。

00:33:16.000 --> 00:33:23.000
アクターは、隔離された状態への相互に排他的なアクセスを提供する同期メカニズムです。

00:33:23.000 --> 00:33:29.000
外部から俳優を入力するには、タスクを一時停止する可能性があるため、「待機」が必要です。

00:33:29.000 --> 00:33:39.000
タスクとアクターは抽象言語モデルに統合されていますが、そのモデル内では、異なる環境に合わせてさまざまな方法で実装できます。

00:33:39.000 --> 00:33:43.000
タスクはグローバル同時プールで実行されます。

00:33:43.000 --> 00:33:48.000
グローバル同時プールがどのように作業をスケジュールするかは、環境次第です。

00:33:48.000 --> 00:33:58.000
Appleのプラットフォームの場合、ディスパッチライブラリはオペレーティングシステム全体に最適化されたスケジューリングを提供し、各プラットフォーム向けに広範囲に調整されています。

00:33:58.000 --> 00:34:04.000
より制限的な環境では、マルチスレッドスケジューラのオーバーヘッドは受け入れられない場合があります。

00:34:04.000 --> 00:34:10.000
Swiftの並行性モデルは、シングルスレッドの協力キューで実装されています。

00:34:10.000 --> 00:34:19.000
抽象モデルは多様なランタイム環境にマッピングするのに十分な柔軟性があるため、同じSwiftコードは両方の環境で機能します。

00:34:19.000 --> 00:34:28.000
さらに、コールバックベースのライブラリとの相互運用性は、最初からSwiftのasync/awaitサポートに組み込まれていました。

00:34:28.000 --> 00:34:35.000
withCheckedContinuation操作を使用すると、タスクを一時停止し、コールバックに応答して後で再開できます。

00:34:35.000 --> 00:34:41.000
これにより、タスク自体を管理する既存のライブラリとの統合が可能になります。

00:34:41.000 --> 00:34:51.000
Swift並行性ランタイムにおけるアクターの標準実装は、アクターで実行するタスクのロックフリーキューですが、可能な実装はそれだけではありません。

00:34:51.000 --> 00:35:00.000
より制限された環境では、アトミックを持っていない可能性があり、代わりにスピンロックなどの別の並行性プリミティブを使用できます。

00:35:00.000 --> 00:35:09.000
その環境がシングルスレッドの場合、同期は必要ありませんが、アクターモデルは関係なくプログラムの抽象並行性モデルを維持します。

00:35:09.000 --> 00:35:15.000
同じコードをマルチスレッドの別の環境に持っていくことができます。

00:35:15.000 --> 00:35:22.000
Swift 5.9では、カスタムアクターエグゼキュータにより、特定のアクターが独自の同期メカニズムを実装できます。

00:35:22.000 --> 00:35:27.000
これにより、アクターはより柔軟になり、既存の環境に適応しやすくなります。

00:35:27.000 --> 00:35:30.000
例を挙げてみましょう。

00:35:30.000 --> 00:35:34.000
ここでは、データベース接続を管理するアクターを検討します。

00:35:34.000 --> 00:35:42.000
Swiftは、このアクターのストレージへの相互に排他的なアクセスを保証するため、データベースへの同時アクセスはありません。

00:35:42.000 --> 00:35:48.000
ただし、同期が行われる特定の方法をより詳細に制御する必要がある場合はどうなりますか?

00:35:48.000 --> 00:35:57.000
たとえば、そのキューがアクターを採用していない他のコードと共有されているため、データベース接続に特定のディスパッチキューを使用する場合はどうなりますか?

00:35:57.000 --> 00:36:01.000
カスタム俳優の執行者があれば、できます。

00:36:01.000 --> 00:36:13.000
ここでは、アクターにシリアルディスパッチキューを追加し、そのディスパッチキューに対応するexecututorを生成するunowned executorプロパティの実装を追加しました。

00:36:13.000 --> 00:36:20.000
この変更により、アクターインスタンスのすべての同期は、そのキューを介して行われます。

00:36:20.000 --> 00:36:29.000
アクターの外部からpruneOldEntriesへの呼び出しを「待機」すると、対応するキューでディスパッチ非同期が実行されます。

00:36:29.000 --> 00:36:43.000
これにより、個々のアクターがどのように同期を提供するかをより詳細に制御でき、おそらくObjective-CまたはC ++で書かれているため、アクターをまだ使用していない他のコードとアクターを同期させることもできます。

00:36:43.000 --> 00:36:51.000
ディスパッチキューが新しいSerialExecutorプロトコルに準拠しているため、ディスパッチキューを介したアクターの同期が可能になります。

00:36:51.000 --> 00:37:07.000
コア操作がほとんどないこのプロトコルに準拠した新しいタイプを定義することで、アクターで使用する独自の同期メカニズムを提供できます。コードが実行者のコンテキストですでに実行されているかどうかを確認します。

00:37:07.000 --> 00:37:11.000
例えば、私たちはメインスレッドで実行していますか?

00:37:11.000 --> 00:37:18.000
執行者への未所有の参照を抽出して、過剰な参照カウントトラフィックなしでアクセスできるようにします。

00:37:18.000 --> 00:37:24.000
そして、最も中核的な操作であるエンキューは、執行者の「仕事」の所有権を取ります。

00:37:24.000 --> 00:37:29.000
ジョブは、実行者で同期的に実行する必要がある非同期タスクの一部です。

00:37:29.000 --> 00:37:38.000
エンキューが呼び出される時点で、シリアルエグゼキュータで他のコードが実行されていないときに、ある時点でそのジョブを実行するのはエグゼキュータの責任です。

00:37:38.000 --> 00:37:45.000
たとえば、ディスパッチキューのエンキューは、そのキューでディスパッチ非同期を呼び出します。

00:37:45.000 --> 00:37:55.000
Swift Concurrencyは数年前から使用されており、タスクとアクターで構成される抽象モデルは、幅広い同時プログラミングタスクをカバーしています。

00:37:55.000 --> 00:38:05.000
抽象的なモデル自体は非常に柔軟で、iPhoneからApple Watch、サーバーなど、さまざまな実行環境に適応できます。

00:38:05.000 --> 00:38:13.000
また、重要なポイントでのカスタマイズを可能にし、まだSwift Concurrencyを完全に採用していないコードと相互運用できるようにしました。

00:38:13.000 --> 00:38:20.000
詳細については、「舞台裏」トークと「構造化並行性の基本を超えて」を参照してください。

00:38:20.000 --> 00:38:29.000
私たちが見慣れているiOSやMacOSアプリとは大きく異なる環境で動作するSwiftのケーススタディを少し締めくくりたいと思います。

00:38:29.000 --> 00:38:44.000
FoundationDBは分散データベースであり、コモディティハードウェアで実行され、MacOS、Linux、Windowsなどのさまざまなプラットフォームをサポートする非常に大規模なキーバリューストアにスケーラブルなソリューションを提供します。

00:38:44.000 --> 00:38:50.000
FoundationDBは、C++で書かれた大規模なコードベースを持つオープンソースプロジェクトです。

00:38:50.000 --> 00:39:01.000
コードは非常に非同期であり、独自の形式の分散アクターとランタイムがあり、テスト目的で非常に重要な決定論的シミュレーション環境を提供します。

00:39:01.000 --> 00:39:11.000
FoundationDBはコードベースを近代化しようとしており、Swiftはパフォーマンス、安全性、コードの明確さに適していることがわかりました。

00:39:11.000 --> 00:39:14.000
完全な書き換えは、大きくて危険な努力になるだろう。

00:39:14.000 --> 00:39:21.000
代わりに、Swiftの相互運用性を活用して、既存のコードベースに統合しました。

00:39:21.000 --> 00:39:29.000
たとえば、これはFoundationDBの「マスターデータ」アクターのC++実装の一部です。

00:39:29.000 --> 00:39:33.000
ここでは多くのことが起こっており、このC++のすべてを理解する必要はありません。

00:39:33.000 --> 00:39:38.000
しかし、私はコードのいくつかの重要な側面を指摘したいと思います。

00:39:38.000 --> 00:39:48.000
まず、C++にはasync/awaitがないため、FoundationDBはそれをエミュレートするための独自のプリプロセッサのようなアプローチを持っています。

00:39:48.000 --> 00:39:56.000
多くのC++コードベースと同様に、彼らは非同期タスクを管理するために独自のC++フューチャータイプを実装しています。

00:39:56.000 --> 00:40:01.000
これらは、要求に応答を送信するための明示的なメッセージングとペアになります。

00:40:01.000 --> 00:40:07.000
返信の送信と関数からの返却の慎重なペアリングに注意してください。

00:40:07.000 --> 00:40:13.000
最後に、FoundationDBには、メモリを自動的に管理するための独自の参照カウントスマートポインタがあります。

00:40:13.000 --> 00:40:20.000
Swiftでは、この全体をはるかにきれいに実装できます。

00:40:20.000 --> 00:40:24.000
その方がいい。

00:40:24.000 --> 00:40:28.000
この関数は、Swiftで非同期関数として直接実装できます。

00:40:28.000 --> 00:40:36.000
この要求に応答するための通常のリターンタイプと通常のリターンステートメントがありますので、同期を外すことはありません。

00:40:36.000 --> 00:40:43.000
他のすべてのSwift非同期コードと同じ方法でサスペンションポイントを示す「待機」があります。

00:40:43.000 --> 00:40:51.000
そして、このSwiftコードは、継続を使用して適応されたC++ Futureタイプと結びついています。

00:40:51.000 --> 00:40:54.000
ここでは、いくつかのC++タイプを使用しています。

00:40:54.000 --> 00:40:59.000
C++のMasterDataタイプは、参照カウントされたスマートポインタを使用していました。

00:40:59.000 --> 00:41:09.000
C++で型に注釈を付けることで、Swiftコンパイラは他のクラスと同様にこの型を使用し、参照数を自動的に管理できます。

00:41:09.000 --> 00:41:16.000
リクエストタイプや返信タイプなどの他のタイプは、Swiftで直接使用されているC++値タイプです。

00:41:16.000 --> 00:41:19.000
そして、相互運用性は両方向です。

00:41:19.000 --> 00:41:28.000
この非同期関数、そして実際、Swift並行性モデルによって導入されたすべての作業は、FoundationDBの既存の決定論的ランタイムで実行されます。

00:41:28.000 --> 00:41:38.000
そのため、既存のC++とインターフェースして、Swiftのメリットを必要な場所で得ることができます。

00:41:38.000 --> 00:41:41.000
このセッションでは、多くの分野をカバーしました。

00:41:41.000 --> 00:41:51.000
より表現力豊かなAPIを可能にし、より良いコードをより速く書くのに役立つパラメータパックやマクロなどの機能について説明しました。

00:41:51.000 --> 00:42:01.000
パフォーマンスに敏感なコードでのSwiftの使用と、参照カウントのオーバーヘッドなしでリソース管理を提供するためのコピー不可能な型の導入について話しました。

00:42:01.000 --> 00:42:15.000
次に、SwiftでC ++ APIを使用するためのサポートを提供するC ++の相互運用性に飛び込み、Swiftの利点をより多くのコードに簡単にもたらすことができます。

00:42:15.000 --> 00:42:26.000
最後に、Swiftの柔軟な並行性モデルがデバイスや言語間の無数の環境に適応し、並行性をより簡単かつ安全にする方法について話しました。

00:42:26.000 --> 00:42:41.000
Swift 5.9のパラメータパック、マクロ、コピー不可能なタイプ、および他のすべての言語強化は、Swift Evolutionプロセスを通じてオープンに設計および開発され、コミュニティのフィードバックはこれらの機能を形作る上で非常に重要でした。

00:42:41.000 --> 00:42:54.000
Swift 5.9は、アクティブなデザインディスカッション、バグレポート、プルリクエスト、教育コンテンツなど、Swiftコミュニティのメンバーからの数え切れないほどの貢献の集大成です。

00:42:54.000 --> 00:42:59.000
Swift 5.9を素晴らしいリリースにしてくれてありがとう。

00:42:59.000 --> 23:59:59.000
♪ ♪

