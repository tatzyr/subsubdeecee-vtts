WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:11.000
ニヴァシュ:皆さん、こんにちは。

00:00:11.000 --> 00:00:16.000
私はコアロケーションフレームワークチームのエンジニア、Nivash Raaja Karukankaatur Murugasamyです。

00:00:16.000 --> 00:00:19.000
コアロケーションモニターに関する私の講演へようこそ。

00:00:19.000 --> 00:00:23.000
私たちの新しいCLMonitor APIについて話すことに本当に興奮しています。

00:00:23.000 --> 00:00:31.000
Swiftでわずか数行のコードで、シンプルで強力な監視ロジックを書くことができます。

00:00:31.000 --> 00:00:36.000
モニターを作成し、条件を追加し、イベントを待つだけです。

00:00:36.000 --> 00:00:39.000
そこにあります。こんにちは、CLMonitor!

00:00:39.000 --> 00:00:43.000
CLMonitor APIの詳細を見てみましょう。 

00:00:43.000 --> 00:00:54.000
ユーザーの位置やビーコンを監視するための新しいシンプルで強力な方法であるCLMonitor APIの概要から始めます。

00:00:54.000 --> 00:01:02.000
次に、監視できる条件の種類と、それらを追加または削除する方法について説明します。

00:01:02.000 --> 00:01:10.000
次に、監視記録、それらに含まれるもの、およびアプリのライフサイクル中にそれらにアクセスする方法について説明します。

00:01:10.000 --> 00:01:17.000
監視対象の条件のいずれかがイベントに遭遇した場合に、アプリで実行する必要がある手順に従います。

00:01:17.000 --> 00:01:25.000
そして最後に、CLMonitorを使用する際に役立ついくつかの要件と推奨事項をまとめます。

00:01:25.000 --> 00:01:33.000
まず、モニターとは何か、監視用のモニターを作成する方法を見てみましょう。

00:01:33.000 --> 00:01:39.000
CLMonitorはトップレベルのSwiftアクターであり、各CLMonitorインスタンスは監視へのゲートウェイとして機能します。

00:01:39.000 --> 00:01:45.000
アクターであるため、スレッドとタスクの同期のオーバーヘッドから解放されます。

00:01:45.000 --> 00:01:53.000
したがって、CLMonitorのコンテンツにアクセスしたり、いつでも条件を追加または削除したりするのを待つ必要があります。

00:01:53.000 --> 00:01:58.000
モニターを作成するには、英数字の文字列でモニターのinitメソッドを呼び出します。

00:01:58.000 --> 00:02:03.000
その名前の既存のモニターがない場合は、新しいモニターが作成されます。

00:02:03.000 --> 00:02:06.000
そうでなければ、既存のものが開かれます。

00:02:06.000 --> 00:02:10.000
いずれにせよ、モニターインスタンスが返されます。

00:02:10.000 --> 00:02:16.000
いつでも開くことができるのは、指定された名前のインスタンスが1つだけであることに注意してください。

00:02:16.000 --> 00:02:20.000
監視されているエンティティは条件と呼ばれます。

00:02:20.000 --> 00:02:28.000
監視用の条件をCLMonitorインスタンスに追加し、addメソッドを使用して識別子に関連付けることができます。

00:02:28.000 --> 00:02:30.000
識別子は英数字の文字列です。

00:02:30.000 --> 00:02:39.000
たとえば、この例の「作業」は、ユーザーが作業中に満たされる条件の記録を一意に識別します。

00:02:39.000 --> 00:02:47.000
レコードオブジェクトとその内容は、この識別子によってアクセスでき、条件は削除されるまで監視されます。

00:02:47.000 --> 00:02:52.000
同じ識別子でremoveを呼び出すことで、監視から条件を削除できます。

00:02:52.000 --> 00:02:56.000
条件を削除すると、対応するレコードも削除されます。

00:02:56.000 --> 00:03:07.000
モニターインスタンスの作成方法とそれが条件とどのように関連しているかがわかったので、利用可能な条件の種類と、それを作成して監視用に追加する方法を見てみましょう。

00:03:07.000 --> 00:03:11.000
iOSでサポートされている条件には2種類あります。

00:03:11.000 --> 00:03:14.000
まず、CircularGeographicCondition。

00:03:14.000 --> 00:03:19.000
円形の地理的条件は、中心と半径によって定義されます。

00:03:19.000 --> 00:03:24.000
中心は条件の地理的位置を定義します。

00:03:24.000 --> 00:03:29.000
半径は、条件が満たされていると見なされる領域を定義します。

00:03:29.000 --> 00:03:34.000
その地域以外の場所では、その状態が満たされていないと報告します。

00:03:34.000 --> 00:03:39.000
これは、iOS 16および以前のリリースのCLCircularRegionに似ています。

00:03:39.000 --> 00:03:46.000
関心のある緯度と経度でCLLocationCoordinate2Dを構築することで、中心を定義します。

00:03:46.000 --> 00:03:54.000
次に、その中心と関心のある半径でCircularGeographicConditionを作成します。

00:03:54.000 --> 00:03:59.000
iOSでサポートされている他のタイプの条件は、BeaconIdentityConditionです。

00:03:59.000 --> 00:04:09.000
BeaconIdentityConditionは、iOS 16以前のリリースで使用した可能性のあるCLBeaconIdentityConstraintまたはCLBeaconRegionに似ています。

00:04:09.000 --> 00:04:25.000
会社が異なる場所に複数のサイトがある場合は、ビーコンを展開して、ユーザーがいずれかのサイト、特定のサイト、または特定のサイトの特定のセクションにいるかどうかをアプリで検出できます。

00:04:25.000 --> 00:04:31.000
複数のサイトのオフィスで利用可能な簡単な例として、Appleのカフェテリアを考えてみましょう。

00:04:31.000 --> 00:04:37.000
関連するアプリで位置情報ベースの動作を有効にするために、ビーコンを効果的に展開する方法を見てみましょう。

00:04:37.000 --> 00:04:47.000
そして、私たちが行くにつれて、そのアプリがさまざまな状況でBeaconIdentityConditionの異なるフレーバーを使用して、これらのビーコンを監視する方法について話します。

00:04:47.000 --> 00:04:51.000
ビーコンを定義するものを簡単に見てみましょう。

00:04:51.000 --> 00:04:56.000
UUID文字列、メジャー番号、マイナー番号が含まれています。

00:04:56.000 --> 00:05:06.000
BeaconIdentityConditionを使用すると、UUID、メジャー、マイナーの3つすべてを指定することで、特定のビーコンを監視できます。

00:05:06.000 --> 00:05:16.000
または、UUIDとメジャーのみ、またはUUIDのみを指定することで、ビーコンのグループから任意の単一のビーコンを一致させるためにワイルドカードで一致させることができます。

00:05:16.000 --> 00:05:23.000
マイナーまたはメジャーとマイナーを未指定のままにすると、それらのプロパティの値を持つビーコンが一致する可能性があります。

00:05:23.000 --> 00:05:25.000
この例でこれをどのように使用できるか見てみましょう。

00:05:25.000 --> 00:05:32.000
私たちは、すべて同じUUIDを持つこれらのカフェテリアサイトにビーコンを展開することができます。

00:05:32.000 --> 00:05:38.000
また、アプリでは、このUUIDを監視するためのBeaconIdentityConditionを作成できます。

00:05:38.000 --> 00:05:45.000
その後、ユーザーがこれらのビーコンの1つに近づくと、条件が満たされます。

00:05:45.000 --> 00:05:49.000
そうでなければ、それは満足していないと判断されます。

00:05:49.000 --> 00:05:57.000
コードでは、UUIDのみを指定するinitメソッドを呼び出すことでこれを行うことができます。

00:05:57.000 --> 00:06:05.000
必要な場所にビーコンを展開したので、ユーザーが特定のサイトの1つにいるかどうかを検出することに興味があるかもしれません。

00:06:05.000 --> 00:06:11.000
この場合、ユーザーがアップルパークのサイトにいるかどうかを監視する方法を見てみましょう。

00:06:11.000 --> 00:06:17.000
これを達成するために、各サイトに展開されたビーコンは、一意の主要な番号を共有する必要があります。

00:06:17.000 --> 00:06:25.000
その後、アプリで、そのメジャーと全体的なUUIDでBeaconIdentityConditionを監視できます。

00:06:25.000 --> 00:06:36.000
条件の状態は、デバイスがビーコンがUUIDとメジャー値の両方と一致するサイトにある場合にのみ、満たされていると判断されます。

00:06:36.000 --> 00:06:39.000
他のサイトでは満足できないままです。

00:06:39.000 --> 00:06:50.000
コードでは、UUIDとメジャーのみを指定するinitメソッドを呼び出すことで、BeaconIdentityConditionを作成できます。

00:06:50.000 --> 00:06:54.000
これで、すべてのサイトまたは特定のサイトを監視する方法がわかりました。

00:06:54.000 --> 00:07:01.000
ただし、特定のサイト内の特定のセクションを監視することもできます。

00:07:01.000 --> 00:07:10.000
これは、対応するマイナーな値を持つ各サイト内の異なる場所（例えば、料理ステーション）にビーコンを配置することで達成できます。

00:07:10.000 --> 00:07:19.000
アプリでは、UUIDとメジャーとともに、特定のマイナー値のBeaconIdentityConditionを監視できます。

00:07:19.000 --> 00:07:27.000
このような状態は、そのマイナーと全体的なUUIDとメジャーを持つビーコンが検出された場合にのみ満たされます。

00:07:27.000 --> 00:07:38.000
コードでは、これはUUID、メジャー、マイナーを渡すことによってBeaconIdentityConditionを作成することを意味します。

00:07:38.000 --> 00:07:43.000
BeaconIdentityConditionを作成するときは、ニーズに合ったinitメソッドを使用してください。

00:07:43.000 --> 00:07:53.000
さて、さまざまなタイプとフレーバーの条件を作成する方法がわかったので、監視のためにそれらを追加する方法を見てみましょう。

00:07:53.000 --> 00:08:01.000
CLMonitorインスタンスで識別子と呼ばれる英数字の文字列でaddメソッドを呼び出すことで、監視の条件を追加できます。

00:08:01.000 --> 00:08:05.000
条件は識別子に関連付けられます。

00:08:05.000 --> 00:08:13.000
条件がすでに指定された識別子で監視されている場合は、渡された新しい条件に置き換えられます。

00:08:13.000 --> 00:08:20.000
条件を追加すると、コアロケーションによって決定されるまで、初期状態は不明になります。

00:08:20.000 --> 00:08:26.000
追加する前に、条件の現在の状態を認識している場合があります。

00:08:26.000 --> 00:08:33.000
そのような場合、監視のために追加するときに状態を渡すことで、デフォルトの初期状態を上書きできます。

00:08:33.000 --> 00:08:43.000
この例では、あなたのアプリはあなたがアップルパークのサイトにいないと推測し、条件が満たされていないことを期待していると仮定しましょう。

00:08:43.000 --> 00:08:46.000
通話に「assuming: .unsatisfied」を追加できます。

00:08:46.000 --> 00:08:50.000
その後、監視は「不満」に設定された状態から始まります。

00:08:50.000 --> 00:08:52.000
でも、心配しないでください。

00:08:52.000 --> 00:08:58.000
状態の仮定が間違っている場合、コアロケーションは、それが決定されると正しい状態を提供します。

00:08:58.000 --> 00:09:07.000
モニタリングから条件を削除するには、条件が追加されたときに渡された識別子でremoveメソッドを呼び出すことができます。

00:09:07.000 --> 00:09:14.000
これで、条件とは何か、どのタイプがサポートされているか、監視から条件を追加または削除する方法がわかりました。

00:09:14.000 --> 00:09:23.000
レコードの内容と、レコードまたはモニター内のすべてのレコードをいつでも検査する方法を詳しく見てみましょう。

00:09:23.000 --> 00:09:34.000
以前のスライドから思い出せる場合、監視の条件を追加すると、Core Locationはレコードを作成し、そのレコードに条件を追加します。

00:09:34.000 --> 00:09:42.000
条件に加えて、レコードにはイベントと呼ばれる別のオブジェクトが含まれています。

00:09:42.000 --> 00:09:57.000
イベントには、満足しているかどうか、満足していないかどうか、不明であるかどうかにかかわらず、条件の現在の観察状態を表す状態と、条件が状態に遭遇した日時が含まれます。

00:09:57.000 --> 00:10:03.000
今、あなたはなぜイベントに別の条件のインスタンスがあるのか疑問に思うかもしれません。

00:10:03.000 --> 00:10:05.000
これは洗練と呼ばれています。

00:10:05.000 --> 00:10:07.000
それは何のためですか?

00:10:07.000 --> 00:10:21.000
BeaconIdentityConditionから呼び出すことができれば、アプリはUUID、UUIDとメジャー、またはUUIDとメジャーとマイナーだけを監視できます。

00:10:21.000 --> 00:10:30.000
メジャーとマイナーのワイルドカードを持つ条件が満たされた場合、そのイベントは改良が入力された状態で配信されます。

00:10:30.000 --> 00:10:37.000
その改良条件は、UUIDだけでなく、観察されたビーコンの主要な情報とマイナーな情報も運びます。

00:10:37.000 --> 00:10:43.000
その後、条件が満たされなくなると、絞り込みはゼロにリセットされます。

00:10:43.000 --> 00:10:52.000
条件が追加されたときに渡された識別子によって一意にアドレスされた各レコードを持つレコードのインスタンスが複数ある可能性があります。

00:10:52.000 --> 00:11:00.000
lastEventsと識別子に条件を関連付けるモニターのすべてのレコードは、アプリに保存されます。

00:11:00.000 --> 00:11:06.000
これにより、いつでも最後に観察された条件とその対応する状態を照会できます。

00:11:06.000 --> 00:11:09.000
それがコードでどのように見えるか見てみましょう。

00:11:09.000 --> 00:11:15.000
条件に関連付けられたレコードを取得するには、その識別子でレコードメソッドを呼び出すことができます。

00:11:15.000 --> 00:11:20.000
渡した識別子で条件が監視されていない場合は、nilが返されます。

00:11:20.000 --> 00:11:26.000
その後、条件プロパティにアクセスすることで、基礎となる監視条件を取得できます。

00:11:26.000 --> 00:11:35.000
また、lastEventプロパティにアクセスすることで、その条件のlastEventをアプリに配信できます。

00:11:35.000 --> 00:11:42.000
その後、イベントから、最近観察された状態、日付、および洗練を得ることができます。

00:11:42.000 --> 00:11:45.000
今、あなたは1つのレコードを取得する方法を知っています。

00:11:45.000 --> 00:11:47.000
すべての監視記録はどうやって取得しますか?

00:11:47.000 --> 00:11:51.000
すべての識別子を追跡する必要がありますか? 

00:11:51.000 --> 00:11:53.000
まあ、あなたはする必要はありません。

00:11:53.000 --> 00:11:58.000
モニターの識別子プロパティでリストを維持します。

00:11:58.000 --> 00:12:04.000
簡単に反復して、各レコードとその内容を取得できます。

00:12:04.000 --> 00:12:12.000
レコードの内容にアクセスする方法がわかったので、変更が発生したときにイベントを消費する方法を見てみましょう。

00:12:12.000 --> 00:12:17.000
イベントを受信するコードは、タスクにラップされた単純なループを使用して実装できます。

00:12:17.000 --> 00:12:33.000
Core LocationがlastEventで報告された状態とは異なる監視対象の状態を観察すると、Core Locationはモニターのイベント非同期シーケンスプロパティを介して新しいイベントを配信し、待機ループを再開します。

00:12:33.000 --> 00:12:40.000
配信されるイベントオブジェクトは、新しい状態と影響を受ける条件の識別子をもたらします。

00:12:40.000 --> 00:12:51.000
または、新しいイベントの処理中に、識別子を使用して、その条件のレコードとlastEventを取得することもできます。

00:12:51.000 --> 00:12:56.000
その情報を使用して、今起こったことについてより多くの文脈を得ることができます。

00:12:56.000 --> 00:12:57.000
そこにある！

00:12:57.000 --> 00:13:01.000
私たちのシンプルなグリータープログラムが完成しました。

00:13:01.000 --> 00:13:08.000
CLMonitorの仕組みがわかったので、最適な使い方についてアドバイスがあります。

00:13:08.000 --> 00:13:11.000
3つの重要な要件から始めましょう。

00:13:11.000 --> 00:13:24.000
まず、異なる条件の処理を別々にするために、異なる名前の複数のモニターを持つことができますが、特定の名前に対して一度に1つだけをインスタンス化する必要があります。

00:13:24.000 --> 00:13:35.000
CLMonitorは監視している条件の状態を維持しているため、同じ名前の別の状態を初期化しようとすると、望ましくない動作が発生する可能性があります。

00:13:35.000 --> 00:13:45.000
第二に、イベントは予測不可能に到着する可能性があるため、モニターのイベントシーケンスに常にタスクを待機させるのが最善です。

00:13:45.000 --> 00:13:51.000
イベントは、あなたがそれを処理した後にのみ、いくつかのレコードの最後のイベントになることができます。

00:13:51.000 --> 00:13:59.000
したがって、イベントを待っていない間に状態が変更された場合、モニターは新しい状態を反映しません。

00:13:59.000 --> 00:14:11.000
最後に、アプリが終了した場合、監視された条件がイベントに遭遇すると、ユーザーの位置情報を受け取ることが許可されている限り、コアロケーションはバックグラウンドでアプリを起動します。

00:14:11.000 --> 00:14:21.000
つまり、アプリは、監視している状態の状態に興味がある場合は、起動するたびにモニターを再監視し、イベントを待つ必要があります。

00:14:21.000 --> 00:14:29.000
これを行う1つの方法は、didFinishLaunchingWithOptionsアプリデリゲートコールバックを聞くことです。

00:14:29.000 --> 00:14:36.000
新しいAPIは起動動作をもたらすので、あなたのアプリからのみCLMonitorを使用することを強くお勧めします。

00:14:36.000 --> 00:14:47.000
ウィジェットやプラグインで使用すると、代わりにアプリが起動し、一度に特定の名前のモニターが1つしか存在しないことが複雑になります。

00:14:47.000 --> 00:15:12.000
最後に、先に述べたように、条件とその状態は持続し、CLMonitorが監視している条件の1つで状態の変化を観察したときにイベントが生成されるため、CLMonitorがそれらを自分のテーブルに維持するのではなく、それらを表すようにそれらの状態を見て、到着したイベントと同期しないことを強くお勧めします。

00:15:12.000 --> 00:15:20.000
とはいえ、SwiftUIビジュアライゼーションなどの一部のアプリケーションでは、別の表現を保持する必要があるかもしれません。

00:15:20.000 --> 00:15:27.000
それを行う必要がある場合は、その表現をSwiftUI用に予約し、予想されるイベントについて推論するために使用しないでください。

00:15:27.000 --> 00:15:30.000
それがCLMonitorです!

00:15:30.000 --> 00:15:32.000
私たちの新しいAPIには本当に興奮しています。

00:15:32.000 --> 00:15:34.000
試してみて！

00:15:34.000 --> 00:15:37.000
監視体験が大幅に向上することを願っています。

00:15:37.000 --> 00:15:40.000
私たちはあなたのフィードバックを聞きたいです。

00:15:40.000 --> 00:15:44.000
また、CLMonitorの動作を実証するサンプルアプリもあります。

00:15:44.000 --> 00:15:47.000
このビデオのリソースセクションで入手できます。

00:15:47.000 --> 00:15:50.000
ダウンロードして試してみてください。

00:15:50.000 --> 00:15:55.000
最後に、場所の更新について同僚のSirajによるセッションをチェックアウトします。

00:15:55.000 --> 23:59:59.000
見てくれてありがとう!

