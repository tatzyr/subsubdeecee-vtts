WEBVTT

00:00:00.000 --> 00:00:12.000
SwiftUIのMeet StoreKitへようこそ。

00:00:12.000 --> 00:00:15.000
私はStoreKitチームのエンジニア、グレッグです。

00:00:15.000 --> 00:00:19.000
アプリ内購入のマーチャンダイジングについて話しましょう。

00:00:19.000 --> 00:00:27.000
マーチャンダイジングアプリ内購入とは、製品の提供を提示し、顧客が購入を完了する方法を提供することです。

00:00:27.000 --> 00:00:34.000
マーチャンダイジングは、販売している製品に関するデータを取得し、顧客のステータスを取得することから始まります。

00:00:34.000 --> 00:00:38.000
例えば、顧客はすでに私の非消耗性製品を所有していますか?

00:00:38.000 --> 00:00:41.000
彼らは私のサブスクリプションを購読していますか?

00:00:41.000 --> 00:00:48.000
このデータを組み合わせて、顧客に製品を販売するためのインターフェースを構築し、製品を購入するためのインタラクションを提供します。

00:00:48.000 --> 00:00:54.000
この小さな赤い長方形は、インターフェイスの構築にかかわるすべてのハードワークを過小評価しています。

00:00:54.000 --> 00:01:00.000
実際、インターフェイスの構築には多くの側面があり、さまざまな分野のスキルが必要です。

00:01:00.000 --> 00:01:03.000
その後、顧客はあなたの製品を購入することを選択します。

00:01:03.000 --> 00:01:10.000
アプリは、購入APIを使用して応答し、購入の結果としてインターフェイスを更新する必要があります。

00:01:10.000 --> 00:01:16.000
アプリにアプリ内購入を追加したことがある場合は、マーチャンダイジングを正しく取得することが重要であることを知っています。

00:01:16.000 --> 00:01:22.000
これらすべてのステップをシンプルでありながら強力なビューに抽象化できればいいのではないでしょうか?

00:01:22.000 --> 00:01:30.000
このビューは、すべての一般的な機能を処理し、アプリをアプリにするビットを設定できるパラメータを取ることができます。

00:01:30.000 --> 00:01:37.000
さて、マーチャンダイジングUIを構築するためのStoreKitの強力な新しいAPIセットを紹介することに興奮しています。

00:01:37.000 --> 00:01:44.000
Xcode 15では、StoreKitは、宣言的なアプリ内購入UIを構築するのに役立つSwiftUIビューのコレクションを提供するようになりました。

00:01:44.000 --> 00:01:52.000
マーチャンダイジング体験を望んでいるものを宣言するだけで、システムは舞台裏であなたの宣言を実行に移します。

00:01:52.000 --> 00:02:01.000
StoreView、ProductView、SubscriptionStoreViewは、これまで以上に迅速にマーチャンダイジングを稼働させるための新しいビューです。

00:02:01.000 --> 00:02:08.000
これらのビューは、App Storeからのデータフローを抽象化し、アプリ内購入を表すためにシステムが提供するUIを表示します。

00:02:08.000 --> 00:02:16.000
すでに慣れ親しんでいるSwiftUI APIを使用して、これらのビューがアプリとどのように統合されるかをカスタマイズすることもできます。

00:02:16.000 --> 00:02:29.000
SwiftUIと同様に、これらの新しいビューはすべてのプラットフォームでサポートされているため、iPhone、iPad、Mac、Apple Watch、Apple TVでアプリ内購入のマーチャンダイジングがこれまで以上に簡単になります。

00:02:29.000 --> 00:02:36.000
羽の生えた友人の群れが私に近づいてきて、Backyard Birdsと呼ばれる新しいゲームにアプリ内購入を追加するのを手伝うことができるかどうか尋ねました。

00:02:36.000 --> 00:02:41.000
StoreKitからのこれらの新しいビューで、もちろん私は「全く問題ありません」と言いました。

00:02:41.000 --> 00:02:45.000
Backyard Birdsで優れたアプリ内購入体験をお届けしますので、ぜひご参加ください。

00:02:45.000 --> 00:02:49.000
私と一緒にこれに取り組むために、サンプルプロジェクトを自由にダウンロードしてください。

00:02:49.000 --> 00:02:54.000
Xcodeプレビューを使用して、SwiftUIビューをすばやく反復します。

00:02:54.000 --> 00:02:59.000
カバーすることがたくさんあるので、私はすでにStoreKit設定ファイルを設定しました。

00:02:59.000 --> 00:03:05.000
これには、StoreKitでXcodeプレビューを使用するために必要なアプリ内購入に関するメタデータが含まれています。

00:03:05.000 --> 00:03:15.000
「StoreKitテストの新機能」や「XcodeでのStoreKitテストの紹介」など、独自のアプリを使い始めるのに役立つ素晴らしいセッションがいくつかあります。

00:03:15.000 --> 00:03:17.000
Xcodeにすぐに入りましょう。

00:03:17.000 --> 00:03:21.000
裏庭の鳥では、この栄養ペレットのようなプレミアムバードフードを販売したいと考えています。

00:03:21.000 --> 00:03:26.000
食べ物を購入した後、私たちはより多くの空腹の鳥の訪問者を引き付けるために私たちの裏庭にそれを残すことができます。

00:03:26.000 --> 00:03:33.000
コードに飛び込んで、StoreKitを活用してこれらの製品を商品化する方法を見てみましょう。

00:03:33.000 --> 00:03:39.000
始めるために、鳥の餌を商品にするためにBirdFoodShopというビューを作成します。

00:03:39.000 --> 00:03:42.000
このビューを実装するためのファイルをすでに作成しました。

00:03:42.000 --> 00:03:50.000
StoreKitを使用してビューを構築するには、ファイルの上部にStoreKitとSwiftUIの両方をインポートする必要があります。

00:03:50.000 --> 00:03:59.000
次に、私たちの店を構築するのに役立つ鳥の餌データモデルを取得するために、ここでクエリを宣言します。

00:03:59.000 --> 00:04:05.000
マーチャンダイジングビューを起動して実行する最も簡単な方法であるため、アプリにStoreViewを追加しています。

00:04:05.000 --> 00:04:18.000
birdFoodモデルから取得できるStoreKit設定ファイルから製品識別子のコレクションを提供する必要があります。

00:04:18.000 --> 00:04:22.000
この宣言の後、今、私たちは機能するマーチャンダイジングビューを持っています。

00:04:22.000 --> 00:04:28.000
StoreKitは、App Storeからすべての製品識別子をロードし、UIで表示します。

00:04:28.000 --> 00:04:37.000
表示名、説明、価格はすべて、App Store ConnectまたはStoreKit設定ファイルで設定したものを使用するApp Storeから直接来ています。

00:04:37.000 --> 00:04:49.000
StoreKitは、有効期限が切れるまで、またはシステムがメモリの圧力下にあるまでデータをキャッシュしたり、スクリーンタイムでアプリ内購入が無効になっているかどうかを確認するなど、より微妙だが重要な考慮事項を処理します。

00:04:49.000 --> 00:04:54.000
以前、鳥のデザイナーは、各鳥の食品に装飾的なアイコンを送りました。

00:04:54.000 --> 00:05:04.000
末尾のビュービルダーを追加し、アイコンを表すSwiftUIビューを渡すだけで、これらのアイコンをストアビューに追加できます。

00:05:04.000 --> 00:05:10.000
ビュービルダーは、製品値をパラメータとして取り、使用するアイコンを決定するために使用できます。

00:05:10.000 --> 00:05:20.000
製品IDを受け取り、アセットカタログから正しいアイコンを調べるヘルパービューを作成しました。

00:05:20.000 --> 00:05:26.000
これをここに置くと、各製品のアイコンを表示するプレビューの更新を見ることができます。

00:05:26.000 --> 00:05:35.000
ストアビューは、製品識別子とアイコンを機能的でよく設計されたストアに変えることで、簡単に起動して実行するのに役立ちます。

00:05:35.000 --> 00:05:43.000
ストアビューの強力な機能は、当社の製品がさまざまなプラットフォームに自動的に調整されるため、iPad、Mac、Apple Watchで見栄えの良いショップがすでにあります。

00:05:43.000 --> 00:05:57.000
XcodeのターゲットをApple Watchに変更して、ショップをプレビューしましょう。

00:05:57.000 --> 00:05:58.000
美味しそう！

00:05:58.000 --> 00:06:03.000
Apple Watchでも鳥の餌を売る準備ができていると思います。

00:06:03.000 --> 00:06:07.000
あなたの製品に固有の方法で製品を整理したいと思うのが一般的です。

00:06:07.000 --> 00:06:13.000
私たちの鳥のデザイナーチームは、鳥の餌を展示するための構図の作成に懸命に取り組んできました。

00:06:13.000 --> 00:06:20.000
この構成は、最高の価値を目立つように表示し、他の製品を棚に整理します。

00:06:20.000 --> 00:06:28.000
これは、StoreViewで達成できるリストスタイルのレイアウトとは異なりますが、StoreKitではここでも取り上げています。

00:06:28.000 --> 00:06:31.000
より詳細なレイアウトについては、新しいProductViewを利用できます。

00:06:31.000 --> 00:06:38.000
実際、私たちがちょうど見ていたStoreViewは、同じProductViewを使用して行を作成します。

00:06:38.000 --> 00:06:46.000
新しい店舗のコンテナを宣言することから始めましょう。

00:06:46.000 --> 00:06:53.000
栄養ペレットのこの箱は、私たちの最高の価値であるため、他の製品の上に目立つように展示したいと思います。

00:06:53.000 --> 00:07:04.000
これを行うには、栄養ペレットボックスのIDを入力してProductViewを宣言します。

00:07:04.000 --> 00:07:09.000
StoreViewと同様に、末尾のクロージャを追加することで装飾的なアイコンを追加できます。

00:07:09.000 --> 00:07:16.000
以前からヘルパービューを再利用します。

00:07:16.000 --> 00:07:20.000
次に、他の食品について以下のセクションを追加しましょう。

00:07:20.000 --> 00:07:26.000
私は最高の価値の後ろに背景を置くことから始めます...

00:07:26.000 --> 00:07:37.000
その後、棚に私たちの鳥の餌をレイアウトするために作った別のヘルパービューと一緒にヘッダー。

00:07:37.000 --> 00:07:50.000
このシェルフヘルパービューでは、装飾アイコンとともに、各バードフード製品のProductViewを宣言できます。

00:07:50.000 --> 00:07:52.000
この店全体を結びつけるために、最後に1つ必要なものがあります。

00:07:52.000 --> 00:08:00.000
私たちは本当にこの栄養ペレットの箱を顧客に目立つように表示したいと思っていますが、鳥のデザイナーは私たちが今持っているものがより良く見えるかもしれないと考えています。

00:08:00.000 --> 00:08:06.000
鳥をなだめるために、新しいproductViewStyle APIを使用して、主力製品のスタイルを設定できます。

00:08:06.000 --> 00:08:16.000
これを本当に際立たせるために、大きなスタイルを選びます。

00:08:16.000 --> 00:08:24.000
わずか数分で、StoreKitの新しいProductViewを使用して、鳥の餌専用の専門店を建設しました。

00:08:24.000 --> 00:08:31.000
大規模なProductViewスタイルは、1つのビュー修飾子を追加するだけで、最高の価値を目立つように表示するのに役立ちます。

00:08:31.000 --> 00:08:35.000
ニーズに合わせて選択できる3つの標準スタイルがあります。

00:08:35.000 --> 00:08:49.000
コンパクトは、より小さなスペースでより多くの製品を表示するのに役立ちます、私たちの鳥の食べ物の棚は自動的にレギュラースタイルを使用し、そしてもちろん、大きなスタイルは目立つプレゼンテーションに最適です。

00:08:49.000 --> 00:08:58.000
StoreViewはProductViewインスタンスで構成されているため、同じproductViewStyle修飾子を使用してStoreViewのスタイルを変更できます。

00:08:58.000 --> 00:09:03.000
カスタムスタイルを作成し、ProductViewとStoreViewで使用することもできます。

00:09:03.000 --> 00:09:07.000
近くにいて、セッションの後半でその方法をお見せします。

00:09:07.000 --> 00:09:13.000
ProductViewを使用して、消耗品のバードフードのアプリ内購入を提供する素晴らしい方法を構築しました。

00:09:13.000 --> 00:09:22.000
ビジネスバードは、私たちが十分に進んでいないと考えており、彼らは最も熱心なバードウォッチャーのためにバックヤードバードパスと呼ばれるサブスクリプションを提供することを私に課しました。

00:09:22.000 --> 00:09:31.000
ProductViewまたはStoreViewを使用してサブスクリプションUIを構築できますが、新しいSubscriptionStoreViewはサブスクリプション専用に構築されています。

00:09:31.000 --> 00:09:34.000
Xcodeに戻って、これを一緒に構築しましょう。

00:09:34.000 --> 00:09:44.000
始めるために、StoreKitの設定で、3つのレベルのサービスを提供するこの「Backyard Birds Pass」サブスクリプショングループを作成しました。

00:09:44.000 --> 00:09:48.000
このグループIDに注意してください。私たちはすぐにこれが必要になります。

00:09:48.000 --> 00:09:56.000
以前、パスショップの新しいファイルを作ったので、SubscriptionStoreViewに飛び込みましょう。

00:09:56.000 --> 00:10:04.000
SubscriptionStoreViewを起動して実行する最速の方法は、StoreKit設定ファイルまたはApp Store ConnectからグループIDを提供することです。

00:10:04.000 --> 00:10:21.000
すでにグループIDを環境に追加したので、アクセスするための環境プロパティを宣言し、グループIDを入力してSubscriptionStoreViewを宣言することができます。

00:10:21.000 --> 00:10:30.000
StoreViewやProductViewと同様に、SubscriptionStoreViewはデータフローを管理し、さまざまなプランオプションでビューをレイアウトします。

00:10:30.000 --> 00:10:37.000
また、既存の加入者ステータスと、顧客が入門オファーの対象となるかどうかもチェックします。

00:10:37.000 --> 00:10:44.000
この自動外観は素晴らしいですが、これをBackyard Birdsのルックアンドフィールに合わせるために使用できる強力な新しいAPIがいくつかあります。

00:10:44.000 --> 00:10:50.000
たとえば、ヘッダーのマーケティングコンテンツを任意のSwiftUIビューに置き換えることができます。

00:10:50.000 --> 00:10:57.000
先ほどマーケティングコンテンツビューを構築したので、これをここにドロップします。

00:10:57.000 --> 00:11:03.000
また、サブスクリプションストアにコンテナの背景を追加して、物事をより視覚的に面白くすることもできます。

00:11:03.000 --> 00:11:10.000
新しいSwiftUI containerBackground APIを使用できます。

00:11:10.000 --> 00:11:20.000
これをサブスクリプションストアのフルハイトに配置し、以前に作成したビューを空のグラデーションといくつかの雲で宣言する方法に注目してください。

00:11:20.000 --> 00:11:26.000
すべてを結びつけるために、サブスクリプションストアのスタイリングに他のAPIを使用できます。

00:11:26.000 --> 00:11:35.000
デフォルトでは、サブスクリプションストアは、サブスクリプションコントロールとフルハイトの背景の間にマテリアルレイヤーを追加します。

00:11:35.000 --> 00:11:45.000
背景スタイル修飾子を使用して、サブスクリプションコントロールの背後にある背景をクリアにすることができます。

00:11:45.000 --> 00:11:55.000
次に、subscriptionStoreButtonLabelを使用して、サブスクライブボタンの複数行レイアウトを選択します。

00:11:55.000 --> 00:12:01.000
購読ボタンに価格と「無料で試してみる」の両方が含まれていることに注目してください。

00:12:01.000 --> 00:12:12.000
次に、subscriptionStorePickerItemBackgroundを追加して、サブスクリプションオプションの重要な効果を宣言します。

00:12:12.000 --> 00:12:20.000
ここでは、サブスクリプションプランのオプションを通して空のグラデーションが輝くのを見ることができます。

00:12:20.000 --> 00:12:32.000
最後に、サブスクリプションにはオファーコードがあるため、新しいstoreButton修飾子を使用して、コード引き換えボタンを可視として宣言します。

00:12:32.000 --> 00:12:40.000
この1つのビュー修飾子だけで、顧客がオファーコード引き換えシートを開くためのボタンがあります。

00:12:40.000 --> 00:12:45.000
今、私たちのサブスクリプションビューは、裏庭の鳥の残りの部分の感触と一致します。

00:12:45.000 --> 00:12:54.000
これらの新しいビューは、アプリにアプリ内購入を追加するために必要な労力を大幅に削減しますが、見逃している重要な部分がいくつかあります。

00:12:54.000 --> 00:12:59.000
まず、購入後に実際にコンテンツのロックを解除するためのロジックを追加する必要があります。

00:12:59.000 --> 00:13:07.000
次に、誰かがすでに購読しているかどうかを確認し、SubscriptionStoreViewを表示するコントロールを非表示にする必要があります。

00:13:07.000 --> 00:13:20.000
StoreKitビューは、すでに自動的に購読している顧客を処理しますが、多くの場合、最高のエクスペリエンスは、既存の顧客にマーチャンダイジングUIを提示しないことを選択することです。

00:13:20.000 --> 00:13:28.000
StoreKitには、これらの重要な機能をコンテンツを販売するのと同じくらい簡単で楽しいものにするための新しいAPIがいくつかあります。

00:13:28.000 --> 00:13:35.000
これらのAPIを使い始める前に、すでにビジネスロジックを実装しているか、少なくともいくつかの足場を配置したいと思うでしょう。

00:13:35.000 --> 00:13:47.000
更新されたトランザクションを処理し、サーバーと協力し、消耗品の資格を追跡し、UIコードに適したデータモデルを作成していることを確認してください。

00:13:47.000 --> 00:13:56.000
ビジネスロジックの実装の詳細については、「Meet StoreKit 2」と「App StoreサーバーAPIの新機能」をチェックすることをお勧めします。

00:13:56.000 --> 00:14:01.000
私はすでに先に進み、バードブレインと呼ばれる俳優に私たちの鳥のビジネスロジックを実装しました。

00:14:01.000 --> 00:14:04.000
あなたは私がすぐにこれを参照しているのを見るでしょう。

00:14:04.000 --> 00:14:10.000
バードウォッチャーが購入した消耗品の鳥の餌にアクセスできるようにすることから始めましょう。

00:14:10.000 --> 00:14:13.000
StoreKitビューのいずれかからの購入の処理は簡単です。

00:14:13.000 --> 00:14:21.000
onInAppPurchaseCompletionでビューを変更し、購入が完了するたびに呼び出す機能を提供するだけです。

00:14:21.000 --> 00:14:27.000
この方法で任意のビューを変更でき、子孫のStoreKitビューが購入を完了するたびに呼び出されます。

00:14:27.000 --> 00:14:39.000
この修飾子をBirdFoodShopに追加しましょう。

00:14:39.000 --> 00:14:46.000
修飾子は、成功したかどうかにかかわらず、購入した製品と購入結果を提供します。

00:14:46.000 --> 00:14:55.000
これを実装して、成功した結果を処理のためにBirdBrainアクターに送信しましょう。

00:14:55.000 --> 00:15:01.000
この修飾子を追加することで、人々が購入する消耗品の鳥の餌のロックを解除しています。

00:15:01.000 --> 00:15:05.000
シミュレーターでこれを試してみましょう。

00:15:05.000 --> 00:15:10.000
裏庭を選んで、物資を叩きます。

00:15:10.000 --> 00:15:19.000
それから、私はいくつかの栄養ペレットを購入します。

00:15:19.000 --> 00:15:26.000
シートが却下された後、消耗品の在庫に5つの栄養ペレットがあることに気付くでしょう。

00:15:26.000 --> 00:15:34.000
今、私たちは栄養ペレットを置き、私たちのペレットがすべての空腹の鳥を庭に連れて行くように後ろに座ることができます。

00:15:34.000 --> 00:15:43.000
onInAppPurchaseCompletionに加えて、StoreKitビューからイベントを処理するために使用できる関連するビュー修飾子がいくつかあります。

00:15:43.000 --> 00:15:50.000
onInAppPurchaseStartを使用して、誰かが購入ボタンをトリガーしたときに、購入が始まる前に処理できます。

00:15:50.000 --> 00:15:56.000
これは、調光コントロールなど、購入の実行中にいくつかのUIコンポーネントを更新したい場合に便利です。

00:15:56.000 --> 00:16:02.000
ここで提供する機能は、パラメータとして購入される製品を受け取ります。

00:16:02.000 --> 00:16:13.000
これらの修飾子を使用する場合は、子孫のProductView、StoreView、またはSubscriptionStoreViewインスタンスからのイベントを処理することを知っておくことが重要です。

00:16:13.000 --> 00:16:17.000
複数の修飾子を追加すると、イベントごとにすべてのアクションが実行されます。

00:16:17.000 --> 00:16:21.000
これらの修飾子の使用は完全にオプションであることを覚えておいてください。

00:16:21.000 --> 00:16:33.000
デフォルトでは、StoreKitビューからの成功したトランザクションはTransaction.updatesシーケンスから発行されますが、結果を直接処理するためにonInAppPurchaseCompletionを追加するオプションがあります。

00:16:33.000 --> 00:16:38.000
これらの修飾子のいずれかにnilを渡して、デフォルトの動作に戻すことができます。

00:16:38.000 --> 00:16:43.000
では、Backyard Birds Passのサブスクリプションの取り扱いについて話しましょう。

00:16:43.000 --> 00:16:50.000
新しいビューAPIに加えて、StoreKitにはSwiftUIでデータ依存関係を宣言するための新しいビュー修飾子があります。

00:16:50.000 --> 00:16:56.000
まず、パスのロック解除を簡単にするために使用できるsubscriptionStatusTaskをカバーします。

00:16:56.000 --> 00:17:02.000
サブスクリプションに依存する任意のビューでは、subscriptionStatusTask修飾子を追加できます。

00:17:02.000 --> 00:17:14.000
サブスクリプションオファーシートを開くためのボタンが表示されるので、裏庭グリッドから始めましょう。

00:17:14.000 --> 00:17:20.000
subscriptionStatusTask修飾子は、私たちが依存するサブスクリプションのグループIDを取ります。

00:17:20.000 --> 00:17:25.000
これは、以前にSubscriptionStoreViewを宣言したときに使用したのと同じグループIDです。

00:17:25.000 --> 00:17:36.000
これで、Backyard Gridが表示されるたびに、バックグラウンドタスクがサブスクリプションステータスをロードし、タスクが完了したら提供する関数を呼び出します。

00:17:36.000 --> 00:17:55.000
このAPIを使用するためのベストプラクティスは、ステータスをビジネスロジック、私たちの場合はBirdBrainアクターに渡し、アクターにデータを処理させ、UIコードで作業しやすいモデルタイプを返すことです。

00:17:55.000 --> 00:18:07.000
このパスステータス列挙型を作ったので、これを割り当てる州のプロパティを作ります。

00:18:07.000 --> 00:18:18.000
その後、誰かが現在購読していない場合にのみ、サブスクリプションオファーカードを表示することを選択できます。

00:18:18.000 --> 00:18:23.000
これらの迅速な追加により、まだ購読していないバードウォッチャーにのみオファーカードを表示します。

00:18:23.000 --> 00:18:31.000
ステータスが変更されたときにStoreKitは私たちの機能を呼び出しますので、私たちのビューは常に最新の情報を反映します。

00:18:31.000 --> 00:18:44.000
アプリ全体でこの同じパターンを使用してBackyard Birds Passコンテンツのロックを解除することができ、onInAppPurchaseCompletion修飾子を使用して、サブスクリプションが成功した後にパスショップシートを自動的に却下することができます。

00:18:44.000 --> 00:18:55.000
私はすでにこの部分を以前に完了したので、iPhoneシミュレータでアプリを実行して、この全体をテストしてみましょう。

00:18:55.000 --> 00:19:02.000
「Check It Out」をタップして、「無料で試す」を押します。

00:19:02.000 --> 00:19:09.000
支払いシートが表示され、購読をタップし、アラートを閉じることができます。

00:19:09.000 --> 00:19:15.000
オファーシートが自動的に却下され、オファーカードも隠されているのを見てください。

00:19:15.000 --> 00:19:25.000
これは、サブスクリプションステータスタスクがステータスが変更されるたびに関数を再度呼び出すため、アプリのUIが常に最新であることを確認できます。

00:19:25.000 --> 00:19:35.000
このトピックでは、アプリが非消耗品または非更新サブスクリプションを提供している場合、subscriptionStatusTaskと同じくらい簡単に資格を確認するための新しいAPIがあります。

00:19:35.000 --> 00:19:51.000
currentEntitlementTask修飾子を使用して、製品IDの現在のエンタイトルメントに依存するビューを宣言することができ、システムは現在のエンタイトルメントを非同期にロードし、変更されるたびに現在のエンタイトルメントで関数を呼び出します。

00:19:51.000 --> 00:19:59.000
subscriptionStatusTaskとcurrentEntitlementTaskの両方に提供する関数は、エンタイトルメントタスクの状態をパラメータとして取ります。

00:19:59.000 --> 00:20:09.000
そうすれば、エンタイトルメントがまだロードされているとき、ロードに失敗した場合、エンタイトルメントが正常にロードされたときに、ケースを詳細に処理することを選択できます。

00:20:09.000 --> 00:20:15.000
これらの新しいStoreKitビューが、Backyard Birdsでのアプリ内購入の統合を合理化するのにどのように役立つかを取り上げました。

00:20:15.000 --> 00:20:25.000
さて、もう少し深く掘り下げて、SwiftUI用のすべての新しいStoreKit APIを使用して、これらのビューをさらに一歩進める方法を紹介したいと思います。

00:20:25.000 --> 00:20:30.000
まず、ProductViewとStoreViewのアイコンを設定するためのより多くのオプションを見ていきます。

00:20:30.000 --> 00:20:34.000
次に、製品ビューのスタイリングについて詳しく説明します。

00:20:34.000 --> 00:20:41.000
その後、StoreViewとSubscriptionStoreViewに共通の機能を備えたボタンを追加する方法について説明します。

00:20:41.000 --> 00:20:49.000
最後に、サブスクリプションストアビューをブランドのルックアンドフィールに合わせるために使用できるさまざまな新しいAPIについていきます。

00:20:49.000 --> 00:20:51.000
装飾的なアイコンに入りましょう。

00:20:51.000 --> 00:21:00.000
アイコンを指定すると、標準の製品ビュースタイルはすべて、左側に表示されるもののように、製品の読み込み中にプレースホルダアイコンを表示します。

00:21:00.000 --> 00:21:05.000
自動アイコンは、実際のアイコンが期待するものと正確に一致しない場合があります。

00:21:05.000 --> 00:21:13.000
たとえば、iPhoneでは、自動プレースホルダは正方形ですが、バードフード製品には円のアイコンを使用します。

00:21:13.000 --> 00:21:21.000
プレースホルダに使用するアイコンを使用して、ProductViewに2番目のトレーリングクロージャを追加することで、この外観を簡単に改善できます。

00:21:21.000 --> 00:21:25.000
この場合、プレースホルダに円を提供しただけです。

00:21:25.000 --> 00:21:33.000
App Store ConnectでApp Storeプロモーションイメージを設定した場合、ProductViewにSwiftUIビューの代わりに同じイメージを使用させることができます。

00:21:33.000 --> 00:21:38.000
prefersPromotionalIconパラメータをtrueに設定するだけです。

00:21:38.000 --> 00:21:45.000
SwiftUIビューをフォールバックとして提供することはできますが、製品にプロモーションアイコンがある限り、このビューは無視されます。

00:21:45.000 --> 00:21:56.000
プロモーションアイコンの設定方法については、「XcodeでのStoreKit 2とStoreKitテストの新機能」と「App Store Connectの新機能」をご覧ください。

00:21:56.000 --> 00:22:06.000
App Storeのプロモーションアイコンを使用したくなくても、SwiftUIで宣言されたアイコンにクールなアプリ内購入アイコン処理を使用できます。

00:22:06.000 --> 00:22:12.000
アイコンに指定したビューにこの修飾子を追加するだけで、この境界線がビューに追加されます。

00:22:12.000 --> 00:22:15.000
それはすべて製品ビューのアイコンについてです。

00:22:15.000 --> 00:22:22.000
ストアビューアイコンで同じことをすべて行うための対応するAPIもあることを覚えておいてください。

00:22:22.000 --> 00:22:26.000
では、製品ビューのスタイリングについて話しましょう。

00:22:26.000 --> 00:22:33.000
セッションの前半で、カスタム製品ビュースタイルを作成できると述べましたが、ついにその方法をお見せします。

00:22:33.000 --> 00:22:40.000
プロダクトビューの外観、レイアウトの動作、および相互作用は、使用するスタイルによって完全に定義されます。

00:22:40.000 --> 00:22:48.000
したがって、あなたがしようとしているものに合った標準的なスタイルが見つからない場合は、いつでも独自のカスタム製品ビュースタイルを作成できます。

00:22:48.000 --> 00:22:55.000
私たちが検討する最初のケースは、あなたが完全にゼロから始めるわけではないように、標準スタイルで構成されたカスタムスタイルを作成することです。

00:22:55.000 --> 00:23:03.000
たとえば、ロード中に標準のプレースホルダの外観ではなく、製品ビューにプログレススピナーを表示したい場合はどうなりますか?

00:23:03.000 --> 00:23:10.000
カスタムスタイルを作成するための最初のステップは、ProductViewStyleプロトコルに準拠したタイプを作成することです。

00:23:10.000 --> 00:23:15.000
プロトコルを実装するための唯一の要件は、このmakeBodyメソッドです。

00:23:15.000 --> 00:23:23.000
makeBodyメソッドに渡される設定値には、優れた製品ビューを宣言するために必要なすべてのプロパティがあります。

00:23:23.000 --> 00:23:29.000
たとえば、製品のロードのさまざまな状態をカバーする状態列挙があります。

00:23:29.000 --> 00:23:34.000
読み込みの外観をカスタマイズするには、読み込み状態のProgressViewを宣言するだけです。

00:23:34.000 --> 00:23:44.000
次に、構成をProductViewインスタンスに渡すだけで、他の状態の標準ProductView動作にフォールバックできます。

00:23:44.000 --> 00:23:52.000
productViewStyle修飾子に渡すことで、標準スタイルと同じようにカスタムスタイルを適用します。

00:23:52.000 --> 00:23:58.000
もちろん、標準スタイルでカスタムスタイルを構成する必要はありません。 カスタムスタイルを作成する必要はありません。

00:23:58.000 --> 00:24:03.000
makeBodyメソッドの他のビューを使用して、いつでもスタイルを定義できます。

00:24:03.000 --> 00:24:09.000
タスク状態が成功すると、ビューが表しているプロダクト値にアクセスできます。

00:24:09.000 --> 00:24:14.000
これは、アプリがStoreKit 2を使用している場合、すでに作業に慣れているのと同じ製品価値です。

00:24:14.000 --> 00:24:19.000
製品のすべてのプロパティを使用して、ビューを作成できます。

00:24:19.000 --> 00:24:24.000
この設定では、装飾アイコンにアクセスすることもできます。

00:24:24.000 --> 00:24:32.000
購入ボタンを追加するときは、製品値ではなく、設定値で購入方法を使用してください。

00:24:32.000 --> 00:24:47.000
設定でメソッドを使用すると、デフォルトの購入オプションが追加され、支払い確認シートが製品ビューの近くに表示され、onInAppPurchaseCompletionなどのリアクティブ修飾子もトリガーされます。

00:24:47.000 --> 00:24:57.000
覚えておいてください：カスタムスタイルがゼロから構築されている場合、このスタイルを使用する製品ビューの外観と動作は、スタイルを構築するために作成したビューの外観と動作と一致します。

00:24:57.000 --> 00:25:10.000
カスタムスタイルを作成することは、App Storeのデータフローなど、製品ビューのすべてのインフラストラクチャを活用するのに最適な方法ですが、必要な外観や動作を自由に宣言できます。

00:25:10.000 --> 00:25:15.000
読み込み中、バードフードショップ用に作成したUIには、各製品のプレースホルダーの形状が表示されます。

00:25:15.000 --> 00:25:19.000
しかし、右側にこのローディングスピナーのような外観が必要な場合はどうなりますか?

00:25:19.000 --> 00:25:22.000
この問題の解決策は、状態を上げることです。

00:25:22.000 --> 00:25:25.000
ここで私が言いたいことを説明させてください。

00:25:25.000 --> 00:25:30.000
この図は、以前に構築したBirdFoodShopの階層を表しています。

00:25:30.000 --> 00:25:34.000
BirdFoodShopにはいくつかのProductViewの子孫がいます。

00:25:34.000 --> 00:25:42.000
製品IDでProductViewを初期化すると、ロード操作が非同期であるため、各ビューは製品の状態を内部的に保持します。

00:25:42.000 --> 00:25:51.000
製品の読み込み中に親BirdFoodShopが異なる外観を表示するエフェクトを作成する場合は、状態を親のBirdFoodShopに持ち上げる必要があります。

00:25:51.000 --> 00:26:04.000
親のBirdFoodShopが製品の状態を管理したら、データの読み込み中に外観を自由に変更し、IDの代わりにプリロードされた製品値を使用してProductViewインスタンスを作成できます。

00:26:04.000 --> 00:26:14.000
これまでのところ、製品IDによる製品ビューの作成のみを取り上げましたが、すでにロードした製品値をProductViewに渡すことができることを知っておくことが重要です。

00:26:14.000 --> 00:26:19.000
これにより、製品ビューは読み込みをスキップし、マーチャンダイジングビューを直接レイアウトするだけです。

00:26:19.000 --> 00:26:27.000
あなたは考えているかもしれません：それはすべてクールですが、そのためには、今、私は自分の製品要求とキャッシュロジックを書かなければなりません。

00:26:27.000 --> 00:26:38.000
さて、StoreKitビューの内部をビュー修飾子として公開していることを知って喜んでいるので、任意のビューを製品IDのメタデータに依存するものとして宣言できます。

00:26:38.000 --> 00:26:43.000
StoreKitは、製品のロード、キャッシュ、最新の状態に保ちます。

00:26:43.000 --> 00:26:48.000
これを行うには、新しいstoreProductsTask修飾子を使用するだけです。

00:26:48.000 --> 00:26:56.000
先ほど説明したsubscriptionStatusTaskと同様に、ビューが依存する製品IDのコレクションを渡します。

00:26:56.000 --> 00:27:00.000
次に、非同期タスクの状態を処理するために使用できる状態値を取得します。

00:27:00.000 --> 00:27:07.000
カスタムProductViewStyleの実装を見た後、これはすべてかなり身近に感じられるはずです。

00:27:07.000 --> 00:27:12.000
ここから、ロードに関するロードビューを表示できます。

00:27:12.000 --> 00:27:21.000
製品が利用できない場合は、新しいContentUnavailableViewを使用してください。または、プリロードされた製品値でBirdFoodShopを直接表示してください。

00:27:21.000 --> 00:27:23.000
それはとても簡単です。

00:27:23.000 --> 00:27:30.000
簡単に言えば、アプリ内購入マーチャンダイジングUIに含めるいくつかの有用な一般的なアクションがあります。

00:27:30.000 --> 00:27:37.000
StoreViewとSubscriptionStoreViewを使用すると、これらの一般的なアクションの補助ボタンを簡単に追加できます。

00:27:37.000 --> 00:27:44.000
補助ボタンについて話すとき、私はビューの主な目的をサポートするアクションを実行するボタンを意味します。

00:27:44.000 --> 00:27:53.000
たとえば、このキャンセルボタンとコードの引き換えボタンは、どちらもパスの購読に補助的です。

00:27:53.000 --> 00:28:00.000
このシートを最初に作成したときに、storeButton修飾子を使用してコードを引き換えるボタンを追加することをすでに検討しました。

00:28:00.000 --> 00:28:03.000
このビュー修飾子を詳しく見てみましょう。

00:28:03.000 --> 00:28:07.000
ここでは、2つのパラメータのそれぞれに渡すことができる値がいくつかあります。

00:28:07.000 --> 00:28:11.000
最初のパラメータを使用すると、可視性を選択できます。

00:28:11.000 --> 00:28:18.000
自動はすべてのボタンのデフォルトであり、StoreKitはコンテキストに応じてボタンを表示するかどうかを選択します。

00:28:18.000 --> 00:28:23.000
ボタンを明示的に表示または非表示にすることもできます。

00:28:23.000 --> 00:28:29.000
次のパラメータでは、可視性を設定するボタンの種類を選択できます。

00:28:29.000 --> 00:28:34.000
キャンセルボタンには、ビューを閉じるためのプラットフォームに適したボタンが表示されます。

00:28:34.000 --> 00:28:38.000
このボタンは、StoreViewとSubscriptionStoreViewの両方で機能します。

00:28:38.000 --> 00:28:44.000
キャンセルボタンの自動動作は、ビューが表示されるたびに表示されます。

00:28:44.000 --> 00:28:52.000
右側には、サブスクリプションストアビューがシートとして表示され、右上にキャンセルボタンが自動的に表示されます。

00:28:52.000 --> 00:28:58.000
左側では、ビューはシートとして表示されていないため、キャンセルボタンはありません。

00:28:58.000 --> 00:29:04.000
もちろん、この動作をオーバーライドし、表示されたときにキャンセルボタンを非表示にすることもできます。

00:29:04.000 --> 00:29:11.000
キャンセルボタンを独自のキャンセルボタンに置き換える場合にのみ、これを行うことを覚えておいてください。

00:29:11.000 --> 00:29:19.000
プレゼンテーションを閉じるための明確なボタンで、常にマーチャンダイジングUIに付随することをお勧めします。

00:29:19.000 --> 00:29:26.000
キャンセルボタンと同様に、ストアビューとサブスクリプションストアビューの両方で、購入の復元ボタンを表示できます。

00:29:26.000 --> 00:29:35.000
デフォルトでは、[購入の復元]ボタンは常に非表示になっていますが、storeButton修飾子を使用してマーチャンダイジングUIに表示することを選択できます。

00:29:35.000 --> 00:29:40.000
次の3つのボタンの種類は、SubscriptionStoreView専用です。

00:29:40.000 --> 00:29:43.000
redeemCodeボタンについては、すでに話しました。

00:29:43.000 --> 00:29:45.000
次のボタンの種類はサインインボタンです。

00:29:45.000 --> 00:29:56.000
サブスクリプションサービスでユーザーがApp Storeの外で購読できる場合は、既存の加入者がサブスクリプションにアクセスする必要がある場合に備えて、サインインボタンを表示することをお勧めします。

00:29:56.000 --> 00:30:05.000
サインインボタンで知っておくべき重要なことは、新しいsubscriptionStoreSignInAction修飾子を使用してサインインアクションを宣言する必要があることです。

00:30:05.000 --> 00:30:11.000
サインインアクションを設定すると、サインインボタンが自動的に表示されます。

00:30:11.000 --> 00:30:20.000
サインインボタンは、subscriptionStoreSignInActionで宣言した関数を呼び出すだけなので、これをシグナルとして使用してサインインフローを実行できます。

00:30:20.000 --> 00:30:23.000
確認する最後のボタンの種類はポリシーです。

00:30:23.000 --> 00:30:33.000
サブスクリプションオファーと一緒に利用規約とプライバシーポリシーへのリンクを表示したい場合があり、SubscriptionStoreViewはこれが本当に簡単になります。

00:30:33.000 --> 00:30:36.000
通常、ポリシーボタンはデフォルトで非表示になっています。

00:30:36.000 --> 00:30:43.000
storeButton修飾子で表示させると、iOSとMacのサブスクライブコントロールの上に表示されます。

00:30:43.000 --> 00:30:50.000
これらのボタンはコンテナの背景の上に表示されるため、デフォルトのスタイルは背景に対して読みやすくない場合があります。

00:30:50.000 --> 00:31:00.000
subscriptionStorePolicyForegroundStyleを使用して、背景に対して読みやすいポリシーボタンに使用するシェイプスタイルを設定します。

00:31:00.000 --> 00:31:11.000
storeButton修飾子で補助ボタンを設定すると、いくつかの簡単な宣言でマーチャンダイジングUIに強力な機能を追加できます。

00:31:11.000 --> 00:31:18.000
セッションの早い段階で、Backyard Birdsのルックアンドフィールに合わせてサブスクリプションストアビューのスタイルを設定しました。

00:31:18.000 --> 00:31:21.000
さて、これらのスタイルのAPIを詳しく見てみたい。

00:31:21.000 --> 00:31:25.000
まず、コントロールスタイルの選択を見てみましょう。

00:31:25.000 --> 00:31:33.000
自動的に、SubscriptionStoreViewは、マーチャンダイジングするサブスクリプションの種類に基づいてコントロールスタイルを選択します。

00:31:33.000 --> 00:31:40.000
新しいsubscriptionStoreControlStyle修飾子を使用して、サブスクリプションプランに使用するコントロールのスタイルを選択できます。

00:31:40.000 --> 00:31:46.000
たとえば、自動ピッカーではなく、プランごとにボタンを選択できます。

00:31:46.000 --> 00:31:50.000
さまざまなスタイルのコントロールについて話しましょう。

00:31:50.000 --> 00:31:56.000
スタイルを指定しない場合、サブスクリプションストアビューは自動的にコントロールを選択します。

00:31:56.000 --> 00:32:01.000
iPhoneでは、これは複数のプランオプションを持つサブスクリプションのピッカーコントロールです。

00:32:01.000 --> 00:32:05.000
ピッカーコントロールを明示的に選択することもできます。

00:32:05.000 --> 00:32:15.000
iOSとMacでは、目立つピッカーコントロールがあり、サブスクリプションプランのオプションを影と選択リングでより目立つように表示します。

00:32:15.000 --> 00:32:22.000
最後に、ピッカーコントロールの代わりに、各サブスクリプションプランのボタンを表示することを選択できます。

00:32:22.000 --> 00:32:28.000
購読ボタンのトピックでは、ボタンラベルをカスタマイズするために使用できる新しいAPIがあります。

00:32:28.000 --> 00:32:38.000
デフォルトでは、SubscriptionStoreViewには、アクションフレーズと価格情報を含む購読ボタンがボタンの上にキャプションとして表示されます。

00:32:38.000 --> 00:32:50.000
subscriptionStoreButtonLabel修飾子を追加して、ボタンラベルを複数行に変更できます。これにより、価格テキストは別のキャプションとしてではなく、ボタンラベル内に含まれます。

00:32:50.000 --> 00:32:56.000
ボタンラベルのレイアウトをカスタマイズするだけでなく、コンテンツをカスタマイズすることもできます。

00:32:56.000 --> 00:33:03.000
たとえば、アクションフレーズの代わりに、選択したサブスクリプションの表示名を表示するように選択できます。

00:33:03.000 --> 00:33:12.000
このようにコンポーネントをチェーンすることで、レイアウトとコンテンツの両方でボタンラベルの値を作成することもできます。

00:33:12.000 --> 00:33:21.000
ボタンコントロールはピッカーコントロールと同じサブスクライブボタンで構成されているため、同じ修飾子を使用してこれらのボタンをカスタマイズすることもできます。

00:33:21.000 --> 00:33:25.000
たとえば、ラベルに価格のみを表示するように選択できます。

00:33:25.000 --> 00:33:30.000
これは、プランがすべて同じサービスであるが、価格帯が異なる場合に便利です。

00:33:30.000 --> 00:33:38.000
異なるサブスクリプションプランでは、App Store Connectで設定した表示名と説明を使用してコントロールを構築します。

00:33:38.000 --> 00:33:44.000
これらのコントロールをより面白くするために、異なるプランごとに装飾的なビューを追加することを選択できます。

00:33:44.000 --> 00:33:51.000
装飾ビューを追加するには、subscriptionStoreControlIcon修飾子をサブスクリプションストアに追加するだけです。

00:33:51.000 --> 00:33:54.000
修飾子はビュービルダーを取ります。

00:33:54.000 --> 00:34:00.000
ビュービルダーに製品値とSubscriptionInfo値の両方を提供します。

00:34:00.000 --> 00:34:06.000
これらのパラメータを使用すると、プランごとに異なるビューを提供できます。

00:34:06.000 --> 00:34:11.000
これらのアイコンは、サブスクリプションプランにボタンコントロールスタイルを使用する場合にも機能します。

00:34:11.000 --> 00:34:16.000
では、サブスクリプションストアビューにバックグラウンドコンテンツを追加することをもう少し詳しく見てみましょう。

00:34:16.000 --> 00:34:26.000
以前から要約するには、containerBackgroundモディファイアを使用してマーケティングコンテンツを変更することで、サブスクリプションストアにコンテナの背景を追加できます。

00:34:26.000 --> 00:34:34.000
この場合、背景にアクセントカラーのグラデーションを提供し、サブスクリプションストアに配置することを選択します。

00:34:34.000 --> 00:34:41.000
新しいcontainerBackground APIの詳細については、「SwiftUIの新機能」セッションをご覧ください。

00:34:41.000 --> 00:34:45.000
サブスクリプションストアで使用できるいくつかの異なるバックグラウンドプレースメントがあります。

00:34:45.000 --> 00:34:51.000
サブスクリプションストアの配置を使用する場合は、コンテキストに基づいて自動配置を選択します。

00:34:51.000 --> 00:34:58.000
iOSとMacでは、サブスクリプションストアのヘッダーに背景を配置することを明示的に指定できます。

00:34:58.000 --> 00:35:02.000
このプレースメントは、あなたのマーケティングコンテンツの背後にあるものです。

00:35:02.000 --> 00:35:09.000
また、サブスクリプションストアビューのフルハイトの後ろに背景を配置するフルハイトの配置もあります。

00:35:09.000 --> 00:35:18.000
セッションの前半では、Get Backyard Birds Passシートの表示を避けるために、サブスクリプションステータスタスクなどのAPIを使用する方法について議論しました。

00:35:18.000 --> 00:35:29.000
ただし、既存の加入者にサブスクリプションストアビューを表示したい場合があり、加入者にプレミアムプランへのアップグレードを奨励したい場合があります。

00:35:29.000 --> 00:35:41.000
加入者が現在プレミアムよりもサービスレベルの低いプランに加入していることを検出すると、アップグレードをvisibleRelationshipsパラメータとして渡すことで、アップグレードシートを表示できます。

00:35:41.000 --> 00:35:48.000
これは、私たちが望むサブスクリプション関係の任意の組み合わせである可能性があり、誰かが現在購読している場合にのみ効果があります。

00:35:48.000 --> 00:35:58.000
次に、オファーをより効果的にするために、プレミアムプランの利点を説明するために、マーケティングコンテンツに異なるビューを提供することができます。

00:35:58.000 --> 00:36:07.000
subscriptionStatusTaskを使用して、加入者のサービスレベルを追跡し、この情報を使用して顧客に提示するオファーを知ることができます。

00:36:07.000 --> 00:36:10.000
それが私が今日カバーしなければならないすべてです。

00:36:10.000 --> 00:36:16.000
アプリにアプリ内課金アイテムを追加し始めると、すぐに起動して実行できるようにStoreViewを宣言してください。

00:36:16.000 --> 00:36:20.000
よりカスタマイズされたレイアウトが必要な場合は、ProductViewを試してみてください。

00:36:20.000 --> 00:36:26.000
サブスクリプションでは、SubscriptionStoreViewを宣言して、説得力のあるオファーを構築できます。

00:36:26.000 --> 00:36:34.000
そして、物事を次のレベルに引き上げる準備ができたら、新しいビュー修飾子やその他のAPIを試して、これを本当に自分のものにしてください。

00:36:34.000 --> 00:36:46.000
十分なStoreKitとSwiftUIを入手できない場合は、セッションをチェックしてください。「XcodeでのStoreKit 2とStoreKitテストの新機能」と「SwiftUIの新機能」。

00:36:46.000 --> 00:36:50.000
SwiftUI用の新しいStoreKit APIについて学ぶために、今日参加してくれてありがとう。

00:36:50.000 --> 00:36:52.000
ハッピーコーディング!

00:36:52.000 --> 23:59:59.000
。

