WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:16.000
Cyndy: こんにちは、私はCyndyで、Languages and Runtimesチームのコンパイラエンジニアです。

00:00:16.000 --> 00:00:19.000
このセッションでは、マージ可能なライブラリについて会います。

00:00:19.000 --> 00:00:25.000
これは、静的リンカーを搭載したライブラリを構築して配布するための新しいモデルです。

00:00:25.000 --> 00:00:32.000
アプリの構築と実行を高速化するために、マージ可能なライブラリがどのように機能するかを共有します。

00:00:32.000 --> 00:00:38.000
次に、Xcode 15でマージ可能なライブラリを有効にする方法を実演します。

00:00:38.000 --> 00:00:45.000
そして最後に、マージ可能なライブラリを使用する際の考慮事項と推奨するものについて説明します。

00:00:45.000 --> 00:00:51.000
飛び込む前に、静的ライブラリと動的ライブラリの概要を簡単に説明します。

00:00:51.000 --> 00:00:55.000
これは、マージ可能なものの利点を強調します。

00:00:55.000 --> 00:00:59.000
静的ライブラリはオブジェクトファイルのコレクションです。

00:00:59.000 --> 00:01:10.000
ビルド時に、静的リンカーはそれらのライブラリから使用するAPIを見つけ、そのコードをアプリバイナリにコピーします。

00:01:10.000 --> 00:01:15.000
そして、それはコピーされているので、図書館は構築後は必要ありません。

00:01:15.000 --> 00:01:22.000
静的ライブラリのコードが変更された場合、またはより多くのライブラリが使用された場合、ビルド時間の減速が発生します。

00:01:22.000 --> 00:01:30.000
これは、それらがどのようにアーカイブされ、アプリにリンクされているかの結果であり、反復的な構築とデバッグが遅くなります。

00:01:30.000 --> 00:01:35.000
代わりに、動的ライブラリを使用してこれを防ぐことができます。

00:01:35.000 --> 00:01:39.000
動的ライブラリは一般にディリブと呼ばれます。

00:01:39.000 --> 00:01:44.000
これらは、Xcodeのフレームワークターゲットのバイナリファイルタイプです。

00:01:44.000 --> 00:01:48.000
フレームワークのコードは実行可能ファイルにコピーされません。

00:01:48.000 --> 00:01:56.000
むしろ、静的リンカーは、後でのためにライブラリのインストールされたパスをアプリバイナリに記録します。

00:01:56.000 --> 00:02:02.000
Apple SDKにないフレームワークは、アプリバンドルに埋め込む必要があります。

00:02:02.000 --> 00:02:10.000
主な違いは、動的ライブラリが追加または更新されると、静的リンカがコードをコピーする必要がないことです。

00:02:10.000 --> 00:02:13.000
これにより、ビルドが高速化されます。

00:02:13.000 --> 00:02:18.000
しかし、それは実行時にアプリが使用されるときに複雑さを増します。

00:02:18.000 --> 00:02:22.000
これは、動的リンカーが必要な場所です。

00:02:22.000 --> 00:02:29.000
アプリが起動されると、dyldという名前の動的リンカーはフレームワークの依存関係を見つけてロードする必要があります。

00:02:29.000 --> 00:02:34.000
これには、それらのフレームワークが依存するライブラリが含まれます。

00:02:34.000 --> 00:02:42.000
より多く使用されるにつれて、これによりメモリ消費とアプリの起動時間が着実に増加します。

00:02:42.000 --> 00:02:49.000
また、Apple SDKからの依存関係を考慮すると、アプリはしばしば何百ものフレームワークをロードすることができます。

00:02:49.000 --> 00:02:55.000
当社のプラットフォームは、これを考慮するために大幅に最適化されたシステムライブラリを持っています。

00:02:55.000 --> 00:02:59.000
しかし、これはアプリに組み込まれるフレームワークには適用されません。

00:02:59.000 --> 00:03:07.000
要約すると、静的ライブラリと動的ライブラリの使用を決定する際には、いくつかのトレードオフがあります。

00:03:07.000 --> 00:03:19.000
動的ライブラリはビルド時間にほとんど影響を与えませんが、起動時間の影響は顕著ですが、静的ライブラリは起動時間の影響を最小限に抑えますが、ビルド時間にコストがかかります。

00:03:19.000 --> 00:03:25.000
このため、私たちは歴史的にあなたのアプリに最適なものを測定することを推奨してきました。

00:03:25.000 --> 00:03:30.000
マージ可能なライブラリでは、これはもはや必要ありません。

00:03:30.000 --> 00:03:35.000
マージ可能なライブラリは、両方のリンク戦略を最大限に活用します。

00:03:35.000 --> 00:03:42.000
マージ可能なライブラリがパフォーマンスと開発のためにどのように最適化できるかを説明します。

00:03:42.000 --> 00:03:47.000
実行可能ファイルのようなバイナリイメージを考えてみましょう。

00:03:47.000 --> 00:03:51.000
このバイナリが依存するフレームワークは、静的リンカーに与えられます。

00:03:51.000 --> 00:03:55.000
これらの依存関係はマージ可能なライブラリになる可能性があります。

00:03:55.000 --> 00:04:00.000
そして、リンクされた出力はマージされたバイナリになることができます。

00:04:00.000 --> 00:04:03.000
しかし、これらの依存関係をマージ可能にする理由は何ですか?

00:04:03.000 --> 00:04:06.000
これは、それらがどのように構築されているかによって説明できます。

00:04:06.000 --> 00:04:10.000
任意の動的ライブラリはマージ可能として構築できます。

00:04:10.000 --> 00:04:16.000
静的リンカーがライブラリを作成すると、メタデータも生成されます。

00:04:16.000 --> 00:04:21.000
メタデータはバイナリ内にあり、全体のサイズが大きくなります。

00:04:21.000 --> 00:04:29.000
リンク依存関係として使用される場合、リンカーはライブラリを静的ライブラリと同様に扱うことができます。

00:04:29.000 --> 00:04:37.000
メタデータを使用すると、ライブラリのユーザーは、通常の動的ライブラリとして静的にリンクするか、マージするかを選択できます。

00:04:37.000 --> 00:04:46.000
マージされたバイナリ出力は、アプリのような実行可能ファイル、またはフレームワークのような別の動的ライブラリにすることができます。

00:04:46.000 --> 00:04:50.000
マージは、静的ライブラリがどのようにリンクされるかに匹敵します。

00:04:50.000 --> 00:04:55.000
最終的には、ライブラリのセグメントを含むバイナリが残ります。

00:04:55.000 --> 00:04:59.000
そして、その出力バイナリは同じファイルタイプのままです。

00:04:59.000 --> 00:05:03.000
マージはXcode 15で真新しいものです。

00:05:03.000 --> 00:05:07.000
新しく実装された静的リンカーは、これを可能にするものです。

00:05:07.000 --> 00:05:10.000
これは、新しいリンカーオプションを使用して機能します。

00:05:10.000 --> 00:05:15.000
まず、マージするライブラリはオプション-make_mergeableで構築されます。

00:05:15.000 --> 00:05:19.000
これは、メタデータを記録するようにリンカーに指示します。

00:05:19.000 --> 00:05:30.000
次に、マージされたバイナリの場合、リンカーはそのメタデータとライブラリを使用して、オプション-merge_libraryまたは-merge_frameworkで最終出力を生成します。

00:05:30.000 --> 00:05:33.000
Xcodeはこれらの詳細を処理します。

00:05:33.000 --> 00:05:38.000
ただし、ビルドログを検査すると、これらのオプションが適用されていることがわかります。

00:05:38.000 --> 00:05:42.000
しかし、単なるリンクよりもマージの方が良いのはどうですか?

00:05:42.000 --> 00:05:46.000
さて、マージ後のサイズを考えてみましょう。

00:05:46.000 --> 00:05:52.000
まず、ライブラリとそのメタデータは不要で、マージ後に削除できます。

00:05:52.000 --> 00:05:57.000
したがって、唯一の焦点は、マージされたバイナリのサイズです。

00:05:57.000 --> 00:06:02.000
マージすると、リンカはすべてのライブラリで文字列などのコンテンツの重複排除を解除できます。

00:06:02.000 --> 00:06:10.000
たとえば、冗長なシンボル参照、Objective-Cセレクタ、およびobjc_msgsendスタブを削除します。

00:06:10.000 --> 00:06:14.000
これにより、全体的なアプリバンドルが小さくなります。

00:06:14.000 --> 00:06:18.000
最終的なバイナリの画像タイプも同じままです。

00:06:18.000 --> 00:06:24.000
これは、すでにサポートされているリンカーの最適化を適用できることを意味します。

00:06:24.000 --> 00:06:28.000
これはアプリの立ち上げにも良い影響を与えます。

00:06:28.000 --> 00:06:39.000
ロードされるフレームワークが少なくなると、アプリを起動するときに必要な作業とカーネルが削減され、メモリ使用量が削減され、ユーザーを満足させます。

00:06:39.000 --> 00:06:46.000
しかし、コードをライブラリに分離することは、効果的な開発とメンテナンスに不可欠であることを知っています。

00:06:46.000 --> 00:06:50.000
マージ可能なライブラリを使用すると、両方を持つことができます。

00:06:50.000 --> 00:06:55.000
マージ可能なライブラリは、最小限のコードと構成の変更でこれを可能にします。

00:06:55.000 --> 00:06:59.000
そして、これは新しいフレームワークを採用するにつれてうまく拡張されます。

00:06:59.000 --> 00:07:04.000
動的リンクに関する以前の図を再検討しましょう。

00:07:04.000 --> 00:07:11.000
リンカーがメタデータを生成できるため、これらの組み込みフレームワークはすべてマージ可能になる可能性があります。

00:07:11.000 --> 00:07:15.000
他のライブラリの内容をマージするフレームワークを作成できます。

00:07:15.000 --> 00:07:19.000
したがって、埋め込むフレームワークは1つだけです。

00:07:19.000 --> 00:07:26.000
Dyldは、埋め込まれたフレームワーク全体のすべてのセグメントを含む1つのライブラリをロードするだけです。

00:07:26.000 --> 00:07:31.000
このようにして、マージすると、大規模な依存関係チェーンを大幅に簡素化できます。

00:07:31.000 --> 00:07:35.000
それがマージ可能なライブラリが達成できることです。

00:07:35.000 --> 00:07:37.000
それらを有効にする方法について話しましょう。

00:07:37.000 --> 00:07:41.000
Xcodeでライブラリのマージを有効にするには2つの方法があります。

00:07:41.000 --> 00:07:44.000
最も単純な自動マージから始めます。

00:07:44.000 --> 00:07:50.000
次に、マージ可能なものを管理したいときはいつでも、手動マージに入ります。

00:07:50.000 --> 00:07:57.000
デバッグモードでは、マージ可能なライブラリがどのように最適なビルド時間を提供できるかを説明します。

00:07:57.000 --> 00:08:04.000
そしてその後、マージ可能なライブラリにデバッグしてシンボリック化する必要があるときに何を期待するかを共有します。

00:08:04.000 --> 00:08:12.000
自動マージは、組み込みフレームワークターゲットであるすべての直接依存関係をマージするようにビルドシステムに通知します。

00:08:12.000 --> 00:08:15.000
アプリのターゲットで特に便利です。

00:08:15.000 --> 00:08:17.000
見せてあげるよ。

00:08:17.000 --> 00:08:22.000
例として、SwiftとC++ Forestプロジェクトを使っています。

00:08:22.000 --> 00:08:27.000
4つのフレームワークにリンクするアプリターゲットがあります。

00:08:27.000 --> 00:08:31.000
Apple SDKから来ているSwiftUIがあります。

00:08:31.000 --> 00:08:37.000
他の3つ、ForestBuilder、ForestUI、Forestは、プロジェクトに組み込まれています。

00:08:37.000 --> 00:08:42.000
自動マージを有効にすると、3つのフォレストフレームワークがマージ可能になります。

00:08:42.000 --> 00:08:47.000
SwiftUIはシステムライブラリなので、そのまま残っています。

00:08:47.000 --> 00:08:53.000
アプリをリンクしている間、これらのフレームワークはアプリのバイナリに直接マージされます。

00:08:53.000 --> 00:08:59.000
つまり、これらのフレームワークは起動時に必要とされず、ディスクから削除できます。

00:08:59.000 --> 00:09:02.000
Xcodeでこれをオンにする方法を見てみましょう。

00:09:02.000 --> 00:09:09.000
プロジェクト内では、すでにSwiftとC++アプリのターゲットをクリックし、ビルド設定タブに入っています。

00:09:09.000 --> 00:09:13.000
MERGED_BINARY_TYPEのビルド設定を更新する必要があります。

00:09:13.000 --> 00:09:19.000
フィルターテキストボックスを使って検索できます。

00:09:19.000 --> 00:09:23.000
「Create Merged Binary」は、まさに私が更新したいものです。

00:09:23.000 --> 00:09:28.000
これは、設定 MERGED_BINARY_TYPE にマッピングされるオプションです。

00:09:28.000 --> 00:09:32.000
設定をクリックして、その値を自動に更新します。

00:09:32.000 --> 00:09:36.000
そして、それだけです!

00:09:36.000 --> 00:09:40.000
マージ可能なライブラリの設定は、一般的なリンクオプションの下にあります。

00:09:40.000 --> 00:09:47.000
それらは「Linking - Mergeable Libraries」という名前の独自のセクションに便利に表示されます。

00:09:47.000 --> 00:09:54.000
アプリがライブラリのマージを有効にすると、ライブラリのセグメントはアプリのバイナリに直接リンクされます。

00:09:54.000 --> 00:09:59.000
これにより、静的ライブラリと同様のパフォーマンスが得られます。

00:09:59.000 --> 00:10:04.000
しかし、マージ可能なライブラリのエクスポートはアプリに保存されます。

00:10:04.000 --> 00:10:11.000
アプリがシンボルをエクスポートすることは適用されないことが多く、サイズとビルド時間に悪影響を及ぼします。

00:10:11.000 --> 00:10:16.000
これを防ぐには、リンカーオプション-no_exported_symbolsを使用します。

00:10:16.000 --> 00:10:24.000
これは、他のリンカーフラグを「-Wl、-no_exported_symbols」で更新することで、Xcodeで適用できます。

00:10:24.000 --> 00:10:31.000
アプリにアプリ拡張機能のエントリポイントが必要な場合は、これらのシンボルを一覧表示するエクスポートリストを使用して、これを厳密に制御します。

00:10:31.000 --> 00:10:37.000
これは、エクスポートされたシンボルファイルを使用して、同じ一般的なリンクオプションで設定できます。

00:10:37.000 --> 00:10:44.000
これにより、静的リンカーは、デッドコードストリッピングなどのサイズの最適化に最も効果的です。

00:10:44.000 --> 00:10:52.000
それは自動マージでしたが、フレームワークの一部のみをマージする必要がある場合があります。

00:10:52.000 --> 00:10:56.000
Xcodeは手動マージでこれをサポートしています。

00:10:56.000 --> 00:11:02.000
手動マージは、マージするライブラリを指定するためのきめ細かなアプローチです。

00:11:02.000 --> 00:11:06.000
これは、いくつかの依存関係がアプリバンドルにとどまる必要がある場合に便利です。

00:11:06.000 --> 00:11:10.000
検討事項について議論するときは、後で詳しく説明します。

00:11:10.000 --> 00:11:17.000
包括的なターゲットにMERGED_BINARY_TYPE =手動を設定することで有効になります。

00:11:17.000 --> 00:11:24.000
最終的にマージされた製品を構成するライブラリは、MERGEABLE_LIBRARYをYESに設定することで認識されます。

00:11:24.000 --> 00:11:30.000
また、ディスクにとどまるべきライブラリについては、MERGEABLE_LIBRARYのデフォルト設定をNOにしてください。

00:11:30.000 --> 00:11:34.000
SwiftとC++のフォレストプロジェクトに戻ってデモをしましょう。

00:11:34.000 --> 00:11:39.000
自動マージに関連する変更なしに、新しく始めています。

00:11:39.000 --> 00:11:45.000
アプリのターゲットと、それがリンクしている4つのフレームワークがまだあります。

00:11:45.000 --> 00:11:48.000
しかし今、私はテストも検討しています。

00:11:48.000 --> 00:11:52.000
プロジェクトにはXCTestターゲットとサポートフレームワークがあります。

00:11:52.000 --> 00:11:56.000
テストはフォレストフレームワークにも依存します。

00:11:56.000 --> 00:12:01.000
プロジェクトのフレームワーク間では、依存関係はすべて絡み合っています。

00:12:01.000 --> 00:12:13.000
この例では、XCTestターゲットがありますが、プロジェクトでは、同様の外観の依存関係グラフを作成するアプリ拡張機能などのターゲットがあるかもしれません。

00:12:13.000 --> 00:12:20.000
マージ可能なライブラリを活用するために、3つのフォレストフレームワークのアプリの依存関係を分離します。

00:12:20.000 --> 00:12:30.000
アプリに必要なライブラリをマージするフレームワーク、ForestKitを作成しますが、テストの依存性も満たします。

00:12:30.000 --> 00:12:39.000
ForestKitは、私のアプリとテストの両方が依存するマージ可能なライブラリをカプセル化するため、グループライブラリと見なされます。

00:12:39.000 --> 00:12:45.000
手動モードを有効にすると、マージ可能にするフレームワークを明示的に設定します。

00:12:45.000 --> 00:12:51.000
この場合、それはForestBuilder、ForestUI、Forestです。

00:12:51.000 --> 00:12:55.000
これらの依存関係はForestKitにマージされます。

00:12:55.000 --> 00:13:02.000
ライブラリの読み込みを減らすことで、私のアプリは起動時間とバンドルサイズを改善しました。

00:13:02.000 --> 00:13:04.000
Xcodeでこれをオンにしましょう。

00:13:04.000 --> 00:13:10.000
プロジェクトを再起動し、自動マージに使用される設定を削除しました。

00:13:10.000 --> 00:13:14.000
他のフレームワークをマージするフレームワークターゲットを作成することから始めます。

00:13:14.000 --> 00:13:17.000
これは私のグループライブラリ、ForestKitです。

00:13:17.000 --> 00:13:23.000
ターゲットセクションの下部をクリックしてこれを行うことができます。

00:13:23.000 --> 00:13:32.000
テンプレートポップアップのmacOSタブにいて、フィルターテキストボックスを使用してフレームワークテンプレートを見つけます。

00:13:32.000 --> 00:13:39.000
製品名をForestKitに設定し、[完了]をクリックします。

00:13:39.000 --> 00:13:44.000
このフレームワークでは、フォレストテストサポートフレームワークを除くすべてのライブラリをマージしたい。

00:13:44.000 --> 00:13:50.000
しかし、私の依存関係は絡み合っているので、当分の間、それらすべてに対してリンクします。

00:13:50.000 --> 00:13:59.000
これを行うには、「Link Binary with Libraries」ビルドフェーズを更新して、プラス記号を使用してフレームワークを追加します。

00:13:59.000 --> 00:14:11.000
ライブラリのポップアップが表示されたら、Forestフレームワークをクリックし、SHIFTとDOWNキーを押したままにして、Xcodeプロジェクトの他のフレームワークを強調表示します。

00:14:11.000 --> 00:14:15.000
次に、このターゲットで手動マージを有効にする必要があります。

00:14:15.000 --> 00:14:21.000
これを行うには、[ビルド設定]タブに移動し、もう一度「Create Merged Binary」を探します。

00:14:21.000 --> 00:14:26.000
フィルターテキストボックスを使用して「マージ」と入力します。

00:14:26.000 --> 00:14:30.000
今回は、値として「マニュアル」を選択します。

00:14:30.000 --> 00:14:33.000
それは私がグループライブラリのターゲットに設定する必要があるすべてです。

00:14:33.000 --> 00:14:40.000
各フレームワークターゲットのビルド設定に移動して、マージするライブラリを選択できます。

00:14:40.000 --> 00:14:45.000
ターゲットセクションをナビゲートして、フォレストフレームワークから始めます。

00:14:45.000 --> 00:14:49.000
[ビルド設定] タブで、[マージ可能なライブラリのビルド] をクリックできます。

00:14:49.000 --> 00:14:57.000
このオプションはビルド設定 MERGEABLE_LIBRARY にマッピングされ、この値を「はい」に更新します。

00:14:57.000 --> 00:15:07.000
ForestUIとForest Builderにも同じことをする必要があります。

00:15:07.000 --> 00:15:10.000
マージされたForestKitフレームワークの作成が完了しました。

00:15:10.000 --> 00:15:14.000
しかし、私はいくつかの依存関係を更新する必要があります。

00:15:14.000 --> 00:15:23.000
ほとんどの動的ライブラリをカプセル化するフレームワークを作成したので、アプリとテストが他のライブラリではなくForestKitにリンクしていることを確認する必要があります。

00:15:23.000 --> 00:15:32.000
SwiftとC++アプリのターゲットをクリックして、まずアプリを修正します。

00:15:32.000 --> 00:15:38.000
ビルドフェーズタブに戻り、「バイナリをライブラリにリンクする」に戻ります。

00:15:38.000 --> 00:15:41.000
ここで不要なフレームワークを削除します。

00:15:41.000 --> 00:15:49.000
Forestを選択し、SHIFTとUPを保持してForestUIとForestBuilderを収集して削除します。

00:15:49.000 --> 00:15:51.000
最後のステップはテストです。

00:15:51.000 --> 00:15:59.000
XCTestターゲットをクリックし、「バイナリをライブラリとリンクする」の下のビルドフェーズタブに移動します。

00:15:59.000 --> 00:16:07.000
テーブルの名前をクリックして削除して、Forestフレームワークを削除します。

00:16:07.000 --> 00:16:12.000
次に、プラス記号を使用してForestKitを追加します。

00:16:12.000 --> 00:16:19.000
ポップアップが表示されたら、ForestKitをダブルクリックします。

00:16:19.000 --> 00:16:22.000
そして、これは手動マージを設定する方法です。

00:16:22.000 --> 00:16:27.000
SwiftとC++フォレストプロジェクトでは、リリースモードで作業しています。

00:16:27.000 --> 00:16:30.000
これは、ライブラリがマージされ、ディスクから削除されるときです。

00:16:30.000 --> 00:16:41.000
ただし、静的ライブラリのビルド時間の動作と同様に、マージにはビルド時間のオーバーヘッドがあり、開発にコストがかかる可能性があります。

00:16:41.000 --> 00:16:47.000
Xcodeでの反復開発をサポートするために、リンカーはデバッグモードでマージされません。

00:16:47.000 --> 00:16:52.000
ビルドシステムは、代わりにライブラリを再エクスポートするようにリンカーに指示します。

00:16:52.000 --> 00:17:02.000
再エクスポートは、コードの実装を1つの動的ライブラリに実装できるが、別の動的ライブラリに実装されているかのように表示するリンカーオプションです。

00:17:02.000 --> 00:17:13.000
言い換えれば、これは、アプリの拡張機能やテストなど、マージされたターゲットに依存するだけで、すべてのライブラリのAPIに到達できることを意味します。

00:17:13.000 --> 00:17:19.000
これにより、動的ライブラリと同様のビルド時間の利点が得られます。

00:17:19.000 --> 00:17:29.000
起動時に、dyldは、マージされたバイナリから直接来ることを期待するのではなく、再エクスポートされたライブラリへの参照をリダイレクトします。

00:17:29.000 --> 00:17:35.000
つまり、デバッグの場合、マージ可能なライブラリはディスクにとどまります。

00:17:35.000 --> 00:17:40.000
デバッグといえば、マージ可能なライブラリにある可能性のあるシンボルを見てみましょう。

00:17:40.000 --> 00:17:46.000
私は整数を取り込み、その2乗結果を返す関数を持っています。

00:17:46.000 --> 00:17:48.000
これはビルドされるコードです。

00:17:48.000 --> 00:17:52.000
しかし、これはマシンが実行するコードではないことを知っています。

00:17:52.000 --> 00:17:57.000
代わりに、このコードは多くの変換を経ます。

00:17:57.000 --> 00:18:01.000
そのコードでバグを調べる必要があるまで、これはすべて問題ありません。

00:18:01.000 --> 00:18:04.000
これが、Xcodeがシンボリック化をサポートする理由です。

00:18:04.000 --> 00:18:12.000
シンボリック化は、これらの機械命令を元のソースコードに関連付けるプロセスです。

00:18:12.000 --> 00:18:18.000
これは、クラッシュログを理解したり、コードをプロファイリングしてデバッグしたりするのに便利です。

00:18:18.000 --> 00:18:22.000
これはマージされたバイナリでどのように機能しますか?

00:18:22.000 --> 00:18:29.000
マージを有効にしても、ソース位置情報は元のライブラリから保持されます。

00:18:29.000 --> 00:18:33.000
つまり、デバッグの経験は同じままです。

00:18:33.000 --> 00:18:41.000
ただし、スタックトレースのようにライブラリ情報が表示されると、マージされたバイナリへのパスが表示されることを覚えておいてください。

00:18:41.000 --> 00:18:48.000
この情報は、クラッシュログ、Instruments内、およびデバッガに表示されます。

00:18:48.000 --> 00:18:54.000
独自のプロジェクトがマージ可能なライブラリをどのように採用できるかを考慮する時が来ました。

00:18:54.000 --> 00:18:58.000
多くの場合、それらを有効にするには、いくつかのXcode設定が必要です。

00:18:58.000 --> 00:19:01.000
しかし、注目に値するいくつかの要因があります。

00:19:01.000 --> 00:19:06.000
考えるべき重要な5つのトピックを取り上げます。

00:19:06.000 --> 00:19:13.000
まず、マージ可能なライブラリに関する既存の依存関係をどのように処理すべきかから始めます。

00:19:13.000 --> 00:19:18.000
次に、自動リンクとは何か、それがマージ可能なライブラリでどのように機能するかについて説明します。

00:19:18.000 --> 00:19:26.000
また、dlopenやバンドルインターフェイスなどのランタイムルックアップAPIを使用する場合は、いくつかの制限があります。

00:19:26.000 --> 00:19:35.000
マージはXcode 15の静的リンカーによって駆動されるため、それと前任者との重要な違いについて言及します。

00:19:35.000 --> 00:19:42.000
そして、最後の考慮事項は、フレームワークを他の開発者に出荷することに興味がある人々のためのものです。

00:19:42.000 --> 00:19:48.000
ライブラリの依存関係については、ディルドの仕事を示す図に戻りましょう。

00:19:48.000 --> 00:20:03.000
マージ可能なライブラリの依存関係（たとえば、他の実行可能ファイルなど）がある場合は、マージ可能なライブラリがディスクから削除されるため、マージされたフレームワークに依存するように更新する必要があります。

00:20:03.000 --> 00:20:07.000
これが出てくるもう1つの方法は、アプリが自動リンクに依存している場合です。

00:20:07.000 --> 00:20:11.000
自動リンクは、デフォルトでオンになっているコンパイラオプションです。

00:20:11.000 --> 00:20:19.000
コンパイラがソースコードでモジュールのインポートを見つけると、フレームワークの依存関係を検出してリンカーに渡します。

00:20:19.000 --> 00:20:27.000
したがって、マージ可能なライブラリからモジュールをインポートする場合、動的リンクの問題が発生する可能性があります。

00:20:27.000 --> 00:20:30.000
ただし、自動リンクを無効にする必要はありません。

00:20:30.000 --> 00:20:37.000
ここでの解決策は以前と同じです。マージされたフレームワークに対するリンクです。

00:20:37.000 --> 00:20:47.000
これを行う最も一般的な方法は、「ライブラリとバイナリをリンクする」ビルドフェーズにマージされたフレームワークを追加し、すでにある場合はマージ可能なフレームワークを削除することです。

00:20:47.000 --> 00:20:54.000
そうしないと、dyldはアプリに適したフレームワークを読み込むことができません。

00:20:54.000 --> 00:20:59.000
ほとんどの開発者は、dlopenのような動的リンクAPIを使用する必要はありません。

00:20:59.000 --> 00:21:07.000
しかし、その場合、これらの入力パスもマージされたフレームワークターゲットを指す必要があります。

00:21:07.000 --> 00:21:12.000
同様に、リソースの検索はライブラリのマージによって影響を受ける可能性があります。

00:21:12.000 --> 00:21:15.000
これは、ランタイムが期待していることのためです。

00:21:15.000 --> 00:21:21.000
Swiftでは、bundleはランタイムがフレームワークのバンドルをロードするためのAPIです。

00:21:21.000 --> 00:21:26.000
Objective-Cの同等のAPIは、NSBundleのbundleForClassです。

00:21:26.000 --> 00:21:35.000
これらのAPIは、バンドルの構造を考慮することなく、フレームワークのリソースを操作するために使用されます。

00:21:35.000 --> 00:21:47.000
iOS 12までは、ランタイムはバンドルを発見するためにフレームワークのバイナリが必要でしたが、マージ可能なフレームワークには、プロセスが実行されるまでにバイナリはありません。

00:21:47.000 --> 00:21:48.000
朗報！

00:21:48.000 --> 00:21:52.000
iOS 12では、このシナリオのルックアップを可能にするフックが追加されました。

00:21:52.000 --> 00:22:03.000
つまり、バンドルルックアップサポートに依存している場合は、マージ可能なライブラリを使用するには、最小展開バージョンをiOS 12以降に更新する必要があります。

00:22:03.000 --> 00:22:11.000
しかし、これらのAPIに依存しない場合は、新しいリンカーオプション-no_merged_libraries_hookでこのサポートを無効にすることができます。

00:22:11.000 --> 00:22:15.000
そうすれば、アプリのデプロイバージョンを更新する必要はありません。

00:22:15.000 --> 00:22:22.000
バンドルリソースを含まないフレームワークをマージする場合は、バンドルフックも必要ないかもしれません。

00:22:22.000 --> 00:22:29.000
その場合は、起動時間のパフォーマンスを向上させるために、とにかくこのオプションを追加することを検討する必要があります。

00:22:29.000 --> 00:22:33.000
この講演を通して、私はいくつかの新しいリンカーオプションについて言及しました。

00:22:33.000 --> 00:22:37.000
これらのオプションは、新しく実装されたリンカーでのみ機能します。

00:22:37.000 --> 00:22:43.000
しかし、ツールチェーンの中を覗くと、2つの静的リンカーがあることに気付くでしょう。

00:22:43.000 --> 00:22:47.000
古いリンカーは、下位互換性のためにまだサポートされています。

00:22:47.000 --> 00:22:54.000
最も注目すべきは、そのリンカはまだarmv7k用に構築できますが、新しいリンカはそうではありません。

00:22:54.000 --> 00:22:59.000
armv7kアーキテクチャをサポートする最後のプラットフォームはwatchOS 8でした。

00:22:59.000 --> 00:23:08.000
watchOS 8以前に展開する必要がない場合は、展開バージョンをwatchOS 9にアップグレードして、新しいリンカーを使用してください。

00:23:08.000 --> 00:23:17.000
アプリでマージ可能なライブラリを構築して使用する方法を説明しましたが、他の人が使用できるようにマージ可能なライブラリを出荷したい場合はどうなりますか?

00:23:17.000 --> 00:23:23.000
これを行うには、Swift Package ManagerまたはXcodeでXCFrameworkを作成できます。

00:23:23.000 --> 00:23:29.000
これにより、配布用のメタデータを含むフレームワークを構築できます。

00:23:29.000 --> 00:23:34.000
他の開発者がフレームワークを使用する場合、マージを有効にするかどうかを決定できます。

00:23:34.000 --> 00:23:38.000
マージ可能なメタデータは、dylibのサイズの約2倍になります。

00:23:38.000 --> 00:23:46.000
アプリを構築した後、メタデータはマージ可能なライブラリとともに破棄されるため、これはアプリのサイズには影響しません。

00:23:46.000 --> 00:23:53.000
そうでなければ、そのメタデータはアプリに埋め込むときに肥大化を防ぐために削除されます。

00:23:53.000 --> 00:23:56.000
マージ可能なライブラリにいくつかのニュアンスを説明しました。

00:23:56.000 --> 00:23:59.000
今、私たちの推奨事項を共有します。

00:23:59.000 --> 00:24:05.000
マージされたバイナリへの依存関係を設定することは、シームレスに採用するための鍵です。

00:24:05.000 --> 00:24:09.000
これは、リンクの依存関係に必要です。

00:24:09.000 --> 00:24:16.000
スクリプトフェーズでバイナリを期待するツールにライブラリをフィードする場合は特に重要です。

00:24:16.000 --> 00:24:20.000
静的リンカーは、直接的な依存関係のみをマージします。

00:24:20.000 --> 00:24:27.000
したがって、より多くのマージ可能なライブラリを含めるには、明示的なリンク依存関係として設定する必要があります。

00:24:27.000 --> 00:24:33.000
マージの設定は、フレームワークのバイナリをディスクから削除するようにXcodeビルドシステムに指示します。

00:24:33.000 --> 00:24:40.000
これは意図的でない場合は副作用を引き起こすので、Xcodeのターゲットレベルで有効にすることをお勧めします。

00:24:40.000 --> 00:24:52.000
そして最後に、パフォーマンスを最適化しながら生産性の最大の利益を得るには、動的にマージ可能な静的ライブラリの更新を検討してください。

00:24:52.000 --> 00:24:56.000
マージ可能なライブラリは、利便性と柔軟性を提供します。

00:24:56.000 --> 00:25:06.000
自動ワークフローと手動ワークフローの間で、余暇にマージ可能なライブラリを再構築して追加し、必要なライブラリをディスクに残すことができます。

00:25:06.000 --> 00:25:11.000
この柔軟性は、徐々に採用またはプロファイリングする場合に役立ちます。

00:25:11.000 --> 00:25:20.000
マージ可能なライブラリは、フレームワークと実行可能ターゲットに適用すると、サイズ、ビルド、およびランタイムの改善を提供します。

00:25:20.000 --> 00:25:27.000
自動設定を使用して、ビルドシステムにすべての直接フレームワークの依存関係をマージさせることができます。

00:25:27.000 --> 00:25:34.000
しかし、マージする依存関係を選択して選択する必要がある場合、これは手動モードで行うことができます。

00:25:34.000 --> 00:25:47.000
そして最後に、マージ可能なライブラリを使用するようにプロジェクトを更新するときは、それらのライブラリのすべての依存者が、削除されるライブラリではなく、マージされたバイナリに依存していることを確認してください。

00:25:47.000 --> 00:25:53.000
マージ可能なライブラリに関するドキュメントについては、「マージ可能なライブラリを使用するようにプロジェクトを設定する」を参照してください。

00:25:53.000 --> 00:26:01.000
また、静的および動的リンクの詳細については、セッション「高速リンク：ビルドと起動時間の改善」をチェックしてください。

00:26:01.000 --> 00:26:06.000
マージ可能なライブラリがプロジェクトでどのように使用されるかを学ぶことに興奮しています。

00:26:06.000 --> 23:59:59.000
参加してくれてありがとう。 

