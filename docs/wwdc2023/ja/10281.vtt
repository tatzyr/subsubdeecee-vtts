WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:11.000
スペンサー:みなさん、こんにちは。

00:00:11.000 --> 00:00:13.000
私の名前はスペンサー・ルーソンです。

00:00:13.000 --> 00:00:21.000
今日は、ここ数年でキーボードがどのように変化したか、そして「キーボードに合わせる」ようにアプリをデザインする方法についてお話ししたいと思います。

00:00:21.000 --> 00:00:29.000
ご存知のように、iPhoneのキーボードはもともと2007年に導入され、それ以来大幅に進化してきました。

00:00:29.000 --> 00:00:35.000
現在、多くの異なる言語をサポートしており、それぞれがレイアウトのサイズが異なる場合があります。

00:00:35.000 --> 00:00:39.000
そしてもちろん、キーボードは多くの異なるデバイスにも搭載されています。

00:00:39.000 --> 00:00:50.000
しかし、キーボードがどのように進化したかと同じように、システムはマルチタスクやフローティングキーボードなどのエキサイティングな機能を追加し、キーボードがアプリの境界を超越できるようにしました。

00:00:50.000 --> 00:00:56.000
昨年、iPadでまったく新しいレベルの生産性を解き放つStage Managerを導入しました。

00:00:56.000 --> 00:01:03.000
複数のシーンが複数のディスプレイで実行されるようになったため、ハードウェアキーボードとマウスの使用はこれまで以上に魅力的になりました。

00:01:03.000 --> 00:01:14.000
だからこそ、今日は、キーボードの再構築でこの多種多様なキーボードシナリオを可能にする方法と、それがアプリにどのように影響するかについてお話ししたいと思います。

00:01:14.000 --> 00:01:23.000
また、できるだけ少ない労力で、可能な限りキーボードとシームレスに動作するようにアプリを設計するためのヒントやコツを共有したいと思います。

00:01:23.000 --> 00:01:29.000
そして最後に、テキスト入力の世界でいくつかのエキサイティングな新機能を紹介したいと思います。

00:01:29.000 --> 00:01:32.000
では、新しいアウトオブプロセスキーボードについて話しましょう。

00:01:32.000 --> 00:01:39.000
アプリのプロセスからキーボードを取り外すと、セキュリティを向上させ、ユーザーが入力したもののプライバシーを確保することができます。

00:01:39.000 --> 00:01:48.000
また、複数のアプリで実行されている複数のインスタンスではなく、キーボードが1つしかないため、アプリやシステム全体のメモリを解放します。

00:01:48.000 --> 00:01:54.000
そして、この新しいアーキテクチャにより、将来に向けて設計し、エキサイティングな新機能を実装することができます。

00:01:54.000 --> 00:01:57.000
それでは、それがどのように機能するかについて少し話しましょう。

00:01:57.000 --> 00:02:03.000
iOS 17以前は、キーボードのビューとロジックはアプリプロセス内で実行されていました。

00:02:03.000 --> 00:02:10.000
しかし、iOS 17のiPhoneでは、キーボードは独自のプロセスに移行され、アプリの外でほぼ完全に実行されています。

00:02:10.000 --> 00:02:18.000
これらすべてがどのように機能するかをお見せできることに興奮していますが、まず、違いがわかるように、その過程でどのように機能するかについて話しましょう。

00:02:18.000 --> 00:02:31.000
処理中、アプリは、タッチに応答してbeonFirstResponderを呼び出すなど、最初にキーボードを要求し、これはすべてのビューを初期化するための一連の同期作業を開始します。

00:02:31.000 --> 00:02:37.000
それが完了すると、システムはキーボードを呼び出すためにアニメーションを実行します。

00:02:37.000 --> 00:02:48.000
その後、アプリはアイドル状態になるか、タッチイベントが入り、テキスト挿入が生成されるまで、アプリサイドワークを実行します。

00:02:48.000 --> 00:02:52.000
プロセス外では、これは少し違った方法で機能するようになりました。

00:02:52.000 --> 00:03:04.000
アプリがキーボードを要求すると、beonFirstResponderを呼び出すなど、アプリはいくつかの初期計算を実行し、キーボードプロセスはUIを非同期に初期化します。

00:03:04.000 --> 00:03:08.000
その間、アプリはアイドル状態になるか、アプリのサイドワークを実行します。

00:03:08.000 --> 00:03:14.000
準備ができたら、キーボードを上げて、2つのプロセス間でアニメーションを調整します。

00:03:14.000 --> 00:03:23.000
キーボードUIが起動したので、キーボードの範囲内で発生するタッチイベントを待ち、アプリのテキスト挿入に変換します。

00:03:23.000 --> 00:03:29.000
ほとんどのアプリでは、これらの変更は完全に透明であり、あなたからの採用を必要としません。

00:03:29.000 --> 00:03:36.000
しかし、この新しい非同期アプローチの側面は現在、キーボード全体に存在し、タイミングにわずかな違いをもたらす可能性があります。

00:03:36.000 --> 00:03:46.000
したがって、アプリがテキスト入力、選択の変更、またはその他のテキスト関連の操作のタイミングに特に敏感な場合は、この新しいアーキテクチャを念頭に置いておく必要があります。

00:03:46.000 --> 00:03:56.000
iOSでのタイピングの多様性について少しお話ししたので、アプリを設計する際に考慮すべき比較的新しいシナリオについて話しましょう。

00:03:56.000 --> 00:04:02.000
もちろん、私たちは皆、最も一般的なユースケースに精通しています。キーボード付きのフルスクリーンアプリです。

00:04:02.000 --> 00:04:15.000
これは、アプリとキーボードの両方がフルスクリーンである比較的簡単なユースケースであり、キーボードの調整は、たまたまキーボードの高さである値でビューを上に移動するのと同じくらい簡単です。

00:04:15.000 --> 00:04:20.000
しかし、ステージマネージャーでは、システムはそのモデルから遠ざかっています。

00:04:20.000 --> 00:04:24.000
高度なマルチタスクでは、アプリは必ずしもフルスクリーンであるとは限りません。

00:04:24.000 --> 00:04:30.000
つまり、キーボードが起動すると、アプリのビューを正しく調整するために特別な注意を払う必要があります。

00:04:30.000 --> 00:04:34.000
それは、キーボードのシーンとアプリのシーンが並ばなくなったからです。

00:04:34.000 --> 00:04:40.000
そして、そのコンテキストに合わせてアプリを適切に調整するために、いくつかの追加の変換を行う必要があります。

00:04:40.000 --> 00:04:51.000
たとえば、このシナリオでは、アプリの調整は実際にはYではなく、キーボードの高さであり、キーボードとアプリの交差によって調整する必要があります。

00:04:51.000 --> 00:05:01.000
そして今、画面上に複数のシーンがあり、それぞれが異なる計算と調整が必要なため、計算するための単一の調整さえないかもしれません。

00:05:01.000 --> 00:05:05.000
ハードウェアキーボードで最近導入されたシナリオもあります。

00:05:05.000 --> 00:05:10.000
ハードウェアキーボードが接続されると、システムは画面の中央にアシスタントツールバーを表示します。

00:05:10.000 --> 00:05:17.000
このフルサイズのツールバーが存在する場合、キーボードの一部として機能するため、ビューを邪魔にならないように調整する必要があります。

00:05:17.000 --> 00:05:20.000
フリックジェスチャーを使用すると、このツールバーを最小化することもできます。

00:05:20.000 --> 00:05:29.000
ステージマネージャーの外では、このミニツールバーがキーボードの一部として機能せず、ビューと重なる既存の動作を保持しています。

00:05:29.000 --> 00:05:34.000
ユーザーは、ツールバーを画面の反対側にドラッグすることで、下のコンテンツにアクセスできます。

00:05:34.000 --> 00:05:49.000
ただし、ステージマネージャーでは、ミニツールバーがキーボードの一部として機能し、ユースケースに応じて、スクロールオフセットを更新したり、入力アクセサリビューを押し上げたり、必要に応じて他のレイアウト調整を行うことができます。

00:05:49.000 --> 00:05:57.000
さて、私たちはここで説明すべき多くのシナリオとニュアンスがあることを知っていますが、良いニュースは、適切なAPIがあれば、システムがあなたのためにほとんどの仕事をするということです。

00:05:57.000 --> 00:06:00.000
では、キーボードレイアウトガイドについて話しましょう。

00:06:00.000 --> 00:06:05.000
iOS 15で導入されたキーボードレイアウトガイドに精通しているかもしれません。

00:06:05.000 --> 00:06:11.000
キーボードを自動的に調整する簡単な自動レイアウトガイドを提供し、昨年追加してきました。

00:06:11.000 --> 00:06:17.000
実際、現在、SpotlightやMessagesなどの複雑なAppleアプリで使用されています。

00:06:17.000 --> 00:06:25.000
採用は、ビューとガイドの間に制約を追加するために1行と同じくらい簡単にできるため、推奨されるアプローチです。

00:06:25.000 --> 00:06:28.000
さて、これがあなたに何を得るかについて正確に話しましょう。

00:06:28.000 --> 00:06:35.000
既存のデフォルトの動作は次のとおりです。キーボードレイアウトガイドは、キーボードが画面に表示され、ドッキングされたときにキーボードに従います。

00:06:35.000 --> 00:06:39.000
つまり、キーボードが画面の下部に触れているときです。

00:06:39.000 --> 00:06:46.000
iPadに浮かんでいるときなど、キーボードがドッキングされていない場合、ガイドの高さはビューの下部の安全な領域と一致します。

00:06:46.000 --> 00:06:53.000
最後に、ガイドは、タッチポイントがガイドと交差すると、キーボードの閉じるジェスチャーを追跡します。

00:06:53.000 --> 00:07:01.000
あなたが望む正確な動作を得るためにこれらを変更できるように、iOS 17のカスタマイズオプションを拡張したことをお伝えできることを嬉しく思います。

00:07:01.000 --> 00:07:05.000
現在、UIKeyboardLayoutGuideには3つのプロパティがあります。

00:07:05.000 --> 00:07:07.000
まず、UndockedKeyboardに従います。

00:07:07.000 --> 00:07:13.000
デフォルトでは、ガイドはフローティングキーボードまたはミニツールバーをオフスクリーンキーボードと同じように扱います。

00:07:13.000 --> 00:07:21.000
ただし、trueに設定すると、ガイドは、アプリのウィンドウ上にある限り、フローティングされていてもキーボードをたどり続けます。

00:07:21.000 --> 00:07:24.000
次はuseBottomSafeエリアです。

00:07:24.000 --> 00:07:29.000
デフォルトでは、キーボードレイアウトガイドは、キーボードが却下されたときに安全な領域の高さを追跡します。

00:07:29.000 --> 00:07:37.000
しかし、falseに設定すると、useBottomSafeAreaは代わりにビューの下部を追跡します。この場合は画面の下部です。

00:07:37.000 --> 00:07:39.000
これはいつ役に立ちますか?

00:07:39.000 --> 00:07:50.000
さて、これにより、キーボードが却下されたときに画面の下部を覆うように背景を拡張し、キーボードが取り上げられたときに調整することができ、InputAccessoryViewと同様に動作します。

00:07:50.000 --> 00:07:56.000
そして実際、それはこのプロパティにとって本当に興味深いユースケースなので、それがどのように機能するかについて話しましょう。

00:07:56.000 --> 00:08:07.000
これは、下部の安全な領域の上にとどまるテキストフィールドと、キーボードが却下されたときにのみビューの下部まで伸びる背景を持つ、そのシンプルな入力アクセサリーのようなビューを取得するコードです。

00:08:07.000 --> 00:08:13.000
注：この場合は興味深いものなので、ここでは垂直方向の制約のみを扱います。

00:08:13.000 --> 00:08:17.000
まず、usesBottomSafeAreaをfalseに設定しましょう。

00:08:17.000 --> 00:08:25.000
次に、テキストフィールドの上部を背景の上部に結び付け、2つの間のシステム間隔を使用して、少しパディングを与えましょう。

00:08:25.000 --> 00:08:33.000
次に、少なくともシステム間隔で、ガイドの上部をテキストフィールドの下部に制限することで、テキストフィールドが常にキーボードの上にあることを確認してください。

00:08:33.000 --> 00:08:35.000
より大きいことがここで重要です。

00:08:35.000 --> 00:08:42.000
キーボードが画面外にある場合、テキストフィールドは、下部の安全な領域のインセットの上にとどまるのに十分な柔軟性が必要になります。

00:08:42.000 --> 00:08:46.000
また、ガイドの上部アンカーを背景の下部に結び付けましょう。

00:08:46.000 --> 00:08:54.000
これにより、ガイドがオフスクリーンのときに背景が下まで続くことが保証されますが、useBottomSafeAreaをfalseに設定したためです。

00:08:54.000 --> 00:08:59.000
最後に、下部のセーフ領域をテキストフィールドの下部とシステム間隔に制限します。

00:08:59.000 --> 00:09:05.000
そして再び、私たちはここで制約よりも大きなものを使用して、キーボードが出てきたときにキーボードに従うのに十分な柔軟性があることを確認しています。

00:09:05.000 --> 00:09:20.000
そして、それに伴い、ビューの一番下まで伸びる背景を持つアダプティブビューがありますが、入力アクセサリビューのように、キーボードの上にテキストフィールドシステムの間隔を保ち、キーボードの上部の背景を保つように調整します。

00:09:20.000 --> 00:09:23.000
第三に、キーボードディスミスパディングがあります。

00:09:23.000 --> 00:09:27.000
これにより、スクロールのパラメータが調整されます。

00:09:27.000 --> 00:09:37.000
過去にキーボードレイアウトガイドを使用してInputAccessoryのようなビューを作成しようとしたことがあるなら、タッチがキーボードと交差するまでキーボードの閉じるジェスチャーが始まらないことに気づいたかもしれません。

00:09:37.000 --> 00:09:40.000
この新しいプロパティを使ってそれを修正しましょう。

00:09:40.000 --> 00:09:47.000
keyboardDismissPaddingプロパティを使用すると、キーボードの閉じるジェスチャーに応答するキーボードの上にあるパディングを指定できます。

00:09:47.000 --> 00:09:49.000
これは比較的簡単です。

00:09:49.000 --> 00:09:53.000
あなたが望むようにあなたのビューの高さをつかみ、プロパティを設定するだけです。

00:09:53.000 --> 00:09:55.000
完了。

00:09:55.000 --> 00:10:00.000
これで、タッチがビューと交差すると、キーボードの却下ジェスチャーが始まります。

00:10:00.000 --> 00:10:03.000
もちろん、アプリが構築されているフレームワークはUIKitだけではありません。

00:10:03.000 --> 00:10:05.000
SwiftUIもあります。

00:10:05.000 --> 00:10:09.000
幸いなことに、SwiftUIは一般的なケースを自動的に処理します。

00:10:09.000 --> 00:10:18.000
SwiftUIでは、キーボードはセーフエリアの一部として含まれており、キーボードが却下されると、画面の下部にある小さなホームアフォーダンスを追跡します。

00:10:18.000 --> 00:10:27.000
キーボードが起動すると、システムは安全領域をアニメーション化して調整し、ビューのサイズを自動的に変更するので、書くキーボードコードはまったくありません。

00:10:27.000 --> 00:10:33.000
ただし、ビューが必要に応じてサイズ変更または再配置されていることを確認するために、レイアウトの作業を行う必要があるかもしれません。

00:10:33.000 --> 00:10:41.000
SwiftUIには、私がリストアップできる以上の素晴らしいリソースがたくさんあるので、これについてもっと知るには、以下にリンクされているドキュメントをご覧ください。

00:10:41.000 --> 00:10:46.000
さて、キーボード、キーボード通知を統合するより手動的な方法について話しましょう。

00:10:46.000 --> 00:11:02.000
SwiftUIとキーボードレイアウトガイドの前に、キーボードをアプリケーションに統合する唯一の方法は、一連のキーボード通知（willShow、didShow、willHide、didHide）をリッスンし、通知のフレームとアニメーション情報に基づいてレイアウトを手動で調整することでした。

00:11:02.000 --> 00:11:08.000
これらはまだありますが、システムがあなたのために仕事をしていないので、より慎重な取り扱いが必要です。

00:11:08.000 --> 00:11:16.000
そして、ステージマネージャーの導入により、そのハンドリングが100%機能しなくなったため、一般的に使用されるパターンの増加に気付きました。

00:11:16.000 --> 00:11:25.000
このパターンは通常、キーボード通知を受信し、キーボードの高さから生の値を直接使用することに重点を置いています。

00:11:25.000 --> 00:11:31.000
先ほど、キーボードの高さと画面上のアプリの位置がどのように相互作用するかのニュアンスについて話し合っていたときのことを覚えていますか?

00:11:31.000 --> 00:11:34.000
これが通知でどのように機能するかについて話し合いましょう。

00:11:34.000 --> 00:11:40.000
各通知は、画面座標に対するキーボードの予想されるフレームを指定します。

00:11:40.000 --> 00:11:51.000
アプリがフルスクリーンの場合など、画面の座標空間とアプリの座標空間が一致する場合、通知に含まれる生の高さの値は、たまたまビューが期待どおりに調整されます。

00:11:51.000 --> 00:11:59.000
ただし、画面の座標空間とアプリの座標空間が異なる場合、この生の高さ値はビューを調整するための正しい値ではなくなります。

00:11:59.000 --> 00:12:04.000
これにより、あなたのビューがあまりにも高く押され、間違った場所に表示される可能性があります。

00:12:04.000 --> 00:12:11.000
幸いなことに、物事を再びスムーズに機能させるために、通知処理にいくつかの変更を加えることができます。

00:12:11.000 --> 00:12:18.000
iOS 16.1では、キーボード通知は対応するUIScreenを通知のオブジェクトとして含め始めました。

00:12:18.000 --> 00:12:26.000
まず、キーボードがアプリと同じ画面に表示されていることを確認しましょう。そうしないと、調整は必要ありません。

00:12:26.000 --> 00:12:31.000
次に、ビューに対するキーボードの配置を表すrectを計算しましょう。

00:12:31.000 --> 00:12:43.000
これを行うには、キーボードの期待されるエンドフレーム、通知とビューによって提供される座標空間を取得し、それらを使用してkeyboardFrameEndを座標空間に変換します。

00:12:43.000 --> 00:12:53.000
この新しいrectを使用すると、ビューと変換されたKeyboardFrameEndの交差を計算することで、ビューに必要なオフセットを決定できます。

00:12:53.000 --> 00:13:02.000
ビューとキーボードが重なっている場合、必要なオフセットは、ビューとキーボードの間の交差の高さになります。

00:13:02.000 --> 00:13:06.000
それにより、制約やレイアウトを好きなように調整できます。

00:13:06.000 --> 00:13:13.000
さて、新しいプロセスアーキテクチャでは、知っておくべき通知の動作に小さな変化があるかもしれません。

00:13:13.000 --> 00:13:15.000
では、少し時間を取ってそれについて話しましょう。

00:13:15.000 --> 00:13:19.000
キーボードプロセスのライフサイクルを概説したこの図を覚えていますか?

00:13:19.000 --> 00:13:24.000
「アニメーションを育成する」と呼ばれるアニメーションフェーズにズームインしましょう。

00:13:24.000 --> 00:13:34.000
インプロセスアーキテクチャでは、アプリがキーボードを要求すると、システムはキーボードUIを同期的に初期化し、通知を投稿し、アニメーションを実行します。

00:13:34.000 --> 00:13:46.000
ただし、新しいプロセス外アーキテクチャでは、アプリがキーボードを要求すると、システムはキーボードUIを非同期に初期化し、非同期に通知を投稿してアニメーションを実行します。

00:13:46.000 --> 00:14:06.000
これにより、タイミングにわずかな違いがあるため、アプリがbeonFirstResponderを呼び出すことからある種の「コールバック」として通知のタイミングに依存している場合、または通知の処理が遅れる可能性のあるメインスレッドで重要な作業を行っている場合は、アプリに影響を与える可能性があるため、この新しいモデルを念頭に置いておく必要があります。

00:14:06.000 --> 00:14:17.000
ユーザーがアプリにできるだけ簡単に入力できるように、これらすべてのヒントとコツを確認したので、テキスト入力をさらに高速化する新機能とAPIを導入することに興奮しています。

00:14:17.000 --> 00:14:21.000
そして、それはインライン予測です。

00:14:21.000 --> 00:14:28.000
iOS 17では、英語のキーボードがテキストフィールドとインラインで次の数語の予測を提供するようになりました。

00:14:28.000 --> 00:14:35.000
これらの予測はデバイス上で安全に生成され、フォーカスされたテキストフィールドで提供されるコンテキスト情報のみを使用します。

00:14:35.000 --> 00:14:38.000
これらの予測を採用するのも本当に簡単です。

00:14:38.000 --> 00:14:48.000
ここにはUITextInputTraitsプロトコルがあり、ご覧のとおり、新しいinlinePredictionTypeプロパティが追加され、いくつかのオプションが付属しています。

00:14:48.000 --> 00:14:58.000
デフォルトでは、インライン予測はほとんどのテキスト入力フィールドでアクティブになりますが、検索フィールドやパスワードフィールドなど、予測が適切ではないフィールドでは自動的に無効になります。

00:14:58.000 --> 00:15:05.000
もちろん、プロパティを「はい」または「いいえ」に明示的に設定することで、アプリの動作をカスタマイズすることもできます。

00:15:05.000 --> 00:15:09.000
そして、それで、いくつかの重要なポイントを要約しましょう。

00:15:09.000 --> 00:15:16.000
覚えておいてください: どのように表示されても、キーボードとシームレスに動作するようにアプリを設計してください。

00:15:16.000 --> 00:15:21.000
時間に敏感なコードを書くときは、新しいプロセスキーボードモデルを念頭に置いてください。

00:15:21.000 --> 00:15:26.000
そして、テキスト入力を加速するAPIを採用することで、アプリのエクスペリエンスを向上させます。

00:15:26.000 --> 00:15:29.000
キーボードに追いついてくれてありがとう。

00:15:29.000 --> 23:59:59.000
♪ ♪

