WEBVTT

00:00:01.000 -> 00:00:10.000
♪ ♪

00:00:10.000 -> 00:00:13.000
ゲオルギ:こんにちは、ようこそ!

00:00:13.000 -> 00:00:19.000
GPU、グラフィックス、ディスプレイソフトウェアのソフトウェアエンジニア、Georgi Rakidovです。

00:00:19.000 -> 00:00:24.000
このセッションは、ゲームをMacに持ち込むのに役立つ3部構成のシリーズの3番目です。

00:00:24.000 -> 00:00:47.000
最初のセッションでは、新しいゲームポーティングツールキットを使用してMac上で変更されたWindowsゲームを実行し、グラフィックス、オーディオ、およびディスプレイ機能を評価する方法について説明します。2番目のセッションでは、新しいメタルシェーダーコンバーターツールを使用して既存のHLSLシェーダーをMetalにコンパイルすることで、開発時間を節約できるかを示します。

00:00:47.000 -> 00:00:59.000
このセッションでは、レンダラーをMetalに移植し、Apple Siliconから優れたパフォーマンスを得る方法についての詳細な洞察を提供することで、ゲームをMacに持ち込むプロセスを完了します。

00:00:59.000 -> 00:01:08.000
レンダラーをMetalに移植すると、エンジンが他のプラットフォームグラフィックスAPIからMetalに概念をマッピングする必要があることに気付くでしょう。

00:01:08.000 -> 00:01:18.000
それを支援するために、このセッションでは、Metalのベストプラクティスを含む4つのトピックを取り上げているため、Apple GPUの強力なアーキテクチャを活用できます。

00:01:18.000 -> 00:01:30.000
各ゲームは、テクスチャやデータバッファを含むGPUリソースをGPUで使用できるようにし、シェーダーがそれらにアクセスする方法を設定する責任があります。

00:01:30.000 -> 00:01:40.000
あなたのゲームは、GPUにコマンドを送信する方法を最適化することで、Appleプロセッサの強力なグラフィックスアーキテクチャを活用できます。

00:01:40.000 -> 00:01:46.000
ゲームは通常、間接レンダリングを使用して現代のレンダリング技術を実装します。

00:01:46.000 -> 00:01:57.000
MetalFXは、より低い解像度にレンダリングし、MetalFXで最終的な解像度にアップスケーリングすることで、ゲームが各フレームの時間を節約するのに役立ちます。

00:01:57.000 -> 00:02:07.000
リソースの管理に関しては、各エンジンはGPUが各テクスチャ、データバッファなどにどのようにアクセスするかを決定する必要があります。

00:02:07.000 -> 00:02:21.000
Metalでは、シェーダーにバインディングでリソースへのアクセスを提供し、リソースをGPUアクセス可能なメモリに常駐させ、それらへのアクセスを同期させることを考えることが重要です。

00:02:21.000 -> 00:02:24.000
リソースバインディングとシェーダーは一緒になります。

00:02:24.000 -> 00:02:36.000
今年の新しいツールであるMetal Shader Converterを使用して、既存のシェーダーを翻訳することから始めましょう。これにより、シェーダーをMetalに移植する多くの時間を節約できます。

00:02:36.000 -> 00:02:40.000
このシリーズの「シェーダーをコンパイルする」セッションから詳細を学ぶことができます。

00:02:40.000 -> 00:02:45.000
メタルシェーダーコンバーターは、2つのバインディングモデルから選択できます。

00:02:45.000 -> 00:02:57.000
「自動レイアウト」を使用すると、コンバーターは自動的にバインディング情報を生成するか、「明示的なレイアウト」でバインディング情報をMetal Shader Converterに渡すことができます。

00:02:57.000 -> 00:03:06.000
明示的なレイアウトは非常に柔軟で、他のプラットフォームからバインディングモデルを実装する必要がある場合に役立ちます。

00:03:06.000 -> 00:03:30.000
たとえば、一部のAPIデザインはシェーダールートシグネチャを使用しており、ここでは4つのエントリを持つ典型的なものです。一連のテクスチャを指す記述子テーブル、バッファルートパラメータ、32ビット定数、および一連のサンプラーを指す別の記述子テーブルです。

00:03:30.000 -> 00:03:42.000
各記述子テーブルは、すべてのテクスチャ、すべてのサンプラー、またはすべてのバッファなど、同じタイプの要素を含むリソース配列です。

00:03:42.000 -> 00:03:47.000
メタルの引数バッファは、要素が複数のタイプである可能性があるという点で、より柔軟です。

00:03:47.000 -> 00:03:54.000
しかし、エンジンが均質な配列を期待している場合は、引数バッファで簡単にエンコードできます。

00:03:54.000 -> 00:03:59.000
この例では、テクスチャ記述子テーブルに相当するものをエンコードします。

00:03:59.000 -> 00:04:10.000
これは、各テクスチャのMetalリソースIDを格納することにより、テクスチャ記述子テーブルとして機能するMetalバッファを割り当てることから始まります。

00:04:10.000 -> 00:04:19.000
各テクスチャを作成すると、コードはリソースIDをテーブルに直接保存します。

00:04:19.000 -> 00:04:25.000
良い部分は、レンダリングループの前面と外側でこのようなコードを実行できることです!

00:04:25.000 -> 00:04:32.000
サンプラー記述子テーブルをエンコードするプロセスはほぼ同じです。

00:04:32.000 -> 00:04:41.000
テクスチャと同様に、コードはサンプラー記述子テーブルとして機能するMetalバッファを作成することから始まります。

00:04:41.000 -> 00:04:49.000
コードが各サンプラーの記述子を設定すると、supportArgumentBuffersプロパティをyesに設定します。

00:04:49.000 -> 00:04:57.000
コードが記述子を使用してサンプラーを作成した後、サンプラーのリソースIDをテーブルに保存します。

00:04:57.000 -> 00:05:04.000
引数バッファを使用して、トップレベルのルート署名自体を表すこともできます。

00:05:04.000 -> 00:05:15.000
この例では、ルートシグネチャの構造を定義し、その1つのインスタンスを保存できるMetalバッファを作成します。

00:05:15.000 -> 00:05:26.000
コードは、テクスチャとサンプラーテーブルのGPUアドレスを含む適切な値を持つ構造体のフィールドの各フィールドを割り当てます。

00:05:26.000 -> 00:05:29.000
ルート署名を変換するために必要なのはそれだけです。

00:05:29.000 -> 00:05:33.000
議論バッファはメタル3で超効率的です!

00:05:33.000 -> 00:05:38.000
これで、トップレベルの引数バッファをシェーダーにバインドできます。

00:05:38.000 -> 00:05:48.000
この部分はレンダリングループで行われますが、レンダリングループの外側で事前に記述子テーブルとルート構造を作成できます。

00:05:48.000 -> 00:06:00.000
Metal 3引数バッファは、ルートシグネチャや記述子テーブルなど、他のバインディングモデルを変換するための柔軟でパフォーマンスの高い方法を提供します。

00:06:00.000 -> 00:06:08.000
リソースは、シェーダーがアクセスするために、特定のパスまたはレンダリングステージの実行中に常駐する必要があります。

00:06:08.000 -> 00:06:16.000
また、リソースがパス間で共有されている場合は、それらのパスの実行順序を同期する必要があります。

00:06:16.000 -> 00:06:30.000
Metal引数バッファを使用したバインドレスリソースの使用には、すべてのGPUアーキテクチャで明示的なレジデンシー管理が必要であり、Metalはレジデンシーを制御する効率的な方法を提供します。

00:06:30.000 -> 00:06:35.000
推奨事項は、すべての読み取り専用リソースを大きなヒープにグループ化することです。

00:06:35.000 -> 00:06:50.000
そうすれば、エンコーダごとに1回useHeapを呼び出すだけで、そのパスまたはレンダリングステージの期間中、すべての読み取り専用リソースが常駐し、シェーダーがアクセスできるようになります。

00:06:50.000 -> 00:06:52.000
これがあなたのやり方です。

00:06:52.000 -> 00:07:02.000
すべての読み取り専用リソースを割り当てるために必要なサイズのヒープを作成し、このヒープから各リソースを割り当てます。

00:07:02.000 -> 00:07:09.000
そして、レンダリング時に、useHeapを呼び出すだけで、これらすべてのリソースを常駐させます。

00:07:09.000 -> 00:07:13.000
書き込み可能なリソースについては、ストーリーは少し異なります。

00:07:13.000 -> 00:07:21.000
書き込み可能なリソースを個別に割り当て、適切な使用フラグでuseResourceを呼び出すことを検討してください。

00:07:21.000 -> 00:07:27.000
この場合、Metalはあなたのために同期を処理し、パフォーマンスを最適化します。

00:07:27.000 -> 00:07:35.000
これにより、Metalエンコーダ間でリソースを手動で同期する負担を回避できます。

00:07:35.000 -> 00:07:42.000
以前と同様に、リソースを割り当てることから始めますが、今回はヒープに裏打ちされていません。

00:07:42.000 -> 00:07:51.000
次に、これらのリソースにアクセスするエンコーダに対してのみ、適切な使用フラグでuseResourceを呼び出します。

00:07:51.000 -> 00:07:59.000
この例では、エンコーダはテクスチャに書き込み、バッファから読み取っています。

00:07:59.000 -> 00:08:02.000
これはこの推奨事項の表です。

00:08:02.000 -> 00:08:09.000
読み取り専用リソースと書き込み可能なリソースの両方が、トップレベルの引数バッファからアクセスされます。

00:08:09.000 -> 00:08:14.000
理想的なケースでは、エンコーダごとに1回だけ設定してください。

00:08:14.000 -> 00:08:21.000
読み取り専用リソースは、ヒープにグループ化され、ハザードトラッキングモードは追跡なしに設定されています。

00:08:21.000 -> 00:08:28.000
ヒープ内のすべてのリソースを常駐させるには、エンコーダごとに1回useHeapを呼び出します。

00:08:28.000 -> 00:08:35.000
書き込み可能なリソースは、個別に割り当てられ、ハザードトラッキングと同期をMetalに残します。

00:08:35.000 -> 00:08:41.000
そして、各リソース呼び出しについて、エンコーダごとに1回resourceを使用します。

00:08:41.000 -> 00:08:43.000
これは効率的なアプローチです!

00:08:43.000 -> 00:08:57.000
CPUオーバーヘッドの少ないバインドレスモデルを実装し、アプリケーションはハザードトラッキングと同期、深刻な労力を必要とする複雑なタスク、開発時間を心配する必要はありません。

00:08:57.000 -> 00:09:18.000
バインドレス、レジデンシー、同期の詳細については、セッション「Go bindless with Metal 3」を参照してください。リソースバインディング、レジデンシー、および同期がコードに実装されると、画面上で何かをレンダリングするために、エンジンはレンダラーにコマンドを送信する必要があります。

00:09:18.000 -> 00:09:24.000
Appleプロセッサには、コマンドの実行を最適化するための多くの機能があります。

00:09:24.000 -> 00:09:34.000
GPUは、CPUとGPUがシステムメモリを共有しているユニファイドメモリアーキテクチャを備えたタイルベースの遅延レンダラー（TBDR）です。

00:09:34.000 -> 00:09:40.000
また、GPUにはTile Memoryと呼ばれる高速なオンチップメモリがあります。

00:09:40.000 -> 00:09:51.000
このアーキテクチャを活用するために、Metalはパスの概念を持っており、あなたの目標はレンダリングコマンドをパスにグループ化し、それらのパスを適切に設定することです。

00:09:51.000 -> 00:10:05.000
TBDRアーキテクチャの詳細については、関連するプレゼンテーション「MetalアプリをApple Silicon Macに持ち込む」と「AppleGPUをMetalで活用する」を参照してください。

00:10:05.000 -> 00:10:16.000
他のAPIは、異なるタイプのGPUコマンドを混合する連続ストリームを持つことができ、あなたのエンジンはこれを想定するかもしれません。

00:10:16.000 -> 00:10:21.000
コマンドをMetalに変換して、まずコマンドバッファを作成します。

00:10:21.000 -> 00:10:28.000
次に、コマンド、グラフィックス、コンピュート、またはBlitの種類に応じて、それらをパスにグループ化します。

00:10:28.000 -> 00:10:35.000
コマンドエンコーダを使用して、各パスのコマンドをコマンドバッファに書き込みます。

00:10:35.000 -> 00:10:46.000
最後に、すべてのコマンドがエンコードされたら、GPUによって実行するためにコマンドバッファをコマンドキューに送信します。

00:10:46.000 -> 00:10:53.000
エンジンは、レンダリングコマンドをMetalに効率的に変換するための4つのベストプラクティスを検討できます。

00:10:53.000 -> 00:11:04.000
レンダリング開始前にコピーを事前にバッチ処理し、同じタイプのコマンドをグループ化し、レンダリングターゲットをクリアするための空のエンコーダを避けることから始めます。

00:11:04.000 -> 00:11:11.000
そして最後に、Metal LoadとStoreのアクションを最適化して、メモリ帯域幅を最小限に抑えます。

00:11:11.000 -> 00:11:16.000
これらのベストプラクティスは、例を使って簡単に説明できます。

00:11:16.000 -> 00:11:25.000
次のシーケンスがあるとします。レンダリングターゲットクリア、ドロー、コピー、ディスパッチ、および別のドローです。

00:11:25.000 -> 00:11:32.000
特に、このシーケンスで生成されたシステムとタイルメモリ間のすべてのメモリトラフィックを見てください。

00:11:32.000 -> 00:11:34.000
これは理想的ではありません!

00:11:34.000 -> 00:11:42.000
ストリームの中央にあるコピーは、後続のドロー、この場合はドロー1の均一なデータをコピーします。

00:11:42.000 -> 00:11:53.000
可能であれば、レンダリングパスの中断を避けるために、レンダリング前にこれらのコピーを移動してバッチ処理することをお勧めします。

00:11:53.000 -> 00:12:01.000
変更後、コピーが最初になり、次にクリア、描画0、ディスパッチ、描画1です。

00:12:01.000 -> 00:12:13.000
2つのドローコールとディスパッチの間に依存関係がない場合は、ドローとディスパッチを一緒にバッチ処理できるように、それらを並べ替える必要があります。

00:12:13.000 -> 00:12:23.000
この例では、ドローとディスパッチコールの順序を切り替えた後、互いに2つのレンダリングパスを持つようになりました。

00:12:23.000 -> 00:12:35.000
このシナリオは、同じレンダリングターゲットを共有している場合、それらを単一のレンダリングパスにマージするのに最適で、メモリ帯域幅を大幅に節約できます。

00:12:35.000 -> 00:12:48.000
そうすれば、データがタイルメモリからシステムメモリに移動し、2つの描画の間に戻る必要がないため、不要なメモリトラフィックを削除できます。

00:12:48.000 -> 00:12:52.000
これはすでに優れていますが、さらに最適化される可能性があります。

00:12:52.000 -> 00:13:01.000
クリアは空のエンコーダで、1つの目的しかありません。次のドローで使用されるレンダリングターゲットをクリアすることです。

00:13:01.000 -> 00:13:04.000
金属では、これを行うための非常に効率的な方法があります。

00:13:04.000 -> 00:13:12.000
レンダリングターゲットを使用する最初のレンダリングパスには、LoadActionClearを使用するだけです。

00:13:12.000 -> 00:13:21.000
これははるかに優れていますが、ロードとストアアクションを最適化できる推奨事項がもう1つあります。

00:13:21.000 -> 00:13:29.000
次のパスで使用されるレンダリングターゲットの内容をシステムメモリに保存するだけです。

00:13:29.000 -> 00:13:36.000
この例から、ドロー1の後、最初のレンダリングターゲットのみが使用されると仮定します。

00:13:36.000 -> 00:13:43.000
他のすべてのレンダリングターゲットは中間であり、コンテンツを保存する必要はありません。

00:13:43.000 -> 00:13:49.000
メタルを使用すると、各レンダリングターゲットのストアアクションを制御できます。

00:13:49.000 -> 00:13:58.000
この場合、最初のレンダリングターゲットにはStoreActionStoreを使用し、他のターゲットにはStoreActionDontCareを使用できます。

00:13:58.000 -> 00:14:02.000
そして、それだけです!これが最初のコマンドシーケンスです。

00:14:02.000 -> 00:14:08.000
タイルメモリとシステムメモリの間には5回の往復があります。

00:14:08.000 -> 00:14:13.000
そして、これはいくつかの簡単な最適化の後、コマンドシーケンスがどのように見えるかです。

00:14:13.000 -> 00:14:17.000
タイルメモリからシステムメモリへの最後のフラッシュは1回だけです。

00:14:17.000 -> 00:14:21.000
メモリ帯域幅が大幅に削減されました!

00:14:21.000 -> 00:14:36.000
そして、レンダリング前にコピーを移動し、同じタイプのコマンドをグループ化し、空のエンコーダでレンダリングターゲットをクリアすることを避け、ロードとストアアクションを最適化することによって達成されました。

00:14:36.000 -> 00:14:39.000
GPUツールは、これらの問題を特定するのに役立ちます。

00:14:39.000 -> 00:14:48.000
Xcodeのメタルデバッガは自動的に最適化の機会を見つけるので、ゲームで最高のパフォーマンスを得ることができます。

00:14:48.000 -> 00:15:00.000
これにより、Metalパスの依存関係を検査して理解することができ、フル機能のデバッグおよびプロファイリングツールスイートが付属しています。

00:15:00.000 -> 00:15:06.000
メタルデバッガを使用して、言及された問題を特定するのは簡単です。

00:15:06.000 -> 00:15:13.000
メタルワークロードをキャプチャすると、メタルデバッガーはサマリービューアを表示します。

00:15:13.000 -> 00:15:27.000
下部のインサイトセクションには、メモリ、帯域幅、パフォーマンス、API使用の4つのカテゴリに分類された最適化の機会が表示されます。

00:15:27.000 -> 00:15:33.000
このワークロードで強調したい帯域幅の洞察が2つあります。

00:15:33.000 -> 00:15:36.000
1つ目は未使用のリソース用です。

00:15:36.000 -> 00:15:45.000
インサイトを選択すると、右側のパネルでそれに対処するための要約と実用的なアドバイスを見つけることができます。

00:15:45.000 -> 00:15:51.000
GBufferパスは、必要以上に多くの添付ファイルを保存しています。

00:15:51.000 -> 00:15:58.000
この場合、GBufferパスはアルベド/アルファテクスチャをロードして保存します。

00:15:58.000 -> 00:16:11.000
ただし、アルベドテクスチャはこのフレームの後半では使用されないため、ストアは冗長であるため、ストアアクションをDontCareに設定することで修正できます。

00:16:11.000 -> 00:16:14.000
次のインサイトを確認しましょう。

00:16:14.000 -> 00:16:27.000
レンダリングパスを組み合わせることは、帯域幅を減らすのに役立ち、ここでの洞察は、GBufferとForwardパスを1つのパスに組み合わせることができることを示唆しています。

00:16:27.000 -> 00:16:40.000
また、右側の[依存関係で表示]ボタンをクリックして、依存関係ビューアでこのレンダリングパスを見つけると、これらのパスが何を読み書きしているかについて詳しく知ることができます。

00:16:40.000 -> 00:16:45.000
依存関係ビューアは、パス間の依存関係を検査するための素晴らしいツールです!

00:16:45.000 -> 00:16:54.000
ここでは、レンダリング添付ファイルの上下に示されているロードとストアのアクションを一目で確認できます。

00:16:54.000 -> 00:17:03.000
このパスのすべての添付ファイルにはストアアクションストアがありますが、将来のパスではカラー0と深度アタッチメントのみが使用されます。

00:17:03.000 -> 00:17:07.000
以前の洞察はこれを明らかにした。

00:17:07.000 -> 00:17:16.000
少しズームアウトすると、データエッジがGBufferパスからフォワードパスに流れるように表示されます。

00:17:16.000 -> 00:17:27.000
洞察が示すように、GBufferパスとフォワードパスは、同じ添付ファイルから保存およびロードしているため、帯域幅を節約するためにマージできます。

00:17:27.000 -> 00:17:33.000
これら2つのパスをマージすると、帯域幅が節約され、パフォーマンスが向上します。

00:17:33.000 -> 00:17:41.000
これは、Metal Debuggerを使用してゲームの最適化の機会を見つける方法の一例にすぎません。

00:17:41.000 -> 00:17:55.000
Metal Debuggerの詳細については、関連するセッション「Xcode 12でMetalアプリの洞察を得る」と「Metalのデバッグ、プロファイリング、アセット作成ツールを発見」をご覧ください。

00:17:55.000 -> 00:18:03.000
間接レンダリングは、ハイエンドゲームが高度なレンダリング技術を実装するために使用する重要な機能です。

00:18:03.000 -> 00:18:10.000
このトピックでは、ExecuteIndirectの仕組みと、この特定のコマンドをMetalに翻訳する方法について説明します。

00:18:10.000 -> 00:18:33.000
間接レンダリングでは、複数のドローコマンドをエンコードする代わりに、それらの引数はメモリ内の通常のバッファに格納され、1つのExecuteIndirectコマンドのみがバッファを参照してエンコードされ、バッファからそれぞれの引数を取得することによってGPUが実行しなければならないドロー呼び出しの数を指定します。

00:18:33.000 -> 00:18:47.000
このアプローチの主なアイデアは、ExecuteIndirectコマンドの前に実行がスケジュールされた計算シェーダーによって間接バッファのコンテンツに入力できるようにすることです。

00:18:47.000 -> 00:18:53.000
このようにして、GPUは自分で作業を準備し、何をレンダリングするかを決定します。

00:18:53.000 -> 00:19:03.000
間接引数によるコマンドの実行は、GPU駆動のレンダリングループなどの高度な技術を実装するための重要な機能です。

00:19:03.000 -> 00:19:14.000
このコマンドをMetalに変換するには、Draw IndirectとMetal Indirect Command Buffers（ICB）の2つの方法があります。

00:19:14.000 -> 00:19:23.000
Metalでは、レンダラーは各ExecuteIndirectをDrawIndirectへの一連のAPI呼び出しに変換しなければなりません。

00:19:23.000 -> 00:19:30.000
それぞれがバッファを参照し、描画引数のオフセットを提供します。

00:19:30.000 -> 00:19:32.000
これがコードです。

00:19:32.000 -> 00:19:37.000
このExecuteIndirectが持つ可能性のあるドロー呼び出しの最大数を調べてください。

00:19:37.000 -> 00:19:46.000
それぞれについて、間接引数バッファとそのバッファ内のオフセットを指定する別々のドローをエンコードします。

00:19:46.000 -> 00:19:53.000
反復の最後に、オフセットを次の間接引数のセットを指すように移動します。

00:19:53.000 -> 00:19:59.000
このアプローチは実装が非常に簡単で、ほとんどすべての状況で機能します。

00:19:59.000 -> 00:20:11.000
ただし、何千ものドローコールのシーンがあり、ゲームのパフォーマンスがCPUエンコーディング時間によって制限されている場合は、Metalの間接コマンドバッファを検討する必要があります。

00:20:11.000 -> 00:20:17.000
ICBは、間接ドロー引数を持つバッファのスーパーセットです。

00:20:17.000 -> 00:20:26.000
引数を描画するだけでなく、バッファバインディングを設定し、GPUからパイプライン状態オブジェクトをレンダリングすることもできます。

00:20:26.000 -> 00:20:37.000
GPUで実行するためにICBからのコマンドをスケジュールするには、executeCommandsInBufferコマンドをエンコードする必要があります。

00:20:37.000 -> 00:20:44.000
通常、ExecuteIndirectでは、すべてのドロー呼び出しは同じパイプライン状態オブジェクトを共有します。

00:20:44.000 -> 00:20:52.000
また、PSOが変更されるたびに、新しいExecuteIndirectコマンドをエンコードする必要があります。

00:20:52.000 -> 00:21:00.000
ICBを使用している場合は、頻繁に状態変更によって間接実行コマンドを分割する必要はありません。

00:21:00.000 -> 00:21:09.000
すべてのPSOとバッファバインディングはICBから設定できるので、エンコードする必要はありません。

00:21:09.000 -> 00:21:15.000
シーンの構造によっては、エンコード時間が大幅に短縮される可能性があります。

00:21:15.000 -> 00:21:24.000
ICBを活用するには、間接引数を入力する既存のシェーダーを変更する必要はありません。

00:21:24.000 -> 00:21:42.000
同じシェーダーを他のプラットフォームと共有し、Metal Shader Converterでコンパイルし、間接引数の生成後、間接レンダリングパスの前に小さな計算カーネルを追加して、描画引数をICBに変換できます。

00:21:42.000 -> 00:21:48.000
コンピューティングカーネルでICBをエンコードするには、Metal Shading Languageで記述します。

00:21:48.000 -> 00:21:55.000
シェーダへの入力として、翻訳したい間接引数へのポインタがあります。

00:21:55.000 -> 00:22:02.000
次に、引数が有効かどうかを確認し、その場合にのみコマンドをエンコードします。

00:22:02.000 -> 00:22:11.000
encodeCommand関数で、レンダリングパイプライン状態、バッファバインディング、およびドロー呼び出しを設定します。

00:22:11.000 -> 00:22:18.000
これは、描画引数を間接コマンドバッファのレンダリングコマンドに変換します。

00:22:18.000 -> 00:22:22.000
そして、それが間接レンダリングをMetalに変換する方法です。

00:22:22.000 -> 00:22:28.000
一連のdraw間接コマンドまたはMetal Indirectコマンドバッファを使用できます。

00:22:28.000 -> 00:22:39.000
間接レンダリングを使用して高度なレンダリング技術を実装する方法を学びたい場合は、「Metalによるモダンレンダリング」サンプルコードをチェックしてください。

00:22:39.000 -> 00:22:54.000
ゲームがリソースをパイプラインにバインドし、コマンドをコマンドバッファに適切にエンコードすることで正しい画像を生成すると、アップスケーリングを活用してプレイヤーのデバイスからパフォーマンスを向上させることができます。

00:22:54.000 -> 00:23:02.000
MetalFXを介したアップスケーリングは、GPUの作業量を減らすことで、ゲームが各フレームの時間を節約するのに役立ちます。

00:23:02.000 -> 00:23:06.000
MetalFXは、アップスケーリングパイプラインを実装するためのターンキーソリューションです。

00:23:06.000 -> 00:23:22.000
これは、出力解像度で直接レンダリングするよりも短い時間で、低解像度の画像をターゲット出力解像度までスケーリングすることで機能します。

00:23:22.000 -> 00:23:30.000
MetalFXは昨年Mac用に導入され、高性能なアップスケーリングを提供します!

00:23:30.000 -> 00:23:44.000
MetalFXは、最高のパフォーマンスのための「Spatial」と、出力解像度のネイティブレンダリングに近づく品質のための「Temporal」の2つのアップスケーリングアルゴリズムをサポートしています。

00:23:44.000 -> 00:23:55.000
MetalFXをエンジンに統合すると、より高い解像度でより良いパフォーマンスでレンダリングすることで、プレイヤーの体験が向上します。

00:23:55.000 -> 00:24:07.000
今年の新機能には、iOSのサポート、最大3倍のアップスケーリング、Metal-cppのサポートが含まれます。

00:24:07.000 -> 00:24:21.000
エンジンがすでに他のプラットフォームで既存のアップスケーリングソリューションをサポートしている場合、MetalFXの統合はエンジン側で多くのコーディングと変更を必要としません。

00:24:21.000 -> 00:24:27.000
MetalFXをサポートするには、エンジンのアップスケーリングサポートが必要です。

00:24:27.000 -> 00:24:37.000
もう1つの要件は、マテリアルシェーダーのテクスチャサンプリングの詳細レベルを手動で制御するレンダラーです。

00:24:37.000 -> 00:24:42.000
時間的アップスケーリングには、ジッタシーケンスとモーションベクトルが必要です。

00:24:42.000 -> 00:24:48.000
エンジンが一時的なアンチエイリアシングをサポートしている場合は、おそらくすでにそれらを持っているでしょう。

00:24:48.000 -> 00:24:56.000
MetalFXの一時的なアップスケーリングは、レンダリングの露出を考慮に入れることができ、2つの選択肢があります。

00:24:56.000 -> 00:25:02.000
レンダラーが1×1の露出テクスチャをサポートしている場合は、それを使用してください。

00:25:02.000 -> 00:25:09.000
それ以外の場合は、自動露光機能を有効にして、品質が向上するかどうかを確認できます。

00:25:09.000 -> 00:25:17.000
カメラのカットや極端なカメラの動きの履歴をリセットすることを忘れないでください。

00:25:17.000 -> 00:25:29.000
MetalFXをアプリケーションに統合する方法の詳細については、昨年のドキュメントと「MetalFXアップスケーリングによるパフォーマンスの向上」を参照してください。

00:25:29.000 -> 00:25:36.000
Metalは、アプリのレンダリング時間を最大限に活用するためのいくつかの強力なオプションを提供します。

00:25:36.000 -> 00:25:41.000
リソースを管理し、できるだけ効率的にバインドすることができます。

00:25:41.000 -> 00:25:53.000
シェーダーがそれらにアクセスする方法に基づいて、リソースを共有するパスが正しい順序で実行されるようにし、リソースを常駐してGPUで利用可能にします。

00:25:53.000 -> 00:26:09.000
アプリは、XcodeのMetal Debuggerで最適化の機会を見つけて適用し、コマンド送信を最適化することで、Appleの強力なグラフィックスアーキテクチャの可能性を最大限に活用できます。

00:26:09.000 -> 00:26:20.000
間接レンダリングを実装することで、GPUが自分で作業を決定することができます。これは、多くの最新のレンダリング技術の鍵になる可能性があります。

00:26:20.000 -> 00:26:28.000
MetalFXでレンダリングをアップスケーリングすることで、レンダリングゲームをアップします。これにより、レンダリングループでアプリの貴重な時間を節約できます。

00:26:28.000 -> 00:26:35.000
より多くのレンダリングのヒントとガイドラインについては、「AppleシリコンMacのメタルパフォーマンスの最適化」をチェックしてください。

00:26:35.000 -> 00:26:38.000
見てくれてありがとう!

00:26:38.000 -> 23:59:59.000
♪ ♪

