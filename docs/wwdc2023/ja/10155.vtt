WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:12.000
マリーナ：こんにちは、WWDCへようこそ。

00:00:12.000 --> 00:00:16.000
私の名前はマリーナで、後で同僚のマットが加わります。

00:00:16.000 --> 00:00:22.000
私たちはAppleのローカリゼーションチームから来ており、今日はストリングカタログをお見せできることを嬉しく思います。

00:00:22.000 --> 00:00:26.000
ここアップルでは、アクセシビリティと包括性を強く信じています。

00:00:26.000 --> 00:00:32.000
アプリをローカライズすることは、コンテンツが世界中のより多くの人々に届くようにする1つの方法です。

00:00:32.000 --> 00:00:43.000
実際、今日、私たちは40以上の言語でオペレーティングシステムを出荷し、誰もが母国語で製品を使用できるように、この数を継続的に拡大しています。

00:00:43.000 --> 00:00:57.000
私たちのチームは、ローカリゼーションをできるだけ簡単にするためにXcodeでツールを提供することにコミットしており、今日、私たちはあなたのプロジェクトでローカライズされたコンテンツを管理するための新しい改善とワークフローを提示することに興奮しています。

00:00:57.000 --> 00:01:04.000
以前は、アプリをローカライズしたい場合は、文字列とstringsdictファイルを維持する必要がありました。

00:01:04.000 --> 00:01:11.000
これにより、すべての文字列を手動でコードと同期させる必要があり、多くの場合、コンテンツのローカライズを見逃す可能性があります。

00:01:11.000 --> 00:01:15.000
これにより、ユーザーにローカライズされていない文字列が発生する可能性があります。

00:01:15.000 --> 00:01:23.000
私たちのプロジェクトは長年にわたってこのプロセスに依存してきましたが、Xcode 15では文字列カタログを導入しています。

00:01:23.000 --> 00:01:29.000
時間が経つにつれて、この新しいフォーマットはXcodeの文字列とstringsdictファイルの両方に取って代わります。

00:01:29.000 --> 00:01:38.000
文字列カタログを使用すると、すべての文字列を1か所で簡単に管理でき、出荷前にコンテンツが完全にローカライズされていることを確信できます。

00:01:38.000 --> 00:01:41.000
それがどのように機能するか見てみましょう。

00:01:41.000 --> 00:01:46.000
このコードでは、SwiftUIコントロールを使用してビューを構築し、コンテンツに入力しています。

00:01:46.000 --> 00:01:50.000
そして、これは文字列カタログです。

00:01:50.000 --> 00:01:55.000
Swiftコードで見たすべての文字列は、Xcodeによって自動的に抽出されました。

00:01:55.000 --> 00:01:58.000
自分で追加する必要はありませんでした。

00:01:58.000 --> 00:02:05.000
ブラジルの友人がこのアプリを使えるようにしたいので、ポルトガル語に翻訳しました。

00:02:05.000 --> 00:02:10.000
私はこの裏庭を訪れた最近の鳥を展示するこのビューを持っています。

00:02:10.000 --> 00:02:20.000
ここでは、裏庭を訪れた鳥の実際の数を表示したいので、この数を表す変数を追加させてください。

00:02:20.000 --> 00:02:23.000
そして、これはプレビューにあります。

00:02:23.000 --> 00:02:25.000
今、私たちは鳥の数を見ることができます。

00:02:25.000 --> 00:02:34.000
プロジェクトを構築し、カタログに戻ります。

00:02:34.000 --> 00:02:37.000
それは簡単でした。これが新しい文字列です。

00:02:37.000 --> 00:02:41.000
そして、私の翻訳の進捗状況が下がっていることがわかります。

00:02:41.000 --> 00:02:47.000
文字列カタログには、複雑な操作を簡単に実行できる強力な編集機能も付属しています。

00:02:47.000 --> 00:02:58.000
たとえば、この文字列にはタップという単語がありますが、これはマルチプラットフォームアプリなので、Macデバイスの場合、正しい単語を使用していることを確認したいです。

00:02:58.000 --> 00:03:05.000
だから、私の英語の弦に戻って、「もっと学ぶためにタップ」という弦を見つけましょう。

00:03:05.000 --> 00:03:07.000
ここにあります。

00:03:07.000 --> 00:03:09.000
右クリックします。

00:03:09.000 --> 00:03:14.000
選択はデバイスによって異なります。Macを選んでください。

00:03:14.000 --> 00:03:25.000
そして、テキストを正しく適応させます。

00:03:25.000 --> 00:03:26.000
そして、それだけです。

00:03:26.000 --> 00:03:35.000
さて、自分のビューに戻り、実行先をMacに変更すると...

00:03:35.000 --> 00:03:39.000
プレビューを使って私の作品をチェックすることができます。

00:03:39.000 --> 00:03:41.000
それは簡単でした。

00:03:41.000 --> 00:03:44.000
ストリングカタログでできることはたくさんあります。

00:03:44.000 --> 00:03:48.000
すべてがどのように機能するかを詳しく見てみましょう。

00:03:48.000 --> 00:03:59.000
文字列を抽出できる場所から始め、文字列カタログと対話するためのXcodeのネイティブエディタを探索し、ローカリゼーションのエクスポートプロセスを確認します。

00:03:59.000 --> 00:04:07.000
次に、ストリングカタログがどのように構築され、既存のプロジェクトでどのように採用できるかを見ていきます。

00:04:07.000 --> 00:04:13.000
まず、私はそれをマットに引き渡して、ローカライズ可能な文字列とそれらがどこから来たのかについて話し合います。

00:04:13.000 --> 00:04:14.000
マット：ありがとう、マリーナ！

00:04:14.000 --> 00:04:26.000
ローカライズ可能な文字列は、単に実行時にユーザーに表示されるテキストの文字列であるため、アプリがサポートするすべての言語に翻訳する必要があります。

00:04:26.000 --> 00:04:36.000
ローカライズ可能な文字列には4つのコンポーネントがあります。キーは文字列の一意の識別子であり、多くの場合、文字列自体と同等です。

00:04:36.000 --> 00:04:41.000
これは、表示する適切な値を検索するために実行時に使用されるものです。

00:04:41.000 --> 00:04:51.000
デフォルト値は必要に応じて明示的に指定できますが、それ以外の場合はデフォルトのローカリゼーションのキーにフォールバックします。

00:04:51.000 --> 00:05:00.000
Xcode 14.3では、プロジェクトエディタを使用してプロジェクトのデフォルトのローカリゼーションを変更する機能を導入しました。

00:05:00.000 --> 00:05:05.000
これは、ソースコードの文字列が英語でない場合に便利です。

00:05:05.000 --> 00:05:14.000
次に、文字列コメントは、文字列がユーザーインターフェイスでどこでどのように使用されているかについて、翻訳者にコンテキストを与える方法を提供します。

00:05:14.000 --> 00:05:21.000
翻訳者の曖昧さを解決するために、文字列にコメントを追加することをお勧めします。

00:05:21.000 --> 00:05:31.000
最後に、各ローカライズ可能な文字列は、翻訳が保存される1つ以上のファイルに対応する文字列テーブルに属します。

00:05:31.000 --> 00:05:41.000
デフォルトでは、コードの文字列は「Localizable」テーブルに配置されますが、文字列を他の方法で整理したい場合はカスタマイズできます。

00:05:41.000 --> 00:05:44.000
文字列テーブルを詳しく見てみましょう。

00:05:44.000 --> 00:05:58.000
.Stringsファイルを使用する既存のアプリケーションの場合、単一の文字列テーブルには、実際にはサポートされている各言語のlprojディレクトリ内に.stringsとおそらく.stringsdictファイルが含まれています。

00:05:58.000 --> 00:06:03.000
ここに表示されているすべてのファイルは、「ローカライズ可能な」文字列テーブルを構成する。

00:06:03.000 --> 00:06:11.000
一方、文字列カタログには、文字列テーブル全体が1つのファイルに含まれています。

00:06:11.000 --> 00:06:19.000
これには、そのテーブル内の各ローカライズ可能な文字列のすべての翻訳と追加のメタデータが含まれます。

00:06:19.000 --> 00:06:27.000
文字列を複数の文字列テーブルに整理したい場合は、複数の文字列カタログを作成できます。

00:06:27.000 --> 00:06:37.000
各カタログには、そのテーブルに属する文字列キーと、アプリがサポートするすべての言語での翻訳が含まれています。

00:06:37.000 --> 00:06:45.000
キーは包含テーブル内で常に一意ですが、キーがテーブル間で一意である必要はありません。

00:06:45.000 --> 00:06:56.000
例えば、「WWDCへようこそ!」文字列は、アプリ内の異なるコンテキストで表示される可能性があるため、ここでは両方のファイルに存在します。

00:06:56.000 --> 00:07:08.000
Marinaが以前に述べたように、Xcode 15は自動的に文字列カタログに入力し、プロジェクトで見つかったローカライズ可能な文字列と同期させるために最善を尽くします。

00:07:08.000 --> 00:07:13.000
しかし、Xcodeはこれらのローカライズ可能な文字列をどこで見つけますか?

00:07:13.000 --> 00:07:18.000
まあ、ローカライズ可能な文字列が住んでいるかもしれない様々な場所があります。

00:07:18.000 --> 00:07:27.000
Xcodeは、ソースコード、インターフェイスビルダーファイル、さらには文字列カタログに含める情報plistの文字列を見つけることができます。

00:07:27.000 --> 00:07:32.000
しばらく前からアプリをローカライズしているなら、これらの多くは馴染みがあるはずです。

00:07:32.000 --> 00:07:36.000
それらのいくつかを詳しく見てみましょう。

00:07:36.000 --> 00:07:38.000
SwiftUIから始めます。

00:07:38.000 --> 00:07:49.000
SwiftUIは、ビュー内で文字列リテラルを指定するたびに、その文字列は自動的にローカライズ可能と見なされるため、ローカリゼーションをシームレスにします。

00:07:49.000 --> 00:08:01.000
これらの文字列はすべてローカライズ可能と見なされ、存在する場合はLocalizable.xcstringsという名前の文字列カタログに抽出されます。

00:08:01.000 --> 00:08:07.000
これは、LocalizedStringKeyのタイプを受け入れる任意のパラメータに対して機能します。

00:08:07.000 --> 00:08:16.000
SwiftUI文字列は、テキストビューを使用して、コメント、カスタムテーブル名、または文字列ルックアップ用のバンドルを指定できます。

00:08:16.000 --> 00:08:23.000
また、クライアントに対してローカライズ可能と見なされるべき文字列を受け入れる独自のカスタムビューを定義することもできます。

00:08:23.000 --> 00:08:28.000
ここでは、StringタイプとしてLocalizedStringResourceを使用していることに注意してください。

00:08:28.000 --> 00:08:38.000
Xcodeは、コールサイトでLocalizedStringResourceをインスタンス化するために文字列リテラルが使用されているのを見ると、文字列がローカライズ可能であることがわかります。

00:08:38.000 --> 00:08:46.000
LocalizedStringResourceは、ローカライズ可能な文字列を表現して渡すための推奨型です。

00:08:46.000 --> 00:08:58.000
文字列リテラルを使用した初期化をサポートするだけでなく、コメント、テーブル名、または文字列キーとは異なるデフォルト値も提供できます。

00:08:58.000 --> 00:09:03.000
では、より一般的にSwiftコードに注意を向けましょう。

00:09:03.000 --> 00:09:08.000
ここには、後で提示される文字列を含むモデルコードがいくつかあります。

00:09:08.000 --> 00:09:18.000
StringとAttributedStringのローカライズされた初期化子を使用して、実行時にユーザーに表示される文字列を指定しています。

00:09:18.000 --> 00:09:25.000
LocalizedStringResourceは、Foundationをインポートした場所ならどこでも直接使用できます。

00:09:25.000 --> 00:09:33.000
文字列カタログは、ローカライズ可能なSwift文字列を抽出するために、Swiftコンパイラの強力な技術を利用します。

00:09:33.000 --> 00:09:39.000
このため、ビルド設定「コンパイラを使用してスウィフト文字列を抽出する」を有効にしてください。

00:09:39.000 --> 00:09:44.000
しかし、文字列カタログは、Swiftコード以上のものから文字列を抽出することができます。

00:09:44.000 --> 00:09:49.000
NSLocalizedStringを使用したObjective-Cコードの例を次に示します。

00:09:49.000 --> 00:10:03.000
NSLocalizedStringマクロに埋め込まれた文字列リテラルは、自動的にローカライズ可能と見なされ、検出可能な独自の同様のマクロを定義することもできます。

00:10:03.000 --> 00:10:10.000
同じ概念は、CFCopyLocalizedStringを使用してCコードでも使用できます。

00:10:10.000 --> 00:10:20.000
CまたはObjective-Cでカスタムローカライズされた文字列マクロを指定するには、ローカライズされた文字列マクロ名のビルド設定を使用します。

00:10:20.000 --> 00:10:27.000
これがソースコードでどのように機能するかを見たので、Interface Builderでローカライズ可能な文字列を探りましょう。

00:10:27.000 --> 00:10:32.000
インターフェイスビルダーで指定された文字列は、自動的にローカライズ可能として扱われます。

00:10:32.000 --> 00:10:42.000
インスペクタを使用して、これらの文字列のコメントを指定して、翻訳者に表示される場所に関するコンテキストを提供することもできます。

00:10:42.000 --> 00:10:51.000
文字列カタログがストーリーボードまたはxibとペアリングされている場合、インターフェイスビルダーからのすべてのローカライズ可能な文字列がカタログに存在します。

00:10:51.000 --> 00:10:58.000
ソースコードと同様に、Xcodeはプロジェクトが構築されるたびにカタログを更新します。

00:10:58.000 --> 00:11:02.000
このプロセスは、Info plistファイルでも同様に機能します。

00:11:02.000 --> 00:11:11.000
このためには、InfoPlist.xcstringsファイルをプロジェクトに追加し、目的のターゲットに追加するだけです。

00:11:11.000 --> 00:11:21.000
ビルドするたびに、Xcodeはローカライズ可能な情報plistキーの既知のセットをカタログに追加し、必要に応じて手動で追加できます。

00:11:21.000 --> 00:11:28.000
最後に、Xcodeには、App Shortcutのフレーズをローカライズする方法に、今年いくつかの大きな改善が含まれています。

00:11:28.000 --> 00:11:35.000
詳細については、今年の講演「Spotlight your app with App Shortcuts」を必ずチェックしてください。

00:11:35.000 --> 00:11:45.000
Xcodeがローカライズ可能な文字列を見つけることができるさまざまな場所を見学したので、これらの文字列が文字列カタログにどのようになるかについてもう少し話しましょう。

00:11:45.000 --> 00:11:52.000
ビルドするたびに、Xcodeは現在のスキームとプラットフォームでローカライズ可能な文字列を発見します。

00:11:52.000 --> 00:12:02.000
ソースコードからの文字列は、ローカライズ可能な文字列の真実のソースとして機能しますが、文字列カタログのソース文字列は同期されます。

00:12:02.000 --> 00:12:07.000
コードで新しい文字列が検出されると、Xcodeはそれらを文字列カタログに追加します。

00:12:07.000 --> 00:12:12.000
この時点で、文字列は翻訳する準備ができています。

00:12:12.000 --> 00:12:18.000
先に説明したように、ローカライズ可能な文字列は、コードで指定されたデフォルトのソース値を持つ可能性があります。

00:12:18.000 --> 00:12:24.000
その場合、カタログはコードから新しい値で更新されます。

00:12:24.000 --> 00:12:29.000
Xcodeは、コードから文字列を削除したときに検出することもできます。

00:12:29.000 --> 00:12:34.000
文字列がまだ翻訳されていない場合、Xcodeはあなたのためにそれを削除します。

00:12:34.000 --> 00:12:44.000
ただし、文字列の翻訳をすでに提供してから削除した場合、Xcodeはそれをそのままにして、古いものとしてマークします。

00:12:44.000 --> 00:12:48.000
これは、文字列がコードで見つからなかったことを示しています。

00:12:48.000 --> 00:12:55.000
不要になったことを確認できれば、文字列とその翻訳を削除できます。

00:12:55.000 --> 00:13:03.000
または、インスペクタを使用して、その特定の文字列を手動で管理したいことをXcodeに伝えることもできます。

00:13:03.000 --> 00:13:11.000
手動で管理された文字列は、ビルド後にローカリゼーションを同期するときにXcodeによって更新または削除されることはありません。

00:13:11.000 --> 00:13:19.000
これは、キーがコードで動的に構築されているか、おそらくデータベースに由来する文字列に役立ちます。

00:13:19.000 --> 00:13:30.000
すべての文字列を文字列カタログに抽出したので、文字列カタログエディタが翻訳を簡単に管理する方法を詳しく見てみましょう。

00:13:30.000 --> 00:13:39.000
文字列カタログには、アプリをローカライズする際に、状態と翻訳の進捗状況を追跡するためのファーストクラスのサポートが付属しています。

00:13:39.000 --> 00:13:45.000
コードに文字列が見つからなくなったときに、Xcodeがどのように文字列を古いものとして表示するかについては、すでに話しました。

00:13:45.000 --> 00:13:49.000
しかし、あなたが知っておくべき他の3つのローカリゼーション状態があります。

00:13:49.000 --> 00:13:55.000
「新規」は、文字列がまだ選択した言語に翻訳されていないことを示します。

00:13:55.000 --> 00:13:58.000
コードに新しい文字列を追加した後、これが表示されます。

00:13:58.000 --> 00:14:07.000
「レビューが必要」は、値を変更する必要がある可能性があるため、文字列がローカライザーの注意を必要とすることを示します。

00:14:07.000 --> 00:14:13.000
現在の値を使用する場合は、コンテキストメニューから「レビュー済みとしてマーク」を選択するだけです。

00:14:13.000 --> 00:14:18.000
このメニューを使用して、ローカライザーによるレビューのために文字列をマークすることもできます。

00:14:18.000 --> 00:14:23.000
これは、翻訳の欠陥に関するバグレポートを受け取った場合に便利です。

00:14:23.000 --> 00:14:29.000
最後に、選択した言語で翻訳された文字列には緑色のチェックマークが表示されます。

00:14:29.000 --> 00:14:33.000
これは、それ以上の行動が必要ないことを示しています。

00:14:33.000 --> 00:14:39.000
開発者として、もう1つの一般的なローカリゼーションの課題は複数化です。

00:14:39.000 --> 00:14:47.000
たとえば、Marinaが以前にBackyard Birdsに追加した文字列で、最近の訪問者数が表示されます。

00:14:47.000 --> 00:14:55.000
英語では、数字が1か他の数字かに応じて、文字列の文法を変更する必要があります。

00:14:55.000 --> 00:15:01.000
しかし、ウクライナ語のような言語では、考慮すべきケースがさらに増えるかもしれません。

00:15:01.000 --> 00:15:08.000
この問題を解決するには、渡された番号の値に基づいて文字列を変更する方法が必要です。

00:15:08.000 --> 00:15:15.000
以前は、多数の言語でこの問題を解決するには、stringsdictファイルが必要でした。

00:15:15.000 --> 00:15:25.000
このplist形式は正しく使用するのが難しく、文字列を複数形にするなどの単純なタスクにかなり高い障壁をもたらします。

00:15:25.000 --> 00:15:32.000
現在、文字列カタログエディタには、文字列バリエーションワークフローのサポートが組み込まれています。

00:15:32.000 --> 00:15:39.000
文字列のコンテキストメニューを表示すると、文字列を変更するオプションが表示されます。

00:15:39.000 --> 00:15:46.000
また、デフォルトのローカリゼーションで文字列を変更すると、翻訳も自動的に変更されます。

00:15:46.000 --> 00:15:53.000
2つの変数で複数のバリエーションを使用する必要がある文字列のより複雑な例を次に示します。

00:15:53.000 --> 00:15:57.000
実行時には、いくつかの異なるシナリオで終わる可能性があります。

00:15:57.000 --> 00:16:10.000
1つの裏庭に1羽の鳥、1つの裏庭に複数の鳥、複数の裏庭に複数の鳥、または複数の裏庭があるにもかかわらず1羽の鳥がいるかもしれません。

00:16:10.000 --> 00:16:18.000
いずれの場合も、数字を囲む文字列は、文法的な一致を維持するために少し異なる方法で翻訳する必要があります。

00:16:18.000 --> 00:16:22.000
文字列カタログエディタを使用すると、これも簡単にできます。

00:16:22.000 --> 00:16:25.000
ここで代替品の出番です。

00:16:25.000 --> 00:16:30.000
ここでは、文字列の両方の引数を複数形で変更しました。

00:16:30.000 --> 00:16:37.000
@記号の接頭辞が付いた各置換は、複数のケースとその値の辞書を格納します。

00:16:37.000 --> 00:16:48.000
この例には、鳥の数をフォーマットするための「鳥」の置換と、裏庭の数をフォーマットするための「ヤード」の置換が含まれています。

00:16:48.000 --> 00:16:59.000
実行時に、ここに示されているトップレベルの文字列が使用され、参照される各置換から適切な複数形のケースで置き換えられます。

00:16:59.000 --> 00:17:10.000
したがって、この例では、これらの文字列のいずれかを生成し、各置換の可能な複数のケースの順列を効果的に作成できます。

00:17:10.000 --> 00:17:18.000
置換は通常、文字列に渡された引数に対応し、多くの場合、文字列補間を使用します。

00:17:18.000 --> 00:17:29.000
インスペクタでは、Xcodeは、数値に使用する引数の位置に関する情報と、渡されるタイプのCスタイルの書式指定子を表示します。

00:17:29.000 --> 00:17:38.000
ここに示されているヤード置換は、ソースコードで使用される2番目の文字列補間であるため、引数2に対応しています。

00:17:38.000 --> 00:17:48.000
Backyards.countの値は、この置換内で1つまたは他のケースを使用するかどうかを判断するために使用されます。

00:17:48.000 --> 00:17:57.000
このようにして、文字列カタログは、このような高度なユースケースをサポートしながら、さまざまな文字列にシンプルなUIを提供します。

00:17:57.000 --> 00:18:02.000
さて、これらのテクニックを実行するためにマリーナに戻ります。

00:18:02.000 --> 00:18:03.000
マリーナ:ありがとう、マット。

00:18:03.000 --> 00:18:09.000
Backyard Birdsアプリに戻ると、文字列カタログエディタを使用すると、探している文字列を簡単に見つけることができます。

00:18:09.000 --> 00:18:20.000
「学ぶ」という単語を含むすべての文字列を見つけるためにフィルタリングしたり、状態別に並べ替えて、上部に最も重要な状態を表示したりできます。

00:18:20.000 --> 00:18:26.000
マットが指摘したように、コードにないがアプリに表示される文字列があるかもしれません。

00:18:26.000 --> 00:18:33.000
例えば、私のアプリは、アプリの加入者のためにクラウドから来る特別な種類の鳥を表示するかもしれないことを知っています。

00:18:33.000 --> 00:18:46.000
この場合、ここでプラスボタンを使用して、手動文字列を定義し、キーとコメントを与えることができます。

00:18:46.000 --> 00:18:52.000
手動で管理された文字列は、Xcodeによって更新または削除されないことを覚えておいてください。

00:18:52.000 --> 00:19:01.000
Xcodeにコードから文字列の抽出を開始したい場合は、インスペクタを展開してください...

00:19:01.000 --> 00:19:05.000
そして、文字列を自動的に管理するように設定します。

00:19:05.000 --> 00:19:09.000
Xcodeでは、ローカリゼーションの進捗状況を簡単に追跡できます。

00:19:09.000 --> 00:19:15.000
各文字列の横には、翻訳状態を表すバッジが表示されます。

00:19:15.000 --> 00:19:24.000
文字列がコードから追加されたとき、または私たちがやったように手動で追加されたとき、あなたはそれが「NEW」とマークされているのを見るでしょう、つまり、まだ翻訳されていないことを意味します。

00:19:24.000 --> 00:19:29.000
ソース文字列が変更されるたびに、翻訳はレビューのためにマークされます。

00:19:29.000 --> 00:19:36.000
以前、この文字列を英語で変更したので、既存の翻訳はレビューのためにマークされました。

00:19:36.000 --> 00:19:44.000
この文字列がそのままで大丈夫であれば、文字列を右クリックして「レビュー済みとしてマーク」を選択するだけです。

00:19:44.000 --> 00:19:55.000
私はポルトガル語を話すので、この翻訳を更新する必要があることを知っています。

00:19:55.000 --> 00:20:02.000
この変更により、サイドバーでローカリゼーションの割合が上昇したことがわかります。

00:20:02.000 --> 00:20:09.000
言語が完全にローカライズされると、サイドバーに緑色のチェックマークが表示されます。

00:20:09.000 --> 00:20:19.000
Xcodeでローカリゼーションの進捗状況を追跡し、App Storeに送信する前にアプリが完全にローカライズされていることを確信できるのはこれが初めてです。

00:20:19.000 --> 00:20:23.000
また、このアプリをウクライナ語でローカライズできるように準備したいです。

00:20:23.000 --> 00:20:37.000
プラスボタンを押して、このリストから新しい言語を選択することで、文字列カタログエディタから直接これを行うことができます。

00:20:37.000 --> 00:20:43.000
そして、これはまだ翻訳されていない私のウクライナのカタログです。

00:20:43.000 --> 00:20:48.000
これは先ほど追加した文字列で、複数形で変更する必要があるようです。

00:20:48.000 --> 00:20:52.000
そのために、英語に戻りましょう。

00:20:52.000 --> 00:20:57.000
この文字列を右クリックして「複数形」を選択します。

00:20:57.000 --> 00:21:06.000
英語では、複数形と単数形を区別する必要があることを知っているので、それを修正しましょう。

00:21:06.000 --> 00:21:10.000
ポルトガル語では、複数形のケースは英語と同じです。

00:21:10.000 --> 00:21:17.000
しかし、ウクライナ語を覗くと、複数のケースの別のセットが追加されたことがわかります。

00:21:17.000 --> 00:21:23.000
私のウクライナの翻訳者は、これをどうするかを正確に知っているでしょう。

00:21:23.000 --> 00:21:30.000
私の見解に戻って、私はそれぞれの裏庭に鳥の数を示す別のラベルを追加したいと思いました。

00:21:30.000 --> 00:21:35.000
だから、それを追加させてください...

00:21:35.000 --> 00:21:39.000
ビルド...

00:21:39.000 --> 00:21:43.000
そして、私のカタログに戻ります。

00:21:43.000 --> 00:21:45.000
そして、これは私のカタログにあります。

00:21:45.000 --> 00:21:50.000
また、文字列を複数形に変化させたいのですが、複数の引数が含まれています。

00:21:50.000 --> 00:21:58.000
今回は、文字列を右クリックして複数形を選択すると、どの引数を変えたいかを選択できます。

00:21:58.000 --> 00:22:06.000
両方で変えましょう。

00:22:06.000 --> 00:22:12.000
次に、実行時に複数化できるように置換を設定します。 置換

00:22:12.000 --> 00:22:16.000
議論に同意する必要がある言葉を移動しましょう。

00:22:16.000 --> 00:22:29.000
だから、「鳥」は「鳥」の置換に、「裏庭」は「ヤード」の置換に。

00:22:29.000 --> 00:22:38.000
読みやすさのために、変数がどの引数に対応するかを知るために、置換の名前を変更したいと思います。

00:22:38.000 --> 00:22:40.000
それは理解しやすいです。

00:22:40.000 --> 00:22:47.000
今、マットは、ウクライナ語の翻訳のためにそれらを送信するために私たちの文字列をエクスポートする方法を教えてくれます。

00:22:47.000 --> 00:22:48.000
マット:ありがとう、マリーナ。

00:22:48.000 --> 00:23:02.000
すでに見たように、Xcodeを使用すると、文字列カタログで直接翻訳を簡単に提供および編集できますが、多くの場合、翻訳者と協力してXcodeの外部でアプリの文字列をローカライズする必要があります。

00:23:02.000 --> 00:23:07.000
このシナリオでは、Xcodeはローカリゼーションのエクスポートオプションを提供します。

00:23:07.000 --> 00:23:15.000
これにより、言語ごとに1つのローカリゼーションカタログが生成され、翻訳のために送信できます。

00:23:15.000 --> 00:23:26.000
Xcode 10で最初に導入されたローカリゼーションカタログは、プロジェクトまたはワークスペース内のすべてのローカライズ可能なコンテンツを含むパッケージ形式です。

00:23:26.000 --> 00:23:34.000
今のところ、すべてのローカライズ可能な文字列とその翻訳を含む内部XLIFFファイルに焦点を当てます。

00:23:34.000 --> 00:23:42.000
XLIFFは、ローカリゼーションを保存および転送するための業界標準のフォーマットです。

00:23:42.000 --> 00:23:53.000
あなたやツールがXLIFFファイルで直接作業する場合は、文字列カタログを使用してプロジェクトでさまざまな文字列がどのように表現されるかにいくつかの変更を認識する必要があります。

00:23:53.000 --> 00:24:00.000
これは、もともと.stringsdictファイルで定義された複数文字列のXLIFF表現の例です。

00:24:00.000 --> 00:24:07.000
ここに示されているトランスユニット識別子は、stringsdict plist形式へのパスとして機能します。

00:24:07.000 --> 00:24:14.000
さまざまな文字列が代わりに文字列カタログに由来する場合、代わりにこのようになります。

00:24:14.000 --> 00:24:23.000
文字列キー、セパレータシーケンス、そして最後にドット区切り構成文字列が含まれています。

00:24:23.000 --> 00:24:36.000
この構成文字列は、単純な複数の指定子、デバイス指定子、複数の条件のチェーン、または置換内の複数のケースへのパスである可能性があります。

00:24:36.000 --> 00:24:47.000
自動化ツールがこれらのキーを読みやすいだけでなく、人間が一目で読みやすく理解しやすいように設計しました。

00:24:47.000 --> 00:24:57.000
翻訳ツールは、XLIFFの翻訳ユニットを目的のバリエーション構造に置き換えることで、以前は変更されていなかった文字列を変化させることもできます。

00:24:57.000 --> 00:25:02.000
たとえば、現在まったく変化していない文字列を次に示します。

00:25:02.000 --> 00:25:08.000
しかし、ポルトガル語では、特にApple Watchでより短い文字列を提供したいと思います。

00:25:08.000 --> 00:25:23.000
そのユニットをXLIFFのdevice.applewatchとdevice.otherバリアントに置き換えることで、次のインポート時にこの言語に存在するバリエーション構造に影響を与えることができます。

00:25:23.000 --> 00:25:34.000
ローカリゼーションをエクスポートするときにXLIFFがデフォルトで文字列カタログ形式を使用していることを確認するには、ローカリゼーションが文字列カタログを好むことを「はい」に設定してください。

00:25:34.000 --> 00:25:41.000
翻訳者から翻訳されたローカリゼーションカタログを受け取ったら、それをプロジェクトにインポートすることができます。

00:25:41.000 --> 00:25:51.000
文字列カタログから来た文字列の場合、インポートされたファイルで指定された翻訳は、適切な文字列カタログに自動的に追加されます。

00:25:51.000 --> 00:25:54.000
裏庭の鳥でこれを試してみましょう。

00:25:54.000 --> 00:26:05.000
マリーナ:私はポルトガル語を話すので、すでにアプリをポルトガル語に翻訳しましたが、ローカライズされたコンテンツを提供するために翻訳者のためにウクライナのローカリゼーションカタログを送信する必要があります。

00:26:05.000 --> 00:26:15.000
まず、製品メニューのここをクリックし、ローカリゼーションのエクスポートを選択し、エクスポートする言語を選択します。

00:26:15.000 --> 00:26:18.000
この場合、ウクライナ語だけです。

00:26:18.000 --> 00:26:24.000
これで、エクスポートをクリックできます。

00:26:24.000 --> 00:26:29.000
彼らが私に翻訳を送り返したら、私はそれらを私のアプリにインポートすることができます。

00:26:29.000 --> 00:26:31.000
ああ、彼らはここにいます。

00:26:31.000 --> 00:26:52.000
翻訳の準備ができたら、アプリに戻り、今回は製品メニューをクリックし、ローカリゼーションのインポートを選択し、ウクライナのローカリゼーションカタログを選択します。

00:26:52.000 --> 00:26:58.000
さて、すべてがどのように見えるか見てみましょう。

00:26:58.000 --> 00:27:06.000
完璧です、私のウクライナ語の翻訳は整っています、そして今、私は両方の言語に完全にローカライズされた私のアプリを持っています。

00:27:06.000 --> 00:27:08.000
ポルトガル語でどのように見えるか見てみましょう。

00:27:08.000 --> 00:27:13.000
スキームセレクタをクリックし、[スキームの編集]を選択します。

00:27:13.000 --> 00:27:21.000
オプションでは、アプリの言語をシステムからポルトガル語に変更できます。

00:27:21.000 --> 00:27:37.000
そして、私はアプリを実行します。

00:27:37.000 --> 00:27:48.000
かっこいい、ここに私たちが一緒に働いた文字列のいくつかがあります。

00:27:48.000 --> 00:27:52.000
翻訳が終わったので、引き継いでください、マット。

00:27:52.000 --> 00:27:59.000
マット：アプリのコンテンツが完全に翻訳されたので、ビルド中に何が起こるかを簡単に議論しましょう。

00:27:59.000 --> 00:28:05.000
文字列カタログは、Xcodeプロジェクト内のインタラクションのために特別に設計されています。

00:28:05.000 --> 00:28:11.000
ボンネットの下のJSONファイルとして、ソース管理でも簡単に差分できるはずです。

00:28:11.000 --> 00:28:17.000
次に、ビルド時に、これらのファイルは.stringsと.stringsdictファイルにコンパイルされます。

00:28:17.000 --> 00:28:31.000
これらのファイル形式は長年にわたって当社のオペレーティングシステムでサポートされているため、最小展開目標を更新することなく、すぐに文字列カタログの使用を開始できることを嬉しく思います。

00:28:31.000 --> 00:28:37.000
また、コードから抽出されたソース文字列が最終ビルドに含まれていないことも注目に値します。

00:28:37.000 --> 00:28:43.000
これにより、実行時に表示される文字列に影響を与えることなく、ディスク容量を節約できるはずです。

00:28:43.000 --> 00:28:51.000
これらすべての利点が実際にあるのを見たので、マリーナは既存のプロジェクトでストリングカタログを使い始める方法を紹介します。

00:28:51.000 --> 00:28:57.000
Marina: Xcodeを使用すると、既存のプロジェクトを簡単に移行して文字列カタログを使用できます。

00:28:57.000 --> 00:28:59.000
そして、あなたは自分のペースでこれを行うことができます。

00:28:59.000 --> 00:29:04.000
準備ができたらいつでも、どの文字列ファイルとターゲットを移行するかを選択できます。

00:29:04.000 --> 00:29:09.000
これは、昨年ローカライズした既存のアプリ、FoodTruckです。

00:29:09.000 --> 00:29:13.000
ここでは、文字列とstringsdictファイルがあることがわかります。

00:29:13.000 --> 00:29:21.000
文字列カタログはレガシーフォーマットと共存できるため、準備ができたらいつでもLocalizableテーブルを移行することを選択できます。

00:29:21.000 --> 00:29:22.000
今これをやりましょう。

00:29:22.000 --> 00:29:28.000
ファイルを右クリックして「文字列カタログにマイグレーション」を選択します。

00:29:28.000 --> 00:29:35.000
Xcodeには、私のプロジェクト内のすべての移行可能なファイルを一覧表示する移行アシスタントが組み込まれています。

00:29:35.000 --> 00:29:41.000
ここでは、FoodTruckターゲットの一部であるローカライズ可能なテーブルを見ることができます。

00:29:41.000 --> 00:29:46.000
今からこれを移行します。

00:29:46.000 --> 00:29:51.000
いいね！移行後、Xcodeは文字列を抽出するためのプロジェクトを構築します。

00:29:51.000 --> 00:29:55.000
カタログがビルド後にどのように見えるか見てみましょう。

00:29:55.000 --> 00:30:03.000
ここでは、私の文字列ファイルのすべての文字列と、stringsdictファイルの複数形さえも移行されたことがわかります。

00:30:03.000 --> 00:30:11.000
私のアラビア語の翻訳はすべて整っていますが、ここではフランス語の翻訳の進捗状況が100%ではないことがわかります。

00:30:11.000 --> 00:30:16.000
文字列カタログは、すでに私のプロジェクトでローカライズされていない文字列を見つけるのに役立っています。

00:30:16.000 --> 00:30:22.000
FoodTruckには、まだローカライズされていない迅速なパッケージFoodTruckKitもあります。

00:30:22.000 --> 00:30:29.000
ストリングカタログを使えば、新しいパッケージやプロジェクトのローカライズを始めるのはとても簡単です。

00:30:29.000 --> 00:30:40.000
まず、パッケージマニフェストにデフォルトのローカリゼーションを追加し、Swift Toolsバージョン5.9を使用していることを確認します。

00:30:40.000 --> 00:30:51.000
次に、デフォルトのテーブル名「Localizable」で新しい文字列カタログをパッケージに追加します。

00:30:51.000 --> 00:30:56.000
プロジェクトを構築した後、パッケージ全体からすべての文字列を見ることができます。

00:30:56.000 --> 00:31:02.000
新しいプロジェクトやパッケージのローカライズを始めるのはとても簡単です。

00:31:02.000 --> 00:31:11.000
文字列カタログは、Xcodeのローカリゼーションの新しい基盤であり、プロジェクトの翻訳を管理するプロセスを簡素化します。

00:31:11.000 --> 00:31:14.000
既存の文字列を移行して、今日から始められることを願っています。

00:31:14.000 --> 00:31:21.000
そして、これまでにアプリをローカライズしたことがないなら、始めるのがいかに簡単かに触発されることを願っています。

00:31:21.000 --> 00:31:23.000
Obrigada pela companhia hoje.

00:31:23.000 --> 00:31:26.000
私たちに参加してくれてありがとう、そして幸せなバードウォッチング。

00:31:26.000 --> 23:59:59.000
♪ ♪

