WEBVTT

00:00:00.000 --> 00:00:03.000
♪まろやかなインストゥルメンタルヒップホップ♪

00:00:03.000 --> 00:00:10.000
♪

00:00:10.000 --> 00:00:14.000
こんにちは、私の名前はロイで、パフォーマンスチームのエンジニアです。

00:00:14.000 --> 00:00:19.000
今日は、空間コンピューティングのためにアプリを最適化する方法を学びます。

00:00:19.000 --> 00:00:25.000
まず、パフォーマンスとパワーに関するこの新しいプラットフォームのユニークな側面を見ていきます。

00:00:25.000 --> 00:00:31.000
次に、アプリのプロファイリングから始めて、パフォーマンスプランの構築に進みます。

00:00:31.000 --> 00:00:39.000
そして最後に、このプラットフォームのパフォーマンスの問題を最適化するための最良の方法を見学します。

00:00:39.000 --> 00:00:44.000
では、パワーとパフォーマンスで空間コンピューティングが異なる理由は何ですか?

00:00:44.000 --> 00:00:51.000
1つは、アプリのアップデートに関係なく、ディスプレイ上のコンテンツは常に更新されます。

00:00:51.000 --> 00:00:57.000
人々が体、手、目を動かすたびに、コンテンツを更新する必要があります。

00:00:57.000 --> 00:01:04.000
これは、システムが常にすべてのフレームをレンダリングしていることを意味します。

00:01:04.000 --> 00:01:17.000
また、プラットフォームは常に空間アルゴリズムを実行して、すべてのアプリでビジュアルとインタラクションを作成し、同時に複数のアプリを実行できます。

00:01:17.000 --> 00:01:20.000
人々はあなたのアプリを他のアプリと一緒に使うでしょう。

00:01:20.000 --> 00:01:28.000
マルチタスクと追加のシステム作業を処理するには、自分のアプリのリソース使用量をできるだけ最適化してください。

00:01:28.000 --> 00:01:35.000
優れたユーザーエクスペリエンスを提供するには、アプリのパフォーマンスが不可欠です。

00:01:35.000 --> 00:01:45.000
人々は、アプリが入力に即座に反応し、没入感と快適さのためにスムーズな視覚的な更新を提供することを望んでいます。

00:01:45.000 --> 00:01:52.000
パフォーマンスの問題についてアプリをプロファイリングして分析する方法について話しましょう。

00:01:52.000 --> 00:01:58.000
あなたはすでに他のAppleプラットフォームのパフォーマンス指標に精通しているかもしれません。

00:01:58.000 --> 00:02:06.000
どのプラットフォームでも、人々はすぐに起動し、ディスクの摩耗を避け、バッテリーを使いすぎないアプリを望んでいます。

00:02:06.000 --> 00:02:11.000
彼らはまた、非効率的なメモリ使用による終了を回避するアプリを望んでいます。

00:02:11.000 --> 00:02:17.000
空間コンピューティングでは、これらの指標のいくつかは新しい意味を持ちます。

00:02:17.000 --> 00:02:18.000
権力を握る。

00:02:18.000 --> 00:02:25.000
ユーザーは、バッテリー寿命ではなく、熱圧力のために、電力用に最適化されたアプリを望んでいます。

00:02:25.000 --> 00:02:36.000
優れたパフォーマンスを維持するために、熱圧力に遭遇する可能性を減らすために、システムの電力使用に合わせてアプリを最適化する必要があります。

00:02:36.000 --> 00:02:38.000
ハングは別の例です。

00:02:38.000 --> 00:02:44.000
それらは、アプリのメインスレッドが一定期間作業を停止しているときに発生します。

00:02:44.000 --> 00:02:51.000
しかし、このプラットフォームでは、小さくて瞬間的な屋台でさえ、応答性を混乱させます。

00:02:51.000 --> 00:02:54.000
では、レンダリングを検討してください。

00:02:54.000 --> 00:03:02.000
他のプラットフォームでは、主にスムーズなUIと3Dアニメーションを提供するために、レンダリングパフォーマンスを最適化することができます。

00:03:02.000 --> 00:03:12.000
しかし、ここでは、システムは常にレンダリングされているため、レンダリングパフォーマンスは静的コンテンツにも不可欠です。

00:03:12.000 --> 00:03:17.000
すべてのAppleプラットフォームは、これらの指標をプロファイリングするためのツールを提供します。

00:03:17.000 --> 00:03:23.000
今日は、空間コンピューティングアプリに特化したパフォーマンスの問題の発見について説明します。

00:03:23.000 --> 00:03:34.000
しかし、Appleプラットフォームでこれらの指標を最適化する方法の詳細については、「究極のアプリケーションパフォーマンスサバイバルガイド」セッションをご覧ください。

00:03:34.000 --> 00:03:42.000
アプリを最適化するには、InstrumentsやXcode Gaugesなどのツールを使用して、開発中にプロファイルします。

00:03:42.000 --> 00:03:49.000
アプリがリリースされたら、フィールドからより多くのデータを収集して、アプリをさらに最適化するのに役立ちます。

00:03:49.000 --> 00:03:54.000
開発中のプロファイリングについてもっと話しましょう。

00:03:54.000 --> 00:04:03.000
RealityKit Traceは、パフォーマンスとパワーのためにあらゆる空間コンピューティングアプリをプロファイリングするのに役立つInstrumentsの真新しいテンプレートです。

00:04:03.000 --> 00:04:14.000
これは、アプリのレンダリングパフォーマンスが低いとき、または高いシステム電力使用を引き起こしているときに識別するのに役立つ素晴らしいツールです。

00:04:14.000 --> 00:04:18.000
他にも使える楽器のテンプレートがたくさんあります。

00:04:18.000 --> 00:04:26.000
詳細を学び、この新しいテンプレートを実際に探索するには、「Meet RealityKit Trace」のセッションをご覧ください。

00:04:26.000 --> 00:04:31.000
アプリのパフォーマンスとパワーは、誰かがそれとどのようにやり取りするかによって異なります。

00:04:31.000 --> 00:04:39.000
シミュレータは実際のデバイスと同じ作業を実行しないため、パフォーマンスデータが正確ではない可能性があります。

00:04:39.000 --> 00:04:41.000
デバイス内のプロファイル。

00:04:41.000 --> 00:04:50.000
オーディオやビデオを再生するとき、またはFaceTimeやペルソナなどのテクノロジーを使用するときに、アプリでさまざまなインタラクションを使用するプロファイル。

00:04:50.000 --> 00:04:57.000
使用数分にわたって、良好なパフォーマンスと低いシステム電力を確認してください。

00:04:57.000 --> 00:05:04.000
最後に、他のアプリも実行され、リソースを使用している間にプロファイリングしてみてください。

00:05:04.000 --> 00:05:14.000
互換性のあるiPadとiPhoneのアプリを持ち込む場合は、デバイス上でそれらをプロファイリングして、必要なさらなる最適化を特定してください。

00:05:14.000 --> 00:05:20.000
開発後、人々はさまざまな条件でアプリを実行する可能性があります。

00:05:20.000 --> 00:05:27.000
現場からのデータは、人々が実際に遭遇している問題を見つけるのに最適な方法です。

00:05:27.000 --> 00:05:35.000
アプリがベータ版または公開されている場合は、MetricKitを使用してユーザーから診断レポートを取得します。

00:05:35.000 --> 00:05:47.000
Xcodeオーガナイザーは、電力の問題を見つけるのに役立つエネルギー診断を含む、同意したユーザーのデバイスから集約されたパフォーマンスデータを提供します。

00:05:47.000 --> 00:05:55.000
収集するこれらのデータはすべて、ボトルネックを見つけ、アプリのパフォーマンス作業に優先順位を付けるのに役立ちます。

00:05:55.000 --> 00:06:00.000
では、空間コンピューティングアプリの最適化について話しましょう。

00:06:00.000 --> 00:06:04.000
パフォーマンスの問題は、多くの分野から発生する可能性があります。

00:06:04.000 --> 00:06:19.000
今日は、レンダリング、ユーザー入力、ARKit、オーディオとビデオの再生、SharePlay、システムプレッシャーによるアプリの終了など、いくつかのコア領域を最適化するための戦略について説明します。

00:06:19.000 --> 00:06:26.000
優れたレンダリングパフォーマンスは、優れたユーザーエクスペリエンスのための最優先事項の1つです。

00:06:26.000 --> 00:06:28.000
飛び込みましょう。

00:06:28.000 --> 00:06:37.000
このプラットフォームでは、レンダリングパイプラインはアプリから始まり、アプリのコンテンツの更新を担当します。

00:06:37.000 --> 00:06:45.000
すべてのAppleプラットフォームと同様に、アプリのインターフェースはメインスレッドで更新され、速やかに更新を提供する必要があります。

00:06:45.000 --> 00:06:55.000
アプリは他のアプリと一緒に3Dスペースでレンダリングされるため、その更新はシステムレンダリングサーバーに送信されます。

00:06:55.000 --> 00:07:05.000
レンダリングサーバーは、アプリ、ユーザーの入力、およびそのスペースとその周辺からの更新を処理するために継続的に実行されています。

00:07:05.000 --> 00:07:12.000
これらすべての更新で新しいフレームをレンダリングし、コンポジターに送信します。

00:07:12.000 --> 00:07:15.000
コンポジターは常にレンダリングしています。

00:07:15.000 --> 00:07:21.000
ディスプレイのリフレッシュレートに一致する速度で新しいフレームをディスプレイに供給します。

00:07:21.000 --> 00:07:24.000
これは快適な体験を提供するのに役立ちます。

00:07:24.000 --> 00:07:31.000
このレートは通常1秒間に90フレームですが、より高くなる可能性があります。

00:07:31.000 --> 00:07:40.000
コンポジターはディスプレイを一貫して更新しますが、優れたユーザーエクスペリエンスには、アプリからの迅速な視覚的な更新が必要です。

00:07:40.000 --> 00:07:50.000
アプリにレンダリングに時間がかかりすぎるコンテンツやアップデートがある場合、レンダリングサーバーは最適なレンダリングレイテンシーのレンダリング期限を逃す可能性があります。

00:07:50.000 --> 00:07:59.000
これは、アプリのビジュアルがフレームYのコンポジターにたどり着いたかもしれないが、代わりにフレームY+1にたどり着いたことを意味します。

00:07:59.000 --> 00:08:07.000
これにより、人々がディスプレイで見る視覚的な更新が遅れ、アプリの応答性が低下します。

00:08:07.000 --> 00:08:14.000
特に深刻なレンダリングストールにより、アプリが終了することさえあります。

00:08:14.000 --> 00:08:28.000
アプリがSwiftUI、UIKit、RealityKit、またはMetalで構築されているかどうかにかかわらず、フレームドロップとレンダリングサーバーでの作業を減らすために、コンテンツと更新を最適化したいと考えています。

00:08:28.000 --> 00:08:33.000
SwiftUIとUIKitの使用を最適化することから始めましょう。

00:08:33.000 --> 00:08:40.000
このプラットフォームでは、アプリはアップデートがなくても、静的なUIコンテンツの作業をシステムがレンダリングします。

00:08:40.000 --> 00:08:44.000
このレンダリング作業は、オーバードローから増加する可能性があります。

00:08:44.000 --> 00:08:50.000
オーバードローは、他の仮想コンテンツの前に半透明のコンテンツがある場合に発生します。

00:08:50.000 --> 00:09:04.000
GPUは両方のコンテンツをレンダリングするために作業を行う必要がありますが、その半透明のコンテンツが完全に不透明であれば、GPUはその背後にUIをレンダリングする必要はありません。

00:09:04.000 --> 00:09:11.000
Zオフセットで重複するUIビューがある場合は、半透明性を追加しないでください。

00:09:11.000 --> 00:09:20.000
また、アプリのUIが占有するディスプレイのピクセル数が多いほど、ウィンドウをレンダリングする作業が増えます。

00:09:20.000 --> 00:09:24.000
デフォルトのサイズを減らすことを検討してください。

00:09:24.000 --> 00:09:37.000
レンダリングサーバーでのUIの再描画は通常、アプリの更新によってトリガーされますが、このプラットフォームでは、コアアニメーションレイヤーの動的コンテンツスケーリングによってもトリガーされます。

00:09:37.000 --> 00:09:49.000
この動作では、テキストの解像度、またはベクトルベースのUIコンテンツは、ユーザーがよりシャープなビジュアルを可能にしようとしている場所に基づいて変化します。

00:09:49.000 --> 00:09:59.000
これはまた、アプリのアップデートがなくても、潜在的により高いスケールでUIコンテンツのより頻繁な再描画につながる可能性があります。

00:09:59.000 --> 00:10:10.000
SwiftUIとUIKitはデフォルトでこの動作を有効にしますが、カスタムコアアニメーションまたはコアグラフィックスレンダリングを行うアプリはこの動作にオプトインできます。

00:10:10.000 --> 00:10:19.000
視覚的な利点とトレードオフの詳細については、セッション「空間コンピューティングのレンダリングを探る」をご覧ください。

00:10:19.000 --> 00:10:23.000
これらの再描画のコストは、オフスクリーンレンダリングパスによって大きく影響を受けます。

00:10:23.000 --> 00:10:29.000
これは、影、ぼかし、マスキングなどの視覚効果によって引き起こされる可能性があります。

00:10:29.000 --> 00:10:34.000
これらの効果を減らして、システムがアプリをレンダリングしやすくします。

00:10:34.000 --> 00:10:40.000
アプリの再描画を最小限に抑えるために、可能な限り不要なビューの更新を避けてください。

00:10:40.000 --> 00:10:44.000
たとえば、SwiftUIでは、@Observableを使用します。

00:10:44.000 --> 00:10:51.000
@Observableは、より詳細な変更追跡を提供し、不要なレイアウトの更新を減らします。

00:10:51.000 --> 00:10:58.000
次に、RealityKitによる3Dレンダリングの最適化について話しましょう。

00:10:58.000 --> 00:11:03.000
SwiftUIは今年、空間コンピューティングのためにRealityViewを追加しました。

00:11:03.000 --> 00:11:10.000
SwiftUI階層内でRealityKit 3Dシーンをネイティブに表示できます。

00:11:10.000 --> 00:11:18.000
あなたのアプリは、これらのRealityKit機能のすべてに対して3Dシーンを最適化することで、プラットフォーム上の善良な市民でなければなりません。

00:11:18.000 --> 00:11:27.000
これらの3Dシーンでは、それらに含まれるアセットの複雑さは、各フレームで行われるレンダリングサーバー作業の量を大幅に増やすことができます。

00:11:27.000 --> 00:11:31.000
では、これらの資産を最適化することから始めましょう。

00:11:31.000 --> 00:11:37.000
Reality Composer Proは、アセットからRealityKitのシーンを作成するのに役立ちます。

00:11:37.000 --> 00:11:50.000
メッシュレンダリング、パーティクル、アニメーション、物理学、オーディオ作業から、このツールは、パフォーマンスへの影響を理解するのに役立つシーン全体に関する統計を提供します。

00:11:50.000 --> 00:11:58.000
これらの統計を調べるとき、数字が低いことは通常、作業が少ないことを意味し、レンダリングパフォーマンスを向上させることができます。

00:11:58.000 --> 00:12:10.000
「クイックルック空間体験のための3Dモデルを作成する」セッションを見て、ビジュアルと3Dアセットのパワー使用のベストプラクティスについて詳しく学んでください。

00:12:10.000 --> 00:12:15.000
特にメッシュレンダリングは、3Dレンダリングの中核部分です。

00:12:15.000 --> 00:12:21.000
複雑なメッシュや材料は、すぐにパフォーマンスのボトルネックになる可能性があります。

00:12:21.000 --> 00:12:24.000
メッシュ資産のジオメトリを最適化します。

00:12:24.000 --> 00:12:30.000
材料を共有する部品を組み合わせることで、別々のメッシュ部品の量を減らします。

00:12:30.000 --> 00:12:36.000
三角形と頂点数の高いメッシュジオメトリもコストがかかる場合があります。

00:12:36.000 --> 00:12:39.000
必要に応じて、より少ないカウントで資産を使用してください。

00:12:39.000 --> 00:12:43.000
3Dメッシュでオーバードローの影響を最小限に抑えます。

00:12:43.000 --> 00:12:49.000
これを行うには、UIコンテンツと同様に透明性を控えめに使用してください。

00:12:49.000 --> 00:13:00.000
Reality Composer Proの「Physically Based」素材は、環境照明を持ち、よく最適化されており、最小限の透明性でメッシュに最適です。

00:13:00.000 --> 00:13:12.000
しかし、半透明または非常に大きなコンテンツの場合は、照らされていない表面を持つカスタム素材を使用し、焼きたての照明テクスチャやその他の安価なビジュアルを使用することを検討してください。

00:13:12.000 --> 00:13:18.000
これは、より高価な照明計算で潜在的なボトルネックを回避するのに役立ちます。

00:13:18.000 --> 00:13:26.000
RealityKitでの材料の構築と使用に関する詳細なガイダンスについては、これら2つのセッションをご覧ください。

00:13:26.000 --> 00:13:30.000
ランタイムレンダリング用に最適化されたコンテンツを持つことは、素晴らしいスタートです。

00:13:30.000 --> 00:13:37.000
しかし、RealityKitでアプリを最適化するためにできることはさらにあります。

00:13:37.000 --> 00:13:46.000
アプリがRealityKitのコンテンツを更新すると、更新がレンダリングサーバーに送信され、レンダリングされます。

00:13:46.000 --> 00:13:52.000
しかし、短期間で更新が多すぎると、レンダリングサーバーのボトルネックになる可能性があります。

00:13:52.000 --> 00:13:59.000
たとえば、アプリはRealityKitエンティティを急速に作成および破壊している可能性があります。

00:13:59.000 --> 00:14:10.000
複雑なアニメーションが多すぎるか、SwiftUIビューの更新が多すぎるか、1つのフレームに多くのアセットをロードしている可能性があります。

00:14:10.000 --> 00:14:15.000
事前にエンティティを作成し、必要に応じて非表示または表示します。

00:14:15.000 --> 00:14:21.000
それらを削除してシーン階層に追加したり、isEnabledフラグを使用したりできます。

00:14:21.000 --> 00:14:28.000
メッシュエンティティ階層を平坦化することで、更新されるエンティティの量を最小限に抑えます。

00:14:28.000 --> 00:14:37.000
コードベースのアニメーションについては、更新率を下げるか、アニメーションが更新するエンティティの数を減らすことを検討してください。

00:14:37.000 --> 00:14:44.000
そして、RealityKitエンティティを更新するときは、誤って過度のSwiftUI再描画をトリガーしないでください。

00:14:44.000 --> 00:14:54.000
添付ファイルを使用する場合は、すべてのSwiftUIコンテンツを最適化するのと同じ方法でレンダリングを最適化してください。

00:14:54.000 --> 00:14:59.000
複雑なアセットをロードすると、高価なレンダリング更新が発生することもあります。

00:14:59.000 --> 00:15:05.000
複雑な資産は、高いアプリの起動時間とコンテンツの読み込み時間にも貢献する可能性があります。

00:15:05.000 --> 00:15:15.000
実行時に非同期ロードAPIを使用して、メインスレッドをブロックしないようにし、必要になる前にアセットをロードします。

00:15:15.000 --> 00:15:22.000
同じ資産を使用するエンティティも、その資産を共有し、一度しかロードできません。

00:15:22.000 --> 00:15:30.000
これらのファイルは読み込み時間とメモリコストに最適化されているため、Reality Composer Proからエクスポートされたファイルを使用してください。

00:15:30.000 --> 00:15:34.000
また、テクスチャ圧縮も無料で入手できます。

00:15:34.000 --> 00:15:47.000
アセットサイズを減らすと、通常、読み込みが高速化されますが、テクスチャ圧縮はすでにReality Composer Proファイルで行われているため、自分で行う必要はないことを覚えておいてください。

00:15:47.000 --> 00:15:52.000
最後に、RealityKitの没入型体験について話しましょう。

00:15:52.000 --> 00:16:00.000
アプリが専用のフルスペースへの移行をリクエストすると、実行中の唯一のフォアグラウンドエクスペリエンスになります。

00:16:00.000 --> 00:16:10.000
ポータルを使用したり、完全に没入型の体験に移行したりすると、システムは周囲の環境の一部または全部も隠します。

00:16:10.000 --> 00:16:17.000
アプリは、RealityKitコンテンツで環境を作成してスペースを埋めることができます。

00:16:17.000 --> 00:16:25.000
完全に没入型のコンテンツは、共有スペースやフルスペースのシーンよりも、ディスプレイ上ではるかに多くのピクセルにレンダリングする必要があります。

00:16:25.000 --> 00:16:31.000
これは、そのコンテンツをレンダリングするためにGPUでより多くの作業を行うことができることを意味します。

00:16:31.000 --> 00:16:35.000
GPUの電力使用のためにこのタイプのコンテンツを最適化します。

00:16:35.000 --> 00:16:42.000
最適な電力使用のために、Reality Composer Proの照らされていない表面を持つ「カスタム」素材から始めましょう。

00:16:42.000 --> 00:16:50.000
代わりに、焼きたての照明テクスチャを追加するか、時間ベースのアニメーションを使用して、ダイナミックな照明の感触を得ることを検討してください。

00:16:50.000 --> 00:16:56.000
システムパワーとレンダリングパフォーマンスのマテリアルをプロファイリングします。

00:16:56.000 --> 00:17:01.000
また、Metalで完全に没入感のある体験を作成することもできます。

00:17:01.000 --> 00:17:09.000
3Dエンジンを構築したり、Metalを使った経験をしたりする人のために、最適化すべきいくつかのことについて話しましょう。

00:17:09.000 --> 00:17:19.000
CompositorServicesフレームワークでMetalを使用して、レンダリングサーバーをバイパスし、レンダリングされたサーフェスをコンポジターに直接送信できます。

00:17:19.000 --> 00:17:26.000
セッション「没入型アプリのMetalを発見」を見て、これを適切に行う方法を学んでください。

00:17:26.000 --> 00:17:36.000
CompositorServicesを使用する場合は、Metalフレームの提出のペースを調整して、compositorが更新のたびに新しいフレームを受け取るようにします。

00:17:36.000 --> 00:17:41.000
必ず新しいフォベーションマップを照会し、各フレームの予測を投稿してください。

00:17:41.000 --> 00:17:48.000
そして、GPU作業をエンコードするために使用し始める前に、最後の瞬間にこの入力データを照会します。

00:17:48.000 --> 00:17:57.000
これら3つすべてを実行すると、ユーザーの動きと入力に関連して応答性の高い仮想コンテンツを確保するのに役立ちます。

00:17:57.000 --> 00:18:03.000
アプリが新しいフレームの提出に時間がかかりすぎると、システムはそれを終了します。

00:18:03.000 --> 00:18:06.000
長いフレームのストールは避けてください。

00:18:06.000 --> 00:18:14.000
アプリの実行中は、Metal System Trace Instrumentsテンプレートを使用してGPUのパフォーマンスをプロファイリングしてください。

00:18:14.000 --> 00:18:27.000
MetalアプリまたはReality Composer Proを使用したカスタムマテリアルからの長時間のフラグメントと頂点シェーダーの実行は、システムのレンダリング時間に大きな影響を与える可能性があります。

00:18:27.000 --> 00:18:36.000
フラグメントと頂点の時間を短縮するには、シェーダーによるALU命令とテクスチャアクセスを減らすことから始めます。

00:18:36.000 --> 00:18:41.000
金属の場合は、可能な限り代わりに計算シェーダーを使用してください。

00:18:41.000 --> 00:18:47.000
これらの講演を確認して、GPUパフォーマンスの最適化について詳しく学んでください。

00:18:47.000 --> 00:18:57.000
UIと3Dレンダリングのパフォーマンスのためにアプリを最適化することは、全体的なユーザーエクスペリエンスに利益をもたらすことを覚えておいてください。

00:18:57.000 --> 00:19:00.000
それでは、入力パフォーマンスに移りましょう。

00:19:00.000 --> 00:19:08.000
人々はこのプラットフォームで目、手、音声、ハードウェア入力を使用できます。

00:19:08.000 --> 00:19:12.000
入力に対するアプリの更新は、メインスレッドで処理されます。

00:19:12.000 --> 00:19:19.000
これらに時間がかかりすぎると、アプリが遅くて反応しなくなると感じます。

00:19:19.000 --> 00:19:26.000
メインスレッドの入力更新は、ディスプレイのリフレッシュレートに基づいて特定の期限内に完了する必要があります。

00:19:26.000 --> 00:19:32.000
このプラットフォームのハードウェアのリフレッシュレートは通常90ヘルツ以上です。

00:19:32.000 --> 00:19:39.000
90ヘルツのリフレッシュレートでは、最適なレイテンシのために入力更新を8ミリ秒未満に保ちます。

00:19:39.000 --> 00:19:50.000
空間コンテンツと対話するとき、システムは、ユーザーが対話しようとしているUIまたは3Dオブジェクトを確認するためのテスト作業をヒットします。

00:19:50.000 --> 00:19:56.000
RealityKitのコンテンツでは、物理コライダーを追加して対話します。

00:19:56.000 --> 00:20:06.000
これらのコライダーを追加するときは、静的衝突器の方が安いので、可能な限り動的衝突器の上に静的衝突器を使用してください。

00:20:06.000 --> 00:20:13.000
アプリでの冗長なヒットテスト作業を減らすために、インタラクティブなコンテンツの重複を最小限に抑えます。

00:20:13.000 --> 00:20:17.000
では、ARKitに移りましょう。

00:20:17.000 --> 00:20:26.000
このプラットフォームでは、ARKitアルゴリズムは常に実行され、すべてのアプリでビジュアルとインタラクションを作成しています。

00:20:26.000 --> 00:20:36.000
アプリは、ARKitデータの使用方法と仮想コンテンツのアンカー方法に基づいて、システムのパワーと視覚的な滑らかさに影響を与える可能性があります。

00:20:36.000 --> 00:20:46.000
たとえば、アプリはARKitまたはRealityKitを使用して、ユーザーの周囲、頭、または手にアンカーコンテンツを配置できます。

00:20:46.000 --> 00:20:50.000
すべてのアンカーは、システムに追加の作業を追加します。

00:20:50.000 --> 00:20:57.000
コンテンツをアンカーするときは、アンカーをユーザーのスペースで継続的に追跡する必要があるかどうかを検討してください。

00:20:57.000 --> 00:21:05.000
RealityKitでAnchorComponentを使用する場合は、「一度」追跡モードを使用して、継続的な追跡コストを回避します。

00:21:05.000 --> 00:21:12.000
アプリからの永続的および一時的なアンカーの総量を最小限に抑えます。

00:21:12.000 --> 00:21:20.000
特に永続的なアンカーの場合、すべてのアプリがそれらを追加できるので、自分のアプリからあまり多く追加しないようにしてください。

00:21:20.000 --> 00:21:26.000
ARKitデータを使用している間、さらに多くの最適化を行うことができます。

00:21:26.000 --> 00:21:35.000
アプリのコンテンツに古すぎるARKitデータを適用すると、アプリのビジュアルが入力と同期していないように見えることがあります。

00:21:35.000 --> 00:21:42.000
ARKitデータを使用する必要がある直前にクエリし、速やかに更新に適用します。

00:21:42.000 --> 00:21:46.000
ポスト予測は計算に費用がかかります。

00:21:46.000 --> 00:21:51.000
一般的に、カスタムメタルレンダリングエンジンのみがこのデータを必要とします。

00:21:51.000 --> 00:21:57.000
アプリのコンテンツをシーンに配置したいだけなら、RealityKitは代わりに素晴らしい選択です。

00:21:57.000 --> 00:22:03.000
シーン理解メッシュのための衝突データの生成も高価です。

00:22:03.000 --> 00:22:09.000
このデータを使用する場合は、アプリが不要になったときにオフにしてください。

00:22:09.000 --> 00:22:16.000
では、空間コンピューティングのためのオーディオとビデオの再生の最適化について話しましょう。

00:22:16.000 --> 00:22:20.000
このプラットフォームでは、空間オーディオがデフォルトで使用されます。

00:22:20.000 --> 00:22:30.000
システムは、ユーザーの位置、周囲、およびオーディオソースに関する情報をリアルタイムで処理し、オーディオを出力します。

00:22:30.000 --> 00:22:40.000
アプリが空間オーディオ作業を引き起こしすぎると、システム電力の使用に問題が発生したり、オーディオ出力が遅れたりする可能性があります。

00:22:40.000 --> 00:22:55.000
これらの問題が発生した場合、空間オーディオ作業を減らすために検討すべき3つの主なことがあります。オーディオソースの同時再生、移動オーディオソースの数、およびサウンドステージのサイズです。

00:22:55.000 --> 00:23:01.000
これらはすべて、計算作業を増やすことができる変数です。

00:23:01.000 --> 00:23:03.000
さて、ビデオを考えてみましょう。

00:23:03.000 --> 00:23:08.000
共有スペースでは、一度に複数のビデオを再生できます。

00:23:08.000 --> 00:23:15.000
ビデオごとに、システムはそれをデコードし、レンダリングサーバーでレンダリングする必要があります。

00:23:15.000 --> 00:23:25.000
それぞれの新しいレンダリングされたビデオフレームは、素晴らしいビデオ視聴体験のために、一貫した間隔でディスプレイに表示する必要があります。

00:23:25.000 --> 00:23:37.000
レンダリングサーバーにレンダリング期限に間に合うように多くの電力と時間を与えるために、アプリはビデオ再生中のUIまたは3Dコンテンツの更新を最小限に抑える必要があります。

00:23:37.000 --> 00:23:41.000
ビデオフレームレートは、完了した作業にも影響します。

00:23:41.000 --> 00:23:47.000
最適なパフォーマンスとパワーのために、24または30ヘルツのビデオを使用することを検討してください。

00:23:47.000 --> 00:23:58.000
最後に、いつでもアプリからデバイスで再生およびレンダリングする必要がある同時ビデオの数を減らします。

00:23:58.000 --> 00:24:06.000
ビデオプレゼンテーション方法を選択するときは、さまざまな機能とパフォーマンスを最適化する方法を検討してください。

00:24:06.000 --> 00:24:12.000
詳細については、「素晴らしい空間再生体験を作成する」セッションをご覧ください。

00:24:12.000 --> 00:24:16.000
では、SharePlayについて話しましょう。

00:24:16.000 --> 00:24:23.000
このプラットフォームは、人々と協力し、つながるためのまったく新しい経験を開きます。

00:24:23.000 --> 00:24:34.000
本当に素晴らしいSharePlayグループ体験を作成するには、アプリが長期間にわたって優れたパフォーマンスを維持できるようにしたいと考えています。

00:24:34.000 --> 00:24:40.000
そして、SharePlayによる優れた空間コンピューティングパフォーマンスは、基本から始まります。

00:24:40.000 --> 00:24:44.000
まず、ローカルパフォーマンスのためにアプリをプロファイリングして最適化します。

00:24:44.000 --> 00:24:54.000
次に、SharePlay中にアプリのパフォーマンスを調べて、高価なレンダリングアップデートがデバイス間で同期されるのを防ぎます。

00:24:54.000 --> 00:25:06.000
システムの電力ニーズが熱圧力を引き起こさないように、アプリの電力プロファイルを作成し、アプリが優れたパフォーマンスを維持するのを防ぐことができます。

00:25:06.000 --> 00:25:19.000
これを助けるために、アプリのSharePlay体験に不可欠なアプリの作業と機能を慎重に検討し、必要のないものはすべてオフにしてください。

00:25:19.000 --> 00:25:25.000
最後に、熱圧力またはメモリ圧力によるアプリの終了を見てみましょう。

00:25:25.000 --> 00:25:29.000
人々は暖かい場所でこの装置を使うかもしれない。

00:25:29.000 --> 00:25:42.000
すべてのAppleプラットフォームと同様に、このシステムは、使用時にデバイスを涼しく快適に保つために、熱圧力下で利用可能な計算リソースを管理します。

00:25:42.000 --> 00:25:48.000
計算リソースが少ないと、アプリのパフォーマンスに影響を与える可能性があります。

00:25:48.000 --> 00:25:59.000
システムは、重大な熱圧力、またはレンダリングの期限が満たされなくなったため、アプリを終了することさえあります。

00:25:59.000 --> 00:26:09.000
熱圧力下にあるときは、良好なパフォーマンスを維持し、熱圧力がさらに上昇するのを防ぐために、アプリでの作業を減らしてください。

00:26:09.000 --> 00:26:15.000
これを行うには、sthermalStateDidChange通知を購読します。

00:26:15.000 --> 00:26:22.000
プレッシャーが高まったら、それに応じてアプリのコンテンツとアップデートを適応させます。

00:26:22.000 --> 00:26:32.000
熱圧力下でアプリがどのように機能するかを確認するには、Xcodeで熱誘導器を使用して、デバイスのより高い熱状態をシミュレートします。

00:26:32.000 --> 00:26:41.000
熱圧力の詳細については、セッション「有害なネットワークと温度条件の設計」をチェックしてください。

00:26:41.000 --> 00:26:44.000
次に、記憶力の圧力について話しましょう。

00:26:44.000 --> 00:26:52.000
デバイスは、システムと実行中のすべてのアプリの間で共有されるメモリ量が限られています。

00:26:52.000 --> 00:27:02.000
デバイスがこの制限に近づくと、システムは積極的に使用されていないアプリから始めて、アプリを終了し始めます。

00:27:02.000 --> 00:27:09.000
メモリを使いすぎる単一のアプリも、使用されていても終了する可能性があります。

00:27:09.000 --> 00:27:13.000
あなたはこれがあなたのアプリで起こることを望んでいません。

00:27:13.000 --> 00:27:19.000
アプリのメモリ使用量をできるだけ減らすことで、これを避けることができます。

00:27:19.000 --> 00:27:29.000
このプラットフォームでは、アプリはUIと3Dレンダリング、オーディオとビデオの再生に大量のメモリが割り当てられる可能性が高くなります。

00:27:29.000 --> 00:27:41.000
アプリにUIコンテンツがある場合は、画面外でのレンダリングパス、ウィンドウの総量、メディアコンテンツを最小限に抑えることで、レンダリングメモリの割り当てを減らします。

00:27:41.000 --> 00:27:53.000
RealityKitを使用した3Dメモリの場合、メッシュとパーティクルのテクスチャとジオメトリサイザーの解像度は、メモリの使用に大きく貢献できます。

00:27:53.000 --> 00:27:57.000
可能な限りそれらを減らしてください。

00:27:57.000 --> 00:28:05.000
オーディオとビデオを再生するときは、アプリ内のすべてのオーディオとビデオファイルからの総メモリ負荷を評価します。

00:28:05.000 --> 00:28:17.000
解像度、ビットレート、ファイル形式、および期間を変更するときは、メモリの節約に対するユーザーエクスペリエンスとパフォーマンスのトレードオフを考慮してください。

00:28:17.000 --> 00:28:26.000
これらの講演を確認して、すべてのAppleプラットフォームでメモリフットプリントを削減するためのヒントを学んでください。

00:28:26.000 --> 00:28:33.000
このプラットフォームで優れたユーザーエクスペリエンスを得るには、パフォーマンスが不可欠であることを覚えておいてください。

00:28:33.000 --> 00:28:41.000
開始するには、開発中にアプリを積極的にプロファイリングして、パフォーマンスと電力の問題を見つけてください。

00:28:41.000 --> 00:28:46.000
空間コンピューティングの重要な指標に関するパフォーマンスプランを作成します。

00:28:46.000 --> 00:28:53.000
そして、レンダリング、パワー、そして今日取り上げた他のすべての分野のためにアプリを最適化します。

00:28:53.000 --> 00:29:01.000
そして最後に、MetricKitやXcode Organizerなどのツールを使用してパフォーマンスフィールドデータを収集します。

00:29:01.000 --> 00:29:07.000
このプラットフォームで思いついたすべての素晴らしいアプリや体験を見るのが待ちきれません。

00:29:07.000 --> 00:29:08.000
見てくれてありがとう。

00:29:08.000 --> 23:59:59.000
♪

