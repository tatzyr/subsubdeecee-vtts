WEBVTT

00:00:10.000 --> 00:00:12.000
ジュリア：こんにちは！私の名前はジュリアです。

00:00:12.000 --> 00:00:14.000
私はSwiftUIエンジニアです。

00:00:14.000 --> 00:00:20.000
最近、Swiftでモデルレイヤーを永続化する新しい方法であるSwiftDataを導入しました。

00:00:20.000 --> 00:00:33.000
今日のセッションでは、SwiftUIアプリにSwiftDataをシームレスに統合する方法を見てみましょう。SwiftDataモデルとのスムーズな統合を可能にする新しいSwiftUI機能について説明します。

00:00:33.000 --> 00:00:38.000
基本をカバーするために、まだ見ていない場合は、まず「Meet SwiftData」セッションをご覧ください。

00:00:38.000 --> 00:00:44.000
SwiftDataとSwiftUIがどのように一緒にプレイするかを見るために、フラッシュカードアプリを作りましょう。

00:00:44.000 --> 00:00:53.000
しばらくの間、私は偉大な発明の日付や著者を覚えるのに役立つツールを作りたいと思っていましたが、SwiftDataはこのタスクに最適です。

00:00:53.000 --> 00:01:00.000
フラッシュカードデッキを永続化するのに役立ちますので、時間があるときにいつでも開いてクリックすることができます。

00:01:00.000 --> 00:01:08.000
このアプリをどこでも動作させたい：Mac、iPhone、Watch、TV、そしてSwiftDataが私の背中を持っています。

00:01:08.000 --> 00:01:12.000
それはすべてのプラットフォームで利用可能です。

00:01:12.000 --> 00:01:14.000
これはコードアロングです。

00:01:14.000 --> 00:01:17.000
このセッションでは、あなたと一緒にアプリを構築します。

00:01:17.000 --> 00:01:26.000
今すぐ一時停止を押して、コンパニオンXcodeプロジェクトをダウンロードしてください：準備された開始点と完成したアーカイブ。

00:01:26.000 --> 00:01:31.000
スタータープロジェクトを開き、ContentViewファイルに移動します。

00:01:31.000 --> 00:01:38.000
このセッションでは、新しいXcode機能、Mac用の埋め込みインタラクティブライブプレビューを活用します。

00:01:38.000 --> 00:01:43.000
プレビューセクションには、いくつかのフラッシュカードが入ったグリッドがあります。

00:01:43.000 --> 00:01:50.000
任意のカードをクリックすると、カードを1つずつスクロールできるビューに移行します。

00:01:50.000 --> 00:01:53.000
誰がコンパイラを発明したか覚えていますか？

00:01:53.000 --> 00:01:57.000
カードをクリックします。それはひっくり返って答えを与えます!

00:01:57.000 --> 00:02:06.000
アプリにはメモリに保存されているサンプルカードが入力されており、アプリを実行して新しいカードを追加すると、アプリを閉じると消えます。

00:02:06.000 --> 00:02:09.000
ここでSwiftDataの出番です。

00:02:09.000 --> 00:02:13.000
作成したフラッシュカードを永続化するために使用します。

00:02:13.000 --> 00:02:24.000
今日は、SwiftDataの使用を開始するために知っておくべきことすべてについて話し、私が私たちのためにまとめたこのtodoリストで次々とチェックします。

00:02:24.000 --> 00:02:27.000
あなたは私たちが構築するアプリに会ったばかりです。

00:02:27.000 --> 00:02:32.000
次に、スタータープロジェクトとそのモデルクラスを見ていきます。

00:02:32.000 --> 00:02:40.000
その後、段階的に、SwiftDataをストレージとして使用するように変換して修正します。

00:02:40.000 --> 00:02:56.000
モデルクラスを拡張してSwiftDataモデルになる方法、データを照会し、モデルレイヤーのすべての変更のビューを更新する方法、モデルを作成して保存し、UI要素を便利にバインドする方法を学びます。

00:02:56.000 --> 00:03:05.000
そして最後に、ボーナスとして、SwiftDataがストレージの世話をするときに、ドキュメントベースのアプリを作成するのがいかに簡単かを確認します。

00:03:05.000 --> 00:03:19.000
スタータープロジェクトでは、時間を節約するために、単一のフラッシュカード、いくつかのビュー、およびサポートファイルを表すカードモデルを定義しました。

00:03:19.000 --> 00:03:25.000
すべてのカードは、前面と背面のテキストと作成日を保存します。

00:03:25.000 --> 00:03:28.000
それはかなり典型的なモデルです。

00:03:28.000 --> 00:03:33.000
SwiftDataが保存できるように更新しましょう。

00:03:33.000 --> 00:03:36.000
まず、SwiftDataをこのファイルにインポートします。

00:03:36.000 --> 00:03:46.000
そして次に、私たちが行う必要がある主な変更は、定義に@Modelマクロを追加することです。

00:03:46.000 --> 00:03:50.000
そして今、クラスはSwiftDataで完全に永続化可能です。

00:03:50.000 --> 00:03:53.000
もうタイピングはしない。それでおそれ！

00:03:53.000 --> 00:04:02.000
さらに、@Modelを使用すると、カードはObservableプロトコルに準拠し、ObservableObjectの代わりに使用します。

00:04:02.000 --> 00:04:11.000
Observableオブジェクトと@Publishedプロパティラッパーへの適合性を削除します。

00:04:11.000 --> 00:04:21.000
以前は、ObservedObjectコンフォーマンスを使用して、CardEditorViewファイルのUIから直接カードを編集しました。

00:04:21.000 --> 00:04:28.000
ここでObservableを採用するために、「ObservedObject」プロパティラッパーを「Bindable」に置き換えます。

00:04:28.000 --> 00:04:35.000
これにより、テキストフィールドをカードの前面に直接バインドできます。

00:04:35.000 --> 00:04:37.000
そしてバックテキスト。

00:04:37.000 --> 00:04:39.000
完了！

00:04:39.000 --> 00:04:49.000
新しいObservableマクロとBindableプロパティラッパーを使用すると、以前よりもさらに少ないコードでアプリケーション内のデータフローを簡単に設定できます。

00:04:49.000 --> 00:04:58.000
ビューが本体でObservableタイプのプロパティを使用する場合、指定されたプロパティが変更されると自動的に更新されます。

00:04:58.000 --> 00:05:05.000
そして、モデルの可変状態をUI要素にバインドすることはそれほど簡単ではありませんでした!

00:05:05.000 --> 00:05:13.000
WWDC23セッション「SwiftUIで観察を発見する」を見ることをお勧めします。

00:05:13.000 --> 00:05:20.000
ObservableがSwiftDataの有無にかかわらず、データフローコードを簡素化する方法に驚かれることでしょう。

00:05:20.000 --> 00:05:25.000
そして、モデルについて知っておくべきことはそれだけです。

00:05:25.000 --> 00:05:28.000
これ以上何もない。それはどれくらいかっこいいですか?

00:05:28.000 --> 00:05:37.000
次に、SwiftDataからモデルを照会してUIに表示するには、ContentViewに切り替えましょう。

00:05:37.000 --> 00:05:48.000
SampleDeck.contentsの代わりに、SwiftDataが持っているカードを表示します。

00:05:48.000 --> 00:06:00.000
そして、カード配列をSwiftDataストレージにバインドするために必要な1つの変更があります。@Stateプロパティラッパーを@Queryに置き換えます。

00:06:00.000 --> 00:06:02.000
それでおそれ！

00:06:02.000 --> 00:06:09.000
プレビューでわかるように、おそらく保存していないため、表示するカードはもうありません。

00:06:09.000 --> 00:06:17.000
SwiftDataが管理するモデルをUIに表示したいときはいつでも@Queryを使用してください。

00:06:17.000 --> 00:06:22.000
@Queryは、SwiftDataからモデルを照会する新しいプロパティラッパーです。

00:06:22.000 --> 00:06:30.000
また、@Stateがそれを行う方法と同様に、モデルの変更ごとに更新されたビューをトリガーします。

00:06:30.000 --> 00:06:35.000
すべてのビューは、必要なだけ多くのクエリプロパティを持つことができます。

00:06:35.000 --> 00:06:44.000
クエリは、ソート、順序付け、フィルタリング、さらには変更のアニメーション化を設定するための軽量な構文を提供します。

00:06:44.000 --> 00:06:50.000
ボンネットの下では、ビューのモデルコンテキストをデータソースとして使用します。

00:06:50.000 --> 00:06:53.000
@Queryにモデルコンテキストを提供するにはどうすればよいですか?

00:06:53.000 --> 00:06:57.000
モデルコンテナから1つを取得します。

00:06:57.000 --> 00:07:04.000
SwiftUIは、ビューのModelContainerの便利なセットアップのために、新しいビューとシーンの修飾子を販売します。

00:07:04.000 --> 00:07:10.000
SwiftDataを使用するには、どのアプリケーションでも少なくとも1つのModelContainerを設定する必要があります。

00:07:10.000 --> 00:07:17.000
@Queryが使用するコンテキストを含む、ストレージスタック全体を作成します。

00:07:17.000 --> 00:07:27.000
ビューには単一のモデルコンテナがありますが、アプリケーションは異なるビュー階層に必要な数のコンテナを作成して使用できます。

00:07:27.000 --> 00:07:37.000
アプリケーションがmodelContainerを設定しない場合、そのウィンドウと作成したビューは、SwiftDataを介してモデルを保存またはクエリすることはできません。

00:07:37.000 --> 00:07:41.000
多くのアプリケーションには、単一のモデルコンテナが必要です。

00:07:41.000 --> 00:07:45.000
この場合、ウィンドウグループシーン全体に設定できます。

00:07:45.000 --> 00:07:53.000
ウィンドウとそのビューは、同じグループから作成された他のウィンドウと同様に、コンテナを継承します。

00:07:53.000 --> 00:07:59.000
これらのビューはすべて、単一のコンテナから書き込みおよび読み取ります。

00:07:59.000 --> 00:08:06.000
一部のアプリはいくつかのストレージスタックを必要とし、異なるウィンドウ用にいくつかのモデルコンテナを設定できます。

00:08:06.000 --> 00:08:11.000
SwiftUIでは、ビューレベルでの詳細な設定も可能です。

00:08:11.000 --> 00:08:19.000
同じウィンドウの異なるビューは別々のコンテナを持つことができ、あるコンテナに保存しても別のコンテナには影響しません。

00:08:19.000 --> 00:08:24.000
では、クエリにデータソースを提供するようにmodelContainerを設定しましょう。

00:08:24.000 --> 00:08:33.000
アプリの定義を開きます...

00:08:33.000 --> 00:08:37.000
そして、アプリのウィンドウのモデルコンテナを設定します。

00:08:37.000 --> 00:08:47.000
サブビューは、ビュー修飾子にリストされているモデルタイプのみを作成、読み取り、更新、削除できることに注意してください。

00:08:47.000 --> 00:08:50.000
そして、セットアップは終わりました!

00:08:50.000 --> 00:08:56.000
しかし、私は1つの余分なステップを踏み出したいと思います:私のプレビューにサンプルデータを提供します。

00:08:56.000 --> 00:09:01.000
アプリでは、サンプルカードでインメモリコンテナを定義しました。

00:09:01.000 --> 00:09:08.000
「PreviewSampleData」ファイルを開いて、ターゲットに含めましょう。

00:09:08.000 --> 00:09:12.000
このファイルには、サンプルデータを含むコンテナの定義が含まれています。

00:09:12.000 --> 00:09:18.000
ContentViewでそれを使用して、プレビューをサンプルカードで塗りつぶします。

00:09:18.000 --> 00:09:33.000
@Queryにデータソースが表示されたので、プレビューにはカードが表示されます!

00:09:33.000 --> 00:09:41.000
そして、これはSwiftDataスタックを準備してプレビューを生成するために必要なすべてのセットアップです。

00:09:41.000 --> 00:09:50.000
次に、SwiftDataが作成した新しいカードと既存のカードに加えられた変更を追跡して保存することを確認したいと思います。

00:09:50.000 --> 00:09:55.000
これを行うには、ビューのモデルコンテキストを使用します。

00:09:55.000 --> 00:10:01.000
モデルコンテキストにアクセスするために、SwiftUIは新しい環境変数を提供します。

00:10:01.000 --> 00:10:11.000
モデルコンテナと同様に、各ビューには単一のコンテキストがありますが、一般的に、アプリケーションは必要な数だけ持つことができます。

00:10:11.000 --> 00:10:14.000
私たちのアプリでは、コンテキストはすでに設定されています。

00:10:14.000 --> 00:10:21.000
この環境変数は、モデルコンテナを以前に設定したときに自動的に入力されました。

00:10:21.000 --> 00:10:24.000
Xcodeに戻りましょう。 

00:10:24.000 --> 00:10:33.000
カードを保存および更新するには、modelContextにアクセスする必要があります。

00:10:33.000 --> 00:11:03.000
新しく作成したカードをモデルのコンテキストに挿入して、SwiftDataに保存したいモデルを認識させます。

00:11:03.000 --> 00:11:13.000
モデルを挿入した後、「modelContext.save()」を呼び出してコンテキストを保存する必要があると思うかもしれませんが、それを行う必要はありません。

00:11:13.000 --> 00:11:19.000
SwiftDataの素晴らしい詳細は、モデルのコンテキストを自動保存することです。

00:11:19.000 --> 00:11:24.000
自動保存は、UI関連のイベントとユーザー入力によってトリガーされます。

00:11:24.000 --> 00:11:29.000
SwiftDataが私たちのためにそれを行うので、私たちは保存について心配する必要はありません。

00:11:29.000 --> 00:11:40.000
SwiftDataストレージを共有したり送信したりする前に、すべての変更がすぐに保持されていることを確認したいケースはごくわずかです。

00:11:40.000 --> 00:11:44.000
このような場合は、「save()」を明示的に呼び出します。

00:11:44.000 --> 00:11:50.000
私たちのアプリはカードを保存して照会できるので、カードを作成しましょう!

00:11:50.000 --> 00:11:53.000
私はアプリを実行します...

00:11:53.000 --> 00:11:58.000
プラスボタンを押してカードを作成します。

00:11:58.000 --> 00:12:04.000
前に見たコンパイラカードを追加しましょう。

00:12:04.000 --> 00:12:19.000
では、アプリを終了して、もう一度起動して、新しいカードがあるかどうか見てみましょう。

00:12:19.000 --> 00:12:21.000
そして、ここにあります!

00:12:21.000 --> 00:12:26.000
これで、ビューのモデルコンテキストにアクセスしてカードを追加する方法がわかりました。

00:12:26.000 --> 00:12:28.000
完了！

00:12:28.000 --> 00:12:31.000
新しいウィンドウを開きましょう。

00:12:31.000 --> 00:12:41.000
最初のデッキと同じデッキを表示しますが、両方のウィンドウが同じモデルコンテナを使用し、同じデータにアクセスするため、理にかなっています。

00:12:41.000 --> 00:12:48.000
しかし、アプリが異なるウィンドウで異なるフラッシュカードデッキを開くことができればいいのですが。

00:12:48.000 --> 00:12:53.000
本質的には、すべてのデッキを別々の文書として扱いたいということです。

00:12:53.000 --> 00:12:56.000
その後、これらの文書を友達と共有できます。

00:12:56.000 --> 00:13:03.000
ドキュメントベースのアプリは、macOS、iOS、iPadOSで使用される概念です。

00:13:03.000 --> 00:13:12.000
ユーザーがさまざまな種類のドキュメントを作成、オープン、表示、または編集できる特定の種類のアプリケーションについて説明します。

00:13:12.000 --> 00:13:18.000
すべての文書はファイルであり、ユーザーはそれらを保存、コピー、共有することができます。

00:13:18.000 --> 00:13:26.000
そして、SwiftUIがSwiftDataに裏打ちされたドキュメントアプリをサポートしていることをお知らせできることを嬉しく思います。

00:13:26.000 --> 00:13:28.000
このアプローチを試してみましょう。

00:13:28.000 --> 00:13:32.000
FlashCardAppファイルを開きます。

00:13:32.000 --> 00:13:45.000
ドキュメントベースのアプリはiOSとmacOSに存在し、これらのプラットフォームでは、DocumentGroup初期化子の使用に切り替えます。

00:13:45.000 --> 00:14:13.000
モデルタイプCard.self、コンテンツタイプ、ビュービルダーを渡します。

00:14:13.000 --> 00:14:20.000
少し回り道をして、2番目のパラメータ、コンテンツタイプについてより詳細に話しましょう!

00:14:20.000 --> 00:14:25.000
SwiftDataドキュメントベースのアプリは、カスタムコンテンツタイプを宣言する必要があります。

00:14:25.000 --> 00:14:32.000
各SwiftDataドキュメントは、ユニークなモデルセットから構築されているため、ディスク上にユニークな表現があります。

00:14:32.000 --> 00:14:40.000
ドキュメントのコンテキストでは、コンテンツタイプをJPEGのようなバイナリファイル形式と考えることができます。

00:14:40.000 --> 00:14:48.000
別のタイプのドキュメントであるパッケージは、Xcodeプロジェクトのように、ディスク上の固定構造を持つディレクトリです。

00:14:48.000 --> 00:14:53.000
たとえば、すべてのJPEG画像は同じバイナリ構造です。

00:14:53.000 --> 00:14:57.000
そうでなければ、写真編集者はそれらを読む方法を知らないだろう。

00:14:57.000 --> 00:15:03.000
同様に、すべてのXcodeプロジェクトには特定のディレクトリとファイルが含まれています。

00:15:03.000 --> 00:15:12.000
ユーザーがデッキを開くと、デッキの形式とファイル拡張子をアプリに関連付けるオペレーティングシステムが必要です。

00:15:12.000 --> 00:15:16.000
そのため、コンテンツタイプを宣言する必要があります。

00:15:16.000 --> 00:15:29.000
SwiftDataドキュメントはパッケージです。SwiftDataモデルのいくつかのプロパティを「externalStorage」属性でマークすると、外部に保存されたすべてのアイテムがドキュメントパッケージの一部になります。

00:15:29.000 --> 00:15:39.000
UTType+FlashCardsファイルには、新しいコンテンツタイプの定義があるので、コードで便利に使用できます。

00:15:39.000 --> 00:15:52.000
Info.plistに同じ定義を入れます。

00:15:52.000 --> 00:15:57.000
オペレーティングシステムで新しいコンテンツタイプを宣言しようとしています。

00:15:57.000 --> 00:16:05.000
アプリによって作成されたカードデッキを他のドキュメントと区別するために、ファイル拡張子を指定する必要があります。

00:16:05.000 --> 00:16:13.000
このサンプルアプリでは、拡張機能として「sampledeck」を使用します。

00:16:13.000 --> 00:16:24.000
また、フラッシュカードデッキのような簡単な説明を追加します。

00:16:24.000 --> 00:16:33.000
識別子は、コード内のものとまったく同じである必要があります。

00:16:33.000 --> 00:16:46.000
SwiftDataドキュメントはパッケージであるため、タイプがcom.apple.packageに準拠していることを確認する必要があります。

00:16:46.000 --> 00:16:51.000
では、宣言したコンテンツタイプを使ってみましょう。

00:16:51.000 --> 00:16:59.000
アプリ定義に戻り、コンテンツタイプをDocumentGroupに渡します。

00:16:59.000 --> 00:17:06.000
ビュービルダーは同じように見えます。

00:17:06.000 --> 00:17:10.000
特に、私たちはモデルコンテナを設定していません。

00:17:10.000 --> 00:17:16.000
ドキュメントインフラストラクチャは、ドキュメントごとに1つずつ設定されます。

00:17:16.000 --> 00:17:23.000
アプリケーションを実行して、それが今どのように見えるか見てみましょう!

00:17:23.000 --> 00:17:27.000
アプリはパネルを開いた状態で起動します。

00:17:27.000 --> 00:17:31.000
ドキュメントベースのアプリケーションの標準的な動作。

00:17:31.000 --> 00:17:38.000
新しい文書を作成し、そこにカードを追加します。

00:17:38.000 --> 00:17:44.000
ドキュメントには、未保存の変更があることを示すツールバーのサブタイトルが追加されました。

00:17:44.000 --> 00:17:50.000
Command+Sを押すと、保存ダイアログが表示されます。

00:17:50.000 --> 00:17:57.000
デッキは、先ほどInfo.plistに入れたのと同じファイル拡張子で保存されることに注意してください。

00:17:57.000 --> 00:18:06.000
私は新しいデッキを保存し、これが私の最初のフラッシュカードデッキをデスクトップにあります。

00:18:06.000 --> 00:18:14.000
Command+Nを押して新しいデッキを作成したり、Command+Oを押して新しいデッキを開くこともできます。

00:18:14.000 --> 00:18:22.000
これらのショートカットは、他の多くの機能と同様に、ドキュメントベースのアプリケーションが自動的に取得されます。

00:18:22.000 --> 00:18:28.000
要約すると、今日はSwiftUIアプリでSwiftDataストレージを使用する方法を学びました。

00:18:28.000 --> 00:18:42.000
新しい@Modelマクロ、@Queryプロパティラッパー、モデルコンテキスト用の新しい環境変数について話し、SwiftDataをドキュメントのストレージとして使用するのがいかに簡単かを見ました。

00:18:42.000 --> 00:18:46.000
今日は参加してくれてありがとう、アプリを作って楽しんでください！

00:18:46.000 --> 23:59:59.000
♪ ♪

