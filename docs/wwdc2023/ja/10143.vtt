WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:15.000
Dave: こんにちは、App Store Commerceチームの開発者アドボケートであるDave Wendlandです。

00:00:15.000 --> 00:00:34.000
同僚のアレックスと私は、新しいApp Storeサーバーライブラリと、その機能のセットが、サーバーがApp Store Server APIのJWTの生成から購入検証のためにverifyReceiptエンドポイントから移行することまで、さまざまな機能を利用できるようにする方法について話し合います。

00:00:34.000 --> 00:00:40.000
振り返ってみると、アプリが無料または有料だった2008年にApp Storeが発売されました。

00:00:40.000 --> 00:00:49.000
すぐに、私たちはアプリ内購入を追加し、それ以来、開発者コミュニティは世界中で規模と複雑さを増しています。

00:00:49.000 --> 00:00:59.000
App Storeは、グローバルでダイナミックなモバイルアプリエコシステムをサポートするために、開発者や顧客向けのアップデートを展開し続けています。

00:00:59.000 --> 00:01:10.000
2021年には、改良されたStoreKit Framework、App Store Server API、App Store Server Notifications v2を備えたStoreKitツールの次の時代をリリースしました。

00:01:10.000 --> 00:01:16.000
2022年と今年もWWDC 2023でさらに更新されます。

00:01:16.000 --> 00:01:22.000
これらのツールは、署名されたJWS形式でトランザクションとステータスを提供します。

00:01:22.000 --> 00:01:29.000
また、開発者に堅牢な情報、クライアント側、サーバー側を提供するように設計されています。

00:01:29.000 --> 00:01:33.000
この一連のAPIは、App Store Server Libraryに影響を与えました。

00:01:33.000 --> 00:01:46.000
このライブラリが一連の機能を提供していることを誇りに思います。これにより、開発者コミュニティが現在および将来利用可能な最新のAPIを採用し、統合することが容易になります。

00:01:46.000 --> 00:01:59.000
ライブラリのベータリリースは、Swift、Java、Node、Pythonの4つの言語をサポートしており、バックエンドと専門知識を最もよくサポートする言語を柔軟に選択できます。

00:01:59.000 --> 00:02:07.000
各言語のApp StoreサーバーライブラリはGitHubで入手できますので、ご意見やご意見をお待ちしております。

00:02:07.000 --> 00:02:13.000
図書館が提供するものを4つの重要な機能に分解しました。

00:02:13.000 --> 00:02:18.000
最初で最も堅牢な機能は、App Store Server APIです。

00:02:18.000 --> 00:02:26.000
JWTの作成を合理化することで、App Store Server APIが提供する12の異なるエンドポイントのいずれかを使用できます。

00:02:26.000 --> 00:02:39.000
次に、JWSの署名されたデータを検証するコア機能なので、トランザクションとサーバー通知がAppleによって生成され、署名されていることを確認できます。

00:02:39.000 --> 00:02:43.000
次は、抽出レシートトランザクションユーティリティです。

00:02:43.000 --> 00:02:48.000
このシンプルなツールは、アプリの領収書からトランザクション識別子を抽出します。

00:02:48.000 --> 00:03:00.000
これにより、verifyReceiptエンドポイントを使用する必要性を軽減し、購入検証と追加機能のためにApp Store Server APIに移行することができます。

00:03:00.000 --> 00:03:05.000
これは、現在およびレガシーアプリのバージョンをサポートするための明確なパスを提供します。

00:03:05.000 --> 00:03:11.000
最後に、サブスクリプションプロモーションオファーの署名を生成するユーティリティです。

00:03:11.000 --> 00:03:18.000
このユーティリティは、アプリ内購入の秘密鍵を使用してオファーに署名して生成する重い作業を行います。

00:03:18.000 --> 00:03:27.000
サブスクリプションプロモーションオファーに精通していない場合は、「サブスクリプションオファーのベストプラクティス」というタイトルのセッションで詳細をご覧ください。

00:03:27.000 --> 00:03:31.000
次に、これらのコアライブラリ機能の3つを深く掘り下げてみましょう。

00:03:31.000 --> 00:03:38.000
App Store Server API、署名されたデータ検証、およびApp Store Server APIへの移行。

00:03:38.000 --> 00:03:42.000
App Store Server APIから始めましょう。

00:03:42.000 --> 00:03:48.000
サーバーAPIの基盤は、トランザクション履歴の取得エンドポイントです。

00:03:48.000 --> 00:03:56.000
トランザクションIDを使用するだけで、このAPIは顧客の完全なアプリ内購入トランザクション履歴を提供します。

00:03:56.000 --> 00:03:59.000
そして、このエンドポイントを超えてさらに多くの機能を備えています。

00:03:59.000 --> 00:04:07.000
このAPIには12のエンドポイントがあり、そのすべてにJSON Webトークンという認証形式が必要です。

00:04:07.000 --> 00:04:15.000
JWTの生成は重要なステップであり、このプロセスに精通していない場合は、ライブラリの出番です。

00:04:15.000 --> 00:04:22.000
アレックスに渡して、App Store Server APIで使用するためのライブラリのセットアップを実演します。

00:04:22.000 --> 00:04:25.000
アレックス：こんにちは、App Storeサーバーエンジニアのアレックス・ベイカーです。

00:04:25.000 --> 00:04:32.000
App Store Serverライブラリの使用を開始する方法と、それを使用してApp Store Server APIを呼び出す方法を実演します。

00:04:32.000 --> 00:04:42.000
このデモでは、App Storeサーバーライブラリを設定するために必要な情報を収集し、APIクライアントを作成してAPIを呼び出す例を示します。

00:04:42.000 --> 00:04:49.000
ライブラリでApp Store Server APIを使用するために必要な情報を取得するために、App Store Connectから始めています。

00:04:49.000 --> 00:04:54.000
ユーザーとアクセスモジュールに移動します...

00:04:54.000 --> 00:04:59.000
次に、[キー]タブ、次に[アプリ内購入]オプション。

00:04:59.000 --> 00:05:01.000
ここには役に立つ情報がいくつかあります。

00:05:01.000 --> 00:05:04.000
まず、発行者IDです。

00:05:04.000 --> 00:05:07.000
次に、新しい秘密鍵を生成します。

00:05:07.000 --> 00:05:12.000
名前を付けてから、[生成]をクリックします。

00:05:12.000 --> 00:05:19.000
キーの生成には、キーIDと秘密鍵をダウンロードするオプションの2つの情報があります。

00:05:19.000 --> 00:05:22.000
ダウンロードは一度しかできません。

00:05:22.000 --> 00:05:28.000
Apple公開鍵インフラストラクチャWebサイトに切り替えて、左上のAppleルート証明書セクションに焦点を当てます。

00:05:28.000 --> 00:05:34.000
ルート証明書をダウンロードしてください。

00:05:34.000 --> 00:05:38.000
これは、Gradleビルドシステムを使用した簡単なJavaプロジェクトです。

00:05:38.000 --> 00:05:44.000
まず、App Store Serverライブラリへの依存関係を追加します。

00:05:44.000 --> 00:05:53.000
ExampleAppクラスに移動すると、先ほど入手した情報、issuerId、keyId、秘密鍵があります。

00:05:53.000 --> 00:06:05.000
さらに、アプリのbundleIdを保存します--このデモンストレーションでは、私はサンドボックスを使用しています--そして適切な列挙値を保存します。

00:06:05.000 --> 00:06:10.000
これらの情報を使用して、AppStoreServerAPIClientをインスタンス化します。

00:06:10.000 --> 00:06:21.000
このクライアントでは、テスト通知のリクエストエンドポイントを呼び出し、App StoreサーバーにApp Store Connectで設定したURLにTESTタイプの通知を送信するように要求します。

00:06:21.000 --> 00:06:24.000
最後に、testNotificationTokenを印刷します。

00:06:24.000 --> 00:06:35.000
これを実行すると、testNotificationTokenが印刷され、予想通り、このトークンが表示されます。

00:06:35.000 --> 00:06:42.000
これは、App Store Serverライブラリを使用して、App Store Server APIとApp Store Connectから必要な情報を簡素化する方法を示しました。

00:06:42.000 --> 00:06:44.000
さて、デイブに戻ります。

00:06:44.000 --> 00:06:45.000
デイブ:ありがとう、アレックス。

00:06:45.000 --> 00:06:54.000
そのデモは、このライブラリがサーバーAPIで使用するためにJWTをセットアップして生成する速さを示しています。

00:06:54.000 --> 00:07:02.000
このライブラリは、APIを採用する際の実装タイムラインの短縮に有意義な影響を与えます。

00:07:02.000 --> 00:07:09.000
ライブラリの使用は便利で簡単ですが、アプリ内購入の秘密鍵を安全に保管することほど重要なものはありません。

00:07:09.000 --> 00:07:16.000
また、キーが侵害されたと思われる場合は、いつでもApp Store Connectで新しいキーを生成してください。

00:07:16.000 --> 00:07:22.000
開発を開始するには、サンドボックスとTestFlightトランザクションから始めることをお勧めします。

00:07:22.000 --> 00:07:29.000
そして最後に、更新されたAppleルート認証局を定期的に確認してください。

00:07:29.000 --> 00:07:36.000
それでは、署名されたデータ検証がアプリ内購入でビジネスの基礎的な行動である理由について話し合いましょう。

00:07:36.000 --> 00:07:40.000
まず、署名されたデータには何が含まれているのか、なぜそれが重要なのかについて話し合いましょう。

00:07:40.000 --> 00:07:56.000
StoreKit署名データは、JSON Web署名形式でApp Storeによって生成および署名されたことを意味し、アプリ内購入、アプリ内購入、顧客イベント、および顧客のサブスクリプションステータスに関するデータが含まれています。

00:07:56.000 --> 00:08:03.000
最も一般的な2つの署名付きデータペイロードは、JWSトランザクションとJWS更新情報です。

00:08:03.000 --> 00:08:11.000
次に、appTransactionには、最初に購入したアプリのバージョンと、現在デバイスにインストールされているバージョンの詳細が含まれています。

00:08:11.000 --> 00:08:25.000
そして、App Store Server Notifications V2があり、通知自体は署名されたデータであり、さらにJWSトランザクションとJWS更新情報が含まれている場合があります。

00:08:25.000 --> 00:08:38.000
念のため、このJWS署名データは、iOS 15以降のStoreKit 2とApp Store Server APIとApp Store Server Notifications v2でのみ見つかります。

00:08:38.000 --> 00:08:57.000
次のいずれかのイベントの後に、JWS署名されたデータを確認することをお勧めします。デバイスでコンテンツを配信またはロック解除するとき、またはサーバーが署名されたデータを受信したとき、それが自分のアプリ、別のサーバー、またはApp Storeサーバーの通知からであるかどうか。

00:08:57.000 --> 00:09:01.000
そして最後に、App StoreサーバーAPIから応答を受け取ったとき。

00:09:01.000 --> 00:09:09.000
JWSの署名されたデータを検証する方法と、ライブラリがこれをどのように処理するかをデモするアレックスです。

00:09:09.000 --> 00:09:13.000
アレックス：このセクションでは、App Storeから署名されたデータを確認する方法を紹介します。

00:09:13.000 --> 00:09:17.000
実行する必要がある検証プロセスについて説明します。

00:09:17.000 --> 00:09:24.000
次に、App Store Server LibraryのSignedDataVerifierクラスがこのプロセスを実行する方法について説明します。

00:09:24.000 --> 00:09:34.000
私が説明しようとしている操作の背後にあるRFCやプロトコルに精通していない場合は、App Store Server Libraryのようなツールを使用することが非常に賢明であることを強調したいと思います。

00:09:34.000 --> 00:09:36.000
以下はApp Storeからの署名入りデータです。

00:09:36.000 --> 00:09:38.000
ここではたくさんのことが起こっているようです。

00:09:38.000 --> 00:09:42.000
カラーコーディングは、3つのセクションがあることを明らかにします。

00:09:42.000 --> 00:09:46.000
各セクションはピリオドで区切られており、Base64 URLでエンコードされています。

00:09:46.000 --> 00:09:49.000
最初で最大のセクションはヘッダーです。

00:09:49.000 --> 00:09:55.000
デコードされると、ヘッダーはJWS仕様で定義されたフィールドを持つJSON構造です。

00:09:55.000 --> 00:10:03.000
この場合、ヘッダーには2つのフィールドしかありません。まず、アルゴリズムで、常にES256です。

00:10:03.000 --> 00:10:05.000
次に、x5cというフィールド。

00:10:05.000 --> 00:10:11.000
これは、JWSに署名した予想される公開鍵を計算するために使用される証明書の配列です。

00:10:11.000 --> 00:10:14.000
証明書チェーンの構築プロセスを見直しましょう。

00:10:14.000 --> 00:10:17.000
配列の最初の証明書はリーフ証明書です。

00:10:17.000 --> 00:10:21.000
この証明書の公開鍵はJWSに署名しました。

00:10:21.000 --> 00:10:30.000
この証明書がAppleからのものであることを確認するには、既知の信頼できるソース、この場合はAppleのルート認証局への信頼の連鎖を構築します。

00:10:30.000 --> 00:10:36.000
配列の次の証明書は、Apple Worldwide Developer Relationsの中間認証局です。

00:10:36.000 --> 00:10:42.000
これは、開発者に焦点を当てたApple Root Certificate Authorityのより専門的なバージョンと考えてください。

00:10:42.000 --> 00:10:49.000
チェーンの最後の証明書はAppleのルート認証局なので、どのAppleの認証局がこのチェーンを起源としているのかを理解しています。

00:10:49.000 --> 00:10:58.000
リマインダー、証明書が以前にAppleの公開鍵インフラストラクチャWebサイトから取得したルート証明書と正確に一致することを確認することが重要です。

00:10:58.000 --> 00:11:03.000
最初のステップは、各証明書がチェーン内の前の証明書によって署名されていることを確認することです。

00:11:03.000 --> 00:11:10.000
次に、各証明書に有効な日付、適切にフォーマットされていることを確認するなど、追加の検証手順を実行します。

00:11:10.000 --> 00:11:21.000
次に、これらの証明書がAppleからのものであり、その目的がApp Storeデータに署名することであり、App Storeデータに署名することは有効ではない無関係なユースケースとは対照的に、検証します。

00:11:21.000 --> 00:11:30.000
リーフ証明書を確認するには、Mac App Storeレシート署名のオブジェクト識別子またはOIDの存在をチェックして、その目的を確認します。

00:11:30.000 --> 00:11:36.000
中間証明書については、Apple Worldwide Developer Relationsの中間機関OIDを確認してください。

00:11:36.000 --> 00:11:45.000
最後に、前述のように、ルート認証局がAppleルート認証局として保存した証明書の1つであることを確認してください。

00:11:45.000 --> 00:11:52.000
それでは、実際にリーフ証明書をデコードし、これらの値をチェックする方法を観察しましょう。

00:11:52.000 --> 00:12:01.000
これは、OpenSSL x509コマンドによって生成された証明書のX.509 v3拡張セクションです。

00:12:01.000 --> 00:12:09.000
下部には、前のスライドに記載されているOIDがあり、証明書の目的がApp Storeの領収書署名であることを示しています。

00:12:09.000 --> 00:12:14.000
ただし、チェックすべき重要な追加のフィールドがいくつかあります。

00:12:14.000 --> 00:12:23.000
ここでは、発行者に関する情報を提供し、重要なことに、証明書が取り消されたかどうかを確認するための情報を提供する権限情報アクセスセクションが表示されます。

00:12:23.000 --> 00:12:27.000
オンライン証明書ステータスプロトコル（OCSP）を使用する。

00:12:27.000 --> 00:12:31.000
検証プロセスを進める前に、証明書が取り消されたかどうかを確認してください。

00:12:31.000 --> 00:12:38.000
そうするためのプロセスと暗号化手順は、RFC 6960で定義されています。

00:12:38.000 --> 00:12:44.000
証明書チェーンを確認した後、JWSがリーフ証明書の公開鍵で署名されていることを確認します。

00:12:44.000 --> 00:12:58.000
以前からリーフ証明書を取得し、リーフ証明書の公開鍵を抽出し、キーと元のJWSを取得し、それらをJWS署名検証機能に渡します。

00:12:58.000 --> 00:13:03.000
検証機能は、データが公開鍵で署名されていることをチェックし、ペイロードをデコードします。

00:13:03.000 --> 00:13:08.000
プロセスはほぼ完了していますが、追加の検証手順が1つあります。

00:13:08.000 --> 00:13:12.000
これはデコードされたApp Storeサーバーのテスト通知です。

00:13:12.000 --> 00:13:15.000
前の手順では、データがApp Storeから来たことを確認しました。

00:13:15.000 --> 00:13:22.000
ただし、通知が正しいアプリケーションと環境を対象としていることも確認してください。

00:13:22.000 --> 00:13:29.000
appAppleIdとbundleIdをチェックして、通知が正しいアプリケーションを対象としていることを確認してください。

00:13:29.000 --> 00:13:33.000
環境が予想される環境と一致していることを確認します。

00:13:33.000 --> 00:13:41.000
検証プロセスの他の手順と同様に、App Store Serverライブラリも検証を実行するときにこれらをチェックします。

00:13:41.000 --> 00:13:45.000
これにより、App Storeから署名されたデータを確認するプロセスが完了します。

00:13:45.000 --> 00:13:52.000
次に、以前からプロジェクトを拡張して、App Storeサーバーライブラリに含まれているSignedDataVerifierクラスを使用して署名されたデータを検証します。

00:13:52.000 --> 00:13:57.000
SignedDataVerifierクラスは、以前に説明した検証手順を実行します。

00:13:57.000 --> 00:14:03.000
このデモでは、先ほどリクエストしたテスト通知を受け取り、署名された通知を検証してデコードします。

00:14:03.000 --> 00:14:08.000
テスト通知のリクエストと、サーバーで受信された通知との間に少し遅れがあります。

00:14:08.000 --> 00:14:12.000
したがって、5秒の遅延を追加します。

00:14:12.000 --> 00:14:19.000
次に、以前に取得したtestNotificationTokenを使用して、Get Test Notification Statusエンドポイントを呼び出します。

00:14:19.000 --> 00:14:23.000
最後に、通知の最初の数文字を印刷して成功を確認します。

00:14:23.000 --> 00:14:30.000
Get Test Notification Statusエンドポイントは、送信試行の結果と通知ペイロードを返します。

00:14:30.000 --> 00:14:37.000
そのペイロードの始まりは、私たちが見るべきものです。

00:14:37.000 --> 00:14:41.000
予想通り、通知の最初の数文字が表示されます。

00:14:41.000 --> 00:14:44.000
次に、署名されたデータ検証者を作成します。

00:14:44.000 --> 00:14:52.000
これには、Apple Root認証局のリストから始まる3つの情報が必要です。

00:14:52.000 --> 00:14:56.000
先ほどダウンロードした証明書は、リソースフォルダにあります。

00:14:56.000 --> 00:15:00.000
ルート証明書をセットにインポートします。

00:15:00.000 --> 00:15:04.000
私はサンドボックスを使用しているので、アプリのApple IDは必要ありません。

00:15:04.000 --> 00:15:08.000
代わりにサンドボックスでnullを渡します。

00:15:08.000 --> 00:15:11.000
最後に、失効チェックを実行するかどうか。

00:15:11.000 --> 00:15:16.000
通知を受け取ったばかりなので、onlineChecksは真であるべきです。

00:15:16.000 --> 00:15:22.000
数ヶ月または数年前に受け取った通知については、証明書の有効期限が切れている可能性があるため、これは虚偽である必要があります。

00:15:22.000 --> 00:15:26.000
これらのフィールドを新しいSignedDataVerifierに渡します。

00:15:26.000 --> 00:15:37.000
次に、以前に受信した通知を渡し、結果を印刷してからプログラムを実行します。

00:15:37.000 --> 00:15:41.000
プログラムが完了すると、プログラムには検証済みでデコードされた通知が表示されます。

00:15:41.000 --> 00:15:51.000
これはテスト通知であるため、他のいくつかのフィールドとともに、ペイロードにTESTの種類とアプリのバンドル識別子があります。

00:15:51.000 --> 00:15:56.000
予想通り、TESTタイプのデコードされた通知が表示されます。

00:15:56.000 --> 00:16:00.000
SignedDataVerifierオブジェクトを実演するために、以前のデモを拡張しました。

00:16:00.000 --> 00:16:03.000
ここでは、いくつかのベストプラクティスを確認するデイブです。

00:16:03.000 --> 00:16:17.000
デイブ：うわー、それは署名されたデータを検証するために必要なすべての手順と、ライブラリがその複雑さをどのように処理できるかを本当に示しているので、サーバー側の検証にSignedDataVerifierを必ず利用してください。

00:16:17.000 --> 00:16:29.000
重要なリマインダー：データを確認するときは、正しいアプリまたはサービスの購入を許可または取り消すことを確認するために、アプリと製品識別子を確認する必要があります。

00:16:29.000 --> 00:16:40.000
最後に、証明書の有効期限が切れて取り消すことができるので、証明書、クライアント側またはサーバー側をハードコードせず、常にアクティブであることを検証してください。

00:16:40.000 --> 00:16:52.000
次に、サーバー側のアプリレシート検証をverifyReceiptエンドポイントからApp Store Server APIに移動するのを支援するために、別のApp Storeサーバーユーティリティを確認します。

00:16:52.000 --> 00:17:01.000
App Store Serverライブラリは、この移行を具体的に支援するユーティリティを提供し、アプリが取り残されないようにします。

00:17:01.000 --> 00:17:07.000
App Store Server APIへの移行を検討する際には、ロードマップでこの作業を優先する理由はたくさんあります。

00:17:07.000 --> 00:17:18.000
このAPIは購入検証をサポートし、カスタマーサポート、アピーズメント、およびApp Store Server Notifications V2のテストに役立つ追加のエンドポイントが含まれています。

00:17:18.000 --> 00:17:32.000
更新と新しいプロパティのリリースを継続するにつれて、これらはStoreKit 2、App Store Server API、およびApp Store Server Notifications V2でサポートされているJWS署名付きデータでのみリリースされます。

00:17:32.000 --> 00:17:40.000
追加の利点、記録する必要がある唯一のデータは、元のトランザクションIDまたはトランザクションIDです。

00:17:40.000 --> 00:17:45.000
Base64でエンコードされた領収書をアカウントシステムに保存する必要がなくなりました。

00:17:45.000 --> 00:17:53.000
また、最新のAPIへの継続的な投資により、verifyReceiptエンドポイントが非推奨になったことを発表しました。

00:17:53.000 --> 00:18:01.000
詳細については、セッション「App StoreサーバーAPIの新機能」をチェックして、詳細なアップデートとガイダンスを確認してください。

00:18:01.000 --> 00:18:06.000
アレックスは、App Storeのサーバーライブラリが移行にどのように役立つかを共有します。

00:18:06.000 --> 00:18:07.000
アレックス？

00:18:07.000 --> 00:18:08.000
アレックス:ありがとう、デイブ。

00:18:08.000 --> 00:18:12.000
では、アプリレシートのフロー図を見ていきましょう。

00:18:12.000 --> 00:18:25.000
StoreKit 2とApp Store Server APIは使用するのに最適なツールですが、最近更新されておらず、アプリレシートのみがサーバーに提供できる古いデバイスやユーザーのクライアントをサポートすることが重要です。

00:18:25.000 --> 00:18:34.000
これらのデバイスが以前にどのようにサポートされていたか、そしてverifyReceiptの廃止後、これらのクライアントをどのようにサポートし続けることができるかを紹介します。

00:18:34.000 --> 00:18:38.000
まず、デバイスはサーバーに領収書を送信します。

00:18:38.000 --> 00:18:46.000
古いモデルでは、サーバーはこのレシートをverifyReceiptに渡し、デコードされたレシートを受け取ります。

00:18:46.000 --> 00:18:55.000
応答には、App Store Server APIのGet Transaction Historyエンドポイントに渡されるoriginalTransactionIdが含まれています。

00:18:55.000 --> 00:19:00.000
App Storeサーバーは、顧客にサービスを提供するために使用する署名済みのトランザクションを返します。

00:19:00.000 --> 00:19:05.000
verifyReceiptが非推奨になったので、このセクションを置き換えましょう。

00:19:05.000 --> 00:19:10.000
App Storeサーバーライブラリのレシートユーティリティは、レシートからトランザクションIDを直接抽出します。

00:19:10.000 --> 00:19:16.000
トランザクションIDをApp Store Server APIに渡すと、2回の往復を行う必要がなくなります。

00:19:16.000 --> 00:19:19.000
この後、エンドポイントからリビジョンを保存します。

00:19:19.000 --> 00:19:24.000
これにより、毎回履歴全体を再解析する必要がなくなります。

00:19:24.000 --> 00:19:41.000
アプリのレシートから抽出された値は、元のトランザクションIDである場合とそうでない可能性があるため、トランザクション履歴の取得エンドポイントを含む多くのエンドポイントが、元のトランザクションIDだけでなく、任意のトランザクションIDをパラメータとしてサポートしていることを発表できることを嬉しく思います。

00:19:41.000 --> 00:19:49.000
次に、App Store Serverライブラリを使用して、Get Transaction Historyエンドポイントで使用するトランザクションIDの抽出を実演します。

00:19:49.000 --> 00:19:56.000
ここでは、アプリの領収書を取得し、トランザクションIDを抽出し、IDを使用してGet Transaction Historyエンドポイントを呼び出します。

00:19:56.000 --> 00:19:58.000
まず、アプリの領収書。

00:19:58.000 --> 00:20:03.000
デバイスまたはApp Store Server Notification V1からアプリの領収書を入手できます。

00:20:03.000 --> 00:20:05.000
私はすでにここに1つ持っています。

00:20:05.000 --> 00:20:09.000
次に、ReceiptUtilityクラスのインスタンスを作成します。

00:20:09.000 --> 00:20:15.000
トランザクションIDを抽出するには、アプリのレシートメソッドから抽出トランザクションIDを呼び出します。

00:20:15.000 --> 00:20:17.000
すべての領収書にトランザクションIDがあるわけではありません。

00:20:17.000 --> 00:20:20.000
ユーザーが何も購入していない可能性があります。

00:20:20.000 --> 00:20:24.000
したがって、ヌルチェックを追加します。

00:20:24.000 --> 00:20:34.000
この問題にもう少し深みを提供するために、このユーザーの最新の消耗品に関する情報を入手し、取り消された消耗品を除外したいと想像してください。

00:20:34.000 --> 00:20:49.000
トランザクション履歴要求オブジェクトを作成し、取り消されたトランザクションを除外するCONSUMABLEタイプの製品のみが求められ、データを降順で返されることを指定します。

00:20:49.000 --> 00:20:55.000
2つのヘルパーオブジェクト、応答変数、およびトランザクションのリストが必要です。

00:20:55.000 --> 00:21:00.000
Do whileは、トランザクション履歴エンドポイントからの応答を介してページをループします。

00:21:00.000 --> 00:21:06.000
これが最初の要求でない場合は、前の応答からリビジョントークンを取得して、データをページングし続けます。

00:21:06.000 --> 00:21:16.000
次に、アプリのレシート、リクエストオブジェクト、およびリビジョンからのトランザクションIDを使用して、トランザクション履歴の取得エンドポイントを呼び出します。

00:21:16.000 --> 00:21:21.000
最後に、応答からすべてのトランザクションをトランザクションリストに追加します。

00:21:21.000 --> 00:21:27.000
応答のhasMoreフィールドがfalseになるまで、このプロセスを繰り返します。

00:21:27.000 --> 00:21:36.000
トランザクションを印刷して結果を確認してください。

00:21:36.000 --> 00:21:41.000
ここでは、APIから返されたトランザクションのリストが表示されます。

00:21:41.000 --> 00:21:46.000
前のデモのSignedDataVerifierを使用してデコードできます。

00:21:46.000 --> 00:21:51.000
App Store Server APIでApp Receiptsを使用する方法を示した最終デモンストレーションにご参加いただきありがとうございます。

00:21:51.000 --> 00:21:53.000
私たちを包むためにデイブに戻ります。

00:21:53.000 --> 00:22:04.000
デイブ：新しいApp Store Serverライブラリに本当に興奮しており、これらの機能がAPIの採用を容易にし、App Store Server APIに移行すると思います。

00:22:04.000 --> 00:22:09.000
これは、GithubのApp Store Server API Javaリポジトリのスクリーンショットです。

00:22:09.000 --> 00:22:17.000
このページでは、ドキュメントへのリンクを見つけたり、プルリクエストを送信したり、ライブラリの使用方法の例を見つけることができます。

00:22:17.000 --> 00:22:24.000
すぐにApp Store ServerライブラリBETAをダウンロードして、App Store Server APIの採用計画を開始できます。

00:22:24.000 --> 00:22:27.000
フィードバックや機能のリクエストをお待ちしております。

00:22:27.000 --> 00:22:31.000
フィードバックアシスタントとGithubでお問い合わせください。

00:22:31.000 --> 00:22:32.000
ありがとうございます。

00:22:32.000 --> 23:59:59.000
♪ ♪

