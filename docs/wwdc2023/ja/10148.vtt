WEBVTT

00:00:00.000 -> 00:00:04.000
♪まろやかなインストゥルメンタルヒップホップ♪

00:00:04.000 -> 00:00:10.000
♪

00:00:10.000 -> 00:00:12.000
カート・クリフトン：こんにちは、参加してくれてありがとう。

00:00:12.000 -> 00:00:16.000
私はCurtで、SwiftUIチームのエンジニアです。

00:00:16.000 -> 00:00:17.000
ジェフ・ロバートソン:そして、私はジェフです。

00:00:17.000 -> 00:00:19.000
私はSwiftUIチームのエンジニアでもあります。

00:00:19.000 -> 00:00:23.000
SwiftUIの新機能を共有する機会があることを嬉しく思います。

00:00:23.000 -> 00:00:29.000
Curt: SwiftUIは、まったく新しいプラットフォームを含め、さらに多くの場所で使用できるようになりました!

00:00:29.000 -> 00:00:36.000
新しいデータフロータイプは、ドメインのモデリングを劇的に簡素化し、これまで以上に多くの電力を提供します。

00:00:36.000 -> 00:00:42.000
インスペクタとテーブルの改善は、データを表示するための優れた方法を提供します。

00:00:42.000 -> 00:00:50.000
チームはアニメーションAPIを増幅し、アプリを使用している人々のためにさらに美しい体験を作成できるようにしました。

00:00:50.000 -> 00:01:04.000
フレームワーク全体で、強力なスクロールビューの改善、フォーカスとキーボード入力の改良、ボタンやメニューなどのコントロールのより深いカスタマイズなど、優れたインタラクションを提供する能力を強化しました。

00:01:04.000 -> 00:01:10.000
SwiftUIを使用するためのいくつかの素晴らしい新しい場所についてお話しできることを嬉しく思います。

00:01:10.000 -> 00:01:22.000
ヘッドセットやwatchOS 10から新しいウィジェットやクロスフレームワークの統合まで、SwiftUIはアプリを使用する人々を喜ばせる体験を生み出すのに役立ちます。

00:01:22.000 -> 00:01:38.000
空間コンピューティングは、ボリュームなどのまったく新しい3D機能、没入型スペースでの豊かな体験、新しい3Dジェスチャー、エフェクト、レイアウト、RealityKitとの深い統合により、SwiftUIを大胆な新しい未来にもたらします。

00:01:38.000 -> 00:01:55.000
コントロールセンターのホームビューのようなコアピースから、テレビ、サファリ、フリーフォームなどの使い慣れたアプリまで、基調講演の没入型リハーサルのようなまったく新しい環境まで、SwiftUIはこれらのユーザーエクスペリエンスの中心にあります。

00:01:55.000 -> 00:02:01.000
この新しいプラットフォームでは、WindowGroupのような使い慣れたシーンタイプを使用してウィンドウを構築します。

00:02:01.000 -> 00:02:08.000
WindowGroupのシーンは、楽しい深度に敏感な3Dコントロールで、2Dウィンドウとしてレンダリングされます。

00:02:08.000 -> 00:02:17.000
ウィンドウ内で、NavigationSplitViewやTabViewなどの通常のSwiftUIコンテナの1つを選択します。

00:02:17.000 -> 00:02:24.000
これらのコンテナ内では、他のプラットフォームと同様に、通常のSwiftUIコントロールをすべて使用できます。

00:02:24.000 -> 00:02:29.000
さらに深みを得るには、ボリュームスタイルをシーンに適用してください。

00:02:29.000 -> 00:02:35.000
ボリュームは、ボードゲームや建築モデルなどの3D体験を境界空間で表示します。

00:02:35.000 -> 00:02:38.000
それらは他のアプリと一緒に表示されます。

00:02:38.000 -> 00:02:44.000
人々は、メモに考えを書き留めたり、Keynoteでスライドを更新したりしながら、あなたのコンテンツを使用することができます。

00:02:44.000 -> 00:02:49.000
Model3Dを使用して静的モデルでボリュームを埋めます。

00:02:49.000 -> 00:02:56.000
照明効果などを備えたダイナミックでインタラクティブなモデルには、新しいRealityViewを使用してください。

00:02:56.000 -> 00:03:00.000
本当に全力を尽くすには、ImmersiveSpacesをアプリに追加してください。

00:03:00.000 -> 00:03:09.000
新しいImmersiveSpaceシーンタイプでは、周囲に埋め込まれているか、完全に没入しているかにかかわらず、没入感のある空間体験を定義できます。

00:03:09.000 -> 00:03:15.000
このシステムは、他のアプリを遠ざけ、人々があなたが作った世界に飛び込むようにします。

00:03:15.000 -> 00:03:24.000
混合イマージョンスタイルのImmersiveSpaceを使用して、アプリを現実世界に接続し、コンテンツを人々の環境と組み合わせます。

00:03:24.000 -> 00:03:32.000
アプリの要素をテーブルやサーフェスに固定し、仮想オブジェクトとエフェクトで現実世界を増強し、豊かにします。

00:03:32.000 -> 00:03:37.000
完全なイマージョンスタイルでさらに進んでください。

00:03:37.000 -> 00:03:40.000
あなたのアプリは完全にコントロールします。

00:03:40.000 -> 00:03:47.000
ボリュームで動作する同じModel3DとRealityViewを使用して、これらの接続された没入型エクスペリエンスを構築します。

00:03:47.000 -> 00:03:52.000
この新しいプラットフォームのSwiftUIを使用すると、魔法のような体験を作成できます。

00:03:52.000 -> 00:03:59.000
「空間コンピューティングのためのSwiftUIに会う」を見て、この素晴らしい組み合わせを探求し続けてください。

00:03:59.000 -> 00:04:08.000
SwiftUIは自宅で部屋いっぱいの体験を構築していますが、Appleの最もポータブルなディスプレイの体験を構築することもできます。

00:04:08.000 -> 00:04:20.000
watchOS 10は、タイムリーな情報を明らかにし、焦点を絞ったコンテンツを一目で伝え、ディスプレイの形状と忠実度を祝う、再設計されたユーザーエクスペリエンスを提供します。

00:04:20.000 -> 00:04:27.000
この美しいフルスクリーンの色と画像を活用するために、プラットフォーム全体でアプリを更新しました。

00:04:27.000 -> 00:04:34.000
これらのデザインの根底には、watchOS 10用に新しく強化されたいくつかの既存のSwiftUIビューがあります。

00:04:34.000 -> 00:04:40.000
NavigationSplitViewとNavigationStackは、美しい新しいトランジションを取得します。

00:04:40.000 -> 00:04:45.000
TabViewは、デジタルクラウンによって駆動される新しい垂直ページングスタイルを取得します。

00:04:45.000 -> 00:04:53.000
SwiftUIは、このフルカラーのセンスをApple Watchアプリにももたらすのに役立つ新しいAPIを導入しています。

00:04:53.000 -> 00:05:01.000
新しいcontainerBackground修飾子を使用すると、コンテンツをプッシュしてポップするときにアニメーション化するこれらの微妙な背景ウォッシュを設定できます。

00:05:01.000 -> 00:05:05.000
watchOSでタブビューの背景を設定することもできます。

00:05:05.000 -> 00:05:19.000
そして、新しいマルチプラットフォームツールバーの配置 - topBarLeadingとtopBarTrailing、および既存のbottomBar - を使用すると、これらの小さな詳細ビューをApple Watchアプリに完璧に配置できます。

00:05:19.000 -> 00:05:30.000
これらの新しい追加に加えて、DatePickerやリストの選択など、既存のAPIを初めてwatchOSに持ち込むことを嬉しく思います。

00:05:30.000 -> 00:05:35.000
今、これらの新機能でApple Watchアプリを磨くのに最適な時期です。

00:05:35.000 -> 00:05:40.000
そして、まだApple Watchアプリをお持ちでない場合は、始めるのに最適な時期です。

00:05:40.000 -> 00:05:47.000
「watchOS 10用のアプリの設計と構築」で、デザインとエンジニアリングがどのように連携してこれらの体験を生み出すかを学びましょう。

00:05:47.000 -> 00:05:54.000
次に、「watchOS 10用にアプリをアップデートする」を使用して、これらのアイデアを作業に適用します。

00:05:54.000 -> 00:06:01.000
watchOS 10のスマートスタックのウィジェットを使用すると、アプリを使用しているユーザーが外出先で情報を見ることができます。

00:06:01.000 -> 00:06:08.000
SwiftUIは、これらの他の新しい場所のように、どこに現れてもウィジェットの中核です。

00:06:08.000 -> 00:06:15.000
iPadOS 17のロック画面のウィジェットは、ホーム画面のウィジェットを補完するものです。

00:06:15.000 -> 00:06:21.000
大きくて大胆なウィジェットは、スタンバイモードでiPhoneの常時オンディスプレイに輝きます。

00:06:21.000 -> 00:06:27.000
また、macOS Sonomaのデスクトップウィジェットは、日々の間、人々を最新の状態に保ちます。

00:06:27.000 -> 00:06:32.000
ウィジェットは新しい場所への道を見つけ、チームは彼らに別のトリックを教えました。

00:06:32.000 -> 00:06:37.000
ウィジェットがインタラクティブなコントロールをサポートするようになったことを共有できることを嬉しく思います。

00:06:37.000 -> 00:06:44.000
ウィジェットのトグルとボタンは、App Intentsを使用して、独自のアプリバンドルで定義されたコードをアクティブにできるようになりました。

00:06:44.000 -> 00:06:50.000
また、SwiftUIトランジションとアニメーション修飾子を使用してウィジェットをアニメーション化できます。

00:06:50.000 -> 00:06:58.000
これらの素晴らしい新機能を使い始めるには、「ウィジェットを新しい場所へ」と「ウィジェットに命を吹き込み」をチェックしてください。

00:06:58.000 -> 00:07:05.000
新しいインタラクティブなアニメーションウィジェットを開発して改良するには、Xcodeプレビューのパワーを気に入るはずです。

00:07:05.000 -> 00:07:12.000
プレビューは、Swift 5.9のマクロを活用して、エレガントな新しい構文を提供します。

00:07:12.000 -> 00:07:19.000
プレビューを宣言して設定し、ウィジェットタイプを追加し、テストのタイムラインを定義します。

00:07:19.000 -> 00:07:26.000
Xcodeプレビューは、現在のウィジェットの状態と、状態間のアニメーションを確認できるタイムラインを表示します。

00:07:26.000 -> 00:07:31.000
もちろん、新しいプレビューは、通常のSwiftUIビューやアプリでも機能します。

00:07:31.000 -> 00:07:38.000
そして、Xcode内でMacアプリのプレビューと対話できるようになりました。

00:07:38.000 -> 00:07:48.000
「XcodeプレビューでプログラマティックUIを構築する」というトークをチェックして、これらの素晴らしい新しいツールを活用してアプリとウィジェットの開発を加速する方法を学びましょう。

00:07:48.000 -> 00:07:55.000
プレビューに電力を供給するマクロに加えて、Swift 5.9は他の多くの改善をもたらします。

00:07:55.000 -> 00:08:02.000
「Swiftの新機能」をキューイングして、Swiftで新鮮なものの概要を把握しましょう。

00:08:02.000 -> 00:08:09.000
SwiftUIが新しい場所に来るもう1つの方法は、他のAppleフレームワークへのSwiftUI固有の拡張機能です。

00:08:09.000 -> 00:08:17.000
いくつかのフレームワークは、新しいまたは改善されたサポートをもたらし、私は特にエキサイティングだと思ういくつかを強調したいと思います。

00:08:17.000 -> 00:08:24.000
MapKitは、SwiftUIコードでAppleの素晴らしいマッピングフレームワークの力を提供する大規模なアップデートを提供します。

00:08:24.000 -> 00:08:29.000
SwiftUIとMapKitをインポートするだけで、これらの素晴らしい機能を使用できます。

00:08:29.000 -> 00:08:31.000
あなたのビューに地図を入れてください。

00:08:31.000 -> 00:08:35.000
カスタムマーカー、ポリライン、およびユーザーの位置情報を追加します。

00:08:35.000 -> 00:08:38.000
利用可能なコントロールを設定します。

00:08:38.000 -> 00:08:45.000
SwiftUIアプリに素晴らしいマップを追加することについてすべて学ぶには、「SwiftUIのMapKitに会う」というトークをチェックしてください。

00:08:45.000 -> 00:09:03.000
2年生のシーズンでは、Swift Chartsは、スクロールチャート、選択のための組み込みサポート、そして人々が飢えていることを知っているものなど、多くの大きな改善をもたらします：新しいSectorMarkでドーナツと円グラフ。

00:09:03.000 -> 00:09:10.000
これらの新機能を掘り下げるには、「Swift Chartsで円グラフとインタラクティブ性を探る」というトークをチェックしてください。

00:09:10.000 -> 00:09:19.000
忠実な顧客を引き付け、維持する体験を構築するために、新しいアプリ内購入とサブスクリプションストアの使いやすさとパワーを気に入るはずです。

00:09:19.000 -> 00:09:24.000
カスタムマーケティングコンテンツを含むサブスクリプションストアビューを提示します。

00:09:24.000 -> 00:09:31.000
ブランディングに合わせてフルブリードの背景を設定し、さまざまなコントロールオプションから選択します。

00:09:31.000 -> 00:09:38.000
「Meet StoreKit for SwiftUI」を見て、アプリ内マーケティングゲームをパワーアップしましょう。

00:09:38.000 -> 00:09:48.000
新しいプラットフォームやウィジェットから、クロスフレームワークの統合、watchOSの美しさまで、SwiftUIはAppleの開発者体験を前進させ続けています。

00:09:48.000 -> 00:09:52.000
SwiftUIを使用するすべての新しい場所を見るのはエキサイティングです、ジェフ。

00:09:52.000 -> 00:09:57.000
ジェフ：確かに！また、すべてのプラットフォームで機能する多くの大きな改善もあります。

00:09:57.000 -> 00:09:59.000
カート：確かに！

00:09:59.000 -> 00:10:01.000
ジェフ：これらの改善点を使用するアプリに取り組むべきです。

00:10:01.000 -> 00:10:02.000
カート：ああ、同意しました！

00:10:02.000 -> 00:10:05.000
私のアイデアについてもっと考えましたか？

00:10:05.000 -> 00:10:07.000
ジェフ：犬についてのやつ？カート：うん！

00:10:07.000 -> 00:10:11.000
それはバードウォッチングのようなものですが、犬向けです!

00:10:11.000 -> 00:10:14.000
ジェフ：あなたは本当に人々がドッグウォッチングアプリを望んでいると思いますか？

00:10:14.000 -> 00:10:18.000
カート：ああ、確かに！ピッチデッキは実質的に自分自身を書きます。

00:10:18.000 -> 00:10:23.000
ジェフ：100万ドルのアイデアが整ったので、アプリの構築を開始する時が来ました。

00:10:23.000 -> 00:10:32.000
すべての素晴らしいアプリは素晴らしいデータモデルから始まるので、SwiftUIがアプリのデータを操作するための素晴らしい新機能のパックを見ることから始めましょう。

00:10:32.000 -> 00:10:39.000
SwiftUIについて私が好きなことの1つは、UIをアプリの状態の関数として定義できることです。

00:10:39.000 -> 00:10:46.000
SwiftUIでモデルタイプを定義する方法の最大のアップグレードを共有できることを嬉しく思います。新しいObservableマクロです。

00:10:46.000 -> 00:10:55.000
観測可能なモデルを使用すると、データフローに使い慣れたSwiftUIパターンを使用すると同時に、コードをより簡潔でパフォーマンスの高いものにすることができます。

00:10:55.000 -> 00:11:01.000
これは、外出中に会った犬を表すデータを保存するために設定したモデルクラスです。

00:11:01.000 -> 00:11:05.000
このタイプをObservableにするには、自分のタイプにマクロを追加します。

00:11:05.000 -> 00:11:07.000
私がする必要があるのはそれだけです。

00:11:07.000 -> 00:11:12.000
ObservableObjectとは異なり、プロパティを公開済みとしてマークする必要はありません。

00:11:12.000 -> 00:11:18.000
観測可能なモデルは、データフローのための既存のSwiftUIメカニズムに簡単に統合できます。

00:11:18.000 -> 00:11:21.000
私のDogCardビューを例に挙げてみましょう。

00:11:21.000 -> 00:11:28.000
ビューでObservableを使用する場合、SwiftUIは読み込むプロパティへの依存関係を自動的に確立します。

00:11:28.000 -> 00:11:34.000
また、読み取り時にプロパティラッパーを使用する必要がないため、ビューコードはよりクリーンになります。

00:11:34.000 -> 00:11:40.000
そして、このビューはisFavoriteプロパティを読んでいるので、それが変更されると再評価されます。

00:11:40.000 -> 00:11:50.000
無効化は読み込まれたプロパティに対してのみ行われるため、不要な更新をトリガーすることなく、中間ビューを介してモデルを渡すことができます。

00:11:50.000 -> 00:12:01.000
SwiftUIには、状態とビューとの関係を定義するためのいくつかのツールが含まれており、そのうちのいくつかはObservableObjectで使用するために設計されています。

00:12:01.000 -> 00:12:11.000
Observableを使用すると、状態と環境の動的プロパティで直接動作するように設計されているため、これはさらに簡単になります。

00:12:11.000 -> 00:12:21.000
読み取り専用値のモデリングに加えて、Observablesは、新しい犬の目撃のためのこのフォームのように、可変状態を表すのに自然に適合します。

00:12:21.000 -> 00:12:32.000
モデルはState dynamicプロパティを使用して定義され、そのプロパティの編集を担当するフォーム要素にそのプロパティへのバインディングを渡しています。

00:12:32.000 -> 00:12:37.000
最後に、Observableタイプは環境にシームレスに統合されます。

00:12:37.000 -> 00:12:44.000
アプリ全体のビューは、現在のユーザーを取得する方法を望んでいるので、ルートビューの環境に追加しました。

00:12:44.000 -> 00:12:49.000
次に、ユーザープロファイルビューは、環境動的プロパティを使用して値を読み取ります。

00:12:49.000 -> 00:12:54.000
ここでは環境キーとしてタイプを使用していますが、カスタムキーもサポートされています。

00:12:54.000 -> 00:13:02.000
この強力な新しいツールを活用する方法の詳細については、「SwiftUIで観察を発見する」を必ずキャッチしてください。

00:13:02.000 -> 00:13:06.000
Observableで明確で簡潔なコードを書くことができるのが大好きです。

00:13:06.000 -> 00:13:16.000
それは私のアプリの素晴らしいスタートを与えてくれましたが、お気に入りの子犬を見失わないように、データモデルの変更が持続していることを確認したいと思います。

00:13:16.000 -> 00:13:20.000
SwiftDataは、データモデリングと管理のためのまったく新しいフレームワークです。

00:13:20.000 -> 00:13:24.000
高速でスケーラブルで、SwiftUIでうまく機能します。

00:13:24.000 -> 00:13:31.000
SwiftDataモデルはコードで完全に表されるため、SwiftUIアプリに自然に適合します。

00:13:31.000 -> 00:13:37.000
SwiftDataのDogモデルタイプを設定するには、Observableの使用からModelマクロに切り替えます。

00:13:37.000 -> 00:13:39.000
これが私が行う必要がある唯一の変更です。

00:13:39.000 -> 00:13:46.000
SwiftDataが提供する永続性に加えて、モデルはObservableを使用するすべての利点も受けられます。

00:13:46.000 -> 00:13:48.000
それは本当に強力です。

00:13:48.000 -> 00:13:54.000
私たちのドッグウォッチングアプリのメイン画面には、最近出会った犬のスクロールスタックが表示されます。

00:13:54.000 -> 00:13:58.000
ここでSwiftDataを使用するために必要な変更点について説明しましょう。

00:13:58.000 -> 00:14:04.000
まず、アプリの定義にモデルコンテナを追加し、モデルタイプを提供します。

00:14:04.000 -> 00:14:11.000
次に、ビューコードで、新しいクエリ動的プロパティを使用するように犬の配列を切り替えます。

00:14:11.000 -> 00:14:16.000
クエリを使用すると、基礎となるデータベースからモデル値を取得するようにSwiftDataに指示されます。

00:14:16.000 -> 00:14:22.000
新しい犬を見つけたときのように、データが変わると、私のビューは無効になります。

00:14:22.000 -> 00:14:35.000
クエリは、大規模なデータセットに対して非常に効率的であり、犬を見つけた日付を使用するようにソート順を変更するなど、データの戻り方法のカスタマイズが可能になり、アプリでのエクスペリエンスが向上します。

00:14:35.000 -> 00:14:40.000
SwiftDataは、ドキュメントのデータをmacOSとiOSに保存するのにも最適です。

00:14:40.000 -> 00:14:52.000
アプリのドッグタグビジュアルトリートメントのプロトタイプを素早く試したいと思ったので、Curtとデザイナーとコラボレーションするためのこの小さなドキュメントベースのアプリを構築しました。

00:14:52.000 -> 00:14:58.000
ドキュメントベースのアプリは、新しい初期化子を使用してSwiftDataのすべての機能を利用できます。

00:14:58.000 -> 00:15:06.000
SwiftUIは、各ドキュメントの基礎となるストレージにSwiftDataを使用し、モデルコンテナを自動的に設定します。

00:15:06.000 -> 00:15:14.000
SwiftDataとSwiftUIとの統合方法の詳細については、「Meet SwiftData」と「SwiftDataでアプリを構築する」をご覧ください。

00:15:14.000 -> 00:15:32.000
SwiftDataのサポートに加えて、DocumentGroupは、iOS 17またはiPadOS 17で実行すると、自動共有やドキュメントの名前変更のサポート、ツールバーの取り消しコントロールなど、多くの新しいプラットフォームのアフォーダンスも得ることができます。

00:15:32.000 -> 00:15:39.000
インスペクタは、現在の選択またはコンテキストの詳細を表示するための新しい修飾子です。

00:15:39.000 -> 00:15:43.000
それはあなたのインターフェースの明確なセクションとして提示されています。

00:15:43.000 -> 00:15:47.000
macOSでは、Inspectorは末尾のサイドバーとして表示されます。

00:15:47.000 -> 00:15:50.000
レギュラーサイズのクラスでiPadOSでも。

00:15:50.000 -> 00:15:55.000
コンパクトサイズのクラスでは、シートとして表示されます。

00:15:55.000 -> 00:16:02.000
インスペクターのすべての詳細を明らかにするには、「SwiftUIのインスペクター：詳細を発見する」をご覧ください。

00:16:02.000 -> 00:16:09.000
ダイアログには、iOS 17とmacOS Sonomaでいくつかの新しいカスタマイズAPIが与えられています。

00:16:09.000 -> 00:16:18.000
新しい修飾子のいくつかを使用して、画像エクスポートダイアログに、確認ボタンのラベルの調整など、いくつかの有用な情報を与えています。

00:16:18.000 -> 00:16:32.000
重大度の増加は、重要な確認ダイアログに注意を引くのに役立ち、抑制トグルを含めることは、ダイアログがその後のインタラクションのために自分自身を表示すべきではないという好みを示します。

00:16:32.000 -> 00:16:38.000
最後に、HelpLinkを追加すると、ダイアログの目的に関する詳細情報のガイドになります。

00:16:38.000 -> 00:16:49.000
リストとテーブルはほとんどのアプリの重要な部分であり、SwiftUIはiOS 17とmacOS Sonomaでそれらを微調整するためのいくつかの新機能とAPIをもたらしました。

00:16:49.000 -> 00:16:53.000
テーブルは、列の順序と可視性のカスタマイズをサポートします。

00:16:53.000 -> 00:17:00.000
SceneStorageの動的プロパティと組み合わせると、これらの設定はアプリの実行中に保持できます。

00:17:00.000 -> 00:17:09.000
カスタマイズ状態を表す値をテーブルに提供し、各列に一意の安定した識別子を与えます。

00:17:09.000 -> 00:17:12.000
テーブルには、OutlineGroupのすべてのパワーも組み込まれています。

00:17:12.000 -> 00:17:22.000
これは、私のお気に入りの犬のいくつかを誇り高い両親とグループ化するこのような、階層構造に適した大規模なデータセットに最適です。

00:17:22.000 -> 00:17:30.000
新しいDisclosureTableRowを使用して、他の行を含む行を表し、通常どおりテーブルの残りの部分をビルドするだけです。

00:17:30.000 -> 00:17:35.000
リストまたはテーブル内のセクションは、プログラマティック拡張のサポートを得ています。

00:17:35.000 -> 00:17:44.000
アプリのサイドバーで使用して、ロケーションセクションを最初に折りたたんだものとして表示しましたが、拡張はまだ許可されています。

00:17:44.000 -> 00:17:51.000
新しい初期化子は、セクションの現在の展開状態を反映した値にバインディングします。

00:17:51.000 -> 00:18:01.000
小規模なデータセットの場合、テーブルは、行の背景や列ヘッダーの表示方法など、いくつかの新しいスタイリングアフォーダンスも得ています。

00:18:01.000 -> 00:18:09.000
そして最後に、私の星評価のようなカスタムコントロールも、新しいバックグラウンドプロミネンス環境プロパティの恩恵を受けるでしょう。

00:18:09.000 -> 00:18:16.000
背景が目立つときに目立たないフォアグラウンドスタイルを使用すると、カスタムコントロールをリストでくつろげることができます。

00:18:16.000 -> 00:18:28.000
リストやテーブルのルックアンドフィールを微調整できるこれらのAPIやその他のAPIに加えて、特に大規模なデータセットを扱う場合、パフォーマンスを大幅に改善しました。

00:18:28.000 -> 00:18:37.000
これと、独自のSwiftUIビューを最適化する方法の詳細については、「SwiftUIのパフォーマンスを解明する」をチェックしてください。

00:18:37.000 -> 00:18:45.000
ObservableからSwiftData、Inspector、テーブルのカスタマイズまで、アプリ内のデータの操作はまったく新しい体験のように感じられます。

00:18:45.000 -> 00:18:52.000
カート：ジェフがまとめたデータモデルとテーブルで、私たちは素晴らしいアプリの骨を持っています。

00:18:52.000 -> 00:18:57.000
並外れた新しいアニメーションAPIを使って、いくつかのピザを追加したいと思います。

00:18:57.000 -> 00:19:02.000
犬の写真のギャラリーを見るためのApple TVアプリがあればいいと思います。

00:19:02.000 -> 00:19:07.000
これは私が現在の視聴者を選択するために取り組んできたアニメーションです。

00:19:07.000 -> 00:19:11.000
私は新しいKeyframe Animator APIでこれを構築しました。

00:19:11.000 -> 00:19:15.000
キーフレームアニメーターは、複数のプロパティを並行してアニメーション化できるようにしました。

00:19:15.000 -> 00:19:23.000
私はアニメーターにアニメ可能なプロパティと等しい状態の一部を含む値を与えます。

00:19:23.000 -> 00:19:26.000
状態の変更は、私のアニメーションをトリガーします。

00:19:26.000 -> 00:19:34.000
最初のクロージャでは、ロゴの垂直オフセットのように、アニメーション可能なプロパティによって変更されたビューを構築します。

00:19:34.000 -> 00:19:38.000
2番目のクロージャでは、これらのプロパティが時間の経過とともにどのように変化するかを定義します。

00:19:38.000 -> 00:19:44.000
たとえば、最初のトラックは、私のverticalTranslationプロパティのアニメーションを定義します。

00:19:44.000 -> 00:19:50.000
春のアニメーションを使用して、第1四半期にロゴを30ポイント引き下げます。

00:19:50.000 -> 00:19:54.000
その後、私はビーグルを飛躍させ、立方曲線を使って着陸させます。

00:19:54.000 -> 00:19:59.000
最後に、私は自然の春のアニメーションでこの犬を家に持ち帰ります。

00:19:59.000 -> 00:20:03.000
他のアニメーションプロパティの追加トラックを定義します。

00:20:03.000 -> 00:20:08.000
これらのトラックはすべて、このクールなアニメーションを作成するために並行して実行されます。

00:20:08.000 -> 00:20:16.000
アプリでキーフレームアニメーターを活用する方法を学ぶには、「SwiftUIで高度なアニメーションを駆け抜ける」をチェックしてください。

00:20:16.000 -> 00:20:21.000
私はまた、ランニング中に犬の目撃情報を記録するためにApple Watchアプリに取り組んでいます。

00:20:21.000 -> 00:20:26.000
これまでのところかなりシンプルで、私たちの幸せなアイコンと目撃を登録するためのボタンだけです。

00:20:26.000 -> 00:20:29.000
ボタンをタップすると、このアイコンをアニメーション化したいです。

00:20:29.000 -> 00:20:33.000
これはフェーズアニメーターにとって良い場所です。

00:20:33.000 -> 00:20:36.000
フェーズアニメーターは、キーフレームアニメーターよりも簡単です。

00:20:36.000 -> 00:20:41.000
並列トラックの代わりに、単一の一連のフェーズをステップスルーします。

00:20:41.000 -> 00:20:46.000
これにより、前のアニメーションが終了したときに1つのアニメーションを開始できます。

00:20:46.000 -> 00:20:52.000
私はアニメーターに一連のフェーズを与え、私の目撃カウントが変わるたびに私のアニメーションを実行するように指示します。

00:20:52.000 -> 00:20:59.000
そして、この最初の閉鎖で、私は現在の段階に基づいて私の幸せな犬の回転とスケールを設定しました。

00:20:59.000 -> 00:21:05.000
2番目のクロージャは、各フェーズにアニメーション化する方法をSwiftUIに伝えます。

00:21:05.000 -> 00:21:07.000
私はここでクールな新しい春のアニメーションのいくつかを使用しています。

00:21:07.000 -> 00:21:10.000
私はただこれらの名前が大好きです。

00:21:10.000 -> 00:21:14.000
軽快なアニメーションや弾力のあるアニメーションを望まない人はいますか?

00:21:14.000 -> 00:21:18.000
そして、私の成長段階では、私は完全にカスタムスプリングを使用しています。

00:21:18.000 -> 00:21:23.000
スプリングは持続時間を取り、バウンスし、説明しやすくなりました。

00:21:23.000 -> 00:21:28.000
SwiftUIアニメーションを取るこれらの新しいスプリングはどこでも使用できます。

00:21:28.000 -> 00:21:31.000
春のアニメーションは素敵で自然な感じがします。

00:21:31.000 -> 00:21:37.000
それらは以前のアニメーションの速度と一致し、現実的な摩擦で最終的な値に落ち着きます。

00:21:37.000 -> 00:21:44.000
それらは現在、iOS 17以降に構築されたアプリと調整されたリリースのデフォルトのアニメーションです。

00:21:44.000 -> 00:21:50.000
私は今、私のアニメーションに満足していますが、私が走っているとき、それはまた、いくつかの触覚フィードバックを得るのは素晴らしいことです。

00:21:50.000 -> 00:21:58.000
触覚フィードバックは、タップなどの触覚応答を提供し、注意を引き、行動やイベントを強化します。

00:21:58.000 -> 00:22:03.000
手首を叩くと、犬を見逃さなかったという自信が高くなると思います。

00:22:03.000 -> 00:22:07.000
触覚フィードバックは、新しい感覚フィードバックAPIで簡単です。

00:22:07.000 -> 00:22:16.000
触覚フィードバックを再生するには、sensoryFeedback修飾子を添付し、どのようなフィードバックが欲しいか、いつ起こるべきかを指定するだけです。

00:22:16.000 -> 00:22:21.000
sensoryFeedback修飾子は、触覚フィードバックをサポートするすべてのプラットフォームで動作します。

00:22:21.000 -> 00:22:30.000
異なるプラットフォームは異なる種類のフィードバックをサポートしているので、ヒューマンインターフェースガイドラインをチェックして、アプリにどのようなフィードバックが最適かを学んでください。

00:22:30.000 -> 00:22:37.000
また、新しい視覚効果修飾子を使用して、ウェルカム画面のアニメーションにも取り組んできました。

00:22:37.000 -> 00:22:42.000
視覚効果修飾子を使用すると、位置に基づいてこれらの犬の写真を更新することができます。

00:22:42.000 -> 00:22:45.000
そして、それを行うのにGeometryReaderは必要ありません。

00:22:45.000 -> 00:22:49.000
私は画面の周りに焦点を動かす小さなシミュレーションを持っています。

00:22:49.000 -> 00:22:53.000
この赤い点は、焦点の意味を示しています。

00:22:53.000 -> 00:22:58.000
私はすべての犬を示すこのグリッドと座標空間を関連付けます。

00:22:58.000 -> 00:23:03.000
次に、DogCircleビュー内に視覚効果を追加します。

00:23:03.000 -> 00:23:07.000
クロージャは、私のコンテンツを変更し、ジオメトリプロキシを取得します。

00:23:07.000 -> 00:23:11.000
スケールを計算するために、ジオメトリプロキシをヘルパーメソッドに渡しています。

00:23:11.000 -> 00:23:21.000
ジオメトリプロキシを使用して、グリッドビューのサイズと、グリッドビューに対する単一の犬の円のフレームを取得できます。

00:23:21.000 -> 00:23:28.000
これにより、犬がシミュレーションの焦点からどのくらい離れているかを計算できるので、集中したドッグゴをスケールアップできます。

00:23:28.000 -> 00:23:33.000
視覚効果があれば、GeometryReaderを使わずにこれらすべてを行うことができます。

00:23:33.000 -> 00:23:38.000
そして、それは自動的に異なるサイズに適応します。

00:23:38.000 -> 00:23:41.000
もう1つ例を挙げたいと思います。

00:23:41.000 -> 00:23:46.000
私は私が会った犬の人々に良い犬のメッセージを送るための機能で遊んできました。

00:23:46.000 -> 00:23:51.000
犬の名前をスタイリングして目立たせるのは楽しいだろうと思いました。

00:23:51.000 -> 00:23:58.000
別のテキストビュー内で前景スタイルでテキストを補間できるようになったので、これは簡単です。

00:23:58.000 -> 00:23:59.000
そして、それをチェックしてください!

00:23:59.000 -> 00:24:04.000
これらのスライダーを使ってスタイリングを調整できます。

00:24:04.000 -> 00:24:06.000
さて、それはどのように機能しますか?

00:24:06.000 -> 00:24:08.000
私がスタイルを定義する方法は次のとおりです。

00:24:08.000 -> 00:24:17.000
ストライプスペーシングと角度を、アセットカタログの色とともに、カスタムメタルシェーダーに渡しています。

00:24:17.000 -> 00:24:31.000
SwiftUIの新しいShaderLibraryを使用すると、Furdinandの名前でストライプをレンダリングするこのようなSwiftUIシェイプスタイルにメタルシェーダー関数を直接回すことができます。

00:24:31.000 -> 00:24:41.000
Metalシェーダーをスピンアウトしたい場合は、新しいMetalファイルをプロジェクトに追加し、SwiftUIのShaderLibraryを使用してシェーダー関数を呼び出すだけです。

00:24:41.000 -> 00:24:44.000
この例では、私が指摘したいことがもう一つあります。

00:24:44.000 -> 00:24:51.000
スライダーのトラックの端を押すと、シンボルがこの満足のいくバウンスを与えることに注意してください。

00:24:51.000 -> 00:24:55.000
その効果は、macOSとiOSのスライダーに組み込まれています。

00:24:55.000 -> 00:25:01.000
新しいシンボル効果修飾子を使用して、独自のシンボルに追加することもできます。

00:25:01.000 -> 00:25:07.000
この修飾子を適用して、SFシンボル、またはビュー階層内のすべてのシンボルをアニメーション化するだけです。

00:25:07.000 -> 00:25:15.000
シンボルは、パルスや可変色の連続アニメーションなど、さまざまなエフェクトをサポートしています。

00:25:15.000 -> 00:25:25.000
状態はスケールで変化し、現れ、消え、置き換え、イベント通知はバウンスで変化します。

00:25:25.000 -> 00:25:33.000
「アプリでシンボルをアニメーション化」を見て、シンボルエフェクトを使用するための最高の人々を喜ばせるプラクティスについて学んでください。

00:25:33.000 -> 00:25:37.000
この例を残す前に、最後の1つの機能を指摘したいと思います。

00:25:37.000 -> 00:25:40.000
ここのテキストの単位に注目してください。

00:25:40.000 -> 00:25:51.000
以前は、この効果のために小さなキャップを使用していたかもしれませんが、今では新しいtextScale修飾子をユニットに適用することで、この外観を得ることができます。

00:25:51.000 -> 00:26:01.000
ジェフと私がアプリを中国市場に持ち込みた場合、スモールキャップの概念は中国語のタイポグラフィの一部ではないにもかかわらず、ユニットのサイズは正しくなります。

00:26:01.000 -> 00:26:05.000
アプリが複数のロケールでうまく機能するのに役立つ別のツールがあります。

00:26:05.000 -> 00:26:09.000
タイ語のような一部の言語は、背の高い文字形式を使用します。

00:26:09.000 -> 00:26:22.000
これらの言語のいずれかからのテキストが、英語のような短い文字形式の言語にローカライズされたテキストに埋め込まれている場合、背の高いテキストは混雑したり、クリップされたりする可能性があります。

00:26:22.000 -> 00:26:32.000
たとえば、犬の名前がグローバルにクラウドソーシングされている場合など、これが問題になる可能性があることがわかっている場合は、タイプセット言語修飾子を適用できます。

00:26:32.000 -> 00:26:37.000
これにより、SwiftUIはテキストにより多くのスペースが必要になる可能性があることを知らせます。

00:26:37.000 -> 00:26:46.000
私はこれらの新しいAPIを使ってとても楽しんでいますが、圧倒的な人々を避けるためにアニメーションを上品に選択することが重要です。

00:26:46.000 -> 00:26:52.000
SwiftUIのアニメーションの基礎については、「SwiftUIアニメーションを探索する」をチェックしてください。

00:26:52.000 -> 00:27:01.000
その後、「スプリングでアニメーション化」では、ジェイコブはみんなのデバイスでくつろげるアニメーションを構築するのに役立ちます。

00:27:01.000 -> 00:27:05.000
SwiftUIの新しいアニメーションAPIの幅は素晴らしいです。

00:27:05.000 -> 00:27:07.000
私はここで表面を引っ掻いただけです。

00:27:07.000 -> 00:27:14.000
アニメーション補完ハンドラから完全にカスタムアニメーションの構築まで、さらに多くの発見があります。

00:27:14.000 -> 00:27:18.000
あなたが私と同じくらいこれらのAPIを楽しんでくれることを願っています。

00:27:18.000 -> 00:27:23.000
ジェフ：これらすべての新しいアニメーションとエフェクトが本当に私たちのアプリに命を吹き込むのが大好きです。

00:27:23.000 -> 00:27:28.000
さて、最後の仕上げのための新しいインタラクションAPIのいくつかを見てみましょう。

00:27:28.000 -> 00:27:38.000
インタラクションは、優れたアプリ体験の中心であり、これらはiOS 17と調整されたリリースに搭載される更新されたAPIのほんの一部です。

00:27:38.000 -> 00:27:45.000
最近会った犬の私のスクリーンは、それに磨きの最後のビットを与えるために少し余分な才能を使うことができます。

00:27:45.000 -> 00:27:53.000
スクロールビューの可視領域に出入りする際に、犬のカードにいくつかの視覚効果を追加したいと思います。

00:27:53.000 -> 00:28:00.000
スクロール遷移修飾子は、以前にウェルカム画面に使用した視覚効果修飾子Curtと非常によく似ています。

00:28:00.000 -> 00:28:04.000
スクロールビューのアイテムにエフェクトを適用できます。

00:28:04.000 -> 00:28:13.000
スケールと不透明度の効果を使用すると、ほんの数行の余分なコードだけで、私が望んでいたほんの少しの磨きが与えられました。

00:28:13.000 -> 00:28:18.000
また、お気に入りのドッグパークの横スクロールリストをこの画面に追加したいと思います。

00:28:18.000 -> 00:28:22.000
SwiftUIは、これを構築できるようにいくつかの素晴らしい機能を追加しました。

00:28:22.000 -> 00:28:27.000
犬の垂直スタックの上に、私は公園カードのために水平スタックをドロップします。

00:28:27.000 -> 00:28:38.000
新しいcontainerRelativeFrame修飾子を使用して、水平スクロールビューの可視サイズに対してこれらのパークカードのサイズを調整しています。

00:28:38.000 -> 00:28:42.000
カウントは、画面を分割するチャンクの数を指定します。

00:28:42.000 -> 00:28:47.000
スパンは、各ビューが取る必要があるそれらのチャンクの数を示しています。

00:28:47.000 -> 00:28:52.000
これはかなり素晴らしいですが、私のパークカードが所定の位置にスナップしたいです。

00:28:52.000 -> 00:28:56.000
新しいscrollTargetLayout修飾子はそれを簡単にします。

00:28:56.000 -> 00:29:03.000
LazyHStackに追加し、スクロールビューを変更して、ターゲットレイアウトのビューに合わせます。

00:29:03.000 -> 00:29:08.000
ビューの配置に加えて、スクロールビューはページング動作を使用するように定義することもできます。

00:29:08.000 -> 00:29:15.000
また、真にカスタムエクスペリエンスを得るには、scrollTargetBehaviorプロトコルを使用して独自の動作を定義できます。

00:29:15.000 -> 00:29:20.000
私はまた、彼らがスクロールビューの一番上にいるとき、私の雑種犬は少し称賛に値すると思いました。

00:29:20.000 -> 00:29:28.000
新しいscrollPosition修飾子は、一番上のアイテムのIDにバインドされ、スクロールすると更新されます。

00:29:28.000 -> 00:29:31.000
このようにして、私はいつも誰がトップドッグか知っています。

00:29:31.000 -> 00:29:39.000
これらすべてとスクロールビューの他の大きな改善点の詳細については、「スクロールビューを超えて」を必ずご覧ください。

00:29:39.000 -> 00:29:44.000
画像は、ハイダイナミックレンジでコンテンツのレンダリングをサポートするようになりました。

00:29:44.000 -> 00:29:53.000
allowedDynamicRange修飾子を適用することで、アプリのギャラリー画面の美しい画像を完全な忠実度で表示できます。

00:29:53.000 -> 00:29:58.000
しかし、通常は画像が単独で立っているときに、これを控えめに使用するのが最善です。

00:29:58.000 -> 00:30:09.000
SwiftUIで書かれたアプリは、すぐに使えるアクセシビリティ機能でうまく機能しますが、私たちが導入している新しいアクセシビリティAPIのいくつかでそれらをさらに良くすることができます。

00:30:09.000 -> 00:30:17.000
この写真の冒険的な犬は少し遠すぎて見えないので、ズームインできるように倍率のジェスチャーを適用しました。

00:30:17.000 -> 00:30:21.000
また、新しいaccessibilityZoomAction修飾子をビューに追加します。

00:30:21.000 -> 00:30:29.000
これにより、VoiceOverのような支援技術は、ジェスチャーを使用せずに同じ機能にアクセスできます。

00:30:29.000 -> 00:30:36.000
アクションの方向に応じてズームレベルを更新するだけで、彼女が今までどんないたずらをしてきたかがわかります。

00:30:36.000 -> 00:30:40.000
VoiceOver: 画像ビューをズームします。画像。

00:30:40.000 -> 00:30:50.000
ジェフ：Appleのプラットフォーム全体のすべての新しいアクセシビリティ機能の詳細については、「SwiftUIとUIKitでアクセス可能なアプリを構築する」を必ずチェックしてください。

00:30:50.000 -> 00:30:58.000
カラーは、静的メンバー構文を使用して、アプリのアセットカタログで定義されたカスタムカラーを検索できるようになりました。

00:30:58.000 -> 00:31:04.000
これにより、それらを使用する際のコンパイル時の安全性が得られるため、タイプミスに時間を失うことはありません。

00:31:04.000 -> 00:31:10.000
先ほど示したドキュメントアプリでは、ツールバーにいくつかの便利なアクションを含むメニューを追加しました。

00:31:10.000 -> 00:31:21.000
メニューの上部セクションは、新しいcompactMenuスタイルのControlGroupで、そのアイテムを水平スタックのアイコンとして表示します。

00:31:21.000 -> 00:31:26.000
タグカラーセレクターは、新しいパレットスタイルのピッカーとして定義されています。

00:31:26.000 -> 00:31:37.000
シンボル画像と協調してこのスタイルを使用すると、メニュー、特にラベルの色合いを使用してそれらを区別できるこのようなメニューで素晴らしい視覚的表現が得られます。

00:31:37.000 -> 00:31:45.000
最後に、パレット選択効果修飾子を使用すると、シンボルバリアントを使用して、ピッカーで選択したアイテムを表すことができます。

00:31:45.000 -> 00:31:52.000
私のメニューが整っていると、バディのドッグタグは彼のお気に入りの色、テニスボールの黄色になりました。

00:31:52.000 -> 00:31:59.000
境界線付きボタンは、円や丸みを帯びた長方形などの新しい組み込みの図形で定義できるようになりました。

00:31:59.000 -> 00:32:04.000
これらの新しいボーダーシェイプスタイルは、iOS、watchOS、macOSで動作します。

00:32:04.000 -> 00:32:11.000
macOSとiOSのボタンは、ポップオーバーを開くエディタのこのボタンのように、ドラッグアクションに反応できるようになりました。

00:32:11.000 -> 00:32:23.000
新しいspringLoadingBehavior修飾子は、ドラッグが一時停止したとき、またはmacOSで強制クリックしたときに、ボタンがそのアクションをトリガーする必要があることを示しています。

00:32:23.000 -> 00:32:27.000
tvOSのボタンは、新しいハイライトホバー効果を大いに活用できます。

00:32:27.000 -> 00:32:37.000
ギャラリーの画像に使用し、ボタンのラベルの画像部分だけに適用して、プラットフォーム上で自宅のように感じられる効果を作り出しました。

00:32:37.000 -> 00:32:42.000
これらのボタンは、tvOSで利用可能になったボーダレススタイルも使用します。

00:32:42.000 -> 00:32:49.000
ハードウェアキーボードは、アプリ内の一般的なインタラクションの促進剤を提供するのに最適です。

00:32:49.000 -> 00:32:57.000
ハードウェアキーボードをサポートするプラットフォームでのフォーカス可能なビューは、onKeyPress修飾子を使用して、任意のキーボード入力に直接反応できます。

00:32:57.000 -> 00:33:03.000
修飾子は、照合するキーのセットと、イベントに対して実行するアクションを取ります。

00:33:03.000 -> 00:33:10.000
フォーカス関連のレシピをいっぱいにするには、「The SwiftUI cookbook for focus」を必ずご覧ください。

00:33:10.000 -> 00:33:21.000
スクロールの遷移や動作から、ボタンのスタイルやフォーカスインタラクションまで、これらの新しいAPIは、豊富な機能と優れたスタイルを備えたアプリを構築するのに役立ちます。

00:33:21.000 -> 00:33:24.000
カート:私たちはアプリで大きな進歩を遂げたと思います!

00:33:24.000 -> 00:33:26.000
ジェフ:それは確かに何かです。

00:33:26.000 -> 00:33:28.000
Curt: これらすべての新しいAPIを使うのは楽しかったです。

00:33:28.000 -> 00:33:30.000
ジェフ:それだけの真実です。

00:33:30.000 -> 00:33:32.000
Curt: SwiftUIにとってエキサイティングな時期です。

00:33:32.000 -> 00:33:34.000
真新しいプラットフォームがあります!

00:33:34.000 -> 00:33:38.000
ジェフ：ObservableとSwiftDataの優雅さは、SwiftUIでとてもうまく機能します。

00:33:38.000 -> 00:33:41.000
カート:アニメーションの改善は素晴らしいです。

00:33:41.000 -> 00:33:43.000
ジェフ:そして、スクロールビューを忘れないでください!

00:33:43.000 -> 00:33:49.000
カート:私たちの素晴らしい開発者コミュニティがこれらの新しいAPIで何ができるかを見るのはいつもスリルです。

00:33:49.000 -> 00:33:51.000
ジェフ：皆さん、見てくれてありがとう。

00:33:51.000 -> 00:33:52.000
私のためにあなたの犬に挨拶してください!

00:33:52.000 -> 00:33:55.000
カート：素晴らしい仕事を続けてください！

00:33:55.000 -> 23:59:59.000
♪

