WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:11.000
イアン:みなさん、こんにちは。

00:00:11.000 --> 00:00:14.000
私はイアンで、App Storeサーバーチームのエンジニアです。

00:00:14.000 --> 00:00:23.000
今日は、新機能や重要なアップデートなど、アプリ内購入用のサーバーAPIに関するエキサイティングなアップデートを共有します。

00:00:23.000 --> 00:00:32.000
馴染みがない場合は、サーバー上のアプリ内購入を最大限に活用するのに役立つ2つの主要なAPIを提供しています。

00:00:32.000 --> 00:00:35.000
1つ目はApp Store Server APIです。

00:00:35.000 --> 00:00:47.000
サーバーからオンデマンドでApp Store Server APIを呼び出すと、アプリで行われたアプリ内購入を効果的に管理するために必要なすべてのデータが返されます。

00:00:47.000 --> 00:00:57.000
APIは、アプリ内購入データを取得および変更するためのさまざまな強力なエンドポイントを提供します。

00:00:57.000 --> 00:01:03.000
私たちが提供する他の主要なAPIは、App Store Server Notifications V2です。

00:01:03.000 --> 00:01:14.000
App Store Server Notifications V2では、App Storeサーバーは、アプリで行われたアプリ内購入に関する更新をサーバーに積極的に送信します。

00:01:14.000 --> 00:01:22.000
つまり、App Store Server APIをポーリングすることなく、分単位で更新を取得できます。

00:01:22.000 --> 00:01:33.000
通知は、サブスクリプションの更新、有効期限、払い戻しなど、包括的な一連のイベントをカバーしています。

00:01:33.000 --> 00:01:43.000
これらのイベントでは、アプリ内購入のライフサイクル全体を追跡できるため、ユーザーの行動をよりよく理解し、対応することができます。

00:01:43.000 --> 00:01:50.000
App Store Server APIとApp Store Server Notifications V2は、多くの優れた機能を共有しています。

00:01:50.000 --> 00:02:00.000
どちらもおなじみのJSON形式でトランザクションデータを提供し、データは署名されているので、Appleから来たと確信できます。

00:02:00.000 --> 00:02:08.000
両方のAPIを使用して、StoreKit 2またはオリジナルのStoreKit APIを使用するアプリをサポートすることもできます。

00:02:08.000 --> 00:02:15.000
そして、私たちはあなたのフィードバックに基づいて新機能でこれらのAPIを積極的にサポートしています。

00:02:15.000 --> 00:02:26.000
本日、App Store Server APIとApp Store Server Notifications V2のアップデートの最新コレクションを発表できることを嬉しく思います。

00:02:26.000 --> 00:02:32.000
非常に多くの新機能があるので、今日のセッションでいくつかをカバーする時間しかありません。

00:02:32.000 --> 00:02:38.000
これらすべての新機能の詳細については、開発者ドキュメントをご覧ください。

00:02:38.000 --> 00:02:43.000
それでは、App Storeサーバーのアップデートのこの素晴らしい選択に飛び込みましょう。

00:02:43.000 --> 00:02:46.000
今日のアップデートを3つの部分で共有します。

00:02:46.000 --> 00:02:53.000
まず、サーバーでのトランザクションを簡単に操作できる新機能をいくつか詳しく説明します。

00:02:53.000 --> 00:03:02.000
次に、ユーザーのサブスクリプションのステータスを確実に判断するのに役立つApp Storeサーバー通知の機能強化について説明します。

00:03:02.000 --> 00:03:09.000
そして最後に、古いAPIからの移行に関する重要な最新情報を提供します。

00:03:09.000 --> 00:03:12.000
取引を始めましょう。

00:03:12.000 --> 00:03:17.000
トランザクションは、アプリ内購入のコアデータオブジェクトです。

00:03:17.000 --> 00:03:31.000
それらはデバイス上のアプリ内購入を表し、製品識別子、タイプ、購入日など、その購入に関する重要な情報が含まれています。

00:03:31.000 --> 00:03:38.000
App Storeサーバーは、JWSで署名されたJSONオブジェクトを介したトランザクションを表します。

00:03:38.000 --> 00:03:48.000
これは、App Store Server APIとApp Store Server Notifications V2全体で見られる、安全で標準化された形式です。

00:03:48.000 --> 00:03:59.000
これらの署名されたトランザクションを取得する主な方法は、App Store Server APIのGet Transaction Historyエンドポイントを使用することです。

00:03:59.000 --> 00:04:11.000
このエンドポイントは、アプリの特定のユーザーの完全なトランザクション履歴を返すため、過去から現在まで、ユーザーのすべての購入を最新の状態に保つことができます。

00:04:11.000 --> 00:04:19.000
しかし、アプリからサーバーへの呼び出しなど、サーバーがすでにトランザクションを認識している場合があります。

00:04:19.000 --> 00:04:29.000
サーバー側では、そのトランザクションをさらに検証し、最新の情報を持っていることを確認することをお勧めします。

00:04:29.000 --> 00:04:38.000
以前は、このユースケースでは、トランザクション履歴を取得を呼び出し、一致するトランザクションの応答をふるいにかける必要がありました。

00:04:38.000 --> 00:04:44.000
見つかったら、応答のデータを使用してトランザクションの記録を更新できます。

00:04:44.000 --> 00:04:54.000
特に、ユーザーのトランザクション履歴が複数のページにまたがり、エンドポイントへの複数の呼び出しが必要な場合、このプロセスは退屈に感じるかもしれません。

00:04:54.000 --> 00:05:03.000
また、完了した消耗品トランザクションを探している場合も、トランザクション履歴の取得応答に表示されないため、機能しません。

00:05:03.000 --> 00:05:09.000
このユースケースは、単により具体的な解決策を要求します。

00:05:09.000 --> 00:05:15.000
そのため、今日、このユースケースに直接対処する新しいエンドポイントを導入します。

00:05:15.000 --> 00:05:28.000
新しいGet Transaction Infoエンドポイントを使用すると、1回の購入で署名されたトランザクション情報を要求でき、提供する必要があるのはtransactionIdだけです。

00:05:28.000 --> 00:05:36.000
製品の種類やユーザーのデバイス上のトランザクションの終了ステータスに関係なく、すべてのトランザクションIDがサポートされています。

00:05:36.000 --> 00:05:43.000
そうです、このエンドポイントから完成した消耗品を取得することもできます。

00:05:43.000 --> 00:05:47.000
新しいエンドポイントがどのように機能するかを簡単に見てみましょう。

00:05:47.000 --> 00:05:57.000
パスパラメータとしてtransactionIdを含め、App Storeサーバー上のこの新しいエンドポイントにGETリクエストを送信します。

00:05:57.000 --> 00:06:03.000
signedTransactionInfo文字列を含む応答を受け取ります。

00:06:03.000 --> 00:06:13.000
signedTransactionInfoをデコードすることで、リクエストで指定したIDのトランザクション情報を表示できます。

00:06:13.000 --> 00:06:14.000
そして、それだけです。

00:06:14.000 --> 00:06:22.000
新しいGet Transaction Infoエンドポイントは非常にシンプルですが、サーバー上でトランザクションを操作する際の柔軟性が向上します。

00:06:22.000 --> 00:06:26.000
さまざまなユースケースに役立つと思います。お役に立てばできます。

00:06:26.000 --> 00:06:32.000
さて、その柔軟性のテーマを取り、さらに拡張しましょう。

00:06:32.000 --> 00:06:38.000
App Store Server APIのこれらの一般的なエンドポイントに精通しているかもしれません。

00:06:38.000 --> 00:06:44.000
これらの各エンドポイントには、パスパラメータとしてoriginalTransactionIdが必要です。

00:06:44.000 --> 00:06:51.000
このIDは、どのユーザーにデータを要求または送信しているかをサーバーに示します。

00:06:51.000 --> 00:06:55.000
しかし、あなたはいつもオリジナルのTransactionIdを手元に持っているとは限りません。

00:06:55.000 --> 00:06:59.000
あなたが持っているのがトランザクションIDだけの場合はどうなりますか?

00:06:59.000 --> 00:07:09.000
元のTransactionIdを取得するために、新しいGet Transaction Infoエンドポイントに送信できますが、なぜあるエンドポイントを呼び出して別のエンドポイントを呼び出すのですか?

00:07:09.000 --> 00:07:16.000
代わりに、今日から、任意のtransactionIdでこれらのエンドポイントを呼び出すことができます。

00:07:16.000 --> 00:07:21.000
以前と同じように、リクエストのパスにIDを入力するだけです。

00:07:21.000 --> 00:07:28.000
このより大きな柔軟性により、App Store Server APIのこれらのコアエンドポイントの呼び出しがこれまで以上に簡単になることを願っています。

00:07:28.000 --> 00:07:36.000
そして、すでにこれらのエンドポイントをoriginalTransactionIdsで呼び出している場合は、心配しないでください、それらも引き続き機能します。

00:07:36.000 --> 00:07:42.000
では、App Storeサーバー通知のアップデートに切り替えましょう。

00:07:42.000 --> 00:07:52.000
アプリが自動更新サブスクリプションを提供している場合は、それらのサブスクリプションのステータスと時間の経過とともにどのように変化するかを追跡することが重要です。

00:07:52.000 --> 00:07:57.000
ここでは、サブスクリプションの5つの可能なステータスを確認できます。

00:07:57.000 --> 00:08:13.000
App Store Server Notifications V2では、このステータスの変更につながるイベントのプロンプト通知を受け取るため、適切なタイミングでコンテンツをすばやく有効または無効にし、スムーズなユーザーエクスペリエンスを維持できます。

00:08:13.000 --> 00:08:19.000
通知がサブスクリプションのステータスに関する知識をどのように知らせることができるかを見てみましょう。

00:08:19.000 --> 00:08:27.000
多くの通知イベントは、そのタイプとサブタイプを通じてサブスクリプションのステータスを直接示します。

00:08:27.000 --> 00:08:34.000
たとえば、サブタイプINITIAL_BUYを使用したこのSUBSCRIBED通知を考えてみましょう。

00:08:34.000 --> 00:08:43.000
この通知は、製品の新しいサブスクリプションを示すので、サブスクリプションのステータスがアクティブであることがわかります。

00:08:43.000 --> 00:08:49.000
これは、通知タイプがEXPIREDであるさらに簡単な例です。

00:08:49.000 --> 00:08:57.000
これは、関連するサブスクリプションのステータスが期限切れになったことを明確に示しています。

00:08:57.000 --> 00:09:02.000
しかし、一部の通知では、サブスクリプションのステータスがそれほど明確ではないかもしれません。

00:09:02.000 --> 00:09:06.000
例えば、この払い戻し通知を考えてみましょう。

00:09:06.000 --> 00:09:13.000
この通知タイプは、アプリで行われたアプリ内購入の払い戻しが認められたときに送信されます。

00:09:13.000 --> 00:09:21.000
この通知のsignedTransactionInfoを確認すると、どの購入が返金されたかがわかります。

00:09:21.000 --> 00:09:31.000
この場合、払い戻しは自動更新サブスクリプションのものだったため、サブスクリプションのステータスの記録を更新したいと思います。

00:09:31.000 --> 00:09:38.000
ステータスが「Revoked」になったと仮定するのは魅力的かもしれませんが、必ずしもそうとは限りません。

00:09:38.000 --> 00:09:49.000
同じ元のTransactionIdで最近のサブスクリプション更新購入がある場合、サブスクリプションのステータスは引き続きアクティブである可能性があります。

00:09:49.000 --> 00:09:56.000
その場合は、サブスクリプションコンテンツへのアクセスを無効にすべきではありません。

00:09:56.000 --> 00:10:06.000
この状況では、サブスクリプションのステータスは単に不明確であり、通知のデータだけでは更新するのに十分ではありません。

00:10:06.000 --> 00:10:08.000
これは理想的ではありません。

00:10:08.000 --> 00:10:22.000
サブスクリプションのApp Storeサーバー通知を受け取ったら、サブスクリプションの最新のステータスを明確に表示して、この重要な情報をサーバーで最新の状態に保つことができます。

00:10:22.000 --> 00:10:30.000
そのため、今日、App Store Server Notifications V2のデータオブジェクトに新しいステータスフィールドを導入しています。

00:10:30.000 --> 00:10:40.000
このフィールドは、先ほど詳しく説明したサブスクリプションの5つのコア状態の1つを示す単純な整数です。

00:10:40.000 --> 00:10:46.000
この新しいフィールドは、自動更新サブスクリプションに送信するすべての通知に含まれます。

00:10:46.000 --> 00:10:55.000
これで、App Store Server APIのGet All Subscription Statusesエンドポイントを呼び出すことなく、サブスクリプションのステータスを取得できます。

00:10:55.000 --> 00:11:00.000
この新しい分野が、先ほど説明したシナリオをどのように改善するか見てみましょう。

00:11:00.000 --> 00:11:12.000
サブスクリプションの払い戻し通知を受け取ったら、ステータスフィールドを確認するだけで、サブスクリプションのステータスを把握できます。

00:11:12.000 --> 00:11:18.000
この場合、それは1なので、関連するサブスクリプションがアクティブであることを知っています。

00:11:18.000 --> 00:11:28.000
新しいステータスフィールドにより、App Store Server Notificationsがこれまで以上に便利になり、1つも見逃さないようにすることができます。

00:11:28.000 --> 00:11:36.000
しかし、サーバーが停止した場合、App Storeのサーバーは通知を送信するために到達できない可能性があります。

00:11:36.000 --> 00:11:44.000
そのため、App Store Server APIのGet Notification Historyエンドポイントを提供しています。

00:11:44.000 --> 00:11:55.000
このエンドポイントでは、App Storeサーバーがアプリ用に生成したバージョン2の通知を過去6か月まで要求できます。

00:11:55.000 --> 00:12:05.000
そうすれば、サーバーに既知の停止がある場合、停止期間にこのエンドポイントを呼び出して、サーバーが見逃した通知を取得できます。

00:12:05.000 --> 00:12:09.000
しかし、いくつかのユースケースでは、このプロセスはあまり効率的に感じられないかもしれません。

00:12:09.000 --> 00:12:18.000
一時的なネットワークの問題など、サーバーが停止の外でも通知を見逃すことがあります。

00:12:18.000 --> 00:12:30.000
この状況では、エンドポイントを照会する明確な期間がない可能性があり、サーバーがすでに受信した通知のページをふるいにかけることができます。

00:12:30.000 --> 00:12:39.000
このユースケースに対処するために、「onlyFailures」という通知履歴を取得するための新しいリクエストフィールドを導入しています。

00:12:39.000 --> 00:12:47.000
このオプションのフィールドは、サーバーに到達できなかった通知のみに返される通知を制限します。

00:12:47.000 --> 00:12:54.000
応答には、現在再試行プロセス中の通知も含まれます。

00:12:54.000 --> 00:13:04.000
これで、サーバーがまだ見ていない通知を解析するだけでよいので、停止や時折のネットワークの問題からはるかに速く回復できます。

00:13:04.000 --> 00:13:08.000
この新しい分野がどのように機能するかを見てみましょう。

00:13:08.000 --> 00:13:18.000
通知履歴の取得エンドポイントにリクエストを送信し、リクエスト本文に新しいフィールドonlyFailuresを含めます。

00:13:18.000 --> 00:13:21.000
これが返事です。

00:13:21.000 --> 00:13:36.000
notificationHistory配列の各エントリは通知を表しており、リクエストに新しいonlyFailuresフィールドを含めたため、ここにリストされているすべての通知がサーバーに到達できませんでした。

00:13:36.000 --> 00:13:41.000
1つの通知エントリにズームインしましょう。

00:13:41.000 --> 00:13:44.000
ここに署名されたPayloadがあります。

00:13:44.000 --> 00:13:53.000
最初にサーバーに送信されたのと同じように、この文字列をデコードして通知の内容を表示できます。

00:13:53.000 --> 00:14:01.000
この通知のsendAttempts配列を見ると、各送信試行の結果を確認できます。

00:14:01.000 --> 00:14:10.000
この配列には最大6つのエントリを含めることができ、最初の送信試行には1つ、再試行には最大5つのエントリが含まれます。

00:14:10.000 --> 00:14:19.000
ここでは2つのエントリしか表示され、両方とも失敗したので、通知はまだ再試行プロセスにある必要があります。

00:14:19.000 --> 00:14:29.000
後で再試行が成功すると、onlyFailuresフィールドを含む後続のリクエストに対して、この通知は表示されなくなります。

00:14:29.000 --> 00:14:32.000
それが新しいonlyFailuresフィールドの仕組みです。

00:14:32.000 --> 00:14:38.000
通知履歴の取得がさらに便利になると思います。

00:14:38.000 --> 00:14:44.000
最後に、古いAPIからの移行に関する重要なアップデートです。

00:14:44.000 --> 00:14:53.000
アプリがしばらくの間アプリ内購入を提供している場合は、verifyReceipt APIに精通している可能性があります。

00:14:53.000 --> 00:15:01.000
2021年には、App Store Serverからアプリ内購入データを取得する新しい方法として、App Store Server APIをリリースしました。

00:15:01.000 --> 00:15:06.000
これら2つのAPIを比較してみましょう。

00:15:06.000 --> 00:15:15.000
verifyReceiptを使用すると、StoreKitのオリジナルバージョンを実行しているクライアントから受け取った領収書を検証およびデコードできます。

00:15:15.000 --> 00:15:23.000
App Store Server APIを使用すると、これら3つのエンドポイントを使用して、領収書などにあるのと同じデータをすべて取得できます。

00:15:23.000 --> 00:15:36.000
また、App Store Server APIは、他では見られない便利なデータと強力な機能を提供するさまざまな追加エンドポイントも提供します。

00:15:36.000 --> 00:15:45.000
通知APIに移行しても、古いApp Store Server Notifications V1を引き続きサポートしています。

00:15:45.000 --> 00:15:50.000
しかし、2021年には、App Store Server Notifications V2を導入しました。

00:15:50.000 --> 00:15:54.000
では、これらのAPIを比較してみましょう。

00:15:54.000 --> 00:16:04.000
App Storeサーバー通知V1とV2は、どちらもサーバーに直接送信されるリアルタイムのアプリ内購入イベントを提供します。

00:16:04.000 --> 00:16:10.000
しかし、V2は、タイプとサブタイプの両方を使用してイベントを定義することで、より明確になります。

00:16:10.000 --> 00:16:13.000
そして、違いはそこで止まりません。

00:16:13.000 --> 00:16:29.000
V2は、追加のイベントの通知、テスト通知を要求する機能、通知履歴へのアクセス、およびユーザーのサブスクリプションの状態を追跡するための真新しいステータスフィールドも提供します。

00:16:29.000 --> 00:16:43.000
App Store Server APIとApp Store Server Notifications V2を採用することで、サーバー上のアプリ内購入データを安全かつ効率的に管理するための幅広い新機能のロックを解除できます。

00:16:43.000 --> 00:16:49.000
最終的には、それはあなたの顧客のためのより良いアプリ内購入体験を意味します。

00:16:49.000 --> 00:16:56.000
そのため、本日、verifyReceiptとApp Store Server Notifications V1の廃止を発表します。

00:16:56.000 --> 00:17:04.000
今日から、これらのAPIは非推奨と見なされ、機能の更新を受け取らない。

00:17:04.000 --> 00:17:11.000
新しいAPIのすべての利点を享受するために、今すぐ移行の計画を始めましょう。

00:17:11.000 --> 00:17:16.000
移行には、いくつかの短いステップが必要です。

00:17:16.000 --> 00:17:29.000
verifyReceiptからApp Store Server APIに移行するには、まずアプリを表すJWTに署名する必要があります。これは、ドキュメントで概説されている簡単なプロセスです。

00:17:29.000 --> 00:17:35.000
App Store Server APIを呼び出すたびに、このJWTをヘッダーとして提供します。

00:17:35.000 --> 00:17:40.000
要求されたアプリデータを所有していることを証明します。

00:17:40.000 --> 00:17:45.000
次に、ユーザーごとにトランザクションIDを保存する必要があります。

00:17:45.000 --> 00:17:56.000
トランザクション履歴の取得やすべてのサブスクリプションステータスの取得など、コアエンドポイントを呼び出すたびに、このtransactionIdをパスパラメータとして提供します。

00:17:56.000 --> 00:17:58.000
どのトランザクションIDでも機能します。

00:17:58.000 --> 00:18:02.000
データベースを維持している場合は、すでに保存されている可能性があります。

00:18:02.000 --> 00:18:08.000
それ以外の場合は、各ユーザーの領収書から1つを抽出できます。

00:18:08.000 --> 00:18:10.000
そして、それだけです。

00:18:10.000 --> 00:18:18.000
その後、verifyReceiptなどから取得するために使用したすべてのデータにアクセスできます。

00:18:18.000 --> 00:18:25.000
App Store Server Notifications V1からV2への移行はさらに簡単です。

00:18:25.000 --> 00:18:30.000
まず、新しいV2フォーマットを解析するためにサーバーを準備します。

00:18:30.000 --> 00:18:44.000
すでにApp Store Server APIを使用している場合、App Store Server Notifications V2は同じJWSトランザクション形式を使用しているため、この手順は簡単である必要があります。

00:18:44.000 --> 00:18:52.000
サーバーの準備ができたら、App Store Connectにアクセスして、設定をV1からV2通知に変更してください。

00:18:52.000 --> 00:19:01.000
実装をテストするには、サンドボックスでのみバージョン2の通知を受け取ることから始めることができます。

00:19:01.000 --> 00:19:08.000
設定を切り替えた後、App StoreサーバーはV2形式で新しい通知の送信を開始します。

00:19:08.000 --> 00:19:17.000
再試行プロセス中にV1通知がある場合は、最大3日間引き続き受け取ることができます。

00:19:17.000 --> 00:19:22.000
移行に関するさらなる支援については、追加のリソースが利用可能です。

00:19:22.000 --> 00:19:35.000
App Store Server APIとApp Store Server Notifications V2はサンドボックス環境で利用できるため、本番環境に展開する前に実装をテストできます。

00:19:35.000 --> 00:19:48.000
そして今週、App Store Server APIを呼び出してApp Store Server Notifications V2を解析するための新しいオープンソースライブラリであるApp Store Server Libraryをリリースします。

00:19:48.000 --> 00:20:01.000
エンドポイントに簡単に電話をかけたり、受信した署名付きデータを確認したり、領収書からtransactionIdを抽出して移行を容易にするのに役立ちます。

00:20:01.000 --> 00:20:09.000
今年のWWDCでの「Meet the App Store Server Library」というタイトルの専用セッションをチェックしていただければ幸いです。

00:20:09.000 --> 00:20:20.000
また、移行方法の詳細については、「アプリ内購入の統合と移行を探る」というタイトルのWWDC22セッションを参照してください。

00:20:20.000 --> 00:20:24.000
これで、このセッションのApp Store Serverのアップデートは終了です。

00:20:24.000 --> 00:20:34.000
今日発表した素晴らしい新機能を活用し、レビューする時間がなかったさらに多くの機能については、ドキュメントをチェックしてください。

00:20:34.000 --> 00:20:45.000
すべての機能がサンドボックスと本番の両方で利用できるようになったので、まずサンドボックスでテストし、準備ができたらいつでも本番サーバーに展開できます。

00:20:45.000 --> 00:20:47.000
そして、私たちはあなたから話を聞きたいです。

00:20:47.000 --> 00:20:54.000
App Storeサーバーの機能リクエストがある場合は、Appleのフィードバックアシスタントからお知らせください。

00:20:54.000 --> 00:20:57.000
WWDC23に参加してくれてありがとう!

00:20:57.000 --> 23:59:59.000
♪ ♪

