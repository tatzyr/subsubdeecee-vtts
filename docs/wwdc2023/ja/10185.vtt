WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:14.000
ジェフ：こんにちは、ライブアクティビティチームのエンジニア、ジェフです。

00:00:14.000 --> 00:00:20.000
プッシュ通知でライブアクティビティの更新をあなたと共有できることを嬉しく思います。

00:00:20.000 --> 00:00:26.000
ライブアクティビティは、進行中のアクティビティについて誰かに glanceable情報を表示するのに最適な方法です。

00:00:26.000 --> 00:00:32.000
ActivityKitを使用すると、アプリはライブアクティビティを開始、更新、終了できます。

00:00:32.000 --> 00:00:40.000
次に、WidgetKitとSwiftUIを利用することで、ユーザーに情報を表示するUIを構築できます。

00:00:40.000 --> 00:00:45.000
これらの技術についてもっと知りたい場合は、Canの「Meet ActivityKit」セッションをチェックしてください。

00:00:45.000 --> 00:00:54.000
「Meet ActivityKit」セッションでは、ヒーローの冒険のステータスを表示するために、Emoji Rangersに新しいライブアクティビティを追加しました。

00:00:54.000 --> 00:00:58.000
でも、ヒーローに仲間がいたらもっと楽しいと思います。

00:00:58.000 --> 00:01:05.000
そのため、複数のユーザーがヒーローとパーティーを結成し、一緒に冒険に送ることができる新機能を追加したいと思います。

00:01:05.000 --> 00:01:13.000
最高のユーザーエクスペリエンスを提供するために、ライブアクティビティを更新して、パーティー内のすべてのヒーローのイベントを表示します。

00:01:13.000 --> 00:01:21.000
これを達成するために、私はデバイス上でそれを行うのではなく、冒険を追跡するためのサーバーを紹介します。

00:01:21.000 --> 00:01:25.000
サーバーは、ライブアクティビティを最新の状態に保つ責任があります。

00:01:25.000 --> 00:01:32.000
また、計算はサーバーで行われるため、アプリはライブアクティビティを更新するためにフォアグラウンドランタイムを必要としないはずです。

00:01:32.000 --> 00:01:36.000
これにより、ユーザーのバッテリー寿命への影響が減少します。

00:01:36.000 --> 00:01:42.000
ActivityKitのプッシュ通知でライブアクティビティを更新することは、この機能を実装する素晴らしい方法だと思います。

00:01:42.000 --> 00:01:51.000
このセッションでは、私が最初に取り上げるのは、プッシュアップデートでライブアクティビティを更新できるようにするために必要な準備です。

00:01:51.000 --> 00:01:56.000
その後、コンピュータから最初のプッシュアップデートを送信します。

00:01:56.000 --> 00:02:03.000
第三に、更新の優先順位とユーザーに警告する方法の違いについて説明します。

00:02:03.000 --> 00:02:11.000
最後に、プッシュアップデートに追加の機能強化を行い、次のレベルに引き上げます。

00:02:11.000 --> 00:02:13.000
準備を始めましょう。

00:02:13.000 --> 00:02:23.000
プッシュアップデートでライブアクティビティの更新を開始する前に、アプリとサーバーがAppleプッシュ通知サービスとどのようにやり取りするかを理解すると便利です。

00:02:23.000 --> 00:02:26.000
すべてはあなたのアプリから始まります。

00:02:26.000 --> 00:02:35.000
新しいライブアクティビティが開始されると、ActivityKitはAppleプッシュ通知サービス、略してAPNsからプッシュトークンを取得します。

00:02:35.000 --> 00:02:41.000
このプッシュトークンは、リクエストするライブアクティビティごとに一意です。

00:02:41.000 --> 00:02:47.000
そのため、アプリはプッシュ更新の送信を開始する前にサーバーに送信する必要があります。

00:02:47.000 --> 00:02:54.000
その後、ライブアクティビティを更新する必要があるときはいつでも、サーバーはトークンを使用してプッシュリクエストをAPNsに送信します。

00:02:54.000 --> 00:03:04.000
最後に、APNsはペイロードをデバイスに送信し、ウィジェット拡張機能をウェイクしてUIをレンダリングします。

00:03:04.000 --> 00:03:09.000
この新機能をサポートするために、APNsは新しいライブアクティビティプッシュタイプを導入しました。

00:03:09.000 --> 00:03:15.000
このプッシュタイプは、APNsへのトークンベースの接続を持つサーバーでのみ使用できます。

00:03:15.000 --> 00:03:23.000
プッシュリクエストの送信の詳細については、「APNsへの通知リクエストの送信」のドキュメントを参照してください。

00:03:23.000 --> 00:03:30.000
トークンベースの接続の詳細については、「APNsへのトークンベースの接続の確立」を参照してください。

00:03:30.000 --> 00:03:37.000
次のステップは、ライブアクティビティがプッシュアップデートを受け取るように設定されるようにアプリを変更することです。

00:03:37.000 --> 00:03:39.000
Xcodeで、アプリのターゲットに移動します。

00:03:39.000 --> 00:03:45.000
「署名と機能」タブで、プッシュ通知機能を追加します。

00:03:45.000 --> 00:03:51.000
これにより、ActivityKitはアプリに代わってプッシュトークンをリクエストできるようになります。

00:03:51.000 --> 00:03:53.000
今からコードに飛び込みます。

00:03:53.000 --> 00:03:59.000
これは、ライブアクティビティを要求する絵文字レンジャーズのコードのスニペットです。

00:03:59.000 --> 00:04:04.000
アクティビティリクエストメソッドに、冒険の属性と最初のコンテンツ状態を与えます。

00:04:04.000 --> 00:04:12.000
プッシュ更新の受信をサポートするには、pushTypeパラメータをメソッドに追加し、その値を「トークン」に設定します。

00:04:12.000 --> 00:04:19.000
これにより、ActivityKitは、作成時にライブアクティビティのプッシュトークンを要求することを知らせます。

00:04:19.000 --> 00:04:24.000
アクティビティが作成されると、アプリはプッシュトークンをサーバーに送信する必要があります。

00:04:24.000 --> 00:04:30.000
アクティビティタイプには、プッシュトークンに同期的にアクセスできるpushTokenプロパティがあります。

00:04:30.000 --> 00:04:35.000
ただし、アクティビティの作成直後にはアクセスしないでください。

00:04:35.000 --> 00:04:38.000
あなたが得る価値は、ほとんどの場合ゼロになります。

00:04:38.000 --> 00:04:42.000
これは、プッシュトークンの要求が非同期プロセスであるためです。

00:04:42.000 --> 00:04:48.000
また、システムはアクティビティの存続期間中、プッシュトークンを更新することも可能です。

00:04:48.000 --> 00:04:52.000
したがって、アプリはそれに応じて処理する必要があります。

00:04:52.000 --> 00:04:57.000
プッシュトークンを適切に処理する方法は、まず非同期タスクを作成することです。

00:04:57.000 --> 00:05:04.000
次に、アクティビティのpushTokenUpdates非同期シーケンスから値を観察するfor-awaitループを開始します。

00:05:04.000 --> 00:05:10.000
Forループ内のコードは、ライブアクティビティの新しいプッシュトークンがあるたびに実行されます。

00:05:10.000 --> 00:05:19.000
最初のプッシュトークンだけでなく、その後のプッシュトークンの更新も処理できるため、ここでは非同期forループを使用することが重要です。

00:05:19.000 --> 00:05:24.000
トークンを受け取ったら、それを16進数の文字列に変換し、デバッグコンソールに記録します。

00:05:24.000 --> 00:05:28.000
これは、次のセクションのテスト中に役に立ちます。

00:05:28.000 --> 00:05:35.000
次に、最後に、アプリに必要な他のデータと一緒にプッシュトークンをサーバーに送信します。

00:05:35.000 --> 00:05:42.000
プッシュトークンはアクティビティごとに一意であるため、ユーザーが開始するライブアクティビティごとに追跡することが重要です。

00:05:42.000 --> 00:05:51.000
また、システムが既存のアクティビティの新しいプッシュトークンを要求すると、アプリにはそれに応じて処理するためのフォアグラウンドランタイムが与えられます。

00:05:51.000 --> 00:05:59.000
新しいプッシュトークンをサーバーに送信し、古いプッシュトークンを無効にすることが重要です。そうすれば、その後のプッシュ更新が正しく送信されます。

00:05:59.000 --> 00:06:04.000
準備が完了したので、最初のプッシュアップデートを送信する時が来ました。

00:06:04.000 --> 00:06:10.000
プッシュ更新を送信するには、APNsにHTTPリクエストを送信する必要があります。

00:06:10.000 --> 00:06:16.000
リクエストは、APNsヘッダーとAPNsペイロードの2つの部分で構成されています。

00:06:16.000 --> 00:06:21.000
通常のHTTPヘッダーに加えて、提供する必要があるヘッダーが3つあります。

00:06:21.000 --> 00:06:27.000
1つ目はapnsプッシュタイプです。価値は活動です。

00:06:27.000 --> 00:06:36.000
次はapns-topicで、これはアプリのバンドルIDで、その後に.push-type.liveactivityが続きます。

00:06:36.000 --> 00:06:42.000
3つ目はapns-priorityで、値は5または10です。

00:06:42.000 --> 00:06:48.000
5は、このプッシュリクエストが優先度が低いことを示し、10は優先度が高いことを示します。

00:06:48.000 --> 00:06:54.000
ライブアクティビティがすぐに更新されるため、テスト中に高優先度を使用します。

00:06:54.000 --> 00:06:58.000
最初のAPNsペイロードでは、3つのフィールドで構成されるものを送信します。

00:06:58.000 --> 00:07:05.000
1つ目は「タイムスタンプ」で、1970年以降の秒単位の時間間隔です。

00:07:05.000 --> 00:07:10.000
システムはタイムスタンプを使用して、常に最新のコンテンツ状態をレンダリングしていることを確認します。

00:07:10.000 --> 00:07:12.000
2つ目は「イベント」です。

00:07:12.000 --> 00:07:15.000
ライブアクティビティで実行したいアクションです。

00:07:15.000 --> 00:07:18.000
その値は「更新」または「終了」のいずれかです。

00:07:18.000 --> 00:07:21.000
この最初のAPNsリクエストは「更新」に設定する必要があります。

00:07:21.000 --> 00:07:24.000
3番目のフィールドは「コンテンツ状態」です。

00:07:24.000 --> 00:07:29.000
これは、アクティビティのコンテンツ状態タイプにデコードできるJSONオブジェクトです。

00:07:29.000 --> 00:07:36.000
コンテンツの状態を正しい形式で取得するために、アプリ内からFoundationのJSONEncoderタイプを使用できます。

00:07:36.000 --> 00:07:40.000
ここでは、ライブアクティビティのContentStateのインスタンスを作成します。

00:07:40.000 --> 00:07:43.000
次に、JSONEncoderをインスタンス化します。

00:07:43.000 --> 00:07:50.000
最後に、コンテンツの状態をJSONデータにエンコードし、その文字列表現をコンソールに記録します。

00:07:50.000 --> 00:07:54.000
キャメルケースキーを使用したこのJSON出力は、私が期待していた通りのように見えます。

00:07:54.000 --> 00:08:01.000
コンテンツ状態JSONは、常にデフォルトのデコード戦略を持つJSONDecoderを使用してデコードされます。

00:08:01.000 --> 00:08:07.000
したがって、コンテンツの状態をエンコードするときは、カスタムエンコーディング戦略を設定しないでください。

00:08:07.000 --> 00:08:12.000
そうしないと、JSONが不一致になり、システムがライブアクティビティの更新に失敗します。

00:08:12.000 --> 00:08:18.000
プッシュリクエストに何が含まれているかがわかったので、次のステップは送信をテストすることです。

00:08:18.000 --> 00:08:22.000
私は開発中に素早く反復できることの大ファンです。

00:08:22.000 --> 00:08:28.000
だから私は、サーバーを変更せずにライブアクティビティのプッシュ通知をテストするのが好きです。

00:08:28.000 --> 00:08:33.000
ターミナルから直接APNsにプッシュリクエストを送信することで、これを実現できます。

00:08:33.000 --> 00:08:40.000
これを行うためのコマンドラインを設定するには、「コマンドラインツールを使用してプッシュ通知を送信する」の記事を参照してください。

00:08:40.000 --> 00:08:46.000
「トークンを使用してプッシュ通知を送信する」というセクションの指示に従っていることを確認してください。

00:08:46.000 --> 00:08:52.000
認証トークン変数を印刷することで、すべてが正しく設定されていることをすばやく確認できます。

00:08:52.000 --> 00:08:56.000
次に必要な情報はプッシュトークンです。

00:08:56.000 --> 00:09:00.000
前のセクションでは、プッシュトークンをコンソールに記録するコードを追加しました。

00:09:00.000 --> 00:09:03.000
だから、そこから私はそれを得るでしょう。

00:09:03.000 --> 00:09:08.000
同じアプローチを取った場合は、アプリをデバイスにデプロイし、ライブアクティビティを開始してください。

00:09:08.000 --> 00:09:12.000
アプリは、アクティビティが開始された直後にプッシュトークンをログに記録します。

00:09:12.000 --> 00:09:18.000
プッシュトークンをコピーして、ターミナルのアクティビティプッシュトークン変数として設定します。

00:09:18.000 --> 00:09:22.000
APNsリクエストを送信するには、curlコマンドを実行します。

00:09:22.000 --> 00:09:25.000
これは私が冒険のライブアクティビティのために構築したものです。

00:09:25.000 --> 00:09:31.000
「apns-topic」ヘッダーは、アプリのバンドルIDの後にプッシュタイプの接尾辞が続きます。

00:09:31.000 --> 00:09:35.000
次に、「apns-push-type」ヘッダーがアクティブに設定されます。

00:09:35.000 --> 00:09:41.000
第三に、「apns-priority」は10に設定されているので、私のリクエストはすぐに配信されます。

00:09:41.000 --> 00:09:49.000
最終的なHTTPヘッダー「authorization」は「bearer」に設定され、その後に認証トークン変数が続きます。

00:09:49.000 --> 00:09:53.000
データに関しては、APNsペイロード全体が含まれています。

00:09:53.000 --> 00:10:00.000
日付コマンドを使用してタイムスタンプを自動的に作成し、数字が秒単位で正確であることを確認しています。

00:10:00.000 --> 00:10:04.000
最後に、URLについては、HTTP2を使用していることを確認してください。

00:10:04.000 --> 00:10:11.000
そして、URLの最後に、前のステップで設定されたアクティビティプッシュトークン変数を参照します。

00:10:11.000 --> 00:10:12.000
そして、それだけです。

00:10:12.000 --> 00:10:19.000
このcurlコマンドを実行すると、ライブアクティビティはペイロードで提供される新しいコンテンツ状態で更新されます。

00:10:19.000 --> 00:10:25.000
場合によっては、ライブアクティビティが期待どおりに更新されなかった状況が表示されることがあります。

00:10:25.000 --> 00:10:30.000
最初に確認すべきことは、curlコマンドを実行するときにエラー応答がないことです。

00:10:30.000 --> 00:10:36.000
エラーは、リクエストのフィールドが正しくないことを示しているか、環境の設定時に問題があった可能性があります。

00:10:36.000 --> 00:10:47.000
APNsが成功した応答を返したが、ライブアクティビティがまだ更新されなかった場合は、コンソールアプリを使用してデバイスログを表示し、問題をトリアージしようとすることができます。

00:10:47.000 --> 00:10:54.000
関連するログを持つ可能性のあるプロセスは、liveactivitiesd、apsd、およびchronodです。

00:10:54.000 --> 00:11:04.000
ライブアクティビティがプッシュ通知でどのように更新されているかに満足したら、サーバーを変更して実際のプッシュ更新の送信を開始する時間になります。

00:11:04.000 --> 00:11:11.000
そして、それはあなたのユーザーエクスペリエンス、優先順位、アラートを設計する際の重要な部分に私を連れて行きます。

00:11:11.000 --> 00:11:18.000
最高のユーザーエクスペリエンスを確保するためには、各アップデートに正しいプッシュ優先度を選択することが重要です。

00:11:18.000 --> 00:11:23.000
常に最初に使用することを考慮すべき優先順位は低優先度です。

00:11:23.000 --> 00:11:29.000
優先度の低いアップデートは日和見的に配信されるため、ユーザーのバッテリー寿命への影響が低下します。

00:11:29.000 --> 00:11:35.000
ただし、これは、プッシュリクエストが送信されたときにライブアクティビティがすぐに更新されない可能性があることを意味します。

00:11:35.000 --> 00:11:40.000
したがって、時間の制約の低い更新には低優先度を使用する必要があります。

00:11:40.000 --> 00:11:49.000
私の冒険ライブアクティビティでは、一般的な戦利品を見つけたり、いくつかのヘルスポイントを癒すヒーローを見つけるなどの更新は、ユーザーの即時の注意を必要としません。

00:11:49.000 --> 00:11:53.000
だからこそ、彼らは優先順位の低いアップデートを使用するための素晴らしい候補者です。

00:11:53.000 --> 00:12:00.000
低優先度を使用するもう1つの利点は、送信できる更新の数に制限がないことです。

00:12:00.000 --> 00:12:06.000
これを利用するには、ライブアクティビティの更新の大部分に低優先度を使用する必要があります。

00:12:06.000 --> 00:12:15.000
一方、特定のアップデートでは、ヒーローがノックダウンされたときや主要なボスが敗北したときなど、ユーザーの即時の注意が必要です。

00:12:15.000 --> 00:12:19.000
このような場合は、優先度の高い更新を選択します。

00:12:19.000 --> 00:12:22.000
優先度の高いアップデートはすぐに配信されます。

00:12:22.000 --> 00:12:25.000
そのため、時間に敏感なアップデートに最適です。なぜなら、それらは時間に敏感なアップデートです。

00:12:25.000 --> 00:12:32.000
しかし、ユーザーのバッテリー寿命への影響により、システムはデバイスの状態に応じて予算を課します。

00:12:32.000 --> 00:12:40.000
アプリが予算を超えた場合、システムはプッシュ更新を制限し、ユーザーエクスペリエンスに劇的な影響を与えます。

00:12:40.000 --> 00:12:47.000
あなたは自分のアプリを一番よく知っているので、どのアップデートにどの優先順位を使うべきかを慎重に検討することが重要です。

00:12:47.000 --> 00:12:55.000
絵文字レンジャーズでは、パーティーが次々と主要なボスと戦う特別なタイプの冒険を紹介しています。

00:12:55.000 --> 00:13:05.000
この集中的なライブアクティビティに最高のユーザーエクスペリエンスを提供するために、サーバーが優先度の高いプッシュを頻繁に送信して最新の状態に保つ必要があります。

00:13:05.000 --> 00:13:11.000
これをサポートするために、アプリのライブアクティビティの頻繁な更新機能を有効にします。

00:13:11.000 --> 00:13:19.000
この機能を有効にすると、アプリがより高い更新予算を取得できるため、ライブアクティビティの更新が制限される可能性が低くなります。

00:13:19.000 --> 00:13:30.000
この機能を採用するには、NSSupportsLiveActivitiesFrequentUpdatesと呼ばれる情報plistに新しいキーを追加し、その値をYESに設定するだけです。

00:13:30.000 --> 00:13:36.000
ユーザーは、設定でライブアクティビティとは無関係に頻繁な更新を無効にすることができます。

00:13:36.000 --> 00:13:45.000
そのため、ActivityAuthorizationInfo frequentPushesEnabledプロパティにアクセスすることで、頻繁な更新機能のステータスを検出できます。

00:13:45.000 --> 00:13:55.000
サーバーはこの値に従って更新頻度を調整する必要があるので、プッシュ更新の送信を開始する前にサーバーに送信していることを確認してください。

00:13:55.000 --> 00:13:59.000
この値は、アクティビティの開始後に一度だけ確認する必要があります。

00:13:59.000 --> 00:14:09.000
この値が変更された場合、システムは進行中のすべてのアクティビティを終了するため、サーバーはアクティビティの存続期間中に頻繁に更新が切り替えられることを心配する必要はありません。

00:14:09.000 --> 00:14:21.000
アドベンチャーライブアクティビティでは、ヒーローがノックダウンされたとき、すぐに更新することに加えて、私はまた、彼らがすぐにアプリに入って癒しのポーションを使用できるように、ユーザーの注意を引きたいと思います。

00:14:21.000 --> 00:14:28.000
これを行うには、ペイロードに3つのフィールドを持つ追加の「アラート」オブジェクトを追加します。

00:14:28.000 --> 00:14:32.000
「タイトル」は通知のタイトルになります。

00:14:32.000 --> 00:14:36.000
「ボディ」は、アップデートに関する短いメッセージになります。

00:14:36.000 --> 00:14:40.000
「サウンド」は、アラートがトリガーされたときに再生される音を示します。

00:14:40.000 --> 00:14:51.000
絵文字レンジャーズは複数の言語をサポートしているので、英語でアラートを送信するだけでは理想的ではありませんが、私のサーバーでのローカリゼーションの処理は非常にトリッキーです。

00:14:51.000 --> 00:14:56.000
ありがたいことに、アラートオブジェクトの「タイトル」フィールドと「ボディ」フィールドを設定する別の方法があります。

00:14:56.000 --> 00:15:02.000
文字列を渡す代わりに、ローカライズされた文字列オブジェクトとして設定できます。

00:15:02.000 --> 00:15:08.000
「Loc-key」フィールドは、アプリのローカリゼーションファイルにあるローカリゼーションキーになります。

00:15:08.000 --> 00:15:14.000
「Loc-args」フィールドは、ローカライズされた文字列に挿入される値のリストになります。

00:15:14.000 --> 00:15:19.000
これで、デバイスはユーザーのロケールに応じて通知を自動的にローカライズします。

00:15:19.000 --> 00:15:25.000
アラートに最後のタッチを加えるために、さまざまなアップデートのカスタムサウンドを追加したいと思います。

00:15:25.000 --> 00:15:31.000
これを実現するには、まず、リソースとしてアプリのターゲットにサウンドファイルを追加する必要があります。

00:15:31.000 --> 00:15:36.000
次に、アラートオブジェクトの「サウンド」フィールドをサウンドのファイル名に設定します。

00:15:36.000 --> 00:15:39.000
そして、それだけです。今、私のアラートは素晴らしく見え、聞こえます。

00:15:39.000 --> 00:15:45.000
今、私はライブアクティビティのユーザーエクスペリエンスを本当に磨くために強化を行うつもりです。

00:15:45.000 --> 00:15:52.000
冒険が終わったら、ライブアクティビティを終了し、一定時間後に却下したい。

00:15:52.000 --> 00:15:56.000
これを行うには、イベントが終了するように設定されたプッシュペイロードを送信します。

00:15:56.000 --> 00:16:03.000
ライブアクティビティをロック画面から削除するタイミングを制御したいので、カスタムの「解雇日」を提供します。

00:16:03.000 --> 00:16:07.000
このフィールドを省いて、ライブアクティビティをいつ却下するかをシステムが決定できるようにすることができます。

00:16:07.000 --> 00:16:13.000
「解雇日」の値は、1970年以降の秒単位の時間間隔である必要があります。

00:16:13.000 --> 00:16:18.000
また、ライブアクティビティに最終的な更新を提供するために、最終的なコンテンツの状態も提供しています。

00:16:18.000 --> 00:16:27.000
これもオプションであり、省略された場合、アクティビティは却下されるまで以前のコンテンツ状態を表示し続けるだけです。

00:16:27.000 --> 00:16:31.000
場合によっては、ユーザーのデバイスがプッシュ通知を受信できないことがあります。

00:16:31.000 --> 00:16:36.000
そして、アドベンチャーライブアクティビティはまだ時代遅れの健康値を表示しているかもしれません。

00:16:36.000 --> 00:16:44.000
これらのシナリオでは、Live Activity UIのユーザーに不正確な情報が表示されている可能性があることを警告したいと思います。

00:16:44.000 --> 00:16:48.000
これを達成するために、ペイロードに「stale-date」フィールドを追加します。

00:16:48.000 --> 00:16:53.000
システムは、この日付を使用して、古いビューをいつレンダリングするかを決定します。

00:16:53.000 --> 00:16:59.000
ウィジェット拡張機能で宣言されたActivityConfigurationから古いビューを提供できます。

00:16:59.000 --> 00:17:07.000
私がしなければならないのは、私のビューがActivityViewContextのisStaleプロパティの値に反応することだけです。

00:17:07.000 --> 00:17:13.000
同時に複数のアドベンチャーライブアクティビティがある場合は、ロック画面で正しく注文されていることを確認したいです。

00:17:13.000 --> 00:17:19.000
より重要なアップデートがあるものはトップの近くにあり、最も重要なものはダイナミックアイランドにあるべきです。

00:17:19.000 --> 00:17:23.000
オプションの「relevance-score」フィールドを提供することで、これを手配できます。

00:17:23.000 --> 00:17:27.000
数字が高いほど、関連性が高いことを示します。

00:17:27.000 --> 00:17:33.000
ライブアクティビティをプッシュ通知で更新する方法がわかったので、アプリに追加する時が来ました。

00:17:33.000 --> 00:17:40.000
最初にすべきことは、ActivityKitのプッシュ通知をサポートするようにサーバーとアプリを設定することです。

00:17:40.000 --> 00:17:45.000
次に、端末からプッシュ更新の送信をテストして、すばやく反復します。

00:17:45.000 --> 00:17:50.000
それに満足したら、サーバーにエンド・トゥ・エンドのサポートを実装し始めてください。

00:17:50.000 --> 00:17:57.000
一方、ユーザーエクスペリエンスを念頭に置いて、適切な優先順位を使用し、必要に応じてユーザーに警告する必要があります。

00:17:57.000 --> 00:18:01.000
私と一緒にライブアクティビティについて学ぶのを楽しんでいただければ幸いです。

00:18:01.000 --> 00:18:10.000
あなたがダイナミックアイランドとロック画面にもたらすすべての創造的なアイデアを見るのが待ちきれません。

00:18:10.000 --> 00:18:12.000
見てくれてありがとう。

00:18:12.000 --> 23:59:59.000
♪ ♪

