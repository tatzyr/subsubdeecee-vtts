WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:16.000
みなさん、こんにちは。私はガウリ・ジョグで、ここアップルのメタルエコシステムチームで働いています。

00:00:16.000 --> 00:00:21.000
Metalを使用したGPUレンダラーの最適化についてお話しできることを嬉しく思います。

00:00:21.000 --> 00:00:31.000
最新のデジタルコンテンツ作成アプリケーションとゲームエンジンにより、コンテンツクリエイターは3Dアセットのマテリアルをインタラクティブに作成および変更できます。

00:00:31.000 --> 00:00:37.000
実行時にこれらの複雑で動的な材料を処理するための一般的なテクニックがいくつかあります。

00:00:37.000 --> 00:00:47.000
個々のシェーダーにマテリアルをコンパイルするアプリケーションもあれば、uberシェーダーやシェーダー仮想マシンなどのデータ駆動型ソリューションを使用するアプリケーションもあります。

00:00:47.000 --> 00:00:51.000
これらの材料中心のワークフローには、2つの主なパフォーマンス目標があります。

00:00:51.000 --> 00:00:57.000
資料のオーサリングは、高速な反復と最高の経験のために応答する必要があります。

00:00:57.000 --> 00:01:05.000
レンダリングパフォーマンスは、リアルタイムのインタラクティブ性と効率的な最終フレームレンダリングのために、可能な限り良好である必要があります。

00:01:05.000 --> 00:01:11.000
Blender 3Dのこのデモンストレーションでは、マテリアル編集はレスポンシブです。

00:01:11.000 --> 00:01:21.000
ユーザーインターフェイスでマテリアルスライダーを変更すると、シェーダーの再コンパイルによるスタッターなしで、結果がビューポートに即座に表示されます。

00:01:21.000 --> 00:01:34.000
素材が変更されると、結果のレンダリングパフォーマンスは高速でインタラクティブになり、コンテンツ作成者は作業結果を効率的に表示できます。

00:01:34.000 --> 00:01:43.000
アプリケーションでレスポンシブでパフォーマンスの高いワークフローを実現するには、主要なMetal機能を活用し、Metalのベストプラクティスを実装できます。

00:01:43.000 --> 00:01:59.000
Metalは、複雑なシェーダーのパフォーマンスを最大化し、非同期コンパイルを活用してアプリケーションの応答性を維持し、動的リンクでより速くコンパイルし、新しいMetalコンパイラオプションでコンピューティングシェーダーを調整するのに役立ちます。

00:01:59.000 --> 00:02:05.000
シェーダーを最適化することがパフォーマンスの鍵です。

00:02:05.000 --> 00:02:11.000
Uberシェーダーは、あらゆる可能な素材をレンダリングするために使用できる長くて複雑なシェーダーの例です。

00:02:11.000 --> 00:02:17.000
これらのタイプのシェーダーは、あらゆる可能な組み合わせのための多くの枝を持っています。

00:02:17.000 --> 00:02:25.000
アーティストがマテリアルを作成すると、マテリアルパラメータはマテリアルシェーダーで使用されるメタルバッファに保存されます。

00:02:25.000 --> 00:02:35.000
このバッファはパラメータを変更すると更新されますが、再コンパイルは必要ありません。

00:02:35.000 --> 00:02:39.000
このアプローチは、優れたレスポンシブオーサリング体験を提供します。

00:02:39.000 --> 00:02:48.000
ただし、uberシェーダーは、すべての可能なオプションを考慮する必要があるため、最適ではありません。

00:02:48.000 --> 00:02:55.000
最も最適なシェーダーバリアントを作成するには、関数定数を持つ金属特殊化を使用する必要があります。

00:02:55.000 --> 00:03:02.000
メタルシェーダーで関数定数を宣言し、変更時に実行時に値を設定するだけです。

00:03:02.000 --> 00:03:09.000
マテリアルバッファの内容は、シェーダーパイプライン状態では単に定数になり、動的分岐は排除されます。

00:03:09.000 --> 00:03:13.000
特殊な材料はあなたに最高のパフォーマンスを与えます。

00:03:13.000 --> 00:03:21.000
これは、Blender 3D、Wanderer、Tree Creatureの2つの一般的なテストアセットからのリアルタイムパフォーマンスデータの比較です。

00:03:21.000 --> 00:03:28.000
1つ目は、ウーバーシェーダーを使用したシーンのフレーム/秒のベースラインパフォーマンスです。

00:03:28.000 --> 00:03:34.000
2つ目は、はるかに高速に実行する関数定数を備えた特殊なシェーダーアプローチです。

00:03:34.000 --> 00:03:45.000
最速の特殊なシェーダーバリアントを作成するには、関数定数を使用して未使用の機能を無効にし、分岐を排除します。

00:03:45.000 --> 00:03:54.000
Uberシェーダーは、実行時に条件付きブランチを実行するバッファからマテリアルパラメータを照会し、機能を有効または無効にします。

00:03:54.000 --> 00:03:59.000
関数定数では、材料フィーチャごとに1つの定数を宣言します。

00:03:59.000 --> 00:04:09.000
これで、機能コードパスの動的ブランチが関数定数に置き換えられ、未使用のコードがすべて排除されます。

00:04:09.000 --> 00:04:14.000
これは、関数定数を使用しているのと同じuberシェーダーです。

00:04:14.000 --> 00:04:20.000
メタルコンパイラは、これらを一定のブール値として折りたたんで、未使用のコードを削除することができます。

00:04:20.000 --> 00:04:29.000
Falseに解決するブランチ式は最適化され、真のブランチのみが残ります。

00:04:29.000 --> 00:04:34.000
未使用の制御フローはすべて最適化されています。

00:04:34.000 --> 00:04:40.000
特殊なシェーダーは、材料データを照会する必要が不要になり、制御フローがはるかにシンプルになりました。

00:04:40.000 --> 00:04:48.000
メモリの負荷とブランチが削除され、ランタイムのパフォーマンスが向上しました。

00:04:48.000 --> 00:04:52.000
機能の特殊化は、定数の折り畳みにも役立ちます。

00:04:52.000 --> 00:04:58.000
変化しない材料パラメータは定数に置き換えられます。

00:04:58.000 --> 00:05:03.000
このサンプルマテリアルは、メタルバッファからの入力パラメータのコレクションを使用します。

00:05:03.000 --> 00:05:09.000
パラメータは、色、重量、光沢色などである可能性があります。

00:05:09.000 --> 00:05:16.000
材料作成時に、これらの静的パラメータは関数定数に置き換えることができます。

00:05:16.000 --> 00:05:23.000
関数定数は、バッファ読み取りを必要とせず、最も最適なコードを生成します。

00:05:23.000 --> 00:05:30.000
ホスト側では、特殊なパイプライン状態を作成するときに関数定数値が提供されます。

00:05:30.000 --> 00:05:37.000
MaterialParameter構造は、材料に対して一定であるすべてのパラメータを表すために使用できます。

00:05:37.000 --> 00:05:44.000
IsGlossyは、光沢を制御するブール材料機能フラグの例です。

00:05:44.000 --> 00:05:50.000
MaterialColorは、色を記述するために使用されるベクトルパラメータの例です。

00:05:50.000 --> 00:06:02.000
特殊なパイプライン状態オブジェクトを作成するには、MetalFunctionConstantValuesセットを反復し、setConstantValueを使用して値を挿入します。

00:06:02.000 --> 00:06:05.000
次に、通常どおりレンダリングパイプラインを作成します。

00:06:05.000 --> 00:06:16.000
唯一の違いは、フラグメント関数を作成するときに、constantValuesでnewFunctionWithNameのバリアントを使用することです。

00:06:16.000 --> 00:06:19.000
最後に、パイプライン状態オブジェクトを作成します。

00:06:19.000 --> 00:06:26.000
結果として得られるシェーダーは、この材料の最も最適なパフォーマンスバリアントです。

00:06:26.000 --> 00:06:35.000
関数定数を使用することの影響を確認するには、常にXcodeのGPUデバッガパフォーマンスセクションを使用してください。

00:06:35.000 --> 00:06:42.000
オリジナルのウーバーシェーダーは、多数のALU命令と大量の流出を示しています。

00:06:42.000 --> 00:06:46.000
メモリの待ち時間も多いです。

00:06:46.000 --> 00:06:51.000
専門的なアプローチは、ALUと流出を即座に救済します。

00:06:51.000 --> 00:06:55.000
これは、デッドコードの消去と定数の折り畳みによるものです。

00:06:55.000 --> 00:07:01.000
また、メモリの待ち時間の数は大幅に少なくなっています。

00:07:01.000 --> 00:07:11.000
ランタイムシェーダーの実行コストで元のuberシェーダーを観察し、GPUはメモリ待機にかなりの時間を費やしています。

00:07:11.000 --> 00:07:23.000
対照的に、専門的なアプローチは、メモリ待機に費やす時間がはるかに少なく、他の効率の利点とともに、より生産的なALU利用を可能にします。

00:07:23.000 --> 00:07:31.000
GPUデバッガのタイムラインビューでは、uberシェーダーを使用してマテリアルパスをレンダリングするのに58ミリ秒かかります。

00:07:31.000 --> 00:07:36.000
そして、特殊なバージョンでレンダリングするのにわずか12.5ミリ秒です。

00:07:36.000 --> 00:07:40.000
それはかなり劇的な改善です。

00:07:40.000 --> 00:07:52.000
材料の特殊化にはランタイムシェーダーのコンパイルが必要であり、これらの特殊な材料が作成されるのをブロックして待つと、ヒッチハイチになることがよくあります。

00:07:52.000 --> 00:08:06.000
Metal非同期コンパイルAPIを使用すると、汎用のuberシェーダーを使用し、バックグラウンドで特殊なバージョンを生成しながら、ユーザーエクスペリエンスをインタラクティブで応答性に保つことができます。

00:08:06.000 --> 00:08:11.000
非同期パイプライン状態の作成をオプトインするには、完了ハンドラを提供します。

00:08:11.000 --> 00:08:18.000
これらの通話はすぐに返され、ユーザーエクスペリエンスをインタラクティブで応答性に保つことができます。

00:08:18.000 --> 00:08:28.000
特殊なパイプライン状態の準備ができたら、完了ハンドラが呼び出され、すぐに最適なシェーダーに切り替えることができます。

00:08:28.000 --> 00:08:31.000
これは非同期材料ワークフローの図です。

00:08:31.000 --> 00:08:38.000
デフォルトでは、素材がまだ特化したものではない場合は、uberシェーダーを使用します。

00:08:38.000 --> 00:08:44.000
同時に、Metalは特殊なシェーダーをバックグラウンドでコンパイルします。

00:08:44.000 --> 00:08:51.000
これが完了したら、ユーバーシェーダーを高速特殊材料に切り替えることができます。

00:08:51.000 --> 00:08:58.000
ランタイムメタルシェーダーのコンパイルは、バランスのとれたレベルの並列性を提供するように設計されています。

00:08:58.000 --> 00:09:08.000
しかし、現代のコンテンツ作成アプリケーションは、マルチマテリアル編集ワークフローを提供する必要があり、その結果、多くのシェーダーの再コンパイルが発生します。

00:09:08.000 --> 00:09:16.000
このような重いオーサリングのニーズを支援するために、メタルにシェーダーコンパイルの並列性を最大化するように依頼することをお勧めします。

00:09:16.000 --> 00:09:24.000
Metalデバイスには、macOS13.3にshould-Maximize-Concurrent-Compilationという新しいプロパティがあります。

00:09:24.000 --> 00:09:30.000
「はい」に設定すると、MetalコンパイラはCPUコアを最大限に活用します。

00:09:30.000 --> 00:09:37.000
同時コンパイルを最大化することは、マルチマテリアルオーサリングワークフローにとって本当に素晴らしいです。

00:09:37.000 --> 00:09:44.000
追加のコンパイラジョブが利用可能になると、特殊なマテリアルバリアントがはるかに早く利用可能になります。

00:09:44.000 --> 00:09:46.000
これがすべて実際にどのように機能するかです。

00:09:46.000 --> 00:09:58.000
材料パラメータが変更されると、材料の現在の特殊なバリアントが無効になり、オーサリング流体を維持するためにuberシェーダーを使用するためのスイッチがあります。

00:09:58.000 --> 00:10:07.000
新しい非同期ジョブがキューに入れられ、完了すると、特殊な資料が従事すると、大幅なパフォーマンスの向上を観察できます。

00:10:07.000 --> 00:10:16.000
ほとんどの最新のアプリは非常に複雑な素材を持っているので、特殊なバリアントが準備されるのにかなりの時間がかかることがあります。

00:10:16.000 --> 00:10:25.000
Metalの動的ライブラリは、ユーティリティ関数を事前にコンパイルし、全体的な材料のコンパイル時間を短縮するために使用できます。

00:10:25.000 --> 00:10:31.000
これを行うには、機能のグループを別々の動的ライブラリに分割します。

00:10:31.000 --> 00:10:37.000
ランタイムコンパイルをさらに高速化するために、ユーティリティライブラリをオフラインでプリコンパイルできます。

00:10:37.000 --> 00:10:43.000
そして、実行時にはるかに少ないコードをコンパイルすることになります。

00:10:43.000 --> 00:10:47.000
もし私が以前のウーバーシェーダーを取り、それをディリブに分割するなら。

00:10:47.000 --> 00:10:51.000
1つのアプローチは、共通の機能グループによってそれを分割することです。

00:10:51.000 --> 00:10:58.000
この場合、1つの数学ユーティリティライブラリと照明機能用のもう1つ。

00:10:58.000 --> 00:11:04.000
リンク用に関数記号を表示させるには、「デフォルト」の可視性を割り当てます。

00:11:04.000 --> 00:11:12.000
シンボルは、可視性を「非表示」に割り当てることで、外部プログラムから非表示にすることもできます。

00:11:12.000 --> 00:11:17.000
Metalデバイスが動的ライブラリをサポートしているかどうかを確認するための2つのプロパティがあります。

00:11:17.000 --> 00:11:24.000
レンダリングパイプラインの場合は、MetalデバイスのsupportsRenderDynamicLibrariesプロパティを使用する必要があります。

00:11:24.000 --> 00:11:30.000
これは現在、Apple6以上のGPUファミリを搭載したデバイスで利用可能です。

00:11:30.000 --> 00:11:36.000
コンピューティングパイプラインの場合は、supportsDynamicLibrariesプロパティを照会する必要があります。

00:11:36.000 --> 00:11:43.000
これは、Apple6以上およびほとんどのMac2 GPUファミリで利用できます。

00:11:43.000 --> 00:11:53.000
既存のMetalライブラリから動的ライブラリを作成するには、newDynamicLibraryを呼び出してMetalライブラリに渡すだけです。

00:11:53.000 --> 00:12:03.000
URLから作成するには、newDynamicLibraryWithURLメソッドを呼び出して、保存された動的ライブラリへのパスを指定します。

00:12:03.000 --> 00:12:08.000
メタルコンパイラツールチェーンを使用して、動的ライブラリをオフラインで事前コンパイルできます。

00:12:08.000 --> 00:12:15.000
実行時にプリコンパイルされた動的ライブラリをロードすると、コンパイルは完全に回避されます。

00:12:15.000 --> 00:12:26.000
リンクフェーズでdylibsを指定するには、パイプライン記述子のpreloadedLibrariesパラメータにMetal Dynamic Libraryオブジェクトの配列を渡します。

00:12:26.000 --> 00:12:35.000
他のシェーダーライブラリをコンパイルするときに、メタルコンパイルオプションを介してこの動的ライブラリの配列を提供するオプションもあります。

00:12:35.000 --> 00:12:42.000
ユーティリティコードの大部分を動的ライブラリに移動すると、ランタイムコンパイルが大幅に短縮されます。

00:12:42.000 --> 00:12:52.000
そして最後に、コンパイラオプションのチューニングは、最終的な生産品質レンダリングにおけるパストレースのような計算ケースにとって本当に重要です。

00:12:52.000 --> 00:12:58.000
そして、最終的なレンダリングから最大限のパフォーマンスを引き出すための追加のメタル機能が1つあります。

00:12:58.000 --> 00:13:10.000
メタルコンパイラのオプションと占有ヒントにより、ダイナミックリンクで作業するときに、特にこれらのコンピューティングカーネルのパフォーマンスを調整できます。

00:13:10.000 --> 00:13:17.000
すべてのGPUワークロードには、分析と評価が必要なパフォーマンススイートスポットがあります。

00:13:17.000 --> 00:13:26.000
希望するGPU占有率をターゲットとするMetal APIがあり、現在は動的ライブラリでも利用可能です。

00:13:26.000 --> 00:13:33.000
これにより、元のコードやアルゴリズムを変更することなく、既存のワークロードのパフォーマンスをアンロックできます。

00:13:33.000 --> 00:13:45.000
パフォーマンス特性はGPUアーキテクチャによって異なる可能性があるため、デバイスごとにチューニングを実行する必要があることは注目に値します。

00:13:45.000 --> 00:13:56.000
Metal compute pipeline descriptorプロパティを使用すると、Max-Total-Threads-Per-Threadgroup値を指定して、目的の占有レベルを表現できます。

00:13:56.000 --> 00:14:02.000
値が高いほど、コンパイラが目指すと示唆する占有率が高くなります。

00:14:02.000 --> 00:14:13.000
これで、動的ライブラリ用のこの新しいMetal-Compile-Optionsプロパティを使用すると、パイプライン状態オブジェクトの希望する占有レベルを一致させることができます。

00:14:13.000 --> 00:14:24.000
Max-Total-Threads-Per-Threadgroupは、iOS 16.4とmacOS 13.3のMetalCompileOptionsで利用できます。

00:14:24.000 --> 00:14:33.000
これで、最適なパフォーマンスのためにMetalダイナミックライブラリをチューニングしながら、パイプライン状態オブジェクトの望ましい占有率を簡単に一致させることができます。

00:14:33.000 --> 00:14:42.000
Blender Cyclesシェーディングと交差計算カーネルのパフォーマンスのこのグラフは、Max-Total-Threads-Per-Threadgroupの変更の影響を示しています。

00:14:42.000 --> 00:14:48.000
それが、パイプライン状態オブジェクトとディリブに対して変更された唯一の変数でした。

00:14:48.000 --> 00:14:53.000
この場合、カーネルが最高のパフォーマンスを発揮するスイートスポットがあります。

00:14:53.000 --> 00:15:03.000
各ワークロードとデバイスは一意であり、Max-Total-Threads-Per-Threadgroupの最適値はカーネルの性質によって異なります。

00:15:03.000 --> 00:15:10.000
最適な値は、必ずしもGPUがサポートするスレッドグループあたりのスレッドの最大数であるとは限りません。

00:15:10.000 --> 00:15:16.000
カーネルを試して、使用したい最適な値を見つけて、コードで焼きます。

00:15:16.000 --> 00:15:24.000
これはBlender Cyclesシェーディングカーネルです。コンパイラの統計は、カーネルが非常に複雑であることを示しています。

00:15:24.000 --> 00:15:28.000
実際のランタイムに影響を与えるパラメータがいくつかあります。

00:15:28.000 --> 00:15:34.000
流出の量、使用されるレジスタの数、およびメモリ負荷などのその他の操作。

00:15:34.000 --> 00:15:44.000
Max-Total-Threads-Per-Threadgroupを調整することで、目標占有率を変更し、そのパフォーマンススイートスポットを見つけることができます。

00:15:44.000 --> 00:15:55.000
スイートスポットを見つけた後、流出は少し増加しますが、全体的な占有率の増加により、カーネルのパフォーマンスが大幅に向上しました。

00:15:55.000 --> 00:16:10.000
Blender 3D 3.5内のサイクルパストレーサーは現在、金属用に十分に最適化されており、今日説明したすべてのベストプラクティスを使用しています。

00:16:10.000 --> 00:16:38.000
関数の特殊化を使用して大規模で複雑なシェーダーのシェーダーパフォーマンスを最大化し、非同期コンパイルを使用して、バックグラウンドで最適化されたシェーダーを生成しながらアプリケーションの応答性を維持し、実行時にコンパイルを高速化するための動的リンクを有効にし、最適なパフォーマンスを得るために新しいMetalコンパイラオプションでコンピューティングカーネルを調整することを忘れないでください。

00:16:38.000 --> 00:16:48.000
Apple GPUの計算ワークロードを拡張する方法を学び、Metalでより多くのコンパイルワークフローを発見できる以前のセッションを必ずチェックしてください。

00:16:48.000 --> 00:16:50.000
ご覧いただきありがとうございます。

00:16:50.000 --> 23:59:59.000
♪ ♪

