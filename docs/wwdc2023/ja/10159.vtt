WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:14.000
ハリー：こんにちは、私はSwiftUIチームのエンジニア、ハリーです。

00:00:14.000 --> 00:00:21.000
Beyond Scroll Viewsへようこそ。SwiftUIのスクロールビューの新しい改善について説明します。

00:00:21.000 --> 00:00:27.000
私たちのデバイスがやりたいことは、固定画面サイズに含めることはめったにありません。

00:00:27.000 --> 00:00:31.000
この複雑さに対処する方法の1つは、スクロールを導入することです。

00:00:31.000 --> 00:00:34.000
これにより、画面に収まらないものをすべて表示できます。

00:00:34.000 --> 00:00:40.000
SwiftUIは、スクロールを自分のアプリに統合できるいくつかの異なるコンポーネントを提供しています。

00:00:40.000 --> 00:00:43.000
今日は、これらのコンポーネントの1つについて話します。

00:00:43.000 --> 00:00:44.000
スクロールビュー。

00:00:44.000 --> 00:00:49.000
ScrollViewは、コンテンツをスクロールできるビルディングブロックです。

00:00:49.000 --> 00:00:54.000
スクロールビューには、スクロール可能な方向を定義する軸があります。

00:00:54.000 --> 00:00:56.000
スクロールビューにはコンテンツがあります。

00:00:56.000 --> 00:01:05.000
そのコンテンツがScrollViewのサイズを超えると、そのコンテンツの一部がクリップされ、人々はそれを表示するためにスクロールする必要があります。

00:01:05.000 --> 00:01:14.000
スクロールビューは、セーフエリアをそのコンテンツをアウトセットする余白に解決することによって、コンテンツがセーフエリア内に配置されていることを確認します。

00:01:14.000 --> 00:01:18.000
ScrollViewは、デフォルトでコンテンツを熱心に評価します。

00:01:18.000 --> 00:01:23.000
遅延スタックを使用して、この動作を変更できます。

00:01:23.000 --> 00:01:29.000
コンテンツ内でScrollViewがスクロールされる場所の正確な位置は、コンテンツオフセットと呼ばれます。

00:01:29.000 --> 00:01:34.000
SwiftUIは、コンテンツオフセットを制御する方法としてScrollViewReader APIを提供しました。

00:01:34.000 --> 00:01:42.000
今年、SwiftUIは、ScrollViewによって管理されるコンテンツオフセットに影響を与え、反応するより多くの方法を導入しています。

00:01:42.000 --> 00:01:48.000
この講演では、ScrollViewのマージンに影響を与える方法と、それらが安全なエリアとどのように関連しているかについて議論することから始めます。

00:01:48.000 --> 00:01:54.000
次に、スクロールターゲットとスクロール位置によるScrollViewのコンテンツオフセットの管理について説明します。

00:01:54.000 --> 00:02:00.000
最後に、スクロールトランジションでアプリに本当の才能を追加する方法を紹介します。

00:02:00.000 --> 00:02:07.000
私がColorsアプリを作り始めて以来、私のユーザーは私のお気に入りの色の組み合わせのいくつかを私に見せるのが本当に好きでした。

00:02:07.000 --> 00:02:12.000
他の人が楽しめるように、これらの組み合わせのいくつかを特集したいと思います。

00:02:12.000 --> 00:02:16.000
これを行うために、私はColorsアプリにギャラリー機能を追加することに取り組んできました。

00:02:16.000 --> 00:02:19.000
私はすでに私のギャラリーの実装でいくつかの進歩を遂げました。

00:02:19.000 --> 00:02:27.000
この講演を通して、私はギャラリーの特集セクションのヘッダーと内容の両方を磨きます。

00:02:27.000 --> 00:02:31.000
私のギャラリーでは、怠惰なスタックを包む水平スクロールビューがあります。

00:02:31.000 --> 00:02:35.000
まず、このビューをいくつかの余白で少しきれいに見せます。

00:02:35.000 --> 00:02:46.000
あなたの最初の本能は、ScrollViewにパディングを追加することかもしれません、そしてこれはScrollViewを挿入しますが、スクロールするときにそのコンテンツがクリップされていることに注意してください。

00:02:46.000 --> 00:02:53.000
ScrollView自体を設定する代わりに、ScrollViewのコンテンツマージンを拡張したいと思います。

00:02:53.000 --> 00:02:56.000
私は新しい安全なエリアパディング修飾子でそれを行うことができます。

00:02:56.000 --> 00:03:03.000
これは通常のパディング修飾子のように動作しますが、コンテンツをパディングする代わりに、安全な領域にパディングを追加します。

00:03:03.000 --> 00:03:08.000
これで、私のScrollViewは全体の幅を拡大し、次のアイテムを覗くことができます。

00:03:08.000 --> 00:03:15.000
先に進む前に、ScrollViewに関連する安全な領域について少し話します。

00:03:15.000 --> 00:03:19.000
安全なエリアは、最も一般的には、アプリが実行されているデバイスから来ています。

00:03:19.000 --> 00:03:24.000
また、セーフエリアパディングやセーフエリアインセット修飾子などのAPIからも来ることができます。

00:03:24.000 --> 00:03:30.000
ScrollViewは、セーフエリアをコンテンツに適用する余白に解決します。

00:03:30.000 --> 00:03:39.000
これには、あなたが責任を負うコンテンツだけでなく、スクロールビューが担当するスクロールインジケーターなどの追加コンテンツも含まれます。

00:03:39.000 --> 00:03:48.000
これは、セーフエリアを変更することで、異なる種類のコンテンツに対して異なるインセットを設定することができないことを意味します。

00:03:48.000 --> 00:03:53.000
異なるインセットを適用したい場合は、新しいcontentMargins APIを使用できます。

00:03:53.000 --> 00:03:59.000
このAPIを使用すると、スクロールインジケーターとは別にScrollViewのコンテンツを挿入できます。

00:03:59.000 --> 00:04:03.000
または、コンテンツとは別にインジケーターを挿入します。

00:04:03.000 --> 00:04:10.000
ギャラリーに戻って、セーフエリアのパディング修飾子を更新して、コンテンツマージンAPIを使用します。

00:04:10.000 --> 00:04:20.000
私のビューに少し余白が適用されたので、私がやりたいことの1つは、誰かが指を離すとScrollViewがスクロールするコンテンツのオフセットを制御することです。

00:04:20.000 --> 00:04:31.000
デフォルトでは、ScrollViewはスクロールの速度とともに標準の減速速度を使用して、スクロールが終了するターゲットコンテンツのオフセットを計算します。

00:04:31.000 --> 00:04:36.000
ScrollViewのサイズやそのコンテンツなどを考慮していません。

00:04:36.000 --> 00:04:38.000
しかし、時にはそれらのことが重要です。

00:04:38.000 --> 00:04:46.000
SwiftUIの新機能では、ScrollViewがこのターゲットコンテンツのオフセットを計算する方法をscrollTargetBehavior修飾子で変更できます。

00:04:46.000 --> 00:04:52.000
この修飾子は、scrollTargetBehaviorプロトコルに準拠した型を取ります。

00:04:52.000 --> 00:04:56.000
ここでは、ページングの動作を指定しました。

00:04:56.000 --> 00:04:59.000
今、私のScrollViewは一度に1ページずつスワイプします。

00:04:59.000 --> 00:05:01.000
ページングの動作は特別です。

00:05:01.000 --> 00:05:08.000
カスタム減速率があり、ScrollView自体の包含サイズに基づいてスクロールする場所を選択します。

00:05:08.000 --> 00:05:14.000
これはiOSではうまく機能しますが、iPadOSの大きな画面では少し大きくなります。

00:05:14.000 --> 00:05:21.000
ScrollViewの包含サイズに整列する代わりに、個々のビューに整列したいと思います。

00:05:21.000 --> 00:05:29.000
ビューの整列動作はScrollViewをビューに整列させるので、ScrollViewは整列のためにどのビューを考慮すべきかを知る必要があります。

00:05:29.000 --> 00:05:38.000
これらのビューはスクロールターゲットと呼ばれ、どのビューがスクロールターゲットであるかを指定できる新しい修飾子ファミリーがあります。

00:05:38.000 --> 00:05:46.000
ここでは、スクロールターゲットレイアウト修飾子を使用して、遅延スタック内の各ヒーロービューをスクロールターゲットとみなします。

00:05:46.000 --> 00:05:52.000
スクロールターゲット修飾子を使用して、個々のビューをターゲットとしてマークすることもできます。

00:05:52.000 --> 00:05:57.000
しかし、レイジースタックを使用する場合は、スクロールターゲットレイアウト修飾子を使用することが重要です。

00:05:57.000 --> 00:06:01.000
可視領域外のビューはまだ作成されていません。

00:06:01.000 --> 00:06:10.000
ただし、レイアウトはどのビューを作成するかを知っているので、ScrollViewが正しい場所にスクロールするようにすることができます。

00:06:10.000 --> 00:06:14.000
今、私のScrollViewはiPadでずっと良く見えます。

00:06:14.000 --> 00:06:19.000
ページングとビューの整列動作は、新しいScrollTargetBehaviorプロトコルに基づいて構築されています。

00:06:19.000 --> 00:06:32.000
SwiftUIはこれらの一般的な動作を提供しますが、以前に導入されたレイアウトプロトコルを採用するのと同様に、独自のタイプをこのプロトコルに適合させ、独自のカスタム動作を実装することもできます。

00:06:32.000 --> 00:06:39.000
必要なメソッドを1つ実装して、ScrollTargetBehaviorに独自のタイプを適合させます: updateTarget。

00:06:39.000 --> 00:06:48.000
SwiftUIは、スクロールが終了する場所を計算するときにこのメソッドを呼び出しますが、ScrollViewがサイズを変更したときなどの他のコンテキストでも呼びます。

00:06:48.000 --> 00:06:50.000
動作のカスタマイズは簡単です。

00:06:50.000 --> 00:07:02.000
ここで、ターゲットがScrollViewの上部に近く、スクロールが上にフリックされている場合は、提供されたターゲットを変更して、ScrollViewの正確な上部までスクロールすることを好みます。

00:07:02.000 --> 00:07:08.000
これにより、ScrollViewはスクロールの終点として別のコンテンツオフセットを選択します。

00:07:08.000 --> 00:07:15.000
そして、ScrollViewがスクロールすることを選択した場所に影響を与えるために、私自身のカスタムコードを挿入するために必要なのはそれだけです。

00:07:15.000 --> 00:07:16.000
私のギャラリービューに戻りましょう。

00:07:16.000 --> 00:07:18.000
レイアウトについて話したいのですが。

00:07:18.000 --> 00:07:24.000
私のヒーロービューは、デバイスの全体的な幅に関連してサイズが設定されていることに注意してください。

00:07:24.000 --> 00:07:29.000
そして、iPadを見ると、2つのビューがデバイスの幅に均等に収まります。

00:07:29.000 --> 00:07:40.000
以前は、これを達成するためにGeometryReaderを使用する必要がありましたが、今年はSwiftUIがcontainerRelativeFrame修飾子と呼ばれる新しいAPIでこれをはるかに簡単にします。

00:07:40.000 --> 00:07:44.000
私のヒーロービューがこのAPIをどのように使用しているかをお見せします。

00:07:44.000 --> 00:07:51.000
固定高さを指定するフレーム修飾子とともに、カラービューのスタックから始めます。

00:07:51.000 --> 00:07:54.000
containerRelativeFrame修飾子をビューに追加します。

00:07:54.000 --> 00:08:01.000
ここでは、ビューがコンテナの幅を取ることができる水平軸を指定します。

00:08:01.000 --> 00:08:10.000
私の場合、コンテナは周囲のScrollViewになりますが、ナビゲーション分割ビューの最も近い列、またはアプリのウィンドウである可能性があります。

00:08:10.000 --> 00:08:15.000
コンテナの幅が変わると、ビューのサイズが自動的に更新されます。

00:08:15.000 --> 00:08:21.000
カウントと間隔を指定することで、これらのビューのグリッドのようなレイアウトを作成できます。

00:08:21.000 --> 00:08:28.000
水平サイズクラスに基づいてカウントを条件付けして、iPadに2つの列、電話で1つの列を持つことができます。

00:08:28.000 --> 00:08:38.000
さらに良いのは、水平sizeClass環境プロパティがすべてのプラットフォームで利用可能になったため、OSの条件を削除できることです。

00:08:38.000 --> 00:08:48.000
最後に、固定高さをハードコーディングするのではなく、幅に対して相対的な高さを持つために、aspectario修飾子を使用します。

00:08:48.000 --> 00:08:51.000
だから、ギャラリーのレイアウトとスクロールの動作を完成させました。

00:08:51.000 --> 00:08:54.000
もう少し変更を加えたいことがあります。

00:08:54.000 --> 00:08:57.000
あなたが気づくことの1つは、スクロールインジケーターです。

00:08:57.000 --> 00:09:00.000
それらを削除したいのですが。

00:09:00.000 --> 00:09:05.000
既存のscrollIndicators APIを使用してこれを達成できます。

00:09:05.000 --> 00:09:10.000
これはiPadで指をスワイプするときに素晴らしく見えますが、私はよくMacでギャラリーを使います。

00:09:10.000 --> 00:09:19.000
また、Macでは、マウスやその他の入力デバイスを使用するときのように、水平方向のスワイプジェスチャーを簡単に実行できないかもしれません。

00:09:19.000 --> 00:09:25.000
そして、マウスを接続すると、非表示にするように要求したにもかかわらず、インジケーターが表示されます。

00:09:25.000 --> 00:09:29.000
マウスを使用すると、スクロールインジケーターなしでスクロールが困難または不可能になる可能性があります。

00:09:29.000 --> 00:09:43.000
このため、scrollIndicators修飾子のデフォルトの動作は、トラックパッドなどのより柔軟な入力デバイスを使用するときにインジケーターを非表示にすることですが、マウスが接続されているときにインジケーターを表示できるようにすることです。

00:09:43.000 --> 00:09:50.000
scrollIndicators修飾子にneverの値を指定して、入力デバイスに関係なく常にインジケーターを非表示にすることができます。

00:09:50.000 --> 00:09:54.000
しかし、私のアプリはまだマウスを使用する人々をサポートする必要があります。

00:09:54.000 --> 00:09:58.000
だから、私は彼らのために私のギャラリーをスクロールする別の手段を提供する必要があります。

00:09:58.000 --> 00:10:07.000
スクロールインジケーターの代わりに、ユーザーがクリックで前または次のビューにスクロールできるビューをレンダリングします。

00:10:07.000 --> 00:10:11.000
それを構築し始めるために、私のScrollViewを少しクリーンアップしましょう。

00:10:11.000 --> 00:10:15.000
ヘッダービューでScrollViewをVStackに移動します。

00:10:15.000 --> 00:10:19.000
次に、ヘッダービューに焦点を当てます。

00:10:19.000 --> 00:10:22.000
ヘッダービューにカスタムパドルビューを追加します。

00:10:22.000 --> 00:10:30.000
過去のバージョンのSwiftUIでは、ScrollViewReaderに手を伸ばしてパドルに渡して適切なビューにスクロールしただろう。

00:10:30.000 --> 00:10:34.000
しかし、SwiftUIの新機能はscrollPosition修飾子です。

00:10:34.000 --> 00:10:38.000
この修飾子は、識別子をラップする状態へのバインディングを関連付けます。

00:10:38.000 --> 00:10:45.000
私はそれを、ScrollViewが読み取る私のscrollPosition修飾子に渡し、私のヘッダービューに渡します。

00:10:45.000 --> 00:10:51.000
ヘッダービューのパドルでは、他の状態と同じようにバインディングに書き込むことができます。

00:10:51.000 --> 00:10:56.000
バインディングが書き込まれると、ScrollViewはそのIDでビューにスクロールします。

00:10:56.000 --> 00:11:09.000
View aligned ScrollTargetBehaviorと同様に、スクロール位置モディファイアは、スクロールターゲットレイアウトモディファイアを使用して、アイデンティティ値を照会するためにどのビューを検討するかを知る。

00:11:09.000 --> 00:11:15.000
スクロール位置修飾子を使用すると、現在スクロールされているビューのアイデンティティを知ることもできます。

00:11:15.000 --> 00:11:22.000
そのため、現在スクロールされているヒーロー画像の値を示すテキストをヘッダービューに追加できます。

00:11:22.000 --> 00:11:27.000
ScrollViewで最も主要なビューが変更されると、バインディングは自動的に更新されます。

00:11:27.000 --> 00:11:30.000
今、私のマウスユーザーは私のギャラリーをスクロールすることができます。

00:11:30.000 --> 00:11:33.000
このビューに追加したい磨く最後のビットがあります。

00:11:33.000 --> 00:11:43.000
どのビューが現在スクロールされているかを知るのが便利なように、スクロールビュー内のどこにあるかに基づいてビューを視覚的に変更したい場合があります。

00:11:43.000 --> 00:11:48.000
SwiftUIにはScrollTransitionsと呼ばれる新しいAPIがあり、これを本当に簡単にします。

00:11:48.000 --> 00:11:52.000
スクロールトランジションは、通常のトランジションによく似ています。

00:11:52.000 --> 00:11:58.000
トランジションは、ビューが出現または消滅したときに受けるべき変更を記述します。

00:11:58.000 --> 00:12:04.000
ビューが表示されたとき、それはカスタマイズを適用すべきではないアイデンティティ段階にあります。

00:12:04.000 --> 00:12:17.000
ScrollTransitionは、同様の一連の変更をトランジションとして記述しますが、代わりにビューがScrollViewの可視領域に入り、可視領域を離れるときにそれらを適用します。

00:12:17.000 --> 00:12:24.000
デフォルトでは、ビューが可視領域の中央にある場合、ScrollTransitionのアイデンティティフェーズにあります。

00:12:24.000 --> 00:12:27.000
私のヒーロービューの文脈でこれを見てみましょう。

00:12:27.000 --> 00:12:33.000
ScrollTransitionsに集中するために、これを少しクリーンアップします。

00:12:33.000 --> 00:12:38.000
ビューがScrollViewの端に近づくと、サイズを少し縮小したいと思います。

00:12:38.000 --> 00:12:42.000
scrollTransition修飾子を追加することから始めます。

00:12:42.000 --> 00:12:50.000
このAPIは、コンテンツとフェーズを取り、フェーズに基づいてコンテンツの視覚的な変更を指定できます。

00:12:50.000 --> 00:12:57.000
ここでは、ビューがアイデンティティフェーズにない場合のスケールの縮小を指定します。

00:12:57.000 --> 00:12:59.000
それは素晴らしいですね！

00:12:59.000 --> 00:13:04.000
ScrollTransitionsは、VisualEffectと呼ばれる新しいプロトコルで動作します。

00:13:04.000 --> 00:13:12.000
このプロトコルは、スクロールビューのコンテンツオフセットなどのレイアウトの機能として安全に使用できるビューコンテンツの一連のカスタマイズを提供します。

00:13:12.000 --> 00:13:15.000
それらの多くはあなたに見覚えがあるかもしれません。

00:13:15.000 --> 00:13:18.000
あなたはすでにスケール効果について知っています。

00:13:18.000 --> 00:13:24.000
ビュー修飾子と同じように、回転やオフセットをカスタマイズすることもできます。

00:13:24.000 --> 00:13:30.000
ただし、すべてのビュー修飾子がscrollTransition内で安全に使用できるわけではありません。

00:13:30.000 --> 00:13:35.000
たとえば、フォントのカスタマイズはサポートされておらず、ビルドされません。

00:13:35.000 --> 00:13:42.000
ScrollViewの全体的なコンテンツサイズを変更するものは、scrollTransition修飾子内で使用することはできません。

00:13:42.000 --> 00:13:47.000
うわー、私たちは多くのことをカバーしたので、簡単なレビューをしましょう。

00:13:47.000 --> 00:13:53.000
セーフエリアとcontentMarginsの違いと、ScrollViewsとの関係について話しました。

00:13:53.000 --> 00:14:05.000
ページングとビューで整列されたscrollTargetBehaviorsを使用して、ScrollViewの動作に影響を与える方法と、scrollTargetBehaviorプロトコルに独自の適合性を書き込む方法を示しました。

00:14:05.000 --> 00:14:14.000
containerRelativeFrame修飾子を使用して、コンテナを基準にしてレイアウトを作成するのがいかに簡単かを学びました。

00:14:14.000 --> 00:14:24.000
scrollPosition修飾子を使用してScrollViewの状態に接続し、プログラムでスクロールし、どのビューが現在スクロールされているかを知らせることができました。

00:14:24.000 --> 00:14:31.000
そして最後に、scrollTransition APIを使用してScrollViewのコンテンツオフセットに基づいて視覚効果を作成しました。

00:14:31.000 --> 00:14:34.000
ScrollViewsのこれらの改善について学ぶことを楽しんだことを願っています。

00:14:34.000 --> 00:14:37.000
ありがとう、そして素晴らしいWWDCをお過ごしください。

00:14:37.000 --> 23:59:59.000
♪ ♪

