WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:17.000
ジェームズ:こんにちは。私はUIKitのJames Magahernです。テキストとテキストのインタラクションに関する新機能のガイドになります。

00:00:17.000 --> 00:00:20.000
テキストはすべてのアプリケーションで重要な役割を果たします。

00:00:20.000 --> 00:00:24.000
これは、情報を消費し、コミュニケーションをとるための主要な方法です。

00:00:24.000 --> 00:00:33.000
今、私たちは、ゼロから始めるか、高レベルの抽象化から始めるかにかかわらず、アプリで強力なテキスト体験を作成するためのさらに多くのツールを提供しています。

00:00:33.000 --> 00:00:56.000
システム選択UIへのいくつかの変更、UITextViewsへのテキストアイテムアクションとメニューの追加、TextKit 2のリストと箇条書き、macOSのディクテーションUI、国際化のためのいくつかの重要なアップデートなど、テキストエクスペリエンスの作成とアプリでそれらを活用する方法に関する多くの大きな改善について説明します。

00:00:56.000 --> 00:00:59.000
まず、選択UIのいくつかの変更について話します。

00:00:59.000 --> 00:01:04.000
すべてのプラットフォームで新しくなったのは、完全に再設計されたテキストカーソルです。

00:01:04.000 --> 00:01:19.000
入力言語を変更するときにインラインでインタラクティブなスイッチャーを表示し、範囲選択を行うときにより人間工学に基づいた選択ハンドルを表示し、大きなテキストにカーソルを簡単に配置できるように、まったく新しいルーペもあります。

00:01:19.000 --> 00:01:27.000
アプリがUITextViewsまたはUITextFieldsを使用している場合は、この新しいUIがすべて自動的に取得されます。

00:01:27.000 --> 00:01:33.000
さらに、UITextInteractionのクライアントも新しい選択UIを取得することを確認しました。

00:01:33.000 --> 00:01:46.000
ただし、テキストを表示するための高度にカスタマイズされたUIがある場合、特にUITextInteractionを採用できない場合は、独自の実装でこれらの変更に追いつくのは難しい場合があります。

00:01:46.000 --> 00:01:57.000
そのため、iOS 17では、UITextInteractionに含まれるジェスチャーなしで選択UIを提供するUITextSelectionDisplayInteractionを追加しました。

00:01:57.000 --> 00:02:04.000
UITextSelectionDisplayInteractionは、任意のUIViewにインストールできる新しいタイプのUIInteractionです。

00:02:04.000 --> 00:02:16.000
また、ビューから選択状態を取得するためのインタラクションのさまざまなメソッドを定義するUITextInputプロトコルを実装するオブジェクトも提供する必要があります。

00:02:16.000 --> 00:02:28.000
UITextSelectionDisplayInteractionは、カーソルビューとカーソルアクセサリー、および範囲のハイライトと選択ハンドルを提供し、すべての重い作業を行います。

00:02:28.000 --> 00:02:33.000
これらのビューはすべて交換可能なので、必要に応じて動作をカスタマイズできます。

00:02:33.000 --> 00:02:36.000
ここでは、コードでこれを行う方法の例を簡単に見てみましょう。

00:02:36.000 --> 00:02:46.000
まず、選択表示インタラクションを作成し、UITextInputプロトコルを実装するドキュメントオブジェクトを提供します。

00:02:46.000 --> 00:02:50.000
該当する場合、これはあなたの見解と同じにすることができます。

00:02:50.000 --> 00:02:56.000
次に、内部に選択UIを表示するビューにインタラクションを追加するだけです。

00:02:56.000 --> 00:03:01.000
これは、コンテナビューでも、ドキュメントをレンダリングするビューでもかまです。

00:03:01.000 --> 00:03:13.000
選択状態が変更されるたびに、インタラクションでsetNeedsSelectionUpdateを呼び出すだけで、インタラクションは新しい選択状態を反映するようにすべてのビューを更新します。

00:03:13.000 --> 00:03:19.000
UITextSelectionDisplayInteractionに加えて、ルーペを表示するための新しいAPIも追加しました。

00:03:19.000 --> 00:03:27.000
どのビューでも使用でき、UITextSelectionDisplayInteractionまたはUITextInputを使用する必要はありません。

00:03:27.000 --> 00:03:35.000
ルーペの更新を推進するには、UIPanGestureRecognizerなどのジェスチャーリコグナイザを使用することをお勧めします。

00:03:35.000 --> 00:03:38.000
ルーペセッションをコードで管理する方法は次のとおりです。

00:03:38.000 --> 00:03:47.000
パンジェスチャーリコグナイザを使用する場合は、コールバックで、ジェスチャーの場所と選択ウィジェット、この場合はカーソルビューをつかみます。

00:03:47.000 --> 00:04:00.000
次に、ジェスチャーが開始されている場合は、 begin(at:) を呼び出して新しい UITextLoupeSession を作成し、ルーペの開始場所、選択ウィジェット、および座標空間を提供します。

00:04:00.000 --> 00:04:08.000
次に、ジェスチャーが移動したら、既存のルーペセッションでmove(to:)を呼び出すと、その場所を更新します。

00:04:08.000 --> 00:04:15.000
最後に、ジェスチャーリコグナイザが終了したら、ルーペセッションで無効を呼び出すようにしてください。

00:04:15.000 --> 00:04:22.000
次に、テキストアイテムのアクションと、それらを使用してテキストビュー内のメニューを表示する方法について説明します。

00:04:22.000 --> 00:04:31.000
UITextViewのテキストアイテムのインタラクションは、UITextViewDelegateの新しいAPIを使用して、はるかにカスタマイズ可能になりました。

00:04:31.000 --> 00:04:41.000
これらの新しい追加により、テキスト項目のプライマリアクションを変更したり、翻訳アプリでここに表示されている候補メニューのようなメニューを表示したりすることができます。

00:04:41.000 --> 00:04:53.000
以前は、UITextViewでは、開発者はリンクと添付ファイルのUITextViewDelegateのshouldInteractWith APIを介してアイテムインタラクションを無効にすることができます。

00:04:53.000 --> 00:05:00.000
iOS 17では、テキストビューのテキストアイテムのアイテムインタラクションをカスタマイズできるようになりました。

00:05:00.000 --> 00:05:09.000
UITextViewDelegateは、プライマリアクションの両方をカスタマイズしたり、特定のテキスト項目のメニューを提供したりする新しいメソッドを獲得しました。

00:05:09.000 --> 00:05:16.000
ここでは、テキストアイテムが実際に何であり、それらがアプリとどのように統合されるかを簡単に確認します。

00:05:16.000 --> 00:05:21.000
テキストアイテムは、アイテムのインタラクションをサポートするコンテンツを表します。

00:05:21.000 --> 00:05:32.000
これには、NSTextAttachmentで表されるテキスト添付ファイルと、NSLinkAttributeNameで表されるリンクが含まれます。

00:05:32.000 --> 00:05:38.000
UITextItemは、インタラクションのためのテキストのカスタム範囲のタグ付けもサポートするようになりました。

00:05:38.000 --> 00:05:47.000
インタラクションの範囲にタグを付けるには、インタラクティブにしたいテキストの範囲を表す属性文字列にUITextItemTagAttributeNameを使用します。

00:05:47.000 --> 00:05:56.000
これらの新しいAPIを使用すると、テキスト項目が操作されているときのデフォルトのタップまたはメニューの動作を変更できるようになりました。

00:05:56.000 --> 00:06:07.000
たとえば、既知のリンクをアプリ内の既存のビューにリダイレクトしたり、テキストの一部にカスタムメニューを追加したりできます。

00:06:07.000 --> 00:06:18.000
プライマリアクションまたはメニューを抑制または無効にし続けるには、menuConfigurationまたはprimaryActionデリゲートメソッドのnilを返すだけです。

00:06:18.000 --> 00:06:27.000
これは、ユーザーがUITextView内のリンクをタップしたことに応じてメニューを表示する方法を示す小さなコード例です。

00:06:27.000 --> 00:06:38.000
UITextViewDelegateからmenuConfigurationFor:defaultMenu:メソッドを実装し、表示したいメニューを含むメニュー設定を返すだけです。

00:06:38.000 --> 00:06:46.000
メニュー設定の一部としてプレビューを提供して、コンテキストメニューの残りの部分とインラインで表示することもできます。

00:06:46.000 --> 00:06:50.000
リストと箇条書きのサポートもTextKit 2に追加されました。

00:06:50.000 --> 00:06:53.000
アプリケーションでこれを利用する方法について説明します。 

00:06:53.000 --> 00:07:02.000
複数の異なる種類の箇条書きアイテムをサポートすることに加えて、ローマ数字、アルファベット順、小数順もサポートされています。

00:07:02.000 --> 00:07:12.000
それぞれは、デバイスまたはアプリの設定されたロケールに基づいて自動的にローカライズされるため、世界的な国際化が組み込まれています。

00:07:12.000 --> 00:07:17.000
以下は、属性文字列を使用してテキストリストを使い始める方法の簡単な例です。

00:07:17.000 --> 00:07:25.000
NSParagraphStyleのtextListsプロパティを使用して、どの段落に順序付きリストが適用されているかを定義します。

00:07:25.000 --> 00:07:36.000
システムは、改行などの行終端文字に基づいてアイテムに自動的に番号を付け、UITextViewは入力属性に基づいて段落スタイルを自動的に伝播します。

00:07:36.000 --> 00:07:41.000
macOS Sonomaでのディクテーションの仕組みにはいくつかの大きな変化があります。

00:07:41.000 --> 00:07:46.000
カスタムテキスト要素が新しいデザインでうまく機能することを確認するのに役立つ新しいAPIがいくつかあります。

00:07:46.000 --> 00:07:52.000
これは、新しいディクテーションインジケーターがmacOS 14でどのように動作するかです。

00:07:52.000 --> 00:08:01.000
iOSと同様に、ディクテーションは話している間に後続のグロー効果があり、静止時にはマイクインジケーターが表示されます。

00:08:01.000 --> 00:08:12.000
スクロール後、カーソルの横にあるインジケーターがスクロールビューの端にくっつき、ドキュメントの現在の位置に戻るボタンを提供することに注意してください。

00:08:12.000 --> 00:08:19.000
NSTextViewのようなAppKitで標準のテキストコントロールを使用している場合、この動作は箱から出してすぐに得るでしょう。

00:08:19.000 --> 00:08:28.000
アプリが挿入ポイントを表示するためのカスタマイズされた実装を提供している場合、この新しい動作をサポートするために少し作業する必要があります。

00:08:28.000 --> 00:08:38.000
iOS用のUITextSelectionDisplayInteractionと同様に、システムの選択UIとの一貫性を保つことができるmacOS用の新しいAPIがあります。

00:08:38.000 --> 00:08:51.000
独自のカーソルを描画する代わりに、ドキュメントのビュー内に配置してカーソルの位置を示すことができるカスタマイズ可能なNSViewサブクラスであるNSTextInsertionIndicatorを採用してください。

00:08:51.000 --> 00:08:53.000
その外観はカスタマイズ可能です。

00:08:53.000 --> 00:08:56.000
色とサイズを変更できます。

00:08:56.000 --> 00:09:00.000
デフォルトでは、現在のアクセントカラーに従います。

00:09:00.000 --> 00:09:03.000
ディクテーション効果のサポートが本当に簡単になります。

00:09:03.000 --> 00:09:09.000
システムが適切なビューを階層に挿入できるようにするには、ほんの少しの設定が必要です。

00:09:09.000 --> 00:09:15.000
macOSでNSTextInsertionIndicatorを使い始める方法は次のとおりです。

00:09:15.000 --> 00:09:24.000
NSTextInsertionIndicatorビューを作成し、ドキュメントの内容を表示しているビューにサブビューとして追加するだけです。

00:09:24.000 --> 00:09:32.000
完了したら、effectsViewInserterを、システムが提供するビューをドキュメントのビュー階層に挿入するブロックに設定します。

00:09:32.000 --> 00:09:41.000
システムは自動的にエフェクトビューを配置し、挿入インジケーターが移動するにつれて更新されるようにします。

00:09:41.000 --> 00:09:50.000
カスタムテキストビューがレスポンダーステータスを辞任するときは、displayModeを非表示に設定してカーソルを非表示にしてください。

00:09:50.000 --> 00:09:59.000
テキストが挿入されると、ディクテーションが入力ソースとして使用されている場合、フレームの更新は自動的にグロー効果でアニメーション化されます。

00:09:59.000 --> 00:10:07.000
グロー効果を無効にする必要がある場合は、automaticModeOptionsからshowEffectsViewオプションを削除してください。

00:10:07.000 --> 00:10:17.000
ユーザーが入力モードを変更すると、効果ビューが水平テキストでカーソルの下に表示され、言語選択UIが表示されます。

00:10:17.000 --> 00:10:26.000
このUIの配置を上書きする必要がある場合は、NSTextInputClientの実装でpreferredTextAccessoryPlacementを指定できます。

00:10:26.000 --> 00:10:31.000
システムは、このプロパティの値をチェックして、アクセサリを描画する場所を決定します。

00:10:31.000 --> 00:10:46.000
ディクテーション中にテキストカーソルが画面外にスクロールされると、システムにはスクロールアウェイインジケーターも表示され、カーソルの相対的な位置を示し、ディクテーションポイントに戻るためのアフォーダンスを提供します。

00:10:46.000 --> 00:10:58.000
この動作がカスタムテキストビューでサポートされていることを確認するには、NSTextInputClientを採用し、selectionRectとdocumentVisibleRectプロパティを実装してください。

00:10:58.000 --> 00:11:08.000
textInputClientWillStartScrollingOrZoomingとwillEndScrollingOrZoomingを呼び出して、スクロールの開始と終了についてシステムに通知します。

00:11:08.000 --> 00:11:15.000
アプリがすべての言語でうまく機能することを確認することは、優れたテキスト体験を提供するために不可欠です。

00:11:15.000 --> 00:11:22.000
標準のテキストコントロールにいくつかの重要な変更を加え、より幅広い言語で読みやすさと人間工学を強化しました。

00:11:22.000 --> 00:11:30.000
アプリのダイナミックタイプをサポートすることは、すべての言語でUIのレイアウトを改善するのに大いに役立ちます。

00:11:30.000 --> 00:11:42.000
アプリでテキスト要素をレイアウトする際に考慮すべき重要なことは、レイアウト方向やフォントスタイルに加えて、多くの言語が可変行の高さを持つことができるという事実です。

00:11:42.000 --> 00:11:49.000
言語間の可変行の高さを扱うときに発生する一般的な問題は、クリップされたテキストの問題です。

00:11:49.000 --> 00:11:59.000
これは見た目が悪いだけでなく、読みやすさに大きな影響を与え、アプリの全体的なユーザーエクスペリエンスを著しく妨げる可能性があります。

00:11:59.000 --> 00:12:04.000
これらの問題は、特にすべての言語でアプリをテストできない場合は、気づくのが難しいかもしれません。

00:12:04.000 --> 00:12:13.000
ほとんどの場合、この問題に自動的に対処するために、UITextFieldやUILabelなどの標準テキスト要素にいくつかの改善を加えました。

00:12:13.000 --> 00:12:21.000
ただし、システムがこれらの要素のクリッピングを防ぐことができることを確認するために、確実に従うべきベストプラクティスがいくつかあります。

00:12:21.000 --> 00:12:33.000
これらの一般的なクリッピングの問題を防ぐために、すべてのプラットフォームは、非常にダイナミックな行の高さを持つ言語に対応するために、UILabelまたはUITextFieldの行の高さを自動的に調整します。

00:12:33.000 --> 00:12:37.000
この新しい動作は、特定の場合にのみ行われます。

00:12:37.000 --> 00:12:43.000
まず、線の高さは、デバイスが設定した優先言語に依存することを覚えておいてください。

00:12:43.000 --> 00:12:57.000
第二に、この調整はユーザーインターフェイス全体に影響し、英語などの固定行の高さのスクリプトを表示するものでも、すべてのテキスト要素の行の高さが増加し、通常は余分なスペースを必要としません。

00:12:57.000 --> 00:13:02.000
これは、すべてのテキスト要素にわたって視覚的な一貫性を確保するために意図的です。

00:13:02.000 --> 00:13:08.000
最後に、この自動調整は、テキストスタイルを使用するテキスト要素にのみ適用されます。

00:13:08.000 --> 00:13:12.000
カスタムフォントは、固定行の高さを引き続き使用します。

00:13:12.000 --> 00:13:17.000
この動作は、いくつかのリリースで有効になっているため、まったく新しいものではありません。

00:13:17.000 --> 00:13:26.000
しかし、iOS 17でははるかにダイナミックで、正確な調整はテキストスタイルと使用される言語の両方に依存します。

00:13:26.000 --> 00:13:37.000
この動作を利用するには、preferredFont(forTextStyle:)メソッドでUIFontを明示的に作成し、UILabelのようなテキスト要素に割り当てることでテキストスタイルを採用します。

00:13:37.000 --> 00:13:41.000
次に、テキスト要素にclipsToBoundsを設定しないでください。

00:13:41.000 --> 00:13:48.000
タイ語やヒンディー語などの言語のアセンダとディセンダーは、しばしばラインの高さの境界を越えて突き出ます。

00:13:48.000 --> 00:13:59.000
これは通常、隣接する要素の周りに余分なスペースがあるため、ほとんどのレイアウトで一般的に許容されますが、clipsToBoundsを設定すると、それらのテキスト要素がクリップされることを意味します。

00:13:59.000 --> 00:14:06.000
UIKitは、以前にデフォルトで有効になっていたこの設定の不要な使用を防ぐためにも更新されました。

00:14:06.000 --> 00:14:16.000
最後に、テキスト要素が垂直に成長できるようになったため、UIが高さの変化に反応し、他のすべてのコントロールが整列したままであることを確認してください。

00:14:16.000 --> 00:14:24.000
また、中国語、ドイツ語、日本語、韓国語などの言語の改行行動を大幅に強化しました。

00:14:24.000 --> 00:14:32.000
これらの改善は、UIで使用しているテキストスタイルの種類と表示されている言語に基づいて、異なるルールを適用します。

00:14:32.000 --> 00:14:39.000
たとえば、以前は、韓国語のテキスト内の単語が行間で分割されていた可能性があります。

00:14:39.000 --> 00:14:47.000
これで、UIKitはタイトルテキストスタイルの分割を防ぎ、よりシームレスな読書体験を保証します。

00:14:47.000 --> 00:14:53.000
アプリでこの新しい動作の恩恵を受けるには、同様にテキストスタイルを採用してください。

00:14:53.000 --> 00:15:00.000
iOS 17のアプリで強力なテキスト体験を作成するために知っておくべきことはすべてです。

00:15:00.000 --> 00:15:09.000
アプリでカスタムテキストビューを使用している場合は、システム選択UIを使用して、OSのすべての新機能を活用してください。

00:15:09.000 --> 00:15:15.000
テキストアイテムを使用して、テキストビュー内のリンクとのより良いインタラクションを作成します。

00:15:15.000 --> 00:15:21.000
TextKit 2の強力な新機能を活用して、より豊かなテキスト編集体験を提供します。

00:15:21.000 --> 00:15:31.000
また、一般的なテキスト要素にテキストスタイルを採用して、言語や優先テキストサイズに関係なく、すべての人に優れたユーザーエクスペリエンスを提供します。

00:15:31.000 --> 00:15:32.000
今のところはこれで全部です。

00:15:32.000 --> 00:15:34.000
見てくれてありがとう。

00:15:34.000 --> 00:15:37.000
必ず5つ星を評価し、下にコメントを残してください。

00:15:37.000 --> 23:59:59.000
♪ ♪

