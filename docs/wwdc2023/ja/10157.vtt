WEBVTT

00:00:01.000 -> 00:00:10.000
♪ ♪

00:00:10.000 -> 00:00:14.000
人物：こんにちは、SwiftUIの高度なアニメーションへようこそ。

00:00:14.000 -> 00:00:18.000
私はSwiftUIチームのメンバーであるティムです。

00:00:18.000 -> 00:00:29.000
SwiftUIには、アプリを輝かせる強力なアニメーションツールセットが付属しており、中断可能で、信頼できる動きのための物理ベースで、フレームワーク全体に深く統合されています。

00:00:29.000 -> 00:00:35.000
今日は、アプリのアニメーションを次のレベルに引き上げることができるエキサイティングな新しいツールについて話します。

00:00:35.000 -> 00:00:42.000
始める前に、SwiftUIですでに知っているアニメーションツールを簡単に確認しましょう。

00:00:42.000 -> 00:00:47.000
他のセッションでお気に入りのペットに投票できるこのアプリを見たことがあるかもしれません。

00:00:47.000 -> 00:00:53.000
このデモを簡素化するために、猫は明らかに最良の選択なので、私は先に進み、他のすべてのオプションを削除しました。

00:00:53.000 -> 00:01:02.000
アプリにアニメーションを追加するのは、「withAnimation」を使用したり、「アニメーション」モディファイアを追加したりするのと同じくらい簡単で、箱から出して素晴らしい動作を提供します。

00:01:02.000 -> 00:01:10.000
アプリケーションの状態が変更された後、SwiftUIは前の状態から新しい状態に補間するアニメーションを適用します。

00:01:10.000 -> 00:01:20.000
しかし、アニメーションでは、人生と同様に、どこから来たのか、どこに行くのかに集中していないときに、最もやりがいのある経験が見つかることがあります。

00:01:20.000 -> 00:01:25.000
時には、人里離れた道を降りて、何か特別なものを作るために旅そのものに集中する必要があります。

00:01:25.000 -> 00:01:29.000
また、一部のアニメーションは、単に以前の状態から新しい状態にアニメーション化しません。

00:01:29.000 -> 00:01:36.000
今日は、複雑でマルチステップのアニメーションを構築するための強力な新しいツールについて話します。

00:01:36.000 -> 00:01:42.000
これらのアニメーションは、2つの状態間でアニメーション化するのではなく、順番に発生する複数のステップを定義できます。

00:01:42.000 -> 00:01:51.000
そして、それらは2つの状況で特に素晴らしいです:アニメーションを繰り返し、ビューが見える間に連続的にループします...

00:01:51.000 -> 00:01:56.000
そして、イベントが発生したときにパルスするビューなど、イベント駆動型のアニメーション。

00:01:56.000 -> 00:02:02.000
この講演では、このようなアニメーションをさらに簡単に構築できる新しいAPIファミリーを紹介します。

00:02:02.000 -> 00:02:11.000
SwiftUIがアニメーションを構成する一連の事前に計画された状態を自動的に進めることができるアニメーションフェーズを紹介することから始めます。

00:02:11.000 -> 00:02:16.000
次に、キーフレームでアニメーションをさらに進める方法を実演します。

00:02:16.000 -> 00:02:21.000
そして最後に、このAPIを最大限に活用するための高度なヒントとコツを紹介します。

00:02:21.000 -> 00:02:25.000
私たちは行く準備ができていると思います。すぐに飛び込みましょう。

00:02:25.000 -> 00:02:29.000
スウィフトを書いていないときは、トレイルランニングに出るのが好きです。

00:02:29.000 -> 00:02:31.000
トレイルレースは非常に長くなることがあります。

00:02:31.000 -> 00:02:41.000
ウルトラマラソンは終了するのに丸1日、あるいは数日かかることがあるので、私は今後のイベントを計画し、実行中に重要な詳細を覚えておくのに役立つアプリを構築しています。

00:02:41.000 -> 00:02:44.000
あなたがトレイルにいるとき、栄養は非常に重要です。

00:02:44.000 -> 00:02:49.000
残念ながら、疲労が始まると、レースの後半に食べるのを忘れがちです。

00:02:49.000 -> 00:02:53.000
適切なタイミングで食べることを思い出させる機能をアプリに追加しました。

00:02:53.000 -> 00:02:58.000
ここでは、画面の下部にあるリマインダーは、私が食事の期限を過ぎていることを私に知らせています。

00:02:58.000 -> 00:03:00.000
しかし、問題があります。

00:03:00.000 -> 00:03:05.000
レースの後半で、私はとても疲れてしまうので、このような微妙な指標を見逃す可能性があります。

00:03:05.000 -> 00:03:11.000
私は本当に誤って食事をスキップしたくないので、このリマインダーを目立たせるためにいくつかの動きを追加します。

00:03:11.000 -> 00:03:13.000
この1つの見解に焦点を当てましょう。

00:03:13.000 -> 00:03:18.000
アニメーションのハイライト効果を与えて、さらに目立つようにしたい。

00:03:18.000 -> 00:03:23.000
このビューをアニメーション化するには、「.phaseAnimator」修飾子を適用します。

00:03:23.000 -> 00:03:31.000
フェーズアニメーター修飾子を使用すると、マルチパートアニメーションの個々のステップを定義する一連の状態を提供します。

00:03:31.000 -> 00:03:35.000
SwiftUIは、これらの状態間で自動的にアニメーション化されます。

00:03:35.000 -> 00:03:42.000
この場合、強調表示と強調表示されていない2つの状態の間でアニメーション化するので、単にブール値を使用できます。

00:03:42.000 -> 00:03:47.000
次に、現在のフェーズに応じてビューの外観を変更するために、いくつかの修飾子を適用します。

00:03:47.000 -> 00:03:54.000
不透明度修飾子から始めます。強調表示するとビューを完全に不透明にし、そうでない場合は50%透明にします。

00:03:54.000 -> 00:03:57.000
そしてすぐに、景色がアニメーション化し始めます。

00:03:57.000 -> 00:04:01.000
SwiftUIがあなたに代わって何をしているのかについて話しましょう。

00:04:01.000 -> 00:04:08.000
私たちの見解では、フェーズアニメーター修飾子に2つのフェーズを提供しました：falseとtrue。

00:04:08.000 -> 00:04:14.000
ビューが最初に表示されると、最初のフェーズがアクティブになり、ビューが50%透明になります。

00:04:14.000 -> 00:04:21.000
SwiftUIはすぐに、ビューが完全に不透明な次のフェーズへのアニメーション化された移行を開始します。

00:04:21.000 -> 00:04:25.000
そして、そのアニメーションが終了すると、SwiftUIは再び進みます。

00:04:25.000 -> 00:04:29.000
フェーズは2つしかないので、最初からループします。

00:04:29.000 -> 00:04:33.000
これにより、私たちのアニメーションは2つの状態の間で循環します。

00:04:33.000 -> 00:04:43.000
もちろん、2つ以上のフェーズと、後で実演する任意の数の追加ビュー修飾子を含むアニメーションを定義することもできます。

00:04:43.000 -> 00:04:46.000
今、ビューがアニメーション化している間、その効果は本当に微妙です。

00:04:46.000 -> 00:04:51.000
不透明度を変更する代わりに、フォアグラウンドスタイルを変更してみましょう。

00:04:51.000 -> 00:04:56.000
ハイライトされたときに赤を使用し、それ以外の場合は主要な前景スタイルにフォールバックします。

00:04:56.000 -> 00:05:01.000
そして、それははるかに目立ちます。しかし、アニメーションは少し唐突です。

00:05:01.000 -> 00:05:04.000
デフォルトでは、SwiftUIは春のアニメーションを使用します。

00:05:04.000 -> 00:05:11.000
また、スプリングは動的な状態の変化を処理するのに最適ですが、この場合、よりスムーズで一貫性のあるアニメーションが必要です。

00:05:11.000 -> 00:05:15.000
末尾の「アニメーション」クロージャを追加することで、アニメーションを変更できます。

00:05:15.000 -> 00:05:21.000
フェーズごとに異なるアニメーションを使用したい場合に備えて、アニメーション化されているフェーズが渡されます。

00:05:21.000 -> 00:05:28.000
しかし、この場合、私はいつも物事を遅くするために、カスタム期間のアニメーションで同じ使いやすさを使用したいと考えています。

00:05:28.000 -> 00:05:37.000
さて、アニメーションが終了するのを人々に待たせたくないので、通常、インタラクティブな状態変更のために1秒の持続時間を持つアニメーションを使用しません。

00:05:37.000 -> 00:05:45.000
しかし、この場合、私たちは周囲の効果を構築しているので、その食事を逃した場合の私のペースと同じように、物事が少し遅く動くのは大丈夫です。

00:05:45.000 -> 00:05:54.000
人種半ばの栄養の緊急の問題を解決したので、アニメーションフェーズを使用するもう1つの方法を見てみましょう。イベントによって引き起こされるアニメーションです。

00:05:54.000 -> 00:05:59.000
私はしばらくの間、自分のアプリに取り組んでいて、友達がどのレースを走ったかを見る機能を追加しました。

00:05:59.000 -> 00:06:01.000
絵文字は他の人が残した反応を示しています。

00:06:01.000 -> 00:06:05.000
すべてのランナーは時々自問します:なぜ私はこれをするのですか?

00:06:05.000 -> 00:06:08.000
なぜ私はそんなに多くのマイルを走るためにサインアップしたのですか?

00:06:08.000 -> 00:06:15.000
そして、私たちのアプリが少なくともできることは、他の誰かがレースが好きなときにいくつかの興奮を追加することによって、外部検証の必要性を満たすことです。

00:06:15.000 -> 00:06:20.000
誰かがリアクションを追加するたびに再生されるアニメーションを追加します。

00:06:20.000 -> 00:06:24.000
最初に行うことは、アニメーションのフェーズを定義することです。

00:06:24.000 -> 00:06:30.000
単に2つの状態を交互にした前の例とは異なり、より複雑なアニメーションが必要です。

00:06:30.000 -> 00:06:35.000
列挙型は、アニメーションのステップのリストを定義するのに最適な方法です。

00:06:35.000 -> 00:06:42.000
3つのケースを追加しました。最初の外観のケース、次にビューを上に移動し、ビューをスケールアップするケースです。

00:06:42.000 -> 00:06:49.000
ビュー本文を簡素化するために、適用するさまざまな効果を定義する計算されたプロパティをこの列挙型に追加します。

00:06:49.000 -> 00:06:56.000
アニメーション中にビューをジャンプさせたいので、計算された垂直オフセットプロパティを追加しました。

00:06:56.000 -> 00:07:00.000
列挙型を切り替えて、各ケースの正しいオフセットを返します。

00:07:00.000 -> 00:07:07.000
同様に、ビューのスケールとフォアグラウンドスタイルを決定するために、2つの計算プロパティを追加しました。

00:07:07.000 -> 00:07:13.000
ここでは実装を表示しませんが、垂直オフセットプロパティと同様にスイッチステートメントも使用します。

00:07:13.000 -> 00:07:17.000
では、ビューに戻ってアニメーションを追加しましょう。

00:07:17.000 -> 00:07:22.000
phaseAnimator修飾子を追加しますが、今回は「トリガー」値を与えます。

00:07:22.000 -> 00:07:28.000
フェーズアニメーター修飾子にトリガー値を与えると、変更に指定した値が観察されます。

00:07:28.000 -> 00:07:33.000
そして、変更が発生すると、指定したフェーズを通じてアニメーション化が開始されます。

00:07:33.000 -> 00:07:38.000
フェーズタイプで定義した計算されたプロパティを使用して、ビューに修飾子を適用します。

00:07:38.000 -> 00:07:41.000
そして、このアニメーションは技術的には正しいことをしますが、気分が良くありません。

00:07:41.000 -> 00:07:43.000
それは少し遅いです。

00:07:43.000 -> 00:07:50.000
いくつかの異なる春のアニメーションを含め、必要な効果を得るために、各トランジションのアニメーションをカスタマイズします。

00:07:50.000 -> 00:07:52.000
そして、これははるかに良く見えます!

00:07:52.000 -> 00:07:56.000
しかし、このアニメーションをさらに進めたい場合はどうなりますか?

00:07:56.000 -> 00:08:08.000
誰かがトレイルで50または100マイルを終えたとき、私たちは彼らがいくつかの当然の賞賛を受け取ったとき、それらのマイルのすべてがそれだけの価値があったことを彼らの心に疑いの余地のないアニメーションを与えたいと思います。

00:08:08.000 -> 00:08:13.000
さらに多くの制御が必要な場合は、もう1つの強力なツールがあります。キーフレームです。

00:08:13.000 -> 00:08:21.000
次に、キーフレームを使用して、タイミングと動きを完全に制御して複雑で調整されたアニメーションを定義する方法を紹介します。

00:08:21.000 -> 00:08:26.000
まず、キーフレームがこれまで使用したフェーズとどのように異なるかについて話しましょう。

00:08:26.000 -> 00:08:30.000
フェーズは、一度に1つずつビューに提供される離散状態を定義します。

00:08:30.000 -> 00:08:41.000
そして、SwiftUIは、あなたがすでに知っているのと同じアニメーションタイプを使用して、これらの状態間でアニメーション化し、これは離散状態としてモデル化できるアニメーションで本当にうまく機能します。

00:08:41.000 -> 00:08:46.000
状態遷移が発生すると、すべてのプロパティが同時にアニメーション化されます。

00:08:46.000 -> 00:08:50.000
そして、そのアニメーションが終了すると、SwiftUIは次の状態にアニメーション化されます。

00:08:50.000 -> 00:08:54.000
そして、これはアニメーションのすべての段階で続きます。

00:08:54.000 -> 00:08:57.000
しかし、各プロパティを個別にアニメーション化したい場合はどうなりますか?

00:08:57.000 -> 00:09:00.000
そこでキーフレームの出番です。

00:09:00.000 -> 00:09:04.000
キーフレームを使用すると、アニメーション内の特定の時間に値を定義できます。

00:09:04.000 -> 00:09:08.000
実演するために、回転効果から始めて、このビューをアニメーション化します。

00:09:08.000 -> 00:09:14.000
ここの点は、アニメーション中に各ポイントで使用する角度であるキーフレームを示しています。

00:09:14.000 -> 00:09:23.000
アニメーションが再生されると、SwiftUIはこれらのキーフレーム間の値を補間し、ビューに修飾子を適用するために使用できます。

00:09:23.000 -> 00:09:31.000
また、キーフレームを使用すると、それぞれに独自のタイミングを持つ別々のトラックを定義することで、複数のエフェクトを同時に独立してアニメーション化できます。

00:09:31.000 -> 00:09:36.000
キーフレームを使用してSwiftUIで任意の修飾子を駆動できるため、これは本当に強力です。

00:09:36.000 -> 00:09:43.000
この例では、キーフレームを使用して、垂直ストレッチ、スケール、翻訳など、他のいくつかのトラックを駆動しています。

00:09:43.000 -> 00:09:47.000
私たちの見解に戻って、これがコードでどのように見えるか見てみましょう。

00:09:47.000 -> 00:09:55.000
私はすでに構築したいアニメーションのアイデアを持っているので、私の最初のステップは、アニメーションを駆動するプロパティを定義することです。

00:09:55.000 -> 00:10:02.000
これを行うには、独立してアニメーション化されるすべての異なるプロパティを含む新しい構造体を作成します。

00:10:02.000 -> 00:10:06.000
キーフレームは、「Animatable」プロトコルに準拠した任意の値をアニメーション化できます。

00:10:06.000 -> 00:10:11.000
いくつかのプロパティが「Animatable」に準拠している「Double」を使用していることに注意してください。

00:10:11.000 -> 00:10:19.000
別々の離散状態をモデル化するフェーズとは異なり、キーフレームは指定したタイプの補間値を生成します。

00:10:19.000 -> 00:10:27.000
アニメーションが進行中の間、SwiftUIはビューを更新できるように、すべてのフレームにこのタイプの値を提供します。

00:10:27.000 -> 00:10:30.000
次に、キーフレームアニメーター修飾子を追加します。

00:10:30.000 -> 00:10:37.000
この修飾子は、以前に使用したフェーズアニメーターに似ていますが、キーフレームを受け入れます。

00:10:37.000 -> 00:10:42.000
初期値として使用する構造体のインスタンスを提供していることに注意してください。

00:10:42.000 -> 00:10:47.000
定義するキーフレームは、この値にアニメーションを適用します。

00:10:47.000 -> 00:10:52.000
次に、構造体上の各プロパティのビューに修飾子を適用します。

00:10:52.000 -> 00:10:55.000
そして最後に、キーフレームの定義を開始します。

00:10:55.000 -> 00:11:01.000
前述したように、キーフレームを使用すると、異なるプロパティに対して異なるキーフレームで洗練されたアニメーションを構築できます。

00:11:01.000 -> 00:11:05.000
これを可能にするために、キーフレームはトラックに編成されています。

00:11:05.000 -> 00:11:12.000
各トラックは、アニメーション化しているタイプの異なるプロパティを制御します。これは、トラックの作成時に提供するキーパスによって指定されます。

00:11:12.000 -> 00:11:17.000
ここでは、スケールプロパティのキーフレームを追加しています。

00:11:17.000 -> 00:11:23.000
まず、リニアキーフレームを追加し、初期スケール値を繰り返して0.36秒間保持します。

00:11:23.000 -> 00:11:33.000
そして、私が0.36にどのように落ち着いたのか疑問に思っているなら、私はアニメーションの感触を変えるために異なる値を試すことによってその期間を見つけました、そしてそれはキーフレームに関する重要なポイントです。

00:11:33.000 -> 00:11:37.000
あなたのアプリに合ったアニメーションを作るには、いくつかの実験が必要です。

00:11:37.000 -> 00:11:41.000
Xcodeのプレビューは、アニメーションを微調整するのに最適な方法です。

00:11:41.000 -> 00:11:44.000
次に、「SpringKeyframe」を追加します。

00:11:44.000 -> 00:11:48.000
これは、スプリング関数を使用して値をターゲットに引き寄せます。

00:11:48.000 -> 00:11:50.000
そして、私たちは期間を指定しました。

00:11:50.000 -> 00:11:56.000
期間が設定されたスプリングキーフレームの場合、これはスプリング関数がその期間の値のみをアニメーション化することを意味します。

00:11:56.000 -> 00:12:00.000
その後、次のキーフレームへの補間が始まります。

00:12:00.000 -> 00:12:06.000
最後に、スケールを1.0に戻す別のスプリングキーフレームを追加します。

00:12:06.000 -> 00:12:10.000
さまざまな種類のキーフレームは、値の補間方法を制御します。

00:12:10.000 -> 00:12:14.000
さて、私たちはLinearKeyframeとSpringKeyframeを見ました。

00:12:14.000 -> 00:12:17.000
実際には4種類のキーフレームがあります。

00:12:17.000 -> 00:12:25.000
それらがどのように異なるかを説明します。LinearKeyframeは、前のキーフレームからベクトル空間を直線的に補間します。

00:12:25.000 -> 00:12:33.000
SpringKeyframeは、その名前が示すように、spring関数を使用して、以前のキーフレームのターゲット値に補間します。

00:12:33.000 -> 00:12:39.000
CubicKeyframeは、キュービックベジエ曲線を使用してキーフレーム間を補間します。

00:12:39.000 -> 00:12:46.000
複数のキュービックキーフレームを順番に組み合わせると、結果の曲線はCatmull-Romスプラインに相当します。

00:12:46.000 -> 00:12:52.000
そして最後に、MoveKeyframeはすぐに補間なしで値にジャンプします。

00:12:52.000 -> 00:12:59.000
各種類のキーフレームは、完全な制御を提供するためにカスタマイズをサポートし、アニメーション内でさまざまな種類のキーフレームをミックスして一致させることができます。

00:12:59.000 -> 00:13:06.000
SwiftUIは、アニメーションが連続していることを確認するために、キーフレーム間の速度を維持します。

00:13:06.000 -> 00:13:12.000
私たちの見解に戻ると、次のトラックを追加する準備が整いました。

00:13:12.000 -> 00:13:17.000
ここでは、リニアキーフレームとスプリングキーフレームを使用して垂直変換をアニメーション化しました。

00:13:17.000 -> 00:13:21.000
景色が飛び上がる直前に、それは期待して後退します。

00:13:21.000 -> 00:13:26.000
私たちは、ビューが上がる前にビューを一時的に引き下げるスプリングキーフレームでそれをモデル化しました。

00:13:26.000 -> 00:13:32.000
これは良さそうですが、まだアニメーション化する2つのプロパティがあります。垂直ストレッチと回転です。

00:13:32.000 -> 00:13:37.000
垂直ストレッチから始めて、このためにキュービックキーフレームを使用します。

00:13:37.000 -> 00:13:45.000
繰り返しますが、これは正しくなるためにいくつかの試行錯誤を取ることができますが、キーフレームを使用してアニメーションをモデル化するさまざまな方法を試してみることを躊躇しないでください。

00:13:45.000 -> 00:13:50.000
スカッシュとストレッチは本当にこのアニメーションにもっと多くのエネルギーを与えます。

00:13:50.000 -> 00:13:53.000
最後に、ローテーションもアニメーション化します。

00:13:53.000 -> 00:13:55.000
そして、これは素晴らしく見えます。

00:13:55.000 -> 00:13:58.000
そして、私たちが以前に見たそれらの曲線?

00:13:58.000 -> 00:14:01.000
これらは、私たちが構築したばかりのアニメーションの視覚化です。

00:14:01.000 -> 00:14:04.000
追加のトラックを追加して、SwiftUI修飾子を適用できます。

00:14:04.000 -> 00:14:07.000
さまざまな組み合わせを探るのはとても楽しかったです。

00:14:07.000 -> 00:14:11.000
少し時間を取って、キーフレームのモデルを確認しましょう。

00:14:11.000 -> 00:14:13.000
キーフレームは事前定義されたアニメーションです。

00:14:13.000 -> 00:14:19.000
つまり、UIが流動的でインタラクティブであるべき状況では、通常のSwiftUIアニメーションに代わるものではありません。

00:14:19.000 -> 00:14:24.000
代わりに、再生できるビデオクリップのようなキーフレームを考えてください。

00:14:24.000 -> 00:14:27.000
彼らはあなたにたくさんのコントロールを与えますが、トレードオフがあります。

00:14:27.000 -> 00:14:38.000
アニメーションの進行方法を正確に指定しているため、キーフレームアニメーションはスプリングのように優雅にリターゲティングできないため、一般的にアニメーションの途中でキーフレームの変更を避けるのが最善です。

00:14:38.000 -> 00:14:44.000
キーフレームは、定義したタイプの値をアニメーション化し、ビューに修飾子を適用するために使用します。

00:14:44.000 -> 00:14:49.000
単一のキーフレームトラックを使用して、単一の修飾子、または異なる修飾子の組み合わせを駆動できます。

00:14:49.000 -> 00:14:51.000
それはあなた次第です。

00:14:51.000 -> 00:15:03.000
また、アニメーションは定義した値の観点から行われるため、更新はすべてのフレームで行われるため、キーフレームアニメーションをビューに適用している間は、高価な操作の実行を避ける必要があります。

00:15:03.000 -> 00:15:07.000
最後に、キーフレームでさらに多くのことができる方法を紹介します。

00:15:07.000 -> 00:15:12.000
私のアプリには、各脚のルートを示すレースマップが含まれています。

00:15:12.000 -> 00:15:16.000
自動的にズームインしてコースをたどるアニメーションを追加したい。

00:15:16.000 -> 00:15:22.000
ありがたいことに、MapKitでキーフレームを使ってカメラを動かすことができるようになりました。

00:15:22.000 -> 00:15:25.000
ここでは、コースを表示するために「マップ」ビューを使用しています。

00:15:25.000 -> 00:15:31.000
私の見解にはすでにルートがあり、これはレースの1つの脚に沿ったすべての座標を含むモデルです。

00:15:31.000 -> 00:15:36.000
ツアーを構築するには、州のプロパティとそれを変更するボタンを追加します。

00:15:36.000 -> 00:15:40.000
最後に、新しい「mapCameraKeyframeAnimator」修飾子を使用します。

00:15:40.000 -> 00:15:47.000
前の例でハートアイコンに使用したように、トリガー値を与え、キーフレームを追加します。

00:15:47.000 -> 00:15:52.000
トリガー値が変更されるたびに、マップはこれらのキーフレームを使用してアニメーション化します。

00:15:52.000 -> 00:15:57.000
キーフレームの最終値は、アニメーションの最後に使用されるカメラ値を決定します。

00:15:57.000 -> 00:16:02.000
最後に、ボタンを押すと、ツアーが始まります。

00:16:02.000 -> 00:16:09.000
ユーザーがアニメーション中にジェスチャーを実行すると、アニメーションは削除され、ユーザーはカメラを完全に制御できます。

00:16:09.000 -> 00:16:19.000
中心座標、方向、距離を独立してアニメーション化することで、このコースに沿ってスムーズにアニメーション化し、ズームアウトして俯瞰することができます。

00:16:19.000 -> 00:16:26.000
最後に、あなたが考えることができるあらゆる種類の効果をもたらすために、キーフレームを手動で評価する方法を実証したいと思います。

00:16:26.000 -> 00:16:29.000
「keyframeAnimator」の修飾子を見ました。

00:16:29.000 -> 00:16:35.000
修飾子以外では、「KeyframeTimeline」タイプを使用して、キーフレームとトラックのセットをキャプチャできます。

00:16:35.000 -> 00:16:43.000
このタイプを初期値で初期化し、ビュー修飾子と同様に、アニメーションを定義するキーフレームトラックを初期化します。

00:16:43.000 -> 00:16:50.000
KeyframeTimelineは、最も長いトラックの持続時間に等しい持続時間を与えるAPIを提供します。

00:16:50.000 -> 00:16:55.000
また、アニメーションの範囲内でいつでも値を計算できます。

00:16:55.000 -> 00:17:02.000
これにより、先ほど示した曲線の視覚化に使用したSwiftチャートでキーフレームを簡単に視覚化できます。

00:17:02.000 -> 00:17:19.000
これはまた、キーフレーム定義の曲線を好きなように使用したり、キーフレームを他のAPIと創造的に組み合わせたりできることを意味します。たとえば、ジオメトリプロキシを使用してスクロール位置を使用してキーフレーム駆動効果をスクラブしたり、「TimelineView」を使用して時間に基づいて更新したりできます。

00:17:19.000 -> 00:17:26.000
そして、いつこれを使用するかわからない場合、それは大丈夫です、それは高度なツールであり、ほとんどの開発者はビュー修飾子に固執したいと思うでしょう。

00:17:26.000 -> 00:17:33.000
しかし、それはビルディングブロックとしてここにあり、私はそれをあなたのアプリに統合するための創造的な方法を見つけることに興奮しています。

00:17:33.000 -> 00:17:35.000
それは私たちの旅を完成させます。

00:17:35.000 -> 00:17:38.000
この新しいAPIファミリーを使用することに興奮していることを願っています。

00:17:38.000 -> 00:17:42.000
覚えておいてください：連鎖アニメーションにはフェーズを使用してください。

00:17:42.000 -> 00:17:48.000
彼らはあなたがすでに知っている既存のアニメーションタイプをすべて使用しているので、すぐに起動して実行することができます。

00:17:48.000 -> 00:17:53.000
完全な制御が必要な、より複雑なアニメーションにキーフレームを使用してください。

00:17:53.000 -> 00:17:56.000
そして最後に、探検を楽しんでください。

00:17:56.000 -> 00:18:02.000
アニメーションの世界はエキサイティングで、これらの新しいツールがあなたとあなたのアプリをどこか新しい場所に導くことを願っています。

00:18:02.000 -> 00:18:04.000
ありがとう！

00:18:04.000 -> 23:59:59.000
♪ ♪

