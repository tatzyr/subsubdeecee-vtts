WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:15.000
ジョナサン：こんにちは、私はジョナサンで、インターネットテクノロジーチームのエンジニアです。

00:00:15.000 --> 00:00:23.000
今日は、URLSessionを使用して堅牢で再開可能なファイル転送を構築する方法を探ります。

00:00:23.000 --> 00:00:33.000
大規模なファイル転送は、小さな中断でもユーザーの進捗状況をすべて捨て、最初から強制的に開始させる可能性があるため、大きな課題になる可能性があります。

00:00:33.000 --> 00:00:44.000
さらに、転送が大きければ大きいほど、時間がかかり、時間がかかるほど、何かがうまくいかない機会が増えます。

00:00:44.000 --> 00:00:56.000
その間に、ユーザーはアプリから離れたり、Wi-Fiの範囲を離れたり、制御できないほど多くのネットワーク問題の1つを経験したりする可能性があります。

00:00:56.000 --> 00:01:04.000
このセッションでは、これらの課題を解決し、ユーザーに堅牢なネットワーキング体験を提供する方法を探ります。

00:01:04.000 --> 00:01:13.000
最初の停止は再開可能なHTTPプロトコルで、接続が中断されたときにユーザーが進行状況を維持できます。

00:01:13.000 --> 00:01:22.000
これにより、時間と帯域幅の無駄を防ぎ、これらのプロトコルは大量のデータを転送する際の強力なツールになります。

00:01:22.000 --> 00:01:31.000
再開可能なアップロードタスクのためのまったく新しいAPIを含む、URLSessionでダウンロードとアップロードの両方を再開する方法を実演します。

00:01:31.000 --> 00:01:40.000
これらのAPIの背後にあるメカニズムを理解することは、アプリをデバッグしたり、独自のサーバーサポートを構築したりするのに本当に役立ちます。

00:01:40.000 --> 00:01:50.000
そのため、再開可能なプロトコル自体もカバーするので、アプリとサーバーがHTTPを介してこれを達成する方法を正確に知ることができます。

00:01:50.000 --> 00:01:59.000
次に、サーバーといえば、SwiftNIOを使用するサーバーに再開可能なアップロードサポートを提供する方法を学びます。

00:01:59.000 --> 00:02:11.000
最後に、バックグラウンドURLSessionsがシステムリソースを効率的に利用しながら、ユーザーとネットワークの中断を適切に処理する方法を確認します。

00:02:11.000 --> 00:02:16.000
URLSessionでのダウンロードとアップロードの再開について詳しく学びましょう。

00:02:16.000 --> 00:02:23.000
だから私は最新のXcodeをダウンロードしていますが、7ギガバイトのダウンロードはほぼ終了しています。

00:02:23.000 --> 00:02:26.000
すぐ最後に、私のWi-Fiが切れます。

00:02:26.000 --> 00:02:37.000
しかし、待って、ダウンロードは一時停止され、Wi-Fiがオンラインに戻ったら、中断したところからダウンロードを再開できます。

00:02:37.000 --> 00:02:42.000
私はちょうど多くの時間といくつかのギグの帯域幅を節約しました。

00:02:42.000 --> 00:02:44.000
再開可能なダウンロードは素晴らしいです。

00:02:44.000 --> 00:02:47.000
しかし、それらはどのように機能しますか?

00:02:47.000 --> 00:02:53.000
まず、クライアントはサーバーからダウンロードを取得するためにGETリクエストを送信します。

00:02:53.000 --> 00:03:01.000
応答では、サーバーはAccept-Rangesヘッダーを使用して再開可能なダウンロードのサポートをアドバタイズします。

00:03:01.000 --> 00:03:09.000
Accept-Ranges: バイトは、サーバーがこのリソースの特定のバイトの範囲要求をサポートすることを意味します。

00:03:09.000 --> 00:03:17.000
サーバー応答には、現時点でリソースを一意に識別するETagと呼ばれるものも含まれています。

00:03:17.000 --> 00:03:22.000
サーバー上のコンテンツが変更された場合、ETagも変更されます。

00:03:22.000 --> 00:03:26.000
では、このダウンロードが中断された場合はどうなりますか?

00:03:26.000 --> 00:03:32.000
クライアントは部分的なダウンロードデータを保存しているので、最後の部分だけが必要です。

00:03:32.000 --> 00:03:39.000
これを達成するために、ダウンロードの不足しているバイトを取得するための範囲要求を送信できます。

00:03:39.000 --> 00:03:44.000
リクエストは、Rangeフィールドを使用するバイトを示します。

00:03:44.000 --> 00:03:55.000
しかし、クライアントはまた、リソースが変更されていないことを確認する必要があります。そうしないと、保存されている古いリソースに新しいリソースからデータを追加します。

00:03:55.000 --> 00:04:09.000
これを防ぐために、If-Rangeフィールドには、以前の応答から受信したETagが含まれており、ETagが同じ場合にのみ部分的なデータを送信するようにサーバーに指示します。

00:04:09.000 --> 00:04:15.000
ETagが同じ場合、サーバーは206の部分コンテンツで応答します。

00:04:15.000 --> 00:04:24.000
ここのContent-Rangeフィールドは、この応答に含まれるバイトの範囲を示し、ダウンロードを完了します。

00:04:24.000 --> 00:04:32.000
当初から、URLSessionはRangeリクエストを使用してダウンロードタスクを一時停止および再開するAPIを提供してきました。

00:04:32.000 --> 00:04:35.000
これで、アップロードを一時停止して再開することもできます。

00:04:35.000 --> 00:04:49.000
これにより、進行中のタスクを手動で一時停止できるだけでなく、エラー処理を実行して予期しない接続の問題から回復し、中断したところから転送を再開することもできます。

00:04:49.000 --> 00:04:53.000
まず、これがダウンロードのためにどのように機能するかを確認しましょう。

00:04:53.000 --> 00:05:00.000
ユーザーが手動でダウンロードを一時停止して再開できるUIを作成していると想像してみてください。

00:05:00.000 --> 00:05:14.000
Safariの例のように、アプリはこのUIを所有していますが、内部では、URLSessionを使用して、部分的なダウンロードデータ、ETag、リクエストヘッダーの追跡など、すべての詳細を処理できます。

00:05:14.000 --> 00:05:21.000
ダウンロードを開始するには、通常どおりダウンロードタスクを作成し、resumeを呼び出して開始します。

00:05:21.000 --> 00:05:30.000
ユーザーが一時停止ボタンをタップしたときなど、ダウンロードを一時停止するには、cancelByProducingResumeDataを呼び出すことができます。

00:05:30.000 --> 00:05:41.000
後でこのダウンロードを再開するには、URLSessionには、ETag、現在のサイズ、ディスク上の場所など、部分的なダウンロードに関する情報が必要になります。

00:05:41.000 --> 00:05:49.000
これと他のメタデータは、この関数から返された履歴書データオブジェクトに便利に保存されます。

00:05:49.000 --> 00:05:55.000
繰り返しますが、この履歴書データは部分的なダウンロードデータではないことに注意することが重要です。

00:05:55.000 --> 00:06:05.000
履歴書データがゼロの場合、これは再開可能なダウンロードの1つ以上の要件が満たされていないことを意味し、すぐに説明します。

00:06:05.000 --> 00:06:11.000
一方、履歴書データがゼロでない場合は、後で使用するために保存する必要があります。

00:06:11.000 --> 00:06:22.000
これは、ユーザーが再開ボタンをタップしたときのように、ダウンロードを再開するには、この保存されたデータをdownloadTask withResumeDataメソッドに渡すためです。

00:06:22.000 --> 00:06:24.000
それはそれと同じくらい簡単です!

00:06:24.000 --> 00:06:34.000
このパターンは手動でダウンロードを一時停止するのに最適ですが、URLSessionは予測されない接続の中断から回復する方法も提供します。

00:06:34.000 --> 00:06:42.000
ネットワークの問題でダウンロードタスクが失敗した場合は、エラー自体で再開データを確認できます。

00:06:42.000 --> 00:06:49.000
ダウンロードを再開できる場合、エラーのuserInfo辞書にはその再開データが含まれます。

00:06:49.000 --> 00:06:56.000
URLErrorのdownloadTaskResumeDataプロパティを使用して、このデータに便利にアクセスできます。

00:06:56.000 --> 00:07:02.000
URLSessionで再開可能なダウンロードにはいくつかの要件があります。

00:07:02.000 --> 00:07:12.000
ダウンロードは本質的にデータを取得し、繰り返しても安全である必要があるため、URLSessionではダウンロードタスクにHTTP GETリクエストが必要です。

00:07:12.000 --> 00:07:15.000
他のスキームや方法はサポートされていません。

00:07:15.000 --> 00:07:23.000
次に、サーバーはバイト範囲の要求をサポートし、Accept-Rangesヘッダーを使用してこれをアドバタイズする必要があります。

00:07:23.000 --> 00:07:32.000
サーバーは、応答のリソースにETagまたはLast-Modifiedフィールドを提供する必要がありますが、ETagが優先されます。

00:07:32.000 --> 00:07:41.000
そして最後に、一時的なダウンロードファイルは、ディスク容量の圧力に応じてシステムによって削除されてはなりません。

00:07:41.000 --> 00:07:50.000
これらの要件があれば、手動でダウンロードを一時停止して再開したり、接続の中断から回復したりできます。

00:07:50.000 --> 00:07:58.000
再開プロトコルがなければ、小さな中断でも最初から転送を再起動することを余儀なくされます。

00:07:58.000 --> 00:08:02.000
これはアップロードにとってさらに大きな問題です。

00:08:02.000 --> 00:08:09.000
アップロード速度は多くの場合、ダウンロード速度よりもはるかに遅いため、再起動すると、時間とリソースがさらに失われます。

00:08:09.000 --> 00:08:14.000
iOS 17では、再開可能なアップロードタスクに対するまったく新しいサポートが導入されています。

00:08:14.000 --> 00:08:16.000
私はこれらにとても興奮しています。

00:08:16.000 --> 00:08:23.000
現在、サーバーが最新のプロトコルドラフトをサポートしている場合、アップロードタスクは自動的に再開できます。

00:08:23.000 --> 00:08:30.000
まず新しいAPIを調べてから、再開可能なアップロードプロトコルの詳細に飛び込みましょう。

00:08:30.000 --> 00:08:36.000
ダウンロードタスクと同様に、アップロードタスクを作成し、履歴書を呼び出して開始するだけです。

00:08:36.000 --> 00:08:45.000
一時停止するには、アップロードタスクがダウンロードタスクと同じcancelByProducingResumeDataメソッドをサポートするようになりました。

00:08:45.000 --> 00:08:51.000
このタスクは、サーバーが最新の再開可能なアップロードプロトコルをサポートしているかどうかを自動的に検出します。

00:08:51.000 --> 00:08:58.000
サーバーがそれをサポートしている場合は、後で使用するために履歴書データを保存できます。

00:08:58.000 --> 00:09:05.000
そして最後に、一時停止したアップロードを再開するには、新しいuploadTask withResumeDataメソッドを使用します。

00:09:05.000 --> 00:09:10.000
ここに示されているパターンがダウンロードタスクと同じであることに気付くでしょう。

00:09:10.000 --> 00:09:21.000
つまり、アプリでダウンロードを一時停止および再開するための素晴らしいエクスペリエンスをすでに作成している場合は、ユーザーの再開可能なアップロードも簡単に実装できます。

00:09:21.000 --> 00:09:30.000
一時的なネットワークの中断があるだけで、サーバーにまだ到達可能な場合、URLSessionは自動的にアップロードを再開しようとします。

00:09:30.000 --> 00:09:33.000
追加のコードは必要ありません。

00:09:33.000 --> 00:09:44.000
しかし、ネットワークやサーバーが完全にダウンした場合など、他のより広範な接続の問題が発生した場合は、ダウンロードタスクと同様に、再開データのエラーを確認できます。

00:09:44.000 --> 00:09:50.000
URLSessionで再開可能なアップロードを見て非常にうれしく思います。あなたもそれらを愛することを願っています。

00:09:50.000 --> 00:09:59.000
しかし、この機能を利用するには、サーバーが最新の再開可能なアップロードプロトコルもサポートしている必要があります。

00:09:59.000 --> 00:10:07.000
このプロトコルは現在開発中であり、IETFで標準化するための業界全体の取り組みがあります。

00:10:07.000 --> 00:10:12.000
プロトコルでは、クライアントはサーバーのサポートを自動的に検出できます。

00:10:12.000 --> 00:10:19.000
これは、URLSessionが最初のリクエストですべてのアップロードを再開可能にできることを意味します。

00:10:19.000 --> 00:10:27.000
サーバーが再開可能なアップロードをサポートしていない場合、リクエストは単に通常のアップロードとして継続されます。

00:10:27.000 --> 00:10:30.000
ワイヤーでどのように機能するか見てみましょう。

00:10:30.000 --> 00:10:34.000
クライアントは最初にアップロードエンドポイントにリクエストを送信します。

00:10:34.000 --> 00:10:40.000
Upload-Incompleteフィールドは、このクライアントが再開可能なアップロードをサポートしていることを示します。

00:10:40.000 --> 00:10:48.000
疑問符ゼロは、構造化フィールドブール値と呼ばれるもので、値falseを表します。

00:10:48.000 --> 00:10:55.000
これは、すべてのアップロードデータがこのリクエストの本文に含まれていることを意味します。

00:10:55.000 --> 00:11:05.000
サーバーが再開可能なアップロードをサポートしている場合、クライアントのヘッダーを検出し、104情報応答を使用して独自のサポートをアドバタイズします。

00:11:05.000 --> 00:11:11.000
104レスポンスには、履歴書URL付きのロケーションフィールドが含まれています。

00:11:11.000 --> 00:11:20.000
この再開URLは、アップロードを一意に識別するために使用されるため、接続が中断された場合、クライアントはアップロードを再開する場所を知っています。

00:11:20.000 --> 00:11:28.000
サーバーは、受信したアップロードデータをこの一意の再開URLに関連付けます。

00:11:28.000 --> 00:11:31.000
アップロードが中断することなく終了すれば、素晴らしいことです。

00:11:31.000 --> 00:11:35.000
サーバーは201を送信し、完了です。

00:11:35.000 --> 00:11:44.000
ただし、アップロードが中断された場合、クライアントとサーバーは再開可能なアップロード手順を実行します。

00:11:44.000 --> 00:11:53.000
サーバーは履歴書URLの部分的なアップロードを保存しましたが、クライアントはサーバーが実際に取得したデータ量を判断する方法が必要です。

00:11:53.000 --> 00:12:01.000
これを行うには、クライアントは履歴書URLにHEADリクエストを送信し、サーバーにアップロードオフセットを要求します。

00:12:01.000 --> 00:12:07.000
このオフセットは、サーバーが受信した真のバイト数です。

00:12:07.000 --> 00:12:13.000
次に、サーバーはクライアントの特定のアップロードのアップロードオフセットで応答します。

00:12:13.000 --> 00:12:20.000
そして最後に、クライアントはサーバーのオフセットを確認し、残りのデータを送信する必要があります。

00:12:20.000 --> 00:12:28.000
これを行うには、クライアントは一致するアップロードオフセットで履歴書URLにPATCHリクエストを送信します。

00:12:28.000 --> 00:12:35.000
このリクエストの本文には、指定されたオフセットから始まるアップロードデータが含まれています。

00:12:35.000 --> 00:12:42.000
これで、クライアントは最終的にすべてのデータをサーバーに送信し、アップロードを完了しました。

00:12:42.000 --> 00:12:46.000
あなたのアプリは、URLSessionのアップロードタスクを使用して、これらすべてを無料で入手できます。

00:12:46.000 --> 00:12:56.000
それでは、サーバー側に簡単に移動して、SwiftNIOを使用して独自の再開可能なアップロードサーバーを構築する方法を探りましょう。

00:12:56.000 --> 00:13:02.000
すでにサーバーでSwiftNIOを使用している方のために、このセクションはあなたのためです。

00:13:02.000 --> 00:13:12.000
再開可能なアップロードはどのサーバーでも実装できますが、サーバーがすでにSwiftNIOを使用している場合は、サポートを簡単に追加できる新しいパッケージがあります。

00:13:12.000 --> 00:13:15.000
簡単な例を見てみましょう。

00:13:15.000 --> 00:13:24.000
馴染みがない場合は、SwiftNIOはアプリとサーバーで動作する非同期ネットワークアプリケーションフレームワークです。

00:13:24.000 --> 00:13:29.000
このサンプルコードでは、HTTP/2サーバーを設定しています。

00:13:29.000 --> 00:13:33.000
サーバーに2つのハンドラーを追加しました。

00:13:33.000 --> 00:13:40.000
コーデックは、HTTP/2フレームをハンドラーの例が理解できる要求に変換します。

00:13:40.000 --> 00:13:48.000
他の方向では、サンプルハンドラからの応答を受け取り、それらをHTTP/2フレームにコード化します。

00:13:48.000 --> 00:13:54.000
ExampleChannelHandlerは、サーバーの基本的なルーティングとロジックを実行します。

00:13:54.000 --> 00:13:58.000
最初は、定期的なアップロードのみをサポートしています。

00:13:58.000 --> 00:14:06.000
再開可能なアップロードをサポートするためにサーバーを変換するのがどれほど簡単か調べてみましょう。

00:14:06.000 --> 00:14:14.000
まず、NIOResumableUploadプロジェクトをダウンロードし、依存関係として追加し、コードにインポートします。

00:14:14.000 --> 00:14:19.000
次に、再開可能なアップロードコンテキストを定義します。

00:14:19.000 --> 00:14:25.000
これは、再開URLを生成するときに使用するエンドポイントをアップロードするハンドラーに指示します。

00:14:25.000 --> 00:14:32.000
そして最後に、現在のハンドラをHTTPResumableUploadHandlerでラップします。

00:14:32.000 --> 00:14:38.000
これは、現在のロジックの上に再開可能なアップロード手順を実行します。

00:14:38.000 --> 00:14:46.000
アップロードごとに、ランダムで安全な履歴書URLを生成し、これをアップロードデータに関連付けます。

00:14:46.000 --> 00:14:55.000
接続が中断された場合、ハンドラーは部分的なデータを保持し、すべての再開可能なアップロード手順に応答します。

00:14:55.000 --> 00:14:57.000
うわー！

00:14:57.000 --> 00:15:03.000
わずか数行のコードで、再開可能なアップロードをサポートするためにサーバーをスーパーチャージしました。

00:15:03.000 --> 00:15:08.000
すでにサーバーでSwiftを使用している方は、これを試してみてください!

00:15:08.000 --> 00:15:13.000
そして、すべての人のために、説明のリンクからオープンソースのサンプルコードを必ずチェックしてください。

00:15:13.000 --> 00:15:23.000
サンプルコードでは、新しいHTTPタイプも使用します。これにより、アプリとSwift on Serverプロジェクトで同じタイプを使用できます。

00:15:23.000 --> 00:15:34.000
これらのデータタイプは、SwiftNIOと共同でオープンソースパッケージとしてリリースされたので、Swiftブログをチェックして詳細を確認し、フィードバックを提供してください。

00:15:34.000 --> 00:15:42.000
再開可能なアップロードプロトコルが104ステータスコードを使用して情報応答を使用していることに気づいたかもしれません。

00:15:42.000 --> 00:15:48.000
新しいHTTPタイプにより、サーバー側でこれらの応答を簡単にサポートできます。

00:15:48.000 --> 00:15:55.000
アプリでは、URLSessionは再開可能なアップロードの104応答を自動的に処理します。

00:15:55.000 --> 00:16:02.000
しかし、それに加えて、URLSessionはデリゲートメソッドdidReceiveInformationalResponseを提供するようになりました。

00:16:02.000 --> 00:16:10.000
これにより、アプリは102 Processingや103 Early Hintsなどの他の中間応答を処理できます。

00:16:10.000 --> 00:16:17.000
再開可能なプロトコルは、ネットワークの中断を軽減し、帯域幅を節約するための素晴らしい方法です。

00:16:17.000 --> 00:16:23.000
バックグラウンドURLSessionは、大規模なファイル転送を処理する場合にも役立ちます。

00:16:23.000 --> 00:16:29.000
ユーザーが最新のスキー旅行から巨大な4Kビデオをアップロードしたいと想像してみてください。

00:16:29.000 --> 00:16:35.000
接続が中断された場合は、可能であればアップロードを再開してください。

00:16:35.000 --> 00:16:37.000
すべてのエラー処理は自分で行うことができます。

00:16:37.000 --> 00:16:42.000
または、バックグラウンドセッションに任せることもできます。

00:16:42.000 --> 00:16:51.000
実際、バックグラウンドセッションは、サーバーがサポートしている場合、ダウンロードとアップロードの両方のタスクの再開を自動的に処理します。

00:16:51.000 --> 00:16:59.000
タスクが中断された場合、システムは増加する時間間隔でタスクを再開しようとします。

00:16:59.000 --> 00:17:07.000
タスクを再開できない場合、システムは自動的に最初からタスクを再試行します。

00:17:07.000 --> 00:17:13.000
おそらく、あなたのユーザーはスキー山で携帯電話のカバレッジを失うか、吹雪が彼らのWi-Fiを取り出しました。

00:17:13.000 --> 00:17:23.000
バックグラウンドセッションは常に接続を待つため、デバイスが再びインターネットに接続した後、ある時点でタスクがスケジュールされます。

00:17:23.000 --> 00:17:29.000
ユーザーがビデオをアップロードしている間、彼らはあなたのアプリを離れるか、デバイスを片付けるかもしれません。

00:17:29.000 --> 00:17:36.000
たぶん、彼らはより多くの粉末を細断する準備をしていて、彼らはまだ彼らのアップロードが続くことを期待しています。

00:17:36.000 --> 00:17:40.000
これは特にバックグラウンドセッションを必要とします。

00:17:40.000 --> 00:17:46.000
バックグラウンドタスクはシステムによってスケジュールされるため、アプリのプロセスの外で実行されます。

00:17:46.000 --> 00:17:53.000
これは、アプリがシステムによって一時停止または終了された場合でも、ネットワークタスクは確実に継続することを意味します。

00:17:53.000 --> 00:18:02.000
長い時間がかかり、ユーザーがアプリを離れるときに持続する必要がある大きなファイル転送には、バックグラウンドセッションを使用します。

00:18:02.000 --> 00:18:11.000
最後に、あなたのユーザーはアプリにいるときに最高の経験に値し、それは後で発生する緊急の少ないタスクをスケジュールすることを意味するかもしれません。

00:18:11.000 --> 00:18:20.000
バックグラウンドセッションを使用すると、ネットワークアクティビティを効率的にスケジュールし、ユーザーのリソースを節約する方法がいくつかあります。

00:18:20.000 --> 00:18:29.000
すぐに実行する必要のないタスクについては、バックグラウンド設定でisDiscretionaryプロパティをtrueに設定することを検討してください。

00:18:29.000 --> 00:18:41.000
これにより、システムは「ユーザーはWi-Fiに接続していますか」、「デバイスは電源に接続されていますか」、「ネットワークは制限されていますか」などの要因を考慮して、タスクをインテリジェントにスケジュールすることができます。

00:18:41.000 --> 00:18:49.000
これは、後で使用するためにアセットをダウンロードしたり、毎晩のバックアップや分析をアップロードしたりするときに素晴らしいオプションになります。

00:18:49.000 --> 00:18:58.000
低データモードで帯域幅を使いすぎないようにするには、allowsConstrainedNetworkAccessプロパティをfalseに設定することを検討してください。

00:18:58.000 --> 00:19:06.000
アプリで低データモードをサポートするためのヒントについては、Advances in Networkingセッションをご覧ください。

00:19:06.000 --> 00:19:15.000
また、バックグラウンドタスク自体を、人がシステムリソースを使用する可能性が低いときに、後で開始するようにスケジュールすることもできます。

00:19:15.000 --> 00:19:22.000
深夜は、多くの場合、大規模なバックアップなどのタスクをスケジュールするのに最適な時間です。

00:19:22.000 --> 00:19:30.000
システムのスケジューリングをさらに支援するために、countOfBytesClientExpectsToSendとReceiveのプロパティを設定できます。

00:19:30.000 --> 00:19:39.000
これらのプロパティを利用することで、システムにリソースを最適に割り当て、それらの利点をユーザーに渡すことができます。

00:19:39.000 --> 00:19:49.000
バックグラウンドセッションは、すぐに行う必要のない大規模なファイル転送や、アプリが一時停止されたときに継続すべき転送に最適なツールです。

00:19:49.000 --> 00:19:56.000
小規模なタスク、またはできるだけ早く実行する必要があるタスクには、標準のURLSessionを使用できます。

00:19:56.000 --> 00:20:02.000
アプリに再開の力をもたらすことで、ユーザーにとってネットワークを信頼できるものにします。

00:20:02.000 --> 00:20:11.000
SwiftNIOとHTTPタイプをチェックして、Swiftで最高のHTTPエクスペリエンスを作成するために協力しましょう。

00:20:11.000 --> 00:20:18.000
そして最後に、大規模または裁量的なファイル転送にバックグラウンドセッションを使用してみてください。

00:20:18.000 --> 00:20:23.000
ユーザーが最も必要とするときにリソースを節約する方法はたくさんあります。

00:20:23.000 --> 00:20:29.000
ご覧いただきありがとうございます。以下の他の素晴らしいネットワーキングセッションを必ずチェックしてください。

00:20:29.000 --> 00:20:31.000
そして、それはラップです!

00:20:31.000 --> 23:59:59.000
♪ ♪

