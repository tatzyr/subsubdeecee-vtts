WEBVTT

00:00:00.000 -> 00:00:13.000
こんにちは！私の名前はジャクソンです。

00:00:13.000 -> 00:00:14.000
そして私はデビッドです。

00:00:14.000 -> 00:00:21.000
このセッションでは、この分野でHDR画像と最近公開された標準に関する背景を提供します。

00:00:21.000 -> 00:00:27.000
次に、新規および既存のAPIを使用してアプリでこれらの画像をサポートする方法について説明します。

00:00:27.000 -> 00:00:37.000
デビッドはHDR画像パイプラインの処理の詳細に飛び込み、ハイダイナミックレンジコンテンツの表示に関するいくつかのより高度なトピックをまとめます。

00:00:37.000 -> 00:00:40.000
HDRの仕組みについて掘り下げてみましょう。

00:00:40.000 -> 00:00:47.000
物理的な世界では、私たちの目が適応する能力のおかげで、人間は膨大な範囲の光レベルを知覚することができます。

00:00:47.000 -> 00:00:54.000
対照的に、典型的な標準ダイナミックレンジ、またはSDRディスプレイは、限られた範囲の光しか生成できません。

00:00:54.000 -> 00:01:01.000
これは、シーンの画像がキャプチャされると、広い範囲の光レベルを何らかの形でより小さなSDR範囲に圧縮する必要があります。

00:01:01.000 -> 00:01:08.000
ハイダイナミックレンジ、またはHDRディスプレイを使用すると、それらを圧縮することなく、はるかに広い範囲の光レベルを表示できます。

00:01:08.000 -> 00:01:14.000
これにより、元のシーンに似ており、より明るく、より鮮やかな画像を表示できます。

00:01:14.000 -> 00:01:23.000
私たちは長年にわたってハイダイナミックレンジをキャプチャする能力を持っていましたが、過去には、そのキャプチャ範囲を取り、SDR表示範囲に圧縮する必要がありました。

00:01:23.000 -> 00:01:29.000
これで、HDRディスプレイに表示すると、シーンを元のようにレンダリングできます。

00:01:29.000 -> 00:01:37.000
例えば、スノーシーンの上の日の出のこの画像では、現実世界の光レベルの広い範囲に落ちる領域があります。

00:01:37.000 -> 00:01:41.000
SDRディスプレイでは、シーンの一部のみを正確に表現できます。

00:01:41.000 -> 00:01:48.000
HDRディスプレイを使用すると、コントラストを損なうことなく、はるかに多くのシーンを表現できます。

00:01:48.000 -> 00:01:54.000
したがって、HDR範囲のディスプレイを使用すると、シーンの一部を最も明るいSDRホワイトよりも明るくレンダリングできます。

00:01:54.000 -> 00:01:58.000
これは一般的にヘッドルームと呼ばれています。

00:01:58.000 -> 00:02:02.000
このパラダイムでは、リファレンスホワイトはSDRディスプレイが生成した最も明るいホワイトです。

00:02:02.000 -> 00:02:05.000
その点を超えるものはヘッドルームです。

00:02:05.000 -> 00:02:15.000
過去の講演では、HDR対応ディスプレイのヘッドルームでレンダリングできるコンテンツと対話するために、拡張ダイナミックレンジ（EDR）を導入しました。

00:02:15.000 -> 00:02:22.000
EDRパラダイムでは、参照白は1.0で、ピークはディスプレイが表すことができる最大値です。

00:02:22.000 -> 00:02:29.000
今日紹介するHDR APIは、EDRを使用して、ハイダイナミックレンジコンテンツのより完全なパイプラインを実装しています。

00:02:29.000 -> 00:02:35.000
EDRについてもっと知りたい場合は、「EDRでHDRレンダリングを探索する」トークをチェックしてください。

00:02:35.000 -> 00:02:37.000
これは、動作中のHDRの例です。

00:02:37.000 -> 00:02:44.000
窓の前に座っている人のこのSDR画像は、本の中の紙の白が参考白のすぐ下にあるときによく見えます。

00:02:44.000 -> 00:02:49.000
窓など、より明るいものは、転がされたり、クリップされたりします。

00:02:49.000 -> 00:02:57.000
ただし、HDRで画像を表示できる場合は、ハイライトでより多くの詳細を表示し、シーン全体でコントラストをより確実に維持できます。

00:02:57.000 -> 00:03:01.000
これは、HDRをサポートすることで得られる利点です。

00:03:01.000 -> 00:03:10.000
では、なぜHDR画像をサポートするのですか?ユーザーが作成または提供したコンテンツが重要なアプリを構築している場合、HDRをサポートすると、その体験がさらに良くなります。

00:03:10.000 -> 00:03:22.000
HDRサポートはほぼすべてのAppleプラットフォームで利用でき、Appleの信じられないほどのディスプレイハードウェアを最大限に活用できるように、これらのAPIを導入しました。

00:03:22.000 -> 00:03:35.000
現在HDRサポートを検討するもう1つの重要な理由は、Appleが写真技術委員会を通じて国際標準化機構と協力して、今年HDR画像の新しい技術仕様を公開していることです。

00:03:35.000 -> 00:03:46.000
この仕様であるTS22028-5は、品質を損なうことなく、HDRコンテンツを既存の静止画フォーマットにエンコードする構造を提供します。

00:03:46.000 -> 00:03:58.000
HDRビデオ、キャプチャ、ディスプレイなどの他の形式のHDRとの混同を避けるために、このISO仕様に従うHDR画像を「ISO HDR」と呼びます。

00:03:58.000 -> 00:04:08.000
sRGBとディスプレイP3を含む以前の典型的なSDR画像からスケールを想起し、白黒を1平方メートルあたり0.2と80カンデラと定義します。

00:04:08.000 -> 00:04:16.000
一方、ISO HDRは、黒とデフォルトの参照白をそれぞれ.0005と203と定義しています。

00:04:16.000 -> 00:04:20.000
203を超えるものはすべてヘッドルームです。

00:04:20.000 -> 00:04:23.000
では、これらの新しい画像ファイルには何がありますか?

00:04:23.000 -> 00:04:31.000
この仕様では、エンコーディング転送機能として、Hybrid Log-Gamma、HLG、またはPerceptual Quantizer、PQが必要です。

00:04:31.000 -> 00:04:36.000
これらは、SDR画像で使用されるガンマ曲線に機能的に類似しています。

00:04:36.000 -> 00:04:40.000
ISO HDRファイルのカラープライマリーはBT.2020プライマリーです。

00:04:40.000 -> 00:04:45.000
これは広い色域で、これまではビデオでしか一般的に使用されませんでした。

00:04:45.000 -> 00:04:50.000
バンディングの問題を避けるために、HDR画像はコンポーネントごとに10ビット以上である必要があります。

00:04:50.000 -> 00:05:02.000
これは、HEIFのような一部のフォーマットはHDRをエンコードできますが、従来のJPEGのような他のフォーマットは、コンポーネントごとに8ビットしかサポートしていないため、22028-5に準拠できないことを意味します。

00:05:02.000 -> 00:05:08.000
また、必要なメタデータについては、従来のICCプロファイルとCICPタグの両方が有効です。

00:05:08.000 -> 00:05:12.000
これらの要件は、新しいISO HDRファイルを定義します。

00:05:12.000 -> 00:05:18.000
あなたに関連する可能性のあるISO HDRファイルに関連付けられている追加のオプションのメタデータフィールドがいくつかあります。

00:05:18.000 -> 00:05:25.000
参照環境タグは、コンテンツ参照条件の環境条件を定義します。

00:05:25.000 -> 00:05:29.000
拡散白色輝度は、参照白色がこのコンテンツのどこに該当するかを定義します。

00:05:29.000 -> 00:05:33.000
デフォルトは先ほど述べた203です。

00:05:33.000 -> 00:05:36.000
シーン参照タグは、HLGが転送曲線である場合に使用できます。

00:05:36.000 -> 00:05:40.000
画像コンテンツがシーンかディスプレイかを定義します。

00:05:40.000 -> 00:05:44.000
このタグのデフォルト値は表示参照です。

00:05:44.000 -> 00:05:52.000
マスタリングとコンテンツのカラーボリュームタグは、既存のHDRビデオに共通しており、画像に存在する色範囲に関する情報を定義します。

00:05:52.000 -> 00:05:59.000
最後に、コンテンツライトレベルタグは、画像内のシーンのライトレベルに関する情報を提供します。

00:05:59.000 -> 00:06:04.000
ISO HDRの詳細については、ISOのウェブサイトで仕様を確認してください。

00:06:04.000 -> 00:06:13.000
ISO HDRに加えて、iPhoneでキャプチャされた画像のベストバージョンにアクセスする方法を初めてお伝えできることを非常に嬉しく思います。

00:06:13.000 -> 00:06:22.000
2020年以来、数兆枚のiPhone画像が、SDR画像からHDR表現を再構築できる追加データでキャプチャされました。

00:06:22.000 -> 00:06:27.000
私はこのタイプのHDRを「ゲインマップHDR」と呼んでいます。

00:06:27.000 -> 00:06:41.000
今日、デビッドと私は、あなたのアプリでこのHDR表現にアクセスするための新しいAPIを紹介し、すでにあなたの写真ライブラリにある任意の世代のゲインマップHDRから信じられないほどのHDR画像を表示するオプションを提供します。

00:06:41.000 -> 00:06:46.000
では、これらの新しいAPIを使用してHDR画像をアプリに組み込む方法について話しましょう。

00:06:46.000 -> 00:06:51.000
お見せするAPIは、SwiftUI、UIKit、AppKitで利用できます。

00:06:51.000 -> 00:06:54.000
SwiftUIとUIKit APIを見てみましょう。 

00:06:54.000 -> 00:07:00.000
この例では、URL経由でアクセスできるISO HDR画像ファイルがあり、それを表示したいです。

00:07:00.000 -> 00:07:09.000
私がしなければならないのは、UIImageを作成し、ハイダイナミックレンジを有効にするための新しい許可されたDynamicRange修飾子と一緒にイメージビューに提供することだけです。

00:07:09.000 -> 00:07:12.000
それはとても簡単です。

00:07:12.000 -> 00:07:21.000
同様に、UIKitアプリでは、新しいUIImageViewプロパティ「preferredImageDynamicRange」と、HDR結果を設定できます。

00:07:21.000 -> 00:07:26.000
ダイナミックレンジのプロパティには、HDRコンテンツの処理方法に関する3つのオプションが含まれています。

00:07:26.000 -> 00:07:31.000
これらのプロパティは、SwiftUI Image、UIImage、およびNSImageビューで動作します。

00:07:31.000 -> 00:07:44.000
ハイオプションは、ハイダイナミックレンジのコンテンツを表示したいことをシステムに知らせ、表示状態が変更されたときの更新を含め、そのコンテンツを現在のディスプレイにマッピングする重い作業を行うことができます。

00:07:44.000 -> 00:07:50.000
画像がHDRでない場合は、dynamicRangeフラグがない場合とまったく同じエクスペリエンスが得られることに注意してください。

00:07:50.000 -> 00:07:54.000
これらのオプションは、HDR以外のコンテンツで安全に使用できます。

00:07:54.000 -> 00:08:01.000
標準オプションは、ハイダイナミックレンジレンダリングを無効にし、代わりにすべてのコンテンツをSDRとして表示します。

00:08:01.000 -> 00:08:05.000
これは、SDR範囲外のトーンマッピングコンテンツを意味します。

00:08:05.000 -> 00:08:11.000
これは、HDR機能のないディスプレイに画像が表示される方法でもあります。

00:08:11.000 -> 00:08:18.000
最後に、いくつかのHDRを表示したいが、コンテンツの全範囲を表示しない場合は、constrainedHighオプションを使用する必要があります。

00:08:18.000 -> 00:08:22.000
なぜ、すべてではなく、いくつかのHDRだけを表示したいのですか?

00:08:22.000 -> 00:08:25.000
さて、考えられる理由はいくつかあります。

00:08:25.000 -> 00:08:29.000
この例では、多くの画像のサムネイルを含むスタックビューがあります。

00:08:29.000 -> 00:08:32.000
これらの画像の中にはHDRであるものもあれば、そうでないものもあります。

00:08:32.000 -> 00:08:36.000
私が高いDynamicRangeオプションを使用すると、これはあなたが得るものです。

00:08:36.000 -> 00:08:44.000
一部の画像は非常に明るくHDRですが、SDR画像はそうではなく、今では鈍く見え、おそらく非アクティブでさえあります。

00:08:44.000 -> 00:08:47.000
では、constrainedHighオプションを使ってみましょう。

00:08:47.000 -> 00:08:53.000
HDRコンテンツの使用が許可されるヘッドルームを制限することで、フィルムストリップをより一貫性のあるものにします。

00:08:53.000 -> 00:09:00.000
あなたはまだHDR画像をSDR画像と区別することができますが、私はもはやSDR画像が灰色または非アクティブに見えるという問題はありません。

00:09:00.000 -> 00:09:12.000
特定の画像ビューにconstrainedHighまたは標準を使用したいもう1つの理由は、HDRコンテンツが非常に明るくなる場合があり、アプリの他の側面から注意をそらしたくない可能性があることです。

00:09:12.000 -> 00:09:24.000
たとえば、ここでは、フルHDRで表示すると、アプリの最も重要な部分のように見えますが、重要なコントロールや情報から注意をそらしている小さな画像です。

00:09:24.000 -> 00:09:30.000
先に進む前に、ここには画像のトーンマッピングを含まないオプションがないことに気づいたかもしれません。

00:09:30.000 -> 00:09:40.000
OSにトーンマッピングをさせたくない場合は、下位レベルのAPIを使用する必要があります。このセッションの後半で説明します。

00:09:40.000 -> 00:09:48.000
心に留めておくべきHDRの重要な側面は、HDRデータをクランプしたり劣化させたりしないパイプラインが必要であることです。

00:09:48.000 -> 00:09:55.000
今日議論するAPIはすべて完全にサポートされていますが、非推奨のAPIにはHDRセーフなパイプラインがない可能性があります。

00:09:55.000 -> 00:10:05.000
たとえば、非推奨のUIGraphicsBeginImageContextWithOptionsを使用して画像のサイズを変更すると、HDRと広色域の色が失われます。

00:10:05.000 -> 00:10:10.000
HDR対応アプリを作成する際には、これは避けるべきです。

00:10:10.000 -> 00:10:16.000
サムネイルを作成しようとしている場合、UIKitはiOS 15のUIImageにサムネイルAPIを導入しました。

00:10:16.000 -> 00:10:21.000
正確なサイズ制御を必要としない場合、これはHDRサムネイルを取得するための推奨される方法です。

00:10:21.000 -> 00:10:29.000
iOS 15より前により多くのコントロールが必要な場合やサポートが必要な場合、UIKitはUIGraphicsImageRendererを提供しています。

00:10:29.000 -> 00:10:37.000
imageRendererFormatを使用することで、UIKitは、再描画時に画像内のHDR情報が失われないレンダラーを構築する方法を知っています。

00:10:37.000 -> 00:10:42.000
画像データをアプリに取り込む一般的な方法を見てみましょう。

00:10:42.000 -> 00:10:46.000
PhotoKitは、アプリがフォトライブラリにアクセスするためのインターフェースを提供します。

00:10:46.000 -> 00:10:52.000
私のアプリでは、メインビューに写真ピッカーを追加し、ユーザーが選択した画像に簡単にアクセスできます。

00:10:52.000 -> 00:11:04.000
PhotosPickerはHDRデータを保持しない形式に画像をトランスコードしようとする可能性があるため、「現在の」エンコーディングポリシーと一般的な「画像」マッチングタイプを使用します。

00:11:04.000 -> 00:11:10.000
フォトピッカーの仕組みの詳細については、「写真ピッカーをアプリに埋め込む」セッションをチェックしてください。

00:11:10.000 -> 00:11:20.000
ISO HDR画像を使用すると、DataRepresentationからUIImageを作成し、余分なコードなしで画像ビューで直接使用できます。

00:11:20.000 -> 00:11:28.000
ゲインマップHDRもサポートしている場合は、新しいUIImageReaderを使用して、利用可能なときにHDR表現を取得できます。

00:11:28.000 -> 00:11:36.000
このAPIは、HDRディスプレイの場合、デフォルトでHDR表現を返し、それ以外の場合はSDRバージョンを返します。

00:11:36.000 -> 00:11:42.000
これまで議論したAPIは、画像がHDRであることや、画像がHDRであることを知ることに依存していません。

00:11:42.000 -> 00:11:49.000
画像ビューに高いダイナミックレンジを表示する必要があることを知らせるとき、その画像がHDRであるかどうかは問題ではないことを思い出してください。

00:11:49.000 -> 00:11:55.000
ただし、画像がHDRであるかどうかを識別したいパイプラインやアプリがあるかもしれません。

00:11:55.000 -> 00:12:02.000
UIKitを使用すると、isHighDynamicRangeプロパティをチェックして、コンテンツがISO HDR互換かどうかを判断できます。

00:12:02.000 -> 00:12:08.000
AppKit、CoreGraphics、CoreImageでは、画像のCGColorSpaceを確認する必要があります。

00:12:08.000 -> 00:12:17.000
CGColorSpaceUsesITUR_2100TF関数は、ISO HDR画像に対してtrueを返します。

00:12:17.000 -> 00:12:20.000
HDR画像は、幅広いヘッドルームを使用できます。

00:12:20.000 -> 00:12:25.000
たとえば、現在のiPhoneは、最大8倍のヘッドルームを使用する画像を生成します。

00:12:25.000 -> 00:12:30.000
ただし、一部のディスプレイのみがHDRを表示でき、すべてのHDRディスプレイが同じというわけではありません。

00:12:30.000 -> 00:12:45.000
iPhone 14は、リファレンスホワイトよりも最大8倍明るくHDRハイライトを表示でき、12.9インチのiPad ProとMacBook Proは最大16倍、Pro XDRディスプレイは最大400倍を表示できます。

00:12:45.000 -> 00:12:47.000
他のほとんどのAppleディスプレイは、最大2倍のヘッドルームを表示できます。

00:12:47.000 -> 00:12:51.000
しかし、これはほとんどのHDRコンテンツでは十分ではないかもしれません。

00:12:51.000 -> 00:12:56.000
サポートされているHDR機能を備えた外部ディスプレイもあります。

00:12:56.000 -> 00:13:06.000
これらのディスプレイの完全なリストはありません。ただし、アプリが現在表示されているディスプレイの機能を判断するためのAPIがあります。

00:13:06.000 -> 00:13:20.000
iOSとiPad OSでは潜在的なEDRHeadroomを照会し、macOSではmaximumPotentialExtendedDynamicRange-ColorComponentValueを照会して、アプリが表示されているディスプレイの機能を判断できます。

00:13:20.000 -> 00:13:26.000
より高度なトピックに移る前に、HDRを表示することが理にかなっているときについて話しましょう。

00:13:26.000 -> 00:13:33.000
私が議論したように、HDRは素晴らしく見え、画像を表示するときにサポートを含めることを検討する必要があります。

00:13:33.000 -> 00:13:36.000
しかし、時には気が散ることがあります。

00:13:36.000 -> 00:13:43.000
したがって、HDRがあなたに与えることができる余分なポップを必要としないと思う場合は、constrainedHighまたは標準オプションの使用を検討してください。

00:13:43.000 -> 00:13:44.000
要約しましょう。

00:13:44.000 -> 00:13:57.000
これで、ISO HDR画像を識別し、HDR画像を表示し、フォトライブラリからISO HDRとゲインマップHDRにアクセスする方法、およびディスプレイがHDRであるかどうかを判断する方法がわかります。

00:13:57.000 -> 00:14:02.000
今、デビッドはHDR画像の読み取り、書き込み、操作を案内します。

00:14:02.000 -> 00:14:29.000
ありがとう、ジャクソン。HDR画像を扱う場合、アプリがサポートする可能性のある一般的な操作がいくつかあります。ファイルまたはデータからISO HDRまたはゲインマップHDR画像をメモリに読み込む。HDRコンテンツを保持しながらメモリ内の画像を変更する。HDRを失うことなく、ある画像クラスから別の画像クラスに変換する。そして最後に、HDR画像をISO HDRファイルに書き込む。

00:14:29.000 -> 00:14:36.000
機能的なHDR画像パイプラインの重要な特性は、画像オブジェクトが関連する色空間を持っていることです。

00:14:36.000 -> 00:14:42.000
たとえば、CGImageとCIImageの両方のオブジェクトは、これにCGColorSpace APIを使用します。

00:14:42.000 -> 00:14:54.000
画像はさまざまなサポートされている色空間を持つことができますが、ISO HDR画像にはITUR 2100 HLGまたはPQのいずれかのCGColorSpaceがあります。

00:14:54.000 -> 00:14:58.000
それを念頭に置いて、ISO HDR画像の読み方から始めましょう。

00:14:58.000 -> 00:15:04.000
UIImageとNSImageは、ISO HDR画像の読み取りを自動的にサポートするようになりました。

00:15:04.000 -> 00:15:14.000
Appleのカラー管理インフラストラクチャであるColorSyncは、HDR ICCプロファイルを処理し、表示に適した画像オブジェクトを提供します。

00:15:14.000 -> 00:15:25.000
ゲインマップHDR画像を読むときは、ハイダイナミックレンジを好むUIImageReader構成を作成することで、HDR表現をリクエストできます。

00:15:25.000 -> 00:15:29.000
この新しい動作は、ゲインマップHDR画像にのみ影響することに注意してください。

00:15:29.000 -> 00:15:37.000
NSImageやUIImageと同様に、Core ImageはISO HDRファイルの読み取りを自動的にサポートします。

00:15:37.000 -> 00:15:41.000
あなたがする必要があるのは、CIImage contentsOfURL APIを使用することだけです。

00:15:41.000 -> 00:15:52.000
結果のCIImageオブジェクトには、ファイルの色空間からCore Imageの拡張範囲の作業空間に変換する正しいレシピが自動的に含まれます。

00:15:52.000 -> 00:15:58.000
コードをデバッグするときにXcodeのQuickLook機能を使用して、画像オブジェクトのレシピを調べることができます。

00:15:58.000 -> 00:16:07.000
この例では、QuickLookポップオーバーは、画像がPQ ISO HDR色空間から変換されていることを示しています。

00:16:07.000 -> 00:16:12.000
コードは、ファイルの色空間を検査するために.colorspaceプロパティを取得することもできます。

00:16:12.000 -> 00:16:19.000
これは、sRGBやDisplay P3などのSDR色空間、またはHDR色空間である可能性があります。

00:16:19.000 -> 00:16:33.000
CoreGraphics APIを使用する場合は、新しいdecodeRequestキーをdecodeToHDRに設定してCGImageSourceCreateImageAtIndexを使用することで、同等の動作を得ることができます。

00:16:33.000 -> 00:16:39.000
数分前、ジャクソンはHDR画像をSDRに制限したい理由を説明しました。

00:16:39.000 -> 00:16:48.000
同様に、Core Imageを使用しているアプリは、画像がSDRにトーンマッピングされていることを確認するために、自動HDRサポートをオーバーライドしたい場合があります。

00:16:48.000 -> 00:16:54.000
これは、機能検出などの特定のシナリオでHDRの使用を避けたい場合に役立ちます。

00:16:54.000 -> 00:17:03.000
これを有効にするには、CIImageの作成時にtoneMapHDRtoSDRオプションを提供するだけです。

00:17:03.000 -> 00:17:14.000
この場合、返されるCIImageオブジェクトには、他の操作が適用される前にHDRソースをSDR範囲にトーンマップするレシピステップが含まれます。

00:17:14.000 -> 00:17:20.000
このオプションは、画像にHDR色空間がある場合にのみ効果があることに注意してください。

00:17:20.000 -> 00:17:28.000
結果のCIImageは、画像ビューがdynamicRange.standardオプションを使用することを指定するのと同じです。

00:17:28.000 -> 00:17:38.000
また、これは、decodeRequestがdecodeToSDRに設定されているCGImageSourceCreateImageAtIndexを使用するのと同じ動作です。

00:17:38.000 -> 00:17:50.000
従来、ゲインマップHDR画像は写真アプリでフルダイナミックレンジを表示しますが、Core ImageやImageIOなどのAPIではSDR表現のみが利用可能でした。

00:17:50.000 -> 00:18:00.000
アプリケーションがゲインマップHDR画像のフルレンジにアクセスできるようにする新しいAPIについて説明できることを本当に楽しみにしています。

00:18:00.000 -> 00:18:02.000
APIはとても使いやすいです。

00:18:02.000 -> 00:18:08.000
CIImageを初期化するときに、expandToHDRオプションを提供するだけです。

00:18:08.000 -> 00:18:19.000
この場合、返されるCIImageオブジェクトには、プライマリ画像とゲインマップを組み合わせてHDR画像を生成するレシピが含まれます。

00:18:19.000 -> 00:18:27.000
フォトライブラリにこれをサポートするための追加のゲインマップデータが含まれている場合、画像の.colorspaceプロパティはHDR色空間になります。

00:18:27.000 -> 00:18:37.000
この動作は、decodeRequestキーをdecodeToHDRに設定してCGImageSourceCreateImageAtIndexを使用することと同等です。

00:18:37.000 -> 00:18:44.000
これらのオプションはRAWファイルでも機能しますが、これから詳しく説明します。

00:18:44.000 -> 00:18:52.000
iPhoneからのProRAW画像とカメラからのRAW画像は、写真家に重要な創造的なコントロールを与える柔軟な画像フォーマットです。

00:18:52.000 -> 00:18:57.000
これには、シーンの一部をHDRヘッドルームにレンダリングする機能が含まれます。

00:18:57.000 -> 00:19:04.000
多くのRAWフォーマットには十分なダイナミックレンジが含まれており、単に制約のないフォームに処理する必要があります。

00:19:04.000 -> 00:19:06.000
これがどのように機能するかを説明しましょう。

00:19:06.000 -> 00:19:15.000
まず、アプリケーションがデフォルトのSDRを表示したい場合は、通常どおりURLから画像を作成します。

00:19:15.000 -> 00:19:24.000
しかし、アプリケーションがデフォルトのHDRレンダリングの外観を表示したいだけなら、あなたがする必要があるのは新しいexpandToHDRオプションを追加することだけです。

00:19:24.000 -> 00:19:33.000
ただし、アプリがRAWの完全な機能のロックを解除したい場合は、コードはURLからCIRAWFilterを作成する必要があります。

00:19:33.000 -> 00:19:39.000
そのフィルターに出力画像を尋ねると、デフォルトの外観のCIImageが表示されます。

00:19:39.000 -> 00:19:45.000
しかし、このAPIの主な利点は、フィルターを簡単に変更できることです。

00:19:45.000 -> 00:19:52.000
各CIRAWFilterインスタンスには、アプリが出力画像を変更するために変更できるいくつかのプロパティがあります。

00:19:52.000 -> 00:20:03.000
これらのプロパティは、「ProRAW画像のキャプチャと処理」セッションでよく説明されていますが、このHDRディスカッションに特に関連するものを確認しましょう。

00:20:03.000 -> 00:20:09.000
RAW画像のダイナミックレンジの量は、0から1までの任意の値に調整できます。

00:20:09.000 -> 00:20:17.000
extendedDynamicRangeAmountプロパティは、Jacksonが以前に説明したviewDynamicRangeコントロールに似ています。

00:20:17.000 -> 00:20:23.000
このプロパティのデフォルト値は0で、出力画像がSDRである必要があることを示します。

00:20:23.000 -> 00:20:31.000
このプロパティの最大値は1で、出力画像がファイルに存在するヘッドルームを最大限に活用する必要があることを示します。

00:20:31.000 -> 00:20:35.000
これは、ISO HDR画像を読み取るさまざまな方法をまとめています。

00:20:35.000 -> 00:20:41.000
次に、HDR画像を変更する方法に関する推奨事項について話し合いましょう。

00:20:41.000 -> 00:20:52.000
Core Imageは、HDRをサポートする150以上のフィルターが組み込まれているため、HDR画像を操作するための強力で柔軟なAPIを提供します。

00:20:52.000 -> 00:20:58.000
これらのフィルターはすべて、HDRコンテンツを含む画像を生成または処理できます。

00:20:58.000 -> 00:21:10.000
これらのフィルタはすべて、コア画像の作業色空間がクランプされておらず線形であるため、0から1の範囲外のRGB値を可能にするため、機能します。

00:21:10.000 -> 00:21:15.000
アプリを開発する際に、特定のフィルターがHDRをサポートしているかどうかを確認できます。

00:21:15.000 -> 00:21:27.000
これを行うには、フィルターのインスタンスを作成し、フィルターの属性にカテゴリを尋ね、配列にカテゴリの高いダイナミックレンジが含まれているかどうかを確認します。

00:21:27.000 -> 00:21:37.000
組み込みのCIフィルタとカスタムCIカーネルの詳細については、「Core Image、Metal、SwiftUIでEDRコンテンツを表示する」セッションを参照してください。

00:21:37.000 -> 00:21:41.000
次に、HDR画像をISO HDRファイルに書き込むことについて議論しましょう。

00:21:41.000 -> 00:21:47.000
多くの場合、アプリはメモリ内の画像オブジェクトを新しいファイル表現に書き込む必要があります。

00:21:47.000 -> 00:21:55.000
従来、UIImage、jpegData、およびpngData APIを使用すると、8ビットの精度SDRイメージが保存されます。

00:21:55.000 -> 00:22:06.000
今年の新機能、UIImageは、オブジェクトにHDRコンテンツが含まれている場合、16ビットPNGまたは10ビットHEIF形式のいずれかを使用してISO HDR画像を自動的に書き込むことができます。

00:22:06.000 -> 00:22:13.000
また、元の画像がゲインマップHDR画像の場合、ISO HDRに変換されます。

00:22:13.000 -> 00:22:26.000
同様に、Core Imageは、HDR色空間を指定し、RGBA16形式を要求するwritePNGRepresentationOfImageを呼び出すと、HDR PNGファイルを書き込むことができます。

00:22:26.000 -> 00:22:38.000
または、Core Imageは、HDR色空間を指定し、RGBA16形式を要求するwriteTIFFRepresentationOfImageを呼び出すと、HDR TIFFファイルを書き込むことができます。

00:22:38.000 -> 00:22:45.000
PNGとTIFFの両方がロスレス圧縮を使用しており、ファイルサイズがはるかに大きくなることに注意してください。

00:22:45.000 -> 00:22:54.000
その結果、ベストプラクティスは、writeHEIF10RepresentationOfImageを使用してHEIFファイルを作成し、HDR色空間を指定することです。

00:22:54.000 -> 00:23:02.000
あるフレームワーククラスから別のクラスへ、またはある色空間から別の色空間に変換する必要がある場合があります。

00:23:02.000 -> 00:23:12.000
画像クラスUIImage、CIImage、CGImage、IOSurface、およびCVPixelBufferの間で変換するプロセスは、ほとんど同じままです。

00:23:12.000 -> 00:23:18.000
とはいえ、HDRパイプラインで作業する際に見るべき点がいくつかあります。

00:23:18.000 -> 00:23:23.000
まず、IOSurfaceまたはCVPixelBufferオブジェクトへの変換について話し合いましょう。

00:23:23.000 -> 00:23:29.000
この画像タイプは、たとえば、CALayerのコンテンツとして使用できるため便利です。

00:23:29.000 -> 00:23:34.000
また、バイプレーナークロマサブサンプリング画像を保持できるため、非常にメモリ効率が高まります。

00:23:34.000 -> 00:23:41.000
CVPixelBufferを使用する前に、ISO HDR互換コンテンツがあることを必ず宣言してください。

00:23:41.000 -> 00:23:48.000
最初のステップは、10ビットのバイプレーナーフルレンジなどの適切なフォーマットでピクセルバッファを作成することです。

00:23:48.000 -> 00:23:57.000
その間、最高のパフォーマンスのために、IOSurfacePropertiesKeyを提供することで、バッファをサーフェスバックする必要があることを必ず指定してください。

00:23:57.000 -> 00:24:05.000
次に、CVPixelBufferに添付ファイルを追加して、ISO HDR互換の色空間プロパティが含まれていることをシステムが認識できるようにします。

00:24:05.000 -> 00:24:09.000
CVPixelBufferがあれば、それをCIImageに変換するのは簡単です。

00:24:09.000 -> 00:24:13.000
CIImage withCVPixelBuffer APIを呼び出すだけです。

00:24:13.000 -> 00:24:21.000
また、CIContextを使用してバッファにレンダリングすることで、CIImageからCVPixelBufferに変換できます。

00:24:21.000 -> 00:24:29.000
アプリがCore ImageとCGImageRef APIの間で変換したい状況がいくつかあります。

00:24:29.000 -> 00:24:43.000
この変換でHDRコンテンツを保存したい場合は、HDR色空間を選択し、RGBA16やRGBAh形式などのディープピクセル形式をリクエストする必要があります。

00:24:43.000 -> 00:24:50.000
そして今年新しく、CoreImageは深いがメモリの半分を使用するRGB10フォーマットを追加しました。

00:24:50.000 -> 00:24:58.000
CIImageをCGImageに変換することは、CGImagesがさまざまなAPIでサポートされていることを考えると、非常に便利です。

00:24:58.000 -> 00:25:03.000
しかし、ユーザー対話型レンダリングの最高のパフォーマンスのためにそうすることは推奨されないことに注意してください。

00:25:03.000 -> 00:25:13.000
最速のパフォーマンスを得るには、CoreImageをMTKViewに直接レンダリングするか、PixelBufferを介してCALayerにレンダリングするのが最善です。

00:25:13.000 -> 00:25:21.000
CALayersといえば、ジャクソンに戻って、より複雑なワークフローに必要な低レベルのAPIについて詳しく学びましょう。

00:25:21.000 -> 00:25:22.000
ありがとう、デビッド!

00:25:22.000 -> 00:25:30.000
CALayersは、最高のレンダリングパフォーマンスや、コンテンツがどのようにアプリに合成されるかをより詳細に制御する必要があるときに強力なツールです。

00:25:30.000 -> 00:25:37.000
CALayersでHDRレンダリングを有効にするには、 wantsExtendedDynamicRangeContentプロパティを設定できるようになりました。

00:25:37.000 -> 00:25:44.000
これは、CAMetalLayersがディスプレイのヘッドルームにコンテンツを表示できるようにするために使用されるプロパティに似ています。

00:25:44.000 -> 00:25:54.000
これら2つの方法の主な違いは、CALayerプロパティがレイヤーコンテンツのトーンマッピングを可能にするのに対し、CAMetalLayerはできないことです。これは実際にはどういう意味ですか?

00:25:54.000 -> 00:25:58.000
この画像とプロットは、10倍のヘッドルームを持つコンテンツを示しています。

00:25:58.000 -> 00:26:04.000
少なくとも10倍のヘッドルームが利用可能なディスプレイにレンダリングされると、両方のレイヤーは同じように動作します。

00:26:04.000 -> 00:26:09.000
ディスプレイには5倍のヘッドルームしかないと仮定しましょう。

00:26:09.000 -> 00:26:19.000
CAMetalLayerの場合、5回を超える画像データは、ディスプレイが表示できるものに固定され、画像の急激な不連続が生じます。

00:26:19.000 -> 00:26:23.000
CALayerの場合、その不連続性を避けるために、画像はトーンマッピングされます。

00:26:23.000 -> 00:26:29.000
使用される正確なトーンマッピングアルゴリズムは、その画像で使用される転送曲線によって異なります。

00:26:29.000 -> 00:26:36.000
これらのアルゴリズムの詳細については、HLGとPQのITU規格を参照してください。

00:26:36.000 -> 00:26:46.000
CALayersはHDRコンテンツを画面に表示するための迅速かつ簡単な方法を提供し、CAMetalLayersは独自のトーンマッピングパイプラインを自由に作成できます。

00:26:46.000 -> 00:26:51.000
CALayerを直接使用してHDRをレンダリングするには、これらの利用可能なクラスのいずれかを使用する必要があります。

00:26:51.000 -> 00:27:01.000
ISO HDRとして適切にタグ付けされたCGImage、CVPixelBuffer、またはIOSurfaceタイプのオブジェクトは、CALayerによってレンダリングされ、トーンがマッピングされます。

00:27:01.000 -> 00:27:09.000
CALayerを直接使用し、これらのクラスの1つを使用していない場合は、Davidが説明した方法の1つを使用して変換できます。

00:27:09.000 -> 00:27:14.000
HDRワークフローで作業するときは、正しいピクセルフォーマットを使用することが重要です。

00:27:14.000 -> 00:27:18.000
これらのピクセルフォーマットは、HDRデータを扱うときに安全に使用できます。

00:27:18.000 -> 00:27:22.000
16ビットと32ビットのフロートフォーマットは、常に高いダイナミックレンジをサポートしています。

00:27:22.000 -> 00:27:29.000
16ビット整数形式は、適切なファイル形式とコンテキストでHDRコンテンツをサポートするためにも機能します。

00:27:29.000 -> 00:27:34.000
最後に、メモリとファイルサイズが重要な場合に使用できる10ビットピクセルフォーマットがあります。

00:27:34.000 -> 00:27:39.000
これは、ほとんどの圧縮されたISO HDR画像のデフォルトのビット深度です。

00:27:39.000 -> 00:27:44.000
HDRコンテンツに使用できるCGImageを作成する際には、CoreGraphicsフラグもあります。

00:27:44.000 -> 00:27:50.000
前のリストと同様に、float、half float、16ビット整数、10ビットRGBを使用できます。

00:27:50.000 -> 00:27:56.000
このような新機能を導入する際の最後の重要なトピックの1つは、下位互換性です。

00:27:56.000 -> 00:28:01.000
HDR画像を扱う際に、古いバージョンのiOSとmacOSをサポートするために何ができますか?

00:28:01.000 -> 00:28:09.000
ISO HDR画像の場合、CoreImageはHDRをSDRに変換するtoneMapHDRtoSDRオプションを提供します。

00:28:09.000 -> 00:28:18.000
同様に、CoreGraphics CGContextを使用してレンダリングする場合、SDR CGColorspaceをターゲットにすることができ、画像はそのスペースにトーンマップされます。

00:28:18.000 -> 00:28:24.000
ゲインマップHDRでは、新しいexpandToHDRオプションが使用されたときにバージョンチェックを使用してゲートします。

00:28:24.000 -> 00:28:30.000
これらのオプションを省略すると、ファイルのSDRバージョンが常にHDRバージョンの代わりに読み込まれます。

00:28:30.000 -> 00:28:44.000
最後に、HDR画像の読み取り、書き込み、表示のための新しいAPIを導入し、ゲインマップHDR表現にアクセスする方法を示し、完全にHDR対応のパイプラインを操作するためのAPIを提供します。

00:28:44.000 -> 00:28:48.000
あなたがHDRで作る素晴らしいものを見るのが待ちきれません!

00:28:48.000 -> 00:28:50.000
一緒に:見てくれてありがとう!

00:28:50.000 -> 23:59:59.000
。

