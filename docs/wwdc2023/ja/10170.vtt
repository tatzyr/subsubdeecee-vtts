WEBVTT

00:00:01.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:12.000
エヴァン：こんにちは、私の名前はエヴァンです。

00:00:12.000 --> 00:00:20.000
今日、私たちは構造化された並行性の基本を超えて、構造化されたタスクが有用な動作の実現を簡素化する方法を模索しています。

00:00:20.000 --> 00:00:33.000
始める前に、初めての場合、または構造化された並行性を確認したい場合は、WWDC 2021の「Swiftで構造化された並行性を探索する」セッションと「Swift並行性：舞台裏」セッションを自由にご覧ください。

00:00:33.000 --> 00:00:44.000
今日は、タスク階層と、それが自動タスクキャンセル、優先順位の伝播、および有用なタスクローカル値の動作のロックを解除する方法を確認します。

00:00:44.000 --> 00:00:48.000
次に、リソースの使用状況を管理するのに役立つタスクグループでいくつかのパターンをカバーします。

00:00:48.000 --> 00:00:56.000
最後に、これらすべてが組み合わされ、サーバー環境でのプロファイリングとトレースタスクを容易にする方法を見ていきます。

00:00:56.000 --> 00:01:13.000
構造化された並行性を使用すると、「if」ブロックと「for」ループが同期コードで制御フローがどのように振る舞うかを定義するのと同様に、実行が分岐して同時に実行され、その実行の結果が再結合する明確に定義されたポイントを使用して、並行コードについて推論することができます。

00:01:13.000 --> 00:01:20.000
「Async let」、タスクグループ、またはタスクまたは切り離されたタスクを作成すると、同時実行がトリガーされます。

00:01:20.000 --> 00:01:26.000
結果は、「待機」で示される停止ポイントで現在の実行に再結合します。

00:01:26.000 --> 00:01:28.000
すべてのタスクが構造化されているわけではありません。

00:01:28.000 --> 00:01:37.000
構造化タスクは「async let」とタスクグループを使用して作成され、非構造化タスクはTaskとTask.detachedを使用して作成されます。

00:01:37.000 --> 00:01:48.000
構造化されたタスクは、ローカル変数のように宣言されたスコープの最後まで生き、スコープ外になると自動的にキャンセルされ、タスクの存続期間を明確にします。

00:01:48.000 --> 00:01:51.000
可能な限り、構造化されたタスクを好みます。

00:01:51.000 --> 00:01:57.000
後で説明する構造化並行性の利点は、必ずしも非構造化タスクに適用されるとは限りません。

00:01:57.000 --> 00:02:02.000
コードに飛び込む前に、具体的な例を考えましょう。

00:02:02.000 --> 00:02:05.000
複数のシェフがスープを準備しているキッチンがあるとします。

00:02:05.000 --> 00:02:08.000
スープの準備は複数のステップで構成されています。

00:02:08.000 --> 00:02:16.000
シェフは材料を切り、鶏肉をマリネし、スープを沸騰させ、最後に、準備が整う前にスープを調理する必要があります。

00:02:16.000 --> 00:02:21.000
一部のタスクは並行して実行できますが、他のタスクは特定の順序で実行する必要があります。

00:02:21.000 --> 00:02:24.000
これをコードで表現する方法を見てみましょう。

00:02:24.000 --> 00:02:28.000
今のところ、makeSoup機能に焦点を当てます。

00:02:28.000 --> 00:02:35.000
関数に並行性を追加するために非構造化タスクを作成し、必要に応じてその値を待っているかもしれません。

00:02:35.000 --> 00:02:43.000
これは、どのタスクが同時に実行でき、どのタスクが実行できないかを表しますが、これはSwiftで並行性を使用する推奨される方法ではありません。

00:02:43.000 --> 00:02:47.000
これは、構造化された並行性を使用して表現される同じ関数です。

00:02:47.000 --> 00:02:54.000
作成する子タスクの数が知られているので、便利な「async let」構文を使用できます。

00:02:54.000 --> 00:02:58.000
これらのタスクは、親タスクと構造化された関係を形成します。

00:02:58.000 --> 00:03:01.000
なぜこれが重要なのか、まもなく話します。

00:03:01.000 --> 00:03:04.000
makeSoupは多くの非同期関数を呼び出します。

00:03:04.000 --> 00:03:11.000
そのうちの1つは「chopIngredients」で、材料のリストを取り、タスクグループを使用してそれらをすべて同時に切り刻みます。

00:03:11.000 --> 00:03:16.000
makeSoupに慣れたので、タスク階層を見てみましょう。 タスク階層を見てみましょう。

00:03:16.000 --> 00:03:22.000
子タスクは色付きのボックスで示され、矢印は親タスクから子タスクを指しています。

00:03:22.000 --> 00:03:29.000
makeSoupには、材料を切り刻む、鶏肉をマリネし、スープを沸騰させるための3つの子供のタスクがあります。

00:03:29.000 --> 00:03:34.000
chopIngredientsは、タスクグループを使用して、各成分の子タスクを作成します。

00:03:34.000 --> 00:03:38.000
私たちが3つの材料を持っていれば、それも3人の子供を作るでしょう。

00:03:38.000 --> 00:03:43.000
この親子階層は、ツリー、タスクツリーを形成します。

00:03:43.000 --> 00:03:48.000
タスクツリーを導入したので、それがコードにどのように役立つかを特定し始めましょう。

00:03:48.000 --> 00:03:58.000
タスクのキャンセルは、アプリがタスクの結果を必要としなくなり、タスクが停止して部分的な結果を返すか、エラーをスローする必要があることを知らせるために使用されます。

00:03:58.000 --> 00:04:08.000
私たちのスープの例では、その顧客が去った場合、何か他のものを注文したいと決めた場合、または閉店時間になった場合、スープの注文をやめたいと思うかもしれません。

00:04:08.000 --> 00:04:10.000
タスクのキャンセルの原因は何ですか?

00:04:10.000 --> 00:04:21.000
構造化タスクは、スコープ外になると暗黙的にキャンセルされますが、タスクグループで「cancelAll」を呼び出して、すべてのアクティブな子と将来の子タスクをキャンセルできます。

00:04:21.000 --> 00:04:26.000
非構造化タスクは、「キャンセル」機能で明示的にキャンセルされます。

00:04:26.000 --> 00:04:32.000
親タスクをキャンセルすると、すべての子タスクがキャンセルされます。

00:04:32.000 --> 00:04:36.000
キャンセルは協力的なので、子供のタスクはすぐには停止されません。

00:04:36.000 --> 00:04:40.000
そのタスクに「isCancelled」フラグを設定するだけです。

00:04:40.000 --> 00:04:43.000
実際にキャンセルに基づいて行動することは、あなたのコードで行われます。

00:04:43.000 --> 00:04:45.000
キャンセルはレースです。

00:04:45.000 --> 00:04:51.000
チェックの前にタスクがキャンセルされた場合、「makeSoup」は「SoupCancellationError」をスローします。

00:04:51.000 --> 00:04:58.000
警備員の実行後にタスクがキャンセルされた場合、プログラムはスープの準備に続けます。

00:04:58.000 --> 00:05:08.000
部分的な結果を返す代わりにキャンセルエラーをスローする場合は、「Task.checkCancellation」を呼び出すことができ、タスクがキャンセルされた場合に「CancellationError」をスローします。

00:05:08.000 --> 00:05:15.000
結果がまだ必要であることを確認するために、高価な作業を開始する前に、タスクのキャンセル状況を確認することが重要です。

00:05:15.000 --> 00:05:27.000
キャンセルチェックは同期的であるため、キャンセルに反応する非同期または同期の機能は、続行する前にタスクのキャンセルステータスを確認する必要があります。

00:05:27.000 --> 00:05:42.000
「isCancelled」または「checkCancellation」によるキャンセルのポーリングは、タスクが実行されているときに便利ですが、AsyncSequenceを実装するときのように、タスクが一時停止され、コードが実行されていない間は、キャンセルに応答する必要がある場合があります。

00:05:42.000 --> 00:05:47.000
これは「withTaskCancellationHandler」が便利な場所です。

00:05:47.000 --> 00:05:50.000
シフト機能を紹介しましょう。

00:05:50.000 --> 00:05:58.000
料理人は、タスクのキャンセルによって通知され、シフトの終わりまで注文が入ってくるので、スープを作る必要があります。

00:05:58.000 --> 00:06:04.000
1つのキャンセルシナリオでは、非同期for-loopはキャンセルされる前に新しい注文を取得します。

00:06:04.000 --> 00:06:09.000
「makeSoup」関数は、先に定義したようにキャンセルを処理し、エラーをスローします。

00:06:09.000 --> 00:06:16.000
別のシナリオでは、タスクが中断されている間にキャンセルが行われ、次の注文を待つことがあります。

00:06:16.000 --> 00:06:23.000
このケースは、タスクが実行されていないため、より興味深いため、キャンセルイベントを明示的にポーリングすることはできません。

00:06:23.000 --> 00:06:31.000
代わりに、キャンセルハンドラを使用してキャンセルイベントを検出し、非同期のfor-loopから抜け出す必要があります。

00:06:31.000 --> 00:06:35.000
注文はAsyncSequenceから生成されます。

00:06:35.000 --> 00:06:42.000
AsyncSequencesは、非同期の「次の」関数を定義するAsyncIteratorによって駆動されます。

00:06:42.000 --> 00:06:52.000
同期イテレータと同様に、「次」関数はシーケンス内の次の要素を返すか、シーケンスの最後にいることを示すためにnilを返します。

00:06:52.000 --> 00:06:59.000
多くのAsyncSequencesは、実行中のシーケンスを停止するために使用するステートマシンで実装されています。

00:06:59.000 --> 00:07:05.000
ここでの例では、「isRunning」が真の場合、シーケンスは注文を発し続ける必要があります。

00:07:05.000 --> 00:07:10.000
タスクがキャンセルされたら、シーケンスが完了し、シャットダウンする必要があることを示す必要があります。

00:07:10.000 --> 00:07:16.000
これを行うには、シーケンスステートマシンで「キャンセル」関数を同期的に呼び出します。

00:07:16.000 --> 00:07:28.000
キャンセルハンドラはすぐに実行されるため、ステートマシンはキャンセルハンドラと本体の間で可変状態が共有され、同時に実行できることに注意してください。

00:07:28.000 --> 00:07:30.000
ステートマシンを保護する必要があります。

00:07:30.000 --> 00:07:41.000
俳優はカプセル化された状態を保護するのに最適ですが、ステートマシン上の個々のプロパティを変更して読みたいので、俳優はこれに適したツールではありません。

00:07:41.000 --> 00:07:49.000
さらに、操作がアクターで実行される順序を保証できないため、キャンセルが最初に実行されることを保証することはできません。

00:07:49.000 --> 00:07:51.000
私たちは何か他のものが必要になります。

00:07:51.000 --> 00:07:58.000
Swift Atomicsパッケージのアトミックを使用することにしましたが、ディスパッチキューまたはロックを使用できます。

00:07:58.000 --> 00:08:10.000
これらのメカニズムにより、共有状態を同期し、競合状態を回避しながら、キャンセルハンドラに非構造化タスクを導入することなく、実行中のステートマシンをキャンセルすることができます。

00:08:10.000 --> 00:08:14.000
タスクツリーは自動的にタスクのキャンセル情報を伝播します。

00:08:14.000 --> 00:08:21.000
キャンセルトークンと同期を心配する代わりに、Swiftランタイムに安全に処理させます。

00:08:21.000 --> 00:08:31.000
キャンセルはタスクの実行を停止せず、キャンセルされたことをタスクに通知するだけで、できるだけ早く実行を停止する必要があることを覚えておいてください。

00:08:31.000 --> 00:08:35.000
キャンセルを確認するのはあなたのコード次第です。

00:08:35.000 --> 00:08:42.000
次に、構造化されたタスクツリーが優先順位を伝播し、優先順位の反転を回避するのにどのように役立つかを考えてみましょう。

00:08:42.000 --> 00:08:46.000
まず、優先順位とは何ですか、そしてなぜ私たちは気にするのですか?

00:08:46.000 --> 00:08:51.000
優先順位は、特定のタスクがどれほど緊急であるかをシステムに伝える方法です。

00:08:51.000 --> 00:08:57.000
ボタン押下への応答などの特定のタスクは、すぐに実行する必要があるか、アプリがフリーズして表示されます。

00:08:57.000 --> 00:09:04.000
一方、サーバーからのコンテンツのプリフェッチなどの他のタスクは、誰にも気づかれずにバックグラウンドで実行できます。

00:09:04.000 --> 00:09:08.000
第二に、優先度反転とは何ですか?

00:09:08.000 --> 00:09:15.000
優先度の反転は、優先度の高いタスクが優先度の低いタスクの結果を待っているときに発生します。

00:09:15.000 --> 00:09:28.000
デフォルトでは、子タスクは親から優先度を継承するので、makeSoupが中優先度のタスクで実行されていると仮定すると、すべての子タスクも中優先度で実行されます。

00:09:28.000 --> 00:09:33.000
スープを求めて私たちのレストランに来るVIPゲストとしましょう。

00:09:33.000 --> 00:09:37.000
私たちは良いレビューを得るために、彼らのスープをより優先します。

00:09:37.000 --> 00:09:50.000
彼らがスープを待つとき、すべての子タスクの優先順位がエスカレートし、優先順位の高いタスクが優先順位の低いタスクを待っていないことを確認し、優先順位の反転を回避します。

00:09:50.000 --> 00:09:57.000
優先度の高いタスクの結果を待つと、タスクツリー内のすべての子タスクの優先度がエスカレートします。

00:09:57.000 --> 00:10:07.000
タスクグループの次の結果を待つと、次に完了する可能性が最も高いものがわからないため、グループ内のすべての子タスクがエスカレートすることに注意してください。

00:10:07.000 --> 00:10:16.000
並行性ランタイムは優先度キューを使用してタスクをスケジュールするため、優先度の高いタスクは優先度の低いタスクの前に実行するように選択されます。

00:10:16.000 --> 00:10:20.000
タスクは、その寿命の残りの期間、エスカレートされた優先順位を維持します。

00:10:20.000 --> 00:10:23.000
優先エスカレーションを元に戻すことはできません。

00:10:23.000 --> 00:10:31.000
私たちは迅速なスープ配達でVIPゲストを効果的に満足させ、良いレビューを得たので、私たちのキッチンは今人気になり始めています。

00:10:31.000 --> 00:10:37.000
私たちは、リソースを効果的に使用していることを確認したいし、多くのチョッピングタスクを作成していることに気づきました。

00:10:37.000 --> 00:10:43.000
タスクグループとの並行性を管理するための便利なパターンをいくつか調べてみましょう。

00:10:43.000 --> 00:10:45.000
私たちは非常に多くのまな板のためのスペースしかありません。

00:10:45.000 --> 00:10:56.000
同時に材料を切り刻みすぎると、他のタスクのためのスペースが足りなくなるので、同時に切り刻まれる材料の数を制限したいと考えています。

00:10:56.000 --> 00:11:03.000
コードに戻って、チョッピングタスクを作成するループを調査したい。

00:11:03.000 --> 00:11:10.000
各成分の元のループを、チョッピングタスクの最大数まで起動するループに置き換えます。

00:11:10.000 --> 00:11:18.000
次に、結果を収集するループで、以前のタスクが終了するたびに新しいタスクを開始します。

00:11:18.000 --> 00:11:28.000
新しいループは、実行中のタスクの1つが終了するまで待機し、まだチョップする材料がありますが、次の成分をチョップする新しいタスクを追加します。

00:11:28.000 --> 00:11:32.000
パターンをより明確に見るために、このアイデアを抽出しましょう。

00:11:32.000 --> 00:11:37.000
最初のループは、最大数の同時タスクを作成し、作成しすぎないようにします。

00:11:37.000 --> 00:11:42.000
最大数のタスクが実行されたら、1つが終了するのを待ちます。

00:11:42.000 --> 00:11:49.000
それが終了し、停止条件に達していない後、進歩し続けるための新しいタスクを作成します。

00:11:49.000 --> 00:11:57.000
これにより、以前のタスクが終了するまで新しい作業を開始しないため、グループ内の同時タスクの数が制限されます。

00:11:57.000 --> 00:12:04.000
先ほど、シフトで働くシェフと、シフトがいつ終わったかを示すためにキャンセルを使用することについて話しました。

00:12:04.000 --> 00:12:07.000
これは、シフトを処理するキッチンサービスコードです。

00:12:07.000 --> 00:12:11.000
各料理人は別々のタスクでシフトを開始します。

00:12:11.000 --> 00:12:14.000
料理人が働いたら、タイマーを始めます。

00:12:14.000 --> 00:12:18.000
タイマーが終了したら、進行中のシフトをすべてキャンセルします。

00:12:18.000 --> 00:12:23.000
どのタスクも値を返さないことに注意してください。

00:12:23.000 --> 00:12:27.000
Swift 5.9の新機能には、withDiscardingTaskGroup APIがあります。

00:12:27.000 --> 00:12:32.000
タスクグループを破棄することは、完了した子タスクの結果を保持しません。

00:12:32.000 --> 00:12:37.000
タスクで使用されるリソースは、タスクが終了した直後に解放されます。

00:12:37.000 --> 00:12:42.000
実行メソッドを変更して、破棄タスクグループを利用することができます。

00:12:42.000 --> 00:12:48.000
タスクグループを破棄すると、自動的に子がクリーンアップされるため、グループを明示的にキャンセルしてクリーンアップする必要はありません。

00:12:48.000 --> 00:12:52.000
破棄タスクグループには、兄弟の自動キャンセルもあります。

00:12:52.000 --> 00:12:59.000
子タスクのいずれかがエラーをスローすると、残りのタスクはすべて自動的にキャンセルされます。

00:12:59.000 --> 00:13:02.000
これはここでのユースケースに最適です。

00:13:02.000 --> 00:13:10.000
シフトが終わったら「TimeToCloseError」をスローすることができ、すべてのシェフのシフトが自動的に終了します。

00:13:10.000 --> 00:13:18.000
新しい破棄タスクグループは、結果を収集する必要がある通常のタスクグループとは異なり、タスクが終了すると自動的にリソースを解放します。

00:13:18.000 --> 00:13:26.000
これは、リクエストのストリームを処理しているときなど、何も返す必要がないタスクがたくさんあるときに、メモリ消費量を減らすのに役立ちます。

00:13:26.000 --> 00:13:33.000
状況によっては、タスクグループから値を返すだけでなく、同時タスクの数を制限したいこともあります。

00:13:33.000 --> 00:13:42.000
あるタスクの完了を使用して別のタスクを開始し、タスクの爆発を回避するための一般的なパターンを取り上げました。

00:13:42.000 --> 00:13:47.000
私たちはこれまで以上に効率的にスープを作っていますが、まだもっとスケールアップする必要があります。

00:13:47.000 --> 00:13:49.000
プロダクションをサーバーに移行する時が来ました。

00:13:49.000 --> 00:13:53.000
それに伴い、処理される注文を追跡するという課題が伴います。

00:13:53.000 --> 00:13:56.000
タスクローカルの値は助けるためにここにあります。

00:13:56.000 --> 00:14:03.000
タスクローカル値は、特定のタスク、より正確にはタスク階層に関連付けられたデータです。

00:14:03.000 --> 00:14:10.000
これはグローバル変数のようなものですが、タスクローカル値にバインドされた値は、現在のタスク階層からのみ使用できます。

00:14:10.000 --> 00:14:16.000
タスクローカル値は、「TaskLocal」プロパティラッパーで静的プロパティとして宣言されます。

00:14:16.000 --> 00:14:19.000
タスクをローカルにオプションにするのは良い習慣です。

00:14:19.000 --> 00:14:28.000
値が設定されていないタスクは、オプションのnilで簡単に表されるデフォルト値を返す必要があります。

00:14:28.000 --> 00:14:32.000
ローカルのバインドされていないタスクには、そのデフォルト値が含まれています。

00:14:32.000 --> 00:14:39.000
私たちの場合、オプションの文字列があるので、それはnilであり、現在のタスクに関連付けられたクックはありません。

00:14:39.000 --> 00:14:46.000
タスクローカル値は明示的に割り当てることはできませんが、特定のスコープにバインドする必要があります。

00:14:46.000 --> 00:14:54.000
バインディングはスコープの期間中持続し、スコープの最後に元の値に戻ります。

00:14:54.000 --> 00:14:59.000
タスクツリーに戻ると、各タスクにはタスクローカル値に関連する場所があります。

00:14:59.000 --> 00:15:05.000
スープを作る前に、「さくら」という名前を「クック」タスクローカル変数にバインドしました。

00:15:05.000 --> 00:15:08.000
makeSoupのみがバインドされた値を保存します。

00:15:08.000 --> 00:15:13.000
子は、タスクローカルストレージに保存された値を持っていません。

00:15:13.000 --> 00:15:21.000
タスクローカル変数にバインドされた値を探すには、その値を持つタスクを見つけるまで、各親を再帰的に歩く必要があります。

00:15:21.000 --> 00:15:26.000
値がバインドされたタスクが見つかった場合、ローカルのタスクはその値を想定します。

00:15:26.000 --> 00:15:34.000
親がないタスクによって示されるルートに到達すると、ローカルタスクはバインドされておらず、元のデフォルト値を取得します。

00:15:34.000 --> 00:15:38.000
Swiftランタイムは、これらのクエリをより高速に実行するために最適化されています。

00:15:38.000 --> 00:15:44.000
木を歩く代わりに、探している鍵でタスクを直接参照します。

00:15:44.000 --> 00:15:51.000
タスクツリーの再帰的な性質は、前者の値を失うことなく、値をシャドーイングするのに適しています。

00:15:51.000 --> 00:15:56.000
スープ製造プロセスの現在のステップを追跡したいとします。

00:15:56.000 --> 00:16:03.000
「step」変数を「makeSoup」の「soup」にバインドし、「chopIngredients」の「chop」に再バインドできます。

00:16:03.000 --> 00:16:12.000
chopIngredientsにバインドされた値は、元の値を観察する chopIngredientsから戻るまで、前者の値をシャドウします。

00:16:12.000 --> 00:16:18.000
ビデオ編集の魔法の力を通じて、私たちはスープの需要に追いつくためにサービスをクラウドに移行しました。

00:16:18.000 --> 00:16:23.000
私たちはまだ同じスープ作り機能を持っていますが、代わりにサーバー上にあります。

00:16:23.000 --> 00:16:32.000
注文がシステムを通過するのを観察し、タイムリーに完了していることを確認し、予期しない障害を監視する必要があります。

00:16:32.000 --> 00:16:41.000
サーバー環境は多くのリクエストを同時に処理するため、特定の順序を追跡できる情報を含める必要があります。

00:16:41.000 --> 00:16:46.000
手作業でのロギングは反復的で冗長であり、微妙なバグやタイプミスにつながります。

00:16:46.000 --> 00:16:51.000
ああ、いや、注文IDだけでなく、誤って注文全体をログに記録してしまいました。

00:16:51.000 --> 00:16:57.000
タスクローカル値を使用して、ロギングの信頼性を高める方法を見つけましょう。

00:16:57.000 --> 00:17:08.000
Appleデバイスでは、OSLog APIを直接使い続けたいと思うでしょうが、アプリケーションの一部がクラウドに移行するにつれて、他のソリューションが必要になります。

00:17:08.000 --> 00:17:19.000
SwiftLogは、複数のバッキング実装を備えたロギングAPIパッケージで、サーバーに変更を加えることなく、ニーズに合ったロギングバックエンドをドロップすることができます。

00:17:19.000 --> 00:17:24.000
MetadataProviderは、SwiftLog 1.5の新しいAPIです。

00:17:24.000 --> 00:17:34.000
メタデータプロバイダーを実装すると、ロギングロジックを簡単に抽象化し、関連する値に関する一貫した情報を確実に送信できます。

00:17:34.000 --> 00:17:40.000
メタデータプロバイダーは、辞書のような構造を使用し、ログに記録される値に名前をマッピングします。

00:17:40.000 --> 00:17:51.000
orderIDタスクローカル変数を自動的にログに記録したいので、定義されているかどうかを確認し、定義されている場合は辞書に追加します。

00:17:51.000 --> 00:18:05.000
複数のライブラリは、ライブラリ固有の情報を探すために独自のメタデータプロバイダーを定義できるため、MetadataProviderは、複数のメタデータプロバイダーを受け取り、それらを1つのオブジェクトに結合する「マルチプレックス」関数を定義します。

00:18:05.000 --> 00:18:14.000
メタデータプロバイダーができたら、そのプロバイダーでロギングシステムを初期化し、ロギングを開始する準備が整いました。

00:18:14.000 --> 00:18:22.000
ログには、メタデータプロバイダーで指定された情報が自動的に含まれるので、ログメッセージに含めることを心配する必要はありません。

00:18:22.000 --> 00:18:28.000
ログは、注文0がキッチンに入り、シェフがその注文を受け取る場所として表示されます。

00:18:28.000 --> 00:18:37.000
メタデータプロバイダーの値はログに明確にリストされているため、スープ製造プロセスを通じて注文を簡単に追跡できます。

00:18:37.000 --> 00:18:41.000
タスクローカル値を使用すると、タスク階層に情報を添付できます。

00:18:41.000 --> 00:18:48.000
切り離されたタスクを除くすべてのタスクは、現在のタスクからタスクローカル値を継承します。

00:18:48.000 --> 00:18:59.000
それらは特定のスコープで特定のタスクツリーにバインドされており、タスク階層を介して追加のコンテキスト情報を伝播するための低レベルのビルディングブロックを提供します。

00:18:59.000 --> 00:19:07.000
次に、タスク階層とツールを使用して、同時分散システムをトレースしてプロファイリングします。

00:19:07.000 --> 00:19:11.000
Appleプラットフォームで並行性を扱うとき、Instrumentsはあなたの友達です。

00:19:11.000 --> 00:19:17.000
Swift Concurrencyインストゥルメントは、構造化されたタスク間の関係についての洞察を提供します。

00:19:17.000 --> 00:19:23.000
詳細については、セッション「Swiftの並行性の視覚化と最適化」をチェックしてください。

00:19:23.000 --> 00:19:31.000
インスツルメンツはまた、「インスツルメント内のHTTPトラフィックを分析する」セッションでHTTPトラフィックインスツルメントを導入しました。

00:19:31.000 --> 00:19:36.000
HTTPトラフィックアナライザは、ローカルで発生するイベントのトレースのみを表示します。

00:19:36.000 --> 00:19:46.000
プロファイルには、サーバーからの応答を待っている間に灰色のボックスが表示されるので、サーバーのパフォーマンスを向上させる方法を理解するには、より多くの情報が必要です。

00:19:46.000 --> 00:19:50.000
新しいSwift分散トレーシングパッケージをご紹介します。

00:19:50.000 --> 00:19:54.000
タスクツリーは、単一のタスク階層で子タスクを管理するのに最適です。

00:19:54.000 --> 00:20:04.000
分散トレースを使用すると、複数のシステムにわたるタスクツリーの利点を活用して、パフォーマンス特性とタスク関係についての洞察を得ることができます。

00:20:04.000 --> 00:20:16.000
Swift Distributed TracingパッケージにはOpenTelemetryプロトコルが実装されているため、ZipkinやJaegerなどの既存のトレースソリューションは箱から出してすぐに機能します。

00:20:16.000 --> 00:20:26.000
Swift Distributed Tracingの目標は、Xcode Instrumentsの不透明な「応答待ち」に、サーバーで何が起こっているかに関する詳細情報を記入することです。

00:20:26.000 --> 00:20:31.000
どこに集中する必要があるかを把握するために、サーバーコードを計測する必要があります。

00:20:31.000 --> 00:20:35.000
分散トレースは、ローカルでのトレースプロセスとは少し異なります。

00:20:35.000 --> 00:20:43.000
関数ごとのトレースを取得する代わりに、「withSpan」APIを使用してスパンでコードを計測します。

00:20:43.000 --> 00:20:49.000
スパンを使用すると、トレースシステムで報告されるコードの領域に名前を割り当てることができます。

00:20:49.000 --> 00:20:51.000
スパンは機能全体をカバーする必要はありません。

00:20:51.000 --> 00:20:56.000
それらは、特定の機能の特定の部分についてより多くの洞察を提供することができます。

00:20:56.000 --> 00:21:06.000
withSpanは、追加のトレースIDやその他のメタデータを使用してタスクに注釈を付け、トレースシステムがタスクツリーを単一のトレースにマージできるようにします。

00:21:06.000 --> 00:21:17.000
トレースシステムには、タスクのランタイムパフォーマンス特性に関する情報とともに、タスク階層に関する洞察を提供するのに十分な情報があります。

00:21:17.000 --> 00:21:20.000
スパン名はトレースUIに表示されます。

00:21:20.000 --> 00:21:27.000
混乱することなく、特定のスパンに関する情報を簡単に見つけることができるように、それらを短く説明的に保ちたいと思うでしょう。

00:21:27.000 --> 00:21:36.000
スパン属性を使用して追加のメタデータを添付できるので、スパン名をオーダーIDで乱雑にする必要はありません。

00:21:36.000 --> 00:21:51.000
ここでは、スパン名を「#function」ディレクティブに置き換えて、スパン名を関数名で自動的に塗りつぶし、スパン属性を使用して現在の注文IDをトレーサーに報告されたスパン情報に添付しました。

00:21:51.000 --> 00:21:56.000
トレースシステムは通常、特定のスパンを検査しながら属性を提示します。

00:21:56.000 --> 00:22:07.000
ほとんどのスパンには、HTTPステータスコード、要求と応答のサイズ、開始時間と終了時間、その他のメタデータが付属しており、システムを通過する情報を簡単に追跡できます。

00:22:07.000 --> 00:22:11.000
前のスライドで述べたように、独自の属性を定義できます。

00:22:11.000 --> 00:22:18.000
スパンを活用する方法のその他の例については、swift-distributed-tracing-extrasリポジトリをご覧ください。

00:22:18.000 --> 00:22:26.000
タスクが失敗してエラーが発生した場合、その情報もスパンで表示され、トレースシステムで報告されます。

00:22:26.000 --> 00:22:39.000
スパンにはタイミング情報とツリー内のタスクの関係の両方が含まれているため、タイミングレースによって引き起こされるエラーを追跡し、それらが他のタスクにどのように影響するかを特定するのに役立つ方法です。

00:22:39.000 --> 00:22:52.000
トレースシステムと、トレースIDを使用してタスクツリーを再構築する方法、および独自の属性をスパンに添付する方法について話しましたが、まだ分散システムへの作業を開始していません。

00:22:52.000 --> 00:22:56.000
トレースシステムの美しさは、これ以上やるべきことがないことです。

00:22:56.000 --> 00:23:09.000
キッチンサービスからチョッピングサービスを考慮し、同じコードを保持すると、トレースシステムは自動的にトレースを拾い、分散システムの異なるマシンに関連付けます。

00:23:09.000 --> 00:23:15.000
トレースビューは、スパンが別のマシンで実行されていることを示しますが、それ以外は同じになります。

00:23:15.000 --> 00:23:26.000
分散トレースは、HTTPクライアント、サーバー、その他のRPCシステムなど、システムのすべての部分がトレースを受け入れる場合に最も強力です。

00:23:26.000 --> 00:23:37.000
Swift Distributed Tracingは、タスクツリー上に構築されたタスクローカル値を活用して、信頼性の高いクロスノードトレースを生成するために必要なすべての情報を自動的に伝播します。

00:23:37.000 --> 00:23:52.000
構造化されたタスクは、並行システムの秘密を解き明かし、操作を自動的にキャンセルし、優先順位情報を自動的に伝播し、複雑な分散ワークロードの追跡を容易にするツールを提供します。

00:23:52.000 --> 00:23:57.000
これらのすべては、Swiftの並行性の構造化された性質のために機能します。

00:23:57.000 --> 00:24:05.000
このセッションが構造化された並行性についてあなたを興奮させ、構造化されていない代替手段を使用する前に構造化されたタスクに到達することを願っています。

00:24:05.000 --> 00:24:06.000
見てくれてありがとう!

00:24:06.000 --> 00:24:11.000
構造化された並行性を使用して、他にどのような有用なパターンを思いつくかを見るのが待ちきれません。

00:24:11.000 --> 00:24:15.000
うーん、スープ！

00:24:15.000 --> 23:59:59.000
♪ ♪

