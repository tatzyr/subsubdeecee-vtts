WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:14.000
ソフィア：こんにちは、「パラメータパックでAPIを一般化する」へようこそ。

00:00:14.000 --> 00:00:18.000
私の名前はソフィアで、Swiftコンパイラチームで働いています。

00:00:18.000 --> 00:00:26.000
今日は、Swiftパラメータパックと、それらが一般的なプログラミングで新しい次元の柔軟性を提供する方法についてお話しします。

00:00:26.000 --> 00:00:30.000
これは高度な話であり、既存のジェネリックシステムに基づいています。

00:00:30.000 --> 00:00:37.000
このトピックに慣れていない場合は、WWDC22の「Embrace Swift generics」を見ることをお勧めします。

00:00:37.000 --> 00:00:51.000
今日は、パラメータパックが解決できる問題の種類、ライブラリでパラメータパックに遭遇したときにパラメータパックについて考える方法、そして最後に、パラメータパックを利用する独自のコードを実装する方法について説明します。

00:00:51.000 --> 00:00:55.000
パラメータパックに飛び込む前に、それらが存在する理由を知ることが重要です。

00:00:55.000 --> 00:01:00.000
だから私はジェネリックとvariadicsについて少し話すことから始めます。

00:01:00.000 --> 00:01:07.000
あなたが書くコードは、基本的に値と型の2つのカテゴリで構成されています。

00:01:07.000 --> 00:01:13.000
異なる値をパラメータとして受け入れる関数を書くことで、値を抽象化できます。

00:01:13.000 --> 00:01:25.000
例としては、入力として度を表す任意のダブル値を受け入れ、出力のためにラジアンを表す新しいダブル値を返すラジアン(from:)関数があります。

00:01:25.000 --> 00:01:31.000
パラメータにさまざまなタイプを受け入れるジェネリックコードを書くことで、オーバータイプを抽象化できます。

00:01:31.000 --> 00:01:39.000
たとえば、標準ライブラリアレイタイプは、それを埋めたい任意の形式のデータを保持するように設計されています。

00:01:39.000 --> 00:01:47.000
これには、配列の特定のインスタンスに使用する具体的な型のプレースホルダである要素型パラメータがあります。

00:01:47.000 --> 00:01:53.000
どちらの場合も、具体的な値または具体的なタイプが抽象化の引数として渡されます。

00:01:53.000 --> 00:01:59.000
ほとんどの汎用コードは、型と値の両方を抽象化します。

00:01:59.000 --> 00:02:04.000
これを調べるために、サーバーにクエリを送信するためのコードを書くつもりです。

00:02:04.000 --> 00:02:16.000
その基本的な実装は、いくつかのペイロードタイプの要求を受け取り、それをクエリとしてサーバーに渡し、最後にペイロードタイプのサーバー応答を返します。

00:02:16.000 --> 00:02:21.000
この関数には1つのパラメータがありますが、同じ呼び出しで複数のリクエストを照会することをサポートしたいです。

00:02:21.000 --> 00:02:27.000
可変数の引数を持つ能力のために、可変パラメータがあります。

00:02:27.000 --> 00:02:34.000
可変パラメータにより、関数は単一のタイプの任意の数の引数を柔軟に受け入れることができます。

00:02:34.000 --> 00:02:37.000
しかし、可変パラメータには限界があります。

00:02:37.000 --> 00:02:45.000
たとえば、指定された引数を、長さが引数の数と同じタプルにマッピングしたい場合があります。

00:02:45.000 --> 00:02:52.000
ただし、可変パラメータでは、引数の長さに基づく戻り値の型を宣言する方法はありません。

00:02:52.000 --> 00:03:04.000
また、可変パラメータが型消去を使用せずにさまざまな型を受け入れる方法がないため、各引数の特定の静的型情報を保持する方法はありません。

00:03:04.000 --> 00:03:14.000
ジェネリックシステムと可変パラメータに欠けているのは、型情報を維持し、引数の数を変える能力です。

00:03:14.000 --> 00:03:22.000
今日、これを行う唯一の方法はオーバーロードであり、サポートする引数の上限を選択することを余儀なくされます。

00:03:22.000 --> 00:03:26.000
2つのパラメータで十分でしょうか？おそらくそうではありません。

00:03:26.000 --> 00:03:29.000
最大3つのパラメータを処理する方が良いです。

00:03:29.000 --> 00:03:31.000
しかし、私たちが4つ欲しい場合はどうなりますか?

00:03:31.000 --> 00:03:40.000
このオーバーロードパターンとその制限は、さまざまな数の型パラメータを概念的に処理するAPI全体に浸透しています。

00:03:40.000 --> 00:03:50.000
このアプローチには冗長性の欠点がありますが、さらに重要なのは、サポートされる引数の数に任意の上限を強制的に選択することです。

00:03:50.000 --> 00:03:56.000
選択した制限を超えると、追加の引数に関するコンパイラエラーが発生します。

00:03:56.000 --> 00:04:00.000
これは、パラメータパックが解決する種類の問題です。

00:04:00.000 --> 00:04:08.000
この過負荷パターンに陥っていることに気付いた場合、それはパラメータパックを使用したいという強い兆候です。

00:04:08.000 --> 00:04:18.000
Swift 5.9では、ジェネリックシステムは「パラメータパック」と呼ばれる新しい構造で、引数の長さに対する抽象化のファーストクラスのサポートを獲得しています。

00:04:18.000 --> 00:04:24.000
今から、APIでパラメータパックを見ると、パラメータパックが何を意味するのかについて話します。

00:04:24.000 --> 00:04:28.000
コードでは、ほとんどの場合、単一のタイプまたは値で作業します。

00:04:28.000 --> 00:04:37.000
パラメータパックは、任意の量の型または値を保持し、それらを一緒にパックして関数の引数として渡すことができます。

00:04:37.000 --> 00:04:41.000
個々のタイプを保持するパックは、タイプパックと呼ばれます。

00:04:41.000 --> 00:04:49.000
たとえば、Bool、Int、Stringの3つの個別のタイプを保持するタイプパックを持つことができます。

00:04:49.000 --> 00:04:54.000
個々の値を保持するパックは、バリューパックと呼ばれます。

00:04:54.000 --> 00:05:02.000
たとえば、true、数値10、空の文字列の3つの個々の値を保持する値パックを持つことができます。

00:05:02.000 --> 00:05:05.000
タイプパックとバリューパックは一緒に使用されます。

00:05:05.000 --> 00:05:12.000
タイプパックは、バリューパック内の個々の値ごとに個々のタイプを提供します。

00:05:12.000 --> 00:05:17.000
対応するタイプと値は、それぞれのパックで同じ位置にあります。

00:05:17.000 --> 00:05:22.000
位置0で、値trueの型はBoolです。

00:05:22.000 --> 00:05:27.000
位置1では、整数リテラル10のタイプはIntです。

00:05:27.000 --> 00:05:32.000
そして、位置2では、空の文字列リテラルのタイプは文字列です。

00:05:32.000 --> 00:05:39.000
パラメータパックを使用すると、パック内のすべての個々の要素で動作する一般的なコードを1つ書くことができます。

00:05:39.000 --> 00:05:48.000
Swiftでコレクションを使用するときに、異なる個々の要素で動作する1つのコードを書くことに慣れているので、この概念は身近に聞こえるかもしれません。

00:05:48.000 --> 00:05:51.000
そのようなコードを書く方法は、反復を通してです。

00:05:51.000 --> 00:05:58.000
たとえば、for-inループの本体は、配列の個々の要素を操作します。

00:05:58.000 --> 00:06:08.000
パラメータパックがコレクションと異なるのは、パック内の各要素が異なる静的型を持ち、型レベルでパックを操作できることです。

00:06:08.000 --> 00:06:16.000
通常、角括弧内に型パラメータを宣言することで、異なる具体的なタイプで動作する汎用コードを記述します。

00:06:16.000 --> 00:06:24.000
Swift 5.9では、キーワード「each」で型パラメータのパックを宣言できます。

00:06:24.000 --> 00:06:31.000
単一の型パラメータを持つ代わりに、関数はクエリする各ペイロード型を受け入れます。

00:06:31.000 --> 00:06:34.000
これはタイプパラメータパックと呼ばれます。

00:06:34.000 --> 00:06:45.000
タイプパックとバリューパックの名前を自然に読み取るには、「各ペイロード」ではなく「各ペイロード」などの単一の命名規則を使用します。

00:06:45.000 --> 00:06:53.000
パラメータパックを使用する汎用コードは、繰り返しパターンを使用して各ペイロードを個別に操作できます。

00:06:53.000 --> 00:07:00.000
繰り返しパターンは「繰り返し」キーワードを使用して表現され、その後にパターンタイプと呼ばれるタイプが続きます。

00:07:00.000 --> 00:07:05.000
パターンには、パック要素への1つ以上の参照が含まれます。

00:07:05.000 --> 00:07:12.000
「繰り返し」は、指定された引数パック内のすべての要素に対してパターンタイプが繰り返されることを示します。

00:07:12.000 --> 00:07:19.000
「それぞれ」は、すべての反復で個々のパック要素に置き換えられるプレースホルダとして機能します。

00:07:19.000 --> 00:07:24.000
この交換が、Bool、Int、Stringを含む具体的なタイプのパックでどのように機能するかを見てみましょう。

00:07:24.000 --> 00:07:34.000
パターンは3回繰り返され、プレースホルダ「各ペイロード」は各繰り返しの間にパック内の具体的なタイプに置き換えられます。

00:07:34.000 --> 00:07:42.000
結果は、タイプのカンマ区切りリストです: Boolの要求、Intの要求、および文字列の要求。

00:07:42.000 --> 00:07:52.000
繰り返しパターンは、カンマで区切られたタイプのリストを生成するため、自然にカンマで区切られたリストを受け入れる位置でのみ使用できます。

00:07:52.000 --> 00:07:59.000
これには、タプル型または単一型のいずれかである括弧で囲まれた型が含まれます。

00:07:59.000 --> 00:08:07.000
さらに、それらは関数パラメータリストで使用でき、繰り返しパターンは一般的な引数リストで使用できます。

00:08:07.000 --> 00:08:16.000
繰り返しパターンを関数パラメータのタイプとして使用すると、その関数パラメータが値パラメータパックに変換されます。

00:08:16.000 --> 00:08:27.000
これにより、呼び出し元の任意の数のリクエストインスタンスを渡すことができ、引数値はパックに収集され、関数に渡されます。

00:08:27.000 --> 00:08:32.000
これは、パラメータパックの基本的な概念と使用される構文をカバーしています。

00:08:32.000 --> 00:08:40.000
次に、APIの機能を簡素化および拡張する方法を実証するために、クエリAPIに戻りましょう。

00:08:40.000 --> 00:08:47.000
可変要求引数と対応する戻り値タイプを提供するために、複数の汎用オーバーロードを追加しました。

00:08:47.000 --> 00:08:52.000
各過負荷の宣言は、予測可能なパターンに従います。

00:08:52.000 --> 00:08:58.000
各オーバーロードには、それぞれ1、2、3、および4つのタイプのパラメータがあります。

00:08:58.000 --> 00:09:04.000
各オーバーロードは、各タイプのパラメータをパラメータリストのそのタイプのリクエストにマップします。

00:09:04.000 --> 00:09:09.000
そして、各オーバーロードには、戻り値タイプの各型パラメータのリストが含まれています。

00:09:09.000 --> 00:09:15.000
パラメータパックを使用すると、これらの4つのオーバーロードを1つの関数に折りたたむことができます。

00:09:15.000 --> 00:09:22.000
まず、型パラメータ宣言、次に関数パラメータリスト、そして最後に戻り値の型を考えてみましょう。

00:09:22.000 --> 00:09:27.000
各タイプパラメータは、タイプパラメータパックに折りたたむことができます。

00:09:27.000 --> 00:09:33.000
個々のリクエストパラメータは、値パラメータパックに折りたたむことができます。

00:09:33.000 --> 00:09:40.000
また、リターンタイプは、各ペイロードタイプを繰り返すことによって構築されたタプルに折りたたむことができます。

00:09:40.000 --> 00:09:44.000
これで、任意の数のリクエスト引数を処理できるクエリ関数が1つあります。

00:09:44.000 --> 00:10:00.000
関数パラメータと戻り値タイプは、どちらもタイプパラメータパック「各ペイロード」の従属タイプであるため、関数の値パラメータパックの長さは常に返されるタプル内の要素数と一致することがわかります。

00:10:00.000 --> 00:10:10.000
このAPIでパラメータパックを採用したので、この単一のクエリ関数を1つの引数または3つの引数、または任意の量で呼び出すことができます。

00:10:10.000 --> 00:10:13.000
パラメータパックは、すべての引数の長さを同じように処理します。

00:10:13.000 --> 00:10:17.000
3つの議論で電話に集中しましょう。

00:10:17.000 --> 00:10:21.000
具体的な引数パックは、コールサイトの引数から推測されます。

00:10:21.000 --> 00:10:28.000
プレースホルダ「各ペイロード」のすべての具体的なタイプは、引数リストからタイプパックに収集されます。

00:10:28.000 --> 00:10:33.000
そして、コンクリートタイプのパックは、リターンタイプを生成するために代用されます。

00:10:33.000 --> 00:10:38.000
「各ペイロード」は、パラメータリストと戻り値タイプに表示されます。

00:10:38.000 --> 00:10:48.000
コンクリートタイプのパック「Int、String、Bool」は両方の場所で置き換えられ、パターンが3回繰り返されます。

00:10:48.000 --> 00:10:55.000
結局のところ、実行されるコードは、タイプパックの3つのタイプすべての反復に相当します。

00:10:55.000 --> 00:11:00.000
では、クエリAPIに戻って、パラメータパックに制約を追加する方法を見てみましょう。

00:11:00.000 --> 00:11:04.000
クエリペイロードがEquatableであると仮定します。

00:11:04.000 --> 00:11:15.000
タイプパラメータパックの後にコロンとプロトコル名Equatableを追加することで、ペイロードパック内のすべての要素がEquatableに準拠する必要があります。

00:11:15.000 --> 00:11:20.000
より一般的な要件は、通常のジェネリック医薬品と同様に、「where」句で宣言できます。

00:11:20.000 --> 00:11:32.000
パラメータパックには0個以上の引数を含めることができることを覚えておいてください、このサーバークエリAPIにはゼロ引数を受け入れる特別な理由がないと思うかもしれません。

00:11:32.000 --> 00:11:36.000
幸いなことに、最小の引数の長さを要求する簡単なテクニックがあります。

00:11:36.000 --> 00:11:43.000
この場合、関数に何かを与えるために、少なくとも1つの引数を要求したい。

00:11:43.000 --> 00:11:53.000
これを達成するために、タイプパラメータパックの前に通常のタイプパラメータを追加し、値パラメータパックの前に対応する値パラメータを追加します。

00:11:53.000 --> 00:12:01.000
型パラメータパックの制約は、新しい型パラメータにも適用する必要があります。この例では、Equatableに準拠しています。

00:12:01.000 --> 00:12:05.000
今、あなたの関数への呼び出し者は、少なくとも1つの引数を提供する必要があります。

00:12:05.000 --> 00:12:12.000
この時点で、どのパラメータパックが解決し、APIでそれらを読む方法の基礎をカバーしました。

00:12:12.000 --> 00:12:16.000
次に、パラメータパックを使用するコードを実装する方法について説明します。

00:12:16.000 --> 00:12:21.000
パラメータパックを使用してサーバークエリの実装を構築します。

00:12:21.000 --> 00:12:30.000
クエリ関数は、個々の要素がタイプパック内のすべての要素に対するリクエストである値パックを受け入れます。

00:12:30.000 --> 00:12:39.000
リクエスト構造体には、ペイロードと呼ばれる単一の型パラメータと、ペイロードのインスタンスを返す評価メソッドがあります。

00:12:39.000 --> 00:12:44.000
クエリ関数の本体は、「項目」値パックで動作します。

00:12:44.000 --> 00:12:51.000
クエリの本文内で、バリューパック内のすべての項目について評価メソッドを呼び出したい。

00:12:51.000 --> 00:12:54.000
繰り返しパターンを使ってこれを表現できます。

00:12:54.000 --> 00:13:01.000
繰り返しパターンは、型レベルと値レベルで同じ構文を使用して表現されます。

00:13:01.000 --> 00:13:06.000
値レベルでは、「repeat」キーワードの後にパターン式が続きます。

00:13:06.000 --> 00:13:11.000
パターン式には、1つ以上のバリューパックが含まれます。

00:13:11.000 --> 00:13:17.000
パックは、含まれているすべての値を介して反復され、式は値ごとに1回評価されます。

00:13:17.000 --> 00:13:25.000
タプルに含まれるすべての評価結果のリストを作成するには、パターン式を括弧で囲むことができます。

00:13:25.000 --> 00:13:31.000
関数に渡される値パックが空の場合、結果は空のタプルになります。

00:13:31.000 --> 00:13:36.000
値パックに単一の要素がある場合、結果は別の単一の値になります。

00:13:36.000 --> 00:13:40.000
バリューパックに複数の要素がある場合、結果はタプルになります。

00:13:40.000 --> 00:13:41.000
そして、それだけです。

00:13:41.000 --> 00:13:52.000
これで、結果の値パックを受け入れ、すべての個々の要求を評価し、すべての要求の結果をタプルで一緒に返すクエリ関数があります。

00:13:52.000 --> 00:13:57.000
これは、コードでパラメータパックを使用する方法の基礎です。

00:13:57.000 --> 00:14:08.000
これは、パラメータパックではなく複数のオーバーロードを使用した以前の例よりもはるかに少ないコードであり、そのバージョンには実装さえありませんでした。

00:14:08.000 --> 00:14:14.000
メンテナンスはより簡単で、反復的なコードパターンからしばしば発生するエラーはなくなりました。

00:14:14.000 --> 00:14:16.000
では、もう少し柔軟性を加えましょう。

00:14:16.000 --> 00:14:31.000
私の例をリファクタリングして、クエリAPIが状態を保存できるようにし、各リクエスト評価が異なる入力タイプと出力タイプを持つようにし、パラメータパックの反復中に制御フローを管理します。

00:14:31.000 --> 00:14:40.000
クエリ関数を評価者構造体内に移動し、タイプパラメータパックをクエリメソッドから評価者タイプに持ち上げます。

00:14:40.000 --> 00:14:47.000
Evaluator struct は、リクエスト パックを括弧で囲んでタプル値にすることで、保存されたプロパティに格納できます。

00:14:47.000 --> 00:14:57.000
具体的なペイロードタイプの引数パックが与えられた場合、「項目」変数は、単一の要求またはすべての要求のタプルのいずれかになります。

00:14:57.000 --> 00:15:04.000
次に、リクエストを構造体から、Outputという名前の関連型を持つプロトコルに変更します。

00:15:04.000 --> 00:15:09.000
そして、Inputという名前のリクエストプロトコルに別の関連タイプを追加します。

00:15:09.000 --> 00:15:15.000
次に、リクエストの評価メソッドを更新して、その引数をプロトコルの入力タイプにします。

00:15:15.000 --> 00:15:20.000
これにより、メソッドの戻り値の型が引数の型の型と異なることができます。

00:15:20.000 --> 00:15:40.000
この後、すべてのペイロードタイプがリクエストに準拠するように評価者を更新し、それに応じて「アイテム」の保存プロパティを単に「各ペイロード」タイプに更新します。しかし、現時点では、評価者のタイプパラメータパックの「ペイロード」という名前はあまり当てはまらない。

00:15:40.000 --> 00:15:46.000
ペイロードは、もはやリクエストに含まれるものではなく、代わりにリクエスト全体に準拠しています。

00:15:46.000 --> 00:15:53.000
したがって、ペイロードの名前をRequestに変更し、プロトコルの名前をRequestProtocolに変更します。

00:15:53.000 --> 00:16:02.000
クエリメソッドは、各リクエストの入力タイプのパックを受け入れることができ、各リクエストの出力タイプのリストを返します。

00:16:02.000 --> 00:16:11.000
最後に、クエリメソッドへの新しいパラメータ「input」は、すべての項目の評価メソッドの呼び出しに渡す必要があります。

00:16:11.000 --> 00:16:19.000
これで、サーバーの応答から、クエリに含まれるデータの種類とは異なるタイプを返すことができます。

00:16:19.000 --> 00:16:30.000
メソッドの値引数パックの長さは、そのタイプが両方とも評価者の型パックに基づいているため、返される値パックの長さと一致することを知ることができます。

00:16:30.000 --> 00:16:35.000
保存されたプロパティ「item」の引数の長さについても同様です。

00:16:35.000 --> 00:16:43.000
パラメータパックの使用が反復の一形態であることを考えると、反復から早期に終了したい場合は、制御フローについて疑問に思うかもしれません。

00:16:43.000 --> 00:16:50.000
おそらく、クエリのコレクションの結果は、すべてのクエリが成功した場合にのみ有効になるはずです。

00:16:50.000 --> 00:16:53.000
これにはスローエラーを使用できます。

00:16:53.000 --> 00:17:03.000
この例では、RequestProtocolの評価メソッドをスロー関数に更新し、評価者のクエリメソッドの戻り値タイプをオプションに変更できます。

00:17:03.000 --> 00:17:12.000
クエリメソッドの本文をdo-catchステートメントに移動し、do句内にreturnステートメントを配置し、catch句からnilを返すことができます。

00:17:12.000 --> 00:17:20.000
これで、個々のクエリの評価は、必要に応じて、すべてのクエリの反復を停止することができます。

00:17:20.000 --> 00:17:29.000
このセッションでは、パラメータパックで型を抽象化する方法と、汎用コードの引数について話しました。

00:17:29.000 --> 00:17:41.000
パラメータパックを使用して、以前は多数のオーバーロードが必要だった単一の汎用実装を書くことで、コードの制限を簡素化および削除する方法について説明しました。

00:17:41.000 --> 00:17:48.000
最後に、パラメータパックを利用しながらサーバーへのクエリの送信を実装するためのコードを書きました。

00:17:48.000 --> 00:17:54.000
ジェネリックの詳細については、WWDC22のセッション「Embrace Swiftジェネリック」をチェックしてください。

00:17:54.000 --> 00:18:03.000
また、プロトコルとタイプの消去の詳細については、WWDC22のセッション「Swiftでプロトコルインターフェイスを設計する」をチェックしてください。

00:18:03.000 --> 00:18:13.000
Swiftパラメータパックは、一般的なジェネリックパターンを簡素化することを可能にすると同時に、ジェネリックコードで可能なことを拡張するための強力なツールです。

00:18:13.000 --> 00:18:15.000
あなたが彼らと一緒に何を作るかを見るのが待ちきれません。

00:18:15.000 --> 23:59:59.000
ご覧いただきありがとうございます。

