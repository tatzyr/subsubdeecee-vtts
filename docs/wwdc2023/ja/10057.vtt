WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:13.000
タイラー：「UIKit特性システムを解き放つ」へようこそ。

00:00:13.000 --> 00:00:23.000
私はUIフレームワークエンジニアのタイラー・フォックスです。iOS 17で活用できる素晴らしい新しいUIKit機能についてお伝えできることを嬉しく思います。

00:00:23.000 --> 00:00:28.000
まず、UIKitの特性システムに関する基礎を確認します。

00:00:28.000 --> 00:00:46.000
次に、UITraitCollectionに独自のデータを追加するためのカスタム特性を定義する機能、アプリの階層に特性オーバーライドを適用する簡単な方法、特性が変更されたときに処理するより柔軟な方法など、新しい機能と機能をご案内します。

00:00:46.000 --> 00:00:57.000
最後に、UIKitの特性とSwiftUI環境キーをブリッジして、アプリ内のUIKitとSwiftUIコンポーネント間でデータをシームレスに渡す方法を説明します。

00:00:57.000 --> 00:01:00.000
いくつかのファンダメンタルズを見直す時が来ました。

00:01:00.000 --> 00:01:08.000
特性は、システムがアプリ内のすべてのビューコントローラーとビューに自動的に伝播する独立したデータです。

00:01:08.000 --> 00:01:18.000
UIKitは、ユーザーインターフェイススタイル、水平サイズクラス、優先コンテンツサイズカテゴリなど、多くの組み込みシステム特性を提供します。

00:01:18.000 --> 00:01:23.000
iOS 17では、独自のカスタム特性も定義できます。

00:01:23.000 --> 00:01:30.000
これにより、アプリのビューコントローラーとビューにデータを提供する強力な新しい方法が解放されます。

00:01:30.000 --> 00:01:34.000
カスタム特性については、少し後でお話しします。

00:01:34.000 --> 00:01:39.000
UIKitで特性を扱う主な方法は、特性コレクションを使用することです。

00:01:39.000 --> 00:01:44.000
トレイトコレクションには、トレイトとその関連値が含まれています。

00:01:44.000 --> 00:01:50.000
iOS 17には、トレイトコレクションの操作を容易にする新しいAPIがいくつかあります。

00:01:50.000 --> 00:01:54.000
まず、クロージャを取る新しい初期化子があります。

00:01:54.000 --> 00:02:01.000
そのクロージャの中で、値を設定できる変更可能な特性コンテナを受け取ります。

00:02:01.000 --> 00:02:08.000
この可変コンテナは、UIMutableTraitsという名前の新しいプロトコルに準拠しています。

00:02:08.000 --> 00:02:15.000
クロージャの中で、ユーザーインターフェイスのイディオムを電話に設定し、水平サイズクラスをレギュラーに設定しました。

00:02:15.000 --> 00:02:26.000
クロージャの実行が終了すると、初期化子は、クロージャ内で設定したすべてのトレイト値を含む不変のUITraitCollectionインスタンスを返します。

00:02:26.000 --> 00:02:37.000
また、クロージャ内の元のトレイトコレクションから値を変更して新しいインスタンスを作成できる新しいmodifytTraitsメソッドもあります。

00:02:37.000 --> 00:02:46.000
ここでは、水平サイズクラスをコンパクトに変更し、ユーザーインターフェイススタイルの暗い値を入力しました。

00:02:46.000 --> 00:02:55.000
私はユーザーインターフェイスのイディオムを変更していないので、それは私の元の特性コレクションから電話と等しいままです。

00:02:55.000 --> 00:03:03.000
このような独自のトレイトコレクションを作成できますが、ほとんどの場合、トレイト環境からトレイトコレクションを取得します。

00:03:03.000 --> 00:03:11.000
アプリの特性環境は、ウィンドウシーン、ウィンドウ、プレゼンテーションコントローラー、ビューコントローラー、ビューです。

00:03:11.000 --> 00:03:20.000
これらの特性環境にはそれぞれ独自の特性コレクションがあり、各特性コレクションには異なる値が含まれている場合があります。

00:03:20.000 --> 00:03:27.000
特性環境は、特性階層に接続されています。これは、特性がアプリを流れる方法です。

00:03:27.000 --> 00:03:36.000
以下は、各ウィンドウシーンから個々のビューコントローラーとビューまで、トレイト階層のツリー構造の例です。

00:03:36.000 --> 00:03:41.000
各トレイト環境は、親環境からトレイト値を継承します。

00:03:41.000 --> 00:03:47.000
可能な限り最も具体的な特性環境の特性コレクションを常に使用してください。

00:03:47.000 --> 00:03:55.000
特性がビューコントローラーとビューを流れる方法をより深く掘り下げます。

00:03:55.000 --> 00:04:00.000
以下は、子ビューコントローラーを含む親ビューコントローラーの例です。

00:04:00.000 --> 00:04:04.000
破線はビューコントローラーの階層を表します。

00:04:04.000 --> 00:04:11.000
親コントローラはビューを所有し、それらを接続する実線はそれらの関係を表します。

00:04:11.000 --> 00:04:19.000
親ビューには1つのサブビューがあり、ビューを通る破線はビュー階層を表します。

00:04:19.000 --> 00:04:25.000
最後に、子コントローラのビューは、その中間ビューのサブビューです。

00:04:25.000 --> 00:04:33.000
まず、iOS 17より前に、ビューコントローラーとビューで特性がどのように流れていたかを説明します。

00:04:33.000 --> 00:04:38.000
ビューコントローラーは、親のビューコントローラーから直接特性を継承しました。

00:04:38.000 --> 00:04:45.000
そして、ビューコントローラーが所有するビューは、ビューコントローラーから直接特性を継承しました。

00:04:45.000 --> 00:04:52.000
最後に、ビューコントローラーのないビューは、スーパービューから直接特性を継承しました。

00:04:52.000 --> 00:04:59.000
この動作は、ビュー階層内の特性の流れが、ビューコントローラーが所有する各ビューで停止することを意味します。

00:04:59.000 --> 00:05:07.000
たとえば、親コントローラのビューからのトレイト値は、その直接サブビューによってのみ継承されます。

00:05:07.000 --> 00:05:15.000
子コントローラのビューは、それらのビューの下のビュー階層のサブビューであるにもかかわらず、その値を受け取りません。

00:05:15.000 --> 00:05:18.000
この行動は驚くべきことかもしれません。

00:05:18.000 --> 00:05:27.000
iOS 17では、ビューコントローラーとビューの特性階層を統一することで、この問題を排除しました。

00:05:27.000 --> 00:05:35.000
ビューコントローラーは、親ビューコントローラーから直接ではなく、ビューのスーパービューからトレイトコレクションを継承するようになりました。

00:05:35.000 --> 00:05:42.000
これにより、ビューコントローラーとビューを介して特性の単純な線形フローが作成されます。

00:05:42.000 --> 00:05:50.000
ビューコントローラーがまだ親ビューコントローラーから特性を継承する方法に注意してください、それはそれらの間のビューを介して間接的に起こります。

00:05:50.000 --> 00:06:02.000
ビューコントローラーはビュー階層から特性を継承するようになったため、ビューコントローラーが更新された特性を受け取るには、ビューコントローラーのビューが階層にある必要があります。

00:06:02.000 --> 00:06:12.000
その結果、ビューが階層に追加される前にビューコントローラーのトレイトコレクションにアクセスすると、ビューコントローラーはそのトレイトの最新の値を持ちません。

00:06:12.000 --> 00:06:23.000
影響を受けるコードを見つける最も一般的な場所は、ビューが階層に追加される前に常に呼び出されるため、viewWillAppear内です。

00:06:23.000 --> 00:06:29.000
代わりに使用できるviewIsAppearingという名前の新しいコールバックがあります。

00:06:29.000 --> 00:06:40.000
viewIsAppearingは、ビューが階層に追加され、ビューコントローラーとビューの両方が最新のトレイトコレクションを持つと、viewWillAppearの後に呼び出されます。

00:06:40.000 --> 00:06:47.000
viewIsAppearingは、今日viewWillAppearを使用しているほぼすべてのケースのドロップイン代替品です。

00:06:47.000 --> 00:06:54.000
そして、最良の部分は、この新しい方法がiOS 13に展開されることです。

00:06:54.000 --> 00:07:03.000
「UIKitの新機能」を見て、この新しいコールバックとそれがビューコントローラーのライフサイクルにどのように適合するかについて詳しく学んでください。

00:07:03.000 --> 00:07:09.000
iOS 17は、ビュー特性の更新の一貫性とパフォーマンスも向上させます。

00:07:09.000 --> 00:07:13.000
ビューは、階層内にある場合にのみ、特性コレクションを更新します。

00:07:13.000 --> 00:07:20.000
そして、階層に入ると、各ビューはレイアウトを実行する直前にトレイトコレクションを更新するだけです。

00:07:20.000 --> 00:07:24.000
ベストプラクティスは、レイアウト中に特性を使用することです。

00:07:24.000 --> 00:07:31.000
ビューの場合、それはlayoutSubviewsメソッド内からtraitCollectionを使用することを意味します。

00:07:31.000 --> 00:07:43.000
layoutSubviewsは、setNeedsLayoutがビューで呼び出されるたびに再び実行されるので、実装は複数回呼び出された場合、作業の重複を避ける必要があります。

00:07:43.000 --> 00:07:48.000
カスタム特性は、iOS 17の強力な新機能です。

00:07:48.000 --> 00:07:54.000
彼らは、あなたのビューコントローラーとビューにデータを提供するための全く新しい方法を開きます。

00:07:54.000 --> 00:08:02.000
アプリでデータを扱う際には、新しいカスタム特性を定義するタイミングを決定するのに役立つ次の点を考慮してください。

00:08:02.000 --> 00:08:13.000
特性は、親ビューコントローラーから複数の子ビューコントローラー、またはスーパービューからすべてのサブビューなど、多くの子にデータを伝播する必要がある場合に最適です。

00:08:13.000 --> 00:08:22.000
また、特性を使用して、多くのレイヤーに深くネストされている可能性のある他のコンポーネントにデータを渡すこともできます。

00:08:22.000 --> 00:08:35.000
特性は階層を通じて継承されるため、含まれているビューコントローラーに関する情報を提供するなど、環境に関するビューやビューコントローラーにコンテキストを提供できます。

00:08:35.000 --> 00:08:40.000
特性システムは強力ですが、それを使用してデータを伝播することは自由ではありません。

00:08:40.000 --> 00:08:48.000
最高のパフォーマンスを得るには、価値を追加するときに特性を使用しますが、データを直接簡単に渡すことができる場合は特性を使用しないでください。

00:08:48.000 --> 00:08:52.000
これで、最初のカスタム特性を定義する準備が整いました。

00:08:52.000 --> 00:09:02.000
アプリに設定画面があり、ビューが設定ビューコントローラーに含まれているかどうかを示す特性を実装したいと想像してみてください。

00:09:02.000 --> 00:09:06.000
ほんの数行のコードでカスタムトレイトを定義できます。

00:09:06.000 --> 00:09:12.000
まず、新しい構造体を宣言し、UITraitDefinitionプロトコルに準拠します。

00:09:12.000 --> 00:09:17.000
必要な静的プロパティであるdefaultValueを実装します。

00:09:17.000 --> 00:09:21.000
これは、値が設定されていない場合のトレイのデフォルト値です。

00:09:21.000 --> 00:09:28.000
各トレイト定義には、defaultValueから推測される関連する値タイプがあります。

00:09:28.000 --> 00:09:37.000
この場合、falseのdefaultValueを割り当てているので、この特性の値のタイプはBoolであると推測されます。

00:09:37.000 --> 00:09:45.000
以前にSwiftUIでカスタム環境キーを定義したことがあるなら、これは非常に身近に感じるはずです。

00:09:45.000 --> 00:09:52.000
トレイトを定義したら、UITraitCollectionとUIMutableTraitsの新しいAPIですぐに使用できます。

00:09:52.000 --> 00:09:58.000
この特性は、値を取得して設定するために使用するキーと考えることができます。

00:09:58.000 --> 00:10:08.000
新しいUITraitCollectionイニシャライザ内では、UIMutableTraitsの添字演算子を使用して、トレイトの値を設定できます。

00:10:08.000 --> 00:10:15.000
そして、UITraitCollectionの添字演算子を使用して、特性の値を読み戻すことができます。

00:10:15.000 --> 00:10:24.000
2つの簡単な拡張機能を追加すると、すべてのシステム特性と同様に、標準のプロパティ構文を使用してこの特性にアクセスできます。

00:10:24.000 --> 00:10:31.000
ここでは、不変のUITraitCollectionクラスの拡張で読み取り専用プロパティを宣言しました。

00:10:31.000 --> 00:10:38.000
そして、UIMutableTraitsプロトコルの拡張で読み取り/書き込みプロパティを宣言しました。

00:10:38.000 --> 00:10:46.000
これらの非常にシンプルな拡張機能を追加したので、標準のプロパティ構文を使用して、どこでも自分の特性にアクセスできます。

00:10:46.000 --> 00:10:52.000
独自のカスタム特性を定義するときは、常にこれらの拡張機能を書いてください。

00:10:52.000 --> 00:10:55.000
私は別のカスタム特性のアイデアを持っています。

00:10:55.000 --> 00:10:59.000
私のアプリでカスタムカラーテーマのサポートを構築していると想像してみてください。

00:10:59.000 --> 00:11:08.000
私のアプリがサポートする4つの異なるカラーテーマを表すMyAppThemeという名前の列挙型があります。

00:11:08.000 --> 00:11:15.000
私が最初に行うことは、UITraitDefinitionプロトコルに準拠した新しい構造体を宣言することです。

00:11:15.000 --> 00:11:20.000
この特性のデフォルト値として標準テーマを使用します。

00:11:20.000 --> 00:11:34.000
この新しいテーマ特性をアプリのカスタムダイナミックカラーで使用する予定なので、この特性が色の外観に影響し、この特性が変更されるとシステムが自動的にビューを再描画することを示しています。

00:11:34.000 --> 00:11:43.000
色の外観に影響を与える特性ははるかに高価であるため、これを控えめに、まれに変化する特性にのみ使用してください。

00:11:43.000 --> 00:11:48.000
トレイトには、デバッガにトレイトを印刷するなどに使用される名前もあります。

00:11:48.000 --> 00:11:59.000
デフォルトでは、特性タイプ自体の名前を使用しますが、「テーマ」のような短い名前を付けることができます。そして最後に、識別子文字列を提供できます。

00:11:59.000 --> 00:12:04.000
この識別子により、特性はエンコーディングなどの追加機能の対象となります。

00:12:04.000 --> 00:12:12.000
リバースDNS形式を使用して、各特性の識別子がアプリでグローバルに一意であることを確認します。

00:12:12.000 --> 00:12:25.000
通常のプロパティ構文を使用してこの特性を設定して取得できるようにしたいので、前の例と同じように、UITraitCollectionとUIMutableTraitsを拡張してプロパティを宣言します。

00:12:25.000 --> 00:12:29.000
そして、カスタムテーマ特性を実装するために必要なのはそれだけです。

00:12:29.000 --> 00:12:32.000
今、私はこの新しい特性を使い始めることができます。

00:12:32.000 --> 00:12:40.000
たとえば、テーマに基づいて外観を変更するカスタムダイナミックカラーを定義する方法は次のとおりです。

00:12:40.000 --> 00:12:45.000
動的プロバイダー初期化子を使用して新しいUIColorを作成します。

00:12:45.000 --> 00:12:54.000
クロージャの中では、どの色を返すかを決定するために渡される特性コレクションのテーマを使用します。

00:12:54.000 --> 00:12:58.000
これで、このカスタム背景色をビューに設定できます。

00:12:58.000 --> 00:13:08.000
この特性は、定義したときに色の外観に影響することを示したため、このカスタム背景色を使用するビューは、テーマが変更されると自動的に更新されます。

00:13:08.000 --> 00:13:16.000
特性を定義するとき、考慮すべき最も重要なことは、特性の値の関連データ型です。

00:13:16.000 --> 00:13:21.000
最良の特性は、単純な構造体や列挙型など、価値タイプを中心に構築されています。

00:13:21.000 --> 00:13:26.000
Swiftのクラスに基づく特性は避けてください。

00:13:26.000 --> 00:13:35.000
特性の最も効率的なデータ型は、Bool、Int、Double、またはIntの生値を使用する列挙型です。

00:13:35.000 --> 00:13:38.000
列挙型は、特性に最も有用なデータ型の1つです。

00:13:38.000 --> 00:13:47.000
最大限の効率を得るには、列挙型の生データ型としてIntを明示的に指定してください。

00:13:47.000 --> 00:13:54.000
特性値として使用するカスタム構造体データ型には、Equatableプロトコルの効率的な実装が必要です。

00:13:54.000 --> 00:14:05.000
システムは、特性値がいつ変化したかを判断するために特性値を頻繁に比較するので、あなたの等しい機能はできるだけ速くする必要があります。

00:14:05.000 --> 00:14:12.000
Objective-Cを使用するアプリを使用している人のために、新しい特性システム機能もそこで利用可能です。

00:14:12.000 --> 00:14:17.000
カスタム特性のAPIは、SwiftとObjective-Cで異なります。

00:14:17.000 --> 00:14:26.000
ただし、Swiftで1つのカスタムトレイトを定義し、Objective-Cで1つのカスタムトレイトを定義し、両方とも同じ基礎データを指すことができます。

00:14:26.000 --> 00:14:32.000
詳細と特別な考慮事項については、ドキュメントを参照してください。

00:14:32.000 --> 00:14:39.000
カスタムトレイトを定義したら、次のステップは、アプリのトレイト階層にデータを入力することです。

00:14:39.000 --> 00:14:45.000
トレイトオーバーライドは、トレイト階層内のデータを変更するために使用するメカニズムです。

00:14:45.000 --> 00:14:50.000
iOS 17では、特性オーバーライドを適用することがこれまで以上に簡単になりました。

00:14:50.000 --> 00:15:01.000
ウィンドウシーン、ウィンドウ、ビュー、ビューコントローラー、プレゼンテーションコントローラーなど、各トレイト環境クラスに新しい traitOverridesプロパティがあります。

00:15:01.000 --> 00:15:10.000
トレイト階層の図に戻ると、トレイトオーバーライドは、このツリー内の任意の場所でトレイトの値を変更します。

00:15:10.000 --> 00:15:21.000
この階層内のトレイト環境の1つにトレイトオーバーライドを適用すると、そのオブジェクトとそのすべての子孫のトレイトコレクション内のそのトレイトの値が変更されます。

00:15:21.000 --> 00:15:29.000
トレイト階層から親子トレイト環境を取ると、トレイトオーバーライドが両方にどのように影響するかを次に示します。

00:15:29.000 --> 00:15:34.000
親に適用される特性上書きは、親自身の特性コレクションに影響します。

00:15:34.000 --> 00:15:40.000
そして、親の特性コレクションの値は子に継承されます。

00:15:40.000 --> 00:15:48.000
最後に、子の特性オーバーライドは、継承した値に適用され、独自の特性コレクションを生成します。

00:15:48.000 --> 00:15:54.000
特性オーバーライドをオプションの入力として、特性コレクションを出力として考えてください。

00:15:54.000 --> 00:15:58.000
オーバーライドのない特性は、親から継承されます。

00:15:58.000 --> 00:16:04.000
トレイトオーバーライドを使用して、アプリの特定の部分のカラーテーマを変更する例を見ていきます。

00:16:04.000 --> 00:16:09.000
右側には、私のアプリの特性階層のイラストがあります。

00:16:09.000 --> 00:16:20.000
当初、テーマトレイトの値を入力するためにオーバーライドを適用していないため、これらのトレイトコレクションはすべて、標準テーマであるデフォルト値を持っています。

00:16:20.000 --> 00:16:27.000
まず、ウィンドウシーンのこの階層のルートにトレイトオーバーライドを適用します。

00:16:27.000 --> 00:16:34.000
traitOverridesプロパティは、UIMutableTraitsプロトコルを活用して、トレイト値を簡単に設定できます。

00:16:34.000 --> 00:16:44.000
したがって、先ほど説明したUIMutableTraitsの拡張機能を使用して、標準プロパティ構文でカスタム特性のオーバーライド値を設定できます。

00:16:44.000 --> 00:16:57.000
ウィンドウシーンのトレイトオーバーライドでテーマをパステルに設定すると、そのウィンドウシーン内のすべてのウィンドウ、ビュー、ビューが、トレイトコレクションのパステル値を継承するようになりました。

00:16:57.000 --> 00:17:06.000
したがって、階層のルートにある1か所にテーマを設定することで、その階層内のすべてに伝播される基本値を変更しました。

00:17:06.000 --> 00:17:15.000
たとえば、そのウィンドウシーン内のビューコントローラーのトレイトコレクションからテーマを読み、パステルを取り戻すことができます。

00:17:15.000 --> 00:17:25.000
次に、階層の奥深くにあるビューで traitOverrides プロパティを使用して、そのビューとその下のテーマを変更できます。

00:17:25.000 --> 00:17:30.000
ここでは、このビューのモノクロテーマトレイトオーバーライドを設定しています。

00:17:30.000 --> 00:17:38.000
したがって、このモノクロ値は、そのサブビューによって継承されるものであり、階層の上位からパステル値を上書きします。

00:17:38.000 --> 00:17:43.000
トレイトオーバーライドの変更は、トレイトコレクションにすぐに反映されない場合があります。

00:17:43.000 --> 00:17:57.000
たとえば、ビューはレイアウトの直前にトレイトコレクションを更新するため、ビューのトレイトオーバーライドへの変更は、layoutSubviewsを実行する直前までトレイトコレクションに反映されません。

00:17:57.000 --> 00:18:04.000
traitOverridesプロパティでは、オーバーライドが適用されているかどうかを確認し、オーバーライドを完全に削除することもできます。

00:18:04.000 --> 00:18:15.000
以下は、オーバーライドが存在するかどうかを確認するためにcontainsメソッドと、オーバーライドを完全に削除する removeメソッドを使用してオーバーライドを切り替える例です。

00:18:15.000 --> 00:18:25.000
このメソッドが呼び出されるたびに、既存のオーバーライドを削除するか、まだテーマオーバーライドがなかったときに新しいテーマオーバーライドを適用します。

00:18:25.000 --> 00:18:29.000
特性オーバーライドは、値を設定するための入力メカニズムです。

00:18:29.000 --> 00:18:34.000
Trait 値を読み取るには、常に traitCollection プロパティを使用します。

00:18:34.000 --> 00:18:41.000
オーバーライドが設定されていないときにtraitOverridesから読み取ると、例外が発生します。

00:18:41.000 --> 00:18:45.000
トレイトオーバーライドを使用する際に留意すべきパフォーマンスの考慮事項をいくつか紹介します。

00:18:45.000 --> 00:18:55.000
まず、各トレイトオーバーライドはコストが小さいため、必要な場所にトレイトオーバーライドのみを設定し、使用されていないトレイトオーバーライドの設定を避けてください。

00:18:55.000 --> 00:19:03.000
そして、トレイトオーバーライドを変更するたびに、システムは階層内の子孫のトレイトコレクションを更新する必要があります。

00:19:03.000 --> 00:19:08.000
したがって、特性オーバーライドを変更する回数を最小限に抑えます。

00:19:08.000 --> 00:19:17.000
最後に、ウィンドウシーンやウィンドウなど、階層のルートの近くに適用される特性オーバーライドは、その下のすべてに影響します。

00:19:17.000 --> 00:19:24.000
これは非常に便利で、ウィンドウシーンやウィンドウに特性オーバーライドを適用するための多くの素晴らしいユースケースがあります。

00:19:24.000 --> 00:19:37.000
ただし、トレイトが階層の奥深くにある少数のビューにしか影響しない場合は、代わりに、共通のスーパービューやビューコントローラーなど、それらのビューの最も近い共通の祖先にトレイトオーバーライドを適用します。

00:19:37.000 --> 00:19:47.000
そうすれば、階層のごく一部だけがそのデータを使用しているときに、階層全体に特性を伝播するコストを支払うことはありません。

00:19:47.000 --> 00:19:56.000
特性を定義し、階層にデータを入力する方法がわかったので、値が変更されたときに処理する必要があります。

00:19:56.000 --> 00:20:00.000
traitCollectionDidChangeはiOS 17では非推奨です。

00:20:00.000 --> 00:20:11.000
traitCollectionDidChangeを実装すると、システムは実際にどの特性を気にしているかを知らないため、特性が値を変更するたびにそのメソッドを呼び出す必要があります。

00:20:11.000 --> 00:20:18.000
しかし、ほとんどのクラスはほんの一握りの特性しか使用せず、他の変化を気にしません。

00:20:18.000 --> 00:20:25.000
これが、より多くのカスタム特性を追加するにつれて、traitantCollectionDidChangeが拡張されない理由です。

00:20:25.000 --> 00:20:33.000
その代わりに、より柔軟でパフォーマンスを向上させる新しい特性登録APIがあります。

00:20:33.000 --> 00:20:40.000
特定の特性への変更を登録することで、システムはあなたが依存している特性を正確に把握します。

00:20:40.000 --> 00:20:46.000
新しいAPIを使用すると、ターゲットアクションパターンまたはクロージャを使用してコールバックを受信できます。

00:20:46.000 --> 00:20:54.000
また、サブクラスのメソッドをオーバーライドする必要がなくなったため、どこからでも特性の変化を簡単に観察できるようになりました。

00:20:54.000 --> 00:21:00.000
まず、t traitCollectionDidChange の既存の実装を更新する方法を説明します。

00:21:00.000 --> 00:21:02.000
これが私の既存の実装です。

00:21:02.000 --> 00:21:12.000
そのメソッドはこの1つのトレイトにのみ依存しているため、updateViewsを呼び出す前にhorizontalSizeClassトレイトが変更されたかどうかを確認する方法に注意してください。

00:21:12.000 --> 00:21:24.000
アプリを古いiOSバージョンにデプロイしているため、traitCollectionDidChangeを使用し続ける必要がある場合は、実装が気になる特定の特性が変更されたかどうかをチェックしていることを確認してください。

00:21:24.000 --> 00:21:31.000
次に、この実装をiOS 17の新しい特性登録方法に置き換えます。

00:21:31.000 --> 00:21:33.000
クロージャベースの方法から始めます。

00:21:33.000 --> 00:21:39.000
registerForTraitChangesを呼び出し、登録する特性の配列を渡します。

00:21:39.000 --> 00:21:46.000
水平サイズクラス用のこのような、すべてのシステム特性に新しいUITraitシンボルがあります。

00:21:46.000 --> 00:21:52.000
次に、それらの特定の特性が変化したときに呼び出されるクロージャを渡します。

00:21:52.000 --> 00:22:00.000
クロージャは、他の特性への変更が求められていないため、ここで古い特性値と新しい特性値を比較する必要はありません。

00:22:00.000 --> 00:22:05.000
特性が変更されたオブジェクトは、クロージャの最初のパラメータとして渡されます。

00:22:05.000 --> 00:22:11.000
このパラメータを使用すると、そのオブジェクトへの弱い参照をキャプチャする必要はありません。

00:22:11.000 --> 00:22:19.000
自己の特性変更を登録するときは、常にここに「自己：自己」と書いてください。

00:22:19.000 --> 00:22:24.000
また、異なる特性環境の特性の変化を観察することもできます。

00:22:24.000 --> 00:22:33.000
ここでは、以前に定義した水平サイズクラスとContainedInSettingsカスタムトレイトという2つの特性の変更を登録しています。

00:22:33.000 --> 00:22:39.000
クロージャは、これらの特性のいずれかがこの他のビューで変化したときに実行されます。

00:22:39.000 --> 00:22:47.000
クロージャの最初のパラメータとして、登録しているビューのタイプを書きます。

00:22:47.000 --> 00:22:51.000
これは、新しいターゲットアクションベースのメソッドの例です。

00:22:51.000 --> 00:23:00.000
registerForTraitChangesを呼び出し、登録する特性の配列と、変更を呼び出すターゲットとアクションメソッドを渡します。

00:23:00.000 --> 00:23:02.000
ターゲットパラメータはオプションです。

00:23:02.000 --> 00:23:08.000
省略すると、ターゲットはregisterForTraitChangesが呼び出されるのと同じオブジェクトになります。

00:23:08.000 --> 00:23:11.000
この場合、それは自己です。

00:23:11.000 --> 00:23:17.000
クロージャ方法と同様に、他のトレイト環境の変更を登録することもできます。

00:23:17.000 --> 00:23:26.000
ここでは、別のビューで特性の変更を登録していますが、selfnamed handleTraitChangeのメソッドの呼び出しを設定しています。

00:23:26.000 --> 00:23:36.000
ターゲットアクションを使用して特性変更を登録する場合、アクションメソッドは0、1、または2つのパラメータを持つことができます。

00:23:36.000 --> 00:23:40.000
最初のパラメータは、常に特性が変化しているオブジェクトです。

00:23:40.000 --> 00:23:44.000
このパラメータを使用して、新しいtraitCollectionを取得します。

00:23:44.000 --> 00:23:52.000
2番目のパラメータは、変更前のオブジェクトの以前のトレイトコレクションです。

00:23:52.000 --> 00:24:00.000
個々の特性の登録に加えて、システム特性の新しいセマンティックセットを使用して登録することもできます。

00:24:00.000 --> 00:24:10.000
たとえば、systemTraitsAffectingColorAppearanceがあり、システムの動的色の解決方法に影響を与える可能性のあるシステム特性を返します。

00:24:10.000 --> 00:24:20.000
また、UIImage(named:)を使用して画像をロードするときに考慮されるシステム特性のサブセットを返すsystemTraitsAffectingImageLookupもあります。

00:24:20.000 --> 00:24:28.000
これらのセットのいずれかをregisterForTraitChangesに直接渡して、カスタム無効化を実行します。

00:24:28.000 --> 00:24:34.000
新しい方法を使用して特性変更を登録すると、登録は自動的にクリーンアップされます。

00:24:34.000 --> 00:24:43.000
高度なユースケースがある場合は、各登録方法によって返されるトークンを使用して手動で登録を解除できます。

00:24:43.000 --> 00:24:51.000
しかし、これらのケースは非常にまれであるため、通常、registerForTraitChangesを呼び出すときに戻り値を無視する必要があります。

00:24:51.000 --> 00:24:56.000
新しい特性登録APIを採用する際に、覚えておくべき2つのベストプラクティスがあります。

00:24:56.000 --> 00:25:04.000
まず、無関係な特性が価値を変えたときに作業を実行しないように、実際に依存している特性のみを登録します。

00:25:04.000 --> 00:25:10.000
最後に、すぐに更新せずに、特性の変更に応じて無効にしてみてください。

00:25:10.000 --> 00:25:19.000
たとえば、ビューサブクラスのlayoutSubviewsメソッド内でトレイトを使用する場合は、setNeedsLayoutを呼び出してトレイトの変更を無効にします。

00:25:19.000 --> 00:25:25.000
これは、レイアウトサブビューを受信するようにビューをスケジュールしますが、すぐに更新を実行しません。

00:25:25.000 --> 00:25:37.000
UIKitのトレイトシステムを使用して独自のデータを伝播できるようになったので、アプリ内のUIKitとSwiftUIコンポーネント間でデータをシームレスに渡すためのまったく新しい方法のロックを解除します。

00:25:37.000 --> 00:25:43.000
UIKitのカスタム特性は、SwiftUIのカスタム環境キーと非常によく似ています。

00:25:43.000 --> 00:25:48.000
それらをブリッジして、UIKitとSwiftUIの両方から同じデータにアクセスできます。

00:25:48.000 --> 00:25:59.000
UIKit内にSwiftUIコンポーネントを埋め込む場合でも、SwiftUI内にUIKitコンポーネントを埋め込む場合でも、ブリッジデータはそれらの間でシームレスに通過します。

00:25:59.000 --> 00:26:08.000
UIKitコードのトレイトAPIとSwiftUIコードの環境APIを使用して、同じ基礎となるデータを読み書きできます。

00:26:08.000 --> 00:26:19.000
アプリのUIKitコード用に定義した新しいカラーテーマの特性を、SwiftUIの対応する環境キーにブリッジするのは信じられないほど簡単です。

00:26:19.000 --> 00:26:33.000
UIKitにカスタムトレイトがあり、同じデータを表すSwiftUIにカスタム環境キーがあると仮定すると、それらをブリッジするために必要なのは、UITraitBridgedEnvironmentKeyプロトコルへの適合性を追加することだけです。

00:26:33.000 --> 00:26:46.000
これを行うには、UIKitからトレイトを読み取り、値をSwiftUIに返す1つのメソッドと、UIKitトレイトにSwiftUI環境値を書き込む1つのメソッドを実装します。

00:26:46.000 --> 00:26:59.000
そして今、UIKit特性とSwiftUI環境キーの両方が統合ストレージにアクセスするので、どちらかのフレームワークを使用して書かれたコンポーネントから同じデータを読み書きすることができます。

00:26:59.000 --> 00:27:04.000
ブリッジされた特性と環境キーを使用する方法の例を次に示します。

00:27:04.000 --> 00:27:12.000
アプリのルートでは、UIKitウィンドウシーンにテーマトレイトのトレイトオーバーライドを適用します。

00:27:12.000 --> 00:27:18.000
これは、そのウィンドウシーンに含まれるすべてのものにモノクロのテーマ値を伝播します。

00:27:18.000 --> 00:27:24.000
次に、そのウィンドウシーンのウィンドウの奥深くに、UIKitコレクションビューがあります。

00:27:24.000 --> 00:27:34.000
このコレクションビューには、各セルにSwiftUIビューを表示するようにUIHostingConfigurationを使用して設定されたセルが含まれています。

00:27:34.000 --> 00:27:44.000
SwiftUI CellViewの内部には、Environmentプロパティラッパーを使用してSwiftUI環境から値を読み取ります「theme」という名前のプロパティがあります。

00:27:44.000 --> 00:27:51.000
環境の値は、UIKitのブリッジされた特性の同じ値に対応します。

00:27:51.000 --> 00:27:58.000
そして最後に、テーマプロパティを使用して、このSwiftUIビュー内のテキストの色を制御します。

00:27:58.000 --> 00:28:14.000
SwiftUIは自動的にデータの依存関係を追跡するため、UIKitウィンドウシーンでテーマトレイトが上書きされ、別の値に変更されると、SwiftUIセルビューは自動的に更新され、新しいテーマが反映されます。

00:28:14.000 --> 00:28:17.000
ブリッジングは別の方向でも機能します。

00:28:17.000 --> 00:28:22.000
ここには、アプリの設定を表示するSwiftUIビューがあります。

00:28:22.000 --> 00:28:30.000
環境修飾子を使用して標準テーマを設定し、設定コントローラーのすべてに適用されます。

00:28:30.000 --> 00:28:35.000
これは概念的には、UIKitで特性オーバーライドを適用することと同等です。

00:28:35.000 --> 00:28:50.000
次に、UIViewControllerRepresentableに含まれるUIKitベースの設定ビューコントローラーで、ブリッジされたトレイトからテーマ値を読み取り、それを使用してこのビューコントローラーに表示されるタイトルを更新します。

00:28:50.000 --> 00:28:58.000
これは、ブリッジされたUIKit特性とSwiftUI環境キーを使用して、データにシームレスにアクセスするのがいかに簡単かです。

00:28:58.000 --> 00:29:10.000
これらの強力な新機能について学んだので、アプリ内で特性システムを活用して、独自のカスタム特性を定義することでデータを自動的に伝播できる場所を見つけてください。

00:29:10.000 --> 00:29:17.000
次に、新しい traitOverrides プロパティを採用して、トレイト階層のデータを簡単に変更します。

00:29:17.000 --> 00:29:25.000
そして、より柔軟な特性登録APIを使用して、使用する正確な特性に正確な依存関係を作成します。

00:29:25.000 --> 00:29:36.000
最後に、カスタムUIKit特性とカスタムSwiftUI環境キーをブリッジし、アプリ内のUIKitとSwiftUIコンポーネント間でデータがシームレスに流れるようにします。

00:29:36.000 --> 00:29:41.000
今、特性の力を解き放つのはあなた次第です。

00:29:41.000 --> 00:29:43.000
見てくれてありがとう。

00:29:43.000 --> 23:59:59.000
♪ ♪

