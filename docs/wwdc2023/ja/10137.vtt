WEBVTT

00:00:00.000 -> 00:00:10.000
♪ ♪

00:00:10.000 -> 00:00:16.000
ラスマス:こんにちは、私はラスマスです。私はコンピュータビデオを扱うカメラアルゴリズムチームのエンジニアです。

00:00:16.000 -> 00:00:18.000
私はすでにシネマティックモードに興奮しています。

00:00:18.000 -> 00:00:29.000
そして今、新しいシネマティックAPIを使用して、シネマティックモードの魔法を独自のアプリに統合する方法を示すことにさらに興奮しています。

00:00:29.000 -> 00:00:41.000
このプレゼンテーションでは、新しいAPIを使用して、再生と編集を行うサンプルアプリを構築し、シネマティックモードの素晴らしい機能を実現するために、必要な手順を説明します。

00:00:41.000 -> 00:00:51.000
しかし、統合について話し始める前に、まずシネマティックモードとは何か、それをキャプチャする方法、そしてキャプチャ後に何ができるかをお見せしましょう。

00:00:51.000 -> 00:00:57.000
私たちはiPhone 13でシネマティックモードを導入しました、そしてそれは本当にあなたのポケットの中の小さな映画クルーです。

00:00:57.000 -> 00:01:16.000
それはあなたに美しい浅い被写界深度と自然な焦点のフォールオフを持つカメラ、焦点を変更することによって注意と物語を指示する監督、そして事前にキーフレームを予測し、フォーカスポイント間のスムーズな移行を作成するフォーカスプーラーをもたらします。

00:01:16.000 -> 00:01:17.000
では、どのようにシネマティックモードをキャプチャしますか?

00:01:17.000 -> 00:01:27.000
iPhone 13と14のラインナップのどのデバイスでもカメラアプリでキャプチャされ、録画時にレンダリングプレビューを提供します。

00:01:27.000 -> 00:01:36.000
これは、あなたが意欲的なインディーズ映画制作者であろうと、キャンプ旅行のビデオに魔法のタッチを加えたいであろうと、非常にアクセスしやすくなります。

00:01:36.000 -> 00:01:42.000
そして、私は映画製作者になることを夢見ていましたが、自分の家族のシネマティックモードを捉えるのが大好きです。

00:01:42.000 -> 00:01:44.000
しかし、魔法はここで止まりません。

00:01:44.000 -> 00:01:47.000
シネマティックモードには、目に見える以上のものがあります。

00:01:47.000 -> 00:01:52.000
それはあなたがキャプチャ後にいくつかのかなり驚くべき非破壊的な編集を行うことを可能にします。

00:01:52.000 -> 00:01:56.000
絞りを変更し、それによってボケ味の量を変更できます。

00:01:56.000 -> 00:02:01.000
そして、代替検出を使用して焦点と物語をリダイレクトすることができます。

00:02:01.000 -> 00:02:10.000
これは写真でのキャプチャ後の編集を示していますが、編集はiMovie、Final Cut Pro、Motionなどのアプリでも行うことができます。

00:02:10.000 -> 00:02:20.000
そして今、シネマティックAPIの導入により、シネマティックモードのビデオを使用して、独自の素晴らしいアプリで再生および編集することができます。

00:02:20.000 -> 00:02:29.000
Cinematic APIは、新しいmacOS Sonoma、iOS 17、iPadOS 17、tvOS 17で広く利用可能です。

00:02:29.000 -> 00:02:31.000
だから、これは本当にエキサイティングです。

00:02:31.000 -> 00:02:37.000
まず、特別なシネマティックモードのアセットとデータフローに関するいくつかの基礎から始めます。

00:02:37.000 -> 00:02:46.000
次に、絞りの変更など、簡単な再生調整でシネマティックモードのアセットを取得して再生するための特定の手順を実行します。

00:02:46.000 -> 00:02:56.000
そして、シネマティックモードでフォーカスを駆動する非破壊編集を行う方法と、これらの編集変更を保存してロードする方法。

00:02:56.000 -> 00:03:04.000
新しいシネマティックAPI呼び出しのいくつかを見て、詳細な参照として使用できるサンプルコードアプリも提供します。

00:03:04.000 -> 00:03:09.000
しかし、約束通り、シネマティックモードに関するいくつかの基礎を説明することから始めましょう。

00:03:09.000 -> 00:03:15.000
シネマティックモードは、実際には2つのファイルと、一方から他方へのデータフローで構成されています。

00:03:15.000 -> 00:03:17.000
まず、レンダリングされた資産があります。

00:03:17.000 -> 00:03:26.000
これは、シネマティックモードエフェクトが適用されたベイクドファイルで、通常のQuickTimeムービーとしてエクスポート、共有、再生できます。

00:03:26.000 -> 00:03:33.000
そして、レンダリングされたアセットを作成するために必要なすべての情報を含む特別なシネマティックモードアセットがあります。

00:03:33.000 -> 00:03:40.000
絞りを変更したり、物語に再フォーカスしたりするなど、非破壊的なキャプチャ後の編集を行うことができます。

00:03:40.000 -> 00:03:48.000
まず、レンダリングされたアセットを見て、小さなシネマトグラフィー101でショットを分解しましょう。

00:03:48.000 -> 00:03:59.000
オープニングショット:私たちは明らかにストリートハンドボールの重要なゲームであるものに入り、メインの主題に焦点を当てることで、彼が大きなプレーをする準備をするにつれて、私たちは本当に緊張を感じます。

00:03:59.000 -> 00:04:02.000
彼はチームプレーヤーをチェックします。彼も準備ができています。

00:04:02.000 -> 00:04:06.000
彼に焦点を当てることは、彼がどれだけ準備ができているかを強調しています。

00:04:06.000 -> 00:04:09.000
私たちは主なテーマに焦点を合わせます。

00:04:09.000 -> 00:04:14.000
これです。ナイフで緊張を断ち切ることができます。

00:04:14.000 -> 00:04:19.000
彼は芝居を作り、それを完全に台無しにし、いくつかのコミカルな救済を設定します。

00:04:19.000 -> 00:04:28.000
さて、ショットの早い段階で彼に焦点を当てることで、物語をチームプレーヤーについてに変更し、行ったり来たりする代わりに、彼に焦点を合わせましょう。

00:04:28.000 -> 00:04:29.000
私は彼の考えの声になります。

00:04:29.000 -> 00:04:33.000
「愛してるよ、相棒、でもあなたはいつも永遠にかかる。」

00:04:33.000 -> 00:04:38.000
はい、準備はできていますが、期待は低いです。

00:04:38.000 -> 00:04:47.000
「なんて時間の無駄だ。ブラボー。」だから、これはiPhone 13で撮影され、シネマティックモードが提供するストーリーテリングのための映画撮影ツールを紹介しました。

00:04:47.000 -> 00:04:51.000
そして、このレンダリングされたアセットを生成するために、特別なシネマティックモードアセットがあります。

00:04:51.000 -> 00:04:58.000
非破壊的なキャプチャ後の編集をサポートするために、シネマティックモードのアセットには実際には複数のトラックがあります。

00:04:58.000 -> 00:05:03.000
1つ目は、キャプチャされたオリジナルのQuickTimeムービーであるビデオトラックです。

00:05:03.000 -> 00:05:14.000
HDR/SDR、毎秒30フレームで1080p、iPhone 14、24、25、毎秒30フレームで4Kでもかまることができます。

00:05:14.000 -> 00:05:21.000
このトラックは通常のビデオとして再生できますが、レンダリングされたアセットと比較して美学とストーリーテリングが欠けています。

00:05:21.000 -> 00:05:28.000
サスペンスもコミックリリーフもなく、私たちは何人かの人々が路地裏でゲームをするのを見ているだけです。

00:05:28.000 -> 00:05:35.000
2番目のトラックには、同じシーンを見ている2つのカメラから見られるピクセルシフトである格差が含まれています。

00:05:35.000 -> 00:05:38.000
近いオブジェクトは、遠く離れたオブジェクトよりもシフトされています。

00:05:38.000 -> 00:05:45.000
片方の目を閉じて、もう片方の目を閉じて、オブジェクトが異なる距離でどのようにシフトするかを自分でテストできます。

00:05:45.000 -> 00:05:50.000
格差は、焦点を合わせ、浅い被写界深度をレンダリングするために使用されます。

00:05:50.000 -> 00:05:55.000
格差マップはビデオトラックよりも低い解像度です。

00:05:55.000 -> 00:06:13.000
色分けとして表示されるトラックには、絶対格差ではなく相対的な格差が含まれています。つまり、焦点格差に対する相対的なレンダリングや2つの焦点格差間の遷移など、同じマップ内の他のサンプルに対してのみ使用できます。

00:06:13.000 -> 00:06:22.000
相対的な格差と大きな深さのダジャレについての洞察については、WWDC17「iPhone写真で深みを捉える」を強くお勧めします。

00:06:22.000 -> 00:06:27.000
3番目のトラックには、レンダリングと編集のための重要なメタデータが含まれています。

00:06:27.000 -> 00:06:29.000
トラックは2つのもので構成されています。

00:06:29.000 -> 00:06:36.000
まず、フォーカスの格差と絞りをf数として保持するレンダリング属性。

00:06:36.000 -> 00:06:38.000
これらはレンダリングを駆動します。

00:06:38.000 -> 00:06:46.000
オーバーレイとして表示されるフォーカスはシネマティックエンジンによって決定され、絞りはユーザーによって選択されます。

00:06:46.000 -> 00:06:52.000
そして、すべての自動シーン検出を保持するシネマティックスクリプトがあります。

00:06:52.000 -> 00:07:02.000
このシーンは、顔、頭、胴体を示し、可能であれば時間の経過とともにそれらをリンクするIDでグループ化されます。

00:07:02.000 -> 00:07:08.000
スクリプトはまた、フォーカスの決定を保持し、どの検出にフォーカスを維持するかを決定します。

00:07:08.000 -> 00:07:16.000
フォーカスの決定は、他の検出に従うようにキャプチャ後に変更することができ、それによって物語とレンダリングを変更することができます。

00:07:16.000 -> 00:07:21.000
これは、シネマティックモードアセットからレンダリングされたアセットへのデータフローです。

00:07:21.000 -> 00:07:30.000
先ほど説明したように、シネマティックモードアセットは、レンダリングとキャプチャ後のフォーカスと絞りの変更に必要なすべての情報を保持します。

00:07:30.000 -> 00:07:37.000
以下はオプションの編集で、変更は非破壊的であり、いつでも元に戻すことができます。

00:07:37.000 -> 00:07:49.000
編集が行われない場合、シネマティックエンジンはフォーカスの格差を自動的に制御し、キャプチャ時にユーザーが設定した絞りは変更されません。

00:07:49.000 -> 00:07:58.000
焦点格差と絞りで、レンダリングは格差マップを使用して正確な焦点フォールオフで浅い被写界深度を適用します。

00:07:58.000 -> 00:08:05.000
そして最後に、効果が適用されたレンダリングされたアセットを取得します。これは、通常の共有可能なQuickTimeムービーです。

00:08:05.000 -> 00:08:10.000
シネマティックモードをよりよく理解して、再生アプリの構築を開始する時が来ました。

00:08:10.000 -> 00:08:16.000
しかし、まずシネマティックモードのアセットを手に入れる必要があるので、それを得るためにコードを見てみましょう。

00:08:16.000 -> 00:08:21.000
フォトライブラリからシネマティックモードのアセットを選ぶのはとても簡単です。

00:08:21.000 -> 00:08:25.000
シネマティックビデオには、写真ピッカーとフィルターを使用するだけです。

00:08:25.000 -> 00:08:29.000
ピッカーは、選択したファイルのローカル識別子を取得します。

00:08:29.000 -> 00:08:43.000
非コード関連の補足として、シネマティックモードアセットをまだお持ちでない場合は、レンダリングされたアセットとシネマティックモードアセットの両方を含めるために、すべての写真データオプションを使用して、異なるユーザーデバイス間でAirDropすることができます。

00:08:43.000 -> 00:08:45.000
コーディングに戻りましょう。

00:08:45.000 -> 00:08:55.000
ピックのアセット識別子を使用して、リクエストする前にシネマティックモードアセットに関する情報を含む写真アセットを取得できるようになりました。

00:08:55.000 -> 00:09:09.000
元のバージョンを取得するためのリクエストオプションを設定し、アセットがiCloudにある場合にネットワークアクセスを許可し、最後にシネマティックモードアセットをAVAssetとしてリクエストする必要があります。

00:09:09.000 -> 00:09:10.000
そして今、エキサイティングな部分へ。

00:09:10.000 -> 00:09:12.000
シネマティックモードのアセットを手に入れました。

00:09:12.000 -> 00:09:14.000
再生を統合しましょう。

00:09:14.000 -> 00:09:24.000
レンダリングされたアセットは、AVPlayerとAVPlayerItemを使用して通常のムービーとして再生でき、シネマティックモードアセット内のムービートラックも再生できます。

00:09:24.000 -> 00:09:38.000
しかし、シネマティックモードアセットの可能性を実現するには、複数のトラック、ユーザー変更を処理できるカスタムビデオコンポジターを追加し、最後にシネマティックレンダラーを呼び出して出力を作成する必要があります。

00:09:38.000 -> 00:09:49.000
このカスタムコンポジターは、サムネイルやオフラインエクスポートにも使用できますが、シネマティックモードのアセットの再生と編集に使用することに焦点を当てましょう。

00:09:49.000 -> 00:10:05.000
Cinematic APIに固有の詳細のみ詳しく説明しますので、カスタムビデオコンポジタークラスとHDRに関する追加の洞察については、WWDC20「AVFoundationでHDRビデオを編集して再生する」をお勧めします。

00:10:05.000 -> 00:10:08.000
シネマティックAPIを使い始めましょう。

00:10:08.000 -> 00:10:20.000
Cinematic APIはプレフィックスCNを使用するため、浅い被写界深度をレンダリングするレンダリングセッションを設定するために必要な3つのAPI呼び出しを見つけることができるかもしれません。

00:10:20.000 -> 00:10:24.000
最初の呼び出しは、シネマティックアセットからレンダリング属性を取得します。

00:10:24.000 -> 00:10:28.000
2つ目は、これらの属性を持つレンダリングセッションを設定します。

00:10:28.000 -> 00:10:34.000
レンダリングセッションはGPUを使用するため、金属コマンドキューを提供する必要があります。

00:10:34.000 -> 00:10:38.000
そして、最後の呼び出しは、エクスポートするレンダリング品質を設定します。

00:10:38.000 -> 00:10:44.000
品質は、パフォーマンスや品質の制約に応じて、プレビューやエクスポートなどの異なる列挙型に設定できます。

00:10:44.000 -> 00:10:53.000
これらと次のコードスニペットでは、コアコードに集中するために、ガードレットエラーのようなグッドプラクティスエラーチェックを削除しました。

00:10:53.000 -> 00:11:01.000
カスタムコンポジターには、出力をレンダリングするために必要なシネマティックアセット情報を含むコンポジションが必要です。

00:11:01.000 -> 00:11:10.000
一般的なケースでは、複数のトラックを追加するには複数のステップが必要ですが、幸いなことに、私たちは1つのステップでこれを行う簡単な方法を提供します。

00:11:10.000 -> 00:11:16.000
アセット情報からコンポジションまで、すべてのトラックを直接追加できます。

00:11:16.000 -> 00:11:23.000
シネマティックコンポジション情報は、シネマティックアセット情報に似ていますが、コンポジショントラックを指しています。

00:11:23.000 -> 00:11:27.000
その後、シネマティックアセットからシネマティックスクリプトを取得します。

00:11:27.000 -> 00:11:32.000
シネマティックスクリプトは、すべての検出とフォーカスの決定を保持します。

00:11:32.000 -> 00:11:35.000
そして、これについては後で詳しく説明します。

00:11:35.000 -> 00:11:45.000
カスタムコンポジターでは、レンダリングセッション、アセットトラックを使用したコンポジション、シネマティックスクリプト、および絞りをf番号として設定します。

00:11:45.000 -> 00:11:51.000
このカスタムインストラクションでは、レンダリングされたシネマティックコンテンツを構成する方法について説明します。

00:11:51.000 -> 00:12:06.000
ビデオを再生するには、ビデオコンポジションが必要です。これにシネマティックコンポジションからトラックIDを追加し、エフェクトを作成するためにレンダラーが呼び出されるサンプルカスタムコンポジターを追加し、コンポジション命令を追加します。

00:12:06.000 -> 00:12:10.000
カスタムコンポジターで何が起こっているのかを詳しく見てみましょう。

00:12:10.000 -> 00:12:17.000
カスタムコンポジターのstartRequest関数には、シネマティックAPIに固有の重要な点がいくつかあります。

00:12:17.000 -> 00:12:34.000
シネマティックコンポジションのトラックIDを使用して、元のビデオトラック、格差トラック、メタデータトラックから現在のフレームのソースバッファを取得し、最後にレンダリングされた出力のバッファを作成します。

00:12:34.000 -> 00:12:38.000
これらのバッファを使用すると、編集や新しいレンダリングを行うことができます。

00:12:38.000 -> 00:12:44.000
メタデータバッファから、レンダリングを駆動するレンダリングフレーム属性を取得できます。

00:12:44.000 -> 00:12:52.000
メタデータは不透明な構造なので、CNRenderingSessionを使用してフレーム属性を直接取得します。

00:12:52.000 -> 00:13:04.000
フレーム属性を使用すると、UI要素からの絞り変更を保持する指示に従って絞りf番号を変更することで、オプションの再生変更を行うことができます。

00:13:04.000 -> 00:13:11.000
フォーカスの格差も同様の方法で変更できますが、後で検出を使用してシーン主導の変更に戻ります。

00:13:11.000 -> 00:13:15.000
この時点で、私たちは再生を達成するために本当に、本当に近づいています。

00:13:15.000 -> 00:13:23.000
構成された出力をGPUでレンダリングできるように、レンダリングコマンドキューでコマンドバッファを取得する必要があります。

00:13:23.000 -> 00:13:30.000
更新されたフレーム属性と画像と格差バッファを使用してレンダリングをエンコードします。

00:13:30.000 -> 00:13:36.000
ビデオコンポジションに渡される出力バッファの完了ハンドラを追加します。

00:13:36.000 -> 00:13:38.000
そして最後にコマンドバッファをコミットします。

00:13:38.000 -> 00:13:42.000
では、サンプルアプリで再生してみましょう。

00:13:42.000 -> 00:13:47.000
フォトライブラリからシネマティックモードアセットを選択できるようになりました。

00:13:47.000 -> 00:13:53.000
そして、アセットを再生すると、その効果はリアルタイムで適用されます。

00:13:53.000 -> 00:14:04.000
前後にスクラブして絞りを変更して、ボケ味の量を変更することができます。

00:14:04.000 -> 00:14:09.000
停止すると、効果が最小限に抑えられます。

00:14:09.000 -> 00:14:11.000
開放はそれを増加させる。

00:14:11.000 -> 00:14:15.000
たぶん、これは多すぎます。

00:14:15.000 -> 00:14:17.000
これは良さそうだと思います。

00:14:17.000 -> 00:14:22.000
アプリはすでにかなりクールですが、今後の編集セクションではさらにクールになります。

00:14:22.000 -> 00:14:27.000
そして、参考として、各部品のコードはサンプルアプリで入手できます。

00:14:27.000 -> 00:14:38.000
私は今、シネマティックスクリプトを変更し、それによってフォーカスを変更することによって、より高度で非破壊的な編集を行うために、再生アプリとカスタムビデオコンポジターを拡張するために進みます。

00:14:38.000 -> 00:14:53.000
しかし、シネマティックモードの写真アプリの編集環境を再検討し、オブジェクトを検出し、どこで何を焦点を合わせるかを決定することによって、キャプチャ中に自動的に駆動されるフォーカスを具体的に見てみましょう。

00:14:53.000 -> 00:15:00.000
これらの検出と決定はすべてシネマティックスクリプトにあり、スクリプトはあなたの物語に変更することができます。

00:15:00.000 -> 00:15:09.000
フォーカス検出は黄色の正方形で表示され、タイムラインの下にはキーフレームとフォーカスの決定の変更があります。

00:15:09.000 -> 00:15:15.000
これがどのように機能するかをよりよく理解するために、簡単な例で映画のスクリプト構造を分解しましょう。

00:15:15.000 -> 00:15:20.000
短いシーケンスで2つのシネマティックスクリプトフレームから始めましょう。

00:15:20.000 -> 00:15:26.000
それぞれが特定の時点ですべての検出を保持し、この場合は2つの検出のみを保持します。

00:15:26.000 -> 00:15:34.000
検出は、顔、頭、胴体を一緒にグループ化するグループIDで時間の経過とともに追跡されます。

00:15:34.000 -> 00:15:43.000
さらに、猫、犬、ボールが検出され、追跡されますが、ここではアクター1とアクター2の顔しかありません。

00:15:43.000 -> 00:15:52.000
自動ベース決定は、最初のフレームでアクター1に焦点を当て、フォーカスは新しい決定までこのトラックに従います。

00:15:52.000 -> 00:16:01.000
アクター3がシーンに入り、新しい顔と検出トラックを導入した後でも、焦点はアクター1のままです。

00:16:01.000 -> 00:16:09.000
フレーム5では、自動キーフレームイベントが決定とフォーカスをアクター2に変更します。

00:16:09.000 -> 00:16:16.000
そして、わずか4フレームの後、アクター3は彼女が値する集中的な注目を得ることなく、落胆した出口を行います。

00:16:16.000 -> 00:16:21.000
残りのシーケンスでは、アクター2にフォーカスが残ります。

00:16:21.000 -> 00:16:32.000
これらの自動基本決定は、誰がカメラに直面するか、誰が離れて見るか、誰が近くにいるか、何が面白いかなど、さまざまなパラメータで決定されます。

00:16:32.000 -> 00:16:36.000
そして、私たちは良い物語を作成するために最善を尽くしますが、あなたは別の物語を持っているかもしれません。

00:16:36.000 -> 00:16:39.000
幸いなことに、決定は変更することができ、実際には2つの方法で変更できます。

00:16:39.000 -> 00:16:44.000
1つ目は、弱いユーザーの決定を追加することです。

00:16:44.000 -> 00:16:48.000
これは、彼女がシーンに入るときにアクター3に焦点を合わせます。

00:16:48.000 -> 00:17:01.000
ただし、弱い決定は、フレーム5で発生する次のベースまたはユーザーの決定までトラックに続くだけで、基本決定は残りのフレームのフォーカスをアクター2に変更します。

00:17:01.000 -> 00:17:09.000
したがって、アクター3に集中したい場合は、フレーム5に別の弱い決定を追加するか、より強力なものを使うことができます。

00:17:09.000 -> 00:17:13.000
はい、あなたはそれを推測したかもしれません、強力なユーザーの決定です。

00:17:13.000 -> 00:17:22.000
強力な決定は、他の場所に焦点を当てる次のユーザーの決定または検出トラックの終わりまで、主題に焦点を当て続けます。

00:17:22.000 -> 00:17:28.000
強力な決定を追加すると、アクター3が焦点になり、次の基本決定が上書きされます。

00:17:28.000 -> 00:17:38.000
アクター3の検出トラックが終了した後、焦点はアクター2に焦点を当てるという基本決定に戻ります。

00:17:38.000 -> 00:17:49.000
決定階層は次のように機能します。基本決定の上にユーザーの決定、ユーザーの決定は可能な限り適用され、基本決定はギャップを埋めます。

00:17:49.000 -> 00:17:54.000
したがって、この例で行ったように、ユーザーはスクリプトの一部だけを変更できます。

00:17:54.000 -> 00:18:04.000
そして、検出トラックが終了すると、両方の決定は基本決定に戻りますが、強力な決定はできるだけ長くフォーカストラックを保持します。

00:18:04.000 -> 00:18:09.000
スクリプトを変更する前に、スクリプトフレームを取得し、検出ボックスを描きましょう。

00:18:09.000 -> 00:18:20.000
まず、ビデオコンポジションのリクエストからフレームタイムを取得し、その現在の時点のシネマティックスクリプトフレームを取得する必要があります。

00:18:20.000 -> 00:18:24.000
このスクリプトフレームは、フォーカス検出を含むすべての検出を保持します。

00:18:24.000 -> 00:18:28.000
検出ボックスを描くのが簡単になりました。

00:18:28.000 -> 00:18:39.000
スクリプト内のすべての検出を反復することで、各検出矩形を取得し、drawコマンドを使用してrenderEncoderにアタッチされたテクスチャに描画できます。

00:18:39.000 -> 00:18:42.000
この例では、検出は白で描かれています。

00:18:42.000 -> 00:18:48.000
そして、現在のfocusDetectionを強調するために、それを別の色で描きましょう。

00:18:48.000 -> 00:19:01.000
私はシネマティックスクリプトフレームから直接フォーカス検出を取得し、対応する長方形を取得し、それを目立たせるために、フォーカス長方形を黄色で描きます。

00:19:01.000 -> 00:19:04.000
検出オーバーレイを追加した再生アプリを試してみましょう。

00:19:04.000 -> 00:19:10.000
新しい検出オーバーレイを有効にして、検出を描画できるようになりました。

00:19:10.000 -> 00:19:17.000
このシーンでは、顔、頭、胴体は白で、焦点検出は黄色です。

00:19:17.000 -> 00:19:24.000
アプリにとって理にかなっている場合にのみ、検出の特定のサブセットを表示するようにオーバーレイをカスタマイズできます。

00:19:24.000 -> 00:19:34.000
再生を開始すると、フォーカスとレンダリングが映画を通して黄色のフォーカス検出に続き、代替検出が白で表示されていることに注目してください。

00:19:34.000 -> 00:19:40.000
これらの代替検出を使用して焦点を変更する方法を紹介します。

00:19:40.000 -> 00:19:47.000
検出ボックスの描き方を知ったら、実際にUIタッピングポイントでスクリプトを変更することは非常によく似ています。

00:19:47.000 -> 00:19:59.000
繰り返しますが、すべての検出を反復し、タッピングポイントが検出内にある場合は、対応する検出IDを取得し、新しい決定を作成します。

00:19:59.000 -> 00:20:02.000
意思決定の強さはUIで設定できます。

00:20:02.000 -> 00:20:11.000
サンプルアプリでは、弱いものはシングルタップで設定され、強いものはダブルタップで設定されますが、UIは本当にあなた次第です。

00:20:11.000 -> 00:20:18.000
そして最後に、この新しいユーザーの決定をシネマティックスクリプトに追加し、スクリプトが変更されました。

00:20:18.000 -> 00:20:21.000
それでは、更新されたスクリプトがどのように焦点を集中させるかについて話しましょう。

00:20:21.000 -> 00:20:29.000
これを通常のクリップの長さと考え、3つの決定と対応するフォーカス検出トラックを見てみましょう。

00:20:29.000 -> 00:20:34.000
2Dプロットで時間と距離に応じてフォーカストラックを配置しましょう。

00:20:34.000 -> 00:20:42.000
シネマティックエンジンは更新されたスクリプト全体を知っているので、事前にスムーズなフォーカスの移行を行うことができます。

00:20:42.000 -> 00:20:50.000
フォーカスラックが事前に開始され、各キーフレームの先頭にフォーカスに到達すると、このように見えます。

00:20:50.000 -> 00:21:00.000
それはかなり魔法であり、セットマーカーを知ることで、注意を向け、事前にフォーカスをラックすることができるフォーカスプラーのように機能します。

00:21:00.000 -> 00:21:07.000
ラックされたフォーカスの格差は、更新されたシネマティックスクリプトのフレームから直接アクセスできます。

00:21:07.000 -> 00:21:16.000
私はすでにスクリプトフレームを抽出する方法を示しており、フォーカスのフレーム属性を変更することは絞りの変更に似ています。

00:21:16.000 -> 00:21:23.000
更新されたスクリプトからスクリプトフレームを取得したら、フォーカス格差のフレーム属性を直接更新できます。

00:21:23.000 -> 00:21:29.000
これにより、更新されたスクリプトに従ってスムーズなトランジションでフォーカスがレンダラーに渡されます。

00:21:29.000 -> 00:21:34.000
タップしてスクリプトを変更し、サンプルアプリでフォーカスしてみましょう。

00:21:34.000 -> 00:21:41.000
再生モードから編集に移行して、シネマティックスクリプトを更新できるようになりました。

00:21:41.000 -> 00:21:53.000
黄色の破線ボックスとして表示されている弱い決定を得るためにシングルタップするか、強い決定と固体の黄色のボックスを得るためにダブルタップすることによって、焦点の決定を変更することができます。

00:21:53.000 -> 00:22:00.000
異なるプレーヤーをタップすると、ユーザーの入力に応じてフォーカスとレンダリングがどのように変化するかを確認できます。

00:22:00.000 -> 00:22:02.000
これは超かっこいいと思います。

00:22:02.000 -> 00:22:05.000
スクラブ、スクラブ。

00:22:05.000 -> 00:22:08.000
タップ、タップ、タップ。

00:22:08.000 -> 00:22:10.000
絞りを変更します。

00:22:10.000 -> 00:22:15.000
スクラブ、タップ、タップ、ダブルタップ。

00:22:15.000 -> 00:22:19.000
そして、編集が完了したので、これらの編集変更を保存するにはどうすればよいですか?

00:22:19.000 -> 00:22:27.000
スクリプトの変更は別のデータファイルに保存でき、変更を別々に保存すると、オリジナルは変更されません。

00:22:27.000 -> 00:22:30.000
そして、変更はいつでも元に戻すことができます。

00:22:30.000 -> 00:22:41.000
だから私はスクリプトの変更を取得し、コンパクトなバイナリ表現として変更を取得し、データファイルに変更を書き込みます。

00:22:41.000 -> 00:22:45.000
Cinematic APIはデータ表現を処理します。

00:22:45.000 -> 00:22:50.000
また、ニーズに合わせてリロードできるように、このデータをアプリに保存する必要があります。

00:22:50.000 -> 00:22:56.000
スクリプトの変更の読み込みは、3つの同様に簡単なステップで行われます。

00:22:56.000 -> 00:23:04.000
データファイルからバイナリデータを取得し、スクリプトの変更を解凍し、変更をシネマティックスクリプトにリロードします。

00:23:04.000 -> 00:23:09.000
変更は、元のスクリプトと同時に読み込むこともできます。

00:23:09.000 -> 00:23:14.000
そのため、シネマティックスクリプトの変更を編集、レンダリング、保存、ロードすることができます。

00:23:14.000 -> 00:23:21.000
前述のように、カスタムビデオコンポジターを使用して、レンダリングされたビデオをエクスポートできます。

00:23:21.000 -> 00:23:25.000
そして、これらはすぐにフォトライブラリにレンダリングすることができます。

00:23:25.000 -> 00:23:29.000
これはサンプルコードで詳しく説明されています。

00:23:29.000 -> 00:23:38.000
APIには、自動検出なしでオブジェクトに使用できるトラッカーCNObjectTrackerも含まれています。

00:23:38.000 -> 00:23:45.000
サンプルコードは、検出せずにオブジェクトをタップすることでトラッカーをエンゲージする方法をカバーしています。

00:23:45.000 -> 00:23:50.000
また、トラッカーは検出トラックを提供し、スクリプトに追加できます。

00:23:50.000 -> 00:23:53.000
そして今、いくつかのより高度な可能性に。

00:23:53.000 -> 00:24:01.000
また、独自のトラッカーを提供することでカスタムトラッキングを追加し、独自のカスタム検出トラックをスクリプトに追加することもできます。

00:24:01.000 -> 00:24:10.000
また、フレームごとにレンダリング属性にカスタム変更を加えることができ、カスタムトランジションと絞りの変更が可能です。

00:24:10.000 -> 00:24:15.000
個人的には、シネマティックモードと新しいAPIでできることにとても興奮しています。

00:24:15.000 -> 00:24:22.000
そして、それがシンプルなアプリであろうと複雑なエディタであろうと、私たちが考えもしなかったアイデアを思いつくことができると確信しています。

00:24:22.000 -> 00:24:39.000
これは、再生調整で再生用のシネマティックモードビデオアセットを統合し、シネマティックスクリプトとフォーカスを変更して非破壊的な編集と新しいレンダリングを行い、これらのスクリプトの変更を保存してロードできる新しいシネマティックAPIの紹介でした。

00:24:39.000 -> 00:24:42.000
付属のサンプルアプリでこれなどをチェックしてください。

00:24:42.000 -> 00:24:46.000
あなたの集中と幸せなコーディングに感謝します。

00:24:46.000 -> 23:59:59.000
♪ ♪

