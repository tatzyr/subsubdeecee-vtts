WEBVTT

00:00:00.000 -> 00:00:10.000
♪ ♪

00:00:10.000 -> 00:00:15.000
David: こんにちは、ShazamKitチームのエンジニア、David Ilenwaborです。

00:00:15.000 -> 00:00:21.000
ShazamKitは、アプリに音声認識をもたらすことができるフレームワークです。

00:00:21.000 -> 00:00:29.000
Shazamの膨大な音楽カタログとオーディオを照合したり、カスタムカタログを使用して独自の録音済みオーディオと照合したりできます。

00:00:29.000 -> 00:00:36.000
2022年には、ShazamKitにいくつかの素晴らしいアップデートがあり、カスタムカタログでの作業が大規模に改善されました。

00:00:36.000 -> 00:00:52.000
カスタムカタログを使用するときに重いワークフローを処理するためのShazam CLI、より良い同期のための時間制限されたメディアアイテム、およびオーディオの2つの同様のサウンドビットを区別するための周波数スキューイングが導入されました。

00:00:52.000 -> 00:00:59.000
これらの仕組みにまだ慣れていない場合は、ShazamKitビデオでカスタムカタログを大規模に作成してください。

00:00:59.000 -> 00:01:09.000
しかし、簡単な概要を説明するために、ShazamKitでは、オーディオをシグネチャと呼ばれる特別な形式に変換してマッチを実行できます。

00:01:09.000 -> 00:01:16.000
オーディオバッファのストリームまたはシグネチャデータをShazamKitセッションに渡すことができます。

00:01:16.000 -> 00:01:23.000
その後、セッションは署名を使用して、Shazamカタログまたはカスタムカタログで一致するものを見つけます。

00:01:23.000 -> 00:01:31.000
一致がある場合、セッションは一致のメタデータを表すメディアアイテムを持つ一致オブジェクトを返します。

00:01:31.000 -> 00:01:35.000
その後、アプリにメディアアイテムを表示できます。

00:01:35.000 -> 00:01:45.000
ShazamKitは、オーディオバッファのストリームから署名を生成するか、ディスクに保存できる署名ファイルを使用して、一致を実行できます。

00:01:45.000 -> 00:01:53.000
署名は不可逆的であるため、署名から元の記録を再構築することはできません。

00:01:53.000 -> 00:01:57.000
これにより、お客様のプライバシーが保護されます。

00:01:57.000 -> 00:02:11.000
カタログは、関連するメディアアイテムを持つ署名のグループであり、クエリ署名がカタログ内の参照署名の一部と十分に一致する場合に一致が発生します。

00:02:11.000 -> 00:02:18.000
レストランで音楽が再生されるなど、クエリ署名が騒々しい場合でも、一致が発生する可能性があります。

00:02:18.000 -> 00:02:24.000
それをカバーしたので、今年はShazamKitのエキサイティングな新しいアップデートに移ります。

00:02:24.000 -> 00:02:37.000
このセッションでは、ShazamKitでオーディオを認識するための新しい変更を行い、エキサイティングな新機能で再定義されたShazam Library APIについて説明します。

00:02:37.000 -> 00:02:44.000
最後に、ShazamKitでより良いアプリ体験を作成するためのベストプラクティスをいくつかお行します。

00:02:44.000 -> 00:02:51.000
始める前に、開発者ポータルで添付のサンプルコードプロジェクトをダウンロードすることをお勧めします。

00:02:51.000 -> 00:02:56.000
私はこのビデオを通してこのプロジェクトを利用します。

00:02:56.000 -> 00:03:00.000
カバーすることがたくさんあるので、始めます。

00:03:00.000 -> 00:03:04.000
まず、音声認識。

00:03:04.000 -> 00:03:11.000
ShazamKitを使用してマイクからの音声を認識するプロセスは、次の手順で要約できます。

00:03:11.000 -> 00:03:15.000
まず、ユーザーにマイクの許可を求めます。

00:03:15.000 -> 00:03:20.000
次に、許可が付与された後に録画を開始します。

00:03:20.000 -> 00:03:27.000
次に、録音されたオーディオバッファをShazamKitに渡し、最後に結果を処理します。

00:03:27.000 -> 00:03:32.000
これを実証するために、サンプルプロジェクトで見つけることができるデモアプリを構築しました。

00:03:32.000 -> 00:03:40.000
私はダンスが大好きで、最新のトレンドに追いつくために、曲にトレンドのダンスの動きを発見するのに役立つアプリを構築しました。

00:03:40.000 -> 00:03:46.000
このアプリは、マイクを使ってオーディオを聴くことで動作し、ダンスビデオを見つけるために進みます。

00:03:46.000 -> 00:03:50.000
例えば、Siriに曲を探すのを手伝ってもらうことができます。

00:03:50.000 -> 00:03:56.000
ねえ、Siri、デュークスの「Push It」をプレイして。

00:03:56.000 -> 00:03:58.000
Siri: デュークスの「Push It」を再生中。

00:03:58.000 -> 00:04:02.000
David: その後、Learn The Danceボタンをタップして録音を開始できます。

00:04:02.000 -> 00:04:05.000
♪ ♪

00:04:05.000 -> 00:04:11.000
ShazamKitは曲を認識し、アプリはそれに合わせて適切なダンスビデオを検索します。

00:04:11.000 -> 00:04:14.000
私は1つ手に入れたようです。うーん！

00:04:14.000 -> 00:04:17.000
私の双子のダンシングデイブは私にいくつかの動きを見せているようです。

00:04:17.000 -> 00:04:19.000
これはエキサイティングに見えます。

00:04:19.000 -> 00:04:22.000
では、これはどのように実装されましたか?

00:04:22.000 -> 00:04:25.000
コードを案内させてください。

00:04:25.000 -> 00:04:30.000
ここでは、サンプルプロジェクトをXcodeで開きました。

00:04:30.000 -> 00:04:38.000
マイクへのアクセスを要求するために使用されるinfo.plistファイルにマイクの使用状況の説明を追加しました。

00:04:38.000 -> 00:04:43.000
私はまた、ホーム画面とダンスビデオ画面のためのSwiftUIビューのホストを持っています。

00:04:43.000 -> 00:04:49.000
しかし、このマッチャークラスは、音声認識のすべての魔法が起こる場所です。

00:04:49.000 -> 00:04:55.000
初期化時に、オーディオエンジンを設定して設定する方法があります。

00:04:55.000 -> 00:05:03.000
この方法では、タップをインストールしてPCMbuffersを受信し、オーディオエンジンを準備します。

00:05:03.000 -> 00:05:08.000
また、「ダンスを学ぶ」ボタンをタップしたときに呼び出されるマッチメソッドがあります。

00:05:08.000 -> 00:05:17.000
録音許可を要求し、これが許可された場合は、オーディオエンジンのスタートを呼び出すと録音を開始します。

00:05:17.000 -> 00:05:27.000
次に、UIマッチングが開始されたことを伝え、session.resultsを呼び出し、マッチ結果の非同期シーケンスを待ちます。

00:05:27.000 -> 00:05:36.000
結果を受け取った後、一致する場合は一致オブジェクトを設定し、不一致とエラーのケースを処理します。

00:05:36.000 -> 00:05:43.000
このクラスには、オーディオエンジンを停止するstopRecording機能もあります。

00:05:43.000 -> 00:05:51.000
これはうまくいきますが、オーディオバッファを受信する前に、オーディオエンジンを設定するためのセットアップコードがたくさんあることに注意してください。

00:05:51.000 -> 00:05:57.000
特にオーディオプログラミングに精通していない場合は、これを正しく理解するのは難しいかもしれません。

00:05:57.000 -> 00:06:06.000
そして、記録とマッチングを容易にするために、SHManagedSessionと呼ばれる新しいAPIを導入しました。

00:06:06.000 -> 00:06:14.000
マネージドセッションは、オーディオバッファを設定する手間をかけずに、自動的に録音を開始します。

00:06:14.000 -> 00:06:19.000
これにより、セットアップと使用が非常に簡単になります。

00:06:19.000 -> 00:06:22.000
マネージドセッションを使用するには、マイクの許可が必要です。

00:06:22.000 -> 00:06:26.000
この許可がなければ、セッションは録画を開始できません。

00:06:26.000 -> 00:06:35.000
したがって、アプリのinfo.plistファイルにマイクの使用状況の説明エントリを追加することが重要です。

00:06:35.000 -> 00:06:41.000
マネージドセッションは、ユーザーからマイクへのアクセスを求めるときに、この説明を使用します。

00:06:41.000 -> 00:06:46.000
では、このAPIをコードで使用するにはどうすればよいですか?

00:06:46.000 -> 00:06:55.000
まず、SHManagedSessionのインスタンスを作成し、結果メソッドを呼び出すことで結果を待つことができます。

00:06:55.000 -> 00:07:04.000
このメソッドは、一致、NoMatch、またはエラーのいずれかである3つの状態を持つ列挙型を返します。

00:07:04.000 -> 00:07:15.000
次に、一致の場合に返されたメディアアイテムを使用して結果を切り替え、不一致とエラーのケースを処理できます。

00:07:15.000 -> 00:07:21.000
そして、時間の経過とともに多くの結果を返すことができる、より長い録音セッションをしたい場合はどうなりますか?

00:07:21.000 -> 00:07:27.000
さて、managedSessionのasyncシーケンス結果プロパティを使用することでこれを行うことができます。

00:07:27.000 -> 00:07:32.000
以前と同じように、シーケンスから受信した各結果を使用できます。

00:07:32.000 -> 00:07:37.000
これにより、長時間オーディオを録音し続けることができます。

00:07:37.000 -> 00:07:42.000
最後に、managedSessionでキャンセルを呼び出すことで、マッチングを停止できます。

00:07:42.000 -> 00:07:47.000
これにより、現在実行中のマッチ試行がキャンセルされ、録画が停止されます。

00:07:47.000 -> 00:07:48.000
そして、それだけです。

00:07:48.000 -> 00:07:55.000
マネージドセッションでは、記録を開始し、照合後に結果を受け取るのはほんの数行のコードです。

00:07:55.000 -> 00:08:01.000
アプリに戻って、ManagedSessionを使用するようにMatcherの実装を更新します。

00:08:01.000 -> 00:08:13.000
SHSessionのすべてのインスタンスをSHManagedSessionに置き換えることができます。

00:08:13.000 -> 00:08:20.000
その後、オーディオエンジンの設定方法とその使用法を削除できます。

00:08:20.000 -> 00:08:29.000
そして、マッチメソッドでは、録音許可を要求し、オーディオエンジンを起動するために呼び出しを削除することができます。

00:08:29.000 -> 00:08:43.000
最後に、stopRecordingメソッドでは、オーディオエンジンを停止するための既存のコードを、managedSessionのキャンセルメソッドを呼び出すだけで置き換えることができます。

00:08:43.000 -> 00:08:48.000
次に、アプリを実行して、すべてが期待どおりに機能していることを確認します。

00:08:48.000 -> 00:08:53.000
ねえ、Siri、デュークスの「Push It」をプレイして。

00:08:53.000 -> 00:08:55.000
Siri:これはデュークスの「Push It」です。

00:08:55.000 -> 00:08:57.000
♪ ♪

00:08:57.000 -> 00:08:58.000
エキサイティング！

00:08:58.000 -> 00:09:06.000
すべてが正常に動作していますが、今回はマネージドセッションでコードがさらに良く、クリーンになります。

00:09:06.000 -> 00:09:07.000
それだけですか？

00:09:07.000 -> 00:09:11.000
マネージドセッションについて話すことはさらにたくさんあります。

00:09:11.000 -> 00:09:18.000
ユースケースによっては、ManagedSessionが事前に試合の試みに備えることをお勧めします。

00:09:18.000 -> 00:09:23.000
マネージドセッションを準備すると、マッチング時にセッションの応答性が向上します。

00:09:23.000 -> 00:09:32.000
また、試合に必要なリソースを事前に割り当て、試合の試みを見越して事前記録を開始します。

00:09:32.000 -> 00:09:40.000
準備を使用する利点のアイデアを与えるために、ここに準備を呼び出すことなくセッションの動作を表すタイムラインがあります。

00:09:40.000 -> 00:09:53.000
結果を求めると、セッションは一致試行のリソースを割り当て、記録を開始し、最後に一致を返します。

00:09:53.000 -> 00:10:00.000
ただし、準備を呼び出すと、セッションはすぐにリソースを事前に割り当て、事前録音を開始します。

00:10:00.000 -> 00:10:07.000
その後、結果を尋ねると、セッションは以前よりも速く一致を返します。

00:10:07.000 -> 00:10:13.000
コードでこれを行うには、結果を尋ねる前にprepareメソッドを呼び出すだけです。

00:10:13.000 -> 00:10:20.000
このメソッドを呼び出すのは完全にあなた次第であり、必要に応じてShazamKitはあなたに代わってそれを呼び出します。

00:10:20.000 -> 00:10:25.000
さて、「セッションの現在の動作を追跡するにはどうすればよいですか?」と疑問に思うかもしれません。

00:10:25.000 -> 00:10:33.000
「たとえば、長時間のセッションでは、「録音、マッチング、または何か他のことをしていることをどうやって知ることができますか?」

00:10:33.000 -> 00:10:41.000
これを助けるために、マネージドセッションには、セッションの現在の状態を表すstateというプロパティがあります。

00:10:41.000 -> 00:10:49.000
3つの状態は、アイドル状態、事前記録、およびマッチングです。

00:10:49.000 -> 00:10:55.000
アイドル状態では、セッションは記録も試合の試みもしていません。

00:10:55.000 -> 00:11:10.000
これは、セッションが1回の一致試行を完了したか、キャンセルを呼び出した場合、または複数の一致を実行するときにセッションが結果の非同期シーケンスを終了する場合に当てはまります。

00:11:10.000 -> 00:11:15.000
事前録音は、セッションが準備された後の状態を表します。

00:11:15.000 -> 00:11:23.000
この状態では、マッチングに必要なすべてのリソースの準備が整い、セッションはマッチの試みのために事前に記録されています。

00:11:23.000 -> 00:11:28.000
その後、事前録音の照合またはキャンセルを続行できます。

00:11:28.000 -> 00:11:34.000
マッチングは、セッションが少なくとも1回のマッチング試行をしていることを示す3番目の可能な状態です。

00:11:34.000 -> 00:11:38.000
この状態で準備を呼び出すことは、セッションによって無視されます。

00:11:38.000 -> 00:11:45.000
以下は、スウィフトUIでマネージドセッション状態を使用してビューの動作を促進する方法の例です。

00:11:45.000 -> 00:11:51.000
ここでは、デモアプリからのサブビューの実装例があります。

00:11:51.000 -> 00:11:58.000
状態がアイドル状態または一致している場合、このビューに異なる動作を実装しました。

00:11:58.000 -> 00:12:05.000
現在、セッションの状態はアイドル状態であり、テキストビューはHear Musicに設定されています。

00:12:05.000 -> 00:12:10.000
また、状態が一致しているかどうかを確認する条件があります。

00:12:10.000 -> 00:12:18.000
そうでない場合は、進行状況ビューを表示し、そうでない場合は、ダンスを学ぶボタンを表示します。

00:12:18.000 -> 00:12:24.000
状態は現在アイドル状態なので、ダンスを学ぶボタンが表示されます。

00:12:24.000 -> 00:12:31.000
ボタンをタップすると、状態が一致に変わり、UIが自動的に更新されます。

00:12:31.000 -> 00:12:41.000
今回はテキストがマッチングに設定され、マッチングが開始されたため、進行状況ビューがボタンを置き換えます。

00:12:41.000 -> 00:12:50.000
セッションの状態が変更されるたびに、SwiftUIは自動的にビューを更新し、余分な作業なしでそれらの変更に応答します。

00:12:50.000 -> 00:13:00.000
これは、managedSessionがObservableに準拠しているためです。これは、オブジェクトが変更をオブザーバーに自動的に通信させる新しいSwiftタイプです。

00:13:00.000 -> 00:13:06.000
したがって、SwiftUIはmanagedSessionの状態変更に簡単に対応できます。

00:13:06.000 -> 00:13:12.000
Observableの詳細については、Discover Observation of SwiftUIビデオをご覧ください。

00:13:12.000 -> 00:13:19.000
音声認識を取り上げたので、Shazamライブラリについて話します。

00:13:19.000 -> 00:13:29.000
2021年、ShazamKitは、有効なShazam IDがあれば、開発者がShazamライブラリに一致結果を書き込むことを可能にするAPIを提供しました。

00:13:29.000 -> 00:13:34.000
これは、Shazamカタログの曲に対応することを意味します。

00:13:34.000 -> 00:13:42.000
追加されたアイテムは、コントロールセンターの音楽認識モジュールとインストールされている場合はShazamアプリに表示されます。

00:13:42.000 -> 00:13:45.000
また、デバイス間で同期されます。

00:13:45.000 -> 00:13:59.000
Shazamライブラリに書き込むのに特別な許可は必要ありませんが、ライブラリに保存されているすべての曲は、それらを追加したアプリに起因するため、顧客に知らせずにコンテンツを保存しないことをお勧めします。

00:13:59.000 -> 00:14:06.000
ここでは、リストの2番目の曲はShazamKit Dance Finderアプリによるものです。

00:14:06.000 -> 00:14:13.000
長年にわたり、このAPIの使用はさまざまなユースケースを提示し、いくつかの欠点につながりました。

00:14:13.000 -> 00:14:18.000
たとえば、自分のアプリに追加したアイテムを表示したい場合はどうなりますか?

00:14:18.000 -> 00:14:27.000
頼りになる解決策は、処理するのが面倒でバグが発生しやすい独自のローカルストレージを管理することです。

00:14:27.000 -> 00:14:32.000
これらの欠点のために、SHLibraryと呼ばれる新しいクラスが導入されました。

00:14:32.000 -> 00:14:40.000
以前のSHMediaLibraryクラスと比較して、より広範な機能を提供するため、SHLibraryを採用することをお勧めします。

00:14:40.000 -> 00:14:57.000
SHLibraryのコア機能には、SHMediaLibraryの対応する方法と同じように機能するShazamライブラリへのメディアアイテムの追加、メディアアイテムの読み取り、ライブラリからのメディアアイテムの削除などがあります。

00:14:57.000 -> 00:15:02.000
アプリはライブラリに追加したものしか読み取ったり削除したりできないことに注意してください。

00:15:02.000 -> 00:15:10.000
読んだときに返されるアイテムはアプリに固有のものであり、ライブラリ全体を表すものではありません。

00:15:10.000 -> 00:15:16.000
また、アプリが追加していないメディアアイテムを削除しようとすると、エラーがスローされます。

00:15:16.000 -> 00:15:21.000
次に、SHLibraryの使い方を説明します。

00:15:21.000 -> 00:15:29.000
SHLibraryでの追加は、デフォルトのライブラリオブジェクトのaddItemsメソッドを呼び出すのと同じくらい簡単です。

00:15:29.000 -> 00:15:33.000
このメソッドは、追加するメディアアイテムの配列を取ります。

00:15:33.000 -> 00:15:36.000
図書館からの読書も同様に簡単です。

00:15:36.000 -> 00:15:42.000
例として、ライブラリからアイテムを読み取り、SwiftUIでリストビューに入力する方法は次のとおりです。

00:15:42.000 -> 00:15:48.000
ライブラリオブジェクトのアイテムプロパティをリスト初期化子に渡すだけです。

00:15:48.000 -> 00:15:59.000
SHLibraryは新しいSwift Observableタイプにも準拠しているため、変更があるとSwiftUIビューが自動的にリロードされます。

00:15:59.000 -> 00:16:03.000
また、非UIコンテキストでライブラリから読み取ることもできます。

00:16:03.000 -> 00:16:13.000
たとえば、同期されたShazamsからユーザーの最も人気のあるジャンルを取得したい場合は、ライブラリの現在のアイテムを尋ねることができます。

00:16:13.000 -> 00:16:24.000
次に、これを手に入れたら、アイテムの配列をフィルタリングして、返されたすべてのジャンルを取得し、最も高い頻度でジャンルを数えることができます。

00:16:24.000 -> 00:16:34.000
最後に、ライブラリオブジェクトのremoveItemsを呼び出して、削除するメディアアイテムの配列を渡すことで、ライブラリからアイテムを削除できます。

00:16:34.000 -> 00:16:42.000
アプリに戻ると、認識された曲をライブラリに追加したので、新しいSHLibraryを使用してこれらの曲を読むことができます。

00:16:42.000 -> 00:16:49.000
RecentDancesViewには、初期化子に空のmediaItems配列を含むリストがあります。

00:16:49.000 -> 00:16:58.000
空の配列をSHLibraryのアイテムに置き換えて、ライブラリのアイテムを自動的に読み込みます。

00:16:58.000 -> 00:17:02.000
これらの変更でアプリを実行します。

00:17:02.000 -> 00:17:09.000
アプリが読み込まれるとすぐに、アプリがShazamライブラリに追加した曲のリストを受け取ります。

00:17:09.000 -> 00:17:16.000
SHLibraryを使用すると、この機能を無料で利用でき、一致した曲のデータベースを維持する必要はありません。

00:17:16.000 -> 00:17:24.000
次に、各行のアクションを削除するスワイプを追加して、ライブラリから曲を削除します。

00:17:24.000 -> 00:17:29.000
行ビューにスワイプアクションを追加できます。

00:17:29.000 -> 00:17:42.000
次に、スワイプボタンをタップすると、SHLibraryのremoveItemsメソッドを呼び出して、削除するメディアアイテムを渡すことができます。

00:17:42.000 -> 00:17:46.000
これで完了したら、これらの変更でアプリを実行します。

00:17:46.000 -> 00:17:49.000
iPadでもアプリを開いています。私はアプリを開いています。

00:17:49.000 -> 00:17:54.000
iPhoneでアイテムをスワイプして、削除ボタンをタップできます。

00:17:54.000 -> 00:18:00.000
変更は同期され、削除された項目もiPadのリストから削除されます。

00:18:00.000 -> 00:18:02.000
これは素晴らしいです。

00:18:02.000 -> 00:18:16.000
新しいライブラリAPIの使用方法と、マネージドセッションを使用して記録を処理する方法を学んだので、今年導入された新機能のいくつかを使用する際のベストプラクティスを紹介し、いくつかのヒントを提供します。

00:18:16.000 -> 00:18:20.000
SHManagedSessionとSHSessionは密接に関連しています。

00:18:20.000 -> 00:18:25.000
彼らは異なる方法ではありますが、ほぼ同じことを達成することができます。

00:18:25.000 -> 00:18:31.000
ShazamKitに録音を処理させたいときは、managedSessionを使用してください。

00:18:31.000 -> 00:18:37.000
オーディオバッファを生成してフレームワークに渡すときは、SSHSessionを使用してください。

00:18:37.000 -> 00:18:43.000
managedSessionを使用して、マイクまたはAirPodからの音声を認識します。

00:18:43.000 -> 00:18:49.000
マイクからのオーディオストリーミングのみを認識したい場合は、SSHSessionを使用してください。

00:18:49.000 -> 00:18:54.000
任意の署名とmanagedSessionとのマッチングはサポートされていません。

00:18:54.000 -> 00:19:02.000
したがって、署名ファイルまたはメモリにロードされた署名データがある場合は、SHSessionを使用して一致させます。

00:19:02.000 -> 00:19:14.000
最後に、managedSsessionはマッチングのオーディオフォーマットを自動的に処理し、SHSessionは複数のPCMオーディオフォーマットとのマッチングを可能にします。

00:19:14.000 -> 00:19:27.000
SHSessionのオーディオフォーマットといえば、以前は、matchStreamingBufferメソッドは、これらのサンプルレートで特定のフォーマット設定でPCMオーディオバッファを一致させることしか許可しませんでした。

00:19:27.000 -> 00:19:32.000
サポートされていない設定のオーディオバッファは、NoMatchになりました。

00:19:32.000 -> 00:19:41.000
このリリースでは、SSHSessionは、さまざまなレートでサンプリングされたほとんどのフォーマット設定でPCMバッファをサポートするようになりました。

00:19:41.000 -> 00:19:48.000
これらのバッファを渡すと、SHSessionがフォーマット変換を処理します。

00:19:48.000 -> 00:20:04.000
最後に、カスタムカタログで同じように聞こえる2つ以上のオーディオビットがある場合、ShazamKitは、複数の参照署名に一致するクエリ署名を渡すと、カスタムカタログからすべての一致を返すことができます。

00:20:04.000 -> 00:20:12.000
マッチは返され、最高のマッチ品質でソートされ、必要な適切なマッチ結果をフィルタリングできます。

00:20:12.000 -> 00:20:24.000
ヒントとして、それぞれのメタデータで似ているように聞こえる参照署名に適切に注釈を付けて、必要な結果を区別することができます。

00:20:24.000 -> 00:20:27.000
これを達成する方法の例を次に示します。

00:20:27.000 -> 00:20:33.000
すべてのエピソードが同じイントロサウンドを持つテレビ番組があるとします。

00:20:33.000 -> 00:20:40.000
各エピソードを表す参照署名でtelevisionShowCatalogを生成できます。

00:20:40.000 -> 00:20:51.000
このカタログを使用してセッションを作成でき、イントロセクションを照合すると、ShazamKitは各エピソードのmediaItemsとの一致結果を返します。

00:20:51.000 -> 00:21:01.000
その後、mediaItemsをフィルタリングして、エピソード2などの特定のエピソードのmediaItemsのみを返すことができます。

00:21:01.000 -> 00:21:05.000
これが適切な注釈がどのように役立つかです。

00:21:05.000 -> 00:21:14.000
今年はすべてエキサイティングなアップデートを経験したので、素晴らしいアプリに切り替えて、もう1つのダンスを学ぼうとします。

00:21:14.000 -> 00:21:17.000
AirPodsに切り替えて曲を再生します。

00:21:17.000 -> 00:21:25.000
私はアプリでマネージドセッションを使用しているので、AirPodで再生されているオーディオを聴いて、私のためにダンスビデオを見つけることができます。

00:21:25.000 -> 00:21:35.000
AirPodsのタッチコントロールを押して曲を再生し、アプリが音声を検出するのを待ちます。

00:21:35.000 -> 00:21:36.000
甘い！

00:21:36.000 -> 00:21:43.000
ダンシングデイブはいくつかのアフロビートの動きを披露しているようですが、この話の後に学ぶために最善を尽くします。

00:21:43.000 -> 00:21:47.000
あなたがこれらの新しいアップデートに私たちと同じくらい興奮していることを願っています。

00:21:47.000 -> 00:21:51.000
ご参加いただきありがとうございます。素晴らしいWWDCをお過ごしください。

00:21:51.000 -> 23:59:59.000
♪ ♪

