WEBVTT

00:00:00.000 -> 00:00:10.000
♪ ♪

00:00:10.000 -> 00:00:15.000
Dima: こんにちは、「iOS 17のUIKitの新機能」へようこそ。

00:00:15.000 -> 00:00:19.000
私はUIKitチームのエンジニアリングマネージャーであるDimaです。

00:00:19.000 -> 00:00:28.000
アプリケーションの背後にある強力なフレームワークであるUIKitは、iOS 17の新機能をサポートするようにアップグレードされました。

00:00:28.000 -> 00:00:50.000
このビデオでは、新しい主要機能とコアアーキテクチャの改善、言語設定に関係なくすべてのユーザーのためのインターフェイスの構築の進歩、iPadOSアプリの改善、およびリリースに含まれる多数の一般的な機能強化について説明します。

00:00:50.000 -> 00:01:03.000
UIKitに主要なアーキテクチャの強化を導入し、強力なアプリケーションの作成を容易にし、SwiftUIとの統合を劇的に改善しました。

00:01:03.000 -> 00:01:07.000
5つの主要な新機能をご案内します。

00:01:07.000 -> 00:01:23.000
Xcodeプレビューのサポート、コントローラーのライフサイクルの更新、トレイトシステムの進歩、アニメーションシンボル画像、アプリの空の状態を表す新しいAPIについて説明します。

00:01:23.000 -> 00:01:26.000
まず、大きな変化。

00:01:26.000 -> 00:01:30.000
XcodeのプレビューはUIKitで直接使用できます。

00:01:30.000 -> 00:01:38.000
この機能を利用するには、プレビューマクロを使用してプレビューの名前を指定し、ビューコントローラーを返します。

00:01:38.000 -> 00:01:46.000
プレビューにデータを設定して入力するためだけに、ビューコントローラーの任意のプロパティを設定できます。

00:01:46.000 -> 00:01:51.000
UIViewsを直接プレビューすることもでき、ビューコントローラーは必要ありません。

00:01:51.000 -> 00:01:59.000
プレビューは、UIコンポーネントを視覚化し、コードを反復する際に即座にフィードバックを与えるのに役立ちます。

00:01:59.000 -> 00:02:07.000
そして、アプリが作成されると、Xcodeプレビューは構成と設定の配列にわたるテストを可能にします。

00:02:07.000 -> 00:02:20.000
次に、ビューコントローラーを提示したり、ナビゲーションコントローラーを押したりポップしたりするときなど、外観遷移中のビューコントローラーのライフサイクルの重要な改善をカバーしたいと思います。

00:02:20.000 -> 00:02:30.000
viewIsAppearingという名前の新しいビューコントローラーコールバックがあり、viewWillAppearの後、viewDidAppearの前に呼び出されます。

00:02:30.000 -> 00:02:37.000
viewIsAppearingは、ビューが表示されるたびに物事を行うのに最適な場所です。

00:02:37.000 -> 00:02:43.000
呼び出されると、ビューコントローラーとビューの両方に最新のトレイトコレクションがあります。

00:02:43.000 -> 00:02:50.000
さらに、ビューは階層に追加され、そのスーパービューによってレイアウトされています。

00:02:50.000 -> 00:02:59.000
これにより、viewIsAppearingは、サイズを含むビューの初期ジオメトリに依存するコードを実行するための理想的なコールバックになります。

00:02:59.000 -> 00:03:12.000
最後に、この新しいviewIsAppearingメソッドはiOS 13に展開されるため、アプリが古いバージョンのiOSで実行されている場合でも、それを活用できます。

00:03:12.000 -> 00:03:23.000
これは、新しいviewIsAppearingコールバックが、典型的なビューコントローラーの外観遷移中に他の重要なイベントとどのように適合するかの図です。

00:03:23.000 -> 00:03:27.000
いくつか指摘したいことがあります。

00:03:27.000 -> 00:03:34.000
まず、ビューが階層に追加される前、およびレイアウトが始まる前に、viewWillAppearがどのように呼び出されるかに注意してください。

00:03:34.000 -> 00:03:43.000
このため、特性コレクションを使用したり、ビューのサイズやその他のジオメトリに依存することをするのは時期尚早です。

00:03:43.000 -> 00:03:53.000
次に、アニメーションが行われた後、最後に別のCATransactionでviewDidAppearがどのように呼び出されるかに注目してください。

00:03:53.000 -> 00:04:05.000
つまり、viewDidAppearで行った変更は、トランジションが完了するまで表示されなくなるため、トランジション中に表示したい変更を行うには遅すぎます。

00:04:05.000 -> 00:04:12.000
一方、viewIsAppearingはviewWillAppearと同じトランザクション内で呼び出されます。

00:04:12.000 -> 00:04:24.000
これは、これらのコールバックのいずれかで行った変更が、トランジションの最初のフレームから同時にユーザーに表示されることを意味します。

00:04:24.000 -> 00:04:35.000
最後に、タイミングは似ているかもしれませんが、viewIsAppearingとviewWillLayoutSubviewsのようなレイアウトコールバックの間には重要な違いがあります。

00:04:35.000 -> 00:04:48.000
レイアウトコールバックは、ビューがlayoutSubviewsを実行するたびに行われます。これは、トランジション中に複数回、またはビューが表示されている間に発生する可能性があります。

00:04:48.000 -> 00:04:58.000
しかし、viewIsAppearingは外観遷移中に一度だけ呼び出され、ビューがレイアウトを必要としない場合でも呼び出されます。

00:04:58.000 -> 00:05:07.000
これが、viewIsAppearingをGoldilocksのコールバックとして考えるのが好きな理由です。早すぎたり、遅すぎたり、頻繁に呼び出されたりしません。

00:05:07.000 -> 00:05:09.000
それはちょうどいい。

00:05:09.000 -> 00:05:15.000
UIKitの特性システムは、iOS 17でアップグレードされました。

00:05:15.000 -> 00:05:18.000
特性は、アプリの階層を通じて自動的にデータを伝播します。

00:05:18.000 -> 00:05:31.000
UITraitCollectionには、ユーザーインターフェイススタイル、水平および垂直サイズクラス、優先コンテンツサイズカテゴリなど、多くのシステム特性が含まれています。

00:05:31.000 -> 00:05:37.000
これで、カスタムトレイトを定義して、独自のデータをUITraitCollectionに追加できます。

00:05:37.000 -> 00:05:44.000
これは、アプリのビューとビューコントローラーにデータを伝播するためのまったく新しい方法です。

00:05:44.000 -> 00:05:53.000
また、任意のビューまたはビューコントローラーのトレイト値を簡単に変更するために、新しいトレイトオーバーライドAPIを追加しました。

00:05:53.000 -> 00:06:05.000
また、サブクラスでtraitCollectionDidChangeをオーバーライドする代わりに、特性が値を変更したときにコールバックを受け取るために、より柔軟なAPIを採用することもできます。

00:06:05.000 -> 00:06:17.000
最後に、カスタムUIKit特性とカスタムSwiftUI環境キーをブリッジして、アプリ内のUIKitとSwiftUIコンポーネント間でデータをシームレスに渡すことができます。

00:06:17.000 -> 00:06:26.000
これらのエキサイティングな新しい機能強化についてすべて学ぶには、ビデオ「UIKit特性システムを解き放つ」をチェックしてください。

00:06:26.000 -> 00:06:36.000
すべてのプラットフォームで、SFシンボルはツールバーのアイコン、ナビゲーションバー、その他のUI要素の一貫した外観を可能にします。

00:06:36.000 -> 00:06:46.000
それらはテキストラベルと自動的に整列するように設計されており、アプリのデザインに合わせて重量、スケール、外観を簡単にカスタマイズできます。

00:06:46.000 -> 00:06:54.000
iOS 17では、UIKitは新しいシンボルエフェクトAPIでアニメーションシンボルをサポートしています。

00:06:54.000 -> 00:07:00.000
これらの効果は、カスタム画像であっても、あらゆるシンボル画像に適用できます。

00:07:00.000 -> 00:07:07.000
シンボル効果を適用するには、UIImageViewで新しいaddSymbolEffect()メソッドを使用します。

00:07:07.000 -> 00:07:14.000
ここでは、バウンス効果を追加します。これにより、シンボルが1回バウンスします。

00:07:14.000 -> 00:07:17.000
次に、可変色効果を追加します。

00:07:17.000 -> 00:07:24.000
バウンスとは異なり、可変色効果は追加すると無期限にアニメーション化されます。

00:07:24.000 -> 00:07:29.000
removeSymbolEffect() メソッドを使用して効果を終了します。

00:07:29.000 -> 00:07:39.000
最後に、新しいsetSymbolImage()メソッドを使用して、シンボル間でトランジション効果を実行できます。

00:07:39.000 -> 00:07:43.000
私が調べた3つの機能よりも、シンボル効果にはもっと多くのものがあります。

00:07:43.000 -> 00:07:49.000
詳細については、ビデオ「アプリでシンボルをアニメーション化」をご覧ください。

00:07:49.000 -> 00:07:55.000
次に、空の状態を簡単に表現できるように、新しいAPIを追加しました。

00:07:55.000 -> 00:08:05.000
空の状態は、アプリに表示するコンテンツがない瞬間です。

00:08:05.000 -> 00:08:10.000
コンテンツが作成されていないため、通常、アプリの最初の起動時に発生します。

00:08:10.000 -> 00:08:17.000
また、インターネット接続の欠如などの制限により、アプリがコンテンツを表示できない場合にも発生します。

00:08:17.000 -> 00:08:29.000
UIContentUnavailableConfigurationは、空の状態の構成可能な説明であり、画像やテキストなどのプレースホルダコンテンツを提供できます。

00:08:29.000 -> 00:08:35.000
この例では、表示するお気に入りの翻訳がないことをお知らせします。

00:08:35.000 -> 00:08:43.000
この空の状態を表すために、設定をビューコントローラーのcontentUnavailableConfigurationとして設定しました。

00:08:43.000 -> 00:08:52.000
.Empty() 設定に加えて、UIKit は準備中のコンテンツを表す .loading() 設定を提供します。

00:08:52.000 -> 00:09:02.000
さらに、UIHostingConfiguration APIを活用して、SwiftUIビューでアプリの空の状態を表すことができます。

00:09:02.000 -> 00:09:08.000
これは、セルでUIHostingConfigurationを使用するのと同じように機能します。

00:09:08.000 -> 00:09:20.000
ビューコントローラーのコンテンツ利用できない構成を更新するのに最適な場所は、新しいメソッド、updateContentUnavailableConfiguration（使用：状態）です。

00:09:20.000 -> 00:09:28.000
この例では、結果を返さないクエリ用に設計された .search 設定を使用しています。

00:09:28.000 -> 00:09:38.000
この設定は、ローカライズされたプライマリテキストとセカンダリテキストを提供し、クエリは近くの検索コントローラーから補間されます。

00:09:38.000 -> 00:09:49.000
ビューコントローラーのコンテンツの可用性が変更されるたびに、setNeedsUpdateContentUnavailable Configurationを呼び出すと、更新をリクエストします。

00:09:49.000 -> 00:09:59.000
すべてのAppleプラットフォームで、言語設定に関係なく、一貫性のある高品質のエクスペリエンスを提供することが不可欠です。

00:09:59.000 -> 00:10:07.000
それを促進するために、私たちはフォントとテキストレンダリングの分野で大きな進歩を遂げました。

00:10:07.000 -> 00:10:17.000
このセクションでは、特定のフォントや言語でのテキストのクリッピングや衝突を防ぐのに役立つ動的な行の高さ調整について説明します。

00:10:17.000 -> 00:10:27.000
また、改善された改行ルールとハイフネーションルール、およびロケールに基づいて画像を要求する新しいAPIについても学びます。

00:10:27.000 -> 00:10:32.000
まず、フォントとその指標を詳しく見てみましょう。

00:10:32.000 -> 00:10:35.000
フォントメトリックは、いくつかの用語を使用して定義されます。

00:10:35.000 -> 00:10:42.000
ベースラインは、文字や単語が休む架空の線を表します。

00:10:42.000 -> 00:10:46.000
線の高さは、これらのベースラインの間のスペースを指します。

00:10:46.000 -> 00:10:53.000
そして、x-heightは小文字の上にある線です。

00:10:53.000 -> 00:10:59.000
一部のフォントには、これらの行を超えて広がるアセンダとディセンダーがあります。

00:10:59.000 -> 00:11:03.000
アセンダーは、x-heightの上に伸びるフォントの一部です。

00:11:03.000 -> 00:11:08.000
一方、ディセンダーはベースラインの下にぶら下がっています。

00:11:08.000 -> 00:11:22.000
アラビア語、ヒンディー語、タイ語などの一部の言語では、これらの要素はラテン文字よりもはるかに多くの垂直空間を必要とし、衝突やクリッピングの問題につながる可能性があります。

00:11:22.000 -> 00:11:32.000
すべての言語でアセンダとディセンダーの重複を防ぐために、動的な線の高さ調整機能を導入しました。

00:11:32.000 -> 00:11:42.000
これにより、UILabelsなどのテキスト要素は、最適な読みやすさのために、行の高さと垂直方向の寸法を自動的に調整できます。

00:11:42.000 -> 00:11:51.000
また、中国語、ドイツ語、日本語、韓国語などの言語の改行行動を大幅に強化しました。

00:11:51.000 -> 00:11:59.000
これらの改善は、使用しているテキストスタイルの種類に応じて異なるルールを適用します。

00:11:59.000 -> 00:12:15.000
テキストスタイルを採用している限り、ほとんどの場合、これは自動的に機能しますが、ベストプラクティスとアプリがすべての言語で動作することを確認する方法の詳細については、「テキストとテキストインタラクションの新機能」をチェックしてください。

00:12:15.000 -> 00:12:23.000
特定の状況では、UIのかなりの部分が、ユーザーが選択した言語とは異なる言語で表示される場合があります。

00:12:23.000 -> 00:12:26.000
例えば、コンテンツがウェブから来たとき。

00:12:26.000 -> 00:12:38.000
このような場合、新しい組版言語特性を使用してインターフェイスの言語を示すことができ、それに応じて行の高さとハイフネーションのルールを調整するのに役立ちます。

00:12:38.000 -> 00:12:43.000
UIKitは、画像の特定のローカライズされたバリアントへのアクセスをサポートするようになりました。

00:12:43.000 -> 00:12:51.000
たとえば、character.textbox SFシンボルには8つの異なるロケールベースのバリアントがあります。

00:12:51.000 -> 00:12:56.000
デフォルトでは、UIKitはデバイスの現在の言語設定に一致するバリアントを引き出します。

00:12:56.000 -> 00:13:04.000
したがって、現在の言語が米国の場合英語、その後、ラテン語の変種が表示されます。

00:13:04.000 -> 00:13:13.000
iOS 17では、アプリは画像の構成でロケールを提供することで、特定のバリアントを要求できます。

00:13:13.000 -> 00:13:20.000
ここでは、日本語のロケールで設定を提供することで、シンボルの日本語版を調べます。

00:13:20.000 -> 00:13:29.000
テキストレンダリングとロケールサポートに対するこれらすべての変更により、あなたのアプリは誰にとっても自宅に近いと感じることができます。

00:13:29.000 -> 00:13:35.000
では、iPad用のアプリを構築するための改善を案内します。

00:13:35.000 -> 00:13:56.000
新しいウィンドウのドラッグインタラクション、ステージマネージャーのサイドバーの動作の強化、キーボードスクロールのサポート、ドキュメント中心のアプリの構築の進歩、新しいApple Pencilの機能とAPIの5つの分野の改善について説明します。

00:13:56.000 -> 00:14:07.000
iOS 17では、ドラッグジェスチャーを開始できる領域を拡大することで、ステージマネージャーのウィンドウドラッグ機能を更新しました。

00:14:07.000 -> 00:14:14.000
これで、UINavigationBar内の任意の場所をドラッグすると、ウィンドウの移動が開始されます。

00:14:14.000 -> 00:14:23.000
このジェスチャーは、パンやスワイプジェスチャーなど、アプリに存在する可能性のある他のジェスチャーリコグナイザとうまく機能します。

00:14:23.000 -> 00:14:34.000
アプリのUIの一部としてUINavigationBarを使用していない場合は、UIWindowSceneDragInteractionを採用し、任意のビューに追加できます。

00:14:34.000 -> 00:14:42.000
また、アプリで他のパンジェスチャーとのジェスチャー関係を設定して、競合がないことを確認することもできます。

00:14:42.000 -> 00:14:46.000
これは、箱から出してすぐにMac Catalystでも機能します。

00:14:46.000 -> 00:14:54.000
列スタイルのUISplitViewControllersは、ステージマネージャーで優雅に新しいサイズ変更動作を獲得しました。

00:14:54.000 -> 00:15:02.000
サイドバーは必要に応じて自動的に非表示になり、表示が特に要求されるまで非表示のままになります。

00:15:02.000 -> 00:15:12.000
サイドバーが狭い幅で要求された場合、UISplitViewControllerは必要に応じてオーバーレイを使用するか、動作を置き換えます。

00:15:12.000 -> 00:15:17.000
ウィンドウのサイズが大きくなると、オーバーレイされたサイドバーが持続します。

00:15:17.000 -> 00:15:23.000
より大きな幅で却下され、リコールされると、タイル張りで戻ってきます。

00:15:23.000 -> 00:15:29.000
メールなどの3列分割ビューコントローラは、同様に動作します。

00:15:29.000 -> 00:15:36.000
この新しい動作は、ダブルカラムまたはトリプルカラムスタイルで作成されたUISplitViewControllersで発生します。

00:15:36.000 -> 00:16:04.000
要約すると、自動動作は可能な限り列をタイル化し、幅が小さくなると必要に応じてサイドバーを非表示にし、サイドバーボタンがタップされたときにタイルをタイルするのに十分なスペースがない場合は、セカンダリ列をサイドバーにオーバーレイまたは置き換え、preferredDisplayModeとpreferredSplitBehaviorを使用してアプリケーションの動作をオーバーライドできます。

00:16:04.000 -> 00:16:10.000
iPadOS 17では、ドキュメント中心のアプリのサポートを改善しました。

00:16:10.000 -> 00:16:18.000
UIKitは、コンテンツビューコントローラーの基本クラスとして機能する新しいUIDocumentViewControllerを提供します。

00:16:18.000 -> 00:16:32.000
システムのデフォルトのエクスペリエンスを保証し、タイトルメニューの自動設定、共有、ドラッグアンドドロップ、キーコマンドなど、追加の採用なしで多くの機能を提供します。

00:16:32.000 -> 00:16:47.000
さらに、UIDocumentはUINavigationItemRenameDelegateに準拠し、ビューコントローラーのナビゲーションアイテムの名前変更デリゲートとして設定すると、完全な名前変更エクスペリエンスを提供します。

00:16:47.000 -> 00:16:57.000
ドキュメント管理に焦点を当てたアプリのこれらの機能やその他の新機能の詳細については、「より良いドキュメントベースのアプリを構築する」をチェックしてください。

00:16:57.000 -> 00:17:05.000
Apple PencilはiPadOSアプリに余分なファセットを追加し、新しいAPIもたくさんあります。

00:17:05.000 -> 00:17:11.000
新しいiPad ProとiOS 16.4では、Apple Pencilでホバーを導入しました。

00:17:11.000 -> 00:17:17.000
鉛筆からホバーをキャプチャするには、UIHoverGestureRecognizerを使用できます。

00:17:17.000 -> 00:17:24.000
Zオフセットは、0から1の範囲の画面からの正規化されたホバー距離を反映します。

00:17:24.000 -> 00:17:35.000
また、ホバー範囲内で鉛筆の高度と方位角をキャプチャして、ブラシストロークが画面上でどのように見えるかのプレビューを正確にレンダリングすることもできます。

00:17:35.000 -> 00:17:42.000
鉛筆ホバーを使用すると、ホーム画面やアプリのツールバーアイコンにホバーを置くこともできます。

00:17:42.000 -> 00:17:48.000
UIPointerInteractionを使用している場合は、追加の採用は必要ありません。

00:17:48.000 -> 00:17:57.000
しかし、注目すべきは、マウスやトラックパッドの入力とApple Pencilの入力を使用する際の視覚的な相互作用はわずかに異なります。

00:17:57.000 -> 00:18:05.000
たとえば、Apple Pencilを使用している間は、システムポインタなどのポインタスタイルは表示されません。

00:18:05.000 -> 00:18:10.000
アプリでペンシルホバーを試してみてください。

00:18:10.000 -> 00:18:17.000
iOS 17では、PencilKitはさらに表現力豊かになり、新しいインクが導入されます。

00:18:17.000 -> 00:18:24.000
モノラインペンは細部に最適で、一貫したサイズの幅を提供します。

00:18:24.000 -> 00:18:31.000
万年筆は、厚いダウンストロークと薄いアップストロークで、書道を模倣しています。

00:18:31.000 -> 00:18:35.000
水彩画は美しいストロークと表現力を可能にします。

00:18:35.000 -> 00:18:39.000
そして、クレヨンは楽しい追加です。

00:18:39.000 -> 00:18:43.000
新しいインクでは、下位互換性を念頭に置いてください。

00:18:43.000 -> 00:18:50.000
以前のバージョンのiOSでは、新しいインクを含むPKDrawingsを読み込めません。

00:18:50.000 -> 00:19:01.000
PKDrawing、PKStrokeなどのデータモデルタイプの新しいコンテンツバージョンプロパティは、オブジェクトをロードするために必要なPencilKitバージョンを示します。

00:19:01.000 -> 00:19:11.000
1のコンテンツバージョンは、iOS 14と2で出荷されたインクを示し、iOS 17の新しいインク用です。

00:19:11.000 -> 00:19:21.000
優れたユーザーエクスペリエンスを提供するために、このAPIを使用して非互換性を検出し、メッセージを提供したり、フォールバックイメージをレンダリングしたりします。

00:19:21.000 -> 00:19:34.000
下位互換性を維持できない場合は、新しいmaximumSupportedContentVersion APIを使用して、キャンバスとツールピッカーを介して利用可能な機能を制限します。

00:19:34.000 -> 00:19:44.000
Magic Keyboardのようなハードウェアキーボードと組み合わせると、iPadをさらにパワフルにするために、キーボードスクロールのサポートを追加しました。

00:19:44.000 -> 00:19:54.000
iOS 17の新機能では、UIScrollViewsは、可能であれば、ページアップ、ページダウン、ホーム、および終了キーを使用してスクロールできます。

00:19:54.000 -> 00:20:02.000
UIScrollViewの新しいAPIを使用してこの動作をオーバーライドすることができ、KeyboardScrollingを許可します。

00:20:02.000 -> 00:20:09.000
最後に、UIKitの複数の分野で行った一般的な機能強化をご案内します。

00:20:09.000 -> 00:20:23.000
コレクションビューの改善、新しい春のアニメーションパラメータ、テキストインタラクションなど、8つの一般的な機能強化についてお話しします。

00:20:23.000 -> 00:20:31.000
iOS 17で多くのパフォーマンスが向上し、大幅に最適化されたコレクションビューから始めます。

00:20:31.000 -> 00:20:42.000
これらのグラフは、多数のアイテムで操作を実行する場合、iOS 17でコレクションビューがどれだけ高速であるかを示しています。

00:20:42.000 -> 00:20:57.000
iOS 17は、1万個のアイテムを含むコレクションビューの並べ替え順序を反転させるのはiOS 16のほぼ2倍の速さで、それらのアイテムの半分を削除するアップデートを実行するのはほぼ3倍の速さです。

00:20:57.000 -> 00:21:05.000
さらに、アニメーションなしで更新を実行すると、コレクションビューのパフォーマンスがさらに向上します。

00:21:05.000 -> 00:21:16.000
スナップショットを差分可能なデータソースに適用する場合でも、バッチ更新を手動で実行する場合でも、iOS 17ではコレクションビューが全面的に高速になります。

00:21:16.000 -> 00:21:23.000
これらの改善により、アプリの応答性が向上し、アプリのヒッチが減りなくなります。

00:21:23.000 -> 00:21:32.000
さて、最初にかなり典型的なレイアウトの例から始めて、コンポジションレイアウトの強力な新機能について話します。

00:21:32.000 -> 00:21:47.000
これはiPadの新しい健康アプリです。お気に入りセクションは、2つのアイテムの行を持つ構成レイアウトを使用しており、すべてNSCollectionLayoutDimension.estimatedを使用して自己サイジングしています。

00:21:47.000 -> 00:21:54.000
薬の細胞の高さが隣の細胞の高さと一致しないことに注目してください。

00:21:54.000 -> 00:22:00.000
この行のアイテムが同じ高さであれば、これははるかに良く見えるでしょう。

00:22:00.000 -> 00:22:10.000
iOS 17では、Compositional Layoutはまったく新しいレイアウトディメンションを取得します：uniformAcrossSiblings。

00:22:10.000 -> 00:22:20.000
この新機能により、レイアウト内のセルフサイジングアイテムは、最大のアイテムのサイズに基づいて一貫したサイズを受け取ることができます。

00:22:20.000 -> 00:22:28.000
この種のレイアウトが必要な場合は、推定寸法をuniformAcrossSiblingsに置き換えるだけです。

00:22:28.000 -> 00:22:42.000
この機能を使用する場合は、最大のアイテムのサイズを決定するために、すべての兄弟アイテムを作成し、サイズ設定する必要があります。したがって、グループに多数のアイテムがある場合は使用しないでください。

00:22:42.000 -> 00:22:45.000
この健康アプリの例に戻ります。

00:22:45.000 -> 00:22:50.000
このグループには、アイテムの高さが異なる2つのアイテムがあります。

00:22:50.000 -> 00:23:02.000
このレイアウトのすべてのアイテムを更新して、uniformAcrossSiblingsを使用するようにしました。これにより、MedicationsセルはSound Levelsセルの高さに合わせて成長し、必要なレイアウトになります。

00:23:02.000 -> 00:23:13.000
次に、春のアニメーションでは、理解しやすく、作業しやすいパラメータを指定する新しい方法を洗練しています。

00:23:13.000 -> 00:23:19.000
持続時間とバウンスの2つのパラメータのみを使用します。

00:23:19.000 -> 00:23:30.000
期間は、アニメーションが完全に完了するのにかかる時間ではなく、春のアニメーションが落ち着くまでの長さを定義し、バウンスとは無関係です。

00:23:30.000 -> 00:23:40.000
そして、ゼロからバウンスを増やすと、アニメーションの感触を変えることなく、アニメーションにバウンスが追加されます。

00:23:40.000 -> 00:23:45.000
これらのスプリングパラメータを取る新しいメソッドをUIViewに追加しました。

00:23:45.000 -> 00:23:55.000
そして、それらはすべてオプションなので、今では「アニメーション」だけを書いて、システムのデフォルトに一致する春のアニメーションを取得することもできます。

00:23:55.000 -> 00:24:03.000
スプリングを記述するこの新しい方法についてのより多くの洞察を得るために、「スプリングでアニメーション」トークを見てください。

00:24:03.000 -> 00:24:09.000
次に、テキストと対話するための新機能とAPIについて説明します。

00:24:09.000 -> 00:24:19.000
私たちは、新しい再設計された選択ルーペを含む、iOS 17のテキストカーソルとテキスト選択UIにいくつかの重要な改善を行いました。

00:24:19.000 -> 00:24:33.000
ワードプロセッサなどのカスタムテキストビューを持つ開発者は、UITextInteractionをすべて採用することなく、選択UIにシステムが提供するビューを使用できるようになりました。

00:24:33.000 -> 00:24:50.000
テキストビューのテキストアイテムのインタラクションは、UITextViewDelegateの新しいAPIを通じてよりカスタマイズ可能になり、リンクやテキスト添付ファイルなどのテキストアイテムのプライマリアクションやメニューを変更できるようになりました。

00:24:50.000 -> 00:25:01.000
さらに、コンテンツのカスタム範囲にタグを付けてインタラクションを有効にすることもできます。これにより、リンクではないテキストにアクションやメニューを簡単に追加できます。

00:25:01.000 -> 00:25:11.000
テキストカーソルの改善とテキスト項目のアクションとメニューの詳細については、「テキストとテキストのインタラクションの新機能」をご覧ください。

00:25:11.000 -> 00:25:19.000
次に、iOSの確立された要素であるステータスバーに関する最新情報を提供します。

00:25:19.000 -> 00:25:31.000
iOSのステータスバーのスタイリングは、その下のアプリケーションによって制御され、アプリまたはビューコントローラーがダークモードまたはライトモードになっていることに基づいて切り替わるデフォルトのスタイルです。

00:25:31.000 -> 00:25:37.000
ユーザーコンテンツでは、コントラストを確保するために正しく取得するのが難しい場合があります。

00:25:37.000 -> 00:25:43.000
アプリが明るいユーザーインターフェイスを使用しているため、ここでのデフォルトのスタイルは暗いです。

00:25:43.000 -> 00:25:48.000
しかし、ユーザーコンテンツの一部は暗いです。

00:25:48.000 -> 00:26:00.000
現在、iOS 17では、デフォルトのスタイルはアプリのコンテンツに継続的に調整され、コントラストを維持するためにダークスタイルとライトスタイルの間で自動的に変更されます。

00:26:00.000 -> 00:26:06.000
必要に応じて、ステータスバーがスタイルをこぼすことさえできます。

00:26:06.000 -> 00:26:18.000
アプリはこれらすべてのケースでダークとライトを明示的に指定する必要がなくなったため、カスタマイズコードを削除し、デフォルトのスタイルを利用する機会があります。

00:26:18.000 -> 00:26:22.000
iOS 17では、ドラッグ&amp;ドロップがより強力になっています。

00:26:22.000 -> 00:26:31.000
サポートされているファイルとコンテンツは、ホーム画面のアイコンにドロップし、それぞれのアプリで直接開くことができます。

00:26:31.000 -> 00:26:37.000
これは今日、多くのドキュメントベースのアプリで変更なしで自動的に機能します。

00:26:37.000 -> 00:26:46.000
システムは、アプリのInfo.plistファイルで定義されているCFBundleDocumentTypesを使用して、ドロップされたファイルがサポートされているかどうかを判断します。

00:26:46.000 -> 00:26:54.000
ドロップすると、他のURLと同様に、既存のシーンデリゲートメソッドを使用してファイルが開かれます。

00:26:54.000 -> 00:27:00.000
この機能を選択するには、アプリがサポートされているドキュメントタイプを定義していることを確認してください。

00:27:00.000 -> 00:27:13.000
UIKitはISO HDR画像のサポートを追加し、これらの画像をUIImageViewで簡単に表示したり、UIGraphicsImageRendererで操作したりできます。

00:27:13.000 -> 00:27:27.000
さらに、新しいUIImageReaderを使用すると、カメラロールからISO HDRなど、一部のHDR画像形式を変換するなど、画像の読み込み時により多くの制御が提供されます。

00:27:27.000 -> 00:27:36.000
詳細については、「アプリでHDR画像をサポートする」セッションをご覧ください。

00:27:36.000 -> 00:27:42.000
UIPageControlは、分数ページの進行状況を表す新機能を獲得しました。

00:27:42.000 -> 00:27:52.000
今日、ページコントロールは、設定された期間、またはビデオコンテンツに沿って自動的にページングするスライドショーコンテンツを表示するためにアプリで一般的に使用されています。

00:27:52.000 -> 00:28:04.000
新しい進行状況とタイマー進行状況APIを使用すると、アクティブなインジケーターで分数ページの進行状況を表すことができ、ページがいつ変更されるかについてのより良いコンテキストを提供できます。

00:28:04.000 -> 00:28:13.000
分数の進捗ページコントロールを設定するには、UIPageControlの新しい進捗プロパティを進捗オブジェクトで設定するだけです。

00:28:13.000 -> 00:28:21.000
UIPageControlTimerProgressには、各ページの期間を簡単に設定するためのタイマーが組み込まれています。

00:28:21.000 -> 00:28:28.000
UIPageControlは、タイマーの期間が満たされると、自動的にページを変更します。

00:28:28.000 -> 00:28:42.000
独自の真実のソースを持つビデオプレーヤーや外部タイマーに従う必要があるページについては、基本UIPageControlProgressタイプを使用して、コンテンツが進むにつれてcurrentProgress値を手動で更新します。

00:28:42.000 -> 00:28:49.000
iOS 17とmacOS Sonomaはパレットメニューを導入します。

00:28:49.000 -> 00:28:55.000
パレットは、アイテムのコレクションから選択するために一般的に使用されるメニュー要素の列です。

00:28:55.000 -> 00:29:03.000
このスタイルのコントロールは、iOSのBooksアプリ、またはMacのMailとFinderで見つけることができます。

00:29:03.000 -> 00:29:07.000
今では、UIKitでファーストクラスのコントロールとして利用可能になりました。

00:29:07.000 -> 00:29:15.000
メニューをパレットに変えるには、.displayAsPaletteをこのようにオプションに追加するだけです。

00:29:15.000 -> 00:29:23.000
パレットの要素は比較的小さいため、通常のメニュー要素と同様に、選択はチェックマークで示されません。

00:29:23.000 -> 00:29:29.000
代わりに、UIKitは提供された画像に基づいて適切な選択インジケーターを選択します。

00:29:29.000 -> 00:29:38.000
パレット内のすべての要素が単色のSFシンボルまたはテンプレート画像を使用している場合、選択した要素はアプリの色合いで着色されます。

00:29:38.000 -> 00:29:46.000
要素にマルチカラーのSF記号がある場合、選択したものの周りに色合いのストロークが描画されます。

00:29:46.000 -> 00:30:01.000
メニュー要素に完全にカスタム画像を使用している場合、または独自の選択インジケーターを提供して組み込みの動作をオーバーライドしたい場合は、UIMenuLeafプロトコルで新しいselectedImageプロパティを使用できます。

00:30:01.000 -> 00:30:08.000
この例では、選択したImageがUIActionの初期化子に設定されています。

00:30:08.000 -> 00:30:19.000
UIKitのメニューAPIは、iOS、iPadOS、Mac Catalystで利用でき、同じ使い慣れたAPIで複雑なメニューを構築できます。

00:30:19.000 -> 00:30:30.000
そして、tvOS 17以降、同じAPIはすべて、まったく新しい外観とネイティブtvOSの動作でApple TVで利用できます。

00:30:30.000 -> 00:30:33.000
うわー！私たちは多くの分野をカバーしました。

00:30:33.000 -> 00:30:41.000
UIKitは確かに一連の機能を獲得し、その機能をさらに強化しています。

00:30:41.000 -> 00:30:43.000
次は何ですか?

00:30:43.000 -> 00:30:47.000
iOS 17 SDKを使用してアプリをコンパイルします。

00:30:47.000 -> 00:30:54.000
新しいUIKit機能を組み込み、Xcodeプレビューをプロジェクトで活用してください。

00:30:54.000 -> 00:31:01.000
また、UIが柔軟で、非ラテン語のさまざまなテキストメトリックに対応していることを確認してください。

00:31:01.000 -> 00:31:05.000
これらのトピックの簡単な概要を楽しんでいただければ幸いです。

00:31:05.000 -> 00:31:09.000
より詳細な外観については、関連するビデオをチェックしてください。

00:31:09.000 -> 00:31:11.000
ありがとうございます。

00:31:11.000 -> 23:59:59.000
♪ ♪

