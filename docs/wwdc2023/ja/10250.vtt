WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:15.000
Dariusz: こんにちは、私はDariuszで、Xcode Playgroundsチームのエンジニアです。

00:00:15.000 --> 00:00:23.000
Xcode Playgroundsの改善により、プロジェクトの新機能のプロトタイプを簡単にする方法をお見せしたいと思います。

00:00:23.000 --> 00:00:28.000
Xcode Playgroundsがワークフローを改善できるシナリオはたくさんあります。

00:00:28.000 --> 00:00:40.000
まず第一に、新機能のプロトタイプを作成したり、コードの小さな変更を試したりしたいときはいつでも、プロジェクトの再構築と再起動をスキップすることができます。

00:00:40.000 --> 00:00:51.000
また、ショッピングアプリで注文サマリーを生成するロジックのように、そうでなければ到達するのが非常に難しいコードの実行がはるかに簡単になります。

00:00:51.000 --> 00:01:01.000
もちろん、そのようなコードはテストで検証することができ、検証する必要がありますが、プレイグラウンドはそれらを開発するための素晴らしい出発点にもなります。

00:01:01.000 --> 00:01:10.000
また、プロジェクトに新しい依存関係を導入する前にコードを試すのに最適な環境です。

00:01:10.000 --> 00:01:14.000
Xcode Playgroundsが私のプロジェクトでどのように役立っているかをお見せしたいと思います。

00:01:14.000 --> 00:01:20.000
私は野生動物の写真撮影に役立つ小さなアプリに取り組んできました。

00:01:20.000 --> 00:01:26.000
現時点では、私のアプリは、私がすでに発見して撮影した種を追跡するのに役立ちます。

00:01:26.000 --> 00:01:37.000
さて、このアプリは、野生動物写真の非常に重要な側面の1つで私を助けたいと思っています。それは、実際に最初に動物を見つけることです。

00:01:37.000 --> 00:01:42.000
チェックリストビューの新しいタブを紹介したいと思います。

00:01:42.000 --> 00:01:48.000
私はすでにビューを実装し始めており、このユーザーインターフェイスに非常に満足しています。

00:01:48.000 --> 00:01:53.000
各鳥にはチェックボックスがあり、進捗状況を追跡できます。

00:01:53.000 --> 00:01:59.000
しかし、リストに2,000羽以上の鳥が載っているので、私はおそらくあまり進歩しているようには感じないでしょう。

00:01:59.000 --> 00:02:04.000
このリストを少し絞り込むのは素晴らしいことです。

00:02:04.000 --> 00:02:11.000
これを行うには、カスタムChecklistViewでbirdsToShowの計算プロパティを調整する必要があります。

00:02:11.000 --> 00:02:21.000
現時点では、北米用に設定された私のBirdProviderタイプを作成し、大陸全体で見つかったすべての鳥種を返します。

00:02:21.000 --> 00:02:34.000
プロジェクトを頻繁に再構築して再起動し、ChecklistViewに移動して変更を確認することを避けるために、Xcode Playgroundでこのコードを調整してみます。

00:02:34.000 --> 00:02:40.000
私のプロジェクトに新しい遊び場を追加することから始めます。

00:02:40.000 --> 00:02:44.000
これはiOSアプリなので、iOSのテンプレートに固執します。

00:02:44.000 --> 00:02:55.000
フィルターバーに「遊び場」と入力し、空白の遊び場を選択します。

00:02:55.000 --> 00:03:07.000
この場合、いくつかのことを試してみたら、おそらく遊び場を取り除くので、デフォルトの「MyPlayground」の名前を保つことができます。

00:03:07.000 --> 00:03:15.000
遊び場のデフォルトの内容を取り除きます。

00:03:15.000 --> 00:03:30.000
さらに高速に反復するには、下部バーの実行ボタンを長押しすると表示されるメニューで「自動実行」に切り替えます。

00:03:30.000 --> 00:03:36.000
これにより、変更を停止するたびに、プレイグラウンドは自動的にコード全体を実行します。

00:03:36.000 --> 00:03:45.000
プロジェクトに追加されたプレイグラウンドには、デフォルトで2つの設定が有効になっていることに注意してください。ビルドアクティブスキームとインポートアプリタイプです。

00:03:45.000 --> 00:03:54.000
彼らは、各プレイグラウンドの実行前にアクティブなスキームが構築され、アプリのターゲットモジュールが自動的にインポートされることを保証します。

00:03:54.000 --> 00:03:59.000
これにより、プロジェクト内で定義されたタイプをはるかに簡単に操作できます。

00:03:59.000 --> 00:04:05.000
私は遊び場のためのもう少しスペースを与えるために検査官を閉じることができます。

00:04:05.000 --> 00:04:19.000
私のChecklistViewのbirdsToShowプロパティで見たように、BirdProviderインスタンスを宣言することから始めましょう。

00:04:19.000 --> 00:04:27.000
エディタの右側にある結果サイドバーは、この宣言がプレイグラウンドの結果を生成したことを示しています。

00:04:27.000 --> 00:04:33.000
インライン結果のトグルを使用して、詳細を確認できます。

00:04:33.000 --> 00:04:43.000
インラインの結果は、このBirdProviderインスタンスの詳細と、鳥の配列と提供された領域の2つのプロパティを示しています。

00:04:43.000 --> 00:04:58.000
Xcode 15では、各行にはタイプ情報の短い要約を示すタイプ情報ラベルもあり、各行のツールチップを使用して詳細を表示できます。

00:04:58.000 --> 00:05:10.000
たとえば、ツールチップは、BirdProviderタイプが私のアプリモジュールから来ており、領域列挙型がその構造体内で定義されていることを示しています。

00:05:10.000 --> 00:05:17.000
配列行を展開して、鳥の詳細を見てみましょう。

00:05:17.000 --> 00:05:26.000
インライン結果ビューと対話し始めると、Xcode 15は結果を生み出したソースコードを強調表示することに注意してください。

00:05:26.000 --> 00:05:31.000
この場合、ビューはbirdProvider定数に割り当てられた値を表示します。

00:05:31.000 --> 00:05:37.000
これにより、表示された値を理解しやすくなります。

00:05:37.000 --> 00:05:45.000
配列要素を詳しく見てみましょう。

00:05:45.000 --> 00:05:54.000
地域と鳥の配列プロパティの素敵な要約を見ましたが、デフォルトでは、各鳥を表す行は配列インデックスについてのみ教えてくれます。

00:05:54.000 --> 00:06:00.000
なぜなら、カスタムバードタイプには説明が定義されていないからです。

00:06:00.000 --> 00:06:06.000
BirdタイプをCustomStringConvertibleプロトコルに準拠させることで、これを改善できます。

00:06:06.000 --> 00:06:12.000
遊び場またはそのソースディレクトリに拡張機能を追加できます。

00:06:12.000 --> 00:06:23.000
これらのオプションは両方とも、遊び場の範囲内の鳥のタイプにのみ影響し、デバッガのようなそれらに依存する他の場所では素敵な新しい説明を得ることはありません。

00:06:23.000 --> 00:06:34.000
そのため、Birdタイプを定義するファイルに拡張子を追加します。

00:06:34.000 --> 00:06:40.000
新しい説明の定義では、各行は鳥の共通名と学名を示す必要があります。

00:06:40.000 --> 00:06:47.000
遊び場に戻って、新しい説明の動作を見てみましょう。

00:06:47.000 --> 00:06:53.000
プレイグラウンド実行の自動モードでは、プレイグラウンドは再度開くと自動的に再実行されます。

00:06:53.000 --> 00:07:02.000
鳥の配列行をもう一度展開して、説明を確認しましょう。

00:07:02.000 --> 00:07:04.000
これははるかに良いです。

00:07:04.000 --> 00:07:14.000
これで、行が展開せずに何を表すかは明らかですが、バードタイプの他のプロパティを見てみましょう。

00:07:14.000 --> 00:07:26.000
私はすでにこれらの鳥のいくつかを見つけて撮影しました、そして、あなたはそれらのいくつかがすでにこの大西洋ツノメドリのような写真のプロパティを持っていることがわかります。

00:07:26.000 --> 00:07:41.000
その行をクリックすると、写真は新しい分割ビューベースのユーザーインターフェイスに表示され、プレビューとともにオブジェクトの構造を見ることができます。

00:07:41.000 --> 00:07:47.000
デフォルトでは、行をクリックすると、カスタムBirdタイプのプレビューはありません。

00:07:47.000 --> 00:07:53.000
私はすべての種の名前にそれほど精通していないので、すでにここで写真を見るのは素晴らしいことです。

00:07:53.000 --> 00:07:59.000
それを達成するために、私はCustomPlaygroundDisplayConvertibleプロトコルを使用することができます。

00:07:59.000 --> 00:08:18.000
プロトコルの名前が示すように、この適合性はプレイグラウンドの表現にのみ影響するので、今回はプレイグラウンドのソースディレクトリに拡張機能を追加します。

00:08:18.000 --> 00:08:29.000
アプリモジュールをインポートしてBirdタイプにアクセスし、photoプロパティをplaygroundDescriptionとして返す簡単な拡張機能を追加します。

00:08:29.000 --> 00:08:34.000
リターンステートメントでAnyに明示的に写真をキャストしていることに注意してください。

00:08:34.000 --> 00:08:41.000
それがなければ、コンパイラは、値がオプションであることに関する重要な情報を失っていると警告します。

00:08:41.000 --> 00:08:53.000
Xcode Playgroundsは、playgroundDescriptionプロパティでnilを返さないオブジェクトのカスタム説明のみを作成することで、オプションを処理するため、この場合は問題ありません。

00:08:53.000 --> 00:09:00.000
もう一度遊び場に戻って、新しい説明を確認しましょう。

00:09:00.000 --> 00:09:18.000
Xcode 15では、CustomPlaygroundDisplayConvertibleに準拠したタイプによって返されたplaygroundDescriptionが、オブジェクトの構造に沿って分割ビューに表示されます。

00:09:18.000 --> 00:09:24.000
今、すでに写真を持っている鳥は、列を広げることなく、すぐにそれを表示します。

00:09:24.000 --> 00:09:31.000
これにより、このカスタムタイプの大規模なコレクションでの作業がはるかに簡単になります。

00:09:31.000 --> 00:09:35.000
しかし、今日は、まだ写真を持っていない鳥に焦点を当てたいと思います。

00:09:35.000 --> 00:09:48.000
このインライン結果を閉じて、すでに写真を持っているすべての鳥をフィルタリングしましょう。

00:09:48.000 --> 00:09:52.000
これら2つのサイドバーの注釈が少し違って見えることがわかります。

00:09:52.000 --> 00:09:55.000
それは、新しい行に複数の式があるからです。

00:09:55.000 --> 00:10:04.000
新しいコントロールをクリックすると、各式のおなじみの要約を見ることができます。

00:10:04.000 --> 00:10:10.000
インライン結果のトグルにカーソルを合わせると、ソースコードの範囲が強調表示されます。

00:10:10.000 --> 00:10:25.000
これにより、配列はbirdsToFind定数に割り当てられた結果であり、trueはフィルタ関数に渡されたクロージャによって生成される最新の値であることを明確にします。

00:10:25.000 --> 00:10:33.000
結果のサイドバーによると、私がまだ撮影していないすべての鳥の数はまだ1,800を超えており、これは非常に威圧的です。

00:10:33.000 --> 00:10:41.000
これは最終的に目標かもしれませんが、フクロウなどの鳥の小さなグループに焦点を当てることで、それを低くしたいと思います。

00:10:41.000 --> 00:10:46.000
6月はオウリングに行くのに最適な月ですが、それは別のセッションのトピックです。

00:10:46.000 --> 00:10:57.000
他の家族から鳥をフィルタリングしましょう。

00:10:57.000 --> 00:11:02.000
配列には5つの要素しかありません。これははるかに心強いです。

00:11:02.000 --> 00:11:07.000
この小さな鳥のグループでカスタムチェックリストビューを試してみたいと思います。

00:11:07.000 --> 00:11:22.000
これを行うには、ChecklistViewインスタンスを作成し、各鳥を1つずつ追加します。

00:11:22.000 --> 00:11:27.000
ChecklistViewのインライン結果を開きましょう。

00:11:27.000 --> 00:11:33.000
UIViewサブクラスとして、スナップショットとともにいくつかのプロパティも表示されるようになりました。

00:11:33.000 --> 00:11:45.000
値履歴モードに切り替えることができ、新しいスプリットビューベースのユーザーインターフェイスも使用できるようになりました。

00:11:45.000 --> 00:11:58.000
これにより、各ループ反復でChecklistViewがどのように見えるかを確認できます。

00:11:58.000 --> 00:12:06.000
それは実際に私の見解に問題を見つけるのに役立ちました。これは、たった1羽の鳥のヘッダーに「鳥」と間違って書かれています。

00:12:06.000 --> 00:12:16.000
新しい文字列カタログで定義された文字列を調整することで、これを修正できるはずです。

00:12:16.000 --> 00:12:20.000
最初の行は、私のチェックリストビューのヘッダーで使用されているもののようです。

00:12:20.000 --> 00:12:28.000
コンテキストメニューを表示し、Vary By Pluralを選択します。

00:12:28.000 --> 00:12:33.000
そうすると、影響を受ける行の状態が「レビューが必要」に変更されます。

00:12:33.000 --> 00:12:41.000
この文字列の単数形を調整します。

00:12:41.000 --> 00:12:48.000
新しい文字列カタログの詳細については、「文字列カタログの発見」セッションを確認してください。

00:12:48.000 --> 00:13:02.000
遊び場に戻って、この変更でチェックリストがどのように見えるかを見てみましょう。

00:13:02.000 --> 00:13:13.000
ヘッダーは各ループ反復で正しく見えます。

00:13:13.000 --> 00:13:19.000
私は今、このインライン結果を閉じることができます。

00:13:19.000 --> 00:13:21.000
私のChecklistViewは使えると思います。

00:13:21.000 --> 00:13:30.000
鳥のリストを絞り込むために使用したコードをすぐに私のプロジェクトに持ってきます。

00:13:30.000 --> 00:13:39.000
この3行をChecklistViewのbirdsToShowプロパティにコピーします。

00:13:39.000 --> 00:13:57.000
また、新しい、はるかに小さな鳥の配列でリターンステートメントを追加します。

00:13:57.000 --> 00:14:02.000
プロジェクトを再実行する前に、もう1つの機能のプロトタイプを作成したいと思います。

00:14:02.000 --> 00:14:06.000
カスタムチェックリストビューの各行に開示インジケーターがあることがわかります。

00:14:06.000 --> 00:14:12.000
リスト内の行を選択すると、簡単なマップビューが開きます。

00:14:12.000 --> 00:14:20.000
まだそれほど役に立ちませんが、選択した鳥の最新の目撃に関するデータを取得し、地図に表示したいと思います。

00:14:20.000 --> 00:14:27.000
そのためには、ChecklistViewで目撃情報ToShow(鳥の場合:)機能を調整する必要があります。

00:14:27.000 --> 00:14:32.000
それを助けるために、私はすでに私のプロジェクトに1つの依存関係を追加しました。

00:14:32.000 --> 00:14:41.000
BirdSightingsパッケージを使用すると、人々が目撃情報を報告する市民科学ウェブサイトの1つからデータを簡単に取得できます。

00:14:41.000 --> 00:14:46.000
私は以前にそのパッケージを使ったことがないので、まだそのAPIに精通していません。

00:14:46.000 --> 00:14:57.000
幸いなことに、このパッケージには、いくつかの例を示す遊び場の形でドキュメントが含まれています。

00:14:57.000 --> 00:15:04.000
これは、パッケージのクライアントが提供されたAPIを試すのに最適な方法です。

00:15:04.000 --> 00:15:13.000
fetchSightings関数に2つの引数を提供する必要があるようです。探す鳥のコードと見回す場所です。

00:15:13.000 --> 00:15:22.000
予想される結果についてもっと知るために、この遊び場を実行することができます。

00:15:22.000 --> 00:15:37.000
遊び場に戻って使ってみよう。そして使ってみよう。

00:15:37.000 --> 00:15:44.000
ナビゲーターを閉じて、エディタエリアにもっとスペースを与えることができます。

00:15:44.000 --> 00:15:49.000
関数を呼び出す前に、2つのインポートステートメントを追加する必要があります。

00:15:49.000 --> 00:16:01.000
座標で作業できるようにCoreLocationフレームワークをインポートし、APIを使用するためにBirdSightingフレームワークをインポートします。

00:16:01.000 --> 00:16:14.000
関数引数については、リストから最初の鳥から始めることができます。

00:16:14.000 --> 00:16:18.000
短耳のフクロウを探しているようです。

00:16:18.000 --> 00:16:21.000
ここで強制包装解除を使用したことに注目してください。

00:16:21.000 --> 00:16:31.000
Playgrounds環境でのエラー処理についてそれほど心配する必要はありませんが、コードをプロジェクトに持ち込むときは、それを念頭に置いておくことが重要です。

00:16:31.000 --> 00:16:44.000
場所に関しては、私はおそらくほとんどの場合、現在の場所を使用しますが、特定の座標を提供する能力は、コードのテストとすべてのロードトリップの計画という2つのことに最適です。

00:16:44.000 --> 00:16:53.000
アップルパーク周辺で何が見つかるか見てみよう。

00:16:53.000 --> 00:17:02.000
ネットワークコールを導入する前に、プレイグラウンド実行の手動モードに切り替えて、不要な呼び出しを回避できるようにします。

00:17:02.000 --> 00:17:08.000
このようなリクエストにはしばらく時間がかかることがあり、できるだけ早く新機能を反復したいです。

00:17:08.000 --> 00:17:20.000
これを行うには、もう一度下のバーのメニューを表示し、手動で実行を選択します。

00:17:20.000 --> 00:17:25.000
今、私は実行すべきコードの部分を完全に制御できます。

00:17:25.000 --> 00:17:33.000
フェッチコードを追加しましょう。

00:17:33.000 --> 00:17:42.000
ソースエディタの溝のコントロールは、これらの2行を実行すると、上記ですでに実行したすべての行が再実行されないことを示しています。

00:17:42.000 --> 00:17:49.000
新しい行を実行して、データが得られるかどうか見てみましょう。

00:17:49.000 --> 00:17:52.000
幸いなことに、いくつかの目撃情報があります。

00:17:52.000 --> 00:18:02.000
最新のはずの最初のものを見てみましょう。これは最新のはずです。

00:18:02.000 --> 00:18:07.000
短耳のフクロウは最近、昌門崖保護区で見られたようです。

00:18:07.000 --> 00:18:17.000
私はまだこの地域のすべてのバードウォッチングホットスポットに精通していないので、私のSightingMapViewで目撃に関するデータを見るのは素晴らしいことです。

00:18:17.000 --> 00:18:25.000
フェッチされた照準データで初期化しましょう。

00:18:25.000 --> 00:18:35.000
マップビューのような複雑なユーザーインターフェイス要素では、プレイグラウンドのライブビューを使用して、大きくて完全にインタラクティブなプレビューを見ることができます。

00:18:35.000 --> 00:18:44.000
それを使用するには、まずPlaygroundSupportフレームワークをインポートする必要があります。

00:18:44.000 --> 00:18:56.000
これで、ライブビューを設定し、プレイグラウンドを実行する準備が整いました。

00:18:56.000 --> 00:19:08.000
ファイルの上部にimportステートメントを追加して、プレイグラウンドのすでに実行された部分を変更したので、ソースエディタのガターのコントロールは、ファイル全体を再実行する必要があることを教えてくれます。

00:19:08.000 --> 00:19:23.000
前回の実行で結果を失いますが、この場合は問題ないはずですので、先に進んで遊び場を実行します。

00:19:23.000 --> 00:19:27.000
アップルパークに近すぎる島は覚えていません。

00:19:27.000 --> 00:19:44.000
ライブビューは完全にインタラクティブなので、iPhoneシミュレータのように少しズームアウトして、私たちがどこにいるかを見ることができます。

00:19:44.000 --> 00:19:47.000
私たちは東が遠すぎるようです。

00:19:47.000 --> 00:19:58.000
エディタオプションのライブビューを閉じて、問題が導入された場所を見てみましょう。

00:19:58.000 --> 00:20:05.000
私のSightingMapViewはmostRecentSighting定数で初期化されたので、その値を確認しましょう。

00:20:05.000 --> 00:20:16.000
インライン結果を開く代わりに、サイドバーの目のアイコンをクリックして値を簡単に見ることができます。

00:20:16.000 --> 00:20:23.000
Xcode 15では、MapKitとCoreLocationタイプの一部のプレイグラウンドの結果を改善しました。

00:20:23.000 --> 00:20:34.000
プレイグラウンドはCLLocationCoordinate2Dのプレビューを表示できるようになりましたので、ロケーションプロパティを見てみましょう。

00:20:34.000 --> 00:20:40.000
これは同じ場所を指しているように見えるので、これは私のSightingMapViewによって引き起こされたのではないようです。

00:20:40.000 --> 00:20:50.000
BirdSightingsパッケージから間違った場所を得たので、パッケージの問題によって引き起こされるか、最初に間違った場所を通過した可能性があります。

00:20:50.000 --> 00:20:57.000
後者を検証しましょう。

00:20:57.000 --> 00:21:07.000
これはアップルパークにも近くないようです。

00:21:07.000 --> 00:21:13.000
私たちは東が遠すぎるので、これは西と東を混ぜるだけの問題かもしれないと思います。

00:21:13.000 --> 00:21:26.000
経度の前にマイナス記号を追加し、遊び場を再実行して、これを修正してみましょう。

00:21:26.000 --> 00:21:37.000
今、これは間違いなくアップルパークです。

00:21:37.000 --> 00:21:52.000
更新された場所で遊び場の残りの部分を実行し、エディタオプションでライブビューを再度開きましょう。

00:21:52.000 --> 00:21:58.000
それはもっとそれのようなものです。

00:21:58.000 --> 00:22:03.000
今、私はコヨーテヒルズが新種を撮影するのに最適な場所かもしれないことを知っています。

00:22:03.000 --> 00:22:12.000
すばやく取得コードを私のChecklistViewに持ち込みましょう。

00:22:12.000 --> 00:22:21.000
この3行を目撃情報表示機能にコピーします。

00:22:21.000 --> 00:22:41.000
ここでハードコードされたApple Parkの場所を常に使用するのではなく、CLLocationManagerから取得したlastCurrentLocationに置き換えます。

00:22:41.000 --> 00:22:49.000
また、新しいmostRecentSightingで返品明細書を追加します。

00:22:49.000 --> 00:23:00.000
ついに私たちの変更でプロジェクトを実行する時が来ました。

00:23:00.000 --> 00:23:10.000
チェックリストは、私たちが鳥の小さなグループに焦点を当てた今、はるかに現実的に見えます。

00:23:10.000 --> 00:23:16.000
今、行をクリックするとどうなるか見てみましょう。 

00:23:16.000 --> 00:23:17.000
それはすごい。

00:23:17.000 --> 00:23:22.000
私のアプリは、選択した鳥の最新の目撃情報を表示できるようになりました。

00:23:22.000 --> 00:23:25.000
もちろん、まだ改善の余地はたくさんあります。

00:23:25.000 --> 00:23:34.000
たとえば、目撃情報がバックグラウンドで取得されている間に進行状況インジケーターを表示する必要がありますが、これは素晴らしい出発点です。

00:23:34.000 --> 00:23:41.000
このアプリはすでに私に大いに役立ち、Xcode Playgroundsはこれらの改善作業をはるかに簡単にしました。

00:23:41.000 --> 00:23:47.000
このセッションでは、Xcode Playgroundsを使用して、プロジェクトの新機能をすばやくプロトタイプ化しました。

00:23:47.000 --> 00:23:57.000
CustomStringConvertibleとCustomPlaygroundDisplayConvertibleプロトコルを使用して、カスタムタイプの表現をカスタマイズしました。

00:23:57.000 --> 00:24:02.000
プレイグラウンドの実行モードを調整することで、ワークフローを高速化する方法を見ました。

00:24:02.000 --> 00:24:10.000
値履歴モードを使用すると、クラスが複数の入力にどのように反応するかをすばやく確認できます。

00:24:10.000 --> 00:24:17.000
最後に、プレイグラウンドのライブビューを使用して、複雑なユーザーインターフェイス要素を詳しく調べました。

00:24:17.000 --> 23:59:59.000
ご覧いただきありがとうございます。

