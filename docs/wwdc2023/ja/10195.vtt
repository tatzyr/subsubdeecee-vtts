WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:17.000
Rishi: こんにちは、私の名前はRishi Vermaです。このセッションでは、SwiftDataのスキーマを構築するためにモデルをコーディングする方法について説明します。

00:00:17.000 --> 00:00:28.000
まず、スキーママクロを最大限に活用する方法と、アプリの変更に合わせてスキーマ移行でスキーマを進化させる方法について説明します。

00:00:28.000 --> 00:00:39.000
始める前に、このコンテンツはこれらのビデオで紹介された概念に基づいて発展するので、「SwiftDataに会う」と「SwiftDataでアプリを構築する」を見てください。

00:00:39.000 --> 00:00:45.000
SwiftDataは、データモデリングと管理のための強力なフレームワークであり、最新のSwiftアプリを強化します。

00:00:45.000 --> 00:00:57.000
SwiftUIと同様に、外部ファイル形式なしでコードに完全に焦点を当て、Swiftの新しいマクロシステムを使用してシームレスなAPIエクスペリエンスを作成します。

00:00:57.000 --> 00:01:02.000
私は、ユーザーが今後の旅行を計画できるSampleTripsアプリに取り組んでいます。

00:01:02.000 --> 00:01:08.000
各旅行は、名前、目的地、開始日と終了日で作成されます。

00:01:08.000 --> 00:01:15.000
旅行には、バケットリストのアイテムや旅行者が滞在する場所の関係を含めることもできます。

00:01:15.000 --> 00:01:21.000
SwiftDataの追加は、インポートを追加して@ModelでTripを飾るのと同じくらい簡単です。

00:01:21.000 --> 00:01:24.000
それでおそれ。

00:01:24.000 --> 00:01:30.000
@Modelマクロは、私のTripクラスをPersistentModelに適合させ、説明的なスキーマを生成します。

00:01:30.000 --> 00:01:35.000
私のモデルを定義するコードは、今や私のアプリケーションのスキーマの真実の源です。

00:01:35.000 --> 00:01:41.000
私の旅行モデルのデフォルトの動作は良いですが、少し微調整できると思います。

00:01:41.000 --> 00:01:49.000
SwiftDataのスキーママクロを使用すると、永続性エクスペリエンスの動作をカスタマイズして、アプリに合わせて完璧に機能させることができます。

00:01:49.000 --> 00:01:55.000
元のスキーマでアプリを公開したとき、各旅行名が一意であることを確認しませんでした。

00:01:55.000 --> 00:02:00.000
これは、私が今解決する必要がある同じ名前の旅行の間にいくつかの競合を引き起こしました。

00:02:00.000 --> 00:02:06.000
これは、@Attributeスキーママクロと一意のオプションを使用して修正できます。

00:02:06.000 --> 00:02:16.000
SwiftDataは、永続的なバックエンドに保存した旅行が一意の名前を持つことを保証する旅行のモデルのスキーマを生成します。

00:02:16.000 --> 00:02:23.000
その名前のトリップがすでに存在する場合、永続的なバックエンドは最新の値に更新されます。

00:02:23.000 --> 00:02:25.000
これはアップサートと呼ばれます。

00:02:25.000 --> 00:02:28.000
アップサートはインサートとして始まります。

00:02:28.000 --> 00:02:34.000
インサートが既存のデータと衝突すると、更新になり、既存のデータのプロパティが更新されます。

00:02:34.000 --> 00:02:47.000
数値、文字列、UUIDなどのプリミティブな値タイプである限り、他のプロパティにも一意の制約を適用したり、1つの関係を飾ることもできます。

00:02:47.000 --> 00:02:49.000
私のスキーマにはもう少し作業が必要です。

00:02:49.000 --> 00:02:56.000
最初に指定したstart_dateとend_dateからこれらの厄介なアンダースコアを削除したい。

00:02:56.000 --> 00:03:02.000
変数の名前を変更すると、これは生成されたスキーマの新しいプロパティと見なされます。

00:03:02.000 --> 00:03:05.000
SwiftDataにこれらの新しいプロパティを作成してほしくない。

00:03:05.000 --> 00:03:10.000
代わりに、既存のデータをそのまま保存したい。

00:03:10.000 --> 00:03:18.000
@Attributeを使用して元の名前をプロパティ名にマッピングし、originalName:パラメータを指定するだけで、これを行うことができます。

00:03:18.000 --> 00:03:22.000
これらを元の名前からマッピングすることで、データの損失を回避できます。

00:03:22.000 --> 00:03:30.000
これはまた、私のスキーマの更新がSampleTripsアプリの次のリリースのための簡単な移行になることを保証します。

00:03:30.000 --> 00:03:40.000
また、@Attributeマクロは、大規模なデータを外部に保存し、変換可能なサポートを提供するなど、さらに多くのことを行うことができます。

00:03:40.000 --> 00:03:45.000
私の旅行はうまくいっていますが、今は人間関係に取り組みたいです。

00:03:45.000 --> 00:03:55.000
私の旅行に新しいバケットリストアイテムや住居を追加すると、SwiftDataは暗黙のうちに私のモデル間の逆を発見し、私のためにそれらを設定します。

00:03:55.000 --> 00:03:59.000
暗黙の逆は注釈を必要としません。

00:03:59.000 --> 00:04:01.000
彼らはただ働くだけです。

00:04:01.000 --> 00:04:10.000
暗黙の逆は、旅行が削除されたときにバケットリストアイテムと居住宿泊施設のプロパティを無効にするデフォルトの削除ルールを使用します。

00:04:10.000 --> 00:04:17.000
しかし、バケットリストのアイテムと住居を旅行と一緒に削除したいです。

00:04:17.000 --> 00:04:22.000
カスケード削除ルールで@Relationshipマクロを追加することで、簡単にそれを行うことができます。

00:04:22.000 --> 00:04:28.000
今、私が旅行を削除すると、それらの関係も削除されます。

00:04:28.000 --> 00:04:39.000
そして、@Relationshipマクロは、originalName修飾子や、to-many関係の最小カウントと最大カウントを指定する機能など、はるかに多くのことを行います。

00:04:39.000 --> 00:04:43.000
SampleTripsアプリはうまく形成されていますが、まだアップデートがあります。

00:04:43.000 --> 00:04:48.000
さて、旅行を何回見たかを追跡する方法を追加したいと思います。

00:04:48.000 --> 00:04:52.000
このようにして、私は休暇を取ることにどれだけ興奮しているかを測ることができます。

00:04:52.000 --> 00:04:53.000
待ちきれない！

00:04:53.000 --> 00:05:02.000
ただし、このビューカウントがSwiftDataによって保持されることを望んでおらず、@Transientマクロで簡単に行うことができます。

00:05:02.000 --> 00:05:08.000
私は単に@Transientで私のプロパティを飾るだけで、この特定のプロパティは持続しません。

00:05:08.000 --> 00:05:10.000
それはとても簡単です。

00:05:10.000 --> 00:05:14.000
@Transientマクロは、不要なデータの永続化を避けるのに役立ちます。

00:05:14.000 --> 00:05:18.000
一時的なプロパティのデフォルト値を必ず指定してください。

00:05:18.000 --> 00:05:23.000
これにより、SwiftDataからフェッチされたときに論理値を持つことが保証されます。

00:05:23.000 --> 00:05:29.000
これらのスキーママクロの活用の詳細については、SwiftDataのドキュメントをご覧ください。

00:05:29.000 --> 00:05:35.000
SampleTripsアプリのスキーマは、永続性の経験を調整しながら、いくつかの進化を遂げました。

00:05:35.000 --> 00:05:39.000
私のアプリがリリースからリリースまでこれらのアップデートを処理できることを確認する必要があります。

00:05:39.000 --> 00:05:46.000
また、プロパティの追加や削除など、スキーマに変更を加えると、データの移行が発生します。

00:05:46.000 --> 00:05:51.000
これらの移行は難しいシナリオになる可能性がありますが、SwiftDataはそれを簡単にします。

00:05:51.000 --> 00:05:55.000
VersionedSchemaとSchemaMigrationPlanは、それを支援するためにここにいます。

00:05:55.000 --> 00:06:05.000
SwiftDataモデルを変更してアプリの新しいバージョンをリリースする準備をするときはいつでも、以前にリリースされたスキーマをカプセル化するVersionedSchemaを定義してください。

00:06:05.000 --> 00:06:15.000
スキーマの各異なるバージョンは、SwiftDataがそれらの間でどのような変更が発生したかを知ることができるように、VersionedSchemaとして定義する必要があります。

00:06:15.000 --> 00:06:21.000
次に、VersionedSchemasの合計順序を使用して、SchemaMigrationPlanを作成します。

00:06:21.000 --> 00:06:26.000
これにより、SwiftDataは必要な移行を順番に実行できます。

00:06:26.000 --> 00:06:33.000
移行計画で注文したスキーマを設定したら、各移行段階の定義を開始できます。

00:06:33.000 --> 00:06:37.000
利用可能な移行段階には2つの異なるタイプがあります。

00:06:37.000 --> 00:06:40.000
1つ目は軽量の移行段階です。

00:06:40.000 --> 00:06:47.000
軽量移行は、次のアプリリリースのために既存のデータを移行するために追加のコードを必要としません。

00:06:47.000 --> 00:06:57.000
日付プロパティにoriginalNameを追加したり、関係に削除ルールを指定したりするなどの変更は、軽量移行の対象となります。

00:06:57.000 --> 00:07:03.000
ただし、旅行の名前をユニークにすることは、軽量な移行の対象にはなりません。

00:07:03.000 --> 00:07:12.000
名前がユニークになる前に、旅行の重複排除が可能なこの変更のためのカスタム移行ステージを作成する必要があります。

00:07:12.000 --> 00:07:18.000
私は最初のリリースから元のスキーマを取り、それをVersionedSchemaにカプセル化することから始めます。

00:07:18.000 --> 00:07:23.000
私はこのバージョンのスキーマSampleTripsSchemaV1と名付けます。

00:07:23.000 --> 00:07:28.000
私のバージョン管理されたスキーマのそれぞれは、それらが定義するモデルクラスをリストします。

00:07:28.000 --> 00:07:33.000
私のスキーマのバージョン2は、旅行名に一意性制約を追加した場所です。

00:07:33.000 --> 00:07:41.000
Tripモデルクラスに加えた変更もカプセル化する別のバージョン制スキーマを作成します。

00:07:41.000 --> 00:07:48.000
スキーマのバージョン3でも同じことをして、開始日と終了日に行われた名前の変更をキャプチャします。

00:07:48.000 --> 00:07:56.000
VersionedSchemasがすべてわかったので、リリースからリリースへの移行を処理する方法を説明するSchemaMigrationPlanを構築します。

00:07:56.000 --> 00:07:58.000
それはかなり単純です。

00:07:58.000 --> 00:08:02.000
アプリケーションのスキーマの総順序を提供するだけです。

00:08:02.000 --> 00:08:07.000
次に、どの移行が軽量またはカスタムであるかに注釈を付ける必要があります。

00:08:07.000 --> 00:08:14.000
V1からV2の場合、データを移行する前に操作を実行できるカスタムステージが必要です。

00:08:14.000 --> 00:08:20.000
willMigrateの閉鎖では、移行が起こる前に旅行の重複を解除することができます。

00:08:20.000 --> 00:08:28.000
SwiftDataは、V1からV2への移行がいつ行われるかを検出し、このクロージャを実行します。

00:08:28.000 --> 00:08:34.000
originalNameの他の移行は軽量なので、その段階も追加できます。

00:08:34.000 --> 00:08:41.000
移行計画に関するすべての詳細を定義したので、移行を実行する時が来ました。

00:08:41.000 --> 00:08:47.000
現在のスキーマと移行計画でModelContainerをセットアップし、完了です。

00:08:47.000 --> 00:08:52.000
私のユーザーは任意のバージョンから最新のリリースにアップグレードすることができ、データが確実に保存されるようにしました。

00:08:52.000 --> 00:08:58.000
SampleTripsアプリを使って今後の休暇を計画するのが待ちきれません。

00:08:58.000 --> 00:09:09.000
スキーママクロを活用してスキーマの追加メタデータを伝え、アプリケーションが進化するにつれて、それらの進化をVersionedSchemaでキャプチャして、アプリが以前のリリースから移行できるようにします。

00:09:09.000 --> 00:09:15.000
これらの他の講演をチェックして、皆さんがSwiftDataで作る素晴らしいものを見るのを楽しみにしています。

00:09:15.000 --> 23:59:59.000
光栄でした。

