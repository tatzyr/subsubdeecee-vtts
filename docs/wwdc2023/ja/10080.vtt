WEBVTT

00:00:00.000 --> 00:00:03.000
♪まろやかなインストゥルメンタルヒップホップ♪

00:00:03.000 --> 00:00:10.000
♪

00:00:10.000 --> 00:00:14.000
こんにちは。私はジョンで、RealityKitチームのエンジニアです。

00:00:14.000 --> 00:00:20.000
今日は、空間体験を作成するための新しいRealityKitを紹介できることを嬉しく思います。

00:00:20.000 --> 00:00:27.000
RealityKitは、3Dモデルとエフェクトを現実的にレンダリング、アニメーション化、シミュレートするためのフレームワークです。

00:00:27.000 --> 00:00:33.000
2019年にRealityKitを導入し、それ以来多くの新機能を追加しました。

00:00:33.000 --> 00:00:40.000
すでにRealityKitを使用して他のデバイスでアプリを構築している場合は、多くの共通点があることがわかります。

00:00:40.000 --> 00:00:54.000
RealityKitを使用すると、アプリの2Dウィンドウを3Dコンテンツで拡張したり、3Dコンテンツを前面と中央に別のウィンドウに配置したり、自分自身と環境を没入感のある体験にしたりできます。

00:00:54.000 --> 00:00:58.000
RealityKitは、Appleプラットフォーム上のコア3Dフレームワークです。

00:00:58.000 --> 00:01:02.000
そして、特にxrOSでは、多くの機能を提供しています。

00:01:02.000 --> 00:01:13.000
このプレゼンテーションでは、エンティティ、コンポーネント、RealityViewなどの重要な機能に焦点を当て、RealityKitを紹介し、その使用方法を紹介します。

00:01:13.000 --> 00:01:18.000
また、他の概念をカバーするセッションや、より詳細なセッションについても言及します。

00:01:18.000 --> 00:01:20.000
始めましょう。

00:01:20.000 --> 00:01:25.000
Hello Worldの経験を使って、このプレゼンテーションの概念を説明します。

00:01:25.000 --> 00:01:32.000
しかし、これらの概念にたどり着く前に、この経験の一部である3つの異なるモジュールを案内しましょう。

00:01:32.000 --> 00:01:40.000
最初のモジュールであるPlanet Earthは、任意の角度から対話できる独自のウィンドウに3D地球儀を提示します。

00:01:40.000 --> 00:01:53.000
2番目のモジュール「軌道の物体」は、地球、月、衛星のモデルに没頭し、衛星に続くトレースのようなアニメーション、空間オーディオ、カスタム動作を実演します。

00:01:53.000 --> 00:02:02.000
3番目のモジュールである太陽系には、完全に没入型の体験が含まれており、他のセッションで詳しく学ぶことができます。

00:02:02.000 --> 00:02:11.000
SwiftUI、RealityKit、Reality Composer Proを使用して、このHello Worldエクスペリエンスの3D要素を構築する方法を紹介します。

00:02:11.000 --> 00:02:12.000
飛び込みましょう。

00:02:12.000 --> 00:02:20.000
RealityKitをSwiftUIと一緒に使用して、アプリを次の次元に引き込む方法について話すことから始めます。

00:02:20.000 --> 00:02:28.000
次に、RealityKitの構成要素、地球モデルのようなエンティティ、およびその動作を実装するコンポーネントを調べます。

00:02:28.000 --> 00:02:35.000
3Dモデルとエフェクト用の新しいSwiftUIビューであるRealityViewの機能について学びます。

00:02:35.000 --> 00:02:42.000
次に、入力を処理し、アニメーションと空間オーディオでアプリに命を吹き込む方法を説明します。

00:02:42.000 --> 00:02:49.000
最後に、カスタムコンポーネントとシステムでRealityKitの可能性を解き放つことについて話します。

00:02:49.000 --> 00:02:54.000
RealityKitとSwiftUIがどのように連携するかを探ることから始めましょう。

00:02:54.000 --> 00:03:01.000
SwiftUIはビューとウィンドウを定義する方法であり、RealityKitでは3D要素を追加できます。

00:03:01.000 --> 00:03:09.000
たとえば、WorldアプリはSwiftUIを使用して、いくつかのボタンで標準の2Dウィンドウを表示します。

00:03:09.000 --> 00:03:16.000
左側の惑星地球ボタンをタップすると、地球の2Dイラストを示す詳細ビューに移動します。

00:03:16.000 --> 00:03:21.000
しかし、その2D画像を3D地球儀に置き換えたい場合はどうなりますか?

00:03:21.000 --> 00:03:27.000
RealityKitのモデル3Dビューを使用して、2Dウィンドウに3Dコンテンツを追加するのは簡単です。

00:03:27.000 --> 00:03:29.000
コードを調べてみましょう。

00:03:29.000 --> 00:03:33.000
これは、その地球画像を表示するSwiftUIビューです。

00:03:33.000 --> 00:03:47.000
RealityKitをインポートし、画像をモデル3Dビューに変更し、Globeと呼ばれるプロジェクトのUSDファイルを参照して、3Dグローブを表示するように変更します。

00:03:47.000 --> 00:04:03.000
2つのコードを追加することで、表示する前にロードされたモデルをカスタマイズできます。返されるモデルのコンテンツクロージャと、モデルのロード中に表示されるビューを指定するプレースホルダビュービルダーです。

00:04:03.000 --> 00:04:13.000
コンテンツクロージャでは、サイズ変更可能でスケーリングされたToFit修飾子を追加して、モデルがUIの利用可能なスペースに収まるようにします。

00:04:13.000 --> 00:04:23.000
また、モデル3Dはモデルを非同期にロードするため、ロードプロセス中に表示されるビューをカスタマイズするために使用できるプレースホルダビュービルダーがあります。

00:04:23.000 --> 00:04:28.000
この場合、組み込みのProgressViewを使用してスピナーを表示しているだけです。

00:04:28.000 --> 00:04:46.000
最後に、アプリまたはSwiftパッケージにリソースとしてグローブ3Dモデルを追加する必要があります。

00:04:46.000 --> 00:04:54.000
そして今、モデルはQuick LookやReality Composer Proと同じ外観でアプリに表示されます。

00:04:54.000 --> 00:05:01.000
3Dコンテンツを2Dウィンドウに配置するのは素晴らしいことですが、3Dモデルを前面と中央にしたいです。

00:05:01.000 --> 00:05:05.000
それを達成するために、私は地球を別の窓に置くつもりです。

00:05:05.000 --> 00:05:09.000
アプリの詳細ビューにボタンを追加して、その新しいウィンドウを開きます。

00:05:09.000 --> 00:05:19.000
そして、2Dの背景に対して内容を表示する通常のウィンドウを使用する代わりに、その内容をボリュームに配置する新しいウィンドウスタイルを使用します。

00:05:19.000 --> 00:05:25.000
これは体積ウィンドウと呼ばれ、3Dコンテンツを表示するのに最適です。

00:05:25.000 --> 00:05:32.000
2Dウィンドウとは異なり、体積ウィンドウはあらゆる角度から使用することを意図しているため、3Dモデルに最適です。

00:05:32.000 --> 00:05:37.000
体積窓はまた、生活に忠実な固定サイズを保ちます。

00:05:37.000 --> 00:05:44.000
体積ウィンドウでモデルを1メートルに拡大縮小することができ、常に正確にそのサイズで表示されます。

00:05:44.000 --> 00:05:48.000
それはハローワールドの地球にぴったりだと思います。

00:05:48.000 --> 00:05:51.000
体積ウィンドウを追加するプロセスを見てみましょう。 ボリュームウィンドウを追加します。

00:05:51.000 --> 00:05:55.000
まず、アプリにウィンドウグループを追加します。

00:05:55.000 --> 00:06:00.000
ウィンドウグループは、アプリが新しいウィンドウを開くために使用できるテンプレートとして機能します。

00:06:00.000 --> 00:06:05.000
新しいウィンドウに、このアプリのメインウィンドウと区別するための識別子を与えます。

00:06:05.000 --> 00:06:10.000
次に、windowStyleの体積修飾子をウィンドウグループに追加します。

00:06:10.000 --> 00:06:16.000
また、defaultSize修飾子を追加して、このウィンドウにメートル単位のサイズを与えます。

00:06:16.000 --> 00:06:19.000
最後に、詳細ビューにボタンを追加します。

00:06:19.000 --> 00:06:35.000
追加したばかりのウィンドウを開くために、SwiftUI環境から開いているウィンドウアクションにアクセスできるプロパティを追加します。

00:06:35.000 --> 00:06:42.000
それから、私のボタンからそのアクションを呼び出します。

00:06:42.000 --> 00:06:45.000
シミュレーターでこのアプリを実行しましょう。

00:06:45.000 --> 00:06:51.000
View Globeボタンを押すと、体積ウィンドウが表示されます。

00:06:51.000 --> 00:06:59.000
今、私は正面だけでなく、複数の角度から地球と対話することができます。

00:06:59.000 --> 00:07:05.000
しかし、時には、あなたが作りたい経験のロックを解除するための鍵は没入です。

00:07:05.000 --> 00:07:14.000
WorldアプリのObjects in Orbitモジュールでは、軌道を示す地球とその衛星のアニメーションモデルに没頭しています。

00:07:14.000 --> 00:07:22.000
これは、アプリが空間のどこにでも3D要素を配置できる新しいシーンタイプである没入型スペースを使用します。

00:07:22.000 --> 00:07:30.000
没入型スペースを開くと、アプリは窓の境界を超えて魔法のような体験を提供することができます。

00:07:30.000 --> 00:07:34.000
没入型スペースの追加は、ウィンドウグループの追加に似ています。

00:07:34.000 --> 00:07:37.000
それは私のアプリの本体の新しいシーンです。

00:07:37.000 --> 00:07:43.000
ここでは、Model 3DよりもシーンをコントロールできるRealityViewを使用しています。

00:07:43.000 --> 00:07:46.000
数分後にRealityViewについて詳しく説明します。

00:07:46.000 --> 00:07:53.000
以前と同様に、アプリの詳細ビューにボタンを追加します。

00:07:53.000 --> 00:08:06.000
環境からopenImmersiveSpaceアクションを取得し、定義したシーンの識別子で呼び出します。

00:08:06.000 --> 00:08:09.000
openImmersiveSpaceアクションは非同期であることに注意してください。

00:08:09.000 --> 00:08:14.000
スペースの開放が終わると完了します。

00:08:14.000 --> 00:08:19.000
View Orbitsボタンを押すと、没入型空間が現れます。

00:08:19.000 --> 00:08:28.000
これはすでに素晴らしいですが、RealityKitでインタラクティブ性、アニメーション、オーディオを追加することで、より魅力的にすることができます。

00:08:28.000 --> 00:08:39.000
3Dコンテンツを含む2Dウィンドウでも、3Dモデルを強調する体積ウィンドウでも、まだチェックしていない場合は、これらのSwiftUIセッションをチェックすることをお勧めします。

00:08:39.000 --> 00:08:46.000
「空間コンピューティングのためのSwiftUIに会う」セッションは、このプラットフォームのSwiftUIの新機能の概要です。

00:08:46.000 --> 00:08:55.000
「SwiftUIを次の次元へ」セッションは、ウィンドウで3Dコンテンツを最大限に活用する方法を示しています。

00:08:55.000 --> 00:08:58.000
没入のスタイルも複数あります。

00:08:58.000 --> 00:09:07.000
ハローワールドの太陽系モジュールは、パススルーを隠し、独自の背景を表示する完全に没入型のスペースを使用しています。

00:09:07.000 --> 00:09:14.000
「SwiftUIでウィンドウを越えて」セッションでは、没入型スペースのすべてのスタイルについて詳しく説明します。

00:09:14.000 --> 00:09:19.000
没入型体験を生み出すことを考えているなら、この講演を強くお勧めします。

00:09:19.000 --> 00:09:28.000
SwiftUIビューでRealityKitを使用する2つの方法、使いやすいModel 3DとRealityViewに遭遇しました。

00:09:28.000 --> 00:09:36.000
RealityViewは、RealityKitエンティティを使用して3Dコンテンツを作成できるため、このセッションの残りの部分に使用するものです。

00:09:36.000 --> 00:09:39.000
では、RealityKitエンティティとは何ですか?

00:09:39.000 --> 00:09:41.000
エンティティはコンテナオブジェクトです。

00:09:41.000 --> 00:09:44.000
コードから空のエンティティを作成しても、何もしません。

00:09:44.000 --> 00:09:49.000
エンティティをレンダリングまたは動作させるには、コンポーネントが必要です。

00:09:49.000 --> 00:09:54.000
各コンポーネントは、エンティティの特定の動作を可能にします。

00:09:54.000 --> 00:09:57.000
ここにいくつかの例があります。

00:09:57.000 --> 00:10:09.000
このアプリの地球エンティティは、エンティティにメッシュと材料を与えるモデルコンポーネントと、エンティティを3D空間に配置する変換コンポーネントの2つのコンポーネントで実装されています。

00:10:09.000 --> 00:10:13.000
衛星エンティティにも同じことが当てはまります。

00:10:13.000 --> 00:10:18.000
モデルコンポーネントはメッシュをレンダリングし、それに材料を適用します。

00:10:18.000 --> 00:10:27.000
これらの地球と衛星モデルは、デジタルコンテンツ作成ツールで作成され、USDZファイルにエクスポートされ、RealityKitにロードされました。

00:10:27.000 --> 00:10:33.000
これらのメッシュには、最終的な外観を与えるために物理的ベースの材料が適用されています。

00:10:33.000 --> 00:10:41.000
素材は、メッシュの表面が光にどのように反応するかを説明するために、一連のテクスチャとシェーダーを使用します。

00:10:41.000 --> 00:10:49.000
資料の詳細については、ニールスセッション「Explore materials in Reality Composer Pro」を見ることをお勧めします。

00:10:49.000 --> 00:10:53.000
モデルに加えて、これらのエンティティには変換コンポーネントがあります。

00:10:53.000 --> 00:10:57.000
変換コンポーネントは、エンティティを3D空間に配置します。

00:10:57.000 --> 00:11:08.000
エンティティの位置、向き、およびスケールを制御するには、変換コンポーネントのプロパティを設定するだけでなく、エンティティの親を設定することもできます。

00:11:08.000 --> 00:11:15.000
RealityKitは、ARKitや他の多くの3Dエンジンと同じ3D座標規則を使用しています。

00:11:15.000 --> 00:11:18.000
起源はRealityViewの中心にあります。

00:11:18.000 --> 00:11:25.000
Y軸は上を指し、z軸はあなたを指し、x軸は右を指しています。

00:11:25.000 --> 00:11:28.000
1ユニットは1メートルです。

00:11:28.000 --> 00:11:33.000
これらの慣習は、SwiftUIの慣習とは異なることに注意してください。

00:11:33.000 --> 00:11:42.000
RealityViewのコンテンツインスタンスには、RealityKitとSwiftUI座標空間の間で簡単に変換できる機能があります。

00:11:42.000 --> 00:11:47.000
すべてのエンティティには変換がありますが、すべてのエンティティにモデルがあるわけではありません。

00:11:47.000 --> 00:11:54.000
エンティティは、それぞれが独自のコンポーネントセットを持つ複数の子エンティティから組み立てられることがあります。

00:11:54.000 --> 00:11:56.000
これにより、よりプログラムによる制御が提供されます。

00:11:56.000 --> 00:12:03.000
たとえば、子エンティティの変換で個々のアニメーションを再生できます。

00:12:03.000 --> 00:12:07.000
RealityKitには、やりたいことに応じてさまざまなコンポーネントが含まれています。

00:12:07.000 --> 00:12:14.000
今日は、いくつかの特定のコンポーネント、衝突、入力ターゲット、ホバー効果について説明します。

00:12:14.000 --> 00:12:19.000
また、独自のコンポーネントを作成する方法も実演します。

00:12:19.000 --> 00:12:27.000
エンティティとコンポーネントがどのように機能するかを理解したので、RealityViewを使用してそれらのエンティティをアプリに配置しましょう。

00:12:27.000 --> 00:12:31.000
RealityViewは、任意の数のエンティティを含むSwiftUIビューです。

00:12:31.000 --> 00:12:37.000
レンダリング、アニメーション化、シミュレートするには、エンティティをRealityViewに追加する必要があります。

00:12:37.000 --> 00:12:40.000
では、RealityViewはどのように機能しますか?

00:12:40.000 --> 00:12:46.000
RealityViewは、ビューにエンティティを追加できるコンテンツインスタンスを提供します。

00:12:46.000 --> 00:12:53.000
これは、すでにエンティティをロードしている場合、またはプログラムでエンティティを作成したい場合は、簡単に開始できます。

00:12:53.000 --> 00:13:00.000
しかし、このクロージャは非同期なので、ファイルからエンティティをロードしてビューに表示するのは簡単です。

00:13:00.000 --> 00:13:10.000
ここでは、USDファイルから地球モデルを非同期にロードし、ロードが完了したらコンテンツインスタンスに追加します。

00:13:10.000 --> 00:13:15.000
また、複数のモデルをロードして、両方をRealityViewに配置することもできます。

00:13:15.000 --> 00:13:20.000
隣り合う代わりに、これらのモデルは宇宙で一致します。

00:13:20.000 --> 00:13:24.000
それがあなたが望むものでない場合は、ビューに追加されたエンティティの位置を変更できます。

00:13:24.000 --> 00:13:30.000
この例では、月の実体を半メートル右に配置します。

00:13:30.000 --> 00:13:38.000
RealityViewを設定したら、アプリの状態をRealityKitコンポーネントに保存されているプロパティに接続したいと思うかもしれません。

00:13:38.000 --> 00:13:47.000
RealityViewを使用すると、SwiftUI管理状態とRealityView内のエンティティ間の接続を更新クロージャで表現できます。

00:13:47.000 --> 00:13:54.000
これにより、アプリのデータモデルからの真実のソースを使用して、3Dモデルの動作を簡単に推進できます。

00:13:54.000 --> 00:14:00.000
このビューはモデルをロードし、ビューを使用する人によって制御される回転を適用します。

00:14:00.000 --> 00:14:07.000
更新セクションのコードは、依存する値が変更された場合にのみ実行されることに注意してください。

00:14:07.000 --> 00:14:16.000
2D要素と3D要素を組み合わせてUIを構築する場合は、ビューとエンティティ間の座標を変換する必要がある場合があります。

00:14:16.000 --> 00:14:25.000
RealityViewは、SwiftUIビュー座標空間とRealityKitエンティティ座標空間の間の座標変換関数を提供します。

00:14:25.000 --> 00:14:39.000
RealityViewのコンテンツインスタンスは、ポイント、境界ボックスを変換し、SwiftUI座標空間からエンティティのローカル空間、またはその逆に変換する変換関数を提供します。

00:14:39.000 --> 00:14:48.000
ここでは、ビューの寸法の最小長を取得し、利用可能なスペースに収まるようにロードされたエンティティをスケーリングします。

00:14:48.000 --> 00:14:56.000
RealityViewは、エンティティとコンポーネントによって公開されたイベントを購読するメカニズムも提供します。

00:14:56.000 --> 00:15:02.000
この例では、ロードが完了した後、ロードされたUSDファイルで作成されたアニメーションを再生します。

00:15:02.000 --> 00:15:08.000
コンテンツインスタンスには、イベントハンドラを追加するsubscribe to:関数があります。

00:15:08.000 --> 00:15:12.000
この例では、アニメーションが完了したときにいくつかのコードを実行します。

00:15:12.000 --> 00:15:19.000
アニメーションから物理学、オーディオまで、あらゆる種類のものに対して公開されたRealityKitイベントがあります。

00:15:19.000 --> 00:15:23.000
SwiftUIビューをエンティティに添付することもできます。

00:15:23.000 --> 00:15:29.000
RealityViewのアタッチメント機能により、3D空間でビューを簡単に配置できます。

00:15:29.000 --> 00:15:36.000
詳細については、ユージーンのセッション「RealityKitで空間コンピューティングアプリを強化する」をご覧ください。

00:15:36.000 --> 00:15:39.000
RealityViewでできることはたくさんあります。

00:15:39.000 --> 00:15:43.000
しかし、私たちの天体に戻って、それらを生き生きとさせましょう。

00:15:43.000 --> 00:15:49.000
まず、地球のエンティティの位置を変更できるように、ドラッグジェスチャーを追加する方法を紹介します。

00:15:49.000 --> 00:15:52.000
そして、アニメーションと空間オーディオについて説明します。

00:15:52.000 --> 00:15:56.000
これは、3つのエンティティを含むRealityViewの例です。

00:15:56.000 --> 00:16:04.000
他のSwiftUIビューと同様に、RealityViewにジェスチャーを追加することができ、そのビューのエンティティに対してテストにヒットします。

00:16:04.000 --> 00:16:10.000
入力を受信するには、エンティティに入力ターゲットコンポーネントと衝突コンポーネントの両方が必要です。

00:16:10.000 --> 00:16:19.000
タッチイベントがRealityViewによって処理されると、衝突と入力ターゲットの両方を持つエンティティは無視されます。

00:16:19.000 --> 00:16:29.000
この最後のエンティティだけが両方のコンポーネントを持っているので、このRealityViewに追加されたジェスチャーは、このエンティティに向けられた入力にのみ反応します。

00:16:29.000 --> 00:16:38.000
地球のエンティティをドラッグ可能にするために、入力ターゲットコンポーネントと衝突コンポーネントを与え、RealityViewにドラッグジェスチャーを追加します。

00:16:38.000 --> 00:16:43.000
コンポーネントを追加するには、Reality Composer Proを使用します。

00:16:43.000 --> 00:16:49.000
Reality Composer Proは、3Dコンテンツを構成、編集、プレビューできる新しい開発者ツールです。

00:16:49.000 --> 00:16:53.000
エンティティにいくつかのコンポーネントを追加するだけです。

00:16:53.000 --> 00:17:01.000
Reality Composer Proでできることの詳細については、エリックのセッション「Meet Reality Composer Pro」をご覧ください。

00:17:01.000 --> 00:17:09.000
Worldアプリには、このエクスペリエンスが使用するUSDファイルを含むWorld Assetsパッケージがすでに設定されています。

00:17:09.000 --> 00:17:20.000
Reality Composer Proでそのパッケージを開きます。

00:17:20.000 --> 00:17:27.000
地球モデルはUSDZのアーカイブにあり、これは自己完結型であり、変更されるものではありません。

00:17:27.000 --> 00:17:34.000
その資産を変更する代わりに、新しいUSDシーンファイルを作成し、地球の資産を参照します。

00:17:34.000 --> 00:17:42.000
USDファイルは、参照されたファイルを実際に変更することなく、他のUSDを参照して変更することができます。

00:17:42.000 --> 00:17:50.000
このような非破壊編集は、他の誰かが取り組んでいるUSDファイルに小さな変更を加える必要があるときに本当に便利です。

00:17:50.000 --> 00:18:02.000
DraggableGlobeという名前の新しいシーンを作成し、グローブファイルをドラッグして参照を作成します。

00:18:02.000 --> 00:18:04.000
今、私はそれにコンポーネントを追加することができます。

00:18:04.000 --> 00:18:11.000
入力ターゲットコンポーネントと衝突コンポーネントを追加します。

00:18:11.000 --> 00:18:15.000
衝突コンポーネントのデフォルトの形状は立方体です。

00:18:15.000 --> 00:18:21.000
モデルによりよく一致するように、球体に変更します。

00:18:21.000 --> 00:18:26.000
衝突形状が視覚モデルの合理的な近似であることが重要です。

00:18:26.000 --> 00:18:31.000
試合が近ければ近いほど、モデルとのより直感的な相互作用になります。

00:18:31.000 --> 00:18:37.000
地球モデルを移動できるようにしたいので、RealityViewにドラッグジェスチャーを追加します。

00:18:37.000 --> 00:18:50.000
標準のSwiftUIドラッグジェスチャーは機能しますが、ジェスチャーに targetedToEntity修飾子を追加することで、ビュー全体ではなく特定のエンティティを操作できるようにすることができます。

00:18:50.000 --> 00:18:55.000
ジェスチャーの値が変更されたら、エンティティの位置を一致するように変更します。

00:18:55.000 --> 00:18:56.000
しかし、重要な詳細が1つあります。

00:18:56.000 --> 00:19:06.000
ジェスチャーの値はSwiftUIの座標空間にあるので、エンティティの位置を変更するには、RealityKitの座標空間に変換する必要があります。

00:19:06.000 --> 00:19:08.000
すべてのピースが所定の位置に整っています。

00:19:08.000 --> 00:19:15.000
したがって、Orbitモジュールのオブジェクトでは、ピンチしてドラッグして地球を動かすことができます。

00:19:15.000 --> 00:19:18.000
素晴らしい、私たちのアプリはインタラクティブになりました。

00:19:18.000 --> 00:19:22.000
しかし、私の地球エンティティは、それがインタラクティブであることを示すことをしたいと思います。

00:19:22.000 --> 00:19:27.000
このために使用できるRealityKitコンポーネント、HoverEffectComponentがあります。

00:19:27.000 --> 00:19:34.000
SwiftUIとRealityKitが提供するホバー効果は、アプリが探している場所に反応させる唯一の方法です。

00:19:34.000 --> 00:19:41.000
この効果は、プライバシーを保護する方法でアプリのプロセスの外で適用されます。

00:19:41.000 --> 00:19:46.000
RealityViewに追加されると、地球エンティティにホバー効果コンポーネントを追加します。

00:19:46.000 --> 00:19:54.000
今、地球モデルはポインタが上にあるときに点灯し、私がそれと対話できることを示しています。

00:19:54.000 --> 00:19:56.000
次に、アニメーションに移りましょう。

00:19:56.000 --> 00:20:16.000
RealityKitには、初期値から最終値にプロパティをアニメーション化するfrom-to-byアニメーション、エンティティが親の周りを回転させる軌道アニメーション、一連の値を介してフレームごとに進行するタイムサンプリングアニメーションなど、多くのアニメーションタイプが組み込まれています。

00:20:16.000 --> 00:20:20.000
月に軌道アニメーションを設定します。 軌道アニメーションを設定します。

00:20:20.000 --> 00:20:27.000
月は全軌道を完了するのに30秒かかり、軌道軸はy軸になります。

00:20:27.000 --> 00:20:32.000
そして、軌道が月の現在の位置から始まることを確認します。

00:20:32.000 --> 00:20:42.000
この軌道アニメーションのプロパティを定義したら、そのためのアニメーションリソースを生成し、そのアニメーションを月のエンティティで再生します。

00:20:42.000 --> 00:20:46.000
そして今、月は地球を周回しています。

00:20:46.000 --> 00:20:48.000
私にとって、これは魔法の瞬間です。

00:20:48.000 --> 00:20:51.000
アニメーションを配置すると、シーンは生き生きとしています。

00:20:51.000 --> 00:21:00.000
しかし、アニメーションは3Dコンテンツに命を吹き込むのに役立ちますが、空間オーディオはモデルが本当にそこにあるように感じさせます。

00:21:00.000 --> 00:21:05.000
RealityKitには、空間、アンビエント、チャンネルの3種類のオーディオがあります。

00:21:05.000 --> 00:21:08.000
それぞれをもっと詳しく見てみましょう。 

00:21:08.000 --> 00:21:16.000
RealityKitの音はデフォルトでは空間的なので、オーディオソースは実際に周囲に存在するように聞こえます。

00:21:16.000 --> 00:21:26.000
空間オーディオコンポーネントを使用すると、オブジェクトが空間に音を放出する方法をカスタマイズして、さらに現実的または芸術的にすることができます。

00:21:26.000 --> 00:21:34.000
指向性を使用して、あらゆる方向に音を発したり、特定の方向に音を投影したりします。

00:21:34.000 --> 00:21:40.000
アンビエントオーディオコンポーネントは、環境の音をキャプチャするマルチチャンネルファイルに最適です。

00:21:40.000 --> 00:21:43.000
アンビエントソースには追加のリバーブは追加されません。

00:21:43.000 --> 00:21:49.000
雰囲気の各チャンネルは固定された方向から再生されます。

00:21:49.000 --> 00:21:56.000
そして最後に、チャンネルオーディオコンポーネントは、空間効果なしでオーディオファイルチャンネルをスピーカーに直接送信します。

00:21:56.000 --> 00:22:01.000
これは、視覚的要素に接続されていないバックグラウンドミュージックに最適です。

00:22:01.000 --> 00:22:07.000
Reality Composer Proでシーンにオーディオを追加し、RealityKitを使用してインターフェイスすることができます。

00:22:07.000 --> 00:22:10.000
または、コードでオーディオを接続することもできます。

00:22:10.000 --> 00:22:11.000
見てみましょう。 

00:22:11.000 --> 00:22:16.000
軌道上の衛星にループオーディオを少し追加します。

00:22:16.000 --> 00:22:22.000
まず、オーディオソースとして機能する空のエンティティに空間オーディオコンポーネントを追加します。

00:22:22.000 --> 00:22:28.000
0.75の指向性は、特定の方向にタイトな音のビームを作成します。

00:22:28.000 --> 00:22:36.000
オーディオが望む方向に投影されるように、そのオーディオソースエンティティをy軸の周りに回転させます。

00:22:36.000 --> 00:22:44.000
次に、リソースからループオーディオクリップをロードし、playAudioを呼び出してaudioSourceエンティティで再生します。

00:22:44.000 --> 00:22:46.000
これを実際に見てみましょう。

00:22:46.000 --> 00:23:00.000
空間オーディオソースはしっかりと焦点を絞った指向性で構成されているため、オーディオは地球の私の側ではっきりと聞くことができますが、衛星が反対側にあるときは静かです。

00:23:00.000 --> 00:23:04.000
それは入力、アニメーション、オーディオでした。

00:23:04.000 --> 00:23:11.000
既存の機能をさまざまな方法で組み合わせることで、RealityKitでより多くの機能を構築できます。

00:23:11.000 --> 00:23:18.000
この目的のために使用できる2つの主要なツールは、独自のコンポーネントを定義し、独自のシステムを定義します。

00:23:18.000 --> 00:23:24.000
コンポーネントには、3Dエクスペリエンスの1つの側面を制御するデータが含まれています。

00:23:24.000 --> 00:23:26.000
コンポーネントはエンティティにグループ化されます。

00:23:26.000 --> 00:23:29.000
コンポーネントがなければ、エンティティは何もしません。

00:23:29.000 --> 00:23:33.000
各コンポーネントは、エンティティの実装の単一の要素を提供します。

00:23:33.000 --> 00:23:40.000
変換コンポーネントがエンティティを配置し、モデルコンポーネントが3Dモデルをレンダリングすることを学びました。

00:23:40.000 --> 00:23:46.000
RealityKitが提供する事前定義されたコンポーネントに加えて、独自のコンポーネントを定義できます。

00:23:46.000 --> 00:23:53.000
以下は、同僚のPaulが作成したtraceMeshオブジェクトを含むカスタムコンポーネントの例です。

00:23:53.000 --> 00:24:03.000
トレースコンポーネントタイプはコンポーネントプロトコルに準拠しているため、実行時に任意のエンティティでこのコンポーネントを取得して設定できます。

00:24:03.000 --> 00:24:12.000
また、Swiftパッケージでコンポーネントを定義し、Codableプロトコルに準拠することで、データ駆動型のワークフローを採用することもできます。

00:24:12.000 --> 00:24:20.000
コード可能なコンポーネントは、Reality Composer Proインターフェイスに表示され、設計時にエンティティに直接追加できます。

00:24:20.000 --> 00:24:28.000
カスタムコンポーネントの詳細については、トーク「XcodeでReality Composer Proのコンテンツを操作する」を参照してください。

00:24:28.000 --> 00:24:32.000
この講演の早い段階ですでにエンティティを調べましたが、コンポーネントを取り上げました。

00:24:32.000 --> 00:24:35.000
次に、システムについて話しましょう。

00:24:35.000 --> 00:24:40.000
システムには、エンティティとコンポーネントに作用するコードが含まれています。

00:24:40.000 --> 00:24:51.000
まとめると、エンティティ、コンポーネント、システム、またはECSは、3Dエクスペリエンスの外観と動作をモデル化するためのツールです。

00:24:51.000 --> 00:24:56.000
システムは、アプリの動作を実装するコードを構造化する方法です。

00:24:56.000 --> 00:25:02.000
システム内のコードは定期的に実行され、コンポーネントの現在の状態に応じて作用します。

00:25:02.000 --> 00:25:10.000
たとえば、このTraceSystemは、地球を周回する際に衛星エンティティの後ろにトレースされたラインメッシュを更新します。

00:25:10.000 --> 00:25:15.000
更新のたびに、エンティティの現在の位置がトレースに追加されます。

00:25:15.000 --> 00:25:22.000
システムが登録されると、RealityKitを使用するアプリのどこにでも自動的に適用されます。

00:25:22.000 --> 00:25:29.000
アプリの初期化子にトレースシステムを登録すると、関連するすべてのエンティティが更新されます。

00:25:29.000 --> 00:25:34.000
しかし、どのようなエンティティが関連し、システムはいつ更新されますか?

00:25:34.000 --> 00:25:44.000
このシステムは、トレースコンポーネントを持つエンティティのみを更新したいので、トレースコンポーネントを持つエンティティにフィルタリングするエンティティクエリを作成します。

00:25:44.000 --> 00:25:53.000
更新機能では、システムはエンティティクエリを渡し、レンダリング時にエンティティを更新することも指定します。

00:25:53.000 --> 00:26:00.000
レンダリング条件は、このシステムがスムーズなアニメーションのために適切な速度で更新されることを意味します。

00:26:00.000 --> 00:26:09.000
これが動作中のトレースシステムで、流体カスタムアニメーションを生成するために、エンティティの位置をラインメッシュに追加します。

00:26:09.000 --> 00:26:15.000
システムは、さまざまな効果と行動を実装するための本当に効果的な方法です。

00:26:15.000 --> 00:26:19.000
RealityKitには、3Dアプリを簡単に構築できる機能がたくさんあります。

00:26:19.000 --> 00:26:28.000
RealityKitとRealityViewを使用して、SwiftUIで定義されたビュー、ウィンドウ、没入型スペースに3D要素を追加できます。

00:26:28.000 --> 00:26:35.000
RealityKitを使用して、USDファイルをロードしたり、ジェスチャーを処理したり、アニメーションや空間オーディオを再生したりできます。

00:26:35.000 --> 00:26:45.000
RealityKitは多くの事前定義されたコンポーネントを提供しますが、アプリの特定のニーズに合わせてカスタムコンポーネントやシステムを定義することもできます。

00:26:45.000 --> 00:26:50.000
私はそれを使って、RealityKitを使い始めるために必要な概念を取り上げました。

00:26:50.000 --> 00:27:00.000
ユージーンのセッション「Enhance Your spatial computing app with RealityKit」では、ポータル、パーティクルエミッタ、添付ファイルなど、RealityKitのより多くの機能について説明します。

00:27:00.000 --> 00:27:14.000
そして、アマンダのセッション「XcodeでReality Composer Proコンテンツを使用する」では、Reality Composer Pro、RealityKit、Xcodeプレビュー、およびシミュレータを使用して没入型アプリを構築するプロセスを説明します。

00:27:14.000 --> 00:27:18.000
RealityKitには、アプリで使用できるエキサイティングな機能がたくさんあります。

00:27:18.000 --> 00:27:23.000
あなたが生み出す素晴らしい経験を見るのが本当に楽しみです。

00:27:23.000 --> 00:27:24.000
見てくれてありがとう。

00:27:24.000 --> 23:59:59.000
♪

