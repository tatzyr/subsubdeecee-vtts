WEBVTT

00:00:01.000 -> 00:00:10.000
♪ ♪

00:00:10.000 -> 00:00:16.000
Can：こんにちは、私はCan Aranで、iOS System Experienceチームのエンジニアです。

00:00:16.000 -> 00:00:20.000
ライブアクティビティについてお話しできて光栄です。

00:00:20.000 -> 00:00:26.000
この講演では、ライブアクティビティの概要を説明します。

00:00:26.000 -> 00:00:29.000
次に、ライブアクティビティのライフサイクルを経ます。

00:00:29.000 -> 00:00:36.000
最後に、あなたの活動のための没入型でシンプルなUIを構築する方法を紹介します。

00:00:36.000 -> 00:00:41.000
まず、ライブアクティビティで何ができるかを掘り下げます。

00:00:41.000 -> 00:00:49.000
ライブアクティビティは、イベントやタスクの進捗状況を追跡するための没入型で glanceable方法です。

00:00:49.000 -> 00:00:59.000
ライブアクティビティには個別の開始と終了があり、バックグラウンドアプリのランタイムから、またはプッシュ通知を使用してリモートでリアルタイムの更新を提供できます。

00:00:59.000 -> 00:01:06.000
ユナイテッド航空とMLBの素晴らしい例を次に示します。

00:01:06.000 -> 00:01:12.000
ライブアクティビティは、iPhone 14 ProとPro Maxでさらに没入感があります。

00:01:12.000 -> 00:01:19.000
ダイナミックアイランドは、アプリがバックグラウンドにあるときに、システム全体にライブアクティビティを表示します。

00:01:19.000 -> 00:01:28.000
1つのライブアクティビティがアクティブになると、可変幅の「コンパクト」プレゼンテーションを使用してレンダリングされます。

00:01:28.000 -> 00:01:32.000
ダイナミックアイランドは、一度に最大2つのライブアクティビティを表示します。

00:01:32.000 -> 00:01:41.000
これらのライブアクティビティの1つはTrueDepthカメラに取り付けられ、もう1つは独自の切り離されたビューでレンダリングされます。

00:01:41.000 -> 00:01:47.000
これらのライブアクティビティは両方とも「最小限の」プレゼンテーションを使用します。

00:01:47.000 -> 00:01:58.000
いつでも、ライブアクティビティを長押しして「拡張された」プレゼンテーションを表示し、さらに目を見やすい情報を与えることができます。

00:01:58.000 -> 00:02:07.000
拡張されたプレゼンテーションでは、ビューはアプリ内のさまざまな領域に深くリンクすることができ、豊富なユーザーエクスペリエンスを提供します。

00:02:07.000 -> 00:02:13.000
iOS 17のライブアクティビティにはいくつかの新しい体験があります。

00:02:13.000 -> 00:02:20.000
ロック画面とダイナミックアイランドに加えて、ライブアクティビティはスタンバイに表示されます。

00:02:20.000 -> 00:02:24.000
そして今、iPadはライブアクティビティもサポートしています。

00:02:24.000 -> 00:02:33.000
iPadOSでの実装を有効にし、Crumbl Cookiesのように、没入型のライブアクティビティをiPadに持ち込みます。

00:02:33.000 -> 00:02:42.000
iOS 17では、WidgetKitとSwiftUIを使用して、ライブアクティビティにインタラクティブ性を追加できます。

00:02:42.000 -> 00:02:48.000
ボタンやトグルを追加して、ユーザーエクスペリエンスを向上させることができます。

00:02:48.000 -> 00:02:56.000
ルカのビデオ「ウィジェットに命を吹き込む」で、ウィジェットにインタラクティブ性をもたらす方法の詳細をご覧ください。

00:02:56.000 -> 00:03:06.000
ライブアクティビティはActivityKitフレームワークに依存しており、アプリがライフサイクルをリクエスト、更新、管理できるようにします。

00:03:06.000 -> 00:03:11.000
それらはSwiftUIとWidgetKitを使用して宣言的にレイアウトされています。

00:03:11.000 -> 00:03:17.000
以前にホーム画面のウィジェットを実装したことがあれば、これは非常に身近に感じるでしょう。

00:03:17.000 -> 00:03:22.000
ライブアクティビティは、アプリがフォアグラウンドにあるときにリクエストできます。

00:03:22.000 -> 00:03:33.000
アプリは、個別のユーザーアクション、おそらくイベントを「フォロー」した後、またはタスクを明示的に開始した後にのみ、ライブアクティビティを要求する必要があります。

00:03:33.000 -> 00:03:37.000
これは、ポジティブなユーザーエクスペリエンスを確保するために不可欠です。

00:03:37.000 -> 00:03:42.000
ライブアクティビティは、通知と同様にユーザーモデレートされます。

00:03:42.000 -> 00:03:47.000
誰かがあなたのアプリのためにそれらを完全に却下またはオフにすることができます。

00:03:47.000 -> 00:03:57.000
APIでは、ロック画面から3つのダイナミックアイランドプレゼンテーションすべてまで、すべてのプレゼンテーションをサポートする必要があります。

00:03:57.000 -> 00:04:03.000
スタンバイでは、システムはロック画面のプレゼンテーションをスケーリングして画面を埋めます。

00:04:03.000 -> 00:04:14.000
バックグラウンドランタイムに依存することに加えて、アプリは「ライブアクティビティ」プッシュタイプのプッシュ通知を使用して、ライブアクティビティをリモートで更新できます。

00:04:14.000 -> 00:04:23.000
プッシュ通知でライブアクティビティを更新する方法の詳細については、ジェフのビデオをご覧ください。

00:04:23.000 -> 00:04:28.000
アプリのライブアクティビティは、ライフサイクル中にさまざまな段階を経ます。

00:04:28.000 -> 00:04:36.000
私は、絵文字レンジャーアプリからヒーローを選択し、冒険に連れて行くことができるライブアクティビティを構築しています。

00:04:36.000 -> 00:04:42.000
冒険の間、主人公は挑戦に直面し、ボスと戦います。

00:04:42.000 -> 00:04:48.000
この冒険の重要な瞬間をライブアクティビティで表示します。

00:04:48.000 -> 00:04:54.000
このライブアクティビティは、ヒーローの冒険に関する最も重要な情報を表示します。

00:04:54.000 -> 00:05:05.000
これには、ヒーローの名前と統計、アバター、健康レベル、そしてこのヒーローが冒険で経験したことについての説明が含まれています。

00:05:05.000 -> 00:05:09.000
ライブアクティビティのライフサイクルには、4つの主要なステップが含まれています。

00:05:09.000 -> 00:05:12.000
アクティビティをリクエストすることから始めます。

00:05:12.000 -> 00:05:16.000
開始したら、最新のコンテンツで更新してください。

00:05:16.000 -> 00:05:22.000
それまでの間、それを終わらせる人々など、状態の変化に反応するためにあなたの活動を観察してください。

00:05:22.000 -> 00:05:28.000
タスクが完了したら、必ずアクティビティを終了してください。

00:05:28.000 -> 00:05:31.000
ライブアクティビティのリクエストはとても簡単です。

00:05:31.000 -> 00:05:41.000
アプリがフォアグラウンドにあることを確認し、初期コンテンツと必要なアクティビティリクエストデータがあるようにアプリを設定します。

00:05:41.000 -> 00:05:53.000
Emoji Rangersアプリでライブアクティビティをリクエストする前に、「ActivityAttributes」を実装して、ライブアクティビティの静的および動的データのセットを定義することから始める必要があります。

00:05:53.000 -> 00:05:57.000
私はそれを「AdventureAttributes」と呼んでいます。

00:05:57.000 -> 00:06:02.000
「AdventureAttributes」は、ヒーローである1つの静的データを記述します。

00:06:02.000 -> 00:06:11.000
また、ヒーローのヘルスレベルとイベントの説明をカプセル化する、必要なカスタム「ContentState」を定義します。

00:06:11.000 -> 00:06:21.000
これらのプロパティが変更されると、ライブアクティビティUIが更新され、冒険の現在の状態を画面に表示できるようになります。

00:06:21.000 -> 00:06:27.000
動的データと静的データの準備ができたので、アドベンチャーアクティビティのリクエストを設定します。

00:06:27.000 -> 00:06:39.000
ヒーローと一緒にAdventureAttributesのインスタンスの作成を開始し、ヒーローのヘルスレベルとイベントの説明で最初のコンテンツを設定します。

00:06:39.000 -> 00:06:48.000
各アクティビティコンテンツは、コンテンツが古くなったと見なされたときにシステムに通知するために、古い日付を提供することができます。

00:06:48.000 -> 00:06:51.000
今のところ、私はゼロで合格します。

00:06:51.000 -> 00:07:01.000
コンテンツの関連性スコアは、いくつかのアドベンチャーアクティビティが開始されたときに各ライブアクティビティが表示される順序を決定します。

00:07:01.000 -> 00:07:08.000
別のアドベンチャーアクティビティを開始する場合は、それぞれに異なる関連性スコアを指定します。

00:07:08.000 -> 00:07:11.000
関連性スコアに合格することはオプションです。

00:07:11.000 -> 00:07:14.000
デフォルト値はゼロです。

00:07:14.000 -> 00:07:17.000
アクティビティをリクエストできるようになりました。

00:07:17.000 -> 00:07:24.000
属性、初期コンテンツ、プッシュ通知タイプを渡します。

00:07:24.000 -> 00:07:34.000
プッシュ通知タイプは、ライブアクティビティがActivityKitプッシュ通知で動的コンテンツの更新を受信するかどうかを示します。

00:07:34.000 -> 00:07:41.000
この例では、「nil」に設定します。つまり、このアクティビティはローカルでしか更新を受信できません。

00:07:41.000 -> 00:07:50.000
このライブアクティビティを開始するには、絵文字レンジャーアプリのライブアクティビティ設定を有効にする必要があります。

00:07:50.000 -> 00:08:00.000
ライブアクティビティをリクエストできるようになったので、ヒーローがスリリングなタスクを経験したときに冒険を更新する方法を見ていきます。

00:08:00.000 -> 00:08:04.000
動的属性は、ライブアクティビティをいつ更新するかを教えてくれます。

00:08:04.000 -> 00:08:10.000
イベントの説明やヒーローのヘルスレベルが変わるたびに、アクティビティを更新します。

00:08:10.000 -> 00:08:15.000
やばい！主人公はボスから大打撃を受ける。

00:08:15.000 -> 00:08:24.000
そこで、健康レベルの変化を反映し、イベントを説明する「contentState」を作成します。

00:08:24.000 -> 00:08:29.000
ヒーローの体力レベルが大幅に低下したので、アラートを送信する必要があります。

00:08:29.000 -> 00:08:32.000
そのためにアラート設定を作成します。

00:08:32.000 -> 00:08:42.000
これにより、ライブアクティビティで重要な情報が変更された場合、iPhone、iPad、または同期されたApple Watchにアラートが表示されます。

00:08:42.000 -> 00:08:47.000
この場合、ヒーローは重傷を負い、癒すためにポーションが必要です。

00:08:47.000 -> 00:08:54.000
設定のタイトルと本文はApple Watchでのみ使用され、通知として表示されます。

00:08:54.000 -> 00:09:02.000
iPhoneとiPadでは、更新されたコンテンツを含むアクティビティUIが指定されたサウンドで表示されます。

00:09:02.000 -> 00:09:10.000
これで、更新されたコンテンツとアラート設定を使用して、アクティビティオブジェクトの更新APIを呼び出すことができます。

00:09:10.000 -> 00:09:17.000
これにより、ライブアクティビティUIが更新され、ユーザーがこの更新で警告されるようになります。

00:09:17.000 -> 00:09:23.000
アクティビティ状態の変更は、ライブアクティビティのライフサイクル中いつでも発生する可能性があります。

00:09:23.000 -> 00:09:30.000
「開始」、「終了」、「却下」、「古い」の4つの状態があります。

00:09:30.000 -> 00:09:38.000
アクティビティオブジェクトのactivityStateUpdates APIを使用してこれらの状態を観察し、更新を非同期に受信します。

00:09:38.000 -> 00:09:50.000
アクティビティが却下されると、私はもう冒険データを追跡していないことを確認し、進行中のアクティビティを表示しないようにアプリのUIを更新します。

00:09:50.000 -> 00:09:57.000
また、activityState APIを通じて状態をチェックして、必要に応じて同期的に取得することもできます。

00:09:57.000 -> 00:09:59.000
私のヒーローは多くのことを経験しました。

00:09:59.000 -> 00:10:03.000
冒険のライブアクティビティを終わらせる時が来ました。

00:10:03.000 -> 00:10:09.000
アクティビティを終了できるようにするには、最終的なコンテンツを作成することから始めます。

00:10:09.000 -> 00:10:15.000
私のコンテンツは、ヒーローがボスを倒す冒険の最終状態を示します。

00:10:15.000 -> 00:10:19.000
次に、UIの解雇ポリシーを決定します。

00:10:19.000 -> 00:10:23.000
デフォルトのポリシーは、この場合に適しています。

00:10:23.000 -> 00:10:37.000
このポリシーは、誰かがロック画面を見て冒険の終わりに何が起こったのかを見ることができるように、冒険情報が終了後しばらくの間ロック画面に表示されることを保証します。

00:10:37.000 -> 00:10:43.000
私は今、冒険活動を終了し、ヒーローを休ませることができます。

00:10:43.000 -> 00:10:46.000
ライブアクティビティのライフサイクルに関するすべてのロジックを構築しました。

00:10:46.000 -> 00:10:50.000
アクティビティUIに焦点を当てる時が来ました。

00:10:50.000 -> 00:10:56.000
Emoji Rangerウィジェット拡張機能には現在、WidgetBundleに2つのウィジェットがあります。

00:10:56.000 -> 00:11:00.000
WidgetBundleにライブアクティビティの設定を追加する必要があります。

00:11:00.000 -> 00:11:04.000
私はそれを「AdventureActivityConfiguration」と呼びます。

00:11:04.000 -> 00:11:13.000
「AdventureActivityConfiguration」はウィジェットインフラストラクチャを活用し、本体にWidgetConfigurationを返す必要があります。

00:11:13.000 -> 00:11:19.000
ライブアクティビティの内容を説明するActivityConfigurationオブジェクトを作成します。

00:11:19.000 -> 00:11:31.000
プレゼンテーションの終了ごとに、ActivityConfigurationオブジェクトは、静的および動的属性とアクティビティIDを格納するActivityViewContextを提供します。

00:11:31.000 -> 00:11:37.000
このコンテキストは、設定に渡された属性タイプに基づいて作成されます。

00:11:37.000 -> 00:11:43.000
このタイプは、アクティビティが要求される属性と一致する必要があります。

00:11:43.000 -> 00:11:50.000
アクティビティ設定を正常に初期化できるように、「AdventureAttributes」タイプを渡します。

00:11:50.000 -> 00:11:55.000
「ActivityConfiguration」の最初のクロージャは、ロック画面のUIを指定します。

00:11:55.000 -> 00:12:02.000
アクティビティの更新でビューのコンテキストが変更されると、このUIは更新ごとにレンダリングされます。

00:12:02.000 -> 00:12:13.000
ウィジェットと同様に、ライブアクティビティのロック画面UIのサイズは提供していませんが、システムに適切な寸法を決定させます。

00:12:13.000 -> 00:12:25.000
絵文字レンジャーのアクティビティでは、ネイビーブルーの背景のロック画面にヒーロー情報、名前とアバター、ヘルスレベル、イベントの説明を表示します。

00:12:25.000 -> 00:12:32.000
「AdventureLiveActivityView」は、渡されたビューコンテキストを介してすべての情報を持ちます。

00:12:32.000 -> 00:12:43.000
ロック画面での私のライブアクティビティはシンプルでエレガントに見え、ヒーローが冒険で経験していることについて必要な情報がすべて揃っています。

00:12:43.000 -> 00:12:49.000
ロック画面のUIをまとめたので、ダイナミックアイランドのプレゼンテーションを実装する必要があります。

00:12:49.000 -> 00:12:54.000
コンパクト、ミニマル、拡張の3つのプレゼンテーションがあります。

00:12:54.000 -> 00:13:03.000
私のアプリのライブアクティビティがシステムで実行されている唯一のものである場合、コンパクトなプレゼンテーションを使用して表示されます。

00:13:03.000 -> 00:13:08.000
コンパクトなプレゼンテーションには、先行と後続の2つの領域があります。

00:13:08.000 -> 00:13:13.000
彼らは一緒に現れ、ダイナミックアイランドでまとまりのあるプレゼンテーションを形成します。

00:13:13.000 -> 00:13:21.000
スペースが限られているため、先頭と後続のスペースに表示する必須コンテンツを選択してください。

00:13:21.000 -> 00:13:28.000
ユーザーは、ここのコンテンツを見ることで、特定のアクティビティを特定できるはずです。

00:13:28.000 -> 00:13:42.000
ActivityConfigurationオブジェクトの「DynamicIsland」クロージャで、私は再びビューコンテキストにアクセスして、拡張されたコンパクトリーディング、コンパクトトレーリング、および最小限のビューを作成できます。

00:13:42.000 -> 00:13:49.000
これらのプレゼンテーションのそれぞれを表すために、DynamicIslandビュービルダーを作成する必要があります。

00:13:49.000 -> 00:14:01.000
私のヒーローの冒険のために、ヒーローアバターをリーディングコンテンツに追加し、ヘルスレベルをトレーリングビューに追加します。

00:14:01.000 -> 00:14:08.000
私はまた、私のヒーローの健康レベルに基づいてダイナミックな色合いを持っています。

00:14:08.000 -> 00:14:15.000
冒険のためのコンパクトなプレゼンテーションの準備が整いました。

00:14:15.000 -> 00:14:34.000
複数のアプリがライブアクティビティを開始すると、システムはどのライブアクティビティを表示するかを選択し、それぞれの最小限のプレゼンテーションを使用して両方を表示します。1つの最小限のプレゼンテーションはダイナミックアイランドに添付され、もう1つは切り離されて表示されます。

00:14:34.000 -> 00:14:42.000
最小限のビューは、作業するスペースが非常に限られているため、最も重要な情報のみを持つ必要があります。

00:14:42.000 -> 00:14:58.000
私のライブアクティビティの最小限のビューでは、最も重要な情報はヒーローとヒーローの健康なので、アバターと健康レベルをダイナミックな色合いで表示します。

00:14:58.000 -> 00:15:05.000
このようにして、ユーザーは最小限のビューを見ることで、いつヒーローを助けるべきかを知ることができます。

00:15:05.000 -> 00:15:16.000
ユーザーがコンパクトまたは最小限のプレゼンテーションでライブアクティビティをタッチして保持すると、システムは拡張プレゼンテーションでコンテンツを表示します。

00:15:16.000 -> 00:15:18.000
私もそれを支持する必要があります。

00:15:18.000 -> 00:15:26.000
拡張されたプレゼンテーションの場合、システムは拡張されたプレゼンテーションを異なる領域に分割します。

00:15:26.000 -> 00:15:33.000
DynamicIslandビュービルダーの最初の閉鎖は、拡張されたコンテンツを表します。

00:15:33.000 -> 00:15:41.000
そのクロージャ内で、各セクションのコンテンツは、特定の位置を通過する展開された領域で定義できます。

00:15:41.000 -> 00:15:58.000
ヒーローの名前とアバターを先頭のスペースに追加し、ヒーローの統計を後続のスペースに追加し、最後にヘルスバーとイベントの説明を一番下のスペースに追加します。

00:15:58.000 -> 00:16:06.000
結局、私のダイナミックアイランドUIはシンプルに見え、冒険に必要なすべての情報を提供します。

00:16:06.000 -> 00:16:16.000
今、私はお気に入りのヒーローと一緒に冒険に行き、作成したばかりのシンプルで没入感のあるライブアクティビティUIに従う準備ができています。

00:16:16.000 -> 00:16:24.000
独自のUIを設計しながら、ライブアクティビティで最も重要なコンテンツのみを表示します。

00:16:24.000 -> 00:16:32.000
ユーザーがライブアクティビティをタップすると、シンプルに保ち、アプリに追加の詳細を表示します。

00:16:32.000 -> 00:16:38.000
詳細については、「デザインダイナミックライブアクティビティ」をご覧ください。

00:16:38.000 -> 00:16:46.000
ライブアクティビティを強力なツールとして使用して、進行中のアクティビティの glanceableとライブ情報を表示します。

00:16:46.000 -> 00:16:54.000
シンプルな設定で、iOSとiPadOSでユーザーとやり取りするダイナミックな方法を作成します。

00:16:54.000 -> 00:17:05.000
アップデートのプッシュの詳細については、「プッシュ通知でライブアクティビティを更新する」をチェックしてください。ActivityKitで何を構築するかを見るのが待ちきれません。

00:17:05.000 -> 00:17:07.000
見てくれてありがとう!

00:17:07.000 -> 23:59:59.000
♪ ♪

