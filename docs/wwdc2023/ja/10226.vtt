WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:12.000
ネイサン：みなさん、こんにちは。私の名前はネイサンです。

00:00:12.000 --> 00:00:15.000
そして、私はXcode Debugger UIチームのエンジニアです。

00:00:15.000 --> 00:00:21.000
今日は、Xcode 15に登場する真新しいデバッグコンソールを紹介できることを嬉しく思います。

00:00:21.000 --> 00:00:25.000
このセッションでは、デバッグコンソールをすぐにご案内します。

00:00:25.000 --> 00:00:32.000
次に、自分のアプリケーションで実際のバグを診断することで、デバッグコンソールがどれほど有用であるかを示します。

00:00:32.000 --> 00:00:36.000
次に、LLDBにいくつかの改善点を紹介します。

00:00:36.000 --> 00:00:45.000
そして最後に、AppleのUnified Logging APIを活用して診断体験を向上させる方法についてのヒントを共有します。

00:00:45.000 --> 00:00:49.000
掘り下げて、デバッグコンソールの新機能を見てみましょう。

00:00:49.000 --> 00:00:51.000
私のデバイスで、Backyard Birdsアプリを起動しました。

00:00:51.000 --> 00:00:57.000
このアプリを使用すると、ユーザーは裏庭を管理し、仮想鳥の世話をすることができます。

00:00:57.000 --> 00:01:02.000
アプリケーションを起動した後、デバッグコンソールに多くのログが入力されました。

00:01:02.000 --> 00:01:08.000
すぐに、コンソールが私が慣れているメタデータを各ログの前に付けていないことに気づきました。

00:01:08.000 --> 00:01:13.000
代わりに、注意は開発者が私に表示することを意図した根本的なメッセージに焦点を当てています。

00:01:13.000 --> 00:01:26.000
もちろん、これらのログに関連する追加情報を表示したい場合がありますので、デバッグコンソールの左下にあるメタデータオプションボタンを選択し、現在のニーズに最適なタイプを選択することで、これを表示する機能を提供します。

00:01:26.000 --> 00:01:33.000
この場合、タイプ、ライブラリ、サブシステム、カテゴリを選択します。

00:01:33.000 --> 00:01:42.000
これを有効にすると、メタデータはコンソールの各ログの下に配置され、意図した出力から奪わないように、より小さく、より微妙になります。

00:01:42.000 --> 00:01:45.000
私はまた、黄色または赤の背景を持つログに出くわすかもしれません。

00:01:45.000 --> 00:01:52.000
これは、これらのログがより重要であり、それぞれエラーと障害を表していることを示しています。

00:01:52.000 --> 00:02:03.000
すべてのログのメタデータを同時に見たくない場合は、コンソールで問題のログを選択し、スペースを押してすばやく確認することで、単一のログのメタデータを検査できます。

00:02:03.000 --> 00:02:07.000
これにより、利用可能なすべてのメタデータを提供するポップアップウィンドウが表示されます。

00:02:07.000 --> 00:02:14.000
これには、最初にログを発行した関数の名前が表示されるコールサイトなどの情報も含まれます。

00:02:14.000 --> 00:02:21.000
この追加のメタデータを見ることは素晴らしいことですが、新しいデバッグコンソールが本当に輝いているのは、そのフィルタリング機能です。

00:02:21.000 --> 00:02:28.000
コンソールが私が気にしないログでいっぱいになるのは簡単ですが、Xcode 15では、それらをフィルタリングすることがこれまで以上に簡単です。

00:02:28.000 --> 00:02:35.000
これで、コンソールは複雑でトークン化されたフィルタリングを実行して、私のニーズに最も関連性の高いログを簡単に見つけることができます。

00:02:35.000 --> 00:02:40.000
コンソールには、これらのフィルターを作成するさまざまな方法もあります。

00:02:40.000 --> 00:02:46.000
もちろん、フィルターはこのようにフィルターバーに直接入力できます。

00:02:46.000 --> 00:02:55.000
そうしている間、オートコンプリートポップオーバーが表示され、入力しようとしているフィルターの作成を支援します。

00:02:55.000 --> 00:03:05.000
さらに、フィルターメニューでは、特定の種類のログのフィルターにすばやくアクセスできるため、表示したいタイプを選択できます。

00:03:05.000 --> 00:03:20.000
そして最後に、多かれ少なかれ興味のあるログをセカンダリクリックすると、コンソールは、このようなビューから特定のログセットにすばやく集中または除外するために、同様のログを非表示にして表示するオプションを提供します。

00:03:20.000 --> 00:03:29.000
これらのフィルタリング方法はすべて、私が持っているすべての出力を迅速かつ効率的にカットすることを可能にし、現在のデバッグニーズに最も関連性の高いログを見つけることができます。

00:03:29.000 --> 00:03:35.000
では、新しいデバッグコンソールを使用して、私のアプリケーションの実際の問題を見つけて修正しましょう。

00:03:35.000 --> 00:03:42.000
一部のユーザーがプロフィールを更新した後、コンテンツが保存されていないように見えることに気づいたという報告を受けました。

00:03:42.000 --> 00:03:51.000
優れたロギングプラクティスと新しいデバッグコンソールからの少しの助けを利用して、このバグの原因を迅速かつ簡単に特定する方法を発見しましょう。

00:03:51.000 --> 00:03:56.000
まず、タブバーの[アカウント]を選択して、問題を再現してみます。

00:03:56.000 --> 00:04:02.000
鉛筆を選択してアカウントを編集します。

00:04:02.000 --> 00:04:08.000
最後に、表示名を変更してみます。

00:04:08.000 --> 00:04:16.000
この後、うまくいったようですが、ページを終了してアカウントを確認すると、変更が失われるようです。

00:04:16.000 --> 00:04:25.000
さて、うまくいかなかったかもしれないいくつかのことが頭に浮かびますが、新しいデバッグコンソールがこの問題の根源を見つけるためにこれを絞り込むのにどのように役立つかを探りましょう。

00:04:25.000 --> 00:04:29.000
これらの手順を実行している間、デバッグコンソールで大量の出力が生成されました。

00:04:29.000 --> 00:04:36.000
ありがたいことに、新しいコンソールでは、私が最も興味を持っているものを見つけるためにフィルターを設定できるので、あまりにも多くのログを見つけることは常に素晴らしいことです。

00:04:36.000 --> 00:04:39.000
この場合、アカウント管理のみに特化したカテゴリがいくつかあります。

00:04:39.000 --> 00:04:49.000
これらに焦点を当てるために、フィルターフィールドに入力し、ポップアップからカテゴリフィルターを選択して、「アカウント」を含むプロジェクト内のすべてのカテゴリをフィルタリングします。

00:04:49.000 --> 00:04:54.000
これにより、私のコードのアカウント関連の部分からすべてのログが残ります。

00:04:54.000 --> 00:04:58.000
このフィルターセットを使用すると、出力ははるかに管理しやすくなります。

00:04:58.000 --> 00:05:03.000
これらのログのいくつかは、私が「displayName」プロパティを設定するように要求したことを示しているようです。

00:05:03.000 --> 00:05:07.000
私のアプリが期待どおりに機能しなかった理由を見つけるために、より深く調査しましょう。

00:05:07.000 --> 00:05:18.000
さて、このコードがどこにあるのか正確に思い出せないので、ログにカーソルを合わせることで、私はより興味があり、右下隅のソースの場所を選択します...

00:05:18.000 --> 00:05:24.000
Xcodeはログのソースにジャンプし、この場合、表示名を設定するように要求しました。

00:05:24.000 --> 00:05:31.000
ソースコードを確認した後、現在のアカウントのsetDisplayName関数を呼び出すと、実際にこの操作を実行するようです。

00:05:31.000 --> 00:05:38.000
この問題をより深く調査するために、アカウント情報の更新を担当する機能に飛び込みましょう。

00:05:38.000 --> 00:05:47.000
このコードをさらに確認したところ、これらの変更を中央アカウントデータベースに送信している間に、ローカルアカウントのキャッシュを更新するのを忘れてしまったようです。

00:05:47.000 --> 00:05:56.000
データベースを更新した後、このようにローカル表示名を新しいものに設定する必要があります。

00:05:56.000 --> 00:05:59.000
その間、メールアドレスに同じバグがあることに気づきました。

00:05:59.000 --> 00:06:08.000
ありがたいことに、これは同じように修正できます。

00:06:08.000 --> 00:06:18.000
それでは、ライン上のブレークポイントを設定して、私の疑いを確認し、これが私の問題を解決したことを確認しましょう。

00:06:18.000 --> 00:06:24.000
次に、アプリケーションを再構築し、この場所で一時停止する前の手順を再作成します。

00:06:24.000 --> 00:06:28.000
この場所に着いた後、私の疑いが正しいことを確認したい。

00:06:28.000 --> 00:06:40.000
これを行うには、アカウントの現在の状態を「po」し、期待している古いデータを取得することを確認します。

00:06:40.000 --> 00:06:44.000
ああ、いや。私はこのオブジェクトのアドレスしか取得していないようです。

00:06:44.000 --> 00:06:45.000
さて、それはなぜですか?

00:06:45.000 --> 00:06:55.000
「Po」は非常に一般的ですが、このクラスの独自のカスタムデバッグ記述を宣言していないため、実行したい式のタイプではないことが判明しました。

00:06:55.000 --> 00:07:03.000
実際、この場合、私はただ「p」を実行したいので、今それをさせてください。

00:07:03.000 --> 00:07:10.000
さて、これは私が望んでいたものであり、これはデータベースを更新することによって表示名が単独で設定されていないという私の疑いを確認します。

00:07:10.000 --> 00:07:20.000
追加した行を越え、表示名が更新されたことを確認しましょう。

00:07:20.000 --> 00:07:22.000
完璧--私のアップデートでこの問題を解決したようです。

00:07:22.000 --> 00:07:25.000
今、私は鳥に餌をやることに戻ることができます。

00:07:25.000 --> 00:07:33.000
それでは、Xcode 15内のLLDBに「ステップイン」して、最も単純なLLDB式をさらに良くしましょう。

00:07:33.000 --> 00:07:38.000
そのバグを解決していたときを思い出すと、私はそれが正しくない場所で「po」を使用していることに気づきました。

00:07:38.000 --> 00:07:48.000
せいぜい、これは式の実行に時間がかかることがありますが、最悪の場合、CustomStringConvertibleを実装していないときに、単にプロパティのアドレスを返すことができます。

00:07:48.000 --> 00:07:52.000
これは私をイライラさせ、より良い選択肢があればいいのにと思います。

00:07:52.000 --> 00:07:57.000
その後、プロパティで「p」を実行し、正しい結果が得られました。

00:07:57.000 --> 00:08:05.000
しかし、「式」、「v」、「vo」、「フレーム変数」など、覚えておく必要があるかもしれない他の多くのコマンドがあります。

00:08:05.000 --> 00:08:11.000
これは難しい場合がありますので、開発者を支援するために、Do What I Mean Printを導入しています。

00:08:11.000 --> 00:08:22.000
Do What I Mean Printを使用すると、1つのコマンドを使用してコード内の多くの異なる式を評価し、可能な限り最速の方法で結果を返すことで時間を節約できます。

00:08:22.000 --> 00:08:27.000
もちろん、変数を調べるたびにこの長いコマンドを入力したくありません。 変数を調べるたびにこの長いコマンドを入力する必要があります。

00:08:27.000 --> 00:08:32.000
したがって、以前の「p」エイリアスを置き換えて、Do What I Mean Printを実行しました。

00:08:32.000 --> 00:08:37.000
これにより、ほとんどのユースケースで「p」を実行するだけです。

00:08:37.000 --> 00:08:45.000
さらに、実際に変数のカスタムオブジェクト記述を印刷したい場合は、オプションのオブジェクト記述フラグを使用してDo What I Mean Printコマンドを実行できます。

00:08:45.000 --> 00:08:53.000
ただし、以前の「po」エイリアスを置き換えて、Do What I Mean Printをカスタムオブジェクトの説明で実行しました。

00:08:53.000 --> 00:09:03.000
新しいDo What I Mean Print関数を使用することで、以前は、可能な限り最速の方法で意図した出力を取得するために複数の異なるコマンドを必要とする多くの異なる式に対して2つのコマンドのいずれかを実行できるようになりました。

00:09:03.000 --> 00:09:18.000
最後に、誰もがロギングを最大限に活用できるようにする方法を確認しましょう。したがって、デバッグエクスペリエンスを向上させ、再作成が難しい問題や、ユーザーが受信したレポートに依存する可能性のある問題をより効果的に見つけて解決できるようにします。

00:09:18.000 --> 00:09:25.000
まず、標準のI/OはコマンドラインUI用で、OSLogはデバッグ用であることを皆さんに思い出させます。

00:09:25.000 --> 00:09:29.000
したがって、プログラムの実行中のイベントをログに記録するために「印刷」を使用することはめったにありません。

00:09:29.000 --> 00:09:37.000
OSLogを使用して、エンドユーザーから構造化ロギングを取得し、デバッグコンソールで構造を保持する方がはるかに良いです。

00:09:37.000 --> 00:09:43.000
それでは、標準I/OからOSLogへの変換がいかに簡単かを示すいくつかの例を見ていきましょう。

00:09:43.000 --> 00:09:47.000
これは、追加のロギングを追加したいシンプルな機能です。

00:09:47.000 --> 00:09:52.000
実行されているタスクと、それらのタスクを実行した結果を記録するのは良い習慣です。

00:09:52.000 --> 00:09:56.000
私が知っている最善の方法でこれを追加するために少し時間を取らせてください。

00:09:56.000 --> 00:10:01.000
素晴らしい--私は今、このコードに従うのを助けるためにいくつかの簡単な「印刷」ステートメントを追加しました。

00:10:01.000 --> 00:10:07.000
私は今、この機能で行っているアクションを印刷し、タスクが結果で完了したときに印刷しています。

00:10:07.000 --> 00:10:13.000
しかし、私のプロジェクト内のより多くの場所にこれをした後、この出力のすべてがどこから来ているのかを見つけるのが難しくなりました。

00:10:13.000 --> 00:10:18.000
これにより、多くの人が必要としていたように、私のプリントにマーカーを追加し始めました。

00:10:18.000 --> 00:10:20.000
しかし、これは手に負えなくなっているように感じます。

00:10:20.000 --> 00:10:24.000
この追加出力をすべて追加した後、それは私のコンソールをさらに乱雑にしました。

00:10:24.000 --> 00:10:29.000
余分な作業なしで、このメタデータをすべて取得するためのより良い方法があればいいのにと思います。

00:10:29.000 --> 00:10:32.000
さて、OSLogは私が必要とすることをすることがわかりました。

00:10:32.000 --> 00:10:36.000
さて、この機能をアップデートして、Unified Loggingを活用したいと思います。

00:10:36.000 --> 00:10:43.000
開始するには、まずOSLogをプロジェクトにインポートしてから、ログハンドルを作成できるようにする必要があります。

00:10:43.000 --> 00:10:48.000
これは、ログが表現するサブシステムとカテゴリを指定する場所です。

00:10:48.000 --> 00:10:57.000
これらは、デバッグフィルタリングを容易にする任意の文字列にすることができますが、サブシステムとカテゴリのクラスまたはコンポーネント名にバンドル識別子を使用するのが一般的です。

00:10:57.000 --> 00:11:07.000
ロガーを作成したら、ロガーオブジェクトで提供された関数を呼び出すだけで、ログのレベルを指定し、表示したいメッセージが表示されます。

00:11:07.000 --> 00:11:11.000
これにより、読み取りがはるかに良くなり、長期的にはコードが大幅に少なくなります。

00:11:11.000 --> 00:11:16.000
今、私がそれを実行するとき、これがコンソールでどのように見えるかを見てみましょう。

00:11:16.000 --> 00:11:22.000
このために、これらのログの2つを分離して、このすべてのメタデータがどこから来るのかを検査できるようにしましょう。

00:11:22.000 --> 00:11:31.000
ログ出力では、有効になっている場合、そのすぐ下のログに指定した追加のメタデータで出力するつもりだったメッセージが見つかります。

00:11:31.000 --> 00:11:37.000
このメタデータの一部は、メッセージやレベルなど、最初のログを書いた場所から収集されます。

00:11:37.000 --> 00:11:43.000
その他は、サブシステムやカテゴリなど、繰り返しを保存するためにログハンドルを作成したときから収集されます。

00:11:43.000 --> 00:11:44.000
そして、いくつかはバックグラウンドで処理されます。

00:11:44.000 --> 00:11:50.000
これらには、タイムスタンプ、ライブラリ名、プロセスID、スレッドID、ソースの場所などが含まれます。

00:11:50.000 --> 00:11:58.000
この情報はすべて、必要なときに大いに役立ちますが、ニーズに関係なく、すべてのログに印刷すると大量のスペースがかかります。

00:11:58.000 --> 00:12:04.000
ありがたいことに、新しいデバッグコンソールでは、そのビューをカスタマイズして、あなたが望むものだけを提供することができます。

00:12:04.000 --> 00:12:10.000
最後に、ロギングを最大限に活用するには、アプリケーションを構築する際にこれを考慮してください。

00:12:10.000 --> 00:12:24.000
まず、アプリケーションのさまざまなコンポーネントに対して常に別々のログハンドルを作成する必要があります。したがって、基礎となるメタデータに意味のある検索用語を設定して、アプリケーションのセクションに最も関連性の高いログをより迅速に見つけることができます。

00:12:24.000 --> 00:12:32.000
また、OSLogStoreを利用して、現場でアプリケーションに問題が発生した場合に貴重な診断を収集します。

00:12:32.000 --> 00:12:35.000
そして最後に、OSLogは追跡施設であることを覚えておいてください。

00:12:35.000 --> 00:12:42.000
これは、Instrumentsなどのツールを使用して、アプリケーションの複雑なパフォーマンス分析を提供できることを意味します。

00:12:42.000 --> 00:12:50.000
この例では、ロギングプロファイリングテンプレートを使用して、OSLogとサインポストを使用してアプリケーションのパフォーマンスを分析しています。

00:12:50.000 --> 00:12:56.000
さて、先ほど調べたことと、あなた自身のプログラミング体験を向上させるために何ができるかをまとめましょう。

00:12:56.000 --> 00:13:04.000
まず、Xcode 15の新しいデバッグコンソールを探索する必要があります。そこでは、すべてのロギングニーズに多くの改善を提供しました。

00:13:04.000 --> 00:13:12.000
次に、コードを標準のI/OからOSLogに移行し、新しいデバッグコンソールが提供するすべての新機能を提供する必要があります。

00:13:12.000 --> 00:13:21.000
次に、LLDBの新しいDo What I Mean Printまたは「p」コマンドを試して、最初に可変検査を実行するときに必ずこれを使用してください。

00:13:21.000 --> 00:13:32.000
そして最後に、AppleのUnified Logging APIの詳細については、以前のセッション「ロギングを使用したパフォーマンスの測定」と「Swiftでのログインを探る」をご覧ください。

00:13:32.000 --> 23:59:59.000
幸せなロギング、そして見てくれてありがとう。

