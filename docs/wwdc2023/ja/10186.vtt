WEBVTT

00:00:00.000 --> 00:00:11.000
♪ ♪

00:00:11.000 --> 00:00:19.000
David: こんにちは、「コアデータの新機能」へようこそ。私の名前はDavid Stitesで、Core Dataチームのエンジニアです。

00:00:19.000 --> 00:00:33.000
このセッションでは、アプリでCore Dataデータモデルをより迅速かつ簡単に設計、クエリ、更新、移行するのに役立つCore Dataの新技術について学びます。

00:00:33.000 --> 00:00:56.000
まず、アプリのモデルで構造化データを整理する素晴らしい新しい方法である複合属性について話してから、最も複雑なモデル移行を「ステージング」して軽量移行を使用できるようにする方法について話し、アプリの応答性を維持するためにモデルの移行を延期する方法で締めくくります。

00:00:56.000 --> 00:01:01.000
複合属性は新しいタイプの属性です。

00:01:01.000 --> 00:01:10.000
複合属性は、単一の属性内の複雑なカスタムデータ型をカプセル化できます。

00:01:10.000 --> 00:01:23.000
各複合属性は、String、Float、Int、Dataなど、すでに慣れ親しんでいる組み込みコアデータタイプの属性で構成されています。

00:01:23.000 --> 00:01:34.000
複合属性は互いにネストされる可能性があるため、トップレベルの複合属性には追加の複合属性を含めることができます。

00:01:34.000 --> 00:01:46.000
Xcode Core Dataモデルエディタが更新され、モデルの複合属性の定義と管理が容易になりました。

00:01:46.000 --> 00:01:55.000
複合属性は、変換可能な型属性を使用して耐久性のあるカスタムデータ型を作成するための魅力的な代替手段です。

00:01:55.000 --> 00:02:00.000
属性の値を変換するコードを書く必要はありません。

00:02:00.000 --> 00:02:13.000
変換可能な属性とは異なり、複合属性は、複合属性の名前空間キーパスで設定されたNSPredicatesを持つNSFetchRequestsを許可します。

00:02:13.000 --> 00:02:25.000
複合属性を使用して、平坦化された属性の増殖をカプセル化し、より保守的で読みやすいコードにつながります。

00:02:25.000 --> 00:02:29.000
複合属性は、アプリのパフォーマンスを向上させるために使用できます。

00:02:29.000 --> 00:02:43.000
データモデルが、1つのエンティティを取得すると、ほとんどの場合、別のエンティティへの関係にアクセスできるように構成されている場合、その関係を複合属性を使用してリファクタリングできます。

00:02:43.000 --> 00:02:53.000
最初のエンティティに複合属性を埋め込む効果は、関係全体のオブジェクトのフォールトを防ぐことです。

00:02:53.000 --> 00:02:59.000
複合属性クラスはNSCompositeAttributeDescriptionです。

00:02:59.000 --> 00:03:07.000
NSCompositeAttributeDescriptionの属性タイプはNSCompositeAttributeTypeです。

00:03:07.000 --> 00:03:20.000
NSCompositeAttributeDescriptionクラスには、NSAttributeDescriptionまたは他のネストされたNSCompositeAttributeDescriptionで構成される配列、要素が含まれています。

00:03:20.000 --> 00:03:28.000
要素配列には、NSRelationshipDescriptionなど、他のタイプのプロパティ記述を含めることはできません。

00:03:28.000 --> 00:03:36.000
無効な要素を設定しようとすると、NSInvalidArgumentExceptionが発生します。

00:03:36.000 --> 00:03:43.000
デモで複合属性を採用する方法を説明します。

00:03:43.000 --> 00:03:46.000
航空機エンティティで、この基本的なデータモデルを検討してください。

00:03:46.000 --> 00:03:53.000
変換可能なタイプであるcolors属性を含む多くの属性があります。

00:03:53.000 --> 00:04:04.000
そのタイプのトランスフォーマーは、航空機の一次色、二次色、三次色を記述するフォーマットされた文字列を格納し、解析します。

00:04:04.000 --> 00:04:14.000
航空機のペイントカラーを保存するために、colors属性を複合属性colorSchemeに置き換えることで、このエンティティを改善します。

00:04:14.000 --> 00:04:25.000
colorSchemeは、プライマリ、セカンダリ、三次の要素を持つ複合属性で、それぞれが文字列属性です。

00:04:25.000 --> 00:04:33.000
Xcodeで、飛行時間を追跡するために使用するアプリであるプロジェクトを開きます。

00:04:33.000 --> 00:04:42.000
そのアプリのデータモデルは、先ほど話した航空機エンティティと、他のいくつかのエンティティで構成されています。

00:04:42.000 --> 00:04:51.000
変換を開始するには、Core Dataモデルエディタで、colorSchemeという名前の新しい複合属性を追加します。

00:04:51.000 --> 00:05:12.000
そのコンポジットの中に、一次、二次、三次の3つの文字列属性を追加します。

00:05:12.000 --> 00:05:34.000
航空機エンティティでは、複合属性を追加し、その属性のタイプをcolorSchemeに設定します。

00:05:34.000 --> 00:05:40.000
モデルの作業が完了し、コードを更新する時が来ました。

00:05:40.000 --> 00:05:52.000
私の航空機の実装では、新しいプロパティ、@NSManaged var colorSchemeを追加しています。そのタイプはStringキーとAnyオブジェクトを持つ辞書です。

00:05:52.000 --> 00:06:02.000
コード全体でこの複合属性を使用するため、属性の名前をキーとして辞書表記を使用して値にアクセスしています。

00:06:02.000 --> 00:06:13.000
ここでは、プライマリ、セカンダリ、および三次のストリングキーを使用して、航空機のcolorScheme属性を設定しています。

00:06:13.000 --> 00:06:24.000
同様に、NSPredicateでNSFetchRequestを設定すると、複合属性の要素は名前空間のキーパスを介してアクセスされます。

00:06:24.000 --> 00:06:31.000
ここでは、colorScheme.primaryがその属性をフィルタリングするために使用されます。

00:06:31.000 --> 00:06:37.000
アプリケーションが進化するにつれて、データモデルを変更する必要があるかもしれません。

00:06:37.000 --> 00:06:46.000
データモデルを更新するには、これらの変更が基礎となるストレージスキーマで具体化される必要があります。

00:06:46.000 --> 00:06:55.000
numPassengers属性がモデルに追加された場合は、対応するストレージを更新する必要があります。

00:06:55.000 --> 00:07:01.000
スキーマの変更を実行するプロセスは移行と呼ばれます。

00:07:01.000 --> 00:07:08.000
移行後、変更は基盤となるストレージに完全に反映されます。

00:07:08.000 --> 00:07:15.000
Core Dataには、現在のデータモデルでアプリのデータストレージを最新の状態に保つのに役立つ移行ツールセットが組み込まれています。

00:07:15.000 --> 00:07:29.000
総称して、これらのツールは「軽量移行」と呼ばれます。軽量移行の詳細については、WWDC 2022の「アプリのスキーマを進化させる」をご覧ください。

00:07:29.000 --> 00:07:36.000
場合によっては、データモデルへの複合変更は、軽量移行の機能を超えています。

00:07:36.000 --> 00:07:40.000
この問題の解決策は、段階的な移行です。

00:07:40.000 --> 00:08:12.000
段階的な移行APIは、いくつかの目標を念頭に置いて設計されました。不適合の軽量スキーマ変更を持つ複雑なデータモデルを移行し、移行と移行インフラストラクチャに関連する数千行のコードを削除してアプリを簡素化し、移行プロセス中にアプリが実行制御を獲得してさまざまなタスクを実行する機会を提供します。

00:08:12.000 --> 00:08:56.000
このAPIを使用するには、いくつかの手順を踏む必要があります。モデルへの変更が軽量移行でサポートされている操作に準拠していないかどうかを判断し、不適合モデル変更を軽量移行でサポートされている一連の適合モデル変更に分解し、新しい段階的な移行APIを使用してNSManagedObjectModelのコアデータへの総順序を説明し、Core Dataに各未処理モデルをシリアルオーダーで反復的にステップするイベント

00:08:56.000 --> 00:09:07.000
移行中の特定の時点で、その移行に関連する必要なタスクを実行するために、実行制御がアプリに与えられます。

00:09:07.000 --> 00:09:14.000
モデルに不適合の軽量変更がある場合を判断するには、いくつかのオプションがあります。

00:09:14.000 --> 00:09:23.000
最初のオプションは、スキーマの変更を手動で確認し、各変更が軽量移行の対象となることを確認することです。

00:09:23.000 --> 00:09:39.000
2番目のオプションは、新しいモデルと軽量移行オプション、NSMigratePersistentStores AutomaticallyOptionとNSInferMappingModelAutomaticallyOptionをtrueに設定して永続ストアを開くことです。

00:09:39.000 --> 00:09:48.000
変更が軽量適格でない場合、NSPersistentStore IncompatibleVersionHashErrorが表示されます。

00:09:48.000 --> 00:09:57.000
最後のオプションは、NSMappingModel.inferredMappingModel(forSourceModel:destinationModel:)を使用することです。

00:09:57.000 --> 00:10:01.000
このメソッドは、Core Dataが作成できた場合、推論されたモデルを返します。

00:10:01.000 --> 00:10:05.000
それ以外の場合は、nilを返します。

00:10:05.000 --> 00:10:14.000
航空機モデルを再度考えると、データをバイナリ形式で保存する新しい属性であるflightDataがあります。

00:10:14.000 --> 00:10:26.000
既存のデータとそれが生成された航空機との関係を維持しながら、このモデルを非正規化し、すべての飛行データを独自のエンティティタイプに分離する必要があるとします。

00:10:26.000 --> 00:10:33.000
これは非常に複雑なモデル変更であり、それ自体では軽量移行の対象にはなりません。

00:10:33.000 --> 00:10:38.000
これらの変更は、段階的な移行を使用するために分解する必要があります。

00:10:38.000 --> 00:10:54.000
非軽量の変更を分解する場合、目標は、軽量移行の対象とならない移行タスクを、軽量移行の対象となる最小限の一連の移行に変換することです。

00:10:54.000 --> 00:11:06.000
導入された各モデルには、不適合な変更を構成する軽量移行の機能の範囲内にある1つ以上の操作があります。

00:11:06.000 --> 00:11:18.000
その結果、各モデルが軽量で移行可能ですが、不適合の移行と同等の一連の移行が発生します。

00:11:18.000 --> 00:11:24.000
例に戻ると、元のモデルModelV1にラベルを付けました。

00:11:24.000 --> 00:11:34.000
このモデルの移行は、ModelV2とModelV3の2つの新しいモデルバージョンを導入することで分解されます。

00:11:34.000 --> 00:11:44.000
ModelV2では、航空機エンティティは、新しく作成されたFlightDataエンティティのコレクションであるflightParametersと呼ばれる関係を取得します。

00:11:44.000 --> 00:11:52.000
FlightDataエンティティには、バイナリタイプの属性データと航空機との関係があります。

00:11:52.000 --> 00:12:06.000
既存のデータを保存するために、移行段階では、航空機エンティティからデータを新しいFlightDataエンティティにコピーし、航空機に関連付けます。

00:12:06.000 --> 00:12:12.000
私たちの最終モデルは、ModelV2から作成されたModelV3です。

00:12:12.000 --> 00:12:24.000
ModelV3では、古いflightData属性が航空機エンティティから削除され、モデルが正常に非正規化され、既存のデータがすべて保存されます。

00:12:24.000 --> 00:12:30.000
説明されている各ステップは、軽量移行の機能の範囲内です。

00:12:30.000 --> 00:12:53.000
モデルの総順序を記述するために、Core Dataフレームワークレベルのサポートは、NSStagedMigrationManager、NSCustomMigrationStage、NSLightweightMigrationStage、およびNSManagedObjectModelReferenceのクラスで構成されています。

00:12:53.000 --> 00:13:09.000
NSStagedMigrationManagerクラスは、NSCustomMigrationStageとあなたが説明した補足NSLightweightMigrationStageの合計順序をカプセル化します。

00:13:09.000 --> 00:13:19.000
段階的な移行マネージャーはまた、移行イベントループを管理し、NSPersistentContainerを介して移行ストアへのアクセスを提供します。

00:13:19.000 --> 00:13:32.000
マネージャーは、キーNSPersistentStoreStagedMigrationManager OptionKeyを使用してストアオプションに追加されます。

00:13:32.000 --> 00:13:40.000
移行段階は、モデルのバージョン間で移行するための基礎を形成します。

00:13:40.000 --> 00:13:53.000
段階的な移行を採用すると、NSCustomMigrationStageまたはNSLightweightMigrationStageのいずれかを使用して、各モデルバージョンをコアデータに記述します。

00:13:53.000 --> 00:14:04.000
NSLightweightMigrationStageクラスは、分解を必要とせず、軽量移行の対象となる一連のモデルについて説明しています。

00:14:04.000 --> 00:14:08.000
これはおそらくあなたのモデルの大半になるでしょう。

00:14:08.000 --> 00:14:16.000
これらの軽量移行段階は、コアデータに記述されたモデルの総順序を補完するために使用されます。

00:14:16.000 --> 00:14:25.000
すべての軽量モデルバージョンは、1つ以上のNSLightweightMigrationStageで表現する必要があります。

00:14:25.000 --> 00:14:39.000
作成したモデルの分解された各バージョンは、NSCustomMigrationStageを使用して表現され、ソースモデル参照と宛先モデル参照が含まれます。

00:14:39.000 --> 00:14:47.000
NSCustomMigrationStageは、移行段階の直前と直後に実行されるオプションのハンドラを提供します。

00:14:47.000 --> 00:14:54.000
これらのハンドラを使用すると、移行プロセス中にカスタムコードを実行できます。

00:14:54.000 --> 00:15:00.000
段階的な移行は、NSManagedObjectModelReferenceクラスを利用します。

00:15:00.000 --> 00:15:06.000
このクラスは、NSManagedObjectModelの約束を表します。

00:15:06.000 --> 00:15:10.000
移行中、コアデータはこの約束を果たします。

00:15:10.000 --> 00:15:20.000
NSManagedObjectModelReferenceは柔軟性があり、さまざまな方法で作成できます。

00:15:20.000 --> 00:15:26.000
すべてのNSManagedObjectModelReferenceは、バージョンチェックサムで初期化する必要があります。

00:15:26.000 --> 00:15:31.000
これは、モデルが誤って変更されていないことを検証するためのものです。

00:15:31.000 --> 00:15:39.000
チェックサムは、NSManagedObjectModel .versionChecksumメソッドを使用して取得できます。

00:15:39.000 --> 00:16:01.000
または、「データモデルのコンパイル」の下にあるXcodeビルドログからバージョンのチェックサムを取得することもできます。「バージョンチェックサム」という文字列を検索します。バージョン管理されたモデルの場合、チェックサムはNSManagedObjectModelバンドルのVersionInfo.plistでも利用できます。

00:16:01.000 --> 00:16:10.000
例に戻ると、段階的な移行の使用を開始するには、3つのモデルのそれぞれにモデル参照を作成することから始めます。

00:16:10.000 --> 00:16:19.000
モデル名とバンドル参照を受け入れるイニシャライザを使用していますが、他のオプションもあります。

00:16:19.000 --> 00:16:24.000
次のステップは、必要な移行段階を説明することです。

00:16:24.000 --> 00:16:35.000
最初のステージではflightData属性のみが追加されたので、属性の追加は軽量な変更であるため、軽量ステージで表現できます。

00:16:35.000 --> 00:16:47.000
ただし、モデルの変更が2つのモデルバージョンに分解され、既存のデータを保存するためにカスタムコードを実行する必要があるため、次の段階はカスタム段階になります。

00:16:47.000 --> 00:16:56.000
カスタム移行ステージは、ModelV2とModelV3で初期化されます。

00:16:56.000 --> 00:17:02.000
willMigrateHandlerでは、コードはflightDataがnilではないエンティティ行を取得します。

00:17:02.000 --> 00:17:21.000
移行中に航空機クラスが期待どおりに存在しない可能性があるため、航空機管理オブジェクトサブクラスの代わりに、一般的なNSManagedObjectおよびNSFetchRequestResultタイプが使用されています。

00:17:21.000 --> 00:17:31.000
フェッチされた航空機エンティティごとに、データはFlightDataの新しいインスタンスにコピーされ、2つのエンティティは関連付けられ、永続化されます。

00:17:31.000 --> 00:17:41.000
この移行段階の実行終了時に、ストアスキーマが最新のモデルに更新され、既存のデータが保存されます。

00:17:41.000 --> 00:17:53.000
段階的な移行を完了するには、軽量移行ステージとカスタム移行ステージを備えたNSStagedMigrationManagerを作成します。

00:17:53.000 --> 00:18:06.000
NSStagedMigrationManagerは、キーNSPersistentStore StagedMigrationManagerOptionKeyを使用してNSPersistentStoreDescriptionオプションに追加されます。

00:18:06.000 --> 00:18:12.000
その後、永続ストアがロードされ、移行プロセスが開始され、ストアスキーマに影響します。

00:18:12.000 --> 00:18:14.000
そして、それだけです。

00:18:14.000 --> 00:18:21.000
コアデータは自動的に必要なステージを適用し、ストアスキーマを移行します。

00:18:21.000 --> 00:18:31.000
一部の軽量移行では、アプリがフォアグラウンドで提供できない可能性のある追加のランタイムが必要です。

00:18:31.000 --> 00:18:38.000
軽量移行中にユーザーデータを変換するプロセスは瞬間的ではありません。

00:18:38.000 --> 00:18:47.000
たとえば、移行に、ある列から別の列へのデータのコピー、またはあるテーブルから別のテーブルへのデータのコピーが含まれる場合、時間がかかる場合があります。

00:18:47.000 --> 00:18:56.000
これは、特に移行が起動時に行われる場合、イライラするユーザーエクスペリエンスをもたらす可能性があります。

00:18:56.000 --> 00:18:59.000
遅延移行は、この問題を解決するのに役立ちます。

00:18:59.000 --> 00:19:10.000
このAPIを使用すると、軽量移行中に行われた作業の一部を延期することができ、後日延期された作業を終了することができます。

00:19:10.000 --> 00:19:31.000
軽量移行中、エンティティにインデックスの更新やテーブルコピーを実行した後に列をドロップするなど、クリーンアップが必要な移行変換がある場合、リソースがテーブル変換を実行できると判断されるまで、このテーブル変換が遅れる可能性があります。

00:19:31.000 --> 00:19:36.000
軽量移行はまだ同期しており、正常に行われます。

00:19:36.000 --> 00:19:39.000
スキーマのクリーンアップのみが延期されます。

00:19:39.000 --> 00:19:44.000
あなたのアプリは通常通り最新のスキーマを使用します。

00:19:44.000 --> 00:19:55.000
遅延移行を選択するには、ストアオプションのNSPersistentStore DeferredLightweightMigrationOptionKeyをtrueに設定します。

00:19:55.000 --> 00:20:06.000
延期された移行APIは、macOS Big SurとiOS 14にまでさかのぼってランタイム互換性があります。

00:20:06.000 --> 00:20:13.000
遅延移行は、SQLiteストアタイプでのみ利用可能です。

00:20:13.000 --> 00:20:34.000
延期された移行が役立つ場合の例には、エンティティから属性または関係の削除、エンティティ階層がもはや存在しない関係の変更、順序付きから順序なしへの関係の変更などがあります。

00:20:34.000 --> 00:20:39.000
延期された移行タスクを完了するには、永続的なストアのメタデータを確認してください。

00:20:39.000 --> 00:20:52.000
キーNSPersistentStore DeferredLightweightMigrationOptionKeyが含まれている場合、それは完了する必要がある遅延移行作業があるというシグナルです。

00:20:52.000 --> 00:21:02.000
遅延移行は、NSPersistentStoreCoordinator .finishDeferredLightweightMigrationを呼び出すことで処理できます。

00:21:02.000 --> 00:21:16.000
アプリの軽量移行を延期するには、永続ストアをコーディネーターに追加するときに、ストアオプションでNSPersistentStoreDeferred LightweightMigrationOptionKeyをtrueに設定します。

00:21:16.000 --> 00:21:25.000
延期された移行を完了するのに良い時期になったら、ストアのメタデータをチェックして、保留中の延期された作業があるかどうかを確認できます。

00:21:25.000 --> 00:21:37.000
NSPersistentStoreDeferredLightweight MigrationOptionKey が true に設定されている場合は、finishDeferredLightweightMigration() を呼び出します。

00:21:37.000 --> 00:21:43.000
延期された移行タスクをスケジュールするには、バックグラウンドタスクAPIの使用を検討してください。

00:21:43.000 --> 00:21:51.000
BGProcessingTaskは、長いデータ更新やアプリのメンテナンスなど、時間のかかる操作を目的としています。

00:21:51.000 --> 00:21:55.000
システムは、タスクを実行するのに最適な時間を決定します。

00:21:55.000 --> 00:22:08.000
ただし、通常、処理タスクはデバイスがアイドル状態のときにのみ実行され、ユーザーがデバイスの使用を開始するとバックグラウンド処理タスクが終了します。

00:22:08.000 --> 00:22:12.000
延期された移行と段階的な移行を組み合わせることができます。

00:22:12.000 --> 00:22:22.000
時間がかかる可能性のある一連の複雑な移行がある場合は、両方のAPI機能を利用するステージの設計を検討してください。

00:22:22.000 --> 00:22:34.000
ModelV3のサンプルモデルに戻ると、属性flightDataを削除すると、これは良い遅延移行候補になるかもしれません。

00:22:34.000 --> 00:22:39.000
コアデータには3つの素晴らしい新技術があります。

00:22:39.000 --> 00:23:01.000
複合属性を使用してネスト可能な構造化された方法でカスタムデータ型をカプセル化し、モデル変更を分解して段階的な移行を使用して複雑なモデル移行を実行し、遅延移行を使用していくつかの移行作業を遅らせることでアプリのパフォーマンスをターボチャージします。

00:23:01.000 --> 00:23:06.000
3つの技術はすべて、アプリを改善するために調和して機能します。

00:23:06.000 --> 00:23:11.000
私たちのチームは、あなたがこれらの新技術をどのように使用しているかを聞いて興奮しています。

00:23:11.000 --> 00:23:15.000
見てくれてありがとう、そして素晴らしいWWDCをお過ごしください。

00:23:15.000 --> 23:59:59.000
♪ ♪

