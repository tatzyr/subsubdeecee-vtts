WEBVTT

00:00:01.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:18.000
ロバート：こんにちは、私の名前はロバート・ケンドール・クッペです。今日は、私たちが「環境制約」と呼んでいる新しいmacOS機能について話します。

00:00:18.000 --> 00:00:22.000
機能豊富なMacアプリは、多くの場合、1つのプロセスやファイル以上のものです。

00:00:22.000 --> 00:00:30.000
フレームワークとライブラリを使用すると、アプリ全体や他の開発者からコードを再利用することができます。

00:00:30.000 --> 00:00:36.000
ヘルパーツール、ヘルパーアプリ、XPCサービスを使用すると、作業を分割して攻撃面を減らすことができます。

00:00:36.000 --> 00:00:42.000
起動エージェント、起動デーモン、およびログイン項目を使用すると、バックグラウンドまたはユーザーログインで作業を行うことができます。

00:00:42.000 --> 00:00:48.000
また、アプリの拡張機能を使用すると、他のアプリで便利な機能を提供できます。

00:00:48.000 --> 00:00:51.000
しかし、あなたのアプリは潜在的に敵対的な環境で実行されます。

00:00:51.000 --> 00:00:58.000
アプリアーキテクトは、ソフトウェアと一緒に実行されている、またはフレームワークを使用して、未知のソフトウェアの潜在的な影響を考慮する必要があります。

00:00:58.000 --> 00:01:04.000
ヘルパーツールまたはXPCサービスの実行により、攻撃者はキーチェーンデータにアクセスできますか?

00:01:04.000 --> 00:01:07.000
iCloudのデータやその他の特権はどうですか？

00:01:07.000 --> 00:01:12.000
予期しないコードがプロセスに注入された場合、どうなりますか?

00:01:12.000 --> 00:01:20.000
実際の親子関係と同様に、親プロセスは子供の行動に大きな影響を与えます。

00:01:20.000 --> 00:01:27.000
macOSでは、posix_spawnのパワーは別のプロセスを与え、親は子供へのほぼすべての入力を制御する能力を与えます。

00:01:27.000 --> 00:01:32.000
親プロセスは、子のシステムリソースへのアクセスを制限することもできます。

00:01:32.000 --> 00:01:42.000
このレベルの制御により、子が予期しないコードをロードしたり、予期しない機能を実行したり、プロセスが攻撃に対してより脆弱になるような振る舞いをしたりする可能性があります。

00:01:42.000 --> 00:01:48.000
しかし、親子関係を超えて、プロセスは生成するディスクレイアウトに信頼を置きます。

00:01:48.000 --> 00:02:05.000
ディスク上のファイルを変更できる悪意のあるプロセスは、被害者プロセスに予期しないデータをフィードしたり、被害者プロセスからランタイム保護を削除したり、システム上で永続的な実行を取得したり、プロセスの権限を盗んだりできる可能性があります。

00:02:05.000 --> 00:02:09.000
これらすべての脅威に直面して、macOSはアプリを保護するためのツールを提供します。

00:02:09.000 --> 00:02:14.000
特に、アプリが侵害された場合の影響を制限するために、アプリサンドボックスを採用することができます。

00:02:14.000 --> 00:02:20.000
また、強化されたランタイムとライブラリの検証を採用して、実行時にプロセスの整合性を保護することができます。

00:02:20.000 --> 00:02:26.000
ゲートキーパーと公証は、顧客のシステムに既知の悪意のあるコードのない状態に保つのにも役立ちます。

00:02:26.000 --> 00:02:34.000
前に述べた脅威について考えると、既存の保護は実行環境ではなく実行プロセスに焦点を当てていることに気づきました。

00:02:34.000 --> 00:02:38.000
そのため、環境制約を導入しています。

00:02:38.000 --> 00:02:48.000
環境の制約により、プロセスを実行できる状況と、プロセス内でコードを混在させる方法を新しいレベルで制御できます。

00:02:48.000 --> 00:03:02.000
この講演の残りの部分では、環境制約がmacOSのセキュリティアーキテクチャにどのように適合するか、環境制約がどのように構成されているか、アプリに環境制約をどのように採用できるかについて説明します。

00:03:02.000 --> 00:03:07.000
しばらく下がって、macOSのセキュリティスタックについて話しましょう。

00:03:07.000 --> 00:03:19.000
デフォルトでは、macOSはこれらすべての技術を活用して、ブートチェーンを保護し、OSの整合性を確保し、特権分離を強制し、悪意のあるソフトウェアからユーザーを保護します。

00:03:19.000 --> 00:03:25.000
macOS Venturaでは、オペレーティングシステムプロセス間の関係をよりよく保護するために、環境制約を使用し始めました。

00:03:25.000 --> 00:03:28.000
彼らはOSにセキュリティの新しい次元を提供します。

00:03:28.000 --> 00:03:35.000
macOS Sonomaでは、環境制約の使用を拡大し、アプリで使用できるように開放しました。

00:03:35.000 --> 00:03:38.000
では、環境の制約とは何ですか?

00:03:38.000 --> 00:03:47.000
基本的に、それらはコードが何であるかだけでなく、コードがどのように存在し、システム上で実行されることが期待されるかを記述する方法です。

00:03:47.000 --> 00:03:50.000
macOSでは、さまざまな目的で環境制約を使用します。

00:03:50.000 --> 00:04:00.000
たとえば、プロセスが信頼できるバンドルリソースを使用していることを確認するために、署名されたシステムボリュームからOSプロセスを実行する必要があります。

00:04:00.000 --> 00:04:10.000
特権デーモンが予期しない引数やMachポートで実行されないようにするために、システムデーモンは保護されたlaunchd.plistに基づいてのみ実行する必要があります。

00:04:10.000 --> 00:04:23.000
システムアプリの攻撃面を減らすために、アプリケーションとしてLaunch Servicesから実行する必要があり、バックグラウンドアイテムのユーザー承認に歯があることを確認するために、環境制約を使用して変更を検出します。

00:04:23.000 --> 00:04:28.000
今、あなたは尋ねているかもしれません。「私のアプリは環境制約を採用する必要がありますか？」

00:04:28.000 --> 00:04:34.000
環境の制約は完全にオプションですが、あらゆるアプリの攻撃面を減らすことができることを強調したいと思います。

00:04:34.000 --> 00:04:38.000
この講演の後半で、より具体的なユースケースについて説明します。

00:04:38.000 --> 00:04:49.000
ただし、アプリに複数のプロセスがある場合や、異なる開発者チームによって署名されたコードがロードされている場合、環境の制約が特に役立つ可能性があることに注意してください。

00:04:49.000 --> 00:04:54.000
環境制約にはいくつかの種類があるので、まず起動制約について話しましょう。

00:04:54.000 --> 00:05:07.000
起動制約は特定のバイナリに埋め込まれ、そのプロセスのプロパティ、その親になることができるプロセスのプロパティ、またはそれを担当できるプロセスのプロパティのいずれかを定義します。

00:05:07.000 --> 00:05:14.000
これらのプロパティを「自己制約」、「親プロセス制約」、および「責任あるプロセス制約」と呼びます。

00:05:14.000 --> 00:05:18.000
3つすべてをバイナリに適用するか、最も理にかなっているものを選ぶことができます。

00:05:18.000 --> 00:05:26.000
必要なプロパティのいずれかが満たされない場合、起動制約が埋め込まれたプロセスは実行されません。

00:05:26.000 --> 00:05:32.000
それでは、いくつかのプロセス関係を見て、起動制約を使用してそれらを保護する方法について話しましょう。

00:05:32.000 --> 00:05:35.000
まず、MyDemo.appがあなたのアプリであると仮定します。

00:05:35.000 --> 00:05:41.000
MyDemo.appで自己制約を設定して、Launch Servicesからアプリケーションとして起動するように要求できます。

00:05:41.000 --> 00:05:54.000
アプリがXPCサービスへの接続を要求すると、launchdはXPCサービスを生成し、そのXPCサービスの親ですが、アプリはそのXPCサービスに「責任」があります。

00:05:54.000 --> 00:06:04.000
MyXPCDemo.xpcに責任あるプロセス制約を設定して、MyDemo.appだけが責任を負うことを示すことができます。

00:06:04.000 --> 00:06:13.000
アプリが後でNSTaskまたはposix_spawnを使用してヘルパーを起動する場合、それはそのヘルパーの親であり、その責任者です。

00:06:13.000 --> 00:06:21.000
MyDemo.appのみが親になることを要求するように、MyFirstHelperで親プロセス制約を設定できます。

00:06:21.000 --> 00:06:32.000
次に、最初のヘルパーが2番目のヘルパーをposix_spawnsする場合、最初のヘルパーは2番目のヘルパーの親ですが、アプリは2番目のヘルパーを担当します。

00:06:32.000 --> 00:06:45.000
MySecondHelperの場合、MyFirstHelperによってのみ起動されることを要求する親プロセス制約を設定でき、MyDemo.appのみが責任を負うことを要求するように責任あるプロセス制約を設定できます。

00:06:45.000 --> 00:06:51.000
起動エージェントと起動デーモンのlaunchd plistsで環境制約を指定することもできます。

00:06:51.000 --> 00:07:01.000
SMAppService APIを使用してplistを登録すると、OSは制約を満たすプロセスのみがplistに代わって起動されることを強制します。

00:07:01.000 --> 00:07:11.000
この機能は、アプリのバックグラウンドアクティビティに対するユーザーの承認に基づいて、悪意のあるコードが永続的な実行を得ないようにするのに役立ちます。

00:07:11.000 --> 00:07:17.000
最後に、ライブラリの負荷制約を使用して、アドレス空間にロードできるコードを具体的に制御できます。

00:07:17.000 --> 00:07:21.000
ライブラリの負荷制約の前に、ライブラリの検証を採用するか、採用しないかのどちらかです。

00:07:21.000 --> 00:07:28.000
ライブラリの検証により、プロセスは、あなたが署名したコードまたはAppleによって署名されたコードをロードすることができます。

00:07:28.000 --> 00:07:38.000
ライブラリの負荷制約を使用すると、任意のコードがプロセスにロードされるのを防ぎながら、ライブラリの検証が許可するよりも制限の少ないコードセットを記述できます。

00:07:38.000 --> 00:07:48.000
ただし、Apple署名入りのコードをプロセスの読み込みから除外することはできず、独自のコードを許可するには1つ以上のプロパティを指定する必要があることに注意してください。

00:07:48.000 --> 00:07:55.000
環境制約とは何か、どのように使用できるかがわかったので、それらがどのように定義されているかについて話し合いましょう。

00:07:55.000 --> 00:07:59.000
環境制約は、コードが満たさなければならない一連の条件を記述します。

00:07:59.000 --> 00:08:09.000
それらは、キーがコードについて真実でなければならない事実、または事実または述語間の必要な関係を示す演算子を表す辞書としてエンコードされています。

00:08:09.000 --> 00:08:17.000
トップレベルでは、暗黙的に、各キーと値のペアの結果が一緒にANDされ、制約が満たされるかどうかが決定されます。

00:08:17.000 --> 00:08:23.000
これらは辞書であるため、各キーは辞書レベルごとに1回しか表示されないことに注意してください。

00:08:23.000 --> 00:08:26.000
あなたが使いたいかもしれないいくつかの事実を見てみましょう。

00:08:26.000 --> 00:08:31.000
左側は関連する環境制約キーで、右側は共同設計コマンドから出力されます。

00:08:31.000 --> 00:08:40.000
署名識別キーを使用すると、特定のコードに固有である文字列を指定できますが、そのコードのバージョン間で同じままです。

00:08:40.000 --> 00:08:46.000
署名識別キーは、共同設計出力の識別子フィールドを参照します。

00:08:46.000 --> 00:08:57.000
Cdhashキーを使用すると、許可するコードの一意のハッシュを指定でき、チーム識別キーを使用すると、特定の開発チームによって署名されたコードを指定できます。

00:08:57.000 --> 00:09:08.000
事実はコードの特定の特性を示しますが、演算子を使用して、事実のセットを論理的に結合したり、事実の許容値のセットを定義したりできます。

00:09:08.000 --> 00:09:17.000
ご想像のとおり、$と$or演算子を使用すると、決定後に論理的に結合される述語の辞書を指定できます。

00:09:17.000 --> 00:09:28.000
$and-arrayと$or-array演算子は、複数の$または述語または複数の$と述語をANDしたい場合に、辞書のネストを制限するために存在します。

00:09:28.000 --> 00:09:33.000
そして最後に、$in演算子を使用すると、事実を満たす値の配列を指定できます。

00:09:33.000 --> 00:09:35.000
この制約の例を見てみましょう。 

00:09:35.000 --> 00:09:39.000
左側には、制約のplist表現があります。

00:09:39.000 --> 00:09:44.000
右側は、XMLの意味を示す疑似コードです。

00:09:44.000 --> 00:09:49.000
Plistの最上位レベルには、$or-arrayという1つのキーがあります。

00:09:49.000 --> 00:09:51.000
値は3つのタプルの配列です。

00:09:51.000 --> 00:10:10.000
各タプルには、その演算子が適用される演算子と辞書が含まれているため、この制約により、チーム識別子によって署名されたすべてのコード、または2番目のチーム識別子によって署名されたライブラリB、または3番目のチーム識別子によって署名されたライブラリCが許可されます。

00:10:10.000 --> 00:10:16.000
最初のタプルでは、単一の要素であるため、$or演算子を使用することもできます。

00:10:16.000 --> 00:10:21.000
制約を定義できるようになったので、プロジェクトでそれらを採用する方法を見てみましょう。

00:10:21.000 --> 00:10:34.000
この議論の目的のために、ローンチエージェント、ヘルパーツール、XPCサービスを含むフレームワーク、および別の開発チームによって署名されたライブラリを含むメインアプリを検討してください。

00:10:34.000 --> 00:10:38.000
それでは、環境の制約が軽減できる潜在的な問題をいくつか考えてみましょう。

00:10:38.000 --> 00:10:47.000
おそらく、キーチェーンデータへのアクセスやiCloudコンテナへのアクセスなど、ヘルパーツールに特権を割り当てた可能性があります。

00:10:47.000 --> 00:10:53.000
ヘルパーツールはアプリによってのみ起動でき、他のものは起動できないようにすることをお勧めします。

00:10:53.000 --> 00:11:00.000
ヘルパーツールに親プロセスの制約を設定することで、アプリのみがヘルパーツールを起動できるようにすることができます。

00:11:00.000 --> 00:11:08.000
これを行うには、チーム識別子とメインアプリの署名識別子を必要とするコード要件plistファイルを作成します。

00:11:08.000 --> 00:11:15.000
次に、「Launch Constraint Parent Process Plist」設定で、ヘルパーツールの署名設定に制約を追加します。

00:11:15.000 --> 00:11:18.000
詳しく見てみましょう。 

00:11:18.000 --> 00:11:23.000
ここには、私が言及したプロパティを含むXcodeのデモプロジェクトがあります。

00:11:23.000 --> 00:11:29.000
MyDemo.appはメインアプリのターゲットであり、demohelperはヘルパーツールです。

00:11:29.000 --> 00:11:33.000
アプリを起動しましょう。

00:11:33.000 --> 00:11:42.000
このボタンを押すと、アプリはヘルパーツールを生成し、ヘルパーツールはいくつかの作業を行い、アプリに応答します。

00:11:42.000 --> 00:11:52.000
ターミナルのdemohelperの署名を見てみましょう。

00:11:52.000 --> 00:12:01.000
起動制約が設定されていないことが確認でき、demohelperを実行できます。

00:12:01.000 --> 00:12:04.000
しかし、それを見てください。

00:12:04.000 --> 00:12:09.000
--cloud引数でdemohelperを実行すると、demohelperはアプリのiCloudデータにアクセスできます。

00:12:09.000 --> 00:12:16.000
私たちは、任意のプロセスがdemohelperを実行し、iCloudデータを変更できるようにしたくありません。

00:12:16.000 --> 00:12:22.000
Xcodeに戻って、demohelperに親の制約を設定しましょう。

00:12:22.000 --> 00:12:30.000
ここでは、メインアプリMyDemoを識別するための制約plistファイルがすでに入力されています。

00:12:30.000 --> 00:12:39.000
署名設定に制約を追加しましょう。

00:12:39.000 --> 00:12:45.000
では、アプリを再構築しましょう。

00:12:45.000 --> 00:12:51.000
私たちは再びアプリを起動することができます...

00:12:51.000 --> 00:12:58.000
そして、メインアプリはまだヘルパーを生成することができます。

00:12:58.000 --> 00:13:00.000
しかし、ターミナルに戻ると...

00:13:00.000 --> 00:13:14.000
デモヘルパーには起動の制約があることがわかります...

00:13:14.000 --> 00:13:18.000
そして、それはもはやターミナルから実行することはできません。

00:13:18.000 --> 00:13:26.000
打ち上げ制約違反のために打ち上げがブロックされると、制約に違反したことを示すクラッシュレポートが生成されます。

00:13:26.000 --> 00:13:36.000
それでは、環境の制約が軽減できるいくつかの問題について話しましょう。

00:13:36.000 --> 00:13:42.000
XPCサービスを使用して、異なるプロセス間で権限を分離することをお勧めします。

00:13:42.000 --> 00:13:48.000
しかし、XPCサービスを構築すると、バンドルからこれらのサービスを抽出し、他のコードから呼び出すことができます。

00:13:48.000 --> 00:13:57.000
XPCサービスに何らかの権限を割り当てている場合は、期待されるプロセスのみがその権限にアクセスできるようにする必要があります。

00:13:57.000 --> 00:14:04.000
コードだけがそのXPCサービスにアクセスできるようにする1つの方法は、責任あるプロセス起動制約を設定することです。

00:14:04.000 --> 00:14:15.000
ここでは、XPCサービスにアクセスできるはずのバンドル内の各プロセスの署名識別子のリストを使用して、チームによって署名されたコードを許可する起動制約plistを示します。

00:14:15.000 --> 00:14:22.000
「Launch Constraint Responsible Process Plist」設定で、署名設定に制約を追加できます。

00:14:22.000 --> 00:14:24.000
考慮すべきもう一つの問題。

00:14:24.000 --> 00:14:30.000
macOS Ventura以降、ユーザーはアプリに代わってインストールされたバックグラウンドタスクを承認するよう求められます。

00:14:30.000 --> 00:14:34.000
これは、ユーザーがその作業がアプリに代わってのみ行われることを期待していることを意味します。

00:14:34.000 --> 00:14:42.000
攻撃者がplistが実行することを期待するコードを置き換えることができる場合、攻撃者はアプリに代わって永続的なバックグラウンド実行を得る可能性があります。

00:14:42.000 --> 00:14:51.000
登録されたplistが期待するコードの実行にのみ使用できるように、SpawnConstraintキーを使用してlaunchd plist制約を設定できます。

00:14:51.000 --> 00:14:56.000
ここでは、SpawnConstraintキーで完全な起動plistを見ることができます。

00:14:56.000 --> 00:15:02.000
この制約は、私たちのチームとDemoMenuBarエージェントを特定します。

00:15:02.000 --> 00:15:04.000
最後に、ライブラリの読み込みについて話しましょう。

00:15:04.000 --> 00:15:16.000
変更せずに別の開発チームからライブラリをリンクする義務がある場合は、強化されたランタイムでアプリを公証するには、disable-library-validation資格を採用する必要があります。

00:15:16.000 --> 00:15:23.000
残念ながら、それはあなたのアプリが、あなたがライブラリを入手した信頼できる開発者だけでなく、誰でも署名したコードを読み込むことができることを意味します。

00:15:23.000 --> 00:15:27.000
この問題に対処するには、ライブラリの負荷制約を採用できます。

00:15:27.000 --> 00:15:33.000
ここでは、チームまたは信頼できるライブラリサプライヤーによって署名されたコードをロードできる制約を示します。

00:15:33.000 --> 00:15:40.000
また、これを1つ以上の署名識別子の事実を使用して、特定のライブラリまたはライブラリのセットにさらに制限することもできます。

00:15:40.000 --> 00:15:51.000
起動制約と同様に、Xcode署名設定で「Library Load Constraint Plist」設定を設定すると、ライブラリのロード制約がプロセスにサインインします。

00:15:51.000 --> 00:15:53.000
では、環境制約はどこで利用できますか?

00:15:53.000 --> 00:15:59.000
ライブラリの負荷制約と起動plistの制約は、任意のmacOSバージョンをターゲットとするアプリに含めることができます。

00:15:59.000 --> 00:16:02.000
それらはmacOS Sonomaで開始されます。

00:16:02.000 --> 00:16:10.000
起動制約は、macOS 13.3以降をターゲットとするアプリに追加でき、macOS 13.3から強制されます。

00:16:10.000 --> 00:16:17.000
環境制約で使用できるサポートされているキーと値のセットは、macOSのバージョン間で変更される可能性があることに注意してください。

00:16:17.000 --> 00:16:21.000
完全な可用性情報については、ドキュメントを参照してください。

00:16:21.000 --> 00:16:30.000
アプリのプロセス関係、起動済みplist、およびライブラリを見て、環境制約を使用してアプリをより安全にできるかどうかを確認してください。

00:16:30.000 --> 00:16:32.000
見てくれてありがとう。

00:16:32.000 --> 23:59:59.000
♪ ♪

