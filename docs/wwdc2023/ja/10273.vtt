WEBVTT

00:00:00.000 --> 00:00:04.000
♪まろやかなインストゥルメンタルヒップホップ♪

00:00:04.000 --> 00:00:10.000
♪

00:00:10.000 --> 00:00:17.000
こんにちは、私の名前はアマンダで、RealityKitとReality Composer Proに取り組んでいるエンジニアです。

00:00:17.000 --> 00:00:25.000
このセッションでは、Reality Composer Proで組み立てた3Dコンテンツを使用して空間体験を作る方法を学びます。

00:00:25.000 --> 00:00:32.000
Reality Composer Proは、空間コンピューティングアプリで使用するRealityKitコンテンツを準備するための開発者ツールです。

00:00:32.000 --> 00:00:42.000
このセッションでは、同僚のエリックとニールスがセッションで作成したプロジェクトを反復し続け、コードでインタラクティブにする方法を学びます。

00:00:42.000 --> 00:00:53.000
まだセッションを見ていない場合は、セッションで取り上げられているエディタUIとReality Composer Proの機能に慣れておくことをお勧めします。

00:00:53.000 --> 00:00:59.000
まず、私たちが作った完成品を見てみましょう。その後、各部分をどのように作成したかを説明します。

00:00:59.000 --> 00:01:05.000
ヨセミテ国立公園の地形図を見ています。

00:01:05.000 --> 00:01:12.000
ヘッドセットでそれを見ると、実際にそこに行かずに以前は不可能だった広大さの感覚が本当に与えられます。

00:01:12.000 --> 00:01:20.000
前回のReality Composer Proセッションでは、エリックがこのシーンを組み立て、ニールスが地形で使用している素材を作成しました。

00:01:20.000 --> 00:01:25.000
ここでは、2つの異なるカリフォルニアのランドマークの間をモーフィングするスライダーを追加しました。

00:01:25.000 --> 00:01:30.000
今、私たちはロサンゼルス沖のカタリナ島を見ています。

00:01:30.000 --> 00:01:39.000
また、3D空間に配置されたホバリング2D SwiftUIボタンがあり、そのマップのさまざまな興味のあるポイントについて詳しく知ることができます。

00:01:39.000 --> 00:01:47.000
このセッションでは、エクスペリエンスを推進できるように、Reality Composer Proでこのコンテンツをどのように配置したかを探ります。

00:01:47.000 --> 00:01:55.000
Reality Composer Proで作成したシーンに影響を与えるように、このスライダーとポイントオブインタレストボタンをどのように接続したかをお見せします。

00:01:55.000 --> 00:02:02.000
Reality Composer Proプロジェクトから3Dコンテンツをプログラムでロードすることから始めます。

00:02:02.000 --> 00:02:11.000
RealityKitコンポーネントがどのように機能し、独自のカスタムコンポーネントを作成するなど、それらをコードでどのように活用できるかを探ります。

00:02:11.000 --> 00:02:22.000
SwiftUIの新しいRealityView APIについて学び、Attachments APIを使用してシーンにユーザーインターフェイス要素を追加する方法を発見します。

00:02:22.000 --> 00:02:27.000
そして、Reality Composer Proで設定したオーディオの操作方法を学びます。

00:02:27.000 --> 00:02:37.000
次に、Shader Graphを使用して作成したカスタムマテリアルを接続し、コードから要素を駆動することで、Nielsが中断したところから再開します。

00:02:37.000 --> 00:02:40.000
始めましょう。

00:02:40.000 --> 00:02:48.000
エリックのセッションでは、私たちが望むように配置されたジオラマのすべての資産を含むReality Composer Proプロジェクトを作成しました。

00:02:48.000 --> 00:02:53.000
上部にあるこれらのタブは、それぞれ実行時にロードできる1つのルートエンティティを表しています。

00:02:53.000 --> 00:02:58.000
私たちは多くのものをシーンに入れて、それを完全に組み立てられたシーンとして扱うことができます。

00:02:58.000 --> 00:03:03.000
または、ほんの少し置いて、そのシーンを少し再利用可能な集合体のように扱うこともできます。

00:03:03.000 --> 00:03:05.000
私たちは好きなだけ作ることができます。

00:03:05.000 --> 00:03:12.000
実行時にDioramaAssembledという名前のこのシーンをどのようにロードするか見てみましょう。

00:03:12.000 --> 00:03:20.000
エンティティの非同期初期化子を使用して、Reality Composer Proパッケージのコンテンツを持つエンティティにします。

00:03:20.000 --> 00:03:28.000
文字列名を使用してロードするエンティティを指定し、パッケージが生成するバンドルを指定します。

00:03:28.000 --> 00:03:33.000
その名前のReality Composer Proプロジェクトで何も見つからない場合は、スローされます。

00:03:33.000 --> 00:03:41.000
realityKitContentBundleは、Reality Composer Proパッケージで自動生成する一定の値です。

00:03:41.000 --> 00:03:44.000
これはRealityViewで終了します。

00:03:44.000 --> 00:03:48.000
RealityViewは、新しい種類のSwiftUIビューです。

00:03:48.000 --> 00:03:50.000
それはRealityKitへのあなたの入り口です。

00:03:50.000 --> 00:03:54.000
SwiftUIとRealityKitの世界の架け橋です。

00:03:54.000 --> 00:04:00.000
このセッションの後半で、このRealityViewをより深く掘り下げます。

00:04:00.000 --> 00:04:16.000
Xcodeプロジェクトで使用していて、Reality Composer Proプロジェクトに追加していないUSDアセットがある場合は、これらのアセットをこのように.rkassetsディレクトリを含むSwiftパッケージに入れることを強くお勧めします。

00:04:16.000 --> 00:04:23.000
Xcodeは、.rkassetsフォルダを、実行時に読み込むのが速い形式にコンパイルします。

00:04:23.000 --> 00:04:29.000
ロードしたばかりのエンティティは、実際にはより大きなエンティティ階層のルートです。

00:04:29.000 --> 00:04:33.000
それは子エンティティを持っており、彼らは順番に子エンティティを持っています。

00:04:33.000 --> 00:04:37.000
それは私たちがReality Composer Proのシーンで手配したすべてです。

00:04:37.000 --> 00:04:49.000
階層の下位にあるエンティティの1つに対処したい場合は、Reality Composer Proで名前を付け、実行時にシーンにそのエンティティをその名前で見つけるように依頼することができます。

00:04:49.000 --> 00:04:55.000
エンティティは、エンティティコンポーネントシステムの略であるECSの一部です。

00:04:55.000 --> 00:04:59.000
ECSは、RealityKitとReality Composer Proに力を与えるものです。

00:04:59.000 --> 00:05:03.000
一歩下がってECSを理解しましょう。

00:05:03.000 --> 00:05:11.000
ECSは、オブジェクト指向プログラミングといくつかの密接な類似点がありますが、いくつかの重要な点で異なります。

00:05:11.000 --> 00:05:20.000
オブジェクト指向プログラミングの世界では、オブジェクトには、その性質を定義する属性であるプロパティがあり、独自の機能があります。

00:05:20.000 --> 00:05:25.000
これらのプロパティと関数は、オブジェクトを定義するクラスに記述します。

00:05:25.000 --> 00:05:30.000
ECSの世界では、エンティティはシーンで見られるあらゆるものです。

00:05:30.000 --> 00:05:32.000
彼らはまた、目に見えないことができます。

00:05:32.000 --> 00:05:34.000
しかし、彼らは属性やデータを保持していません。

00:05:34.000 --> 00:05:37.000
代わりに、データをコンポーネントに入れます。

00:05:37.000 --> 00:05:48.000
コンポーネントは、アプリの実行中にいつでもエンティティに追加または削除することができ、エンティティの性質を動的に変更する方法を提供します。

00:05:48.000 --> 00:05:51.000
システムは、私たちの行動が住んでいる場所です。

00:05:51.000 --> 00:05:54.000
フレームごとに1回呼び出される更新機能があります。

00:05:54.000 --> 00:05:56.000
それはあなたが継続的な論理を置く場所です。

00:05:56.000 --> 00:06:10.000
システムでは、特定のコンポーネントを持つすべてのエンティティ、またはコンポーネントの構成を照会し、いくつかのアクションを実行し、更新されたデータをそれらのコンポーネントに保存します。

00:06:10.000 --> 00:06:23.000
ECSに関するより詳細な議論については、2021年の「Dive into RealityKit 2」セッションと今年の「RealityKitで空間体験を構築する」をチェックしてください。

00:06:23.000 --> 00:06:26.000
では、コンポーネントについて学びましょう。

00:06:26.000 --> 00:06:38.000
Reality Composer Proプロジェクトのエンティティにコンポーネントを追加する方法を確認し、ジオラマでロケーションマーカーを作成するためのカスタムコンポーネントを作成する方法を学びます。

00:06:38.000 --> 00:06:48.000
Swift でエンティティにコンポーネントを追加するには、entity.components.set() と言い、コンポーネントの値を指定します。

00:06:48.000 --> 00:06:57.000
Reality Composer Proでも同じことをするには、ビューポートまたは階層で必要なエンティティを選択します。

00:06:57.000 --> 00:07:09.000
次に、インスペクタパネルの下部にある[コンポーネントの追加]ボタンをクリックして、RealityKitで利用可能なすべてのコンポーネントのリストを表示します。

00:07:09.000 --> 00:07:16.000
エンティティに好きなだけコンポーネントを追加でき、各タイプの1つしか追加できません。それはセットです。

00:07:16.000 --> 00:07:20.000
また、このリストで作成したカスタムコンポーネントも表示されます。

00:07:20.000 --> 00:07:26.000
Reality Composer Proを使用して独自のカスタムコンポーネントを作成する方法を見てみましょう。

00:07:26.000 --> 00:07:35.000
地形の特定のポイントにカーソルを合わせるフローティングボタンを作成し、それらを選択してその場所に関する詳細情報を見ることができます。

00:07:35.000 --> 00:07:48.000
コードでそのUIと機能の多くを準備しますが、Reality Composer Proでこれらのエンティティを、それらのフローティングボタンを表示したい位置としてマークする方法を紹介したいと思います。

00:07:48.000 --> 00:07:59.000
これを行うには、地形マップの上の場所にエンティティを追加します。これは、これらがフローティングボタンを表示したい場所であることをアプリに意味します。

00:07:59.000 --> 00:08:05.000
次に、各場所に関する情報を格納するためのポイントオブインタレストコンポーネントを作成します。

00:08:05.000 --> 00:08:14.000
次に、XcodeでPointOfInterestComponent.swiftを開いて編集し、名前や説明などのプロパティを追加します。

00:08:14.000 --> 00:08:24.000
Reality Composer Proでは、新しいPointOfInterestComponentを新しいエンティティのそれぞれに追加し、プロパティの値を入力します。

00:08:24.000 --> 00:08:30.000
カタリナ島にある最初のロケーションマーカーエンティティ、リボンビーチを作りましょう。

00:08:30.000 --> 00:08:35.000
プラスメニューをクリックし、[トランスフォーム]を選択して、新しい目に見えないエンティティにします。

00:08:35.000 --> 00:08:44.000
エンティティにRibbon_Beachという名前を付けることができます。

00:08:44.000 --> 00:08:53.000
リボンビーチが実際に島にある場所にこのエンティティを置きましょう。

00:08:53.000 --> 00:09:08.000
[コンポーネントの追加]ボタンをクリックしますが、今回は独自のコンポーネントを作成するため、新しいコンポーネントを選択します。

00:09:08.000 --> 00:09:14.000
PointOfInterestという名前を付けましょう。

00:09:14.000 --> 00:09:26.000
これで、他のコンポーネントと同じようにインスペクタパネルに表示されます。

00:09:26.000 --> 00:09:29.000
しかし、このカウントプロパティは何ですか?

00:09:29.000 --> 00:09:33.000
Xcodeで新しいコンポーネントを開きましょう。

00:09:33.000 --> 00:09:39.000
Xcodeでは、Reality Composer Proが私たちのためにPointOfInterestComponent.swiftを作成したことがわかります。

00:09:39.000 --> 00:09:47.000
Reality Composer ProプロジェクトはSwiftパッケージであり、生成したばかりのSwiftコードはパッケージの中に住んでいます。

00:09:47.000 --> 00:09:54.000
テンプレートコードを見ると、カウントプロパティがそこから来たことがわかります。

00:09:54.000 --> 00:09:57.000
代わりに別の物件を持ちましょう。

00:09:57.000 --> 00:10:07.000
地図を変更するときに、古い興味のあるポイントをフェードアウトし、適切なポイントでフェードインできるように、各興味のあるポイントがどのマップに関連付けられているかを知ってもらいたいです。

00:10:07.000 --> 00:10:11.000
したがって、列挙プロパティ、var領域を追加します。

00:10:11.000 --> 00:10:21.000
列挙領域をここに作りましょう...

00:10:21.000 --> 00:10:32.000
...そして、私たちは今2つの地図しか構築していないので、それに2つのケースを与えます:カタリナとヨセミテ。

00:10:32.000 --> 00:10:44.000
文字列としてシリアライズできます。

00:10:44.000 --> 00:10:52.000
また、Reality Composer Proがそれを見て、そのインスタンスをシリアライズできるように、Codableプロトコルに準拠しています。

00:10:52.000 --> 00:11:00.000
Reality Composer Proに戻ると、カウントプロパティがなくなり、新しい地域のプロパティが表示されます。

00:11:00.000 --> 00:11:09.000
コードで初期化したものであるため、デフォルト値はyosemiteですが、この特定のエンティティに対してここでオーバーライドできます。

00:11:09.000 --> 00:11:17.000
それを上書きすると、この値はこの特定のエンティティに対してのみ有効になります。

00:11:17.000 --> 00:11:24.000
残りのポイントオブインタレストコンポーネントは、それらをオーバーライドしない限り、ヨセミテのデフォルト値になります。

00:11:24.000 --> 00:11:30.000
PointOfInterestComponentを記号、これらのエンティティに貼り付けるマーカーのように使用しています。

00:11:30.000 --> 00:11:36.000
これらのエンティティは、実行時にSwiftUIボタンを配置する場所のプレースホルダのように機能します。

00:11:36.000 --> 00:11:42.000
リボンビーチを追加したのと同じ方法で、他のカタリナ島の興味のあるポイントを追加します。

00:11:42.000 --> 00:11:51.000
アプリを実行して、新しいカスタムコンポーネントが何をするか見てみましょう。

00:11:51.000 --> 00:11:53.000
ああ！それは何もしません。

00:11:53.000 --> 00:11:58.000
それは、これらのポイントオブインタレストコンポーネントを処理するためのコードをまだ書いていないからです。

00:11:58.000 --> 00:12:00.000
そうしましょう。そうしましょう。

00:12:00.000 --> 00:12:05.000
SwiftUIのコンテンツをRealityKitのシーンに入れる新しい方法があります。

00:12:05.000 --> 00:12:07.000
これは添付ファイルAPIと呼ばれます。 は添付ファイルAPIと呼ばれます。

00:12:07.000 --> 00:12:15.000
添付ファイルをPointOfInterestComponentと組み合わせて、実行時にカスタムデータでホバリングボタンを作成します。

00:12:15.000 --> 00:12:20.000
まずこれをコードで見てから、データフローを順を追って説明します。

00:12:20.000 --> 00:12:23.000
添付ファイルはRealityViewの一部です。

00:12:23.000 --> 00:12:33.000
まず、RealityViewの構造を示す簡略化された例を見て、SwiftUIビューがどのようにRealityKitシーンに入るかを見てみましょう。

00:12:33.000 --> 00:12:45.000
使用するRealityView初期化子には、makeクロージャ、更新クロージャ、添付ファイルViewBuilderの3つのパラメータが必要です。

00:12:45.000 --> 00:12:56.000
これを少し広げて、アタッチメントビュー、緑色のSwiftUIボタンを作成し、RealityKitシーンに追加するという最低限の実装を追加しましょう。

00:12:56.000 --> 00:13:06.000
Attachments ViewBuilderでは、通常のSwiftUIビューを作成します。ビュー修飾子とジェスチャー、およびSwiftUIが提供する残りのすべてを使用できます。

00:13:06.000 --> 00:13:09.000
ビューにユニークなハッシュ可能なタグを付けます。

00:13:09.000 --> 00:13:14.000
このボタンビューに魚の絵文字をタグ付けすることを選択しました。

00:13:14.000 --> 00:13:21.000
その後、SwiftUIがアップデートクロージャを呼び出すと、ボタンビューがエンティティになります。

00:13:21.000 --> 00:13:29.000
このクロージャの添付ファイルパラメータに保存され、以前に与えたタグを使用してそれを釣り出します。

00:13:29.000 --> 00:13:31.000
その後、他のエンティティと同じように扱うことができます。

00:13:31.000 --> 00:13:41.000
シーン内の既存のエンティティの子として追加することも、コンテンツのエンティティコレクションに新しいトップレベルのエンティティとして追加することもできます。

00:13:41.000 --> 00:13:52.000
そして、それが通常のエンティティになったので、その位置を設定して、3Dで必要な場所を表示し、必要なコンポーネントを追加することもできます。

00:13:52.000 --> 00:13:57.000
RealityViewのある部分から別の部分へのデータの流れは次のとおりです。

00:13:57.000 --> 00:14:01.000
このRealityView初期化子の3つのパラメータを見てみましょう。

00:14:01.000 --> 00:14:13.000
1つ目はmakeで、Reality Composer Proバンドルから最初のセットアップシーンをエンティティとしてロードし、RealityKitシーンに追加します。

00:14:13.000 --> 00:14:19.000
2つ目は更新です。これは、ビューの状態が変更されたときに呼び出されるクロージャです。

00:14:19.000 --> 00:14:29.000
ここでは、コンポーネントのプロパティや位置など、エンティティに関するものを変更したり、シーンからエンティティを追加または削除したりすることもできます。

00:14:29.000 --> 00:14:32.000
この更新プログラムのクロージャは、すべてのフレームで実行されるわけではありません。

00:14:32.000 --> 00:14:37.000
SwiftUIビューの状態が変わるたびに呼び出されます。

00:14:37.000 --> 00:14:40.000
3つ目は添付ファイルViewBuilderです。

00:14:40.000 --> 00:14:46.000
これは、SwiftUIビューを作成してRealityKitシーンに入れることができる場所です。

00:14:46.000 --> 00:14:55.000
SwiftUIビューは、添付ファイルViewBuilderで始まり、添付ファイルパラメータの更新クロージャで配信されます。

00:14:55.000 --> 00:15:04.000
ここでは、添付ファイルViewBuilderのボタンに与えたのと同じタグを使用してエンティティがあるかどうかを添付ファイルパラメータに尋ねます。

00:15:04.000 --> 00:15:09.000
もしあれば、それはあなたにRealityKitエンティティを提供します。

00:15:09.000 --> 00:15:19.000
アップデートのクロージャでは、その3D位置を設定し、RealityKitシーンに追加して、好きな場所に宇宙に浮かんでいるのを見ることができます。

00:15:19.000 --> 00:15:24.000
ここでは、ボタンエンティティを球体エンティティの子として追加しました。

00:15:24.000 --> 00:15:28.000
私はそれを親の0.2メートル上に配置しました。

00:15:28.000 --> 00:15:32.000
Makeクロージャには添付ファイルパラメータもあります。

00:15:32.000 --> 00:15:41.000
これは、makeクロージャが一度しか実行されないため、このビューが最初に評価された時点で準備ができている添付ファイルを追加するためのものです。

00:15:41.000 --> 00:15:48.000
RealityViewの一般的な流れを理解したので、アップデートの終了についてさらに詳しく説明しましょう。

00:15:48.000 --> 00:15:54.000
makeとupdateのクロージャのパラメータはRealityKitContentです。

00:15:54.000 --> 00:16:00.000
RealityKitコンテンツにエンティティを追加すると、シーンのトップレベルのエンティティになります。

00:16:00.000 --> 00:16:08.000
同様に、更新機能から、コンテンツにエンティティを追加すると、シーンに新しいトップレベルのエンティティが表示されます。

00:16:08.000 --> 00:16:14.000
Makeクロージャは1回のみ呼び出されますが、更新のクロージャは複数回呼び出されます。

00:16:14.000 --> 00:16:25.000
アップデートクロージャで新しいエンティティを作成し、そこでコンテンツに追加すると、そのエンティティの重複を取得しますが、これはあなたが望むものではない可能性があります。

00:16:25.000 --> 00:16:32.000
それを防ぐには、一度しか実行されていない場所で作成されたコンテンツにエンティティのみを追加する必要があります。

00:16:32.000 --> 00:16:37.000
Content.entitiesにすでにエンティティが含まれているかどうかを確認する必要はありません。

00:16:37.000 --> 00:16:42.000
セットのように、同じエンティティでaddを2回呼び出すと、no-opです。

00:16:42.000 --> 00:16:49.000
シーン内の既存のエンティティにエンティティを親にするときも同じです - それは2回追加されません。

00:16:49.000 --> 00:16:58.000
添付ファイルエンティティはあなたによって作成されるのではなく、添付ファイルViewBuilderで提供する添付ファイルビューごとにRealityViewによって作成されます。

00:16:58.000 --> 00:17:05.000
つまり、すでにそこにあるかどうかを確認せずに、アップデートクロージャのコンテンツに追加しても安全です。

00:17:05.000 --> 00:17:13.000
だから、添付ファイルViewBuilderで興味のあるポイントをハードコードしたい場合、それが添付ファイルコードを書く方法でした。

00:17:13.000 --> 00:17:20.000
しかし、Reality Composer Proプロジェクトのデータが体験を駆動させたいので、より柔軟にしましょう。

00:17:20.000 --> 00:17:31.000
そうすれば、デザイナーやプロデューサーはReality Composer Proプロジェクトで興味のあるポイントを作成することができ、私たちのコードは彼らが追加するどんなデータにも対応できます。

00:17:31.000 --> 00:17:38.000
データドリブンにするには、Reality Composer Proシーンで設定したデータを読み取るためのコードが必要です。

00:17:38.000 --> 00:17:42.000
添付ファイルビューを動的に作成します。

00:17:42.000 --> 00:17:46.000
高レベル、これが私たちがやろうとしていることです。

00:17:46.000 --> 00:17:56.000
Reality Composer Proでは、すでにリボンビーチのプレースホルダーエンティティを設定しており、ジオラマで強調したい他の興味のあるポイントにも同じことをします。

00:17:56.000 --> 00:18:02.000
名前やどの地図に属しているかなど、それぞれが必要とするすべての情報を記入します。

00:18:02.000 --> 00:18:09.000
さて、コードでは、これらのエンティティを照会し、それぞれに新しいSwiftUIボタンを作成します。

00:18:09.000 --> 00:18:20.000
コレクションに新しいボタンを追加するたびにSwiftUIが添付ファイルViewBuilderを呼び出すために、このコレクションに@Stateプロパティラッパーを追加します。

00:18:20.000 --> 00:18:24.000
これらのボタンを添付ファイルViewBuilderまで提供します。

00:18:24.000 --> 00:18:33.000
そして最後に、RealityViewの更新終了で、ボタンをエンティティとして受け取り、それらの新しいボタンエンティティをシーンに追加します。

00:18:33.000 --> 00:18:39.000
それぞれをReality Composer Proで設定したマーカーエンティティの子として追加します。

00:18:39.000 --> 00:18:46.000
より詳細な図を通してこれらの6つのステップを理解し、コードを見てみましょう。

00:18:46.000 --> 00:18:51.000
まず、Reality Composer Proのシーンに目に見えないエンティティを追加します。

00:18:51.000 --> 00:18:58.000
目に見えないエンティティを、ボタンを表示したい場所に、x軸、y軸、z軸に配置します。

00:18:58.000 --> 00:19:04.000
ここでは、すべてのエンティティがデフォルトで持っているトランスフォームコンポーネントを利用しています。

00:19:04.000 --> 00:19:09.000
次に、それぞれにPointOfInterestComponentを追加します。

00:19:09.000 --> 00:19:17.000
コードでは、PointOfInterestComponentを持つシーン内のすべてのエンティティを照会することで、これらのエンティティへの参照を取得します。

00:19:17.000 --> 00:19:24.000
このクエリは、Reality Composer Proで設定した3つの目に見えないエンティティを返します。

00:19:24.000 --> 00:19:30.000
それぞれに新しいSwiftUIビューを作成し、コレクションに保存します。

00:19:30.000 --> 00:19:36.000
ボタンをRealityViewに取り込むには、SwiftUIビュー更新フローを利用します。

00:19:36.000 --> 00:19:43.000
これは、ビューのボタンのコレクションにプロパティラッパー@Stateを追加することを意味します。

00:19:43.000 --> 00:19:53.000
@Stateプロパティラッパーは、このコレクションにアイテムを追加すると、SwiftUIがImmersiveViewでビューの更新をトリガーする必要があることをSwiftUIに伝えます。

00:19:53.000 --> 00:20:00.000
これにより、SwiftUIは添付ファイルViewBuilderとアップデートの閉鎖を再び評価します。

00:20:00.000 --> 00:20:09.000
RealityViewの添付ファイルViewBuilderは、これらのボタンをエンティティにしたいことをSwiftUIに宣言する場所です。

00:20:09.000 --> 00:20:16.000
RealityViewのアップデートクロージャは次に呼び出され、ボタンはエンティティとして配信されます。

00:20:16.000 --> 00:20:18.000
彼らはもはやSwiftUIビューではありません。

00:20:18.000 --> 00:20:22.000
そのため、それらをエンティティ階層に追加できます。

00:20:22.000 --> 00:20:30.000
アップデートクロージャでは、目に見えない各エンティティの上に浮かぶ位置にあるアタッチメントエンティティをシーンに追加します。

00:20:30.000 --> 00:20:35.000
今、私たちがジオラマのシーンを見るとき、彼らは視覚的に現れるでしょう。

00:20:35.000 --> 00:20:38.000
これらの各ステップがどのように行われるか見てみましょう。

00:20:38.000 --> 00:20:43.000
まず、Reality Composer Proのシーンで目に見えないエンティティをマークします。

00:20:43.000 --> 00:20:48.000
マークしたエンティティを見つけるために、EntityQueryを作ります。

00:20:48.000 --> 00:20:53.000
それを使用して、PointOfInterestComponentを持つすべてのエンティティを尋ねます。

00:20:53.000 --> 00:21:03.000
次に、QueryResultを反復し、PointOfInterestComponentを持つシーン内の各エンティティに対して新しいSwiftUIビューを作成します。

00:21:03.000 --> 00:21:10.000
コンポーネントから取得した情報、Reality Composer Proに入力したデータを記入します。

00:21:10.000 --> 00:21:15.000
そのビューは私たちの添付ファイルの1つになるので、タグを付けます。

00:21:15.000 --> 00:21:23.000
この場合、私たちは真剣になっているので、魚の絵文字ではなくObjectIdentifierを使用します。

00:21:23.000 --> 00:21:26.000
SwiftUIビューのコレクションを作る部分はこちらです。

00:21:26.000 --> 00:21:34.000
RealityViewの添付ファイルViewBuilderに添付ファイルを提供するため、添付ファイルプロバイダーと呼びます。

00:21:34.000 --> 00:21:37.000
次に、ビューをattachmentsProviderに保存します。

00:21:37.000 --> 00:21:40.000
そのコレクションの種類を見てみましょう。 

00:21:40.000 --> 00:21:45.000
AttachmentsProviderには、ビューへの添付タグの辞書があります。

00:21:45.000 --> 00:21:52.000
ビューをタイプ消去したので、LearnMoreView以外にも他の種類のビューを入れることができます。

00:21:52.000 --> 00:22:03.000
sortedTagViewPairsという計算されたプロパティがあり、タプルの配列（タグと対応するビュー）を毎回同じ順序で返します。

00:22:03.000 --> 00:22:10.000
次に、添付ファイルViewBuilderで、作成した添付ファイルのコレクションをForEachします。

00:22:10.000 --> 00:22:19.000
これは、私たちが与えたペアごとに1つのビューが欲しいことをSwiftUIに伝え、コレクションからビューを提供します。

00:22:19.000 --> 00:22:31.000
ここでは、ObjectIdentifierに、ビューの添付ファイルタグとForEach構造の識別子の両方として二重の義務を負わせています。

00:22:31.000 --> 00:22:37.000
では、代わりにPointOfInterestComponentにタグプロパティを追加してみませんか？

00:22:37.000 --> 00:22:45.000
添付ファイルタグは、ForEach構造体と添付ファイルメカニズムの両方が機能するために、一意である必要があります。

00:22:45.000 --> 00:22:58.000
また、コンポーネントをエンティティに追加すると、カスタムコンポーネントのすべてのプロパティがReality Composer Proのインスペクタパネルに表示されるため、attachTagもそこに表示されます。

00:22:58.000 --> 00:23:06.000
Reality Composer Proに関心のある各ポイントを追加するときに、すべてのタグを統一することを覚えておくことに負担をかけたくありません。

00:23:06.000 --> 00:23:15.000
しかし、私たちにとって便利なことに、エンティティは識別可能なプロトコルに準拠しているため、自動的に一意の識別子を持っています。

00:23:15.000 --> 00:23:25.000
Reality Composer Proでシーンを設計する際に、事前に知ることなく、実行時にエンティティからこの識別子を取得できます。

00:23:25.000 --> 00:23:36.000
Reality Composer ProにattachTagプロパティが表示されないようにするには、「デザインタイムとランタイムコンポーネント」と呼ばれるテクニックを使用します。

00:23:36.000 --> 00:23:51.000
データを2つの異なるコンポーネントに分割します。1つはReality Composer Proで配置する設計時データ用、もう1つは実行時に同じエンティティに動的にアタッチするランタイムデータ用です。

00:23:51.000 --> 00:23:58.000
これは、Reality Composer Proのインスペクタパネルに表示したくないプロパティ用です。

00:23:58.000 --> 00:24:06.000
そこで、新しいコンポーネントPointOfInterestRuntimeComponentを定義し、その中に添付ファイルタグを移動します。

00:24:06.000 --> 00:24:13.000
Reality Composer Proは、Swiftパッケージで読んだ内容に基づいて、コンポーネントUIを自動的に構築します。

00:24:13.000 --> 00:24:22.000
パッケージ内のSwiftコードを検査し、見つけたコード可能なコンポーネントをシーンで使用できるようにします。

00:24:22.000 --> 00:24:24.000
ここでは、4つのコンポーネントを示しています。

00:24:24.000 --> 00:24:37.000
コンポーネントAとBはXcodeプロジェクトにありますが、Reality Composer Proパッケージ内にないため、Reality Composer Proのエンティティに添付することはできません。

00:24:37.000 --> 00:24:45.000
コンポーネントCはパッケージ内にありますが、体系化できないため、Reality Composer Proはそれを無視します。

00:24:45.000 --> 00:24:56.000
ここに示されている4つのコンポーネントのうち、コンポーネントDのみがSwiftパッケージ内にあり、コーディング可能なコンポーネントであるため、Reality Composer Proのリストに表示されます。

00:24:56.000 --> 00:25:03.000
それは私たちの設計時コンポーネントですが、他のものはすべてランタイムコンポーネントとして使用できます。

00:25:03.000 --> 00:25:13.000
デザインタイムコンポーネントは、3Dアーティストやデザイナーが利用するint、文字列、SIMD値などのより単純なデータを格納するためのものです。

00:25:13.000 --> 00:25:23.000
Reality Composer Proがシリアライズしないタイプのプロパティをカスタムコンポーネントに追加すると、Xcodeプロジェクトにエラーが表示されます。

00:25:23.000 --> 00:25:26.000
では、私たちのコードに戻りましょう。

00:25:26.000 --> 00:25:39.000
まず、PointOfInterestランタイムコンポーネントをエンティティに追加し、ランタイムコンポーネントを使用して、添付ファイルエンティティとジオラマの対応するポイントを照合します。

00:25:39.000 --> 00:25:42.000
ここでランタイムコンポーネントの出番です。

00:25:42.000 --> 00:25:48.000
私たちは、PointOfInterestエンティティで読み、添付ファイルビューを作成している部分にいます。

00:25:48.000 --> 00:25:55.000
すべての設計時コンポーネントを照会し、それぞれに対応する新しいランタイムコンポーネントを作ります。

00:25:55.000 --> 00:26:02.000
attachmentTagをランタイムコンポーネントに保存し、ランタイムコンポーネントを同じエンティティに保存します。

00:26:02.000 --> 00:26:06.000
このようにして、デザインタイムコンポーネントは記号のようなものです。

00:26:06.000 --> 00:26:10.000
それは私たちのアプリに、それのために作られた添付ファイルを望んでいることを伝えます。

00:26:10.000 --> 00:26:20.000
ランタイムコンポーネントは、アプリの実行中に必要な他の種類のデータを処理しますが、設計時コンポーネントに保存したくありません。

00:26:20.000 --> 00:26:26.000
RealityViewでは、アタッチメントエンティティがシーンに表示される前に、もう1つのステップがあります。

00:26:26.000 --> 00:26:38.000
添付ファイルViewBuilderでSwiftUIビューを提供すると、SwiftUIはRealityViewのアップデートクロージャを呼び、RealityKitエンティティとして添付ファイルを提供します。

00:26:38.000 --> 00:26:47.000
しかし、それらを配置せずにコンテンツに追加するだけで、それらはすべてシーンの原点、位置0、0、0に座って表示されます。

00:26:47.000 --> 00:26:49.000
それは私たちがそれらが欲しい場所ではありません。

00:26:49.000 --> 00:26:53.000
私たちは、彼らが地形上の各興味のあるポイントの上に浮かんでほしい。

00:26:53.000 --> 00:27:01.000
アタッチメントエンティティを、Reality Composer Proで設定した目に見えないポイントオブインタレストエンティティと照合する必要があります。

00:27:01.000 --> 00:27:06.000
目に見えないエンティティに配置したランタイムコンポーネントには、タグが入っています。

00:27:06.000 --> 00:27:12.000
それが、どのattachmentEntityが各ポイントオブインタレストエンティティと一致させる方法です。

00:27:12.000 --> 00:27:30.000
すべてのPointOf InterestRuntimeComponentsをクエリし、クエリによって返された各エンティティからそのランタイムコンポーネントを取得し、コンポーネントのattachTagプロパティを使用して、attachmentmentsパラメータから更新クロージャにattachEntityを取得します。

00:27:30.000 --> 00:27:37.000
次に、attachEntityをコンテンツに追加し、ポイントオブインタレストエンティティの半メートル上に配置します。

00:27:37.000 --> 00:27:42.000
アプリをもう一度実行して、これらがどのように見えるか見てみましょう。

00:27:42.000 --> 00:27:44.000
ねえ、彼らは素晴らしく見えます!

00:27:44.000 --> 00:27:50.000
それぞれの場所の名前が、Reality Composer Proプロジェクトに入れた場所の上に浮かんでいるのを見ることができます。

00:27:50.000 --> 00:27:56.000
次に、Reality Composer Proで設定したオーディオの再生方法を調べてみましょう。

00:27:56.000 --> 00:28:09.000
Reality Composer Proでオーディオを再生するものを設定するには、プラスボタンをクリックしてオーディオを選択し、アンビエントオーディオを選択することで、オーディオエンティティを持ち込むことができます。

00:28:09.000 --> 00:28:15.000
これにより、AmbientAudioComponentが付いた通常の目に見えないエンティティが作成されます。

00:28:15.000 --> 00:28:22.000
カタリナ島のオーシャンサウンドを再生するために使用するので、エンティティOceanEmitterに名前を付けましょう。

00:28:22.000 --> 00:28:25.000
シーンにもオーディオファイルを追加する必要があります。

00:28:25.000 --> 00:28:35.000
私たちの海の音を持ち込みましょう。

00:28:35.000 --> 00:28:48.000
インスペクタパネルのコンポーネントのプレビューメニューでサウンドを選択することで、オーディオコンポーネントをプレビューできますが、エンティティがアプリに読み込まれると、選択したサウンドは自動的に再生されません。

00:28:48.000 --> 00:28:55.000
そのために、オーディオリソースをロードして再生するように指示する必要があります。

00:28:55.000 --> 00:29:00.000
このサウンドを再生するには、オーディオコンポーネントを配置したエンティティへの参照を取得します。

00:29:00.000 --> 00:29:05.000
エンティティをOceanEmitterと名付けたので、その名前でエンティティを見つけます。

00:29:05.000 --> 00:29:15.000
AudioFileResource初期化子を使用してサウンドファイルをロードし、シーン内のオーディオファイルリソースプリムへのフルパスを渡します。

00:29:15.000 --> 00:29:20.000
Reality Composer Proプロジェクトに含まれている.usdaファイルの名前を付けます。

00:29:20.000 --> 00:29:27.000
私たちの場合、それはDioramaAssembled.usdaという名前のメインシーンです。

00:29:27.000 --> 00:29:35.000
entity.prepareAudioを呼び出してaudioPlaybackControllerを作成し、このサウンドを再生、一時停止、停止することができます。

00:29:35.000 --> 00:29:38.000
今、私たちはそれで遊びを呼び出す準備ができています。

00:29:38.000 --> 00:29:41.000
これは私たちのアプリで流れている海の音です。

00:29:41.000 --> 00:29:56.000
私たちのアプリのスライダーは、ヨセミテとカタリナ島の2つの異なる地形マップの間でモーフィングします。

00:29:56.000 --> 00:30:04.000
シーンにオーディオを導入したので、2つのオーディオソースの間でクロスフェードします。

00:30:04.000 --> 00:30:09.000
オーシャンエミッターエンティティを追加したのと同じ方法で、フォレストオーディオエミッターを追加します。

00:30:09.000 --> 00:30:17.000
スライダーを使用して地形をどのようにモーフィングしているかを見てみましょう。このトランジションにはオーディオも含めます。

00:30:17.000 --> 00:30:22.000
シェーダーグラフ素材のプロパティを使用して、2つの地形の間でモーフィングします。

00:30:22.000 --> 00:30:25.000
それをどうするか見てみましょう。

00:30:25.000 --> 00:30:33.000
ニールスのセッションでは、Reality Composer Proのシェーダーグラフを使用して、この美しいジオメトリ修飾子を作成しました。

00:30:33.000 --> 00:30:38.000
これで、それをシーンに接続して、実行時にパラメータの一部を駆動することができます。

00:30:38.000 --> 00:30:42.000
このシェーダーグラフ素材をスライダーで接続したい。

00:30:42.000 --> 00:30:45.000
そのためにには、入力ノードを宣伝する必要があります。

00:30:45.000 --> 00:30:49.000
ノードをCommandキーを押しながらクリックし、プロモートを選択します。

00:30:49.000 --> 00:30:55.000
これは、材料のこの部分に実行時にデータを提供する予定であることをプロジェクトに伝えます。

00:30:55.000 --> 00:31:02.000
この昇格されたノードProgressに名前を付けるので、実行時にその名前で対処できます。

00:31:02.000 --> 00:31:06.000
コードでこの値を動的に変更できるようになりました。

00:31:06.000 --> 00:31:10.000
私たちは、私たちの材料がオンになっているエンティティへの参照を取得します。

00:31:10.000 --> 00:31:16.000
次に、材料を収容するRealityKitコンポーネントであるModelComponentを取得します。

00:31:16.000 --> 00:31:20.000
ModelComponentから、最初の材料を入手します。

00:31:20.000 --> 00:31:22.000
この特定のエンティティには1つしかありません。

00:31:22.000 --> 00:31:26.000
ShaderGraphMaterialと入力するようにキャストします。

00:31:26.000 --> 00:31:31.000
これで、Progressという名前でパラメータの新しい値を設定できます。

00:31:31.000 --> 00:31:39.000
最後に、マテリアルをModelComponentに格納し、ModelComponentを地形エンティティに戻します。

00:31:39.000 --> 00:31:43.000
次に、それをSwiftUIスライダーに接続します。

00:31:43.000 --> 00:31:52.000
スライダーの値が変わるたびに、0から1の範囲にあるその値を取得し、ShaderGraphMaterialにフィードします。

00:31:52.000 --> 00:31:59.000
次に、2つの地形のアンビエントオーディオトラックをクロスフェードしましょう。

00:31:59.000 --> 00:32:11.000
また、海と森の2つのオーディオエンティティにAmbientAudioComponentを入れたため、ゲインプロパティを使用して音の再生音量を調整できます。

00:32:11.000 --> 00:32:19.000
この時点で、AmbientAudioComponentを持つすべてのエンティティ（この時点で2つすべて、海と森林）を照会します。

00:32:19.000 --> 00:32:28.000
さらに、ある地域または別の地域に行くエンティティをマークできるように、RegionSpecificComponentと呼ばれる別のカスタムコンポーネントを追加しました。

00:32:28.000 --> 00:32:36.000
変更してエンティティに保存するため、audioComponentの可変コピーを取得します。

00:32:36.000 --> 00:32:42.000
リージョンとスライダー値を与えるゲインを計算する関数を呼び出します。

00:32:42.000 --> 00:32:50.000
ゲイン値をAmbientAudioComponentに設定し、コンポーネントをエンティティに保存します。

00:32:50.000 --> 00:32:52.000
それを実際に見てみましょう。

00:32:52.000 --> 00:33:08.000
すごい！

00:33:08.000 --> 00:33:18.000
スライダーを動かすと、シェーダーグラフの素材が地形マップのジオメトリを変更し、森の音がフェードアウトし、海の音が入ってくるのが聞こえます。

00:33:18.000 --> 00:33:28.000
今日は多くの情報を取り上げました。

00:33:28.000 --> 00:33:29.000
要約しましょう。

00:33:29.000 --> 00:33:35.000
Reality Composer ProのコンテンツをXcodeのアプリに読み込む方法を学びました。

00:33:35.000 --> 00:33:40.000
Reality Composer Proで独自のカスタムコンポーネントを作成する方法を検討しました。

00:33:40.000 --> 00:33:46.000
SwiftUIアタッチメントAPIがどのように機能し、エンティティとしてどのように配信されるかを調査しました。

00:33:46.000 --> 00:33:50.000
オーディオを設定し、そのオーディオをコードで再生する方法を見ました。

00:33:50.000 --> 00:33:57.000
そして最後に、プロモーションされたマテリアルプロパティを取得し、コードからそれを駆動する方法を見ました。

00:33:57.000 --> 00:34:01.000
これらのワークフローは、空間体験に命を吹き込むのに役立ちます。

00:34:01.000 --> 00:34:06.000
私はあなたが私たちの新しいプラットフォームで構築するすべての素晴らしいものを見るのを楽しみにしています。

00:34:06.000 --> 00:34:07.000
ありがとうございます。

00:34:07.000 --> 23:59:59.000
♪

