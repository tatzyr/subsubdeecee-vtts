WEBVTT

00:00:00.000 --> 00:00:04.000
♪まろやかなインストゥルメンタルヒップホップ♪

00:00:04.000 --> 00:00:10.000
♪

00:00:10.000 --> 00:00:14.000
こんにちは！私はイワンで、RealityKitチームのエンジニアです。

00:00:14.000 --> 00:00:19.000
私のセッション「空間コンピューティングのためのレンダリングを探る」へようこそ。

00:00:19.000 --> 00:00:24.000
RealityKitは、3Dモデルをレンダリング、アニメーション化、シミュレートするためのフレームワークです。

00:00:24.000 --> 00:00:31.000
RealityKitの最も強力なスーツの1つは、コンテンツにリアルなレンダリングを適用することです。

00:00:31.000 --> 00:00:45.000
RealityKitのレンダリング機能を最大限に活用し、コンテンツの外観を向上させるために、空間コンピューティング用のアプリを開発する際に留意すべきいくつかのレンダリングの考慮事項を共有したいと思いました。

00:00:45.000 --> 00:00:49.000
3Dコンテンツの照明と影から始めます。

00:00:49.000 --> 00:00:53.000
その後、RealityKitの素材の新機能を学びます。

00:00:53.000 --> 00:00:59.000
次に、システムのパフォーマンスを大幅に向上させるラスタライズレートマップを紹介します。

00:00:59.000 --> 00:01:06.000
この最適化でうまく機能するようにコンテンツを調整する方法についての推奨事項を共有します。

00:01:06.000 --> 00:01:14.000
最後に、UIが常にシャープであることを保証するダイナミックコンテンツスケーリングと呼ばれるテクニックを紹介します。

00:01:14.000 --> 00:01:17.000
照明と影から始めましょう。

00:01:17.000 --> 00:01:26.000
iOSとmacOSのRealityKitに精通している場合、その知識のほとんどが空間体験の構築にも当てはまることがわかります。

00:01:26.000 --> 00:01:32.000
コンテンツをリアルに見せるために、RealityKitに画像ベースの照明を導入しました。

00:01:32.000 --> 00:01:41.000
画像ベースの照明、またはIBLは、右側のようなテクスチャを使用して現実的な反射を生成します。

00:01:41.000 --> 00:01:47.000
影は、オブジェクトが互いにどのように配置されているかを理解するのに役立ちます。

00:01:47.000 --> 00:01:54.000
新機能を見る前に、画像ベースの照明のコンポーネントを簡単に見てみましょう。

00:01:54.000 --> 00:02:10.000
IBLには2つの主要なコンポーネントがあります。ARKitによって提供され、部屋の物理的なスペースに固有の環境プローブテクスチャと、OSにパッケージ化されたシステムIBLテクスチャです。

00:02:10.000 --> 00:02:17.000
システムIBLテクスチャは、コンテンツがどの環境でも素晴らしく見えるように、追加のハイライトを追加します。

00:02:17.000 --> 00:02:23.000
2つのコンポーネントが一緒に追加され、組み合わせたIBLテクスチャが生成されます。

00:02:23.000 --> 00:02:29.000
アクティブな環境がある場合は、組み合わせたIBLテクスチャにも影響します。

00:02:29.000 --> 00:02:36.000
今年、RealityKitは、照明をカスタマイズするためにシステムIBLテクスチャをオーバーライドする機能を追加します。

00:02:36.000 --> 00:02:40.000
例を見てみましょう。 例を見てみましょう。

00:02:40.000 --> 00:02:45.000
これは、太陽系の眺めを提供する「ハローワールド」体験です。

00:02:45.000 --> 00:02:50.000
デフォルトでは、RealityKitはシステムIBLを使用して点灯します。

00:02:50.000 --> 00:03:02.000
ただし、新しい画像ベースの光コンポーネントに新しいIBLを割り当てると、システムIBLを置き換え、周囲の没入型環境を使用してそれらのオブジェクトを照らします。

00:03:02.000 --> 00:03:05.000
それがどのように行われるかをお見せしましょう。

00:03:05.000 --> 00:03:08.000
ここでは、まず3Dコンテンツをロードします。

00:03:08.000 --> 00:03:11.000
この場合、それは衛星モデルです。

00:03:11.000 --> 00:03:15.000
次に、Sunlightという環境リソースをロードします。

00:03:15.000 --> 00:03:21.000
地球を取り囲む太陽と星の画像が含まれています。

00:03:21.000 --> 00:03:30.000
IBLを設定するにはモデルと環境リソースの両方が必要なので、両方のロード操作が終了したことを確認しましょう。

00:03:30.000 --> 00:03:33.000
次に、ImageBasedLightComponentを追加します。

00:03:33.000 --> 00:03:38.000
ロードしたばかりの環境リソースを参照しています。

00:03:38.000 --> 00:03:44.000
最後に、ImageBasedLightReceiverComponentを衛星エンティティに追加します。

00:03:44.000 --> 00:03:51.000
これらのレシーバーコンポーネントを他のエンティティに追加して、同じIBLを使用して点灯させることができます。

00:03:51.000 --> 00:03:56.000
そして、RealityKitで照明をカスタマイズするのはとても簡単です。

00:03:56.000 --> 00:04:01.000
次に、アプリケーションに影を追加する方法を見てみましょう。 影を追加します。

00:04:01.000 --> 00:04:09.000
この花瓶のような3Dオブジェクトを浮遊面の上に置く簡単な例を考えてみましょう。

00:04:09.000 --> 00:04:16.000
影がオンになっていないと、花瓶と飛行機の相対的な位置を理解するのは難しいかもしれません。

00:04:16.000 --> 00:04:25.000
しかし、RealityKitの接地影を追加するだけで、花瓶が飛行機の中心の上にあることがはるかに明確になります。

00:04:25.000 --> 00:04:28.000
コードでこれを行う方法を見てみましょう。

00:04:28.000 --> 00:04:31.000
花瓶モデルをロードすることから始めます。

00:04:31.000 --> 00:04:36.000
ここでは、flower_tulipは私たちのプロジェクトの3Dモデルの名前です。

00:04:36.000 --> 00:04:40.000
次に、グラウンディングシャドウコンポーネントを追加します。

00:04:40.000 --> 00:04:43.000
castsShadowフラグをtrueに設定してください。

00:04:43.000 --> 00:04:45.000
そして、それだけです!

00:04:45.000 --> 00:04:48.000
花瓶の実体は今、接地影を投げかけます。

00:04:48.000 --> 00:04:49.000
シンプルですね。

00:04:49.000 --> 00:04:56.000
グラウンディングシャドウは、物理環境のオブジェクトだけでなく、3Dモデルの上に表示されます。

00:04:56.000 --> 00:05:10.000
カスタムIBLを使用してシーンを照らし、グラウンディングシャドウを含めると、コンテンツをはるかに良く見せることができますが、素材を微調整することでオブジェクトの外観に直接取り組むこともできます。

00:05:10.000 --> 00:05:17.000
macOSとiOSで利用可能なRealityKitの素材のほとんどは、xrOSでも使用できます。

00:05:17.000 --> 00:05:20.000
それらをすぐに見直しましょう。

00:05:20.000 --> 00:05:24.000
最も一般的に使用される材料はPhysicallyBasedMaterialです。

00:05:24.000 --> 00:05:35.000
RealityKitのPhysicallyBasedMaterialは照明に反応し、プラスチックや金属などのさまざまな現実世界の材料を表現するために使用できます。

00:05:35.000 --> 00:05:41.000
SimpleMaterialは照明にも反応しますが、パラメータの小さなサブセットを使用します。

00:05:41.000 --> 00:05:45.000
素早い実験には特に適しています。

00:05:45.000 --> 00:05:48.000
UnlitMaterialは照明に反応しません。

00:05:48.000 --> 00:05:54.000
言い換えれば、それは変化する照明条件の下で一定の外観を維持します。

00:05:54.000 --> 00:06:03.000
VideoMaterialは、ムービーファイルをエンティティの表面にマッピングできる点灯されていない素材のバリエーションです。

00:06:03.000 --> 00:06:10.000
これらの素材に加えて、RealityKitはShaderGraphMaterialと呼ばれる新しいタイプの素材を導入しています。

00:06:10.000 --> 00:06:19.000
Reality Composer Proで新しいShaderGraphMaterialを作成するか、MaterialXファイルから読み込むことができます。

00:06:19.000 --> 00:06:27.000
ShaderGraphMaterialの詳細については、「Explore Materials in Reality Composer Pro」をご覧ください。

00:06:27.000 --> 00:06:34.000
これらすべての材料の色出力は、トーンマッピングと呼ばれる特別なステップを経ます。

00:06:34.000 --> 00:06:42.000
トーンマッピングは、RealityKitが素材の色出力にデフォルトで適用する変換です。

00:06:42.000 --> 00:06:47.000
さまざまな技術を使用して、より自然な知覚色を可能にします。

00:06:47.000 --> 00:06:52.000
そのようなテクニックの1つは、1より上の値を可視範囲に再マッピングすることです。

00:06:52.000 --> 00:06:57.000
例を挙げて実演しましょう。

00:06:57.000 --> 00:07:01.000
これは、トーンマッピングが無効になっているテレビの3Dレンダリングです。

00:07:01.000 --> 00:07:06.000
非常に明るい値のテクスチャをディスプレイに割り当てました。

00:07:06.000 --> 00:07:14.000
さて、トーンマッピングを有効にすると、これらの花びらのような明るい領域で詳細を見ることができます。

00:07:14.000 --> 00:07:27.000
トーンマッピングは一般的にうまく機能し、美しいビジュアルをレンダリングします。しかし、いくつかのユースケースでは、トーンマッピングをオプトアウトする必要があるオブジェクトの正確な色を表示したい場合があります。

00:07:27.000 --> 00:07:30.000
例を見てみましょう。 例を見てみましょう。

00:07:30.000 --> 00:07:37.000
これは、信号機と「Stop」、「Wait」、「Go」というラベルが付いた3つのボタンを示すシンプルなアプリケーションです。

00:07:37.000 --> 00:07:44.000
信号機自体は3Dモデルで、3つのボタンはSwiftUIを使用して追加されました。

00:07:44.000 --> 00:07:59.000
ランプの色とボタンの色を正確に一致させるために、点灯していない材料は、照明条件に関係なく、オブジェクトの同じ一定の外観を維持するため、ランプに点灯していない材料を使用することができます。

00:07:59.000 --> 00:08:07.000
ただし、点灯されていない素材の出力は、すべてのRealityKit素材でデフォルトでオンになっているトーンマッピングの影響を受けます。

00:08:07.000 --> 00:08:16.000
したがって、SwiftUIボタンとランプの素材に同じ色が割り当てられていても、それらは互いにわずかに異なって見えるかもしれません。

00:08:16.000 --> 00:08:26.000
あなたが見るスクリーンショットは、トーンマッピングが有効になっている状態で撮影されました。ランプ素材のトーンマッピングが無効になっているときの様子をお見せしましょう。

00:08:26.000 --> 00:08:31.000
ランプとボタンの色が正確に一致していることに気付くでしょう。

00:08:31.000 --> 00:08:35.000
ランプ素材のトーンマッピングをもう一度切り替えましょう。

00:08:35.000 --> 00:08:42.000
これはトーンマッピングが有効になっており、これはトーンマッピングが無効になっている場合です。

00:08:42.000 --> 00:08:48.000
トーンマッピングをコードで切り替える方法を示すコードサンプルを見てみましょう。

00:08:48.000 --> 00:08:51.000
信号機モデルをロードすることから始めます。

00:08:51.000 --> 00:08:57.000
ここでは、traffic_lightは私たちのプロジェクトの3Dモデルの名前です。

00:08:57.000 --> 00:09:01.000
次に、red_lightという名前のエンティティを見つけます。

00:09:01.000 --> 00:09:06.000
このエンティティは、信号機の上部ランプに対応しています。

00:09:06.000 --> 00:09:10.000
エンティティを取得したら、そのモデルコンポーネントにアクセスします。

00:09:10.000 --> 00:09:13.000
次に、新しい照明のない素材を作成します。

00:09:13.000 --> 00:09:21.000
目的の色とapplyPostProcessToneMapと呼ばれる新しいブールパラメータの両方を渡します。

00:09:21.000 --> 00:09:30.000
このブールパラメータは、このマテリアルのトーンマッピング変換を無効にするためにfalseに設定されています。

00:09:30.000 --> 00:09:37.000
最後に、モデルコンポーネントの材料を交換し、モデルコンポーネントをエンティティに割り当てます。

00:09:37.000 --> 00:09:40.000
これは3つのランプのそれぞれに対して行われます。

00:09:40.000 --> 00:09:46.000
これで、ボタンの色とランプの色が密接に一致するはずです。

00:09:46.000 --> 00:09:54.000
applyPostProcessToneMapフラグは、シーンの色の正確な表現を表示したい場合に便利です。

00:09:54.000 --> 00:10:01.000
これは、RealityKitを使用してメニューやヘッドアップディスプレイのようなものを構築するときに便利です。

00:10:01.000 --> 00:10:08.000
この新しいプロパティは、Reality Composer Proのマテリアルエディタでも公開されています。

00:10:08.000 --> 00:10:11.000
さて、いくつかの品質に関する考慮事項を見てみましょう。

00:10:11.000 --> 00:10:16.000
空間コンピューティングのラスタライズレートマップから始めます。

00:10:16.000 --> 00:10:24.000
ヘッドセットで使用されるディスプレイは高解像度で、OSはこれらのディスプレイを1秒間に何度も更新する必要があります。

00:10:24.000 --> 00:10:27.000
これを視覚的に説明させてください。

00:10:27.000 --> 00:10:34.000
すでにご存知かもしれませんが、ヘッドセットは人の目がどこを見ているかを正確に検出する能力を持っています。

00:10:34.000 --> 00:10:41.000
これは、人が目を右に動かしてから中央に戻るシミュレートされたシナリオです。

00:10:41.000 --> 00:10:46.000
黄色の円は、その人の焦点の中心点を表しています。

00:10:46.000 --> 00:10:52.000
その点を囲む領域は輝きで強調され、周辺は暗くなります。

00:10:52.000 --> 00:10:59.000
ラスタライズレートマップにより、暗くなった領域で実行される計算が少なくなります。

00:10:59.000 --> 00:11:06.000
いつでも、ハイライトされた領域が周辺領域と比較して小さいことがわかります。

00:11:06.000 --> 00:11:12.000
これにより、システムはメモリとパフォーマンスを大幅に節約できます。

00:11:12.000 --> 00:11:17.000
RealityKitでは、この最適化が自動的に有効になります。

00:11:17.000 --> 00:11:27.000
システムのパフォーマンスが大幅に向上しますが、状況によっては、この最適化でうまく機能するようにコンテンツを調整する必要があるかもしれません。

00:11:27.000 --> 00:11:35.000
たとえば、ここにヤシの葉の資産があります。画面の中央に置くと、シャープで詳細に見えます。

00:11:35.000 --> 00:11:44.000
しかし、オブジェクトを左に動かし、再び目の動きのシミュレーションを適用すると、ヤシの葉のちらつきを観察することができます。

00:11:44.000 --> 00:11:52.000
目の方向を表す黄色の円が画面の右端に近い場合、ちらつきは特に強いです。

00:11:52.000 --> 00:12:06.000
ちらつきは、ラスタライズレートマップが人が見ているポイントの周りのより高いディテールを可能にし、目がそこから遠ざかるにつれてヤシの葉の周りのピクセルがより低いディテールでレンダリングされるために起こります。

00:12:06.000 --> 00:12:12.000
これで、コンテンツのいくつかのパラメータを調整するだけで、ちらつきを減らすことができます。

00:12:12.000 --> 00:12:14.000
これを見てみましょう。 見ていきましょう。

00:12:14.000 --> 00:12:21.000
これは、上部に赤いワイヤーフレームオーバーレイが付いた同じヤシの葉の資産の表現です。

00:12:21.000 --> 00:12:24.000
ここには小さな三角形がたくさんあることがわかります。それはたくさんの小さな三角形があります。

00:12:24.000 --> 00:12:28.000
これらの小さな三角形は、周辺でちらつく理由でした。

00:12:28.000 --> 00:12:38.000
三角形を大きくし、細かいディテールを不透明度のテクスチャに保存するだけで、ちらつきを減らすことができます。

00:12:38.000 --> 00:12:43.000
資産を調整した後のシミュレーションの様子は次のとおりです。

00:12:43.000 --> 00:12:53.000
RealityKitは、アセットがロードされたときに不透明度マップの低解像度バージョンを自動的に生成するため、この3Dモデルは調整後に見栄えが良くなります。

00:12:53.000 --> 00:13:03.000
これらの低解像度バージョンのテクスチャはミップマップと呼ばれ、低詳細領域の外観を改善するためにGPUによって自動的に使用されます。

00:13:03.000 --> 00:13:12.000
ラスタライズレートマップの詳細については、記事「異なるラスタライズレートでのレンダリング」を参照してください。

00:13:12.000 --> 00:13:23.000
ラスタライズレートマップと同様に、SwiftUIを使用して作成されたコンテンツの外観を自動的に改善する「動的コンテンツスケーリング」と呼ばれる別の手法があります。

00:13:23.000 --> 00:13:26.000
見てみましょう。 

00:13:26.000 --> 00:13:31.000
これは、グリッドに配置された月のリストを表示するアプリケーションです。

00:13:31.000 --> 00:13:36.000
毎月はテキストラベルで表されます。

00:13:36.000 --> 00:13:44.000
目が6月を見ると、システムはその領域のテキストを最高レベルの詳細でラスタライズします。

00:13:44.000 --> 00:13:55.000
「6月」を囲む青でマークされた領域は、わずかに縮小された詳細レベルでラスタライズされますが、それでも全体的に高品質を維持します。

00:13:55.000 --> 00:14:07.000
しかし、紫色でマークされた領域は、人間の視覚システムが周辺でより少ない詳細を知覚し、それほど目立たないため、はるかに低い詳細レベルでラスタライズされています。

00:14:07.000 --> 00:14:17.000
目が見ているものに基づいて、さまざまなレベルの詳細でこの種のラスタライズは、「動的コンテンツスケーリング」と呼ばれます。

00:14:17.000 --> 00:14:27.000
このシステムは、UIコンテンツを適切なスケールで描画するために動的コンテンツスケーリングに依存し、常にシャープであることを保証します。

00:14:27.000 --> 00:14:32.000
動的コンテンツスケーリングは、ラスタライズされたコンテンツのメモリの相対サイズに影響します。

00:14:32.000 --> 00:14:42.000
言い換えれば、私たちのテキストラベルは、目が見ているポイントにどれだけ近いかに応じて、異なるサイズに拡大縮小されます。

00:14:42.000 --> 00:14:51.000
たとえば、「6月」と書かれたラベルが最大であることがわかります - それは最も解像度と詳細を持っています。

00:14:51.000 --> 00:14:58.000
次に、1月、2月、3月などの8ヶ月のグループがあり、詳細がわずかに少ないです。

00:14:58.000 --> 00:15:06.000
最後に、目から見る方向から最も遠い4月、8月、12月の3ヶ月のグループがあります。

00:15:06.000 --> 00:15:11.000
その最後のグループは、メモリ内のより小さな画像で表されます。

00:15:11.000 --> 00:15:16.000
では、動的コンテンツスケーリングを有効にする方法を理解しましょう。

00:15:16.000 --> 00:15:23.000
UIKitとSwiftUIを使用している場合、アプリケーションは自動的にこのテクニックの恩恵を受けます。

00:15:23.000 --> 00:15:30.000
UIを構築するためにCore Animationフレームワークに依存している場合は、動的コンテンツのスケーリングを可能にする新しいAPIがあります。

00:15:30.000 --> 00:15:34.000
このAPIを見てみましょう。 では、このAPIを見てみましょう。

00:15:34.000 --> 00:15:42.000
動的コンテンツスケーリングは、CALayer wantsDynamicContentScalingのプロパティをtrueに設定することで有効にできます。

00:15:42.000 --> 00:15:52.000
この手法は、より高い解像度でのラスタライズに依存しているため、主にビットマップベースのコンテンツで使用することはお勧めできません。

00:15:52.000 --> 00:16:01.000
動的コンテンツのスケーリングに関する推奨事項の完全なリストは、developer.apple.comで見つけることができます。

00:16:01.000 --> 00:16:04.000
私たちが学んだことをすべてまとめさせてください。

00:16:04.000 --> 00:16:12.000
私たちは、RealityKitアプリケーションに画像ベースのライトと接地影を追加する方法を検討することから始めました。

00:16:12.000 --> 00:16:19.000
次に、新しいShaderGraphMaterialなど、空間体験に利用できる資料をレビューしました。

00:16:19.000 --> 00:16:24.000
また、照明されていない素材のトーンマッピングを制御する方法も学びました。

00:16:24.000 --> 00:16:36.000
次に、周辺でのちらつきを減らすために3Dモデルを調整する方法の例など、ラスタライズレートマップが空間コンピューティングにどのように使用されるかを学びました。

00:16:36.000 --> 00:16:43.000
最後に、動的コンテンツスケーリングがシステムでどのように機能し、それをどのように活用できるかを学びました。

00:16:43.000 --> 00:16:51.000
私たちは今年のリリースに非常に興奮しており、xrOSで構築する美しい空間体験を見るのが待ちきれません。

00:16:51.000 --> 23:59:59.000
ありがとうございます。

