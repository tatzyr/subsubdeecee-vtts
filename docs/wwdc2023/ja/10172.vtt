WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:14.000
ゾーイ：こんにちは、私はアップルのコンパイラチームのエンジニア、ゾーイです。

00:00:14.000 --> 00:00:25.000
今日は、SwiftとC++を一緒に使用できるXcode 15の新機能であるSwiftとC++の相互運用性を紹介します。

00:00:25.000 --> 00:00:28.000
この講演は2つの部分に分かれます。

00:00:28.000 --> 00:00:32.000
まず、相互運用性の基本を説明します。

00:00:32.000 --> 00:00:40.000
次に、SwiftでC++ APIを自然で安全に感じさせる方法を紹介します。

00:00:40.000 --> 00:00:46.000
Swiftは、Objective-Cで書かれた多くの大きなアプリやコードベースがある世界に参入しました。

00:00:46.000 --> 00:00:54.000
Swiftがこの既存のコードを活用し、これらのコードベースに段階的に採用することが不可欠でした。

00:00:54.000 --> 00:01:03.000
今日、Swiftはこの相互運用性を次のレベルに引き上げ、さらに多くの場所でSwiftを採用することができます。

00:01:03.000 --> 00:01:12.000
大規模なC ++コードベースをお持ちの場合は、双方向の相互運用性を利用してSwiftを段階的に採用できるようになりました。

00:01:12.000 --> 00:01:20.000
また、アプリのC++ライブラリにアクセスする必要がある場合は、Objective-Cブリッジングレイヤーを書く必要がなくなります。

00:01:20.000 --> 00:01:28.000
サンプルアプリを見て、C++コードベースにSwiftを採用するのがどれほど簡単か見てみましょう。

00:01:28.000 --> 00:01:30.000
私は写真編集アプリに取り組んでいます。

00:01:30.000 --> 00:01:38.000
カメラロールから写真を選択したり、色を反転させたり、明るさを変更したりできます。

00:01:38.000 --> 00:01:42.000
コードに入る前に、私のアプリの構造を見てみましょう。

00:01:42.000 --> 00:01:48.000
アプリは、画像処理フレームワークとユーザーインターフェイスコードの2つの部分に分けることができます。

00:01:48.000 --> 00:01:54.000
私のアプリが基づいている画像処理フレームワークは、C++で書かれています。

00:01:54.000 --> 00:02:07.000
ユーザーインターフェイスレイヤーがC ++フレームワークと簡単に通信できるようにしたかったので、Objective-C ++を使用して、ViewControllerなどのユーザーインターフェイスのほとんどを実装しました。

00:02:07.000 --> 00:02:13.000
今、私のアプリのユーザーがカメラロールから数枚の写真を選んで編集できるようにしたい。

00:02:13.000 --> 00:02:21.000
SwiftUIにはこれを簡単にする新しいPhotoPickerビューがあると聞いたので、アプリでSwiftの採用を始めたいと思います。

00:02:21.000 --> 00:02:31.000
幸いなことに、Xcode 15から始めて、Objective-C++コードベースにSwiftを簡単に採用でき、すべてのC ++ APIにアクセスできます。

00:02:31.000 --> 00:02:36.000
では、プロジェクトにSwiftファイルを追加することから始めましょう。

00:02:36.000 --> 00:02:47.000
C++フレームワークを使用しているため、XcodeはC++ APIを自動的にインポートするので、ブリッジングヘッダーは必要ありません。

00:02:47.000 --> 00:02:53.000
次に、プロジェクトのビルド設定でC++の相互運用性を有効にする必要があります。

00:02:53.000 --> 00:03:02.000
ご存知のように、SwiftはすでにCおよびObjective-C APIを呼び出すことができるため、ビルド設定は現在CおよびObjective-Cモードに設定されています。

00:03:02.000 --> 00:03:07.000
しかし、私はこれをC++に変更することができます。

00:03:07.000 --> 00:03:16.000
設定がC++とObjective-C++を読み取るようになったので、C++イメージキットフレームワークからAPIを直接呼び出すことができます。

00:03:16.000 --> 00:03:27.000
Swiftファイルに戻ると、他のSwiftモジュールと同じようにフレームワークをインポートでき、コマンドでモジュール名をクリックしてその内容を表示できます。

00:03:27.000 --> 00:03:36.000
さて、これらはSwift APIのように見えるかもしれませんが、実際には私のC ++ ImageKitライブラリからのものです。これはSwiftコンパイラがそれらを見る方法です。

00:03:36.000 --> 00:03:41.000
今日使用するAPIをいくつか見てみましょう。 いくつか見てみましょう。

00:03:41.000 --> 00:03:47.000
下部から、CxxImageEngineタイプの静的メンバーが表示されます。

00:03:47.000 --> 00:03:51.000
これは現在、安全でないポインタとしてインポートされていますが、後で詳しく説明します。

00:03:51.000 --> 00:03:59.000
CxxImageEngineには、loadImageとgetImagesという他のメンバーがいくつかあり、すぐに使用します。

00:03:59.000 --> 00:04:10.000
今、私は先に進み、C ++と話す2つの方法に集中できるように、私のフォトピッカーのすべてのUIをドロップします。

00:04:10.000 --> 00:04:18.000
共有されたCxxImageEngineをつかみ、選択した各画像のloadImageを呼び出すと、エンジンに読み込むことができます。

00:04:18.000 --> 00:04:22.000
うわー、SwiftでC++メソッドを呼び出すのはとても簡単です。

00:04:22.000 --> 00:04:29.000
SwiftUIビューが完成したので、Objective-C++ ViewControllerで使いたいです。

00:04:29.000 --> 00:04:36.000
これを行うには、Objective-C++コードからアクセスできるように、構造体を公開する必要があります。

00:04:36.000 --> 00:04:39.000
すごい！私のSwiftコードはすべて正常に構築されました。

00:04:39.000 --> 00:04:47.000
これで、ViewControllerファイルに移動して、Swiftが生成したヘッダーをインポートできます。

00:04:47.000 --> 00:04:50.000
このヘッダーには、私のすべてのパブリックSwift APIが含まれています。

00:04:50.000 --> 00:04:56.000
生成されたヘッダーをインポートしたので、C++でSwiftコードを呼び出すことができます。

00:04:56.000 --> 00:05:00.000
まず、SwiftUIビューを構築します。

00:05:00.000 --> 00:05:06.000
その後、現在のメソッドを呼び出すことができます。

00:05:06.000 --> 00:05:11.000
そして、Xcodeはコードの完成に役立ちます。

00:05:11.000 --> 00:05:17.000
これをデバイス上でテストしましょう。

00:05:17.000 --> 00:05:27.000
アプリを構築して実行した後、Objective-C++アプリに直接インポートされた新しいSwiftUIビューを見ることができます。

00:05:27.000 --> 00:05:31.000
これは、真の双方向の相互運用性の例でした。

00:05:31.000 --> 00:05:38.000
私はSwiftでC++の型と関数をシームレスに使用することができ、その逆も同様でした。

00:05:38.000 --> 00:05:47.000
C++では、ビューの本体がC++フレームワークに呼び戻されるSwiftUIビューを構築して使用することができました。

00:05:47.000 --> 00:05:54.000
すべての統合はSwiftコンパイラによって自動的に行われたので、ブリッジングレイヤーを書く必要はありませんでした。

00:05:54.000 --> 00:06:05.000
そして、すべてのAPIは直接的でネイティブだったので、相互運用する他のほとんどの言語とは異なり、Swiftまたはその逆でC ++ APIを呼び出すときにオーバーヘッドはありません。

00:06:05.000 --> 00:06:15.000
今日はかなり小さなアプリで作業していますが、Swiftコンパイラは大規模で複雑なコードベースでの相互運用性をサポートできます。

00:06:15.000 --> 00:06:21.000
Swiftは、標準ライブラリと他の場所の両方から、ほとんどのC++コレクションをインポートできます。

00:06:21.000 --> 00:06:26.000
Swiftは、関数テンプレートとクラステンプレートの専門分野を処理できます。

00:06:26.000 --> 00:06:32.000
また、共有ポインタや同様のユーザー定義型を使用してメモリの管理をサポートしています。

00:06:32.000 --> 00:06:35.000
Swiftは、これらのインポートされたAPIを高いレベルで理解できます。

00:06:35.000 --> 00:06:46.000
たとえば、共有ポインタの保持およびリリース操作について知っており、この高レベルの知識を使用して一連の強力な最適化を適用できます。

00:06:46.000 --> 00:06:55.000
他の方向では、構造体、クラス、そのメソッド、その他のメンバーなど、ほとんどのSwift APIをC++に公開することができます。

00:06:55.000 --> 00:07:02.000
時間の経過とともに進化する配列や回復力のあるタイプなどのジェネリックタイプを公開することもできます。

00:07:02.000 --> 00:07:14.000
また、C++の相互運用性はXcodeで完全にサポートされているため、両方の言語でコード補完、定義へのジャンプ、デバッガのサポートを受けることができます。

00:07:14.000 --> 00:07:18.000
これらは、C++の相互運用性でサポートされているAPIのほんの一部です。

00:07:18.000 --> 00:07:32.000
Swiftコンパイラは、これらすべてのAPIなどを使用する大規模なコードベース間の相互運用性をサポートし、言語間でまとまりのある体験を促進し、さらに多くの場所でSwiftを採用できるようにします。

00:07:32.000 --> 00:07:44.000
相互運用性の基本を網羅したので、この機能について詳しく掘り下げ、SwiftでC ++ APIを自然で安全に感じさせる方法をいくつか探りましょう。

00:07:44.000 --> 00:07:52.000
Swiftコンパイラは、ほとんどのC++ APIを自動的にインポートし、安全なSwift APIとして表現することができます。

00:07:52.000 --> 00:08:06.000
たとえば、デフォルトでは、C ++タイプはSwift構造体としてインポートされ、C ++演算子は同様のSwift演算子にマッピングされ、コンテナは自動的にコレクションとしてインポートされます。

00:08:06.000 --> 00:08:14.000
しかし、コンパイラでは、APIのインポート方法を微調整し、さらに自然に感じるAPIを公開することもできます。

00:08:14.000 --> 00:08:23.000
アノテーションを使用して、APIに関する詳細情報をコンパイラに提供することで、これを行うことができます。

00:08:23.000 --> 00:08:30.000
たとえば、関数やメソッドは、Swiftでは自然に感じられないC++の命名規則を使用するかもしれません。

00:08:30.000 --> 00:08:41.000
このような場合、アノテーションを使用して、インポートされた関数の名前を変更したり、引数ラベルを追加したり、ゲッターとセッターを計算されたプロパティとしてインポートしたりできます。

00:08:41.000 --> 00:08:52.000
注釈は、参照セマンティクスなどの高レベルのパターンを説明し、いくつかのタイプをSwiftクラスとしてインポートするのにも役立ちます。

00:08:52.000 --> 00:08:58.000
または、実際に問題ないのにAPIが安全ではないと思われる場合は、Swiftを修正してください。

00:08:58.000 --> 00:09:05.000
これらの注釈は、SwiftがインポートしているAPIに関する情報を伝える強力な方法です。

00:09:05.000 --> 00:09:19.000
サンプルアプリで使用しているいくつかの異なるAPIを特定し、これらの注釈を使用して、Swiftが安全で直感的に感じる方法でAPIをインポートする方法を探りましょう。

00:09:19.000 --> 00:09:29.000
フォトピッカーが完成したので、編集した写真をフォトライブラリに保存するための保存ボタンも追加したいです。

00:09:29.000 --> 00:09:36.000
Swiftに戻ると、インポートしたすべてのAPIをもう一度見ることができます。

00:09:36.000 --> 00:09:39.000
まず、保存する写真を集める必要があります。 保存する必要があります。

00:09:39.000 --> 00:09:44.000
そして、私はgetImages関数を使ってそれを行うことができます。

00:09:44.000 --> 00:09:49.000
getImages関数はC++ベクトルを返します。

00:09:49.000 --> 00:09:55.000
このメソッドを呼び出す前に、ベクトルがSwiftでどのように動作するかの詳細を理解しましょう。

00:09:55.000 --> 00:10:01.000
Swiftタイプは、値タイプと参照タイプの2つのカテゴリに分類されます。

00:10:01.000 --> 00:10:08.000
Swiftでは、構造体は値型を表し、クラスは参照型を表します。

00:10:08.000 --> 00:10:15.000
デフォルトでは、C++タイプはSwiftで値タイプとしてインポートされます。

00:10:15.000 --> 00:10:20.000
したがって、SwiftはSwift構造体のように振る舞う値型としてベクトルをインポートします。

00:10:20.000 --> 00:10:31.000
ベクトルと他のSwift構造体の唯一の違いは、Swiftがコピーコンストラクタなどのタイプの特別なメンバーを使用してライフタイムを管理することです。

00:10:31.000 --> 00:10:35.000
これらのコピーコンストラクタは、多くの場合、ディープコピーを実行します。

00:10:35.000 --> 00:10:44.000
したがって、変更されたときにのみコピーされるSwift配列とは異なり、Swiftがベクトルをコピーすると、すべての要素がコピーされます。

00:10:44.000 --> 00:11:02.000
画像のベクトルがわかったので、フォアループでベクトルを反復して各画像を取得し、画像をuiImageに戻し、画像をフォトライブラリに保存することができます。

00:11:02.000 --> 00:11:10.000
このforループは、ベクトルには開始メソッドと終了メソッドがあるため、Swiftは自動的にコレクションとしてインポートします。

00:11:10.000 --> 00:11:20.000
このコレクションへの自動適合により、ベクトルをSwift配列に簡単に変換でき、マップやフィルターなどのメソッドにアクセスできます。

00:11:20.000 --> 00:11:32.000
安全のために、Swiftの安全モデルに適合しないC++イテレータAPIではなく、これらのSwift Collection APIを使用することが重要です。

00:11:32.000 --> 00:11:39.000
これらのC ++イテレータを使用すると、生涯の問題や無効なメモリアクセスなどのバグを簡単に導入できます。

00:11:39.000 --> 00:11:48.000
一方、SwiftコレクションAPIは、C++コレクションで動作する場合でも、完全に安全です。

00:11:48.000 --> 00:11:58.000
Swiftコンパイラは、安全でないC++ APIを利用できないとマークし、より安全な代替案を提案することで、これらのより安全なAPIに向けてあなたを導くのに役立ちます。

00:11:58.000 --> 00:12:02.000
私のSwiftアプリに戻りましょう。

00:12:02.000 --> 00:12:04.000
私を悩ませている何かがあります。 

00:12:04.000 --> 00:12:09.000
C++ImageEngineを使用するたびに、それが安全でないポインタであることを思い出します。

00:12:09.000 --> 00:12:15.000
実際、このタイプは常にSwiftとC++の両方でポインタとして使用されます。

00:12:15.000 --> 00:12:19.000
これは、このタイプが「参照セマンティクス」と呼ばれるものを持っているためです。

00:12:19.000 --> 00:12:28.000
これは、タイプがオブジェクトアイデンティティを持つことを意図していることを意味し、コピーは個別の値ではなく、同じメモリへの参照を共有します。

00:12:28.000 --> 00:12:35.000
前に述べたように、Swiftタイプは値タイプと参照タイプの2つのカテゴリに分類されます。

00:12:35.000 --> 00:12:44.000
Objective-Cはまた、値型と参照型を明確に区別できるため、Objective-C型を構造体やクラスに簡単にマッピングできます。

00:12:44.000 --> 00:12:59.000
C ++の場合、SwiftやObjective-Cとは異なり、C ++は値型と参照型の間に強い区別がないため、どの型がどのカテゴリに分類されるかは明らかではありません。

00:12:59.000 --> 00:13:03.000
したがって、デフォルトでは、コンパイラはすべてを値型としてインポートします。

00:13:03.000 --> 00:13:14.000
しかし、Swiftは、C++コードに注釈を追加することで、参照型またはクラス型としていくつかのものをインポートするオプションも提供します。

00:13:14.000 --> 00:13:21.000
そのため、SWIFT_SHARED_REFERENCE属性を使用して、CxxImageEngineをSwiftクラスにマッピングできます。

00:13:21.000 --> 00:13:34.000
この属性は、Swiftが型が常にポインタまたは参照として渡されることを強制し、Swiftの安全でないポインタではなく、単に型でこの間接を表すことを意味します。

00:13:34.000 --> 00:13:42.000
コードを安全にするために、Swiftは必要に応じて参照を保持および解放することで、参照の寿命を自動的に管理します。

00:13:42.000 --> 00:13:48.000
この種の参照カウントを有効にするには、これらの保持機能とリリース機能の両方をSwiftに提供する必要があります。

00:13:48.000 --> 00:13:55.000
C++ ImageKitヘッダーを掘り下げてみましょう。

00:13:55.000 --> 00:14:01.000
SWIFT_SHARED_REFERENCEのような注釈にアクセスするためにswift/bridgingをインポートできます。

00:14:01.000 --> 00:14:08.000
これで、Swiftが呼び出すことができる保持関数とリリース関数の両方を指定して、この注釈をタイプに適用できます。

00:14:08.000 --> 00:14:10.000
すごい！

00:14:10.000 --> 00:14:18.000
今、私がもはやポインタを逆参照する必要がないことを私に伝えているいくつかのSwiftコンパイラエラーがあります。

00:14:18.000 --> 00:14:24.000
このC++ APIをSwiftでくつろげるために、最後にできることが1つあります。

00:14:24.000 --> 00:14:28.000
ここfor-loopでは、getImagesと呼んでいます。

00:14:28.000 --> 00:14:36.000
このようにゲッターとセッターを定義することは、C++ではかなり一般的なパターンですが、Swiftではあまり自然とは感じません。

00:14:36.000 --> 00:14:43.000
これをSwiftでもう少しネイティブに感じさせるために、私はswift/bridgingから別の注釈を使用することができます。

00:14:43.000 --> 00:14:49.000
SWIFT_COMPUTED_PROPERTY属性は、ゲッターとセッターに適用して、ペアをSwiftの計算プロパティにマッピングできます。

00:14:49.000 --> 00:14:57.000
もう一度C++ヘッダーに移動して、この注釈を適用しましょう。

00:14:57.000 --> 00:15:11.000
これで、定義をセカンダリクリックしてSwift呼び出し元を選択することで、getImagesメソッドの呼び出し元を検索できます。これにより、単に「画像」に名前を変更できます。

00:15:11.000 --> 00:15:12.000
美しい！

00:15:12.000 --> 00:15:20.000
では、最後にもう一度アプリを試してみましょう。

00:15:20.000 --> 00:15:26.000
いくつかの写真を選択して、カメラロールに保存することができます。

00:15:26.000 --> 00:15:29.000
すごい！

00:15:29.000 --> 00:15:35.000
この講演では、APIのインポート方法を改善するために、わずか2つの注釈を使用しました。

00:15:35.000 --> 00:15:40.000
しかし、C++ヘッダーで使用できる注釈は他にもたくさんあります。

00:15:40.000 --> 00:15:46.000
それらにアクセスするために必要なのは、スウィフト/ブリッジングをインポートすることだけです。

00:15:46.000 --> 00:15:58.000
Xcode 15でC++の相互運用性を有効にするには、C++とObjective-Cの相互運用性モードをCとObjective-CからC++とObjective-C++に変更します。

00:15:58.000 --> 00:16:05.000
また、SwiftとC++の相互運用性は、LinuxやWindowsだけでなく、すべてのAppleプラットフォームでサポートされています。

00:16:05.000 --> 00:16:15.000
C++は大規模で複雑な言語であり、C++ APIをインポートし、フィードバックでSwift APIを公開する方法を改善したいと考えています。

00:16:15.000 --> 00:16:22.000
C++ APIのインポート方法を変更すると、新しいバージョンの相互運用性が作成されます。

00:16:22.000 --> 00:16:32.000
これは、これらの新機能を引き受けたいときに選択できることを意味し、今日あなたの開発で自信を持ってC ++ APIを使い始めることができます。

00:16:32.000 --> 00:16:37.000
問題に気付いたり、何か提案があれば、ぜひご意見をお聞かせください。

00:16:37.000 --> 00:16:41.000
フィードバックアシスタントを使って教えてください。

00:16:41.000 --> 00:16:47.000
C++の相互運用性は、完全にオープンソースのSwiftコンパイラワークグループによって設計されました。

00:16:47.000 --> 00:16:54.000
ワークグループは、12以上の企業や学校のエンジニアと学生で構成されています。

00:16:54.000 --> 00:17:04.000
ワークグループは、SwiftとC++の相互運用性の将来のビジョンを定義する2つの文書を開発し、時間の経過とともにこの機能の進化を導きます。

00:17:04.000 --> 00:17:07.000
ワークグループに参加して、フォーラムに参加できます。

00:17:07.000 --> 00:17:11.000
Swift.orgに向かうだけです。

00:17:11.000 --> 00:17:17.000
Swift 5.9では、オーバーヘッドなしでC++ APIを自動的かつ安全に使用できます。

00:17:17.000 --> 00:17:23.000
新しいSwiftコードをC++に戻すことで、Swiftを段階的に採用できます。

00:17:23.000 --> 00:17:32.000
また、コンパイラに詳細情報を提供することで、インポートされたAPIを改善し、微調整することができます。

00:17:32.000 --> 23:59:59.000
見てくれてありがとう、そしてすべてのC++コードベースでSwiftを採用して楽しんでください。

