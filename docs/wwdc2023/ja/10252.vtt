WEBVTT

00:00:00.000 --> 00:00:11.000
♪ ♪

00:00:11.000 --> 00:00:14.000
ケビン・キャシー：こんにちは、私の名前はケビンで、プレビューに取り組んでいます。

00:00:14.000 --> 00:00:25.000
ソフトウェア、特にアプリの構築は、本当に反復的で創造的なプロセスであるため、コードをテストし、生き生きとしているものを体験する最速の方法が必要です。

00:00:25.000 --> 00:00:33.000
それが私たちがプレビューを作った理由です。だから、あなたはそのほぼ即時の視覚的フィードバックを持つことができるので、あなたは創造的であることに集中することができます。

00:00:33.000 --> 00:00:35.000
そして、プレビューは柔軟に構築されています。

00:00:35.000 --> 00:00:41.000
さまざまな種類のビュー、データ、デバイスを使用して、アプリ全体で使用できます。

00:00:41.000 --> 00:00:47.000
プレビューを初めて使用する場合でも、しばらく使用している場合でも、それらを最大限に活用するお手伝いをしたいと思います。

00:00:47.000 --> 00:00:48.000
これを3つの部分で行います。

00:00:48.000 --> 00:00:51.000
まず、プレビューが何であるかを確認します。

00:00:51.000 --> 00:00:58.000
それらがどのように機能し、プロジェクトの残りのコードとどのように関連しているかを少し理解することは役に立ちます。

00:00:58.000 --> 00:01:04.000
第二に、プレビューにコンテンツを提供するには、ビューとウィジェットの2つの異なる方法があります。

00:01:04.000 --> 00:01:09.000
これらを書く方法と、Xcodeでのユニークなワークフローのいくつかを紹介します。

00:01:09.000 --> 00:01:17.000
そして最後に、プロジェクトでプレビューを採用し始めると、遭遇する一般的なシナリオや質問がいくつかあります。

00:01:17.000 --> 00:01:23.000
あなたのプロジェクトでさらにプレビューを取るのに役立ついくつかのヒントとコツをお伝えしたいと思います。

00:01:23.000 --> 00:01:25.000
始めましょう。

00:01:25.000 --> 00:01:27.000
では、プレビューとは何ですか?

00:01:27.000 --> 00:01:31.000
プレビューは、ビューを制作して設定するコードのスニペットです。

00:01:31.000 --> 00:01:37.000
それらはソースファイルの最上位レベルで書かれています。つまり、どのタイプや関数にもネストされていません。

00:01:37.000 --> 00:01:40.000
そして、彼らは文字通りこれ簡単にすることができます。

00:01:40.000 --> 00:01:44.000
#Previewマクロを使用し、ビューを返します。

00:01:44.000 --> 00:01:50.000
プレビューは、残りのアプリコードとリソースと一緒にアプリにコンパイルされます。

00:01:50.000 --> 00:01:55.000
プレビューはこれらのシンボルとリソースにアクセスできるため、プレビューは本当に柔軟です。

00:01:55.000 --> 00:02:02.000
アプリ内の任意のビューのプレビューを設定するために必要なことは何でもでき、Xcodeのキャンバスに直接表示されます。

00:02:02.000 --> 00:02:06.000
しかし、プレビューはより速く反復することでもあります。

00:02:06.000 --> 00:02:11.000
プロジェクト内のSwiftコードを編集すると、Xcodeは自動的に2つのことを行います。

00:02:11.000 --> 00:02:18.000
まず、行った変更を調べて、最小限のコードを再コンパイルします。

00:02:18.000 --> 00:02:20.000
そして、次に、プレビューを再実行します。

00:02:20.000 --> 00:02:30.000
これは、コードの作成と反復に集中できることを意味し、Xcodeは自動的にプレビューの構築、実行、更新を処理します。

00:02:30.000 --> 00:02:39.000
また、プレビューが定義されると、Xcodeは追加のコードを書くことなく、異なるコンテキストでそのプレビューを自動的に実行できます。

00:02:39.000 --> 00:02:45.000
たとえば、ダークモードまたは異なるタイプのサイズと向きでテストできます。

00:02:45.000 --> 00:02:51.000
これは完璧なアナロジーではありませんが、テストに似たプレビューを考えるのに役立つかもしれません。

00:02:51.000 --> 00:02:55.000
テストと同様に、プレビューは実際のプロジェクトで実際のコードを実行します。

00:02:55.000 --> 00:02:58.000
私たちはコードをエミュレートしたり解釈したりしていません。

00:02:58.000 --> 00:03:06.000
これは、あなたがテストしてプレビューしているものが、あなたのアプリを使用する人々が経験するものも表しているという自信があることを意味します。

00:03:06.000 --> 00:03:15.000
第二に、テストやプレビューの作成に投資すると、最終的にはより迅速に開発するのに役立ちます。少しでも長い道のりを行くことができます。

00:03:15.000 --> 00:03:19.000
第三に、アプリのさまざまなレイヤーをテストしてプレビューすることができます。

00:03:19.000 --> 00:03:31.000
たとえば、テストでは、アプリの機能のかなりの部分を行使する高レベルのUIテストを行うことができ、個々のコンポーネントをテストする小さな単体テストを行うこともできます。

00:03:31.000 --> 00:03:40.000
同様に、アプリケーションの多くを網羅するビューのプレビューを持つことができ、個々のリーフビューを表示するプレビューを持つことができます。

00:03:40.000 --> 00:03:43.000
これは、プレビューがどのように機能するかを簡単に見ることです。

00:03:43.000 --> 00:03:48.000
次に、それらを書く方法と、プレビューできるコンテンツの種類に焦点を当てましょう。

00:03:48.000 --> 00:03:54.000
何をプレビューするかに関係なく、定義するすべてのプレビューは、3つのピースで同じ基本的な形状を持っています。

00:03:54.000 --> 00:04:00.000
まず、ソースファイルの最上位にあるプレビューマクロ初期化子から始めます。

00:04:00.000 --> 00:04:04.000
次に、コンテンツの1つ以上の末尾のクロージャを返します。

00:04:04.000 --> 00:04:10.000
ここでは、プレビューしたいシナリオのUIを設定できます。

00:04:10.000 --> 00:04:19.000
そして、プレビューを作成するために必要なのはそれだけですが、オプションでプレビュー自体を設定して、さらに柔軟性を高めることもできます。

00:04:19.000 --> 00:04:28.000
名前を付けることができ、プレビューの内容によっては、初期化子で追加の設定が必要になるか、または渡す必要があるかもしれません。

00:04:28.000 --> 00:04:30.000
これの例をいくつか見てみましょう。

00:04:30.000 --> 00:04:34.000
プレビューできるコンテンツの種類について話しましょう。

00:04:34.000 --> 00:04:38.000
ビューとウィジェットの2種類があります。

00:04:38.000 --> 00:04:43.000
ビューはSwiftUI、UIKit、またはAppKitから来ることができます。

00:04:43.000 --> 00:04:47.000
SwiftUIの場合は、作業中のビューを返すだけです。

00:04:47.000 --> 00:04:54.000
しかし、作業中のビューを渡す必要はありません。必要な他のビューに配置できます。

00:04:54.000 --> 00:04:59.000
そして、多くの場合、より広い文脈でビューに取り組みたいので、これは役に立ちます。

00:04:59.000 --> 00:05:05.000
たとえば、常にリストにあることを意図したビュー。

00:05:05.000 --> 00:05:12.000
これは、プレビューしているビューが必要な場合は、環境を通じてデータを提供する修飾子を添付する場所でもあります。

00:05:12.000 --> 00:05:16.000
プレビューは、アプリの最上位レベルで定義するシーンのようなものです。

00:05:16.000 --> 00:05:19.000
シーンはアプリのエントリーポイントとして機能します。

00:05:19.000 --> 00:05:22.000
データを設定し、それをビューに渡します。

00:05:22.000 --> 00:05:31.000
プレビューは同じ目的を果たすため、プレビューを使用してデータとアセットを設定し、プレビューしているビューに渡すことができます。

00:05:31.000 --> 00:05:34.000
プレビューの設定に関しては、名前を付けることができます。

00:05:34.000 --> 00:05:43.000
また、SwiftUIのようなビューベースのプレビューは、可変引数リストとして1つ以上の構成特性を渡すことをサポートしています。

00:05:43.000 --> 00:05:48.000
たとえば、プレビューするデバイスの開始方向を設定できます。

00:05:48.000 --> 00:05:53.000
APIの形状はUIKitとAppKitで同じです。

00:05:53.000 --> 00:05:59.000
SwiftUIビューの代わりに、ビューコントローラーを作成し、必要に応じて設定するだけです。

00:05:59.000 --> 00:06:04.000
ビューコントローラー以外にも、UIViewまたはNSViewを直接プレビューすることもできます。

00:06:04.000 --> 00:06:08.000
だから、あなたが構築しようとしているものに応じて、多くの柔軟性があります。

00:06:08.000 --> 00:06:19.000
プレビューの使用を開始する方法と、プレビューを非常に柔軟にするツールのいくつかを理解できるように、これまでに話したことをお見せしたいと思います。

00:06:19.000 --> 00:06:23.000
画像のコラージュを作るアプリを書いている最中です。

00:06:23.000 --> 00:06:29.000
写真を選んだり、レイアウトを選んだり、フィルターを追加したりできます。

00:06:29.000 --> 00:06:34.000
Xcodeに行って、プレビューキャンバスの機能を探りましょう。

00:06:34.000 --> 00:06:38.000
画像にフィルターを追加できるビューを書き始めました。

00:06:38.000 --> 00:06:41.000
このビューを反復するために、プレビューが必要です。

00:06:41.000 --> 00:06:49.000
まず、エディタの右上に移動し、オプションメニューをクリックして、キャンバスモードが有効になっていることを確認します。

00:06:49.000 --> 00:06:56.000
キャンバスモードは、新しいプロジェクトではデフォルトで有効になっていますが、既存のプロジェクトがある場合は、これをオンにする必要があるかもしれません。

00:06:56.000 --> 00:07:04.000
しかし、キャンバスモードが有効になっていても、ファイルにプレビューが定義されていない限り、キャンバスは非表示のままなので、追加しましょう。

00:07:04.000 --> 00:07:09.000
#Previewと入力し始めると、Xcodeがプレビューを提案します。

00:07:09.000 --> 00:07:17.000
完了を受け入れると、Xcodeはプレビューをビルドして実行し、ビューがキャンバスに表示されます。

00:07:17.000 --> 00:07:20.000
私のビューに取り組むために使用できる3つの異なるモードがあります。

00:07:20.000 --> 00:07:24.000
これらはキャンバスの左下隅に表示されます。

00:07:24.000 --> 00:07:27.000
最初のデフォルトモードは、ライブモードまたはインタラクティブモードです。

00:07:27.000 --> 00:07:38.000
これらのスライダーをドラッグするように、キャンバス内のビューと対話できるため、ほとんどの時間をこのモードで過ごします。

00:07:38.000 --> 00:07:44.000
アニメーションをテストしたり、非同期コードを呼び出したり応答したりすることもできます。

00:07:44.000 --> 00:07:48.000
2番目のモードは、選択モード、または静的モードです。

00:07:48.000 --> 00:07:54.000
このモードでは、私のビューのスナップショットを取り、キャンバス内の要素と対話することができます。

00:07:54.000 --> 00:08:00.000
ビューをクリックすると、ソースエディタで作成したコード行が強調表示されます。

00:08:00.000 --> 00:08:08.000
そして、このラベルのような特定のテキストビューをダブルクリックすると、フォーカスがソースエディタに移動して、すばやく変更できます。

00:08:08.000 --> 00:08:12.000
ヴィネットはより簡潔なラベルです。

00:08:12.000 --> 00:08:14.000
環境について話しましょう。-環境について話しましょう

00:08:14.000 --> 00:08:17.000
つまり、プレビュー環境です。

00:08:17.000 --> 00:08:22.000
キャンバスにはライトモードでプレビューが表示されていますが、ダークモードで見たい場合はどうなりますか?

00:08:22.000 --> 00:08:29.000
コードを編集して配色を設定することはできますが、多くの場合、ダークモードですばやくチェックして、微調整をしたいだけです。

00:08:29.000 --> 00:08:33.000
代わりに、キャンバスでデバイス設定のポップオーバーを使用します。

00:08:33.000 --> 00:08:38.000
下のバーで、コントロールアイコンをクリックして設定を表示します。

00:08:38.000 --> 00:08:46.000
これで、ダークモードまたは特定のダイナミックタイプサイズを有効にすることができます。

00:08:46.000 --> 00:08:52.000
しかし、両方のカラースキームで自分のビューがどのように見えるかを同時に見たい場合はどうなりますか?

00:08:52.000 --> 00:08:58.000
さて、このために、私はプレビューの3番目のモードを使用します:バリアント。

00:08:58.000 --> 00:09:12.000
キャンバスの下部にあるバリアントモードをクリックすると、カラースキームやすべての動的タイプサイズなど、すべての値を表示したいデバイス設定を選択できます。

00:09:12.000 --> 00:09:23.000
クリックして個々のバリアントを検査し、各バリアントをページスルーすることができます。

00:09:23.000 --> 00:09:24.000
うーん。

00:09:24.000 --> 00:09:29.000
これらのより大きなダイナミックタイプのサイズにたどり着くと、私の視界は本当に崩壊し始めますよね?

00:09:29.000 --> 00:09:30.000
直しましょう。

00:09:30.000 --> 00:09:37.000
VStackの代わりに、コントロールのグループに最適なフォームを使用します。このフォームを使用します。

00:09:37.000 --> 00:09:41.000
また、コントロールがセクションに配置されると、フォームは見栄えがします。

00:09:41.000 --> 00:09:44.000
各HStackをセクションにしましょう。

00:09:44.000 --> 00:09:50.000
マルチカーソル編集を活用することで、すべてのHStackインスタンスでこれらの変更を加えることができます。

00:09:50.000 --> 00:09:59.000
最初のHStackを選択し、Command-Option-Eを押して、HStackの各インスタンスのカーソルを見つけて挿入します。

00:09:59.000 --> 00:10:05.000
これらのそれぞれをセクションに変更します。

00:10:05.000 --> 00:10:11.000
また、2番目の末尾のクロージャで提供される各セクションのヘッダーも必要です。

00:10:11.000 --> 00:10:18.000
下矢印で、追加の末尾のクロージャを追加します。

00:10:18.000 --> 00:10:21.000
これらのヘッダーにすでに持っているラベルを使いましょう。

00:10:21.000 --> 00:10:29.000
矢印をラベルに戻し、Command-Option-Right Braceを押してラベルをヘッダーに移動します。

00:10:29.000 --> 00:10:32.000
そして、うわー、私たちの景色はずっと良く見えます。

00:10:32.000 --> 00:10:38.000
これらの同じ機能はすべて、AppKitとUIKitのビューとビューコントローラーでもうまく機能します。

00:10:38.000 --> 00:10:48.000
CoreImageを使用してフィルターをレンダリングするビューコントローラーにタブを切り替え、キャンバスをライブモードに戻します。

00:10:48.000 --> 00:10:53.000
さて、私はすでにこのビューコントローラーのプレビューを作成しましたが、SwiftUIに本当に似ています。

00:10:53.000 --> 00:10:59.000
プレビューマクロで、ビューコントローラーを作成し、サンプル画像を渡しました。

00:10:59.000 --> 00:11:08.000
しかし、フィルターを適用してこの画像をテストしたいので、ビューコントローラーにフィルターを渡すコードを追加します。

00:11:08.000 --> 00:11:13.000
そして、ああ、花とケレ。決して年をとることはない。

00:11:13.000 --> 00:11:17.000
ビューコントローラーを設定するだけでなく、プレビューを設定することもできます。

00:11:17.000 --> 00:11:22.000
どのプレビューでも、最初の引数としてオプションの名前を持つことができます。

00:11:22.000 --> 00:11:29.000
また、SwiftUIやUIKitなどのビュープレビューを使用すると、名前の後に可変リストに1つ以上の特性を追加できます。

00:11:29.000 --> 00:11:35.000
たとえば、プレビューを横向きで開始するように設定できます。

00:11:35.000 --> 00:11:40.000
これは、ライティングビューのプレビューのクイックツアーです。

00:11:40.000 --> 00:11:44.000
プレビューできるコンテンツの2番目の主なカテゴリはウィジェットです。

00:11:44.000 --> 00:11:49.000
ウィジェットは、プレビューの速さを本当に強調します。

00:11:49.000 --> 00:11:51.000
プレビューできるウィジェットには2種類あります。

00:11:51.000 --> 00:11:57.000
まず、個々のエントリを生成するタイムラインプロバイダーを使用するウィジェット。

00:11:57.000 --> 00:12:05.000
Xcodeでは、タイムラインプロバイダー全体をプレビューすることも、プレビューでエントリの独自のタイムラインを作成することもできます。

00:12:05.000 --> 00:12:08.000
Xcodeに行って、それぞれの例を見てみましょう。 それぞれの例を見てみましょう。

00:12:08.000 --> 00:12:16.000
私の画像コラージュアプリには、1時間ごとにランダムに構築されたコラージュを表示するタイムラインプロバイダー付きのウィジェットがあります。

00:12:16.000 --> 00:12:22.000
タイムラインプロバイダーの場合、3つの点でプレビューを行います。まず、プレビューしたいウィジェットです。

00:12:22.000 --> 00:12:25.000
第二に、タイムラインプロバイダー。

00:12:25.000 --> 00:12:31.000
そして、第三に、プレビューに使用するウィジェットファミリー。

00:12:31.000 --> 00:12:37.000
それは少量のコードですが、Xcodeで素晴らしいワークフローを提供します。

00:12:37.000 --> 00:12:44.000
このウィジェットは1時間ごとにランダムなコラージュを作成しますが、タイムラインのすべてのエントリを見るのに1時間待つ必要はありません。

00:12:44.000 --> 00:12:48.000
各タイムラインエントリのスナップショットをプレビューし、キャンバスに表示します。

00:12:48.000 --> 00:12:55.000
それらをクリックするか、矢印キーを使うことができます。

00:12:55.000 --> 00:13:09.000
そして、私がそうするとき、Xcodeは私のウィジェットと通信し、これらのエントリ間のアニメーションでトランジションを表示し、ユーザーインターフェイスだけでなく、タイムラインのさまざまなポイント間の変更でも問題を見つけることができます。

00:13:09.000 --> 00:13:13.000
ここのように、エントリ8と9の間。

00:13:13.000 --> 00:13:16.000
ここのアニメーションは素晴らしくありません。それはただクロスフェードします。

00:13:16.000 --> 00:13:24.000
このシナリオを修正したいのですが、タイムラインプロバイダーはランダムなので、テスト中にこのシナリオをもう一度見るかどうかはわかりません。

00:13:24.000 --> 00:13:28.000
これは、特定のエントリのタイムラインが便利な場所です。

00:13:28.000 --> 00:13:32.000
反復したい正確なシナリオを作成できます。 

00:13:32.000 --> 00:13:46.000
timelineProvider: プレビューでタイムラインのみに変更し、タイムラインプロバイダーを返す代わりに、修正したいケースを複製する2つのエントリを返します。

00:13:46.000 --> 00:13:53.000
しかし、この移行のために修正する必要があるコードは別のファイルにあり、移動するときにこのプレビューを失いたくありません。

00:13:53.000 --> 00:13:58.000
便利なことに、ピン留めを使用してプレビューをキャンバスに保存できます。

00:13:58.000 --> 00:14:08.000
キャンバスの左上にあるピンボタンをクリックすると、別のファイルに移動してもプレビューがアクティブになります。

00:14:08.000 --> 00:14:13.000
以下は、コラージュを描画し、トランジションを含むビューです。

00:14:13.000 --> 00:14:23.000
問題の解決に集中するために、キャンバスでは、タイムラインの再生ボタンとループボタンを押すことができます。

00:14:23.000 --> 00:14:29.000
今、私がコードを修正している間、Xcodeはこのトランジションを再生し続けます。

00:14:29.000 --> 00:14:31.000
そして、ああ、ここに問題があります。

00:14:31.000 --> 00:14:39.000
コラージュが行で構成されている場合は、トランジションが添付されていますが、コラージュが列で構成されている場合はトランジションがありません。

00:14:39.000 --> 00:14:43.000
トランジションをコピーして貼り付けることができます。

00:14:43.000 --> 00:14:49.000
そして、それはより良いですが、それは後縁からアニメーション化しています。

00:14:49.000 --> 00:14:53.000
底を押しの方が良いと思います。

00:14:53.000 --> 00:14:55.000
そして、私たちはそこに行きます。

00:14:55.000 --> 00:15:05.000
プレビューでは、タイムラインプロバイダーだけでなく、特定のイベントを使用してアニメーションを微調整することができました。

00:15:05.000 --> 00:15:11.000
それは本当に私のUIの構築と反復をより速く、より楽しくします。

00:15:11.000 --> 00:15:18.000
これらの同じウィジェットのワークフローは、プレビューできる2番目の種類のウィジェット、ライブアクティビティでも利用できます。

00:15:18.000 --> 00:15:28.000
APIはほぼ同じように見えますが、タイムラインプロバイダーとエントリを提供する代わりに、一連のライブアクティビティ属性と一連の状態を提供します。

00:15:28.000 --> 00:15:29.000
ここに例があります。

00:15:29.000 --> 00:15:34.000
まず、初期化子で使用する属性を渡します。

00:15:34.000 --> 00:15:38.000
次に、これらの属性のコンテンツ状態を渡します。

00:15:38.000 --> 00:15:50.000
たとえば、ピザを注文するためのウィジェットを構築している場合は、そのピザのベーキングと配達がどのように進んでいるかについての州のカスタムセットを提供し、それらのすべての州間でアニメーションをテストすることができます。

00:15:50.000 --> 00:15:54.000
ウィジェットのプレビューでできることの表面を引っ掻いているだけです。

00:15:54.000 --> 00:15:59.000
詳細については、「ウィジェットに命を吹き込み」セッションをチェックしてください。

00:15:59.000 --> 00:16:06.000
この講演の最後の部分に進むにつれて、プロジェクトのプレビューの作成を最大限に活用するお手伝いをしたいと思います。

00:16:06.000 --> 00:16:15.000
プロジェクトの設定、データの提供、デバイスの機能の活用に影響を与える3つの異なるシナリオを調査します。

00:16:15.000 --> 00:16:19.000
まず、ライブラリターゲットのコンテンツのプレビューについて話したいと思います。

00:16:19.000 --> 00:16:24.000
これには、フレームワーク、Swiftパッケージ、または動的ライブラリが含まれます。

00:16:24.000 --> 00:16:27.000
ライブラリを使用している理由はたくさんあります。

00:16:27.000 --> 00:16:35.000
たとえば、ライブラリを使用してプロジェクトをモジュール化したり、他の人に配布するライブラリを開発したりできます。

00:16:35.000 --> 00:16:44.000
プレビューはこれらのターゲットでうまく機能しますが、素晴らしいのは、ライブラリターゲットを活用して、どのプロジェクトでもプレビューをさらに進めることができるということです。

00:16:44.000 --> 00:16:50.000
ライブラリを活用するための最初のステップは、プレビューがコードの実行に使用する実行可能ファイルの感覚を得ることです。

00:16:50.000 --> 00:16:55.000
プレビューを起動してレンダリングするには、実行可能ファイル、アプリ、またはウィジェットが必要です。

00:16:55.000 --> 00:17:00.000
通常、これはあなたのアプリですが、アプリを持っていない場合、これはどのように機能しますか?

00:17:00.000 --> 00:17:04.000
プレビューは3つのものを使用して、どの実行可能ファイルを使用するかを把握します。

00:17:04.000 --> 00:17:06.000
1つは、あなたが作業しているソースファイルです。

00:17:06.000 --> 00:17:11.000
第二に、それらのファイルを含むターゲットとそれらのターゲットのすべての依存関係。

00:17:11.000 --> 00:17:18.000
次に、3番目に、プレビューは、これらのターゲットの依存関係と、選択したスキームのターゲットと交差します。

00:17:18.000 --> 00:17:22.000
プレビューは、アクティブなスキームにあるアプリのみを選択します。

00:17:22.000 --> 00:17:24.000
いくつかの例を見てみましょう。 ではいくつかの例を見てみましょう。

00:17:24.000 --> 00:17:30.000
最も単純なケースでは、アプリケーションターゲットのメンバーである単一のソースファイルで作業している可能性があります。

00:17:30.000 --> 00:17:34.000
これがプレビューに使用するアプリであることは、おそらく驚くことではありません。

00:17:34.000 --> 00:17:37.000
しかし、2つのターゲットにそのソースファイルがある場合はどうなりますか?

00:17:37.000 --> 00:17:42.000
例えば、アプリの試用版とアプリのフルバージョン。

00:17:42.000 --> 00:17:43.000
ここでスキームの出番です。

00:17:43.000 --> 00:17:47.000
プレビューは、アクティブなスキームにあるアプリのみを使用します。

00:17:47.000 --> 00:17:57.000
ここに別の例があります。2つのSwiftファイルが開いていて、それぞれが別のパッケージによってインポートされる可能性のあるパッケージに属し、その後、すべてアプリによってインポートされます。

00:17:57.000 --> 00:18:02.000
これらのファイルから移動して、上部にある最初の一般的な実行可能ファイルを見つけます。

00:18:02.000 --> 00:18:09.000
それを念頭に置いて、今、私たちは私たちが始めた質問に戻ることができます:私が全くアプリを持っていない場合はどうなりますか?

00:18:09.000 --> 00:18:16.000
この場合、プレビューはあなたに代わってXCPreviewAgentと呼ばれるアプリを作り、ライブラリをロードします。

00:18:16.000 --> 00:18:24.000
これはすべて自動的に行われますが、コードがどこで実行されているかを知ることができるように、これがどのように機能するか、特にこのプロセスの名前を知ることは役に立ちます。

00:18:24.000 --> 00:18:32.000
たとえば、XCPreviewAgentのクラッシュレポートがある場合、それがコードで起こっていることを知り、問題がどこにあるかを見つけることができます。

00:18:32.000 --> 00:18:38.000
しかし、ライブラリのターゲットを利用して、少なくとも2つの方法でプロジェクトでプレビューをより良く機能させることができます。

00:18:38.000 --> 00:18:44.000
これらのそれぞれについて話すのに多くの時間を費やすことができますが、少なくとも簡単に言及したいと思います。

00:18:44.000 --> 00:18:54.000
まず、アプリをライブラリにモジュール化すると、より小さなスキームを作成して、ビルド時間を改善したり、プロジェクトの一部に集中したりできます。

00:18:54.000 --> 00:19:02.000
また、ターゲットのサブセットでより小さなスキームを使用している場合でも、プレビューのフルパワーを得ることができます。

00:19:02.000 --> 00:19:12.000
次に、コードをライブラリにモジュール化すると、アプリのターゲットが提供していた必要なエンタイトルメントまたはInfo.plistキーを必要とするビューがあるかもしれません。

00:19:12.000 --> 00:19:17.000
プレビューのためだけに小さなアプリを作成することで、これらのビューをプレビューできます。

00:19:17.000 --> 00:19:19.000
方法は次のとおりです。

00:19:19.000 --> 00:19:31.000
特定のInfo.plistキーを必要とするフォトライブラリを使用するビューを作成し、そのビューをライブラリに入れたとします。たとえば、SamplePhotoLibraryUtilitiesです。

00:19:31.000 --> 00:19:35.000
新しいアプリのターゲットを作ることで、適切な機能でプレビューできます。

00:19:35.000 --> 00:19:38.000
次に、必要な機能を追加します。

00:19:38.000 --> 00:19:49.000
この場合、Info.plistキーを追加する必要があるので、ビルド設定に移動し、フォトライブラリの使用文字列をフィルタリングして設定します。

00:19:49.000 --> 00:19:55.000
次に、作業中のビューを持つライブラリがアプリに埋め込まれていることを確認します。

00:19:55.000 --> 00:20:03.000
ビルドフェーズタブを使用して、ターゲット依存関係として追加し、コピーファイルフェーズに埋め込みます。

00:20:03.000 --> 00:20:09.000
これで、このプレビューアプリとライブラリだけを含むスキームを選択する準備が整いました。

00:20:09.000 --> 00:20:17.000
ビューをプレビューすると、プレビュー用に作成したアプリが使用され、適切なInfo.plistキーがすべて配置されます。

00:20:17.000 --> 00:20:25.000
これにより、作業中のすべてのビューをプレビューする機能を維持しながら、より速いビルド時間でより小さなスキームを利用することができます。

00:20:25.000 --> 00:20:30.000
次に、データとアセットをプレビューに取り込む方法について話しましょう。

00:20:30.000 --> 00:20:36.000
私はすでにこれを以前のデモに忍び込んだが、私は戻って私が何をしたかを見直したい。

00:20:36.000 --> 00:20:40.000
フィルターをレンダリングした、先ほど見ていたビューコントローラーに戻りましょう。

00:20:40.000 --> 00:20:44.000
プレビューを設定すると、サンプル画像を渡しました。

00:20:44.000 --> 00:20:48.000
この画像は私のプロジェクトの資産カタログから来ています。

00:20:48.000 --> 00:20:56.000
プロジェクトナビゲーターを公開すると、アセットカタログはここ、プレビューコンテンツフォルダ内にあります。

00:20:56.000 --> 00:21:06.000
これらの画像は、開発中にさまざまなシナリオをテストするのに役立ち、写真でテストするすべてのデバイスを設定する必要はありません。

00:21:06.000 --> 00:21:09.000
しかし、私は私のアプリでこれらを出荷したくありません。

00:21:09.000 --> 00:21:13.000
開発資産と呼ばれる機能でそれを避けることができます。

00:21:13.000 --> 00:21:21.000
これらは、私がビルド設定で設定したプロジェクト内のフォルダであり、それらのフォルダ内のものは、App Storeに提出するとアプリから削除されます。

00:21:21.000 --> 00:21:27.000
これには、アセットカタログや、プレビューに使用するリソースが含まれる場合があります。

00:21:27.000 --> 00:21:32.000
このPreview Contentsフォルダを開発アセットパスとして追加しましょう。

00:21:32.000 --> 00:21:40.000
プロジェクト設定で、ビルド設定タブに移動し、開発資産をフィルタリングできます。

00:21:40.000 --> 00:21:51.000
ダブルクリックして編集した後、パスを手動で入力したり、プレビューコンテンツフォルダをポップオーバーにドラッグしたりできます。

00:21:51.000 --> 00:21:56.000
それを追加すると、App Storeに提出すると、このパスがアプリから削除されます。

00:21:56.000 --> 00:22:08.000
開発アセットパスは、新しいプロジェクトやアプリのターゲットを作成すると自動的に設定されますが、追加のパスを追加したり、他のターゲットタイプや既存のプロジェクトに追加したりできます。

00:22:08.000 --> 00:22:14.000
そのデモでは、開発アセットを使用してプロジェクトに追加することで、プレビューにアセットを提供する1つの方法を強調しています。

00:22:14.000 --> 00:22:21.000
これは、これらすべての資産をすべてのデバイスとチーム全体で共有したい場合に最適です。

00:22:21.000 --> 00:22:27.000
しかし、迅速に起動して実行しようとしている場合は、データと画像を提供する別の方法があります。

00:22:27.000 --> 00:22:31.000
私たちの多くは、すでにデバイスに資産とデータを持っています。

00:22:31.000 --> 00:22:34.000
プレビューでは、それらも活用できます。

00:22:34.000 --> 00:22:40.000
Xcodeのシミュレータは非常に多くのことができ、ほとんどの開発のための素晴らしい出発点です。

00:22:40.000 --> 00:22:45.000
プレビューはシミュレータでうまく機能し、物理デバイスでもうまく機能します。

00:22:45.000 --> 00:22:50.000
アプリが最終的に出荷されるデバイスでプレビューしたいのには理由があります。

00:22:50.000 --> 00:22:54.000
たとえば、カメラやセンサーにアクセスしたい場合です。

00:22:54.000 --> 00:23:01.000
もう1つの理由は、あなたのデバイスにはおそらくすでに写真やファイルなど、多くの実際のデータがあるということです。

00:23:01.000 --> 00:23:07.000
デバイスのデータを活用する方法の例をお見せしたいと思います。

00:23:07.000 --> 00:23:16.000
私が作業中である別のビューには、iCloudフォトライブラリから写真を選択し、レイアウトを選んで新しいコラージュを作成できるボタンがあります。

00:23:16.000 --> 00:23:25.000
他のビューで反復したのと同じ方法でテストしたいのですが、写真の素晴らしい選択があるデバイスを使用する必要があります。 

00:23:25.000 --> 00:23:31.000
キャンバスの下部にあるプレビューデバイスピッカーを使用して、プレビューに使用するデバイスを変更します。

00:23:31.000 --> 00:23:34.000
いくつかのオプションに飛び込みましょう。

00:23:34.000 --> 00:23:42.000
ほとんどの場合、選択した実行先のデバイスファミリを追跡する自動モードに固執することができます。

00:23:42.000 --> 00:23:47.000
メニューの文字通りの反対側には、Moreサブメニューがあります。

00:23:47.000 --> 00:23:55.000
これは、デバイスウィンドウに追加したすべてのシミュレータデバイスを一覧表示するので、必要なモデルを正確に選択できます。

00:23:55.000 --> 00:23:59.000
しかし、時には、その機能によってデバイスを選びたいだけです。

00:23:59.000 --> 00:24:08.000
メニューの中央セクションは、一般的な機能によってデバイスを提供しているので、例えば、どのモデルがTouch IDを持っていたかを正確に覚えておく必要はありません。

00:24:08.000 --> 00:24:21.000
しかし、私は隣でこのデバイスを使いたいので、ライブラリから大きな写真セットにアクセスできます。

00:24:21.000 --> 00:24:25.000
プレビューデバイスピッカーには、私のMacに接続されているすべてのデバイスも含まれます。

00:24:25.000 --> 00:24:35.000
これらの接続されたデバイスの1つを選択すると、Xcodeはシミュレータを完全にバイパスして、このデバイス専用にビルドしてプレビューします。

00:24:35.000 --> 00:24:40.000
そして、ちょうどそのように、私は実際のデバイスで私のビューを実行しています。

00:24:40.000 --> 00:24:46.000
しかし、それが私のデバイスにあるからといって、これまでに話したプレビューの機能を使用できないわけではありません。

00:24:46.000 --> 00:24:50.000
私はまだキャンバスのすべてのモードを使用することができ、デバイス設定を設定することさえできます。

00:24:50.000 --> 00:24:57.000
例えば、これはダークモードではどのように見えますか?

00:24:57.000 --> 00:25:00.000
そして、私のコードの更新は、私のデバイスに即座に表示されます。

00:25:00.000 --> 00:25:14.000
このビューにはナビゲーションタイトルが必要なので、コードにナビゲーションタイトルを追加し、タイトルをカスタマイズしてすぐにデバイスで確認します。

00:25:14.000 --> 00:25:17.000
それはとても速いです!

00:25:17.000 --> 00:25:21.000
これで、この電話のすべての画像を使用して、写真ライブラリの統合をテストする準備が整いました。

00:25:21.000 --> 00:25:31.000
写真から追加をタップし、いくつかの写真を選択します--ああ、このリスはかわいいです--そして追加をタップします。

00:25:31.000 --> 00:25:33.000
この景色はうまくいっています。

00:25:33.000 --> 00:25:38.000
私の写真はレイアウトピッカーに表示され、さまざまなレイアウトをすばやくテストできます。

00:25:38.000 --> 00:25:39.000
私はこれが大好きです。

00:25:39.000 --> 00:25:45.000
Xcodeで編集し、私の見解を体験することは、私の携帯電話で命を吹き込むことは決して古くはありません。

00:25:45.000 --> 00:25:50.000
そして、それはあなたのプロジェクトでプレビューを使用するための3つのヒントとコツです。

00:25:50.000 --> 00:26:01.000
まとめるべきいくつかのこと：Preview APIは、アプリケーション全体およびすべてのプラットフォームのUIのプレビューを定義する柔軟性を提供します。

00:26:01.000 --> 00:26:06.000
SwiftUI、UIKit、AppKit、および複数の種類のウィジェットを使用できます。

00:26:06.000 --> 00:26:11.000
プレビューは、必要なようにプレビューを正確に設定できるように柔軟です。

00:26:11.000 --> 00:26:20.000
サンプルデータとアセットを渡したり、コードで環境を設定したり、Xcodeの機能を利用してさまざまなデバイス設定をテストしたりできます。

00:26:20.000 --> 00:26:34.000
また、プレビューは、キャンバス内のシミュレータの利便性であろうと、物理デバイスを使用して最高の忠実度を得たり、データや写真にアクセスしたりするなど、さまざまなデバイスでプレビューする柔軟性も提供します。

00:26:34.000 --> 00:26:38.000
しかし、どのデバイスを選んでも、プレビューのすべての機能を利用できます。

00:26:38.000 --> 00:26:50.000
最後に、アプリケーションの少なくとも一部をライブラリにモジュール化すると、Xcodeでスキームを作成して、ビルド時間を改善し、取り組んでいる1つのことに集中することができます。

00:26:50.000 --> 00:26:53.000
プレビューは、あなたが創造的になるのを助けるためにここにあります。

00:26:53.000 --> 23:59:59.000
見てくれてありがとう。

