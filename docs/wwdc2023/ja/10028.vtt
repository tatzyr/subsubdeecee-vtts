WEBVTT

00:00:01.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:15.000
ルカ：こんにちは！私の名前はルカで、SwiftUIチームのエンジニアです。

00:00:15.000 --> 00:00:24.000
今日は、新しいエキサイティングな機能でウィジェットに命を吹き込む方法について説明します。

00:00:24.000 --> 00:00:39.000
ウィジェットはiOSとmacOSの体験の愛されている部分であり、今ではインタラクティブ性とアニメーションで、さらに強力です。

00:00:39.000 --> 00:00:52.000
インタラクティブ性により、ユーザーはウィジェット内のデータを直接操作し、アプリで最も重要なアクションを実行するための強力なインタラクションを作成できます。

00:00:52.000 --> 00:01:03.000
そして、アニメーションは、ユーザーがコンテンツがどのように変化したか、そして彼らの行動の結果が何であるかを理解するのを助けることによって、ウィジェットに命を吹き込みます。

00:01:03.000 --> 00:01:09.000
私はこれらすべての新機能にとても興奮しているので、始めましょう。

00:01:09.000 --> 00:01:16.000
まず、アニメーションと、ウィジェットを素晴らしく見せるのがいかに簡単かについて説明します。

00:01:16.000 --> 00:01:23.000
その後、ウィジェットにインタラクティブ性を追加する方法を説明します。

00:01:23.000 --> 00:01:25.000
アニメーションから始めましょう。

00:01:25.000 --> 00:01:36.000
この講演を通して、私たちは私の友人ニルスが日中のカフェイン摂取量を追跡するために取り組んでいるアプリを使用するつもりです。

00:01:36.000 --> 00:01:43.000
カフェインの総量と今日最後に飲んだ飲み物を示すウィジェットがすでにあります。

00:01:43.000 --> 00:01:58.000
ウィジェットを最新のSDKで再コンパイルすると、ウィジェットの内容が変更されるたびに、システムはデフォルトのアニメーションでエントリ間の遷移をアニメーション化します。

00:01:58.000 --> 00:02:10.000
見栄えをさらに良くするためにここにいくつかの調整を追加しますが、Xcodeに飛び込む前に、アニメーションがウィジェットでどのように機能するかについて簡単に説明しましょう。

00:02:10.000 --> 00:02:16.000
通常のSwiftUIアプリでは、状態を使用してビューの変更を推進します。

00:02:16.000 --> 00:02:23.000
そして、アニメーションはwithAnimationのような修飾子を使用して状態突然変異によって駆動されます。

00:02:23.000 --> 00:02:26.000
しかし、ウィジェットの動作は少し異なります。

00:02:26.000 --> 00:02:29.000
ウィジェットには状態がありません。

00:02:29.000 --> 00:02:38.000
代わりに、特定の時間にレンダリングされた異なるビューに対応するエントリで構成されたタイムラインを作成します。

00:02:38.000 --> 00:02:47.000
SwiftUIは、エントリ間で何が同じで何が違うかを決定し、変更された部分をアニメーション化します。

00:02:47.000 --> 00:03:05.000
デフォルトでは、ウィジェットは暗黙のスプリングアニメーションとさまざまな暗黙のコンテンツトランジションを取得しますが、SwiftUIが箱から出してすぐに提供するすべてのトランジション、アニメーション、およびコンテンツトランジションAPIを使用して、ウィジェットのアニメーションをカスタマイズできます。

00:03:05.000 --> 00:03:11.000
SwiftUIのすべてのアニメーションプリミティブがどのように機能するかについては、これ以上詳しく説明しません。

00:03:11.000 --> 00:03:37.000
そのために、「Explore SwiftUI Animation」という素晴らしい講演があります。さて、Xcodeを開き、いくつかの調整で、ウィジェットが朝のカプチーノのラテアートと同じくらい豪華になり、新しいXcode Preview APIがこれらのアニメーションをすばやく反復するのにどのように役立つかをお見せします。

00:03:37.000 --> 00:03:41.000
ここには、私のウィジェットを構成するすべてのビューがあります。

00:03:41.000 --> 00:03:53.000
メインビューには2つのビューを持つVStackがあり、1つ目はカフェインの総量を示し、2つ目は今日飲んだ最後の飲み物です。

00:03:53.000 --> 00:04:01.000
ここでcontainerBackground修飾子を使用して、ウィジェットの背景を定義する方法に注意してください。

00:04:01.000 --> 00:04:06.000
これにより、MacとiPadでサポートされているすべての新しい場所に表示できます。

00:04:06.000 --> 00:04:24.000
通常、ウィジェットのアニメーションを見るには、たくさんのエントリがあり、その瞬間が画面に表示されるのを待つ必要がありますが、それは面倒で遅くなる可能性がありますが、幸いなことに、今年導入する新しいAPIプレビューで素晴らしいソリューションがあります。

00:04:24.000 --> 00:04:35.000
systemSmallでウィジェットの新しいプレビューを定義し、ウィジェットを定義するタイプを渡すことができます。

00:04:35.000 --> 00:04:42.000
そして今、先ほど定義したいくつかのエントリでタイムラインをレンダリングする方法を指定できます。

00:04:42.000 --> 00:04:50.000
キャンバスでそれを行うと、タイムラインのプレビューと、すべてのエントリがどのように見えるかを確認できます。

00:04:50.000 --> 00:04:52.000
しかし、これをチェックしてください!

00:04:52.000 --> 00:04:59.000
プレビューをクリックすると、エントリ間を遷移するときにウィジェットがどのようにアニメーション化されるかがわかります。

00:04:59.000 --> 00:05:01.000
これはかなりかっこいい！

00:05:01.000 --> 00:05:07.000
そして、これはこの新しいプレビューAPIができることの表面を引っ掻いているだけです。

00:05:07.000 --> 00:05:16.000
この新しい強力なAPIの詳細については、セッション「XcodeプレビューでプログラマティックUIを構築する」をチェックしてください。

00:05:16.000 --> 00:05:20.000
さて、これらのアニメーションを微調整し始める時間です。

00:05:20.000 --> 00:05:26.000
私が最初にやりたいことは、カフェイン量のテキストから始めることです。

00:05:26.000 --> 00:05:34.000
今、それはちょうど次の値とクロスフェードしていますが、私は本当に上昇する値にいくつかのドラマを追加したいです。

00:05:34.000 --> 00:05:44.000
この場合、ビューは変更されませんが、テキストコンテンツのみが変更され、それをアニメーション化するには、コンテンツトランジションを使用できます。

00:05:44.000 --> 00:05:51.000
そして、私はカフェインの価値で数字のテキストを追加することを選択します。

00:05:51.000 --> 00:06:02.000
これは、変更時に目立つようにしたい重要な数値のために特別に作られたコンテンツの移行です。

00:06:02.000 --> 00:06:05.000
すごく良さそうだね！

00:06:05.000 --> 00:06:11.000
さて、私は最後の飲み物を示す景色に焦点を当てたいと思います。

00:06:11.000 --> 00:06:16.000
新しい飲み物が入ってくることを強調するためのトランジションを追加したい。

00:06:16.000 --> 00:06:27.000
最初にしたいことは、ID修飾子を使用して、このビューのアイデンティティをレンダリングされている特定のログに関連付けることです。

00:06:27.000 --> 00:06:35.000
これにより、このログが変更されるたびに、これは新しいビューであり、新しいビューに移行する必要があることをSwiftUIに通知します。

00:06:35.000 --> 00:06:41.000
そして今、私は移行を指定することができます。プッシュは良いことだと思います。

00:06:41.000 --> 00:06:43.000
どの端から？

00:06:43.000 --> 00:06:49.000
下からは良い選択だと思います。

00:06:49.000 --> 00:06:57.000
さて、あなたはすでに今何をすべきか知っています。プレビューキャンバスに戻ります。

00:06:57.000 --> 00:07:01.000
そして、ええ、私は下からのこの移行が好きです。

00:07:01.000 --> 00:07:03.000
最後の微調整。

00:07:03.000 --> 00:07:11.000
そんなにコーヒーを飲むと少し不安になり、それをこのトランジションのアニメーション曲線に反映させたい。

00:07:11.000 --> 00:07:32.000
素晴らしいのは、通常のSwiftUIアプリのように、アニメーション修飾子を使用して、より短い持続時間の滑らかなスプリングを選択し、そのアニメーションをログ値にバインドできることです。

00:07:32.000 --> 00:07:36.000
そして今、アニメーションは私のカフェインと一致します。

00:07:36.000 --> 00:07:42.000
私たちが今持っているものについてかなり気分が良いので、インタラクティブ性に注意を切り替えましょう。

00:07:42.000 --> 00:07:48.000
インタラクティブ性により、ウィジェットから直接アクションを実行できます!

00:07:48.000 --> 00:07:55.000
Xcodeに飛び込む前に、ウィジェットの仕組みのアーキテクチャについて少し話し合いたいと思います。

00:07:55.000 --> 00:08:02.000
これにより、インタラクティブ性がどのように機能するかについて、より良いメンタルモデルを作成できます。

00:08:02.000 --> 00:08:12.000
ウィジェットを作成するときは、システムによって検出され、独立したプロセスとして実行されるウィジェット拡張を定義します。

00:08:12.000 --> 00:08:20.000
ウィジェットは、効果的にウィジェットのモデルである一連のエントリを返すタイムラインプロバイダーを定義します。

00:08:20.000 --> 00:08:29.000
ウィジェットが表示されている場合、システムはウィジェット拡張プロセスを起動し、タイムラインプロバイダーにエントリを尋ねます。

00:08:29.000 --> 00:08:40.000
これらのエントリは、ウィジェット設定の一部であるビュービルダーにフィードバックされ、これらのエントリに基づいて一連のビューを生成するために使用されます。

00:08:40.000 --> 00:08:47.000
その後、システムはこれらのビューの表現を生成し、ディスクにアーカイブします。

00:08:47.000 --> 00:08:57.000
特定のエントリを表示する時間になると、システムはそのプロセスでウィジェットのアーカイブされた表現をデコードしてレンダリングします。

00:08:57.000 --> 00:09:03.000
ちょっと立ち止まって、この最後の点を繰り返します。

00:09:03.000 --> 00:09:07.000
ビューコードはアーカイブ中にのみ実行されます。

00:09:07.000 --> 00:09:12.000
そのビューの別の表現は、システムプロセスによってレンダリングされます。

00:09:12.000 --> 00:09:18.000
しかし、データが静的でない場合は、それらのエントリを更新することをお勧めします。

00:09:18.000 --> 00:09:28.000
ウィジェットに表示されるデータを更新するたびに、アプリのreloadTimelines関数を呼び出すことで、これを行うことができます。

00:09:28.000 --> 00:09:37.000
これは、先ほど説明したプロセスを繰り返し、新しいエントリを再生成し、ディスク上のビューの新しいコピーをアーカイブします。

00:09:37.000 --> 00:09:41.000
この建築には3つの重要なポイントがあります。

00:09:41.000 --> 00:09:47.000
まず、ウィジェットが表示されているとき、コードは実行されていません。

00:09:47.000 --> 00:09:56.000
タイムラインエントリを更新することで、ウィジェットコンテンツの変更を推進します。これはインタラクティブなウィジェットにも当てはまります。

00:09:56.000 --> 00:10:10.000
通常、ウィジェットの更新は最善の努力で行われますが、重要なことに、インタラクションから開始されたリロードは常に発生することが保証されています。

00:10:10.000 --> 00:10:15.000
邪魔にならないように、インタラクティブ性を追加する方法を見てみましょう。

00:10:15.000 --> 00:10:25.000
素晴らしいのは、ボタンやトグルなど、すでに慣れ親しんでいるコントロールを使用して、ウィジェットの一部をインタラクティブにできることです。

00:10:25.000 --> 00:10:36.000
しかし、ウィジェットは別のプロセスでレンダリングされるため、SwiftUIはプロセス空間でクロージャを実行したり、バインディングを変更したりしないことを忘れないでください。

00:10:36.000 --> 00:10:45.000
したがって、ウィジェット拡張機能によって実行され、システムによって呼び出されるアクションを表す方法が必要です。

00:10:45.000 --> 00:10:51.000
ありがたいことに、この問題に対する解決策はすでにあります。アプリの意図です。

00:10:51.000 --> 00:10:58.000
アプリのインテントを使用して、アプリのアクションをショートカットまたはSiriに公開した可能性があります。

00:10:58.000 --> 00:11:05.000
そして今、同じ意図を使用してウィジェットのアクションを表すことができます。

00:11:05.000 --> 00:11:15.000
AppIntentは、システムによって実行できるアクションをコードで定義できるプロトコルです。

00:11:15.000 --> 00:11:22.000
たとえば、ここでは、todoアプリでtodoアイテムを切り替えるアプリの意図を定義しています。

00:11:22.000 --> 00:11:34.000
インテントは、入力として多くのパラメータと、インテントを実行するためのビジネスロジックを持つperperという非同期関数として定義します。

00:11:34.000 --> 00:11:52.000
アプリインテントは非常に強力で、それらについて知っておくべきことがたくさんあるので、WWDC22と23の「アプリインテントに飛び込む」と「アプリのインテントの強化を探る」セッションを必ずチェックしてください。

00:11:52.000 --> 00:12:15.000
また、UIから直接App Intentを実行する機能をサポートするために、SwiftUIとAppIntentsの両方をインポートするときに、AppIntentを引数として受け入れ、これらのコントロールが操作されたときにそのインテントを実行するButtonとToggleに新しいイニシャライザのファミリーがあります。

00:12:15.000 --> 00:12:21.000
インタラクティブなウィジェットでは、AppIntentを使用したボタンとトグルのみがサポートされていることに注意してください。

00:12:21.000 --> 00:12:24.000
他のコントロールは機能しません。

00:12:24.000 --> 00:12:35.000
そしてもちろん、これらの初期化子はアプリでも機能します。これは、ウィジェットとアプリの間でアプリのインテントロジックを共有できるのでクールです。

00:12:35.000 --> 00:12:41.000
Xcodeとコーヒートラッカーアプリに戻り、インタラクティブ性を追加しましょう。

00:12:41.000 --> 00:13:00.000
現在、ユーザーはアプリを開くことによってのみ新しい飲み物を記録することができますが、インタラクティブなウィジェットが輝く場所は、あなたのアプリで最も重要なアクションを表面化するためのアクセラレータであり、私のアプリの場合、これは間違いなく新しい飲み物のロギングです。

00:13:00.000 --> 00:13:03.000
だから、私がすでに作成したファイルに追加しましょう。

00:13:03.000 --> 00:13:11.000
私が最初にしたいことは、新しい飲み物を記録するためにAppIntentに準拠したタイプを定義することです。

00:13:11.000 --> 00:13:26.000
システムで使用できる人間が読めるタイトルを与え、エスプレッソをストアに記録し、空のインテント結果を返すことで、実行要件を実装します。

00:13:26.000 --> 00:13:44.000
私が注意を喚起したいのは、実行は非同期関数であり、ログ書き込み操作を待っているときにここで行っているのとまったく同じようにデータベースに書き込むなど、非同期作業を行う場合は、それを十分に活用する必要があるということです。

00:13:44.000 --> 00:13:56.000
パフォーマンスが戻るとすぐに、システムはすぐにウィジェットのタイムラインのリロードを開始し、ウィジェットのコンテンツを更新する機会を提供します。

00:13:56.000 --> 00:14:07.000
繰り返しますが、実行から戻る前に、更新されたウィジェットをリロードするために必要なすべての情報を保持していることを確認してください。

00:14:07.000 --> 00:14:15.000
私は飲み物をエスプレッソにハードコード化しましたが、もちろん、特定の飲み物をログに渡すことができるようにしたいです。

00:14:15.000 --> 00:14:24.000
これを行うには、@Parameterプロパティラッパーとすべてのパラメータを入力する初期化子を使用して、ストアドプロパティを追加できます。

00:14:24.000 --> 00:14:39.000
このプロパティラッパーを使用することが重要です。なぜなら、注釈が付けられている保存されたプロパティのみが永続化され、ウィジェット拡張でインテントが実行されたときに利用可能になるからです。

00:14:39.000 --> 00:14:48.000
このインテントを呼び出すボタンを追加する前に、ここでアプリインテントを使用することの重要なエコシステムの利点を強調したいと思います。

00:14:48.000 --> 00:15:02.000
私が今定義したこのアプリの意図は、ショートカットとSiriで利用可能になるので、ここでそれを定義するための投資は、ウィジェットを超えてあなたのユーザーエクスペリエンスに配当を支払うでしょう。

00:15:02.000 --> 00:15:06.000
そして今、ウィジェットにボタンを追加する準備が整いました。

00:15:06.000 --> 00:15:10.000
ボタンを押しながら新しいビューを作成しましょう。

00:15:10.000 --> 00:15:18.000
このビューでは、アプリの意図を取るこのボタン初期化子を使用しているので、定義したばかりのものを渡すことができます。

00:15:18.000 --> 00:15:24.000
そして、いくつかのスペーサーを使って、このビューをウィジェットの残りの部分に追加しましょう。

00:15:24.000 --> 00:15:32.000
今、私たちはすべてを整えました、これが構築して実行することによってウィジェットでどのように機能するかを見てみましょう。

00:15:32.000 --> 00:15:43.000
ここでのちょっとしたヒント：実際にウィジェット拡張機能のターゲットを直接構築することができ、Xcodeがホーム画面にウィジェットをインストールします。

00:15:43.000 --> 00:15:47.000
私のウィジェットには、先ほど定義したボタンがあります。

00:15:47.000 --> 00:15:52.000
それをタップすると、この最後のエスプレッソを記録できます。

00:15:52.000 --> 00:16:00.000
しかし、私のウィジェットが可能な限り最高のユーザーエクスペリエンスを提供するために、私がしたい追加の変更も1つあります。

00:16:00.000 --> 00:16:06.000
アプリのインテントの実行が終了すると、ウィジェットがタイムラインをリロードします。

00:16:06.000 --> 00:16:12.000
これにより、アクションからUIの変更まで、小さなレイテンシが発生する可能性があります。

00:16:12.000 --> 00:16:21.000
しかし、このレイテンシはMac上のiPhoneウィジェットでより顕著になる可能性があるため、箱から出して解決策を提供しています。

00:16:21.000 --> 00:16:31.000
たとえば、私のウィジェットでは、カフェインの総量を示す値は、更新されたエントリが到着するまで更新されません。

00:16:31.000 --> 00:16:36.000
invalidatableContent修飾子を使用して、このビューに注釈を付けることができます。

00:16:36.000 --> 00:16:40.000
このウィジェットをiPhoneからMacに追加しました。

00:16:40.000 --> 00:16:44.000
ボタンをタップしましょう。

00:16:44.000 --> 00:16:54.000
カフェインの量を示すビューは、更新が来るまでその値が無効になっていることを示すシステム効果を示しています。

00:16:54.000 --> 00:17:04.000
ボタンの動作を見て、invalidableContent修飾子を使用すると、ユーザーがレイテンシの認識を向上させることができます。

00:17:04.000 --> 00:17:06.000
この修飾子を慎重に使用してください。

00:17:06.000 --> 00:17:11.000
変更される可能性のあるすべてのビューに注釈を付ける必要はありません。

00:17:11.000 --> 00:17:19.000
この修飾子は、ユーザーに正しい期待値を設定するために意味のあるビューで使用する必要があります。

00:17:19.000 --> 00:17:32.000
Toggleはさらに一歩進んで、ウィジェットの拡張機能への往復を待つことなく、対話したときにプレゼンテーションを楽観的に更新します。

00:17:32.000 --> 00:17:42.000
これは、両方の設定でトグルスタイルを事前にレンダリングすることで、アーカイブ時にあなたに代わって自動的に行われます。

00:17:42.000 --> 00:17:53.000
独自のトグルスタイルを定義する場合は、スタイルからconfiguration isOnプロパティを確認し、それを使用して外観を切り替えてください。

00:17:53.000 --> 00:17:58.000
これで、インタラクティブ性とアニメーションの概要は終わりです。

00:17:58.000 --> 00:18:16.000
アニメーションとインタラクティブ性により、ウィジェットに新しい命を吹き込む機会があり、これらすべての新しい場所にあるウィジェットを使用すると、どこにいてもユーザーにこれらの小さな楽しいインタラクションをもたらすことができます。

00:18:16.000 --> 00:18:38.000
したがって、新しいXcode Preview APIの助けを借りてウィジェットのアニメーションを微調整し、アプリで最も重要なアクションを探し、ウィジェットに表示し、いつでもどこでもユーザーに強力なインタラクションを提供します。

00:18:38.000 --> 00:18:39.000
ありがとう！

00:18:39.000 --> 23:59:59.000
♪ ♪

