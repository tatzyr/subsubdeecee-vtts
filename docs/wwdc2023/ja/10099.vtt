WEBVTT

00:00:00.000 --> 00:00:03.000
♪まろやかなインストゥルメンタルヒップホップ♪

00:00:03.000 --> 00:00:10.000
♪

00:00:10.000 --> 00:00:14.000
サリナ・ウー:こんにちは!私の名前はサリナで、RealityKit Toolsチームのソフトウェアエンジニアです。

00:00:14.000 --> 00:00:17.000
Harjas Monga: そして、私はプロファイリングツールエンジニアのHarjasです。

00:00:17.000 --> 00:00:22.000
Sarina:今日、Harjasと私はInstrumentsでRealityKit Traceテンプレートを紹介します。

00:00:22.000 --> 00:00:26.000
このテンプレートが空間体験のパフォーマンスを最適化するのにどのように役立つかを紹介します。

00:00:26.000 --> 00:00:30.000
パフォーマンスは、空間コンピューティングのユーザーエクスペリエンスに不可欠です。

00:00:30.000 --> 00:00:43.000
空間体験を最適化する方法を学ぶために、このプラットフォームでのレンダリングの仕組みを簡単に説明し、InstrumentsのRealityKit Traceテンプレートを使用してプロファイリングする方法を示し、コンテンツを最適化するために利用可能な他の優れたツールを簡単に説明します。

00:00:43.000 --> 00:00:46.000
このプラットフォームには独自のパフォーマンス制約があります。

00:00:46.000 --> 00:00:49.000
それらを理解するには、まずレンダリングがどのように機能するかを理解する必要があります。

00:00:49.000 --> 00:00:56.000
レンダリングには、アプリプロセス、レンダリングサーバー、およびコンポジターが含まれます。

00:00:56.000 --> 00:01:01.000
アプリがこれらのコンポーネントとどのように相互作用するかは、作成するエクスペリエンスの種類によって異なります。

00:01:01.000 --> 00:01:07.000
空間アプリ用に作成できるエクスペリエンスの種類と、それらがどのようにレンダリングされるかを見てみましょう。

00:01:07.000 --> 00:01:11.000
プラットフォーム上のアプリは、共有スペースまたはフルスペースのいずれかに入ることができます。

00:01:11.000 --> 00:01:16.000
これらは、レンダリング方法に基づいて考慮すべきパフォーマンスの影響が異なります。

00:01:16.000 --> 00:01:23.000
複数のアプリが並んで実行されると、それらはすべて同じスペースにレンダリングされます。これは、共有スペースと呼ぶ理由の1つです。

00:01:23.000 --> 00:01:30.000
これは、アプリのパフォーマンスが、レンダリングサーバーが他のアプリをレンダリングするために行っている作業によって影響を受ける可能性があることを意味します。

00:01:30.000 --> 00:01:36.000
その後、レンダリングサーバーはコンポジターと連携して最終フレームを生成します。

00:01:36.000 --> 00:01:40.000
アプリがフルスペースに入ると、他の目に見えるアプリはすべて非表示になります。

00:01:40.000 --> 00:01:46.000
これは、アプリのパフォーマンスが、現在隠されているアプリのレンダリング作業の影響を受けなくなったことを意味します。

00:01:46.000 --> 00:01:52.000
フルスペースに入る方法の詳細については、「SwiftUIでウィンドウを越える」セッションをチェックしてください。

00:01:52.000 --> 00:01:57.000
先ほど取り上げられた内容に基づいて、アプリをプロファイリングする2つの推奨方法があります。

00:01:57.000 --> 00:02:06.000
パフォーマンスの問題を調査したり、システムの電力への影響を分析したりするたびに、アプリがシステムパフォーマンスに与える影響を理解するために、アプリを個別にプロファイリングする必要があります。

00:02:06.000 --> 00:02:12.000
アプリが他のアプリと一緒に動作することを期待する場合は、それらの他のアプリでアプリをプロファイリングする必要があります。

00:02:12.000 --> 00:02:16.000
これは、ユーザーがアプリをどのように体験するかを理解するために重要です。

00:02:16.000 --> 00:02:23.000
空間アプリをプロファイリングして、RealityKit Traceテンプレートを使用して、アプリのパフォーマンスを個別に最適化する方法を紹介しましょう。

00:02:23.000 --> 00:02:28.000
私たちはHello Worldに取り組んできましたが、パフォーマンスに問題がないことを確認したいと考えています。

00:02:28.000 --> 00:02:32.000
サリナ：これはアプリのスタート画面で、SwiftUIビューです。

00:02:32.000 --> 00:02:34.000
このビューには、Objects in Orbitボタンがあります。

00:02:34.000 --> 00:02:38.000
そのボタンをタップして、地球を周回する物体について詳しく知ることができます。

00:02:38.000 --> 00:02:43.000
このボタンは、地球を周回しているさまざまな物体の例を一覧表示する新しいビューを開きます。

00:02:43.000 --> 00:02:54.000
このビューには、衛星、月、望遠鏡など、これらのオブジェクトの3Dモデルがあります。

00:02:54.000 --> 00:02:57.000
このビューには、View Orbitsボタンもあります。

00:02:57.000 --> 00:03:05.000
ボタンをタップすると、地球とその周囲を周回する衛星を示す没入型体験が開きます。

00:03:05.000 --> 00:03:11.000
これらのモデルに詳細な資産を使用しましたが、このアプリのパフォーマンスに影響を与えているのではないかと思います。

00:03:11.000 --> 00:03:17.000
没入型体験では、地球を周回する衛星の経路がアニメーション化されるのを見ることができます。

00:03:17.000 --> 00:03:20.000
地球をスケールアップして、より詳細に見ることもできます。

00:03:20.000 --> 00:03:25.000
このインタラクションは信じられないほど途切れ途切れなので、ここにはパフォーマンスの問題があると思います。

00:03:25.000 --> 00:03:29.000
Harjasと私は、RealityKit Traceテンプレートを使用してその経験をプロファイリングしました。

00:03:29.000 --> 00:03:30.000
ハルジャス、それを案内してくれませんか？

00:03:30.000 --> 00:03:35.000
Harjas:もちろん、RealityKit Traceで利用可能なすべての機能について説明しましょう。

00:03:35.000 --> 00:03:40.000
RealityKit Traceは、Instruments 15で新しいテンプレートとして利用できます。

00:03:40.000 --> 00:03:44.000
実際のデバイスとシミュレータの両方をプロファイリングするために使用できます。

00:03:44.000 --> 00:03:49.000
最も正確で実用的な情報を得るには、実際のデバイスをプロファイリングする必要があります。

00:03:49.000 --> 00:03:58.000
シミュレータに対してプロファイリングする場合、Macとオンデバイス間のハードウェアとソフトウェアの違いにより、すべてのタイミング情報が正確になるわけではありません。

00:03:58.000 --> 00:04:04.000
しかし、あなたはまだ迅速な反復と時間に基づいていない統計のいくつかを改善するためにそれを使用することができます。

00:04:04.000 --> 00:04:08.000
RealityKitトレーステンプレートには、いくつかの機器が含まれています。

00:04:08.000 --> 00:04:13.000
あなたが最初に見たいと思う楽器は、RealityKit Frames楽器です。

00:04:13.000 --> 00:04:18.000
この楽器は、デバイスによってレンダリングされる各フレームを追跡します。

00:04:18.000 --> 00:04:23.000
これらのフレームを拡大して、各フレームのレンダリングにかかった時間を確認できます。

00:04:23.000 --> 00:04:27.000
これにより、フレームの各ステージがレンダリングにかかった時間を確認できます。

00:04:27.000 --> 00:04:33.000
これにより、レンダリングパイプラインのどの部分がパフォーマンスの問題を引き起こしている可能性があるかについて、高レベルのアイデアが得られます。

00:04:33.000 --> 00:04:40.000
スムーズなユーザーエクスペリエンスを実現するために、アプリケーションは毎秒90フレームを達成できる必要があります。

00:04:40.000 --> 00:04:43.000
ただし、OSは常に90fpsをターゲットとするとは限りません。

00:04:43.000 --> 00:04:49.000
表示されるコンテンツとデバイスが配置されている環境に最も適したフレームレートでレンダリングされます。

00:04:49.000 --> 00:04:59.000
フレームレートは変更される可能性があるため、すべてのフレームには、デバイスが現在のターゲットフレームレートに達することができるように、レンダリングを完了しなければならない期限があります。

00:04:59.000 --> 00:05:12.000
フレームは3つのグループに分類されます。締め切り内によく完了しているフレーム、締め切り内にかろうじて終了しているフレーム、締め切りを過ぎてフレームがドロップするフレームです。

00:05:12.000 --> 00:05:17.000
これらの分類は、それぞれ緑、オレンジ、赤の色分けされています。

00:05:17.000 --> 00:05:23.000
締め切りを過ぎているフレームは、ユーザーエクスペリエンスに悪影響を及ぼします。

00:05:23.000 --> 00:05:30.000
ズームアウトして高いレベルからフレームをチェックすると、カラーコーディングにより、トレースの問題のある部分をすばやく見つけることができます。

00:05:30.000 --> 00:05:37.000
したがって、パフォーマンス調査をフレームドロップが最も多い領域に絞り込むことができます。

00:05:37.000 --> 00:05:49.000
個々のフレームに加えて、機器は、システムが各フレームをレンダリングするためにCPUまたはGPUの作業に費やした平均時間も視覚化します。

00:05:49.000 --> 00:05:53.000
次にチェックしたい機器は、RealityKitメトリクス機器です。

00:05:53.000 --> 00:05:57.000
トップレベルでは、機器は検出したすべてのボトルネックを描画します。

00:05:57.000 --> 00:06:03.000
これらのボトルネックは、レンダリングパイプライン全体からの包括的なタイミング情報を見ることによって生成されます。

00:06:03.000 --> 00:06:10.000
フレームが期限を超えるのと同じ時間に発生するボトルネックに優先順位を付けます。

00:06:10.000 --> 00:06:18.000
以下の詳細ビューでは、これらのRealityKitのボトルネックが重大度とタイプ別に要約されていることがわかります。

00:06:18.000 --> 00:06:26.000
さらに掘り下げて、機器がどのようなボトルネックを見つけたか、それが全体的なパフォーマンスにどの程度影響したかを正確に確認できます。

00:06:26.000 --> 00:06:36.000
拡張詳細ビューでは、この機器は、これらのボトルネックをさらに診断する方法と、それらを軽減するために実行できる手順に関する推奨事項を提供します。

00:06:36.000 --> 00:06:44.000
RealityKitメトリクストラックを拡張すると、レンダリングパイプラインのさまざまなコンポーネントからいくつかのタイプのメトリクスが表示されます。

00:06:44.000 --> 00:06:49.000
これらの統計は、アプリが提示しているシーンの完全な複雑さを理解するのに役立ちます。

00:06:49.000 --> 00:06:57.000
主要な指標の一部には、これらの指標に対する合理的な期待を知らせるのに役立つしきい値が関連付けられています。

00:06:57.000 --> 00:07:05.000
メトリクスを使用して、ボトルネックの診断やフレームが期限に達していない理由をさらにガイドします。

00:07:05.000 --> 00:07:12.000
RealityKitメトリクスは、アプリケーションのRealityKitシステムを実行するために各フレームに費やされている時間を視覚化します。

00:07:12.000 --> 00:07:18.000
これには、すべての組み込みシステムと、アプリケーションが実装する可能性のあるすべてのカスタムシステムが含まれます。

00:07:18.000 --> 00:07:26.000
この情報はTime Profilerと組み合わせるのが最善なので、RealityKitのシステムコードを最適化できます。

00:07:26.000 --> 00:07:38.000
最後に、RealityKit Metricsに示されているSystem Power Impactレーンを確認して、アプリケーションが優れた一貫したユーザーエクスペリエンスを提供するために動作する必要があるパワーエンベロープを理解します。

00:07:38.000 --> 00:07:43.000
さて、私たちが世界の経験に足を踏み入れている間に取ったいくつかの痕跡を見てみましょう。

00:07:43.000 --> 00:07:48.000
アプリの最初のシーンは、SwiftUIに実装されているスタート画面でした。

00:07:48.000 --> 00:07:53.000
フレーム機器には、このトレース全体にかなりの数のドロップフレームがあります。

00:07:53.000 --> 00:07:58.000
これらのドロップされたフレームは重要ではないように見えるかもしれませんが、ユーザーエクスペリエンスを本当に損なう可能性があります。

00:07:58.000 --> 00:08:04.000
Optionキーを押しドラッグすると、より問題のある領域の1つにズームインできます。

00:08:04.000 --> 00:08:15.000
また、時間範囲を調整することで、これらの長時間のフレーム中にRealityKit Metrics機器が見つけたボトルネックを確認できます。

00:08:15.000 --> 00:08:21.000
インストゥルメントは、この時代の最大のボトルネックがコアアニメーションエンコーディングであることを発見しました。

00:08:21.000 --> 00:08:35.000
そこで、Core Animationの統計を確認します。これは、RealityKit Metrics Instrumentの横にある詳細表示三角形をクリックし、Core Animationというラベルの付いたトラックを選択することで確認できます。

00:08:35.000 --> 00:08:40.000
これらのコアアニメーションメトリクスは、これらのフレームドロップの原因を知らせるのに役立ちます。

00:08:40.000 --> 00:08:47.000
これらのメトリクスを調査すると、それらのいくつかはメトリクスがどれほど厳しいかという文脈を持っていることに気付くでしょう。

00:08:47.000 --> 00:08:50.000
タイムラインでは、これはカラーコーディングに反映されています。

00:08:50.000 --> 00:08:55.000
これは、これらの重要な指標の合理的なしきい値が何であるかをガイドするためのものです。

00:08:55.000 --> 00:09:03.000
タイムラインの視覚化に基づいて、アプリケーションがオフスクリーンの準備数の推奨しきい値を超えていることは明らかです。

00:09:03.000 --> 00:09:13.000
下部の要約は、ここで準備するオフスクリーンの平均数が180であることを示しています。これはかなり高い平均です。

00:09:13.000 --> 00:09:18.000
コアアニメーションの統計を考慮すると、心に留めておきたい作業には3つのタイプがあります。

00:09:18.000 --> 00:09:23.000
第一に、透明性とぼかし効果は、システムにとって非常に高価な操作です。

00:09:23.000 --> 00:09:29.000
これらの効果は、ユーザーに最も影響を与えるときに使用し、それ以外の場合は控えめに使用してください。

00:09:29.000 --> 00:09:37.000
レンダリングパスの数は、コアアニメーションが画像全体に対して個別にレンダリングする必要があるレイヤーの数によって決まります。

00:09:37.000 --> 00:09:40.000
そして最後に、画面外パスがあります。

00:09:40.000 --> 00:09:47.000
したがって、名前が示すように、オフスクリーンパスは、ディスプレイではなくオフスクリーンにレンダリングされるレンダリングパスです。

00:09:47.000 --> 00:09:56.000
オフスクリーンパスでは、レンダリングパスが現在行っていることを一時停止し、ユーザーに表示されない作業を行う必要があります。

00:09:56.000 --> 00:10:02.000
ただし、通常のレンダリングパスを継続するには、オフスクリーンパスの出力が必要です。

00:10:02.000 --> 00:10:06.000
オフスクリーンパスは、空間アプリに特にインパクトがあります。

00:10:06.000 --> 00:10:19.000
他のアプリプラットフォームとは異なり、このプラットフォームは、すべてのフレームがユーザーの頭の動きなどの環境要因を考慮する必要があるため、空間アプリを継続的にレンダリングします。

00:10:19.000 --> 00:10:26.000
したがって、静的UIは、システムのターゲットフレームレートでレンダリングできるほど効率的である必要があります。

00:10:26.000 --> 00:10:35.000
オフスクリーンパスを引き起こす可能性のある作業には、影、マスキング、丸みを帯びた長方形、視覚効果の4つの主なタイプがあります。

00:10:35.000 --> 00:10:43.000
オフスクリーンパスの詳細については、「レンダリングフェーズの謎を解明し、問題を排除する」に関する技術講演をご覧ください。

00:10:43.000 --> 00:10:50.000
オフスクリーンパスがたくさんあったので、このビューのSwiftUIコードをチェックして、原因を見つけてください。

00:10:50.000 --> 00:10:54.000
SwiftUIコードでは、このビューはマスキングや視覚効果を行っていません。

00:10:54.000 --> 00:10:57.000
しかし、影が適用されている例があります。

00:10:57.000 --> 00:11:02.000
たとえば、SwiftUI Viewアイテムでは、いくつかのボタンに影が適用されています。

00:11:02.000 --> 00:11:07.000
シャドウは、特に透明性と組み合わせると、特に高価な操作です。

00:11:07.000 --> 00:11:13.000
シャドウは便利なUIイディオムですが、空間アプリの場合、ユーザーに大きな影響を与えるときに使用する必要があります。

00:11:13.000 --> 00:11:18.000
これらの影を無効にして、新しいトレースを見てみます。

00:11:18.000 --> 00:11:30.000
シャドウが無効になっているため、RealityKit Frames Instrumentではフレームの問題はほとんどなく、RealityKit Metricsは、オフスクリーンパスが4倍に減少したと報告しています。

00:11:30.000 --> 00:11:34.000
さて、ワールドアプリで見た次のシーンは、軌道ビューのオブジェクトでした。

00:11:34.000 --> 00:11:41.000
そのシーンの痕跡を開いて、最適化できるものがあるかどうかを確認します。 最適化できるものがあるかどうかを確認します。

00:11:41.000 --> 00:11:48.000
フレームインストゥルメントでは、トレース全体にドロップされたフレームが散乱し、多くのボトルネックがあります。

00:11:48.000 --> 00:11:55.000
RealityKitメトリクスの詳細ビューは、これらのボトルネックの概要を提供します。

00:11:55.000 --> 00:12:00.000
要約すると、これらのボトルネックのほとんどはGPUワークストールに関連しています。

00:12:00.000 --> 00:12:08.000
最も頻繁に報告されるボトルネックタイプはGPUストールであるため、私は再びRealityKitメトリクスを拡張するつもりです。

00:12:08.000 --> 00:12:14.000
しかし、今回は3Dレンダリングトラックを使って調査します。

00:12:14.000 --> 00:12:21.000
フレームドロップの数が多いトレースの領域を選択します。 

00:12:21.000 --> 00:12:31.000
この時間選択では、3Dレンダリングメトリックは、三角形と頂点の数が推奨されるしきい値をはるかに上回っていることを報告します。

00:12:31.000 --> 00:12:39.000
次に、フレームドロップがそれほど多くないトレースの領域を強調します。

00:12:39.000 --> 00:12:46.000
また、レンダリングメトリックによると、三角形と頂点の数は推奨されるしきい値の範囲内です。

00:12:46.000 --> 00:12:52.000
これは、アプリがシーンで使用しているアセットの数と品質を本当に評価する必要があることを意味します。

00:12:52.000 --> 00:13:01.000
アセットレンダリングを最適化するときは、まず三角形、頂点をチェックし、RealityKit Metricsの3Dレンダリンググループから呼び出しを描画します。

00:13:01.000 --> 00:13:06.000
これらのメトリクスを最適化するには、可能であれば単純な形状のメッシュを使用してください。

00:13:06.000 --> 00:13:11.000
同じメッシュでアセットを利用するときは、インスタンス化を活用してください。

00:13:11.000 --> 00:13:22.000
3Dコンテンツを組み立て、編集、プレビューできる新しい開発者ツールであるReality Composer Proの統計を使用して、アセットの複雑さを確認してください。

00:13:22.000 --> 00:13:27.000
そのコンテンツは、後でXcodeプロジェクトで直接コードを介してアクセスすることができます。

00:13:27.000 --> 00:13:34.000
このツールの詳細と優れたアセットの作成方法については、セッション「Meet Reality Composer Pro」をご覧ください。

00:13:34.000 --> 00:13:41.000
私は先に進み、使用していた資産を、より少ないポリゴンを使用する資産と交換し、新しいトレースをキャプチャしました。

00:13:41.000 --> 00:13:47.000
このトレースでは、フレームインストゥルメントは、すべてのフレームが締め切りに達していると報告しています。

00:13:47.000 --> 00:13:57.000
そして、3Dレンダリング統計をもう一度確認すると、三角形と頂点の数が大幅に減少したと報告されます。

00:13:57.000 --> 00:14:02.000
これらの資産はポリゴンを使用していましたが、経験の質に損失はありませんでした。

00:14:02.000 --> 00:14:06.000
次の痕跡は、私たちが地球モデルと相互作用していたときのものです。

00:14:06.000 --> 00:14:10.000
このシーンでは、地球のサイズを変更することは実際にはかなり不安でした。

00:14:10.000 --> 00:14:18.000
RealityKit Metricsは、System Power Impactレーンがかなりの時間にわたって非常に高かったと報告しています。

00:14:18.000 --> 00:14:25.000
これは、アプリケーションの一部が非常に非効率的であり、ユーザーエクスペリエンスが影響を受ける可能性があることを示しています。

00:14:25.000 --> 00:14:33.000
デバイスのシステム電力の影響をできるだけ多くの時間公称状態に保ちながら、アプリケーションがうまく機能するようにターゲットにする必要があります。

00:14:33.000 --> 00:14:42.000
システムの電力への影響を軽減するためにプロファイリングするときは、常にアプリケーションを分離してプロファイリングして、最も実用的な情報を取得できるようにします。

00:14:42.000 --> 00:14:46.000
いくつかのアプローチを使用して、システムの電力への影響を下げることができます。

00:14:46.000 --> 00:14:51.000
まず、RealityKitメトリクスの統計が期待の範囲内であることを確認してください。

00:14:51.000 --> 00:15:00.000
これらが期待を上回っている場合、デバイスはスムーズな体験を提供するために、長時間高電力状態で動作する可能性があります。

00:15:00.000 --> 00:15:04.000
次に、CPUとGPUが何をしているのかを確認します。

00:15:04.000 --> 00:15:11.000
CPUの場合、タイムプロファイラがハイパワードローリージョン中に高いCPU使用率を報告するかどうかを確認します。

00:15:11.000 --> 00:15:17.000
もしそうなら、タイムプロファイラを使用してCPUにバインドされたコードを最適化します。

00:15:17.000 --> 00:15:20.000
GPUには、パフォーマンスの状態があります。

00:15:20.000 --> 00:15:25.000
GPUが最大段階にあるとき、それはかなりの量の電力を消費します。

00:15:25.000 --> 00:15:33.000
その場合は、InstrumentsのMetal System Traceテンプレートを使用して、GPUでどのような作業が行われているかを確認する必要があります。

00:15:33.000 --> 00:15:37.000
そうすれば、何が最適化できるかを理解できます。

00:15:37.000 --> 00:15:52.000
トレースに戻ると、タイムプロファイラは、この地域ではCPU使用率が平均100%であり、このほとんどの時間でGPUのパフォーマンス状態が最小限であったことを示しています。

00:15:52.000 --> 00:15:57.000
タイムプロファイラを使用すると、高いCPU使用率の原因を確認できます。

00:15:57.000 --> 00:16:00.000
最も重いスタックトレースは、拡張詳細ビューにあります。

00:16:00.000 --> 00:16:08.000
これは、コールツリーでコードの最も高価な部分をすばやく見つけることができるため、タイムプロファイラーの非常に便利な機能です。

00:16:08.000 --> 00:16:15.000
これらのフレームを見ると、Entity.makeModelは多くのCPU時間を使用しているようです。

00:16:15.000 --> 00:16:20.000
次のフレームダウンは、Entity.generateCollisionShapesを呼び出すことです。

00:16:20.000 --> 00:16:30.000
したがって、パフォーマンスの問題は、常にモデルと衝突形状を生成することによって引き起こされているように見えますが、これは高価な操作です。

00:16:30.000 --> 00:16:34.000
Xcodeを開いて、これについて何ができるかを確認します。 

00:16:34.000 --> 00:16:42.000
これは、コールツリーが示したEntity.makeModel関数呼び出しで、多くのCPU時間がかかっていました。

00:16:42.000 --> 00:16:49.000
これはmakeGlobe関数内で呼び出されます。

00:16:49.000 --> 00:16:54.000
makeGlobe関数をControlキーを押しながらクリックすると、誰がそれを呼び出しているかを確認できます。

00:16:54.000 --> 00:16:58.000
Orbit SwiftUIビューボディから呼び出されています。

00:16:58.000 --> 00:17:05.000
これは、ビュー本体を非常に迅速に計算する必要があるため、避けるべきアンチパターンです。

00:17:05.000 --> 00:17:17.000
ビューの状態が変更されるときはいつでも、すべての高価な操作を再計算する必要があるため、SwiftUIビューの本文でモデルの読み込みやその他の高価な操作は避けるべきです。

00:17:17.000 --> 00:17:23.000
だから、私がやろうとしているのは、ビューボディからこの呼び出しを削除することです。

00:17:23.000 --> 00:17:29.000
次に、ViewModelに、地球エンティティの再利用可能なバージョンを追加します。

00:17:29.000 --> 00:17:36.000
そして最後に、私は軌道ビューでその再利用可能な地球エンティティを使用するつもりです。

00:17:36.000 --> 00:17:43.000
さて、ビューボディが再計算されると、アプリは同じモデルをリロードする時間を無駄にしません。

00:17:43.000 --> 00:17:50.000
修正後の痕跡を見ると、電力への影響は名目状態に戻されます。

00:17:50.000 --> 00:17:56.000
また、タイムプロファイラは、CPU使用率が100%から10%に低下したと報告しています。

00:17:56.000 --> 00:18:04.000
これらすべての最適化の後、報告されたボトルネックはほとんどなく、ほとんどすべてのフレームが期限に達しており、電力は期待の範囲内であります。

00:18:04.000 --> 00:18:09.000
現在、Worldアプリは、このプラットフォーム用に最適化されているアプリです。

00:18:09.000 --> 00:18:23.000
オフスクリーンパスの数を減らし、高ポリゴン資産を合理的なものに置き換え、CPUと電力使用量を削減したので、このアプリの最適化されたバージョンをステップアップします。

00:18:23.000 --> 00:18:30.000
スタート画面は素晴らしく見え、影はユーザーエクスペリエンスにあまり追加されていなかったので、これは良い最適化でした。

00:18:30.000 --> 00:18:33.000
次に、軌道のオブジェクトを開きましょう。

00:18:33.000 --> 00:18:38.000
これらのモデルは、ポリゴンの少ない資産を使用しているにもかかわらず、見栄えがします。

00:18:38.000 --> 00:18:41.000
だから、その余分な詳細はリソースを無駄にしていました。

00:18:41.000 --> 00:18:47.000
そして最後に、地球モデルを再び開いて、サイズを変更してみます。

00:18:47.000 --> 00:18:53.000
今、この相互作用はバターのように滑らかです。

00:18:53.000 --> 00:18:59.000
これは、RealityKit Traceを使用して、この新しいプラットフォーム用にアプリを最適化する方法の簡単な概要でした。

00:18:59.000 --> 00:19:03.000
ねえ、サリナ、開発者が利用できる他にどんなツールがありますか？

00:19:03.000 --> 00:19:07.000
Sarina: 空間コンピューティング用のアプリを最適化するのに役立つツールがいくつかあります。

00:19:07.000 --> 00:19:15.000
SwiftUIコンテンツを最適化するために、Instrumentsアプリには、SwiftUI、Core Animation、およびハングを分析するためのドメイン固有のツールがあります。

00:19:15.000 --> 00:19:20.000
Hangs楽器の詳細については、「Instrumentsでハングアップを分析する」セッションで学ぶことができます。

00:19:20.000 --> 00:19:24.000
また、3Dアセットベースのコンテンツを最適化するためのツールもいくつかあります。

00:19:24.000 --> 00:19:32.000
タイムプロファイラインストゥルメントは、アセットの読み込みに多くの時間を費やしている場合など、アプリが最も時間を費やしている領域を見つけるのに役立ちます。

00:19:32.000 --> 00:19:38.000
RealityKit Metrics Instrumentは、シーンのアセットが多すぎる場合やアセットが複雑すぎる場合の診断に役立ちます。

00:19:38.000 --> 00:19:44.000
最後に、Reality Composer Proを使用してシーンを組み立てるときに、アセットの複雑さを確認することもできます。

00:19:44.000 --> 00:19:49.000
Reality Composer Proの詳細については、セッション「Meet Reality Composer Pro」をご覧ください。

00:19:49.000 --> 00:19:55.000
アプリでMetalを使用している場合、最も便利なツールはInstrumentsのMetal System Traceテンプレートです。

00:19:55.000 --> 00:20:01.000
このテンプレートには、GPUタイムライン、GPUカウンタ、GPUパフォーマンス状態などの重要な指標があります。

00:20:01.000 --> 00:20:10.000
このテンプレートとメタルコンテンツのプロファイリングのための他のツールの詳細については、セッション「メタルデバッグ、プロファイリング、および資産作成ツールの発見」をチェックしてください。

00:20:10.000 --> 00:20:13.000
要約すると、このプラットフォームにはパフォーマンスが不可欠です。

00:20:13.000 --> 00:20:17.000
アプリは、可能な限り最高のユーザーエクスペリエンスを提供するために十分に最適化されている必要があります。

00:20:17.000 --> 00:20:22.000
RealityKitトレーステンプレートを使用して、アプリのパフォーマンスのボトルネックを見つけることができます。

00:20:22.000 --> 00:20:29.000
他の楽器で積極的にプロファイリングし、Reality Composer Proでコンテンツをチェックすることは、パフォーマンスの問題を見つけて解決するのにも役立ちます。

00:20:29.000 --> 00:20:36.000
RealityKit Traceテンプレートを使用してアプリを最適化する方法の詳細については、開発者ドキュメントを確認してください。

00:20:36.000 --> 00:20:44.000
そして、このプラットフォームのパフォーマンスをよりよく理解するために、「空間コンピューティングのためのアプリのパワーとパフォーマンスを最適化する」セッションを見てください。

00:20:44.000 --> 00:20:48.000
トレースが何であれ、空間コンピューティングアプリの最適化をお楽しみください。

00:20:48.000 --> 00:20:49.000
ハルジャス:見てくれてありがとう。

00:20:49.000 --> 23:59:59.000
♪

