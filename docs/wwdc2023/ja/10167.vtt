WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:13.000
ベッカ：こんにちは、私はスウィフトチームのベッカです。

00:00:13.000 --> 00:00:20.000
今日は、ニーズに合わせてSwift言語をカスタマイズできるエキサイティングな新機能であるSwiftマクロについて話します。

00:00:20.000 --> 00:00:24.000
マクロが何のためにあるのかについて話すことから始めます。

00:00:24.000 --> 00:00:29.000
次に、Swiftマクロを設計する際に念頭に置いていた原則のいくつかについて話します。

00:00:29.000 --> 00:00:37.000
次に、Swiftマクロの仕組みと、プロジェクト内の他のコードと対話する具体的な方法について説明します。

00:00:37.000 --> 00:00:46.000
その後、マクロを実装する方法について話し、マクロが正しく機能することを確認する方法について話し合います。

00:00:46.000 --> 00:00:50.000
それでは、Swiftがマクロをサポートする理由について話しましょう。

00:00:50.000 --> 00:00:54.000
Swiftは、ユーザーが表現力豊かなコードとAPIを書くのが大好きです。

00:00:54.000 --> 00:01:02.000
そのため、派生コンフォーマンスや結果ビルダーなどの機能を提供し、ユーザーが反復的なボイラープレートを書くのを避けるのに役立ちます。

00:01:02.000 --> 00:01:06.000
これらの機能はすべて基本的に同じように機能します。

00:01:06.000 --> 00:01:17.000
たとえば、メンバーに実装を提供せずにCodableに準拠すると、Swiftはプログラムに挿入するメンバーのセットに自動的にコンフォーマンスを拡張します。

00:01:17.000 --> 00:01:20.000
灰色のボックスに適合性のための拡張を示しました。

00:01:20.000 --> 00:01:32.000
このコードを作成すると、どのように機能するかを正確に知ることなくCodableを使用できるため、Codableサポートを追加すると、画面いっぱいのコードを書く価値があるかどうかを判断する必要はありません。

00:01:32.000 --> 00:01:34.000
Swiftには、このように機能する多くの機能があります。

00:01:34.000 --> 00:01:41.000
簡単な構文を書くと、コンパイラはそれをより複雑なコードに自動的に展開します。

00:01:41.000 --> 00:01:44.000
しかし、既存の機能があなたが望むことができない場合はどうなりますか?

00:01:44.000 --> 00:01:49.000
さて、オープンソースなので、Swiftコンパイラに機能を追加できます。

00:01:49.000 --> 00:01:59.000
しかし、それは文字通り、私が個人的にビデオ会議に参加し、他のSwiftプロジェクトリーダーとあなたの機能について話し合うことを含むので、それは正確にスケールするプロセスではありません。

00:01:59.000 --> 00:02:02.000
それが私たちがマクロを導入している理由です。

00:02:02.000 --> 00:02:11.000
独自の言語機能をSwiftに追加し、退屈さと定型文を排除し、コンパイラを変更せずにSwiftパッケージで配布できます。

00:02:11.000 --> 00:02:14.000
他の言語でマクロを使ったことがない人もいます。

00:02:14.000 --> 00:02:17.000
しかし、あなたが持っているなら、あなたはそれらについて複雑な感情を持っているかもしれません。

00:02:17.000 --> 00:02:27.000
これは、多くのSwift開発者がObjective-CまたはCプリプロセッサを使用する他の言語に精通しており、Cマクロの制限と落とし穴について知っているためです。

00:02:27.000 --> 00:02:32.000
しかし、Swiftマクロは、これらの問題の多くを回避する方法が大きく異なります。

00:02:32.000 --> 00:02:34.000
私たちは4つの目標を念頭に置いてそれらを設計しました。

00:02:34.000 --> 00:02:38.000
最初の目標は、マクロを使用しているときにかなり明白であるべきだということです。

00:02:38.000 --> 00:02:44.000
マクロには2種類あります。自立型マクロは、コード内の他の何かの代わりに立っています。

00:02:44.000 --> 00:02:47.000
彼らはいつもポンド(#)の記号で始まります。

00:02:47.000 --> 00:02:51.000
また、添付されたマクロは、コード内の宣言の属性として使用されます。

00:02:51.000 --> 00:02:54.000
彼らはいつもat(@)のサインで始まります。

00:02:54.000 --> 00:02:58.000
スウィフトはすでにポンド(#)とアット(@)記号を使用して、特別なコンパイラの動作を示します。

00:02:58.000 --> 00:03:01.000
マクロはそれを拡張可能にするだけです。

00:03:01.000 --> 00:03:06.000
そして、#や@が表示されない場合は、マクロが関与していないと確信できます。

00:03:06.000 --> 00:03:14.000
2番目の目標は、マクロに渡されたコードとそこから送り返されたコードの両方が完了し、間違いがないかチェックすることです。

00:03:14.000 --> 00:03:20.000
引数は完全な式でなければならないため、マクロに「1 +」を渡すことはできません。

00:03:20.000 --> 00:03:28.000
関数の引数と同じように、マクロ引数と結果が型チェックされるため、間違った型で引数を渡すこともできません。

00:03:28.000 --> 00:03:37.000
また、マクロの実装は、入力を検証し、何か問題が発生した場合にコンパイラの警告やエラーを発行することができるため、マクロを正しく使用していることを確認する方が簡単です。

00:03:37.000 --> 00:03:44.000
3番目の目標は、マクロ拡張を予測可能で追加的な方法でプログラムに組み込むことです。

00:03:44.000 --> 00:03:47.000
マクロは、プログラムの目に見えるコードにのみ追加できます。

00:03:47.000 --> 00:03:49.000
削除したり変更したりすることはできません。

00:03:49.000 --> 00:03:58.000
したがって、「someUnknownMacro」が何をしているのかわからなくても、「finishDoingThingy」の呼び出しを削除したり、新しい機能に移動したりしないことを確認できます。

00:03:58.000 --> 00:04:01.000
これにより、マクロを使用するコードが読みやすくなります。

00:04:01.000 --> 00:04:06.000
そして、最終的な目標は、マクロが不可解な魔法であってはならないということです。

00:04:06.000 --> 00:04:12.000
マクロはプログラムにコードを追加するだけで、Xcodeですぐに見ることができます。

00:04:12.000 --> 00:04:16.000
マクロの使用サイトを右クリックして、それが何に展開するかを尋ねることができます。

00:04:16.000 --> 00:04:20.000
拡張にブレークポイントを設定したり、デバッガで介入したりできます。

00:04:20.000 --> 00:04:28.000
マクロ展開内のコードがコンパイルされない場合、エラーが展開のどこにあるかと、その展開がソースコードのどこにあるかの両方が表示されます。

00:04:28.000 --> 00:04:32.000
そして、これらのツールはすべて、マクロがクローズドソースライブラリによって提供されていても機能します。

00:04:32.000 --> 00:04:40.000
マクロ作成者は、期待どおりに機能することを確認するために、マクロの単体テストを書くことさえできます。

00:04:40.000 --> 00:04:45.000
これらの目標は、開発者がSwiftマクロを理解し、維持しやすくすると考えています。

00:04:45.000 --> 00:04:51.000
Swiftマクロが何を達成しようとしているのかを理解したので、その方法について話しましょう。

00:04:51.000 --> 00:04:55.000
細部に迷う前に、基本的な概念を書き留めましょう。

00:04:55.000 --> 00:05:08.000
Swiftは、Xcodeマクロパッケージテンプレートから「stringify」マクロのように、コード内のマクロを呼び出すのを見ると、コードから使用を抽出し、そのマクロの実装を含む特別なコンパイラプラグインに送信します。

00:05:08.000 --> 00:05:16.000
プラグインは安全なサンドボックスで別のプロセスとして実行され、マクロの作成者によって書かれたカスタムSwiftコードが含まれています。

00:05:16.000 --> 00:05:23.000
マクロの使用を処理し、マクロによって作成された新しいコードの断片である「拡張」を返します。

00:05:23.000 --> 00:05:29.000
その後、Swiftコンパイラは、その拡張をプログラムに追加し、コードと拡張を一緒にコンパイルします。

00:05:29.000 --> 00:05:36.000
したがって、プログラムを実行すると、マクロを呼び出すのではなく、自分で展開を書いたかのように機能します。

00:05:36.000 --> 00:05:39.000
さて、私がここで隠した重要なポイントがあります。

00:05:39.000 --> 00:05:43.000
スウィフトは「ストリンジ化」マクロが存在することをどうやって知りましたか?

00:05:43.000 --> 00:05:47.000
そして答えは、それはマクロ宣言から来ています。

00:05:47.000 --> 00:05:50.000
マクロ宣言は、マクロのAPIを提供します。

00:05:50.000 --> 00:05:56.000
独自のモジュールで宣言を書くことも、ライブラリやフレームワークからインポートすることもできます。

00:05:56.000 --> 00:06:07.000
関数宣言と同様に、マクロの名前と署名、パラメータの数、ラベルとタイプ、およびマクロに1つがある場合の結果のタイプを指定します。

00:06:07.000 --> 00:06:11.000
また、マクロの役割を指定する1つ以上の属性もあります。

00:06:11.000 --> 00:06:16.000
その役割が何であるかを考えずにマクロを書くことは不可能です。

00:06:16.000 --> 00:06:23.000
それでは、役割とは何か、異なる役割を使用して異なる種類のマクロを書く方法について話しましょう。

00:06:23.000 --> 00:06:25.000
役割は、マクロの一連のルールです。

00:06:25.000 --> 00:06:34.000
マクロを適用する場所と方法、展開するコードの種類、その展開がコードに挿入される場所を管理します。

00:06:34.000 --> 00:06:43.000
最終的には、予測可能で追加的な方法で拡張を挿入するという目標を達成する責任を負うのは、マクロの役割です。

00:06:43.000 --> 00:06:48.000
自立型マクロを作成するには、式と宣言の2つの役割があります。

00:06:48.000 --> 00:06:56.000
また、アタッチされたマクロを作成する5つの役割があります。ピア、アクセサ、メンバー属性、メンバー、コンフォーマンスです。

00:06:56.000 --> 00:06:59.000
これらの役割と、いつ使うかを見てみましょう。

00:06:59.000 --> 00:07:02.000
「自立表現」の役割から始めます。

00:07:02.000 --> 00:07:10.000
「式」という用語がベルを鳴らさない場合、式は、実行して結果を生成するコードの単位と呼ばれるものです。

00:07:10.000 --> 00:07:15.000
この「let」ステートメントでは、等号の後の算術は式です。

00:07:15.000 --> 00:07:20.000
しかし、式は再帰的な構造を持っています - それらはしばしば小さな式で構成されています。

00:07:20.000 --> 00:07:23.000
したがって、「x + width」だけでも表現です。

00:07:23.000 --> 00:07:26.000
そして、ちょうど「幅」という言葉です。

00:07:26.000 --> 00:07:32.000
「自立式」マクロは、式に展開するマクロです。

00:07:32.000 --> 00:07:34.000
どうやって使うの？

00:07:34.000 --> 00:07:36.000
オプションを強制的に開封する必要があると想像してみてください。

00:07:36.000 --> 00:07:50.000
Swiftはforce-unwrap演算子を提供しますが、一部のチームは、安全性を考えずにforce-unwrapを投げるのは少し簡単すぎると感じているので、彼らのスタイルガイドは、値がゼロであってはならない理由を示す、より複雑なものを書くように開発者に指示します。

00:07:50.000 --> 00:07:58.000
しかし、「guard let」を使用し、「else」ブランチで「preconditionFailure」を呼び出すなど、これらの選択肢のほとんどは、少しあまりにも多くの儀式です。

00:07:58.000 --> 00:08:03.000
これらの極端の間でより良いバランスを取るマクロを設計しましょう。

00:08:03.000 --> 00:08:08.000
このマクロに値を計算して返してもらいたいので、「フリースタンディング(式)」マクロにします。

00:08:08.000 --> 00:08:15.000
「Unwrap」という名前と、渡された値がオプションですが、返される値が非オプションである汎用型を与えます。

00:08:15.000 --> 00:08:20.000
また、アンラップが失敗した場合に印刷されたメッセージの一部である文字列も渡します。

00:08:20.000 --> 00:08:28.000
したがって、関数のように呼び出すマクロで終わりますが、クロージャに包まれた「guard let」を含む式に展開されます。

00:08:28.000 --> 00:08:34.000
エラーメッセージには変数名も含まれており、通常の関数では不可能です。

00:08:34.000 --> 00:08:39.000
自立型表現の役割を見たので、自立型宣言の役割を見てみましょう。

00:08:39.000 --> 00:08:44.000
関数、変数、型など、1つ以上の宣言に展開されます。

00:08:44.000 --> 00:08:46.000
あなたはそれを何に使うことができますか?

00:08:46.000 --> 00:08:51.000
2D配列タイプを必要とするある種の統計分析を書いていると想像してみてください。

00:08:51.000 --> 00:08:58.000
配列内のすべての行が同じ数の列を持つようにしたいので、配列の配列は必要ありません。

00:08:58.000 --> 00:09:09.000
代わりに、要素をフラットな1次元配列に格納し、開発者が渡した2次元インデックスから1次元インデックスを計算します。

00:09:09.000 --> 00:09:12.000
これを行うには、このようなタイプを書くかもしれません。

00:09:12.000 --> 00:09:20.000
「makeIndex」関数は、2Dインデックスに必要な2つの整数を受け取り、それらを1Dインデックスに変えるために少し算術を行います。

00:09:20.000 --> 00:09:25.000
しかし、プログラムの別の部分では、3次元配列が必要であることがわかります。

00:09:25.000 --> 00:09:28.000
2Dアレイとほぼ同じです。

00:09:28.000 --> 00:09:32.000
もう少しインデックスがあるだけで、計算はもう少し複雑です。

00:09:32.000 --> 00:09:47.000
そして、4Dアレイと5Dアレイが必要で、すぐにほぼ同一の配列タイプで泳いでいますが、ジェネリック、プロトコル拡張、サブクラス、またはSwiftがこの種のもののために提供する他の機能を使用するのに十分なほど近くはありません。

00:09:47.000 --> 00:09:53.000
幸いなことに、これらの構造体のそれぞれは宣言であるため、宣言マクロを使用して作成できます。

00:09:53.000 --> 00:10:02.000
では、N次元配列タイプを作成するので、「makeArrayND」という名前の自立型宣言マクロを宣言しましょう。

00:10:02.000 --> 00:10:14.000
次元の数をIntパラメータとして渡し、このマクロは他のコードで使用される結果を計算するのではなく、プログラムに宣言を追加するため、結果タイプを宣言しません。

00:10:14.000 --> 00:10:28.000
これで、2次元、3次元、4次元、5次元でマクロを4回呼び出すことができ、これらの呼び出しのそれぞれは、適切な数の引数とそのサイズに適した計算を持つ多次元配列タイプ全体に展開されます。

00:10:28.000 --> 00:10:31.000
これまでのところ、私たちは自立型マクロしか見ていません。

00:10:31.000 --> 00:10:34.000
それでは、添付されたマクロのロールに移りましょう。

00:10:34.000 --> 00:10:40.000
添付されたマクロは、名前が示すように、特定の宣言に添付されています。

00:10:40.000 --> 00:10:43.000
それは、彼らが作業するより多くの情報を持っていることを意味します。

00:10:43.000 --> 00:10:50.000
自立型マクロには、渡された引数のみが与えられますが、添付されたマクロは、添付されている宣言にアクセスすることもできます。

00:10:50.000 --> 00:10:56.000
彼らはしばしばその宣言を検査し、内部から名前、種類、その他の情報を引き出します。

00:10:56.000 --> 00:10:58.000
添付のピアロールから始めます。

00:10:58.000 --> 00:11:10.000
ピアマクロは、変数、関数、型だけでなく、インポート宣言や演算子宣言など、任意の宣言に添付でき、それと一緒に新しい宣言を挿入できます。

00:11:10.000 --> 00:11:20.000
したがって、メソッドまたはプロパティで使用すると、タイプのメンバーが作成されますが、トップレベルの関数またはタイプで使用すると、新しいトップレベルの宣言が作成されます。

00:11:20.000 --> 00:11:22.000
それは彼らを信じられないほど柔軟にします。

00:11:22.000 --> 00:11:24.000
ここにあなたがそれらを使うかもしれない1つの方法があります。

00:11:24.000 --> 00:11:35.000
Swiftの並行性を使用するライブラリを書いているが、一部のクライアントがまだ古い並行性技術を使用していることを知っているので、完了ハンドラを使用するAPIのバージョンを提供したいとします。

00:11:35.000 --> 00:11:37.000
これらの方法を書くのは難しくありません。

00:11:37.000 --> 00:11:46.000
「Async」キーワードを削除し、完了ハンドラパラメータを追加し、結果タイプをパラメータリストに移動し、切り離されたタスクで非同期バージョンを呼び出すだけです。

00:11:46.000 --> 00:11:50.000
しかし、あなたはこれをたくさんやっていて、手で書く必要はありません。

00:11:50.000 --> 00:11:53.000
それは添付されたピアマクロにとって素晴らしい仕事です。

00:11:53.000 --> 00:12:03.000
「AddCompletionHandler」と呼ばれるものを宣言し、完了ハンドラーの引数ラベルのパラメータを与え、そのマクロをメソッドの非同期バージョンに添付します。

00:12:03.000 --> 00:12:13.000
マクロは、オリジナルと同等の完了ハンドラベースの署名を作成し、メソッド本文を書き、完了ハンドラ用の余分なテキストを含むドキュメントコメントを添付します。

00:12:13.000 --> 00:12:15.000
かなりかっこいい。

00:12:15.000 --> 00:12:18.000
次に、添付のアクセサの役割を見てみましょう。

00:12:18.000 --> 00:12:26.000
これらは変数や添字に添付でき、「get」、「set」、「willSet」、または「didSet」などのアクセサをそれらにインストールできます。

00:12:26.000 --> 00:12:28.000
では、それはどのように役に立つのでしょうか?

00:12:28.000 --> 00:12:34.000
基本的に辞書をラップし、プロパティでそのコンテンツにアクセスできるタイプの束があるとします。

00:12:34.000 --> 00:12:47.000
たとえば、この「Person」構造体を使用すると、「name」、「height」、「birth_date」フィールドにアクセスできますが、これらの3つのフィールド以外に辞書に他の情報がある場合は、プログラムによって保存され、無視されます。

00:12:47.000 --> 00:12:59.000
これらの3つのプロパティには計算されたゲッターとセッターが必要ですが、手で書くのは面倒で、プロパティラッパーは使用されているタイプの他の保存されたプロパティにアクセスできないため、プロパティラッパーを使用できません。

00:12:59.000 --> 00:13:03.000
それでは、これに役立つ付属のアクセサマクロを書いてみましょう。

00:13:03.000 --> 00:13:05.000
私たちはそれを「DictionaryStorage」と呼びます。

00:13:05.000 --> 00:13:16.000
辞書は「birth_date」をアンダースコアで綴るため、「キー」パラメータを与えますが、キーを除外することもできます。デフォルトはnilになり、マクロはプロパティの名前をキーとして使用します。

00:13:16.000 --> 00:13:26.000
だから今、その大きなアクセサブロックを書く代わりに、各プロパティの前に「@DictionaryStorage」を置くだけで、マクロがあなたのためにアクセサを生成します。

00:13:26.000 --> 00:13:32.000
それは素晴らしい改善ですが、ここにはまだいくつかのボイラープレートがあります:同一の「DictionaryStorage」属性。

00:13:32.000 --> 00:13:35.000
それらはより少ない定型板ですが、それでも定型板です。

00:13:35.000 --> 00:13:42.000
一部の組み込み属性を使用すると、タイプまたは拡張機能全体に適用することで、この種の状況に対処できます。

00:13:42.000 --> 00:13:46.000
「アタッチメンバー属性」の役割は、マクロもそのように振る舞うことができます。

00:13:46.000 --> 00:13:53.000
マクロは型または拡張子にアタッチされ、アタッチされているもののメンバーに属性を追加できます。

00:13:53.000 --> 00:13:55.000
それがどのように行われるか見てみましょう。

00:13:55.000 --> 00:13:58.000
私たちはここで少し違うことをするつもりです。

00:13:58.000 --> 00:14:07.000
新しいマクロを宣言するのではなく、すでに持っている「アタッチされたアクセサー」ロールと一緒に、「DictionaryStorage」マクロに別のロール属性を追加します。

00:14:07.000 --> 00:14:10.000
これはマクロを作成するための本当に便利なテクニックです。

00:14:10.000 --> 00:14:19.000
スウィフトがどちらを使用すべきかわからない場所があるため、2つの自立型の役割を除いて、役割の任意の組み合わせを構成することができます。

00:14:19.000 --> 00:14:27.000
Swiftは、どこに適用しても意味のあるすべての役割を拡大しますが、少なくとも1つの役割はそこで働かなければなりません。

00:14:27.000 --> 00:14:32.000
したがって、タイプに「DictionaryStorage」をアタッチすると、Swiftは「メンバー属性」の役割を展開します。

00:14:32.000 --> 00:14:36.000
プロパティにアタッチすると、Swiftは「アクセサー」の役割を拡張します。

00:14:36.000 --> 00:14:44.000
しかし、関数にアタッチすると、「DictionaryStorage」には関数にアタッチできるロールがないため、コンパイルエラーが発生します。

00:14:44.000 --> 00:14:51.000
この2番目の役割を「DictionaryStorage」に追加すると、すべてのプロパティに個別に添付する代わりに、タイプ全体に添付できます。

00:14:51.000 --> 00:15:01.000
マクロには、初期化子、「dictionary」プロパティ、およびすでに「DictionaryStorage」属性を持つ「birth_date」などのプロパティなど、特定のメンバーをスキップするロジックがあります。

00:15:01.000 --> 00:15:10.000
しかし、他の保存されたプロパティに「DictionaryStorage」属性を追加し、それらの属性は私たちがすでに見たアクセサに展開されます。

00:15:10.000 --> 00:15:16.000
それは素晴らしい改善ですが、排除できる定型文はまだあります。初期化子と保存されたプロパティです。

00:15:16.000 --> 00:15:26.000
これらは「DictionaryRepresentable」プロトコルで必要とされ、プロパティはアクセサによって使用されますが、DictionaryStorageを使用するどのタイプでもまったく同じです。

00:15:26.000 --> 00:15:30.000
DictionaryStorageマクロに自動的に追加して、手で書く必要がないようにしましょう。

00:15:30.000 --> 00:15:33.000
「アタッチメンバー」の役割を使ってそれを行うことができます。

00:15:33.000 --> 00:15:42.000
メンバー属性マクロと同様に、これらのマクロをタイプと拡張に適用できますが、既存のメンバーに属性を追加する代わりに、まったく新しいメンバーを追加します。

00:15:42.000 --> 00:15:46.000
そのため、メソッド、プロパティ、初期化子などを追加できます。

00:15:46.000 --> 00:15:51.000
保存されたプロパティをクラスや構造体に追加したり、ケースを列挙に追加したりすることもできます。

00:15:51.000 --> 00:15:57.000
もう一度、DictionaryStorageマクロに新しい「アタッチメンバー」ロールを追加し、他の2つと一緒に構成します。

00:15:57.000 --> 00:16:03.000
この新しいロールは、初期化子と「辞書」というプロパティを追加します。

00:16:03.000 --> 00:16:10.000
2つの異なるマクロが同じコードに適用されると、どちらが最初に展開されるのか疑問に思うかもしれません。

00:16:10.000 --> 00:16:13.000
答えは、それは本当に問題ではないということです。

00:16:13.000 --> 00:16:18.000
それぞれが、他の人から提供された拡張なしで宣言のオリジナルバージョンを見るでしょう。

00:16:18.000 --> 00:16:21.000
だから、注文について心配する必要はありません。

00:16:21.000 --> 00:16:25.000
コンパイラがいつマクロを展開しても、同じものが表示されます。

00:16:25.000 --> 00:16:30.000
添付のメンバーの役割が追加されると、その2人のメンバーを書く必要さえありません。

00:16:30.000 --> 00:16:35.000
タイプでDictionaryStorageを使用するだけで、自動的に追加されます。

00:16:35.000 --> 00:16:44.000
そして、他の役割はプロパティにDictionaryStorage属性を追加し、それらの属性はアクセサに展開されます。

00:16:44.000 --> 00:16:51.000
しかし、排除すべき定型文の最後のビットがまだ1つあります。DictionaryRepresentableプロトコルへの適合性です。

00:16:51.000 --> 00:16:55.000
「アタッチコンフォーマンス」の役割は、これに最適です。

00:16:55.000 --> 00:16:59.000
タイプまたは拡張機能に適合性を追加できます。

00:16:59.000 --> 00:17:05.000
「DictionaryStorage」マクロに最後の「添付コンフォーマンス」ロールを追加し、他の3つと一緒に構成します。

00:17:05.000 --> 00:17:08.000
この新しい役割は、「DictionaryRepresentation」への適合性を追加します。

00:17:08.000 --> 00:17:12.000
だから今、私たちは手動で適合性を書く必要はありません。

00:17:12.000 --> 00:17:22.000
アクセサと生成されたメンバーにすでに追加したDictionaryStorage属性は、すでに行っていた他のすべてのものとともに、適合性も自動的に追加されます。

00:17:22.000 --> 00:17:40.000
出発点を見てから長い時間が経っているので、あなたに思い出させるために、私たちは反復的なコードでいっぱいの大きな、手に負えないタイプを取り、そのコードのほとんどを超強力なマクロのいくつかの役割に移動して、この特定のタイプの特別なものだけを簡潔に指定しました。

00:17:40.000 --> 00:17:44.000
DictionaryStorageを使用できる10種類または20種類があると想像してみてください。

00:17:44.000 --> 00:17:47.000
それらすべてと一緒に仕事をするのはどれくらい簡単ですか?

00:17:47.000 --> 00:17:56.000
私たちは今、宣言と役割について話すのに多くの時間を費やしてきましたが、これまでのところ、彼らが拡張するコードは魔法のように現れているように見えました。

00:17:56.000 --> 00:18:00.000
今、そのギャップを埋めて、マクロの実装方法について話しましょう。

00:18:00.000 --> 00:18:07.000
これまでにマクロ宣言を見せたとき、私は非常に重要なことを省略しました：実装。

00:18:07.000 --> 00:18:11.000
それは等号の後であり、常に別のマクロです。

00:18:11.000 --> 00:18:19.000
時には、パラメータを再配置したり、リテラルとして指定された余分なパラメータで、あなたが書いた別のマクロです。

00:18:19.000 --> 00:18:22.000
しかし、通常、外部マクロを使用します。

00:18:22.000 --> 00:18:26.000
外部マクロは、コンパイラプラグインによって実装されるものです。

00:18:26.000 --> 00:18:29.000
先ほどコンパイラプラグインについて話したことを覚えているかもしれません。

00:18:29.000 --> 00:18:37.000
私は、コンパイラがマクロが使用されているのを見ると、別のプロセスでプラグインを開始し、マクロを展開するように要求すると言いました。

00:18:37.000 --> 00:18:41.000
「#externalMacro」は、その関係を定義するものです。

00:18:41.000 --> 00:18:47.000
コンパイラが起動するプラグインと、そのプラグイン内の型の名前を指定します。

00:18:47.000 --> 00:18:55.000
したがって、Swiftがこのマクロを拡張すると、「MyLibMacros」というプラグインを起動し、「StringifyMacro」というタイプに展開を依頼します。

00:18:55.000 --> 00:19:04.000
したがって、マクロ宣言は他のAPIと一緒に通常のライブラリに入りますが、マクロの実装は別のコンパイラプラグインモジュールに入ります。

00:19:04.000 --> 00:19:10.000
そして、「#externalMacro」は、宣言とそれを実装するタイプの間のリンクを作成します。

00:19:10.000 --> 00:19:13.000
マクロの実装はどのようなものですか?

00:19:13.000 --> 00:19:17.000
さて、DictionaryStorageがどのように実装されるかを見てみましょう。

00:19:17.000 --> 00:19:25.000
思い出せば、「DictionaryStorage」マクロには、格納されたプロパティと初期化子をタイプに追加した「添付メンバー」ロールがありました。

00:19:25.000 --> 00:19:27.000
これがその役割の簡単な実装です。

00:19:27.000 --> 00:19:32.000
私たちはそれを一歩ずつ歩き、それがどのように機能するかを学びます。

00:19:32.000 --> 00:19:37.000
一番上で、SwiftSyntaxというライブラリをインポートすることから始めます。

00:19:37.000 --> 00:19:45.000
SwiftSyntaxは、Swiftソースコードの解析、検査、操作、生成に役立つSwiftプロジェクトによって維持されているパッケージです。

00:19:45.000 --> 00:19:52.000
Swiftコントリビューターは、言語が進化するにつれてSwiftSyntaxを最新の状態に保つため、Swiftコンパイラが行うすべての機能をサポートします。

00:19:52.000 --> 00:19:56.000
SwiftSyntaxは、ソースコードを特別なツリー構造として表します。

00:19:56.000 --> 00:20:03.000
たとえば、このコードサンプルの「Person」構造体は、「StructDeclSyntax」と呼ばれる型のインスタンスとして表されます。

00:20:03.000 --> 00:20:11.000
しかし、そのインスタンスにはプロパティがあり、それらのプロパティのそれぞれは構造体宣言の一部を表します。

00:20:11.000 --> 00:20:14.000
属性のリストは「属性」プロパティにあります。

00:20:14.000 --> 00:20:17.000
実際のキーワード「struct」は「structKeyword」プロパティにあります。

00:20:17.000 --> 00:20:20.000
構造体の名前は「識別子」プロパティにあります。

00:20:20.000 --> 00:20:26.000
そして、波括弧と構造体のメンバーを持つ体は「memberBlock」プロパティにあります。

00:20:26.000 --> 00:20:30.000
一部の構造体宣言が持つものを表す「修飾子」のようなプロパティもあります。

00:20:30.000 --> 00:20:33.000
しかし、これはそうではありません。これらはゼロです。

00:20:33.000 --> 00:20:37.000
これらのプロパティの構文ノードのいくつかは「トークン」と呼ばれています。

00:20:37.000 --> 00:20:50.000
これらは、名前、キーワード、または少しの句読点など、ソースファイル内の特定のテキストを表し、そのテキストとスペースやコメントなどの周囲のトリビアが含まれています。

00:20:50.000 --> 00:20:56.000
構文ツリーを十分に掘り下げると、ソースファイルのすべてのバイトをカバーするトークンノードが見つかります。

00:20:56.000 --> 00:21:06.000
しかし、「attributes」プロパティの「AttributeListSyntax」ノードや「memberBlock」プロパティの「MemberDeclBlockSyntax」ノードなど、これらのノードのいくつかはトークンではありません。

00:21:06.000 --> 00:21:09.000
これらは、独自のプロパティに子ノードを持っています。

00:21:09.000 --> 00:21:20.000
たとえば、「memberBlock」プロパティ内を調べると、開始中括弧のトークン、メンバーリストの「MemberDeclListSyntax」ノード、および終了中括弧のトークンが見つかります。

00:21:20.000 --> 00:21:28.000
そして、その「MemberDeclListSyntax」ノードの内容を探索し続けると、最終的に各プロパティのノードなどを見つけることができます。

00:21:28.000 --> 00:21:36.000
SwiftSyntaxでの作業はそれ自体が大きなトピックなので、このビデオを2倍長くするのではなく、他の2つのリソースを紹介します。

00:21:36.000 --> 00:21:46.000
1つは、コンパニオン「Write Swift Macros」セッションで、特定のソースコードが構文ツリーとしてどのように表現されるかを理解するための実用的なヒントが含まれています。

00:21:46.000 --> 00:21:50.000
もう1つは、SwiftSyntaxパッケージのドキュメントです。

00:21:50.000 --> 00:21:59.000
オンラインで見つけるか、マクロパッケージでXcodeのBuild Documentationコマンドを使用すると、SwiftSyntaxドキュメントが開発者ドキュメントウィンドウに表示されます。

00:21:59.000 --> 00:22:04.000
メインのSwiftSyntaxライブラリに加えて、他の2つのモジュールもインポートします。

00:22:04.000 --> 00:22:10.000
1つは、マクロを書くために必要なプロトコルとタイプを提供する「SwiftSyntaxMacros」です。

00:22:10.000 --> 00:22:13.000
もう1つは「SwiftSyntaxBuilder」と呼ばれています。

00:22:13.000 --> 00:22:19.000
このライブラリは、新しく生成されたコードを表す構文ツリーを構築するための便利なAPIを提供します。

00:22:19.000 --> 00:22:25.000
マクロは使用せずに書くことができますが、非常に便利で、それを利用することを強くお勧めします。

00:22:25.000 --> 00:22:32.000
これらのライブラリをインポートしたので、プラグインが提供するはずの「DictionaryStorageMacro」タイプを実際に書き始めます。

00:22:32.000 --> 00:22:36.000
「MemberMacro」と呼ばれるプロトコルに準拠していることに注意してください。

00:22:36.000 --> 00:22:44.000
各ロールには対応するプロトコルがあり、実装はマクロが提供する各ロールのプロトコルに準拠している必要があります。

00:22:44.000 --> 00:22:52.000
「DictionaryStorage」マクロにはこれらの役割の4つがあるため、「DictionaryStorageMacro」タイプは、対応する4つのプロトコルに準拠する必要があります。

00:22:52.000 --> 00:22:57.000
しかし、物事をシンプルにするために、私たちは今のところ「MemberMacro」の適合性を心配しているだけです。

00:22:57.000 --> 00:23:04.000
このタイプの本体に移動すると、「expansion of, providingMembersOf, in」という方法が見られます。

00:23:04.000 --> 00:23:12.000
このメソッドはMemberMacroプロトコルによって必要であり、マクロが使用されるときにメンバーの役割を展開するためにSwiftコンパイラが呼び出すものです。

00:23:12.000 --> 00:23:16.000
私たちはまだ議論を使用していませんが、後でそれらについて話します。

00:23:16.000 --> 00:23:19.000
今のところ、それが静的な方法であることに注目してください。

00:23:19.000 --> 00:23:25.000
すべての拡張メソッドは静的であるため、Swiftは実際にDictionaryStorageMacroタイプのインスタンスを作成しません。

00:23:25.000 --> 00:23:28.000
メソッドのコンテナとして使用するだけです。

00:23:28.000 --> 00:23:33.000
各拡張メソッドは、ソースコードに挿入されたSwiftSyntaxノードを返します。

00:23:33.000 --> 00:23:43.000
メンバーマクロは、タイプにメンバーとして追加する宣言のリストに展開されるため、メンバーマクロの展開メソッドは「DeclSyntax」ノードの配列を返します。

00:23:43.000 --> 00:23:47.000
体の中を見ると、その配列が作成されていることがわかります。

00:23:47.000 --> 00:23:51.000
このマクロを追加したい初期化子と保存されたプロパティがあります。

00:23:51.000 --> 00:23:57.000
さて、ここの「var辞書」ビットは普通の文字列のように見えますが、実際にはそうではありません。

00:23:57.000 --> 00:24:07.000
この文字列リテラルはDeclSyntaxが期待される場所に書かれているので、Swiftは実際にそれをソースコードの断片として扱い、SwiftパーサーにDeclSyntaxノードに変えるように依頼します。

00:24:07.000 --> 00:24:11.000
これは、SwiftSyntaxBuilderライブラリが提供する便利な機能の1つです。

00:24:11.000 --> 00:24:14.000
もっと早く輸入してよかった。

00:24:14.000 --> 00:24:22.000
そのため、他の3つの役割のプロトコルに準拠して、DictionaryStorageマクロの実用的な実装があります。

00:24:22.000 --> 00:24:28.000
しかし、このマクロは正しく使用すると機能しますが、間違って使用するとどうなりますか?

00:24:28.000 --> 00:24:33.000
たとえば、構造体ではなく列挙型に適用しようとするとどうなりますか?

00:24:33.000 --> 00:24:38.000
さて、「アタッチメンバー」ロールは、保存された「辞書」プロパティを追加しようとします。

00:24:38.000 --> 00:24:45.000
しかし、列挙型は保存されたプロパティを持つことができないので、Swiftは「Enumsは保存されたプロパティを含んではならない」というエラーを生成します。

00:24:45.000 --> 00:24:51.000
Swiftがこのコードのコンパイルを停止するのは素晴らしいことですが、エラーメッセージは少し混乱していますね。

00:24:51.000 --> 00:24:57.000
なぜDictionaryStorageマクロがストアドプロパティを作成しようとしたのか、または何を違う方法で行うべきだったのかは明らかではありません。

00:24:57.000 --> 00:25:04.000
先ほど、Swiftの目標の1つは、マクロが入力の間違いを検出し、カスタムエラーを発生させることだと言いました。

00:25:04.000 --> 00:25:13.000
では、マクロの実装を変更して、より明確なエラーメッセージを生成しましょう。「@DictionaryStorageは構造体にのみ適用できます。」

00:25:13.000 --> 00:25:16.000
これにより、開発者は何が間違ったのかをよりよく知ることができるでしょう。

00:25:16.000 --> 00:25:22.000
これを行うための鍵は、これまで無視してきた拡張メソッドのパラメータです。

00:25:22.000 --> 00:25:28.000
正確な議論は役割によってわずかに異なりますが、メンバーマクロには3つあります。

00:25:28.000 --> 00:25:32.000
1つ目は「属性」と呼ばれ、その型はAttributeSyntaxです。

00:25:32.000 --> 00:25:37.000
これは、開発者がマクロを使用するために書いた実際のDictionaryStorage属性です。

00:25:37.000 --> 00:25:42.000
2番目の引数は「宣言」と呼ばれ、「DeclGroupSyntax」に準拠した型です。

00:25:42.000 --> 00:25:51.000
DeclGroupSyntaxは、構造体、列挙型、クラス、アクター、プロトコル、および拡張機能のノードがすべて準拠するプロトコルです。

00:25:51.000 --> 00:25:56.000
したがって、このパラメータは、開発者が属性を添付した宣言を提供します。

00:25:56.000 --> 00:26:02.000
そして、最後のパラメータは「context」と呼ばれ、「MacroExpansionContext」に準拠したタイプです。

00:26:02.000 --> 00:26:07.000
コンテキストオブジェクトは、マクロ実装がコンパイラと通信したいときに使用されます。

00:26:07.000 --> 00:26:12.000
エラーや警告の発行など、いくつかの異なることを行うことができます。

00:26:12.000 --> 00:26:15.000
これら3つのパラメータすべてを使用してエラーを発行します。

00:26:15.000 --> 00:26:17.000
それがどのように行われるか見てみましょう。

00:26:17.000 --> 00:26:19.000
まず、問題を検出する必要があります。

00:26:19.000 --> 00:26:23.000
これを行うには、「宣言」パラメータのタイプをチェックします。

00:26:23.000 --> 00:26:34.000
宣言の種類ごとに異なる型があるので、それが構造体であれば、その型は「StructDeclSyntax」、列挙型であれば「EnumDeclSyntax」などになります。

00:26:34.000 --> 00:26:41.000
そこで、「宣言」パラメータの「is」メソッドを呼び出し、「StructDeclSyntax」を渡すguard-elseを書きます。

00:26:41.000 --> 00:26:45.000
宣言が構造体でない場合は、「else」ブロックになります。

00:26:45.000 --> 00:26:54.000
今のところ、空の配列を返すので、マクロはプロジェクトにコードを追加しませんが、私たちが本当にやりたいことはエラーを出すことです。

00:26:54.000 --> 00:27:01.000
さて、それを行う簡単な方法は、通常のSwiftエラーをスローすることですが、それは出力をあまり制御することはできません。

00:27:01.000 --> 00:27:06.000
代わりに、より洗練されたエラーを作成できる、より複雑な方法を紹介します。

00:27:06.000 --> 00:27:11.000
最初のステップは、「診断」というタイプのインスタンスを作成することです。

00:27:11.000 --> 00:27:13.000
これはちょっとしたコンパイラの専門用語です。

00:27:13.000 --> 00:27:24.000
壊れた足のX線を見ている医師が骨折を診断するように、壊れたコードの構文ツリーを見ているコンパイラまたはマクロはエラーまたは警告を診断します。

00:27:24.000 --> 00:27:28.000
したがって、エラーを表すインスタンスを「診断」と呼びます。

00:27:28.000 --> 00:27:32.000
診断には少なくとも2つの情報が含まれています。

00:27:32.000 --> 00:27:38.000
1つ目は、エラーが発生した構文ノードなので、コンパイラはどの行を不正確としてマークするかを知っています。

00:27:38.000 --> 00:27:47.000
ここでは、ユーザーが書いたDictionaryStorage属性を指摘したいと思います。これは、幸いなことに、メソッドが渡された「属性」パラメータによって提供されます。

00:27:47.000 --> 00:27:51.000
2つ目は、コンパイラに生成させたい実際のメッセージです。

00:27:51.000 --> 00:27:55.000
カスタムタイプを作成し、そのインスタンスを渡すことで、これを提供します。

00:27:55.000 --> 00:27:58.000
ざっと見てみましょう。 

00:27:58.000 --> 00:28:04.000
「MyLibDiagnostic」タイプは、このモジュールが生成できるすべての診断を定義します。

00:28:04.000 --> 00:28:11.000
列挙型を使用し、各診断にケースを提供することを選択しましたが、必要に応じて別の種類のタイプを使用できます。

00:28:11.000 --> 00:28:14.000
このタイプは、スロー可能なSwiftエラーのように機能します。

00:28:14.000 --> 00:28:21.000
「DiagnosticMessage」プロトコルに準拠しており、診断に関する情報を提供する多くのプロパティがあります。

00:28:21.000 --> 00:28:24.000
最も重要なものの1つは「重大度」の特性です。

00:28:24.000 --> 00:28:30.000
診断がエラーか警告かを指定します。

00:28:30.000 --> 00:28:37.000
次に、実際のエラーメッセージを生成する「message」プロパティと「diagnosticID」プロパティがあります。

00:28:37.000 --> 00:28:42.000
ドメインにはプラグインのモジュール名を使用し、IDには何らかの一意の文字列を使用する必要があります。

00:28:42.000 --> 00:28:46.000
この列挙型に文字列の生値を使用することを選択しましたが、それは単なる利便性です。

00:28:46.000 --> 00:28:51.000
したがって、メッセージを手にして、診断を作成できます。

00:28:51.000 --> 00:28:56.000
その後、それを診断するためにコンテキストを指示し、完了です。

00:28:56.000 --> 00:29:00.000
それはかなり基本的な診断ですが、あなたが望むなら、あなたは彼らと一緒に多くのファンシーを得ることができます。

00:29:00.000 --> 00:29:06.000
たとえば、Xcode Fixボタンによって自動的に適用される診断にFix-Itsを追加できます。

00:29:06.000 --> 00:29:10.000
ハイライトを追加したり、コード内の他の場所を指すメモを添付したりすることもできます。

00:29:10.000 --> 00:29:14.000
そのため、開発者に一流のエラー体験を提供できます。

00:29:14.000 --> 00:29:20.000
しかし、マクロが正しく適用されていることを確認したら、実際に展開を作成する必要があります。

00:29:20.000 --> 00:29:24.000
SwiftSyntaxは、それを行うためのいくつかの異なるツールを提供します。

00:29:24.000 --> 00:29:32.000
構文ノードは不変ですが、新しいノードを作成するか、既存のノードの修正バージョンを返すAPIがたくさんあります。

00:29:32.000 --> 00:29:39.000
SwiftSyntaxBuilderライブラリは、子ノードの一部が末尾のクロージャによって指定されるSwiftUIスタイルの構文ビルダーを追加します。

00:29:39.000 --> 00:29:48.000
たとえば、多次元配列マクロは、構文ビルダーを使用して、作成するタイプに適した数のパラメータを生成できます。

00:29:48.000 --> 00:29:56.000
また、DictionaryStorageプロパティと初期化子を作成するために使用した文字列リテラル機能も補間をサポートしています。

00:29:56.000 --> 00:30:04.000
これらの機能はすべてさまざまな状況で有用であり、おそらく特に複雑なマクロでいくつかを組み合わせることに気付くでしょう。

00:30:04.000 --> 00:30:12.000
しかし、文字列リテラル機能は、大量のコードの構文ツリーを生成するのに特に得意であり、その補間機能について学ぶべき点が少しあります。

00:30:12.000 --> 00:30:16.000
では、それらを使用してコードを生成する方法を見てみましょう。

00:30:16.000 --> 00:30:19.000
先ほど、「アンラップ」マクロについて話しました。

00:30:19.000 --> 00:30:25.000
オプションの値とメッセージ文字列を受け取り、クロージャでラップされた「ガードレット」に展開されます。

00:30:25.000 --> 00:30:32.000
このコードの一般的な形状は常に同じですが、多くのコンテンツは特定の使用サイトに合わせてカスタマイズされています。

00:30:32.000 --> 00:30:38.000
「Guard let」ステートメントに焦点を当てて、そのステートメントだけを生成する関数を書く方法を見てみましょう。

00:30:38.000 --> 00:30:47.000
まず、先ほど見た正確なコードサンプルを取り、ステートメント構文ノードを返す「makeGuardStatement」と呼ばれるヘルパーメソッドに入れます。

00:30:47.000 --> 00:30:53.000
次に、使用場所に応じて異なる必要があるすべてのものを置き換えるために、ゆっくりと補間を追加します。

00:30:53.000 --> 00:30:57.000
最初に行うことは、正しいメッセージ文字列を追加することです。

00:30:57.000 --> 00:31:04.000
メッセージ文字列は任意の式なので、ExprSyntaxノードとして渡してから補間します。

00:31:04.000 --> 00:31:10.000
このような通常の補間では、コードに構文ノードを追加できますが、プレーンな文字列を追加することはできません。

00:31:10.000 --> 00:31:15.000
これは、誤って無効なコードを挿入するのを防ぐための安全機能です。

00:31:15.000 --> 00:31:21.000
Guard-letの条件は似ていますが、単なる変数名なので、式ではなくトークンです。

00:31:21.000 --> 00:31:28.000
関係なく、式を補間したのと同じように、TokenSyntaxパラメータを追加して補間します。

00:31:28.000 --> 00:31:33.000
ラップされていない式をエラーメッセージに追加すると、よりトリッキーなケースがあります。

00:31:33.000 --> 00:31:38.000
マクロの特徴の1つは、失敗すると、解明しようとしていたコードが出力されることです。

00:31:38.000 --> 00:31:44.000
つまり、構文ノードの文字列化されたバージョンを含む文字列リテラルを作成する必要があります。

00:31:44.000 --> 00:31:50.000
まず、プレフィックスをステートメント構文のリテラルから引き出して、単なる文字列である変数にしましょう。

00:31:50.000 --> 00:31:56.000
その文字列を補間しますが、「リテラル:」で始まる特別な補間を使用します。

00:31:56.000 --> 00:32:01.000
これを行うと、SwiftSyntaxは文字列の内容を文字列リテラルとして追加します。

00:32:01.000 --> 00:32:10.000
これは、マクロ、数値、ブール値、配列、辞書、さらにはオプションによって計算された他の種類の情報からリテラルを作成するためにも機能します。

00:32:10.000 --> 00:32:15.000
変数に文字列を構築したので、メッセージに適切なコードを持つように変更できます。

00:32:15.000 --> 00:32:22.000
元の式のパラメータを追加し、その「説明」プロパティを文字列に補間するだけです。

00:32:22.000 --> 00:32:24.000
あなたはそれを逃れるために特別なことをする必要はありません。

00:32:24.000 --> 00:32:33.000
「リテラル:」補間は、文字列に特殊文字が含まれているかどうかを自動的に検出し、エスケープを追加するか、コードが有効であることを確認するために生のリテラルに切り替えます。

00:32:33.000 --> 00:32:38.000
したがって、「リテラル」補間により、正しいことを非常に簡単に行うことができます。

00:32:38.000 --> 00:32:41.000
最後に対処すべきことは、ファイルと行番号です。

00:32:41.000 --> 00:32:47.000
コンパイラは、展開しているソースの場所をマクロに伝えないため、これらは少しトリッキーです。

00:32:47.000 --> 00:32:56.000
ただし、マクロ拡張コンテキストには、コンパイラがソース位置情報を持つリテラルに変わる特別な構文ノードを生成するために使用できるAPIがあります。

00:32:56.000 --> 00:32:58.000
では、それがどのように行われるか見てみましょう。

00:32:58.000 --> 00:33:04.000
マクロ展開コンテキストに別の引数を追加し、その「場所」メソッドを使用します。

00:33:04.000 --> 00:33:09.000
これは、提供するノードの場所の構文ノードを生成できるオブジェクトを返します。

00:33:09.000 --> 00:33:24.000
ノードがコンパイラがあなたに渡したノードではなく、マクロが作成したノードである場合はnilを返しますが、「originalWrapped」はユーザーが書いた引数の1つであることを知っているので、その場所は決してnilではなく、結果を安全に強制解除できます。

00:33:24.000 --> 00:33:31.000
今、あなたがしなければならないのは、ファイルと行番号の構文ノードを補間することだけで完了です。

00:33:31.000 --> 00:33:34.000
私たちは今、正しい「ガード」ステートメントを生成しています。

00:33:34.000 --> 00:33:38.000
これまでのところ、マクロを機能させる方法について議論しました。

00:33:38.000 --> 00:33:41.000
しかし、先に進んで、それらをうまく機能させる方法について話しましょう。

00:33:41.000 --> 00:33:45.000
そして、名前の衝突について話すことから始めます。

00:33:45.000 --> 00:33:52.000
前に「アンラップ」マクロを見たとき、単純な変数名をアンラップした例を見ました。

00:33:52.000 --> 00:33:57.000
しかし、より複雑な表現を展開しようとすると、マクロは異なる方法で展開する必要があります。

00:33:57.000 --> 00:34:05.000
式の結果を「wrappedValue」と呼ばれる変数にキャプチャするコードを生成し、それをアンラップします。

00:34:05.000 --> 00:34:11.000
しかし、メッセージで「wrappedValue」という変数を使用しようとするとどうなりますか?

00:34:11.000 --> 00:34:20.000
コンパイラが「wrappedValue」を探しに行くと、より近いものを見つけることになるので、実際に意味したものの代わりにそれを使用します。

00:34:20.000 --> 00:34:30.000
ユーザーがおそらく偶然に使用しないと思う名前を選んで、これを修正しようとすることができますが、これを不可能にした方が良いのではないでしょうか?

00:34:30.000 --> 00:34:35.000
それが、マクロ展開コンテキストの「makeUniqueName」メソッドが行うことです。

00:34:35.000 --> 00:34:46.000
ユーザーコードやその他のマクロ展開で使用されないことが保証されている変数名を返すので、メッセージ文字列が誤って参照されないことを確認できます。

00:34:46.000 --> 00:34:51.000
なぜスウィフトは自動的にそれが起こるのを止めないのか、疑問に思う人もいるかもしれません。

00:34:51.000 --> 00:35:02.000
一部の言語には、いわゆる「衛生的な」マクロシステムがあり、マクロ内の名前は外部の名前とは異なるため、互いに競合することはできません。

00:35:02.000 --> 00:35:08.000
Swiftは、多くのマクロが外部からの名前を使用する必要があることがわかったので、そうではありません。

00:35:08.000 --> 00:35:13.000
タイプに「辞書」プロパティを使用するDictionaryStorageマクロを考えてみてください。

00:35:13.000 --> 00:35:21.000
マクロ内の「辞書」が外部の「辞書」とは異なることを意味する場合、それを機能させるのはかなり難しいでしょう。

00:35:21.000 --> 00:35:27.000
また、非マクロコードがアクセスできるまったく新しい名前を導入したい場合もあります。

00:35:27.000 --> 00:35:34.000
ピアマクロ、メンバーマクロ、および宣言マクロは、基本的にこれを行うために完全に存在します。

00:35:34.000 --> 00:35:39.000
しかし、彼らがそうするとき、彼らは追加している名前を宣言する必要があるので、コンパイラはそれらについて知っています。

00:35:39.000 --> 00:35:43.000
そして、彼らは彼らの役割属性の中でそれを行います。

00:35:43.000 --> 00:35:48.000
あなたは以前にそれに気付かなかったかもしれませんが、私たちは実際にこれらの宣言をずっと見てきました。

00:35:48.000 --> 00:35:56.000
DictionaryStorageマクロの「メンバー」ロールには、「dictionary」と「init」という名前を指定する「names:」パラメータがありました。

00:35:56.000 --> 00:36:02.000
実際、このセッションで見たマクロのほとんどは、「名前」の引数を持つ少なくとも1つの役割を持っています。

00:36:02.000 --> 00:36:13.000
使用できる5つの名前指定子があります。「オーバーロード」とは、マクロがマクロが添付されているのとまったく同じ基本名で宣言を追加することを意味します。

00:36:13.000 --> 00:36:19.000
「プレフィックス」とは、指定されたプレフィックスが追加された場合を除き、マクロが同じベース名の宣言を追加することを意味します。

00:36:19.000 --> 00:36:24.000
「接尾辞付き」は、接頭辞の代わりに接尾辞を除いて、同じものです。

00:36:24.000 --> 00:36:30.000
「Named」とは、マクロが特定の固定基本名で宣言を追加することを意味します。

00:36:30.000 --> 00:36:37.000
そして、「任意」とは、マクロがこれらのルールのいずれを使用しても記述できない他の名前で宣言を追加することを意味します。

00:36:37.000 --> 00:36:39.000
「恣意的」を使うのは本当に一般的です。

00:36:39.000 --> 00:36:47.000
たとえば、多次元配列マクロは、そのパラメータの1つから計算された名前を持つ型を宣言するので、「任意」を指定する必要があります。

00:36:47.000 --> 00:36:51.000
しかし、他の指定子の1つを使用できる場合は、そうしてください。

00:36:51.000 --> 00:36:56.000
コンパイラとコード補完などの他のツールの両方が速くなります。

00:36:56.000 --> 00:37:01.000
さて、セッションのこの時点で、皆さんは最初のマクロを書きたがっていると思います。

00:37:01.000 --> 00:37:07.000
そして、あなたは始める方法の素晴らしいアイデアを持っているかもしれません:それが展開された日付と時刻を挿入するマクロを書くだけです。

00:37:07.000 --> 00:37:09.000
いい考えだよね？

00:37:09.000 --> 00:37:11.000
間違っています。

00:37:11.000 --> 00:37:14.000
結局のところ、このマクロを書いてはいけません。

00:37:14.000 --> 00:37:16.000
理由を説明させてください。

00:37:16.000 --> 00:37:21.000
マクロは、コンパイラが提供する情報のみを使用する必要があります。

00:37:21.000 --> 00:37:31.000
コンパイラは、マクロ実装は純粋な関数であり、提供したデータが変更されていない場合、展開も変更できないことを前提としています。

00:37:31.000 --> 00:37:35.000
それを回避すると、一貫性のない行動が見られるかもしれません。

00:37:35.000 --> 00:37:41.000
現在、マクロシステムは、このルールに違反する可能性のあるある種の行動を防ぐように設計されています。

00:37:41.000 --> 00:37:49.000
コンパイラプラグインは、マクロ実装がディスク上のファイルを読んだり、ネットワークにアクセスしたりするのを停止するサンドボックスで実行されます。

00:37:49.000 --> 00:37:52.000
しかし、サンドボックスはすべての悪い行動をブロックするわけではありません。

00:37:52.000 --> 00:38:02.000
APIを使用して日付や乱数などの情報を取得することも、ある展開からの情報をグローバル変数に保存して別の展開で使用することもできます。

00:38:02.000 --> 00:38:06.000
しかし、これらのことをすると、マクロが誤動作する可能性があります。

00:38:06.000 --> 00:38:08.000
だから、しないでください。

00:38:08.000 --> 00:38:13.000
最後になりましたが、テストについて話しましょう。

00:38:13.000 --> 00:38:22.000
あなたのマクロプラグインは普通のSwiftモジュールです。つまり、通常の単体テストを書くことができ、間違いなく書くべきです。

00:38:22.000 --> 00:38:27.000
テスト駆動開発は、Swiftマクロを開発するための非常に効果的なアプローチです。

00:38:27.000 --> 00:38:35.000
SwiftSyntaxMacrosTestSupportの「assertMacroExpansion」ヘルパーは、マクロが適切な展開を生成することを確認します。

00:38:35.000 --> 00:38:40.000
マクロと展開すべきコードの例を挙げるだけで、それらが一致することを確認します。

00:38:40.000 --> 00:38:44.000
だから、私たちは今日、Swiftマクロについて多くのことを学びました。

00:38:44.000 --> 00:38:52.000
マクロを使用すると、小規模な使用サイトをより複雑なコードに「拡張」する新しい言語機能を設計することで、定型文を減らすことができます。

00:38:52.000 --> 00:39:01.000
通常、ライブラリで他のAPIと一緒にマクロを宣言しますが、実際には安全なサンドボックスでSwiftコードを実行する別のプラグインで実装します。

00:39:01.000 --> 00:39:07.000
マクロの役割は、それを使用できる場所と、その拡張がプログラムの残りの部分にどのように統合されているかを表します。

00:39:07.000 --> 00:39:14.000
そして、期待どおりに機能することを確認するために、マクロの単体テストを書くことができますし、間違いなく書くべきです。

00:39:14.000 --> 00:39:19.000
まだ見ていない場合は、「Write Swift Macros」セッションが次の目的地になるはずです。

00:39:19.000 --> 00:39:31.000
Xcodeのマクロ開発ツールとマクロパッケージテンプレートの操作方法、SwiftSyntaxツリーを検査して情報を引き出す方法、ユニットテストを中心にマクロ開発ワークフローを構築する方法を紹介します。

00:39:31.000 --> 00:39:35.000
だから、見てくれてありがとう、そして幸せなコーディング。

00:39:35.000 --> 23:59:59.000
♪ ♪

