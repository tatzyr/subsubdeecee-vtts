WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:14.000
Si：こんにちは、私はAppleのSwift on ServerチームのSiです。

00:00:14.000 --> 00:00:20.000
このビデオでは、Swift OpenAPI GeneratorがサーバーAPIの操作にどのように役立つかを紹介します。

00:00:20.000 --> 00:00:29.000
iOSアプリを拡張する場合でも、Swiftでバックエンドサーバーを作成する場合でも、この新しいSwiftパッケージプラグインはワークフローを合理化し、コードベースを簡素化できます。

00:00:29.000 --> 00:00:34.000
今年は、デバイス上のデータ操作がこれまで以上に簡単になったことを見てきました。

00:00:34.000 --> 00:00:39.000
しかし、実装したい機能には、サーバーコンポーネントによって提供される動的コンテンツが必要になる場合があります。

00:00:39.000 --> 00:00:44.000
これは、リモートサービスにネットワーク要求を行い、そのAPIを呼び出すことを意味します。

00:00:44.000 --> 00:00:49.000
しかし、適切なネットワーク要求を行うためには、考慮すべきことがたくさんあります。

00:00:49.000 --> 00:00:52.000
サーバーのベースURLは何ですか?

00:00:52.000 --> 00:00:55.000
APIエンドポイントを構成するパスコンポーネントは何ですか?

00:00:55.000 --> 00:00:58.000
どのようなHTTPメソッドを使用すべきですか?

00:00:58.000 --> 00:01:01.000
そして、どのようにパラメータを提供するべきですか?

00:01:01.000 --> 00:01:05.000
これらは、サーバーAPIを呼び出す際に考慮すべき質問のほんの一部です。

00:01:05.000 --> 00:01:09.000
より複雑なAPIについては、さらに多くのことを考慮する必要があります。

00:01:09.000 --> 00:01:13.000
では、これらの質問にどのように答えますか?

00:01:13.000 --> 00:01:16.000
ほとんどのサービスには、何らかの形のAPIドキュメントがあります。

00:01:16.000 --> 00:01:24.000
しかし、手書きの文書は、特にサービスが急速に進化している場合、不正確または時代遅れになることがよくあります。

00:01:24.000 --> 00:01:30.000
ソースコードにアクセスできる場合は、実装を見るか、手動でAPIを試すことができます。

00:01:30.000 --> 00:01:35.000
しかし、これはサービスの動作の不完全な理解につながる可能性があります。

00:01:35.000 --> 00:01:39.000
サポートフォーラムを検索したり、他の機関の知識に頼ることができます。

00:01:39.000 --> 00:01:48.000
しかし、最も善意の個人でさえ、十分な情報不足であるか、一貫性のない答えを提供し、あなたが始めたよりも多くの質問を残します。

00:01:48.000 --> 00:01:52.000
これらのリソースはいくつかの助けを提供しますが、全体像ではありません。

00:01:52.000 --> 00:01:58.000
APIのより正式で構造化された説明を使用すると、曖昧さを排除するのに役立ちます。

00:01:58.000 --> 00:02:04.000
HTTPサービスを定義するためのオープン仕様であるOpenAPIをご紹介します。

00:02:04.000 --> 00:02:14.000
OpenAPIは業界標準であり、その広範な採用と成熟度は、APIを操作するのに役立つ確立された慣習とベストプラクティスがあることを意味します。

00:02:14.000 --> 00:02:25.000
OpenAPIを使用すると、サービスの動作をYAMLまたはJSONのいずれかで文書化し、これらの機械読み取り可能な形式により、豊富なツールのエコシステムの恩恵を受けることができます。

00:02:25.000 --> 00:02:32.000
テスト生成、ランタイム検証、相互運用性などのツールがあります。

00:02:32.000 --> 00:02:38.000
OpenAPIが特に知られていることの1つは、インタラクティブなドキュメントを生成するためのツールです。

00:02:38.000 --> 00:02:46.000
しかし、OpenAPIの中核的な動機は、採用者がスペック主導の開発を使用できるようにするコード生成です。

00:02:46.000 --> 00:02:48.000
APIエンドポイントの例を覚えていますか？

00:02:48.000 --> 00:02:55.000
さて、このリクエストを受け取ると、サーバーはJSONオブジェクトでパーソナライズされた挨拶を返します。

00:02:55.000 --> 00:03:02.000
コード生成を使用せずに、このAPIを呼び出すために書く必要があるコードを見てみましょう。

00:03:02.000 --> 00:03:07.000
まず、そのコンポーネントに変換するサーバーのベースURLを知る必要があります。

00:03:07.000 --> 00:03:14.000
次に、パスコンポーネントを追加してAPIエンドポイントを構築し、パラメータをクエリ項目として指定します。

00:03:14.000 --> 00:03:21.000
次に、URLRequestを構築し、URLSessionを使用してHTTPリクエストを作成します。

00:03:21.000 --> 00:03:29.000
次に、予想されるタイプの応答に、予想されるステータスコードとコンテンツタイプがあることを確認する必要があります。

00:03:29.000 --> 00:03:37.000
次に、Decodeableに準拠したSwift型を定義し、JSONDecoderを使用して、応答からバイトをデコードする必要があります。

00:03:37.000 --> 00:03:42.000
最後に、応答からメッセージプロパティを返します。

00:03:42.000 --> 00:03:47.000
このコードを書くことは問題ありませんが、これは些細なAPI操作のための単一の要求でした。

00:03:47.000 --> 00:03:54.000
多くの現実世界のAPIには、豊富なリクエストタイプとレスポンスタイプ、ヘッダーフィールド、パラメータなど、何百もの操作があります。

00:03:54.000 --> 00:04:00.000
すべての操作に対してこのコードを書くことは、反復的で、冗長で、エラーが発生しやすくなります。

00:04:00.000 --> 00:04:05.000
そして、あなたのコードベースのこの儀式のすべては、あなたのアプリのコアロジックを損ないます。

00:04:05.000 --> 00:04:12.000
OpenAPIを使用すると、ツールを使用してこのコードのほとんどを生成できるため、ユーザーがやり取りするコードに集中できます。

00:04:12.000 --> 00:04:17.000
サンプルAPIを使用して、OpenAPIドキュメントを探索します。

00:04:17.000 --> 00:04:22.000
すべてのOpenAPIドキュメントは、使用しているOpenAPI仕様のバージョンを宣言します。

00:04:22.000 --> 00:04:29.000
名前とバージョン、サーバーURLのリストなど、APIに関するメタデータを提供します。

00:04:29.000 --> 00:04:34.000
次に、APIを構成するパスとHTTPメソッドを一覧表示します。

00:04:34.000 --> 00:04:41.000
このAPIには、 greet パス上の GET メソッドの動作を定義する getGreeting という名前の操作が 1 つだけです。

00:04:41.000 --> 00:04:53.000
この例では、サーバーは常にOKのHTTPステータスコードである200で応答し、JSONスキーマを使用して定義されたJSONオブジェクトを返します。

00:04:53.000 --> 00:05:05.000
この図では、シンプルにしましたが、操作には異なるステータスコードとコンテンツタイプを持つ複数の応答を持つことができるため、エラーが発生した場合に何が起こるかを含め、すべてのシナリオを文書化できます。

00:05:05.000 --> 00:05:11.000
また、操作がパラメータを受け入れる場合、これらはOpenAPIドキュメントに含めることもできます。

00:05:11.000 --> 00:05:21.000
この操作は、挨拶をパーソナライズするために使用される文字列値である「name」と呼ばれる1つのオプションのクエリパラメータをサポートしています。

00:05:21.000 --> 00:05:28.000
Swift OpenAPI Generatorの助けを借りて、はるかに少ないコードで同じAPI呼び出しを行うことができます。

00:05:28.000 --> 00:05:38.000
型安全な入力を使用でき、出力値は豊富な列挙型であるため、コンパイラは文書化されたすべての応答とコンテンツタイプを確実に処理するのに役立ちます。

00:05:38.000 --> 00:05:44.000
また、応答本文の関連する値は、型安全なプロパティを持つ値型です。

00:05:44.000 --> 00:05:57.000
入力のエンコード、要求の作成、応答の解析、出力のデコードに関連するすべての儀式は、すべて生成されたコードによって処理されます。

00:05:57.000 --> 00:06:02.000
Swift OpenAPI Generatorは、ビルド時に実行されるSwift Packageプラグインです。

00:06:02.000 --> 00:06:09.000
これは、生成されたコードが常にOpenAPIドキュメントと同期しており、ソースリポジトリにコミットする必要がないことを意味します。

00:06:09.000 --> 00:06:16.000
Swiftパッケージプラグインの詳細については、「Meet Swiftパッケージプラグイン」という名前のセッションをチェックしてください。

00:06:16.000 --> 00:06:21.000
シンプルなiOSアプリでSwift OpenAPI Generatorを使用する方法を見てみましょう。

00:06:21.000 --> 00:06:25.000
このためには、呼び出すことができるAPIが必要になります。

00:06:25.000 --> 00:06:32.000
このデモでは、10匹の猫の顔の絵文字の1つをランダムに返すシンプルなAPIを呼び出します。

00:06:32.000 --> 00:06:41.000
テンプレートSwiftUIアプリから始めて、サンプルコンテンツを大きな絵文字と、タップするたびにサーバーから新しいものを取得するボタンに置き換えます。

00:06:41.000 --> 00:06:54.000
すでにサーバーが実行されており、localhostでリッスンしており、curlを使用してターミナルからクエリできます。

00:06:54.000 --> 00:06:56.000
これが素晴らしいAPIであることは否定できない。

00:06:56.000 --> 00:07:00.000
しかし、さらに良いのは、OpenAPIを使用して定義されていることです。

00:07:00.000 --> 00:07:08.000
非常に異なる種類の猫を使って、このサービスのOpenAPIドキュメントを表示しましょう。

00:07:08.000 --> 00:07:16.000
このAPIにはgetEmojiという名前の単一の操作があり、アプリからUIを更新するために呼び出します。

00:07:16.000 --> 00:07:20.000
はじめに、Xcodeに切り替えます。

00:07:20.000 --> 00:07:27.000
このサンプルiOSアプリには、SwiftUIを使用して定義された基本的なUIがあり、Xcodeのプレビューで見ることができます。

00:07:27.000 --> 00:07:33.000
次の数分で、UIコンポーネントを動的コンテンツに置き換え、サーバーから取得します。

00:07:33.000 --> 00:07:41.000
また、Swift OpenAPI Generatorを使用して、API呼び出しを行うために手書きしなければならないコードを簡素化します。

00:07:41.000 --> 00:07:45.000
まず、必要なパッケージの依存関係をプロジェクトに追加します。

00:07:45.000 --> 00:07:54.000
次に、コード生成にプラグインを使用するようにターゲットを設定し、OpenAPIドキュメントとプラグイン設定ファイルをターゲットソースディレクトリに追加します。

00:07:54.000 --> 00:08:02.000
プロジェクトが構成されたら、UIコンポーネントを置き換え、生成されたクライアントタイプを使用してサーバーへのAPI呼び出しを行います。

00:08:02.000 --> 00:08:13.000
Swift OpenAPI Generatorを使用するようにアプリを設定するには、プロジェクトエディタに移動し、[パッケージの依存関係]タブを選択し、クリックして新しい依存関係を追加します。

00:08:13.000 --> 00:08:20.000
このデモでは、ローカルパッケージコレクションを使用していますが、セッションノートでパッケージのURLを見つけることができます。

00:08:20.000 --> 00:08:31.000
まず、パッケージプラグインを提供するswift-openapi-generatorへの依存関係を追加します。

00:08:31.000 --> 00:08:47.000
次に、生成されたコードで使用される一般的なタイプと抽象化を提供するswift-openapi-runtimeへの依存関係を追加します。

00:08:47.000 --> 00:08:55.000
また、生成されたコードは特定のHTTPクライアントライブラリに関連付けられていないため、使用するライブラリの統合パッケージを選択する必要があります。

00:08:55.000 --> 00:09:05.000
iOSアプリを構築しているので、URLSessionパッケージを使用しますが、他の例や独自の書き方については、ドキュメントを確認してください。

00:09:05.000 --> 00:09:10.000
依存関係があれば、OpenAPI Generatorプラグインを使用するようにターゲットを設定できます。

00:09:10.000 --> 00:09:17.000
ターゲット設定で、ビルドフェーズを選択し、「ビルドツールプラグインを実行」という名前のセクションを展開します。

00:09:17.000 --> 00:09:25.000
クリックして新しいプラグインを追加し、リストからOpenAPIGeneratorを選択します。

00:09:25.000 --> 00:09:43.000
プラグインは、ターゲットのソースディレクトリに2つの入力ファイルを期待しています。OpenAPIドキュメントとプラグイン設定ファイルで、今からプロジェクトに追加します。

00:09:43.000 --> 00:09:50.000
プラグインの設定は、プラグインが生成するコードを指定する単純なYAMLスキーマを使用して書かれています。

00:09:50.000 --> 00:09:55.000
この場合、OpenAPIドキュメントから派生した再利用可能なタイプである「タイプ」を生成します。

00:09:55.000 --> 00:10:01.000
また、任意のHTTPクライアントでAPI呼び出しを行うために使用できるクライアントコードも生成します。

00:10:01.000 --> 00:10:11.000
ContentView.swiftに切り替えて、プロジェクトを再コンパイルして、生成されたコードをアプリで使用できるようになります。

00:10:11.000 --> 00:10:18.000
セキュリティ対策として、初めて使用するときにプラグインを信頼するように求められます。

00:10:18.000 --> 00:10:28.000
プロジェクトを再コンパイルしたので、UIコンポーネントを置き換え、生成されたクライアントタイプを使用してサーバーにAPI呼び出しを行い、ビューを更新することができます。

00:10:28.000 --> 00:10:34.000
まず、絵文字のビューに新しい状態プロパティを追加し、プレースホルダ値で初期化します。

00:10:34.000 --> 00:10:51.000
次に、地球画像を絵文字を含むテキストビューに置き換え、「Hello, world」メッセージをボタンに置き換え、ビューのボタンスタイルを設定します。

00:10:51.000 --> 00:10:56.000
生成されたコードは、API呼び出しを行うために使用できるクライアントという名前の型を提供します。

00:10:56.000 --> 00:11:02.000
しかし、まず、OpenAPIランタイムとトランスポートモジュールをインポートする必要があります。

00:11:02.000 --> 00:11:14.000
これで、クライアントプロパティをビューに追加し、OpenAPIドキュメントで定義されているローカルホストサーバーURLを使用するように設定する初期化子を追加できます。

00:11:14.000 --> 00:11:28.000
次に、このクライアントを使用してサーバーにAPI呼び出しを行う関数を追加します。

00:11:28.000 --> 00:11:32.000
APIリクエストを行うために手書きで書く必要があるコードは、それだけです。

00:11:32.000 --> 00:11:35.000
他のすべては、生成されたコードによって処理されます。

00:11:35.000 --> 00:11:44.000
応答は、文書化されたすべての応答とコンテンツタイプをモデル化するタイプの列挙値であり、すべてのシナリオを処理することを奨励します。

00:11:44.000 --> 00:11:50.000
そのため、スイッチステートメントを使用して、応答本文から絵文字を抽出する必要があります。

00:11:50.000 --> 00:11:51.000
ここに何かが欠けています。

00:11:51.000 --> 00:11:55.000
コンパイラは、すべてのシナリオを処理していないと教えてくれました。

00:11:55.000 --> 00:12:01.000
不足しているスイッチケースをXcodeに記入させます。

00:12:01.000 --> 00:12:09.000
サーバーがOpenAPIドキュメントで指定されていないもので応答しても、それを優雅に処理する機会があります。

00:12:09.000 --> 00:12:20.000
このデモでは、コンソールに警告を印刷し、絵文字を猫以外のものに更新します。

00:12:20.000 --> 00:12:26.000
これで、ボタンがタップされたときにこの関数を呼び出すことができます。

00:12:26.000 --> 00:12:33.000
また、ボタンを使用して新しい猫の絵文字を取得し、UIを更新することができます。

00:12:33.000 --> 00:12:37.000
サーバーに新機能が追加されると、そのAPIは進化します。

00:12:37.000 --> 00:12:45.000
また、サーバーがOpenAPIを使用して文書化されている場合、Swift OpenAPI Generatorを使用すると、アプリからこれらの新機能を簡単に使用できます。

00:12:45.000 --> 00:12:52.000
OpenAPIドキュメントが進化するにつれて、アプリを更新する方法の例を見てみましょう。

00:12:52.000 --> 00:13:02.000
絵文字に関しては、より多くのことなので、複数の絵文字を取得するために使用できる新しいオプションのクエリパラメータ、カウントを取るためにサービスAPIを拡張しました。

00:13:02.000 --> 00:13:10.000
1匹ではなく3匹の猫を取得する別のボタンでアプリを拡張します。

00:13:10.000 --> 00:13:14.000
まず、OpenAPIドキュメントにパラメータを追加します。

00:13:14.000 --> 00:13:19.000
そして、プロジェクトを再コンパイルすると、パラメータはアプリで使用できるようになります。

00:13:19.000 --> 00:13:24.000
次に、このパラメータを使用してAPI呼び出しを行う新しいボタンを作成します。

00:13:24.000 --> 00:13:32.000
OpenAPIドキュメントに新しいパラメータを追加することから始めます。

00:13:32.000 --> 00:13:35.000
このパラメータは「count」という名前です。

00:13:35.000 --> 00:13:36.000
これはオプションのパラメータです。

00:13:36.000 --> 00:13:41.000
URLクエリの一部として提供され、整数値です。

00:13:41.000 --> 00:13:50.000
ContentView.swiftに戻り、updateEmoji関数を拡張してパラメータも取りましょう。

00:13:50.000 --> 00:14:01.000
そして、API呼び出しを行うときにこのパラメータを使用しましょう。

00:14:01.000 --> 00:14:09.000
ボタンを複製し、ラベルを「More cats」に変更します。

00:14:09.000 --> 00:14:18.000
このボタンをタップすると、同じ関数を呼び出しますが、今回は3を数えます。

00:14:18.000 --> 00:14:25.000
プレビューでは、「Get cat」をタップして1匹の猫を、または「More cats」をタップして3匹を獲得できます。

00:14:25.000 --> 00:14:33.000
この間ずっと、私たちは実際のサーバーにリクエストをしてきましたが、特に開発中は、必ずしも実用的で望ましいとは限りません。

00:14:33.000 --> 00:14:41.000
生成されたクライアントタイプはSwiftプロトコルに準拠しているため、ネットワーク接続やトランスポートライブラリを必要としないモックを書くのは簡単です。

00:14:41.000 --> 00:14:49.000
生成されたプロトコルはAPIProtocolという名前なので、このプロトコルを採用する新しいMockClientタイプを定義することから始めます。

00:14:49.000 --> 00:14:58.000
次に、APIProtocolに準拠した任意のタイプに対してビューをジェネリックに更新し、依存性注入をサポートするように初期化子を更新します。

00:14:58.000 --> 00:15:02.000
次に、XcodeでUIをプレビューするときにMockClientを使用します。

00:15:02.000 --> 00:15:07.000
MockClientタイプを宣言することから始めます。

00:15:07.000 --> 00:15:14.000
このタイプはAPIProtocolを採用すると宣言したため、コンパイラはプロトコル要件を満たしていることを確認します。

00:15:14.000 --> 00:15:20.000
XcodeにAPI操作の不足しているハンドラーを追加させます。

00:15:20.000 --> 00:15:28.000
そして、ロボットの絵文字を返すビジネスロジックを追加して、実際のサービスと区別します。

00:15:28.000 --> 00:15:39.000
これで、このプロトコルに準拠したタイプに対してビューをジェネリックにし、ジェネリックタイプパラメータを使用するようにクライアントプロパティを更新することができます。

00:15:39.000 --> 00:15:53.000
クライアントをパラメータとして取る初期化子を追加し、既存の初期化子を一般的なwhere句で更新しますので、クライアントが提供されない場合は、以前と同じものを使用します。

00:15:53.000 --> 00:16:02.000
アプリが起動されると、実際のサーバーを使用し続けますが、XcodeでUIをプレビューするときにMockClientを注入できるようになりました。

00:16:02.000 --> 00:16:13.000
これで、UIプレビューでボタンをタップすると、猫の代わりにロボットを取得し、ネットワーク接続や実行中のサーバーを必要としません。

00:16:13.000 --> 00:16:20.000
モッククライアントを追加するまで、私たちのiOSアプリは私のローカルマシンで実行されている実際のサーバーにリクエストをしていました。

00:16:20.000 --> 00:16:25.000
このサーバーはまた、Swift OpenAPI Generatorの助けを借りてSwiftで書かれました。

00:16:25.000 --> 00:16:33.000
サーバーは、コード生成にSwift OpenAPI Generatorパッケージプラグインを使用するシンプルなSwiftパッケージです。

00:16:33.000 --> 00:16:43.000
生成されたサーバーコードを使用するには、APIProtocolという名前の生成されたプロトコルに準拠したタイプを定義し、API操作のビジネスロジックのみを実装しました。

00:16:43.000 --> 00:16:54.000
また、サーバーを設定するために、生成された関数registerHandlersを使用して、API操作の着信HTTPリクエストをビジネスロジックを提供するハンドラーに接続しました。

00:16:54.000 --> 00:16:58.000
見てみましょう。 

00:16:58.000 --> 00:17:04.000
コンソールを拡張すると、デモiOSアプリからの実際のリクエストを確認できます。

00:17:04.000 --> 00:17:09.000
そして、これは私たちがサーバーを実装するために手で書く必要があったすべてのSwiftコードです。

00:17:09.000 --> 00:17:22.000
OpenAPIを使用してこのサービスを文書化する代わりに、OpenAPIドキュメントから開始し、Swift OpenAPI Generatorを使用して、API仕様を実装するサーバーの作成を簡素化しました。

00:17:22.000 --> 00:17:30.000
生成されたAPIProtocolに準拠し、API運用にビジネスロジックのみを提供するタイプを定義しました。

00:17:30.000 --> 00:17:36.000
そして、生成された関数を使用して、そのメソッドをAPIエンドポイントのHTTPサーバーに登録しました。

00:17:36.000 --> 00:17:40.000
このデモでは、Swift用のオープンソースのWebフレームワークであるVaporを使用しています。

00:17:40.000 --> 00:17:47.000
しかし、生成されたコードは、Swift OpenAPI Generatorの統合パッケージを提供する任意のWebフレームワークで使用できます。

00:17:47.000 --> 00:17:53.000
他のオプションや自分で書く方法については、ドキュメントを確認してください。

00:17:53.000 --> 00:18:00.000
主な機能では、OpenAPIトランスポートを作成するために使用する新しいVaporアプリケーションを作成します。

00:18:00.000 --> 00:18:12.000
次に、ハンドラータイプのインスタンスを作成し、生成されたregisterHandlers関数を使用して、各API操作のHTTPサーバー内のルーティングを設定します。それ以外の場合は、手動で行う必要があります。

00:18:12.000 --> 00:18:18.000
最後に、手動で設定したのと同じ方法で、Vaporアプリを実行します。

00:18:18.000 --> 00:18:30.000
Swiftはサーバー開発に最適な言語であり、Swiftでバックエンドサービスを書くことについてもっと知りたい場合は、「サーバーサイド開発にXcodeを使用する」という名前のセッションをチェックしてください。

00:18:30.000 --> 00:18:35.000
Swift OpenAPI Generatorを使用するようにパッケージがどのように構成されているかを見てみましょう。

00:18:35.000 --> 00:18:41.000
サーバーはSwiftパッケージとして実装され、Package.swiftファイルを使用して定義されます。

00:18:41.000 --> 00:18:48.000
このパッケージには、Swift OpenAPI Generatorプラグインを使用するCatServiceと呼ばれる単一の実行可能ターゲットがあります。

00:18:48.000 --> 00:19:04.000
生成されたサーバーコードは、ランタイムライブラリからの共通のタイプと抽象化に依存し、統合パッケージを提供する任意のWebフレームワークで使用できるため、このターゲットはswift-openapi-runtime、swift-openapi-vapor、およびvapor itselfに依存しています。

00:19:04.000 --> 00:19:13.000
ターゲットソースディレクトリに、デモiOSアプリで使用したのと同じOpenAPIドキュメントとプラグイン設定ファイルを追加しました。

00:19:13.000 --> 00:19:17.000
このターゲットでは、タイプとサーバースタブを生成しています。

00:19:17.000 --> 00:19:24.000
スペック主導の開発により、このサービスに新機能を追加する方法を簡単にする方法を見てみましょう。

00:19:24.000 --> 00:19:35.000
猫の絵文字は素晴らしいですが、多くの証拠が、インターネットが主に猫のビデオの交換のために構築されたことを示唆しているので、その機能をサーバーに追加します。

00:19:35.000 --> 00:19:40.000
スペック主導の開発では、新しいAPI操作を追加するには2つのステップしか必要ありません。

00:19:40.000 --> 00:19:44.000
まず、OpenAPIドキュメントに新しい操作を追加します。

00:19:44.000 --> 00:19:53.000
次に、生成されたプロトコルに新しい関数要件があるため、コンパイラはハンドラでメソッドを定義し、ビジネスロジックを実装することを主張します。

00:19:53.000 --> 00:20:06.000
始める前に、ターゲットのリソースフォルダに追加した猫のビデオが必要です。

00:20:06.000 --> 00:20:12.000
OpenAPIドキュメントに向かい、新しい操作を追加します。

00:20:12.000 --> 00:20:22.000
この操作はgetClipと呼ばれ、応答本文にビデオデータが含まれていることを示すコンテンツタイプのバイナリ応答があります。

00:20:22.000 --> 00:20:27.000
パッケージを再コンパイルしようとすると、失敗します。

00:20:27.000 --> 00:20:34.000
これは、ハンドラが生成されたプロトコルに準拠しなくなったためです。なぜなら、新しい操作のための機能を提供していないからです。

00:20:34.000 --> 00:20:44.000
Xcodeにプロトコルスタブを記入させ、ビデオリソースファイルからバイトを読み取り、バイナリボディでOK応答を返すビジネスロジックを提供します。

00:20:44.000 --> 00:20:55.000
タイプセーフ生成コードは、この操作のOpenAPIドキュメントで指定されているため、この関数からバイナリ応答本文のみを返すことができることに注意してください。

00:20:55.000 --> 00:21:00.000
パッケージを再コンパイルすると、成功し、サーバーを再起動できます。

00:21:00.000 --> 00:21:13.000
また、Safariに切り替えると、新しいAPIエンドポイントをテストできます。

00:21:13.000 --> 00:21:20.000
そのため、OpenAPIを使用してサービスを文書化することで、あいまいさを排除し、仕様主導の開発を可能にする方法を見てきました。

00:21:20.000 --> 00:21:27.000
Swift OpenAPI GeneratorがiOSアプリのサーバーAPIの操作を簡素化する方法を示しました。

00:21:27.000 --> 00:21:35.000
最後に、Swiftの言語機能と成長するSwift-on-serverエコシステムがどのようにバックエンドサービスを実装するための素晴らしい選択であるかを見てきました。

00:21:35.000 --> 00:21:44.000
だからこそ、Swift OpenAPI Generatorはオープンソースであり、GitHubで利用でき、成長を続けるにつれてプロジェクトにもっと学び、貢献することさえできます。

00:21:44.000 --> 00:21:45.000
このセッションを見てくれてありがとう。

00:21:45.000 --> 23:59:59.000
ニャー、それだけ！

