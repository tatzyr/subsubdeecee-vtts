WEBVTT

00:00:00.000 -> 00:00:10.000
♪ ♪

00:00:10.000 -> 00:00:14.000
アレックス：こんにちは。私の名前はアレックスです。私はビデオエンジニアリングチームの出身です。

00:00:14.000 -> 00:00:21.000
今日、同僚のアントワーヌと私は、RoomPlanの新機能を共有します。

00:00:21.000 -> 00:00:34.000
RoomPlanは、ARKitを搭載した洗練された機械学習アルゴリズムを使用して、壁、窓、ドア、開口部、その他の部屋を定義するオブジェクトを検出します。

00:00:34.000 -> 00:00:42.000
RoomCaptureView APIを使用すると、スキャン体験をアプリに直接統合できます。

00:00:42.000 -> 00:00:50.000
スキャンが完了すると、アプリは結果の3Dモデルを表示し、USDZファイルにエクスポートできます。

00:00:50.000 -> 00:00:54.000
このセッションでは、RoomPlanの新機能について説明します。

00:00:54.000 -> 00:01:02.000
カスタムARSessionを使用して、RoomPlanとARKitを組み合わせる新しい方法から始めます。

00:01:02.000 -> 00:01:07.000
その後、マルチルームサポートに注意を向けます。

00:01:07.000 -> 00:01:14.000
個々のルームスキャンを1つの大きな構造にマージする新しいマルチルームAPIを提供します。

00:01:14.000 -> 00:01:20.000
次に、RoomCaptureViewの新しいVoiceOverサポートを紹介します。

00:01:20.000 -> 00:01:32.000
最後に、RoomPlanの表現のいくつかの改善と、新しいワークフローを可能にするためのエクスポート機能の強化について確認します。

00:01:32.000 -> 00:01:36.000
カスタムARSessionサポートから始めましょう。

00:01:36.000 -> 00:01:48.000
前述のように、RoomPlanはスキャン中に壁、窓、ドア、開口部、その他のオブジェクトを検出するためにARKitからの情報に依存しています。

00:01:48.000 -> 00:01:53.000
このため、RoomCaptureSessionはデフォルトのARSessionで実行されています。

00:01:53.000 -> 00:02:02.000
iOS 17の新機能であるRoomPlanでは、ARWorldTrackingConfigurationでカスタムARSessionを使用できます。

00:02:02.000 -> 00:02:10.000
これにより、同じワークフロー内でRoomPlanとARKitの使用を組み合わせるいくつかの新しい方法が可能になります。

00:02:10.000 -> 00:02:12.000
いくつかの例を見てみましょう。 ではいくつかの例を見てみましょう。

00:02:12.000 -> 00:02:28.000
カスタムARSessionでRoomPlanを使用する1つの方法は、RoomPlanの結果とARKitシーンジオメトリと平面検出を組み合わせて、仮想コンテンツと現実世界のジオメトリの間のより没入感のある相互作用を実現することです。

00:02:28.000 -> 00:02:40.000
さらに、ARKitから高品質の画像キャプチャを使用して、RoomPlanでより豊かな不動産リストを作成することで、スペースの写真表現を収集できます。

00:02:40.000 -> 00:02:51.000
また、既存のAR体験の一部としてRoomPlanを使用している場合は、既存のARAnchorsを中断することなく、RoomPlanの結果を組み合わせることができます。

00:02:51.000 -> 00:02:56.000
これらは、カスタムARSessionが提供できるいくつかのユースケースにすぎません。

00:02:56.000 -> 00:03:02.000
カスタムARSessionをRoomPlanに渡す方法を確認するために、いくつかのコードを見てみましょう。

00:03:02.000 -> 00:03:07.000
これは、以前のRoomPlanのinitとstop機能です。

00:03:07.000 -> 00:03:12.000
そして、カスタムARSessionをinit関数に渡す方法は次のとおりです。

00:03:12.000 -> 00:03:20.000
ARWorldTrackingConfigurationを使用したカスタムARSessionは、RoomCaptureSession内で尊重されます。

00:03:20.000 -> 00:03:29.000
また、停止機能には、基礎となるARSessionを一時停止するかどうかを判断するための新しいオプションが含まれています。

00:03:29.000 -> 00:03:37.000
RoomCaptureSessionが停止した後もARSessionを実行し続ける場合は、Booleanをfalseに設定できます。

00:03:37.000 -> 00:03:53.000
次のセクションでは、複数のスキャンを1つの大きな構造にマージするなど、ARSessionでの作業がどのように新しいワークフローを可能にするかを見ていきます。マルチルームサポートに注意を向けましょう。

00:03:53.000 -> 00:03:55.000
マルチルームサポートとは何ですか?

00:03:55.000 -> 00:04:02.000
以前のRoomPlanでは、1回のスキャンを行い、シングルルームの3Dモデルを取得できました。

00:04:02.000 -> 00:04:13.000
ダイニングルーム、キッチン、リビングルーム、廊下、寝室など、家のさまざまな部屋のスキャンを数回行ったとします。

00:04:13.000 -> 00:04:17.000
それらをマージしたい場合は、いくつかの課題に直面するでしょう。

00:04:17.000 -> 00:04:26.000
まず、それらはすべて独自の座標系にあります。つまり、世界座標の原点と向きは部屋ごとに異なります。

00:04:26.000 -> 00:04:37.000
第二に、手動でステッチしても、壁が重複し、オブジェクトが重複する可能性があります。

00:04:37.000 -> 00:04:41.000
まず、異なる座標系に取り組みましょう。

00:04:41.000 -> 00:04:47.000
ここで達成したいのは、すべてのスキャンを同じ座標系で撮影することです。

00:04:47.000 -> 00:04:52.000
ここでは、複数の部屋をスキャンするための2つのアプローチが提案されています。

00:04:52.000 -> 00:04:55.000
まず、継続的なARSessionを使用してください。

00:04:55.000 -> 00:04:59.000
第二に、ARSessionの再ローカリゼーションを使用します。

00:04:59.000 -> 00:05:02.000
連続ARSessionの使い方を見てみましょう。

00:05:02.000 -> 00:05:08.000
以前のRoomPlanでは、RoomCaptureSessionが停止すると、ARSessionは一時停止されます。

00:05:08.000 -> 00:05:12.000
各スキャンには異なる座標系があります。

00:05:12.000 -> 00:05:20.000
新しいAPIには、stop関数に新しい引数があり、pauseARSessionをfalseに設定できます。

00:05:20.000 -> 00:05:32.000
これにより、ARSessionは、最終的に再びARSessionを一時停止することを決定するまで、その後のスキャンであっても、次のスキャンのために実行し続けることができます。

00:05:32.000 -> 00:05:39.000
このアプローチを使用すると、同じARSessionが複数のスキャンで実行されるようにすることができます。

00:05:39.000 -> 00:05:45.000
これにより、すべてのスキャンに1つの共通の世界座標系を持つことができます。

00:05:45.000 -> 00:05:49.000
これがコードでどのように機能するかを見てみましょう。

00:05:49.000 -> 00:05:55.000
連続ARSessionでRoomCaptureSessionを実行する例を次に示します。

00:05:55.000 -> 00:05:59.000
RoomCaptureSession.runで最初のスキャンを開始します。

00:05:59.000 -> 00:06:01.000
次に、ここに重要な部分があります。

00:06:01.000 -> 00:06:09.000
RoomCaptureSession.stopの新しいAPIでは、pauseARSessionをfalseに設定する必要があります。

00:06:09.000 -> 00:06:13.000
これにより、次のスキャンのためにARSessionを実行し続けます。

00:06:13.000 -> 00:06:19.000
その後、2回目のスキャンに同じroomCaptureSessionインスタンスを使用します。

00:06:19.000 -> 00:06:22.000
次に、2回目のスキャンを停止します。

00:06:22.000 -> 00:06:29.000
最後に、同じ座標系で1番目と2番目のスキャン結果を得ることができました。

00:06:29.000 -> 00:06:38.000
同じ座標空間内で個々の部屋スキャンを行うもう1つのアプローチは、ARSessionの再ローカリゼーションを使用することです。

00:06:38.000 -> 00:06:49.000
このアプローチは、翌日または週に同じ場所に戻ってくるなど、異なる時間に個々の部屋のスキャンを行う場合に最適です。

00:06:49.000 -> 00:06:52.000
これがどのように機能するかを見てみましょう。

00:06:52.000 -> 00:06:57.000
繰り返しになりますが、これはシングルルームの3Dモデルを取得するためのシングルスキャンです。

00:06:57.000 -> 00:07:07.000
RoomCaptureSessionを停止し、ARSessionを一時停止するため、将来のスキャンのために再ローカリゼーションが機能するために、ARWorldMapをディスクに保存する必要があります。

00:07:07.000 -> 00:07:18.000
ARSessionが一時停止したときに前のスキャンを続行したい場合は、一時停止したARSessionからARWorldMapをロードしてスキャンを再開できます。

00:07:18.000 -> 00:07:30.000
このARWorldMapを使用すると、以前のスキャンの環境に対して再ローカライズして、一連のスキャンがすべて共通の座標系を共有することを確認できます。

00:07:30.000 -> 00:07:36.000
再ローカリゼーションによるスキャンワークフローのサンプルコードを見てみましょう。

00:07:36.000 -> 00:07:40.000
まず、最初のスキャンを実行します。

00:07:40.000 -> 00:07:44.000
次に、ARSessionを一時停止して最初のスキャンを停止します。

00:07:44.000 -> 00:07:52.000
その後、再ローカリゼーションが機能するには、ARSessionが一時停止されたときにARWorldMapを保存する必要があります。

00:07:52.000 -> 00:07:57.000
2回目のスキャンを実行する前に、以前のARWorldMapを復元する必要があります。

00:07:57.000 -> 00:08:01.000
まず、ARWorldMapをロードします。

00:08:01.000 -> 00:08:07.000
そして、ロードされたARWorldMapをARWorldTrackingConfigurationに割り当てます。initialWorldMap。

00:08:07.000 -> 00:08:12.000
次に、ARSessionを実行して再ローカリゼーションをトリガーします。

00:08:12.000 -> 00:08:17.000
再ローカリゼーションが完了すると、以前のARSessionが読み込まれます。

00:08:17.000 -> 00:08:22.000
現在の世界座標は、以前の世界座標と一致しています。

00:08:22.000 -> 00:08:24.000
その後、2回目のスキャンを実行できます。

00:08:24.000 -> 00:08:27.000
最後に、2回目のスキャンを停止します。

00:08:27.000 -> 00:08:35.000
これらすべてのステップで、1回目と2回目のスキャン結果は同じ3D世界座標になります。

00:08:35.000 -> 00:08:42.000
同じ3D座標系で複数のスキャンをリンクする2つのアプローチを見てきました。

00:08:42.000 -> 00:08:51.000
次に、新しいMultiRoom APIを使用して、それらを1つの結合構造にマージする方法を見ていきます。

00:08:51.000 -> 00:08:57.000
スキャンごとに、RoomBuilder APIを実行して、個々のCapturedRoomを生成できます。

00:08:57.000 -> 00:09:09.000
前に示したように、継続的なARSessionとARSessionの再ローカリゼーションにより、すべてのCapturedRoomは同じ3D世界空間にあります。

00:09:09.000 -> 00:09:14.000
これは、3つのCapturedRoomsを備えたRoomBuilderからの出力です。

00:09:14.000 -> 00:09:24.000
次に、新しいマージAPIであるStructureBuilderを提供し、それらをすべて1つの大きな構造であるCapturedStructureにマージします。

00:09:24.000 -> 00:09:30.000
次に、StructureBuilder APIのサンプルコードを見てみましょう。

00:09:30.000 -> 00:09:35.000
StructureBuilder APIを使用して複数のスキャンをマージする方法は次のとおりです。

00:09:35.000 -> 00:09:40.000
まず、設定オプションでStructureBuilderインスタンスを作成します。

00:09:40.000 -> 00:09:46.000
次に、以前にスキャンした複数のCapturedRoomsをロードする配列を作成します。

00:09:46.000 -> 00:09:54.000
その後、StructureBuilder APIを呼び出すと、マージされた結果である capturedStructureを取得します。

00:09:54.000 -> 00:09:59.000
最後に、キャプチャされたStructureをUSDZファイルにエクスポートできます。

00:09:59.000 -> 00:10:02.000
そして、これがCapturedStructureの定義です。

00:10:02.000 -> 00:10:06.000
まず、それは部屋のプロパティを持っています。

00:10:06.000 -> 00:10:09.000
これはCapturedRoomインスタンスの配列です。

00:10:09.000 -> 00:10:18.000
次に、マージされた壁、ドア、窓、開口部、およびオブジェクトのプロパティがあります。

00:10:18.000 -> 00:10:24.000
最後に、USDZファイルにエクスポートする機能があります。

00:10:24.000 -> 00:10:27.000
マルチルームの動作を見てみましょう。

00:10:27.000 -> 00:10:37.000
複数のスキャンをStructureBuilder APIとマージし、USDZファイルにエクスポートできるsample.appを提供しています。

00:10:37.000 -> 00:10:43.000
私たちのUSDZファイルは、iOSとmacOSの両方でプレビューする準備ができています。

00:10:43.000 -> 00:10:54.000
USDZファイルをBlenderなどのデジタルコンテンツ作成ツールに読み込むことで、これをさらに一歩進めることができます。

00:10:54.000 -> 00:11:03.000
3Dモデルにいくつかの美化を適用した後、結果はさらに良く見えます。

00:11:03.000 -> 00:11:11.000
最後に、マルチルームサポートで最高のマルチルーム体験を得るためのいくつかの考慮事項について話しましょう。

00:11:11.000 -> 00:11:23.000
マルチルームは、1〜4つのベッドルーム、リビングルーム、キッチン、ダイニングルームの典型的なセットアップで、1階建ての住宅に最適です。

00:11:23.000 -> 00:11:34.000
個々の部屋をスキャンしてマージするには、2,000平方フィートまたは約186平方メートルの最大総面積をお勧めします。

00:11:34.000 -> 00:11:47.000
さらに、RoomPlanがクリアなビデオストリームと優れたARトラッキングパフォーマンスでスキャンできるように、50ルクス以上の良好な照明が推奨されます。

00:11:47.000 -> 00:11:55.000
さて、アントワーヌがiOS 17のRoomPlanのさらなる機能強化について教えてくれます。

00:11:55.000 -> 00:11:56.000
アントワーヌ:ありがとう、アレックス。

00:11:56.000 -> 00:12:00.000
ここからピックアップして、アクセシビリティについて話しましょう。

00:12:00.000 -> 00:12:09.000
レンダリングについて話すとき、私たちのほとんどは視覚的なモダリティについて考えますが、弱視の人にとっては、このモダリティは最も有用なものではありません。

00:12:09.000 -> 00:12:18.000
今年、RoomPlanはVoiceOverが有効になっているときにオーディオフィードバックを追加し、携帯電話がスキャンに関するガイドラインを提供し、見たものを説明できるようにしました。

00:12:18.000 -> 00:12:20.000
VoiceOver: デバイスを移動して起動します。

00:12:20.000 -> 00:12:22.000
壁の下端にあるポイントカメラ。

00:12:22.000 -> 00:12:25.000
暖炉。壁。

00:12:25.000 -> 00:12:27.000
窓。

00:12:27.000 -> 00:12:32.000
アントワーヌ：それでは、RoomPlanが部屋から収集できる新しい情報と、それがどのようにレンダリングされるかについて話しましょう。

00:12:32.000 -> 00:12:36.000
RoomPlanを使用すると、幅広い部屋を簡単にスキャンできます。

00:12:36.000 -> 00:12:43.000
しかし、これまでのところ、それは部屋の状況の有限セットを正確に表すことに限定されていました。

00:12:43.000 -> 00:12:55.000
RoomPlanは現在、傾斜した壁や湾曲した壁だけでなく、食器洗い機、オーブン、シンクなどのくぼんだキッチン要素を含む、さらに多種多様な部屋をサポートしています。

00:12:55.000 -> 00:13:01.000
RoomPlanは、特定のカテゴリのオブジェクトの構成を検出するためにも改善されました。

00:13:01.000 -> 00:13:11.000
たとえば、シングルシートからL字型、そしてRoomPlanが新しいバージョンで検出するシンプルな四角いソファまで、多くのタイプのソファがあります。

00:13:11.000 -> 00:13:20.000
RoomPlanを紹介したとき、RoomPlanがスキャンできる2つの要素、サーフェスとオブジェクトについて話しました。

00:13:20.000 -> 00:13:24.000
今、私たちは部屋の中の領域を記述するための新しい要素を追加しています。

00:13:24.000 -> 00:13:27.000
私たちはそれらをセクションと呼んでいます。

00:13:27.000 -> 00:13:35.000
壁は、傾斜した壁や梁のある壁などの不均一な壁を扱うために、ポリゴンとして記述できるようになりました。

00:13:35.000 -> 00:13:40.000
これまでのところ、湾曲した壁と窓はデータのみのAPIの一部でした。

00:13:40.000 -> 00:13:46.000
これで、RoomCaptureViewの最終結果は、湾曲した壁をレンダリングすることもできます。

00:13:46.000 -> 00:13:54.000
表面カテゴリに加えて、フロアカテゴリはポリゴンとしても記述できる別の追加です。

00:13:54.000 -> 00:14:01.000
オブジェクトには、カテゴリ内のさまざまな構成をよりよく記述するための属性を持つようになりました。

00:14:01.000 -> 00:14:05.000
サーフェスとオブジェクトに新しい親変数が追加されました。

00:14:05.000 -> 00:14:08.000
親の識別子が含まれています。

00:14:08.000 -> 00:14:17.000
たとえば、窓の親は壁、椅子の親はテーブル、食器洗い機の親は収納になります。

00:14:17.000 -> 00:14:21.000
これらのすべての改善を例で詳しく説明しましょう。

00:14:21.000 -> 00:14:26.000
各セクションでは、あなたの部屋や家のさまざまなエリアについて説明しています。

00:14:26.000 -> 00:14:35.000
セクションには、リビングルーム、ベッドルーム、バスルーム、キッチン、ダイニングルームなどのラベルがあります。

00:14:35.000 -> 00:14:41.000
それは、特定のフロアで、特定の位置を持っています。

00:14:41.000 -> 00:14:48.000
不均一な壁は、polygonCorner変数を使用してポリゴンとしてレンダリングできます。

00:14:48.000 -> 00:14:56.000
床はスキャン中に長方形として表現され、スキャン終了時に多角形として美化されるようになりました。

00:14:56.000 -> 00:15:01.000
食器洗い機、オーブン、シンクの親は現在、レンダリングに刻まれています。

00:15:01.000 -> 00:15:06.000
RoomPlanを導入したとき、オブジェクトを記述するためにカテゴリが使用されました。

00:15:06.000 -> 00:15:10.000
しかし、この表現には限界がありました。

00:15:10.000 -> 00:15:12.000
椅子の例を見てみましょう。 

00:15:12.000 -> 00:15:21.000
いくつかの種類の椅子は、スツール、ダイニングチェア、オフィスチェアなど、このカテゴリを表すことができます。

00:15:21.000 -> 00:15:23.000
それらはすべて異なる目的を持っています。

00:15:23.000 -> 00:15:29.000
オブジェクトをよりよく表現するために、属性を追加しています。

00:15:29.000 -> 00:15:35.000
この例では、属性を使用して、スキャンされたものをより忠実に理解しています。

00:15:35.000 -> 00:15:41.000
RoomPlan APIでは、属性は列挙型のポリモーフィック配列を介して利用できます。

00:15:41.000 -> 00:15:46.000
しかし、列挙型は属性を理解するための最良の方法ではありません。

00:15:46.000 -> 00:15:51.000
次のセクションでは、より魅力的な表現に到達するための新しい方法を探ります。

00:15:51.000 -> 00:15:59.000
属性は、スキャン中にキャプチャされた他の新しい情報とともに、エクスポートされた結果に含めることができます。

00:15:59.000 -> 00:16:11.000
エクスポートできるデータの種類には、USDZノードからメタデータを取り戻すためのファイルと、エクスポートされたUSDZをモデルで充実させる構造という2つの追加があります。

00:16:11.000 -> 00:16:19.000
ルームをメッシュとしてエクスポートする場合、サーフェスとオブジェクトのノードツリーを含むUSDZを作成します。

00:16:19.000 -> 00:16:24.000
今年は、セクションセンターを含むセクショングループを追加しました。

00:16:24.000 -> 00:16:35.000
しかし、そうすると、壁やオブジェクトの寸法だけでなく、オブジェクト属性など、スキャンからかなりの量の情報が欠落しています。

00:16:35.000 -> 00:16:39.000
ルームをエクスポートするときにマッピングファイルを作成できるようになりました。

00:16:39.000 -> 00:16:51.000
これは、USDZの一意のノード名とその識別子によって一意に識別されるCapturedRoom要素の間のブリッジを作成する、文字列からUUIDへのエンコードされた辞書です。

00:16:51.000 -> 00:16:55.000
RoomPlan APIでどのように展開するか見てみましょう。

00:16:55.000 -> 00:17:08.000
以前のバージョンのRoomPlanでは、ルームは2つの方法でエクスポートできます。USDZとして、エクスポート機能を介して、およびJSONまたはPlistとして、CapturedRoom構造をエンコードします。

00:17:08.000 -> 00:17:19.000
iOS 17の新機能で、エクスポート機能で部屋をUSDZにマップするメタデータURLを指定すると、エクスポートされた2つの情報を関連付けることができます。

00:17:19.000 -> 00:17:26.000
このようにして、スキャンした部屋をレンダリングするときに、サーフェスまたはオブジェクトに関する追加情報を照会できます。

00:17:26.000 -> 00:17:40.000
新しいマッピングファイルとともに、以前はボックスとして表現されていたオブジェクトを、スキャンされた属性に一致するモデルに置き換えるために、モデルプロバイダーを導入しています。

00:17:40.000 -> 00:17:48.000
ここでやりたいことは、オブジェクトを3Dモデル、より具体的にはそのURLに関連付けることです。

00:17:48.000 -> 00:17:57.000
このようにして、オブジェクトを表すために使用されるバウンディングボックスを、より説得力のある真実のレンダリングに置き換えることができます。

00:17:57.000 -> 00:18:03.000
その目的のために、新しい構造がRoomPlan: ModelProviderで利用可能です。

00:18:03.000 -> 00:18:08.000
ModelProviderは、カテゴリと属性のセットをモデルURLにマップします。

00:18:08.000 -> 00:18:16.000
カテゴリと属性を持つオブジェクトから、対応するモデルURLを提供するようにModelProviderに依頼することができます。

00:18:16.000 -> 00:18:32.000
カテゴリと属性を持つセクション、サーフェス、オブジェクトのコレクションである部屋全体に一般化すると、エクスポート機能で指定されたModelProviderインスタンスは、3DモデルURLを部屋の各オブジェクトに関連付けることができます。

00:18:32.000 -> 00:18:40.000
モデルの関連付けを処理する構造ができたら、モデルプロバイダーとどのように連携できるかを見てみましょう。

00:18:40.000 -> 00:18:43.000
ModelProviderに入力する方法はたくさんあります。

00:18:43.000 -> 00:18:50.000
たとえば、データベースから一連の属性に一致するモデルを取得したり、既存のカタログに注釈を付けたりできます。

00:18:50.000 -> 00:18:56.000
ここでは、独自の小さな資産カタログを作成するための非常に簡単な例を紹介します。

00:18:56.000 -> 00:18:59.000
4つのステップでカタログを作成して使用します。

00:18:59.000 -> 00:19:04.000
まず、RoomPlanがサポートするカテゴリと属性を解析します。

00:19:04.000 -> 00:19:08.000
次に、各カテゴリと属性セットのモデルを関連付けます。

00:19:08.000 -> 00:19:12.000
その後、ModelProviderをインスタンス化します。

00:19:12.000 -> 00:19:17.000
そして最後に、それを使って部屋をエクスポートします。

00:19:17.000 -> 00:19:22.000
属性を発見し、いくつかのモデルを使用してモデルプロバイダーを作成する方法を見てみましょう。

00:19:22.000 -> 00:19:26.000
まず、RoomPlanがサポートするすべてのカテゴリを反復します。

00:19:26.000 -> 00:19:30.000
次に、サポートされている各カテゴリのフォルダを作成します。

00:19:30.000 -> 00:19:33.000
後で各フォルダにモデルを追加できます。

00:19:33.000 -> 00:19:40.000
次に、カテゴリごとに、RoomPlanでサポートされている属性の組み合わせを要求します。

00:19:40.000 -> 00:19:44.000
サポートされている属性のセットごとに、フォルダを作成します。

00:19:44.000 -> 00:19:51.000
これらの各フォルダに、カテゴリまたは属性のセットに対応する3Dモデルを追加できます。

00:19:51.000 -> 00:19:57.000
カタログの内容の準備が整ったので、インデックスファイルを作成する必要があります。

00:19:57.000 -> 00:20:01.000
以下は、カタログインデックスを処理する構造の例です。

00:20:01.000 -> 00:20:07.000
要素の配列が含まれており、それぞれにカテゴリまたは属性のセットが含まれています。

00:20:07.000 -> 00:20:11.000
各要素には、対応するモデルのパスへの参照があります。

00:20:11.000 -> 00:20:18.000
これで、インデックスファイルをplistとして、カタログをバンドルとして保存できます。

00:20:18.000 -> 00:20:29.000
モデルで部屋をエクスポートするたびに、またはモデルプロバイダーを使用してオブジェクトをモデルに関連付けるたびに、このカタログバンドルを使用してModelProviderを生成できるようになりました。

00:20:29.000 -> 00:20:45.000
私たちがしなければならないのは、カタログのカテゴリと属性を反復したり、対応するモデルURLを見つけたり、属性がない場合はモデルURLをカテゴリに関連付けたり、モデルURLを属性セットに関連付けたりすることだけです。

00:20:45.000 -> 00:20:54.000
最後のステップは、エクスポート関数を呼び出して、出力URL、モデルプロバイダーインスタンス、および.modelオプションを指定することです。

00:20:54.000 -> 00:21:00.000
出来上がり！私たちが得るのは、あなたのスキャンに対応する3Dモデルを備えたUSDZです。

00:21:00.000 -> 00:21:12.000
さらに進むために、オプションでUSDZをBlenderのようなDCCツールに取り込んで、光と影を追加して、数分でさらに現実的な結果を得ることができます。

00:21:12.000 -> 00:21:18.000
説得力のある結果を生み出すために、サンプルコードに事前に入力されたカタログを追加しました。

00:21:18.000 -> 00:21:21.000
戻るよ、アレックス!

00:21:21.000 -> 00:21:22.000
アレックス:ありがとう、アントワーヌ。

00:21:22.000 -> 00:21:25.000
今日共有したものを見てみましょう。そして、私たちが共有したものを見てみましょう。

00:21:25.000 -> 00:21:39.000
まず、カスタムARSessionサポートは、不動産リストを改善するためにスキャンと一緒に高品質の画像やビデオをキャプチャするなどの新しいユースケースを可能にします。

00:21:39.000 -> 00:21:49.000
これで、複数の部屋をスキャンし、新しいStructureBuilder APIを使用して、家全体のマージされた3Dモデルを生成することもできます。

00:21:49.000 -> 00:21:59.000
ロービジョンユーザーのスキャン体験を向上させるために、RoomPlanはRoomCaptureViewを使用する際にVoiceOverをサポートするようになりました。

00:21:59.000 -> 00:22:06.000
RoomPlanの新しいオブジェクト属性を使用すると、スキャンした部屋をより正確に表現できます。

00:22:06.000 -> 00:22:17.000
そして最後に、新しいエクスポートAPIを使用して、カスタムカタログから対応するスキャンされたオブジェクトに3Dモデルを割り当てることができます。

00:22:17.000 -> 00:22:19.000
それがiOS 17のRoomPlanです。

00:22:19.000 -> 23:59:59.000
私たちはあなたがそれで何を作るかを見るのが待ちきれません。

