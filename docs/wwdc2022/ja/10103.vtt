WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:11.000
こんにちは、ようこそ。

00:00:11.000 --> 00:00:14.000
私の名前はAppleのGPUソフトウェアチームのKelvin Chiuです。

00:00:14.000 --> 00:00:20.000
今日は、MetalFXアップスケーリングでMetalアプリケーションのパフォーマンスを向上させる方法について説明します。

00:00:20.000 --> 00:00:27.000
MetalFXは、Metalアプリケーションにプラットフォームに最適化されたグラフィックエフェクトを提供する新しいAPIです。

00:00:27.000 --> 00:00:34.000
高性能のアップスケーリングを可能にし、レンダリング品質を維持しながらアプリケーションのパフォーマンスを向上させます。

00:00:34.000 --> 00:00:38.000
高解像度でフレームをレンダリングすると、GPUの時間がかかります。

00:00:38.000 --> 00:00:42.000
その時間を短縮するために、通常、より低い解像度でのレンダリングはトリックを行います。

00:00:42.000 --> 00:00:45.000
しかし、トレードオフはレンダリング品質が低いことです。

00:00:45.000 --> 00:00:55.000
MetalFXアップスケーリングを使用すると、アプリケーションはレンダリング品質を損なうことなく、より低い解像度でフレームをレンダリングし、レンダリング時間を短縮できるようになりました。

00:00:55.000 --> 00:01:00.000
MetalFXアップスケーリングは、Appleデバイスで最適に動作するように最適化されています。

00:01:00.000 --> 00:01:04.000
そして、あなたのゲームに採用することも簡単です。

00:01:04.000 --> 00:01:09.000
MetalFXは2つのアップスケーリング効果を提供しており、詳しく説明します。

00:01:09.000 --> 00:01:14.000
空間アップスケーリングは使いやすく、パフォーマンスが大幅に向上します。

00:01:14.000 --> 00:01:22.000
一時的なアンチエイリアシングとアップスケーリングは、複数のフレームからの情報を統合して、より高品質の出力を生成します。

00:01:22.000 --> 00:01:27.000
次に、これらの効果を使用するためのベストプラクティスについて話します。

00:01:27.000 --> 00:01:32.000
最後に、それらを実際に示すデモでセッションを終了します。

00:01:32.000 --> 00:01:36.000
空間的なアップスケーリングから始めましょう。

00:01:36.000 --> 00:01:43.000
MetalFX Spatialアップスケーリングは、入力の空間情報を分析して、新しいアップスケールされたサンプルを生成します。

00:01:43.000 --> 00:01:45.000
空間アップスケーリングの統合は簡単です。

00:01:45.000 --> 00:01:51.000
空間的にアップスケールされたカラー出力を生成するには、アンチエイリアス入力色のみが必要です。

00:01:51.000 --> 00:02:00.000
典型的なゲームレンダリングパイプラインでは、アンチエイスレンダリングやさまざまな後処理効果など、さまざまなレンダリングパスがあります。

00:02:00.000 --> 00:02:05.000
ゲームのトーンマッピングプロセスが完了した直後にMetalFX空間アップスケーリングを追加します。

00:02:05.000 --> 00:02:10.000
入力がトーンマッピングされ、知覚色空間にある場合、最高のパフォーマンスを発揮します。

00:02:10.000 --> 00:02:15.000
MetalFXの空間アップスケーリングを実際にチェックしましょう。

00:02:15.000 --> 00:02:20.000
このチェスシーンは、4K解像度の高品質のリファレンスレンダラーで制作されています。

00:02:20.000 --> 00:02:26.000
これは、レイトレースされた反射や影のような複雑なグラフィック効果で、パストレースです。

00:02:26.000 --> 00:02:32.000
これは、左側に540pの入力で、サイドバイサイドの比較です...

00:02:32.000 --> 00:02:38.000
...そして、右側にMetalFX空間アップスケーリングを備えた1080p出力。

00:02:38.000 --> 00:02:44.000
左側のクイーンにズームインすると、画像には詳細がなく、低解像度です。

00:02:44.000 --> 00:02:52.000
右側では、空間的にアップスケールされた出力は、よりシャープな反射とより洗練されたエッジを持っています。

00:02:52.000 --> 00:02:57.000
次に、MetalFXの空間アップスケーリングを実装する方法を説明します。

00:02:57.000 --> 00:03:04.000
Metalでは、通常、コマンドをコマンドバッファにエンコードし、効果の入力を生成するコマンドエンコーダを作成します。

00:03:04.000 --> 00:03:12.000
同様に、MetalFXエフェクトオブジェクトを作成して、コマンドをコマンドバッファにエンコードし、エフェクトを実行できます。

00:03:12.000 --> 00:03:17.000
最後に、MetalFX出力を利用するコマンドをエンコードする3番目のコマンドエンコーダを作成します。

00:03:17.000 --> 00:03:27.000
作成に費用がかかるため、アプリケーションが最初に起動したとき、またはディスプレイが解像度を切り替えたときにのみ、新しい空間スケーラーオブジェクトを作成する必要があります。

00:03:27.000 --> 00:03:32.000
まず、MTLFXSpatialScalerDescriptorを作成して設定します。

00:03:32.000 --> 00:03:37.000
次に、makeSpatialScaler()メソッドを呼び出してスケーラーオブジェクトを作成します。

00:03:37.000 --> 00:03:41.000
初期化コードでは、記述子から始めます。

00:03:41.000 --> 00:03:45.000
入力テクスチャと出力テクスチャの幅と高さの両方を塗りつぶします。

00:03:45.000 --> 00:03:50.000
次に、後でスケーラーオブジェクトに設定するテクスチャのテクスチャ形式を設定します。

00:03:50.000 --> 00:03:53.000
色処理モードを設定します。

00:03:53.000 --> 00:03:57.000
これは、入力と出力がどの色空間にあるかをAPIに伝えます。

00:03:57.000 --> 00:04:03.000
値を知覚色空間、線形色空間、HDR色空間のいずれかに設定できます。

00:04:03.000 --> 00:04:08.000
記述子が入力されたら、スケーラーオブジェクトを作成します。

00:04:08.000 --> 00:04:18.000
スケーラーオブジェクトが作成されたら、オブジェクトのプロパティを好きなだけ変更し、encode()メソッドを呼び出してアップスケーリングプロセスを開始できます。

00:04:18.000 --> 00:04:28.000
フレームごとの描画コードでは、スケーリング効果をコマンドバッファにエンコードする前に、スケーラーオブジェクトに正しい入力と出力のテクスチャが設定されていることを確認してください。

00:04:28.000 --> 00:04:32.000
空間アップスケーリングは、パフォーマンスを向上させる簡単な方法を提供します。

00:04:32.000 --> 00:04:39.000
そして、さらに高品質のレンダリングが必要な場合は、MetalFXの一時的なアンチエイリアシングとアップスケーリングが登場します。

00:04:39.000 --> 00:04:46.000
時間的AAとアップスケーリングは、以前のフレームのデータを使用して高品質のアップスケール出力を生成する手法です。

00:04:46.000 --> 00:04:53.000
つまり、前のフレームからのアップスケーリングの出力は、現在のフレームアップスケーリングの入力の1つとして使用されます。

00:04:53.000 --> 00:05:02.000
一時的なAAとアップスケーリングが以前のフレームからのデータを必要とする理由をよりよく理解するために、まずスーパーサンプリングの概念を確認します。

00:05:02.000 --> 00:05:09.000
スーパーサンプリングでは、ピクセルごとに複数のサンプルが計算され、単一のピクセル値に統合されます。

00:05:09.000 --> 00:05:14.000
ピクセルごとに統合するサンプルが多ければ多いほど、結果は良くなります。

00:05:14.000 --> 00:05:21.000
ただし、1つのフレーム内でピクセルごとに複数のサンプルを計算するには大きなコストがかかります。

00:05:21.000 --> 00:05:28.000
1つのフレームでピクセルごとに複数の場所をサンプリングする代わりに、一時的なサンプリングを実行できます。

00:05:28.000 --> 00:05:34.000
時間的サンプリングは、特定のフレーム内のすべてのピクセルに対して異なるサンプル位置をレンダリングする概念です。

00:05:34.000 --> 00:05:41.000
これにより、大幅に低コストで複数のフレームでスーパーサンプリング品質を実現できます。

00:05:41.000 --> 00:05:56.000
複数のフレームからサンプルを蓄積し、サンプル位置を考慮することにより、一時的なAAとアップスケーリングは、ターゲット解像度のピクセルにサンプルを適切に統合し、高品質のアンチエイリアスアップスケール出力を実現します。

00:05:56.000 --> 00:06:03.000
ただし、コンテンツはフレーム間で変更されることが多いため、これらの変更を検出するにはより多くの入力データが必要になります。

00:06:03.000 --> 00:06:14.000
前のフレーム出力に加えて、テンポラルAAとアップスケーリングには、ジッタリングされたカラー入力と、シーンからの動きと深度のデータも必要です。

00:06:14.000 --> 00:06:19.000
それぞれを調べて、なぜ必要なのかを説明します。

00:06:19.000 --> 00:06:23.000
ジッタリングカラー入力から始めましょう。

00:06:23.000 --> 00:06:26.000
これはジッタなしでレンダリングされた赤い三角形です。

00:06:26.000 --> 00:06:30.000
明るい白い輪郭は、レンダリングされている三角形を表しています。

00:06:30.000 --> 00:06:33.000
小さな正方形はそれぞれピクセルを表しています。

00:06:33.000 --> 00:06:38.000
そして、真ん中の灰色の点は、ピクセルがサンプリングされる場所です。

00:06:38.000 --> 00:06:43.000
これは、小さなジッタでレンダリングされたときの同じ三角形の出力です。

00:06:43.000 --> 00:06:47.000
灰色の点は、特定のピクセルのサンプリング位置を示しています。

00:06:47.000 --> 00:06:54.000
ジッタオフセットは、必要な数のサンプルを完全に収集するために、設定された数のフレームに対して一意である必要があります。

00:06:54.000 --> 00:06:58.000
ジッターシーケンスのトピックについては、後で詳しく説明します。

00:06:58.000 --> 00:07:01.000
次は現場からの動き情報です。

00:07:01.000 --> 00:07:09.000
シーンからの動きデータは、オブジェクトが前のフレームからどれだけ、どの方向に移動したかを示します。

00:07:09.000 --> 00:07:18.000
一時的なAAとアップスケーリングは、サンプルを正しく収集するために、モーション情報を使用してバックトラックし、前のフレーム内の対応する場所を見つけます。

00:07:18.000 --> 00:07:22.000
もう1つの入力は、シーンからの深さ情報です。

00:07:22.000 --> 00:07:26.000
シーンからの深度データは、フォアグラウンドにあるものとバックグラウンドにあるものを示します。

00:07:26.000 --> 00:07:37.000
これは、フォアグラウンドエッジのアンチエイリアシングを優先する際に重要であり、以前のフレームからサンプルを収集するときに、他のオブジェクトが新たに公開される可能性のある手がかりを提供します。

00:07:37.000 --> 00:07:42.000
最後の入力データは、前のフレームの出力です。

00:07:42.000 --> 00:07:56.000
前のフレームの出力には、以前に統合されたすべてのサンプルが含まれており、ピクセルあたりのサンプル数を増やすために、現在のフレームのジッタカラー入力とブレンドされます。

00:07:56.000 --> 00:08:02.000
現在のフレームと前のフレームの両方の情報を組み合わせることで、結果の画像に詳細が表示されます。

00:08:02.000 --> 00:08:11.000
MetalFXはアップスケールされた出力を追跡するので、現在レンダリングされたフレームから色、動き、深さを渡すだけで済みます。

00:08:11.000 --> 00:08:24.000
典型的なゲームのレンダリングパイプラインに戻ると、MetalFXの一時的なAAとアップスケーリングは、これらの効果がアップスケーリングの結果を妨げるため、後処理効果の前に実行する必要があります。

00:08:24.000 --> 00:08:29.000
今回はMetalFX Temporal AAとアップスケーリングを使用して、再びチェスのレンダリングです。

00:08:29.000 --> 00:08:41.000
これは、左側の1080p入力と右側の4Kアップスケール出力のサイドバイサイド比較です。

00:08:41.000 --> 00:08:55.000
クイーンの近くにズームインすると、入力は低解像度でエイリアスされていますが、右側の一時的にアップスケールされた出力は滑らかなアウトラインを持つ高解像度で、反射に細かい詳細があります。

00:08:55.000 --> 00:09:05.000
空間スケーラーと同様に、新しい時間スケーラーの作成は高価であり、アプリケーションが最初に起動したとき、またはディスプレイが解像度を切り替えたときにのみ行う必要があります。

00:09:05.000 --> 00:09:10.000
まず、MTLFXTemporalScalerDescriptorを割り当てて記入する必要があります。

00:09:10.000 --> 00:09:15.000
次に、makeTemporalScaler()メソッドを呼び出して、スケーラーオブジェクトを作成します。

00:09:15.000 --> 00:09:19.000
初期化コードでは、記述子から始めます。

00:09:19.000 --> 00:09:23.000
入力テクスチャと出力テクスチャの幅と高さの両方を記入します。

00:09:23.000 --> 00:09:32.000
次に、後でスケーラーオブジェクトにバインドされるテクスチャのジッタされた色、深さ、およびモーションテクスチャフォーマットを入力として設定します。

00:09:32.000 --> 00:09:38.000
最後に、MetalFXがアップスケールされた出力を保存する出力テクスチャのフォーマットを設定します。

00:09:38.000 --> 00:09:42.000
記述子が入力されたら、スケーラーオブジェクトを作成します。

00:09:42.000 --> 00:09:45.000
スケーラーオブジェクトで、モーションスケールのプロパティを設定します。

00:09:45.000 --> 00:09:50.000
これは、アプリのモーションデータをAPIが期待するものにスケーリングするのに役立ちます。

00:09:50.000 --> 00:09:59.000
MetalFXは、現在のフレームの位置から前のフレームの位置までの方向で、レンダリング解像度のピクセル空間のモーションデータを期待しています。

00:09:59.000 --> 00:10:03.000
例として、1080pのレンダリング解像度を使用します。

00:10:03.000 --> 00:10:09.000
クリップ空間座標(-0.75、-0.75)から移動するオブジェクトがあるとします。

00:10:09.000 --> 00:10:12.000
スペース座標(0.25、0.25)をクリップします。

00:10:12.000 --> 00:10:17.000
モーションデータは(1, 1)として保存されます。

00:10:17.000 --> 00:10:26.000
MetalFXがゲームのモーションデータを正しく解釈できるように、モーションベクタースケールプロパティを(-960、540)に設定します。

00:10:26.000 --> 00:10:30.000
スケーラーオブジェクトのプロパティは、好きなだけ頻繁に変更できます。

00:10:30.000 --> 00:10:35.000
そして、encode()メソッドを呼び出して、アップスケーリングプロセスを開始します。

00:10:35.000 --> 00:10:39.000
フレームごとの描画コードについては、まずresetHistoryプロパティを設定します。

00:10:39.000 --> 00:10:44.000
アプリケーションが最初のフレームをロードするとき、またはシーンカットがあるときに、これをtrueに設定します。

00:10:44.000 --> 00:10:51.000
次に、エフェクトの入力であるテクスチャを設定し、続いて出力テクスチャを設定します。

00:10:51.000 --> 00:10:57.000
次に、res逆Depthプロパティを設定して、深度値が逆Zマッピングにあるかどうかを示します。

00:10:57.000 --> 00:11:03.000
スケーリング効果をエンコードする前に設定する最後のプロパティは、現在のジッタオフセットです。

00:11:03.000 --> 00:11:07.000
ジッタオフセットを正しく取得することは、出力の品質に不可欠です。

00:11:07.000 --> 00:11:11.000
ジッターオフセットの設定方法を簡単に見てみましょう。

00:11:11.000 --> 00:11:16.000
例として、左側にはジッターでレンダリングされた三角形があります。

00:11:16.000 --> 00:11:19.000
右側はピクセルのズームインビューです。

00:11:19.000 --> 00:11:23.000
サンプルは(0.625、0.78)にあります。

00:11:23.000 --> 00:11:26.000
ピクセルの中心はオレンジ色のドットで表されます。

00:11:26.000 --> 00:11:30.000
それは(0.5、0.5)に位置しています。

00:11:30.000 --> 00:11:35.000
この例では、ジッターオフセットは(-0.125、-0.28)です。

00:11:35.000 --> 00:11:40.000
ジッタオフセットは常に-0.5から0.5の範囲であることに注意してください。

00:11:40.000 --> 00:11:49.000
正しいジッタオフセットを提供していることを確認するには、異なるジッタオフセットのシーケンスを使用して、カメラとオブジェクトの動きなしでシーンをレンダリングします。

00:11:49.000 --> 00:11:53.000
左側は、誤ったジッタオフセットが指定されている場合の例です。

00:11:53.000 --> 00:11:57.000
静的な物体はシフトする可能性があり、細い線はあいまいです。

00:11:57.000 --> 00:12:01.000
右側は、正しいジッタオフセットが指定されている場合の出力です。

00:12:01.000 --> 00:12:05.000
オブジェクトは所定の位置にとどまり、細い線は徐々に解決されます。

00:12:05.000 --> 00:12:16.000
MetalFXの「一時的なAAとアップスケーリング」効果は、アプリケーションのパフォーマンスを向上させ、ネイティブターゲット解像度レンダリングの品質に匹敵するアップスケーリング品質を提供します。

00:12:16.000 --> 00:12:25.000
両方のアップスケーリング効果を使用する際に最適な品質とパフォーマンスを得るために、実装のベストプラクティスについて説明します。

00:12:25.000 --> 00:12:28.000
空間的なアップスケーリングから始めます。

00:12:28.000 --> 00:12:33.000
最高の空間アップスケーリング品質のために、カラー入力はアンチエイリアスでノイズフリーであるべきです。

00:12:33.000 --> 00:12:41.000
これは、ノイズ効果とエイリアス画像が良好なエッジ決定を妨げ、空間アップスケーリング品質を悪化させるためです。

00:12:41.000 --> 00:12:46.000
最高のパフォーマンスを得るには、知覚色処理モードを使用してください。

00:12:46.000 --> 00:12:53.000
つまり、入力色は、sRGB色空間で0-1の値でトーンマッピングする必要があります。

00:12:53.000 --> 00:12:58.000
そして最後に、より高いテクスチャディテールのために適切な負のミップバイアスを設定します。

00:12:58.000 --> 00:13:08.000
空間アップスケーリングに推奨されるミップバイアス計算は、レンダリング解像度幅のlog2をターゲット解像度幅で割ることです。

00:13:08.000 --> 00:13:21.000
たとえば、各レンダリング解像度のディメンションを2倍スケーリングすると-1 mipバイアスになり、各ディメンションを1.5xスケーリングすると-0.58 mipバイアスになります。

00:13:21.000 --> 00:13:26.000
低いミップレベルは、高周波パターンのテクスチャがちらつく可能性があることに注意してください。

00:13:26.000 --> 00:13:31.000
そのようなアーティファクトを見つけた場合は、特定のテクスチャのミップバイアスを調整する必要があります。

00:13:31.000 --> 00:13:36.000
次に、TemporalAAとアップスケーリングのベストプラクティスについて話します。

00:13:36.000 --> 00:13:43.000
一時的なAAとアップスケーリングから最高の品質を得るには、良いジッターシーケンスを選択することが重要です。

00:13:43.000 --> 00:13:50.000
アップスケールされたターゲット解像度で、すべてのピクセルにわたるサンプルの良好な分布を提供するジッタシーケンスを探してください。

00:13:50.000 --> 00:13:57.000
通常、出力ピクセルあたり8つのジッタサンプルは、高品質のアンチエイリアスアップスケール出力を生成します。

00:13:57.000 --> 00:14:06.000
2倍のアップスケーリングの場合、32のジッターを持つハルトン(2,3)シーケンスを使用して、ジッターされたカラー入力を生成することをお勧めします。

00:14:06.000 --> 00:14:15.000
これは、ハルトン（2,3）シーケンスからの最初の32のサンプル場所のプロットで、出力ピクセルごとに約8つのサンプルを生成します。

00:14:15.000 --> 00:14:20.000
また、より高いテクスチャの詳細のために適切な負のミップバイアスを設定することも重要です。

00:14:20.000 --> 00:14:31.000
時間AAとアップスケーリングの推奨されるミップバイアス計算は、レンダリング解像度幅のlog2をターゲット解像度幅で割って1で減算することです。

00:14:31.000 --> 00:14:44.000
たとえば、各レンダリング解像度のディメンションを2倍スケーリングすると-2ミップバイアスになり、各ディメンションを1.5倍スケーリングすると-1.58ミップバイアスになります。

00:14:44.000 --> 00:14:50.000
次に、さまざまな状況でミップバイアスが出力にどのように影響するかの例を紹介します。

00:14:50.000 --> 00:15:00.000
MetalFXの時間的AAと、0、-1、-2のミップバイアスを使用して、同じシーンの出力をアップスケーリングします。

00:15:00.000 --> 00:15:09.000
-2のミップバイアスは最もシャープで明確な出力を生成しますが、0のミップバイアスは最も柔らかく、最もぼやけた出力を生成します。

00:15:09.000 --> 00:15:14.000
時間的アップスケーリング効果を使用する回路基板の3つのレンダリングを次に示します。

00:15:14.000 --> 00:15:21.000
上から下まで、テクスチャをサンプリングするときに適用されるmipバイアス値は0、-1、および-2です。

00:15:21.000 --> 00:15:31.000
回路基板のテクスチャには、小さなトレースワイヤなどの高周波パターンがあるため、-2のミップバイアスはちらつきとモアレ効果を生成します。

00:15:31.000 --> 00:15:39.000
しかし、-1のミップバイアスはこれらの効果を大幅に軽減し、0のミップバイアスはそれらを完全に排除します。

00:15:39.000 --> 00:15:43.000
低いミップレベルは、一般的により多くの詳細をもたらします。

00:15:43.000 --> 00:15:50.000
ミップバイアスの提案を出発点として使用しますが、高周波パターンのテクスチャにミップバイアスを選択するときは注意してください。

00:15:50.000 --> 00:16:00.000
これらのプラクティスに従って、MetalFX Temporal AAとアップスケーリングからのアンチエイリアス、高品質のアップスケール出力を確保してください。

00:16:00.000 --> 00:16:05.000
最後に、MetalFXアップスケーリングを使用する際のパフォーマンスのベストプラクティスについて説明します。

00:16:05.000 --> 00:16:16.000
MetalFXアップスケーリングで最高のパフォーマンスを得るには、2つの非依存的なレンダリングまたはコンピューティングパスで読み書きするために同じリソースをバインドしないように注意する必要があります。

00:16:16.000 --> 00:16:18.000
そうすることで、誤った依存関係が生まれます。

00:16:18.000 --> 00:16:22.000
金属では、誤った依存関係を避けることは常に良い考えです。

00:16:22.000 --> 00:16:27.000
しかし、次に説明するように、これはMetalFXのアップスケーリングにとって特に重要です。

00:16:27.000 --> 00:16:30.000
この例では、2つのフレームがあります。

00:16:30.000 --> 00:16:37.000
シャドウと後処理パスは完全に無関係であり、リソースの依存関係はありません。

00:16:37.000 --> 00:16:43.000
メタルは、次のフレームのシャドウパスと現在のフレームのポストプロセッシングパスと重なります。

00:16:43.000 --> 00:16:59.000
ただし、後処理パスがMetalバッファに書き込み、シャドウパスも同じバッファから読み込む場合、Metalは、同じリソースへの読み取りと書き込みの潜在的な危険を同時に回避するために、GPUがこれら2つのパスを並行して実行するのを防ぎます。

00:16:59.000 --> 00:17:05.000
フレーム間の誤った依存関係は、MetalFXアップスケーリングのパフォーマンスに悪影響を及ぼす可能性があります。

00:17:05.000 --> 00:17:14.000
フレーム間に誤った依存関係がない場合、次のフレームのシャドウパスが前のフレームのMetalFXアップスケーリングと重なっている可能性があることに注意してください。

00:17:14.000 --> 00:17:23.000
しかし、フレーム間の誤った依存関係のため、パフォーマンスの低下には、MetalFX Upscalingがプロセスを完了するのにかかる時間も含まれます。

00:17:23.000 --> 00:17:35.000
理想的には、異なるフレーム間のワークロードの重複を可能にするために、フレーム間に誤った依存関係がないことを確認し、MetalFXアップスケーリングを使用する際に最適なパフォーマンスを確保する必要があります。

00:17:35.000 --> 00:17:49.000
この例では、代わりに、誤った依存関係を防ぐために、後処理とシャドウパス用の別のバッファを作成し、独立したパスを並列に実行することができます。

00:17:49.000 --> 00:17:55.000
誤った依存関係を避けることは、MetalFXアップスケーリングを採用する際に常に心に留めておくべきことです。

00:17:55.000 --> 00:18:01.000
これら2つの効果のどちらを選択するかを決定する際には、心に留めておくべき考慮事項がいくつかあります。

00:18:01.000 --> 00:18:07.000
増え続けるシェーディングコストとピクセル数により、一時的なAAとアップスケーリングはここにとどまります。

00:18:07.000 --> 00:18:13.000
ピクセルを償却すると、視覚的な忠実度が一時的に向上し、パフォーマンスが向上します。

00:18:13.000 --> 00:18:26.000
優れた時間的AAソリューションをまだ持っておらず、ジッタした色、動き、深度バッファをレンダリングできる場合、MetalFX時間的AAとアップスケーリングは、考慮すべき魅力的なプラットフォーム最適化ソリューションを提供します。

00:18:26.000 --> 00:18:34.000
必要な入力がない場合は、またはすでに調整されたAAソリューションをお持ちの場合は、MetalFX空間アップスケーリングの使用を検討してください。

00:18:34.000 --> 00:18:39.000
これで、どのアップスケーリング効果を選択するかをよりよく理解できることを願っています。

00:18:39.000 --> 00:18:44.000
次に、メタルアプリケーションでライブで実行されているこれらの効果の両方の例を紹介します。

00:18:44.000 --> 00:18:56.000
これは、アンビエントオクルージョンや体積霧などのリアルタイムレンダリングアルゴリズムを特徴とする「Modern Rendering with Metal」サンプルコードの「Bistro」シーンを並べて比較します。

00:18:56.000 --> 00:19:02.000
左側の1080pのネイティブレンダリングと、右側のMetalFX空間アップスケーリングによる4K出力。

00:19:02.000 --> 00:19:10.000
このサンプルには、MetalFX空間アップスケーリングの入力として使用する独自の時間的アンチエイリアスソリューションがあることに注意してください。

00:19:10.000 --> 00:19:15.000
スクーターでより密接にズームインする...

00:19:15.000 --> 00:19:23.000
左側では、画像は少しぼやけていますが、右側では、空間的にアップスケールされた出力により、よりシャープなエッジでより鮮明な画像が得られます。

00:19:23.000 --> 00:19:28.000
ハンドルバーの直線はうまくアンチエイリアスされています。

00:19:28.000 --> 00:19:32.000
体の曲線もはるかに滑らかです。

00:19:32.000 --> 00:19:35.000
パフォーマンス比較をしましょう。

00:19:35.000 --> 00:19:38.000
左側は4Kでのネイティブレンダリングです。

00:19:38.000 --> 00:19:44.000
右側は、MetalFX Spatialアップスケーリングからの4K出力です。

00:19:44.000 --> 00:19:55.000
カメラが動くにつれて、左側のネイティブレンダリングは不安定なフレームレートで実行されていますが、右側の空間的にアップスケールされた出力ははるかにスムーズです。

00:19:55.000 --> 00:20:01.000
次は、多くの反射と影を持つレイトレーシングシーンを並べて比較します。

00:20:01.000 --> 00:20:04.000
左側は1080pのネイティブレンダリングです。

00:20:04.000 --> 00:20:10.000
右側は、MetalFX Temporal AAとアップスケーリングを備えた4K出力です。

00:20:10.000 --> 00:20:14.000
シャンデリアをより密接にズームインする...

00:20:14.000 --> 00:20:22.000
左側のネイティブ出力はエイリアスの外観を持っていますが、右側の一時的にアップスケールされた出力は、より細かいディテールを持つ鋭いエッジを持っています。

00:20:22.000 --> 00:20:26.000
影はぼやけて見えるのではなく、素敵で鮮明です。

00:20:26.000 --> 00:20:32.000
そして、シャンデリアの細かいディテールが認識できるようになりました。

00:20:32.000 --> 00:20:37.000
MetalFX Temporal AAとアップスケーリングでは、パフォーマンスの向上も明らかです。

00:20:37.000 --> 00:20:40.000
左側は4Kでのネイティブレンダリングです。

00:20:40.000 --> 00:20:45.000
右側は、MetalFX Temporal AAとアップスケーリングを備えた4K出力です。

00:20:45.000 --> 00:21:06.000
カメラが動くにつれて、左側のネイティブレンダリングは非常に低いフレームレートで実行されていますが、右側の一時的にアップスケールされた出力ははるかにスムーズです。

00:21:06.000 --> 00:21:18.000
主要なゲーム開発者は、MetalFX Upscalingの機能に興奮しており、今年後半に「Grid: Legends」、「Resident Evil: Village」、「No Man's Sky」をMacに持ち込む予定です。

00:21:18.000 --> 00:21:21.000
次に、フレームワークを使用した初期の作業を紹介します。

00:21:21.000 --> 00:21:33.000
このシーンでは、MetalFX Temporal AAとUpscalingを使用して、「No Man's Sky」の信じられないほどのビジュアルと流動的なゲームプレイを見ることができます。

00:21:33.000 --> 00:21:45.000
要約すると、MetalFXはアップスケーリングに焦点を当てた新しいAPIです。

00:21:45.000 --> 00:21:54.000
空間アップスケーリングは採用が簡単で、大幅なパフォーマンスの向上をもたらし、一時的なAAとアップスケーリングを使用して、より高品質のレンダリングを実現できます。

00:21:54.000 --> 00:22:01.000
先ほど話したベストプラクティスに従うことで、MetalFXのアップスケーリングを最大限に活用できます。

00:22:01.000 --> 00:22:02.000
ご覧いただきありがとうございます。

00:22:02.000 --> 23:59:59.000
♪ ♪

