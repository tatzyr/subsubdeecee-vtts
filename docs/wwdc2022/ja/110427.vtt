WEBVTT

00:00:00.000 -> 00:00:02.000
♪インストゥルメンタルヒップホップ音楽♪

00:00:02.000 -> 00:00:09.000
♪

00:00:09.000 -> 00:00:12.000
みなさん、こんにちは。私はジョナサン・マーです。

00:00:12.000 -> 00:00:13.000
そして私はリサ・シャオです。

00:00:13.000 -> 00:00:17.000
そして、Xcode 14の新機能を紹介したいと思います。

00:00:17.000 -> 00:00:28.000
今日は、ソース編集やSwiftUIプレビュー、マルチプラットフォームアプリケーション、TestFlightフィードバック、パフォーマンスの向上など、Xcode全体の新機能と機能強化を見ていきます。

00:00:28.000 -> 00:00:31.000
カバーすることがたくさんあるので、それを手に入れましょう。

00:00:31.000 -> 00:00:34.000
あなたが最初に気づくのは、それがどれだけ速く始まったばかりかということです。

00:00:34.000 -> 00:00:37.000
Xcode 14は30%小さいです。

00:00:37.000 -> 00:00:40.000
大幅に高速にダウンロードとインストールが高速になります。

00:00:40.000 -> 00:00:44.000
追加のプラットフォームやシミュレータはオンデマンドでダウンロードできます。

00:00:44.000 -> 00:00:51.000
すぐに必要な場合は、ここで入手できます。または後で、最初に使用しようとするときに入手できます。

00:00:51.000 -> 00:00:58.000
私たちは、食品配達アプリケーションであるフードトラックを構築しています。

00:00:58.000 -> 00:01:03.000
ライブプレビュー付きのSwiftUIは素晴らしいワークフローであり、さらに良くなっています。

00:01:03.000 -> 00:01:10.000
これで、プレビューキャンバスはデフォルトでインタラクティブなので、変更は作成するとすぐに有効になります。

00:01:10.000 -> 00:01:16.000
キャンバスには、コードを書かずに各プレビューの追加バリアントを作成するための新しいコントロールがあります。

00:01:16.000 -> 00:01:24.000
配色、テキストサイズ、またはデバイスの向きを変えて、各シナリオでレンダリングされたインターフェイスをすぐに見ることができます。

00:01:24.000 -> 00:01:37.000
さまざまなダイナミックタイプサイズで私たちのビューがどのように見えるか見てみましょう。

00:01:37.000 -> 00:01:43.000
これらのプレビューを並べて、インターフェイスを検証し、物事が正しく見えることを確認するのは簡単です。

00:01:43.000 -> 00:01:51.000
大きいサイズを確認しましょう。

00:01:51.000 -> 00:01:56.000
最初のアイコンは非常に広く、テキストをぎこちなくラップします。

00:01:56.000 -> 00:02:00.000
幸いなことに、私のデザイナーはちょうど私にそれを変更するように頼んだが、ヘッダーでのみ。

00:02:00.000 -> 00:02:07.000
私たちのCardViewはまだヘッダーの別のアイコンをサポートしていないので、その機能を追加することから始めましょう。

00:02:07.000 -> 00:02:15.000
実装に切り替えます。

00:02:15.000 -> 00:02:22.000
ヘッダーとコンテンツ要素はどちらも同じ画像を使用しています。

00:02:22.000 -> 00:02:36.000
ヘッダー専用の別の画像プロパティを追加しましょう。

00:02:36.000 -> 00:02:41.000
ほとんどのカードでは、両方の場所で同じ画像を使用すると見栄えがします。

00:02:41.000 -> 00:02:53.000
デフォルト値のカスタム初期化子を追加することで、既存の各呼び出しを更新する時間を節約できます。

00:02:53.000 -> 00:02:59.000
イニシャライザを入力し始めると、Xcode 14は現在、すべてを完了するために提供しています!

00:02:59.000 -> 00:03:07.000
カスタマイズの出発点としてデフォルト値を受け入れることができ、多くの時間を節約できます。

00:03:07.000 -> 00:03:10.000
これは、コーダブルメソッドでも機能します。

00:03:10.000 -> 00:03:24.000
headerIconパラメータにデフォルト値を与えましょう。

00:03:24.000 -> 00:03:36.000
次に、CardStackビューに戻り、この新しい機能を使用します。

00:03:36.000 -> 00:03:39.000
私のデザイナーは私にここでカレンダーのシンボルを使うように頼んだ。

00:03:39.000 -> 00:03:54.000
ライブラリにはすべてのSFシンボルが含まれているので、正しいものを使用していることを確認するのは簡単です。

00:03:54.000 -> 00:04:06.000
Returnキーを押して、シンボルを使用するための正しいコードを挿入できます。

00:04:06.000 -> 00:04:08.000
このシンボルは素晴らしく見えます。

00:04:08.000 -> 00:04:17.000
プレビューバリアントから得られる新しいサイドバイサイド比較により、ユーザーが選択したすべての設定でアプリが見栄えを良くすることが容易になります。

00:04:17.000 -> 00:04:26.000
初期化と作成可能な定義に加えて、Xcode 14はよりインテリジェントな推奨事項を提供するため、アイデアをより迅速かつ簡単に書くことができます。

00:04:26.000 -> 00:04:33.000
もう少しお見せしましょう。

00:04:33.000 -> 00:04:43.000
別のCardViewを追加し始めると、初期化子が完了リストに直接表示されるようになりました。

00:04:43.000 -> 00:04:45.000
headerIconパラメータはイタリック体です。

00:04:45.000 -> 00:04:48.000
それはデフォルト値があるからです。

00:04:48.000 -> 00:04:55.000
今すぐ完了を受け入れると、headerIconラベルは含まれず、追加したばかりのデフォルト値が使用されます。

00:04:55.000 -> 00:05:03.000
ここでは、もう一度アイコンを特殊化したいので、名前の一部を入力してオプトインできます。

00:05:03.000 -> 00:05:14.000
新しいカードにいくつかの値を与えます。

00:05:14.000 -> 00:05:17.000
新しいカードの前に仕切りが欲しいです。

00:05:17.000 -> 00:05:29.000
VStackに仕切りを追加すると、幅全体に線が渡されます。

00:05:29.000 -> 00:05:36.000
より微妙にするために、フレームを使って最大幅を設定します。

00:05:36.000 -> 00:05:40.000
フレーム修飾子には多くのオプションの引数があります。

00:05:40.000 -> 00:05:51.000
新しい完了機能により、必要な議論だけを簡単に取得できます。

00:05:51.000 -> 00:05:54.000
それはXcode 14のコード補完です。

00:05:54.000 -> 00:05:57.000
この最初のカードのタイトルは、ある方法から来ています。

00:05:57.000 -> 00:06:01.000
すべての数字を正しく処理していないと聞いたので、どのように実装されているか見てみましょう。

00:06:01.000 -> 00:06:11.000
コマンドキーを押しながらクリックして、定義にジャンプを選択します。

00:06:11.000 -> 00:06:17.000
再設計された定義リストは、各結果の違いを強調しているため、必要な結果をすばやく選択できます。

00:06:17.000 -> 00:06:22.000
私たちのテキスト(for:)メソッドはプロトコルからのものなので、複数のオプションがあります。

00:06:22.000 -> 00:06:29.000
このリストは、メソッドを定義する特定のタイプを示しています。プロトコルからの宣言と2つの実装があります。

00:06:29.000 -> 00:06:36.000
サーバーにバックアップされた実装に移動します。

00:06:36.000 -> 00:06:44.000
このクラスは、Swift 5.7で新しい正規表現リテラルを使用して解析を実装します。

00:06:44.000 -> 00:06:48.000
私の同僚は、問題が私たちのユニットテストで発見されていると私に言いました。

00:06:48.000 -> 00:07:02.000
今すぐそれらを実行しましょう。

00:07:02.000 -> 00:07:03.000
はい、私たちはいくつかの失敗があります。

00:07:03.000 -> 00:07:09.000
見てみましょう。 

00:07:09.000 -> 00:07:12.000
イベント数を抽出することに何か問題があるようです。

00:07:12.000 -> 00:07:15.000
この関数がどのように呼び出されるかを確認しましょう。

00:07:15.000 -> 00:07:20.000
コマンドキーを押しながらこのメソッドの呼び出しを開くと、直接確認できます。

00:07:20.000 -> 00:07:38.000
定義リストと同様に、呼び出し者リストには、このメソッドの呼び出しを含むさまざまなファイルと関数と、各コールサイトのプレビューが表示されます。

00:07:38.000 -> 00:07:40.000
これは失敗したテスト方法からの呼び出しです。

00:07:40.000 -> 00:07:47.000
プレビューは、テストが文字列「0レコード」に合格していることを示しています。これは私に問題についてのヒントを与えてくれます。

00:07:47.000 -> 00:07:55.000
そして今、私はバグを見つけることができます:正規表現は1〜9の数字と一致していますが、ゼロを含めるのを忘れました!

00:07:55.000 -> 00:08:11.000
0-9を使用するように文字範囲を更新するか、より説明的な数字文字クラスに切り替えることで、これを修正できます。

00:08:11.000 -> 00:08:16.000
何かがまだ正しくありませんが、今、コンパイラがその理由を教えています。

00:08:16.000 -> 00:08:20.000
正規表現は、Swift 5.7のファーストクラスの機能です。

00:08:20.000 -> 00:08:26.000
コンパイラは他のコードと同じように私の正規表現をチェックし、Xcodeはすぐに私のタイプミスをハイライトします。

00:08:26.000 -> 00:08:41.000
式を修正すると、2つのことが起こることに注意してください。正規表現のシンタックスハイライトが私の編集を確認し、エラーが灰色に薄暗くなります。

00:08:41.000 -> 00:08:45.000
この新しい調光は、Xcodeが診断を再評価していることを示しています。

00:08:45.000 -> 00:08:52.000
しばらく一時停止すると、ファイルが再処理され、Xcodeはエラーが解決されたことを確認します。

00:08:52.000 -> 00:09:02.000
この調光は長いビルド中にも行われるので、どの問題が最新のビルドからのもので、どの問題が以前のビルドからのものかを簡単に知ることができます。

00:09:02.000 -> 00:09:15.000
テストに行きましょう。

00:09:15.000 -> 00:09:19.000
これは、テスト方法の真ん中にある呼び出しにまっすぐに私をジャンプしました。

00:09:19.000 -> 00:09:21.000
エディタの上部を見てください。

00:09:21.000 -> 00:09:32.000
Xcode 14は、スクロールされても、目に見えるコードを含む定義を示しています。

00:09:32.000 -> 00:09:44.000
上部のテストダイヤモンドを使ってテストを再実行できます。

00:09:44.000 -> 00:09:49.000
素晴らしい、修正はすべてのテストに合格します。

00:09:49.000 -> 00:10:02.000
Xcode 14を使用すると、新しいコード補完でより速くコードを書き、SwiftUIプレビューバリアントで流動的に設計し、改善されたエラー表示でより多くの情報を得て、定義にジャンプして自信を持ってナビゲートすることができます。

00:10:02.000 -> 00:10:04.000
そして、さらに多くのものがあります。こちらがリサです。

00:10:04.000 -> 00:10:05.000
ありがとう、ジョナサン。

00:10:05.000 -> 00:10:10.000
ビルドパフォーマンスの改善を見てみましょう。 

00:10:10.000 -> 00:10:20.000
Xcodeがフレームワークやアプリケーションなどの複数のターゲットを構築すると、まずフレームワークソースをコンパイルします。

00:10:20.000 -> 00:10:23.000
次に、モジュールを生成します。

00:10:23.000 -> 00:10:27.000
これにより、アプリケーションソースのリンクとコンパイルが可能になります。

00:10:27.000 -> 00:10:31.000
そして、アプリケーションをリンクし、ビルドを完了します。

00:10:31.000 -> 00:10:36.000
Xcode 14は、並列性を改善するためにビルドを再配置します。

00:10:36.000 -> 00:10:44.000
Swiftモジュールを熱心に生産することで、Xcodeはビルドタスクのブロックを解除し、並列性を高めます。

00:10:44.000 -> 00:10:53.000
マシンの同時使用をより尊重しながら、ビルドのすべての重要なパスを短縮します。

00:10:53.000 -> 00:10:55.000
しかし、私たちはそこで止まりませんでした。

00:10:55.000 -> 00:11:00.000
また、並列性を高めることで、リンカーを最大2倍高速化しました。

00:11:00.000 -> 00:11:12.000
全体として、Xcode 14はプロジェクトを最大25%速く構築し、最も多くのコアを持つマシンが最大の改善を見ています。

00:11:12.000 -> 00:11:21.000
スケジューリングの構築が改善されても、プロジェクトが長い同期タスクに内部依存関係を持つ場合があります。

00:11:21.000 -> 00:11:27.000
視覚化なしでこれが起こっていることを伝えるのは難しいかもしれません。

00:11:27.000 -> 00:11:31.000
良いニュース、私たちはそれをXcode 14に含めました!

00:11:31.000 -> 00:11:36.000
新しいビルドタイムラインは、ビルドログまたは結果バンドルで開くことができます。

00:11:36.000 -> 00:11:42.000
予想外に長いタスクやボトルネックを特定するのに役立ちます。

00:11:42.000 -> 00:11:44.000
これがフードトラックのビルドタイムラインです。

00:11:44.000 -> 00:11:49.000
ビルドを単一のコアに制限するスクリプトフェーズが見えます。

00:11:49.000 -> 00:11:57.000
新しいビルドタイムラインを使用して、重要な洞察を得て、ビルドのパフォーマンスの機会を特定できます。

00:11:57.000 -> 00:12:10.000
ビルドの並列化、新しいビルドタイムライン、および「Xcodeビルドで並列化を解明する」と「Link Fast: ビルドと起動を改善する」のリンクについてすべて学ぶことができます。

00:12:10.000 -> 00:12:16.000
Xcodeでの並列テストは、テストをより高速に実行するための素晴らしい方法でした。

00:12:16.000 -> 00:12:19.000
Xcode 14では、さらに優れています。

00:12:19.000 -> 00:12:25.000
先ほどお見せしたビルドパフォーマンスを向上させるために、同じテクニックを使用しました。

00:12:25.000 -> 00:12:34.000
Xcode 14は、ターゲットとテストクラス間のスケジューリングの依存関係を排除し、テスト中の並列性をさらに高めます。

00:12:34.000 -> 00:12:45.000
異なるテストクラスとターゲットで長時間実行するテストがある場合、この機能はテストの実行時間を最大30%向上させることができます。

00:12:45.000 -> 00:12:55.000
テストの速度と信頼性を向上させる方法については、「Xcode Cloudの高速で信頼性の高いテストを承認」をご覧ください。

00:12:55.000 -> 00:13:03.000
構築が速くなり、テストが速くなり、macOSアプリの配布の準備も速くなります。

00:13:03.000 -> 00:13:09.000
Xcode 14で公証を4倍に高速化しました。

00:13:09.000 -> 00:13:14.000
Interface Builderを使用するプロジェクトでは、もっと良いニュースがあります!

00:13:14.000 -> 00:13:23.000
ドキュメントの読み込みは最大50%高速で、デバイスバーでのiPhoneとiPadの切り替えは最大30%高速です。

00:13:23.000 -> 00:13:34.000
キャンバスの編集操作は段階的であり、見ているシーンに優先順位を付けて、大きなストーリーボードでもすぐにフィードバックを提供します。

00:13:34.000 -> 00:13:38.000
Xcode 14はより高速で、使いやすいです。

00:13:38.000 -> 00:13:41.000
やり方をお見せしましょう。

00:13:41.000 -> 00:13:45.000
Xcode 14を使用すると、アプリをさまざまなプラットフォームに簡単に持ち込むことができます。

00:13:45.000 -> 00:13:52.000
単一のターゲットを使用してアプリを定義し、サポートするプラットフォームを一覧表示できます。

00:13:52.000 -> 00:14:01.000
これにより、設定とファイルを同期させる必要がなくなり、各プラットフォームでユニークなものを説明するだけで済みます。

00:14:01.000 -> 00:14:09.000
プロジェクトでこの機能を利用するには、「Xcodeを使用してマルチプラットフォームアプリを構築する」をチェックしてください。

00:14:09.000 -> 00:14:13.000
Xcodeには、アプリを小さくするための優れたツールもあります。

00:14:13.000 -> 00:14:19.000
メモリデバッガは、アプリケーションのリークを探索するのに常に最適です。

00:14:19.000 -> 00:14:29.000
ルートオブジェクトから予期しないライブオブジェクトへの最短パスをゼロにするので、漏洩した理由を調査できます。

00:14:29.000 -> 00:14:37.000
Xcode 14は、これらの機能を拡張して、オブジェクトの出入りするすべての参照パスを確認できるようにします。

00:14:37.000 -> 00:14:47.000
漏れのより徹底的な説明に加えて、オブジェクトの総重量を測定できるようになりました。

00:14:47.000 -> 00:14:53.000
Xcode 14では、SwiftパッケージプラグインでXcode自体を拡張することもできます。

00:14:53.000 -> 00:15:05.000
これで、パッケージはリンターやフォーマッタなどのコードを処理するプラグインを統合でき、プロジェクトナビゲーターから直接呼び出すことができます。

00:15:05.000 -> 00:15:12.000
また、ビルド中にコードやプロセスリソースを生成するビルドツールを統合することもできます。

00:15:12.000 -> 00:15:21.000
たとえば、ビルド中にリモートプロシージャコールインターフェイスの高レベルの説明を低レベルのグルーコードに変換できます。

00:15:21.000 -> 00:15:26.000
構築中にリソースを圧縮または最適化することもできます。

00:15:26.000 -> 00:15:36.000
パッケージプラグインの詳細については、「Meet Swift Package plugins」と「Create Swift Package plugins」をチェックしてください。

00:15:36.000 -> 00:15:40.000
アプリケーションと同じようにパッケージリソースをローカライズすることもできます。

00:15:40.000 -> 00:15:50.000
これで、パッケージのデフォルトのローカリゼーションを設定し、ローカリゼーションカタログをエクスポートし、翻訳し、再インポートすることができます。

00:15:50.000 -> 00:15:58.000
ローカリゼーションの詳細については、「グローバルアプリの構築：例によるローカリゼーション」をご覧ください。

00:15:58.000 -> 00:16:03.000
次に、実行先セレクタに移りましょう。

00:16:03.000 -> 00:16:13.000
デバイス間の切り替えは私がいつもやっていることであり、更新された実行先セレクタで必要なデバイスを入手するのがさらに簡単になりました。

00:16:13.000 -> 00:16:18.000
見てみましょう。 

00:16:18.000 -> 00:16:26.000
実行先セレクタを開くと、選択したスキームで利用可能なすべての実行先が表示されます。

00:16:26.000 -> 00:16:30.000
私はよくiPhoneとiPadを切り替えます。

00:16:30.000 -> 00:16:39.000
新しい実行先セレクタは、最近の選択を優先するので、これは本当に便利です。

00:16:39.000 -> 00:16:44.000
また、最近使用していない他のデバイスを選択するのも簡単です。

00:16:44.000 -> 00:16:56.000
ここでリストをフィルタリングし、「max」と入力してすべてのMaxデバイスをまとめて、欲しいものを簡単に選ぶことができます。

00:16:56.000 -> 00:17:00.000
これらの同じ機能はすべて、スキームセレクタでも利用できます。

00:17:00.000 -> 00:17:04.000
次に、オーガナイザーウィンドウを見てみましょう。 主催者ウィンドウを見てみましょう。

00:17:04.000 -> 00:17:12.000
新しい問題を特定し、アプリを改善するために、オーガナイザーにいくつかの大きな改善を行いました。

00:17:12.000 -> 00:17:21.000
オーガナイザーには、アプリのユーザーがユーザーのデバイスでどのように機能しているかを理解するのに役立つ2つの新しいレポートがあります。フィードバックとハング。

00:17:21.000 -> 00:17:26.000
飛び込みましょう。

00:17:26.000 -> 00:17:31.000
フィードバックオーガナイザーは、すべてのTestFlightフィードバックをXcodeに直接表示します。

00:17:31.000 -> 00:17:39.000
TestFlightユーザーは、最近のビルドについて素晴らしいコメントとスクリーンショットを送信しました。

00:17:39.000 -> 00:17:49.000
検査官は、根本的な問題を特定するのに役立つ、テスター情報やデバイス構成などの追加の詳細を表示します。

00:17:49.000 -> 00:17:57.000
もう少しコンテキストが必要な場合は、このボタンでテスターに直接メールを送ることができます。

00:17:57.000 -> 00:18:05.000
TestFlightのフィードバックはベータユーザーからのものですが、テストをすり抜けてApp Storeに入れる可能性のある問題がいくつかあります。

00:18:05.000 -> 00:18:11.000
このような最も一般的なタイプのバグの1つはハングです。

00:18:11.000 -> 00:18:17.000
アプリは、ユーザー入力を処理するために休憩を取らずにメインスレッドを使用するとハングします。

00:18:17.000 -> 00:18:26.000
あなたのコードは重要な仕事をしているかもしれませんが、ユーザーは反応しないアプリを経験します。

00:18:26.000 -> 00:18:38.000
この新しいハングレポートは、App Storeユーザーから最もインパクトのあるハングを示し、どのコードを再構築して最大の影響を与えるかを知ることができます。

00:18:38.000 -> 00:18:43.000
左側には、重大度順に並べられたハングのリストがあります。

00:18:43.000 -> 00:18:49.000
それぞれに、問題のあるコードを示す加重バックトレースがあります。

00:18:49.000 -> 00:18:53.000
私たちのアプリは多くのデバイスとOSバージョンをサポートしています。

00:18:53.000 -> 00:18:57.000
いくつかのハングは、他のものよりも特定の構成に影響を与えます。

00:18:57.000 -> 00:19:05.000
検査官では、このハングが主にiOS 15.3で起こることがわかりに役立ちます。

00:19:05.000 -> 00:19:13.000
これに取り組む準備ができたら、このプロジェクトで開くボタンでコードに直接飛び込むことができます。

00:19:13.000 -> 00:19:20.000
新しいハングとフィードバックレポートは、問題をトリアージし、ユーザーに適切な修正を迅速に取得するのに役立ちます。

00:19:20.000 -> 00:19:28.000
ハングの修正の詳細については、「Xcodeとデバイス上の検出でハングアップを追跡する」をチェックしてください。

00:19:28.000 -> 00:19:33.000
次に、アイコンを見てみましょう。 

00:19:33.000 -> 00:19:46.000
私たちのアプリのアイコンは、ピクセルヒントに時間を取り、すべての解像度に適切な数のストライプを選択して、常に鮮明に見えるようにしたため、あらゆるサイズで見栄えがします。

00:19:46.000 -> 00:19:54.000
このピクセルヒントはすべて、一部のアイコンには完全に不可欠であり、他のアイコンには不要になる可能性があります。

00:19:54.000 -> 00:19:56.000
今、私たちは新しいアイコンを持っています。

00:19:56.000 -> 00:19:59.000
それを見てみましょう。 てみましょう。

00:19:59.000 -> 00:20:07.000
これらのシンプルなテクスチャはヒントを必要とせず、どんなサイズでも素晴らしく見えます。

00:20:07.000 -> 00:20:14.000
ダブルクリックで、新しい画像を選択できます。

00:20:14.000 -> 00:20:19.000
Xcode 14では、自分に合った詳細レベルを選択できます。

00:20:19.000 -> 00:20:22.000
このアイコンでは、私たちの単一の画像は素晴らしく見えます。

00:20:22.000 -> 00:20:32.000
新しいシングルサイズ機能を使用して、Xcodeにこのサイズからすべての異なるサイズを自動的に作成するように指示します。

00:20:32.000 -> 00:20:39.000
これを行うには、インスペクタでシングルサイズを選択できます。

00:20:39.000 -> 00:20:42.000
そして、それだけです!

00:20:42.000 -> 00:20:46.000
これは、Xcode 14の新機能の簡単な概要でした。

00:20:46.000 -> 00:20:49.000
あなたの開発を手伝うのはより速く、より簡単です。

00:20:49.000 -> 00:20:51.000
見てくれてありがとう!

00:20:51.000 -> 00:20:53.000
ジョナサン：ダウンロードして、今日から始めましょう！

00:20:53.000 -> 23:59:59.000
♪

