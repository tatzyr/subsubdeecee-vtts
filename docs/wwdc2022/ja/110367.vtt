WEBVTT

00:00:00.000 -> 00:00:09.000
♪ ♪

00:00:09.000 -> 00:00:13.000
アレックス：こんにちは、私の名前はアレックスで、開発者ツールに取り組んでいます。

00:00:13.000 -> 00:00:20.000
今日は、Xcode 14でサポートされている新しいC++ 20の機能についてお話ししたいと思います。

00:00:20.000 -> 00:00:30.000
C ++ 20の概念が一般的なC++コードの型安全性をどのように簡素化し、改善するかに特に焦点を当てます。

00:00:30.000 -> 00:00:37.000
コンセプトの使い方を実演し、独自のコンセプトを作成する方法も説明します。

00:00:37.000 -> 00:00:55.000
Xcodeでサポートされている他のいくつかの新しいC ++ 20機能をリストアップして講演を終了し、コンパイル時コード評価の力を通じてC ++プロジェクトのパフォーマンスを向上させるためにそれらのいくつかをどのように使用できるかについて説明します。

00:00:55.000 -> 00:01:03.000
C++の概念に飛び込む前に、まずC++でジェネリックコードを書く方法の概要を簡単に説明しましょう。

00:01:03.000 -> 00:01:08.000
数値が奇数かどうかをチェックする関数を書きたいとしましょう。

00:01:08.000 -> 00:01:16.000
私は「int」パラメータを取り込む関数を書くことができ、それは「int」型で表現できる任意の値で動作します。

00:01:16.000 -> 00:01:22.000
64ビットの符号なし整数値を渡すとどうなりますか?

00:01:22.000 -> 00:01:31.000
このような具体的な関数は、「int」タイプに収まるように切り捨てられるため、64ビット値では正しく動作しません。

00:01:31.000 -> 00:01:36.000
これを修正するには、「isOdd」を関数テンプレートにすることができます。

00:01:36.000 -> 00:01:42.000
関数テンプレートがわかったので、64ビットの符号なし整数値を渡すことができます。

00:01:42.000 -> 00:01:53.000
コンパイラは、「uint64_t」タイプで正しく動作する「isOdd」の特殊化を自動的に生成します。

00:01:53.000 -> 00:02:00.000
これは、2つの異なるタイプで動作する「isOdd」の2つのバージョンを書く必要がないことを意味するので、本当に便利です。

00:02:00.000 -> 00:02:08.000
C++テンプレートを使用して、「isOdd」などの汎用関数や汎用コンテナクラスを書くこともできます。

00:02:08.000 -> 00:02:12.000
「isOdd」の使用方法を見てみましょう。

00:02:12.000 -> 00:02:18.000
この機能は、テストファイルに追加したいくつかのテストケースでテストされます。

00:02:18.000 -> 00:02:21.000
残念ながら、私はテストの1つで間違いを犯しました。

00:02:21.000 -> 00:02:31.000
コンパイラは間違いをキャッチしましたが、私が間違いを犯した場所を指す代わりに、コンパイラは「isOdd」テンプレート内にエラーを表示します。

00:02:31.000 -> 00:02:37.000
タイプミスをして、テストで「11」ではなく「1.1」と書いたようです。

00:02:37.000 -> 00:02:44.000
そのため、コンパイラは「ダブル」型を取る「isOdd」の特殊化を生成します。

00:02:44.000 -> 00:02:55.000
残念ながら、Xcodeは「isOdd」が間違ったタイプで呼び出された特定の場所を指し示さなかったため、このタイプミスを見つけるのに時間がかかりました。

00:02:55.000 -> 00:03:00.000
言語とコンパイラは、このような間違いをより早く見つけるのに役立ちますか?

00:03:00.000 -> 00:03:09.000
さて、現在の例では、「isOdd」に許可されるタイプの要件は明示的に指定されていません。

00:03:09.000 -> 00:03:16.000
整数型を使用してisOddを呼び出す必要があるというドキュメントコメントしかありません。

00:03:16.000 -> 00:03:25.000
C ++ 20以前は、C ++プログラマーは、一般的なC ++コードを書くときにテンプレートの要件を指定する良い方法を持っていませんでした。

00:03:25.000 -> 00:03:35.000
テンプレートの要件を指定する際には、多くの場合、ドキュメントのコメント、特定のパラメータ名、または複雑なenable_ifチェックに頼らなければなりませんでした。

00:03:35.000 -> 00:03:42.000
さて、聞いたことがあるかもしれませんが、C ++ 20はコンセプトと呼ばれる新しいC ++機能を導入しています。

00:03:42.000 -> 00:03:49.000
概念を使用して、一般的なC++コードのテンプレート要件を検証できます。

00:03:49.000 -> 00:03:56.000
概念が「isOdd」に渡すことができるタイプを検証するのにどのように役立つかを見てみましょう。

00:03:56.000 -> 00:04:00.000
まず、「isOdd」の宣言に戻りましょう。

00:04:00.000 -> 00:04:09.000
現在、「class」キーワードを使用して、このテンプレートで使用されているタイプ「T」を任意のタイプに指定しています。

00:04:09.000 -> 00:04:19.000
C++ 20では、「クラス」キーワードの代わりに概念を使用して、このテンプレートで使用できるタイプのセットを制限できます。

00:04:19.000 -> 00:04:30.000
標準ライブラリが提供する「積分」の概念を使用して、この「isOdd」関数テンプレートを組み込みの整数型のみに制限できます。

00:04:30.000 -> 00:04:39.000
Tがこの概念を満たさない場合、コンパイラはこの関数テンプレートを専門化しようとさえしません。

00:04:39.000 -> 00:04:43.000
積分概念は、C++標準ライブラリで宣言されています。

00:04:43.000 -> 00:04:48.000
そのため、コードに使用するには、概念ヘッダーを含める必要があります。

00:04:48.000 -> 00:05:04.000
「isOdd」関数テンプレートのタイプ_T_に「インテグラル」要件を追加したので、コンパイラは、テストで間違いを犯した場所を直接指摘する、より明確な診断を提供することができます。

00:05:04.000 -> 00:05:11.000
「1.1」はダブルであり、したがって、「インテグラル」の概念を満たしていないことが判明しました。

00:05:11.000 -> 00:05:22.000
コンパイラは、このタイプミスを以前よりもはるかに迅速に見つけて修正するのに役立つ明確なエラーメッセージでこれを私に説明することができます。

00:05:22.000 -> 00:05:41.000
バグを修正するのを助けることに加えて、「isOdd」に渡された型を制限することは、私が持っているすべてのテストケースが「isOdd」が整数型でのみ機能し、実際にアルゴリズムの意図した動作をテストしているという安心感を与えてくれます。

00:05:41.000 -> 00:05:48.000
概念を使用して、テンプレートを使用するタイプの意図を宣言できます。

00:05:48.000 -> 00:05:55.000
コンパイラは、テンプレートが専門化される前に型要件を検証します。

00:05:55.000 -> 00:06:04.000
概念がどのように使用できるか、そしてどのコア概念がC++標準ライブラリによって提供されているかを詳しく見てみましょう。

00:06:04.000 -> 00:06:08.000
C++標準ライブラリは、概念ライブラリを提供します。

00:06:08.000 -> 00:06:16.000
型のコア動作を検証するために使用できる一連のコア言語の概念を実装しています。

00:06:16.000 -> 00:06:22.000
コードにコンセプトヘッダーを含めることで、このライブラリにアクセスできます。

00:06:22.000 -> 00:06:28.000
以前の例で「インテグラル」の概念を使用する方法をすでに示しました。

00:06:28.000 -> 00:06:33.000
さて、このライブラリが提供する他の概念を見てみましょう。

00:06:33.000 -> 00:06:42.000
このライブラリは、タイプが組み込み型の1つであるかどうかをテストする概念など、多くの有用なコア言語の概念を提供します。

00:06:42.000 -> 00:06:48.000
たとえば、「floating_point」の概念は、「float」や「double」などの組み込み型によって満たされます。

00:06:48.000 -> 00:06:54.000
ここに示されている「static_assert」は、これが実際に当てはまることを検証します。

00:06:54.000 -> 00:07:05.000
また、タイプが構築可能、破壊可能、コンバーチブル、または別のタイプと同じかどうかを確認する他の多くの有用なコアコンセプトも提供します。

00:07:05.000 -> 00:07:12.000
たとえば、「convertible_to」の概念は、型を別の型に変換できるかどうかをテストします。

00:07:12.000 -> 00:07:21.000
そして、「move_constructible」の概念は、同じ型の別の値から直接構築できる型によって満たされます。

00:07:21.000 -> 00:07:30.000
このライブラリは、タイプを他のタイプと比較できるかどうかをテストするいくつかの比較概念も提供します。

00:07:30.000 -> 00:07:42.000
たとえば、「equality_comparable」の概念は、同じ型の値で動作する有効な「==」演算子を持つ型によって満たされます。

00:07:42.000 -> 00:07:49.000
このスライドに記載されている概念に加えて、このライブラリは他の多くのコア言語の概念を提供します。

00:07:49.000 -> 00:07:54.000
また、タイプを移動またはコピーできるかどうかをテストする概念も提供します。

00:07:54.000 -> 00:08:02.000
それに加えて、型が呼び出し可能なオブジェクトであるかどうかを確認する概念も提供します。

00:08:02.000 -> 00:08:12.000
C ++標準ライブラリから提供された概念を調べたところで、概念を使用してテンプレートを制約する方法を見てみましょう。

00:08:12.000 -> 00:08:22.000
先に示したように、テンプレート内のクラスキーワードの代わりに概念を使用して、このテンプレートに許可されるタイプを制限できます。

00:08:22.000 -> 00:08:31.000
それに加えて、型を複数の概念に制限する必要がある場合は、テンプレート宣言で「必須」句を使用できます。

00:08:31.000 -> 00:08:37.000
それがどのようにできるかを見るために、少し異なる例を見てみましょう。

00:08:37.000 -> 00:08:41.000
ここに「isDefaultValue」関数テンプレートがあります。

00:08:41.000 -> 00:08:47.000
指定された値がその型のデフォルト値と等しい場合、trueを返します。

00:08:47.000 -> 00:08:56.000
標準ライブラリの2つの概念を使用して、このテンプレートが専門化される前に、このタイプがこれらの操作をサポートしていることをテストできます。

00:08:56.000 -> 00:09:03.000
この関数テンプレートで許可されているタイプのセットを制限するために、「必須」句を追加します。

00:09:03.000 -> 00:09:08.000
コンセプトライブラリのどの概念が、ここでタイプを検証するのに役立つか見てみましょう。

00:09:08.000 -> 00:09:18.000
まず、「equality_comparable」の概念は、_T_を同じタイプの別の値と比較できるかどうかをテストします。

00:09:18.000 -> 00:09:26.000
次に、「default_constructible」の概念は、_T_がデフォルトのコンストラクタを持つ型であるかどうかをテストします。

00:09:26.000 -> 00:09:32.000
それらの間の論理演算子と演算子は、両方の概念を検証するようにコンパイラに指示します。

00:09:32.000 -> 00:09:39.000
これにより、この関数テンプレートはサポートされているタイプでのみ特殊になります。

00:09:39.000 -> 00:09:43.000
概念についてこれまでに学んだことを見てみましょう。

00:09:43.000 -> 00:09:48.000
コンセプトを使用して、テンプレートで使用できるタイプを制限する必要があります。

00:09:48.000 -> 00:09:57.000
コンパイラは、型の不一致が発生した場合にテンプレートを専門化する必要がないため、より明確な診断を表示できるようになります。

00:09:57.000 -> 00:10:05.000
型のコア動作を検証する必要がある場合は、概念ライブラリの概念を再利用する必要があります。

00:10:05.000 -> 00:10:12.000
タイプが複数の要件に準拠しているかどうかをテストする必要がある場合は、テンプレートに「必須」句を追加する必要があります。

00:10:12.000 -> 00:10:17.000
私たちは今、C++プログラムで概念を使用する方法を見てきました。

00:10:17.000 -> 00:10:24.000
C++を使用すると、型の特定の動作を検証するカスタム概念を宣言できます。

00:10:24.000 -> 00:10:31.000
特定のタイプの動作を検証する独自の概念を作成する方法を見てみましょう。

00:10:31.000 -> 00:10:41.000
しかし、その前に、宣言したい概念によって検証されなければならない行動要件を特定する方法を検討する必要があります。

00:10:41.000 -> 00:10:49.000
概念を使用して特定のタイプの動作を検証する方法を説明するために、新しい例を使用します。

00:10:49.000 -> 00:10:57.000
さまざまな2次元形状を画像にレンダリングできるC++ライブラリを構築しているとします。

00:10:57.000 -> 00:11:00.000
ライブラリでさまざまな図形をサポートしたいです。

00:11:00.000 -> 00:11:05.000
レンダリングするのが最も簡単なので、私は円の形から始めています。

00:11:05.000 -> 00:11:12.000
C++クラスを使用して、位置や半径などのプロパティを保存します。

00:11:12.000 -> 00:11:23.000
円をレンダリングするには、レンダリングされた画像の各ピクセルで実行される距離関数ベースのレンダリングアルゴリズムを使用します。

00:11:23.000 -> 00:11:30.000
このアルゴリズムは、それをレンダリングするために図形の表面までの距離を計算する必要があります。

00:11:30.000 -> 00:11:34.000
Circleクラスの「getDistanceFrom」メソッドがそれを計算します。

00:11:34.000 -> 00:11:42.000
円の内側の負の距離と、円の外側の正の距離を返します。

00:11:42.000 -> 00:11:45.000
円に加えて、他の図形をレンダリングしたいと思います。

00:11:45.000 -> 00:11:55.000
たとえば、別の円の形から1つの円の形を幾何学的に減算することで、三日月の形もレンダリングできます。

00:11:55.000 -> 00:12:00.000
私もクラスを使ってレンダリングしたいクレセントのような図形を表現します。

00:12:00.000 -> 00:12:06.000
各新しいシェイプクラスには、「getDistanceFrom」メソッドが含まれています。

00:12:06.000 -> 00:12:15.000
いくつかの図形クラスを作成した後、これらの図形をレンダリングして実装を検証したいと思います。

00:12:15.000 -> 00:12:21.000
任意の形状で動作するレンダリング機能を作成する方法について、いくつかのオプションがあります。

00:12:21.000 -> 00:12:29.000
図形のクラス階層を作成し、仮想メソッドを使用して図形の表面までの距離を計算できます。

00:12:29.000 -> 00:12:43.000
ただし、この関数はレンダリング中に数百万回呼び出されるため、仮想コールのオーバーヘッドを避けたいので、パフォーマンス上の理由から代わりに関数テンプレートを使用します。

00:12:43.000 -> 00:12:47.000
これが私がこのレンダリング関数テンプレートを作成した理由です。

00:12:47.000 -> 00:12:55.000
computePixelColor関数は、図形の値を取り込み、指定されたピクセルが図形の内側にあるかどうかをチェックします。

00:12:55.000 -> 00:12:59.000
中にある場合は、無地の白色を返します。

00:12:59.000 -> 00:13:05.000
これにより、図形を正しく入力できることを確認できるようになりました。

00:13:05.000 -> 00:13:14.000
この関数はテンプレートであり、円、三日月、またはその他の一致するタイプなど、任意の形状タイプで動作します。

00:13:14.000 -> 00:13:22.000
テンプレートはここでうまく機能しますが、概念を使用して、この関数に渡すことができる型を制限したいと思います。

00:13:22.000 -> 00:13:32.000
この関数に渡された型を制限することで、型の不一致が発生したときにコンパイラはより明確な診断を生成できます。

00:13:32.000 -> 00:13:41.000
それに加えて、この関数に渡されたタイプを制限することで、この関数のオーバーロードを追加することもできます。

00:13:41.000 -> 00:13:46.000
タイプを制約するために、シェイプのコンセプトを作成します。

00:13:46.000 -> 00:13:57.000
この概念は、タイプの動作を検証し、円、三日月、および将来追加したいかもしれない他の形状クラスのようなクラスを受け入れます。

00:13:57.000 -> 00:14:04.000
「シェイプ」のような概念を作成するには、まずこの概念によって検証する必要がある要件を特定する必要があります。

00:14:04.000 -> 00:14:07.000
これがどのようにできるか見てみましょう。 

00:14:07.000 -> 00:14:11.000
この関数テンプレートは、ジェネリック型として型「T」を使用します。

00:14:11.000 -> 00:14:16.000
次に、タイプ「T」の「shape」という名前の引数がこの関数に渡されます。

00:14:16.000 -> 00:14:24.000
「shape」引数は、関数内で「getDistanceFrom」メソッドを呼び出すと使用されます。

00:14:24.000 -> 00:14:35.000
ご覧のとおり、この関数では形状に対して他の操作が実行されていないため、これは私のコンセプトで検証したい唯一の要件です。

00:14:35.000 -> 00:14:41.000
「Requires」式を使用して、型が特定の方法で動作するかどうかをテストできます。

00:14:41.000 -> 00:14:46.000
「requires」を使用してShapeコンセプトを作成する方法を見てみましょう。

00:14:46.000 -> 00:14:53.000
「Requires」内の型の動作をテストする一連の表現を提供する必要があります。

00:14:53.000 -> 00:15:03.000
私はすでにテストする必要がある単一の要件として「getDistanceFrom」への呼び出しを特定したので、今、私は先に進んで「シェイプ」の概念を作成することができます。

00:15:03.000 -> 00:15:07.000
「コンセプト」キーワードを使用して形状の概念を宣言しました。

00:15:07.000 -> 00:15:13.000
次に、タイプを検証するために、この概念に「必須」式を追加しました。

00:15:13.000 -> 00:15:17.000
「Requires」式に引数リストを追加しました。

00:15:17.000 -> 00:15:26.000
この引数リストでは、タイプ「T」の値「形状」を宣言し、「必須」内でテストします。

00:15:26.000 -> 00:15:31.000
Requires式で引数リストを使用して、任意のタイプの値を宣言できます。

00:15:31.000 -> 00:15:36.000
その後、これらの値を要件内で使用できるようになります。

00:15:36.000 -> 00:15:44.000
「Requires」式の本文には、この概念を満たすために合格しなければならない一連の要件が含まれています。

00:15:44.000 -> 00:15:53.000
「shape」の概念には、「getDistanceFrom」へのメソッド呼び出しが有効かどうかを確認する単純な式要件が1つだけあります。

00:15:53.000 -> 00:15:58.000
この式は実際にはプログラムで実行されません。

00:15:58.000 -> 00:16:06.000
型の動作を検証するためにコンパイル時にのみ必要であり、検証後に破棄されます。

00:16:06.000 -> 00:16:15.000
式の要件を使用して、特定の式がコンパイルされるかどうかをテストすることで、型の動作を検証できます。

00:16:15.000 -> 00:16:23.000
ただし、「getDistanceFrom」メソッド呼び出しの引数が欠落しているため、この特定の式はまだ完全ではありません。

00:16:23.000 -> 00:16:33.000
このメソッドに「float」型の2つの値を取りたいので、2つの浮動小数点リテラルを使用してこの式を完成させることができます。

00:16:33.000 -> 00:16:45.000
「getDistanceFrom」メソッドが浮動小数点値を返すことをテストするために追加のチェックを追加します。

00:16:45.000 -> 00:16:53.000
私は現在、タイプに「getDistanceFrom」メソッドがあるかどうかをテストするために、単純な式要件を使用しています。

00:16:53.000 -> 00:17:01.000
ただし、式要件の代わりに複合要件を使用して、浮動小数点数の値を返すことをテストできます。

00:17:01.000 -> 00:17:05.000
矢印演算子は複合要件に従うことができます。

00:17:05.000 -> 00:17:19.000
矢印演算子は右側に制約を期待しているので、「same_as」のような標準ライブラリの概念を使用して、「getDistanceFrom」メソッドの呼び出しが浮動小数点数値を返すことを検証できます。

00:17:19.000 -> 00:17:23.000
今、このコンセプトは私には準備ができているように見えます。

00:17:23.000 -> 00:17:30.000
先に進んで、それを使って「computePixelColor」関数に渡すことができるタイプを制約することができます。

00:17:30.000 -> 00:17:38.000
これで、私の一般的な「computePixelColor」関数は、「Shape」の概念を満たすタイプでのみ動作します。

00:17:38.000 -> 00:17:52.000
これは、CircleやCrescentなどのクラスは、これらのタイプの両方が「Shape」の概念を満たすため、この特定の一般的な「computePixelColor」関数を使用してレンダリングされることを意味します。

00:17:52.000 -> 00:18:01.000
無地の図形がレンダリングされたのを見た後、私の図形のいくつかに色を追加する「computePixelColor」の別のバージョンを作成したいと思います。

00:18:01.000 -> 00:18:07.000
シェイプライブラリにカラフルなGradientCircleクラスを追加したいとしましょう。

00:18:07.000 -> 00:18:13.000
今、画像内のピクセルカラーを計算するための新しい機能が必要です。

00:18:13.000 -> 00:18:20.000
C++ 20では、「computePixelColor」関数テンプレートの複数のバリアントを作成できます。

00:18:20.000 -> 00:18:24.000
各バリアントは、異なる概念を使用して制約する必要があります。

00:18:24.000 -> 00:18:31.000
GradientCircleのようなクラスで満足する新しいGradientShapeコンセプトを作成します。

00:18:31.000 -> 00:18:40.000
この概念は、グラデーションを持つ図形でのみ機能する「computePixelColor」の新しいバリアントを制限します。

00:18:40.000 -> 00:18:46.000
この概念は、シェイプの概念と同様に、「必須」式を使用して実装されています。

00:18:46.000 -> 00:18:56.000
しかし、GradientShapeも元のShapeコンセプトを満たしたいので、新しいコンセプトの最初の要件としてそれを含めます。

00:18:56.000 -> 00:19:10.000
これにより、GradientShapeの概念を満たすクラスがShapeの概念も満たすことができます。つまり、そのようなクラスの値に対して「getDistanceFrom」メソッドを呼び出すことができます。

00:19:10.000 -> 00:19:23.000
次に、論理式と演算子と「必須」式を使用して、GradientShapeの概念が「getGradientColor」メソッドを持つクラスによってのみ満たされるようにします。

00:19:23.000 -> 00:19:31.000
GradientShapeコンセプトを作成したので、「computePixelColor」の新しいバリアントを作成できます。

00:19:31.000 -> 00:19:42.000
この関数テンプレートは、GradientShapeの概念によって制約されるため、GradientCircleクラスのようなグラデーションを持つ図形クラスでのみ機能します。

00:19:42.000 -> 00:19:49.000
すべてのピースが整ったので、グラデーションで円をレンダリングしてみることができます。

00:19:49.000 -> 00:19:52.000
ここでは、GradientCircleをレンダリングしています。

00:19:52.000 -> 00:20:00.000
コンパイラが「render」関数内でどの「computePixelColor」のオーバーロードを選択するか見てみましょう。

00:20:00.000 -> 00:20:15.000
GradientCircleはcomputePixelColorの両方のバリアントで安全に使用できますが、コンパイラは最初のオーバーロードよりも特異的であるため、GradientShapeの概念で制約されたオーバーロードを選択します。

00:20:15.000 -> 00:20:24.000
コンパイラは「computePixelColor」の最も一致するオーバーロードを選択するため、ライブラリをテストすると、この美しいグラデーション円がレンダリングされるのを見ることができます。

00:20:24.000 -> 00:20:26.000
すごい！

00:20:26.000 -> 00:20:32.000
それでは、コンセプトの作成について学んだことを確認しましょう。

00:20:32.000 -> 00:20:40.000
既存のジェネリックコードの行動要件を特定することで、概念を作成できます。

00:20:40.000 -> 00:20:46.000
型の動作を検証するための概念を作成するには、requires式を使用する必要があります。

00:20:46.000 -> 00:20:55.000
また、概念を使用して、汎用関数やクラスのより具体的なバリアントを作成することもできます。

00:20:55.000 -> 00:21:00.000
私たちは今、概念であなたの一般的なC++コードを強化する方法を見ました。

00:21:00.000 -> 00:21:09.000
サポートコンセプトに加えて、Xcode 14は他のC++20機能のサポートも改善しました。

00:21:09.000 -> 00:21:19.000
具体的には、Xcode 14でのコンパイル時のC++コード評価の改善されたサポートを強調したいと思います。

00:21:19.000 -> 00:21:28.000
コンパイル時間コードの評価は、C ++コードの変数の初期化コストを削減できるため便利です。

00:21:28.000 -> 00:21:38.000
これは、アプリに複雑な初期化シーケンスに依存する多くのC ++コードがある場合、アプリの起動時間を短縮するのに役立ちます。

00:21:38.000 -> 00:21:47.000
それに加えて、コンパイル時コードの評価は、コンパイル時に検証が必要な定数を検証するのに役立ちます。

00:21:47.000 -> 00:21:52.000
これは、コードが実行される前にバグをキャッチするのに役立ちます。

00:21:52.000 -> 00:21:59.000
C++でコンパイル時コード評価を使用する方法を示す例を見てみましょう。

00:21:59.000 -> 00:22:05.000
ここには、シェイプレンダリングライブラリでカラーパレットを初期化するコードのスニペットがあります。

00:22:05.000 -> 00:22:11.000
このライブラリは、図形をディスプレイにレンダリングするiOSアプリで使用されます。

00:22:11.000 -> 00:22:18.000
パレットの各色は、色のHTML 16進コードで文字列リテラルを解析することによって初期化されます。

00:22:18.000 -> 00:22:26.000
現在、「fromHexCode」関数は、配列の初期化中に3つの文字列リテラルを解析する必要があります。

00:22:26.000 -> 00:22:36.000
このような複雑な定数初期化操作は、アプリの起動時間がたくさんある場合、アプリの起動時間に測定可能な影響を与える可能性があります。

00:22:36.000 -> 00:22:44.000
コンパイル時のコード評価を使用して、この配列が代わりに一定の色値で初期化されていることを確認できます。

00:22:44.000 -> 00:22:47.000
これができることをお見せしましょう。

00:22:47.000 -> 00:22:53.000
「constexpr」キーワードは、C++でコンパイル時のコード評価を可能にします。

00:22:53.000 -> 00:23:02.000
パレットが一定の色の配列であることを確認するために、私の例のいくつかの場所にそれを追加する必要があります。

00:23:02.000 -> 00:23:07.000
まず、「fromHexCode」関数に「constexpr」キーワードを追加する必要があります。

00:23:07.000 -> 00:23:16.000
コンパイラは、コンパイル時の初期化シーケンスで使用されるコンパイル時にこの関数のコードを実行できるようになります。

00:23:16.000 -> 00:23:23.000
コンパイル時に評価可能にしたい場合は、C++関数を「constexpr」にする必要があります。

00:23:23.000 -> 00:23:34.000
コンパイラは、「constexpr」初期化シーケンスで使用するときにエラーを表示することで、コンパイル時にそのような関数のコードを評価できない場合に知らせます。

00:23:34.000 -> 00:23:42.000
ただし、「constexpr」を追加する前に関数を調べて、コンパイル時に評価できるかどうかを確認することもできます。

00:23:42.000 -> 00:23:51.000
fromHexCodeを覗いて、このような関数がコンパイル時コード評価の良い候補になるかどうかを確認する方法を見てみましょう。

00:23:51.000 -> 00:24:02.000
この関数は、if文のような多くの言語構造と、比較演算子や算術演算子のようなプリミティブ演算を使用します。

00:24:02.000 -> 00:24:07.000
これらの操作はすべて、コンパイル時に評価できます。

00:24:07.000 -> 00:24:13.000
また、この関数は別の関数にいくつかの呼び出しを行います。hexToInt。

00:24:13.000 -> 00:24:22.000
私はすでに「constexpr」でhexToInt関数に注釈を付けているので、この関数の呼び出しはコンパイル時に評価できます。

00:24:22.000 -> 00:24:34.000
全体として、fromHexCodeには、コンパイラがコンパイル時に評価できるコードが含まれているように見えるので、コンパイル時の初期化シーケンスで続行して使用しても安全だと思います。

00:24:34.000 -> 00:24:45.000
コンパイル時にfromHexCodeを評価できることを確認した後、「colorPalette」変数宣言に「constexpr」キーワードを追加する必要があります。

00:24:45.000 -> 00:24:54.000
コンパイラは、コンパイル時にこの配列の初期化シーケンス全体を評価することを保証します。

00:24:54.000 -> 00:25:01.000
具体的には、コンパイラはfromHexCode関数への各呼び出しを評価します。

00:25:01.000 -> 00:25:09.000
評価は、パレットの初期化子の関数への元の呼び出しを置き換える一定の色値を生成します。

00:25:09.000 -> 00:25:24.000
fromHexCodeへのすべての呼び出しが定数色値に置き換えられるようになったため、「colorPalette」変数は、定数色値を含む配列リテラルによって初期化されることが保証されるようになりました。

00:25:24.000 -> 00:25:33.000
これは、このパレットが初期化されたときに、私のアプリが色の値を解析するための追加費用を支払う必要がないことを意味します。

00:25:33.000 -> 00:25:43.000
これは、アプリ内のこのC ++ライブラリが起動時に行わなければならない作業量を減らすので、私のアプリの起動時間に最適です。

00:25:43.000 -> 00:25:51.000
定数値で初期化されるようにする場合は、C++変数を「constexpr」にする必要があります。

00:25:51.000 -> 00:25:59.000
Xcode 14は、実際にコンパイル時評価のための標準ライブラリのサポートを大幅に改善しました。

00:25:59.000 -> 00:26:10.000
今年は、コンパイル時のコード評価中に使用できる、いくつかの異なる標準ライブラリタイプとアルゴリズムに「constexpr」サポートを追加しました。

00:26:10.000 -> 00:26:17.000
それに加えて、Xcode 14はC++20の標準サポートを大幅に改善しました。

00:26:17.000 -> 00:26:23.000
ここに示されているすべての機能は、C++ 20モードで使用できるようになりました。

00:26:23.000 -> 00:26:29.000
まだ切り替えていない場合は、今日C++ 20モードに切り替える必要があります。

00:26:29.000 -> 00:26:37.000
Xcodeプロジェクトの「C++言語方言」設定を使用して、C++ 20にアップグレードできます。

00:26:37.000 -> 00:26:43.000
C++20に切り替えると、コードで概念などの機能を使用できます。

00:26:43.000 -> 00:26:53.000
C++ 20は最低展開ターゲットを必要としないため、現在ターゲットとしているのと同じOSバージョンのコードを出荷できます。

00:26:53.000 -> 00:26:56.000
今日C++20を試してみてください。

00:26:56.000 -> 00:26:57.000
ありがとう！

00:26:57.000 -> 23:59:59.000
開発者会議の残りの部分をお楽しみください。

