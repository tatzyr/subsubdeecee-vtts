WEBVTT

00:00:00.000 --> 00:00:09.000
♪インストゥルメンタルヒップホップ音楽♪

00:00:09.000 --> 00:00:14.000
ようこそ、皆さん。私の名前はデビッド・ヘイワードで、コアイメージチームのソフトウェアエンジニアです。

00:00:14.000 --> 00:00:20.000
今日は、Core Imageアプリケーションで拡張ダイナミックレンジのコンテンツを表示する方法について説明します。

00:00:20.000 --> 00:00:23.000
私の話は4つの部分に分かれます。

00:00:23.000 --> 00:00:29.000
まず、私たちのプラットフォームでEDRの重要な用語をいくつか紹介します。

00:00:29.000 --> 00:00:38.000
次に、新しいCore Imageサンプルプロジェクトについて説明します。その後、EDRのサポートを追加する方法を実演します。

00:00:38.000 --> 00:00:47.000
最後に、CIFiltersを使用してEDRコンテンツを生成する画像を作成する方法を紹介します。

00:00:47.000 --> 00:00:50.000
では、いくつかの重要な用語から始めましょう。

00:00:50.000 --> 00:01:00.000
SDR、または標準ダイナミックレンジは、黒の0から白の1の正規化された範囲を使用してRGB色を表す伝統的な方法です。

00:01:00.000 --> 00:01:09.000
対照的に、EDRまたは拡張ダイナミックレンジは、正常範囲を超えてRGB色を表す推奨される方法です。

00:01:09.000 --> 00:01:16.000
SDRと同様に、0は黒を表し、1はSDR白と同じ明るさを表します。

00:01:16.000 --> 00:01:22.000
しかし、EDRでは、1より大きい値を使用して、さらに明るいピクセルを表すことができます。

00:01:22.000 --> 00:01:30.000
しかし、1より大きい値は許可されていますが、ヘッドルームの上の値は切り取られることを覚えておいてください。

00:01:30.000 --> 00:01:37.000
ヘッドルームは、ディスプレイの現在の最大ニットをSDRホワイトのニットで割った値から派生します。

00:01:37.000 --> 00:01:44.000
ヘッドルームの値は、ディスプレイ間、または周囲の条件やディスプレイの明るさの変化に応じて変化する可能性があることに注意してください。

00:01:44.000 --> 00:01:52.000
これらの概念をより深く議論するために、「iOSでEDRを探索する」プレゼンテーションを見ることをお勧めします。

00:01:52.000 --> 00:01:57.000
アプリケーションに提示できるEDRコンテンツのソースはいくつかあります。

00:01:57.000 --> 00:02:05.000
まず、TIFFやOpenEXRなどの一部のファイル形式は、EDRの浮動小数点値を保存できます。

00:02:05.000 --> 00:02:12.000
また、AVFoundationを使用して、HDRビデオフォーマットからフレームを取得することもできます。

00:02:12.000 --> 00:02:17.000
Metal APIは、EDR環境をテクスチャにレンダリングするために使用できます。

00:02:17.000 --> 00:02:23.000
また、ProRAW DNGファイルをレンダリングしてEDRのハイライトを表示することもできます。

00:02:23.000 --> 00:02:30.000
2021年のプレゼンテーション「ProRAW画像をキャプチャして処理する」では、これを詳細に説明しています。

00:02:30.000 --> 00:02:38.000
プレゼンテーションの次の部分では、SwiftUIアプリケーションでMetalでCore Imageを使用する方法について説明します。

00:02:38.000 --> 00:02:43.000
後で、このアプリケーションにEDRサポートを追加する方法を概説します。

00:02:43.000 --> 00:02:54.000
私たちは最近、SwiftUIマルチプラットフォームアプリでCore ImageとMetal Kit Viewを組み合わせる方法のベストプラクティスを示す新しいサンプルコードプロジェクトをリリースしました。

00:02:54.000 --> 00:03:01.000
サンプルをダウンロードしてコードを見ることをお勧めしますが、この機会にそれがどのように見え、どのように機能するかをお見せしましょう。

00:03:01.000 --> 00:03:08.000
サンプルは、メタルビューに表示されるアニメーション化された手続き型CIImageを描画します。

00:03:08.000 --> 00:03:12.000
最適なパフォーマンスを得るには、サンプルはMTKViewを使用します。

00:03:12.000 --> 00:03:22.000
コードをシンプルに保つために、アプリはアニメーションチェッカーボードCIImageをアプリが望むコンテンツのプロキシとして表示します。

00:03:22.000 --> 00:03:32.000
また、このアプリはSwiftUIを使用しているため、macOS、iOS、iPadOSプラットフォームで共通のコードベースを使用できます。

00:03:32.000 --> 00:03:39.000
このプロジェクトはいくつかの短いソースファイルから構築されているので、クラスがどのように相互作用するかを説明しましょう。

00:03:39.000 --> 00:03:42.000
このアプリケーションには3つの重要な部分があります。

00:03:42.000 --> 00:03:45.000
最初で最も重要なのは「MetalView」です。

00:03:45.000 --> 00:03:53.000
MTKViewクラスをラップするSwiftUI互換のView実装を提供します。

00:03:53.000 --> 00:04:09.000
MTKViewクラスはmacOSのNSViewと他のプラットフォームのUIViewに基づいているため、MetalViewの実装ではViewRepresentableを使用してSwiswisUIとプラットフォーム固有のMTKViewクラスをブリッジします。

00:04:09.000 --> 00:04:14.000
ただし、MTKViewはレンダリングに直接責任を負いません。

00:04:14.000 --> 00:04:18.000
代わりに、そのデリゲートを使用してその作業を行います。

00:04:18.000 --> 00:04:23.000
このアプリでは、RendererクラスはMTKViewのデリゲートです。

00:04:23.000 --> 00:04:30.000
MetalコマンドキューやCore Imageコンテキストなどのグラフィック状態オブジェクトの初期化を担当します。

00:04:30.000 --> 00:04:37.000
また、MetalViewデリゲートであるために必要なdraw()メソッドも実装しています。

00:04:37.000 --> 00:04:43.000
ただし、レンダラーは、どの画像を描くかを決定する直接的な責任を負いません。

00:04:43.000 --> 00:04:49.000
代わりに、imageProviderブロックを使用してCIImageを描画します。

00:04:49.000 --> 00:04:58.000
このアプリでは、ContentViewクラスは、レンダリングするCIImageを提供するコードブロックを実装します。

00:04:58.000 --> 00:05:03.000
簡単に要約すると、MetalViewはデリゲートに描画を呼び出します。

00:05:03.000 --> 00:05:09.000
Renderer draw() メソッドは、描画する画像を提供するために ContentView を呼び出します。

00:05:09.000 --> 00:05:17.000
MetalViewクラスのmakeView()コードから始めて、これら3つのクラスのコードについてもう少し詳しく説明しましょう。

00:05:17.000 --> 00:05:24.000
makeView() が MTKView を作成するために呼び出されると、ビューのデリゲートをレンダラー状態オブジェクトに設定します。

00:05:24.000 --> 00:05:31.000
これは、NSViewまたはUIViewをラップするSwiftUIビューを実装するための標準的なアプローチです。

00:05:31.000 --> 00:05:37.000
次に、viewをレンダリングする頻度を指定するためにpreferredFramesPerSecondを設定します。

00:05:37.000 --> 00:05:42.000
このプロパティは、ビューの描画を駆動するものを決定するため、重要です。

00:05:42.000 --> 00:05:45.000
これがどのように機能するかを説明しましょう。

00:05:45.000 --> 00:05:53.000
このサンプルはアニメーション化されたアプリケーションなので、コードはview.preferredFramesPerSecondを目的のフレームレートに設定します。

00:05:53.000 --> 00:06:00.000
これを設定すると、MTKViewは、ビュー自体が描画イベントのタイミングを駆動するように設定されます。

00:06:00.000 --> 00:06:11.000
これにより、ビューのレンダリングデリゲートは定期的にdraw（）し、コンテンツプロバイダーに現在のCIImageを作成するように要求します。

00:06:11.000 --> 00:06:18.000
そして、アニメーションが一時停止されるまで、プロセスは繰り返されます。

00:06:18.000 --> 00:06:27.000
画像編集アプリなどの他のケースでは、ビューを描画する必要があるときに駆動するコントロールとのユーザーインタラクションに最適です。

00:06:27.000 --> 00:06:36.000
enableSetNeedsDisplayをtrueに設定すると、MTKViewはコントロールが描画イベントのタイミングを駆動できるように設定されます。

00:06:36.000 --> 00:06:41.000
コントロールが移動されると、updateView()メソッドを呼び出す必要があります。

00:06:41.000 --> 00:06:46.000
その後、ビューのデリゲートは一度draw()に呼び出されます。

00:06:46.000 --> 00:06:55.000
そして、各ドローは、現在の制御状態のCIImageを作成するようにコンテンツプロバイダーに依頼します。

00:06:55.000 --> 00:07:02.000
このアプローチは、ビデオのフレームの到着がドローイベントを駆動する場合にも適切です。

00:07:02.000 --> 00:07:05.000
それで、MetalViewクラスについての私の議論を締めくくります。

00:07:05.000 --> 00:07:12.000
次に、レンダラーデリゲートで最も重要なコードはdraw()メソッドです。

00:07:12.000 --> 00:07:16.000
レンダラーのdraw()メソッドは、定期的なフレームレートで呼び出されます。

00:07:16.000 --> 00:07:23.000
Draw() メソッドが呼び出されると、ビューがオンになっているディスプレイの解像度を反映するコンテンツスケールファクターを決定する必要があります。

00:07:23.000 --> 00:07:28.000
CIImagesはポイントではなくピクセルで測定されるため、これは必要です。

00:07:28.000 --> 00:07:38.000
ビューを別のディスプレイに移動すると、このプロパティが変更される可能性があるため、draw()メソッドが呼び出されるたびにこれを行うことが重要です。

00:07:38.000 --> 00:07:43.000
次に、mtlTextureProviderでCIRenderDestinationを作成します。

00:07:43.000 --> 00:07:49.000
次に、コンテンツプロバイダーを呼び出して、現在の時間とスケールファクターに使用するCIImageを作ります。

00:07:49.000 --> 00:08:02.000
この返された画像は、ビューの可視領域の中央に配置され、不透明な背景にブレンドされ、CIImageをビューの宛先にレンダリングするタスクを開始します。

00:08:02.000 --> 00:08:07.000
ContentView クラスで最も重要なコードは init() メソッドです。

00:08:07.000 --> 00:08:12.000
Init() メソッドは、コンテンツ ビューの本文を作成する責任があります。

00:08:12.000 --> 00:08:17.000
これを行うと、RendererとMetalViewクラスへの接続が確立されます。

00:08:17.000 --> 00:08:23.000
まず、イメージプロバイダーブロックを持つレンダラーオブジェクトを作成します。

00:08:23.000 --> 00:08:30.000
そのブロックは、要求された時間とスケールのCIImageを返す責任があります。

00:08:30.000 --> 00:08:37.000
そして最後に、ContentViewの本体を、そのレンダラーを使用するMetalViewに設定します。

00:08:37.000 --> 00:08:44.000
さて、これで完了です。Core Imageを使用してレンダリングできるシンプルなSwiftUIアプリがあります。

00:08:44.000 --> 00:08:50.000
次に、EDRヘッドルームでレンダリングをサポートするためにこのアプリを変更する方法を見てみましょう。

00:08:50.000 --> 00:08:54.000
このアプリケーションにEDRサポートを追加するのは本当に簡単です。

00:08:54.000 --> 00:09:06.000
ステップ1はEDRのビューを初期化し、ステップ2はすべてのレンダリングの前にヘッドルームを計算し、ステップ3は利用可能なヘッドルームを使用するCIImageを構築することです。

00:09:06.000 --> 00:09:10.000
これらの追加のための実際のコードをお見せしましょう。

00:09:10.000 --> 00:09:14.000
まず、MetalViewクラスで1つの小さな追加が必要です。

00:09:14.000 --> 00:09:29.000
ビューを作成するときは、拡張DynamicRangeContent が必要なレイヤーに伝え、その pixelFormat は .rgba16Float で、色空間は拡張され、線形である必要があることをビューに伝える必要があります。

00:09:29.000 --> 00:09:35.000
第二に、Rendererクラスのdraw()メソッドにいくつかの変更が必要です。

00:09:35.000 --> 00:09:45.000
Draw() メソッドでは、ビューの現在の画面を取得し、現在のEDRヘッドルームを画面に要求するコードを追加する必要があります。

00:09:45.000 --> 00:09:49.000
その後、ヘッドルームはパラメータとしてイメージプロバイダーブロックに渡されます。

00:09:49.000 --> 00:09:54.000
Draw() メソッドが呼び出されるたびにこれを行うことが重要であることに注意してください。

00:09:54.000 --> 00:10:01.000
ヘッドルームは、周囲の条件やディスプレイの明るさがどのように変化するかによって変化する動的特性です。

00:10:01.000 --> 00:10:06.000
そして3番目の変更は、ContentViewクラスのプロバイダブロックです。

00:10:06.000 --> 00:10:10.000
ここでは、イメージプロバイダーブロック宣言にヘッドルーム引数を追加する必要があります。

00:10:10.000 --> 00:10:19.000
その後、CIFiltersでヘッドルームを使用して、ユーザーのEDRディスプレイで素晴らしく見えるCIImageを返すことができます。

00:10:19.000 --> 00:10:34.000
要約すると、これらはこのアプリケーションにEDRサポートを追加するための3つの簡単なステップでした。EDRのビューを初期化し、すべてのレンダリングの前にヘッドルームを決定し、ヘッドルームを考慮して表示するCIImageを構築します。

00:10:34.000 --> 00:10:37.000
これがこのプレゼンテーションの残りの部分のトピックになります。

00:10:37.000 --> 00:10:46.000
アプリがEDRをサポートしたので、CIImagesを作成するためにCIFiltersを使用していくつかのEDRコンテンツを表示させましょう。

00:10:46.000 --> 00:10:50.000
Core Imageに組み込まれた150以上のフィルターがEDRをサポートしています。

00:10:50.000 --> 00:10:59.000
これは、これらすべてのフィルタがEDRコンテンツを含む画像を生成するか、EDRコンテンツを含む画像を処理できることを意味します。

00:10:59.000 --> 00:11:12.000
たとえば、CIColorControlsとCIExposureAdjustフィルターを使用すると、アプリがEDRカラーで画像の明るさ、色相、彩度、コントラストを変更できます。

00:11:12.000 --> 00:11:19.000
また、グラデーションフィルターなどのいくつかのフィルターは、EDRカラーパラメータを指定して画像を生成できます。

00:11:19.000 --> 00:11:23.000
今年追加した3つの新しいフィルターは、EDR画像もサポートしています。

00:11:23.000 --> 00:11:31.000
最も注目すべきは、CIAreaLogarithmicHistogramは、任意の範囲の明るさ値のヒストグラムを生成することができます。

00:11:31.000 --> 00:11:40.000
CIColorCubeフィルターは、EDR入力画像でよりよく機能するように今年更新したフィルターの例です。

00:11:40.000 --> 00:11:51.000
これらの組み込みフィルタはすべて、Core Imageの作業色空間がクランプされておらず線形であるため、0から1の範囲外のRGB値を可能にするため、機能します。

00:11:51.000 --> 00:11:57.000
アプリを開発する際に、特定のフィルターがEDRをサポートしているかどうかを確認できます。

00:11:57.000 --> 00:12:09.000
これを行うには、フィルタのインスタンスを作成し、フィルタの属性にそのカテゴリを尋ね、配列にkCICategoryHighDynamicRangeが含まれているかどうかを確認します。

00:12:09.000 --> 00:12:16.000
また、私たちが追加した新機能は、CIFilter変数のXcode QuickLookデバッグサポートです。

00:12:16.000 --> 00:12:25.000
これにより、各入力パラメータのカテゴリと要件を含む、各フィルタークラスのドキュメントが表示されます。

00:12:25.000 --> 00:12:32.000
これらすべてのEDRフィルターを考えると、アプリがコンテンツに適用できるさまざまな効果があります。

00:12:32.000 --> 00:12:42.000
今日説明する例では、サンプルアプリからチェッカーボードパターンに明るい鏡面反射を伴う波及効果を追加します。

00:12:42.000 --> 00:12:48.000
この効果を作成するには、rippleTransitionフィルタのインスタンスが必要です。

00:12:48.000 --> 00:12:54.000
次に、入力画像とターゲット画像の両方をチェッカー画像に設定します。

00:12:54.000 --> 00:13:02.000
次に、リップルの中心と遷移時間を制御するフィルタ入力を設定します。

00:13:02.000 --> 00:13:09.000
そして、shadingImageをリップルに鏡面ハイライトを生成するグラデーションに設定します。

00:13:09.000 --> 00:13:15.000
そして最後に、設定したすべてのフィルタ入力が与えられた出力画像のフィルタを求めます。

00:13:15.000 --> 00:13:24.000
また、リップル効果の鏡面ハイライトを作成するために使用されるシェーディングイメージを作成する方法も説明しましょう。

00:13:24.000 --> 00:13:33.000
ビットマップデータからこのイメージを作成できますが、さらに優れたパフォーマンスを得るために、このCIImageを手続き的に生成できます。

00:13:33.000 --> 00:13:38.000
これを行うには、linearGradientフィルタのインスタンスを作成します。

00:13:38.000 --> 00:13:44.000
このフィルタは、2つの点と2つのCIColorsが与えられたグラデーションを作成します。

00:13:44.000 --> 00:13:51.000
鏡面は白で、明るさは現在のヘッドルームに基づいていますが、合理的な最大値に制限されています。

00:13:51.000 --> 00:13:58.000
使用する制限は、適用したい効果の外観によって異なります。

00:13:58.000 --> 00:14:05.000
Color0は、クランプされていない線形色空間でその白色レベルを使用して作成する必要があります。

00:14:05.000 --> 00:14:09.000
Color1はクリアカラーに設定されています。

00:14:09.000 --> 00:14:16.000
点0と点1は、鏡面が左上方向から表示されるように座標に設定されています。

00:14:16.000 --> 00:14:22.000
そして、フィルターの出力画像は、リップルフィルターに必要なサイズにトリミングされます。

00:14:22.000 --> 00:14:29.000
結果として生じる鏡面効果のリップルは、アプリでできることの単純なプロキシにすぎません。

00:14:29.000 --> 00:14:32.000
しかし、それは重要な原則を示しています。

00:14:32.000 --> 00:14:36.000
通常、明るいピクセルを適度に使用するのが最善です。

00:14:36.000 --> 00:14:37.000
少ないほど多い。

00:14:37.000 --> 00:14:41.000
明るいピクセルは、その方法でよりインパクトがあります。

00:14:41.000 --> 00:14:48.000
私たちは今、EDR効果のために2つの組み込みシフィターを使用する作業アプリを持っています。

00:14:48.000 --> 00:14:53.000
他の内蔵EDRフィルターで自由に試してみてください。

00:14:53.000 --> 00:15:03.000
次に、CIColorCubeフィルターの最適な使用方法と、独自のカスタムフィルターを書く際の注意事項について少しお話ししたいと思います。

00:15:03.000 --> 00:15:08.000
非常に人気のあるフィルターの1つはCIColorCubeWithColorSpaceです。

00:15:08.000 --> 00:15:13.000
従来、このフィルターはSDR画像にルックスを適用するために使用されます。

00:15:13.000 --> 00:15:21.000
このフィルターは、プロセス、インスタント、トーンなどの写真アプリにエフェクトを実装するためにも使用されます。

00:15:21.000 --> 00:15:32.000
伝統的に、このように見える立方体データには重大な制限があります。データは0対1の範囲のRGB色のみを入力および出力します。

00:15:32.000 --> 00:15:43.000
この制限を回避する1つの方法は、CIColorCubeWithColorSpaceフィルターにHLGやPQなどのEDR色空間を使用するように指示することです。

00:15:43.000 --> 00:15:52.000
これにより、EDRコンテンツに最適な結果が得られますが、これには色空間範囲で有効な新しいキューブデータを作成する必要があります。

00:15:52.000 --> 00:15:56.000
また、キューブの寸法を増やす必要があるかもしれません。

00:15:56.000 --> 00:16:07.000
代わりに、EDR画像にSDRキューブデータを引き続き使用することをお勧めします。今年の新機能では、フィルターにSDRキューブデータを推定するように指示できます。

00:16:07.000 --> 00:16:12.000
この機能を有効にするには、通常どおりSDRキューブデータを設定します。

00:16:12.000 --> 00:16:17.000
次に、フィルタの新しい外挿プロパティを設定します。

00:16:17.000 --> 00:16:25.000
この設定を「true」にすると、フィルターにEDR入力画像を与え、EDR出力画像を取得できます。

00:16:25.000 --> 00:16:33.000
今日取り上げたい最後のトピックは、独自のカスタムCIKernelsを作成する場合のベストプラクティスです。

00:16:33.000 --> 00:16:44.000
まず、クランプ、最小、最大などの関数を使用して、RGB値を0対1の範囲に制限する数学のカーネルコードを確認します。

00:16:44.000 --> 00:16:50.000
多くの場合、これらの制限は安全に削除でき、カーネルは正しく動作します。

00:16:50.000 --> 00:17:03.000
第二に、RGB値は0から1の範囲を超える可能性がありますが、アルファ値は0から1の間でなければなりません。そうしないと、画像をブレンドまたは表示するときに未定義の動作になります。

00:17:03.000 --> 00:17:15.000
この例では、正しい動作がRGB値に5を掛けるだけである場合、カーネルは誤ってアルファチャンネルに5を掛けています。

00:17:15.000 --> 00:17:16.000
これで私のプレゼンテーションは終わりです。

00:17:16.000 --> 00:17:31.000
最後に、今日は、Core Image SwiftUIアプリケーションにEDRヘッドルームのサポートを追加する方法と、さまざまな組み込みシピルターを使用してEDRコンテンツを作成および変更する方法を学びました。

00:17:31.000 --> 00:17:33.000
見てくれてありがとう!

00:17:33.000 --> 23:59:59.000
♪インストゥルメンタルヒップホップ音楽♪

