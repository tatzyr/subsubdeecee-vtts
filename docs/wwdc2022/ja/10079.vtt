WEBVTT

00:00:00.000 --> 00:00:11.000
Qiaoyu Deng:こんにちは。

00:00:11.000 --> 00:00:20.000
「アプリとサーバーのDNSセキュリティの改善」へようこそ。私の名前はQiaoyu Dengです。

00:00:20.000 --> 00:00:37.000
このビデオでは、DNSがしばしば安全ではない理由と、DNSSECとDDRで暗号化されたDNSを使用してDNSを保護する方法について説明します。

00:00:37.000 --> 00:00:44.000
まず、DNSが安全ではない理由について話しましょう。

00:00:44.000 --> 00:00:49.000
DNSはインターネットの電話帳です。

00:00:49.000 --> 00:01:02.000
人間が読めて覚えやすいドメイン名を、機械用に作られたIPアドレスに変換します。

00:01:02.000 --> 00:01:17.000
TCP、TLS、QUICなどの他のインターネットプロトコルは、IPアドレスを持つことに依存しているため、すべてがDNSから始まります。

00:01:17.000 --> 00:01:24.000
今日、TLSはインターネット通信を保護するために広く使用されています。

00:01:24.000 --> 00:01:31.000
それは素晴らしいことですが、基礎層であるDNSにはいくつかのセキュリティ上の問題があります。

00:01:31.000 --> 00:01:35.000
DNSは歴史的に安全ではありません。

00:01:35.000 --> 00:01:41.000
それはいくつかのセキュリティ上の考慮事項で1983年に設計されました。

00:01:41.000 --> 00:01:46.000
それ以来、多くのDNS攻撃が作成されました。

00:01:46.000 --> 00:02:05.000
1つの例は、DNSキャッシュポイズニングです。攻撃者はDNSリゾルバの欠陥を悪用し、誤ったIPアドレスをキャッシュさせ、クライアントを悪意のあるホストに接続させます。

00:02:05.000 --> 00:02:12.000
これは、DNSの脆弱性の1つを明らかにします:それは認証されていません。

00:02:12.000 --> 00:02:21.000
今日の従来のDNSクライアントには、回答を検証する方法がないため、簡単にスプーフィングできます。

00:02:21.000 --> 00:02:35.000
もう1つの一般的な攻撃は、攻撃者がクライアントとDNSサーバー間のDNSトラフィックを監視し、クライアントの履歴を収集するDNSスニッフィングです。

00:02:35.000 --> 00:02:39.000
これはユーザーのプライバシーにとって深刻な問題です。

00:02:39.000 --> 00:02:49.000
この攻撃が可能な理由は、DNSトラフィックがもともと暗号化されなかったためです。

00:02:49.000 --> 00:03:01.000
その上に構築されたプロトコルの安全な出発点になるためには、DNSを認証して暗号化する必要があります。

00:03:01.000 --> 00:03:09.000
DNSSECを使用してDNS応答に署名すると、認証が提供されます。

00:03:09.000 --> 00:03:18.000
TLSとHTTPSを使用してDNS解決を暗号化すると、プライバシーが保証されます。

00:03:18.000 --> 00:03:23.000
次に、DNSSECについて話しましょう。

00:03:23.000 --> 00:03:30.000
DNSSECは、IETFによって作成された一連の拡張仕様です。

00:03:30.000 --> 00:03:39.000
多くのDNSサービスプロバイダーはすでにそれをサポートしていますが、クライアントのサポートはまだ増加しています。

00:03:39.000 --> 00:03:47.000
iOS 16とmacOS Venturaは、クライアント側のDNSSEC検証をサポートするようになりました。

00:03:47.000 --> 00:03:54.000
DNSSECは、デジタル署名を追加することで、データの認証を保証します。

00:03:54.000 --> 00:03:57.000
データの整合性を保護します。

00:03:57.000 --> 00:04:04.000
答えが存在しないときに存在の否定を認証します。

00:04:04.000 --> 00:04:09.000
また、暗号認証も提供します。

00:04:09.000 --> 00:04:17.000
DNSSECは、応答に署名を添付することで、データの整合性を保護します。

00:04:17.000 --> 00:04:26.000
応答が攻撃者によって変更された場合、変更されたデータの署名は元のデータと一致しません。

00:04:26.000 --> 00:04:33.000
その場合、クライアントは変更された応答を検出して破棄することができます。

00:04:33.000 --> 00:04:47.000
DNSSECはまた、NSECレコードなどの特別なタイプのDNSレコードを使用して、ゾーン内のレコードの存在と非存在を主張します。

00:04:47.000 --> 00:04:56.000
NSECレコードは、次のレコード名が何であるかをアルファベット順に安全に伝えます。

00:04:56.000 --> 00:05:06.000
それによってリストされている名前は存在するものであり、リストされていない名前は存在しません。

00:05:06.000 --> 00:05:10.000
例えば、ここには3つのNSECレコードがあります。

00:05:10.000 --> 00:05:20.000
レコードセットは、ゾーン組織にはA.org、C.org、E.orgの3つのレコード名しかないことを明らかにしています。

00:05:20.000 --> 00:05:31.000
さて、A.orgが存在しないという攻撃者がいる場合、クライアントはこの攻撃を検出できます。

00:05:31.000 --> 00:05:39.000
A.orgは、最初のNSECレコードにリストされているため、存在します。

00:05:39.000 --> 00:06:03.000
同様に、攻撃者がD.orgが存在すると言った場合、2番目のNSECレコードによると、D.orgはC.orgとE.orgの間にあり、2つの名前の間に名前が存在しないため、クライアントもそれを検出できます。

00:06:03.000 --> 00:06:09.000
DNSSECは、信頼の連鎖を確立することによってレコードを認証します。

00:06:09.000 --> 00:06:12.000
ここに例があります。

00:06:12.000 --> 00:06:21.000
デバイスは、DNSSEC検証を有効にしてwww.example.orgを解決したいと考えています。

00:06:21.000 --> 00:06:28.000
IPアドレス、署名、キーを要求するクエリを送信します。

00:06:28.000 --> 00:06:37.000
応答を使用すると、IPアドレスからキー番号1への信頼関係を構築できます。

00:06:37.000 --> 00:06:53.000
次に、クライアントは親ゾーンの組織にクエリを送信し、キー番号1の認証に使用できるレコードを要求し、キー番号1からキー番号2への信頼関係を構築できます。

00:06:53.000 --> 00:07:01.000
したがって、デバイスはルートに到達するまで、このプロセスを再帰的に繰り返します。

00:07:01.000 --> 00:07:16.000
これで、図のキー番号3であるルートキーが信頼できる場合、IPアドレスからキー番号3への信頼関係を認証できます。

00:07:16.000 --> 00:07:21.000
ルートキーのハッシュは常にデバイスに安全に保存されます。

00:07:21.000 --> 00:07:26.000
DNSSECでは、ルートトラストアンカーと呼ばれています。

00:07:26.000 --> 00:07:35.000
キー番号3のハッシュがプリインストールされたアンカーと一致する場合、信頼チェーンを安全に確立できます。

00:07:35.000 --> 00:07:45.000
トラストチェーンでは、www.example.orgのIPアドレスが認証されるようになりました。

00:07:45.000 --> 00:07:54.000
アプリでDNSSECの検証が必要な場合、やるべきことは次のとおりです。

00:07:54.000 --> 00:07:58.000
ドメインのIPv6をサポートします。

00:07:58.000 --> 00:08:08.000
IPv6のみの環境では、IPv4のみのアドレスは合成IPv6アドレスに変換されます。

00:08:08.000 --> 00:08:20.000
ドメインが署名されている場合、合成されたアドレスはDNSSEC検証に合格できません。DNSSECが有効になっていると到達できません。

00:08:20.000 --> 00:08:26.000
したがって、ドメインがIPv6をサポートしていることを確認してください。

00:08:26.000 --> 00:08:33.000
DNSサービスプロバイダーがDNSSECでドメインに署名していることを確認してください。

00:08:33.000 --> 00:08:51.000
ドメインに署名せずにアプリでDNSSECを有効にすると、メリットはありませんが、追加のDNSトラフィックと未署名ドメインの認証を試みるための解決時間が延長されます。

00:08:51.000 --> 00:09:01.000
対応するインフラストラクチャのサポートを取得したら、アプリにDNSSECを採用するために必要なコードは次のとおりです。

00:09:01.000 --> 00:09:10.000
NSURLSessionクライアントの場合は、URLリクエストにDNSSEC検証を要求できます。

00:09:10.000 --> 00:09:13.000
ここに例があります。

00:09:13.000 --> 00:09:17.000
まず、デフォルトのセッション設定を作成します。

00:09:17.000 --> 00:09:23.000
その後、DNSSECの検証が必要になります。

00:09:23.000 --> 00:09:29.000
次に、変更された設定でセッションを作成します。

00:09:29.000 --> 00:09:37.000
このセッションから作成されたすべてのURLリクエストに対してDNSSECを有効にします。

00:09:37.000 --> 00:09:46.000
セッション全体でDNSSECを有効にしたくない場合は、リクエストレベルでこれを行うこともできます。

00:09:46.000 --> 00:09:54.000
まず、DNSSEC検証が無効になっているデフォルト設定でセッションを作成します。

00:09:54.000 --> 00:09:57.000
次に、リクエストで有効にします。

00:09:57.000 --> 00:10:06.000
これで、このセッションタスクは、DNSSECの検証が完了したときにのみ開始されます。

00:10:06.000 --> 00:10:15.000
Network.frameworkクライアントの場合は、接続にDNSSEC検証を要求することもできます。

00:10:15.000 --> 00:10:24.000
まず、パラメータオブジェクトを作成するときは、DNSSECの検証が必要です。

00:10:24.000 --> 00:10:30.000
次に、パラメータオブジェクトを使用してNWConnectionを作成します。

00:10:30.000 --> 00:10:46.000
これで、接続を開始すると、DNSSECの検証が完了し、検証済みのIPアドレスへの接続が確立された場合にのみ、準備完了状態に移行します。

00:10:46.000 --> 00:10:55.000
DNSSECを有効にすると、検証済みのアドレスのみが接続の確立に使用されます。

00:10:55.000 --> 00:11:01.000
HTTPSでは、エラーはAPIを通じて報告されます。

00:11:01.000 --> 00:11:06.000
DNSSECでは、検証失敗のエラーは返されません。

00:11:06.000 --> 00:11:13.000
検証に失敗した応答を受信することは、応答を受信しないことと同じです。

00:11:13.000 --> 00:11:25.000
応答を改ざんするDNSプロバイダーがある場合、アドレスは認証チェックに合格しないため、直接破棄されます。

00:11:25.000 --> 00:11:41.000
デバイスがDNSプロバイダーが応答を改ざんしていない新しいネットワークに参加すると、検証は再び進行し、解決は自動的に正常に戻ります。

00:11:41.000 --> 00:11:47.000
DNSSECの失敗を引き起こす可能性のあるケースをいくつか紹介します。

00:11:47.000 --> 00:12:00.000
元のDNS応答が変更されると、不一致のシグネチャはDNSSECチェックに合格せず、検証に失敗します。

00:12:00.000 --> 00:12:11.000
デバイスがプリインストールされたトラストアンカーに到達できず、そこからトラストチェーンを確立できない場合。

00:12:11.000 --> 00:12:30.000
ネットワークがDNS over TCPやEDNS0オプションなど、DNSSECが必要とする必要なプロトコルをサポートしていない場合、DNSSECイネーブルメントビットを伝送します。

00:12:30.000 --> 00:12:45.000
署名されたドメインがIPv6をサポートしていない場合、インターネットサービスプロバイダから提供された合成されたIPv6アドレスは検証に失敗します。

00:12:45.000 --> 00:12:59.000
それがDNSSECでDNS応答を認証する方法ですが、まだ暗号化されていない場合は、ネットワーク上の誰でもそれらを見ることができます。

00:12:59.000 --> 00:13:09.000
次に、DDRでDNS暗号化を自動的に有効にする方法について説明します。

00:13:09.000 --> 00:13:19.000
iOS 14とmacOS Big Surでは、プライバシーを保護するために暗号化されたDNSを導入しました。

00:13:19.000 --> 00:13:32.000
アプリでNEDNSSettingsManagerを使用するか、プロファイルでDNSSettingsを使用して、システム全体で暗号化されたDNSを手動で設定できます。

00:13:32.000 --> 00:13:41.000
NWParametersのPrivacyContextを使用して、アプリの暗号化されたDNSを選択することもできます。

00:13:41.000 --> 00:13:47.000
詳細については、「暗号化されたDNSを有効にする」をご覧ください。

00:13:47.000 --> 00:13:56.000
iOS 16とmacOS Venturaの新機能で、暗号化されたDNSを自動的に使用できます。

00:13:56.000 --> 00:14:10.000
ネットワークがDDRとも呼ばれる指定リゾルバーの検出をサポートしている場合、DNSクエリは自動的にTLSまたはHTTPSを使用します。

00:14:10.000 --> 00:14:28.000
暗号化されたDNSを使用するには、リゾルバがTLSまたはHTTPSをサポートしていることを知る必要があり、ポートまたはURLパスも学習する必要があるかもしれません。

00:14:28.000 --> 00:14:40.000
DHCPやルーター広告などの一般的なメカニズムは、プレーンなIPアドレスのみを提供します。

00:14:40.000 --> 00:14:49.000
DDRは、Appleが他の業界パートナーと協力してIETFで開発した新しいプロトコルです。

00:14:49.000 --> 00:14:59.000
これは、DNSクライアントが特別なDNSクエリを使用してこの必要な情報を学ぶ方法を提供します。

00:14:59.000 --> 00:15:10.000
デバイスが新しいネットワークに参加すると、「_dns.resolver.arpa」のサービスバインディングクエリが発行されます。

00:15:10.000 --> 00:15:18.000
DNSサーバーがDDRをサポートしている場合、1つ以上の構成で応答します。

00:15:18.000 --> 00:15:28.000
次に、デバイスはこの情報を使用して、指定されたリゾルバへの暗号化接続を設定します。

00:15:28.000 --> 00:15:38.000
暗号化されていないリゾルバのIPアドレスが、指定されたリゾルバのTLS証明書に含まれていることを確認します。

00:15:38.000 --> 00:15:47.000
これは、暗号化されていないリゾルバと暗号化されたリゾルバが同じエンティティに属していることを確認するために行われます。

00:15:47.000 --> 00:15:55.000
すべてが良さそうであれば、デバイスはデフォルトで暗号化されたDNSを使用するようになりました。

00:15:55.000 --> 00:15:59.000
DDRは一度に1つのネットワークに適用されます。

00:15:59.000 --> 00:16:09.000
お使いのデバイスは、現在のネットワークがサポートしている場合にのみ、自動的に暗号化されたDNSを使用します。

00:16:09.000 --> 00:16:20.000
また、DNSサーバーのIPアドレスがプライベートIPアドレスの場合、DDRは機能しないことに注意することも重要です。

00:16:20.000 --> 00:16:32.000
これは、所有権を確認できないため、そのようなIPアドレスがTLS証明書で許可されていないためです。

00:16:32.000 --> 00:16:53.000
iOS 16とmacOS Venturaでは、NEDNSSettingsManagerまたはDNSSettingsプロファイルを使用して、構成設定に暗号化されたDNSを使用する場合、クライアント認証を指定する機能もサポートしています。

00:16:53.000 --> 00:17:06.000
クライアント認証により、暗号化されたDNSサーバーは、サーバーがアクセスを許可する前にクライアントを検証する必要があるエンタープライズ環境で使用できます。

00:17:06.000 --> 00:17:16.000
NEDNSSettingsのidentityReferenceプロパティを使用してクライアント証明書を設定できるようになりました。

00:17:16.000 --> 00:17:22.000
これは、VPNのクライアント証明書と同じように動作します。

00:17:22.000 --> 00:17:30.000
これらは、DNS over TLSとDNS over HTTPSの両方に適用できます。

00:17:30.000 --> 00:17:35.000
これがDNSを保護するための道です。

00:17:35.000 --> 00:17:47.000
DNSSECでドメインに署名し、IPアドレスを認証するためにアプリでDNSSEC検証を要求します。

00:17:47.000 --> 00:17:58.000
ネットワーク上でDDRを有効にして、クライアントが暗号化されたDNSに自動的に切り替えて、ユーザーのプライバシーを向上させることができます。

00:17:58.000 --> 00:18:06.000
より良いアクセス制御が必要な企業でクライアント認証を採用する。

00:18:06.000 --> 00:18:14.000
私はあなたが将来構築するのに役立つ、より安全なDNS基盤を楽しみにしています。

00:18:14.000 --> 00:18:16.000
見てくれてありがとう!

00:18:16.000 --> 23:59:59.000
。

