WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:13.000
アダム：こんにちは、私の名前はアダムで、SharePlayチームのエンジニアです。

00:00:13.000 --> 00:00:18.000
SharePlayの新機能と、アプリで採用する方法についてお話しできることを嬉しく思います。

00:00:18.000 --> 00:00:24.000
まず、アプリからSharePlayを開始するための新しいAPIについて説明します。

00:00:24.000 --> 00:00:28.000
次に、いくつかのエキサイティングなGroupSessionMessengerのアップデートに入ります。

00:00:28.000 --> 00:00:34.000
最後に、SharePlayエクスペリエンスの実装に関するいくつかのベストプラクティス。

00:00:34.000 --> 00:00:36.000
アプリからSharePlayを開始します。

00:00:36.000 --> 00:00:46.000
私たちはあなたのフィードバックを聞き、配信しました。iOS 15.4以降、新しいAPIを活用して、アプリが既存のFaceTime通話なしでSharePlayを開始できるようになりました。

00:00:46.000 --> 00:00:48.000
では、それがどのように見えるか見てみましょう。

00:00:48.000 --> 00:00:52.000
だから今、私たちがしなければならないのは、お気に入りのSharePlayアプリを見つけることだけです。

00:00:52.000 --> 00:00:54.000
音楽アプリとしましょう。

00:00:54.000 --> 00:01:00.000
そして、Viral HitsのようにSharePlayしたい曲を見つけて、それを長押しします。

00:01:00.000 --> 00:01:03.000
コンテキストメニューで、新しいSharePlayボタンがあることがわかります。

00:01:03.000 --> 00:01:07.000
だから私は先に進んでそれを押して、それはピープルピッカーを引き出します。

00:01:07.000 --> 00:01:13.000
だから、Sueを選択してFaceTime通話を開始できます。

00:01:13.000 --> 00:01:17.000
そして、ご覧のとおり、私たちは今、ステージングされた活動でここにピルを持っています。

00:01:17.000 --> 00:01:24.000
だから、Sueが参加したら、先に進んで始めることができ、グループセッションがあります。

00:01:24.000 --> 00:01:30.000
まあ、私はそれがすべてかなりクールだと思いましたが、それをもう少し詳細に分解しましょう。

00:01:30.000 --> 00:01:37.000
ここでは、ユーザーが共有シートからSharePlayを開始する機能があり、これが機能するために何をする必要があるのか疑問に思うかもしれません。

00:01:37.000 --> 00:01:58.000
さて、答えは、あなたのアプリがSharePlayの資格を持っている場合、あなたは私たちのゼロ採用フローでこのボタンを無料で取得しますが、ユーザーはシステムUIを介してGroupActivityを開始することができず、代わりにSharePlayのコンテンツを選択するためにアプリと再対話する必要があるため、これは最適なユーザーエクスペリエンスではありません。

00:01:58.000 --> 00:02:03.000
それでは、アプリに新しいAPIをどのように採用するか見てみましょう。

00:02:03.000 --> 00:02:13.000
答えは、NSItemProviderにGroupActivityを登録し、ItemProviderをシェアシートに提供するのと同じくらい簡単です。

00:02:13.000 --> 00:02:17.000
SharePlayボタンをまだ提供したいが、目立つように表示したくないですか?

00:02:17.000 --> 00:02:18.000
問題ありません。

00:02:18.000 --> 00:02:23.000
UIActivityViewControllerのallowsProminentActivityで動作を調整できます。

00:02:23.000 --> 00:02:27.000
allowsProminentActivityをfalseに設定するだけです。

00:02:27.000 --> 00:02:31.000
または、アプリにSharePlayをサポートしていないコンテンツがある場合はどうなりますか?

00:02:31.000 --> 00:02:44.000
さて、SharePlayをサポートするためにすべてをサポートしたいと思いますが、UIActivityViewControllerにSharePlayアクティビティタイプを除外するように指示することで、SharePlayが共有シートに表示されないようにすることができます。

00:02:44.000 --> 00:02:55.000
また、アプリ内にボタンを直接配置したい場合は、新しいAPI GroupActivitySharingControllerを使用してUIViewControllerを作成し、それを提示することができます!

00:02:55.000 --> 00:03:05.000
誰かがあなたのアプリ内エクスペリエンスを押してFaceTimeまたはSharePlayセッションを開始すると、ステージングされたGroupActivityを有効にする機能が表示されます。

00:03:05.000 --> 00:03:08.000
アクティベートされると、アプリはGroupSessionを受け取ります。

00:03:08.000 --> 00:03:12.000
そして、あなたが自分自身に「待って、アダム、あなたはちょうど「ステージグループ活動」と言ったのですか?」と言っていても心配しないでください。

00:03:12.000 --> 00:03:14.000
なぜ、はい。はい、やりました！

00:03:14.000 --> 00:03:20.000
しかし、その考えに固執し、後でベストプラクティスについて話すときにそれをより深く掘り下げてみましょう。

00:03:20.000 --> 00:03:25.000
とりあえず、DrawTogetherアプリでこれを採用する方法を見てみましょう。

00:03:25.000 --> 00:03:27.000
これは私たちのDrawTogetherアプリです。

00:03:27.000 --> 00:03:39.000
2021年のWWDCトーク「グループアクティビティでカスタムエクスペリエンスを構築する」と同じアプリなので、まだ見ていない場合は、チェックすることを強くお勧めします。

00:03:39.000 --> 00:03:48.000
あなたが先に進んでそれを見たので、あなたは私たちのアプリに共有ボタンがなかったことを覚えているでしょうが、あなたがGroupSessionの資格があったとき、私たちはSharePlayボタンを持っていました。

00:03:48.000 --> 00:04:00.000
先に進み、その動作を修正して、isEligibleForGroupSessionがfalseであっても、ボタンを表示し、ユーザーがSharePlayセッションを開始できるようにします。

00:04:00.000 --> 00:04:02.000
そして今、私たちは先に進んで、それを実際に見ることができます。

00:04:02.000 --> 00:04:05.000
先に進んで、ControlBarコードに行きましょう。

00:04:05.000 --> 00:04:13.000
さて、ここで見ることができるように、グループセッションがなく、グループセッションの資格があることを確認する「if」ステートメントがあります。

00:04:13.000 --> 00:04:24.000
では、後者のステートメントを削除して、ここに移動しましょう。

00:04:24.000 --> 00:04:30.000
そして今、私たちがしなければならないことは、GroupActivity共有コントローラーをいつ提示するかを知るために、新しい変数を登録することです。

00:04:30.000 --> 00:04:43.000
だから、ここに新しい変数があります。それでは、その変数がtrueに変わったときに処理しましょう。

00:04:43.000 --> 00:04:55.000
そして、SwiftUIでGroupActivity共有コントローラーを提示できるように、今ラッパーを持っている必要があります。

00:04:55.000 --> 00:05:08.000
そして今、最後に、私たちがしなければならないのは、GroupSessionの資格がない場合、isSharingControllerPresentedをtrueに設定するための「else」ステートメントを持つことだけです。

00:05:08.000 --> 00:05:10.000
そして今、私たちはコードの動作を見ることができます。

00:05:10.000 --> 00:05:14.000
そこで、DrawTogetherアプリに移動します。ご覧のとおり、SharePlayボタンがあります。

00:05:14.000 --> 00:05:19.000
だから、私たちは今それを押すことができ、私たちはピープルピッカーを与えられています。

00:05:19.000 --> 00:05:24.000
そして今、私たちはあなたのアプリからSharePlayを始めるための素晴らしい経験を持っています。

00:05:24.000 --> 00:05:26.000
しかし、それは私たちが行った唯一のアップデートではありません。

00:05:26.000 --> 00:05:30.000
それでは、私たちが行ったGroupSessionMessengerのアップデートのいくつかについて話しましょう。

00:05:30.000 --> 00:05:34.000
GroupSessionMessengerには2つのエキサイティングな新しいアップデートがあります。

00:05:34.000 --> 00:05:38.000
最初のアップデートでは、この魔法の数字に遭遇したかもしれません。

00:05:38.000 --> 00:05:43.000
これは、GroupSessionMessengerで送信できるペイロードサイズです。

00:05:43.000 --> 00:05:45.000
まあ、もう違います。

00:05:45.000 --> 00:05:51.000
ペイロードサイズが256KBで4倍大きくなりました。

00:05:51.000 --> 00:05:57.000
この変更により、アプリはメッセージを小さなメッセージに分割することを心配する必要はありません。

00:05:57.000 --> 00:06:01.000
メッセージを送信して、素晴らしい体験を構築することに集中できます。

00:06:01.000 --> 00:06:06.000
そして、それがあなたを十分に興奮させなかったなら、私たちの次のアップデートはそうすると確信しています。

00:06:06.000 --> 00:06:08.000
信頼できないメッセージ。

00:06:08.000 --> 00:06:13.000
GroupSessionMessengerの一部として、メッセージの信頼性を選択できるようになりました。

00:06:13.000 --> 00:06:20.000
これにより、希望する経験に応じて、信頼できるメッセージングと信頼できないメッセージングのどちらかを選択できます。

00:06:20.000 --> 00:06:30.000
私たちがしなければならないのは、MessageReliabilityを指定できるGroupSessionMessengerの新しい初期化子を活用することだけです。

00:06:30.000 --> 00:06:35.000
APIの使い方を理解したので、その経験はどうですか?

00:06:35.000 --> 00:06:38.000
信頼性の低いメッセージングをいつ使いたいですか?

00:06:38.000 --> 00:06:46.000
まあ、それは人々がFaceTimeとSharePlayでリアルタイムのアクションを実行している素晴らしい質問です。

00:06:46.000 --> 00:06:48.000
だから、セッションに3人いると想像してみましょう。

00:06:48.000 --> 00:06:51.000
エイミー、ブライアン、クリス。

00:06:51.000 --> 00:06:58.000
それらはすべてセッションに参加し、時間が進むにつれて私たちの映画も同期されます。

00:06:58.000 --> 00:07:04.000
しかし、エイミーがその瞬間の特定の時間に関連する何かをしたい場合はどうなりますか?

00:07:04.000 --> 00:07:16.000
まあ、信頼できるメッセージングを使用する場合は、すべてのデバイスでメッセージが受信されることを保証しますが、それは彼らが期待している時間に受信されるという意味ではありません。

00:07:16.000 --> 00:07:23.000
たとえば、クリスはメッセージを受信しましたが、ブライアンは最初にメッセージをドロップし、その後適切に受信しました。

00:07:23.000 --> 00:07:26.000
しかし、覚えておいてください、映画はまだ上映中です。

00:07:26.000 --> 00:07:32.000
だから今、私たちはエイミーがメッセージが反映されることを意図した場所にたどり着きましたが、ブライアンはそれを持っていません。

00:07:32.000 --> 00:07:35.000
彼は後でそれを受け取りますが、その時点では遅すぎます。

00:07:35.000 --> 00:07:39.000
まあ、これは信頼性の低いネットワーキングのための完璧なケースです。

00:07:39.000 --> 00:07:46.000
これにより、開発者は、反対側で確実に受信する必要がある情報と、そうでない情報を知ることができます。

00:07:46.000 --> 00:07:53.000
これは、ユーザーエクスペリエンスがレイテンシに深く影響するプロトコルを設計する際に理解すべき重要な概念です。

00:07:53.000 --> 00:08:05.000
信頼性の低いメッセージはUDPを使用しており、関係する各メッセージの待ち時間とオーバーヘッドが少なく、その結果、それらを介してメッセージを送信するときに、よりリアルタイムのエクスペリエンスが得られます。

00:08:05.000 --> 00:08:15.000
それでは、これをDrawTogetherアプリにどのように使用するかについて話しましょう。WWDC '21のこの画面、特に私の美しく描かれたスマイリーフェイスを覚えているかもしれません。

00:08:15.000 --> 00:08:22.000
画面にスマイリーフェイスを描いているときに何が起こるかを少し掘り下げてみましょう。

00:08:22.000 --> 00:08:30.000
私たちのアプリには、GestureRecognizerをリッスンするコードがあり、変更に気づくたびにメッセージを送信しました。

00:08:30.000 --> 00:08:38.000
これは、私たちがスマイリーフェイスを描いているとき、GestureRecognizerが私たちに与えるポイントごとに常に新しいメッセージを送っていたことを意味しました。

00:08:38.000 --> 00:08:40.000
それはたくさんのメッセージです!

00:08:40.000 --> 00:08:48.000
さて、プロトコルを変更して、信頼性の低いメッセージングを使用して、よりシームレスな描画体験を実現できるようになりました。

00:08:48.000 --> 00:08:57.000
ここで行うことは、GestureRecognizerから更新を受け取るたびに、信頼性の低いメッセージングを使用して新しく追加されたポイントを送信できるようにすることです。

00:08:57.000 --> 00:09:05.000
ジェスチャーが完了したら、信頼できるメッセージングを使用し、すべてのポイントを与えて、クライアントが見逃したポイントに追いつくようにします。

00:09:05.000 --> 00:09:13.000
これにより、信頼性の低いメッセージングによって提供される低レイテンシを利用して、より迅速な描画体験を得ることができます。

00:09:13.000 --> 00:09:16.000
では、コードでこれを行う方法を見てみましょう。

00:09:16.000 --> 00:09:20.000
では、まずメッセージファイルに行きましょう。

00:09:20.000 --> 00:09:25.000
そして、先に進んで新しいメッセージタイプを定義します。

00:09:25.000 --> 00:09:32.000
ご覧のとおり、この新しいメッセージタイプは古いものとほぼ同じですが、今回はストロークのすべてのポイントが含まれます。

00:09:32.000 --> 00:09:40.000
では、キャンバスファイルに進みます。

00:09:40.000 --> 00:09:50.000
そして、取得する新しいメッセージを処理するためにハンドラー機能を設定する必要があります。

00:09:50.000 --> 00:09:54.000
そして、先に進んで、私たちの信頼できないメッセンジャーを作りましょう。

00:09:54.000 --> 00:09:59.000
まず、変数を作成します。

00:09:59.000 --> 00:10:06.000
そして今、それを初期化しましょう。

00:10:06.000 --> 00:10:12.000
次に、完成したストロークメッセージを聞きます。

00:10:12.000 --> 00:10:19.000
そして、前のメッセージも信頼できないメッセンジャーとしてマークしてください。

00:10:19.000 --> 00:10:21.000
しかし、メッセージを送る方法が必要です。

00:10:21.000 --> 00:10:26.000
だから、私たちはfinishedStrokeに行きます。

00:10:26.000 --> 00:10:31.000
そして、私たちは先に進んで新しいメッセージタイプを送信します。

00:10:31.000 --> 00:10:39.000
そして、信頼できないメッセンジャーを使用するためにすべてのポイントを送信するための古い機能を変更しましょう。

00:10:39.000 --> 00:10:41.000
そして今、私たちはコードの動作を見ることができます。

00:10:41.000 --> 00:10:47.000
そこで、DrawTogetherアプリに行くと、それがどれほどシームレスであるかがわかります。

00:10:47.000 --> 00:10:49.000
そして、それだけです!

00:10:49.000 --> 00:10:55.000
そして今、約束通り、SharePlay実装のベストプラクティスについて話しましょう。

00:10:55.000 --> 00:11:00.000
以前のこの用語を覚えているかもしれません：段階的なグループアクティビティ。

00:11:00.000 --> 00:11:02.000
あなたのアプリにとって、その用語はどういう意味ですか?

00:11:02.000 --> 00:11:07.000
さて、シナリオを通して話しましょう。

00:11:07.000 --> 00:11:12.000
左側のデバイス「アダム」が、右側のデバイス「ブライアン」でSharePlayを開始するとしましょう。

00:11:12.000 --> 00:11:15.000
しかし、アダムは彼らが見ていたショーを再開しようとしています。

00:11:15.000 --> 00:11:24.000
したがって、誰かがステージングされたGroupActivityをアクティブにすると、最初からやり直すのではなく、特定の時間に再開されたショーに飛び込みたいと考えています。

00:11:24.000 --> 00:11:31.000
「アダム」はショーに11分残っていることを知っていたが、ブライアンのデバイスはそうしなかったので、これは問題を提起した。

00:11:31.000 --> 00:11:37.000
これは、ブライアンのデバイスがステージングされたGroupActivityをアクティブにした場合、ショーを最初からやり直す可能性があることを意味します。

00:11:37.000 --> 00:11:39.000
それで、私たちはここで何ができますか?

00:11:39.000 --> 00:11:43.000
それは本当にあなたのアプリと経験に依存します。

00:11:43.000 --> 00:11:45.000
では、いくつかのアイデアを見てみましょう。

00:11:45.000 --> 00:11:52.000
再生ケースについては、各デバイスがキャッチアップで他のデバイスに最初の再生状態を貢献させたいと考えています。

00:11:52.000 --> 00:12:05.000
これは、アダムのデバイスが再生状態が23秒であることを知っていたので、彼がセッションに参加するとき、彼は他のすべてのデバイスに彼の意図した再生状態を伝え、彼らはそれを真実の源として使用することを意味します。

00:12:05.000 --> 00:12:09.000
この同じ原則は、SharePlayを使用して作成したすべてのエクスペリエンスにも適用されます。

00:12:09.000 --> 00:12:15.000
セッションに参加する各人は、セッションの理解を他の人に貢献する必要があります。

00:12:15.000 --> 00:12:18.000
これは、セッションがピアツーピアで所有者がないためです。

00:12:18.000 --> 00:12:21.000
では、それについてもう少し話しましょう。

00:12:21.000 --> 00:12:29.000
オーナーレスセッションは把握するのが難しい概念ですが、適切なSharePlayエクスペリエンスを設計する際に重要です。

00:12:29.000 --> 00:12:34.000
この場合、左側のアダムは、セッションをApple TVに引き継ぎたいと思っています。

00:12:34.000 --> 00:12:39.000
その結果、彼の電話はGroupSessionをドロップし、彼のテレビが参加します。

00:12:39.000 --> 00:12:42.000
しかし、所有権が実装されたらどうなりますか?

00:12:42.000 --> 00:12:46.000
さて、オーナーが降ろしたので...

00:12:46.000 --> 00:12:50.000
そして、これはテレビのためだけではないことを覚えておいてください。

00:12:50.000 --> 00:12:53.000
iOS 16では、FaceTimeのハンドオフがあります。

00:12:53.000 --> 00:12:59.000
だからアダムは先に進み、彼のiPadを手放し、まあ、同じことです。

00:12:59.000 --> 00:13:01.000
ブーム、それだけではありません。

00:13:01.000 --> 00:13:10.000
誰かがセッションをあるデバイスから別のデバイスに移動しようとするユーザーフローの例について話しましたが、考えるべき他のケースがあります。

00:13:10.000 --> 00:13:14.000
さて、心配しないでください、もう1つの例で短くします。

00:13:14.000 --> 00:13:17.000
この画面は少し見覚えがあるかもしれません。

00:13:17.000 --> 00:13:19.000
それはFaceTime HUDです。

00:13:19.000 --> 00:13:23.000
しかし、SharePlayボタンをクリックするとどうなりますか?

00:13:23.000 --> 00:13:30.000
これで、SharePlayを終了するボタンが表示されました。これにより、SharePlayを終了できます。

00:13:30.000 --> 00:13:38.000
これにより、すべての人のSharePlayを終了できます。基本的には、アプリケーションに代わってGroupSessionで.end（）を呼び出すシステムです。

00:13:38.000 --> 00:13:47.000
これは、そのデバイスが所有者でない限り、.end()を呼び出しないようにどんなに慎重であっても、システムはあなたに代わってGroupSessionで.end()を呼び出すことができることを意味します。

00:13:47.000 --> 00:13:58.000
したがって、把握するのが難しい概念かもしれませんが、アプリケーションに所有権の感覚がないことを確認することは、全体的にはるかに良い経験をもたらすことを意味します。

00:13:58.000 --> 00:14:11.000
セッション全体を聴いたので、アプリ内からSharePlayを開始するための新しいAPIを採用し、アプリが信頼性の低いメッセージングを使用して新しい低レイテンシで通信する方法を探ります。

00:14:11.000 --> 00:14:16.000
皆さんからの連絡が大好きですので、フィードバックアシスタントを使用してフィードバックを提出し続けてください。

00:14:16.000 --> 00:14:22.000
あなたが私たちが行ったすべての変更を楽しんだことを願っていますし、あなたが構築したすべての素晴らしい経験を見るのを楽しみにしています。

00:14:22.000 --> 00:14:28.000
まだしていない場合は、他のWWDCトーク「素晴らしいSharePlay体験を作る」をチェックしてください。

00:14:28.000 --> 00:14:36.000
または、メディア再生に関する素晴らしい機能強化をお探しの場合は、「SharePlayで広告やその他のインタースティシャルを表示する」をチェックしてください。

00:14:36.000 --> 00:14:41.000
ご不明な点がございましたら、GroupActivitiesラボとチャレンジをご覧ください。

00:14:41.000 --> 00:14:45.000
いつものように、チューニングしてくれてありがとう、そして素晴らしいWWDCをお過ごしください。

00:14:45.000 --> 23:59:59.000
あなたが何を作るかを見るのが待ちきれません。

