WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:12.000
スウィフト並行性の視覚化と最適化へようこそ。

00:00:12.000 --> 00:00:16.000
私の名前はマイクで、スウィフトのランタイムライブラリに取り組んでいます。

00:00:16.000 --> 00:00:18.000
こんにちは、私はHarjasで、楽器に取り組んでいます。

00:00:18.000 --> 00:00:28.000
一緒に、Instruments 14で利用可能な新しい視覚化ツールを含め、Swift Concurrencyコードをよりよく理解し、より速くする方法について話し合います。

00:00:28.000 --> 00:00:36.000
Swift Concurrencyのさまざまな部分とそれらがどのように連携するかを本当に簡単に要約して、スピードアップしていることを確認しましょう。

00:00:36.000 --> 00:00:38.000
その後、新しい並行性機器をデモします。

00:00:38.000 --> 00:00:44.000
Swift Concurrencyを使用するアプリで実際のパフォーマンスの問題を解決するために、それを使用する方法を紹介します。

00:00:44.000 --> 00:00:51.000
最後に、スレッドプールの枯渇と継続誤用の潜在的な問題と、それらを回避する方法について説明します。

00:00:51.000 --> 00:00:54.000
昨年、私たちはSwift Concurrencyを導入しました。

00:00:54.000 --> 00:01:01.000
これは、非同期/待機、構造化並行性、およびアクターを含む新しい言語機能でした。

00:01:01.000 --> 00:01:07.000
それ以来、Appleの内外で、これらの機能が大量に採用されていることを嬉しく思います。

00:01:07.000 --> 00:01:14.000
Swiftの並行性は、同時プログラミングをより簡単かつ安全にするために連携する言語にいくつかの新機能を追加します。

00:01:14.000 --> 00:01:19.000
Async/awaitは、同時コードの基本的な構文ビルディングブロックです。

00:01:19.000 --> 00:01:29.000
実行の途中で作業を中断し、実行スレッドをブロックすることなく、後でその作業を再開できる関数を作成して呼び出すことができます。

00:01:29.000 --> 00:01:32.000
タスクは、並行コードの基本的な作業単位です。

00:01:32.000 --> 00:01:37.000
タスクは並行コードを実行し、その状態と関連するデータを管理します。

00:01:37.000 --> 00:01:44.000
それらはローカル変数を含み、キャンセルを処理し、非同期コードの実行を開始および一時停止します。

00:01:44.000 --> 00:01:50.000
構造化された並行性により、子タスクを生成して並行して実行し、完了するのを待つことが容易になります。

00:01:50.000 --> 00:01:59.000
この言語は、作業をグループ化して維持し、タスクが待たれるか、使用しない場合は自動的にキャンセルされることを保証する構文を提供します。

00:01:59.000 --> 00:02:03.000
アクターは、共有データにアクセスする必要がある複数のタスクを調整します。

00:02:03.000 --> 00:02:12.000
彼らは外部からデータを分離し、一度に1つのタスクのみが内部状態を操作することを許可し、同時突然変異からデータレースを回避します。

00:02:12.000 --> 00:02:24.000
Instruments 14の新機能では、アプリでこのアクティビティをすべてキャプチャして視覚化できる一連の機器を導入し、アプリが何をしているのかを理解し、問題を特定し、パフォーマンスを向上させるのに役立ちます。

00:02:24.000 --> 00:02:34.000
Swift Concurrencyの基礎をより深く議論するために、関連ビデオセクションにリンクされているこれらの機能に関するいくつかのビデオがあります。

00:02:34.000 --> 00:02:38.000
Swift Concurrencyコードを使用したアプリの最適化を見てみましょう。 アプリの最適化を見てみましょう。

00:02:38.000 --> 00:02:43.000
迅速な並行性により、正しい並行コードと並列コードを簡単に書くことができます。

00:02:43.000 --> 00:02:48.000
しかし、並行性構造を悪用するコードを書くことはまだ可能です。

00:02:48.000 --> 00:02:54.000
それらを正しく使用することも可能ですが、あなたが目指していたパフォーマンスの利点を得られない方法で。

00:02:54.000 --> 00:03:02.000
Swiftの並行性を使用してコードを書くときに発生する可能性のあるいくつかの一般的な問題があり、パフォーマンスの低下やバグを引き起こす可能性があります。

00:03:02.000 --> 00:03:06.000
メインアクターのブロックにより、アプリがハングする可能性があります。

00:03:06.000 --> 00:03:13.000
アクターの競合とスレッドプールの枯渇は、並列実行を減らすことでパフォーマンスを低下させます。

00:03:13.000 --> 00:03:17.000
継続的な誤用は、リークやクラッシュを引き起こします。

00:03:17.000 --> 00:03:22.000
新しいSwift並行性インストゥルメントは、これらの問題を発見して修正するのに役立ちます。

00:03:22.000 --> 00:03:26.000
メインアクターのブロッキングから始めて、これらのそれぞれを見てみましょう。

00:03:26.000 --> 00:03:31.000
メインアクターブロックは、ロングランのタスクがメインアクターで実行されたときに発生します。

00:03:31.000 --> 00:03:36.000
メインアクターは、メインスレッドですべての作業を実行する特別なアクターです。

00:03:36.000 --> 00:03:43.000
UI作業はメインスレッドで行う必要があり、メインアクターではUIコードをSwift Concurrencyに統合できます。

00:03:43.000 --> 00:03:50.000
ただし、メインスレッドはUIにとって非常に重要であるため、利用可能である必要があり、長時間の作業ユニットで占有することはできません。

00:03:50.000 --> 00:03:55.000
これが起こると、アプリがロックされているように見え、応答しなくなります。

00:03:55.000 --> 00:04:04.000
メインアクターで実行されているコードは、すぐに終了し、作業を完了するか、メインアクターからバックグラウンドに計算を移動する必要があります。

00:04:04.000 --> 00:04:09.000
作業は、通常のアクターまたは切り離されたタスクに入れることで、バックグラウンドに移動できます。

00:04:09.000 --> 00:04:16.000
UIを更新したり、メインスレッドで実行する必要がある他のタスクを実行するために、メインアクターで小さな作業ユニットを実行できます。

00:04:16.000 --> 00:04:18.000
これのデモを見てみましょう。 アクション。

00:04:18.000 --> 00:04:20.000
ありがとう、マイク。

00:04:20.000 --> 00:04:22.000
ここにファイルスクイーザアプリケーションがあります。

00:04:22.000 --> 00:04:27.000
フォルダ内のすべてのファイルをすばやく圧縮できるように、このアプリケーションを構築しました。

00:04:27.000 --> 00:04:30.000
小さなファイルでは問題ないようです。

00:04:30.000 --> 00:04:39.000
ただし、より大きなファイルを使用すると、予想よりもはるかに時間がかかり、UIは完全にフリーズし、いかなるインタラクションにも応答しません。

00:04:39.000 --> 00:04:46.000
この動作はユーザーにとって非常に不快であり、アプリケーションがクラッシュしたか、決して終わらないと思わせる可能性があります。

00:04:46.000 --> 00:04:51.000
私たちは、最高のユーザーエクスペリエンスのために、UIが常に応答するように努力する必要があります。

00:04:51.000 --> 00:04:58.000
このパフォーマンスの問題を調査するために、Instrumentsで新しいSwift Concurrencyテンプレートを使用できます。

00:04:58.000 --> 00:05:06.000
Swift TasksとSwift Actorsのインストゥルメントは、並行性コードを視覚化して最適化するのに役立つツールの完全なスイートを提供します。

00:05:06.000 --> 00:05:15.000
パフォーマンスの問題を調査し始めたばかりのときは、まずSwift Tasks機器が提供するトップレベルの統計を確認する必要があります。

00:05:15.000 --> 00:05:22.000
1つ目は実行中のタスクで、同時に実行されているタスクの数を示します。

00:05:22.000 --> 00:05:28.000
次に、Alive Tasksがあり、特定の時点で存在するタスクの数を示します。

00:05:28.000 --> 00:05:36.000
そして最後に、合計タスク; その時点までに作成されたタスクの総数をグラフ化します。

00:05:36.000 --> 00:05:44.000
アプリケーションのメモリフットプリントを削減しようとするときは、AliveとTotal Tasksの統計を詳しく調べる必要があります。

00:05:44.000 --> 00:05:53.000
これらすべての統計を組み合わせることで、コードがどれだけ並列化されているか、どれだけのリソースを消費しているかがよくわかります。

00:05:53.000 --> 00:06:09.000
この機器の多くの詳細ビューの1つは、タスクフォレストです。このウィンドウの下半分に示されているように、構造化された並行性コード内のタスク間の親子関係のグラフィカルな表現を提供します。

00:06:09.000 --> 00:06:12.000
次に、タスクサマリービューがあります。

00:06:12.000 --> 00:06:17.000
これは、各タスクが異なる州で費やす時間を示しています。

00:06:17.000 --> 00:06:27.000
タスクを右クリックして、選択したタスクに関するすべての情報を含むトラックをタイムラインに固定できるようにすることで、ビューをスーパーチャージしました。

00:06:27.000 --> 00:06:38.000
これにより、非常に長い間実行されているか、アクターへのアクセスを待って立ち往生している可能性のある関心のあるタスクをすばやく見つけて学ぶことができます。

00:06:38.000 --> 00:06:43.000
Swiftタスクをタイムラインに固定すると、4つの重要な機能があります。

00:06:43.000 --> 00:06:48.000
まず、Swiftタスクがどのような状態にあるかを示すトラックです。

00:06:48.000 --> 00:06:53.000
次に、拡張詳細ビューのタスク作成バックトレースです。

00:06:53.000 --> 00:06:58.000
第三に、スウィフトタスクの状態に関するより多くのコンテキストを提供する物語的なビューです。

00:06:58.000 --> 00:07:04.000
たとえば、タスクを待っている場合は、どのタスクを待っているかを通知します。

00:07:04.000 --> 00:07:10.000
最後に、サマリービューで行ったのと同じピンアクションにアクセスできます。

00:07:10.000 --> 00:07:16.000
したがって、子タスク、スレッド、さらにはスウィフトアクターをタイムラインに固定することができます。

00:07:16.000 --> 00:07:26.000
この物語のビューは、Swiftタスクが他の並行性プリミティブやCPUとどのように関連しているかを見つけるのに役立ちます。

00:07:26.000 --> 00:07:33.000
新しい機器のいくつかの機能の概要を見たので、アプリケーションをプロファイリングし、コードを最適化しましょう。

00:07:33.000 --> 00:07:38.000
Xcodeでプロジェクトをプルアップし、Command-Iを押すことでこれを行うことができます。

00:07:38.000 --> 00:07:44.000
これにより、アプリケーションがコンパイルされ、機器が開かれ、File Squeezerアプリケーションにターゲットが事前に選択されます。

00:07:44.000 --> 00:07:52.000
ここから、テンプレートピッカーでSwift並行性オプションを選択し、記録を開始できます。

00:07:52.000 --> 00:07:56.000
もう一度、大きなファイルをアプリにドロップします。

00:07:56.000 --> 00:08:01.000
繰り返しになりますが、アプリが回転し始め、UIが反応しないことがわかります。

00:08:01.000 --> 00:08:08.000
インスツルメンツがアプリケーションに関するすべての情報をキャプチャできるように、これをさらに数秒間実行します。

00:08:08.000 --> 00:08:11.000
痕跡が見つかったので、調査を開始できます。

00:08:11.000 --> 00:08:17.000
すべての情報をよりよく見るために、このトレースをフルスクリーンにします。

00:08:17.000 --> 00:08:24.000
オプションドラッグを使用して、関心のある領域を拡大することができます。

00:08:24.000 --> 00:08:31.000
プロセストラックでは、Instrumentsは、このUIハングが発生した場所を正確に示しています。

00:08:31.000 --> 00:08:37.000
これは、ハングがいつ発生したか、どのくらいの期間続いたかが明確ではない場合に役立ちます。

00:08:37.000 --> 00:08:42.000
先に述べたように、始めるのに良い場所は、トップレベルのSwiftタスク統計です。

00:08:42.000 --> 00:08:46.000
すぐに目を引くのは、ランニングタスクの数です。

00:08:46.000 --> 00:08:49.000
ほとんどの場合、実行されているタスクは1つだけです。

00:08:49.000 --> 00:08:55.000
これは、問題の一部は、私たちのすべての仕事がシリアル化を余儀なくされていることを示しています。

00:08:55.000 --> 00:09:03.000
タスク状態の要約を使用して、最も長く実行されているタスクを見つけ、ピンアクションを使用してタイムラインにピン留めできます。

00:09:03.000 --> 00:09:14.000
このタスクの物語ビューは、バックグラウンドスレッドで短時間実行され、その後メインスレッドで長時間実行されたことを示しています。

00:09:14.000 --> 00:09:23.000
さらに調査するには、メインスレッドをタイムラインに固定することができます。

00:09:23.000 --> 00:09:27.000
メインスレッドは、いくつかの長時間実行中のタスクによってブロックされています。

00:09:27.000 --> 00:09:31.000
これは、マイクが話したメインアクターブロッキングの問題を示しています。

00:09:31.000 --> 00:09:38.000
だから、私たちが自問しなければならない質問は、「このタスクは何をしていますか?」です。そして「このタスクはどこから来たのですか?」

00:09:38.000 --> 00:09:43.000
これらの質問の両方に答えるために、物語のビューに戻ることができます。

00:09:43.000 --> 00:09:50.000
拡張詳細ビューの作成バックトレースは、タスクがcompressAllFiles関数で作成されたことを示しています。

00:09:50.000 --> 00:09:56.000
物語は、タスクが compressAllFiles でクロージャ番号1 を実行していることを示しています。

00:09:56.000 --> 00:10:03.000
このシンボルを右クリックすると、ソースビューアで開くことができます。

00:10:03.000 --> 00:10:08.000
この関数内のクロージャナンバーワンは、圧縮作業を呼び出しています。

00:10:08.000 --> 00:10:18.000
このタスクがどこで作成され、何をしているのかがわかったので、Xcodeでコードを開き、メインスレッドでこれらの重い計算を実行しないように調整することができます。

00:10:18.000 --> 00:10:24.000
圧縮ファイル機能は、CompressionStateクラス内にあります。

00:10:24.000 --> 00:10:29.000
CompressionStateクラス全体は、@MainActorで実行するように注釈が付けられています。

00:10:29.000 --> 00:10:32.000
これは、タスクがメインスレッドでも実行された理由を説明しています。

00:10:32.000 --> 00:10:44.000
ここでの@Publishedプロパティはメインスレッドからのみ更新する必要があるため、このクラス全体をMainActorにする必要があります。そうしないと、ランタイムの問題が発生する可能性があります。

00:10:44.000 --> 00:10:49.000
だから、代わりに、このクラスを独自のアクターに変換しようとすることができます。

00:10:49.000 --> 00:11:01.000
しかし、コンパイラは、本質的にこの共有可変状態は2つの異なるアクターによって保護される必要があると言っているので、これを行うことができないことを教えてくれます。

00:11:01.000 --> 00:11:04.000
しかし、それは私たちに本当の解決策が何であるかのヒントを与えてくれます。

00:11:04.000 --> 00:11:09.000
このクラスには2つの異なる可変状態があります。

00:11:09.000 --> 00:11:16.000
1つの状態である「ファイル」プロパティは、SwiftUIによって観察されるため、MainActorに分離する必要があります。

00:11:16.000 --> 00:11:27.000
しかし、他の状態であるログへのアクセスは、同時アクセスから保護する必要がありますが、どのスレッドが任意の時点でログにアクセスするかは関係ありません。

00:11:27.000 --> 00:11:32.000
したがって、実際には主役である必要はありません。

00:11:32.000 --> 00:11:38.000
しかし、私たちはまだ同時アクセスから保護したいので、独自のアクターでラップします。

00:11:38.000 --> 00:11:45.000
今必要なのは、必要に応じてタスクが2つの間をホップする方法を追加することだけです。

00:11:45.000 --> 00:11:53.000
新しいアクターを作成し、ParallelCompressorと呼ぶことができます。

00:11:53.000 --> 00:12:04.000
その後、ログ状態を新しいアクターにコピーし、追加のセットアップコードを追加できます。

00:12:04.000 --> 00:12:08.000
ここから、これらの俳優同士がお互いにコミュニケーションをとる必要があります。

00:12:08.000 --> 00:12:27.000
まず、CompressionStateクラスからログ変数を参照したコードを削除し、ParallelCompressor Actorに追加しましょう。

00:12:27.000 --> 00:12:43.000
最後に、ParallelCompressorでcompressFileを呼び出すためにCompressionStateを更新する必要があります。

00:12:43.000 --> 00:12:48.000
これらの変更で、アプリケーションをもう一度テストしましょう。

00:12:48.000 --> 00:12:55.000
もう一度、大きなファイルをアプリケーションにドロップします。

00:12:55.000 --> 00:13:01.000
UIはもはやハングアップしておらず、これは大きな改善ですが、期待するスピードは得られていません。

00:13:01.000 --> 00:13:08.000
私たちは、この作業をできるだけ早く行うために、機械内のすべてのコアを最大限に活用したいと考えています。

00:13:08.000 --> 00:13:12.000
マイク、他に何に気をつければいいの？

00:13:12.000 --> 00:13:19.000
マイク：私たちはメイン俳優から仕事を移動させることでハングアップを解決しましたが、私たちはまだ私たちが望むパフォーマンスを得ていません。

00:13:19.000 --> 00:13:22.000
理由を確認するには、俳優を詳しく調べる必要があります。

00:13:22.000 --> 00:13:26.000
アクターは、複数のタスクが共有状態を操作することを安全にします。

00:13:26.000 --> 00:13:31.000
しかし、彼らはその共有状態へのアクセスをシリアル化することによってこれを行います。

00:13:31.000 --> 00:13:38.000
一度に1つのタスクのみがアクターを占有することが許可され、そのアクターを使用する必要がある他のタスクは待機します。

00:13:38.000 --> 00:13:45.000
Swiftの並行性は、非構造化タスク、タスクグループ、およびasync letを使用した並列計算を可能にします。

00:13:45.000 --> 00:13:49.000
理想的には、これらの構造は、多くのCPUコアを同時に使用できます。

00:13:49.000 --> 00:13:57.000
そのようなコードからアクターを使用する場合は、これらのタスク間で共有されているアクターで大量の作業を実行することに注意してください。

00:13:57.000 --> 00:14:04.000
複数のタスクが同じアクターを同時に使用しようとすると、アクターはそれらのタスクの実行をシリアル化します。

00:14:04.000 --> 00:14:11.000
このため、並列計算のパフォーマンスメリットが失われます。

00:14:11.000 --> 00:14:16.000
これは、各タスクが俳優が利用可能になるのを待たなければならないためです。

00:14:16.000 --> 00:14:23.000
これを修正するには、アクターのデータへの排他的なアクセスが本当に必要な場合にのみ、タスクがアクターで実行されることを確認する必要があります。

00:14:23.000 --> 00:14:25.000
他のすべては俳優から逃げるべきだ。

00:14:25.000 --> 00:14:28.000
タスクをチャンクに分割します。

00:14:28.000 --> 00:14:32.000
いくつかのチャンクは俳優で実行しなければならず、他のチャンクは実行しません。

00:14:32.000 --> 00:14:39.000
非アクターの分離されたチャンクは並行して実行できます。つまり、コンピュータは作業をはるかに速く完了できます。

00:14:39.000 --> 00:14:41.000
これのデモを見てみましょう。 アクション。

00:14:41.000 --> 00:14:43.000
ハルジャス:ありがとう、マイク。

00:14:43.000 --> 00:14:49.000
更新された「ファイルスクイーザー」アプリケーションの痕跡を見て、マイクが私たちに教えてくれたことを覚えておきましょう。

00:14:49.000 --> 00:14:57.000
タスクサマリービューは、並行性コードがキューに入れられた状態で驚くべき時間を費やしていることを示しています。

00:14:57.000 --> 00:15:02.000
これは、俳優への排他的なアクセスを得るために待っている多くのタスクがあることを意味します。

00:15:02.000 --> 00:15:07.000
これらのタスクの1つをピン留めして、その理由を学びましょう。

00:15:07.000 --> 00:15:16.000
このタスクは、圧縮作業を実行する前に、ParallelCompressor Actorに入るのを待つのにかなりの時間がかかります。

00:15:16.000 --> 00:15:23.000
先に進んで、俳優を私たちのタイムラインに固定しましょう。

00:15:23.000 --> 00:15:28.000
ここには、ParallelCompressor Actorのトップレベルのデータをいくつか紹介します。

00:15:28.000 --> 00:15:33.000
このアクターキューは、いくつかの長時間実行中のタスクによってブロックされているようです。

00:15:33.000 --> 00:15:37.000
タスクは、本当に必要な期間だけ俳優にとどまるべきです。

00:15:37.000 --> 00:15:42.000
タスクの物語に戻りましょう。

00:15:42.000 --> 00:15:50.000
ParallelCompressorのエンキューの後、タスクはcompressAllFilesのクロージャ番号1で実行されます。

00:15:50.000 --> 00:15:52.000
では、そこで調査を始めましょう。

00:15:52.000 --> 00:15:59.000
ソースコードは、このクロージャが主に圧縮作業を実行していることを示しています。

00:15:59.000 --> 00:16:11.000
compressFile関数はParallelCompressor Actorの一部であるため、この関数の実行全体はActorで行われ、他のすべての圧縮作業をブロックします。

00:16:11.000 --> 00:16:22.000
この問題を解決するには、compressFile関数をアクター隔離から切り離されたタスクに引き出す必要があります。

00:16:22.000 --> 00:16:31.000
これにより、関連する可変状態を更新するために必要な限り、アクターでのみ切り離されたタスクを持つことができます。

00:16:31.000 --> 00:16:42.000
したがって、圧縮機能は、アクターで保護された状態にアクセスする必要があるまで、スレッドプール内の任意のスレッドで自由に実行できます。

00:16:42.000 --> 00:16:48.000
たとえば、「ファイル」プロパティにアクセスする必要がある場合、メインアクターに移動します。

00:16:48.000 --> 00:17:01.000
しかし、そこで完了するとすぐに、logsプロパティにアクセスする必要があるまで、再び「並行性の海」に移動し、ParallelCompressor Actorに移動します。

00:17:01.000 --> 00:17:08.000
しかし、再び、それがそこで行われるとすぐに、それはスレッドプールで実行されるために再び俳優を残します。

00:17:08.000 --> 00:17:14.000
しかし、もちろん、圧縮作業を行うタスクは1つだけではありません。たくさんあります。

00:17:14.000 --> 00:17:23.000
そして、アクターに制約されないことで、スレッドの数によってのみ制限され、すべて同時に実行できます。

00:17:23.000 --> 00:17:33.000
もちろん、各アクターは一度に1つのタスクしか実行できませんが、ほとんどの場合、私たちのタスクはアクターである必要はありません。

00:17:33.000 --> 00:17:43.000
マイクが説明したように、これにより、圧縮タスクを並行して実行し、利用可能なすべてのCPUコアを利用することができます。

00:17:43.000 --> 00:17:47.000
では、今すぐこの変更を加えましょう。

00:17:47.000 --> 00:17:53.000
compressFile関数を非分離としてマークできます。

00:17:53.000 --> 00:17:56.000
これにより、いくつかのコンパイラエラーが発生します。

00:17:56.000 --> 00:18:04.000
非分離としてマークすることで、このアクターの共有状態にアクセスする必要はないとSwiftコンパイラに伝えました。

00:18:04.000 --> 00:18:06.000
しかし、それは完全に真実ではありません。

00:18:06.000 --> 00:18:13.000
このログ関数はアクター分離されており、共有可変状態にアクセスする必要があります。

00:18:13.000 --> 00:18:29.000
これを修正するには、この関数を非同期にし、すべてのログ呼び出しをawaitキーワードでマークする必要があります。

00:18:29.000 --> 00:18:40.000
次に、タスクの作成を更新して、切り離されたタスクを作成する必要があります。

00:18:40.000 --> 00:18:47.000
タスクが作成されたアクターコンテキストを継承しないようにします。

00:18:47.000 --> 00:18:56.000
切り離されたタスクでは、明示的に自己をキャプチャする必要があります。

00:18:56.000 --> 00:19:05.000
アプリケーションをもう一度テストしましょう。

00:19:05.000 --> 00:19:12.000
アプリはすべてのファイルを同時に圧縮することができ、UIは応答性を維持します。

00:19:12.000 --> 00:19:18.000
改善点を確認するために、Swift Actorsのインストゥルメントをチェックすることができます。

00:19:18.000 --> 00:19:30.000
ParallelCompressorアクターを見ると、アクターで実行される作業のほとんどは短時間で、キューのサイズが手に負えなくなったことはありません。

00:19:30.000 --> 00:19:42.000
要約すると、インストゥルメントを使用してUIハングの原因を分離し、並行性を向上させるために並行性コードを再構築し、データを使用してパフォーマンスの向上を検証しました。

00:19:42.000 --> 00:19:46.000
今、マイクは、他の潜在的なパフォーマンスの問題について私たちに話すつもりです。

00:19:46.000 --> 00:19:50.000
マイク：デモで見たものを超えて、私がカバーしたい2つの一般的な問題があります。

00:19:50.000 --> 00:19:53.000
まず、スレッドプールの枯渇について話しましょう。

00:19:53.000 --> 00:19:57.000
スレッドプールの枯渇は、パフォーマンスを傷つけたり、アプリケーションをデッドロックしたりする可能性があります。

00:19:57.000 --> 00:20:02.000
迅速な並行性には、実行中に前進するタスクが必要です。

00:20:02.000 --> 00:20:06.000
タスクが何かを待つとき、それは通常、一時停止することによってそうします。

00:20:06.000 --> 00:20:15.000
ただし、タスク内のコードは、中断することなく、ファイルやネットワークIOのブロック、ロックの取得など、ブロッキングコールを実行する可能性があります。

00:20:15.000 --> 00:20:20.000
これにより、タスクが前進するための要件が破れます。

00:20:20.000 --> 00:20:27.000
これが起こると、タスクは実行されているスレッドを占有し続けますが、実際にはCPUコアを使用していません。

00:20:27.000 --> 00:20:34.000
スレッドのプールが制限されており、一部がブロックされているため、並行性ランタイムはすべてのCPUコアを完全に使用することはできません。

00:20:34.000 --> 00:20:41.000
これにより、実行できる並列計算の量とアプリの最大パフォーマンスが削減されます。

00:20:41.000 --> 00:20:52.000
極端な場合、スレッドプール全体がブロックされたタスクによって占有され、スレッドプールで実行するために新しいタスクを必要とする何かを待っている場合、並行性ランタイムはデッドロックする可能性があります。

00:20:52.000 --> 00:20:55.000
タスク内の通話をブロックしないようにしてください。

00:20:55.000 --> 00:21:00.000
ファイルとネットワークIOは、非同期APIを使用して実行する必要があります。

00:21:00.000 --> 00:21:03.000
条件変数やセマフォで待つことは避けてください。

00:21:03.000 --> 00:21:12.000
きめ細かい、短時間保持されたロックは、必要に応じて許容されますが、競合の多いロックや長期間保持されるロックは避けてください。

00:21:12.000 --> 00:21:23.000
これらのことを行う必要があるコードがある場合は、そのコードを並行性スレッドプールの外に移動します。たとえば、ディスパッチキューで実行し、継続を使用して並行性の世界にブリッジします。

00:21:23.000 --> 00:21:30.000
可能な限り、システムを円滑に動作させるために、操作をブロックするために非同期APIを使用してください。

00:21:30.000 --> 00:21:35.000
継続を使用するときは、それらを正しく使用するように注意する必要があります。

00:21:35.000 --> 00:21:40.000
継続は、Swiftの並行性と他の形式の非同期コードの架け橋です。

00:21:40.000 --> 00:21:47.000
継続は現在のタスクを一時停止し、呼び出されたときにタスクを再開するコールバックを提供します。

00:21:47.000 --> 00:21:51.000
これは、コールバックベースの非同期APIで使用できます。

00:21:51.000 --> 00:21:58.000
Swiftの並行性の観点から、タスクは中断され、継続が再開されると再開されます。

00:21:58.000 --> 00:22:05.000
コールバックベースの非同期APIの観点から、作業が開始され、作業が完了するとコールバックが呼び出されます。

00:22:05.000 --> 00:22:14.000
Swift Concurrency機器は継続について知っており、それに応じて時間間隔をマークし、タスクが呼び出される継続を待っていたことを示します。

00:22:14.000 --> 00:22:20.000
継続コールバックには特別な要件があります。正確に一度、それ以上、それ以下で呼び出す必要があります。

00:22:20.000 --> 00:22:29.000
これはコールバックベースのAPIの一般的な要件ですが、非公式な要件である傾向があり、言語によって強制されず、見落としが一般的です。

00:22:29.000 --> 00:22:32.000
スウィフトの並行性は、これを難しい要件にします。

00:22:32.000 --> 00:22:36.000
コールバックが2回呼び出されると、プログラムがクラッシュしたり、動作を間違えたりします。

00:22:36.000 --> 00:22:40.000
コールバックが呼び出されない場合、タスクはリークされます。

00:22:40.000 --> 00:22:45.000
このコードスニペットでは、withCheckedContinuationを使用して継続を取得します。

00:22:45.000 --> 00:22:48.000
次に、コールバックベースのAPIを呼び出します。

00:22:48.000 --> 00:22:51.000
コールバックでは、継続を再開します。

00:22:51.000 --> 00:22:54.000
これは、一度だけ呼び出すという要件を満たしています。

00:22:54.000 --> 00:22:58.000
コードがより複雑なときは注意することが重要です。

00:22:58.000 --> 00:23:02.000
左側では、成功時に継続のみを再開するようにコールバックを変更しました。

00:23:02.000 --> 00:23:04.000
これはバグです。

00:23:04.000 --> 00:23:10.000
失敗すると、継続は再開されず、タスクは永久に中断されます。

00:23:10.000 --> 00:23:13.000
右側では、継続を2回再開します。

00:23:13.000 --> 00:23:17.000
これもバグであり、アプリは誤動作したりクラッシュしたりします。

00:23:17.000 --> 00:23:23.000
これらのスニペットは両方とも、継続を一度だけ再開する要件に違反しています。

00:23:23.000 --> 00:23:27.000
継続には、チェックと安全でない2種類の継続があります。

00:23:27.000 --> 00:23:35.000
パフォーマンスが絶対に重要でない限り、継続には、常にwithCheckedContinuation APIを使用してください。

00:23:35.000 --> 00:23:40.000
チェックされた継続は自動的に誤用を検出し、エラーにフラグを立てます。

00:23:40.000 --> 00:23:44.000
チェックされた継続が2回呼び出されると、継続はトラップします。

00:23:44.000 --> 00:23:53.000
継続がまったく呼び出されない場合、継続が破棄されると、継続が漏洩したことを警告するメッセージがコンソールに出力されます。

00:23:53.000 --> 00:24:00.000
Swift Concurrencyインストゥルメントは、継続状態で無期限に立ち往している対応するタスクを表示します。

00:24:00.000 --> 00:24:04.000
Instrumentsの新しいSwift Concurrencyテンプレートについては、さらに調べる必要があります。

00:24:04.000 --> 00:24:15.000
構造化された並行性のグラフィック視覚化を取得し、タスク作成コールツリーを表示し、正確な組み立て手順を検査して、Swift Concurrencyランタイムの全体像を把握することができます。

00:24:15.000 --> 00:24:22.000
Swift Concurrencyがボンネットの下でどのように機能するかの詳細については、昨年の「Swift Concurrency: Behind the Scenes」のセッションをご覧ください。

00:24:22.000 --> 00:24:27.000
また、データレースの詳細については、「Swift Concurrencyを使用してデータレースを排除する」をご覧ください。

00:24:27.000 --> 00:24:28.000
見てくれてありがとう!

00:24:28.000 --> 23:59:59.000
そして、並行性コードをデバッグして楽しんでください。

