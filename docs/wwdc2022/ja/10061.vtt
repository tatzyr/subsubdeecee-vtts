WEBVTT

00:00:00.000 -> 00:00:03.000
♪まろやかなインストゥルメンタルヒップヒップミュージック♪

00:00:03.000 -> 00:00:09.000
♪

00:00:09.000 -> 00:00:10.000
みなさん、こんにちは。

00:00:10.000 -> 00:00:14.000
SwiftUIチームのエンジニア、ジェフです。

00:00:14.000 -> 00:00:22.000
今日は、iPadOSとmacOSのSwiftUIアプリに複数のウィンドウを導入することについてお話しできることを嬉しく思います。

00:00:22.000 -> 00:00:32.000
このセッションでは、導入するいくつかの新しいタイプを含む、SwiftUIライフサイクルのさまざまなシーンタイプの概要を説明します。

00:00:32.000 -> 00:00:39.000
続いて、補助シーンを追加して、これらのシーンタイプをどのように構成できるかを示します。

00:00:39.000 -> 00:00:45.000
次に、アプリで特定のシーンのウィンドウを開くための新しいAPIをいくつか取り上げます。

00:00:45.000 -> 00:00:51.000
そして、アプリのシーンをカスタマイズするためのいくつかの方法で物事をまとめます。

00:00:51.000 -> 00:00:57.000
新しいシーンタイプを掘り下げる前に、既存のシーンタイプの概要から始めましょう。

00:00:57.000 -> 00:01:03.000
以前のセッションから、SwiftUIのアプリはシーンとビューで構成されていることを思い出すでしょう。

00:01:03.000 -> 00:01:08.000
シーンは通常、画面上のウィンドウで内容を表します。

00:01:08.000 -> 00:01:12.000
例えば、これは私が読んでいる本を追跡するために作ったアプリです。

00:01:12.000 -> 00:01:17.000
これは、プラットフォームに適した方法で私の読書リストを表示する単一のウィンドウグループとして定義されています。

00:01:17.000 -> 00:01:26.000
iPadOSやmacOSなど、複数のウィンドウをサポートするプラットフォームでは、シーンはそのようないくつかのウィンドウで自分自身を表現できます。

00:01:26.000 -> 00:01:32.000
シーンの動作と表現は、使用されるタイプによって異なります。

00:01:32.000 -> 00:01:39.000
たとえば、シーンは、プラットフォームの機能に関係なく、単一のインスタンスでのみ表現できます。

00:01:39.000 -> 00:01:43.000
SwiftUIのシーンタイプの現在のリストを見てみましょう。

00:01:43.000 -> 00:01:49.000
WindowGroupは、Appleのすべてのプラットフォームでデータ駆動型アプリケーションを構築する方法を提供します。

00:01:49.000 -> 00:01:54.000
DocumentGroupでは、iOSとmacOSでドキュメントベースのアプリを構築できます。

00:01:54.000 -> 00:02:01.000
そして、設定は、macOSのアプリ内設定値を表すためのインターフェースを定義します。

00:02:01.000 -> 00:02:05.000
これらのシーンタイプは、アプリの機能を拡張するために一緒に構成できます。

00:02:05.000 -> 00:02:08.000
2つの新しい追加でシーンのリストを拡張しています。

00:02:08.000 -> 00:02:24.000
1つ目はウィンドウで、すべてのプラットフォームで単一のユニークなウィンドウを表すシーンです。また、macOSの新しいシーンタイプ：MenuBarExtraは、システムメニューバーの永続的なコントロールとしてレンダリングされます。

00:02:24.000 -> 00:02:33.000
他のシーンタイプと同様に、WindowとMenuBarExtraの両方をスタンドアロンシーンとして使用したり、アプリ内の他のシーンで構成したりできます。

00:02:33.000 -> 00:02:41.000
WindowGroupとは異なり、ウィンドウシーンは、その内容を1つのユニークなウィンドウインスタンスでのみ表現します。

00:02:41.000 -> 00:02:54.000
この特性は、シーンの内容が、macOSとiPadOSのWindowGroupsのマルチウィンドウプレゼンテーションスタイルに必ずしも適合しないグローバルなアプリの状態を表す場合に役立ちます。

00:02:54.000 -> 00:03:01.000
たとえば、ゲームは、そのコンテンツをレンダリングするために単一のメインウィンドウのみを許可したい場合があります。

00:03:01.000 -> 00:03:08.000
MenuBarExtraは、他のシーンとは少し異なる動作をする新しいmacOSのみのシーンタイプです。

00:03:08.000 -> 00:03:19.000
ウィンドウに内容をレンダリングするのではなく、メニューバーにラベルを配置し、ラベルに固定されているメニューまたはウィンドウに内容を表示します。

00:03:19.000 -> 00:03:27.000
さらに、そのアプリが最前面にあるかどうかに関係なく、関連するアプリが実行されている限り使用できます。

00:03:27.000 -> 00:03:34.000
MenuBarExtraは、その機能に簡単にアクセスできるスタンドアロンのユーティリティアプリを作成するのに最適です。

00:03:34.000 -> 00:03:41.000
または、アプリの機能にアクセスする別の方法を提供するために、他のシーンと構成することもできます。

00:03:41.000 -> 00:03:56.000
また、メニューバーからプルダウンするメニューの内容を表示するデフォルトのスタイルと、メニューバーに固定されたクロムレスウィンドウに内容を表示するスタイルという2つのレンダリングスタイルもサポートしています。

00:03:56.000 -> 00:04:07.000
これら2つの新しいシーンタイプを追加することで、SwiftUIアプリは、すべてのプラットフォームでさらに豊富な機能セットを表すことができます。

00:04:07.000 -> 00:04:13.000
これらの新しいAPIを既存のシーンタイプと組み合わせてどのように使用できるかを見てみましょう。

00:04:13.000 -> 00:04:17.000
これは私が以前に示した私のBookClubアプリの定義です。

00:04:17.000 -> 00:04:19.000
現在、単一のウィンドウグループで構成されています。

00:04:19.000 -> 00:04:27.000
macOSでは、私のBookClubアプリは、時間の経過とともに読書活動を表示するための追加のウィンドウの恩恵を受けることができます。

00:04:27.000 -> 00:04:37.000
これは、macOSアプリがそのプラットフォームに存在する追加の画面の不動産と柔軟なウィンドウの配置をどのように活用できるかの素晴らしい例です。

00:04:37.000 -> 00:04:41.000
このインターフェイスを表現するために、アプリに補助シーンを追加します。

00:04:41.000 -> 00:04:48.000
アクティビティウィンドウのデータは、アプリ全体の状態から派生しているため、ウィンドウシーンが理想的な選択です。

00:04:48.000 -> 00:04:52.000
同じ状態で複数の窓を開けると、私たちのデザインにはうまく収まりません。

00:04:52.000 -> 00:05:00.000
シーンに提供されたタイトルは、ウィンドウメニューのセクションに追加されるメニュー項目のラベルとして使用されます。

00:05:00.000 -> 00:05:05.000
この項目を選択すると、まだ開いていなくても、シーンのウィンドウが開きます。

00:05:05.000 -> 00:05:08.000
そうでなければ、それは正面に持ち込まれるでしょう。

00:05:08.000 -> 00:05:21.000
BookClubアプリに補助シーンを追加することを取り上げたので、追加している新しいシーンプレゼンテーションAPIのいくつかと、それらをアプリに統合してより豊かな体験を提供する方法について議論したいと思います。

00:05:21.000 -> 00:05:26.000
BookClubアプリには、コンテンツリストペインの任意のブックに対して呼び出すことができるコンテキストメニューがあります。

00:05:26.000 -> 00:05:31.000
このコンテキストメニューには、ウィンドウプレゼンテーションをトリガーするためのボタンが含まれます。

00:05:31.000 -> 00:05:33.000
まもなく詳細を記入します。

00:05:33.000 -> 00:05:41.000
SwiftUIは、アプリが定義するシーンに関連付けられたウィンドウを表示するための環境を介していくつかの新しい呼び出し可能なタイプを提供します。

00:05:41.000 -> 00:05:49.000
1つ目はopenWindowアクションで、WindowGroupまたはウィンドウシーンのいずれかのウィンドウを表示できます。

00:05:49.000 -> 00:05:56.000
アクションに渡される識別子は、アプリで定義されたシーンの識別子と一致する必要があります。

00:05:56.000 -> 00:06:03.000
openWindowアクションは、提示されたシーンがその内容を表示するために使用するプレゼンテーション値を取ることもできます。

00:06:03.000 -> 00:06:10.000
この形式のアクションは、まもなく確認する新しい初期化子を使用して、WindowGroupによってのみサポートされます。

00:06:10.000 -> 00:06:15.000
値のタイプは、シーンの初期化子に提供されたタイプと一致する必要があります。

00:06:15.000 -> 00:06:28.000
また、ドキュメントウィンドウを表示するための環境には、FileDocumentsとReferenceFileDocumentsの両方で新しいドキュメントウィンドウを開くことをサポートするnewDocumentアクションの2つの呼び出し可能なタイプもあります。

00:06:28.000 -> 00:06:34.000
このアクションでは、アプリ内の対応するDocumentGroupがエディターの役割で定義されている必要があります。

00:06:34.000 -> 00:06:39.000
このアクションに提供されたドキュメントは、ウィンドウが表示されるたびに作成されます。

00:06:39.000 -> 00:06:48.000
ディスク上の既存のファイルによってコンテンツが提供されているドキュメントウィンドウを表示するには、openDocumentアクションがあります。

00:06:48.000 -> 00:06:51.000
このアクションは、開きたいファイルのURLを取ります。

00:06:51.000 -> 00:07:01.000
アプリはウィンドウを表示するためのDocumentGroupを定義する必要があり、そのグループのドキュメントタイプは、提供されたURLでファイルのタイプを読み取ることができる必要があります。

00:07:01.000 -> 00:07:06.000
ボタンを再訪して、openWindow環境プロパティをビューに追加します。

00:07:06.000 -> 00:07:11.000
このタイプは呼び出し可能なので、ボタンのアクションから直接呼び出すことができます。

00:07:11.000 -> 00:07:18.000
私たちのブックタイプは識別可能なものに準拠しているため、提示する値としてその識別子を渡します。

00:07:18.000 -> 00:07:23.000
さて、先に進む前に、openWindowアクションに渡された値について話し合いたいと思います。

00:07:23.000 -> 00:07:30.000
UUIDタイプの値である本の識別子を渡していることに気づきました。

00:07:30.000 -> 00:07:37.000
一般的に、値自体ではなく、モデルの識別子をこのように使用したいと思うでしょう。

00:07:37.000 -> 00:07:39.000
ブックタイプは値タイプであることに注意してください。

00:07:39.000 -> 00:07:47.000
そのため、提示された値として使用すると、新しいウィンドウはプレゼンテーションを開始したもののコピーを取得します。

00:07:47.000 -> 00:07:50.000
どちらか一方の編集は、もう一方には影響しません。

00:07:50.000 -> 00:07:59.000
本の識別子を使用すると、モデルストアは、単一の値に複数のバインディングを提供することで、代わりにこれらの値の真実の源になります。

00:07:59.000 -> 00:08:03.000
値型セマンティクスの詳細については、開発者ドキュメントを参照してください。

00:08:03.000 -> 00:08:10.000
提示されるタイプは、HashableプロトコルとCodableプロトコルの両方に準拠している必要があります。

00:08:10.000 -> 00:08:21.000
提示された値を開いているウィンドウに関連付けるには、ハッシュ可能な適合性が必要です。状態復元のために提示された値を永続化するには、コード可能な適合性が必要です。

00:08:21.000 -> 00:08:24.000
近いうちに、これらの両方の行動について詳しく説明します。

00:08:24.000 -> 00:08:29.000
最後に、可能であれば、軽量値を渡すことを好みます。

00:08:29.000 -> 00:08:32.000
私たちの本の識別子は、これのもう一つの素晴らしい例です。

00:08:32.000 -> 00:08:41.000
値は状態復元のためにSwiftUIによって保持されるため、より小さな値を使用すると、アプリの応答性が向上します。

00:08:41.000 -> 00:08:48.000
今、私たちのボタンは今、私たちの詳細ウィンドウを表示するために必要な部分を持っていますが、それが選択されると何も表示されません。

00:08:48.000 -> 00:08:56.000
これは、SwiftUIに特定のデータタイプのウィンドウを表示するように指示したが、それを反映したシーンをアプリで定義していないためです。

00:08:56.000 -> 00:08:58.000
私たちのアプリに戻って、今すぐその変更を加えましょう。

00:08:58.000 -> 00:09:05.000
プライマリウィンドウグループと補助ウィンドウに加えて、本の詳細を処理するための追加のウィンドウグループを追加します。

00:09:05.000 -> 00:09:09.000
私たちの本の詳細WindowGroupは新しい初期化子を使用しています。

00:09:09.000 -> 00:09:16.000
タイトルに加えて、このグループはBook.IDタイプのデータを提示しています。私たちの場合はUUIDです。

00:09:16.000 -> 00:09:22.000
このタイプは、先ほど追加したopenWindowアクションに渡す値と一致する必要があります。

00:09:22.000 -> 00:09:36.000
プレゼンテーション用に指定された値がWindowGroupに提供されると、SwiftUIはその値の新しい子シーンを作成し、そのシーンのウィンドウのルートコンテンツは、グループのビュービルダーを使用してその値によって定義されます。

00:09:36.000 -> 00:09:40.000
それぞれのユニークな提示された価値は、新しいシーンを作成します。

00:09:40.000 -> 00:09:48.000
値の等価性は、新しいウィンドウを作成するか、既存のウィンドウを再利用できるかを判断するために使用されます。

00:09:48.000 -> 00:09:56.000
openWindowがウィンドウがすでに存在する値を提示すると、グループは新しいウィンドウを作成するのではなく、そのウィンドウを使用します。

00:09:56.000 -> 00:10:09.000
BookClubアプリを例として、すでにウィンドウに表示されているブックのコンテキストメニューアクションを選択すると、同じブックを表示する2番目のウィンドウではなく、そのウィンドウが前面に並べられます。

00:10:09.000 -> 00:10:16.000
提示された値は、状態復元の目的でSwiftUIによって自動的に保持されます。

00:10:16.000 -> 00:10:20.000
あなたのビューには、最初に提示された値へのバインディングが与えられます。

00:10:20.000 -> 00:10:24.000
このバインディングは、ウィンドウが開いている間はいつでも変更できます。

00:10:24.000 -> 00:10:31.000
状態復元のためにシーンが再作成されると、SwiftUIは最新の値をウィンドウのコンテンツビューに渡します。

00:10:31.000 -> 00:10:40.000
ここでは、詳細ビューにBook.IDバインディングを与え、モデルストアで指定されたアイテムを検索して表示することができます。

00:10:40.000 -> 00:10:48.000
すべての作品が整った状態で、コンテキストメニュー項目を選択し、独自のウィンドウで本の詳細を表示できるようになりました。

00:10:48.000 -> 00:10:54.000
最後に、アプリでシーンをカスタマイズする方法をいくつか確認したいと思います。 では、いくつかのシーンをカスタマイズできますか？

00:10:54.000 -> 00:11:06.000
メインビューアウィンドウ用と詳細ウィンドウ用の2つのWindowGroupシーンでアプリを定義したため、SwiftUIはデフォルトでファイルメニューに各グループのメニュー項目を追加します。

00:11:06.000 -> 00:11:10.000
しかし、詳細ウィンドウのメニュー項目は、私たちのユースケースにはあまり合いません。

00:11:10.000 -> 00:11:16.000
ウィンドウは、以前に追加されたコンテキストメニューからのみ開くことができることを望みます。

00:11:16.000 -> 00:11:26.000
新しいシーン修飾子「commandsRemoved」を使用すると、ファイルメニューのようなデフォルトのコマンドを提供しなくなるようにシーンを変更できます。

00:11:26.000 -> 00:11:34.000
この修飾子を適用した後、ファイルメニューには、プライマリウィンドウグループのウィンドウを開くための項目のみが含まれるようになりました。

00:11:34.000 -> 00:11:43.000
私の読書活動を示すための補助ウィンドウシーンの現在のプレゼンテーションにはあまり満足していないので、次はそれに焦点を当てましょう。

00:11:43.000 -> 00:11:50.000
いくつかの修飾子を適用するので、アプリの定義をよりクリーンに保つカスタムシーンに抽出します。 

00:11:50.000 -> 00:11:57.000
ウィンドウの以前の状態がない場合、SwiftUIはデフォルトでそれを画面の中央に配置します。

00:11:57.000 -> 00:12:03.000
ただし、読書アクティビティがデフォルトで別の場所に配置されている場合は、その方がいいと思います。

00:12:03.000 -> 00:12:11.000
新しいdefaultPosition修飾子を追加することで、以前の状態が利用できない場合に使用する位置を指定できます。

00:12:11.000 -> 00:12:19.000
この位置は画面サイズに相対的であり、現在のロケールを考慮してウィンドウを適切な場所に配置します。

00:12:19.000 -> 00:12:25.000
この新しい位置は、私のアクティビティウィンドウを画面上の他の表示ウィンドウと区別するのに役立ちます。

00:12:25.000 -> 00:12:31.000
また、アクティビティウィンドウをデフォルトで特定のサイズで表示したいのですが、それでもサイズ変更可能です。

00:12:31.000 -> 00:12:36.000
defaultPositionと並んで、defaultSize修飾子を追加します。

00:12:36.000 -> 00:12:43.000
提供された値は、レイアウトシステムに与えられ、ウィンドウの初期サイズを導き出します。

00:12:43.000 -> 00:12:49.000
ウィンドウのプレゼンテーションをカスタマイズしたので、その動作をカスタマイズするためにもう1つの修飾子を追加しましょう。

00:12:49.000 -> 00:12:54.000
keyboardShortcut修飾子は、シーンタイプでも機能するように拡張されました。

00:12:54.000 -> 00:12:59.000
シーンレベルで使用すると、この修飾子は新しいウィンドウを作成するコマンドに影響します。

00:12:59.000 -> 00:13:06.000
ここでは、ショートカットOption-Command-0で開くことができるように、アクティビティウィンドウを変更しました。

00:13:06.000 -> 00:13:21.000
これは、一般的に使用されるシーンへのショートカットを提供することでアプリをカスタマイズする素晴らしい方法であり、アプリのプライマリWindowGroupに追加されるCommand-Nのデフォルトのショートカットをカスタマイズするためにも使用できます。

00:13:21.000 -> 00:13:25.000
これにより、SwiftUIの新しいシーンとウィンドウ機能のツアーが終了します。

00:13:25.000 -> 00:13:29.000
私たちはこれらの新しいAPIの可能性に本当に興奮しており、あなたもそうであることを願っています!

00:13:29.000 -> 00:13:44.000
iPadOSとmacOSアプリに機能を追加する方法の詳細については、「iPadのSwiftUI：インターフェイスを整理する」と「iPadのSwiftUI：ツールバー、タイトルなどを追加する」という他のセッションをチェックしてください。

00:13:44.000 -> 00:13:46.000
見てくれてありがとう。

00:13:46.000 -> 23:59:59.000
♪

