WEBVTT

00:00:00.000 --> 00:00:03.000
♪まろやかなインストゥルメンタルヒップホップ音楽♪

00:00:03.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:14.000
こんにちは！Safariチームのソフトウェアエンジニア、Kendall Bagleyです。

00:00:14.000 --> 00:00:32.000
WWDCで最後に集まってから丸1年が経ちましたが、今日は、今年のWWDCの新機能と過去1年間を通して見てきたものの両方から、SafariとWebKitのすべての素晴らしい機能と機能強化について話します。

00:00:32.000 --> 00:00:35.000
実際、かなり忙しい年でした!

00:00:35.000 --> 00:00:44.000
昨年の秋から、Safariの各リリースは、ウェブ開発者が求めていた皆さんが知っている新しいエキサイティングな機能を提供してきました。

00:00:44.000 --> 00:00:51.000
今年提供された新しい機能強化のそれぞれは、あなたが私たちと共有してきたフィードバックの最大のポイントのいくつかに対処することを目的としています。

00:00:51.000 --> 00:00:59.000
:Has() 疑似クラス、新しいフレックスボックスインスペクタ、さらにはコンテナクエリで親セレクタを追加するように。

00:00:59.000 --> 00:01:06.000
私たちは、ウェブのための最良かつ最も強力なソフトウェアを構築しながら、あなたの日常業務をより良く、より簡単にしたいと考えています。

00:01:06.000 --> 00:01:11.000
実際、ここにあるのは、今日取り次う新しいコンテンツのほんの一部です。

00:01:11.000 --> 00:01:18.000
しかし、この1つのセッションですべてをカバーできないほど多くのことがあります。

00:01:18.000 --> 00:01:27.000
昨年、7つのSafariリリースで合計162の新しいウェブプラットフォームの機能と改善がありました。

00:01:27.000 --> 00:01:34.000
私たちは、あなたがあなたのウェブサイトやウェブアプリを作るために使用する非常に多くの新しいツールを提供することを誇りに思っています。

00:01:34.000 --> 00:01:51.000
そして、macOSの場合、できるだけ早く新しくてエキサイティングなものを見るための最良の方法は、Safariテクノロジープレビューです。ここでは、SafariとWebKitの最新かつ最高のものを試すことができ、次に何が来るべきかを知るのに役立ちます。

00:01:51.000 --> 00:01:59.000
しかし、あなたが見たように、新機能がたくさんあるので、私たちがカバーしようとしているすべてを見てみましょう。

00:01:59.000 --> 00:02:23.000
今日は、新しいHTML機能、コードアーキテクチャを支援する多くのものを含むCSSの強化、新しいWebインスペクタツール、幅広い新しいWeb API、優れたJavaScriptとWebAssembly機能、セキュリティとプライバシーの改善を見ていきます。

00:02:23.000 --> 00:02:32.000
それでは、同僚と私が使うために作成しているウェブページを見て、HTMLの新機能から始めましょう。

00:02:32.000 --> 00:02:46.000
私は個人的に本当に私のワードローブをより持続可能にする方法として私の服を倹約し、再利用するのが好きで、私は服の交換ウェブサイトが私のチームにもそれを試してみる素晴らしい方法だと思いました。

00:02:46.000 --> 00:02:54.000
サイトの私のデザインには、あなたが好きな服を見つけたときに記入するフォームを表示するアイテムのリクエストボタンが含まれています。

00:02:54.000 --> 00:02:58.000
そして、そのフォームをページ全体の上部にオーバーレイで表示したいです。

00:02:58.000 --> 00:03:08.000
新しいダイアログ要素は、リクエストフォームに使用できる堅牢でアクセスしやすい方法でオーバーレイを作成する本当に簡単な方法を提供します。

00:03:08.000 --> 00:03:16.000
そして、CSSの新しい背景擬似要素は、モーダルの背後にある背景をスタイルすることを可能にします。

00:03:16.000 --> 00:03:19.000
アイテムをリクエストしてダイアログをアップしましょう。

00:03:19.000 --> 00:03:22.000
その影とアニメーションが見えますか？

00:03:22.000 --> 00:03:24.000
それは本当に素晴らしく見えます!

00:03:24.000 --> 00:03:32.000
その後、私たちのサイトでアイテムがリクエストされると、それを投稿した人がリクエストを受け入れることができる必要があります。

00:03:32.000 --> 00:03:38.000
ページの下部には、受信したすべてのリクエストをめくるためのカルーセルがあります。

00:03:38.000 --> 00:03:49.000
しかし、誰かがクリックやキーボードナビゲーションのいずれかで、最前面ではない項目の1つのボタンやテキストフィールドを誤って操作してほしくありません。

00:03:49.000 --> 00:03:52.000
これを修正するために不活性属性を使用できます。

00:03:52.000 --> 00:04:04.000
ここでJavaScriptで不活性属性を動的に適用することで、それらを切り替えるときに、現在選択されているスライドではないスライド上の要素のインタラクションを無効にします。

00:04:04.000 --> 00:04:20.000
また、inertを使用すると、支援技術のインタラクションを無効にし、スクリーンリーダーがこれらの無効なアイテムを声に出して読むのを防ぎ、インタラクションを意図した要素についてより明確なガイダンスを提供します。

00:04:20.000 --> 00:04:25.000
そして最後に、HTMLには、画像の新しい遅延読み込みがあります。

00:04:25.000 --> 00:04:44.000
私のサイトでは、すぐに読み込む必要があるヘッダーにいくつかのアイコンがありますが、最初の読み込み時に画面外にある衣料品の画像の場合、遅延読み込みを利用できるため、画像はユーザーがスクロールしたときにのみ読み込まれ、ページがより速く、より応答性が高くなります。

00:04:44.000 --> 00:04:52.000
これまでのサイトの様子が本当に好きで、支援技術を使用している人にとってもうまくいくでしょう。

00:04:52.000 --> 00:05:02.000
そして、これらのHTML機能は、今年もCSSでチェックすることがたくさんあるので、私たちは始めたばかりです。

00:05:02.000 --> 00:05:10.000
私たちのCSSの焦点の大部分は、より強力なアーキテクチャを通じてCSSをより簡単に再利用できるようにすることです。

00:05:10.000 --> 00:05:16.000
それにより、新しいWeb技術に対するナンバーワンの要求はコンテナクエリであることを知っています。

00:05:16.000 --> 00:05:22.000
そして、コンテナクエリがSafari 16で出荷されることを発表できることを嬉しく思います!

00:05:22.000 --> 00:05:27.000
サイズクエリとコンテナクエリユニットの両方を使用できます。

00:05:27.000 --> 00:05:32.000
ここでは、衣類交換ウェブサイトの代替レイアウトを試しています。

00:05:32.000 --> 00:05:42.000
私は服を再利用可能なコンポーネントに提示するカードを作り、そのコンポーネントをページレイアウトのいくつかの異なる場所にドロップしています。

00:05:42.000 --> 00:05:51.000
ここサイドバーでは、利用可能なスペースが少し狭いので、コンポーネント内のすべてのコンテンツを垂直に積み重ねたいです。

00:05:51.000 --> 00:06:05.000
アイテムのメイングリッドでは、最初のものをすべての利用可能なスペースを水平に占有し、幅広いレイアウトでより意味のある方法でコンテンツを配置するヒーローグラフィックとして特集したいと思います。

00:06:05.000 --> 00:06:10.000
メインコンテンツエリアの残りの項目は、より小さな列に分割する必要があります。

00:06:10.000 --> 00:06:17.000
そこで、中程度の水平スペースがあるときに機能する別のレイアウトを作成しました。

00:06:17.000 --> 00:06:35.000
メディアクエリではなく、コンテナクエリを使用してレイアウトの変更を処理し、このコンポーネントのレイアウトコードを一度だけ作成し、任意のサイズのコンテナ内のサイトの任意の場所でそのコンポーネントを使用でき、正しいレイアウトが常に適用されます。

00:06:35.000 --> 00:06:48.000
コンテナタイププロパティを使用して、コンテナに使用する要素と、インラインサイズのみに対して測定するか、インラインサイズとブロックサイズの両方に対して同時に測定するかを指定しました。

00:06:48.000 --> 00:06:58.000
オプションで、container-nameプロパティを使用してコンテナに名前を付けることができます。これにより、HTMLの構成方法の柔軟性が向上します。

00:06:58.000 --> 00:07:05.000
次に、@containerルールを使用して、コンテナのサイズに基づいて条件付きでスタイルを適用します。

00:07:05.000 --> 00:07:14.000
ここでは、衣類カードコンポーネントが250ピクセルより広い容器に入っている場合、グリッドは1列ではなく2列に変更されます。

00:07:14.000 --> 00:07:18.000
次にCSSアーキテクチャ：カスケードレイヤー。

00:07:18.000 --> 00:07:22.000
これはCSSカスケードへの強力な変更です。

00:07:22.000 --> 00:07:28.000
CSSの開始以来、カスケードはこれらの異なるレイヤーで構成されています。

00:07:28.000 --> 00:07:39.000
しかし、各レイヤー内の特定のセレクタの特異性に関係なく、著者スタイル（Web開発者として書くスタイル）は常にUAスタイルを打ち負かします。

00:07:39.000 --> 00:07:46.000
インラインスタイルは、階層の残りの部分で、著者スタイルなど、常に強力です。

00:07:46.000 --> 00:07:57.000
カスケードレイヤーは、この同じ概念を取り、特異性が各レイヤー内で独立して計算される独自のカスタムレイヤーを作成できます。

00:07:57.000 --> 00:08:04.000
使用されているセレクタの特異性に関係なく、1つのレイヤー全体が別のレイヤー全体に打ち負かします。

00:08:04.000 --> 00:08:13.000
そして、CSSでレイヤーを定義する順序によって、どのレイヤーが他のレイヤーよりも力を持っているかを決定します。

00:08:13.000 --> 00:08:20.000
カスケードレイヤーは、大規模なプロジェクトでCSSを設計し、時間の経過とともにそのコードを維持するための便利なツールになります。

00:08:20.000 --> 00:08:28.000
おそらく、あなたのチームは、プロジェクトのカスタムスタイルに使用しているオーバーライドやフレームワークからデザインシステムを分離するためにそれらを使用します。

00:08:28.000 --> 00:08:30.000
それは完全にあなた次第です!

00:08:30.000 --> 00:08:42.000
そして、CSSアーキテクチャのすべての驚くべき新しい機能強化を締めくくるためには:has()、長年の親セレクタとして機能する疑似クラスなどです。

00:08:42.000 --> 00:08:51.000
CSSの他のセレクタと組み合わせると、:has()は兄弟、属性、フォームフィールドの状態などを探すことができます。

00:08:51.000 --> 00:08:54.000
それは本当に強力です。

00:08:54.000 --> 00:09:01.000
ここでは、誰かが「緊急」にチェックを入れたときはいつでも、メッセージボックス全体を強調表示したい。彼らのメッセージの1つのチェックボックス。

00:09:01.000 --> 00:09:12.000
ここで:has疑似クラスを使用して、フォーム要素にそのチェックボックスがチェックされたタイプチェックボックスの入力があるときはいつでも、このCSSを適用すると言うことができます。

00:09:12.000 --> 00:09:16.000
そして、私はJavaScriptを使う必要さえありません。

00:09:16.000 --> 00:09:30.000
:has()、カスケードレイヤー、コンテナクエリを使用して、CSSアーキテクチャを処理するためのこれらすべての大きな改善が、Web開発者としての作業をはるかに向上させることを願っています。

00:09:30.000 --> 00:09:35.000
しかし、これらは私たちが興奮している唯一のCSSの追加ではありません。

00:09:35.000 --> 00:09:44.000
既存のビューポートユニットに似たツールが欲しかったのですが、スクロールによってビューポートのサイズが変わるデバイスでより便利です。

00:09:44.000 --> 00:09:48.000
そのために、皆さんのための新しいビューポートユニットがあります。

00:09:48.000 --> 00:09:53.000
ビューポートの高さを最も小さいときに知りたい場合は、svhを使用してください。

00:09:53.000 --> 00:09:57.000
ビューポートの高さが最大の場合、lvhを使用します。

00:09:57.000 --> 00:10:00.000
覚えておいてください：小さい場合はs、大きい場合はl。

00:10:00.000 --> 00:10:07.000
ビューポートの現在の実際の高さと常に一致するように変化する動的数値の場合は、dvhを使用します。

00:10:07.000 --> 00:10:10.000
そして、それは身長のためだけではありません。

00:10:10.000 --> 00:10:14.000
私たちは、さらに多くのビューポートユニットであなたをカバーしています。

00:10:14.000 --> 00:10:20.000
高度に使用されている高さの単位と一致する完全性に適した幅の単位があります。

00:10:20.000 --> 00:10:28.000
ブロックとインラインがあります。どちらも、テキストのフロー方法が異なる複数の言語で書く場合に便利です。

00:10:28.000 --> 00:10:32.000
そして、私たちはミニとマックスも忘れませんでした。

00:10:32.000 --> 00:10:39.000
しかし、それに反応するだけでなく、あなたのページにいくつかの動きを作りたいときはどうですか?

00:10:39.000 --> 00:10:48.000
アニメーションは以前、オブジェクトを移動させるための開始、終了、および期間を指定できる非常に宣言的でした。

00:10:48.000 --> 00:10:59.000
しかし、ページ上の要素をアニメーション化することは、湾曲したパスをたどろうとしたり、オフセットで移動したりすることもできます。

00:10:59.000 --> 00:11:07.000
そして、あなたがそれをクリックしたときにヘッダーに秘密のアニメーションを追加したいと思います、本当にそれが楽しいだろうと思っただけです。

00:11:07.000 --> 00:11:13.000
新しいオフセットパスを使用すると、オブジェクトをアニメーション化するパスを定義できます。

00:11:13.000 --> 00:11:19.000
オフセットパスでパスを設定し、キーフレーム効果にオフセット距離を使用します。

00:11:19.000 --> 00:11:30.000
次に、アニメーションプロパティを使用してキーフレーム効果を適用し、アニメーションで必要なコントロールをすべてCSSで提供します。

00:11:30.000 --> 00:11:43.000
また、通常、ブラウザエンジン自体によって定義されているWebの部分でも、ページをより詳細に制御したいと考えています。スクロールビヘイビアは、この最初の例にすぎません。

00:11:43.000 --> 00:11:51.000
ウェブの初めから、ウェブページの別の部分に移動するリンクをクリックすると、視覚的にジャンプとして表示されます。

00:11:51.000 --> 00:11:54.000
時々、これはあなたのユーザーにとって混乱しています。

00:11:54.000 --> 00:12:01.000
CSSのscroll-behaviorプロパティは、この動作をしたいかどうかを指定する方法を提供します。

00:12:01.000 --> 00:12:06.000
デフォルトでは、自動に設定されており、そのジャンプとして表示されます。

00:12:06.000 --> 00:12:14.000
スクロール動作をスムーズとして指定することで、代わりにページの次の場所にスムーズにスクロールするようにブラウザに依頼できます。

00:12:14.000 --> 00:12:21.000
JavaScript メソッド window.scroll()、scrollTo()、または scrollBy() でこれを行うこともできます。

00:12:21.000 --> 00:12:37.000
顧客を最もよく知っており、ブラウザエンジンのデフォルト以外で独自のWebページエクスペリエンスを定義できる必要があります。これは、:focus-visibleとアクセントカラーの使用が機能する場所でもあります。

00:12:37.000 --> 00:12:47.000
フォーカスインジケーターに特定のスタイルを適用したい場合は、おそらくフォーカスセレクターに精通しているでしょう。

00:12:47.000 --> 00:12:55.000
しかし、それを行うと、ブラウザベースのヒューリスティックを失うというアクセシビリティの落とし穴がいくつかあります。

00:12:55.000 --> 00:13:02.000
そして、私のサイトでは、組み込みのフォームカラーの代わりに、カスタムカラーを使用したいと思っています。

00:13:02.000 --> 00:13:09.000
フォーカスハイライトとチェックボックスの両方に、すでにヘッダーにあるティールカラーを使用しましょう。

00:13:09.000 --> 00:13:21.000
:Focus-visible擬似クラスを使用すると、選択したフォーカスインジケータのスタイルを設定できますが、その様式化されたインジケータは、ブラウザによってネイティブに表示される場合にのみ表示されます。

00:13:21.000 --> 00:13:30.000
また、フォームに別のカスタマイズレイヤーを追加するには、アクセントカラーを使用して、フォームコントロールUIのさまざまな部分の色を変更できます。

00:13:30.000 --> 00:13:35.000
そのチェックボックスやラジオボタンなどに影響します。 

00:13:35.000 --> 00:13:42.000
また、CSSでは、ますます多くのWebKitプレフィックスを置き換えています。

00:13:42.000 --> 00:13:55.000
これらは以前は実験的な機能を試すのに最適な方法でしたが、今では標準で定義されたプロパティに移行して、CSSの書き込みを容易にし、相互運用性を高めることができます。

00:13:55.000 --> 00:14:04.000
しかし、心配しないでください、WebKitプレフィックスを持つ既存のCSSは、Web標準のカウンターパートに移行する際に機能し続けます。

00:14:04.000 --> 00:14:14.000
Backface-visibility、print-color-adjust、およびtext-align：match-parentはすべて、接頭辞のカウンターパートとまったく同じです。

00:14:14.000 --> 00:14:23.000
Maskとtext-combine-uprightの両方が、標準と一致するようにプレフィックスバージョンから構文を更新しました。

00:14:23.000 --> 00:14:38.000
また、接頭辞なしの外観プロパティは、新しい自動値のサポートも追加しますが、標準仕様にまで上がったため、キャレットやリストアイテムなど、Safari 16のWebKit固有の値を削除しました。

00:14:38.000 --> 00:14:42.000
タイポグラフィの追加についても注意すべきことがたくさんあります。

00:14:42.000 --> 00:14:50.000
特に、カラーフォント内のカラーパレットを簡単に選択できるfont-paletteプロパティを追加しました。

00:14:50.000 --> 00:14:55.000
私のサイトの潜在的なロゴで試してみるのは本当にクールだと思います。私のサイトにいくつかの潜在的なロゴで試してみると思います。

00:14:55.000 --> 00:15:08.000
内蔵のダークパレットまたはライトパレットでどのように見えるか、または色のオーバーライドで私が望むものを正確にカスタマイズし、それを明るくするためにそこにいくつかの黄色を得るのがどのようなものかをテストすることができます。

00:15:08.000 --> 00:15:21.000
また、タイポグラフィでは、テキスト装飾スキップインクが追加され、下線やオーバーラインが文字や文字と交差したときに何が起こるかを制御できます。

00:15:21.000 --> 00:15:28.000
さらに、Cユニットにより、CJK文字をブロック方向に正確に並べることができます。

00:15:28.000 --> 00:15:36.000
中国語、日本語、韓国語などの言語でクリーンなタイポグラフィグリッドを作成するのに便利です。

00:15:36.000 --> 00:15:43.000
これらすべての素晴らしいCSS機能についての議論を締めくくるために、私たちは間違いなくサブグリッドについて話す必要があります。

00:15:43.000 --> 00:15:47.000
何年もの間、ウェブ上のレイアウトはかなり難しかった。

00:15:47.000 --> 00:15:55.000
CSSグリッドは革命的でしたが、グリッドコンテナの直接の子にのみ影響します。

00:15:55.000 --> 00:16:08.000
ここでは、CSSグリッドを使用してこれらのカードをレイアウトし、メディアクエリなしで列を追加および削除することで、ビューポートの幅に合わせてレイアウトを自動的に調整します。

00:16:08.000 --> 00:16:21.000
しかし、各カードのコンテンツのサイズは同じではありません。いくつかの見出しは長く、写真はアスペクト比が異なるため、ビジュアルは本当に乱雑に見えます。

00:16:21.000 --> 00:16:35.000
すべてのリクエストアイテムボタンとメッセージボックスをページ全体に並べ、他のカードのレイアウトに影響を与えるために1枚のカードに長いタイトルを付けたいので、それらはすべて同じ間隔になります。

00:16:35.000 --> 00:16:39.000
これで、サブグリッドを使用してこれを達成できます。

00:16:39.000 --> 00:16:49.000
私は各記事にグリッドを置き、「grid-template-rows: subgrid」と書くだけで、それらのすべてのグリッドを親のグリッドに結び付けました。

00:16:49.000 --> 00:17:01.000
Webインスペクタのグリッドインスペクタを使用して、必要なすべてのグリッドをオンにすることで、各衣類カードのすべてのコンテンツが完全に並んでいることがわかります。

00:17:01.000 --> 00:17:06.000
Webインスペクタを使用すると、多くのCSS作業が簡単になります。

00:17:06.000 --> 00:17:14.000
実際、Webインスペクタにいくつかの素晴らしい追加があり、試してみることに本当に興奮すると思います。

00:17:14.000 --> 00:17:23.000
まず、何が起こっているかを見ることができるとき、レイアウトは書きやすくなります。これはまさにWebインスペクタを非常に重要にしています。

00:17:23.000 --> 00:17:30.000
また、新しいFlexboxインスペクタを使用すると、要素間の間隔を実際に視覚化できます。

00:17:30.000 --> 00:17:35.000
私のウェブサイトでは、これらのアイコンをヘッダーに追加するのに苦労していました。

00:17:35.000 --> 00:17:51.000
私がする必要があるのは、要素を検査し、レイアウトタブに移動することだけです。今はグリッドに関心がないので、先に進んでそのセクションを折りたたんで、新しいFlexbox Inspectorに直行できます。

00:17:51.000 --> 00:17:57.000
ワンクリックですべてのビューをオンにすることもできますが、それでもスムーズなパフォーマンスが得られます。

00:17:57.000 --> 00:18:09.000
そして、すべてのビューをオンにすると、ハッシュマークとコンテナボックスで、私の要素がどのように配置されているか、空きスペースがどのようにビューを占有しているかをはっきりと見ることができます。

00:18:09.000 --> 00:18:16.000
だから今、私は新しいアライメントエディタを使用できるアライメントを正しく取得していることを確認したいです。

00:18:16.000 --> 00:18:21.000
スタイルタブに移動して、整列項目の横にある新しいボタンを見つけることができます。

00:18:21.000 --> 00:18:30.000
ここでは、さまざまなオプションを切り替えて、ヘッダーに最適なものを見つけることができます。また、justify-contentでも同じことができます。

00:18:30.000 --> 00:18:39.000
繰り返しますが、各オプションを切り替えて、私がちょうどいいと思うものに着陸するだけです。

00:18:39.000 --> 00:18:54.000
また、黄色のアイコンは少し小さすぎると思うので、名前に「medium」の変数を使用していると思われる赤いアイコンと同じサイズにしてみたいと思いますが、本当にフルネームを思い出せません。

00:18:54.000 --> 00:19:02.000
黄色のアイコンの1つを検査し、インスペクタでその高さを編集することで、サイズを変更してみることができます。

00:19:02.000 --> 00:19:14.000
そして、新しいCSSファジーオートコンプリートのおかげで、「medium」と入力すると、「medium」が名前の末尾にあるにもかかわらず、必要な変数がポップアップ表示されます。

00:19:14.000 --> 00:19:20.000
そして、それらの黄色のアイコンは間違いなくもう小さすぎません。

00:19:20.000 --> 00:19:29.000
そして、異なるアイコンの他の変数が私が検査している要素に使用されていないとき、それらは私たちの新しいCSSツールで隠されます。

00:19:29.000 --> 00:19:34.000
しかし、心配しないでください、あなたがそれらを必要とするときにそれらを明らかにするボタンがあります。

00:19:34.000 --> 00:19:44.000
そして、おそらく今年のWeb Inspectorにとって最もエキサイティングなことに、Safari Web Inspectorの開発者ツール拡張機能のサポートを発表できることを嬉しく思います。

00:19:44.000 --> 00:19:55.000
お気に入りの開発者ツール拡張機能の作成者は、他のブラウザで使用しているのと同じ基盤となるAPIを使用して、Safariに移植できるようになりました。

00:19:55.000 --> 00:20:12.000
Web Inspectorの拡張機能の作成方法を学び、新しいAPIを探索し、自分で使用を開始するように設定することに興味がある場合は、今年のWWDCで「Create Safari Web Inspector Extensions」を必ず見てください。

00:20:12.000 --> 00:20:22.000
今、私たちはフロントエンド技術の新機能の多くをカバーしたので、ギアを切り替えて、ウェブAPIの新機能に入りましょう。

00:20:22.000 --> 00:20:26.000
ウェブプッシュのサポートを発表できることをとても嬉しく思います。

00:20:26.000 --> 00:20:31.000
macOS VenturaのSafari 16で利用可能になります。

00:20:31.000 --> 00:20:35.000
来年はiOSとiPadOSに登場します。

00:20:35.000 --> 00:20:41.000
ウェブプッシュを使用すると、ウェブサイトやウェブアプリからユーザーに通知をリモートで送信できます。

00:20:41.000 --> 00:20:46.000
これは、完全に相互運用可能な標準ベースの実装です。

00:20:46.000 --> 00:20:55.000
すでにウェブプッシュを実装していて、他のブラウザで動作する場合は、変更せずにSafariで動作するはずです。

00:20:55.000 --> 00:20:58.000
また、Apple Developerアカウントも必要ありません。

00:20:58.000 --> 00:21:06.000
詳細を知るには、WWDC22で「Meet Web Push for Safari」をご覧ください。

00:21:06.000 --> 00:21:13.000
ウェブプッシュに興奮しているなら、おそらく新しいウェブアプリのマニフェストの改善にも興奮するでしょう。

00:21:13.000 --> 00:21:20.000
これで、ウェブアプリをマニフェストファイルのホーム画面に保存するときに使用するアイコンを定義できます。

00:21:20.000 --> 00:21:28.000
マニフェストのアイコンを優先するには、HTMLヘッドにapple-touch-iconが定義されていないことを確認する必要があります。

00:21:28.000 --> 00:21:44.000
他のモバイルプラットフォームに別のアイコンを配信しながら、iOSとiPadOSに1つのアイコンを配信したい場合は、apple-touch-iconを使用して、そのHTMLヘッドでAppleデバイスのアイコンを定義することで、そうすることができます。

00:21:44.000 --> 00:21:52.000
また、どちらの場所でもアイコンを宣言しない場合、ユーザーがサイトをホーム画面に保存すると、サイトのスクリーンショットを取得するだけです。

00:21:52.000 --> 00:22:11.000
エキサイティングなことに、ユーザーが共有メニューから「ホーム画面に追加」を選択してマニフェストファイルを読み込むのを待つ必要がなくなりました。つまり、そのマニフェストファイルを使用して、すべてのサイトでWebページの特性を定義し、メタタグを使用する必要性をさらに減らすことができます。

00:22:11.000 --> 00:22:20.000
APIを継続して、同じ起源を持つ複数のブラウジングコンテキストでのWebページの使用を改善するために多くのことを行ってきました。

00:22:20.000 --> 00:22:25.000
ブロードキャストチャンネルを使用すると、これらの異なるブラウジングコンテキスト間で通知を送信できます。

00:22:25.000 --> 00:22:32.000
誰かが衣類交換ウェブサイトを使用していて、同時に2つのウィンドウで開いていると想像してみましょう。

00:22:32.000 --> 00:22:35.000
その後、彼らは1つの窓に服を主張します。

00:22:35.000 --> 00:22:43.000
メッセージを投稿して、その使用できない状態を他の開いているタブやウィンドウに同期することができます。

00:22:43.000 --> 00:22:49.000
しかし、バックグラウンドでタブを更新するのではなく、サイト用に保存されたファイルを更新しているのかもしれません。

00:22:49.000 --> 00:22:54.000
そのためには、ファイルシステムアクセスAPIが追加されました。

00:22:54.000 --> 00:23:05.000
今年は、オリジンに基づくプライベートストレージであるオリジンプライベートファイルシステムから始めて、複数のリリースでこのAPIを段階的に更新しました。

00:23:05.000 --> 00:23:13.000
例えば、私の衣類交換サイトには、apple.comのような他のサイトがファイルを読んでいないでしょう。

00:23:13.000 --> 00:23:29.000
次に、たまたま作成したばかりのドラフトファイルで行っているように、サイトのルートディレクトリから取得した既存のファイルを読み取るFileSystemFileHandleのgetFile（）メソッドを使用してAPIに追加しました。

00:23:29.000 --> 00:23:37.000
それでは、今年最も活気のあるAPIの追加を、新しい色の豊かさで見てみましょう。

00:23:37.000 --> 00:23:45.000
ディスプレイP3色空間は、RGBに存在しない色を表現することを可能にします。

00:23:45.000 --> 00:23:48.000
ここでは、カラーピッカーの例をいくつか紹介します。

00:23:48.000 --> 00:23:53.000
曲がりくねった白い線の左側には、RGBに存在する色があります。

00:23:53.000 --> 00:23:58.000
そして、線の右側には、P3でのみ利用可能な色があります。

00:23:58.000 --> 00:24:03.000
2016年には、ビデオと写真のP3サポートを追加しました。

00:24:03.000 --> 00:24:12.000
昨年、私たちはCSSカラーレベル4で定義された新しいカラー構文を実装する最初のブラウザエンジンになることに興奮しました。

00:24:12.000 --> 00:24:18.000
今年は、キャンバス要素内のコンテンツにP3カラーのサポートを追加しました。

00:24:18.000 --> 00:24:29.000
したがって、今日のすべての素晴らしいデバイスのフルカラー機能を活用し始めることができる90年代からデバイスに基づいた色を使用する必要はありません。

00:24:29.000 --> 00:24:50.000
しかし、シャドウレルム、Webロック、ResizeObserverSizeインターフェイスのResizeObserver APIの更新されたサポートなど、昨年の新しいWeb APIでさらに多くのことがチェックできます。これは、要素のボックスサイジングプロパティの変更を観察するのに役立ちます。

00:24:50.000 --> 00:24:58.000
すべての新しいAPIの追加、そしてもちろん、すべての新機能についても、試してみるべきことがたくさんあります。

00:24:58.000 --> 00:25:02.000
実際、私たちはまだカバーすることがもっとあります。

00:25:02.000 --> 00:25:08.000
それでは、次にJavaScriptとWebAssemblyの新機能をすべて取りましょう。

00:25:08.000 --> 00:25:20.000
ウェブサイトがワーカーを使用していて、これらのワーカーのインスタンスをタブやウィンドウ間で共有したい場合、新しい共有ワーカーインターフェイスは間違いなく役立ち、メモリ使用量を減らす可能性があります。

00:25:20.000 --> 00:25:31.000
バックグラウンドで実行したいすべてのタスクに対して新しいワーカーを生成する代わりに、同じオリジンを持つ各ブラウジンコンテキストで1人のワーカーを使用できます。

00:25:31.000 --> 00:25:40.000
各スクリプトは、同じ方法で共有ワーカーを作成し、同じポートを使用してメッセージを受信して投稿することができます。

00:25:40.000 --> 00:25:47.000
共有ワーカーは、すべての異なるスクリプトから送信されたメッセージを受信して応答することができます。

00:25:47.000 --> 00:25:56.000
これにより、サーバーの需要が少なくなり、Webページが顧客にとって高速で応答性の高いものになります。

00:25:56.000 --> 00:26:00.000
私たちはまた、あなたに示すために配列機能の全体の配列を持っています。

00:26:00.000 --> 00:26:17.000
最初から検索するときに reverse() を使用して配列を変異させる代わりに、「シューストリング」を含む最後のアイテムのアイテムとインデックスを見つけるためにここで行ったように、findLast() メソッドと findLastIndex() メソッドを使用できるようになりました。

00:26:17.000 --> 00:26:22.000
新しいat()メソッドにより、配列の末尾からの検索もさらに簡単になります。

00:26:22.000 --> 00:26:35.000
括弧を使用すると、インデックスが正の場合にうまく機能しますが、at()を使用すると、負の値でインデックスを作成する追加機能により、コードがより簡潔で読みやすくなります。

00:26:35.000 --> 00:26:46.000
しかし、その数の新しいアレイ機能があっても、私たちがあなたのために手に入れた新しい国際化機能の全く数に勝るものはありません。

00:26:46.000 --> 00:26:54.000
WebKitは、過去1年間を通じて、Intlの実装に定期的な更新を追加し続けています。

00:26:54.000 --> 00:27:09.000
LocaleとDisplayNamesの更新、およびIntl Enumeration APIを使用した通貨のおかげで、NumberFormat、カレンダーの新しいメソッドを使用して、さまざまなナンディングシステムのサポートが追加されました。

00:27:09.000 --> 00:27:24.000
そして、私が言ったように、今年のIntlの実装には、世界中のユーザーに対応するために試してみて探索するものが不足していないことがたくさんあります。

00:27:24.000 --> 00:27:38.000
そして、C、Objective C、Swiftなど、あらゆる種類の異なるコーディング言語で既存のコードを持っているすべての人のために、WebAssemblyは書き換えることなくそれらを実行します。

00:27:38.000 --> 00:27:54.000
そして、今年の改善により、WebAssemblyを使用するWebアプリは、アドレス指定可能なメモリが4GBに拡張され、新しいゼロコストの例外処理によるパフォーマンスの向上により、より強力になっています。

00:27:54.000 --> 00:28:01.000
全体として、JavaScriptとWebAssemblyがここで試してみるためのエキサイティングなものがいくつかあります。

00:28:01.000 --> 00:28:16.000
また、WebAssemblyといえば、私たちが開発するウェブのユーザーを保護するだけでなく、開発者としてあなたに新しい可能性をもたらすセキュリティとプライバシーの強化もあります。

00:28:16.000 --> 00:28:33.000
新しいクロスオリジンオープナーポリシーとクロスオリジンエンベダーポリシーHTTPレスポンスヘッダーの両方で、サイトはプロセスの分離をオプトインできます。つまり、サイトは独自の専用のwebContentプロセスで実行されます。

00:28:33.000 --> 00:28:46.000
WebAssemblyスレッドを使用して複数のスレッドで並行して実行することで、多くのアプリが恩恵を受けることができることを知っており、これらの新しいヘッダーを使用すると、安全に行うことができます。

00:28:46.000 --> 00:28:55.000
2回目のセキュリティ強化には、コンテンツセキュリティポリシーレベル3のサポートが改善されたHTTPヘッダーも含まれています。

00:28:55.000 --> 00:29:04.000
CSPは、コンテンツの読み込みに対するセキュリティ制御を強化し、クロスサイトスクリプティングやその他の脆弱性のリスクを軽減します。

00:29:04.000 --> 00:29:11.000
レベル3のアップデートでは、最もエキサイティングな追加は、新しい厳密でダイナミックなソース表現でした。

00:29:11.000 --> 00:29:21.000
Strict-dynamicの設計者は、ノンスを使用して特定のスクリプトを許可し、その信頼をすでに信頼されているスクリプトによってロードされたスクリプトに拡張できることに気づきました。

00:29:21.000 --> 00:29:24.000
明示的な許可リストは必要ありません。

00:29:24.000 --> 00:29:26.000
ヘッダーがどれだけシンプルになるか見てください。

00:29:26.000 --> 00:29:32.000
潜在的にあまりにも多くのことを許可する可能性のあるドメインの元の長いリストから行きます。

00:29:32.000 --> 00:29:45.000
そして、それで、私たちはセキュリティとプライバシー機能を締めくくります。これはまた、私たちが今日カバーするすべての終わりに私たちをもたらしますが、あなた自身で探求することはさらにあります。

00:29:45.000 --> 00:30:03.000
たとえば、getUserDisplay() API、WebRTC Perfect Negotiation、In-bandチャプタートラック、およびrequestVideoFrameCallback()を使用して特定のSafariウィンドウをキャプチャするためのサポートを含むメディアアップデートがありました。

00:30:03.000 --> 00:30:12.000
マニフェストバージョン3をサポートするWeb拡張機能の多くのクールな追加と、新しいWeb拡張機能APIの束。

00:30:12.000 --> 00:30:41.000
今日ここで取り上げられているこれらすべての機能を深く掘り下げ、過去1年間にSafariとWebKitで開発されたすべての162の機能と改善点を探索するには、Safari Technology Previewをダウンロードして将来どうなるかについていくようにしてください。リリースノート、ブログ記事、およびWeb Inspectorの広範なドキュメントを含むwebkit.orgのすべての素晴らしいコンテンツをチェックして、Webテクノロジーを探索してください。

00:30:41.000 --> 00:30:47.000
そして、いつものように、バグレポートを提出して、あなたの考えと次に見たいものをお知らせください。

00:30:47.000 --> 00:31:03.000
HTML、CSS、JavaScript、DOM API、またはWebインスペクタに関するWebKitのバグに遭遇した場合は、bugs.webkit.orgのWebKitのバグ追跡システムを通じてフィードバックを送信してください。

00:31:03.000 --> 00:31:11.000
そして、Safariインターフェースの提案やバグについては、Appleのフィードバックアシスタントでファイルの問題があります。

00:31:11.000 --> 00:31:24.000
私たちは、来年登場するすべてのSafariとSafariテクノロジープレビューリリースで、あなたのようなウェブ開発者の仕事をはるかに良くする素晴らしい機能の多くを提供することを楽しみにしています。

00:31:24.000 --> 00:31:30.000
今日はご参加いただきありがとうございます。WWDCで最高の時間を過ごせることを願っています。

00:31:30.000 --> 00:31:32.000
さようなら！

00:31:32.000 --> 23:59:59.000
♪

