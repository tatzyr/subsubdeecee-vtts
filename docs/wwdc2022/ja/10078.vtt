WEBVTT

00:00:00.000 --> 00:00:03.000
♪まろやかなインストゥルメンタルヒップヒップミュージック♪

00:00:03.000 --> 00:00:10.000
♪

00:00:10.000 --> 00:00:21.000
こんにちは、私はVidhi Goelです。このビデオでは、アプリのネットワーク遅延を減らし、より応答性を高める方法について話します。

00:00:21.000 --> 00:00:29.000
まず、アプリをレスポンシブにするためにレイテンシを減らすことが重要である理由を説明します。

00:00:29.000 --> 00:00:40.000
次に、不必要な遅延を取り除くために、アプリとサーバーでできることのリストを調べます。

00:00:40.000 --> 00:00:47.000
最後に、ネットワーク自体の遅延を減らすために何ができるかを紹介します。

00:00:47.000 --> 00:00:55.000
ネットワークレイテンシは、データが1つのエンドポイントから別のエンドポイントに取得するのにかかる時間です。

00:00:55.000 --> 00:01:01.000
コンテンツがアプリにどれだけ早く配信できるかを決定します。

00:01:01.000 --> 00:01:11.000
ネットワークを使用するすべてのアプリは、ネットワークトランザクションが遅くなり、アプリ体験が悪くなる可能性があります。

00:01:11.000 --> 00:01:20.000
たとえば、ビデオ通話がフリーズしたり、遅れたりして、会議を中断することがあります。

00:01:20.000 --> 00:01:31.000
これに対処するために、人々はしばしば帯域幅をアップグレードするためにサービスプロバイダーに電話をかけますが、それでも問題はまだ存在します。

00:01:31.000 --> 00:01:40.000
この問題の根本原因を突き止めるには、アプリのパケットがネットワーク内でどのように移動するかを理解する必要があります。

00:01:40.000 --> 00:01:48.000
アプリやフレームワークがサーバーからデータを要求すると、パケットはネットワークスタックによって送信されます。

00:01:48.000 --> 00:01:56.000
多くの場合、パケットはネットワークに遅延なくサーバーに直接送信されると仮定されます。

00:01:56.000 --> 00:02:05.000
しかし、実際には、ネットワークの最も遅いリンクには、通常、処理するパケットの大きなキューがあります。

00:02:05.000 --> 00:02:16.000
したがって、アプリからのパケットは、その前のパケットが処理されるまで、実際にはこの大きなキューの後ろで待ちます。

00:02:16.000 --> 00:02:24.000
最も遅いリンクでのこのキューイングは、アプリとサーバー間の各往復の期間を延ばします。

00:02:24.000 --> 00:02:34.000
この問題は、アプリのリクエストに対する最初の応答を得るために複数の往復が必要な場合に悪化します。

00:02:34.000 --> 00:02:50.000
たとえば、TCPでTLS 1.2を使用するときに最初の応答パケットを取得する時間は、各往復の期間に4回のトリップを乗じた時間です。

00:02:50.000 --> 00:03:02.000
各往復時間は、ネットワーク内のキューイングによってすでに膨らんでいることを考えると、結果として生じる合計時間は単に長すぎます。

00:03:02.000 --> 00:03:15.000
アプリの応答性を決定するために乗算する2つの要因があります。各往復の期間と往復の回数です。

00:03:15.000 --> 00:03:24.000
これらを減らすと、アプリのレイテンシが下がり、アプリの応答性が向上します。

00:03:24.000 --> 00:03:33.000
ページの読み込み時間に対する帯域幅の増加とレイテンシの減少の影響を調べる研究がありました。

00:03:33.000 --> 00:03:44.000
最初のテストでは、レイテンシは固定され、帯域幅は1から10Mbpsに段階的に増加します。

00:03:44.000 --> 00:03:56.000
最初は、帯域幅を1から2Mbpsに増やすと、ページの読み込み時間がほぼ40%短縮され、これは素晴らしいことです。

00:03:56.000 --> 00:04:07.000
しかし、4Mbpsの後、増加するたびに、ページの読み込み時間がほとんど改善されません。

00:04:07.000 --> 00:04:14.000
これが、ギガビットインターネットにアップグレードした後でもアプリが遅くなる可能性がある理由です。

00:04:14.000 --> 00:04:28.000
一方、レイテンシテストの結果は、レイテンシが20ミリ秒減少するごとに、ページの読み込み時間が直線的に改善されることを示しています。

00:04:28.000 --> 00:04:35.000
そして、これらの結果は、アプリ内のすべてのネットワークアクティビティに適用されます。

00:04:35.000 --> 00:04:45.000
さて、レイテンシを減らし、アプリの応答性を高めるための簡単なアクションをいくつか確認します。

00:04:45.000 --> 00:04:57.000
IPv6、TLS 1.3、HTTP/3などの最新のプロトコルを採用することで、アプリのレイテンシを大幅に削減できます。

00:04:57.000 --> 00:05:12.000
そして、アプリでURLSessionとNetwork.framework APIを使用するだけで、これらのプロトコルはサーバーで有効にすると自動的に使用されます。

00:05:12.000 --> 00:05:32.000
展開以来、HTTP / 3の使用が絶えず増加しており、わずか1年以内にWebトラフィックの20%がすでにHTTP / 3を使用しており、成長を続けています。

00:05:32.000 --> 00:05:42.000
異なるHTTPバージョンのSafariトラフィックを比較すると、HTTP/3はそれらすべての中で最速です。

00:05:42.000 --> 00:05:57.000
HTTP/3リクエストは、リクエスト完了時間の中央値を往復時間の倍数として見ると、HTTP/1と比較して半分強の時間がかかります。

00:05:57.000 --> 00:06:03.000
これは、アプリのリクエストがはるかに速く完了することを意味します。

00:06:03.000 --> 00:06:15.000
デバイスがWi-Fiから携帯電話に移動すると、新しい接続を再確立するのに時間がかかり、アプリケーションが停止する可能性があります。

00:06:15.000 --> 00:06:20.000
接続移行を使用すると、これらのストールが排除されます。

00:06:20.000 --> 00:06:32.000
オプトインするには、URLSession 設定または NWParameters で multipathServiceType プロパティを .handover に設定します。

00:06:32.000 --> 00:06:39.000
このオプションを有効にして、アプリで動作することを確認してください。

00:06:39.000 --> 00:06:52.000
UDPを直接使用する独自のプロトコルを設計する場合、iOS 16とmacOS Venturaはデータグラムを送信するより良い方法を導入します。

00:06:52.000 --> 00:07:07.000
QUICデータグラムは、プレーンUDPよりも多くの利点を提供します。最も重要なのは、QUICデータグラムがネットワーク内の輻輳に反応し、ラウンドトリップ時間を低く抑え、パケット損失を減らすことです。

00:07:07.000 --> 00:07:19.000
クライアントをオプトインするには、QUICオプションでisDatagramをtrueに設定し、使用する最大データグラムフレームサイズを設定します。

00:07:19.000 --> 00:07:27.000
データグラムフローを作成した後、他のQUICストリームと同じように送受信できます。

00:07:27.000 --> 00:07:32.000
これで、待ち時間を減らすためにアプリで何をすべきかがわかりました。

00:07:32.000 --> 00:07:39.000
次に、サーバーがアプリの応答性にどのように影響するかを説明します。

00:07:39.000 --> 00:07:49.000
最高級のハードウェアで実行されることが多いにもかかわらず、サーバーが実際にアプリの低速化の原因になる可能性があります。

00:07:49.000 --> 00:08:03.000
macOS Montereyにネットワーク品質ツールを導入しました。このツールを使用して、サービスプロバイダーのネットワークとサーバーのバッファの肥大化を測定できます。

00:08:03.000 --> 00:08:09.000
ネットワーク品質ツールの宛先として機能するようにサーバーを設定する必要があります。

00:08:09.000 --> 00:08:22.000
完了したら、まずAppleのデフォルトサーバーに対して、次に自分で設定したサーバーに対して、networkQualityツールを実行します。

00:08:22.000 --> 00:08:35.000
ツールがデフォルトのサーバーを使用してうまく採点するが、自分のサーバーと話すときにあまりうまくない場合は、サーバーの応答性を向上させる余地があるかもしれません。

00:08:35.000 --> 00:08:50.000
さて、このテクニックを使用して、皆さんが今やっていること、つまりストリーミングビデオを改善した例を紹介します。

00:08:50.000 --> 00:09:01.000
ビデオの別の場所にスキップして、リバフしている間に長時間待つことになるという経験があるかもしれません。

00:09:01.000 --> 00:09:08.000
そこで、ランダムアクセスにおけるこの遅さの理由を調査しました。

00:09:08.000 --> 00:09:18.000
ネットワーク品質ツールを使用してストリーミングサーバーの動作をテストしたところ、応答性スコアが低いことがわかりました。

00:09:18.000 --> 00:09:23.000
右側では、WWDCのビデオをストリーミングしました。

00:09:23.000 --> 00:09:26.000
それから、私はビデオで先にスキップしました。

00:09:26.000 --> 00:09:32.000
ビデオが再バッファリングされている間、画面には何も表示されませんでした。

00:09:32.000 --> 00:09:36.000
数秒後、ビデオが現れました。

00:09:36.000 --> 00:09:46.000
macOSのネットワーク品質ツールからの詳細な出力の助けを借りて、サーバーに巨大なキューイングがあることがわかりました。

00:09:46.000 --> 00:09:52.000
そこで、サーバーの設定を見てみました。

00:09:52.000 --> 00:10:09.000
具体的には、それぞれ4MB、256KB、4MBに設定されたTCP、TLS、およびHTTPバッファサイズを調べました。

00:10:09.000 --> 00:10:14.000
RAMが豊富であるため、バッファは巨大でした。

00:10:14.000 --> 00:10:22.000
しかし、いくつかのバッファリングが良いからといって、必ずしもより多くのバッファリングが良いとは限りません。

00:10:22.000 --> 00:10:41.000
私たちの応答性の測定は、この正確な問題を強調しました - 新しく生成されたパケットは、これらの大きなバッファの古いデータの後ろにキューに入れられ、これは最新のパケットの配信に多くの追加の遅延を引き起こしました。

00:10:41.000 --> 00:10:57.000
そのため、バッファサイズをHTTPの場合は256KB、TLSの場合は16KB、TCPの場合は128KBに縮小しました。

00:10:57.000 --> 00:11:05.000
これは、設定されたオプションを示すApache Traffic Serverの設定ファイルです。

00:11:05.000 --> 00:11:16.000
TCPが送信されていないローウォーターマークは、バッファリングを下げるために有効になった他のオプションとともに128KBに設定されました。

00:11:16.000 --> 00:11:28.000
TLSでは、動的レコードサイズを有効にし、HTTP/2では、低ウォーターマークとバッファブロックサイズを減らしました。

00:11:28.000 --> 00:11:41.000
Apacheトラフィックサーバーにこれらの構成を使用することをお勧めします。別のWebサーバーを使用している場合は、同等のオプションを探してください。

00:11:41.000 --> 00:11:47.000
これらの変更を行った後、ネットワーク品質ツールを再び実行しました。

00:11:47.000 --> 00:11:52.000
そして、今回は高いRPMスコアを獲得しました!

00:11:52.000 --> 00:12:03.000
右側では、同じビデオをストリーミングしましたが、今回はスキップすると、ビデオがすぐに再開されました。

00:12:03.000 --> 00:12:11.000
サーバーでの不要なキューイングを取り除くことで、ランダムアクセスの応答性が向上しました。

00:12:11.000 --> 00:12:24.000
アプリがネットワークをどのように使用しているかに関係なく、サーバー上のこれらの変更により、アプリの応答性が向上し、ユーザーエクスペリエンスが向上します。

00:12:24.000 --> 00:12:29.000
それがあなたのアプリを改善し、サーバーを更新する方法です。

00:12:29.000 --> 00:12:37.000
応答性に大きな影響を与える3番目の要因があります。ネットワーク自体です。

00:12:37.000 --> 00:12:44.000
Appleは、iOS 15とmacOS Montereyにネットワーク品質ツールを導入した。

00:12:44.000 --> 00:12:52.000
それ以来、他の人は同じ方法論を使用してネットワーク品質テストを開発してきました。

00:12:52.000 --> 00:12:56.000
波形はバッファブロートテストを開始しました。

00:12:56.000 --> 00:13:03.000
Goで書かれた応答性テストのオープンソース実装があります。

00:13:03.000 --> 00:13:11.000
そして、OoklaはSpeedtestアプリに応答性測定を追加しました。

00:13:11.000 --> 00:13:24.000
Ooklaのアプリは往復時間をミリ秒単位で表示し、60,000をその数で割ると、1分あたりの往復数、つまりRPMが表示されます。

00:13:24.000 --> 00:13:30.000
これらのツールを使用して、自分のネットワークがどれだけうまく機能しているかを測定できます。

00:13:30.000 --> 00:13:37.000
ネットワークの遅延を理解する最善の方法は、遅延に敏感なアプリケーションです。

00:13:37.000 --> 00:13:43.000
だから、私の画面共有体験をリモートマシンに見せます。

00:13:43.000 --> 00:13:54.000
私は、そのネットワークを共有する他のデバイスからのトラフィックを使用して、代表的なアクセスネットワークを模倣するようにネットワーク条件を設定しました。

00:13:54.000 --> 00:14:01.000
ここでは、画面共有を使用してリモートマシンにログオンしました。

00:14:01.000 --> 00:14:09.000
異なるFinderメニューをクリックしましたが、各メニューの表示が非常に遅かったです。

00:14:09.000 --> 00:14:21.000
このインタラクションがどれだけ遅れたかを確認するために、ローカルマシンで時間を表示するアプリを起動し、リモートマシンで同じアプリを起動しました。

00:14:21.000 --> 00:14:34.000
これらのコンピュータの時間は同期されていますが、私のリモート画面は定期的に更新されておらず、時間が数秒遅れています。

00:14:34.000 --> 00:14:50.000
この更新が遅れた理由は、ネットワークの最も遅いリンクに大きなキューが存在し、画面共有アプリからのパケットがこの大きなキューで立ち往生していたためです。

00:14:50.000 --> 00:14:59.000
このキューイングの問題を解決するために、AppleはL4Sと呼ばれる新しい技術でネットワーキングコミュニティと協力しています。

00:14:59.000 --> 00:15:06.000
iOS 16とmacOS Venturaでベータ版として利用可能です。

00:15:06.000 --> 00:15:14.000
L4Sは、キューイングの遅延を大幅に削減し、混雑損失をゼロにします。

00:15:14.000 --> 00:15:29.000
一貫して短いキューを維持するために、ネットワークはパケットをドロップするのではなく、明示的に輻輳を通知し、送信者はネットワークからの輻輳フィードバックに基づいて送信速度を調整します。

00:15:29.000 --> 00:15:41.000
これにより、パケットの損失なしにネットワーク内で非常に低いキューイングを維持することが可能になり、アプリは非常に応答性が高くなります。

00:15:41.000 --> 00:15:48.000
さて、L4Sが画面共有をどのように改善したかを見てみましょう。

00:15:48.000 --> 00:15:57.000
ここでは、同じマシンと同じネットワークを使用しましたが、今回はL4Sを有効にしました。

00:15:57.000 --> 00:16:02.000
別のFinderメニューをクリックすると、すぐに開きました。

00:16:02.000 --> 00:16:06.000
私は両方のマシンでタイムアプリを起動しました。

00:16:06.000 --> 00:16:16.000
そして今、リモート画面とローカルマシンの両方の時間はほぼ完全に同期しています。

00:16:16.000 --> 00:16:21.000
この技術は画面共有のためだけではありません。

00:16:21.000 --> 00:16:31.000
L4Sは今日のすべてのアプリを改善し、今日でも不可能な将来のアプリの扉を開きます。

00:16:31.000 --> 00:16:46.000
このチャートは、同じネットワークを共有する他のデバイスからのトラフィックと同時に実行されていた画面共有アプリからのパケットの観測された平均往復時間をプロットします。

00:16:46.000 --> 00:16:56.000
古典的なキューイングとL4Sを比較すると、L4Sとの往復時間が大幅に短縮されることを示しています。

00:16:56.000 --> 00:17:05.000
これが私の画面共有体験が劇的に改善された主な理由です。

00:17:05.000 --> 00:17:11.000
L4SでHTTP/3またはQUICを使用するアプリをテストします。

00:17:11.000 --> 00:17:22.000
開発者設定内のiOS 16またはデフォルトの書き込みを介してmacOS VenturaでL4Sを有効にすることができます。

00:17:22.000 --> 00:17:34.000
Linuxサーバーを使用してテストするには、QUICの実装は正確なECNとスケーラブルな輻輳制御アルゴリズムをサポートする必要があります。

00:17:34.000 --> 00:17:50.000
L4S対応ネットワークが展開されたときに準備ができていることを確認するために、L4Sとの互換性についてアプリをテストし、遭遇する可能性のある問題についてフィードバックを提供します。

00:17:50.000 --> 00:17:58.000
これで、アプリの応答性を向上させるには、レイテンシを減らすことが不可欠であることを知っています。

00:17:58.000 --> 00:18:09.000
したがって、HTTP/3とQUICを採用して、往復の数を減らし、アプリへのコンテンツの配信を高速化します。

00:18:09.000 --> 00:18:17.000
サーバー上の不要なキューイングを排除して、より応答性の高いインタラクションを提供します。

00:18:17.000 --> 00:18:25.000
開発者設定で有効にして、アプリのL4Sとの互換性をテストし、フィードバックを提供します。

00:18:25.000 --> 00:18:32.000
そして最後に、L4Sサポートを有効にすることについてサーバープロバイダーに相談してください。

00:18:32.000 --> 00:18:34.000
見てくれてありがとう!

00:18:34.000 --> 23:59:59.000
♪

