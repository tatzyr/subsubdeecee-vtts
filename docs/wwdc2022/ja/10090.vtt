WEBVTT

00:00:00.000 --> 00:00:14.000
- こんにちは、TextKitとテキストビューの新機能へようこそ!

00:00:14.000 --> 00:00:18.000
私はDonna Tomで、TextKitのエンジニアです。

00:00:18.000 --> 00:00:30.000
iOS 15とmacOS Montereyでは、パフォーマンス、正確性、安全性が向上した強力な新しいテキストエンジンであるTextKit 2を導入しました。

00:00:30.000 --> 00:00:40.000
TextKit 2のビューポートベースのレイアウトアーキテクチャは、特にコンテンツが大きいドキュメントに対して、高性能なテキストレイアウトを提供します。

00:00:40.000 --> 00:00:56.000
TextKit 2は、グリフでの作業の不要な複雑さを取り除くことで、国際的な視聴者により良いテキスト体験を提供し、OpenTypeや可変フォントなどの最新のフォント技術を完全にサポートしています。

00:00:56.000 --> 00:01:10.000
また、テキストレイアウトを制御するために高レベルのオブジェクトを操作することに焦点を当てたTextKit 2は、テキストのレイアウトを簡単にカスタマイズできるため、より少ないコードでよりクールなものを構築できます。

00:01:10.000 --> 00:01:19.000
今後、TextKit 2エンジンは、Appleのすべてのプラットフォームでテキストレイアウトとレンダリングの基盤を形成します。

00:01:19.000 --> 00:01:28.000
将来のパフォーマンスの向上、アップデート、改善はすべてTextKit 2エンジンに焦点を当てます。

00:01:28.000 --> 00:01:34.000
TextKit 2にアップデートすることで、アプリはこれらの改善のメリットを得ることができます。

00:01:34.000 --> 00:01:39.000
TextKit2の詳細な紹介については、Meet TextKit2のビデオをご覧ください。

00:01:39.000 --> 00:01:47.000
そのビデオでは、基本と、TextKit 2を使用して独自のテキストレイアウトコンポーネントを構築する方法について説明します。

00:01:47.000 --> 00:01:56.000
対照的に、このビデオでは、TextKit 2の最新の進歩と、TextKit 2バックのテキストビューを最大限に活用する方法について説明します。

00:01:56.000 --> 00:02:12.000
そうです、私はテキストビュー、複数形と言いました。なぜなら、iOS 16とmacOS Venturaの時点で、UIKitとAppKitのすべてのテキストコントロールは、UITextViewを含むTextKit 2を使用しているからです。

00:02:12.000 --> 00:02:17.000
そのため、システム全体のレイアウトとレンダリングにTextKit 2を使用しています。

00:02:17.000 --> 00:02:27.000
すべてのアプリができるだけ早くTextKit 2に移行することが重要であり、移行を容易にするために多くのツールを追加しました。

00:02:27.000 --> 00:02:31.000
多くのアプリでは、これはゼロコード遷移になる可能性があります。

00:02:31.000 --> 00:02:36.000
そして、これはテキストビューに特別な変更を加えないアプリにも当てはまることを期待しています。

00:02:36.000 --> 00:02:40.000
それについては後でもう少し話します。

00:02:40.000 --> 00:02:48.000
しかし、まず、先ほど述べたツールのいくつかを含め、TextKit 2の新機能について述べることから始めます。

00:02:48.000 --> 00:02:54.000
その後、テキストビューのTextKit 1互換モードの詳細を深く掘り下げます。

00:02:54.000 --> 00:03:03.000
最後に、コードをTextKit 2に移行する準備をする際に使用できる近代化戦略について話し合います。

00:03:03.000 --> 00:03:08.000
だから、最初はTextKit 2の新機能です。

00:03:08.000 --> 00:03:15.000
TextKit 2は、iOS 15でUIKitに初めて登場し、UITextFieldがそれを使用するようにアップグレードされました。

00:03:15.000 --> 00:03:26.000
iOS 16では、UIKitからTextKit 2への移行が完了し、UITextViewを含むすべてのテキストコントロールがデフォルトでTextKit 2を使用しています。

00:03:26.000 --> 00:03:32.000
ほとんどのテキストビューは、TextKit 2に自動的にオプトインされ、採用はゼロになります。

00:03:32.000 --> 00:03:42.000
テキストビューがオプトインされない可能性がある状況はいくつかありますが、このビデオの互換性セグメントで説明します。

00:03:42.000 --> 00:03:44.000
そして、それはAppKitと同様の話です。

00:03:44.000 --> 00:03:49.000
TextKit 2は、macOS Big SurでAppKitに初めて登場しました。

00:03:49.000 --> 00:03:58.000
macOS Montereyでは、NSTextFieldはデフォルトで使用するようにアップグレードされ、オプトインすることでNSTextViewで利用可能になりました。

00:03:58.000 --> 00:04:03.000
macOS Venturaでは、すべてのテキストコントロールがデフォルトでTextKit 2を使用します。

00:04:03.000 --> 00:04:14.000
UITextViewと同様に、ほとんどのNSTextViewはTextKit 2に自動的にオプトインし、あなたの側の採用をゼロに要求します。

00:04:14.000 --> 00:04:22.000
NSTextViewの薄いラッパーであるTextEditは、macOS VenturaのどこでもTextKit 2を使用します。

00:04:22.000 --> 00:04:27.000
TextEditは、macOS Big Sur以来、プレーンテキストモードでTextKit 2を使用しています。

00:04:27.000 --> 00:04:34.000
macOS Venturaでは、リッチテキストモードはTextKit 2も使用します。

00:04:34.000 --> 00:04:42.000
TextKit 2は新しい標準であるため、UITextViewとNSTextViewの両方に便利なコンストラクタを追加しました。

00:04:42.000 --> 00:04:49.000
これらの新しいコンストラクタを使用して、初期化時にどのテキストエンジンを使用するかを選択します。

00:04:49.000 --> 00:04:58.000
TextKit 2 を使用するテキスト ビューを作成するには、新しいコンストラクタを使用し、「UsingTextLayoutManager」パラメータに true を渡します。

00:04:58.000 --> 00:05:07.000
テキストビューが互換性のためにTextKit 1を使用する必要がある場合は、代わりに「false」を渡してください。

00:05:07.000 --> 00:05:12.000
また、Interface Builderで作成されたテキストビューの新しいテキストレイアウトオプションがあります。

00:05:12.000 --> 00:05:18.000
この新しいオプションを使用すると、インスタンスごとに使用するレイアウトシステムを制御できます。

00:05:18.000 --> 00:05:23.000
デフォルト設定はシステムのデフォルトで、TextKit 2です。

00:05:23.000 --> 00:05:30.000
TextKit 2またはTextKit 1を明示的に使用することもできます。

00:05:30.000 --> 00:05:34.000
TextKit 2は、単純でないテキストコンテナをサポートするようになりました。

00:05:34.000 --> 00:05:39.000
単純でないテキストコンテナには、穴や隙間がある場合があります。

00:05:39.000 --> 00:05:45.000
これにより、テキストは画像やその他のインラインコンテンツをラップすることができます。

00:05:45.000 --> 00:05:55.000
単純でないテキスト コンテナを作成するには、NSTextContainer の exclusionPaths プロパティを使用して、テキストをレイアウトすべきでない領域を定義します。

00:05:55.000 --> 00:06:03.000
これを行う方法の例については、このビデオに関連付けられているリソースからTextKitAndTextViewサンプルコードをチェックしてください。

00:06:03.000 --> 00:06:10.000
関連する例は「除外パス」タブにあります。

00:06:10.000 --> 00:06:17.000
TextKit 2の改行エンジンを強化して、正当な段落に対してより均一な改行を選択しました。

00:06:17.000 --> 00:06:23.000
これは、テキストの長い段落で気付きやすい微妙な変更です。

00:06:23.000 --> 00:06:28.000
ここでは、同じ領域にレイアウトされた同じテキストの2つのバージョンがあります。

00:06:28.000 --> 00:06:36.000
引き伸ばされた行と、従来の改行を伴う大きなインターワード間隔に注目してください。

00:06:36.000 --> 00:06:40.000
新しい偶数ラインブレークで起こっていることははるかに少ないです。

00:06:40.000 --> 00:06:45.000
これにより、テキストが読みやすくなり、TextKit 2で無料で入手できます。

00:06:45.000 --> 00:06:48.000
養子縁組は必要ありません。

00:06:48.000 --> 00:06:53.000
そして最後に、すべてのプラットフォームのTextKit 2にテキストリストのサポートを追加しました。

00:06:53.000 --> 00:07:00.000
テキストリストを使用すると、テキストビューに表示するための番号付きまたは箇条書きのリストをプログラムで作成できます。

00:07:00.000 --> 00:07:07.000
TextKit 2は、TextKit 1と同様に、NSTextListを使用してテキストリストを表します。

00:07:07.000 --> 00:07:15.000
NSTextListは以前はAppKitでのみ利用可能でしたが、iOS 16ではUIKitでも利用可能です。

00:07:15.000 --> 00:07:25.000
NSTextListをNSmutableParagraphStyleと一緒に使用して、テキストストレージ内の段落を表示リストとしてフォーマットするように指定します。

00:07:25.000 --> 00:07:35.000
テキストビューは、テキストストレージからこれらの属性をピックアップし、段落コンテンツをリストのように再フォーマットする責任があります。

00:07:35.000 --> 00:07:41.000
NSTextList自体は新しいものではありませんが、新しいTextKit 2の追加がいくつかあります。

00:07:41.000 --> 00:07:47.000
リストにはネストされたアイテムを持つことができるので、それらをツリー構造として表すのは当然です。

00:07:47.000 --> 00:07:58.000
TextKit 2では、NSTextElementを強化し、子要素と親要素にアクセスするためのプロパティを持つツリーとして構造化をサポートしました。

00:07:58.000 --> 00:08:02.000
そして、NSTextListElementという新しい要素サブクラスを追加しました。

00:08:02.000 --> 00:08:14.000
コンテンツマネージャーがテキストコンテンツ内のNSTextListに出くわすと、リスト内の項目を表すNSTextListElementsが生成されます。

00:08:14.000 --> 00:08:22.000
テキストリストの作成方法とアイテムの追加方法の詳細については、TextKitAndTextViewのサンプルコードを参照してください。

00:08:22.000 --> 00:08:27.000
関連する例は「リスト」タブで見つけることができます。

00:08:27.000 --> 00:08:38.000
また、サンプルコードを探索している間は、TextKit 2でテキストアタッチメントビュープロバイダーAPIを使用する方法を示すテキストアタッチメントの例をお見逃しなく。

00:08:38.000 --> 00:08:47.000
これらのAPIを使用すると、UIまたはNSViewをテキスト添付ファイルとして使用でき、イベントは添付ファイルビューで直接処理できます。

00:08:47.000 --> 00:08:54.000
これにより、テキスト添付ファイルによるイベント処理がはるかに簡単になり、TextKit 2でのみ可能です。

00:08:54.000 --> 00:08:57.000
よし、TextKit 2の新機能については、それだけです。

00:08:57.000 --> 00:09:03.000
次に、TextKit 1互換モードの詳細に入ります。

00:09:03.000 --> 00:09:17.000
TextKit 2はTextKit 1の設計から根本的に逸脱しているため、TextKit 2の完全な採用は、TextKit 1アーキテクチャに多額の投資をしているアプリには時間がかかる可能性があることを理解しています。

00:09:17.000 --> 00:09:28.000
移行が行われるまで、これらのアプリが引き続きうまく機能することを望んでいます。そのため、UITextViewとNSTextViewに特別なTextKit 1互換モードを追加しました。

00:09:28.000 --> 00:09:41.000
NSLayoutManager APIを明示的に呼び出すと、テキストビューはNSTextLayoutManagerをNSLayoutManagerに置き換え、TextKit 1を使用するように再構成します。

00:09:41.000 --> 00:09:52.000
これは、テキストビューがテーブルや印刷時など、TextKit 2でまだサポートされていない属性に遭遇した場合にも発生する可能性があります。

00:09:52.000 --> 00:10:01.000
UITextViewでTextKit 1への予期しないランタイムフォールバックに遭遇した場合は、スイッチに関するメッセージ警告のログを確認してください。

00:10:01.000 --> 00:10:13.000
シンボルアンダースコアUITextViewEnablingCompatibilityModeにブレークポイントを設定して、スタックトレースやその他の有用なデバッグ情報をキャプチャします。

00:10:13.000 --> 00:10:25.000
NSTextViewの場合、willSwitchまたはdidSwitchToNSLayoutManager通知を購読することで、予期しないランタイムフォールバックに関する詳細情報を取得できます。

00:10:25.000 --> 00:10:34.000
TextKit 1に戻る必要がある場合は、プログラムで初期化されたテキストビューで初期化時にオプトアウトするのが最善です。

00:10:34.000 --> 00:10:40.000
独自のテキストコンテナとTextKit 1レイアウトマネージャーを使用して、これを行います。

00:10:40.000 --> 00:10:49.000
もう1つのオプションは、新しい便利なコンストラクタを使用してTextKit 1のテキストビューを初期化し、パラメータとしてfalseを渡すことです。

00:10:49.000 --> 00:10:54.000
これにより、テキストビューはTextKit 1を使用します。

00:10:54.000 --> 00:11:03.000
そして3番目のオプションは、Interface Builderを使用して、テキストビューで新しいテキストレイアウトオプションをTextKit 1に設定することです。

00:11:03.000 --> 00:11:05.000
ここに注意すべきことがあります。

00:11:05.000 --> 00:11:16.000
初期化中または初期化後にテキストコンテナのレイアウトマネージャを交換する場合、テキストビューは設計どおりにTextKit 1にフォールバックします。

00:11:16.000 --> 00:11:24.000
初期化中にすべてのTextKit 2オブジェクトを作成し、すぐに捨てるだけでは非効率的です。

00:11:24.000 --> 00:11:28.000
タイミングに応じて、潜在的なユーザーの副作用もあります。

00:11:28.000 --> 00:11:38.000
入力中に発生すると、テキストビューはフォーカスを失い、入力を中断する可能性があり、再開するにはテキストビューを再度選択する必要があります。

00:11:38.000 --> 00:11:44.000
初期化時にテキストビューアウトをオプトアウトすることで、これを回避してください。

00:11:44.000 --> 00:11:54.000
互換性モードについてすべて知っているので、アプリをモダナイズしてTextKit 2を採用することで、それを完全に回避する方法について話す時が来ました。

00:11:54.000 --> 00:11:59.000
そして、あなたに覚えておいてほしい本当に重要なことが1つあります。

00:11:59.000 --> 00:12:03.000
テキストビューごとにレイアウトマネージャーは1つだけです。

00:12:03.000 --> 00:12:11.000
テキストビューは、NSTextLayoutManagerとNSLayoutManagerの両方を同時に持つことはできません。

00:12:11.000 --> 00:12:17.000
テキストビューがTextKit 1に切り替わると、自動で戻る方法はありません。

00:12:17.000 --> 00:12:25.000
レイアウトシステムを切り替えるプロセスは高価であり、切り替え時に存在していたUI状態が失われます。

00:12:25.000 --> 00:12:33.000
したがって、最適なパフォーマンスと使いやすさのために、システムはテキストビューをTextKit 1からTextKit 2に戻すことはありません。

00:12:33.000 --> 00:12:36.000
それは一方通行の操作です。

00:12:36.000 --> 00:12:42.000
これは、互換性モードを避けることが本当に重要であることを意味します。

00:12:42.000 --> 00:12:46.000
そして、テキストビューが互換性モードに入る理由はいくつかあります。

00:12:46.000 --> 00:12:55.000
テキストビューが互換性モードに入る一番の理由は、テキストビューのlayoutManagerプロパティにアクセスすることです。

00:12:55.000 --> 00:12:59.000
他の理由はそれほど一般的ではありません。

00:12:59.000 --> 00:13:05.000
したがって、重要な戦略は、テキストビューのレイアウトマネージャープロパティへのアクセスを避けることです。

00:13:05.000 --> 00:13:11.000
また、テキストビューのテキストコンテナからレイアウトマネージャにアクセスすることも避けてください。

00:13:11.000 --> 00:13:20.000
これらのプロパティの使用についてコードを監査し、それらを削除するか、同等のTextKit 2に置き換えます。

00:13:20.000 --> 00:13:29.000
TextKit 2が搭載されていない古いOSバージョンにアプリをデプロイする場合、layoutManagerコードを完全に削除できない場合があります。

00:13:29.000 --> 00:13:36.000
その場合は、まずテキストビューのNSTextLayoutManagerを確認する必要があります。

00:13:36.000 --> 00:13:45.000
TextKit 2コードをif句に入れ、TextKit 1コードをlayoutManagerアクセスを含むelse句に入れます。

00:13:45.000 --> 00:13:57.000
このようにして、TextKit 1コードはTextKit 2が利用できない場合にのみ実行され、layoutManagerクエリはTextKit 1への意図しないフォールバックを引き起こしません。

00:13:57.000 --> 00:14:09.000
このアドバイスをすべて守っても、システムからTextKit 1への予期しないフォールバックに遭遇した場合、それは私たちの問題ですので、フィードバックアシスタントで問題を報告してください。

00:14:09.000 --> 00:14:25.000
UIKitのアンダースコアUITextViewEnablingCompatibilityMode、またはAppKitのwillSwitchToNSLayoutManagerNotificationでブレークから取得できるフォールバック時のスタックトレースのキャプチャを含めます。

00:14:25.000 --> 00:14:34.000
さて、NSLayoutManagerから始めて、TextKit 1タイプに関連するコードの更新の詳細について説明します。

00:14:34.000 --> 00:14:44.000
NSLayoutManagerクエリのコードを監査したら、NSTextLayoutManagerと同等のTextKit 2を把握する必要があります。

00:14:44.000 --> 00:14:51.000
一部のレイアウトマネージャーAPIは、TextKit 1と2の間で同様の名前を持ち、置換は簡単です。

00:14:51.000 --> 00:14:53.000
ここにいくつかの例があります。

00:14:53.000 --> 00:15:04.000
TextKit 1では、NSLayoutManagerでusedRect(for: textContainer)を呼び出すと、テキストコンテナ内のテキストの境界矩形を取得します。

00:15:04.000 --> 00:15:12.000
TextKit 2では、NSTextLayoutManagerのagesageBoundsForTextContainerプロパティからこれを取得します。

00:15:12.000 --> 00:15:21.000
TextKit 1では、レイアウトではなくレンダリングにのみ影響する属性に「一時的な属性」という名前を使用しました。

00:15:21.000 --> 00:15:27.000
TextKit 2では、より正確にそれらを「レンダリング属性」と呼んでいます。

00:15:27.000 --> 00:15:33.000
しかし、TextKit 2には直接同等のものを持たないTextKit 1 APIがいくつかあります。

00:15:33.000 --> 00:15:43.000
その理由を理解するには、カンナダ語のようなインド文字の多くの単語のグリフマッピングに正しい文字がないことを理解する必要があります。

00:15:43.000 --> 00:15:50.000
これらのスクリプトでは、グリフを分割したり、並べ替えたり、再結合したり、削除したりできます。

00:15:50.000 --> 00:16:03.000
NSLayoutManagerのグリフベースのAPIは、連続した範囲の文字と連続した範囲のグリフを直接関連付けることができることを前提としていますが、それはすべてのスクリプトに当てはまるわけではありません。

00:16:03.000 --> 00:16:09.000
これらのAPIを使用すると、カンナダ語などのスクリプトで書かれたテキストのレイアウトとレンダリングが破損する可能性があります。

00:16:09.000 --> 00:16:14.000
そのため、TextKit 2にはグリフAPIはゼロです。

00:16:14.000 --> 00:16:19.000
TextKit 1グリフAPIを単一のTextKit 2 APIに置き換えることはできません。

00:16:19.000 --> 00:16:24.000
これらのAPIを置き換えるには、別のアプローチが必要です。

00:16:24.000 --> 00:16:28.000
グリフベースのコードを更新する方法は次のとおりです。

00:16:28.000 --> 00:16:33.000
最初のステップは、使用しているグリフAPIを特定することです。

00:16:33.000 --> 00:16:40.000
次に、これらのAPIをどのように使用しているかを見て、高いレベルで何をしようとしているかを定義します。

00:16:40.000 --> 00:16:48.000
グリフベースのコードは非常に低レベルであり、高レベルのタスクとは関係のない詳細がたくさんあります。

00:16:48.000 --> 00:16:58.000
高レベルのタスクを定義したら、レイアウトフラグメント、行フラグメント、テキスト選択など、TextKit 2で利用可能な構造を調べます。

00:16:58.000 --> 00:17:02.000
これらはあなたのタスクを達成するのに役立ちます。

00:17:02.000 --> 00:17:06.000
例えば、このTextKit 1のコードを考えてみましょう。

00:17:06.000 --> 00:17:15.000
ここで使用されているグリフAPIには、numberOfGlyphsとlineFragmentRect(forGlyphAt: index)の2つがあります。

00:17:15.000 --> 00:17:22.000
このTextKit 1コードは、ドキュメント内のすべてのグリフを反復し、行フラグメントのレクトをカウントしています。

00:17:22.000 --> 00:17:29.000
高レベルのタスクは、テキストビューでラップされたテキストの行数を数えることです。

00:17:29.000 --> 00:17:40.000
このコードは行フラグメント直列で動作するため、使用するTextKit 2構造はNSTextLineFragmentとNSTextLayoutFragmentです。

00:17:40.000 --> 00:17:43.000
そして、これはTextKit 2を使用するように書き換えられたコードです。

00:17:43.000 --> 00:17:57.000
グリフを反復する代わりに、ドキュメント内のテキストレイアウトフラグメントを列挙し、各レイアウトフラグメント内のすべてのテキスト行フラグメントをカウントするクロージャを提供します。

00:17:57.000 --> 00:18:01.000
TextKit 2の独自のコードを更新するときは、その例を覚えておいてください。

00:18:01.000 --> 00:18:09.000
次に、ギアをシフトし、NSRangeに基づくコードの更新について話し合います。

00:18:09.000 --> 00:18:19.000
TextKit 1はNSRangeを使用してテキストコンテンツにインデックスを作成し、NSRangeは文字列への線形インデックスです。

00:18:19.000 --> 00:18:36.000
「Hello TextKit 2!」というテキストについて感嘆符、「TextKit 2感嘆符」を表すNSRangeは、6文字目から始まり、10文字の長さであるため、場所6と長さ10です。

00:18:36.000 --> 00:18:43.000
この線形モデルは理解しやすく、文字列へのインデックス作成に最適です。

00:18:43.000 --> 00:18:50.000
しかし、線形モデルは、文字列よりも構造を持つコンテンツへのインデックス作成には機能しません。

00:18:50.000 --> 00:18:52.000
ここに例があります。

00:18:52.000 --> 00:18:58.000
HTMLドキュメントはツリー構造として表され、各タグはツリー内のノードです。

00:18:58.000 --> 00:19:10.000
私たちのハローTextKit 2なら!テキストはHTMLドキュメントの一部であり、NSRangeがテキストが3レベルの深さでネストされたスパンタグ内にあることを教えてくれる方法はありません。

00:19:10.000 --> 00:19:19.000
線形モデルは、その情報を保存するのに十分な表現力がないため、このようなネストされた構造にインデックスを作成するために使用することはできません。

00:19:19.000 --> 00:19:26.000
これが、TextKit 2がテキストコンテンツの範囲を表すための新しいタイプを追加した理由です。

00:19:26.000 --> 00:19:33.000
NSTextLocationは、テキストコンテンツ内の単一の場所を表すオブジェクトです。

00:19:33.000 --> 00:19:38.000
NSTextRangeは、開始位置と終了位置で構成されています。

00:19:38.000 --> 00:19:42.000
終了位置は範囲から除外されます。

00:19:42.000 --> 00:19:53.000
これらの新しいタイプは、場所をDOMノードと文字オフセットとして定義することで、このHTMLドキュメントのネストされた構造を表すことができます。

00:19:53.000 --> 00:20:03.000
NSTextLocationはプロトコルであるため、NSTextLocationプロトコルメソッドを実装している限り、任意のカスタムオブジェクトは場所になることができます。

00:20:03.000 --> 00:20:11.000
これは、モデルで構造化データをサポートするさまざまなタイプのバッキングストアと連携するための重要なインフラストラクチャです。

00:20:11.000 --> 00:20:23.000
しかし、テキストビューは、この構造を持たないNSAttributedStringバッキングストア上に構築されており、あなたを含む多くのアプリを壊さずにそれを変更することはできません。

00:20:23.000 --> 00:20:30.000
したがって、selectedRangeやscrollRangeToVisibleなどのテキストビューAPIを使用する場合は、NSRangeを引き続き使用します。

00:20:30.000 --> 00:20:40.000
また、TextKit 2レイアウトマネージャーまたはコンテンツマネージャーと通信する場合は、NSRangeとNSTextRangeの間で変換する必要があります。

00:20:40.000 --> 00:20:50.000
テキストビューのNSRangeをNSTextRangeに変換するには、位置を属性文字列の整数インデックスとして定義します。

00:20:50.000 --> 00:20:56.000
NSTextRangeの開始場所としてNSRangeの場所を使用してください。

00:20:56.000 --> 00:21:02.000
NSTextRangeの終了位置として、NSRangeの場所と長さを使用してください。

00:21:02.000 --> 00:21:09.000
概念的には、それがNSRangeからNSTextRangeにマッピングする方法です。

00:21:09.000 --> 00:21:17.000
実際には、NSTextLocationsはオブジェクトでなければならないため、コードは少し違って見えます。

00:21:17.000 --> 00:21:21.000
場所を計算するには、コンテンツマネージャーを通過する必要があります。

00:21:21.000 --> 00:21:31.000
開始場所については、ドキュメントの開始位置をコンテンツマネージャーに尋ね、NSRangeの場所で相殺します。

00:21:31.000 --> 00:21:38.000
次に、開始位置をNSRangeの長さでオフセットして、終了位置を取得します。

00:21:38.000 --> 00:21:45.000
他の方向に進むには、テキストコンテンツマネージャーを使用して2つの異なるオフセットを取得します。

00:21:45.000 --> 00:21:53.000
NSRangeの場所は、ドキュメントの先頭とNSTextRangeの場所の間のオフセットです。

00:21:53.000 --> 00:22:01.000
そして、NSRangeの長さは、NSTextRangeの開始位置と終了位置の間のオフセットです。

00:22:01.000 --> 00:22:09.000
UITextViewsとUITextFieldsは、UITextPositionと範囲を使用するUITextInputプロトコルに準拠しています。

00:22:09.000 --> 00:22:19.000
ほとんどの場合、UITextViewまたはUITextFieldを使用する場合、UITextRangeをNSTextRangeに直接変換する必要はありません。

00:22:19.000 --> 00:22:26.000
ただし、その場合は、整数オフセットを2つの範囲タイプの中間として使用してください。

00:22:26.000 --> 00:22:38.000
一方、UITextInputでカスタムビューを使用している場合は、ビューで使用されるUITextPositionとUITextRangeサブクラスを直接制御できます。

00:22:38.000 --> 00:22:51.000
UITextPositionサブクラスをNSTextLocationに準拠させ、必要なメソッドを実装し、サブクラスを使用してNSTextRangesを直接作成できます。

00:22:51.000 --> 00:23:02.000
最後に、両方のビューのコンテンツが似ている場合でも、異なるビュー間でUITextPositionオブジェクトを再利用しないようにするためのリマインダーです。

00:23:02.000 --> 00:23:09.000
UITextPositionは、作成に使用されたビューに対してのみ有効です。

00:23:09.000 --> 00:23:14.000
さて、今、あなたはあなたのコードを近代化するために自由に使える多くの戦略を持っています。

00:23:14.000 --> 00:23:21.000
これらの戦略を適用すると、アプリはTextKit 2のメリットを享受する準備が整います。

00:23:21.000 --> 00:23:24.000
そして、それがTextKitとテキストビューの新機能です。

00:23:24.000 --> 00:23:33.000
私はTextKit 2の多くの大きな改善をカバーし、古いOSバージョンとの互換性を維持しながらアプリを更新するためのいくつかの戦略を共有しました。

00:23:33.000 --> 00:23:39.000
今すぐアプリでTextKit 2を使用して、新しい改善点を最大限に活用してください。

00:23:39.000 --> 00:23:44.000
テキストビューをチェックして、意図せずにTextKit 1にフォールバックしていないことを確認してください。

00:23:44.000 --> 00:23:50.000
そして最後に、近代化戦略を採用して、TextKit 2でアプリを入手してください。

00:23:50.000 --> 00:23:55.000
TextKit 2とテキストビューで作成するものを読むのが待ちきれません。

00:23:55.000 --> 23:59:59.000
見てくれてありがとう!

