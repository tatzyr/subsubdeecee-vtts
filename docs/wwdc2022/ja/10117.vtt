WEBVTT

00:00:00.000 -> 00:00:03.000
♪まろやかなインストゥルメンタルヒップホップ音楽♪

00:00:03.000 -> 00:00:09.000
♪

00:00:09.000 -> 00:00:19.000
ケビン・フェレル:こんにちは、私の名前はケビンで、iOS上のアプリのトランシーバーシステム体験を可能にする新しいPushToTalkフレームワークに取り組んでいるエンジニアです。

00:00:19.000 -> 00:00:27.000
その後、同僚のトレバーと一緒に、この新しいフレームワークでアプリの音声コミュニケーションを強化する方法について話します。

00:00:27.000 -> 00:00:32.000
まず、PushToTalkフレームワークを紹介し、それがあなたのアプリにどのように適合するかを説明します。

00:00:32.000 -> 00:00:37.000
次に、PushToTalk用にアプリを設定する方法について説明します。

00:00:37.000 -> 00:00:43.000
その後、トレバーはフレームワークを使用してオーディオを送受信する方法を説明します。

00:00:43.000 -> 00:00:52.000
最後に、Trevorは、ユーザーのバッテリー寿命を維持しながら、Push To Talkのユーザーエクスペリエンスを向上させるためのベストプラクティスをまとめます。

00:00:52.000 -> 00:00:57.000
新しいPushToTalkフレームワークの主な機能を紹介することから始めます。

00:00:57.000 -> 00:01:07.000
PushToTalkフレームワークを使用すると、iOSで新しいクラスのオーディオ通信アプリを構築し、ユーザーにトランシーバースタイルの体験を提供することができます。

00:01:07.000 -> 00:01:15.000
Push To Talkアプリは、医療や緊急サービスなど、迅速なコミュニケーションが不可欠な分野で多くの用途があります。

00:01:15.000 -> 00:01:26.000
優れたプッシュ・トゥ・トーク体験を提供するために、ユーザーは誰が応答しているかを確認しながら、オーディオ伝送機能にすばやくアクセスする方法が必要です。

00:01:26.000 -> 00:01:35.000
同時に、Push To Talkアプリは、ユーザーがアプリの使用中に終日のバッテリー寿命を維持できるように、電力効率が高くなければなりません。

00:01:35.000 -> 00:01:45.000
PushToTalkフレームワークは、ユーザーがアプリを直接起動することなく、システム上のどこからでもアクセスできるシステムUIを利用するためのAPIを提供します。

00:01:45.000 -> 00:01:55.000
システムUIを使用すると、ユーザーはオーディオ伝送をすばやくアクティブにすることができ、バックグラウンドでアプリを起動して、オーディオを録音してサーバーにストリーミングします。

00:01:55.000 -> 00:02:02.000
このシステムは、アプリがサーバーから音声を再生するときに誰が話しているかを示すことで、ユーザーに透明性を提供します。

00:02:02.000 -> 00:02:11.000
PushToTalkフレームワークは、新しいオーディオが再生可能になったときにアプリに通知する新しいプッシュ通知タイプを導入することで、これを達成します。

00:02:11.000 -> 00:02:19.000
アプリがこの通知を受信すると、バックグラウンドで起動され、オーディオをストリーミングして再生できます。

00:02:19.000 -> 00:02:27.000
PushToTalkフレームワークは、既存のエンドツーエンドの通信ソリューションやバックエンドインフラストラクチャと互換性があるように設計されています。

00:02:27.000 -> 00:02:36.000
アプリにPush To Talkワークフローをすでに実装している場合は、PushToTalkフレームワークを既存のコードに簡単に統合できるはずです。

00:02:36.000 -> 00:02:43.000
このフレームワークにより、アプリは独自のオーディオエンコーディングとストリーミングプロセスを実装して、ユーザー間でオーディオを送信できます。

00:02:43.000 -> 00:02:51.000
これにより、オーディオ伝送がアプリによってどのように処理されるかに柔軟性が提供され、他のプラットフォームとの互換性が可能になります。

00:02:51.000 -> 00:02:59.000
最後に、多くのPush To Talkアプリは、オーディオの録音と送信をトリガーするためにワイヤレスBluetoothアクセサリに依存しています。

00:02:59.000 -> 00:03:07.000
アプリは、CoreBluetoothフレームワークを使用してこれらのアクセサリと引き続き統合でき、PushToTalkでオーディオ録音をトリガーできます。

00:03:07.000 -> 00:03:15.000
最初のPush To Talkアプリを構築する場合は、コードの設計を開始する際に、これらの統合の考慮事項を念頭に置いてください。

00:03:15.000 -> 00:03:24.000
新しいPushToTalkフレームワークのコードを進める前に、Push To Talkエクスペリエンスがアプリでどのように機能するかを実証したいと思います。

00:03:24.000 -> 00:03:28.000
トレバーと私は、PushToTalkがどのように機能するかを示すデモアプリを構築しました。

00:03:28.000 -> 00:03:36.000
まず、参加ボタンをタップして、チャンネルと呼ばれるPush To Talkセッションに接続します。

00:03:36.000 -> 00:03:41.000
チャンネルに参加すると、チャンネルの他のメンバーにオーディオを送受信できます。

00:03:41.000 -> 00:03:47.000
トレバーと数人の同僚が同じチャンネルに参加しているので、一日中コミュニケーションをとることができます。

00:03:47.000 -> 00:03:59.000
マイクボタンを使用してアプリから直接オーディオを送信できますが、PushToTalkフレームワークを使用すると、システムのどこからでも送信機能にアクセスできます。

00:03:59.000 -> 00:04:03.000
アクティブなPush To Talkチャンネルがある場合、ステータスバーに青い錠剤が表示されます。

00:04:03.000 -> 00:04:08.000
そのピルをタップすると、システムUIが表示されます。

00:04:08.000 -> 00:04:18.000
システムUIには、私が参加したPush To Talkチャンネルの名前とアプリが提供する画像が表示され、ユーザーがチャンネルをすばやく識別するのに役立ちます。

00:04:18.000 -> 00:04:29.000
トークボタンを長押しし、システムのチャイムが私が話し始めることができることを示すのを待つことで、チャンネルにオーディオを送信できます。

00:04:29.000 -> 00:04:32.000
ねえ、トレバー。

00:04:32.000 -> 00:04:37.000
WWDCのスライドをカバーする準備はできていますか？オーバー。

00:04:37.000 -> 00:04:48.000
トレバー・シェリダン：私のデバイスがケビンのメッセージを受信すると、彼の名前と画像を含む通知が表示され、誰からメッセージを受信しているかを透明にしました。

00:04:48.000 -> 00:04:56.000
システムUIを起動すると、ケビンのメッセージにすばやく応答したり、やっていることを停止することなくチャンネルを離れることができます。

00:04:56.000 -> 00:05:01.000
ケビンを待たせたくないので、今返信します。

00:05:01.000 -> 00:05:04.000
ねえ、ケビン。数分で準備できます。

00:05:04.000 -> 00:05:07.000
オーバー。

00:05:07.000 -> 00:05:21.000
ケビン：PushToTalkシステムUIはロック画面からもアクセスできるため、ユーザーはデバイスのロックを解除することなくメッセージを受信して応答できます。

00:05:21.000 -> 00:05:27.000
わかった、またね！オーバー。

00:05:27.000 -> 00:05:33.000
PushToTalkの仕組みについて話し合ったので、独自のアプリにフレームワークを統合する方法を確認します。

00:05:33.000 -> 00:05:39.000
PushToTalkフレームワークをサポートするために、Xcodeプロジェクトに加える必要がある変更がいくつかあります。

00:05:39.000 -> 00:05:43.000
まず、新しいPush To Talkのバックグラウンドモードを追加する必要があります。

00:05:43.000 -> 00:05:48.000
これにより、Push To Talkイベントに応答するときにアプリをバックグラウンドで実行できます。

00:05:48.000 -> 00:05:55.000
次に、フレームワーク機能を有効にするには、アプリにPush To Talk機能を追加する必要があります。

00:05:55.000 -> 00:06:04.000
APNSが受信したオーディオを再生するためにバックグラウンドでアプリをウェイクできるようにするには、プッシュ通知機能が必要です。

00:06:04.000 -> 00:06:12.000
最後に、アプリはユーザーに録音許可を要求し、Info.plistファイルにマイク目的の文字列を含める必要があります。

00:06:12.000 -> 00:06:16.000
これで、コードの統合を開始する準備が整いました。

00:06:16.000 -> 00:06:19.000
Push To Talkワークフローの最初のステップは、チャンネルに参加することです。

00:06:19.000 -> 00:06:24.000
チャンネルは、システムへのプッシュ・トゥ・トーク・セッションを表し、説明しています。

00:06:24.000 -> 00:06:28.000
あなたのアプリはチャンネルマネージャーを通じてチャンネルと対話します。

00:06:28.000 -> 00:06:37.000
チャンネルマネージャーは、アプリがチャンネルに参加し、オーディオの送受信などのアクションを実行するための主要なインターフェイスです。

00:06:37.000 -> 00:06:47.000
チャンネルに参加すると、Push To TalkシステムUIが利用可能になり、アプリはチャンネルの生涯を通じて使用できるAPNSデバイストークンを受け取ります。

00:06:47.000 -> 00:06:52.000
オーディオの送受信を開始する前に、チャンネルに参加する必要があります。

00:06:52.000 -> 00:06:57.000
最初のステップは、クラス初期化子を使用してチャネルマネージャーを作成することです。

00:06:57.000 -> 00:07:04.000
この初期化子では、チャネルマネージャーデリゲートとチャネル復元デリゲートを提供する必要があります。

00:07:04.000 -> 00:07:13.000
イニシャライザを複数回呼び出すと、同じ共有インスタンスが返されますが、チャネルマネージャーをインスタンス変数に保存することをお勧めします。

00:07:13.000 -> 00:07:22.000
ApplicationDelegateのdidFinishLaunchingWithOptionsメソッドで、アプリの起動時にできるだけ早くチャネルマネージャーを初期化することが重要です。

00:07:22.000 -> 00:07:33.000
これにより、チャネルマネージャーが迅速に初期化され、既存のチャネルが復元され、バックグラウンドで起動するとプッシュ通知がアプリに配信されます。

00:07:33.000 -> 00:07:35.000
今、私たちはチャンネルに参加する準備が整いました。

00:07:35.000 -> 00:07:44.000
誰かがアプリからチャンネルに参加するときは、チャンネルを識別するためのUUIDと、システムへのチャンネルを説明する記述子を提供する必要があります。

00:07:44.000 -> 00:07:50.000
このチャンネルの生涯を通じてマネージャーとやり取りする際に、同じUUIDが使用されます。

00:07:50.000 -> 00:07:53.000
記述子には名前と画像が含まれています。

00:07:53.000 -> 00:08:01.000
チャンネルを表すユニークな画像を提供することで、ユーザーがシステムと対話するときにチャンネルを識別しやすくなります。

00:08:01.000 -> 00:08:06.000
アプリは、チャンネルマネージャーのrequestJoinメソッドを呼び出すことで、チャンネルに参加します。

00:08:06.000 -> 00:08:12.000
アプリがフォアグラウンドで実行されている場合にのみ、チャンネルに参加できることに注意してください。

00:08:12.000 -> 00:08:18.000
アプリがチャンネルに参加すると、チャンネルマネージャーデリゲートのdidJoinChannelメソッドが呼び出されます。

00:08:18.000 -> 00:08:23.000
このデリゲートメソッドは、アプリがチャンネルに参加したことを示すものです。

00:08:23.000 -> 00:08:34.000
さらに、デリゲートのreceivedEphemeralPushTokenメソッドは、このデバイスにPush To Talk通知を送信するために使用できるAPNSプッシュトークンで呼び出されます。

00:08:34.000 -> 00:08:38.000
このトークンは、Push To Talkチャンネルの存分の間のみ有効になります。

00:08:38.000 -> 00:08:45.000
APNSプッシュトークンは可変長であり、その長さをアプリにハードコードするべきではないことを覚えておいてください。

00:08:45.000 -> 00:08:53.000
別のチャンネルがすでにアクティブなときにチャンネルに参加しようとするときなど、チャンネル参加要求が失敗する可能性があります。

00:08:53.000 -> 00:09:00.000
これが発生すると、エラーハンドラが呼び出され、エラーは失敗の理由を示します。

00:09:00.000 -> 00:09:04.000
ユーザーがチャンネルを離れると、デリゲートのdidLeaveChannelメソッドが呼び出されます。

00:09:04.000 -> 00:09:14.000
アプリはプログラムで退去を要求した結果、またはユーザーがシステムUIの「チャンネルを離れる」ボタンをタップした結果、ユーザーはチャンネルを離れることができます。

00:09:14.000 -> 00:09:23.000
チャネルマネージャーデリゲートには、関連するLeaveChannelエラー処理メソッドがあり、チャネルを離れる要求が失敗した場合に呼び出されます。

00:09:23.000 -> 00:09:30.000
PushToTalkは、終了後、またはデバイスの再起動後にアプリが再起動されるたびに、以前のチャンネルの復元をサポートしています。

00:09:30.000 -> 00:09:37.000
システムがこれを達成するためには、システムを更新するためのチャネル記述子を提供する必要があります。

00:09:37.000 -> 00:09:43.000
ここには、復元デリゲートでキャッシュされたチャネル記述子を取得するヘルパーメソッドがあります。

00:09:43.000 -> 00:09:56.000
システムの応答性を維持するために、できるだけ早くこの方法から戻る必要があり、チャネル記述子を取得するためのネットワーク要求などの長時間実行またはブロックタスクを実行しないでください。

00:09:56.000 -> 00:10:04.000
プッシュ・トゥ・トーク・セッションのライフサイクルを通じて、チャンネルに関する情報が変更されるたびに記述子を更新する必要があります。

00:10:04.000 -> 00:10:12.000
また、サービスステータスオブジェクトを使用して、ネットワーク接続またはサーバーの可用性の変更についてシステムに通知する必要があります。

00:10:12.000 -> 00:10:15.000
ここでは、チャンネルの記述子を更新しています。

00:10:15.000 -> 00:10:20.000
チャンネル名や画像を更新する必要があるときはいつでも、このメソッドを呼び出すことができます。

00:10:20.000 -> 00:10:28.000
この例では、アプリのサーバーへの接続が再接続状態であることを示すために、システムにアップデートを提供しています。

00:10:28.000 -> 00:10:37.000
これにより、システムUIがそれに応じて更新され、サービスステータスが接続または切断されている場合にユーザーがオーディオを送信できなくなります。

00:10:37.000 -> 00:10:42.000
接続が再確立されたら、サービスステータスを「準備完了」に更新する必要があります。

00:10:42.000 -> 00:10:46.000
それでは、PushToTalkを使用してオーディオを送受信する方法を確認しましょう。

00:10:46.000 -> 00:10:51.000
トレバー、APIの残りの部分を歩く準備はできていますか？

00:10:51.000 -> 00:10:55.000
オーバー。

00:10:55.000 -> 00:10:59.000
トレバー：うん。それらを送ってください。オーバー。

00:10:59.000 -> 00:11:09.000
PushToTalkフレームワークの設定方法を見たので、オーディオを送受信する方法を探りましょう。

00:11:09.000 -> 00:11:16.000
PushToTalkフレームワークのコア機能は、ユーザーがオーディオをすばやく送信できるようにすることです。

00:11:16.000 -> 00:11:22.000
ユーザーは、アプリ内またはシステムPush To Talk UIからオーディオ送信を開始できます。

00:11:22.000 -> 00:11:33.000
アプリがCoreBluetoothを介してBluetoothアクセサリをサポートしている場合は、周辺機器の特性の変化に応じてバックグラウンドで送信を開始することもできます。

00:11:33.000 -> 00:11:44.000
送信時、PushToTalkフレームワークはデバイスのマイクのロックを解除し、アプリのオーディオセッションをアクティブにして、バックグラウンドでのオーディオ録音を有効にします。

00:11:44.000 -> 00:11:48.000
このプロセスを詳細に確認しましょう。

00:11:48.000 -> 00:11:54.000
アプリ内から送信を開始するには、requestBeginTransmitting関数を呼び出すことができます。

00:11:54.000 -> 00:12:03.000
これは、アプリがフォアグラウンドで実行されているとき、またはBluetooth周辺機器の特性の変化に反応するたびに呼び出すことができます。

00:12:03.000 -> 00:12:13.000
システムが送信を開始できない場合、デリゲートのfailedToBeginTransmitting InChannelメソッドが失敗の理由で呼び出されます。

00:12:13.000 -> 00:12:22.000
たとえば、ユーザーが進行中の携帯電話通話をアクティブにしている場合、Push To Talkの送信を開始できません。

00:12:22.000 -> 00:12:28.000
送信を停止するには、チャネルマネージャーのstopTransmittingメソッドを呼び出します。

00:12:28.000 -> 00:12:41.000
ユーザーが送信状態ではない場合など、送信を停止しようとするときの障害を処理するために、チャネルマネージャーデリゲートには、関連するfailedToStopTransmitting InChannelメソッドがあります。

00:12:41.000 -> 00:12:53.000
アプリ内から送信を開始する場合でも、ユーザーがシステムUIから開始する場合でも、チャネルマネージャーのデリゲートは「送信開始」コールバックを受け取ります。

00:12:53.000 -> 00:13:04.000
送信ソースはメソッドに渡され、送信がシステムUI、プログラマティックAPI、またはハードウェアボタンイベントから開始されたかどうかを示します。

00:13:04.000 -> 00:13:10.000
送信が開始されると、システムはアプリのオーディオセッションをアクティブにします。

00:13:10.000 -> 00:13:13.000
これは、録音を開始できる信号です。

00:13:13.000 -> 00:13:19.000
独自のオーディオセッションを開始または停止すべきではありません。

00:13:19.000 -> 00:13:29.000
送信が終了すると、チャネルマネージャーのデリゲートは終了送信とオーディオセッションの無効化イベントを受け取ります。

00:13:29.000 -> 00:13:42.000
送信がアクティブな間は、オーディオセッションは、アプリ内で処理する必要がある電話やFaceTime通話など、他のソースによって中断される可能性があることに注意してください。

00:13:42.000 -> 00:13:49.000
PushToTalkフレームワークでは、アプリがバックグラウンドで他のユーザーからオーディオを受信して再生することもできます。

00:13:49.000 -> 00:13:56.000
このプロセスは、Push To Talkアプリに固有の新しいAppleプッシュ通知タイプに依存しています。

00:13:56.000 -> 00:14:09.000
Push To Talkサーバーにユーザーが受信する新しいオーディオがある場合、チャンネルへの参加時に受信したデバイスプッシュトークンを使用して、Push To Talk通知をユーザーに送信する必要があります。

00:14:09.000 -> 00:14:23.000
アプリがプッシュ通知を受信すると、アクティブなスピーカーをフレームワークに報告する必要があります。これにより、システムはアプリのオーディオセッションをアクティブにし、再生を開始できます。

00:14:23.000 -> 00:14:34.000
新しいPush To Talk通知は、iOSの他の通知タイプに似ており、Push To Talkアプリへの配信を有効にするために設定する必要がある特定の属性があります。

00:14:34.000 -> 00:14:41.000
まず、APNSプッシュタイプは、リクエストヘッダーで「pushtotalk」に設定する必要があります。

00:14:41.000 -> 00:14:52.000
次に、APNSトピックヘッダーをアプリのバンドル識別子に設定し、末尾に「.voip-ptt」サフィックスを追加する必要があります。

00:14:52.000 -> 00:15:05.000
プッシュペイロードには、アクティブなスピーカーの名前やセッションが終了し、アプリがPush To Talkチャンネルを離れる必要があるという表示など、アプリに関連するカスタムキーを含めることができます。

00:15:05.000 -> 00:15:10.000
「Aps」プロパティの本文は空白のままにすることができます。

00:15:10.000 -> 00:15:29.000
さらに、他の通信関連のプッシュタイプと同様に、Push To Talkペイロードは、すぐに配信をリクエストするためにAPNS優先度が10で、APNSの有効期限がゼロで、関連性のない古いプッシュが後で配信されるのを防ぐ必要があります。

00:15:29.000 -> 00:15:39.000
サーバーがPush To Talk通知を送信すると、アプリはバックグラウンドで起動し、着信プッシュデリゲートメソッドが呼び出されます。

00:15:39.000 -> 00:15:50.000
プッシュペイロードを受け取ったら、プッシュ通知の結果として実行すべきアクションを示すプッシュ結果タイプを構築する必要があります。

00:15:50.000 -> 00:16:01.000
リモートユーザーが話していることを示すために、名前やオプションの画像など、アクティブな参加者の情報を含むプッシュ結果を返します。

00:16:01.000 -> 00:16:08.000
これにより、システムはアクティブな参加者をチャンネルに設定し、チャンネルが受信モードになっていることを示します。

00:16:08.000 -> 00:16:15.000
その後、システムはオーディオセッションをアクティブにし、didActivateaudioSessionデリゲートメソッドを呼び出します。

00:16:15.000 -> 00:16:19.000
再生を開始する前に、このメソッドが呼び出されるのを待つ必要があります。

00:16:19.000 -> 00:16:31.000
サーバーがユーザーをチャネルに参加させないように決定した場合、プッシュペイロードにこれが表示される可能性があり、そのためにはleaveChannelプッシュ結果を返すことができます。

00:16:31.000 -> 00:16:40.000
スレッドをブロックしないように、このメソッドからできるだけ早くPTPushResultを返す必要があることに注意することが重要です。

00:16:40.000 -> 00:16:50.000
アクティブなリモート参加者を設定しようとしていて、そのイメージがローカルに保存されていない場合は、スピーカーの名前のみでactiveRemoteParticipantを返すことができます。

00:16:50.000 -> 00:17:03.000
次に、別のスレッドに画像をダウンロードし、画像が取得されたら、チャンネルマネージャーでsetActiveRemoteParticipantを呼び出してactiveRemoteParticipantを更新します。

00:17:03.000 -> 00:17:08.000
リモート参加者が話し終わったら、activeRemoteParticipantをnilに設定する必要があります。

00:17:08.000 -> 00:17:17.000
これは、チャンネルでオーディオを受信しなくなり、システムがオーディオセッションを無効にする必要があることをシステムに示します。

00:17:17.000 -> 00:17:24.000
これにより、システムPush To Talk UIも更新され、ユーザーが再度送信できるようになります。

00:17:24.000 -> 00:17:37.000
PushToTalkをアプリに統合する方法の基本を説明したので、ユーザーエクスペリエンスを最適化し、バッテリー寿命を維持するためのベストプラクティスを確認しましょう。

00:17:37.000 -> 00:17:46.000
PushToTalkフレームワークは、ユーザーが送信を開始し、システム内のどこからでもチャネルを離れるためのシステムUIを提供します。

00:17:46.000 -> 00:17:56.000
さらに、柔軟性があり、アプリがフォアグラウンドにあるときに独自のカスタムPush To Talk UIを実装できます。

00:17:56.000 -> 00:18:00.000
PushToTalkフレームワークは、共有システムリソースを利用します。

00:18:00.000 -> 00:18:11.000
一度にシステム上でアクティブにできるPush To Talkアプリは1つだけで、Push To Talk通信は携帯電話、FaceTime、VoIP通話に取って代わられます。

00:18:11.000 -> 00:18:18.000
アプリはPushToTalkの障害を適切に処理し、それに応じて応答する必要があります。

00:18:18.000 -> 00:18:25.000
前述のように、PushToTalkフレームワークは、オーディオセッションの有効化と無効化を処理します。

00:18:25.000 -> 00:18:33.000
ただし、アプリの起動時に再生および録音するようにオーディオセッションのカテゴリを設定する必要があります。

00:18:33.000 -> 00:18:42.000
このシステムは、送信時にマイクがアクティブおよび無効になっていることをユーザーに警告する組み込みのサウンドエフェクトを提供します。

00:18:42.000 -> 00:18:46.000
これらのイベントに独自の効果音を提供するべきではありません。

00:18:46.000 -> 00:18:57.000
また、アプリがセッションの中断、ルートの変更、障害などのAVAudioSession通知を監視して応答することも重要です。

00:18:57.000 -> 00:19:05.000
Push To Talkアプリは、システム上の他のオーディオアプリと同様に、これらのオーディオセッションイベントの影響を受ける可能性があります。

00:19:05.000 -> 00:19:09.000
バッテリーの寿命を維持するために、アプリを最適化することが重要です。

00:19:09.000 -> 00:19:17.000
PushToTalkフレームワークは、オーディオの送受信など、必要に応じてバックグラウンドランタイムをアプリに提供します。

00:19:17.000 -> 00:19:24.000
アプリがユーザーによって使用されていない場合、バッテリー寿命を維持するためにシステムによって一時停止されます。

00:19:24.000 -> 00:19:28.000
独自のオーディオセッションを有効または無効にしないでください。

00:19:28.000 -> 00:19:34.000
システムは、適切なタイミングでオーディオセッションのアクティベーションを処理します。

00:19:34.000 -> 00:19:43.000
これにより、オーディオセッションがシステム内で適切な優先順位を持ち、使用されていないときに一時停止することができます。

00:19:43.000 -> 00:19:54.000
プッシュ・トゥ・トーク・サーバーは、新しいプッシュ通知タイプを使用して、再生する新しいオーディオがあること、またはプッシュ・トゥ・トークセッションが終了したことをアプリに警告する必要があります。

00:19:54.000 -> 00:20:03.000
アプリのバッテリー寿命の改善の詳細については、「パワーダウン：バッテリー消費量の改善」セッションを参照してください。

00:20:03.000 -> 00:20:11.000
Push To Talkアプリがバックグラウンドにあり、アプリがオーディオを送受信していない場合、システムによって中断されます。

00:20:11.000 -> 00:20:17.000
アプリが一時停止されると、ネットワーク接続が切断されます。

00:20:17.000 -> 00:20:28.000
安全なTLS接続を確立し、初期接続速度を向上させるために必要な手順を減らすために、Network.frameworkとQUICの採用を検討する必要があります。

00:20:28.000 -> 00:20:31.000
Network.frameworkにはQUICのサポートが組み込まれています。

00:20:31.000 -> 00:20:40.000
QUICの使用方法の詳細については、「より応答性の高いアプリのためのネットワークの遅延を減らす」セッションをチェックしてください。

00:20:40.000 -> 00:20:49.000
PushToTalkフレームワークを使用すると、アプリ内で堅牢で電力効率の高いトランシーバースタイルのコミュニケーション体験を構築できます。

00:20:49.000 -> 00:20:59.000
iOSでウォークトーキースタイルのエクスペリエンスを実装するアプリをすでにお持ちの場合は、新しいAPIを使用するように既存のアプリの更新を開始する必要があります。

00:20:59.000 -> 00:21:05.000
新しいトランシーバーアプリを実装する場合は、今すぐPushToTalkフレームワークを使用する必要があります。

00:21:05.000 -> 00:21:12.000
最後に、新しいフレームワークのテストを開始し、アプリと統合する際にフィードバックを送信してください。

00:21:12.000 -> 00:21:15.000
ありがとう、そして素晴らしいWWDCを!

00:21:15.000 -> 00:21:17.000
オーバー・アンド・アウト!

00:21:17.000 -> 23:59:59.000
♪

