WEBVTT

00:00:01.000 -> 00:00:09.000
♪インストゥルメンタルヒップホップ音楽♪

00:00:09.000 -> 00:00:12.000
こんにちは、私の名前はジョンで、Xcode Cloudチームのエンジニアです。

00:00:12.000 -> 00:00:15.000
そして、私はXcode Cloudチームのデザイナー、ジョー・リンです。

00:00:15.000 -> 00:00:23.000
今日は、5人のチームであろうと500人のチームであろうと、チームの一員としてXcode Cloudを使用しているときに非常に役立つXcode Cloudの機能のいくつかを見ていきます。

00:00:23.000 -> 00:00:30.000
そして、Xcode Cloudをチームの一員として使用するときにうまく機能する他の機能やベストプラクティスをいくつか共有します。

00:00:30.000 -> 00:00:35.000
今日のセッションでは、他のセッションでも取り上げられているいくつかのトピックについて詳しく説明します。

00:00:35.000 -> 00:00:43.000
Webhookやその他の高度なワークフローのトピックについて詳しく知りたい場合は、「高度なXcode Cloudワークフローをカスタマイズする」セッションをチェックしてください。

00:00:43.000 -> 00:01:01.000
このセッションでは、Xcode Cloudを毎日使用する既存のツールやテクノロジーに統合し、コードの依存関係を簡単に管理し、アプリを効果的に継続的に構築、テスト、配布するためのワークフローを設定するのに役立つXcode Cloudのベストプラクティスを紹介します。

00:01:01.000 -> 00:01:02.000
始めましょう。

00:01:02.000 -> 00:01:06.000
Xcode Cloudを既存のツールに統合するには、いくつかのオプションがあります。

00:01:06.000 -> 00:01:10.000
Webhooksを使用すると、それらをサポートするツールやサービスと簡単に統合できます。

00:01:10.000 -> 00:01:20.000
Webhookを送信するURLをXcode Cloudに指示することで、App Store ConnectでWebhookを接続することができ、それらのWebhookがすぐに入ってくるのを見始めるはずです。

00:01:20.000 -> 00:01:34.000
また、当社のAPIにより、ビルドを大量に可視化できるため、ビルドダッシュボードを簡単に作成したり、ビルドアーティファクトを抽出したり、今日の例では、ビルド情報を既存のソフトウェアに統合したりできます。

00:01:34.000 -> 00:01:46.000
私たちはフードトラックアプリの新機能をたくさん構築してきましたが、新しいバグも発見しており、一緒にアプリに取り組んでいる人々のチームがいるので、誰が何に取り組んでいるのかを理解するのは難しいと感じました。

00:01:46.000 -> 00:01:52.000
この問題を解決するために、イシュートラッカーを使用して、アプリで行われているすべての作業を追跡することにしました。

00:01:52.000 -> 00:01:55.000
イシュートラッカーを使用している場合は、多くの場合、このようなビューがあります。

00:01:55.000 -> 00:02:06.000
問題トラッカーの一般的なワークフローは、チケットを作成し、デザイナーや開発者にそのチケットに取り組んでもらい、最後に機能やバグが完了したら閉じることです。

00:02:06.000 -> 00:02:12.000
問題トラッカーに実際のビルド情報を表示すると、すべての点をつなぐのに大きな助けになります。

00:02:12.000 -> 00:02:14.000
今、それをどのように行うことができるかを見てみましょう。

00:02:14.000 -> 00:02:23.000
ここでの私たちの計画は、イシュートラッカーをXcode Cloudと統合するために必要なすべてを処理する、非常にシンプルなSwift On Serverベースのサービスを作成することです。

00:02:23.000 -> 00:02:29.000
開発をスピードアップするために、Vapor Webフレームワークを使用して、Webhook処理コードの作成に集中します。

00:02:29.000 -> 00:02:32.000
基本的な流れはこんな感じになります。

00:02:32.000 -> 00:02:35.000
WebhookはXcode Cloudから当社のサーバーに来ます。

00:02:35.000 -> 00:02:43.000
そのWebhookを読み、コミッターによって書かれたコミットメッセージに、トラッカーの問題にマップする特定の文字列があるかどうかを確認します。

00:02:43.000 -> 00:02:48.000
その場合は、Xcode Cloud APIを使用して、ビルドに関する詳細情報を収集します。

00:02:48.000 -> 00:02:56.000
次に、関心のある情報を含むイシュートラッカーに投稿できるコメントを作成します。

00:02:56.000 -> 00:03:01.000
その後、問題トラッカーでAPIを呼び出すと、問題に対するメッセージが保存されます。

00:03:01.000 -> 00:03:04.000
まず、Xcode Cloud APIのドキュメントを見てみましょう。

00:03:04.000 -> 00:03:08.000
すべてのXcode Cloud APIは、App Store Connect APIの下にあります。

00:03:08.000 -> 00:03:17.000
App Store Connect APIの認証トークンをすでに設定している場合は、Xcode Cloudデータにもアクセスするために必要なものがすべて揃っています。

00:03:17.000 -> 00:03:22.000
Build Runsコレクションを開くと、ビルドと対話できるエンドポイントがいくつか見えます。

00:03:22.000 -> 00:03:29.000
エンドポイントを呼び出すと、ビルドを作成したり、ビルドをキャンセルしたり、特定のビルドに関する詳細情報を取得したりできます。

00:03:29.000 -> 00:03:36.000
たとえば、ビルドのステータスを表示するダッシュボードを構築したい場合は、Ci_Build_Runsエンドポイントが呼び出す必要があるすべてである必要があります。

00:03:36.000 -> 00:03:40.000
次に、ドキュメントのアーティファクトコレクションを見てみましょう。 アーティファクトコレクションを見てみましょう。

00:03:40.000 -> 00:03:46.000
ワークフローでは、ビルドアーティファクトをXcode Cloudの外部に保ちたいとしており、APIにはそれを行うために必要なすべてが揃っているはずです。

00:03:46.000 -> 00:03:52.000
まず、ビルドアクションエンドポイントからアーティファクトIDを取得できます。これにより、特定のアクションに対して生成されたすべてのアーティファクトが返されます。

00:03:52.000 -> 00:04:00.000
次に、ci_artifactを呼び出すと、downloadUrl属性でアーティファクトをダウンロードするために必要なURLが表示されます。

00:04:00.000 -> 00:04:09.000
まず、App Store ConnectのドキュメントからopenAPI仕様をダウンロードし、APIのクライアントを作成するために必要なものを見てみましょう。

00:04:09.000 -> 00:04:12.000
クライアントコードを作成できる新しいディレクトリを作成しましょう。

00:04:12.000 -> 00:04:14.000
私はこれをxcodecloud-clientと呼びます。

00:04:14.000 -> 00:04:17.000
次に、ジェネレータのコマンドラインツールをダウンロードする必要があります。

00:04:17.000 -> 00:04:27.000
openAPIのウェブサイトでこれを行う方法はたくさんあります。セッションでは、すでに設定しました。app_store_connect_APIから入手したばかりのopenAPI仕様をディレクトリにコピーしましょう。

00:04:27.000 -> 00:04:36.000
素晴らしい、これでopenAPIジェネレータを呼び出すことができ、API用の迅速なクライアントを作成するように指示できます。

00:04:36.000 -> 00:04:39.000
発電機が稼働している間、それが何をしているかについてすぐに話すことができます。

00:04:39.000 -> 00:04:45.000
openAPI仕様は、APIを構成するすべてのパスとモデルに関する情報で構成されています。

00:04:45.000 -> 00:04:55.000
ジェネレータは、各APIパスを通過し、強く型付けされたswiftオブジェクトを使用して、その特定のパスと通信できるSwiftコードを生成します。

00:04:55.000 -> 00:05:01.000
ほとんどの場合、これはJSONエンコーディングやデコードを行う必要がないことを意味します。

00:05:01.000 -> 00:05:06.000
素晴らしい、私たちのジェネレータは完成したので、作成したファイルを簡単に見てみましょう。

00:05:06.000 -> 00:05:09.000
便利なことに、クライアントコードはSwiftパッケージです。

00:05:09.000 -> 00:05:13.000
これにより、イシュートラッカーを更新するWebhookサーバーに含めるのが本当に簡単になります。

00:05:13.000 -> 00:05:19.000
これで、コードを新しいgitリポジトリにコミットし、これをSwiftパッケージとして参照することができます。

00:05:19.000 -> 00:05:24.000
APIと話し合うために必要なものがすべて揃ったので、Webhookを設定しましょう。

00:05:24.000 -> 00:05:29.000
App Store Connectでは、ビルドが完了するたびにサーバーに知らせるWebhookを登録できます。

00:05:29.000 -> 00:05:44.000
これを行うには、App Store Connectで製品に移動し、設定に移動し、Webhooksに移動します。

00:05:44.000 -> 00:05:46.000
そして、サーバーのURLを貼り付けます。

00:05:46.000 -> 00:05:49.000
これにより、Xcode CloudはWebhookの送信先を知ることができます。

00:05:49.000 -> 00:05:55.000
私たちのウェブフックが設定されているので、残っているのはそれらを処理するためのコードを書くことだけなので、それを始めましょう。

00:05:55.000 -> 00:06:00.000
まず、Webhookから関心のあるフィールドに一致する構造体を定義する必要があります。

00:06:00.000 -> 00:06:09.000
Webhookには、実行されている特定のビルドと実行されている各アクションに関する情報が含まれているので、それらをWebhookペイロード構造体に入れておきましょう。

00:06:09.000 -> 00:06:14.000
次に、Vaporが着信Webhookを関数に正しくルーティングするためのコードを作成する必要があります。

00:06:14.000 -> 00:06:19.000
Webhookパスへのポストリクエストで実行される関数を定義します。

00:06:19.000 -> 00:06:28.000
この関数の中で、着信JSONペイロードを強く型付けされたSwiftオブジェクトに変換するために必要なのは、それをデコードすることだけなので、そのコードも追加します。

00:06:28.000 -> 00:06:37.000
素晴らしい、今私たちがする必要があるのは、Xcode Cloud APIを呼び出すだけで、完了したばかりのビルドについてもう少し情報を入手して、イシュートラッカーページに含めることができます。

00:06:37.000 -> 00:06:43.000
Webhookペイロードには、実行されたばかりのビルドと、どのアクションが成功または失敗したかに関する多くの情報が含まれています。

00:06:43.000 -> 00:06:47.000
私たちはおそらくそこで止まることができますが、それを次のレベルに引き上げましょう。

00:06:47.000 -> 00:06:53.000
各アクションでどの問題が見つかったかについての情報も含めると素晴らしいと思います。

00:06:53.000 -> 00:07:03.000
CiBuildActionsAPIに拡張関数を書くことで、特定のアクションに関心のある問題を簡単に返すことができます。

00:07:03.000 -> 00:07:12.000
この拡張機能では、ビルドアクションIDをパラメータとして取り、特定のアクションで見つかったすべての問題を返す関数を記述します。

00:07:12.000 -> 00:07:16.000
私はすでに私のプロジェクトにこれを持っていますが、残りのコードを記入しましょう。

00:07:16.000 -> 00:07:21.000
ビルドが完了した場合のみ、Webhookハンドラを実行させたいので、それを防ぎましょう。

00:07:21.000 -> 00:07:24.000
次に、コメント文字列の作業を開始できます。

00:07:24.000 -> 00:07:32.000
ビルド番号、コミットハッシュ、およびこの文字列に著者があるのは素晴らしいことだと思います。

00:07:32.000 -> 00:07:37.000
それでは、各アクションを実行し、拡張機能を呼び出すと、各アクションの問題を取得します。

00:07:37.000 -> 00:07:47.000
今、これをすべてイシュートラッカーに伝えましょう。

00:07:47.000 -> 00:07:52.000
これらすべての情報で、これは問題トラッカーをビルドで最新の状態に保つのに役立つと思います。

00:07:52.000 -> 00:07:54.000
そして、私たちは終わりました!

00:07:54.000 -> 00:08:03.000
この時点で、Webhooks用にXcode Cloudに提供したURLでサーバーコードをホストし、イシュートラッカーでXcode Cloudのビルド情報を表示し始める必要があります。

00:08:03.000 -> 00:08:06.000
これまでに学んだことを簡単にまとめましょう。 

00:08:06.000 -> 00:08:12.000
Xcode Cloudには、既存の開発ワークフローとさらに深く統合するために使用できる優れたAPIがあります。

00:08:12.000 -> 00:08:20.000
そのAPIとWebhookを使用して、すべての点を接続し、既存のツールやテクノロジーをXcode Cloudと統合できます。

00:08:20.000 -> 00:08:24.000
次に、ジョーが他の機能やベストプラクティスについて話します。

00:08:24.000 -> 00:08:25.000
ジョー：ありがとう、ジョン！

00:08:25.000 -> 00:08:34.000
Xcode Cloudは、アプリやフレームワークの作成に使用するAppleの開発者ツールやサービスと統合するように設計されています。

00:08:34.000 -> 00:08:41.000
ただし、Xcodeプロジェクトでは、コードをコンパイルするために追加の依存関係や外部ツールが必要になる場合があります。

00:08:41.000 -> 00:08:45.000
Xcode CloudはSwift Package Managerでうまく機能します。

00:08:45.000 -> 00:08:53.000
パッケージのリポジトリが一般に公開されている場合、追加の設定を必要とせずにSwiftパッケージの依存関係をサポートします。

00:08:53.000 -> 00:09:05.000
Xcode CloudをCocoapodsやCarthageなどのサードパーティの依存関係マネージャーと連携させることもできますが、カスタムビルドスクリプトを使用して少し余分な作業を行う必要があります。

00:09:05.000 -> 00:09:15.000
Xcode Cloudで依存関係を利用可能にする方法については、Xcodeのドキュメントを参照してください。

00:09:15.000 -> 00:09:26.000
Swiftパッケージを追加し、ワークフローを開始するために変更をプッシュしたら、レポートナビゲーターのクラウドタブに移動し、最新のビルドのステータスを表示できます。

00:09:26.000 -> 00:09:31.000
[ログ] を選択して、詳細なビルド ログを表示します。

00:09:31.000 -> 00:09:36.000
Xcode Cloudが依存関係を自動的に解決したことがわかります。

00:09:36.000 -> 00:09:50.000
Xcode Cloudが最初のビルドを正常に完了した後、アプリやフレームワークが常に出荷可能な状態であることを確認するために、継続的な統合と配信の実践を洗練するための次のステップを計画する必要があります。

00:09:50.000 -> 00:10:05.000
このセクションでは、静的コード分析のためにSwiftLintでXcode Cloudを使用する方法、ワークフローの編集を制限する方法、および複数の開始条件を設定することの価値について説明します。

00:10:05.000 -> 00:10:14.000
SwiftLintは、Swiftコミュニティで一般的に受け入れられているスタイルガイドのルールと慣習を強制するオープンソースのリンターツールです。

00:10:14.000 -> 00:10:20.000
静的コード分析を実行して、コードの品質を向上させ、悪い慣行を防ぎます。

00:10:20.000 -> 00:10:27.000
SwiftLintは、特に大規模なチームで作業する場合、チームのコードベースの一貫性を維持するための素晴らしい方法であることがわかりました。

00:10:27.000 -> 00:10:33.000
これからお見せするのは、カスタムビルドスクリプトを使用してSwiftLintをXcode Cloudと統合する方法です。

00:10:33.000 -> 00:10:41.000
チームのプライマリリポジトリからソースコードを複製した後、Xcode CloudがSwiftLintツールを実行したいと考えています。

00:10:41.000 -> 00:10:51.000
プロジェクトナビゲーターでは、すでにci_scriptsフォルダのpost_cloneスクリプトをフードトラックプロジェクトに追加しました。

00:10:51.000 -> 00:10:59.000
Xcode Cloudのビルド環境にはHomebrewが含まれており、SwiftLintをインストールするためにここで使用しているものです。

00:10:59.000 -> 00:11:02.000
このラインでは、SwiftLintを実行しています。

00:11:02.000 -> 00:11:16.000
覚えておくべきことの1つは、スクリプトはci_scriptsディレクトリ内で実行されるため、リポジトリを指すci_workspace環境変数内で実行するようにSwiftLintに指示する必要があります。

00:11:16.000 -> 00:11:19.000
コード分析の結果を確認しましょう。

00:11:19.000 -> 00:11:24.000
SwiftLintはたくさんの違反を見つけたようで、そのうち15件は深刻です。

00:11:24.000 -> 00:11:42.000
ツールを統合するのは初めてなので、このワークフローを一時的に無効にして、まずチームの他のメンバーと話し合い、コーディングスタイルと慣習について合意し、どの問題を解決したいかをチームとして決定します。

00:11:42.000 -> 00:11:46.000
ワークフローの管理メニューからXcodeでワークフローを無効にすることができます。

00:11:46.000 -> 00:11:57.000
そうすることで、開始条件が機能しなくなり、手動ビルドのみを開始できます。

00:11:57.000 -> 00:12:04.000
静的コード分析ワークフローが無効になったので、修正したい問題の修正に集中できます。

00:12:04.000 -> 00:12:07.000
その後、戻ってきて、このワークフローを有効にすることができます。

00:12:07.000 -> 00:12:13.000
私たちのチームは急速に成長しており、ワークフロー構成について意識的な選択をしたいと考えています。

00:12:13.000 -> 00:12:21.000
私はチームのすべてのワークフローを維持および管理する責任があるので、チームメンバーにワークフローに意図しない変更を加えたくありません。

00:12:21.000 -> 00:12:23.000
それは元に戻すのに多くの時間がかかります。

00:12:23.000 -> 00:12:29.000
意図しない変更を防ぐために、ワークフローを編集できるユーザーを制限できます。

00:12:29.000 -> 00:12:35.000
ワークフローを選択し、コンテキストメニューから「編集を制限する」を選択します。

00:12:35.000 -> 00:12:47.000
チームの誰でもこのワークフローを使用または実行できますが、管理者、アカウント所有者、アプリマネージャーのみが制限を適用できるため、彼らだけが編集できます。

00:12:47.000 -> 00:12:51.000
編集が制限されているワークフローには「キー」記号があります。

00:12:51.000 -> 00:12:59.000
これは、ロックされており、あなたや他の管理ユーザーのみが編集できることを意味します。

00:12:59.000 -> 00:13:06.000
代わりに「ロック」記号が表示された場合は、管理者によってロックされており、編集できないことを意味します。

00:13:06.000 -> 00:13:13.000
この機能により、特に大規模なチームの一員である場合は、複雑なワークフローへのアクセスを簡単に管理できます。

00:13:13.000 -> 00:13:18.000
ワークフローを一時停止またはロックダウンするのがいかに簡単かを学びました。

00:13:18.000 -> 00:13:22.000
では、ワークフローの管理とメンテナンスについて話しましょう。

00:13:22.000 -> 00:13:30.000
プルリクエストを行うたびに、またはブランチをマージするときに、同じテストとアーカイブアクションを実行したいです。

00:13:30.000 -> 00:13:33.000
これを行う最善の方法は、複数の開始条件を通過することです。

00:13:33.000 -> 00:13:41.000
これにより、作成および管理する必要のあるワークフローの数が減るため、ワークフローのメンテナンスが向上します。

00:13:41.000 -> 00:14:01.000
説明するために、この例では、次の条件でビルドを開始したいと思います。メインブランチまたはリリースブランチに変更がある場合、またはメインブランチにスケジュールされたビルドがある場合は、同じアーカイブとテストアクションのセットを実行し、内部テストのためにTestFlightにデプロイします。

00:14:01.000 -> 00:14:10.000
3つのワークフローを作成し、それらを管理して同期させる代わりに、すべての開始条件を一度に指定する単一のワークフローを作成します。

00:14:10.000 -> 00:14:17.000
これにより、特にチームが維持すべき多くのワークフローがある場合、管理性が向上します。

00:14:17.000 -> 00:14:20.000
Xcodeでの開始条件の設定は簡単です。

00:14:20.000 -> 00:14:28.000
ワークフローエディタから、+ボタンメニューから開始条件のタイプを選択します。

00:14:28.000 -> 00:14:35.000
App Store ConnectのXcode Cloudは、フル機能のウェブベースの体験を提供します。

00:14:35.000 -> 00:14:46.000
無効化やロックダウンから、複数の起動条件の設定まで、ワークフローを設定するためにXcodeで行ったすべてのことは、AppStoreConnectからも入手できます。

00:14:46.000 -> 00:15:03.000
Xcode Cloudは、Xcodeに組み込まれた強力で継続的な統合&amp;配信サービスで、あらゆる規模の開発チームを支援し、既存のツールやプロセスと簡単に統合して、ユーザーに高品質のアプリを提供することができます。

00:15:03.000 -> 00:15:09.000
Xcode Cloudのベータ参加者の皆様、ご意見に本当に感謝し、さらに皆様のご連絡をお待ちしております。

00:15:09.000 -> 00:15:13.000
これらの機能が、チームの継続的な統合と配信の実践を洗練させるのに役立つことを願っています。

00:15:13.000 -> 00:15:16.000
ご覧いただきありがとうございます、そして素晴らしいWWDCをお過ごしください!

00:15:16.000 -> 23:59:59.000
♪インストゥルメンタルヒップホップ音楽♪

