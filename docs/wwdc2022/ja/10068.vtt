WEBVTT

00:00:00.000 --> 00:00:09.000
♪インストゥルメンタルヒップホップ音楽♪

00:00:09.000 --> 00:00:14.000
- iOS 16の「UIKitの新機能」へようこそ。

00:00:14.000 --> 00:00:19.000
私はDimaで、UIKitチームのエンジニアリングマネージャーです。

00:00:19.000 --> 00:00:23.000
UIKitは、アプリの中核となる強力なフレームワークです。

00:00:23.000 --> 00:00:29.000
iOS 16の新機能をサポートするために更新されました。

00:00:29.000 --> 00:00:50.000
このビデオでは、生産性、コントロールの強化、APIの改良のためのUIの改善を取り上げ、UIKitとSwiftUIを一緒に使用するエキサイティングな新しい方法について話します。

00:00:50.000 --> 00:01:07.000
UIKitでは、新しいタイトルメニュー、検索と置換、カット、コピー、ペーストの編集インタラクションを再考した改良されたナビゲーションバーを備えた、合理化された検出可能なユーザーインターフェイスの開発をさらに簡単にしました。

00:01:07.000 --> 00:01:11.000
ドキュメントベースのアプリケーションを強化できます。

00:01:11.000 --> 00:01:22.000
まず、デスクトップクラスのツールバー機能をサポートするように更新されたナビゲーションバーを詳しく見ていきます。

00:01:22.000 --> 00:01:35.000
iOS 16では、UIKitは、ドキュメントベースのアプリのニーズをよりよくサポートするために、ブラウザとエディタの2つの新しいナビゲーションスタイルを導入しています。

00:01:35.000 --> 00:01:47.000
ブラウザスタイルは、ウェブやドキュメントブラウザなど、ナビゲーションに履歴やフォルダ構造を使用するアプリ向けに設計されています。

00:01:47.000 --> 00:01:55.000
エディタは、ドキュメントの編集を中心としたインターフェイスを対象としています。

00:01:55.000 --> 00:02:07.000
iOS 16では、さまざまなバーボタンアイテムをアプリに追加でき、そのサブセットがナビゲーションバーの中央に表示されます。

00:02:07.000 --> 00:02:17.000
メニューの「ツールバーのカスタマイズ」エントリをタップすると、アイテムのポップアップとの間でドラッグしてアイテムを並べ替えることができます。

00:02:17.000 --> 00:02:25.000
結果として生じる新しい設定は、アプリの起動中も持続します。

00:02:25.000 --> 00:02:42.000
サイズ変更に対応するために、たとえば、別のアプリでサイドバイサイドモードに入ると、システムは自動的にオーバーフローメニューを提供し、合わないアイテムにアクセスします。

00:02:42.000 --> 00:02:57.000
新しいナビゲーションスタイルで動作し、複製、移動、名前変更、エクスポート、印刷など、いくつかの標準機能をサポートするタイトルメニューを追加しました。

00:02:57.000 --> 00:03:05.000
これらは、対応するデリゲートメソッドが実装されると、自動的にメニューに表示されます。

00:03:05.000 --> 00:03:15.000
タイトルメニューに完全にカスタムアイテムを追加することも可能です。

00:03:15.000 --> 00:03:29.000
さらに、Mac Catalystで構築されたアプリは、追加のコードを必要とせず、NSToolbarとシームレスに統合することで、改良されたナビゲーションバーを活用します。

00:03:29.000 --> 00:03:37.000
iOS 16では、さまざまなアプリで一貫してテキストを操作する新しい方法が導入されています。

00:03:37.000 --> 00:03:41.000
1つ目は、新しい発見と置換です。

00:03:41.000 --> 00:03:53.000
概念的には、写真やカレンダーイベントなどのデータモデルオブジェクトで動作する、より高レベルのアプリ内検索とは異なります。

00:03:53.000 --> 00:03:58.000
代わりに、検索と置換はテキストで動作するように意図的に構築されています。

00:03:58.000 --> 00:04:09.000
UITextViewやWKWebViewなどの組み込みUIKitビューの機能をアクティブにするには、フラグを設定するだけです。

00:04:09.000 --> 00:04:17.000
さらに、このシステムを選択した複数のビューやドキュメントでシームレスに機能します。

00:04:17.000 --> 00:04:22.000
次に、編集メニューが大幅にアップグレードされました。

00:04:22.000 --> 00:04:26.000
今では、使用される入力方法によって異なって見えます。

00:04:26.000 --> 00:04:35.000
タッチインタラクションでは、よりインタラクティブな再設計されたメニューが表示されます。

00:04:35.000 --> 00:04:42.000
ポインタを使用すると、よりフル機能のコンテキストメニューが表示されます。

00:04:42.000 --> 00:04:56.000
これらの両方のエクスペリエンスをシームレスな方法で提供するために、現在非推奨のUIMenuControllerの完全な代替品としてUIEditMenuInteractionを導入しました。

00:04:56.000 --> 00:05:03.000
テキストビューのメニューにアクションを挿入する新しいAPIもあります。

00:05:03.000 --> 00:05:17.000
「デスクトップクラスの編集インタラクションを採用する」を見て、新しい編集メニューのすべての詳細を学び、カスタムビューの検索インタラクションを採用する方法を学びます。

00:05:17.000 --> 00:05:22.000
カバーしたいビジュアルUIアップデートが1つあります。

00:05:22.000 --> 00:05:31.000
iOS 16では、スライドオーバーモードのサイドバーは、追加のコードなしで自動的に鮮やかになります。

00:05:31.000 --> 00:05:38.000
これを達成するために、UIKitはあなたに代わって一連のプライベートビューを管理します。

00:05:38.000 --> 00:05:52.000
これらは、UIKitの新しい生産性機能です。新しいカスタマイズ可能なナビゲーションバー、検索と置換、インタラクションの編集、強力なタイトルメニューです。

00:05:52.000 --> 00:05:54.000
私はここで表面を引っ掻いているだけです。

00:05:54.000 --> 00:06:13.000
さらに多くのことを学ぶには、「Meet desktop class iPad」セッションと、iOS 16の新しい高度なUIKit機能を備えたサンプルアプリの改善について、より詳細な「デスクトップクラスのiPadアプリを構築する」を確認してください。

00:06:13.000 --> 00:06:22.000
次に、追加した2つの新しいコントロールを紹介し、UIPageControlの機能強化について説明します。

00:06:22.000 --> 00:06:34.000
UIDatePickerのインラインカレンダースタイルは、UICalendarViewの形で、スタンドアロンのフル機能コンポーネントとして利用可能になりました。

00:06:34.000 --> 00:06:45.000
UICalendarViewは、オプションの単一の日付や複数の日付の選択など、さまざまな種類の選択動作をサポートしています。

00:06:45.000 --> 00:06:53.000
利用可能な日付範囲に加えて、選択から個々の日付を無効にすることもサポートしています。

00:06:53.000 --> 00:07:00.000
さらに、個々の日付に装飾で注釈を付けることができます。

00:07:00.000 --> 00:07:13.000
UICalendarViewとUIDatePickerの主な違いの1つは、UICalendarViewが日付をNSDateではなくNSDateComponentsとして表していることです。

00:07:13.000 --> 00:07:27.000
NSDateとは異なり、日付コンポーネントは日付のより良く、より正しい表現ですが、NSDateは時点の表現です。

00:07:27.000 --> 00:07:38.000
NSDateComponentsは多くの柔軟性を提供するため、コンポーネントがどのNSCalendarで表されるかを非常に明確にする必要があります。

00:07:38.000 --> 00:07:43.000
現在のカレンダーの種類について仮定すべきではないことに注意してください。

00:07:43.000 --> 00:07:53.000
カレンダーをグレゴリオ暦にする必要がある場合は、グレゴリオ暦を明示的に指定してください。

00:07:53.000 --> 00:08:02.000
先に示したようなカレンダービューを設定するには、まずカレンダービューを作成し、そのデリゲートを設定します。

00:08:02.000 --> 00:08:15.000
カレンダーがグレゴリアンNSCalendarによってバックアップされていることを確認するには、calenalViewのカレンダープロパティをグレゴリアンNSCalendarに設定します。

00:08:15.000 --> 00:08:19.000
次に、マルチ日付の選択を設定します。

00:08:19.000 --> 00:08:35.000
UICalendarSelectionMultiDateオブジェクトを作成し、選択オブジェクトの選択した日付プロパティを、カレンダービューに表示するデータモデルから既存の日付に設定します。

00:08:35.000 --> 00:08:44.000
次に、選択オブジェクトをカレンダービューの選択動作に設定します。

00:08:44.000 --> 00:09:00.000
カレンダーで個々の日付の選択を防ぐために、カレンダーの選択のデリゲートからmultiDateSelection:canSelectDate:メソッドを実装して、どの日付を選択できるかを制御します。

00:09:00.000 --> 00:09:07.000
選択できない日付は、カレンダービューでグレー表示になります。

00:09:07.000 --> 00:09:19.000
個々の日付に装飾で注釈を付けるには、カレンダーデリゲートのcalendarView:decorationForDateComponents:メソッドを実装します。

00:09:19.000 --> 00:09:23.000
装飾が無の場合は、単にゼロを返します。

00:09:23.000 --> 00:09:29.000
デフォルトの灰色の円の場合は、デフォルトの装飾を返します。

00:09:29.000 --> 00:09:35.000
また、色をカスタマイズするオプションを使用して、画像の装飾を作成することもできます。

00:09:35.000 --> 00:09:44.000
さらに必要な場合は、customViewデコレーションを使用して、ビュープロバイダーにビューを返します。

00:09:44.000 --> 00:09:53.000
カスタムビューの装飾はインタラクションを許可せず、利用可能なスペースにクリップされることに注意してください。

00:09:53.000 --> 00:09:56.000
ページコントロールも改善されました。

00:09:56.000 --> 00:10:08.000
現在のページのカスタムインジケーター画像のサポートを追加したので、ページが選択されているかどうかに応じて異なる画像を選択できるようになりました。

00:10:08.000 --> 00:10:16.000
これで、ページコントロールの向きと方向の両方を完全にカスタマイズすることもできます。

00:10:16.000 --> 00:10:27.000
以下は、現在のページと非現在のページの間でインジケータが変化する垂直ページコントロールを設定する例です。

00:10:27.000 --> 00:10:41.000
ページコントロールの方向を上から下に設定し、優先インジケーター画像と優先現在のインジケーター画像を設定しました。それだけです!

00:10:41.000 --> 00:10:46.000
Appleは、ユーザーのプライバシーとセキュリティを保護することにコミットしています。

00:10:46.000 --> 00:11:00.000
iOS 15では、システムが提供するペーストインターフェイスを使用せずにアプリケーションがプログラムでペーストボードにアクセスすると、ペーストボードがアクセスされたことを示すバナーが表示されます。

00:11:00.000 --> 00:11:04.000
iOS 16の新機能により、システムの動作が変わりました。

00:11:04.000 --> 00:11:13.000
次に、バナーの代わりに、ペーストボードを使用する許可を求めるアラートを表示します。

00:11:13.000 --> 00:11:23.000
ユーザーが対話するシステムペーストインターフェイスは、ペーストボードへの暗黙のアクセスを提供し、アラートを回避します。

00:11:23.000 --> 00:11:34.000
カスタムペーストコントロールがある場合は、塗りつぶされたUIButtonのように見え、動作する新しいUIPasteControlに置き換えることができます。

00:11:34.000 --> 00:11:43.000
ペーストボードがコントロールの貼り付けターゲットと互換性のあるコンテンツを取得するたびに有効になります。

00:11:43.000 --> 00:11:53.000
したがって、これらは新しい強力なUICalendarView、改良されたUIPageControl、およびセキュリティ指向のUIPasteControlです。

00:11:53.000 --> 00:11:57.000
さあ、それらを試してみてください。

00:11:57.000 --> 00:12:03.000
それでは、私たちが行ったいくつかのAPIの改良をご案内します。

00:12:03.000 --> 00:12:11.000
iOS 15では、柔軟でダイナミックなUIの構築を可能にするシートにデテントが追加されました。

00:12:11.000 --> 00:12:21.000
iOS 16では、任意のサイズのシートを作成できるように、カスタムディテントのサポートを追加しました。

00:12:21.000 --> 00:12:31.000
この機能を利用するには、新しい「.custom」デテントを使用し、シートの高さを関連するブロックのポイントで指定します。

00:12:31.000 --> 00:12:42.000
一定の値、または最大ディテント高さのパーセンテージを返すことができます。

00:12:42.000 --> 00:12:57.000
また、カスタムディテントの上の調光を無効にするなど、他のAPIから参照する必要がある場合は、カスタムディテントに識別子を与えることもできます。

00:12:57.000 --> 00:13:05.000
カスタムブロックから返す値は、ボトムセーフエリアインセットを考慮に入れるべきではないことに注意してください。

00:13:05.000 --> 00:13:13.000
これは、フローティングシートとエッジアタッチシートの両方で同じ計算が機能します。

00:13:13.000 --> 00:13:24.000
システムデテントやその他のオプションを使用したシートのカスタマイズの詳細については、UIKitビデオのシートのカスタマイズとサイズ変更をご覧ください。

00:13:24.000 --> 00:13:33.000
そのビデオのサンプルコードも更新され、これらの新しいカスタムディテントAPIが表示されます。

00:13:33.000 --> 00:13:38.000
UIKitにはSFシンボルの新機能があります。

00:13:38.000 --> 00:13:47.000
シンボルは、モノクロ、マルチカラー、階層、パレットの4つのレンダリングモードをサポートしています。

00:13:47.000 --> 00:13:55.000
UIKitは、シンボルが異なるレンダリングモードで設定されていない限り、デフォルトでモノクロレンダリングを使用します。

00:13:55.000 --> 00:14:07.000
iOS 16では、レンダリングモードが指定されていない場合、UIKitはモノクロ以外のモードで個々のシンボルをレンダリングすることがあります。

00:14:07.000 --> 00:14:10.000
例えば、これらのデバイスシンボルを見てみましょう。

00:14:10.000 --> 00:14:20.000
iOS 15以前では、レンダリングモードが指定されていない場合、これらのシンボルはモノクロレンダリングを使用します。

00:14:20.000 --> 00:14:26.000
iOS 16では、これらのシンボルは代わりに階層的なレンダリングにデフォルト設定されています。

00:14:26.000 --> 00:14:33.000
一般的に、シンボルのデフォルトのレンダリングモードは、シンボルを表示するための好ましい方法です。

00:14:33.000 --> 00:14:40.000
したがって、この場合、デフォルトの階層レンダリングを有効にする必要があります。

00:14:40.000 --> 00:14:55.000
ただし、モノクロレンダリングは、新しいUIImage.SymbolConfiguration. preferringMonochrome() APIで明示的に要求できます。

00:14:55.000 --> 00:15:06.000
UIKitは、アプリが0から1までの値に基づいてシンボルのバリエーションを表示できるように、可変シンボルのサポートを追加しました。

00:15:06.000 --> 00:15:11.000
アプリが現在の音量レベルをシンボルで描写したいとします。

00:15:11.000 --> 00:15:20.000
このアプリは、可変レンダリングをサポートするように更新されたspeaker.3.wave.fillシンボルを使用できます。

00:15:20.000 --> 00:15:27.000
0の値で、スピーカーの波はフェードアウトされ、最も低い音量レベルを示します。

00:15:27.000 --> 00:15:37.000
値が最大1まで増加すると、スピーカーの波は徐々に塗りつぶし、より高い音量レベルを示します。

00:15:37.000 --> 00:15:48.000
シンボルが変数レンダリングをサポートしている場合、アプリは0から1の間の値を反映したシンボルのバージョンを要求できます。

00:15:48.000 --> 00:15:53.000
可変記号を使うのは簡単です。

00:15:53.000 --> 00:16:03.000
UIImageの標準SFシンボルAPIを使用して、シンボルの通常の非変数バージョンを取得できます。

00:16:03.000 --> 00:16:12.000
特定の変数値を持つそのシンボルのバージョンを取得するには、variableValueパラメータを追加するだけです。

00:16:12.000 --> 00:16:20.000
可変レンダリングをパレットなどの他のレンダリングモードと混在させることで、シンボルのスタイルをさらに高めることができます。

00:16:20.000 --> 00:16:32.000
多くのシステムシンボルは現在、変数レンダリングをサポートしており、アプリはカスタムシンボルを更新して変動性もサポートできます。

00:16:32.000 --> 00:16:45.000
カスタム変数シンボルの作成方法を学ぶには、「SFシンボルで可変色を採用」と「SFシンボル4の新機能」のセッションをチェックしてください。

00:16:45.000 --> 00:17:03.000
UIImageやUIColorなどの不変型をSendableに準拠させるなど、新しいSwift並行性機能で動作するようにUIKitを近代化したので、コンパイラの警告なしにMainActorとカスタムアクターの間で送信できます。

00:17:03.000 --> 00:17:16.000
たとえば、ここにはProcessorというカスタムアクターと、MainActorにバインドされているImageViewerというビューコントローラーがあります。

00:17:16.000 --> 00:17:28.000
sendImageForProcessingメソッドでは、ImageViewerは処理のためにプロセッサアクターに画像を送信し、キラキラと虹を追加するようにファンシーにします。

00:17:28.000 --> 00:17:38.000
UIImageは不変であるため、これは安全であるため、プロセッサは虹とキラキラを追加するために新しいコピーを作成する必要があります。

00:17:38.000 --> 00:17:49.000
元の画像への参照を持つコードは、これらの変更を表示せず、共有状態は安全でない変異ではありません。

00:17:49.000 --> 00:17:57.000
これをUIBezierPathと対比してください。UIBezierPathは変更可能であるため、送信できません。

00:17:57.000 --> 00:18:09.000
以前はドキュメントでしか表現できなかったものが、コンパイラでチェックできるようになったのは、どれほどクールですか?

00:18:09.000 --> 00:18:25.000
SendableとSwiftの並行性の詳細については、「Swift並行性を使用してデータレースを排除する」と「Swift並行性の視覚化と最適化」のビデオをご覧ください。

00:18:25.000 --> 00:18:31.000
iOS 16は、外部ディスプレイの新しい強力なサポートを備えています。

00:18:31.000 --> 00:18:41.000
素晴らしいニュースは、古いUIScreen APIを使用していない限り、これを利用するためにアプリを更新する必要がないことです。

00:18:41.000 --> 00:18:46.000
アプリがメイン画面に表示されていると仮定できなくなりました。

00:18:46.000 --> 00:18:55.000
代わりに、トレイトコレクションやUIScene APIなど、より具体的なAPIを参照して、必要な情報を入手してください。

00:18:55.000 --> 00:19:05.000
アプリがまだUISceneを使用していない場合は、アップグレードして複数のウィンドウをサポートする理由がさらに増えます。

00:19:05.000 --> 00:19:12.000
UICollectionViewとUITableViewのセルフサイジングセルが大幅にアップグレードされました。

00:19:12.000 --> 00:19:16.000
今、細胞も自己サイズ変更しています!

00:19:16.000 --> 00:19:28.000
iOS 16では、可視セル内のコンテンツが変更されると、新しいコンテンツに合わせてセルのサイズが自動的に変更されます。

00:19:28.000 --> 00:19:43.000
この新しい動作はデフォルトで有効になっており、UICollectionViewとUITableViewにはそれぞれ新しいselfSizingInvalidationプロパティがあり、この新しい機能を制御できます。

00:19:43.000 --> 00:19:56.000
仕組みは次のとおりです。selfSizingInvalidationが有効になっている場合、セルは包含コレクションまたはテーブルビューによってサイズ変更を要求できます。

00:19:56.000 --> 00:20:08.000
UIListContentConfigurationを使用してセルを設定する場合、セルの設定が変更されるたびに無効化が自動的に行われます。

00:20:08.000 --> 00:20:20.000
それ以外の場合は、セルまたはその contentView で invalidateIntrinsicContentSize メソッドを呼び出して、セルのサイズを変更できます。

00:20:20.000 --> 00:20:33.000
デフォルトでは、セルはアニメーションでサイズ変更されますが、performWithoutAnimation内でindinateIntrinsicContentSizeの呼び出しをラップして、アニメーションなしでサイズを変更することができます。

00:20:33.000 --> 00:20:47.000
UICollectionViewとUITableViewは、最適なタイミングで実行された単一の更新に、セルからのサイズ無効化をインテリジェントに結合します。

00:20:47.000 --> 00:20:57.000
セルで自動レイアウトを使用している場合は、enabledIncludingConstraintsを選択することで、さらに包括的な動作にオプトインできます。

00:20:57.000 --> 00:21:15.000
つまり、セルがcontentView内の自動レイアウト変更を検出すると、自動的にinvalidateIntrinsicContentSizeを呼び出すため、含まれているコレクションまたはテーブルビューは必要に応じてサイズを変更できます。

00:21:15.000 --> 00:21:25.000
これにより、コンテンツやレイアウトの更新に応じて自動的にサイズを調整するセルを持つことが非常に簡単になります。

00:21:25.000 --> 00:21:28.000
UIKitはパワフルで柔軟です。

00:21:28.000 --> 00:21:36.000
また、SwiftUIを使用してUIを実装する表現力を活用することもできます。

00:21:36.000 --> 00:21:43.000
両方のフレームワークを同じアプリに組み込むことがはるかに簡単になりました。

00:21:43.000 --> 00:21:55.000
iOS 16では、SwiftUIを使用してコレクションとテーブルビューのセルを構築するまったく新しい方法があります。

00:21:55.000 --> 00:22:03.000
これは、UIHostingConfigurationという名前の新しいコンテンツ構成タイプによって可能になります。

00:22:03.000 --> 00:22:15.000
たった1行のコードで、セル内でSwiftUIを書き始めることができます。余分なビューやビューコントローラーはまったく必要ありません。

00:22:15.000 --> 00:22:22.000
これは、UIHostingConfigurationを使用してSwiftUIで書かれたシンプルなカスタムセルです。

00:22:22.000 --> 00:22:27.000
このセルを構築するのは非常に簡単です。

00:22:27.000 --> 00:22:43.000
これは、SwiftUIをアプリに統合し始めるのに最適な方法であるだけでなく、SwiftUIの表現力豊かな性質は、UIKitでカスタムセルを構築するためのこれほど強力な方法がなかったことを意味します。

00:22:43.000 --> 00:22:56.000
このトピックにはもっと多くのことがあるので、ビデオ「UIKitでSwiftUIを使用する」を必ずチェックしてください。

00:22:56.000 --> 00:23:02.000
注意すべき小さな、しかし重要な変更がいくつかあります。

00:23:02.000 --> 00:23:14.000
ユーザーがフィンガープリントされるのを防ぐために、UIDevice.nameはユーザーのカスタムデバイス名ではなくモデル名を報告するようになりました。

00:23:14.000 --> 00:23:20.000
カスタマイズされた名前を使用するには、資格を取得する必要があります。

00:23:20.000 --> 00:23:24.000
UIDevice.orientationの設定はサポートされなくなりました。

00:23:24.000 --> 00:23:36.000
代わりに、preferredInterfaceOrientationなどのUIViewController APIを使用して、インターフェイスの意図した向きを表現します。

00:23:36.000 --> 00:23:38.000
次は何ですか?

00:23:38.000 --> 00:23:43.000
iOS 16 SDKを使用してアプリをコンパイルします。

00:23:43.000 --> 00:23:50.000
テキスト編集メニューや検索と置換などの新機能をテストします。

00:23:50.000 --> 00:23:57.000
新しいUIKit APIを採用して、新しい強化されたコントロールと生産性機能を使用します。

00:23:57.000 --> 00:24:05.000
そして、UIKitアプリにSwiftUIを組み込む新しいエキサイティングな方法を試してみてください。

00:24:05.000 --> 23:59:59.000
ありがとうございます。♪ ♪

