WEBVTT

00:00:00.000 --> 00:00:03.000
♪まろやかなインストゥルメンタルヒップホップ音楽♪

00:00:03.000 --> 00:00:10.000
♪

00:00:10.000 --> 00:00:15.000
Meng Yang: こんにちは、私の名前はMeng Yangです。ここAppleのGPUソフトウェアのエンジニアです。

00:00:15.000 --> 00:00:26.000
今日は、ScreenCaptureKitに関するいくつかの高度なトピックと、アプリの画面共有体験を次のレベルに引き上げる方法について説明します。

00:00:26.000 --> 00:00:32.000
後で、私の同僚のドリューは、このエキサイティングな新しいAPIを実際に実演します。

00:00:32.000 --> 00:00:55.000
スクリーンキャプチャは、Zoom、Google Meet、SharePlayなどの画面共有アプリケーション、さらにはTwitchなどの人気のあるゲームストリーミングサービスの中心であり、過去数年間で私たちの働き方、勉強、コラボレーション、社交の新しい規範となっています。

00:00:55.000 --> 00:01:05.000
ScreenCaptureKitは、強力な機能セットでゼロから構築された、まったく新しい高性能スクリーンキャプチャフレームワークです。

00:01:05.000 --> 00:01:21.000
豊富な機能セットには、高度にカスタマイズ可能なコンテンツコントロールが含まれており、キャプチャするウィンドウ、アプリケーション、ディスプレイの任意の組み合わせを簡単に選択して選択できます。

00:01:21.000 --> 00:01:28.000
画面コンテンツのネイティブ解像度とフレームレートまでキャプチャする機能。

00:01:28.000 --> 00:01:34.000
解像度、フレームレート、ピクセルフォーマットなどの動的ストリームプロパティコントロール。

00:01:34.000 --> 00:01:40.000
そして、これらのコントロールは、ストリームを再作成することなく、その場で変更することができます。

00:01:40.000 --> 00:01:47.000
メモリコピーを減らすために、GPUメモリバックアップのバッファをキャプチャします。

00:01:47.000 --> 00:01:59.000
ハードウェアで加速されたコンテンツキャプチャ、スケーリング、ピクセル、カラーフォーマット変換により、CPU使用率を削減した高性能キャプチャを実現します。

00:01:59.000 --> 00:02:07.000
最後になりましたが、ビデオとオーディオの両方のキャプチャをサポートします。

00:02:07.000 --> 00:02:17.000
始める前に、この講演では、フレームワークの仕組みの基本的な概念、ビルディングブロック、ワークフローにすでに精通していることを前提としています。

00:02:17.000 --> 00:02:23.000
詳細については、イントロセッション「Meet ScreenCaptureKit」をご覧ください。

00:02:23.000 --> 00:02:30.000
このセッションでは、単一のウィンドウをキャプチャして表示する方法について説明します。

00:02:30.000 --> 00:02:36.000
次に、フルディスプレイキャプチャに画面コンテンツを追加する方法。

00:02:36.000 --> 00:02:40.000
ディスプレイキャプチャからコンテンツを削除する方法。

00:02:40.000 --> 00:02:48.000
次に、さまざまなユースケース用にストリームを設定する方法をいくつか紹介します。

00:02:48.000 --> 00:03:03.000
そして最後に、ScreenCaptureKitが人気のあるオープンソースのスクリーンキャプチャアプリであるOBS Studioの画面とオーディオのキャプチャ体験をどのように変えたかのデモを見ることができます。

00:03:03.000 --> 00:03:14.000
さて、最初の例から始めましょう。おそらく最も一般的なユースケースは、単一のウィンドウをキャプチャすることです。

00:03:14.000 --> 00:03:30.000
この例では、単一のウィンドウフィルターを設定する方法について説明します。キャプチャされたウィンドウがサイズ変更、閉塞、画面外、または最小化されているときに、ストリーム出力から何を期待するかについて説明します。

00:03:30.000 --> 00:03:38.000
また、フレームごとのメタデータの使用方法と、キャプチャされたウィンドウを適切に表示する方法も学びます。

00:03:38.000 --> 00:03:40.000
飛び込みましょう。

00:03:40.000 --> 00:03:54.000
どのディスプレイに依存しない単一のウィンドウをキャプチャするには、単一のウィンドウフィルターを使用して開始し、1つのウィンドウでフィルターを初期化できます。

00:03:54.000 --> 00:04:01.000
この例では、フィルターは単一のSafariウィンドウを含むように設定されています。

00:04:01.000 --> 00:04:06.000
ビデオ出力には、そのウィンドウだけが含まれており、他には何も含まれていません。

00:04:06.000 --> 00:04:13.000
Safariの子供、ポップアップ、その他のウィンドウは含まれません。

00:04:13.000 --> 00:04:20.000
一方、ScreenCaptureKitのオーディオキャプチャポリシーは、常にアプリレベルで機能します。

00:04:20.000 --> 00:04:36.000
単一のウィンドウフィルターを使用すると、ビデオ出力に存在しないウィンドウからでも、ウィンドウを含むアプリケーションからのすべてのオーディオコンテンツがキャプチャされます。

00:04:36.000 --> 00:04:40.000
では、コードサンプルを見てみましょう。

00:04:40.000 --> 00:04:50.000
単一のウィンドウでストリームを作成するには、利用可能なすべてのコンテンツをSCShareableContent経由で共有することから始めます。

00:04:50.000 --> 00:04:58.000
次に、windowIDと一致して、SCShareableContentから共有するウィンドウを取得します。

00:04:58.000 --> 00:05:08.000
次に、指定されたSCWindowでdesktopIndependentWindowタイプのSCContentFilterを作成します。

00:05:08.000 --> 00:05:15.000
ストリーム出力の一部としてオーディオを含めるようにストリームをさらに設定できます。

00:05:15.000 --> 00:05:21.000
これで、contentFilterとstreamConfigでストリームを作成する準備が整いました。

00:05:21.000 --> 00:05:27.000
その後、StreamOutputを追加してストリームを開始できます。

00:05:27.000 --> 00:05:31.000
次に、ストリーム出力を見てみましょう。 

00:05:31.000 --> 00:05:40.000
この例では、ソース表示は左側に、ストリーム出力は右側にあります。

00:05:40.000 --> 00:05:45.000
ストリームフィルターには、単一のSafariウィンドウが含まれています。

00:05:45.000 --> 00:05:52.000
今から、キャプチャされているSafariウィンドウをスクロールし始めます。

00:05:52.000 --> 00:06:06.000
ストリーム出力には、単一のSafariウィンドウからのライブコンテンツが含まれており、ソースウィンドウと同じケイデンスで、ソースディスプレイのネイティブフレームレートまで更新されます。

00:06:06.000 --> 00:06:20.000
たとえば、ソースウィンドウが120Hzディスプレイで常に更新されている場合、ストリーム出力は最大120fpsの更新も実現できます。

00:06:20.000 --> 00:06:24.000
ウィンドウのサイズが変更されるとどうなるのか疑問に思うかもしれません。

00:06:24.000 --> 00:06:36.000
ストリームの出力ディメンションを頻繁に変更すると、追加のメモリ割り当てにつながる可能性があるため、推奨されないことに注意してください。

00:06:36.000 --> 00:06:44.000
ストリームの出力ディメンションはほとんど固定されており、ソースウィンドウでサイズを変更しません。

00:06:44.000 --> 00:06:51.000
では、ソースウィンドウのサイズを変更して、ストリームの出力がどうなるか見てみましょう。

00:06:51.000 --> 00:07:03.000
ScreenCaptureKitは常にキャプチャされたウィンドウでハードウェアスケーリングを実行するため、ソースウィンドウのサイズが変更されるときにフレーム出力を超えることはありません。

00:07:03.000 --> 00:07:07.000
他の窓で覆われている窓はどうですか？

00:07:07.000 --> 00:07:19.000
ソースウィンドウがオクルードまたは部分的にオクルードされている場合、ストリーム出力には常にウィンドウの完全なコンテンツが含まれます。

00:07:19.000 --> 00:07:28.000
また、これは、ウィンドウが完全に画面から外れたり、他のディスプレイに移動したりした場合にも当てはまります。

00:07:28.000 --> 00:07:41.000
また、最小化されたウィンドウの場合、ソースウィンドウが最小化されると、ストリーム出力は一時停止され、ソースウィンドウが最小化されなくなったときに再開されます。

00:07:41.000 --> 00:07:45.000
次に、オーディオ出力に移りましょう。

00:07:45.000 --> 00:07:55.000
この例では、オーディオトラック付きの2つのSafariウィンドウがあり、左側のウィンドウがキャプチャされています。

00:07:55.000 --> 00:08:05.000
ビデオ出力には最初のウィンドウのみが含まれ、両方のSafariウィンドウのオーディオトラックがオーディオ出力に含まれます。

00:08:05.000 --> 00:08:07.000
見て聞いてみましょう。

00:08:07.000 --> 00:08:12.000
♪エレクトロニックダンスミュージック♪

00:08:12.000 --> 00:08:16.000
シェフ：そして、私はお気に入りのワカモレのレシピを書き留めました。

00:08:16.000 --> 00:08:19.000
4つのアボカドが必要です。

00:08:19.000 --> 00:08:27.000
Meng: ストリームが稼働すると、新しいフレームが利用可能になるたびに、アプリはフレームの更新を受け取ります。

00:08:27.000 --> 00:08:36.000
フレームの出力には、キャプチャされたフレームとフレームごとのメタデータを表すIOSurfaceが含まれています。

00:08:36.000 --> 00:08:42.000
メタデータについて話すのに時間を費やしたいと思います。

00:08:42.000 --> 00:08:48.000
アプリに非常に役立つメタデータの例をお見せします。

00:08:48.000 --> 00:08:58.000
そして、これらには、ダーティレクト、コンテンツレクト、コンテンツスケール、スケールファクターが含まれます。

00:08:58.000 --> 00:09:01.000
汚い直腸から始めましょう。

00:09:01.000 --> 00:09:06.000
汚いrectsは、新しいコンテンツが前のフレームのどこにあるかを示します。

00:09:06.000 --> 00:09:15.000
この例では、フレーム更新の領域を説明するために、汚れた直腸が強調表示されています。

00:09:15.000 --> 00:09:38.000
常にフレーム全体をエンコードしたり、エンコーダ内の2つのフレーム間のデルタを計算したりする代わりに、ダーティレクトを使用して、新しい更新で領域のみをエンコードして送信し、更新をレシーバー側の前のフレームにコピーして新しいフレームを生成することができます。

00:09:38.000 --> 00:09:49.000
汚れたrectsは、マッチングキーを使用して、出力CMSampleBufferのメタデータ辞書から取得できます。

00:09:49.000 --> 00:09:54.000
では、コンテンツrectとコンテンツスケールに移りましょう。

00:09:54.000 --> 00:10:02.000
キャプチャするソースウィンドウは左側にあり、ストリーム出力は右側にあります。

00:10:02.000 --> 00:10:13.000
ウィンドウのサイズを変更できるため、ソースウィンドウのネイティブバッキングサーフェスサイズは、ストリーム出力のディメンションと一致しないことがよくあります。

00:10:13.000 --> 00:10:22.000
この例では、キャプチャされたウィンドウはフレームの出力とは異なるアスペクト比を持ち、より大きくなっています。

00:10:22.000 --> 00:10:29.000
キャプチャされたウィンドウは、出力に収まるように縮小されます。

00:10:29.000 --> 00:10:40.000
ここで緑色で強調表示されているコンテンツrectは、ストリーム出力でキャプチャされたコンテンツの関心のある領域を示します。

00:10:40.000 --> 00:10:46.000
そして、コンテンツのスケールは、コンテンツがどれだけ適合するようにスケーリングされているかを示します。

00:10:46.000 --> 00:10:55.000
ここでは、キャプチャされたSafariウィンドウは、フレーム内に収まるように0.77縮小されます。

00:10:55.000 --> 00:11:06.000
これで、先ほど説明したメタデータを使用して、キャプチャされたウィンドウをできるだけネイティブの外観に正しく表示できます。

00:11:06.000 --> 00:11:13.000
まず、コンテンツrectを使用して出力からコンテンツをトリミングすることから始めましょう。

00:11:13.000 --> 00:11:20.000
次に、コンテンツのスケールを分割してコンテンツをスケールアップします。

00:11:20.000 --> 00:11:28.000
これで、キャプチャされたコンテンツは、ソースウィンドウとして1対1のピクセルサイズに一致するようにスケーリングされます。

00:11:28.000 --> 00:11:33.000
しかし、キャプチャされたウィンドウはターゲットディスプレイでどのように見えますか?

00:11:33.000 --> 00:11:40.000
その質問に答えるために、スケールファクターがどのように機能するかを説明することから始めたいと思います。

00:11:40.000 --> 00:11:53.000
ディスプレイのスケールファクターは、ディスプレイまたはウィンドウの論理ポイントサイズとそのバッキングサーフェスのピクセルサイズの間のスケール比を示します。

00:11:53.000 --> 00:12:03.000
スケールファクター2、または2倍モードは、画面上のすべてのポイントがバッキングサーフェスの4ピクセルに等しいことを意味します。

00:12:03.000 --> 00:12:17.000
ウィンドウは、この例のようにスケールファクター2のRetinaディスプレイから、キャプチャ中にスケールファクター1の非Retinaディスプレイに移動できます。

00:12:17.000 --> 00:12:26.000
スケールファクター1では、画面上の各論理ポイントは、裏面上の1ピクセルに対応します。

00:12:26.000 --> 00:12:38.000
さらに、ソースディスプレイには、キャプチャされたコンテンツが表示されるターゲットディスプレイとのスケールファクターが一致しない可能性があります。

00:12:38.000 --> 00:12:52.000
この例では、ウィンドウはスケールファクター2で左側のRetinaディスプレイからキャプチャされ、右側の非Retinaディスプレイに表示されます。

00:12:52.000 --> 00:13:06.000
キャプチャされたウィンドウが、1ポイントから1ピクセルのマッピングでターゲットの非Retinaディスプレイにスケーリングせずにそのまま表示される場合、ウィンドウは4倍の大きさに見えます。

00:13:06.000 --> 00:13:16.000
これを修正するには、常にフレームのメタデータのスケールファクターをターゲットディスプレイのスケールファクターと照合する必要があります。

00:13:16.000 --> 00:13:24.000
不一致がある場合は、表示する前に、キャプチャしたコンテンツのサイズをスケールファクターで拡大縮小します。

00:13:24.000 --> 00:13:34.000
スケーリング後、ターゲットディスプレイのキャプチャされたウィンドウは、ソースウィンドウと同じサイズに見えるようになりました。

00:13:34.000 --> 00:13:39.000
さて、コードを見てみましょう、それは非常に簡単です。それは非常に簡単です。

00:13:39.000 --> 00:13:51.000
コンテンツrect、コンテンツスケール、およびスケールファクターは、出力CMSampleBufferのメタデータ添付ファイルから取得することもできます。

00:13:51.000 --> 00:14:00.000
その後、これらのメタデータを使用して、キャプチャしたコンテンツをトリミングして拡大縮小し、正しく表示することができます。

00:14:00.000 --> 00:14:11.000
要約すると、単一のウィンドウフィルターには、ソースウィンドウがオフスクリーンまたは閉塞している場合でも、常に完全なウィンドウコンテンツが含まれています。

00:14:11.000 --> 00:14:14.000
ディスプレイとスペースに依存しません。

00:14:14.000 --> 00:14:20.000
出力は常に左上隅でオフセットされます。

00:14:20.000 --> 00:14:25.000
ポップアップウィンドウや子ウィンドウは含まれていません。

00:14:25.000 --> 00:14:29.000
メタデータを使用してコンテンツを最適に表示することを検討してください。

00:14:29.000 --> 00:14:35.000
また、オーディオには、含まれているアプリ全体のトラックが含まれています。

00:14:35.000 --> 00:14:46.000
単一のウィンドウをキャプチャして表示する方法を学んだばかりなので、表示ベースのコンテンツフィルタの次のクラスに移りましょう。

00:14:46.000 --> 00:15:00.000
この次の例では、ウィンドウやアプリでディスプレイベースのフィルターを作成する方法を学び、ビデオフィルタリングとオーディオフィルタリングのルールの違いをいくつか示します。

00:15:00.000 --> 00:15:07.000
ディスプレイベースのインクルージョンフィルターは、コンテンツをキャプチャするディスプレイを指定します。

00:15:07.000 --> 00:15:11.000
デフォルトでは、ウィンドウはキャプチャされません。

00:15:11.000 --> 00:15:15.000
キャプチャするコンテンツをウィンドウで選択できます。

00:15:15.000 --> 00:15:23.000
この例では、SafariウィンドウとKeynoteウィンドウが表示フィルターに追加されています。

00:15:23.000 --> 00:15:37.000
ビデオ出力には、ディスプレイスペースに配置されたこれら2つのウィンドウのみが含まれ、オーディオ出力にはKeynoteとSafariアプリのすべてのサウンドトラックが含まれています。

00:15:37.000 --> 00:15:44.000
このコードサンプルは、付属のウィンドウでディスプレイベースのフィルターを作成する方法を示しています。

00:15:44.000 --> 00:15:52.000
SCShareableContentとwindowIDを使用してSCWindowsのリストを作成することから始めます。

00:15:52.000 --> 00:16:01.000
次に、指定されたディスプレイと含まれているウィンドウのリストを使用して、ディスプレイベースのSCContentFilterを作成します。

00:16:01.000 --> 00:16:13.000
その後、デスクトップに依存しないウィンドウと同じ方法でフィルターと設定を使用してストリームを作成し、ストリームを開始できます。

00:16:13.000 --> 00:16:18.000
ストリームを稼働させたら、ストリームの出力を見てみましょう。

00:16:18.000 --> 00:16:30.000
フィルターは、2つのSafariウィンドウ、メニューバー、壁紙ウィンドウを含むように設定されています。

00:16:30.000 --> 00:16:37.000
ウィンドウが画面から移動されると、ストリーム出力から削除されます。

00:16:37.000 --> 00:16:48.000
新しいSafariウィンドウが作成されると、新しいウィンドウがフィルターにないため、新しいウィンドウはストリーム出力に表示されません。

00:16:48.000 --> 00:16:56.000
同じルールは、ストリームの出力に表示されない子ウィンドウまたはポップアップウィンドウにも適用されます。

00:16:56.000 --> 00:17:07.000
子ウィンドウがストリーム出力に自動的に含まれていることを確認したい場合は、付属のアプリでディスプレイベースのフィルターを使用できます。

00:17:07.000 --> 00:17:36.000
この例では、SafariアプリとKeynoteアプリをフィルターに追加すると、これらの2つのアプリのすべてのウィンドウとサウンドトラックからのオーディオとビデオ出力が出力ウィンドウ例外フィルターに含まれることが、フィルターが付属のアプリでディスプレイとして指定されている場合に、出力から特定のウィンドウを除外する強力な方法です。

00:17:36.000 --> 00:17:42.000
たとえば、単一のSafariウィンドウが出力から削除されます。

00:17:42.000 --> 00:17:57.000
ScreenCaptureKitはアプリレベルでのオーディオキャプチャを可能にするため、単一のSafariウィンドウからオーディオを除外することは、すべてのSafariアプリのオーディオトラックを削除するのと同じです。

00:17:57.000 --> 00:18:13.000
ストリームのビデオ出力にはまだSafariウィンドウが含まれていますが、Safariアプリのすべてのサウンドトラックが削除され、オーディオ出力にはKeynoteのサウンドトラックのみが含まれています。

00:18:13.000 --> 00:18:23.000
ここのコード例では、SCContentFilterをSCWindowsの代わりにSCRunningApplicationsのリストを含むように変更します。

00:18:23.000 --> 00:18:41.000
さらに除外したい個々のウィンドウがある場合は、SCWindowsのリストを作成し、除外するウィンドウのリストを持つSCApplicationsのリストを使用してSCContentFilterを作成します。

00:18:41.000 --> 00:18:51.000
含まれているアプリを指定して、新しいウィンドウまたは子ウィンドウが作成されると、ストリーム出力がどのように見えるかを見てみましょう。

00:18:51.000 --> 00:18:58.000
今回は、Safariアプリとシステムウィンドウがフィルターに追加されます。

00:18:58.000 --> 00:19:08.000
新しいSafariウィンドウがストリーム出力に自動的に含まれるようになり、子ウィンドウとポップアップウィンドウにも同じルールが適用されます。

00:19:08.000 --> 00:19:19.000
これは、チュートリアルを行っていて、ポップアップや新しいウィンドウを呼び出すなど、完全なアクションを実演したいときに非常に便利です。

00:19:19.000 --> 00:19:26.000
いくつかの異なる方法でストリーム出力にコンテンツを追加する方法を実演しました。

00:19:26.000 --> 00:19:32.000
次の例では、ストリーム出力からコンテンツを削除する方法を説明します。

00:19:32.000 --> 00:19:43.000
この例には、共有されているディスプレイのプレビューを含むビデオ会議アプリをエミュレートするテストアプリが含まれています。

00:19:43.000 --> 00:19:52.000
テストアプリはプレビューに再帰的に表示されるため、いわゆるミラーホール効果を生み出しています。

00:19:52.000 --> 00:20:10.000
フルディスプレイ共有中でも、画面共有アプリケーションが独自のウィンドウ、キャプチャプレビュー、ミラーホール効果を回避するための参加者カメラビュー、または通知ウィンドウなどの他のシステムUIを削除するのが一般的です。

00:20:10.000 --> 00:20:21.000
ScreenCaptureKitは、ディスプレイキャプチャからコンテンツをすばやく削除できる一連の除外ベースのフィルターを提供します。

00:20:21.000 --> 00:20:28.000
除外ベースのディスプレイフィルタは、デフォルトで指定されたディスプレイからすべてのウィンドウをキャプチャします。

00:20:28.000 --> 00:20:35.000
その後、除外フィルターに追加することで、個々のウィンドウやアプリの削除を開始できます。

00:20:35.000 --> 00:20:46.000
たとえば、コンテンツキャプチャテストアプリと通知センターを除外されたアプリケーションのリストに追加できます。

00:20:46.000 --> 00:20:59.000
アプリケーションのリストを除外する表示ベースのフィルタを作成するには、まずSCApplicationsを取得してバンドルIDを一致させて除外します。

00:20:59.000 --> 00:21:10.000
ストリーム出力に戻りたい個々のウィンドウがある場合は、SCWindows以外のオプションリストを作成することもできます。

00:21:10.000 --> 00:21:22.000
そして、特定のディスプレイ、除外するアプリケーションのリスト、および除外ウィンドウのリストを使用して、コンテンツフィルターを作成します。

00:21:22.000 --> 00:21:26.000
結果を見てみましょう。 見ていきましょう。

00:21:26.000 --> 00:21:36.000
ミラーホールの問題を引き起こしているコンテンツキャプチャテストアプリと通知ウィンドウは、どちらもストリーム出力から削除されます。

00:21:36.000 --> 00:21:43.000
これらのアプリから新しいウィンドウまたは子ウィンドウも自動的に削除されます。

00:21:43.000 --> 00:21:50.000
これらの削除されたアプリにオーディオが含まれている場合、そのオーディオはオーディオ出力から削除されます。

00:21:50.000 --> 00:21:58.000
単一のウィンドウをキャプチャする方法、ディスプレイフィルターからウィンドウを追加および削除する方法を見ました。

00:21:58.000 --> 00:22:02.000
次にストリーム設定に移りましょう。

00:22:02.000 --> 00:22:18.000
次のいくつかの例では、設定できるさまざまなストリームプロパティ、スクリーンキャプチャとストリーミング用のストリームの設定方法、ライブプレビューでウィンドウピッカーを構築する方法について学びます。

00:22:18.000 --> 00:22:22.000
設定プロパティから始めましょう。

00:22:22.000 --> 00:22:43.000
これらは、ストリーム出力寸法、送信元と宛先のrects、色空間、カラーマトリックス、ピクセル形式、カーソルを含めるかどうか、フレームレート制御など、設定できる一般的なストリームプロパティの一部です。

00:22:43.000 --> 00:22:48.000
次に、各物件の詳細を見ていきます。

00:22:48.000 --> 00:22:56.000
幅と高さをピクセル単位で指定できる出力寸法から始めましょう。

00:22:56.000 --> 00:23:04.000
ソースディスプレイのディメンションとアスペクト比は、必ずしも出力ディメンションと一致するとは限りません。

00:23:04.000 --> 00:23:13.000
そして、フルディスプレイのキャプチャ中にこのミスマッチが発生すると、ストリーム出力にピラーまたはレターボックスがあります。

00:23:13.000 --> 00:23:26.000
また、キャプチャする領域を定義するソースrectを指定して、結果がレンダリングされ、フレーム出力の宛先rectにスケーリングされることもできます。

00:23:26.000 --> 00:23:36.000
ScreenCaptureKitは、ハードウェアアクセラレーション色空間、カラーマトリックス、ピクセルフォーマット変換をサポートしています。

00:23:36.000 --> 00:23:41.000
一般的なBGRAとYUVフォーマットがサポートされています。

00:23:41.000 --> 00:23:46.000
完全なリストについては、開発者ページをご覧ください。

00:23:46.000 --> 00:23:54.000
ショーカーソルが有効になっている場合、ストリーム出力にはフレームにプリレンダリングされたカーソルが含まれます。

00:23:54.000 --> 00:24:02.000
これは、カメラ型のカーソルのようなカスタムカーソルでも、すべてのシステムカーソルに適用されます。

00:24:02.000 --> 00:24:08.000
最小フレーム間隔を使用して、目的の出力フレームレートを制御できます。

00:24:08.000 --> 00:24:16.000
たとえば、60 fpsをリクエストする場合は、最小間隔を1/60に設定します。

00:24:16.000 --> 00:24:26.000
フレーム更新は60fps以下で、コンテンツのネイティブフレームレート以下です。

00:24:26.000 --> 00:24:34.000
キューの深さを指定して、サーバー側のサーフェスプール内のサーフェスの数を決定できます。

00:24:34.000 --> 00:24:50.000
プール内のサーフェスが増えると、フレームレートとパフォーマンスが向上しますが、システムメモリの使用率が高くなり、レイテンシのトレードオフが発生する可能性があります。これについては後で詳しく説明します。

00:24:50.000 --> 00:24:59.000
ScreenCaptureKitは、デフォルトのキューの深さが3で3から8の間のキューの深さ範囲を受け入れます。

00:24:59.000 --> 00:25:09.000
この例では、サーフェスプールは、ScreenCaptureKitがレンダリングできる4つのサーフェスを含むように構成されています。

00:25:09.000 --> 00:25:19.000
現在のアクティブサーフェスはサーフェス1で、ScreenCaptureKitは次のフレームをレンダリングしています。

00:25:19.000 --> 00:25:26.000
サーフェス1が完了すると、ScreenCaptureKitはサーフェス1をアプリに送信します。

00:25:26.000 --> 00:25:35.000
アプリはサーフェス1を処理して保持していますが、ScreenCaptureKitはサーフェス2にレンダリングされています。

00:25:35.000 --> 00:25:43.000
Surface 1は、アプリがまだ使用中であるため、プールで使用不可としてマークされるようになりました。

00:25:43.000 --> 00:25:51.000
サーフェス2が完了すると、アプリに送信され、ScreenCaptureKitがサーフェス3にレンダリングされるようになりました。

00:25:51.000 --> 00:26:03.000
しかし、アプリがまだサーフェス1を処理している場合は、フレームが処理できるよりも速く提供されるため、遅れ始めます。

00:26:03.000 --> 00:26:15.000
サーフェスプールに多数のサーフェスが含まれている場合、新しいサーフェスが積み重なり始め、追いつくためにフレームをドロップし始めることを検討する必要があるかもしれません。

00:26:15.000 --> 00:26:22.000
この場合、プール内のより多くのサーフェスが、より高いレイテンシにつながる可能性があります。

00:26:22.000 --> 00:26:34.000
ScreenCaptureKitが使用するプールに残っているサーフェスの数は、キューの深さからアプリが保持するサーフェスの数を差し引いたものと同じです。

00:26:34.000 --> 00:26:40.000
この例では、サーフェス1と2の両方がまだアプリによって保持されています。

00:26:40.000 --> 00:26:45.000
表面プールには2つの表面が残っています。

00:26:45.000 --> 00:26:54.000
サーフェス3が完了し、アプリに送信された後、プールに残っている唯一の利用可能なサーフェスはサーフェス4です。

00:26:54.000 --> 00:27:07.000
アプリがサーフェス1、2、3を保持し続けると、ScreenCaptureKitはすぐにレンダリングするサーフェスを使い果たし、フレームの損失とグリッチが見られます。

00:27:07.000 --> 00:27:20.000
フレームの損失を避けるために、ScreenCaptureKitがサーフェス4の後に次のフレームをレンダリングし始める前に、アプリはサーフェス1を終了してリリースする必要があります。

00:27:20.000 --> 00:27:27.000
これで、アプリはサーフェス1をリリースし、ScreenCaptureKitが再び使用できるようになりました。

00:27:27.000 --> 00:27:35.000
要約すると、フレームレイテンシとフレーム損失を避けるために、アプリが従う必要がある2つのルールがあります。

00:27:35.000 --> 00:27:42.000
フレームの遅延を回避するには、MinimumFrameInterval内でフレームを処理できる必要があります。

00:27:42.000 --> 00:28:04.000
フレームの損失を避けるために、アプリがサーフェスをプールに戻すのにかかる時間は、MinimumFrameInterval時間QueueDepthマイナス1未満でなければなりません。その後、ScreenCaptureKitは使用するサーフェスを使い果たし、ストールに入り、新しいフレームを見逃し始めます。

00:28:04.000 --> 00:28:15.000
設定できるさまざまなプロパティを見たので、スクリーンキャプチャとストリーミング用のストリームを設定するためのいくつかの例を掘り下げてみましょう。

00:28:15.000 --> 00:28:26.000
一部の画面コンテンツには、常に更新され、より高いフレームレートを必要とするビデオ、ゲーム、またはアニメーションが含まれています。

00:28:26.000 --> 00:28:45.000
他のものには、フレームレートよりも高解像度を優先する基調講演ウィンドウのような主に静的なテキストが含まれていますが、共有されるコンテンツとネットワーク状態に基づいてストリームの設定をライブ調整できます。

00:28:45.000 --> 00:28:55.000
このコード例では、4K、60fpsのゲームをストリーミングするようにキャプチャを設定する方法を見て回ります。

00:28:55.000 --> 00:29:01.000
ストリーム出力の寸法をピクセルサイズで4Kに設定することから始めることができます。

00:29:01.000 --> 00:29:10.000
そして、最小フレーム間隔を1/60に設定して、出力フレームレートを60fpsに設定します。

00:29:10.000 --> 00:29:18.000
次に、エンコードとストリーミングにピクセル形式のYUV420を使用します。

00:29:18.000 --> 00:29:25.000
オプションのソースrectを設定して、画面の一部だけをキャプチャします。

00:29:25.000 --> 00:29:33.000
次に、背景塗りつぶし色を黒に変更し、フレーム出力にカーソルを含めます。

00:29:33.000 --> 00:29:39.000
最適なフレームレートとパフォーマンスのために、サーフェスキューの深さを5に設定します。

00:29:39.000 --> 00:29:45.000
最後に、出力ストリームでオーディオを有効にします。

00:29:45.000 --> 00:29:55.000
前の例で見たすべてのストリーム構成は、ストリームを再作成することなく、その場で動的に変更できます。

00:29:55.000 --> 00:30:07.000
たとえば、出力ディメンションなどの一部のプロパティをライブ調整したり、フレームレートを動的に変更したり、ストリームフィルタを更新したりできます。

00:30:07.000 --> 00:30:14.000
出力寸法を4Kから720pに切り替える例を次に示します。

00:30:14.000 --> 00:30:21.000
そして、フレームレートを60fpsから15fpsにダウングレードします。

00:30:21.000 --> 00:30:31.000
その後、updateConfigurationを呼び出すだけで、ストリームを中断することなく、その場で新しい設定を適用できます。

00:30:31.000 --> 00:30:39.000
最後の例では、ライブプレビュー付きのウィンドウピッカーの構築をご案内したいと思います。

00:30:39.000 --> 00:30:45.000
以下は、典型的なウィンドウピッカーがどのように見えるかの例です。

00:30:45.000 --> 00:30:55.000
ウェブ会議の画面共有アプリは、共有する正確なウィンドウを選択するオプションをユーザーに提供するのが一般的です。

00:30:55.000 --> 00:31:09.000
ScreenCaptureKitは、ライブコンテンツの更新で多数のサムネイルサイズのストリームを作成するための効率的で高性能なソリューションを提供し、実装が簡単です。

00:31:09.000 --> 00:31:17.000
それを分解して、ScreenCaptureKitを使用してこのようなウィンドウピッカーを構築するために何が必要かを見てみましょう。

00:31:17.000 --> 00:31:31.000
ピッカーを設定するには、アプリがユーザーがデスクトップに依存しないウィンドウをフィルタータイプとして選択できる対象ウィンドウごとに1つのウィンドウフィルターを作成することから始めることができます。

00:31:31.000 --> 00:31:48.000
次に、オンスクリーン表示用のBGRAピクセルフォーマット、デフォルトのキューの深さ、カーソルやオーディオなしで、サムネイルサイズの5 fpsのストリーム構成を設定します。

00:31:48.000 --> 00:31:57.000
単一のウィンドウフィルターとここでのストリーム構成を使用して、各ウィンドウに1つのストリームを作成します。

00:31:57.000 --> 00:32:07.000
コードでこれを行うには、デスクトップとシステムウィンドウを除外してSCShareableContentを取得することから始めることができます。

00:32:07.000 --> 00:32:16.000
次に、対象となるウィンドウごとにデスクトップに依存しないウィンドウタイプのコンテンツフィルターを作成します。

00:32:16.000 --> 00:32:21.000
次に、ストリーム設定部分に移動します。

00:32:21.000 --> 00:32:33.000
適切なサムネイルサイズ（この例では、284×182）を選択し、最小フレーム間隔を1対5に設定します。

00:32:33.000 --> 00:32:45.000
画面表示用のBGRAのピクセル形式では、プレビューでそれらを必要としないため、オーディオとカーソルを無効にします。

00:32:45.000 --> 00:32:52.000
そして、あまりにも頻繁な更新を期待していないので、キューの深さを3に設定します。

00:32:52.000 --> 00:32:59.000
ストリームコンテンツフィルターと構成が作成されると、ストリームを作成する準備が整いました。

00:32:59.000 --> 00:33:08.000
ウィンドウごとに1つのストリームを作成し、各ストリームにストリーム出力を追加し、ストリームを開始します。

00:33:08.000 --> 00:33:13.000
最後に、ストリームリストに追加します。

00:33:13.000 --> 00:33:20.000
これは、先ほど見たサンプルコードを使用して作成されたライブプレビュー付きのウィンドウピッカーです。

00:33:20.000 --> 00:33:29.000
各サムネイルはライブ更新され、シングルウィンドウフィルターを備えた個々のストリームによってバックアップされます。

00:33:29.000 --> 00:33:44.000
ScreenCaptureKitを使用すると、このようなライブプレビューピッカーを簡単に構築できます。これにより、システムに負担をかけることなく、同時に多くのライブ画面コンテンツを同時にキャプチャできます。

00:33:44.000 --> 00:33:54.000
それでは、同僚のドリューに渡しましょう。ドリューは、ScreenCaptureKitのOBS採用に関するエキサイティングなデモを提供します。

00:33:54.000 --> 00:33:56.000
ドリュー・ミルズ:ありがとう、メン。

00:33:56.000 --> 00:33:59.000
こんにちは、私の名前はドリューで、アップルのパートナーエンジニアです。

00:33:59.000 --> 00:34:05.000
OBS Studioは、ユーザーが自分のコンピュータから録画やストリーミングコンテンツを管理できるオープンソースアプリケーションです。

00:34:05.000 --> 00:34:11.000
これには、この春に統合するプロジェクトに協力したScreenCaptureKitの実装が含まれています。

00:34:11.000 --> 00:34:18.000
ScreenCaptureKitは、OBSの既存のCGDisplayStreamベースのキャプチャと同様のコードを利用したため、簡単に実装できました。

00:34:18.000 --> 00:34:24.000
ScreenCaptureKitの実装は、「Meet ScreenCaptureKit」セッションで議論された多くの機能を示しています。

00:34:24.000 --> 00:34:30.000
これには、デスクトップ全体、アプリケーションのすべてのウィンドウ、または1つの特定のウィンドウのキャプチャが含まれます。

00:34:30.000 --> 00:34:36.000
ScreenCaptureKitは、OBSのCGWindowListCreateImageベースのキャプチャよりもオーバーヘッドが低い。

00:34:36.000 --> 00:34:43.000
これは、画面の一部をキャプチャすると、コンテンツの制作に使用できるリソースが増えることを意味します。

00:34:43.000 --> 00:34:46.000
デモに飛び込んで、私たちが実際に議論してきたことを見てみましょう。

00:34:46.000 --> 00:34:51.000
左側には、OBSのウィンドウキャプチャの最悪の例があります。

00:34:51.000 --> 00:34:56.000
このキャプチャはCGWindowListCreateImage APIを使用しており、大きな吃音があります。

00:34:56.000 --> 00:35:01.000
私たちのテストでは、フレームレートが7fpsまで低下するのを見ました。

00:35:01.000 --> 00:35:09.000
一方、右側のScreenCaptureKitの実装は、はるかにスムーズな結果をもたらし、大幅に滑らかな動きで出力ビデオを提供します。

00:35:09.000 --> 00:35:13.000
この場合、60fpsを提供します。

00:35:13.000 --> 00:35:19.000
OBSはウィンドウキャプチャよりも最大15%少ないRAMを使用します。

00:35:19.000 --> 00:35:28.000
また、OBSのウィンドウキャプチャの代わりにScreenCaptureKitを使用すると、OBSのCPU使用率が最大半分に削減されます。

00:35:28.000 --> 00:35:33.000
ScreenCaptureKitがOBSユーザーに提供しなければならないその他の改善点を見てみましょう。

00:35:33.000 --> 00:35:37.000
私はまだサヨナラワイルドハーツのすべてのゴールドランクを追跡しようとしています。

00:35:37.000 --> 00:35:40.000
最高の走りを見せびらかしたいので、ゲームプレイを録画しています。

00:35:40.000 --> 00:35:50.000
ScreenCaptureKitのおかげで、ゲームから直接オーディオストリームをキャプチャできるようになったので、Macで通知を受け取ったときに、録画のオーディオやビデオが台無しになることはありません。

00:35:50.000 --> 00:35:54.000
そして、これは追加のオーディオルーティングソフトウェアをインストールしなくても可能です。

00:35:54.000 --> 00:35:56.000
♪

00:35:56.000 --> 00:36:06.000
現在、AppleシリコンでScreenCaptureKitが提供するすべての機能強化を使用して、Taiko no Tatsujin Pop Tap BeatのようなゲームをMacから人気のあるストリーミングサービスにストリーミングできます。

00:36:06.000 --> 00:36:17.000
Appleシリコンのハードウェアエンコーダの新しい定数ビットレートオプションは、ゲームのパフォーマンスに大きな影響を与えることなく、一定のビットレートを必要とするサービスのためにストリーミングコンテンツをエンコードできることを意味します。

00:36:17.000 --> 00:36:24.000
現在、ScreenCaptureKitのリソース使用量の削減とエンコーディングのオフロードのおかげで、重要なコンテンツでさらに多くのパフォーマンスを利用できます。

00:36:24.000 --> 00:36:25.000
あなたに戻って、メン。

00:36:25.000 --> 00:36:28.000
メン:ありがとう、ドリュー。

00:36:28.000 --> 00:36:34.000
デモと例を通して、高度な画面コンテンツフィルターについて学びました。

00:36:34.000 --> 00:36:38.000
さまざまなユースケースのためにストリームを設定するいくつかの方法。

00:36:38.000 --> 00:36:44.000
そして、フレームごとのメタデータを使用し、キャプチャされたコンテンツを正しく表示する方法。

00:36:44.000 --> 00:36:49.000
最高のパフォーマンスを達成するのに役立ついくつかのベストプラクティス。

00:36:49.000 --> 00:36:59.000
そして最後に、ドリューはScreenCaptureKitがOBSにもたらした重要な機能とパフォーマンスの向上を紹介しました。

00:36:59.000 --> 00:37:09.000
ScreenCaptureKitを使用して、アプリの画面共有、ストリーミング、コラボレーション体験をどのように再定義するかを見るのが待ちきれません。

00:37:09.000 --> 00:37:11.000
見てくれてありがとう!

00:37:11.000 --> 23:59:59.000
♪

