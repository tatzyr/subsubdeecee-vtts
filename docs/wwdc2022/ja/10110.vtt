WEBVTT

00:00:09.000 -> 00:00:12.000
アンドレアス:こんにちは、WWDCへようこそ。

00:00:12.000 -> 00:00:20.000
私はAppleのローカリゼーションチームのAndreasです。今日は、高品質でローカライズされたアプリを構築する方法に関するいくつかの例を共有したいと思います。

00:00:20.000 -> 00:00:26.000
国際化とは、世界中のデバイスで実行するためにアプリを準備することを意味します。

00:00:26.000 -> 00:00:33.000
ローカリゼーションがうまくいくと、話す言語に関係なく、誰もが同じ素晴らしい経験と実用性を楽しむことができます。

00:00:33.000 -> 00:00:41.000
Appleが提供するAPIを使用して、アプリのほとんどの部分は箱から出してすぐに国際化に優しいです。

00:00:41.000 -> 00:00:49.000
この講演では、いくつかの課題やそれらをどのように解決したかなど、Appleのアプリを多様な視聴者にアピールする私たちの経験から学びます。

00:00:49.000 -> 00:00:53.000
ローカライズされたテキストの宣言と読み込みから始めます。

00:00:53.000 -> 00:00:57.000
フォーマットされた日付、時刻などを文字列に含めるのは簡単です。

00:00:57.000 -> 00:01:02.000
いくつかのオプションを強調し、洗練された例を見ていきます。

00:01:02.000 -> 00:01:10.000
Swiftパッケージにはローカライズされたテキストも含まれる可能性があり、ローカリゼーションワークフローの改善について学びます。

00:01:10.000 -> 00:01:14.000
最後に、SwiftUIのレイアウトと素晴らしい新しい追加について話します。

00:01:14.000 -> 00:01:20.000
Appleでは、アプリが国際的な視聴者に素晴らしい体験を提供していることを確認しています。

00:01:20.000 -> 00:01:22.000
そして、天気アプリはその一例です。

00:01:22.000 -> 00:01:30.000
何百万人ものユーザーが毎日それを開いて予測を確認し、これは彼らが世界のどこにいても彼らにとってアプリがどのように見えるかです。

00:01:30.000 -> 00:01:34.000
UIのすべてが好みに合わせて調整されていることに注目してください。

00:01:34.000 -> 00:01:39.000
現在の気象条件の説明をローカライズし、数字をフォーマットします。

00:01:39.000 -> 00:01:45.000
UIは、言語が左から右か右から左かに応じて適切に調整されます。

00:01:45.000 -> 00:01:50.000
翻訳から始めてカスタマイズするものの1つを詳しく見てみましょう。

00:01:50.000 -> 00:01:54.000
この景色には、英語で「風が涼しく感じさせている」と書かれています。

00:01:54.000 -> 00:01:57.000
そして、これは他の言語でどのように見えるかです。

00:01:57.000 -> 00:02:02.000
それらを適切にサポートするには、String(localized)を使用して文字列を宣言するだけです。

00:02:02.000 -> 00:02:09.000
Xcodeはローカリゼーションのためにエクスポートするときにそれを検出し、翻訳者に結果を送信できます。

00:02:09.000 -> 00:02:11.000
そうするためにMacのメールアプリを使います。

00:02:11.000 -> 00:02:13.000
そして、私たちがそこにいる間、私はあなたに何かを見せたいです。

00:02:13.000 -> 00:02:22.000
メールのコンテキストメニューを開くと、「アーカイブ」という特別なフォルダに移動できます。それは私のサイドバーにあります。

00:02:22.000 -> 00:02:25.000
両方の単語が英語で「アーカイブ」であることに注目してください。

00:02:25.000 -> 00:02:31.000
ただし、スペイン語のような他の言語では、アクションとフォルダ名の単語が異なります。

00:02:31.000 -> 00:02:37.000
英語の単語は同じですが、異なる文脈で表示される場合、他の言語は異なる単語を使用する可能性があります。

00:02:37.000 -> 00:02:40.000
この場合、コードに2つの文字列を使用する必要があります。

00:02:40.000 -> 00:02:45.000
これを行うには、今年、文字列初期化子に新しいAPIを追加しました。

00:02:45.000 -> 00:02:50.000
これで、英語の文字列に使用できるデフォルト値が使用されます。

00:02:50.000 -> 00:02:55.000
次に、ローカライズされた文字列のキーを変更して、翻訳者に区別を明確にします。

00:02:55.000 -> 00:03:02.000
このようにして、英語でアプリを実行するときに同じ単語が表示され、スペイン語の翻訳者は異なる単語を提供することができます。

00:03:02.000 -> 00:03:11.000
昨年の講演「ローカライズされた文字列を合理化する」は、文字列管理の基本を理解するのに役立ち、ローカリゼーションプロセスをさらに進めます。

00:03:11.000 -> 00:03:20.000
この例から、同じ英語の単語、または文全体がUIの異なるコンテキストで表示されることがあります。

00:03:20.000 -> 00:03:25.000
このような場合は、コードで2つの異なる文字列を使用するようにしてください。

00:03:25.000 -> 00:03:27.000
天気はアプリだけではありません。

00:03:27.000 -> 00:03:30.000
また、システムにうまく統合されています。

00:03:30.000 -> 00:03:36.000
ここでは、ユーザーのアクティビティが表示され、アプリを開いて現在の場所の天気を確認することを提案します。

00:03:36.000 -> 00:03:39.000
それがどのように実装されるかを見てみましょう。 

00:03:39.000 -> 00:03:45.000
文字列は、任意の場所名を挿入するために文字列補間を使用して、このように宣言して読み込むことができます。

00:03:45.000 -> 00:03:50.000
そして、この名前は都市または現在の場所の用語である可能性があります。

00:03:50.000 -> 00:03:57.000
結果は英語でうまく機能します:それぞれ「クパチーノの天気を表示」と「私の場所で天気を表示」。

00:03:57.000 -> 00:04:00.000
しかし、他の言語では、文法的な問題に遭遇するかもしれません。

00:04:00.000 -> 00:04:07.000
たとえば、ドイツ語では、前置詞は都市名に対して機能しますが、現在の場所の用語を挿入するときは間違っています。

00:04:07.000 -> 00:04:10.000
代わりに別の翻訳が必要です。

00:04:10.000 -> 00:04:15.000
ここでの解決策は簡単です。2つの異なる文字列を使用するだけです。

00:04:15.000 -> 00:04:21.000
都市名を挿入することは最初の都市で問題ありませんが、現在の場所には別の文字列を使用します。

00:04:21.000 -> 00:04:25.000
これにより、翻訳者は自分の言語に正しい文法を使用できるようになります。

00:04:25.000 -> 00:04:28.000
そして、それは英語とドイツ語でうまく機能します。

00:04:28.000 -> 00:04:34.000
変数を挿入することが文全体に影響を与えることを示すために、この例を作りました。

00:04:34.000 -> 00:04:46.000
文字列の結合は、他の言語で驚くべき結果をもたらす可能性があります。文法を反転させる必要があるか、大文字化に問題があるかもしれませんが、コードを書くときに事前にそれを知ることは困難です。

00:04:46.000 -> 00:04:51.000
言語を話す人にアプリをテストしてもらうことは、ワークフローのかなりの部分です。

00:04:51.000 -> 00:04:57.000
文字列をプログラムで構築したくなるときは、それを覚えておいてください。

00:04:57.000 -> 00:05:03.000
コードで文字列がどのように宣言されているかについてよく理解したので、彼らのコメントについて話しましょう。

00:05:03.000 -> 00:05:07.000
これは、前回の例の文字列で、適切なコメントがあります。

00:05:07.000 -> 00:05:10.000
コメントは翻訳者にとって本当に、本当に重要です。

00:05:10.000 -> 00:05:17.000
文字列を宣言するときと同じ意図を保ちながら、翻訳に必要なコンテキストを必ず与える必要があります。

00:05:17.000 -> 00:05:23.000
素晴らしいコメントは、ラベルやボタンなど、文字列がどのインターフェイス要素に表示されているかを説明しています。

00:05:23.000 -> 00:05:28.000
また、UI要素のコンテキストと、それが画面に表示される場所についても説明しています。

00:05:28.000 -> 00:05:33.000
これは、セクションヘッダー、コンテキストメニュー、またはユーザーアクティビティである可能性があります。

00:05:33.000 -> 00:05:37.000
文字列に変数が含まれている場合は、実行時にその値を必ず説明してください。

00:05:37.000 -> 00:05:42.000
これは、例で見たように、文の文法を一致させるために非常に重要です。

00:05:42.000 -> 00:05:47.000
翻訳者は、コンテンツを翻訳するときに実行時にアプリが表示されない可能性があることを覚えておいてください。

00:05:47.000 -> 00:05:56.000
しかし、これらのヒントを使用すると、文字列の宣言と翻訳、およびそれがアプリで果たす役割の間に共通の理解を作成できるはずです。

00:05:56.000 -> 00:06:00.000
さて、あなたには思いつかなかったかもしれませんが、天気アプリは実際には天気をコントロールしていません。

00:06:00.000 -> 00:06:03.000
代わりに、データはサーバーからダウンロードされます。

00:06:03.000 -> 00:06:09.000
それは世界のどこにでも配置することができ、コンテンツを送信する言語さえ知らないかもしれません。

00:06:09.000 -> 00:06:15.000
コンテンツがユーザーのデバイスにダウンロードされるときは、常にユーザーが好む言語で表示する必要があります。

00:06:15.000 -> 00:06:20.000
アプリの一部だけをローカライズすると、非常に混乱する可能性があります。

00:06:20.000 -> 00:06:26.000
ここでは、天気アプリには、サーバーから読み込まれた厳しい気象警報が表示されます。

00:06:26.000 -> 00:06:32.000
これは本当に深刻に見え、私の言語に翻訳されなければ、後でトラブルに巻き込まれるかもしれません。

00:06:32.000 -> 00:06:38.000
ユーザーが常にリモートコンテンツを読むことができるようにするために何ができるかを見てみましょう。 ユーザーがリモートコンテンツを読むことができるようにするために何ができるかを見てみましょう。

00:06:38.000 -> 00:06:42.000
サーバーは、サポートされている言語のリストをアプリに送信できます。

00:06:42.000 -> 00:06:51.000
これは言語IDの配列でなければならず、デバイスはユーザーが好む言語に関するすべての知識を持っているので、自分で比較をチェックする必要はありません。

00:06:51.000 -> 00:06:55.000
「Bundle.preferredLocalizations」を呼び出すことで、Appleのフレームワークを活用できます。

00:06:55.000 -> 00:06:57.000
そして、これはあなたのためにマッチを行います。

00:06:57.000 -> 00:07:03.000
ユーザーの言語選択とどの程度一致するかでソートされた候補言語の配列を返します。

00:07:03.000 -> 00:07:08.000
そして、最初のものは通常最も適しているので、あなたはこれを使用します。

00:07:08.000 -> 00:07:13.000
その言語は、サーバーへの後続の要求に使用する必要があります。

00:07:13.000 -> 00:07:19.000
それを使用して、ユーザーが理解できる言語のコンテンツで応答を生成します。

00:07:19.000 -> 00:07:27.000
このテクニックを使用すると、サーバーからの文字列がUIを更新し、ユーザーにアラートを表示する準備ができていることを確信できます。

00:07:27.000 -> 00:07:40.000
したがって、リモートコンテンツを表示する際の欲求不満の嵐からユーザーを救うために、利用可能な言語をダウンロードし、それをユーザーの好みと照合し、ユーザー向けコンテンツをロードするリクエストに結果を使用します。

00:07:40.000 -> 00:07:42.000
でも、今はもっといい天気に戻りましょう。

00:07:42.000 -> 00:07:48.000
雨でも晴れでも、天気アプリはデータが非常に豊富で、その多くの側面に数字とカウントが含まれています。

00:07:48.000 -> 00:07:51.000
そのうちの1つに集中しましょう。

00:07:51.000 -> 00:08:01.000
「降水量」の下には「過去6時間で0mm」と書かれています。似たようなものを作りたいが、ここでは「1時間」と綴りたいと仮定しましょう。

00:08:01.000 -> 00:08:04.000
これは、コードで文字列を宣言する方法です。

00:08:04.000 -> 00:08:11.000
英語では、時間数が1時間より大きい場合は、複数形を使用する必要があります：1時間、ただし2時間。

00:08:11.000 -> 00:08:16.000
別のバリアントを使用するときのルールは、ウクライナ語ではさらに複雑です。

00:08:16.000 -> 00:08:22.000
そのロジックをコードに実装したくないので、これがAppleのフレームワークを活用する理由です。

00:08:22.000 -> 00:08:29.000
あなたがしなければならないのは、コードで文字列を宣言し、複数のルールをエンコードするstringsdictファイルを提供することだけです。

00:08:29.000 -> 00:08:33.000
もう1つの選択肢は、自動文法契約を利用することです。

00:08:33.000 -> 00:08:45.000
昨年の講演「ローカライズされた文字列を合理化する」では、これら2つのテクニックについて詳しく知ることができます。簡単ですが、すべての文字列に常に複数のルールを適用するべきではありません。

00:08:45.000 -> 00:08:52.000
たとえば、文に何もカウントされず、数字が含まれていない場合は、複数形のルールを使用しないでください。

00:08:52.000 -> 00:09:00.000
ここでは、「この都市をお気に入りから削除する」は番号がないため、1つを必要とせず、同じことが複数の都市にも当てはまります。

00:09:00.000 -> 00:09:05.000
しかし、文字列に数字が含まれている場合は、複数形のバリエーションを検討する必要があります。

00:09:05.000 -> 00:09:14.000
前の例の文字列は、次の数時間でどれだけの雨が降るかを数え、1より大きい数字に適応させるのがいかに簡単かを学びました。

00:09:14.000 -> 00:09:21.000
ただし、文に期間、時間、パーセンテージなどの単位がある場合は、フォーマッタの使用を検討する必要があります。

00:09:21.000 -> 00:09:24.000
では、フォーマッタについて話しましょう。

00:09:24.000 -> 00:09:28.000
天気は、このビューで現在の湿度をパーセントで表示します。

00:09:28.000 -> 00:09:32.000
SwiftUIでこれを行うには、たった1行のコードの問題です。

00:09:32.000 -> 00:09:37.000
値を Text() でラップし、番号のフォーマット方法を指定するだけです。

00:09:37.000 -> 00:09:39.000
そして、同等のSwiftコードも簡単です。

00:09:39.000 -> 00:09:43.000
あなたはあなたの価値で.formattedを呼び出すだけです。

00:09:43.000 -> 00:09:48.000
それは本当にあなたがする必要があるすべてであり、フォーマッタは他のすべての世話をします。

00:09:48.000 -> 00:10:00.000
数字の前または後にパーセント記号を配置し、スペースを追加するだけでなく、ユーザーの好みのナンバリングシステムにも対応し、アラビア語とヒンディー語のユーザーが期待するものです。

00:10:00.000 -> 00:10:05.000
しかし、それは本当にあなたがフォーマットできるデータの種類の始まりにすぎません。

00:10:05.000 -> 00:10:19.000
ほとんどすべてのフォーマッタがあり、「フォーマッタ：データを人間に優しいものにする」というセッションを要約することをお勧めします。これまで見てきたように、天気はいつも晴れているわけではないし、雨が降る日もあるだろう。

00:10:19.000 -> 00:10:23.000
もちろん、このハイライトは天気アプリで見逃せません。

00:10:23.000 -> 00:10:32.000
「Rainfall」の下には、「今後24時間で50mmが予想される」と書かれていて、私が今いる場所がそれほど多くないことを本当にうれしく思います。

00:10:32.000 -> 00:10:34.000
英語では、ケースは単純です。

00:10:34.000 -> 00:10:41.000
私たちは「次の24時間で50ミリメートルが予想される」と言います。しかし、スペイン語では、この問題はより複雑です。

00:10:41.000 -> 00:10:47.000
降水量が単数形または複数形の場合、翻訳を変える必要があります。

00:10:47.000 -> 00:10:51.000
フォーマッタと複数ルールの両方を組み合わせることで、これを解決できます。

00:10:51.000 -> 00:10:59.000
文字列「2 mm」はフォーマッタによって生成され、スペイン語で複数形に変化させる必要がある文に埋め込まれています。

00:10:59.000 -> 00:11:03.000
さて、コードでこれを行う方法を見てみましょう。 

00:11:03.000 -> 00:11:10.000
降水量がミリメートル単位になるというパラメータを取る関数を宣言することから始めます。

00:11:10.000 -> 00:11:13.000
おそらくそれはサーバーからダウンロードされました。

00:11:13.000 -> 00:11:23.000
まず、ユーザーの構成をエンコードするUnitLengthをシステムに要求し、降雨量を示す場合に適したものを選択します。

00:11:23.000 -> 00:11:31.000
ユーザーがメトリクスを使用するようにシステムを設定していない場合は、測定タイプを優先ユニットに簡単に変換できます。

00:11:31.000 -> 00:11:38.000
次に、書式設定APIを使用すると、1行のコードで値のフォーマットされた文字列を生成できます。

00:11:38.000 -> 00:11:42.000
preferredUnitには、降雨量を表示したい情報がすでにあります。

00:11:42.000 -> 00:11:45.000
したがって、フォーマットするときは、使用法をasProvidedに設定します。

00:11:45.000 -> 00:11:51.000
1ミリメートルまたはインチ以上の雨が降る場合は、複数形のケースを使用します。

00:11:51.000 -> 00:11:55.000
それを確認できるように、値を整数に変換します。

00:11:55.000 -> 00:12:01.000
次に、指定されたキーでローカライズされた文字列をロードし、デフォルト値も提供します。

00:12:01.000 -> 00:12:07.000
そこでは、文字列補間を使用して、integerValue、formattedValue、および数値24を含めます。

00:12:07.000 -> 00:12:11.000
数字は常に24時間であるため、ここのコードで定義されています。

00:12:11.000 -> 00:12:17.000
文字列補間を使用すると、自動的に正しいナンベリングシステムが使用されていることを確認します。

00:12:17.000 -> 00:12:19.000
キーはstringsdictファイルで宣言されています。

00:12:19.000 -> 00:12:22.000
それを見てみましょう。それを見てみましょう。

00:12:22.000 -> 00:12:26.000
Stringsdictは、コードで使用したばかりのキーから始まります。

00:12:26.000 -> 00:12:33.000
英語では、複数形の文字列を変更する必要がないため、「その他」のカテゴリを使用します。

00:12:33.000 -> 00:12:36.000
最初のパラメータは、実行時にどのカテゴリが選択されるかを定義します。

00:12:36.000 -> 00:12:39.000
覚えておいてください、それは整数値でした。

00:12:39.000 -> 00:12:43.000
パラメータ番号2と3は、フォーマットされた文字列に存在します。

00:12:43.000 -> 00:12:47.000
これは、実行時に文がどのように見えるかを定義します。

00:12:47.000 -> 00:12:56.000
スペイン語のstringsdictは、単数形と複数形の両方で翻訳を提供することを除いて、同じ構造を持っています。

00:12:56.000 -> 00:13:00.000
これで、データをコードでフォーマットし、文に配置しました。

00:13:00.000 -> 00:13:05.000
Stringsdictファイルには複数ルールが含まれているため、スペイン語の翻訳は正しい文法を使用しています。

00:13:05.000 -> 00:13:11.000
時には、すべての言語でうまく機能する完全にローカライズされたUIを提供することが困難です。

00:13:11.000 -> 00:13:18.000
繰り返しになりますが、文字列の結合は英語で機能しますが、他の言語では驚くべき結果をもたらす可能性があることを学びました。

00:13:18.000 -> 00:13:24.000
これにはいくつかの包括的なコードが必要になるかもしれませんが、今、あなたはすべてのユーザーのためにそれを正しくする方法を知っています。

00:13:24.000 -> 00:13:31.000
時々、あなたの文字列は依存関係、またはあなたのアプリが使用するモジュールにあります。

00:13:31.000 -> 00:13:36.000
または、Swiftパッケージを使用して、他の開発者にも独自のコードを配布することもできます。

00:13:36.000 -> 00:13:39.000
ローカリゼーションの新機能を見てみましょう。 

00:13:39.000 -> 00:13:45.000
Swiftパッケージを定義するには、Swift自体を使用して構造とビルド設定を宣言します。

00:13:45.000 -> 00:13:53.000
ユーザー向けコンテンツがある場合は、パラメータdefaultLocalizationを使用して、コンテンツが主要言語として英語を使用していることを宣言できます。

00:13:53.000 -> 00:13:58.000
これは、アプリプロジェクトの開発言語を指定するのと似ています。

00:13:58.000 -> 00:14:05.000
Xcodeは、そのパラメータを読み取り、ローカライズされたエクスペリエンスを提供することに興味があることを認識します。

00:14:05.000 -> 00:14:10.000
そのため、製品メニューにローカリゼーションをエクスポートするオプションが追加されます。

00:14:10.000 -> 00:14:16.000
あなたはおそらくメインアプリでこの機能を使用することに慣れていて、今ではSwiftパッケージでも機能します。

00:14:16.000 -> 00:14:21.000
「エクスポート」をクリックすると、Xcodeはコードを読み取り、すべての文字列を抽出します。

00:14:21.000 -> 00:14:25.000
それらは.xclocファイルに配置され、翻訳者に送信されます。

00:14:25.000 -> 00:14:34.000
また、ローカライズされたコンテンツをパッケージにインポートするには、Import Localizationsを使用すると、Xcodeはパッケージ内の正しいファイルパスにファイルを配置します。

00:14:34.000 -> 00:14:41.000
Swiftパッケージをローカライズするワークフローは、アプリをローカライズするのと同じです。

00:14:41.000 -> 00:14:47.000
しかし、Swiftパッケージに文字列を読み込むには、「バンドル」引数を指定する必要があることを覚えておいてください。

00:14:47.000 -> 00:15:05.000
講演「Swiftパッケージ：リソースとローカリゼーション」で詳しく知ることができます。Swiftパッケージとして配布されているライブラリの作者であれば、プロジェクトを最新の状態に保ち、ローカリゼーションをワークフローの定期的な一部にする簡単な方法があります。

00:15:05.000 -> 00:15:12.000
あなたはプロジェクトに多大な労力と注意を払い、それをローカライズすることは、すべてのクライアントにとって大きな時間の節約になります。

00:15:12.000 -> 00:15:14.000
それは本当にそれを際立たせることができます。

00:15:14.000 -> 00:15:21.000
あなたのソフトウェアで最高の体験を提供するために余分な努力をしていることを人々に認識させるので、先に進んで彼らに伝えてください!

00:15:21.000 -> 00:15:25.000
箱から出してすぐにサポートする言語についてオープンにしてください。

00:15:25.000 -> 00:15:32.000
アプリ開発者として、コード品質の観点からだけでなく、依存関係に特別な配慮を払います。

00:15:32.000 -> 00:15:39.000
使用するコンポーネントは、アプリの残りの部分と同じ言語と高品質の翻訳をサポートする必要があります。

00:15:39.000 -> 00:15:48.000
サードパーティのコードが必要な言語にローカライズされていない場合でも、パッケージのローカルコピーを作成し、そこでローカリゼーションを更新することができます。

00:15:48.000 -> 00:15:53.000
アプリのすべての部分を、サポートされている言語でテストしてください。

00:15:53.000 -> 00:15:58.000
このようにして、ユーザーの言語に適応していないUI要素がないことを確認できます。

00:15:58.000 -> 00:16:06.000
ほとんどの場合、翻訳された文字列は英語の同等のものよりも長くまたは短く、それは常にアプリのレイアウトに影響します。

00:16:06.000 -> 00:16:08.000
これが天気アプリにとって何を意味するのか見てみましょう。

00:16:08.000 -> 00:16:14.000
これは英語で実行されているアプリで、右側にはアラビア語で実行されているのが見えます。

00:16:14.000 -> 00:16:22.000
翻訳が言語に適応しているだけでなく、レイアウトも適切な方向性に従っていることは明らかです。

00:16:22.000 -> 00:16:40.000
すべての言語で動作するレイアウトを作成する方法、どのタイプのシンボルがローカライズされた代替手段を提供するか、右から左の言語について他に考慮すべきことについてもっと知りたい場合は、「正しく...左に」というトークを必ず見てください。ここでは、アプリは右側のヒンディー語で実行されています。

00:16:40.000 -> 00:16:42.000
ズームインしましょう。

00:16:42.000 -> 00:16:45.000
その言語のスクリプトは一般的に背が高い傾向があります。

00:16:45.000 -> 00:16:50.000
そして、よく見ると、ラベルの高さがそれに合わせて調整されていることがわかります。

00:16:50.000 -> 00:16:52.000
システムはこれを自動的に行います。

00:16:52.000 -> 00:16:57.000
あなたがしなければならないのは、UI要素に固定された高さを与えないようにすることだけです。

00:16:57.000 -> 00:17:03.000
英語の弦に合うのに十分な高さだからといって、すべてが44ポイント以内に収まると仮定しないでください。

00:17:03.000 -> 00:17:09.000
状況に応じて、常にテキストが高くなることを期待してください。

00:17:09.000 -> 00:17:17.000
メインビューに戻って上にスクロールすると、天気には10日間の予報ビューがあり、来週のチェックアウトに最適です。

00:17:17.000 -> 00:17:24.000
この画面で際立っているのは、最も長いラベルに従って要素の位置を動的に調整する方法です。

00:17:24.000 -> 00:17:28.000
英語では、「今日」はすべての短縮された平日の名前よりも長いです。

00:17:28.000 -> 00:17:36.000
しかし、スペイン語では、それらはすべて3文字の幅で、ギリシャ語では「今日」の翻訳はほぼ2倍の大きさです。

00:17:36.000 -> 00:17:40.000
しかし、すべての言語で、天気のアイコンは互いに垂直に並んでいます。

00:17:40.000 -> 00:17:47.000
つまり、彼らは隣人の要素に固定された間隔を持っていませんが、最も長い平日のラベルに従って流れます。

00:17:47.000 -> 00:17:55.000
国際化でうまく機能するレイアウトを作成することに関しては、ラベルが柔軟である必要があることを常に心に留めておく必要があります。

00:17:55.000 -> 00:18:03.000
垂直方向に柔軟にすることがいかに重要であるかを見たばかりですが、より長い翻訳でラベルが水平に成長することを期待しています。

00:18:03.000 -> 00:18:15.000
この例のように、特定のレイアウトでそれに対応するのは難しいかもしれませんが、今年、SwiftUIは、この種のレイアウトをより簡単に構築するのに役立つ新しいビューであるグリッドのサポートを追加します。

00:18:15.000 -> 00:18:19.000
グリッドの使い方を詳しく見てみましょう。

00:18:19.000 -> 00:18:22.000
先頭のアライメントでグリッドを宣言することから始めます。

00:18:22.000 -> 00:18:31.000
つまり、UI要素は画面の左側で左から右に、画面の右側で右から左の言語で始まります。

00:18:31.000 -> 00:18:35.000
次に、水平グループごとにGridRowを追加します。

00:18:35.000 -> 00:18:38.000
そして最後に、行の内容を宣言します。

00:18:38.000 -> 00:18:41.000
このかなり高度なレイアウトを作成するために必要なのはそれだけです。

00:18:41.000 -> 00:18:48.000
ラベルがより多くのスペースを必要とする場合、カプセルは最も柔軟な要素であるため、サイズを縮小することができます。

00:18:48.000 -> 00:18:55.000
SwiftUIは、ビューの測定、サイジング、位置決めなど、すべての重い作業を行います。

00:18:55.000 -> 00:19:02.000
もう1つの課題は、Apple Watchのように、限られたスペースでより長い翻訳作業でビューを作ることです。

00:19:02.000 -> 00:19:07.000
ここでは、「チップ機能」のドイツ語翻訳が長すぎて一列に収まりません。

00:19:07.000 -> 00:19:11.000
これを修正するために、より多くのスペースを作るためにテキストの横にあるアイコンを削除しません。

00:19:11.000 -> 00:19:17.000
解決策は、必要に応じて2行以上のテキストを使用することです。これはデフォルトの動作です。

00:19:17.000 -> 00:19:22.000
十分なスペースがない場合は、それを変更してインターフェイス要素を隠すことはお勧めしません。

00:19:22.000 -> 00:19:28.000
通常、言語のニーズに対応できるように、レイアウトを調整する方法があります。

00:19:28.000 -> 00:19:32.000
メールアプリは創造的な方法でこれを行います。

00:19:32.000 -> 00:19:37.000
シートプレゼンテーションには、このメールに対してアクションを実行するための4つのボタンがあります。

00:19:37.000 -> 00:19:43.000
ボタンのタイトルの1つの翻訳が長すぎる場合、テキストをクリップしたり、新しい行にラップしたりしません。

00:19:43.000 -> 00:19:45.000
これにより、ビューが不均衡に見えるようになります。

00:19:45.000 -> 00:19:53.000
代わりに、レイアウト全体が水平スタックから2行の垂直スタックに移行します。

00:19:53.000 -> 00:20:00.000
今年、SwiftUIは、この動的レイアウトを簡単に作成する別の素晴らしいツールを追加します。ViewThatFits。

00:20:00.000 -> 00:20:07.000
本質的には、スペースが制約され、ビューが収まらない場合に、代替レイアウトを提供できます。

00:20:07.000 -> 00:20:13.000
互いに独立して意見を宣言し、ViewThatFitsに配置するだけです。

00:20:13.000 -> 00:20:19.000
SwiftUIは、クリッピングなしでビューが収まらないかどうかを自動的に検出し、提供された次のビューに移行します。

00:20:19.000 -> 00:20:22.000
レイアウトのみを切り替える必要があることを覚えておいてください。

00:20:22.000 -> 00:20:26.000
翻訳が長すぎるという理由だけでビューを隠すのは悪い習慣です。

00:20:26.000 -> 00:20:30.000
これにより、ユーザーがUIで自分自身を方向づけるのが難しくなります。

00:20:30.000 -> 00:20:36.000
柔軟なレイアウトを持つことで、まずすべてのインターフェイス要素のためのスペースを作るようにしてください。

00:20:36.000 -> 00:20:38.000
これはローカリゼーションに役立つだけではありません。

00:20:38.000 -> 00:20:45.000
このレイアウトは、ユーザーがテキストを小さくまたは大きくすることを好み、異なるデバイスを使用する場合にも最適です。

00:20:45.000 -> 00:20:59.000
今年のSwiftUIの素晴らしい新しいレイアウト機能の詳細については、「SwiftUIでカスタムレイアウトを作成する」というトークを見ることをお勧めします。異なるアクセシビリティ設定とローカライズされたテキストを持つことは、レイアウトにとって課題になる可能性があります。

00:20:59.000 -> 00:21:02.000
インターフェース要素は、より高く、より広くすることができます。

00:21:02.000 -> 00:21:09.000
それに対応するためにレイアウトを適応させるのは難しいかもしれませんが、SwiftUIを使用すると、今年ははるかに簡単になります。

00:21:09.000 -> 00:21:16.000
この話から、コードで文字列を構築することは、他の言語をサポートするときに難しいことを取り除いてほしい。

00:21:16.000 -> 00:21:23.000
国際的なユーザーやテスターからのフィードバックを聞いて、誰にとってもうまくいくことを確認してください。

00:21:23.000 -> 00:21:27.000
Swiftでの値の書式設定は簡単で、多くの場合、1行のコードが必要です。

00:21:27.000 -> 00:21:33.000
そうすることで、フォーマットされた値はユーザーの好みを自動的に尊重します。

00:21:33.000 -> 00:21:42.000
Swiftパッケージを提供するときは、新しいXcodeローカリゼーションワークフローを使用して、クライアントに完全にローカライズされたエクスペリエンスを提供します。

00:21:42.000 -> 00:21:49.000
これで、SwiftUIの有無にかかわらず、レイアウトは翻訳されたテキストとアクセシビリティの設定に対応できるはずです。

00:21:49.000 -> 00:21:55.000
レイアウトツールを使用して、インターフェイス要素を隠すことなく、レイアウトを柔軟にします。

00:21:55.000 -> 00:22:03.000
最終的には、あなたのアプリは彼らの生活に適合することを期待し、それは彼らの言語を尊重することを含むので、あなたのユーザーはそれに感謝するでしょう。

00:22:03.000 -> 00:22:06.000
今、私はとても晴れた週を楽しみにしています。

00:22:06.000 -> 23:59:59.000
WWDCの残りの部分を楽しんで、見てくれてありがとう。

