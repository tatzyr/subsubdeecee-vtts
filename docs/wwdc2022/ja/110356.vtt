WEBVTT

00:00:00.000 -> 00:00:03.000
♪インストゥルメンタルヒップホップ音楽♪

00:00:03.000 -> 00:00:09.000
♪

00:00:09.000 -> 00:00:13.000
こんにちは！私の名前はコンラッドで、スウィフトチームのエンジニアです。

00:00:13.000 -> 00:00:15.000
「スウィフトで配布された俳優に会う」へようこそ。

00:00:15.000 -> 00:00:21.000
このセッションでは、Swiftの並行性ベースのアプリを単一のプロセスを超えて進める方法を学びます。

00:00:21.000 -> 00:00:26.000
スウィフトアクターは、同じプロセスで低レベルのデータレースからあなたを守るために設計されました。

00:00:26.000 -> 00:00:30.000
彼らはコンパイル時にアクターの分離チェックを強制することによってこれを行います。

00:00:30.000 -> 00:00:39.000
分散アクターは、同じ概念アクターモデルを洗練し、クラスター内の複数のデバイスやサーバーなど、複数のプロセスに拡張します。

00:00:39.000 -> 00:00:49.000
したがって、まだスウィフトの俳優に精通していない場合に備えて、まずWWDC 2021の「スウィフト俳優で可変状態を保護する」セッションを見ることをお勧めします。

00:00:49.000 -> 00:00:56.000
このセッションで取り組むアプリは、私が最近開発しているチックタックトースタイルのゲームです:チックタックフィッシュ!

00:00:56.000 -> 00:01:05.000
ここでの楽しいアイデアは、あなたがプレイしているチームを選択できることです。これは、ゲームをプレイする際に動きをマークするために使用される絵文字に対応します。

00:01:05.000 -> 00:01:12.000
その後、フィールドで動きをマークすると、プレイヤーの1人が勝つまで、チームの絵文字がフィールドに配置されます。

00:01:12.000 -> 00:01:23.000
現在、私はボットの対戦相手と対戦できるオフラインモードのみを実装していますが、アプリを次のレベルに引き上げるためにいくつかのマルチプレイヤーモードを導入したいと思います。

00:01:23.000 -> 00:01:28.000
私はすでにこのアプリで俳優を使用して、並行性を管理し、ゲームに関与するプレイヤーをモデル化しています。

00:01:28.000 -> 00:01:37.000
これらのプレイヤーアクターをさまざまなプロセスに移行するために必要なことと、分散アクターがこれを行うのにどのように役立つかを見てみましょう。

00:01:37.000 -> 00:01:46.000
コードにジャンプする前に、一歩下がって、俳優が同時および分散アプリケーションの構築に適している理由を視覚化しましょう。

00:01:46.000 -> 00:01:52.000
WWDCセッションを通して、俳優について話すときに「並行性の海」という用語を使うのを聞くかもしれません。

00:01:52.000 -> 00:01:56.000
これは、彼らについて考える素晴らしいメンタルモデルだからです。

00:01:56.000 -> 00:02:05.000
各俳優は並行性の海にある独自の島であり、お互いの島に直接アクセスするのではなく、それらの間でメッセージを交換します。

00:02:05.000 -> 00:02:12.000
Swiftでは、これらのメッセージを島間で送信することは、非同期メソッド呼び出しとasync/awaitとして実装されます。

00:02:12.000 -> 00:02:23.000
これにより、アクターの状態分離と組み合わせることで、コンパイラは、アクターベースのプログラムがコンパイルされると、低レベルのデータレースから解放されることを保証することができます。

00:02:23.000 -> 00:02:30.000
それでは、この同じ概念モデルを取り、分散システムとして再考されたゲームに適用してみましょう。

00:02:30.000 -> 00:02:39.000
各デバイス、クラスター内のノード、またはオペレーティングシステムのプロセスを、独立した並行性の海であるかのように考えることができ、ここではより小さな暗い長方形としてマークされています。

00:02:39.000 -> 00:02:46.000
その中で、彼らはまだ同じメモリスペースを共有していたので、私たちはかなり簡単に情報を同期することができました。

00:02:46.000 -> 00:02:57.000
そして、メッセージパッシングの同じ概念は、並行性と配布のために完全にうまく機能しますが、それがすべて機能するためには、さらにいくつかの制限配布を実施する必要があります。

00:02:57.000 -> 00:03:00.000
これは、配布された俳優が絵に出てくる場所です。

00:03:00.000 -> 00:03:07.000
分散アクターを使用することで、2つのプロセス間のチャネルを確立し、それらの間でメッセージを送信することができます。

00:03:07.000 -> 00:03:17.000
言い換えれば、スウィフトのアクターが並行性の海の島である場合、分散アクターは分散システムの広大な海で同じです。

00:03:17.000 -> 00:03:27.000
プログラミングモデルから、実際にはあまり変わっていません - 俳優はまだ彼らの状態を分離し、まだ非同期メッセージを使用してのみ通信することができます。

00:03:27.000 -> 00:03:41.000
同じプロセスでより多くの分散アクターを持つことができ、すべての意図と目的のために、彼らは地元のアクターと同じくらい有用であり、必要に応じてリモートインタラクションに参加する準備ができているという違いがあります。

00:03:41.000 -> 00:03:51.000
このような分散アクターとのやり取り方法を変更することなく、潜在的に遠隔地になるこの機能は、「場所の透明性」と呼ばれます。

00:03:51.000 -> 00:03:57.000
これは、分散型アクターがどこにいるかに関係なく、同じように対話できることを意味します。

00:03:57.000 -> 00:04:10.000
これは、ローカルアクターで同じロジックを実行するため、テストにとって素晴らしいだけでなく、実装を変更することなく、アクターをどこにでも透過的に移動させることができます。

00:04:10.000 -> 00:04:15.000
さて、私たちはいくつかのコードを見て、最初の俳優を分散俳優に変換する準備ができていると思います。

00:04:15.000 -> 00:04:21.000
まず、一般的なゲームUIと、それが私のプレイヤー俳優とどのように相互作用するかを簡単に見てみましょう。

00:04:21.000 -> 00:04:28.000
ビューはかなり標準的なSwiftUIコードであり、ゲームフィールドを表すテキストとボタンの要素がいくつかあります。

00:04:28.000 -> 00:04:36.000
ユーザーがGameCellをクリックすると、プレイヤーアクターに移動を生成し、UIを強化するビューモデルを更新するよう依頼します。

00:04:36.000 -> 00:04:40.000
Swiftの並行性のおかげで、これらのアップデートはすべてスレッドセーフで行儀が良好です。

00:04:40.000 -> 00:04:45.000
現在、ユーザー入力を表すアクターはオフラインプレーヤーとして実装されています。

00:04:45.000 -> 00:04:47.000
次にそれを見てみましょう。 見ていきましょう。

00:04:47.000 -> 00:04:52.000
このアクターは、ゲームの動きを生成できる状態をカプセル化します。

00:04:52.000 -> 00:04:58.000
具体的には、すでに行った動きの数と、どのチームのためにプレーしているかを追跡する必要があります。

00:04:58.000 -> 00:05:05.000
各チームには、移動ごとに選択できる絵文字の数があるため、移動回数を使用して絵文字の文字IDを選択します。

00:05:05.000 -> 00:05:09.000
また、移動が作成されたら、モデルを更新する必要があります。

00:05:09.000 -> 00:05:13.000
モデルはMainActor単離クラスであるため、その突然変異はスレッドセーフです。

00:05:13.000 -> 00:05:17.000
ただし、userMadeMoveの呼び出しを行うときに「await」を使用する必要があります。

00:05:17.000 -> 00:05:24.000
最後に、オフラインプレーヤーは、対戦相手が動くたびに呼び出されるメソッドも宣言します。

00:05:24.000 -> 00:05:34.000
ここでする必要があるのは、ビューモデルを更新することだけです。これにより、ゲームフィールドが再びアクティブになり、人間のプレイヤーが動きを選択でき、ゲームが終了するまでサイクルが続きます。

00:05:34.000 -> 00:05:37.000
私たちのボットプレーヤーも俳優を使って表現されています。

00:05:37.000 -> 00:05:47.000
その実装は、ビューモデルの更新を心配する必要がないため、実際にはオフラインプレーヤーよりもかなり簡単です。GameStateを追跡し、ゲームの動きを生成するだけです。

00:05:47.000 -> 00:05:53.000
ボットプレーヤーは少しシンプルなので、分散アクターへの変換を開始するのは良いことだと思います。

00:05:53.000 -> 00:05:59.000
さて、私たちはいくつかのコードを見て、最初の俳優を分散俳優に変換する準備ができていると思います。

00:05:59.000 -> 00:06:07.000
分散型Tic Tac Fishゲームへの最初のステップは、BotPlayerタイプを分散アクターに変換し、ローカルでのみ使用することです。

00:06:07.000 -> 00:06:10.000
Xcodeを開いて、どうすればそれができるか見てみましょう。

00:06:10.000 -> 00:06:17.000
分散アクターを宣言するには、Swift 5.7で導入した新しい分散モジュールをインポートする必要があります。

00:06:17.000 -> 00:06:23.000
このモジュールには、分散アクターを宣言して使用するために必要なすべてのタイプが含まれています。

00:06:23.000 -> 00:06:28.000
このように、BotPlayerアクター宣言の前に分散キーワードを追加できるようになりました。

00:06:28.000 -> 00:06:36.000
これにより、アクターは自動的にDistributedActorプロトコルに準拠し、多くの追加のコンパイル時間チェックを有効にします。

00:06:36.000 -> 00:06:39.000
コンパイラが今修正するように求めるエラーの種類を見てみましょう。

00:06:39.000 -> 00:06:44.000
コンパイラは、BotPlayerが使用できるアクターシステムを宣言しないことを有益に教えてくれます。

00:06:44.000 -> 00:06:57.000
分散アクターは常に、リモートコールを実行するために必要なすべてのシリアル化とネットワーキングを処理する分散アクターシステムに属しているため、このアクターを使用する予定のアクターシステムを宣言する必要があります。

00:06:57.000 -> 00:07:10.000
今のところ、私の唯一の目標は、リモートホストで実際に実行することなく、ボットプレーヤーにすべての分散分離チェックに合格させることなので、分散モジュールに付属のLocalTestingDistributedActorシステムを使用できます。

00:07:10.000 -> 00:07:22.000
特定のアクターの本体にモジュール全体のDefaultDistributedActorSystemタイプエイリアスまたはアクターシステムタイプエイリアスを宣言することで、使用するアクターシステムについてコンパイラに伝えることができます。

00:07:22.000 -> 00:07:32.000
後者のビットはもう少し具体的なので、それで行きましょう。

00:07:32.000 -> 00:07:41.000
次のエラーは、両方のプレイヤーアクターが準拠する必要がある識別可能なプロトコルに準拠するために、以前に手動で実装していた「id」プロパティに関するものです。

00:07:41.000 -> 00:07:50.000
エラーは、分散アクター合成プロパティと競合するため、IDプロパティを明示的に定義できないというエラーが表示されます。

00:07:50.000 -> 00:07:53.000
IDは、分散型アクターの重要な部分です。

00:07:53.000 -> 00:08:00.000
それらは、それが一部である分散アクターシステム全体のアクターを一意に識別するために使用されます。

00:08:00.000 -> 00:08:06.000
それらは、アクターが初期化されると分散アクターシステムによって割り当てられ、後でそのシステムによって管理されます。

00:08:06.000 -> 00:08:12.000
そのため、IDプロパティを手動で宣言または割り当てることはできません。アクターシステムはこれを行います。

00:08:12.000 -> 00:08:18.000
言い換えれば、アクターシステムに任せて、手動で宣言したIDプロパティを削除することができます。

00:08:18.000 -> 00:08:23.000
ここで対処する必要がある最後のエラーは、分散アクターの初期化子です。

00:08:23.000 -> 00:08:28.000
コンパイラは、actorSystemプロパティが使用前に初期化されていないと述べています。

00:08:28.000 -> 00:08:33.000
これは、すべての分散アクターの一部である別のコンパイラ合成プロパティです。

00:08:33.000 -> 00:08:43.000
使用するアクターシステムの種類を宣言する必要があるだけでなく、合成されたactorSystemプロパティを具体的なアクターシステムで初期化する必要があります。

00:08:43.000 -> 00:08:49.000
一般的に、ここで行う正しいことは、初期化子のアクターシステムを受け入れ、それをプロパティに渡すことです。

00:08:49.000 -> 00:08:56.000
このようにして、簡単な単体テストを容易にするために、テストで別のアクターシステムの実装に合格することができます。

00:08:56.000 -> 00:09:11.000
また、新しいボットプレーヤーを作成するたびにインスタンスを渡す必要があるので、今すぐやりましょう。

00:09:11.000 -> 00:09:14.000
すごい！宣言側のエラーはすべて終わりました。

00:09:14.000 -> 00:09:18.000
しかし、まだ対処する必要があるコールサイトのエラーがいくつかあります。

00:09:18.000 -> 00:09:23.000
潜在的にリモート分散アクターでは、分散メソッドのみを呼び出すことができるようです。

00:09:23.000 -> 00:09:29.000
これは、システム内の一部のアクターのみを分散アクターとして注釈を付けるのと似ています。

00:09:29.000 -> 00:09:34.000
分散アクターのすべてのメソッドが必ずしもリモートで呼び出されるように設計されているわけではありません。

00:09:34.000 -> 00:09:40.000
彼らは小さなヘルパー関数、または呼び出し者がすでに認証されていると仮定する関数を持つことができます。

00:09:40.000 -> 00:09:47.000
これが、Swiftが分散APIサーフェスについて明確にするように求める理由です。リモート呼び出し者に公開したいと考えています。

00:09:47.000 -> 00:09:53.000
ありがたいことに、これはこれらの関数に分散キーワードを追加するだけで簡単に修正できます。

00:09:53.000 -> 00:10:06.000
makeMoveメソッドと opponentMovedメソッドの両方がリモートで呼び出されることを意図しているので、分散キーワードを両方に追加させてください。

00:10:06.000 -> 00:10:11.000
OK！それだけで、私たちが世話をしなければならない最後のことは1つだけです。

00:10:11.000 -> 00:10:21.000
分散メソッド呼び出しはネットワークの境界を越える可能性があるため、すべてのパラメータと戻り値がアクターシステムのシリアル化要件に準拠していることを確認する必要があります。

00:10:21.000 -> 00:10:26.000
私たちの場合、アクターシステムはSwiftのネイティブシリアル化メカニズムであるCodableを使用しています。

00:10:26.000 -> 00:10:34.000
具体的には、コンパイラは「結果タイプのGameMoveはシリアル化要件Codableに準拠していない」と教えてくれます。

00:10:34.000 -> 00:10:37.000
GameMoveタイプを簡単に見てみましょう。

00:10:37.000 -> 00:10:44.000
幸いなことに、必要な適合性を追加するだけで簡単にコード可能にできるクリーンな小さなデータタイプのようです。

00:10:44.000 -> 00:10:49.000
Swiftコンパイラは、私のために必要なCodable実装を合成します。

00:10:49.000 -> 00:10:50.000
そして、それで、私たちは終わりました!

00:10:50.000 -> 00:10:55.000
予想通りゲームの実行を確認できます。

00:10:55.000 -> 00:10:57.000
OK、チームフィッシュのポイント！

00:10:57.000 -> 00:11:04.000
そして、ボットプレーヤーはまだ同じローカルデバイスで実行していますが、私たちはすでにエキサイティングな次のステップへの道を開きました。

00:11:04.000 -> 00:11:10.000
このステップでは、ボットプレイヤーが新たに獲得した場所の透明性の力の恩恵を実際に享受します。

00:11:10.000 -> 00:11:15.000
これに使用できるWebSocketベースのサンプルアクターシステムをすでに準備しました。

00:11:15.000 -> 00:11:24.000
このアクターシステムを利用することで、ボットプレーヤーをサーバー側のSwiftアプリケーションに移動し、モバイルゲームからのリモート参照を解決することができます。

00:11:24.000 -> 00:11:37.000
アクターに関する限り、宣言されたActorSystemをLocalTesting DistributedActor Systemから、サンプルアプリ用に準備したSampleWebSocketActorSystemに変更するだけです。

00:11:37.000 -> 00:11:40.000
残りのアクターコードは同じままです。

00:11:40.000 -> 00:11:45.000
次に、ローカルで作成するのではなく、リモートボットプレーヤーの参照を解決しましょう。

00:11:45.000 -> 00:11:52.000
「ローカル」と「リモート」という用語は、分散型アクターに関しては視点の問題であることを覚えておく価値があります。

00:11:52.000 -> 00:11:59.000
リモート参照ごとに、分散アクターシステムの他のノードにいくつかの対応するローカルインスタンスがあります。

00:11:59.000 -> 00:12:06.000
分散アクターのローカルインスタンスの作成は、他のSwiftオブジェクトとほぼ同じ方法で実行されます。初期化子を呼び出すことによって。

00:12:06.000 -> 00:12:12.000
しかし、分散アクターへのリモート参照を取得することは、わずかに異なるパターンに従います。

00:12:12.000 -> 00:12:19.000
俳優を作成する代わりに、具体的な俳優システムを使用して俳優IDを解決しようとします。

00:12:19.000 -> 00:12:31.000
静的解決方法を使用すると、アクターシステムに、そのIDを持つアクターの既存のアクターインスタンスを提供しようとしたり、それによって識別されたアクターにリモート参照を返したりすることができます。

00:12:31.000 -> 00:12:44.000
アクターシステムは、識別子を解決するときに実際のリモートルックアップを実行すべきではありません。なぜなら、ご覧のとおり、解決方法は非同期ではないため、すぐに戻り、ネットワーキングやその他のブロッキング操作を実行すべきではないからです。

00:12:44.000 -> 00:12:53.000
アイデンティティが有効に見え、有効な遠隔地を指しているように見える場合、システムはそのようなアクターが存在すると仮定し、それへのリモート参照を返すものとします。

00:12:53.000 -> 00:13:01.000
IDを解決する時点で、リモートシステム上の実際のインスタンスはまだ存在しない可能性があることを覚えておいてください!

00:13:01.000 -> 00:13:08.000
たとえば、ここでは、私たちと一緒にゲームをプレイすることに専念するべき相手のボットプレーヤーのランダムな識別子を作成しています。

00:13:08.000 -> 00:13:16.000
このボットはまだ存在しませんが、このIDに指定された最初のメッセージが受信されると、サーバーサイドシステムで作成されます。

00:13:16.000 -> 00:13:19.000
次に、サーバー側のSwiftアプリケーションに移行します。

00:13:19.000 -> 00:13:24.000
私が準備したサンプルWebSocketアクターシステムのおかげで、それを実装するのは簡単です。

00:13:24.000 -> 00:13:32.000
まず、WebSocketアクターシステムをサーバーモードで作成します。これにより、ポートに接続するのではなく、ポートにバインドしてリッスンします。

00:13:32.000 -> 00:13:36.000
そして、システムが終了するまでアプリを待ちます。

00:13:36.000 -> 00:13:46.000
次に、アクターインスタンスがまだ割り当てられていないIDに宛てられたメッセージを受信する際に、何らかの形でアクターをオンデマンドで作成するパターンを処理する必要があります。

00:13:46.000 -> 00:13:59.000
一般的に、アクターシステムは着信メッセージを受信し、受信者IDを解決してローカルの分散アクターインスタンスを見つけようとし、見つかったアクターに対してリモートコールを実行します。

00:13:59.000 -> 00:14:11.000
しかし、先ほど議論したように、私たちのボットプレーヤーIDは文字通り作成されているため、システムはそれらについて知ることができず、さらに適切なタイプのアクターを単独で作成することはできません。

00:14:11.000 -> 00:14:18.000
ありがたいことに、私たちのサンプルアクターシステムの実装には、オンデマンドアクターの作成という適切なパターンが用意されています。

00:14:18.000 -> 00:14:25.000
これは単なるパターンであり、分散アクターモジュールによって内蔵または提供されるものではないことに注意してください。

00:14:25.000 -> 00:14:30.000
しかし、これは、アクターシステムの実装がどれほど柔軟で強力であるかを示す素晴らしい例です。

00:14:30.000 -> 00:14:36.000
システムはさまざまなパターンを提供し、複雑なタスクを簡単に処理できます。

00:14:36.000 -> 00:14:42.000
このパターンを使用して、アクターシステムは、通常どおりすべての着信IDのローカルアクターを解決しようとします。

00:14:42.000 -> 00:14:47.000
ただし、既存のアクターが見つからない場合は、CreateOnDemandを解決しようとします。

00:14:47.000 -> 00:14:58.000
IDとサーバーコードの一部を作成するクライアントコードの両方を管理しているため、必要なアクターをオンデマンドで作成することで、アクターシステムを支援することができます。

00:14:58.000 -> 00:15:15.000
クライアントで作成しているボット識別子は、ActorIdentityにタグを追加したり、認識可能な名前を使用したりするなど、認識可能な命名スキームを使用しているため、これらのIDを検出し、まだアクティブになっていないすべてのメッセージに対して新しいボット対戦相手を作成できます。

00:15:15.000 -> 00:15:24.000
後続のリモートコールは既存のインスタンスを単に解決するため、指定された最初のメッセージに対して新しいボットプレーヤーのみを作成します。

00:15:24.000 -> 00:15:25.000
そして、それがすべてです!

00:15:25.000 -> 00:15:30.000
サーバーの実装が完了し、リモートボットプレーヤーでゲームをプレイできるようになりました。

00:15:30.000 -> 00:15:39.000
Swift runを使用してコマンドラインからサーバーを実行するか、Xcodeを使用してサーバースキームを選択して、通常どおり[実行]をクリックします。

00:15:39.000 -> 00:15:46.000
最初の動きが終わったら、作成したリモートプレーヤー参照でmakeMoveを呼び出して、ボットプレーヤーに同じことをするように依頼します。

00:15:46.000 -> 00:15:49.000
これにより、サーバー側のシステムで解決がトリガーされます。

00:15:49.000 -> 00:15:55.000
このIDの既存のボットが見つからないので、試行して成功し、オンデマンドでボットを作成します。

00:15:55.000 -> 00:16:01.000
ボットはmakeMoveコールを受信し、生成したGameMoveで返信します。

00:16:01.000 -> 00:16:03.000
それはもうかなり素晴らしかったです!

00:16:03.000 -> 00:16:11.000
ボットプレーヤーを分散アクターに変換するためにいくつかの先行作業を行う必要がありましたが、実際にリモートシステムに移動するのはかなり簡単でした。

00:16:11.000 -> 00:16:16.000
そして、ネットワーキングやシリアル化の実装の詳細をまったく処理する必要はありませんでした!

00:16:16.000 -> 00:16:19.000
すべての重い作業は、分散アクターシステムによって私たちのために行われました。

00:16:19.000 -> 00:16:28.000
そして、まだ利用可能な強化された機能の完全な実装はあまりありませんが、この配布のしやすさは、この機能で努力しているものです。

00:16:28.000 -> 00:16:32.000
次に、ゲームの真のマルチプレイヤー体験を構築する方法を見てみましょう。

00:16:32.000 -> 00:16:39.000
以前の例では、クライアント/サーバーのシナリオで分散アクターを使用していましたが、作業した他のアプリからすでに慣れ親しんでいるかもしれません。

00:16:39.000 -> 00:16:46.000
ただし、分散アクターは、専用のサーバーコンポーネントがまったく存在しないピアツーピアシステムでも使用できます。

00:16:46.000 -> 00:16:48.000
これは私が私たちのゲームのために持っていた別のアイデアと一致します。

00:16:48.000 -> 00:16:55.000
時々、旅行中に、あなたは本当に素晴らしいインターネットを持っていないこれらの場所に終わるが、ローカルWi-Fiはうまく機能します。

00:16:55.000 -> 00:17:02.000
このような状況に陥ったので、同じネットワークに接続されている友人と挑戦して遊べるようになりたいです。

00:17:02.000 -> 00:17:10.000
私は先に進み、今回はネットワークフレームワークが提供するローカルネットワーキング機能を使用して、別のアクターシステムの実装を実装しました。

00:17:10.000 -> 00:17:21.000
この講演では、そのアクターシステムの実装には掘り下げていませんが、WWDC 2019の「Advances in Networking, Part 2」を見て、そのようなカスタムプロトコルを実装する方法を学ぶことができます。

00:17:21.000 -> 00:17:29.000
また、ローカルネットワークへのアクセスは非常にプライバシーに敏感な情報が公開される可能性があるので、慎重に使用するように注意してください。

00:17:29.000 -> 00:17:38.000
今回は、他のデバイス上の既存の分散アクターを扱うことになるので、前の例のようにIDを構成することはできません。

00:17:38.000 -> 00:17:42.000
ゲームをプレイしたい他のデバイスで特定の俳優を発見する必要があります。

00:17:42.000 -> 00:17:48.000
この問題は、分散アクターに固有のものではなく、一般的にサービス発見メカニズムを使用して解決されます。

00:17:48.000 -> 00:17:59.000
しかし、分散アクターの領域では、すべてのコード全体で強く型付けされたAPIに固執することを可能にするAPIアクターシステムの共通のパターンとスタイルを提供することが期待されています。

00:17:59.000 -> 00:18:08.000
私たちはそれを受付パターンと呼んでいます。なぜなら、ホテルと同様に、俳優は他の人が会うために知られ、利用可能になるためにそれでチェックインする必要があるからです。

00:18:08.000 -> 00:18:16.000
すべてのアクターシステムには独自の受付係があり、アクターの発見を実装するために基礎となる輸送メカニズムに最も適した手段を使用できます。

00:18:16.000 -> 00:18:28.000
場合によっては、これは既存のサービスディスカバリーAPIに依存し、その上にタイプセーフなAPIのみを重ねるか、ゴシップベースのメカニズム、または完全に何か他のものを実装するかもしれません。

00:18:28.000 -> 00:18:41.000
しかし、これはアクターシステムのユーザーの観点からの実装の詳細です。私たちが気にする必要があるのは、アクターをチェックして発見可能にし、アクターを発見する必要があるときにタグやタイプでアクターを検索することだけです。

00:18:41.000 -> 00:18:46.000
SampleLocalNetworkActorSystemに実装したシンプルな受付係を見てみましょう。

00:18:46.000 -> 00:18:53.000
これにより、アクターがチェックインできるため、分散アクターシステム内のすべての受付担当者がそれを発見できます。

00:18:53.000 -> 00:19:00.000
その後、そのシステムで利用可能になると、特定のタイプとタグのすべてのアクターのリストを取得できます。

00:19:00.000 -> 00:19:06.000
この受付係を使って、一緒にゲームをしたい具体的な対戦相手俳優を見つけましょう。

00:19:06.000 -> 00:19:12.000
以前は、GameViewはビュー初期化子で対戦相手を直接作成または解決しました。

00:19:12.000 -> 00:19:18.000
対戦相手がネットワークに現れるのを非同期に待つ必要があるため、これはもうできません。

00:19:18.000 -> 00:19:25.000
これを行うには、発見しようとしている間に「相手を探しています...」というメッセージを表示するマッチメイキングビューを紹介します。

00:19:25.000 -> 00:19:28.000
この見解が表示されたら、マッチメイキングを開始します。

00:19:28.000 -> 00:19:39.000
マッチメイキングは、新しい非構造化タスクで行われ、地元の俳優システムの受付係に、相手チームのタグを使用してタグ付けされたすべての俳優のリストを依頼します。

00:19:39.000 -> 00:19:45.000
だから、私たちがチームフィッシュのためにプレーしているなら、私たちはチームのげっ歯類から選手を探し、その逆も同様です。

00:19:45.000 -> 00:19:50.000
次に、非同期forループを使用して、対戦相手の俳優を待ちます。

00:19:50.000 -> 00:19:56.000
システムが私たちがプレイできる対戦相手と一緒に近くのデバイスを発見すると、このタスクループが再開されます。

00:19:56.000 -> 00:20:02.000
対戦相手が常にゲームをプレイする準備ができていると仮定し、すぐにモデルに保存し、彼らと一緒にゲームを開始しましょう。

00:20:02.000 -> 00:20:09.000
ヘルパー機能を使用して、誰が最初の動きをすべきかを決定し、最後に、相手と一緒にゲームを始めたいと相手に伝えます。

00:20:09.000 -> 00:20:16.000
マッチメイキングタスクで完了する必要があるのは1人の対戦相手だけなので、非同期のループから抜け出すために、必ずここに戻ってきてください。

00:20:16.000 -> 00:20:21.000
このゲームプレイモードでは、オフラインプレイヤーの実装を少し変更する必要があります。

00:20:21.000 -> 00:20:27.000
LocalNetworkPlayerと呼び、SampleLocalNetworkActorSystemを使用します。

00:20:27.000 -> 00:20:35.000
それについて最も興味深いのは、人間のプレーヤーを表す俳優のmakeMoveメソッドがリモートで呼び出される可能性があることです!

00:20:35.000 -> 00:20:39.000
しかし、動きをすることは、実際には人間のプレーヤーの責任です。

00:20:39.000 -> 00:20:46.000
この課題を解決するために、ビューモデルにhumanSelectedField非同期関数を導入します。

00:20:46.000 -> 00:20:51.000
これは、人間のユーザーがフィールドの1つをクリックしたときにトリガーされる@Published値によって駆動されます。

00:20:51.000 -> 00:20:59.000
人間のプレイヤーがフィールドをクリックすると、makeMove機能が再開され、実行されたGameMoveをリモート呼び出し元に返すことでリモートコールを完了します。

00:20:59.000 -> 00:21:01.000
そしてまた、それがすべてです!

00:21:01.000 -> 00:21:09.000
真のマルチプレイヤーゲームモードを処理するために、アクターの実装を少し変更する必要がありましたが、システムの全体的なデザインには何も変わりませんでした。

00:21:09.000 -> 00:21:16.000
そして最も重要なことは、私たちのゲームロジックの変更は、私たちがローカルネットワーキングを使用するという事実に本当に固有のものではなかったということです。

00:21:16.000 -> 00:21:21.000
私たちは対戦相手を発見し、プレイヤーの俳優に分散された方法を呼び出すことによって彼らとゲームをプレイします。

00:21:21.000 -> 00:21:24.000
このゲームモードをデモするには、一緒にプレイする対戦相手が必要です。

00:21:24.000 -> 00:21:27.000
ふわふわのアシスタントのカプリン・ザ・カピバラに聞いてみましょう。

00:21:27.000 -> 00:21:32.000
彼はそれがかなり得意だと聞きました！

00:21:32.000 -> 00:21:38.000
OK、彼はかなり頭がいい。

00:21:38.000 -> 00:21:41.000
彼はそれがかなり得意です。

00:21:41.000 -> 00:21:44.000
ここで試してみましょう。

00:21:44.000 -> 00:21:46.000
ああ、彼は私を捕まえた！

00:21:46.000 -> 00:21:49.000
今回はあなたが勝ちます、小さな生き物、しかし、私たちは別のセッションをプレイします。

00:21:49.000 -> 00:21:52.000
助けてくれてありがとう、カプリン!

00:21:52.000 -> 00:21:57.000
最後になりましたが、異なるアクターシステムを組み合わせることで何が達成できるかをお伝えします。

00:21:57.000 -> 00:22:10.000
たとえば、WebSocketシステムを使用して、サーバー側のロビーシステムにデバイスホストされたアクタープレーヤーアクターを登録し、それらをペアリングし、それらの間の分散コールのプロキシとして機能します。

00:22:10.000 -> 00:22:16.000
デバイスホストのプレイヤーアクターが自分自身を登録できるGameLobbyアクターを実装するかもしれません。

00:22:16.000 -> 00:22:23.000
デバイスがプレイオンラインモードに入ると、受付係を使用してGameLobbyを発見し、参加を呼び出します。

00:22:23.000 -> 00:22:30.000
GameLobbyは、利用可能なプレイヤーを追跡し、プレイヤーのペアが特定されたときにゲームセッションを開始します。

00:22:30.000 -> 00:22:36.000
ゲームセッションは、ゲームのドライバーとして機能し、動きをポーリングし、サーバーに保存されたゲームの表現でそれらをマークします。

00:22:36.000 -> 00:22:40.000
ゲームが完了したら、結果を集めてロビーに報告することができます。

00:22:40.000 -> 00:22:45.000
しかし、もっと興味深いことに、このデザインを水平にスケーリングすることができます。

00:22:45.000 -> 00:22:58.000
もちろん、より多くのゲームセッションアクターを作成して、単一のサーバーでより多くのゲームを同時に提供できますが、分散アクターのおかげで、クラスター全体の同時ゲーム数の負荷バランスを取るために、他のノードでゲームセッションを作成することもできます。

00:22:58.000 -> 00:23:01.000
つまり、クラスターアクターシステムがあればいいのに。

00:23:01.000 -> 00:23:03.000
そして、実際、私たちはそうします!

00:23:03.000 -> 00:23:08.000
このようなシナリオで使用するために、機能豊富なクラスターアクターシステムライブラリをオープンソース化しました。

00:23:08.000 -> 00:23:13.000
SwiftNIOを使用して実装され、サーバー側のデータセンタークラスタリングに特化しています。

00:23:13.000 -> 00:23:20.000
障害検出のための高度な技術を適用し、クラスター全体の受付係の独自の実装が付属しています。

00:23:20.000 -> 00:23:28.000
アクターシステムの高度なリファレンス実装であり、強力なサーバーサイドアプリケーションであるため、それを見ることをお勧めします。

00:23:28.000 -> 00:23:31.000
このセッションで学んだことをまとめましょう。

00:23:31.000 -> 00:23:39.000
まず、分散アクターと、追加のコンパイラ支援アクターの分離とシリアル化チェックを提供する方法について学びました。

00:23:39.000 -> 00:23:48.000
私たちは、彼らが場所の透明性を可能にする方法と、発信者と同じプロセスに配置される必要性から俳優を解放するためにそれを利用する方法を学びました。

00:23:48.000 -> 00:23:55.000
また、分散アクターを使用して構築できるものについてインスピレーションを得るために、いくつかのアクターシステムの実装が実行されているのを見ました。

00:23:55.000 -> 00:24:00.000
分散アクターは、使用されているアクターシステムと同じくらい強力です。

00:24:00.000 -> 00:24:04.000
参考までに、このセッションで見たアクターシステムのリストです。

00:24:04.000 -> 00:24:15.000
デフォルトでSwiftに同梱されているローカルテストシステムと、クライアント/サーバースタイルのWebSocketベースのシステムとローカルネットワーキングベースの2つのサンプルアクターシステム。

00:24:15.000 -> 00:24:21.000
これらのシステムはかなり不完全であり、分散アクターを使用して構築する可能性のあるもののインスピレーションとしてより役立ちました。

00:24:21.000 -> 00:24:25.000
このセッションに関連付けられているサンプルコードアプリで表示できます。

00:24:25.000 -> 00:24:30.000
最後になりましたが、オープンソースのフル機能のサーバーサイドクラスタリングの実装です。

00:24:30.000 -> 00:24:35.000
現在ベータパッケージとして利用可能で、Swift 5.7と一緒に成熟します。

00:24:35.000 -> 00:24:47.000
分散アクターの詳細については、次のリソースを参照してください。このセッションに関連するサンプルコードには、Tic Tac Fishゲームのすべてのステップが含まれているため、自分でコードを深く掘り下げることができます。

00:24:47.000 -> 00:24:55.000
分散アクター言語機能に関連するSwift進化の提案は、それらを強化するメカニズムを非常に詳細に説明しています。

00:24:55.000 -> 00:25:04.000
また、Swiftフォーラムで手を差し伸べることもできます。ここでは、アクターシステム開発者とユーザー専用の分散アクターカテゴリを見つけることができます。

00:25:04.000 -> 00:25:08.000
聞いてくれてありがとう、そして私はあなたがあなたのアプリで何のために分散俳優を使うかを見るのを楽しみにしています!

00:25:08.000 -> 23:59:59.000
♪

