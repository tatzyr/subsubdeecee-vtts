WEBVTT

00:00:00.000 -> 00:00:03.000
♪まろやかなインストゥルメンタルヒップホップ音楽♪

00:00:03.000 -> 00:00:09.000
♪

00:00:09.000 -> 00:00:14.000
こんにちは、私の名前はKeyi Yuで、Metal Ecosystemチームのエンジニアです。

00:00:14.000 -> 00:00:17.000
今日は、metal-cppを紹介できて光栄です。

00:00:17.000 -> 00:00:25.000
C++を使用し、Appleプラットフォーム用のMetalアプリケーションを構築したい人のためにmetal-cppを作成しました。

00:00:25.000 -> 00:00:31.000
Metal-cppは、C++アプリケーションをMetalに接続する低オーバーヘッドライブラリです。

00:00:31.000 -> 00:00:43.000
まず、metal-cppとは何か、それがどのように機能するかの概要から始め、次にObjective-Cオブジェクトのライフサイクルに関するいくつかの詳細について説明します。

00:00:43.000 -> 00:00:52.000
C ++とObjective-Cはライフサイクルを少し異なる方法で処理し、それらの違いを処理する方法を紹介します。

00:00:52.000 -> 00:01:01.000
Xcodeとmetal-cppには、アプリのオブジェクトライフサイクルを管理するのに役立つ優れたユーティリティがいくつかあります。

00:01:01.000 -> 00:01:09.000
最後に、C++コードをObjective-Cクラスと統合する方法を紹介します。

00:01:09.000 -> 00:01:13.000
ここでは、metal-cppとその仕組みを見てみましょう。

00:01:13.000 -> 00:01:23.000
Metalは、Appleプラットフォームでグラフィックスとコンピューティングを加速するための基盤であり、アプリやゲームがGPUの信じられないほどのパワーを活用できるようにします。

00:01:23.000 -> 00:01:29.000
もともとは、Objective-Cが提供する強力な機能と慣習を使用して設計されました。

00:01:29.000 -> 00:01:37.000
しかし、コードベースがC++の場合、コードとMetalのObjective-Cコードを橋渡しする何かが必要になるかもしれません。

00:01:37.000 -> 00:01:39.000
Metal-cppを紹介!

00:01:39.000 -> 00:01:45.000
これは、C++アプリケーションとObjective-C Metalの間のハブとして機能します。

00:01:45.000 -> 00:01:56.000
アプリケーションにmetal-cppを使用すると、C ++でMetalクラスと関数を使用でき、metal-cppは実行時にObjective-C関数を呼び出すのに役立ちます。

00:01:56.000 -> 00:02:00.000
metal-cppは軽量のMetal C++ラッパーです。

00:02:00.000 -> 00:02:07.000
インライン関数呼び出しでヘッダーのみのライブラリとして実装されているため、軽量だと言います。

00:02:07.000 -> 00:02:16.000
Objective-C APIへのC++呼び出しの1対1のマッピングを実装することで、Metal APIの100%のカバレッジを提供します。

00:02:16.000 -> 00:02:22.000
これを行うには、metal-cppはFoundationとCoreAnimationフレームワークの一部をラップします。

00:02:22.000 -> 00:02:29.000
Apache 2ライセンスの下でオープンソースなので、ライブラリを変更してアプリケーションに簡単に含めることができます。

00:02:29.000 -> 00:02:35.000
metal-cppはCを使用してObjective-Cランタイムに直接呼び出します。

00:02:35.000 -> 00:02:42.000
これは、Objective-CコンパイラがObjective-Cメソッドを実行するために使用するのとまったく同じメカニズムです。

00:02:42.000 -> 00:02:47.000
したがって、このラッパーはオーバーヘッドをほとんど導入しません。

00:02:47.000 -> 00:02:57.000
metal-cppはC++からObjective-Cへの呼び出しの1対1のマッピングを実装しているため、同じCocoaメモリ管理ルールに従います。

00:02:57.000 -> 00:02:59.000
これについては後で詳しく説明します。

00:02:59.000 -> 00:03:10.000
この1対1のマッピングにより、GPUフレームキャプチャやXcodeデバッガなど、すべての開発者ツールがシームレスに動作することもできます。

00:03:10.000 -> 00:03:15.000
これらは、metal-cppで三角形を描くために必要な一連の呼び出しです。

00:03:15.000 -> 00:03:22.000
C++に精通している場合は、言語構文を心配する必要がないので、Metalを学ぶのに良い時期です。

00:03:22.000 -> 00:03:33.000
すでにObjective-CでMetalを使用している場合、関数呼び出しの面では、Metalとmetal-cppのObjective-Cインターフェースにはほとんど違いはありません。

00:03:33.000 -> 00:03:38.000
私は金属cppを使用するのがいかに簡単かを示すつもりです。

00:03:38.000 -> 00:03:45.000
まず、コマンドバッファを作成し、GPUが実行するコマンドで埋めます。

00:03:45.000 -> 00:03:51.000
C++の生のポインタを、Objective-CのIDへのマッピングとして簡単に使用できます。

00:03:51.000 -> 00:03:57.000
レンダリングコマンドエンコーダを作成し、コマンドバッファでレンダリングコマンドを書くことができます。

00:03:57.000 -> 00:04:06.000
C++関数renderCommandEncoderとObjective-CメソッドrenderCommandEncoder WithDescriptorは同じです。

00:04:06.000 -> 00:04:11.000
唯一の違いは、言語の名前の慣習です。

00:04:11.000 -> 00:04:19.000
次に、頂点とフラグメントシェーダー、その他のさまざまなレンダリング状態を含むレンダリングパイプライン状態オブジェクトを設定します。

00:04:19.000 -> 00:04:24.000
次に、描画呼び出しをエンコードして、単一の三角形をレンダリングします。

00:04:24.000 -> 00:04:29.000
次に、レンダリングコマンドのエンコードが終了したことを示します。

00:04:29.000 -> 00:04:33.000
ドローブルを提示するので、三角形が画面に表示されます。

00:04:33.000 -> 00:04:36.000
最後に、コマンドバッファをコミットします。

00:04:36.000 -> 00:04:40.000
これは、私のコマンドの実行を開始できることをGPUに伝えます。

00:04:40.000 -> 00:04:45.000
明らかに、metal-cppとObjective-C Metalはほぼ同じです。

00:04:45.000 -> 00:04:56.000
metal-cppで言語構文を心配する必要はありません。Metalのドキュメントを直接調べて、Metalの概念と使用法を学ぶことができます。

00:04:56.000 -> 00:05:00.000
あなたはすでにこの延期された照明サンプルで遊んだことがあるかもしれません。

00:05:00.000 -> 00:05:06.000
私たちは今、金属cppを使用するこの延期照明サンプルの新しいバージョンを提供しています。

00:05:06.000 -> 00:05:11.000
これが実際にmetal-cppでコーディングする方法を学ぶのに役立つことを願っています。

00:05:11.000 -> 00:05:25.000
また、Metal APIを導入し、さまざまなタスクを達成する方法を示す一連のインクリメンタルC++サンプルを紹介することに興奮しています。

00:05:25.000 -> 00:05:30.000
Metal-cppについて少し知っているので、実際にどのように使用しますか？

00:05:30.000 -> 00:05:32.000
私たちは昨年metal-cppを出版しました。

00:05:32.000 -> 00:05:36.000
これは、ダウンロードと手順を見つけることができるウェブページです。

00:05:36.000 -> 00:05:39.000
あなたが取る必要があるステップをお見せしましょう。

00:05:39.000 -> 00:05:44.000
metal-cppをダウンロードした後、それを見つける場所をXcodeに伝える必要があります。

00:05:44.000 -> 00:05:49.000
ここでは、現在のプロジェクトの下にmetal-cppを入れました。

00:05:49.000 -> 00:05:56.000
次に、C++17以上をC++言語の方言として設定する必要があります。

00:05:56.000 -> 00:06:03.000
次に、Foundation、QuartzCore、Metalの3つのフレームワークをプロジェクトに追加します。

00:06:03.000 -> 00:06:09.000
今、これらのフレームワークのC++インターフェイスを使用する前にやるべきことは1つだけです。

00:06:09.000 -> 00:06:12.000
Metal-cppには3つのヘッダーがあります。

00:06:12.000 -> 00:06:19.000
Metal-cppはヘッダーのみのライブラリであるため、ヘッダーファイルをインポートする前に実装を生成する必要があります。

00:06:19.000 -> 00:06:29.000
これを行うには、NS_PRIVATE_IMPLEMENTATION、CA_PRIVATE_IMPLEMENTATION、MTL_PRIVATE_IMPLEMENTATIONの3つのマクロを定義します。

00:06:29.000 -> 00:06:37.000
Metal-cppがボンネットの下のマクロで何をするかに興味がある場合は、metal-cppフォルダのヘッダーブリッジファイルをチェックしてください。

00:06:37.000 -> 00:06:42.000
ヘッダーを別々に使用することも、1つのヘッダーに入れることもできます。

00:06:42.000 -> 00:06:45.000
ヘッダーファイルは、必要なときにいつでもインポートできます。

00:06:45.000 -> 00:06:52.000
ただし、NS、CA、またはMTL_PRIVATE_IMPLEMENTATIONマクロを複数回定義しないでください。

00:06:52.000 -> 00:06:56.000
そうしないと、重複した定義エラーが発生する可能性があります。

00:06:56.000 -> 00:07:12.000
metal-cppを効果的に使用するには、Cocoaのメモリ管理ルール、オブジェクトのライフサイクルの管理に役立つ優れたユーティリティの使用方法、他のフレームワークとインターフェイスするときにアプリケーションアーキテクチャを設計する方法を知る必要があります。

00:07:12.000 -> 00:07:16.000
オブジェクトのライフサイクル管理から始めます。

00:07:16.000 -> 00:07:21.000
アプリケーションの動作中は、通常、メモリを割り当てて解放する必要があります。

00:07:21.000 -> 00:07:27.000
また、コマンドバッファ、パイプラインオブジェクト、およびリソースも管理する必要があります。

00:07:27.000 -> 00:07:33.000
このメモリを管理するために、Objective-CとCocoaオブジェクトには参照カウントが含まれています。

00:07:33.000 -> 00:07:36.000
これは金属cppにも存在します。

00:07:36.000 -> 00:07:39.000
参照カウントは、記憶を管理するのに役立ちます。

00:07:39.000 -> 00:07:43.000
参照カウントを使用すると、すべてのオブジェクトにretainCountプロパティが含まれています。

00:07:43.000 -> 00:07:51.000
アプリのコンポーネントは、相互作用しているオブジェクトを生き続けるために数を増やし、それらが終わったらそれを減らします。

00:07:51.000 -> 00:07:56.000
retainCountがゼロになると、ランタイムはオブジェクトの割り当てを解除します。

00:07:56.000 -> 00:07:59.000
Objective-Cの参照カウントには2つのタイプがあります。

00:07:59.000 -> 00:08:06.000
1つは手動保持リリース-MRRと呼ばれ、もう1つは自動参照カウント-ARCです。

00:08:06.000 -> 00:08:16.000
ARC機能でコードをコンパイルするとき、コンパイラは作成した参照を受け取り、基礎となるメモリ管理メカニズムへの呼び出しを自動的に挿入します。

00:08:16.000 -> 00:08:20.000
Metal-cppオブジェクトは手動で保持され、解放されます。

00:08:20.000 -> 00:08:26.000
したがって、オブジェクトを保持して解放するタイミングを知るには、ココアの慣習を理解する必要があります。

00:08:26.000 -> 00:08:34.000
C++でオブジェクトを作成するのとは異なり、metal-cppオブジェクトは新規で作成されず、削除で破棄されません。

00:08:34.000 -> 00:08:45.000
Cocoaの規約では、alloc、new、copy、mutableCopy、またはcreateで始まるメソッドで作成したオブジェクトを所有します。

00:08:45.000 -> 00:08:49.000
保持を使用してオブジェクトの所有権を取得することができます。

00:08:49.000 -> 00:08:54.000
もはやそれを必要としないときは、所有しているオブジェクトの所有権を放棄する必要があります。

00:08:54.000 -> 00:08:58.000
すぐにリリースすることも、後でリリースすることもできます。

00:08:58.000 -> 00:09:05.000
二重の自由を危険にさらすため、所有していないオブジェクトの所有権を放棄してはいけません。

00:09:05.000 -> 00:09:10.000
次に、これらのココアコンベンションの例を見ていきます。

00:09:10.000 -> 00:09:16.000
クラスAでは、メソッドはallocを使用してオブジェクトを作成し、initを使用してこのオブジェクトを初期化します。

00:09:16.000 -> 00:09:20.000
オブジェクトにinitを2回呼び出しないことを覚えておいてください。

00:09:20.000 -> 00:09:25.000
クラスAは所有権を取得し、それを割り当てる責任があります。

00:09:25.000 -> 00:09:29.000
さて、このオブジェクトの保持カウントは1つです。

00:09:29.000 -> 00:09:35.000
次に、クラスBはretainを使用してオブジェクトを取得し、このオブジェクトの所有権を取得します。

00:09:35.000 -> 00:09:42.000
これまでのところ、私はオレンジ色の立方体で表されるこのオブジェクトの所有権を共有する2つのオブジェクトを持っています。

00:09:42.000 -> 00:09:46.000
保持数は1つ増加します。

00:09:46.000 -> 00:09:53.000
クラスAはもうこのオブジェクトを必要としないので、クラスAは手動でリリースを呼び出す必要があります。

00:09:53.000 -> 00:09:56.000
その結果、保持数は1つ減少します。

00:09:56.000 -> 00:10:00.000
現在、クラスBのみがオブジェクトを所有しています。

00:10:00.000 -> 00:10:03.000
さて、最後に、クラスBもこのオブジェクトをリリースしたいと考えています。

00:10:03.000 -> 00:10:08.000
これで、保持カウントはゼロなので、ランタイムはオブジェクトを解放します。

00:10:08.000 -> 00:10:13.000
これは、クラスBのメソッドがオブジェクトを返す状況です。

00:10:13.000 -> 00:10:16.000
残りのプログラムにはまだこのオブジェクトが必要です。

00:10:16.000 -> 00:10:26.000
言い換えれば、クラスBのメソッド内のオブジェクトの所有権を放棄したいが、すぐに割り当て解除されたくない。

00:10:26.000 -> 00:10:30.000
この場合、クラスBのオートリリースを呼び出す必要があります。

00:10:30.000 -> 00:10:36.000
オートリリースを呼び出した後も保持カウントは1つであるため、後でオブジェクトを使用できます。

00:10:36.000 -> 00:10:44.000
ここに質問があります:クラスBはもうこのオブジェクトを所有していないので、誰がそれを割り当て解除する責任がありますか?

00:10:44.000 -> 00:10:49.000
Foundation Frameworkは、AutoreleasePoolと呼ばれる重要なオブジェクトを提供します。

00:10:49.000 -> 00:10:54.000
Autorelease APIは、オブジェクトをAutoreleasePoolに入れます。

00:10:54.000 -> 00:10:58.000
今、AutoreleasePoolはオブジェクトの所有権を取ります。

00:10:58.000 -> 00:11:04.000
AutoreleasePoolは、AutoreleasePoolが破壊されると、レシーバーの保持数を減少させます。

00:11:04.000 -> 00:11:08.000
自動リリースされたオブジェクトを作成できるのはあなただけではありません。

00:11:08.000 -> 00:11:13.000
金属は、その操作の一環として、いくつかの自動解放されたオブジェクトを作成します。

00:11:13.000 -> 00:11:21.000
一時的なオブジェクトを作成するすべてのメソッドは、ボンネットの下でautoreleaseを呼び出すことによって、それらをAutoreleasePoolsに追加します。

00:11:21.000 -> 00:11:24.000
それらを解放するのはAutoreleasePoolの責任です。

00:11:24.000 -> 00:11:30.000
言い換えれば、AutoreleasePoolを使用すると、よりエレガントな方法でコーディングできます。

00:11:30.000 -> 00:11:33.000
メインアプリケーション用のAutoreleasePoolを持つことができます。

00:11:33.000 -> 00:11:41.000
また、プログラムの作業セットを減らすために、より小さなスコープで追加のAutoreleasePoolsを作成および管理することをお勧めします。

00:11:41.000 -> 00:11:45.000
また、作成するすべてのスレッドにAutoreleasePoolsも必要です。

00:11:45.000 -> 00:11:51.000
以下は、AutoreleasePoolと自動解放オブジェクトの使用方法を示す例です。

00:11:51.000 -> 00:12:00.000
このサンプルでは、AutoreleasePoolがallocによって作成されます。つまり、所有権を取得し、手動でリリースする必要があります。

00:12:00.000 -> 00:12:03.000
今、私たちはオートリリースプールを持っています。

00:12:03.000 -> 00:12:07.000
冒頭で説明したように、コマンドバッファを作成する必要があります。

00:12:07.000 -> 00:12:13.000
アロクやクリエイトで作成されていないので、あなたはそれを所有していません。

00:12:13.000 -> 00:12:19.000
代わりに、それはメタルによって作成された自動リリースされたオブジェクトです。

00:12:19.000 -> 00:12:22.000
このコマンドバッファはAutoreleasePoolに入れられます。

00:12:22.000 -> 00:12:26.000
割り当てを解除するのはAutoreleasePoolの責任です。

00:12:26.000 -> 00:12:31.000
AutoreleasePoolをリリースするまで、好きなように使用できます。

00:12:31.000 -> 00:12:35.000
次に、RenderPassDescriptorを作成する必要があります。

00:12:35.000 -> 00:12:40.000
このRenderPassDescriptorは、AutoreleasePoolにも入れられます。

00:12:40.000 -> 00:12:43.000
RenderCommandEncoderも同様です。

00:12:43.000 -> 00:12:46.000
また、Metalによって作成された自動リリースオブジェクトでもあります。

00:12:46.000 -> 00:12:49.000
このcurrentDrawableオブジェクトを忘れないでください。

00:12:49.000 -> 00:12:53.000
オートリリースプールにも入れられます。

00:12:53.000 -> 00:12:59.000
コードの最後に、pPool-&gt;releaseを使用してAutoreleasePoolをリリースします。

00:12:59.000 -> 00:13:14.000
割り当てが解除される前に、AutoreleasePoolは所有するすべてのものをリリースします。この場合、CommandBuffer、RenderPassDescriptor、RenderCommandEncoder、およびcurrentDrawableをリリースします。

00:13:14.000 -> 00:13:16.000
その後、AutoreleasePoolがリリースされます。

00:13:16.000 -> 00:13:22.000
これまでのところ、Cocoaの慣習、自動リリースオブジェクト、AutoreleasePoolsを知ることができました。

00:13:22.000 -> 00:13:35.000
メモリリークやゾンビオブジェクトを避けるために、オブジェクトのライフサイクルを正しく管理することが重要であり、これらの問題を回避およびデバッグするのに役立つ優れたツールがあります。

00:13:35.000 -> 00:13:40.000
NS::SharedPtrとNSZombieの2つのユーティリティに焦点を当てます。

00:13:40.000 -> 00:13:46.000
NS::SharedPtrは、オブジェクトのライフサイクルを管理するのに役立つ新しいユーティリティです。

00:13:46.000 -> 00:13:51.000
metal-cppフォルダのFoundationフレームワークの下にあります。

00:13:51.000 -> 00:13:55.000
Std:shared_ptrとまったく同じではないことに注意してください。

00:13:55.000 -> 00:14:03.000
したがって、C ++標準ライブラリへの依存はなく、参照数を格納するための追加費用もありません。

00:14:03.000 -> 00:14:05.000
NS::SharedPtrはこんな感じです。

00:14:05.000 -> 00:14:11.000
転送と保持機能は、オブジェクトを消費する意図を明確に表現します。

00:14:11.000 -> 00:14:21.000
転送は、ポワン先のreferenceCountを増やすことなくSharedPtrを作成し、SharedPtrに所有権を効果的に譲渡します。

00:14:21.000 -> 00:14:25.000
保持関数は、渡されたオブジェクトに保持を送信します。

00:14:25.000 -> 00:14:36.000
この機能を使用して、AutoreleasePoolsにあるオブジェクトを生き続け、ポインタの所有者がポワン先のライフサイクルに既得権益を持っていることを表現します。

00:14:36.000 -> 00:14:42.000
期待どおりに、getとオペレーター-&gt;を介して、基礎となるオブジェクトにアクセスできます。

00:14:42.000 -> 00:14:51.000
SharedPtrのコピー、移動、構築、および割り当ては期待どおりに作業し、コピーはretainCountを増やします。

00:14:51.000 -> 00:14:56.000
移動は速く、一般的なケースでは保持数には影響しません。

00:14:56.000 -> 00:15:02.000
SharedPtrsは常に破壊時にポワンティーに正確に1つのリリースを送信します。

00:15:02.000 -> 00:15:06.000
必要に応じて、detach関数を呼び出すことでこれを回避できます。

00:15:06.000 -> 00:15:14.000
トップに戻ると、ポインタを転送または保持してポインタを作成することの違いを知ることが重要です。

00:15:14.000 -> 00:15:22.000
したがって、TransferPtrの場合、参照カウントが1のMRRオブジェクトを持っているとします。

00:15:22.000 -> 00:15:30.000
TransferPtr関数に渡すと、SharedPtrはオブジェクトの所有権を取りますが、そのretainCountは変更されません。

00:15:30.000 -> 00:15:40.000
ポインタがスコープ外になると、SharedPtrのデストラクタが実行され、MRRオブジェクトでreleaseを呼び出し、retainCountが0に減少します。

00:15:40.000 -> 00:15:43.000
もう1つの機能はNS::RetainPtrです。

00:15:43.000 -> 00:15:50.000
後で使用したいため、オブジェクトの割り当て解除を避けたい場合は、NS::RetainPtrを使用する必要があります。

00:15:50.000 -> 00:15:55.000
このMRRオブジェクトがあるとします。retainCountは1つです。

00:15:55.000 -> 00:16:00.000
RetainPtr関数に渡すと、retainCountが1つ増加します。

00:16:00.000 -> 00:16:06.000
スコープを使い果たした後、このRetainPtrはこのMRRオブジェクトのリリースを呼び出します。

00:16:06.000 -> 00:16:09.000
したがって、retainCountは1つです。

00:16:09.000 -> 00:16:13.000
一般的に、NS::TransferPtrはあなたのためにオブジェクトの所有権を取ります。

00:16:13.000 -> 00:16:20.000
しかし、NS::RetainPtrは、割り当てを解除したくないときにオブジェクトを保持するのに役立ちます。

00:16:20.000 -> 00:16:34.000
これら2つの関数にオブジェクトを渡すと、NS::TransferPtrは参照数を変更しませんが、NS::RetainPtrは、内部で保持を呼び出すため、参照数を1つ増加させます。

00:16:34.000 -> 00:16:43.000
これら2つの関数のデストラクタは、渡されたオブジェクトのリリースを呼び出すため、参照数は1つ減少します。

00:16:43.000 -> 00:16:48.000
参照数がゼロになると、オブジェクトは実行時に解放されます。

00:16:48.000 -> 00:16:51.000
NS::TransferPtrの例を次に示します。

00:16:51.000 -> 00:16:58.000
単一の三角形を描いたレンダリングパスについて話すとき、このレンダリングパイプラインの状態が必要でした。

00:16:58.000 -> 00:17:02.000
レンダリングパイプライン状態オブジェクトを作成するための呼び出しを次に示します。

00:17:02.000 -> 00:17:05.000
これらは、レンダリングパイプライン記述子が必要とする属性です。

00:17:05.000 -> 00:17:14.000
Cocoaの慣習によると、これらの呼び出しはnewとallocで始まるので、私はこれらのオブジェクトを所有しています。

00:17:14.000 -> 00:17:17.000
だから、私はこれらのオブジェクトのリリースを呼び出す必要があります。

00:17:17.000 -> 00:17:27.000
NS::SharedPtrでは、NS::SharedPtrsがこれらのオブジェクトの所有権を取得するため、これらのMRRオブジェクトのリリースを呼び出す必要はありません。

00:17:27.000 -> 00:17:33.000
そこで、ここでは、TransferPtr関数に生のポインタを渡します。

00:17:33.000 -> 00:17:38.000
その後、前のスライドのようにリリースを呼び出す必要はありません。 前のスライドのように。

00:17:38.000 -> 00:17:46.000
ARCに精通している場合は、NS::SharedPtrで使用されるMRRがARCの使用に似ていることがわかります。

00:17:46.000 -> 00:17:50.000
メモリを手動で処理すると、use-after-freeのバグに遭遇する可能性があります。

00:17:50.000 -> 00:17:55.000
これらは、すでにリリースされたオブジェクトを使用しようとしているときに発生します。

00:17:55.000 -> 00:17:58.000
NSZombieは、これらのバグをチェックする良い方法です。

00:17:58.000 -> 00:18:04.000
Use-after-freeのバグが発生すると、ブレークポイントをトリガーし、スタックトレースを提供します。

00:18:04.000 -> 00:18:08.000
環境変数を使用すると、ゾンビを非常に簡単に有効にできます。

00:18:08.000 -> 00:18:11.000
NSZombieEnabledをYESに設定するだけです。

00:18:11.000 -> 00:18:16.000
または、Xcodeを使用している場合は、スキームでゾンビを有効にすることができます。

00:18:16.000 -> 00:18:18.000
これがその仕組みです。

00:18:18.000 -> 00:18:25.000
同じレンダリングパイプライン設定で新しいレンダリングパイプライン状態オブジェクトを作成したいです。

00:18:25.000 -> 00:18:34.000
したがって、この新しいRenderPipelineState関数では、pDescオブジェクトを再利用します。

00:18:34.000 -> 00:18:40.000
実行をクリックすると、Xcodeはブレークポイントをトリガーし、スタックトレースを表示します。

00:18:40.000 -> 00:18:43.000
それは私が何か間違っていたことを意味します。

00:18:43.000 -> 00:18:47.000
うーん、何が問題なの？

00:18:47.000 -> 00:18:57.000
NSZombieがここで助けてくれるかもしれないので、私はスキームでNSZombieを有効にします。

00:18:57.000 -> 00:19:01.000
プログラムを再度実行すると、NSZombieはブレークポイントをトリガーします。

00:19:01.000 -> 00:19:09.000
コンソール出力に何か新しいものが入りました：「割り当て解除されたインスタンスに送信されたメッセージ」。

00:19:09.000 -> 00:19:12.000
ああ、私はすでにリリースしたオブジェクトを再利用しました。

00:19:12.000 -> 00:19:16.000
そして、それはレンダリングパイプライン記述子です。

00:19:16.000 -> 00:19:21.000
そのため、リリースを呼び出す前に、このレンダリングパイプライン記述子を使用する必要があります。

00:19:21.000 -> 00:19:24.000
そうすることで、私は問題を解決します。

00:19:24.000 -> 00:19:31.000
より多くのツールと詳細は、今年の講演「ゲームのメモリのプロフィレと最適化」で取り上げられています。

00:19:31.000 -> 00:19:37.000
たとえば、機器の割り当てでretainCountを追跡する方法を学ぶことができます。

00:19:37.000 -> 00:19:40.000
Appleプラットフォームの他のツールを自由にチェックしてください。

00:19:40.000 -> 00:19:45.000
彼らがあなたのゲームをデバッグし、パフォーマンスを向上させるのに役立つことがわかります。

00:19:45.000 -> 00:19:50.000
これで、metal-cppでオブジェクトのライフサイクルを管理する方法がわかりました。

00:19:50.000 -> 00:19:56.000
しかし、ゲームコントローラーやオーディオなどの他のフレームワークとインターフェースする必要があるかもしれません。

00:19:56.000 -> 00:19:59.000
これらはまだObjective-Cにあります。

00:19:59.000 -> 00:20:05.000
これらのAPIとどのようにインターフェースし、エレガントなアプリケーションアーキテクチャを設計できますか?

00:20:05.000 -> 00:20:13.000
Objective-CでViewControllerを書いたが、metal-cppでC++でレンダラーを書いたとします。

00:20:13.000 -> 00:20:18.000
ViewControllerからdrawのようなレンダラーメソッドを呼び出す必要があります。

00:20:18.000 -> 00:20:25.000
ここでの課題は、2つの言語をうまく分離し、それらを連携させることです。

00:20:25.000 -> 00:20:32.000
解決策は、Objective-CファイルからC++を呼び出すアダプタークラスを作成することです。

00:20:32.000 -> 00:20:40.000
これにより、機能を実装するファイルでObjective-CまたはC++に集中できます。

00:20:40.000 -> 00:20:45.000
たとえば、Objective-CでRendererAdapterクラスを作成できます。

00:20:45.000 -> 00:20:53.000
そして、実装では、ViewControllerから直接呼び出すことができるように、Objective-Cメソッドを追加します。

00:20:53.000 -> 00:21:00.000
インターフェイス内で、レンダラーオブジェクトへのC++ポインタを宣言します。

00:21:00.000 -> 00:21:06.000
メソッドの本体の中で、レンダラーのC++メソッドを直接呼び出します。

00:21:06.000 -> 00:21:20.000
このメソッドは、MTK::ViewをC ++オブジェクトとしてdrawメソッドに渡す必要があるため、__bridgeキーワードを使用してビューをC++タイプとしてキャストします。

00:21:20.000 -> 00:21:23.000
このキャストについては後で詳しく話します。

00:21:23.000 -> 00:21:32.000
対照的に、C++で書かれたRendererでObjective-Cで書かれたMTKViewを呼び出す必要があります。

00:21:32.000 -> 00:21:35.000
それも挑戦的です。

00:21:35.000 -> 00:21:39.000
同様に、解決策はアダプタークラスを作成することです。

00:21:39.000 -> 00:21:47.000
このクラスでは、C++ファイルでは、C++インターフェイスを使用してObjective-Cメソッドを呼び出すことができます。

00:21:47.000 -> 00:21:50.000
たとえば、ViewAdapterクラスを作成できます。

00:21:50.000 -> 00:21:58.000
私はC++でインターフェイスを書くので、Rendererクラスでは、これらのC++ビューメソッドを簡単に呼び出すことができます。

00:21:58.000 -> 00:22:08.000
実装中は、currentDrawableやdepthStencilTextureなど、MTKViewからObjective-Cメソッドを呼び出します。

00:22:08.000 -> 00:22:11.000
ここには__bridgeのキーワードがあることに気付くかもしれません。

00:22:11.000 -> 00:22:16.000
私はそれらを使用して、metal-cppオブジェクトとObjective-Cオブジェクトの間でキャストします。

00:22:16.000 -> 00:22:27.000
最初に学んだように、metal-cppオブジェクトは手動で保持および解放されますが、Objective-Cによって作成されたオブジェクトは自動参照カウントを使用します。

00:22:27.000 -> 00:22:33.000
オブジェクトをMRRからARCに、ARCからMRRに移動する必要があります。

00:22:33.000 -> 00:22:39.000
Objective-CとC++の間でキャストするのに役立つ3種類のブリッジキャスティングを次に示します。

00:22:39.000 -> 00:22:47.000
彼らはまた、あなたが所有権を譲渡するのを助けることができます_Objective-Cとmetal-cppオブジェクトの間で鋳造キャストをブリッジします。

00:22:47.000 -> 00:22:52.000
両者の間に所有権の移転はありません。

00:22:52.000 -> 00:23:00.000
__Bridge_retained castingは、Objective-Cポインタをmetal-cppポインタにキャストし、ARCから所有権を取ります。

00:23:00.000 -> 00:23:07.000
__Bridge_transfer castingは、metal-cppポインタをObjective-Cに移動し、所有権をARCに譲渡します。

00:23:07.000 -> 00:23:13.000
問題に戻ると、metal-cppオブジェクトとObjective-Cオブジェクトの間でキャストする必要があります。

00:23:13.000 -> 00:23:18.000
所有権の譲渡がない場合は、__bridge castを使用できます。

00:23:18.000 -> 00:23:29.000
metal-cppからObjective-Cオブジェクトにキャストし、所有権をObjective-Cに譲渡する場合は、__bridge_transfer castを使用する必要があります。

00:23:29.000 -> 00:23:37.000
Objective-Cからmetal-cppオブジェクトにキャストし、ARCから所有権を取得したい場合は、__bridge_retained castを使用する必要があります。

00:23:37.000 -> 00:23:42.000
これは、資産の読み込みコードを活用するためにMetalKitを使用しなければならないケースです。

00:23:42.000 -> 00:23:53.000
つまり、私のC++アプリケーションでは、metal-cppオブジェクトとしてテクスチャが必要ですが、Objective-Cメソッドによって作成されます。

00:23:53.000 -> 00:23:59.000
手動でリリースできるように、ARCから所有権を譲渡する能力が必要です。

00:23:59.000 -> 00:24:06.000
そして、この場合、私は__bridge_retainedキャストを選ぶ必要があります。

00:24:06.000 -> 00:24:13.000
カタログからテクスチャをロードするこのC++関数があり、metal-cppテクスチャを返したいです。

00:24:13.000 -> 00:24:19.000
しかし、内部では、MetalKitでいくつかのObjective-C関数を呼んでいます。

00:24:19.000 -> 00:24:23.000
テクスチャローダーに必要なオプションを定義する必要があります。

00:24:23.000 -> 00:24:31.000
次に、MetalKitからObjective-Cメソッドを呼び出してテクスチャローダーを作成します。

00:24:31.000 -> 00:24:38.000
そのローダーを使用すると、テクスチャオブジェクトを作成し、カタログからテクスチャを読み込むことができます。

00:24:38.000 -> 00:24:43.000
この方法は、MetalKitのObjective-C方法でもあります。

00:24:43.000 -> 00:24:52.000
今、私はObjective-Cタイプのテクスチャを持っているので、それをmetal-cppオブジェクトにキャストしてARCから取り出す必要があります。

00:24:52.000 -> 00:24:58.000
これらのステップを念頭に置いて、コード化する時が来ました。キャスティングが実際にどのように機能するかをお見せします。

00:24:58.000 -> 00:25:03.000
最初のステップは、テクスチャローダーが必要とするテクスチャローダーのオプションを定義することです。

00:25:03.000 -> 00:25:13.000
metal-cppタイプがそれらを同じ値に定義するので、metal-cppストレージモードと使用法をObjective-Cタイプに安全にキャストできます。

00:25:13.000 -> 00:25:16.000
ここでは、テクスチャローダーを作成します。

00:25:16.000 -> 00:25:24.000
私はmetal-cppオブジェクトであるデバイスを持っており、それをinitWithDeviceメソッドに渡す必要があります。

00:25:24.000 -> 00:25:31.000
metal-cppオブジェクトはObjective-Cオブジェクトなので、フリーダイヤルオブジェクトのようにキャストできます。

00:25:31.000 -> 00:25:35.000
所有権の譲渡はありません。

00:25:35.000 -> 00:25:39.000
今、私はテクスチャローダーオプションとテクスチャローダーを使用してテクスチャを作成します。

00:25:39.000 -> 00:25:44.000
そして、ロードされたテクスチャをmetal-cppオブジェクトとして返したい。

00:25:44.000 -> 00:25:50.000
そのため、ARCから取り出して、対応するポインタタイプにキャストする必要があります。

00:25:50.000 -> 00:25:53.000
これは__bridge_retainedキャストで行われます。

00:25:53.000 -> 00:25:57.000
この後、このテクスチャを任意のmetal-cppオブジェクトとして使用できます。

00:25:57.000 -> 00:26:00.000
私はそれを解放する責任があります。

00:26:00.000 -> 00:26:08.000
このセクションでは、プログラムで2つの異なる言語を処理するのに役立つアダプターパターンを提供しました。

00:26:08.000 -> 00:26:15.000
また、3種類のキャストでObjective-CとC++とインターフェースする方法も示しました。

00:26:15.000 -> 00:26:22.000
要約すると、metal-cppは軽量で非常に効率的なMetal C++ラッパーです。

00:26:22.000 -> 00:26:37.000
metal-cppを使用する際のオブジェクトライフサイクルの管理方法、Objective-Cとのエレガントなインターフェース方法、開発者ツールがデバッグにどのように役立つかについて話しました。

00:26:37.000 -> 00:26:41.000
Metal-cppをダウンロードして、今すぐすべての素晴らしいサンプルで遊ぼう!

00:26:41.000 -> 00:26:44.000
メタルで作れるものを見てください。

00:26:44.000 -> 00:26:49.000
C++アプリケーションがすべてのAppleプラットフォームで実行されるのを楽しみにしています。

00:26:49.000 -> 00:26:51.000
見てくれてありがとう!

00:26:51.000 -> 23:59:59.000
♪

