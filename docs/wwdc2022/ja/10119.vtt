WEBVTT

00:00:01.000 -> 00:00:14.000
こんにちは、アップルのコアデータチームのエンジニア、ニック・ギレットです。

00:00:14.000 -> 00:00:21.000
このセッションでは、開発者ツールを使用して、NSPersistentCloudKitContainerを使用するアプリケーションについて詳しく知る方法を紹介します。

00:00:21.000 -> 00:00:28.000
まず、生産的で教育的な方法でアプリケーションを探索する方法を詳しく見ていきます。

00:00:28.000 -> 00:00:33.000
次に、私のお気に入りのツールのいくつかを使用して、アプリケーションがどのように動作するかを分析します。

00:00:33.000 -> 00:00:42.000
そして最後に、NSPersistentCloudKitContainerでの経験について、詳細で実用的なフィードバックを提供する方法を見ていきます。

00:00:42.000 -> 00:00:46.000
私はエンジニアリングを水循環のように考えるのが好きです。

00:00:46.000 -> 00:00:51.000
通常、私は機能が存在する空間を探索することで、機能に取り組み始めます。

00:00:51.000 -> 00:01:00.000
次に、学んだことに基づいて、ツールとテストを組み合わせて、再現可能な環境で作業を分析します。

00:01:00.000 -> 00:01:07.000
最後に、同僚や同僚と結果を確認し、フィードバックを集めます。

00:01:07.000 -> 00:01:12.000
このサイクルの目標は、私が仕事中に学んだことを永続的に捉えることです。

00:01:12.000 -> 00:01:21.000
Appleのプラットフォームには、私が学んだことをキャプチャするために使用するXcode、Instruments、XCTestなどのツールの素晴らしい選択が含まれています。

00:01:21.000 -> 00:01:30.000
これらのツールはまた、実用的なフィードバックを提供するために使用できる豊富な診断情報を収集することを可能にします。

00:01:30.000 -> 00:01:34.000
このセッションでは、過去数年間の多くの知識を参照しています。

00:01:34.000 -> 00:01:51.000
NSPersistentCloudKitContainerとCore Data CloudKitサンプルアプリケーションについて、本日、セッション「CloudKitとCore Dataを介してデータを共有するアプリを構築する」とセッション「CloudKitでCore Dataを使用する」で詳しく説明しました。

00:01:51.000 -> 00:02:00.000
また、XcodeとInstrumentsを使用してテストを実行する方法と、デバイスオーガナイザーを使用してデバイスからデータをキャプチャする方法も実演します。

00:02:00.000 -> 00:02:14.000
必要に応じて、「Instrumentsを使い始める」と「Xcodeオーガナイザーでパフォーマンスの問題を診断する」セッションを確認して、ツールチェーンのこれら2つの重要な部分について詳しく知ることをお勧めします。

00:02:14.000 -> 00:02:19.000
さて、サイクルの最初の部分、探検から始めましょう。

00:02:19.000 -> 00:02:24.000
私にとって、探検の主な目標は学ぶことです。

00:02:24.000 -> 00:02:30.000
アプリケーションがどのように機能するかについて私が持っているすべての仮定に挑戦し、検証したいと思います。

00:02:30.000 -> 00:02:34.000
私は尋ねるかもしれません：このボタンをタップするとどうなりますか？

00:02:34.000 -> 00:02:39.000
永続ストアにデータを保存すると、NSPersistentCloudKitContainerは同期しますか?

00:02:39.000 -> 00:02:44.000
大規模なデータセットで作業するとき、アプリケーションはメモリを使い果たしますか?

00:02:44.000 -> 00:02:51.000
コアデータの観点から、これらの質問はすべて、アプリケーションが作業するデータの影響を受けます。

00:02:51.000 -> 00:02:58.000
たとえば、Core Data CloudKitサンプルアプリケーションは、このデータモデルを使用します。

00:02:58.000 -> 00:03:04.000
タイトルとコンテンツのテキストフィールドを含む一連の投稿を管理します。

00:03:04.000 -> 00:03:10.000
投稿は添付ファイル、一般的に画像に関連している可能性があり、これは非常に大きくなる可能性があります。

00:03:10.000 -> 00:03:17.000
したがって、ImageDataは、オンデマンドでロードできるように、to-oneリレーションシップ全体で保存されます。

00:03:17.000 -> 00:03:30.000
そして、私はそのデータセット、特にそのデータの形状、構造、分散を変更するときにサンプルアプリケーションに何が起こるかに焦点を当てます。

00:03:30.000 -> 00:03:36.000
リリース以来、サンプルアプリケーションには、それを探索するための組み込みの方法が含まれています。

00:03:36.000 -> 00:03:41.000
1000件の投稿の生成ボタンは、ラベルに書かれていることを正確に行います。

00:03:41.000 -> 00:03:47.000
タップすると、短いタイトルの1,000件の投稿のサンプルデータセットが生成されます。

00:03:47.000 -> 00:03:50.000
投稿テーブルビューは、このレベルのデータを簡単に処理できます。

00:03:50.000 -> 00:03:59.000
だから、私が尋ねる次の質問は、このアプリケーションで異なる形状やサイズのデータセットを探索するにはどうすればよいですか?

00:03:59.000 -> 00:04:05.000
1000投稿の生成ボタンは、私がアルゴリズムデータジェネレータと呼ぶものを実行します。

00:04:05.000 -> 00:04:17.000
アルゴリズムデータジェネレータは、「1000個のオブジェクトを挿入する」や「すべてのフィールドに値があることを確認する、またはフィールドに値がないことを確認する」などの一連の所定のルールに従います。

00:04:17.000 -> 00:04:21.000
結局のところ、私たちもデータジェネレータです。

00:04:21.000 -> 00:04:34.000
コード、SQL、またはアプリケーションと直接対話することで、特定のデータセットを手作りすることができ、これらの生成されたデータセットは、後で使用または分析するために保存することができます。

00:04:34.000 -> 00:04:46.000
より大きなデータセットを探索するには、新しいデータジェネレータであるLargeDataGeneratorを定義し、単一のメソッドであるgenerateDataを使用して新しいデータセットを構築できます。

00:04:46.000 -> 00:04:54.000
わずか2つのforループで、それぞれがそれらに関連付けられた11の画像添付ファイルを持つ60の投稿のセットを生成することができます。

00:04:54.000 -> 00:04:57.000
それは合計660枚の画像です。

00:04:57.000 -> 00:05:06.000
画像あたり10〜20メガバイトの平均サイズで、生成されたデータセットはほぼ10GBのデータを消費します。

00:05:06.000 -> 00:05:12.000
このようなシンプルなインターフェースで、このようなテストではデータジェネレータを簡単に呼び出すことができます。

00:05:12.000 -> 00:05:20.000
この1行のコードは、このテストで使用するために10GB以上の代表的なデータを生成します。

00:05:20.000 -> 00:05:33.000
さらに、各投稿が実際に11の画像添付ファイルを取得すると主張するなど、データジェネレータが正しく動作することを検証するテストで検証方法を構築できます。

00:05:33.000 -> 00:05:39.000
もちろん、このデータを同期しなければ、これはNSPersistentCloudKitContainerの話ではないでしょう。

00:05:39.000 -> 00:05:43.000
だから、それを行うための新しいテストを作りましょう。

00:05:43.000 -> 00:05:49.000
最初に必要なのは、使用するNSPersistentCloudKitContainerのインスタンスです。

00:05:49.000 -> 00:05:52.000
私はそれを簡単にするためのヘルパーメソッドを作成しました。

00:05:52.000 -> 00:05:59.000
次に、LargeDataGeneratorを使用して、目的のデータセットをコンテナに入力します。

00:05:59.000 -> 00:06:04.000
そして最後に、コンテナがデータのエクスポートを完了するのを待ちます。

00:06:04.000 -> 00:06:11.000
この特定のテストでは、大きなデータセットをアップロードする時間を与えるために最大20分待ちます。

00:06:11.000 -> 00:06:18.000
あなたの中のワシの目は、このテストがさまざまな種類のイベントを待っているように見えることに気づいたかもしれません。

00:06:18.000 -> 00:06:24.000
ここでは、コンテナを作成するときに、コンテナのセットアップが完了するのを待ちます。

00:06:24.000 -> 00:06:32.000
そしてここでは、コンテナからのエクスポートイベントのXCTestExpectationsを作成するために書いたヘルパーメソッドを使用します。

00:06:32.000 -> 00:06:34.000
それを詳しく見てみましょう。

00:06:34.000 -> 00:06:41.000
このメソッドは、目的のイベントタイプとNSPersistentCloudKitContainerのインスタンスを引数として取ります。

00:06:41.000 -> 00:06:55.000
NSPersistentCloudKitContainerのeventChanged通知を観察するために、XCTestCaseのexpectForNotificationメソッドを使用して、コンテナ内の各永続ストアに1つの期待値を作成します。

00:06:55.000 -> 00:07:08.000
通知ハンドラブロックでは、着信イベントがこの期待値が対象である特定のストアの正しいタイプであり、endDateがnilに等しくないことを確認することで終了したことを確認します。

00:07:08.000 -> 00:07:17.000
この手法を使用することで、テストのコントロールポイントをNSPersistentCloudKitContainerのイベントと強く関連付けることができます。

00:07:17.000 -> 00:07:24.000
テストに戻って、エクスポートされたばかりのデータをインポートするための新しいコンテナを追加します。

00:07:24.000 -> 00:07:26.000
このテクニックはトリックを使います。

00:07:26.000 -> 00:07:31.000
空のストアファイルを使用して、NSPersistentCloudKitContainerの新しいインスタンスを作成します。

00:07:31.000 -> 00:07:42.000
これにより、テストはNSPersistentCloudKitContainerの初回インポートを利用して、このすべてのデータがデバイスによってダウンロードされたときに何が起こるかを調べることができます。

00:07:42.000 -> 00:07:48.000
今、テストは素晴らしいですが、時々私はアプリケーションでデータセットがどのように振る舞うかを感じたいです。

00:07:48.000 -> 00:07:56.000
これを行うには、サンプルアプリケーションで行ったように、データジェネレータをユーザーインターフェイスにバインドできます。

00:07:56.000 -> 00:08:02.000
「大きなデータの生成」ボタンをタップすると、データジェネレータがデータセットに入力されるのを見ることができます。

00:08:02.000 -> 00:08:12.000
2台目のデバイスでは、NSPersistentCloudKitContainerが生成されたデータのダウンロードを進めるにつれて、テーブルビューが入力されるのを見ることができます。

00:08:12.000 -> 00:08:22.000
個々の投稿をタップすると、このアプリケーションのユーザーと同じように、添付ファイルがダウンロードされ、段階的に入力されます。

00:08:22.000 -> 00:08:27.000
この特定のユーザーインターフェイスは、アラートコントローラーによって駆動されます。

00:08:27.000 -> 00:08:34.000
LargeDataGeneratorのシンプルなインターフェースにより、この2行のコードだけで新しいアラートアクションを簡単に追加できます。

00:08:34.000 -> 00:08:39.000
それは明確で、簡潔で、理解しやすいです。

00:08:39.000 -> 00:08:46.000
このセクションでは、データジェネレータの概念を使用して、アプリケーションの動作を探りました。

00:08:46.000 -> 00:09:01.000
データジェネレータは、私が実証したように、テストやカスタムUI、またはコマンドライン引数のようなもの、または特定のユースケースで機能する他の何かによって、私たちが選択した方法でアプリケーションで駆動することができます。

00:09:01.000 -> 00:09:08.000
アプリケーションにデータを入力する方法がわかったので、それがアプリケーションの動作をどのように変えるかを分析する準備が整いました。

00:09:08.000 -> 00:09:16.000
このセクションでは、アプリケーションが大規模なデータセットでどのように動作するかを分析するためのいくつかのツールとテクニックについて学びます。

00:09:16.000 -> 00:09:25.000
具体的には、Instrumentsを使用して、LargeDataGeneratorによって作成されたデータセットの時間とメモリの複雑さを分析します。

00:09:25.000 -> 00:09:30.000
次に、システムログで利用可能な豊富な情報を見ていきます。 

00:09:30.000 -> 00:09:39.000
そこでは、NSPersistentCloudKitContainer、CloudKit、システムスケジューラ、およびプッシュ通知からアクティビティの記録を見つけることができます。

00:09:39.000 -> 00:09:42.000
インスツルメンツで見つめましょう。

00:09:42.000 -> 00:09:49.000
私がテストが好きな理由の1つは、Xcodeがテストの動作を簡単に分析できるからです。

00:09:49.000 -> 00:09:55.000
私のテストケースでは、側溝でテストの開示を右クリックして、プロファイルを選択できます。

00:09:55.000 -> 00:10:00.000
Xcodeはテストを構築し、自動的にインストゥルメントを起動します。

00:10:00.000 -> 00:10:07.000
タイムプロファイラー機器をダブルクリックして、テストが作業に時間を費やしている場所を調べることができます。

00:10:07.000 -> 00:10:14.000
記録ボタンをクリックすると、Instrumentsはアプリケーションを起動し、選択したテストを実行します。

00:10:14.000 -> 00:10:18.000
このテストは実行にかなり時間がかかるようです。

00:10:18.000 -> 00:10:21.000
先にスキップして理由を見てみましょう。

00:10:21.000 -> 00:10:30.000
インストゥルメントはすでにメインスレッドを選択しており、右側にはテスト実行の最も重いスタックトレースが見えます。

00:10:30.000 -> 00:10:36.000
もう少し読みやすくしましょう。

00:10:36.000 -> 00:10:38.000
行くよ。

00:10:38.000 -> 00:10:45.000
さて、一番下までスクロールすると、LargeDataGeneratorがサムネイルの生成に多くの時間を費やしていることがわかります。

00:10:45.000 -> 00:10:50.000
これがバグなのか機能なのか、どのように判断しますか?

00:10:50.000 -> 00:10:56.000
LargeDataGeneratorには、添付ファイルごとに新しいサムネイルを生成するコード行があります。

00:10:56.000 -> 00:11:01.000
しかし、私はアプリケーションのデータモデルから、サムネイルが特別であることを知っています。

00:11:01.000 -> 00:11:05.000
それらは関連するimageDataからオンデマンドで計算されます。

00:11:05.000 -> 00:11:11.000
つまり、この行は不要であり、私のデータジェネレータはそれらに多くの時間を無駄にしています。

00:11:11.000 -> 00:11:14.000
だから、私はそれを取り除くことができます。

00:11:14.000 -> 00:11:17.000
それがテストのパフォーマンスをどのように変えるか見てみましょう。

00:11:17.000 -> 00:11:23.000
更新されたデータジェネレータでアプリを再構築した後、Instrumentsでテストを再実行できます。

00:11:23.000 -> 00:11:32.000
正直なところ、あまり変化は見られませんが、あと数秒でテストは完了します。

00:11:32.000 -> 00:11:35.000
それは前回の実行よりもずっと速いです。

00:11:35.000 -> 00:11:43.000
テストがほとんどの時間をどこに費やしたのか見てみましょう。

00:11:43.000 -> 00:11:55.000
右の引き出しでは、最も重いスタックトレースが永続ストアに画像を保存することであり、それはまさに私がこれだけのデータを管理するテストに期待するものです。

00:11:55.000 -> 00:12:02.000
その1つの変更により、generateDataテストのランタイムがこれからこれに短縮されました。

00:12:02.000 -> 00:12:05.000
それは10分の1の時間で実行されます。

00:12:05.000 -> 00:12:16.000
このようにテストを分析すると、必ずしもバグが明らかになるとは限りません。特定のデータセットで作業するときに、アプリケーションが時間を費やしている場所について詳しく学ぶこともあります。

00:12:16.000 -> 00:12:19.000
しかし、いずれにせよ、それは貴重な学習です。

00:12:19.000 -> 00:12:26.000
そのため、タイムプロファイラ機器は、アプリケーションがデータセットに時間を費やす場所を調査するのに役立ちます。

00:12:26.000 -> 00:12:33.000
さて、このデータセットのサイズのために、テストがどれだけのメモリを使用しているかにも興味があります。

00:12:33.000 -> 00:12:37.000
では、割り当て機器を使用して実行してみましょう。

00:12:37.000 -> 00:12:42.000
Xcodeを使用してInstrumentsを起動し、テストをプロファイリングします。

00:12:42.000 -> 00:12:51.000
タイムプロファイラ機器を選択する代わりに、割り当てをダブルクリックします...

00:12:51.000 -> 00:13:02.000
そして、[記録]をクリックします。

00:13:02.000 -> 00:13:10.000
このテストは迅速に実行されていますが、実際には10GBを超える多くのメモリを使用しています。

00:13:10.000 -> 00:13:15.000
これは、テスト実行中にデータセットのほぼ全体がメモリに保持されていることを示しています。

00:13:15.000 -> 00:13:19.000
理由を調べてみましょう。

00:13:19.000 -> 00:13:22.000
見るための割り当ての範囲を選択できます。

00:13:22.000 -> 00:13:27.000
下のペインには、多くの大きな割り当てがあることがわかります。

00:13:27.000 -> 00:13:36.000
この開示をクリックしてそれらを掘り下げ、テストに割り当てられた大きなデータブロブの1つをクリックすることができます。

00:13:36.000 -> 00:13:41.000
この特定のブロブは割り当てられましたが、ほぼ2秒間解放されませんでした。

00:13:41.000 -> 00:13:46.000
それはテスト時間の永遠です。なぜそんなに長く生きていたのですか?

00:13:46.000 -> 00:13:53.000
右側のスタックトレースを展開することで、それを探索できます。

00:13:53.000 -> 00:14:05.000
経験から、割り当てと割り当て解除スタックトレースは、このオブジェクトがCoreDataによって障害を受け、管理オブジェクトコンテキストが作業を終了したときにリリースされたことを教えてくれます。

00:14:05.000 -> 00:14:15.000
これは通常、オブジェクトがフェッチ、オートリリースプール、またはテストのオブジェクトによって保持されたことを示しています。

00:14:15.000 -> 00:14:19.000
コードの問題のあるセクションは、私の検証者にあります。

00:14:19.000 -> 00:14:22.000
添付ファイルから画像をロードして確認します。

00:14:22.000 -> 00:14:29.000
ただし、これにより、添付ファイルと関連する画像データが管理オブジェクトコンテキストに登録されたままになります。

00:14:29.000 -> 00:14:33.000
これを解決する方法はいくつかあります。この問題を解決する方法はいくつかあります。

00:14:33.000 -> 00:14:41.000
たとえば、テーブルビューでは、バッチフェッチを使用して、テーブルが投稿の上をスクロールするときに画像を解放することができます。

00:14:41.000 -> 00:14:46.000
しかし、このテストは、それが効果的であるにはあまりにも速く実行されています。

00:14:46.000 -> 00:14:48.000
私はアプローチを変える必要があります。

00:14:48.000 -> 00:14:54.000
投稿を取得して検証する代わりに、代わりに添付ファイルを取得できます。

00:14:54.000 -> 00:15:03.000
オブジェクトIDのみを取得する場合、管理オブジェクトコンテキストは、私が要求するまでロードされたオブジェクトをキャプチャしません。

00:15:03.000 -> 00:15:11.000
NSManagedObjectContextのobjectWithIDメソッドを使用して、検証のために添付ファイルを取得できます。

00:15:11.000 -> 00:15:21.000
最後に、検証する10個の添付ファイルごとに、コンテキストをリセットし、キャッシュされた状態と関連するメモリをすべて解放します。

00:15:21.000 -> 00:15:30.000
この変更でテストを再実行すると、はるかに予測可能で調整可能なレベルのメモリ消費になることがわかります。

00:15:30.000 -> 00:15:38.000
実際、検証者は、これらのオブジェクトを挿入するときにLargeDataGeneratorよりもさらに少ないメモリを使用します。

00:15:38.000 -> 00:15:44.000
修正がどのように機能するかを学ぶために、特定の割り当てを掘り下げてみましょう。

00:15:44.000 -> 00:15:47.000
まず、作業する割り当ての範囲を選択します。

00:15:47.000 -> 00:16:05.000
次に、検査する特定のサイズを選択し、破壊されたオブジェクトがこの間に解放されたものを見つけることができるようにする必要があり、その後、検査する特定の割り当てを選択できます。

00:16:05.000 -> 00:16:15.000
右側では、Instrumentsには割り当てスタックトレースが表示されますが、どこで解放されたのか知りたいので、割り当て解除イベントを選択します。

00:16:15.000 -> 00:16:27.000
このスタックトレースは、NSManagedObjectContextがこのブロブを保持したオブジェクトを非同期に割り当て解除し、消費されたメモリを解放することを意味することをたまたま知っています。

00:16:27.000 -> 00:16:35.000
この技術により、テストの高いウォーターマークを確立し、メモリの少ないシステムで実行することができます。

00:16:35.000 -> 00:16:43.000
テストとインスツルメンツを組み合わせることで、この特定のテストには望ましくない動作があることがわかりました。

00:16:43.000 -> 00:16:49.000
ターゲットを絞った変更を行い、その行動に直接対処し、結果を確認しました。

00:16:49.000 -> 00:17:02.000
さらに、システムログには、CloudKit、スケジューリング、プッシュ通知など、アプリケーションとそれが依存するシステムサービスに関する豊富な情報も含まれています。

00:17:02.000 -> 00:17:08.000
MacBook ProとiPhoneの間で1つの投稿を同期するつもりです。

00:17:08.000 -> 00:17:18.000
Macに新しい投稿を挿入し、短いタイトルを付けてiCloudにアップロードすると、システムログは多くのイベントをキャプチャします。

00:17:18.000 -> 00:17:27.000
私のiPhoneに同期すると、時には中間状態をキャプチャすると、システムログは対応する一連のイベントをキャプチャします。

00:17:27.000 -> 00:17:37.000
MacBook Proでは、NSPersistentCloudKitContainerはアプリケーションプロセス、この場合はCoreDataCloudKitDemo内で機能します。

00:17:37.000 -> 00:17:47.000
データが永続ストアに書き込まれると、DASDと呼ばれるシステムサービスに、そのデータをCloudKitにエクスポートする良い時期かどうかを尋ねます。

00:17:47.000 -> 00:17:53.000
もしそうなら、DASDはNSPersistentCloudKitContainerにアクティビティを実行するように指示します。

00:17:53.000 -> 00:18:02.000
NSPersistentCloudKitContainerは、変更されたオブジェクトをCloudKitにエクスポートするためにclouddと呼ばれるプロセスで作業をスケジュールします。

00:18:02.000 -> 00:18:07.000
コンソールアプリを使用して、これらの各プロセスのログを観察できます。

00:18:07.000 -> 00:18:14.000
アプリケーションログについては、アプリケーションプロセスであるCoreDataCloudKitDemoを探すだけです。

00:18:14.000 -> 00:18:18.000
ここでは、エクスポート完了を示すものを選択しました。

00:18:18.000 -> 00:18:26.000
スケジューリングログについては、プロセスdasdとアプリケーションの特定のストアからのログを見たいです。

00:18:26.000 -> 00:18:32.000
ここでは、アプリケーションのプライベートストアのエクスポートアクティビティの開始を選択しました。

00:18:32.000 -> 00:18:36.000
このログをもう少し詳しく調べてみましょう。

00:18:36.000 -> 00:18:43.000
NSPersistentCloudKitContainerがdasdで作成したアクティビティは、特定の形式に従います。

00:18:43.000 -> 00:18:55.000
アクティビティ識別子は、NSPersistentCloudKitContainerが使用する特定のプレフィックスと、アクティビティが属するストアのストア識別子で構成されています。

00:18:55.000 -> 00:19:01.000
Dasdログには、サービスがアクティビティを実行できるかどうかを決定する方法に関する情報が含まれています。

00:19:01.000 -> 00:19:10.000
アプリケーションの作業能力に影響を与えるポリシーは、最終決定とともにログにリストされます。

00:19:10.000 -> 00:19:19.000
最後に、プロセスはCloudKitから情報をクラウド化し、私が作業しているコンテナ識別子でこれらのログをフィルタリングしたいと思います。

00:19:19.000 -> 00:19:26.000
ここでは、先に述べたエクスポートに対応するレコード変更操作を選択しました。

00:19:26.000 -> 00:19:33.000
受信デバイスに変更がインポートされると、観察すべき追加のプロセスが1つあります。

00:19:33.000 -> 00:19:41.000
プロセスapsdは、プッシュ通知を受信し、アプリケーションに転送する責任があります。

00:19:41.000 -> 00:19:48.000
これにより、NSPersistentCloudKitContainerは、エクスポートプロセスに似た一連のアクティビティを開始します。

00:19:48.000 -> 00:20:00.000
dasdにインポートを実行する時間を要求し、clouddと連携してCloudKitから更新されたすべてのオブジェクトを取得し、ローカルストアにインポートします。

00:20:00.000 -> 00:20:10.000
Apsdは、アプリケーションのプッシュ通知を受信したときにログを記録し、このログは多くの重要な詳細をキャプチャします。

00:20:10.000 -> 00:20:19.000
ログメッセージには、ここにコンテナ識別子と、プッシュ通知をトリガーしたサブスクリプション名とゾーン識別子が含まれています。

00:20:19.000 -> 00:20:29.000
これらはNSPersistentCloudKitContainerによって管理され、常にプレフィックスcom.apple.coredata.cloudkitで始まります。

00:20:29.000 -> 00:20:31.000
今、コンソールアプリは素晴らしいです。

00:20:31.000 -> 00:20:40.000
しかし、Macで開発しているときは、ターミナルのログストリームコマンドを使用して、これらのログをアプリと一緒に表示するのが好きです。

00:20:40.000 -> 00:20:46.000
次の述語ごとに1つのターミナルウィンドウまたはタブを開き、まずアプリケーションを開きます。

00:20:46.000 -> 00:20:52.000
次に、CloudKitサーバーで何が起こっているかを確認できるように、クラウドからのログ。

00:20:52.000 -> 00:20:56.000
次に、プッシュ通知ログのapsd。

00:20:56.000 -> 00:21:04.000
そして最後に、dasdは、NSPersistentCloudKitContainerが私に代わってスケジュールする活動で何が起こっているのかを見ることができます。

00:21:04.000 -> 00:21:11.000
これらの述語は、コンソールアプリでクエリを導くためにも使用できます。

00:21:11.000 -> 00:21:15.000
私たちが使用するデバイスには、非常に多くの情報があります。

00:21:15.000 -> 00:21:19.000
課題は、本当に、それを見つけて分析するために使用するツールを知ることです。

00:21:19.000 -> 00:21:27.000
インスツルメントだけで、ランタイムやメモリパフォーマンスなどの多くのトピックについて学ぶことができます。

00:21:27.000 -> 00:21:34.000
システムログは、アプリケーションが行う作業と、システムが舞台裏で何をしているかを説明するキャプチャイベントをキャプチャします。

00:21:34.000 -> 00:21:40.000
私の開発サイクルの最後の段階は、実用的なフィードバックを収集して提供することです。

00:21:40.000 -> 00:21:45.000
このセクションでは、デバイスから診断情報を収集する方法を紹介します。

00:21:45.000 -> 00:21:52.000
私たちの目標は、この情報を使用して、実行可能で特定の目標に沿ったフィードバックを生成することです。

00:21:52.000 -> 00:21:59.000
これらのテクニックは、所有しているデバイスであろうと顧客のデバイスであろうと、あらゆるデバイスからフィードバックを収集するのに役立ちます。

00:21:59.000 -> 00:22:04.000
デバイスから診断情報を収集するには3つのステップがあります。

00:22:04.000 -> 00:22:13.000
まず、問題を特定し、効果的にトリアージするために使用できるログを可能にするCloudKitロギングプロファイルをインストールする必要があります。

00:22:13.000 -> 00:22:17.000
次に、影響を受けるデバイスからsysdiagnoseを収集します。

00:22:17.000 -> 00:22:25.000
そして最後に、デバイスに物理的にアクセスできる場合は、Xcodeから永続的なストアファイルを収集することもできます。

00:22:25.000 -> 00:22:31.000
ロギングプロファイルをインストールするには、開発者ポータルのプロファイルとログページにアクセスするだけです。

00:22:31.000 -> 00:22:36.000
CloudKitプロファイルを検索し、プロファイルリンクをタップしてダウンロードできます。

00:22:36.000 -> 00:22:41.000
一部のデバイスでは、プロファイルをインストールするための通知が表示されます。

00:22:41.000 -> 00:22:47.000
ただし、ここiOSでは、設定アプリから手動でインストールする必要があります。

00:22:47.000 -> 00:22:52.000
設定では、プロファイルダウンロードセルをタップするためにナビゲートできます。

00:22:52.000 -> 00:22:56.000
その後、ダウンロードしたプロファイルをタップしてインストールできます。

00:22:56.000 -> 00:23:00.000
手順に従ってインストールを完了してください。

00:23:00.000 -> 00:23:09.000
プロファイルがインストールされた後、デバイスを再起動することができ、有効になります。

00:23:09.000 -> 00:23:16.000
デバイスが再起動したら、キャプチャしたい動作を再現し、sysdiagnoseを取ることができます。

00:23:16.000 -> 00:23:21.000
Sysdiagnoseの取得は、特別な一連のボタンであるキーコードを使用して行われます。

00:23:21.000 -> 00:23:25.000
これらは、プロフィールの手順ページに記載されています。

00:23:25.000 -> 00:23:33.000
iPhoneの場合、音量ボタンとサイドボタンを数秒間押し続けてから放すことを知っています。

00:23:33.000 -> 00:23:37.000
しばらくすると、sysdiagnoseが設定で利用可能になります。

00:23:37.000 -> 00:23:43.000
それを見つけるための指示は、プロファイルの指示ファイルに含まれています。

00:23:43.000 -> 00:23:57.000
[設定] で、[プライバシーとセキュリティ]、[分析と改善] に移動し、[分析データ] を選択し、sysdiagnose が見つかるまでログをスクロールします。

00:23:57.000 -> 00:24:04.000
Sysdiagnoseをタップしてから[共有]ボタンをタップすると、いくつかの共有方法を選択できます。

00:24:04.000 -> 00:24:08.000
例えば、私は分析のためにそれらを私のMacにAirDropするのが好きです。

00:24:08.000 -> 00:24:14.000
最後に、可能であれば、デバイスオーガナイザーを使用してXcodeからストアファイルを収集できます。

00:24:14.000 -> 00:24:30.000
インストールされたアプリリストのサンプルアプリケーションをクリックし、開示ボタンをクリックし、ダウンロードコンテナを選択し、ダウンロードディレクトリに保存することで、このiPhoneからファイルを収集できます。

00:24:30.000 -> 00:24:36.000
そのすべてが完了すると、システムログとストアファイルの両方が分析可能になりました。

00:24:36.000 -> 00:24:45.000
ログストリームコマンドについてはすでに話しましたが、sysdiagnoseを使用すると、log showコマンドを使用してsysdiagnoseからログを印刷できます。

00:24:45.000 -> 00:24:51.000
ここでは、先ほど話したapsdログの述語をコピーしました。

00:24:51.000 -> 00:24:56.000
Log show コマンドの最後の引数は、使用する logarchive です。

00:24:56.000 -> 00:25:01.000
何も指定されていない場合は、実行中のマシンのシステムログが表示されます。

00:25:01.000 -> 00:25:08.000
ここでは、sysdiagnoseから取ったログを読み取るようにsystem_logs.logarchiveを指定しました。

00:25:08.000 -> 00:25:16.000
たとえば、興味のあるイベントが発生した時間に焦点を当てるために、正確な時間範囲を指定できます。

00:25:16.000 -> 00:25:36.000
また、先ほど説明した述語の多くを組み合わせて、アプリケーションに関連するすべてのアクティビティの統一されたログを形成することもできます。ここのアプリケーションログ、ここのクラウドログ、ここのapsdログ、そして最後にここのdasdログ。

00:25:36.000 -> 00:25:46.000
この強力なコマンドは、フィードバックレポートに含めたり、チームメイトと共有したりして、誰もが分析のために特定のログセットに集中できるようにすることができます。

00:25:46.000 -> 00:26:03.000
このセッションでは、データジェネレータを使用してアプリケーションの動作を探索し、機器とシステムログを使用してアプリケーションを分析し、NSPersistentCloudKitContainerを使用するアプリケーションから実用的なフィードバックを提供または収集する方法について話しました。

00:26:03.000 -> 00:26:08.000
私はニック・ジレットです。このプレゼンテーションをお届けできて光栄です。

00:26:08.000 -> 00:26:14.000
見てくれてありがとう、アクティブでいて、リングを閉じて、素晴らしいWWDCをお過ごしください。

00:26:14.000 -> 23:59:59.000
。

