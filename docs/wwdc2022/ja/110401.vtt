WEBVTT

00:00:00.000 --> 00:00:09.000
♪インストゥルメンタルヒップホップ音楽♪

00:00:09.000 --> 00:00:14.000
こんにちは、私の名前はボリスです。「Swiftパッケージプラグインの作成」セッションへようこそ。

00:00:14.000 --> 00:00:22.000
ライブラリをソースコードとして配布するための簡単なアプローチを提供するために、Xcode 11でSwiftパッケージのサポートを導入しました。

00:00:22.000 --> 00:00:34.000
Xcode 14では、Swiftパッケージプラグインを使用して、ソースコードの生成やリリースタスクの自動化など、開発ワークフローにコンポーネントを構造化して共有するための同じ素晴らしい方法をもたらしたいと考えています。

00:00:34.000 --> 00:00:36.000
まず、講演の簡単な概要。

00:00:36.000 --> 00:00:42.000
プラグインの基本を学んだ後、デモで最初のカスタムコマンドプラグインを構築します。

00:00:42.000 --> 00:00:51.000
次に、プラグインの作成に関する詳細を見て、その後、さらなるデモでビルド内とビルド前のコマンドプラグインの両方を構築します。

00:00:51.000 --> 00:00:58.000
パッケージプラグインは、パッケージマニフェストと同様に、PackagePlugin APIを使用するSwiftコードです。

00:00:58.000 --> 00:01:06.000
プラグインは、明確に定義された拡張ポイントを通じて、XcodeまたはSwift Package Managerの機能を拡張できます。

00:01:06.000 --> 00:01:09.000
パッケージプラグインはどのように機能しますか?

00:01:09.000 --> 00:01:24.000
Xcodeはプラグインをコンパイルして実行し、利用可能な実行可能ファイルと入力ファイルに関する情報を使用して、必要に応じて実行するためにXcodeに通信するコマンドを作成できます。

00:01:24.000 --> 00:01:33.000
パッケージプラグインは、ソースコードやリソースファイルを生成するなど、ビルド前またはビルド中に実行されるカスタムビルドタスクを貢献できます。

00:01:33.000 --> 00:01:39.000
また、SwiftPMのコマンドラインインターフェイスにカスタムコマンドを追加したり、メニュー項目をXcodeに追加することもできます。

00:01:39.000 --> 00:01:53.000
プラグインの基本の詳細については、まず「Meet swift package plugins」を見ることをお勧めします。パッケージを完全に初めての場合は、WWDC19セッション「Swiftパッケージの作成」を見ることができます。

00:01:53.000 --> 00:01:58.000
最初のカスタムコマンドプラグインの構築を見てみましょう。

00:01:58.000 --> 00:02:06.000
私はSwiftオープンソースのツールサポートコアパッケージに取り組んでおり、プロジェクトへのすべての貢献者をリストするテキストファイルを追加したいと思います。

00:02:06.000 --> 00:02:12.000
また、パッケージのGit履歴から必要に応じて再生したいです。

00:02:12.000 --> 00:02:22.000
以前は、これを行うためにシェルスクリプトやメイクファイルを書いたかもしれませんが、Xcodeを離れることなくファイルを再生成できるように、カスタムコマンドプラグインを作成したいと思います。

00:02:22.000 --> 00:02:26.000
まず、プラグインのディレクトリ構造を作成する必要があります。

00:02:26.000 --> 00:02:43.000
パッケージのコンテキストメニューを開き、新しいフォルダを選択して、既存のソースとテストに似たプラグインと呼ばれるトップレベルのフォルダを作成します。

00:02:43.000 --> 00:02:57.000
次に、「GenerateContributors」と呼ばれるプラグインターゲット用の別のネストされたフォルダを作成します。

00:02:57.000 --> 00:03:12.000
そして、その中で新しいファイルを作成し、それを「plugin.swift」と呼びます。

00:03:12.000 --> 00:03:18.000
次に、そこで新しいターゲットを宣言するために、パッケージマニフェストにいくつかの変更を加える必要があります。

00:03:18.000 --> 00:03:33.000
しかし、まず、プラグインはそのバージョン以降のみ利用可能であるため、パッケージのツールバージョンを5.6にバンプする必要があります。

00:03:33.000 --> 00:03:44.000
次に、プラグインターゲットを挿入できます。

00:03:44.000 --> 00:03:49.000
ここで新しいマニフェストAPIを見てみましょう。

00:03:49.000 --> 00:03:56.000
ソースモジュールのターゲットと同様に、プラグインフォルダ内のフォルダに対応するプラグインターゲットを作成しています。

00:03:56.000 --> 00:04:03.000
フォルダの命名に関連する名前と、Xcodeのメニュー項目の両方を取得します。

00:04:03.000 --> 00:04:07.000
機能を指定するので、どのタイプの拡張ポイントを使用するかを指定します。

00:04:07.000 --> 00:04:12.000
この場合、カスタムコマンドを作成しています。

00:04:12.000 --> 00:04:24.000
インテントは、SwiftPMコマンドラインの動詞とプラグインが何をするかの説明を定義することができ、最後に、プラグインが必要とする権限を宣言することができます。

00:04:24.000 --> 00:04:30.000
この場合、パッケージのルートに新しいファイルを書きたいので、そのディレクトリに書き込む権限が必要です。

00:04:30.000 --> 00:04:39.000
理由文字列は、OS自体で権限がどのように機能するかと同様に、許可を付与するかどうかを知るために、プラグインのユーザーに表示されます。

00:04:39.000 --> 00:04:45.000
プラグインを宣言したので、実際に実装するために戻ってみましょう。

00:04:45.000 --> 00:04:49.000
プラグインはGitにシェルアウトしてコミット履歴を取得します。

00:04:49.000 --> 00:04:59.000
外部Gitコマンドの標準出力から履歴を読み取り、結果を解析し、最後にテキストファイルに書き出します。

00:04:59.000 --> 00:05:09.000
先ほど作成したプラグインソースファイルを開き、PackagePluginをインポートします。

00:05:09.000 --> 00:05:17.000
これはPackageDescriptionとよくよく合う組み込みモジュールで、プラグインの実装に使用できるAPIにアクセスできます。

00:05:17.000 --> 00:05:32.000
構造体GenerateContributorsを定義し、CommandPluginに準拠します。

00:05:32.000 --> 00:05:39.000
プロトコルを実装するための不足しているスタブを取得するために、ここで修正を受け入れます。

00:05:39.000 --> 00:05:46.000
また、プラグイン実行可能ファイルの主な機能となるため、構造体は@mainとしてマークする必要があります。

00:05:46.000 --> 00:06:00.000
performCommandはコマンドのエントリポイントであり、2つの引数を受け取ります。コンテキストは、解決されたパッケージグラフや、実行されているコンテキストに関するその他の情報、および引数にアクセスできます。

00:06:00.000 --> 00:06:06.000
カスタムコマンドはユーザーによって呼び出されるため、引数の形式で入力を提供できます。

00:06:06.000 --> 00:06:20.000
簡単なコマンドを作成しているので、現時点では実際にユーザーにオプションを提供しません。

00:06:20.000 --> 00:06:35.000
コミット履歴に関する情報を取得するためにGitにシェルアウトしたいので、プロセスAPIを使用したいので、Foundationをインポートしています。

00:06:35.000 --> 00:06:45.000
次に、プロセスインスタンスを定義し、いくつかの書式設定引数でGitログを実行するように設定します。

00:06:45.000 --> 00:06:48.000
プロセス出力をキャプチャするためのパイプを作成する必要があります。

00:06:48.000 --> 00:06:55.000
その後、私たちはそれを実行し、それが終了するまで待つことができます。

00:06:55.000 --> 00:07:05.000
プロセスが完了したら、パイプからすべてのデータを読み取り、すべてのgitログ出力を持つ文字列に変換します。

00:07:05.000 --> 00:07:22.000
文字列操作を実行して、出力を重複のないリストにトリミングし、最後に「CONTRIBUTORS.txt」というファイルに書き込むことができます。カスタムコマンドはパッケージのルートディレクトリで実行されるため、そこにファイルを保存します。

00:07:22.000 --> 00:07:32.000
さて、プロジェクトナビゲーターでパッケージを保存して右クリックすると、コンテキストメニューにコマンドの新しいエントリが表示されます。

00:07:32.000 --> 00:07:37.000
実行しよう！

00:07:37.000 --> 00:07:51.000
次のダイアログでは、プラグインの入力となるパッケージまたはターゲットと引数を選択できますが、プラグインはこれらのオプションに反応しないため、[実行] をクリックします。

00:07:51.000 --> 00:07:55.000
次に、先ほどマニフェストで定義したように、許可を求められます。

00:07:55.000 --> 00:08:08.000
プラグインを自分で書いたばかりなので、先に進んで実行することができますが、信頼できるプラグインにのみ追加の許可を与えることを確認する必要があります。

00:08:08.000 --> 00:08:14.000
実行後、CONTRIBUTORS.txtファイルがプロジェクトナビゲーターに表示されます。

00:08:14.000 --> 00:08:26.000
それでは、最初のプラグインでXcodeを拡張した後、プラグインがどのように機能し、プラグインを作成する際に何に目を向けるべきかをもう少し深く掘り下げてみましょう。

00:08:26.000 --> 00:08:31.000
パッケージプラグインは、パッケージの評価と同様に、サンドボックスで実行されます。

00:08:31.000 --> 00:08:38.000
プラグイン自身の作業ディレクトリ以外の一時的な場所へのネットワークアクセスと書き込みは禁止されています。

00:08:38.000 --> 00:08:45.000
カスタムコマンドは、先に示したように、パッケージのルートディレクトリに書き込むことをオプションで宣言できます。

00:08:45.000 --> 00:08:55.000
既存のサードパーティツールをラップする場合は、生成されたファイルが書き込まれる場所を設定するなど、サンドボックスモデルに限定する方法を検討する必要があるかもしれません。

00:08:55.000 --> 00:09:07.000
序文でさまざまな種類のプラグインについて話しましたが、問題がカスタムコマンドとビルドツールのどちらがよりよく解決されるかは明らかであるはずですが、ビルドツールプラグインの構造を見てみましょう。

00:09:07.000 --> 00:09:19.000
これらのプラグインを使用すると、ビルド中に実行する実行可能ファイルの説明を提供し、ビルド中の適切なタイミングで作業をスケジュールするのに役立つ入力と出力を指定することで、ビルドシステムを拡張できます。

00:09:19.000 --> 00:09:26.000
Xcodeプロジェクトで実行スクリプトフェーズを作成している場合は、ここでの基本に精通しているかもしれません。

00:09:26.000 --> 00:09:29.000
ビルドツールプラグインには2つの異なるタイプもあります。

00:09:29.000 --> 00:09:34.000
ここでの区別要因は、ツールに定義された出力セットがあるかどうかです。

00:09:34.000 --> 00:09:43.000
その場合は、出力が入力と比較して古くない場合、ビルドシステムによって自動的に再実行されるビルド内コマンドを作成する必要があります。

00:09:43.000 --> 00:09:49.000
明確な出力セットがない場合は、すべてのビルドの開始時に実行されるビルド前のコマンドを作成できます。

00:09:49.000 --> 00:10:02.000
このため、ビルド前のコマンドで高価な作業を行うか、ユースケースに適した結果をキャッシュするためのカスタム戦略を考え出すことに注意する必要があります。

00:10:02.000 --> 00:10:11.000
2回目のデモでは、作業しているさまざまなツール間で共有したいアイコンをカプセル化する新しいライブラリを作成したいと思います。

00:10:11.000 --> 00:10:15.000
始めて、テンプレートから新しいパッケージを作成し、「IconLibrary」と呼びましょう。

00:10:15.000 --> 00:10:20.000
そして、すでに持っているいくつかのアイコンアセットをライブラリのターゲットにドラッグします。

00:10:20.000 --> 00:10:24.000
また、基本的なSwiftUIビューとプレビューをライブラリに追加しましょう。

00:10:24.000 --> 00:10:33.000
まず、必要な最小展開目標をマニフェストに追加する必要があります。

00:10:33.000 --> 00:10:37.000
次に、その基本的なビューとプレビューを実際に追加しましょう。

00:10:37.000 --> 00:10:44.000
ここでは、以前に引き込んだ資産を使用できます。

00:10:44.000 --> 00:10:52.000
ここで文字列を扱う代わりに、これらの画像を参照するタイプセーフな方法があればいいと思います。

00:10:52.000 --> 00:10:59.000
これは、アセットカタログを見て、それらに基づいていくつかのSwiftコードを生成するビルド中のコマンドプラグインの素晴らしいユースケースのようです。

00:10:59.000 --> 00:11:06.000
Finderのアセットカタログを見て、プラグインに必要な情報を抽出する方法を見つけましょう。

00:11:06.000 --> 00:11:15.000
各画像は、アセットの名前を持つ独自の画像セットディレクトリを取得します...

00:11:15.000 --> 00:11:21.000
そして、基本的な内容を説明するJSONファイルがあります。

00:11:21.000 --> 00:11:30.000
ビルド中のコマンドは、実行する実行可能ファイルの説明と入力と出力を提供するという点で、カスタムコマンドとは少し異なります。

00:11:30.000 --> 00:11:36.000
実行可能ファイルは、システム、サードパーティのパッケージによって提供されるか、プラグイン用にオーダーメイドのものを作成することができます。

00:11:36.000 --> 00:11:40.000
私たちはここで3番目のアプローチを取りたいです。

00:11:40.000 --> 00:11:46.000
プラグインは、ビルドグラフの計算に参加するために、ビルドプロセスの開始時に実行されます。

00:11:46.000 --> 00:11:52.000
それに基づいて、実行可能ファイルはビルド実行の一部としてスケジュールされます。

00:11:52.000 --> 00:11:54.000
さて、私たちが構築している実行可能ファイルに戻ります。

00:11:54.000 --> 00:12:07.000
アセットカタログ内の各画像のコンパイル時定数を指定して、各画像の正しい文字列を記憶する代わりに、Swiftシンボルとしてオートコンプリートできるようにしたいと考えています。

00:12:07.000 --> 00:12:12.000
アセットカタログのディレクトリ内容をループして、すべての画像セットを見つけたいです。

00:12:12.000 --> 00:12:21.000
各画像セットについて、メタデータを解析して、実際に画像が含まれているかどうかを判断するため、生成されたコードを取得する必要があります。

00:12:21.000 --> 00:12:24.000
その後、コードを生成してファイルに書き込むことができます。

00:12:24.000 --> 00:12:33.000
これらのファイルをプラグインの出力として宣言したため、プラグインが適用されているターゲットのビルドに自動的に組み込まれます。

00:12:33.000 --> 00:12:40.000
それがプラグインと実行可能ファイルの間で通信する方法であるため、議論に対処する方法が必要になります。

00:12:40.000 --> 00:12:51.000
最初の引数は、処理しているアセットカタログへのパスであり、2番目の引数は、生成されたコードのプラグインによって提供されるパスになります。

00:12:51.000 --> 00:12:57.000
次に、contents.jsonファイルをデコードするためのモデルオブジェクトが必要です。

00:12:57.000 --> 00:13:02.000
私たちは、Swiftの組み込みJSONデコードを利用するためにDecodableを使用しています。

00:13:02.000 --> 00:13:13.000
私たちが興味を持っている唯一の情報は、画像のリストとそのファイル名です。これは、各ピクセル密度の画像がない可能性があるため、オプションです。

00:13:13.000 --> 00:13:17.000
ここでは、文字列を構築するだけで、単純な方法でコードを生成します。

00:13:17.000 --> 00:13:23.000
必要なフレームワーク、FoundationとSwiftUIのインポートから始めます。

00:13:23.000 --> 00:13:32.000
アセットカタログのディレクトリ内容をループして、次にJSONを解析する必要があるすべての画像セットを見つけたいです。

00:13:32.000 --> 00:13:35.000
ファイル名は入力パラメータを使用します。

00:13:35.000 --> 00:13:41.000
また、Foundationの「JSONDecoder」APIを使用してデコードします。

00:13:41.000 --> 00:13:54.000
私たちが興味を持っている主な情報は、特定の画像セットに定義された画像があるかどうかです。これは、空でないファイル名を持つ少なくとも1つの画像があるかどうかをチェックすることによって判断します。

00:13:54.000 --> 00:14:02.000
指定された画像セットに画像がある場合は、パッケージのバンドルからその画像をロードするSwiftUI画像を生成します。

00:14:02.000 --> 00:14:13.000
これを行うには、モジュールバンドルから指定された画像をロードする各画像のベース名を持つ文字列を構築します。これは、ビルドシステムがリソースを持つ各パッケージに対して作成するリソースバンドルです。

00:14:13.000 --> 00:14:21.000
引数によって与えられたように、生成されたコードをファイルに書き込むことで、実行可能ファイルの作業をまとめることができます。

00:14:21.000 --> 00:14:30.000
Xcodeに戻って実行可能ファイルを作成しましょう。

00:14:30.000 --> 00:14:40.000
私たちはそれを「AssetConstantsExec」と呼んでいます...

00:14:40.000 --> 00:14:51.000
そして、メインファイルを追加します。

00:14:51.000 --> 00:15:00.000
今、私たちはパッケージマニフェストでそれを宣言する必要があります。

00:15:00.000 --> 00:15:09.000
そして、先ほど説明したコードをメインファイルに追加できます。

00:15:09.000 --> 00:15:41.000
コードを生成できる実行可能ファイルができ、プラグインを使用してビルドシステムに持ち込むことができます。

00:15:41.000 --> 00:16:09.000
必要なターゲットを追加し、ライブラリターゲットからプラグインの使用法を追加しましょう。

00:16:09.000 --> 00:16:37.000
以前と同様に、PackagePluginライブラリをインポートして構造体を作成し、今回はBuildToolプラグインプロトコルに準拠しています。

00:16:37.000 --> 00:16:42.000
エントリポイントは似ていますが、ユーザーの引数の代わりに、ここにターゲットを与えています。

00:16:42.000 --> 00:16:55.000
これは、プラグインが適用されているターゲットであり、エントリポイントは、指定されたプラグインを使用するターゲットごとに1回呼び出されます。

00:16:55.000 --> 00:17:05.000
このプラグインは、例えばバイナリターゲットとは対照的に、実際にソースファイルを運ぶターゲットであるソースモジュールターゲットを特に気にします。

00:17:05.000 --> 00:17:11.000
ビルドコマンドの配列を構築するには、ターゲット内のすべてのxcassetバンドルをループします。

00:17:11.000 --> 00:17:19.000
ビルドログに表示される表示名の文字列を抽出し、適切な入力パスと出力パスを構築します。

00:17:19.000 --> 00:17:27.000
また、プラグインAPIを使用してここで実行可能ファイルを検索し、ビルドコマンドをまとめることもできます。

00:17:27.000 --> 00:17:29.000
これで、私たちは再びプロジェクトを構築する準備が整いました。

00:17:29.000 --> 00:17:40.000
起こっている新しいビルドステップのビルドログを見ることができます。

00:17:40.000 --> 00:17:52.000
プラグインはビルドの開始時にコンパイルされ、実行され、そこから生成されたコマンドをビルドグラフに追加します。

00:17:52.000 --> 00:17:59.000
ターゲットを見ると、新しいビルドコマンドが実行されました。

00:17:59.000 --> 00:18:05.000
そして最後に、生成されたソースファイルは、Swiftファイルのコンパイルの一部として表示されます。

00:18:05.000 --> 00:18:20.000
プレビューに戻りましょう。ここでは、文字列で型付けされた画像構造を新しい定数に置き換えることができます。

00:18:20.000 --> 00:18:28.000
また、他の画像名のオートコンプリートも取得します。

00:18:28.000 --> 00:18:39.000
これはいいですね。比較的少ないコードで、使い慣れたSwift APIを使用し、Xcodeを離れることなく、ワークフローを改善することができました。

00:18:39.000 --> 00:18:53.000
これまでのところ、私たちはすでに取り組んでいたライブラリの一部として、私たち自身の使用のためのプラグインを作ることを検討してきましたが、プラグインのもう一つの強力な属性は、ライブラリと同様に、簡単な方法でそれらを共有できることです。

00:18:53.000 --> 00:18:59.000
次のデモでは、Xcodeに同梱されているgenstringsツールを使用して、いくつかのビルド前処理を自動化したいと思います。

00:18:59.000 --> 00:19:05.000
このツールは、さらに使用するために、コードからローカライズされた文字列をローカリゼーションディレクトリに抽出します。

00:19:05.000 --> 00:19:12.000
それは一般的に役に立つように思えるので、プラグインを別のパッケージにして、独立して共有できるようにしたいと思います。

00:19:12.000 --> 00:19:20.000
パッケージのリソースとローカリゼーションについてもっと知りたい場合は、そのトピックに関するWWDC20セッションをお勧めします。

00:19:20.000 --> 00:19:28.000
一般的なローカリゼーションの詳細については、WWDC21のSwiftUIアプリのLocalizeをチェックしてください。

00:19:28.000 --> 00:19:34.000
このプラグインでは、ローカリゼーション用の出力ディレクトリを計算することから始めます。

00:19:34.000 --> 00:19:46.000
指定されたターゲット内のすべてのSwiftまたはObjective-Cソースファイルである入力ファイルを計算し、Xcodeが提供するgenstringsツールを実行するためのプレビルドコマンドを構築します。

00:19:46.000 --> 00:19:56.000
ビルド前のコマンドとビルド中のコマンドの最大の違いは、明確に定義された出力セットを宣言しないことです。つまり、これらのコマンドはすべてのビルドで実行されます。

00:19:56.000 --> 00:20:11.000
このツールは、ユーザーのソースコードからすべてのローカライズされた文字列を抽出し、それらのすべての文字列をローカリゼーションディレクトリに書き込みます。これは、ユーザーのプロジェクトの実際のローカリゼーション作業の基礎として使用できます。

00:20:11.000 --> 00:20:13.000
まず、私はすでにここで足場を作成しました。

00:20:13.000 --> 00:20:29.000
パッケージマニフェストでは、以前と同じようにターゲットを追加しますが、プラグイン製品も追加します。

00:20:29.000 --> 00:20:38.000
ライブラリ製品と同様に、これは単にプライベートではなく、パッケージのクライアントがプラグインを利用できるようにする方法です。

00:20:38.000 --> 00:20:50.000
先ほど話し合ったコードを書くことができます...

00:20:50.000 --> 00:21:00.000
プラグインを構築したので、別のサンプルパッケージでテストしたいと思います。

00:21:00.000 --> 00:21:04.000
そのために、テンプレートから新しいパッケージを作成しましょう。

00:21:04.000 --> 00:21:14.000
ローカライズされた文字列をパッケージに提供するAPIを追加します。

00:21:14.000 --> 00:21:35.000
そして、生成されたテストでその使用を追加します。

00:21:35.000 --> 00:21:40.000
予想通り、APIが「World」という文字列を返すので、テストは機能します。

00:21:40.000 --> 00:21:51.000
プラグインパッケージにパスベースの依存関係を追加しましょう...

00:21:51.000 --> 00:22:03.000
そして、ライブラリターゲットへのプラグインの使用。

00:22:03.000 --> 00:22:10.000
私たちは今、再び走ることができます...

00:22:10.000 --> 00:22:38.000
ビルドログを見ると、ビルドの開始時にプラグインが実行され、生成されたファイルがターゲットに追加されるため、リソースが最初からターゲットの一部であったかのように、リソースバンドルが構築され、リソースアクセサーが生成されます。

00:22:38.000 --> 00:22:53.000
それでは、リソースバンドルを実際に使用するようにコードを変更しましょう。

00:22:53.000 --> 00:23:10.000
最後に、コードを変更したら...

00:23:10.000 --> 00:23:26.000
そして、生成されたバンドルを覗いてみましょう...

00:23:26.000 --> 00:23:30.000
私たちはここに反映された変化を見ることができます。

00:23:30.000 --> 00:23:37.000
プラグインのテストベッドができたので、テストスイートを具体化し、最終的にプラグインパッケージを他の人と共有することができます。

00:23:37.000 --> 00:23:51.000
要約すると、プラグインを使用して開発者ツールを自動化および共有することができ、カスタムコマンドは一般的なタスクを自動化する方法を提供し、ビルドツールを使用してビルドプロセス中にファイルを生成できます。

00:23:51.000 --> 00:23:53.000
聞いてくれてありがとう!

00:23:53.000 --> 23:59:59.000
♪インストゥルメンタルヒップホップ音楽♪

