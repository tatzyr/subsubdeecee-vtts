WEBVTT

00:00:09.000 --> 00:00:15.000
サム・ラザラス：こんにちは、私の名前はサムで、SwiftUIチームのエンジニアです。

00:00:15.000 --> 00:00:26.000
SwiftUIを設計するとき、私たちは常に明確に定義された原則に基づいて決定を下すよう努めてきましたが、今日、そのうちの1つである漸進的な開示を強調します。

00:00:26.000 --> 00:00:41.000
SwiftUIチームでは、新しいAPIの思考と構築に多くの時間を費やしていますが、あなたが気づいていないかもしれないのは、再利用可能なコンポーネントや抽象化を構築した瞬間、あなたもAPIデザイナーであるということです。

00:00:41.000 --> 00:00:57.000
この講演では、設計プロセスのカーテンをはがし、漸進的な開示について学んだことを共有したかったので、次回再利用可能なコンポーネントまたは抽象化を構築するときは、ツールベルトに新しいツールがあります。

00:00:57.000 --> 00:01:02.000
進歩的な開示が実際に何を意味するのかについて話すことから始めましょう。

00:01:02.000 --> 00:01:06.000
結局のところ、それはAPIの設計に固有のものではありません!

00:01:06.000 --> 00:01:14.000
実際、最も一般的なmacOS UIの1つである保存ダイアログで実際に見ることができます。

00:01:14.000 --> 00:01:20.000
最初に保存ダイアログが表示されたら、デフォルトの場所がすでに入力されています。

00:01:20.000 --> 00:01:29.000
さらに、ダイアログには、いくつかの一般的な場所を含むドロップダウンが表示されるので、選択する可能性のある場所に簡単にアクセスできます。

00:01:29.000 --> 00:01:40.000
そして最後に、正しいパスを見つけるためにファイルシステムを閲覧する必要がある場合は、ダイアログを展開して、より複雑でより強力なUIを表示することができます。

00:01:40.000 --> 00:01:45.000
ここには、必要なときに明らかにできるさまざまな複雑さの層があります。

00:01:45.000 --> 00:01:51.000
これは、私たちがAPIで提供したいのと同じ経験です。

00:01:51.000 --> 00:02:00.000
素敵なUI体験を提供することに相当するコードは、あなたのAPIを素晴らしい気分にさせることです。

00:02:00.000 --> 00:02:07.000
開発者として、私たちはコードを書く場所、つまり宣言サイトの観点からコードを見ることに慣れています。

00:02:07.000 --> 00:02:19.000
しかし、コードを素晴らしい気分にさせるには、コードが実際に使用される場所、またはコールサイトと呼ぶものなど、別の視点から見る必要があります。

00:02:19.000 --> 00:02:28.000
したがって、プログレッシブ開示は、コールサイトの複雑さがユースケースの複雑さとともに増大するようにAPIを設計しています。

00:02:28.000 --> 00:02:37.000
理想的なAPIは、シンプルで親しみやすいだけでなく、強力なユースケースにも対応できます。

00:02:37.000 --> 00:02:40.000
これは開発者にとって本当の利点があります。

00:02:40.000 --> 00:02:49.000
まず、最初のビルドと実行までの時間を最小限に抑え、APIをすばやく使用できるようにします。

00:02:49.000 --> 00:02:59.000
また、コードの学習曲線を下げ、すべてのユースケースに関連しない概念によってAPIが行き詰まるのを防ぎます。

00:02:59.000 --> 00:03:02.000
最後に、それはタイトなフィードバックループを作成します。

00:03:02.000 --> 00:03:11.000
漸進的な開示を受け入れるAPIを使用すると、各ステップで作成したものを見て、少しずつ追加できます。

00:03:11.000 --> 00:03:20.000
これらすべてが一緒になって、アプリの構築は、単一の大規模な先行投資ではなく、迅速な改良のサイクルになります。

00:03:20.000 --> 00:03:28.000
したがって、漸進的な開示は有用な指針ですが、その原則を受け入れるように特定のAPIをどのように設計できますか?

00:03:28.000 --> 00:03:34.000
SwiftUIチームでは、一般的なユースケースを検討することから始めます。

00:03:34.000 --> 00:03:41.000
機能を徐々に開示するためには、単純なケースがどうあるべきかを特定する必要があります。

00:03:41.000 --> 00:03:49.000
また、インテリジェントなデフォルトを提供するよう努めているため、これらの一般的なケースでは、必要なもののみを指定できます。

00:03:49.000 --> 00:03:56.000
次に、コールサイトを最適化し、コールサイトのすべてのキャラクターに目的があることを確認することを目指しています。

00:03:56.000 --> 00:04:04.000
そして最後に、可能性を列挙するのではなく、ピースを構成するようにAPIを設計します。

00:04:04.000 --> 00:04:12.000
すぐに飛び込んで、一般的なユースケースをどのように考慮するかから始めて、SwiftUIのいくつかの例を見てみましょう。

00:04:12.000 --> 00:04:18.000
SwiftUIがこれを特にうまくやっている場所の1つは、ラベルです。

00:04:18.000 --> 00:04:24.000
たとえば、ボタンを作成するときは、ボタンのラベルを提供する必要があります。

00:04:24.000 --> 00:04:33.000
ほとんどの場合、そのラベルはボタンの目的を説明するテキストであり、SwiftUIはそれを綴る簡潔な方法を提供します。

00:04:33.000 --> 00:04:38.000
しかし、ボタンをさらにカスタマイズしたい場合、SwiftUIは別のオーバーロードを提供します。

00:04:38.000 --> 00:04:41.000
これは、ラベルとして任意のビューを取ります。

00:04:41.000 --> 00:04:47.000
これにより、このシンプルなコントロールから複雑な機能を構築できます。

00:04:47.000 --> 00:04:56.000
しかし、このAPIは一般的なユースケースを慎重に検討しているため、99%の確率で、シンプルなバージョンだけが必要です。

00:04:56.000 --> 00:05:00.000
このラベルパターンは、SwiftUIのどこにでも表示されます。

00:05:00.000 --> 00:05:04.000
そして、私がどこでも言うとき、私は本当にそれを意味します。

00:05:04.000 --> 00:05:10.000
したがって、一般的なユースケースを考慮することは、フレームワーク全体で行うことです。

00:05:10.000 --> 00:05:14.000
次に、インテリジェントなデフォルトを提供することを見てみましょう。

00:05:14.000 --> 00:05:22.000
一般的なユースケースを合理化するために、明示的に指定していないすべてのものにインテリジェントなデフォルトを提供する必要があります。

00:05:22.000 --> 00:05:30.000
そして、SwiftUI: Textのすべてで最も一般的に使用されているAPIの1つよりも良い例はありません。

00:05:30.000 --> 00:05:42.000
テキストはインテリジェントなデフォルトの素晴らしい例であり、指定する必要がないすべてについて考えずに、おそらくこのようなコードを何百回も書いたことがあるでしょう。

00:05:42.000 --> 00:05:50.000
このコードだけで、SwiftUIは環境ロケールでアプリバンドル内のローカライズされた文字列を検索することで、テキストをローカライズします。

00:05:50.000 --> 00:05:56.000
現在の配色に自動的に適応し、箱から出してすぐにダークモードをサポートします。

00:05:56.000 --> 00:06:04.000
また、現在のアクセシビリティの動的タイプサイズに応じて、テキストを自動的に拡大または縮小します。

00:06:04.000 --> 00:06:11.000
私たちは以前にこれらの行動について話しましたが、テキストはそれよりも舞台裏でさらに多くのことをしています。

00:06:11.000 --> 00:06:23.000
たとえば、2つのテキストをスタックに並べて配置すると、テキスト間のスペースは、現在のコンテキストのテキストの正しい行間隔に自動的に調整されます。

00:06:23.000 --> 00:06:34.000
その動作はすべて手動で指定できますが、SwiftUIのインテリジェントなデフォルトは、ユースケースに関連しない場合、コールサイトに表示されないことを意味します。

00:06:34.000 --> 00:06:43.000
テキストは、最も単純なケースが非常に最小限であるAPIの例ですが、インテリジェントなデフォルトはあらゆる種類のコールサイトに適用されます。

00:06:43.000 --> 00:06:45.000
例えば、ツールバーを考えてみましょう。

00:06:45.000 --> 00:06:49.000
ここには、たくさんのボタンがあるツールバーがあります。

00:06:49.000 --> 00:06:57.000
位置を明示的に指定することなく、ツールバーボタンはプラットフォームの慣習に従って配置されます。

00:06:57.000 --> 00:07:07.000
macOSでは、ツールバーの最上端に表示されますが、iOSでは、後端からナビゲーションバーに表示されます。

00:07:07.000 --> 00:07:14.000
そして最後に、watchOSでは、ナビゲーションバーの下に固定された最初の項目のみが表示されます。

00:07:14.000 --> 00:07:25.000
これは大多数のケースでうまく機能しますが、より多くの制御が必要な場合は、アイテムの配置を明示的に指定するための追加のAPIを提供します。

00:07:25.000 --> 00:07:33.000
繰り返しますが、必要に応じてカスタマイズはありますが、インテリジェントなデフォルトは大部分のケースを処理します。

00:07:33.000 --> 00:07:46.000
一般的なユースケースを考慮し、インテリジェントなデフォルトを提供することは、いくつかの本当に素晴らしい経験を生み出しますが、これらのAPIを使用することが不格好な、または洗練されていないと感じる場合、それは全体の効果を台無しにする可能性があります。

00:07:46.000 --> 00:07:50.000
これにより、通話サイトを最適化するという最後の戦略につながります。

00:07:50.000 --> 00:07:55.000
そのために、別のAPIを見てみましょう:テーブル。

00:07:55.000 --> 00:08:00.000
マルチカラムテーブルは、非常に機能豊富なコントロールです。

00:08:00.000 --> 00:08:03.000
設定することがたくさんあり、機能がたくさんあります。

00:08:03.000 --> 00:08:09.000
しかし、大多数のテーブルははるかにシンプルで、これらすべての機能を必要としません。

00:08:09.000 --> 00:08:16.000
私たちは、テーブルがこのより複雑な動作を可能にすることを望んでおり、その最も冗長な形式では、それを持っています。

00:08:16.000 --> 00:08:25.000
ソート、豊富なセルコンテンツを持つ複数の列、セクション化された行などをサポートしています。

00:08:25.000 --> 00:08:38.000
しかし、より一般的なケースでも素晴らしい体験を提供したいので、このシンプルなテーブルに完全に指定されたコードを見て、コールサイトを最適化する方法を見てみましょう。

00:08:38.000 --> 00:08:42.000
まず、この例を分解しましょう。

00:08:42.000 --> 00:08:48.000
テーブルは、各行のデータの生成方法を指定することから始まります。

00:08:48.000 --> 00:08:56.000
ここでは、現在読んでいる各本を反復し、それらの本ごとにテーブル行を作成しています。

00:08:56.000 --> 00:09:01.000
次に、各行のデータから列に入力する方法を指定します。

00:09:01.000 --> 00:09:08.000
ここでは、タイトル列と著者列を作成します。

00:09:08.000 --> 00:09:18.000
また、ユーザーがテーブル列ヘッダーをクリックしたときにテーブルがソートを変更できるようにするには、ソート順へのバインディングも必要です。

00:09:18.000 --> 00:09:25.000
最後に、ソート順序が変更されるたびにテーブルのデータを再ソートするコードを追加しました。

00:09:25.000 --> 00:09:33.000
それは多くの情報なので、本当に漸進的な開示を受け入れるためにこのコールサイトを最適化する方法を見てみましょう。

00:09:33.000 --> 00:09:38.000
すぐに目立つ一般的なユースケースの1つは、行に関係しています。

00:09:38.000 --> 00:09:48.000
ほとんどの場合、行フィールドは、この例のように見えます。コレクション上のForEachは、各項目のテーブル行を提供します。

00:09:48.000 --> 00:09:56.000
開発者はこれらすべてを自分でループする必要がないため、SwiftUIはボンネットの下でこれを処理する利便性を提供します。

00:09:56.000 --> 00:10:10.000
コレクションをテーブルに直接渡すことで、ForEachの動作を舞台裏で提供し、コールサイトを大幅に簡素化できますが、これはさらに簡素化できます。

00:10:10.000 --> 00:10:12.000
他の一般的なユースケースは何ですか?

00:10:12.000 --> 00:10:20.000
さて、ほとんどの場合、表に表示したい値の1つが文字列の場合、テキストを使用して列に表示します。

00:10:20.000 --> 00:10:25.000
このケースでは、コールサイトも最適化します。

00:10:25.000 --> 00:10:32.000
値のキーパスが文字列を指すたびに、TableColumnに関連付けられたビューを省略できるようにします。

00:10:32.000 --> 00:10:38.000
それはもう一つの重要な単純化ですが、最適化することはまだあります!

00:10:38.000 --> 00:10:46.000
コールサイトには、すべてのテーブルが関心を持つ必要のない情報があります。ソート順です。

00:10:46.000 --> 00:10:50.000
テーブルの最も簡単なユースケースは、並べ替えをまったく気にしません!

00:10:50.000 --> 00:10:55.000
そのため、ソートにも関係のないテーブルのバージョンを提供します。

00:10:55.000 --> 00:10:59.000
そして、これは私たちの最終的な反復に私たちをもたらします。はるかにシンプル!

00:10:59.000 --> 00:11:14.000
このコールサイトのすべてのキャラクターは明確な目的を果たしており、すべてのステップで2つの重要な質問を自問することでここにたどり着きました。「利便性を構築すべき最も一般的なユースケースは何ですか？」

00:11:14.000 --> 00:11:19.000
そして「常に必要とされるべき重要な情報は何ですか?」

00:11:19.000 --> 00:11:26.000
これらのガイドの質問は、通話サイトを最適化するのに最適ですが、慎重に適用する必要があります。

00:11:26.000 --> 00:11:31.000
APIへの影響を考えなければ、彼らはあなたを迷わせる可能性があります。

00:11:31.000 --> 00:11:37.000
それは私たちの最終的な戦略に私たちをもたらします:作成し、列挙しないでください。

00:11:37.000 --> 00:11:46.000
そして、これを説明するために、SwiftUIのレイアウトシステムの一部の設計について話しましょう:スタック、特にHStack。

00:11:46.000 --> 00:11:52.000
まず、HStackにとって重要な情報が何であるかを考えてみましょう。

00:11:52.000 --> 00:12:01.000
さて、どのコンテンツがスタックにあるべきか、そしてそのコンテンツがスタック内にどのように配置されるべきかを知る必要があります。

00:12:01.000 --> 00:12:08.000
HStackのコンテンツを指定するビュービルダーがすでにあるので、配置に焦点を当てましょう。

00:12:08.000 --> 00:12:15.000
強調したガイドの質問に戻ると、Hstackで要素を配置する際の最も一般的なユースケースは何ですか?

00:12:15.000 --> 00:12:25.000
さて、時々、私は最先端から始めて、次々と箱を示すこのようなスタックを見せたいです。

00:12:25.000 --> 00:12:28.000
もう1つの一般的なケースは、要素を中央に配置したいということです。

00:12:28.000 --> 00:12:34.000
そして最後に、要素を後縁に合わせたいと思うかもしれません。

00:12:34.000 --> 00:12:45.000
VStackはすでにこれと同様のケースであるアライメントを持つAPIを持っているので、スタック内の要素の配置に同様の列挙型を作成するのは魅力的に思えるかもしれません。

00:12:45.000 --> 00:12:48.000
これは、私たちが言及したすべてのケースをサポートしています!

00:12:48.000 --> 00:12:57.000
HStackの配置を指定することで、どちらが欲しいかに応じて、先頭、末尾、または中央の配置を選択できます。

00:12:57.000 --> 00:13:08.000
しかし、今、要素を均等に間隔をあけたり、要素の間に間隔だけを置いたり、最後の要素の前にスペースだけを置いたりしたい場合はどうなりますか?

00:13:08.000 --> 00:13:10.000
これは本当にめちゃくちゃになってきています!

00:13:10.000 --> 00:13:13.000
しかし、もっと重要なのは、それは持続不可能です。

00:13:13.000 --> 00:13:20.000
私たちが望むすべての行動に列挙ケースを追加する必要がありますが、すべての有用なケースを考えないかもしれません!

00:13:20.000 --> 00:13:35.000
利便性を提供するのではなく、一般的なケースを列挙していることに気づいたら、APIを分解して、ソリューションを構築できる構成可能な部分に分解してみてください。作成、列挙しないでください。

00:13:35.000 --> 00:13:51.000
スタックの場合、SwiftUIはスペーサーを提供し、スタックの要素で構成して、列挙したすべてのスペーシングスキームを構築できます。

00:13:51.000 --> 00:14:07.000
ここでの漸進的な開示に最適なエクスペリエンスを設計することは、コールサイトを最小限に抑えるだけでなく、そのコールサイトがすべてのケースを処理するためにどのように拡張すべきかについて慎重に考える必要がありました。この場合、構成を通じて。

00:14:07.000 --> 00:14:15.000
自分でコードを書くときは、作成したコンポーネントに同じ種類の慎重な考慮を適用すると非常に役立ちます。

00:14:15.000 --> 00:14:20.000
そして要約すると、それは一般的なユースケースを考慮することから始まります。

00:14:20.000 --> 00:14:27.000
プログレッシブディスクロージャーを適用することで、あなたが書いたコードは、最も一般的なユースケースで時間を節約できます。

00:14:27.000 --> 00:14:33.000
インテリジェントなデフォルトは、これらの一般的なケースで詳細について考える必要がないことを意味します。

00:14:33.000 --> 00:14:38.000
構築したコールサイトを最適化することで、すばやく反復できます。

00:14:38.000 --> 00:14:47.000
そして最後に、コンポジションを利用することで、すべてのユースケースに対応するのに十分な柔軟性を備えたAPIを構築できます。

00:14:47.000 --> 00:14:58.000
そして、あなたはAPIデザイナーなので、他の誰かのために設計されているか、あなたが使うためだけに設計されているかにかかわらず、毎日書くコードにこれらのレッスンを適用することができます。

00:14:58.000 --> 00:15:00.000
ご覧いただきありがとうございます。

00:15:00.000 --> 23:59:59.000
。

