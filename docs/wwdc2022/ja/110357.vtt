WEBVTT

00:00:00.000 -> 00:00:13.000
- こんにちは、私はMichael Ilsemanで、Swift標準ライブラリチームのエンジニアです。

00:00:13.000 -> 00:00:17.000
私と会って、SwiftでRegexを知ってください。

00:00:17.000 -> 00:00:21.000
Swift Regexにはたくさんのことがあり、私たちはそれが提供しなければならないすべてのものを味わうでしょう。

00:00:21.000 -> 00:00:30.000
不正取引を分析するツールで、一部の金融調査員と協力している開発者だとしましょう。

00:00:30.000 -> 00:00:36.000
さて、この重要なタスクでは、よく構造化されたデータを処理することだと思うでしょう。

00:00:36.000 -> 00:00:40.000
しかし、代わりに、私たちはたくさんの文字列を持っています。

00:00:40.000 -> 00:00:53.000
ここでは、最初のフィールドには取引の種類、2番目のフィールドには取引日、3番目のフィールドには個人または機関、4番目の最後のフィールドには米ドルの金額があります。

00:00:53.000 -> 00:01:06.000
フィールドは、関係者が覚えておくことができない非常に重要な技術的な理由から、2つ以上のスペースまたはタブで区切られています。

00:01:06.000 -> 00:01:11.000
そして、はい、その日付フィールドは完全に曖昧です。

00:01:11.000 -> 00:01:16.000
私たちはそれが月/日/年であることを願って、何が起こるかを見るつもりです。

00:01:16.000 -> 00:01:26.000
これらのトランザクションの処理には文字列の処理が含まれ、文字列はコレクションであり、汎用コレクションアルゴリズムにアクセスできます。

00:01:26.000 -> 00:01:34.000
これらのアルゴリズムには、基本的に要素を操作するものとインデックスを操作するアルゴリズムの2種類があります。

00:01:34.000 -> 00:01:45.000
トランザクションフィールドを分割して要素ベースのアルゴリズムを使用しようとすることができますが、フィールドの区切り文字がタブまたは2つ以上のスペースであるため、これは困難になります。

00:01:45.000 -> 00:01:48.000
空白を分割するだけでは、それをカットすることはできません。

00:01:48.000 -> 00:01:55.000
もう1つのアプローチは、低レベルのインデックス操作コードにドロップダウンすることです。

00:01:55.000 -> 00:02:01.000
しかし、正しく行うことは難しく、自分が何をしているのかを知っていても、まだ多くのコードが必要です。

00:02:01.000 -> 00:02:02.000
スプリットに戻りましょう。

00:02:02.000 -> 00:02:09.000
このアプローチが機能しない理由は、要素ベースであり、フィールドセパレータはより複雑なパターンであるためです。

00:02:09.000 -> 00:02:15.000
多種多様な言語で見られる解決策は、正規表現を書くことです。

00:02:15.000 -> 00:02:21.000
正規表現は、正規言語を定義する形式言語理論から生まれました。

00:02:21.000 -> 00:02:28.000
彼らは、エディタやコマンドラインツールでの検索、およびコンパイラの語彙分析のための実用的なアプリケーションに入りました。

00:02:28.000 -> 00:02:40.000
これらのアプリケーションは、入力、制御、直接実行の一部を抽出し、表現力を追加する必要があるため、理論的なルーツを超えて正規表現を取ります。

00:02:40.000 -> 00:02:42.000
そして、スウィフトは彼らをさらに進めています。

00:02:42.000 -> 00:02:45.000
私たちはこれをデリバティブ正規表現と呼んでいます。

00:02:45.000 -> 00:02:52.000
正規表現は、その出力に対する構造体ジェネリックであり、キャプチャを含むそれを適用した結果です。

00:02:52.000 -> 00:02:58.000
スラッシュ区切り文字の間に正規表現構文を含むリテラルを使用して作成できます。

00:02:58.000 -> 00:03:07.000
Swiftの正規表現構文は、Perl、Python、Ruby、Java、NSRegularExpression、その他多くのものと互換性があります。

00:03:07.000 -> 00:03:10.000
この正規表現は1つ以上の数字と一致します。

00:03:10.000 -> 00:03:20.000
コンパイラは正規表現構文を知っているので、構文の強調表示、コンパイル時のエラー、さらには強く型付けされたキャプチャを取得し、後で会う予定です。

00:03:20.000 -> 00:03:25.000
正規表現は、同じ正規表現構文を含む文字列から実行時に作成できます。

00:03:25.000 -> 00:03:29.000
これは、エディタやコマンドラインツールの検索フィールドに便利です。

00:03:29.000 -> 00:03:34.000
入力に無効な構文が含まれている場合、実行時にエラーがスローされます。

00:03:34.000 -> 00:03:44.000
キャプチャの種類と数は実行時までわからないため、出力タイプは実存的なAnyRegexOutputです。

00:03:44.000 -> 00:03:53.000
そして、同じ正規表現は、より冗長ではありますが、宣言的でよく構造化された正規表現ビルダーを使用して書くことができます。

00:03:53.000 -> 00:03:57.000
以前の分割アプローチを、正規表現リテラルを使用するように適応させましょう。

00:03:57.000 -> 00:04:03.000
最初の部分は、任意の空白文字の2つ以上の出現と一致します。

00:04:03.000 -> 00:04:07.000
2番目の部分は、単一の水平タブと一致します。

00:04:07.000 -> 00:04:17.000
そして、パイプ文字は選択肢の間の選択を示し、2つ以上のスペースまたは単一のタブのフィールドセパレータを与えます。

00:04:17.000 -> 00:04:29.000
フィールドが分割されたので、文明自体に貢献し、そのフィールドの区切り文字を1つのタブに正規化して、それで終わりましょう。

00:04:29.000 -> 00:04:40.000
分割後の結果に「join」を呼び出すことができますが、そのためのより良いアルゴリズムがあります。「replacecing」を使用すると、すべてのフィールドセパレータを1つのタブに置き換えることができます。

00:04:40.000 -> 00:04:46.000
だから私たちは外に出て、耳を傾ける人に私たちの明らかに優れたアプローチを伝道します。

00:04:46.000 -> 00:04:50.000
養子縁組は...遅いが有望だ。

00:04:50.000 -> 00:04:55.000
正規表現に精通している場合は、それらの複雑な評判も知っているかもしれません。

00:04:55.000 -> 00:05:00.000
古いことわざにあるように、「私は問題を抱えていたので、正規表現を書きました。

00:05:00.000 -> 00:05:02.000
今、私は2つの問題を抱えています。

00:05:02.000 -> 00:05:05.000
しかし、スウィフト正規表現は違います。

00:05:05.000 -> 00:05:09.000
スウィフトは4つの重要な分野で芸術を進歩させる。

00:05:09.000 -> 00:05:15.000
正規表現構文は簡潔で表現力豊かですが、簡潔で読みにくくなることがあります。

00:05:15.000 -> 00:05:20.000
そして、新しい機能はますます不可解な構文を使用する必要があります。

00:05:20.000 -> 00:05:26.000
Swift正規表現は、Regexビルダーを通じてソースコードを構造化および整理する方法で構造化および整理できます。

00:05:26.000 -> 00:05:36.000
リテラルは簡潔で、ビルダーは構造を与え、リテラルはビルダー内でその完璧なバランスを見つけるために使用できます。

00:05:36.000 -> 00:05:45.000
データのテキスト表現ははるかに複雑になり、それらを正しく処理するには標準に準拠したパーサーが必要です。

00:05:45.000 -> 00:05:52.000
Swift正規表現を使用すると、工業強度のパーサーを正規表現の個々のコンポーネントとして織り交ぜることができます。

00:05:52.000 -> 00:05:58.000
これはライブラリ拡張可能な方法で行われ、任意のパーサーが参加できることを意味します。

00:05:58.000 -> 00:06:10.000
適用された正規表現の歴史の多くは、コンピュータシステム全体が単一の言語とエンコーディング、特にASCIIのみをサポートする世界で起こりました。

00:06:10.000 -> 00:06:13.000
しかし、現代世界はUnicodeです。

00:06:13.000 -> 00:06:18.000
Swift regexは、表現力を損なうことなくUnicodeを行います。

00:06:18.000 -> 00:06:25.000
そして最後に、正規表現の力は、徹底的に探求しなければならない幅広い検索スペースを開くことができます。

00:06:25.000 -> 00:06:28.000
これにより、彼らの実行を推論するのが難しくなります。

00:06:28.000 -> 00:06:35.000
一部の言語はコントロールをサポートしていますが、不可解な構文の背後にあるため、あいまいな傾向があります。

00:06:35.000 -> 00:06:41.000
Swift regexは予測可能な実行を提供し、表面制御を目立つようにします。

00:06:41.000 -> 00:06:52.000
私たちが取り組んできた財務諸表に戻り、Swiftでの文字列処理に対する宣言的アプローチであるRegexビルダーを使用して各トランザクションを完全に解析しましょう。

00:06:52.000 -> 00:06:56.000
始めるためにRegexBuilderモジュールをインポートします。

00:06:56.000 -> 00:07:01.000
先ほど定義したフィールドセパレータ正規表現を再利用することができます。

00:07:01.000 -> 00:07:05.000
最初のフィールドは簡単です。クレジットまたはデビットのいずれかです。

00:07:05.000 -> 00:07:10.000
すでに見た正規表現のリテラル構文を使って書くことができます。

00:07:10.000 -> 00:07:13.000
その後、フィールドセパレータと日付が来ます。

00:07:13.000 -> 00:07:16.000
日付を手で解析するのは悪い考えです。

00:07:16.000 -> 00:07:25.000
Foundationには、日付、数値、URLなどのタイプの非常に優れたパーサーがあり、Regex Builderで直接使用できます。

00:07:25.000 -> 00:07:30.000
私たちは、著者の意図に対する最善の推測である明示的なロケールを提供します。

00:07:30.000 -> 00:07:35.000
システムの現在のロケールを暗黙的に使用するのではなく、これを行います。

00:07:35.000 -> 00:07:43.000
後でいつでも変更でき、コードで_explicit_を仮定したので、簡単に行うことができます。

00:07:43.000 -> 00:07:48.000
3番目のフィールドは「何でも」になる可能性があるので、「何かの1つ以上」と書くのは魅力的です。

00:07:48.000 -> 00:07:58.000
そして、それは私たちに正しい答えを与えるでしょうが、それはその後に来る他のものを一致させることから始まるので、それは最初に多くの不必要な作業を行います。

00:07:58.000 -> 00:08:02.000
正規表現は一度に1文字ずつバックアップし、残りのパターンを試します。

00:08:02.000 -> 00:08:08.000
終端フィールドセパレータが表示されたら、正規表現に停止するように指示したい。

00:08:08.000 -> 00:08:10.000
これを達成する方法はたくさんあります。 かなりの数あります。

00:08:10.000 -> 00:08:20.000
これを行う良い方法の1つは、実際に消費せずに入力の次の部分を覗くNegativeLookaheadを使用することです。

00:08:20.000 -> 00:08:26.000
ここでは、入力を覗いて、文字を一致させる前にフィールドセパレータが出てこないことを確認します。

00:08:26.000 -> 00:08:35.000
NegativeLookaheadは、Regexがコンポーネントとどのように一致するかを正確に制御できるツールファミリーの1つです。

00:08:35.000 -> 00:08:42.000
最後に、今回は通貨のために、再び財団のパーサーの1つを使用して、金額を一致させます。

00:08:42.000 -> 00:08:51.000
コンマは千の区切り文字であり、ピリオドは小数点の区切り文字であると仮定しており、この仮定を明確にしています。

00:08:51.000 -> 00:08:55.000
トランザクション台帳から行を解析できる正規表現を構築しました。

00:08:55.000 -> 00:09:01.000
私たちは線を認識したいだけではありません。このデータの一部を抽出したい。

00:09:01.000 -> 00:09:08.000
これを行うには、後で処理するために入力の一部を抽出するキャプチャを使用します。

00:09:08.000 -> 00:09:17.000
慣習的に、「0番目の」キャプチャは、正規表現全体が一致した入力の一部であり、各明示的なキャプチャが続きます。

00:09:17.000 -> 00:09:23.000
トランザクションの種類は、入力のスライスである部分文字列としてキャプチャされます。

00:09:23.000 -> 00:09:31.000
日付については、テキストを後処理することなく、解析された強く型付けされた値を実際にキャプチャします。

00:09:31.000 -> 00:09:41.000
個人または機関は再び入力の一部としてキャプチャされ、10進キャプチャは別の強く型付けされた値です。

00:09:41.000 -> 00:09:47.000
それを使用するには、一致結果から日付と小数点の値を抽出し、研究者はここからそれを取ります。

00:09:47.000 -> 00:09:56.000
この時点で、構造化されたクエリのような明らかな利点のために、データを実際のデータベースにダンプすることをお勧めします。

00:09:56.000 -> 00:09:58.000
彼らは...異なる意見を持っています。

00:09:58.000 -> 00:10:01.000
彼らはすべてをひもとして保ちたいと思っている。

00:10:01.000 -> 00:10:07.000
Swift Regexをさらに見ることができるので、この講演には良いニュースです。

00:10:07.000 -> 00:10:11.000
突然うまくいかないまで、すべてがうまくいっています。

00:10:11.000 -> 00:10:20.000
取引テキストの日付順序は、私たちが皆に完全に曖昧であると言ったが、実際には曖昧であることを知りました。

00:10:20.000 -> 00:10:28.000
それは必ずしも同じではなく、主要な理論は、それが取引で使用される通貨に依存するということです。

00:10:28.000 -> 00:10:30.000
もちろんそうだから。

00:10:30.000 -> 00:10:40.000
これは、米ドルが月/日/年であり、英ポンドが日/月/年であることを意味します。

00:10:40.000 -> 00:10:44.000
では、これを曖昧にするために、sedのようなスクリプトを書きましょう。

00:10:44.000 -> 00:10:48.000
正規表現では、拡張区切り文字を使用します。

00:10:48.000 -> 00:10:53.000
これにより、私たちはそれらから逃れることなく、内部にスラッシュを持つことができます。

00:10:53.000 -> 00:11:05.000
これにより、空白が無視される拡張構文モードにもアクセスできます。つまり、通常のコードと同じように、読みやすさのために空白を使用できます。

00:11:05.000 -> 00:11:11.000
Regexの出力にタプルラベルとして表示される名前付きキャプチャを使用しました。

00:11:11.000 -> 00:11:15.000
また、Unicodeプロパティを使用して通貨記号を認識します。

00:11:15.000 -> 00:11:23.000
これにより、正規表現の適応性が高くなります。アプリケーションロジックで特定のシンボルを処理します。

00:11:23.000 -> 00:11:30.000
テキストを手動でカットしてスプライスするのではなく、再びFoundationの日付パーサーを使用します。

00:11:30.000 -> 00:11:35.000
pickStrategyは通貨シンボルを受け取り、それに基づいて解析戦略を決定します。

00:11:35.000 -> 00:11:46.000
私たちの仮定はすべてコードで明示的であり、適応と進化が容易になり、ほぼ確実に必要になります。

00:11:46.000 -> 00:11:58.000
キャプチャを含む一致結果を使用して置換文字列を構築するクロージャを提供することで、検索置換アルゴリズムで正規表現とヘルパー関数を使用しましょう。

00:11:58.000 -> 00:12:02.000
キャプチャされた通貨に基づいて戦略を選択し、キャプチャされた日付を解析します。

00:12:02.000 -> 00:12:07.000
位置だけでではなく、名前でキャプチャにアクセスできます。

00:12:07.000 -> 00:12:14.000
出力については、明確な業界標準であるISO-8601を使用して新しい日付をフォーマットします。

00:12:14.000 -> 00:12:20.000
私たちのツールは、この台帳を明確なものに変換します。

00:12:20.000 -> 00:12:27.000
実際の日付パーサーとフォーマッタを使用しているため、変化する要件にはるかに適応できます。

00:12:27.000 -> 00:12:33.000
そして、Unicodeプロパティを使用して通貨記号を認識することは、私たちがはるかに速く進化するのに役立ちます。

00:12:33.000 -> 00:12:38.000
正規表現は、文字列のいくつかのモデルに対してアルゴリズムを宣言します。

00:12:38.000 -> 00:12:43.000
SwiftのStringは、Unicodeを操作するための複数のモデルを提示します。

00:12:43.000 -> 00:12:50.000
年齢のためのラブストーリーを表すこの文字列には、3つの文字が含まれています。

00:12:50.000 -> 00:12:56.000
これらの文字は、正式にはUnicode拡張書記素クラスタと呼ばれる複雑なエンティティです。

00:12:56.000 -> 00:13:02.000
1つの文字は、1つ以上のUnicodeスカラー値で構成されています。

00:13:02.000 -> 00:13:09.000
Stringは、その内容のこの下位レベルの表現にアクセスするためのUnicodeScalarViewを提供します。

00:13:09.000 -> 00:13:15.000
これにより、高度な使用だけでなく、他のシステムとの互換性が可能になります。

00:13:15.000 -> 00:13:27.000
私たちの物語の主人公である私たちの最初のキャラクターは、4つのUnicodeスカラーで構成されています：ZOMBIE、Zero Width Joiner、FEMALE SIGN、そして...

00:13:27.000 -> 00:13:35.000
この文脈では、絵文字としてレンダリングされる好みを示すVARIATION SELECTOR-16。

00:13:35.000 -> 00:13:37.000
もちろんです！

00:13:37.000 -> 00:13:41.000
これらのスカラーは、私たちが視覚的に見る単一の絵文字を生成します。

00:13:41.000 -> 00:13:47.000
文字列がメモリに保存されると、UTF-8バイトとしてエンコードされます。

00:13:47.000 -> 00:13:50.000
UTF-8ビューを使用して、これらのバイトを表示できます。

00:13:50.000 -> 00:14:03.000
UTF-8は可変幅エンコーディングです。つまり、単一のスカラーに複数のバイトが必要になる可能性があり、私たちが見たように、1つの文字に複数のスカラーが必要になる場合があります。

00:14:03.000 -> 00:14:11.000
4つのUnicodeスカラーで表される私たちの物語の主人公は、13 UTF-8バイトを使用してエンコードされています。

00:14:11.000 -> 00:14:20.000
複数のスカラーで構成されていることに加えて、同じ正確な文字が異なるスカラーのセットで表されることがあります。

00:14:20.000 -> 00:14:24.000
これは、英語以外の言語を扱うときによく出てきます。

00:14:24.000 -> 00:14:38.000
この例では、急性アクセントを持つ「e」は、単一のスカラー、急性アクセントを持つ事前に構成された「e」、またはASCII「e」とそれに続く結合急性アクセントのいずれかとして表すことができます。

00:14:38.000 -> 00:14:43.000
これらは同じ文字なので、文字列比較はtrueを返します。

00:14:43.000 -> 00:14:49.000
これは、Stringが正式にUnicode Canonical Equivalenceと呼ばれるものに従うためです。

00:14:49.000 -> 00:14:59.000
UnicodeScalarView、またはUTF-8ビューの観点から見ると、内容は異なり、これらの低レベルのビュー内で比較すると、この違いがわかります。

00:14:59.000 -> 00:15:05.000
Stringと同様に、Swift regexはデフォルトで強迫的に正しいUnicodeです。

00:15:05.000 -> 00:15:09.000
しかし、それは表現力を損なうことなくこれを行います。

00:15:09.000 -> 00:15:11.000
文字列のペアを切り替えましょう。

00:15:11.000 -> 00:15:21.000
最初の文字列では、ドット(.)で示される文字で囲まれた名前付きUnicode Scalar SPARKLING HEARTを一致させます。

00:15:21.000 -> 00:15:29.000
任意の文字クラスは、任意のSwift文字と一致します。つまり、任意のUnicode拡張書記素クラスタです。

00:15:29.000 -> 00:15:34.000
2番目の文字列では、等しい文字は等しいものとして比較されます...

00:15:34.000 -> 00:15:37.000
そして、私たちはケースを無視することができます。

00:15:37.000 -> 00:15:41.000
そして今、私たちのシンプルなラブストーリーはもっと複雑になりました。

00:15:41.000 -> 00:15:49.000
時には人生、またはこの場合は非人生には、私たちが処理する必要がある複雑さがあります。

00:15:49.000 -> 00:16:02.000
Stringと同様に、互換性またはサブグラフクラスタの精度のためにUnicodeスカラー値を自分で処理する必要がある場合は、「unicodeScalar」セマンティクスと照合することができます。

00:16:02.000 -> 00:16:09.000
Unicode Scalarレベルで一致すると、ドットは完全なSwift文字ではなく、単一のUnicode Scalar値と一致します。

00:16:09.000 -> 00:16:14.000
これは、私たちが再び友人に会えることを意味します：VARIATION-SELECTOR 16。

00:16:14.000 -> 00:16:23.000
このフレンドリーな小さなセレクターはドットで一致し、それがすべて一人でいるとき、それは空の空白としてレンダリングされるので、あなたはそれを見ることができません。

00:16:23.000 -> 00:16:26.000
とても助かります。

00:16:26.000 -> 00:16:34.000
精度と正確性で作業したので、少し違うことをして、財務に戻りましょう。

00:16:34.000 -> 00:16:40.000
調査員が戻ってきて、今回は興味深い要求があります。

00:16:40.000 -> 00:16:48.000
彼らは、事後に元帳を処理するのではなく、ワイヤからライブトランザクションを嗅ぐようにトランザクションマッチングツールを変更しました。

00:16:48.000 -> 00:16:56.000
彼らのコードを見ると、彼らは実際に合理的に良い仕事をしましたが、スケーリングの問題に直面しており、私たちの助けを必要としています。

00:16:56.000 -> 00:17:01.000
彼らが処理しているトランザクションは非常に似ていますが、わずかな違いがあります。

00:17:01.000 -> 00:17:05.000
日付の代わりに、彼らは代わりに正確なタイムスタンプを持っています。

00:17:05.000 -> 00:17:12.000
これは、明確で、明確で、衝撃的に独自の形式で表されます。

00:17:12.000 -> 00:17:19.000
彼らは前世紀に書かれた正規表現を持っていて、これに一致します。

00:17:19.000 -> 00:17:22.000
大丈夫です。

00:17:22.000 -> 00:17:26.000
次に、個人と識別コードを含む詳細フィールドがあります。

00:17:26.000 -> 00:17:33.000
入力から派生したランタイムコンパイルされた正規表現を使用して、このフィールドに対してトランザクションをフィルタリングします。

00:17:33.000 -> 00:17:41.000
これはライブであり、後でより多くのフィールドがあるので、彼らは興味のない取引を早期に保釈するのが好きです。

00:17:41.000 -> 00:17:47.000
次に、金額とチェックサムのような他のフィールドが来て、彼らは自分でうまく処理します。

00:17:47.000 -> 00:17:55.000
そしてもちろん、フィールドはまだ2つ以上のスペースまたはタブで区切られています。

00:17:55.000 -> 00:17:58.000
彼らのトランザクションマッチャーは私たちのものによく似ています。

00:17:58.000 -> 00:18:06.000
タイムスタンプには独自の正規表現があり、詳細正規表現は入力からコンパイルされ、残りのフィールドを処理します。

00:18:06.000 -> 00:18:10.000
彼らは合理的に良い仕事をした。すべてが技術的に機能します。

00:18:10.000 -> 00:18:12.000
うまくスケーリングされていないだけです。

00:18:12.000 -> 00:18:19.000
彼らは、タイムスタンプと詳細の正規表現が、フィールドよりもはるかに多くの入力と一致することが多いことに気づきます。

00:18:19.000 -> 00:18:25.000
理想的には、これらの正規表現は単一のフィールドのみを実行するように制約されます。

00:18:25.000 -> 00:18:33.000
ネガティブな先読みを使用して、プロジェクトで同様の問題を処理したので、その正規表現を引き出しましょう。

00:18:33.000 -> 00:18:43.000
「フィールド」は、フィールドセパレータに遭遇するまで、任意の文字に効率的に一致し、その正規表現を含めるために使用したいと思います。

00:18:43.000 -> 00:18:52.000
これは後処理ステップとして行うことができますが、これはライブで実行されているため、これらの正規表現がフィールドと一致しない場合は、早期に保釈したいと考えています。

00:18:52.000 -> 00:18:55.000
TryCaptureを使用してこれを行うことができます。

00:18:55.000 -> 00:19:05.000
TryCaptureは、一致したフィールドをクロージャに渡し、研究者のタイムスタンプと詳細正規表現に対してテストします。

00:19:05.000 -> 00:19:12.000
それらが一致する場合は、フィールドの値を返します。つまり、一致が成功し、フィールドがキャプチャされます。

00:19:12.000 -> 00:19:18.000
それ以外の場合は、マッチングが失敗したことを示すnilを返します。

00:19:18.000 -> 00:19:24.000
TryCaptureの閉鎖はマッチングに積極的に参加しており、これはまさに私たちが必要としているものです。

00:19:24.000 -> 00:19:27.000
そして、これで、私たちは大きなスケーリングの問題を解決しました。

00:19:27.000 -> 00:19:37.000
しかし、まだもう1つの問題があります。トランザクションマッチャーの後半で何かが失敗すると、終了に長い時間がかかることがあります。

00:19:37.000 -> 00:19:46.000
冒頭で定義したfieldSeparator正規表現は、2つ以上の空白またはタブと一致します。

00:19:46.000 -> 00:19:53.000
8つの空白文字がある場合、残りの正規表現を試す前に、それらすべてと一致します。

00:19:53.000 -> 00:20:00.000
しかし、後で正規表現が失敗した場合、バックアップされ、再試行する前に7つの空白文字のみが一致します。

00:20:00.000 -> 00:20:10.000
そして、それが失敗した場合、それは6つの空白文字だけに一致します。

00:20:10.000 -> 00:20:15.000
すべての選択肢を試した後にのみ、マッチングは失敗します。

00:20:15.000 -> 00:20:24.000
代替案を試すためのこのバックアップは、グローバルバックトラック、または正式な論理ではKleeneクロージャと呼ばれます。

00:20:24.000 -> 00:20:29.000
それは正規表現に特徴的な力を与えるものです。

00:20:29.000 -> 00:20:36.000
しかし、それは探索するための幅広い検索スペースを開き、ここではより直線的な検索スペースが必要です。

00:20:36.000 -> 00:20:40.000
私たちはすべての空白を一致させ、決してあきらめないようにしたい。

00:20:40.000 -> 00:20:51.000
使用できるツールがいくつかあります。より一般的なツールは、フィールドセパレータをグローバルスコープではなくローカルバックトラッキングスコープに置くことです。

00:20:51.000 -> 00:21:02.000
ローカルビルダーは、含まれている正規表現が正常に一致した場合、未試行の選択肢が破棄されるスコープを作成します。

00:21:02.000 -> 00:21:10.000
トランザクションマッチャーが後で失敗したとしても、より少ないスペースを消費するために戻らない。

00:21:10.000 -> 00:21:17.000
正規表現のデフォルトであるグローバルバックトラッキングは、検索とファジーマッチングに最適です。

00:21:17.000 -> 00:21:22.000
ローカルは、正確に指定されたトークンを一致させるのに便利です。

00:21:22.000 -> 00:21:29.000
フィールドセパレータは、それが厄介なように、正確です。

00:21:29.000 -> 00:21:36.000
ローカルは、原子非捕獲グループとして他の場所で知られており、それは...恐ろしい名前になる可能性があります。

00:21:36.000 -> 00:21:40.000
あなたの正規表現が爆発するかもしれないように見えます。

00:21:40.000 -> 00:21:46.000
しかし、実際には逆のことをします-検索スペースが含まれています。

00:21:46.000 -> 00:21:50.000
そして、これで、私たちは彼らがスケーリングの問題を解決するのを助けました。

00:21:50.000 -> 00:21:56.000
今日はSwift Regexに会うことができましたが、カバーできなかったことがたくさんあります。

00:21:56.000 -> 00:22:02.000
同僚のリチャードによるSwift Regex: Beyond the Basicsを必ずチェックしてください。

00:22:02.000 -> 00:22:05.000
出発する前に、いくつかの点を強調したいと思います。

00:22:05.000 -> 00:22:11.000
正規表現ビルダーは構造を与えます。正規表現リテラルは簡潔です。

00:22:11.000 -> 00:22:17.000
いつ一方を他方よりも使用するかの選択は、最終的には主観的になります。

00:22:17.000 -> 00:22:21.000
可能な限り、必ず実際のパーサーを使用してください。

00:22:21.000 -> 00:22:27.000
これにより、膨大な時間を節約し、頭痛を避けることができます。

00:22:27.000 -> 00:22:33.000
Swiftのデフォルトを使用するだけで、他のどこよりもはるかに多くのUnicodeサポートと良さを得ることができます。

00:22:33.000 -> 00:22:40.000
通貨記号を照合したときなど、文字のプロパティなどを効果的に使用する方法を探してください。

00:22:40.000 -> 00:22:49.000
そして最後に、先読みやローカルバックトラックスコープなどのコントロールを使用して、検索と処理アルゴリズムを簡素化します。

00:22:49.000 -> 23:59:59.000
ご覧いただきありがとうございます。

