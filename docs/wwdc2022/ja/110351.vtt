WEBVTT

00:00:00.000 -> 00:00:03.000
♪まろやかなインストゥルメンタルヒップホップ音楽♪

00:00:03.000 -> 00:00:09.000
♪

00:00:09.000 -> 00:00:10.000
こんにちは。

00:00:10.000 -> 00:00:17.000
私はSwiftチームのDougで、データレースを排除するためのSwift Concurrencyのアプローチについて話すためにここにいます。

00:00:17.000 -> 00:00:23.000
並行プログラムを書きやすくする一連の言語機能として、Swift Concurrencyを導入しました。

00:00:23.000 -> 00:00:32.000
これらの個々の言語機能の仕組みについては、それぞれをカバーする2021年のWWDC講演を参照してください。

00:00:32.000 -> 00:00:42.000
この講演では、データレースを導入せずに並行性を効率的に利用するためにプログラムを構造化する方法として、Swift Concurrencyの異なる、より包括的な見方を取ります。

00:00:42.000 -> 00:00:50.000
しかし、そうするには、私たちは素晴らしいアナロジーが必要なので、並行性の公海で私たちと一緒に航海することを勧めます。

00:00:50.000 -> 00:01:01.000
並行性の海は予測不可能で、一度に多くのことが起こっていますが、あなたが舵取りをし、スウィフトがあなたが海をナビゲートするのを手伝って、それは素晴らしいものを生み出すことができます。

00:01:01.000 -> 00:01:02.000
飛び込もう！

00:01:02.000 -> 00:01:14.000
まず、Swiftの並行性モデルの重要なアイデアの1つである分離について話し、データがデータレースを導入できる方法で共有されないようにします。

00:01:14.000 -> 00:01:17.000
タスクの分離から始めましょう。

00:01:17.000 -> 00:01:22.000
私たちの並行性の海では、タスクはボートで表されます。

00:01:22.000 -> 00:01:29.000
ボートは私たちの主な労働者です - 彼らはやるべき仕事があり、最初から最後まで順番に実行します。

00:01:29.000 -> 00:01:37.000
それらは非同期であり、その作業はコードの「待機」操作で何度でも中断することができます。

00:01:37.000 -> 00:01:48.000
最後に、それらは自己完結型です。各タスクには独自のリソースがあるので、海の他のすべてのボートとは独立して、単独で操作できます。

00:01:48.000 -> 00:01:59.000
私たちのボートが完全に独立している場合、データレースのない並行性がありますが、何らかの通信方法がなければあまり役に立ちません。

00:01:59.000 -> 00:02:01.000
コミュニケーションを追加しましょう!

00:02:01.000 -> 00:02:07.000
例えば、あるボートには、別のボートと共有したいパイナップルがあるかもしれません。

00:02:07.000 -> 00:02:13.000
だから、ボートは外洋で出会い、パイナップルをあるボートから別のボートに移します。

00:02:13.000 -> 00:02:22.000
さて、このパイナップルは、あるボートから次のボートに移動する物理的なアイテムではないので、これは物理的なアナロジーが少し壊れる場所です。

00:02:22.000 -> 00:02:29.000
それはデータであり、Swiftでは、そのデータを表現するいくつかの異なる方法があります。

00:02:29.000 -> 00:02:31.000
パイナップルの種類をどのように定義しますか?

00:02:31.000 -> 00:02:39.000
私たちはスウィフトの値タイプが好きなので、パイナップルをその重量と熟度によって定義される構造体にしましょう。

00:02:39.000 -> 00:02:41.000
これがどのように機能するか見てみましょう。

00:02:41.000 -> 00:02:52.000
ボートが外洋で会うとき、私たちは本当にパイナップルインスタンスのコピーを1つのボートから次のボートに渡し、各ボートは独自のコピーで消えます。

00:02:52.000 -> 00:03:01.000
Slice() や ripen() メソッドを呼び出すなど、コピーを変異させた場合、他のメソッドには影響しません。

00:03:01.000 -> 00:03:09.000
Swiftは、まさにこの理由で常に値型を好んできました。突然変異は局所的な影響しかありません。

00:03:09.000 -> 00:03:14.000
その原則は、価値タイプが分離を維持するのに役立ちます。

00:03:14.000 -> 00:03:18.000
では、データモデルを少し拡張して、鶏を追加しましょう!

00:03:18.000 -> 00:03:26.000
食べるのに良いパイナップルとは異なり、鶏は独自の個性を持つ美しい生き物です。

00:03:26.000 -> 00:03:30.000
だから、私たちはこのようなクラスでそれらをモデル化するつもりです。

00:03:30.000 -> 00:03:34.000
勇敢な船員に鶏を交換してもらいましょう。

00:03:34.000 -> 00:03:47.000
私たちのボートが会うとき、私たちはチキンを共有しますが、チキンのような参照タイプをコピーしてもチキンの別の完全なコピーは得られません、それはあなたにその特定のオブジェクトへの参照を与えます。

00:03:47.000 -> 00:04:00.000
だから、私たちのボートが別々の道を行くと、私たちは問題を抱えていることがわかります。両方のボートは同時に仕事をしていますが、両方とも同じチキンオブジェクトを参照しているため、独立していません。

00:04:00.000 -> 00:04:12.000
その共有可変データは、一方のボートが鶏に餌を与えようとし、もう一方のボートがそれで遊びたいときなど、データレースになりやすく、非常に混乱した鶏につながります。

00:04:12.000 -> 00:04:18.000
パイナップルをボートで共有しても安全だったが、鶏は安全ではないことを知る方法が必要です。

00:04:18.000 -> 00:04:27.000
そして、鶏が誤ってあるボートから別のボートに渡されないように、Swiftコンパイラでチェックインする必要があります。

00:04:27.000 -> 00:04:33.000
Swiftプロトコルは、その動作について推論できるように、タイプを分類する素晴らしい方法です。

00:04:33.000 -> 00:04:43.000
Sendableプロトコルは、データレースを作成することなく、異なる分離ドメイン間で安全に共有できるタイプを記述するために使用されます。

00:04:43.000 -> 00:04:47.000
タイプは、コンフォーマンスを書くことで送信可能にすることができます。

00:04:47.000 -> 00:04:58.000
パイナップル構造体は値型であるためSendableに準拠していますが、Chickenクラスは同期されていない参照型であるためできません。

00:04:58.000 -> 00:05:06.000
Sendableをプロトコルとしてモデル化することで、データが分離ドメイン間で共有される場所を記述することができます。

00:05:06.000 -> 00:05:15.000
たとえば、タスクが値を返すと、この値は、その値を待っているタスクのいずれかに提供されます。

00:05:15.000 -> 00:05:25.000
ここでは、タスクからチキンを返そうとしていますが、チキンが送信できないため、これは安全ではないというエラーが表示されます。

00:05:25.000 -> 00:05:37.000
実際のSendable制約は、Successと呼ばれるタスクの結果タイプがSendableプロトコルに準拠しなければならないことを指定するタスク構造体自体の定義から来ています。

00:05:37.000 -> 00:05:45.000
値が異なる分離ドメインに渡される汎用パラメータを持つSendable制約を使用する必要があります。

00:05:45.000 -> 00:05:50.000
さて、ボート間でデータを共有するというアイデアを再検討しましょう。

00:05:50.000 -> 00:06:00.000
2隻のボートが公海で出会い、データを共有したい場合は、すべての商品を一貫してチェックして、安全に共有できるかどうかを確認する人が必要です。

00:06:00.000 -> 00:06:09.000
これは、Swiftコンパイラがここで演じるフレンドリーな税関検査官の役割であり、Sendableタイプのみが交換されるようにします。

00:06:09.000 -> 00:06:14.000
パイナップルは大丈夫で、送信可能なので自由に交換できます。

00:06:14.000 -> 00:06:23.000
しかし、鶏肉は交換できず、私たちのフレンドリーな税関検査官は私たちがその間違いを犯すのを防ぎます。

00:06:23.000 -> 00:06:28.000
コンパイラは、多くの異なるポイントで送信可能な正確性のチェックに関与しています。

00:06:28.000 -> 00:06:35.000
送信可能なタイプは、構築によって正しくなければならず、共有データを密輸することはできません。

00:06:35.000 -> 00:06:44.000
列挙型と構造体は通常、すべてのインスタンスデータをコピーして独立した値を生成する値型を定義します。

00:06:44.000 -> 00:06:51.000
したがって、すべてのインスタンスデータも送信可能である限り、送信可能にすることができます。

00:06:51.000 -> 00:06:57.000
Sendableは、条件付き適合を使用して、コレクションやその他のジェネリックタイプを通じて伝播できます。

00:06:57.000 -> 00:07:04.000
Sendableタイプの配列はSendableなので、パイナップルでいっぱいのクレートもSendableです。

00:07:04.000 -> 00:07:15.000
これらのSendableの適合性はすべて、非公開型のSwiftコンパイラによって推測することさえできるため、Ripeness、Pineapple、およびCrateはすべて暗黙的にSendableです。

00:07:15.000 -> 00:07:19.000
しかし、鶏の群れを収容する小屋を作ったとしましょう。

00:07:19.000 -> 00:07:29.000
このタイプは、送信可能でない状態が含まれているため、送信可能としてマークすることはできません。チキンは送信可能ではないため、鶏の配列は送信可能ではありません。

00:07:29.000 -> 00:07:35.000
コンパイラから、このタイプを安全に共有できないことを示すエラーメッセージが表示されます。

00:07:35.000 -> 00:07:46.000
クラスは参照型であるため、最終的なクラスに不変のストレージしかない場合など、非常に狭い状況でのみ送信可能にすることができます。

00:07:46.000 -> 00:07:53.000
ChickenクラスをSendableにしようとすると、可変状態が含まれているため、エラーが発生します。

00:07:53.000 -> 00:08:01.000
これで、ロックを一貫して使用することで、独自の内部同期を行う参照型を実装することが可能になります。

00:08:01.000 -> 00:08:07.000
これらのタイプは概念的には送信可能ですが、Swiftがそれについて推論する方法はありません。

00:08:07.000 -> 00:08:12.000
チェックされていないSendableを使用して、コンパイラのチェックを無効にします。

00:08:12.000 -> 00:08:21.000
@Unchecked Sendableを介して変更可能な状態を密輸することは、スウィフトが提供しているデータレースの安全性を保証するため、これに注意してください。

00:08:21.000 -> 00:08:30.000
タスクの作成には、ボートから手漕ぎボートを送り出すなど、新しい独立したタスクで閉鎖を実行することが含まれます。

00:08:30.000 -> 00:08:41.000
これを行うと、元のタスクから値をキャプチャし、新しいタスクに渡すことができるので、データレースを導入しないようにSendableチェックが必要です。

00:08:41.000 -> 00:08:51.000
この境界を越えて送信不可能なタイプを共有しようとすると、Swiftコンパイラが私たちをカバーし、このようなエラーメッセージを生成します。

00:08:51.000 -> 00:08:53.000
これはタスク作成のための魔法ではありません。

00:08:53.000 -> 00:09:01.000
クロージャは、At-Sendableで明示的に書かれた可能性のあるSendableクロージャであると推測されています。

00:09:01.000 -> 00:09:07.000
Sendableクロージャは、Sendable関数型の値です。

00:09:07.000 -> 00:09:13.000
At-Sendableは、関数型がSendableプロトコルに準拠していることを示すために、関数型に書き込むことができます。

00:09:13.000 -> 00:09:23.000
これは、その関数型の値を他の分離ドメインに渡し、キャプチャされた状態にデータレースを導入することなく、そこで呼び出すことができることを意味します。

00:09:23.000 -> 00:09:31.000
通常、関数型はプロトコルに準拠できませんが、コンパイラがセマンティック要件を検証するため、Sendableは特別です。

00:09:31.000 -> 00:09:41.000
Sendableプロトコルに準拠したSendableタイプのタプルにも同様のサポートがあり、Sendableを言語全体で使用できます。

00:09:41.000 -> 00:09:48.000
私たちが説明したシステムには、互いに分離された多くのタスクを同時に実行しています。

00:09:48.000 -> 00:09:59.000
Sendableプロトコルは、タスク間で安全に共有できるタイプを記述し、Swiftコンパイラは、タスクの分離を維持するために、すべてのレベルでSendable適合性をチェックします。

00:09:59.000 -> 00:10:07.000
しかし、どこでも共有可変データの概念がなければ、タスクが有意義な方法で調整するのは難しいです。

00:10:07.000 -> 00:10:13.000
そのため、データレースを再導入しないタスク間でデータを共有する方法が必要です。

00:10:13.000 -> 00:10:16.000
ここが俳優の出番です。

00:10:16.000 -> 00:10:26.000
アクターは、さまざまなタスクでアクセスできる状態を分離する方法を提供しますが、データレースを排除する調整された方法で。

00:10:26.000 -> 00:10:30.000
俳優は私たちの並行性の海の島です。

00:10:30.000 -> 00:10:38.000
ボートのように、各島は自己完結型で、海の他のすべてのものから隔離された独自の状態があります。

00:10:38.000 -> 00:10:43.000
その状態にアクセスするには、コードが島で実行されている必要があります。

00:10:43.000 -> 00:10:47.000
たとえば、adsanceTimeメソッドはこの島に隔離されています。

00:10:47.000 -> 00:10:51.000
それは島に住み、島の州すべてにアクセスできます。

00:10:51.000 -> 00:10:56.000
実際に島でコードを実行するには、ボートが必要です。

00:10:56.000 -> 00:11:02.000
ボートは島を訪れて島でコードを実行することができ、その時点でその州にアクセスできます。

00:11:02.000 -> 00:11:11.000
一度にコードを実行するために島を訪れることができるのは1つのボートだけで、島の州への同時アクセスがないことを保証します。

00:11:11.000 -> 00:11:16.000
他のボートが現れたら、彼らは島を訪れる順番を待たなければならない。

00:11:16.000 -> 00:11:27.000
そして、特定のボートが島を訪れる機会を得るまでには長い時間がかかるかもしれないので、俳優に入ることは「待つ」キーワードでマークされた潜在的なサスペンションポイントです。

00:11:27.000 -> 00:11:34.000
島が解放されると、再び、サスペンションポイントで、別のボートが訪れることができます。

00:11:34.000 -> 00:11:47.000
2つのボートが外洋で会うのと同じように、ボートと島の間の相互作用は、送信不可能なタイプが2つの間を通過しないようにすることで、両方の分離を維持する必要があります。

00:11:47.000 -> 00:11:52.000
例えば、おそらく私たちはボートから島の群れに鶏を追加しようとします。

00:11:52.000 -> 00:12:00.000
これにより、異なる分離ドメインから同じチキンオブジェクトへの2つの参照が作成されるので、Swiftコンパイラはそれを拒否します。

00:12:00.000 -> 00:12:11.000
同様に、島からペットの鶏を採用し、ボートで持ち去ろうとすると、送信可能なチェックにより、このデータレースを作成できなくなります。

00:12:11.000 -> 00:12:19.000
アクターは参照型ですが、クラスとは異なり、同時アクセスを防ぐためにすべてのプロパティとコードを分離します。

00:12:19.000 -> 00:12:25.000
したがって、別の分離ドメインのアクターへの参照を持つことは安全です。

00:12:25.000 -> 00:12:34.000
それは島への地図を持っているようなものです:あなたは島を訪問するために地図を使用することができますが、あなたはまだその状態にアクセスするためにドッキング手順を通過する必要があります。

00:12:34.000 -> 00:12:40.000
したがって、すべてのアクタータイプは暗黙的に送信可能です。

00:12:40.000 -> 00:12:46.000
どのコードがアクターに分離され、どのコードが分離されていないかを知る方法を疑問に思うかもしれません。

00:12:46.000 -> 00:12:50.000
俳優の隔離は、あなたがいる文脈によって決まります。

00:12:50.000 -> 00:12:54.000
アクターのインスタンスプロパティは、そのアクターに分離されます。

00:12:54.000 -> 00:13:03.000
アクターのインスタンスメソッドまたはアクターの拡張も、このad advanceTimeメソッドのように、デフォルトで分離されています。

00:13:03.000 -> 00:13:14.000
削減アルゴリズムに渡されたクロージャなど、送信できないクロージャは、アクターにとどまり、アクター分離コンテキストにあるときにアクター分離されます。

00:13:14.000 -> 00:13:23.000
タスク初期化子はまた、そのコンテキストからアクターの分離を継承するので、作成されたタスクは、開始されたのと同じアクターにスケジュールされます。

00:13:23.000 -> 00:13:27.000
ここでは、群れへのアクセスを許可します。

00:13:27.000 -> 00:13:37.000
一方、切り離されたタスクは、作成されたコンテキストから完全に独立しているため、コンテキストからアクターの分離を継承しません。

00:13:37.000 -> 00:13:46.000
ここでのクロージャのコードは、孤立した「食べ物」プロパティを参照するために「await」を使用する必要があるため、アクターの外にあると考えられていることがわかります。

00:13:46.000 -> 00:13:52.000
このクロージャには用語があります:それは非分離コードです。

00:13:52.000 -> 00:13:56.000
分離されていないコードは、どのアクターでもまったく実行されないコードです。

00:13:56.000 -> 00:14:05.000
非分離キーワードを使用して、アクターの外部に置くことで、アクター内の関数を明示的に非分離にすることができます。

00:14:05.000 -> 00:14:10.000
切り離されたタスクに使用されたクロージャで暗黙的に起こったことと同じように。

00:14:10.000 -> 00:14:20.000
つまり、俳優に隔離された州の一部を読みたい場合は、「待機」を使用して島を訪問し、必要な州のコピーを入手する必要があります。

00:14:20.000 -> 00:14:26.000
分離されていない非同期コードは、常にグローバル協同組合プールで実行されます。

00:14:26.000 -> 00:14:33.000
ボートが外洋に出ているときだけ走っていると考えるので、仕事をするために訪問している島を離れなければなりません。

00:14:33.000 -> 00:14:39.000
つまり、送信不可能なデータを持ち行っていないことを確認することを意味します!

00:14:39.000 -> 00:14:47.000
ここで、コンパイラは、送信不可能なチキンのインスタンスが島を離れようとしている潜在的なデータレースを検出します。

00:14:47.000 -> 00:14:52.000
分離されていないコードのケースをもう1つ考えてみましょう。

00:14:52.000 -> 00:14:56.000
「グリート」操作は、分離されていない同期コードです。

00:14:56.000 -> 00:15:00.000
ボートや島、または一般的な並行性について何も知りません。

00:15:00.000 -> 00:15:05.000
そして、ここで、私たちは俳優が分離したgreetOne関数からそれを呼んでいます、そしてそれは大丈夫です!

00:15:05.000 -> 00:15:14.000
この同期コードは、島から呼び出されると、島にとどまるので、群れから鶏を自由に操作できます。

00:15:14.000 -> 00:15:23.000
代わりに「グリート」を呼び出す非分離非同期操作があった場合、「グリート」は外洋でボートで実行されます。

00:15:23.000 -> 00:15:35.000
ほとんどのSwiftコードは次のようになります。同期し、任意のアクターに分離せず、指定されたパラメータのみで動作するため、呼び出される分離ドメインにとどまります。

00:15:35.000 -> 00:15:40.000
俳優は、プログラムの残りの部分から隔離された状態を保持します。

00:15:40.000 -> 00:15:47.000
一度にアクターで実行できるタスクは1つだけなので、その状態への同時アクセスはありません。

00:15:47.000 -> 00:15:56.000
送信可能なチェックは、タスクがアクターに出入りするときはいつでも適用され、同期されていない可変状態がエスケープされないようにします。

00:15:56.000 -> 00:16:04.000
全体として、これは俳優をSwiftの同時プログラムの構成要素の1つにします。

00:16:04.000 -> 00:16:09.000
私たちがよく話す、主役と呼ばれる別の特別な俳優がいます。

00:16:09.000 -> 00:16:13.000
主人公は海の真ん中にある大きな島だと考えてください。

00:16:13.000 -> 00:16:19.000
これは、ユーザーインターフェイスのすべての描画とインタラクションが発生するメインスレッドを表します。

00:16:19.000 -> 00:16:24.000
したがって、何かを描きたい場合は、メイン俳優の島でコードを実行する必要があります。

00:16:24.000 -> 00:16:32.000
それはあなたのUIにとって非常に重要なので、私たちはそれを「U-I-land」と呼ぶべきかもしれません。

00:16:32.000 -> 00:16:39.000
主な俳優が「大きい」と言うとき、私たちが意味するのは、プログラムのユーザーインターフェイスに関連する多くの状態が含まれているということです。

00:16:39.000 -> 00:16:45.000
UIフレームワークとアプリの両方で、実行する必要がある多くのコードがあります。その上で実行する必要があります。

00:16:45.000 -> 00:16:51.000
しかし、それはまだ俳優なので、一度に1つのジョブしか実行しません。

00:16:51.000 -> 00:17:00.000
したがって、UIが応答しなくなる可能性があるため、メインアクターにあまりにも多くの作業や長時間の作業をかけないように注意する必要があります。

00:17:00.000 -> 00:17:04.000
メインアクターへの分離は、MainActor属性で表現されます。

00:17:04.000 -> 00:17:12.000
この属性は、コードがメインアクターで実行する必要があることを示すために、関数またはクロージャに適用できます。

00:17:12.000 -> 00:17:16.000
次に、このコードはメインアクターに分離されていると言います。

00:17:16.000 -> 00:17:28.000
Swiftコンパイラは、他のアクターへの相互に排他的なアクセスを保証する同じメカニズムを使用して、メインアクター分離コードがメインスレッドでのみ実行されることを保証します。

00:17:28.000 -> 00:17:39.000
メインアクターに分離されていないコンテキストからupdateViewを呼び出す場合は、メインアクターへの切り替えを説明するために「待機」を導入する必要があります。

00:17:39.000 -> 00:17:47.000
メインアクター属性はタイプにも適用でき、その場合、これらのタイプのインスタンスはメインアクターに分離されます。

00:17:47.000 -> 00:17:58.000
繰り返しますが、これは他のアクターと似ています。プロパティはメインアクターでのみアクセスでき、明示的にオプトアウトしない限り、メソッドはメインアクターに分離されます。

00:17:58.000 -> 00:18:07.000
通常のアクターと同様に、メインアクタークラスへの参照自体は、データが分離されているため、送信可能です。

00:18:07.000 -> 00:18:16.000
これにより、メインアクターの注釈は、必然的にフレームワーク自体によってメインスレッドに関連付けられているUIビューとビューコントローラーに適しています。

00:18:16.000 -> 00:18:26.000
ビューコントローラーへの参照をプログラム内の他のタスクやアクターと共有することができ、ビューコントローラーに非同期に呼び戻して結果を投稿することができます。

00:18:26.000 -> 00:18:30.000
これはアプリのアーキテクチャに直接影響します。

00:18:30.000 -> 00:18:35.000
アプリでは、ビューとビューコントローラーがメインアクターになります。

00:18:35.000 -> 00:18:45.000
他のプログラムロジックは、そのメインアクターから分離し、他のアクターを使用して共有状態とタスクを安全にモデル化し、独立した作業を記述する必要があります。

00:18:45.000 -> 00:18:51.000
そして、これらのタスクは、必要に応じて主役と他の俳優の間を行き来することができます。

00:18:51.000 -> 00:18:57.000
並行アプリでは多くのことが起こっているので、私たちはあなたがそれを理解するのに役立ついくつかの素晴らしいツールを構築しました。

00:18:57.000 -> 00:19:03.000
詳細については、「スウィフト並行性の視覚化と最適化」トークをご覧ください。

00:19:03.000 -> 00:19:08.000
原子性について話すために、より深い海に飛び込みましょう。

00:19:08.000 -> 00:19:12.000
Swift Concurrencyモデルの目標は、データ競合を排除することです。

00:19:12.000 -> 00:19:18.000
それが本当に意味することは、データ破損を伴う低レベルのデータレースを排除するということです。

00:19:18.000 -> 00:19:23.000
あなたはまだ高いレベルで原子性について推論する必要があります。

00:19:23.000 -> 00:19:28.000
前に話したように、俳優は一度に1つのタスクしか実行しません。

00:19:28.000 -> 00:19:32.000
ただし、アクターで実行をやめると、アクターは他のタスクを実行できます。

00:19:32.000 -> 00:19:38.000
これにより、プログラムが進歩し、デッドロックの可能性が排除されます。

00:19:38.000 -> 00:19:43.000
ただし、待機ステートメントの周りに俳優の不変量を慎重に検討する必要があります。

00:19:43.000 -> 00:19:52.000
そうしないと、データが実際に破損していなくても、プログラムが予期しない状態にある高レベルのデータレースに終わる可能性があります。

00:19:52.000 -> 00:19:56.000
これの例を分解しましょう。

00:19:56.000 -> 00:20:01.000
ここでは、島にいくつかの追加のパイナップルを堆積させる機能があります。

00:20:01.000 -> 00:20:06.000
それは俳優の外にあるので、分離されていない非同期コードです。

00:20:06.000 -> 00:20:10.000
それは、ここ外洋で走り出すことを意味します。

00:20:10.000 -> 00:20:16.000
それはいくつかのパイナップルと、それらのパイナップルを預けるべき島への地図を与えられました。

00:20:16.000 -> 00:20:22.000
ここでの最初の興味深い操作は、島から食べ物の配列のコピーを取得します。

00:20:22.000 -> 00:20:27.000
これを行うには、ボートは「待つ」キーワードで示される島を訪れる必要があります。

00:20:27.000 -> 00:20:33.000
食べ物のコピーがあるとすぐに、ボートは仕事を続けるために外洋に戻ります。

00:20:33.000 -> 00:20:39.000
それは、島から得た2つにパイナップルパラメータからパイナップルを追加することを意味します。

00:20:39.000 -> 00:20:43.000
これで、関数の最後の行に進むことができます。

00:20:43.000 -> 00:20:50.000
私たちのボートは今、これらの3つのパイナップルに島の食べ物の配列を設定するために再び島を訪問する必要があります。

00:20:50.000 -> 00:20:55.000
ここでは、すべてがうまくいき、島には3つのパイナップルがあります!

00:20:55.000 -> 00:20:58.000
しかし、物事は少し違っていたかもしれません。

00:20:58.000 -> 00:21:07.000
私たちの最初のボートが島を訪れる順番を待っている間に、海賊船が忍び込み、すべてのパイナップルを盗んだとしましょう。

00:21:07.000 -> 00:21:13.000
今、私たちの元の船は島に3つのパイナップルを堆積し、私たちは問題に気づきます。

00:21:13.000 -> 00:21:17.000
3つのパイナップルが突然5つのパイナップルに変わった!

00:21:17.000 -> 00:21:19.000
ここで何があったの?

00:21:19.000 -> 00:21:32.000
さて、同じ俳優の州へのアクセスのために2つの待機があることに注目してください、そして、私たちはここで島の食糧配列がそれらの2つの待機の間で変わらないと仮定しています。

00:21:32.000 -> 00:21:42.000
しかし、これらは待っています。つまり、私たちのタスクはここで中断され、俳優は海賊との戦いなど、他の優先度の高い仕事をすることができます。

00:21:42.000 -> 00:21:49.000
この特定のケースでは、Swiftコンパイラは別のアクターの状態を完全に変更しようとする試みを拒否します。

00:21:49.000 -> 00:21:56.000
しかし、このように、入金操作をアクターの同期コードとして書き換える必要があります。

00:21:56.000 -> 00:22:01.000
これは同期コードであるため、中断することなくアクターで実行されます。

00:22:01.000 -> 00:22:09.000
したがって、島の状態は機能全体を通して他の誰によっても変わらないことを確信できます。

00:22:09.000 -> 00:22:17.000
アクターを書くときは、何らかの方法でインターリーブできる同期的なトランザクション操作の観点から考えてください。

00:22:17.000 -> 00:22:23.000
彼ら全員が、俳優が終了時に良い状態にあることを確認する必要があります。

00:22:23.000 -> 00:22:35.000
非同期アクター操作の場合、それらをシンプルに保ち、主に同期のトランザクション操作からそれらを形成し、各待機操作でアクターが良好な状態にあるように注意してください。

00:22:35.000 -> 00:22:42.000
このようにして、アクターを最大限に活用して、低レベルと高レベルのデータレースの両方を排除することができます。

00:22:42.000 -> 00:22:51.000
同時プログラムでは、多くのことが一度に起こっているため、それらのことが起こる順序は、実行ごとに異なる場合があります。

00:22:51.000 -> 00:22:56.000
しかし、プログラムは多くの場合、一貫した順序でイベントを処理することに依存しています。

00:22:56.000 -> 00:23:02.000
たとえば、ユーザー入力やサーバーからのメッセージから入ってくるイベントのストリーム。

00:23:02.000 -> 00:23:07.000
これらのイベントストリームが入ってくると、その効果が順番に起こると予想されます。

00:23:07.000 -> 00:23:14.000
Swift Concurrencyは操作を順序付けするためのツールを提供しますが、アクターはそうするためのツールではありません。

00:23:14.000 -> 00:23:20.000
俳優は、システム全体が応答性を維持するのを助けるために、最も優先度の高い作業を最初に実行します。

00:23:20.000 -> 00:23:28.000
これにより、同じアクターで優先度の高い作業が行われる前に、優先度の低い作業が行われる優先度反転が排除されます。

00:23:28.000 -> 00:23:38.000
これは、厳密に先入れ先出し順で実行されるシリアルディスパッチキューとは大きな違いであることに注意してください。

00:23:38.000 -> 00:23:41.000
Swift Concurrencyには、作業を注文するためのいくつかのツールがあります。

00:23:41.000 -> 00:23:45.000
最初に、私たちはすでに多くのことを話してきました - タスク

00:23:45.000 -> 00:23:54.000
タスクは、慣れている通常の制御フローで最初から最後まで実行されるため、自然に作業を注文します。

00:23:54.000 -> 00:23:58.000
AsyncStreamは、実際のイベントストリームをモデル化するために使用できます。

00:23:58.000 -> 00:24:05.000
1つのタスクは、for-await-inループでイベントのストリームを反復し、各イベントを順番に処理できます。

00:24:05.000 -> 00:24:14.000
AsyncStreamは、任意の数のイベントプロデューサーと共有でき、順序を維持しながらストリームに要素を追加できます。

00:24:14.000 -> 00:24:26.000
Swiftの並行性モデルは、タスクとアクターの境界でSendableチェックによって維持される分離の概念を使用してデータレースを排除するようにどのように設計されているかについて多くのことを話しました。

00:24:26.000 -> 00:24:32.000
しかし、私たちは皆、どこにでもすべてのSendableタイプをマークするためにやっていることを止めることはできません。

00:24:32.000 -> 00:24:36.000
代わりに、漸進的なアプローチが必要です。

00:24:36.000 -> 00:24:44.000
Swift 5.7では、SwiftコンパイラがSendabilityをどれだけ厳密にチェックすべきかを指定するビルド設定が導入されています。

00:24:44.000 -> 00:24:53.000
デフォルト設定はMinimalです。つまり、コンパイラは明示的に何かをSendableとしてマークしようとした場所のみを診断します。

00:24:53.000 -> 00:25:00.000
これはSwift 5.5と5.6の動作に似ており、上記については警告やエラーはありません。

00:25:00.000 -> 00:25:09.000
さて、Sendableコンフォーマンスを追加すると、ChickenがSendableではないため、コンパイラはCoopタイプがSendableできないと文句を言います。

00:25:09.000 -> 00:25:22.000
ただし、これと他のSendable関連の問題は、問題を1つずつ解決しやすくするために、エラーではなくSwift 5で警告として表示されます。

00:25:22.000 -> 00:25:28.000
データレースの安全性に向けてさらに進むには、「ターゲットを絞った」厳格な並行性設定を有効にします。

00:25:28.000 -> 00:25:37.000
この設定により、async/await、タスク、アクターなどのSwift並行性機能をすでに採用しているコードのSendableチェックが可能になります。

00:25:37.000 -> 00:25:45.000
これは、たとえば、新しく作成されたタスクで送信不可能なタイプの値をキャプチャしようとする試みを識別します。

00:25:45.000 -> 00:25:50.000
送信不可能なタイプは、別のモジュールから来ることがあります。

00:25:50.000 -> 00:25:57.000
おそらく、それはまだSendable用に更新されていないパッケージ、またはあなたが回避していない独自のモジュールです。

00:25:57.000 -> 00:26:07.000
それらについては、@preconcurrency属性を使用して、そのモジュールから来たタイプの送信可能な警告を一時的に無効にすることができます。

00:26:07.000 -> 00:26:12.000
これにより、このソースファイル内のチキンタイプの送信可能な警告が消音になります。

00:26:12.000 -> 00:26:17.000
ある時点で、FarmAnimalsモジュールはSendableコンフォーマンスで更新されます。

00:26:17.000 -> 00:26:27.000
次に、2つのうちの1つが起こります。Chickenが何らかの形でSendableになり、その場合、preconcurrency属性をインポートから削除できます。

00:26:27.000 -> 00:26:38.000
または、チキンは送信可能ではないことが知られており、その場合、警告が戻ってきて、チキンが送信可能であるというあなたの仮定が実際には正しくないことを示しています。

00:26:38.000 -> 00:26:47.000
ターゲットを絞った厳格さの設定は、既存のコードとの互換性と潜在的なデータレースの特定のバランスを取ろうとします。

00:26:47.000 -> 00:26:55.000
ただし、レースが発生する可能性のある場所をどこでも見たい場合は、もう1つのオプションがあります。完全なチェックです。

00:26:55.000 -> 00:27:01.000
完全なチェックは、データレースを完全に排除するために、意図したSwift 6セマンティクスを近似します。

00:27:01.000 -> 00:27:07.000
以前の2つのモードがチェックするすべてをチェックしますが、モジュール内のすべてのコードに対してチェックします。

00:27:07.000 -> 00:27:11.000
ここでは、実際にはSwiftの並行性機能をまったく使用していません。

00:27:11.000 -> 00:27:17.000
むしろ、そのコードを同時に実行するディスパッチキューで作業を実行しています。

00:27:17.000 -> 00:27:31.000
ディスパッチキューでの非同期操作は、実際には送信可能なクロージャを取ることが知られているため、コンパイラは、送信不可能なボディがディスパッチキューで実行されているコードによってキャプチャされたときにデータレースがあることを示す警告を生成します。

00:27:31.000 -> 00:27:36.000
本文パラメータを送信可能にすることで、これを修正できます。

00:27:36.000 -> 00:27:45.000
その変更により、この警告が排除され、doWorkのすべての発信者は、Sendableクロージャを提供する必要があることを知っています。

00:27:45.000 -> 00:27:53.000
つまり、データレースをよりよくチェックし、訪問機能がデータレースのソースであることがわかります。

00:27:53.000 -> 00:28:00.000
完全なチェックは、プログラムの潜在的なデータレースを洗い流すのに役立ちます。

00:28:00.000 -> 00:28:06.000
データレースを排除するというSwiftの目標を達成するためには、最終的にはチェックを完了する必要があります。

00:28:06.000 -> 00:28:21.000
その目標に向かって段階的に取り組むことをお勧めします。Swiftの並行性モデルを採用して、データレースの安全性のためにアプリを設計し、徐々に厳格な並行性チェックを有効にして、コードからエラーのクラスを排除します。

00:28:21.000 -> 00:28:27.000
また、インポートされたタイプの警告を抑制するために、インポートを@preconcurrencyでマークすることを心配しないでください。

00:28:27.000 -> 00:28:33.000
これらのモジュールはより厳格な並行性チェックを採用するため、コンパイラはあなたの仮定を再チェックします。

00:28:33.000 -> 00:28:42.000
この道の終わりに、あなたのコードはメモリの安全性とデータレースの安全性の両方から恩恵を受け、優れたアプリの構築に集中するのに役立ちます。

00:28:42.000 -> 00:28:47.000
そして、並行性の海で私と一緒に航海してくれてありがとう。

00:28:47.000 -> 23:59:59.000
♪

