WEBVTT

00:00:00.000 -> 00:00:13.000
アンディ:こんにちは。

00:00:13.000 -> 00:00:17.000
「デスクトップクラスの編集インタラクションを採用する」へようこそ。

00:00:17.000 -> 00:00:24.000
私はUIKitフレームワークエンジニアのアンディで、後で同僚のジェームズが参加します。

00:00:24.000 -> 00:00:32.000
iPadは、シンプルで使いやすいインタラクションを損なうことなく、絶えず進化しています。

00:00:32.000 -> 00:00:41.000
このビデオでは、アプリをよりデスクトップクラスに変えるエキサイティングな新しい編集インタラクションについて学びます。

00:00:41.000 -> 00:00:49.000
まず、iOS 16で大幅なフェイスリフトを受けた新しい編集メニューについて確認します。

00:00:49.000 -> 00:00:55.000
その後、ジェームズは新しいシステムに飛び込み、経験を見つけて置き換えます。

00:00:55.000 -> 00:01:06.000
iOS 16では、編集メニューはまったく新しいデザインが特徴で、馴染みのあるままですが、よりインタラクティブで、アクションを見つけやすくなっています。

00:01:06.000 -> 00:01:12.000
編集メニューには、使用された入力方法に基づいて代替プレゼンテーションが追加されました。

00:01:12.000 -> 00:01:26.000
タッチインタラクションの場合、編集メニューはまだおなじみのコンパクトな外観を持っていますが、ページング動作が改善され、アクションが以前よりも発見可能になります。

00:01:26.000 -> 00:01:38.000
マジックキーボードまたはトラックパッドでは、コンテキストメニューがセカンダリまたは右クリックで表示され、よりデスクトップクラスのエクスペリエンスを実現します。

00:01:38.000 -> 00:01:46.000
同様に、iPhoneのタッチインタラクションでは、新しい編集メニューが表示されます。

00:01:46.000 -> 00:01:53.000
また、Mac Catalystアプリでは、Macユーザーがよく知っているコンテキストメニューが表示されます。

00:01:53.000 -> 00:02:02.000
iOS 16では、テキスト編集メニューは、新しいデータ検出器の統合により、大きなパワーアップを取得します。

00:02:02.000 -> 00:02:13.000
これには、インライン単位と通貨変換、および選択したテキストに応じてコンテキストアクションを表示するスマートルックアップが含まれます。

00:02:13.000 -> 00:02:27.000
たとえば、Safariでアドレスを選択すると、既存の編集メニューアクションの上に「道順を取得」や「マップで開く」などのマップベースのアクションが表示されます。

00:02:27.000 -> 00:02:31.000
最良の部分は、養子縁組が不要なことです!

00:02:31.000 -> 00:02:42.000
これらの機能は、テキストインタラクションビュー、WebKit、Safari、PDFKitなど、すべてのテキスト編集メニューで利用できます。

00:02:42.000 -> 00:02:55.000
テキストビューのメニューにアクションを挿入するには、新しいTextViewDelegateメソッドを実装して、システムが提供するアクションを使用して、指定された範囲内のテキストの表示メニューをカスタマイズします。

00:02:55.000 -> 00:03:01.000
何もカスタマイズする必要がない場合は、nilを返して標準システムメニューを入手してください。

00:03:01.000 -> 00:03:08.000
UITextFieldDelegateとUITextInputにも同様の方法があり、メニューをカスタマイズすることもできます。

00:03:08.000 -> 00:03:27.000
UIMenuControllerを使用したメニュー項目の挿入は、iOS 16では廃止されました。代わりに、新しいメソッドを使用してテキスト編集メニューにメニュー要素を追加する必要があります。

00:03:27.000 -> 00:03:32.000
以下は、いくつかのカスタムアクションを含むテキストビューの例です。

00:03:32.000 -> 00:03:41.000
テキスト選択にメニューが表示されると、システムが提案したアクションの後に、カスタムの「ハイライト」と「写真を挿入」アクションが表示されます。

00:03:41.000 -> 00:03:47.000
ハイライトアクションを選択すると、期待どおりにテキストのハイライトが実行されます。

00:03:47.000 -> 00:04:01.000
次に、強調表示するものがないテキスト選択なしでメニューが表示された場合、メニューはシステムが提案したアクションの後に「写真を挿入」アクションのみを表示します。

00:04:01.000 -> 00:04:05.000
新しいAPIを使用してこれらのアクションを追加する方法を紹介します。

00:04:05.000 -> 00:04:29.000
プレゼンテーション時に動的にメニューにアクションを挿入するには、UITextViewDelegateメソッドtextView editMenuForTextIn range suggestedActionsを実装します。この例では、選択したテキストがある場合にのみ「ハイライト」アクションを追加したいので、このメソッドを使用して動的にアクションを追加できます。

00:04:29.000 -> 00:04:39.000
「写真を挿入」アクションは常に有効なので、配列に追加して、常にメニューにアクションを表示できます。

00:04:39.000 -> 00:04:50.000
最後に、カット、コピー、ペーストなどの項目を含むシステムが推奨するアクションにアクションを追加し、メニューを返します。

00:04:50.000 -> 00:04:54.000
そして、それだけです!

00:04:54.000 -> 00:05:02.000
UIEditMenuInteractionは、新しい編集メニューを強化するUIInteraction APIです。

00:05:02.000 -> 00:05:15.000
このインタラクションでは、独自のジェスチャーに基づいてテキストビューの外側に軽量編集メニューをプログラムで表示でき、セカンダリクリックでコンテキストメニューを表示するネイティブサポートがあります。

00:05:15.000 -> 00:05:25.000
iOS 16では、UIMenuControllerとその関連するすべてのAPIは、新しい編集メニューのインタラクションに置き換えられます。

00:05:25.000 -> 00:05:33.000
編集メニューを最初から表示するには、まずインタラクションを作成してビューに追加します。

00:05:33.000 -> 00:05:39.000
次に、メニューを表示するようにジェスチャーリコグナイザを設定します。

00:05:39.000 -> 00:05:50.000
メニューが間接的なポインタクリックからではなく、直接タッチでのみ表示されるようにするには、ジェスチャーリコグナイザの許可されたTouchTypesプロパティを直接タッチのみに設定してください。

00:05:50.000 -> 00:05:56.000
次に、ジェスチャーリコグナイザをビューに追加します。

00:05:56.000 -> 00:06:06.000
最後に、ジェスチャーリコグナイザが起動したら、ジェスチャーの場所にメニューを表示できるコンテンツがあるかどうかを判断します。

00:06:06.000 -> 00:06:12.000
次に、ジェスチャーの場所のソースポイントで編集メニュー設定を作成します。

00:06:12.000 -> 00:06:22.000
ソースポイントは、メニューに表示するインタラクションのビューで実行可能なアクションを決定するために使用されます。

00:06:22.000 -> 00:06:30.000
設定が完了したら、presentEditMenu(with: configuration)を呼び出すとメニューが表示されます。

00:06:30.000 -> 00:06:41.000
選択した「Jello there!」内の任意の場所を右クリックするとビュー、コンテキストメニューには、アプリのコンテンツに対して実行可能なシステムアクションが表示されます。

00:06:41.000 -> 00:06:52.000
さらに、選択したビューをタップすると、タッチが発生した場所に編集メニューが表示され、コンテキストメニューと同じアクションが表示されます。

00:06:52.000 -> 00:06:55.000
これは良いことですが、もっと良くなるかもしれません。

00:06:55.000 -> 00:07:02.000
タッチが発生した場所にメニューが表示されるのは良いことですが、実際には選択したビューのコンテンツをブロックしています。

00:07:02.000 -> 00:07:10.000
さらに、システムのデフォルトアクションではない新しい「複製」アクションをメニューに挿入したい。

00:07:10.000 -> 00:07:12.000
戻ってこれを変えましょう。

00:07:12.000 -> 00:07:32.000
選択したビューの周りにメニューを表示するには、デリゲートメソッドeditMenuInteraction targetRectFor構成を実装します。このメソッドは、メニューを表示する場所を決定するために使用されるCGRectを返し、インタラクションのビューの座標空間にあります。

00:07:32.000 -> 00:07:42.000
メソッドが実装されていない場合、またはnull CGRectが提供されている場合、メニューは設定のソースポイントから表示されます。

00:07:42.000 -> 00:07:49.000
この場合、メニューが選択したビューをオクルードするのを防ぐために、そのフレームを返します。

00:07:49.000 -> 00:08:07.000
次に、「複製」アクションを追加するには、edinMenuInteraction menuFor configuration suggestedActionsを実装し、システムが提案したアクションの後にカスタムアクションを追加します。これは、以前にテキストビューのメニューにアクションを挿入する方法と同じです。

00:08:07.000 -> 00:08:15.000
これで、選択したビューをもう一度タップすると、メニューに「Jello there!」が表示されなくなりました。代わりに、その周りに提示します。

00:08:15.000 -> 00:08:22.000
メニューが表示されると、新しい「複製」アクションも含まれており、すべてわずか数行のコードで表示されます。

00:08:22.000 -> 00:08:25.000
素晴らしい！

00:08:25.000 -> 00:08:36.000
Mac Catalystアプリの場合、編集メニューは、ユーザーがインタラクションのビューを右クリックしたときにMacで期待する使い慣れたコンテキストメニューにブリッジします。

00:08:36.000 -> 00:08:44.000
iPadのイディオムMac Catalystアプリの場合、プログラムで提示された編集メニューもコンテキストメニューにブリッジします。

00:08:44.000 -> 00:08:53.000
編集メニューのプログラムによるプレゼンテーションは、Macのイディオムアプリではサポートされていないことに注意してください。

00:08:53.000 -> 00:09:03.000
異なるプレゼンテーションスタイル間のシームレスなブリッジングを提供するために、UIEditMenuInteractionはAPIのUIMenuElementファミリの上に構築されています。

00:09:03.000 -> 00:09:10.000
これらは、サブメニューや画像のサポートなど、以前よりも柔軟性とカスタマイズ性を提供します。

00:09:10.000 -> 00:09:20.000
UIMenusを初めて使用する場合は、「Modernizing Your UI for iOS 13」を見て、メニューとアクションについて詳しく学んでください。

00:09:20.000 -> 00:09:31.000
UIMenuElementの上に構築することは、編集メニューがすでにメニューをサポートしているUIMenuSystemのような多種多様なAPIにアクセスできることを意味します。

00:09:31.000 -> 00:09:38.000
編集メニューは、既存のUIMenuSystem.contextシステムを使用してメニューを作成します。

00:09:38.000 -> 00:09:51.000
メニュービルダーの詳細と、レスポンダーチェーンのトラバーサルとコマンドの検証について詳しく知るには、「iPadアプリを次のレベルに引き上げる」をご覧ください。

00:09:51.000 -> 00:09:57.000
メニューといえば、iOS 16のUIMenuにはいくつかの新しい機能強化があります。

00:09:57.000 -> 00:10:06.000
UIMenuには、コンテキストメニューで異なるレイアウトから選択できる優先要素サイズプロパティが追加されました。

00:10:06.000 -> 00:10:15.000
小さいサイズは、メニューのサイドバイサイドの外観をよりコンパクトに見せ、より多くのアクションを1行に収めます。

00:10:15.000 -> 00:10:21.000
ミディアムサイズもアクションを横に並べて表示しますが、もう少し詳細に表示します。

00:10:21.000 -> 00:10:26.000
これは、標準の編集メニューを表示するためにテキスト編集メニューで使用されます。

00:10:26.000 -> 00:10:34.000
そして最後に、大きな要素サイズは、メニューにデフォルトの全角の外観を与えます。

00:10:34.000 -> 00:10:44.000
さらに、UIMenuElementには、アクションが実行された後に表示されたメニューを保持するための新しい.keepsMenuPresented属性があります。

00:10:44.000 -> 00:10:51.000
この属性を使用して、メニューを再表示せずにアクションを複数回実行できるようにします。

00:10:51.000 -> 00:10:55.000
それは新しい編集メニューの氷山の一角にすぎません。

00:10:55.000 -> 00:11:00.000
テキスト編集メニューをカスタマイズして、テキスト編集機能を拡張します。

00:11:00.000 -> 00:11:08.000
メニューがさまざまなプレゼンテーションスタイルで完全に見えるように、アクションにタイトルと画像があることを確認してください。

00:11:08.000 -> 00:11:19.000
最も重要なことは、プラットフォームと異なる入力方法間でのカスタマイズ性と一貫性の向上のために、新しいUIEditMenuInteractionを採用することです。

00:11:19.000 -> 00:11:24.000
新しい編集メニューのサポートを追加することは、素晴らしい第一歩です。

00:11:24.000 -> 00:11:34.000
デスクトップクラスの編集体験を完了するために、ジェームズに渡して、新しいシステムの検索と置換の経験について話します。

00:11:34.000 -> 00:11:37.000
ジェームズ・マガハーン:ああ、そこにある!

00:11:37.000 -> 00:11:44.000
こんにちは、私はUIKitエンジニアのJames Magahernです。検索と交換について話すためにここにいます。

00:11:44.000 -> 00:11:51.000
iOS 16の新機能では、アプリでテキストを見つけて置き換えるための新しいUIコンポーネントを導入しました。

00:11:51.000 -> 00:12:02.000
これはシステム全体で標準であり、多くの組み込みアプリに含まれており、ユーザーはさらに一般的に使用される編集ショートカットで筋肉の記憶を柔軟にすることができます。

00:12:02.000 -> 00:12:06.000
これはiPadで実行されている新しい検索パネルです。

00:12:06.000 -> 00:12:19.000
ハードウェアキーボードが取り付けられているときにショートカットバーでフローティングインラインから、ハードウェアキーボードなしで使用するとソフトウェアキーボードの上に置いて、自動的に移行します。

00:12:19.000 -> 00:12:25.000
iPhoneでは、よりコンパクトなレイアウトを使用して、より小さな画面サイズに適応します。

00:12:25.000 -> 00:12:33.000
自動却下、最小化、およびキーボード回避はすべてシステムによって処理されます。

00:12:33.000 -> 00:12:46.000
Macでアプリを実行するときは、検索パネルをコンテンツとインラインに表示し、AppKit検索バーと同じように動作し、ユーザーがMacで期待する使い慣れたレイアウトを使用します。

00:12:46.000 -> 00:13:02.000
UITextView、WKWebView、またはPDFViewを使用してアプリにテキストコンテンツを表示する場合、開始するために必要なのは、組み込みの検索インタラクションでisFindInteractionEnabledをtrueに設定することだけです。

00:13:02.000 -> 00:13:04.000
そんなに簡単だよ！

00:13:04.000 -> 00:13:14.000
さらに、QuickLookを使用してテキストコンテンツを表示している場合、これはすでにあなたからの作業なしで利用可能になります。

00:13:14.000 -> 00:13:28.000
ハードウェアキーボードを使用すると、findのcommand+F、find nextのcommand+G、find previousのcommand+shift+Gなどのすべての標準システムショートカットが期待どおりに動作します。

00:13:28.000 -> 00:13:33.000
これらのコマンドへのアクセスは、Macで実行しているときにメニューバーから利用できます。

00:13:33.000 -> 00:13:40.000
あなたがする必要があるのは、コンテンツを表示するビューがファーストレスポンダーになることを確認することだけです。

00:13:40.000 -> 00:13:51.000
ハードウェアキーボードを使用していないユーザーは、含まれているfindインタラクションプロパティで、presentFindNavigatorを介してプログラムでfindインタラクションを呼び出すことができます。

00:13:51.000 -> 00:13:58.000
たとえば、ナビゲーションバーの項目でこれを利用できるようにすることをお勧めします。

00:13:58.000 -> 00:14:02.000
Macで実行するときは、他にも覚えておくべきことがいくつかあります。

00:14:02.000 -> 00:14:09.000
たとえば、iOSでは、検索パネルはソフトウェアキーボードまたはショートカットバーの一部として表示されます。

00:14:09.000 -> 00:14:13.000
Macでは、あなたのコンテンツとインラインで表示します。

00:14:13.000 -> 00:14:25.000
スクロールビューに検索インタラクションをインストールする場合は、検索パネルに合わせてコンテンツ挿入を自動的に調整し、トレイトコレクションの変更に自動的に適応します。

00:14:25.000 -> 00:14:33.000
それ以外の場合は、macOSのUIで検索パネルをホストするのに十分なスペースがあることを確認する必要があります。

00:14:33.000 -> 00:14:41.000
さらに、虫眼鏡のアイコンをタップしたときに利用可能な検索オプションの標準セットを含むメニューを表示します。

00:14:41.000 -> 00:14:49.000
UIFindInteractionのoptionsMenuProviderプロパティを使用して、このメニューの内容をカスタマイズできます。

00:14:49.000 -> 00:14:53.000
これは、カスタム実装でより重要になります。

00:14:53.000 -> 00:14:59.000
そして、私が前に述べた組み込みビューの1つを使用している場合は、それだけです。

00:14:59.000 -> 00:15:11.000
アプリが完全にカスタムビューやリストビューなど、他の方法でテキストコンテンツを表示している場合でも、検索インタラクションをアプリに追加できます。

00:15:11.000 -> 00:15:14.000
やり方をお見せしましょう。

00:15:14.000 -> 00:15:21.000
検索インタラクションに関する良いニュースは、任意のビューにインストールできることです。

00:15:21.000 -> 00:15:32.000
アプリに既存の検索と置換の実装がある場合は、UIFindInteractionにブリッジし、システムのUIを活用するのは簡単です。

00:15:32.000 -> 00:15:46.000
カスタムビューの既存の検索実装がまだない場合は、特にシステムキーボードを操作するためにUITextInputプロトコルをすでに実装している場合は、始めるのが非常に簡単です。

00:15:46.000 -> 00:15:51.000
UIFindInteractionがカスタムビューでどのように機能するかは次のとおりです。

00:15:51.000 -> 00:15:58.000
カスタムビューにUIFindInteractionをインストールした後、検索インタラクションデリゲートを設定します。

00:15:58.000 -> 00:16:10.000
検索インタラクションデリゲートは、検索セッションの開始時または終了時について通知されるだけでなく、UIFindSessionsを処理する責任があります。

00:16:10.000 -> 00:16:21.000
UIFindSessionは、現在強調表示されている結果など、特定のセッションのすべての状態をカプセル化する抽象基本クラスです。

00:16:21.000 -> 00:16:30.000
また、「次の結果に進む」や「この文字列を検索する」など、UIから要求されたすべてのアクションにもサービスを提供します。

00:16:30.000 -> 00:16:40.000
この状態をすべて自分で管理したい場合は、検索インタラクションデリゲートからUIFindSessionのサブクラスを販売することを選択できます。

00:16:40.000 -> 00:16:50.000
アプリに既存の検索と置換の実装がすでにあり、それをシステムUIにブリッジしたい場合、これは良い選択肢です。

00:16:50.000 -> 00:17:05.000
それ以外の場合は、システムが状態を処理し、代わりに表示されるドキュメントの内容をカプセル化するクラスでUITextSearchingプロトコルを採用する方がはるかに良いでしょう。

00:17:05.000 -> 00:17:13.000
これを行うには、UITextSearchingFindSessionを返し、ドキュメントクラスに接続します。

00:17:13.000 -> 00:17:19.000
カスタムビューの検索実装がまだない場合は、これが最良の選択肢です。

00:17:19.000 -> 00:17:22.000
コードでこれを行う方法は次のとおりです。

00:17:22.000 -> 00:17:30.000
この例には、カスタムドキュメントクラスと、このドキュメントを表示するカスタムビューがあります。

00:17:30.000 -> 00:17:42.000
UIFindInteractionがこのビューにインストールされ、UITextSearchingFindSessionがこのドキュメントとともに「検索可能なオブジェクト」として提供されます。

00:17:42.000 -> 00:17:51.000
キーボードショートカットが期待どおりに機能するように、ビューコントローラーまたはカスタムビューのいずれかがファーストレスポンダーになることを確認してください。

00:17:51.000 -> 00:17:57.000
検索インタラクションを作成し、検索セッションを処理するためのセッションデリゲートを提供します。

00:17:57.000 -> 00:18:01.000
ここでは、ビューコントローラーはセッションデリゲートです。

00:18:01.000 -> 00:18:12.000
次に、インタラクションによって検索セッションを求められたら、検索可能なオブジェクトとしてドキュメントを提供する新しいUITextSearchingFindSessionを返すだけです。

00:18:12.000 -> 00:18:19.000
もちろん、ドキュメントクラスがUITextSearchingプロトコルに準拠していることを確認する必要があります。

00:18:19.000 -> 00:18:28.000
UITextSearchingプロトコルを実装するクラスは、ドキュメント内のテキストを実際に見つける責任があります。

00:18:28.000 -> 00:18:36.000
システムはperformTextSearchを呼び出し、結果を提供できるアグリゲータオブジェクトを渡します。

00:18:36.000 -> 00:18:42.000
アグリゲーターはUITextRangeと連携して、ドキュメントの結果を表します。

00:18:42.000 -> 00:18:51.000
これは、テキストの保存方法に意味のあるデータをカプセル化するために使用できる別の抽象クラスです。

00:18:51.000 -> 00:18:58.000
たとえば、これはWebKitを使用してテキストをレンダリングするクライアントのDOM範囲を表すことができます。

00:18:58.000 -> 00:19:04.000
アグリゲーターもスレッドセーフなので、バックグラウンドスレッドで結果を提供できます。

00:19:04.000 -> 00:19:16.000
最後に、検索インタラクションでは、カスタムビューを使用して結果を表示する方法がわからないため、 decorate() が呼び出されたときに、特定のスタイルの結果を装飾する必要があります。

00:19:16.000 -> 00:19:26.000
UITextSearching検索セッションとプロトコルは、同じインタラクションを使用して複数の可視ドキュメント間の多重化もサポートしています。

00:19:26.000 -> 00:19:52.000
言い換えれば、アプリがメールの会話ビューに似た方法でコンテンツを表示する場合、その場合の各「ドキュメント」はメールメッセージであり、ルートレベルのコレクションビューに単一の検索インタラクションをインストールし、同時にすべてのドキュメントで検索を実行できるため、ユーザーは異なるドキュメントの結果を簡単に移動できます。

00:19:52.000 -> 00:19:57.000
だから、iOS 16で新しい検索インタラクションを始めるために必要なのはそれだけです。

00:19:57.000 -> 00:20:04.000
多くのテキストコンテンツを表示するシステムビューの場合は、必ずisFindInteractionEnabledを有効にしてください。

00:20:04.000 -> 00:20:08.000
既存のfind実装をUIFindInteractionに移動します。

00:20:08.000 -> 00:20:16.000
アプリにテキスト検索がまだない場合は、UITextSearchingを実装し、UITextSearchingFindSessionを使用してください。

00:20:16.000 -> 00:20:22.000
そして最後に、アプリに競合するキーボードショートカットがないことを確認してください。

00:20:22.000 -> 00:20:31.000
そして、それがiOS 16用のアプリの編集インタラクションを更新し、それらを真のデスクトップクラスにするために必要なものです。

00:20:31.000 -> 00:20:38.000
アプリで新しいテキスト編集メニューを試して、カスタムUIに編集メニューのインタラクションを採用してください。

00:20:38.000 -> 00:20:42.000
また、アプリのテキストコンテンツを検索可能にすることで、生産性を向上させます。

00:20:42.000 -> 00:20:47.000
あなたのアプリでこれらの素晴らしい新機能を見つけるのを楽しみにしています。

00:20:47.000 -> 00:20:52.000
見てくれてありがとう!必ず「いいね！」、コメント、購読してください。

00:20:52.000 -> 23:59:59.000
。

