WEBVTT

00:00:00.000 -> 00:00:10.000
♪ ♪

00:00:10.000 -> 00:00:13.000
こんにちは、WWDCへようこそ。

00:00:13.000 -> 00:00:18.000
私の名前はデビッドです。MusicKitでより多くのコンテンツを探索する方法についてお話ししたいと思います。

00:00:18.000 -> 00:00:25.000
MusicKitフレームワークは2021年に開始され、Swiftでネイティブに音楽にアクセスして再生するための一連のAPIを提供します。

00:00:25.000 -> 00:00:32.000
このフレームワークにより、アプリがApple Musicと簡単に統合でき、Apple Musicカタログ全体にアクセスできます。

00:00:32.000 -> 00:00:36.000
今日は、MusicKitの主な機能強化についてお話ししたいと思います。 いくつかお話ししたいと思います。

00:00:36.000 -> 00:00:46.000
新しい音楽アイテムの種類、新しいリクエスト、新しいメタデータを使用して、Apple Musicカタログをさらに引き出すために、いくつかの追加から始めます。

00:00:46.000 -> 00:00:53.000
その後、パーソナライズされたコンテンツを取得して、ユーザーごとにカスタマイズされたエクスペリエンスを提供する方法について説明します。

00:00:53.000 -> 00:00:56.000
次に、Apple Musicのカタログを超えます。

00:00:56.000 -> 00:01:02.000
今年は、ユーザーのライブラリから音楽を含めることで、アプリをまったく新しいレベルに引き上げることができます。

00:01:02.000 -> 00:01:12.000
最後に、ライブラリやプレイリストにアイテムを追加したり、プレイリストを作成したり編集したりするなど、ライブラリと積極的にやり取りする方法について説明します。

00:01:12.000 -> 00:01:14.000
カタログコンテンツの追加に飛び込みましょう。

00:01:14.000 -> 00:01:22.000
MusicKitの最初のリリースでは、曲、アルバム、プレイリストなどのコアタイプを含む音楽の新しいモデルレイヤーが導入されました。

00:01:22.000 -> 00:01:32.000
今年は、キュレーターとラジオショーの2つの新しいタイプを追加して、MusicKitで新しい音楽を簡単に発見できるようにしています。

00:01:32.000 -> 00:01:49.000
さらに、MusicKitでは、カタログを検索するための優れたUIを構築したり、トップチャートにアクセスして最も人気のある曲、アルバムなどを取得したり、ドルビーアトモスの空間オーディオなどの高品質のオーディオメタデータなどの新しい属性を取得したりすることもできます。

00:01:49.000 -> 00:01:54.000
音楽の発見のための素晴らしいリソースであるキュレーターとラジオ番組から始めましょう。

00:01:54.000 -> 00:01:58.000
ここでは、キュレーターのナイキの例を見ていきます。

00:01:58.000 -> 00:02:02.000
キュレーターの他の例は、ShazamとBeats by Drです。ドレー。

00:02:02.000 -> 00:02:07.000
ここでは、このキュレーターによって生成されたすべてのプレイリストを簡単に見つけることができます。

00:02:07.000 -> 00:02:14.000
この機能により、人々は好きなプレイリストにすばやくアクセスしたり、新しい曲を見つけたり、古いお気に入りを再訪したりすることができます。

00:02:14.000 -> 00:02:18.000
では、より技術的な詳細を掘り下げてみましょう。

00:02:18.000 -> 00:02:20.000
キュレーターはさまざまな属性をホストしています。

00:02:20.000 -> 00:02:28.000
この新しいキュレータータイプの主な属性のいくつかは、名前、URL、アートワーク、および種類です。

00:02:28.000 -> 00:02:38.000
種類のプロパティは、特定のキュレーターがAppleキュレーターであるか第三者キュレーターであるかを示す「編集」または「外部」のいずれかであることができる列挙です。

00:02:38.000 -> 00:02:47.000
キュレーターはまた、そのキュレーターによって作られたプレイリストを示すプレイリスト関係を持っており、私たちが今見た音楽発見の概念に本当に奉仕しています。

00:02:47.000 -> 00:02:50.000
次に、ラジオ番組タイプがあります。

00:02:50.000 -> 00:02:59.000
「New Music Daily by Zane Lowe」や「Pop Hits Radio by Brooke Reese」などのラジオ番組は、熟練した専門家を通じて新しい音楽を発見するもう1つの方法です。

00:02:59.000 -> 00:03:06.000
キュレータータイプと同様に、ラジオ番組には、ラジオ番組の特徴である音楽を見つけるためのプレイリストの関係もあります。

00:03:06.000 -> 00:03:23.000
これら2つの新しいタイプがプレイリストとの関係を保持するように、私たちはまた、逆のロジックのためにプレイリストタイプの「キュレーター」と「ラジオショー」の2つの新しい関係を公開しています。プレイリストが与えられた場合、そのプレイリストを生成したエンティティの構造を簡単に取得できます。

00:03:23.000 -> 00:03:31.000
MusicKitでは、多数のタイプのコンテンツをカタログで検索できます。現在、キュレーターやラジオ番組などの新しいアイテムタイプのサポートを追加しています。

00:03:31.000 -> 00:03:37.000
リストは増え続けており、その結果、優れたUIの構築はますます困難になっています。

00:03:37.000 -> 00:03:43.000
だからこそ、今年は、最高の結果と提案を通じて、あなたのためにそれをはるかに簡単にしています。

00:03:43.000 -> 00:03:47.000
これらの機能強化がUIにもたらすユーティリティを見てみましょう。

00:03:47.000 -> 00:03:53.000
コンテンツを検索するために入力するときは、音楽関連の強力なオートコンプリートサポートを提供したいと思うかもしれません。

00:03:53.000 -> 00:03:59.000
そこで提案が作用し、人々が到達しようとしている可能性のある条件を提供します。

00:03:59.000 -> 00:04:06.000
さらに一歩進んで、トップの結果を表示して、人々が探しているものにすばやくアクセスすることもできます。

00:04:06.000 -> 00:04:12.000
最良の結果を得るには、アイテムの種類を気にせず、代わりに関連性に焦点を当てたいと思うかもしれません。

00:04:12.000 -> 00:04:15.000
これがトップ結果の力です。

00:04:15.000 -> 00:04:20.000
さて、トップ結果から始めて、これを実装する方法を見てみましょう。

00:04:20.000 -> 00:04:28.000
ここでは、カタログ検索リクエストを作成する既存の方法があり、検索語と表現したいアイテムの種類が必要です。

00:04:28.000 -> 00:04:35.000
応答には、要求されたタイプによって分類されたコレクションを含み、タイプ固有の結果の複数のリストを意味します。

00:04:35.000 -> 00:04:41.000
これは素晴らしいことですが、型に依存しない最も関連性の高い結果の単一のリストを公開したいと考えています。

00:04:41.000 -> 00:04:45.000
そして、この情報を要求するのは、1行を追加するのと同じくらい簡単です。

00:04:45.000 -> 00:04:53.000
ここでは、リクエストのincludeTopResultsプロパティをtrueに設定し、応答に新しいプロパティが入力されます。

00:04:53.000 -> 00:04:58.000
この新しいプロパティは、要求されたタイプの項目を含むtopResultsという名前です。

00:04:58.000 -> 00:05:02.000
印刷ステートメントの出力は次のようになります。

00:05:02.000 -> 00:05:11.000
返されるトップの結果は、単一のコレクションの曲、アーティスト、アルバムのミックスであり、関連性によって順序付けられていることがわかります。

00:05:11.000 -> 00:05:16.000
さて、私は人々が提案でより早く検索先に着くのを助ける方法を紹介します。

00:05:16.000 -> 00:05:20.000
文字列用語で提案リクエストを作成するだけです。

00:05:20.000 -> 00:05:25.000
応答を呼び出すと、提案応答が返されます。

00:05:25.000 -> 00:05:27.000
応答には、提案の配列が含まれています。

00:05:27.000 -> 00:05:34.000
また、各提案には、UIに適した表示用語と検索用語が含まれています。

00:05:34.000 -> 00:05:41.000
ユーザーが提案を選択すると、検索語で検索リクエストを実行することで、対応する結果を取得できます。

00:05:41.000 -> 00:05:46.000
カタログチャートは、最も人気のある曲を最新の状態に保つのに最適な方法です。

00:05:46.000 -> 00:05:50.000
MusicKitは、トレンドを確認するために、さまざまな種類のチャートを提供しています。

00:05:50.000 -> 00:06:01.000
提供されているチャートの種類は、最も再生された音楽、都市チャート、毎日のトップ100に対応するトップソングやトップアルバムなどのトップチャートです。

00:06:01.000 -> 00:06:06.000
また、特定のジャンルでフィルタリングする要求されたチャートを指定することもできます。

00:06:06.000 -> 00:06:09.000
コードでこれらのチャートを取得するのは非常に簡単です。

00:06:09.000 -> 00:06:15.000
カタログチャート要求は、カタログ検索要求ですでに使用されている確立されたパターンに従います。

00:06:15.000 -> 00:06:18.000
まず、チャートリクエストを初期化します。

00:06:18.000 -> 00:06:22.000
その後、好きなチャートの種類を指定できます。

00:06:22.000 -> 00:06:30.000
デフォルトでは、これは最も再生されたコンテンツを取得しますが、毎日のグローバルトップチャートや都市トップチャートを含めることもできます。

00:06:30.000 -> 00:06:33.000
最後に、チャートに含めるタイプを指定するだけです。

00:06:33.000 -> 00:06:35.000
そして、それだけです。

00:06:35.000 -> 00:06:43.000
応答の最初のプレイリストチャートにアクセスすると、毎日のグローバルトップチャートを表すMusicCatalogChartを取得します。

00:06:43.000 -> 00:06:48.000
そのアイテムは「Top 100: Global」や「Top 100: USA」などのプレイリストです。

00:06:48.000 -> 00:06:58.000
過去にMusicDataRequestを使用してカタログチャートを取得していた場合は、アイテムのコレクションにページネーションサポートが組み込まれているため、MusicKitがあなたのために仕事をするので、もはやする必要はありません。

00:06:58.000 -> 00:07:09.000
2021年には、真の多次元サウンドと明瞭さを備えた画期的なオーディオ体験を導入しました。ドルビーアトモスをサポートする空間オーディオです。

00:07:09.000 -> 00:07:15.000
この没入型体験はすでに何千もの曲で利用でき、このデータにアクセスできるようになりました。

00:07:15.000 -> 00:07:25.000
MusicKitは、Audio Variantsを通じて任意の曲やアルバムで利用可能なオーディオリソースを公開するので、この情報を他の人に伝えることができます。

00:07:25.000 -> 00:07:34.000
オーディオバリアントの例は、前述のドルビーアトモス付き空間オーディオ、ロスレスオーディオなどです。

00:07:34.000 -> 00:07:43.000
また、オーディオバリアントと並んで新しいブールプロパティを公開しています。Apple Digital Masterは、サポートされている最高品質のマスターです。

00:07:43.000 -> 00:07:51.000
このメタデータはアイテムレベルで公開されるため、オーディオバリアントは詳細ビューに最適で、このようなUIを実現できます。

00:07:51.000 -> 00:07:54.000
ここでは、アルバムの詳細ビューがあります。

00:07:54.000 -> 00:08:02.000
そして、ここでは、前述のオーディオバリアントプロパティに基づいて適切なバッジを見ることができ、ユーザーに期待できるオーディオ品質を知らせることができます。

00:08:02.000 -> 00:08:08.000
この場合、この特定のアルバムでは空間オーディオとロスレスオーディオが利用可能です。

00:08:08.000 -> 00:08:11.000
それでは、これを達成するためにコードを書く方法を見てみましょう。

00:08:11.000 -> 00:08:14.000
オーディオバリアントの読み込みは、他の拡張属性の読み込みに似ています。

00:08:14.000 -> 00:08:22.000
既存のアルバムまたは曲、この場合はアルバムを取り、withメソッドを使用してaudioVariants拡張属性をロードします。

00:08:22.000 -> 00:08:27.000
これで、detailAlbumにaudioVariantsプロパティが入力されました。

00:08:27.000 -> 00:08:32.000
ここでは、要素がAudioVariantである配列であるaudio variantsプロパティを見ることができます。

00:08:32.000 -> 00:08:40.000
これらの値を使用すると、先ほど見たように、その特定の要素で利用可能なオーディオリソースをUIで示すことができます。

00:08:40.000 -> 00:08:45.000
さて、これは素晴らしいですが、これらのオーディオバッジをトップレベルや詳細ビュー以上のもので表示したいと思うかもしれません。

00:08:45.000 -> 00:08:52.000
だからこそ、私たちはさらに一歩進んで、音楽プレーヤーのアクティブなオーディオバリアントを公開しています。

00:08:52.000 -> 00:09:01.000
アクティブなオーディオバリアントにアクセスすると、このビューでドルビーアトモスなど、現在再生中のアイテムのオーディオ品質を視覚的に表示できます。

00:09:01.000 -> 00:09:09.000
また、MusicKitプレーヤーAPIは、ユーザーの設定とネットワーク条件に基づいて正しいオーディオ品質を自動的に選択します。

00:09:09.000 -> 00:09:17.000
プレーヤーからアクティブな特性にアクセスするには、まず、観察されたオブジェクトでApplicationMusicPlayerの再生状態にアクセスします。

00:09:17.000 -> 00:09:27.000
その後、再生状態から直接アクティブなaudioVariantにアクセスできます。今、audioVariantプロパティをチェックしてdolbyAtmosであるかどうかを確認し、追加UIを追加するだけです。

00:09:27.000 -> 00:09:37.000
再生状態は観察されたオブジェクトであるため、このビューは、現在再生中のアイテムが変更されるたびに自動的に更新され、ビューが常に最新であることを確認します。

00:09:37.000 -> 00:09:42.000
カタログの追加をいくつか見てきたので、パーソナライズされたコンテンツの取得に飛び込みましょう。

00:09:42.000 -> 00:09:49.000
パーソナライズされたコンテンツは、加入者に固有のデータであり、アプリ内のすべてのユーザーにユニークでカスタマイズされた体験を提供します。

00:09:49.000 -> 00:09:59.000
通常、パーソナライズされたコンテンツには特別な認証とユーザートークンが必要ですが、MusicKitフレームワークでは、これをすべて自動化したので、面倒に対処する必要はありません。

00:09:59.000 -> 00:10:06.000
私たちが開発者にもたらしているパーソナライズされたコンテンツは、最近再生されたアイテムや個人的な推奨事項へのアクセスです。

00:10:06.000 -> 00:10:12.000
最近再生されたコンテンツは、人の音楽消費体験のための貴重なデータです。

00:10:12.000 -> 00:10:16.000
それはあなたが彼らが楽しんでいることを知っている音楽アイテムに迅速かつ簡単にアクセスすることができます。

00:10:16.000 -> 00:10:22.000
そして、新しい音楽を聴くとき、それは人々が後で戻って彼らの歴史を参照することを可能にします。

00:10:22.000 -> 00:10:29.000
アルバム、プレイリスト、ステーションなどの最近再生されたコンテナを取得するには、最近再生されたコンテナリクエストを作成できます。

00:10:29.000 -> 00:10:34.000
プレイリストやアルバムから曲を再生すると、コンテナタイプが検索されることに注意してください。

00:10:34.000 -> 00:10:43.000
応答には、タイトル、字幕、アートワークの便利なアクセサを提供する、最近再生された音楽アイテムがあります。

00:10:43.000 -> 00:10:48.000
曲やステーションなど、より具体的なタイプの最近再生されたアイテムを取得することもできます。

00:10:48.000 -> 00:10:56.000
ここでは、最近再生されたリクエストを作成し、山括弧で示される汎用パラメータを使用してソングタイプを指定します。

00:10:56.000 -> 00:10:59.000
私たちの回答には、私たちが演奏した曲のみが含まれています。

00:10:59.000 -> 00:11:02.000
さて、個人的な推薦について。

00:11:02.000 -> 00:11:11.000
個人的な推奨事項は、ユーザーのライブラリとリスニング履歴に基づいて生成されるため、アプリ体験をより親密で魅力的に感じさせます。

00:11:11.000 -> 00:11:20.000
推奨事項はテーマごとにうまく整理され、ジャンル、アーティスト、「Made for You」などのコレクションごとにグループ化されます。

00:11:20.000 -> 00:11:25.000
個人的な推薦を取得するには、個人的な推薦リクエストを作成するだけです。

00:11:25.000 -> 00:11:28.000
回答は推奨事項の集まりです。

00:11:28.000 -> 00:11:34.000
最初の推奨事項を記録すると、この特定の要素が「Made for You」の推奨事項を表していることがわかります。

00:11:34.000 -> 00:11:38.000
推奨事項には、ID、タイトル、およびnextRefreshDateがあります。

00:11:38.000 -> 00:11:45.000
nextRefreshDateは、最新の提案のためにこの推奨事項を更新する必要がある日時を表します。

00:11:45.000 -> 00:11:49.000
プレイリストのプロパティには、私のために作られたすべてのプレイリストが含まれています。

00:11:49.000 -> 00:11:52.000
推奨事項の別の例を見てみましょう。

00:11:52.000 -> 00:11:56.000
ここでは、推奨事項の応答の2番目の要素を印刷します。

00:11:56.000 -> 00:12:04.000
私はたくさんのオルタナティブ音楽を聴いていますが、この推奨事項には、さまざまなタイプ、この場合はアルバムとプレイリストのミックスが含まれています。

00:12:04.000 -> 00:12:11.000
これらは、カタログ検索のトップ結果と同様に、関連性順に並べられたアイテムの単一のコレクションにグループ化されています。

00:12:11.000 -> 00:12:21.000
では、さらに一歩進んで、ユーザーのライブラリのコンテンツをアプリに組み込むことで、音楽に関するより関連性の高い体験を作成する方法について話しましょう。

00:12:21.000 -> 00:12:39.000
今年、MusicKitを使用すると、アプリは2種類のリクエストでライブラリからアイテムを取得できます。ライブラリリクエストとライブラリセクションリクエスト、ユーザーのライブラリ内のコンテンツの検索、特にライブラリから拡張属性と関係をロードします。

00:12:39.000 -> 00:12:45.000
技術的な詳細を見る前に、ライブラリコンテンツを使用してアプリを強化する方法を見てみましょう。

00:12:45.000 -> 00:12:50.000
私はあなたの屋外ランニングを追跡するミュージックマラソンというフィットネスアプリに取り組んできました。

00:12:50.000 -> 00:12:59.000
プロジェクトにMusicKitを組み込むことで、Apple Musicアプリとこのアプリの間でコンテキストを切り替えるのではなく、アプリから直接音楽を再生できるようにします。

00:12:59.000 -> 00:13:04.000
新しいワークアウトを始めて、音楽コンテンツを探そう。

00:13:04.000 -> 00:13:12.000
ここでは、人々が彼らが気に入ると思うプレイリストにすばやくアクセスできるように、個人的な推奨リクエストから取得されたいくつかの推奨プレイリストが表示されます。

00:13:12.000 -> 00:13:17.000
ライブラリタブに行くと、空のビューであることがわかります。

00:13:17.000 -> 00:13:21.000
私の個人的なプレイリストをすべて見ることができるのは素晴らしいので、その機能を書きましょう。

00:13:21.000 -> 00:13:29.000
私はすでにこのビューの基本を処理するためにいくつかのUIを設定しています、そして今、私は私のライブラリからプレイリストをロードしたいです。

00:13:29.000 -> 00:13:33.000
まず、図書館のリクエストをします...

00:13:33.000 -> 00:13:42.000
一般的なパラメータでプレイリストを指定して、ユーザーのライブラリからプレイリストが欲しいことを示します。

00:13:42.000 -> 00:13:47.000
そして、それをローカル変数に格納し、「request」と名付けます。

00:13:47.000 -> 00:13:53.000
次に、このリクエストを受けて、応答関数を呼び出します。

00:13:53.000 -> 00:13:58.000
このメソッドは非同期スローメソッドなので、try and awaitキーワードを追加しましょう。

00:13:58.000 -> 00:14:04.000
そして、もう一度それを応答変数に格納します。

00:14:04.000 -> 00:14:11.000
次に、この応答を受け取るために状態オブジェクトを更新します。

00:14:11.000 -> 00:14:17.000
今、残っているのは、私のUIでプレイリストを見ることができるようにリストを更新することだけです。

00:14:17.000 -> 00:14:25.000
ForEachを使用して、応答の項目を反復します。

00:14:25.000 -> 00:14:30.000
そして、MusicItemCollectionで各プレイリストを取得します。

00:14:30.000 -> 00:14:35.000
プレイリストがわかったので、すでに作ったPlaylistCellに渡します。

00:14:35.000 -> 00:14:44.000
今、私たちが再実行したら...

00:14:44.000 -> 00:14:50.000
そして、アプリに戻ると、ライブラリで私の個人的なプレイリストをすべて見ることができます。

00:14:50.000 -> 00:14:57.000
今、私は個人的な推奨事項、Apple Musicカタログから何でも、そして自分の個人的なライブラリを聴くことを選ぶことができます。

00:14:57.000 -> 00:15:02.000
ライブラリのコンテンツへのアクセスがどれほど簡単かがわかったので、ライブラリのリクエストで他に何ができるかを見てみましょう。

00:15:02.000 -> 00:15:07.000
音楽ライブラリのリクエストは、ユーザーのライブラリからアイテムを取得するための強力なAPIです。

00:15:07.000 -> 00:15:15.000
iOSでは、音楽カタログからコンテンツを取得する他のリクエストとは異なり、MusicLibraryRequestは実際にネットワークからデータをロードしません。

00:15:15.000 -> 00:15:21.000
代わりに、デバイスに保存されているユーザーのライブラリのコピーからアイテムをロードします。

00:15:21.000 -> 00:15:27.000
このリクエストの基本では、必要な音楽アイテムの種類を指定するだけです。

00:15:27.000 -> 00:15:32.000
このアイテムタイプは、MusicLibraryRequestの一般的なパラメータを介して渡されます。

00:15:32.000 -> 00:15:39.000
要件に合わせて通話を細かく調整するために、リクエストにさまざまなフィルターとソートオプションを適用できます。

00:15:39.000 -> 00:15:46.000
このリクエストは、すでにダウンロードしたコンテンツを取得することもでき、完全にオフラインのエクスペリエンスをサポートします。

00:15:46.000 -> 00:15:55.000
シンプルな基本リクエストから始めましょう。ミュージックマラソンアプリで書いたのと同じリクエストですが、今回はライブラリのアルバムを依頼してください。

00:15:55.000 -> 00:15:58.000
アルバムタイプは、一般的なパラメータで指定されます。

00:15:58.000 -> 00:16:01.000
要求を実行するには、応答関数を呼び出します。

00:16:01.000 -> 00:16:11.000
出力を見ると、MusicLibraryResponseがあり、そのアイテムはユーザーの音楽ライブラリ内にあるすべてのアルバムのMusicItemCollectionです。

00:16:11.000 -> 00:16:19.000
ここでは、これらのアルバムは、さまざまなカタログリクエストの1つから得られるのと同じアルバム構造であり、同じ機能を持っていることがわかります。

00:16:19.000 -> 00:16:27.000
この例では、ライブラリ内のすべてのアルバムを取得していますが、アルバムの特定のサブセットのみを必要なシナリオがあることを知っています。

00:16:27.000 -> 00:16:34.000
そのため、MusicLibraryRequestでは、ライブラリから取得したいアイテムをより具体的にすることもできます。

00:16:34.000 -> 00:16:38.000
前に書いたのと同じリクエストを受けて、フィルターを追加しましょう。

00:16:38.000 -> 00:16:44.000
ここでは、isCompilationプロパティがtrueに等しいすべてのアルバムをロードします。

00:16:44.000 -> 00:16:52.000
フィルターメソッドを呼び出すと、Xcodeのオートコンプリートは、要求するアイテムのタイプでサポートされている特定のキーパスのみを提供します。

00:16:52.000 -> 00:16:56.000
さて、応答にはコンピレーションであるアルバムしかありません。

00:16:56.000 -> 00:16:59.000
しかし、それはMusicLibraryRequestが提供するすべての力ではありません。

00:16:59.000 -> 00:17:04.000
複数のフィルターをチェーン接続できるため、追加するたびにより洗練されたリクエストが得られます。

00:17:04.000 -> 00:17:08.000
特定のジャンルのすべてのコンピレーションが欲しかったらどうなりますか?

00:17:08.000 -> 00:17:11.000
リクエストに別のフィルターを追加できます。

00:17:11.000 -> 00:17:15.000
例えば、ここには「ダンス」という名前のジャンルのインスタンスがあります。

00:17:15.000 -> 00:17:22.000
ジャンルの関係でフィルタリングして、この特定のジャンルを含むコンパイルのみを含むように結果を制限できます。

00:17:22.000 -> 00:17:25.000
今、私たちの応答にはダンスコンピレーションのみが含まれています。

00:17:25.000 -> 00:17:29.000
すでにダウンロードされているダンスコンピレーションだけを含めるのはどうですか？

00:17:29.000 -> 00:17:33.000
これを行うには、リクエスト時にincludeOnlyDownloadedContentをtrueに設定するだけです。

00:17:33.000 -> 00:17:34.000
そして、それだけです。

00:17:34.000 -> 00:17:41.000
応答は同じMusicLibraryResponseですが、アイテムにはダウンロードされた要素のみが含まれています。

00:17:41.000 -> 00:17:50.000
ご覧のとおり、音楽ライブラリのリクエストは非常に強力で、カスタムMusicDataRequestでは不可能だった新しい機能のロックを解除します。

00:17:50.000 -> 00:17:54.000
しかし、MusicKitは、ユーザーのライブラリからデータを取得するためのさらに多くのオプションを提供します。

00:17:54.000 -> 00:17:57.000
図書館のセクションリクエストを満たします。

00:17:57.000 -> 00:18:02.000
セクション化されたリクエストは、セクションごとにグループ化されたアイテムを取得できます。

00:18:02.000 -> 00:18:07.000
その結果、セクション化された要求は2つの異なる汎用パラメータを取ります。

00:18:07.000 -> 00:18:11.000
1つ目はセクションタイプを表し、2つ目はアイテムタイプを表します。

00:18:11.000 -> 00:18:23.000
ライブラリセクション要求は、セクションまたはアイテムのいずれかに適用できるさまざまなフィルタおよびソートメソッドなど、通常のライブラリ要求と同じ機能をサポートしています。

00:18:23.000 -> 00:18:29.000
ライブラリのセクションリクエストを使用して、ジャンルごとにセクション化されたすべてのアルバムを取得する方法は次のとおりです。

00:18:29.000 -> 00:18:38.000
セクション化された応答には、「セクション」という名前のプロパティがあり、各要素は要求の最初の汎用パラメータ、この場合はジャンルに対応します。

00:18:38.000 -> 00:18:46.000
各ジャンルは、独自の属性を公開するだけでなく、アイテムプロパティを介してアクセスできるアルバムのコレクションも含まれています。

00:18:46.000 -> 00:18:50.000
これらの項目は、2番目の一般的な引数に対応しています。

00:18:50.000 -> 00:18:53.000
ここでは、ハイライトはジャンルがオルタナティブであるアルバムを示しています。

00:18:53.000 -> 00:18:59.000
そして、前述したように、フィルタリングとソートの機能もこのセクション化された要求で利用できます。

00:18:59.000 -> 00:19:06.000
ジャンル別に区切られた同じアルバムが欲しいが、アルバムはアーティストの名前でソートされたとしましょう。

00:19:06.000 -> 00:19:07.000
ソートフィルターを追加します。

00:19:07.000 -> 00:19:15.000
アルバムでartistName keyPathを指定し、これらを昇順にしたいと言うことで、応答をソートしています。

00:19:15.000 -> 00:19:21.000
セクションではなくアイテムに適用するソートを指定しているため、メソッドはsortItemsであることに注意してください。

00:19:21.000 -> 00:19:27.000
セクションを指定したい場合は、filterSectionsとsortSectionメソッドのセットが利用可能です。

00:19:27.000 -> 00:19:32.000
新しい反応を見てみましょう。 見てみましょう。

00:19:32.000 -> 00:19:37.000
アルバムがタイトルではなくアーティスト名でアルファベット順に並べられていることがわかります。

00:19:37.000 -> 00:19:48.000
ライブラリ要求とライブラリセクション要求の両方が非常に強力ですが、ユーザーのライブラリから検索結果を追加することで、音楽検索UIを補完することもできます。

00:19:48.000 -> 00:19:59.000
そのため、カタログ検索とほぼ同じように動作する新しい構造化要求を追加しましたが、カタログから結果をロードする代わりに、ユーザーのライブラリで関連するアイテムを見つけます。

00:19:59.000 -> 00:20:06.000
カタログと同様に、ライブラリの検索要求には検索語と型の配列のみが必要です。

00:20:06.000 -> 00:20:13.000
ユーザーのライブラリからアイテムを取得するさまざまな方法を見たので、拡張属性と関係を読み込むのはどうですか?

00:20:13.000 -> 00:20:22.000
ご存知かもしれませんが、MusicKitの最初のリリースでは、Apple Music APIからこれらのプロパティを簡単にロードするwithメソッドが導入されました。

00:20:22.000 -> 00:20:28.000
今年は、好ましいソースパラメータも取り込む方法で電流を増強します。

00:20:28.000 -> 00:20:38.000
この優先ソースは、Apple Musicカタログとユーザーのライブラリの両方で利用可能な拡張属性と関係について、どこからデータをロードするかを示します。

00:20:38.000 -> 00:20:47.000
また、カタログまたはライブラリにのみ存するプロパティについては、優先ソースに関係なくフェッチされ、何も無視されません。

00:20:47.000 -> 00:20:56.000
さらに、カタログリクエスト、ライブラリリクエストなど、最初のアイテムがどこから来たのかに関係なく、この機能を使用できます。

00:20:56.000 -> 00:20:58.000
それはすべてうまくいきます。

00:20:58.000 -> 00:21:02.000
ここでは、音楽アイテムの関係を受け取る既知の方法があります。

00:21:02.000 -> 00:21:09.000
アルバムのトラックをロードしており、出力を表示すると、そのアルバムのすべてのトラックを見ることができます。

00:21:09.000 -> 00:21:17.000
ただし、preferredSourceプロパティの新しい追加により、ライブラリからこの関係を取得することを指定できます。

00:21:17.000 -> 00:21:22.000
現在、私たちの出力には、ライブラリで見つかったアルバムのトラックのみが含まれています。

00:21:22.000 -> 00:21:31.000
ユーザーのライブラリからアイテムを取得できるさまざまな方法で、ユーザーがMusicKitを通じてライブラリを直接操作できるようにすることは理にかなっています。

00:21:31.000 -> 00:21:37.000
私のサンプルアプリ、ミュージックマラソンに戻って、ライブラリが提供する機能のいくつかを見てみましょう。

00:21:37.000 -> 00:21:43.000
ワークアウト中、私の個人的な推奨事項のいくつかを閲覧したいと思います。

00:21:43.000 -> 00:21:48.000
トラックを見ると、これらの曲の1つが私のワークアウトプレイリストに最適であることに気づきます。

00:21:48.000 -> 00:21:53.000
これらのセルの1つを押したままにすると、コンテキストメニューがポップアップし、この曲をプレイリストに追加できます。

00:21:53.000 -> 00:21:57.000
それを押すと、すべてのプレイリストのポップアップが再び表示されます。

00:21:57.000 -> 00:22:01.000
選択したトラックをどのプレイリストにでも追加するコードを書きましょう。

00:22:01.000 -> 00:22:13.000
私はすでに選択したアイテムをAddToPlaylistCellセルにパイプしたので、共有インスタンスを介してMusicLibraryにアクセスするだけです。

00:22:13.000 -> 00:22:23.000
「追加」メソッドを呼び出して、選択したトラックと追加するプレイリストを指定します。

00:22:23.000 -> 00:22:31.000
このメソッドは非同期スロー関数でもあるので、try and awaitキーワードをもう一度追加します。

00:22:31.000 -> 00:22:38.000
最後に、isShowingPlaylistPickerバインディング変数をfalseに設定して、ピッカーを閉じます。

00:22:38.000 -> 00:22:47.000
今、再実行してプレイリストにトラックを追加し、プレイリストの1つを選択すると、このアイテムが追加されることを期待する必要があります。

00:22:47.000 -> 00:22:53.000
アプリ内のライブラリタブに戻ると、曲がワークアウトプレイリストに追加されていることがわかります。

00:22:53.000 -> 00:22:56.000
そして、プレイリストにアイテムを追加するのはとても簡単です。

00:22:56.000 -> 00:22:59.000
ライブラリが提供する他の機能のいくつかを見てみましょう。

00:22:59.000 -> 00:23:10.000
ライブラリと対話する他のさまざまな方法は、ライブラリにコンテンツを追加したり、プレイリストを作成したり、プレイリストのメタデータとトラックリストを編集したりすることです。

00:23:10.000 -> 00:23:24.000
ユーザーの音楽ライブラリにコンテンツを追加すると、Apple Musicアプリのライブラリタブで特定の曲やアルバムを見つけることができ、設定で「ライブラリを同期」がオンになっているときにすべてのデバイス間で同期できます。

00:23:24.000 -> 00:23:34.000
この機能をアプリで直接提供することで、Apple Musicアプリとあなたのアプリの間のコンテキストの切り替えから人々を救うので、彼らはあなたが提供しているコンテンツに関わり続けることができます。

00:23:34.000 -> 00:23:46.000
また、新しく導入されたライブラリリクエストと一緒にライブラリへの追加を統合することで、アプリはこれらの結果からすぐに恩恵を受けることができ、ユーザーは好きなコンテンツに簡単にアクセスできます。

00:23:46.000 -> 00:23:51.000
この強力なサービスでも、あなたはまだ特定の音楽体験を作りたいと思うかもしれません。

00:23:51.000 -> 00:23:56.000
だから今年は、プレイリストの作成と編集をMusicKitにもたらします。

00:23:56.000 -> 00:23:59.000
ユーザーに代わってプレイリストを作成できるようになりました。

00:23:59.000 -> 00:24:07.000
また、曲やアルバム全体などのアイテムを、ユーザーのライブラリの対象となるプレイリストに追加することも許可しています。

00:24:07.000 -> 00:24:14.000
プレイリストの作成は、人々が愛するコンテンツをグループ化したり、アプリが設定したい気分に合わせるのに最適です。

00:24:14.000 -> 00:24:22.000
また、既存のプレイリストにコンテンツを追加することで、MusicKitが提供するさまざまな音楽発見ツールが人々に直接影響を与えることができます。

00:24:22.000 -> 00:24:30.000
作成したプレイリストを編集して、トラックリストとメタデータを編集して、すべてがあなたが望むとおりであることを確認できるようになりました。

00:24:30.000 -> 00:24:35.000
そして、これらはアプリ内からユーザーのライブラリと対話する方法です。

00:24:35.000 -> 00:24:39.000
最後に、MusicKitは今年いくつかの大きなアップグレードを受けました。

00:24:39.000 -> 00:24:49.000
新しいタイプ、プロパティ、検索拡張のカタログ機能強化を既存のアプリに簡単に組み込むことで、さらに優れた体験ができます。

00:24:49.000 -> 00:24:57.000
ライブラリのコンテンツと機能を統合して、まったく新しい機能のロックを解除し、ユーザーが自分の経験をコントロールできるようにします。

00:24:57.000 -> 00:25:00.000
また、MusicKitを使用すると、複数の異なるタイプのアプリを強化できます。

00:25:00.000 -> 00:25:08.000
フィットネスアプリ、ゲーム、ソーシャルメディアアプリ、マッピングアプリなどはすべて、音楽を再生または共有することで恩恵を受けることができます。

00:25:08.000 -> 00:25:12.000
さらに進むには、関連するセッションをいくつか確認してください。

00:25:12.000 -> 00:25:19.000
Swiftを深く掘り下げて、MusicKitやその他のAppleフレームワークを最大限に活用するための言語への新しい追加について学びましょう。

00:25:19.000 -> 00:25:28.000
2021年のMusicKitセッションをチェックして、フレームワークを使用するようにアプリを設定し、再生を開始し、サブスクリプションオファーを提示する方法を学んでください。

00:25:28.000 -> 00:25:37.000
また、Androidやウェブ上のApple Musicとの統合に興味がある場合は、Apple Music APIを直接使用する方法について説明する別のセッションがあります。

00:25:37.000 -> 00:25:42.000
あなたが私たちのセッションを楽しんだことを願っています、そして私たちの開発者フォーラムを通じて最新情報とエンゲージメントを維持してください。

00:25:42.000 -> 23:59:59.000
ご覧いただきありがとうございます。WWDC 2022をお楽しみください。

