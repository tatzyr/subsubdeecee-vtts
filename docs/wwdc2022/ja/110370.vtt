WEBVTT

00:00:00.000 -> 00:00:09.000
♪ ♪

00:00:09.000 -> 00:00:11.000
みなさん、こんにちは。

00:00:11.000 -> 00:00:19.000
私の名前はエイドリアンです。LLDBでの素晴らしいデバッグ体験のためにプロジェクトを設定する方法についてお話しします。

00:00:19.000 -> 00:00:23.000
LLDBは、Xcodeに同梱されている基礎となるデバッグ技術です。

00:00:23.000 -> 00:00:35.000
LLDBを使用すると、アプリケーションにブレークポイントを設定したり、実行を一時停止したり、変数やオブジェクトの状態を検査したり、コードを探索したりできます。

00:00:35.000 -> 00:00:46.000
LLDBは、コードが何をしているのかを理解するのに役立ち、コードの動作が期待から逸脱するポイントを見つけることができます。

00:00:46.000 -> 00:00:51.000
これは、コードを理解し、探索するための強力なツールです。

00:00:51.000 -> 00:00:59.000
LLDBについてもっと知りたい場合は、WWDC21の「ブレークポイントの改善を発見する」など、以前のビデオをチェックしてください。

00:00:59.000 -> 00:01:06.000
今日は、Swiftコードのデバッグに独自の意味を持ついくつかの高度なワークフローを見ていきます。

00:01:06.000 -> 00:01:10.000
サードパーティのフレームワークをアプリに統合しているのかもしれません。

00:01:10.000 -> 00:01:18.000
おそらく、あなたのアプリとあなたのチームは、あなたのコードのほとんどが継続的インテグレーションシステムによって構築されているところまで成長しました。

00:01:18.000 -> 00:01:23.000
カスタムビルドシステムを使用して、会社のインフラストラクチャと統合しているかもしれません。

00:01:23.000 -> 00:01:28.000
たぶん、あなたは他のソフトウェア開発者のためのソフトウェアを構築しています。

00:01:28.000 -> 00:01:30.000
または、LLDBについてもっと知りたいだけです。

00:01:30.000 -> 00:01:40.000
私の目標は、LLDBがどのように機能し、機能するためにビルドシステムからどのような情報が必要かをよりよく理解することです。

00:01:40.000 -> 00:01:44.000
ここに小さなプロジェクトがあり、実行例として使用する予定です。

00:01:44.000 -> 00:01:50.000
私はコンパイラエンジニアで、ゲームが好きなので、余暇にはテキストアドベンチャー用のパーサーを書きます。

00:01:50.000 -> 00:01:54.000
これは私が最近純粋なスウィフトで始めたものです。

00:01:54.000 -> 00:01:56.000
私がこれまでに持っているものをお見せしましょう。

00:01:56.000 -> 00:02:00.000
ゲームはテキストインターフェースを使用しているので、ターミナルで実行しています。

00:02:00.000 -> 00:02:07.000
すべての良い冒険と同様に、私たちは在庫を確認することから始めます。

00:02:07.000 -> 00:02:10.000
このゲームは現代的な環境で行われます。

00:02:10.000 -> 00:02:12.000
私はiPhoneを持っているのを見ました。

00:02:12.000 -> 00:02:17.000
次に、私たちの周囲を見てみましょう。 

00:02:17.000 -> 00:02:21.000
うーん、このセンサーは興味をそそられます。

00:02:21.000 -> 00:02:30.000
センサーでiPhoneを使えるかな？

00:02:30.000 -> 00:02:32.000
iPhoneを落としたの？

00:02:32.000 -> 00:02:35.000
ええと、それは私があなたに見せたかったものではありません。

00:02:35.000 -> 00:02:39.000
私のゲームにはバグがあると思います。

00:02:39.000 -> 00:02:41.000
これがデバッガトークでよかった。

00:02:41.000 -> 00:02:51.000
パーサーにブレークポイントを設定し、コマンドをもう一度実行しましょう。

00:02:51.000 -> 00:03:03.000
まず、コマンドが正しく読み込まれたことを確認する必要があります。

00:03:03.000 -> 00:03:11.000
「Words」変数には、トークン化されたコマンドが含まれています。

00:03:11.000 -> 00:03:15.000
ああ、これは期待通りにいかなかった。

00:03:15.000 -> 00:03:17.000
ここで何が起こっているのかわかりません。 わかりません。

00:03:17.000 -> 00:03:25.000
昨日は問題なくデバッガを使用していましたが、昨夜はターミナルでテキストをスタイリングするためにこのUIフレームワークを統合しました。

00:03:25.000 -> 00:03:34.000
そのフレームワークの開発者は、フレームワークの毎晩のビルドをクランクアウトする継続的インテグレーションシステムを持っており、私は最新のものと直接リンクしています。

00:03:34.000 -> 00:03:39.000
このフレームワークは私のデバッグのトラブルと関係があるのだろうか。

00:03:39.000 -> 00:03:47.000
例を挙げると、デバッグビルドを明示的にダウンロードしたにもかかわらず、フレームワークのソースコードに足を踏み入れることができないことにすでに気づきました。

00:03:47.000 -> 00:03:51.000
それを見てください。

00:03:51.000 -> 00:03:54.000
分解しか見えません。

00:03:54.000 -> 00:04:01.000
そこで何が起こったのかを理解しようとし、なぜソースコードを見ることができなかったのかを理解することから始めましょう。

00:04:01.000 -> 00:04:05.000
LLDBはソースコードを表示するために何が必要ですか?

00:04:05.000 -> 00:04:15.000
コンパイラが関数をコンパイルすると、マシンコードが生成されます。

00:04:15.000 -> 00:04:24.000
また、デバッガ用のブレッドクラムを残すため、実行可能ファイルのアドレスをソースファイルと行番号にマッピングでき、その逆も同様です。

00:04:24.000 -> 00:04:28.000
これらのブレッドクラムはデバッグ情報と呼ばれます。

00:04:28.000 -> 00:04:33.000
Appleプラットフォームでは、デバッグ情報はオブジェクトファイルに保存されます。

00:04:33.000 -> 00:04:39.000
アーカイブと配布のために、デバッグ情報を.dSYMバンドルにリンクすることができます。

00:04:39.000 -> 00:04:43.000
デバッグ情報リンカーはdsymutilと呼ばれています。

00:04:43.000 -> 00:04:50.000
LLDBはSpotlightを使用して.dSYMバンドルを見つけるので、ディスク上のどこにあるかという点で非常に柔軟です。

00:04:50.000 -> 00:04:55.000
デバッグ情報の仕組みがわかったので、例に戻りましょう。

00:04:55.000 -> 00:05:01.000
まず、LLDBが実際にフレームワークのdSYMを見つけたことを確認しましょう。

00:05:01.000 -> 00:05:04.000
画像リストコマンドでこれを行うことができます。

00:05:04.000 -> 00:05:15.000
UIフレームワークは「TerminalInterface」と呼ばれています。

00:05:15.000 -> 00:05:19.000
はい、LLDBはフレームワークのdSYMを見つけました。

00:05:19.000 -> 00:05:22.000
つまり、デバッグ情報にアクセスできるということです。

00:05:22.000 -> 00:05:30.000
「画像検索」を使用して、現在の住所に関する詳細情報を取得できます。

00:05:30.000 -> 00:05:37.000
ところで、さまざまなオプションについてもっと知りたい場合は、LLDBには優れた組み込みヘルプがあります。

00:05:37.000 -> 00:05:48.000
ああ、ソースコードがない理由がわかると思います。このソースパスは、ソースがビルドサーバーのどこにあるかを指し、ローカルマシンのどこにあるかを示しています。

00:05:48.000 -> 00:05:49.000
私たちはそれを修正することができます。

00:05:49.000 -> 00:06:04.000
LLDBには、これらのパスをリダイレクトするために使用できるソースマップが組み込まれています。

00:06:04.000 -> 00:06:09.000
今すぐコマンドを入力できますが、この変更をより永続的にしたいと思います。

00:06:09.000 -> 00:06:25.000
スキームエディタでは、製品、スキーム、スキームの編集、または再生ボタンをオプションでクリックするだけで、プロジェクトごとのLLDB initファイルを定義できます。

00:06:25.000 -> 00:06:38.000
私はすでにこのプロジェクトのために1つ追加しました。

00:06:38.000 -> 00:06:52.000
LLDBを設定したので、プロジェクトを再び実行しましょう。

00:06:52.000 -> 00:06:58.000
そして、私たちはソースコードを持っています。

00:06:58.000 -> 00:07:04.000
LLDBは、「settings set target.source-map」を使用してソースパスを再マップできます。

00:07:04.000 -> 00:07:10.000
このコマンドをプロジェクトの.lldbinitファイルに入れて、自動的に実行させることができます。

00:07:10.000 -> 00:07:18.000
あるいは、各 .dSYM バンドルには、パス プレフィックス再マッピング辞書を置くことができる XML .plist ファイルが含まれています。

00:07:18.000 -> 00:07:29.000
サーバーから最新のビルドを取得するダウンロードスクリプトがある場合は、そのスクリプトを変更して、ダウンロードした.dSYMに適切なリマップ辞書を自動的に注入できます。

00:07:29.000 -> 00:07:35.000
このプロセスの詳細については、LLDBのウェブサイトをご覧ください。

00:07:35.000 -> 00:07:44.000
ソースパスはまったく言語固有ではないため、このメソッドはSwift、C++、およびObjective-Cプロジェクトでも同様に機能します。

00:07:44.000 -> 00:07:52.000
Appleプラットフォームのシンボルの詳細については、WWDC21の「Symbolication: Beyond the basics」をご覧ください。

00:07:52.000 -> 00:08:00.000
ソースコードがビルドサーバーファームでコンパイルされると、ソースファイルへのリモートパスはマシンごとに異なる場合があります。

00:08:00.000 -> 00:08:10.000
マシンごとに1つのリマッププレフィックスを定義する必要がないように、デバッグ情報に入れる前にソースパスを正規化するようにコンパイラに指示することができます。

00:08:10.000 -> 00:08:14.000
これは、-debug-prefix-mapオプションを使用して行われます。

00:08:14.000 -> 00:08:24.000
これにより、マシン固有のパスプレフィックスを一意の正規のプレースホルダ名に置き換えることができ、LLDBのローカルパスに再マッピングできます。

00:08:24.000 -> 00:08:33.000
ソースタンジェントに行く前に、私は「単語」のオブジェクト記述を印刷しようとしていました。

00:08:33.000 -> 00:08:35.000
それはうまくいかなかった。

00:08:35.000 -> 00:08:45.000
実際、「単語」という表現を評価するだけでもうまくいかなかった。

00:08:45.000 -> 00:08:51.000
少なくとも、変数ビューで変数を見ることができます。

00:08:51.000 -> 00:09:05.000
Xcode変数ビューに相当するコンソールは、「フレーム変数」または「v」コマンドです。

00:09:05.000 -> 00:09:14.000
これらのコマンドのニュアンスについてもっと知りたい場合は、WWDC19の「LLDB: Beyond 'po'」をチェックしてください。

00:09:14.000 -> 00:09:18.000
では、poとは何ですか、なぜまだ機能していないのですか?

00:09:18.000 -> 00:09:21.000
これが何を意味するのかを理解するには、LLDBについてもっと学ぶ必要があります。

00:09:21.000 -> 00:09:25.000
リマインダーとして、LLDBはデバッガです。

00:09:25.000 -> 00:09:27.000
しかし、LLDBは単なるデバッガではありません。

00:09:27.000 -> 00:09:30.000
それはまた、コンパイラです!

00:09:30.000 -> 00:09:37.000
デバッガの機能に加えて、LLDBにはSwiftおよびClangコンパイラの完全に機能するコピーも含まれています。

00:09:37.000 -> 00:09:45.000
これらのコンパイラは、pおよびpoコマンドエイリアスを通じて知ることができるLLDBの式評価者を強化します。

00:09:45.000 -> 00:09:55.000
式評価者を使用すると、変数を見るだけでなく、計算を実行したり、関数を呼び出したり、プログラムの状態を変更したりできます。

00:09:55.000 -> 00:10:04.000
WWDC18の「XcodeとLLDBによる高度なデバッグ」をチェックして、これらのコマンドで何が可能かについてのアイデアを入手してください。

00:10:04.000 -> 00:10:09.000
デバッガはローカル変数をどのようにフォーマットしますか?

00:10:09.000 -> 00:10:15.000
コンパイラによって提供されるデバッグ情報は、変数がメモリに格納されている場所をデバッガに伝えます。

00:10:15.000 -> 00:10:22.000
しかし、その情報だけでは、LLDBは生のバイトのランダムな品揃えしか表示できません。

00:10:22.000 -> 00:10:26.000
では、LLDBはどのようにしてそれをうまくフォーマットされた出力に変えるのでしょうか?

00:10:26.000 -> 00:10:28.000
答えはタイプです。

00:10:28.000 -> 00:10:34.000
タイプ情報により、LLDBはソース変数の構造とメモリレイアウトを理解できます。

00:10:34.000 -> 00:10:45.000
タイプ情報を使用すると、LLDBは集計タイプがどのようなフィールドを持っているかを知っており、タイプはLLDBが適切なデータフォーマッタを使用してそれらをきれいに印刷できるようにします。

00:10:45.000 -> 00:10:50.000
では、型情報がどこから来るのかを見てみましょう。

00:10:50.000 -> 00:10:59.000
フレーム変数とvコマンドが存在するデバッガ側では、LLDBはDebug Infoから型情報を取得します。

00:10:59.000 -> 00:11:04.000
また、LLDBはSwiftリフレクションメタデータから型を取得します。

00:11:04.000 -> 00:11:12.000
式評価者とpoが生きているコンパイラ側では、LLDBはモジュールから型情報を取得します。

00:11:12.000 -> 00:11:21.000
このクリーンな分離はXcode 14で新しく、式評価者がなくても可変ビューが完全に機能する理由を説明しています。

00:11:21.000 -> 00:11:24.000
モジュールは、コンパイラが型宣言を整理する方法です。

00:11:24.000 -> 00:11:32.000
Swiftコンパイラはモジュールをインポートする多くの方法を知っていますが、それに飛び込む前に、便利な新機能を紹介したいと思います。

00:11:32.000 -> 00:11:38.000
コンパイラ側で起こっている問題の診断を開始するにはどうすればよいですか?

00:11:38.000 -> 00:11:42.000
今年、LLDBは新しい「swift-healthcheck」コマンドを追加しました。

00:11:42.000 -> 00:11:47.000
モジュールのインポートに失敗したかどうかを把握するための最初の停留所です。

00:11:47.000 -> 00:11:49.000
これがどのように機能するかをお見せしましょう。

00:11:49.000 -> 00:12:05.000
問題が発生した後にスウィフトヘルスチェックを実行することで、Swift式評価者設定のログにアクセスできます。

00:12:05.000 -> 00:12:11.000
ログの最後に、LLDBが「TerminalUI」Swiftモジュールのインポートに問題があったことがわかります。

00:12:11.000 -> 00:12:18.000
名前に基づいて、これはTerminalInterfaceフレームワークの実装の詳細であると仮定します。

00:12:18.000 -> 00:12:33.000
この不足しているモジュールは、selfのタイプがUI実装上で一般的であり、その型を含むモジュールがなければ、式評価者は「self」の動的型を実現できないため、問題です。

00:12:33.000 -> 00:12:37.000
フレームワークの開発者にメッセージを送り、調査を依頼します。

00:12:37.000 -> 00:12:41.000
私の経験では、彼らはいつも非常に敏感でした。

00:12:41.000 -> 00:12:45.000
誰が知っているか、多分私たちはこのビデオの終わりの前に解決策を見つけることさえできます。

00:12:45.000 -> 00:12:52.000
それまでの間、LLDBのコンパイラがSwiftモジュールを見つける方法を見てみましょう。

00:12:52.000 -> 00:12:55.000
私のアプリには独自のSwiftモジュールがあります。

00:12:55.000 -> 00:13:00.000
Foundationなどのシステムフレームワークをインポートする可能性があります。

00:13:00.000 -> 00:13:06.000
システムフレームワークは、SDKに存在するテキストの安定したSwiftインターフェイスファイルです。

00:13:06.000 -> 00:13:16.000
Swiftモジュールは、モジュールマップファイルの助けを借りてグループ化された1つ以上のヘッダーファイルの派手な名前であるClangモジュールをインポートする可能性があります。

00:13:16.000 -> 00:13:21.000
Clangモジュールは、他のClangモジュールに依存することができます。

00:13:21.000 -> 00:13:26.000
私のアプリは、ローカルに構築されたフレームワークに属するSwiftモジュールをインポートすることもあります。

00:13:26.000 -> 00:13:32.000
また、SDKの一部ではないテキストのSwiftインターフェイスファイルをインポートすることもできます。

00:13:32.000 -> 00:13:39.000
方法を知りたい場合は、WWDC19の「Binary Frameworks in Swift」をチェックしてください。

00:13:39.000 -> 00:13:47.000
私のアプリは、Swiftコードを含む静的ライブラリとリンクする可能性があり、それにはSwiftモジュールも付属しています。

00:13:47.000 -> 00:13:49.000
うーん、まだ終わってないけどね。

00:13:49.000 -> 00:13:54.000
Clangモジュールをインポートできるブリッジングヘッダーもあることに言及する必要があります。

00:13:54.000 -> 00:14:02.000
最後に、LLDBのみの特別な機能として、一部のモジュールの内容はデバッグ情報だけで再構築できます。

00:14:02.000 -> 00:14:04.000
それは多くの情報源です!

00:14:04.000 -> 00:14:07.000
LLDBはそれらをすべてどのように見つけますか?

00:14:07.000 -> 00:14:12.000
LLDBがモジュールを見つけることができるようにモジュールをパッケージ化するのは、ビルドシステムの仕事です。

00:14:12.000 -> 00:14:16.000
システムフレームワークのモジュールはSDKにとどまります。

00:14:16.000 -> 00:14:22.000
LLDBは、プログラムに添付されているときに読み取るために一致するSDKを見つけます。

00:14:22.000 -> 00:14:29.000
オブジェクトファイルから直接デバッグする場合、LLDBはビルド時にあったすべての非SDKモジュールを見つけます。

00:14:29.000 -> 00:14:40.000
Dsymutilは、aと呼ばれるデバッグ情報アーカイブをパッケージ化できます。すべての動的ライブラリ、フレームワークまたはdylib、および実行可能ファイルのDSYMバンドル。

00:14:40.000 -> 00:14:49.000
各.dSYMバンドルには、ブリッジングヘッダー、テキストSwiftインターフェイスファイル、および最も重要なデバッグ情報を含むバイナリSwiftモジュールを含めることができます。

00:14:49.000 -> 00:14:51.000
それはすべてをカバーしています。

00:14:51.000 -> 00:14:53.000
すべて？

00:14:53.000 -> 00:14:59.000
静的アーカイブに属するSwiftモジュールを除くすべて。

00:14:59.000 -> 00:15:05.000
Swiftモジュールをdsymutilがピックアップするには、リンカーに登録する必要があります。

00:15:05.000 -> 00:15:10.000
動的ライブラリと実行可能ファイルの場合、ビルドシステムは自動的にこれを行います。

00:15:10.000 -> 00:15:18.000
しかし、静的アーカイブはリンカーによって生成されるのではなく、zipファイルのようなオブジェクトファイルのコレクションにすぎません。

00:15:18.000 -> 00:15:29.000
つまり、リンカにSwiftモジュールを登録する責任は、静的アーカイブをリンクするすべての実行可能または動的ライブラリにあります。

00:15:29.000 -> 00:15:34.000
多くの場合、Xcodeのビルドシステムはあなたのためにこれを行います。

00:15:34.000 -> 00:15:44.000
しかし、独自のカスタムビルドシステムを維持している場合、またはカスタムビルドルールを定義している場合、これは注意すべきことです。

00:15:44.000 -> 00:15:52.000
Appleリンカーを使用する場合、Swiftモジュールは-add-ast-pathオプションで登録する必要があります。

00:15:52.000 -> 00:15:57.000
ビルドログを確認して、これが当てはまることを確認してください。

00:15:57.000 -> 00:16:08.000
また、dsymutilを使用して実行可能ファイルのシンボルテーブルをダンプし、「swiftmodule」をgrepして、それが機能したことを確認することもできます。

00:16:08.000 -> 00:16:20.000
Linuxなどの他のプラットフォームでは、swiftドライバーは、バイナリSwiftモジュールファイルを残りのデバッグ情報と一緒にバイナリにリンクできるオブジェクトに変換する-modulewrapアクションをサポートしています。

00:16:20.000 -> 00:16:23.000
LLDBはそこでそれを見つけるでしょう。

00:16:23.000 -> 00:16:27.000
フレームワークの開発者は信じられないほど反応が良かったです。

00:16:27.000 -> 00:16:33.000
私たちが疑ったように、フレームワークのビルドシステムの一部として静的アーカイブが使用されていることがわかりました。

00:16:33.000 -> 00:16:38.000
そして、dSYMバンドルから欠けていた静的アーカイブに属するのはSwiftモジュールでした。

00:16:38.000 -> 00:16:41.000
私は今、フレームワークの固定バージョンをインストールしました。

00:16:41.000 -> 00:16:49.000
不足している静的モジュールをリンカーに登録したので、dsymutilはそれを収集することができました。

00:16:49.000 -> 00:16:54.000
今、自己は解決することができます。

00:16:54.000 -> 00:17:01.000
そして、「単語」のオブジェクトの説明を印刷することができます。

00:17:01.000 -> 00:17:12.000
とにかくコンソールを使用しているので、sエイリアスを使用してparseFrom関数に足を踏み入れています。

00:17:12.000 -> 00:17:26.000
そして今、私たちはまた、ここで単なるコピーアンドペーストエラーであるバグを簡単に見つけることができます。

00:17:26.000 -> 00:17:53.000
そして、私たちは行方不明のSwiftモジュールのパズルだけでなく、ゲームの最初のパズルも解決しました。

00:17:53.000 -> 00:17:57.000
締めくくる前に、注意すべき詳細がもう1つあります。

00:17:57.000 -> 00:18:04.000
Swiftコンパイラは、Clangヘッダーの検索パスやその他の関連オプションをバイナリ.swiftmoduleファイルにシリアル化します。

00:18:04.000 -> 00:18:11.000
Clangモジュールの依存関係のインポートがビルド中に機能するので、これは素晴らしいことです。

00:18:11.000 -> 00:18:16.000
しかし、別のマシンで構築する場合、これらのローカルパスは有害になる可能性があります。

00:18:16.000 -> 00:18:25.000
したがって、バイナリ.swiftmoduleを別のマシンに出荷する前に、-no-serialize-debugging-optionsコンパイラフラグを使用して構築することを検討してください。

00:18:25.000 -> 00:18:32.000
Xcodeでは、これはSWIFT_SERIALIZE_DEBUGGING_OPTIONS設定で制御されます。

00:18:32.000 -> 00:18:38.000
次のいずれかの設定で、これらの検索パスをLLDBに再導入できます。

00:18:38.000 -> 00:18:40.000
私たちが学んだことをまとめましょう。

00:18:40.000 -> 00:18:47.000
あるマシンから別のマシンにコードを出荷したい場合は、どのレベルのデバッグを行うことを期待しているかを自問する必要があります。

00:18:47.000 -> 00:18:59.000
たとえば、バイナリフレームワークを別の開発者に出荷し、デバッガでコードに足を踏み入れることを期待していない場合は、Swiftモジュールをテキストの.swiftinterfaceファイルとして出荷するのが最善です。

00:18:59.000 -> 00:19:15.000
しかし、開発者がダウンロードしたビルドアーティファクトをデバッグすることが期待されるビルドサーバーまたは継続的インテグレーションシステムを設定する場合は、バイナリSwiftモジュールを構築し、検索パスのシリアル化をオフにすることを検討する必要があります。

00:19:15.000 -> 00:19:21.000
また、-debug-prefix-mapオプションを使用して、デバッグ情報でサーバー上のソースパスを正規化することもできます。

00:19:21.000 -> 00:19:24.000
私があなたのために持っているのはそれだけです。

00:19:24.000 -> 00:19:30.000
今日は、デバッガとコンパイラとしてのLLDBの二重の性質について学びました。

00:19:30.000 -> 00:19:38.000
デバッガは、機能するためにデバッグ情報とリフレクションメタデータを必要とし、Xcode変数ビューとvコマンドを提供します。

00:19:38.000 -> 00:19:43.000
コンパイラはモジュールを必要とし、検索パスに敏感です。

00:19:43.000 -> 00:19:47.000
Expr、p、poコマンドの背後にあります。

00:19:47.000 -> 00:19:54.000
コンパイラ診断を取得する良い方法は、LLDBの新しいswift-healthcheckコマンドです。

00:19:54.000 -> 23:59:59.000
見てくれてありがとう!♪ ♪

