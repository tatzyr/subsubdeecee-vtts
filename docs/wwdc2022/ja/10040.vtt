WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:14.000
ガブリエル・ティン:こんにちは、私たちのセッション「アプリ内購入の統合と移行を探る」へようこそ。

00:00:14.000 --> 00:00:22.000
このセッションは2つの部分に分かれています。1つはApp Store Server APIへの移行専用で、もう1つはApp Store Server Notifications Version 2への移行専用です。

00:00:22.000 --> 00:00:27.000
私の名前はガブリエルで、App Store Server APIに移行する方法について話し合っています。

00:00:27.000 --> 00:00:33.000
アレックス・ベイカー：私の名前はアレックスです。App Storeサーバー通知バージョン2への移行をご案内します。

00:00:33.000 --> 00:00:38.000
ガブリエル：まず、App Store Server APIとApp Store Server通知の簡単な紹介から始めましょう。

00:00:38.000 --> 00:00:45.000
昨年、データを取得し、サーバーから操作を実行するための強力で安全で効率的な方法として、App Store Server APIを導入しました。

00:00:45.000 --> 00:00:58.000
受け取ったデータが改ざんされ、あなたのために意図され、App Storeによって署名されていることを確認できるように、JSON Web署名またはJWS形式で署名された、必要なデータのみを提供することを目指しています。

00:00:58.000 --> 00:01:10.000
たとえば、App Store Server APIエンドポイントの1つであるGet Transaction Historyエンドポイントは、新しいフィルタとソート機能と組み合わせて、元のTransactionIdだけで、指定したトランザクションのセットを取得できます。

00:01:10.000 --> 00:01:22.000
App Storeサーバー通知バージョン2のペインでは、表現できるサブスクリプションの状態の数が増えるにつれて、通知バージョン2はサブスクリプションのすべての可能な状態をリアルタイムで更新します。

00:01:22.000 --> 00:01:30.000
私たちは、情報を求めることなく、購読者に何が起こっているかについて知る必要があるすべての情報を積極的に提供することを目指しています。

00:01:30.000 --> 00:01:33.000
アレックスは、このセッションの彼の部分でこれをもっと説明します。

00:01:33.000 --> 00:01:37.000
これらの機能を簡単かつ効果的に使用することが興味があるなら、このセッションはあなたのためです。

00:01:37.000 --> 00:01:46.000
App Store Server APIとApp Store Server Notifications Version 2の使用を開始する方法と、いくつかの移行のヒントとベストプラクティスについて説明します。

00:01:46.000 --> 00:01:53.000
これらのそれぞれの詳細については、以下にリストされているこれらの追加セッションを参照してください。

00:01:53.000 --> 00:01:57.000
それでは、App Store Server APIへの移行について話し合いましょう。

00:01:57.000 --> 00:02:02.000
まず、App Store Server APIの使用を開始する方法について説明します。

00:02:02.000 --> 00:02:06.000
次に、JSON Webトークンに署名する詳細をいくつか掘り下げます。

00:02:06.000 --> 00:02:13.000
第三に、App Storeから受け取った署名された取引が本物であることを確認する方法を実演します。

00:02:13.000 --> 00:02:19.000
最後に、verifyReceiptからApp Store Server APIに移行する方法について説明します。

00:02:19.000 --> 00:02:20.000
始めましょう。

00:02:20.000 --> 00:02:39.000
まず、異なるバージョンのStoreKitでApp Store Server APIを使用する方法について話しましょう。まず、オリジナルのStoreKitだけで、次にStoreKit 2だけで、その後、StoreKit 2をサポートするiOSバージョンを使用する両方のクライアント、つまりiOS 15以上のクライアントとそうでないクライアントの両方を同時にサポートする方法について説明します。

00:02:39.000 --> 00:02:43.000
まず、App Store Server APIへのリクエストがどのように見えるかを見てみましょう。

00:02:43.000 --> 00:02:49.000
ここにリストされている5つのAPIは、originalTransactionIdをパスパラメータとして利用していることがわかります。

00:02:49.000 --> 00:02:58.000
これにより、領収書、署名されたトランザクション、署名された更新、および通知から受け取った元のTransactionIdを使用して、これらのAPIを簡単に呼び出すことができます。

00:02:58.000 --> 00:03:00.000
次はルックアップオーダーIDエンドポイントです。

00:03:00.000 --> 00:03:05.000
このエンドポイントは、代わりに、サポートクエリに顧客から提供されたorderIdを使用します。

00:03:05.000 --> 00:03:16.000
これは、各トランザクションの顧客領収書にorderIdが提供されますが、元のTransactionIdは提供されないため、顧客から直接の質問をよりよく支援できるようにするためです。

00:03:16.000 --> 00:03:21.000
これにより、顧客が手元に持っているデータを使用して、顧客の問い合わせに直接対応できます。

00:03:21.000 --> 00:03:28.000
ここにリストされている最後のエンドポイントは通知関連で、アレックスはこのセッションの彼の部分で触れます。

00:03:28.000 --> 00:03:33.000
次に、Original StoreKitでオリジナルのTransactionIdsを入手できる場所を見てみましょう。

00:03:33.000 --> 00:03:48.000
統一されたアプリレシートでverifyReceiptを呼び出すと、App Store Server APIを呼び出すときに使用する元のTransactionIdは、このユーザーが購入した各トランザクションの領収書、および最新の_receipt_infoとpending_renewal_infoのin_appフィールドに戻ってきます。

00:03:48.000 --> 00:03:59.000
オリジナルのStoreKitトランザクションからoriginalTransactionIdを取得する方法がわかったので、顧客、App Storeサーバー、サーバー間のフロー全体を見てみましょう。

00:03:59.000 --> 00:04:02.000
まず、サーバーでアプリのレシートを取得します。

00:04:02.000 --> 00:04:08.000
次に、アプリのレシートを受け取り、サーバーからverifyReceiptを呼び出します。

00:04:08.000 --> 00:04:11.000
これにより、デコードされた領収書が返されます。

00:04:11.000 --> 00:04:17.000
デコードされた領収書から、以前に示したのとまったく同じ方法で、元のTransactionIdをすべて収集します。

00:04:17.000 --> 00:04:27.000
次に、収集された元のTransactionIdsのいずれかを使用して、トランザクション履歴の取得エンドポイントを呼び出すことができます。これにより、このユーザーのトランザクションの履歴が署名されたトランザクションとして返されます。

00:04:27.000 --> 00:04:34.000
これらの取引には、非消耗品、返金された消耗品、非更新サブスクリプション、および自動更新サブスクリプションが含まれます。

00:04:34.000 --> 00:04:45.000
次に、特定のサブスクリプションの最新の署名付きトランザクションと署名付き更新情報を取得したい場合は、対応するoriginalTransactionIdを使用してGet All Subscription Statusesエンドポイントを呼び出します。

00:04:45.000 --> 00:04:52.000
これにより、指定された元のTransactionIdに対応するサブスクリプションのすべての署名済みトランザクションと更新が返されます。

00:04:52.000 --> 00:04:58.000
次に、StoreKit 2トランザクションの場合、元のTransactionIdがどこにあるかを見てみましょう。

00:04:58.000 --> 00:05:03.000
これは、トランザクションから元のTransactionIdを取得するためのクライアントのコードです。

00:05:03.000 --> 00:05:15.000
StoreKit 2をサポートするデバイス、つまりiOS 15以降のデバイスでは、検証済みでデコードされたトランザクションで元のIDプロパティを取得して、元のTransactionIdを取得できます。

00:05:15.000 --> 00:05:28.000
さて、サーバー側を見ると、署名されたJWSトランザクションの例を次に示します。これは、App Store Server APIおよびApp Store Server通知から署名されたトランザクションと署名された更新で受け取るデータタイプです。

00:05:28.000 --> 00:05:34.000
ここでは、originalTransactionIdがトップレベルのフィールドであることがわかります。

00:05:34.000 --> 00:05:41.000
次に、顧客、App Storeサーバー、およびStoreKit 2トランザクションのサーバー間のフロー全体を見てみましょう。

00:05:41.000 --> 00:05:44.000
まず、デバイスで署名されたトランザクションを取ります。

00:05:44.000 --> 00:05:48.000
StoreKit 2を使用すると、このトランザクションをデバイス上で確認できます。

00:05:48.000 --> 00:05:58.000
オンデバイスステータスリスナー、トランザクションリスナー、または最後のトランザクションを使用すると、最新のトランザクション、キャンセル、払い戻しが更新され、記録保持のためにサーバーに送信できます。

00:05:58.000 --> 00:06:05.000
たとえば、これらはサブスクリプションの更新、サブスクリプションオファーの償還、有効期限などについて更新されます。

00:06:05.000 --> 00:06:07.000
トランザクションをサーバーに送信します。

00:06:07.000 --> 00:06:19.000
Alexが次のセクションで詳しく説明するApp Store Server Notificationsと組み合わせることで、App Store Server APIを呼び出すことなく、サブスクリプションの最新のステータスと状態を最新の状態に保つことができます。

00:06:19.000 --> 00:06:33.000
サブスクリプションの更新日を延長するなど、サブスクリプションの操作を実行する必要がある場合は、署名されたトランザクションから元のTransactionIdを使用して、対応するエンドポイントを呼び出し、必要なデータを取り戻すことができます。

00:06:33.000 --> 00:06:42.000
オリジナルのStoreKitとStoreKit 2でApp Store Server APIを使用する方法を見たので、StoreKitとStoreKit 2の両方をサポートする方法について話しましょう。

00:06:42.000 --> 00:06:47.000
StoreKit 2を完全に採用しなくても、App Store Server APIを利用できます。

00:06:47.000 --> 00:06:52.000
前述のように、元のStoreKitの領収書から元のTransactionIdを取得できます。

00:06:52.000 --> 00:06:59.000
また、JWSトランザクションからStoreKit 2で元のTransactionIDを取得することもできます。

00:06:59.000 --> 00:07:04.000
App Store Server APIは、他のAPIとは独立して使用することもできます。

00:07:04.000 --> 00:07:07.000
これは、他のAPIの特定のバージョンの使用とは関係ありません。

00:07:07.000 --> 00:07:13.000
App Storeサーバー通知に関しては、バージョン1またはバージョン2の通知で使用できます。

00:07:13.000 --> 00:07:24.000
サブスクリプションの変更が発生した場合に通知し、安全なJWS形式などを使用するため、バージョン2を使用することをお勧めします。アレックスはこのセッションの彼の部分でさらに掘り下げます。

00:07:24.000 --> 00:07:31.000
ただし、バージョン1の通知または通知なしで、App Store Server APIを個別に使用できます。

00:07:31.000 --> 00:07:38.000
次に、以前に説明した移行手順を完了した後、新しい購入を処理する方法について話し合いましょう。

00:07:38.000 --> 00:08:06.000
元のStoreKitを使用してデバイスでの新しい購入をサポートするには、新しい領収書を受け取り、サーバーに送信し、途中で新しいデータを収集しながら、以前に示したのとまったく同じ手順を実行できます。新しい領収書でverifyReceiptを呼び出し、最新の領収書の新しいoriginalTransactionIdでデコードされた領収書を取得し、それらの元のTransactionIdsをレシートのin_appセクションの他の元のTransaction

00:08:06.000 --> 00:08:18.000
次に、新しいoriginalTransactionIdを取得し、対応するサブスクリプションの最新のステータスを取得するためにすべてのサブスクリプションステータスエンドポイントを呼び出す必要がある場合など、必要に応じてApp Store Server APIを呼び出すことができます。

00:08:18.000 --> 00:08:29.000
Original StoreKitとStoreKit 2の両方でApp Store Server APIを使用する方法を取り上げたので、App Store Server APIを呼び出すための要件であるJSON Web Tokensに署名する詳細をいくつか掘り下げてみましょう。

00:08:29.000 --> 00:08:39.000
開発者アカウントがApp Store Server APIの発信者であることを認証するために、JWTとも呼ばれるJSON Webトークンを使用してリクエストを認証します。

00:08:39.000 --> 00:08:45.000
このトークンは、サーバーからの呼び出しの承認ヘッダーとして、すべてのリクエストに含める必要があります。

00:08:45.000 --> 00:08:49.000
JWTは、ヘッダー、ペイロード、および署名で構成されています。

00:08:49.000 --> 00:08:55.000
次に、アプリケーションに固有のJWTを構築する方法について説明します。

00:08:55.000 --> 00:09:00.000
ここでは、JSON Webトークンがどのように構成されているか、およびヘッダーとペイロードの構造を確認できます。

00:09:00.000 --> 00:09:16.000
トークン自体は、ピリオドで区切られた3つの部分に分けることができます。ベース64エンコードされたヘッダー、ベース64エンコードされたペイロード、および署名シークレットを使用して署名されたベース64エンコードされたヘッダーとペイロードで構成される署名です。

00:09:16.000 --> 00:09:21.000
ヘッダーは、データに署名する方法に関するメタデータを含むこれらのフィールドで構成されています。

00:09:21.000 --> 00:09:27.000
ここで重要なフィールドの1つは、App Store Connectの秘密鍵IDであるキーIDです。

00:09:27.000 --> 00:09:32.000
これは、JWTに署名するために使用するキーと一致する必要があります。

00:09:32.000 --> 00:09:37.000
ペイロードには、特定のアプリケーションに関する追加情報が含まれています。

00:09:37.000 --> 00:09:46.000
APIキーの取得方法に関する追加情報とガイダンスについては、記事「App Store Server APIで使用するAPIキーの作成」を参照してください。

00:09:46.000 --> 00:09:53.000
これらの各フィールドの詳細については、記事「APIリクエストのトークンの生成」を参照してください。

00:09:53.000 --> 00:10:02.000
すべての適切な情報を含むヘッダーとペイロードを取得したら、次にkeyIdに対応する証明書を使用してJWTに署名します。

00:10:02.000 --> 00:10:06.000
これは、言語に関係なく使用できるコア疑似コードです。

00:10:06.000 --> 00:10:12.000
まず、先ほど見たヘッダーで提供されたキーIDに対応する秘密鍵があることを確認してください。

00:10:12.000 --> 00:10:19.000
次に、JWTライブラリが公開する署名関数を秘密鍵、ヘッダー、およびペイロードで呼び出します。

00:10:19.000 --> 00:10:27.000
ヘッダーには署名アルゴリズムが含まれているため、JWTライブラリは提供されたアルゴリズムに従って署名します。

00:10:27.000 --> 00:10:34.000
最後に、Get All Subscription StatusesエンドポイントへのcURL呼び出しを認証する際のこのトークンの使用例を次に示します。

00:10:34.000 --> 00:10:41.000
${token}と${originalTransactionId}を、それぞれ生成したトークンと目的のoriginalTransactionIdの値に置き換えます。

00:10:41.000 --> 00:10:49.000
次に、あなたが受け取る署名されたトランザクションがあなたのものであり、App Storeによって署名されていることを確認する方法について話しましょう。

00:10:49.000 --> 00:11:00.000
署名されたトランザクションは、本質的には、JavaScript Object Notation、または暗号的に署名されたJSONオブジェクトであり、App Storeとサーバーの間で改ざんされた場合、それを検出できます。

00:11:00.000 --> 00:11:04.000
署名されたトランザクションは、JSON Web署名、またはJWS形式で署名されます。

00:11:04.000 --> 00:11:09.000
App Storeが送信する署名済みのトランザクションは、JWS形式で到着します。

00:11:09.000 --> 00:11:16.000
受け取ったJWSを確認することで、データがApp Storeから来て、コンテンツが改ざんされていることを確認します。

00:11:16.000 --> 00:11:20.000
では、署名されたトランザクションを検証する方法を見てみましょう。

00:11:20.000 --> 00:11:23.000
まず、ベース64はヘッダーをデコードします。

00:11:23.000 --> 00:11:27.000
次に、algクレームを介して使用する署名アルゴリズムを決定できます。

00:11:27.000 --> 00:11:31.000
これは、JWSの検証の一部として使用されます。

00:11:31.000 --> 00:11:39.000
x5cクレームの証明書チェーンはAppleによって発行され、クレームの検証は、データが適切に署名され、改ざんされていないことを示しています。

00:11:39.000 --> 00:11:46.000
JWSの検証方法の詳細については、App Storeの開発者ドキュメントを参照してください。

00:11:46.000 --> 00:11:50.000
本質的に、x5cチェーンは証明書のチェーンです。

00:11:50.000 --> 00:11:57.000
証明書チェーンの検証が成功すると、データは信頼できること、データはAppleによって署名されていることがわかります。

00:11:57.000 --> 00:12:01.000
証明書チェーンの注文事項。最初にルート証明書が来ます。

00:12:01.000 --> 00:12:08.000
このルート証明書の後には、これらの証明書のそれぞれが以前の証明書によって署名されている追加の証明書が続く場合があります。

00:12:08.000 --> 00:12:13.000
チェーンの最後の証明書をリーフ証明書と呼びます。

00:12:13.000 --> 00:12:18.000
最初の証明書はルート証明書と呼ばれ、自己署名されています。

00:12:18.000 --> 00:12:22.000
この証明書は、Appleの認証局から取得したルート証明書と一致する必要があります。

00:12:22.000 --> 00:12:27.000
証明書が一致しない場合、チェーンは信頼されるべきではありません。

00:12:27.000 --> 00:12:33.000
チェーンの最後の証明書であるリーフ証明書は、JWSに署名するために使用される証明書です。

00:12:33.000 --> 00:12:38.000
以下は、App Storeが送信するJWSのヘッダーがどのように見えるかの例です。

00:12:38.000 --> 00:12:42.000
まず、JWSに署名するために使用されるアルゴリズムです。

00:12:42.000 --> 00:12:48.000
次はx5c証明書チェーンで、証明書は順番にリストされています。

00:12:48.000 --> 00:12:53.000
それでは、x5c証明書チェーンの生成が高レベルの概要からどのように見えるかを見てみましょう。

00:12:53.000 --> 00:12:57.000
Appleの認証局のルート証明書から始めます。

00:12:57.000 --> 00:13:02.000
次に、ルート証明書を使用して中間署名証明書に署名します。

00:13:02.000 --> 00:13:08.000
中間署名証明書は、リーフ証明書に署名するために使用されます。

00:13:08.000 --> 00:13:14.000
X5c証明書チェーンの生成がどのように見えるかを取り上げたので、チェーンの検証がどのように見えるかを見てみましょう。

00:13:14.000 --> 00:13:20.000
リーフ証明書から始めて、中間署名証明書によって署名されていることを確認します。

00:13:20.000 --> 00:13:25.000
次に、中間署名証明書がルート証明書によって署名されていることを確認します。

00:13:25.000 --> 00:13:29.000
さらに、ルート証明書はApple認証局の証明書と一致する必要があります。

00:13:29.000 --> 00:13:35.000
これらの手順がすべて成功すると、チェーン全体が正当なものとして検証されます。

00:13:35.000 --> 00:13:38.000
証明書チェーンを検証する方法について話しましょう。

00:13:38.000 --> 00:13:43.000
これは、OpenSSLを使用してx5c証明書チェーンを検証するコマンドです。

00:13:43.000 --> 00:13:49.000
これを細かく分割すると、大まかに言えば、検証コマンドを使用すると、検証のために証明書を渡すことができます。

00:13:49.000 --> 00:13:57.000
信頼できるフラグを使用すると、信頼する証明書、つまり、次の証明書を検証するために使用される証明書を提供できます。

00:13:57.000 --> 00:14:04.000
この場合、Apple認証局から取得したルート証明書を渡しているため、信頼できます。

00:14:04.000 --> 00:14:10.000
これを使用して、チェーン内の次の証明書であるWWDR証明書を検証します。

00:14:10.000 --> 00:14:18.000
信頼できないフラグを使用すると、信頼できる証明書を使用して検証したい証明書または証明書を提供できます。

00:14:18.000 --> 00:14:25.000
ここでは、まず、ルート証明書で署名されたApple認証局からのWWDR証明書を渡します。

00:14:25.000 --> 00:14:29.000
これは、x5cチェーンの2番目の証明書と一致する必要があります。

00:14:29.000 --> 00:14:36.000
そして最後に、ここのリーフ証明書は、前の証明書によって署名された最後の証明書です。

00:14:36.000 --> 00:14:41.000
検証に成功すると、成功コードが返されます。

00:14:41.000 --> 00:14:44.000
その後、デコードされた情報の使用に進むことができます。

00:14:44.000 --> 00:14:49.000
検証に失敗した場合は、返されたエラーコードに基づいて問題を判断します。

00:14:49.000 --> 00:14:53.000
検証できない場合、このデータは改ざんされる可能性があり、使用すべきではありません。

00:14:53.000 --> 00:15:02.000
OpenSSLを使用したx5c証明書チェーンの検証に関する完全な手順については、App Storeの開発者ドキュメントを参照してください。

00:15:02.000 --> 00:15:06.000
署名されたトランザクションを検証する方法に関する疑似コードは次のとおりです。

00:15:06.000 --> 00:15:10.000
まず、確認したいJWSを入手してください。

00:15:10.000 --> 00:15:14.000
次に、JWSライブラリが検証に必要な証明書を取得します。

00:15:14.000 --> 00:15:19.000
適切な証明書を使用して、JWSライブラリの検証機能を呼び出します。

00:15:19.000 --> 00:15:27.000
JWSに署名する証明書はリーフ証明書ですが、一部のライブラリではチェーン全体を渡す必要があります。

00:15:27.000 --> 00:15:31.000
通話が成功した場合は、タスクを続行できます。

00:15:31.000 --> 00:15:38.000
これがApp Store Server APIへの呼び出しの結果である場合、検証されたデータの保存に進むことができます。

00:15:38.000 --> 00:15:44.000
通知の場合、アレックスはこのセッションの彼の部分でこれにもっと入ります。

00:15:44.000 --> 00:15:48.000
JWSを検証できない場合は、JWSを使用しないでください。

00:15:48.000 --> 00:15:52.000
これは、App Storeから改ざんされた、または送信されなかったことを意味する可能性があります。

00:15:52.000 --> 00:15:57.000
アレックスは、通知を使用する際にセキュリティをより適切に確保する方法について詳しく説明します。

00:15:57.000 --> 00:16:04.000
JWSの検証と処理に関する完全な手順については、App Storeの開発者ドキュメントを参照してください。

00:16:04.000 --> 00:16:10.000
それでは、verifyReceiptからApp Store Server APIへの移行のユースケースをいくつか確認しましょう。

00:16:10.000 --> 00:16:16.000
まず、特定の加入者の最新のステータスを確認したいケースを見てみましょう。 特定の加入者の最新のステータスを確認しましょう。

00:16:16.000 --> 00:16:20.000
これにより、個々のサブスクリプションの変更が最新の状態に保たされます。

00:16:20.000 --> 00:16:32.000
以前は、加入者の最新のステータスを取得するには、verifyReceiptを呼び出し、有効期限の意図、grace_period_expires_dateなどのフィールドに基づいてサブスクリプションのステータスを決定する必要がありました。

00:16:32.000 --> 00:16:45.000
現在、App Store Server APIを使用すると、Get All Subscription Statusesエンドポイントを呼び出すと、現在のステータスと最新の署名済みトランザクションと更新情報を含むステータスフィールドを使用して、サブスクリプションの最新のステータスを取得できます。

00:16:45.000 --> 00:16:48.000
これを実行する方法の流れを見てみましょう。 これを行う方法のフローを見てみましょう。

00:16:48.000 --> 00:16:55.000
まず、あなたが持っているデコードされた領収書については、私が以前に示した方法で元のTransactionIdsを取得できます。

00:16:55.000 --> 00:17:04.000
次に、その元のTransactionIdのGet All Subscription Statusesエンドポイントを呼び出すと、そのトランザクションの最新の署名済みトランザクションと更新が返されます。

00:17:04.000 --> 00:17:08.000
次に、最新の取引を取得するケースを見てみましょう。

00:17:08.000 --> 00:17:16.000
最新のトランザクションを取得すると、ユーザーが購入したもの、更新されたもの、ユーザーのサブスクリプションに変更があった場合などが通知されます。

00:17:16.000 --> 00:17:27.000
以前は、ユーザーの最新のトランザクションを取得するには、verifyReceiptを呼び出すとin_app配列を使用し、ユーザーのすべてのトランザクションを含む latest_receipt_infoを調べる必要がありました。

00:17:27.000 --> 00:17:36.000
App Store Server APIを使用すると、最新のトランザクションを取得するために、トランザクション履歴の取得エンドポイントを使用すると、ユーザーの完全な購入履歴を取得できます。

00:17:36.000 --> 00:17:48.000
さらに、WWDC22トーク「アプリ内購入の新機能」で取り上げられている新しいフィルタとソート機能と組み合わせることで、必要なデータを効率的に正確に取得できます。

00:17:48.000 --> 00:17:51.000
これが伴うかもしれないものの流れを見てみましょう。

00:17:51.000 --> 00:18:06.000
そのユーザーに属する元のTransactionIdを使用すると、Get Transaction Historyエンドポイントを呼び出すことができます。これにより、このユーザーのトランザクションの履歴が、署名されたトランザクションとして返され、フィルタリングされ、ソートされ、仕様にページネーションされます。

00:18:06.000 --> 00:18:09.000
最後に、appAccountTokenを採用するケースを見てみましょう。

00:18:09.000 --> 00:18:15.000
appAccountTokenフィールドを使用すると、StoreKit 2トランザクションをユーザーに関連付けるUUIDを提供できます。

00:18:15.000 --> 00:18:22.000
その後、署名されたトランザクション、署名された更新、およびそのトランザクションの通知に、appAccountTokenが表示されます。

00:18:22.000 --> 00:18:29.000
以前は、StoreKit2の新しい機能であったため、元のStoreKitでappAccountTokenがサポートされていませんでした。

00:18:29.000 --> 00:18:38.000
現在、Original StoreKitクライアントとの互換性をサポートするために、Original StoreKitのフィールドアプリケーションユーザー名にUUIDを提供するサポートを追加しました。

00:18:38.000 --> 00:18:43.000
この条件下では、そのUUIDはappAccountTokenが行うすべての機能をサポートします。

00:18:43.000 --> 00:18:56.000
その後、appAccountTokenは、Original StoreKitユーザーのverifyReceiptに戻り、App Store Server APIへの呼び出しとApp Store Server通知からの通知で、Original StoreKitとStoreKit 2の両方のユーザーにも表示されます。

00:18:56.000 --> 00:18:59.000
このセッションのApp Store Server API部分については、これでおそれです。

00:18:59.000 --> 00:19:04.000
次に、App Store Server Notifications Version 2への移行をカバーするAlexです。

00:19:04.000 --> 00:19:05.000
アレックス:ありがとう、ガブリエル。

00:19:05.000 --> 00:19:11.000
私の名前はアレックスで、今日ここに来てApp Storeサーバー通知バージョン2について話し合うことに興奮しています。

00:19:11.000 --> 00:19:15.000
まず、バージョン2の通知を開始する方法について説明します。

00:19:15.000 --> 00:19:21.000
次に、バージョン2の通知がどのように異なり、利用可能な他のモデルに基づいて構築されるか。

00:19:21.000 --> 00:19:29.000
第三に、通知を逃した場合の回復と、このタスクを達成するために利用可能な新しいリソースのいくつかについて話します。

00:19:29.000 --> 00:19:37.000
最後に、通知が顧客の行動に関する洞察を提供し、サブスクリプションのライフサイクルについて知らされる追加の機会を生み出す方法。

00:19:37.000 --> 00:19:42.000
通知とは何か、誰が使用できるのかを簡単に紹介しましょう。

00:19:42.000 --> 00:19:49.000
App Storeサーバー通知は、アプリのユーザーが特定のアクションを実行するたびに送信するメッセージです。

00:19:49.000 --> 00:19:57.000
これらの通知は、サブスクリプションの更新と払い戻しの更新の2つのカテゴリに分類されますが、私たちは常に追加のシナリオをカバーするために取り組んでいます。

00:19:57.000 --> 00:20:03.000
これらの通知は、アプリで利用できない可能性のあるユーザーアクションのギャップを埋めるのに役立ちます。

00:20:03.000 --> 00:20:08.000
例として、最も一般的なユースケースの1つは、サブスクリプションの更新です。

00:20:08.000 --> 00:20:12.000
このトランザクションが利用可能になると、ユーザーはアプリにいない可能性があります。

00:20:12.000 --> 00:20:20.000
App Storeサーバー通知は、サブスクリプションの更新時に最新のトランザクション情報をサーバーに直接送信することで、この問題を説明するのに役立ちます。

00:20:20.000 --> 00:20:27.000
バージョン2の通知は、Gabrielから聞いたばかりのStoreKit 2モデルとApp Store Server APIと多くの類似点を共有しています。

00:20:27.000 --> 00:20:33.000
しかし、それらはうまく連携しますが、それらはすべて異なる時期に採用できる独立したツールです。

00:20:33.000 --> 00:20:43.000
最も重要なことは、バージョン2のサーバー通知を利用しながら、iOS-15以前のクライアントであるStoreKit 2が利用できないクライアントを引き続きサポートできることです。

00:20:43.000 --> 00:20:52.000
私たちは、バージョン2の通知を、サブスクリプションライフサイクル全体を通じてユーザーに関する情報を提供するための最も詳細で柔軟なツールの1つにするために取り組んできました。

00:20:52.000 --> 00:21:01.000
プレゼンテーションの後半で詳しく説明しますが、通知はアプリの外で実行されたアクションをキャプチャすることはほとんど不可能な情報を提供します。

00:21:01.000 --> 00:21:06.000
通知の概念と、特にバージョン2の通知に興味を持っていただければ幸いです。

00:21:06.000 --> 00:21:14.000
先に進む前に、このプレゼンテーションでは、開始と通知を受け取るためのベストプラクティスについて説明しますが、全体のストーリーを伝えるものではありません。

00:21:14.000 --> 00:21:20.000
通知の詳細と、さまざまなユースケースに対応する方法については、これらの最近のビデオを参照してください。

00:21:20.000 --> 00:21:23.000
バージョン2の通知の設定を見てみましょう。

00:21:23.000 --> 00:21:27.000
最初の通知を受け取るまで、通知を設定する方法を説明します。 通知を最後まで説明します。

00:21:27.000 --> 00:21:32.000
まず、App Store Connectのアプリのページに移動します。

00:21:32.000 --> 00:21:37.000
下にスクロールすると、App Storeサーバー通知のセクションが表示されます。

00:21:37.000 --> 00:21:41.000
ここでは、生産とサンドボックスの両方のオプションが表示されます。

00:21:41.000 --> 00:21:47.000
各環境には、個別のURLと個別の通知バージョンを含めることができます。

00:21:47.000 --> 00:21:50.000
以下は、本番設定のオプションページの例です。

00:21:50.000 --> 00:21:53.000
サンドボックスの設定はまったく同じです。

00:21:53.000 --> 00:22:01.000
特にバージョン1の通知ユーザーの場合は、まずサンドボックス環境でバージョン2の通知を試すことをお勧めします。

00:22:01.000 --> 00:22:07.000
これは、生産設定に影響を与えることなく、通知に慣れるのに最適な場所です。

00:22:07.000 --> 00:22:15.000
[サンドボックスの設定] ボタンを選択し、サーバーの URL を提供し、バージョン 2 通知を選択します。

00:22:15.000 --> 00:22:21.000
通知をトリガーする前に、サーバーエンドポイントに有効なHTTPS証明書があることを確認してください。

00:22:21.000 --> 00:22:25.000
また、AppleのパブリックIPのサーバーへのアクセスを許可したことを確認してください。

00:22:25.000 --> 00:22:30.000
通知を設定する際の最も一般的な失敗のいくつかは、ファイアウォールと証明書に関連しています。

00:22:30.000 --> 00:22:36.000
これらは、最初のトラブルシューティング手順として突然通知の受信を停止したかどうかを確認するのにも最適です。

00:22:36.000 --> 00:22:39.000
これで、最初の通知を受け取る準備が整いました。

00:22:39.000 --> 00:22:44.000
サンドボックスでは、アプリ内サブスクリプションの購入など、さまざまなアクションによって通知をトリガーできます。

00:22:44.000 --> 00:22:54.000
ただし、テスト中の使いやすさのために、App Store Server APIの一部である新しいRequest a Test Notificationエンドポイントを使用して通知をトリガーすることをお勧めします。

00:22:54.000 --> 00:22:57.000
このエンドポイントは、通知テストプロセスを自動化するのに役立ちます。

00:22:57.000 --> 00:23:02.000
テスト通知のリクエストエンドポイントをトリガーした後、通知がすぐに届くことを期待するはずです。

00:23:02.000 --> 00:23:11.000
通知の受信に問題がある場合は、新しいGet Test Notification Statusエンドポイントを参照してください。これは、通知が配信されなかった理由に関する簡単なステータスを提供できます。

00:23:11.000 --> 00:23:17.000
たとえば、SSL_ISSUEのようなステータスは、HTTPS証明書を再確認するための手がかりになります。

00:23:17.000 --> 00:23:22.000
設定変更を実行するたびに、テスト通知をトリガーすることをお勧めします。

00:23:22.000 --> 00:23:26.000
これは、変更後も通知を受信できることを確認するのに最適な方法です。

00:23:26.000 --> 00:23:32.000
では、受け取ったばかりの通知の理解に移りましょう。

00:23:32.000 --> 00:23:37.000
ガブリエルから以前に見た取引と同様に、通知もJWS形式です。

00:23:37.000 --> 00:23:42.000
通知ペイロードをデコードして検証する方法を見てみましょう。

00:23:42.000 --> 00:23:49.000
まず、通知を受け取ったら、JSONボディのsignedPayloadフィールドを抽出する必要があります。

00:23:49.000 --> 00:23:55.000
次に、署名されたトランザクションを検証するために、ガブリエルが先ほど案内したのとまったく同じ手順を実行します。

00:23:55.000 --> 00:24:04.000
通知からの署名された通知ペイロードであるか、App Store Server APIからの署名されたトランザクションであるかにかかわらず、署名されたデータを確認するために同じ手順に従います。

00:24:04.000 --> 00:24:09.000
次に、通知がどのアプリのものかを確認することが重要です。

00:24:09.000 --> 00:24:15.000
同じエンドポイントを共有する複数のアプリがある場合、これはターゲットアプリを決定するのに適した場所です。

00:24:15.000 --> 00:24:24.000
また、通知がターゲットとするアプリがあなたのアプリであり、通知が他の開発者を対象としていないことを確認することも重要です。

00:24:24.000 --> 00:24:32.000
最後に、もう1つの便利なチェックは、通知の環境が本番環境またはサンドボックスのいずれかの予想される環境と一致していることを確認することです。

00:24:32.000 --> 00:24:46.000
App Store Connectは環境ごとに個別のURLを許可するため、この要件を強制するか、URLが共有されている場合は、環境に基づいて通知を個別に保存および処理することを保証します。

00:24:46.000 --> 00:24:50.000
この時点で、JWSは完全に検証され、さらなる処理のために保存することができます。

00:24:50.000 --> 00:24:56.000
いくつかの基本的なチェックに加えて、サーバーが通知を非同期に処理することをお勧めします。

00:24:56.000 --> 00:25:03.000
通知の処理に時間がかかりすぎる場合、当社のサーバーはタイムアウトを記録し、通知が正常に配信されなかったと仮定します。

00:25:03.000 --> 00:25:06.000
その後、通知を再送信します。

00:25:06.000 --> 00:25:19.000
したがって、時間のかかる処理をこの機能の外に移動すると、App Storeサーバーが正常に送信された通知を記録し、サーバーが再試行時に通知を再処理する必要がなくなります。

00:25:19.000 --> 00:25:24.000
では、確認後、通知の本文を確認しましょう。

00:25:24.000 --> 00:25:28.000
最初のフィールドは、通知タイプとオプションのサブタイプです。

00:25:28.000 --> 00:25:32.000
これらを組み合わせると、通知のシナリオがわかります。

00:25:32.000 --> 00:25:38.000
これらのフィールドは、前回の通知から何が変更されたかを表示し、これらの変更が発生した理由に関する情報を提供するのにも役立ちます。

00:25:38.000 --> 00:25:43.000
notificationUUIDは、通知ごとの一意の識別子です。

00:25:43.000 --> 00:25:49.000
サーバーが通知を再試行すると、再試行された通知には同じnotificationUUIDが含まれます。

00:25:49.000 --> 00:25:57.000
これは、サーバーが通知を処理したが、成功したHTTP応答コードでタイムリーに応答しなかったケースを検出するのに役立ちます。

00:25:57.000 --> 00:26:03.000
このフィールドに基づいて、再試行による重複通知検出を追加することをお勧めします。

00:26:03.000 --> 00:26:07.000
signedDateフィールドは、通知がいつ作成されたかを示します。

00:26:07.000 --> 00:26:10.000
これは、再試行された通知を検出するのに特に便利です。

00:26:10.000 --> 00:26:13.000
次に、appAppleIdとbundleId。

00:26:13.000 --> 00:26:16.000
これらは、ターゲットアプリケーションを検出するために重要です。

00:26:16.000 --> 00:26:23.000
先に説明したように、リプレイ攻撃を防ぐために、これらのフィールドをチェックし、期待値と一致することを確認することが重要です。

00:26:23.000 --> 00:26:33.000
さらに、通知の環境が期待される環境と一致していること、サンドボックス通知が本番データとして記録されていないこと、またはその逆であることを確認してください。

00:26:33.000 --> 00:26:38.000
最後に、実際のsignedTransactionInfoとオプションのsignedRenewalInfo。

00:26:38.000 --> 00:26:43.000
これらは、署名時の基礎となる購入の最新のステータスになります。

00:26:43.000 --> 00:26:51.000
この時点で、通知を解析すると、最新のトランザクションと更新情報、およびステータスの変更の最新の理由が残ります。

00:26:51.000 --> 00:27:06.000
特定の通知の設定と受信について説明したので、バージョン2の通知モデル、通知がサブスクリプションのライフサイクルを追跡するためにどのように適合するか、バージョン1の通知との比較によるバージョン2の通知の背後にある設計決定を調べてみましょう。

00:27:06.000 --> 00:27:10.000
バージョン2は、購入状況に関する情報を送信する際に異なる哲学を採用しています。

00:27:10.000 --> 00:27:24.000
通知ごとに最近の履歴全体を送信する代わりに、バージョン2の通知は、最新の取引情報、およびサブスクリプションの場合は保留中の更新情報の送信のみに焦点を当てています。

00:27:24.000 --> 00:27:30.000
通知では、サブスクリプションライフサイクルのあらゆるステップに関する情報を提供するために取り組んでいます。

00:27:30.000 --> 00:27:36.000
したがって、通知には、購入またはサブスクリプションに関する最新情報のみが含まれます。

00:27:36.000 --> 00:27:41.000
これらの通知は、サブスクリプションのステータスの完全なタイムラインを作成します。

00:27:41.000 --> 00:27:54.000
トランザクション履歴全体を表示する必要があり、通知履歴にアクセスできない場合は、ページネーションされたフィルタリング可能なコンテキストでユーザーのトランザクション履歴全体を照会できるトランザクション履歴の取得エンドポイントとよくペアになります。

00:27:54.000 --> 00:27:58.000
第二に、バージョン1の通知では、クライアントがStoreKit 2を使用する必要はありません。

00:27:58.000 --> 00:28:01.000
そして、そうです、バージョン2もそうではありません。

00:28:01.000 --> 00:28:09.000
実際、クライアント側でどのようなフレームワークが使用されても、今日からバージョン2の通知のメリットを享受することができます。

00:28:09.000 --> 00:28:19.000
最後に、バージョン2の通知は、提供される詳細のレベルを高め、追加のタイプを追加し、新しいサブタイプフィールドを追加することでカバーするケースを拡張します。

00:28:19.000 --> 00:28:24.000
これにより、より多くのシナリオをカバーし、サブスクリプションライフサイクルのあらゆる段階で通知を提供することができます。

00:28:24.000 --> 00:28:34.000
私たちが追加した注目すべきシナリオには、有効期限、自動更新ステータスの変更に関連するより詳細な情報、および払い戻しプロセスに関するより多くのシナリオが含まれます。

00:28:34.000 --> 00:28:45.000
さて、カバーするシナリオの複雑さを説明し、より具体的な例を提供するために、通知がサブスクリプションが最初から最後まで取る各ステップを通知する方法を見てみましょう。

00:28:45.000 --> 00:28:49.000
サブスクリプションの前にユーザーを想像してみましょう。

00:28:49.000 --> 00:29:00.000
購読すると、ユーザーは更新サブスクリプション状態に移行し、サブタイプINITIAL_BUYのSUBSCRIBED通知が送信されるか、オファーが使用された場合はサブタイプINITIAL_BUYのOFFER_REDEEMEDが送信されます。

00:29:00.000 --> 00:29:06.000
通知には、最初に署名されたトランザクションと署名された更新情報が含まれます。

00:29:06.000 --> 00:29:10.000
時間が経過し、サブスクリプションが更新され、更新状態のままになります。

00:29:10.000 --> 00:29:16.000
更新のたびに、次の署名された取引情報を記載したDID_RENEW通知を送信します。

00:29:16.000 --> 00:29:28.000
ユーザーが自動更新を無効にすると、有効期限が切れるサブスクリプション状態に移行し、サブタイプAUTO_RENEW_DISABLED通知を含むDID_CHANGE_RENEWAL_STATUSが届きます。

00:29:28.000 --> 00:29:36.000
自動更新を再度有効にしない場合は、期間の終了時に期限切れの状態に移行し、サブタイプのVOLUNTARY通知でEXPIREDを受け取ります。

00:29:36.000 --> 00:29:43.000
さて、あなたは疑問に思うかもしれません、他のすべての通知タイプはどこにありますか?

00:29:43.000 --> 00:29:46.000
通知からわかるように、サブスクリプションのライフサイクルは次のとおりです。

00:29:46.000 --> 00:29:49.000
たくさんのことが起こっています。

00:29:49.000 --> 00:29:52.000
そして、この図は全体の物語さえ語っていません。

00:29:52.000 --> 00:29:57.000
たとえば、払い戻し/失効のライフサイクルはここには含まれていません。

00:29:57.000 --> 00:30:06.000
この図は、バージョン2の通知がカバーし、サブスクリプションライフサイクルの各ステップを通知するために機能するシナリオの膨大な配列を示しています。

00:30:06.000 --> 00:30:10.000
私が言いたいもう一つのポイントは、私たちはすべての可能な移行状態をカバーするために働くということです。

00:30:10.000 --> 00:30:20.000
これは、サブスクリプションを追跡するための単一のソースになることで通知の有用性を高め、加入者の旅のすべてのステップを見ているという自信を高めるのに役立ちます。

00:30:20.000 --> 00:30:25.000
ただし、このデータはすべてここにありますが、利用可能なすべてのタイプで作業する必要はありません。

00:30:25.000 --> 00:30:31.000
たとえば、更新設定の変更に関連する通知を処理するだけでも、価値を提供できます。

00:30:31.000 --> 00:30:37.000
特に始めたばかりの場合は、あなたの状況に最も有用な通知タイプから始めてください。

00:30:37.000 --> 00:30:44.000
さて、サーバーをセットアップした後に何が起こるかをカバーしましょう。すべてがスムーズに実行されていますが、残念ながら、サーバーがダウンします。

00:30:44.000 --> 00:30:50.000
数日であろうと、数分であろうと、または1つだけ見逃したかもしれないと思うかどうかにかかわらず、この問題を解決するためのいくつかの手順について説明しましょう。

00:30:50.000 --> 00:30:52.000
サーバーをイメージしてみましょう。

00:30:52.000 --> 00:30:56.000
正常にセットアップされ、通知を受信しています。

00:30:56.000 --> 00:31:01.000
ある時点で、サーバーに問題があり、通知を受信できません。

00:31:01.000 --> 00:31:06.000
私たちはまだあなたのサーバーにメッセージを送信しようとしていますが、今、それらの要求は失敗し始めます。

00:31:06.000 --> 00:31:08.000
このシナリオに対処する方法はいくつかあります。

00:31:08.000 --> 00:31:10.000
1つ目はただ待つことです。

00:31:10.000 --> 00:31:18.000
サーバーからステータスコードが正常に届かない場合、またはまったく接続できなかった場合は、文書化された再試行ポリシーに従って通知を再試行します。

00:31:18.000 --> 00:31:28.000
バージョン2の通知については、各試行後に、まず1時間の遅延、次に12時間の遅延、24時間、48、そして最後に72時間の遅延の後に再試行します。

00:31:28.000 --> 00:31:36.000
通知は最初の失敗の1時間後に再試行されるため、待機は1時間未満の停止に最適です。

00:31:36.000 --> 00:31:41.000
ある時点でサーバーが回復し、再び通知を受信し始めます。

00:31:41.000 --> 00:31:46.000
まず、見逃した通知とは関係のない新しい通知を受け取ります。

00:31:46.000 --> 00:31:53.000
通知は遅れて再試行されるため、サーバーがオンラインになるとすぐに、見逃したすべての通知をすぐに受け取ることはありません。

00:31:53.000 --> 00:32:01.000
時間が経ち、見逃した通知を受け取り始め、新しい通知が散在します。

00:32:01.000 --> 00:32:07.000
これは、通知が元の通知か再試行された通知かをどのように検出できるかという質問を提起します。

00:32:07.000 --> 00:32:10.000
通知を調べてみましょう。

00:32:10.000 --> 00:32:14.000
この通知では、いくつかのフィールドを表示しているだけです。

00:32:14.000 --> 00:32:17.000
通知にはsignedDateフィールドが含まれています。

00:32:17.000 --> 00:32:23.000
このフィールドは、署名日と通知の受信時間を比較することで、再試行を検出するのに便利です。

00:32:23.000 --> 00:32:32.000
通知を受け取った日付よりかなり早い署名日の通知が表示された場合は、停止を経験した可能性があることを示しています。

00:32:32.000 --> 00:32:38.000
このシナリオでは、6と3というラベルの付いた通知が同じサブスクリプションのものだったと想像してみてください。

00:32:38.000 --> 00:32:41.000
これは、元のTransactionIdsを比較することで決定できます。

00:32:41.000 --> 00:32:51.000
この場合、通知6の後に通知3が受信されたからといって、通知6よりも新しい情報が含まれているわけではありません。

00:32:51.000 --> 00:32:58.000
それ以外の場合は、サーバーが通知を受信した可能性がありますが、成功したHTTP 200ステータスコードで応答できませんでした。

00:32:58.000 --> 00:33:02.000
これにより、通知がサーバーに再配信される可能性があります。

00:33:02.000 --> 00:33:08.000
先に説明したように、これらの要求を重複排除するためにnotificationUUIDフィールドを必ず確認してください。

00:33:08.000 --> 00:33:14.000
通知を正常に記録したにもかかわらず、かなりの数の再試行された通知が表示される場合があります。

00:33:14.000 --> 00:33:19.000
この場合、通知を受け取るたびにHTTP 200応答で応答していることを確認してください。

00:33:19.000 --> 00:33:30.000
さらに、タイムアウトを記録して通知を再送信するのを防ぐために、タイムリーにそうしており、正常に応答する前に広範な処理を行っていないことを確認してください。

00:33:30.000 --> 00:33:39.000
時には、特により長い停止では、次の再試行は数時間または数日かかるかもしれませんし、長時間の停止のために、再試行が使い果たされたかもしれません。

00:33:39.000 --> 00:33:45.000
見逃した通知から回復するための次のオプションは、通知履歴の取得エンドポイントです。

00:33:45.000 --> 00:33:52.000
サーバーに送信した通知の6か月の履歴を提供する新しい通知履歴エンドポイントを発表しました。

00:33:52.000 --> 00:33:58.000
このエンドポイントの概要と、私たちが発表する他の優れた機能については、「アプリ内購入の新機能」ビデオを参照してください。

00:33:58.000 --> 00:34:04.000
ここでは、このエンドポイントを使用する際のベストプラクティスと、それが支援できるシナリオに焦点を当てます。

00:34:04.000 --> 00:34:08.000
停止が解決した後、停止の開始と終了のタイムスタンプに注意してください。

00:34:08.000 --> 00:34:13.000
通知履歴の取得エンドポイントでは、特定の期間にわたってクエリを行うことができます。

00:34:13.000 --> 00:34:21.000
停止の開始時刻と終了時刻を指定することで、履歴全体のページングを要求するのではなく、見逃した可能性が高い通知のみを処理できます。

00:34:21.000 --> 00:34:27.000
これは、回復の速度を向上させ、すでに記録された通知を再処理する作業を減らすのに役立ちます。

00:34:27.000 --> 00:34:32.000
次に、通知履歴の取得エンドポイントでは、通知の種類でフィルタリングできます。

00:34:32.000 --> 00:34:42.000
延長された停止を経験し、かなりの数の通知を期待している場合は、タイプ別にフィルタリングし、DID_RENEWやEXPIREDなど、すぐに影響する可能性のあるタイプから始めることを検討してください。

00:34:42.000 --> 00:34:46.000
これらは、最も関連性の高いケースに対して最初に行動を起こすのに役立ちます。

00:34:46.000 --> 00:34:55.000
通知タイプを渡すときの1つのヒントは、notificationSubtypeフィールドが省略されている場合、これはサブタイプのない通知のみを返します。

00:34:55.000 --> 00:35:05.000
したがって、DID_RENEW notificationTypeに示されている例では、これはBILLING_RECOVERYのサブタイプでDID_RENEW通知を返しません。

00:35:05.000 --> 00:35:11.000
最後に、通知履歴の取得エンドポイントでは、元のTransactionIdを使用して特定のユーザーにフィルタリングできます。

00:35:11.000 --> 00:35:18.000
サブスクリプションのライフサイクルを振り返ってみると、ユーザーの旅のすべてのステップが通知でカバーされていることを確認しました。

00:35:18.000 --> 00:35:27.000
したがって、サブスクリプションの更新から直接有効期限が切れるまでなど、予期せぬ方法で飛び回っていることに気付いた場合、そのユーザーの通知を見逃したことを示す可能性があります。

00:35:27.000 --> 00:35:33.000
これは、ユーザーのアカウントが予想とは異なる状態にある場合、カスタマーサポートのコンテキストでも役立ちます。

00:35:33.000 --> 00:35:38.000
このような場合、そのユーザーの通知履歴のクエリを送信できます。

00:35:38.000 --> 00:35:42.000
通知履歴の取得エンドポイントからの応答を見てみましょう。

00:35:42.000 --> 00:35:46.000
シンプルにするために、応答には特定の値のみが表示されます。

00:35:46.000 --> 00:35:52.000
応答で返される値は、notificationHistory配列にあります。

00:35:52.000 --> 00:35:56.000
配列内の各エントリは、単一の通知を表します。

00:35:56.000 --> 00:36:02.000
署名されたペイロードフィールドには、あなたに送信された正確な通知が含まれています。

00:36:02.000 --> 00:36:05.000
次に、最初のSendAttemptResultフィールドがあります。

00:36:05.000 --> 00:36:11.000
このフィールドには、サーバーによって記録された最初の通知試行の結果に基づいて、いくつかの値のいずれかが含まれています。

00:36:11.000 --> 00:36:14.000
成功した場合、これは価値SUCCESSになります。

00:36:14.000 --> 00:36:19.000
しかし、先ほど議論しているように、通知がサーバーに届かないことがあります。

00:36:19.000 --> 00:36:25.000
これらのメッセージは、問題の方向を指し示し、解決プロセスを簡素化するための一般的なガイドとなることを目的としています。

00:36:25.000 --> 00:36:28.000
たとえば、ここにSSL_ISSUEが表示されます。

00:36:28.000 --> 00:36:33.000
これは、サーバー上のSSL証明書またはプロセスに問題があることを示しています。

00:36:33.000 --> 00:36:39.000
このフィールドは、通知が届かなかったことを超えて、サーバーの問題を診断するための可視性を向上させます。

00:36:39.000 --> 00:36:45.000
また、テスト通知を使用するときにこの機能を提供するために、テスト通知ステータスの取得エンドポイントでこの同じフィールドを提供します。

00:36:45.000 --> 00:36:52.000
これらは、オンボーディング中やトラブルシューティング中、または停止の根本原因を特定する際に遡及的に役立ちます。

00:36:52.000 --> 00:36:55.000
通知は、ユーザーの履歴のすべてのケースをカバーするとは限りません。

00:36:55.000 --> 00:37:00.000
通知を採用したばかりで、既存のユーザーがカバーされていない可能性があります。

00:37:00.000 --> 00:37:06.000
また、通知履歴の取得エンドポイントで通知の保存期間よりも長い履歴を調べることもできます。

00:37:06.000 --> 00:37:09.000
トランザクション履歴の取得エンドポイントが画像を入力する場所です。

00:37:09.000 --> 00:37:18.000
このエンドポイントは、ガブリエルのプレゼンテーションで先に見たように、通知の使用を開始する前にケースをカバーする履歴を顧客に提供することで、これらの問題を解決します。

00:37:18.000 --> 00:37:25.000
それでは、通知が購入履歴を超えて洞察と機会を提供する方法について説明します。

00:37:25.000 --> 00:37:32.000
バージョン2の通知の新しい追加機能の1つは、サブタイプフィールドで、notificationTypeフィールドに追加のコンテキストを追加します。

00:37:32.000 --> 00:37:38.000
このフィールドは、EXPIREDやDID_CHANGE_RENEWAL_STATUSなど、特定のシナリオで詳細を提供することを目的としています。

00:37:38.000 --> 00:37:45.000
たとえば、EXPIREDの場合、実行するアクションは通常同じで、サブスクリプションを非アクティブとしてマークし、製品へのアクセスを取り消します。

00:37:45.000 --> 00:37:49.000
しかし、ユーザーが期限切れになった理由を理解することはしばしば役に立ちます。

00:37:49.000 --> 00:37:53.000
それは請求の問題、自発的な選択、または決して受け入れられなかった値上げによるものですか？

00:37:53.000 --> 00:38:01.000
別の通知、DID_CHANGE_RENEWAL_STATUSは、通知を使用する際に追加情報と機会を得る素晴らしい例です。

00:38:01.000 --> 00:38:04.000
表面的には、優先順位が低いようです。

00:38:04.000 --> 00:38:06.000
すぐに行動を起こす必要はありません。

00:38:06.000 --> 00:38:11.000
製品へのアクセスを取り消すための重要な通知は、期限切れの通知です。

00:38:11.000 --> 00:38:14.000
だまされてはいけません。ここにはたくさんの機会があります。

00:38:14.000 --> 00:38:20.000
1つは、この通知は、サブスクリプションの有効期限が切れる前に顧客を取り戻すことを試みる絶好の機会です。

00:38:20.000 --> 00:38:29.000
特に、自動更新の無効化はアプリケーション外で発生する可能性があるため、これは有効期限前に更新ステータスのこの変更で通知される唯一のトリガーになる可能性があります。

00:38:29.000 --> 00:38:32.000
この通知は、顧客の行動に関する洞察も提供します。

00:38:32.000 --> 00:38:36.000
この通知は、更新期間の購読者がいつキャンセルするかを判断するために使用できます。

00:38:36.000 --> 00:38:37.000
更新の前日ですか？

00:38:37.000 --> 00:38:42.000
新規加入者は、サービスにサインアップした直後に自動更新を無効にしますか?

00:38:42.000 --> 00:38:47.000
この種の情報は、キャンセルの原因を理解し、製品を改善するために重要です。

00:38:47.000 --> 00:38:52.000
最後に、特定のシナリオは、通知なしにユーザーの履歴に反映されない場合があります。

00:38:52.000 --> 00:38:59.000
たとえば、ユーザーは、サブスクリプション期間が終了する前に、自動更新を無効にしてから再アクティブ化することができます。

00:38:59.000 --> 00:39:05.000
これはすべてサブスクリプション期間内に発生するため、サブスクリプションの長期ステータスには影響しません。

00:39:05.000 --> 00:39:13.000
これらの決定は、顧客を理解するために重要であり、通知はこれらのタイプのシナリオを検出して記録するための情報を提供します。

00:39:13.000 --> 00:39:23.000
全体として、通知は、カスタマージャーニーのあらゆる段階で情報を提供し、これまで以上に多くのシナリオをカバーすることで、顧客の行動を理解する機会を強化し、創出するために機能します。

00:39:23.000 --> 00:39:29.000
結論として、今日はApp Store Server APIとApp Store Server Notificationsの両方を取り上げました。

00:39:29.000 --> 00:39:33.000
これらは、購入の管理と追跡を取り巻く機能を改善するために利用できます。

00:39:33.000 --> 00:39:37.000
彼らは更新されたメッセージタイプを使用し、これまで以上に多くのケースをカバーしています。

00:39:37.000 --> 00:39:46.000
これらのシステムは、すべてのクライアントで利用でき、オリジナルのStoreKitとStoreKit 2の両方と相互互換性があり、サブスクリプションのライフサイクルを監視する能力を向上させることができます。

00:39:46.000 --> 00:39:51.000
最後に、これらのツールはすでにサンドボックスとプロダクションの両方で利用でき、あらゆるシステムに最適です。

00:39:51.000 --> 23:59:59.000
ご参加いただきありがとうございます。素晴らしいWWDCをお過ごしください。

