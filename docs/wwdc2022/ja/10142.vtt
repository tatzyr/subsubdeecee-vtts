WEBVTT

00:00:00.000 -> 00:00:03.000
♪まろやかなインストゥルメンタルヒップホップ音楽♪

00:00:03.000 -> 00:00:09.000
♪

00:00:09.000 -> 00:00:13.000
「効率性が待っている：SwiftUIのバックグラウンドタスク」へようこそ。

00:00:13.000 -> 00:00:17.000
私はwatchOSフレームワークチームのエンジニア、ジョン・ギャラガーです。

00:00:17.000 -> 00:00:26.000
この講演では、Swift Concurrencyを使用して、Appleのすべてのプラットフォームで一貫した方法でバックグラウンドタスクを処理するための新しいSwiftUI APIについて学びます。

00:00:26.000 -> 00:00:36.000
まず、バックグラウンドタスクを利用した嵐の日に空の写真を撮るためのアプリ、ストーミーと呼ばれるサンプルアプリについて説明します。

00:00:36.000 -> 00:00:44.000
次に、アプリがバックグラウンドタスクをどのように使用し、バックグラウンドタスクが内部でどのように機能するかを掘り下げます。

00:00:44.000 -> 00:00:52.000
次に、SwiftUIの新しいAPIを使用してこれらのバックグラウンドタスクを処理する方法を学びます。

00:00:52.000 -> 00:01:03.000
そして最後に、APIがSwift Concurrencyを使用してバックグラウンドタスクの処理をこれまで以上に簡単にする方法を確認します。

00:01:03.000 -> 00:01:19.000
新しいAPIは、Macで実行されているiOSアプリを含むwatchOS、iOS、tvOS、Mac Catalyst、ウィジェット間で共有されます。つまり、あるプラットフォームのバックグラウンドタスクを処理する概念とパターンは、他のプラットフォームで行う作業に適用できます。

00:01:19.000 -> 00:01:29.000
Swift Concurrencyを利用して、新しいAPIは、深くネストされた完了ハンドラとコールバックの必要性だけでなく、しばしば副作用であった変更可能な状態の多くを減らします。

00:01:29.000 -> 00:01:40.000
Swift Concurrencyのネイティブタスクキャンセルは、アプリケーションがタイムリーにタスクを優雅に完了し、システムによってバックグラウンドで終了されるのを避けるのに役立ちます。

00:01:40.000 -> 00:01:49.000
雲の中に頭を置くのが好きな人のために、外が嵐のときに空の写真を撮ることをユーザーに思い出させるStormyというアプリを構築します。

00:01:49.000 -> 00:01:56.000
アプリは、嵐の日の正午に、ユーザーが空の写真を撮ることを要求する通知を表示します。

00:01:56.000 -> 00:02:03.000
ユーザーが通知をタップすると、空の写真を撮って、将来の賞賛のためにプロフィールにアップロードします。

00:02:03.000 -> 00:02:07.000
この写真を背景にアップロードします。

00:02:07.000 -> 00:02:11.000
アップロードが完了すると、アプリは別の通知を送信します。

00:02:11.000 -> 00:02:15.000
バックグラウンドタスクでこれを行う方法に飛び込みましょう。

00:02:15.000 -> 00:02:23.000
この図では、バックグラウンドタスクを利用して嵐の日にのみ通知がどのように送信されるかを高いレベルで検討します。

00:02:23.000 -> 00:02:36.000
フォアグラウンドアプリケーションランタイムを左側のバーで表し、バックグラウンドアプリケーションランタイムを中央にバーで表現し、システムは右側で表されます。

00:02:36.000 -> 00:02:46.000
アプリがユーザーによって最初にフォアグラウンドに起動されたとき、私たちは正午にバックグラウンドアプリの更新タスクをスケジュールする最初の機会を利用することができます。

00:02:46.000 -> 00:02:57.000
その後、ユーザーがアプリを離れ、アプリが一時停止されると、システムはスケジュールした時間にバックグラウンドでアプリケーションを再び起動することを知っています。

00:02:57.000 -> 00:03:07.000
タスクを正午にスケジュールしたので、システムはバックグラウンドでアプリをスリープ解除し、バックグラウンドアプリの更新タスクを送信します。

00:03:07.000 -> 00:03:16.000
このバックグラウンドランタイムでは、外が嵐であるかどうかを把握し、その場合はユーザーに通知を送信する必要があります。

00:03:16.000 -> 00:03:22.000
まず、現在の天気を確認するために気象サービスにネットワークリクエストを行います。

00:03:22.000 -> 00:03:30.000
URLSessionがバックグラウンドにスケジュールされている場合、アプリケーションは一時停止し、ネットワーク要求が完了するのを待つことができます。

00:03:30.000 -> 00:03:41.000
気象データのバックグラウンドネットワーク要求が完了すると、アプリケーションには新しいURLSessionバックグラウンドタスクで再びバックグラウンドランタイムが与えられます。

00:03:41.000 -> 00:03:55.000
天気データ要求の結果を手にして、私たちのアプリケーションは外が嵐であるかどうかを知っており、ユーザーに空の写真を撮るように促す通知を送信するかどうかを選択できます。

00:03:55.000 -> 00:04:02.000
URLSessionタスクの作業が完了したので、システムは再びアプリケーションを一時停止することができます。

00:04:02.000 -> 00:04:07.000
単一のバックグラウンドタスクの詳細を掘り下げて、それがどのように機能するかを見てみましょう。

00:04:07.000 -> 00:04:14.000
これを行うには、単一のアプリリフレッシュバックグラウンドタスクのライフサイクルを詳しく見ていきます。

00:04:14.000 -> 00:04:19.000
ここで少しズームインしましょう。

00:04:19.000 -> 00:04:25.000
まず、システムはアプリケーションをスリープ解除し、アプリのリフレッシュバックグラウンドタスクを送信します。

00:04:25.000 -> 00:04:32.000
その後、まだバックグラウンドで、外が嵐であるかどうかを確認するためにネットワーク要求を行います。

00:04:32.000 -> 00:04:41.000
理想的には、当社のネットワーク要求は、アプリケーションがアプリの更新のために割り当てられているバックグラウンドランタイム内に完了します。

00:04:41.000 -> 00:04:47.000
ネットワークの応答を受け取ったら、すぐに通知を投稿したいと思います。

00:04:47.000 -> 00:04:56.000
通知が投稿されたことで、アプリの更新中に行う必要があることをすべて完了し、システムはアプリケーションを再び一時停止することができます。

00:04:56.000 -> 00:05:02.000
しかし、気象データのネットワーク要求が時間内に完了しない場合はどうでしょうか?

00:05:02.000 -> 00:05:13.000
アプリが現在のタスクのバックグラウンドランタイムで不足している場合、システムは時間が不足していることをアプリに通知し、この状況を優雅に処理する機会を与えます。

00:05:13.000 -> 00:05:24.000
アプリケーションがランタイムの有効期限が切れる前にバックグラウンド作業を完了したことを通知しない場合、アプリケーションはシステムによって終了され、将来のバックグラウンドタスク要求のためにスロットルされる可能性があります。

00:05:24.000 -> 00:05:39.000
この場合、ネットワーク要求がバックグラウンドネットワーク要求であることを確認する必要があります。これにより、アプリの更新タスクをすぐに完了し、ネットワーク要求が完了したときに追加のバックグラウンドランタイムのために再び目を覚ますことができます。

00:05:39.000 -> 00:05:45.000
バックグラウンドURLSessionがスケジュールされている場合、システムはアプリケーションを再び一時停止できます。

00:05:45.000 -> 00:05:52.000
では、SwiftUIのBackgroundTask APIがStormyの構築にどのように役立つかについて掘り下げてみましょう。

00:05:52.000 -> 00:05:56.000
まず、基本的なアプリケーションが必要です。

00:05:56.000 -> 00:06:02.000
次に、明日の正午にバックグラウンドアプリの更新をスケジュールする関数を書きます。

00:06:02.000 -> 00:06:07.000
まず、明日の正午を表す日付を作成します。

00:06:07.000 -> 00:06:15.000
次に、最も早い開始日が明日の正午でバックグラウンドアプリの更新リクエストを作成し、スケジューラに提出します。

00:06:15.000 -> 00:06:21.000
これは、明日の正午にアプリケーションをウェイクするようにシステムに指示するものです。

00:06:21.000 -> 00:06:29.000
ユーザーが最初にアプリケーションを開き、正午に毎日のストーム通知を要求するときに、この関数を呼び出す必要があります。

00:06:29.000 -> 00:06:38.000
新しいバックグラウンドタスクシーン修飾子を使用して、スケジュールしたバックグラウンドタスクに対応するハンドラを登録できます。

00:06:38.000 -> 00:06:46.000
アプリがバックグラウンドタスクを受信すると、受信したバックグラウンドタスクに一致するこの修飾子で登録されたブロックが実行されます。

00:06:46.000 -> 00:06:57.000
この場合、事前にスケジュールできるappRefreshタスクタイプを使用して、目的の日付にバックグラウンドで限られた量のランタイムをアプリケーションに提供しました。

00:06:57.000 -> 00:07:10.000
バックグラウンドタスク修飾子でリクエストとハンドラーに同じ識別子を使用すると、システムは、対応するタスクがアプリケーションによって受信されたときに呼び出すハンドラを識別できます。

00:07:10.000 -> 00:07:24.000
明日に再びスケジュールされていることを確認するために、明日の正午にバックグラウンドランタイムを再びスケジュールするために書いたscheduleAppRefresh関数を呼び出して、バックグラウンドタスクを開始します。

00:07:24.000 -> 00:07:36.000
正午のバックグラウンドランタイムが繰り返されるようになったので、外が嵐であるかどうかを確認し、await Swiftキーワードを使用して結果を待ちます。

00:07:36.000 -> 00:07:46.000
その後、ネットワーク要求が返され、実際に外が嵐になっている場合は、空の写真をアップロードするように促す通知をユーザーに送信するのを待っています。

00:07:46.000 -> 00:07:58.000
クロージャの本体が戻ると、システムによってアプリケーションに割り当てられた基礎となるバックグラウンドタスクは暗黙的に完了としてマークされ、システムはアプリケーションを再び一時停止することができます。

00:07:58.000 -> 00:08:08.000
ここでは、Swift Concurrencyを使用すると、作業が完了したときに明示的なコールバックを必要とせずに、バックグラウンドタスクで潜在的に長時間実行される操作を行うことができます。

00:08:08.000 -> 00:08:16.000
通知の追加など、Appleプラットフォーム全体の多くのAPIは、すでに非同期操作のためのSwift Concurrencyをサポートしています。

00:08:16.000 -> 00:08:29.000
ここでは、NotifyForPhoto非同期機能は、UserNotificationCenterにある非同期addNotificationメソッドを使用して、簡単な方法で実装できます。

00:08:29.000 -> 00:08:38.000
Swift Concurrencyとasync/awaitがどのように私たちのためにいくつかの重い作業を行い、バックグラウンドタスクの処理をこれまで以上に簡単にする方法に飛び込みましょう。

00:08:38.000 -> 00:08:43.000
私たちが参照してきた非同期isStormy関数を書いてみましょう。

00:08:43.000 -> 00:08:49.000
この非同期機能は、外の天気をチェックするネットワーク要求を行う必要があります。

00:08:49.000 -> 00:08:56.000
まず、共有URLSessionを取得し、気象データのリクエストをインスタンス化します。

00:08:56.000 -> 00:09:06.000
URLSessionはSwift Concurrencyを採用しており、非同期コンテキストから待つことができるネットワークからデータをダウンロードする方法があります。

00:09:06.000 -> 00:09:12.000
ネットワーク応答を手にして、気象データを読み取り、結果を返すことができます。

00:09:12.000 -> 00:09:19.000
しかし、ランタイムの有効期限が切れる前に、アプリケーションがネットワーク要求を完了できない場合はどうでしょうか?

00:09:19.000 -> 00:09:34.000
この場合、URLSessionをバックグラウンドセッションとして設定し、URLSessionバックグラウンドタスクを使用してアプリケーションに起動イベントを送信することを確認したかったことを思い出してください。

00:09:34.000 -> 00:09:37.000
私たちのコードに戻ります。

00:09:37.000 -> 00:09:41.000
共有URLSessionを使用していました。

00:09:41.000 -> 00:09:51.000
代わりに、sessionSendsLaunchEventsプロパティをtrueに設定して、バックグラウンド設定からURLSessionを作成する必要があります。

00:09:51.000 -> 00:10:02.000
これは、アプリが一時停止されていても一部のネットワーク要求が実行され、その要求が完了したときにURLSessionバックグラウンドタスクのためにアプリをウェイク解除する必要があることをシステムに伝えます。

00:10:02.000 -> 00:10:16.000
watchOSでバックグラウンドで実行されているアプリによって行われたすべてのネットワーク要求は、バックグラウンドURLSessionsを通じて要求する必要があるため、これはwatchOSで特に重要であることに注意してください。

00:10:16.000 -> 00:10:18.000
しかし、私たちはまだ終わっていません。

00:10:18.000 -> 00:10:28.000
バックグラウンドタスクランタイムの有効期限が切れると、システムはバックグラウンドタスク修飾子に提供されるクロージャを実行している非同期タスクをキャンセルすることを思い出してください。

00:10:28.000 -> 00:10:38.000
これは、バックグラウンドランタイムが期限切れになると、ここで行われたネットワーク要求もキャンセルされることを意味します。

00:10:38.000 -> 00:10:47.000
そのキャンセルに対応して処理するには、Swift Concurrencyに組み込まれたwithTaskCancellationHandler関数を使用できます。

00:10:47.000 -> 00:10:57.000
直接結果を待つ代わりに、ダウンロードをwithTaskCancellationHandler呼び出しに配置し、これも待ちます。

00:10:57.000 -> 00:11:03.000
withTaskCancellationHandlerに渡された最初のブロックは、実行して待機したい非同期手順です。

00:11:03.000 -> 00:11:10.000
2番目のonCancelトレーリングクロージャは、タスクがキャンセルされたときに実行されるコードです。

00:11:10.000 -> 00:11:26.000
ここでは、ランタイムの期限切れのために即時のネットワーク要求がキャンセルされた場合、ネットワーク要求をバックグラウンドダウンロードタスクに昇格させ、そこでresumeを呼び出すことができ、アプリが一時停止されても持続するバックグラウンドダウンロードをトリガーします。

00:11:26.000 -> 00:11:41.000
このコードは、同じURLSessionを使用して両方をバックアップしているため、基礎となるネットワーク要求を2回行いません。URLSessionは、内部で処理中の要求を重複排除します。

00:11:41.000 -> 00:11:48.000
最後に、バックグラウンドURLSessionからの起動を処理するようにアプリケーションが設定されていることを確認する必要があります。

00:11:48.000 -> 00:11:54.000
バックグラウンドタスク修飾子を再度使用できますが、今回はURLSessionタスクタイプを使用します。

00:11:54.000 -> 00:12:08.000
先ほど作成したバックグラウンドURLSession設定に同じ識別子を使用することで、その特定のURLSessionがバックグラウンドタスクを生成する場合にのみ、このブロックが呼び出されるようにすることができます。

00:12:08.000 -> 00:12:20.000
バックグラウンドタスクを処理するための新しい統合SwiftUI APIを掘り下げ、Swift Concurrencyがタスクの完了と有効期限の管理をこれまで以上に簡単にする方法を発見しました。

00:12:20.000 -> 00:12:29.000
Swift Concurrencyの詳細については、WWDC 2021の「Meet Async/await in Swift」トークをご覧ください。

00:12:29.000 -> 00:12:37.000
また、SwiftUIの並行性の詳細については、WWDC 2021の「SwiftUIで並行性を発見」をお勧めします。

00:12:37.000 -> 00:12:41.000
「Efficiency awaits: Background Tasks in SwiftUI」をご覧いただきありがとうございます。

00:12:41.000 -> 23:59:59.000
♪

