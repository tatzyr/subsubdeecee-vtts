WEBVTT

00:00:00.000 --> 00:00:03.000
♪まろやかなインストゥルメンタルヒップホップ音楽♪

00:00:03.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:14.000
デヴィン・クラリー:こんにちは。私はメッセージチームのエンジニア、デビンです。

00:00:14.000 --> 00:00:17.000
ランス・パーカー:そして、私はランスで、メッセージエンジニアでもあります。

00:00:17.000 --> 00:00:22.000
デヴィン：「カスタムコラボレーションアプリをメッセージと統合する」へようこそ。

00:00:22.000 --> 00:00:32.000
コラボレーションは会話から始まり、iOS 16とmacOS Venturaでは、アプリのカスタムコラボレーション体験を会話のファブリックに直接組み込むことができます。

00:00:32.000 --> 00:00:36.000
このビデオでは、コラボレーションのライフサイクルについていきます。

00:00:36.000 --> 00:00:42.000
次に、メッセージを通じて共有するアプリの共同コンテンツを準備する方法を紹介します。

00:00:42.000 --> 00:00:52.000
次に、プライバシーを損なうことなく、受信者のアクセスを即座に確認し、参加者の変更に対応するために必要なすべてを提供します。

00:00:52.000 --> 00:00:59.000
最後に、アプリがメッセージの会話にコンテンツに関する通知を投稿する方法を紹介します。

00:00:59.000 --> 00:01:06.000
このビデオは、アプリに既存のコラボレーションインフラストラクチャがあり、すでにユニバーサルリンクを採用していることを前提としています。

00:01:06.000 --> 00:01:14.000
また、「アプリへの共有の追加」と「メッセージとのコラボレーション体験の強化」で導入されたいくつかの概念に基づいて構築します。

00:01:14.000 --> 00:01:24.000
まず、カスタムコラボレーションメッセージのライフサイクルを経て、このAPIにより、ユーザーがこれまで以上に迅速にコラボレーションを開始する方法を説明します。

00:01:24.000 --> 00:01:33.000
ユーザーがメッセージを通じてアプリからのコラボレーションを共有することを決定した場合、まずコンテンツを表すメタデータを作成します。

00:01:33.000 --> 00:01:41.000
メタデータには、ユーザーがメッセージを送信する前に設定できる共有オプションと、カスタマイズできる他の多くのプロパティが含まれています。

00:01:41.000 --> 00:01:46.000
次に、そのメタデータを共有シートに提供するか、ドラッグアンドドロップします。

00:01:46.000 --> 00:01:51.000
これにより、メッセージの作成フィールドでコンテンツの下書きを演出できます。

00:01:51.000 --> 00:01:55.000
コラボレーションは普遍的なリンクで表される必要があります。

00:01:55.000 --> 00:02:00.000
それはすぐに作成できますが、メッセージが送信される直前まで延期するのが最善です。

00:02:00.000 --> 00:02:08.000
これは、アプリのリンク作成が、メッセージ作成フィールドで設定された選択した共有オプションまたは受信者に依存する場合に便利です。

00:02:08.000 --> 00:02:14.000
ユーザーは受信者と共有オプションを選択し、送信ボタンをタップします。

00:02:14.000 --> 00:02:21.000
メッセージが送信される前に、メッセージはアプリにユニバーサルリンクとコンテンツのデバイスに依存しない識別子を要求します。

00:02:21.000 --> 00:02:29.000
その識別子を使用して、メッセージは、その特定のコラボレーションメッセージの受信者を表す一連の暗号化IDを提供します。

00:02:29.000 --> 00:02:38.000
アプリは後でこれらのアイデンティティを使用して、受信者が任意のデバイスでリンクをすぐに開くようにします。

00:02:38.000 --> 00:02:44.000
アプリはこれらのIDをサーバーに保存し、共有コンテンツに関連付けます。

00:02:44.000 --> 00:02:50.000
アプリがこのステップを完了すると、メッセージが受信者に送信されます。

00:02:50.000 --> 00:02:53.000
さて、受信デバイスで起こることは次のとおりです。

00:02:53.000 --> 00:02:59.000
目標は、アクセスを即座に確認し、受信者の身元をサーバー上のアカウントとペアリングすることです。

00:02:59.000 --> 00:03:08.000
受信者がリンクを開くと、アプリは他のリンクと同じようにURLを開くための呼び出しを受け取ります。

00:03:08.000 --> 00:03:18.000
アプリは、ユーザーアカウントがまだドキュメントにアクセスできないことを検出すると、受信者デバイスによって暗号的に署名されたユーザーIDの証明をシステムに照会します。

00:03:18.000 --> 00:03:23.000
アプリは、検証のために署名された身分証明書をサーバーに送信します。

00:03:23.000 --> 00:03:30.000
署名が有効な場合、サーバーは送信デバイスによって以前に提供されたIDと証明を比較します。

00:03:30.000 --> 00:03:35.000
一致する場合、サーバーはユーザーのアカウントへのアクセスを許可します。

00:03:35.000 --> 00:03:42.000
そして、それにより、受信者はアカウント情報を交換することなく、コンテンツへの即時かつ安全なアクセスを得ました!

00:03:42.000 --> 00:03:45.000
そして、それがコラボレーションメッセージのライフサイクルです!

00:03:45.000 --> 00:03:51.000
次に、コラボレーションを開始するためのAPIをより詳しく見てみましょう。

00:03:51.000 --> 00:03:55.000
システムには、コラボレーションに関するメタデータが必要です。

00:03:55.000 --> 00:04:01.000
そのために、Shared with YouフレームワークでSWCollaborationMetadataと呼ばれる新しいクラスを使用します。

00:04:01.000 --> 00:04:21.000
このクラスには、設定するためのいくつかのプロパティがあります。コンテンツのタイトル、共有される前にコンテンツを参照するためのローカル識別子。イニシエータ名とアカウントハンドルは、ユーザーが共有しているアカウントに関する透明性をユーザーに提供します。ユーザーが設定するためのデフォルトの共有オプション。

00:04:21.000 --> 00:04:27.000
メタデータオブジェクトを作成し、そのプロパティを設定する方法は次のとおりです。

00:04:27.000 --> 00:04:33.000
文字列で初期化されたSWLocalCollaborationIdentifierを使用してローカル識別子を作成します。

00:04:33.000 --> 00:04:41.000
文字列は、アプリがデバイス間でではなく、ローカルでコンテンツを識別するのに十分である必要があります。

00:04:41.000 --> 00:04:47.000
ローカル識別子を使用して新しいメタデータインスタンスを初期化します。

00:04:47.000 --> 00:04:57.000
ファンデーションフレームワークのPersonNameComponentsを使用して、コンテンツタイトル、イニシエータのアカウントハンドル、および名前を設定します。

00:04:57.000 --> 00:05:04.000
ハンドルと名前はローカルでのみ表示されるため、ユーザーは共有しているアカウントを確認できます。

00:05:04.000 --> 00:05:07.000
次に、defaultShareOptionsを設定します。

00:05:07.000 --> 00:05:12.000
その方法をお見せする前に、まずオプションの仕組みを説明します。

00:05:12.000 --> 00:05:18.000
共有オプションは、ユーザーがメッセージまたは共有シートのコラボレーションで構成する設定です。

00:05:18.000 --> 00:05:23.000
ユーザーが選択したオプションは、メッセージが送信される前に提供されます。

00:05:23.000 --> 00:05:32.000
共有オプションには、誰がコラボレーションを編集できるか、誰がコンテンツにアクセスできるかなどの設定が含まれる場合があります。

00:05:32.000 --> 00:05:38.000
SWCollaborationOptionから始めて、いくつかのクラスを使用してオプションを定義します。

00:05:38.000 --> 00:05:46.000
グループ化方法に応じて、オプションは個々のスイッチ、または設定の相互に排他的な値を表します。

00:05:46.000 --> 00:05:53.000
オプションにはタイトルと識別子があり、選択または未選択のいずれかです。

00:05:53.000 --> 00:06:04.000
オプションのグループを表すには、SWCollaborationOptionsGroupとSWCollaborationOptions PickerGroupの2つのクラスがあります。

00:06:04.000 --> 00:06:16.000
SWCollaborationOptionsGroupを使用してスイッチのコレクションを表し、SWCollaborationOptions PickerGroupは設定の相互に排他的な値を表します。

00:06:16.000 --> 00:06:25.000
最後に、SWCollaborationShareOptionsは、メタデータのdefaultShareOptionsプロパティに設定するオプショングループのフルセットを定義します。

00:06:25.000 --> 00:06:29.000
オプションを記述するための要約文字列を指定することもできます。

00:06:29.000 --> 00:06:34.000
オプションクラスについて説明したので、使用方法を示す例を次に示します。

00:06:34.000 --> 00:06:38.000
このコードは2つのオプショングループを定義します。

00:06:38.000 --> 00:06:43.000
最初のグループは、識別子と2つの可能なオプションで初期化されます。

00:06:43.000 --> 00:06:50.000
識別子は、後でユーザーが選択したオプションを識別するために使用する任意の文字列です。

00:06:50.000 --> 00:06:54.000
これはピッカーグループなので、オプションは相互に排他的です。

00:06:54.000 --> 00:07:00.000
このグループは、コンテンツの許可設定を表します: 読み取り書き込みまたは読み取り専用。

00:07:00.000 --> 00:07:06.000
次に、そのグループの最初のオプションがデフォルトで選択されます。

00:07:06.000 --> 00:07:11.000
そして、タイトルはこのグループを記述する文字列に設定されています。

00:07:11.000 --> 00:07:16.000
2番目のオプショングループも同じように初期化され、2つのオプションも含まれています。

00:07:16.000 --> 00:07:23.000
しかし、これは一般的なオプショングループであるため、ユーザーはメンションとコメントを個別に許可するかどうかを設定できます。

00:07:23.000 --> 00:07:34.000
最後に、2つのオプショングループを使用してSWCollaborationShareOptionsのインスタンスを初期化し、メタデータに設定します。

00:07:34.000 --> 00:07:42.000
次に、ユーザーがコンテンツの共有を決定する方法に応じて、メタデータが共有シートまたはドラッグアンドドロップに提供されます。

00:07:42.000 --> 00:07:49.000
アプリがSwiftUIを使用している場合、SWCollaborationMetadataは新しいShareLink APIと互換性があります。

00:07:49.000 --> 00:07:58.000
TransferableとShareLinkの詳細については、「Meet Transferable」と「SwiftUIの新機能」をご覧ください。

00:07:58.000 --> 00:08:05.000
SwiftUIでプロキシ表現でのコラボレーションをサポートするのがいかに簡単かをご紹介します!

00:08:05.000 --> 00:08:15.000
転送可能なモデルオブジェクト内から、コラボレーションメタデータインスタンスを返すようにProxyRepresentationを設定します。

00:08:15.000 --> 00:08:22.000
次に、ビューから、そのモデルオブジェクトでShareLinkを初期化します。

00:08:22.000 --> 00:08:28.000
UIKitアプリとAppKitアプリでは、NSItemProviderを使用して共有をサポートします。

00:08:28.000 --> 00:08:33.000
また、SWCollaborationMetadataはNSItemProviderReading and writingに準拠しています。

00:08:33.000 --> 00:08:39.000
そのため、コラボレーションをサポートするために、アイテムプロバイダーにメタデータインスタンスを登録するだけです。

00:08:39.000 --> 00:08:47.000
また、できるだけ多くのチャネルを通じて共有をサポートするために、コンテンツの複数の表現を登録することも良い習慣です。

00:08:47.000 --> 00:08:55.000
たとえば、メッセージは、ファイル表現を提供する場合、コンテンツをコピーとして送信するオプションを自動的に提供します。

00:08:55.000 --> 00:09:08.000
iOSとiPadOSではUIActivityViewControllerとUIDragItem、macOSではNSSharingServicePickerでNSItemProvider APIを使用します。

00:09:08.000 --> 00:09:12.000
iOSの共有シートでそれを設定する方法は次のとおりです。

00:09:12.000 --> 00:09:16.000
NSItemProviderインスタンスを作成します。

00:09:16.000 --> 00:09:25.000
前の例で作成したコラボレーションメタデータを登録し、可視性をシステム上のすべてのプロセスに設定します。

00:09:25.000 --> 00:09:36.000
アイテムプロバイダーでUIActivityItemsConfigurationを初期化し、その設定でUIActivityViewControllerを初期化します。

00:09:36.000 --> 00:09:40.000
そして最後に、ビューコントローラーを提示します。

00:09:40.000 --> 00:09:44.000
ドラッグ&amp;ドロップをサポートするのと同じくらい簡単です。

00:09:44.000 --> 00:09:58.000
NSItemProviderを初期化し、同じ方法でメタデータを登録し、ドラッグアンドドロップAPIで使用するアイテムプロバイダーでUIDragItemを作成します。

00:09:58.000 --> 00:10:03.000
APIは、共有ポップオーバーのmacOSで似ています。

00:10:03.000 --> 00:10:06.000
繰り返しますが、アイテムプロバイダーを設定します。

00:10:06.000 --> 00:10:11.000
そして今回は、それを使ってNSSharingServicePickerを初期化します。

00:10:11.000 --> 00:10:17.000
そして、ターゲットビューに対するピッカーを表示します。

00:10:17.000 --> 00:10:22.000
macOSでのドラッグアンドドロップは、NSItemProviderではなくNSPasteboardItemを利用します。

00:10:22.000 --> 00:10:29.000
これをサポートするために、SharedWithYouはNSPasteboardItem拡張機能をエクスポートします。

00:10:29.000 --> 00:10:39.000
その拡張機能を使用して、ドラッグアンドドロップをサポートするために、新しいNSPasteboardItemインスタンスでコラボレーションメタデータを直接設定します。

00:10:39.000 --> 00:10:45.000
そして、コラボレーションコンテンツのドラフトがメッセージで上演されるために必要なのはそれだけです!

00:10:45.000 --> 00:10:52.000
次に、ユーザーが送信ボタンをタップすると、システムはアプリと連携して共有を設定します。

00:10:52.000 --> 00:10:57.000
これは、SWCollaborationCoordinatorと呼ばれる新しいクラスを通じて行います。

00:10:57.000 --> 00:11:03.000
SWCollaborationCoordinatorはシングルトンであり、グローバルな共有インスタンスがあることを意味します。

00:11:03.000 --> 00:11:09.000
その共有インスタンスは、actionHandlerと呼ばれる定義したデリゲートを通じてコラボレーションを調整します。

00:11:09.000 --> 00:11:15.000
コラボレーションを調整するためにアプリが常に利用可能であることを確認するために、必要に応じてバックグラウンドで起動されます。

00:11:15.000 --> 00:11:22.000
したがって、タイムアウトを避けるために、起動後すぐにデリゲートを登録し、すぐにアクションを処理する必要があります。

00:11:22.000 --> 00:11:28.000
アプリの起動終了後にコラボレーションコーディネーターを設定する方法は次のとおりです。

00:11:28.000 --> 00:11:33.000
共有プロパティからシングルトンコーディネーターインスタンスにアクセスします。

00:11:33.000 --> 00:11:44.000
次に、アプリデリゲートのdidFinishLaunchingWithOptionsメソッドで、actionHandlerプロパティをSWCollaborationActionHandlerプロトコルに準拠したオブジェクトに設定します。

00:11:44.000 --> 00:11:49.000
アクションハンドラプロトコルは、SWActionという新しいクラスを使用します。

00:11:49.000 --> 00:11:53.000
SWActionsは、アプリが実行することが期待される作業を表します。

00:11:53.000 --> 00:11:59.000
完了としてマークするアクションを実行し、そうでない場合は失敗します。

00:11:59.000 --> 00:12:03.000
アプリが処理する必要がある最初のアクションは、コラボレーションアクションの開始です。

00:12:03.000 --> 00:12:12.000
SWStartCollaborationActionには、ユーザーが選択した共有オプションで更新された、以前に設定したコラボレーションメタデータが含まれています。

00:12:12.000 --> 00:12:20.000
必要なセットアップを実行したら、ユニバーサルリンクとコラボレーションのデバイスに依存しない識別子を使用して開始アクションを実行します。

00:12:20.000 --> 00:12:26.000
明示的に開始アクションに失敗すると、メッセージはキャンセルされます。

00:12:26.000 --> 00:12:32.000
これは、サーバーリクエストの例を使用して開始アクションを処理するための実装です。

00:12:32.000 --> 00:12:40.000
まず、アクションのメタデータプロパティからローカル識別子とユーザーが選択した共有オプションを取得します。

00:12:40.000 --> 00:12:47.000
識別子とオプションを使用してコラボレーションを準備するためのサーバーリクエストを設定します。

00:12:47.000 --> 00:12:50.000
次に、リクエストをサーバーに送信します。

00:12:50.000 --> 00:12:54.000
この例では、async awaitを使用しています。

00:12:54.000 --> 00:13:01.000
最後に、ユニバーサルリンクと応答からのデバイスに依存しない識別子でアクションを実行します。

00:13:01.000 --> 00:13:05.000
または、エラーが発生した場合は、メッセージをキャンセルするアクションに失敗します。

00:13:05.000 --> 00:13:13.000
開始アクションが成功した場合、システムはコラボレーション参加者を更新するための2番目のアクションをアプリに送信します。

00:13:13.000 --> 00:13:19.000
SWUpdateCollaboration ParticipantsActionには、参加者の暗号IDが含まれています。

00:13:19.000 --> 00:13:26.000
アイデンティティは、前のステップの開始アクションによって満たされたコラボレーション識別子から派生します。

00:13:26.000 --> 00:13:30.000
コンテンツに関連付けられたIDをサーバーに保存します。

00:13:30.000 --> 00:13:35.000
このデータを使用して、受信者のデバイスでのアクセスを検証します。

00:13:35.000 --> 00:13:40.000
最後に、このアクションを実行すると、メッセージのユニバーサルリンクが送信されます。

00:13:40.000 --> 00:13:45.000
この例は、参加者の更新アクションを処理する方法を示しています。

00:13:45.000 --> 00:13:49.000
アクションのメタデータからコラボレーション識別子を取得します。

00:13:49.000 --> 00:13:53.000
これは、開始アクションの処理中に達成した識別子です。

00:13:53.000 --> 00:14:01.000
次に、アクションのaddedIdentitiesプロパティを使用して、サーバーに保存する参加者データを取得します。

00:14:01.000 --> 00:14:05.000
各アイデンティティには、ルートハッシュと呼ばれるデータプロパティがあります。

00:14:05.000 --> 00:14:09.000
これは、後で使用するためにサーバーに保存すべきデータです。

00:14:09.000 --> 00:14:16.000
ランスは、このプロパティの詳細を「アクセスの確認」セクションで確認します。

00:14:16.000 --> 00:14:23.000
別のサーバーリクエストを設定し、今回は参加者をターゲット識別子とのコラボレーションに追加します。

00:14:23.000 --> 00:14:29.000
そして、以前と同じように、リクエストをサーバーに送信し、アクションを実行または失敗します。

00:14:29.000 --> 00:14:34.000
今回、フルフィルメントメソッドはパラメータを取りません。

00:14:34.000 --> 00:14:42.000
コラボレーションを設定したので、アプリにはメッセージの受信者への即時アクセスを許可するために必要なものがすべて揃っています。

00:14:42.000 --> 00:14:44.000
ランスに渡して、その方法をお見せします。

00:14:44.000 --> 00:14:56.000
ランス:ありがとう、デヴィン。このセクションでは、前の手順でサーバーに保存したIDデータを使用して、受信者に即時アクセスを提供する方法を紹介します。

00:14:56.000 --> 00:15:02.000
SWPersonIdentityのrootHashプロパティは、この検証を行うために使用されます。

00:15:02.000 --> 00:15:08.000
rootHashは、デバイス上の参加者を一意に識別するために使用される安全な値です。

00:15:08.000 --> 00:15:14.000
検証を実行するには、ルートハッシュの計算方法を理解する必要があります。

00:15:14.000 --> 00:15:16.000
今からそれを案内します。

00:15:16.000 --> 00:15:24.000
コラボレーションメッセージが送信されると、実際には各人のデバイスに個別に送信されます。

00:15:24.000 --> 00:15:29.000
メッセージは、暗号化された公開鍵を使用して各デバイスを識別します。

00:15:29.000 --> 00:15:39.000
目標は、この一連のデバイスでのみアクセスを許可することであるため、ルートハッシュは各受信者に登録された公開鍵のセットから派生します。

00:15:39.000 --> 00:15:45.000
ルートハッシュは、マークルツリーと呼ばれるデータ構造のルートノードです。

00:15:45.000 --> 00:15:51.000
マークルツリーは、一連のハッシュ操作を実行することによって構築されるバイナリツリーです。

00:15:51.000 --> 00:15:59.000
公開鍵に基づいてユーザーのアイデンティティを導き出すために、キーはこのツリーの葉として使用されます。

00:15:59.000 --> 00:16:07.000
Merkleツリーで使用されるハッシュアルゴリズムは、ルートノードがそのキーセットからのみ計算できることを保証します。

00:16:07.000 --> 00:16:15.000
この例では、このユーザーは3つのデバイスと3つの公開鍵を持っています。

00:16:15.000 --> 00:16:24.000
キーは、キーの多様化と呼ばれるプロセスを使用して、アプリが提供するコラボレーション識別子ごとに一意になります。

00:16:24.000 --> 00:16:31.000
ユーザーに登録されたデバイスの数の追跡を防ぐために、セットには固定サイズまでのランダムなキーが埋め込まれています。

00:16:31.000 --> 00:16:38.000
ツリーのリーフノードは、多様なキーのパッド入りセットをハッシュすることによって作成されます。

00:16:38.000 --> 00:16:44.000
SHA256アルゴリズムは、このツリーのハッシュ操作に使用されます。

00:16:44.000 --> 00:16:51.000
次に、各リーフノードのペアが連結され、ハッシュ化され、親ノードが導出されます。

00:16:51.000 --> 00:17:00.000
このプロセスは親ノードで繰り返され、単一のルートノードが残るまで繰り返されます。

00:17:00.000 --> 00:17:09.000
これは、デバイス間でこの受信者の身元を一意に表現するために使用されるルートハッシュです。

00:17:09.000 --> 00:17:17.000
完全なマークルツリーからノードのサブセットを使用してルートハッシュを生成できることに注意してください。

00:17:17.000 --> 00:17:29.000
このツリーのルートハッシュは、多様な公開鍵P3とともに、ハッシュH4、7、および11のみを使用して再現できます。

00:17:29.000 --> 00:17:35.000
まず、公開鍵をハッシュして、不足しているリーフノードH3を取得します。

00:17:35.000 --> 00:17:39.000
H3とH4を使用してH8を生成します。

00:17:39.000 --> 00:17:44.000
H8で指定されたH7ノードを使用してH10を生成します。

00:17:44.000 --> 00:17:49.000
そして最後に、H10とH11はルートハッシュを生成します。

00:17:49.000 --> 00:17:59.000
ツリー全体を再構築することなく、公開鍵P3が指定されたルートハッシュを生成するために使用されたことを証明できることに注意することが重要です。

00:17:59.000 --> 00:18:05.000
これを行うために必要なノードのサブセットは、包含の証明と呼ばれます。

00:18:05.000 --> 00:18:10.000
検証は、アプリでユニバーサルリンクが開かれたときに開始されます。

00:18:10.000 --> 00:18:15.000
これを行うには、まずリンクが共同作業であることを確認する必要があります。

00:18:15.000 --> 00:18:22.000
SWCollaborationHighlightは共同リンクを表し、SWHighlightCenterから取得されます。

00:18:22.000 --> 00:18:28.000
そのコラボレーションのハイライトを使用して、包含の証明を生成します。

00:18:28.000 --> 00:18:35.000
包含の証明を表すには、SWPersonIdentityProofというクラスを使用します。

00:18:35.000 --> 00:18:43.000
検証を実行するには、まずこのオブジェクトと暗号化署名を生成してサーバーに送信します。

00:18:43.000 --> 00:18:48.000
SWHighlightCenterのgetSignedIdentityProofメソッドを使用して証明を取得します。

00:18:48.000 --> 00:18:57.000
デバイスによって署名するには、SWCollaborationHighlightといくつかの任意のデータが必要です。

00:18:57.000 --> 00:19:05.000
署名を使用して、悪いアクターがリクエストを再生してコラボレーションにアクセスできないようにします。

00:19:05.000 --> 00:19:13.000
データは、サーバーに要求するチャレンジ、またはデバイスで生成されたノンスである可能性があります。

00:19:13.000 --> 00:19:16.000
この例では、チャレンジアプローチを使用しています。

00:19:16.000 --> 00:19:22.000
URLは、アプリのUIApplicationDelegateでこのメソッドに渡されます。

00:19:22.000 --> 00:19:28.000
このURLは、コラボレーションに関連するユニバーサルリンクです。

00:19:28.000 --> 00:19:36.000
URLは、関連するSWCollaborationHighlightをSWHighlightCenterから取得するために使用されます。

00:19:36.000 --> 00:19:50.000
次に、サーバーからチャレンジをリクエストし、取得したデータをハイライトとともにSWHighlightCenterのgetSignedIdentityProofメソッドに渡します。

00:19:50.000 --> 00:19:53.000
このメソッドは、署名された身分証明書を返します。

00:19:53.000 --> 00:19:58.000
このデータを検証するためにサーバーが何をすべきかについては、後で説明します。

00:19:58.000 --> 00:20:03.000
これで、署名された証明をサーバーに送信して確認することができます。

00:20:03.000 --> 00:20:09.000
最後に、結果でユーザーインターフェイスを更新します。

00:20:09.000 --> 00:20:16.000
アプリは、公開鍵と署名されたデータとともに、証明をサーバーに送信します。

00:20:16.000 --> 00:20:27.000
データは、ハッシュ関数としてSHA256を使用して、P-256楕円曲線上の楕円曲線デジタル署名アルゴリズムを使用して署名されます。

00:20:27.000 --> 00:20:32.000
身分証明書の公開鍵を使用して、データの署名を確認します。

00:20:32.000 --> 00:20:38.000
これは、最も一般的に使用される暗号化ライブラリで行うことができます。

00:20:38.000 --> 00:20:46.000
署名を確認したら、その公開鍵に関連付けられたデバイスから身分証明書が送信されたことを信頼できます。

00:20:46.000 --> 00:20:52.000
次に、身分証明書を使用してルートハッシュを再計算します。

00:20:52.000 --> 00:20:59.000
これは、以前に見た例木を使用して、SWPersonIdentityProofに含まれるものの例です。

00:20:59.000 --> 00:21:04.000
マークルツリーのルートハッシュを再構築するために使用します。

00:21:04.000 --> 00:21:06.000
公開鍵はP3です。

00:21:06.000 --> 00:21:12.000
包含ハッシュはH4、7、11です。

00:21:12.000 --> 00:21:19.000
2のローカルキーインデックスは、ツリー内の公開鍵の位置を示します。

00:21:19.000 --> 00:21:26.000
プルーフのプロパティからルートハッシュを再構築する実装例を次に示します。

00:21:26.000 --> 00:21:32.000
再帰アルゴリズムは、ツリーデータ構造を操作するときにうまく機能するので、それは私がここでやったことです。

00:21:32.000 --> 00:21:44.000
最初の呼び出し時に、公開鍵のハッシュ、包含ハッシュのセット、および公開鍵インデックスを渡します。

00:21:44.000 --> 00:21:49.000
次に、最初の包含ハッシュが引き出されます。

00:21:49.000 --> 00:21:56.000
公開鍵インデックスは、キーが兄弟の左側にあるか右にあるかを確認します。

00:21:56.000 --> 00:22:03.000
選択したハッシュは正しい順序で連結され、ハッシュ化されます。

00:22:03.000 --> 00:22:14.000
次に、inclusionHashes配列の消費されたノードが削除され、残りはこの同じ関数への再帰呼び出しに渡されます。

00:22:14.000 --> 00:22:20.000
公開鍵インデックスも更新され、ツリー内の次のノードの準備が整います。

00:22:20.000 --> 00:22:28.000
このシンプルな関数を使用すると、身分証明書が与えられたルートハッシュをすばやく計算できます。

00:22:28.000 --> 00:22:36.000
サーバーは、この生成されたルートハッシュが、送信中にアップロードされたドキュメントの所有者のルートハッシュのリストにあることを確認できるようになりました。

00:22:36.000 --> 00:22:42.000
ハッシュは既知のハッシュのリストに存在するため、サーバーはドキュメントへのアクセスを許可できます。

00:22:42.000 --> 00:22:46.000
これで、自信を持って文書へのアクセスを許可することができます!

00:22:46.000 --> 00:22:55.000
身元を確認するために従う手順を要約するには、まず、ユニバーサルリンクを処理しながら、コンテンツのコラボレーションのハイライトを調べます。

00:22:55.000 --> 00:22:59.000
次に、いくつかのデータに署名し、包含の証明を取得します。

00:22:59.000 --> 00:23:04.000
署名されたデータと証明をサーバーに送信します。

00:23:04.000 --> 00:23:07.000
データの署名を確認します。

00:23:07.000 --> 00:23:11.000
包含の証明を使用して、ルートハッシュを生成します。

00:23:11.000 --> 00:23:19.000
最後に、ルートハッシュをそのコンテンツに関連付けられた既知のアイデンティティのリストと比較します。

00:23:19.000 --> 00:23:28.000
コラボレーションリンクへのアクセスの検証についてすべてわかったので、参加者の変更をメッセージで調整する方法について説明します。

00:23:28.000 --> 00:23:40.000
メッセージグループの参加者が変更され、そのグループが一緒に共同作業している場合、ユーザーはメッセージスレッドのバナーから直接、それらの変更をアプリに伝播することを選択できます。

00:23:40.000 --> 00:23:50.000
このシナリオでは、アプリは追加および削除されたIDを含む別のSWUpdateCollaboration ParticipantsActionを受け取ります。

00:23:50.000 --> 00:24:00.000
コラボレーションを設定するときに、このアクションを処理するために書いたのと同じコードを使用しますが、削除された参加者も処理する必要があります。

00:24:00.000 --> 00:24:06.000
削除するには、削除されたIDに関連付けられているアカウントを検索し、アクセスを取り消すだけです。

00:24:06.000 --> 00:24:12.000
アカウントがまだ関連付けられていない場合は、データベースからルートハッシュを削除するだけです。

00:24:12.000 --> 00:24:19.000
これは、Devinが以前に実施した更新参加者アクションの実装です。

00:24:19.000 --> 00:24:28.000
この例では、アクションで削除されたアイデンティティプロパティを使用し、同様の削除APIリクエストに渡します。

00:24:28.000 --> 00:24:38.000
このコードは削除されたアイデンティティの処理のみを示していますが、完全な実装では、追加されたアイデンティティと削除されたアイデンティティの両方を処理する必要があることに注意してください。

00:24:38.000 --> 00:24:42.000
そして、参加者の変更を処理するために必要なのはそれだけです!

00:24:42.000 --> 00:24:50.000
最後に、コラボレーションに変更が加えられると、アプリはそれらの変更について通知し、メッセージに直接表示されます。

00:24:50.000 --> 00:24:55.000
このセクションで確認する、サポートされている通知にはいくつかの種類があります。

00:24:55.000 --> 00:25:01.000
通知は、リンクが共有された会話の中でバナーとして表示されます。

00:25:01.000 --> 00:25:07.000
バナーには、変更された内容と、誰が変更したかの説明が含まれています。

00:25:07.000 --> 00:25:12.000
この会話では、チャーリーはベーキングレシピの文書を編集しました。

00:25:12.000 --> 00:25:17.000
ショーボタンをタップすると、コンテンツにすぐに接続されます。

00:25:17.000 --> 00:25:24.000
通知を表すために、SharedWithYouフレームワークにはSWHighlightEventという名前のプロトコルがあります。

00:25:24.000 --> 00:25:31.000
ハイライトイベントは、SWHighlightCenter APIから取得したSWHighlightsで初期化されます。

00:25:31.000 --> 00:25:36.000
メッセージは、いくつかのカテゴリのイベントをサポートしています。

00:25:36.000 --> 00:25:54.000
コンテンツの更新またはコメントの変更イベント、参加者が参加または退出したときのメンバーシップイベント、ユーザーがコラボレーションで言及されたときのメンションイベント、コンテンツが移動または削除されたときの永続性イベント。

00:25:54.000 --> 00:25:59.000
以下は、コラボレーションを編集するための変更イベントを投稿する方法を示す例です。

00:25:59.000 --> 00:26:06.000
ハイライトセンターAPIを使用して、ターゲット識別子のコラボレーションハイライトを取得します。

00:26:06.000 --> 00:26:17.000
この識別子は、コラボレーションの開始時に定義した識別子であるため、コンテンツの変更が行われたときにアプリが使用できるようにする必要があります。

00:26:17.000 --> 00:26:21.000
次に、ハイライト変更イベントインスタンスを作成します。

00:26:21.000 --> 00:26:30.000
イニシャライザはハイライトとトリガー列挙値を取ります。この場合、編集タイプに設定します。

00:26:30.000 --> 00:26:36.000
最後に、再びハイライトセンターを使用して、そのイベントの通知を投稿します。

00:26:36.000 --> 00:26:49.000
同様に、メンバーシップの変更については、メンバーシップイベントを投稿し、今回は追加されたコラボレータまたは削除されたコラボレータのトリガータイプを渡します。

00:26:49.000 --> 00:26:55.000
次に、アプリがユーザーのメンションをサポートしている場合は、メンションイベントを投稿できます。

00:26:55.000 --> 00:27:00.000
言及されたユーザーのルートハッシュで個人のアイデンティティを初期化します。

00:27:00.000 --> 00:27:07.000
アクセスを検証中に、人の身元をアプリのユーザーアカウントに関連付けたことを思い出してください。

00:27:07.000 --> 00:27:15.000
次に、同じ方法でメンションイベントを投稿し、今回は言及されたアイデンティティをパラメータとして渡します。

00:27:15.000 --> 00:27:21.000
この通知は、言及されたユーザーへのメッセージにのみ表示されます。

00:27:21.000 --> 00:27:29.000
最後に、コンテンツが移動、名前変更、または削除されたときに、永続性イベントタイプを使用します。

00:27:29.000 --> 00:27:37.000
ここでは、ユーザーがコンテンツの名前を変更したことを示すために、名前が変更されたトリガータイプが使用されます。

00:27:37.000 --> 00:27:46.000
そして、それはあなたのアプリが共同作業者に通知する方法であり、彼らはメッセージでそれらの更新を取得します。

00:27:46.000 --> 00:27:52.000
Devin: そして、いくつかの手順に従うことで、アプリのコラボレーション体験をメッセージと統合する準備が整いました。

00:27:52.000 --> 00:28:06.000
共同で共有するコンテンツを設定し、参加者のアクセスを暗号的に検証し、参加者の変更を追跡し、メッセージに通知を投稿して、ユーザーをコンテンツに直接接続します。

00:28:06.000 --> 00:28:15.000
コラボレーション用に表示できる新しいUI要素の詳細については、「メッセージでコラボレーション体験を強化する」ビデオを必ず確認してください。

00:28:15.000 --> 00:28:18.000
ランス:あなたのアプリとコラボレーションするのが待ちきれません!

00:28:18.000 --> 00:28:20.000
デビンとランス、暗号的にサインオフ。

00:28:20.000 --> 00:28:22.000
デヴィン：見てくれてありがとう！

00:28:22.000 --> 23:59:59.000
♪

