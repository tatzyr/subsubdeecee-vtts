WEBVTT

00:00:01.000 -> 00:00:11.000
- こんにちは！私の名前はアンドレイです。

00:00:11.000 -> 00:00:15.000
私はMetal FrameworksチームのGPUソフトウェアエンジニアです。

00:00:15.000 -> 00:00:19.000
今日は、メタルメッシュシェーダーをご紹介できることを嬉しく思います。

00:00:19.000 -> 00:00:26.000
メッシュシェーダーは、GPU主導のジオメトリの作成と処理のためのMetalの新しい柔軟なパイプラインです。

00:00:26.000 -> 00:00:35.000
頂点/フラグメントパイプラインを改善し、多くの柔軟性を追加し、頂点ごとの処理の制限を取り除きます。

00:00:35.000 -> 00:00:52.000
複数のアプリケーションがありますが、きめ細かいジオメトリの淘汰、GPUでのスケーラブルな手続き型ジオメトリの作成、圧縮された頂点ストリーム、メッシュレット、複雑な手続き型アルゴリズムなどのカスタムジオメトリ入力の許可など、これらに限定されません。

00:00:52.000 -> 00:00:55.000
今日はこの3つのことを取り上げたいと思います。

00:00:55.000 -> 00:00:59.000
まず、メタルメッシュシェーダーとは何かについて確認します。

00:00:59.000 -> 00:01:03.000
次に、2つのメッシュシェーダーのユースケースについてお話ししたいと思います。

00:01:03.000 -> 00:01:09.000
メッシュシェーダーは、手続き型毛のレンダリングなどの手続き型ジオメトリを生成するのに最適です。

00:01:09.000 -> 00:01:13.000
メッシュシェーダーは、シーンの処理とレンダリングの改善にも役立ちます。

00:01:13.000 -> 00:01:19.000
これの主な例は、メッシュシェーダーを使用してGPU駆動のメッシュレットカリングを実装することです。

00:01:19.000 -> 00:01:21.000
メッシュシェーダーの導入から始めましょう。

00:01:21.000 -> 00:01:27.000
これはスタンフォードバニーで、GPUでレンダリングできる典型的なメッシュを表しています。

00:01:27.000 -> 00:01:34.000
このメッシュをレンダリングするには、まず頂点とインデックスデータをデバイスのメモリに配置する必要があります。

00:01:34.000 -> 00:01:39.000
次に、レンダリングコマンドエンコーダを使用してドローコールを実行する必要があります。

00:01:39.000 -> 00:01:52.000
従来のレンダリングパイプラインは、プログラム可能な頂点シェーダーステージ、固定機能ラスタライズステージ、プログラム可能なフラグメントシェーダーステージの3つの基本段階で構成されています。

00:01:52.000 -> 00:01:57.000
頂点シェーダーステージは、デバイスメモリからジオメトリを入力として取り、それを処理します。

00:01:57.000 -> 00:02:04.000
ラスタライザはスクリーンスペースのフラグメントを生成し、フラグメントシェーダーはそれらをシェーディングして最終的な画像を生成します。

00:02:04.000 -> 00:02:08.000
このパイプラインは、その目的に非常によく役立っています。

00:02:08.000 -> 00:02:13.000
しかし、柔軟性に欠け、一定の制限があります。

00:02:13.000 -> 00:02:15.000
例を踏んでみましょう。

00:02:15.000 -> 00:02:19.000
GPUでいくつかの手続き型ジオメトリを生成したいと想像してみてください。

00:02:19.000 -> 00:02:25.000
例えば、あなたはこのバニーに手続き的な毛皮を追加することにしました。

00:02:25.000 -> 00:02:30.000
このタスクが従来のジオメトリパイプラインでどのように処理されるかをお見せしましょう。

00:02:30.000 -> 00:02:40.000
従来、手続き型ジオメトリを生成するには、コンピューティングカーネルディスパッチを実行するコンピューティングコマンドエンコーダも必要です。

00:02:40.000 -> 00:02:49.000
コンピューティングカーネルは、元のメッシュを入力として取り、手続き型ジオメトリを生成し、デバイスメモリに出力します。

00:02:49.000 -> 00:02:57.000
次に、レンダリングコマンドエンコーダを使用して、手続き型ジオメトリを入力として取り、最終的な画像を生成する描画呼び出しを実行します。

00:02:57.000 -> 00:03:05.000
このアプローチでは、2つのコマンドエンコーダを必要とするだけでなく、手続き型ジオメトリを格納するために追加のメモリを割り当てる必要があります。

00:03:05.000 -> 00:03:13.000
間接的なドローコールや高い拡張係数の場合、このメモリの量は非常に高く、予測が難しい場合があります。

00:03:13.000 -> 00:03:18.000
2つのエンコーダの間には障壁もあり、GPU全体で作業をシリアル化します。

00:03:18.000 -> 00:03:21.000
メタルメッシュシェーダーは、これらすべての問題に対処します。

00:03:21.000 -> 00:03:32.000
メッシュシェーダーは、頂点シェーダーステージをオブジェクトシェーダーステージとメッシュシェーダーステージの2つの新しいプログラム可能なステージに置き換える新しいジオメトリパイプラインです。

00:03:32.000 -> 00:03:41.000
この例では、オブジェクトシェーダーはジオメトリを入力として取り、それを処理し、「ペイロード」と呼ばれるデータをメッシュシェーダーに出力します。

00:03:41.000 -> 00:03:45.000
このデータが何であるかを決めるのはあなた次第です。

00:03:45.000 -> 00:03:50.000
メッシュシェーダーは、順番に、このデータを使用して手続き型ジオメトリを生成します。

00:03:50.000 -> 00:03:58.000
この手続き型ジオメトリはドローコール内にのみ存在するので、デバイスメモリを割り当てる必要はありません。

00:03:58.000 -> 00:04:06.000
ラスタライザに直接パイプライン化され、その後、最終的な画像を生成するフラグメントシェーダーにパイプラインされます。

00:04:06.000 -> 00:04:12.000
メッシュドロー呼び出しは、従来のドロー呼び出しと同じタイプのレンダリングコマンドエンコーダを使用して実行されます。

00:04:12.000 -> 00:04:16.000
メッシュドローコールと従来のドローコールを混合して一致させることができます。

00:04:16.000 -> 00:04:22.000
では、2つの新しいプログラム可能なステージを見てみましょう。

00:04:22.000 -> 00:04:27.000
頂点シェーダーとは対照的に、オブジェクトとメッシュシェーダーは計算カーネルに似ています。

00:04:27.000 -> 00:04:30.000
それらはスレッドグループのグリッドで起動されます。

00:04:30.000 -> 00:04:37.000
各スレッドグループは、コンピューティングスレッドと同様に、相互に通信できる個々のスレッドのグリッドです。

00:04:37.000 -> 00:04:48.000
さらに、各オブジェクトスレッドグループはメッシュグリッドを生成し、起動するメッシュグリッドのサイズをプログラムで定義し、十分な柔軟性を提供します。

00:04:48.000 -> 00:04:53.000
各オブジェクトスレッドグループは、ペイロードデータを生成するメッシュグリッドに渡します。

00:04:53.000 -> 00:04:57.000
名前が示すように、オブジェクトステージはオブジェクトを処理します。

00:04:57.000 -> 00:05:01.000
オブジェクトは、ニーズに応じて定義できる抽象的な概念です。

00:05:01.000 -> 00:05:09.000
これは、シーンモデル、シーンモデルの一部、またはたとえば、手続き型ジオメトリを生成するスペースの領域にすることができます。

00:05:09.000 -> 00:05:15.000
メッシュステージは、メッシュを構築し、ジオメトリデータをラスタライザに直接送信するように設計されています。

00:05:15.000 -> 00:05:20.000
次の2つの例では、オブジェクトとメッシュの関係について説明します。

00:05:20.000 -> 00:05:23.000
1つ目は、メッシュシェーダーを使用してヘアレンダリングを実装することです。

00:05:23.000 -> 00:05:28.000
この作業を簡素化するために、バニーモデルの代わりに、単純な平面を使用します。

00:05:28.000 -> 00:05:41.000
髪のパッチを生成するには、入力ジオメトリをタイルに分割し、各タイルは詳細のレベルと生成する必要があるストランドの数を計算し、個々の髪のストランドを生成します。

00:05:41.000 -> 00:05:46.000
メッシュシェーダーを使用して、この平面上で手続き的に髪を生成する方法をお見せしましょう。

00:05:46.000 -> 00:05:52.000
平面はタイルに分割することができ、各タイルはオブジェクトのスレッドグループに対応します。

00:05:52.000 -> 00:05:59.000
各オブジェクトスレッドグループは、ヘアストランドの数を計算し、各ストランドのカーブコントロールポイントを生成します。

00:05:59.000 -> 00:06:01.000
これがペイロードになります。

00:06:01.000 -> 00:06:08.000
その後、オブジェクトスレッドグループはメッシュグリッドを起動し、各メッシュスレッドグループは1本の髪の毛を表します。

00:06:08.000 -> 00:06:11.000
各メッシュスレッドグループは、メッシュをラスタライザーに出力します。

00:06:11.000 -> 00:06:21.000
新しいジオメトリパイプラインを使用すると、ジオメトリ処理をハードウェアに密接にマッピングでき、GPUが提供するすべてのスレッドを最大限に活用できます。

00:06:21.000 -> 00:06:27.000
メッシュレンダリングパイプラインでは、入力ジオメトリはオブジェクトシェーダーグリッドのタイルに分割されます。

00:06:27.000 -> 00:06:33.000
各オブジェクトシェーダースレッドグループは、独立してペイロードを生成し、メッシュグリッドを起動できます。

00:06:33.000 -> 00:06:41.000
グリッドからの各メッシュシェーダースレッドグループは、レンダリングパイプラインの残りの部分でさらに処理される金属::メッシュを生成します。

00:06:41.000 -> 00:06:46.000
これらの各段階で生成されたデータを詳しく見てみましょう。

00:06:46.000 -> 00:06:48.000
ペイロードはオブジェクトシェーダーで定義されています。

00:06:48.000 -> 00:06:55.000
各オブジェクトスレッドグループは、カスタマイズされたペイロードを、オブジェクトスレッドグループが生成する生成されたメッシュグリッドに渡します。

00:06:55.000 -> 00:07:00.000
ヘアレンダリングの場合、ペイロードはカーブコントロールポイントで構成されています。

00:07:00.000 -> 00:07:09.000
一方、メッシュシェーダーは、新しいmetal::meshタイプを介して頂点とプリミティブデータを出力し、これについて少し詳しく説明します。

00:07:09.000 -> 00:07:15.000
オブジェクトとメッシュステージは、パイプラインの残りの部分によって消費されるメッシュデータを出力します。

00:07:15.000 -> 00:07:25.000
従来のパイプラインからの頂点出力と同様に、メッシュデータは最初にラスタライザーによって消費され、次にフラグメントシェーダーが実行されます。

00:07:25.000 -> 00:07:30.000
ヘアレンダリングメッシュパイプラインの設定方法を深く掘り下げてみましょう。

00:07:30.000 -> 00:07:38.000
まず、髪で覆われる平面はタイルに分割され、各タイルはオブジェクトのスレッドグループに対応します。

00:07:38.000 -> 00:07:45.000
オブジェクトスレッドグループは、メッシュグリッドのサイズを決定し、メッシュグリッドに渡すペイロードデータを初期化します。

00:07:45.000 -> 00:07:54.000
この場合、タイルには6本の髪の毛があり、各ストランドの曲線ペイロードデータとともに3x2メッシュグリッドを生成します。

00:07:54.000 -> 00:07:57.000
各スレッドグループは、独自のメッシュグリッドサイズを生成できます。

00:07:57.000 -> 00:08:07.000
次のスレッドグループでは、4本の髪の毛のみを生成する必要があるため、4本のストランドの曲線ペイロードデータの初期化とともに、2x2メッシュグリッドが設定されます。

00:08:07.000 -> 00:08:11.000
これは、このアプローチを実装するオブジェクトシェーダーがどのように見えるかです。

00:08:11.000 -> 00:08:17.000
オブジェクト属性がMetalに追加され、オブジェクトシェーダーのコードが指定されました。

00:08:17.000 -> 00:08:26.000
ペイロード属性とobject_dataアドレス空間に加えて、ペイロード引数をシェーダーで使用できるようにします。

00:08:26.000 -> 00:08:31.000
メッシュグリッドプロパティ引数は、メッシュグリッドサイズをエンコードするために使用されます。

00:08:31.000 -> 00:08:34.000
次のステップはパイプラインの初期化です。

00:08:34.000 -> 00:08:47.000
まず、メッシュレンダリングパイプライン記述子を割り当て、次にオブジェクト関数を初期化し、スレッドグループあたりのスレッドの最大数とともに、目的のペイロード長を指定します。

00:08:47.000 -> 00:08:50.000
オブジェクトシェーダーには一定の制約があります。

00:08:50.000 -> 00:08:54.000
ペイロードの形式とコンテンツは完全にカスタマイズ可能です。

00:08:54.000 -> 00:08:58.000
ただし、ペイロードサイズは16キロバイトの制限を超えることはできません。

00:08:58.000 -> 00:09:06.000
また、各オブジェクトスレッドグループが生成するメッシュスレッドグループの最大数は1024を超えることはできません。

00:09:06.000 -> 00:09:11.000
オブジェクトシェーダーステージを準備した後の次のステップは、メッシュシェーダーステージを初期化することです。

00:09:11.000 -> 00:09:15.000
メッシュシェーダーには、ユーザーが入力として定義したペイロードがあります。

00:09:15.000 -> 00:09:19.000
この例では、ペイロードはカーブコントロールポイントのセットです。

00:09:19.000 -> 00:09:25.000
各メッシュスレッドグループは、髪の毛の一本である金属::メッシュを生成します。

00:09:25.000 -> 00:09:29.000
メッシュシェーダーの出力メッシュは、metal::meshタイプである必要があります。

00:09:29.000 -> 00:09:38.000
metal::meshは、頂点とプリミティブデータをラスタライザとフラグメントシェーダーに出力するためのインターフェースを提供するMetalの組み込み構造です。

00:09:38.000 -> 00:09:57.000
各metal::meshは、頂点シェーダーの出力タイプ、プリミティブデータ型、頂点の最大数、プリミティブの最大数、そして最後に、点、線、または三角形のいずれかのメッシュトポロジと同様に、頂点データ型を定義します。

00:09:57.000 -> 00:10:04.000
メッシュ属性は、メッシュシェーダーのコードを指定するためにメタルシェーディング言語に追加されました。

00:10:04.000 -> 00:10:09.000
Metal::meshは、メッシュシェーダーの出力構造として使用されます。

00:10:09.000 -> 00:10:18.000
メッシュシェーダーは、これらの金属::メッシュをその場で生産できるため、GPU駆動のジオメトリ処理に最適です。

00:10:18.000 -> 00:10:27.000
メッシュシェーダーは、金属::meshを有利に活用するため、追加のコンピューティングパスなしでレンダリングコマンドにより多くの処理を入れることができます。

00:10:27.000 -> 00:10:31.000
メッシュのエンコードは、同じスレッドグループ内のスレッド間で行われます。

00:10:31.000 -> 00:10:39.000
この例では、スレッドグループの最初の9つのスレッドは、このヘアストランドの頂点、インデックス、およびプリミティブデータをエンコードします。

00:10:39.000 -> 00:10:45.000
スレッド0から4まで、それぞれメッシュ内の1つの頂点をエンコードします。

00:10:45.000 -> 00:10:50.000
スレッドグループの残りのスレッドは、メッシュ内の頂点をエンコードしません。

00:10:50.000 -> 00:10:57.000
次に、9つのスレッドすべてが1つのインデックスをメッシュインデックスにエンコードします。

00:10:57.000 -> 00:11:03.000
次に、最初の3つのスレッドは、3つの三角形のプリミティブデータをエンコードします。

00:11:03.000 -> 00:11:07.000
残りのスレッドはプリミティブデータをエンコードしません。

00:11:07.000 -> 00:11:12.000
そして最後に、1つのスレッドは、metal::meshのプリミティブカウントをエンコードします。

00:11:12.000 -> 00:11:16.000
このメッシュシェーダーのソースコードをお見せしましょう。

00:11:16.000 -> 00:11:30.000
メッシュシェーダーは、頂点、インデックス、プリミティブデータ、そして最後にプリミティブカウントをエンコードするために同じ手順に従って、スレッドのできるだけ多くの発散を避けるために編成されています。

00:11:30.000 -> 00:11:34.000
メッシュパイプライン記述子の初期化に戻りましょう。

00:11:34.000 -> 00:11:41.000
メッシュパイプライン記述子では、メッシュスレッドグループごとの最大スレッドとともにメッシュ関数が設定されます。

00:11:41.000 -> 00:11:45.000
金属::メッシュ構造が遵守する必要がある制限があります。

00:11:45.000 -> 00:11:54.000
Metal::meshシェーダーには、次の制限があります。metal::meshは、最大256の頂点と最大512のプリミティブをサポートします。

00:11:54.000 -> 00:11:58.000
金属::メッシュの合計サイズは16キロバイトを超えることはできません。

00:11:58.000 -> 00:12:06.000
メッシュグリッドが金属::メッシュを生成したので、これらはラスタライザに供給され、最後にフラグメントシェーダーが実行されます。

00:12:06.000 -> 00:12:13.000
したがって、従来のレンダリングパイプラインと同様に、フラグメント関数はメッシュパイプライン記述子に設定されます。

00:12:13.000 -> 00:12:23.000
記述子が初期化されたので、Metalデバイスの「メッシュ記述子でパイプライン状態をレンダリングする」メソッドを使用してパイプライン状態が作成されます。

00:12:23.000 -> 00:12:29.000
メッシュパイプラインのエンコードは、従来のドローコールのエンコードと非常によく似ています。

00:12:29.000 -> 00:12:31.000
パイプラインの状態はエンコーダに設定されています。

00:12:31.000 -> 00:12:34.000
パイプラインの各段階では、リソースにバインドすることができます。

00:12:34.000 -> 00:12:46.000
この例では、バインドされたリソースは、オブジェクトステージへのオブジェクトバッファ、メッシュステージへのテクスチャ、フラグメントステージへのフラグメントバッファです。

00:12:46.000 -> 00:13:04.000
次に、メッシュパイプラインを起動するために必要ないくつかの定数を定義します。オブジェクトグリッドの寸法、オブジェクトスレッドグループごとのスレッド数、メッシュスレッドグループごとのスレッド数、およびこれらの定数を使用して、新しい「draw mesh threadgroups」メソッドを使用して描画をエンコードします。

00:13:04.000 -> 00:13:13.000
髪の平面をレンダリングするために使用されるのと同じアプローチは、メッシュパイプラインを介して手続き的に毛皮を生成するためにバニー全体に適用することができます。

00:13:13.000 -> 00:13:16.000
次に、メッシュシェーダーを使用する別の方法を見てみましょう。

00:13:16.000 -> 00:13:23.000
メッシュシェーダーは、メッシュレットカリングを使用して大量のジオメトリを効率的に処理およびレンダリングするために使用できます。

00:13:23.000 -> 00:13:33.000
このテクニックの基礎は、シーンのメッシュをメッシュレットと呼ばれる小さな部分に分割することです。

00:13:33.000 -> 00:13:39.000
シーンのジオメトリをメッシュレットに分割すると、シーンの粒度が高まり、より効率的できめ細かいカリングが可能になります。

00:13:39.000 -> 00:13:42.000
これにより、ジオメトリのオーバーヘッドを大幅に削減できます。

00:13:42.000 -> 00:13:51.000
メッシュレット粒度処理を活用することで、スクリーンスペースオクルージョンカリングや通常のフィルタリングなどの効率的なオクルージョンおよびカリングアルゴリズムが可能になります。

00:13:51.000 -> 00:13:56.000
メッシュシェーダーを使用して、完全にGPU駆動のカリングとレンダリングパイプラインを実装できます。

00:13:56.000 -> 00:14:05.000
これは、1つのコンピューティングと1つのレンダリングパスを使用してシーン処理とレンダリングを実行する従来のGPU駆動のパイプラインです。

00:14:05.000 -> 00:14:17.000
シーンデータはメッシュレットに分割され、フラスタムカリング、LOD選択、およびデバイスメモリへの描画のエンコードを担当するコンピューティングパスに供給されます。

00:14:17.000 -> 00:14:23.000
レンダリングパスは、シーンの描画コマンドを実行し、最終的な画像を生成します。

00:14:23.000 -> 00:14:33.000
メッシュシェーダーを使用すると、2つのパスを1つのメッシュシェーダーディスパッチにマージすることで、同期ポイントを削除し、中間描画コマンドを回避できます。

00:14:33.000 -> 00:14:35.000
それがどのようにできるかをお見せしましょう。

00:14:35.000 -> 00:14:39.000
これは、メッシュシェーダーディスパッチを実行する単一のレンダリングパスです。

00:14:39.000 -> 00:14:45.000
オブジェクトシェーダーは、フルスタムカルリングを実行し、目に見えるメッシュレットごとにLODを計算します。

00:14:45.000 -> 00:14:50.000
メッシュシェーダーへのペイロードは、エンコードする必要があるメッシュレットIDのリストです。

00:14:50.000 -> 00:14:55.000
次に、メッシュシェーダーは、ラスタライズされ、シェーディングされるmetal::meshオブジェクトをエンコードします。

00:14:55.000 -> 00:15:00.000
その後、最終的な画像は、従来のパイプラインと同じフラグメントシェーダーでシェーディングされます。

00:15:00.000 -> 00:15:06.000
ジオメトリ処理は、完全にメッシュスレッドグループコマンド内と単一のエンコーダ内で行われます。

00:15:06.000 -> 00:15:13.000
三角形データがメッシュシェーダーにエンコードされるため、これらの描画コマンドを保存するための中間バッファはもはや必要ありません。

00:15:13.000 -> 00:15:19.000
今、淘汰に注意を向けましょう。具体的には、メッシュレット淘汰の実装です。

00:15:19.000 -> 00:15:22.000
シーンは、ここの図形で表されるモデルで構成されています。

00:15:22.000 -> 00:15:27.000
この実装では、シーンの各モデルがオブジェクトグリッドの一部になります。

00:15:27.000 -> 00:15:35.000
オブジェクトシェーダースレッドグループによって生成されるメッシュグリッドは、モデルの表面を構成する三角形のパッチであるメッシュレットで構成されます。

00:15:35.000 -> 00:15:38.000
新しいジオメトリパイプラインは非常に柔軟です。

00:15:38.000 -> 00:15:41.000
シーンをオブジェクトグリッドにマッピングする方法を決めるのはあなた次第です。

00:15:41.000 -> 00:15:49.000
この例では、各モデルをオブジェクトスレッドグループにマッピングしていますが、タスクに適したマッピングを使用できます。

00:15:49.000 -> 00:15:58.000
これで、オブジェクトシェーダーは、表示フラスタムを使用してメッシュレットの可視性を決定し、最終的な画像に表示されるものに対してのみディスパッチ作業を行います。

00:15:58.000 -> 00:16:00.000
現場の2つのモデルに焦点を当てましょう。

00:16:00.000 -> 00:16:04.000
オブジェクトシェーダーは、決定された可視性に基づいてメッシュグリッドを起動します。

00:16:04.000 -> 00:16:09.000
次に、メッシュシェーダーはメッシュレットを処理し、metal::meshesを構築します。

00:16:09.000 -> 00:16:16.000
プログラム可能なメッシュグリッドサイズにより、柔軟なディスパッチが可能になるため、目に見えるメッシュレットのみがメッシュシェーダーによって処理されます。

00:16:16.000 -> 00:16:21.000
これにより、パイプラインの後半で目に見えないジオメトリの処理に費やす時間が短縮されます。

00:16:21.000 -> 00:16:30.000
固定機能ラスタライザは、目に見えることが知られているサーフェスのみを受け取り、目に見えないジオメトリの処理とクリッピングに費やす時間を短縮します。

00:16:30.000 -> 00:16:35.000
最後に、プログラム可能なフラグメントシェーダーが呼び出され、最終的な画像が生成されます。

00:16:35.000 -> 00:16:48.000
ご覧のとおり、このメッシュレットカリングの例に示されているように、手続き型メッシュを作成したり、ドローコールをより効率的にしたりするなど、新しいジオメトリパイプラインで対処できるさまざまな問題があります。

00:16:48.000 -> 00:16:52.000
金属には、モダンで柔軟な新しいジオメトリパイプラインが含まれています。

00:16:52.000 -> 00:16:59.000
ヘアレンダリングの例に示されているように、手続き型ジオメトリの作成がこれまで以上に簡単になりました。

00:16:59.000 -> 00:17:11.000
さらに、メッシュレットの淘汰デモに見られるように、単一のレンダリングパスでのGPU駆動作業の可能性は、追加のコンピューティングパスや中間バッファを必要とせずに拡大しました。

00:17:11.000 -> 00:17:18.000
この新しいジオメトリパイプラインは、Family7およびMac2デバイスで利用できます。

00:17:18.000 -> 00:17:27.000
メッシュシェーダーの学習と実験を開始するために、新しいAPIの使用方法を示すサンプルコードがApple開発者Webサイトで入手できます。

00:17:27.000 -> 00:17:35.000
この機能をどのように使用し、ジオメトリ処理のニーズに合わせてApple GPUの大規模な並列性を活用する方法に興奮しています。

00:17:35.000 -> 23:59:59.000
見てくれてありがとう!

