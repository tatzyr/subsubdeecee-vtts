WEBVTT

00:00:00.000 -> 00:00:03.000
♪まろやかなインストゥルメンタルヒップホップ音楽♪

00:00:03.000 -> 00:00:09.000
♪

00:00:09.000 -> 00:00:13.000
Dani Chootong: こんにちは、「アプリ内購入の新機能」へようこそ。

00:00:13.000 -> 00:00:16.000
私はダニで、StoreKitチームのエンジニアです。

00:00:16.000 -> 00:00:23.000
今日は同僚のイアンと発表し、今年のアプリ内購入にもたらす新しい改善点について紹介します。

00:00:23.000 -> 00:00:32.000
昨年、アプリ内購入を簡単に統合できるように、ゼロから設計された新しいAPIのセットであるStoreKit 2を導入しました。

00:00:32.000 -> 00:00:38.000
StoreKit 2は、async/awaitパターンを使用したSwift並行性を含む最新の言語機能を使用しています。

00:00:38.000 -> 00:00:45.000
サーバー側では、まったく新しいApp Store Serverエンドポイントセットでこれらの新しいStoreKit機能を補完しました。

00:00:45.000 -> 00:00:52.000
これらのサーバーエンドポイントを使用すると、トランザクション情報を簡単に取得し、サーバーのサブスクリプションステータスを確認できます。

00:00:52.000 -> 00:01:00.000
また、サーバー上のサブスクリプションライフサイクルの追跡をこれまで以上に簡単にするために、App Storeサーバー通知のバージョン2をリリースしました。

00:01:00.000 -> 00:01:07.000
今日は、これらの新しいAPIと、新しいStoreKitモデルにもたらす機能強化について取りに行きます。

00:01:07.000 -> 00:01:17.000
その後、イアンは、App Store Server APIの強化やApp Store Server通知用の新しいAPIなど、いくつかのエキサイティングな新しいサーバーアップデートをご案内します。

00:01:17.000 -> 00:01:23.000
まず、アプリの購入を確認するために、新しいアプリトランザクションAPIを確認します。

00:01:23.000 -> 00:01:28.000
次に、StoreKitモデルに追加した新しいプロパティを掘り下げます。

00:01:28.000 -> 00:01:37.000
サブスクリプションオファーコードを引き換え、顧客にアプリのレビューを依頼するための新しいSwiftUIフレンドリーなAPIを紹介します。

00:01:37.000 -> 00:01:44.000
次に、App Storeのメッセージを顧客に表示するために使用されるAPIであるStoreKitメッセージを紹介します。

00:01:44.000 -> 00:01:52.000
そして最後に、オリジナルから最新のStoreKit APIに移行する際に、アプリケーションのユーザー名を維持するために追加している機能強化について検討します。

00:01:52.000 -> 00:01:57.000
このプレゼンテーションを通して、私はお気に入りのアプリ、フードトラックを使います。

00:01:57.000 -> 00:02:02.000
フードトラックアプリでは、ドーナツの配達をするためにさまざまな都市を訪れるポップアップドーナツフードトラックを管理しています。

00:02:02.000 -> 00:02:05.000
では、始めましょう！

00:02:05.000 -> 00:02:06.000
アプリトランザクションに会う。

00:02:06.000 -> 00:02:12.000
アプリトランザクションは、アプリの購入を確認するための新しいAPIです。

00:02:12.000 -> 00:02:18.000
アプリトランザクションは、実行中のデバイスのアプリを購入するための署名された情報を表します。

00:02:18.000 -> 00:02:27.000
JWSを使用して署名され、元のStoreKit APIからアプリの領収書のアプリ詳細部分を置き換えます。

00:02:27.000 -> 00:02:34.000
トランザクション検証と同様に、StoreKitはアプリトランザクションの自動検証を実行します。

00:02:34.000 -> 00:02:39.000
ただし、必要に応じて、独自の検証を実行することもできます。

00:02:39.000 -> 00:02:43.000
JWS署名の検証は、十分に文書化された標準です。

00:02:43.000 -> 00:02:48.000
公開ドキュメントを参照して、独自の検証を実装できます。

00:02:48.000 -> 00:02:52.000
StoreKitは、必要に応じてアプリトランザクションを自動的に更新します。

00:02:52.000 -> 00:02:57.000
ただし、まれにユーザーが何か問題があると思われる場合は、更新することができます。

00:02:57.000 -> 00:03:03.000
顧客がアプリのトランザクションを更新できるように、アプリにUIを提供する必要があります。

00:03:03.000 -> 00:03:11.000
これは、アプリトランザクションを更新するとユーザーに認証を促すため、ユーザーのアクションに応答してのみ使用する必要があります。

00:03:11.000 -> 00:03:15.000
詐欺を防ぐことは、アプリトランザクションを愛する唯一の理由ではありません。

00:03:15.000 -> 00:03:31.000
ビジネスモデルを有料アプリからアプリ内購入を提供する無料アプリに切り替えたい場合、どの顧客がアプリを予約注文したかに興味がある場合、またはアプリがいつ購入されたかを知りたい場合でも、これらはすべてアプリトランザクションで処理できる状況です。

00:03:31.000 -> 00:03:39.000
アプリの領収書では、領収書のペイロードは、アプリケーションに関する購入データと、発生したすべてのアプリ内購入を組み合わせます。

00:03:39.000 -> 00:03:43.000
これらは現在、StoreKitで2つの別々のコンポーネントに分割されています。

00:03:43.000 -> 00:03:46.000
1つ目は取引履歴です。

00:03:46.000 -> 00:03:52.000
StoreKitのトランザクションAPIは、デバイス上で、ユーザーのアプリ内購入履歴全体についての洞察を提供します。

00:03:52.000 -> 00:04:02.000
これらのAPIを使用すると、ユーザーの最新のトランザクション、未完了のトランザクション、現在の資格など、必要な正確な情報を見つけることができます。

00:04:02.000 -> 00:04:09.000
サーバーでこれらの計算を実行したい場合は、App Store Server APIからユーザーの購入履歴を取得することもできます。

00:04:09.000 -> 00:04:13.000
イアンは、このセッションの後半にいくつかのエキサイティングなアップデートを行います。

00:04:13.000 -> 00:04:20.000
そして、2番目のコンポーネントはアプリトランザクションで、アプリが実行中のデバイスに対して有効であることを確認するために必要なデータが含まれています。

00:04:20.000 -> 00:04:28.000
アプリトランザクションを使用してアプリの購入を確認するのは簡単で、すぐに、それを使用する方法の例について説明します。 では、その使用方法について説明します。

00:04:28.000 -> 00:04:32.000
しかし、まず、私のお気に入りのアプリについての背景をいくつかお伝えします。

00:04:32.000 -> 00:04:39.000
フードトラックでは、ドーナツの配達を行い、基本的なソーシャルフィードをチェックし、販売履歴を視覚化することができます。

00:04:39.000 -> 00:04:49.000
これらすべての情報をデータベースに保存することは、私のアプリの継続的なコストなので、コストをカバーするために、年間販売履歴チャートを1回限りの購入に変えるつもりです。

00:04:49.000 -> 00:04:52.000
さらに、ソーシャルフィードを強化したいです。

00:04:52.000 -> 00:04:59.000
だから、他の人が私のフードトラックについて何を言っているかを見るのではなく、私も顧客と関わることができるようにツールを提供したいです。

00:04:59.000 -> 00:05:04.000
これはサブスクリプションサービスになり、私は月間プランと年間プランを持っています。

00:05:04.000 -> 00:05:10.000
フードトラックは有料アプリとして始まりましたが、アプリ内購入を提供する無料アプリに切り替えるつもりです。

00:05:10.000 -> 00:05:15.000
しかし、すでにフードトラックを購入した既存の顧客に取り残されたと感じてほしくない。

00:05:15.000 -> 00:05:24.000
したがって、私はアプリトランザクションを使用して、フードトラックを購入した顧客が支払ったプレミアムコンテンツに引き続きアクセスできるようにします。

00:05:24.000 -> 00:05:26.000
これがフードトラックのタイムラインです。

00:05:26.000 -> 00:05:31.000
最初のリリースでは、フードトラックは4.99ドルの有料アプリとして始まりました。

00:05:31.000 -> 00:05:37.000
バージョン1.0は、ドーナツの配達、基本的なソーシャルフィード、販売履歴チャートを提供しました。

00:05:37.000 -> 00:05:42.000
その後、バージョン8.0のリリースで、私のビジネスモデルが変わりました。

00:05:42.000 -> 00:05:47.000
フードトラックは現在無料ですが、プレミアム機能のロックを解除するさまざまなアプリ内購入が含まれています。

00:05:47.000 -> 00:05:58.000
年間販売履歴チャートは現在、非消費の1回限りの購入であり、高度なエンゲージメントツールを提供するプレミアムソーシャルフィードの新しいサブスクリプションサービスがあります。

00:05:58.000 -> 00:06:03.000
それでは、この影響を受ける可能性のある2種類の顧客を見てみましょう。

00:06:03.000 -> 00:06:11.000
アリスはバージョン2.5で私のフードトラックアプリについて知り、デジタル世界でドーナツへの情熱を共有したいと決めました。

00:06:11.000 -> 00:06:16.000
それで、彼女は私のアプリを4.99ドルで購入し、ドーナツの配達の旅を始めました。

00:06:16.000 -> 00:06:23.000
2番目の顧客、ボブは、友人を通して私のフードトラックアプリについて知り、バージョン8.2のApp Storeで無料でダウンロードします。

00:06:23.000 -> 00:06:33.000
このシナリオでは、無料になる前に私のアプリを購入したアリスは、すでに支払ったすべてのプレミアムコンテンツにアクセスできるはずです。

00:06:33.000 -> 00:06:42.000
彼女はまだプレミアムソーシャルフィードサブスクリプションを購入するオプションを持っていますが、最初に含まれていた年間販売履歴チャートを否定したくありません。

00:06:42.000 -> 00:06:44.000
しかし、ボブは私のアプリを無料で手に入れました。

00:06:44.000 -> 00:06:49.000
私は、彼らがアプリ内購入を完了するまで、機能やコンテンツのロックを解除しないことを知っています。

00:06:49.000 -> 00:06:53.000
では、コード内のアプリトランザクションでこれを達成する方法を見てみましょう。

00:06:53.000 -> 00:06:59.000
まず、AppTransaction.sharedを呼び出してアプリトランザクションを取得します。

00:06:59.000 -> 00:07:03.000
この呼び出しは、私のアプリトランザクションを含むVerificationResultを取得します。

00:07:03.000 -> 00:07:09.000
結果の中で、AppTransactionタイプにはJWSペイロードが含まれています。

00:07:09.000 -> 00:07:11.000
次に、結果をオンにします。

00:07:11.000 -> 00:07:22.000
結果が未確認の場合、これはアプリの購入がApp Storeで確認できないことをユーザーに警告する良い機会であり、その後、アプリのトランザクションを更新するように促すことができます。

00:07:22.000 -> 00:07:26.000
現時点では、私のアプリに最小限の体験を提供します。

00:07:26.000 -> 00:07:31.000
結果が確認されたら、これをユーザーが私のアプリを購入したかどうかを確認する機会として使うつもりです。

00:07:31.000 -> 00:07:36.000
私のアプリを購入したお客様には、有料のサービスが付与されるべきです。

00:07:36.000 -> 00:07:39.000
これには、元のアプリバージョンのプロパティを使用します。

00:07:39.000 -> 00:07:46.000
このプロパティは、顧客が私のアプリを初めてダウンロードしたアプリのバージョンを知らせてくれます。

00:07:46.000 -> 00:07:51.000
バージョン8.0は、私のアプリがアプリ内購入で無料になったバージョンです。

00:07:51.000 -> 00:07:58.000
ユーザーの元のアプリバージョンを私の機能に渡して、ユーザーがバージョン8.0より前にアプリを購入したかどうかを確認します。

00:07:58.000 -> 00:08:05.000
そして、それにより、ユーザーにプレミアムコンテンツをどのように提供すべきかについて、情報に基づいた決定を下すことができます。

00:08:05.000 -> 00:08:13.000
私のアプリを購入したアリスのような顧客のために、私はユーザーが購入時に持っていた権利があるコンテンツを提供するつもりです。

00:08:13.000 -> 00:08:18.000
私の場合、私は彼女の配達の年間販売履歴チャートのロックを解除するつもりです。

00:08:18.000 -> 00:08:25.000
また、彼らが行った可能性のある追加のアプリ内購入を確認したいので、それも提供できます。

00:08:25.000 -> 00:08:31.000
そうでなければ、ボブのようにビジネスモデルを切り替えた後、ユーザーが私のアプリをダウンロードしたと確信できます。

00:08:31.000 -> 00:08:37.000
これは、ユーザーが支払った機能やコンテンツのロックを解除できるように、ユーザーの現在の資格を確認する良い機会です。

00:08:37.000 -> 00:08:52.000
そして、ほんの数行のコードで、私のアプリの購入を確認し、ユーザーが私のアプリの有料版をダウンロードしたかどうかを確認し、顧客が私のアプリを購入したかどうかにかかわらず、すぐにプレミアムコンテンツの提供を開始することができます。

00:08:52.000 -> 00:08:59.000
App Transactionを使用すると、早期のサポーターでも、最近アプリをダウンロードしたばかりの場合でも、顧客を簡単にサポートできます。

00:08:59.000 -> 00:09:04.000
では、StoreKitモデルに追加する新しいプロパティに移りたいと思います。

00:09:04.000 -> 00:09:07.000
これらのプロパティの最初のものは、価格ロケールです。

00:09:07.000 -> 00:09:10.000
価格ロケールは現在、StoreKit製品に含まれています。

00:09:10.000 -> 00:09:16.000
オリジナルの購入APIとのインターフェースから、すでに価格ロケールに精通しているかもしれません。

00:09:16.000 -> 00:09:19.000
次に、サーバー環境のプロパティを掘り下げます。

00:09:19.000 -> 00:09:25.000
これで、トランザクションまたは更新情報が発生したことをサーバー環境に伝えることができます。

00:09:25.000 -> 00:09:28.000
次に、最近のサブスクリプション開始日のプロパティに移動します。

00:09:28.000 -> 00:09:35.000
これをツールとして使用して、サブスクリプションパターンに基づいて顧客のために情報に基づいた決定を下すことができます。

00:09:35.000 -> 00:09:41.000
そして最後に、XcodeのStoreKitテストで使用する際に、これらのプロパティに関するいくつかの特別な考慮事項について説明します。

00:09:41.000 -> 00:09:48.000
これらのプロパティは、古いオペレーティングシステムでセンチネル値を返し、これが何を意味するのかを少し説明します。

00:09:48.000 -> 00:10:01.000
StoreKit APIは柔軟性を念頭に置いて設計されているため、当初は出荷されていなかったにもかかわらず、昨年のオペレーティングシステムにさかのぼるデバイスでこれらの新しいプロパティを利用できることを発表できることを誇りに思います。

00:10:01.000 -> 00:10:10.000
これを実現するために必要なのは、Xcode 14を使用してアプリを構築することだけで、以前のオペレーティングシステムでこれらのプロパティにアクセスできます。

00:10:10.000 -> 00:10:21.000
これは、これらのプロパティの実装がアプリにコンパイルされるため、顧客が新しいバージョンに更新すると、オペレーティングシステムを更新せずにこれらの機能強化の恩恵を受けることができます。

00:10:21.000 -> 00:10:26.000
ただし、これらのプロパティを使用する際に留意すべき点が1つあります。

00:10:26.000 -> 00:10:32.000
これらの古いオペレーティングシステムでXcodeでStoreKitテストを使用している場合、これらのプロパティはセンチネル値を返します。

00:10:32.000 -> 00:10:41.000
私がセンチネル値と言うとき、私はこれらがあなたが作業すべき実際の値ではないことを示すプレースホルダ値を指しています、そして私はこれが起こる理由を説明します。

00:10:41.000 -> 00:10:48.000
サンドボックスと本番環境は、App Storeサーバーの応答から値を抽出することで、これらのプロパティを利用します。

00:10:48.000 -> 00:10:54.000
ただし、XcodeでのStoreKitテストは、App Storeサーバーとは独立して動作するローカルテスト環境です。

00:10:54.000 -> 00:11:00.000
これは、これらのプロパティの値を以前のオペレーティングシステムにバックポートできないことを意味します。

00:11:00.000 -> 00:11:08.000
テストデバイスを新しいオペレーティングシステムに更新することで、この制限を簡単に回避でき、ローカル環境でこれらの値をテストできます。

00:11:08.000 -> 00:11:15.000
これらの新しいプロパティの使用を開始する方法を示すいくつかの状況について話し合いましょう。最初は価格ロケールです。

00:11:15.000 -> 00:11:25.000
StoreKit製品にはすでに購入価格にラベルを付ける表示価格プロパティがありますが、価格ロケールを使用すると、製品の10進価格から派生した数字をフォーマットできます。

00:11:25.000 -> 00:11:32.000
年間サブスクリプションをお持ちの場合は、これを顧客に月額の費用を示す機会として使用するかもしれません。

00:11:32.000 -> 00:11:38.000
この例では、年間サブスクリプションの金額が月額4.17ドルであることがわかります。

00:11:38.000 -> 00:11:44.000
または、彼らがあなたの毎月のサービスよりもあなたの年間サービスを購入した場合、彼らがどれだけ節約できるかを彼らに示したいと思うかもしれません。

00:11:44.000 -> 00:11:51.000
この情報により、顧客は購入オプションを検討する際に、情報に基づいた決定を下すことができます。

00:11:51.000 -> 00:11:54.000
では、環境プロパティに移りましょう。

00:11:54.000 -> 00:11:57.000
環境プロパティは、トランザクションと更新情報で利用できます。

00:11:57.000 -> 00:12:06.000
このプロパティは、トランザクションまたは更新情報が発信されたサーバー環境を示します。これは、Xcode、サンドボックス、または本番環境です。

00:12:06.000 -> 00:12:13.000
顧客が簿記と分析のために購入した後、アプリは取引情報をサーバーに伝達することがあります。

00:12:13.000 -> 00:12:18.000
アプリがこれらのトランザクションを生成するとき、それはこれらのサーバー環境のいずれかからである可能性があります。

00:12:18.000 -> 00:12:22.000
ほとんどの人と同じように、私は無関係なテストデータで私の分析にノイズを追加したくありません。

00:12:22.000 -> 00:12:29.000
したがって、環境を知ることは、不要な情報がサーバーに送信されるのをフィルタリングするのに役立ちます。

00:12:29.000 -> 00:12:32.000
最後に、最近のサブスクリプション開始日を見てみましょう。

00:12:32.000 -> 00:12:41.000
最近のサブスクリプション開始日は、製品のサブスクリプション情報内で利用でき、継続的なサブスクリプションの最新の期間を表します。

00:12:41.000 -> 00:12:48.000
任意の2つの購読期間の間に60日以上のギャップがない場合、サブスクリプションは継続的と見なされます。

00:12:48.000 -> 00:12:59.000
この期間には、顧客が製品を購読していないギャップが含まれている可能性があるので、これを顧客が購読した日数の指標として使用しないでください。

00:12:59.000 -> 00:13:05.000
最近のサブスクリプション開始日は、あなたとあなたの顧客との間の忠誠心のパターンを決定するのに役立ちます。

00:13:05.000 -> 00:13:10.000
あなたの忠実な顧客のために、あなたは彼らがあなたの製品に従事し続ける方法として彼らに報酬を提供するかもしれません。

00:13:10.000 -> 00:13:21.000
または、顧客がサービスの購読を解除したことに気付いた場合は、製品の使用を再開するインセンティブを提供することで、失効した顧客を取り戻すチャンスとして使用できます。

00:13:21.000 -> 00:13:26.000
先ほど、これらのプロパティのセンチネル値を詳しく調べると述べました。

00:13:26.000 -> 00:13:34.000
リマインダーとして、私がセンチネル値と言うとき、私は実際の値の欠如の指標として機能するプレースホルダ値を指しています。

00:13:34.000 -> 00:13:38.000
これらのプロパティのセンチネル値は簡単に識別できます。

00:13:38.000 -> 00:13:45.000
価格ロケールを扱う場合、センチネル値は識別子xx_XXのロケールです。

00:13:45.000 -> 00:13:49.000
環境プロパティの場合、空の文字列になります。

00:13:49.000 -> 00:13:54.000
そして最後に、最近のサブスクリプション開始日の場合、この値はDate.distantPastです。

00:13:54.000 -> 00:14:05.000
幸いなことに、これらのセンチネル値の発生は予測可能です - 古いオペレーティングシステムでXcodeでStoreKitテストを使用している場合にのみそれらに遭遇し、テストデバイスを更新することでこれを回避できます。

00:14:05.000 -> 00:14:09.000
これで、StoreKitモデルの機能強化がわかりました。

00:14:09.000 -> 00:14:19.000
そして、私のお気に入りの部分は、モデルが導入されたオペレーティングシステムまでずっと下位互換性があるので、顧客はアプリを更新するだけですぐに利点を見ることができます。

00:14:19.000 -> 00:14:26.000
価格値で算術を実行すると、価格ロケールはApp Storeのロケールと一致するように正しくフォーマットするのに役立ちます。

00:14:26.000 -> 00:14:37.000
トランザクションとサブスクリプション情報の場合、環境はそれらがどこから来たのかを正確に教えてくれるので、このデータをサーバーに保存すると、環境に応じてそれに応じて行動することができます。

00:14:37.000 -> 00:14:49.000
最近のサブスクリプション開始日は、顧客のロイヤルティを理解するのに役立つため、長年の顧客に特定のオファーを調整したり、購読を解除した顧客にインセンティブを提供することもできます。

00:14:49.000 -> 00:15:01.000
そして、あなたが疑問に思っていた場合に備えて、はい、環境と最近のサブスクリプション開始日は、イアンが議論するApp Store Server APIとApp Store Server Notificationsを介しても利用できます。

00:15:01.000 -> 00:15:08.000
さて、オファーコードの引き換えとレビューのリクエストのために提供している新しいSwiftUI APIについて話したいと思います。

00:15:08.000 -> 00:15:16.000
オファーコードは、期間限定でサブスクリプションを割引または無料で提供することで、加入者の獲得、維持、獲得に役立ちます。

00:15:16.000 -> 00:15:20.000
App Store Connectでは、一意の名前のカスタムコードを作成できます。

00:15:20.000 -> 00:15:26.000
そこでは、最大償還限度額を設定し、有効期限を設定するかどうかを選択できます。

00:15:26.000 -> 00:15:32.000
SwiftUIの実装を見て、アプリから直接オファーコードの引き換えシートを提示しましょう。

00:15:32.000 -> 00:15:36.000
ここでは、オファーコード引き換えシートをトリガーするボタン付きのSwiftUIビューがあります。

00:15:36.000 -> 00:15:42.000
オファーコード償還シートには、SwiftUIで独自のビュー修飾子が追加されました。

00:15:42.000 -> 00:15:47.000
ビュー修飾子は使いやすく、プロセスを開始するにはバインディングブール値が必要です。

00:15:47.000 -> 00:15:54.000
そして、オファーコードシートが却下されると、シートが正常に提示されたかどうかを表す結果が得られます。

00:15:54.000 -> 00:16:02.000
顧客がアプリのオファーコードを引き換えると、結果のトランザクションがトランザクションリスナーに送信されます。

00:16:02.000 -> 00:16:09.000
したがって、アプリの実行中に新規および更新されたトランザクションを受信するために、アプリが起動したらすぐにトランザクションリスナーを設定してください。

00:16:09.000 -> 00:16:14.000
オファーコードビュー修飾子は、iOS 16から利用できます。

00:16:14.000 -> 00:16:18.000
次に、レビューをリクエストするための更新について話したいと思います。

00:16:18.000 -> 00:16:21.000
顧客からのフィードバックを得ることは重要です。

00:16:21.000 -> 00:16:27.000
潜在的な新規顧客は、アプリをダウンロードする決定の決定要因としてレビューを使用するかもしれません。

00:16:27.000 -> 00:16:32.000
他の人は、フィードバックや提案を提供する方法としてレビューを残したいと思うかもしれません。

00:16:32.000 -> 00:16:41.000
いずれにせよ、顧客に簡単に評価をリクエストできるツールを提供したいので、あなたが聞いていることを彼らに知らせ、彼らと関わり続けることができます。

00:16:41.000 -> 00:16:44.000
コードを見直しましょう。

00:16:44.000 -> 00:16:48.000
ここでは、リクエストレビューAPIを実証するための非常に簡単なビューがあります。

00:16:48.000 -> 00:16:52.000
SwiftUIには、requestReviewという環境値が追加されました。

00:16:52.000 -> 00:17:03.000
この値を使用してRequestReviewActionのインスタンスを取得し、評価を要求する準備ができたら、レビュープロンプトを表示するように要求する関数としてインスタンスを呼び出すだけです。

00:17:03.000 -> 00:17:06.000
アプリのレビューをリクエストする適切な時期を決めることができます。

00:17:06.000 -> 00:17:14.000
ただし、プロンプトは365日以内に最大3回しか顧客に表示されないことに注意してください。

00:17:14.000 -> 00:17:19.000
また、同じバージョンのアプリを複数回レビューするよう顧客に依頼すべきではありません。

00:17:19.000 -> 00:17:22.000
レビュープロンプトで顧客の邪魔をしないでください。

00:17:22.000 -> 00:17:31.000
レビューを求めるのに良い時期は、eコマースアプリでの購入を完了したり、ゲームのレベルを完了したりするなど、ポジティブなやり取りをした後かもしれません。

00:17:31.000 -> 00:17:39.000
最後に、顧客はデバイスに表示されるリクエストを無効にできるため、ユーザーのアクションの結果としてレビューをリクエストすべきではありません。

00:17:39.000 -> 00:17:43.000
これらのAPIは、SwiftUIアプリに本当に役に立ちます。

00:17:43.000 -> 00:17:48.000
次に、StoreKitメッセージ用の新しいAPIをご紹介します。

00:17:48.000 -> 00:17:54.000
StoreKitメッセージは、重要な情報をユーザーに表示するためにアプリ上に表示されるシートを表します。

00:17:54.000 -> 00:17:57.000
メッセージはApp Storeによって販売されます。

00:17:57.000 -> 00:18:01.000
各メッセージには理由があり、メッセージのメタデータに含まれています。

00:18:01.000 -> 00:18:05.000
アプリがフォアグラウンドになると、StoreKitメッセージが取得されます。

00:18:05.000 -> 00:18:10.000
例として、メッセージの理由の1つである値上げの同意を見てみましょう。

00:18:10.000 -> 00:18:21.000
サブスクリプションの価格を引き上げ、ユーザーの同意が必要な場合、App Storeは電子メール、プッシュ通知、およびアプリ内価格同意シートを通じて影響を受ける購読者に通知します。

00:18:21.000 -> 00:18:28.000
この場合、App Storeでは、より高い価格で更新する前に、ユーザーがサブスクリプションの新しい価格に同意する必要があります。

00:18:28.000 -> 00:18:38.000
したがって、サブスクリプションに対してさらに料金を請求することにした場合、ユーザーがアプリを開くと、値上げにまだ応答していない場合、値上げ同意書が表示される場合があります。

00:18:38.000 -> 00:18:46.000
デフォルトでは、ユーザーがアプリをフォアグラウンドに持ち込むと、StoreKitメッセージがアプリ上に表示され、アプリに関連する何らかのアクションを実行するようユーザーに要求する場合があります。

00:18:46.000 -> 00:18:48.000
これを見直しましょう。

00:18:48.000 -> 00:18:51.000
プロセス全体はアプリから始まります。

00:18:51.000 -> 00:18:56.000
アプリがフォアグラウンドに入ると、StoreKitは表示する保留中のメッセージがあるかどうかを確認することを知っています。

00:18:56.000 -> 00:19:00.000
そして、もしあれば、StoreKitはApp Storeにチェックインします。

00:19:00.000 -> 00:19:03.000
App Storeは、メッセージに関する情報をStoreKitに返します。

00:19:03.000 -> 00:19:07.000
現時点では、StoreKitはアプリがメッセージを受信するように設定されているかどうかを確認します。

00:19:07.000 -> 00:19:12.000
アプリでメッセージリスナーを設定することでこれを行うことができます。すぐに取り込みます。

00:19:12.000 -> 00:19:17.000
アプリがメッセージリスナーを設定している場合、StoreKitはメッセージに関する情報をアプリに送信します。

00:19:17.000 -> 00:19:25.000
今、アプリがメッセージを表示するのに良い時期かどうか、またはプレゼンテーションを後で延期するかどうかを決定するチャンスです。

00:19:25.000 -> 00:19:32.000
メッセージリスナーを設定しない場合、StoreKitはアプリ上にメッセージシートを表示することで、すぐにメッセージを表示します。

00:19:32.000 -> 00:19:34.000
コードでこれを行う方法について説明します。

00:19:34.000 -> 00:19:41.000
しかし、その前に、App Storeメッセージの表示を制御するのに役立つ状況を説明します。 メッセージの表示を制御するのに役立つ状況を説明します。

00:19:41.000 -> 00:19:45.000
フードトラックアプリでは、さまざまな都市に配達するドーナツをカスタマイズできます。

00:19:45.000 -> 00:19:59.000
この間にメッセージが私のアプリに配信された場合、メッセージシートによって突然中断された場合、ユーザーは混乱を招くので、受信メッセージがいつ表示されるかを制御することによって、これが起こらないようにメッセージAPIを実装するつもりです。

00:19:59.000 -> 00:20:01.000
では、コードに入りましょう。

00:20:01.000 -> 00:20:04.000
ここでは、ドーナツエディタの簡単なビューがあります。

00:20:04.000 -> 00:20:09.000
先に述べたように、アプリがフォアグラウンドに来るたびに保留中のメッセージが送信されます。

00:20:09.000 -> 00:20:15.000
だから、メッセージの提示を延期したい各ビューでメッセージリスナーを設定したい。

00:20:15.000 -> 00:20:20.000
編集ビューにいる間にアプリに配信されるすべてのメッセージを収集するためのバインディング配列を追加します。

00:20:20.000 -> 00:20:28.000
メッセージリスナーを設定しないと、アプリがフォアグラウンドになると、StoreKitがすぐにメッセージシートを表示するので、これは重要です。

00:20:28.000 -> 00:20:32.000
ビューが表示されたらすぐに、メッセージリスナーを設定しました。

00:20:32.000 -> 00:20:37.000
これを行うには、メッセージタイプの静的プロパティを反復するタスクを設定します。

00:20:37.000 -> 00:20:42.000
このプロパティは非同期シーケンスであり、メッセージが入ってくると受信できます。

00:20:42.000 -> 00:20:46.000
私のユースケースでは、pendingMessages配列にメッセージを保存します。

00:20:46.000 -> 00:20:56.000
保留中のメッセージは、アプリがフォアグラウンドに入るたびに配信されるため、アプリは同じメッセージを複数回受信する可能性があるため、配列に重複したメッセージを追加しないようにします。

00:20:56.000 -> 00:21:01.000
次に、ビューが閉じたら、親ビューにメッセージを表示します。

00:21:01.000 -> 00:21:05.000
これは、ドーナツエディタへのナビゲーションリンクを保持する親ビューです。

00:21:05.000 -> 00:21:10.000
ここでは、このpendingMessages配列に表示する必要があるすべての保留中のメッセージを収集しました。

00:21:10.000 -> 00:21:13.000
では、これらの保留中のメッセージを表示するにはどうすればよいですか?

00:21:13.000 -> 00:21:17.000
さて、今、環境値displayStoreKitMessageがあります。

00:21:17.000 -> 00:21:23.000
これにより、DisplayMessageActionのインスタンスを取得し、特定のメッセージを表示するために使用できます。

00:21:23.000 -> 00:21:30.000
ビューが表示されたら、保留中のメッセージを反復し、表示したいメッセージを渡すdisplayStoreKitMessageを呼び出します。

00:21:30.000 -> 00:21:34.000
StoreKitはメッセージシートの提示を担当します。

00:21:34.000 -> 00:21:38.000
先ほど、同じメッセージがアプリに複数回配信される可能性があると述べました。

00:21:38.000 -> 00:21:42.000
これは、メッセージがユーザーに提示されるまで既読としてマークされないためです。

00:21:42.000 -> 00:21:48.000
したがって、StoreKitは、各固有のメッセージが1回しか表示されないようにします。

00:21:48.000 -> 00:21:52.000
そして、それはメッセージAPIの迅速な実装でした。

00:21:52.000 -> 00:22:04.000
StoreKitメッセージはフォアグラウンドに来るたびにアプリに送信されるので、メッセージが表示されるタイミングを制御する各ビューでメッセージリスナーを設定する必要があります。

00:22:04.000 -> 00:22:10.000
メッセージシートが予期しない瞬間に表示されないようにすることで、顧客が素晴らしい体験を得られるようにします。

00:22:10.000 -> 00:22:14.000
または、特定のメッセージタイプに合わせてロジックを調整したいかもしれません。

00:22:14.000 -> 00:22:23.000
値上げ同意メッセージを使用すると、値上げ同意シートが表示される前に、提供している付加価値について顧客を教育したいと思うかもしれません。

00:22:23.000 -> 00:22:31.000
最後に、ユーザーが購入した後、StoreKitがapplicationUsernameをappAccountTokenとして保存する方法を確認しましょう。

00:22:31.000 -> 00:22:38.000
サーバーにユーザーアカウントシステムがある場合は、すでにapplicationUsernameプロパティを使用している可能性があります。

00:22:38.000 -> 00:22:45.000
applicationUsernameは、トランザクションをサービスのユーザーアカウントに関連付けるために作成する文字列です。

00:22:45.000 -> 00:22:53.000
アプリ内購入の元のAPIでは、支払いキューに支払いを追加するときにapplicationUsername値を設定します。

00:22:53.000 -> 00:23:01.000
applicationUsernameは任意の文字列を受け入れますが、UUIDの文字列表現を提供することをお勧めします。

00:23:01.000 -> 00:23:08.000
UUID文字列を指定すると、StoreKitは値を保持し、キューが更新するトランザクションにそれが表示されます。

00:23:08.000 -> 00:23:13.000
applicationUsernameにUUID文字列を提供しない場合、StoreKitはそれを保持しない可能性があります。

00:23:13.000 -> 00:23:21.000
支払いトランザクションをキューに追加してからキューがトランザクションを更新するまで、値が持続する保証はありません。

00:23:21.000 -> 00:23:30.000
UUIDの文字列表現を提供すると、どのアプリのユーザーアカウントがトランザクションを開始および完了したかを識別できます。

00:23:30.000 -> 00:23:39.000
現代のStoreKit APIでは、この概念をappAccountTokenと呼ばれる購入オプションとして実装しており、UUID形式が必要です。

00:23:39.000 -> 00:23:47.000
これで、支払い時にapplicationUsernameをUUID文字列に設定すると、App StoreサーバーはそれをappAccountTokenとして保存します。

00:23:47.000 -> 00:23:57.000
したがって、そのUUIDは、App Store Server APIによって返された署名されたトランザクション情報とV2 App Store Server Notificationsに表示されます。

00:23:57.000 -> 00:24:03.000
また、UUIDとして、最新のStoreKitトランザクションAPIのappAccountTokenと互換性があります。

00:24:03.000 -> 00:24:15.000
したがって、コードベースを最新のStoreKit APIに更新すると、アプリケーションユーザー名に使用したUUIDがStoreKitトランザクションでappAccountTokenとして保持されることを確認できます。

00:24:15.000 -> 00:24:18.000
今日はたくさんのことに触れました。

00:24:18.000 -> 00:24:24.000
サーバーのアップデートに進む前に、今年のStoreKitのアップデートを確認しましょう。

00:24:24.000 -> 00:24:35.000
App Transactionでアプリの購入を検証し、オファーコードを引き換え、SwiftUIでレビューを要求し、StoreKitメッセージの表示を制御することについて話し合いました。

00:24:35.000 -> 00:24:41.000
新しい価格ロケール、環境、最近のサブスクリプション開始日のプロパティについて話しました。

00:24:41.000 -> 00:24:50.000
そして、アプリケーションユーザー名にUUIDの文字列表現を使用して、アプリアカウントトークンとして永続化することの重要性について説明しました。

00:24:50.000 -> 00:24:56.000
他のセッション「StoreKitテストの新機能」をチェックすることを強くお勧めします。

00:24:56.000 -> 00:25:01.000
また、StoreKit 2 APIの復習が必要な場合は、昨年のセッション「Meet StoreKit 2」をチェックしてください。

00:25:01.000 -> 00:25:06.000
今、私はそれをイアンに渡して、App Storeサーバーのアップデートを案内したいと思います。

00:25:06.000 -> 00:25:07.000
イアン・ザンガー:ありがとう、ダニ。

00:25:07.000 -> 00:25:12.000
みなさん、こんにちは。私の名前はイアンで、App Store Serverチームのエンジニアです。

00:25:12.000 -> 00:25:19.000
StoreKitでのアプリ内購入に関する最新情報を聞いたので、ギアを切り替えてサーバーについて話します。

00:25:19.000 -> 00:25:32.000
まず、App Store Server APIとApp Store Server Notifications Version 2に登場するエキサイティングな新しいアップデートに進む前に、過去1年間の最近の開発を確認します。

00:25:32.000 -> 00:25:34.000
始めましょう。

00:25:34.000 -> 00:25:36.000
去年は大きかった。

00:25:36.000 -> 00:25:48.000
これらすべての新機能の完全なサンドボックステストサポートを含む、App Store Server APIとApp Store Server Notifications V2を備えたまったく新しいエンドポイントスイートをご用意しました。

00:25:48.000 -> 00:26:03.000
「トランザクション履歴を取得」エンドポイントを使用して、ユーザーのアプリ内購入の完全な履歴を取得する方法、または「すべてのサブスクリプションステータスを取得」エンドポイントを使用して、ユーザーのサブスクリプションの現在の状態を最新の状態に保つ方法を共有しました。

00:26:03.000 -> 00:26:14.000
これらのエンドポイントは両方とも、ユーザーの元のTransactionIdから便利にキーオフするので、この1つの単純な値だけを格納することで、このデータの宝庫にアクセスできます。

00:26:14.000 -> 00:26:25.000
また、App Store Server Notificationsのバージョン2がサーバー上のイベント処理を簡素化し、App Store Server APIを補完する方法についても説明しました。

00:26:25.000 -> 00:26:33.000
V2通知を使用すると、App Storeサーバーはサーバーに直接電話をかけ、アプリ内購入の更新を提供します。

00:26:33.000 -> 00:26:40.000
合理化された通知タイプとサブタイプにより、何が起こっているのかを簡単に理解できます。

00:26:40.000 -> 00:26:45.000
これらを使用して、アプリ内サブスクリプションやその他のイベントに関連する変更を追跡できます。

00:26:45.000 -> 00:26:51.000
これらすべてのデータソースで、私たちはそのデータをできるだけ簡単に解析できるようにしたかった。

00:26:51.000 -> 00:27:04.000
これらの新しいサービスは、署名されたJSON形式でアプリ内データを提供するため、簡単に解析し、App Storeサーバーから来たことを信頼できるため、領収書は過去のものになりました。

00:27:04.000 -> 00:27:07.000
昨年はApp Storeサーバーにとって大きな年でした。

00:27:07.000 -> 00:27:15.000
これらすべての新機能を活用するためにサーバーコードの更新に取り組んだ場合、それはあなたにとっても大きかったかもしれません。

00:27:15.000 -> 00:27:27.000
App Store Server APIとApp Store Server Notifications V2に強力な新しい機能強化と機能をもたらすため、努力は引き続き報われますのでご安心ください。

00:27:27.000 -> 00:27:45.000
それは私たちのレビューの年ですが、今年のアップデートを聞いた後、より多くの復習をご希望の場合は、「サーバーでアプリ内購入を管理する」、「StoreKit 2に会う」、「顧客をサポートし、払い戻しを処理する」というタイトルのWWDC21セッションを必ずチェックしてください。

00:27:45.000 -> 00:27:53.000
それでは、WWDC22のApp Storeサーバーに登場するまったく新しいアップデートに移りましょう。

00:27:53.000 -> 00:27:58.000
まず、トランザクションと更新情報フィールドの更新を共有します。

00:27:58.000 -> 00:28:03.000
次に、App Store Server APIの新しい機能強化について説明します。

00:28:03.000 -> 00:28:11.000
そして最後に、App Store Server Notifications V2に登場するエキサイティングな新機能を紹介します。

00:28:11.000 -> 00:28:18.000
それでは、新しいトピックの最初のトピックに飛び込みましょう。トランザクションと更新情報で見つかった新しいフィールドです。

00:28:18.000 -> 00:28:26.000
以前、アプリ内購入の取引と更新情報にいくつかの新しいフィールドについてDaniから聞きました。

00:28:26.000 -> 00:28:40.000
これらのフィールド、環境、および最近のSubscriptionStartDateは、App Store Server APIおよびV2 App Store Server通知から受け取るトランザクションおよび更新情報のペイロードにも届きます。

00:28:40.000 -> 00:28:48.000
これらの新しいフィールドを含めて、App Storeサーバーから受け取ることが期待できるデータをもう一度見てみましょう。

00:28:48.000 -> 00:28:53.000
まず、デコード後にここで見ることができるトランザクション情報ペイロードです。

00:28:53.000 -> 00:28:57.000
一番下には、私たちの新しい分野「環境」が見えます。

00:28:57.000 -> 00:29:04.000
トランザクションが本番環境で行われたかサンドボックス環境で行われたかを一目で確認できます。

00:29:04.000 -> 00:29:10.000
次は更新情報ペイロードで、デコード後にここでも見られます。

00:29:10.000 -> 00:29:15.000
ご覧のとおり、環境フィールドもここで参照できます。

00:29:15.000 -> 00:29:21.000
さらに、最近のSubscriptionStartDateは、すべての更新情報ペイロードに表示されるようになりました。

00:29:21.000 -> 00:29:32.000
これは、60日以下のギャップを無視して、最新の更新での最初のサブスクリプション購入の開始日です。

00:29:32.000 -> 00:29:38.000
recentSubscriptionStartDateは、顧客のロイヤルティを一目で把握する簡単な方法です。

00:29:38.000 -> 00:29:51.000
ただし、サービスのギャップのタイミングや長さなど、詳細をご希望の場合は、Get Transaction Historyエンドポイントに電話して、ユーザーのサブスクリプション更新購入の完全な履歴を調べることができます。

00:29:51.000 -> 00:30:03.000
または、さらに詳細については、App Store Server Notifications V2では、App Storeサーバーはユーザーのサブスクリプションに関する更新を自動的にサーバーに送信します。

00:30:03.000 -> 00:30:14.000
これらの通知は、更新設定の変更、オファーの償還、請求の失敗などのイベントのタイミングについて最大限の洞察を提供します。

00:30:14.000 -> 00:30:21.000
ご覧のとおり、最近のSubscriptionStartDateは、顧客ロイヤルティを決定するための一連のオプションを締めくくっています。

00:30:21.000 -> 00:30:27.000
これらのツールを使用して、オファーをターゲットにし、最も忠実な顧客に報酬を与えます。

00:30:27.000 -> 00:30:33.000
それでは、Get Transaction Historyエンドポイントの便利な新しい機能強化に移りましょう。

00:30:33.000 -> 00:30:41.000
トランザクション履歴の取得エンドポイントを使用すると、アプリでユーザーの購入の全履歴を取得できます。

00:30:41.000 -> 00:30:46.000
エンドポイントの応答はページ分割されているため、このデータを合理的なチャンクで処理できます。

00:30:46.000 -> 00:30:53.000
各応答には、次のページを取得するために次のリクエストで提供するリビジョントークンが含まれています。

00:30:53.000 -> 00:31:02.000
また、ページは変更された日付でソートされます。つまり、後続の各ページには、最近変更されたトランザクションが含まれています。

00:31:02.000 -> 00:31:05.000
これがどのように機能するかを見てみましょう。

00:31:05.000 -> 00:31:12.000
トランザクション履歴の取得エンドポイントを呼び出すと、元のTransactionIdが提供されます。

00:31:12.000 -> 00:31:18.000
App Storeサーバーは、そのユーザーに対して最大20件の署名済みトランザクションを返します。

00:31:18.000 -> 00:31:25.000
また、このユーザーの次のページリクエストで提供する更新されたリビジョン値も返されます。

00:31:25.000 -> 00:31:31.000
応答のhasMoreフィールドが真である場合、利用可能なデータが増えることがわかっています。

00:31:31.000 -> 00:31:35.000
この場合、利用可能なデータの別のページがあるとしましょう。

00:31:35.000 -> 00:31:41.000
エンドポイントに別のリクエストを行い、最初の応答からそのリビジョン値を含めます。

00:31:41.000 -> 00:31:46.000
更新されたリビジョン値を含むデータの次のページを受け取ります。

00:31:46.000 -> 00:31:52.000
hasMoreはfalseになったので、最新の取引データが最新であることを知っています。

00:31:52.000 -> 00:31:58.000
今回を除いて、あなたは応答で最終的な取引について何かに気づきます。あなたは以前にそれを見たことがあります!

00:31:58.000 -> 00:32:03.000
それはあなたが最初の要求に応えて受け取った最初の20のうちの1つでした。

00:32:03.000 -> 00:32:10.000
これは、トランザクションが変更された必要があるため、ソート順の一番上に戻されたことを意味します。

00:32:10.000 -> 00:32:15.000
これで、そのトランザクションのデータを調べて、何が変更されたかをメモすることができます。

00:32:15.000 -> 00:32:24.000
この場合、revocationDateフィールドとrevocationReasonフィールドが入力され、トランザクションが取り消されたことを意味します。

00:32:24.000 -> 00:32:29.000
購入に関連するコンテンツを取り消すことで、アクションを実行できます。

00:32:29.000 -> 00:32:39.000
この最終応答のリビジョン値を、ユーザーを識別するために使用した元のTransactionIdと一緒に保存することをお勧めします。

00:32:39.000 -> 00:32:50.000
次回このユーザーのエンドポイントを呼び出すときは、そのリビジョンを提供し、前回のリクエスト以降に変更された新しいトランザクションデータのみが戻ってくることを知ることができます。

00:32:50.000 -> 00:33:00.000
ご覧のとおり、取引履歴の取得エンドポイントは、アプリ内購入データの包括的なセットを取得する簡単な方法を提供します。

00:33:00.000 -> 00:33:03.000
しかし、時にはそれは少し包括的すぎるかもしれません。

00:33:03.000 -> 00:33:09.000
一部のユーザーは、数年前にさかのぼる長い購入履歴を持っています。

00:33:09.000 -> 00:33:16.000
これらのユーザーにとって、このエンドポイントはさまざまなタイプの何百もの購入を返す可能性があります。

00:33:16.000 -> 00:33:20.000
ページがあっても、これは処理するのが大変です。

00:33:20.000 -> 00:33:27.000
そのため、今年は、さまざまな新しいソートとフィルターオプションでこのエンドポイントを強化しています。

00:33:27.000 -> 00:33:39.000
これで、最初から必要なデータを正確に伝え、サーバーの処理時間を節約し、利用可能なすべてのページを取得するために必要なネットワークコールの数を減らすことができます。

00:33:39.000 -> 00:33:47.000
結果の最初のページで最近変更された購入を見ることに興味がある場合は、変更日を降順に並べ替えることができます。

00:33:47.000 -> 00:33:56.000
また、製品タイプ、製品ID、ファミリー共有ステータスなど、いくつかの便利なフィールドでフィルタリングすることもできます。

00:33:56.000 -> 00:34:06.000
これらの新しいソートとフィルターオプションを適用するには、トランザクション履歴の取得エンドポイントにリクエストにクエリパラメータとして追加するだけです。

00:34:06.000 -> 00:34:09.000
それがどのように機能するかを詳しく見てみましょう。

00:34:09.000 -> 00:34:12.000
ここでは、すべての新しいパラメータオプションを見ることができます。

00:34:12.000 -> 00:34:18.000
ほとんどがトランザクション情報ペイロードから直接取得されるため、これらは見覚えがあるかもしれません。

00:34:18.000 -> 00:34:22.000
これらのパラメータを混ぜ合わせると、非常に具体的な結果が得られます。

00:34:22.000 -> 00:34:31.000
たとえば、今年の初めからユーザーが行った非消耗性の購入のみを取得したいのかもしれません。

00:34:31.000 -> 00:34:34.000
また、取り消された購入も除外したいと考えています。

00:34:34.000 -> 00:34:45.000
productTypeをNON_CONSUMABLEに設定し、startDateをミリ秒単位で表される今年の初めとして指定することで、カスタムリクエストを構築します。

00:34:45.000 -> 00:34:49.000
最後に、excludeRevokedをtrueに設定します。

00:34:49.000 -> 00:34:50.000
そして、それは私たちの要求です!

00:34:50.000 -> 00:34:58.000
ソート順を指定しなかったため、応答はデフォルトで昇順の変更日でソートされます。

00:34:58.000 -> 00:35:04.000
このような特定のリクエストがあっても、取得する購入ページが複数ある可能性があります。

00:35:04.000 -> 00:35:12.000
フォローアップリクエストについては、以前の応答からのリビジョンに加えて、まったく同じクエリパラメータを含める必要があります。

00:35:12.000 -> 00:35:24.000
さらに柔軟性を高めるために、3つのフィルターフィールドは複数の値をサポートしているため、提供された値の少なくとも1つに一致する購入のみにフィルタリングできます。

00:35:24.000 -> 00:35:32.000
これらのフィールドは、productType、productId、およびsubscriptionGroupIdentifierです。

00:35:32.000 -> 00:35:39.000
これらのパラメータに複数の値を提供するには、複数回定義するだけです。

00:35:39.000 -> 00:35:44.000
次に、App Store Serverの通知の更新に移りましょう。

00:35:44.000 -> 00:35:50.000
App Store Server Notifications V2を使用すると、サーバーを次のレベルに引き上げることができます。

00:35:50.000 -> 00:35:57.000
V2通知は、他では得られないアプリ内購入イベントに関する詳細な洞察を提供します。

00:35:57.000 -> 00:36:05.000
これらは、アプリで提供される自動更新サブスクリプションのライフサイクルを追跡するのに特に便利です。

00:36:05.000 -> 00:36:15.000
これらの洞察を使用して、顧客を維持したり、解約した顧客を取り戻したり、カスタマーサポートのリクエストを解決したりできます。

00:36:15.000 -> 00:36:19.000
これらすべての利点で、あなたはどのように始めるのか疑問に思うかもしれません。

00:36:19.000 -> 00:36:24.000
他の新機能と同様に、サンドボックステスト環境は始めるのに最適な場所です。

00:36:24.000 -> 00:36:35.000
そのため、昨年、サンドボックスでApp Storeサーバー通知を受信するために、App Store Connectで別のサーバーURLを設定する機能を追加しました。

00:36:35.000 -> 00:36:43.000
サーバーのURLを登録した後、サーバーがApp Storeサーバーから通知を受信していることを確認する必要があります。

00:36:43.000 -> 00:36:49.000
ユーザーアクションを通じて通知をトリガーするためだけに、サンドボックスアカウントを設定できます。

00:36:49.000 -> 00:36:56.000
たとえば、そのサンドボックスアカウントを使用してサブスクリプションの初回購入を行うとします。

00:36:56.000 -> 00:37:03.000
SUBSCRIBEDタイプとサブタイプINITIAL_BUYのV2通知を受け取る必要があります。

00:37:03.000 -> 00:37:05.000
しかし、その通知が来ない場合はどうなりますか?

00:37:05.000 -> 00:37:12.000
サーバーに問題があったのか、通知をトリガーするために実行した手順があったのか疑問に思うかもしれません。

00:37:12.000 -> 00:37:16.000
この状況は、始めるときに多くの不確実性を生み出す可能性があります。

00:37:16.000 -> 00:37:25.000
このエクスペリエンスを簡素化し、App Storeサーバー通知がサーバーに到達できることを簡単に確認する方法を提供したいと考えています。

00:37:25.000 -> 00:37:31.000
そのため、今年は新しいRequest a Test Notificationエンドポイントを導入します。

00:37:31.000 -> 00:37:42.000
このシンプルなエンドポイントを呼び出すことで、App Store Connectでアプリに登録されたサーバーURLにTESTタイプのV2通知を送信するように依頼することができます。

00:37:42.000 -> 00:37:47.000
新しいTEST通知タイプは、このエンドポイントにのみ使用されます。

00:37:47.000 -> 00:37:55.000
サンドボックスまたは本番環境でエンドポイントを呼び出して、いずれかの環境で保存したURLをテストできます。

00:37:55.000 -> 00:38:01.000
この新しいエンドポイントを使用して、新しいサーバーのURLと構成をすばやくテストします。

00:38:01.000 -> 00:38:04.000
これが初めてのセットアップをどのように簡素化するかを見てみましょう。

00:38:04.000 -> 00:38:12.000
さて、最初の通知をトリガーしたいだけなら、サンドボックスアカウントを設定したり、購入を実行したりする必要はありません。

00:38:12.000 -> 00:38:22.000
テストしたい環境で新しいエンドポイントを呼び出すだけで、リクエストを確認するHTTP 200応答が届きます。

00:38:22.000 -> 00:38:31.000
応答には、サーバーが受信するテスト通知を識別する新しいフィールド、testNotificationTokenが含まれます。

00:38:31.000 -> 00:38:34.000
後でこの分野に戻ります。

00:38:34.000 -> 00:38:43.000
その後まもなく、サーバーはApp Store Connectに保存されたURLでTESTタイプのV2通知を受け取るはずです。

00:38:43.000 -> 00:38:46.000
では、このエンドポイントを呼び出す方法を見てみましょう。

00:38:46.000 -> 00:38:52.000
App Storeサーバー上のこの新しいパスに簡単なPOSTリクエストを送信するだけです。

00:38:52.000 -> 00:38:58.000
HTTP 200の応答を受け取り、リクエストが送信されたことを知ることができます。

00:38:58.000 -> 00:39:03.000
応答には、私が言及した新しいフィールド、testNotificationTokenが含まれます。

00:39:03.000 -> 00:39:06.000
後でこれをメモしておいてください。

00:39:06.000 -> 00:39:10.000
まもなく、署名されたテスト通知が届きます。

00:39:10.000 -> 00:39:14.000
デコードされると、その通知はこんな感じになります。

00:39:14.000 -> 00:39:23.000
新しいnotificationType、TESTを含む、V2通知の通常の最上位フィールドがすべて含まれていることに気付くでしょう。

00:39:23.000 -> 00:39:27.000
データオブジェクトの内容は、通常の通知よりも少し短いです。

00:39:27.000 -> 00:39:40.000
これは単なるテストであるため、含めるトランザクション関連のデータがないため、トランザクション固有のフィールド、特にsignedTransactionInfoを省略します。

00:39:40.000 -> 00:39:48.000
新しいテスト通知要求エンドポイントを呼び出すときは、App Storeサーバー通知が非同期に送信されることに注意してください。

00:39:48.000 -> 00:39:59.000
エンドポイントへの呼び出しが成功すると、HTTP 200が返されますが、実際のテスト通知はしばらくして別々に届きます。

00:39:59.000 -> 00:40:07.000
このエンドポイントはサーバー構成のテストがすべてであることを考えると、そのテストが失敗したときに何をすべきか疑問に思うかもしれません。

00:40:07.000 -> 00:40:12.000
言い換えれば、テスト通知が届かない場合はどうなりますか?

00:40:12.000 -> 00:40:24.000
テスト機能をさらに強化するために、テスト通知のリクエストエンドポイントと組み合わせて使用するテスト通知ステータスを取得するエンドポイントをリリースします。

00:40:24.000 -> 00:40:30.000
この新しいエンドポイントを使用すると、以前に要求されたTEST通知のステータスを確認できます。

00:40:30.000 -> 00:40:39.000
エンドポイントの応答は、App Storeサーバーがサーバーに到達し、TEST通知を正常に送信できたかどうかを教えてくれます。

00:40:39.000 -> 00:40:46.000
送信に失敗した場合は、その理由がわかるので、サーバー設定をよりよくトラブルシューティングできます。

00:40:46.000 -> 00:40:50.000
このエンドポイントの使用方法を確認しましょう。

00:40:50.000 -> 00:40:54.000
App Storeサーバー上のこのパスにGETリクエストを送信します。

00:40:54.000 -> 00:41:02.000
パスには、Request a Test Notificationエンドポイントから受け取ったtestNotificationTokenを含めます。

00:41:02.000 -> 00:41:07.000
これにより、ステータスを確認したいテスト通知がわかります。

00:41:07.000 -> 00:41:09.000
さて、応答のために。

00:41:09.000 -> 00:41:17.000
signedPayloadフィールドには、App Storeサーバーがサーバーに送信しようとしたTEST通知ペイロードが含まれています。

00:41:17.000 -> 00:41:23.000
そして、最初のSendAttemptResultフィールドは、その送信試行の結果を示します。

00:41:23.000 -> 00:41:34.000
ここで、SUCCESSは送信が成功したことを示します。これは、App StoreサーバーがサーバーからHTTP 200応答を受信したことを意味します。

00:41:34.000 -> 00:41:40.000
送信に失敗した場合、代わりにいくつかの異なるエラー値のいずれかが表示されます。

00:41:40.000 -> 00:41:48.000
これらの値は、App Storeサーバーがテスト通知でサーバーに到達しようとして経験したエラーを示しています。

00:41:48.000 -> 00:41:58.000
この情報を使用して、サーバーの問題をトラブルシューティングし、必要に応じて新しいテスト通知を要求し、サーバーを確実に実行することができます。

00:41:58.000 -> 00:42:11.000
全体として、これらのテスト通知エンドポイントは使いやすく、V2 App Storeサーバー通知を受信するようにサーバーを設定または再構成する際に多くの手間を省くことができます。

00:42:11.000 -> 00:42:17.000
これらのエンドポイントの助けを借りて、サーバーを設定し、スムーズに実行されていることを確認できます。

00:42:17.000 -> 00:42:20.000
しかし、サーバーは完璧ではなく、停止が発生します。

00:42:20.000 -> 00:42:26.000
サーバーがダウンし、App Storeサーバー通知を見逃したときにどのように回復しますか?

00:42:26.000 -> 00:42:30.000
これに対する現在の解決策は、再試行システムです。

00:42:30.000 -> 00:42:36.000
App Storeサーバーがサーバーに到達できない場合、再試行プロセスが開始されます。

00:42:36.000 -> 00:42:43.000
同じ通知の送信を最大5回まで再試行し、各試行の間により長い待ち時間があります。

00:42:43.000 -> 00:42:47.000
これらの再試行は、本番環境でのみ行われます。

00:42:47.000 -> 00:42:53.000
再試行は最終的に停止から回復するのに役立ちますが、すべての状況に完璧ではありません。

00:42:53.000 -> 00:42:57.000
たとえば、一部の停電は広範囲に及ぶ可能性があります。

00:42:57.000 -> 00:43:05.000
サーバーがApp Storeサーバーからの最終的な再試行を見逃すのに十分な長さでダウンしている場合、その通知は失われます。

00:43:05.000 -> 00:43:13.000
または、より一般的には、サーバーは非常に短い問題が発生する可能性があり、その間に一握りの通知しか見逃しません。

00:43:13.000 -> 00:43:20.000
しかし、1つの通知を見逃すということは、顧客記録の一部が少なくとも1時間時代遅れであることを意味します。

00:43:20.000 -> 00:43:23.000
しかし、あなたはどれかわからない!

00:43:23.000 -> 00:43:29.000
明らかに、サーバーの停止はストレスであり、それらからの回復は複雑な作業になる可能性があります。

00:43:29.000 -> 00:43:39.000
そのため、見逃したApp Storeサーバー通知をできるだけ簡単に回復できるようにし、できるだけ早くサーバーを軌道に戻すことができます。

00:43:39.000 -> 00:43:45.000
そのため、今年は新しい通知履歴の取得エンドポイントを導入します。

00:43:45.000 -> 00:43:53.000
このエンドポイントを使用すると、アプリ用に生成されたV2 App Storeサーバー通知の履歴を取得できます。

00:43:53.000 -> 00:44:02.000
サーバーが通知を正常に受信したかどうかにかかわらず、その通知はこのエンドポイントの応答に表示されます。

00:44:02.000 -> 00:44:08.000
このエンドポイントを呼び出すときは、取得する通知の日付範囲を指定します。

00:44:08.000 -> 00:44:18.000
WWDCでは、このデータの記録を開始し、利用可能な最新の6ヶ月間のローリング履歴の上限まで構築します。

00:44:18.000 -> 00:44:29.000
オプションで、タイプとサブタイプでリクエストをフィルタリングすることも、元のTransactionIdを提供することで単一のユーザーの通知のみを取得することもできます。

00:44:29.000 -> 00:44:35.000
また、既存の再試行システムはまだ利用可能であるため、この新しいエンドポイントと並行して使用できます。

00:44:35.000 -> 00:44:39.000
このエンドポイントをどのように呼び出すかを見てみましょう。

00:44:39.000 -> 00:44:43.000
App Storeサーバー上のこの新しいパスにPOSTリクエストを送信します。

00:44:43.000 -> 00:44:48.000
リクエスト本文には、startDateとendDateが含まれます。

00:44:48.000 -> 00:44:54.000
応答には、このウィンドウで最初に送信しようとした通知のみが含まれます。

00:44:54.000 -> 00:45:02.000
利用可能な最も早い通知は、リクエストの日付の6ヶ月前に送信されることに注意してください。

00:45:02.000 -> 00:45:08.000
オプションで、notificationTypeとnotificationSubtypeを指定できます。

00:45:08.000 -> 00:45:15.000
そうすると、履歴はこれらの値の両方に一致する通知のみにフィルタリングされます。

00:45:15.000 -> 00:45:19.000
一部の通知にはサブタイプがないことを覚えておいてください。

00:45:19.000 -> 00:45:28.000
または、ユーザーの元のTransactionIdを提供して、そのユーザーのみの通知履歴を取得することもできます。

00:45:28.000 -> 00:45:37.000
最後に、次のページを取得するために、すべてのフォローアップリクエストのクエリパラメータとしてpaginationTokenを提供する必要があります。

00:45:37.000 -> 00:45:44.000
フォローアップリクエストに同じリクエストボディを使用し、このpaginationTokenのみを変更してください。

00:45:44.000 -> 00:45:47.000
では、その反応を見てみましょう。

00:45:47.000 -> 00:45:55.000
notificationHistory配列には最大20件の通知が含まれており、最も古い通知が最初に含まれています。

00:45:55.000 -> 00:46:07.000
この配列の各エントリは通知を表し、内部には署名されたPayloadがあり、通常どおりデコードしてトランザクションデータを表示できます。

00:46:07.000 -> 00:46:14.000
内部のデータは、元の通知でApp Storeサーバーが送信したペイロードと同じです。

00:46:14.000 -> 00:46:20.000
また、このエンドポイント応答に新しいfirstSendAttemptResultフィールドをもたらしたことがわかります。

00:46:20.000 -> 00:46:30.000
このフィールドを使用して、タイムアウトやその他のエラーのシーケンスを検索し、サーバーが過去に通知を見逃した理由をよりよく理解できます。

00:46:30.000 -> 00:46:36.000
応答には、取得するページがもっとある場合、paginationTokenも含まれています。

00:46:36.000 -> 00:46:41.000
通知の次のページを取得するには、次のリクエストでこれを提供する必要があります。

00:46:41.000 -> 00:46:47.000
hasMoreフィールドがtrueである限り、取得するページがもっとあることがわかるでしょう。

00:46:47.000 -> 00:46:52.000
そして、この便利な新しいエンドポイントについて知っておくべきことはすべてです。

00:46:52.000 -> 00:46:56.000
これで、今日のApp Storeサーバーのアップデートは終了です。

00:46:56.000 -> 00:47:02.000
本日発表されたすべてのサーバー機能は、サンドボックスと本番の両方で利用可能になりました。

00:47:02.000 -> 00:47:07.000
これらの新機能を活用して、サーバーを最高のものにすることを願っています。

00:47:07.000 -> 00:47:24.000
レガシークライアントをサポートしながら最新の機能を使用する方法など、アプリ内購入でサーバーを使用するためのより優れたコンテンツについては、WWDC22の別のセッション「アプリ内購入の統合と移行を探索する」をチェックすることをお勧めします。

00:47:24.000 -> 00:47:27.000
両方：WWDC22に参加してくれてありがとう！

00:47:27.000 -> 23:59:59.000
♪

