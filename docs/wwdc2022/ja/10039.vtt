WEBVTT

00:00:00.000 -> 00:00:09.000
♪ ♪

00:00:09.000 -> 00:00:11.000
グレッグ:こんにちは、私はグレッグです。

00:00:11.000 -> 00:00:13.000
StoreKitテストの新機能へようこそ。

00:00:13.000 -> 00:00:20.000
このセッションでは、ピーターと私は、StoreKitでアプリ内購入をテストするために利用可能ないくつかの素晴らしい新機能を強調します。

00:00:20.000 -> 00:00:27.000
Xcode 14を使用してアプリ内購入テストを合理化する方法のいくつかを見てみましょう。 アプリ内購入テストを合理化します。

00:00:27.000 -> 00:00:37.000
次に、アプリ内サブスクリプションの実装でさらに多くのコーナーケースをカバーするために利用できるいくつかの新しい機能を見ていきます。

00:00:37.000 -> 00:00:42.000
そして最後に、ピーターはサンドボックステスト環境の新しい機能強化を紹介します。

00:00:42.000 -> 00:00:49.000
私たちは、ドーナツを販売するフードトラックオペレーターに強力な機能を提供するアプリであるフードトラックと協力します。

00:00:49.000 -> 00:00:58.000
私はすでにStoreKitと統合して、フードトラックの販売履歴機能のフルバージョンと、ソーシャルフィードサービスの拡張バージョンのサブスクリプションを提供しています。

00:00:58.000 -> 00:01:04.000
セッションを通して、XcodeでStoreKitテストを使用して、アプリのアプリ内購入機能をテストします。

00:01:04.000 -> 00:01:12.000
WWDC 2020では、XcodeでStoreKitテストを導入し、Xcodeで直接アプリ内購入のテストを開始できるようになりました。

00:01:12.000 -> 00:01:20.000
今年は、Xcode 14で、StoreKitアプリのテストライフサイクルに関するいくつかのアップデートを共有できることを嬉しく思います。

00:01:20.000 -> 00:01:30.000
以前と同様に、XcodeでStoreKit構成ファイルを作成し、App Store Connectでアプリを設定せずにアプリ内購入の実装のテストを開始できます。

00:01:30.000 -> 00:01:42.000
App Store Connectでアプリを設定する準備ができたら、Xcode 14にまったく新しい機能を導入し、XcodeのStoreKit TestingでApp Store Connectに入力したのと同じアプリ内購入製品を使用できるようにします。

00:01:42.000 -> 00:01:50.000
すでにストアにアプリがある場合は、StoreKit構成ファイルを最初から設定することなく、今すぐXcodeでStoreKitテストを使用開始できます。

00:01:50.000 -> 00:02:05.000
この便利な機能を使用すると、アプリ内購入を一度設定し、Xcode、ユニットテスト内、サンドボックス環境、およびリリースの準備ができたら、App Storeで同じ設定をローカルで使用できます。

00:02:05.000 -> 00:02:08.000
App Store Connectで製品をXcodeと簡単に同期できます。

00:02:08.000 -> 00:02:14.000
まず、このソーシャルフィード+サブスクリプションのように、App Store Connectで製品を設定します。

00:02:14.000 -> 00:02:21.000
次に、Xcodeで同期された設定ファイルを作成し、製品データをXcodeにロードします。

00:02:21.000 -> 00:02:30.000
米国の英語タイトルを更新するなど、変更を加えたい場合は、App Store Connectで変更を加え、Xcodeで設定を再度同期できます。

00:02:30.000 -> 00:02:36.000
同期した設定をローカルの編集可能なファイルに変換して、その場で変更を加えることもできます。

00:02:36.000 -> 00:02:45.000
同期された構成をローカル構成に変換することは一方向操作であり、再度同期するには、新しい構成ファイルを作成する必要があります。

00:02:45.000 -> 00:02:53.000
フードトラックアプリが提供するソーシャルフィードサービスの拡張バージョンであるソーシャルフィード+のサブスクリプショングループを設定することからすでに始めました。

00:02:53.000 -> 00:02:59.000
Xcodeに飛び込んで、XcodeのStoreKitテストでこれらの製品を使用する方法を見てみましょう。

00:02:59.000 -> 00:03:01.000
私はMacでフードトラックプロジェクトを開いています。

00:03:01.000 -> 00:03:17.000
開始するには、ファイルメニューに移動し、新しいファイルを作成し、StoreKitでフィルタリングし、[次へ]をクリックして、新しいStoreKit構成ファイルを作成します。

00:03:17.000 -> 00:03:26.000
Xcode 14では、新しい設定ファイルを作成すると、App Store Connectのアプリとファイルを同期させるためのチェックボックスが表示されます。

00:03:26.000 -> 00:03:32.000
ローカルファイルを作成するには、名前を入力し、ボックスのチェックを外したままにします。

00:03:32.000 -> 00:03:40.000
同期を設定するには、チェックボックスをオンにして、正しいチームとアプリが選択されていることを確認するだけです。

00:03:40.000 -> 00:03:45.000
必要に応じて、ピッカーメニューを使用して別のチームとアプリを選択できます。

00:03:45.000 -> 00:03:51.000
「次へ」をクリックし、ファイルを保存する場所を選択します。

00:03:51.000 -> 00:03:56.000
ファイルを保存するとすぐに、アプリ内課金メタデータがApp Store Connectから同期を開始します。

00:03:56.000 -> 00:04:02.000
データがダウンロードされている間、私たちはアプリで作業を続け、アクティビティバーでその進捗状況を追跡することができます。

00:04:02.000 -> 00:04:09.000
同期が完了すると、このファイルが一般的なStoreKit構成ファイルとは異なって見えることに気付くでしょう。

00:04:09.000 -> 00:04:13.000
これは、同期されたファイルが読み取り専用状態だからです。

00:04:13.000 -> 00:04:21.000
Xcodeのすべてのデータを一目で確認できますが、変更を加えるにはApp Store Connectを開く必要があります。

00:04:21.000 -> 00:04:25.000
私はSafariでソーシャルフィード+の月間製品を持っています。

00:04:25.000 -> 00:04:37.000
製品を年間計画と区別するために接尾辞を追加して、この製品の英語タイトルを更新しましょう。

00:04:37.000 -> 00:04:45.000
これが更新されたので、保存してXcodeに戻りましょう。

00:04:45.000 -> 00:04:56.000
この変更を設定ファイルに反映させるには、左下隅にあるこの同期ボタンを押すだけです。

00:04:56.000 -> 00:05:03.000
同期が完了すると、変更がXcodeに反映されていることがわかります。

00:05:03.000 -> 00:05:21.000
同期されたファイルは読み取り専用ですが、データをローカルファイルにコピーして、Xcode内ですばやく変更を加えることができます。

00:05:21.000 -> 00:05:29.000
設定ファイルからアイテムをコピーするだけでなく、同期したファイル全体をローカルの編集可能なファイルに変換することもできます。

00:05:29.000 -> 00:05:43.000
同期したファイルを開き、エディタメニューに移動し、「ローカルストアキット構成に変換」をクリックするだけです。

00:05:43.000 -> 00:05:47.000
ファイルを変換した後、この操作を元に戻すことはできないことを覚えておいてください。

00:05:47.000 -> 00:05:52.000
アプリと再度同期するには、新しいStoreKit設定ファイルを作成する必要があります。

00:05:52.000 -> 00:05:59.000
このファイルをApp Store Connectと同期させたいので、このアラートをキャンセルしましょう。

00:05:59.000 -> 00:06:04.000
ファイルを同期したので、テスト環境を設定しましょう。

00:06:04.000 -> 00:06:11.000
はじめに、スキームエディタを開きます。

00:06:11.000 -> 00:06:18.000
実行アクションを選択し、オプションを選択します。

00:06:18.000 -> 00:06:23.000
オプションでは、ピッカーメニューから異なるStoreKit環境を切り替えることができます。

00:06:23.000 -> 00:06:30.000
「なし」を選択するとサンドボックスに接続し、「フードトラック」を選択するとXcode環境に接続します。

00:06:30.000 -> 00:06:41.000
現在のテストニーズに応じて環境を切り替えるのは簡単で、両方の環境がまったく同じ製品とサブスクリプションのメタデータを使用するようになります。

00:06:41.000 -> 00:06:47.000
とりあえず、同期した設定ファイルを選びましょう。

00:06:47.000 -> 00:06:51.000
XcodeでStoreKitを設定したので、テストに行きましょう。

00:06:51.000 -> 00:07:00.000
SwiftUIアプリを使用しているため、Xcodeでサブスクリプションストアをプレビューできます。

00:07:00.000 -> 00:07:07.000
Xcode 14以降、StoreKit設定ファイルの製品がSwiftUIプレビューに直接読み込まれます。

00:07:07.000 -> 00:07:14.000
これにより、実際のアプリ内購入データを使用して、見栄えの良いストアユーザーインターフェイスの構築とテストが非常に簡単になります。

00:07:14.000 -> 00:07:21.000
当社の製品のサブタイトルを含めることで、製品オプションに詳細を追加してみましょう。

00:07:21.000 -> 00:07:29.000
製品のローカライズされた説明を含むテキストビューを追加するだけです。

00:07:29.000 -> 00:07:34.000
そして、App Store Connectで設定した説明で、すぐにプレビューアップデートを見てください。

00:07:34.000 -> 00:07:38.000
これは今、ずっと良くなっていると思います。

00:07:38.000 -> 00:07:56.000
UIの状態が良くなったので、iPhoneでアプリを実行して、機能テストを始めましょう。

00:07:56.000 -> 00:08:01.000
Xcode 14では、StoreKitトランザクションマネージャーにいくつかの強力な新しいツールがあります。

00:08:01.000 -> 00:08:10.000
アプリを実行している状態で、デバッグバーの購入アイコンを押してトランザクションマネージャーを開くことができます。

00:08:10.000 -> 00:08:18.000
右側には、トランザクションに関するすべての内部の詳細を視覚化できる新しいトランザクションインスペクタがあります。

00:08:18.000 -> 00:08:22.000
このツールは、アプリ内トランザクションの状態を理解するのに役立ちます。

00:08:22.000 -> 00:08:32.000
たとえば、このSocial Feed+のサブスクリプションの有効期限が切れた日付と、今後の更新に関する情報を確認できます。

00:08:32.000 -> 00:08:38.000
また、製品、サブスクリプショングループ、またはサブスクリプションオファーの設定ファイルにジャンプすることもできます。

00:08:38.000 -> 00:08:45.000
このサブスクリプショングループの横にあるジャンプボタンをクリックするだけです。

00:08:45.000 -> 00:08:53.000
そして、私たちは設定ファイルでソーシャルフィード+に直接連れて行かれます。

00:08:53.000 -> 00:09:00.000
この検査官は、より高度なテストケースを検討する際に、セッションの後半で私たちを助けてくれます。

00:09:00.000 -> 00:09:10.000
また、今すぐトランザクションをフィルタリングすることもできます。これは、これらすべてのソーシャルフィード+更新でトランザクションのリストをナビゲートするのに本当に便利です。

00:09:10.000 -> 00:09:17.000
私たちのアプリでは、年間販売履歴機能にアクセスできることに気付くでしょう。

00:09:17.000 -> 00:09:25.000
これらのサブスクリプションの更新がすべてあるため、どのトランザクションにその機能を受ける権利があるかを見分けるのが困難です。

00:09:25.000 -> 00:09:32.000
IDの入力を開始することで、製品のトランザクションを簡単に見つけることができます。

00:09:32.000 -> 00:09:40.000
そして、オートコンプリートメニューから製品IDフィルターを選択します。

00:09:40.000 -> 00:09:52.000
購入日で絞り込むこともできるので、今行っている購入だけに集中できます。

00:09:52.000 -> 00:10:06.000
ソーシャルフィード+のサブスクリプションの有効期限が切れているので、アプリに入ってもう一度購読しましょう。

00:10:06.000 -> 00:10:13.000
サブスクリプションを確認したので、新しいトランザクションだけが表示されます。

00:10:13.000 -> 00:10:28.000
App Store Connectから製品とサブスクリプションを同期し、SwiftUIプレビューでStoreKit構成を使用し、トランザクションマネージャーの新しいツールを活用することで、Xcodeでのアプリ内購入テストを強化するいくつかの方法を検討しました。

00:10:28.000 -> 00:10:38.000
次に、Xcodeの新機能を使用して高度なサブスクリプションケースをカバーすることで、Food Truckのアプリ内購入機能のテストを続けます。

00:10:38.000 -> 00:10:46.000
まず、フードトラックでの購入の払い戻しをリクエストできるように、払い戻しリクエストのテストを見ていきます。

00:10:46.000 -> 00:11:04.000
次に、オファーコードをテストし、ソーシャルフィード+の加入者にプロモーションを提供し、フードトラックのユーザーインターフェイスで価格上昇の処理を検討し、最後に、請求の再試行と猶予期間をサポートすることで、ソーシャルフィード+の非自発的な解約を減らします。

00:11:04.000 -> 00:11:14.000
払い戻しリクエストのテストを開始するには、アプリでこのサポートビューに移動し、払い戻しする最近のトランザクションを選択できます。

00:11:14.000 -> 00:11:16.000
これのコードは簡単です。

00:11:16.000 -> 00:11:25.000
ビューにrefundRequestSheetビュー修飾子を追加し、払い戻しボタンを押すと、isPresented Bindingをtrueに反転します。

00:11:25.000 -> 00:11:29.000
さて、これを実際に見てみましょう。

00:11:29.000 -> 00:11:34.000
バインディングがtrueの場合、払い戻しリクエストシートがビューの上に表示されます。

00:11:34.000 -> 00:11:43.000
Xcode環境でテストする場合、選択した問題は、StoreKit APIのRevocationReasonと1対1に対応します。

00:11:43.000 -> 00:11:49.000
「開発者の問題」を選択し、「払い戻しのリクエスト」を押しましょう。

00:11:49.000 -> 00:12:00.000
App Storeでは、払い戻しリクエストの処理には時間がかかりますが、XcodeまたはSandboxでテストすると、払い戻しリクエストはすぐに取引を返金します。

00:12:00.000 -> 00:12:13.000
トランザクションマネージャーでは、この更新されたトランザクションのインスペクタを見て、選択したばかりの失効理由と失効日を確認できます。

00:12:13.000 -> 00:12:19.000
トランザクションマネージャーの払い戻しボタンをクリックするだけで、払い戻しをテストすることもできます。

00:12:19.000 -> 00:12:25.000
払い戻しリクエストAPIは、フードトラックを使用する人々に優れたカスタマーサポートを提供するのに役立ちます。

00:12:25.000 -> 00:12:33.000
Xcodeで払い戻しリクエストをテストする方法を見て、StoreKitを使用して払い戻しされたトランザクションを処理する方法をいくつか見てみましょう。

00:12:33.000 -> 00:12:41.000
トランザクションを返金した後、更新されたトランザクション値はTransaction.updatesシーケンスから発行されます。

00:12:41.000 -> 00:12:47.000
revocationDateとrevocationReasonプロパティを使用して、これらの返金されたトランザクションを検出できます。

00:12:47.000 -> 00:12:55.000
Xcodeの払い戻しリクエストシートで対応するオプションを選択することで、2つの失効理由のケースを簡単にテストできます。

00:12:55.000 -> 00:12:58.000
それが、Xcodeで払い戻しリクエストシートをテストする方法です。

00:12:58.000 -> 00:13:04.000
これは、Xcode環境またはサンドボックスのいずれかを使用する場合、iOSとmacOSで動作します。

00:13:04.000 -> 00:13:11.000
Xcodeでテストするには、iOSまたはiPadOS 15.2以降を実行するためにiPhoneまたはiPadが必要です。

00:13:11.000 -> 00:13:15.000
MacのXcodeでテストするには、macOS 12.1以降が必要です。

00:13:15.000 -> 00:13:19.000
では、サブスクリプションオファーコードのテストを見てみましょう。

00:13:19.000 -> 00:13:24.000
このためには、ローカルのStoreKit設定ファイルを使用します。

00:13:24.000 -> 00:13:32.000
コードの新しいオファーを行うには、サブスクリプションを選択し、オファーコード表の下にある「+」を押します。

00:13:32.000 -> 00:13:34.000
その後、オファーを設定できます。

00:13:34.000 -> 00:13:42.000
これを「無料月」と名付け、1か月間無料オファーにします。

00:13:42.000 -> 00:13:51.000
App Store Connectと同様に、対象となる顧客を選択し、入門オファーをこのオファーで引き換えることができるかどうかを選択します。

00:13:51.000 -> 00:13:54.000
とりあえずデフォルト設定はそのままにしておきましょう。

00:13:54.000 -> 00:13:58.000
コードが設定されたので、「完了」を押します。

00:13:58.000 -> 00:14:06.000
もちろん、App Store Connectと同期している場合、設定されたオファーはこの表に自動的に表示されます。

00:14:06.000 -> 00:14:12.000
オファーが設定されたので、アプリのストアビューに移動しましょう。

00:14:12.000 -> 00:14:18.000
サブスクリプションオファーを引き換えるために、ビューの下部にこのボタンを追加しました。

00:14:18.000 -> 00:14:33.000
Xcodeでストアビューの実装を開くと、オファーコードを実装することは、ビューにofferCodeRedemption修飾子を追加し、誰かがボタンをタップしたときにisPresented Bindingをtrueに反転させるのと同じくらい簡単です。

00:14:33.000 -> 00:14:37.000
これがどのように機能するか見てみましょう。

00:14:37.000 -> 00:14:42.000
ボタンを押すと、引き換えシートがアプリの上に表示されます。

00:14:42.000 -> 00:14:51.000
App Storeでは、App Store Connectで生成したオファーコードを入力できますが、Xcodeではテスト体験がはるかに合理化されています。

00:14:51.000 -> 00:14:57.000
設定ファイルには、ロック解除されたサブスクリプションでグループ化されたコードのすべてのオファーのリストがあります。

00:14:57.000 -> 00:15:03.000
引き換えるには、先ほど作成したオファーをタップし、引き換えボタンを押しましょう。

00:15:03.000 -> 00:15:17.000
支払いシートが表示され、入門オファーに行くと、支払いの直後にコードのオファーが開始されることがわかります。

00:15:17.000 -> 00:15:30.000
購読後、確認画面が表示され、シートを閉じて、アプリがソーシャルフィード+へのアクセスのロックを解除することを確認できます。

00:15:30.000 -> 00:15:37.000
この新しい取引の検査官を見ると、導入オファーが現在適用されていることがわかります。

00:15:37.000 -> 00:15:43.000
オファーは有料なので、更新セクションでは、入門オファーのさらに2つの更新を取得することを示しています。

00:15:43.000 -> 00:15:47.000
その後、私たちが引き換えたばかりの無料の月コード。

00:15:47.000 -> 00:15:51.000
その後、標準サブスクリプションは無期限に更新されます。

00:15:51.000 -> 00:16:00.000
検査官は、複数のオファーのような複雑なシナリオであっても、サブスクリプションの状態に何が起こっているのかを非常に明確にします。

00:16:00.000 -> 00:16:08.000
ローカルのStoreKit構成でオファーコードを設定する方法と、iPhoneで引き換えをテストする方法を見ました。

00:16:08.000 -> 00:16:18.000
オファーコードは、将来および既存の加入者に柔軟なプロモーションを提供する素晴らしい方法であり、フードトラックでオファーコードを使い始めるのがこれまで以上に簡単になりました。

00:16:18.000 -> 00:16:22.000
では、StoreKitを使用してこれらのオファーを処理する方法を見てみましょう。

00:16:22.000 -> 00:16:30.000
コードを引き換えた後、Transaction.updatesとStatus.updatesの両方のシーケンスが新しい値を出力します。

00:16:30.000 -> 00:16:38.000
トランザクション値のofferTypeプロパティをチェックして、現在のトランザクションに適用されるオファーがあるかどうかを確認できます。

00:16:38.000 -> 00:16:49.000
サブスクライバーがコードのオファーで入門オファーを引き換えることを許可したため、offerTypeの価値は導入になります。

00:16:49.000 -> 00:16:57.000
renewalInfo値では、offerTypeプロパティをチェックして、次の更新でどのようなオファーが存在するかを確認できます。

00:16:57.000 -> 00:17:04.000
先ほど見たケースでは、ペイ・ア・ア・ゴー・オファーを使用したため、初期値が導入されることが期待できます。

00:17:04.000 -> 00:17:11.000
2つのサブスクリプション期間の後、コードオファーが積み重ねられているため、値がコードに切り替わります。

00:17:11.000 -> 00:17:19.000
offerTypeがコードの場合、offerIDプロパティを使用して、コードに適用されたオファーの参照名を取得できます。

00:17:19.000 -> 00:17:23.000
それが、Xcodeでコードのオファーをテストする方法です。

00:17:23.000 -> 00:17:32.000
Xcode 13.3以降のコードのオファーを設定し、iOS 15.4以降を実行しているiPhoneとiPadでテストできます。

00:17:32.000 -> 00:17:40.000
フードトラックでコードが機能するオファーを確認したので、アプリがソーシャルフィード+の値上げをどのように処理するかをテストしましょう。

00:17:40.000 -> 00:17:43.000
Xcodeでは、値上げのテストは本当に簡単です。

00:17:43.000 -> 00:17:50.000
開始するには、毎月のソーシャルフィードサブスクリプションの価格を引き上げます。

00:17:50.000 -> 00:17:52.000
このステップはオプションです。

00:17:52.000 -> 00:17:56.000
価格を同じままにして、値上げをシミュレートすることができます。

00:17:56.000 -> 00:18:10.000
トランザクションマネージャーに戻ると、サブスクリプションの最新のトランザクションを選択し、ツールバーの「Request Price Increase Consent」を押すだけです。

00:18:10.000 -> 00:18:24.000
トランザクションマネージャーでは、取引が「値上げ保留中」状態になっていることがわかります。デバイスを見ると、アプリの上に表示され、値上げへの同意を求めるシートが表示されます。

00:18:24.000 -> 00:18:33.000
このシートはコードを追加せずに単独で表示されますが、新しいメッセージAPIを利用して動作をカスタマイズしました。

00:18:33.000 -> 00:18:48.000
コードでメッセージAPIとどのように統合したかを見てみましょう。

00:18:48.000 -> 00:19:00.000
ここにメッセージシーケンスを反復するforループがあり、値上げなどのメッセージが表示された場合は、ドーナツエディタのような敏感なビューが表示されていないことを確認してください。

00:19:00.000 -> 00:19:06.000
それ以外の場合は、DisplayMessageActionを使用してメッセージを表示します。

00:19:06.000 -> 00:19:14.000
ドーナツエディタが表示されたら、メッセージの値を保持し、ドーナツ編集が終了した後に表示します。

00:19:14.000 -> 00:19:19.000
テストに戻りましょう。

00:19:19.000 -> 00:19:29.000
App Storeでは、既存の加入者は、値上げのキャンセルまたは同意を決定するまで、異なる時間に複数の値上げメッセージを受け取ることがあります。

00:19:29.000 -> 00:19:33.000
Xcodeでは、これらのメッセージがいつ届くかを完全に制御できます。

00:19:33.000 -> 00:19:43.000
トランザクションマネージャーのボタンを押すたびに、トランザクションがすでに値上げ状態であっても、再びメッセージが表示されます。

00:19:43.000 -> 00:19:48.000
これで、延期ロジックが実際に機能するかどうかをテストできます。

00:19:48.000 -> 00:19:54.000
だから私はドーナツエディタを開きます...

00:19:54.000 -> 00:20:02.000
そして、シートをもう一度開くようにメッセージを送ってください。

00:20:02.000 -> 00:20:10.000
シートはまだ表示されませんが、ドーナツエディタを離れると、シートは期待どおりに表示されます。

00:20:10.000 -> 00:20:21.000
値上げを受け入れるか、シートのサブスクリプションをキャンセルすることができますが、実際には、ユーザーは電子メールなどの外部ソースを介して値上げに応答する可能性があります。

00:20:21.000 -> 00:20:29.000
これをシミュレートするには、トランザクションマネージャーの承認ボタンと拒否ボタンを使用できます。

00:20:29.000 -> 00:20:38.000
ドーナツ編集の経験はとても素晴らしかったので、トランザクションマネージャーで承認を押すことで新しい価格に同意します。

00:20:38.000 -> 00:20:45.000
XcodeでStoreKitを使用すると、値上げのような複雑なコーナーケースのテストが非常にスムーズになります。

00:20:45.000 -> 00:20:53.000
値上げをシミュレートする方法を見たので、StoreKitを使用してアプリの値上げを処理する方法を見てみましょう。

00:20:53.000 -> 00:21:00.000
値上げステータスをテストする場合、ステータス更新シーケンスは状態が変わるたびに新しい値を発行します。

00:21:00.000 -> 00:21:07.000
RenewalInfo値のpriceIncreaseStatusプロパティをチェックすることで、アプリでこれらの更新を検出できます。

00:21:07.000 -> 00:21:19.000
お客様が値上げのためにサブスクリプションをキャンセルした場合、expirthReasonプロパティでdidNotConsentToPriceIncreaseをチェックすることで、これを検出できます。

00:21:19.000 -> 00:21:23.000
また、テスト価格の上昇に関する単体テストを書くこともできます。

00:21:23.000 -> 00:21:31.000
まず、ダイアログを無効にすると、アプリの上にある値上げUIを実際に表示せずにテストできます。

00:21:31.000 -> 00:21:44.000
サブスクリプションを購入した後、requestPriceIncreaseConsentForTransaction APIを使用して、サブスクリプションの最新のトランザクションのIDを渡してプロセスを開始できます。

00:21:44.000 -> 00:21:52.000
テストトランザクションが値上げを保留していることを確認するために、isPendingPriceIncreaseConsentプロパティを確認します。

00:21:52.000 -> 00:22:06.000
最後に、テストしているものに応じて、同意ToPriceIncreaseForTransactionまたは declinePriceIncreaseForTransactionを呼び出すことで、アプリが終了した値上げケースにどのように反応するかを確認できます。

00:22:06.000 -> 00:22:09.000
価格の上昇をテストするのはそれだけです。

00:22:09.000 -> 00:22:14.000
値上げは、すべてのプラットフォームでXcode 13.3でテスト可能です。

00:22:14.000 -> 00:22:20.000
値上げメッセージは、iOS 15.4以降でのみテスト可能であることに注意してください。

00:22:20.000 -> 00:22:26.000
最後に、サブスクリプション請求の再試行と猶予期間を見てみましょう。

00:22:26.000 -> 00:22:33.000
請求の再試行は、期限切れのクレジットカードなど、サブスクリプションを更新しようとしたときにエラーが発生した状態です。

00:22:33.000 -> 00:22:41.000
App Storeでは、請求再試行中に、App Storeは問題の修正とサブスクリプションの回復を試みます。

00:22:41.000 -> 00:22:50.000
オプションで猶予期間を有効にすることができます。これにより、請求再試行状態の開始時に、期間限定でサブスクリプションを使用し続けることができます。

00:22:50.000 -> 00:22:54.000
Xcodeでテストするときにこれをシミュレートする方法を実演しましょう。

00:22:54.000 -> 00:23:08.000
サブスクリプション更新の請求問題をシミュレートするために、テストしているStoreKit構成の「エディタ」メニューを開き、「更新時に請求再試行」を有効にします。

00:23:08.000 -> 00:23:17.000
フードトラックに請求猶予期間をサポートしてもらいたいので、メニューでも「請求猶予期間」を有効にしましょう。

00:23:17.000 -> 00:23:28.000
サブスクリプションレートもスピードアップするので、状態がどのように変化するかを見ることができます。

00:23:28.000 -> 00:23:44.000
まず、ソーシャルフィード+を購読しましょう。

00:23:44.000 -> 00:23:51.000
さあ、更新の時期になるのを待ちましょう。

00:23:51.000 -> 00:23:57.000
トランザクションの有効期限が切れたら、最初に請求猶予期間の状態に入ることに注意してください。

00:23:57.000 -> 00:24:04.000
トランザクションインスペクタを見て、各州が終了する時間を確認できます。

00:24:04.000 -> 00:24:09.000
請求猶予期間が満了したばかりで、現在は標準の請求再試行状態です。

00:24:09.000 -> 00:24:17.000
いつでも「トランザクションの問題を解決する」ボタンを使用して、請求エラーの修正をシミュレートできます。

00:24:17.000 -> 00:24:22.000
問題の解決をテストしましょう。

00:24:22.000 -> 00:24:30.000
問題が解決したので、新しいトランザクションを取得します。

00:24:30.000 -> 00:24:41.000
「更新時の請求再試行」が有効になっている限り、新しいトランザクションごとに請求の再試行が引き続き入力されるため、このテストを何度でも繰り返すことができます。

00:24:41.000 -> 00:24:48.000
請求の再試行と猶予期間を適切に処理することは、不本意な解約を減らすことによって加入者を維持するための鍵です。

00:24:48.000 -> 00:24:56.000
Xcodeでこれらの状態をシミュレートするのがどれほど簡単かを見たので、StoreKitを使用してそれらを処理する方法を見ていきます。

00:24:56.000 -> 00:25:04.000
請求の再試行と猶予期間の状態が変更されると、ステータス更新シーケンスは新しい値を発行します。

00:25:04.000 -> 00:25:13.000
フードトラックでは請求猶予期間を提供しているため、猶予期間中に加入者にソーシャルフィード+へのアクセスを許可する必要があります。

00:25:13.000 -> 00:25:21.000
更新情報のgracePeriodExpirationDateプロパティを使用して、加入者の猶予期間を確認できます。

00:25:21.000 -> 00:25:27.000
請求の再試行を確認するには、isInBillingRetryを確認するだけです。

00:25:27.000 -> 00:25:33.000
また、ステータスの州のプロパティを使用して、これらの状態のいずれかを簡単に検出することもできます。

00:25:33.000 -> 00:25:41.000
お客様がこれらのいずれかの州にいる場合は、App Storeへのディープリンクに誘導して請求の問題を解決できます。

00:25:41.000 -> 00:25:50.000
現在のエンタイトルメントAPIを使用している場合は、猶予期間中に期限切れのサブスクリプションのトランザクションを受け取ります。

00:25:50.000 -> 00:26:03.000
また、BillingGracePeriodIsEnabledとStoreKitテストセッションでshouldEnterBillingRetryOnRenewalを設定することで、ユニットテストで請求の再試行と猶予期間を制御することもできます。

00:26:03.000 -> 00:26:12.000
アプリがサブスクリプションが請求の再試行に入ることに気付いた後、テストトランザクションのhasPurchaseIssueプロパティは真になります。

00:26:12.000 -> 00:26:24.000
さまざまなステータスの更新を待ち、期待どおりにアプリの更新をアサートした後、トランザクション方法の解決問題を使用して、サブスクリプションを回復するApp Storeをシミュレートすることができます。

00:26:24.000 -> 00:26:30.000
請求の再試行と猶予期間は、すべてのプラットフォームでXcode 13.3以降でテスト可能です。

00:26:30.000 -> 00:26:39.000
セッションの後半で、ピーターはiOSとiPadOS 16のサンドボックスでこれらの状態をテストする方法について詳しく説明します。

00:26:39.000 -> 00:26:45.000
払い戻しのリクエストから請求の再試行と猶予期間の処理まで、高度なテストケースをカバーしました。

00:26:45.000 -> 00:26:55.000
これらのケースの一部をサポートするために新しいStoreKit APIを使用する方法の詳細については、「アプリ内購入の新機能」をご覧ください。

00:26:55.000 -> 00:27:01.000
これは、今年のXcodeでのStoreKitテストの新機能の簡単な概要でしたが、すべてをカバーしたわけではありません。

00:27:01.000 -> 00:27:15.000
新しいサブスクリプション更新率があり、XcodeでStoreKit 2のアプリ内管理サブスクリプションシートをテストしたり、StoreKitTestを使用してSKAdNetwork実装の単体テストを書いたりできます。

00:27:15.000 -> 00:27:19.000
詳細については、「SKAdNetworkの新機能」をご覧ください。

00:27:19.000 -> 00:27:25.000
今、ピーターは今年のサンドボックステスト環境の新機能を説明します。

00:27:25.000 -> 00:27:26.000
ピーター:ありがとう、グレッグ。

00:27:26.000 -> 00:27:29.000
こんにちは、私はApp Storeサーバーエンジニアのピーターです。

00:27:29.000 -> 00:27:37.000
XcodeのStoreKitテストの新機能が、より複雑なアプリ内購入の実装をテストするのにどのように役立つかを見ました。

00:27:37.000 -> 00:27:46.000
私たちは常にあなたのフィードバックに耳を傾けており、あなたの多くがアプリ内購入とサーバーの実装をテストするためにApp Storeサンドボックス環境に依存していることを知っています。

00:27:46.000 -> 00:27:55.000
オンラインテスト環境でアプリとサーバーをより簡単にテストできるように、サンドボックスで行っている新しい機能強化を共有できることを嬉しく思います。

00:27:55.000 -> 00:28:04.000
Sandbox Apple IDの作成、App Store Connect API、および請求失敗シミュレーションの機能強化を導入します。

00:28:04.000 -> 00:28:11.000
サンドボックス環境を使用するには、まずApp Store ConnectでサンドボックスApple IDを設定する必要があります。

00:28:11.000 -> 00:28:18.000
サンドボックステスターリストをユーザーとアクセスページのナビゲーションバーに移動したことに気付くでしょう。

00:28:18.000 -> 00:28:22.000
ここでは、プラスボタンで新しいテスターを作成できます。

00:28:22.000 -> 00:28:27.000
新しいテスターウィンドウからいくつかのフィールドを削除して、作成プロセスを合理化しました。

00:28:27.000 -> 00:28:35.000
私たちは今、最小限の情報のみを求めているので、不要な情報なしでアカウントの作成を進めることができます。

00:28:35.000 -> 00:28:43.000
メールアドレスに「プラス記号」を使用することもできるので、テスターごとに新しいメールアドレスを作成する必要はありません。

00:28:43.000 -> 00:28:47.000
強力なパスワードの作成は面倒なことがわかっており、これも簡単にしました。

00:28:47.000 -> 00:28:53.000
また、パスワードをより安全にするためのインラインの提案も追加しました。

00:28:53.000 -> 00:29:03.000
合理化されたApple ID作成フォームと、より良いパスワードの複雑さのヒントが、アカウントの設定に費やす時間を減らし、アプリの開発により多くの時間を費やすのに役立つことを願っています。

00:29:03.000 -> 00:29:11.000
App Store Connectは、Sandbox Apple IDを作成および管理し、アプリのコンテンツと組織を管理する中心的な場所です。

00:29:11.000 -> 00:29:20.000
ここ数年、サンドボックスアカウントの地域の変更や購入履歴のクリアなど、あなたが求めていた機能をサンドボックスに追加してきました。

00:29:20.000 -> 00:29:27.000
これらの機能の多くは、App Store ConnectまたはSandbox Manage Subscriptionsページのデバイス上でアクセスできます。

00:29:27.000 -> 00:29:40.000
今年後半には、サンドボックスApple IDのリストの照会、購入履歴の消去、中断された購入状態の設定など、これらのサンドボックス機能のいくつかをApp Store Connect APIに持ち込む予定です。

00:29:40.000 -> 00:29:47.000
これにより、サンドボックスアカウントでのテストが高速化され、一般的に使用されるテストツールの自動化クライアントのセットアップに役立ちます。

00:29:47.000 -> 00:29:53.000
最後に、サンドボックスでの請求失敗シミュレーションのサポートを発表できることを嬉しく思います。

00:29:53.000 -> 00:30:01.000
2018年には、不本意な解約を減らすために、自動更新サブスクリプションの請求再試行と猶予期間を発表しました。

00:30:01.000 -> 00:30:09.000
2019年に開始されて以来、請求猶予期間により、顧客への3億日間の有料サービスを回収することができました。

00:30:09.000 -> 00:30:16.000
これにより、ビジネスの収益が増加し、顧客はサービスの中断を経験しません。

00:30:16.000 -> 00:30:28.000
多くの人がすでに本番環境で請求失敗のケースを処理していますが、Sandboxでより多くのテストシナリオを提供したいので、アプリがApp Storeで公開される前に請求失敗をテストして処理できます。

00:30:28.000 -> 00:30:48.000
新しいサンドボックスアカウント設定ページを使用して、アカウントの請求失敗シミュレーションを有効にし、アプリのコンテキストでフォアグラウンドおよびバックグラウンドサブスクリプションの失敗をテストし、サンドボックスのverifyReceipt、App Store Server API、およびApp Store Server Notifications V2でサブスクリプションステータスを確認できます。

00:30:48.000 -> 00:30:57.000
請求の再試行と不本意な解約の削減の詳細については、2018年のWWDCセッション「エンジニアリングサブスクリプション」をお勧めします。

00:30:57.000 -> 00:31:04.000
今年は、アプリ内購入の失敗をシミュレートするために、新しいサンドボックスアカウント設定にスイッチを導入します。

00:31:04.000 -> 00:31:08.000
これは、サンドボックスのサブスクリプションページの新しいホームでもあります。

00:31:08.000 -> 00:31:12.000
請求失敗シミュレーションを有効にすると、フォアグラウンドのアプリ内購入は失敗します。

00:31:12.000 -> 00:31:17.000
この動作は、顧客の支払い方法が拒否されたときの動作と一致します。

00:31:17.000 -> 00:31:25.000
請求失敗シミュレーションはまた、自動更新サブスクリプションの状態が本番環境での請求失敗の状態と一致することを保証します。

00:31:25.000 -> 00:31:30.000
これは、請求の問題を抱えている顧客のためにアプリ内メッセージをテストできることを意味します。

00:31:30.000 -> 00:31:37.000
これらのサブスクリプションの状態は、アプリ内購入の領収書に反映され、V2通知で確認されます。

00:31:37.000 -> 00:31:39.000
サブスクリプションのライフサイクルを確認しましょう。

00:31:39.000 -> 00:31:48.000
サンドボックスで自動更新サブスクリプションを購入すると、SUBSCRIBEDやDID_RENEWなどのV2通知がすでに届きます。

00:31:48.000 -> 00:31:55.000
アクティブなサブスクリプションを持つアカウントのアプリ内購入試行のテストに失敗すると、次の更新は請求再試行状態になります。

00:31:55.000 -> 00:32:01.000
これで、DID_FAIL_TO_RENEWのような請求再試行通知がサンドボックスで届きます。

00:32:01.000 -> 00:32:15.000
サブスクリプションの更新を回復しようとするのを停止する前に請求失敗シミュレーションを無効にすると、次の更新試行が成功し、サブタイプのBILLING_RECOVERYを含むDID_RENEW通知が届きます。

00:32:15.000 -> 00:32:26.000
再試行の制限に達し、請求失敗シミュレーションが有効になっている場合、サブスクリプションは期限切れになり、サブタイプBILLING_RETRYでEXPIREDを受け取ります。

00:32:26.000 -> 00:32:37.000
すでに本番環境で猶予期間を使用し、サンドボックスでV2通知を使用している場合は、GRACE_PERIODサブタイプでDID_FAIL_TO_RENEW通知を受け取ることが期待できます。

00:32:37.000 -> 00:32:41.000
以下は、猶予期間付きの請求再試行状態のサブスクリプションの例です。

00:32:41.000 -> 00:32:53.000
猶予期間の終了時に請求失敗シミュレーションがまだ有効になっている場合は、GRACE_PERIODのサブタイプのDID_FAIL_TO_RENEW通知とGRACE_PERIOD_EXPIREDが届きます。

00:32:53.000 -> 00:33:03.000
App Store Server APIでサブスクリプション情報を確認する場合、signedRenewalInfoのペイロードをデコードすることで、サブスクリプションの状態を確認できます。

00:33:03.000 -> 00:33:09.000
ここでは、expirthIntentフィールドと請求再試行フィールドが入力されていることがわかります。

00:33:09.000 -> 00:33:19.000
請求再試行状態のサブスクリプションの領収書で/verifyReceiptを呼び出すと、is_in_billing_retry_periodフラグが1に設定されていることがわかります。

00:33:19.000 -> 00:33:26.000
また、猶予期間を使用する場合、猶予期間の有効期限フィールドが入力されることを期待できるようになりました。

00:33:26.000 -> 00:33:32.000
サンドボックスでの請求失敗のテストが完了したら、サンドボックスアカウント設定でスイッチを無効にすることができます。

00:33:32.000 -> 00:33:38.000
この新しいテスト可能性が、お客様に可能な限り最高の体験を提供するのに役立つことを願っています。

00:33:38.000 -> 00:33:46.000
今日は、アプリのアプリ内購入機能のテストを合理化するために使用できるいくつかの新しいテスト機能について説明しました。

00:33:46.000 -> 00:33:56.000
App Store Connectで設定をXcodeと同期することで、ローカルまたはサンドボックス環境でテストするときに、同じアプリ内購入設定を使用できます。

00:33:56.000 -> 00:34:03.000
Xcodeでのオファーコードや払い戻しテストなどの新機能は、複雑なStoreKitの実装を検証するのに役立ちます。

00:34:03.000 -> 00:34:12.000
また、サブスクリプション管理のテスト可能性により、サービスが中断された場合でも、優れた顧客体験を確保するためにアプリを進化させることができます。

00:34:12.000 -> 00:34:26.000
請求の失敗がサブスクリプションの領収書にどのように影響するか、さらにサンドボックスのApp Store Server Notifications V2の詳細については、WWDC 21セッション「サーバーでアプリ内購入を管理する」をお勧めします。

00:34:26.000 -> 00:34:34.000
また、App Store Server APIとV2通知の新機能については、「アプリ内購入の新機能」をご覧ください。

00:34:34.000 -> 00:34:37.000
これらの新機能についてのご意見をお待ちしております。

00:34:37.000 -> 23:59:59.000
ご参加いただきありがとうございます。

