WEBVTT

00:00:00.000 -> 00:00:09.000
♪ ♪

00:00:09.000 -> 00:00:13.000
David Stites: こんにちは、「コアデータスキーマを進化させる」へようこそ。

00:00:13.000 -> 00:00:17.000
私の名前はDavid Stitesで、Core Dataチームのエンジニアです。

00:00:17.000 -> 00:00:24.000
このセッションでは、アプリのコアデータスキーマを更新および移行する方法についてお話しできることを嬉しく思います。

00:00:24.000 -> 00:00:41.000
このセッションの議題は、スキーマ移行とは何か、データモデルを更新した後にアプリが実行しなければならない理由、既存のスキーマを移行する方法、CloudKitとスキーマ移行がどのように相互作用するかを学ぶことです。

00:00:41.000 -> 00:00:49.000
まず、スキーマ移行とは何か、データモデルを更新するときにアプリを移行する必要がある理由。

00:00:49.000 -> 00:00:54.000
アプリケーションが進化するにつれて、データモデルを変更する必要があるかもしれません。

00:00:54.000 -> 00:01:00.000
データモデルを更新するには、これらの変更が基礎となるストレージスキーマで具体化される必要があります。

00:01:00.000 -> 00:01:02.000
このデータモデルを考えてみましょう。

00:01:02.000 -> 00:01:09.000
エンジンの種類と数の2つの属性を持つ航空機エンティティがあります。

00:01:09.000 -> 00:01:13.000
これらの属性は、基礎となるストレージに反映されます。

00:01:13.000 -> 00:01:20.000
多数の乗客属性を追加すると、対応するストレージを追加する必要があります。

00:01:20.000 -> 00:01:25.000
移行後、変更は基盤となるストレージに完全に反映されます。

00:01:25.000 -> 00:01:36.000
基礎となるストレージの変更を移行せずに、新しく変更されたモデルがストレージに使用されるモデルと一致しないため、Core Dataは永続的なストアを開くことを拒否します。

00:01:36.000 -> 00:01:45.000
互換性のないストアを開こうとすると、コードNSPersistentStore-IncompatibleVersionHashErrorでエラーが発生します。

00:01:45.000 -> 00:01:51.000
このエラーが表示された場合は、移行が必要であることを示す必要があります。

00:01:51.000 -> 00:01:59.000
スキーマ移行とは何か、なぜアプリを進化させるのに不可欠なのかを説明したので、移行がどのように達成されるかをお教えしましょう。

00:01:59.000 -> 00:02:08.000
Core Dataには、現在のデータモデルでアプリのデータストレージを最新の状態に保つためのデータ移行ツールが組み込まれています。

00:02:08.000 -> 00:02:14.000
総称して、これらのツールは「軽量移行」と呼ばれます。

00:02:14.000 -> 00:02:17.000
軽量移行は、移行の好ましい方法です。

00:02:17.000 -> 00:02:27.000
軽量移行は、ソースと宛先管理オブジェクトモデルの違いから移行を自動的に分析し、推測します。

00:02:27.000 -> 00:02:36.000
実行時に、Core Dataは、NSBundleクラスの.allBundlesおよび.allFrameworksメソッドによって返されるバンドル内のモデルを探します。

00:02:36.000 -> 00:02:45.000
その後、軽量移行は、データベーススキーマでアプリで行った変更を具体化するためのマッピングモデルを生成します。

00:02:45.000 -> 00:02:54.000
軽量移行を使用するには、明らかな移行パターンに合わせてデータモデルを変更する必要があります。

00:02:54.000 -> 00:03:11.000
属性を含む軽量操作には、属性の追加、属性の削除、オプション以外の属性のオプション化、オプション属性の非オプション化、デフォルト値の定義、属性の名前の変更などがあります。

00:03:11.000 -> 00:03:20.000
属性の名前を変更する場合は、宛先モデルの名前変更識別子をソースモデルの対応する属性の名前に設定します。

00:03:20.000 -> 00:03:26.000
名前変更識別子は、Xcode Data Model Editorのプロパティインスペクタにあります。

00:03:26.000 -> 00:03:32.000
たとえば、航空機エンティティのカラー属性の名前をペイントカラーに変更できます。

00:03:32.000 -> 00:03:43.000
名前変更識別子は正規名を作成するため、その属性にすでに名前変更識別子がない限り、名前変更識別子をソースモデルの属性の名前に設定します。

00:03:43.000 -> 00:03:50.000
これは、モデルのバージョン2で属性の名前を変更し、バージョン3で再び名前を変更できることを意味します。

00:03:50.000 -> 00:04:00.000
名前の変更は、バージョン2からバージョン3、またはバージョン1からバージョン3に正しく機能します。

00:04:00.000 -> 00:04:05.000
軽量の移行は、汗をかくことなく関係の変更を処理することもできます。

00:04:05.000 -> 00:04:10.000
新しい関係を追加したり、既存の関係を削除したりできます。

00:04:10.000 -> 00:04:16.000
属性と同じように、名前変更識別子を使用して関係の名前を変更することもできます。

00:04:16.000 -> 00:04:29.000
さらに、関係カーディナリティを変更できます。たとえば、a to-oneからa to-manyへの移行、または非順序付けられたto-manyへの移行、またはその逆です。

00:04:29.000 -> 00:04:34.000
エンティティも軽量移行の対象となると推測したなら、あなたは正しいです。

00:04:34.000 -> 00:04:40.000
新しいエンティティを追加したり、既存のエンティティを削除したり、エンティティの名前を変更したりできます。

00:04:40.000 -> 00:04:48.000
また、新しい親または子エンティティを作成し、エンティティ階層内で属性を上下に移動することもできます。

00:04:48.000 -> 00:04:53.000
エンティティを階層にまたは階層外に移動できます。

00:04:53.000 -> 00:04:56.000
ただし、エンティティ階層をマージすることはできません。

00:04:56.000 -> 00:05:03.000
2つの既存のエンティティがソースで共通の親を共有しない場合、宛先で共通の親を共有することはできません。

00:05:03.000 -> 00:05:16.000
軽量移行は、NSMigratePersistent-StoresAutomaticallyOptionとNSInferMappingModelAutomaticallyOptionの2つのオプションキーによって制御されます。

00:05:16.000 -> 00:05:31.000
ストアが永続コーディネーターに追加されたときにこれらの2つのキーの存在が真の値に設定されると、永続ストアが現在のモデルと一致しなくなったことを検出した場合、Core Dataは自動的に軽量移行を実行します。

00:05:31.000 -> 00:05:41.000
NSPersistentContainerまたはNSPersistentStoreDescriptionを使用している場合、これらのオプションは自動的に設定され、何もする必要はありません。

00:05:41.000 -> 00:06:08.000
NSPersistentStoreCoordinator .addPersistentStore (type:configuration:at:options:) などの代替 API を使用している場合、キーセット NSMigratePersistent- StoresAutomaticallyOption と NSInferMappingModelAutomaticallyOption を YES の値に設定して渡すことで、軽量移行を

00:06:08.000 -> 00:06:16.000
Core Dataは、永続ストアが現在のモデルと一致しなくなったことを検出すると、自動的に軽量移行を実行します。

00:06:16.000 -> 00:06:19.000
これがコードでどのように機能するかです。

00:06:19.000 -> 00:06:23.000
まず、CoreDataをインポートし、管理オブジェクトモデルを作成します。

00:06:23.000 -> 00:06:29.000
次に、先ほど作成したモデルを使用して、永続的なストアコーディネーターを作成します。

00:06:29.000 -> 00:06:36.000
私が作成したオプション辞書に注意してください。ストアを永続コーディネーターに追加するときに渡します。

00:06:36.000 -> 00:06:43.000
最後に、必要に応じて移行が自動的に行われるコーディネーターにストアを追加します。

00:06:43.000 -> 00:06:52.000
使用するAPIに関係なく、データモデルの変更は、アプリケーションに同梱されているのと同じモデルで直接行うことができます。

00:06:52.000 -> 00:06:56.000
変更を加えるためにモデルの新しいバージョンを作成する必要はありません。

00:06:56.000 -> 00:07:11.000
Core Data が実際に移行作業を行うことなく、ソースモデルと宛先モデル間のマッピング モデルを推測できるかどうかを事前に判断したい場合は、NSMappingModel .inferredMappingModel メソッドを使用できます。

00:07:11.000 -> 00:07:16.000
このメソッドは、Core Dataが作成できた場合、推論されたモデルを返します。

00:07:16.000 -> 00:07:19.000
それ以外の場合は、nilを返します。

00:07:19.000 -> 00:07:25.000
場合によっては、スキーマへの結合された変更は、軽量移行の機能を超える可能性があります。

00:07:25.000 -> 00:07:31.000
その問題に対処し、まだ軽量の移行を使用する方法を説明します。

00:07:31.000 -> 00:07:46.000
以前の例モデルに戻ると、FLIGHT_DATAに保存されているファイルパスによって示されるバイナリデータに外部ストレージを使用する「flightData」という属性を以前に追加したと仮定します。

00:07:46.000 -> 00:07:53.000
さらに、その属性を変更してデータを内部に保存し、外部ストレージを削除する必要があると仮定します。

00:07:53.000 -> 00:08:00.000
この移行が軽量移行の機能のいずれかに適合しているかどうかを確認すると、そうではないことが判明しました。

00:08:00.000 -> 00:08:05.000
一見すると、私たちは立ち往生していて、この変更を行うことができないようです。

00:08:05.000 -> 00:08:06.000
しかし、恐れるな!

00:08:06.000 -> 00:08:16.000
軽量移行は、複数のステップではありますが、より複雑で不適合な移行を実行するために引き続き使用できます。

00:08:16.000 -> 00:08:28.000
目標は、軽量移行の対象とならない移行タスクを、軽量移行の対象となる最小限の一連の移行に分解することです。

00:08:28.000 -> 00:08:46.000
一般的に、元のモデルがAで、目的モデルがBであるが、モデルBに軽量移行の対象とならない変更がある場合、それらの変更を分解する1つ以上のモデルバージョンを導入することでブリッジを作成できます。

00:08:46.000 -> 00:08:55.000
導入された各モデルには、不適合な変更を構成する機能の範囲内にある1つ以上の操作があります。

00:08:55.000 -> 00:09:05.000
これにより、一連の移行が発生し、各モデルは軽量で移行可能ですが、不適合の移行と同等になります。

00:09:05.000 -> 00:09:11.000
軽量移行の対象ではなかった私の例に戻ると、元のモデルはモデルAです。

00:09:11.000 -> 00:09:26.000
新しいモデルバージョン、Aプライムを導入してタスクの分解を開始し、外部ファイルからインポートされたデータを保存するために一時的に使用される新しい属性「tmpStorage」を追加します。

00:09:26.000 -> 00:09:31.000
次に、外部ファイルから新しい属性にデータをインポートします。

00:09:31.000 -> 00:09:37.000
このデータをインポートするコードは、Core Dataが提供する機能とは別です。

00:09:37.000 -> 00:09:42.000
このインポートの実行は、移行の間に介在しています。

00:09:42.000 -> 00:09:50.000
データが安全にインポートされたら、AプライムからモデルAダブルプライムの別の新しいバージョンを作成します。

00:09:50.000 -> 00:09:58.000
ダブルプライムでは、古い外部ストレージ属性を削除し、同時に新しい属性の名前を変更します。

00:09:58.000 -> 00:10:04.000
説明されているこれらの各ステップは、軽量移行の機能の範囲内です。

00:10:04.000 -> 00:10:19.000
直感的には、軽量移行オプションを設定して永続的なストアを開き、各未処理モデルをシリアルオーダーで反復的にステップスルーするイベントループを構築することができ、Core Dataはストアを移行します。

00:10:19.000 -> 00:10:34.000
前の例で外部ファイルからデータをインポートする方法など、移行中にアプリ固有のロジックを実行する場合、プロセスの終了により移行が中断された場合、そのロジックは「再スタート可能」でなければなりません。

00:10:34.000 -> 00:10:42.000
アプリがCore DataとCloudKitを使用している場合、Core Dataでデータモデルを設計する際に留意すべき重要なポイントがいくつかあります。

00:10:42.000 -> 00:10:51.000
コアデータストアとCloudKitデータベースの間でレコードを渡すには、データモデルに対する共通の理解が必要です。

00:10:51.000 -> 00:10:55.000
このモデルは、コアデータモデルエディタで定義します。

00:10:55.000 -> 00:10:59.000
そのモデルはその後、CloudKitスキーマを生成するために使用されます。

00:10:59.000 -> 00:11:07.000
生成されたスキーマは、最初に開発環境で作成され、その後プロダクションに昇格されます。

00:11:07.000 -> 00:11:12.000
CloudKitはコアデータモデルのすべての機能をサポートしていないことに注意する必要があります。

00:11:12.000 -> 00:11:18.000
モデルを設計する際には、次の制限事項を認識し、互換性のあるデータモデルを作成してください。

00:11:18.000 -> 00:11:23.000
たとえば、エンティティに対する一意の制約はサポートされていません。

00:11:23.000 -> 00:11:28.000
未定義とobjectIDの属性タイプは、属性タイプとしてサポートされていません。

00:11:28.000 -> 00:11:34.000
そして、関係はオプションでなければならず、逆の関係を持つ必要があります。

00:11:34.000 -> 00:11:38.000
さらに、CloudKitは削除拒否ルールをサポートしていません。

00:11:38.000 -> 00:11:43.000
アプリを開発する際には、開発環境を使用します。

00:11:43.000 -> 00:11:48.000
CloudKitスキーマは、この環境で自由に変更できます。

00:11:48.000 -> 00:11:54.000
ただし、スキーマをプロダクションに昇格した後、レコードタイプとそのフィールドは不変です。

00:11:54.000 -> 00:12:02.000
軽量移行は多くの異なるシナリオを処理しますが、CloudKitはサポートするものがより制限されています。

00:12:02.000 -> 00:12:07.000
先に説明した軽量操作の多くはサポートされていません。

00:12:07.000 -> 00:12:16.000
具体的には、CloudKitでサポートされているのは、既存のレコードタイプに新しいフィールドを追加し、新しいレコードタイプを追加することです。

00:12:16.000 -> 00:12:21.000
既存のレコードタイプやフィールドを変更または削除することはできません。

00:12:21.000 -> 00:12:26.000
モデルスキーマを変更するときは、これらの制限を考慮してください。

00:12:26.000 -> 00:12:35.000
データモデルを更新するときは、軽量移行はローカルストアファイルのスキーマ変更のみを具体化することに注意してください。

00:12:35.000 -> 00:12:45.000
特定のストアがCloudKitで使用されているかどうかにかかわらず、移行はディスク上のストアを変更するだけで、CloudKitスキーマは変更されません。

00:12:45.000 -> 00:12:58.000
スキーマ初期化子を実行し、CloudKitコンソールを使用して開発でそれらの変更を本番環境に昇格させることで、開発データベースでこれらの変更を具体化する必要があります。

00:12:58.000 -> 00:13:04.000
アプリのユーザーは、古いバージョンと新しいバージョンを使用することを覚えておいてください。

00:13:04.000 -> 00:13:09.000
アプリの最新バージョンは、もちろん、スキーマへの新しい追加について知っているでしょう。

00:13:09.000 -> 00:13:15.000
アプリの古いバージョンでは、新しいフィールドやレコードタイプについてはわかりません。

00:13:15.000 -> 00:13:24.000
CloudKitスキーマは本質的に付加的であるため、古いバージョンのアプリを実行しているデバイスへのスキーマ移行の影響を考慮してください。

00:13:24.000 -> 00:13:33.000
たとえば、一般的な落とし穴の1つは、アプリの古いバージョンでは使用しますが、新しいバージョンでは使用しない古いフィールドを更新するのを忘れることです。

00:13:33.000 -> 00:13:37.000
CloudKitスキーマを移行するための戦略をいくつか紹介します。

00:13:37.000 -> 00:13:43.000
最初のオプションは、既存のレコードタイプに新しいフィールドを段階的に追加することです。

00:13:43.000 -> 00:13:52.000
このアプローチを採用すると、アプリの古いバージョンは、ユーザーが作成したすべてのレコードにアクセスできますが、すべてのフィールドにはアクセスできません。

00:13:52.000 -> 00:14:04.000
2番目のオプションは、バージョン属性を含めてエンティティをバージョン化し、フェッチ要求を使用して、アプリの現在のバージョンと互換性のあるレコードのみを選択することです。

00:14:04.000 -> 00:14:15.000
このアプローチを採用すると、古いバージョンのアプリは、ユーザーがより新しいバージョンで作成したレコードを取得せず、そのデバイスに効果的に非表示にします。

00:14:15.000 -> 00:14:25.000
最後の戦略は、NSPersistentCloudKitContainerOptionsを使用してまったく新しいコンテナを作成し、新しいストアを新しいコンテナに関連付けることです。

00:14:25.000 -> 00:14:33.000
ユーザーが大きなデータセットを持っている場合、データセットをiCloudにアップロードするには長い時間がかかる可能性があることに注意してください。

00:14:33.000 -> 00:14:37.000
どのような方法を使用しても、データモデルの設計には注意してください。

00:14:37.000 -> 00:14:44.000
クロスバージョンの互換性の問題を考慮し、データモデルの異なるバージョンを一緒にテストしてください。

00:14:44.000 -> 00:14:51.000
データモデル、移行、CloudKitについて徹底的に議論したので、これを実際に実演します。

00:14:51.000 -> 00:14:54.000
推測かもしれませんが、私はパイロットです。

00:14:54.000 -> 00:14:57.000
飛行時間を記録するための小さなアプリを作成しました。

00:14:57.000 -> 00:14:59.000
これがそのアプリのデータモデルです。

00:14:59.000 -> 00:15:14.000
私は「LogEntry」と呼ばれる単一のエンティティを持っており、必要な経験情報を記録できるように、航空機の種類、飛行時間、出発地、目的地、尾行番号など、多くの属性を追加しました。

00:15:14.000 -> 00:15:21.000
このアプリケーションを初めて実行すると、Core Dataはストアを作成し、そのストアでスキーマを具体化します。

00:15:21.000 -> 00:15:34.000
アプリケーションを実行する前に、com.apple.CoreData.SQLDebugとcom.apple.CoreData.MigrationDebug環境変数をオンにします。

00:15:34.000 -> 00:15:37.000
これにより、Core Dataは実行している手順をログに記録します。

00:15:37.000 -> 00:15:42.000
これらの引数があれば、アプリを実行します。

00:15:42.000 -> 00:15:52.000
アプリが起動すると、Core Dataは、ファイルの作成、ストアのメタデータの作成、スキーマの具体化など、実行している手順を記録しています。

00:15:52.000 -> 00:15:56.000
SQLiteは、スキーマを含むテーブルZLOGENTRYを作成しました。

00:15:56.000 -> 00:16:02.000
これは、sqlite3コマンドラインツールを使用してストアファイルを見ることでも確認できます。

00:16:02.000 -> 00:16:10.000
ここにはLogEntryテーブルがあり、データモデルで作成した属性に対応する列があります。

00:16:10.000 -> 00:16:14.000
今、私はいくつかの軽量な変更を加えるつもりです。

00:16:14.000 -> 00:16:18.000
私はいくつかの新しいエンティティ、航空機、パイロット、空港を追加しています。

00:16:18.000 -> 00:16:21.000
これはスキーマを正規化するのに役立ちます。

00:16:21.000 -> 00:16:26.000
LogEntryエンティティの属性の一部を関係に変更しています。

00:16:26.000 -> 00:16:34.000
たとえば、宛先と原点が文字列属性から空港と1の関係に移行します。

00:16:34.000 -> 00:16:40.000
空港エンティティには、icaoIdentifierとfaaIdentifierの2つの新しい属性もあります。

00:16:40.000 -> 00:16:49.000
type属性は新しいエンティティに昇格されます。航空機と私は、tailNumberとregistrationNumberの2つの新しい属性を追加します。

00:16:49.000 -> 00:16:56.000
LogEntryでは、LogEntryから航空機との対1の関係を作成しています。

00:16:56.000 -> 00:17:02.000
最後に、名前と証明書IDを持つパイロットエンティティを追加しました。

00:17:02.000 -> 00:17:06.000
各ログエントリは、パイロットエンティティに関連付けられます。

00:17:06.000 -> 00:17:15.000
データモデルの変更が完了したので、アプリをもう一度実行します。

00:17:15.000 -> 00:17:19.000
おっと！アプリの実行中にエラーが発生しました。

00:17:19.000 -> 00:17:24.000
コードを調べると、NSPersistentStore- IncompatibleVersionHashErrorです。

00:17:24.000 -> 00:17:30.000
そのエラーは、私の現在のモデルがストア内のモデルのスキーマと一致しなくなったことを意味します。

00:17:30.000 -> 00:17:32.000
ストアスキーマを移行する必要があります。

00:17:32.000 -> 00:17:35.000
私は3つの方法のいずれかでそれを行うことができます。

00:17:35.000 -> 00:17:45.000
最初の方法を使用すると、軽量の移行オプションが自動的に設定されるため、コードをNSPersistentContainerを使用するように変換できます。

00:17:45.000 -> 00:17:55.000
2番目の方法を使用すると、軽量移行オプションが自動的に設定されるため、NSPersistentStoreDescriptionを使用できます。

00:17:55.000 -> 00:18:06.000
最後に、3番目の方法を使用して、オプション辞書で軽量移行オプションを手動で設定し、ストアを開くときにその辞書をコーディネーターに渡すことができます。

00:18:06.000 -> 00:18:11.000
NSPersistentContainerを使用して、最初のオプションで行こうと思います。

00:18:11.000 -> 00:18:32.000
NSPersistentContainerを使用するようにコードを変換したので、アプリを起動し、Core Dataがストアファイル内のスキーマを移行していることを再度観察します。

00:18:32.000 -> 00:18:36.000
繰り返しますが、これはsqlite3コマンドラインツールを使用して確認できます。

00:18:36.000 -> 00:18:42.000
新しいスキーマは、軽量の移行を使用して、Core Dataによって自動的に具体化されたことに注意してください。

00:18:42.000 -> 00:18:44.000
何がもっと簡単でしょうか?

00:18:44.000 -> 00:18:48.000
デモを終了する前に、オプション番号3を表示したかった。

00:18:48.000 -> 00:18:58.000
このオプションを思い出すと、オプション辞書で軽量移行オプションを手動で設定し、ストアを開くときにその辞書をコーディネーターに渡します。

00:18:58.000 -> 00:19:03.000
最終的な結果は、ストアが新しいスキーマに移行されるという点で同じです。

00:19:03.000 -> 00:19:07.000
データモデルを変更するときは、軽量の移行を使用してください。

00:19:07.000 -> 00:19:14.000
軽量移行は非常に柔軟で、大部分のデータモデルの変更に使いやすいです。

00:19:14.000 -> 00:19:22.000
より複雑なデータモデルがある場合は、そのモデルを軽量な変更で構成されたモデルに分解してください。

00:19:22.000 -> 00:19:29.000
最後に、アプリでCloudKitを使用する場合は、データモデルの変更の影響を慎重に検討してください。

00:19:29.000 -> 00:19:32.000
データモデルの変更を徹底的にテストします。

00:19:32.000 -> 00:19:40.000
この情報が役に立ち、プロジェクトのモデルを更新して素晴らしい新機能を構築することを検討することを願っています。

00:19:40.000 -> 23:59:59.000
私と一緒に飛んでくれてありがとう、そして素晴らしいWWDCをお過ごしください。

