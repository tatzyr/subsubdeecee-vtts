WEBVTT

00:00:00.000 -> 00:00:03.000
♪まろやかなインストゥルメンタルヒップホップ音楽♪

00:00:03.000 -> 00:00:09.000
♪

00:00:09.000 -> 00:00:13.000
みなさん、こんにちは、私はスウィフトコンパイラチームのホリーです。

00:00:13.000 -> 00:00:17.000
「Embrace Swift generics」へようこそ。

00:00:17.000 -> 00:00:26.000
ジェネリックは、Swiftで抽象的なコードを書くための基本的なツールであり、コードが進化するにつれて複雑さを管理するために不可欠です。

00:00:26.000 -> 00:00:31.000
抽象化は、アイデアを特定の詳細から分離します。

00:00:31.000 -> 00:00:36.000
コードでは、抽象化が役立つ方法はたくさんあります。

00:00:36.000 -> 00:00:45.000
常に使用している可能性のある抽象化の1つの形式は、コードを関数またはローカル変数に因数分解することです。

00:00:45.000 -> 00:00:51.000
これは、同じ機能や値を複数回使用する必要がある場合に本当に便利です。

00:00:51.000 -> 00:01:04.000
関数に機能を抽出すると、詳細が抽象化され、抽象化を使用するコードは、詳細を繰り返すことなく何が起こっているかという考えを表現することができます。

00:01:04.000 -> 00:01:09.000
Swiftでは、具体的なタイプを抽象化することもできます。

00:01:09.000 -> 00:01:18.000
異なる詳細を持つすべての同じアイデアであるタイプのセットがある場合は、それらの具体的なタイプのすべてで動作するように抽象的なコードを書くことができます。

00:01:18.000 -> 00:01:38.000
今日は、具体的なタイプでコードをモデリングし、一連の具体的なタイプの共通の機能を特定し、それらの機能を表すインターフェイスを構築し、最後に、そのインターフェイスを使用して一般的なコードを書くことに飛び込みます。

00:01:38.000 -> 00:01:44.000
ファームをシミュレートするためのコードを構築しながら、Swiftの抽象化ツールを掘り下げます。

00:01:44.000 -> 00:01:48.000
では、いくつかの具体的なタイプを書くことから始めましょう。

00:01:48.000 -> 00:01:50.000
「カウ」と呼ばれる1つの構造体から始めます。

00:01:50.000 -> 00:01:56.000
牛には、ヘイ型のパラメータを受け入れる「食べる」というメソッドがあります。

00:01:56.000 -> 00:01:58.000
干し草は別の構造体です。

00:01:58.000 -> 00:02:05.000
それは、アルファルファである干し草を生産する作物を育てるために「栽培」と呼ばれる静的な方法を持っています。

00:02:05.000 -> 00:02:10.000
アルファルファ構造体には、アルファルファの例から干し草を収穫する方法があります。

00:02:10.000 -> 00:02:16.000
最後に、牛に餌をやる方法を持つ「農場」と呼ばれる構造体を追加します。

00:02:16.000 -> 00:02:26.000
飼料方法は、最初に干し草を生産するためにいくつかのアルファルファを栽培し、次に干し草を収穫し、最後に牛に干し草を与えることによって実装することができます。

00:02:26.000 -> 00:02:30.000
そして今、私は農場で牛に餌をやることができます。

00:02:30.000 -> 00:02:34.000
しかし、私はより多くの種類の動物を追加したいです。

00:02:34.000 -> 00:02:39.000
馬や鶏のような他の動物を表すために、より多くの構造を追加することができます。

00:02:39.000 -> 00:02:46.000
そして、農場で牛、馬、鶏に餌をやれるようになりたいです。

00:02:46.000 -> 00:02:56.000
フィードメソッドをオーバーロードして、各タイプのパラメータを別々に受け入れることができますが、各オーバーロードには本当に同様の実装があります。

00:02:56.000 -> 00:03:04.000
より多くの種類の動物を追加すると、これは余分なボイラープレートになり、とにかくほとんどが繰り返されるコードです。

00:03:04.000 -> 00:03:11.000
反復的な実装で過負荷を書くことに気づいたら、それは一般化する兆候かもしれません。

00:03:11.000 -> 00:03:20.000
基本的に、異なる種類の動物が機能的に似ているため、これらの実装は非常に似ています。

00:03:20.000 -> 00:03:25.000
次のステップは、動物の種類間の共通の能力を特定することです。

00:03:25.000 -> 00:03:31.000
私たちは、あらゆる種類の食べ物を食べる能力を持つ動物タイプのセットを構築しました。

00:03:31.000 -> 00:03:40.000
動物の各タイプは異なる食べ方を持っているので、食べ方の各実装には行動の違いがあります。

00:03:40.000 -> 00:03:51.000
私たちがやりたいことは、抽象コードがeatメソッドを呼び出すことを可能にし、その抽象コードが動作している具体的なタイプに応じて異なる動作をすることです。

00:03:51.000 -> 00:03:58.000
抽象コードが具体的なタイプによって異なる動作をする能力は「多型」と呼ばれます。

00:03:58.000 -> 00:04:07.000
多相性により、コードの使用方法に応じて、1つのコードが多くの動作を持つことができます。

00:04:07.000 -> 00:04:12.000
適切に、多型自体はさまざまな形で来ます。

00:04:12.000 -> 00:04:20.000
1つ目は関数のオーバーロードで、同じ関数呼び出しは引数の種類によって異なる意味を持ちます。

00:04:20.000 -> 00:04:26.000
オーバーロードは、実際には一般的な解決策ではないため、「アドホック多型」と呼ばれています。

00:04:26.000 -> 00:04:30.000
オーバーロードがどのように反復的なコードにつながるかを見ました。

00:04:30.000 -> 00:04:41.000
次はサブタイプポリモーフィズムで、スーパータイプで動作するコードは、実行時にコードが使用している特定のサブタイプに基づいて異なる動作を持つことができます。

00:04:41.000 -> 00:04:47.000
最後に、ジェネリックを使用して達成されるパラメトリック多型があります。

00:04:47.000 -> 00:04:58.000
汎用コードは、型パラメータを使用して、異なる型で動作する1つのコードを書き込むことができ、具体的な型自体が引数として使用されます。

00:04:58.000 -> 00:05:04.000
すでに過負荷を除外したので、サブタイプ多型を使ってみましょう。

00:05:04.000 -> 00:05:10.000
サブタイプ関係を表す1つの方法は、クラス階層です。

00:05:10.000 -> 00:05:14.000
「動物」というクラスを紹介することができます。

00:05:14.000 -> 00:05:19.000
次に、各動物の種類を構造体からクラスに変更します。

00:05:19.000 -> 00:05:27.000
各特定の動物クラスは、動物のスーパークラスを継承し、食べる方法を上書きします。

00:05:27.000 -> 00:05:35.000
今、私たちはすべての特定の動物タイプを表すことができる抽象的なベースクラスの動物を持っています。

00:05:35.000 -> 00:05:43.000
Animalクラスでeatを呼び出すコードは、サブタイプ多型を使用してサブクラスの実装を呼び出します。

00:05:43.000 -> 00:05:44.000
しかし、私たちはまだ終わっていません。

00:05:44.000 -> 00:05:52.000
私たちはまだAnimalのeatメソッドのパラメータタイプを記入しておらず、このコードには他にもいくつかの赤旗があります。

00:05:52.000 -> 00:06:04.000
まず、クラスを使用すると、異なる動物のインスタンス間で状態を共有する必要がない、または共有したくない場合でも、参照セマンティクスを余儀なくされました。

00:06:04.000 -> 00:06:13.000
この戦略では、サブクラスが基本クラスのメソッドを上書きすることも必要ですが、これを行うのを忘れることはランタイムまでキャッチされません。

00:06:13.000 -> 00:06:26.000
しかし、この抽象化モデルのより大きな問題は、各動物のサブタイプが異なる種類の食物を食べることであり、この依存性はクラス階層で表現するのが本当に困難です。

00:06:26.000 -> 00:06:33.000
私たちが取ることができる1つのアプローチは、メソッドにAnyのようなあまり具体的ではないタイプを受け入れてもらうことです。

00:06:33.000 -> 00:06:40.000
しかし、この戦略は、実行時に正しい型が渡されたことを確認するために、サブクラスの実装に依存しています。

00:06:40.000 -> 00:06:53.000
そのため、オーバーライドされた各方法で余分なボイラープレートを課しましたが、さらに重要なことに、誤って間違った種類の食品を渡すことができ、実行時にしかキャッチできない別のバグが残ります。

00:06:53.000 -> 00:06:56.000
では、何か他のことを試してみましょう。

00:06:56.000 -> 00:07:06.000
代わりに、動物のスーパークラスにタイプパラメータを導入することで、動物の飼料タイプをタイプセーフな方法で表現することができます。

00:07:06.000 -> 00:07:13.000
このタイプパラメータは、各サブクラスの特定のフィードタイプのプレースホルダとして機能します。

00:07:13.000 -> 00:07:20.000
このアプローチでは、食品タイプのパラメータを動物クラスの宣言に昇格させる必要があります。

00:07:20.000 -> 00:07:33.000
動物は操作するために食べ物を必要としますが、食べ物を食べることは動物の中核的な目的ではなく、動物で動作する多くのコードはおそらく食べ物をまったく気にしないので、これは少し不自然に思えます。

00:07:33.000 -> 00:07:39.000
それにもかかわらず、動物クラスへのすべての参照は、食品の種類を指定する必要があります。

00:07:39.000 -> 00:07:48.000
たとえば、各動物サブクラスは、継承句の角括弧で食品タイプを明示的に指定する必要があります。

00:07:48.000 -> 00:07:58.000
動物クラスの各使用サイトのこのボイラープレートは、各動物に固有のタイプを追加すると、面倒になる可能性があります。

00:07:58.000 -> 00:08:04.000
だから、ここでの私たちのアプローチはどれも良い人間工学や適切な意味論を持っていません。

00:08:04.000 -> 00:08:15.000
根本的な問題は、クラスがデータ型であり、スーパークラスを複雑化して、具体的なタイプに関する抽象的なアイデアを表すようにすることです。

00:08:15.000 -> 00:08:26.000
代わりに、機能がどのように機能するかの詳細なしに、タイプの機能を表すように設計された言語構造が必要です。

00:08:26.000 -> 00:08:29.000
動物には2つの共通の能力があります。

00:08:29.000 -> 00:08:36.000
各動物は、その食品の一部を消費するための操作とともに、特定の種類の食品を持っています。

00:08:36.000 -> 00:08:41.000
これらの機能を表すインターフェースを構築できます。

00:08:41.000 -> 00:08:44.000
Swiftでは、これはプロトコルを使用して行われます。

00:08:44.000 -> 00:08:52.000
プロトコルは、適合型の機能を記述する抽象化ツールです。

00:08:52.000 -> 00:08:59.000
プロトコルを使用すると、タイプが何をするかについてのアイデアを実装の詳細から分離できます。

00:08:59.000 -> 00:09:04.000
タイプが何をするかについてのアイデアは、インターフェイスを通じて表現されます。

00:09:04.000 -> 00:09:10.000
動物の機能をプロトコルインターフェースに翻訳しましょう。

00:09:10.000 -> 00:09:17.000
プロトコルの名前は、私たちが説明しているタイプのカテゴリを表しているので、私はこのプロトコルを「動物」と呼びました。

00:09:17.000 -> 00:09:21.000
各機能はプロトコル要件にマッピングされます。

00:09:21.000 -> 00:09:28.000
特定の種類の食品は、関連するタイプの動物プロトコルにマッピングされます。

00:09:28.000 -> 00:09:34.000
型パラメータと同様に、関連する型は具体的な型のプレースホルダとして機能します。

00:09:34.000 -> 00:09:40.000
関連するタイプを特別なものにしているのは、プロトコルに準拠した特定のタイプに依存することです。

00:09:40.000 -> 00:09:49.000
この関係は保証されているので、特定の種類の動物の各インスタンスは常に同じ種類の食べ物を持っています。

00:09:49.000 -> 00:09:55.000
次に、食品を消費する操作は、方法にマッピングされます。

00:09:55.000 -> 00:10:00.000
この方法は「食べる」と呼ばれ、動物の飼料タイプのパラメータを受け入れます。

00:10:00.000 -> 00:10:08.000
プロトコルにはこの方法の実装がなく、実装には具体的な動物タイプが必要です。

00:10:08.000 -> 00:10:14.000
動物プロトコルがわかったので、それぞれの具体的な動物タイプをそれに適合させることができます。

00:10:14.000 -> 00:10:22.000
宣言または拡張でプロトコル適合性を持つ具体的なタイプに注釈を付けることができます。

00:10:22.000 -> 00:10:29.000
プロトコルはクラスに限定されないため、構造体、列挙型、アクターを含むプロトコルも使用できます。

00:10:29.000 -> 00:10:38.000
この適合性アノテーションを書くと、コンパイラは具体的な型が各プロトコル要件を実装していることを確認します。

00:10:38.000 -> 00:10:48.000
各動物タイプはeatメソッドを実装する必要があり、コンパイラはパラメータリストで使用されるため、フィードタイプが何であるかを推測できます。

00:10:48.000 -> 00:10:54.000
フィードタイプは、タイプエイリアスを使用して明示的に書き込むこともできます。

00:10:54.000 -> 00:11:02.000
私たちは、動物の共通の能力をうまく特定し、プロトコルインターフェースを使用してそれらの能力を表現しました。

00:11:02.000 -> 00:11:06.000
今、私たちは一般的なコードを書き始めることができます。

00:11:06.000 -> 00:11:10.000
動物プロトコルを使用して、農場で飼料方法を実装することができます。

00:11:10.000 -> 00:11:15.000
私たちは、すべての具体的な動物タイプで動作する1つの実装を書きたい。

00:11:15.000 -> 00:11:25.000
パラメトリック多型を使用し、メソッドが呼び出されたときに具体的な型に置き換えられる型パラメータを導入します。

00:11:25.000 -> 00:11:30.000
型パラメータは、関数名の後に角括弧で記述されます。

00:11:30.000 -> 00:11:37.000
通常の変数や関数パラメータと同様に、タイプパラメータに好きな名前を付けることができます。

00:11:37.000 -> 00:11:44.000
そして、他のタイプと同様に、その名前を使用して、関数の署名全体でtypeパラメータを参照できます。

00:11:44.000 -> 00:11:51.000
ここでは、「A」という型パラメータを宣言し、動物関数パラメータの型としてAを使用しました。

00:11:51.000 -> 00:12:00.000
私たちは常に具体的な動物タイプが動物プロトコルに準拠していることを望んでいるので、プロトコル適合性でタイプパラメータに注釈を付けます。

00:12:00.000 -> 00:12:13.000
プロトコル適合性は、山括弧で書くことも、末尾の「where」句で書くこともできます。ここでは、異なる型パラメータ間の関係を指定することもできます。

00:12:13.000 -> 00:12:22.000
名前付き型パラメータと末尾の「where」句は、洗練された要件と型関係を書くことができるため、本当に強力です。

00:12:22.000 -> 00:12:26.000
しかし、ほとんどの一般的な機能は、この一般性を必要としません。

00:12:26.000 -> 00:12:29.000
フィード方法に焦点を当てましょう。

00:12:29.000 -> 00:12:39.000
型パラメータAはパラメータリストに一度表示され、「where」句は型パラメータの適合要件を一覧表示します。

00:12:39.000 -> 00:12:46.000
この場合、型パラメータに名前を付け、「where」句を使用すると、メソッドが実際よりも複雑に見えます。

00:12:46.000 -> 00:12:52.000
この一般的なパターンは本当に一般的なので、それを表現する簡単な方法があります。

00:12:52.000 -> 00:13:03.000
型パラメータを明示的に書く代わりに、「some Animal」と書くことで、この抽象型をプロトコル適合性の観点から表現できます。

00:13:03.000 -> 00:13:14.000
この宣言は前の宣言と同じですが、それらが提供する表現力を必要としなかったため、不要な型パラメータリストと「where」句はなくなりました。

00:13:14.000 -> 00:13:27.000
「いくつかの動物」を書くことは、構文ノイズを減らし、パラメータ宣言に動物パラメータに関する意味情報が含まれているため、より簡単です。

00:13:27.000 -> 00:13:30.000
動物の構文を分解しましょう。

00:13:30.000 -> 00:13:37.000
「Some Animal」の「some」は、あなたが作業している特定のタイプがあることを示しています。

00:13:37.000 -> 00:13:42.000
「Some」キーワードの後には常に適合要件が続きます。

00:13:42.000 -> 00:13:52.000
この場合、特定のタイプはAnimalプロトコルに準拠する必要があります。これにより、Animalプロトコルの要件をパラメータ値に使用できます。

00:13:52.000 -> 00:13:56.000
「Some」キーワードは、パラメータと結果タイプで使用できます。

00:13:56.000 -> 00:14:05.000
以前にSwiftUIコードを書いたことがある場合は、すでに「some View」を使用して結果位置に「some」を使用しています。

00:14:05.000 -> 00:14:10.000
「いくつかのビュー」の結果タイプはまったく同じ概念です。

00:14:10.000 -> 00:14:21.000
SwiftUIビューでは、ボディプロパティは特定のタイプのビューを返しますが、ボディプロパティを使用するコードは、特定のタイプが何であるかを知る必要はありません。

00:14:21.000 -> 00:14:28.000
特定の抽象的なタイプの概念をよりよく理解するために、一歩下がってみましょう。

00:14:28.000 -> 00:14:36.000
特定の具体的なタイプのプレースホルダを表す抽象型は、不透明な型と呼ばれます。

00:14:36.000 -> 00:14:42.000
置換される特定のコンクリートタイプは、基礎となるタイプと呼ばれます。

00:14:42.000 -> 00:14:48.000
不透明な型の値の場合、基礎となる型は値のスコープに対して固定されます。

00:14:48.000 -> 00:14:57.000
このようにして、値を使用するジェネリックコードは、値にアクセスするたびに同じ基礎となる型を取得することが保証されます。

00:14:57.000 -> 00:15:05.000
「Some」キーワードと山括弧内の名前付きtypeパラメータを使用する型は、どちらも不透明な型を宣言します。

00:15:05.000 -> 00:15:15.000
不透明な型は、入力と出力の両方に使用できるため、パラメータ位置または結果位置で宣言できます。

00:15:15.000 -> 00:15:19.000
関数の矢印は、これらの位置の境界線です。

00:15:19.000 -> 00:15:30.000
不透明なタイプの位置は、プログラムのどの部分が抽象タイプを見て、プログラムのどの部分が具体的なタイプを決定するかを決定します。

00:15:30.000 -> 00:15:41.000
名前付き型パラメータは常に入力側で宣言されるため、呼び出し先が基礎となる型を決定し、実装は抽象型を使用します。

00:15:41.000 -> 00:15:53.000
一般に、不透明なパラメータまたは結果タイプの値を提供するプログラムの一部が基礎となるタイプを決定し、値を使用するプログラムの一部は抽象タイプを見ます。

00:15:53.000 -> 00:16:00.000
パラメータと結果値に関する直感に従って、これがどのように機能するかを掘り下げてみましょう。

00:16:00.000 -> 00:16:09.000
基礎となる型は値から推測されるため、基礎となる型は常に値と同じ場所から来ています。

00:16:09.000 -> 00:16:16.000
ローカル変数の場合、基礎となる型は代入の右側の値から推測されます。

00:16:16.000 -> 00:16:27.000
これは、不透明な型のローカル変数が常に初期値を持たなければならないことを意味します。そして、あなたがそれを提供しない場合、コンパイラはエラーを報告します。

00:16:27.000 -> 00:16:37.000
基礎となるタイプは変数のスコープに合わせて固定する必要があるため、基礎となるタイプを変更しようとするとエラーも発生します。

00:16:37.000 -> 00:16:44.000
不透明なタイプのパラメータの場合、基礎となるタイプはコールサイトの引数値から推測されます。

00:16:44.000 -> 00:16:50.000
パラメータ位置に「some」を使用することは、Swift 5.7では新しいことです。

00:16:50.000 -> 00:16:58.000
基礎となるタイプは、パラメータのスコープに対してのみ固定する必要があるため、各呼び出しは異なる引数タイプを提供できます。

00:16:58.000 -> 00:17:05.000
不透明な結果型の場合、基礎となる型は実装の戻り値から推測されます。

00:17:05.000 -> 00:17:15.000
不透明な結果型を持つメソッドまたは計算されたプロパティは、プログラム内のどこからでも呼び出すことができるので、この名前付き値の範囲はグローバルです。

00:17:15.000 -> 00:17:28.000
これは、基礎となるリターンタイプがすべてのリターンステートメントで同じでなければならないことを意味します。そうでない場合、コンパイラは基礎となるリターン値の型が一致しないというエラーを報告します。

00:17:28.000 -> 00:17:38.000
不透明なSwiftUIビューの場合、ViewBuilder DSLはコントロールフローステートメントを変換して、ブランチごとに同じ基礎となるリターンタイプを持つことができます。

00:17:38.000 -> 00:17:43.000
したがって、この場合、ViewBuilder DSLを使用して問題を解決できます。

00:17:43.000 -> 00:17:53.000
メソッドに@ViewBuilderアノテーションを書き、リターンステートメントを削除すると、ViewBuilderタイプによって結果が構築されます。

00:17:53.000 -> 00:17:56.000
feedAnimalメソッドに戻りましょう。

00:17:56.000 -> 00:18:02.000
他の場所で不透明なタイプを参照する必要がないため、パラメータリストで「一部」を使用できます。

00:18:02.000 -> 00:18:11.000
関数シグネチャで不透明なタイプを複数回参照する必要がある場合は、名前タイプのパラメータが便利です。

00:18:11.000 -> 00:18:23.000
たとえば、「ハビタット」と呼ばれる動物プロトコルに別の関連タイプを追加すると、特定の動物の農場に生息地を構築できるようになるかもしれません。

00:18:23.000 -> 00:18:34.000
この場合、結果タイプは特定の動物タイプに依存するため、パラメータタイプとリターンタイプにタイプパラメータAを使用する必要があります。

00:18:34.000 -> 00:18:41.000
不透明なタイプを複数回参照する必要があるもう1つの一般的な場所は、ジェネリックタイプです。

00:18:41.000 -> 00:18:52.000
コードは、多くの場合、ジェネリック型に型パラメータを宣言し、格納されたプロパティに型パラメータを使用し、再びメンバーワイズ初期化子で宣言します。

00:18:52.000 -> 00:19:01.000
異なるコンテキストでジェネリック型を参照するには、型パラメータを角括弧で明示的に指定する必要があります。

00:19:01.000 -> 00:19:12.000
宣言の山括弧は、ジェネリック型の使用方法を明確にするのに役立つため、不透明な型は常にジェネリック型に名前を付ける必要があります。

00:19:12.000 -> 00:19:15.000
では、フィードメソッドの実装を構築しましょう。

00:19:15.000 -> 00:19:23.000
動物パラメータのタイプを使用して、飼料関連タイプを介して成長する作物タイプにアクセスできます。

00:19:23.000 -> 00:19:28.000
Feed.grow() を呼び出して、このタイプのフィードを生成する作物のインスタンスを取得します。

00:19:28.000 -> 00:19:36.000
次に、作物から農産物を収穫する必要があります。これは、「収穫」と呼ばれる作物タイプによって提供されるメソッドを呼び出すことによって行うことができます。

00:19:36.000 -> 00:19:39.000
そして最後に、私たちはこの農産物を動物に与えることができます。

00:19:39.000 -> 00:19:50.000
基礎となる動物型は固定されているため、コンパイラは、さまざまなメソッド呼び出しにわたる植物型、農産物型、および動物型の関係を知っています。

00:19:50.000 -> 00:19:58.000
これらの静的な関係は、私たちが動物に間違った種類の食べ物を与えるという間違いを犯すのを防ぎます。

00:19:58.000 -> 00:20:07.000
この動物の正しい食品タイプであることが保証されていないタイプを使用しようとすると、コンパイラが教えてくれます。

00:20:07.000 -> 00:20:18.000
動物飼料タイプとその植物の関係を表現するために、他の農場プロトコルがどのように作られたかを学ぶには、「Swiftでプロトコルインターフェイスを設計する」をチェックしてください。

00:20:18.000 -> 00:20:23.000
最後に、すべての動物に餌をやる方法を追加しましょう。

00:20:23.000 -> 00:20:26.000
配列を受け入れるfeedAllというメソッドを追加します。

00:20:26.000 -> 00:20:35.000
要素タイプが動物プロトコルに準拠する必要があることは知っていますが、配列がさまざまな種類の動物を保存できるようにしたいです。

00:20:35.000 -> 00:20:39.000
動物がここで私たちを助けることができるかどうか見てみましょう。

00:20:39.000 -> 00:20:44.000
「いくつか」には、変化できない特定の基礎となるタイプがあります。

00:20:44.000 -> 00:20:51.000
基礎となる型は固定されているため、配列内のすべての要素が同じ型を持つ必要があります。

00:20:51.000 -> 00:20:59.000
だから、私は異なる動物の種類を保持できる配列が欲しいので、いくつかの動物の配列は正しいことを表現しません。

00:20:59.000 -> 00:21:04.000
ここでは、あらゆる種類の動物を表現できるスーパータイプが本当に必要です。

00:21:04.000 -> 00:21:11.000
「どんな動物でも」と書くことで、任意の種類の動物を表現することができます。

00:21:11.000 -> 00:21:21.000
「Any」キーワードは、このタイプが任意のタイプの動物を保存でき、基礎となる動物の種類が実行時に異なる可能性があることを示しています。

00:21:21.000 -> 00:21:28.000
「Some」キーワードと同様に、「any」キーワードには常に適合要件が続きます。

00:21:28.000 -> 00:21:40.000
任意の動物は、任意の具体的な動物タイプを動的に格納する機能を持つ単一の静的型であり、値型のサブタイプ多型を使用することができます。

00:21:40.000 -> 00:21:48.000
この柔軟なストレージを可能にするために、どの動物タイプもメモリに特別な表現を持っています。

00:21:48.000 -> 00:21:52.000
この表現は箱のように考えることができます。

00:21:52.000 -> 00:21:57.000
時々、値は箱の中に直接収まるほど小さいです。

00:21:57.000 -> 00:22:06.000
また、他の値はボックスには大きすぎるので、値を他の場所に割り当てる必要があるため、ボックスはその値へのポインタを格納します。

00:22:06.000 -> 00:22:16.000
任意の具体的な動物タイプを動的に格納できる動物の静的タイプは、正式には実存タイプと呼ばれます。

00:22:16.000 -> 00:22:23.000
そして、異なる具体的なタイプに同じ表現を使用する戦略は「タイプ消去」と呼ばれます。

00:22:23.000 -> 00:22:30.000
コンクリートタイプはコンパイル時に消去されると言われ、コンクリートタイプは実行時にのみ知られています。

00:22:30.000 -> 00:22:38.000
実存タイプのこれら2つのインスタンスは、どの動物も同じ静的タイプですが、動的タイプは異なります。

00:22:38.000 -> 00:22:51.000
タイプ消去は、異なる動物値間のタイプレベルの区別を排除し、異なる動的タイプの値を同じ静的タイプとして交換可能に使用できるようにします。

00:22:51.000 -> 00:23:00.000
型消去を使用して、値型の異種配列を書くことができます。これはまさにfeedAllメソッドに望むものです。

00:23:00.000 -> 00:23:04.000
したがって、任意の動物の配列をパラメータタイプとして使用します。

00:23:04.000 -> 00:23:11.000
関連するタイプのプロトコルに「any」キーワードを使用することは、Swift 5.7で新しく追加されたものです。

00:23:11.000 -> 00:23:17.000
feedAllメソッドを実装するには、まず動物の配列を反復します。

00:23:17.000 -> 00:23:22.000
動物ごとに、動物のプロトコルから食べる方法を呼び出したい。

00:23:22.000 -> 00:23:29.000
このメソッドを呼び出すには、この反復で基礎となる動物の特定の飼料タイプを取得する必要があります。

00:23:29.000 -> 00:23:35.000
しかし、任意の動物で食べるとすぐに、コンパイラエラーが発生します。

00:23:35.000 -> 00:23:48.000
特定の動物タイプ間のタイプレベルの区別を排除したため、関連するタイプを含む特定の動物タイプに依存するすべてのタイプ関係も排除しました。

00:23:48.000 -> 00:23:53.000
だから、この動物がどんな種類の飼料を期待しているかはわかりません。

00:23:53.000 -> 00:24:00.000
タイプ関係に頼るには、特定のタイプの動物が固定されているコンテキストに戻る必要があります。

00:24:00.000 -> 00:24:08.000
任意の動物に直接食べるを呼び出す代わりに、いくつかの動物を受け入れる飼料方法を呼び出す必要があります。

00:24:08.000 -> 00:24:24.000
現在、任意のAnimalは一部のAnimalとは異なるタイプですが、コンパイラは、基礎となる値をボックス化解除して一部のAnimalパラメータに直接渡すことで、AnimalのインスタンスをAnimalに変換できます。

00:24:24.000 -> 00:24:30.000
この開梱引数の機能は、Swift 5.7で新しいものです。

00:24:30.000 -> 00:24:37.000
ボックス化解除は、コンパイラがボックスを開き、内部に格納されている値を取り出すと考えることができます。

00:24:37.000 -> 00:24:51.000
一部のAnimalパラメータの範囲では、値は固定された基礎となる型を持つため、関連する型へのアクセスを含む、基礎となる型に関するすべての操作にアクセスできます。

00:24:51.000 -> 00:25:07.000
これは、必要なときに柔軟なストレージを選択できると同時に、関数の範囲の基礎となるタイプを修正することで、静的タイプシステムの完全な表現力を持つコンテキストに戻ることができるため、本当にクールです。

00:25:07.000 -> 00:25:20.000
そして、ほとんどの場合、Animalでプロトコルメソッドを呼び出すことが実際に基礎となるタイプのメソッドを呼び出すのと同様に、期待どおりに機能するため、ボックス化解除について考える必要はありません。

00:25:20.000 -> 00:25:31.000
したがって、各動物を飼料方法に渡すことができ、各反復で特定の動物に餌を与えるために適切な作物を栽培して収穫することができます。

00:25:31.000 -> 00:25:38.000
このプロセスを通して、私たちは「いくつか」と「どれでも」が異なる能力を持っているのを見てきました。

00:25:38.000 -> 00:25:42.000
「いくつか」では、基礎となるタイプが固定されています。

00:25:42.000 -> 00:25:54.000
これにより、ジェネリックコードの基礎となるタイプへのタイプ関係に頼ることができるため、作業中のプロトコルのAPIと関連タイプに完全にアクセスできます。

00:25:54.000 -> 00:25:59.000
任意の具体的なタイプを格納する必要がある場合は、「any」を使用してください。

00:25:59.000 -> 00:26:12.000
「Any」は型消去を提供します。これにより、異種コレクションを表現し、基礎となる型の欠如を表し、オプションを使用し、抽象化を実装の詳細にします。

00:26:12.000 -> 00:26:20.000
一般に、デフォルトで「some」と書き、任意の値を保存する必要があることがわかっている場合は、「some」を「any」に変更します。

00:26:20.000 -> 00:26:30.000
このアプローチでは、タイプ消去のコストとその意味的な制限は、それが提供するストレージの柔軟性が必要な場合にのみ支払うことができます。

00:26:30.000 -> 00:26:36.000
このワークフローは、突然変異が必要であることがわかるまで、デフォルトでlet-constantsを書くのと似ています。

00:26:36.000 -> 00:26:44.000
このセッションでは、コードが進化し、より多くの機能を得るにつれて、コードを一般化するワークフローを説明しました。

00:26:44.000 -> 00:26:47.000
私たちは具体的なタイプを書くことから始めました。

00:26:47.000 -> 00:26:54.000
コードがより多くの機能を得るにつれて、私たちは異なる具体的なタイプ間の繰り返しに気づきました。

00:26:54.000 -> 00:27:00.000
そこから、共通の機能を特定し、プロトコルを使用して一般化しました。

00:27:00.000 -> 00:27:09.000
最後に、「some」と「any」を使用して抽象的なコードを書き、より表現力豊かなコードのために「some」を好むことについて話し合いました。

00:27:09.000 -> 00:27:18.000
プロトコルの作成とタイプの消去の理解を深く掘り下げるには、「Swiftでプロトコルインターフェイスを設計する」をチェックしてください。

00:27:18.000 -> 00:27:21.000
参加してくれてありがとう、素晴らしいWWDCをお過ごしください。

00:27:21.000 -> 23:59:59.000
♪

