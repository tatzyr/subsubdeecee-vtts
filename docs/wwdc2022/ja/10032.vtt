WEBVTT

00:00:00.000 --> 00:00:03.000
♪まろやかなインストゥルメンタルヒップホップ音楽♪

00:00:03.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:13.000
こんにちは、皆さん。私の名前はショートカットエンジニアリングのマイケル・ゴーバックです。

00:00:13.000 --> 00:00:22.000
アプリの機能をシステムに公開するための新しいフレームワークであるApp Intentsを深く掘り下げていただきありがとうございます。

00:00:22.000 --> 00:00:24.000
これが私たちのダイビングの計画です。

00:00:24.000 --> 00:00:31.000
簡単な紹介の後、意図とそのパラメータ、およびエンティティを定義する方法について説明します。

00:00:31.000 --> 00:00:38.000
構築できる強力な検索とフィルタリング機能、および意図がユーザーとどのようにやり取りできるかについて説明します。

00:00:38.000 --> 00:00:43.000
最後に、App Intentsのアーキテクチャとライフサイクルについて説明します。

00:00:43.000 --> 00:00:45.000
最初から始めましょう。

00:00:45.000 --> 00:00:56.000
iOS 10では、メッセージング、ワークアウト、支払いなどのSiriドメインにアプリの機能を接続できるSiriKit Intentsフレームワークを導入しました。

00:00:56.000 --> 00:01:01.000
今、私たちはApp Intentsと呼ばれる新しいフレームワークを導入しています。

00:01:01.000 --> 00:01:04.000
それには3つの重要な要素があります。

00:01:04.000 --> 00:01:08.000
意図は、システム全体で使用できるアプリに組み込まれたアクションです。

00:01:08.000 --> 00:01:12.000
インテントは、アプリのコンセプトを表すためにエンティティを使用します。

00:01:12.000 --> 00:01:18.000
アプリのショートカットは、それらを自動的かつ発見可能にするためにあなたの意図をラップします。

00:01:18.000 --> 00:01:26.000
App Intentsがアプリの機能をより多くの場所で利用できるようにし、顧客に利益をもたらす方法について話しましょう。

00:01:26.000 --> 00:01:34.000
アプリショートカットを使用すると、誰もが最初に何も設定することなく、Siriを介して自分の声でアプリの機能を使用できます。

00:01:34.000 --> 00:01:42.000
同じ採用により、人々があなたのアプリを検索し、あなたのアプリが提案されたときに、あなたの意図がSpotlightに表示されます。

00:01:42.000 --> 00:01:45.000
これはあなたの仕事を前面と中央に置くでしょう。

00:01:45.000 --> 00:01:53.000
アプリインテントを使用すると、フォーカスフィルターを構築して、顧客が特定のフォーカスに合わせてアプリをカスタマイズできるようにすることもできます。

00:01:53.000 --> 00:02:01.000
たとえば、実際に仕事中に作業カレンダーのみを表示するようにカレンダーアプリを設定する場合があります。

00:02:01.000 --> 00:02:06.000
フォーカスフィルターの採用方法の詳細については、このセッションをご覧ください。

00:02:06.000 --> 00:02:14.000
アプリショートカットを使用すると、手動で追加することなく、インテントがショートカットアプリに自動的に表示されます。

00:02:14.000 --> 00:02:25.000
アクションをショートカットに統合することは、システム内の多くの場所からショートカットを実行し、アプリの機能を活用できるため、顧客にとって非常に価値があります。

00:02:25.000 --> 00:02:32.000
ホーム画面、macOSのメニューバー、その他多くの方法でワンタップでショートカットを実行できます。

00:02:32.000 --> 00:02:37.000
オートメーションで自動的に実行するようにショートカットを設定することもできます。

00:02:37.000 --> 00:02:51.000
ショートカットのサポートは、アプリをショートカットエコシステム全体に接続し、Appleや他の開発者からの一連のアプリの力を活用することで、アプリのパワーと機能を倍増させます。

00:02:51.000 --> 00:03:02.000
なぜなら、ショートカットは複数のアプリのアクションを組み合わせることができ、ユーザーが作業をしなくてもまったく新しい機能や機能を発明できるからです。

00:03:02.000 --> 00:03:11.000
あなたの行動が他の人とうまく機能し、このエコシステムにシームレスにフィットする方法を学びたい場合は、私たちのデザイントークをチェックしてください。

00:03:11.000 --> 00:03:16.000
アプリインテントを構築する私たちの目標は、開発する喜びにすることでした。

00:03:16.000 --> 00:03:18.000
アプリの意図は簡潔です。

00:03:18.000 --> 00:03:27.000
単純なインテントを書くには数行のコードしかかかりませんが、APIはより深く、よりカスタマイズ可能なアクションにも拡張できます。

00:03:27.000 --> 00:03:29.000
アプリの意図は現代的です。

00:03:29.000 --> 00:03:36.000
私たちはSwiftに全力を尽くし、結果ビルダー、プロパティラッパー、プロトコル指向のプログラミング、ジェネリックを活用しました。

00:03:36.000 --> 00:03:41.000
これらのAPIは、最先端の言語機能なしでは存在できませんでした。

00:03:41.000 --> 00:03:49.000
製品やターゲットを再設計したり、フレームワークを作成したりする必要がないため、App Intentsの採用も簡単です。

00:03:49.000 --> 00:03:53.000
拡張機能を必要とせず、アプリですぐに採用できます。

00:03:53.000 --> 00:03:55.000
そして、App Intentsコードはメンテナンス可能です。

00:03:55.000 --> 00:04:04.000
SwiftUIと同様に、App Intentsはコードを真実の基本的な情報源として使用し、個別のエディタや定義ファイルの必要性を回避します。

00:04:04.000 --> 00:04:12.000
これにより、採用を迅速に構築して反復し、すべてが1か所に存在するため、メンテナンスを簡素化できます。

00:04:12.000 --> 00:04:19.000
とはいえ、新しいフレームワークの中心的な構成要素である意図から始めて、これらの新しいAPIを探りましょう。

00:04:19.000 --> 00:04:27.000
アプリの意図、または略して「意図」は、アプリがシステムに公開する単一の分離された機能ユニットです。

00:04:27.000 --> 00:04:34.000
たとえば、インテントは新しいカレンダーイベントを作成したり、特定の画面を開いたり、注文したりすることができます。

00:04:34.000 --> 00:04:45.000
インテントは、ショートカットを実行したり、Siriに頼んだり、フォーカスフィルターやショートカットの自動化を使用するなど、リクエストに応じてユーザーが実行できます。

00:04:45.000 --> 00:04:51.000
インテントが実行されると、結果を返すか、エラーをスローします。

00:04:51.000 --> 00:05:09.000
インテントには、メタデータ、またはローカライズされたタイトルを含むインテントに関する情報、インテントが実行時に使用できる入力であるパラメータ、およびインテントが実行されたときに実際の作業を行う実行メソッドの3つのキーピースが含まれます。

00:05:09.000 --> 00:05:11.000
今日の出発点は、この図書館アプリです。

00:05:11.000 --> 00:05:18.000
私は巨大な本の虫なので、読んだ本、読みたい本、または現在読んでいる本を追跡することがすべてです。

00:05:18.000 --> 00:05:24.000
各カテゴリは、私がシェルフと呼ぶアプリの別々のタブに表示されます。

00:05:24.000 --> 00:05:34.000
私のユーザーは、現在読んでいる棚を常に訪問しているので、私はそれをより速く、より便利に開くためにアプリの意図を公開するつもりです。

00:05:34.000 --> 00:05:41.000
AppIntentプロトコルに準拠したSwift構造体を定義して、ここでOpenCurrentlyReadingインテントを作成します。

00:05:41.000 --> 00:05:45.000
実行と呼ばれるメソッドを1つだけ実装する必要があります。

00:05:45.000 --> 00:05:52.000
私のアプリでは、私はすでにタブを開くことができるナビゲーターを持っているので、私のために意図を実装するのはほんの数行のコードです。

00:05:52.000 --> 00:05:59.000
ナビゲーターがメインスレッドを期待しているので、@MainActorでperformメソッドに注釈を付けます。

00:05:59.000 --> 00:06:02.000
私の意図にもタイトルが必要です。

00:06:02.000 --> 00:06:09.000
今日お見せする他のすべての文字列と同様に、文字列ファイルにキーを追加すると、これは自動的にローカライズされます。

00:06:09.000 --> 00:06:13.000
基本的なアプリの意図を機能させるために私がする必要があるのはこれだけです。

00:06:13.000 --> 00:06:24.000
私のコードで定義されているので、ショートカットエディタに自動的に表示され、ユーザーがショートカットに追加できます。

00:06:24.000 --> 00:06:36.000
この意図を公開するだけで、大きなレバレッジが得られます。なぜなら、顧客がこの意図をショートカットに変えると、これらすべてを含むシステム内の多くの場所から使用できるからです。

00:06:36.000 --> 00:06:41.000
私の新しい意図を使いやすく、発見しやすくするために、アプリショートカットのサポートも追加します。

00:06:41.000 --> 00:06:53.000
少しのコードで、Spotlightとショートカットアプリに私の意図を自動的に表示させることができ、人々が自分の声でこの意図を使用するようにSiriに言うことができるフレーズを定義することができます。

00:06:53.000 --> 00:07:00.000
「App IntentsでApp Shortcutsを実装する」セッションをチェックして、すべての詳細を入手してください。

00:07:00.000 --> 00:07:05.000
これまでのところ、私は現在読んでいる棚を開く意図を明らかにしました。

00:07:05.000 --> 00:07:12.000
次に、それを一般化し、任意の棚を開くことができるようにパラメータを追加します。

00:07:12.000 --> 00:07:15.000
私は棚を表す列挙型を持っています。

00:07:15.000 --> 00:07:21.000
インテントパラメータとして使用するには、AppEnumプロトコルに準拠する必要があります。

00:07:21.000 --> 00:07:26.000
AppEnumには文字列の生の値が必要なので、最初にそれを追加します。

00:07:26.000 --> 00:07:32.000
また、列挙型ケースごとにローカライズ可能で人間が読めるタイトルを提供する必要があります。

00:07:32.000 --> 00:07:39.000
これらは、コンパイラがビルド時にこのコードを読み取るため、辞書リテラルとして提供する必要があります。

00:07:39.000 --> 00:07:46.000
最後に、typeDisplayNameを追加します。これは、この列挙型全体のユーザー可視でローカライズ可能な名前です。

00:07:46.000 --> 00:07:49.000
「シェルフ」を使います。

00:07:49.000 --> 00:07:58.000
インテントでは、各パラメータは@Parameterプロパティラッパーを使用して宣言され、タイトルなどのパラメータに関する情報で初期化されます。

00:07:58.000 --> 00:08:04.000
ここでは、performメソッドで読んだ新しいシェルフパラメータを定義します。

00:08:04.000 --> 00:08:13.000
パラメータは、数字、文字列、ファイル、アプリのエンティティや列挙型など、これらすべてのタイプをサポートします。

00:08:13.000 --> 00:08:17.000
ショートカットエディタでこの意図がどのように見えるかは次のとおりです。

00:08:17.000 --> 00:08:21.000
シェルフパラメータはテーブルの行に表示されることに注意してください。

00:08:21.000 --> 00:08:29.000
ParameterSummary APIを使用することで、UIをより合理化し、ショートカットによりよく適合させることができます。

00:08:29.000 --> 00:08:37.000
パラメータサマリーは、「開く」のように、エディタであなたの意図とそのパラメータを表す文です。

00:08:37.000 --> 00:08:45.000
ショートカットで最良の結果を得るには、作成するすべてのインテントのパラメータサマリーを常に提供する必要があります。

00:08:45.000 --> 00:08:50.000
また、折り目の下に表示されるパラメータと非表示のパラメータを定義することもできます。

00:08:50.000 --> 00:09:05.000
これらのAPIは、When and Otherwise API、またはSwitch、Case、およびDefault APIを使用して、意図のパラメータの実際の値に基づいて要約を変化させるなど、かなりクールなことを行うことができます。

00:09:05.000 --> 00:09:09.000
パラメータサマリーを追加するには、この静的プロパティを実装します。

00:09:09.000 --> 00:09:15.000
ここでは、文字列「Open」を返し、シェルフパラメータを補間します。

00:09:15.000 --> 00:09:25.000
Open Shelfを動作させるために私がする必要がある最後のことは、このように、実行時にインテントがライブラリアプリを開くことを確認することです。

00:09:25.000 --> 00:09:30.000
アプリを開くのは、静的プロパティopenAppWhenRunによって制御されます。

00:09:30.000 --> 00:09:33.000
デフォルトはfalseで、ほとんどの意図に最適です。

00:09:33.000 --> 00:09:40.000
しかし、このようなUIで何かを開く意図については、trueに設定する必要があります。

00:09:40.000 --> 00:09:43.000
私はちょうど棚を開ける意図を作成しました。

00:09:43.000 --> 00:09:47.000
棚のセットが固定されているので、これは超簡単です。

00:09:47.000 --> 00:09:53.000
しかし、セットが固定ではなく動的である本を開く意図を構築したい場合はどうなりますか?

00:09:53.000 --> 00:09:55.000
そのために、エンティティが必要になります。

00:09:55.000 --> 00:09:59.000
エンティティは、アプリがApp Intentsに公開する概念です。

00:09:59.000 --> 00:10:09.000
ノートのメモや写真の写真やアルバムのように、値が動的またはユーザー定義の場合は、列挙型の代わりにエンティティを使用する必要があります。

00:10:09.000 --> 00:10:17.000
エンティティのインスタンスを提供するために、アプリはクエリを実装し、インテントの結果としてエンティティを返すことができます。

00:10:17.000 --> 00:10:21.000
アプリで本を開く意図を作ることから始めます。

00:10:21.000 --> 00:10:25.000
ショートカットエディタでは、次のようになります。

00:10:25.000 --> 00:10:34.000
人々がブックパラメータをタップすると、私のアプリが提供した提案されたエンティティのセットを含む、本を選択するためのピッカーを取得します。

00:10:34.000 --> 00:10:41.000
また、ピッカーの上部にあるこの検索フィールドを使用して、ライブラリ内の任意の本を見つけることができます。

00:10:41.000 --> 00:10:47.000
インテント自体を構築する前に、ブックエンティティと対応するクエリを作成する必要があります。

00:10:47.000 --> 00:10:56.000
エンティティには、識別子、表示表現、エンティティタイプ名の少なくとも3つのものが含まれています。

00:10:56.000 --> 00:11:01.000
エンティティを追加するには、まずAppEntityプロトコルに構造体を合わせることから始めます。

00:11:01.000 --> 00:11:08.000
ここでは、BookEntityの新しい構造体を定義しますが、モデルから既存の型を適合させることもできます。

00:11:08.000 --> 00:11:14.000
エンティティを識別可能なプロトコルに準拠させることで、識別子を提供します。

00:11:14.000 --> 00:11:20.000
App Intentsは、この識別子を使用して、アプリとシステムの他の部分の間で渡されるエンティティを参照します。

00:11:20.000 --> 00:11:29.000
識別子は、顧客が作成したショートカットに保存される可能性があるため、安定して永続的である必要があります。

00:11:29.000 --> 00:11:33.000
表示表現は、このエンティティをユーザーに表示するために使用されます。

00:11:33.000 --> 00:11:37.000
これは、本のタイトルのようなテキストの文字列と同じくらい簡単です。

00:11:37.000 --> 00:11:41.000
字幕と画像を提供することもできます。

00:11:41.000 --> 00:11:46.000
typeDisplayNameは、エンティティの型を表す人間が読める文字列です。

00:11:46.000 --> 00:11:49.000
この例では、「本」です。

00:11:49.000 --> 00:11:54.000
さて、ブックエンティティを締めくくるには、クエリを追加する必要があります。

00:11:54.000 --> 00:12:00.000
クエリは、アプリからエンティティを取得するためのインターフェイスをシステムに提供します。

00:12:00.000 --> 00:12:03.000
クエリは、いくつかの方法でエンティティを検索できます。

00:12:03.000 --> 00:12:07.000
すべてのクエリは、識別子に基づいてエンティティを検索できる必要があります。

00:12:07.000 --> 00:12:09.000
文字列クエリは検索をサポートします。

00:12:09.000 --> 00:12:13.000
そして後で、より柔軟なプロパティクエリに遭遇します。

00:12:13.000 --> 00:12:21.000
すべてのクエリは、ユーザーがリストから選択できる、提案されたエンティティを提供することもできます。

00:12:21.000 --> 00:12:29.000
システムがそのエンティティのインスタンスを検索できるように、すべてのエンティティをクエリに関連付ける必要があります。

00:12:29.000 --> 00:12:35.000
EntityQueryプロトコルに準拠したSwift構造体を作ることで、クエリを提供します。

00:12:35.000 --> 00:12:42.000
基本的なクエリには、識別子の配列が与えられたエンティティを解決するために実装する、必要なメソッドが1つしかありません。

00:12:42.000 --> 00:12:49.000
モデルデータベースに行き、それらの識別子に一致する本を見つけることで、これを実装しました。

00:12:49.000 --> 00:12:53.000
今、私はエンティティにクエリを接続する必要があります。

00:12:53.000 --> 00:13:03.000
これを行うには、BookEntityタイプにdefaultQuery staticプロパティを実装し、BookQueryのインスタンスを返します。

00:13:03.000 --> 00:13:08.000
ユーザーが本を選択すると、その識別子がショートカットに保存されます。

00:13:08.000 --> 00:13:16.000
ショートカットが実行されると、App IntentsはBookEntityインスタンスを取得するために私のクエリに識別子を渡します。

00:13:16.000 --> 00:13:24.000
BookEntityタイプがAppEntityプロトコルに準拠したので、OpenBookインテントのパラメータとして使用できます。

00:13:24.000 --> 00:13:32.000
実行方法は、私のナビゲーターを使用して本に移動します。

00:13:32.000 --> 00:13:38.000
ブックピッカーをサポートするために、私のクエリも提案された結果を提供する必要があります。

00:13:38.000 --> 00:13:45.000
これを行うには、クエリにもう1つのメソッドを実装し、ライブラリアプリに追加されたすべての本を返す必要があります。

00:13:45.000 --> 00:13:49.000
ショートカットはこれらの結果でピッカーを埋めます。

00:13:49.000 --> 00:13:53.000
ショートカットUIの上部に検索フィールドがあることに注意してください。

00:13:53.000 --> 00:14:00.000
私のアプリは多くのブックエンティティを持つことができるので、私は本当に私のデータベースに対して、私のアプリプロセスで検索を実行する必要があります。

00:14:00.000 --> 00:14:04.000
StringQuery APIでは、それを行うことができます。

00:14:04.000 --> 00:14:13.000
StringQueryサブプロトコルを採用すると、文字列が与えられた結果を返すために、エンティティ(一致文字列:)と呼ばれる実装するもう1つの方法が得られます。

00:14:13.000 --> 00:14:24.000
ここでは、本のタイトルに対する単純な大文字と小文字を区別しないマッチとして実装しましたが、たとえば、著者やシリーズ名を検索するなど、より豪華なことをすることができました。

00:14:24.000 --> 00:14:38.000
書籍の膨大なリストとお気に入りのリストが少ない場合は、suggestedEntitiesのお気に入りだけを返し、エンティティ（一致文字列：）に依存して、ユーザーがより長いリストを検索できるようにすることができます。

00:14:38.000 --> 00:14:45.000
今、私はアプリで本を開く方法を公開し、その過程でブックエンティティとブッククエリを構築しました。

00:14:45.000 --> 00:14:49.000
同じエンティティとクエリを使用して、より多くのインテントを作成できます。

00:14:49.000 --> 00:14:53.000
私の次の仕事は、図書館に本を追加する意図を構築することです。

00:14:53.000 --> 00:15:03.000
お客様は、共有シートのショートカットを使用してオンラインで閲覧しながら本をすばやく追加したり、画面を見ずに本を追加するようにHomePodのSiriに指示したりできます。

00:15:03.000 --> 00:15:11.000
UIを表示せずにモデルを直接操作するこのような意図を構築することは、本当にユーザーに力を与えることができます。

00:15:11.000 --> 00:15:19.000
これは、本のタイトルと著者のオプション名をパラメータとして、私のAddBookインテントの実装です。

00:15:19.000 --> 00:15:24.000
また、どの友人が本を推薦したかを記録するためのオプションのメモも含まれています。

00:15:24.000 --> 00:15:31.000
performメソッドは、async/awaitを使用してAPI呼び出しで調べることで、ブックをライブラリに追加します。

00:15:31.000 --> 00:15:36.000
一致するものが見つからない場合、エラーがスローされます。

00:15:36.000 --> 00:15:43.000
このエラーをローカライズするために、エラータイプをCustomLocalizedString ResourceConvertibleプロトコルに適合させます。

00:15:43.000 --> 00:15:50.000
このプロパティからローカライズされた文字列キーを返し、そのキーを文字列ファイルに追加します。

00:15:50.000 --> 00:15:56.000
このAdd Bookの意図は、Siri、ウィジェットなどで非常に便利です。

00:15:56.000 --> 00:16:01.000
しかし、他の意図と組み合わせることができれば、さらに柔軟になります。

00:16:01.000 --> 00:16:10.000
少しの作業で、Add Bookの意図と以前に構築したOpen Bookの意図を組み合わせて、結果を一方から他方へと渡すことができます。

00:16:10.000 --> 00:16:17.000
これを行うには、Add Bookの意図に結果の一部として値を返してもらいます。

00:16:17.000 --> 00:16:23.000
私のperformメソッドの戻り値タイプが、私が返す値を表す新しいプロトコルを拾ったことに注意してください。

00:16:23.000 --> 00:16:31.000
これで、ユーザーはこのインテントの結果値を、ブックエンティティをパラメータとして取る他のインテントに接続できます。

00:16:31.000 --> 00:16:41.000
Add Bookの意図とOpen Bookの意図は非常に自然にペアになるので、本を追加し、すぐにライブラリで開くショートカットを作成できます。

00:16:41.000 --> 00:16:46.000
意図から結果を返してアプリで開くのは一般的なパターンです。

00:16:46.000 --> 00:16:51.000
アプリのインテントには、openIntentと呼ばれるこれを表現する方法が組み込まれています。

00:16:51.000 --> 00:16:57.000
openIntentを追加すると、顧客はショートカットで「実行時に開く」という新しいスイッチを取得します。

00:16:57.000 --> 00:17:04.000
スイッチをオフにすると、このインテントを中断することなくバックグラウンドでショートカットの一部として使用できます。

00:17:04.000 --> 00:17:12.000
スイッチを入れたままにしておくと、新しく追加された本がすぐに私の図書館アプリで開きます。

00:17:12.000 --> 00:17:20.000
openIntentの採用は、Open Bookインテントのインスタンスを作成し、結果の一部として返すのと同じくらい簡単です。

00:17:20.000 --> 00:17:31.000
このインテントが実行されると、Open When Runスイッチがオンの場合、Add Bookインテントが終了すると、Open Bookインテントが自動的に実行されます。

00:17:31.000 --> 00:17:35.000
エンティティとクエリでできることはもっとたくさんあります。

00:17:35.000 --> 00:17:43.000
APIの次のセットで、AppIntentsはSiriKit Intentsフレームワークでこれまでになかったいくつかの強力な能力を開きます。

00:17:43.000 --> 00:17:52.000
エンティティからより多くの情報を公開し、顧客がそれに基づいて見つけてフィルタリングできるようにする方法を見てみましょう。

00:17:52.000 --> 00:17:56.000
これまでのところ、私は本の実体にすべての基本的な要件を追加しました。

00:17:56.000 --> 00:18:05.000
しかし、人々が本をショートカットにもっと深く統合できるようにするために、私は自分の本についてもう少し暴露する必要があります。

00:18:05.000 --> 00:18:11.000
エンティティは、ユーザーに公開したいエンティティに関する追加情報を保持するプロパティをサポートします。

00:18:11.000 --> 00:18:22.000
この場合、本の著者、出版日、既読日、推奨者を追加して、ショートカットでこれらのプロパティを使用できるようにします。

00:18:22.000 --> 00:18:27.000
@Propertyというプロパティラッパーを使用して、BookEntityにプロパティを追加します。

00:18:27.000 --> 00:18:35.000
プロパティは、パラメータと同じタイプをすべてサポートし、それぞれがローカライズされたタイトルを取ります。

00:18:35.000 --> 00:18:55.000
これらの新しいプロパティを使用すると、私の顧客はショートカットのマジック変数を使用して、ブックエンティティで作業するときに新しい情報を引き出すことができます。以前のAdd Bookインテントを使用すると、ショートカットで新しく追加された本の著者または公開日を使用できます。

00:18:55.000 --> 00:19:06.000
プロパティとクエリを組み合わせると、この柔軟な述語エディタUIを使用して、アプリはショートカットでこれらの非常に強力な検索とフィルターアクションを自動的に取得します。

00:19:06.000 --> 00:19:13.000
今、私の顧客は、読んだ日付、タイトル、著者などに基づいて本を見つけてフィルタリングすることができます。

00:19:13.000 --> 00:19:18.000
例えば、デリア・オーウェンズのすべての本を見つけるのは簡単です。

00:19:18.000 --> 00:19:27.000
並べ替えと制限オプションを使用すると、デリア・オーウェンズによって最近出版された3冊の本を見つけるなど、さらに高度なクエリをサポートできます。

00:19:27.000 --> 00:19:36.000
お客様は、これらのビルディングブロックを使用して、コレクション内の3つの最も一般的な著者を見つけるなど、かなりクールなことを行うことができます。

00:19:36.000 --> 00:19:41.000
これらすべてを有効にするには、プロパティクエリと呼ばれる別の種類のクエリを採用する必要があります。

00:19:41.000 --> 00:19:50.000
プロパティクエリは、文字列や識別子ではなく、エンティティ内のプロパティに基づいてエンティティを検索します。

00:19:50.000 --> 00:19:53.000
プロパティクエリを実装するには3つのステップがあります。

00:19:53.000 --> 00:20:00.000
まず、クエリプロパティを宣言します。これは、プロパティを使用してエンティティを検索する方法を指定します。

00:20:00.000 --> 00:20:06.000
次に、クエリ結果をソートする方法を定義するソートオプションを追加します。

00:20:06.000 --> 00:20:12.000
そして最後に、検索を実行するためにエンティティ(matching:)を実装します。

00:20:12.000 --> 00:20:19.000
クエリプロパティは、AppIntentsがこのクエリに関連付けられたエンティティで検索できるあらゆる方法を宣言します。

00:20:19.000 --> 00:20:28.000
それぞれに、私のエンティティのプロパティと、利用可能な比較演算子（包含、等しい、またはそれ以下）がリストされています。

00:20:28.000 --> 00:20:38.000
ここでは、日付プロパティの「未満」と「より大きい」コンパレータをリストし、タイトルプロパティの「contains」と「equal to」をリストします。

00:20:38.000 --> 00:20:48.000
クエリプロパティは、プロパティとコンパレータの各組み合わせを、コンパレータマッピングタイプと呼ばれる選択したタイプにマップします。

00:20:48.000 --> 00:20:51.000
ここでは、CoreDataを使用しているので、NSPredicateを使用します。

00:20:51.000 --> 00:21:00.000
カスタムデータベースまたはREST APIを使用している場合は、独自のコンパレータタイプを設計し、代わりにそれを使用することができます。

00:21:00.000 --> 00:21:04.000
これが私の本のクエリプロパティを設定するコードです。

00:21:04.000 --> 00:21:08.000
BooksQueryをEntityPropertyQueryプロトコルに適合させます。

00:21:08.000 --> 00:21:15.000
次に、QueryProperties結果ビルダーを使用して静的varプロパティを実装します。

00:21:15.000 --> 00:21:24.000
各エントリは、照会できるプロパティのキーパスを指定し、その中で、そのプロパティに適用される各コンパレータを指定します。

00:21:24.000 --> 00:21:31.000
コンパレータごとに、コンパレータマッピングタイプとしてNSPredicateを選択したため、NSPredicateを提供します。

00:21:31.000 --> 00:21:39.000
システムがアプリにクエリの結果を返すように要求すると、ここで構築しているNSPredicatesが返されます。

00:21:39.000 --> 00:21:42.000
ソートにも同様の定義があります。

00:21:42.000 --> 00:21:46.000
これは、私のモデルが本を並べ替えることができるすべてのプロパティのリストです。

00:21:46.000 --> 00:21:52.000
この場合、タイトル、既読日、公開日で並べ替えることができます。

00:21:52.000 --> 00:21:59.000
最後に、データベースを照会し、一致するエンティティを返すエンティティ(matching:)を実装します。

00:21:59.000 --> 00:22:07.000
このメソッドは、以前に定義されたクエリパラメータ（この場合はNSPredicate）で使用したコンパレータマッピングタイプの配列を取ります。

00:22:07.000 --> 00:22:15.000
これらの述語は、私がクエリしたいエンティティのプロパティの基準を記述しています。

00:22:15.000 --> 00:22:26.000
また、述語を「and」または「or」と組み合わせるかどうか、並べ替えるキーパス、および結果数のオプションの制限を示すモードも必要です。

00:22:26.000 --> 00:22:34.000
私の実装では、これらのパラメータを使用して、CoreDataデータベースに対してクエリを実行します。

00:22:34.000 --> 00:22:37.000
顧客はこのプロパティクエリで何ができますか?

00:22:37.000 --> 00:22:40.000
彼らは図書館からランダムな本を選んで読むことができます。

00:22:40.000 --> 00:22:45.000
彼らは20世紀初頭に出版されたすべての本を見つけることができます。

00:22:45.000 --> 00:22:51.000
彼らはショートカットのエコシステムを活用し、他のアプリに接続することで私のアプリをより便利にすることができます。

00:22:51.000 --> 00:22:57.000
たとえば、スプレッドシートアプリを使用して、今年読んだすべての本をCSVファイルにエクスポートできます。

00:22:57.000 --> 00:23:03.000
または、グラフ作成アプリを使用して、過去10年間に毎年読んだ本のチャートを作成することもできます。

00:23:03.000 --> 00:23:04.000
そして、それはほんの始まりに過ぎません。

00:23:04.000 --> 00:23:14.000
この種の深いアプリインテントの採用により、顧客はアプリを使用して必要なことを行うことができ、ワークフローの重要な部分になります。

00:23:14.000 --> 00:23:21.000
たとえば、グラフの作成など、これらの統合のそれぞれは、構築する必要がない機能です。

00:23:21.000 --> 00:23:32.000
意図が実行されると、アプリは、Siriのリクエストであろうとショートカットであろうと、結果を表示したり話したり、あいまいさを解決したりするために、ユーザーと対話する必要があるかもしれません。

00:23:32.000 --> 00:23:43.000
アプリインテントは、インテントが完了したときにユーザーにテキストと音声のフィードバックを与えるためのダイアログと、視覚的なフィードバックを与えるためのスニペットなど、これらのインタラクションの数をサポートしています。

00:23:43.000 --> 00:23:59.000
ユーザーに意図パラメータの値を明確にするように依頼するための要求値と曖昧さの解消、およびパラメータ値を検証したり、トランザクション的または破壊的な意図についてユーザーに確認したりするための確認を要求します。

00:23:59.000 --> 00:24:04.000
ダイアログは、インテントを実行している人に音声またはテキストの応答を提供します。

00:24:04.000 --> 00:24:10.000
音声体験で意図がうまく機能するための対話を提供することは本当に重要です。

00:24:10.000 --> 00:24:20.000
先ほどのAdd Bookのインテントでは、本のタイトルと、performメソッドから返された結果ダイアログを尋ねるときに話されるneedsValueDialogを追加します。

00:24:20.000 --> 00:24:25.000
これらは、多くのプラットフォームでショートカットやSiriによって読み取られたり表示されたりします。

00:24:25.000 --> 00:24:34.000
スニペットはダイアログと視覚的に同等のものと考えることができ、意図の結果に視覚的な表現を追加できます。

00:24:34.000 --> 00:24:42.000
スニペットを使用するには、選択したSwiftUIビューをインテント結果の末尾のクロージャとして追加するだけです。

00:24:42.000 --> 00:24:51.000
ウィジェットと同様に、SwiftUIビューはアーカイブされ、ショートカットまたはSiriに送信されます。

00:24:51.000 --> 00:24:56.000
App Intentsは、requestValueをスローしてユーザーに値を尋ねることもサポートしています。

00:24:56.000 --> 00:25:02.000
たとえば、これは、時にはオプションのパラメータの値が必要な場合に便利です。

00:25:02.000 --> 00:25:08.000
ここでは、文字列検索で複数の本が返されたときに、requestValueが役立ちます。

00:25:08.000 --> 00:25:12.000
この場合、私はプロンプトし、著者に本の検索を絞り込むように依頼します。

00:25:12.000 --> 00:25:21.000
requestValueは、私がスローできるエラーを与え、ユーザーにプロンプトを表示し、更新された著者名でアクションを再実行します。

00:25:21.000 --> 00:25:29.000
一方、曖昧さ回避は、ユーザーがパラメータの値のセットから選択する必要がある場合に最適です。

00:25:29.000 --> 00:25:35.000
これにより、Add Bookアクションで複数の可能な結果を処理するためのさらに優れた方法が得られます。

00:25:35.000 --> 00:25:43.000
ここでは、生成された書籍から著者名のリストを取得し、それらの可能な値で曖昧さ回避を要求します。

00:25:43.000 --> 00:25:49.000
ユーザーはそれらの間で選択するように求められ、私は結果を取り戻します。

00:25:49.000 --> 00:25:53.000
最後に、App Intentsは2種類の確認をサポートしています。

00:25:53.000 --> 00:25:57.000
最初の種類は、パラメータ値の確認です。

00:25:57.000 --> 00:26:04.000
その値がどうあるべきかを推測しているが、確認したいときにこれを使うかもしれません。

00:26:04.000 --> 00:26:13.000
本を追加するとき、時々私がタイトルで本を調べるために呼び出すウェブサービスはいくつかの一致を返しますが、そのうちの1つははるかに人気があります。

00:26:13.000 --> 00:26:21.000
このような場合、ユーザーがその人気のある本を追加するつもりだったと仮定しますが、正しいことを確認するために確認を追加します。 確認を追加します。

00:26:21.000 --> 00:26:26.000
これを行うには、タイトルパラメータでrequestConfirmationを呼び出します。

00:26:26.000 --> 00:26:31.000
2番目の種類は、意図の結果の確認です。

00:26:31.000 --> 00:26:33.000
例えば、これは注文に最適です。

00:26:33.000 --> 00:26:41.000
ライブラリアプリを収益化し、書店を通じて注文を追加したい場合は、注文が正しいことを確認したいです。

00:26:41.000 --> 00:26:47.000
これを行うには、私の意図についてrequestConfirmationを呼び出すことができ、配置される順序を渡します。

00:26:47.000 --> 00:26:52.000
ここでもスニペットを指定し、注文のプレビューを表示します。

00:26:52.000 --> 00:27:00.000
ユーザーが確認する代わりにキャンセルすると、requestConfirmationがエラーをスローするため、呼び出しの前に「try」を付けます。

00:27:00.000 --> 00:27:09.000
私があなたを離れる前に、私がカバーしたいApp Intentsアーキテクチャのいくつかの側面があり、フレームワークを採用する際に知っておくべきです。

00:27:09.000 --> 00:27:16.000
アプリインテントを構築するには、実際には2つの方法があります。アプリ内または別の拡張機能です。

00:27:16.000 --> 00:27:20.000
これらのうち、アプリに直接インテントを実装することが最も簡単です。

00:27:20.000 --> 00:27:28.000
フレームワークやコードを複製する必要はなく、プロセス間で調整する必要がないので、これは素晴らしいことです。

00:27:28.000 --> 00:27:39.000
アプリを使用すると、より高いメモリ制限も提供され、オーディオの再生など、拡張機能でより難しい種類の作業を行うことができます。

00:27:39.000 --> 00:27:45.000
trueを返す意図でopenAppWhenRunを実装すると、アプリはフォアグラウンドで実行できます。

00:27:45.000 --> 00:27:48.000
そうでなければ、バックグラウンドで実行されます。

00:27:48.000 --> 00:27:55.000
バックグラウンドで実行すると、パフォーマンスを最大化するためにシーンが起動されることなく、アプリは特別なモードで起動します。

00:27:55.000 --> 00:28:05.000
実際、アプリにバックグラウンドアプリのインテントを実装する場合は、シーンサポートも実装することを強くお勧めします。

00:28:05.000 --> 00:28:08.000
または、拡張機能でアプリのインテントを構築することもできます。

00:28:08.000 --> 00:28:10.000
これにはいくつかの利点があります。

00:28:10.000 --> 00:28:18.000
拡張プロセスはアプリの意図のみを処理し、アプリをスピンアップする必要がないため、軽量です。

00:28:18.000 --> 00:28:32.000
フォーカスインテントを処理している場合、拡張機能を使用すると、アプリが最初にフォアグラウンドで実行されているという要件なしに、フォーカスが変更されたときに拡張機能ですぐにインテントが実行されることを意味します。

00:28:32.000 --> 00:28:43.000
拡張機能は、新しいターゲットを追加し、いくつかのコードをフレームワークに移動し、アプリと拡張機能の間の調整を処理する必要があるため、もう少し作業です。

00:28:43.000 --> 00:28:52.000
App Intents拡張機能を作成するには、Xcodeの[ファイル]&gt;[新しいターゲット]に移動し、[App Intents拡張機能]を選択します。

00:28:52.000 --> 00:28:56.000
App Intentsでは、あなたのコードが唯一の真実の源です。

00:28:56.000 --> 00:29:06.000
App Intentsは、ビルド時にインテント、エンティティ、クエリ、およびパラメータに関する情報を静的に抽出することで、このエレガントな開発者体験を実現します。

00:29:06.000 --> 00:29:18.000
Xcodeは、ビルドプロセス中にアプリまたは拡張バンドル内にメタデータファイルを生成し、コードで実行されるSwiftコンパイラから受け取った情報を含みます。

00:29:18.000 --> 00:29:25.000
これらすべてが機能することを確認するには、App Intentsタイプをフレームワークではなく、ターゲットまたは拡張機能に直接保持してください。

00:29:25.000 --> 00:29:34.000
同様に、ローカライズされた文字列は、App Intentsタイプが生息する同じバンドル内の文字列ファイルにある必要があります。

00:29:34.000 --> 00:29:48.000
アップグレードしたいSiriKit Intentsを備えた既存のアプリをお持ちの方のために、ウィジェットやメッセージングやメディアなどのドメインと統合するIntentsを採用する場合は、SiriKit Intentsフレームワークを使用し続ける必要があります。

00:29:48.000 --> 00:29:55.000
しかし、Siriとショートカットのカスタムインテントを追加する場合は、先に進んでアプリインテントにアップグレードする必要があります。

00:29:55.000 --> 00:30:04.000
SiriKit Intents定義ファイルの「App Intentに変換」ボタンをクリックすると、アップグレードプロセスを開始できます。

00:30:04.000 --> 00:30:17.000
App Intentsを使用してアプリをショートカットに統合することは、開発者としてのレバレッジを最大化する素晴らしい方法です。なぜなら、App Intentsを採用するために少量の作業を行うことで、顧客に大きな価値を生み出すことができるからです。

00:30:17.000 --> 00:30:18.000
参加してくれてありがとう!

00:30:18.000 --> 00:30:23.000
今日、App Intentsを試して、フィードバックをいただければ幸いです。

00:30:23.000 --> 00:30:29.000
この新しいフレームワークが、アプリを使用している人々を驚かせ、喜ばせ、力を与えるのにどのように役立つかに興奮しています!

00:30:29.000 --> 00:30:33.000
幸せな読書とあなたのWWDCが壮大であることを願っています!

00:30:33.000 --> 23:59:59.000
♪

