WEBVTT

00:00:01.000 -> 00:00:14.000
タイラー：こんにちは、私の名前はタイラーで、WebKitアクセシビリティチームのエンジニアです。

00:00:14.000 -> 00:00:23.000
今日のセッションでは、スクリーンリーダーのような支援技術の簡単な概要から始めて、現代のウェブアクセシビリティのツアーを行います。

00:00:23.000 -> 00:00:36.000
次に、Web Speech APIとダイアログ要素で、カスタムコントロール、音声合成マークアップ言語、SSMLなどのツールを使用して、リッチでアクセスしやすいWebアプリを構築する方法について説明します。

00:00:36.000 -> 00:00:40.000
では、支援技術について話すことから始めましょう。

00:00:40.000 -> 00:00:48.000
世界中の約7人に1人が、世界、デバイス、ウェブとの関わり方に影響を与える障害を持っています。

00:00:48.000 -> 00:00:53.000
人々は、あらゆる年齢、あらゆる期間、さまざまなレベルの重症度で障害を経験することができます。

00:00:53.000 -> 00:01:00.000
Appleは、ユーザーが自分に最適な方法でデバイスと対話できるように、さまざまなツールを構築しています。

00:01:00.000 -> 00:01:09.000
これらのツールには、VoiceOver、スイッチコントロール、音声コントロール、フルキーボードアクセスなどがあり、これらはすべてデバイスの代替手段を提供します。

00:01:09.000 -> 00:01:17.000
これらのツールやその他のツールの詳細については、「iOSアプリでフルキーボードアクセスをサポートする」というタイトルの昨年のセッションをチェックしてください。

00:01:17.000 -> 00:01:23.000
これが実際のウェブページでどのようなものかを感じるために、VoiceOverを使用してサンプルクイズ評価Webサイトをナビゲートしましょう。

00:01:23.000 -> 00:01:28.000
iPadでは、トップボタンを3回押してVoiceOverを有効にします。

00:01:28.000 -> 00:01:32.000
Siri: ボイスオーバーをオンにします。サファリ、サイドバーを表示、ボタン。

00:01:32.000 -> 00:01:36.000
タイラー：そして今、VoiceOverがアクティブになっているので、ページの見出しをタップして焦点を合わせます...

00:01:36.000 -> 00:01:38.000
Siri:ポップクイズ、ヘディングレベル1。

00:01:38.000 -> 00:01:41.000
タイラー：右にスワイプして、このページの要素を移動します。

00:01:41.000 -> 00:01:46.000
Siri：6つのうちの1つ：合計8つのスライスを含むピザの1/4には何枚のスライスがありますか？

00:01:46.000 -> 00:01:55.000
2つのスライス、ラジオボタン、チェックなし、4つのうちの1つ、3つのスライス - 4つのスライス - 6つのスライス - 次の質問ボタン。

00:01:55.000 -> 00:02:02.000
タイラー：ウェブ開発者として、VoiceOverのようなテクノロジーのユーザーがページにアクセスできるようにするための多くのツールを自由に利用できます。

00:02:02.000 -> 00:02:13.000
たとえば、Safariには、ボタン、h1からh6、テーブル要素、リスト要素などのセマンティックHTML要素のアクセシビリティサポートが組み込まれています。

00:02:13.000 -> 00:02:22.000
これらのセマンティックHTML要素を使用することは、すべてのブラウザでユーザーに一貫性のあるアクセス可能なエクスペリエンスを保証するため、デフォルトである必要があります。

00:02:22.000 -> 00:02:30.000
ただし、セマンティックHTMLによって完全に満たされる必要がなく、JavaScriptでカスタムコンポーネントを作成する必要がある場合があります。

00:02:30.000 -> 00:02:38.000
このような場合は、セマンティクスが支援技術に適切に伝えられるように、コンポーネントをARIA属性で補完する必要があります。

00:02:38.000 -> 00:02:42.000
これは、今日の2番目のトピックであるカスタムコントロールに私たちをもたらします。

00:02:42.000 -> 00:02:45.000
ピザクイズの質問をもっと魅力的にしたかったとしましょう。

00:02:45.000 -> 00:02:54.000
私たちができることの1つは、ラジオボタンを、ユーザーがタップでピザトレイからスライスを追加および削除できるカスタムコントロールに置き換えることです。

00:02:54.000 -> 00:02:58.000
このカスタム コントロールのマークアップは、div と ID で始まる場合があります。

00:02:58.000 -> 00:03:05.000
タップまたはクリックで対話するユーザーがこのコンポーネントを操作可能にするには、クリックイベントリスナーを追加する必要があります。

00:03:05.000 -> 00:03:10.000
要素のIDを受け入れるコンストラクタを使用して、新しいPizzaControlクラスを作成しましょう。

00:03:10.000 -> 00:03:15.000
その要素をIDで取得し、クリックイベントリスナーを追加します。

00:03:15.000 -> 00:03:22.000
このリスナーは、タップされた位置に基づいて新しいスライス数を計算し、その値をupdateという関数に渡してコントロールを再レンダリングします。

00:03:22.000 -> 00:03:26.000
これは一部のユーザーにとって素晴らしいことですが、すべてではありません。

00:03:26.000 -> 00:03:31.000
たとえば、視覚障害のあるユーザー、クリックまたはタップする場所がわからないユーザーはどうですか?

00:03:31.000 -> 00:03:37.000
カスタムコンポーネントを構築する際には、すべてのタイプの支援技術のユーザーがコンポーネントとどのように相互作用するかを常に考慮する必要があります。

00:03:37.000 -> 00:03:44.000
それを念頭に置いて、コンポーネントをアクセシブルにするための最初のステップは、「スライダー」の値を持つロール属性を与えることです。

00:03:44.000 -> 00:03:47.000
私たちのコントロールは、スライダーのモデルに非常にうまくマッピングされます。

00:03:47.000 -> 00:03:55.000
最小値、ゼロスライス、最大値、8つのスライス、現在の値、4つのスライスがあります。

00:03:55.000 -> 00:04:03.000
また、コンポーネントがキーボードやその他の非タッチインターフェイスのユーザーにとってフォーカス可能であることを確認するために、ゼロのタブインデックスを追加する必要があります。

00:04:03.000 -> 00:04:06.000
また、いくつかのARIA属性を追加する必要があります。

00:04:06.000 -> 00:04:14.000
Aria-valueminとaria-valuemaxは、このスライダーの最小値と最大値を支援技術に知らせます。

00:04:14.000 -> 00:04:20.000
これらの属性は、ネイティブ範囲タイプの入力で使用できる最小属性と最大属性に似ています。

00:04:20.000 -> 00:04:25.000
次に、コントロールの現在の値を伝えるためにaria-valuenowを追加しましょう。

00:04:25.000 -> 00:04:33.000
また、aria-valuetextを使用して、4つのスライスである現在の値のより有用な説明を提供します。

00:04:33.000 -> 00:04:40.000
フォーカス可能なスライダーとしてコントロールを確立したので、支援技術からのコントロールの価値の更新を処理する必要があります。

00:04:40.000 -> 00:04:49.000
iOSでは、VoiceOverは1本の指でスワイプしてスライダーをインクリメントし、下にスワイプしてスライダーを縮小してスライダーの調整を容易にします。

00:04:49.000 -> 00:04:52.000
Safariは、これらのジェスチャーを処理する簡単な方法を提供します。

00:04:52.000 -> 00:04:59.000
VoiceOverユーザーがスライダーにフォーカスして上にスワイプすると、Safariは自動的に矢印キーの右イベントをシミュレートします。

00:04:59.000 -> 00:05:05.000
同様に、VoiceOverユーザーがスライダーにフォーカスして下にスワイプすると、矢印キー左のイベントがシミュレートされます。

00:05:05.000 -> 00:05:11.000
これらのシミュレートされたイベントは、実際のキープレスと同じように動作します。つまり、キーイベントリスナーが処理できます。

00:05:11.000 -> 00:05:16.000
ツールベルトのこの新しい知識で、ピザコントロールにキーダウンリスナーを追加しましょう。

00:05:16.000 -> 00:05:23.000
アクティブキーが右矢印または上矢印の場合は、現在のスライス量と1でコントロールを更新します。

00:05:23.000 -> 00:05:30.000
同様に、アクティブ化されたキーが左矢印または下矢印の場合は、現在のスライス量から1を引いた値でコントロールを更新します。

00:05:30.000 -> 00:05:40.000
このキーイベントリスナーを追加することは、VoiceOverユーザーだけでなく、フルキーボードアクセスのユーザーにも役立ちます。フルキーボードアクセス可能なウェブアプリに大きく、または完全に依存している可能性があります。

00:05:40.000 -> 00:05:46.000
両方のイベントリスナーが確立されたので、おそらく更新機能も定義したいと思うでしょう。

00:05:46.000 -> 00:05:55.000
まず、与えられた値をクランプして、0から8の間の境界内にあることを確認し、保存されたスライスカウントの状態をこの値に更新します。

00:05:55.000 -> 00:06:00.000
次に、コントロールのビジュアル表現とARIA表現の両方を確実に更新する必要があります。

00:06:00.000 -> 00:06:10.000
カスタムコンポーネントを構築する場合、良いルールは、コンポーネントの視覚的表現を更新する場合は、ARIA表現をどのように更新するかについても考える必要があるということです。

00:06:10.000 -> 00:06:19.000
この場合、aria-valuenow属性とaria-valuetext属性の両方を更新して、新しい制御状態の支援技術をユーザーに通知する必要があります。

00:06:19.000 -> 00:06:24.000
Aria-valuenowを現在のスライス数に設定することから始めます。

00:06:24.000 -> 00:06:32.000
次に、aria-valuetextをスライス数のより人間に優しい説明と、「スライス」または「スライス」という単語に設定します。

00:06:32.000 -> 00:06:38.000
さて、すべてが整ったので、クイズ評価ウェブアプリに戻って、VoiceOverの体験がどのようなものかを見てみましょう。

00:06:38.000 -> 00:06:41.000
まず、ピザコントロールをタップして焦点を合わせることから始めます。

00:06:41.000 -> 00:06:43.000
Siri: 4つのスライス、調整可能。

00:06:43.000 -> 00:06:46.000
1本の指で上下にスワイプして値を調整します。

00:06:46.000 -> 00:06:52.000
タイラー：VoiceOverがスライダーの初期値、4つのスライスを読み、調整可能だと教えてくれたと聞きました。

00:06:52.000 -> 00:06:56.000
VoiceOverのプロンプトに従って、上にスワイプして選択したスライスの数を増やすことができます...

00:06:56.000 -> 00:06:59.000
Siri: 5つのスライス。6つのスライス。

00:06:59.000 -> 00:07:02.000
タイラー：そして、下にスワイプして、選択したスライスの数を減らします。

00:07:02.000 -> 00:07:04.000
Siri: 5つのスライス。4つのスライス。

00:07:04.000 -> 00:07:09.000
タイラー：これらの変更により、カスタムスライダーコンポーネントがはるかにアクセスしやすくなりました。

00:07:09.000 -> 00:07:17.000
それでは、Web Speech APIでSSMLを使用して、すべてのユーザーにとってより豊かなエクスペリエンスを構築する方法について話しましょう。

00:07:17.000 -> 00:07:28.000
Web Speech APIは、音声入力用のSpeechRecognitionと、テキスト読み上げオーディオ出力用のSpeechSynthesisの2つの主要なJavaScriptインターフェイスで構成されています。

00:07:28.000 -> 00:07:34.000
Web Speechは、Webアプリに音声アシストまたは音声のみのインターフェイスを提供する機能を提供します。

00:07:34.000 -> 00:07:42.000
これは、マウス、キーボード、タッチスクリーンなどの他の制御手段の使用に問題がある可能性のある運動障害のあるユーザーにとって有益です。

00:07:42.000 -> 00:07:49.000
SafariのSpeechSynthesisの新機能は、SSMLを使用してテキストの話し方を操作する機能です。

00:07:49.000 -> 00:07:51.000
SSMLにはたくさんの機能があります。

00:07:51.000 -> 00:07:57.000
たとえば、break要素を使用して、選択した時間でスピーチに一時停止を挿入できます。

00:07:57.000 -> 00:08:02.000
ユーザーに息を吸って...息を吐くように頼んだ方がいいかもしれません。

00:08:02.000 -> 00:08:08.000
音素要素を使用すると、「tomayto」や「tomahto」などの単語の発音を制御できます。

00:08:08.000 -> 00:08:14.000
韻律要素を使用すると、音声テキストのピッチ、レート、音量を操作できます。

00:08:14.000 -> 00:08:18.000
そして、これらはSSMLの機能の表面を傷つけるだけです。

00:08:18.000 -> 00:08:22.000
詳細については、w3.orgのSSML仕様を確認してください。

00:08:22.000 -> 00:08:26.000
SSMLに関する新しい知識を活用しましょう。

00:08:26.000 -> 00:08:34.000
クイズの最後の質問では、「水」というフレーズの正しいスペイン語翻訳を含むラジオボタンを選択するよう学生に依頼します。

00:08:34.000 -> 00:08:45.000
ユーザーがボタンを押してテキスト読み上げで質問と回答を読み、SSMLを使用してスペイン語のフレーズをスペイン語の音声で読むことで、この質問をより魅力的にすることができます。

00:08:45.000 -> 00:08:56.000
まず、ボタンを作成することから始めましょう。この絵文字の説明はここでは特に役に立たないので、aria-hiddenがtrueに設定されたスパンでスピーカーの絵文字をラップします。

00:08:56.000 -> 00:09:04.000
次に、話すためのフレーズとそれを話すための音声ロケールを取るwrapWithSSMLと呼ばれるヘルパーJavaScript関数を作成しましょう。

00:09:04.000 -> 00:09:10.000
強調を構築するために、各フレーズの前に短い一時停止を挿入するために、ブレーク要素でSSML文字列を構築し始めます。

00:09:10.000 -> 00:09:17.000
Prosody要素では、デフォルトレートの80%でフレーズを話すことを指定します。

00:09:17.000 -> 00:09:24.000
そして最後に、lang要素を使用して、フレーズを話したいロケール固有の音声を選択できます。

00:09:24.000 -> 00:09:29.000
そして今、読み取り質問ボタンにクリックイベントリスナーを追加し、内部にSSML文字列を構築します。

00:09:29.000 -> 00:09:33.000
文字列全体をスピーク要素で包むことから始めます。

00:09:33.000 -> 00:09:40.000
内部のものがSSMLと見なされるべきであることを合成プロセッサに示すので、話すことは重要です。

00:09:40.000 -> 00:09:45.000
次に、私たちの質問を含めます:スペイン語で「水」を何と言いますか?

00:09:45.000 -> 00:09:53.000
wrapWithSSMLヘルパー機能を使用して、翻訳されているフレーズを強調し、米国で確実に読まれるようにすることができます。英語のロケールボイス。

00:09:53.000 -> 00:10:02.000
また、4つの潜在的な回答すべてにwrapWithSSMLを使用し、強調し、スペイン語のロケール音声で読むように要求します。

00:10:02.000 -> 00:10:13.000
最後に、SSML文字列を使用して新しいSpeechSynthesisUtteranceオブジェクトを作成し、それをウィンドウSpeechSynthesis speakメソッドに渡して読み取ることができます。

00:10:13.000 -> 00:10:17.000
そのすべてが整った状態で、私たちのウェブアプリでの経験がどのようなものか見てみましょう。

00:10:17.000 -> 00:10:21.000
最後の質問があるページで、「質問を読む」ボタンをタップして聞きます。

00:10:21.000 -> 00:10:26.000
Siri: スペイン語で「水」は何と言いますか?

00:10:26.000 -> 00:10:28.000
エル・アグア。

00:10:28.000 -> 00:10:30.000
ラ・アブエラ。

00:10:30.000 -> 00:10:32.000
ラ・アベハ。

00:10:32.000 -> 00:10:34.000
El árbol。

00:10:34.000 -> 00:10:39.000
タイラー：SSMLのおかげで、私たちは学生のためにはるかに魅力的な体験を生み出しました。

00:10:39.000 -> 00:10:43.000
ウェブ上のもう1つの一般的なデザインパターンはモーダルです。

00:10:43.000 -> 00:10:50.000
ウェブアプリでは、サインインまたはサインアップフォーム、確認ダイアログなどとして使用できます。

00:10:50.000 -> 00:10:55.000
アクセシブルなモーダル体験を提供する1つの方法は、アリアモーダル属性です。

00:10:55.000 -> 00:11:02.000
aria-modal="true"では、Safariはモーダル以外のすべてのアクセス可能な要素が無視されると見なします。

00:11:02.000 -> 00:11:06.000
最近、Safariはダイアログ要素のサポートも追加しました。

00:11:06.000 -> 00:11:18.000
ダイアログは、標準的なフォーカスインタラクション、iOSのエスケープキーやスクラブジェスチャーなどのモーダルクロージングジェスチャーの既成概念にとらわれない処理により、アクセシビリティに優しいモーダル体験をはるかに簡単に提供します。

00:11:18.000 -> 00:11:26.000
これを実際に見るには、クイズ評価ウェブアプリの「スコアを表示」ボタンを変更して、結果のダイアログを開きましょう。

00:11:26.000 -> 00:11:30.000
まず最初に、ダイアログ要素を作成する必要があります。

00:11:30.000 -> 00:11:33.000
マークアップはこんな感じかもしれません。

00:11:33.000 -> 00:11:37.000
後でスコアの表示ボタンで参照できるように、ダイアログにIDを与えます。

00:11:37.000 -> 00:11:41.000
また、ダイアログの内容をメソッドダイアログで形式でラップします。

00:11:41.000 -> 00:11:47.000
そうすることで、ボタンのような送信タイプコントロールは、ダイアログを閉じます。

00:11:47.000 -> 00:11:50.000
モーダルを開くには、少しJavaScriptも必要です。

00:11:50.000 -> 00:11:57.000
ダイアログ要素でshowModal()を呼び出す「スコアを表示」ボタンにクリックイベントリスナーを追加しましょう。

00:11:57.000 -> 00:11:59.000
そして今、私たちはこれを試してみる準備ができています。

00:11:59.000 -> 00:12:04.000
VoiceOverがアクティブになっている場合は、「スコアを表示」ボタンをタップしてフォーカスします。

00:12:04.000 -> 00:12:06.000
Siri: スコアを表示します。ボタン。

00:12:06.000 -> 00:12:11.000
タイラー：その後、画面のどこかを1本の指でダブルタップしてボタンを押します。

00:12:11.000 -> 00:12:14.000
Siri: スコアを表示します。ウェブダイアログ。閉じるボタン。

00:12:14.000 -> 00:12:16.000
タイラー：そして今、私たちはモーダルを持っています。

00:12:16.000 -> 00:12:19.000
左にスワイプしてモーダルの内容を移動して、スコアを聞くことができます。

00:12:19.000 -> 00:12:22.000
Siri: 6つの質問はすべて正解です。お疲れ様でした！

00:12:22.000 -> 00:12:26.000
タイラー：終わったら、右にスワイプして閉じるボタンに戻ることができます。

00:12:26.000 -> 00:12:28.000
Siri: 閉じるボタン。

00:12:28.000 -> 00:12:31.000
タイラー：ダブルタップしてモーダルを閉じます。

00:12:31.000 -> 00:12:32.000
Siri: チェックなし。

00:12:32.000 -> 00:12:38.000
タイラー：前述したように、ダイアログ要素は、箱から出してモーダルクロージャのためのiOSスクラブジェスチャーを処理します。

00:12:38.000 -> 00:12:42.000
実演するために、ダブルタップでモーダルを再開します...

00:12:42.000 -> 00:12:44.000
Siri: スコアを表示、ボタン。

00:12:44.000 -> 00:12:46.000
ウェブダイアログ。閉じる、ボタン。

00:12:46.000 -> 00:12:53.000
タイラー：そして、画面上で2本の指を右、左、右に素早く動かして、スクラブジェスチャーを実行します。

00:12:53.000 -> 00:12:55.000
Siri: スコアを表示します。ボタン。

00:12:55.000 -> 00:12:59.000
タイラー：さて、私たちは機能的なモーダルを持っていますが、それでももっとうまくやることができます。

00:12:59.000 -> 00:13:04.000
モーダルを開いたとき、VoiceOverは「ウェブダイアログ、閉じる、ボタン」しか読まないことに気づきましたか?

00:13:04.000 -> 00:13:12.000
このような状況では、支援技術のユーザーにより多くの情報を提供するために、aria-labelまたはaria-labelledby属性を使用することはおそらく理にかなっているでしょう。

00:13:12.000 -> 00:13:19.000
私たちのモーダルコンテンツは短いので、単に彼らが正しい答えの数をユーザーに知らせるので、私たちのラベルにそれを使用しましょう。

00:13:19.000 -> 00:13:24.000
まず、モーダルコンテンツをID付きのスパンでラップします。

00:13:24.000 -> 00:13:29.000
次に、modal-content IDを指すダイアログにaria-labelledby属性を追加できます。

00:13:29.000 -> 00:13:36.000
また、最初のモーダルフォーカス要素をオートフォーカス属性を持つ閉じるボタンに明示的に設定しましょう。

00:13:36.000 -> 00:13:44.000
これはすでにこの単純なモーダルのデフォルトの動作でしたが、私たちのモーダルがより多くのコンテンツを持っていたり、多くのコントロールでより複雑だったりした場合、それはそうではなかったかもしれません。

00:13:44.000 -> 00:13:51.000
たとえば、コンテンツの多いモーダルでは、トップレベルの見出しにオートフォーカスを配置する方が理にかなっているかもしれません。

00:13:51.000 -> 00:13:56.000
モーダル作成者として、ユーザーに素晴らしい体験を提供するものについて最もよく知っているでしょう。

00:13:56.000 -> 00:14:00.000
新しい属性を導入して、VoiceOverでの経験がどのようなものかをもう一度見てみましょう。

00:14:00.000 -> 00:14:04.000
最初にスコアを表示ボタンを1回タップしてピントを合わせます...

00:14:04.000 -> 00:14:06.000
Siri: スコアを表示、ボタン。

00:14:06.000 -> 00:14:09.000
タイラー：そして、ダブルタップして押します。

00:14:09.000 -> 00:14:13.000
Siri: 6つの質問はすべて正解です。お疲れ様でした！ウェブダイアログ、閉じるボタン。

00:14:13.000 -> 00:14:15.000
タイラー：それははるかに良い経験です。

00:14:15.000 -> 00:14:23.000
VoiceOverユーザーは、aria-labelledbyのおかげですぐにスコアを聞き、すでに閉じるボタンに集中しているため、ダブルタップしてモーダルを離れることができます。

00:14:23.000 -> 00:14:26.000
そして、今日のセッションを締めくくる時間です。

00:14:26.000 -> 00:14:33.000
リッチでアクセスしやすいウェブアプリを構築し、すべてのユーザーに素晴らしい体験を提供するためのテクニックを学んだことを願っています。

00:14:33.000 -> 00:14:40.000
最新のSafariでこれらの機能を試して、見つけたバグをbugs.webkit.orgのWebKitバグトラッカーにファイルしてください。

00:14:40.000 -> 00:14:44.000
現代のウェブアクセシビリティの今日の旋風ツアーに参加してくれてありがとう。

00:14:44.000 -> 00:14:46.000
素晴らしいWWDCを！

00:14:46.000 -> 23:59:59.000
。

