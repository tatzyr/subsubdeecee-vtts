WEBVTT

00:00:00.000 --> 00:00:03.000
♪まろやかなインストゥルメンタルヒップホップ音楽♪

00:00:03.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:11.000
Lais Minchillo: こんにちは、私の名前はLaisです。

00:00:11.000 --> 00:00:17.000
デビッド・シルバー:そして、私はデビッドです。そして、今年のWalletとApple Payの新機能を紹介します。

00:00:17.000 --> 00:00:27.000
私たちは2014年にApple Payを立ち上げ、店舗、オンライン、アプリ内で高速で安全でプライベートな支払いを行うための新しいベンチマークを設定しました。

00:00:27.000 --> 00:00:31.000
それ以来、私たちはApple Payを世界中に拡大してきました。

00:00:31.000 --> 00:00:38.000
Apple Payは現在72の国と地域で利用可能で、毎日100万件以上の取引を処理しています。

00:00:38.000 --> 00:00:43.000
本日、WalletとApple Payにエキサイティングな新機能とAPIを導入します。

00:00:43.000 --> 00:00:45.000
ライスはもっと教えてくれるでしょう。

00:00:45.000 --> 00:00:47.000
ライス：ありがとう、デビッド！

00:00:47.000 --> 00:00:50.000
今日のメインアジェンダを見てみましょう。 では。

00:00:50.000 --> 00:00:53.000
まず、いくつかの簡単なアップデートについて話します。

00:00:53.000 --> 00:00:59.000
1つのトランザクションで複数のマーチャントへの支払いのサポートを追加しています。

00:00:59.000 --> 00:01:10.000
また、サブスクリプションを含む自動支払いのサポートを大幅に改善しています。注文追跡を使用すると、顧客の購入後体験を向上させることができます。

00:01:10.000 --> 00:01:17.000
そして最後に、デビッドはウォレットのIDによる本人確認について話します。

00:01:17.000 --> 00:01:20.000
共有するエキサイティングなアップデートがいくつかあります。

00:01:20.000 --> 00:01:27.000
iPhoneでタップして支払うことは今年初めに発表され、米国ではiOS 15.4で発売されました。

00:01:27.000 --> 00:01:33.000
iPhoneでタップして支払うことは、非接触型決済を受け入れるための安全でプライベートで簡単な方法を提供します。

00:01:33.000 --> 00:01:39.000
これをアプリに簡単に統合して、シームレスかつ安全に非接触型決済を受け入れることができます。

00:01:39.000 --> 00:01:45.000
これには、Apple Pay、非接触型クレジットカードとデビットカード、その他のデジタルウォレットが含まれます。

00:01:45.000 --> 00:01:53.000
取引はiPhoneをタップするだけで完了し、追加のハードウェアや決済端末が不要になります。

00:01:53.000 --> 00:01:58.000
一方、macOS 13では、Apple Payの体験を再設計しました。

00:01:58.000 --> 00:02:06.000
昨年のiOSペイメントシートの再設計は大成功を収め、今年はmacOSに同様の体験をもたらします。

00:02:06.000 --> 00:02:13.000
SwiftUIを使用してこれを実装し、iOSと同時にmacOSに新しい機能を導入するのに役立ちました。

00:02:13.000 --> 00:02:19.000
今日導入するすべてのApple Pay機能は、Macでもサポートされています。

00:02:19.000 --> 00:02:23.000
新しいSwiftUI APIを導入しています。

00:02:23.000 --> 00:02:29.000
SwiftUIアプリでApple WalletまたはApple Payボタンに追加を統合する方がはるかに簡単になります。

00:02:29.000 --> 00:02:33.000
これらの新しいAPIは、書く必要があるコードの量を大幅に減らします。

00:02:33.000 --> 00:02:39.000
ユーザーに航空会社のパスを追加するように促すボタンを追加する方法を見てみましょう。

00:02:39.000 --> 00:02:41.000
まず、パスを作成します。

00:02:41.000 --> 00:02:45.000
正常にロードされなかったケースを処理する必要があります。

00:02:45.000 --> 00:02:51.000
これは、たとえば、パスデータの形式が間違っている場合や、適切に署名されていない場合に発生する可能性があります。

00:02:51.000 --> 00:02:56.000
次に、パスの配列でAddPassToWalletButtonを呼び出します。

00:02:56.000 --> 00:03:02.000
この例では、1つの要素のみの配列がありますが、同じボタンで複数のパスを持つことができます。

00:03:02.000 --> 00:03:12.000
結果はブールとして渡され、ユーザーがパスを追加したかどうかに基づいて、アプリ内の他のアクションを保存、記録、またはトリガーできます。

00:03:12.000 --> 00:03:15.000
この例では、私はそれを状態変数に保存しています。

00:03:15.000 --> 00:03:16.000
そして、それだけです!

00:03:16.000 --> 00:03:21.000
最小値のセット内でボタンのサイズとスタイルをカスタマイズすることもできます。

00:03:21.000 --> 00:03:28.000
これはデフォルトのサイズです:幅250と高さ50。

00:03:28.000 --> 00:03:32.000
あなたはそれをより広くすることもできます...

00:03:32.000 --> 00:03:35.000
...または背が高い。

00:03:35.000 --> 00:03:40.000
これは、SwiftUIでApple Walletに追加ボタンを追加する方法をまとめています。

00:03:40.000 --> 00:03:45.000
では、Apple Payボタンでペイを追加する方法を見てみましょう。

00:03:45.000 --> 00:03:52.000
まず、PKPaymentRequestクラスを使用して支払いリクエストを作成し、通常の設定を設定します。

00:03:52.000 --> 00:03:57.000
次に、authorizationChangeメソッドを作成します。

00:03:57.000 --> 00:04:01.000
これら2つのピースの準備ができたので、ボタンを表示するコードを追加しましょう。

00:04:01.000 --> 00:04:10.000
PayWithApplePayButtonへの呼び出しを追加し、ラベル、paymentRequestオブジェクト、およびauthorizationChangeメソッドを渡します。

00:04:10.000 --> 00:04:16.000
現在のデバイスでApple Payがサポートされていないケースを処理するには、フォールバックビューで渡すことができます。

00:04:16.000 --> 00:04:23.000
パスの追加ボタンと同様に、サイズとスタイルをカスタマイズすることもできます。

00:04:23.000 --> 00:04:31.000
合計で17の異なるラベルがあるので、ユースケースに合わせて支払いボタンをカスタマイズできます。

00:04:31.000 --> 00:04:38.000
これらはiOS、iPadOS、macOS、watchOSで利用できます。

00:04:38.000 --> 00:04:42.000
では、マルチマーチャントの支払いを見てみましょう。

00:04:42.000 --> 00:04:50.000
iOS 16では、同じトランザクションで異なるマーチャントに対して複数の支払いトークンを要求する機能を導入しています。

00:04:50.000 --> 00:04:56.000
これは、オンラインマーケットプレイス、旅行予約、発券サービスなどに役立ちます。

00:04:56.000 --> 00:04:59.000
例を詳しく見てみましょう。

00:04:59.000 --> 00:05:01.000
アリソンが旅行を計画していると想像してみてください。

00:05:01.000 --> 00:05:12.000
彼女は旅行代理店のウェブサイトに行き、航空券、ホテル滞在、レンタカーなど、予約する必要があるすべてのものを便利に提供しています。

00:05:12.000 --> 00:05:16.000
アリソンは合計500ドルを支払う必要があります。

00:05:16.000 --> 00:05:20.000
アリソンは旅行代理店に彼女の完全なクレジットカード情報を提供します。

00:05:20.000 --> 00:05:29.000
さて、旅行代理店がアリソンのクレジットカードに500ドルを請求し、関係する他の会社に支払うと想像するかもしれません。

00:05:29.000 --> 00:05:38.000
しかし、通常起こることは、旅行代理店がクレジットカード情報を各企業に渡すだけで、個別の請求を行います。

00:05:38.000 --> 00:05:46.000
これは機能しますが、アリソンのプライバシーとセキュリティがクレジットカード情報を共有するのは素晴らしいことではありません。

00:05:46.000 --> 00:05:55.000
これで、新しいマルチマーチャント支払いAPIを使用すると、取引に関与する各マーチャントの支払いトークンをリクエストすることができます。

00:05:55.000 --> 00:06:03.000
これらの支払いトークンを使用して、関係する複数の企業は、それぞれ彼女が承認した関連金額をアリソンに請求することができます。

00:06:03.000 --> 00:06:12.000
アリソンは、Apple Payが提供するプライバシーとセキュリティの利点を活用しながら、旅行の予約と支払いができます。

00:06:12.000 --> 00:06:18.000
支払いシートが更新され、取引に関与するサブマーチャントの内訳を顧客に表示しました。

00:06:18.000 --> 00:06:22.000
お客様は合計フィールドをタップして、支払いの概要に移動できます。

00:06:22.000 --> 00:06:30.000
ここでは、取引に関与するすべての商人の内訳と、それぞれに承認された金額を見ることができます。

00:06:30.000 --> 00:06:35.000
では、アプリにマルチマーチャントの支払いを追加する方法を見てみましょう。

00:06:35.000 --> 00:06:43.000
まず、PKPaymentRequestクラスを使用して支払いリクエストを作成し、通常の設定を設定します。

00:06:43.000 --> 00:06:48.000
次に、合計を含む支払いの要約項目を追加します。

00:06:48.000 --> 00:06:58.000
次に、新しいPKPaymentTokenContextクラスを使用して、トランザクションに関与する追加のマーチャントごとに支払いトークンコンテキストを作成します。

00:06:58.000 --> 00:07:04.000
各マーチャントの詳細と、それぞれに承認する金額を提供します。

00:07:04.000 --> 00:07:09.000
最後に、支払い要求に支払いトークンのコンテキストを設定します。

00:07:09.000 --> 00:07:19.000
すべての支払いトークンコンテキストの金額の合計は、支払い要求自体の合計金額以下でなければならないことに注意してください。

00:07:19.000 --> 00:07:28.000
また、アプリでそのマーチャントの支払いトークンを要求するときはいつでも、常に同じマーチャントに同じ外部識別子を使用する必要があります。

00:07:28.000 --> 00:07:36.000
ウェブ上でApple Payでマルチマーチャント決済を採用するには、Apple Pay JS APIのドキュメントをご覧ください。

00:07:36.000 --> 00:07:41.000
では、自動支払いの改善を見てみましょう。

00:07:41.000 --> 00:07:50.000
iOS 16では、ウォレットアプリから直接、マーチャントで設定した自動支払いを表示および管理する機能を導入しています。

00:07:50.000 --> 00:08:05.000
このリリースでは、サブスクリプション、分割払い、定期的な請求などを含む定期的な支払いと、ストアカード残高のチャージなどの自動リロード支払いの2種類の自動支払いをサポートしています。

00:08:05.000 --> 00:08:12.000
支払いリクエストを行う際に自動支払いの設定をリクエストできるように、新しいAPIを導入しています。

00:08:12.000 --> 00:08:24.000
また、顧客のApple IDに関連付けられた新しい種類の支払いトークンであるApple Payマーチャントトークンも導入しています。これにより、継続的に顧客に請求をより確実に行うことができます。

00:08:24.000 --> 00:08:29.000
Apple Payのマーチャントトークンを詳しく見て、どのように役立つかを見てみましょう。

00:08:29.000 --> 00:08:34.000
ジュリーがiPhoneでApple Payを使ってブッククラブの会費を支払っていると想像してみてください。

00:08:34.000 --> 00:08:46.000
ブッククラブは支払い要求を行い、ジュリーが支払いを承認すると、ブッククラブは支払いトークンを受け取り、毎月それを使ってジュリーに会費を請求することができます。

00:08:46.000 --> 00:08:51.000
この支払いトークンは、ジュリーが支払いを承認するために使用したデバイスにリンクされています。

00:08:51.000 --> 00:08:55.000
しかし、ジュリーが新しいiPhoneを手に入れたらどうなりますか?

00:08:55.000 --> 00:09:04.000
新しい自動支払い機能により、ジュリーの支払いネットワークがサポートしている場合、ブッククラブは代わりにApple Payマーチャントトークンを受け取ります。

00:09:04.000 --> 00:09:14.000
この支払いトークンは、彼女のiPhoneではなく、ジュリーのApple IDに結び付けられており、継続的な承認のためのより良い保証を提供します。

00:09:14.000 --> 00:09:23.000
これは、ジュリーがiPhoneをアップグレードしたり、現在の携帯電話をリセットしたりした場合、ブッククラブはジュリーに毎月の会費を確実に請求し続けることができることを意味します。

00:09:23.000 --> 00:09:36.000
これらの種類の支払いにApple Payを受け入れる場合は、顧客に確実に請求し続け、サービスの中断を避けるために、自動支払いを採用することをお勧めします。

00:09:36.000 --> 00:09:41.000
このリリースでサポートする自動支払いの最初のタイプは、定期的な支払いです。

00:09:41.000 --> 00:09:51.000
定期的な支払いには、毎週、毎月、または毎年などの定期的なスケジュールで請求される固定または変動額があります。

00:09:51.000 --> 00:09:57.000
これらの支払いは、特定の日に終了することも、キャンセルされるまで継続することもできます。

00:09:57.000 --> 00:10:01.000
試用期間または入門期間もサポートされています。

00:10:01.000 --> 00:10:08.000
サブスクリプション、分割払いプラン、および通常の請求は、このタイプの支払いに最適です。

00:10:08.000 --> 00:10:14.000
自動支払いを使用してアプリで定期的な支払いを設定する方法を見てみましょう。 アプリ内での定期的な支払いを設定する方法を見てみましょう。

00:10:14.000 --> 00:10:22.000
PKRecurringPaymentSummaryItemクラスを使用して、定期的な支払いの金額と期間を指定することから始めます。

00:10:22.000 --> 00:10:30.000
定期的な支払いの場合、通常の請求期間と導入期間または試用期間の両方を指定できます。

00:10:30.000 --> 00:10:40.000
startDateとendDateのプロパティを使用して、試用期間が終了し、通常の請求期間がいつ開始されるかを示すことができます。

00:10:40.000 --> 00:10:47.000
次に、新しいPKRecurringPaymentRequestクラスを使用して recurringPaymentRequestを作成します。

00:10:47.000 --> 00:10:59.000
支払いの説明、通常の請求期間、および顧客が定期的な支払いの支払い方法を更新または削除できるWebページに管理URLを提供します。

00:10:59.000 --> 00:11:09.000
オプションで、トライアル請求期間と請求契約テキストを提供して、顧客への支払い条件を説明することもできます。

00:11:09.000 --> 00:11:21.000
最後に、オプションで、サーバーが発行された場合、支払いのApple Payマーチャントトークンに関するライフサイクル通知を受信できるtokenNotificationURLを提供できます。

00:11:21.000 --> 00:11:27.000
たとえば、カード発行者またはユーザーがトークンを削除した場合に通知を受け取ることができます。

00:11:27.000 --> 00:11:36.000
マーチャントトークンライフサイクル通知の詳細については、Apple Payマーチャントトークン管理APIのドキュメントを参照してください。

00:11:36.000 --> 00:11:42.000
最後に、paymentRequestオブジェクトに recurringPaymentRequestを設定します。

00:11:42.000 --> 00:11:49.000
サマリーアイテムに関する簡単なメモ、定期的な支払いは支払いリクエストのサマリーアイテムに自動的に追加されません。

00:11:49.000 --> 00:11:54.000
したがって、必ず要約項目配列に項目を追加してください。

00:11:54.000 --> 00:11:59.000
支払い要求の合計は、顧客に請求される最初の金額でなければなりません。

00:11:59.000 --> 00:12:07.000
したがって、この例では、顧客が請求される最初の金額であるため、合計は試用期間の金額を表示するように設定されています。

00:12:07.000 --> 00:12:17.000
支払いシートには、顧客への定期的な支払いの詳細が表示され、請求の詳細セクションをタップしてさらに読むことができます。

00:12:17.000 --> 00:12:24.000
さて、このリリースでサポートしている2番目のタイプの自動支払いを見てみましょう。自動リロード支払いです。

00:12:24.000 --> 00:12:32.000
このタイプの支払いでは、残高が特定のしきい値を下回るたびに、残高が自動的に固定額で補充されます。

00:12:32.000 --> 00:12:39.000
自動リロード支払いは、店舗カードのチャージやプリペイド残高などに最適です。

00:12:39.000 --> 00:12:51.000
自動リロード支払いの設定をリクエストするには、新しいPKAutomatic ReloadPaymentSummaryItemクラスを使用して、リロードとしきい値の金額を指定することから始めます。

00:12:51.000 --> 00:13:06.000
次に、新しいPKAutomatic ReloadPaymentRequestクラスを使用してautomaticReloadPaymentRequestを作成し、定期的な支払いと同様に、支払いの説明、請求、および管理URLを渡します。

00:13:06.000 --> 00:13:13.000
オプションで、請求契約のテキストとトークン通知URLを提供することもできます。

00:13:13.000 --> 00:13:19.000
最後に、支払い要求オブジェクトに自動リロード支払い要求を設定します。

00:13:19.000 --> 00:13:27.000
繰り返しますが、要約項目に自動リロード支払いを必ず含め、支払いリクエストの合計を適切に設定してください。

00:13:27.000 --> 00:13:35.000
ウェブ上でApple Payで自動支払いを採用するには、Apple Pay JS APIのドキュメントをご覧ください。

00:13:35.000 --> 00:13:41.000
自動リロード支払いが顧客の支払いシートに表示される方法は次のとおりです。

00:13:41.000 --> 00:13:50.000
最後に、アプリで自動支払いを採用する際に、顧客に可能な限り最高の体験を提供するために覚えておくべきことがいくつかあります。

00:13:50.000 --> 00:13:56.000
これらは追加されないため、自動支払いの要約項目を含めることを忘れないでください。

00:13:56.000 --> 00:14:02.000
支払い要求の合計金額は、顧客に請求される最初の金額である必要があります。

00:14:02.000 --> 00:14:05.000
請求契約のテキストを短くしておく必要があります。

00:14:05.000 --> 00:14:09.000
支払いシートには最初の500文字しか表示されなくなります。

00:14:09.000 --> 00:14:14.000
請求契約のテキストは、通常の請求および法的契約に代わるものではありません。

00:14:14.000 --> 00:14:19.000
現地の定期請求法に準拠するのはあなた次第です。

00:14:19.000 --> 00:14:27.000
顧客に見せる法的契約がある場合は、支払いシートを提示する前に顧客に表示することを意味するかもしれません。

00:14:27.000 --> 00:14:32.000
1つのトランザクションで1種類の自動支払いのみをリクエストできます。

00:14:32.000 --> 00:14:37.000
また、自動支払いはマルチマーチャントの支払いでは使用できません。

00:14:37.000 --> 00:14:52.000
最後に、支払いのために発行されたApple Payマーチャントトークンのライフサイクル通知を受け取りたい場合は、必ずトークン通知URLを提供し、サーバーでApple Payマーチャントトークン管理APIを採用してください。

00:14:52.000 --> 00:14:57.000
これらの新しいAPIとApple Payマーチャントトークンの利点を気に入っていただけると思います。

00:14:57.000 --> 00:15:03.000
以下は、自動支払いのサポートを採用するパートナーのほんの一部です。

00:15:03.000 --> 00:15:14.000
Apple Payマーチャントトークンは、American Express、Discover、Mastercard、Visaによってサポートされ、将来的には他の決済ネットワークもサポートされます。

00:15:14.000 --> 00:15:20.000
購入後の体験を向上させるために、注文追跡を導入できることを嬉しく思います。

00:15:20.000 --> 00:15:26.000
iOS 16の新機能で、注文追跡により、ユーザーは参加加盟店との注文を追跡できます。

00:15:26.000 --> 00:15:34.000
ウォレットは、アクティブな注文、最近完了した注文、過去の注文の直感的な概要を提供します。

00:15:34.000 --> 00:15:38.000
私は現在、いくつかのベーカリーグッズの単一のアクティブな注文を持っています。

00:15:38.000 --> 00:15:42.000
私の注文はまだ処理中です。後でそれに戻ります。

00:15:42.000 --> 00:15:47.000
とりあえず、ペットアベニューから猫用のおもちゃやアクセサリーを買いたいです。

00:15:47.000 --> 00:15:50.000
私はApple Payでチェックアウトすることを選択します。

00:15:50.000 --> 00:15:55.000
支払いを承認した直後に、ウォレットで注文を追跡する通知が届きます。

00:15:55.000 --> 00:16:02.000
その通知とやり取りすると、現在のステータスを確認できる注文の詳細が表示されます。

00:16:02.000 --> 00:16:09.000
配送情報や追跡情報、注文したラインアイテムのリストなど、注文状況を見ることができます。

00:16:09.000 --> 00:16:18.000
さらに以下では、ペットアベニューに連絡し、支払い情報を確認し、ペットアベニューのアプリに戻るための複数のオプションがあります。

00:16:18.000 --> 00:16:25.000
さて、ペットアベニューが着信注文の処理が本当に速く、彼らはちょうど私のアイテムを出荷したと想像してください。

00:16:25.000 --> 00:16:30.000
ペットアベニューが私の注文を出荷するとすぐに、彼らは利用可能な情報を更新しました。

00:16:30.000 --> 00:16:36.000
ステータスが「オン・ザ・ウェイ」に変更され、配達予定日は6月10日です。

00:16:36.000 --> 00:16:41.000
また、出荷のカスタムメッセージと追跡情報も含まれていました。

00:16:41.000 --> 00:16:43.000
ああ、私のベーキンググッズを覚えていますか？

00:16:43.000 --> 00:16:46.000
私はちょうど彼らがピックアップの準備ができているという通知を受け取りました。

00:16:46.000 --> 00:16:48.000
調べてみましょう。

00:16:48.000 --> 00:16:50.000
ピックアップのためにベーカリーグッズを注文しました。

00:16:50.000 --> 00:16:52.000
彼らはピックアップの準備ができています、それは素晴らしいです!

00:16:52.000 --> 00:16:59.000
Bake My Breath Awayは、私のピックアップウィンドウ、ピックアップの指示、および到着時に提示するバーコードを提供しました。

00:16:59.000 --> 00:17:03.000
注文追跡がApple Payでシームレスに機能するのを見てきました。

00:17:03.000 --> 00:17:08.000
注文追跡を顧客体験に統合する方法を見てみましょう。

00:17:08.000 --> 00:17:15.000
注文追跡を開始するには、まず、開発者アカウントで注文タイプIDを作成する必要があります。

00:17:15.000 --> 00:17:22.000
注文タイプIDは、注文情報を提供するエンティティとして組織を識別します。

00:17:22.000 --> 00:17:29.000
複数の注文タイプIDを登録できます。たとえば、複数の加盟店に代わって注文情報を提供するなどです。

00:17:29.000 --> 00:17:32.000
注文タイプID証明書も作成します。

00:17:32.000 --> 00:17:38.000
証明書を使用して、注文パッケージを作成し、注文を更新します。

00:17:38.000 --> 00:17:41.000
注文は注文パッケージとして配布されます。

00:17:41.000 --> 00:17:46.000
注文パッケージには、注文のすべてのメタデータと情報が含まれています。

00:17:46.000 --> 00:17:53.000
出荷、ピックアップ、マルチフルフィルメント注文など、幅広いシナリオを表すことができます。

00:17:53.000 --> 00:17:58.000
注文パッケージには、ロゴやラインアイテムの画像などの画像も含まれています。

00:17:58.000 --> 00:18:03.000
また、ローカリゼーションを追加して、多様な顧客をサポートすることもできます。

00:18:03.000 --> 00:18:08.000
すべての注文パッケージは、その起源を確認するために暗号署名する必要があります。

00:18:08.000 --> 00:18:14.000
すべてが整ったら、注文パッケージは配布のために圧縮されます。

00:18:14.000 --> 00:18:17.000
このセッションに添付されているサンプル注文パッケージをチェックしてください。

00:18:17.000 --> 00:18:22.000
また、注文パッケージの詳細については、開発者ドキュメントを参照してください。

00:18:22.000 --> 00:18:25.000
ウォレットに注文を追加すると、Apple Payとシームレスに連携します。

00:18:25.000 --> 00:18:34.000
顧客が支払いを承認すると、アプリまたはWebページは支払い情報を受け取り、処理のためにサーバーに送信します。

00:18:34.000 --> 00:18:41.000
支払い情報の処理が成功すると、サーバーは注文とメタデータを作成します。

00:18:41.000 --> 00:18:47.000
その後、サーバーはその順序の詳細をアプリまたはWebページに返し、結果に含めます。

00:18:47.000 --> 00:18:53.000
注文の詳細により、デバイスはサーバーから非同期に注文を要求できます。

00:18:53.000 --> 00:18:57.000
その後、サーバーは注文パッケージをデバイスに返します。

00:18:57.000 --> 00:19:04.000
サーバーが注文を作成するときは、注文タイプIDの名前空間内で一意の注文IDを割り当てます。

00:19:04.000 --> 00:19:08.000
サーバーは安全な認証トークンも生成する必要があります。

00:19:08.000 --> 00:19:12.000
これは、注文の詳細の一部である共有秘密です。

00:19:12.000 --> 00:19:17.000
デバイスは、注文を要求するときにトークンを使用して自分自身を認証します。

00:19:17.000 --> 00:19:22.000
支払い承認結果を返す例を見てみましょう。 支払い承認結果を返します。

00:19:22.000 --> 00:19:29.000
顧客が支払いを承認すると、アプリは支払い情報をサーバーに送信し、注文を作成するように要求します。

00:19:29.000 --> 00:19:36.000
サーバーの結果が成功を示しているかどうかを確認し、サーバーから返されたエラーを処理します。

00:19:36.000 --> 00:19:44.000
サーバーの結果が成功を示している場合は、適切な承認結果で支払いを完了します。

00:19:44.000 --> 00:19:51.000
注文の詳細を含む支払い承認結果を返すには、まずサーバーの結果からそれらを抽出します。

00:19:51.000 --> 00:20:03.000
次に、Order Ttype ID、Order ID、サーバーへのURL、およびauthenticationTokenを使用してPKPaymentOrderDetailsオブジェクトを作成します。

00:20:03.000 --> 00:20:12.000
PKPaymentOrderDetailsオブジェクトをPKPaymentAuthorizationResultの新しいorderDetailsプロパティに割り当てます。

00:20:12.000 --> 00:20:13.000
それでおそれ！

00:20:13.000 --> 00:20:17.000
ウェブ上の注文の詳細で支払いを完了することもできます。

00:20:17.000 --> 00:20:22.000
以前と同様に、サーバーの結果から注文の詳細を抽出します。

00:20:22.000 --> 00:20:27.000
次に、支払いを完了するデータに注文の詳細を含めます。

00:20:27.000 --> 00:20:34.000
注文を更新できるようにするには、自動更新のサポートを示す注文パッケージを作成します。

00:20:34.000 --> 00:20:38.000
注文が追加されると、デバイスは更新のために登録されます。

00:20:38.000 --> 00:20:42.000
サーバーは登録に関する情報を保存する必要があります。

00:20:42.000 --> 00:20:52.000
後で、サーバーが注文を更新するときは、登録情報を使用して、更新のために登録したデバイスに通知します。

00:20:52.000 --> 00:20:58.000
デバイスがプッシュ通知を受信すると、サーバーから再び注文を要求します。

00:20:58.000 --> 00:21:03.000
その後、サーバーは更新された注文パッケージをデバイスに返します。

00:21:03.000 --> 00:21:07.000
あなたの顧客とあなただけが、彼らが注文したものを知るべきです。

00:21:07.000 --> 00:21:10.000
私たちはプライバシーを念頭に置いて注文追跡を設計しました。

00:21:10.000 --> 00:21:15.000
注文情報は、デバイスとサーバー間で直接交換されます。

00:21:15.000 --> 00:21:20.000
注文がiCloud経由で同期されると、それらはエンドツーエンドで暗号化されます。

00:21:20.000 --> 00:21:24.000
可能な限り最高の顧客体験を提供するために、これらの慣行に従ってください。

00:21:24.000 --> 00:21:27.000
あなたのアプリをあなたが提供する注文に関連付けてください。

00:21:27.000 --> 00:21:34.000
アプリが通知を配信してインストールされている場合は、注文追跡通知を無効にすることができます。

00:21:34.000 --> 00:21:37.000
これは、通知の重複を防ぐのに役立ちます。

00:21:37.000 --> 00:21:44.000
顧客の好みに関する知識を使用して、関連するローカリゼーションのみを提供します。

00:21:44.000 --> 00:21:46.000
注文パッケージのサイズに注意してください。

00:21:46.000 --> 00:21:51.000
高価なネットワークコストを削減するために、サイズを小さく保つようにしてください。

00:21:51.000 --> 00:21:56.000
注文を更新するときは、更新を登録したデバイスに速やかに通知してください。

00:21:56.000 --> 00:22:00.000
ウォレット内の注文は、注文の実際の状態と一致する必要があります。

00:22:00.000 --> 00:22:05.000
注文追跡のためにHIGも必ずチェックしてください。

00:22:05.000 --> 00:22:09.000
プラットフォームは、注文追跡の統合をはるかに簡単にすることができます。

00:22:09.000 --> 00:22:15.000
Shopify、Narvar、Routeが秋までに注文追跡をサポートすることをお知らせします。

00:22:15.000 --> 00:22:19.000
今後数ヶ月で注文追跡をサポートするより多くのプラットフォームを探してください。

00:22:19.000 --> 00:22:24.000
注文追跡は、顧客の購入後の体験を向上させる素晴らしい方法です。

00:22:24.000 --> 00:22:31.000
自動更新により、顧客は注文の状況を常に最新の状態に保つことができます。

00:22:31.000 --> 00:22:36.000
私たちはあなたの顧客がこの経験を気に入ると信じており、すぐにあなたと一緒に注文することを楽しみにしています!

00:22:36.000 --> 00:22:39.000
さて、私はデビッドに渡します。

00:22:39.000 --> 00:22:41.000
David: ありがとう、Lais!

00:22:41.000 --> 00:22:48.000
iOS 16のウォレットのIDに追加した新機能について話すのがとても楽しみです。

00:22:48.000 --> 00:22:52.000
今年初めにiOS 15.4でWalletでIDを立ち上げました。

00:22:52.000 --> 00:22:58.000
サポートされている米国の州のユーザーは、運転免許証または州IDをウォレットに追加できます。

00:22:58.000 --> 00:23:04.000
ウォレットのIDは、ユーザーの物理的なIDと同じ発行機関によって発行されます。

00:23:04.000 --> 00:23:10.000
米国では、それは彼らの州の自動車省または同等の組織です。

00:23:10.000 --> 00:23:21.000
iOS 16では、アプリやアプリクリップがユーザーの年齢や身元を確認するためにウォレットのIDから情報を要求できる新しいAPIを追加しました。

00:23:21.000 --> 00:23:32.000
アプリは情報を要求し、ユーザーはリクエストを確認して承認し、アプリは復号化と検証のためにサーバーに応答を送信します。

00:23:32.000 --> 00:23:35.000
ユーザーのIDからいくつかのデータ要素を要求できます。

00:23:35.000 --> 00:23:54.000
これらには、名前、住所、生年月日、写真（肖像画と呼ばれる）、IDを発行した発行機関、物理的なIDの番号と有効期限、およびIDによって付与された運転特権（ある場合）が含まれます。

00:23:54.000 --> 00:23:58.000
IDの非常に一般的なユースケースは、誰かの年齢を確認することです。

00:23:58.000 --> 00:24:02.000
物理的なIDで、それは彼らの生年月日を見ることを意味します。

00:24:02.000 --> 00:24:08.000
しかし、生年月日は、年齢を確認するためだけに必要以上の情報を明らかにします。

00:24:08.000 --> 00:24:14.000
私の年齢をチェックしているなら、実際に私が生まれた正確な日や年、あるいは私が何歳であるかを知る必要はありません。

00:24:14.000 --> 00:24:17.000
あなたは私が十分に年をとっているかどうかを知る必要があります。

00:24:17.000 --> 00:24:21.000
ウォレットのIDを使用すると、その質問を直接尋ねることができます。

00:24:21.000 --> 00:24:33.000
アプリは、ユーザーが特定の年齢を超えているかどうかを示すブールデータ要素を要求することができ、完全な生年月日を確認するよりも、年齢確認を行うためのよりプライバシーを保護する方法を提供します。

00:24:33.000 --> 00:24:39.000
アプリがAPIを呼び出すと、シートに要求している情報が表示されます。

00:24:39.000 --> 00:24:44.000
また、その情報を保存するかどうか、どのくらいの期間保存するかも表示されます。

00:24:44.000 --> 00:24:49.000
これにより、ユーザーはアプリと情報を共有するかどうかについて情報に基づいた決定を下すことができます。

00:24:49.000 --> 00:24:56.000
Face IDまたはTouch IDを使用して明示的に承認するまで、情報は共有されません。

00:24:56.000 --> 00:25:00.000
受け取った応答には、要求した要素のみが含まれています。

00:25:00.000 --> 00:25:07.000
物理的なIDカードのスキャンなど、他の本人確認メカニズムは、IDにあるすべてのものを共有します。

00:25:07.000 --> 00:25:18.000
共有を必要なものだけに制限することで、ウォレットのIDはユーザーのプライバシーをより保護し、サーバー上で安全に保つために必要な機密情報の量を減らします。

00:25:18.000 --> 00:25:26.000
応答はIDの発行機関によって署名され、応答の情報が本物であることを簡単に確認できます。

00:25:26.000 --> 00:25:32.000
発行機関はIDを作成しますが、APIを呼び出す時点では関与していないことに注意してください。

00:25:32.000 --> 00:25:39.000
彼らは、ユーザーが自分の情報を共有するとき、または誰と共有するかを学習しません。

00:25:39.000 --> 00:25:44.000
APIを使用するには、開発者アカウントから資格をリクエストする必要があります。

00:25:44.000 --> 00:25:48.000
その後、マーチャントIDと暗号化証明書を設定する必要があります。

00:25:48.000 --> 00:25:53.000
このプロセスは、Apple Payでアプリ内支払いを設定するのと非常によく似ています。

00:25:53.000 --> 00:25:58.000
IDと証明書の使い方については、もう少し詳しくお話しします。

00:25:58.000 --> 00:26:01.000
とりあえず、検証フローについて話しましょう。

00:26:01.000 --> 00:26:04.000
高レベルでは、4つのステップで構成されています。

00:26:04.000 --> 00:26:11.000
まず、アプリはPassKitフレームワークでAPIを呼び出し、要求する情報を指定します。

00:26:11.000 --> 00:26:16.000
その後、システムはユーザーにリクエストを承認するよう促すシートを表示します。

00:26:16.000 --> 00:26:21.000
そうすると、アプリは暗号化された応答を受け取ります。

00:26:21.000 --> 00:26:27.000
その後、アプリは復号化と検証のためにその応答をサーバーに渡します。

00:26:27.000 --> 00:26:32.000
まず、PassKitでAPIを使用する方法について話しましょう。

00:26:32.000 --> 00:26:37.000
アプリがSwiftUIを使用している場合は、VerifyIdentityWithWalletButton SwiftUIビューを使用する必要があります。

00:26:37.000 --> 00:26:43.000
これにより、押されたときに本人確認フローをトリガーするボタンが表示されます。

00:26:43.000 --> 00:26:54.000
「Apple Payで支払う」ボタンや「ウォレットにパスを追加」ボタンと同様に、「ウォレットで身元を確認する」ボタンは、APIを使用してアプリ間で使い慣れた一貫した体験を提供します。

00:26:54.000 --> 00:26:58.000
4つの異なるラベルから選択して、ユースケースに合ったボタンを表示できます。

00:26:58.000 --> 00:27:05.000
利用可能なスペースに応じて、シングルラインバージョンとマルチラインバージョンを自動的に切り替えます。

00:27:05.000 --> 00:27:15.000
ボタンを作成するときは、要求する情報と返される方法を説明するPKIdentityRequestオブジェクトを指定する必要があります。

00:27:15.000 --> 00:27:18.000
それを作成する方法を見てみましょう。 では、作成方法を見てみましょう。

00:27:18.000 --> 00:27:26.000
まず、探しているデータ要素を記述するPKIdentityDrivers LicenseDescriptorを作成します。

00:27:26.000 --> 00:27:32.000
addElementsメソッドを使用して、要求する要素と、それらを保存するかどうかを指定します。

00:27:32.000 --> 00:27:39.000
addElementsメソッドを複数回呼び出して、保存する意図が異なる要素の異なるセットを指定できます。

00:27:39.000 --> 00:27:42.000
この例では、私はそれを2回呼んでいます。

00:27:42.000 --> 00:27:48.000
まず、保存されないage(atLeast:要素)を追加します。

00:27:48.000 --> 00:27:58.000
次に、addElementsメソッドを再度呼び出して、ユーザーの givenName、familyName、およびポートレートを要求します。これらはすべて最大30日間保存できます。

00:27:58.000 --> 00:28:03.000
その後、記述子はPKIdentityRequestに入ります。

00:28:03.000 --> 00:28:07.000
次のステップは、使用するmerchantIdentifierを指定することです。

00:28:07.000 --> 00:28:13.000
merchantIdentifierは、API応答が暗号化される暗号化証明書を示します。

00:28:13.000 --> 00:28:19.000
開発者アカウントを使用して、merchantIdentifierとその暗号化証明書の両方を設定します。

00:28:19.000 --> 00:28:25.000
最後に、APIから受信した応答に関連付けられるノンスを指定する必要があります。

00:28:25.000 --> 00:28:32.000
応答のリプレイを防ぎ、特定のユーザーセッションにバインドするために使用される重要なセキュリティ機能です。

00:28:32.000 --> 00:28:37.000
ノンスをどのように管理するかは、あなた自身のセキュリティ要件に基づいて、あなた次第です。

00:28:37.000 --> 00:28:45.000
多くの場合、それはあなたのサーバーから来ています。なぜなら、後で、あなたのサーバーはノンスが有効であることを強制する責任を負うからです。

00:28:45.000 --> 00:28:50.000
これらのプロパティをすべて設定すると、PKIdentityRequestがあります。

00:28:50.000 --> 00:28:52.000
では、ボタンに戻りましょう。

00:28:52.000 --> 00:29:02.000
本人確認が利用可能な場合、ボタンがアプリに表示され、タップするとリクエストで本人確認フローが開始されます。

00:29:02.000 --> 00:29:08.000
本人確認が利用できない場合は、代わりに指定したフォールバックビューが表示されます。

00:29:08.000 --> 00:29:12.000
たとえば、このiPhoneのウォレットにIDがない場合に発生します。

00:29:12.000 --> 00:29:18.000
フォールバックビューを使用して、身元を確認する他の方法を提供できます。

00:29:18.000 --> 00:29:22.000
本人確認が利用可能で、ユーザーがボタンをタップしたと仮定しましょう。

00:29:22.000 --> 00:29:30.000
その後、システムは、要求した要素とそれらを保存する意図を含む、要求を含むシートを表示します。

00:29:30.000 --> 00:29:37.000
ユーザーは、Face IDまたはTouch IDでリクエストを承認するか、承認せずにシートを閉じることができます。

00:29:37.000 --> 00:29:42.000
その後、コードはリクエストの結果を含む結果オブジェクトを受け取ります。

00:29:42.000 --> 00:29:46.000
リクエストが承認された場合、成功結果が表示されます。

00:29:46.000 --> 00:29:56.000
これには、暗号化された応答を含むPKIdentityDocumentオブジェクトが付属しており、アプリは復号化と検証のためにサーバーに送信します。

00:29:56.000 --> 00:30:00.000
リクエストが成功しなかった場合、失敗結果が表示されます。

00:30:00.000 --> 00:30:07.000
失敗の最も一般的な原因は、リクエストが承認されなかったことです。その場合、キャンセルされたエラーが表示されます。

00:30:07.000 --> 00:30:12.000
それは、APIのSwiftUIバージョンであるVerifyIdentityWithWalletButtonでした。

00:30:12.000 --> 00:30:19.000
本人確認フローを起動し、ウォレットのIDから情報を要求するボタンを表示するために使用します。

00:30:19.000 --> 00:30:31.000
アプリでSwiftUIを使用していない場合は、PKIdentityButtonとPKIdentityAuthorization Controllerクラスを使用して同じことを達成することもできます。

00:30:31.000 --> 00:30:40.000
さて、今、あなたは情報を要求し、ユーザーは要求を承認し、アプリは暗号化された応答をサーバーに送信しました。

00:30:40.000 --> 00:30:46.000
それでは、サーバーがその応答を復号化して検証するために何をする必要があるかについて話しましょう。

00:30:46.000 --> 00:30:53.000
このトピックについては表面をざっと見るだけなので、詳細については開発者のドキュメントを確認してください。

00:30:53.000 --> 00:31:01.000
応答形式はいくつかの国際標準を使用しているので、それらにも精通することを強くお勧めします。

00:31:01.000 --> 00:31:06.000
受信する応答データは、CBORでエンコードされた暗号化エンベロープに入っています。

00:31:06.000 --> 00:31:10.000
CBORは、RFC 8949で定義されているデータ形式です。

00:31:10.000 --> 00:31:14.000
JSONに似ていますが、バイナリデータを使用してオブジェクトをエンコードします。

00:31:14.000 --> 00:31:21.000
暗号化エンベロープには、暗号化されたデータ自体とともに、復号化プロセスに必要なメタデータが含まれています。

00:31:21.000 --> 00:31:28.000
データは、RFC 9180で定義された暗号化スキームであるHPKEを使用して暗号化されます。

00:31:28.000 --> 00:31:32.000
サーバーは秘密鍵を使用してこのデータを復号化します。

00:31:32.000 --> 00:31:35.000
復号化されると、mdoc応答オブジェクトを取得します。

00:31:35.000 --> 00:31:44.000
mdoc応答は、モバイル運転免許証と州IDのISO規格であるISO 18013パート5で定義されています。

00:31:44.000 --> 00:31:48.000
Mdocレスポンスオブジェクトには、要求したデータ要素が含まれています。

00:31:48.000 --> 00:31:55.000
また、応答が本物であることを確認するためにサーバーが検証する必要がある多くのセキュリティ機能も含まれています。

00:31:55.000 --> 00:31:59.000
サーバーは復号化と検証自体を実行することに注意してください。

00:31:59.000 --> 00:32:04.000
Appleのサーバーも発行機関のサーバーも関与していません。

00:32:04.000 --> 00:32:09.000
復号化と応答の検証について話す前に、セッションのトランスクリプトについて話す必要があります。

00:32:09.000 --> 00:32:16.000
これは、応答ペイロードを特定のアプリからの特定の要求にバインドするCBOR構造です。

00:32:16.000 --> 00:32:23.000
サーバーはこの構造を構築し、復号化と検証の両方で使用する必要があります。

00:32:23.000 --> 00:32:37.000
セッションのトランスクリプトには、PKIdentityRequestで以前に使用したのと同じノンスIDとマーチャントID、開発者チームのチームID、暗号化証明書の公開鍵のSHA256ハッシュが含まれています。

00:32:37.000 --> 00:32:43.000
セッショントランスクリプトを作成するとき、サーバーは使用している入力がすべて有効であることを確認する必要があります。

00:32:43.000 --> 00:32:47.000
つまり、ノンスはすでに使用されるべきではなく、現在のユーザーに関連付けられている必要があります。

00:32:47.000 --> 00:32:52.000
他の値は、開発者アカウントで期待される値と一致する必要があります。

00:32:52.000 --> 00:32:55.000
では、暗号化されたデータの復号化について話しましょう。

00:32:55.000 --> 00:33:01.000
作成したばかりのセッショントランスクリプトと、暗号化エンベロープのメタデータが必要です。

00:33:01.000 --> 00:33:03.000
秘密鍵も必要です。

00:33:03.000 --> 00:33:09.000
これは、開発者アカウントで以前に設定した証明書に対応する秘密鍵です。

00:33:09.000 --> 00:33:15.000
ユーザー情報の機密性を保護するために、秘密鍵が非公開であることを確認する必要があります。

00:33:15.000 --> 00:33:19.000
サーバーに安全に保存し、アプリに含めないでください。

00:33:19.000 --> 00:33:25.000
秘密鍵が侵害された場合は、すぐに開発者アカウントの証明書を取り消してください。

00:33:25.000 --> 00:33:34.000
暗号化されたデータを復号化した後、2つの暗号署名と要求したデータ要素を含むmdoc応答オブジェクトを受け取ります。

00:33:34.000 --> 00:33:39.000
データ要素を使用する前に、mdocレスポンスで両方の署名を確認する必要があります。

00:33:39.000 --> 00:33:42.000
まず、発行者の署名を確認する必要があります。

00:33:42.000 --> 00:33:46.000
これは、ユーザーIDの発行機関からの署名です。

00:33:46.000 --> 00:33:54.000
この署名をチェックすることで、応答のデータが実際の発行機関からのものであり、改ざんされていないことを確認します。

00:33:54.000 --> 00:34:01.000
署名が有効であるだけでなく、信頼できる発行者証明書によって署名されていることを確認する必要があります。

00:34:01.000 --> 00:34:07.000
ウォレットのIDで使用される発行者証明書の詳細については、ドキュメントをご覧ください。

00:34:07.000 --> 00:34:11.000
次に、デバイスの署名を確認する必要があります。

00:34:11.000 --> 00:34:15.000
これは、ユーザーのiPhoneのSecure Elementのキーによって作成された署名です。

00:34:15.000 --> 00:34:22.000
あなたが受け取った応答は、発行機関が最初にIDを発行したのと同じiPhoneから来たことを証明しています。

00:34:22.000 --> 00:34:29.000
ここでは、発行者の署名でカバーされている情報とともに、セッションのトランスクリプトを再度使用する必要があります。

00:34:29.000 --> 00:34:33.000
最後に、要求したデータ要素を使用する準備が整いました。

00:34:33.000 --> 00:34:44.000
最初に発行者とデバイスの署名を確認せずにこれらの要素を使用するべきではありません。そうしないと、受信したデータが本物かどうかわからないからです。

00:34:44.000 --> 00:34:46.000
そして、これらの手順がすべて完了すれば、完了です!

00:34:46.000 --> 00:34:52.000
アプリは情報を要求し、サーバーは応答を復号化して検証しました。

00:34:52.000 --> 00:34:57.000
ウォレットにIDがない場合は、実装をテストする方法を疑問に思うかもしれません。

00:34:57.000 --> 00:35:01.000
私たちはあなたがそれを行うのを助けるためにいくつかのメカニズムを提供しました。

00:35:01.000 --> 00:35:07.000
まず、APIがモックレスポンスを返すiOSシミュレータでテストできます。

00:35:07.000 --> 00:35:12.000
この応答は実際の応答に似ていますが、実際の署名が欠けています。

00:35:12.000 --> 00:35:21.000
同様に、そのiPhoneのウォレットにIDがなくても、テストプロファイルを使用して実際のiPhoneで模擬応答を受け取ることができます。

00:35:21.000 --> 00:35:24.000
これを行う方法の詳細については、ドキュメントを参照してください。

00:35:24.000 --> 00:35:30.000
サーバーは、これらの模擬応答のいずれかを実際の応答のように扱うべきではないことに注意してください。

00:35:30.000 --> 00:35:41.000
サーバーの実装を支援するために、ドキュメントには応答の例と、復号化と検証に必要なものがすべて含まれています。

00:35:41.000 --> 00:35:47.000
そして、それがiOS 16のウォレットのIDで本人確認を行う方法です。

00:35:47.000 --> 00:35:54.000
アプリでAPIを使用する方法、サーバーで応答を処理する方法、実装をテストする方法について説明しました。

00:35:54.000 --> 00:35:59.000
Lais: 今年は、WalletとApple Payに多くの素晴らしい新機能を導入しました。

00:35:59.000 --> 00:36:07.000
これらには、マルチマーチャント支払い、自動支払いのサポートの改善、注文追跡、本人確認が含まれます。

00:36:07.000 --> 00:36:10.000
詳細については、開発者ドキュメントをご覧ください。

00:36:10.000 --> 00:36:14.000
David: 見てくれてありがとう、そして素晴らしいWWDCを！

00:36:14.000 --> 23:59:59.000
♪

