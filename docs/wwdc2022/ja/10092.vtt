WEBVTT

00:00:00.000 --> 00:00:03.000
♪まろやかなインストゥルメンタルヒップホップ音楽♪

00:00:03.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:15.000
こんにちは、認証体験チームのエンジニア、ギャレットです。

00:00:15.000 --> 00:00:23.000
そして、このビデオでは、次世代の認証技術であるパスキーについて話すことに興奮しています。

00:00:23.000 --> 00:00:28.000
しかし、まず、今日の認証技術、パスワードについて話す必要があります。

00:00:28.000 --> 00:00:33.000
あなたはおそらく、ほぼすべてのアプリやウェブサイトにサインインすることに慣れているでしょう。

00:00:33.000 --> 00:00:37.000
パスワードは安全に使用するのが本当に難しいです。

00:00:37.000 --> 00:00:45.000
私たちは皆、すべてのアカウントに強力でユニークなパスワードを作成することになっていることを知っていますが、実際に作成する人はあまりいません。

00:00:45.000 --> 00:00:55.000
アプリやウェブサイトを設計する際には、アカウントを安全に保つことと、良い体験を設計することの間には、絶え間ないトレードオフがあります。

00:00:55.000 --> 00:01:06.000
また、アプリやウェブサイトがすべてを正しく行っていても、フィッシングやパスワードの再利用などの問題は、アカウントの侵害につながる可能性があります。

00:01:06.000 --> 00:01:16.000
macOS MontereyとiOS 15では、ソリューションの開発者プレビュー（パスキー）を発表し、多くの素晴らしいフィードバックを得ました。

00:01:16.000 --> 00:01:23.000
macOS VenturaとiOS 16では、誰もがパスキーを利用できるようにすることに興奮しています。

00:01:23.000 --> 00:01:26.000
今が彼らを養子にする時です。

00:01:26.000 --> 00:01:42.000
パスキーを使用すると、ユーザーエクスペリエンスがパスワードよりも優れているだけでなく、弱くて再利用された資格情報、資格情報の漏洩、フィッシングなどのセキュリティ問題のカテゴリ全体も不可能です。

00:01:42.000 --> 00:01:45.000
そして、彼らはとても使いやすいです。

00:01:45.000 --> 00:01:47.000
お見せしましょう。

00:01:47.000 --> 00:01:51.000
お気に入りのデモアプリ、シャイニーから始めましょう。

00:01:51.000 --> 00:01:59.000
このアプリでは、1日に1枚のかわいい写真を見ることができ、典型的なパスワードベースのサインインフローがあります。

00:01:59.000 --> 00:02:04.000
ユーザー名フィールドをタップすると、アカウントの自動入力の提案が表示されます。

00:02:04.000 --> 00:02:08.000
それを選択して、サインインします。

00:02:08.000 --> 00:02:12.000
その後、パスワードを入力できます。

00:02:12.000 --> 00:02:20.000
その後、ワンタイムコードと一緒にSMSメッセージが届くまで少し待ちます。

00:02:20.000 --> 00:02:22.000
そこにあります。

00:02:22.000 --> 00:02:25.000
そして最終的に、私はサインインしました。

00:02:25.000 --> 00:02:33.000
いくつかの手順がかかりましたが、オートフィルとパスワードマネージャーの助けを借りて、私はそこに着くことができました。

00:02:33.000 --> 00:02:37.000
サインインしたので、このアカウントにパスキーを追加します。

00:02:37.000 --> 00:02:41.000
アカウント管理、パスキーを追加します。

00:02:41.000 --> 00:02:45.000
ここでは、パスキーを作成するためのシステムシートを取得します。

00:02:45.000 --> 00:02:47.000
続けてください。

00:02:47.000 --> 00:02:48.000
完了！

00:02:48.000 --> 00:03:06.000
数回タップするだけで、私のデバイスは私のアカウントのユニークで暗号的に強力なキーペアを生成し、iCloudキーチェーンに保存したので、macOS VenturaとiOS 16を実行しているすべてのデバイスで同期して動作します。

00:03:06.000 --> 00:03:11.000
今、私はパスキーを持っているので、それがどれほど使いやすいかをお見せしましょう。

00:03:11.000 --> 00:03:18.000
サインアウトして、先ほど使用したのと同じサインインフォームに戻ります。

00:03:18.000 --> 00:03:21.000
以前のようにユーザー名フィールドに焦点を合わせるつもりです。

00:03:21.000 --> 00:03:28.000
アカウント用のパスキーが保存されたので、QuickTypeバーに表示されます。

00:03:28.000 --> 00:03:31.000
それをタップするだけで、サインインします。サインインしています。

00:03:31.000 --> 00:03:34.000
一歩。

00:03:34.000 --> 00:03:42.000
パスキーを保存するときは、新しいパスワードを思いついたり、複雑な要件を満たそうとしたりする必要はありませんでした。

00:03:42.000 --> 00:03:52.000
各パスキーはシステムによって生成され、強力で単一のアカウントでのみ使用されることが保証されます。

00:03:52.000 --> 00:04:00.000
そして、私がそれでサインインしているとき、それは私が慣れている既存のサインインフローに表示することができ、それは使用する単一のタップです。

00:04:00.000 --> 00:04:10.000
そして、システムは、強力な組み込みのフィッシング耐性で、正しいアプリやウェブサイトでのみ使用できるようにします。

00:04:10.000 --> 00:04:14.000
もちろん、パスキーはウェブでも機能します。

00:04:14.000 --> 00:04:17.000
ここで私はSafariのシャイニーのウェブサイトにいます。

00:04:17.000 --> 00:04:27.000
私の携帯電話と同じように、ユーザー名フィールドに焦点を合わせると、iCloudキーチェーンのおかげで、私のパスキーはすでにそこにあり、すぐに使用できます。

00:04:27.000 --> 00:04:30.000
私がしなければならないのはTouch IDだけで、サインインしています。

00:04:30.000 --> 00:04:32.000
それでおそれ。

00:04:32.000 --> 00:04:37.000
Appleのパスキー実装は、オープンスタンダードに基づいて構築されています。

00:04:37.000 --> 00:04:49.000
私たちは、FIDOアライアンス内の他のプラットフォームベンダーと協力して、パスキーの実装が互換性のあるクロスプラットフォームであり、できるだけ多くのデバイスで動作できることを確認しています。

00:04:49.000 --> 00:04:57.000
パスキーを使用するようにアカウントをアップグレードした後も、友人のPCでサインインできます。

00:04:57.000 --> 00:05:05.000
もちろん、私の友人のPCにはパスキーがローカルに保存されていませんが、ここにユーザー名を入力できます。

00:05:05.000 --> 00:05:11.000
サインインを押すと、電話を使えるようにするシートが届きました。

00:05:11.000 --> 00:05:16.000
それから私はQRコードを取得します。それをスキャンさせてください。

00:05:16.000 --> 00:05:22.000
私の電話は、このQRコードがパスキーでサインインするためのものであることを認識しています。

00:05:22.000 --> 00:05:29.000
このオプションを選択すると、私の電話とブラウザは互いに安全に接続されます。

00:05:29.000 --> 00:05:34.000
今、私はただ続けることができ、サインインしています。

00:05:34.000 --> 00:05:43.000
このクロスプラットフォームのサインイン体験は、パスキーの背後にある標準の一部である一流のシステム機能です。

00:05:43.000 --> 00:05:49.000
表面的には、信じられないほどシンプルに見えますが、これは単なるQRコードではありません。

00:05:49.000 --> 00:06:07.000
舞台裏では、デバイスはローカルキー契約を実行し、近接性を証明し、エンドツーエンドの暗号化された通信チャネルを確立し、すべて簡単ですが、パスキーの強力なフィッシング抵抗を維持する方法でサインインできるようにします。

00:06:07.000 --> 00:06:14.000
どのデバイスでも自分のアカウントに安全にサインインできるようにするのに最適です。

00:06:14.000 --> 00:06:22.000
パスワード交換のもう1つの重要な機能は、2人以上の間でアカウントを共有する機能です。

00:06:22.000 --> 00:06:28.000
パスキーを他の人と共有するには、AirDropを使用できます。

00:06:28.000 --> 00:06:35.000
私のパートナーと私はまた、私たちが共有するシャイニーのアカウントを持っていますが、私はすでにパスキーを使用するようにアップグレードしました。

00:06:35.000 --> 00:06:43.000
パスキーを使用すると、資格情報は私が入力できるものではありませんが、それでも信頼できる人と共有することができます。

00:06:43.000 --> 00:06:48.000
私の電話で、口座の詳細を開きます。

00:06:48.000 --> 00:06:54.000
これは、パスワードとパスキーの両方を使用する私のすべてのアカウントです。

00:06:54.000 --> 00:06:58.000
共有アカウントをタップして、詳細を表示できます。

00:06:58.000 --> 00:07:04.000
ここでは、保存したパスキーに関する情報を入手したり、このアカウントにメモを追加したりできます。

00:07:04.000 --> 00:07:08.000
パスキーも共有できます。

00:07:08.000 --> 00:07:09.000
私のパートナーの電話があります。

00:07:09.000 --> 00:07:14.000
私は先に進んでそれを選択します。

00:07:14.000 --> 00:07:19.000
今、私のパートナーもパスキーを持っています。

00:07:19.000 --> 00:07:25.000
そして、どこでもパスキーを使うのは簡単です。

00:07:25.000 --> 00:07:29.000
パスキーを使った経験について先ほどおきました。

00:07:29.000 --> 00:07:36.000
次に、パスキーとは何か、それらを使用する際のインターフェイスのガイドラインについて説明します。

00:07:36.000 --> 00:07:52.000
次に、オートフィルを利用して、アプリやウェブサイトの既存のサインインフローにパスキーを統合する方法と、サインインプロセスをさらに合理化できる追加のオプションを紹介します。

00:07:52.000 --> 00:08:04.000
その後、パスキーの仕組みについてさらに技術的な詳細を説明し、最後にパスキーと多要素認証について説明します。

00:08:04.000 --> 00:08:07.000
まず、パスキーの設計です。

00:08:07.000 --> 00:08:15.000
パスキーについて話すことになると、何よりもまず、パスキーはパスワードの代替品です。

00:08:15.000 --> 00:08:23.000
サインインが速く、使いやすく、はるかに安全です。

00:08:23.000 --> 00:08:29.000
アプリやウェブサイトでパスキーを参照する方法に関するガイドラインをいくつか紹介します。

00:08:29.000 --> 00:08:33.000
「パスキー」は、一般的なユーザーに表示される用語です。

00:08:33.000 --> 00:08:45.000
このビデオはAppleの実装に焦点を当てていますが、先ほど示したように、他の主要なプラットフォームはすでにパスキーに対する独自のサポートを構築し始めています。

00:08:45.000 --> 00:08:49.000
「パスワード」も「パスワード」のような一般的な名詞です。

00:08:49.000 --> 00:08:54.000
英語では、これは小文字で、「パスワード」のように複数形になることを意味します。

00:08:54.000 --> 00:09:03.000
私は自分のアカウントのパスキーを持っており、設定に移動してパスキーを持つすべてのアカウントを表示することができます。

00:09:03.000 --> 00:09:15.000
Appleプラットフォームでは、SFシンボルperson.key.badgeと.fillバリアントを使用して、システムと一致する図像を提供することもできます。

00:09:15.000 --> 00:09:24.000
アプリやウェブサイトでパスキーを提供することに関しては、まったく新しいインターフェイスを設計する必要はありません。

00:09:24.000 --> 00:09:30.000
ユーザー名フィールドは、今日のほとんどのアプリとウェブサイトのサインインの中心点です。

00:09:30.000 --> 00:09:40.000
ほとんどすべての人が使い方を知っており、多くのアプリやウェブサイトがすでにそれを利用して、アカウントごとのサインイン体験を調整しています。

00:09:40.000 --> 00:09:45.000
現在、ユーザー名フィールドには別の大きな機能があります。

00:09:45.000 --> 00:09:55.000
パスキーはサインインの仕組みに関する新しいパラダイムをもたらしますが、パスワードからの移行もスムーズで簡単である必要があります。

00:09:55.000 --> 00:10:10.000
自動入力を使用してパスキーをファーストクラスの機能として提示し、使い慣れ親しみ、人々が使用方法を知っているインターフェイスで、既存のサインインフローに直接ドロップできるようになりました。

00:10:10.000 --> 00:10:15.000
自動入力でパスキーを提示することは、それらを使用すべき主な方法です。

00:10:15.000 --> 00:10:25.000
しかし、より高度な用途のために、Appleプラットフォームには、パスキーでサインインするための幅広い追加UIオプションもあります。

00:10:25.000 --> 00:10:30.000
パスキーの使用を開始し、自動入力で提示する方法は次のとおりです。

00:10:30.000 --> 00:10:37.000
パスキーは、WebAuthentication（またはWebAuthn標準）に基づいて構築され、公開鍵暗号を使用します。

00:10:37.000 --> 00:10:46.000
タイプ可能な単語や文字列を持つのではなく、アカウントごとに一意の暗号鍵のペアが生成されます。

00:10:46.000 --> 00:10:52.000
パスキーサインインを実行するには、サーバーのバックエンドでWebAuthnを採用する必要があります。

00:10:52.000 --> 00:10:59.000
標準のWebAuthnサーバーの実装は、パスキーで動作する必要があります。

00:10:59.000 --> 00:11:08.000
Appleプラットフォームのアプリでは、パスキーはAuthenticationServicesフレームワークのASAuthorization APIファミリーの一部です。

00:11:08.000 --> 00:11:17.000
これは、パスワード、セキュリティキー、Appleとのサインインなど、あらゆる種類の異なる資格情報を操作するためのAPIです。

00:11:17.000 --> 00:11:30.000
また、このAPIをさらに柔軟にし、既存のサインインフローにシームレスに収めるために、自動入力サポートなど、使用できる新しい方法をいくつか追加しました。

00:11:30.000 --> 00:11:39.000
アプリでパスキーの使用を開始するには、まず、webcredentialsサービスを使用して、関連するドメインを設定する必要があります。

00:11:39.000 --> 00:11:47.000
詳細については、「アプリのパスワード自動入力の紹介」と「ユニバーサルリンクの新機能」のビデオをご覧ください。

00:11:47.000 --> 00:11:54.000
アプリのインターフェースで、ユーザー名フィールドにユーザー名textContentTtypeが使用されていることを確認してください。

00:11:54.000 --> 00:11:59.000
これにより、システムはパスキーの提案を提供する場所を知ることができます。

00:11:59.000 --> 00:12:05.000
それが設定されたら、自動入力支援パスキー要求を開始するために必要なコードは次のとおりです。

00:12:05.000 --> 00:12:09.000
あなたがそれを分解するとき、それはほんの簡単なステップです。

00:12:09.000 --> 00:12:16.000
WebAuthnリクエストと同様に、まずサーバーからチャレンジを取得する必要があります。

00:12:16.000 --> 00:12:19.000
次に、プロバイダーとリクエストを作成します。

00:12:19.000 --> 00:12:28.000
ASAuthorizationPlatformPublicKey CredentialProviderは、パスキー要求を操作するためのASAuthorizationProviderです。

00:12:28.000 --> 00:12:38.000
WebAuthn用語では、アサーションはサインイン時に使用されるため、ここでは既存のパスキーでサインインするためのアサーション要求を作成しています。

00:12:38.000 --> 00:12:42.000
ASAuthorizationControllerは、実際に要求を処理するものです。

00:12:42.000 --> 00:12:50.000
パスキー要求でインスタンスを作成し、そのデリゲートとpresentationContextProviderを設定します。

00:12:50.000 --> 00:12:56.000
そして最後に、performAutoFillAssistedRequestsを呼び出すと、リクエストを開始します。

00:12:56.000 --> 00:13:05.000
このリクエストがアプリで実行されている間、ユーザー名フィールドがフォーカスされるたびに、システムはQuickTypeバーで利用可能なパスキーを提供します。

00:13:05.000 --> 00:13:15.000
キーボードが表示されたときにパスキーが準備できるように、ユーザー名フィールドがフォーカスされる前に、ビューの寿命の早い段階でこのリクエストを開始してください。

00:13:15.000 --> 00:13:26.000
QuickTypeバーの項目を選択すると、Face IDが呼び出され、サインインを完了するためのASAuthorizationController Delegateコールバックを受け取ります。

00:13:26.000 --> 00:13:29.000
テキストフィールドには実際には何も入力されません。

00:13:29.000 --> 00:13:37.000
任意の資格情報タイプの承認が成功すると、didCompleteWithAuthorizationコールバックが返されます。

00:13:37.000 --> 00:13:41.000
最初にすべきことは、取得した資格情報の種類を確認することです。

00:13:41.000 --> 00:13:50.000
パスキーサインインの場合、ASAuthorizationPlatformPublicKey CredentialAssertionになります。

00:13:50.000 --> 00:13:55.000
アサーションオブジェクトには、バックエンドでサインインを検証するために必要なフィールドが含まれます。

00:13:55.000 --> 00:14:01.000
値を読み、サーバーで確認し、サインインを完了する必要があります。

00:14:01.000 --> 00:14:04.000
自動入力支援パスキーリクエストは強力です。

00:14:04.000 --> 00:14:11.000
その小さなコード変更により、アプリのサインインフローは多くの柔軟性を提供します。

00:14:11.000 --> 00:14:19.000
もちろん、主なケースは、QuickTypeバーからパスキーの提案を選択して、そのパスキーですばやくサインインすることです。

00:14:19.000 --> 00:14:24.000
これはあなたが最も頻繁に起こることを期待すべきことです。

00:14:24.000 --> 00:14:26.000
しかし、他の選択肢もあります。

00:14:26.000 --> 00:14:33.000
私が今お見せしたコードは、追加の変更なしで近くのデバイスからのパスキーサインインも許可しています。

00:14:33.000 --> 00:14:43.000
キーアイコンをタップすると、利用可能なすべてのパスキーとパスワードを一覧表示するビューが表示され、近くのデバイスでサインインするオプションが表示されます。

00:14:43.000 --> 00:14:47.000
その後、クロスデバイスパスキーサインインを実行できます。

00:14:47.000 --> 00:14:55.000
どちらの場合も、パスキーを使用すると、同じASAuthorizationController Delegateコールバックを受け取ります。

00:14:55.000 --> 00:14:59.000
これをサポートするためにあなたがする必要がある特別なことは何もありません。

00:14:59.000 --> 00:15:05.000
ユーザーがまだパスキーを持っていない場合は、以前のようにログインフォームを使用できます。

00:15:05.000 --> 00:15:11.000
彼らはQuickTypeバーでパスワードの提案を得るか、フィールドに入力することができます。

00:15:11.000 --> 00:15:21.000
パスワード項目が選択されている場合、資格情報は引き続きテキストフィールドに入力され、実行中のリクエストをキャンセルできます。

00:15:21.000 --> 00:15:30.000
既存のサインインフローに直接ドロップし、ユーザーにとって非常に簡単にできるように、このAPIを設計しました。

00:15:30.000 --> 00:15:46.000
すでにパスキーを使用するようにアップグレードした人が、自動入力提案を使用する代わりにユーザー名を入力することを決定した場合は、自動入力要求をキャンセルし、ASAuthorizationControllerを使用してモーダルパスキーサインインシートを提示する必要があります。

00:15:46.000 --> 00:15:53.000
ここからは、まだワンタップで、同じASAuthorizationController Delegateコールバックを受け取ります。

00:15:53.000 --> 00:15:56.000
これが以前のコードです。

00:15:56.000 --> 00:16:07.000
これを自動入力要求からモーダル要求に切り替えるには、この performAutoFillAssistedRequests メソッド呼び出しを performRequests() 呼び出しと交換するだけです。

00:16:07.000 --> 00:16:16.000
これにより、利用可能なすべてのパスキーと、近くのデバイスからパスキーを使用するオプションを含むモーダルシートが表示されます。

00:16:16.000 --> 00:16:22.000
これらは、パスキーをサポートするためにアプリで必要な唯一のコード変更です。

00:16:22.000 --> 00:16:28.000
Webプラットフォームは、自動入力支援リクエストとモーダルパスキーリクエストの両方もサポートしています。

00:16:28.000 --> 00:16:36.000
ウェブ上では、パスキーは標準のWebAuthn APIを介して使用され、セキュリティキーにも使用されます。

00:16:36.000 --> 00:16:54.000
アプリと同様に、自動入力支援リクエストを採用することで、Touch IDだけですばやくサインインしたり、利用可能なすべてのパスキーとパスワードにアクセスしたり、近くのデバイスからパスキーを使用したりできます。

00:16:54.000 --> 00:17:10.000
まず、パスワードとパスキーの両方の提案が適切な場所に表示されるように、ユーザー名とwebauthnオートコンプリート詳細トークンの両方でWebページのユーザー名フィールドに注釈を付けるようにしてください。

00:17:10.000 --> 00:17:16.000
それが完了したら、JavaScriptの典型的なWebAuthnサインインです。

00:17:16.000 --> 00:17:22.000
WebAuthnでは、自動入力スタイルのリクエストは条件付きメディエーションを使用して呼び出されます。

00:17:22.000 --> 00:17:29.000
標準のJavaScript機能検出を使用して、それが利用可能かどうかを確認することから始めるべきです。

00:17:29.000 --> 00:17:33.000
もしそうなら、リクエストを進めることができます。

00:17:33.000 --> 00:17:40.000
ネイティブAPIと同様に、サーバーからフェッチされたチャレンジを使用してリクエストを行うことから始めます。

00:17:40.000 --> 00:17:47.000
自動入力支援リクエストにするには、メディエーション:「条件付き」パラメータをオプションに追加します。

00:17:47.000 --> 00:17:53.000
次に、navigator.credentials .get を使用してリクエストを開始します。

00:17:53.000 --> 00:17:56.000
.Get呼び出しは約束を返します。

00:17:56.000 --> 00:18:04.000
解決すると、アサーションオブジェクトを受け取り、サーバーに送り返して確認し、サインインを完了します。

00:18:04.000 --> 00:18:15.000
アプリと同様に、誰かがパスキーを持つアカウントのユーザー名を手動で入力した場合は、APIを使用してモーダルサインインシートを表示する必要があります。

00:18:15.000 --> 00:18:22.000
モーダルリクエストに切り替えるには、メディエーション「条件付き」パラメータを削除するだけです。

00:18:22.000 --> 00:18:29.000
WebAuthnを使用する際に注意すべき点の1つは、Appleプラットフォームがユーザー検証（またはUVをどのように処理するかです。

00:18:29.000 --> 00:18:39.000
UVは、オーセンティケータが現在のユーザーがデバイスの所有者であることを確認しようとしたかどうかを示すWebAuthn応答のブールフィールドです。

00:18:39.000 --> 00:18:47.000
Appleデバイスでは、1の値は、生体認証、またはパスワードまたはパスコードが使用されたことを示します。

00:18:47.000 --> 00:18:55.000
バイオメトリクスが利用可能な場合、Appleのプラットフォームは常にパスキーにUVを必要とするので、それについて心配する必要はありません。

00:18:55.000 --> 00:19:02.000
WebAuthnリクエストを行う場合、ユーザー検証要件を指定するオプションがあります。

00:19:02.000 --> 00:19:06.000
デフォルト値はuserVerification:「preferred」です。

00:19:06.000 --> 00:19:14.000
バイオメトリクスのないデバイスで悪い体験をしないように、常にデフォルト値を使用してください。

00:19:14.000 --> 00:19:18.000
ここでは、ウェブ上でパスキーを使用するための追加の注意事項をいくつか紹介します。

00:19:18.000 --> 00:19:25.000
自動入力支援リクエストを行う場合は、アプリと同じように、ページの有効期間の早い段階で作成する必要があります。

00:19:25.000 --> 00:19:32.000
モーダルWebAuthnリクエストの場合、ボタンクリックなどのユーザージェスチャーイベントからトリガーする必要があります。

00:19:32.000 --> 00:19:44.000
モーダルリクエストは、ユーザージェスチャーイベント以外のページロードごとに1回トリガーできますが、WebKitはそのページでの後続の呼び出しを制限する場合があります。

00:19:44.000 --> 00:19:52.000
自動入力要求はモーダルではないため、ユーザーのジェスチャーを必要とせず、タイムアウトがはるかに長くなります。

00:19:52.000 --> 00:19:58.000
最後に、パスキーはSafariのレガシープラットフォームオーセンティケータに取って代わっています。

00:19:58.000 --> 00:20:08.000
既存の資格情報は引き続き機能し、作成されたデバイスにバインドされますが、新しいプラットフォームの資格情報はパスキーとして作成されます。

00:20:08.000 --> 00:20:17.000
パスキーは認証ステートメントを提供しないため、登録時にレガシー資格情報と区別することができます。

00:20:17.000 --> 00:20:19.000
それはパスキーとオートフィルです。

00:20:19.000 --> 00:20:26.000
次に、サインイン体験をさらに合理化できる追加のプラットフォーム機能について説明します。

00:20:26.000 --> 00:20:34.000
自動入力支援サインインに加えて、ASAuthorization APIはより多くの便利な機能を提供します。

00:20:34.000 --> 00:20:39.000
APIの3つの追加機能と、いつ使用したいかについて説明します。

00:20:39.000 --> 00:20:43.000
パスキーで始まり、リストを許可します。

00:20:43.000 --> 00:20:52.000
ユーザー名を入力した後にモーダルパスキーシートを提示すると、デバイスに保存された複数のアカウントのパスキーがある可能性があります。

00:20:52.000 --> 00:20:56.000
利用可能なすべてのパスキーは、デフォルトでシートに表示されます。

00:20:56.000 --> 00:21:05.000
パスキー許可リストを使用して、シートに表示されるパスキーを制限して、一致するアカウントのみを提供できます。

00:21:05.000 --> 00:21:10.000
モーダルリクエストに許可リストを追加するには、まずユーザー名が必要です。

00:21:10.000 --> 00:21:17.000
そのユーザー名を使用して、一致する資格情報IDのリストを取得し、許可リストに変換できます。

00:21:17.000 --> 00:21:22.000
クレデンシャルIDは、パスキーの一意の識別子です。

00:21:22.000 --> 00:21:28.000
Webauthnサーバーには、特定のユーザー名の資格情報IDを検索する方法があるはずです。

00:21:28.000 --> 00:21:32.000
ここから、以前のようにリクエストを進めてください。

00:21:32.000 --> 00:21:42.000
今、パスキーを使用して3つのシャイニーアカウントを持っている私のデバイスでは、シートは私が使用しようとしている単一のアカウントのみを提供します。

00:21:42.000 --> 00:21:54.000
モーダルリクエストを行うときは、ユーザーがすでにユーザー名を入力している場合など、ユーザーがサインインしようとしているアカウントに関する追加のコンテキストがある場合は、許可リストを使用する必要があります。

00:21:54.000 --> 00:22:02.000
次に、現在のデバイスにパスキーが保存されていない場合に、モーダルパスキーリクエストを行うとどうなるかについて説明します。

00:22:02.000 --> 00:22:08.000
これは、許可リストを使用し、保存されたパスキーのいずれもそのリストと一致しない場合にも適用されます。

00:22:08.000 --> 00:22:23.000
デフォルトでは、モーダルパスキー要求を行うと、利用可能な一致するパスキーがない場合、モーダルシートが表示され、近くのデバイスからパスキーでサインインするためのQRコードがすぐに表示されます。

00:22:23.000 --> 00:22:30.000
これは、サインイン時に最も柔軟性を提供し、パスキーが使用されていることを知っている場合に最適なオプションです。

00:22:30.000 --> 00:22:39.000
しかし、APIには、すぐに利用可能な資格情報を優先し、存在しない場合はデリゲートコールバックで静かにフォールバックする新しいオプションがあります。

00:22:39.000 --> 00:22:47.000
これは、従来のサインインフォームを表示する前に、可能な限り既存の資格情報をすばやく提供するために使用できます。

00:22:47.000 --> 00:22:56.000
デフォルトのオプションを使用したこのモーダル要求は、現在のデバイスに一致するパスキーがない場合、QRコードの表示にフォールバックします。

00:22:56.000 --> 00:23:07.000
QRコードを取得する代わりに、preferdImmediately AvailableCredentialsオプションを使用すると、エラーを伴うデリゲートコールバックが届きます。

00:23:07.000 --> 00:23:23.000
キャンセルされたコードでASAuthorizationErrorを受け取った場合、ユーザーがシートを見て手動で却下したか、preferdImmediately AvailableCredentialsに合格し、すぐに利用できる資格情報がないことを意味します。

00:23:23.000 --> 00:23:28.000
ここから何をするかは、あなたがこれを呼び出していた文脈によって異なります。

00:23:28.000 --> 00:23:40.000
たとえば、通常のサインインフォームを表示する前にローカルの資格情報をテストする方法としてこのオプションを使用している場合、これがフォームの表示をトリガーする場所です。

00:23:40.000 --> 00:23:48.000
デバイスに少なくとも1つの一致する資格情報がある場合、使用されるオプションに関係なく、完全なモーダルシートが表示されます。

00:23:48.000 --> 00:24:06.000
また、アプリのどこかでデフォルトのフォールバックでオートフィル支援リクエストまたはモーダルリクエストを使用していることを確認してください。現在のデバイスにパスキーがない場合でも、近くのデバイスでサインインするオプションに引き続き到達できるようにします。

00:24:06.000 --> 00:24:13.000
私がカバーするASAuthorization APIの最後の機能は、結合された資格情報要求を行うことです。

00:24:13.000 --> 00:24:21.000
この例では、アプリはパスキー、パスワード、およびAppleとのサインインを要求しました。

00:24:21.000 --> 00:24:29.000
私のデバイスには、たまたま3つの異なるアカウントの3つの異なる資格情報が保存されているので、それらはすべてここに表示されます。

00:24:29.000 --> 00:24:34.000
しかし、より可能性の高いシナリオは、誰かが1つのアカウントしか持っていないということです。

00:24:34.000 --> 00:24:40.000
その場合、この同じ結合された資格情報要求は、シート内の1つのアカウントのみを提供します。

00:24:40.000 --> 00:24:47.000
既存のASAuthorizationリクエストに追加の資格情報タイプを追加するのは本当に簡単です。

00:24:47.000 --> 00:24:56.000
追加のリクエストタイプのプロバイダーとリクエストを作成し、それらの新しいリクエストをコントローラーに渡すだけです。

00:24:56.000 --> 00:25:02.000
さて、モーダルシートは、これらの資格情報タイプのいずれかから利用可能な資格情報を提供します。

00:25:02.000 --> 00:25:07.000
どの資格情報タイプが使用されているかに関係なく、同じデリゲートコールバックを取得します。

00:25:07.000 --> 00:25:15.000
受け取った資格情報の種類を確認し、その資格情報の種類に応じてサインインを完了する必要があります。

00:25:15.000 --> 00:25:21.000
そのため、ASAuthorization APIファミリのより高度な機能のいくつかをカバーしています。

00:25:21.000 --> 00:25:29.000
さて、パスキーが実際にどのように機能し、何がそれらをとても安全にするのかについて、より技術的な詳細を掘り下げます。

00:25:29.000 --> 00:25:44.000
今日パスワードでサインインすると、通常、実際に起こっていることは、そのパスワードを入力した後、ハッシュ化されてソルトされ、結果の難読化された値がサーバーに送信され、サーバーが保存されます。

00:25:44.000 --> 00:25:51.000
後で、同じハッシュ化された塩漬け値を生成することができれば、アカウントに入ることが許可されます。

00:25:51.000 --> 00:25:59.000
これは、サーバーがこのパスワードの導出を保存する責任があることを意味し、攻撃者にとって非常に価値があります。

00:25:59.000 --> 00:26:06.000
彼らがそれを手に入れることができれば、あなたのパスワードが何であるかを把握し、あなたのアカウントにアクセスすることが可能です。

00:26:06.000 --> 00:26:10.000
しかし、パスキーの仕組みは大きく異なります。

00:26:10.000 --> 00:26:16.000
パスキーは、単一の入力可能な文字列を持つのではなく、実際には関連するキーのペアです。

00:26:16.000 --> 00:26:23.000
これらのキーは、すべてのアカウントに対して、安全かつ一意にデバイスによって生成されます。

00:26:23.000 --> 00:26:27.000
1つは公開されており、サーバーに保存されています。

00:26:27.000 --> 00:26:33.000
もう1つは非公開で、サインインしてもデバイスにとどまります。

00:26:33.000 --> 00:26:36.000
公開鍵は秘密ではありません。

00:26:36.000 --> 00:26:40.000
それはあなたのユーザー名と同じくらい公開されています。

00:26:40.000 --> 00:26:44.000
秘密鍵は、実際にサインインするために必要なものです。

00:26:44.000 --> 00:26:50.000
サーバーはあなたの秘密鍵が何であるかを決して学習せず、あなたのデバイスはそれを安全に保ちます。

00:26:50.000 --> 00:26:57.000
サインインすると、サーバーはデバイスにシングルユースチャレンジを送信します。

00:26:57.000 --> 00:27:07.000
WebAuthnはさまざまなチャレンジレスポンスアルゴリズムを使用できますが、Appleプラットフォームのパスキーは標準のES256を使用します。

00:27:07.000 --> 00:27:14.000
あなたの秘密鍵だけが、あなたのアカウントの課題に対する有効な解決策を生み出すことができます。

00:27:14.000 --> 00:27:23.000
デバイスは、シグネチャと呼ばれるこのソリューションをローカルで生成し、ソリューションのみをサーバーに送り返します。

00:27:23.000 --> 00:27:28.000
あなたの秘密鍵は秘密のままで、あなたのデバイスでのみです。

00:27:28.000 --> 00:27:34.000
次に、サーバーは公開鍵を使用してソリューションを検証します。

00:27:34.000 --> 00:27:39.000
デバイスが提供したソリューションが有効な場合は、サインインしています!

00:27:39.000 --> 00:27:47.000
公開鍵を使用して、ソリューションが有効かどうかを確認できますが、ソリューション自体を生成することはできません。

00:27:47.000 --> 00:27:55.000
これは、サーバーが実際に秘密鍵が何であるかを知らなくても、あなたが正しい秘密鍵を持っていることを確認できることを意味します。

00:27:55.000 --> 00:28:06.000
また、サーバーは秘密鍵を知らないため、リークするユーザーの資格情報がないため、攻撃者にとって価値の低いターゲットです。

00:28:06.000 --> 00:28:13.000
この暗号化と鍵保護はすべて完全に透明で、デバイスによって実行されます。

00:28:13.000 --> 00:28:17.000
あなたの顧客はそれについて知り、考える必要はありません。

00:28:17.000 --> 00:28:23.000
彼らの視点から見ると、パスキーは超シンプルで、どこでも機能します。

00:28:23.000 --> 00:28:30.000
パスキーは、安全でフィッシングに強い方法でデバイス間でサインインするためにも使用できます。

00:28:30.000 --> 00:28:33.000
これがその仕組みです。

00:28:33.000 --> 00:28:34.000
ここには2つのデバイスがあります。

00:28:34.000 --> 00:28:44.000
私がサインインしているデバイスまたはウェブブラウザであるクライアントと、私のパスキーを持つデバイスであるオーセンティケータ。

00:28:44.000 --> 00:28:49.000
まず、クライアントは認証者がスキャンするQRコードを表示します。

00:28:49.000 --> 00:28:56.000
このQRコードには、使い捨ての暗号化キーのペアをエンコードするURLが含まれています。

00:28:56.000 --> 00:29:04.000
次に、オーセンティケータは、ネットワークリレーサーバーのルーティング情報を含むBluetooth広告を生成します。

00:29:04.000 --> 00:29:13.000
このローカルエクスチェンジでは、サーバーを選択してルーティング情報を共有できますが、2つの追加機能も提供します。

00:29:13.000 --> 00:29:25.000
サーバーが確認できないアウトオブバンドキー契約を実行するため、ネットワーク上のすべてのものはエンドツーエンドで暗号化され、サーバーは何も読み取ることができません。

00:29:25.000 --> 00:29:31.000
また、これら2つのデバイスが物理的に近接しているという強い主張も提供します。

00:29:31.000 --> 00:29:47.000
つまり、リモートの攻撃者はBluetooth広告を受信してローカル交換を完了できないため、電子メールで送信された、または偽のウェブサイトで生成されたQRコードは機能しません。

00:29:47.000 --> 00:29:49.000
だから、それは地元の部分です。

00:29:49.000 --> 00:29:57.000
ローカル交換とキー契約が発生すると、2つのデバイスは電話で選択したリレーサーバーに接続します。

00:29:57.000 --> 00:30:09.000
そこから、以前のキーを使用して暗号化された標準のFIDO CTAP操作を実行するため、リレーサーバーは何が起こっているのかを見ることができません。

00:30:09.000 --> 00:30:14.000
このプロセス全体は、デバイスとウェブブラウザによって実行されます。

00:30:14.000 --> 00:30:19.000
ウェブサイトは、クロスデバイス通信のどの時点でも関与していません。

00:30:19.000 --> 00:30:28.000
クロスデバイスクロスプラットフォームサインインは、パスキーを使用できる場所ならどこでも機能するシステム機能です。

00:30:28.000 --> 00:30:37.000
したがって、これは、パスキーがどのように機能し、デバイス間でもそのような強力なセキュリティ保証をどのように行うことができるかについて、より技術的な見方です。

00:30:37.000 --> 00:30:40.000
次に、多要素認証です。

00:30:40.000 --> 00:30:46.000
今日の認証について考える一般的な方法は、要因の観点からです。

00:30:46.000 --> 00:30:55.000
異なる要因は、異なる種類の攻撃に対して強いか弱いかであり、要因を組み合わせることで、より良い集団カバレッジを提供することができます。

00:30:55.000 --> 00:30:59.000
しかし、パスキーでは、もうそのように考える必要はありません。

00:30:59.000 --> 00:31:04.000
今日サインインするために使用される最も一般的な方法をいくつか紹介します。

00:31:04.000 --> 00:31:08.000
あなたの頭の中のパスワードは、ほとんどすべてに対して脆弱です。

00:31:08.000 --> 00:31:20.000
パスワードマネージャーは、ユニークで高エントロピー文字列を生成するのが得意で、デバイスの盗難に対するローカル保護があり、フィッシングに関するいくつかのヒントを提供します。

00:31:20.000 --> 00:31:29.000
SMSまたは時間ベースのコードを追加すると、状況によっては盗難やフィッシングに役立ちますが、実際にはどちらも解決しません。

00:31:29.000 --> 00:31:36.000
ただし、パスキーでは、すべてのパスキーは一意のデバイスで生成されたキーペアです。

00:31:36.000 --> 00:31:42.000
Appleデバイスでは、ローカルデバイス保護の強力な基盤の上に構築されています。

00:31:42.000 --> 00:31:48.000
パスキーはまた、フィッシングから人的要因を完全に排除します。

00:31:48.000 --> 00:31:55.000
また、サーバーには秘密鍵がないため、アプリやウェブサイトのサーバーによって漏洩することはできません。

00:31:55.000 --> 00:32:05.000
パスワードベースのサインインフローに要因を追加することは、パスワード単独よりも多くの種類の攻撃から保護できるため、理にかなっています。

00:32:05.000 --> 00:32:12.000
しかし、パスキーだけでは、追加の要因を必要としないほど多くのものから保護します。

00:32:12.000 --> 00:32:16.000
パスワードのない未来を楽しみにしています。

00:32:16.000 --> 00:32:20.000
それを実現し始める方法は次のとおりです。 始める方法は次のとおりです。

00:32:20.000 --> 00:32:26.000
まず、まだ採用していない場合は、サーバーにWebAuthnを採用する必要があります。

00:32:26.000 --> 00:32:32.000
パスキーは、標準のWebAuthnサーバーの実装で動作する必要があります。

00:32:32.000 --> 00:32:38.000
サーバーの準備ができたら、アプリやウェブサイトに新しいAPIを採用してください。

00:32:38.000 --> 00:32:50.000
自動入力支援パスキーリクエストは、既存のサインインフローに直接ドロップできます。さらに、必要に応じて、より高度なUIオプションも用意しています。

00:32:50.000 --> 00:32:56.000
そして最後に、ユーザーをパスワードから遠ざけます。

00:32:56.000 --> 00:33:05.000
パスキーは、アプリやウェブサイトに安全にサインインするという利便性とセキュリティの問題に対する業界標準のソリューションです。

00:33:05.000 --> 00:33:18.000
顧客をパスキーに誘導し、パスワードから離れることで、すべての人のセキュリティバーを上げながら、信じられないほど迅速かつ便利なサインイン体験を提供することができます。

00:33:18.000 --> 00:33:19.000
ありがとうございます。

00:33:19.000 --> 23:59:59.000
♪

