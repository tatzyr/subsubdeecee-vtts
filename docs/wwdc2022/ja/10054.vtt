WEBVTT

00:00:00.000 -> 00:00:02.000
♪インストゥルメンタルヒップホップ音楽♪

00:00:02.000 -> 00:00:09.000
♪

00:00:09.000 -> 00:00:13.000
こんにちは。私はSwiftUIチームのエンジニア、Curtです。

00:00:13.000 -> 00:00:16.000
SwiftUIには、ナビゲーション用のエキサイティングな新しいAPIがいくつかあります。

00:00:16.000 -> 00:00:23.000
私はこれらの新しいAPIでアプリを構築するのを楽しんでおり、それらをあなたと共有できることに興奮しています。

00:00:23.000 -> 00:00:31.000
これらのAPIは、Apple TV、iPhone、Apple Watchなどの基本的なスタックから、強力な複数列のプレゼンテーションまで拡張できます。

00:00:31.000 -> 00:00:42.000
新しいAPIは、プログラマティックナビゲーションとディープリンクの堅牢なサポートをもたらし、アプリに最適な構造を構築するための作品を作成できます。

00:00:42.000 -> 00:00:48.000
この講演では、SwiftUIのナビゲーションでアプリを調理するための簡単なレシピをいくつか紹介します。

00:00:48.000 -> 00:00:54.000
また、すでにSwiftUIを使用している場合は、これらの新しいAPIがワンランクアップに役立つことを願っています。

00:00:54.000 -> 00:00:59.000
新しいデータ駆動型ナビゲーションAPIに入る成分から始めます。

00:00:59.000 -> 00:01:06.000
次に、テイスティングメニューに移動します。ナビゲーションの完全なプログラム制御のためのいくつかの迅速かつ簡単なレシピ。

00:01:06.000 -> 00:01:14.000
デザートコースでは、新しいAPIを使用してアプリでナビゲーション状態を持続させるためのヒントをいくつか紹介します。

00:01:14.000 -> 00:01:20.000
以前にSwiftUIでナビゲーションを使用したことがあるなら、新しいAPIがどのように違うのか疑問に思うかもしれません。

00:01:20.000 -> 00:01:25.000
だから、掘り下げる前に、既存のAPIのいくつかを確認しましょう。

00:01:25.000 -> 00:01:31.000
既存のAPIは、他の列またはスタックに表示されるビューを送信するリンクに基づいています。

00:01:31.000 -> 00:01:35.000
たとえば、ルートビューにナビゲーションリンクのリストがあるかもしれません。

00:01:35.000 -> 00:01:40.000
これらのリンクの1つをタップすると、リンクはスタック上のビューをプッシュします。

00:01:40.000 -> 00:01:45.000
これは基本的なナビゲーションに最適で、このパターンを使い続けることができます。

00:01:45.000 -> 00:01:48.000
しかし、ルートビューに戻りましょう。

00:01:48.000 -> 00:01:55.000
既存のナビゲーションAPIでは、プログラムでリンクを表示するために、リンクにバインディングを追加します。

00:01:55.000 -> 00:02:01.000
たとえば、item.showDetailをtrueに設定することで、このリンクのビューを表示できます。

00:02:01.000 -> 00:02:06.000
しかし、これはリンクごとに個別のバインディングが必要であることを意味します。

00:02:06.000 -> 00:02:13.000
新しいAPIでは、NavigationStackと呼ばれるコンテナ全体にバインディングを持ち上げます。

00:02:13.000 -> 00:02:18.000
ここのパスは、スタックにプッシュされたすべての値を表すコレクションです。

00:02:18.000 -> 00:02:21.000
NavigationLinksはパスに値を追加します。

00:02:21.000 -> 00:02:28.000
パスを変更してディープリンクしたり、パスからすべてのアイテムを削除してルートビューにポップしたりできます。

00:02:28.000 -> 00:02:34.000
この講演では、新しいナビゲーションAPIがデータ駆動型のプログラマティックナビゲーションを可能にする方法を紹介します。

00:02:34.000 -> 00:02:38.000
パワフルで使いやすいと願っています。

00:02:38.000 -> 00:02:46.000
新しいナビゲーションAPIを使用するためのレシピに飛び込む前に、メニューにあるものを共有することが役立つと思いました。

00:02:46.000 -> 00:02:51.000
私は最近本当に料理に夢中になっていて、自分のレシピを追跡するためのアプリに取り組んでいます。

00:02:51.000 -> 00:02:55.000
私はこの情報を提示するさまざまな方法について多くのアイデアを持っています。

00:02:55.000 -> 00:02:58.000
例えば、ここに3列のアプローチがあります。

00:02:58.000 -> 00:03:01.000
最初の列では、レシピのカテゴリを選択できます。

00:03:01.000 -> 00:03:06.000
カテゴリを選択すると、2番目の列に収集したレシピが一覧表示されます。

00:03:06.000 -> 00:03:11.000
そして、レシピを選択すると、詳細領域にそのレシピの材料が表示されます。

00:03:11.000 -> 00:03:15.000
詳細エリアには、関連するレシピの選択へのリンクもあります。

00:03:15.000 -> 00:03:19.000
おばあちゃんはいつも「皮がパイを作る」と言っていました。

00:03:19.000 -> 00:03:21.000
だから、それが私たちが今日料理しているものです。

00:03:21.000 -> 00:03:24.000
私たちの材料は新しいナビゲーションAPIです。

00:03:24.000 -> 00:03:31.000
それらを掘り下げてから、それらを混ぜ合わせた特定のナビゲーションレシピを見てみましょう。

00:03:31.000 -> 00:03:45.000
新しいナビゲーションAPIは、ゲストがその構造を移動するのを助けるためにNavigationLinkの新鮮な新しい品種とともに、アプリの構造を記述するために使用できるいくつかの新しいコンテナタイプを導入します。

00:03:45.000 -> 00:03:48.000
最初の新しいコンテナはNavigationStackです。

00:03:48.000 -> 00:04:00.000
NavigationStackは、Apple Watchの「探す」、iPhoneの設定、macOS Venturaの新しいシステム設定アプリに見られるようなプッシュポップインターフェースを表しています。

00:04:00.000 -> 00:04:04.000
2番目の新しいコンテナタイプはNavigationSplitViewです。

00:04:04.000 -> 00:04:11.000
NavigationSplitViewは、MacやiPadのメールやメモなどの複数列のアプリに最適です。

00:04:11.000 -> 00:04:20.000
また、NavigationSplitViewは、iPhone、iPadのSlide Over、さらにはApple WatchやApple TVの単一列のスタックに自動的に適応します。

00:04:20.000 -> 00:04:24.000
NavigationSplitViewには2組の初期化子があります。

00:04:24.000 -> 00:04:29.000
ここに示されているように、1つのセットは、2列のエクスペリエンスを作成します。

00:04:29.000 -> 00:04:33.000
他の初期化子のセットは、3列のエクスペリエンスを作成します。

00:04:33.000 -> 00:04:45.000
NavigationSplitViewには、列の幅、サイドバーの表示をカスタマイズしたり、プログラムで列を表示したり非表示にしたりできる設定オプションのカートロードが付属しています。

00:04:45.000 -> 00:05:00.000
この講演では設定オプションについては説明しませんが、同僚のRajの講演「SwiftUI on iPad: Organize your interface」と、NavigationSplitViewをアプリにぴったりになるように調整する方法に関する素晴らしいドキュメントをチェックしてください。

00:05:00.000 -> 00:05:06.000
以前は、NavigationLinksには常にタイトルと表示するビューが含まれていました。

00:05:06.000 -> 00:05:12.000
新しい品種にはまだタイトルが含まれていますが、提示するビューではなく、価値を提示します。

00:05:12.000 -> 00:05:16.000
例えば、このリンクはアップルパイのレシピを提示しています。

00:05:16.000 -> 00:05:18.000
ご覧のとおり、NavigationLinkはスマートです。

00:05:18.000 -> 00:05:24.000
リンクの動作は、NavigationStackまたは表示されるリストによって異なります。

00:05:24.000 -> 00:05:34.000
これらのおいしい新しいAPIがどのように連携するかを見るために、私の料理本アプリとあなたのアプリでそれらを使用するためのいくつかの特定のレシピを見てみましょう。

00:05:34.000 -> 00:05:41.000
私たちの最初のレシピは、Apple WatchのFind MyやiPhoneのSettingsにあるような、基本的なビューのスタックです。

00:05:41.000 -> 00:05:43.000
カテゴリごとにセクションがあります。

00:05:43.000 -> 00:05:47.000
セクション内で、レシピをタップして詳細を確認できます。

00:05:47.000 -> 00:05:53.000
どのレシピでも、関連するレシピの1つをタップしてスタックにプッシュできます。

00:05:53.000 -> 00:06:01.000
戻るボタンを使って元のレシピに戻り、次にカテゴリリストに戻ることができます。

00:06:01.000 -> 00:06:09.000
このレシピは、NavigationStackと新しい種類のNavigationLink、およびナビゲーション先修飾子を組み合わせたものです。

00:06:09.000 -> 00:06:11.000
やり方を見てみましょう。

00:06:11.000 -> 00:06:15.000
基本的なNavigationStackから始めます。

00:06:15.000 -> 00:06:22.000
内部には、すべてのカテゴリとナビゲーションタイトルを反復するリストがあります。

00:06:22.000 -> 00:06:26.000
リストの中には、各カテゴリのセクションがあります。

00:06:26.000 -> 00:06:33.000
次に、各セクション内に、カテゴリ内の各レシピのナビゲーションリンクを追加します。

00:06:33.000 -> 00:06:36.000
今のところ、リンクに私のRecipeDetailビューを表示させます。

00:06:36.000 -> 00:06:41.000
これは、既存のビュー先NavigationLinkを使用しています。

00:06:41.000 -> 00:06:45.000
そして、それはこのナビゲーション体験を一緒に調理するのに十分です。

00:06:45.000 -> 00:06:48.000
しかし、プログラマティックナビゲーションはどうですか?

00:06:48.000 -> 00:06:57.000
プログラムによるナビゲーションを追加するには、このナビゲーションリンクの2つの部分を区別する必要があります。それが提示する値と、その値に付随するビューです。

00:06:57.000 -> 00:06:59.000
やり方を見てみましょう。

00:06:59.000 -> 00:07:08.000
まず、リンクから宛先ビューを引き出し、新しいnavigationDestination修飾子にします。

00:07:08.000 -> 00:07:15.000
この修飾子は、それが責任を負う提示されたデータのタイプを宣言します。ここでは、それがレシピです。

00:07:15.000 -> 00:07:23.000
修飾子は、レシピ値が提示されたときにスタックにプッシュするビューを記述するビュービルダーを取ります。

00:07:23.000 -> 00:07:30.000
次に、新しいNavigationLinksの1つに切り替えて、レシピの値を提示します。

00:07:30.000 -> 00:07:35.000
ボンネットの下を覗いて、NavigationStackがどのように機能するかを見てみましょう。

00:07:35.000 -> 00:07:41.000
すべてのナビゲーションスタックは、スタックが表示しているすべてのデータを表すパスを追跡します。

00:07:41.000 -> 00:07:47.000
ここに示されているように、スタックがルートビューを表示している場合、パスは空です。

00:07:47.000 -> 00:07:55.000
次に、スタックは、その内部、またはスタックにプッシュされたビュー内で宣言されたすべてのナビゲーション先も追跡します。

00:07:55.000 -> 00:08:01.000
一般的に、これはセットですが、この例では、目的地は1つしかありません。

00:08:01.000 -> 00:08:04.000
プッシュされたビューも図に追加しましょう。

00:08:04.000 -> 00:08:09.000
さて、パスが空なので、プッシュされたビューのリストも空です。

00:08:09.000 -> 00:08:13.000
さて、牛乳やクッキーのように、これらをまとめると魔法が起こります。

00:08:13.000 -> 00:08:19.000
値を提示するリンクをタップすると、その値がパスに追加されます。

00:08:19.000 -> 00:08:29.000
次に、ナビゲーションスタックはパス値の上に宛先をマップし、スタックにプッシュするビューを決定します。

00:08:29.000 -> 00:08:37.000
さて、私のアップルパイのレシピから、パイクラストをタップすると、リンクもパスに追加されます。

00:08:37.000 -> 00:08:46.000
NavigationStackはその魔法を行い、別のRecipeDetailビューをスタックにプッシュします。

00:08:46.000 -> 00:08:51.000
パスに値を追加するたびに、NavigationStackは別のビューをプッシュします。

00:08:51.000 -> 00:08:59.000
戻るボタンをタップすると、NavigationStackはパスとプッシュされたビューから最後のアイテムを削除します。

00:08:59.000 -> 00:09:02.000
そして、NavigationStackにはもう1つのトリックがあります。

00:09:02.000 -> 00:09:06.000
バインディングを使用してこのパスに接続できます。

00:09:06.000 -> 00:09:08.000
私たちのコードに戻りましょう。

00:09:08.000 -> 00:09:10.000
ここが私たちがいた場所です。

00:09:10.000 -> 00:09:13.000
パスをバインドするには、まずいくつかの状態を追加します。

00:09:13.000 -> 00:09:20.000
このスタックにプッシュされるすべての値はレシピであるため、レシピの配列をパスとして使用できます。

00:09:20.000 -> 00:09:29.000
スタック上にさまざまなデータを表示する必要がある場合は、新しいタイプ消去NavigationPathコレクションを必ずチェックしてください。

00:09:29.000 -> 00:09:36.000
パス状態になったら、NavigationStackに引数を追加し、パスにバインディングを渡します。

00:09:36.000 -> 00:09:40.000
それがあれば、スタックをシズルにすることができます。

00:09:40.000 -> 00:09:44.000
たとえば、特定のレシピにジャンプする方法を追加できます。

00:09:44.000 -> 00:09:51.000
または、スタックのどこからでも、パスをリセットするだけでルートに戻ることができます。

00:09:51.000 -> 00:10:02.000
これは、新しいNavigationStack、価値提示NavigationLinks、およびSwiftUIのnavigationDestinationsを使用してプッシュ可能なスタックを準備する方法です。

00:10:02.000 -> 00:10:10.000
このレシピは、Macを含むすべてのプラットフォームで動作しますが、iPhone、Apple TV、Apple Watchで本当に輝いています。

00:10:10.000 -> 00:10:18.000
NavigationStackの動作を確認するには、「Apple Watch用の生産性アプリを構築する」を必ずチェックしてください。

00:10:18.000 -> 00:10:25.000
私たちの次のレシピは、MacやiPadのメールで見られるように、スタックのないマルチカラムプレゼンテーションです。

00:10:25.000 -> 00:10:28.000
iPadでは、サイドバーは最初は非表示になっています。

00:10:28.000 -> 00:10:31.000
私はそれを明らかにして、カテゴリを選ぶことができます。

00:10:31.000 -> 00:10:34.000
次に、2番目の列でレシピを選択できます。

00:10:34.000 -> 00:10:38.000
3番目の列はレシピの詳細を示しています。

00:10:38.000 -> 00:10:45.000
このレシピは、NavigationSplitViewと新しい種類のNavigationLink、およびリスト選択を組み合わせたものです。

00:10:45.000 -> 00:10:50.000
このレシピは、モダリティを回避するのに役立つため、より大きなデバイスに最適です。

00:10:50.000 -> 00:10:53.000
掘り下げることなく、すべての情報を見ることができます。

00:10:53.000 -> 00:10:55.000
やり方を見てみましょう。

00:10:55.000 -> 00:11:02.000
コンテンツと詳細のプレースホルダビューを含む3列のNavigationSplitViewから始めます。

00:11:02.000 -> 00:11:09.000
次に、サイドバーにすべてのカテゴリを反復するリストとナビゲーションタイトルを追加します。

00:11:09.000 -> 00:11:14.000
リストの中には、各カテゴリのナビゲーションリンクがあります。

00:11:14.000 -> 00:11:19.000
次に、どのカテゴリが選択されているかを追跡するために、いくつかの州を紹介します。

00:11:19.000 -> 00:11:23.000
サイドバーのリストを微調整して、選択したカテゴリを使用します。

00:11:23.000 -> 00:11:26.000
選択範囲にバインディングを渡していることに注意してください。

00:11:26.000 -> 00:11:30.000
これにより、リストとその内容が選択を操作できます。

00:11:30.000 -> 00:11:41.000
一致する選択タイプ（カテゴリ）を持つリスト内に値表示リンクを入れると、クリックまたはクリックすると、リンクは自動的に選択を更新します。

00:11:41.000 -> 00:11:47.000
だから今、サイドバーでカテゴリを選択すると、SwiftUIは選択したカテゴリを更新します。

00:11:47.000 -> 00:11:56.000
選択とリストに関する素晴らしい情報については、先ほど述べたRajの「インターフェイスを整理する」トークをチェックしてください。

00:11:56.000 -> 00:12:06.000
次に、コンテンツ列のプレースホルダを選択したカテゴリのレシピのリストに置き換え、この列のナビゲーションタイトルも追加します。

00:12:06.000 -> 00:12:14.000
選択したカテゴリと同様に、同じテクニックを使用して、コンテンツリストで選択したレシピを追跡できます。

00:12:14.000 -> 00:12:24.000
選択したレシピにStateを使用し、コンテンツリストにその状態を使用し、各レシピに値表示リンクを使用します。

00:12:24.000 -> 00:12:30.000
最後に、詳細列を更新して、選択したレシピの詳細を表示します。

00:12:30.000 -> 00:12:37.000
これを導入することで、私は再びナビゲーションを完全にプログラムで制御できます。

00:12:37.000 -> 00:12:45.000
たとえば、その日のレシピに移動するには、選択状態を更新するだけです。

00:12:45.000 -> 00:13:00.000
これは、新しいNavigationSplitView、価値提示NavigationLinks、およびSwiftUIで選択したリストを使用して、複数列のナビゲーション体験を準備する方法です。

00:13:00.000 -> 00:13:14.000
このようにリスト選択とNavigationSplitViewを組み合わせることの1つの非常にクールな点は、SwiftUIが分割ビューをiPhoneまたはiPadのSlide Overの単一のスタックに自動的に適応できることです。

00:13:14.000 -> 00:13:20.000
選択の変更は、iPhoneの適切なプッシュとポップに自動的に変換されます。

00:13:20.000 -> 00:13:24.000
もちろん、この複数列のプレゼンテーションはMacでもうまく機能します。

00:13:24.000 -> 00:13:33.000
また、Apple TVとApple Watchには複数の列は表示されませんが、これらのプラットフォームは1つのスタックへの自動翻訳も取得します。

00:13:33.000 -> 00:13:39.000
SwiftUIのNavigationSplitViewは、すべてのプラットフォームで動作します。

00:13:39.000 -> 00:13:48.000
次に、iPadやMacの写真でそのような2列のナビゲーション体験を構築することで、これらすべての成分をまとめる方法を見てみましょう。

00:13:48.000 -> 00:13:55.000
カテゴリを選択すると、詳細領域にそのカテゴリのすべてのレシピのグリッドが表示されます。

00:13:55.000 -> 00:13:59.000
レシピをタップすると、詳細領域のスタックに押し込まれます。

00:13:59.000 -> 00:14:03.000
関連するレシピをタップすると、それもスタックにプッシュされます。

00:14:03.000 -> 00:14:10.000
そして、私はレシピのグリッドに戻ることができます。

00:14:10.000 -> 00:14:17.000
このレシピは、ナビゲーション分割ビュー、スタック、リンク、宛先、およびリストを組み合わせたpièce de résistanceです。

00:14:17.000 -> 00:14:21.000
これらすべての材料がどのように一緒になるか見てみましょう。

00:14:21.000 -> 00:14:24.000
2列のNavigationSplitViewから始めます。

00:14:24.000 -> 00:14:27.000
最初の列は前のレシピとまったく同じです。

00:14:27.000 -> 00:14:39.000
選択したカテゴリと、その状態へのバインディングと値を提示するNavigationLink、および必要なnavigationTitleを使用するリストを追跡するための状態があります。

00:14:39.000 -> 00:14:42.000
このレシピの違いは詳細領域にあります。

00:14:42.000 -> 00:14:46.000
新しいナビゲーションAPIは、コンポジションを本当に利用しています。

00:14:46.000 -> 00:14:56.000
NavigationSplitViewの列の中にリストを入れるのと同じように、列の中にNavigationStackを入れることもできます。

00:14:56.000 -> 00:15:00.000
このナビゲーションスタックのルートビューは私のRecipeGridです。

00:15:00.000 -> 00:15:04.000
RecipeGridがNavigationStack内にあることに注意してください。

00:15:04.000 -> 00:15:09.000
つまり、RecipeGrid内にスタック関連の修飾子を入れることができます。

00:15:09.000 -> 00:15:14.000
RecipeGridの本体にズームインして、それが何を意味するのか見てみましょう。

00:15:14.000 -> 00:15:18.000
RecipeGridはビューであり、パラメータとしてカテゴリを取ります。

00:15:18.000 -> 00:15:22.000
ここではカテゴリはオプションなので、if-letから始めます。

00:15:22.000 -> 00:15:25.000
Elseケースは空の選択を処理します。

00:15:25.000 -> 00:15:30.000
Ifの中に、スクロールビューと遅延グリッドを追加します。

00:15:30.000 -> 00:15:33.000
怠惰なグリッドレイアウトは、一連のビューを取ります。

00:15:33.000 -> 00:15:36.000
ここでは、ForEachを使用してレシピを反復しています。

00:15:36.000 -> 00:15:41.000
レシピごとに、私は価値を提示するNavigationLinkを持っています。

00:15:41.000 -> 00:15:43.000
リンクはレシピの値を示しています。

00:15:43.000 -> 00:15:50.000
リンクのラベルは、この末尾のクロージャで、サムネイルとタイトルが付いた私のRecipeTileです。

00:15:50.000 -> 00:15:52.000
では、このグリッドを完成させるために何が残っていますか?

00:15:52.000 -> 00:15:57.000
さて、私はレシピから詳細ビューにマッピングする方法をNavigationStackに言っていません。

00:15:57.000 -> 00:16:08.000
最初のレシピで述べたように、新しいNavigationStackはnavigationDestination修飾子を使用して、パス上の値からスタックに表示されるビューにマッピングします。

00:16:08.000 -> 00:16:11.000
では、navigationDestination修飾子を追加しましょう。

00:16:11.000 -> 00:16:14.000
しかし、どこに添付すればよいですか?

00:16:14.000 -> 00:16:19.000
リンクに直接添付したいと思っていますが、これは2つの理由で間違っています。

00:16:19.000 -> 00:16:26.000
List、Table、またはここではLazyVGridなどのレイジーコンテナは、すべてのビューをすぐに読み込むわけではありません。

00:16:26.000 -> 00:16:33.000
ここに修飾子を置くと、宛先が読み込まれない可能性があるため、周囲のNavigationStackには表示されない可能性があります。

00:16:33.000 -> 00:16:39.000
第二に、ここに修飾子を置くと、グリッド内のすべての項目に対して繰り返されます。

00:16:39.000 -> 00:16:43.000
代わりに、ScrollViewに修飾子を添付します。

00:16:43.000 -> 00:16:54.000
ScrollViewの外側に修飾子を添付することで、スクロール位置に関係なく、NavigationStackがこのnavigationDestinationを見ることができるようにします。

00:16:54.000 -> 00:17:00.000
ここに修飾子を置くことについて私が好きなもう一つのことは、それがまだそれをターゲットとするリンクに近いということです。

00:17:00.000 -> 00:17:07.000
ナビゲーションの目的地は、私や私のチームにとって意味のある方法で私のコードを整理する柔軟性を与えてくれます。

00:17:07.000 -> 00:17:14.000
私のNavigationSplitViewに戻ると、ここで完全なプログラムナビゲーションを有効にすることがもう1つあります。

00:17:14.000 -> 00:17:17.000
ナビゲーションパスを追加する必要があります。

00:17:17.000 -> 00:17:24.000
状態を追加してパスを保持し、状態をNavigationStackにバインドします。

00:17:24.000 -> 00:17:33.000
完全なプログラマティックナビゲーションを導入することで、このナビゲーション体験でその日のレシピを表示する方法を書くことができます。

00:17:33.000 -> 00:17:48.000
これは、新しいNavigationSplitView、NavigationStack、値表示NavigationLinks、およびSwiftUIで選択したリストを使用して、スタックでマルチカラムナビゲーション体験を準備する方法です。

00:17:48.000 -> 00:17:57.000
以前のレシピと同様に、これは狭いプレゼンテーションにも自動的に適応し、すべてのプラットフォームで動作します。

00:17:57.000 -> 00:18:06.000
私のアプリでナビゲーションを構造化するためにこれらのレシピを探索するのは楽しかったですが、私たちのナビゲーションのごちそうはデザートなしでは完了しません。

00:18:06.000 -> 00:18:11.000
そのために、ナビゲーション状態を永続化する方法を見てみましょう。

00:18:11.000 -> 00:18:18.000
アプリでナビゲーション状態を持続させるには、CodableとSceneStorageの2つの要素が必要です。

00:18:18.000 -> 00:18:21.000
このレシピには3つの基本的なステップがあります。

00:18:21.000 -> 00:18:26.000
まず、ナビゲーション状態をNavigationModelタイプにカプセル化します。

00:18:26.000 -> 00:18:30.000
これにより、ユニットとして保存して復元できるので、常に一貫しています。

00:18:30.000 -> 00:18:34.000
次に、ナビゲーションモデルをCodableにします。

00:18:34.000 -> 00:18:38.000
最後に、SceneStorageを使用してモデルを保存および復元します。

00:18:38.000 -> 00:18:45.000
私は途中で注意する必要があります - 私は私のアプリが落ちたスフレのようにクラッシュしたくありません - しかし、手順は簡単です。

00:18:45.000 -> 00:18:48.000
ステップ1を見てみましょう。

00:18:48.000 -> 00:18:51.000
これが最後のレシピの最後からのコードです。

00:18:51.000 -> 00:18:55.000
私のナビゲーション状態は、選択したカテゴリとパスのプロパティに保存されます。

00:18:55.000 -> 00:18:59.000
selectedCategoryは、サイドバーの選択を追跡します。

00:18:59.000 -> 00:19:04.000
パスは、詳細領域のスタックにプッシュされたビューを追跡します。

00:19:04.000 -> 00:19:12.000
新しいNavigationModelクラスを導入し、ObservableObjectに準拠させます。

00:19:12.000 -> 00:19:22.000
次に、ナビゲーション状態をモデルオブジェクトに移動し、プロパティラッパーを状態から公開に変更します。

00:19:22.000 -> 00:19:33.000
次に、NavigationModelのインスタンスを保持するStateObjectを紹介し、新しいモデルオブジェクトを使用するようにパラメータを変更します。

00:19:33.000 -> 00:19:37.000
次に、ナビゲーションモデルをコード化可能にします。

00:19:37.000 -> 00:19:39.000
クラスにCodableコンフォーマンスを追加することから始めます。

00:19:39.000 -> 00:19:46.000
多くの場合、Swiftは自動的にコード可能な適合性を生成できますが、ここで独自の適合性を実装したいと思います。

00:19:46.000 -> 00:19:50.000
主な理由は、レシピがモデル値だからです。

00:19:50.000 -> 00:19:54.000
状態復元のためにモデル値全体を保存したくありません。

00:19:54.000 -> 00:19:55.000
これには2つの理由があります。

00:19:55.000 -> 00:20:00.000
まず、私のレシピデータベースにはすでにレシピのすべての詳細が含まれています。

00:20:00.000 -> 00:20:06.000
保存したナビゲーション状態でその情報を繰り返すのは、ストレージの良い使い方ではありません。

00:20:06.000 -> 00:20:19.000
第二に、レシピデータベースがローカルナビゲーション状態とは無関係に変更できる場合、つまり、最終的に同期を追加するようになったため、ローカルナビゲーション状態に古いデータを含めたくありません。

00:20:19.000 -> 00:20:23.000
カスタムコード性については、次にCodingKeysを追加します。

00:20:23.000 -> 00:20:25.000
キーの1つはちょうど選択されたカテゴリです。

00:20:25.000 -> 00:20:34.000
しかし、私は他の「recipePathIds」と名付けたことに注意してください。私はレシピの識別子をパスに保存することを計画しています。

00:20:34.000 -> 00:20:42.000
エンコード方法では、コーディングキーを使用してキー付きコンテナを作成し、選択したカテゴリをコンテナに追加します。

00:20:42.000 -> 00:20:48.000
私はencodeIfPresentを使用しているので、nilでない場合にのみ値を書きます。

00:20:48.000 -> 00:20:52.000
次に、レシピパスの識別子を追加します。

00:20:52.000 -> 00:20:57.000
エンコードする識別子を取得するためにパスをマッピングしていることに注意してください。

00:20:57.000 -> 00:21:07.000
たとえば、私のナビゲーション状態に、上部の緑色のボックスに示されているように、パスにアップルパイとパイクラストを含む、選択したカテゴリとしてデザートが含まれているとします。

00:21:07.000 -> 00:21:14.000
これは、この他のボックスに示されているように、JSONにエンコードされている可能性があります。

00:21:14.000 -> 00:21:18.000
Codabilityを完成させるために、必要な初期化子を追加します。

00:21:18.000 -> 00:21:28.000
興味深いのは、レシピIDをデコードし、共有データモデルを使用してIDをレシピに変換することです。

00:21:28.000 -> 00:21:32.000
compactMapを使用して、見つからなかったレシピを破棄しています。

00:21:32.000 -> 00:21:40.000
たとえば、同期作業後に別のデバイスでレシピを削除すると、これは発生する可能性があります。これは、いつか間違いなく行うことです。

00:21:40.000 -> 00:21:50.000
これは、復元されたナビゲーション状態がまだ理にかなっていることを確認するために、自分のアプリで裁量を使用する必要がある場所です。

00:21:50.000 -> 00:21:56.000
最後に、モデルを読み書きするための計算されたプロパティをJSONデータとして追加します。

00:21:56.000 -> 00:22:03.000
今、私はナビゲーションモデルを持っていて、それ自体をエンコードしてデコードする方法を知っているので、残っているのは実際に保存して復元することだけです。

00:22:03.000 -> 00:22:07.000
そのためにSceneStorageを使います。

00:22:07.000 -> 00:22:09.000
これが私たちがメインビューを残したところです。

00:22:09.000 -> 00:22:12.000
私はNavigationModelを保持するためにStateObjectを使用していました。

00:22:12.000 -> 00:22:18.000
さて、NavigationModelを永続化するために、いくつかのSceneStorageを紹介します。

00:22:18.000 -> 00:22:22.000
SceneStorageプロパティは、関連する値を自動的に保存および復元します。

00:22:22.000 -> 00:22:30.000
ストレージのタイプがオプションの場合、ここの私のデータのように、新しいシーンが作成されると値はnilになります。

00:22:30.000 -> 00:22:36.000
システムがシーンを復元すると、SwiftUIはSceneStorageプロパティの値も復元されることを保証します。

00:22:36.000 -> 00:22:40.000
これを利用してNavigationModelを永続化します。

00:22:40.000 -> 00:22:45.000
これを行うには、ビューにタスク修飾子を追加します。

00:22:45.000 -> 00:22:48.000
タスク修飾子は、クロージャを非同期に実行します。

00:22:48.000 -> 00:22:53.000
ビューが表示されたときに始まり、ビューが消えるとキャンセルされます。

00:22:53.000 -> 00:23:00.000
私のビューが表示されるたびに、まずアプリの以前の実行から既存のデータがあるかどうかを確認します。

00:23:00.000 -> 00:23:05.000
もしそうなら、そのデータでナビゲーションモデルを更新します。

00:23:05.000 -> 00:23:11.000
次に、ナビゲーションモデルが変更されるたびに反復する非同期forループを開始します。

00:23:11.000 -> 00:23:21.000
このループの本体は変更ごとに実行されるため、それを使用してナビゲーション状態をシーンストレージデータに保存できます。

00:23:21.000 -> 00:23:23.000
そして、それだけです!

00:23:23.000 -> 00:23:29.000
私がウェブ上でいくつかのヴィンテージジュリアチャイルドの料理番組をチェックしに行くために私のアプリを離れるとき、それは私がどこにいたかを覚えています。

00:23:29.000 -> 00:23:34.000
アプリに戻ると、中断したところに戻ります。

00:23:34.000 -> 00:23:39.000
さて、便利なキッチンのヒントで最後に奇妙なセクションがなければ、料理本は完成しません。

00:23:39.000 -> 00:23:45.000
私はコリアンダーの3つの素晴らしい代替品を持っていませんが、共有するナビゲーションのヒントがいくつかあります。

00:23:45.000 -> 00:23:50.000
できるだけ早く新しいNavigationStackとNavigationSplitViewに切り替えてください。

00:23:50.000 -> 00:23:55.000
スタックスタイルでNavigationViewを使用している場合は、NavigationStackに切り替えてください。

00:23:55.000 -> 00:24:06.000
NavigationStackは、Apple TV、Apple Watch、またはスタックスタイルが常にデフォルトであったiPadやiPhoneのシートでも良い最初の選択肢です。

00:24:06.000 -> 00:24:11.000
複数列のNavigationViewを使用している場合は、NavigationSplitViewに切り替えてください。

00:24:11.000 -> 00:24:24.000
また、バインディングを取るリンクを使用してプログラムによるナビゲーションをすでに採用している場合は、ナビゲーションパスとリストの選択とともに、新しい値を提示するNavigationLinkに移行することを強くお勧めします。

00:24:24.000 -> 00:24:31.000
古いスタイルのプログラマティックリンクは、iOS 16と整列されたリリースから非推奨です。

00:24:31.000 -> 00:24:41.000
新しいAPIへの移行の詳細と例については、開発者ドキュメントの「新しいナビゲーションタイプへの移行」の記事をご覧ください。

00:24:41.000 -> 00:24:48.000
次に、Listと新しいNavigationSplitViewとNavigationStackが混在するように作られたことを覚えておいてください。

00:24:48.000 -> 00:24:54.000
あなたのゲストが愛するナビゲーション体験を作成するためにそれらを構成してください。

00:24:54.000 -> 00:25:00.000
ナビゲーションスタックを使用する場合、ナビゲーションの宛先はスタックまたはそのサブビュー内の任意の場所に置くことができます。

00:25:00.000 -> 00:25:08.000
メンテナンスを容易にするために、対応するリンクの近くに目的地を置くことを検討してください。ただし、遅延コンテナの中に置かないことを忘れないでください。

00:25:08.000 -> 00:25:15.000
最後に、理にかなっている場合は、NavigationSplitViewでナビゲーション体験を構築し始めることをお勧めします。

00:25:15.000 -> 00:25:22.000
最初にiPhone用に開発している場合でも、NavigationSplitViewはより狭いデバイスに自動的に適応します。

00:25:22.000 -> 00:25:32.000
また、iPhone Pro Maxを横向きでサポートしたり、アプリをiPadやMacに持ち込む準備ができたら、NavigationSplitViewは追加のスペースをすべて利用します。

00:25:32.000 -> 00:25:36.000
新しいSwiftUIナビゲーションAPIをあなたと共有する機会をありがとう!

00:25:36.000 -> 00:25:47.000
先に述べた講演に加えて、アプリで新しいウィンドウやシーンを開くための素晴らしい情報については、「SwiftUIアプリに複数のウィンドウをブリングする」をチェックしてください。

00:25:47.000 -> 00:25:51.000
私たちの料理本アプリでのナビゲーションのためのこれらのレシピが味覚を喜ばせることを願っています。

00:25:51.000 -> 00:25:55.000
私はあなたがあなた自身のアプリで調理する素晴らしい経験を見るのを楽しみにしています。

00:25:55.000 -> 00:25:58.000
どうぞ召し上がってください！

00:25:58.000 -> 23:59:59.000
♪

