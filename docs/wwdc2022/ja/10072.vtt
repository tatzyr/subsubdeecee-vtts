WEBVTT

00:00:00.000 --> 00:00:03.000
♪まろやかなインストゥルメンタルヒップホップ音楽♪

00:00:03.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:18.000
こんにちは、私は健康アプリのエンジニアであるSara Frederixonです。UIKitでSwiftUIを使用することについてお話しします。

00:00:18.000 --> 00:00:22.000
多くの人と同じように、私は既存のUIKitアプリに取り組んでいます。

00:00:22.000 --> 00:00:25.000
私にとって、これは健康アプリです。

00:00:25.000 --> 00:00:33.000
健康アプリには、人々が自分の健康データを理解するのに役立つ多くの視覚化がありますが、これらのビューを構築することは非常に複雑になる可能性があります。

00:00:33.000 --> 00:00:43.000
私はSwiftUIを利用することに興味があったので、UIKitとSwiftUIチームと協力して、両方を同じアプリに統合する方法を学びました。

00:00:43.000 --> 00:00:50.000
このビデオでは、独自のUIKitアプリでSwiftUIを使い始めるのがいかに簡単かをお教えします。

00:00:50.000 --> 00:00:58.000
まず、既存のUIHostingControllerについて説明します。これには、さらに柔軟性を追加するいくつかの新しいアップデートがあります。

00:00:58.000 --> 00:01:11.000
次に、アプリにすでに存在するデータをSwiftUIビューに入力する方法と、そのデータが変更されたときにSwiftUIビューを確実に更新する方法について説明します。

00:01:11.000 --> 00:01:20.000
次に、SwiftUIを使用してUICollectionViewとUITableViewセルを構築できるエキサイティングな新機能について説明します。

00:01:20.000 --> 00:01:29.000
最後に、セル内でSwiftUIを使用しているときに、コレクションとテーブルビューでデータフローのユニークな側面について説明します。

00:01:29.000 --> 00:01:33.000
UIHostingControllerについて話すことから始めましょう。

00:01:33.000 --> 00:01:39.000
UIHostingControllerは、SwiftUIビュー階層を含むUIViewControllerです。

00:01:39.000 --> 00:01:45.000
UIKitでビューコントローラーを使用できる場所ならどこでも、ホスティングコントローラーを使用できます。

00:01:45.000 --> 00:01:50.000
これにより、UIHostingControllerはSwiftUIの使用を開始する簡単な方法になります。

00:01:50.000 --> 00:01:53.000
ホスティングコントローラーの仕組みを調べてみましょう。

00:01:53.000 --> 00:02:01.000
ホスティングコントローラーはビューコントローラーです。つまり、ビュープロパティにUIViewが保存されています。

00:02:01.000 --> 00:02:05.000
そして、そのビューの中には、SwiftUIコンテンツがレンダリングされる場所があります。

00:02:05.000 --> 00:02:09.000
ホスティングコントローラーの使い方の例を見てみましょう。 ホスティングコントローラーの使い方の例を見てみましょう。

00:02:09.000 --> 00:02:14.000
ここでは、HeartRateView、SwiftUIビューを作成します。

00:02:14.000 --> 00:02:21.000
次に、HeartRateViewをルートビューとしてホスティングコントローラーを作成し、それを提示します。

00:02:21.000 --> 00:02:26.000
UIHostingControllerは、すべてのUIKitビューコントローラーAPIで動作します。

00:02:26.000 --> 00:02:30.000
別の例を見てみましょう。

00:02:30.000 --> 00:02:34.000
私たちは以前と同じHeartRateViewとホスティングコントローラーを持っています。

00:02:34.000 --> 00:02:39.000
ここでは、ホスティングコントローラーを子ビューコントローラーとして追加します。

00:02:39.000 --> 00:02:43.000
次に、ホスティングコントローラーのビューを配置し、サイズをサイズ化できます。

00:02:43.000 --> 00:02:51.000
UIHostingController内のSwiftUIコンテンツが変更されると、ビューのサイズを変更が必要になる場合があります。

00:02:51.000 --> 00:03:03.000
iOS 16の新機能であるUIHostingControllerでは、ビューコントローラーの優先コンテンツサイズとビューの本質的なコンテンツサイズの自動更新を有効にすることができます。

00:03:03.000 --> 00:03:09.000
UIHostingControllerの新しいsizingOptionsプロパティを使用してこれを有効にできます。

00:03:09.000 --> 00:03:12.000
例を挙げてみましょう。

00:03:12.000 --> 00:03:18.000
まず、HeartRateViewを作成し、hostingControllerを作成します。

00:03:18.000 --> 00:03:27.000
新しいsizingOptions APIを使用して、hostingControllerに優先コンテンツサイズを自動的に更新するように指示します。

00:03:27.000 --> 00:03:31.000
次に、modalPresentationStyleをポップオーバーに設定します。

00:03:31.000 --> 00:03:41.000
新しいsizingOptions APIを使用すると、ポップオーバーが常にSwiftUIコンテンツに合わせて適切なサイズになります。

00:03:41.000 --> 00:03:55.000
UIHostingControllerに精通したので、UIKitアプリの他の部分からSwiftUIにデータを取り込む方法について話し合い、そのデータが変更されたときにSwiftUIビューが更新されるようにしましょう。

00:03:55.000 --> 00:04:04.000
これはUIKitアプリの図です。アプリのデータモデルオブジェクトを所有および管理する既存のモデルレイヤーが含まれています。

00:04:04.000 --> 00:04:07.000
アプリにはいくつかのビューコントローラーも含まれています。

00:04:07.000 --> 00:04:15.000
SwiftUIの使用を開始する場合は、ビューコントローラーの1つ内にSwiftUIビューを持つホスティングコントローラーが必要です。

00:04:15.000 --> 00:04:22.000
このSwiftUIビューに、既存のモデルレイヤーがまだ所有しているデータを入力します。

00:04:22.000 --> 00:04:30.000
このセクションでは、UIKitとSwiftUIの境界を越えてデータを橋渡しする方法に焦点を当てます。

00:04:30.000 --> 00:04:36.000
SwiftUIは、アプリのデータを管理するのに役立つさまざまなデータフロープリミティブを提供しています。

00:04:36.000 --> 00:04:39.000
さまざまなオプションを見てみましょう。

00:04:39.000 --> 00:04:49.000
SwiftUIビューによって作成および所有されているデータを保存するために、SwiftUIは@Stateと@StateObjectプロパティラッパーを提供します。

00:04:49.000 --> 00:04:56.000
SwiftUIの外部で所有するデータに焦点を当てているため、これらのプロパティラッパーは正しい選択ではありません。

00:04:56.000 --> 00:04:58.000
だから、私はこのビデオでこれらをカバーするつもりはありません。

00:04:58.000 --> 00:05:06.000
SwiftUIビューが所有するデータの詳細については、「SwiftUIのData Essentials」をご覧ください。

00:05:06.000 --> 00:05:12.000
SwiftUIの外部データを処理する1つの方法は、ビューを初期化するときに値を直接渡すことです。

00:05:12.000 --> 00:05:25.000
SwiftUIが所有または管理していない生データを渡すだけなので、データが変更されたときにUIHostingControllerを手動で更新する責任があります。

00:05:25.000 --> 00:05:27.000
例を挙げてみましょう。

00:05:27.000 --> 00:05:31.000
これはHeartRateViewという名前のSwiftUIビューです。

00:05:31.000 --> 00:05:39.000
このビューには、心拍数拍数PerMinuteという単一のプロパティがあり、値をテキストとして表示します。

00:05:39.000 --> 00:05:48.000
HeartRateViewControllerという名前の既存のビューコントローラー内にUIHostingControllerを埋め込むことで、このHeartRateViewを表示しています。

00:05:48.000 --> 00:05:53.000
後でルートビューを更新できるように、ホスティングコントローラーへの参照を保存します。

00:05:53.000 --> 00:06:04.000
SwiftUI HeartRateViewは値型なので、それ自体で保存すると別のコピーが作成され、UIを更新できないことを覚えておいてください。

00:06:04.000 --> 00:06:09.000
HeartRateViewControllerは、HeartRateViewの入力に使用されるデータを所有しています。

00:06:09.000 --> 00:06:19.000
このデータはbeatsPerMinuteプロパティに保存され、beatsPerMinuteの値が変更されると、ビューを更新するメソッドを呼び出します。

00:06:19.000 --> 00:06:31.000
更新方法の中で、最新のbeatsPerMinute値を使用して新しいHeartRateViewを作成し、そのビューをホスティングコントローラーのrootViewとして割り当てます。

00:06:31.000 --> 00:06:43.000
これは、UIKitからSwiftUIにデータを取得する簡単な方法ですが、データが変更されるごとにホスティングコントローラーのrootViewを手動で更新する必要があります。

00:06:43.000 --> 00:06:49.000
これらの更新を自動的に実行するために、他のSwiftUIデータプリミティブを調べてみましょう。

00:06:49.000 --> 00:06:59.000
@ObservedObjectおよび@EnvironmentObjectプロパティラッパーを使用すると、ObservableObjectプロトコルに準拠した外部モデルオブジェクトを参照できます。

00:06:59.000 --> 00:07:07.000
これらのプロパティラッパーを使用すると、SwiftUIはデータが変更されたときに自動的にビューを更新します。

00:07:07.000 --> 00:07:18.000
このビデオでは@ObservedObjectプロパティラッパーに焦点を当てますが、前述の「SwiftUIのData Essentials」ビデオでEnvironmentObjectについて詳しく知ることができます。

00:07:18.000 --> 00:07:22.000
@ObservedObjectの作成方法を見てみましょう。

00:07:22.000 --> 00:07:31.000
最初のステップは、アプリの既存の部分が所有するモデルオブジェクトを取り、ObservableObjectプロトコルに準拠させることです。

00:07:31.000 --> 00:07:38.000
次に、モデルをSwiftUIビューに@ObservedObjectプロパティとして保存します。

00:07:38.000 --> 00:07:46.000
ObservableObjectをSwiftUIに接続すると、プロパティの1つが変更されたときにビューを更新できます。

00:07:46.000 --> 00:07:51.000
HeartRateViewの例に戻って、これを配線しましょう。

00:07:51.000 --> 00:07:56.000
私たちのアプリには、プロパティbeatsPerMinuteを含むHeartDataという名前のクラスがあります。

00:07:56.000 --> 00:08:01.000
プロトコルに準拠することで、ObservableObjectにします。

00:08:01.000 --> 00:08:06.000
次に、@PublishedプロパティラッパーをbeatsPerMinuteプロパティに追加します。

00:08:06.000 --> 00:08:12.000
このプロパティラッパーは、SwiftUIが変更に関するビューを更新するトリガーです。

00:08:12.000 --> 00:08:20.000
HeartRateViewでは、@ObservedObjectプロパティラッパーで注釈されたプロパティにHeartDataを保存します。

00:08:20.000 --> 00:08:26.000
ビューの本文では、HeartDataから直接beatsPerMinuteを表示します。

00:08:26.000 --> 00:08:30.000
では、これらをビューコントローラーで一緒に使いましょう。

00:08:30.000 --> 00:08:33.000
これが私たちのHeartRateViewControllerです。

00:08:33.000 --> 00:08:37.000
HeartData ObservableObjectをプロパティに格納します。

00:08:37.000 --> 00:08:44.000
このプロパティはSwiftUIビュー内にないため、ここではプロパティラッパーを使用する必要はありません。

00:08:44.000 --> 00:08:54.000
HeartRateViewControllerは、ホスティングコントローラーのrootViewとなるHeartRateViewを作成するために使用されるHeartDataインスタンスで初期化されます。

00:08:54.000 --> 00:08:57.000
図は、これがどのように一緒になるかを示しています。

00:08:57.000 --> 00:09:04.000
毎分78拍の心拍数を含む現在のHeartDataインスタンスを取得します。

00:09:04.000 --> 00:09:14.000
次に、そのHeartDataインスタンスで新しいHeartRateViewControllerを作成し、SwiftUI HeartRateViewに配線します。

00:09:14.000 --> 00:09:24.000
数秒後、次の心拍データサンプルが到着すると、心臓データのbeatsPerMinuteプロパティが94に更新されます。

00:09:24.000 --> 00:09:33.000
これにより、ObservableObjectの公開されたプロパティが変更されるため、HeartRateViewは自動的に更新され、新しい値が表示されます。

00:09:33.000 --> 00:09:38.000
データが変更されたときに、ホスティングコントローラーを手動で更新する必要がなくなりました。

00:09:38.000 --> 00:09:44.000
これが、ObservableObjectがUIKitからSwiftUIにデータをブリッジする素晴らしい方法である理由です。

00:09:44.000 --> 00:09:52.000
次に、コレクションビューとテーブルビューのセルでSwiftUIを使用することについて話しましょう。

00:09:52.000 --> 00:10:03.000
iOS 16の新機能はUIHostingConfigurationで、既存のUIKit、コレクション、テーブルビュー内でSwiftUIのパワーを活用できます。

00:10:03.000 --> 00:10:13.000
UIHostingConfigurationを使用すると、追加のビューやビューコントローラーの埋め込みを心配することなく、SwiftUIを使用してカスタムセルを簡単に実装できます。

00:10:13.000 --> 00:10:20.000
UIHostingConfigurationについて詳しく掘り下げる前に、UIKitのセル構成を確認しましょう。

00:10:20.000 --> 00:10:28.000
セル構成は、UIKitでセルのコンテンツ、スタイリング、および動作を定義する最新の方法です。

00:10:28.000 --> 00:10:34.000
UIViewやUIViewControllerとは異なり、設定は単なる軽量構造体です。

00:10:34.000 --> 00:10:36.000
作成するのは安価です。

00:10:36.000 --> 00:10:45.000
構成はセルの外観の説明にすぎないため、効果を発揮するにはセルに適用する必要があります。

00:10:45.000 --> 00:10:51.000
構成は構成可能で、UICollectionViewとUITableViewの両方のセルで動作します。

00:10:51.000 --> 00:10:56.000
詳細については、「現代のセル構成」をご覧ください。

00:10:56.000 --> 00:11:02.000
それを念頭に置いて、UIHostingConfigurationを使い始めましょう!

00:11:02.000 --> 00:11:08.000
UIHostingConfigurationは、SwiftUI ViewBuilderで初期化されるコンテンツ構成です。

00:11:08.000 --> 00:11:15.000
つまり、SwiftUIコードを書き始めて、内部に直接ビューを作成できるということです。

00:11:15.000 --> 00:11:23.000
ホスティング設定をレンダリングするために、UICollectionViewまたはUITableViewセルのcontentConfigurationプロパティに設定します。

00:11:23.000 --> 00:11:30.000
カスタム心拍数セルを構築するために、このホスティング構成でSwiftUIコードを書き始めましょう。

00:11:30.000 --> 00:11:36.000
「心拍数」というテキストと心臓の画像を含むラベルを作成することから始めます。

00:11:36.000 --> 00:11:41.000
SwiftUIビューは、使用されているコンテキストに基づいてデフォルトのスタイルを受け取ります。

00:11:41.000 --> 00:11:47.000
しかし、標準のSwiftUIビュー修飾子を使用してスタイリングのカスタマイズを開始できます。

00:11:47.000 --> 00:11:55.000
ラベルにフォアグラウンドスタイルとフォント修飾子を追加して、画像とテキストを太字のフォントでピンク色にしましょう。

00:11:55.000 --> 00:12:03.000
通常のSwiftUIコードを書いているだけなので、いつでもコードをスタンドアロンビューに分解できます。

00:12:03.000 --> 00:12:16.000
ここでは、HeartRateTitleViewという名前の新しいSwiftUIビューを作成し、持っていたコードを本文に移動し、そのHeartRateTitleViewをホスティング設定で使用しました。

00:12:16.000 --> 00:12:22.000
セルに示すように、まったく同じ結果が得られます。

00:12:22.000 --> 00:12:27.000
これで、HeartRateTitleView内にビューを追加できます。

00:12:27.000 --> 00:12:36.000
スペーサー付きのHStackの中にラベルを入れて、その横にあるテキストビューに現在の時刻を追加しました。

00:12:36.000 --> 00:12:38.000
それは今のところかなり良さそうです。

00:12:38.000 --> 00:12:44.000
HeartRateTitleViewの下にあるこのカスタムセルにさらにコンテンツを追加しましょう。

00:12:44.000 --> 00:12:53.000
これを行うには、ホスティング設定内にVStackを挿入して、HeartRateTitleViewの下にコンテンツを追加できます。

00:12:53.000 --> 00:13:05.000
次に、2つのテキストビューをHStackにまとめて90 BPMを表示し、いくつかの修飾子を適用して、必要なスタイルで設定します。

00:13:05.000 --> 00:13:14.000
以前にHeartRateTitleViewで行ったように、この新しいコードを独自のSwiftUIビューに移動できます。

00:13:14.000 --> 00:13:20.000
これで、同じコードがHeartRateBPMViewの本文に抽出されます。

00:13:20.000 --> 00:13:25.000
私たちの細胞は素晴らしく見えますが、追加できる別のアイデアがあります。

00:13:25.000 --> 00:13:35.000
iOS 16の新機能は、わずか数行のコードで美しいグラフでデータを視覚化できるSwift Chartsフレームワークです。

00:13:35.000 --> 00:13:41.000
それを使って、セルのすぐ内側に小さな折れ線グラフを表示してみましょう。

00:13:41.000 --> 00:13:52.000
新しいチャートビューを使用して、最近の心拍数サンプルを視覚化し、セルのBPMビューの横に表示する小さな折れ線グラフを作成します。

00:13:52.000 --> 00:14:01.000
チャートを生成するには、心拍数サンプルのコレクションを渡し、すべてのサンプルを接続するラインマークを描画します。

00:14:01.000 --> 00:14:11.000
ライン上の各サンプルを示す円記号を追加し、ピンクの前景スタイルを適用して、HeartRateTitleViewに合わせてチャートを着色することができます。

00:14:11.000 --> 00:14:22.000
新しいSwift Chartsフレームワークでできることの表面を引っ掻いているだけなので、ビデオ「Hello Swift Charts」をチェックして詳細を確認してください。

00:14:22.000 --> 00:14:29.000
完成した心拍数セルは素晴らしく見えるだけでなく、わずか数分で簡単に作ることができます。

00:14:29.000 --> 00:14:35.000
UIHostingConfigurationとSwiftUIを使用してカスタムセルの構築を開始するのは簡単です。

00:14:35.000 --> 00:14:40.000
UIHostingConfigurationがサポートする4つの特別な機能について話しましょう。

00:14:40.000 --> 00:14:50.000
デフォルトでは、ルートレベルのSwiftUIコンテンツは、UIKitのセルのレイアウトマージンに基づいて、セルの端から挿入されます。

00:14:50.000 --> 00:14:59.000
これにより、セルコンテンツが隣接するセルやナビゲーションバーなどの他のUI要素のコンテンツと適切に整列されることが保証されます。

00:14:59.000 --> 00:15:07.000
場合によっては、異なる余白を使用したり、コンテンツをセルの端まで拡張したりしたい場合があります。

00:15:07.000 --> 00:15:15.000
このような場合、UIHostingConfigurationのマージン修飾子を使用して、デフォルトのマージンを変更できます。

00:15:15.000 --> 00:15:24.000
SwiftUIを使用してセルの背景の外観をカスタマイズしたい場合は、UIHostingConfigurationで背景修飾子を使用できます。

00:15:24.000 --> 00:15:31.000
UIHostingConfigurationの背景とその内容には、いくつかの重要な違いがあります。

00:15:31.000 --> 00:15:39.000
背景は、セルのコンテンツビューのSwiftUIコンテンツの下にあるセルの背面でホストされています。

00:15:39.000 --> 00:15:48.000
さらに、コンテンツは通常、セルのエッジから挿入されますが、背景はセルのエッジからエッジまで拡張されます。

00:15:48.000 --> 00:15:56.000
最後に、セルフサイジングセルを使用する場合、セルの内容のみがセルのサイズに影響します。

00:15:56.000 --> 00:16:06.000
次に、コレクションビューリストまたはテーブルビュー内にセルがある場合に使用できるUIHostingConfigurationの2つの特別な機能を調べてみましょう。

00:16:06.000 --> 00:16:14.000
リストでは、セルの下の区切り文字は、デフォルトでホスティング設定のSwiftUIテキストに自動的に整列されます。

00:16:14.000 --> 00:16:23.000
この例では、セパレータのリーディングエッジが画像を超えて挿入され、セル内のテキストと整列するように注意してください。

00:16:23.000 --> 00:16:32.000
ホスティング設定でセパレータを別のSwiftUIビューに揃える必要がある場合は、aligningGuide修飾子を使用してください。

00:16:32.000 --> 00:16:40.000
コレクションビューリストまたはテーブルビュー内では、SwiftUIで直接行のスワイプアクションを設定できます。

00:16:40.000 --> 00:16:49.000
swipeActions修飾子内にボタンを作成することで、セルをスワイプしてカスタムアクションを表示して実行することができます。

00:16:49.000 --> 00:16:53.000
このビデオのサンプルコードをダウンロードして、完全な例を見つけてください。

00:16:53.000 --> 00:17:01.000
スワイプアクションを定義するときは、ボタンが表現されたアイテムの安定した識別子を使用してアクションを実行することを確認してください。

00:17:01.000 --> 00:17:10.000
インデックスパスを使用しないでください。セルが表示されている間に変更される可能性があるため、スワイプアクションが間違ったアイテムに作用します。

00:17:10.000 --> 00:17:24.000
セルでUIHostingConfigurationを使用している場合、タップ処理、ハイライト、選択などのセルの相互作用は、引き続きコレクションビューまたはテーブルビューによって処理されることに注意してください。

00:17:24.000 --> 00:17:40.000
これらのUIKitセル状態のいずれかに対してSwiftUIビューをカスタマイズする必要がある場合は、セルのconfigurationUpdateHandler内でホスティング構成を作成し、SwiftUIコードで提供される状態を使用できます。

00:17:40.000 --> 00:17:51.000
configurationUpdateHandlerは、セルの状態が変更されるごとに再び実行され、新しい状態の新しいUIHostingConfigurationを作成し、セルに適用します。

00:17:51.000 --> 00:17:57.000
この例では、セルが選択されたときに状態を使用してチェックマーク画像を追加します。

00:17:57.000 --> 00:18:10.000
UIHostingConfigurationに精通したので、モデルレイヤーからSwiftUIを使用してセルで満たされたUICollectionViewまたはUITableViewへのデータフローを管理する方法について説明します。

00:18:10.000 --> 00:18:14.000
私たちの目標は、この病状のリストを構築することです。

00:18:14.000 --> 00:18:22.000
この例では、UICollectionViewを使用していますが、説明するすべてがUITableViewに等しく適用されます。

00:18:22.000 --> 00:18:25.000
関連するコンポーネントを見てみましょう。

00:18:25.000 --> 00:18:33.000
私たちのアプリにはMedicalConditionモデルオブジェクトのコレクションがあり、コレクションビューに表示する予定です。

00:18:33.000 --> 00:18:41.000
このコレクションの各アイテムについて、コレクションビューにセルを作成して、その病状を表示したいと考えています。

00:18:41.000 --> 00:18:47.000
これを行うには、コレクションビューに接続された差分可能なデータソースを作成します。

00:18:47.000 --> 00:18:58.000
次に、データ収集内のMedicalConditionモデルオブジェクトの識別子を差分可能なデータソーススナップショットに入力する必要があります。

00:18:58.000 --> 00:19:08.000
差分可能なデータソースのスナップショットには、MedicalConditionオブジェクト自体ではなく、各MedicalConditionの一意の識別子が含まれていることが重要です。

00:19:08.000 --> 00:19:20.000
これにより、差分可能なデータソースが各項目の身元を正確に追跡し、後で新しいスナップショットが適用されたときに正しい変更を計算できます。

00:19:20.000 --> 00:19:32.000
これらのアイテム識別子を含むスナップショットを差分可能なデータソースに適用すると、コレクションビューが自動的に更新され、各アイテムに新しいセルが作成されます。

00:19:32.000 --> 00:19:42.000
各セルは、UIHostingConfigurationのSwiftUIビューを使用して、1つのメディカルコンディションを表示するように構成されています。

00:19:42.000 --> 00:19:49.000
SwiftUIで構築されたセルを表示している今、データが変更されたときにUIの更新を処理する必要があります。

00:19:49.000 --> 00:19:54.000
別々に処理する必要がある変更には2種類あります。

00:19:54.000 --> 00:19:58.000
最初のタイプは、データ収集自体が変更されたときです。

00:19:58.000 --> 00:20:04.000
たとえば、アイテムが挿入、並べ替え、または削除されたとき。

00:20:04.000 --> 00:20:10.000
これらの変更は、差分可能なデータソースに新しいスナップショットを適用することで処理されます。

00:20:10.000 --> 00:20:23.000
拡散可能なデータソースは、古いスナップショットと新しいスナップショットを差分し、コレクションビューに必要な更新を実行し、セルを挿入、移動、または削除します。

00:20:23.000 --> 00:20:35.000
データ収集自体の変更はセル内の何にも影響しないため、UIKitまたはSwiftUIを使用してセルを構築するかどうかにかかわらず、これらの種類の変更を同じように処理します。

00:20:35.000 --> 00:20:43.000
処理する必要がある2番目のタイプの変更は、個々のモデルオブジェクトのプロパティが変更されたときです。

00:20:43.000 --> 00:20:48.000
これらの変更では、多くの場合、既存のセルのビューを更新する必要があります。

00:20:48.000 --> 00:20:57.000
差分可能なデータソースにはスナップショットにアイテム識別子しか含まれていないため、既存のアイテムのプロパティがいつ変更されるかはわかりません。

00:20:57.000 --> 00:21:08.000
従来、UIKitを使用する場合は、スナップショット内のアイテムを再構成またはリロードすることで、これらの変更について差分可能なデータソースに手動で伝える必要があります。

00:21:08.000 --> 00:21:13.000
しかし、セルでSwiftUIを使用する場合、これはもう必要ありません。

00:21:13.000 --> 00:21:27.000
ObservableObjectモデルをSwiftUIビューのObservedObjectプロパティに保存することにより、モデルの公開されたプロパティへの変更は自動的にSwiftUIをトリガーしてビューを更新します。

00:21:27.000 --> 00:21:34.000
これにより、モデルとセル内のSwiftUIビューとの間の直接接続が確立されます。

00:21:34.000 --> 00:21:44.000
変更が行われると、セル内のSwiftUIビューは、差分可能なデータソースやUICollectionViewを経由せずに直接更新されます。

00:21:44.000 --> 00:21:51.000
セルのデータが変更されると、新しいコンテンツに合わせてセルが成長または縮小する必要がある可能性があります。

00:21:51.000 --> 00:22:00.000
しかし、SwiftUIセルのコンテンツがUIKitを経由せずに直接更新されている場合、コレクションビューはセルのサイズを変更することをどのように知っていますか?

00:22:00.000 --> 00:22:07.000
UIHostingConfigurationは、UIKitの真新しい機能を利用して、これを機能させます。

00:22:07.000 --> 00:22:16.000
iOS 16では、UICollectionViewとUITableViewのセルフサイズセルもセルフサイズ変更になりました!

00:22:16.000 --> 00:22:28.000
これはデフォルトで有効になっているため、UIHostingConfigurationを使用してSwiftUIコンテンツが変更されると、必要に応じて含まれているセルが自動的にサイズ変更されます。

00:22:28.000 --> 00:22:37.000
この新機能の仕組みについては、WWDC 2022の「What's New in UIKit」ビデオで詳しく知ることができます。

00:22:37.000 --> 00:22:48.000
処理する必要があるデータフローのもう1つの側面があり、それはSwiftUIビューからアプリの他の部分にデータを送り返すことです。

00:22:48.000 --> 00:22:52.000
もう一度、ObservableObjectはあなたをカバーしています!

00:22:52.000 --> 00:22:57.000
ObservableObjectの公開されたプロパティへの双方向バインディングを作成できます。

00:22:57.000 --> 00:23:08.000
ObservableObjectからSwiftUIにデータが流れるだけでなく、SwiftUIはモデルオブジェクトのプロパティに変更を書き戻すことができます。

00:23:08.000 --> 00:23:16.000
MedicalConditionセルのテキストを編集可能にすることで、双方向バインディングを作成する簡単な例を見てみましょう。

00:23:16.000 --> 00:23:21.000
これが私たちのObservableObject、MedicalConditionです。

00:23:21.000 --> 00:23:25.000
IDプロパティに一意の識別子を格納します。

00:23:25.000 --> 00:23:30.000
これは、差分可能なデータソースのスナップショットに入力するために使用される識別子です。

00:23:30.000 --> 00:23:35.000
そして、この公開されたプロパティは、病状のテキストを保存します。

00:23:35.000 --> 00:23:42.000
これは、各セル内に病状のテキストを表示するMedicalConditionViewです。

00:23:42.000 --> 00:23:47.000
今、このテキストは読み取り専用なので、編集可能にしましょう。

00:23:47.000 --> 00:23:59.000
必要なのは、テキストビューをTextFieldに変更し、ドル記号の接頭辞を追加してMedicalConditionのテキストプロパティへのバインディングを作成することだけです。

00:23:59.000 --> 00:24:07.000
テキストフィールドに入力すると、このバインディングにより、SwiftUIは変更をObservableObjectに直接書き戻すことができます。

00:24:07.000 --> 00:24:14.000
SwiftUIで双方向のデータフローを設定するのは本当に簡単です。

00:24:14.000 --> 00:24:21.000
UIHostingControllerは、SwiftUIコンテンツをUIKitアプリに埋め込む強力な方法です。

00:24:21.000 --> 00:24:33.000
SwiftUIビューはホスティングコントローラーのビュー内にレンダリングされ、UIKitでビューコントローラーを使用できる場所ならどこでもホスティングコントローラーを使用できます。

00:24:33.000 --> 00:24:41.000
UIHostingControllerを使用する場合は、常にビューコントローラーをビューと一緒にアプリに追加してください。

00:24:41.000 --> 00:25:01.000
ツールバー、キーボードショートカット、UIViewControllerRepresentableを使用するビューなど、多くのSwiftUI機能は、適切に統合するためにUIKitのビューコントローラー階層への接続を必要とするため、ホスティングコントローラーのビューをホスティングコントローラー自体から分離しないでください。

00:25:01.000 --> 00:25:11.000
比較のために、UIHostingConfigurationをセルに適用すると、SwiftUIビューはUIViewControllerなしでセルでホストされます。

00:25:11.000 --> 00:25:16.000
UIHostingConfigurationは、SwiftUI機能の大部分をサポートしています。

00:25:16.000 --> 00:25:23.000
しかし、UIViewControllerRepresentableに依存するSwiftUIビューは、セル内では使用できないことを覚えておいてください。

00:25:23.000 --> 00:25:32.000
UIHostingControllerとUIHostingConfigurationを使用すると、SwiftUIをUIKitアプリに組み込む2つの素晴らしい方法があります。

00:25:32.000 --> 00:25:42.000
SwiftUIは既存のUIKitアプリにシームレスに統合されます。UIHostingControllerを使用して、アプリ全体にSwiftUIを追加します。

00:25:42.000 --> 00:25:49.000
UIHostingConfigurationを使用して、コレクションとテーブルビューにカスタムセルを作成します。

00:25:49.000 --> 00:25:55.000
また、ObservableObjectを利用すると、データとUIは常に同期されます。

00:25:55.000 --> 00:25:59.000
今すぐSwiftUIをアプリに追加しましょう!

00:25:59.000 --> 00:26:00.000
見てくれてありがとう!

00:26:00.000 --> 23:59:59.000
♪

