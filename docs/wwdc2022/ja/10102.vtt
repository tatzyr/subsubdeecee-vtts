WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:10.000
こんにちは、ようこそ。

00:00:10.000 --> 00:00:13.000
私はGPUソフトウェアのエンジニアリングマネージャー、ガロ・アビラです。

00:00:13.000 --> 00:00:19.000
このセッションでは、Eylonと私は、Metal 3でアプリのGPUバイナリ生成を改善する方法を共有することに興奮しています。

00:00:19.000 --> 00:00:26.000
まず、オフラインコンパイルがアプリのスタッター、最初の起動、新しいレベルの読み込み時間を減らすのにどのように役立つかを説明します。

00:00:26.000 --> 00:00:35.000
その後、Eylonは、サイズコンパイラの最適化オプションを使用して、変換を拡張するコードを調整し、コンパイル時間を改善する方法を説明します。

00:00:35.000 --> 00:00:39.000
オフラインコンパイルでは、GPUバイナリ生成をプロジェクトのビルド時間に移動できます。

00:00:39.000 --> 00:00:47.000
採用がMetalアプリケーションにもたらす利点を完全に理解するために、GPUバイナリをすでに生成できる方法を検討することから始めます。

00:00:47.000 --> 00:00:52.000
Metalアプリでは、GPUバイナリ生成はビルド時とランタイムの両方で行われます。

00:00:52.000 --> 00:00:56.000
たとえば、ソースから金属ライブラリをインスタンス化するとします。

00:00:56.000 --> 00:01:02.000
これは、アプリの実行時に、AIRとも呼ばれるAppleの中間表現が生成されます。

00:01:02.000 --> 00:01:11.000
これはCPU集約型の操作であり、ソースをMetalライブラリに事前コンパイルし、代わりにファイルからインスタンス化することで、アプリのビルド時間に移動できます。

00:01:11.000 --> 00:01:18.000
Metalライブラリがメモリに入ったら、状態と関数を含むパイプライン状態記述子を作成することは軽量な操作です。

00:01:18.000 --> 00:01:28.000
パイプライン状態オブジェクトを作成するまで、これは別のCPU集約的な操作であり、タイミングのGPUバイナリ生成が行われます。

00:01:28.000 --> 00:01:36.000
実行時のGPUバイナリ生成はCPU集約的な操作になる可能性があるため、Metalはパイプライン状態オブジェクトの作成を高速化するのに役立ちます。

00:01:36.000 --> 00:01:41.000
PSOをインスタンス化すると、MetalはGPUバイナリをファイルシステムキャッシュに保存します。

00:01:41.000 --> 00:01:46.000
そして、新しいPSOが作成されるたびに、新しく生成された機能が追加されます。

00:01:46.000 --> 00:01:52.000
したがって、参照される以前に生成されたバイナリは、キャッシュから読み込まれます。

00:01:52.000 --> 00:01:58.000
Metalでは、バイナリアーカイブを使用して、GPUバイナリがいつ、どこでキャッシュされるかを明示的に制御することもできます。

00:01:58.000 --> 00:02:05.000
PSO記述子を使用して、GPUバイナリを必要な回数だけアーカイブにキャッシュするだけです。

00:02:05.000 --> 00:02:09.000
その後、PSOの作成は軽量操作になります。

00:02:09.000 --> 00:02:14.000
バイナリアーカイブは、より柔軟なキャッシュを可能にしますが、実行時に生成する必要があります。

00:02:14.000 --> 00:02:20.000
多くの場合、あなたが本当に欲しいのは、ビルド時にそれらのアーカイブを生成することであり、今、あなたは最終的にすることができます。

00:02:20.000 --> 00:02:29.000
オフラインバイナリ生成では、プロジェクト構築時にMetalパイプラインスクリプトと呼ばれる新しいアーティファクトを、MetalソースまたはMetalライブラリとともに指定します。

00:02:29.000 --> 00:02:35.000
パイプラインスクリプトは、APIのパイプライン記述子のコレクションに相当するコンパイラツールチェーンです。

00:02:35.000 --> 00:02:38.000
コンパイルプロセスの出力はバイナリアーカイブです。

00:02:38.000 --> 00:02:42.000
アプリの実行時にこれ以上のGPUコード生成は行われません。

00:02:42.000 --> 00:02:48.000
PSOの作成を加速するために、オフラインで構築されたバイナリアーカイブをロードする。

00:02:48.000 --> 00:02:55.000
オフラインコンパイルは、Metalを低レベルのAPIにする中核となるランタイムCPUのオーバーヘッドを減らすことで、アプリに利益をもたらします。

00:02:55.000 --> 00:03:00.000
さらに、採用は2つの顕著な方法でアプリのエクスペリエンスを向上させることができます。

00:03:00.000 --> 00:03:07.000
最初の打ち上げと新しいレベルのロード時間は劇的に速くなり、エンゲージメントとインタラクションが高まる可能性があります。

00:03:07.000 --> 00:03:15.000
ランタイムコンパイルによるスタッタやフレームレートの低下は、プレウォームフレームのメモリやCPUコストなしで、最終的に削除することができます。

00:03:15.000 --> 00:03:19.000
次に、これらの利点について詳しく説明します。

00:03:19.000 --> 00:03:22.000
ここには、従来のアプリランタイムバイナリ生成があります。

00:03:22.000 --> 00:03:31.000
この例では、アプリは、操作を開始する前に、ロード画面の背後にあるGPUバイナリのコンパイルに約2/3の時間を費やしています。

00:03:31.000 --> 00:03:43.000
しかし、オフラインコンパイルでは、ランタイムシェーダーの生成がアプリのビルド時間に移行し、PSOの作成はわずかな時間で行われ、ロード画面でアイドル状態になるのではなく、より早くアプリと対話することができます。

00:03:43.000 --> 00:03:47.000
オフラインコンパイルは、吃音を減らすのにも役立ちます。

00:03:47.000 --> 00:03:56.000
従来のランタイムバイナリ生成では、ロード時に作成するパイプライン状態が多すぎる可能性があるため、代わりにタイミングで作成する可能性があります。

00:03:56.000 --> 00:04:03.000
そして、それが起こると、コンパイルがコマンドエンコーディングを一時的に中断することによって引き起こされるフレームドロップが発生する可能性があります。

00:04:03.000 --> 00:04:10.000
オフラインコンパイルは、アプリのビルド時にさらに多くのシェーダーをコンパイルできるため、これらの厄介なバブルを削除します。

00:04:10.000 --> 00:04:16.000
次に、オフラインコンパイルの利点を活用するのに役立つ新しい開発者ワークフローを共有します。

00:04:16.000 --> 00:04:21.000
次のワークフローでは、新しいツールチェーン機能を使用してGPUバイナリをオフラインで構築する方法を学びます。

00:04:21.000 --> 00:04:25.000
新しいパイプラインスクリプト入力アーティファクトを生成する方法を紹介します。

00:04:25.000 --> 00:04:29.000
次に、ツールチェーンを呼び出してGPUバイナリを生成する方法。

00:04:29.000 --> 00:04:38.000
パイプラインスクリプトアーティファクトは、1つ以上のAPIパイプライン状態記述子のJSON形式の説明であり、さまざまな方法で生成できます。

00:04:38.000 --> 00:04:46.000
たとえば、お気に入りのJSONエディタで作成するか、開発とテスト中にシリアル化されたバイナリアーカイブからハーベストします。

00:04:46.000 --> 00:04:54.000
ここには、状態と関数とその同等のJSON表現を持つレンダリングパイプライン記述子を生成するMetalコードのスニペットがあります。

00:04:54.000 --> 00:04:59.000
まず、APIメタルライブラリファイルはライブラリパスプロパティとして指定されます。

00:04:59.000 --> 00:05:04.000
次に、APIレンダリング記述子関数名をレンダリングパイプラインのプロパティとして使用します。

00:05:04.000 --> 00:05:11.000
最後に、raster_sample_countやピクセル形式などの他のパイプライン状態もスクリプトプロパティとしてキャプチャされます。

00:05:11.000 --> 00:05:16.000
Metalの開発者ドキュメントで、さらにJSONスキーマの詳細を探してください。

00:05:16.000 --> 00:05:22.000
また、JSONスクリプトの生成をキックスタートしたいと思うかもしれませんし、Metalランタイムを使用すると役立ちます。

00:05:22.000 --> 00:05:27.000
実行時にバイナリアーカイブを生成し、開発とテストの過程でそれらをシリアライズするだけです。

00:05:27.000 --> 00:05:32.000
次に、Metal APIでこれを達成する方法を紹介します。

00:05:32.000 --> 00:05:48.000
ランタイムハーベスティングプロセスを開始するには、状態と機能を備えたパイプライン記述子を作成し、GPUバイナリを生成するアーカイブに追加し、ファイルシステムにシリアライズしてアプリのバンドルにインポートしてロードします。

00:05:48.000 --> 00:05:52.000
Metal 3ランタイムは、GPUバイナリと一緒にパイプライン記述子を保存します。

00:05:52.000 --> 00:05:55.000
では、それらを抽出する方法を紹介します。

00:05:55.000 --> 00:06:00.000
metal-sourceを使用すると、既存のアーカイブからJSONパイプラインスクリプトを抽出できます。

00:06:00.000 --> 00:06:05.000
これは、バイナリ生成をランタイムからアプリビルド時間に移行するのに便利です。

00:06:05.000 --> 00:06:10.000
フラットバッファと出力ディレクトリオプションでメタルソースを呼び出すだけです。

00:06:10.000 --> 00:06:14.000
結果はパイプラインスクリプトファイルで、編集して追加のバイナリを生成できます。

00:06:14.000 --> 00:06:18.000
では、ツールチェーンを呼び出す方法を紹介します。

00:06:18.000 --> 00:06:23.000
XcodeプロジェクトのビルドフェーズからGPUバイナリを生成するのは簡単です。

00:06:23.000 --> 00:06:29.000
ソース、パイプラインスクリプト、および出力ファイルを使用して、端末から金属を呼び出すだけです。

00:06:29.000 --> 00:06:36.000
出力メタルライブラリにはGPUバイナリが含まれており、ツールチェーンでサポートされているどのデバイスにも展開できます。

00:06:36.000 --> 00:06:42.000
また、ソースの代わりにMetalライブラリがある場合は、それをツールチェーンにも渡すことができます。

00:06:42.000 --> 00:06:48.000
既存のMetalライブラリからバイナリを生成するのは、Metal翻訳ツールでも同じように簡単です。

00:06:48.000 --> 00:06:53.000
ソース、パイプラインスクリプト、および出力ファイルを使用して端末で行うのと同じように、metal-ttを呼び出すだけです。

00:06:53.000 --> 00:07:00.000
結果として得られるMetalライブラリには、ツールチェーンでサポートされているすべてのデバイスのGPUバイナリが含まれています。

00:07:00.000 --> 00:07:05.000
バイナリをオフラインで作成する方法がわかったので、それらをロードする方法を確認します。

00:07:05.000 --> 00:07:10.000
アーカイブ記述子を作成するときにバイナリURLを提供し、それを使用してアーカイブをインスタンス化するだけです。

00:07:10.000 --> 00:07:12.000
それでおそれ！

00:07:12.000 --> 00:07:18.000
メタルのバイナリアーカイブAPIの詳細については、前年の講演を参照してください。

00:07:18.000 --> 00:07:25.000
最後に、Metalがオフラインで生成されたアーティファクトのGPUバイナリ互換性をどのように処理するかについての注意。

00:07:25.000 --> 00:07:30.000
オフラインで生成されたバイナリが将来のOSバージョンや製品と前方互換性があることを確認するため。

00:07:30.000 --> 00:07:34.000
Metalは、OSのアップデート中またはアプリのインストール時にバイナリアーカイブを優雅にアップグレードします。

00:07:34.000 --> 00:07:38.000
それは非同期に、そしてバックグラウンドでそうします。

00:07:38.000 --> 00:07:45.000
オフラインコンパイルの利点を活用して、ランタイムスタッターを取り除き、最初の起動と新しいレベルのロード時間を短縮するのが待ちきれません。

00:07:45.000 --> 00:07:49.000
このような改善は、他の人にとって目に見えるものであり、全体的なアプリ体験を向上させることができます。

00:07:49.000 --> 00:07:51.000
さて、エイロンへ。

00:07:51.000 --> 00:07:53.000
アイロン:ありがとう、ガロ。

00:07:53.000 --> 00:07:58.000
次に、サイズを最適化する新しいコンパイルオプションを紹介します。

00:07:58.000 --> 00:08:02.000
Metalコンパイラは、ランタイムパフォーマンスのためにコードを積極的に最適化します。

00:08:02.000 --> 00:08:09.000
一部の最適化により、GPUプログラムのサイズが拡大され、予期せぬコストが発生する可能性があります。

00:08:09.000 --> 00:08:14.000
たとえば、関数インラインは、関数呼び出しのオーバーヘッドを回避するための最適化です。

00:08:14.000 --> 00:08:19.000
これは、呼び出された関数の本体をコールサイトにインライン化することによって機能します。

00:08:19.000 --> 00:08:34.000
このカーネルの例は、多くのコードのようには見えませんが、インライン化後、関数「f」と「g」のコピーと、ヘルパーや非プリミティブライブラリ関数など、「f」と「g」から呼び出される関数のコピーも含まれる可能性があります。

00:08:34.000 --> 00:08:44.000
もう1つの最適化は、ループ本体の追加コピーをインライン化し、反復間で並列性を公開し、分岐オーバーヘッドを回避するループアンローリングです。

00:08:44.000 --> 00:08:53.000
コンパイラは、ループの2つの反復、または境界が固定されているループのすべての反復を展開できます。

00:08:53.000 --> 00:09:04.000
このような最適化が非常に大きなプログラムを作成する場合、コンパイラはコンパイルに多くの時間を費やす必要があり、状況によっては、これらのコストを回避することを好むかもしれません。

00:09:04.000 --> 00:09:10.000
Xcode 14は、新しい金属最適化モードを導入します。サイズに合わせて最適化します。

00:09:10.000 --> 00:09:18.000
このモードは、コンパイラがパフォーマンスの最適化を適用する場合、インラインやループ展開などのサイズ拡張変換を制限します。

00:09:18.000 --> 00:09:27.000
意図された利点は、デフォルトの最適化が高すぎることが判明した場合に、GPUバイナリを小さくし、コンパイル時間を短くすることです。

00:09:27.000 --> 00:09:32.000
サイズを最適化すると、ランタイムのパフォーマンスが低くなる可能性があります。

00:09:32.000 --> 00:09:39.000
それが実際に起こるかどうかはプログラムによって異なりますので、両方の最適化モードを試して比較する必要があります。

00:09:39.000 --> 00:09:43.000
サイズの最適化は、すべてのシェーダーのサイズとコンパイル時間を改善しない場合があります。

00:09:43.000 --> 00:09:50.000
インライン化と展開が一般的なディープコールパスとループを持つ大規模なプログラムには利益をもたらす可能性が最も高いです。

00:09:50.000 --> 00:09:57.000
このオプションは、デフォルトの最適化から予期せず長いコンパイル時間が発生するたびに試してみる価値があります。

00:09:57.000 --> 00:10:02.000
このオプションは、プロジェクトのビルド時にコンパイルする場合でも、アプリの実行時にコンパイルする場合でも利用できます。

00:10:02.000 --> 00:10:06.000
これは、サイズの最適化が違いを生むケースです。

00:10:06.000 --> 00:10:15.000
Cyclesは、Blender 3D設計環境用のプロダクションレンダラーを実装するオープンソースプロジェクトで、最近Metalをサポートするように更新されました。

00:10:15.000 --> 00:10:28.000
Appleは最近Blender開発基金に参加し、私たちが学んだことの1つは、Blenderのパストレーシングアルゴリズムは、多くのヘルパー関数とループを備えた大規模なコンピューティングシェーダーを使用し、そのコンパイル時間は数分まで加算できることでした。

00:10:28.000 --> 00:10:36.000
それらはまさにMetal 3の新しいサイズ最適化オプションの恩恵を受けることができるシェーダーの種類であることが判明しました。

00:10:36.000 --> 00:10:48.000
これらのシーンをApple Silicon GPUでレンダリングすると、シェーダーパイプラインのコンパイルを含むBlenderのセットアップ時間を最大1.4倍に最適化できます。

00:10:48.000 --> 00:10:52.000
そして、レンダリング時間の劣化がほとんどまたはまったくないスピードアップを提供しました。

00:10:52.000 --> 00:10:57.000
レンダリングは4%まで遅くなり、まったく遅くならなかったものもあります。

00:10:57.000 --> 00:11:00.000
したがって、ランタイムパフォーマンスの低下が可能です。

00:11:00.000 --> 00:11:04.000
しかし、場合によっては、サイズを最適化することで、ランタイムのパフォーマンスを向上させることもできます。

00:11:04.000 --> 00:11:07.000
ここに例があります。

00:11:07.000 --> 00:11:14.000
これらは、Intel GPUでサイズの最適化を可能にすることで、同じシーンのレンダリングタイムのスピードアップです。

00:11:14.000 --> 00:11:20.000
利点は、より速いコンパイルだけでなく、最大1.6倍のより速いレンダリングでした。

00:11:20.000 --> 00:11:21.000
どうやって？

00:11:21.000 --> 00:11:35.000
より小さなGPUプログラムは、大きなサイズに付属するランタイムペナルティの一部を回避できるため、命令キャッシュのミスが少なくなるか、レジスタが少なくて済んだりする可能性があり、メモリへの流出が少なくなり、並行してスレッドがさらに多くなります。

00:11:35.000 --> 00:11:40.000
これらの結果は、すべてのシェーダーやシーンに典型的なものではなく、パフォーマンスの低下が可能であることを覚えておいてください。

00:11:40.000 --> 00:11:47.000
プロジェクトでは、コンパイル時とランタイムのパフォーマンスの両方に対する実際の影響を評価する必要があります。

00:11:47.000 --> 00:11:53.000
3つの異なる環境で、Metalソースからコンパイルするときにサイズの最適化を有効にすることができます。

00:11:53.000 --> 00:11:58.000
Xcode 14のユーザーインターフェイスで、ビルド設定としてサイズの最適化を指定します。

00:11:58.000 --> 00:12:03.000
「メタルコンパイラ - ビルドオプション」で、設定「最適化レベル」を見つけます。

00:12:03.000 --> 00:12:07.000
レベル「デフォルト」は、メタルが過去に行ったように、パフォーマンスを最適化します。

00:12:07.000 --> 00:12:11.000
レベル「サイズ」では、サイズを最適化できます。

00:12:11.000 --> 00:12:18.000
コマンドラインでMetalソースをコンパイルするときは、オプション'-Os'を使用してサイズの最適化を指定します。

00:12:18.000 --> 00:12:23.000
最初の例では、単一のコンパイルとリンクコマンドのオプションを指定します。

00:12:23.000 --> 00:12:30.000
2番目の例には2つのコンパイルコマンドがあり、そのうちの1つだけにオプションを指定して、一部のシェーダーのみで有効にします。

00:12:30.000 --> 00:12:34.000
このオプションは、リンクコマンドまたは後続のコマンドに渡す必要はありません。

00:12:34.000 --> 00:12:44.000
また、この講演の前半で提示したコマンドを使用して、GPUバイナリを生成するかどうかにかかわらず、サイズの最適化を使用できます。

00:12:44.000 --> 00:12:57.000
最後に、「newLibraryWithSource」などのMetal Framework APIを使用してアプリ実行時にMetalソースをコンパイルするときは、プロパティ「optimizationLevel」を使用して「MTLCompileOptions」オブジェクトのサイズの最適化を指定します。

00:12:57.000 --> 00:13:02.000
最適化レベルは「デフォルト」または「サイズ」です。

00:13:02.000 --> 00:13:08.000
あなたのプロジェクトがMetalコンパイラのこの新しい最適化モードの恩恵を受けることを願っています。

00:13:08.000 --> 00:13:18.000
Galo: 最後に、アプリ内のスタッター、最初の起動、新しいレベルのロード時間を短縮するために、アプリのビルド時にGPUバイナリを完全に生成するための新しいワークフローであるオフラインコンパイルを発表しました。

00:13:18.000 --> 00:13:27.000
Eylon：次に、プログラムのサイズとコンパイル時間を短縮するために、ソースからコンパイルする際の新しい金属最適化モードであるサイズの最適化を提示しました。

00:13:27.000 --> 00:13:31.000
Galo: これらの改善が、アプリやゲームがユーザーエクスペリエンスを向上させるのに役立つことを願っています。

00:13:31.000 --> 00:13:39.000
Eylon：実行時のコンパイルコストの削減により、セットアップとロード時間が短縮され、スタッターが少なくなり、新しいワークフローが削減されます。

00:13:39.000 --> 23:59:59.000
ご覧いただきありがとうございます。♪ ♪

