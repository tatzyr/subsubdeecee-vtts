WEBVTT

00:00:00.000 --> 00:00:03.000
♪まろやかなインストゥルメンタルヒップホップ音楽♪

00:00:03.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:13.000
こんにちは、私はジャレッド・マルソーで、アップルのゲームテクノロジーで働いています。

00:00:13.000 --> 00:00:21.000
今日は、選択したAppleフレームワークを使用して、Unityベースのゲームに新しい機能を追加する方法についてお話しします。

00:00:21.000 --> 00:00:27.000
私たちは、多くの人がゲームを構築するためにUnityなどのツールを使用していることを知っています。

00:00:27.000 --> 00:00:32.000
私たちの目標は、使用しているツールに関係なく、最新の機能を提供することです。

00:00:32.000 --> 00:00:37.000
今日から、Unityプラグインの新しいセットでゲームを強化しましょう。

00:00:37.000 --> 00:00:43.000
Game Centerプラグインを使用して、プレイヤー認証、リーダーボード、マッチメイキングなどのGameKit機能を追加します。

00:00:43.000 --> 00:00:51.000
MFiとサードパーティのコントローラーのサポートとともに、入力のカスタマイズとグリフにゲームコントローラープラグインを使用してください。

00:00:51.000 --> 00:00:58.000
アクセシビリティプラグインを使用して、VoiceOverやDynamic Typeなどのシステム機能を通じてアクセシビリティを向上させます。

00:00:58.000 --> 00:01:04.000
Appleのデータ駆動型の豊富な触覚フィードバックシステムをCore Hapticsプラグインと統合します。

00:01:04.000 --> 00:01:09.000
PHASEプラグインで高度なジオメトリ対応の空間オーディオを追加します。

00:01:09.000 --> 00:01:16.000
最後に、Apple.Coreプラグインを使用してビルド設定を管理し、ビルドプロセスを簡素化します。

00:01:16.000 --> 00:01:27.000
このプラグインの最初のセットは、新しいゲームプレイの仕組みを追加し、ゲームをよりアクセスしやすくし、最新の機能やサービスをより迅速に活用するのに役立ちます。

00:01:27.000 --> 00:01:32.000
この新しいUnityプラグインセットで作成した素晴らしいゲームを見て、非常に興奮しています。

00:01:32.000 --> 00:01:35.000
では、プロジェクトの詳細に入ります。

00:01:35.000 --> 00:01:38.000
まず、プロジェクトの設計原則について説明します。

00:01:38.000 --> 00:01:42.000
次に、プロジェクトのコンセプトと組織について説明します。

00:01:42.000 --> 00:01:47.000
次に、プロジェクトリポジトリとの対話に関するいくつかの重要な指針を提供します。

00:01:47.000 --> 00:01:50.000
そして最後に、各プラグインについて詳しく説明します。

00:01:50.000 --> 00:01:56.000
ご存知かもしれませんが、Appleのフレームワークはモジュール式の方法で機能をカプセル化しています。

00:01:56.000 --> 00:02:03.000
これにより、コンパクトで効率的なコードを維持しながら、アプリに適したテクノロジーを選択して選択できます。

00:02:03.000 --> 00:02:10.000
Unityプラグインでは、同様のパターンに従います。各プラグインは、単一の基礎となるフレームワークにマップされます。

00:02:10.000 --> 00:02:15.000
これにより、ゲームのニーズに基づいて使用するプラグインのセットを選択して選択できます。

00:02:15.000 --> 00:02:23.000
各プラグインは、基盤となるフレームワークに可能な限り直接マッピングするC#ベースのUnityスクリプトを公開します。

00:02:23.000 --> 00:02:29.000
これを行うことは、基礎となるフレームワークに精通しているかもしれない知識がプラグインに引き継がれていることを意味します。

00:02:29.000 --> 00:02:35.000
概念、そして多くの場合、フレームワークAPIは直接引き継がれます。

00:02:35.000 --> 00:02:42.000
逆に、これはまた、プラグインを学習することで、暗黙的に基礎となるフレームワークを学習することを意味します。

00:02:42.000 --> 00:02:48.000
もう1つの重要な詳細は、これらのプラグインがAppleプラットフォームのネイティブライブラリとして構築されていることです。

00:02:48.000 --> 00:02:55.000
これらのライブラリは、C#スクリプトと基礎となるフレームワークAPIの間の接着剤として機能します。

00:02:55.000 --> 00:03:05.000
Apple UnityプラグインはUnityパッケージとして整理されているため、Unity Editorの組み込みパッケージマネージャーを使用して、プロジェクトへの統合を管理できます。

00:03:05.000 --> 00:03:18.000
場合によっては、プラグインには、プラグインでの作業をさらに簡単にし、すでに慣れ親しんでいるUnityインスペクタ主導のワークフローと一致する追加のエディタ機能も含まれています。

00:03:18.000 --> 00:03:28.000
もちろん、各プラグインは、詳細なreadmes、サンプル、および関連するApple Developerドキュメントなどの追加リソースへのリンクとペアになっています。

00:03:28.000 --> 00:03:35.000
次に、始めるのに役立ついくつかの重要なワークフローの概念を簡単に検討します。

00:03:35.000 --> 00:03:38.000
最初のステップは、GitHubからソースをクローンすることです。

00:03:38.000 --> 00:03:42.000
すべてのプロジェクトのソースとドキュメントは、そこで見つけることができます。

00:03:42.000 --> 00:03:47.000
これは、Apple Unityプラグインを使用するすべての人にとっての出発点です。

00:03:47.000 --> 00:03:52.000
リポジトリを複製したら、プラグインの構築が最初のタスクの1つになります。

00:03:52.000 --> 00:03:59.000
このプロセスを簡素化するために、リポジトリにはリポジトリルートにPythonスクリプトが含まれています:build.py。

00:03:59.000 --> 00:04:10.000
このスクリプトは、ネイティブライブラリの構築、正しい場所へのコピー、Unityメタファイルの更新、プラグインのパッキング、プラグインテストの構築を処理します。

00:04:10.000 --> 00:04:22.000
スクリプトは、最も単純な呼び出しがすべてのプラグインを構築し、それらをtarballにパッケージ化し、Unityプロジェクトに統合する準備ができているビルドフォルダに保存するように整理されています。

00:04:22.000 --> 00:04:32.000
プラグインを完全に構築して梱包するには、Xcode、Python3、npm、およびUnityが必要であることに注意することが重要です。

00:04:32.000 --> 00:04:38.000
最後に、プロジェクトリポジトリでbuild.pyを使用するための詳細なドキュメントがあります。

00:04:38.000 --> 00:04:42.000
今度は、各プラグインの詳細に飛び込む時です。

00:04:42.000 --> 00:04:57.000
各プラグインについて、Unityプロジェクトに追加する方法、含まれている機能の簡単な概要、主要なスクリプトの概念、およびUnity Editorのいくつかのコードスニペットまたは例について説明し、それらをプロジェクトに統合する方法を強調します。

00:04:57.000 --> 00:05:01.000
基本的なプラグイン、Apple.Coreから始めましょう。

00:05:01.000 --> 00:05:09.000
Apple.Coreは、各プラグインのビルド設定をUnityのプロジェクト設定ウィンドウ内の1つの環境設定ペインに統合します。

00:05:09.000 --> 00:05:21.000
各プラグインのネイティブライブラリをコンパイルするため、Apple.Coreにはアセットプロセッサも含まれており、各プラグインライブラリがインポート時に適切なプラットフォーム用に構成されていることを保証します。

00:05:21.000 --> 00:05:32.000
プロジェクトを構築するとき、Apple.Coreには、中間Xcodeプロジェクトでネイティブライブラリが正しく参照されるように、ビルドへの後処理として実行されるスクリプトも含まれています。

00:05:32.000 --> 00:05:44.000
各プラグインは基盤となるフレームワークと相互作用するため、Apple.Coreは一握りのランタイムインターオペタイプも定義し、C#スクリプトとネイティブコードレイヤー間のデータ転送を容易にします。

00:05:44.000 --> 00:05:49.000
最後に、Apple.Coreは他のすべてのApple Unityプラグインの依存関係です。

00:05:49.000 --> 00:05:55.000
これは、他のプラグインよりも先にApple.Coreをプロジェクトにインポートする必要があることを意味します。

00:05:55.000 --> 00:06:04.000
このデモでは、Apple.Coreプラグインを新しいプロジェクトにインポートする方法を紹介し、Apple Build Settingsの環境設定を簡単に説明します。

00:06:04.000 --> 00:06:11.000
プラグインが構築され、パックされると、Apple.CoreはUnity Package Managerでインポートできます。

00:06:11.000 --> 00:06:23.000
Tarballからパッケージを追加し、パッケージ化されたプラグインを参照するオプションを選択するだけです。

00:06:23.000 --> 00:06:26.000
その後、エディタはパッケージをロードし、スクリプトをコンパイルします。

00:06:26.000 --> 00:06:34.000
完了したら、Apple.Coreは使用できるようになります。

00:06:34.000 --> 00:06:46.000
Apple.Coreの主なユーザー向け機能は、エディターのプロジェクト設定ウィンドウにApple Build Settingsタブを追加することです。

00:06:46.000 --> 00:06:52.000
Apple Unityプラグインをインポートすると、利用可能なすべてのビルドオプションがここに表示されます。

00:06:52.000 --> 00:07:00.000
箱から出してすぐに、Apple.Coreには、最小サポートされているOSバージョンなど、いくつかのデフォルト設定オプションが付属しています。

00:07:00.000 --> 00:07:10.000
また、プラグインのポストプロセスビルドステップを無効にできることに注意することも便利です。

00:07:10.000 --> 00:07:18.000
最後に、中間Xcodeプロジェクトに伝播する共通のセキュリティ設定を構成できます。

00:07:18.000 --> 00:07:26.000
Game Centerプラグインを使用して、AppleのソーシャルゲームネットワークであるGame Centerを使用して、ゲームにさらに楽しさとつながりをもたらします。

00:07:26.000 --> 00:07:41.000
Game Centerは、プレイヤーがAppleプラットフォーム間でアイデンティティを構築し、安全で安全なプレイヤー認証、ゲーム内の成果、共有リーダーボード、プレイヤー間で送信されるチャレンジ、マルチプレイヤーマッチメイキングなどの機能を可能にします。

00:07:41.000 --> 00:07:49.000
ゲームに統合するGame Center機能を選択して選択できますが、すべてはプレイヤー認証から始まります。

00:07:49.000 --> 00:07:57.000
Game Centerのプレイヤー認証をゲームに追加すると、Game Centerウィジェットはプレイヤーのホーム画面またはApp Store内でゲームを特集できます。

00:07:57.000 --> 00:08:02.000
また、プレイヤー認証を追加するには、ほとんどコードを必要としません。

00:08:02.000 --> 00:08:06.000
最初のステップは、Apple.CoreとGameKitのプラグインをプロジェクトに追加することです。

00:08:06.000 --> 00:08:10.000
GameKitプラグインはGame Centerサービスを接続します。

00:08:10.000 --> 00:08:16.000
認証するときは、Game Centerサービスに接続し、GKLocalPlayerオブジェクトを初期化します。

00:08:16.000 --> 00:08:22.000
初期化したら、ローカルプレイヤーのプロフィールに基づいてプレイヤーの制限を照会します。

00:08:22.000 --> 00:08:34.000
これらの制限には、未成年プレイヤーのアダルトコンテンツまたは露骨なコンテンツへのアクセスの制限、マルチプレイヤー機能へのアクセスの制限、またはゲーム内コミュニケーションの無効化が含まれます。

00:08:34.000 --> 00:08:43.000
GKLocalPlayerとGame Centerサービスとの相互作用を管理する簡単な方法は、Unity内でコンポーネントを定義することです。

00:08:43.000 --> 00:08:47.000
たとえば、ここでは、単純なゲームマネージャーのコンポーネント定義です。

00:08:47.000 --> 00:08:50.000
このコンポーネントは、GKLocalPlayerへの参照を保持します。

00:08:50.000 --> 00:09:01.000
また、開始方法でプレイヤーの制限の認証とクエリの両方を処理します。プレイヤーの認証は、ゲームの存続期間中に一度だけ行う必要があります。

00:09:01.000 --> 00:09:04.000
これはGameManagerコンポーネントのスクリプトです。

00:09:04.000 --> 00:09:07.000
GKLocalPlayerをキャッシュするためのフィールドは次のとおりです。

00:09:07.000 --> 00:09:17.000
コンポーネントのstartメソッドの中には、GKLocalPlayerインスタンスを返す静的メソッドであるGKLocalPlayer.Authenticateへの1回限りの呼び出しがあります。

00:09:17.000 --> 00:09:22.000
ローカルプレーヤーが正常に認証されたら、プレーヤーの制限を確認する時間です。

00:09:22.000 --> 00:09:31.000
コードでプレイヤーの制限をチェックすると、一連のブールチェックに解決され、GameManagerコンポーネントのスクリプトのtryブロックに追加できます。

00:09:31.000 --> 00:09:36.000
ここでの真実は、ローカルプレーヤーが明示的なコンテンツへのアクセスを制限する必要があることを意味します。

00:09:36.000 --> 00:09:40.000
ここでの真実は、あなたの地元のプレイヤーが制限されたマルチプレイヤー体験を持つべきであることを意味します。

00:09:40.000 --> 00:09:46.000
そして最後に、ここでの真実は、ゲーム内通信を無効にする必要があることを意味します。

00:09:46.000 --> 00:09:51.000
そして、それはあなたのゲームにプレイヤー認証を追加するために必要なすべてのコード変更です。

00:09:51.000 --> 00:09:58.000
ここから、Game Centerを利用するためにゲームを完全に準備するために必要な2つの追加ステップがあります。

00:09:58.000 --> 00:10:04.000
まず、中級のXcodeプロジェクトにGame Center機能を追加する必要があります。

00:10:04.000 --> 00:10:07.000
これは、XcodeプロジェクトUI内から行われます。

00:10:07.000 --> 00:10:14.000
詳細については、Apple Developerのドキュメント記事「Game Centerの有効化と設定」を参照してください。

00:10:14.000 --> 00:10:20.000
次に、App Store Connectを使用してGame Centerの機能をアプリに追加する必要があります。

00:10:20.000 --> 00:10:23.000
詳細については、App Store Connectポータルをチェックしてください。

00:10:23.000 --> 00:10:30.000
これらの手順を完了すると、プレイヤーを認証し、安全なゲーム環境を確保する準備が整いました。

00:10:30.000 --> 00:10:37.000
プレイヤー認証は、Game Center Unityプラグインによって利用可能になった機能の表面を引っ掻くだけです。

00:10:37.000 --> 00:10:45.000
ゲームの発見可能性の向上の詳細については、「Game Centerダッシュボードで新しいプレイヤーにリーチする」セッションをチェックしてください。

00:10:45.000 --> 00:10:52.000
マルチプレイヤーとマッチメイキングの詳細については、昨年の「Game Centerの新機能」セッションをご覧ください。

00:10:52.000 --> 00:10:58.000
コントローラーは、プレイヤーがあなたが作成する世界と対話するための主要な方法です。

00:10:58.000 --> 00:11:04.000
ゲームコントローラープラグインを使用すると、ゲームに信頼性が高く柔軟なゲームコントローラーのサポートを簡単にもたらします。

00:11:04.000 --> 00:11:15.000
ゲームコントローラープラグインは、ゲームコントローラーのカスタマイズのサポートなど、いくつかの機能を備えており、プレイヤーはすべてのゲームのボタンを1か所に再マップできます。

00:11:15.000 --> 00:11:19.000
一貫したユーザーエクスペリエンスを確保するためのボタングリフ。

00:11:19.000 --> 00:11:27.000
また、すべてのMFiコントローラーだけでなく、一部のソニーやマイクロソフトのコントローラーなどのサードパーティのコントローラーもサポートしています。

00:11:27.000 --> 00:11:34.000
他のプラグインと同様に、パッケージマネージャーを使用して、Apple.CoreおよびGame Controllerプラグインをプロジェクトに追加します。

00:11:34.000 --> 00:11:40.000
Game Controllerプラグインがロードされた状態で、最初のステップはGCControllerServiceを初期化することです。

00:11:40.000 --> 00:11:46.000
まもなくわかるように、このサービスはコントローラーとその接続イベントへのアクセス方法です。

00:11:46.000 --> 00:11:52.000
初期化したら、現在システムに接続されているすべてのコントローラーについてGCControllerServiceを照会します。

00:11:52.000 --> 00:11:58.000
接続されたコントローラーは、ゲームコントローラープラグインのGCControllerオブジェクトで表されます。

00:11:58.000 --> 00:12:03.000
接続されている各GCControllerについて、更新されたコントローラの状態をポーリングします。

00:12:03.000 --> 00:12:11.000
ポーリングは、ゲームが必要とするのと同じくらい少ない、または頻繁に発生する可能性がありますが、始めるのに良い場所はUnityの定期的な更新ループです。

00:12:11.000 --> 00:12:20.000
コントローラの状態が更新されたら、ボタン、親指スティックなど、コントローラの個々の要素の入力をテストします。

00:12:20.000 --> 00:12:30.000
忘れないように、コントローラーはゲームのライフサイクル中に行き来するかもしれません - コントローラーの接続と切断イベントを処理するためにコールバックを登録します。

00:12:30.000 --> 00:12:36.000
ゲームコントローラープラグインを統合する簡単な方法は、簡単な入力マネージャーコンポーネントを作成することです。

00:12:36.000 --> 00:12:50.000
このコンポーネントには、現在接続されているすべてのコントローラを保持するコンテナ、初期化の開始方法、入力のポーリングとテストを処理するための更新方法の3つの重要な要素があります。

00:12:50.000 --> 00:12:53.000
まず、開始方法を詳しく見てみましょう。 

00:12:53.000 --> 00:12:58.000
これは、必要な1回限りのセットアップタスクをすべて行うのに最適な場所です。

00:12:58.000 --> 00:13:11.000
ゲームコントローラーサービスの初期化は、接続されたコントローラーの初期チェックと、接続および切断イベントのコールバックの登録とともに、ここで行われる必要があります。

00:13:11.000 --> 00:13:14.000
これが入力マネージャーコンポーネントのスクリプトです。

00:13:14.000 --> 00:13:23.000
すべてのワンタイムセットアップコードは、GCControllerServiceの呼び出しを含むコンポーネントの開始メソッドに入ります。初期化()。

00:13:23.000 --> 00:13:30.000
GetConnectedControllersを呼び出すと、現在接続されているすべてのコントローラの列挙可能なコンテナを取得します。

00:13:30.000 --> 00:13:37.000
最終的な初期化ステップは、コントローラの接続および切断イベントのコールバックを登録することです。

00:13:37.000 --> 00:13:50.000
初期化が完了したので、入力マネージャーは、接続された各コントローラをポーリングして入力状態を更新し、各コントローラの入力の入力状態を処理するための更新方法も必要です。

00:13:50.000 --> 00:13:55.000
入力をポーリングするには、接続されたコントローラーのセットを反復することから始めます。

00:13:55.000 --> 00:13:59.000
GCControllerのPollメソッドを呼び出して、最新の状態を収集します。

00:13:59.000 --> 00:14:05.000
次に、各ボタンの状態を確認し、それに応じて応答します。

00:14:05.000 --> 00:14:12.000
そして、ゲームコントローラープラグインを使用して接続されたコントローラーにアクセスし、コントローラーの入力を取得する方法を簡単に見てみましょう。

00:14:12.000 --> 00:14:27.000
ゲームコントローラーフレームワークについて詳しく知り、サードパーティのコントローラーや非標準入力などのトピックについては、前年のセッション「新しいゲームコントローラーのサポート」と「ゲームコントローラーのアドバンス」をチェックしてください。

00:14:27.000 --> 00:14:32.000
アクセシビリティとは、誰もがテクノロジーを利用できるようにすることです。

00:14:32.000 --> 00:14:41.000
アクセシビリティプラグインを使用して、幅広いAppleの支援技術をUnityベースのゲームに統合します。

00:14:41.000 --> 00:15:07.000
アクセシビリティプラグインは、プログラムでタグ付けされたコンテンツをユーザーに読み取ることができるVoiceOverなどの主要な機能を追加する機能を提供します。スイッチコントロールは、幅広い支援入力デバイスを可能にします。ダイナミックタイプは、ユーザーの好みに基づいてゲーム内のテキストとUIを簡単にスケーリングします。システム全体のアクセシビリティ設定に準拠するためのUIの宿泊施設設定。

00:15:07.000 --> 00:15:18.000
アクセシビリティプラグインでカバーすることがたくさんあるので、アクセシビリティユニティプラグインを深く掘り下げるために、「Unityゲームにアクセシビリティを追加する」セッションをチェックすることをお勧めします。

00:15:18.000 --> 00:15:28.000
そのセッションでは、例やユースケースを得るだけでなく、Appleプラットフォームでのアクセシビリティで何が可能かを理解することもできます。

00:15:28.000 --> 00:15:32.000
機会があればすぐにチェックしてください。お早めに。

00:15:32.000 --> 00:15:38.000
ゲームに触覚フィードバックを追加することは、没入感を高め、ゲームプレイ体験を向上させる素晴らしい方法です。

00:15:38.000 --> 00:15:43.000
Appleの高度な触覚機能とCore Hapticsプラグインを統合します。

00:15:43.000 --> 00:15:49.000
Core Hapticsプラグインを使用して、一連の触覚およびオーディオイベントからカスタム触覚パターンを構築します。

00:15:49.000 --> 00:15:52.000
同期したカスタムオーディオとハプティックを再生します。

00:15:52.000 --> 00:15:58.000
パラメータをリアルタイムで調整することで、触覚フィードバックをプログラムで定義または更新します。

00:15:58.000 --> 00:16:07.000
パターンをアセットとして設計および保存するためのファイルベースのアプローチには、Apple Haptic and Audio Patternファイル形式（AHAP）を使用します。

00:16:07.000 --> 00:16:12.000
インスペクタのサポートにより、Unity EditorでCore Hapticsパターンを調整します。

00:16:12.000 --> 00:16:20.000
Core Hapticsプラグインを最大限に活用するには、Core Hapticsの4つの基本的な要素とその相互関係を理解する必要があります。

00:16:20.000 --> 00:16:24.000
最高レベルの要素はCHHapticEngineです。

00:16:24.000 --> 00:16:31.000
触覚エンジンは、デバイス上の触覚サーバーへのリンクを表し、触覚パターンを再生するために必要です。

00:16:31.000 --> 00:16:35.000
CHHapticEngineはCHHapticPatternPlayersを作成します。

00:16:35.000 --> 00:16:44.000
パターンプレーヤーは、開始、停止、一時停止、再開などのコントロールを備えたCHHapticPatternsの再生に使用されます。

00:16:44.000 --> 00:16:50.000
CHHapticPatternは、1つ以上の触覚イベントとオーディオイベントの論理的なグループです。

00:16:50.000 --> 00:16:54.000
CHHapticEngineはパターンを使用してプレイヤーを作成します。

00:16:54.000 --> 00:17:00.000
CHHapticEventsは、触覚体験を定義するために使用される構成要素です。

00:17:00.000 --> 00:17:11.000
Core Hapticsはデータ駆動型APIで、ハプティックパターンをプログラムで定義したり、スクリプトで直接定義したり、AHAPファイルを活用したりできます。

00:17:11.000 --> 00:17:20.000
プロジェクトにCore Hapticsサポートを追加する簡単な方法の1つは、必要な各Core Hapticsオブジェクトを管理するHapticsコンポーネントを作成することです。

00:17:20.000 --> 00:17:29.000
以下は、CHHapticEngine、CHHapticPatternPlayer、およびAHAPアセットを含むHapticsコンポーネントの例です。

00:17:29.000 --> 00:17:34.000
AHAPアセットは、Core Hapticsプラグインで定義されたカスタムUnityアセットです。

00:17:34.000 --> 00:17:43.000
これにより、AHAPファイルへの簡単なインポートとエクスポート、およびパターンの作成とカスタマイズを管理するためのカスタムエディタ拡張機能が可能になります。

00:17:43.000 --> 00:17:46.000
詳しく見てみましょう。 

00:17:46.000 --> 00:17:52.000
まず、Apple.CoreとCore Hapticsの両方のプラグインがプロジェクトにインストールされていることを確認します。

00:17:52.000 --> 00:17:59.000
それらを追加すると、私は触覚でゲームを強化し始めることができます。

00:17:59.000 --> 00:18:03.000
これは、前の図に基づいて作成したハプティクスコンポーネントです。

00:18:03.000 --> 00:18:12.000
すぐに実装を確認しますが、とりあえず飛行機に取り付けます。お取りします。

00:18:12.000 --> 00:18:20.000
添付すると、コンポーネントにAHAPアセットが必要であることがわかりますが、私のAHAPアセットフォルダは空です。

00:18:20.000 --> 00:18:29.000
アセット&gt;作成&gt;Apple&gt;CoreHaptics&gt;AHAPに移動して、新しいものを作成します。

00:18:29.000 --> 00:18:39.000
一度作成したら、私はそれに幻想的でオリジナルの名前を与えます:MyHapticPattern。

00:18:39.000 --> 00:18:46.000
Core Hapticsプラグインには、インスペクタウィンドウで新しいパターンを調整できるエディタ拡張機能が付属しています。

00:18:46.000 --> 00:18:53.000
これは、再生できるCHHapticPatternの一部であるCHHapticEventsを定義する場所です。

00:18:53.000 --> 00:19:01.000
デフォルトでは、一時的なイベントがありますが、連続イベントも簡単に追加できます。

00:19:01.000 --> 00:19:06.000
UIには、インポート、エクスポート、リセットボタンもあります。

00:19:06.000 --> 00:19:13.000
リセットは、追加したイベントをクリアし、パターンをデフォルトの状態に戻します。

00:19:13.000 --> 00:19:16.000
インポートとエクスポートは素晴らしい機能です。

00:19:16.000 --> 00:19:23.000
これにより、プロジェクトはAHAPファイルをロードして保存できます。

00:19:23.000 --> 00:19:34.000
ここでは、素敵な振動効果を引き起こすランブルと呼ばれる事前定義されたAHAPをインポートしましたが、少しだけ微調整する必要があると思います。

00:19:34.000 --> 00:19:51.000
パターンを更新したので、この改善された触覚パターンを他のチームと共有するために、新しいAHAPファイルにエクスポートすることができます。

00:19:51.000 --> 00:19:59.000
私の資産が作成され、調整されたので、私は飛行機に戻り、それをMyHapticPatternに向けます。

00:19:59.000 --> 00:20:03.000
すごい！すべてが配線されています。

00:20:03.000 --> 00:20:11.000
触覚パターンが定義され、適切に参照されると、残っているのは、触覚パターンを再生できるように、Hapticsコンポーネントにロジックを追加することだけです。

00:20:11.000 --> 00:20:17.000
これは、PrepareHapticsとPlayの2つの方法に分けることができます。

00:20:17.000 --> 00:20:24.000
PrepareHapticsは、触覚エンジンが初期化され、触覚パターンプレーヤーが作成される場所です。

00:20:24.000 --> 00:20:30.000
再生は、CHHapticPatternPlayerの開始メソッドを呼び出して再生を開始するだけです。

00:20:30.000 --> 00:20:34.000
そして、これがHapticsコンポーネントスクリプトです。

00:20:34.000 --> 00:20:39.000
フィールドは、ハプティックエンジンとハプティックプレーヤー用に定義されています。

00:20:39.000 --> 00:20:46.000
重要なのは、erializeField属性を追加して、エディタUIでAHAPアセットを設定できるようにすることです。

00:20:46.000 --> 00:20:56.000
次に、コードを追加してCHHapticEngineを作成し、起動し、参照アセットから直接AHAPにアクセスして触覚パターンプレーヤーを作成します。

00:20:56.000 --> 00:21:02.000
もちろん、プレイヤーにスタートを呼び出すと、触覚パターンが再生されます。

00:21:02.000 --> 00:21:08.000
Core Haptics Unityプラグインは、ゲームにまったく新しいレベルの没入感を追加するために必要なツールを提供します。

00:21:08.000 --> 00:21:15.000
Core Hapticsプラグインを使用して、見た目、音、感触がリアルに感じる魔法のゲームの瞬間を作成します。

00:21:15.000 --> 00:21:21.000
コアハプティクスを深く掘り下げるには、「コアハプティクスの紹介」セッションをご覧ください。

00:21:21.000 --> 00:21:32.000
魅力的なハプティック体験の設計の詳細については、「オーディオハプティック体験の設計」と「オーディオハプティックデザインの練習」を必ずご覧ください。

00:21:32.000 --> 00:21:37.000
没入型オーディオは、素晴らしいゲーム体験の非常に重要な側面です。

00:21:37.000 --> 00:21:45.000
PHASE Unityプラグインを使用して、クリエイティブな可能性を解き放ち、ゲームの世界に緑豊かなサウンドスケープを構築します。

00:21:45.000 --> 00:21:51.000
PHASEを使用すると、ゲームに複雑でダイナミックなオーディオ体験を提供できます。

00:21:51.000 --> 00:21:57.000
ジオメトリを意識したオーディオとは、音がシーン内のメッシュから発せられ、相互作用することを意味します。

00:21:57.000 --> 00:22:02.000
ゲームの環境は、残響と反射を通してより現実的に聞こえます。

00:22:02.000 --> 00:22:14.000
ゲームプレイ中に動的オーディオ制御を可能にする階層的なオーディオグラフを構築できます。PHASEプラグインには、ゲーム対応の事前定義されたコンポーネントのセットが含まれています。

00:22:14.000 --> 00:22:21.000
ゲームオブジェクトに添付するだけで、コードを1行も書かずにPHASEを使い始めることができます。

00:22:21.000 --> 00:22:24.000
最初のコンポーネントはPHASEListenerコンポーネントです。

00:22:24.000 --> 00:22:33.000
ゲームシーンの「耳」として機能し、その位置、向き、リバーブのプリセットに基づいてオーディオを処理します。

00:22:33.000 --> 00:22:36.000
次はPHASEOccluderコンポーネントです。

00:22:36.000 --> 00:22:46.000
PHASEOccludersは、ジオメトリデータを使用してゲームオブジェクトにアタッチし、ソースとシーン内のリスナーの間に来るとオーディオを減衰させます。

00:22:46.000 --> 00:22:48.000
次はPHASESourceコンポーネントです。

00:22:48.000 --> 00:22:55.000
これらはゲームオブジェクトに添付され、オブジェクトの変換を使用してゲームの世界で音を配置します。

00:22:55.000 --> 00:23:02.000
組み込みコンポーネントに加えて、PHASEプラグインはカスタムアセットであるSoundEventアセットも定義します。

00:23:02.000 --> 00:23:09.000
サウンドイベントは、オーディオ再生イベントを記述し、シーン内のソースによって再生されるオーディオを定義するオブジェクトです。

00:23:09.000 --> 00:23:17.000
PHASEプラグインの使用を開始するには、最初のステップは、Apple.CoreプラグインとPHASEプラグインの両方がプロジェクトに追加されていることを確認することです。

00:23:17.000 --> 00:23:22.000
インストールしたら、付属のコンポーネントをシーンに追加し始めることができます。

00:23:22.000 --> 00:23:31.000
このサンプルプロジェクトでは、飛行機、建物、そしてカメラの3つのゲームオブジェクトに興味があります。

00:23:31.000 --> 00:23:36.000
まず、PHASEListenerコンポーネントをカメラに取り付けます。

00:23:36.000 --> 00:23:40.000
そうすることで、私はシーンに「耳」を追加しました。

00:23:40.000 --> 00:23:48.000
次に、PHASEOccluderコンポーネントを取り付けて、建物をオクルーダーにします。

00:23:48.000 --> 00:23:55.000
最後に、飛行機にPHASESourceコンポーネントを追加して、シーンにソースを追加します。

00:23:55.000 --> 00:24:04.000
ソースを追加したので、再生するにはオーディオが必要なので、サウンドイベントを添付する必要がありますが、サウンドイベントフォルダは空です。

00:24:04.000 --> 00:24:14.000
アセット&gt;作成&gt;アップル&gt;フェーズ&gt;サウンドイベントに移動して作成できます。

00:24:14.000 --> 00:24:20.000
サウンドイベントを作成すると、PHASEプラグインはすぐにPHASEサウンドイベントコンポーザーウィンドウを開きます。

00:24:20.000 --> 00:24:24.000
これは、サウンドイベントを構築するために使用されるキャンバスです。

00:24:24.000 --> 00:24:27.000
ウィンドウ内の任意の場所を右クリックすることから始めます。

00:24:27.000 --> 00:24:31.000
これは、イベントにノードを追加できるポップアップを示しています。

00:24:31.000 --> 00:24:36.000
クリップを再生したいので、サンプラーノードを作成します。

00:24:36.000 --> 00:24:45.000
私はすでにアイドリング飛行機のオーディオクリップをプロジェクトに追加したので、ここで参照できます。

00:24:45.000 --> 00:24:50.000
飛行機がハミングし続けるように、ループを有効にし続けます。

00:24:50.000 --> 00:24:53.000
飛行機の音を聞くには、それをミキサーにルーティングする必要があります。

00:24:53.000 --> 00:25:05.000
出力ラインをイベントコンポーザーのキャンバスにドラッグすると、ミキサーを作成できます。ミキサーを作成するオプションが表示されます。

00:25:05.000 --> 00:25:10.000
私のサウンドイベントが完成し、使用する準備が整いました。

00:25:10.000 --> 00:25:16.000
サウンドイベントをクリックすると、インスペクタでその設定を直接見ることができます。

00:25:16.000 --> 00:25:22.000
これにより、サウンドイベントコンポーザーに戻ることなく値を調整できます。

00:25:22.000 --> 00:25:30.000
サウンドイベントが作成されると、以前に飛行機に取り付けたPHASESourceコンポーネントで参照できるようになりました。

00:25:30.000 --> 00:25:35.000
そして、それに伴い、シーン内のオーディオがルーティングされ、再生用に構成されます。

00:25:35.000 --> 00:25:41.000
PHASE Unityプラグインは、ゲーム内のオーディオデザインに全く新しい可能性を開きます。

00:25:41.000 --> 00:25:54.000
PHASEについてもっと学び、今日紹介した概念を深く掘り下げるには、Apple Developerのドキュメントサイトと昨年のWWDC入門セッションビデオを必ずチェックしてください。

00:25:54.000 --> 00:25:59.000
これで、新しいApple Unityプラグインの概要は終わりです。

00:25:59.000 --> 00:26:09.000
今日は多くのことを取り上げましたが、Apple Unityプラグインについてもっと知りたい場合は、GitHubのリポジトリから始めるのに最適な場所です。

00:26:09.000 --> 00:26:17.000
そこで、各プラグインのソース、詳細なドキュメント、サンプルを見つけることができます。

00:26:17.000 --> 00:26:32.000
「Unityゲームにアクセシビリティを追加」セッションでUnityゲームにアクセシビリティを統合する方法の詳細を確認し、「Game Centerダッシュボードで新しいプレイヤーにリーチする」をチェックして、ゲームの可視性を高める方法を学んでください。

00:26:32.000 --> 00:26:34.000
ご覧いただきありがとうございます。

00:26:34.000 --> 23:59:59.000
♪

