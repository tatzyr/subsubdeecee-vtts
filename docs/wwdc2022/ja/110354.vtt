WEBVTT

00:00:00.000 -> 00:00:03.000
♪まろやかなインストゥルメンタルヒップホップ音楽♪

00:00:03.000 -> 00:00:09.000
♪

00:00:09.000 -> 00:00:11.000
こんにちは、私はアンジェラです。

00:00:11.000 -> 00:00:13.000
そして私はベッカです。

00:00:13.000 -> 00:00:15.000
スウィフトの新機能へようこそ!

00:00:15.000 -> 00:00:21.000
今日、Swift 5.7のすべての素晴らしい新機能についてお話しできることを本当に楽しみにしています。

00:00:21.000 -> 00:00:28.000
今日話すことの多くは、開発者としての生活を楽にするというSwiftの目標を示しています。

00:00:28.000 -> 00:00:35.000
ワークフローといくつかの驚くべき改善をカスタマイズするのに役立つ新しいツールを見ていきます。

00:00:35.000 -> 00:00:43.000
次に、最新のSwiftの並行性モデルと、フルスレッドの安全性を含むSwift 6への道について話します。

00:00:43.000 -> 00:00:54.000
最後に、よりクリーンでシンプルなジェネリック、強力な新しい文字列処理機能など、Swiftの読み書きを容易にするいくつかの言語改善を案内します。

00:00:54.000 -> 00:01:02.000
しかし、まず、スウィフトを特別なものにしているものの1つについて話すことから始めましょう。

00:01:02.000 -> 00:01:08.000
あなたのインプットと貢献は、Swiftが急速に拡大することを可能にしたものです。

00:01:08.000 -> 00:01:11.000
コミュニティの関与はスウィフトの中核です。

00:01:11.000 -> 00:01:23.000
今年は、昨年発表されたドキュメント生成ツールであるdocCとSwift.orgのウェブサイトがオープンソース化されたときに、より多くのSwiftプロジェクトがコミュニティで利用可能になりました。

00:01:23.000 -> 00:01:28.000
オープンソースは、活発なコミュニティがそれを羊飼いしているときに最もよく機能します。

00:01:28.000 -> 00:01:38.000
私たちは、サーバー上のSwiftとSwiftのDiversityのワークグループモデルを使用して、特定の分野に関心のあるコミュニティメンバーにスチュワードシップとサポートを提供してきました。

00:01:38.000 -> 00:01:42.000
これは本当にうまくいっているので、2つの新しいワークグループを開始しました。

00:01:42.000 -> 00:01:54.000
1つはSwiftのウェブサイトで反復してコミュニティリソースにするためのもので、もう1つはC ++の相互運用性で、C ++とSwiftの間のモデルのデザインを形作るためです。

00:01:54.000 -> 00:02:00.000
新しい分野に進出する際には、コミュニティ内のメンバーからのサポートが必要です。

00:02:00.000 -> 00:02:05.000
その一環として、Diversity in Swiftワークグループは昨年、Swiftメンターシッププログラムを導入しました。

00:02:05.000 -> 00:02:15.000
このプログラムは、開始方法を知らない、または特定の分野で専門知識を深めようとしている人々のために、すべてのワークグループ分野に貢献するための経路を提供します。

00:02:15.000 -> 00:02:18.000
昨年のプログラムは大成功でした。

00:02:18.000 -> 00:02:25.000
興味のあるメンティーがたくさんいました。それで、私たちは41のメンターシップペアを作ることができました。

00:02:25.000 -> 00:02:30.000
この成功は、プログラムが2年目に戻ってくる理由です。

00:02:30.000 -> 00:02:42.000
このプログラムには、興味のあるすべての人を含めたいと思っています。しかし、それを行うには、私たちはあなたが必要です - 今聞いている興奮した経験豊富な開発者は、彼らの知識の幅を共有し、新しい接続を作る準備ができています。

00:02:42.000 -> 00:02:49.000
メンターシッププログラムは、コードだけでなく、コミュニティ内で関係を築くことだからです。

00:02:49.000 -> 00:02:52.000
そして、少しのガイダンスは永続的な効果をもたらすことができます。

00:02:52.000 -> 00:02:54.000
私の言葉を信じないでください。 

00:02:54.000 -> 00:03:00.000
昨年、アムリットはメンターシッププログラムに参加し、コンパイラと言語設計に焦点を当てました。

00:03:00.000 -> 00:03:06.000
アムリットの陰謀として始まったものは、具体的な貢献に変わりました。

00:03:06.000 -> 00:03:09.000
新しいドメインに飛び込むのは簡単ではありません。

00:03:09.000 -> 00:03:14.000
それでも、彼女は成功を見つけ、もっと貢献するインスピレーションを感じながら立ち去りました。

00:03:14.000 -> 00:03:19.000
他の多くの人と同様に、この経験はアムリットの扉を開きました。

00:03:19.000 -> 00:03:30.000
コンパイラと言語設計に加えて、昨年は、テクニカルライティングやテストからSwiftパッケージへの貢献まで、幅広い重点分野がありました。

00:03:30.000 -> 00:03:36.000
今年はさらに追加し、常に新しいトピックの機会があります。

00:03:36.000 -> 00:03:42.000
このリストに興味のあるものが見当たらない場合は、アプリケーションで言及することができます。

00:03:42.000 -> 00:03:54.000
もう1つの追加は、今年のプログラムは、参加する能力が低いかもしれないが、まだ参加することに興奮している人を収容するために、スターターバグ貢献のためのメンターシップを一年中提供することです。

00:03:54.000 -> 00:04:00.000
応募に興味がある場合、またはもっと聞きたい場合は、最新のSwiftブログ記事をチェックしてください。

00:04:00.000 -> 00:04:05.000
そこでは、ハイライトされたメンティーからの詳細な考察へのリンクを見つけることができます。

00:04:05.000 -> 00:04:10.000
メンターシッププログラムは、Diversity in Swiftの傘下にある1つのイニシアチブにすぎません。

00:04:10.000 -> 00:04:17.000
メンターシッププログラムやその他のDiversity in Swiftの取り組みの詳細については、Swift.org/diversityをご覧ください。

00:04:17.000 -> 00:04:24.000
さらにドアを開けるために、あなたが持っているリソースでSwiftをできるだけ簡単に使用できるようにしたいと考えています!

00:04:24.000 -> 00:04:32.000
Linuxパッケージ形式のサポートを追加することで、LinuxプラットフォームのSwiftツールチェーン配布プロセスを合理化しました。

00:04:32.000 -> 00:04:40.000
新しいネイティブツールチェーンインストーラーを使用すると、Amazon Linux 2とCentOS 7のRPMをSwift.orgから直接ダウンロードできます。

00:04:40.000 -> 00:04:45.000
これらのツールチェーンは実験的なので、必ずSwift.orgフォーラムでフィードバックを共有してください。

00:04:45.000 -> 00:04:48.000
Swiftは主にアプリの構築に使用されます。

00:04:48.000 -> 00:04:57.000
しかし、ビジョンは常にSwiftがスケーラブルになることでした。高レベルのスクリプトからベアメタル環境まで、あらゆるものから使用されています。

00:04:57.000 -> 00:05:04.000
これまでに使用されたことのない場所でスウィフトを使用することを奨励するために、スウィフトは今年いくつかの大きな変更を受けました。

00:05:04.000 -> 00:05:17.000
スタンドアロンの静的にリンクされたバイナリの標準ライブラリを小さくするために、外部Unicodeサポートライブラリへの依存を削除し、より高速なネイティブ実装に置き換えました。

00:05:17.000 -> 00:05:22.000
イベント駆動型サーバーソリューションで実行する場合、より小さく、より高速なバイナリは大きな利点です。

00:05:22.000 -> 00:05:28.000
サーバーのコンテナ化された展開をよりよくサポートするために、デフォルトでLinuxで静的リンクを取得します。

00:05:28.000 -> 00:05:36.000
このサイズ縮小により、Swiftは制限された環境にも適しており、AppleのSecure Enclaveプロセッサーで使用できるようになりました。

00:05:36.000 -> 00:05:46.000
Swiftは、アプリからサーバー、制限されたプロセッサまで便利です。それをすべて結びつけるのは、パッケージエコシステムです。

00:05:46.000 -> 00:05:50.000
今年のSwiftパッケージの新機能は、あなたの人生をより良くするでしょう。

00:05:50.000 -> 00:05:55.000
まず、Swift Package ManagerはTOFUを導入しました。

00:05:55.000 -> 00:05:58.000
いいえ、おいしいおやつではありません。

00:05:58.000 -> 00:06:01.000
TOFUはTrust On First Useの頭字語です。

00:06:01.000 -> 00:06:08.000
これは、パッケージが最初にダウンロードされたときにパッケージの指紋が記録される新しいセキュリティプロトコルです。

00:06:08.000 -> 00:06:14.000
その後のダウンロードでは、この指紋を検証し、指紋が異なる場合はエラーを報告します。

00:06:14.000 -> 00:06:23.000
これは、信頼とセキュリティがパッケージエコシステムのコアに組み込まれ、自信を持って使用できるようにするための一例にすぎません。

00:06:23.000 -> 00:06:28.000
コマンドプラグインは、Swift開発者のワークフローを改善する素晴らしい方法です。

00:06:28.000 -> 00:06:32.000
これらは、より拡張可能で安全なビルドツールを提供するための第一歩です。

00:06:32.000 -> 00:06:38.000
コマンドプラグインは、ドキュメントの生成、ソースコードの再フォーマットなどに使用できます。

00:06:38.000 -> 00:06:44.000
シェルスクリプトで自動化を書き、別々のワークフローを維持する代わりに、Swiftを使用できます!

00:06:44.000 -> 00:06:46.000
オープンソースのフォーマッタとリンターを考えてください。

00:06:46.000 -> 00:06:53.000
現在、これらのオープンソースツールはすべてXcodeとSwift Package Managerで利用できます。

00:06:53.000 -> 00:06:58.000
コマンドプラグインは、オープンソースツールとSwift Package Managerの間の接着剤です。

00:06:58.000 -> 00:07:06.000
Swiftプロジェクトは、自動化されたワークフローとのシームレスな統合を提供するために、オープンソースコミュニティの開発者ツールを採用しています。

00:07:06.000 -> 00:07:10.000
docCは、ドキュメントをソースコードに統合するための素晴らしいツールです。

00:07:10.000 -> 00:07:14.000
今年は、Objective-CとCのサポートでさらに良くなりました。

00:07:14.000 -> 00:07:19.000
docCでプラグインを作成するために何時間がかかるかを見てみましょう。

00:07:19.000 -> 00:07:20.000
プラグインは単純なSwiftコードです。

00:07:20.000 -> 00:07:25.000
CommandPluginプロトコルに準拠した構造体を作成することで、プラグインを定義できます。

00:07:25.000 -> 00:07:30.000
そして、どのツールを呼び出すかをプラグインに伝える関数を追加するだけです。

00:07:30.000 -> 00:07:34.000
この関数内では、docCを呼び出す場所です。

00:07:34.000 -> 00:07:40.000
プラグインを定義すると、Swift PMコマンドラインインターフェイスとXcodeをメニューエントリとして利用できるようになります。

00:07:40.000 -> 00:07:48.000
これで、Swift PMにドキュメントを生成するように指示することができ、このアクションをdocC実行可能ファイルに渡すことを知っています。

00:07:48.000 -> 00:07:50.000
それはそこで止まりません。

00:07:50.000 -> 00:07:54.000
ビルドツールプラグインと呼ばれる2番目のプラグインがあります。

00:07:54.000 -> 00:07:59.000
これらのプラグインは、ビルド中に追加のステップを注入できるパッケージです。

00:07:59.000 -> 00:08:05.000
ビルドツールプラグインを実装すると、ビルドシステムがサンドボックスで実行するためのコマンドが作成されます。

00:08:05.000 -> 00:08:13.000
これらは、いつでも直接実行するコマンドプラグインとは異なり、パッケージ内のファイルを変更する明示的な許可を与えることができます。

00:08:13.000 -> 00:08:20.000
ビルドツールプラグインは、ソースコードの生成や特別な種類のファイルのカスタム処理に使用できます。

00:08:20.000 -> 00:08:23.000
ビルドツールプラグインでは、これはパッケージレイアウトになります。

00:08:23.000 -> 00:08:29.000
この例では、plugin.Swiftは、パッケージプラグインターゲットを実装するSwiftスクリプトです。

00:08:29.000 -> 00:08:33.000
プラグインはSwift実行可能ファイルとして扱われます。

00:08:33.000 -> 00:08:38.000
そして、Swiftの実行可能ファイルを書くのと同じ方法でプラグインを書きます。

00:08:38.000 -> 00:08:48.000
実行する実行可能なコマンドと結果として期待される出力をビルドシステムに指示するビルドコマンドのセットを定義することで、プラグインを実装できます。

00:08:48.000 -> 00:08:53.000
パッケージプラグインは、パッケージの拡張性を提供する安全なソリューションです。

00:08:53.000 -> 00:09:03.000
「Swiftパッケージプラグインに会う」と「Swiftパッケージプラグインを作成する」の2つのセッションで、プラグインの仕組みと独自のプラグインを実装する方法について詳しく知ることができます。

00:09:03.000 -> 00:09:08.000
パッケージの使用を拡大すると、モジュールの衝突に遭遇した可能性があります。

00:09:08.000 -> 00:09:12.000
それは、2つの別々のパッケージが同じ名前のモジュールを定義するときです。

00:09:12.000 -> 00:09:19.000
この状況を解決するために、Swift 5.7はモジュールの曖昧さ回避を導入しています。

00:09:19.000 -> 00:09:26.000
モジュールの曖昧さ回避は、モジュールを定義するパッケージの外部からモジュールの名前を変更できる機能です。

00:09:26.000 -> 00:09:33.000
ここStunningアプリケーションでは、ロギングモジュールを定義する2つのパッケージが導入されているので、それらは衝突します。

00:09:33.000 -> 00:09:42.000
見事なアプリケーションでこれを修正するには、パッケージマニフェストの依存関係セクションにmoduleAliasesキーワードを追加するだけです。

00:09:42.000 -> 00:09:49.000
そうすれば、2つの異なる名前を使用して、以前は同じ名前のモジュールを区別できます。

00:09:49.000 -> 00:09:53.000
Swift 5.7は、いくつかの素晴らしいパフォーマンスの向上をもたらします。

00:09:53.000 -> 00:09:56.000
ビルド時間を見ることから始めましょう。

00:09:56.000 -> 00:10:04.000
昨年、SwiftでSwiftソースコードのコンパイルを調整するプログラムであるSwift Driverをどのように書き換えたかについて話しました。

00:10:04.000 -> 00:10:09.000
昨年の再アーキテクチャは、ビルドを大幅にスピードアップするいくつかの本当に重要な変更のロックを解除しました。

00:10:09.000 -> 00:10:16.000
ドライバーは、別の実行可能ファイルとしてではなく、Xcodeビルドシステム内で直接フレームワークとして使用できるようになりました。

00:10:16.000 -> 00:10:22.000
これにより、ビルドシステムとより密接にビルドを調整して、並列化などを可能にすることができます。

00:10:22.000 -> 00:10:31.000
クイックビルドのサウンドを愛する人なら、「Xcodeビルドで並列化を解明する」セッションで詳細を確認できます。

00:10:31.000 -> 00:10:39.000
ビルドがどれだけ速いかを示すために、Swiftで書かれたよく使用するツールのいくつかを構築するのにどれくらいの時間がかかるかの例を見てみましょう。

00:10:39.000 -> 00:10:46.000
10コアのiMacでは、改善は5%から25%までの範囲でした。

00:10:46.000 -> 00:10:49.000
次に、タイプチェックの速度が改善されます。

00:10:49.000 -> 00:11:00.000
今年は、ジェネリックシステムの重要な部分、つまりプロトコルや「where」句などから関数の署名を計算する部分を再実装することで、タイプチェッカーのパフォーマンスを改善しました。

00:11:00.000 -> 00:11:07.000
古い実装では、より多くのプロトコルが関与するにつれて、時間とメモリの使用が指数関数的に拡大する可能性があります。

00:11:07.000 -> 00:11:16.000
たとえば、ここでは、座標系を定義する複雑なプロトコルのセットがあり、多くの関連するタイプに多くの一般的な要件があります。

00:11:16.000 -> 00:11:20.000
以前は、このコードの入力チェックに17秒かかりました。

00:11:20.000 -> 00:11:28.000
しかし今、Swift 5.7では、この例は1秒未満で大幅に速くタイプチェックすることができます。

00:11:28.000 -> 00:11:32.000
また、同様に印象的なランタイムの改善もあります。

00:11:32.000 -> 00:11:39.000
Swift 5.7より前は、アプリの起動時のプロトコルチェックがiOSで4秒もかかるのを見てきました。

00:11:39.000 -> 00:11:46.000
アプリを起動するたびにプロトコルを計算する必要があり、その結果、追加したプロトコルが増えるほど起動時間が長くなりました。

00:11:46.000 -> 00:11:48.000
今、それらはキャッシュされています。

00:11:48.000 -> 00:11:58.000
アプリがどのように書かれたか、使用したプロトコルの数に応じて、これはiOS 16で実行しているときに一部のアプリで起動時間が半分に短縮されることを意味します。

00:11:58.000 -> 00:12:07.000
「アプリのサイズとランタイムのパフォーマンスを向上させる」セッションでは、これらの改善を独自のアプリケーションで活用する方法をより深く掘り下げます。

00:12:07.000 -> 00:12:12.000
今、あなたの多くが聞きたがっていると確信している何かのための時間です。

00:12:12.000 -> 00:12:19.000
昨年、私たちは新しい並行性モデルを導入し、俳優と非同期/待機を結集しました。

00:12:19.000 -> 00:12:25.000
これは、アプリケーションの並行性アーキテクチャに変革的な影響を与えました。

00:12:25.000 -> 00:12:31.000
非同期/待機とアクターは、コールバックや手動キュー管理よりも安全で簡単です。

00:12:31.000 -> 00:12:37.000
今年は、データレースの安全性を最前線に、モデルをさらに具体化しました。

00:12:37.000 -> 00:12:48.000
並行性は、アプリのコードベースにとって非常に根本的かつ重要な改善であったため、これらの変更をiOS 13とmacOS Catalinaにさかのぼって展開することを可能にしました。

00:12:48.000 -> 00:12:55.000
古いオペレーティングシステムにデプロイするために、アプリは古いOS用のSwift 5.5並行性ランタイムのコピーをバンドルします。

00:12:55.000 -> 00:13:01.000
これは、ABIの安定性の前にSwiftをオペレーティングシステムにバックデプロイするのと似ています。

00:13:01.000 -> 00:13:05.000
次に、このモデルを新しい方向に導きました。

00:13:05.000 -> 00:13:08.000
言語機能とサポートパッケージを導入しました。

00:13:08.000 -> 00:13:12.000
まず、データレース回避について話しましょう。

00:13:12.000 -> 00:13:20.000
それに飛び込む前に、私はおそらく一歩下がって、Swiftの本当に重要な機能の1つは、デフォルトでのメモリの安全性であると言うべきです。

00:13:20.000 -> 00:13:27.000
Swiftユーザーは、変更中に値を読み込むなど、予測不可能な動作を行うことはできません。

00:13:27.000 -> 00:13:33.000
この例では、同じ配列のカウントに一致する配列内のすべての数値を削除しています。

00:13:33.000 -> 00:13:38.000
最初は、配列のカウントは3なので、配列から3を削除します。

00:13:38.000 -> 00:13:41.000
しかし、それを行うと、カウントは2になります。

00:13:41.000 -> 00:13:46.000
配列から3と2を削除しますか、それとも3だけですか？

00:13:46.000 -> 00:13:48.000
答えはどちらでもない。

00:13:48.000 -> 00:13:55.000
Swiftは、変更中に配列のカウントにアクセスするのは安全ではないため、これを行うのを防ぎます。

00:13:55.000 -> 00:13:58.000
私たちの目標は、糸の安全性のために似たようなことをすることです。

00:13:58.000 -> 00:14:03.000
私たちは、デフォルトで低レベルのデータレースを排除する言語を想定しています。

00:14:03.000 -> 00:14:09.000
言い換えれば、予測不可能な動作を引き起こす可能性のある並行性のバグを防ぎたい。

00:14:09.000 -> 00:14:10.000
これは別の例です。

00:14:10.000 -> 00:14:20.000
同じ番号の配列を使用して、配列に0を追加するバックグラウンドタスクを作成し、配列の最後の要素を削除します。

00:14:20.000 -> 00:14:26.000
しかし、待ってください、最後の要素を削除することは、0を追加する前または後に起こりますか?

00:14:26.000 -> 00:14:29.000
答えも、やはり、どちらでもない。

00:14:29.000 -> 00:14:38.000
Swiftは、アクターのようなものとアクセスを同期せずにバックグラウンドタスクから配列を変更するのは安全ではないため、これを行うことをブロックします。

00:14:38.000 -> 00:14:42.000
俳優は、データレースを排除するための最初の大きな一歩でした。

00:14:42.000 -> 00:14:49.000
今年は、最終目標に向けてさらに前進するために、並行性モデルを洗練しました。

00:14:49.000 -> 00:14:56.000
それぞれの俳優は、並行性の海にある他のすべてから隔離された独自の島と考えることができます。

00:14:56.000 -> 00:15:03.000
しかし、異なるスレッドが各孤立したアクターによって保存された情報を照会したい場合、どうなりますか?

00:15:03.000 -> 00:15:10.000
この比喩は、「Swift Concurrencyを使用してデータレースを排除する」セッションで深く掘り下げられます。

00:15:10.000 -> 00:15:16.000
メモリの安全性からデフォルトでスレッドの安全性まで、それがSwift 6の目標です。

00:15:16.000 -> 00:15:23.000
そこに着くために、私たちは最初に私が言及した新しい言語機能で昨年の並行性モデルを改善しました。

00:15:23.000 -> 00:15:30.000
私がまだ言及していない2番目のことは、潜在的なデータレースを特定する新しいオプトイン安全チェックです。

00:15:30.000 -> 00:15:36.000
ビルド設定で有効にすることで、より厳格な並行性チェックを試すことができます。

00:15:36.000 -> 00:15:38.000
俳優をもう一度見てみましょう。

00:15:38.000 -> 00:15:44.000
私たちは、この俳優の孤立の概念を取り、分散した俳優とそれをさらに進めることができます。

00:15:44.000 -> 00:15:49.000
分散アクターは、それらの間のネットワークを持つ異なるマシンにそれらの島を置きます。

00:15:49.000 -> 00:15:54.000
この新しい言語機能により、分散システムの開発がはるかに簡単になります。

00:15:54.000 -> 00:15:59.000
ゲームアプリを作りたいとしましょう。これで、Swiftでバックエンドを簡単に書くことができます。

00:15:59.000 -> 00:16:04.000
ここでは、配布された俳優は俳優のようなものですが、別のマシン上にあるかもしれません。

00:16:04.000 -> 00:16:11.000
この例では、ユーザーとのゲーム中に状態を維持するコンピュータープレーヤーを見ています。

00:16:11.000 -> 00:16:19.000
分散キーワードは、リモートマシン上にある可能性のあるアクターで呼び出す必要があると予想される関数に追加することもできます。

00:16:19.000 -> 00:16:22.000
endOfRoundという別の関数を追加しましょう。

00:16:22.000 -> 00:16:26.000
プレイヤーをループし、それぞれでmakeMoveを呼び出します。

00:16:26.000 -> 00:16:33.000
これらのプレーヤーの中には、ローカルまたはリモートであるものもありますが、どちらがどちらであるかを気にする必要がないという利点があります。

00:16:33.000 -> 00:16:40.000
通常のアクターコールとの唯一の違いは、ネットワークエラーのために分散アクターコールが失敗する可能性があることです。

00:16:40.000 -> 00:16:44.000
ネットワーク障害が発生した場合、アクターメソッドはエラーをスローします。

00:16:44.000 -> 00:16:52.000
したがって、tryキーワードと、アクターの外で関数を呼び出すときに必要な通常のawaitキーワードを追加する必要があります。

00:16:52.000 -> 00:17:02.000
これらのコア言語プリミティブに基づいて、Swiftでサーバー側のクラスター化された分散システムを構築することに焦点を当てたオープンソースの分散アクターパッケージも構築しました。

00:17:02.000 -> 00:17:11.000
このパッケージには、SwiftNIOを使用した統合ネットワーク層が含まれており、クラスター全体の状態を管理するためのSWIMコンセンサスプロトコルを実装しています。

00:17:11.000 -> 00:17:19.000
「Swiftで分散アクターに会う」セッションでは、これらの新機能を使用して分散システムを構築する方法について詳しく説明します。

00:17:19.000 -> 00:17:32.000
また、Swift 5.5でリリースされたAsyncSequenceを扱う際の一般的な操作にすぐに使える簡単なソリューションを提供するために、オープンソースアルゴリズムの新しいセットを立ち上げました。

00:17:32.000 -> 00:17:40.000
これらのAPIをパッケージとしてリリースすることで、開発者はプラットフォームやオペレーティングシステムのバージョン間で柔軟に展開できます。

00:17:40.000 -> 00:17:47.000
複数の非同期シーケンスを結合し、値をコレクションにグループ化する方法はいくつかあります。

00:17:47.000 -> 00:17:51.000
これらはパッケージに含まれているアルゴリズムのほんの一部です。

00:17:51.000 -> 00:17:58.000
「Meet Swift Async Algorithms」トークをチェックして、この新しい強力なAPIをどのように使用できるかを確認してください。

00:17:58.000 -> 00:18:02.000
しかし、並行性のもう1つの側面があり、それはパフォーマンスです。

00:18:02.000 -> 00:18:08.000
今年は、俳優の優先順位付けにより、俳優は最も優先度の高い仕事を最初に実行します。

00:18:08.000 -> 00:18:20.000
そして、オペレーティングシステムスケジューラとの深い統合を継続し、このモデルには優先反転防止が組み込まれているため、重要度の低い作業は優先度の高い作業をブロックすることはできません。

00:18:20.000 -> 00:18:26.000
歴史的に、アプリの並行性のパフォーマンスへの影響を視覚化することは本当に困難でした。

00:18:26.000 -> 00:18:31.000
しかし今、私たちはまさにそれを行うための素晴らしい新しいツールを持っています。

00:18:31.000 -> 00:18:36.000
Instrumentsの新しいSwift並行性ビューは、パフォーマンスの問題を調査するのに役立ちます。

00:18:36.000 -> 00:18:46.000
Swift TasksとSwift Actorsのインストゥルメントは、並行性コードを視覚化して最適化するのに役立つツールの完全なスイートを提供します。

00:18:46.000 -> 00:18:58.000
トップレベルでは、Swift Tasks Instrumentは、同時に実行されているタスクの数や、その時点で作成されたタスクの合計など、有用な統計情報を提供します。

00:18:58.000 -> 00:19:03.000
このウィンドウの下半分には、タスクフォレストと呼ばれるものを見ることができます。

00:19:03.000 -> 00:19:11.000
これは、構造化された並行コード内のタスク間の親子関係のグラフィカルな表現を提供します。

00:19:11.000 -> 00:19:16.000
これは、Swift Actor Instrumentの詳細なビューの1つにすぎません。

00:19:16.000 -> 00:19:24.000
このエキサイティングな新しいツールの使い方を学ぶには、「Swiftの並行性を視覚化して最適化する」というトークに飛び乗りたいと思うでしょう。

00:19:24.000 -> 00:19:26.000
そして、それらの新しいパッケージを試してみることを忘れないでください。

00:19:26.000 -> 00:19:29.000
フォーラムで何が起こっているのかを私たちに知らせることを恥ずかしがらないでください。

00:19:29.000 -> 00:19:36.000
さて、私はそれをベッカに引き渡して、Swift言語の使いやすさの多くの改善について話します。

00:19:36.000 -> 00:19:42.000
言語はツールであり、ツールには面白いことがあります - 彼らはあなたがそれらを使って構築するものに本当に影響を与える可能性があります。

00:19:42.000 -> 00:19:48.000
あなたが持っているのがハンマーだけなら、ネジの代わりに釘で物を作るつもりです。

00:19:48.000 -> 00:19:58.000
そして、あなたがツールのフルセットを持っている場合でも、あなたのドライバーがプラスチックで持ちにくい間、あなたのハンマーが大きくてグリッピーなハンドルを持っている場合、あなたはまだ釘に傾くかもしれません。

00:19:58.000 -> 00:19:59.000
言語も同じです。

00:19:59.000 -> 00:20:05.000
スウィフトが何かを表現するための良いツールを持っているなら、人々はそれをより頻繁に使うだろう。

00:20:05.000 -> 00:20:11.000
そして今年、コードに何をしてほしいかを表現するためのSwiftのツールは、多くの点で改善されました。

00:20:11.000 -> 00:20:15.000
これらの変更のいくつかは、あなたが頻繁に行うことのための単純な利便性です。

00:20:15.000 -> 00:20:22.000
たとえば、Swiftでは、等号の両側に同じ名前でif letを使用することが本当に一般的です。

00:20:22.000 -> 00:20:28.000
結局のところ、おそらくあなたがオプションの名前を与えた名前よりも、ラップされていない値のためのより良い名前はありません。

00:20:28.000 -> 00:20:33.000
しかし、名前が本当に長いとき、その繰り返しは面倒になり始めます。

00:20:33.000 -> 00:20:39.000
名前を省略したくなるかもしれませんが、コードが不可解になります。

00:20:39.000 -> 00:20:45.000
また、後でオプションの変数の名前を変更すると、略語が同期しなくなる可能性があります。

00:20:45.000 -> 00:20:49.000
Swift 5.7は、この一般的なパターンの新しい省略形を導入します。

00:20:49.000 -> 00:20:55.000
オプションをアンラップしていて、アンラップされた値を同じ名前にしたい場合は、右側をドロップするだけです。

00:20:55.000 -> 00:20:58.000
スウィフトはそれが同じだと仮定するだろう。

00:20:58.000 -> 00:21:04.000
そしてもちろん、これはガードでも機能し、その間でも機能します。

00:21:04.000 -> 00:21:09.000
また、軽微な変更を加えると、機能が突然機能しなくなる場所も調べました。

00:21:09.000 -> 00:21:16.000
たとえば、Swiftは、1つのステートメントクロージャ内に書かれたコードに基づいて、コールが返すタイプを常に把握することができました。

00:21:16.000 -> 00:21:30.000
このcompactMap呼び出しでは、クロージャはparseLineの値を返し、parseLine関数はMailmapEntryを返すので、SwiftはエントリがMailmapEntryの配列である必要があることを理解できます。

00:21:30.000 -> 00:21:35.000
これは、複数のステートメントまたは制御フロー機能を持つ、より複雑なクロージャに対して機能するようになりました。

00:21:35.000 -> 00:21:43.000
そのため、クロージャの結果タイプを手動で指定することなく、do-catch、if...else、または単に印刷コールを追加できます。

00:21:43.000 -> 00:21:49.000
私たちが見たもう一つのことは、実際の危険にフラグを立てていない危険フラグです。

00:21:49.000 -> 00:21:52.000
スウィフトは、タイプとメモリの安全性に非常に関心を持っています。

00:21:52.000 -> 00:22:01.000
間違いを防ぐために、異なるポインタタイプのポインタ間、または生のポインタと型付きポインタの間で自動的に変換されることはありません。

00:22:01.000 -> 00:22:05.000
これは、特定の変換を可能にするCとは大きく異なります。

00:22:05.000 -> 00:22:15.000
たとえば、ポインタの符号性を変更したり、Cのポインタルールに違反することなく、ポインタを文字星にキャストしてバイトとしてアクセスしたりできます。

00:22:15.000 -> 00:22:22.000
しかし、ポインタの動作のこれらの違いは、C APIがSwiftにインポートされたときに問題を引き起こすことがあります。

00:22:22.000 -> 00:22:30.000
元の開発者は、Cの自動変換によって処理されるが、Swiftのエラーであるわずかな不一致でAPIを設計した可能性があります。

00:22:30.000 -> 00:22:39.000
Swiftでは、別のタイプであるかのように1つのタイプのポインタにアクセスすることは非常に危険であるため、非常に明示的に何をしているかを説明する必要があります。

00:22:39.000 -> 00:22:47.000
しかし、ポインタをCに直接渡す場合、それはすべて無意味です。なぜなら、Cでは、そのポインタの不一致は完全に合法だからです!

00:22:47.000 -> 00:22:52.000
だから、この場合、私たちは何かを危険であるかのように本当に率直に扱いました。

00:22:52.000 -> 00:23:00.000
Swiftがタイプの安全性を評価するのと同じくらい、Cファミリーコードへの簡単なアクセスも重視しているため、これは重要です。

00:23:00.000 -> 00:23:11.000
それが、CとObjective-Cの相互運用が非常に豊かでシームレスである理由であり、Swiftプロジェクトがアンジェラが先に述べたC ++ワーキンググループを形成し、同等に有能なC ++相互運用の構築を開始する理由です。

00:23:11.000 -> 00:23:16.000
このようなC関数の使用が不必要に苦痛になることを望んでいません。

00:23:16.000 -> 00:23:21.000
そのため、Swiftには、インポートされた関数とメソッドを呼び出すための別のルールセットがあります。

00:23:21.000 -> 00:23:26.000
通常はSwiftになくても、Cで合法になるポインタ変換を可能にします。

00:23:26.000 -> 00:23:31.000
そうすれば、SwiftコードはこれらのAPIをシームレスに使用できます。

00:23:31.000 -> 00:23:35.000
これまでのところ、あなたがすでに持っていたツールの小さな改善について話しました。

00:23:35.000 -> 00:23:41.000
しかし、今年、Swiftには文字列から情報を抽出するためのまったく新しいツールもあります。

00:23:41.000 -> 00:23:45.000
これは、文字列からいくつかの情報を解析する関数です。

00:23:45.000 -> 00:23:48.000
この種のタスクは、Swiftでは常にちょっとした課題でした。

00:23:48.000 -> 00:23:54.000
欲しいものを手に入れるまで、検索し、分割し、スライスし、何度も何度もスライスすることになります。

00:23:54.000 -> 00:24:03.000
人々がこれに気づくと、文字列インデックスを操作することがどれほど冗長であるかなど、ささいなことに焦点を当てる傾向がありますが、それは全体像を見逃していると思います。

00:24:03.000 -> 00:24:15.000
この構文を変更しても、このコードを見たときに尋ねている基本的な質問に答えるのに役立たないからです - 渡された行変数は実際にどのように見えますか?

00:24:15.000 -> 00:24:18.000
どんな弦を分解しようとしているのですか?

00:24:18.000 -> 00:24:29.000
十分に長く見つめていると、メールマップの簡略化されたバージョンを解析していることに気付くかもしれません。これは、古いコミットで開発者の名前を修正するためにgitリポジトリに入れたファイルです。

00:24:29.000 -> 00:24:35.000
しかし、検索とスライスによってその情報を抽出することは非常に複雑であるため、それを理解することは困難です。

00:24:35.000 -> 00:24:42.000
弦をスライスする方法に迷うので、その弦が何であるかを見失います。

00:24:42.000 -> 00:24:48.000
問題はこれら2つの表現ではなく、問題は全体です。

00:24:48.000 -> 00:24:52.000
私たちはこれをすべて引き裂いて、より良いものに置き換える必要があります。

00:24:52.000 -> 00:25:01.000
別のアプローチが必要です。コードが一致させたい文字列の絵を描き、言語がその方法を理解するアプローチです。

00:25:01.000 -> 00:25:05.000
宣言的なアプローチであり、必須のアプローチではありません。

00:25:05.000 -> 00:25:10.000
Swift 5.7では、正規表現を書くことでそれができるようになりました。

00:25:10.000 -> 00:25:14.000
正規表現は、文字列内のパターンを記述する方法です。

00:25:14.000 -> 00:25:21.000
50年以上にわたり、言語とツールにより、開発者は緻密で情報満載の構文で正規表現を書くことができました。

00:25:21.000 -> 00:25:31.000
すでにXcode検索バー、grepなどのコマンドラインツール、FoundationのNSRegularExpressionクラス、または他のプログラミング言語で使用している人もいます。

00:25:31.000 -> 00:25:37.000
その構文は現在、Swiftの正規表現リテラルでサポートされており、他の開発者ツールと同じように機能します。

00:25:37.000 -> 00:25:46.000
しかし、あなた方の何人かは以前に正規表現を使ったことがなく、おそらく「それは本当のコードですか、それとも猫がキーボードを横切って歩いたのですか?」と言うでしょう。

00:25:46.000 -> 00:25:47.000
そして、私はあなたを責めません。

00:25:47.000 -> 00:25:53.000
正規表現リテラルは、それらを読むために暗記しなければならない記号とニーモニックで書かれています。

00:25:53.000 -> 00:26:02.000
言語を知っている人にとっては、開発者の名前に一致する部分のように、この正規表現の最も厄介な部分でさえ、いくつかの単純なマッチングルールの組み合わせにすぎません。

00:26:02.000 -> 00:26:06.000
しかし、それは11文字に詰め込むための多くの行動です。

00:26:06.000 -> 00:26:13.000
正規表現リテラルは非常にコンパクトであるため、経験豊富な開発者でさえ、複雑なものを理解するのに1分かかることがあります。

00:26:13.000 -> 00:26:18.000
しかし、記号の代わりに単語だけで、同じ種類のマッチングルールを書くことができたらどうでしょうか?

00:26:18.000 -> 00:26:21.000
それは理解しやすいようです。それは理解しやすいようです

00:26:21.000 -> 00:26:26.000
実際、すべてをまとめると、SwiftUIによく似たものが手に入る。

00:26:26.000 -> 00:26:30.000
それは正規表現リテラルに代わる素晴らしい選択肢ですよね?

00:26:30.000 -> 00:26:33.000
だから、スウィフトがそれをサポートするのは良いことです!

00:26:33.000 -> 00:26:42.000
RegexBuilderライブラリは、従来の構文よりも使いやすく、読みやすい正規表現用のまったく新しいSwiftUIスタイルの言語を提供します。

00:26:42.000 -> 00:26:52.000
正規表現リテラルと同じことをすることができますが、暗記しなければならない記号や略語の代わりに、理解したり調べたりできる言葉でその動作を説明しています。

00:26:52.000 -> 00:26:57.000
正規表現ビルダーは初心者に最適ですが、これは初心者のみの機能とは程遠いです。

00:26:57.000 -> 00:27:01.000
それは、正規表現リテラルができることをはるかに超えた強力な機能を持っています。

00:27:01.000 -> 00:27:10.000
まず、SwiftUIビュー階層をビューに変えるのと同じように、正規表現を再利用可能な正規表現コンポーネントに変えることができます。

00:27:10.000 -> 00:27:17.000
ビルダー構文で作成された他の正規表現からこれらのコンポーネントを使用することができ、それらを再帰的にすることもできます。

00:27:17.000 -> 00:27:22.000
正規表現ビルダーは、いくつかのSwiftタイプを正規表現に直接ドロップすることもサポートしています。

00:27:22.000 -> 00:27:28.000
たとえば、文字列リテラルは、その中の正確なテキストと一致するだけで、特別なエスケープは必要ありません。

00:27:28.000 -> 00:27:32.000
正規表現ビルダーの途中で正規表現リテラルを使用することもできます。

00:27:32.000 -> 00:27:38.000
そのため、正規表現ビルダーの明快さと正規表現リテラルの簡潔さのバランスを取ることができます。

00:27:38.000 -> 00:27:48.000
また、このFoundationの日付フォーマットスタイルのような他のタイプは、カスタム解析ロジックを正規表現ビルダーと統合し、データをキャプチャする前にデータをよりリッチなタイプに変換することもできます。

00:27:48.000 -> 00:27:58.000
最後に、どの構文を使用しても、正規表現は、使いやすい便利なマッチングメソッドと強く型付けされたキャプチャの束をサポートしています。

00:27:58.000 -> 00:28:09.000
現在、席で身をかがめている正規表現オタクのために、Swift Regexは、最先端の正規表現の実装に匹敵する機能セットを備えた、まったく新しいオープンソースマッチングエンジンを使用しています。

00:28:09.000 -> 00:28:16.000
リテラル構文はUnicode正規表現標準と互換性があり、珍しいレベルのUnicodeの正確性を持っています。

00:28:16.000 -> 00:28:22.000
たとえば、ドットはデフォルトでUnicode.ScalarやUTF-8バイトではなく、文字全体に一致します。

00:28:22.000 -> 00:28:32.000
Swift Regexを使用するには、macOS 13やiOS 16など、Swift Regexエンジンが組み込まれたOSでアプリを実行する必要があります。

00:28:32.000 -> 00:28:38.000
Swift Regexは言語全体です-まあ、2つの言語、本当に-なので、それについて言うべきことはもっとたくさんあります。

00:28:38.000 -> 00:28:46.000
「Meet Swift Regex」と「Swift Regex: Beyond The Basics」の2つのセッションでは、その使用についてさらに詳しく説明します。

00:28:46.000 -> 00:28:53.000
最後に、私たちが持っているツールを包括的に検討し、それらを改善するために多くの変更を加えた場所が1つあります。

00:28:53.000 -> 00:28:56.000
それはジェネリックとプロトコルです。

00:28:56.000 -> 00:29:00.000
これらのツールがどのように改善されたかを示すために、プロトコルの例が必要です。

00:29:00.000 -> 00:29:05.000
Gitクライアントを書いていて、メールマップを2つの異なる方法で表現しなければならないとしましょう。

00:29:05.000 -> 00:29:11.000
コミットを表示するときは、辞書付きのタイプを使用して名前をすばやく検索します。

00:29:11.000 -> 00:29:18.000
しかし、ユーザーにメールマップを編集させるときは、配列を持つタイプを使用して、エントリを元の順序で保持します。

00:29:18.000 -> 00:29:26.000
また、両方とも準拠するMailmapというプロトコルがあるので、mailmapパーサーはどちらのタイプにもエントリを追加できます。

00:29:26.000 -> 00:29:30.000
しかし、パーサーがMailmapプロトコルを使用できる方法は2つあります。

00:29:30.000 -> 00:29:41.000
私はそれらを説明するためにこのaddEntries関数の2つの異なるバージョンを書きましたが、Swiftは2つの異なるものに同じ構文を使用しているため、実際にどのように異なるかを説明するのは難しいです。

00:29:41.000 -> 00:29:50.000
「メールマップ」という言葉はここでは1つのことを意味するが、ここでは微妙に異なることを意味することがわかった。

00:29:50.000 -> 00:30:01.000
継承リスト、汎用パラメータリスト、汎用適合性制約、または不透明な結果型でプロトコルに名前を付けると、「このプロトコルに準拠したインスタンス」を意味します。

00:30:01.000 -> 00:30:14.000
しかし、変数型、ジェネリック引数、ジェネリック同型制約、または関数パラメータまたは結果型では、実際には「このプロトコルに準拠したインスタンスを含むボックス」を意味します。

00:30:14.000 -> 00:30:24.000
この区別は、ボックスは通常、より多くのスペースを使用し、操作に時間がかかり、内部のインスタンスのすべての機能を備えていないため、重要です。

00:30:24.000 -> 00:30:31.000
しかし、あなたが箱を使用している場所は、あなたがいない場所のように見えるので、あなたが箱を使用しているかどうかを理解するのは難しいです。

00:30:31.000 -> 00:30:34.000
Swift 5.7はこの見落としを修正します。

00:30:34.000 -> 00:30:41.000
適合型を含むこれらのボックスの1つを使用している場合、Swiftは任意のキーワードを書くことを期待します。

00:30:41.000 -> 00:30:53.000
これは、Swift 5.7より前に有効だったコードでは必須ではありませんが、明示的に書き出さなくても、生成されたインターフェイスやエラーメッセージに表示されることが推奨されています。

00:30:53.000 -> 00:30:58.000
したがって、右側の列にこれらすべてを書く好ましい方法は、任意のキーワードです。

00:30:58.000 -> 00:31:03.000
そうすると、これらのボックスの1つを使用しているときにわかります。

00:31:03.000 -> 00:31:10.000
この例では、任意のキーワードがパラメータの1つをマークしたので、これら2つの関数の違いを説明するのがはるかに簡単になりました。

00:31:10.000 -> 00:31:17.000
addEntries1はMailmapを汎用型として受け取り、addEntries2は任意の型として受け取ります。

00:31:17.000 -> 00:31:23.000
また、エラーメッセージは、任意のタイプの制限の1つにヒットしたときに何が起こっているかを説明するのも簡単です。

00:31:23.000 -> 00:31:30.000
たとえば、このmergeMailmaps関数は、任意のMailmapを一般的なMailmapパラメータに渡そうとします。

00:31:30.000 -> 00:31:37.000
これは、Mailmapがそれ自体に準拠できないというエラーを生成するために使用されていましたが、これは常に逆説的に思えました。

00:31:37.000 -> 00:31:42.000
しかし、今、私たちはあらゆるタイプの概念を持っているので、何が起こっているのかをより明確に説明することができます。

00:31:42.000 -> 00:31:49.000
問題は、メールマップ（メールマップを含むボックス）がメールマッププロトコルに準拠していないことです。

00:31:49.000 -> 00:31:55.000
しかし、ボックスはあなたが渡そうとしているものであり、一般的なパラメータには収まりません。

00:31:55.000 -> 00:32:04.000
ここのボックス内のインスタンスを渡したい場合は、何とかボックスを開き、その中のメールマップを取り出し、代わりにそれを渡す必要があります。

00:32:04.000 -> 00:32:10.000
しかし、実際には、このような単純なケースでは、スウィフトは今あなたのためにそれを行います。

00:32:10.000 -> 00:32:16.000
ボックスを開き、その中のインスタンスを取り出し、一般的なパラメータに渡します。

00:32:16.000 -> 00:32:19.000
だから、あなたはもうこのエラーメッセージを見ることはないでしょう。

00:32:19.000 -> 00:32:23.000
しかし、それよりもどんなタイプにもさらにエキサイティングな改善があります。

00:32:23.000 -> 00:32:34.000
以前は、プロトコルがセルフタイプを使用した場合、または関連するタイプがある場合、またはEquatableのようなプロトコルに準拠している場合は、どのタイプとしても使用できませんでした。

00:32:34.000 -> 00:32:42.000
しかし、Swift 5.7では、このエラーはちょうど--poof--消えました。

00:32:42.000 -> 00:32:47.000
多くの開発者がこれに苦労しているので、ソースで修正したことに興奮しています。

00:32:47.000 -> 00:32:52.000
さて、それはMailmapのようなプロトコルのためだけに十分にエキサイティングですが、これはさらに進んでいます。

00:32:52.000 -> 00:32:58.000
コレクションのような非常に洗練されたプロトコルでさえ、あらゆるタイプとして使用できるからです。

00:32:58.000 -> 00:33:04.000
「プライマリ関連タイプ」と呼ばれる新機能のおかげで、要素タイプを指定することもできます。

00:33:04.000 -> 00:33:08.000
関連する多くのタイプは、基本的に実装の詳細にすぎません。

00:33:08.000 -> 00:33:16.000
通常、コレクションがインデックス、イテレータ、またはサブシーケンスにどのタイプを使用するかは気にしません。サポートするタイプを使用するだけです。

00:33:16.000 -> 00:33:20.000
しかし、その要素は別の話です。

00:33:20.000 -> 00:33:29.000
コレクションがどの要素タイプを使用するかを必ずしも気にしていないかもしれませんが、おそらく要素で何かをするつもりなので、それらを制限するか、それらを返すか、何かを返す必要があります。

00:33:29.000 -> 00:33:41.000
プロトコルのほぼすべてのユーザーが気にするElementのような関連タイプがある場合、プロトコルの名前の後にその名前を角括弧に入れて、主要な関連タイプにすることができます。

00:33:41.000 -> 00:33:52.000
これを行うと、プロトコルの主要な関連タイプを、コレクションを含め、プロトコルの名前を書くことができる場所ならどこでも、アングルブラケット構文で制限できます。

00:33:52.000 -> 00:33:57.000
さて、このタイプを見て、「ちょっと待ってください。」と行く人もいるかもしれません。

00:33:57.000 -> 00:34:03.000
AnyCollectionと呼ばれるものがすでに存在しませんか、ただ一緒に実行し、「任意の」を大文字にして実行するだけですか?

00:34:03.000 -> 00:34:06.000
そして、あなたは正しいです、あります!

00:34:06.000 -> 00:34:13.000
古いAnyCollectionは、タイプ消去ラッパーであり、任意のタイプと同じ目的を果たす手書きの構造体です。

00:34:13.000 -> 00:34:27.000
違いは、AnyCollection構造体は、あなたが今まで見た中で最も退屈な定型コードの行に次ぐものであるということです。一方、任意のタイプは基本的に同じことをする組み込みの言語機能です - 無料で!

00:34:27.000 -> 00:34:34.000
今、AnyCollection構造体は下位互換性のために固執し、どのタイプもまだ完全に一致できないいくつかの機能を持っているため、固執します。

00:34:34.000 -> 00:34:44.000
しかし、コードに独自のタイプ消去ラッパーがある場合は、ボックスクラスやクロージャの代わりに組み込みの任意のタイプを使用してそれらを再実装できるかどうかを確認したいと思うかもしれません。

00:34:44.000 -> 00:34:47.000
あるいは、それらをタイプエイリアスに置き換えることもできます。

00:34:47.000 -> 00:34:51.000
そのため、Swiftはあらゆるタイプを劇的に改善しました。

00:34:51.000 -> 00:34:55.000
任意のキーワードが導入されているので、使用している場所を確認できます。

00:34:55.000 -> 00:34:58.000
これにより、それらを一般的な引数に渡すことができます。

00:34:58.000 -> 00:35:03.000
多くのプロトコルがそれらと一緒に使用されないようにする制限を廃止しました。

00:35:03.000 -> 00:35:08.000
また、任意のタイプのプライマリ関連タイプを制限することもできます。

00:35:08.000 -> 00:35:13.000
しかし、これらすべての改善があっても、どのタイプにもまだ制限があります。

00:35:13.000 -> 00:35:30.000
たとえば、MailmapがEquatableに準拠している場合、任意のMailmapsを使用できるようになりましたが、equals演算子は両方のmailmapが同じ具体的なタイプを持つ必要があるため、equals演算子を使用することはできませんが、2つのMailmapを使用している場合は保証されません。

00:35:30.000 -> 00:35:37.000
したがって、Swiftはあらゆるタイプを大幅に改善しましたが、機能とパフォーマンスの両方にはまだ重要な制限があります。

00:35:37.000 -> 00:35:43.000
だからこそ、多くの場合、それらを使用すべきではなく、代わりにジェネリック医薬品を使用する必要があります。

00:35:43.000 -> 00:35:48.000
それでは、addEntriesの2つのバージョンに戻り、その知恵を適用しましょう。

00:35:48.000 -> 00:35:56.000
どちらのバージョンもまったく同じことをしますが、上部のものはジェネリックタイプを使用し、下部のものは任意のタイプを使用します。

00:35:56.000 -> 00:36:02.000
ジェネリックバージョンは、より効率的で有能である可能性が高いので、それを使用する必要があります。

00:36:02.000 -> 00:36:08.000
それでも、読み書きがとても簡単なので、おそらくどんなタイプでも使いたくなるでしょう。

00:36:08.000 -> 00:36:18.000
ジェネリックバージョンを書くには、2つのジェネリックタイプ名を宣言し、両方を制約し、最後に、それらのジェネリックタイプ名をパラメータのタイプとして使用する必要があります。

00:36:18.000 -> 00:36:23.000
「任意のコレクション」と「任意のメールマップ」を書くのに比べて、それはただ疲れます。

00:36:23.000 -> 00:36:27.000
だから、欠点にもかかわらず、どんなタイプでも使いたくなるでしょう。

00:36:27.000 -> 00:36:34.000
しかし、それは私が前に話していたのと同じことです - ハンマーは大きくてグリップ力のあるハンドルを持っているので、ドライバーの代わりにハンマーを使用してください。

00:36:34.000 -> 00:36:37.000
あなたはその選択をする必要はありません。

00:36:37.000 -> 00:36:42.000
そのため、Swiftはジェネリック医薬品をあらゆるタイプと同じくらい使いやすいものにしています。

00:36:42.000 -> 00:36:48.000
汎用パラメータが1か所でのみ使用されている場合は、略語としてsomeキーワードで書くことができます。

00:36:48.000 -> 00:36:55.000
また、主要な関連タイプもサポートしているので、はるかに理解しやすいコードでメールマップエントリのすべてのコレクションを受け入れることができます。

00:36:55.000 -> 00:37:00.000
それはあなたのツールボックスで、もうジェネリック医薬品を避ける理由はありません。

00:37:00.000 -> 00:37:07.000
ジェネリックと任意のタイプのどちらかを選択できる場合、ジェネリックは同じように使いやすいです。「any」ではなく「some」と書くだけです。

00:37:07.000 -> 00:37:11.000
だから、仕事に最適なツールを使った方がいいかもしれません。

00:37:11.000 -> 00:37:15.000
私はプロトコルとジェネリックへのこれらの変更の表面を引っ掻いただけです。

00:37:15.000 -> 00:37:28.000
詳細な外観と、Swiftのすべてのジェネリック機能の素晴らしいレビューについては、今年はさらに2つの講演があります。「Embrace Swiftジェネリック」と「Swiftでプロトコルインターフェイスを設計する」です。

00:37:28.000 -> 00:37:35.000
さて、アンジェラと私はスウィフトの2ダース近くの変更について話しましたが、このセッションに収まらないことがたくさんあります。

00:37:35.000 -> 00:37:43.000
これらの変更はすべて、スウィフトフォーラムのEvolutionボードで売り込まれ、提案され、レビューされ、公に受け入れられました。

00:37:43.000 -> 00:37:48.000
そして、それらはすべて、Apple外部のコミュニティメンバーの助けを借りて形作られ、実現されました。

00:37:48.000 -> 00:37:55.000
あなたがその一人なら、Swift 5.7を素晴らしいリリースにしてくれてありがとう。

00:37:55.000 -> 00:38:02.000
そして、次に何が起こるかを決めるのを手伝いたい場合は、Swift.org/contributingにアクセスして参加方法を確認してください。

00:38:02.000 -> 00:38:03.000
お時間をいただきありがとうございます。

00:38:03.000 -> 00:38:06.000
そして幸せなコーディング。

00:38:06.000 -> 23:59:59.000
♪

