WEBVTT

00:00:00.000 --> 00:00:03.000
♪インストゥルメンタルヒップホップ音楽♪

00:00:03.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:13.000
「宣言型デバイス管理を採用する」セッションへようこそ。

00:00:13.000 --> 00:00:18.000
私の名前はサイラス・ダブーで、デバイス管理チームのエンジニアです。

00:00:18.000 --> 00:00:24.000
宣言型デバイス管理のエキサイティングな新機能についてお話しします。

00:00:24.000 --> 00:00:37.000
WWDC21で、同僚のメリッサは、Appleデバイスを管理するための新しいパラダイムである宣言型デバイス管理を導入し、MDMプロトコル自体を再構想しました。

00:00:37.000 --> 00:00:45.000
そのセッションで学んだように、宣言的なデバイス管理は、デバイスが自律的でプロアクティブなものになることを可能にするため、強力です。

00:00:45.000 --> 00:00:54.000
デバイスは、独自の状態の変化に反応し、サーバーからプロンプトを表示することなく、管理ロジックを自分自身に適用するため、自律的です。

00:00:54.000 --> 00:01:06.000
デバイスはプロアクティブであり、重要な状態の変化が発生したときにステータスチャネルがサーバーに非同期に報告し、サーバーがデバイスをポーリングする必要性を回避します。

00:01:06.000 --> 00:01:13.000
宣言型デバイス管理データモデルには、宣言とステータスの2つの重要な要素があります。

00:01:13.000 --> 00:01:20.000
宣言には、アクティベーションと述語、構成、資産、および管理タイプが含まれます。

00:01:20.000 --> 00:01:24.000
また、ステータスはステータス項目とステータスレポートをカバーしています。

00:01:24.000 --> 00:01:32.000
なぜこれが重要なのか、それがあなたにとって何を意味するのか、そしてあなたの製品を使用する組織について話しましょう。

00:01:32.000 --> 00:01:50.000
私たちは、新しい複雑な管理戦略をサポートし、管理対象デバイスの全体的なユーザーエクスペリエンスを向上させ、IT管理者の反復的で面倒なタスクを軽減し、デバイスが独自の管理状態でドライバーになることを可能にするために、この技術を作成しました。

00:01:50.000 --> 00:01:58.000
デバイス管理ソリューションの開発者として、宣言的なアプローチにより、サーバーは軽量で反応的になります。

00:01:58.000 --> 00:02:08.000
また、宣言型データモデルが組織の構造をより密接にマッピングすると、デバイスの変更がより直感的になります。

00:02:08.000 --> 00:02:24.000
ステータスレポートは、豊富なフィードバックチャネルを提供します。これにより、サーバーは、ポーリングの実装に使用される複雑な戦略を必要とせずに、デバイスをより綿密に監視し、よりタイムリーで信頼性の高い方法で関連情報を提示できます。

00:02:24.000 --> 00:02:37.000
これはすべて、より簡単な開発努力を意味し、最も重要な場所に価値を付加するデバイス管理機能に集中し、顧客が気に入るソリューションを作成することができます。

00:02:37.000 --> 00:02:44.000
IT管理者にとって、宣言的なアプローチは、デバイスが期待される状態にあるという自信を高めます。

00:02:44.000 --> 00:02:55.000
また、そうでない状況では、サーバーへの接続が失われた場合でも、機密性の高い組織データを保護する安全な状態にあります。

00:02:55.000 --> 00:03:07.000
ステータスレポートを介してデバイスからの重要なフィードバックを提供し、ネットワーク帯域幅などのリソースの利用率を減らすことで、管理者の効率も向上します。

00:03:07.000 --> 00:03:20.000
組織のユーザーにとって、デバイス管理は、より迅速なオンボーディング、より迅速な回復時間、組織からのより良いサポートにより、より応答性と信頼性の高いエクスペリエンスになります。

00:03:20.000 --> 00:03:36.000
これらすべての利点を念頭に置いて、将来のプロトコル機能の焦点は宣言型デバイス管理であり、今日の製品に宣言型デバイス管理を採用することがさらに重要になります。

00:03:36.000 --> 00:03:46.000
宣言型デバイス管理の詳細な紹介とそれを採用するために必要な手順については、WWDC21セッションビデオを必ずご覧ください。

00:03:46.000 --> 00:03:57.000
このリリースでは、宣言型デバイス管理の範囲の拡大、ステータスレポートの強化、述語の強化の3つの重点分野があります。

00:03:57.000 --> 00:04:02.000
宣言型デバイス管理の範囲を拡大することから始めましょう。

00:04:02.000 --> 00:04:08.000
宣言型デバイス管理が導入されたとき、ユーザー登録のiOSでのみサポートされていました。

00:04:08.000 --> 00:04:25.000
現在、宣言型デバイス管理は、MDMがサポートするすべての登録タイプで利用可能です。監視対象デバイスを含む自動デバイス登録、プロファイルベースの登録、プロファイルとアカウントベースのユーザー登録。

00:04:25.000 --> 00:04:30.000
宣言型デバイス管理は、共有iPadでも利用可能になりました。

00:04:30.000 --> 00:04:38.000
iOS 16では、ユーザーは設定アプリのMDMプロファイル詳細ビューで設定を見つけることができるようになりました。

00:04:38.000 --> 00:04:44.000
設定行をタップすると、アクティブな設定の詳細が表示されます。

00:04:44.000 --> 00:04:53.000
また、宣言型デバイス管理は、MDMがサポートするすべてのプラットフォームで利用可能であることを発表できることを嬉しく思います。

00:04:53.000 --> 00:05:01.000
macOS Venturaは、macOSでサポートされているすべてのMDM登録タイプについて、宣言型デバイス管理をサポートするようになりました。

00:05:01.000 --> 00:05:08.000
tvOS 16は、MDMデバイス登録タイプの宣言型デバイス管理をサポートするようになりました。

00:05:08.000 --> 00:05:18.000
OSでサポートされている場合、iOSで利用可能な同じ宣言とステータスのセットは、macOSとtvOSでも利用可能です。

00:05:18.000 --> 00:05:26.000
macOSでは、MDMプロファイルの詳細ビューに構成セクションがあり、アクティブな構成が表示されます。

00:05:26.000 --> 00:05:34.000
MDMプロファイルの詳細ビューに構成セクションがあるtvOSにも同じことが言えます。

00:05:34.000 --> 00:05:41.000
ここで最後に注意すべきことは、macOSと共有iPadデバイスの両方にはそれぞれ2つのMDMチャンネルがあります。

00:05:41.000 --> 00:05:44.000
これらはデバイスとユーザーチャネルです。

00:05:44.000 --> 00:05:52.000
デバイスチャネルはデバイスレベルの状態の管理を可能にしますが、ユーザーチャネルは特定のユーザーの管理状態をターゲットにしています。

00:05:52.000 --> 00:05:58.000
任意のチャネルで宣言型デバイス管理を使用するには、そのチャネルに対して個別に有効にする必要があります。

00:05:58.000 --> 00:06:03.000
これは、対応するチャネルでDeclarativeManagementコマンドを送信することを意味します。

00:06:03.000 --> 00:06:14.000
また、宣言型デバイス管理ステータスレポートはチャネルごとに個別に生成されるため、個別に監視する必要があります。

00:06:14.000 --> 00:06:19.000
次に、2番目の重点分野であるステータスレポートです。

00:06:19.000 --> 00:06:23.000
ステータスレポートを簡単に確認しましょう。

00:06:23.000 --> 00:06:29.000
デバイスは、サブスクライブされたステータスアイテムのステータスをサーバーに段階的に報告できます。

00:06:29.000 --> 00:06:39.000
デバイスは、サーバーからの正常な応答を追跡し、ステータスの更新が信頼性が高く、ネットワークやその他の種類の問題の場合に見逃さないようにします。

00:06:39.000 --> 00:06:42.000
ステータスレポートは、デバイスをプロアクティブにします。

00:06:42.000 --> 00:06:47.000
サーバーが状態の変化を監視するためにデバイスを継続的にポーリングする必要はありません。

00:06:47.000 --> 00:06:56.000
iOS 15では、モデルタイプやオペレーティングシステムのバージョンなど、デバイスプロパティの一連のステータス項目を導入しました。

00:06:56.000 --> 00:07:08.000
このリリースでは、パスコードの状態、構成によってインストールされたアカウント、およびMDMインストールされたアプリの3つの領域でステータスを拡大しています。

00:07:08.000 --> 00:07:12.000
パスコードのステータスから始めましょう。

00:07:12.000 --> 00:07:16.000
iOS 15では、パスコードポリシーの設定を導入しました。

00:07:16.000 --> 00:07:28.000
MDMパスコードポリシープロファイルと同様に、適用されるポリシーと、ユーザーが変更したときにパスコードが準拠することとの間にいくつかのラグがある可能性があります。

00:07:28.000 --> 00:07:34.000
したがって、MDMサーバーは、パスコードがいつ準拠するかを判断するためにデバイスをポーリングする必要があります。

00:07:34.000 --> 00:07:40.000
しかし、新しい宣言型デバイス管理パスコードステータス項目では、それを行う必要はありません。

00:07:40.000 --> 00:07:48.000
Passcode.is-compliantとpasscode.is-presentの2つのステータス項目を追加しました。

00:07:48.000 --> 00:07:57.000
コンプライアンスは、パスコードがMDMプロファイルまたは構成を介して適用されるすべてのパスコードポリシーに準拠しているかどうかを示します。

00:07:57.000 --> 00:08:05.000
これらのステータス項目には、MDMクエリを介して取得できる同等のプロパティを反映するブール値があります。

00:08:05.000 --> 00:08:08.000
典型的なサーバーの動作を探りましょう。

00:08:08.000 --> 00:08:14.000
多くの場合、組織はデバイスに適用するセキュリティに敏感な状態を持っています。

00:08:14.000 --> 00:08:21.000
たとえば、保護されたネットワークへのアクセスを許可するVPNまたはWi-Fiプロファイル。

00:08:21.000 --> 00:08:31.000
その状態は、強力なパスコードポリシーが存在し、パスコードがそのポリシーに準拠している場合にのみ、デバイスでアクティブである必要があります。

00:08:31.000 --> 00:08:41.000
従来のMDMでは、サーバーはパスコードポリシープロファイルを送信してからデバイスをポーリングし、ユーザーがパスコードを変更したときにパスコードが準拠するのを待つ必要があります。

00:08:41.000 --> 00:08:48.000
最初はパスコードが準拠していない可能性が高いため、Wi-Fiプロファイルを送信できません。

00:08:48.000 --> 00:08:52.000
最終的に、ユーザーはパスコードを変更してコンプライアンスに適合させます。

00:08:52.000 --> 00:09:04.000
サーバーの次のポーリングでは、変更された準拠状態を検出し、Wi-Fiプロファイルを送信しても大丈夫だと判断し、Wi-Fiプロファイルはデバイスにインストールされます。

00:09:04.000 --> 00:09:13.000
宣言型デバイス管理は、パスコードコンプライアンス状態によってトリガーされるアクティベーション述語を使用して、サーバーがポーリングする必要がなくなります。

00:09:13.000 --> 00:09:25.000
サーバーは、パスコードポリシーとWi-Fiプロファイルの両方を構成として送信し、Wi-Fi構成はパスコードのコンプライアンスに基づいてアクティベーションに関連付けられています。

00:09:25.000 --> 00:09:31.000
パスコード設定はすぐに有効になり、強力なパスコードポリシーが適用されます。

00:09:31.000 --> 00:09:40.000
当初、パスコードは準拠していない可能性が高いため、アクティベーション述語はfalseと評価され、Wi-Fi設定はアクティブ化されません。

00:09:40.000 --> 00:09:44.000
ある時点で、ユーザーはパスコードを更新して準拠します。

00:09:44.000 --> 00:09:54.000
これにより、アクティベーションの再評価がトリガーされ、述語がtrueに評価され、Wi-Fi設定がアクティブになります。

00:09:54.000 --> 00:10:03.000
これはすべて、サーバーからの介入なしに起こり、実際にはサーバーへの接続がなくても発生する可能性があります。

00:10:03.000 --> 00:10:11.000
サーバーは、構成がアクティブになると自動的にデバイスからステータスレポートを取得するため、変更がいつ行われるかがわかっています。

00:10:11.000 --> 00:10:24.000
これは、ポーリングの必要性を回避し、より応答性が高く信頼性の高いデバイスの動作を得るために、ビジネスロジックをサーバーからデバイスにうまく移動した方法を示しています。

00:10:24.000 --> 00:10:27.000
では、アカウントのステータスに目を向けましょう。

00:10:27.000 --> 00:10:34.000
iOS 15では、デバイスにさまざまな種類のアカウントをインストールするためのアカウント構成を導入しました。

00:10:34.000 --> 00:10:41.000
これらは通常、組織アカウントであり、ユーザーは組織データにアクセスできます。

00:10:41.000 --> 00:10:51.000
管理者は、アカウントがいつ正常にインストールされ、どの状態にあるかを知ることで、問題が発生している可能性のあるユーザーをサポートするのに役立ちます。

00:10:51.000 --> 00:10:58.000
このリリースでは、メール、カレンダー、その他のアカウントタイプの8つのアカウントステータス項目が追加されます。

00:10:58.000 --> 00:11:08.000
ステータスは、構成によってインストールされたアカウントに対してのみ報告され、手動で作成されたアカウントやMDMプロファイルを介してインストールされたアカウントは含まれません。

00:11:08.000 --> 00:11:18.000
各新しいステータス項目はアカウント設定タイプに対応し、受信メールアカウントと送信メールアカウントのステータスは別々に報告されます。

00:11:18.000 --> 00:11:26.000
新しいステータス項目は、それぞれ異なるタイプのJSONオブジェクトを使用して、対応するアカウントタイプのステータスを表します。

00:11:26.000 --> 00:11:32.000
受信メールのステータス項目と、購読したカレンダーのステータス項目の例を次に示します。

00:11:32.000 --> 00:11:42.000
識別子キーの値は、ステータスアイテムオブジェクトの配列内のオブジェクトの一意の識別子です。

00:11:42.000 --> 00:11:55.000
宣言識別子キーの値は、アカウントをインストールした構成の識別子プロパティ値と一致し、ステータス項目オブジェクトと関連する構成を簡単に相互参照できます。

00:11:55.000 --> 00:12:01.000
これら2つのキーは、すべてのタイプのアカウントステータスアイテムオブジェクトに常に存在します。

00:12:01.000 --> 00:12:03.000
他のキーはアカウントの種類に固有のものです。

00:12:03.000 --> 00:12:11.000
たとえば、メールサーバーのホスト名とポート、または購読したカレンダーのカレンダーURL。

00:12:11.000 --> 00:12:19.000
このリリースでは、同じタイプの1つ以上のアカウントのレポートをサポートするために、値が配列であるステータスアイテムが導入されます。

00:12:19.000 --> 00:12:22.000
このような配列値には特別な動作があります。

00:12:22.000 --> 00:12:30.000
配列内の各項目は、単一の配列内のすべてのオブジェクトに使用されるのと同じスキーマを持つJSONオブジェクトです。

00:12:30.000 --> 00:12:37.000
各オブジェクトタイプには常に識別キーがあり、配列内のオブジェクトを見つけるための主キーとして機能します。

00:12:37.000 --> 00:12:42.000
他のキーが存在し、報告されている基礎となるタイプのステータスに結びついています。

00:12:42.000 --> 00:12:52.000
将来のOSリリースで追加されたキーとの互換性を確保するために、サーバーは配列オブジェクト内の未知のキーを受け入れる必要があります。

00:12:52.000 --> 00:13:01.000
配列値の変更は、パフォーマンス上の理由から、常にオブジェクトごとにサーバーに段階的に報告されます。

00:13:01.000 --> 00:13:05.000
この新機能がどのように機能するかを示す例を見てみましょう。

00:13:05.000 --> 00:13:10.000
この例では、サーバーは2つのメールアカウント設定をデバイスに送信します。

00:13:10.000 --> 00:13:16.000
これらは両方ともアクティブであるため、デバイスに2つのメールアカウントが存在します。

00:13:16.000 --> 00:13:21.000
サーバーは、メールアカウントのステータス項目のステータスサブスクリプションを送信するようになりました。

00:13:21.000 --> 00:13:29.000
サブスクリプションが有効になると、アカウントのステータスが収集され、デバイスはサーバーにステータスレポートを送信します。

00:13:29.000 --> 00:13:38.000
ステータスレポートには、ステータス配列に2つのアカウントステータスオブジェクトが含まれ、サーバーにデバイスに現在存在するものの全体像を提供します。

00:13:38.000 --> 00:13:42.000
各配列オブジェクトには異なる識別子があります。

00:13:42.000 --> 00:13:49.000
このレポートを処理した後、サーバーは2つのメールアカウントのステータスを持ち、デバイス上にあるものと一致します。

00:13:49.000 --> 00:14:03.000
サーバーが新しい構成を送信してデバイスにメールアカウントを追加すると、デバイスのステータスアイテムに新しいオブジェクトが配列値に追加され、別のステータスレポートがサーバーに送信されます。

00:14:03.000 --> 00:14:05.000
新しいアイテムのみが報告されます。

00:14:05.000 --> 00:14:15.000
識別子キーの値は、サーバーがすでに持っている値と一致しないため、サーバーはこれが新しいアカウントに対応していると推測できます。

00:14:15.000 --> 00:14:25.000
このレポートを処理した後、サーバーは3つのメールアカウント、2つの最初のアカウントと新しいアカウントのステータスを持ち、再びデバイス上にあるものと正確に一致します。

00:14:25.000 --> 00:14:41.000
ユーザーがメールやメモの有効状態を切り替えるなど、アカウントのステータスが変更されると、デバイス上のステータスアイテムは配列値に更新されたオブジェクトを持ち、再びステータスレポートがサーバーに送信されます。

00:14:41.000 --> 00:14:43.000
変更された項目のみが報告されます。

00:14:43.000 --> 00:14:47.000
この場合、ユーザーはアカウントのメモ機能をオフにしました。

00:14:47.000 --> 00:14:56.000
識別子キーの値は、サーバーがすでに持っているものと一致するため、サーバーはこれが既存のアカウントの更新であると推測できます。

00:14:56.000 --> 00:15:02.000
その結果、既存のステータスアイテム配列オブジェクトを新しいものに置き換えます。

00:15:02.000 --> 00:15:09.000
このレポートを処理した後、サーバーは3つのメールアカウントのステータスを持っていますが、1つは変更されました。

00:15:09.000 --> 00:15:21.000
アカウント設定がデバイスから削除されると、デバイス上のステータス項目には削除のためにマークされた対応するオブジェクトがあり、別のステータスレポートがサーバーに送信されます。

00:15:21.000 --> 00:15:24.000
削除されたアイテムのみが報告されます。

00:15:24.000 --> 00:15:37.000
削除を示すために、配列項目オブジェクトには2つのキーのみが含まれています。識別子キー（その値はサーバーがすでに持っているものと一致します）と削除されたキーは、値trueに設定されています。

00:15:37.000 --> 00:15:44.000
これにより、サーバーは既存のアイテムを削除することで、デバイス状態の表現を更新できます。

00:15:44.000 --> 00:15:52.000
このレポートを処理した後、サーバーのステータスは2つのメールアカウントのみで、デバイスの状態と正しく一致します。

00:15:52.000 --> 00:15:55.000
ステータスレポートに関する最後のポイント。

00:15:55.000 --> 00:16:01.000
デバイスは、パフォーマンスの問題を回避するために、ステータスレポートが送信される速度を制限します。

00:16:01.000 --> 00:16:10.000
デバイスは、ステータスレポートをサーバーに送信する前に、最大1分間の可変間隔でステータス項目への変更を集約します。

00:16:10.000 --> 00:16:15.000
これは、ステータスが迅速に報告されることを意味しますが、即時ではありません。

00:16:15.000 --> 00:16:24.000
次に、長年のMDMボトルネック問題の解決に注意を向けましょう。アプリケーションのインストールステータスを監視します。

00:16:24.000 --> 00:16:32.000
MDMサーバーは、多くの場合、デバイスにアプリをインストールして、ユーザーが仕事や教育に必要なツールにアクセスできるようにします。

00:16:32.000 --> 00:16:37.000
サーバー側のロジックは、多くの場合、アプリが正常にインストールされたかどうかによって決定されます。

00:16:37.000 --> 00:16:48.000
したがって、MDMサーバーは、アプリのインストールの進捗状況を監視し、ユーザーがデバイスで管理対象アプリを削除する可能性を監視する必要があります。

00:16:48.000 --> 00:16:59.000
現在、MDMサーバーは、InstalledApplicationListまたはManagedApplicationListコマンドを使用してデバイスをポーリングし、アプリのインストールの進行状況を観察できます。

00:16:59.000 --> 00:17:06.000
デバイスにアプリのインストールの進捗状況を積極的にサーバーに送信させることで、ポーリングを回避できます。

00:17:06.000 --> 00:17:12.000
そして、それを行うためのツールは、宣言的なデバイス管理ステータスレポートです。

00:17:12.000 --> 00:17:15.000
このリリースでは、mdm.appのステータス項目が追加されます。

00:17:15.000 --> 00:17:22.000
その値は、それぞれがMDMサーバーによってインストールされたアプリを表すオブジェクトの配列です。

00:17:22.000 --> 00:17:28.000
この値は配列であるため、前述の手順を使用して段階的に報告されます。

00:17:28.000 --> 00:17:35.000
ここでは、監視対象のデバイスでも、MDMによってインストールされたアプリのみが報告されることに注意してください。

00:17:35.000 --> 00:17:40.000
このステータスレポートには、インストールが完了したアプリのステータス項目が含まれています。

00:17:40.000 --> 00:17:48.000
識別子キーは、配列項目オブジェクトの一意の識別子であり、この場合、アプリのバンドル識別子です。

00:17:48.000 --> 00:17:51.000
ネームキーはアプリの名前を示します。

00:17:51.000 --> 00:17:57.000
3つのバージョンキーは、通常、短い、および外部のバージョン識別子を提供します。

00:17:57.000 --> 00:18:02.000
そして、ステートキーは、アプリの現在のインストールフェーズを示す列挙です。

00:18:02.000 --> 00:18:10.000
これらのキーの値は、MDM ManagedApplicationListコマンド応答の同等の項目に対応しています。

00:18:10.000 --> 00:18:18.000
これらすべての情報を使用して、サーバーはどのアプリが報告され、その状態であるかをすぐに識別できます。

00:18:18.000 --> 00:18:22.000
アプリのインストール時のデータの流れの例を見てみましょう。

00:18:22.000 --> 00:18:28.000
右側には、MDMサーバーによって管理されているiOS 16デバイスがあります。

00:18:28.000 --> 00:18:37.000
サーバーはすでに宣言的なデバイス管理を有効にしており、MDMがインストールしたアプリのステータス項目のステータスサブスクリプションを送信しています。

00:18:37.000 --> 00:18:43.000
サーバーの次のステップは、MDM InstallApplicationコマンドを使用してアプリをインストールすることです。

00:18:43.000 --> 00:18:52.000
これはユーザー登録であるため、アプリをインストールするにはユーザーの承認が必要なため、デバイスがアプリのインストールコマンドを処理するときにプロンプトが表示されます。

00:18:52.000 --> 00:18:58.000
この時点で、インストールの進行状況は一時停止され、ユーザーの入力を待ちます。

00:18:58.000 --> 00:19:10.000
デバイスはサーバーにステータスレポートを送信し、アプリのバンドルIDと状態がプロンプトに設定されている単一のMDMインストールアプリのステータスオブジェクトが含まれます。

00:19:10.000 --> 00:19:16.000
ある時点で、ユーザーがインストールボタンをタップすると、アプリのインストールがデバイスで開始されます。

00:19:16.000 --> 00:19:28.000
インストールが進むにつれて、別のステータスレポートが送信され、今回はアプリの状態がインストールに設定されます。アプリがダウンロードされ、インストールされていることを示します。

00:19:28.000 --> 00:19:32.000
最終的には、アプリはインストールを完了し、使用できるようになります。

00:19:32.000 --> 00:19:41.000
その時点で、アプリの状態が管理対象に設定されている別のステータスレポートが送信され、アプリが適切にインストールされ、管理されていることを示します。

00:19:41.000 --> 00:19:46.000
さて、ユーザーがデバイス上のアプリを手動で削除したとしましょう。

00:19:46.000 --> 00:19:53.000
繰り返しになりますが、今回はアプリの状態が管理済みがアンインストールに設定されている状態で、ステータスレポートが送信されます。

00:19:53.000 --> 00:20:00.000
これは、アプリがインストールされなくなったが、その管理状態がまだデバイスで追跡されていることを示しています。

00:20:00.000 --> 00:20:04.000
サーバーがアプリ管理状態を削除したいと仮定しましょう。

00:20:04.000 --> 00:20:09.000
これは、デバイスにRemoveApplicationコマンドを送信することによって行います。

00:20:09.000 --> 00:20:17.000
これにより、内部で維持されている管理状態が削除され、アプリがまだ存在する場合は、それも削除されます。

00:20:17.000 --> 00:20:22.000
別のステータスレポートが送信され、アプリオブジェクトがアプリのステータス配列から削除されたとマークされます。

00:20:22.000 --> 00:20:35.000
これは、アプリのインストールの応答性と信頼性を向上させるのに役立つ新しいMDMステータスアイテムの力を示しており、実装にはほんの数ステップしかかかりません。

00:20:35.000 --> 00:20:40.000
それでは、3番目の重点分野である述語を調べてみましょう。

00:20:40.000 --> 00:20:43.000
アクティベーション述語をすばやく確認しましょう。

00:20:43.000 --> 00:20:52.000
アクティベーションには、アクティベーションで参照される構成がデバイスに適用されるかどうかを決定するオプションの述語を含めることができます。

00:20:52.000 --> 00:20:57.000
述語は、ステータス項目を参照して、それらのステータス項目の値をテストできるようにすることができます。

00:20:57.000 --> 00:21:06.000
述語で参照されるステータス項目が変更されると、デバイスはすべてのアクティベーションを再処理し、述語を再評価します。

00:21:06.000 --> 00:21:13.000
述語は、Apple Developerサイトに記載されているNSPredicate構文を使用して文字列として指定されます。

00:21:13.000 --> 00:21:23.000
より複雑な述語式をサポートするために、式内のステータス項目を検出しやすくするために述語構文を拡張しました。

00:21:23.000 --> 00:21:30.000
新しい構文は、述語文字列の@status項内にステータス項目名を配置します。

00:21:30.000 --> 00:21:38.000
この例では、シリアル番号のステータス項目は、新しい構文を使用して述語式に表示されます。

00:21:38.000 --> 00:21:47.000
以前の構文は下位互換性のために引き続き機能しますが、現在は非推奨なので、新しいものに切り替えてください。

00:21:47.000 --> 00:21:52.000
述語がステータス項目の配列値でどのように使用できるかを調べてみましょう。

00:21:52.000 --> 00:21:59.000
先ほど説明したように、アカウントとMDMがインストールしたアプリのステータスアイテムの配列であるステータスアイテム値ができるようになりました。

00:21:59.000 --> 00:22:05.000
配列内のアイテムのアクティベーションを述語できると便利です。

00:22:05.000 --> 00:22:14.000
たとえば、特定のバンドル識別子を持つアプリがデバイスにインストールされ、管理されているときに、アクティベーションをトリガーしたい場合があります。

00:22:14.000 --> 00:22:20.000
NSPredicateには、配列を操作するために使用できるSUBQUERY用語があります。

00:22:20.000 --> 00:22:26.000
このNSPredicate式は、MDMにインストールされたアプリのステータスアイテムをターゲットにしたSUBQUERYを使用します。

00:22:26.000 --> 00:22:30.000
ステータス項目は、サブクエリの最初の引数として使用されます。

00:22:30.000 --> 00:22:35.000
2番目の引数は、配列の各要素を参照する変数を定義します。

00:22:35.000 --> 00:22:42.000
3番目の引数は、その変数によって識別される各要素をテストする述語式です。

00:22:42.000 --> 00:22:48.000
SUBQUERY式は、3番目の引数の述語に一致する要素の配列を返します。

00:22:48.000 --> 00:22:57.000
次に、@count演算子はその配列の長さを返し、長さをチェックして、結果の一致が1つあるかどうかを判断します。

00:22:57.000 --> 00:23:07.000
指定されたアプリがインストールされ、管理されると、このSUBQUERY式は単一の要素を持つ配列を返し、述語はtrueと評価されます。

00:23:07.000 --> 00:23:15.000
アプリがインストールされていない場合、SUBQUERY式は空の配列を返し、述語はfalseと評価されます。

00:23:15.000 --> 00:23:25.000
ステータス項目配列オブジェクトのキーを参照するには、キーパスが適切に処理されていることを確認するために、@key拡張用語を使用する必要があることに注意してください。

00:23:25.000 --> 00:23:35.000
新しい述語構文は拡張可能であり、新しいタイプのデータの述語用語を追加するためにどのように使用できるかについて説明します。

00:23:35.000 --> 00:23:51.000
サーバーは、複雑なサーバー側のロジックが、それらの変更をトリガーするために大規模な構成セットを同期することなく、デバイス上の単純な状態変更に変換できるように、述語の評価をより直接制御できる必要があります。

00:23:51.000 --> 00:24:10.000
この例としては、複数の役割を持つユーザーがいて、ユーザーに配布されるデバイスの効率的でタイムリーな割り当てを希望する組織、または交換用デバイスを迅速に配布する必要がある組織、または組織データを保護するためにデバイスをセーフモードにすばやく配置する必要がある組織です。

00:24:10.000 --> 00:24:22.000
これをサポートするために、サーバーがアクティベーション述語で直接使用できる任意のプロパティをデバイスに設定できるようにする新しい宣言を追加していることを嬉しく思います。

00:24:22.000 --> 00:24:26.000
これは新しい管理プロパティ宣言です。

00:24:26.000 --> 00:24:33.000
宣言は、キー名がサーバーによって定義されているJSONオブジェクトで構成されています。

00:24:33.000 --> 00:24:39.000
JSONオブジェクト値は、配列やオブジェクトを含む任意のJSON値タイプにすることができます。

00:24:39.000 --> 00:24:51.000
ここでの管理プロパティ宣言には、文字列と整数値を持つ名前と年齢プロパティ、および文字列の配列であるロールプロパティの3つのプロパティが含まれています。

00:24:51.000 --> 00:24:56.000
これは、いくつかの管理プロパティを参照する述語を持つアクティベーションです。

00:24:56.000 --> 00:25:11.000
まず、age プロパティをテストして、その整数値が 18 より大きいかどうかを判断し、次に roles プロパティをテストして、文字列 Grade12 がプロパティ配列値にあるかどうかを判断します。

00:25:11.000 --> 00:25:19.000
各プロパティは、@property拡張用語を使用して参照され、プロパティキー名は用語内にあります。

00:25:19.000 --> 00:25:26.000
複数の管理プロパティ宣言をデバイスに送信できますが、キーはすべてで一意である必要があります。

00:25:26.000 --> 00:25:35.000
重複したキーがある場合、プロパティが述語で参照されると、値の1つが任意に選択され、予測不可能な結果につながります。

00:25:35.000 --> 00:25:39.000
したがって、重複したキー名の使用は避けてください。

00:25:39.000 --> 00:25:43.000
ユースケースの例を探ってみましょう。

00:25:43.000 --> 00:25:45.000
この例には学校が関係しています。

00:25:45.000 --> 00:25:48.000
そしてもちろん、学校には教師がいます。

00:25:48.000 --> 00:25:52.000
学校には上と下の2つの部門があります。

00:25:52.000 --> 00:25:57.000
各部門には、独自のWi-Fiネットワークを備えた独自のキャンパスがあります。

00:25:57.000 --> 00:26:02.000
一部の教師はIT管理者として機能し、共有メールアカウントへのアクセスが必要です。

00:26:02.000 --> 00:26:10.000
一部の教師はスポーツコーチとしても機能し、すべてのチームの試合スケジュールのカレンダーを購読する必要があります。

00:26:10.000 --> 00:26:16.000
したがって、教師には4つの異なる役割があり、時には複数の役割があります。

00:26:16.000 --> 00:26:25.000
各役割には、デバイスに割り当てられた教師の役割に基づいてデバイスに適用する必要がある一連の構成があります。

00:26:25.000 --> 00:26:28.000
私たちの例では2人の教師を考えてみましょう。

00:26:28.000 --> 00:26:33.000
教師は中学校で教えており、スポーツコーチでもあります。

00:26:33.000 --> 00:26:39.000
教師2は高校で教えており、IT管理者でもあります。

00:26:39.000 --> 00:26:44.000
このようなユースケースは、従来のMDMサーバーでどのように処理されますか?

00:26:44.000 --> 00:26:51.000
通常、サーバーは、そのデバイスを完全に設定する前に、デバイスが教師に割り当てられるのを待たなければなりません。

00:26:51.000 --> 00:26:55.000
サーバーは、教師がどのような役割を持っているかを決定する必要があります。

00:26:55.000 --> 00:26:59.000
次に、各ロールにリンクされているプロファイルを決定します。

00:26:59.000 --> 00:27:05.000
次に、各プロファイルを一度に1つずつデバイスにインストールする必要があります。

00:27:05.000 --> 00:27:11.000
教師が役割を変更した場合、サーバーは新しい役割に合わせてプロファイルを追加または削除しなければなりません。

00:27:11.000 --> 00:27:24.000
これは時間がかかり、特にピーク時にデバイス管理システムに大きなボトルネックをもたらす可能性があります。私たちの場合、課題が終わった学校の初日になります。

00:27:24.000 --> 00:27:30.000
新しい管理プロパティ宣言により、これに代わるより効率的な代替手段があります。

00:27:30.000 --> 00:27:35.000
これには、事前にデバイスにフルセットの宣言をプリロードすることが含まれます。

00:27:35.000 --> 00:27:44.000
構成はアクティベーションに割り当てられ、管理プロパティを介して異なる役割に対してトリガーされる述語があります。

00:27:44.000 --> 00:27:56.000
デバイスが教師に割り当てられると、サーバーは教師の役割を持つ管理プロパティ宣言のみを送信し、それらの役割の構成のアクティブ化をトリガーします。

00:27:56.000 --> 00:28:05.000
この方法は、サーバーとネットワーク全体のトラフィックを最小限に抑え、デバイスの状態に迅速な変更を加えることの複雑さを軽減します。

00:28:05.000 --> 00:28:07.000
私たちの学校の例に戻りましょう。

00:28:07.000 --> 00:28:17.000
サーバーは、次の一連の宣言をプリロードします。各部門のWi-Fiネットワークを設定する2つのアクティベーション/構成ペア。

00:28:17.000 --> 00:28:23.000
次に、メールアカウントをインストールするIT管理者の役割のアクティベーション/設定ペアがあります。

00:28:23.000 --> 00:28:29.000
最後に、購読したカレンダーをインストールするアクティベーションと設定があります。

00:28:29.000 --> 00:28:36.000
各アクティベーションには、ロール管理プロパティを使用して除算または関数の名前をテストする述語があります。

00:28:36.000 --> 00:28:44.000
未割り当てのデバイスに最初にロードすると、すべての述語がfalseと評価されるため、何も適用されません。

00:28:44.000 --> 00:28:48.000
では、課題の日に何が起こるかを調べてみましょう。

00:28:48.000 --> 00:28:55.000
サーバーがする必要があるのは、各教師にカスタマイズされた管理プロパティ宣言を作成することだけです。

00:28:55.000 --> 00:28:59.000
教師1には、ローワーとスポーツをリストする役割プロパティがあります。

00:28:59.000 --> 00:29:05.000
教師2には、上部とIT管理者をリストするロールプロパティがあります。

00:29:05.000 --> 00:29:13.000
これらの宣言が割り当てられた各デバイスに別々に送信されると、プリロードされたアクティベーションはすべて再評価されます。

00:29:13.000 --> 00:29:20.000
したがって、教師のデバイスには、ローワーとスポーツの役割の構成が有効になっています。

00:29:20.000 --> 00:29:27.000
そして、教師2のデバイスは、上部とIT管理者の役割の構成がアクティブになっています。

00:29:27.000 --> 00:29:33.000
多くの設定の適用をトリガーするには、単一の宣言のみが必要です。

00:29:33.000 --> 00:29:37.000
最後に、教師が役割を変えたときに何が起こるかを調べてみましょう。

00:29:37.000 --> 00:29:43.000
この場合、教師2は既存の役割に加えてスポーツコーチになりました。

00:29:43.000 --> 00:29:50.000
教師に割り当てられたデバイスの管理プロパティ宣言が更新され、追加の役割名が追加されました。

00:29:50.000 --> 00:29:56.000
その宣言がデバイスで更新されると、すべてのアクティベーションが再評価されます。

00:29:56.000 --> 00:30:01.000
この場合、新しいスポーツロールのサブスクライブカレンダー設定が適用されます。

00:30:01.000 --> 00:30:06.000
繰り返しますが、トリガーとして必要な宣言の変更は1つだけです。

00:30:06.000 --> 00:30:23.000
これは、管理プロパティ宣言が、複雑なサーバーサイドロジックがデバイス上の単純な状態変更に変換できるように、デバイス上の構成セットを迅速かつ簡単に切り替える強力な方法を提供する方法を示しています。

00:30:23.000 --> 00:30:25.000
さあ、締めくくりましょう。

00:30:25.000 --> 00:30:41.000
iOS 16、tvOS 16、macOS Venturaの宣言型デバイス管理の範囲を拡大し、共有iPadを含むすべての適用可能なタイプのMDM登録で利用できるようにしました。

00:30:41.000 --> 00:30:49.000
これにより、MDMをサポートするすべてのAppleデバイスで宣言的なデバイス管理を完全にサポートします。

00:30:49.000 --> 00:30:56.000
パスコード、アカウント、MDMでインストールされたアプリの新しいステータス項目を追加しました。

00:30:56.000 --> 00:31:03.000
MDMにインストールされたアプリのステータスは、MDMの重要なボトルネックの1つに優れたソリューションを提供します。

00:31:03.000 --> 00:31:19.000
最後に、述語構文を強化して、より拡張可能で使いやすくし、サーバーに複雑なビジネスロジックをデバイスに移動するさらに多くの機会を与える新しい管理プロパティ宣言を追加しました。

00:31:19.000 --> 00:31:24.000
今、あなたの製品に宣言的なデバイス管理を追加する時です。

00:31:24.000 --> 00:31:32.000
そして、宣言的なデバイス管理を使用してデバイス管理ソリューションを再考するために何をするかを学ぶことに興奮しています!

00:31:32.000 --> 00:31:35.000
いつものように、あなたのフィードバックは大歓迎です。

00:31:35.000 --> 00:31:38.000
ありがとう、WWDCの残りの部分を楽しんでください。

00:31:38.000 --> 23:59:59.000
♪ ♪

