WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:13.000
こんにちは！私の名前はトムで、アップルのスウィフトチームの一員です。

00:00:13.000 --> 00:00:18.000
今日は、iOSアプリケーションをクラウドに拡張するために必要なことを共有したいと思います。

00:00:18.000 --> 00:00:24.000
私たちのアプリケーションの多くは、単一のデバイス、通常はiPhoneに焦点を当てて始まります。

00:00:24.000 --> 00:00:33.000
使用量が増えるにつれて、Mac、時計、その他のAppleプラットフォームやデバイスなどの追加のデバイスに持ち込みたいと考えています。

00:00:33.000 --> 00:00:38.000
Xcodeは、これらのプラットフォーム用のアプリケーションを整理して構築するのに役立ちます。

00:00:38.000 --> 00:00:47.000
プラットフォーム固有のアプリケーションコードで各デバイスのユニークな側面を取り入れながら、パッケージを使用してコードを共有できます。

00:00:47.000 --> 00:00:54.000
システムが成長し進化し続けるにつれて、アプリケーションは多くの場合、サーバーコンポーネントでクライアントアプリケーションを補完する必要があります。

00:00:54.000 --> 00:00:59.000
これらのサーバーコンポーネントは、クライアントアプリケーションがその機能をクラウドに拡張することを可能にします。

00:00:59.000 --> 00:01:11.000
たとえば、バックグラウンドで実行できるタスクのオフロード、計算上の重いタスクのオフロード、またはデバイスで利用できないデータへのアクセスを必要とするタスクなどです。

00:01:11.000 --> 00:01:21.000
多くの場合、サーバーコンポーネントは、クライアントとは異なるツールや方法論を使用して構築する必要があり、重複作業と統合の課題が生じます。

00:01:21.000 --> 00:01:30.000
サーバーコンポーネントの構築にSwiftを使用すると、このテクノロジーのギャップを埋めるのに役立ち、スタック全体に使い慣れた環境を提供します。

00:01:30.000 --> 00:01:34.000
Swiftでのサーバーアプリケーションの構築がどのようなものか見てみましょう。

00:01:34.000 --> 00:01:38.000
サーバーアプリケーションはSwiftパッケージとしてモデル化されています。

00:01:38.000 --> 00:01:43.000
このパッケージは、アプリケーションのエントリポイントをマッピングする実行可能ターゲットを定義します。

00:01:43.000 --> 00:01:54.000
アプリケーションをWebアプリケーションにするには、コードを構造化し、ルーティングなどの基本的なユーティリティを提供するWebフレームワークへの依存関係を追加できます。

00:01:54.000 --> 00:02:03.000
この例では、Webサービスの構築に人気のあるオープンソースのコミュニティプロジェクトであるVapor Webフレームワークを使用しています。

00:02:03.000 --> 00:02:10.000
他のSwiftベースの実行可能ファイルと同様に、プログラムのエントリポイントは@mainアノテーションを使用してモデル化するのが最善です。

00:02:10.000 --> 00:02:15.000
Webフレームワークを統合するために、関連するブートストラップコードをメイン機能に追加します。

00:02:15.000 --> 00:02:21.000
この例で使用されているアプリケーションタイプは、Vapor Webフレームワークによって提供されます。

00:02:21.000 --> 00:02:26.000
基本的なブートストラップを導入することで、アプリケーションに何か便利なことをさせることができます。

00:02:26.000 --> 00:02:31.000
たとえば、サーバーにリクエストを行うユーザーに挨拶するコードを追加しましょう。

00:02:31.000 --> 00:02:38.000
Webフレームワークを使用してHTTPエンドポイントを定義し、挨拶を提供するメソッドにポイントします。

00:02:38.000 --> 00:02:50.000
さらに一歩進んで、2番目のHTTPエンドポイントを追加します。これはHTTPポストリクエストを処理し、リクエストボディの内容を発信者にエコーします。

00:02:50.000 --> 00:02:52.000
これを実際に見てみましょう。

00:02:52.000 --> 00:02:55.000
ここにはXcodeのサーバーアプリケーションがあります。

00:02:55.000 --> 00:03:01.000
始めたばかりなので、自分のマシンでサーバーをローカルに実行してテストすることができます。

00:03:01.000 --> 00:03:17.000
ローカルで実行するには、Xcodeによって生成された「MyServer」スキームを選択し、「My Mac」を宛先として使用し、「実行」を押します。

00:03:17.000 --> 00:03:23.000
アプリケーションが起動したら、Xcodeコンソールを使用して、サーバーから発行されたログメッセージを調べることができます。

00:03:23.000 --> 00:03:31.000
この場合、サーバーがローカルホストアドレス(127.0.0.1)ポート8080で起動し、リッスンしていることがわかります。

00:03:31.000 --> 00:03:34.000
この情報を使用してサーバーをテストできます。

00:03:34.000 --> 00:03:39.000
ターミナルに切り替えて、広告されたサーバーアドレスにリクエストをしましょう。

00:03:39.000 --> 00:03:43.000
「Curl」というユーティリティを使用してリクエストを行います。

00:03:43.000 --> 00:03:48.000
最初のエンドポイントを使用してください。

00:03:48.000 --> 00:03:51.000
そして、私たちの2番目。

00:03:51.000 --> 00:03:59.000
エコーにいくつかのデータを渡します。

00:03:59.000 --> 00:04:01.000
いいね！

00:04:01.000 --> 00:04:08.000
ターミナルを使うのは確かに楽しかったですが、私たちが本当に知りたいのは、iOSアプリからサーバーを呼び出す方法です。

00:04:08.000 --> 00:04:09.000
それを掘り下げてみましょう。

00:04:09.000 --> 00:04:15.000
以下は、サーバーとの相互作用を抽象化するために使用できるSwiftデータ構造の例です。

00:04:15.000 --> 00:04:23.000
ネットワークは本質的に非同期であるため、サーバーAPIを抽象化の非同期メソッドとしてモデル化します。

00:04:23.000 --> 00:04:32.000
URLSessionを使用して非同期要求を行い、サーバーの応答を解析し、最後に呼び出し元に返します。

00:04:32.000 --> 00:04:39.000
この場合、サーバーの応答はプレーンな文字列ですが、実際にはより洗練されている可能性があります。

00:04:39.000 --> 00:04:47.000
たとえば、応答はJSONでエンコードされる可能性があり、その場合、SwiftのCodableシステムを使用してデコードできます。

00:04:47.000 --> 00:04:50.000
これをすべてXcodeにまとめましょう。

00:04:50.000 --> 00:04:56.000
Xcodeワークスペースを使用して、iOSとサーバーアプリケーションを並べて構築およびテストしています。

00:04:56.000 --> 00:05:00.000
私たちはすでにiOSアプリケーションサーバーの抽象化の準備ができています。

00:05:00.000 --> 00:05:07.000
デフォルトのSwiftUI ContentViewを変更して、まとめたコードを使用してサーバーの挨拶を取得しましょう。

00:05:07.000 --> 00:05:13.000
まず、serverGreetingという状態変数を作成します。

00:05:13.000 --> 00:05:21.000
次に、serverGreetingをテキスト表示にバインドします。

00:05:21.000 --> 00:05:27.000
最後に、サーバーAPIを呼び出すタスクを追加し、状態を設定します。

00:05:27.000 --> 00:05:31.000
コードの準備ができたら、シミュレータでアプリケーションを実行できます。

00:05:31.000 --> 00:05:42.000
「MyApp」スキーム、シミュレーターを選択し、「実行」を押します。

00:05:42.000 --> 00:05:44.000
ああ、いや！エラーが発生しました!

00:05:44.000 --> 00:05:48.000
うーん、これはある種の接続エラーのようです。

00:05:48.000 --> 00:05:52.000
アドレスは正しいように見えるので、ローカルサーバーを起動するのを忘れたに違いない。

00:05:52.000 --> 00:06:07.000
Xcodeに戻り、サーバースキームを選択し、サーバーを実行しましょう。

00:06:07.000 --> 00:06:14.000
さあ、アプリケーションを再起動して、幸運を祈りましょう...

00:06:14.000 --> 00:06:16.000
そして、フーフー！うまくいった！

00:06:16.000 --> 00:06:21.000
デモのこの部分を完了するために、アプリケーションをクラウドにデプロイしましょう。

00:06:21.000 --> 00:06:28.000
AWS、Google Cloud、Azure、Herokuなど、多くのクラウドプロバイダーから選択できます。

00:06:28.000 --> 00:06:31.000
この例では、Herokuを使用します。

00:06:31.000 --> 00:06:36.000
Herokuは、このデモアプリケーションのような小さなプロジェクトのためのシステムを展開するための便利なgitプッシュを持っています。

00:06:36.000 --> 00:06:39.000
ターミナルに切り替えて展開を開始しましょう。

00:06:39.000 --> 00:06:48.000
アカウントを設定し、Herokuサービスでアプリケーションを設定した後、コードをHerokuリモートにプッシュすることができます。

00:06:48.000 --> 00:07:02.000
そして、それは行きます!

00:07:02.000 --> 00:07:11.000
Herokuは、ビルドパックと呼ばれる技術を使用してアプリケーションをリモートでコンパイルし、バイナリアーティファクトを一時的なホストにデプロイします。

00:07:11.000 --> 00:07:19.000
Heroku swift buildpackは、Swiftオープンソースコミュニティのメンバーによって構築され、すべてのSwift on Serverユーザーが利用できます。

00:07:19.000 --> 00:07:24.000
アプリケーションをデプロイすると、ローカルサーバーで行ったように、curlを使用してテストできます。

00:07:24.000 --> 00:07:28.000
最初のエンドポイントをテストしましょう。

00:07:28.000 --> 00:07:37.000
ここに住所をコピーしてください。

00:07:37.000 --> 00:07:42.000
そして、私たちの2番目。

00:07:42.000 --> 00:07:51.000
今回は、別のペイロードを送信します。

00:07:51.000 --> 00:07:55.000
スウィート、私たちのアプリケーションは正常に展開されました!

00:07:55.000 --> 00:08:00.000
続ける前に、ここで一時停止して、トークのこの部分からの主なポイントを確認しましょう。

00:08:00.000 --> 00:08:08.000
すでにSwiftを使用してiOSまたはmacOSアプリケーションを構築している場合は、システムのサーバー側の開発にも使用できます。

00:08:08.000 --> 00:08:15.000
Xcodeは、クライアントとサーバーの両方のシステムのさまざまなコンポーネントを1つのワークスペースで開発およびデバッグするのに役立ちます。

00:08:15.000 --> 00:08:20.000
そして最後に、Swiftベースのサーバーアプリケーションを展開するためのクラウドプロバイダーを選択できます。

00:08:20.000 --> 00:08:28.000
これらのクラウドプラットフォームへの展開に関する追加情報は、swift.orgのSwift Serverのドキュメントに記載されています。

00:08:28.000 --> 00:08:33.000
基本的なセットアップを見たので、より現実的な例を見てみましょう - フードトラック!

00:08:33.000 --> 00:08:36.000
あなたはおそらく、私たちのセッションの多くでこのアプリケーションが使用されているのを見たことがあるでしょう。

00:08:36.000 --> 00:08:39.000
ボンネットの下を覗いて、データがどのように管理されているかを見てみましょう。

00:08:39.000 --> 00:08:43.000
うーん、ドーナツリストはハードコード化されているようです。

00:08:43.000 --> 00:08:49.000
これは、アプリケーションのユーザーが実際に利用可能なものとは異なるドーナツのメニューを見る可能性があることを意味します。

00:08:49.000 --> 00:09:01.000
これは、その場であらゆる種類のドーナツを作ることができる小さなフードトラック操作に役立つかもしれませんが、メニューが一元化され、トラックがすべて顧客サービスに関するドーナツ帝国を構築したいと考えています。

00:09:01.000 --> 00:09:06.000
一元化されたフードトラックシステムがどのように見えるかを設計しましょう。

00:09:06.000 --> 00:09:10.000
私たちは、インメモリストレージを備えたiOSアプリから始めています。

00:09:10.000 --> 00:09:16.000
メニューを一元化するために、iOSアプリからストレージを抽出してサーバーに移動できます。

00:09:16.000 --> 00:09:22.000
これにより、アプリのすべてのユーザーが同じストレージを共有できるため、同じドーナツメニューを共有できます。

00:09:22.000 --> 00:09:28.000
トークの最初の部分の例と同様に、私たちのサーバーはHTTPベースのAPIを公開します。

00:09:28.000 --> 00:09:38.000
iOSアプリは、これらのAPIを操作するために抽象化を使用し、この例ではSwiftUIのプレゼンテーション層に結び付けます。

00:09:38.000 --> 00:09:39.000
私たちのデザインは完成しました。

00:09:39.000 --> 00:09:42.000
甘いコードを書く時間です。

00:09:42.000 --> 00:09:47.000
開発者リソースキットからフードトラックのサンプルアプリをダウンロードすることで、フォローできます。

00:09:47.000 --> 00:09:59.000
アプリケーションスケルトンを使用してサーバーの構築を開始し、「donuts」Web APIのHTTPエンドポイントを定義し、サーバー抽象化の「listDonuts」メソッドにポイントします。

00:09:59.000 --> 00:10:08.000
APIがDonutsタイプのResponseを返し、Response.DonutsがContentと呼ばれるプロトコルに準拠していることに気付いたかもしれません。

00:10:08.000 --> 00:10:15.000
コンテンツプロトコルはWebフレームワークによって定義され、応答をワイヤ上のJSONとしてエンコードするのに役立ちます。

00:10:15.000 --> 00:10:29.000
また、APIには神秘的なモデルの配列が含まれていることに気づいたかもしれません。ドーナツ、私たちはまだ定義していないので、ここに、その栄光のすべてのデータモデルがあります：ドーナツ、生地、グレーズ、トッピング。

00:10:29.000 --> 00:10:39.000
ここで興味深い点の1つは、サーバーとクライアントのデータモデルを大まかに整列させる必要があるため、フードトラックiOSアプリからこのモデルの定義をコピーしたことです。

00:10:39.000 --> 00:10:43.000
もう1つの興味深い点は、Encodableプロトコルへの準拠です。

00:10:43.000 --> 00:10:49.000
これは、サーバーがモデルオブジェクトをワイヤ上でJSONとしてエンコードできるようにする必要があります。

00:10:49.000 --> 00:10:54.000
データモデルと基本的なAPIを導入することで、ロジックを拡張してストレージの抽象化を含めることができます。

00:10:54.000 --> 00:10:58.000
ストレージは、利用可能なドーナツのリストをアプリケーションに提供します。

00:10:58.000 --> 00:11:01.000
この時点で、私たちは完全に機能するサーバーを持っているはずです。

00:11:01.000 --> 00:11:04.000
でも待って！私たちのドーナツメニューは空です!

00:11:04.000 --> 00:11:07.000
集中メニューはどこから入手できますか？

00:11:07.000 --> 00:11:12.000
サーバー側のアプリケーションを設計するとき、ストレージは常に興味深いトピックです。

00:11:12.000 --> 00:11:16.000
ユースケースに応じて、いくつかの戦略から選択できます。

00:11:16.000 --> 00:11:23.000
アプリケーションデータが静的である場合、または非常にゆっくりと手動で変更される場合、ディスク上のファイルは十分な解決策を提供する可能性があります。

00:11:23.000 --> 00:11:32.000
ユーザー中心のデータまたはグローバルデータセットの場合、iCloudは、専用サーバーを展開せずに、iOSアプリケーションから直接使用できる一連のAPIを提供します。

00:11:32.000 --> 00:11:37.000
動的データまたはトランザクションデータを扱う場合、データベースは優れたソリューションを提供します。

00:11:37.000 --> 00:11:42.000
サーバーサイドアプリケーションには、さまざまなデータベース技術が用意されています。

00:11:42.000 --> 00:11:48.000
各テクノロジーは、特定のパフォーマンス、データの一貫性、およびデータモデリングのニーズに合わせて設計されています。

00:11:48.000 --> 00:11:55.000
長年にわたり、Swiftオープンソースコミュニティは、ほとんどのデータベース技術とネイティブに対話するのに役立つデータベースドライバを開発しました。

00:11:55.000 --> 00:12:03.000
部分的なリストには、Postgres、MySQL、MongoDB、Redis、DynamoDBなどが含まれます。

00:12:03.000 --> 00:12:14.000
このデモを簡素化するために、静的ファイルストレージ戦略のみを実演しますが、swift.orgのSwift Serverドキュメントでデータベースの使用について詳しく知ることができます。

00:12:14.000 --> 00:12:21.000
静的ファイルストレージ戦略を使用しているため、ドーナツメニューをキャプチャするJSONファイルを作成することから始めます。

00:12:21.000 --> 00:12:28.000
このファイルを作成した後、SwiftPMのリソースサポートを使用してアプリケーションにアクセスできるようにします。

00:12:28.000 --> 00:12:33.000
それがあれば、ストレージの抽象化をより洗練されたものにする時が来ました。

00:12:33.000 --> 00:12:36.000
つまり、「ロード」メソッドを追加します。

00:12:36.000 --> 00:12:46.000
このメソッドは、SwiftPMの生成されたリソースアクセサを使用してリソースファイルパスを検索し、FileManager APIを使用してファイルの内容をメモリにロードします。

00:12:46.000 --> 00:12:53.000
最後に、JSONDecoderを使用して、JSONコンテンツをサーバーアプリケーションデータモデルにデコードします。

00:12:53.000 --> 00:12:57.000
興味深い変更の1つは、ストレージがアクターとして定義されていることです。

00:12:57.000 --> 00:13:07.000
ストレージには変更可能な「ドーナツ」変数があり、「load」メソッドと「listDonuts」メソッドが同時にアクセスする可能性があるため、アクターを使用することを選択しました。

00:13:07.000 --> 00:13:16.000
Swift 5.5で最初に導入されたアクターは、データレースを回避し、安全で簡単な方法で共有ミュータブル状態に対処するのに役立ちます。

00:13:16.000 --> 00:13:25.000
アクターの導入前に、ロックやキューなどのAPIを使用して変更可能な状態にアクセスするときに、同期ブロックを記憶して追加する必要がありました。

00:13:25.000 --> 00:13:28.000
ストレージの更新が完了すれば、それをすべて結びつけることができます。

00:13:28.000 --> 00:13:33.000
サーバーの抽象化に「ブートストラップ」メソッドを追加し、そこからストレージをロードします。

00:13:33.000 --> 00:13:37.000
次に、ブートストラップを実行可能ファイルのエントリポイントに配線します。

00:13:37.000 --> 00:13:42.000
ストレージはアクターになったため、非同期コンテキストでアクセスすることに注意してください。

00:13:42.000 --> 00:13:43.000
私たちのサーバーは準備ができています。

00:13:43.000 --> 00:13:45.000
クライアント側に切り替えましょう。

00:13:45.000 --> 00:13:52.000
まず、サーバーAPIをカプセル化するのに役立つサーバーの抽象化を追加することから始めます。

00:13:52.000 --> 00:14:02.000
URLSessionを使用してHTTPリクエストを作成し、JSONDecoderを使用してサーバーの応答をデコードし、JSONからiOSアプリケーションモデルに変換します。

00:14:02.000 --> 00:14:08.000
この時点で、ハードコードされたメニューを削除して、サーバーからの非同期フェッチに置き換えることができます。

00:14:08.000 --> 00:14:12.000
最後に、ContentViewロードタスクからサーバーに呼び出します。

00:14:12.000 --> 00:14:14.000
テストの時間だ！

00:14:14.000 --> 00:14:17.000
今回は、サーバーを起動することを忘れないでください。

00:14:17.000 --> 00:14:19.000
ここで「FoodTruckServer」スキームを選択します。

00:14:19.000 --> 00:14:24.000
ヒットラン。

00:14:24.000 --> 00:14:33.000
そして、アプリケーションが実行されているので、ターミナルにジャンプして、APIにアクセスできるようにしましょう。

00:14:33.000 --> 00:14:37.000
住所をもう一度コピーしてください。

00:14:37.000 --> 00:14:43.000
今回は、jqというユーティリティを使用して、JSON出力をよりきれいに印刷します。

00:14:43.000 --> 00:14:46.000
これはかなり良さそうです。

00:14:46.000 --> 00:14:49.000
さて、私たちのアプリでテストする時間です。

00:14:49.000 --> 00:14:52.000
Xcodeに切り替えます。

00:14:52.000 --> 00:14:56.000
ここでフードトラックスキームを選んでください。

00:14:56.000 --> 00:14:57.000
シミュレーター。

00:14:57.000 --> 00:15:01.000
そして、それを実行します。

00:15:01.000 --> 00:15:05.000
そして、そこには、私たちの集中メニューから3つのドーナツがあります。

00:15:05.000 --> 00:15:08.000
サーバーから見たものとそれを相互参照することができます。

00:15:08.000 --> 00:15:09.000
ターミナルに戻りましょう。

00:15:09.000 --> 00:15:26.000
比較を簡単にするために、jqを使用してドーナツの名前だけを照会します。

00:15:26.000 --> 00:15:32.000
ディープスペース、チョコレート2、コーヒーキャラメル-まさに私たちが期待していたものです。

00:15:32.000 --> 00:15:34.000
すごかった！

00:15:34.000 --> 00:15:36.000
しかし、私たちはさらに良くすることができます。

00:15:36.000 --> 00:15:41.000
現状では、当社のサーバーとクライアントアプリケーションはどちらもデータモデルコードの同一のコピーを持っています。

00:15:41.000 --> 00:15:48.000
iOSとサーバーアプリケーション間でモデルを共有することで、繰り返しを避け、シリアル化をより安全にすることができます。

00:15:48.000 --> 00:15:51.000
これを高いレベルで設定する方法を確認しましょう。

00:15:51.000 --> 00:15:58.000
まず、「共有」という名前のライブラリの別のパッケージを作成し、Xcodeワークスペースに追加します。

00:15:58.000 --> 00:16:10.000
次に、ターゲットフレームワークとライブラリの設定を使用して、データモデルコードを共有パッケージに移動し、サーバーアプリケーションの依存関係として、およびiOSアプリケーションの依存関係として共有を追加できます。

00:16:10.000 --> 00:16:22.000
その時点で、クライアントコードをリファクタリングして共有モデルを使用し、サーバーコードにも同じことをすることができます。

00:16:22.000 --> 00:16:24.000
今、物事はずっと良く見えます。

00:16:24.000 --> 00:16:29.000
締めくくる前に、次にアプリケーションをどこに持っていくことができるかについてのアイデアがいくつかあります。

00:16:29.000 --> 00:16:37.000
集中型サーバーがあるという事実を最大限に活用するために、メニューからドーナツを追加、編集、または削除するためのAPIを望み、定義する可能性があります。

00:16:37.000 --> 00:16:42.000
これには、ストレージを静的ファイルからデータベースに移動する必要があります。

00:16:42.000 --> 00:16:46.000
データベースを導入することで、購入および注文APIを実装することもできます。

00:16:46.000 --> 00:16:50.000
このようなAPIは、ドーナツビジネスの収益化に役立ちます。

00:16:50.000 --> 00:16:58.000
また、あまり人気のないドーナツの販売や割引など、動的な価格設定を実装するために使用できるシグナルも提供します。

00:16:58.000 --> 00:17:00.000
機会は無限大です。

00:17:00.000 --> 00:17:24.000
最後に、このセッションでは、Swiftが汎用言語であり、クライアントとサーバーアプリケーションの両方に有用であることがわかります。サーバーとクライアントアプリケーション間でコードを共有すると、ボイラープレートを減らし、システムのシリアル化をより安全にすることができます。URLSessionは、サーバーと非同期に対話するための重要なツールであり、最後に、Xcodeはシステム全体の強力な開発環境です。

00:17:24.000 --> 23:59:59.000
ご覧いただきありがとうございます。残りの会議を楽しんでください。

