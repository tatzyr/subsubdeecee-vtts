WEBVTT

00:00:00.000 -> 00:00:09.000
♪ ♪

00:00:09.000 -> 00:00:14.000
Raj Ramamurthy：こんにちは、「iPadのSwiftUI：インターフェイスを整理する」へようこそ。

00:00:14.000 -> 00:00:17.000
私はRajで、SwiftUIに取り組んでいます。

00:00:17.000 -> 00:00:25.000
iPadOS 16には、豊富な機能を備えた、より生産的でプロフェッショナルなグレードのアプリを構築できるように、多くのアップデートがあります。

00:00:25.000 -> 00:00:34.000
このセッションでは、それらのいくつかについて話し合い、iPadで輝くためにSwiftUIアプリのインターフェースを整理することについて話します。

00:00:34.000 -> 00:00:38.000
まず、リストとテーブルのツアーにご案内します。

00:00:38.000 -> 00:00:44.000
次に、SwiftUIの選択モデルと、選択をメニューと統合する方法について説明します。

00:00:44.000 -> 00:00:50.000
最後に、分割ビューを使用してiPad用のアプリのナビゲーションを構成する方法について説明します。

00:00:50.000 -> 00:00:52.000
でも待って、もっとあるよ。

00:00:52.000 -> 00:00:55.000
これは実際には2部構成のシリーズの最初のセッションです。

00:00:55.000 -> 00:01:01.000
第2部では、同僚のハリーがツールバー、タイトルなどを見学します。

00:01:01.000 -> 00:01:10.000
ハリーは、SwiftUI iPadアプリを次のレベルに引き上げるいくつかの本当に重要な追加をカバーしているので、両方のセッションを必ず見てください。

00:01:10.000 -> 00:01:14.000
リストとテーブルから始めましょう。

00:01:14.000 -> 00:01:18.000
私は最近、いくつかのブッククラブに参加しましたが、かなり遅れています。

00:01:18.000 -> 00:01:20.000
読むのに静かな場所を見つけるのはとても難しいです。

00:01:20.000 -> 00:01:26.000
だから、私が読書に集中するのを助けるために、私はこれらの神話的な静かな場所を見つけるためのアプリに取り組み始めました。

00:01:26.000 -> 00:01:30.000
静かな場所は、ページが飛ぶ読書のオアシスのようなものです。

00:01:30.000 -> 00:01:35.000
そして、このアプリは、私が見つけたすべての静かな場所を追跡するのに役立ちます。

00:01:35.000 -> 00:01:42.000
私はiPhone用のアプリを構築しましたが、より大きなディスプレイを本当に利用するためにiPad用にアップデートするのは楽しい練習だと思います。

00:01:42.000 -> 00:01:48.000
iPad用のアプリをより良くすることで、最終的にMacにも持ち込むときにもさらに進むでしょう。

00:01:48.000 -> 00:01:54.000
このセッションではMacを明示的にカバーしませんが、表示されているAPIの多くはmacOSにも適用されます。

00:01:54.000 -> 00:01:58.000
これは私がこれまでに見つけたすべての静かな場所のリストです。

00:01:58.000 -> 00:02:02.000
このリストは、アプリのアップデートから始めるのに最適な場所です。

00:02:02.000 -> 00:02:04.000
私はiPad版に取り組み始めました。

00:02:04.000 -> 00:02:08.000
ひどいことではありませんが、大きな画面を利用していません。

00:02:08.000 -> 00:02:12.000
かなりの無駄なスペースがあり、情報密度は低いです。

00:02:12.000 -> 00:02:21.000
ありがたいことに、iPadOS 16には、この種の情報密度の高いシナリオに対する素晴らしい解決策があります。複数列のテーブルです。

00:02:21.000 -> 00:02:24.000
彼らがどのように見えるかをお見せしましょう。

00:02:24.000 -> 00:02:29.000
これは、複数列テーブルにSwiftUI APIを採用した後の「すべての場所」ビューです。

00:02:29.000 -> 00:02:33.000
今後数分で、このスクリーンショットに向けて取り組みます。

00:02:33.000 -> 00:02:42.000
SwiftUIの複数列テーブルはmacOS Montereyで最初に導入され、iPadOS 16以降、同じテーブルAPIがiPadで利用可能になりました。

00:02:42.000 -> 00:02:48.000
Macと同様に、iPadのテーブルは複数の列と並べ替えをサポートしています。

00:02:48.000 -> 00:02:55.000
iPadのテーブルの導入に伴い、SwiftUIはiPadとMacのテーブルのセクションをサポートするようになりました。

00:02:55.000 -> 00:03:07.000
前のセッション「SwiftUI on the Mac: Build the fundamentals」のテーブルに関する一般的なガイダンスは、iPadにも引き続き適用されますので、まだ見ていない場合は、そのセッションを見ることをお勧めします。

00:03:07.000 -> 00:03:10.000
iPhoneリストから始めて、先ほど示した表を作り上げましょう。

00:03:10.000 -> 00:03:15.000
これが以前の場所リストのコードです。

00:03:15.000 -> 00:03:18.000
まず、リストからテーブルに切り替えます。

00:03:18.000 -> 00:03:21.000
テーブルはリストとは構造が異なります。

00:03:21.000 -> 00:03:26.000
ビュービルダーの代わりに、テーブルは列ビルダーを受け入れます。

00:03:26.000 -> 00:03:29.000
私が追加する最初の列は、その場所の名前です。

00:03:29.000 -> 00:03:35.000
列には、ヘッダーの名前と、コレクション内の各要素のビューを生成するためのビュービルダーが必要です。

00:03:35.000 -> 00:03:41.000
また、値キーパスも指定しました。これは、後でテーブルにソートを追加するときに重要になります。

00:03:41.000 -> 00:03:45.000
ビュービルダーがリストベースの構造とどれほど似ているかに注目してください。

00:03:45.000 -> 00:03:50.000
実際、以前からPlaceCellタイプを再利用することさえできます。

00:03:50.000 -> 00:04:00.000
コンパクトサイズのクラスでは、テーブルには最初の列しか表示されません。つまり、私のテーブルはiPhoneとiPadのスライドではまだ見栄えがします。

00:04:00.000 -> 00:04:03.000
これは外観のリストに似ていることに気付くかもしれません。

00:04:03.000 -> 00:04:12.000
しかし、テーブルをリストに置き換えただけではありません。テーブルを再利用すると、サイズクラス間を移行するときにスクロール位置と選択を維持できるからです。

00:04:12.000 -> 00:04:23.000
一般的に、コンパクトな特定の外観には最初の列を使用し、スライドオーバーなどのさまざまな環境でiPadアプリをテストしていることを確認してください。

00:04:23.000 -> 00:04:25.000
さて、次に進みます。

00:04:25.000 -> 00:04:28.000
快適さと騒音レベルのために列を追加します。

00:04:28.000 -> 00:04:36.000
テキストコンテンツのみの列の場合、TableColumnは、値が文字列を指すときにビュービルダーを省略できる便利なAPIを提供します。

00:04:36.000 -> 00:04:42.000
そして、この場合、私は快適さのレベルがあまりスペースを必要としないことを知っているので、私は固定幅を適用しました。

00:04:42.000 -> 00:04:45.000
コンパレータを使用してテーブルにソートを追加することもできます。

00:04:45.000 -> 00:04:48.000
コンパレータを格納するための状態を作成します。

00:04:48.000 -> 00:04:53.000
ここの状態は、テーブルのすべてのコンパレータを表すため、配列です。

00:04:53.000 -> 00:05:00.000
また、初期値を名前コンパレータに設定すると、テーブルが最初に表示されたときにソートされて表示されます。

00:05:00.000 -> 00:05:06.000
次に、私の状態へのバインディングをテーブルに渡して、すべてを配線します。

00:05:06.000 -> 00:05:12.000
列はそれぞれ、比較可能なフィールドへのキーパスとして値を指定しているため、デフォルトではソート可能です。

00:05:12.000 -> 00:05:18.000
そして今、テーブルは名前、快適レベル、騒音で完全に並べ替え可能です。

00:05:18.000 -> 00:05:20.000
テーブルは単独でソートを処理しないことに注意してください。

00:05:20.000 -> 00:05:22.000
それは私次第です。

00:05:22.000 -> 00:05:27.000
ソート順が変更されたときに、onChange修飾子を使用してデータをソートできます。

00:05:27.000 -> 00:05:30.000
よし、スピンしよう。"

00:05:30.000 -> 00:05:37.000
テーブルは素晴らしく、すべての場所のデータを表示し、本当に大きな画面を利用しています。

00:05:37.000 -> 00:05:43.000
Macとは異なり、iPadのテーブルは水平にスクロールしないので、列の数を制限することが重要です。

00:05:43.000 -> 00:05:47.000
これにより、すべての列を一度に表示できます。

00:05:47.000 -> 00:05:49.000
各列には、ヘッダーにラベルが表示されます。

00:05:49.000 -> 00:05:52.000
そして、ラベルをタップすると、その列が並べ替えます。

00:05:52.000 -> 00:05:57.000
騒音レベルで並べ替えることさえできます。

00:05:57.000 -> 00:06:03.000
そして、スライドオーバーでは、テーブルはより凝縮された形式ですべての情報を表す単一の列に折りたたまれます。

00:06:03.000 -> 00:06:07.000
リストをテーブルに更新したので、選択に飛び込みましょう。

00:06:07.000 -> 00:06:14.000
このセクションでは、SwiftUIの選択モデルを確認し、選択とメニューの統合について説明します。

00:06:14.000 -> 00:06:18.000
その過程で、私は豊富な機能で場所のテーブルを過給するつもりです。

00:06:18.000 -> 00:06:22.000
しかし、まず、SwiftUIでの選択がどのように機能するかについて話します。

00:06:22.000 -> 00:06:27.000
SwiftUIには、リストとテーブルの選択を管理するための堅牢なAPIが含まれています。

00:06:27.000 -> 00:06:30.000
これは、いくつかの行を含むリストを含む図です。

00:06:30.000 -> 00:06:32.000
各行にはタグがあります。

00:06:32.000 -> 00:06:37.000
これらのタグは、リストが選択を管理するのに役立つ各行の一意の値です。

00:06:37.000 -> 00:06:41.000
この図では、タグは緑色の円で示されています。

00:06:41.000 -> 00:06:45.000
タグに加えて、選択を保持する状態もあります。 選択を保持する状態もあります。

00:06:45.000 -> 00:06:48.000
これはタグの値を保持するタイプです。

00:06:48.000 -> 00:06:54.000
たとえば、複数選択では、これは選択した各行のタグを保持するセットです。

00:06:54.000 -> 00:06:58.000
リストの仕事は、各行のタグと選択状態の間で調整することです。

00:06:58.000 -> 00:07:02.000
そして、それはその選択バインディングを介してこれを行います。

00:07:02.000 -> 00:07:09.000
したがって、ここで2番目の行などの行が選択されると、リストは選択バインディングを介してセットに追加されます。

00:07:09.000 -> 00:07:20.000
同様に、アプリの他の部分がプログラムでセットを変更した場合、ここに示されているように3つを追加すると、選択バインディングが変更されるため、リストはそれを選択します。

00:07:20.000 -> 00:07:24.000
この一般的なモデルは、iOSとmacOSで同じです。

00:07:24.000 -> 00:07:29.000
したがって、選択にはタグと状態の2つの部分があります。

00:07:29.000 -> 00:07:32.000
次に、タグがどこから来るのかについて話したいと思います。

00:07:32.000 -> 00:07:40.000
タグは、そのビューが選択されているかどうかを追跡するために使用される、選択可能なコンテナ内のビューの値にすぎません。

00:07:40.000 -> 00:07:45.000
多くの場合、SwiftUIはあなたに代わってタグを自動的に合成することができます。

00:07:45.000 -> 00:07:49.000
タグは識別子に似ていますが、まったく同じではありません。

00:07:49.000 -> 00:07:55.000
ForEachを使用する場合、SwiftUIは明示的なアイデンティティからビューのタグを自動的に導き出します。

00:07:55.000 -> 00:08:00.000
また、テーブルは行値の識別子を選択タグとして使用します。

00:08:00.000 -> 00:08:04.000
場所アプリでは、場所構造体の識別子タイプが使用されることを意味します。

00:08:04.000 -> 00:08:11.000
明示的なアイデンティティの詳細については、「Demystify SwiftUI」をチェックしてください。

00:08:11.000 -> 00:08:14.000
ビューを手動でタグ付けするには、タグ修飾子を使用します。

00:08:14.000 -> 00:08:16.000
これはForEachがボンネットの下で行うことです。

00:08:16.000 -> 00:08:19.000
タグ修飾子はハッシュ可能な値を取ります。

00:08:19.000 -> 00:08:27.000
ただし、タグ修飾子を使用する場合は注意してください。選択可能なコンテナ内のすべてのビューが同じタグタイプを共有することが重要です。

00:08:27.000 -> 00:08:31.000
そうでなければ、SwiftUIはビューの選択方法を知らないかもしれません。

00:08:31.000 -> 00:08:35.000
ID修飾子を使用する場合、タグは設定されないことに注意してください。

00:08:35.000 -> 00:08:40.000
それがタグの概要です。先ほどの図を元に戻しましょう。

00:08:40.000 -> 00:08:47.000
この図のタグ部分を説明したので、選択方程式の残りの半分である選択状態に焦点を当てたいと思います。

00:08:47.000 -> 00:08:52.000
前の例では、セットを使用しましたが、他のオプションもあります。

00:08:52.000 -> 00:08:56.000
これらのデータ構造を使用して、選択を表すことができます。

00:08:56.000 -> 00:09:06.000
SwiftUIは、macOS Venturaの新機能、macOSサイドバーに必要な選択、および複数選択の単一選択をサポートしています。

00:09:06.000 -> 00:09:11.000
iPadOS 16では、軽量の複数選択も導入されています。

00:09:11.000 -> 00:09:18.000
これで、キーボードが取り付けられているので、複数の行を選択するために編集モードに入る必要はなく、モダリティを避けるのに役立ちます。

00:09:18.000 -> 00:09:24.000
キーボードを使用する場合は、シフトやコマンドなどの一般的なショートカットを使用して、選択範囲を拡張および変更できます。

00:09:24.000 -> 00:09:26.000
そして、これはポインタでうまく機能します。

00:09:26.000 -> 00:09:29.000
選択を採用した後の場所の表は次のようになります。

00:09:29.000 -> 00:09:36.000
この例では、キーボードとトラックパッドが接続されているため、行はインデントされていませんが、まだ選択されています。

00:09:36.000 -> 00:09:42.000
ただし、タッチを使用する場合は、2本指のパンを使用して加速される編集モードに入る必要があります。

00:09:42.000 -> 00:09:45.000
SwiftUIはこのジェスチャーを自動的にサポートしています。

00:09:45.000 -> 00:09:50.000
編集モードといえば、単一選択と編集モードのアップデートもあります。

00:09:50.000 -> 00:09:56.000
iOS 16では、iPhoneとiPadのリスト選択では、単一の行を選択するときに編集モードが不要になりました。

00:09:56.000 -> 00:10:01.000
そして、これは更新されたナビゲーションAPIとの調整に非常に便利です。

00:10:01.000 -> 00:10:08.000
これらすべての更新により、編集モードの新しい列を追加することで、前のテーブルに基づいて構築されたこのテーブルに至ります。

00:10:08.000 -> 00:10:12.000
編集モードは、キーボードなしで複数の選択を使用する場合にのみ必要です。

00:10:12.000 -> 00:10:16.000
それで、選択をサポートするために場所表を更新します。

00:10:16.000 -> 00:10:22.000
選択を格納する状態を追加することで、場所のテーブルに選択を簡単に追加できます。

00:10:22.000 -> 00:10:27.000
状態を作成したら、テーブルの初期化子にバインディングを渡します。

00:10:27.000 -> 00:10:34.000
テーブルは、その選択タイプが行識別子と一致することを強制するので、私は選択タイプとして場所IDタイプを使用しました。

00:10:34.000 -> 00:10:38.000
複数選択したいので、選択状態にセットを使用しました。

00:10:38.000 -> 00:10:44.000
テーブルは自動的に行にタグを付けるので、自分で何もタグを付ける必要はありません。

00:10:44.000 -> 00:10:46.000
そして今、私はテーブルの行を選択することができます。

00:10:46.000 -> 00:10:49.000
しかし、私は本当に選択で何もしていません。

00:10:49.000 -> 00:10:56.000
ブッククラブで他の人と共有できるガイドに選択した場所を追加できるボタンを追加するのは素晴らしいことだと思います。

00:10:56.000 -> 00:10:59.000
これはツールバーのボタンを追加するコードです。

00:10:59.000 -> 00:11:03.000
空でない選択がある場合、ボタンが表示されます。" ボタンが表示されます。

00:11:03.000 -> 00:11:12.000
また、既存の軽量選択サポートを補完する編集ボタンを追加しましたが、キーボードがないときに編集モードを開始および終了するアフォーダンスを提供します。

00:11:12.000 -> 00:11:21.000
優れたiPadアプリは、キーボードの有無にかかわらず輝くので、編集モードに出入りするためのコントロールを提供することが重要です。

00:11:21.000 -> 00:11:22.000
私たちはそこに着いてます。

00:11:22.000 -> 00:11:28.000
これで、行を選択すると表示されるボタンと、編集モードに出入りするボタンがあります。

00:11:28.000 -> 00:11:33.000
ツールバーの詳細については、このシリーズの2番目のセッションを必ずご覧ください。

00:11:33.000 -> 00:11:36.000
私はここのツールバーボタンにかなり満足していますが、私たちはもっとできます。

00:11:36.000 -> 00:11:41.000
選択に関するアクションについては、できるだけ簡単にアクセスできるようにしておくのは素晴らしい習慣です。

00:11:41.000 -> 00:11:50.000
そのため、iOS 16、iPadOS 16、macOS Venturaでは、SwiftUIが複数選択コンテキストメニューのサポートを追加しています。

00:11:50.000 -> 00:11:57.000
複数選択コンテキストメニューを使用すると、選択した識別子のセットで動作するコンテキストメニューを表示できます。

00:11:57.000 -> 00:12:02.000
もっと理解するために、この表の解剖学を調べてみましょう。

00:12:02.000 -> 00:12:05.000
アイテムベースのコンテキストメニューには3つのバリエーションがあります。

00:12:05.000 -> 00:12:10.000
まず、上部の選択など、複数の項目にメニューを表示できます。

00:12:10.000 -> 00:12:15.000
個々の項目にコンテキストメニューを表示することもできます。

00:12:15.000 -> 00:12:21.000
そして最後に、コンテンツがない空の領域にコンテキストメニューを表示できます。

00:12:21.000 -> 00:12:25.000
これのサポートを私たちの場所のテーブルに追加しましょう。

00:12:25.000 -> 00:12:30.000
前のコード例からいくつかの詳細を省略したので、コンテキストメニューに集中できます。

00:12:30.000 -> 00:12:34.000
選択タイプを取る新しいcontextMenu修飾子を追加しました。

00:12:34.000 -> 00:12:43.000
これはリストまたはテーブルの選択タイプと一致する必要があるので、テーブルを使用しているので、PlaceIDタイプを使用します。

00:12:43.000 -> 00:12:49.000
クロージャには、行動するアイテムのセットが渡されるので、それが空の場合、私はメニューが空の領域のためのものであることを知っています。

00:12:49.000 -> 00:12:52.000
新しい場所を追加するボタンは、空のエリアに最適だと思います。

00:12:52.000 -> 00:12:58.000
そうすれば、外出先で読むための新しい静かな場所を見つけたら、すぐに追加できます。

00:12:58.000 -> 00:13:05.000
空のアイテムセットのビュービルダーがビューに解決しない場合、SwiftUIは空の領域にメニューを表示しないことに注意してください。

00:13:05.000 -> 00:13:08.000
次に、単一の選択を処理しましょう。

00:13:08.000 -> 00:13:13.000
セットに1つのアイテムしかない場合、メニューが1つの場所に表示されていることを知っています。

00:13:13.000 -> 00:13:21.000
そして、単一選択と複数選択の両方で、これらの場所をガイドに追加できるようにしたいので、メニューに別のビューを追加します。

00:13:21.000 -> 00:13:23.000
進捗状況を確認しましょう。

00:13:23.000 -> 00:13:25.000
これが動作中の新しいコンテキストメニューサポートです。

00:13:25.000 -> 00:13:29.000
空の領域をクリックすると、新しい場所を追加するためのメニュー項目が表示されます。

00:13:29.000 -> 00:13:33.000
1つの行を選択すると、その行だけのコンテキストメニューが表示されます。

00:13:33.000 -> 00:13:38.000
そして、キーボードで選択範囲を拡張して、この青いハイライトを作成できます。

00:13:38.000 -> 00:13:45.000
その後、複数の行にわたってコンテキストメニューをアクティブにすることができ、ガイドに場所を簡単に追加できます。

00:13:45.000 -> 00:13:50.000
このテーブルは今かなりおしゃれに見えるので、その周りに構造を追加する時が来たと思います。

00:13:50.000 -> 00:13:52.000
これを行うには、スプリットビューが必要です。

00:13:52.000 -> 00:13:55.000
ナビゲーションはiPad体験の基本的な部分です。

00:13:55.000 -> 00:14:04.000
また、分割ビューは、ドリルインすることなく、より多くの情報を一度に表示することで、iPadの大きなディスプレイのモダリティを回避するのに最適な方法です。

00:14:04.000 -> 00:14:09.000
このセクションでは、ナビゲーションとスプリットビューに関するSwiftUIのアップデートについて説明します。

00:14:09.000 -> 00:14:16.000
前のセクションでは、場所のテーブルを作成し、選択モードや編集モードなどの豊富な機能を追加しました。

00:14:16.000 -> 00:14:18.000
しかし、場所アプリにはいくつかの構造が欠けていると思います。

00:14:18.000 -> 00:14:25.000
このセクションでは、ナビゲーションスプリットビューを活用して、アプリの構造の基盤を構築します。

00:14:25.000 -> 00:14:32.000
iPadOS 16とmacOS Venturaの新機能であるSwiftUIは、NavigationSplitViewタイプのスプリットビューのサポートを改善しました。

00:14:32.000 -> 00:14:41.000
SwiftUIは、2つまたは3つの列分割ビューをサポートし、列の表示方法を複雑に制御するための複数のスタイルを持っています。

00:14:41.000 -> 00:14:48.000
このセッションでナビゲーションコンテンツを提示する方法を完全にカバーするつもりはありませんので、そのために、ナビゲーションのためにSwiftUIクックブックをチェックしてください。

00:14:48.000 -> 00:14:53.000
カートは、いくつかの本当においしいナビゲーション体験を調理するためのかなりの数のレシピを持っています。

00:14:53.000 -> 00:14:56.000
代わりに、私は分割ビューにもっと集中するつもりです。

00:14:56.000 -> 00:15:00.000
これは、iPadの2列分割ビューを示す図です。

00:15:00.000 -> 00:15:07.000
SwiftUIでは、先頭の列はサイドバー列と呼ばれ、末尾の列は詳細列と呼ばれます。

00:15:07.000 -> 00:15:10.000
ここで列が隣同士でどのようにバランスが取れているかに注目してください。

00:15:10.000 -> 00:15:13.000
ランドスケープでは、SwiftUIはデフォルトでこれを提供します。

00:15:13.000 -> 00:15:19.000
ただし、ポートレートでは、サイドバーは邪魔にならないように隠れ、詳細列のみが表示されます。

00:15:19.000 -> 00:15:27.000
サイドバーボタンをタップすると、詳細列の上に表示されるサイドバーが表示され、その下に暗めます。

00:15:27.000 -> 00:15:37.000
一般的に、2列分割ビューは、スペースが制約されている場合に詳細列のみを表示することを好みます。詳細列は、サイドバー列よりも重要な情報を表示することが多いためです。

00:15:37.000 -> 00:15:48.000
この動作をカスタマイズしたい場合は、常に目立つ詳細ナビゲーションスプリットビュースタイルで詳細列を好むか、バランスの取れたNavigationSplitViewスタイルで重みのバランスをとることができます。

00:15:48.000 -> 00:15:53.000
NavigationSplitViewは、3つの列レイアウトもサポートしています。

00:15:53.000 -> 00:15:59.000
3つの列で、サイドバーと詳細の間にコンテンツ列と呼ばれる追加の列があります。

00:15:59.000 -> 00:16:02.000
UIKitから来ている場合は、これを補足列として知っているかもしれません。

00:16:02.000 -> 00:16:09.000
横向きでは、コンテンツと詳細の列が表示され、サイドバーを切り替えることができます。

00:16:09.000 -> 00:16:16.000
ツールバーボタンをタップすると、詳細列が邪魔にならないようにスライドし、サイドバーとコンテンツのためのスペースを作ります。

00:16:16.000 -> 00:16:23.000
縦向きでは、詳細列のみが表示され、ツールバーボタンをタップするとコンテンツが表示されます。

00:16:23.000 -> 00:16:26.000
そこから、もう一度タップするとサイドバーが表示されます。

00:16:26.000 -> 00:16:31.000
サイドバーとコンテンツの両方が詳細をオーバーレイします。

00:16:31.000 -> 00:16:40.000
一般的に、利用可能なスペースを最大限に活用し、より大きなディスプレイに特化しているため、3列分割ビューの自動スタイルに固執することをお勧めします。

00:16:40.000 -> 00:16:46.000
2列分割ビューと同様に、3列分割ビューはコンパクトなサイズのクラスでスタックに折りたたまれます。

00:16:46.000 -> 00:16:51.000
スプリットビューの基本をカバーしたので、プレイスアプリに追加する時が来ました。

00:16:51.000 -> 00:16:53.000
これがコンテンツビューです。

00:16:53.000 -> 00:16:56.000
ここに2つの列を持つNavigationSplitViewを作成しました。

00:16:56.000 -> 00:17:00.000
最初の列はサイドバーの列で、2番目の列は詳細列です。

00:17:00.000 -> 00:17:10.000
詳細列にはサイドバー列からのリンクが入力されますが、何も表示されない場合は、代わりに「場所を選択」のプレースホルダが表示されます。

00:17:10.000 -> 00:17:13.000
これはプレースホルダのスクリーンショットです。それはかなり素晴らしいです。

00:17:13.000 -> 00:17:20.000
これは、サイドバーを横向きに表示し、ポートレートで邪魔にならないように隠す自動スタイルを使用しています。

00:17:20.000 -> 00:17:24.000
サイドバーの行をタップすると、その行が詳細列に表示されます。

00:17:24.000 -> 00:17:28.000
また、スライドオーバーを使用すると、列は自動的に折りたたまれます。

00:17:28.000 -> 00:17:38.000
これは氷山の一角に過ぎません。状態回復のより良いサポート、ディープリンク、さらにはより豊かなプログラム制御など、非常に多くのエキサイティングなナビゲーションの追加があります。

00:17:38.000 -> 00:17:44.000
繰り返しになりますが、ナビゲーションクックブックセッションで詳細を確認することをお勧めします。

00:17:44.000 -> 00:17:50.000
私はアプリにいくつかの素晴らしいiPad機能を構築しました、そして私は読むためにいくつかの平和な場所を探しに行くことに興奮しています。

00:17:50.000 -> 00:17:53.000
うまくいけば、私はすぐに私のブッククラブに追いつくでしょう。

00:17:53.000 -> 00:18:05.000
このセッションでは、データの豊富な表示のためにテーブルを活用する方法、洗練された選択インタラクションを管理する方法、および分割ビューでモダリティを回避する方法を取り上げました。

00:18:05.000 -> 00:18:11.000
関連するセッションをチェックし、SwiftUIアプリを洗練して、iPadのパワーを活用してください。

00:18:11.000 -> 00:18:13.000
ありがとうございます。

00:18:13.000 -> 23:59:59.000
♪ ♪

