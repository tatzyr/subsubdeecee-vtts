WEBVTT

00:00:00.000 -> 00:00:09.000
♪ ♪

00:00:09.000 -> 00:00:13.000
Nick Kledzik: こんにちは、Appleのリンカーチームのリードエンジニア、Nick Kledzikです。

00:00:13.000 -> 00:00:16.000
今日は、速くリンクする方法を皆さんと共有したいと思います。

00:00:16.000 -> 00:00:25.000
Appleがリンクを改善するために何をしたかをお伝えします。また、アプリのリンクパフォーマンスを向上させるために、リンク中に実際に何が起こるかを理解するのに役立ちます。

00:00:25.000 -> 00:00:27.000
では、リンクとは何ですか?

00:00:27.000 -> 00:00:33.000
あなたはコードを書きましたが、他の誰かがライブラリやフレームワークの形で書いたコードも使用します。

00:00:33.000 -> 00:00:38.000
コードがこれらのライブラリを使用するには、リンカーが必要です。

00:00:38.000 -> 00:00:41.000
さて、実際には2種類のリンクがあります。

00:00:41.000 -> 00:00:44.000
アプリを構築するときに発生する「静的リンク」があります。

00:00:44.000 -> 00:00:50.000
これは、アプリの構築にかかる時間や、アプリの大きさに影響を与える可能性があります。

00:00:50.000 -> 00:00:52.000
そして、「ダイナミックリンク」があります。

00:00:52.000 -> 00:00:54.000
これは、アプリが起動したときに発生します。

00:00:54.000 -> 00:00:59.000
これは、顧客がアプリの起動を待たなければならない時間に影響を与える可能性があります。

00:00:59.000 -> 00:01:04.000
このセッションでは、静的リンクと動的リンクの両方について話します。

00:01:04.000 -> 00:01:10.000
まず、いくつかの例を挙げて、静的リンクとは何か、どこから来たのかを定義します。

00:01:10.000 -> 00:01:16.000
次に、Appleの静的リンカーであるld64の新機能を発表します。

00:01:16.000 -> 00:01:22.000
次に、静的リンクに関するこの背景で、静的リンクのベストプラクティスについて詳しく説明します。

00:01:22.000 -> 00:01:26.000
この講演の後半では、動的リンクについて説明します。

00:01:26.000 -> 00:01:32.000
動的リンクとは何か、どこから来たのか、動的リンク中に何が起こるかを示します。

00:01:32.000 -> 00:01:38.000
次に、今年のディルドの新機能を明らかにします。

00:01:38.000 -> 00:01:44.000
次に、アプリの動的リンク時間のパフォーマンスを向上させるために何ができるかについて話します。

00:01:44.000 -> 00:01:50.000
そして最後に、カーテンの後ろを覗くのに役立つ2つの新しいツールで締めくくります。

00:01:50.000 -> 00:01:57.000
バイナリに何があるか、動的リンク中に何が起こっているかを見ることができます。

00:01:57.000 -> 00:02:02.000
静的リンクを理解するために、すべてが始まったときに戻りましょう。

00:02:02.000 -> 00:02:06.000
当初、プログラムはシンプルで、ソースファイルは1つだけでした。

00:02:06.000 -> 00:02:08.000
建物は簡単でした。

00:02:08.000 -> 00:02:13.000
1つのソースファイルでコンパイラを実行しただけで、実行可能プログラムが生成されました。

00:02:13.000 -> 00:02:18.000
しかし、すべてのソースコードを1つのファイルにまとめることはスケールしませんでした。

00:02:18.000 -> 00:02:21.000
複数のソースファイルでどのように構築しますか?

00:02:21.000 -> 00:02:24.000
そして、これは大きなテキストファイルを編集したくないからだけではありません。

00:02:24.000 -> 00:02:29.000
本当の節約は、構築するたびにすべての機能を再コンパイルすることではありません。

00:02:29.000 -> 00:02:33.000
彼らがしたことは、コンパイラを2つの部分に分割することでした。

00:02:33.000 -> 00:02:39.000
最初の部分は、ソースコードを新しい中間「再配置可能なオブジェクト」ファイルにコンパイルします。

00:02:39.000 -> 00:02:45.000
2番目の部分は、再配置可能な.oファイルを読み取り、実行可能プログラムを生成します。

00:02:45.000 -> 00:02:49.000
私たちは今、第二部を「ld」、静的リンカーと呼んでいます。

00:02:49.000 -> 00:02:52.000
だから今、あなたは静的リンクがどこから来たのか知っています。

00:02:52.000 -> 00:02:56.000
ソフトウェアが進化するにつれて、すぐに人々は.oファイルを回していました。

00:02:56.000 -> 00:02:58.000
しかし、それは面倒になりました。

00:02:58.000 -> 00:03:04.000
誰かが「.oファイルのセットを「ライブラリ」にパッケージ化できたら素晴らしいと思いませんか?」と思いました。

00:03:04.000 -> 00:03:09.000
当時、ファイルをバンドルする標準的な方法は、アーカイブツール「ar」でした。

00:03:09.000 -> 00:03:12.000
バックアップと配布に使用されました。

00:03:12.000 -> 00:03:15.000
だから、ワークフローはこれになりました。

00:03:15.000 -> 00:03:25.000
複数の.oファイルをアーカイブに「ar」することができ、リンカーはアーカイブファイルから直接.oファイルを読み取る方法を知るために強化されました。

00:03:25.000 -> 00:03:28.000
これは、共通のコードを共有するための大きな改善でした。

00:03:28.000 -> 00:03:32.000
当時、それはちょうど図書館またはアーカイブと呼ばれていました。

00:03:32.000 -> 00:03:35.000
今日、私たちはそれを静的ライブラリと呼んでいます。

00:03:35.000 -> 00:03:44.000
しかし今、これらの関数のほんの一部しか使用されなかったとしても、これらのライブラリからの何千もの関数がそれにコピーされたため、最終的なプログラムは大きくなっていました。

00:03:44.000 -> 00:03:46.000
そこで、巧妙な最適化が追加されました。

00:03:46.000 -> 00:03:57.000
リンカーに静的ライブラリからすべての.oファイルを使用させる代わりに、リンカーは静的ライブラリから.oファイルを取得するだけで、未定義のシンボルが解決されます。

00:03:57.000 -> 00:04:05.000
それは、誰かがすべてのC標準ライブラリ関数を含む大きなlibc.a静的ライブラリを構築できることを意味しました。

00:04:05.000 -> 00:04:12.000
すべてのプログラムは1つのlibc.aとリンクできますが、各プログラムはプログラムが実際に必要とするlibcの部分しか得られませんでした。

00:04:12.000 -> 00:04:15.000
そして、私たちは今日もそのモデルを持っています。

00:04:15.000 -> 00:04:20.000
しかし、静的ライブラリからの選択的な読み込みは明らかではなく、多くのプログラマーをトリップします。

00:04:20.000 -> 00:04:26.000
静的ライブラリの選択的な読み込みを少し明確にするために、簡単なシナリオがあります。

00:04:26.000 -> 00:04:32.000
Main.cには、関数「foo」を呼び出す「main」という関数があります。

00:04:32.000 -> 00:04:36.000
Foo.cには、バーと呼ばれるfooがあります。

00:04:36.000 -> 00:04:45.000
Bar.cには、barの実装がありますが、たまたま未使用の別の関数の実装もあります。

00:04:45.000 -> 00:04:51.000
最後に、baz.cには、undefという名前の関数を呼び出す関数bazがあります。

00:04:51.000 -> 00:04:56.000
次に、それぞれを独自の.oファイルにコンパイルします。

00:04:56.000 -> 00:05:02.000
Foo、bar、undefは未定義であるため、灰色のボックスがないことがわかります。

00:05:02.000 -> 00:05:06.000
つまり、定義ではなくシンボルの使用です。

00:05:06.000 -> 00:05:12.000
さて、bar.oとbaz.oを静的ライブラリにまとめることに決めたとしましょう。

00:05:12.000 -> 00:05:16.000
次に、2つの.oファイルと静的ライブラリをリンクします。

00:05:16.000 -> 00:05:20.000
実際に何が起こるかをステップスルーしましょう。

00:05:20.000 -> 00:05:23.000
まず、リンカーはコマンドライン順にファイルを処理します。

00:05:23.000 -> 00:05:26.000
最初に見つけたのはmain.oです。

00:05:26.000 -> 00:05:31.000
Main.oをロードし、シンボルテーブルにここに示されている「メイン」の定義を見つけます。

00:05:31.000 -> 00:05:36.000
しかし、メインには未定義の「フー」があることもわかった。

00:05:36.000 -> 00:05:41.000
その後、リンカーはコマンドライン上の次のファイル（foo.o）を解析します。

00:05:41.000 -> 00:05:44.000
このファイルは「foo」の定義を追加します。

00:05:44.000 -> 00:05:47.000
つまり、fooはもはや未定義ではないということです。

00:05:47.000 -> 00:05:52.000
しかし、foo.oをロードすると、「bar」の新しい未定義のシンボルも追加されます。

00:05:52.000 -> 00:05:59.000
コマンドライン上のすべての.oファイルがロードされたので、リンカは未定義のシンボルが残っているかどうかをチェックします。

00:05:59.000 -> 00:06:10.000
この場合、「バー」は未定義のままであるため、リンカはコマンドラインでライブラリを見て、ライブラリが欠落している未定義のシンボル「バー」を満たすかどうかを確認します。

00:06:10.000 -> 00:06:16.000
リンカーは、静的ライブラリのbar.oがシンボル「bar」を定義していることを発見しました。

00:06:16.000 -> 00:06:20.000
そのため、リンカーはアーカイブからbar.oをロードします。

00:06:20.000 -> 00:06:26.000
その時点で、未定義のシンボルがなくなったため、リンカーはライブラリの処理を停止します。

00:06:26.000 -> 00:06:33.000
リンカーは次の段階に進み、プログラム内のすべての機能とデータにアドレスを割り当てます。

00:06:33.000 -> 00:06:38.000
次に、すべての機能とデータを出力ファイルにコピーします。

00:06:38.000 -> 00:06:40.000
出来上がり！あなたは出力プログラムを持っています。

00:06:40.000 -> 00:06:46.000
Baz.oは静的ライブラリにあったが、プログラムにロードされていないことに注意してください。

00:06:46.000 -> 00:06:52.000
リンカーが静的ライブラリから選択的にロードする方法のため、ロードされませんでした。

00:06:52.000 -> 00:06:56.000
これは明らかではありませんが、静的ライブラリの重要な側面です。

00:06:56.000 -> 00:07:00.000
これで、静的リンクと静的ライブラリの基本を理解できます。

00:07:00.000 -> 00:07:06.000
ld64として知られるAppleの静的リンカーの最近の改善に移りましょう。

00:07:06.000 -> 00:07:10.000
人気のある需要により、今年はld64の最適化に時間を費やしました。

00:07:10.000 -> 00:07:12.000
そして、今年のリンカーは...

00:07:12.000 -> 00:07:15.000
多くのプロジェクトで2倍の速さ。

00:07:15.000 -> 00:07:16.000
どうやってこれをやったの？

00:07:16.000 -> 00:07:21.000
私たちは今、あなたの開発マシンのコアをよりよく利用しています。

00:07:21.000 -> 00:07:25.000
複数のコアを使用してリンカー作業を並行して実行できる多くの分野を見つけました。

00:07:25.000 -> 00:07:40.000
これには、入力から出力ファイルへのコンテンツのコピー、LINKEDITのさまざまな部分を並行して構築すること、UUID計算の変更、および並行して行うハッシュの共同設計が含まれます。

00:07:40.000 -> 00:07:44.000
次に、多くのアルゴリズムを改善しました。

00:07:44.000 -> 00:07:53.000
各シンボルの文字列スライスを表すためにC ++ string_viewオブジェクトを使用するように切り替えると、exports-trieビルダーは本当にうまく機能することがわかりました。

00:07:53.000 -> 00:08:04.000
また、バイナリのUUIDを計算する際にハードウェアアクセラレーションを利用する最新の暗号ライブラリを使用し、他のアルゴリズムも改善しました。

00:08:04.000 -> 00:08:12.000
リンカーのパフォーマンスの向上に取り組んでいる間、リンク時間に影響を与えるいくつかのアプリで設定の問題に気づきました。

00:08:12.000 -> 00:08:17.000
次に、リンク時間を改善するためにプロジェクトで何ができるかについて話します。

00:08:17.000 -> 00:08:19.000
5つのトピックを取り上げます。

00:08:19.000 -> 00:08:22.000
まず、静的ライブラリを使用すべきかどうか。

00:08:22.000 -> 00:08:27.000
そして、リンク時間に大きな影響を与える3つのあまり知られていないオプション。

00:08:27.000 -> 00:08:32.000
最後に、あなたを驚かせるかもしれない静的リンクの動作について説明します。

00:08:32.000 -> 00:08:40.000
最初のトピックは、静的ライブラリにビルドされるソースファイルに積極的に取り組んでいる場合、ビルド時間の減速を導入したことです。

00:08:40.000 -> 00:08:47.000
ファイルがコンパイルされた後、目次を含め、静的ライブラリ全体を再構築する必要があります。

00:08:47.000 -> 00:08:50.000
これはちょうど多くの余分なI/Oです。

00:08:50.000 -> 00:08:53.000
静的ライブラリは、安定したコードに最も理にかなっています。

00:08:53.000 -> 00:08:56.000
つまり、コードは積極的に変更されていません。

00:08:56.000 -> 00:09:03.000
ビルド時間を短縮するために、静的ライブラリからアクティブな開発中のコードを移動することを検討する必要があります。

00:09:03.000 -> 00:09:06.000
先ほど、アーカイブからの選択的な読み込みを示しました。

00:09:06.000 -> 00:09:10.000
しかし、その欠点は、リンカーの速度を低下させることです。

00:09:10.000 -> 00:09:21.000
これは、ビルドを再現可能にし、従来の静的ライブラリのセマンティクスに従うために、リンカーは静的ライブラリを固定されたシリアルオーダーで処理しなければならないためです。

00:09:21.000 -> 00:09:26.000
つまり、ld64の並列化の勝利の一部は静的ライブラリでは使用できません。

00:09:26.000 -> 00:09:33.000
しかし、この歴史的な行動を本当に必要としない場合は、リンカーオプションを使用してビルドを高速化できます。

00:09:33.000 -> 00:09:37.000
そのリンカーオプションは「すべての負荷」と呼ばれます。

00:09:37.000 -> 00:09:42.000
リンカーに、すべての静的ライブラリからすべての.oファイルを盲目的に読み込むように指示します。

00:09:42.000 -> 00:09:49.000
これは、アプリがとにかくすべての静的ライブラリからほとんどのコンテンツを選択的に読み込む場合に役立ちます。

00:09:49.000 -> 00:09:55.000
-All_loadを使用すると、リンカーはすべての静的ライブラリとそのコンテンツを並行して解析できます。

00:09:55.000 -> 00:10:10.000
しかし、アプリが同じシンボルを実装する複数の静的ライブラリを持つ巧妙なトリックを行い、どの実装が使用されるかを駆動する静的ライブラリのコマンドラインの順序に依存する場合、このオプションはあなたのためではありません。

00:10:10.000 -> 00:10:18.000
リンカーはすべての実装をロードし、必ずしも通常の静的リンクモードで見つかったシンボルセマンティクスを取得するわけではないからです。

00:10:18.000 -> 00:10:26.000
-All_loadのもう1つの欠点は、「未使用の」コードが追加されているため、プログラムが大きくなる可能性があることです。

00:10:26.000 -> 00:10:31.000
それを補うために、リンカーオプション-dead_stripを使用できます。

00:10:31.000 -> 00:10:36.000
このオプションにより、リンカーは到達不能なコードとデータを削除します。

00:10:36.000 -> 00:10:42.000
現在、デッドストリッピングアルゴリズムは高速で、通常は出力ファイルのサイズを小さくすることで支払います。

00:10:42.000 -> 00:10:54.000
しかし、-all_loadと-dead_stripの使用に興味がある場合は、これらのオプションの有無にかかわらずリンカのタイミングをタイムして、特定のケースの勝利であるかどうかを確認する必要があります。

00:10:54.000 -> 00:10:58.000
次のリンカーオプションは-no_exported_symbolsです。

00:10:58.000 -> 00:11:00.000
ここに少し背景があります。

00:11:00.000 -> 00:11:10.000
リンカーが生成するLINKEDITセグメントの一部は、エクスポートトリエです。これは、エクスポートされたすべてのシンボル名、アドレス、フラグをエンコードするプレフィックスツリーです。

00:11:10.000 -> 00:11:18.000
すべてのdylibsはエクスポートされたシンボルを持っている必要がありますが、メインアプリのバイナリは通常、エクスポートされたシンボルを必要としません。

00:11:18.000 -> 00:11:23.000
つまり、通常、メイン実行可能ファイルでシンボルを調べるものは何もありません。

00:11:23.000 -> 00:11:33.000
その場合は、アプリターゲットに-no_exported_symbolsを使用して、LINKEDITでのトライデータ構造の作成をスキップできます。これにより、リンク時間が改善されます。

00:11:33.000 -> 00:11:51.000
しかし、アプリがメイン実行可能ファイルにリンクするプラグインをロードする場合、またはxctestバンドルを実行するためのホスト環境としてアプリでxctestを使用する場合、アプリにはすべてのエクスポートが必要です。つまり、その設定に-no_exported_symbolsを使用することはできません。

00:11:51.000 -> 00:11:55.000
今、それが大きい場合にのみ、輸出を抑制しようとすることは理にかなっています。

00:11:55.000 -> 00:12:00.000
ここに表示されているdyld_infoコマンドを実行して、エクスポートされたシンボルの数を数えることができます。

00:12:00.000 -> 00:12:04.000
私たちが見た1つの大きなアプリには、約100万のシンボルがエクスポートされていました。

00:12:04.000 -> 00:12:09.000
そして、リンカーは、その多くのシンボルのエクスポートトライを構築するのに2〜3秒かかりました。

00:12:09.000 -> 00:12:14.000
したがって、-no_exported_symbolsを追加すると、そのアプリのリンク時間が2〜3秒短縮されました。

00:12:14.000 -> 00:12:18.000
Dyld_infoツールについては、この講演の後半で詳しく説明します。

00:12:18.000 -> 00:12:23.000
次のオプションは、-no_deduplicateです。

00:12:23.000 -> 00:12:29.000
数年前、同じ命令を持つが異なる名前を持つ関数をマージするために、リンカーに新しいパスを追加しました。

00:12:29.000 -> 00:12:33.000
C++テンプレートの拡張では、それらの多くを得ることができることがわかりました。

00:12:33.000 -> 00:12:36.000
しかし、これは高価なアルゴリズムです。

00:12:36.000 -> 00:12:42.000
リンカーは、重複を探すのを助けるために、すべての関数の命令を再帰的にハッシュしなければなりません。

00:12:42.000 -> 00:12:48.000
費用のため、アルゴリズムを制限したので、リンカーは弱い定義のシンボルだけを見ます。

00:12:48.000 -> 00:12:54.000
これらは、インライン化されていないテンプレート拡張用にC++コンパイラが発行するものです。

00:12:54.000 -> 00:13:01.000
さて、de-dupはサイズの最適化であり、デバッグビルドは高速ビルドに関するものであり、サイズに関するものではありません。

00:13:01.000 -> 00:13:11.000
したがって、デフォルトでは、Xcodeはデバッグ設定のリンカに-no_deduplicateを渡すことで、de-dup最適化を無効にします。

00:13:11.000 -> 00:13:19.000
また、-O0でclangリンクラインを実行すると、clangはno-dedupオプションをリンカに渡します。

00:13:19.000 -> 00:13:36.000
要約すると、C ++を使用してカスタムビルドを使用している場合、つまり、Xcodeで非標準構成を使用するか、他のビルドシステムを使用する場合は、デバッグビルドに-no_deduplicateを追加して、リンク時間を改善する必要があります。

00:13:36.000 -> 00:13:40.000
先ほどお話ししたオプションは、実際のコマンドライン引数です。

00:13:40.000 -> 00:13:44.000
Xcodeを使用する場合は、製品のビルド設定を変更する必要があります。

00:13:44.000 -> 00:13:49.000
ビルド設定内で、「その他のリンカーフラグ」を探します。

00:13:49.000 -> 00:13:52.000
-All_loadに設定するものは次のとおりです。

00:13:52.000 -> 00:13:56.000
そして、「デッドコードストリッピング」オプションもここにあることに注意してください。

00:13:56.000 -> 00:13:58.000
そして、-no_exported_symbolsがあります。

00:13:58.000 -> 00:14:03.000
そして、ここに-no_deduplicateがあります。

00:14:03.000 -> 00:14:07.000
それでは、静的ライブラリを使用する際に経験するかもしれないいくつかの驚きについて話しましょう。

00:14:07.000 -> 00:14:16.000
最初の驚きは、アプリがリンクする静的ライブラリにビルドされるソースコードがあり、そのコードが最終的なアプリに終わらない場合です。

00:14:16.000 -> 00:14:22.000
たとえば、ある関数に「使用される属性」を追加したり、Objective-Cカテゴリがあります。

00:14:22.000 -> 00:14:35.000
リンカーが選択的にロードするため、静的ライブラリ内のオブジェクトファイルがリンク中に必要なシンボルも定義しない場合、それらのオブジェクトファイルはリンカーによってロードされません。

00:14:35.000 -> 00:14:40.000
もう1つの興味深い相互作用は、静的ライブラリとデッドストリッピングです。

00:14:40.000 -> 00:14:44.000
デッドストリッピングは、多くの静的ライブラリの問題を隠すことができることが判明しました。

00:14:44.000 -> 00:14:50.000
通常、シンボルが欠落したり、シンボルが重複したりすると、リンカーがエラーになります。

00:14:50.000 -> 00:15:05.000
しかし、デッドストリッピングにより、リンカーはメインから開始してすべてのコードとデータに到達可能性パスを実行し、不足しているシンボルが到達不能なコードからのものであることが判明した場合、リンカーは不足しているシンボルエラーを抑制します。

00:15:05.000 -> 00:15:13.000
同様に、静的ライブラリから重複したシンボルがある場合、リンカーはエラーではなく最初のシンボルを選択します。

00:15:13.000 -> 00:15:20.000
静的ライブラリを使用する最後の大きな驚きは、静的ライブラリが複数のフレームワークに組み込まれている場合です。

00:15:20.000 -> 00:15:32.000
これらのフレームワークのそれぞれは単独で正常に動作しますが、ある時点で、いくつかのアプリは両方のフレームワークを使用し、ブーム、複数の定義のために奇妙なランタイムの問題が発生します。

00:15:32.000 -> 00:15:39.000
最も一般的なケースは、同じクラス名の複数のインスタンスに関するObjective-Cランタイム警告です。

00:15:39.000 -> 00:15:45.000
全体として、静的ライブラリは強力ですが、落とし穴を避けるためにそれらを理解する必要があります。

00:15:45.000 -> 00:15:47.000
それは静的リンクを締めくくります。

00:15:47.000 -> 00:15:51.000
では、ダイナミックリンクに移りましょう。

00:15:51.000 -> 00:15:56.000
まず、静的ライブラリとの静的リンクの元の図を見てみましょう。

00:15:56.000 -> 00:16:02.000
ソースコードが増えているので、これが時間の経過とともにどのように拡大するかを考えてください。

00:16:02.000 -> 00:16:09.000
ますます多くのライブラリが利用可能になるにつれて、エンドプログラムのサイズが大きくなる可能性があることは明らかです。

00:16:09.000 -> 00:16:14.000
つまり、そのプログラムを構築するための静的リンク時間も時間の経過とともに増加するということです。

00:16:14.000 -> 00:16:18.000
では、これらのライブラリがどのように作られているかを見てみましょう。

00:16:18.000 -> 00:16:21.000
もし私たちがこのスイッチをしたらどうなりますか?

00:16:21.000 -> 00:16:27.000
「Ar」を「ld」に変更すると、出力ライブラリは実行可能なバイナリになりました。

00:16:27.000 -> 00:16:31.000
これは90年代の動的ライブラリの始まりでした。

00:16:31.000 -> 00:16:34.000
略語として、動的ライブラリを「dylibs」と呼びます。

00:16:34.000 -> 00:16:38.000
他のプラットフォームでは、それらはDSOまたはDLLとして知られています。

00:16:38.000 -> 00:16:41.000
では、ここで正確に何が起こっているのですか?

00:16:41.000 -> 00:16:44.000
そして、それはスケーラビリティにどのように役立ちますか?

00:16:44.000 -> 00:16:49.000
重要なのは、静的リンカが動的ライブラリとのリンクを異なる方法で扱うことです。

00:16:49.000 -> 00:16:56.000
ライブラリから最終的なプログラムにコードをコピーする代わりに、リンカーは一種の約束を記録するだけです。

00:16:56.000 -> 00:17:03.000
つまり、動的ライブラリから使用されるシンボル名と、実行時にライブラリのパスがどうなるかを記録します。

00:17:03.000 -> 00:17:05.000
これはどのように利点ですか?

00:17:05.000 -> 00:17:08.000
これは、プログラムのファイルサイズが管理下にあることを意味します。

00:17:08.000 -> 00:17:13.000
コードと、実行時に必要な動的ライブラリのリストが含まれているだけです。

00:17:13.000 -> 00:17:16.000
プログラムでライブラリコードのコピーを取得しなくなりました。

00:17:16.000 -> 00:17:24.000
プログラムの静的リンク時間は、コードのサイズに比例し、リンクするディリブの数とは無関係になります。

00:17:24.000 -> 00:17:27.000
また、仮想メモリシステムが輝くようになりました。

00:17:27.000 -> 00:17:37.000
複数のプロセスで使用されているのと同じ動的ライブラリを見ると、仮想メモリシステムは、そのdylibを使用するすべてのプロセスで、そのdylibに対して同じ物理ページのRAMを再利用します。

00:17:37.000 -> 00:17:42.000
動的ライブラリがどのように始まり、どのような問題を解決するかをお見せしました。

00:17:42.000 -> 00:17:46.000
しかし、それらの「利益」の「コスト」は何ですか?

00:17:46.000 -> 00:17:51.000
まず、動的ライブラリを使用する利点は、ビルド時間を高速化することです。

00:17:51.000 -> 00:17:54.000
しかし、コストは、アプリの起動が遅くなるということです。

00:17:54.000 -> 00:17:59.000
これは、起動がもはや1つのプログラムファイルを読み込むだけではないためです。

00:17:59.000 -> 00:18:03.000
これで、すべてのディリブも一緒にロードして接続する必要があります。

00:18:03.000 -> 00:18:08.000
言い換えれば、ビルド時間から起動時間まで、リンクコストの一部を延期しただけです。

00:18:08.000 -> 00:18:13.000
第二に、動的ライブラリベースのプログラムには、より汚いページがあります。

00:18:13.000 -> 00:18:22.000
静的ライブラリの場合、リンカはすべての静的ライブラリからすべてのグローバルをメイン実行可能ファイルの同じDATAページに共同配置します。

00:18:22.000 -> 00:18:26.000
しかし、dylibsでは、各ライブラリにはDATAページがあります。

00:18:26.000 -> 00:18:33.000
最後に、動的リンクのもう一つのコストは、それが何か新しいものの必要性を導入することです:動的リンカー!

00:18:33.000 -> 00:18:37.000
ビルド時に実行可能ファイルに記録された約束を覚えていますか？

00:18:37.000 -> 00:18:44.000
今、私たちはライブラリをロードするという約束を果たすランタイムで何かが必要です。

00:18:44.000 -> 00:18:48.000
ダイナミックリンカーであるdyldはそのためです。

00:18:48.000 -> 00:18:52.000
実行時に動的リンクがどのように機能するかを掘り下げてみましょう。

00:18:52.000 -> 00:18:59.000
実行可能なバイナリはセグメント、通常は少なくともTEXT、DATA、LINKEDITに分割されます。

00:18:59.000 -> 00:19:03.000
セグメントは常にOSのページサイズの倍数です。

00:19:03.000 -> 00:19:05.000
各セグメントには異なる権限があります。

00:19:05.000 -> 00:19:09.000
たとえば、TEXTセグメントには「実行」権限があります。

00:19:09.000 -> 00:19:14.000
つまり、CPUはページ上のバイトをマシンコード命令として扱う可能性があります。

00:19:14.000 -> 00:19:22.000
実行時に、dyldはここで示すように、各セグメントの権限を持つメモリに実行可能ファイルをmmap（）しなければなりません。

00:19:22.000 -> 00:19:33.000
セグメントはページサイズでページが整列されているため、仮想メモリシステムはプログラムまたはdylibファイルをVM範囲のバッキングストアとして簡単に設定できます。

00:19:33.000 -> 00:19:48.000
つまり、これらのページにメモリアクセスがあるまで、何もRAMにロードされません。これにより、ページ障害が発生し、VMシステムがファイルの適切なサブレンジを読み取り、必要なRAMページにその内容を埋めます。

00:19:48.000 -> 00:19:50.000
しかし、マッピングだけでは不十分です。

00:19:50.000 -> 00:19:55.000
どういうわけか、プログラムは「配線」されているか、dylibにバインドされている必要があります。

00:19:55.000 -> 00:19:58.000
そのために、私たちは「フィックスアップ」と呼ばれる概念を持っています。

00:19:58.000 -> 00:20:04.000
図では、プログラムが使用するディリブの部分にそのポイントを設定したポインタを持っていることがわかります。

00:20:04.000 -> 00:20:07.000
フィックスアップとは何かを掘り下げてみましょう。

00:20:07.000 -> 00:20:10.000
これが私たちの友人、mach-oファイルです。

00:20:10.000 -> 00:20:11.000
さて、テキストは不変です。

00:20:11.000 -> 00:20:15.000
そして実際、それはコード署名に基づくシステムにある必要があります。

00:20:15.000 -> 00:20:18.000
では、malloc()を呼び出す関数がある場合はどうなりますか?

00:20:18.000 -> 00:20:20.000
それはどのように機能しますか?

00:20:20.000 -> 00:20:24.000
_Mallocの相対アドレスは、プログラムがいつ構築されたかを知ることができません。

00:20:24.000 -> 00:20:31.000
さて、何が起こるかというと、静的リンカーはmallocがdylibにあるのを見て、コールサイトを変換しました。

00:20:31.000 -> 00:20:45.000
コールサイトは、同じTEXTセグメント内のリンカーによって合成されたスタブへの呼び出しになるため、相対アドレスはビルド時に知られているため、BL命令を正しく形成できます。

00:20:45.000 -> 00:20:51.000
それが役立つのは、スタブがDATAからポインタをロードし、その場所にジャンプすることです。

00:20:51.000 -> 00:20:57.000
現在、実行時にTEXTの変更は必要ありません。DATAだけがdyldによって変更されます。

00:20:57.000 -> 00:21:07.000
実際、dyldを理解する秘訣は、dyldによって行われるすべての修正は、DATAにポインタを設定するだけです。

00:21:07.000 -> 00:21:10.000
だから、ディルドが行う修正をもっと掘り下げてみましょう。

00:21:10.000 -> 00:21:16.000
LINKEDITのどこかには、どのような修正が行われるかを推進するために必要な情報があります。

00:21:16.000 -> 00:21:19.000
修正には2種類あります。

00:21:19.000 -> 00:21:25.000
1つ目はリベースと呼ばれ、ディリブまたはアプリがそれ自体内を指すポインタを持っているときです。

00:21:25.000 -> 00:21:33.000
現在、ASLRと呼ばれるセキュリティ機能があり、dyldはランダムなアドレスでdylibsをロードします。

00:21:33.000 -> 00:21:38.000
そして、それは、これらの内部ポインタがビルド時に設定できないことを意味します。

00:21:38.000 -> 00:21:44.000
代わりに、dyldは起動時にこれらのポインタを調整または「リベース」する必要があります。

00:21:44.000 -> 00:21:51.000
ディスク上では、dylibがアドレスゼロでロードされた場合、これらのポインタにはターゲットアドレスが含まれています。

00:21:51.000 -> 00:21:56.000
そうすれば、LINKEDITが記録する必要があるのは、各リベース場所の場所だけです。

00:21:56.000 -> 00:22:06.000
Dyldは、ディリブの実際のロードアドレスを各リベース場所に追加するだけで、正しく修正できます。

00:22:06.000 -> 00:22:08.000
2番目の種類のフィックスアップはバインドです。

00:22:08.000 -> 00:22:11.000
バインドは象徴的な参照です。

00:22:11.000 -> 00:22:15.000
つまり、彼らのターゲットは数字ではなくシンボル名です。

00:22:15.000 -> 00:22:18.000
例えば、関数「malloc」へのポインタ。

00:22:18.000 -> 00:22:31.000
文字列「_malloc」は実際にはLINKEDITに格納され、dyldはその文字列を使用してlibSystem.dylibのエクスポートトリでmallocの実際のアドレスを検索します。

00:22:31.000 -> 00:22:37.000
次に、dyldはその値をバインドで指定された場所に格納します。

00:22:37.000 -> 00:22:44.000
今年は、私たちが「チェーンフィックスアップ」と呼ぶフィックスアップをエンコードする新しい方法を発表します。

00:22:44.000 -> 00:22:47.000
最初の利点は、LINKEDITを小さくすることです。

00:22:47.000 -> 00:23:00.000
LINKEDITは、すべての修正場所を保存する代わりに、新しい形式は、最初の修正場所が各DATAページにある場所と、インポートされたシンボルのリストのみを保存するため、より小さいです。

00:23:00.000 -> 00:23:08.000
その後、残りの情報は、修正が最終的に設定される場所で、DATAセグメント自体にエンコードされます。

00:23:08.000 -> 00:23:16.000
この新しいフォーマットは、修正場所が一緒に「鎖でつながれている」という事実から、チェーン固定と呼ばれる名前を取得します。

00:23:16.000 -> 00:23:28.000
LINKEDITは、最初の修正がどこにあったかを述べ、次にDATAの64ビットポインタの場所で、一部のビットには次の修正場所へのオフセットが含まれています。

00:23:28.000 -> 00:23:33.000
また、フィックスアップがバインドまたはリベースであるかどうかというビットが詰め込まれています。

00:23:33.000 -> 00:23:37.000
バインドの場合、残りのビットはシンボルのインデックスです。

00:23:37.000 -> 00:23:44.000
リベースの場合、残りのビットは画像内のターゲットのオフセットです。

00:23:44.000 -> 00:23:49.000
最後に、連鎖修正のランタイムサポートは、iOS 13.4以降にはすでに存在します。

00:23:49.000 -> 00:23:57.000
つまり、展開ターゲットがiOS 13.4以降である限り、今日からこの新しいフォーマットを使い始めることができます。

00:23:57.000 -> 00:24:02.000
そして、連鎖修正フォーマットは、今年発表する新しいOS機能を可能にします。

00:24:02.000 -> 00:24:08.000
しかし、それを理解するために、私はディルドがどのように機能するかについて話す必要があります。

00:24:08.000 -> 00:24:11.000
Dyldはメインの実行可能ファイルで始まります - あなたのアプリを言ってください。

00:24:11.000 -> 00:24:18.000
そのmach-oを解析して、依存するディリブ、つまり必要な約束された動的ライブラリを見つけます。

00:24:18.000 -> 00:24:21.000
それはそれらのdylibsとmmap()sを見つけます。

00:24:21.000 -> 00:24:30.000
次に、それらのそれぞれについて、mach-o構造を再帰して解析し、必要に応じて追加のディリブをロードします。

00:24:30.000 -> 00:24:37.000
すべてが読み込まれると、dyldは必要なすべてのバインドシンボルを調べ、修正を行うときにそれらのアドレスを使用します。

00:24:37.000 -> 00:24:44.000
最後に、すべての修正が完了すると、dyldはボトムアップで初期化子を実行します。

00:24:44.000 -> 00:24:47.000
5年前、私たちは新しいdyld技術を発表しました。

00:24:47.000 -> 00:24:53.000
上記の緑色のステップは、アプリが起動するたびに同じであることに気づきました。

00:24:53.000 -> 00:25:02.000
したがって、プログラムとdylibsが変更されない限り、緑色のすべてのステップは最初の起動時にキャッシュされ、その後の起動時に再利用される可能性があります。

00:25:02.000 -> 00:25:07.000
今年は、追加のディルドパフォーマンスの改善を発表します。

00:25:07.000 -> 00:25:12.000
「ページインリンク」と呼ばれる新しいdyld機能を発表します。

00:25:12.000 -> 00:25:23.000
起動時にすべてのディリブにすべてのフィックスアップを適用する代わりに、カーネルはページインでデータページに遅延してフィックスアップを適用できるようになりました。

00:25:23.000 -> 00:25:31.000
Mmap()ed領域のあるページでいくつかのアドレスを最初に使用すると、そのページでカーネルが読み込まれることは常にありました。

00:25:31.000 -> 00:25:38.000
しかし、今、それがデータページである場合、カーネルはそのページに必要な修正も適用します。

00:25:38.000 -> 00:25:45.000
dyld共有キャッシュのOS dylibsの10年以上にわたってページインリンクの特別なケースがありました。

00:25:45.000 -> 00:25:49.000
今年はそれを一般化し、誰もが利用できるようにしました。

00:25:49.000 -> 00:25:53.000
このメカニズムは、汚れたメモリと起動時間を短縮します。

00:25:53.000 -> 00:26:02.000
また、DATA_CONSTページがクリーンであることを意味し、TEXTページと同じように立ち退かして再作成できるため、メモリの圧力が軽減されます。

00:26:02.000 -> 00:26:09.000
このページインリンク機能は、iOS、macOS、watchOSの今後のリリースで行われます。

00:26:09.000 -> 00:26:13.000
しかし、ページインリンクは、チェーン付きフィックスアップで構築されたバイナリでのみ機能します。

00:26:13.000 -> 00:26:23.000
これは、チェーン化されたフィックスアップでは、ほとんどのフィックスアップ情報がディスク上のDATAセグメントにエンコードされるため、ページイン中にカーネルで利用できるためです。

00:26:23.000 -> 00:26:28.000
1つの注意点は、dyldは打ち上げ時にのみこのメカニズムを使用することです。

00:26:28.000 -> 00:26:32.000
後でdlopen（）されたdylibsは、ページインリンクを取得しません。

00:26:32.000 -> 00:26:38.000
その場合、dyldは従来のパスを取り、dlopenコール中にフィックスアップを適用します。

00:26:38.000 -> 00:26:43.000
それを念頭に置いて、dyldワークフロー図に戻りましょう。

00:26:43.000 -> 00:26:52.000
5年間、dyldは最初の打ち上げでその作業をキャッシュし、後の打ち上げで再利用することで、上記の手順を緑色で最適化してきました。

00:26:52.000 -> 00:27:03.000
今、dyldは、実際にフィックスアップを実行せず、カーネルにページインで怠惰に実行させることで、「修正を適用する」ステップを最適化することができます。

00:27:03.000 -> 00:27:11.000
Dyldの新機能を見たので、ダイナミックリンクのベストプラクティスについて話しましょう。

00:27:11.000 -> 00:27:14.000
ダイナミックリンクのパフォーマンスを向上させるために何ができますか?

00:27:14.000 -> 00:27:20.000
先ほど示したように、dyldはすでに動的リンクのほとんどのステップを加速しています。

00:27:20.000 -> 00:27:24.000
あなたがコントロールできることの1つは、あなたが持っているディリブの数です。

00:27:24.000 -> 00:27:28.000
Dylibsが多ければ多いほど、それらをロードするためにdyldがしなければならない作業が増えます。

00:27:28.000 -> 00:27:33.000
逆に、ディリブが少ないほど、ディルドが実行しなければならない作業は少なくなります。

00:27:33.000 -> 00:27:39.000
次に見ることができるのは、静的初期化子です。これは、常に実行されるコードです。

00:27:39.000 -> 00:27:44.000
たとえば、静的初期化子でI/Oやネットワーキングを行わないでください。

00:27:44.000 -> 00:27:49.000
数ミリ秒以上かかる可能性のあるものは、初期化子で行うべきではありません。

00:27:49.000 -> 00:27:54.000
ご存知のように、世界はますます複雑になり、ユーザーはより多くの機能を望んでいます。

00:27:54.000 -> 00:27:59.000
したがって、ライブラリを使用してすべての機能を管理することは理にかなっています。

00:27:59.000 -> 00:28:04.000
あなたの目標は、動的ライブラリと静的ライブラリの間のスイートスポットを見つけることです。

00:28:04.000 -> 00:28:09.000
静的ライブラリが多すぎて、反復的なビルド/デバッグサイクルが遅くなります。

00:28:09.000 -> 00:28:15.000
一方、動的ライブラリが多すぎて起動時間が遅く、顧客は気づきます。

00:28:15.000 -> 00:28:28.000
しかし、今年はld64をスピードアップしたので、より多くの静的ライブラリ、またはより多くのソースファイルをアプリで直接使用し、同じ時間でビルドできるため、スイートスポットが変わった可能性があります。

00:28:28.000 -> 00:28:39.000
最後に、インストールベースで機能する場合、新しい展開ターゲットに更新すると、チェーン化された修正を生成し、バイナリを小さくし、起動時間を短縮できます。

00:28:39.000 -> 00:28:47.000
最後に皆さんに知ってもらいたいのは、リンクプロセスの中を覗くのに役立つ2つの新しいツールです。

00:28:47.000 -> 00:28:49.000
最初のツールはdyld_usageです。

00:28:49.000 -> 00:28:53.000
あなたはそれを使って、ディルドが何をしているかの痕跡を得ることができます。

00:28:53.000 -> 00:29:03.000
このツールはmacOSのみですが、シミュレーターでのアプリの起動、またはMac Catalyst用に構築されたアプリを追跡するために使用できます。

00:29:03.000 -> 00:29:08.000
これは、macOSのテキストエディットに対する実行例です。

00:29:08.000 -> 00:29:18.000
上位数行からわかるように、打ち上げは全体で15msかかりましたが、ページインリンクのおかげで、修正には1msしかかかりませんでした。

00:29:18.000 -> 00:29:23.000
現在、大部分の時間は静的初期化子に費やされています。

00:29:23.000 -> 00:29:26.000
次のツールはdyld_infoです。

00:29:26.000 -> 00:29:31.000
ディスクと現在のディルドキャッシュの両方でバイナリを検査するために使用できます。

00:29:31.000 -> 00:29:36.000
このツールには多くのオプションがありますが、エクスポートと修正を表示する方法を紹介します。

00:29:36.000 -> 00:29:43.000
ここで、-fixupオプションは、dyldが処理するすべての修正場所とそのターゲットを表示します。

00:29:43.000 -> 00:29:50.000
ファイルが古いスタイルの修正か新しいチェーン修正かに関係なく、出力は同じです。

00:29:50.000 -> 00:30:00.000
ここで、-exportsオプションは、dylibにエクスポートされたすべてのシンボルと、dylibの先頭から各シンボルのオフセットを表示します。

00:30:00.000 -> 00:30:07.000
この場合、dyldキャッシュのdylibであるFoundation.frameworkに関する情報が表示されています。

00:30:07.000 -> 00:30:15.000
ディスクにファイルはありませんが、dyld_infoツールはdyldと同じコードを使用しているため、それを見つけることができます。

00:30:15.000 -> 00:30:25.000
静的ライブラリと動的ライブラリの歴史とトレードオフを理解したので、アプリが何をするかを確認し、スイートスポットを見つけたかどうかを判断する必要があります。

00:30:25.000 -> 00:30:35.000
次に、大きなアプリを持っていて、ビルドがリンクするのに時間がかかることに気づいたら、新しいより高速なリンカーを備えたXcode 14を試してみてください。

00:30:35.000 -> 00:30:45.000
それでも静的リンクをさらに高速化したい場合は、私が詳述した3つのリンカーオプションを調べて、ビルドで理にかなっているかどうかを確認し、リンク時間を改善してください。

00:30:45.000 -> 00:30:54.000
最後に、iOS 13.4以降のアプリと埋め込みフレームワークを構築して、連鎖修正を有効にすることもできます。

00:30:54.000 -> 00:30:58.000
次に、iOS 16でアプリが小さく、より速く起動するかどうかを確認します。

00:30:58.000 -> 23:59:59.000
見てくれてありがとう、そして素晴らしいWWDCをお過ごしください。

