WEBVTT

00:00:00.000 -> 00:00:03.000
♪インストゥルメンタルヒップホップ音楽♪

00:00:03.000 -> 00:00:09.000
♪

00:00:09.000 -> 00:00:12.000
「AppKitでSwiftUIを使用する」へようこそ。

00:00:12.000 -> 00:00:16.000
私はショートカットに取り組んでいるエンジニアのイアンです。

00:00:16.000 -> 00:00:20.000
macOS Montereyでは、ショートカットがmacOSに登場しました。

00:00:20.000 -> 00:00:23.000
ショートカットはMacで多くのSwiftUIを使用します。

00:00:23.000 -> 00:00:31.000
SwiftUIは、iOSとwatchOSのアプリと共通のビューを共有しながら、プラットフォームのエクスペリエンスをカスタマイズするのに役立ちます。

00:00:31.000 -> 00:00:40.000
このビデオでは、ショートカットのいくつかの例を見て、MacアプリにSwiftUIを採用し始める方法を紹介します。

00:00:40.000 -> 00:00:50.000
まず、アプリでSwiftUIビューをホストする方法の例を紹介し、AppKitとSwiftUIの間でデータを渡す方法について説明します。

00:00:50.000 -> 00:01:12.000
また、コレクションまたはテーブルビューのセルでSwiftUIビューをホストする方法、AppKitに埋め込まれたときにSwiftUIビューのレイアウトとサイジングを処理する方法、SwiftUIビューをレスポンダーチェーンに参加させ、フォーカスできるようにする方法、そして最後に、SwiftUIでAppKitビューをホストする方法についても説明します。

00:01:12.000 -> 00:01:16.000
さて、AppKitでSwiftUIをホストする方法から始めます。

00:01:16.000 -> 00:01:28.000
ショートカットでは、メインウィンドウにはAppKit分割ビューコントローラーが含まれており、左側のサイドバーはSwiftUIを使用して書かれています。

00:01:28.000 -> 00:01:38.000
サイドバービューはSwiftUIリストとして実装されており、リストにはアプリで移動できるすべての場所の行を含むセクションが表示されます。

00:01:38.000 -> 00:01:45.000
ビューは、選択したアイテムバインディングを通じて、どのアイテムが選択されているかを追跡します。

00:01:45.000 -> 00:01:53.000
選択可能な項目は、SidebarItemタイプのケースとして表されます。

00:01:53.000 -> 00:01:56.000
この場合、すでにスプリットビューコントローラーがあるので。

00:01:56.000 -> 00:02:03.000
このサイドバービューをホストするには、NSHostingControllerというSwiftUIのクラスを使用します。

00:02:03.000 -> 00:02:10.000
SwiftUIサイドバービューは、そのホスティングコントローラーのルートビューとして渡されます。

00:02:10.000 -> 00:02:23.000
ホスティングコントローラーは他のビューコントローラーと同様に使用できるため、ここではsplitViewItemとして設定し、splitViewControllerに追加します。

00:02:23.000 -> 00:02:35.000
これで、サイドバーは分割ビューでホストされていますが、選択が変更されたときに機能するには、分割ビューの右側に別のページを表示する必要があります。

00:02:35.000 -> 00:02:40.000
現在、選択したアイテムの状態はSwiftUI内にのみ存在します。

00:02:40.000 -> 00:02:47.000
私たちがする必要があるのは、スプリットビューとサイドバーの間で共有できる場所に移動することです。

00:02:47.000 -> 00:02:56.000
これを行う良い方法は、SwiftUIの外部に保存でき、共有する必要がある状態を含むモデルオブジェクトを作成することです。

00:02:56.000 -> 00:02:59.000
このオブジェクトをSelectionModelと呼びます。

00:02:59.000 -> 00:03:05.000
これで、サイドバーはSelectionModelの状態を読み書きできます。

00:03:05.000 -> 00:03:11.000
コードでは、SelectionModelはObservableObjectに準拠したクラスです。

00:03:11.000 -> 00:03:18.000
観測可能なオブジェクトであるため、モデルに保存されている状態が変更されたときにSwiftUIはビューをリロードできます。

00:03:18.000 -> 00:03:23.000
現在選択されているサイドバーアイテムを保存します。

00:03:23.000 -> 00:03:31.000
このプロパティは、選択した項目が変更されたときにSwiftUIサイドバービューが更新できるように公開されています。

00:03:31.000 -> 00:03:39.000
誰かがサイドバーの選択を変更するたびに、モデルは詳細ビューに新しいページを表示できます。

00:03:39.000 -> 00:03:46.000
AppKitでSwiftUIをホストする方法について説明したので、コレクションとテーブルセルに移りましょう。

00:03:46.000 -> 00:04:00.000
他のプラットフォームからショートカットをmacOSに持ち込むと、コレクションビューセルまたはホーム画面ウィジェットにショートカットを表示するために構築された象徴的なSwiftUIビューがすでにありました。

00:04:00.000 -> 00:04:06.000
macOSでは、これらの同じビューがNSCollectionViewのセルに表示されます。

00:04:06.000 -> 00:04:17.000
アイテムの多いコレクションまたはテーブルビューでは、各セルビューはスクロールするとリサイクルされ、時間の経過とともに異なるコンテンツが表示されます。

00:04:17.000 -> 00:04:26.000
セルの再利用が機能していることを確認するには、ユーザーがスクロールするにつれてセルからサブビューを追加したり削除したりしないようにする必要があります。

00:04:26.000 -> 00:04:37.000
各セルにSwiftUIビューを表示するときは、単一のホスティングビューを使用し、セルのコンテンツを変更する必要があるときに別のルートビューで更新します。

00:04:37.000 -> 00:04:42.000
SwiftUIをホストするコレクションビューセルを構築するために必要なすべては次のとおりです。

00:04:42.000 -> 00:04:47.000
この例では、ショートカットビューを表示するセルを構築しています。

00:04:47.000 -> 00:04:52.000
各セルには、SwiftUIをホストするためのNSHostingViewが含まれています。

00:04:52.000 -> 00:05:03.000
セルはコンテンツで設定される前に作成されるため、これはnilとして開始され、ショートカットを初めて表示する準備が整ったときに設定されます。

00:05:03.000 -> 00:05:10.000
displayShortcutメソッドは、ショートカットを表示するようにセルを設定するときにデータソースによって呼び出されます。

00:05:10.000 -> 00:05:14.000
このメソッドは、SwiftUI ShortcutViewを作成します。

00:05:14.000 -> 00:05:21.000
次に、すでにhostingViewがある場合、そのhostingViewのrootViewは新しいビューに設定されます。

00:05:21.000 -> 00:05:30.000
それ以外の場合は、初めての場合は、newHostingViewが作成され、セルのサブビューとして追加されます。

00:05:30.000 -> 00:05:34.000
SwiftUIをホストしているセルのライフサイクルは次のとおりです。

00:05:34.000 -> 00:05:41.000
まず、セルが初期化され、まだ表示するショートカットがないため、サブビューなしで始まります。

00:05:41.000 -> 00:05:49.000
displayShortcutが初めて呼び出されるとき、hostingViewは表示するショートカットビューで作成されます。

00:05:49.000 -> 00:05:59.000
これにより、VStack、画像、スペーサー、および2つのテキストビューを含むSwiftUIビュー階層が作成されます。

00:05:59.000 -> 00:06:08.000
このセルが画面からスクロールされると、システムによってキューから外される可能性があり、別のショートカットを表示する必要があります。

00:06:08.000 -> 00:06:15.000
これが発生すると、新しいShortcutViewが作成され、HostingViewに渡されます。

00:06:15.000 -> 00:06:30.000
HostingViewはすでに別のショートカットビューを表示していたため、VStackやスペーサーを含むビューの全体的な構造を再利用し、変更された画像、テキスト、背景のみを更新します。

00:06:30.000 -> 00:06:35.000
さて、次はレイアウトとサイジングについて話しましょう。

00:06:35.000 -> 00:06:43.000
ホスティングコントローラーとホスティングビューは、SwiftUIビューの理想的な幅と高さに基づいて本質的なサイズを持っています。

00:06:43.000 -> 00:06:53.000
SwiftUIは、AppKitレイアウトシステムがビューのサイズを適切に調整するために使用する自動レイアウト制約を自動的に作成および更新します。

00:06:53.000 -> 00:07:00.000
ビューも柔軟です。つまり、最小から最大まで、さまざまなサイズをサポートします。

00:07:00.000 -> 00:07:05.000
SwiftUIはこれらにも制約を生み出します。

00:07:05.000 -> 00:07:15.000
階層にSwiftUIホスティングビューを埋め込む場合は、スーパービューまたは他の隣接するビューに独自の自動レイアウト制約を適用する必要があります。

00:07:15.000 -> 00:07:28.000
フレーム修飾子またはその他のSwiftUIレイアウトを使用すると、幅を固定サイズにオーバーライドするなど、作成された制約が更新されます。

00:07:28.000 -> 00:07:35.000
ウィンドウはユーザーがサイズ変更できるため、最小サイズと最大サイズがあります。

00:07:35.000 -> 00:07:47.000
HostingViewsがウィンドウのトップレベルのcontentViewとして設定されている場合、SwiftUIは表示されるコンテンツに基づいてそのウィンドウの最小サイズと最大サイズを自動的に更新します。

00:07:47.000 -> 00:07:55.000
これにより、コンテンツに応じて、ウィンドウを垂直、水平、またはその両方でサイズ変更できます。

00:07:55.000 -> 00:08:02.000
ホスティングコントローラーに配置されたSwiftUIビューも、モーダルに提示されたときにコンテンツに基づいてサイズが設定されます。

00:08:02.000 -> 00:08:15.000
たとえば、ここに示すように、NSViewControllerのポップオーバープレゼンテーションAPIを使用してホスティングコントローラーを提示することで、SwiftUIビューをAppKitポップオーバーに簡単に配置できます。

00:08:15.000 -> 00:08:20.000
presentAsSheetメソッドを使用して、SwiftUIビューをシートとして表示することもできます。

00:08:20.000 -> 00:08:30.000
そして最後に、モーダルウィンドウの場合、presentAsModalWindowメソッドを使用して、閉じるまでインタラクションをブロックするウィンドウを表示できます。

00:08:30.000 -> 00:08:34.000
ウィンドウはコンテンツに合うようにサイズが決められています。

00:08:34.000 -> 00:08:45.000
macOS Venturaでは、NSHostingViewとNSHostingControllerに新しいAPIがあり、自動的に追加される制約をカスタマイズできます。

00:08:45.000 -> 00:08:53.000
デフォルトでは、ホスティングコントローラーとビューは、最小サイズ、固有サイズ、および最大サイズの制約を作成します。

00:08:53.000 -> 00:09:05.000
ビューを常に柔軟にサイズにしたい場合、またはAppKitの周囲のビューに制約がすでに追加されている場合は、パフォーマンス上の理由からこれらのいくつかを無効にすることをお勧めします。

00:09:05.000 -> 00:09:15.000
ホスティングコントローラーの場合、ビューの理想的なサイズが優先コンテンツサイズを決定するために、優先コンテンツサイズオプションを有効にすることができます。

00:09:15.000 -> 00:09:26.000
アプリにSwiftUIビューを追加し始めるときは、アプリ内の他のビューと同じように、レスポンダーチェーンとフォーカスシステムに参加することが重要です。

00:09:26.000 -> 00:09:32.000
ショートカットでは、エディタはSwiftUIビューとして実装されています。

00:09:32.000 -> 00:09:40.000
しかし、エディタは、AppKitに実装されているメインメニューで定義されたメニューバーコマンドを処理する必要があります。

00:09:40.000 -> 00:09:45.000
これらのコマンドには、切り取り、コピー、貼り付けなどが含まれます。

00:09:45.000 -> 00:09:52.000
アクションを上下に動かすために、独自のカスタムメニュー項目もいくつか実装しました。

00:09:52.000 -> 00:09:58.000
AppKitでは、ビュー階層は「レスポンダーチェーン」と呼ばれるビューのチェーンを構成する。

00:09:58.000 -> 00:10:02.000
集中したレスポンダーはファーストレスポンダーと呼ばれます。

00:10:02.000 -> 00:10:08.000
メニュー項目が選択されると、その項目のセレクタがファーストレスポンダーに送信されます。

00:10:08.000 -> 00:10:20.000
しかし、最初のレスポンダーがそのセレクタに応答しない場合、セレクタは、何かがセレクタを処理するか、アプリに到達するまで、次の各レスポンダーに送信されます。

00:10:20.000 -> 00:10:26.000
SwiftUIの最初のレスポンダーに相当するのは、フォーカスされたビューです。

00:10:26.000 -> 00:10:35.000
フォーカス可能なSwiftUIビューは、キーボード入力に応答し、レスポンダーチェーンに送信されたセレクタを処理できます。

00:10:35.000 -> 00:10:46.000
テキストフィールドのような一部のビューはすでにフォーカス可能ですが、フォーカス可能な修飾子を使用して他のビューもフォーカス可能にすることができます。

00:10:46.000 -> 00:10:52.000
SwiftUIには、コピー、カット、ペーストなどの一般的なコマンドを処理するためのいくつかの修飾子があります。

00:10:52.000 -> 00:11:00.000
これらはペーストボードに出入りする値を渡し、人々があなたのアプリに出入りできるようにするための簡単な方法です。

00:11:00.000 -> 00:11:09.000
ショートカットエディタは、onMoveCommandとonExitコマンド修飾子を使用して、矢印キーとエスケープキーを処理します。

00:11:09.000 -> 00:11:17.000
onCommand修飾子は、AppKitの一般的なセレクタまたはアプリで定義された独自のカスタムセレクタのいずれかを処理するために使用できます。

00:11:17.000 -> 00:11:28.000
ここでは、AppKitのselectAllコマンドと、ショートカットアプリで定義されたmoveActionUpとmoveActionDownコマンドを処理します。

00:11:28.000 -> 00:11:44.000
アプリでフォーカスとキーボードのナビゲーション性をテストするときは、多くのコントロールが有効になっている場合にのみフォーカスできるため、キーボードシステム設定を開き、フルキーボードナビゲーションのオンとオフの両方でテストしてください。

00:11:44.000 -> 00:11:48.000
キーボードでアプリを機能させるためにできることはもっとたくさんあります。

00:11:48.000 -> 00:11:58.000
たとえば、FocusStateやフォーカスされた修飾子などのAPIがあり、どのビューがフォーカスされているかをプログラムで変更できます。

00:11:58.000 -> 00:12:06.000
フォーカスとキーボードの詳細については、「SwiftUIのダイレクトとフォーカスの反映」ビデオをご覧ください。

00:12:06.000 -> 00:12:11.000
最後に、SwiftUIでAppKitビューをホストすることについて話しましょう。

00:12:11.000 -> 00:12:24.000
ショートカットがSwiftUIレイアウト内でAppKitビューをホストしている場合があり、アプリでSwiftUIを採用する際にAppKitビューをホストする必要がある場合があります。

00:12:24.000 -> 00:12:37.000
1つの例は、SwiftUIショートカットエディタの内部で、macOS上の他のいくつかのシステムアプリと共有されるAppKitコントロールであるAppleScriptエディタビューが組み込まれています。

00:12:37.000 -> 00:12:48.000
SwiftUIは、AppKitビューとビューコントローラーをSwiftUIビュー階層に埋め込むことを可能にする2つの表現可能なプロトコルを提供します。

00:12:48.000 -> 00:12:57.000
SwiftUIビューと同様に、representablesはAppKitビューを作成および更新する方法の説明です。

00:12:57.000 -> 00:13:15.000
AppKitの多くのクラスには、デリゲート、オブザーバー、またはKVOまたは通知に依存しているため、プロトコルには、ビューまたはビューコントローラーに付随するように実装できるオプションのコーディネーターオブジェクトも含まれています。

00:13:15.000 -> 00:13:20.000
ホストされたオブジェクトとそのコーディネーターのライフサイクルは次のとおりです。

00:13:20.000 -> 00:13:23.000
ホストされたビューが初期化されることから始めます。

00:13:23.000 -> 00:13:28.000
これは、ビューが初めて表示されようとしているときに発生します。

00:13:28.000 -> 00:13:33.000
初期化中にSwiftUIが最初に行うことは、コーディネーターを作ることです。

00:13:33.000 -> 00:13:41.000
これはオプションですが、委任や状態管理に必要な場合は、独自のタイプを定義し、makeCoordinatorから返すことができます。

00:13:41.000 -> 00:13:47.000
コーディネーターの単一のインスタンスは、ビューの存続期間中存在します。

00:13:47.000 -> 00:13:53.000
次に、makeNSViewまたはmakeNSViewControllerメソッドのいずれかが呼び出されます。

00:13:53.000 -> 00:14:00.000
これは、ビューの新しいインスタンスを作成する方法をSwiftUIに説明する場所です。

00:14:00.000 -> 00:14:13.000
コンテキストには、作成されたばかりのコーディネーターが含まれているので、ビューの代理人または他のタイプのオブザーバーとしてコーディネーターを割り当てるのに良い場所です。

00:14:13.000 -> 00:14:22.000
ビューが作成されると、SwiftUIの状態や環境が変更されるたびに更新ビューメソッドが呼び出されます。

00:14:22.000 -> 00:14:33.000
ここでは、AppKitビューに保存されているプロパティや状態を更新して、周囲のSwiftUIの状態や環境と同期させるのはあなたの責任です。

00:14:33.000 -> 00:14:40.000
更新メソッドは頻繁に呼び出すことができるので、ビューに加える変更はできるだけ最小限に抑える必要があります。

00:14:40.000 -> 00:14:47.000
何が変更されたかを確認し、変更が行われたときにのみ、ビューの影響を受ける部分をリロードする必要があります。

00:14:47.000 -> 00:14:53.000
SwiftUIがホストされたビューを表示し終わると、それは解体されます。

00:14:53.000 -> 00:14:57.000
ホストされたビューとコーディネーターの両方が割り当て解除されます。

00:14:57.000 -> 00:15:06.000
これらが割り当て解除される前に、表現可能なプロトコルは、必要に応じて状態をクリーンアップできるオプションの実装方法を提供します。

00:15:06.000 -> 00:15:18.000
さて、ライフサイクルを知り、表現可能なプロトコルに精通したので、ショートカットがアプリでカスタムスクリプトエディタビューをホストする方法を紹介します。

00:15:18.000 -> 00:15:22.000
スクリプトエディタは、ScriptEditorViewと呼ばれるNSViewです。

00:15:22.000 -> 00:15:32.000
エディタで書かれたコードは、sourceCodeプロパティを介してアクセスおよび変更することができ、ビューを無効にして変更を防ぐことができます。

00:15:32.000 -> 00:15:40.000
スクリプトエディタにはデリゲートもあり、誰かがソースコードを変更するといつでも通知されます。

00:15:40.000 -> 00:15:50.000
AppKitビューをホストするときは、まず、ビューがSwiftUIのどこに配置され、どのデータを出入りする必要があるかを考えてください。

00:15:50.000 -> 00:15:57.000
ショートカットでは、このビューはコンパイルボタンの横にあるコンテナビューに配置されます。

00:15:57.000 -> 00:16:03.000
コンパイルボタンのハンドラは、ビューに入力されたソースコードにアクセスする必要があります。

00:16:03.000 -> 00:16:08.000
ソースコードは、Stateプロパティラッパーを使用してSwiftUIに保存されます。

00:16:08.000 -> 00:16:13.000
表現可能な状態は、この状態への読み取りと書き込みの両方が必要です。

00:16:13.000 -> 00:16:22.000
representableを構築するには、NSViewをホストするため、NSViewRepresentableに準拠したタイプを作成することから始めます。

00:16:22.000 -> 00:16:28.000
SwiftUIから設定可能である必要がある各もののプロパティを追加します。

00:16:28.000 -> 00:16:36.000
ソースコードにはバインディングが使用され、SwiftUIに保存されている状態を読み書きします。

00:16:36.000 -> 00:16:40.000
実装する必要がある最初の方法はmakeNSViewです。

00:16:40.000 -> 00:16:47.000
ここでは、ビューの新しいインスタンスを作成する方法と、必要な1回限りのセットアップを行う場所について説明します。

00:16:47.000 -> 00:16:51.000
ここでは、デリゲートがコーディネーターに設定されます。

00:16:51.000 -> 00:16:55.000
コーディネーターについてもう少し話します。詳細を話します。

00:16:55.000 -> 00:16:58.000
次に、updateNSViewを実装します。

00:16:58.000 -> 00:17:05.000
これは、ソースコードが変更されたとき、またはSwiftUI環境が変更されたときに呼び出されます。

00:17:05.000 -> 00:17:17.000
スクリプトエディタは、sourceCodeプロパティが設定されているときに多くの作業を行うため、すでにビューにある値を比較し、不要な作業を避けるために変更された場合にのみプロパティを設定します。

00:17:17.000 -> 00:17:23.000
updateNSViewに渡されるコンテキストには、SwiftUI環境が含まれています。

00:17:23.000 -> 00:17:35.000
isEnabled環境キーはスクリプトエディタのisEditableプロパティに渡されるため、SwiftUIビュー階層の残りの部分がそうであれば編集は無効になります。

00:17:35.000 -> 00:17:42.000
誰かがビューのソースコードを変更するたびに、ソースコードバインディングは新しい値をキャプチャする必要があります。

00:17:42.000 -> 00:17:49.000
これを行うには、ScriptEditorViewDelegateに準拠したコーディネーターを作成します。

00:17:49.000 -> 00:17:56.000
コーディネーターは、更新する必要があるソースコードバインディングを含む表現可能な値を保存します。

00:17:56.000 -> 00:18:04.000
そして、sourceCodeDidChangeメソッドでは、バインディングはビューから新しい文字列値に設定されます。

00:18:04.000 -> 00:18:10.000
最後に、コーディネーターを作成して更新する方法をSwiftUIに伝える必要があります。

00:18:10.000 -> 00:18:17.000
まず、新しいコーディネーターを作成するためにmakeCoordinatorメソッドを実装する必要があります。

00:18:17.000 -> 00:18:29.000
コーディネーターは、ホストされたビューと同じ寿命を持ち、ホストされたビューと同様に、コーディネーターに追加するプロパティは、表現可能な変更に応じて最新の状態に保つ必要があります。

00:18:29.000 -> 00:18:40.000
updateNSViewは、表現可能な変更に格納された値が呼び出されるため、ここでは、コーディネーターの表現可能なプロパティが更新されます。

00:18:40.000 -> 00:18:50.000
AppKitをSwiftUIに追加する方法と、SwiftUIをAppKitに追加する方法がわかったので、SwiftUIをアプリに統合し始める必要があります。

00:18:50.000 -> 00:18:55.000
始めるのに最適な場所は、サイドバー、またはテーブルとコレクションビューのセルです。

00:18:55.000 -> 00:19:01.000
ビューが正しくサイズ設定され、一般的なコマンドとフォーカスが処理されていることを確認してください。

00:19:01.000 -> 23:59:59.000
お時間をいただきありがとうございます、そしてあなたが作ったものを見るのが待ちきれません♪

