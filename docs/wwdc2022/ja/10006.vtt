WEBVTT

00:00:00.000 -> 00:00:03.000
♪まろやかなインストゥルメンタルヒップホップ音楽♪

00:00:03.000 -> 00:00:09.000
♪

00:00:09.000 -> 00:00:12.000
みなさん、こんにちは！私の名前はアンクル・ソニです。

00:00:12.000 -> 00:00:16.000
私はAppleのマップサービスチームのエンジニアリングマネージャーです。

00:00:16.000 -> 00:00:21.000
今日は、マップ開発者エコシステムに登場するエキサイティングな新機能を見ていきます。

00:00:21.000 -> 00:00:23.000
では、始めましょう。

00:00:23.000 -> 00:00:28.000
当社のマップアプリは、世界中のAppleのお客様にさまざまなエンドユーザー体験を提供します。

00:00:28.000 -> 00:00:38.000
私たちは、MapKitとMapKit JS製品を通じて、開発者がアプリやウェブサイトに美しい位置情報体験を作成できるようにします。

00:00:38.000 -> 00:00:43.000
しかし、Apple Maps開発者の提供は、常に非常にクライアント中心でした。

00:00:43.000 -> 00:00:47.000
私たちはあなたのすべての素晴らしいフィードバックに注意深く耳を傾けました。

00:00:47.000 -> 00:00:54.000
あなたは、パフォーマンスやパワーを損なうことなく、MapKitで自分のデータを拡張する方法を望んでいました。

00:00:54.000 -> 00:01:01.000
だから、私たちのエコシステムを締めくくるために、私たちはApple Maps Server APIを導入することに興奮しています。

00:01:01.000 -> 00:01:12.000
ジオコーディング、リバースジオコーディング、検索、到着予定時刻、またはETAの4つの新しいサーバーAPIを導入しています。

00:01:12.000 -> 00:01:20.000
これらのAPIは、マップをアプリケーションに統合しながら、さまざまなユースケースに取り組むのに役立ちます。

00:01:20.000 -> 00:01:26.000
ジオコーディングAPIを使用すると、アドレスを地理座標の緯度と経度に変換できます。

00:01:26.000 -> 00:01:33.000
同様に、リバースジオコーディングでは、地理座標からアドレスに移動して、逆に行うことができます。

00:01:33.000 -> 00:01:43.000
検索APIを使用すると、ユーザーに検索文字列を入力して、ビジネスや興味のある場所などを見つける機能を与えることができます。

00:01:43.000 -> 00:01:47.000
独自のデータの一部をオーバーレイしてユーザーに提示したいのかもしれません。

00:01:47.000 -> 00:01:56.000
ETA APIを使用すると、顧客があなたのビジネスが彼らからどれだけ離れているかを知るのを助けたり、最寄りの店舗を見つけるためにいくつかの計算を行うことができます。

00:01:56.000 -> 00:02:00.000
可能性は無限大です!

00:02:00.000 -> 00:02:05.000
3つの重要な理由から、サーバーAPIを気に入ると思います。

00:02:05.000 -> 00:02:13.000
MapKit、MapKit JS、および新しいApple Maps Server APIを活用することで、シームレスな体験を提供できるようになりました。

00:02:13.000 -> 00:02:18.000
これにより、アプリケーションアーキテクチャが簡素化され、完全なAppleマップスタックが得られます。

00:02:18.000 -> 00:02:20.000
これはあなたの人生をはるかに楽にするでしょう。

00:02:20.000 -> 00:02:21.000
確かに、それは私を助けてくれました。

00:02:21.000 -> 00:02:24.000
しかし、ねえ、私は偏っています!

00:02:24.000 -> 00:02:27.000
次の利点は、ネットワーク通話の削減です。

00:02:27.000 -> 00:02:38.000
多くの場合、私たちはiPhone、iPad、ウェブサイトなどのユーザーのデバイスから反復的で冗長な要求をしている状況に陥っています。

00:02:38.000 -> 00:02:44.000
異なるユーザーデバイスで実行されているアプリから、同じアドレスを何度も何度も調べているかもしれません。

00:02:44.000 -> 00:02:48.000
これにより、多くのネットワーク通話が発生し、帯域幅が無駄になります。

00:02:48.000 -> 00:02:58.000
この一般的な操作をサーバーに委任し、サーバーAPIを使用してバックエンドで一度だけ行うと、アプリケーションがより少ない帯域幅を消費するのに役立ちます。

00:02:58.000 -> 00:03:09.000
これの良い副作用は、一部の処理がApple Maps Server APIを使用してサーバーに委任されるようになったため、アプリケーションも電力効率が良いようになったことです。

00:03:09.000 -> 00:03:12.000
では、これらのAPIのいくつかをスピンしてみましょう。

00:03:12.000 -> 00:03:17.000
店舗検索アプリケーション用にこれらの連絡先カードを作成しているとしましょう。

00:03:17.000 -> 00:03:22.000
ここでは、住所と顧客の場所からの距離を持つ3つの店舗が見えます。

00:03:22.000 -> 00:03:29.000
この例では、お客様が自分の場所を提供したと仮定します。

00:03:29.000 -> 00:03:32.000
とりあえず、これらのコンタクトカードの1つを構築することに集中しましょう。

00:03:32.000 -> 00:03:41.000
これらのアドレスは、コミック書店の場所を保管し、サービスを提供するサーバー上にあると仮定します。

00:03:41.000 -> 00:03:47.000
これを構築する方法はたくさんありますが、少しの間、これらの新しいサーバーAPIがないと仮定しましょう。

00:03:47.000 -> 00:03:49.000
基本的な建築はどのようなものになるでしょうか?

00:03:49.000 -> 00:03:52.000
クライアントアプリケーションはこのデータをどのように取得しますか?

00:03:52.000 -> 00:03:58.000
この図では、アプリケーションがサーバーに呼び出してストアアドレスのリストを取得しています。

00:03:58.000 -> 00:04:04.000
バックエンドサーバーは、ストアアドレスのリストをクライアントデバイスに返します。

00:04:04.000 -> 00:04:13.000
この例ではサーバーAPIがないため、クライアントアプリケーションは連絡先カードを構築するためにアドレスに対してさまざまなアクションを実行する必要があります。

00:04:13.000 -> 00:04:20.000
1つのタスクを実行するには、クライアントはさまざまなバックエンドサービスに複数の電話をかける必要があるかもしれません。

00:04:20.000 -> 00:04:29.000
ここでは、MapKitまたはMapKit JSを使用して、クライアントアプリがApple Maps Serverに直接電話をかけていることがわかります。

00:04:29.000 -> 00:04:36.000
クライアントとバックエンドの間のこのおしゃべりは、アプリケーションのパフォーマンスと規模に悪影響を及ぼす可能性があります。

00:04:36.000 -> 00:04:47.000
一般的にレイテンシの高いセルラーネットワークでは、この方法で個々の要求を使用することは非効率的であり、接続の破損や不完全な要求につながる可能性があります。

00:04:47.000 -> 00:04:58.000
各リクエストは並行して実行できますが、アプリケーションは各リクエストのデータを送信、待機、処理し、すべて別々の接続で失敗の可能性を高めなければなりません。

00:04:58.000 -> 00:05:02.000
最後に、クライアント上のすべての応答をマージする必要があります。

00:05:02.000 -> 00:05:07.000
そして、これらすべての呼び出しが発生する間、あなたはユーザーにスピナーを表示しています。

00:05:07.000 -> 00:05:12.000
さらに、クライアントデバイスは、これらの余分な通話により多くの帯域幅と電力を使用しています。

00:05:12.000 -> 00:05:14.000
それは良いユーザーエクスペリエンスではありません。

00:05:14.000 -> 00:05:20.000
では、Apple Maps Server APIにアクセスできるモデルアーキテクチャを見てみましょう。

00:05:20.000 -> 00:05:27.000
バックエンドサーバーをゲートウェイとして使用して、クライアントとサービス間のチャット性を減らすことができます。

00:05:27.000 -> 00:05:34.000
以前と同じように、ここではクライアントから店舗のリストを表示するように要求します。

00:05:34.000 -> 00:05:39.000
次に、サーバーからジオコーディングを行うように要求します。

00:05:39.000 -> 00:05:45.000
その後、Apple Maps Serverから各APIの回答を受け取ります。

00:05:45.000 -> 00:05:52.000
コミックブックサーバーは、各サービスからの応答を組み合わせて、アプリケーションに応答を送信します。

00:05:52.000 -> 00:06:02.000
このパターンは、アプリケーションがバックエンドサービスに対して行う要求の数を減らし、高遅延ネットワーク上のアプリケーションのパフォーマンスを向上させることができます。

00:06:02.000 -> 00:06:07.000
要約すると、クライアントはサーバーに1回電話をかけて、ストアのリストを取得します。

00:06:07.000 -> 00:06:16.000
その後、サーバーは、ユーザーに最も適した応答を作成するために適切なAPI呼び出しを行うために重い作業を行います。

00:06:16.000 -> 00:06:19.000
では、ここでケーススタディの例に戻りましょう。

00:06:19.000 -> 00:06:24.000
ジオコーディングとETA APIを使用して、店舗までの距離を取得します。

00:06:24.000 -> 00:06:33.000
Geocode APIを使用して、ストアアドレスの緯度と経度を検索でき、後でETA計算に使用します。

00:06:33.000 -> 00:06:42.000
この例では、まず、コミックブックストアのアドレスを取り、URLでエンコードします。

00:06:42.000 -> 00:06:50.000
次に、Geocode APIを使用し、このURLエンコードされたアドレスをクエリパラメータとして渡します。

00:06:50.000 -> 00:06:55.000
今のところ、認証の詳細をスキップして、いくつかのスライドでそれに戻ります。

00:06:55.000 -> 00:07:01.000
応答では、返されたアドレスの緯度と経度を確認できます。

00:07:01.000 -> 00:07:06.000
お客様の住所の緯度と経度を見つけるために、同じプロセスを繰り返します。

00:07:06.000 -> 00:07:10.000
これは後でETAの計算に使用されます。

00:07:10.000 -> 00:07:13.000
ご覧のとおり、応答にはより多くのフィールドがあります。

00:07:13.000 -> 00:07:18.000
以下のリソースセクションで詳細なドキュメントをリンクします。

00:07:18.000 -> 00:07:26.000
これで、Geocode APIから取得したデータを使用して、ETA APIの出発地と目的地を設定できます。

00:07:26.000 -> 00:07:34.000
前に述べたように、原点の緯度、経度、目的地の緯度、経度があります。

00:07:34.000 -> 00:07:38.000
必要に応じて、ここで最大10の目的地を指定できます。

00:07:38.000 -> 00:07:47.000
それをETA APIで原点として、URLエンコードされた宛先クエリパラメータとしてフィードします。

00:07:47.000 -> 00:07:53.000
APIへの応答は、提供された目的地ごとに1つずつ、ETAのリストです。

00:07:53.000 -> 00:07:58.000
この場合、目的地を1つ提供したので、私たちは1つしか持っていません。

00:07:58.000 -> 00:08:04.000
ここでは、私たちの例では、店舗までの距離を計算するための距離メーターに興味があります。

00:08:04.000 -> 00:08:12.000
これにより、必要な部品がすべて手になります。店舗の住所と、ユーザーが店舗に到着するまでの距離です。

00:08:12.000 -> 00:08:19.000
また、店舗の営業時間など、独自の店舗情報を使用して、このデータを拡張またはオーバーレイすることもできます。

00:08:19.000 -> 00:08:25.000
このようにして、さまざまなサーバーAPIを活用してアプリケーションを構築できます。

00:08:25.000 -> 00:08:29.000
その他のAPIについては、この講演の下にリンクされているドキュメントを参照してください。

00:08:29.000 -> 00:08:33.000
私たちが話していない重要な部分の1つは認証です。

00:08:33.000 -> 00:08:37.000
すべてのApple Maps Server APIが認証されています。

00:08:37.000 -> 00:08:41.000
MapKit JSを使用している場合は、すでに途中です。

00:08:41.000 -> 00:08:47.000
Apple Maps Server APIは、MapKit JSと同じメカニズムを使用して認証します。

00:08:47.000 -> 00:08:51.000
まず、開発者アカウントから秘密鍵をダウンロードします。

00:08:51.000 -> 00:08:56.000
次に、この秘密鍵を使用して、JWT形式でマップ認証トークンを生成します。

00:08:56.000 -> 00:09:00.000
以下にリンクされている作成方法に関する詳細なドキュメントがあります。

00:09:00.000 -> 00:09:06.000
その後、トークンAPIを使用してこのマップ認証トークンを交換して、マップアクセストークンを取得できます。

00:09:06.000 -> 00:09:13.000
バックエンドでマップ認証トークンを認証し、マップアクセストークンを返送します。

00:09:13.000 -> 00:09:18.000
これはJWT形式であり、すべてのAPIインタラクションに使用されます。

00:09:18.000 -> 00:09:25.000
このアクセストークンは、ここで強調表示されたプロセスを繰り返すことで、30分ごとに更新する必要があります。

00:09:25.000 -> 00:09:35.000
認証フローがどのように見えるかを見たので、トークンAPIを使用してアクセストークンを取得する方法の簡単な例を次に示します。

00:09:35.000 -> 00:09:39.000
ここではトークンAPIを使用しています。

00:09:39.000 -> 00:09:43.000
マップ認証トークンをヘッダーとして渡しています。

00:09:43.000 -> 00:09:48.000
APIへのアクセスに使用できるマップアクセストークンが戻ってきます。

00:09:48.000 -> 00:09:55.000
これはJWT形式で、有効期限、発行済みなどの標準フィールドがあります。

00:09:55.000 -> 00:10:01.000
便宜上、expiresInSecondsフィールドには、トークンの有効期間が表示されます。

00:10:01.000 -> 00:10:04.000
この場合、30分です。 分です。

00:10:04.000 -> 00:10:10.000
マップ認証トークンはマップアクセストークンと同じではないことを覚えておいてください。

00:10:10.000 -> 00:10:18.000
マップ認証トークンを交換して、サーバーAPIにアクセスするための30分間のマップアクセストークンを取得します。

00:10:18.000 -> 00:10:24.000
マップアクセストークンとのAPIインタラクションがどのように見えるかを簡単に見てみましょう。

00:10:24.000 -> 00:10:29.000
サーバーAPI呼び出しとともにマップアクセストークンを渡します。

00:10:29.000 -> 00:10:34.000
数枚のスライドで見たように、API呼び出しのヘッダーとして追加されます。

00:10:34.000 -> 00:10:37.000
Apple Maps Serverは、マップのアクセストークンを検証します。

00:10:37.000 -> 00:10:44.000
検証が成功すると、Apple Maps ServerはAPI応答で応答します。

00:10:44.000 -> 00:10:50.000
APIと認証を取り上げたので、使用制限について話しましょう。

00:10:50.000 -> 00:10:55.000
大きな力には大きな責任が伴うので、クォータを賢く使用してください。

00:10:55.000 -> 00:11:01.000
あなたが行うことができるAPI呼び出しの数には1日の上限があり、それは大きいです!

00:11:01.000 -> 00:11:05.000
1日あたり合計25,000件のサービスコールのクォータを取得します。

00:11:05.000 -> 00:11:11.000
MapKit JSとサーバーAPIを介してサービスを呼び出すと、同じクォータを使用することに注意してください。

00:11:11.000 -> 00:11:14.000
もっと必要な場合は、私たちに手を差し伸べてください。

00:11:14.000 -> 00:11:18.000
では、これをすべてどのように追跡しますか?

00:11:18.000 -> 00:11:23.000
マップ開発者ダッシュボードで使用統計を表示できます。

00:11:23.000 -> 00:11:24.000
MapKit JSを使っている人はいますか？

00:11:24.000 -> 00:11:27.000
これはあなたにとても見覚えがあるでしょう。

00:11:27.000 -> 00:11:34.000
サーバーAPIの使用状況はサービスに分類され、ここで強調表示されます。

00:11:34.000 -> 00:11:50.000
1日のクォータを超えた場合、つまり25,000以上のサーバーAPI呼び出しは、新しいサービスコールを拒否し始め、HTTPステータス429で応答します。これは、リクエストが多すぎることを意味します。

00:11:50.000 -> 00:11:55.000
そのようなシナリオでは、アプリのエクスペリエンスが優雅に劣化することを確認する必要があります。

00:11:55.000 -> 00:12:07.000
まれに、サービスが異常な量のリクエストを行う場合、おそらくコードやインフラストラクチャのバグが原因で、HTTPステータス429を取得することもできます。

00:12:07.000 -> 00:12:13.000
HTTP 429を受信するときは、単にリクエストを行う際に繰り返しループしないことが重要です。

00:12:13.000 -> 00:12:18.000
より良いアプローチは、試行の合間に遅延を増やして再試行することです。

00:12:18.000 -> 00:12:21.000
このアプローチは指数関数的なバックオフとして知られています。

00:12:21.000 -> 00:12:24.000
それで、私たちは今日何を学びましたか?

00:12:24.000 -> 00:12:27.000
4つの新しいサーバーAPIをリリースします。

00:12:27.000 -> 00:12:33.000
これらのAPIは、ジオコーディング、リバースジオコーディング、検索、およびETAです。

00:12:33.000 -> 00:12:42.000
これらのAPIをMapKitおよびMapKit JSと組み合わせて使用すると、Apple Mapsスタックを使用してアプリをよりよく設計するのに役立ちます。

00:12:42.000 -> 00:12:51.000
Apple Maps Server APIを使用して、これらのタスクをバックエンドサーバーに委任することで、冗長で反復的な呼び出しを最適化できます。

00:12:51.000 -> 00:12:58.000
これらのAPIの1日のクォータは25,000で、MapKit JSサービスの使用量と共有されます。

00:12:58.000 -> 00:13:01.000
そして、それがあなたのための新しいApple Maps Server APIです。

00:13:01.000 -> 00:13:07.000
ここで言及されている他のセッションと、以下にリンクされている詳細なドキュメントを必ずチェックしてください。

00:13:07.000 -> 00:13:10.000
私たちは、あなたがそれらをどのように利用するかを楽しみにしています。

00:13:10.000 -> 00:13:11.000
ありがとう！

00:13:11.000 -> 23:59:59.000
♪

