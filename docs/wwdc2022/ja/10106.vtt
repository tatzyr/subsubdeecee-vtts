WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:13.000
プロフィールへようこそ、ゲームのメモリを最適化してください。

00:00:13.000 --> 00:00:16.000
私はアップルのGPUソフトウェアチームのジャック・シュー(许)です。

00:00:16.000 --> 00:00:18.000
同僚のセス・ル(陆)が加わります。

00:00:18.000 --> 00:00:26.000
ここ数年、私たちのチームはあなたのようなゲーム開発者と協力して、一緒にゲームメモリを理解し、改善してきました。

00:00:26.000 --> 00:00:37.000
今日、私たちは学習を共有したいので、ゲームのメモリをデバッグし、最高のプレイヤー体験で素晴らしいゲームを作成するときに、有利なスタートを切ることもできます。

00:00:37.000 --> 00:00:43.000
CPUオブジェクトとGPUオブジェクトの両方から、ゲームのメモリ使用量を分解します。

00:00:43.000 --> 00:00:51.000
さらに、ゲーム内の割り当て、物理メモリでの実際の使用、およびオブジェクト間の参照を分析します。

00:00:51.000 --> 00:00:58.000
記憶には多くの側面があるため、当社の開発者ツールはまた、さまざまな角度から記憶の謎を明らかにします。

00:00:58.000 --> 00:01:06.000
ガイド付きツアーに参加し、Xcode、Instruments、ターミナルのコマンドラインツールなど、それらすべての使用方法を体験します。

00:01:06.000 --> 00:01:12.000
今日のガイド付きツアーでは、ゲームの記憶を理解するための前奏曲から始めます。

00:01:12.000 --> 00:01:18.000
そして、メモリとメモリの成長をプロファイリングし始め、セスがインストゥルメントについて教えてくれます。

00:01:18.000 --> 00:01:28.000
Instrumentsで時間的アプローチを取った後、私たちは旅を進め、Xcodeとターミナルのツールを使用してゲームのメモリグラフを分析します。

00:01:28.000 --> 00:01:35.000
これらのワークフローは、メモリ使用の現在の状態と、ゲーム全体のメモリの内訳に焦点を当てています。

00:01:35.000 --> 00:01:45.000
最後に、セスは、メタルデバッガを使用してメタルリソースを最適化する方法を共有します。メタルリソースは、ややスタンドアロンでありながら、ゲームメモリのコア領域です。

00:01:45.000 --> 00:01:51.000
では、ゲームのメモリの理解から始めましょう。

00:01:51.000 --> 00:02:00.000
Modern Rendering with Metalのサンプルコードなど、Xcodeからゲームを起動すると、Xcodeのデバッグナビゲーターでこのメモリレポートを開くことができます。

00:02:00.000 --> 00:02:08.000
これは、ゲームの現在および最近のメモリ使用量、およびシステムへの影響レベルに関する最初の見解です。

00:02:08.000 --> 00:02:12.000
ゲージの数字は、ゲームの現在のメモリ使用量を示しています。

00:02:12.000 --> 00:02:19.000
メモリデバッグの重要な最初のステップは、この数字が何を意味するのかを理解することです。

00:02:19.000 --> 00:02:26.000
1行にまとめると、ゲームでの実際のメモリ使用量は割り当てと同じではありません。

00:02:26.000 --> 00:02:28.000
実際のメモリ使用量は物理メモリにあります。

00:02:28.000 --> 00:02:34.000
割り当てはゲームによって要求されるメモリですが、仮想メモリアドレス空間にあります。

00:02:34.000 --> 00:02:41.000
そして、さまざまな種類の割り当ては自然に別々に計算されます。

00:02:41.000 --> 00:02:48.000
ゲームがメモリを割り当てるとき、これらの新しい割り当てはすぐにも、直接物理的なメモリのスペースを占有することはありません。

00:02:48.000 --> 00:02:56.000
それどころか、システムが各プロセスに提供する仮想メモリアドレス空間にいくつかのスペースを予約します。

00:02:56.000 --> 00:03:04.000
そして、プログラムが後で実際にこの割り当てを使用する場合、システムは物理メモリのスペースを準備します。

00:03:04.000 --> 00:03:11.000
同じ種類の割り当てはカテゴリにグループ化され、仮想アドレス空間をまばらに占有します。

00:03:11.000 --> 00:03:44.000
これらのカテゴリには、プログラムの実行可能バイナリ、すべてのライブラリとフレームワーク、ローカル変数と一時変数といくつかの関数引数のストレージを提供するスタック、ヒープとも呼ばれる動的メモリ領域、プログラムが手動で割り当てるクラスインスタンスストレージとメモリを含む、ゲームアセットファイルなどの読み取り専用リソースからマッピングされた領域、そしてもちろん、バッファ、テクスチャ、パイプライン状態オブジェクトなどのゲーム内のメタルオブジェクトが含まれます。

00:03:44.000 --> 00:03:48.000
そして、これらのカテゴリは地域で構成されています。

00:03:48.000 --> 00:03:57.000
ボンネットの下では、メモリ操作は、最新のAppleデバイスでそれぞれ16キビバイトのメモリページの粒度で機能します。

00:03:57.000 --> 00:04:05.000
これは、各地域が1つ以上のページを占有し、少なくとも16キビバイトの大きさであることを意味します。

00:04:05.000 --> 00:04:16.000
ゲームが続くにつれて、メモリの状態は進化し続けます。新しいオブジェクトが割り当てられ、古いアイテムが破壊され、領域は変化し続けます。

00:04:16.000 --> 00:04:27.000
しかし、地域で使用されているページのみが物理メモリ上にあり、システムは他のアプリと同様に、あなたのゲームに熱心に請求します。

00:04:27.000 --> 00:04:33.000
ゲームのメモリページは、ダーティ、圧縮、クリーンの3種類のうちの1つです。

00:04:33.000 --> 00:04:35.000
それらが何であるかを確認しましょう。

00:04:35.000 --> 00:04:40.000
ダーティメモリページには、ゲームが書いたメモリが含まれています。

00:04:40.000 --> 00:04:47.000
これには、ゲームがこれらの変数やシンボルを変更すると、ヒープでのメモリ割り当てとフレームワークが含まれます。

00:04:47.000 --> 00:05:00.000
Appleシリコンを搭載したデバイスでは、アクセスされた金属リソースもこのカテゴリに分類されます。これは、CPUとGPUが同じ高速ユニファイドメモリのプールを共有しているためです。

00:05:00.000 --> 00:05:12.000
ただし、一部のダーティページが長期間使用されていない場合、システムはこれらのページを圧縮するか、スワップと呼ばれるフラッシュまたはディスクに保存することで、物理メモリ上の存在を減らす可能性があります。

00:05:12.000 --> 00:05:17.000
これにより、デバイスはより多くのアプリやサービスを実行できるようになります。

00:05:17.000 --> 00:05:24.000
後で、ゲームが再びこれらのページを要求すると、システムはディスクから解凍またはページを読み込みます。

00:05:24.000 --> 00:05:29.000
なお、あなたのゲームは圧縮されていないサイズに対して引き続き課金されます。

00:05:29.000 --> 00:05:40.000
クリーンなメモリページの場合、テクスチャやオーディオアセットなど、ディスクからマッピングされた読み取り専用ファイルと、プロセスにロードされたフレームワークが含まれます。

00:05:40.000 --> 00:05:48.000
システムはいつでもディスクから空にしたりリロードしたりできるため、ゲームのメモリフットプリントにはカウントされません。

00:05:48.000 --> 00:05:57.000
しかし、それらはメモリに常駐している可能性があり、過度に使用するとシステムとゲームが遅くなります。

00:05:57.000 --> 00:06:04.000
通常、メモリフットプリントと呼ばれる最初の2つの部分を見るのが最も興味深いです。

00:06:04.000 --> 00:06:09.000
そして、システムはこれを使用してメモリ制限を強制します。

00:06:09.000 --> 00:06:18.000
いくつかの用語では、汚いはクリーンの反対であるため、人々はメモリフットプリントを意味するときに「ダーティメモリ」と言います。

00:06:18.000 --> 00:06:24.000
しかし、心配しないでください、物事が曖昧になったとき、私たちはどちらを意味するかを呼び出します。

00:06:24.000 --> 00:06:29.000
だから今、あなたはメモリがどのように機能し、システムがそれをゲームにどのように充電するかを知っています。

00:06:29.000 --> 00:06:39.000
このXcodeメモリゲージのほかに、Macのアクティビティモニターアプリなど、システム上の多くの場所でメモリフットプリントを見つけることができます。

00:06:39.000 --> 00:06:43.000
また、一部のAppleプラットフォームでは、アプリのメモリ制限に使用しています。

00:06:43.000 --> 00:06:47.000
あなたのゲームは、メモリの使用を導くためにこのメトリックを使用することもできます。

00:06:47.000 --> 00:06:53.000
現在のフットプリントと利用可能なメモリを照会するための便利なAPIがあります。

00:06:53.000 --> 00:06:54.000
簡単に見てみましょう。

00:06:54.000 --> 00:07:07.000
iOS、iPadOS、またはtvOSゲームで利用可能なシステムメモリを取得するには、os/proc.hヘッダーファイルにあるos_proc_available_memoryを呼び出します。

00:07:07.000 --> 00:07:22.000
また、Appleプラットフォームのメモリフットプリントについては、現時点でバージョン6である「get pid」、「rusage_info_current」、およびデータストアからのプロセスIDを使用して、proc_pid_rusageを介して取得できます。

00:07:22.000 --> 00:07:28.000
そして、その物理フットプリントまたはライフタイム最大物理フットプリントプロパティを取得します。

00:07:28.000 --> 00:07:33.000
要約すると、この最初のセクションでは、メモリに関するいくつかの概念を復習しました。

00:07:33.000 --> 00:07:45.000
ゲーム内の割り当ては仮想メモリアドレス空間で行われ、ゲームによってアクセスされると、16キビバイトページとして物理的なメモリスペースを占有します。

00:07:45.000 --> 00:07:53.000
メモリフットプリントは、ゲームの実際のメモリ使用量を決定するためのAppleプラットフォームの主要かつ普遍的な指標です。

00:07:53.000 --> 00:07:58.000
メモリフットプリントには、汚れたページ、圧縮されたページ、交換されたページが含まれています。

00:07:58.000 --> 00:08:03.000
Appleシリコン上のCPUとGPUの両方のオブジェクトが含まれています。

00:08:03.000 --> 00:08:06.000
そして、それはメモリ制限の適用に使用されます。

00:08:06.000 --> 00:08:12.000
あなたのゲームは、そのフットプリントと利用可能なメモリを取得するためにシステムAPIを呼び出すことができます。

00:08:12.000 --> 00:08:18.000
記憶が舞台裏でどのように機能するかがわかったので、それがあなたのゲームでどのように見えるかを調べてみましょう。

00:08:18.000 --> 00:08:21.000
もっと話すために、セスに渡しましょう。

00:08:21.000 --> 00:08:23.000
セス・ルー:ありがとう、ジャック。

00:08:23.000 --> 00:08:26.000
では、ゲームのメモリの成長を捉えることから始めましょう。

00:08:26.000 --> 00:08:30.000
そして、私はモダンレンダラーのサンプルプロジェクトを使い続けます。

00:08:30.000 --> 00:08:36.000
Xcodeからゲームを実行すると、メモリゲージは時間の経過とともにメモリフットプリントを表示します。

00:08:36.000 --> 00:08:42.000
ただし、Instrumentsでゲームをプロファイリングすることで、メモリ使用量をより詳細に見ることができます。

00:08:42.000 --> 00:08:51.000
多くの場合、ゲームは起動時に多くのメモリを割り当てることができるため、既存の実行に添付するのではなく、新しいゲームの起動からプロファイリングを開始することをお勧めします。

00:08:51.000 --> 00:08:59.000
Xcodeから、ゲームのプロファイリングをすばやく開始するには、実行ボタンを長押しし、「プロフィール」を選択します。

00:08:59.000 --> 00:09:02.000
これにより、自動的にインスツルメンツに移動します。

00:09:02.000 --> 00:09:10.000
インスツルメンツアプリには、システムのさまざまな側面を記録し、記録されたデータをタイムラインに視覚化するプロファイリングツールのコレクションが含まれています。

00:09:10.000 --> 00:09:17.000
今年の新しいのは、メタルゲームのメモリの成長をよりよく理解するのに役立つゲームメモリテンプレートです。

00:09:17.000 --> 00:09:37.000
このテンプレートには、履歴でメモリ割り当てを記録するための割り当てとメタルリソースイベント機器、メモリフットプリントを記録するためのVMトラッカー、仮想メモリアクティビティを記録するための仮想メモリトレース、メタル関連のイベントを記録するためのメタルアプリケーションとGPUが付属しています。

00:09:37.000 --> 00:09:44.000
そして、このデモでは、割り当て、金属資源イベント、VMトラッカーの最初の3つの機器を強調します。

00:09:44.000 --> 00:09:47.000
しかし、まず、ゲームの痕跡を記録しましょう。

00:09:47.000 --> 00:09:51.000
ここで録音ボタンを押すと、録音を開始できます。

00:09:51.000 --> 00:09:57.000
そして後で、録音を停止するには、同じボタンを押すか、単にゲームを終了することができます。

00:09:57.000 --> 00:10:03.000
インストゥルメントがモダンレンダラーを録音している間、トレースを記録する別の方法をお見せしましょう。

00:10:03.000 --> 00:10:10.000
Xctraceコマンドを使用すると、録画をプログラムで実行でき、自動化ワークフローに役立ちます。

00:10:10.000 --> 00:10:18.000
さらに、デバイス名を指定して、ターゲットとしてiPhone、iPad、またはApple TVを選択できます。

00:10:18.000 --> 00:10:23.000
インスツルメントのトレースをキャプチャしたので、まず割り当てを見てみましょう。

00:10:23.000 --> 00:10:30.000
割り当て機器は、メモリ割り当て、そのサイズ、およびオブジェクト参照数の詳細なビューを提供します。

00:10:30.000 --> 00:10:34.000
ただし、民間の金属資源は含まれていません。

00:10:34.000 --> 00:10:40.000
統計ビューには、すべてのヒープ割り当てと匿名VMが表示されます。

00:10:40.000 --> 00:10:50.000
すべてのヒープ割り当てには、オブジェクトを含む可能性のあるmalloc'edバッファが含まれており、すべての匿名VMには、汚れている可能性のある興味深いVM領域が含まれています。

00:10:50.000 --> 00:10:56.000
そして、すぐにいくつかの金属資源がこのカテゴリに属していることがわかります。

00:10:56.000 --> 00:10:59.000
では、すべてのヒープ割り当ての内部を見てみましょう。

00:10:59.000 --> 00:11:03.000
通常、より大きな割り当ては最適化にとってより興味深いものです。

00:11:03.000 --> 00:11:11.000
単一の最大の割り当てを見つけるには、サイズテーブル列をクリックして、割り当てをサイズで並べ替えることができます。

00:11:11.000 --> 00:11:20.000
割り当てについては、この矢印をクリックすると、SwiftおよびObjective-Cオブジェクトの参照数の変更を確認できます。

00:11:20.000 --> 00:11:26.000
そして、この大きな割り当てがリストで選択されると、インスペクタに割り当て履歴のスタックトレースがあります。

00:11:26.000 --> 00:11:31.000
ボタンをクリックすると、システムライブラリやフレームワークを非表示にすることができます。

00:11:31.000 --> 00:11:38.000
そしてここで、スタックトレースによると、割り当てはModern Rendererがアセットをロードしたときに起こりました。

00:11:38.000 --> 00:11:43.000
フレームをダブルクリックすると、ソースコードにもアクセスできます。

00:11:43.000 --> 00:11:48.000
では、戻って「すべての匿名VM」カテゴリを見てみましょう。

00:11:48.000 --> 00:11:55.000
メタルゲームでは、IOacceleratorとIOSurfaceのカテゴリで多くの割り当てを見つけることができます。

00:11:55.000 --> 00:12:00.000
IOAcceleratorの割り当ては、金属資源に対応しています。

00:12:00.000 --> 00:12:06.000
スタックトレースから、この割り当てがアセットのロード中に発生したことがわかります。

00:12:06.000 --> 00:12:10.000
IOSurfaceの割り当てはドローアブルに対応します。

00:12:10.000 --> 00:12:16.000
そしてここで、スタックトレースは、描画可能を要求したMetalKitビューを示しています。

00:12:16.000 --> 00:12:20.000
割り当て機器は、デフォルトでは、割り当てサイズを視覚化します。

00:12:20.000 --> 00:12:23.000
しかし、それはまた、別のルックスが付属しています。

00:12:23.000 --> 00:12:29.000
割り当てトラックの矢印ボタンで、表示モードをカスタマイズして、割り当て密度を視覚化できます。

00:12:29.000 --> 00:12:36.000
これにより、グラフが更新され、時間の経過とともに実行された割り当ての量が表示され、メモリ割り当てのスパイクが明らかになります。

00:12:36.000 --> 00:12:39.000
これらのスパイクは、記憶の成長の原因である可能性があります。

00:12:39.000 --> 00:12:43.000
したがって、割り当てに表示されるデータはかなり低レベルです。

00:12:43.000 --> 00:12:50.000
割り当てられた金属資源をよりよく理解するために、金属資源イベントに移りましょう。

00:12:50.000 --> 00:12:54.000
メタルリソースイベント機器は、メタルリソースを中心に設計されています。

00:12:54.000 --> 00:13:00.000
リソースイベントビューでは、金属資源の割り当てと割り当て解除の履歴を見つけることができます。

00:13:00.000 --> 00:13:08.000
ここでは、Metal APIを通じてプログラムで指定できるラベルでMetalリソースを識別することもできます。

00:13:08.000 --> 00:13:15.000
また、割り当てツールと同様に、インスペクタで割り当て履歴のスタックトレースを見つけることができます。

00:13:15.000 --> 00:13:21.000
この機器は、Metalデバイスの下にAllocationとDeallocationsトラックも追加します。

00:13:21.000 --> 00:13:23.000
それらはイベントの密度を視覚化するのに役立ちます。

00:13:23.000 --> 00:13:29.000
これまでのところ、割り当てと金属リソースイベントは、メモリ割り当てを理解するのに役立ちます。

00:13:29.000 --> 00:13:33.000
ただし、割り当ては必ずしもメモリフットプリントに変換されるとは限りません。

00:13:33.000 --> 00:13:38.000
それでは、VMトラッカーに移り、実際のメモリ使用量を調査してみましょう。

00:13:38.000 --> 00:13:44.000
VM Trackerインストゥルメントは、非圧縮されたダーティおよび圧縮またはスワップされたメモリを表示します。

00:13:44.000 --> 00:13:48.000
ダーティサイズは、圧縮されていないダーティメモリを表します。

00:13:48.000 --> 00:13:52.000
そして、スワップされたサイズは、圧縮またはスワップされたメモリを表します。

00:13:52.000 --> 00:13:57.000
この録音では、モダンレンダラーからの圧縮またはスワップされたメモリの使用はありません。

00:13:57.000 --> 00:14:00.000
詳細なサマリービューには、VMリージョンが表示されます。

00:14:00.000 --> 00:14:06.000
また、「マップされたファイル」領域には、ゲームアセットのようなメモリマップされたリソースが見つかる場合があります。

00:14:06.000 --> 00:14:10.000
ここでは、Modern Rendererはビストロアセットファイルをメモリにマッピングします。

00:14:10.000 --> 00:14:17.000
これは、インスツルメントの割り当て、金属資源イベント、VMトラッカーの簡単な概要です。

00:14:17.000 --> 00:14:25.000
メモリの成長をプロファイリングする方法を簡単に要約するには、まず、ゲームメモリテンプレートを選択し、次にトレースを記録して分析します。

00:14:25.000 --> 00:14:31.000
メモリの成長パターンを再現または検証するときに、このプロセスを数回繰り返すことがあります。

00:14:31.000 --> 00:14:37.000
新しいゲームメモリテンプレートが、ゲームのメモリ割り当てやフットプリントの成長をよりよく理解するのに役立つことを願っています。

00:14:37.000 --> 00:14:42.000
また、インスツルメントの使用の詳細については、これらの他のビデオをチェックしてください。

00:14:42.000 --> 00:14:45.000
さて、ジャックに戻ります。

00:14:45.000 --> 00:14:53.000
ゲームのメモリテンプレートは本当にクールに見え、時間の経過に伴うメモリ使用の変化を理解するのに非常に役立ちます。

00:14:53.000 --> 00:15:04.000
さらに、特定の時間にゲームのメモリ状態をキャプチャしたいので、そのメモリ状態を深く掘り下げ、さまざまなレンズで調べることもできます。

00:15:04.000 --> 00:15:09.000
そのために、メモリグラフと一連のツールがあります。

00:15:09.000 --> 00:15:21.000
メモリグラフは、オブジェクトの作成履歴、参照、圧縮やスワップなど、ゲームのメモリ状態の完全なスナップショットを効率的に保存するためのファイルです。

00:15:21.000 --> 00:15:31.000
問題が発生したときや、比較のために問題が発生した前後に、それらのペアなど、いつでもスナップショットを撮ることができます。

00:15:31.000 --> 00:15:38.000
物事を盛り上げるために、メモリグラフでメモリを分析する方法についての料理本のアナロジーを使用しましょう。

00:15:38.000 --> 00:15:43.000
成分と準備部分が含まれています。

00:15:43.000 --> 00:15:52.000
成分については、ゲームが必要です。マロックスタックロギングと呼ばれるもの。そして、キャプチャされたメモリグラフ。

00:15:52.000 --> 00:15:58.000
Malloc Stack Loggingをすばやく設定し、メモリグラフをキャプチャします。

00:15:58.000 --> 00:16:03.000
Malloc Stack Loggingは、ゲームプロセスで割り当て情報を記録します。

00:16:03.000 --> 00:16:05.000
スキームの設定で見つけることができます。

00:16:05.000 --> 00:16:13.000
[実行] アクションを選択し、[診断] に移動し、[Malloc Stack Logging] チェックボックスをオンにします。

00:16:13.000 --> 00:16:22.000
2つのオプションが何であるか疑問に思う場合、すべての割り当てと無料履歴は、割り当てが解除された後でもすべてのオブジェクトを追跡します。

00:16:22.000 --> 00:16:28.000
ロギングデータはより多くのメモリを消費する可能性がありますが、フラグメンテーションなどの問題のデバッグに役立ちます。

00:16:28.000 --> 00:16:36.000
一方、Live Allocation Onlyは、その履歴から割り当てを解除されたオブジェクトを破棄するので、より軽いです。

00:16:36.000 --> 00:16:43.000
この場合、私はライブオブジェクト上の参照のみを調査しているので、このオプションを選ぶことができます。

00:16:43.000 --> 00:16:50.000
実際、ほとんどの場合、ライブ割り当てのみが推奨されるオプションです。

00:16:50.000 --> 00:16:56.000
または、Xcodeから起動しない場合は、環境変数を設定することもできます。

00:16:56.000 --> 00:17:00.000
追加の録音モードについては、mallocのマニュアルページをチェックしてください。

00:17:00.000 --> 00:17:03.000
その後、メモリグラフも準備します。

00:17:03.000 --> 00:17:07.000
デバッグ領域のデバッグメモリグラフボタンをクリックするだけです。

00:17:07.000 --> 00:17:13.000
Xcodeはメモリスナップショットを撮り、それを処理し、メモリデバッガを入力します。

00:17:13.000 --> 00:17:18.000
Xcodeメモリデバッガは、ゲームのメモリ使用に関する直感的な視点を提供します。

00:17:18.000 --> 00:17:22.000
少し時間を取って景色を探りましょう。

00:17:22.000 --> 00:17:30.000
左側のDebug Navigatorは、オブジェクトインスタンスの階層リストを提供します。

00:17:30.000 --> 00:17:40.000
右側のファイルインスペクタは、メモリフットプリント、稼働時間、キャプチャ日などの有用な情報を提供します。

00:17:40.000 --> 00:17:50.000
中央の領域には、左から選択したオブジェクトがあるメモリグラフビューと、参照がこのオブジェクトにどのように接続されているかが輝いています。

00:17:50.000 --> 00:17:56.000
すぐにこのグラフに戻ります。 

00:17:56.000 --> 00:18:05.000
また、ファイルメニューには、将来の分析のためにこのメモリグラフを保存したり、チームと簡単に共有したりできます。

00:18:05.000 --> 00:18:12.000
Macゲームでは、プロセスIDまたは名前を使用して、リークコマンドラインプログラムでメモリグラフをキャプチャすることもできます。

00:18:12.000 --> 00:18:23.000
つまり、安全なシェルでリモートで実行できるので、ゲームがフルスクリーンで実行され、ピントを合わせる必要がある場合に備えて、カーソルはゲーム内にとどまります。

00:18:23.000 --> 00:18:28.000
だから、それはあなたがメモリグラフ分析を開始するために必要なものです。

00:18:28.000 --> 00:18:41.000
今度は、Xcodeメモリデバッガとターミナルの汎用性の高いコマンドラインツールを使用して、このメモリグラフを調べて、割り当て、フットプリントなどを調べる時です。

00:18:41.000 --> 00:18:45.000
良い最初のステップは、カテゴリ別にメモリの使用を分解することです。

00:18:45.000 --> 00:18:50.000
フットプリントプログラムはまさにそれを行います。

00:18:50.000 --> 00:18:56.000
フットプリントは、メモリグラフの情報を使用して、この高レベルの要約を再作成します。

00:18:56.000 --> 00:19:01.000
通常、まずより大きなカテゴリに焦点を当てたいと思うでしょう。

00:19:01.000 --> 00:19:09.000
モダンレンダリングのサンプルコードからこのようなゲームメモリグラフの場合、IOacceleratorは通常最大のものです。

00:19:09.000 --> 00:19:15.000
セスが言ったように、それには金属資源が含まれています。

00:19:15.000 --> 00:19:25.000
ここでは、システムがパフォーマンスを向上させるためにサイズプールにヒープ割り当てをグループ化するため、ヒープ割り当てはいくつかのMALLOC_(接頭辞)カテゴリに移動します。

00:19:25.000 --> 00:19:36.000
これらのオブジェクトは、ゲームが効果音や物理シミュレーションを行うサードパーティのプラグインやライブラリなど、多くの場所から来る可能性があります。

00:19:36.000 --> 00:19:43.000
これは、William "Cheer" Studioによって作成された素晴らしいApple Arcadeゲーム、Manifold Gardenのメモリグラフです。

00:19:43.000 --> 00:19:46.000
ゲームのメモリ使用量を見せてもらえてうれしいです。

00:19:46.000 --> 00:19:58.000
ゲームがUnityを使用したマニホールドガーデンなどのゲームエンジン、またはメモリマップの上にあるカスタムアロケータを使用している場合、そのメモリはこのようにタグなしVM_ALLOCATEとして表示されます。

00:19:58.000 --> 00:20:08.000
ここにプロのヒントがあります：Appleプラットフォームでは、ゲームは最大16のアプリ固有のタグを使用できるため、メモリ使用量を掘り下げるときにより明確にすることができます。

00:20:08.000 --> 00:20:12.000
それは1行の変更と同じくらい簡単です。

00:20:12.000 --> 00:20:16.000
まず、16のオプションの1つからタグを作ります。

00:20:16.000 --> 00:20:24.000
次に、「em map」を呼び出すときに、マイナス1を「ファイル記述子」としてこの新しいタグに置き換えます。

00:20:24.000 --> 00:20:30.000
タグとカテゴリの定義方法については、「em map」のマニュアルページをご覧ください。

00:20:30.000 --> 00:20:39.000
「Mach VM allocate」を使用する場合は、割り当て時にフラグ引数に同じフラグを含めます。

00:20:39.000 --> 00:20:50.000
フットプリントプログラムの世界では、ダーティサイズにはスワップと圧縮も含まれているので、各カテゴリの合計請求額と考えてください。

00:20:50.000 --> 00:20:56.000
これは、現在のメモリ使用の構成と、それがフットプリントをどのように構成するかについての簡単なアイデアです。

00:20:56.000 --> 00:21:01.000
このメモリの一部は使用が少なく、圧縮またはスワップされます。

00:21:01.000 --> 00:21:04.000
それらは記憶の節約の源かもしれません。

00:21:04.000 --> 00:21:12.000
次のステップは、ゲームが使用する圧縮または交換されたメモリの量を調べ、最適化することです。

00:21:12.000 --> 00:21:16.000
このため、vmmapでメモリグラフを実行できます。

00:21:16.000 --> 00:21:22.000
それは、2つの組み合わせではなく、汚れて交換されたサイズを提供します。

00:21:22.000 --> 00:21:33.000
このダーティ列には、現在スワップまたは圧縮されていない通常のダーティメモリが含まれていますが、スワップされた列には、圧縮またはスワップされたメモリの元のサイズが含まれています。

00:21:33.000 --> 00:21:37.000
システムは、フットプリントを決定するために、これら2つの列を一緒に追加します。

00:21:37.000 --> 00:21:48.000
しかし、交換されたサイズの列のコンテンツはそれほど頻繁に使用されないため、ゲームのメモリを最適化するために何を探すべきかの良い指標です。

00:21:48.000 --> 00:21:54.000
ああ、ところで、これが割り当てサイズで、仮想サイズの列があります。

00:21:54.000 --> 00:22:02.000
また、レジデントサイズには、実行可能ファイルやメモリマップファイルなどのクリーンなページが含まれます。

00:22:02.000 --> 00:22:07.000
便利なことに、vmmapは別のテーブルでヒープ割り当てを表示します。

00:22:07.000 --> 00:22:13.000
出力の下部では、vmmapはヒープメモリをゾーンごとにグループ化します。

00:22:13.000 --> 00:22:18.000
これらのゾーンは、ゲームの使用状況やライフサイクルを反映しています。

00:22:18.000 --> 00:22:24.000
MallocStackLoggingをオンにしたので、ヒープの割り当てはツールのゾーンにあります。

00:22:24.000 --> 00:22:33.000
それ以外の場合は、割り当てサイズに基づいて、MallocHelperZoneとDefaultMallocZoneの2つのデフォルトゾーンになります。

00:22:33.000 --> 00:22:42.000
また、通常、QuartzCoreゾーンなどの小さなシステムユーティリティゾーンをスキップできます。

00:22:42.000 --> 00:22:58.000
また、数十または数百メガバイトのような高い断片化サイズまたはパーセンテージによって示される断片化が疑われる場合、WWDC 2021セッションは断片化の問題について詳しく取り上げます。

00:22:58.000 --> 00:23:09.000
また、ダッシュダッシュサマリーなしでvmmapを実行するか、標準モードでvmmapを使用するには、これらのカテゴリ内の各vm領域を1行ずつ表示します。

00:23:09.000 --> 00:23:14.000
先ほど説明したように、仮想アドレス空間がどのように見えるかと同じように。

00:23:14.000 --> 00:23:21.000
したがって、vmmapを使用すると、アクティブに使用されているものから、使用されていないダーティメモリを抽出できます。

00:23:21.000 --> 00:23:30.000
そして、通常、さまざまなサイズの動的割り当て、またはゲーム内のmalloc'dヒープメモリ使用量もかなりの量があります。

00:23:30.000 --> 00:23:32.000
彼らには特別な外観が必要です。

00:23:32.000 --> 00:23:39.000
ヒープツールは、malloc'dリソースをクラスごとにグループ化し、インスタンス数でソートします。

00:23:39.000 --> 00:23:47.000
これらのクラスは、VTable、Objective-C、またはSwiftを使用してC++で決定されます。

00:23:47.000 --> 00:23:53.000
メタデータに関するヘッダーをスキップするために、-quiet引数を使用しています。

00:23:53.000 --> 00:23:59.000
今年は新しい、ヒープはオブジェクトタイプを識別するのがよりインテリジェントです。

00:23:59.000 --> 00:24:10.000
Malloc Stack Loggingによって記録された情報を使用して、発信者または責任あるライブラリを提示するため、巨大な非オブジェクトは過去のものです。

00:24:10.000 --> 00:24:14.000
そして、これは再びマニホールドガーデンからのメモリグラフです。

00:24:14.000 --> 00:24:27.000
この例では、FMOD StudioなどのプラグインやGameAssembly.dylibなどのゲームコンポーネントがどれだけのヒープ使用量を消費しているかが初めて明らかになりました。

00:24:27.000 --> 00:24:32.000
だから今、あなたはメモリがどのように広がっているかについてより多くの情報を得ることができます。

00:24:32.000 --> 00:24:38.000
また、これらのオブジェクトに関するより多くの情報を得るためにどの方向に行くべきかを示唆しています。

00:24:38.000 --> 00:24:52.000
この例では、開発者はFMOD Studioを開いてゲームのサウンドトラックとサウンドエフェクトを微調整したり、Unityにアクセスしてゲームコードの最適化を探したりできます。

00:24:52.000 --> 00:24:58.000
場合によっては、クラスのインスタンス数ではなく、クラスの合計サイズで並べ替える方が便利です。

00:24:58.000 --> 00:25:07.000
モダンレンダリングサンプルプロジェクトのメモリグラフでは、トップコントリビューターは2億5800万バイト以上を使用するクラスです。

00:25:07.000 --> 00:25:24.000
Modern Renderingサンプルでより大きなオブジェクトを探し続けるには、ヒープを使用して-sortBySizeでクラスの合計サイズでオブジェクトをソートし、各クラスの要約ではなく-showSizesですべてのオブジェクトをリストします。

00:25:24.000 --> 00:25:38.000
そして、2億5500万バイトのサイズのバイトストレージにNSConcreteMutableDataの1つのオブジェクトがあります:それは見る価値のあるもののように見えます。

00:25:38.000 --> 00:25:40.000
次に、それが何であるかを知りたいです。

00:25:40.000 --> 00:25:44.000
そして、私は最初にその住所を知りたいです。

00:25:44.000 --> 00:26:00.000
アドレスを追加し、パターンNSConcreteMutableDataに続いてワイルドカードドットスターと、括弧内のサイズフィルターを入力して、10メガバイト以上のオブジェクトのみをリストします。

00:26:00.000 --> 00:26:02.000
そして、これがオブジェクトのアドレスです。

00:26:02.000 --> 00:26:07.000
より詳細な分析のために、次の手順で使用します。

00:26:07.000 --> 00:26:13.000
つまり、インスタンスのオブジェクト識別が改善されたヒープツールです。

00:26:13.000 --> 00:26:21.000
これまでのところ、どのオブジェクトがゲームでメモリを使用しているかを理解するための3つのツールを見てきましたが、それらはすべて異なるビューを提供します。

00:26:21.000 --> 00:26:24.000
私が示したのは、たった1つのワークフローでした。

00:26:24.000 --> 00:26:33.000
ゲームで使用される特定のメモリパターンや技術に応じて、ニーズに合った方法で使用できます。

00:26:33.000 --> 00:26:45.000
その存在について確信が持てないオブジェクトの発見で、次のステップは、その割り当てコールスタックであるその起源を取得することです。

00:26:45.000 --> 00:26:54.000
モダンレンダリングの2億バイトオブジェクトの場合、-callTreeモードを使用し、そのアドレスをmalloc_historyに渡します。

00:26:54.000 --> 00:27:01.000
追加の反転引数とともに、割り当てに最も近い関数に集中できます。

00:27:01.000 --> 00:27:03.000
そして、出来上がり。

00:27:03.000 --> 00:27:06.000
これが割り当てのバックトレースです。

00:27:06.000 --> 00:27:13.000
同様に、Xcodeメモリデバッガは、インスペクタでオブジェクトの割り当て履歴も表示します。

00:27:13.000 --> 00:27:20.000
オブジェクトを選択し、メモリインスペクタをクリックするだけで、そこにあります。

00:27:20.000 --> 00:27:34.000
別の例として、アドレスの代わりにクラスパターンとしてVM_ALLOCATEを渡して、カスタムアロケータのデバッグなど、ゲームやプラグインでの匿名VMの使用状況を確認します。

00:27:34.000 --> 00:27:48.000
Xcodeとmalloc_historyのどちらを使用するかにかかわらず、割り当てバックトレースを知り、ラインにブレークポイントを設定するなど、より深く掘り下げるかどうかを判断できます。

00:27:48.000 --> 00:27:55.000
最後になりましたが、オブジェクト参照を調査することも役立ちます。

00:27:55.000 --> 00:28:04.000
メモリグラフは、さまざまな理由でMallocStackLoggingが有効になっていなくても、常にオブジェクト参照を記録します。

00:28:04.000 --> 00:28:08.000
以前にリークを使用して、Xcodeの外でメモリグラフをキャプチャしました。

00:28:08.000 --> 00:28:10.000
リークはより多くを行います。

00:28:10.000 --> 00:28:17.000
メモリグラフ内のすべての参照をチェックし、それがリークと保持サイクルについて知っている理由です。

00:28:17.000 --> 00:28:24.000
Leaksは、トレースツリー引数とヒープからのオブジェクトアドレスを使用して、オブジェクトへの参照ツリーを取得します。

00:28:24.000 --> 00:28:34.000
しかし、この例ではかなり大きな木であるため、ターミナルよりも見るにはやや良い方法があります。

00:28:34.000 --> 00:28:43.000
Xcode 14では、選択したオブジェクトの送受信エッジと発信エッジの両方を表示するようにメモリグラフビューを再設計しました。

00:28:43.000 --> 00:28:49.000
Xcodeに描画するエッジを選択するための新しいネイバー選択ポップオーバーもあります。

00:28:49.000 --> 00:28:58.000
これにより、複雑なゲーム状態でオブジェクト参照を理解しようとすると、生産性が大幅に向上します。

00:28:58.000 --> 00:29:05.000
少し探索した後、テクスチャマネージャーがこのオブジェクトにアクセスしていると確信しています。

00:29:05.000 --> 00:29:16.000
ゲームでは、リークツールとメモリグラフビューを使用して重要なオブジェクト参照関係を見つけ、これらのオブジェクトがゲーム内でどのようにアクセスされるかを学ぶことを検討してください。

00:29:16.000 --> 00:29:22.000
そのため、リークまたはXcodeを使用してオブジェクトの重要な参照を表示して見つける方法。

00:29:22.000 --> 00:29:29.000
これらのツールの使用の詳細については、リークのマニュアルページとXcodeのヘルプを確認してください。

00:29:29.000 --> 00:29:35.000
このメモリグラフ分析クックブックでは、各ステップはいくつかの特定のツールを使用します。

00:29:35.000 --> 00:29:41.000
それらはすべて協力して、メモリグラフの分析を完了します。

00:29:41.000 --> 00:29:51.000
要約すると、まず、メモリグラフでメモリをキャプチャして分析することを期待するときに、MallocStackLoggingを有効にすることです。

00:29:51.000 --> 00:29:58.000
次に、ゲーム用にXcodeでメモリグラフをキャプチャするか、Macゲーム用にリークツールを使用します。

00:29:58.000 --> 00:30:02.000
次に、大きくて面倒な物体を見つけます。

00:30:02.000 --> 00:30:11.000
フットプリント、vmmap、およびヒープツールは、高レベルと詳細の両方でメモリの内訳を提供します。

00:30:11.000 --> 00:30:19.000
Malloc_historyを使用すると、オブジェクトが割り当てられている場所を知ることができ、リークはオブジェクトの使用状況や参照を分析することができます。

00:30:19.000 --> 00:30:26.000
これらの以前のセッションには、詳細なウォークスルーと、これらのツールのより多くの使用のデモが含まれています。

00:30:26.000 --> 00:30:30.000
今まで、私たちは金属資源の調査を延期してきました。

00:30:30.000 --> 00:30:32.000
さて、今がその時です。

00:30:32.000 --> 00:30:35.000
もっと詳しく言うと、これがセスです。

00:30:35.000 --> 00:30:37.000
またこんにちは!

00:30:37.000 --> 00:30:40.000
ゲームでは、金属資源は大きなメモリを使用できます。

00:30:40.000 --> 00:30:44.000
しかし、メモリの使用を最適化する方法があります。

00:30:44.000 --> 00:30:50.000
ここでは、ゲーム内のメタルリソースを最適化する際に使用できるメモリ節約のリストをまとめました。

00:30:50.000 --> 00:30:59.000
メタルデバッガーがリソースの監査にどのように役立つかを見て、ゲームのメモリをさらに削減するための高度なテクニックを学びます。

00:30:59.000 --> 00:31:03.000
メタルデバッガーは、メタルゲームをデバッグするためのワンストップショップです。

00:31:03.000 --> 00:31:07.000
GPUフレームキャプチャを取得した後、サマリーページを見つけることができます。

00:31:07.000 --> 00:31:12.000
これにより、キャプチャされたワークロードに関する一般的な統計情報が得られます。

00:31:12.000 --> 00:31:17.000
ページの下半分には、4つのカテゴリに分かれた洞察のリストがあります。

00:31:17.000 --> 00:31:22.000
「メモリ」カテゴリのインサイトは、ゲームのメモリの節約を示唆しています。

00:31:22.000 --> 00:31:31.000
このトレースに特有のメモリインサイトはあまりありません。これらのインサイトに対処した後、わずか数メガバイトのメモリを節約できます。

00:31:31.000 --> 00:31:35.000
しかし、あなたのゲームに特有のより多くのメモリ節約があるかもしれません。

00:31:35.000 --> 00:31:42.000
メタルリソースで使用されるメモリの全体像を把握するには、[メモリを表示]ボタンをクリックしてメモリビューアを使用できます。

00:31:42.000 --> 00:31:47.000
メモリービューアは、ゲームからキャプチャされたリソースの完全なリストを提供します。

00:31:47.000 --> 00:31:50.000
上半分は、フィルタリングのための異なるカテゴリを示しています。

00:31:50.000 --> 00:31:54.000
これを使用して、リソース、例えばテクスチャをすばやく検索できます。

00:31:54.000 --> 00:31:58.000
そして、下半分では、テーブルはテクスチャのみを表示します。

00:31:58.000 --> 00:32:01.000
とりあえずフィルターを取り出しましょう。

00:32:01.000 --> 00:32:06.000
リソーステーブルには、ゲームを最適化するのに役立つ列のコレクションがあります。

00:32:06.000 --> 00:32:13.000
そして、いくつかの興味深いリソースをすばやく特定するのに役立つかもしれないいくつかの列を強調したいと思います。

00:32:13.000 --> 00:32:17.000
インサイト列は、要約ページで見たものと似ています。

00:32:17.000 --> 00:32:23.000
この列で表を並べ替えるときに、すべてのリソースを洞察とともにすばやく表示できます。

00:32:23.000 --> 00:32:30.000
そして、洞察アイコンをクリックすると、発見を説明し、いくつかの可能なアクションを提供するポップオーバーが表示されます。

00:32:30.000 --> 00:32:34.000
この列のすぐ隣に割り当てられたサイズがあります。

00:32:34.000 --> 00:32:38.000
この列で並べ替えて、最大のリソースを確認できます。

00:32:38.000 --> 00:32:43.000
一部のリソースが実際にメモリサイズをうまく利用している場合は、監査すると便利です。

00:32:43.000 --> 00:32:55.000
たとえば、一部のテクスチャはより小さな解像度にサイズ変更され、バッファにロードされた一部のモデルは、ゲームの視覚品質に影響を与えないことを考えると、より低いポリカウントを使用する場合があります。

00:32:55.000 --> 00:32:59.000
すぐに言及するテクスチャメモリを保存する別の方法がいくつかあります。

00:32:59.000 --> 00:33:03.000
ここでのもう一つの興味深いコラムは、Last Boundからの時間です。

00:33:03.000 --> 00:33:08.000
この列でリソースを並べ替えて、最近使用されていないリソースを見つけることができます。

00:33:08.000 --> 00:33:14.000
リソースが使用されていない場合は、資産をロードする価値があるかどうかを再確認することをお勧めします。

00:33:14.000 --> 00:33:20.000
しばらくバインドされていないリソースについては、将来再び使用されない場合は、リリースを検討するかもしれません。

00:33:20.000 --> 00:33:25.000
あるいは、パージ可能な状態を揮発性に設定することもできます。

00:33:25.000 --> 00:33:32.000
金属資源は、不揮発性、揮発性、空の3つのパージ可能な状態のいずれかにある可能性があります。

00:33:32.000 --> 00:33:35.000
デフォルトでは、リソースは不揮発性です。

00:33:35.000 --> 00:33:42.000
パージ可能な状態を揮発性に設定することで、システム内のメモリ圧力が高い場合、金属はメモリからリソースを追い出す可能性があります。

00:33:42.000 --> 00:33:48.000
リソースが空になると、システムはゲームのフットプリントに対してそれを充電しなくなります。

00:33:48.000 --> 00:33:53.000
ゲームが再びリソースを必要とするときは、コンテンツがまだそこにあるかどうかを確認し、必要に応じてリロードします。

00:33:53.000 --> 00:34:01.000
パージ可能な状態があなたに不利にならないように、めったに使用されないリソースにのみ揮発性を使用することを検討してください。

00:34:01.000 --> 00:34:05.000
したがって、これらはすべてのリソースの一般的なメモの一部です。

00:34:05.000 --> 00:34:08.000
そして今、テクスチャを詳しく見てみましょう。

00:34:08.000 --> 00:34:12.000
メモリビューアでは、すべての列がデフォルトで表示されるわけではありません。

00:34:12.000 --> 00:34:18.000
テーブルヘッダーを右クリックすると、テクスチャのピクセル形式などの列を表示および非表示にできます。

00:34:18.000 --> 00:34:23.000
テクスチャのピクセルフォーマットを最適化することで、さまざまな節約を得ることができます。

00:34:23.000 --> 00:34:29.000
ゲーム内の多くのテクスチャは、16ビットの半精度ピクセルフォーマットを使用して、メモリ使用量と帯域幅を削減できます。

00:34:29.000 --> 00:34:35.000
単一のアルファ成分を持つテクスチャが必要な場合は、複数のカラーチャンネルを避けることができます。

00:34:35.000 --> 00:34:41.000
そして最後に、いくつかの読み取り専用テクスチャは、より低いメモリ使用のためのブロック圧縮の恩恵を受けるかもしれません。

00:34:41.000 --> 00:34:46.000
ブロック圧縮ピクセルフォーマットには、ASTCやBCなどのオプションがあります。

00:34:46.000 --> 00:34:55.000
さらに、A15 Bionic以降、テクスチャに非可逆圧縮を使用し、ターゲットをレンダリングして、可能な限り品質を維持しながらメモリを節約できます。

00:34:55.000 --> 00:35:00.000
詳細については、これらの以前のビデオをチェックしてください。

00:35:00.000 --> 00:35:05.000
そして、これらは、メモリビューアを使用してすぐに発見できるメモリの節約の一部です。

00:35:05.000 --> 00:35:10.000
しかし、ゲームをさらに最適化するために取るかもしれないいくつかの追加のテクニックがあります。

00:35:10.000 --> 00:35:16.000
テクスチャがシングルパスでのみ使用される場合、ストレージモードをメモリレスに設定してメモリと帯域幅を節約できます。

00:35:16.000 --> 00:35:23.000
メモリーレステクスチャは、深さ、ステンシル、マルチサンプリングテクスチャなどの一時的なレンダリングターゲットにうまく機能します。

00:35:23.000 --> 00:35:31.000
それ以外の場合、テクスチャがGPUによってのみ使用されている場合は、ストレージモードをプライベートに設定したり、共有または管理したりできます。

00:35:31.000 --> 00:35:37.000
念のため、iPhoneやiPadと同じように、AppleシリコンMacではマネージドモードは必要ありません。

00:35:37.000 --> 00:35:39.000
ケースの例を次に示します。

00:35:39.000 --> 00:35:42.000
このゲームにはDepth32Float_Stencil8のテクスチャがあります。

00:35:42.000 --> 00:35:51.000
深度テクスチャはパス全体で使用されますが、ステンシルテクスチャの内容は破棄され、フレームの後半では使用されません。

00:35:51.000 --> 00:35:59.000
そのため、代わりに、ゲームは2つのテクスチャを使用し、ステンシルテクスチャをメモリレスにして、メモリと帯域幅を節約することができます。

00:35:59.000 --> 00:36:05.000
最後に、あなたのゲームの記憶を最大限に活用するために、あなたにとって面白いかもしれない別のテクニックについて言及したいと思います。

00:36:05.000 --> 00:36:09.000
ゲームが同時に使用しない場合は、ヒープからエイリアスされたリソースを使用できます。

00:36:09.000 --> 00:36:13.000
彼らは同じ割り当てでバックアップされたメモリを共有できます。

00:36:13.000 --> 00:36:17.000
しかし、これらのリソースへのアクセスを同期するときは特に注意してください。

00:36:17.000 --> 00:36:23.000
「Go bindless with Metal 3」トークをチェックして、ヒープから割り当てられたリソースの使用について詳しく知ることができます。

00:36:23.000 --> 00:36:26.000
それで、メモリ節約のチェックリストを締めくくります。

00:36:26.000 --> 00:36:31.000
そして、このチェックリストがゲームのメタルリソースを監査するのに役立つことを願っています。

00:36:31.000 --> 00:36:38.000
ゲームメモリを最適化するためのメタルデバッガーの使用の詳細については、これらの他のWWDCトークをチェックしてください。

00:36:38.000 --> 00:36:41.000
そして、あなたに戻って、ジャック。

00:36:41.000 --> 00:36:42.000
ありがとう、セス。

00:36:42.000 --> 00:36:50.000
今日、私たちはガイド付きツアーに参加し、ゲームのメモリ使用量を理解し、改善するためにできる多くの興味深いことを探求しました。

00:36:50.000 --> 00:37:01.000
まず、メモリフットプリントは、ゲームのメモリ使用量を理解するための主要な指標であり、ダーティプラス圧縮およびスワップメモリが含まれます。

00:37:01.000 --> 00:37:05.000
その後、強力なメモリデバッグツールを体験しました。

00:37:05.000 --> 00:37:11.000
セスは、インスツルメンツが有用なテレメトリトラックでメモリプロファイリングを強化する方法を教えてくれました。

00:37:11.000 --> 00:37:16.000
新しいゲームメモリテンプレートは、この仕事のために正確に調整されています。

00:37:16.000 --> 00:37:22.000
その後、ゲームのメモリ状態のスナップショットを保存するためにメモリグラフを提示しました。

00:37:22.000 --> 00:37:31.000
オブジェクト、参照、および割り当て履歴のメモリグラフを分析するための柔軟で強力なコマンドラインプログラムがあります。

00:37:31.000 --> 00:37:38.000
ヒープツールの改善と再設計されたXcodeメモリデバッガは、ゲームメモリ分析を強化します。

00:37:38.000 --> 00:37:51.000
最後に、セスはメタルリソースのメモリ節約チェックリストと、メタルデバッガーがゲーム内のメタルリソースの使用に関する質問に答えるのにどのように役立つかを共有しました。

00:37:51.000 --> 00:37:58.000
また、他のWWDCセッション、ドキュメント、マニュアルページから詳細を学ぶこともできます。

00:37:58.000 --> 00:38:02.000
私たちは常にあなたのために最良かつ最も柔軟なツールを進歩させています。

00:38:02.000 --> 00:38:04.000
では、それらを試してみてみませんか?

00:38:04.000 --> 00:38:07.000
それらはちょうどあなたが探しているものかもしれません。

00:38:07.000 --> 00:38:15.000
そして、フィードバックアシスタントなどのチャネルを通じて、あなたが持っているかもしれないフィードバックを私たちと共有することを躊躇しないでください。

00:38:15.000 --> 23:59:59.000
記憶の旅を楽しんでください、そして見てくれてありがとう。♪ ♪

