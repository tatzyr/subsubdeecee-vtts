WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:15.000
フェリックス・アセロ：こんにちは、私の名前はフェリックス・アセロで、セキュリティエンジニアリングおよびアーキテクチャチームのソフトウェアエンジニアです。

00:00:15.000 --> 00:00:23.000
このビデオでは、LocalAuthenticationフレームワークを使用して、アプリの認証と承認フローを改善する方法を紹介します。

00:00:23.000 --> 00:00:31.000
まず、認証と承認の一般的な概念と、それらがアプリケーションにどのように適用されるかを見てみましょう。

00:00:31.000 --> 00:00:41.000
次に、既存のLocalAuthentication API、特にLAContextが、幅広い承認スキームの実装にどのように役立つかを確認します。

00:00:41.000 --> 00:00:50.000
そして最後に、今年LocalAuthenticationに追加する新しいAPIが、認証コードをさらに合理化するのにどのように役立つかを見ていきます。

00:00:50.000 --> 00:00:53.000
では、認証と承認について話すことから始めましょう。

00:00:53.000 --> 00:00:59.000
認証と承認は明確でありながら密接に関連するセキュリティ概念です。

00:00:59.000 --> 00:01:04.000
一方では、認証はユーザーの身元を確認する行為です。

00:01:04.000 --> 00:01:13.000
一方、承認とは、特定のユーザーが具体的なリソースに対して特定の操作を実行できるかどうかを検証する行為です。

00:01:13.000 --> 00:01:26.000
まとめると、利用可能なリソースと操作を評価する前に、まずユーザーが主張する人であることを確認する必要があるため、認証が実際に承認を可能にすると言えます。

00:01:26.000 --> 00:01:35.000
これらの概念を説明するために、Secure Enclaveキーなど、アプリケーションによって管理される共通のセキュリティリソースを含む具体的な例を見てみましょう。

00:01:35.000 --> 00:01:46.000
セキュアエンクレーブキーは、特定のデバイスにバインドされ、メインプロセッサから分離されたハードウェアベースのキーマネージャーによって保護されている特別なタイプの非対称キーです。

00:01:46.000 --> 00:01:56.000
これらのキーを特別なものにしているのは、Secure Enclaveに秘密鍵を保存すると、実際にキーを扱うことはなく、代わりにSecure Enclaveに操作を実行するように指示することです。

00:01:56.000 --> 00:02:02.000
Secure Enclaveキーは、アクセス制御リストまたは略してACLに関連付けることができます。

00:02:02.000 --> 00:02:11.000
アクセス制御リストは、ブロブの署名や復号化などの特定の操作を実行するために満たす必要がある要件を指定します。

00:02:11.000 --> 00:02:21.000
デバイスのロック解除後など、特定のアイテムがいつ利用可能か、および特定の操作の実行を許可するために必要な認証要件を指定できます。

00:02:21.000 --> 00:02:34.000
この例では、アプリがバイオメトリック認証でキーの署名と復号操作を保護し、デバイスのロックが解除された後にのみキーが利用可能であることを確認したいとします。

00:02:34.000 --> 00:02:40.000
それでは、このキーを含む符号操作の承認フローがどのように見えるかを見てみましょう。

00:02:40.000 --> 00:02:45.000
まず、アプリケーションは秘密鍵を使用してブロブに署名する要求を発行します。

00:02:45.000 --> 00:02:54.000
次に、アプリケーションがキーにアクセスできることを確認した後、システムは署名操作の承認要件を特定します。

00:02:54.000 --> 00:03:01.000
この場合、署名操作には、現在登録されているユーザーのいずれかからの生体認証が成功する必要があります。

00:03:01.000 --> 00:03:07.000
その後、システムは標準のUIを介してバイオメトリック認証プロセスをユーザーに案内します。

00:03:07.000 --> 00:03:21.000
認証が成功すると、システムは、最終的に署名操作を実行し、署名されたブロブをアプリに返す前に、残りのすべての承認要件が満たされていることを確認します。

00:03:21.000 --> 00:03:26.000
このフローに関与する主なコンポーネントを分解して、それらが最初の定義にどのように適合するかを見てみましょう。

00:03:26.000 --> 00:03:30.000
まず、リソースがあります。Secure Enclaveキーです。

00:03:30.000 --> 00:03:35.000
第二に、キーで実行できる操作があります。

00:03:35.000 --> 00:03:46.000
そして第三に、とりわけ、誰が操作を実行することが許可されているか、および身元を確認するために使用する認証手段を指定する一連の要件があります。

00:03:46.000 --> 00:04:09.000
この例のパラメータを定義に差し込むと、認証の場合、これが正しいユーザーであるかどうかという質問は、生体認証によって回答されることがわかります。承認の場合、ユーザーが秘密鍵を使用して署名操作を実行できるかどうかという質問は、アクセス制御リストで指定された要件を検証することによって回答されます。

00:04:09.000 --> 00:04:18.000
これが高いレベルでどのように機能するかを見たので、LocalAuthenticationの現在のAPIを使用して、このようなフローを実装する方法を見てみましょう。

00:04:18.000 --> 00:04:25.000
フレームワークのコアコンポーネントの1つであるLAContextが提供する機能をすばやく確認することから始めましょう。

00:04:25.000 --> 00:04:29.000
LAContextは、ユーザーの身元を評価するために使用できます。

00:04:29.000 --> 00:04:33.000
生体認証またはパスコード認証が必要な場合、ユーザーインタラクションを処理します。

00:04:33.000 --> 00:04:39.000
また、Secure Enclaveと連携して、生体認証データの安全な管理を可能にします。

00:04:39.000 --> 00:04:44.000
この観点から、LAContextは認証のユースケースをサポートするために使用できます。

00:04:44.000 --> 00:04:50.000
LAContextは、承認フローをサポートするために、他のフレームワークと連携して使用することもできます。

00:04:50.000 --> 00:04:56.000
たとえば、前の例で見たようなアクセス制御リストを評価するために使用できます。

00:04:56.000 --> 00:04:58.000
詳しく見てみましょう。 

00:04:58.000 --> 00:05:05.000
最初にする必要があるのは、秘密鍵に関連付けられたACLにアクセスすることです。

00:05:05.000 --> 00:05:15.000
セキュリティフレームワークが提供するSecItemCopyMatching APIの助けを借りてこれを行うことができ、クエリ内でreturn-attributesキーを確実に提供します。

00:05:15.000 --> 00:05:24.000
アクセス制御リストへのアクセスを取得したら、LAContextと evaluateAccessControl APIを使用して直接評価できます。

00:05:24.000 --> 00:05:33.000
このアプローチがもとる最大の利点は、アプリケーション内の適切なタイミングと適切な場所を決定して、ユーザーにこの承認を求めることができることです。

00:05:33.000 --> 00:05:44.000
この場合、アクセス制御リストは署名操作に生体認証を必要とするため、LAContextは使い慣れたFace IDまたはTouch ID UIを表示します。

00:05:44.000 --> 00:05:53.000
ACLがLAContext内で承認されると、キーへの参照を取得するためのクエリの一部として使用できます。

00:05:53.000 --> 00:06:01.000
これを行うには、use-authentication-context キーの下の SecItem クエリに LAContext を追加します。

00:06:01.000 --> 00:06:13.000
LAContextを秘密鍵参照にバインドすることで、署名操作の実行が別の認証をトリガーしないようにし、不要なプロンプトなしで操作を続行できるようにします。

00:06:13.000 --> 00:06:22.000
これらのバインディングはまた、LAContextが無効になるまで、将来の署名に追加のユーザーインタラクションを必要としないことを意味します。

00:06:22.000 --> 00:06:30.000
LAContextは大きな柔軟性を提供し、承認フローに関連する各ステップとパラメータを制御できます。

00:06:30.000 --> 00:06:37.000
セキュリティフレームワークなどの他のフレームワークと組み合わせて使用でき、幅広いユースケースのロックを解除できます。

00:06:37.000 --> 00:06:47.000
しかし、この汎用性は、より高いコードの複雑さを犠牲にし、いくつかのフレームワークによって提供されるAPIを慎重に調整する必要があります。

00:06:47.000 --> 00:06:58.000
ユースケースによっては、特にアプリの主な価値提案がキー、シークレット、コンテキスト、およびアクセス制御リストへの低レベルのアクセスを必要とする場合、LAContextが適切なツールである可能性があります。

00:06:58.000 --> 00:07:09.000
ただし、アプリに必要なのがコンテンツや機密性の高いリソースへのアクセスを許可する方法だけであれば、この柔軟性の一部をよりシンプルなAPIにトレードオフすることをお勧めします。

00:07:09.000 --> 00:07:13.000
これにより、アプリを合理化する最後のトピックに導きます。

00:07:13.000 --> 00:07:22.000
iOS 16とmacOS 13の新機能であるLocalAuthenticationは、より高いレベルの認証に焦点を当てたAPIを導入しています。

00:07:22.000 --> 00:07:38.000
新しいAPIは、LAContextなどのLocalAuthenticationの既存の概念の上に構築され、共通の承認フローの実装を簡素化し、アプリのコアバリュープロポジションにすべてのエネルギーを集中できるようにします。

00:07:38.000 --> 00:07:44.000
新しいAPIによって導入された最も重要な抽象化はLARightです。

00:07:44.000 --> 00:07:51.000
LARightを与えることができる最も簡単なユースケースは、アプリケーション定義リソースの操作を承認するのに役立ちます。

00:07:51.000 --> 00:08:02.000
たとえば、最初にユーザーからの生体認証を成功させることで、アプリケーションのユーザープロファイルセクションへのアクセスを支援する権利を使用できます。

00:08:02.000 --> 00:08:16.000
デフォルトでは、権利は、ユーザーが使用しているデバイスに応じて、Touch ID、Face ID、Apple Watch、またはデバイスのパスコードを使用して認証できる一連の認証要件によって保護されています。

00:08:16.000 --> 00:08:24.000
また、より詳細な要件に権利を関連付けることを選択することもできます。これにより、認証手段をさらに制限することができます。

00:08:24.000 --> 00:08:29.000
コードでLARightsを使用する方法を見てみましょう。

00:08:29.000 --> 00:08:32.000
私たちが最初にすべきことは、私たちの権利をインスタンス化することです。

00:08:32.000 --> 00:08:35.000
私たちは、その要件を指定することによってこれを行います。

00:08:35.000 --> 00:08:43.000
この場合、当社のログイン権では、ユーザーはバイオメトリを使用して認証するか、デバイスのパスコードを提供する必要があります。

00:08:43.000 --> 00:08:48.000
次に、現在のユーザーがログイン権を取得できることを確認します。

00:08:48.000 --> 00:08:58.000
この情報を使用して、ログイン操作を続行できるかどうか、または代わりにユーザーをアプリの公開セクションにリダイレクトする必要があるかどうかを判断します。

00:08:58.000 --> 00:09:08.000
最後に、承認UIでユーザーに表示されるローカライズされた理由を提供して、実際の承認操作を進めることができます。

00:09:08.000 --> 00:09:13.000
このように権利を承認すると、まったく新しいシステム主導のUIが表示されます。

00:09:13.000 --> 00:09:21.000
UIはアプリケーションウィンドウ内にレンダリングされ、操作の起源と目的を理解するのに役立つ関連情報をユーザーに提供します。

00:09:21.000 --> 00:09:32.000
新しい外観により、アプリケーションとよりシームレスに統合され、ユーザーにより多くのコンテキストと情報を提供する承認フローを作成できると信じています。

00:09:32.000 --> 00:09:38.000
権利を作成して承認する方法を見たので、そのライフサイクルを詳しく見てみましょう。

00:09:38.000 --> 00:09:42.000
権利は未知の状態でライフサイクルを開始します。

00:09:42.000 --> 00:09:48.000
アプリケーションが承認要求を発行するとすぐに、権利の状態は承認に変わります。

00:09:48.000 --> 00:09:54.000
この時点で、前のスライドで見た承認UIがユーザーに提示されます。

00:09:54.000 --> 00:10:01.000
操作の成功または失敗に応じて、権利は許可された状態または許可されていない状態に移行する可能性があります。

00:10:01.000 --> 00:10:05.000
これは、アプリケーションにとって最も重要な状態遷移です。

00:10:05.000 --> 00:10:09.000
最後に、権利は許可された状態から許可されていない状態に移動することもできます。

00:10:09.000 --> 00:10:17.000
これは、アプリケーションが右側で明示的に承認解除要求を発行した場合、または適切なインスタンスが割り当て解除されたときに発生します。

00:10:17.000 --> 00:10:23.000
許可された状態を維持するために、あなたの権利を強く参照してください。

00:10:23.000 --> 00:10:31.000
権利が承認解除された後、アプリケーションはサイクルを再開するための承認要求を引き続き発行できます。

00:10:31.000 --> 00:10:35.000
以前の状態遷移はすべて照会して観察できます。

00:10:35.000 --> 00:10:40.000
LARightインスタンスにアクセスできる場合は、その状態プロパティを直接照会できます。

00:10:40.000 --> 00:10:44.000
KVOまたはコンバインを使用して、すべての状態遷移を観察することもできます。

00:10:44.000 --> 00:11:01.000
さらに、アプリケーションが複数の権利を処理する場合は、承認状態の変更が検出された後にデフォルトのNotificationCenterに公開されるdidBecomeAuthorizedおよびdidBecomeUnauthorized通知を聞くことで、すべての状態を1か所から観察できます。

00:11:01.000 --> 00:11:08.000
先に進む前に、例に戻り、ログイン権の認証を解除するためのログアウト操作を追加しましょう。

00:11:08.000 --> 00:11:15.000
これにより、ユーザーが次回ログインしたいときに新しい承認が必要になることを保証します。

00:11:15.000 --> 00:11:23.000
これまでのところ、適切なインスタンスを使用して、アプリケーション定義リソースの操作を承認する方法を見てきました。

00:11:23.000 --> 00:11:35.000
また、これらの権利のライフサイクルと状態が最終的にランタイムにどのように結びついているかを見てきました。つまり、アプリケーションのすべてのセッションで、これらの権利を正しくインスタンス化して設定する必要があります。

00:11:35.000 --> 00:11:42.000
それでは、権利がどのように持続できるか、そしてこれがあなたのアプリにどのような可能性を可能にするかを見てみましょう。

00:11:42.000 --> 00:11:47.000
LARightsは、適切な店舗の助けを借りて持続することができます。

00:11:47.000 --> 00:11:57.000
永続化されると、権利は、権利の承認要件に一致するアクセス制御リストまたはACLで保護された一意のSecure Enclaveキーによってバックアップされます。

00:11:57.000 --> 00:12:05.000
このアプローチは、権利が持続した後も承認要件が不変であることを保証するのに役立ちます。

00:12:05.000 --> 00:12:17.000
また、権利を裏返す秘密鍵にアクセスし、それを使用して、復号化、署名、鍵交換などの保護された暗号化操作を実行することもできます。

00:12:17.000 --> 00:12:25.000
対応する公開鍵もアクセス可能で、暗号化や署名検証などの操作を実行するために使用できます。

00:12:25.000 --> 00:12:31.000
これは公開鍵なので、それに関連付けられたバイトをエクスポートすることもできます。

00:12:31.000 --> 00:12:36.000
秘密鍵操作は、権利が正常に承認された後にのみ許可されます。

00:12:36.000 --> 00:12:42.000
対照的に、公開鍵操作は常に許可されています。

00:12:42.000 --> 00:12:48.000
あなたの権利を保持するとき、あなたはそれと一緒に単一の不変の秘密を保存する機会もあります。

00:12:48.000 --> 00:12:59.000
この秘密は、お客様の権利の承認要件に一致するアクセス制御リストにも関連付けられており、権利が承認された後にのみアクセス可能になります。

00:12:59.000 --> 00:13:03.000
要約すると、LAPersistedRightsは適切なストアの助けを借りて作成されます。

00:13:03.000 --> 00:13:08.000
それらは一度だけ設定され、その承認要件は不変です。

00:13:08.000 --> 00:13:13.000
それらは保存されているため、アプリケーションのさまざまなセッションで使用できます。

00:13:13.000 --> 00:13:25.000
内部的には、それらは特定のデバイスにバインドされており、権利の承認ステータスに応じて、さまざまな暗号化操作を実行するために使用できる一意のSecure Enclaveキーによってバックアップされています。

00:13:25.000 --> 00:13:33.000
最後に、権利が承認された後にのみ利用可能になる単一の不変の秘密を保護するために使用できます。

00:13:33.000 --> 00:13:44.000
永続的な権利によって提供される機能のいくつかを理解したので、署名操作を承認したいプレゼンテーションの冒頭で説明したシナリオを実装するのにどのように役立つかを見てみましょう。

00:13:44.000 --> 00:13:49.000
私たちは、その承認要件を指定する通常の権利のインスタンス化から始めます。

00:13:49.000 --> 00:13:58.000
この場合、権利が権利の作成時にデバイスに生体認証登録を持っているユーザーにのみ権利が付与されるようにしたいと考えています。

00:13:58.000 --> 00:14:03.000
したがって、biometryCurrentSetの要件を使用します。

00:14:03.000 --> 00:14:08.000
その後、適切なストアの助けを借りて権利を保持し、一意の識別子を提供することができます。

00:14:08.000 --> 00:14:15.000
この識別子は、次回アプリケーションの将来のセッションで権利を取得する必要があるときに役立ちます。

00:14:15.000 --> 00:14:25.000
権利が保持されると、その公開鍵にすぐにアクセスでき、明示的な許可を必要とせずに、保護されていない操作を実行し始めることができます。

00:14:25.000 --> 00:14:30.000
この例では、単にそのパブリックバイトをエクスポートしているだけです。

00:14:30.000 --> 00:14:39.000
後で、署名操作を実行するときは、作成時に提供した一意の識別子を使用して、ストアから権利を取得できます。

00:14:39.000 --> 00:14:45.000
その後、権利の承認操作を通じて、現在のユーザーの承認に進むことができます。

00:14:45.000 --> 00:14:53.000
この時点で、システムはユーザーに認証プロセスを案内し、すべての承認要件が満たされていることを確認します。

00:14:53.000 --> 00:14:59.000
権利が承認された後、その秘密鍵を使用して保護された暗号化操作を実行できます。

00:14:59.000 --> 00:15:06.000
この場合、秘密鍵を使用して、アプリケーションのバックエンドサーバーによって発行されたチャレンジに署名しています。

00:15:06.000 --> 00:15:17.000
最後に、認証と承認の一般的な概念の間に存在する関係、特に認証がどのように承認を可能にするかについて話しました。

00:15:17.000 --> 00:15:27.000
LAContextが提供する機能のいくつかと、セキュリティなどのフレームワークと組み合わせて、非常に強力で拡張可能な承認フローのロックを解除する方法について説明しました。

00:15:27.000 --> 00:15:35.000
そして最後に、新しく追加されたLARightが、特定の承認ユースケースを実装するためのコードを合理化するのにどのように役立つかを調べました。

00:15:35.000 --> 00:15:48.000
アプリのLocalAuthenticationの既存の使用法を見て、今日説明した機能のいくつかが、ユーザーのプライバシーとセキュリティを保護しながらコードを簡素化するのに役立つかどうかを検討してください。

00:15:48.000 --> 23:59:59.000
ありがとう。

