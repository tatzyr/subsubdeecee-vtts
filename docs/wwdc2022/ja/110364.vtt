WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:12.000
こんにちは、WWDC 2022へようこそ。

00:00:12.000 --> 00:00:15.000
私の名前はベンで、Xcodeビルドシステムチームのエンジニアです。

00:00:15.000 --> 00:00:19.000
こんにちは、私の名前はArtemで、Swift Compilerチームのエンジニアです。

00:00:19.000 --> 00:00:25.000
この講演では、ビルド内の並列化を解明するために、Xcodeのビルドプロセスを深く掘り下げます。

00:00:25.000 --> 00:00:34.000
ベンは、ビルドに関するコアコンセプトの紹介から始め、ビルドパフォーマンスの問題を調査するためにXcodeが提供する利用可能なツールを見ていきます。

00:00:34.000 --> 00:00:39.000
次に、Xcodeがターゲットの構築中に並列化をどのように増加させるかを説明します。

00:00:39.000 --> 00:00:48.000
それに加えて、多くのターゲットで構成されるプロジェクトを構築しながら、Xcodeがどのように構築を総合的に並列化するかを説明し、最後にテイクアウトを要約します。

00:00:48.000 --> 00:00:50.000
ベン？

00:00:50.000 --> 00:00:55.000
XcodeでCMD+Bを押してアプリを構築するときに何が起こるかをもう一度繰り返しましょう。

00:00:55.000 --> 00:01:07.000
ビルドシステムは、Xcodeの一部として、すべてのソースファイル、アセット、ビルド設定、および実行先などの他の構成を含むプロジェクト全体の表現で呼び出されます。

00:01:07.000 --> 00:01:11.000
ビルドシステムは、アプリの構築方法に関する真実の唯一の情報源です。

00:01:11.000 --> 00:01:18.000
最終的にアプリを作成するために、どの設定とどの中間ファイルを使用してどのツールを呼び出すかを知っています。

00:01:18.000 --> 00:01:26.000
次のステップでは、ビルドシステムは、コンパイラなど、プロジェクトの入力ファイルを処理するためのツールを呼び出します。

00:01:26.000 --> 00:01:34.000
ClangとSwiftの両方のコンパイラは、リンカがアプリを表す実行可能プログラムをリンクするために必要なオブジェクトファイルを生成します。

00:01:34.000 --> 00:01:37.000
この注文は理にかなっていますが、それがどこから来たのかは明らかではありません。

00:01:37.000 --> 00:01:46.000
それでは、そのプロセスの1つの例と、ビルドシステムがすべてのタスクを実行する順序を決定する方法を見てみましょう。

00:01:46.000 --> 00:01:55.000
入力ソースファイルを使用して、Swiftコンパイラはプログラマーの意図をキャプチャし、それを機械実行可能なバイナリに変換し、途中でソースコードのエラーをチェックします。

00:01:55.000 --> 00:02:02.000
このプロセスは失敗する可能性があり、ビルドはキャンセルされますが、成功すると、入力ごとにオブジェクトファイルが作成されます。

00:02:02.000 --> 00:02:11.000
これらのオブジェクトファイルは、それらを組み合わせたリンカを呼び出すために使用され、外部にリンクされたライブラリへの参照を追加して実行可能ファイルを生成します。

00:02:11.000 --> 00:02:15.000
2つのタスクは、消費するものと生産するものに基づいて依存関係があります。

00:02:15.000 --> 00:02:19.000
コンパイラによって生成されたオブジェクトファイルは、リンカーによって消費されます。

00:02:19.000 --> 00:02:22.000
これにより、ビルドシステムグラフへの依存関係が作成されます。

00:02:22.000 --> 00:02:28.000
ファイルの内容自体はビルドシステムには興味がありませんが、タスク間の依存関係は。

00:02:28.000 --> 00:02:35.000
ビルドの実行中に、別のタスクの入力を生成するタスクが、そのタスクが開始される前に終了することを確認する必要があります。

00:02:35.000 --> 00:02:44.000
そして、このコアコンセプトはあらゆる種類のタスクに有効であるため、タスクAとタスクBの間の依存関係を示す、より一般的な視覚化に切り替えましょう。

00:02:44.000 --> 00:02:49.000
この場合、AはBの入力の一部または全部を生成します。

00:02:49.000 --> 00:03:03.000
コンパイルとリンクは、ターゲット全体を構築するために実行する必要がある多くの異なるタスクタイプのほんの一部ですので、アセットのコンパイル、ファイルのコピー、共同設計など、他のタイプを表すより一般的なタスクをグラフに追加しましょう。

00:03:03.000 --> 00:03:07.000
一緒に、彼らはフレームワークターゲットの構築を表しています。

00:03:07.000 --> 00:03:12.000
繰り返しますが、これらのタスクは、入力と出力に基づいて依存関係を定義しています。

00:03:12.000 --> 00:03:21.000
したがって、タスクAの実行を完了すると、実行中のタスクBとCのブロックが解除され、タスクBの終了はタスクDとEのブロックを解除します。

00:03:21.000 --> 00:03:27.000
ブロックを解除するタスクは「ダウンストリーム」と呼ばれ、「アップストリーム」をブロックするタスクと呼ばれます。

00:03:27.000 --> 00:03:34.000
多くのプロジェクトには複数のフレームワークターゲットが含まれているので、アプリとアプリ拡張機能を表すターゲットを2つ追加しましょう。

00:03:34.000 --> 00:03:39.000
ターゲットは、明示的または暗黙の依存関係を介して、プロジェクト内の相互の依存関係を定義します。

00:03:39.000 --> 00:03:45.000
たとえば、「Link Binary with Libraries」のビルドフェーズに追加されます。

00:03:45.000 --> 00:03:50.000
この場合、アプリはアプリの拡張機能を埋め込み、フレームワークにリンクします。

00:03:50.000 --> 00:03:56.000
アプリの拡張機能はフレームワークを使用していないため、依存関係はありません。

00:03:56.000 --> 00:04:00.000
ビルドグラフを実行すると、タスクによって異なる時間がかかります。

00:04:00.000 --> 00:04:10.000
これは、必要な計算と入力のサイズに応じて、作業を完了するために必要な複雑さのレベルに帰着します。

00:04:10.000 --> 00:04:19.000
多くのファイルをコンパイルするには、通常、いくつかのヘッダーファイルをコピーするよりもはるかに時間がかかり、これを考慮に入れると、このようなものになります。

00:04:19.000 --> 00:04:25.000
ビルドシステムがこのビルドを実行すると、依存関係のないタスクを実行することから始めます。

00:04:25.000 --> 00:04:35.000
そして、それらが完了すると、すべての計画されたタスクが完了するまで、このプロセスに従って、ダウンストリームタスクなどのブロックを解除します。

00:04:35.000 --> 00:04:43.000
次のビルドでは、ビルドシステムは、出力がまだ最新である間に入力が変更されていないタスクをスキップすることができます。

00:04:43.000 --> 00:04:52.000
この場合、アプリターゲットのBのように、入力が変更されたためにタスクを再実行する必要がある場合、出力が変更された場合、ダウンストリームのタスクも再実行する必要があります。

00:04:52.000 --> 00:04:58.000
他のすべてのタスクをスキップすると、プロジェクトに反復的に取り組むときに非常に速いターンアラウンドタイムが可能になります。

00:04:58.000 --> 00:05:03.000
これは増分ビルドと呼ばれていますが、今のところはフルビルドに固執しましょう。

00:05:03.000 --> 00:05:10.000
タスク実行の依存関係と期間は、ダウンストリームタスクが開始できる最初の可能な時間を定義します。

00:05:10.000 --> 00:05:18.000
この情報を使用すると、ビルドが理論的な無制限のリソースで実行する必要がある最短時間であるクリティカルパスを計算することができます。

00:05:18.000 --> 00:05:25.000
この講演を通して共通のパターンは、このパスを短縮して、高度に並列化可能でスケーラブルなビルドグラフを作成することです。

00:05:25.000 --> 00:05:34.000
クリティカルパスが短くなると、必ずしも全体的なビルド時間が短くなるとは限りませんが、ビルドがハードウェアでスケーリングされることを保証します。

00:05:34.000 --> 00:05:43.000
クリティカルビルドパスは、ビルドの速度の制限要因を定義します。ハードウェアが許可したとしても、より速く完了することはできません。

00:05:43.000 --> 00:05:47.000
クリティカルパスの短縮は、その中の依存関係を分割することによって行われます。

00:05:47.000 --> 00:05:55.000
ビルドがどのように実行されたかを見て、その実行についてもっと理解するために、実行された時間に基づいてデータをプロットする必要があります。

00:05:55.000 --> 00:05:58.000
幅は依然としてタスクの長さを示します。

00:05:58.000 --> 00:06:07.000
これら2つのような広い要素はロングランニングタスクを示し、このような狭い要素は高速仕上げタスクを表します。

00:06:07.000 --> 00:06:12.000
グラフの高さは、特定の時間に並行して実行するタスクの数を示しています。

00:06:12.000 --> 00:06:18.000
これはCPUやメモリ使用率に直接マッピングされないことに注意してください。

00:06:18.000 --> 00:06:24.000
空のスペースは、これら2つのシナリオのように下流のタスクをブロックするタスクによって発生します。

00:06:24.000 --> 00:06:29.000
そして最後に、要素の色は関連するターゲットを表します。

00:06:29.000 --> 00:06:37.000
このビジュアライゼーションがXcode 14で新しく、完了後のビルドのパフォーマンスを理解するのに役立つことを発表できることを非常に嬉しく思います。

00:06:37.000 --> 00:06:40.000
Xcodeビルドタイムラインは、ビルドログへの素晴らしい新しい追加です。

00:06:40.000 --> 00:06:46.000
ビルドのパフォーマンスを理解するために、階層ではなく並列化に基づいて視覚化します。

00:06:46.000 --> 00:06:51.000
指定された時刻の行数は、その期間中の並列性のレベルを表します。

00:06:51.000 --> 00:06:57.000
個々のタスクの水平方向の長さは、作業を完了するために必要な期間を表します。

00:06:57.000 --> 00:07:04.000
グラフの空のスペースは、未完成のタスクが下流のタスクの実行開始を妨げた場所を示しています。

00:07:04.000 --> 00:07:10.000
タイムライン要素に適用される異なる色は、ビルドの一部であった異なるターゲットを区別するのに役立ちます。

00:07:10.000 --> 00:07:22.000
また、増分ビルドでは、タイムラインには実際に実行されたタスクのみが含まれ、長時間実行されるタスク、特にこのビルド中に実行されると予想されなかったタスクを見つけることができます。

00:07:22.000 --> 00:07:25.000
これはXcode 14のビルドタイムラインのデモです。

00:07:25.000 --> 00:07:31.000
このウィンドウで、ドキュメントコンパイラを構築するGithubのswift-doccプロジェクトのコピーを開きました。

00:07:31.000 --> 00:07:36.000
スキーム用に構築されたターゲットの概要を知るには、スキームエディターをチェックしてみましょう。

00:07:36.000 --> 00:07:40.000
それを開くには、スキームをクリックし、「スキームの編集」を選択します。

00:07:40.000 --> 00:07:43.000
「ビルド」タブには、すべてのターゲットのリストが含まれています。

00:07:43.000 --> 00:07:50.000
ターゲットは、スキームに明示的に追加することも、すでにスキームの一部であるターゲットの依存関係であることによって暗黙的に追加することもできます。

00:07:50.000 --> 00:08:00.000
この場合、パッケージに自動的に生成されたスキームを持つSwiftパッケージを使用しているため、マニフェストのすべてのターゲットが明示的に定義されています。

00:08:00.000 --> 00:08:04.000
このログは、私が以前に実行したスキームのビルドを表しています。

00:08:04.000 --> 00:08:08.000
ビルドシステムが実行したすべてのタスクのエントリが含まれています。

00:08:08.000 --> 00:08:14.000
エントリは、ここでの「docc」ターゲットのように、所属するターゲットに基づいて階層に整理されています。

00:08:14.000 --> 00:08:21.000
そのターゲットの実行可能ファイルを正常に構築するために、Xcodeはこのノードの子によって表されるすべてのタスクを実行しました。

00:08:21.000 --> 00:08:28.000
ビルドログは現在「すべて」状態であるため、増分ビルドで再実行する必要がなかった以前のビルドのタスクも表示されます。

00:08:28.000 --> 00:08:34.000
「最近」を選択すると、実際に実行されたタスクのみが表示され、スキップされたすべてのタスクが非表示になります。

00:08:34.000 --> 00:08:43.000
それに加えて、ビルドログは、問題があったタスクや失敗したタスクのみを表示するフィルターもサポートしています。

00:08:43.000 --> 00:08:49.000
このビルドのビルドタイムラインを開くには、エディタオプションに移動してアシスタントを開きます。

00:08:49.000 --> 00:08:52.000
ビルドタイムラインはビルドログの横に開きます。

00:08:52.000 --> 00:08:57.000
いつものように、エディタオプションは、右側または下部にアシスタントを表示する設定を提供します。

00:08:57.000 --> 00:08:59.000
今のところはボトムにとどまります。

00:08:59.000 --> 00:09:05.000
タイムラインは、ビルドの並列化に基づいて「最近の」ビルドログと同じデータを視覚化します。

00:09:05.000 --> 00:09:08.000
一方の要素を選択すると、もう一方の要素も選択されます。

00:09:08.000 --> 00:09:12.000
これにより、コンテキスト内でタスクの実行を確認できます。

00:09:12.000 --> 00:09:18.000
ここでのタイムラインは、選択したタスクと並行して実行されたタスクについての感覚を与えます。

00:09:18.000 --> 00:09:26.000
トラックパッドでピンチジェスチャーを使って再びズームアウトしています。

00:09:26.000 --> 00:09:30.000
タイムラインで要素を選択すると、ビルドログに表示されます。

00:09:30.000 --> 00:09:38.000
また、ビルドログは階層構造に基づいて視覚化されるため、このコンパイラ呼び出しの一部としてコンパイルされたファイルを表示できます。

00:09:38.000 --> 00:09:46.000
また、その呼び出しのコマンドライン全体を表示することもできます。

00:09:46.000 --> 00:09:52.000
ビルドタイムラインで領域を選択しながらOptionキーを押したままにすると、この時間枠に合わせてビューポートが調整されます。

00:09:52.000 --> 00:09:59.000
ここでは、ターゲットArgumentParserのリンクが実際に同じターゲットのコンパイルを待っていることを確認できます。

00:09:59.000 --> 00:10:03.000
上にスクロールしながらOptionキーを押したままにすると、すばやくズームアウトできます。

00:10:03.000 --> 00:10:08.000
タイムラインの行数は、その時点で並行して実行されたタスクの数を表します。

00:10:08.000 --> 00:10:14.000
このような空のスペースは、未生成の入力を待っているタスクを示します。

00:10:14.000 --> 00:10:18.000
理想的には、タイムラインは垂直に塗りつぶされ、空きスペースはできるだけ少ないです。

00:10:18.000 --> 00:10:23.000
これにより、ビルドグラフが最適にスケーリングされ、ビルドが速くなり、ハードウェアが速くなります。

00:10:23.000 --> 00:10:28.000
これを達成するために、Xcodeは今年、クリティカルパスを短縮するために多くの改善が付属しています。

00:10:28.000 --> 00:10:35.000
次に、Xcodeが個々のターゲットをどのように定義して構築するか、そしてどのように並列化を高めることができるかを確認しましょう。

00:10:35.000 --> 00:10:41.000
ターゲットを設定するとき、ビルドフェーズは、そのターゲットの製品を生産するために必要な作業を記述します。

00:10:41.000 --> 00:10:54.000
それらはプロジェクトエディタで定義され、コンパイルするソースコードファイルとアセットのセット、ヘッダーやリソースのようにコピーする必要があるファイル、リンクする必要があるライブラリ、または実行する必要があるスクリプトを含めることができます。

00:10:54.000 --> 00:11:00.000
多くのビルドフェーズは、他のビルドフェーズからの入力または出力を使用してタスクを記述し、それら間の依存関係を作成します。

00:11:00.000 --> 00:11:04.000
たとえば、ターゲットのソースファイルは、リンクされる前にコンパイルする必要があります。

00:11:04.000 --> 00:11:08.000
ただし、これはすべてのビルドフェーズに適用されるわけではありません。

00:11:08.000 --> 00:11:17.000
各ビルドフェーズからタスクを直線的な順序で実行するのではなく、ビルドシステムはビルドフェーズの入力と出力を考慮して、並行して実行できるかどうかを判断します。

00:11:17.000 --> 00:11:24.000
たとえば、コンパイルとリソースのコピーは、どちらも他方の出力に依存しないため、並行して実行できます。

00:11:24.000 --> 00:11:30.000
ただし、リンクは、そのフェーズによって生成されたオブジェクトファイルに依存するため、コンパイルに従う必要があります。

00:11:30.000 --> 00:11:35.000
では、「スクリプトの実行」ビルドフェーズを含む別のターゲットを考えてみましょう。

00:11:35.000 --> 00:11:41.000
他のビルドフェーズとは異なり、スクリプトフェーズの入力と出力はターゲットエディタで手動で設定する必要があります。

00:11:41.000 --> 00:11:49.000
その結果、ビルドシステムは、ビルドプロセスにデータレースを導入しないように、連続したスクリプトフェーズを一度に1つずつ実行します。

00:11:49.000 --> 00:12:03.000
ターゲットのスクリプトが依存関係分析に基づいて実行され、入力と出力の完全なリストを指定するように構成されている場合、ビルド設定FUSE_BUILD_SCRIPT_PHASESをYESに設定して、ビルドシステムがそれらを並行して実行する必要があることを示すことができます。

00:12:03.000 --> 00:12:09.000
ただし、スクリプトフェーズを並行して実行する場合、ビルドシステムは指定された入力と出力に依存する必要があります。

00:12:09.000 --> 00:12:17.000
したがって、スクリプトフェーズの入力または出力の不完全なリストは、デバッグが非常に難しいデータレースにつながる可能性があることに注意してください。

00:12:17.000 --> 00:12:24.000
これを軽減するために、Xcodeは各スクリプトフェーズの依存関係を正確に宣言するユーザースクリプトサンドボックスをサポートしています。

00:12:24.000 --> 00:12:35.000
サンドボックスは、フェーズの入力または出力として明示的に宣言されていない限り、シェルスクリプトが誤ってソースファイルや中間ビルドオブジェクトにアクセスするのをブロックするオプトイン機能です。

00:12:35.000 --> 00:12:41.000
この例では、inputもoutput.txtも、そのスクリプトフェーズの依存関係として宣言されていません。

00:12:41.000 --> 00:12:46.000
サンドボックスは、プロジェクトを構築するときに、スクリプトが両方のファイルを読み書きするのをブロックします。

00:12:46.000 --> 00:12:52.000
スクリプトがサンドボックスに違反すると、ゼロ以外の終了コードで失敗し、ビルドが失敗します。

00:12:52.000 --> 00:13:00.000
それに加えて、Xcodeは、スクリプトフェーズが適切に宣言せずにアクセスしようとしたすべてのパスを一覧表示します。

00:13:00.000 --> 00:13:04.000
このスクリプトフェーズに依存関係情報として両方のファイルを追加すると、この問題が修正されます。

00:13:04.000 --> 00:13:12.000
このようにして、サンドボックスは、スクリプトが宣言された入力と出力以外のファイルに誤ってアクセスしていないことを保証します。

00:13:12.000 --> 00:13:19.000
では、複数のスクリプトフェーズを持つ例を探り、サンドボックスがデータレースや誤ったビルドを防ぐ方法を見てみましょう。

00:13:19.000 --> 00:13:21.000
スクリプトフェーズは2つあります。

00:13:21.000 --> 00:13:30.000
最初のものは、テキストファイルを読み取り、その内容のチェックサムを計算し、その値をDERIVED_FILE_DIRの中間ファイルに書き込みます。

00:13:30.000 --> 00:13:38.000
他のスクリプトは、同じテキストファイルと生成されたチェックサムを読み取り、後でアプリに表示するためにhtmlファイルに注入します。

00:13:38.000 --> 00:13:48.000
これらのフェーズの入力と出力の依存関係の正確なセットが宣言されていない場合、XcodeはFUSE_BUILD_SCRIPT_PHASESがオンになっているときに2つのスクリプトを並行して実行します。

00:13:48.000 --> 00:13:51.000
この問題のあるシナリオを詳細に調べましょう。

00:13:51.000 --> 00:14:01.000
「HTMLの生成」に「checksum.txt」の入力宣言が欠落しているが、両方のスクリプトの他のすべての入力と出力が正しく宣言されていると仮定しましょう。

00:14:01.000 --> 00:14:07.000
サンドボックスがなければ、この設定ミスは気づかれず、ビルドに問題を引き起こす可能性があります。

00:14:07.000 --> 00:14:16.000
これは、Xcodeが両方のフェーズ間の依存関係を推測することに失敗し、FUSE_BUILD_SCRIPT_PHASESがオンになっているときにそれらを並行して実行するようにスケジュールすることを意味します。

00:14:16.000 --> 00:14:18.000
ここにはいくつかの危険があります。

00:14:18.000 --> 00:14:29.000
checksum.txtはクリーンビルド中に「生成HTML」の入力依存関係としてリストされていないため、スクリプトはファイルシステムで使用できないままファイルを読み取ろうとします。

00:14:29.000 --> 00:14:40.000
もう1つの危険は、「Checksumの計算」の以前の実行のためにchecksum.txtがディスク上で利用可能な場合、「HTMLの生成」は、2つのスクリプトが並行して実行されたときに古いファイルを拾う可能性があります。

00:14:40.000 --> 00:14:45.000
これはユーザーエラーであり、サンドボックスでスクリプトを実行すると、この問題を防ぐのに役立ちます。

00:14:45.000 --> 00:14:51.000
サンドボックスをオンにすると、「HTMLの生成」は「checksum.txt」を読み取ろうとするとすぐに失敗します。

00:14:51.000 --> 00:14:56.000
エラーメッセージは、そのビルドフェーズに不足している入力を追加することをガイドします。

00:14:56.000 --> 00:15:05.000
入力と出力が正しく定義されているため、Xcodeは両方のフェーズ間の依存関係を尊重し、「計算チェックサム」が「HTMLの生成」の前に実行されます。

00:15:05.000 --> 00:15:09.000
無関係なビルドフェーズは依然として並行して実行できますが。

00:15:09.000 --> 00:15:17.000
ターゲットのサンドボックスシェルスクリプトを有効にするには、ビルド設定エディタまたはxcconfigファイルでENABLE_USER_SCRIPT_SANDBOXINGをYESに設定します。

00:15:17.000 --> 00:15:34.000
要約すると、サンドボックス化されたシェルスクリプトは、入力が変更されておらず、出力がまだ有効な場合、ビルドシステムはスクリプトフェーズをスキップする自信があり、そうでない場合はスクリプトを再実行するため、より高速で堅牢な増分ビルドを可能にする正しい依存関係情報を持つことができます。

00:15:34.000 --> 00:15:46.000
スクリプトのターゲットのビルド設定を有効にすると、プロジェクトのソースルート内のファイルと、プロジェクト内のスクリプトの入力または出力として明示的に定義されていない場合は、派生データディレクトリへのアクセスがブロックされます。

00:15:46.000 --> 00:15:52.000
サンドボックスは、他のディレクトリへの不正アクセスを防ぐことはできませんので、これをセキュリティ機能と考えないでください。

00:15:52.000 --> 00:16:11.000
この機能を使用すると、既存のスクリプトフェーズの不足している入力または出力をデバッグして、有効な構成を確保することができます。以前に説明したビルド設定FUSE_BUILD_SCRIPT_PHASESと組み合わせて、サンドボックスを介して正しく定義された依存関係エッジを持つスクリプトフェーズは、ビルドのクリティカルパスを減らすために並行して実行できます。

00:16:11.000 --> 00:16:14.000
それは、ターゲットを構築するステップを並列化するためのものです。

00:16:14.000 --> 00:16:18.000
今、アルテムは多くのターゲットを構築する並列化の謎を解くつもりです。

00:16:18.000 --> 00:16:20.000
アルテム:ありがとう、ベン。

00:16:20.000 --> 00:16:38.000
プロジェクトでターゲットを構築する可能性のあるビルドシステムタスクとフェーズの基本をカバーしたので、よりグローバルなビューを取り、XcodeがSwiftターゲット間の依存関係を使用してビルドから最大量の並列性を抽出する方法と、プロジェクトの構造と組織がビルド時間にどのように影響するかを探りましょう。

00:16:38.000 --> 00:16:41.000
プロジェクトを構成するいくつかのレベルの階層がある可能性があります。

00:16:41.000 --> 00:16:49.000
たとえば、ローカルライブラリのコレクションに応じて、アプリターゲットは、セマンティック境界に沿って、いくつかのフレームワークでターゲットに分割されます。

00:16:49.000 --> 00:16:57.000
各ターゲットには、多くの異なるビルドフェーズとステップが含まれており、他のターゲットのビルドフェーズとの間でファイルの依存関係を生成および消費します。

00:16:57.000 --> 00:17:04.000
プロジェクトのサイズが大きくなるにつれて、これらのタスクグラフはサイズと複雑さが増す傾向があります。

00:17:04.000 --> 00:17:11.000
Xcodeビルドシステムはこれらの階層を平坦化しながら、すべてのターゲットの構築フェーズに対応するタスクの海にビルドを分解します。

00:17:11.000 --> 00:17:15.000
Swiftターゲットにとって特別なタスクの1つは、コンパイルです。

00:17:15.000 --> 00:17:26.000
Swiftターゲットのソースコードをバイナリ製品に構築することは、通常、ビルド計画、コンパイル、およびリンクのための多くのサブタスクで構成される複雑な操作です。

00:17:26.000 --> 00:17:32.000
これらのタスクの調整は、Xcodeツールチェーンの専用ツールであるSwift Driverに委任されます。

00:17:32.000 --> 00:17:39.000
ドライバーは、ターゲットのソースコードに必要なコンパイラとリンカーの呼び出しをいつ、どのように構築するかについての専門的な知識を持っています。

00:17:39.000 --> 00:17:45.000
Swiftコードを含むターゲットは、コード配布の単位であるモジュールにも対応します。

00:17:45.000 --> 00:17:52.000
このターゲットのパブリックインターフェイスをキャプチャするバイナリモジュールファイルは、ダウンストリームターゲットがコンパイルを開始するために必要なビルド製品です。

00:17:52.000 --> 00:17:58.000
Swift Driverがターゲットの1つを構築するために何をするかの例を詳しく見てみましょう。

00:17:58.000 --> 00:18:02.000
あなたのターゲットは、おそらくいくつかのソースファイルのコレクションで構成されています。

00:18:02.000 --> 00:18:10.000
リリースまたは最適化されたビルドでは、ドライバーは最適化の機会を最大化するために、すべてのソースファイルを含む1つのコンパイラタスクをスケジュールします。

00:18:10.000 --> 00:18:15.000
この単一のコンパイルタスクは、ターゲットのSwiftモジュールも生成します。

00:18:15.000 --> 00:18:26.000
デバッグまたは増分コンパイルモードでは、Swift Driverは必要なコンパイル作業を並行して実行できる小さなサブタスクに分解し、そのうちのいくつかは増分ビルドで再実行する必要がない場合があります。

00:18:26.000 --> 00:18:33.000
Swiftモジュールを作成するには、各コンパイルタスクの部分的な中間製品をマージするための追加のステップが必要です。

00:18:33.000 --> 00:18:45.000
この例のように、ターゲット内のソースファイルの数が多い場合、ビルドシステムのヒューリスティックに従って、個々のファイルがバッチコンパイルサブタスクに割り当てられることもあります。

00:18:45.000 --> 00:18:52.000
ビルドログは、どのソースファイルがバッチコンパイルジョブに割り当てられるかを強調表示し、各ファイルの診断に個別のエントリがあります。

00:18:52.000 --> 00:19:04.000
ターゲットのビルドを異なるソースファイル間で並列化できることは、より高速で小規模な増分ビルドの両方にとって非常に重要ですので、デバッグビルドが増分コンパイルモード設定を使用していることを確認してください。

00:19:04.000 --> 00:19:22.000
Xcode 14の前に、XcodeビルドシステムとSwiftドライバーの境界のために、ターゲットビルドフェーズのオーケストレーション、および各ターゲットのドライバーインスタンスによって生成されたコンパイルサブタスクは、互いに独立して発生し、各コンポーネントは利用可能なシステムリソースを最大限に活用するために最善を尽くしました。

00:19:22.000 --> 00:19:30.000
この例では、グラフを構築し、お互いに関してコンパイルフェーズのスケジューリングに入るものを深く掘り下げてみましょう。

00:19:30.000 --> 00:19:39.000
先に学んだように、Swiftのターゲット依存関係は、扶養家族に扶養家族のパブリックインターフェイスをキャプチャするバイナリモジュールファイルを提供させることによって解決されます。

00:19:39.000 --> 00:19:50.000
これらの依存関係を解決すると、各ターゲットのトップレベルのSwift Driverタスクと個々のサブタスクを示すタイムラインでキャプチャされた次の順序につながります。

00:19:50.000 --> 00:19:58.000
Xcode 14では、Swift Driverのまったく新しい実装（それ自体がSwiftで書かれている）のおかげで、ビルドシステムとコンパイラは完全に統合されています。

00:19:58.000 --> 00:20:05.000
Xcodeビルドシステムは、コードをコンパイルするために実行する必要があるすべてのタスクの中央スケジューラとして機能します。

00:20:05.000 --> 00:20:20.000
この中央計画メカニズムにより、Xcodeはきめ細かいスケジューリングの決定を行うことができ、プロジェクトの構築がCPUを過剰購読し、システム全体のパフォーマンスを低下させることなく、利用可能なリソースのみを使用することを保証します。

00:20:20.000 --> 00:20:30.000
そして、以前はXcode Build Systemの範囲外のサブタスクの島のコレクションだったものが、現在は完全にビルドシステムのスケジューラのドメインにあります。

00:20:30.000 --> 00:20:37.000
中央タスクプール内のすべての個々のサブタスクでは、ビルドスケジューラによって行われたトレードオフを考慮することが重要です。

00:20:37.000 --> 00:20:49.000
たとえば、8コアマシンでは、スケジューラのデフォルトは、利用可能なタスク（依存関係が満たされ、準備ができているタスク）を8つの利用可能な実行スロットの1つに割り当てることです。

00:20:49.000 --> 00:20:55.000
スロットの1つが解放されるとすぐに、ビルドシステムはより優れた作業でそれを埋めようとします。

00:20:55.000 --> 00:20:59.000
より高いコアカウントのマシンでは、より多くの同時作業を実行できます。

00:20:59.000 --> 00:21:11.000
しかし、それは、より多くの作業を実行するために利用可能なアイドルコアを持つ可能性が高いことを意味しますが、未処理のタスクはすべて、現在飛行中または待機している他のタスクによって生成されるように、まだ入力を待っています。

00:21:11.000 --> 00:21:17.000
新しい統合ビルドシステムにより、スケジューラはこのアイドル時間を大幅に短縮できます。

00:21:17.000 --> 00:21:25.000
方法を確認するために、コンパイル、バイナリモジュールファイルに対するターゲットの依存関係がどのように解決されるかを再検討しましょう。

00:21:25.000 --> 00:21:32.000
先に説明したように、コンパイルサブタスクの部分的な結果は、ターゲットの最終モジュール製品にマージされます。

00:21:32.000 --> 00:21:36.000
この製品が利用可能になると、ダウンストリームターゲットがコンパイルを開始する可能性があります。

00:21:36.000 --> 00:21:46.000
Xcode 14とSwift 5.7の新機能で、ターゲットのモジュールの構築は、すべてのプログラムソースファイルから直接別のエミッタモジュールタスクで行われます。

00:21:46.000 --> 00:21:55.000
これは、ターゲットの依存関係が、依存関係ターゲットの他のすべてのコンパイラタスクを待つことなく、エミトモジュールタスクが完了するとすぐにコンパイルを開始できることを意味します。

00:21:55.000 --> 00:22:08.000
ダウンストリームターゲットコンパイルのブロックをはるかに早く解除できるため、アイドルCPUコアで利用可能な作業を待つ時間を短縮できます。これは、ビルドタイムラインのアクティビティの拍車の間の空きスペースです。

00:22:08.000 --> 00:22:22.000
これをプロジェクトの残りの部分に拡張すると、同様の量の全体的な作業を行っていますが、ビルドシステムはコンピュータのリソースをより効率的に使用でき、多くの場合、ビルドを大幅に迅速に完了することができます。

00:22:22.000 --> 00:22:28.000
次に、Swift-Eager Linkingを構築するときにビルドシステムが実行できる2番目のクロスターゲット最適化を見てみましょう。

00:22:28.000 --> 00:22:34.000
前の例に基づいて、ビルドの重要なパスにある各ターゲットのリンカータスクを追加しました。

00:22:34.000 --> 00:22:46.000
この場合、ターゲットBはターゲットAをリンクするため、ターゲットBのリンクタスクは、ターゲットAのリンク出力が生成され、独自のコンパイルタスクが完了してから実行されるのを待つ必要があります。

00:22:46.000 --> 00:22:53.000
しかし、熱心なリンクでは、ターゲットBのリンクタスクは、代わりにターゲットAのエミトモジュールタスクに依存することができます。

00:22:53.000 --> 00:23:01.000
その結果、ターゲットBはビルドの早い段階でリンクを開始し、ターゲットAをリンクしてクリティカルパスを短縮することと並行して実行できます。

00:23:01.000 --> 00:23:03.000
これはどのように機能しますか?

00:23:03.000 --> 00:23:09.000
通常、リンクされた製品依存関係を持つ2つのターゲットの依存関係グラフは次のようになります。

00:23:09.000 --> 00:23:16.000
依存ターゲットをリンクするには、ターゲット独自のコンパイル出力に加えて、その依存関係のリンクされた製品が必要です。

00:23:16.000 --> 00:23:23.000
熱心にリンクすると、この依存関係は壊れ、依存ターゲットが早期にリンクを開始できます。

00:23:23.000 --> 00:23:33.000
依存関係のリンクされた生成物に依存するのではなく、エミッタモジュールタスクによってビルドプロセスの早い段階で生成されたテキストベースの動的ライブラリスタブに依存するようになりました。

00:23:33.000 --> 00:23:38.000
このスタブには、扶養家族が使用するためにリンクされた製品に表示されるシンボルのリストが含まれています。

00:23:38.000 --> 00:23:42.000
画面に表示されるXcodeビルド設定を使用して、この最適化を有効にできます。

00:23:42.000 --> 00:23:47.000
Eager Linkingは、扶養家族によって動的にリンクされているすべての純粋なSwiftターゲットに適用されます。

00:23:47.000 --> 00:23:57.000
要約すると、Xcodeビルドシステムは、ビルドフェーズを並行して実行することで、できるだけ多くの並列性を抽出しようとする洗練されたスケジューリングエンジンです。

00:23:57.000 --> 00:24:03.000
また、スクリプトサンドボックスなどの機能により、ビルドが最大限に並列で信頼性が高いことを確認できます。

00:24:03.000 --> 00:24:06.000
XcodeとSwiftはこれまで以上に統合されています。

00:24:06.000 --> 00:24:25.000
そして、プロジェクト構造：そのモジュール化、ターゲット製品間の依存関係で構成されるグラフの全体的な形状、およびそれらの中のビルドフェーズの数と複雑さ、マシンの利用可能な計算リソースと組み合わせる - これらはすべて、Xcodeがビルドを並列化して高速化できる程度に寄与する要因です。

00:24:25.000 --> 00:24:33.000
この知識とビルドタイムラインなどの強力な新しいツールを使用すると、プロジェクトを調査し、ビルドに関する洞察を得ることができます。

00:24:33.000 --> 00:24:41.000
そして、舞台裏の技術的な詳細をさらに知りたい場合は、Xcodeで使用されている私たちが説明した技術の多くはオープンソースで開発されています。

00:24:41.000 --> 00:24:46.000
以下のリンクで、GitHubでSwift Driverのリポジトリを見つけることができます。

00:24:46.000 --> 00:24:51.000
Xcodeに関するより素晴らしいセッションについては、「Xcodeの新機能」で今年のすべての新機能と改善点をチェックしてください。

00:24:51.000 --> 00:24:59.000
そして、Xcode 14のリンカーがセッション「リンク高速：ビルドと起動時間を改善する」でリンク時間を最大2回改善する方法を学びます。

00:24:59.000 --> 00:25:00.000
フォローしてくれてありがとう。

00:25:00.000 --> 00:25:03.000
Xcodeのビルドに関する新しい洞察を学んでいただければ幸いです。

00:25:03.000 --> 00:25:06.000
あなたが何を作るのかを見るのが待ちきれません。

00:25:06.000 --> 23:59:59.000
会議の素晴らしい残りをお過ごしください。

