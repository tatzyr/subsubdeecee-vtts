WEBVTT

00:00:00.000 --> 00:00:03.000
♪まろやかなインストゥルメンタルヒップホップ音楽♪

00:00:03.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:13.000
こんにちは、セッション「Meet Transferable」へようこそ。

00:00:13.000 --> 00:00:26.000
私の名前はジュリアです。私はSwiftUIのエンジニアであり、アプリのドラッグアンドドロップ、コピー/ペースト、その他の機能をサポートする宣言的な方法であるTransferableを紹介することに興奮しています。

00:00:26.000 --> 00:00:34.000
SwiftUIやMac用のアプリケーションの開発とは別に、コンピュータサイエンスの女性の物語にも興味があります。

00:00:34.000 --> 00:00:38.000
ヒーローを知ることは重要だと思います。

00:00:38.000 --> 00:00:50.000
そこで、女性発明家、エンジニア、科学者のプロフィールのリストを表示、追加、編集できるカタログアプリケーションを作成することにしました。

00:00:50.000 --> 00:01:04.000
このアプリケーションは、アプリとの間の科学者の肖像画のドラッグアンドドロップをシームレスにサポートし、クリップボードのコンテンツを使用して興味深い事実を貼り付けることができるようにしたい。

00:01:04.000 --> 00:01:10.000
そして初めて、私のアプリはwatchOSでの共有をサポートできます!

00:01:10.000 --> 00:01:17.000
私の潜在的なユーザーは、時計からパーソナリティプロフィールを共有したいと言っています。

00:01:17.000 --> 00:01:29.000
また、SwiftUIを介して、共有はiOSとMacで利用可能になり、今年ShareSheetのこの真新しいデザインも手に入れました。

00:01:29.000 --> 00:01:42.000
ボンネットの下では、これらすべての機能を有効にするには、アプリ内または他のアプリケーションで受信者に送信されることをすでにサポートしなければならないモデルが必要です。

00:01:42.000 --> 00:01:49.000
プロフィール構造には、単一の人格に関するすべての情報が含まれています。

00:01:49.000 --> 00:01:54.000
アーカイブにパックされたすべてのプロフィールは、友達間で共有できます。

00:01:54.000 --> 00:02:01.000
私たちは、ひもで人格についての楽しい事実を保存し、ビデオを添付することさえできます。

00:02:01.000 --> 00:02:07.000
そして、これらすべてのモデルタイプを共有するための素晴らしい新しい簡単な方法があります。

00:02:07.000 --> 00:02:09.000
譲渡可能に会いましょう!

00:02:09.000 --> 00:02:20.000
これは、共有とデータ転送のためにモデルをシリアライズおよびデシリアライズする方法を説明するスウィフトファーストの宣言的な方法です。

00:02:20.000 --> 00:02:40.000
今日は、Transferableとは何か、それを使用するときに舞台裏で何が起こっているのかについて話します。カスタムタイプに適合する方法。最後に、必要なことを正確に行うためにTransferableをカスタマイズするのに役立ついくつかの高度なヒントとコツを共有します。

00:02:40.000 --> 00:02:43.000
始めましょう！

00:02:43.000 --> 00:02:58.000
2つのアプリケーションが実行されており、ユーザーがコピー/ペースト、ShareSheet、ドラッグ、または他のアプリ機能を使用して、あるアプリから別のアプリに情報を渡したいとします。

00:02:58.000 --> 00:03:05.000
2つの異なるアプリ間で何かを送信すると、このすべてのバイナリデータがあります。

00:03:05.000 --> 00:03:12.000
このデータを送信する際の重要な部分は、それが何に対応するかを決定することです。

00:03:12.000 --> 00:03:21.000
それはテキスト、ビデオ、私のお気に入りの女性エンジニアのプロフィール、またはアーカイブ全体かもしれません。

00:03:21.000 --> 00:03:26.000
そして、データの提供を記述するUTTypeがあります。

00:03:26.000 --> 00:03:31.000
アプリがこのバイナリデータを生成する方法を詳しく見てみましょう。

00:03:31.000 --> 00:03:55.000
他のアプリと共有できるすべてのタイプ、または単一のアプリケーション内でも、2つの情報を提供する必要があります。バイナリデータとの間で変換する方法と、バイナリデータの構造に対応し、実際に得たものを受信者に伝えるコンテンツタイプです。

00:03:55.000 --> 00:04:07.000
コンテンツタイプ（統一型識別子とも呼ばれる）は、さまざまなバイナリ構造の識別子と抽象的な概念を記述するApple固有の技術です。

00:04:07.000 --> 00:04:13.000
識別子はツリーを形成し、カスタム識別子を定義することもできます。

00:04:13.000 --> 00:04:18.000
たとえば、プロファイルで使用されるバイナリ構造用です。

00:04:18.000 --> 00:04:26.000
カスタム識別子を宣言するには、まずその宣言をInfo.plistファイルに追加します。

00:04:26.000 --> 00:04:30.000
また、ファイル拡張子を追加するのも良い考えです。

00:04:30.000 --> 00:04:37.000
データがディスクに保存されている場合、システムはアプリがそのファイルを開くことができることを知るでしょう。

00:04:37.000 --> 00:04:40.000
第二に、コードで宣言します。

00:04:40.000 --> 00:04:49.000
コンテンツタイプの詳細については、「Uniform Type Identifiers -- A reintroduction」というビデオをご覧ください。

00:04:49.000 --> 00:04:58.000
個人的には、私はそれが大好きで、それは均一な型識別子とは何か、そしてそれらをどのように使用するかを明確に提供します。

00:04:58.000 --> 00:05:10.000
良いニュースは、多くの標準タイプがすでにTransferableに準拠していることです。例えば、文字列、データ、URL、帰属文字列、画像。

00:05:10.000 --> 00:05:27.000
新しいSwiftUIペーストボタンインターフェイスを使用してプロフィールに楽しい事実を貼り付けたり、ビューから画像をドラッグしたり、Finderや他のアプリからドロップされた画像を受信したりするには、数行のコードが必要です。

00:05:27.000 --> 00:05:34.000
brと新しいShareLinkを使用して、ウォッチからの共有体験を実装できるようになりました。

00:05:34.000 --> 00:05:40.000
私たちは基本をカバーしました、そして今、あなたはTransferableの使い方とそれが何であるかのアイデアを持っています。

00:05:40.000 --> 00:05:47.000
アプリケーションのモデルに譲渡可能な適合性を追加する方法を見てみましょう。

00:05:47.000 --> 00:05:54.000
先に述べたように、私たちのアプリには共有される4つのモデルタイプがあります。

00:05:54.000 --> 00:06:01.000
そのうちの1つである文字列は、すでにTransferableに準拠しています。これ以上何もする必要はありません。

00:06:01.000 --> 00:06:09.000
しかし、単一のプロフィール、ProfilesArchive、そして私が共有したいビデオはどうですか?

00:06:09.000 --> 00:06:17.000
Transferableにタイプを適合させるために、実装するプロパティは1つだけです。TransferRepresentationです。

00:06:17.000 --> 00:06:22.000
モデルがどのように転送されるかを説明しています。

00:06:22.000 --> 00:06:31.000
CodableRepresentation、DataRepresentation、FileRepresentationの3つの重要な表現に注意する必要があります。

00:06:31.000 --> 00:06:34.000
それぞれについて話しましょう。

00:06:34.000 --> 00:06:39.000
しかし、まず、私たちの中心モデルであるプロファイル構造に会いましょう。

00:06:39.000 --> 00:06:46.000
それはID、名前、略歴、おそらくいくつかの楽しい事実、肖像画、そしてビデオを持っています。

00:06:46.000 --> 00:06:48.000
それはすでにCodableに準拠しています。

00:06:48.000 --> 00:06:56.000
そのため、Transferable conformanceにCodableRepresentationを含めることができます。

00:06:56.000 --> 00:07:05.000
コーディング可能な表現は、エンコーダを使用してプロファイルをバイナリデータに変換し、デコーダを使用して元に戻します。

00:07:05.000 --> 00:07:12.000
デフォルトではJSONを使用しますが、独自のエンコーダとデコーダのペアを提供することもできます。

00:07:12.000 --> 00:07:26.000
Codableプロトコルとエンコーダとデコーダの仕組みの詳細については、このプロトコルが最初に導入されたWWDCセッション「信頼できるデータ」をご覧ください。

00:07:26.000 --> 00:07:28.000
私たちのプロフィールに戻ります。

00:07:28.000 --> 00:07:34.000
Codableに必要なのは、目的のコンテンツタイプを知ることだけです。

00:07:34.000 --> 00:07:41.000
これはカスタム形式になるため、カスタム宣言されたユニフォーム型識別子を使用します。

00:07:41.000 --> 00:07:45.000
プロフィールのコンテンツタイプを追加したら、大丈夫です。

00:07:45.000 --> 00:07:49.000
プロファイルがTransferableに準拠しました!

00:07:49.000 --> 00:07:54.000
さて、別のケースを見てみましょう：ProfilesArchive。

00:07:54.000 --> 00:07:58.000
すでにCSVデータへの変換をサポートしています。

00:07:58.000 --> 00:08:08.000
女性プロファイルのリストをCSVファイルにエクスポートし、友人と共有したり、別のコンピュータにインポートしたりできます。

00:08:08.000 --> 00:08:18.000
アーカイブはデータとの間で変換でき、DataRepresentationを使用できることを意味します。

00:08:18.000 --> 00:08:30.000
中を覗くと、DataRepresentationが変換関数を使用してバイナリ表現を直接作成し、受信者の値を再構築することがわかります。

00:08:30.000 --> 00:08:36.000
これは、DataRepresentationを使用してTransferableに準拠するのがいかに簡単かです。

00:08:36.000 --> 00:08:46.000
必要なのは、すでに持っている2つの関数を呼び出すだけです。初期化子とCSVへのコンバーターです。

00:08:46.000 --> 00:08:53.000
パーソナリティプロフィールにビデオが添付されている場合は、ドラッグまたは共有できるようにしたいです。

00:08:53.000 --> 00:08:58.000
しかし、ビデオは大きくなる可能性があります。私はそれをメモリにロードしたくありません。

00:08:58.000 --> 00:09:02.000
ここでFileRepresentationの出番です。

00:09:02.000 --> 00:09:14.000
また、カーテンを持ち上げると、FileRepresentationが提供されたURLを受信者に渡し、それを使用して転送可能なアイテムを再構築することがわかります。

00:09:14.000 --> 00:09:23.000
FileRepresentationを使用すると、disk: fileに書き込まれたバイナリ表現に裏打ちされたアイテムを共有できます。

00:09:23.000 --> 00:09:25.000
要約しましょう。

00:09:25.000 --> 00:09:37.000
単純なユースケースで単一の表現だけを選択する場合は、まずモデルにコード可能な適合性があり、特定のバイナリ形式の要件がないかどうかを確認してください。

00:09:37.000 --> 00:09:40.000
その場合は、CodableRepresentationを使用してください。

00:09:40.000 --> 00:09:45.000
そうでない場合は、メモリに保存されているか、ディスクに保存されているかを確認してください。

00:09:45.000 --> 00:09:51.000
DataRepresentationは前者に最も適しており、FileRepresetnationは後者に最適です。

00:09:51.000 --> 00:09:57.000
Transferableは、単純なユースケースだけでなく、複雑なユースケースもカバーすることを目的としています。

00:09:57.000 --> 00:10:01.000
そして、ほとんどの場合、ほんの数行のコードで。

00:10:01.000 --> 00:10:04.000
自分で見て！

00:10:04.000 --> 00:10:10.000
以前は、プロファイルに譲渡可能な適合性を追加しましたが、さらに進めましょう。

00:10:10.000 --> 00:10:19.000
プロファイルがペーストボードにコピーされ、任意のテキストフィールドに貼り付けられたら、プロファイルの名前を貼り付けます。

00:10:19.000 --> 00:10:23.000
これは、別の表現を追加する必要があることを意味します。

00:10:23.000 --> 00:10:29.000
ProxyRepresentationは、他のTransferableタイプが私たちのモデルを表すことを可能にします。

00:10:29.000 --> 00:10:34.000
1行、およびプロファイルはテキストとして貼り付けることができます。

00:10:34.000 --> 00:10:41.000
Codableの後にProxyRepresentationを追加したことに注意してください。順序は重要です。

00:10:41.000 --> 00:10:47.000
受信者は、サポートするコンテンツタイプで最初の表現を使用します。

00:10:47.000 --> 00:10:52.000
受信者がカスタムコンテンツタイプのプロファイルを認識している場合は、それを使用する必要があります。

00:10:52.000 --> 00:11:00.000
そうでないが、テキストをサポートしている場合は、代わりにProxyRepresentationを使用させてください。

00:11:00.000 --> 00:11:07.000
現在、プロファイルはエンコーダ/デコーダ変換とテキストへの変換の両方をサポートしています。

00:11:07.000 --> 00:11:15.000
この場合のProxyRepresentationは、テキストへのエクスポートのみを記述しますが、そこからプロファイルの再構築は説明しません。

00:11:15.000 --> 00:11:20.000
どの表現でも、両方の変換、または1つだけを記述できます。

00:11:20.000 --> 00:11:28.000
さて、ProxyRepresentationsについて知ったら、ビデオのFileRepresentationが本当に必要ですか?

00:11:28.000 --> 00:11:31.000
URL付きのプロキシを持つことができます。

00:11:31.000 --> 00:11:33.000
違いは微妙です。

00:11:33.000 --> 00:11:46.000
FileRepresentationは、ディスクに書き込まれたURLを操作し、一時的なサンドボックス拡張子を付与することにより、このファイルまたはそのコピーへの受信者のアクセスを確保することを目的としています。

00:11:46.000 --> 00:11:53.000
ProxyRepresentationは、文字列のような他の転送可能なアイテムと同じようにURLを扱います。

00:11:53.000 --> 00:11:58.000
ファイルに必要な追加機能はありません。これは、いかなる機能も備えていません。

00:11:58.000 --> 00:12:01.000
それは私たちが両方を持つことができることを意味します。

00:12:01.000 --> 00:12:08.000
最初のFileRepresentationは、受信者がその内容を含むムービーファイルにアクセスできるようにします。

00:12:08.000 --> 00:12:15.000
2つ目は、コピーしたビデオをテキストフィールドに貼り付けると機能します。

00:12:15.000 --> 00:12:21.000
したがって、URLはファイルとプロキシの表現によって非常に異なって扱われます。

00:12:21.000 --> 00:12:35.000
最初のケースでは、実際のペイロードはディスク上のアセットであり、2番目のケースでは、ペイロードはリモートWebサイトを指すことができるURL構造自体です。

00:12:35.000 --> 00:12:39.000
アップグレードしたいもう1つのモデルはProfilesArchiveです。

00:12:39.000 --> 00:12:46.000
CSVへの変換をサポートしていない場合があり、それをコードに反映したいと思います。

00:12:46.000 --> 00:12:48.000
見てみましょう。

00:12:48.000 --> 00:12:57.000
CSVにエクスポートできるかどうかと、データとの間で変換関数を知らせるブールプロパティを追加します。

00:12:57.000 --> 00:13:03.000
このアイデアをコードで表現するには、.exportingConditionを使用できます。

00:13:03.000 --> 00:13:09.000
指定されたアーカイブがCSVをサポートしていない場合、この形式ではエクスポートされません。

00:13:09.000 --> 00:13:16.000
このAPIを使用すると、SwiftUIのカスタムビューと同様に、カスタムTransferRepresentationを構築することもできます。

00:13:16.000 --> 00:13:24.000
唯一の要件は、必要に応じて他の表現を構成できるボディプロパティを提供することです。

00:13:24.000 --> 00:13:35.000
表現の組み合わせを再利用したい場合や、公開したくないプライベートデータ表現がある場合に便利です。

00:13:35.000 --> 00:13:42.000
Transferableは、私が望んでいたすべての機能でこのアプリケーションをすばやく構築するのに役立ちました。

00:13:42.000 --> 00:13:49.000
これまで以上に短い時間で機能豊富なアプリを構築するのに役立つことを願っています。

00:13:49.000 --> 00:13:54.000
このセッションに参加してくれてありがとう、素晴らしいアプリを作り続けてください!

00:13:54.000 --> 23:59:59.000
♪

