WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:15.000
ジェレミー:こんにちは。私はジェレミーです。AVFoundationを使用して、より応答性の高いメディアアプリを作成する方法を紹介します。

00:00:15.000 --> 00:00:19.000
アプリでメディアアセットを使用する場合は、単に再生する以上のことをしたいかもしれません。

00:00:19.000 --> 00:00:28.000
サムネイルを表示したり、メディアを新しいコンポジションに結合したり、アセットに関する情報を入手したりしたいと思っています。

00:00:28.000 --> 00:00:35.000
これらのタスクにはデータの読み込みが必要で、ビデオのような大きなファイルでは、完了までに時間がかかる場合があります。

00:00:35.000 --> 00:00:42.000
残念ながら、この作業がメインスレッドで同期的に行われる場合、アプリにレイテンシの問題を導入するのは簡単です。

00:00:42.000 --> 00:00:48.000
アプリの応答性を維持するための素晴らしい方法は、データを非同期にロードし、完了したらUIを更新することです。

00:00:48.000 --> 00:00:51.000
AVFoundationには、これを簡単にするためのツールがあります。

00:00:51.000 --> 00:00:53.000
だから、今日私たちが話すことは次のとおりです。

00:00:53.000 --> 00:00:58.000
まず、AVFoundationの新しい非同期APIを紹介します。

00:00:58.000 --> 00:01:04.000
次に、昨年導入したasync load(_:)メソッドを使用して、資産検査に関する最新情報を提供します。

00:01:04.000 --> 00:01:10.000
また、AVAssetResourceLoaderを使用して、ローカルおよびキャッシュされたメディアのカスタムデータ読み込みを最適化する方法を紹介します。

00:01:10.000 --> 00:01:14.000
しかし、まず、新しい非同期APIに飛び込みましょう。

00:01:14.000 --> 00:01:20.000
AVAssetImageGeneratorでビデオから静止画をつかむことは、サムネイルを作成するのに最適な方法です。

00:01:20.000 --> 00:01:24.000
しかし、画像の生成は瞬間的ではありません。

00:01:24.000 --> 00:01:29.000
画像を生成するには、画像ジェネレータはビデオファイルからフレームデータをロードする必要があります。

00:01:29.000 --> 00:01:35.000
また、リモートサーバーまたはインターネットに保存されているメディアの場合、その読み込みははるかに遅くなります。

00:01:35.000 --> 00:01:39.000
そのため、画像をどのように生成するかが重要です。

00:01:39.000 --> 00:01:48.000
メインスレッドでcopyCGImageのようにデータを同期的にロードする方法を使用すると、ビデオが読み込まれるのを待つときにUIがフリーズする可能性があります。

00:01:48.000 --> 00:01:56.000
今年は、画像ジェネレータがデータをロードしている間、async/awaitを使用して呼び出しスレッドを解放するimage(at: time)asyncメソッドを追加しました。

00:01:56.000 --> 00:02:01.000
画像ジェネレーターは、画像とアセット内の実際の時間を含むタプルを返します。

00:02:01.000 --> 00:02:10.000
実際の時間がリクエストした時間とはいくつかの理由がありますが、画像のみが必要な場合は、.imageプロパティで直接アクセスできます。

00:02:10.000 --> 00:02:14.000
圧縮ビデオの一部のフレームは、他のフレームよりも読み込まれやすい。

00:02:14.000 --> 00:02:20.000
iFrameは独立してデコードできますが、他のフレームは近くのフレームに依存してデコードできます。

00:02:20.000 --> 00:02:26.000
要求された時間に対して、デフォルトで画像ジェネレータは最も近いiFrameを使用して画像を生成します。

00:02:26.000 --> 00:02:31.000
要求された時間の正確なフレームを取得するために、公差をゼロに設定するのは魅力的かもしれません。

00:02:31.000 --> 00:02:39.000
しかし、そのフレームは、画像ジェネレータもロードする必要がある他の近くのフレームに依存する可能性が高いことを覚えておいてください。

00:02:39.000 --> 00:02:44.000
代わりに、まだあなたが探している結果を与える広い公差を設定することを検討してください。

00:02:44.000 --> 00:02:49.000
広い公差は、より多くのフレームを選択することで、画像ジェネレータがデータの読み込みを最小限に抑えるのに役立ちます。

00:02:49.000 --> 00:02:54.000
読み込みに必要なフレームが少なければ少ないほど、画像を返すのが速くなります。

00:02:54.000 --> 00:03:02.000
アセットで数回一連の画像を取得するために、画像ジェネレータはgenerateCGImagesAsynchronously(forTimes:)を持っています。

00:03:02.000 --> 00:03:06.000
しかし、Swiftでは、それを使用するために注意すべきニュアンスがあります。

00:03:06.000 --> 00:03:10.000
今年新しく、画像(for: times)メソッドを追加しました。

00:03:10.000 --> 00:03:15.000
CMTimesの配列が必要なので、最初にNSValuesにマッピングする必要はありません。

00:03:15.000 --> 00:03:18.000
また、非同期シーケンスを使用して結果を提供します。

00:03:18.000 --> 00:03:23.000
Swiftでは、シーケンスでは、for in loopを使用してアイテムを反復処理できます。

00:03:23.000 --> 00:03:31.000
一度に準備ができていないアイテムのシーケンスの場合、非同期シーケンスを使用すると、各反復の後に次の要素を待つことができます。

00:03:31.000 --> 00:03:39.000
正常に生成された各画像について、結果には最初に要求された時間と画像と並んで実際の時間が含まれます。

00:03:39.000 --> 00:03:44.000
失敗した場合、結果には理由を説明するエラーがあります。

00:03:44.000 --> 00:03:54.000
また、画像にのみ興味がある場合、結果にはその値に直接アクセスするプロパティがあり、生成が失敗した場合にもエラーが発生する可能性があります。

00:03:54.000 --> 00:03:59.000
非同期シーケンスの詳細については、「非同期シーケンスを満たす」セッションをチェックすることをお勧めします。

00:03:59.000 --> 00:04:03.000
画像生成のようなタスクでは、データの読み込みがどのように含まれるかを確認するのが少し簡単です。

00:04:03.000 --> 00:04:09.000
しかし、AVFoundationには、問題のあるスポットとして選ぶのが難しい他の同期領域がいくつかあります。

00:04:09.000 --> 00:04:13.000
AVMutableCompositionはこれらの分野の1つです。

00:04:13.000 --> 00:04:19.000
コンポジションにそれらへの参照を追加するために、アセットのトラックに関する資産ニーズ情報の時間範囲を挿入します。

00:04:19.000 --> 00:04:29.000
トラックを同期的に検査するので、トラックがまだロードされていない場合は、同期的にロードされ、新しいコンポジショントラックが作成されます。

00:04:29.000 --> 00:04:36.000
以前は、アセットのトラックをコンポジションに挿入する前に、アセットのトラックを読み込むのを待つことが解決策でした。

00:04:36.000 --> 00:04:46.000
しかし、今年は、必要に応じてトラックを非同期にロードするinsertTimeRangeの非同期バージョンを導入します。

00:04:46.000 --> 00:04:53.000
ビデオコンポジションと可変ビデオコンポジションには、アセットのプロパティをロードする必要がある追加の方法もあります。

00:04:53.000 --> 00:05:01.000
今年の新機能、「propertiesOf asset」コンストラクタとisValid(for:timeRange:)メソッドも非同期のカウンターパートを持つようになりました。

00:05:01.000 --> 00:05:08.000
これらの新しいメソッドは、アセットのトラックと期間を非同期にロードするので、それらをプリロードする必要はありません。

00:05:08.000 --> 00:05:14.000
これらの新しい非同期メソッドは、必要なプロパティを非同期にロードすることで、アセットとのやり取りを容易にします。

00:05:14.000 --> 00:05:21.000
しかし、自分で資産のプロパティをロードする必要がある場合は、非同期資産検査の復習をしましょう。

00:05:21.000 --> 00:05:25.000
資産の財産を検査するには2つの方法があることに気づいたかもしれません。

00:05:25.000 --> 00:05:31.000
AVFoundationが導入されたとき、プロパティを検査する最善の方法は、非同期キー値の読み込みでした。

00:05:31.000 --> 00:05:34.000
昨年、非同期ロード(_:)を導入しました。

00:05:34.000 --> 00:05:43.000
タイプセーフキーを使用してロードするプロパティを識別し、古い非同期キー値のロード技術はハードコードされた文字列をキーとして使用しました。

00:05:43.000 --> 00:05:46.000
これらの文字列キーの誤字はキャッチしにくいです。

00:05:46.000 --> 00:05:54.000
キーのスペルミスは、それが非同期にロードされるのを防ぎ、プロパティが後で使用されると、ロード中にブロックされます。

00:05:54.000 --> 00:06:03.000
また、ロードするキーに新しいプロパティを追加するのを忘れたり、非同期のロードを完全に忘れたりすることも非常に簡単です。

00:06:03.000 --> 00:06:11.000
これらの理由から、今年は非同期キー値のロードとSwiftの同期プロパティを廃止し、非同期ロードを支持します。

00:06:11.000 --> 00:06:15.000
非同期ロードは、タイプセーフ識別子を使用してタイプミスを防ぎます。

00:06:15.000 --> 00:06:21.000
アンロードされたプロパティへのアクセスを避けるために、要求に応じてプロパティ値を直接返します。

00:06:21.000 --> 00:06:28.000
また、これらすべてがコンパイル時にチェックされるため、新しいIOバウンドパフォーマンスの問題の導入を防ぐことができます。

00:06:28.000 --> 00:06:38.000
非同期ロードは、AVAsset、AVAssetTrack、AVMetadataItem、およびそれらのサブクラスのプロパティを非同期に検査する唯一の推奨方法です。

00:06:38.000 --> 00:06:43.000
しかし、これらのクラスのほんの一握りは、引き続き同期プロパティ検査を提供します。

00:06:43.000 --> 00:06:48.000
それは、それらのプロパティのデータがすでにメモリ内で利用可能だからです。

00:06:48.000 --> 00:06:52.000
変更可能な構成をもう一度見て、その理由を見てみましょう。

00:06:52.000 --> 00:06:58.000
可変コンポジションを使用して、2つの既存のビデオトラックのセグメントをつなぎ合わせます。

00:06:58.000 --> 00:07:03.000
空のコンポジションを作成し、空のビデオトラックを追加することから始めます。

00:07:03.000 --> 00:07:09.000
次に、最初のビデオトラックの一部をコンポジショントラックに同期的に挿入できます。

00:07:09.000 --> 00:07:12.000
舞台裏では、このステップはデータをロードしていません。

00:07:12.000 --> 00:07:18.000
代わりに、目的のトラックを指す新しいトラックセグメントを追加します。

00:07:18.000 --> 00:07:23.000
その後、同じ方法で2番目のトラックの一部を追加できます。

00:07:23.000 --> 00:07:33.000
コンポジション自体はファイルではなくインメモリ構造によって裏打ちされているため、最初にロードすることなく、そのプロパティを安全に同期的に検査できます。

00:07:33.000 --> 00:07:44.000
繰り返しますが、このため、同期プロパティ検査はこれらのクラスで引き続き利用可能であり、すべてのクラスは非同期検査に非同期負荷を使用します。

00:07:44.000 --> 00:07:51.000
AVFoundationのこれらの新しい非同期メソッドはすべて、メディアデータの読み込み中にブロッキングを防ぐことが容易になります。

00:07:51.000 --> 00:07:55.000
しかし、初めてアプリに並行性を導入するのは難しいかもしれません。

00:07:55.000 --> 00:08:04.000
Swift並行性を使い始めるためのヘルプと、アプリでのAVFoundationの非同期ロードへの移行については、WWDC 21のこれらのセッションをチェックしてください。

00:08:04.000 --> 00:08:09.000
最後のトピックでは、アセットのカスタムデータ読み込みの最適化について話しましょう。

00:08:09.000 --> 00:08:13.000
まず、AVAssetがデフォルトでデータをロードする方法を見てみましょう。

00:08:13.000 --> 00:08:20.000
URLでAVAssetを作成すると、メディアはネットワーク上にあるか、デバイスにローカルに保存できます。

00:08:20.000 --> 00:08:27.000
ネットワーク上にある場合、AVAssetはスムーズな再生を確保するために一定量のデータを動的にキャッシュします。

00:08:27.000 --> 00:08:32.000
メディアがローカルの場合、AVAssetはキャッシュをバイパスし、再生するために必要に応じてデータをロードできます。

00:08:32.000 --> 00:08:37.000
場合によっては、AVAssetにメディアへの直接ポインタを与えることができない場合があります。

00:08:37.000 --> 00:08:42.000
Mp4の生のバイトをカスタムプロジェクトファイル内に格納するかもしれません。

00:08:42.000 --> 00:08:47.000
このような状況では、AVAssetはAVAssetResourceLoaderを使用できます。

00:08:47.000 --> 00:08:54.000
リソースローダーは、特別な方法でロードするメディアから任意のバイトを要求する方法をアセットに提供します。

00:08:54.000 --> 00:09:01.000
しかし、アセットはデータの読み取りを処理しなくなったため、各チャンクの読み込みにどれくらいの時間がかかるかを予測することはできません。

00:09:01.000 --> 00:09:09.000
したがって、メディアへのアクセスにはネットワーク通信が含まれることを前提とし、再生の準備が整う前にデータをキャッシュするまで待ちます。

00:09:09.000 --> 00:09:16.000
今年は、メディアがローカルで利用可能であれば、リソースローダーで全体LengthAvailableOnDemandを有効にすることができます。

00:09:16.000 --> 00:09:25.000
このフラグを設定すると、要求されたときにデータを受信することを期待できることをアセットに伝えるので、キャッシュをスキップできます。

00:09:25.000 --> 00:09:33.000
ローカルメディアの場合、 entireLengthAvailableOnDemandは、余分なデータをキャッシュする必要がないため、再生中のアプリのメモリ使用量を減らすのに役立ちます。

00:09:33.000 --> 00:09:39.000
また、アセットはキャッシュが最初にいっぱいになるのを待つ必要がないため、再生を開始するのにかかる時間を短縮することもできます。

00:09:39.000 --> 00:09:42.000
ただし、このフラグを有効にするときは注意してください。

00:09:42.000 --> 00:09:50.000
ロードにネットワークファイルストレージを含むネットワーク操作が必要な場合は、再生が信頼できない可能性があります。

00:09:50.000 --> 00:09:52.000
それがリソースローダーの新しい機能強化です。

00:09:52.000 --> 00:09:56.000
それでは、あなたのアプリの次のステップで物事をまとめましょう。

00:09:56.000 --> 00:10:02.000
メディアを操作するときは、async/awaitを使用して、バックグラウンドで読み込まれている間、アプリの応答性を維持します。

00:10:02.000 --> 00:10:07.000
より速い結果を得るために画像ジェネレータを使用する場合は、公差を増やすことを検討してください。

00:10:07.000 --> 00:10:15.000
また、ローカルで利用可能なメディアにリソースローダーを使用している場合は、オンデマンドで利用可能な全長を有効にして、パフォーマンスを向上させます。

00:10:15.000 --> 00:10:16.000
それは私が今日持っているすべてです。

00:10:16.000 --> 23:59:59.000
ご覧いただきありがとうございます。WWDC 22をお楽しみください。

