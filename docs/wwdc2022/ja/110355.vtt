WEBVTT

00:00:00.000 -> 00:00:09.000
♪インストゥルメンタルヒップホップ音楽♪

00:00:09.000 -> 00:00:11.000
こんにちは、私の名前はフィリップです。

00:00:11.000 -> 00:00:15.000
Swiftには、オープンソースパッケージのカタログが増えています。

00:00:15.000 -> 00:00:20.000
最新の追加案の1つであるSwift Async Algorithmsをご紹介します。

00:00:20.000 -> 00:00:26.000
このパッケージは、Swift CollectionsやSwift Algorithmsなどの他のパッケージと並んでいます。

00:00:26.000 -> 00:00:35.000
Swift Async Algorithmsパッケージは、AsyncSequenceを使用して時間の経過とともに値を処理することに特に焦点を当てた一連のアルゴリズムです。

00:00:35.000 -> 00:00:40.000
しかし、それに入る前に、少し時間を取ってAsyncSequenceを要約しましょう。

00:00:40.000 -> 00:00:45.000
AsyncSequenceは、非同期に生成された値を記述できるプロトコルです。

00:00:45.000 -> 00:00:50.000
基本的にはシーケンスに似ていますが、2つの重要な違いがあります。

00:00:50.000 -> 00:00:58.000
イテレータの次の関数は非同期で、Swift並行性を使用して値を配信できます。

00:00:58.000 -> 00:01:03.000
また、Swiftのスロー効果を使用して、潜在的な失敗を処理することもできます。

00:01:03.000 -> 00:01:09.000
そして、シーケンスと同様に、for-await-in構文を使用して反復することができます。

00:01:09.000 -> 00:01:15.000
要するに、Sequenceの使い方を知っていれば、すでにAsyncSequenceの使い方を知っています。

00:01:15.000 -> 00:01:24.000
さて、AsyncSequenceが導入されたとき、非同期バージョンでSequenceで見つけることが期待されるほとんどすべてのツールを追加しました。

00:01:24.000 -> 00:01:30.000
マップ、フィルター、縮小などのアルゴリズムがあります。

00:01:30.000 -> 00:01:41.000
Swift Async Algorithmsパッケージは、より高度なアルゴリズムを組み込むだけでなく、クロックと相互運用して本当に強力なものを提供することで、これをさらに一歩進めます。

00:01:41.000 -> 00:01:48.000
これは、Swiftの並行性を増強するAsyncSequenceアルゴリズムのオープンソースパッケージです。

00:01:48.000 -> 00:01:51.000
昨年、私たちはSwift Algorithmsパッケージを導入しました。

00:01:51.000 -> 00:01:55.000
これらのアルゴリズムの使用を実証するために、私たちはメッセージングアプリを作りました。

00:01:55.000 -> 00:02:00.000
これは、そのパッケージでできる豊かで強力なことのいくつかの素晴らしい例でした。

00:02:00.000 -> 00:02:07.000
私たちは、Swift並行性を使用するようにアプリを移行することを利用する多くの本当に良い機会があると判断しました。

00:02:07.000 -> 00:02:16.000
非同期アルゴリズムのいくつかを強調するために、私たちが使用したもののいくつかとそれらがどのように機能するかを説明します。

00:02:16.000 -> 00:02:21.000
まず、複数の入力AsyncSequencesを操作するためのアルゴリズムのファミリーがあります。

00:02:21.000 -> 00:02:27.000
これらは、AsyncSequencesをさまざまな方法で組み合わせることに焦点を当てたアルゴリズムです。

00:02:27.000 -> 00:02:36.000
しかし、それらはすべて1つの特徴を共有しています。複数の入力AsyncSequencesを取り、1つの出力AsyncSequenceを生成します。

00:02:36.000 -> 00:02:40.000
あなたがすでによく知っているかもしれないのはZipです。

00:02:40.000 -> 00:02:48.000
Zipアルゴリズムは複数の入力を受け取り、それらを反復して、各ベースから結果のタプルを生成します。

00:02:48.000 -> 00:02:52.000
Zipへの各入力は、Zipが構築されるベースです。

00:02:52.000 -> 00:03:04.000
非同期Zipアルゴリズムは、標準ライブラリのZipアルゴリズムと同じように機能しますが、各ベースを同時に反復し、反復処理中に障害が発生した場合にエラーを再度スローします。

00:03:04.000 -> 00:03:10.000
さて、再スローエラーでその同時反復を達成することは、むしろ関与する可能性があります。

00:03:10.000 -> 00:03:15.000
しかし、Swift Async Algorithmsパッケージは、私たちのメッセージングアプリで私たちのためにそのすべてを処理しました。

00:03:15.000 -> 00:03:26.000
以前は、ビデオ録画のプレビューを非同期に生成し、効率的なストレージと伝送のためにビデオを複数のサイズにトランスコードする多くのコードを調整していました。

00:03:26.000 -> 00:03:33.000
Zipを使用することで、トランスコードされたビデオをサーバーに送信するときにプレビューを取得できます。

00:03:33.000 -> 00:03:39.000
Zipは並行しているため、トランスコーディングもプレビューもお互いを遅らせません。

00:03:39.000 -> 00:03:41.000
しかし、これはもう少し進みます。

00:03:41.000 -> 00:03:55.000
Zip自体は、どちらの側が最初に値を生成するかどうかの好みがないため、ビデオを最初に作成するか、プレビューを作成することができ、どちら側であっても、もう一方が完全なタプルを送信するのを待ちます。

00:03:55.000 -> 00:04:04.000
Zipは各側が同時に値のタプルを構築するのを待っているので、一緒にアップロードできるようにペアを待つことができます。

00:04:04.000 -> 00:04:10.000
受信メッセージをAsyncSequenceとしてモデル化することは非常に理にかなっているという結論に達しました。

00:04:10.000 -> 00:04:20.000
そこで、順序を維持し、コールバックをメッセージのAsyncSequenceに変えるため、AsyncStreamを使用してこれらのメッセージを処理することにしました。

00:04:20.000 -> 00:04:25.000
私たちが取り組む必要のある要求された機能の1つは、複数のアカウントをサポートしたかったことです。

00:04:25.000 -> 00:04:36.000
したがって、各アカウントは受信メッセージのAsyncStreamを作成しますが、これを実装するときは、それらをすべて1つの単一のAsyncSequenceとして一緒に処理する必要があります。

00:04:36.000 -> 00:04:41.000
これは、これらのAsyncSequencesをマージするためのアルゴリズムが必要だったことを意味します。

00:04:41.000 -> 00:04:49.000
ありがたいことに、Swift Async Algorithmsパッケージには、まさにそのためのアルゴリズムがあり、適切に「Merge」と名付けられています。

00:04:49.000 -> 00:05:08.000
複数のAsyncSequencesを同時に反復するという点で、Zipと同様に機能します。しかし、ペアのタプルを作成する代わりに、ベースが同じ要素タイプを共有し、ベースAsyncSequencesをそれらの要素の1つの単一のAsyncSequenceにマージする必要があります。

00:05:08.000 -> 00:05:13.000
マージは、反復時に側面のいずれかによって生成された最初の要素を取ることによって動作します。

00:05:13.000 -> 00:05:23.000
特に、すべての基本AsyncSequencesがイテレータからnilを返す場合、生成できる値がなくなるまで反復を続けます。

00:05:23.000 -> 00:05:27.000
ベースのいずれかがエラーが発生した場合、他の反復はキャンセルされます。

00:05:27.000 -> 00:05:33.000
これにより、メッセージのAsyncSequencesを取り、それらをマージすることができます。

00:05:33.000 -> 00:05:43.000
これらの組み合わせアルゴリズムは、値が生成されるときに同時に機能しますが、時には実際に時間自体と対話することが有用です。

00:05:43.000 -> 00:05:51.000
Swift Async Algorithmsパッケージは、Swiftの新しいClock APIを活用することで、時間とともに動作するアルゴリズムのファミリーをもたらします。

00:05:51.000 -> 00:06:06.000
時間自体は本当に複雑な主題になる可能性があり、Swift（5.7）の新機能には、時計、インスタント、持続時間など、安全で一貫性のあるAPIのセットがあります。

00:06:06.000 -> 00:06:13.000
クロックプロトコルは、与えられた瞬間の後に目を覚ます方法と、今の概念を生成する方法の2つのプリミティブを定義します。

00:06:13.000 -> 00:06:15.000
内蔵の時計がいくつかあります。

00:06:15.000 -> 00:06:20.000
より一般的なものの2つは、ContinuousClockとSuspendingClockです。

00:06:20.000 -> 00:06:28.000
ContinuousClockを使用して、測定されているものの状態に関係なく時間が進むストップウォッチのように時間を測定することができます。

00:06:28.000 -> 00:06:35.000
一方、SuspendingClockは、その名前が示すことを行います。マシンがスリープ状態になると一時停止します。

00:06:35.000 -> 00:06:45.000
アプリで新しいクロックAPIを使用して、既存のコールバックイベントからクロックスリープ機能に移行し、締め切り後のアラートの却下を処理しました。

00:06:45.000 -> 00:06:55.000
遅延させたい秒数を具体的に示す期間値を追加することで、締め切りを作成することができました。

00:06:55.000 -> 00:07:00.000
時計には、作業の実行の経過時間を測定するための便利な方法もあります。

00:07:00.000 -> 00:07:07.000
ここには、先に述べた2つの一般的な時計、SuspendingClockとContinuousClockがあります。

00:07:07.000 -> 00:07:12.000
以下は、測定される作業の潜在的な経過時間を示すディスプレイです。

00:07:12.000 -> 00:07:20.000
これら2つの時計の主な違いは、機械が眠っているときの動作から来ています。

00:07:20.000 -> 00:07:36.000
このような長時間の作業では、ここで行ったのと同じように作業を一時停止できますが、実行を再開すると、マシンが眠っている間にContinuousClockは進行しましたが、SuspendingClockは進行しませんでした。

00:07:36.000 -> 00:07:46.000
一般的に、この違いは、実行のタイミングを一時停止することで、アニメーションのようなものが期待どおりに機能するようにするための重要な詳細になる可能性があります。

00:07:46.000 -> 00:07:53.000
アニメーションなど、マシンに関連して時間とやり取りする必要がある場合は、SuspendingClockを使用してください。

00:07:53.000 -> 00:07:59.000
デバイスの前の人間に関連するタスクを測定することは、ContinuousClockにより適しています。

00:07:59.000 -> 00:08:07.000
したがって、人間に関連する絶対的な期間で遅延する必要がある場合は、ContinuousClockを使用してください。

00:08:07.000 -> 00:08:21.000
Swift Async Algorithmsパッケージは、これらの新しいClock、Instant、およびDurationタイプを使用して、時間に関するイベントの処理方法に関する多くの概念に対処するための一般的なアルゴリズムを構築します。

00:08:21.000 -> 00:08:27.000
私たちのメッセージングアプリでは、これらがイベントの正確な制御を提供するのに本当に役立つことがわかりました。

00:08:27.000 -> 00:08:33.000
制限されたインタラクションをレートし、メッセージを効率的にバッファリングすることができます。

00:08:33.000 -> 00:08:38.000
おそらく、私たちが時間を利用した最も顕著な分野は、メッセージの検索でした。

00:08:38.000 -> 00:08:42.000
結果のチャネルを管理するコントローラーを作成しました。

00:08:42.000 -> 00:08:47.000
チャンネルは、検索タスクから検索結果をUIにマーシャリングします。

00:08:47.000 -> 00:08:53.000
検索タスク自体は、時間に関していくつかの特定の特性を持つ必要がありました。

00:08:53.000 -> 00:08:59.000
サーバー上で送信されたメッセージの検索制限を確実に評価したかった。

00:08:59.000 -> 00:09:06.000
アルゴリズムDebounceは、反復時に次の値を放出する前に、静止期間を待ちます。

00:09:06.000 -> 00:09:14.000
それは、イベントが速く入ってくる可能性があることを意味しますが、価値を扱う前に静かな期間を待つようにしたいと考えています。

00:09:14.000 -> 00:09:22.000
検索フィールドからのユーザー入力が急速に変更される場合、検索コントローラーが変更ごとに検索要求を発生させたくありません。

00:09:22.000 -> 00:09:29.000
代わりに、タイピングが完了した可能性が高いと確信している静かな期間を待つようにしたいと考えています。

00:09:29.000 -> 00:09:33.000
デフォルトでは、DebounceアルゴリズムはContinuousClockを使用します。

00:09:33.000 -> 00:09:40.000
この場合、何も起こっていない間に指定された期間を待つように入力をデバウンスすることができます。

00:09:40.000 -> 00:09:46.000
クロックと持続時間はデバウンスに使用されるだけでなく、他のアルゴリズムにも使用されます。

00:09:46.000 -> 00:09:52.000
本当に有用であることがわかった領域の1つは、サーバーにメッセージのバッチを送信することでした。

00:09:52.000 -> 00:09:58.000
Swiftアルゴリズムパッケージには、チャンク値に一連のアルゴリズムがあります。

00:09:58.000 -> 00:10:06.000
Swift Async Algorithmsパッケージはこれらを提供しますが、クロックと持続時間と相互運用する一連のバージョンも追加します。

00:10:06.000 -> 00:10:12.000
チャンキングアルゴリズムのファミリは、カウント、時間、またはコンテンツによってチャンクを制御できます。

00:10:12.000 -> 00:10:20.000
これらのいずれかでエラーが発生した場合、そのエラーは再スローされるため、失敗に関してはコードは安全です。

00:10:20.000 -> 00:10:28.000
「chunked(by:)」APIを使用して、メッセージのチャンクがシリアル化され、特定の経過期間によって送信されるようにしました。

00:10:28.000 -> 00:10:33.000
そうすれば、私たちのサーバーはクライアントから送信された効率的なパケットを取得します。

00:10:33.000 -> 00:10:39.000
このAPIを使用して、500ミリ秒ごとにメッセージのバッチを構築することができました。

00:10:39.000 -> 00:10:47.000
そうすれば、誰かが本当に興奮して本当に速く入力すると、サーバーに送信されたリクエストがグループ化されます。

00:10:47.000 -> 00:10:54.000
コレクションとシーケンスを扱うとき、要素を怠惰に処理することはしばしば有用で高性能です。

00:10:54.000 -> 00:11:00.000
AsyncSequenceは、スウィフト標準ライブラリでの遅延アルゴリズムの仕組みとよく似ています。

00:11:00.000 -> 00:11:08.000
しかし、これらの怠惰なアルゴリズムと同様に、コレクションの世界に戻る必要があることがよくあります。

00:11:08.000 -> 00:11:15.000
Swift Async Algorithmsパッケージは、AsyncSequenceを使用してコレクションを構築するための初期化子のセットを提供します。

00:11:15.000 -> 00:11:23.000
これらは、有限であることが知られている入力AsyncSequencesで辞書、セット、または配列を構築することができます。

00:11:23.000 -> 00:11:31.000
コレクション初期化子を使用すると、メッセージの初期化への変換を組み込み、データ型を配列として保持できます。

00:11:31.000 -> 00:11:38.000
Swiftの並行性を使用するためにいくつかの更新を本当に使用できる多くの機能があったので、これは本当に役に立ちました。

00:11:38.000 -> 00:11:47.000
また、既存のデータ構造を維持することで、アプリの一部を段階的に移行し、理にかなっている場所に移動することができます。

00:11:47.000 -> 00:11:52.000
これまでのところ、Swift Async Algorithmsパッケージのハイライトをほんの一握りにしました。

00:11:52.000 -> 00:11:55.000
今日取り上げたもの以外にも多くのものがあります。

00:11:55.000 -> 00:12:13.000
複数のAsyncSequencesの組み合わせ、時間によるレート制限、物事をチャンクに分割することに至るまでのアルゴリズムがありますが、これらは私たちがアプリで広範囲に使用することになったハイライトに過ぎませんでした。

00:12:13.000 -> 00:12:16.000
このパッケージには、それらだけではありません。

00:12:16.000 -> 00:12:27.000
バッファリング、削減、結合、断続的に値を注入することなど多岐にわたります。

00:12:27.000 -> 00:12:39.000
Swift Async Algorithmsパッケージは、時間の経過とともに物事に対処するためのアルゴリズムのセットを取り、アプリで役立つ幅広い高度な機能に拡張します。

00:12:39.000 -> 00:12:40.000
試してみてください。

00:12:40.000 -> 00:12:46.000
私たちは、あなたがこれらで構築するものを発見することに本当に興奮しており、その興奮は共有されています。

00:12:46.000 -> 00:12:50.000
このパッケージはあなたと一緒にオープンに開発されています。

00:12:50.000 -> 00:12:53.000
見てくれてありがとう、そして会議の残りを楽しんでください。

00:12:53.000 -> 23:59:59.000
♪インストゥルメンタルヒップホップ音楽♪

