WEBVTT

00:00:00.000 -> 00:00:14.000
ベンジャミン・プーライン：皆さん、こんにちは。仮想化に関するセッションへようこそ。

00:00:14.000 -> 00:00:17.000
これが私たちが今日一緒にやろうとしていることです。

00:00:17.000 -> 00:00:24.000
Appleシリコンで、仮想マシン内でmacOSとLinuxを実行する方法を見ていきます。

00:00:24.000 -> 00:00:28.000
このセッションの終わりまでに、あなたは自分のMacで同じことをすることができるようになります。

00:00:28.000 -> 00:00:33.000
これは少し野心的に思えるかもしれませんが、私たちに固執し、一緒にやります。

00:00:33.000 -> 00:00:35.000
これが今日の議題です。

00:00:35.000 -> 00:00:43.000
仮想化技術の概要から始め、仮想化フレームワークを使用して仮想マシンを構築する方法を見ていきます。

00:00:43.000 -> 00:00:47.000
次に、macOSを深く掘り下げます。

00:00:47.000 -> 00:00:51.000
仮想MacをセットアップしてmacOSをインストールする方法を見ていきます。

00:00:51.000 -> 00:00:56.000
そして最後に、今回はLinuxについて2回目の深い掘り下げを行います。

00:00:56.000 -> 00:01:01.000
完全なLinuxディストリビューションといくつかのクールな新機能を実行する方法を見ていきます。

00:01:01.000 -> 00:01:03.000
概要から始めましょう。

00:01:03.000 -> 00:01:08.000
まず、仮想化を可能にするスタックを見ていきます。

00:01:08.000 -> 00:01:10.000
すべてはハードウェアから始まります。

00:01:10.000 -> 00:01:16.000
Appleシリコンには、CPUとメモリの仮想化を可能にする特別なハードウェアがあります。

00:01:16.000 -> 00:01:20.000
これは、単一のSoC上で複数のオペレーティングシステムを実行できることを意味します。

00:01:20.000 -> 00:01:24.000
次に、このハードウェアを利用するためのソフトウェアが必要です。

00:01:24.000 -> 00:01:27.000
そして、これはmacOSカーネルに組み込まれています。

00:01:27.000 -> 00:01:30.000
カーネル拡張機能やKEXTを書く必要がなくなりました。

00:01:30.000 -> 00:01:33.000
それはすべて組み込まれています。

00:01:33.000 -> 00:01:37.000
アプリケーションからこれらの機能を使用するには、ハイパーバイザーフレームワークを使用できます。

00:01:37.000 -> 00:01:43.000
ハイパーバイザーフレームワークは、CPUとメモリを仮想化できる低レベルのAPIです。

00:01:43.000 -> 00:01:50.000
しかし、低レベルのフレームワークであるため、仮想環境のすべての詳細を書く必要があります。

00:01:50.000 -> 00:01:53.000
多くの場合、私たちは完全なオペレーティングシステムを実行したいと考えています。

00:01:53.000 -> 00:01:58.000
このために、仮想化フレームワークである高レベルのAPIがあります。

00:01:58.000 -> 00:02:08.000
仮想化フレームワークは、AppleシリコンとIntelの両方でAppleシリコンまたはLinuxでmacOSを実行する仮想マシンの作成を可能にします。

00:02:08.000 -> 00:02:11.000
今日のセッションでは、仮想化フレームワークに焦点を当てます。

00:02:11.000 -> 00:02:14.000
仮想化フレームワークを使用する場合は、2種類のオブジェクトを扱います。

00:02:14.000 -> 00:02:17.000
最初の種類は構成オブジェクトです。

00:02:17.000 -> 00:02:20.000
彼らは私たちの仮想マシンのすべてのプロパティを定義します。

00:02:20.000 -> 00:02:22.000
2番目の種類は仮想マシンオブジェクトです。

00:02:22.000 -> 00:02:27.000
これらのオブジェクトは、仮想マシンとそれらと対話する方法を抽象化します。

00:02:27.000 -> 00:02:31.000
構成を見ることから始めます。

00:02:31.000 -> 00:02:34.000
構成はハードウェアを定義します。

00:02:34.000 -> 00:02:38.000
設定の作成は、Apple StoreでMacを設定するようなものです。

00:02:38.000 -> 00:02:42.000
必要なCPUの数、メモリの量、デバイスの種類を定義します。

00:02:42.000 -> 00:02:45.000
簡単な設定から始めることができます。

00:02:45.000 -> 00:02:47.000
ディスプレイを追加して、コンテンツを見ることができます。

00:02:47.000 -> 00:02:50.000
キーボードを追加して、入力することができます。

00:02:50.000 -> 00:02:53.000
トラックパッドを追加して、UIと対話することができます。

00:02:53.000 -> 00:02:57.000
仮想マシンの設定はまさにそれです。

00:02:57.000 -> 00:03:01.000
しかし、私たちは仮想マシンを扱っているので、これをコードで行います。

00:03:01.000 -> 00:03:05.000
Swiftで設定を書く方法を見てみましょう。

00:03:05.000 -> 00:03:07.000
ハードウェアの定義はとても簡単です。

00:03:07.000 -> 00:03:12.000
VZVirtualMachineConfiguration型のオブジェクトから始めます。

00:03:12.000 -> 00:03:15.000
これはすべての構成のルートオブジェクトです。

00:03:15.000 -> 00:03:19.000
次に、マシンが持つべきCPUの数を定義します。

00:03:19.000 -> 00:03:22.000
ここでは、4つのCPUを与えます。

00:03:22.000 -> 00:03:24.000
次に、必要なメモリの量を設定します。

00:03:24.000 -> 00:03:28.000
この場合、4ギガバイトのメモリを与えます。

00:03:28.000 -> 00:03:31.000
最後に、マシンが持つデバイスを定義します。

00:03:31.000 -> 00:03:38.000
この例では、単一のストレージデバイス、起動するディスク、およびマウスのようなポインティングデバイスを設定します。

00:03:38.000 -> 00:03:40.000
利用可能なデバイスはたくさんあります。

00:03:40.000 -> 00:03:44.000
あなたが設定したものは、あなたが解決したい問題に依存します。

00:03:44.000 -> 00:03:46.000
今、私たちは設定を見ました。

00:03:46.000 -> 00:03:53.000
これは、CPU、メモリ、およびデバイスを追加するVZVirtualMachineConfigurationから始まります。

00:03:53.000 -> 00:03:58.000
次に、仮想マシンのオブジェクトを調べます。

00:03:58.000 -> 00:04:00.000
Macを設定したら、メールで受け取ります。

00:04:00.000 -> 00:04:03.000
箱を開けて始める時が来ました。

00:04:03.000 -> 00:04:08.000
しかし、私たちは仮想マシンを扱っているので、コードでそれを行う必要があります。

00:04:08.000 -> 00:04:11.000
スウィフトでそれを行う方法を見てみましょう。

00:04:11.000 -> 00:04:16.000
まず、設定からVZVirtualMachineのインスタンスを作成します。

00:04:16.000 -> 00:04:20.000
VZVirtualMachineは、仮想ハードウェアのインスタンスを抽象化します。

00:04:20.000 -> 00:04:23.000
仮想マシンが手になったので、それを操作できます。

00:04:23.000 -> 00:04:27.000
たとえば、この場合、start() を呼び出して起動します。

00:04:27.000 -> 00:04:30.000
私たちはしばしば、仮想マシンと対話したいと思うでしょう。

00:04:30.000 -> 00:04:33.000
このために、私たちは私たちを助ける他のオブジェクトを持っています。

00:04:33.000 -> 00:04:39.000
たとえば、仮想ディスプレイを表示したい場合は、VZVirtualMachineViewタイプのオブジェクトを使用できます。

00:04:39.000 -> 00:04:41.000
ビューを作成することから始めます。

00:04:41.000 -> 00:04:47.000
次に、仮想マシンをビューのvirtualMachineプロパティとして設定し、準備が整いました。

00:04:47.000 -> 00:04:51.000
これで、このVZVirtualMachineViewオブジェクトを他のNSViewと同様に使用できます。

00:04:51.000 -> 00:04:56.000
アプリに統合して、仮想マシンのコンテンツを確認できます。

00:04:56.000 -> 00:05:00.000
最後に、私たちは構成を見てきました。

00:05:00.000 -> 00:05:08.000
設定はVZVirtualMachineConfigurationから始まり、そこからCPU、メモリ、およびデバイスを定義します。

00:05:08.000 -> 00:05:13.000
設定から、仮想マシンを作成し、仮想マシンオブジェクトを使用します。

00:05:13.000 -> 00:05:23.000
VZVirtualMachineがVM自体を抽象化し、VZVirtualMachineViewがコンテンツを表示し、VMを使用するのに役立つ他のオブジェクトがあります。

00:05:23.000 -> 00:05:29.000
私たちは、構成が仮想マシンを定義する方法に多くの柔軟性を与えるのを見てきました。

00:05:29.000 -> 00:05:33.000
残念ながら、1回のセッションでカバーできない機能が多すぎます。

00:05:33.000 -> 00:05:37.000
このセッションでは、コア機能のいくつかを見ていきます。

00:05:37.000 -> 00:05:42.000
それ以外のすべてについては、ドキュメントがありますので、ぜひチェックしてください。

00:05:42.000 -> 00:05:46.000
概要では、仮想マシンを構築する方法を見ました。

00:05:46.000 -> 00:05:50.000
今、それらで完全なオペレーティングシステムを実行する方法を検討する時が来ました。

00:05:50.000 -> 00:05:52.000
そして、私たちはmacOSから始めます。

00:05:52.000 -> 00:05:56.000
仮想化フレームワークは、Appleシリコン上のmacOSをサポートしています。

00:05:56.000 -> 00:06:03.000
Appleシリコンで仮想化フレームワークを構築したとき、私たちはmacOSと仮想化フレームワークを一緒に開発しました。

00:06:03.000 -> 00:06:08.000
これが私たちにもたらすのは、仮想マシン内でmacOSを実行するときの信じられないほどの効率です。

00:06:08.000 -> 00:06:16.000
私たちが見ようとしているものは次のとおりです。まず、仮想マシンを仮想Macに変えるために必要なものを調べます。

00:06:16.000 -> 00:06:20.000
次に、仮想MacにmacOSをインストールする手順を見ていきます。

00:06:20.000 -> 00:06:25.000
次に、macOS用の特別なデバイスのいくつかを見ていきます。

00:06:25.000 -> 00:06:34.000
そして最後に、ホストシステムと仮想Macの間でファイルを共有するという非常に重要なユースケースを調べます。

00:06:34.000 -> 00:06:36.000
設定から始めましょう。

00:06:36.000 -> 00:06:40.000
私たちは以前、一般的な仮想マシンを構築する方法を見てきました。

00:06:40.000 -> 00:06:45.000
次に、仮想マシンをMacにする特別なプロパティを追加します。

00:06:45.000 -> 00:06:49.000
では、どうやって仮想Macを作るのですか?

00:06:49.000 -> 00:06:51.000
まず、特別なプラットフォームを定義します。

00:06:51.000 -> 00:06:57.000
プラットフォームは、特定のタイプの仮想マシンのすべてのプロパティを保持するオブジェクトです。

00:06:57.000 -> 00:07:02.000
仮想Macハードウェアに固有の3つのプロパティがあります。

00:07:02.000 -> 00:07:04.000
まず、ハードウェアモデルがあります。

00:07:04.000 -> 00:07:09.000
ハードウェアモデルは、必要な仮想Macのバージョンを指定します。

00:07:09.000 -> 00:07:11.000
第二に、補助ストレージがあります。

00:07:11.000 -> 00:07:16.000
補助ストレージは、システムで使用される不揮発性メモリの一種です。

00:07:16.000 -> 00:07:19.000
そして第三に、機械識別子があります。

00:07:19.000 -> 00:07:26.000
マシン識別子は、物理的なMacが一意のシリアル番号を持っているのと同じように、マシンを表す一意の番号です。

00:07:26.000 -> 00:07:34.000
プラットフォームを手に入れたら、ハードウェアを説明するすべての部分がありますが、macOSを起動する方法であるもう1つの部分が必要です。

00:07:34.000 -> 00:07:39.000
これには、特別なブートローダであるmacOSブートローダを使用します。

00:07:39.000 -> 00:07:43.000
スウィフトでこれらすべてを行う方法を見てみましょう。

00:07:43.000 -> 00:07:44.000
私たちは以前と同じベースから始めます。

00:07:44.000 -> 00:07:48.000
このコードは、私たちが概要で見たものです。

00:07:48.000 -> 00:07:52.000
次に、VZMacPlatformConfigurationを作成します。

00:07:52.000 -> 00:07:56.000
これは、仮想Mac用のプラットフォームオブジェクトです。

00:07:56.000 -> 00:07:58.000
このMacのハードウェアモデルが必要です。

00:07:58.000 -> 00:08:01.000
ここでは、以前に保存したものを使用します。

00:08:01.000 -> 00:08:06.000
仮想マシンでは、補助ストレージはローカルファイルシステム上のファイルによってバックアップされます。

00:08:06.000 -> 00:08:09.000
ここでは、ファイルURLから補助ストレージを初期化します。

00:08:09.000 -> 00:08:15.000
一意の識別子については、以前に保存した識別子からVZMacMachineIdentifierを初期化します。

00:08:15.000 -> 00:08:19.000
新規インストールの場合、新しい識別子を作成することもできます。

00:08:19.000 -> 00:08:23.000
3つのプロパティをすべて設定しました。私たちのプラットフォームは準備ができています。

00:08:23.000 -> 00:08:27.000
私たちがしなければならないのは、設定オブジェクトに設定することだけです。

00:08:27.000 -> 00:08:31.000
これは私たちにハードウェアを与えます。次に、起動する方法が必要です。

00:08:31.000 -> 00:08:36.000
これを行うには、VZMacBootLoaderでブートローダを設定します。

00:08:36.000 -> 00:08:38.000
今、私たちのマシンは起動する準備ができています。

00:08:38.000 -> 00:08:43.000
これまでにやったことは、仮想Macとその起動方法を定義することです。

00:08:43.000 -> 00:08:48.000
しかし、私たちはまだそれにソフトウェアを取得する必要があり、それは私たちにインストールをもたらします。

00:08:48.000 -> 00:08:51.000
macOSのインストールは3つのステップで行われます。

00:08:51.000 -> 00:08:56.000
まず、インストールしたいmacOSのバージョンで復元イメージをダウンロードする必要があります。

00:08:56.000 -> 00:09:01.000
次に、そのバージョンのmacOSと互換性のある構成を作成する必要があります。

00:09:01.000 -> 00:09:07.000
そして最後に、互換性のある仮想マシンに復元イメージをインストールします。

00:09:07.000 -> 00:09:10.000
まず、復元イメージをダウンロードする必要があります。

00:09:10.000 -> 00:09:16.000
開発者のウェブサイトから復元画像をダウンロードできますが、仮想化も役立ちます。

00:09:16.000 -> 00:09:25.000
VZMacOSRestoreImage.latestSupportedを呼び出すと、最新の安定版のmacOSの復元イメージオブジェクトを取得できます。

00:09:25.000 -> 00:09:29.000
このオブジェクトには、ファイルをダウンロードするために使用できるURLプロパティがあります。

00:09:29.000 -> 00:09:35.000
次に、ダウンロードしたmacOSのバージョンと互換性のある仮想マシンを作成したいと考えています。

00:09:35.000 -> 00:09:37.000
仮想化はここでも私たちを助けることができます。

00:09:37.000 -> 00:09:42.000
復元イメージオブジェクトに構成要件を尋ねることができます。

00:09:42.000 -> 00:09:47.000
復元イメージを現在のシステムで実行できる場合は、要件をリストしたオブジェクトを取得します。

00:09:47.000 -> 00:09:53.000
要件から、このバージョンのmacOSを実行するために必要なハードウェアモデルを入手できます。

00:09:53.000 -> 00:09:55.000
ハードウェアモデルを復元する方法を以前に見てきました。

00:09:55.000 -> 00:09:59.000
これが私たちが新しいものを手に入れる方法です。

00:09:59.000 -> 00:10:03.000
要件には、2つの有用なプロパティも含まれています。

00:10:03.000 -> 00:10:11.000
このオブジェクトは、このバージョンのmacOSを実行するために必要なCPUの数とメモリの量を教えてくれます。

00:10:11.000 -> 00:10:14.000
最後に、インストールを開始する準備が整いました。

00:10:14.000 -> 00:10:18.000
まず、構成から新しい仮想マシンを作成することから始めます。

00:10:18.000 -> 00:10:20.000
次に、インストーラーを作成します。

00:10:20.000 -> 00:10:28.000
インストーラーは、作成した互換性のある仮想マシンと、ダウンロードした復元イメージへのパスの2つの引数を取ります。

00:10:28.000 -> 00:10:33.000
これで、install()を呼び出すだけで、macOSを実行する準備が整いました。

00:10:33.000 -> 00:10:41.000
仮想Macを設定してmacOSをインストールできるようになったので、Mac用の特別なデバイスをいくつか見てみましょう。

00:10:41.000 -> 00:10:44.000
最初のクールな機能はGPUアクセラレーションです。

00:10:44.000 -> 00:10:50.000
私たちは、GPU機能を仮想Macに公開するグラフィックデバイスを構築しました。

00:10:50.000 -> 00:10:56.000
これは、仮想マシンでMetalを実行し、macOSで優れたグラフィックスパフォーマンスを得ることができることを意味します。

00:10:56.000 -> 00:10:59.000
設定方法を見てみましょう。 

00:10:59.000 -> 00:11:02.000
グラフィックデバイスの構成を作成することから始めます。

00:11:02.000 -> 00:11:06.000
ここでは、VZMacGraphicsDeviceConfigurationを使用します。

00:11:06.000 -> 00:11:08.000
次に、私たちはそれにディスプレイを与えたいと思います。

00:11:08.000 -> 00:11:13.000
サイズとピクセル密度を定義してディスプレイを設定します。

00:11:13.000 -> 00:11:15.000
これで、デバイス構成の準備が整いました。

00:11:15.000 -> 00:11:18.000
いつものように、メイン構成オブジェクトに設定します。

00:11:18.000 -> 00:11:23.000
仮想マシンのグラフィックスデバイスとして設定しました。

00:11:23.000 -> 00:11:26.000
次に、Macと対話するための新しいデバイスがあります。

00:11:26.000 -> 00:11:31.000
macOS Venturaでは、仮想MacにMacトラックパッドのサポートを追加しています。

00:11:31.000 -> 00:11:37.000
新しいトラックパッドでは、回転、ピンチからズームなどのジェスチャーを使用できます。

00:11:37.000 -> 00:11:40.000
この新しいデバイスは、macOSで新しいドライバを使用します。

00:11:40.000 -> 00:11:45.000
そのため、それを使用するには、ホストシステムと仮想マシンの両方でmacOS 13が必要になります。

00:11:45.000 -> 00:11:48.000
設定方法を見てみましょう。 

00:11:48.000 -> 00:11:50.000
それはとても簡単です。

00:11:50.000 -> 00:11:54.000
VZMacTrackpadConfigurationタイプの新しいオブジェクトを作成します。

00:11:54.000 -> 00:11:58.000
次に、仮想マシン上のポインティングデバイスとして設定します。

00:11:58.000 -> 00:12:03.000
これで、仮想Macでビューを使用する場合は、ジェスチャーを使用できます。

00:12:03.000 -> 00:12:11.000
最後に、ホストシステムと仮想マシン間でファイルを共有するという、私たちの多くにとって一般的なユースケースを見てみましょう。

00:12:11.000 -> 00:12:16.000
macOS 12では、Linuxでファイルを共有するためのVirtioファイルシステムデバイスを導入しました。

00:12:16.000 -> 00:12:20.000
macOS Venturaでは、macOSのサポートを追加しています。

00:12:20.000 -> 00:12:23.000
仮想マシンと共有したいフォルダを選択できるようになりました。

00:12:23.000 -> 00:12:29.000
ホストシステムから変更を加えると、仮想マシンに即座に反映され、その逆も同様です。

00:12:29.000 -> 00:12:32.000
設定方法を見てみましょう。 

00:12:32.000 -> 00:12:37.000
まず、共有したいディレクトリでVZShareDirectoryを作成します。

00:12:37.000 -> 00:12:39.000
次に、共有オブジェクトを作成します。

00:12:39.000 -> 00:12:43.000
ここでは、VZSingleDirectoryShareを使用して単一のディレクトリを共有します。

00:12:43.000 -> 00:12:48.000
VZMultipleDirectoryShareを使用して、複数のディレクトリを共有することもできます。

00:12:48.000 -> 00:12:51.000
シェアがわかったので、デバイスを作成する必要があります。

00:12:51.000 -> 00:12:54.000
しかし、私たちは何か特別なことを始めます。

00:12:54.000 -> 00:12:56.000
ファイルシステムデバイスはタグで識別されます。

00:12:56.000 -> 00:13:03.000
macOS Venturaでは、仮想マシンにこのデバイスを自動マウントするように指示する特別なタグを追加しました。

00:13:03.000 -> 00:13:07.000
ここでは、この特別なタグ、macOSGuestAutomountTagを取ります。

00:13:07.000 -> 00:13:11.000
次に、デバイスを作成し、特別なタグを使用します。

00:13:11.000 -> 00:13:15.000
設定した単一のディレクトリから共有を設定します。

00:13:15.000 -> 00:13:19.000
そして最後に、いつものようにデバイスを構成に追加します。

00:13:19.000 -> 00:13:23.000
最後に、デモですべてを一緒に見てみましょう。

00:13:23.000 -> 00:13:26.000
私たちは基本的な構成から始めます。

00:13:26.000 -> 00:13:33.000
CPU、メモリ、キーボード、ディスクのみのVZVirtualMachineConfigurationがあります。

00:13:33.000 -> 00:13:35.000
私たちは仮想Macが欲しいです。

00:13:35.000 -> 00:13:39.000
これを行うには、プラットフォームを設定することから始める必要があります。

00:13:39.000 -> 00:13:43.000
これを行うには、上記で定義されたcreateMacPlatformを使用します。

00:13:43.000 -> 00:13:46.000
仮想Macの2番目の部分はブートローダです。

00:13:46.000 -> 00:13:50.000
macOSの起動方法を知っているブートローダが必要です。

00:13:50.000 -> 00:13:55.000
それを取得するには、プラットフォームのブートローダをVZMacOSBootLoader()に設定します。

00:13:55.000 -> 00:13:58.000
次に、デバイスをセットアップします。

00:13:58.000 -> 00:14:00.000
私たちは加速されたグラフィックが欲しい。

00:14:00.000 -> 00:14:04.000
それを取得するには、VZMacGraphicsConfigurationを設定します。

00:14:04.000 -> 00:14:12.000
オブジェクトを作成し、表示サイズとピクセル密度を定義し、設定に追加します。

00:14:12.000 -> 00:14:14.000
次に、新しいトラックパッドを使いたいです。

00:14:14.000 -> 00:14:19.000
私たちがする必要があるのは、ポインティングデバイスをVZMacTrackpadConfigurationに設定することだけです。

00:14:19.000 -> 00:14:20.000
それでおそれ。

00:14:20.000 -> 00:14:24.000
これで、VMを起動できますが、上にチェリーを追加しましょう。

00:14:24.000 -> 00:14:27.000
ディレクトリを共有する方法を見てきました。

00:14:27.000 -> 00:14:29.000
ここでやりましょう。

00:14:29.000 -> 00:14:32.000
ファイルシステムデバイスの設定を作成することから始めます。

00:14:32.000 -> 00:14:37.000
ここでは、特別なタグを使用してmacOSに自動マウントすることに注意してください。

00:14:37.000 -> 00:14:38.000
次に、シェアを定義します。

00:14:38.000 -> 00:14:42.000
ここでは、ファイルシステム上のパスから単一のディレクトリ共有を使用します。

00:14:42.000 -> 00:14:47.000
ここでは、今編集しているこのプロジェクトを共有します。

00:14:47.000 -> 00:14:51.000
設定にデバイスを追加し、完了です。

00:14:51.000 -> 00:14:55.000
準備万端です私たちはアプリを起動します。

00:14:55.000 -> 00:15:01.000
Macグラフィックスデバイスを設定したので、VZVirtualMachineViewはコンテンツを表示できます。

00:15:01.000 -> 00:15:04.000
これはあなたがこの窓に見ているものです。

00:15:04.000 -> 00:15:08.000
そして、ここにあります。macOSをゼロから設定しました。

00:15:08.000 -> 00:15:11.000
共有ディレクトリと、今編集していたプロジェクトを見ることができます。

00:15:11.000 -> 00:15:14.000
最後に、私たちはLinuxに目を向けます。

00:15:14.000 -> 00:15:20.000
仮想化フレームワークは、macOS Big Surの当初からLinuxをサポートしてきました。

00:15:20.000 -> 00:15:26.000
macOS Venturaでは、かなりクールな新機能を追加し、そのうちのいくつかをあなたと共有したいと思います。

00:15:26.000 -> 00:15:33.000
まず、完全に変更されていない完全なLinuxディストリビューションを仮想マシンにインストールする方法を見ていきます。

00:15:33.000 -> 00:15:37.000
次に、LinuxのUIを表示するために追加する新しいデバイスを見ていきます。

00:15:37.000 -> 00:15:44.000
最後に、Rosetta 2を活用して仮想マシンでLinuxバイナリを実行する方法を見ていきます。

00:15:44.000 -> 00:15:47.000
インストールから始めましょう。

00:15:47.000 -> 00:15:52.000
物理マシンにLinuxをインストールしたい場合は、インストーラーでISOファイルをダウンロードすることから始めます。

00:15:52.000 -> 00:15:55.000
次に、ISOでフラッシュドライブを消去します。

00:15:55.000 -> 00:15:59.000
そして最後に、ドライブをコンピュータに接続し、そこから起動します。

00:15:59.000 -> 00:16:03.000
仮想マシンを扱うときは、同じフローを経ます。

00:16:03.000 -> 00:16:07.000
しかし、物理的なUSBドライブを使用する代わりに、仮想USBドライブを使用します。

00:16:07.000 -> 00:16:10.000
それがどのように機能するか見てみましょう。

00:16:10.000 -> 00:16:14.000
まず、ダウンロードしたISOファイルへのパスからURLを作成します。

00:16:14.000 -> 00:16:18.000
次に、ファイルからディスクイメージの添付ファイルを作成します。

00:16:18.000 -> 00:16:24.000
ディスクイメージの添付ファイルは、デバイスに接続できるストレージの一部を表します。

00:16:24.000 -> 00:16:28.000
次に、仮想ストレージデバイスを設定します。

00:16:28.000 -> 00:16:35.000
この場合、USBストレージが必要な場合は、VZUSBMassStorageDeviceConfigurationを使用します。

00:16:35.000 -> 00:16:39.000
最後に、いつものように、メイン構成にデバイスを追加します。

00:16:39.000 -> 00:16:45.000
ここでは、USBデバイスが別のストレージデバイス、Linuxをインストールするメインディスクの横に表示されます。

00:16:45.000 -> 00:16:50.000
今、私たちはUSBドライブを持っていますが、そこから起動する方法が必要です。

00:16:50.000 -> 00:16:54.000
macOS Venturaでは、EFIのサポートを追加しました。

00:16:54.000 -> 00:16:58.000
EFIは、ARMとIntelの両方のハードウェアを起動するための業界標準です。

00:16:58.000 -> 00:17:02.000
私たちは仮想マシンに同じサポートをもたらしています。

00:17:02.000 -> 00:17:05.000
EFIにはブート検出メカニズムがあります。

00:17:05.000 -> 00:17:09.000
これにより、USBドライブのインストーラーを発見することができます。

00:17:09.000 -> 00:17:13.000
EFIは、起動できるドライブごとに各ドライブを調べます。

00:17:13.000 -> 00:17:16.000
インストーラーを見つけて、そこから始めます。

00:17:16.000 -> 00:17:19.000
インストーラー自体は、次にどのドライブを使用するかをEFIに伝えます。

00:17:19.000 -> 00:17:23.000
インストール後、EFIはLinuxディストリビューションを起動できます。

00:17:23.000 -> 00:17:26.000
コードでEFIを設定する方法を見てみましょう。

00:17:26.000 -> 00:17:31.000
まず、VZEFIBootLoaderタイプのブートローダを作成します。

00:17:31.000 -> 00:17:35.000
EFIは、ブーツ間で情報を保存するために不揮発性メモリを必要とします。

00:17:35.000 -> 00:17:38.000
これはEFI変数ストアと呼ばれます。

00:17:38.000 -> 00:17:42.000
仮想マシンでは、ファイルシステム上のファイルでそのようなストレージをバックアップできます。

00:17:42.000 -> 00:17:46.000
ここでは、新しい変数ストアをゼロから作成します。

00:17:46.000 -> 00:17:47.000
これでEFIの準備が整いました。

00:17:47.000 -> 00:17:51.000
構成のブートローダとして設定するだけです。

00:17:51.000 -> 00:17:57.000
次に、Linux VM、グラフィックスの新機能について検討します。

00:17:57.000 -> 00:18:01.000
macOS Venturaでは、Virtio GPU 2Dのサポートを追加しました。

00:18:01.000 -> 00:18:08.000
Virtio GPU 2Dは、LinuxがホストmacOSにサーフェスを提供できる準仮想化デバイスです。

00:18:08.000 -> 00:18:14.000
Linuxはコンテンツをレンダリングし、レンダリングされたフレームを仮想化フレームワークに提供し、それを表示することができます。

00:18:14.000 -> 00:18:21.000
macOSと同様に、VZVirtualMachineViewを使用して、このコンテンツをアプリに表示できるようになりました。

00:18:21.000 -> 00:18:24.000
設定方法を見てみましょう。 

00:18:24.000 -> 00:18:28.000
デバイスの設定は、私たちがmacOSでやったことと似ています。

00:18:28.000 -> 00:18:32.000
VZVirtioGraphicsDeviceConfigurationを作成することから始めます。

00:18:32.000 -> 00:18:36.000
仮想ディスプレイのサイズを定義する必要があります。

00:18:36.000 -> 00:18:39.000
Virtioの用語では、仮想ディスプレイは「スキャンアウト」です。

00:18:39.000 -> 00:18:44.000
そこで、ディスプレイのサイズで1つのスキャンアウトを作成します。

00:18:44.000 -> 00:18:49.000
最後に、新しいデバイスを構成のグラフィックスデバイスとして設定します。

00:18:49.000 -> 00:18:54.000
これで、VMはVZVirtualMachineViewでコンテンツを表示する準備が整いました。

00:18:54.000 -> 00:18:58.000
次に、デモですべてを一緒に見てみましょう。

00:18:58.000 -> 00:19:00.000
私たちは中断したところから始めます。

00:19:00.000 -> 00:19:03.000
Mac固有のコードを削除しましょう。 では、Mac固有のコードを削除しましょう。

00:19:03.000 -> 00:19:05.000
では、起動しているディスクを変更しましょう。

00:19:05.000 -> 00:19:09.000
MacドライブからLinuxドライブへのパスを切り替えます。

00:19:09.000 -> 00:19:12.000
次に、ブートローダが必要です。

00:19:12.000 -> 00:19:16.000
VZEFIBootLoaderでEFIを設定しました。

00:19:16.000 -> 00:19:19.000
まず、EFIブートローダオブジェクトを作成します。

00:19:19.000 -> 00:19:22.000
次に、そのファイルから変数ストアをロードします。

00:19:22.000 -> 00:19:27.000
そして最後に、設定のブートローダとしてEFIを設定しました。

00:19:27.000 -> 00:19:31.000
これで起動できますが、UIを表示するといいですね。

00:19:31.000 -> 00:19:35.000
Virtio GPUを構成に追加しましょう。

00:19:35.000 -> 00:19:40.000
VZVirtioGraphicsDeviceConfigurationタイプのグラフィックデバイスを作成するだけです。

00:19:40.000 -> 00:19:43.000
次に、仮想ディスプレイのサイズでスキャンアウトを定義します。

00:19:43.000 -> 00:19:49.000
そして、私たちの構成でVirtio GPUをグラフィックデバイスとして設定しました。

00:19:49.000 -> 00:19:53.000
最後のタッチは、マウスを動作させることです。

00:19:53.000 -> 00:19:58.000
仮想USBスクリーン座標ポインタデバイスを使用するだけで、Linuxではマウスを使用します。

00:19:58.000 -> 00:20:01.000
それでおそれ。私たちはそのプロジェクトを実行することができます。

00:20:01.000 -> 00:20:04.000
EFIはディスクを見て、起動可能であることがわかりました。

00:20:04.000 -> 00:20:10.000
次に、LinuxはVirtio GPUデバイスを介してUIのコンテンツを表示します。

00:20:10.000 -> 00:20:12.000
そして、マウスを使ってLinuxと対話することができます。

00:20:12.000 -> 00:20:20.000
最後になりましたが、Linux内のRosetta 2テクノロジーをどのように活用できるかを見ていきます。

00:20:20.000 -> 00:20:29.000
私たちの多くにとって、私たちはMacでサービスを開発するのが大好きですが、作業の準備ができたら、作成したバイナリはx86サーバーで実行する必要があるかもしれません。

00:20:29.000 -> 00:20:35.000
X86命令エミュレーションはこれにとって素晴らしいものでしたが、私たちはもっとうまくやることができます。

00:20:35.000 -> 00:20:40.000
macOS Venturaでは、Rosetta 2のパワーをLinuxバイナリにもたらしています。

00:20:40.000 -> 00:20:46.000
Rosetta 2が行うことは、仮想マシン内でLinux x86-64バイナリを翻訳することです。

00:20:46.000 -> 00:20:53.000
これは、お気に入りのARM Linuxディストリビューションを実行でき、そのx86-64アプリはRosettaで実行できることを意味します。

00:20:53.000 -> 00:20:54.000
そして、それは速いです。

00:20:54.000 -> 00:21:00.000
それは私たちがMacで使用してきたのと同じ技術であり、それは私たちが信じられないほどのパフォーマンスを持っていることを意味します。

00:21:00.000 -> 00:21:03.000
使い方を見てみましょう。 

00:21:03.000 -> 00:21:07.000
まず、Linuxにロゼッタへのアクセスを許可する必要があります。

00:21:07.000 -> 00:21:11.000
これを行うには、macOSで見たのと同じファイル共有技術を使用しています。

00:21:11.000 -> 00:21:18.000
フォルダを共有する代わりに、特別な種類のオブジェクトであるVZLinuxRosettaDirectoryShareを使用します。

00:21:18.000 -> 00:21:24.000
次に、共有デバイスを作成し、Rosettaディレクトリ共有を設定します。

00:21:24.000 -> 00:21:28.000
最後に、通常どおり構成でデバイスをセットアップしました。

00:21:28.000 -> 00:21:32.000
今、私たちの仮想マシンはロゼッタを使用する準備ができています。

00:21:32.000 -> 00:21:36.000
次に、Linuxがそれをどのように活用できるかを見てみましょう。

00:21:36.000 -> 00:21:41.000
Linuxでは、ファイルシステムに共有ディレクトリをマウントすることから始めます。

00:21:41.000 -> 00:21:46.000
Linuxから見られるのは、アプリケーションを翻訳できるロゼッタバイナリです。

00:21:46.000 -> 00:21:53.000
次に、update-binfmtsを使用して、x86-64バイナリを処理するためにRosettaを使用するようにシステムに指示することができます。

00:21:53.000 -> 00:21:55.000
このコマンドを覚えておくことを心配しないでください。

00:21:55.000 -> 00:21:58.000
それはすべてドキュメントにあります。

00:21:58.000 -> 00:22:00.000
これでLinuxの準備が整いました。

00:22:00.000 -> 00:22:07.000
起動されたすべてのx86-64バイナリは、ロゼッタによって翻訳されます。

00:22:07.000 -> 00:22:11.000
Linuxのセクションを終了する前に、すべてを一緒に見てみましょう。

00:22:11.000 -> 00:22:15.000
ここでは、完全なLinuxディストリビューションをゼロからインストールしています。

00:22:15.000 -> 00:22:18.000
Virtio GPU 2DでUIを表示できます。

00:22:18.000 -> 00:22:22.000
VM内から、ロゼッタでPHPサーバーを実行します。

00:22:22.000 -> 00:22:27.000
そして、macOSホストから接続するだけです。

00:22:27.000 -> 00:22:31.000
仮想マシンの作成がかつてないほど簡単になったことを見てきました。

00:22:31.000 -> 00:22:37.000
仮想化フレームワークを使用すると、わずか数行のコードで仮想マシンを実行できます。

00:22:37.000 -> 00:22:42.000
また、macOSでは仮想マシンが途方もなく高速であることも見てきました。

00:22:42.000 -> 00:22:47.000
仮想化の詳細については、コードサンプルとドキュメントをチェックしてください。

00:22:47.000 -> 00:22:51.000
そして、チームを代表して、あなたがこの技術で次に何をするかを見るのが待ちきれません。

00:22:51.000 -> 23:59:59.000
。

