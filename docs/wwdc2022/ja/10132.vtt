WEBVTT

00:00:00.000 --> 00:00:03.000
♪まろやかなインストゥルメンタルヒップホップ音楽♪

00:00:03.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:14.000
こんにちは、私の名前はミンディで、写真チームのエンジニアです。

00:00:14.000 --> 00:00:20.000
今日は、あなたのアプリで写真の変更履歴にアクセスする方法について説明します。

00:00:20.000 --> 00:00:29.000
PhotoKitは、フォトライブラリに保存されている写真、ビデオ、アルバムにアクセスして更新するための豊富なAPIセットを提供します。

00:00:29.000 --> 00:00:45.000
PhotoKitは、写真、カスタムカメラ、または人々がユニークな方法でフォトライブラリを閲覧する方法を提供するアプリを管理または編集するために、深いレベルの写真へのアクセスと統合を必要とするアプリのために設計されています。

00:00:45.000 --> 00:00:54.000
これらのタイプのアプリケーションは、フォトエクスペリエンスを密接に反映するために、フォトライブラリが時間の経過とともにどのように変化するかを監視したい場合があります。

00:00:54.000 --> 00:01:02.000
人々が友人とハイキング旅行の写真を共有したり編集したりできるソーシャルハイキングアプリを作成したとしましょう。

00:01:02.000 --> 00:01:13.000
誰かがアプリを起動すると、アプリは最新のハイキングワークアウトの開始と終了のタイムスタンプから写真を収集し、山での経験のコラージュを生成します。

00:01:13.000 --> 00:01:18.000
コラージュは、フォトライブラリから選択した写真と同期します。

00:01:18.000 --> 00:01:25.000
たとえば、誰かが友人からハイキングの写真を受け取った場合、アプリはこれらのアップデートを使用して新しいコラージュを生成します。

00:01:25.000 --> 00:01:37.000
これまで、アプリが新しく挿入されたアセットと以前のハイキングコラージュへの変更を発見するために、アプリは一連のフェッチを実行する必要がありました。

00:01:37.000 --> 00:01:46.000
どのアセットが挿入されたかを判断するために、アプリは最後のアプリの起動日より後に作成された日付でアセットを取得できます。

00:01:46.000 --> 00:01:50.000
資産の更新と削除の決定は難しいです。

00:01:50.000 --> 00:02:06.000
アプリは、すべてのコラージュですべての資産を再フェッチし、変更日を確認して資産の更新を決定する必要がありますが、資産の変更日は内部の写真処理活動によって設定できるため、これは誤検出をもたらす可能性があります。

00:02:06.000 --> 00:02:16.000
フォトライブラリの削除は、すべての追跡されたアセットをフェッチして、フェッチで返されなかったアセットをデフする必要があるため、追跡がより困難です。

00:02:16.000 --> 00:02:28.000
合計で、これは、アプリが起動されるたびに3つの別々のチェックを行う必要があることを意味し、アプリが大量の資産を表示している場合は特にコストがかかる可能性があります。

00:02:28.000 --> 00:02:38.000
不確実な結果のために異なるフェッチとチェックを実行する代わりに、1つの統一されたAPI呼び出しで何が変わったのかを正確に知る方法があったらどうでしょうか?

00:02:38.000 --> 00:02:42.000
さて、私たちはちょうどそれをやったと言うことに興奮しています!

00:02:42.000 --> 00:02:50.000
新しい変更履歴APIを使用すると、フォトライブラリのオフライン更新を簡単に追跡できます。

00:02:50.000 --> 00:02:58.000
変更履歴は、フォトライブラリへの挿入、更新、削除などの変更のタイムラインで構成されています。

00:02:58.000 --> 00:03:07.000
このタイムラインの例では、過去3日間の変更履歴にさまざまなアセット、アルバム、フォルダの変更があります。

00:03:07.000 --> 00:03:17.000
このタイムラインを使用して、過去2日間、またはアプリを最後に起動した時にどの変更が発生したかをどのように判断できますか?

00:03:17.000 --> 00:03:25.000
特定の時点でのフォトライブラリの状態を表す永続的な変更トークンを使用できるようになりました。

00:03:25.000 --> 00:03:37.000
このトークンは、アプリの起動中に保持することができ、サードパーティのアプリの変更を含む、そのトークン以降に発生したフォトライブラリへの変更を取得するために使用できます。

00:03:37.000 --> 00:03:45.000
アプリが制限付きライブラリモードの場合、ユーザーが選択したPhotoKitオブジェクトの変更のみが返されることに注意してください。

00:03:45.000 --> 00:03:55.000
この変更トークンはデバイスにローカルであり、いつでも永続的な変更またはフォトライブラリインスタンスからアクセスするのが安価です。

00:03:55.000 --> 00:04:06.000
この新しいAPIは、macOS、iOS、iPadOS、tvOSなど、PhotoKitをサポートするすべてのプラットフォームで利用できます。

00:04:06.000 --> 00:04:14.000
アプリが実行され、フォトライブラリで作業している間、アプリ内に永続的な変更トークンを保存できます。

00:04:14.000 --> 00:04:21.000
後で、トークンを使用して、その後発生したフォトライブラリの変更を取得できます。

00:04:21.000 --> 00:04:33.000
永続的な変更ごとに、アセット、アセットコレクション、コレクションリストの3種類の写真オブジェクトの変更の詳細を取得できます。

00:04:33.000 --> 00:04:36.000
では、これはコードでどのように見えますか?

00:04:36.000 --> 00:04:42.000
まず、最後に保存された変更トークンを使用して、永続的な変更を取得します。

00:04:42.000 --> 00:04:53.000
次に、永続的な変更を列挙し、各永続的な変更オブジェクトの変更の詳細（この場合は「asset」タイプの）を取得します。

00:04:53.000 --> 00:05:04.000
これらの変更の詳細は、変更トークン以降、どのローカル識別子が更新され、削除され、フォトライブラリに挿入されたかに関する情報を提供します。

00:05:04.000 --> 00:05:10.000
これらの変更を処理した後、将来の使用のために最後の変更トークンを保存できます。

00:05:10.000 --> 00:05:18.000
新しい永続的な履歴APIと既存の変更オブザーバーAPIを比較して対比しましょう。

00:05:18.000 --> 00:05:28.000
PHChangesは、アクティブなインメモリフェッチ結果を処理し、アプリの実行中にフォトライブラリへのライブ変更を記録するために使用されます。

00:05:28.000 --> 00:05:38.000
一方、永続的な履歴は、フォトライブラリへの長期にわたる変更を記録し、アプリがアクティブでない場合からの変更を報告するために使用できます。

00:05:38.000 --> 00:05:45.000
アプリの要件に応じて、これらのAPIの両方またはどちらかを使用できます。

00:05:45.000 --> 00:05:55.000
ハイキングアプリの例に戻ると、ハイキングコラージュを作成および更新するために、永続的な履歴APIを使用してアセットの変更を追跡したいと思います。

00:05:55.000 --> 00:06:02.000
まず、最後に保存された変更トークンを使用して、永続的な変更を取得します。

00:06:02.000 --> 00:06:13.000
次に、永続的な変更を反復し、関連する資産変更の詳細をつかみ、挿入、更新、削除された識別子を処理します。

00:06:13.000 --> 00:06:25.000
アプリは変更の取得から返されるすべての情報を必要としないため、変更履歴からアプリに影響を与えるライブラリの変更を特定する必要があります。

00:06:25.000 --> 00:06:38.000
アプリは、新しいハイキングワークアウトのためにどのアセットがフォトライブラリに追加され、以前のハイキングコラージュで参照されたアセットが更新および削除されたかを知ることが重要です。

00:06:38.000 --> 00:06:47.000
私はすでに、永続的な変更を通じて列挙することから、挿入、更新、削除されたアセットのローカル識別子の3つのセットを特定しました。

00:06:47.000 --> 00:06:51.000
これを反映するためにアプリを更新するにはどうすればよいですか?

00:06:51.000 --> 00:07:08.000
insertedIdentifiersセットを使用して、挿入されたアセットを取得し、各ハイキングの開始日と終了日に対して作成日をチェックすることで、ハイキングのタイムスタンプの間に追加されたアセットを判断できます。

00:07:08.000 --> 00:07:20.000
更新されたアセットに調整が適用される可能性があるため、新しいhasAdjustments APIを使用して、UIでアセットを再描画する必要があるかどうかを確認できます。

00:07:20.000 --> 00:07:27.000
削除されたアセットのローカル識別子を使用して、どのコラージュを再生成する必要があるかを判断できます。

00:07:27.000 --> 00:07:36.000
今、私はすべてのオフラインフォトライブラリの変更を処理し、私のアプリは最新です。

00:07:36.000 --> 00:07:42.000
新しい変更履歴APIを使用する際に留意すべき点がいくつかあります。

00:07:42.000 --> 00:07:49.000
まず、あなたとあなたのアプリにとって重要な変更を判断し、それらの変更のみを確認します。

00:07:49.000 --> 00:07:59.000
パフォーマンスを向上させるために、複数の小さなリクエストではなく、更新および挿入されたアセットの1つの大きなフェッチリクエストを実行することを検討してください。

00:07:59.000 --> 00:08:12.000
フォトライブラリは、内部での処理と同期活動のために大きく変更される可能性があるため、特にアプリが頻繁に起動しない場合は、大量の変更を列挙してしまう可能性があります。

00:08:12.000 --> 00:08:20.000
このため、UIをブロックしないように、バックグラウンドスレッドの変更履歴を尋ねることをお勧めします。

00:08:20.000 --> 00:08:25.000
永続的な履歴を取得するときに発生する可能性のあるエラーには2つのタイプがあります。

00:08:25.000 --> 00:08:33.000
変更トークンが利用可能な変更履歴よりも古い場合、期限切れの変更トークンエラーが返されます。

00:08:33.000 --> 00:08:44.000
場合によっては、永続的な変更は、発生した変更を完全に再構築するために信頼できず、変更の詳細が利用できないというエラーが返されます。

00:08:44.000 --> 00:08:54.000
このような場合、アプリが最新であることを確認するために、フォトライブラリで追跡されたオブジェクトを再フェッチすることをお勧めします。

00:08:54.000 --> 00:09:01.000
締めくくる前に、あなたと共有したい新しいPhotoKit APIがいくつかあります。

00:09:01.000 --> 00:09:08.000
PhotoKitは、メディアサブタイプとスマートアルバムによる映画ビデオへのアクセスをサポートするようになりました。

00:09:08.000 --> 00:09:11.000
2つの新しいエラーコードもあります。

00:09:11.000 --> 00:09:23.000
フォトライブラリバンドルがmacOSのファイルプロバイダ同期ルートディレクトリにある場合、ライブラリが破損する可能性があり、変更を実行しようとするとエラーが返されます。

00:09:23.000 --> 00:09:31.000
ネットワークの問題でアセットリソースが見つからない場合、リソース要求はネットワークエラーを返すようになりました。

00:09:31.000 --> 00:09:35.000
すべての最新のアップデートについては、開発者ドキュメントを確認してください。

00:09:35.000 --> 00:09:44.000
最後に、写真で作業してアクセスする最も簡単な方法であるため、写真ピッカーで今年のセッションを必ずチェックしてください。

00:09:44.000 --> 00:09:51.000
私たちは、あなたが新しい変更履歴APIとPhotoKitのすべての素晴らしい新機能を使用することにとても興奮しています。

00:09:51.000 --> 00:09:52.000
ありがとう！

00:09:52.000 --> 23:59:59.000
♪

