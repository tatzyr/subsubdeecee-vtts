WEBVTT

00:00:00.000 --> 00:00:03.000
♪まろやかなインストゥルメンタルヒップホップ音楽♪

00:00:03.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:14.000
こんにちは、私の名前はデニスで、ここアップルのディスプレイとカラーテクノロジーチームの一員です。

00:00:14.000 --> 00:00:19.000
今日は、EDRに関するいくつかのエキサイティングなアップデートと、iOS開発者への影響を探ります。

00:00:19.000 --> 00:00:29.000
昨年のプレゼンテーションを見たことがあるなら、すでにEDRに精通しているかもしれませんが、短い要約として、EDRは拡張ダイナミックレンジを指し、AppleのHDR技術です。

00:00:29.000 --> 00:00:40.000
EDRは、レンダリング技術とピクセル表現の両方を指し、EDRのピクセル表現は、標準とハイダイナミックレンジの両方のコンテンツを一貫して表しているため、特に重要です。

00:00:40.000 --> 00:00:51.000
よく露出したコンテンツでは、被写体（この例では、キャンパー）は画像の標準ダイナミックレンジ内に収まるはずですが、キャンプファイヤーなどの鏡面および発光ハイライトはより高い範囲に収まるでしょう。

00:00:51.000 --> 00:00:58.000
標準範囲表現では、これらの要素は最終的にクリップされますが、EDRでは表現可能なままです。

00:00:58.000 --> 00:01:07.000
他のピクセル表現は固定範囲の輝度値を表すように設計されていますが、EDRの表現は本当に動的で、任意の値を記述することができます。

00:01:07.000 --> 00:01:15.000
さらに、未使用のバックライトを利用することで、EDRはディスプレイのピークに関係なく、あらゆるディスプレイが高ダイナミックレンジのコンテンツをレンダリングできるようにします。

00:01:15.000 --> 00:01:22.000
そして、HDRコンテンツがはるかに普及し、アクセスしやすくなるにつれて、macOSでEDRを採用しているアプリケーションのリストもそうです。

00:01:22.000 --> 00:01:29.000
「Baldur's Gate 3」、「Divinity: Original Sin 2」、「Shadow of the Tomb Raider」は、すでにmacOSのEDRで出荷されています。

00:01:29.000 --> 00:01:37.000
EDRを採用することで、ゲームはより明るく、より飽和した色をレンダリングするだけでなく、よりリアルな照明、反射、よりカラフルなコンテンツを生成することができます。

00:01:37.000 --> 00:01:45.000
明るい要素がSDRピークホワイトに限定される場合、EDRでは、著者が意図したように活気と深さを取り戻します。

00:01:45.000 --> 00:01:50.000
EDRは、SafariやQuickTimeプレーヤーなど、Appleのエコシステム全体に統合されています。

00:01:50.000 --> 00:02:02.000
その結果、Apple TVやNetflixなどのビデオオンデマンドアプリやサービスは、増え続けるHDR10、ドルビービジョン、ProResコンテンツのカタログを消費者に配信することができます。

00:02:02.000 --> 00:02:15.000
EDRを採用したプロアプリは、HDRの静止画やビデオを正確に編集、グレーディング、マスター、レビューするためのさまざまなプロフェッショナルなワークフローを提供することで、ユーザーが素晴らしいHDRコンテンツを作成できるようにします。

00:02:15.000 --> 00:02:20.000
macOSでのEDRの採用に関するすべての興奮で、私たちはEDRにいくつかの新しいアップデートをもたらすことに興奮しています。

00:02:20.000 --> 00:02:26.000
まず第一に、EDR APIがiOSとiPadOSで利用可能になったことをお知らせします。

00:02:26.000 --> 00:02:36.000
さらに、プロユーザーをサポートするAppleの取り組みの一環として、今年はLiquid Retina XDRディスプレイを搭載した12.9インチiPad Proに2つの新しいプロカラー機能を導入します。

00:02:36.000 --> 00:02:40.000
サイドカーを上るリファレンスモードとEDRレンダリング。

00:02:40.000 --> 00:02:53.000
リファレンスモードは、macOSのリファレンスプリセットと同様に、さまざまな一般的なビデオフォーマットのリファレンスレスポンスを提供することで、カラーグレーディング、編集、コンテンツレビューなどのカラークリティカルなワークフローを可能にするように設計された新しいディスプレイモードです。

00:02:53.000 --> 00:03:02.000
これを行うには、リファレンスモードはSDRのピーク輝度を100ニト、HDRのピーク輝度を1000ニトに固定し、10倍のEDRヘッドルームを与えます。

00:03:02.000 --> 00:03:06.000
リファレンスモードは、マッピングを表示するための1対1のメディアも提供します。

00:03:06.000 --> 00:03:16.000
また、True Tone、Auto-Brightness、Night Shiftなど、アンビエントサラウンドのすべてのダイナミックディスプレイ調整を無効にし、代わりにユーザーが手動でホワイトポイントを細かく調整できるようにします。

00:03:16.000 --> 00:03:22.000
このようにして、ディスプレイはそれぞれの仕様で説明されているとおりに色を生成します。

00:03:22.000 --> 00:03:26.000
このチャートは、参照モードがサポートするフォーマットのリストを提供します。

00:03:26.000 --> 00:03:37.000
macOSの参照プリセットとは異なり、参照モードは、最も一般的な5つのHDRおよびSDRビデオフォーマットをサポートする単一のトグルであり、メディアタイプ間で一貫した参照応答を提供することに注意してください。

00:03:37.000 --> 00:03:41.000
そして、この表に記載されていない形式のコンテンツがある場合でも心配しないでください。

00:03:41.000 --> 00:03:46.000
サポートされていないフォーマットは、デフォルトの表示モードと同様にカラー管理されます。

00:03:46.000 --> 00:03:49.000
例として、リファレンスモードでのLumaFusionを見てみましょう。

00:03:49.000 --> 00:03:55.000
iOSでリファレンスモードを有効にすることで、LumaFusionはビデオポストプロダクションのためのより強力なツールになります。

00:03:55.000 --> 00:04:05.000
HDRビデオを表示する場合、1000ニトピークまでのP3色域内の色が正確にレンダリングされるため、ユーザーは自分のビデオが常に正しく一貫して表示されていることを確信できます。

00:04:05.000 --> 00:04:12.000
リファレンスモードとLumaFusionの新しいビデオスコープ機能の組み合わせにより、iPad Proでカラークリティカルなワークフローが可能になりました。

00:04:12.000 --> 00:04:19.000
参照モードを無効にすると、EDRヘッドルームは動的に変化する可能性があり、iOSがビデオの明るさを変調するので、ここで見ることができます。

00:04:19.000 --> 00:04:29.000
ユーザーはLumaFusionプロジェクトをXMLとしてエクスポートすることができ、他の人気のあるMacポストプロダクションアプリでインポートすることができ、コンテンツクリエイターのチームが両方のプラットフォームで簡単にコラボレーションできます。

00:04:29.000 --> 00:04:37.000
LumaFusionがリファレンスモードを採用し、プロのコンテンツクリエイターにもたらす価値と柔軟性を見るのはとてもエキサイティングです。

00:04:37.000 --> 00:04:39.000
しかし、リファレンスモードだけが新機能ではありません。

00:04:39.000 --> 00:04:46.000
2019年には、MacユーザーがiPadをセカンダリディスプレイとして使用できる技術であるSidecarを導入しました。

00:04:46.000 --> 00:05:02.000
そして今、リファレンスモードの導入により、SidecarでのEDRレンダリングのサポートが追加されています。これは、リファレンスモードがリファレンスグレードのSDRとHDRコンテンツをサポートするために有効になっているときにSidecarの機能を拡張し、プロのコンテンツクリエイターがiPad ProをAppleシリコンMacのセカンダリリファレンスディスプレイとして使用できるようにします。

00:05:02.000 --> 00:05:11.000
言うまでもなく、サイドカーでレンダリングされたコンテンツは、参照モードでネイティブiOSと同じビデオフォーマットの参照応答を提供します。

00:05:11.000 --> 00:05:20.000
たとえば、HDRビデオプリセットでMacでレンダリングされたこのHDR10テストパターンを見て、Sidecarを使用したiPad Proのレンダリングと比較しましょう。

00:05:20.000 --> 00:05:29.000
この構成では、両方のデバイスがP3カラーとD65ホワイトポイントのリファレンスディスプレイとして機能します。

00:05:29.000 --> 00:05:37.000
P3のプライマリカラーバーとセカンダリカラーバーからわかるように、MacとiPadの両方が予想と同様の反応を生み出します。

00:05:37.000 --> 00:05:47.000
さらに、両方の構成は1000ニトのピーク輝度をサポートし、グラデーションに見られるように、これらの値は忠実にレンダリングされ、1000ニトを超える値はクリップされます。

00:05:47.000 --> 00:05:52.000
私たちは、サイドカーをレンダリングするEDRがプロユーザーにもたらす見通しと新しい機会に興奮しています。

00:05:52.000 --> 00:05:58.000
また、より多くの開発者が独自のアプリでEDRを採用することで、これらの機能を利用することを楽しみにしています。

00:05:58.000 --> 00:06:04.000
そのメモでは、EDRレンダリングを独自のiOSおよびiPadOSアプリに統合する方法を探りましょう。

00:06:04.000 --> 00:06:09.000
まず、EDRのピクセル表現とレンダリングパイプラインの影響を見てみましょう。

00:06:09.000 --> 00:06:17.000
伝統的に、SDRの浮動小数点表現は0対1の範囲の値で、0は黒、1はSDRは白でした。

00:06:17.000 --> 00:06:24.000
EDRでは、SDRコンテンツは依然として0から1の範囲で表されますが、1を超える値はSDRよりも明るいコンテンツを表します。

00:06:24.000 --> 00:06:32.000
EDRは線形空間で表されることに注意してください。これは、2.0 EDRが1.0の2倍明るくないことを意味します。

00:06:32.000 --> 00:06:39.000
他のHDRフォーマットとは異なり、EDRは0から1の範囲に値をトーンマップせず、これはレンダリングにいくつかの意味があります。

00:06:39.000 --> 00:06:45.000
その点で、EDRはSDRコンテンツ、または0から1までの値が常にレンダリングされることを保証します。

00:06:45.000 --> 00:06:50.000
そして、1を超える値は、現在のEDRヘッドルームにトーンマッピングすることなく適切にレンダリングされます。

00:06:50.000 --> 00:06:53.000
ただし、より明るい値はクリップされます。

00:06:53.000 --> 00:07:07.000
当初、この動作は不可能に思えるかもしれませんが、HDRで制作されたコンテンツは、従来の表現のように明るすぎるハイライトで、可能な限り意図に近くレンダリングされることを意味します。

00:07:07.000 --> 00:07:11.000
明らかに、ヘッドルームが高ければ高いほど、コンテンツはより明るく、よりダイナミックになります。

00:07:11.000 --> 00:07:13.000
しかし、私たちはどのくらいのヘッドルームを持っていますか?

00:07:13.000 --> 00:07:26.000
さて、瞬間的なEDRヘッドルームは動的値であり、デバイスの特定のディスプレイ技術や現在のディスプレイの明るさを含むがこれらに限定されない多くの要因に基づいていることに注意してください。

00:07:26.000 --> 00:07:35.000
しかし、単純化しすぎとして、現在のEDRヘッドルームは、ディスプレイの最大輝度を現在のSDR輝度で割った値とほぼ同じです。

00:07:35.000 --> 00:07:47.000
先ほど、リファレンスモードが10倍のEDRヘッドルームを提供すると言ったのは、EDR 1.0（またはSDRの明るさ）を100ニトに固定し、HDRのピーク輝度を1000ニトに修正したからです。

00:07:47.000 --> 00:07:53.000
したがって、1000ニトを100ニトで割ると、EDRの10倍の一定のヘッドルームが得られます。

00:07:53.000 --> 00:07:58.000
この表は、さまざまなデバイスとその最大潜在的なヘッドルームの例をもう少し示します。

00:07:58.000 --> 00:08:06.000
これは潜在的なヘッドルームであり、真のヘッドルームは、現在のディスプレイの明るさを含む他のさまざまな要因に依存することに注意してください。

00:08:06.000 --> 00:08:13.000
この講演の後半では、ヘッドルームについてさらに詳しく説明し、ヘッドルームを照会して使用してレンダリングについて情報に基づいた決定を下す方法の例を紹介します。

00:08:13.000 --> 00:08:18.000
しかし、今のところ、あなたはEDRとあなたがそれを望むときによく理解しているはずです。

00:08:18.000 --> 00:08:21.000
それでは、実際にいくつかのEDRコンテンツをレンダリングするようにギアをシフトしましょう。

00:08:21.000 --> 00:08:26.000
このセクションでは、HDRコンテンツをレンダリング可能な形式に読み取る方法について説明します。

00:08:26.000 --> 00:08:34.000
私たちが取り上げる特定の例は、イメージI/Oワークフローですが、別のフレームワークをお探しの場合は、今年の他のEDRトークの1つをご覧ください。

00:08:34.000 --> 00:08:38.000
静止メディアの場合は、読み込む画像ファイルから始めます。

00:08:38.000 --> 00:08:42.000
この画像は通常、二平面YUV空間でエンコードされます。

00:08:42.000 --> 00:08:47.000
最初に読み込むと、画像とバッファは元の形式になります。

00:08:47.000 --> 00:08:52.000
残念ながら、その形式では、意味のある方法で画像を解釈して作業するのは難しい場合があります。

00:08:52.000 --> 00:08:57.000
したがって、CGBitmapContextの助けを借りて、画像をデコードしてより使用可能な形式に変換します。

00:08:57.000 --> 00:09:05.000
その時点で、コンテキストのバッキングピクセルデータからMTLTextureを作成し、Metalエンジンでレンダリングすることができます。

00:09:05.000 --> 00:09:09.000
より具体的には、これを達成するためには、4つのステップをカバーする必要があります。

00:09:09.000 --> 00:09:24.000
まず、HDR静止画用のCGImageを作成し、そのCGImageをビットマップコンテキストに描画し、Metalテクスチャを作成し、最後に、ビットマップのデータを新しく作成されたテクスチャにロードします。

00:09:24.000 --> 00:09:28.000
最初のステップでは、画像を読んで、少しセットアップを行います。

00:09:28.000 --> 00:09:35.000
まず、URLからCGImageSourceに画像を読み込み、そのソースからCGImageを作成します。

00:09:35.000 --> 00:09:39.000
この場合、nilオプション辞書を渡して画像を作成しました。

00:09:39.000 --> 00:09:48.000
ただし、特定のHDRフォーマットの浮動小数点バッファをご希望の場合は、設定したい新しいkCGImageSourceShouldAllowFloatオプションがあります。

00:09:48.000 --> 00:09:51.000
次に、CGBitmapInfoをインスタンス化します。

00:09:51.000 --> 00:09:56.000
この場合、事前に乗算されたアルファで16ビットの浮動小数点コンテキストを作成しています。

00:09:56.000 --> 00:10:01.000
メタルテクスチャを同じフォーマットにしたいので、これを覚えておいてください。

00:10:01.000 --> 00:10:08.000
次に、作成したビットマップ情報とCGImageの幅と高さを使用して、CGBitmapContextを構築します。

00:10:08.000 --> 00:10:14.000
コンテキストの色空間は、レンダリングするCAMetalLayerの色空間と一致するようにしたいことに注意してください。

00:10:14.000 --> 00:10:18.000
それ以外の場合は、適切なカラーマネジメントを自分で実行する必要があります。

00:10:18.000 --> 00:10:23.000
最後に、CGImageをビットマップコンテキストに描画します。

00:10:23.000 --> 00:10:28.000
この時点で、コンテキストからメタルテクスチャの作成に進むことができます。

00:10:28.000 --> 00:10:32.000
メタルテクスチャを作成するには、まずMTLTextureDescriptorをインスタンス化します。

00:10:32.000 --> 00:10:45.000
以前から、ビットマップコンテキストにハーフフロートを使用することを選択したことを思い出してください。しかし、EDRをレンダリングするときは、10ビットの青、緑、赤、2ビットアルファの32ビットパックピクセル形式で2Dテクスチャを持つこともできます。

00:10:45.000 --> 00:10:55.000
次のセクションで詳しく説明しますが、今のところ、テクスチャのピクセル形式がコンテンツのピクセル形式と一致する必要があることを知るだけで十分です。私たちの場合、ハーフフロートです。

00:10:55.000 --> 00:11:02.000
この時点で、メタルレイヤーのデバイスと新しく作成されたテクスチャ記述子でテクスチャをインスタンス化します。

00:11:02.000 --> 00:11:08.000
最後に、ビットマップコンテキストからデータを入手し、テクスチャにコピーします。

00:11:08.000 --> 00:11:14.000
それにより、レンダリングのためにMetalパイプラインに送信できるEDR値を含むMetalテクスチャがあります。

00:11:14.000 --> 00:11:21.000
このセクションでは、URLから始めてメタルテクスチャまで、HDR静止画を調達するためのサンプルワークフローを取り上げました。

00:11:21.000 --> 00:11:27.000
次に、iOSとiPadOSでそのようなテクスチャをレンダリングするために必要な最小限のコード変更について確認します。

00:11:27.000 --> 00:11:33.000
新しいiOSおよびiPadOS APIでEDRを選択するプロセスは、macOSのプロセスと同じです。

00:11:33.000 --> 00:11:39.000
したがって、アプリのmacOSビルドのEDRサポートがすでにある場合は、変更を加える必要はありません。

00:11:39.000 --> 00:11:52.000
EDRにオプトインするには、CAMetalLayerを使用していることを確認し、そのレイヤーに適切なフラグとタグを設定し、サポートされているEDR形式で明るいコンテンツがあることを確認する必要があります。

00:11:52.000 --> 00:11:56.000
まず、コンテンツをレンダリングするCAMetalLayerを取ります。

00:11:56.000 --> 00:12:02.000
そのレイヤーでは、 wantsExtendedDynamicRange Content フラグを有効にします。

00:12:02.000 --> 00:12:08.000
次に、同じレイヤーで、ピクセルフォーマットとCGColorSpaceのサポートされている組み合わせを設定する必要があります。

00:12:08.000 --> 00:12:14.000
コンテンツの種類とソース方法によって、特定のピクセル形式と色空間が異なります。

00:12:14.000 --> 00:12:22.000
私たちの場合、画像を16ビットの浮動小数点バッファにロードし、ここでは拡張リニアディスプレイP3色空間と一致させることを選択しました。

00:12:22.000 --> 00:12:28.000
iOSは、線形色空間と組み合わせた16ビット浮動小数点ピクセルバッファでのEDRのレンダリングをサポートしています。

00:12:28.000 --> 00:12:33.000
ただし、これらの組み合わせのいずれかを使用する場合は、必ず色空間の拡張バリアントを使用してください。

00:12:33.000 --> 00:12:36.000
そうしないと、コンテンツはSDRにクリップされます。

00:12:36.000 --> 00:12:42.000
iOsは、先に簡単に述べた10ビットパックされたBGRAピクセルバッファもサポートしています。

00:12:42.000 --> 00:12:48.000
このようなバッファは、このチャートで概説されているように、PQまたはHLG色空間のいずれかでレンダリングするためにサポートされています。

00:12:48.000 --> 00:13:01.000
このセクションでは、 wantsExtendedDynamicRangeContentフラグや、EDRをサポートするさまざまなピクセル形式や色空間など、EDRレンダリングをサポートするためにレンダリングレイヤーに必要な最小限のコード変更を取り上げました。

00:13:01.000 --> 00:13:08.000
この時点で、Metalテクスチャをレンダリングする場合、前のセクションからこのセクションのCAMetalLayerに供給すると、EDRをレンダリングします。

00:13:08.000 --> 00:13:11.000
しかし、私たちができるトリックがいくつかあります。

00:13:11.000 --> 00:13:16.000
概要で述べたように、EDRのデフォルトの動作は、現在のEDRヘッドルームにクリップすることです。

00:13:16.000 --> 00:13:23.000
ヘッドルームがEDRコンテンツのレンダリングを正当化するのに十分な高さではないと判断し、代わりにSDRパスを下る場合があります。

00:13:23.000 --> 00:13:28.000
または、現在のヘッドルームを使用して、表示する前にコンテンツをトーンマップしたい場合。

00:13:28.000 --> 00:13:38.000
いずれの場合も、iOSにはヘッドルームのクエリをサポートする新しいAPIがあります。このセクションでは、呼び出しとmacOSとの違いについて説明し、そのような決定を下すことができます。

00:13:38.000 --> 00:13:42.000
macOSでは、ヘッドルームクエリはNSScreenにあります。

00:13:42.000 --> 00:13:52.000
NSScreenでは、ディスプレイがサポートできる最大EDRヘッドルーム、現在の参照プリセットの最大EDRヘッドルーム、および現在のEDRヘッドルームに関するクエリがあります。

00:13:52.000 --> 00:13:57.000
さらに、macOSはEDRのヘッドルームが変更されるたびに通知を提供します。

00:13:57.000 --> 00:14:09.000
ただし、iOSでは、ヘッドルームクエリはUIScreenにあり、NSScreenとは異なり、代わりにディスプレイがサポートする最大EDRヘッドルームと現在のEDRヘッドルームのクエリがあります。

00:14:09.000 --> 00:14:17.000
さらに、UIScreenは、参照モードがサポートされ、有効になっているかどうかを示すために使用される参照表示モードのステータスを提供します。

00:14:17.000 --> 00:14:24.000
UIScreenはEDRヘッドルームの変更に関する通知を提供しませんが、参照モードのステータスが変更されるたびに通知を送信することに注意してください。

00:14:24.000 --> 00:14:29.000
また、最大参照ヘッドルームクエリがリストから欠落していることに気付くかもしれません。

00:14:29.000 --> 00:14:37.000
専用のクエリを使用する代わりに、参照モードのステータスが参照モードが有効になっていることを示しているときに、潜在的な最大ヘッドルームを照会することで、その値を決定できます。

00:14:37.000 --> 00:14:42.000
ヘッドルームを照会する方法をよりよく理解するために、いくつかのサンプルコードを見てみましょう。

00:14:42.000 --> 00:14:48.000
UIScreenでは、潜在的なEDRHeadroomを照会して、ディスプレイの可能な最大ヘッドルームを確認できます。

00:14:48.000 --> 00:14:55.000
この値が低すぎると判断した場合は、代わりにSDRパスをレンダリングすることを選択して、処理能力を節約できます。

00:14:55.000 --> 00:15:01.000
その後、EDRパスを決定した場合は、レンダリングデリゲートまたは定期的にスケジュールされたドローコールがあるかもしれません。

00:15:01.000 --> 00:15:10.000
この呼び出しでは、現在のEDRHeadroomを照会し、それを使用してコンテンツをトーンマップして、どれもヘッドルームを超えないようにし、クリップしないようにすることができます。

00:15:10.000 --> 00:15:21.000
参照モードのステータスを知りたい場合は、UIScreen.referenceDisplayMode StatusDidChangeNotificationを使用して、ステータスが変更されるたびに通知を受け取るように登録できます。

00:15:21.000 --> 00:15:30.000
その後、ステータスが変更されるたびに、新しいステータスと新しい潜在的なEDRヘッドルームを取得し、それらを使用してレンダリングに関するさらなる決定を下すことができます。

00:15:30.000 --> 00:15:35.000
参照モードのステータスについては、知っておくべき4つの固有の状態があります。

00:15:35.000 --> 00:15:40.000
StatusEnabledは、参照モードが有効になっており、期待どおりにレンダリングされていることを示します。

00:15:40.000 --> 00:15:46.000
StatusLimitedは、参照モードが有効になっているが、何らかの理由で一時的に参照応答を達成できないことを示しています。

00:15:46.000 --> 00:15:55.000
このステータスが発生した場合、参照応答が侵害されたことをユーザーに通知する参照外のUI通知が添付されることに注意してください。

00:15:55.000 --> 00:16:01.000
StatusNotEnabledは、このデバイスで参照モードがサポートされているが、有効になっていないことを示します。

00:16:01.000 --> 00:16:06.000
そして最後に、StatusNotSupportedは、このデバイスで参照モードがサポートされていないことを示します。

00:16:06.000 --> 00:16:16.000
これらの新しいAPIは、開発者にディスプレイの現在の状態に関するより深い洞察を提供し、EDRコンテンツのレンダリング方法について十分な情報に基づいた決定を下すために必要なツールを提供する必要があります。

00:16:16.000 --> 00:16:24.000
前のセクションでは、コンテンツをトーンマップし、クリッピングを避けるために使用できる現在のEDRヘッドルームを含む、さまざまなヘッドルームパラメータを照会する方法を取り上げました。

00:16:24.000 --> 00:16:28.000
しかし、独自のトーンマッピングアルゴリズムを掘り下げたり実装したりしたくない場合はどうなりますか?

00:16:28.000 --> 00:16:33.000
さて、ビデオコンテンツの場合、Appleの内蔵トーンマッピングを利用したいと思うかもしれません。

00:16:33.000 --> 00:16:44.000
コンテンツでAppleのトーンマッピングを有効にしたい場合は、HDR10とHLGの両方のメタデータコンストラクタを含むCAEDRメタデータインターフェイスを使用して有効にすることができます。

00:16:44.000 --> 00:16:51.000
トーンマッピングはすべてのプラットフォームでサポートされているわけではありませんが、プラットフォームにこのサポートがあるかどうかを確認できるクエリがあることに注意してください。

00:16:51.000 --> 00:16:57.000
プラットフォームがトーンマッピングをサポートしているかどうかを確認するには、CAEDRMetadata.isAvailableに問い合わせてください。

00:16:57.000 --> 00:17:01.000
利用可能な場合は、CAEDRMetadataをインスタンス化する必要があります。

00:17:01.000 --> 00:17:06.000
すぐに特定のコンストラクタを調べますが、今のところこのステップをスキップしましょう。

00:17:06.000 --> 00:17:10.000
EDRメタデータを取得したら、レンダリングするレイヤーに適用します。

00:17:10.000 --> 00:17:16.000
これにより、提供されたメタデータに基づいて、レイヤーがシステムトーンマッパーによって処理されることが選択されます。

00:17:16.000 --> 00:17:23.000
前述のように、HDRビデオフォーマットに固有のEDRメタデータコンストラクタがいくつかあります。

00:17:23.000 --> 00:17:29.000
ここには、パラメータを取らないHLGメタデータのコンストラクタがあります。

00:17:29.000 --> 00:17:32.000
次に、利用可能な2つのHDR10コンストラクタのうちの1つです。

00:17:32.000 --> 00:17:45.000
これには3つのパラメータが必要です。マスタリングディスプレイの最小輝度（nits）、マスタリングディスプレイの最大輝度（nits）、およびEDR 1.0のコンテンツマッピングとnitsの明るさを示す光出力スケールです。

00:17:45.000 --> 00:17:48.000
通常、これを100に設定します。

00:17:48.000 --> 00:18:03.000
最後に、MasterDisplayColourVolume SEIメッセージ、ContentLightLevelInformation SEIメッセージ、およびopticalOutputScaleを取るHDR10コンストラクタの2番目があり、前述のように、通常は100ニトに設定されています。

00:18:03.000 --> 00:18:09.000
これらのコンストラクタの1つを使用してCAEDRMetadataオブジェクトを作成したら、アプリケーションのCAMetalLayerに設定します。

00:18:09.000 --> 00:18:18.000
これにより、このレイヤーでレンダリングされたすべてのコンテンツがシステムトーンマッパーによって処理されるため、マッピングを自分で実行せずにクリッピングを回避できます。

00:18:18.000 --> 00:18:29.000
どのコンストラクタを使用するかは、コンテンツがどのようにソースまたは作成されたかに完全に依存しますが、通常、コンテンツがHLG色空間にある場合は、HLGコンストラクタを使用する必要があります。

00:18:29.000 --> 00:18:34.000
そして、それがPQ色空間にある場合は、HDR10コンストラクタを使用したいと思うでしょう。

00:18:34.000 --> 00:18:41.000
コンテンツにSEIメッセージがすでに添付されている場合は、著者の意図を最もよく遵守するために、2番目のHDR10コンストラクタを使用することをお勧めします。

00:18:41.000 --> 00:18:45.000
それ以外の場合は、最初のコンストラクタを使用する必要があります。

00:18:45.000 --> 00:18:51.000
線形色空間を使用している場合、使用するコンストラクタは、コンテンツの作成方法に完全に依存します。

00:18:51.000 --> 00:19:00.000
したがって、Appleのトーンマッピングで使用する場合は、HDR10とHLGメタデータに関する開発者ドキュメントを読むことを強くお勧めします。

00:19:00.000 --> 00:19:03.000
それでは、PixelmatorとそのEDRの採用を見てみましょう。

00:19:03.000 --> 00:19:07.000
EDRのおかげで、より鮮やかでリアルな方法で画像をレンダリングできます。

00:19:07.000 --> 00:19:18.000
たとえば、RAW写真を開いて露出とハイライトを増やすと、最も明るい領域の詳細は、SDRとも呼ばれるディスプレイの標準ダイナミックレンジを使用してレンダリングできません。

00:19:18.000 --> 00:19:23.000
さて、EDRをオンにすると、SDRホワイトを超えたすべての詳細が目に見えるようになります。

00:19:23.000 --> 00:19:28.000
キャンバスのSDR色と比較して、EDRコンテンツがどれだけ鮮やかに表示されるかに注意してください。

00:19:28.000 --> 00:19:34.000
EDRをオフにすると、SDRとEDRの視覚的な違いがより明らかになります。

00:19:34.000 --> 00:19:37.000
そして、それでセッションは終わりました。

00:19:37.000 --> 00:19:41.000
この講演では、iOSとiPadOSに登場するいくつかの新しいエキサイティングな機能を取り上げました。

00:19:41.000 --> 00:19:54.000
EDRに関する簡単な復習を提供し、画像I / OでHDR画像を読み取り、それをメタルテクスチャに変換するためのサンプルワークフローを検討し、SDRにクリッピングせずにそのテクスチャをレンダリングできるようにEDRにオプトインする方法を調べました。

00:19:54.000 --> 00:20:06.000
また、ヘッドルームクエリAPIと、EDRレンダリングに関する情報に基づいた決定を下す際の有用性、および一般的なHDRフォーマットのトーンマッピングを提供するAppleのシステムにオプトインする方法についても簡単に触れました。

00:20:06.000 --> 00:20:12.000
EDRとそれをiOSとiPadOSのアプリに採用する方法をよりよく理解して、この話から出てきたことを願っています。

00:20:12.000 --> 00:20:22.000
HDR、または一般的なEDRコンテンツでの作業についてもっと知りたい場合は、前年のいくつかのセッションと、私がお勧めするいくつかの今後のセッションがあります。

00:20:22.000 --> 00:20:25.000
とはいえ、私たちのセッション「iOSでのEDRの探索」にご参加いただきありがとうございます。

00:20:25.000 --> 00:20:27.000
そして、素晴らしいWWDCを!

00:20:27.000 --> 23:59:59.000
♪

