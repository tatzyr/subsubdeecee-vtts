WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:12.000
モハメッド：こんにちは、私はUIKitのモハメッドです。

00:00:12.000 --> 00:00:17.000
デスクトップクラスのiPadアプリの構築に深く参加していただきありがとうございます。

00:00:17.000 --> 00:00:25.000
このビデオでは、iPadOS 16 APIを使用して、既存のiPadアプリをデスクトップクラスのエクスペリエンスに更新します。

00:00:25.000 --> 00:00:35.000
新しいナビゲーションバーAPIを使用して、強力な機能を表面化し、UI密度を高め、カスタマイズ性を提供することから始めます。

00:00:35.000 --> 00:00:45.000
次に、新しいUICollectionViewとメニューAPIを採用して、複雑なワークフローと複数の選択に対する迅速なアクションを有効にします。

00:00:45.000 --> 00:00:52.000
そして、新しい検索と置換のエクスペリエンスを有効にし、新しい編集メニューでテキスト編集を強化することで、物事を締めくくります。

00:00:52.000 --> 00:00:57.000
アップデートするアプリは、iPadOS 15用に構築されたMarkdownエディタです。

00:00:57.000 --> 00:01:13.000
近代化プロセスの各ステップを歩きながら、私たちの選択の背後にあるベストプラクティスと動機について話し合い、同様のプロセスを通じて独自のアプリを受講しながら考慮すべき要因のアイデアを提供します。

00:01:13.000 --> 00:01:30.000
始める前に少し入門書をご希望の場合は、「Meet Desktop Class iPad」でUIKitのすべての新しいiPadOS APIの内訳を確認し、「iPadアプリデザインの新機能」をチェックして、可能な限り最高のデスクトップクラスのiPadアプリを設計する方法のヒントを確認してください。

00:01:30.000 --> 00:01:32.000
よし、すぐに飛び込もう！

00:01:32.000 --> 00:01:37.000
物事を始めるために、アプリのコントロールの構成を考えてみましょう。

00:01:37.000 --> 00:01:50.000
このアプリはiPadOS 15用に設計されているため、すでにナビゲーションバーに最も重要なコントロールを公開し、さまざまなメニューやポップオーバーにセカンダリコントロールを配置しています。

00:01:50.000 --> 00:02:01.000
iPadOS 16では、UIKitは既存のナビゲーションスタイルを形式化し、より密度が高く、よりカスタマイズ可能なレイアウトで2つの新しいスタイルを導入します。

00:02:01.000 --> 00:02:11.000
これにより、アプリはUIの最前線により多くの機能をもたらしながら、コンテンツに最も適したレイアウトを表現することができます。

00:02:11.000 --> 00:02:16.000
ナビゲーターアプリには、使い慣れたプッシュ/ポップナビゲーションモデルがあります。

00:02:16.000 --> 00:02:23.000
これは通常、設定などの階層データを表示するアプリに適しています。

00:02:23.000 --> 00:02:34.000
Safariやファイルなどのブラウザは、複数のドキュメントやフォルダ構造の間を行き来したりナビゲートしたりするのに理想的です。

00:02:34.000 --> 00:02:42.000
また、編集者は、個々のドキュメントの集中的な表示や編集に最適です。

00:02:42.000 --> 00:02:48.000
マークダウンエディターとして、このスタイルは私たちのアプリに最適です。

00:02:48.000 --> 00:02:55.000
エディタスタイルは、タイトルをバーの最前縁に合わせ、新しいアイテムセットの中心を開きます。

00:02:55.000 --> 00:03:02.000
これにより、他のビューやメニューに隠されていた可能性のある追加機能を公開することができます。

00:03:02.000 --> 00:03:07.000
このデザインをできるだけ活用するために、いくつかのことをします。

00:03:07.000 --> 00:03:12.000
まず、ニーズに合わせて組み込みのバックアクションをカスタマイズすることから始めます。

00:03:12.000 --> 00:03:18.000
次に、ドキュメント情報と一般的なドキュメントアクションを含むタイトルメニューを追加します。

00:03:18.000 --> 00:03:23.000
また、新しい組み込みのリネームUIによる名前変更のサポートも追加します。

00:03:23.000 --> 00:03:30.000
そして最後に、以前に埋もれた機能をバーの中央に持っていくことで、より簡単にアクセスできるようにします。

00:03:30.000 --> 00:03:39.000
まず、ビューコントローラーのnavigationItemのstyleプロパティを.editorに設定して、エディタスタイルを選択することから始めましょう。

00:03:39.000 --> 00:03:47.000
これはすぐに私たちに主要な整列されたタイトルを与え、センターエリアを開きます。

00:03:47.000 --> 00:03:55.000
その後、末尾の完了ボタンを削除し、新しいbackAction APIを使用して置き換えましょう。

00:03:55.000 --> 00:04:05.000
このようにして、このビューを却下し、ドキュメントピッカーに戻るアクションのより標準的な外観が得られます。

00:04:05.000 --> 00:04:09.000
次に、私たちのアプリがタイトルメニューの恩恵を受けるかどうかを調べてみましょう。

00:04:09.000 --> 00:04:15.000
名前が示すように、タイトルメニューはナビゲーションバーのタイトルビューから表示されます。

00:04:15.000 --> 00:04:22.000
ドキュメント全体に適用されるドキュメントメタデータとサーフェスアクションを表示するのに最適な場所です。

00:04:22.000 --> 00:04:29.000
アプリがドキュメントベースでない場合は、ビュー全体に適用されるアクションを表示するのに適した場所かもしれません。

00:04:29.000 --> 00:04:37.000
私たちのアプリでは、ドキュメントメニューのヘッダーを使用して、ドキュメントに関する有用な情報を表示することは理にかなっています。

00:04:37.000 --> 00:04:45.000
また、ドキュメントのドラッグ可能な表現を提供し、共有機能に簡単にアクセスすることもできます。

00:04:45.000 --> 00:04:49.000
そして今、いくつかのコードを書く時が来ました!

00:04:49.000 --> 00:05:00.000
私たちのアプリはUIDocumentバックアップされているので、UIDocumentのfileURLを使用してUIDocumentPropertiesオブジェクトをインスタンス化できます。

00:05:00.000 --> 00:05:07.000
次に、同じURLを使用してNSItemProviderを作成します。

00:05:07.000 --> 00:05:18.000
次に、アイテムプロバイダーを使用して、プロパティオブジェクトの dragItemsProviderから返すUIDragItemを作成します。

00:05:18.000 --> 00:05:27.000
また、プロパティオブジェクトのactivityViewControllerProviderから返すUIActivityViewControllerを構築するためにも使用します。

00:05:27.000 --> 00:05:34.000
そして最後に、プロパティオブジェクトをエディタビューコントローラーのnavigationItemのdocumentPropertiesとして設定します。

00:05:34.000 --> 00:05:44.000
先ほど書いたコードは、このドキュメントヘッダーに表示され、名前、サイズ、アイコン表現など、ドキュメントの簡単な概要を提供します。

00:05:44.000 --> 00:05:57.000
ドラッグアイテムとアクティビティビューコントローラーのプロバイダーを指定したので、アイコンをドラッグしてドキュメントをアプリの外にコピーしたり、共有ボタンをタップしてアクティビティビューコントローラーを表示したりできます。

00:05:57.000 --> 00:06:05.000
ドキュメントヘッダーを表示することに加えて、タイトルメニューは、ドキュメント全体に適用される機能を提供するのに適した場所です。

00:06:05.000 --> 00:06:19.000
このメニューに表示できるアクションには2種類あります。事前に定義されたローカライズされたタイトルとシンボル画像を持つシステム提供のアクションと、アプリが提供する完全にカスタムのアクションです。

00:06:19.000 --> 00:06:24.000
追加の動作が付属しているので、名前変更のアクションから始めましょう。

00:06:24.000 --> 00:06:30.000
リネームデリゲートプロトコルに準拠することで、このアクションをメニューに追加できます。

00:06:30.000 --> 00:06:35.000
トリガーされると、アクションはバーの組み込みの名前変更UIを表示します。

00:06:35.000 --> 00:06:43.000
まず、ビューコントローラーをナビゲーションアイテムのrenameDelegateとして割り当てます。

00:06:43.000 --> 00:06:52.000
次に、表示されたドキュメントの実際の名前変更を処理するために、navigationItemDidEndRenamingWithTitleを実装します。

00:06:52.000 --> 00:06:56.000
この関数は、名前変更アクションがコミットされたときに呼び出されます。

00:06:56.000 --> 00:07:02.000
実際にドキュメントの名前を変更してこれを処理するのはアプリの責任です。

00:07:02.000 --> 00:07:08.000
APIは、アプリが持つ可能性のあるあらゆる種類のデータモデルをサポートするために、意図的にオープンエンドです。

00:07:08.000 --> 00:07:15.000
他のシステムが提供するアクションに移るには、まずエディタービューコントローラーでそれらの機能をオーバーライドする必要があります。

00:07:15.000 --> 00:07:20.000
ここでは、重複機能と移動機能を実装しました。

00:07:20.000 --> 00:07:32.000
UIKitは、name変更アクションを含むシステムが提供するアクションを、提案されたUIMenuElementsの配列として、navigationItemのtitleMenuProviderに自動的に表示します。

00:07:32.000 --> 00:07:39.000
タイトルメニューに含めるには、返されたメニューの子供に追加するだけです。

00:07:39.000 --> 00:07:47.000
システムで導入されたアクションに加えて、完全にカスタムアクションやメニュー全体の階層を追加することもできます。

00:07:47.000 --> 00:07:54.000
ここでは、HTMLおよびPDFサブアクションとしてエクスポートするエクスポートサブメニューを追加しました。

00:07:54.000 --> 00:08:01.000
これにより、タイトルビューをタップすると、ドキュメントヘッダーと追加したすべてのアクションを含むメニューが表示されます。

00:08:01.000 --> 00:08:08.000
そして、名前の変更を選択すると、組み込みの名前変更UIが有効になり、ドキュメントの名前を変更できます。

00:08:08.000 --> 00:08:17.000
アプリの基本構造を確立し始めたので、Mac触媒でアプリを構築するときに物事がどのように見えるかを確認する良い機会です。

00:08:17.000 --> 00:08:24.000
Macでアプリを実行すると、先頭に整列したタイトルのエディタスタイルがうまく翻訳されていることがわかります。

00:08:24.000 --> 00:08:31.000
私たちのバックアクションも引き継がれ、クリックするとファイルブラウザが表示されます。

00:08:31.000 --> 00:08:37.000
システムが提供するアクションと名前変更機能は、アプリのファイルメニューに自動的に表示されます。

00:08:37.000 --> 00:08:46.000
titleMenuProviderはMac Catalystでは呼び出されないため、カスタムアクションはファイルメニューに含まれていないことに注意してください。

00:08:46.000 --> 00:08:55.000
これらのアクションを公開するには、メインのUIMenuSystemを使用してアプリのメインメニューに手動で追加する必要があります。

00:08:55.000 --> 00:08:57.000
よし、近代化のプロセスを続けましょう。

00:08:57.000 --> 00:09:01.000
目標に向かって前進するにつれて、私たちはMacをチェックし続けます。

00:09:01.000 --> 00:09:06.000
バーのセンターエリアで利用可能な機会を考えてみましょう。

00:09:06.000 --> 00:09:13.000
iOS 15バージョンのアプリには、多くのセカンダリコントロールとツールを保持するメニューがあります。

00:09:13.000 --> 00:09:19.000
センターアイテムを使用すると、これらのツールをより見つけやすくすることができます。

00:09:19.000 --> 00:09:28.000
センターエリアはカスタマイズ可能であるため、あまり一般的に使用されていないものでUIを埋めることを心配することなく、コントロールの大規模なセットを含めることができます。

00:09:28.000 --> 00:09:33.000
各人は、自分のワークフローに合わせてバーの内容を調整できます。

00:09:33.000 --> 00:09:41.000
カスタマイズを有効にする最初のステップは、ナビゲーション項目にcustomizationIdentifierを指定することです。

00:09:41.000 --> 00:09:46.000
次に、センターアイテムをUIBarButtonItemGroupsとして定義します。

00:09:46.000 --> 00:09:54.000
グループは、UINavigationBarに拡張され、iOS 16でのカスタマイズをサポートするように強化された既存の概念です。

00:09:54.000 --> 00:09:59.000
このスクリーンショットは、デフォルトで表示したいセンターアイテムのセットを示しています。

00:09:59.000 --> 00:10:15.000
左側の同期スクロールボタンは、他の手段では到達できない重要な機能を提供するため、UIBarButtonItemの新しいcreatingFixedGroup（）関数を使用して固定グループに配置することは理にかなっています。

00:10:15.000 --> 00:10:22.000
固定グループはカスタマイズできず、ユーザーが移動することはできません。

00:10:22.000 --> 00:10:36.000
一方、リンクの追加ボタンは重要な機能を提供せず、エディタでリンクタグを入力することで同じタスクを達成できるため、createtOptionalGroupを使用して完全にカスタマイズ可能なアイテムを作成します。

00:10:36.000 --> 00:10:45.000
そして、アプリの起動時中にカスタマイズが持続するように、一意のcustomizationIdentifierを与えます。

00:10:45.000 --> 00:10:54.000
同様のプロセスに従って、デフォルトセットの残りの項目を定義し、デフォルトで使用する必要のない優先順位の低い項目に進みます。

00:10:54.000 --> 00:11:01.000
そのような項目の1つは、太字、斜体、下線付きの項目を含むテキスト形式グループです。

00:11:01.000 --> 00:11:10.000
デフォルトで表示するほど重要ではありませんが、バーにドラッグできるようにカスタマイズポップオーバーに入れたいです。

00:11:10.000 --> 00:11:21.000
これを実現するには、isInDefaultCustomizationがfalseに設定されているUIBarButtonItemGroupのoptionalGroup初期化子を使用します。

00:11:21.000 --> 00:11:33.000
また、ポップオーバーにタイトルがあり、バーのスペースがなくなったときに折りたたむことができるコンパクトな表現を持つように、グループに代表的なアイテムを与えるようにしてください。

00:11:33.000 --> 00:11:38.000
iPadに戻ると、私たちが定義した中央のアイテムがバーの中央に表示されます。

00:11:38.000 --> 00:11:44.000
新しく追加された詳細ボタンをクリックすると、メニューがツールバーのカスタマイズアクションとともに表示されます。

00:11:44.000 --> 00:11:49.000
それをクリックすると、カスタマイズモードが有効になります。

00:11:49.000 --> 00:12:00.000
固定としてマークした同期スクロールボタンは強調解除され、静的ですが、他のすべてのアイテムは持ち上げて振ってカスタマイズ可能であることを示しています。

00:12:00.000 --> 00:12:09.000
フォーマットグループなどのオプション項目がポップオーバーに表示され、バーにドラッグできます。

00:12:09.000 --> 00:12:19.000
Macでアプリを実行すると、中央の項目が完全にカスタマイズ可能なmacOSツールバーボタンに変換されていることがわかります。

00:12:19.000 --> 00:12:24.000
先に進む前に、ちょっとiPadに戻って、アプリのサイズを変更しましょう。

00:12:24.000 --> 00:12:30.000
ツールバーで利用可能なスペースが少なくなったため、中央の項目は表示されなくなりました。

00:12:30.000 --> 00:12:37.000
UIKitは、利用可能なスペースに応じて、センターアイテムの表示と非表示を自動的に処理します。

00:12:37.000 --> 00:12:42.000
合わないアイテムはオーバーフローメニューに表示されます。

00:12:42.000 --> 00:12:52.000
標準のバーボタン項目は自動的にメニュー表現に変換されますが、必要に応じてカスタムメニュー表現を提供することもできます。

00:12:52.000 --> 00:13:00.000
UIKitはカスタムビューアイテムの目的についての洞察がないため、スライダーアイテムは自動的に翻訳されません。

00:13:00.000 --> 00:13:04.000
メニュー表現を手動で指定する必要があります。

00:13:04.000 --> 00:13:06.000
これが私たちのスライダーアイテムです。

00:13:06.000 --> 00:13:12.000
これは、カスタムビューを持つ単一のバーボタンアイテムで、オプションのバーボタングループで囲まれています。

00:13:12.000 --> 00:13:25.000
スライダーのコア機能を提供するために、メニュー表現を減少、リセット、増加アクションを含むUIMenuとして定義します。

00:13:25.000 --> 00:13:35.000
UIMenuの新しいpreferredElementSizeプロパティを使用すると、メニューをよりコンパクトなサイドバイサイドの外観にすることができます。

00:13:35.000 --> 00:13:48.000
また、新しいKeepsMenuPresented属性を使用すると、各アクションが実行された後にメニューを表示し続けることができ、メニューを却下して再表示することなく、フォントサイズを複数回変更できます。

00:13:48.000 --> 00:13:51.000
これをiPadでもう一度実行しましょう。

00:13:51.000 --> 00:14:02.000
オーバーフローメニューを表示すると、スライダーは3つのサイドバイサイドアクションを持つインラインメニューとして表示され、スライダーの全機能をカバーしています。

00:14:02.000 --> 00:14:09.000
小さな要素サイズはMacには存在しないため、アクションは標準のmacOSメニュー項目として表示されます。

00:14:09.000 --> 00:14:13.000
そして、それはUIの整理とカスタマイズのためのものです。

00:14:13.000 --> 00:14:19.000
次に、新しいコレクションビューとメニューAPIを使用して、アプリのワークフローを高速化することを検討しましょう。

00:14:19.000 --> 00:14:27.000
私たちのアプリには、ドキュメントをすばやくナビゲートしたり、トップレベルのタグでアクションを実行したりするために使用できる目次サイドバーがあります。

00:14:27.000 --> 00:14:40.000
iOS 16以前は、複数のアイテムを編集する機能を追加すると、バルクアクションがツールバーのボタンに追いやられ、個別の編集モードを実装することを意味する可能性があります。

00:14:40.000 --> 00:14:53.000
iOS 16では、マルチアイテムメニューの新しいデザインが導入され、メニューがどのアイテムに影響するかを明確に伝え、マルチアイテムドラッグへの直接移行を提供します。

00:14:53.000 --> 00:15:00.000
デスクトップクラスのiPadアプリでは、この新しいメニューデザインは、より軽い重量選択スタイルと組み合わせるのが最適です。

00:15:00.000 --> 00:15:09.000
ここでの「軽量」とは、コレクションビューを編集モードにしたり、アプリのUIに大幅な変更を加えたりすることなく、複数のアイテムを選択することを意味します。

00:15:09.000 --> 00:15:15.000
これを達成し、既存のAPIを使用してキーボードフォーカスを有効にすることができます。

00:15:15.000 --> 00:15:21.000
まず、allowsMultipleSelectionをtrueに設定します。

00:15:21.000 --> 00:15:28.000
次に、allowsFocusをtrueに設定して、キーボードフォーカスを有効にします。

00:15:28.000 --> 00:15:36.000
そして、selectionFollowsFocusをtrueに設定することで、フォーカスが選択を促進できるようにします。

00:15:36.000 --> 00:15:46.000
iPadでこれを実行すると、各アイテムが選択に追加されると、まだ選択アクションが実行され、エディタビューがスクロールされることにすぐに気付きます。

00:15:46.000 --> 00:15:51.000
コードに戻って、何が起こっているのかを把握しましょう。 

00:15:51.000 --> 00:15:52.000
そこにある！

00:15:52.000 --> 00:16:01.000
didSelectItemAtIndexPathのコードは、collectionViewのisEditingプロパティをチェックすることで、編集モードでのスクロールを禁止しようとします。

00:16:01.000 --> 00:16:08.000
編集モード以外で複数の選択を許可したので、このコードはすべての選択に対して実行されます。

00:16:08.000 --> 00:16:12.000
新しいUICollectionViewDelegateメソッドを使用して修正できます。

00:16:12.000 --> 00:16:21.000
performPrimaryActionForItemAtIndexPathを実装し、スクロールコードをこの新しい関数に移動するだけです。

00:16:21.000 --> 00:16:31.000
この関数は、単一のアイテムがタップされ、コレクションビューが編集されていない場合にのみ呼び出されるため、編集モードのチェックは不要になりました。

00:16:31.000 --> 00:16:43.000
また、選択関連の動作がないため、indexPathで選択した項目の実装を削除できます。

00:16:43.000 --> 00:16:50.000
iPadに戻って、複数のアイテムを選択すると、エディタビューで対応するテキストにスクロールしなくなりました。

00:16:50.000 --> 00:16:55.000
それが終わったら、実際にメニューのサポートを追加しましょう。

00:16:55.000 --> 00:17:02.000
iPadOS 16では、UICollectionViewDelegateの既存の単一項目メニューメソッドは非推奨です。

00:17:02.000 --> 00:17:08.000
その代替品は、ゼロから多くのアイテムのメニューの表示をサポートしています。

00:17:08.000 --> 00:17:17.000
指定されたindexPaths配列の項目の数は、選択される項目の数と、メニューが呼び出される場所によって異なります。

00:17:17.000 --> 00:17:25.000
配列が空の場合、メニューはセル間の空白で呼び出されました。

00:17:25.000 --> 00:17:35.000
単一のindexPathがある場合、選択解除されたアイテム、または唯一選択されたアイテムで呼び出されました。

00:17:35.000 --> 00:17:44.000
複数の項目がある場合、メニューは複数の選択の一部である項目で呼び出されました。

00:17:44.000 --> 00:17:56.000
iPadに戻り、上位4つの項目をもう一度選択し、選択した項目の1つを2本指でクリックすると、新しいマルチアイテムメニューが表示されます。

00:17:56.000 --> 00:18:02.000
Macで同じことをすると、選択したセルの周りにリングが描かれ、それらを強調表示します。

00:18:02.000 --> 00:18:10.000
マルチアイテムメニューが完了したら、新しい検索と置換と編集メニュー機能を使用して、テキスト編集体験を強化することを検討しましょう。

00:18:10.000 --> 00:18:26.000
私たちのアプリはエディタにUITextViewを使用し、カスタムの検索と置換の動作を必要としないため、デフォルトのシステム機能を有効にするために必要なのは、テキストビューのisFindInteractionEnabledプロパティをtrueに設定することだけです。

00:18:26.000 --> 00:18:33.000
その設定では、テキストの編集中にCommand + Fを押すと、検索と置換のUIが表示されます。

00:18:33.000 --> 00:18:41.000
テキストビューの編集メニューにカスタムアクションを追加することはそれほど多くなく、いくつかの優れたクイック編集機能を有効にすることができます。

00:18:41.000 --> 00:18:48.000
推奨されるアクションの範囲内のテキストの新しいUITextViewDelegateメソッド編集メニューを実装するだけです。

00:18:48.000 --> 00:18:59.000
実装では、この非表示アクションのようなカスタムアクションとシステムメニューを組み合わせたUIMenuを構築して返すことができます。

00:18:59.000 --> 00:19:08.000
そして、これが結果です。テキストを選択して編集メニューを表示すると、カスタムアクションとシステム提供アクションの両方が表示されます。

00:19:08.000 --> 00:19:17.000
検索と置換と編集メニューの詳細については、「デスクトップクラスの編集インタラクションを採用する」を参照してください。そして、それだけです!

00:19:17.000 --> 00:19:25.000
これらのいくつかの変更により、私たちはアプリのデスクトップクラスを作り、それをMacにシームレスに翻訳するためのいくつかの素晴らしい基本的なステップを踏み出しました。

00:19:25.000 --> 00:19:31.000
iPadOS 16で提供されているAPIを使用して、独自のアプリを同様のプロセスで実行します。

00:19:31.000 --> 00:19:35.000
アプリに合ったナビゲーションスタイルを選択することから始めます。

00:19:35.000 --> 00:19:39.000
ドキュメントのプロパティとタイトルメニューを使用して、ドキュメントのワークフローを強化します。

00:19:39.000 --> 00:19:45.000
そして、重要な機能を表面化し、センターアイテムでカスタマイズ性を提供します。

00:19:45.000 --> 00:19:49.000
マルチアイテムメニューを使用して、複数のアイテムにすばやく対応できるようにします。

00:19:49.000 --> 00:19:54.000
また、検索と置換と新しい編集メニューを使用して、アプリのテキスト編集体験を向上させます。

00:19:54.000 --> 00:20:01.000
新しいアプリを構築する場合でも、既存のアプリを更新する場合でも、これらの新しいツールで構築したアプリを使用するのが待ちきれません。

00:20:01.000 --> 23:59:59.000
見てくれてありがとう。

