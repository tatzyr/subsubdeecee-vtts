WEBVTT

00:00:00.000 --> 00:00:13.000
- こんにちは！私はケントで、CloudKitチームのエンジニアです。

00:00:13.000 --> 00:00:18.000
CloudKitにアクセスするために使用できる新しいライブラリを紹介できることを嬉しく思います。

00:00:18.000 --> 00:00:21.000
まず、この新しいライブラリの設定方法について説明します。

00:00:21.000 --> 00:00:27.000
そして、スキーマを管理する方法と、CKTool JSでユーザーデータにアクセスする方法を学びます。

00:00:27.000 --> 00:00:29.000
始めましょう！

00:00:29.000 --> 00:00:35.000
CloudKitは、アプリのデータをコンテナ内のiCloudに保存できる永続性技術です。

00:00:35.000 --> 00:00:42.000
アプリでCloudKitを使用することで、デバイスやウェブ上でデータを最新の状態に保つこともできます。

00:00:42.000 --> 00:00:51.000
アプリを構築するには、Appleプラットフォーム上のCloudKitフレームワークまたはウェブ上のCloudKit JSを使用してiCloudストレージにアクセスできます。

00:00:51.000 --> 00:00:57.000
自動化とツールを実装するために、XcodeはmacOSで使用するためのcktoolを提供します。

00:00:57.000 --> 00:01:03.000
そして今、CKTool JSを使用して、変更を自動化し、iCloudと対話する新しい方法があります。

00:01:03.000 --> 00:01:13.000
CKTool JSを使用すると、Xcode 13で導入されたcktoolコマンドラインユーティリティと同じ操作を実行でき、同様のユースケースをサポートしています。

00:01:13.000 --> 00:01:21.000
実際、CKTool JSは、レコードタイプの追加やレコードのクエリなど、CloudKitコンソールの機能を実装するために使用されます。

00:01:21.000 --> 00:01:29.000
CKTool JSを使用すると、アプリコンテナを管理し、スキーマのリセットや更新の適用などのスキーマ操作を実行できます。

00:01:29.000 --> 00:01:33.000
これは、以前はJavaScriptではできなかったことです。

00:01:33.000 --> 00:01:39.000
CKTool JSを使用すると、一意の識別子または複雑なクエリを使用して既存のレコードを取得できます。

00:01:39.000 --> 00:01:43.000
また、新しいレコードを作成して更新することができます。

00:01:43.000 --> 00:01:47.000
CKTool JSには、TypeScriptの厳密な型定義が付属しています。

00:01:47.000 --> 00:01:55.000
これらの型定義は、クライアントライブラリの誤った使用にフラグを立て、サポートされているIDEでのコード補完を可能にするコンパイル時のチェックを可能にします。

00:01:55.000 --> 00:02:00.000
このため、CKTool JSコードの編集が容易になります。

00:02:00.000 --> 00:02:05.000
さらに、この新しいライブラリには、Node.jsとブラウザの両方をサポートしてすぐに付属しています。

00:02:05.000 --> 00:02:13.000
CKTool JSはnpmパッケージのセットとして配布されており、JavaScriptビルドパイプラインの一部として統合できます。

00:02:13.000 --> 00:02:18.000
そうすることで、ツリーシェイキングやバンドルなどの機能が可能になります。

00:02:18.000 --> 00:02:26.000
リリース履歴はnpmから透過的に利用できるため、これらのパッケージの更新を追跡することもできます。

00:02:26.000 --> 00:02:29.000
以下のパッケージは、CKTool JSディストリビューションの一部です。

00:02:29.000 --> 00:02:38.000
これらのパッケージは@appleスコープ内にあり、名前の先頭にcktoolを使用する慣習に従っていることに注意してください。

00:02:38.000 --> 00:02:42.000
使用するメインパッケージはcktool.databaseです。

00:02:42.000 --> 00:02:57.000
iCloudとの通信を有効にするには、ターゲットプラットフォーム用の別のパッケージ、Node.js用のcktool.target.nodejs、またはWebブラウザ用のcktool.target.browserを使用する必要があります。

00:02:57.000 --> 00:03:10.000
Cktool.databaseは、cktool.core、cktool.api.base、cktool.api.databaseの3つのパッケージを自動的に取り込みます。

00:03:10.000 --> 00:03:15.000
CKTool JSはiCloudと直接通信するため、まず承認する必要があります。

00:03:15.000 --> 00:03:21.000
呼び出す操作によっては、管理トークンまたはユーザートークンが必要です。

00:03:21.000 --> 00:03:25.000
どちらの種類のトークンもCloudKitコンソールから入手できます。

00:03:25.000 --> 00:03:31.000
管理トークンは、管理操作にアクセスするために使用され、チームとユーザーにスコープされます。

00:03:31.000 --> 00:03:39.000
このような操作には、スキーマのインポートとエクスポートの有効化、スキーマの検証、およびコンテナを本番環境にリセットすることが含まれます。

00:03:39.000 --> 00:03:46.000
ユーザートークンは、チームとコンテナにスコープされ、それらのコンテナ内のプライベートユーザーデータへのアクセスを可能にします。

00:03:46.000 --> 00:03:58.000
これらの承認トークンの取得方法とCloudKitとの継続的な統合方法については、WWDC21の「cktoolと宣言型スキーマでCloudKitテストを自動化する」をチェックしてください。

00:03:58.000 --> 00:04:03.000
スクリプトでCKTool JSを使用する場合は、まず使用するように設定する必要があります。

00:04:03.000 --> 00:04:09.000
しかし、CKTool JSの設定に飛び込む前に、CloudKitスキーマを構成するものを簡単に確認します。

00:04:09.000 --> 00:04:13.000
CloudKitでは、データは構造化された方法で保存されます。

00:04:13.000 --> 00:04:18.000
同じ種類の値を持つデータは、レコードとして一緒に保存されます。

00:04:18.000 --> 00:04:25.000
レコードはレコードタイプのインスタンスであり、レコードタイプが記述するレコードのプロパティはフィールドとして知られています。

00:04:25.000 --> 00:04:32.000
CloudKitは、ユーザー定義のフィールドに加えて、レコードのIDであるrecordNameなどのシステムフィールドを追加します。

00:04:32.000 --> 00:04:35.000
私が取り組んできたコインコレクションアプリの例を使います。

00:04:35.000 --> 00:04:42.000
国のコレクションを保存したいので、保存する必要があるプロパティの種類を説明するレコードタイプがあります。

00:04:42.000 --> 00:04:47.000
名前とISOコードを保存し、レコードタイプに「国」という名前を付けています。

00:04:47.000 --> 00:04:53.000
ISOコードは国を一意に識別するので、私のレコードタイプにそれらを含めることが重要です。

00:04:53.000 --> 00:04:58.000
この情報を名前と一緒に保存するために、国タイプのレコードをいくつか作成します。

00:04:58.000 --> 00:05:03.000
私はまた、特定の国のコインの記録タイプを持っており、それらを互いに関連付けたいです。

00:05:03.000 --> 00:05:10.000
コインレコードタイプは、コインからその国との関係を保存します。

00:05:10.000 --> 00:05:13.000
レコードタイプと関係が組み合わさってスキーマが作成されます。

00:05:13.000 --> 00:05:18.000
これらの要素の現在の状態は、私のスキーマの現在のバージョンであると考えることができます。

00:05:18.000 --> 00:05:26.000
アプリを開発するにつれて、スキーマを進化させ、アプリの存続期間中、いくつかのバージョンを持つ可能性があります。

00:05:26.000 --> 00:05:33.000
私のアプリのスキーマは、iCloudに保存したいデータの構造を説明していますが、私のアプリコンテナはそのデータが保存されている場所です。

00:05:33.000 --> 00:05:38.000
コンテナには一意の識別子があり、開発者チームに関連付けられています。

00:05:38.000 --> 00:05:43.000
CloudKitで作業する際に留意すべき環境は2つあります。

00:05:43.000 --> 00:05:47.000
開発環境は、ユーザーを混乱させることなく変更を加えるのに安全な場所です。

00:05:47.000 --> 00:05:51.000
これは、スキーマの変更をテストして開発すべき場所です。

00:05:51.000 --> 00:05:56.000
ユーザーがアプリと対話すると、本番環境と対話します。

00:05:56.000 --> 00:05:59.000
本番環境には、アプリのライブデータが含まれています。

00:05:59.000 --> 00:06:05.000
CloudKitがデータを保存する方法を復習したので、CKTool JSの設定方法について説明します。

00:06:05.000 --> 00:06:15.000
CKTool JSはiCloudと話しているので、適切なコンテナで作業する方法を知っていて、スクリプトがそうする権限を与えられるように、いくつかの情報を収集する必要があります。

00:06:15.000 --> 00:06:20.000
チームIDと、作業したいコンテナのコンテナIDが必要です。

00:06:20.000 --> 00:06:27.000
スキーマを操作するには管理トークンが必要で、スクリプトがデータにアクセスする場合は、ユーザートークンも必要です。

00:06:27.000 --> 00:06:30.000
これらの値はすべて、CloudKitコンソールから取得できます。

00:06:30.000 --> 00:06:35.000
また、スクリプトが実行される環境、開発、または本番環境を指定する必要があります。

00:06:35.000 --> 00:06:38.000
今後、開発を例に挙げます。

00:06:38.000 --> 00:06:43.000
使用するためにCKTool JSを設定するたびに、これらの値が必要になります。

00:06:43.000 --> 00:06:46.000
私の例として、私はNode.jsのスクリプトを書いています。

00:06:46.000 --> 00:06:51.000
それらを使用するために、CKTool JSからオブジェクトと関数をインポートします。

00:06:51.000 --> 00:06:56.000
この場合、CommonJS requireステートメントを使用してこれらのシンボルをインポートできます。

00:06:56.000 --> 00:07:02.000
設定情報を収集したら、その情報を保持するオブジェクトを作成します。

00:07:02.000 --> 00:07:08.000
認証トークンを保存するには、管理トークンを保持するオブジェクトを作成し、ある場合はユーザートークンを作成します。

00:07:08.000 --> 00:07:17.000
teamId、containerId、および環境はCKTool JSに渡される一般的な値であるため、これらの値を保持するオブジェクトを作成できます。

00:07:17.000 --> 00:07:26.000
createConfigurationファクトリ関数を使用して、CKTool JSにiCloudとの会話方法を伝えるConfigurationオブジェクトをインスタンス化します。

00:07:26.000 --> 00:07:28.000
createConfigurationはプラットフォーム固有です。

00:07:28.000 --> 00:07:35.000
この場合、ターゲットパッケージからインポートされた関数であるため、Node.jsの適切な設定を返します。

00:07:35.000 --> 00:07:42.000
次に、設定オブジェクトと以前に宣言されたセキュリティオブジェクトを渡して、APIオブジェクトを初期化します。

00:07:42.000 --> 00:07:47.000
APIオブジェクトには、iCloudと通信できる非同期メソッドが含まれています。

00:07:47.000 --> 00:07:51.000
これで、スクリプトでCKTool JSを使用する手順を完了しました。

00:07:51.000 --> 00:07:56.000
CKTool JSを使用してコンテナのスキーマを管理する方法について学びましょう。

00:07:56.000 --> 00:08:02.000
私のアプリでは、2007年に発行されたアメリカのダイムなどの情報を保存したいです。

00:08:02.000 --> 00:08:08.000
このコインは銅とニッケルで構成されており、刻印された価値は1米ドルの10分の1です。

00:08:08.000 --> 00:08:18.000
このデータの保存方法を考えた後、コインの組成に関する情報をコインに関する他の詳細とは別のレコードとして保存することにしました。

00:08:18.000 --> 00:08:24.000
だから私はダイムの銅パーセンテージとそのニッケルパーセンテージを別々の記録に保存します。

00:08:24.000 --> 00:08:28.000
コンテナのスキーマにしたい2つのレコードタイプを特定しました。

00:08:28.000 --> 00:08:33.000
国の参照、発行年、名目価値を格納するコイン。

00:08:33.000 --> 00:08:40.000
そして、それが記述するコインへの参照と、コイン内の材料とそのパーセンテージを格納するコンポーネントレコードタイプ。

00:08:40.000 --> 00:08:46.000
アプリのスキーマを決定したので、CloudKitスキーマ言語でテキストファイルを作成して説明することができます。

00:08:46.000 --> 00:08:52.000
慣習は、スキーマファイルに.ckdb拡張子を使用することです。

00:08:52.000 --> 00:09:00.000
CloudKitスキーマ言語の詳細については、「テキストベースのスキーマをワークフローに統合する」のドキュメント記事を参照してください。

00:09:00.000 --> 00:09:05.000
コンテナ用に作成したスキーマファイルは、CKTool JSを使用して適用できます。

00:09:05.000 --> 00:09:12.000
新しいスキーマを適用する前に、通常、コンテナの開発スキーマを本番環境のものと一致するようにリセットします。

00:09:12.000 --> 00:09:15.000
これは、resetToProductionメソッドで行うことができます。

00:09:15.000 --> 00:09:20.000
このメソッドは、先ほど宣言したdefaultArgsオブジェクトを渡すことで呼び出します。

00:09:20.000 --> 00:09:24.000
スキーマが本番環境にない場合は、すべてのレコードタイプが削除されます。

00:09:24.000 --> 00:09:29.000
そうでなければ、これは開発スキーマを本番環境の状態に戻します。

00:09:29.000 --> 00:09:35.000
これは非同期呼び出しであるため、このメソッドはpromiseオブジェクトを返すことに注意してください。

00:09:35.000 --> 00:09:40.000
CKTool JSには、コンテナのスキーマをエクスポートおよびインポートできるメソッドがあります。

00:09:40.000 --> 00:09:46.000
exportSchemaとimportSchemaメソッドを使用すると、これを行うことができます。コンテナの観点から名前が付けられます。

00:09:46.000 --> 00:09:56.000
したがって、exportSchemaを使用してコンテナからエクスポートするスキーマをダウンロードし、importSchemaを使用してコンテナにインポートするスキーマをアップロードします。

00:09:56.000 --> 00:10:01.000
これらを組み合わせることで、スキーマの進化を管理できます。

00:10:01.000 --> 00:10:05.000
スキーマをコンテナに適用するヘルプ関数を作成できます。

00:10:05.000 --> 00:10:12.000
まず、CKTool JSからFileオブジェクトをインポートし、Node.jsからfsとpathモジュールをインポートします。

00:10:12.000 --> 00:10:19.000
次に、次のことを行う非同期関数を定義します。スキーマファイルの内容をNode.jsバッファに読み込みます。

00:10:19.000 --> 00:10:23.000
アップロード用のCKTool JSファイルインスタンスを作成します。

00:10:23.000 --> 00:10:28.000
最後に、importSchemaを使用してファイルの内容をサーバーにアップロードします。

00:10:28.000 --> 00:10:33.000
以前に宣言されたdefaultArgsオブジェクトはimportSchemaに渡されることに注意してください。

00:10:33.000 --> 00:10:35.000
今、あなたはそれをまとめることができます。

00:10:35.000 --> 00:10:42.000
resetToProductionとスキーマのインポートに使用されるヘルパー関数は非同期であるため、正しい順序で実行されていることを確認する必要があります。

00:10:42.000 --> 00:10:45.000
それをするために、あなたは約束を鎖でつなぎます。

00:10:45.000 --> 00:10:48.000
エラーが発生した場合、約束は拒否されます。

00:10:48.000 --> 00:10:55.000
CKTool JSの管理機能に加えて、データの読み書きもできます。

00:10:55.000 --> 00:11:03.000
CKTool JSレコードで使用されるフィールド値は、サーバーに送信される前にクライアント側でタイプと範囲がチェックされます。

00:11:03.000 --> 00:11:11.000
渡された値が正しい種類の値でない場合、または値の許容範囲外にある場合、例外がスローされます。

00:11:11.000 --> 00:11:18.000
JavaScriptでネイティブに表現できない大きな数の場合、代わりに使用されるCKTool JSタイプがあります。

00:11:18.000 --> 00:11:26.000
たとえば、CKTool JS Int64に数値を強制するには、toInt64関数を使用します。

00:11:26.000 --> 00:11:30.000
数値をダブル浮動小数点値に強制するには、toDouble関数を使用します。

00:11:30.000 --> 00:11:38.000
TypeScriptを書いている場合、これらの強制関数が使用されていない場合、コンパイラは誤った値型の使用法にフラグを立てます。

00:11:38.000 --> 00:11:44.000
CKTool JSレコードのフィールド値は、フィールド値ファクトリ関数を使用して作成されます。

00:11:44.000 --> 00:11:56.000
2007年に発行されたコインの場合、Int64を含むレコードフィールド値を作成するために、その値をmakeRecordFieldValue.int64ファクトリ関数に渡します。

00:11:56.000 --> 00:12:03.000
一般に、ファクトリ関数が渡された値からレコードフィールド値を作成できない場合、例外がスローされます。

00:12:03.000 --> 00:12:09.000
ここでは、レコードで動作するメソッドに送信する共通の値を保持するオブジェクトを作成しました。

00:12:09.000 --> 00:12:17.000
containerId、environment、databaseType、zoneNameがしばしば必要であるため、このdatabaseArgsオブジェクトにそれらを含めています。

00:12:17.000 --> 00:12:21.000
レコードを照会するには、queryRecordsメソッドを使用します。

00:12:21.000 --> 00:12:28.000
これを簡単にするために、ユニークな3文字のISOコードに一致する国を見つけるヘルパー関数を作成します。

00:12:28.000 --> 00:12:35.000
この場合、クエリを含む本文に加えて、databaseArgsオブジェクトの内容を渡します。

00:12:35.000 --> 00:12:42.000
クエリオブジェクトには、recordType値と単一のフィルタオブジェクトを指定しています。

00:12:42.000 --> 00:12:50.000
フィルタオブジェクトは、国のisoCode3がこの関数が求めているものと等しいクエリを記述します。

00:12:50.000 --> 00:12:56.000
成功すると、見つかったレコードのコレクションはresponse.result.recordsプロパティになります。

00:12:56.000 --> 00:12:59.000
このコレクションから最初のオブジェクトを返します。

00:12:59.000 --> 00:13:08.000
生の値をcreateRecordが使用できるフィールド値に変換するには、これを行うためにmakeCoinFieldValuesというヘルパー関数があります。

00:13:08.000 --> 00:13:16.000
フィールド値に変換したいコインの生のプロパティごとに、適切なRecordFieldValueファクトリ関数を呼び出します。

00:13:16.000 --> 00:13:20.000
ただし、国のフィールドについては、参照を作成する必要があります。

00:13:20.000 --> 00:13:27.000
渡された国別レコード名を使用して、このコインレコードから対応する国別レコードを参照します。

00:13:27.000 --> 00:13:35.000
ここでは、コインレコードフィールドの値を取り、createRecordリクエストをサーバーに送信するヘルパー関数を作成します。

00:13:35.000 --> 00:13:40.000
この関数では、以前に宣言されたdatabaseArgsの内容と本文を渡しています。

00:13:40.000 --> 00:13:43.000
ボディ辞書には、recordTypeとフィールドの値が含まれています。

00:13:43.000 --> 00:13:48.000
成功すると、response.result.recordが返されます。

00:13:48.000 --> 00:13:55.000
ヘルパー関数を呼び出す前に、このコインから参照される正しい国レコードを取得する必要があります。

00:13:55.000 --> 00:13:58.000
先ほど定義した国別クエリ関数を使用します。

00:13:58.000 --> 00:14:08.000
次に、先ほど書いたmakeCoinFieldValuesヘルパー関数で作成されたフィールド値辞書を渡して、coinCreateRecordを呼び出します。

00:14:08.000 --> 00:14:11.000
生のコインの値は、そのヘルパー関数に渡されます。

00:14:11.000 --> 00:14:17.000
これにより、非同期にレコードが作成され、新しいレコードが返されます。

00:14:17.000 --> 00:14:20.000
レコードを更新するには、updateRecordメソッドを使用します。

00:14:20.000 --> 00:14:27.000
レコード名とこのヘルパーに渡されたフィールドと一致するコインを更新するヘルパー関数を作成します。

00:14:27.000 --> 00:14:37.000
次に、databaseArgsオブジェクト、recordName、およびレコードタイプと新しいレコードのフィールド値を含むボディの内容でupdateRecordを呼び出します。

00:14:37.000 --> 00:14:45.000
成功すると、更新されたレコードはhelper関数から返すresponse.result.recordプロパティになります。

00:14:45.000 --> 00:14:52.000
先ほど作成したコインレコードを更新するには、このヘルパー関数を呼び出すと、レコード名とフィールド値を渡して更新します。

00:14:52.000 --> 00:14:57.000
フィールド値はmakeCoinFieldValuesで作成されます。

00:14:57.000 --> 00:15:02.000
レコードを削除するには、APIオブジェクトのasync deleteRecordメソッドを呼び出します。

00:15:02.000 --> 00:15:07.000
databaseArgsオブジェクトの内容と、削除するレコードのrecordNameを渡します。

00:15:07.000 --> 00:15:10.000
CKTool JSを知って楽しんでいただければ幸いです。

00:15:10.000 --> 00:15:16.000
自分で試してみてください。自動化とツーリングの目的でCKTool JSを設定してください。

00:15:16.000 --> 00:15:20.000
スキーマをリセットしてインポートし、JavaScriptを使用してデータを読み書きします。

00:15:20.000 --> 00:15:27.000
継続的インテグレーションシナリオでのCKTool JSの使用については、GitHubのCloudKitサンプルリポジトリをチェックしてください。

00:15:27.000 --> 00:15:32.000
また、より詳細なドキュメントについては、developer.apple.comのCKTool JSをご覧ください。

00:15:32.000 --> 23:59:59.000
今日は参加してくれてありがとう、そしてWWDC22の残りの部分を楽しんでください。

