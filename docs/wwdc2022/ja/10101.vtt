WEBVTT

00:00:00.000 -> 00:00:09.000
♪インストゥルメンタルヒップホップ音楽♪

00:00:09.000 -> 00:00:10.000
こんにちは、ようこそ。

00:00:10.000 -> 00:00:15.000
私の名前はAppleのGPUソフトウェアチームのAlè Segovia Azapianです。

00:00:15.000 -> 00:00:18.000
そして、私もGPUソフトウェアチームのMayurです。

00:00:18.000 -> 00:00:21.000
Alè：このセッションでは、バインドレスレンダリングについて話します。

00:00:21.000 -> 00:00:29.000
バインドレスバインディングモデルは、シェーダーにリソースを提供する最新の方法であり、レイトレーシングなどの高度なレンダリング技術のロックを解除します。

00:00:29.000 -> 00:00:40.000
今日は、バインドレスバインディングモデルがどのように機能するか、そしてMetal 3でゲームやアプリにバインドレスを簡単に採用する方法の簡単な要約から始めます。

00:00:40.000 -> 00:00:47.000
バインドレスレンダリングはデータを集約し、CPUとGPUのパフォーマンスを向上させる新たな機会を開きます。

00:00:47.000 -> 00:00:53.000
今日は、CPUとGPUの時間を改善するための2つの具体的なヒントを紹介します。

00:00:53.000 -> 00:00:59.000
その後、私はそれをMayurに渡し、彼はツールがバインドレスモデルを採用するのにどのように役立つかをあなたに示します。

00:00:59.000 -> 00:01:05.000
バインドレスモデルでは、リソースは集約され、引数バッファと一緒にリンクされます。

00:01:05.000 -> 00:01:07.000
概念的には、これがこのように見えます。

00:01:07.000 -> 00:01:12.000
この例では、配列はシーン内のすべてのメッシュを集約します。

00:01:12.000 -> 00:01:22.000
各リソースをパイプライン内の特定のスロットに独立してバインドする従来のバインディングモデルとは異なり、バインドレスモデルでは、リソースは最初にメモリ内でリンクされます。

00:01:22.000 -> 00:01:32.000
これにより、シェーダーが自由にナビゲートし、精巧な表面と照明を計算するために必要なリソースにアクセスできる単一のバッファをバインドできます。

00:01:32.000 -> 00:01:39.000
アプリがバインドレスになった後、レイトレーシングシェーダーは反射を美しくシェーディングするために必要なすべてのデータにアクセスできます。

00:01:39.000 -> 00:01:52.000
このアプリは、すべてのデータを引数バッファに配置することで、床、トラック、その材料、さらには空を含む3Dモデルとテクスチャをレイトレーシングシェーダーが利用できるようにします。

00:01:52.000 -> 00:02:02.000
さらに良いことに、バインドレスレンダリングがヒープなどの他のメタル機能とペアになっている場合、CPUへの圧力が少ないため、アプリやゲームはより良いパフォーマンスを享受します。

00:02:02.000 -> 00:02:09.000
メタル3の4つの特定の機能強化について、バインドレスレンダリングに役立つかもしれません。

00:02:09.000 -> 00:02:15.000
引数バッファは、リソースをリンクできる基本的なメタル構造です。

00:02:15.000 -> 00:02:20.000
テクスチャやその他のバッファなどのリソースを参照します。

00:02:20.000 -> 00:02:28.000
Metal 3は、引数エンコーダオブジェクトが不要になったため、引数バッファの書き込みをこれまで以上に簡単にします。

00:02:28.000 -> 00:02:31.000
そして、同じことが無制限の配列にも当てはまります。

00:02:31.000 -> 00:02:42.000
メタルヒープから加速構造を割り当てることができ、リソースがGPUメモリに常駐していないときにシェーダーバリデーションレイヤーが警告します。

00:02:42.000 -> 00:02:48.000
これら4つの機能を組み合わせることで、これまで以上に簡単にバインドレスになります。

00:02:48.000 -> 00:02:54.000
特に、Metal 3で引数バッファを書くことは喜びです。

00:02:54.000 -> 00:03:03.000
シーンを引数バッファにエンコードするには、インスタンス、メッシュ、マテリアル、テクスチャなどのシーンデータをこれらのバッファに書き込みます。

00:03:03.000 -> 00:03:07.000
Metal 2では、これは引数エンコーダで達成されます。

00:03:07.000 -> 00:03:14.000
まず、これらのオブジェクトがどのように機能するかを要約してから、Metal 3がコードを簡素化する方法を紹介します。

00:03:14.000 -> 00:03:19.000
引数エンコーダでは、最初のステップはエンコーダインスタンスを作成することです。

00:03:19.000 -> 00:03:25.000
シェーダー関数の反射を介して、または構造体メンバーをMetalに記述することによってこれを行います。

00:03:25.000 -> 00:03:32.000
エンコーダインスタンスで、その記録先とオフセットをターゲット引数バッファに設定します。

00:03:32.000 -> 00:03:36.000
そして、そのメソッドを使用してバッファにデータを書き込みます。

00:03:36.000 -> 00:03:42.000
引数バッファと引数エンコーダに関する詳細な復習については、昨年のバインドレスセッションをチェックしてください。

00:03:42.000 -> 00:03:48.000
今、このメカニズムは素晴らしいですが、エンコーダオブジェクトは時々管理が難しい場合があります。

00:03:48.000 -> 00:03:51.000
メタルは、引数エンコーダを作成するための2つのメカニズムを提供します。

00:03:51.000 -> 00:03:55.000
どちらがあなたのアプリに適しているかは明らかではないかもしれません。

00:03:55.000 -> 00:04:00.000
さらに、複数のスレッドから引数エンコーダを使用するには注意が必要です。

00:04:00.000 -> 00:04:09.000
開発者は、C構造体を書く方法を直感的に理解し、Metal 3を使用すると、引数バッファに対してそれを行うことができます。

00:04:09.000 -> 00:04:16.000
Metal 3は、他のCPU側構造のように直接書き込むことで、引数バッファの書き込みを簡素化します。

00:04:16.000 -> 00:04:23.000
これで、リソースの仮想GPUアドレスとリソースIDにアクセスできます。

00:04:23.000 -> 00:04:29.000
これらを引数バッファに直接書き込むと、Metalは参照しているリソースを理解できるようになりました。

00:04:29.000 -> 00:04:37.000
エンコーダが不要になったことを除いて、以前は引数エンコーダを使用して参照をエンコードするのと機能的に同じです。

00:04:37.000 -> 00:04:41.000
この機能は、引数バッファティア2をサポートするすべてのデバイスでサポートされています。

00:04:41.000 -> 00:04:51.000
つまり、2016年以降のMacと、A13バイオニックチップ以降を搭載したiOSデバイスです。

00:04:51.000 -> 00:05:00.000
デバイスが引数バッファティア2をサポートしているかどうかわからない場合は、使用できるMTLDeviceオブジェクトに便利な機能クエリがあります。

00:05:00.000 -> 00:05:03.000
これが今、Metal 3のプロセスがどのように見えるかです。

00:05:03.000 -> 00:05:13.000
まず、バッファアドレスには64ビット型、テクスチャにはMTLResourceIDを使用して、CPU可視構造体を定義します。

00:05:13.000 -> 00:05:16.000
次に、引数バッファを割り当てます。

00:05:16.000 -> 00:05:23.000
MTLDeviceから直接、またはMTLHeapからバッファを割り当てます。

00:05:23.000 -> 00:05:29.000
バッファの内容を取得し、それを引数バッファ構造体型にキャストします。

00:05:29.000 -> 00:05:34.000
そして最後に、アドレスとリソースIDを構造体メンバーに書き込みます。

00:05:34.000 -> 00:05:37.000
ハイブリッドレンダリングのデモでこれがどのように行われるかを見てみましょう。

00:05:37.000 -> 00:05:41.000
これがコードです。それがどれほど簡単かに注目してください。

00:05:41.000 -> 00:05:46.000
ホスト側の構造体は、法線バッファのGPUアドレスを直接保存します。

00:05:46.000 -> 00:05:52.000
これは64ビットの符号なし整数なので、uint64_tを使いました。

00:05:52.000 -> 00:05:59.000
エンコーダオブジェクトがないので、引数バッファに構造体のサイズを使用するだけです。

00:05:59.000 -> 00:06:08.000
Metalは、GPUとCPU構造体のサイズとアライメントがclangとMetalシェーダーコンパイラ間で一致することを保証します。

00:06:08.000 -> 00:06:13.000
次に、通常どおりバッファを割り当てます。

00:06:13.000 -> 00:06:21.000
また、バッファのストレージモードが管理または共有されている場合は、バッファへの直接ポインタを取得し、それを構造体タイプにキャストします。

00:06:21.000 -> 00:06:32.000
そして最後に、ノーマルメンバーをgpuAddressに設定し、オプションで、GPUのメモリ要件に合わせる必要があるオフセットを設定します。

00:06:32.000 -> 00:06:39.000
私が強調したいことの1つは、金属シェーディング言語とC宣言の間で構造宣言がどのように変化するかです。

00:06:39.000 -> 00:06:53.000
この例では、これらは別々に保持されますが、必要に応じて、共有ヘッダーに単一の構造体宣言を持ち、条件付きコンパイルを使用してシェーダーコンパイラ型とC型を区別できます。

00:06:53.000 -> 00:06:56.000
これはCの統一宣言です。

00:06:56.000 -> 00:07:00.000
__METAL_VERSION__マクロは、シェーダーコードをコンパイルするときにのみ定義されます。

00:07:00.000 -> 00:07:05.000
ヘッダー宣言でGPUとCPUコードを分離するために使用します。

00:07:05.000 -> 00:07:13.000
アプリがC++をターゲットにしている場合は、これをさらに進め、テンプレートを使用して宣言をさらに均一にすることができます。

00:07:13.000 -> 00:07:18.000
ベストプラクティスについては、引数バッファのサンプルコードを確認してください。

00:07:18.000 -> 00:07:24.000
これで1つの構造体を書く方法ですが、無制限の配列を使用して多くの構造体を書くこともできます。

00:07:24.000 -> 00:07:36.000
引数エンコーダを使用してMetalに無制限の配列を実装することはできますが、Metal 3は、構造体の配列を埋めることに近づくことで、プロセスをさらに簡素化します。

00:07:36.000 -> 00:07:40.000
1つの構造体を書くこととの違いは次のとおりです。

00:07:40.000 -> 00:07:46.000
これで、保存するすべての構造体に十分なストレージを割り当てる必要があります。

00:07:46.000 -> 00:07:53.000
そして、配列を反復し、各構造体のデータを書き込む。

00:07:53.000 -> 00:08:01.000
コードサンプルに戻り、まず、バッファのサイズを展開して、シーン内のメッシュと同じくらい多くの構造体を保存します。

00:08:01.000 -> 00:08:10.000
これがCPUバッファとまったく同じであることに注目してください。構造体のサイズにメッシュ数を掛けます。

00:08:10.000 -> 00:08:13.000
これがどれほど強力であるかに注目したいと思います。

00:08:13.000 -> 00:08:17.000
この単一の変数は、配列のサイズを完全に制御します。

00:08:17.000 -> 00:08:24.000
シェーダーは、任意の時点でこのサイズをメタルシェーダーコンパイラに宣言する必要がなく、任意の位置に自由にインデックスを付けることができます。

00:08:24.000 -> 00:08:32.000
これは、制約なしで任意のサイズの配列にアクセスするシェーダーを書くため、バインドレスモデルがMetalで非常に柔軟である理由の一部です。

00:08:32.000 -> 00:08:36.000
それはちょうど動作します!

00:08:36.000 -> 00:08:46.000
次に、このサイズのバッファを割り当て、正しいメッシュ構造体タイプにコンテンツへのポインタをキャストします。

00:08:46.000 -> 00:08:55.000
バッファが十分に大きくなったので、メッシュ構造体のサイズにまたがって、シンプルなforループで歩きます。

00:08:55.000 -> 00:09:04.000
そして最後に、配列内の各構造体のGPUAddressを直接設定し、オプションで整列されたオフセットを設定します。

00:09:04.000 -> 00:09:09.000
シェーダーのGPU側から、これは無制限の配列を表す1つの方法です。

00:09:09.000 -> 00:09:16.000
ここでは、シェーダーに渡すメッシュポインタパラメータとして宣言します。

00:09:16.000 -> 00:09:25.000
これにより、C配列と同様に、コンテンツに直接自由にアクセスできるようになります。

00:09:25.000 -> 00:09:30.000
もう1つのオプションは、すべての無制限の配列を構造体に引き込むことです。

00:09:30.000 -> 00:09:35.000
これは、データを1か所に集約することで、シェーダーをきれいに保つのに役立ちます。

00:09:35.000 -> 00:09:42.000
この例では、すべてのメッシュとマテリアルがシーン構造体でまとめられています。

00:09:42.000 -> 00:09:52.000
シーン構造体を使用すると、シーンは、すべての無制限の配列を別々に渡すのではなく、単一のバッファをバインドすることによってシェーダーに直接渡されます。

00:09:52.000 -> 00:09:59.000
そして、アクセスは以前と似ていますが、今、メッシュ配列はシーン構造体を介して到達されます。

00:09:59.000 -> 00:10:04.000
そして、それがMetal 3で引数バッファと無制限配列を書く方法です。

00:10:04.000 -> 00:10:12.000
完全に刷新されたAPIにより、より直感的になり、CPU構造体や構造体の配列に対して行うことと一致します。

00:10:12.000 -> 00:10:21.000
今年のレイトレーシングアップデートでは、バッファーやテクスチャとともに、メタルヒープからレイトレーシングアクセラレーション構造を割り当てることができます。

00:10:21.000 -> 00:10:26.000
これは、それらが自分自身の間で、そして他のリソースタイプと一緒に集約できることを意味します。

00:10:26.000 -> 00:10:35.000
これは素晴らしいことです。なぜなら、すべての加速構造をヒープに集約すると、Heapを使用するための単一の呼び出しですべての常駐フラグを付けることができるからです。

00:10:35.000 -> 00:10:42.000
これは、アプリケーションのレンダリングスレッドでCPUを大幅に節約するための大きな機会です。

00:10:42.000 -> 00:10:46.000
ここでは、ヒープで加速構造を操作するためのヒントをいくつか紹介します。

00:10:46.000 -> 00:10:53.000
まず、ヒープから割り当てられると、加速度構造には、デバイスごとに異なるアライメントとサイズの要件があります。

00:10:53.000 -> 00:11:00.000
ヒープ割り当てのアクセラレーション構造のサイズとアライメントをチェックする新しいクエリがあります。

00:11:00.000 -> 00:11:09.000
MTLDeviceのheapAccelerationStructureSizeとAlignWithDescriptorメソッドを使用して、構造記述子のSizeAndAlignmentを決定します。

00:11:09.000 -> 00:11:18.000
これは、MTLDeviceの accelerationStructureSizes WithDescriptorメソッドとは異なることを覚えておいてください。

00:11:18.000 -> 00:11:25.000
加速度構造がMTLHeapオブジェクトにあるので、useHeapを呼び出し、それらをすべて1回の呼び出しに常駐させます。

00:11:25.000 -> 00:11:31.000
これは、個々のリソースでuseResourceを呼び出すよりも高速です。

00:11:31.000 -> 00:11:44.000
そして、ハザードトラッキングにヒープを選択しない限り、Metalはそれらから割り当てられたリソースの競合条件を妨げないため、互いに構築される加速構造を同期し、レイトレーシング作業と同期する必要があることを覚えておいてください。

00:11:44.000 -> 00:11:48.000
しかし、心配しないでください、私はすぐにこれについてもっと話します。

00:11:48.000 -> 00:11:58.000
メタル3のこれと他のレイトレーシングパフォーマンスの進歩の詳細については、今年の「メタルレイトレーシングパフォーマンスを最大化する」トークをチェックしてください。

00:11:58.000 -> 00:12:06.000
ヒープに割り当てられたアクセラレーション構造を使用すると、最も重要なときにアプリのCPU使用率を減らす機会が得られます。

00:12:06.000 -> 00:12:13.000
最後になりましたが、今年の私のお気に入りの機能の1つは、シェーダー検証の強化です。

00:12:13.000 -> 00:12:22.000
useResourceとuseHeapのトピックでは、アプリが間接的にアクセスされたすべてのリソースに対してMetalにレジデンシーにフラグを付けることが非常に重要です。

00:12:22.000 -> 00:12:28.000
それを忘れることは、これらのリソースをバックアップするメモリページがレンダリング時に存在しない可能性があることを意味します。

00:12:28.000 -> 00:12:34.000
これは、コマンドバッファの失敗、GPUの再起動、さらには画像の破損を引き起こす可能性があります。

00:12:34.000 -> 00:12:48.000
残念ながら、バインドレスジャーニーを開始するときにこれらの問題に遭遇することは非常に一般的です。なぜなら、バインドレスでは、シーンリソースの大部分が間接的にアクセスされ、シェーダーが実行時にポインタナビゲーションの決定を行うからです。

00:12:48.000 -> 00:12:58.000
今年、Metal 3は、コマンドバッファの実行中にリソースの欠落しているレジデンシーを追跡するのに役立つシェーダー検証レイヤーに新機能を導入しました。

00:12:58.000 -> 00:13:01.000
具体的な例をお見せします。

00:13:01.000 -> 00:13:09.000
ハイブリッドレンダリングアプリの更新プロセス中に、反射が時々正しくないように見える本当の問題に遭遇しました。

00:13:09.000 -> 00:13:15.000
検証層がこの問題の診断と修正にどのように役立ったかをお見せします。

00:13:15.000 -> 00:13:24.000
レジデンシーをMetalにフラグを付けるために、アプリはヒープによってバックアップされていないすべての個々のリソースをロード時に適用可能なセットに保存します。

00:13:24.000 -> 00:13:28.000
アプリはバッファを追加し、テクスチャを追加します。

00:13:28.000 -> 00:13:37.000
レンダリング時に、アプリがレイトレーシングカーネルをディスパッチする前に、セット内のすべてのリソースを使用することをMetalに示します。

00:13:37.000 -> 00:13:43.000
これは、アプリがセットを反復し、各要素でuseResourceを呼び出す簡単なプロセスです。

00:13:43.000 -> 00:13:49.000
金属は、レイトレーシング作業を開始する前に、これらすべてのリソースを常駐させます。

00:13:49.000 -> 00:13:53.000
これは、アプリがこのセットにリソースを収集するコードの一部です。

00:13:53.000 -> 00:13:58.000
アプリは、引数バッファ書き込みプロセスの一部としてこれを行います。

00:13:58.000 -> 00:14:03.000
アプリの読み込み機能は、各サブメッシュを反復します。

00:14:03.000 -> 00:14:16.000
引数バッファに書き込む必要があるデータ、つまりマテリアルのインデックスデータとテクスチャデータを取り込み、インデックスバッファのアドレスを引数バッファに格納します。

00:14:16.000 -> 00:14:24.000
マテリアルの場合、テクスチャ配列をループし、テクスチャGPUリソースIDを引数バッファに書き込みます。

00:14:24.000 -> 00:14:35.000
そして最後に、サブメッシュ素材からすべての個々のテクスチャをsceneResourcesセットに追加するので、ディスパッチ時に居住者にフラグを立てることができます。

00:14:35.000 -> 00:14:39.000
残念ながら、ここには微妙なバグがあります。

00:14:39.000 -> 00:14:45.000
アプリはコマンドバッファを実行し、場合によっては反射が欠落します。

00:14:45.000 -> 00:14:49.000
以前は、これを追跡することは困難でした。

00:14:49.000 -> 00:14:53.000
メタル3では、シェーダー検証レイヤーが救助に来ます。

00:14:53.000 -> 00:15:01.000
この種の問題は、コマンドバッファの実行中にエラーが発生し、問題が何であるかを示すようになりました。

00:15:01.000 -> 00:15:20.000
エラーメッセージは、問題を引き起こしたシェーダー関数の名前、パスの名前、アクセスを検出した金属ファイルとコード行、さらにはバッファのラベル、そのサイズ、およびそれが常駐していないという事実を示します。

00:15:20.000 -> 00:15:24.000
プロのヒントとして、これは金属オブジェクトにラベルを付けることが常に良い習慣である理由です。

00:15:24.000 -> 00:15:30.000
このツールはラベルを使用します。これは、アプリのデバッグ中にどのオブジェクトがどのオブジェクトであるかを特定しようとするときに役立ちます。

00:15:30.000 -> 00:15:36.000
このすべての詳細情報が手元にあるので、シェーダーコードで不足しているリソースを簡単に見つけることができます。

00:15:36.000 -> 00:15:47.000
さらに良いのは、デバッグブレークポイントが有効になっている場合、Xcodeはシェーダー検証が問題を検出するシェーダーコードの正確な行を便利に表示することです。

00:15:47.000 -> 00:15:51.000
デモアプリの場合、常駐していないのはインデックスバッファです。

00:15:51.000 -> 00:15:55.000
修正は今や簡単です。

00:15:55.000 -> 00:16:02.000
コードに戻ると、アプリは不足しているインデックスバッファを常駐リソースセットに保存するようになりました。

00:16:02.000 -> 00:16:10.000
これらの変更により、後でレイトレーシング時に、MetalはインデックスバッファをGPUが利用できるようにし、問題を解決することを知っています。

00:16:10.000 -> 00:16:19.000
これは不可欠なツールであり、完全なゲームチェンジャーであり、バインドレスの旅で何時間ものデバッグ時間を節約できる可能性があります。

00:16:19.000 -> 00:16:24.000
したがって、これらは、メタル3がもたらす機能強化であり、バインドレスリソースを整理して参照するのに役立ちます。

00:16:24.000 -> 00:16:30.000
今、私はギアを切り替えて、バインドレスになったときにゲームのパフォーマンスを最大化する方法について話します。

00:16:30.000 -> 00:16:36.000
このセクションでは、保持されていないリソースと追跡されていないリソースの2つのトピックを取り上げます。

00:16:36.000 -> 00:16:44.000
これらのヒントは、長寿命で集約されたリソースがある場合に、CPUとGPUの両方からより多くのパフォーマンスを引き出すのに役立ちます。

00:16:44.000 -> 00:16:51.000
さて、長寿命のリソースでCPUのパフォーマンスを向上させる方法については、まずメタルリソースのライフサイクルを要約します。

00:16:51.000 -> 00:16:56.000
Objective-CとSwiftは、参照カウントを介してオブジェクトのライフサイクルを処理します。

00:16:56.000 -> 00:16:59.000
金属資源はこのモデルに従います。

00:16:59.000 -> 00:17:07.000
リソースは1のretainCountで始まり、すべての強力な参照が消えたときにランタイムはそれらを割り当て解除します。

00:17:07.000 -> 00:17:19.000
CPUとGPUは並行して動作するため、GPUがまだ使用している間にRetainCountが0に達するようにすることで、CPUがリソースの割り当てを解除した場合、問題になります。

00:17:19.000 -> 00:17:30.000
これを防ぐために、Metalコマンドバッファは、使用するすべてのリソースへの強力な参照を作成し、retainCountが常に少なくとも1であることを確認します。

00:17:30.000 -> 00:17:55.000
Metalは、setVertexBufferやsetFragmentTextureなどの関数を使用してパイプラインに直接バインドするリソースの強力な参照を作成します。これには、レンダリングアタッチメントも含まれます。useHeap APIを介して常駐フラグを付けるMetalヒープオブジェクト、およびheapの一部である場合でも、useResource APIを介して常駐する間接リソース。

00:17:55.000 -> 00:18:03.000
Metalオブジェクトのライフサイクルの詳細については、今年の「Program Metal in C++ with metal-cpp」の講演をご覧ください。

00:18:03.000 -> 00:18:13.000
今、Metalがこれらの参照を作成することは非常に便利です。なぜなら、プログラマーとして、GPUがまだ使用している間にオブジェクトの割り当てを解除する可能性があることを心配する必要がないからです。

00:18:13.000 -> 00:18:20.000
メタルが提供するこの安全保証は、実行が非常に高速ですが、小さなCPUコストが付属しています。

00:18:20.000 -> 00:18:28.000
現在、バインドレスモデルでは、アプリはリソースをヒープに集約し、これらはアプリケーションのドメインと一致して長生きする傾向があります。

00:18:28.000 -> 00:18:34.000
たとえば、ゲームでは、リソースはレベル全体の期間にわたって生きています。

00:18:34.000 -> 00:18:41.000
この場合、Metalがリソースのライフサイクルに関する追加の保証を提供する必要がなくなります。

00:18:41.000 -> 00:18:50.000
次にできることは、Metalコマンドバッファを参照するリソースを保持しないように依頼することで、このCPUコストを回収することです。

00:18:50.000 -> 00:18:57.000
Metalの自動リソース保持をオフにするには、保持されていない参照を含むコマンドバッファを作成するだけです。

00:18:57.000 -> 00:19:03.000
通常のコマンドバッファを作成するのと同じように、MTLCommandQueueから直接これを行います。

00:19:03.000 -> 00:19:09.000
リソースのライフサイクルをすでに保証している限り、アプリに他の変更を加える必要はありません。

00:19:09.000 -> 00:19:14.000
この設定の粒度レベルは、コマンドバッファ全体であることを覚えておいてください。

00:19:14.000 -> 00:19:19.000
参照されたすべてのリソースを保持するか、どれも保持しません。

00:19:19.000 -> 00:19:29.000
小さなマイクロベンチマークでは、保持されていない参照を持つコマンドバッファに切り替えるだけで、コマンドバッファのライフサイクルにおける2%のCPU使用率の減少を測定しました。

00:19:29.000 -> 00:19:37.000
しかし、この時間は不必要な強力な参照の作成と破壊に完全に費やされました。

00:19:37.000 -> 00:19:46.000
要約すると、保持されていないリソースは、すでにリソースのライフサイクルを保証している場合に、追加のCPU節約の機会を提供します。

00:19:46.000 -> 00:19:55.000
保持されていないリソースと同様に、追跡されていないリソースは、より多くのパフォーマンスを得るために安全機能を無効にする機会を提供します。

00:19:55.000 -> 00:20:02.000
多くの視覚的なテクニックは、中間テクスチャにレンダリングし、バッファに書き込み、後でそれらを消費することで構成されています。

00:20:02.000 -> 00:20:07.000
シャドウマッピング、スキニング、後処理は、この良い例です。

00:20:07.000 -> 00:20:15.000
現在、リソースの生産と即時消費は、読み取り/書き込みの危険性をもたらします。

00:20:15.000 -> 00:20:33.000
さらに、2つのレンダーパスが同じアタッチメントに次々と描画したり、2つのブリットエンコーダが同じリソースに書き込んだりするなど、複数のパスが同じリソースに書き込むと、MetalスケジュールがGPUで機能するため、書き込み後の危険が生じます。

00:20:33.000 -> 00:20:41.000
追跡されたリソースを使用すると、Metalは自動的に同期プリミティブを使用してGPUタイムラインの危険を回避します。

00:20:41.000 -> 00:20:51.000
たとえば、MetalはGPUに、同じバッファから読み込むシーンレンダリングパスを開始する前に、コンピューティングスキニングパスがバッファへの書き込みを完了するのを待ちます。

00:20:51.000 -> 00:21:03.000
これは素晴らしいことであり、Metalがこのような親しみやすいグラフィックスAPIである理由の大きな部分ですが、リソースをヒープに集約するアプリにはいくつかのパフォーマンス上の考慮事項があります。

00:21:03.000 -> 00:21:05.000
この例を考えてみましょう。

00:21:05.000 -> 00:21:13.000
ここでは、GPUはビジーで、頂点スキニングを行い、シーンをレンダリングし、トーンマッピングを適用する2つのフレームを次々に描画します。

00:21:13.000 -> 00:21:22.000
アプリはGPUを忙しく保つため、Metalはリソースの依存関係に基づいて、レンダリングと計算作業が重複する可能性のある機会を特定します。

00:21:22.000 -> 00:21:29.000
依存関係がなく、条件が正しい場合、金属スケジュールは重複して並行して実行されます。

00:21:29.000 -> 00:21:38.000
これはGPUを飽和させ、同じ量のウォールクロック時間でより多くの作業を行うことができます。

00:21:38.000 -> 00:21:45.000
これで、アプリがリソースをヒープに集約すると、すべてのサブリソースがMetalに1つ表示されます。

00:21:45.000 -> 00:21:48.000
これは、ヒープを非常に効率的に作業する理由です。

00:21:48.000 -> 00:22:02.000
しかし、これは、Metalが同じリソースで読み取りと書き込みの作業を見て、実際の危険が存在しない場合でも、レース条件を避けるために作業を保守的にスケジュールしなければならないことを意味します。

00:22:02.000 -> 00:22:10.000
この状況は「偽の共有」と呼ばれ、予想通り、GPU作業の実行ウォールクロック時間が長くなります。

00:22:10.000 -> 00:22:12.000
だから、これがパフォーマンスのヒントです。

00:22:12.000 -> 00:22:18.000
ヒープ内のリソース間に依存関係がないことを知っている場合は、この動作を避けることができます。

00:22:18.000 -> 00:22:27.000
誤った共有を避けるために、ハザードトラッキングからリソースをオプトアウトし、金属へのきめ細かい依存関係を直接通知することができます。

00:22:27.000 -> 00:22:34.000
リソース記述子の hazardTracking プロパティを Untracked に設定することで、リソース追跡をオプトアウトします。

00:22:34.000 -> 00:22:43.000
これは非常に重要であるため、GPUがゲートのすぐ外で並行して作業を実行するためのより多くの機会のロックを解除できるため、ヒープのデフォルトの動作です。

00:22:43.000 -> 00:22:49.000
追跡されていないリソースの使用を開始すると、次のプリミティブを使用して依存関係を表現します。

00:22:49.000 -> 00:22:58.000
状況に応じて、フェンス、イベント、共有イベント、またはメモリバリアを使用します。

00:22:58.000 -> 00:23:07.000
メタルフェンスは、単一のコマンドキューのコンテキスト内で、異なるレンダリングとコンピューティングパスにまたがる1つ以上のリソースへのアクセスを同期します。

00:23:07.000 -> 00:23:18.000
これはスプリットバリアのような原始的であるため、消費者パスは生産者がフェンスに信号を送るまで待ちます。

00:23:18.000 -> 00:23:29.000
Fencesを使用する際に留意する必要がある唯一の要件は、コマンドバッファを消費する前に、プロデューサーコマンドバッファをコミットまたはキューに入れることです。

00:23:29.000 -> 00:23:37.000
この注文を保証できない場合、または同じデバイス上の複数のキュー間で同期する必要がある場合は、MTLイベントを使用してください。

00:23:37.000 -> 00:23:45.000
イベントを使用して、コンシューマコマンドバッファは、プロデューサーコマンドバッファが指定された値でイベントにシグナルを送るのを待ちます。

00:23:45.000 -> 00:23:48.000
値を通知した後は、リソースを読み取るのが安全です。

00:23:48.000 -> 00:23:54.000
イベントを使用して、コマンドがイベントに信号を送るまで作業を一時停止するようにGPUに指示します。

00:23:54.000 -> 00:24:02.000
MTLSharedEventsは、通常のイベントと非常によく似ていますが、単一のGPUを超えたより大きなスコープで動作します。

00:24:02.000 -> 00:24:08.000
これらを使用して、さまざまなMetalデバイス、さらにはCPUとのリソースへのアクセスを同期します。

00:24:08.000 -> 00:24:14.000
たとえば、共有イベントを使用して、CPUからGPU計算の結果を処理します。

00:24:14.000 -> 00:24:16.000
ここに例があります。

00:24:16.000 -> 00:24:23.000
この場合、GPUはコンピューティングパスでメッシュをスキンし、CPUはポーズをディスクに保存します。

00:24:23.000 -> 00:24:31.000
これら2つは独立したデバイスであるため、共有イベントを使用して、GPUがリソースを生成するまでCPUを待機させます。

00:24:31.000 -> 00:24:38.000
最初は、CPUはGPUが共有イベントに信号を送るのを無条件に待ち始めます。

00:24:38.000 -> 00:24:44.000
GPUがリソースを生成してユニファイドメモリに配置すると、共有イベントに信号を送ります。

00:24:44.000 -> 00:24:52.000
この時点で、CPUの待機スレッドが起動し、リソースを安全に消費します。

00:24:52.000 -> 00:24:55.000
最後のプリミティブタイプはメモリバリアです。

00:24:55.000 -> 00:25:02.000
メモリバリアは、単一のレンダリングまたは計算パス内の後続のすべてのコマンドを強制して、以前のすべてのコマンドが終了するまで待機させます。

00:25:02.000 -> 00:25:08.000
バリアのコストは、ほとんどすべてのケースでフェンスのコストに似ています。

00:25:08.000 -> 00:25:14.000
しかし、1つの例外があります。

00:25:14.000 -> 00:25:19.000
その例外は、レンダリングパスのフラグメントステージの後の障壁です。

00:25:19.000 -> 00:25:24.000
これらの障壁は、レンダリングパスを分割するのと同様の非常に高いコストがかかります。

00:25:24.000 -> 00:25:32.000
Metalは、Apple GPUのフラグメントステージの後に障壁を無効にし、アプリが最速のドライバーパスにとどまるのに役立ちます。

00:25:32.000 -> 00:25:39.000
Metalデバッグレイヤーは、Apple GPUにフラグメント後のバリアを追加すると、検証エラーも発生します。

00:25:39.000 -> 00:25:46.000
フラグメントステージの後にリソースを同期するためにフェンスを使用することをお勧めします。

00:25:46.000 -> 00:25:51.000
同期プリミティブの簡単な要約と、いつ使用するかを次に示します。

00:25:51.000 -> 00:25:59.000
プロデューサーの単一のコマンドキューに作業をコミットまたはキューに入れるときに、最も低いオーバーヘッドにフェンスを使用することを好み、次に消費者の注文。

00:25:59.000 -> 00:26:04.000
フェンスは、一般的なケースの大半に最適です。

00:26:04.000 -> 00:26:11.000
提出注文を保証できない場合、または複数のコマンドキューがある場合は、Metal Eventsを使用してください。

00:26:11.000 -> 00:26:16.000
共有イベントは、自分自身とCPUとの間で複数のGPUを同期させることができます。

00:26:16.000 -> 00:26:20.000
これらの特定のマルチデバイスのケースでのみ使用してください。

00:26:20.000 -> 00:26:25.000
パス内で同期したい場合は、メモリバリアを使用してください。 メモリバリア

00:26:25.000 -> 00:26:32.000
バリアは、ほとんどの場合、同時計算パスやドローコール間の頂点ステージなど、高速プリミティブです。

00:26:32.000 -> 00:26:44.000
しかし、フレンドリーなリマインダーは、これらの障壁は非常に高価であり、Apple GPUはそれを許可していないため、フラグメントステージの後に同期するためのバリアの代わりにパスの間にフェンスを使用してください。

00:26:44.000 -> 00:26:55.000
追跡されていないリソースと手動のきめ細かい追跡を使用して、GPUの並列性を最大化しながら、データ集約のすべての利点を持つことができます。

00:26:55.000 -> 00:27:02.000
そして、これらはバインドレスになるときにCPUとGPUを最大限に活用するためのパフォーマンスのヒントです。

00:27:02.000 -> 00:27:07.000
Metal 3がシンプルで効率的なバインドレスワークフローのロックを解除する方法についてたくさん話しました。

00:27:07.000 -> 00:27:09.000
しかし、コードを書くことは方程式の半分にすぎません。

00:27:09.000 -> 00:27:15.000
残りの半分は、利用可能なツールがGPUがどのように動作を見て実行するかを確認するのにどのように役立つかです。

00:27:15.000 -> 00:27:19.000
私は今、それをMayurに引き渡して、バインドレス用のMetal 3ツーリングの新機能について話します。

00:27:19.000 -> 00:27:22.000
マユール：ありがとう、アレ。

00:27:22.000 -> 00:27:31.000
今日は、バインドレスアプリのデバッグと最適化に役立つMetal Debuggerの素晴らしい新機能のいくつかをお見せできることを嬉しく思います。

00:27:31.000 -> 00:27:37.000
Alèがあなたに見せたHybridRenderingアプリのフレームキャプチャを撮ったところです。

00:27:37.000 -> 00:27:50.000
メタルデバッガでフレームをキャプチャすると、概要ページが表示され、アプリのパフォーマンスを向上させる方法に関する有用な洞察とともに、フレームの概要が表示されます。

00:27:50.000 -> 00:27:54.000
しかし、今日、私はあなたに新しい依存関係ビューアを見せることに興奮しています。

00:27:54.000 -> 00:28:00.000
それを開くには、左側の依存関係をクリックしてください。

00:28:00.000 -> 00:28:08.000
ここに新しい依存関係ビューアがあり、強力な新機能が満載の真新しいデザインが特徴です。

00:28:08.000 -> 00:28:14.000
依存関係ビューアは、ワークロードのグラフベースの表現を表示します。

00:28:14.000 -> 00:28:25.000
グラフの各ノードは、コマンドエンコーダによってエンコードされたパスとその出力リソースを表します。

00:28:25.000 -> 00:28:31.000
エッジは、パス間のリソース依存関係を表します。

00:28:31.000 -> 00:28:37.000
今年の新機能では、2種類の依存関係に焦点を当てることで、ワークロードを分析できます。

00:28:37.000 -> 00:28:40.000
データフローと同期。

00:28:40.000 -> 00:28:47.000
実線はデータフローを表し、アプリでデータがどのように流れるかを示します。

00:28:47.000 -> 00:28:57.000
点線は同期を表し、パス間のGPU同期を導入する依存関係を示します。

00:28:57.000 -> 00:29:09.000
詳細については、任意のエンコーダ、リソース、またはエッジをクリックすると、デバッガは新しいサイドバーに多くの詳細情報が表示されます。

00:29:09.000 -> 00:29:17.000
たとえば、このエッジは同期を追加し、これらのパス間のデータフローもあります。

00:29:17.000 -> 00:29:31.000
デフォルトでは、依存関係ビューアはデータフローと同期依存関係の両方を表示しますが、下部にあるこのメニューを使用して、依存関係タイプの1つだけに焦点を当てることができます。

00:29:31.000 -> 00:29:37.000
ここでは、同期だけに焦点を当てます。

00:29:37.000 -> 00:29:45.000
Alèが先に述べたように、追跡されたヒープから異なるリソースを読み書きするとき、誤った共有は一般的な問題です。

00:29:45.000 -> 00:29:50.000
依存関係ビューアを使用すると、これらの問題を簡単にキャッチできます。

00:29:50.000 -> 00:29:57.000
私がキャプチャしたこのデモは、この問題がある初期の開発バージョンからのものです。

00:29:57.000 -> 00:30:09.000
このヒープをクリックすると、依存関係ビューアは、このヒープが追跡されていることを示し、したがって、これら2つのパス間の同期を追加します。

00:30:09.000 -> 00:30:26.000
依存関係ビューアは、レンダリングエンコーダが保存するこのレンダリングターゲットテクスチャや、コンピューティングエンコーダが読み書きするバッファなど、ヒープ内に割り当てられたリソースも強調表示します。

00:30:26.000 -> 00:30:39.000
問題は、コンピューティングエンコーダが以前のエンコーダのリソースを使用していないため、これら2つのパス間の同期が不要なことです。

00:30:39.000 -> 00:30:48.000
この依存関係を削除するには、追跡されていないヒープを使用するようにアプリを変更し、同期が必要な場所にフェンスを挿入することができます。

00:30:48.000 -> 00:30:55.000
その変更により、これら2つのパスを並行して実行できるようになりました。

00:30:55.000 -> 00:31:02.000
バインドレスアプリのデバッグに役立つXcode 14のもう1つの大きな改善点は、新しいリソースリストです。

00:31:02.000 -> 00:31:09.000
デバッグして開きたいドローコールに移動できます。

00:31:09.000 -> 00:31:17.000
バインドレスを使用すると、数百または数千のリソースがいつでもGPUで利用できます。

00:31:17.000 -> 00:31:29.000
今年、Metalデバッガは、上部の「アクセス」モードをクリックするだけで、これらのリソースのどれがドローコールにアクセスしたかを確認できます。

00:31:29.000 -> 00:31:40.000
今、デバッガは、このドローコールがアクセスする一握りのリソースと各アクセスの種類だけを表示します。

00:31:40.000 -> 00:31:48.000
これは、シェーダーが引数バッファからアクセスしたリソースを理解するのに非常に役立ちます。

00:31:48.000 -> 00:32:01.000
ドローコールが使用するリソースを知ることは素晴らしいことですが、期待していなかったリソースが表示されている場合は、シェーダーデバッガを使用して何が起こっているのかを把握できます。

00:32:01.000 -> 00:32:15.000
シェーダーデバッガを起動するには、下のバーのデバッグボタンをクリックし、デバッグするピクセルを選択し、デバッグボタンを押すだけです。

00:32:15.000 -> 00:32:19.000
そして今、あなたはシェーダーデバッガにいます。

00:32:19.000 -> 00:32:29.000
シェーダーデバッガは、どのリソースがアクセスされたかなど、コードがどのように行ごとに実行されたかを示します。

00:32:29.000 -> 00:32:35.000
これらの行の場合、このシェーダーは引数バッファからテクスチャを読み取ります。

00:32:35.000 -> 00:32:43.000
右側のサイドバーの詳細なビューを展開して、どのリソースが読み込まれたかを確認できます。

00:32:43.000 -> 00:32:51.000
これは、シェーダーが間違った引数バッファ要素にアクセスする問題を特定するのに役立ちます。

00:32:51.000 -> 00:33:12.000
このデモでは、新しい依存関係ビューアを使用してリソースの依存関係を分析および検証する方法、新しいリソースリストを使用してドロー呼び出しがアクセスしたリソースを理解する方法、シェーダーデバッガを使用してシェーダーがどのように実行されたかを行ごとに分析する方法を示しました。

00:33:12.000 -> 00:33:17.000
これらの新機能を使用して、素晴らしいMetalバインドレスアプリを作成する方法を見るのが待ちきれません。

00:33:17.000 -> 00:33:19.000
君に戻るよ、アレー。

00:33:19.000 -> 00:33:23.000
アレー:ありがとう、マユール。それは素晴らしいデモでした。

00:33:23.000 -> 00:33:27.000
まとめると、メタル3はバインドレスになるためのテーブルに多くをもたらします。

00:33:27.000 -> 00:33:40.000
簡略化された引数バッファエンコーディング、ヒープからの加速構造、検証レイヤーとツールの改善により、Metal 3はゲームやアプリに効果的でパフォーマンスの高いバインドレスをもたらす優れたAPIです。

00:33:40.000 -> 00:33:45.000
今年の機能強化により、ハイブリッドレンダリングアプリはこれまで以上に良くなっています。

00:33:45.000 -> 00:33:51.000
メタルのサンプルコードギャラリーで、完全なソースコードを含むこの更新されたバージョンのアプリをリリースします。

00:33:51.000 -> 00:33:59.000
あなたはそれをダウンロードし、研究し、修正することができ、演習として、私はそれをさらに進め、鏡面に再帰反射を追加することに挑戦します。

00:33:59.000 -> 00:34:01.000
あなたがそれで何をするかを見るのが待ちきれません。

00:34:01.000 -> 00:34:04.000
メタル3でバインドレスになるのにこれほど良い時期はありません。

00:34:04.000 -> 00:34:06.000
ご覧いただきありがとうございます。

00:34:06.000 -> 23:59:59.000
♪インストゥルメンタルヒップホップ音楽♪

