WEBVTT

00:00:00.000 -> 00:00:10.000
♪ ♪

00:00:10.000 -> 00:00:14.000
こんにちは、私はリチャードです。Swift Standard Libraryチームのエンジニアです。

00:00:14.000 -> 00:00:18.000
今日は、Swift Regexの基本を超えた旅に乗り出しましょう。

00:00:18.000 -> 00:00:23.000
Swift 5.7は、文字列処理のための強力な新機能を獲得しています。

00:00:23.000 -> 00:00:28.000
それらは、Swift Standard Libraryの新しいタイプである「Regex」タイプから始まります。

00:00:28.000 -> 00:00:36.000
言語に組み込まれた正規表現リテラル構文は、この強力で馴染みのある概念をさらにファーストクラスにします。

00:00:36.000 -> 00:00:40.000
そして最後に、RegexBuilderと呼ばれる結果ビルダーAPI。

00:00:40.000 -> 00:00:54.000
これは、結果ビルダーの構文的なシンプルさと構成可能性を活用し、Regexの読みやすさをまったく新しいレベルに押し上げるドメイン固有の言語（DSL）です。

00:00:54.000 -> 00:01:04.000
Swift Regexが文字列の処理を容易にする理由については、同僚のMichaelによるMeet Swift Regexセッションをチェックしてください。

00:01:04.000 -> 00:01:07.000
Swift Regexの非常に簡単な例を見てみましょう。

00:01:07.000 -> 00:01:14.000
データの文字列があり、この文字列からユーザーIDを照合して抽出したいとします。

00:01:14.000 -> 00:01:21.000
通常の「NSRegularExpression」のように、テキストから正規表現を作成できます。

00:01:21.000 -> 00:01:35.000
「user_id」コロンに続いて0個以上の空白とそれに続く1つ以上の数字と一致します。今回違うのは、Regex型の値を作成していることです。

00:01:35.000 -> 00:01:39.000
これはSwift Standard Libraryの新しいタイプです。

00:01:39.000 -> 00:01:50.000
次に、文字列の「firstMatch」アルゴリズムを使用して、この正規表現で定義されたパターンの最初の出現を見つけ、そのようにマッチ全体を印刷することができます。

00:01:50.000 -> 00:02:03.000
私の正規表現文字列はコンパイル時に知られているので、コンパイラが構文エラーをチェックし、Xcodeが構文ハイライトを表示できるように、正規表現リテラルの使用に切り替えることができます。

00:02:03.000 -> 00:02:09.000
しかし、究極の読みやすさとカスタマイズのために、私はRegexビルダーDSLを使用することができます。

00:02:09.000 -> 00:02:17.000
Regexビルダーを使用すると、Regexのコンテンツを読むことは、ネイティブのSwift APIを読むのと同じくらい簡単です。

00:02:17.000 -> 00:02:23.000
このセッションでは、Regexの仕組みと、ワークフローにRegexを適用する方法を紹介します。

00:02:23.000 -> 00:02:29.000
Regexは、基礎となるRegexエンジンによって実行されるプログラムです。

00:02:29.000 -> 00:02:38.000
Regexを実行するとき、Regexエンジンは入力文字列を受け取り、文字列の先頭から末尾までマッチングを実行します。

00:02:38.000 -> 00:02:40.000
とてもシンプルな正規表現を見てみましょう。 

00:02:40.000 -> 00:02:48.000
この正規表現は、1つ以上の文字「a」で始まり、1つ以上の数字が続く文字列と一致します。

00:02:48.000 -> 00:02:56.000
入力「aaa12」を照合するために、マッチングアルゴリズムの1つである「wholeMatch」を使用します。

00:02:56.000 -> 00:03:00.000
正規表現エンジンは、入力の最初の文字から起動します。

00:03:00.000 -> 00:03:04.000
まず、1つ以上の文字aと一致します。

00:03:04.000 -> 00:03:11.000
この時点で、文字「1」に到達し、この文字と文字「a」を一致させようとします。

00:03:11.000 -> 00:03:14.000
しかし、それは一致しません。

00:03:14.000 -> 00:03:21.000
したがって、正規表現エンジンは、1つ以上の数字を一致させるために、正規表現の次のパターンに移動します。

00:03:21.000 -> 00:03:25.000
文字列の末尾に達すると、マッチングが成功します。

00:03:25.000 -> 00:03:31.000
このセッションの残りの部分では、この実行モデルについてもう少し説明します。

00:03:31.000 -> 00:03:43.000
Regexを基盤とするRegexエンジン上に構築されているため、RegexビルダーDSLとRegexを搭載したアルゴリズムは、Regexのパワーと表現力を拡張します。

00:03:43.000 -> 00:04:05.000
正規表現を搭載したアルゴリズムは、文字列内の正規表現の最初の出現を見つける最初の一致、正規表現に対して文字列全体を一致する「wholeMatch」、正規表現に対する文字列の接頭辞に一致する「prefixMatch」など、最も一般的な操作のいくつかを提供するコレクションベースのAPIです。

00:04:05.000 -> 00:04:17.000
マッチングに加えて、Swift標準ライブラリは、Regexベースの述語、置換、トリミング、および分割のためのAPIも追加しました。

00:04:17.000 -> 00:04:28.000
また、Regexは、制御フローステートメントのSwiftのパターンマッチング構文で使用できるようになりました。

00:04:28.000 -> 00:04:40.000
最後に、RegexビルダーとRegexを搭載したアルゴリズムに加えて、今年、FoundationはRegexビルダーとシームレスに連携する独自のRegexサポートを導入しました。

00:04:40.000 -> 00:04:51.000
FoundationのRegexサポートは、日付や番号など、おそらくすでに使用しているフォーマッタとパーサーに他なりません。

00:04:51.000 -> 00:04:59.000
これらのAPIについて詳しく知りたい場合は、WWDC21の「What's new in Foundation」セッションをご覧ください。

00:04:59.000 -> 00:05:05.000
今年、FoundationはURLの書式設定と解析のサポートも追加します。

00:05:05.000 -> 00:05:12.000
FoundationのRegexサポートにより、FoundationパーサーをRegexビルダーに直接埋め込むことができます。

00:05:12.000 -> 00:05:26.000
たとえば、このような銀行取引明細書を解析するには、カスタムフォーマットを持つ財団が提供する日付パーサーと、ドメイン固有の解析戦略を持つ通貨パーサーを使用できます。

00:05:26.000 -> 00:05:41.000
コーナーケースを処理し、ローカリゼーションをサポートする既存のバトルテスト済みのパーサーからRegexesを作成し、RegexビルダーDSLの表現力で作成できるため、これは本当に大きな問題です。

00:05:41.000 -> 00:05:47.000
Swift Regexをワークフローに適用する方法を示すために、一緒に例を考えてみましょう。

00:05:47.000 -> 00:05:53.000
XCTestベースの単体テストの実行からログを解析するスクリプトを書いています。

00:05:53.000 -> 00:05:58.000
テストログは、テストスイートのステータスで始まり、テストスイートのステータスで終わります。

00:05:58.000 -> 00:06:05.000
その後、XCTestはすべてのテストケースを実行し、テストケースのステータスを報告します。

00:06:05.000 -> 00:06:09.000
今日は、ログの最初と最後の行を解析しましょう。

00:06:09.000 -> 00:06:12.000
テストスイートに関する情報です。

00:06:12.000 -> 00:06:16.000
まず、RegexBuilderをインポートします。

00:06:16.000 -> 00:06:23.000
RegexBuilderは、RegexBuilder DSLを提供するSwift標準ライブラリの新しいモジュールです。

00:06:23.000 -> 00:06:30.000
正規表現は、正規表現の本体を表すトレーリングクロージャで初期化できます。

00:06:30.000 -> 00:06:33.000
ログメッセージの例を見てみましょう。

00:06:33.000 -> 00:06:46.000
このログには、テストスイートの名前、ステータス、開始、合格、または失敗したかどうか、およびタイムスタンプの3つの変数部分文字列があります。

00:06:46.000 -> 00:06:54.000
3つの変数部分文字列を解析するパターンを考えながら、この行の他の部分を逐語的に解析することができます。

00:06:54.000 -> 00:07:02.000
ログメッセージは「テストスイート」という単語で始まり、その後にスペースと1つの引用符が続きます。

00:07:02.000 -> 00:07:05.000
次に、テストスイートの名前を解析します。

00:07:05.000 -> 00:07:16.000
名前は識別子で、小文字または大文字または数字を含めることができますが、最初の文字は決して数字にすることはできません。

00:07:16.000 -> 00:07:21.000
そのため、最初の文字として文字を一致させるカスタムキャラクタークラスを作成します。

00:07:21.000 -> 00:07:29.000
次に、ゼロから9までの文字または数字のいずれかであるゼロ以上の文字を一致させます。

00:07:29.000 -> 00:07:34.000
これは非常に明確で読みやすいですが、少し面倒です。

00:07:34.000 -> 00:07:38.000
多くの人がテキストの正規表現構文に精通しているかもしれません。

00:07:38.000 -> 00:07:46.000
RegexBuilderでは、実際に簡潔なregexリテラルを本文に直接埋め込むことができます。

00:07:46.000 -> 00:07:50.000
正規表現リテラルはスラッシュで始まり、スラッシュで終わります。

00:07:50.000 -> 00:07:53.000
スウィフトは正しい強いタイプを推測する。

00:07:53.000 -> 00:07:59.000
たとえば、この正規表現は「Hello, WWDC!」という部分文字列と一致します。

00:07:59.000 -> 00:08:02.000
したがって、その出力タイプは部分文字列です。

00:08:02.000 -> 00:08:09.000
しかし、ファーストクラスのレジェックスリテラルについて本当にクールなのは、強く型付けされたキャプチャグループです。

00:08:09.000 -> 00:08:15.000
たとえば、年として2桁をキャプチャするキャプチャグループを書くことができます。

00:08:15.000 -> 00:08:19.000
そして、この捕獲グループに「年」という名前を付けてください。

00:08:19.000 -> 00:08:24.000
これを行うと、出力タイプに別の部分文字列が表示されます。

00:08:24.000 -> 00:08:30.000
この講演の後半では、キャプチャを使用して文字列から情報を抽出する方法を紹介します。

00:08:30.000 -> 00:08:41.000
標準的な正規表現リテラルに加えて、Swiftはポンドスラッシュから始まり、スラッシュポンドで終わる拡張正規表現リテラルもサポートしています。

00:08:41.000 -> 00:08:46.000
拡張リテラルは、非セマンティックな空白を可能にします。

00:08:46.000 -> 00:08:51.000
このモードでは、パターンを複数の行に分割できます。

00:08:51.000 -> 00:08:57.000
私のRegexBuilderにRegexリテラルが埋め込まれており、クリーンでありながら馴染みがあります。

00:08:57.000 -> 00:09:03.000
テスト名を解析した後、単一の引用符と空白を解析します。

00:09:03.000 -> 00:09:05.000
今、私はテストステータスに達しました。

00:09:05.000 -> 00:09:11.000
テストステータスには、開始、失敗、合格の複数のタイプがあります。

00:09:11.000 -> 00:09:16.000
これらのオプションの1つを一致させるために、「ChoiceOf」を使用します。

00:09:16.000 -> 00:09:22.000
「ChoiceOf」は複数のサブパターンの1つに一致し、それはまさに私たちが必要とするものです。

00:09:22.000 -> 00:09:32.000
次に、ステータスの直後に来るもの、スペースの後に「at」の後にスペースが続くものを解析します。

00:09:32.000 -> 00:09:34.000
文字列の残りの部分はタイムスタンプです。

00:09:34.000 -> 00:09:39.000
私たちはこれを任意のキャラクターの1つ以上として一致させることができます。

00:09:39.000 -> 00:09:45.000
しかし、さらにいくつかの例を見ると、ログメッセージはピリオドで終わることがあります。

00:09:45.000 -> 00:09:51.000
私たちはまだ、それが存在する期間を一致させるために「オプション」を使用したいと考えています。

00:09:51.000 -> 00:09:56.000
入力を正規表現と照合するには、提供された照合アルゴリズムの1つを使用します。

00:09:56.000 -> 00:10:02.000
文字列全体を正規表現と照合する「wholeMatch」を使いましょう。

00:10:02.000 -> 00:10:08.000
「wholeMatch」では、これらの各ログメッセージを照合し、一致したコンテンツを印刷します。

00:10:08.000 -> 00:10:10.000
一致しました！

00:10:10.000 -> 00:10:13.000
しかし、それが文字列と一致するかどうかを知りたいだけではありません。

00:10:13.000 -> 00:10:21.000
また、テスト名、ステータス、タイムスタンプなど、関心のある情報を抽出したいと考えています。

00:10:21.000 -> 00:10:26.000
だから、Regexの最もクールな機能の1つであるCapturesでこれをやりましょう!

00:10:26.000 -> 00:10:30.000
キャプチャは、マッチング中に入力の一部を保存します。

00:10:30.000 -> 00:10:38.000
RegexBuilderでは「キャプチャ」として、正規表現構文では括弧のペアとして利用できます。

00:10:38.000 -> 00:10:44.000
キャプチャは、一致した部分文字列を出力タプルタイプに追加します。

00:10:44.000 -> 00:10:55.000
出力タプルタイプは、正規表現全体に一致する部分文字列全体から始まり、最初のキャプチャ、2番目のキャプチャなどが続きます。

00:10:55.000 -> 00:11:03.000
マッチングアルゴリズムは正規表現マッチを返し、そこから出力タプルを取得できます。

00:11:03.000 -> 00:11:09.000
試合全体、最初のキャプチャー、および2番目のキャプチャー。

00:11:09.000 -> 00:11:14.000
テストスイートのログRegexでキャプチャを使用させてください。

00:11:14.000 -> 00:11:21.000
テストスイートの名前、ステータス、タイムスタンプをキャプチャします。

00:11:21.000 -> 00:11:27.000
もう一度、いくつかの入力でこの正規表現を実行し、キャプチャした3つのものを印刷しましょう。

00:11:27.000 -> 00:11:30.000
それは成功した試合のように見えます!

00:11:30.000 -> 00:11:36.000
名前、ステータス、タイムスタンプが印刷されました。

00:11:36.000 -> 00:11:40.000
しかし、よく見ると、日付の何かが少しずれています。

00:11:40.000 -> 00:11:45.000
キャプチャの一部として入力に期間が含まれていました。

00:11:45.000 -> 00:11:49.000
では、戻ってRegexにエラーがないか確認させてください。

00:11:49.000 -> 00:11:53.000
タイムスタンプRegexに集中して、何が悪いのか見てみたい。

00:11:53.000 -> 00:12:04.000
そして、パターン「任意の文字の1つ以上」は、タイムスタンプの最初の桁から行の終わりまですべてを消費することに気づきました。

00:12:04.000 -> 00:12:09.000
したがって、その下の「オプションで期間」パターンは決して一致しませんでした。

00:12:09.000 -> 00:12:14.000
私はこのOneOrMoreを消極的にすることで、これを修正することができます。

00:12:14.000 -> 00:12:18.000
「消極的」は反復行動のケースです。

00:12:18.000 -> 00:12:25.000
1つ以上、0以上、オプションで繰り返しは、Swift Regexが繰り返しと呼ぶものです。

00:12:25.000 -> 00:12:29.000
繰り返しはデフォルトで熱心です。

00:12:29.000 -> 00:12:32.000
できるだけ多くの出来事と一致します。

00:12:32.000 -> 00:12:35.000
先ほどの例を使用させてください。

00:12:35.000 -> 00:12:48.000
正規表現エンジンが任意の文字のOneOrMoreを熱心に一致させようとすると、最初の文字から始まり、入力の終わりまで途中で任意の文字を受け入れます。

00:12:48.000 -> 00:12:53.000
その後、正規表現エンジンはオプションの期間と一致するように移動します。

00:12:53.000 -> 00:12:59.000
一致する期間はもうありませんが、とにかくオプションなので、成功します。

00:12:59.000 -> 00:13:08.000
「wholeMatch」アルゴリズムを実行しており、入力と正規表現パターンの両方が終了に達するため、マッチングは成功します。

00:13:08.000 -> 00:13:18.000
マッチングは成功しましたが、その期間はすでにOneOrMoreの一部として予期せずキャプチャされていました。

00:13:18.000 -> 00:13:26.000
繰り返し動作を消極的に変更すると、Regexエンジンは繰り返しと少し異なります。

00:13:26.000 -> 00:13:30.000
できるだけ少ない文字にマッチします。

00:13:30.000 -> 00:13:44.000
したがって、Regexエンジンが今回入力文字列と一致すると、繰り返しが発生する前に、常に最初にRegexの残りの部分を一致させようとすることで、慎重に前進します。

00:13:44.000 -> 00:13:53.000
正規表現の残りの部分が一致しない場合、エンジンは繰り返しにバックトラックし、追加の出現を消費します。

00:13:53.000 -> 00:13:57.000
最後の文字、ピリオドに早送りしましょう。

00:13:57.000 -> 00:14:08.000
熱心な動作とは異なり、Regexエンジンは当初OneOrMoreの一部として期間を消費しませんでしたが、代わりに「オプションの期間」パターンを一致させようとします。

00:14:08.000 -> 00:14:13.000
これは一致し、正規表現エンジンはパターンの最後に到達します。

00:14:13.000 -> 00:14:21.000
したがって、マッチングは成功し、後続の期間なしで正しいキャプチャを生成します。

00:14:21.000 -> 00:14:30.000
熱心はデフォルトの動作であるため、繰り返しを使用して正規表現を作成する場合は、意図した一致への影響について考える必要があります。

00:14:30.000 -> 00:14:45.000
余分な引数を渡すことで、繰り返しごとのレベルで動作を指定するか、「repetitionBehavior」修飾子を使用して、動作を指定しなかったすべての繰り返しに対してオーバーライドすることができます。

00:14:45.000 -> 00:14:58.000
タイムスタンプが消極的になるように繰り返し動作を変更したため、マッチングはピリオドを含めずに適切なタイムスタンプを抽出するようになりました。

00:14:58.000 -> 00:15:01.000
正規表現に戻りましょう。

00:15:01.000 -> 00:15:08.000
Captureを使用して入力からテストステータスを抽出すると、そのタイプはSubstringです。

00:15:08.000 -> 00:15:16.000
しかし、サブストリングをカスタムデータ構造など、よりプログラミングに優しいものに変換できれば、はるかに良いでしょう。

00:15:16.000 -> 00:15:19.000
これを行うには、変換キャプチャを使用できます。

00:15:19.000 -> 00:15:25.000
変換キャプチャは、変換クロージャ付きのキャプチャです。

00:15:25.000 -> 00:15:36.000
一致すると、正規表現エンジンは、一致した部分文字列の変換クロージャを呼び出し、目的のタイプの結果を生成します。

00:15:36.000 -> 00:15:41.000
対応する正規表現出力タイプは、クロージャの戻り値タイプになります。

00:15:41.000 -> 00:15:50.000
ここでは、StringからIntの初期化子でキャプチャを変換することで、出力タプルタイプのオプションのIntを取得します。

00:15:50.000 -> 00:15:55.000
オプション以外の出力を取得するには、TryCaptureが役立ちます。

00:15:55.000 -> 00:16:05.000
TryCaptureは、オプションを返し、出力タイプのオプション性を削除する変換を受け入れるCaptureのバリアントです。

00:16:05.000 -> 00:16:13.000
マッチング中にnを返すと、Regexエンジンがバックトラックして別のパスを試すようになります。

00:16:13.000 -> 00:16:20.000
TryCaptureは、失敗可能な初期化子でキャプチャを変換する場合に最も便利です。

00:16:20.000 -> 00:16:25.000
キャプチャされたテストステータスを保存するための自然な適合は、列挙です。

00:16:25.000 -> 00:16:28.000
では、1つを定義しましょう。

00:16:28.000 -> 00:16:34.000
開始、合格、失敗の3つのケースでTestStatus列挙型を定義しました。

00:16:34.000 -> 00:16:40.000
生の文字列値は、この列挙型を文字列から初期化可能にします。

00:16:40.000 -> 00:16:44.000
正規表現では、変換で「TryCapture」に切り替えます。

00:16:44.000 -> 00:16:53.000
変換クロージャでは、TestStatus初期化子を呼び呼び出して、一致した部分文字列をTestStatus値に変換します。

00:16:53.000 -> 00:16:57.000
これで、対応する出力タイプはTestStatusです。

00:16:57.000 -> 00:17:03.000
このようなカスタムデータ構造を使用すると、正規表現一致出力タイプが安全になります。

00:17:03.000 -> 00:17:04.000
正規表現に戻る。

00:17:04.000 -> 00:17:08.000
私がしたい追加の改善が1つあります。

00:17:08.000 -> 00:17:12.000
現在、ワイルドカードパターンを使用してタイムスタンプを照合しています。

00:17:12.000 -> 00:17:15.000
それは部分文字列を生成するつもりです。

00:17:15.000 -> 00:17:24.000
これは、私のアプリがタイムスタンプを理解したい場合は、部分文字列を別のデータ構造に再度解析する必要があることを意味します。

00:17:24.000 -> 00:17:33.000
セッションの前半で、FoundationがSwift Regexをサポートし、業界強度のパーサーをRegexesとして提供していることに言及しました。

00:17:33.000 -> 00:17:45.000
したがって、日付を部分文字列として解析する代わりに、FoundationのISO 8601日付パーサーに切り替えて、タイムスタンプを日付として解析することができます。

00:17:45.000 -> 00:17:50.000
今、推論された型は、この正規表現が日付を出力することを示しています。

00:17:50.000 -> 00:17:58.000
入力で「wholeMatch」を実行すると、日付文字列がFoundation Date値に解析されたことがわかります。

00:17:58.000 -> 00:18:07.000
財団の日付パーサーのように、正規表現として戦闘でテストされたパーサーにアクセスできることは、日々の文字列処理タスクで非常に便利です。

00:18:07.000 -> 00:18:16.000
次に、Swift Regexの他の場所で定義された既存のパーサーを再利用する高度な機能を紹介します。

00:18:16.000 -> 00:18:20.000
テストケースの期間を解析したい例を見てみましょう。

00:18:20.000 -> 00:18:26.000
持続時間は、0.001などの浮動小数点数です。

00:18:26.000 -> 00:18:34.000
これを行う最善の方法は、もちろん、ローカリゼーションを完全にサポートするFoundationが提供する浮動小数点パーサーを使用することです。

00:18:34.000 -> 00:18:46.000
しかし、今日は、ボンネットの下にあるものと、既存のパーサーを活用して期間の浮動小数点数を解析するために、自分でRegexエンジンにフックする方法をお見せしたいと思います。

00:18:46.000 -> 00:18:51.000
「strtod」はC標準ライブラリの関数です。

00:18:51.000 -> 00:19:00.000
文字列ポインタを受け取り、基礎となる文字列を解析し、一致の終了位置をエンドポインタに割り当てます。

00:19:00.000 -> 00:19:03.000
期間、Cの道を解析しましょう。

00:19:03.000 -> 00:19:12.000
これを行うには、パーサータイプを自分で定義し、CustomConsumingRegexComponentプロトコルに準拠させることができます。

00:19:12.000 -> 00:19:16.000
CDoubleParserという名前の構造を定義します。

00:19:16.000 -> 00:19:22.000
ダブル数を解析しているので、その「RegexOutput」はダブルです。

00:19:22.000 -> 00:19:33.000
「消費」メソッドでは、C標準ライブラリからダブルパーサーを呼び出し、文字列ポインタを渡し、番号を取り戻します。

00:19:33.000 -> 00:19:41.000
メソッド本体では、withCStringメソッドを使用して開始アドレスを取得します。

00:19:41.000 -> 00:19:49.000
次に、「strtod」C関数を呼び出し、開始アドレスとポインタを渡して結果の終了アドレスを受け取ります。

00:19:49.000 -> 00:19:51.000
その後、エラーをチェックします。

00:19:51.000 -> 00:19:57.000
解析が成功すると、終了アドレスは開始アドレスよりも大きくなります。

00:19:57.000 -> 00:20:01.000
そうでなければ、それは解析の失敗なので、私はnilを返します。

00:20:01.000 -> 00:20:07.000
C APIによって生成されたポインタから一致の上限を計算します。

00:20:07.000 -> 00:20:12.000
そして最後に、一致の上限と数値出力を返します。

00:20:12.000 -> 00:20:19.000
Regexに戻って、Regexで直接「CDoubleParser」を使用できます。

00:20:19.000 -> 00:20:23.000
出力タイプはダブルと推測されます。

00:20:23.000 -> 00:20:30.000
「wholeMatch」を呼び、解析された番号を印刷すると、予想通り0.001が出力されます。

00:20:30.000 -> 00:20:42.000
要約すると、今日は、文字列処理の力をアプリに統合できるSwift 5.7の新機能であるSwift Regexの一般的で高度な使用について話しました。

00:20:42.000 -> 00:20:53.000
Swift Regexを使用する際の良い習慣は、特にRegexBuilder DSLとRegexリテラルを混在させるときに、簡潔さと読みやすさのバランスを取ることです。

00:20:53.000 -> 00:21:07.000
日付やURLなどの一般的なパターンに遭遇した場合、カスタムコードでこれらのパターンを解析するとエラーが発生しやすいため、常にFoundationが提供する業界強度のパーサーを優先してください。

00:21:07.000 -> 00:21:14.000
Swift Regexの詳細については、Swift Evolutionに関する一連の宣言的文字列処理提案をご覧ください。

00:21:14.000 -> 00:21:18.000
Swiftで文字列を処理するのを楽しんでいただければ幸いです。

00:21:18.000 -> 23:59:59.000
ありがとう、そして素晴らしいWWDCをお過ごしください。

