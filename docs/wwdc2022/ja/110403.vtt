WEBVTT

00:00:00.000 --> 00:00:03.000
♪まろやかなインストゥルメンタルヒップホップ音楽♪

00:00:03.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:13.000
こんにちは！私の名前はジャレッドで、アップルのソフトウェアエンジニアです。

00:00:13.000 --> 00:00:19.000
今日は、今年iOS、iPadOS、macOSに導入する新しいフレームワークについてお話ししたいと思います。

00:00:19.000 --> 00:00:27.000
この新しいフレームワークはバックグラウンドアセットと呼ばれ、私たち全員が知っていて愛している、そしてさらに重要なことに、あなたが開発するアプリのユーザーエクスペリエンスを大いに豊かにすると信じています。

00:00:27.000 --> 00:00:32.000
まず、新しいバックグラウンドアセットフレームワークを紹介します。 バックグラウンドアセットフレームワークを紹介します。

00:00:32.000 --> 00:00:36.000
その後、新しいフレームワークをアプリに採用する方法を紹介します。

00:00:36.000 --> 00:00:41.000
その後、拡張機能とそれが提供する新機能の概要が続きます。

00:00:41.000 --> 00:00:45.000
その後、いくつかのベストプラクティスと私たちが学んだすべてで終わります。

00:00:45.000 --> 00:00:48.000
始める前に、ここで解決しようとしていることについて話しましょう。

00:00:48.000 --> 00:00:50.000
真実は、待つことは楽しくないということです。

00:00:50.000 --> 00:00:58.000
ソフトウェアを使用する人に待つように頼むたびに、私たちは欲求不満を増し、アプリに提供してほしい経験から奪っています。

00:00:58.000 --> 00:01:03.000
例えば、どのくらいの頻度で、その完璧なアプリを探してApp Storeを際限なく閲覧していることに気づきましたか?

00:01:03.000 --> 00:01:06.000
あなたはついにそれを見つけました、そしてああ、それはとても完璧に見えますか!

00:01:06.000 --> 00:01:08.000
次に、そのGETボタンをタップします。

00:01:08.000 --> 00:01:12.000
瞬間ごとに、あなたの興奮のレベルが高まります。

00:01:12.000 --> 00:01:19.000
その後、ネットワーク接続やアプリのサイズによっては、アプリがダウンロードされるのを待たなければならないかもしれません。

00:01:19.000 --> 00:01:31.000
その後、数秒待った後、あなたは携帯電話を置き、コーヒーを飲み、マインドフルネスを実践し、忍耐を習得することの利点についてのあなたのお気に入りの本を読んでいます。

00:01:31.000 --> 00:01:35.000
それから数時間が経ち、あなたはついに電話を取りました。

00:01:35.000 --> 00:01:41.000
一日中使うのを待っていた完璧なアプリに飛び込む準備ができたら、興奮レベルが上がります。

00:01:41.000 --> 00:01:45.000
アプリを起動し、すぐにこれで迎えられるために:より多くのダウンロード。

00:01:45.000 --> 00:01:46.000
紛らわしい。

00:01:46.000 --> 00:01:48.000
あなたは一日中電話から離れていました。

00:01:48.000 --> 00:01:51.000
なぜこのアプリは今、あなたをさらに長く待たせるのですか?

00:01:51.000 --> 00:01:55.000
このアプリは、アプリがインストールされた後、このコンテンツを自動的にダウンロードできませんでしたか?

00:01:55.000 --> 00:02:00.000
インターネット接続が遅い人にとって、これはアプリを閉じて削除することを挫折させるかもしれません。

00:02:00.000 --> 00:02:03.000
真実は、これは私たちの誰もが望む経験ではありません。

00:02:03.000 --> 00:02:07.000
私たちはこれがあなたのせいではないことを知っており、この経験をはるかに良くすることができると信じています!

00:02:07.000 --> 00:02:11.000
これが、私たちが今年あなたに紹介することを誇りに思う理由です、バックグラウンドアセット。

00:02:11.000 --> 00:02:15.000
このフレームワークは、アプリのユーザーエクスペリエンスを豊かにするために開発されました。

00:02:15.000 --> 00:02:19.000
アプリが起動した瞬間に、驚異的な第一印象を与えています!

00:02:19.000 --> 00:02:23.000
バックグラウンドアセットは、既存のワークフローに柔軟に対応するように設計されています。

00:02:23.000 --> 00:02:31.000
多くの人がすでに複雑な資産管理システムを開発しており、この新しいフレームワークをすでに開発したソリューションに簡単に適合させたいと思っていました。

00:02:31.000 --> 00:02:38.000
また、App Storeへの追加の提出を必要とせずに、更新されたコンテンツをアプリにプッシュできるようにしたいことも知っています。

00:02:38.000 --> 00:02:43.000
アプリがすでに出荷された後、ゲームやその他のアプリが追加のコンテンツを必要とすることは珍しくありません。

00:02:43.000 --> 00:02:47.000
更新されたアートテクスチャやゲームレベルのデータのバグ修正を考えてください。

00:02:47.000 --> 00:02:52.000
バックグラウンドアセットは、アプリのライフサイクル外でアセットをスケジュールおよび更新する機能を提供します。

00:02:52.000 --> 00:02:58.000
私たちは、最初のアプリの起動前、またはアプリが一晩で更新されるたびに、資産が存在することが重要だと考えています。

00:02:58.000 --> 00:03:03.000
そのため、アプリの起動時までにコンテンツが存在することを確認するためのメカニズムの作成に取り組みました。

00:03:03.000 --> 00:03:08.000
そして最後に、フレームワークの採用が簡単であればあるほど、アプリでの使用を奨励できます。

00:03:08.000 --> 00:03:13.000
バックグラウンドアセットは、大規模なアセットを事前にダウンロードする必要がある場所で使用したいと考えています。

00:03:13.000 --> 00:03:20.000
そうすれば、アプリが待機している時間を最小限に抑え、コンテンツが利用可能になる前にプログレスバーを表示することができます。

00:03:20.000 --> 00:03:23.000
だから、この新しいフレームワークは、この問題の解決にどのように役立っているのか疑問に思うかもしれません。

00:03:23.000 --> 00:03:30.000
さて、できるだけ拡張できるように、バックグラウンドでコンテンツをダウンロードするための新しいアプリ拡張機能を作成しました。

00:03:30.000 --> 00:03:36.000
この新しい拡張機能は、当社のプラットフォーム上の他の拡張機能が使用する強力なアプリ拡張技術の上に構築されています。

00:03:36.000 --> 00:03:40.000
これは、アプリのライフサイクルの外でコードを実行する機会を提供します。

00:03:40.000 --> 00:03:45.000
たとえば、拡張機能は、ユーザーが最初にアプリをインストールしたが、まだ起動していないたびに実行されます。

00:03:45.000 --> 00:03:49.000
拡張機能は、アプリがバックグラウンドで自動的に更新されるたびに実行されます。

00:03:49.000 --> 00:03:56.000
これは、ユーザーが更新後にアプリケーションを開く前に、コンテンツをスケジュールしてダウンロードできるようにするのに役立ちます。

00:03:56.000 --> 00:04:03.000
最後に、拡張機能はバックグラウンドで定期的に実行され、更新されたアセットを確認し、時間の経過とともに定期的にスケジュールすることができます。

00:04:03.000 --> 00:04:10.000
注意することが重要ですが、その拡張ランタイムは短命であるため、すべての作業は急いで拡張機能でスケジュールする必要があります。

00:04:10.000 --> 00:04:14.000
ダウンロードがすぐにスケジュールされない場合、システムは拡張機能を終了する可能性があります。

00:04:14.000 --> 00:04:20.000
また、定期的に実行する拡張機能の頻度は、アプリの使用状況に基づいて後退することに注意することも重要です。

00:04:20.000 --> 00:04:25.000
アプリがあまり使用されていない場合、拡張機能はランタイムの頻度が少なくなります。

00:04:25.000 --> 00:04:27.000
つまり、新しいバックグラウンドアセットフレームワークの概要です。

00:04:27.000 --> 00:04:32.000
アプリが起動されるまでにアセットが利用可能であることを確認するために必要なツールを提供します。

00:04:32.000 --> 00:04:38.000
これは、アプリがインストールまたは更新されるたびに、ユーザーがアプリを起動する前に実行される拡張機能で行われます。

00:04:38.000 --> 00:04:43.000
では、背景アセットフレームワークをプロジェクトに採用し、始めましょう!

00:04:43.000 --> 00:04:49.000
フレームワーク内のダウンロードマネージャは、バックグラウンドアセットシステムサービスと通信するために使用される主要な手段です。

00:04:49.000 --> 00:04:52.000
マネージャーは、アプリ全体で使用できるシングルトンオブジェクトです。

00:04:52.000 --> 00:04:57.000
マネージャーを使用すると、フォアグラウンドまたはバックグラウンドでアセットのダウンロードをスケジュールできます。

00:04:57.000 --> 00:05:03.000
また、アプリケーションが起動される前に開始された可能性のある、現在飛行中のダウンロードを取得することもできます。

00:05:03.000 --> 00:05:04.000
ダウンロードもキャンセルできます。

00:05:04.000 --> 00:05:10.000
これは、すでにスケジュールされている場合、またはダウンロード中であり、最初に要求したアセットが不要になった場合に便利です。

00:05:10.000 --> 00:05:24.000
また、拡張機能とアプリケーションの両方が同時に既存のダウンロードをスケジュールまたは変更しないように、アプリと拡張機能間の排他的なアクセスを管理するための同期メカニズムを導入しました。

00:05:24.000 --> 00:05:27.000
お見せする例がありますが、今のところ、これについては後で詳しく説明します。

00:05:27.000 --> 00:05:31.000
バックグラウンドアセットを使い始めるのがどれほど簡単かを見てみましょう。

00:05:31.000 --> 00:05:34.000
まず、APIの基本をいくつかご案内します。

00:05:34.000 --> 00:05:39.000
その後、これらすべてをアプリの拡張機能に結びつける方法を示すことで、後でフォローアップします。

00:05:39.000 --> 00:05:43.000
開始するには、バックグラウンドアセットフレームワークモジュールをインポートします。

00:05:43.000 --> 00:05:48.000
次に、リモートアセットが配置されている場所を指すURLを定義するのと同じくらい簡単です。

00:05:48.000 --> 00:05:53.000
次に、拡張機能とアプリの両方がメンバーであるアプリグループコンテナを定義します。

00:05:53.000 --> 00:05:59.000
アプリと拡張機能を同じグループにまとめることで、ダウンロード中と完了後にアセットを管理できます。

00:05:59.000 --> 00:06:05.000
アプリグループにまだ慣れていない場合は、Xcode 14の「署名と機能」セクションから簡単に追加できます。

00:06:05.000 --> 00:06:12.000
これらは、2つ以上のアプリケーションが同じリソース、またはこの場合はアプリとその拡張機能にアクセスできるようにする強力な機能です。

00:06:12.000 --> 00:06:15.000
次に行うことは、ダウンロードオブジェクトを作成することです。

00:06:15.000 --> 00:06:19.000
バックグラウンドアセットフレームワークは、複数の異なるタイプのダウンロードオブジェクトをサポートするように設計されています。

00:06:19.000 --> 00:06:25.000
ただし、この例では、最も一般的なもの、BAURLDownloadに焦点を当てます。

00:06:25.000 --> 00:06:30.000
すぐに、初期化子がURLとアプリグループの識別子を取り込むことに気付くでしょう。

00:06:30.000 --> 00:06:35.000
この情報は、私たちがダウンロードしているものと、結果のファイルがどこで終わるかの両方をシステムに伝えます。

00:06:35.000 --> 00:06:37.000
また、識別子も必要です。

00:06:37.000 --> 00:06:43.000
この識別子を使用して、アプリの複数の起動と拡張機能内でダウンロードを追跡します。

00:06:43.000 --> 00:06:48.000
エンジンは、同じ識別子で複数のダウンロードをスケジュールすることはできません。

00:06:48.000 --> 00:06:51.000
したがって、これらの識別子を一意にする必要があります。

00:06:51.000 --> 00:06:56.000
次に、BADownloaderManager共有オブジェクトへの参照をつかみます。

00:06:56.000 --> 00:06:59.000
ダウンロードマネージャは、バックグラウンドアセットへの単一のインターフェースです。

00:06:59.000 --> 00:07:03.000
それはあなたがダウンロードを観察し、キャンセルし、スケジュールすることを可能にするものです。

00:07:03.000 --> 00:07:08.000
次に、BADownloadManagerDelegateプロトコルに準拠したデリゲートへの弱い参照を渡します。

00:07:08.000 --> 00:07:15.000
まもなくこのプロトコルについて詳しく行きますが、今知っておくべき最も重要な部分は、スケジュールされたダウンロードに関するメッセージを受信することです。

00:07:15.000 --> 00:07:19.000
残っているのは、ダウンロードマネージャーにダウンロードのスケジュールを依頼することだけです。

00:07:19.000 --> 00:07:22.000
何らかの理由でダウンロードをスケジュールできない場合は、エラーがスローされます。

00:07:22.000 --> 00:07:27.000
バックグラウンドでダウンロードをスケジュールするだけでなく、フォアグラウンドダウンロードを行うためのAPIも提供しています。

00:07:27.000 --> 00:07:34.000
フォアグラウンドで実行すると、優先順位が高まるだけでなく、ダウンロードをすぐに開始することもできます。

00:07:34.000 --> 00:07:38.000
これは、URLSession内でデフォルトのセッション設定を使用するのと似ています。

00:07:38.000 --> 00:07:43.000
アプリが拡張機能によってスケジュールされたダウンロードをバックグラウンドでフォアグラウンドに促進できるように、このAPIを提供します。

00:07:43.000 --> 00:07:51.000
覚えておくべきことの1つは、フォアグラウンドダウンロードの実行は、拡張機能内からは利用できないことです。アプリからのみ開始できます。

00:07:51.000 --> 00:07:58.000
拡張機能はUIを提示せず、ユーザーは実行されていることに気付かないため、拡張機能はバックグラウンドでのみダウンロードをスケジュールすることができます。

00:07:58.000 --> 00:08:06.000
アプリが既存のバックグラウンドダウンロードをフォアグラウンドに宣伝したい場合は、マネージャーから現在アクティブなダウンロードのリストを取得することで簡単に実現できます。

00:08:06.000 --> 00:08:12.000
返されるリストには、現在スケジュールされているすべてのダウンロードが含まれています。これには、飛行中のダウンロードやスケジューラでキューに入れられたダウンロードが含まれる場合があります。

00:08:12.000 --> 00:08:17.000
次に、アプリはstartForegroundDownloadを呼び出すことでプロモーションプロセスを開始できます。

00:08:17.000 --> 00:08:22.000
ダウンロードがすでにフォアグラウンドにある場合、このメソッドを呼び出すと事実上何もしません。

00:08:22.000 --> 00:08:31.000
ただし、ダウンロードがバックグラウンドの場合、最初に一時停止され、その後、この時点まですでにダウンロードされていたコンテンツを再ダウンロードする必要なしに、フォアグラウンドで再開されます。

00:08:31.000 --> 00:08:39.000
これは、バックグラウンドアセットを使用して、バックグラウンドでスケジュールされたダウンロードをフォアグラウンドに促進することがいかに簡単かを示す効果的で簡単な説明を提供します。

00:08:39.000 --> 00:08:41.000
それは本当にそれと同じくらい簡単です!

00:08:41.000 --> 00:08:46.000
ダウンロードマネージャーは、バックグラウンドダウンロードをスケジュールおよび監視するために使用される主要なインターフェイスです。

00:08:46.000 --> 00:08:51.000
これらのダウンロードオブジェクトはシステムによって処理されるため、デリゲートオブジェクトにメッセージを受信します。

00:08:51.000 --> 00:08:52.000
では、デリゲートを歩きましょう。

00:08:52.000 --> 00:08:58.000
デリゲートは、拡張機能またはアプリによってスケジュールされたすべてのダウンロードに関するメッセージを受信します。

00:08:58.000 --> 00:09:02.000
スケジュールされた多数のダウンロードがある場合、それらすべてに対してコールバックが受信されます。

00:09:02.000 --> 00:09:07.000
これは、ダウンロードオブジェクトの一意の識別子を使用してそれらを区別する場所です。

00:09:07.000 --> 00:09:12.000
デリゲートがBADownloadManagerに設立された瞬間に、アプリはコールバックを受信し始めます。

00:09:12.000 --> 00:09:14.000
コールバックはシステムによってキューにされません。

00:09:14.000 --> 00:09:21.000
アプリがデリゲートメソッドの1つを処理しない場合、またはデリゲートが確立されていない場合、拡張機能は目を覚ましてメッセージを処理します。

00:09:21.000 --> 00:09:29.000
これは、アプリ内でBADownloadManagerにデリゲートを確立していない場合は、拡張機能にメッセージが送信されることを完全に期待する必要があることを意味します。

00:09:29.000 --> 00:09:37.000
アプリが現在ユーザーに提示されているフォアグラウンドにあり、そのデリゲートが確立されている場合、コールバックはアプリに送信され、拡張機能は起こされません。

00:09:37.000 --> 00:09:41.000
拡張機能は、アプリがデリゲートコールバックを処理しない場合にのみ起動します。

00:09:41.000 --> 00:09:46.000
ダウンロードが終了または失敗し、アプリがこのメッセージを処理しない場合、拡張機能はスリープ解除されます。

00:09:46.000 --> 00:09:50.000
拡張機能はすべてのタイプのコールバックで目覚めるわけではないことを覚えておいてください。

00:09:50.000 --> 00:09:57.000
BADownloadManagerDelegateとBADownloaderExtensionプロトコル間の共通インターフェイスを共有するコールバックのみ。

00:09:57.000 --> 00:10:02.000
ダウンロードの成功または失敗は、デリゲートとプロトコルの間の共通のインターフェイスの例です。

00:10:02.000 --> 00:10:11.000
アプリ拡張機能には、スリープ解除を引き起こす独自のエントリポイントがありますが、拡張機能が現在実行されている場合は、BADownloadManagerを使用してデリゲートを確立できます。

00:10:11.000 --> 00:10:16.000
これにより、アプリと拡張機能の両方がデリゲートに重複したメッセージを受信できるようになります。

00:10:16.000 --> 00:10:19.000
拡張機能は、デリゲートメッセージを処理するためにスリープ解除されないことを覚えておいてください。

00:10:19.000 --> 00:10:24.000
それらは、BADownloaderExtensionプロトコルで定義された拡張エントリポイントでのみ起動します。

00:10:24.000 --> 00:10:27.000
ダウンロードマネージャーのデリゲートのプロトコルを見てみましょう。

00:10:27.000 --> 00:10:31.000
最初の機能は、ダウンロードが始まるたびにメッセージを受信することです。

00:10:31.000 --> 00:10:35.000
これは、デバイスが最終的に特定のダウンロードをスケジュールすることを選択したときの追跡に役立ちます。

00:10:35.000 --> 00:10:38.000
ダウンロードが一時停止した場合にも通知される場合があります。

00:10:38.000 --> 00:10:45.000
一時停止が発生する例は、拡張機能がバックグラウンドでダウンロードを開始し、アプリがそれをフォアグラウンドに昇格するように要求した場合です。

00:10:45.000 --> 00:10:50.000
このプロモーションでは、ダウンロードが再開される前に一時停止する小さなウィンドウがあります。

00:10:50.000 --> 00:10:56.000
ダウンロードマネージャーでは、フォアグラウンドでダウンロードされているダウンロードのアクティブな進行状況を監視することもできます。

00:10:56.000 --> 00:11:04.000
また、チャレンジリクエストに答えるメカニズムも提供しています。これは、接続の信頼性を検証したり、接続を承認するための資格情報を提供するのに役立ちます。

00:11:04.000 --> 00:11:08.000
最も重要な機能は、ダウンロードの失敗または終了したダウンロードに対処することです。

00:11:08.000 --> 00:11:12.000
ダウンロードに失敗した場合は、スケジュールを変更するか、原因を特定する必要があるかもしれません。

00:11:12.000 --> 00:11:17.000
ダウンロードを成功させるために、システムはオペレーティングシステムによって管理されている場所にファイルを配置しました。

00:11:17.000 --> 00:11:21.000
デバイスの容量が足りなくなった場合、システムはファイルを削除します。

00:11:21.000 --> 00:11:26.000
システムが提供した場所にファイルを残すことを強くお勧めします。

00:11:26.000 --> 00:11:33.000
絶対に必要である場合にのみファイルを移動し、後で元のファイルを削除しない限り、ファイルを複製しないでください。

00:11:33.000 --> 00:11:40.000
念のため、ダウンロードマネージャーの代理人のプロトコルは、アプリや拡張機能がスケジュールしたダウンロードに関連するメッセージを受信するためのものです。

00:11:40.000 --> 00:11:44.000
それはあなたの拡張機能のエントリポイントではないので、次のトピックに進みます。

00:11:44.000 --> 00:11:49.000
次に、バックグラウンドアセットの最もエキサイティングな部分、拡張機能を見ていきます!

00:11:49.000 --> 00:11:54.000
この拡張機能を使用すると、ユーザーがアプリを起動する前に、アセットのダウンロードをスケジュールできます。

00:11:54.000 --> 00:12:01.000
これにより、最小限の待ち時間でアプリで可能な限り最高のエクスペリエンスを提供するために、資産が配置され、準備ができていることを確認できます。

00:12:01.000 --> 00:12:05.000
先に説明したように、新しいアプリ拡張機能を導入しています。

00:12:05.000 --> 00:12:09.000
この拡張機能は、既存のプロジェクト内のXcode内から作成できます。

00:12:09.000 --> 00:12:13.000
簡単なリマインダーとして、拡張機能はアプリがインストールまたは更新されるたびに実行されます。

00:12:13.000 --> 00:12:18.000
アプリの変更に常に最新の資産があることを確認する柔軟性を提供します。

00:12:18.000 --> 00:12:22.000
この拡張機能は、ユーザーがアプリを使用する頻度に基づいて定期的に実行されます。

00:12:22.000 --> 00:12:28.000
誰かがあなたのアプリを毎日使用している場合、システムはこの動作を学習し、拡張機能はより頻繁に実行されます。

00:12:28.000 --> 00:12:33.000
ただし、アプリが起動しない場合、この定期的なチェックの頻度は収まります。

00:12:33.000 --> 00:12:40.000
新しい拡張機能には、短いライフサイクルとタイトなサンドボックスもあり、その使用がアセットをダウンロードするだけに制限されていることを保証します。

00:12:40.000 --> 00:12:45.000
拡張機能で迅速な決定を下し、拡張機能をバックグラウンドアセットフレームワークに制限することをお勧めします。

00:12:45.000 --> 00:12:51.000
拡張機能のナビゲートを開始する前に、拡張機能を起動する前に作成する必要がある設定がいくつかあります。

00:12:51.000 --> 00:12:56.000
これらの変更は、アプリがApp Storeでの配布を承認するための要件でもあります。

00:12:56.000 --> 00:13:01.000
アプリの情報プロパティリストでは、いくつかの追加キーを定義する必要があります。

00:13:01.000 --> 00:13:05.000
これらのキーは、拡張機能のInfo.plistではなく、アプリのみに配置する必要があります。

00:13:05.000 --> 00:13:08.000
最初のキーはBAInitialDownloadRestrictionsです。

00:13:08.000 --> 00:13:12.000
これは、拡張機能に課される制限を指定する辞書です。

00:13:12.000 --> 00:13:17.000
これらの制限はApp Reviewによってレビューされるので、できるだけ正確であるようにしてください。

00:13:17.000 --> 00:13:21.000
では、辞書内の個々のキーを掘り下げてみましょう。

00:13:21.000 --> 00:13:23.000
最初の制限はダウンロード許容量です。

00:13:23.000 --> 00:13:30.000
これはバイト単位で表され、最初のアプリのインストール中に拡張機能内で要求する最大ダウンロードサイズです。

00:13:30.000 --> 00:13:37.000
このサイズは、個々のファイルのサイズではなく、ダウンロードをリクエストするすべてのファイルの合計に関係します。

00:13:37.000 --> 00:13:41.000
次の項目は、文字列として表されるドメインの配列を取るドメインAllowListです。

00:13:41.000 --> 00:13:48.000
ドメインAllowListはプレフィックスワイルドカードをサポートし、拡張機能がダウンロードが許可されているホスト名のリストを取り込みます。

00:13:48.000 --> 00:13:57.000
DownloadAllowanceやAllowListなどのBAInitialDownloadRestrictionsのキーは、最初のアプリのインストール後にのみ強制されることに注意することが重要です。

00:13:57.000 --> 00:14:01.000
アプリが起動するたびに、これらの制限は適用されなくなります。

00:14:01.000 --> 00:14:09.000
Info.plistのルートにある最後の必要なキーは、アプリがこれらのアセットの追加ストレージに必要な最大サイズです。

00:14:09.000 --> 00:14:15.000
圧縮されたアセットをダウンロードしたいかもしれないので、この値は最終的な抽出された非圧縮サイズである必要があります。

00:14:15.000 --> 00:14:19.000
ここに置かれた番号は、アプリがダウンロードされる前にApp Storeに表示されます。

00:14:19.000 --> 00:14:25.000
ハウスキーピングについて説明しましたので、拡張機能へのエントリポイントについて詳しく話しましょう。

00:14:25.000 --> 00:14:30.000
プロトコルから定義した関数は、アプリではなくシステムによって呼び出されます。

00:14:30.000 --> 00:14:39.000
アプリケーションが拡張機能と会話する責任を負う他のアプリ拡張機能とは異なり、バックグラウンドダウンロード拡張機能はシステムによって仲介されます。

00:14:39.000 --> 00:14:43.000
システムは拡張機能のライフサイクルを維持しているため、一時的なサービスと見なされるべきです。

00:14:43.000 --> 00:14:50.000
プロトコル内の機能のいずれかが呼び出されるたびに、そこで行われる作業を最小限に抑えることが重要です。

00:14:50.000 --> 00:14:53.000
拡張機能は、起動後すぐに終了します。

00:14:53.000 --> 00:14:58.000
ここは、しばらく時間がかかる可能性のある減圧やその他の複雑な操作を開始する場所ではありません。

00:14:58.000 --> 00:15:07.000
拡張機能での作業の大きな部分の1つは、アプリで利用可能なすべてのBackgroundAssets APIが拡張機能内でも利用可能であることです。

00:15:07.000 --> 00:15:10.000
唯一の例外はForegroundDownload APIです。

00:15:10.000 --> 00:15:14.000
これは、アプリと同じようにBADownloadManagerを使用することを意味します。

00:15:14.000 --> 00:15:25.000
実際のところ、アプリとその拡張機能の両方で資産をスケジュールおよび管理するために同じコードを使用するものを作成する機能を発見する可能性が十分にあります。

00:15:25.000 --> 00:15:30.000
また、拡張機能を作成するときは、両方が共通のアプリグループにあることを確認することが重要です。

00:15:30.000 --> 00:15:36.000
アプリとその拡張機能でコンテンツを読み書きできるように、同じグループ識別子を使用する必要があります。

00:15:36.000 --> 00:15:41.000
それでは、拡張機能に適合するダウンローダ拡張プロトコルを見てみましょう。

00:15:41.000 --> 00:15:45.000
最初に気付くのは、ダウンロードマネージャーのデリゲートプロトコルにどれほど似ているかです。

00:15:45.000 --> 00:15:51.000
先に述べたように、BADownloadManagerを使用して、拡張機能内からデリゲートを構築できます。

00:15:51.000 --> 00:15:55.000
しかし、これらのエントリポイントだけが実際に拡張機能を目覚めさせることができます。

00:15:55.000 --> 00:15:59.000
最初の機能は、アプリケーションが最初にインストールされるたびに呼び出されます。

00:15:59.000 --> 00:16:02.000
アプリはまだ起動していませんが、あなたの拡張機能は起動しています。

00:16:02.000 --> 00:16:09.000
これは、アプリが起動したら、アプリが最高の体験を提供するために必要なダウンロードのスケジューリングを開始する絶好の機会です。

00:16:09.000 --> 00:16:14.000
また、最初のアプリのインストール中に、ダウンロード制限が有効であることを思い出すことも重要です。

00:16:14.000 --> 00:16:22.000
Info.plistで定義したBADownloadRestrictionsキーを参照して、最大許可されたダウンロードサイズと許可されたドメインが何であるかを知る必要があります。

00:16:22.000 --> 00:16:25.000
この次の機能は、App Storeがアプリを更新するたびに呼び出されます。

00:16:25.000 --> 00:16:31.000
ユーザーがアプリスイッチャーでアプリを終了していない限り、新しく更新された拡張機能がスリープし、作業のスケジューリングを開始できます。

00:16:31.000 --> 00:16:40.000
checkForUpdates機能は、拡張機能がシステムによって定期的に起動されるのをサポートしているため、バックグラウンドでダウンロードする必要があるアップデートを確認できます。

00:16:40.000 --> 00:16:44.000
この機能は、ユーザーがアプリを使用する頻度に基づいてシステムによって呼び出されます。

00:16:44.000 --> 00:16:48.000
また、認証チャレンジリクエストへの対応もサポートしています。

00:16:48.000 --> 00:16:53.000
そのため、ダウンロードしているファイルが信頼できるソースから来ていることをよりよく制限し、確認することができます。

00:16:53.000 --> 00:16:57.000
最後に、デリゲートと同様に、ダウンロードが失敗または成功した場合に通知されます。

00:16:57.000 --> 00:17:02.000
バックグラウンドDownloadDidFail関数では、エラーが返されていないことに気付くでしょう。

00:17:02.000 --> 00:17:07.000
エラーは、返されたBADownloadオブジェクト内の変数で、その状態とともに取得できます。

00:17:07.000 --> 00:17:13.000
また、拡張機能がダウンロードをスケジュールしたものでなくても、最後の3つの機能を呼び出すことができることに注意することも重要です。

00:17:13.000 --> 00:17:19.000
アプリがダウンロードをスケジュールしたが、バックグラウンドになっていない場合、拡張機能はダウンロードにサービスを提供することが期待されます。

00:17:19.000 --> 00:17:28.000
アプリとその拡張機能からBADownloaderManagerを使用する方法を理解したので、アプリとその拡張機能の両方が同時に実行されている場合の意味を考え始める必要があります。

00:17:28.000 --> 00:17:35.000
たとえば、システムが拡張機能をウェイクして定期的に更新をチェックする時が来たと判断したとしましょう。

00:17:35.000 --> 00:17:48.000
そしてもちろん、拡張機能はこのチェックを行うためにネットワークにアクセスする必要があるため、BADownloaderManagerを使用して、利用可能な更新されたアセットのリストを提供するカタログまたはその他のタイプのメタデータのダウンロードをスケジュールします。

00:17:48.000 --> 00:17:55.000
たとえば、ファイルが、ダウンロードする必要がある大規模なマルチギガバイトアセットのリストを含む小さな100KBのカタログであるとします。

00:17:55.000 --> 00:18:03.000
拡張機能は、スケジュールされたダウンロードがいつ終了したか、または失敗したかを知る必要があるため、ダウンロードマネージャーにデリゲートを添付します。

00:18:03.000 --> 00:18:14.000
ダウンロードマネージャーのデリゲートは、スケジュールするより大きな資産を決定するために小さなファイルをダウンロードするため、拡張エントリポイントで使用され、拡張エントリポイントがすぐに呼び出されることは保証されません。

00:18:14.000 --> 00:18:18.000
ダウンロードが完了すると、拡張機能はデリゲートを通じてこのメッセージを受信します。

00:18:18.000 --> 00:18:23.000
これで、拡張子はカタログファイルにアクセスでき、ダウンロードしたファイルで何をする予定かを選択する必要があります。

00:18:23.000 --> 00:18:28.000
拡張機能がファイルを読み込んで、カタログのどのアセットをデバイスにダウンロードする必要があるかを判断すると想像できます。

00:18:28.000 --> 00:18:32.000
その後、拡張機能は、これらのより大きな資産のバックグラウンドダウンロードをスケジュールすることができます。

00:18:32.000 --> 00:18:37.000
ダウンロードしたファイルが不要になったので、拡張子はファイルを削除する必要があります。

00:18:37.000 --> 00:18:42.000
これは適切と思われますが、拡張機能の実行中にアプリが起動し、独自のBADownloadManagerを作成するとどうなりますか?

00:18:42.000 --> 00:18:44.000
さて、見てみましょう! !

00:18:44.000 --> 00:18:48.000
アプリは起動し、コンテンツが更新されたかどうかをすぐに知りたがっています。

00:18:48.000 --> 00:18:54.000
おそらく、バージョン番号はアプリグループに保存され、両方ともアセットが最新かどうかを判断するために相談します。

00:18:54.000 --> 00:19:05.000
新しいカタログのダウンロードが終了する前にアプリが起動されたため、マネージャーから現在のダウンロードを取得し、カタログのダウンロードが現在飛行中であることを認識し、デリゲートで完了するのを待ちます。

00:19:05.000 --> 00:19:06.000
しかし、私たちには問題があります。

00:19:06.000 --> 00:19:13.000
拡張機能とアプリの両方が、ダウンロードマネージャーに接続されたそれぞれのデリゲートでダウンロード終了メッセージを受け取ります。

00:19:13.000 --> 00:19:16.000
これは、ダウンロードされているファイルにデータレースがあることを意味します。

00:19:16.000 --> 00:19:21.000
アプリと拡張機能の両方が同時にファイルを読み取り、削除しようとします。これは良くありません。

00:19:21.000 --> 00:19:26.000
これは、アプリまたは拡張機能のいずれかがファイルを読み取ろうとし、欠落している可能性があることを意味します。

00:19:26.000 --> 00:19:33.000
これは、アプリ内の2つのスレッドについて考えるのと同様の方法でアプリと拡張機能について考える必要があることを意味します。

00:19:33.000 --> 00:19:38.000
幸いなことに、バックグラウンドアセットは、アプリとその拡張機能の間で同期する方法を提供します。

00:19:38.000 --> 00:19:39.000
今、それについて話しましょう!

00:19:39.000 --> 00:19:44.000
アプリとその拡張機能の同期は、バックグラウンドアセットで非常に簡単です。

00:19:44.000 --> 00:19:49.000
私たちが現在見ているのは、ダウンロードが完了したときのダウンロードマネージャーのデリゲート機能です。

00:19:49.000 --> 00:19:55.000
アプリまたは拡張機能がアクセスできるファイルへのローカルパスを含むURLが提供されます。

00:19:55.000 --> 00:19:59.000
この例では、このファイルを相互に除外します。

00:19:59.000 --> 00:20:05.000
次に、ダウンロードマネージャーへの参照をつかみ、完了ハンドラを取るwithExclusiveControl関数を使用します。

00:20:05.000 --> 00:20:13.000
完了ハンドラスコープ内で実行されるすべてのコードは、排他的制御を必要とする他の呼び出しと相互に排他的であることが保証されています。

00:20:13.000 --> 00:20:21.000
つまり、アプリが完了ハンドラから戻っていない間に拡張機能がExclusiveControlを呼び出す場合、拡張機能は待機します。

00:20:21.000 --> 00:20:23.000
これは他の方向にも当てはまります。

00:20:23.000 --> 00:20:30.000
拡張機能が最初に排他的な制御を取得した場合、アプリは拡張機能が終了するか、スコープを終了して制御を解放するまで待ちます。

00:20:30.000 --> 00:20:35.000
心に留めておくべき重要なことは、排他的な制御の取得が失敗する可能性があるということです。

00:20:35.000 --> 00:20:40.000
これが発生する可能性は非常に低いですが、その場合は、コードがそれを処理する必要があります。

00:20:40.000 --> 00:20:45.000
関数によって提供されるエラーがnilではないかどうかを確認することで、排他的制御を取得できなかったかどうかを検出できます。

00:20:45.000 --> 00:20:51.000
この時点から、アプリまたは拡張機能がそのコンテキスト内で独占的なアクセスを持っていることが保証されます。

00:20:51.000 --> 00:20:58.000
したがって、以前の例に基づいて、ファイルの内容を読み上げてからクリーンアップすることが完全に有効になりました。

00:20:58.000 --> 00:21:07.000
他のアプリや拡張機能が排他的なコントロールに入る機会を得たとき、あなたがすでにファイルを処理したことを知っていることに注意してください。

00:21:07.000 --> 00:21:12.000
これを達成する1つの方法は、まずファイルが存在するかどうかを確認するか、データベースまたはplistに書き込むことです。

00:21:12.000 --> 00:21:19.000
リマインダーとして、バックグラウンドダウンローダー拡張機能は、アプリの大規模なアセットのダウンロードを収集してスケジュールするためのものです。

00:21:19.000 --> 00:21:24.000
ランタイムは短命なので、拡張機能内で行われる作業は最小限に抑えてください。

00:21:24.000 --> 00:21:30.000
また、拡張機能とアプリを共有アプリグループに配置して、両方が互いにダウンロードしたファイルにアクセスできるようにする必要があります。

00:21:30.000 --> 00:21:34.000
そして最後に、拡張機能はアプリではなくシステムによって仲介されます。

00:21:34.000 --> 00:21:41.000
基本的なバックグラウンドダウンロード拡張機能を開発する方法がわかったので、アプリにバックグラウンドアセットを実装するために必要なものがすべて揃っています。

00:21:41.000 --> 00:21:43.000
では、私たちが学んだことをやり直しましょう。

00:21:43.000 --> 00:21:52.000
ダウンロードマネージャーは、アプリとその拡張機能間のダウンロードを調整してスケジュールするために使用されるため、両方の場所でダウンロードマネージャーを使用する必要があります。

00:21:52.000 --> 00:21:55.000
アプリがフォアグラウンドになくても、拡張機能は実行されます。

00:21:55.000 --> 00:22:01.000
これは、アプリのインストール、更新中、またはシステムによって決定された間隔で定期的に発生する可能性があります。

00:22:01.000 --> 00:22:08.000
アプリが起動され、バックグラウンドでダウンロードされていたコンテンツが待機されている場合は、すぐにそれらのダウンロードをフォアグラウンドに宣伝してください。

00:22:08.000 --> 00:22:11.000
拡張機能は、バックグラウンドでのみダウンロードをスケジュールできます。

00:22:11.000 --> 00:22:17.000
アプリをフォアグラウンドに宣伝することで、コンテンツができるだけ早く届くようにします。

00:22:17.000 --> 00:22:23.000
ダウンロードマネージャーへの排他的なアクセスが必要な場合は、排他的なコントロールAPIを使用してください。

00:22:23.000 --> 00:22:27.000
これにより、アプリまたは拡張機能のみがそのウィンドウ内にランタイムを持つことが保証されます。

00:22:27.000 --> 00:22:34.000
これは非常に便利なので、コンテナにアクセスしたり、ダウンロードを管理したりする際に、アプリをレースする拡張機能について考える必要はありません。

00:22:34.000 --> 00:22:39.000
このプレゼンテーションから取るべきものがあれば、それは待つことが貧弱なアプリ体験をもたらすということです。

00:22:39.000 --> 00:22:45.000
待っているタスクが進行している間にアプリを使用できるようにすることで、待ち時間を最小限に抑えます。

00:22:45.000 --> 00:22:51.000
アプリでの待ち時間を最小限に抑える方法の1つは、新しいバックグラウンドアセットフレームワークと基礎となるバックグラウンドダウンロード拡張機能を採用することです。

00:22:51.000 --> 00:22:57.000
これは、アプリが起動する前に、アプリがすべてのコンテンツの準備ができていることを確認するのに役立ちます。

00:22:57.000 --> 00:23:08.000
また、このプレゼンテーションに組み込まれていない可能性のある追加情報を含むドキュメントも必ず確認してください。拡張機能のテスト方法やエントリーポイントのシミュレーション方法など。

00:23:08.000 --> 00:23:12.000
私たちはあなたとバックグラウンドアセットを共有できることを本当に楽しみにしており、あなたのフィードバックを大切にしています。

00:23:12.000 --> 00:23:17.000
フィードバックアシスタントを使用して、何があなたのために働いているのか、何を改善したいのかをお知らせください。

00:23:17.000 --> 00:23:23.000
これは新しいフレームワークであり、播種中に調整する機会があります。

00:23:23.000 --> 00:23:28.000
私たちは、あなたが面白いと思うかもしれないと思ういくつかの追加のセッションがあり、それらをチェックアウトすることをお勧めします。

00:23:28.000 --> 00:23:33.000
「HTTP3でネットワーキングを加速する」は、バックグラウンドアセットとうまく組み合わせる素晴らしいセッションです。

00:23:33.000 --> 00:23:46.000
また、別のセッションをチェックすることをお勧めします。「オンデマンドリソースの紹介」プレゼンテーションでは、コンテンツがAppleによってホストされ、リクエストに応じてファイルがダウンロードされるバックグラウンドアセットの代替手段について説明します。

00:23:46.000 --> 00:23:49.000
これらのセッションは両方とも本当に魅力的で、提供できるものがたくさんあります。

00:23:49.000 --> 00:23:55.000
私と一緒に時間を過ごしてくれてありがとう、そしてアップルのみんなを代表して、あなたが素晴らしいWWDCを過ごせることを願っています!

00:23:55.000 --> 23:59:59.000
♪

