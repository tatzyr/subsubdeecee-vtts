WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:15.000
キアラ・ローズ：こんにちは、私の名前はキアラ・ローズで、Safari拡張エンジニアとして働いています。

00:00:15.000 --> 00:00:22.000
今日は、今年のSafari Web拡張機能の新機能について皆さんにお話しできることをとても楽しみにしています。

00:00:22.000 --> 00:00:33.000
今日のプレゼンテーションに飛び込む前に、iOS、iPadOS、macOSの拡張機能をApp Storeに提出してくれた皆さんに感謝したいと思います。

00:00:33.000 --> 00:00:42.000
今後、私たちの目標は、ユーザーにさらに優れた体験を提供できるように、新しい機能とAPIを実装し続けることです。

00:00:42.000 --> 00:00:58.000
そして今日は、拡張機能の新しいマニフェストバージョン、更新されたAPI、複数のデバイス間での拡張機能の同期など、過去1年間に実装したエキサイティングな新機能のいくつかを強調します。

00:00:58.000 --> 00:01:02.000
マニフェストバージョン3から始めましょう。

00:01:02.000 --> 00:01:06.000
マニフェストバージョン3は、ウェブ拡張プラットフォームの次のイテレーションです。

00:01:06.000 --> 00:01:13.000
パフォーマンスとセキュリティの改善を導入し、一般的な拡張APIを統合します。

00:01:13.000 --> 00:01:23.000
すでにバージョン3を使用するように拡張機能を更新している人のために、拡張機能はSafari 15.4以降で動作します。

00:01:23.000 --> 00:01:32.000
まだ持っていない人のために、Safariでマニフェストバージョン2を使用して拡張機能をサポートし続けるので、心配する必要はありません。

00:01:32.000 --> 00:01:39.000
マニフェストバージョン3の主な新機能の1つは、拡張機能がバックグラウンドページの代わりにサービスワーカーを使用できることです。

00:01:39.000 --> 00:01:43.000
あなたがウェブ開発者なら、おそらくサービスワーカーに精通しているでしょう。

00:01:43.000 --> 00:01:50.000
これらは、addEventListener APIを使用してリスナーを登録できるイベント駆動型ページです。

00:01:50.000 --> 00:01:55.000
これらのページは、マニフェストバージョン3をサポートする他のブラウザとも互換性があります。

00:01:55.000 --> 00:02:03.000
拡張機能にバックグラウンドページを使用し続けることを好む場合は、大歓迎ですが、非永続的でなければなりません。

00:02:03.000 --> 00:02:15.000
バージョン3のもう1つの改善点は、WebページでJavaScriptとスタイリングを実行するためのAPIがタブAPIから新しいスクリプトAPIに移行したことです。

00:02:15.000 --> 00:02:36.000
これらのメソッドの機能のほとんどは同じままですが、Webページにコードを注入する新しい方法、ページ上のどのフレームでコードを実行するかのより多くのオプション、コードを実行するかを決定する機能など、スクリプトが提供するいくつかの新しい追加機能があります。

00:02:36.000 --> 00:02:42.000
新しいスクリプトAPIのコードがタブAPIとどのように異なるかを見てみましょう。

00:02:42.000 --> 00:02:51.000
このコードスニペットでは、tabs.executeScript APIを使用して、ウェブページの背景色を青に変更しています。

00:02:51.000 --> 00:03:05.000
そして、このAPIでは、「コード」プロパティを渡すことによってのみ、文字列に含まれるコードを注入できますが、新しいスクリプトAPIを使用すると、このコードを含む関数オブジェクトを渡すことができます。

00:03:05.000 --> 00:03:10.000
そして、他の関数と同様に、渡すことができる引数を含めることができます。

00:03:10.000 --> 00:03:17.000
これは、文字列でコードを書くことに限定されないため、スクリプトを実行するはるかに改善された方法です。

00:03:17.000 --> 00:03:22.000
また、スクリプティングでは、ターゲットと呼ばれる新しいプロパティがあることに注意してください。

00:03:22.000 --> 00:03:26.000
このプロパティは、スクリプトを実行する場所を指定するために使用されます。

00:03:26.000 --> 00:03:33.000
スクリプトを実行するには、スクリプトを実行するタブのIDを指定する必要があります。

00:03:33.000 --> 00:03:37.000
タブIDが指定されていない場合、このAPIはエラーを返します。

00:03:37.000 --> 00:03:45.000
次に、コードを注入するウェブページのどのフレームを選択するかを選択したい場合は、フレームIDを指定できます。

00:03:45.000 --> 00:03:50.000
タブAPIでは、IDを1つしか指定できないことに注意してください。

00:03:50.000 --> 00:03:55.000
しかし、スクリプトでは、複数のIDを指定できます。

00:03:55.000 --> 00:04:02.000
しかし、私はもっと多くのコードを持っていて、それを複数のファイルに含めることができれば、はるかにきれいに見えるとしましょう。

00:04:02.000 --> 00:04:13.000
tabs.executeScript APIでは1つのファイルしか指定できませんが、scripting.executeScriptでは複数のファイルを指定できます。

00:04:13.000 --> 00:04:26.000
同様に、ウェブページにスタイリングを注入できるinsertCSSでも同じことができ、ウェブページから注入されたスタイリングを削除できるremoveCSSでも同じことができます。

00:04:26.000 --> 00:04:31.000
これらのAPIは、マニフェストバージョン2と3の両方で使用できます。

00:04:31.000 --> 00:04:37.000
ただし、tabs.executeScript APIはバージョン3では利用できません。

00:04:37.000 --> 00:04:43.000
新しいスクリプトAPIに加えて、他のいくつかのAPIにもわずかな変更がありました。

00:04:43.000 --> 00:04:48.000
これらの変更の1つは、web_accessible_resources用です。

00:04:48.000 --> 00:04:58.000
マニフェストバージョン2では、リソースを含める場合は、Webページにアクセスしたいファイルの配列を渡すことでそうします。

00:04:58.000 --> 00:05:07.000
しかし、マニフェストで指定したすべてのリソースにウェブページにアクセスできるため、これは問題になる可能性があります。

00:05:07.000 --> 00:05:14.000
バージョン3の新しいフォーマットでは、特定のサイトで利用可能なリソースを制御できます。

00:05:14.000 --> 00:05:17.000
例を見てみましょう。 例を見てみましょう。

00:05:17.000 --> 00:05:23.000
以前は、クッキーとパイの画像は、拡張機能がアクセスできるすべてのサイトで利用可能でした。

00:05:23.000 --> 00:05:34.000
しかし今、バージョン3では、パイ画像はapple.comのURLでのみ利用可能になり、クッキー画像はwebkit.orgページでのみ利用可能になります。

00:05:34.000 --> 00:05:41.000
それでは、browser_actionとpage_action APIの変更を見てみましょう。

00:05:41.000 --> 00:05:46.000
マニフェストバージョン2では、アクションはこのように明確に指定されました。

00:05:46.000 --> 00:05:56.000
しかし、これらのAPIは同様の役割を果たすため、バージョン3では1つのAPIのみを使用するように統合されています。これはアクションです。

00:05:56.000 --> 00:06:01.000
また、拡張機能のコンテンツセキュリティポリシーを宣言する方法も更新しました。

00:06:01.000 --> 00:06:06.000
バージョン2では、拡張機能のポリシーが文字列を使用して定義されました。

00:06:06.000 --> 00:06:15.000
ただし、バージョン3では、ポリシーはキー「extension_pages」を持つオブジェクトを使用して定義されています。

00:06:15.000 --> 00:06:21.000
スクリプトのリモートソースは、バージョン3では許可されなくなったことに注意することが重要です。

00:06:21.000 --> 00:06:28.000
最終的なAPIの変更は、非推奨のbrowser.extension.getURL APIでした。

00:06:28.000 --> 00:06:31.000
このAPIはバージョン3ではサポートされなくなりました。

00:06:31.000 --> 00:06:35.000
代わりに、browser.runtimeで同等のAPIを使用してください。

00:06:35.000 --> 00:06:47.000
そこで、マニフェストバージョン3で導入された新機能について話しました。では、これらの新機能を使用できるように、拡張機能を更新するプロセスを進めましょう。

00:06:47.000 --> 00:06:54.000
昨年のプレゼンテーションからSea Creatorの拡張機能を更新して、マニフェストバージョン3を使用します。

00:06:54.000 --> 00:07:00.000
この拡張機能は、魚という単語のすべての出現を絵文字に置き換えます。

00:07:00.000 --> 00:07:06.000
最初に行うことは、バージョン番号を2から3に変更することです。

00:07:06.000 --> 00:07:19.000
また、バージョン3の非永続的な背景ページはまだ使用できますが、拡張機能がChromeと互換性があるように、これをサービスワーカーを使用するように更新します。

00:07:19.000 --> 00:07:25.000
最後に、browser_actionをactionに変更します。

00:07:25.000 --> 00:07:34.000
そして、マニフェストの構造の面では、この拡張機能がバージョン3の新しい仕様と互換性を持たせるために私が行う必要がある重要な変更です。

00:07:34.000 --> 00:07:47.000
だから、これをテストするために、拡張機能を構築し、Safariで有効にします。

00:07:47.000 --> 00:07:59.000
次に、webkit.orgのブログページに移動し、この拡張機能を使用して、魚という言葉のすべてのインスタンスを魚の絵文字に置き換えます。

00:07:59.000 --> 00:08:01.000
しかし、何かがうまくいかなかったようです。

00:08:01.000 --> 00:08:05.000
ご覧のとおり、このページの単語はどれも絵文字に置き換えられていません。

00:08:05.000 --> 00:08:15.000
ポップオーバーを調べて、エラーメッセージがないか確認しましょう。

00:08:15.000 --> 00:08:22.000
コンソールタブには、browser.tabs.executeScriptが未定義であるというエラーメッセージが表示されていることがわかります。

00:08:22.000 --> 00:08:31.000
これは、このAPIがバージョン3では利用できなくなったため、代わりに新しいスクリプトAPIを使用するように拡張機能を更新する必要があります。

00:08:31.000 --> 00:08:42.000
Xcodeでは、popup.jsファイルに戻り、代わりにスクリプトを使用するようにこの行を変更します。

00:08:42.000 --> 00:08:50.000
スクリプトをどこに注入するかを指定するために使用されるターゲットプロパティを追加します。

00:08:50.000 --> 00:08:54.000
また、新しいスクリプトAPIでは、タブのIDを指定する必要があります。

00:08:54.000 --> 00:09:08.000
tabs.getCurrent APIを使用して、現在のタブの情報を含むオブジェクトを取得することで、これを行うことができます。

00:09:08.000 --> 00:09:15.000
その後、そのオブジェクトを使用してタブIDを取得できます。

00:09:15.000 --> 00:09:21.000
次に、実行するスクリプトを含むファイルを追加します。

00:09:21.000 --> 00:09:29.000
最後に、私が行う最後の変更は、マニフェストにスクリプト権限を追加することです。

00:09:29.000 --> 00:09:38.000
先に進んで拡張機能を構築し、これらの変更をSafariで使用します。

00:09:38.000 --> 00:09:44.000
ご覧のとおり、この拡張機能は、マニフェストバージョン3の新機能を使用して、Safariで動作します。

00:09:44.000 --> 00:09:47.000
だから、拡張機能をアップグレードするのは簡単です。

00:09:47.000 --> 00:09:56.000
しかし、これらの新しい変更にまだ慣れていない場合は、スクリプトやサービスワーカーなどの多くの機能もバージョン2で使用できます。

00:09:56.000 --> 00:10:03.000
それでは、宣言的なネットリクエストから始めて、今年更新したAPIのいくつかを見てみましょう。

00:10:03.000 --> 00:10:15.000
宣言的なネットリクエストは、ルールセットを使用してネットワークリクエストをブロックまたは変更するための高速でプライバシーを保護する方法をWeb拡張機能に提供するコンテンツブロックAPIです。

00:10:15.000 --> 00:10:26.000
このAPIを使用すると、リクエストの傍受と変更のすべての作業をSafariに委任することができ、あなたがしなければならないのは、適用すべきコンテンツブロックルールを指定することだけです。

00:10:26.000 --> 00:10:30.000
マニフェストでルールセットを指定できます。

00:10:30.000 --> 00:10:40.000
ここでは、宣言的なネットリクエスト許可を追加し、declarative_net_requestキーを使用して、すべてのページに適用されるルールセットを1つ追加しました。

00:10:40.000 --> 00:10:45.000
以前は、マニフェストで最大10のルールセットしか宣言できませんでした。

00:10:45.000 --> 00:10:54.000
しかし、この機能の新しいアップデートにより、最大50のルールセットを宣言できます。つまり、拡張機能をよりカスタマイズ可能にすることができます。

00:10:54.000 --> 00:10:59.000
しかし、これらのルールセットのうち、一度に有効にできるのは10個しかないことを覚えておいてください。

00:10:59.000 --> 00:11:09.000
ルールセットの作成方法の詳細については、昨年のSafari Web Extensionsのプレゼンテーションをご覧ください。このAPIについて詳しく説明します。

00:11:09.000 --> 00:11:13.000
宣言的なネットリクエストの新機能のいくつかに移りましょう。

00:11:13.000 --> 00:11:25.000
以前は、マニフェストでルールセットを宣言することしかできませんでしたが、ルールを動的に更新できる次の2つのAPIを実装しました。

00:11:25.000 --> 00:11:31.000
最初のAPIはupdateSessionRulesで、拡張機能のルールを追加または削除できます。

00:11:31.000 --> 00:11:39.000
しかし、これらのルールはブラウザのセッションや拡張機能の更新では持続しないことに注意することが重要です。

00:11:39.000 --> 00:11:45.000
持続するルールを更新したい場合は、代わりにupdateDynamicRules APIを使用してください。

00:11:45.000 --> 00:11:50.000
これにより、拡張機能全体を更新せずにブロックルールを更新できます。

00:11:50.000 --> 00:11:57.000
これらのAPIの1つを使用してルールセットを変更する方法を見てみましょう。 ルールセットの変更方法を見てみましょう。

00:11:57.000 --> 00:12:06.000
シークリエイター拡張機能を使用してウェブページ上のコンテンツをブロックし、新しいAPIを使用して選択したページのコンテンツのブロックを解除します。

00:12:06.000 --> 00:12:15.000
拡張マニフェストで、私が最初に行うことは、宣言的なネットリクエスト許可を追加することです。

00:12:15.000 --> 00:12:24.000
次に、宣言的なネットリクエストキーを使用してルールセットを追加します。

00:12:24.000 --> 00:12:30.000
適用されているルールは、rules.jsonファイルにあります。

00:12:30.000 --> 00:12:36.000
このファイルでは、すべてのURL上のすべての画像をブロックする1つのルールを宣言しました。

00:12:36.000 --> 00:12:43.000
拡張機能を構築し、このルールがSafariでどのように適用されるかを見てみましょう。

00:12:43.000 --> 00:12:47.000
ご覧のとおり、このページの画像は消えました。

00:12:47.000 --> 00:12:49.000
それはまさに私たちが期待していたことです。

00:12:49.000 --> 00:12:54.000
これは、Safariがコンテンツブロックルールを正常に適用したことを示しています。

00:12:54.000 --> 00:13:01.000
そして、魚に関するこのウィキペディアのページに移動すると、このサイトの画像もブロックされていることがわかります。

00:13:01.000 --> 00:13:09.000
しかし、webkit.orgのブログページを期待しているすべてのページの画像をブロックするようにルールを更新したいとしましょう。

00:13:09.000 --> 00:13:16.000
宣言的なネットリクエストに更新されたAPIの1つを使用して、それを行うことができます。

00:13:16.000 --> 00:13:20.000
Xcodeに戻って、いくつかの変更を加えましょう。

00:13:20.000 --> 00:13:28.000
Popup.jsファイルで、コンテンツブロックルールを更新する関数を宣言します。

00:13:28.000 --> 00:13:33.000
Webkit.org/blog-filesページの画像を許可するルールを設定します。

00:13:33.000 --> 00:13:40.000
次に、updateSessionRules APIを使用して、このルールをルールセットに追加します。

00:13:40.000 --> 00:13:48.000
最後に、拡張機能を構築し、Safariで変更をテストします。

00:13:48.000 --> 00:13:56.000
ご覧のとおり、このブログ記事の画像が読み込まれ、このサイトの画像を許可する新しいルールが機能していることを示しています。

00:13:56.000 --> 00:14:05.000
そして、ウィキペディアのサイトに行くと、このページの画像がまだブロックされていることがわかります。これは、新しいルールがこのページに適用されていないことを示しています。

00:14:05.000 --> 00:14:12.000
そのため、新しい宣言型ネットリクエストAPIを使用して、コンテンツブロックルールを更新できます。

00:14:12.000 --> 00:14:17.000
それでは、拡張機能がウェブページと通信する方法を見てみましょう。

00:14:17.000 --> 00:14:24.000
この素晴らしい機能により、ユーザーが拡張機能を有効にしている場合、ウェブサイトはカスタム動作を作成できます。

00:14:24.000 --> 00:14:28.000
APIはexternally_connectableと呼ばれます。

00:14:28.000 --> 00:14:32.000
それを使用するには、マニフェストでマッチパターンを宣言します。

00:14:32.000 --> 00:14:39.000
これらのマッチパターンは、どのページが拡張機能と通信できるかを決定します。

00:14:39.000 --> 00:14:46.000
そして、注意すべき重要なことは、この機能はブラウザの名前空間でのみ機能するということです。

00:14:46.000 --> 00:14:54.000
そして最後に、ユーザーはメッセージを送受信する前に、拡張機能にページへのアクセスを許可する必要があります。

00:14:54.000 --> 00:14:59.000
この機能を使用するために、ウェブページに追加するコードを見てみましょう。 

00:14:59.000 --> 00:15:02.000
まず、extensionIDを取得する必要があります。

00:15:02.000 --> 00:15:08.000
これは、この形式の拡張機能とチーム識別子のバンドル識別子です。

00:15:08.000 --> 00:15:15.000
チーム識別子は、developer.apple.comのアカウント設定のメンバーシップタブで確認できます。

00:15:15.000 --> 00:15:21.000
次に、送信メッセージAPIを使用して、拡張機能にメッセージを投稿します。

00:15:21.000 --> 00:15:27.000
関数を渡すことで、拡張機能から受け取る応答を処理できます。

00:15:27.000 --> 00:15:32.000
それでは、拡張機能がメッセージを受信しなければならないコードを見てみましょう。

00:15:32.000 --> 00:15:38.000
拡張機能は、onMessageExternalと呼ばれるイベントをリッスンすることで、ウェブページからメッセージを受信できます。

00:15:38.000 --> 00:15:45.000
拡張機能は、イベントリスナーに渡されたメソッドを使用して、Webページにメッセージを送り返すことができます。

00:15:45.000 --> 00:15:52.000
ブラウザごとに異なる拡張ウェブストアがあるため、拡張機能は多くの異なる識別子を持つことができます。

00:15:52.000 --> 00:16:01.000
したがって、ChromeやEdgeの拡張機能ではなく、SafariのWeb拡張機能にメッセージを送信していることを確認するために、使用する正しいものを決定する必要があります。

00:16:01.000 --> 00:16:10.000
これを行うには、Promise.allを呼び出すとbrowser.runtime.sendMessage APIを使用できます。

00:16:10.000 --> 00:16:16.000
次に、これを行うのに役立つコードの例を見てみましょう。 これを行うのに役立つコードの例を見てみましょう。

00:16:16.000 --> 00:16:21.000
ウェブページから、複数の拡張IDを使用して複数のメッセージをブロードキャストできます。

00:16:21.000 --> 00:16:30.000
拡張機能から正確に1つの応答が得られ、さらなる通信に使用する拡張機能IDがわかります。

00:16:30.000 --> 00:16:36.000
ここには、rea determineExtensionIDという関数があります。

00:16:36.000 --> 00:16:43.000
この関数は、browser.runtime.sendMessage APIを使用して拡張機能にメッセージを送信します。

00:16:43.000 --> 00:16:55.000
複数のIDがあり、使用する正しいIDを決定したい場合は、Promise.allを使用して、 determineExtensionID関数を使用して複数の呼び出しを行うことができます。

00:16:55.000 --> 00:17:03.000
Promise.allは約束の配列を受け取り、解決されたすべての値の配列を持つ単一の約束を返します。

00:17:03.000 --> 00:17:08.000
この配列を使用して、ユーザーがインストールした拡張機能を見つけることができます。

00:17:08.000 --> 00:17:14.000
拡張機能のバックグラウンドページでは、ウェブページからのメッセージを聞く必要があります。

00:17:14.000 --> 00:17:20.000
メッセージを受信したら、拡張機能がインストールされていることをウェブページに伝えるために1つを送り返す必要があります。

00:17:20.000 --> 00:17:28.000
これが、新しいexternally_connectable APIを使用して、拡張機能がWebページと通信できるようにする方法です。

00:17:28.000 --> 00:17:33.000
私たちが更新した次の機能は、私の個人的なお気に入りであり、それはunlimitedStorageです。

00:17:33.000 --> 00:17:37.000
そして、unlimitedStorageが実際に無制限であることを発表できることをとても嬉しく思います!

00:17:37.000 --> 00:17:46.000
この機能があなたによって非常に強く要求されたことを考えると、私たちはあなたの拡張機能がもはや10 MBのクォータを持っていないことを共有することに興奮しています。

00:17:46.000 --> 00:17:50.000
必要に応じて、できるだけ多くのデータを自由に使用できます。

00:17:50.000 --> 00:17:59.000
ただし、ユーザーはいつでも拡張機能で使用されているデータを消去できることに注意することが重要です。

00:17:59.000 --> 00:18:06.000
したがって、ユーザーがデータを消去する気がしないように、厳密に必要なデータのみを保存してください。

00:18:06.000 --> 00:18:14.000
この機能を使用するには、マニフェストでストレージとunlimitedStorageの許可を請求するだけで、大丈夫です。

00:18:14.000 --> 00:18:19.000
これらは、昨年ウェブ拡張機能用に更新したすべてのAPIでした。

00:18:19.000 --> 00:18:27.000
最後に、ユーザーがすべてのデバイスで拡張機能を簡単に取得できる新機能について話しましょう。

00:18:27.000 --> 00:18:33.000
Safari 16では、拡張機能の使用体験をよりシームレスにしました。

00:18:33.000 --> 00:18:40.000
ユーザーが自分のデバイスの1つで拡張機能をオンにすると、すべてのデバイスでオンになります。

00:18:40.000 --> 00:18:46.000
これに加えて、拡張機能をダウンロードするプロセスをはるかに簡単にしました。

00:18:46.000 --> 00:18:49.000
これがどのように機能するかを見てみましょう。

00:18:49.000 --> 00:18:53.000
ユーザーがMacで拡張機能の1つを有効にしているとしましょう。

00:18:53.000 --> 00:19:00.000
他のデバイスの拡張機能設定では、拡張機能をダウンロードするオプションが与えられます。

00:19:00.000 --> 00:19:07.000
ダウンロードされると、デバイスで自動的に有効になり、ユーザーエクスペリエンスが向上します。

00:19:07.000 --> 00:19:13.000
では、ウェブ拡張機能やコンテンツブロッカーにこれを設定する方法に飛び込みましょう。

00:19:13.000 --> 00:19:22.000
まず、App Storeに提出する際に、iOS、iPadOS、macOSの拡張機能をリストアップすることをお勧めします。

00:19:22.000 --> 00:19:28.000
このようにして、拡張機能はすべてのユーザーのデバイスで利用できるようになります。

00:19:28.000 --> 00:19:35.000
次に、拡張機能がデバイス間で同期できるようにするには、次の2つの方法のいずれかを使用する必要があります。

00:19:35.000 --> 00:19:41.000
最も簡単で推奨される方法は、ユニバーサル購入を採用することです。

00:19:41.000 --> 00:19:49.000
ユニバーサル購入により、ユーザーは一度だけ購入することで、すべてのプラットフォームで拡張機能を楽しむことができます。

00:19:49.000 --> 00:19:52.000
この方法を使用すると、すべて設定できます。

00:19:52.000 --> 00:19:59.000
ユーザーは、拡張機能を一度ダウンロードした後、私が示したすべての機能を取得します。

00:19:59.000 --> 00:20:11.000
ユニバーサル購入を設定するには、App Store Connectで同じアプリレコードに関連付けることができるように、拡張機能全体で単一のバンドル識別子を使用する必要があります。

00:20:11.000 --> 00:20:19.000
これを行う方法の詳細については、拡張機能のユニバーサル購入を設定する方法に関するドキュメントをご覧ください。

00:20:19.000 --> 00:20:24.000
しかし、ユニバーサル購入を設定しないことを選択した場合は、アプリを手動でリンクすることができます。

00:20:24.000 --> 00:20:32.000
これを行うには、Xcodeを使用して、同期したいアプリや拡張機能の情報plistにバンドル識別子を追加します。

00:20:32.000 --> 00:20:40.000
iOSアプリと拡張機能をmacOSのものと同期するには、情報plistで特定のキーを使用する必要があります。

00:20:40.000 --> 00:20:48.000
このキーはmacOSアプリのplistに、このキーはmacOS拡張機能のplistに入力します。

00:20:48.000 --> 00:20:53.000
同様に、macOSアプリを同期するために同じプロセスに従います。

00:20:53.000 --> 00:21:01.000
このキーをiOSアプリplistに追加し、このキーをiOS拡張plistに追加します。

00:21:01.000 --> 00:21:04.000
これがXcodeでどのように機能するか見てみましょう。

00:21:04.000 --> 00:21:14.000
Xcodeでは、最初に行う必要があるのは、各ターゲットの設定を更新して、同期したい拡張機能とアプリのバンドル識別子を含めることです。

00:21:14.000 --> 00:21:24.000
まず、対応するmacOSアプリのバンドル識別子をiOSアプリの情報plistに追加します。

00:21:24.000 --> 00:21:31.000
そして、ご覧のとおり、iOSアプリのバンドル識別子を追加することで、macOSアプリにも同じプロセスを実行しました。

00:21:31.000 --> 00:21:37.000
そして、macOS拡張機能バンドル識別子を追加することで、iOS拡張機能も同様です。

00:21:37.000 --> 00:21:43.000
そして最後に、iOS拡張機能バンドル識別子を追加して、macOS拡張機能について。

00:21:43.000 --> 00:21:50.000
そして、ユーザーがどこでも使用できるように、アプリと拡張機能をリンクするのがいかに簡単かです。

00:21:50.000 --> 00:22:04.000
要約すると、ユニバーサル購入を設定するか、Xcodeで各iOSおよびmacOSアプリと拡張機能のバンドル識別子を追加することで、ユーザーがこの機能を利用できるようにすることができます。

00:22:04.000 --> 00:22:14.000
今日は、マニフェストバージョン3、更新したAPI、および複数のデバイス間での拡張機能の同期について議論しました。

00:22:14.000 --> 00:22:20.000
Safari Web拡張機能のこれらすべての新機能について、あなたが私と同じくらい興奮していることを願っています。

00:22:20.000 --> 00:22:28.000
今日のセッションのコードを含むサンプルプロジェクトを自由にダウンロードして、私たちが紹介したAPIのいくつかで遊んでください。

00:22:28.000 --> 00:22:30.000
次に、あなたの考えを知りたいです。

00:22:30.000 --> 00:22:40.000
フィードバックアシスタントを使用してバグを提出したり、Safari開発者フォーラムで私たちとチャットしたりして、拡張機能の開発をより良くする方法についてのフィードバックを提供します。

00:22:40.000 --> 00:22:43.000
いいえ、本当に。私たちはあなたがどう思うか知りたいです!

00:22:43.000 --> 00:22:49.000
Web拡張機能の未来を形作るために、WebExtensionsコミュニティグループへの参加を検討してください。

00:22:49.000 --> 00:22:55.000
最後に、ウェブインスペクタ拡張機能の作成に関するWWDCプレゼンテーションをチェックしてください。

00:22:55.000 --> 23:59:59.000
このセッションにチューニングしてくれてありがとう、そしてWWDCの素晴らしい残りをお過ごしください。

