WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:13.000
Ahmed: こんにちは、私の名前はAhmedで、ClangとSwiftのコンパイラに取り組んでいます。

00:00:13.000 --> 00:00:25.000
このセッションでは、アプリのサイズとランタイムのパフォーマンスを向上させるために、一般的なSwiftとObjective-Cの操作をより迅速かつ効率的にするために行った変更を深く掘り下げます。

00:00:25.000 --> 00:00:30.000
SwiftまたはObjective-Cでコードを書くとき、あなたは常に2つの主要なコンポーネントと本当に相互作用しています。

00:00:30.000 --> 00:00:35.000
まず、Xcodeを使用してビルドし、SwiftとClangのコンパイラを使用します。

00:00:35.000 --> 00:00:41.000
しかし、アプリを実行すると、多くの重い作業がSwiftとObjective-Cランタイムで行われます。

00:00:41.000 --> 00:00:45.000
ランタイムは、すべてのプラットフォームのオペレーティングシステムに組み込まれています。

00:00:45.000 --> 00:00:50.000
コンパイラがビルド時にできないことは、ランタイムは実行時に行います。

00:00:50.000 --> 00:00:54.000
コンパイラとランタイムの両方で行ったいくつかの改善を見ていきます。

00:00:54.000 --> 00:01:00.000
さて、このセッションは少し珍しいです。新しいAPI、言語の変更、または新しいビルド設定はありません。

00:01:00.000 --> 00:01:05.000
コードを変更する必要がないので、これらの改善はすべて開発者にとって透明です。

00:01:05.000 --> 00:01:06.000
飛び込みましょう。

00:01:06.000 --> 00:01:08.000
4つの改善点を見ていきます。

00:01:08.000 --> 00:01:21.000
Swiftでのプロトコルチェックをより効率的にし、Objective-Cのメッセージ送信コールを小さくし、最後に自動リリースの省略をより速く、より小さくしました。

00:01:21.000 --> 00:01:23.000
詳しく見てみましょう。 

00:01:23.000 --> 00:01:27.000
Swiftのプロトコルチェックから始めましょう。

00:01:27.000 --> 00:01:30.000
ここにはCustomLoggableプロトコルがあります。

00:01:30.000 --> 00:01:38.000
読み取り専用の計算プロパティcustomLogStringがあり、CustomLoggableオブジェクトの特別な処理を持つログ関数で使用できます。

00:01:38.000 --> 00:01:42.000
後で、名前と日付のフィールドを持つイベントタイプを定義します。

00:01:42.000 --> 00:01:49.000
また、customLogStringプロパティのゲッターを定義することで、CustomLoggableプロトコルに準拠しています。

00:01:49.000 --> 00:01:53.000
これにより、イベントオブジェクトを「ログ」関数に渡すことができます。

00:01:53.000 --> 00:01:59.000
このコードを実行するとき、「log」関数は、渡した値がプロトコルに準拠しているかどうかを確認する必要があります。

00:01:59.000 --> 00:02:05.000
そして、それは「as」演算子を使用してそれを行います。「Is」演算子も見たことがあるかもしれません。

00:02:05.000 --> 00:02:09.000
可能な限り、このチェックはビルド時にコンパイラで最適化されます。

00:02:09.000 --> 00:02:13.000
しかし、私たちはまだ常に十分な情報を持っているわけではありません。

00:02:13.000 --> 00:02:20.000
したがって、これは多くの場合、以前に計算したプロトコルチェックメタデータの助けを借りて、ランタイムで起こる必要があります。

00:02:20.000 --> 00:02:29.000
このメタデータを使用すると、ランタイムはこの特定のオブジェクトが本当にプロトコルに準拠しているかどうかを知り、チェックは成功します。

00:02:29.000 --> 00:02:36.000
メタデータの一部はコンパイル時に構築されますが、特にジェネリックを使用する場合は、起動時にのみ多くを構築できます。

00:02:36.000 --> 00:02:40.000
多くのプロトコルを使用すると、これは最大数百ミリ秒になる可能性があります。

00:02:40.000 --> 00:02:45.000
現実世界のアプリでは、これが打ち上げ時間の最大半分かかるのを見てきました。

00:02:45.000 --> 00:02:54.000
新しいSwiftランタイムでは、アプリの実行可能ファイルと起動時に使用するdylibのdyldクロージャの一部として、これらを事前に事前計算します。

00:02:54.000 --> 00:03:01.000
何よりも、これはiOS 16、tvOS 16、またはwatchOS 9で実行している既存のアプリでも有効になります。

00:03:01.000 --> 00:03:07.000
dyldとローンチの閉鎖についてもっと知りたい場合は、トーク「App Startup Time: Past, Present, and Future」をご覧ください。

00:03:07.000 --> 00:03:10.000
それはSwiftのプロトコルチェックでした。

00:03:10.000 --> 00:03:14.000
メッセージの送信に移りましょう。

00:03:14.000 --> 00:03:22.000
Xcode 14の新しいコンパイラとリンカーにより、ARM64では12バイトから最大8バイト小さくなりました。

00:03:22.000 --> 00:03:30.000
すぐにわかるように、メッセージ送信は本当にどこにでもあるので、これは加算され、バイナリのコードサイズが最大2%改善されました。

00:03:30.000 --> 00:03:38.000
これは、古いOSリリースをデプロイターゲットとして使用している場合でも、Xcode 14でビルドするときに自動的に有効になります。

00:03:38.000 --> 00:03:46.000
デフォルトはサイズの勝利とパフォーマンスのバランスですが、objc_stubs_smallリンカーフラグを使用して、サイズのみの最適化を選択できます。

00:03:46.000 --> 00:03:49.000
では、何が変わったのかを見てみましょう。

00:03:49.000 --> 00:03:50.000
では、例から始めましょう。

00:03:50.000 --> 00:03:54.000
ここでは、会議の開始日にNSDateを作成しようとしています。

00:03:54.000 --> 00:04:01.000
まず、NSCalendarを作成し、NSDateComponentsに記入し、そこから日付を作成し、最後に返します。

00:04:01.000 --> 00:04:05.000
では、コンパイラが生成するアセンブリを見てみましょう。

00:04:05.000 --> 00:04:07.000
さて、アセンブリの詳細はそれほど重要ではありません。

00:04:07.000 --> 00:04:11.000
私たちコンパイラの人々は、あなたがする必要がないように、一日中それを見つめています。

00:04:11.000 --> 00:04:21.000
重要なのは、ここでのほぼすべての行が、日付コンポーネントのようにプロパティアクセスを行う場合でも、objc_msgSendを呼び出す命令を必要とすることです。

00:04:21.000 --> 00:04:26.000
これは、コンパイル時にどのメソッドを呼び出すべきかわからないためであり、objcランタイムのみが呼び出すためです。

00:04:26.000 --> 00:04:32.000
そこで、objc_msgSendを使用してランタイムを呼び出して、正しいメソッドを見つけるように依頼します。

00:04:32.000 --> 00:04:34.000
これらの呼び出しの1つに集中しましょう。

00:04:34.000 --> 00:04:37.000
objc_msgSendを呼び出す指示についてはすでに言及しました。

00:04:37.000 --> 00:04:38.000
しかし、もっとあります。

00:04:38.000 --> 00:04:44.000
どのメソッドを呼び出すかをランタイムに伝えるには、これらのobjc_msgSend呼び出しにセレクタを渡す必要があります。

00:04:44.000 --> 00:04:48.000
セレクターを準備するには、さらにいくつかの指示が必要です。

00:04:48.000 --> 00:04:52.000
バイナリを見ると、これらの指示のそれぞれに少しスペースがかかります。

00:04:52.000 --> 00:04:55.000
ARM64では、それぞれ4バイトです。

00:04:55.000 --> 00:05:04.000
したがって、これらのobjc_msgSend呼び出しごとに、12バイトを使用しており、これらの呼び出しごとにそれが必要です。それは本当に加算されます。

00:05:04.000 --> 00:05:08.000
それを改善するために何ができるか見てみましょう。 

00:05:08.000 --> 00:05:13.000
さて、前に見たように、これらのバイトのうち8バイトはセレクタの準備に専念しています。

00:05:13.000 --> 00:05:17.000
興味深いことに、どのセレクタでも、それは常に同じコードです。

00:05:17.000 --> 00:05:21.000
そして、これが私たちの最適化の出番です。

00:05:21.000 --> 00:05:27.000
これは常に同じコードであるため、共有でき、メッセージを送信するたびにではなく、セレクタごとに1回しか発行できません。

00:05:27.000 --> 00:05:33.000
私たちはそれを取り出して、小さなヘルパー関数に入れて、代わりにその関数を呼び出すことができます。

00:05:33.000 --> 00:05:38.000
同じセレクタを使用して多くの呼び出しで、これらすべての命令バイトを保存できます。

00:05:38.000 --> 00:05:42.000
私たちはこのヘルパー関数を「セレクタースタブ」と呼んでいます。

00:05:42.000 --> 00:05:47.000
しかし、私たちはまだ実際のobjc_msgSend関数を呼び出す必要があるので、それを続けます。

00:05:47.000 --> 00:05:53.000
そして再び、それは関数自体のアドレスをロードし、それを呼び出すための別の、異なる、間接を持っています。

00:05:53.000 --> 00:05:59.000
詳細は重要ではありませんが、重要なのは、それを行うにはさらに数バイトのコードが必要であるということです。

00:05:59.000 --> 00:06:03.000
そして、これは私が先に述べたように、あなたが望むモードを選択できる場所です。

00:06:03.000 --> 00:06:07.000
ここで行ったように、これら2つの小さなスタブ機能を別々にしておくことができます。

00:06:07.000 --> 00:06:11.000
私たちは最も多くのコードを共有し、これらの機能をできるだけ小さくすることができます。

00:06:11.000 --> 00:06:17.000
しかし、残念ながら、これは2回バックコールを行いますが、これはパフォーマンスには理想的ではありません。

00:06:17.000 --> 00:06:20.000
そのため、代替バージョンでこれをさらに改善することができます。

00:06:20.000 --> 00:06:25.000
作成したこの2つのスタブ関数を1つにまとめることができます。

00:06:25.000 --> 00:06:29.000
そうすれば、コードを近づけ、それほど多くの呼び出しを必要としません。

00:06:29.000 --> 00:06:32.000
そして、それはここの右側にあります。

00:06:32.000 --> 00:06:33.000
したがって、これらは2つのオプションです。

00:06:33.000 --> 00:06:38.000
サイズだけを最適化するかどうかを選択し、利用可能な最大のサイズ節約を得ることができます。

00:06:38.000 --> 00:06:48.000
-Objc_stubs_smallリンカフラグを使用して有効にすることも、最高のパフォーマンスを維持しながらサイズの利点を提供するコード生成を使用することもできます。

00:06:48.000 --> 00:06:54.000
そして、サイズに厳しい制約がない限り、これを使用することをお勧めします。そのため、デフォルトです。

00:06:54.000 --> 00:06:57.000
そして、それはスタブを使用して送信する小さなメッセージでした。

00:06:57.000 --> 00:07:01.000
私たちが行ったもう1つの改善は、保持/リリースを安くすることです。

00:07:01.000 --> 00:07:08.000
Xcode 14の新しいコンパイラにより、保持/リリースコールはARM64の8バイトから最大4バイト小さくなりました。

00:07:08.000 --> 00:07:13.000
すぐにわかるように、メッセージの送信と同じように、保持/リリースもどこにでもあります。

00:07:13.000 --> 00:07:18.000
これにより、バイナリのコードサイズが最大2%改善されました。

00:07:18.000 --> 00:07:28.000
さて、メッセージ送信スタブとは異なり、これにはランタイムサポートが必要なため、iOS 16、tvOS 16、またはwatchOS 9の展開ターゲットに移行すると、これが自動的に取得されます。

00:07:28.000 --> 00:07:31.000
では、何が変わったのかを見てみましょう。

00:07:31.000 --> 00:07:32.000
私たちの例に戻りましょう。

00:07:32.000 --> 00:07:42.000
msgSendコールについて話しましたが、自動参照カウント（ARC）では、コンパイラによって多くの保持/リリースコールが挿入されます。

00:07:42.000 --> 00:07:49.000
非常に高いレベルでは、オブジェクトへのポインタのコピーを作成するたびに、それをライブに保つために保持数を増やす必要があります。

00:07:49.000 --> 00:07:53.000
そしてここで、これは私たちの変数cal、dateComponent、およびtheDateで起こります。

00:07:53.000 --> 00:07:57.000
Objc_retainを使用して、ランタイムを呼び出すことによってそれを行います。

00:07:57.000 --> 00:08:03.000
変数がスコープ外になると、objc_releaseを使用して保持カウントを減少させる必要があります。

00:08:03.000 --> 00:08:10.000
もちろん、ARCの利点の一部は、これらの呼び出しの多くを排除し、それらを最小限に抑えるすべてのコンパイラの魔法です。

00:08:10.000 --> 00:08:13.000
そして、私たちは少し後でこれらの手品の1つに入るつもりです。

00:08:13.000 --> 00:08:17.000
しかし、すべての魔法があっても、私たちはまだしばしばこれらの呼び出しを必要とします。

00:08:17.000 --> 00:08:24.000
この例では、カレンダーとdateComponentsのローカルコピーをリリースする必要があります。

00:08:24.000 --> 00:08:32.000
ボンネットの下では、これらのobjc_retain/release関数は単なるC関数です。単一の引数、解放されるオブジェクトを取ります。

00:08:32.000 --> 00:08:38.000
したがって、ARCでは、コンパイラはこれらのC関数への呼び出しを挿入し、適切なオブジェクトポインタを渡します。

00:08:38.000 --> 00:08:46.000
そのため、これらの呼び出しは、当社のプラットフォームApplication Binary Interface（ABI）によって定義されたC呼び出し規約を尊重する必要があります。

00:08:46.000 --> 00:08:53.000
具体的には、これらの呼び出しを行い、正しいレジスタにポインタを渡すために、さらに多くのコードが必要であることを意味します。

00:08:53.000 --> 00:08:57.000
だから、私たちはそのためだけにいくつかの追加の「移動」指示で終わります。

00:08:57.000 --> 00:09:00.000
そして、それが私たちの新しい最適化の出番です。

00:09:00.000 --> 00:09:11.000
カスタム呼び出し規約で保持/リリースに特化することで、オブジェクトポインタがすでにどこにあるかに応じて適切なバリアントを日和見的に使用できるため、移動する必要はありません。

00:09:11.000 --> 00:09:17.000
具体的には、これが意味することは、これらすべての呼び出しに対して冗長なコードの束を取り除くということです。

00:09:17.000 --> 00:09:23.000
そして再び、これはこれらのちっぽけな小さな指示のために多くのようには思えないかもしれませんが、アプリ全体にわたって、それは本当に加算されます。

00:09:23.000 --> 00:09:26.000
それが、私たちが保持/リリース操作を安くした方法です。

00:09:26.000 --> 00:09:29.000
最後に、自動放出の省略について話しましょう。

00:09:29.000 --> 00:09:32.000
今、これはさらに面白いです。

00:09:32.000 --> 00:09:36.000
Objcランタイムの変更により、自動リリースの省略が速くなりました。

00:09:36.000 --> 00:09:41.000
これは、新しいOSリリースで実行すると、既存のアプリで自動的に発生します。

00:09:41.000 --> 00:09:47.000
それに加えて、追加のコンパイラの変更により、コードも小さくしました。

00:09:47.000 --> 00:09:55.000
また、iOS 16、tvOS 16、またはwatchOS 9の展開ターゲットに移行すると、このサイズの利点が自動的に得られます。

00:09:55.000 --> 00:09:59.000
さて、これはすべて素晴らしいですが、そもそも自動リリースの省略とは何ですか?

00:09:59.000 --> 00:10:02.000
私たちの例に戻りましょう。

00:10:02.000 --> 00:10:07.000
先ほど、ARCはすでに保持とリリースを最適化するための多くのコンパイラの魔法を与えていると述べました。

00:10:07.000 --> 00:10:11.000
では、ここで1つのケースに焦点を当てましょう。自動リリースされた戻り値です。

00:10:11.000 --> 00:10:15.000
この例では、一時的なオブジェクトを作り、それを発信者に返しています。

00:10:15.000 --> 00:10:17.000
それでは、それがどのように機能するかを見てみましょう。

00:10:17.000 --> 00:10:24.000
したがって、一時的なtheDateがあり、それを返し、呼び出しが完了し、呼び出し元はそれを独自の変数に保存します。

00:10:24.000 --> 00:10:28.000
それでは、それがARCでどのように機能するかを見てみましょう。

00:10:28.000 --> 00:10:32.000
ARCは、呼び出し元のリテンションを挿入し、呼び出された関数にリリースを挿入します。

00:10:32.000 --> 00:10:39.000
ここでは、一時的なオブジェクトを返すときは、スコープ外になるため、関数で最初にリリースする必要があります。

00:10:39.000 --> 00:10:43.000
しかし、まだ他の参考文献がないので、まだそれを行うことはできません。

00:10:43.000 --> 00:10:48.000
もし私たちがそれをリリースしたら、それは私たちが戻る前に破壊されるだろうし、それは良くない。

00:10:48.000 --> 00:10:51.000
したがって、一時的なものを返すことができるように、特別な慣習が使用されます。

00:10:51.000 --> 00:10:56.000
発信者がそれを保持できるように、返品前に自動リリースします。

00:10:56.000 --> 00:11:02.000
あなたはおそらく以前に自動リリースと自動リリースプールを見たことがあるでしょう:それは単にいくつかの後のポイントまでリリースを延期する方法です。

00:11:02.000 --> 00:11:12.000
ランタイムは、リリースがいつ発生するかについて実際には保証しませんが、それがここにない限り、今、この一時的なオブジェクトを返すことができるので、それは便利です。

00:11:12.000 --> 00:11:13.000
さて、これは無料ではありません。

00:11:13.000 --> 00:11:16.000
自動リリースを行うには多少のオーバーヘッドがあります。

00:11:16.000 --> 00:11:19.000
ここでオートリリースエミッションの出番です。

00:11:19.000 --> 00:11:24.000
だから、それがどのように機能するかを理解するために、アセンブリを見て、このリターンをたどりましょう。

00:11:24.000 --> 00:11:30.000
オートリリースを呼び出すと、それはobjcランタイムに入り、そこで楽しみが始まります。

00:11:30.000 --> 00:11:35.000
ランタイムは、何が起こっているかを認識しようとします。自動リリースされた値を返しています。

00:11:35.000 --> 00:11:40.000
それを助けるために、コンパイラは私たちが決して使用しない特別なマーカーを発行します。

00:11:40.000 --> 00:11:45.000
これは自動リリースの省略の対象となることをランタイムに伝えるためにそこにあります。

00:11:45.000 --> 00:11:48.000
そして、その後に保持が続き、後で実行します。

00:11:48.000 --> 00:11:59.000
しかし、今、私たちはまだ自動リリース中であり、それを行うと、ランタイムは特別なマーカー命令をデータとしてロードし、それを比較して、それが期待する特別なマーカー値であるかどうかを確認します。

00:11:59.000 --> 00:12:05.000
もしそうなら、それはコンパイラがすぐに保持される一時を返すことをランタイムに伝えたことを意味します。

00:12:05.000 --> 00:12:09.000
これにより、一致する自動リリースを解除または削除し、コールを保持することができます。

00:12:09.000 --> 00:12:12.000
そして、それは自動放出の回避です。

00:12:12.000 --> 00:12:20.000
しかし、これも無料ではありません。データとしてコードをロードすることは、そうでなければ非常に一般的なものではないので、CPUでは最適ではありません。

00:12:20.000 --> 00:12:21.000
私たちはもっとうまくやれる。

00:12:21.000 --> 00:12:26.000
では、今回は新しい方法を使用して、もう一度戻りシーケンスをたどりましょう。

00:12:26.000 --> 00:12:28.000
私たちはオートリリースから始めました。

00:12:28.000 --> 00:12:30.000
それはまだObjective-Cランタイムに入ります。

00:12:30.000 --> 00:12:35.000
この時点で、私たちは実際にすでに貴重な情報を持っています：返送先住所。

00:12:35.000 --> 00:12:41.000
この関数の実行が完了した後、どこに戻る必要があるかを教えてくれます。

00:12:41.000 --> 00:12:42.000
だから、私たちはそれを追跡することができます。

00:12:42.000 --> 00:12:45.000
ありがたいことに、返送先住所を取得するのはとても安いです。

00:12:45.000 --> 00:12:48.000
それは単なるポインタで、側面に保管できます。

00:12:48.000 --> 00:12:51.000
その後、ランタイムの自動リリースコールを残します。

00:12:51.000 --> 00:12:56.000
発信者に戻り、保持時にランタイムを再入力します。

00:12:56.000 --> 00:12:59.000
そして、これは新しい魔法が起こる場所です。

00:12:59.000 --> 00:13:04.000
その時点で、私たちがどこにいるかを見て、現在のリターンアドレスへのポインタを得ることができます。

00:13:04.000 --> 00:13:12.000
実行時に、保持中に手に入れたばかりのこのポインタと、オートリリースをしていたときに以前に保存したポインタを比較できます。

00:13:12.000 --> 00:13:14.000
そして、私たちは2つのポインタを比較しているだけなので、これは超安いです。

00:13:14.000 --> 00:13:17.000
高価なメモリアクセスを行う必要はありません。

00:13:17.000 --> 00:13:25.000
比較が成功すれば、自動リリース/保持ペアを省略でき、パフォーマンスを向上させることができます。

00:13:25.000 --> 00:13:32.000
その上、この特別なマーカー命令をデータとして比較する必要がなくなったので、必要ないので、削除できます。

00:13:32.000 --> 00:13:34.000
そして、コードサイズも保存できます。

00:13:34.000 --> 00:13:38.000
それが私たちがオートリリースの省略をより速く、より小さくした方法です。

00:13:38.000 --> 00:13:42.000
SwiftとObjective-Cのランタイムをいくつか改善しました。

00:13:42.000 --> 00:13:43.000
締めくくりましょう。

00:13:43.000 --> 00:13:50.000
アプリが新しいOSで実行されると、ランタイムの改善により、Swiftプロトコルチェックがより効率的になります。

00:13:50.000 --> 00:13:55.000
オートリリースの省略をしようとするたびに、それも速くなります。

00:13:55.000 --> 00:14:02.000
Xcode 14の新しいコンパイラとリンカーとメッセージ送信スタブのおかげで、アプリを再構築することでコードサイズの最大2%を節約できます。

00:14:02.000 --> 00:14:12.000
そして最後に、デプロイメントターゲットをiOS 16、tvOS 16、またはwatchOS 9に更新すると、リテンション/リリースコールを小さくすることで、さらに2%を節約できます。

00:14:12.000 --> 00:14:16.000
さらに、より小さな自動放出エリシオンシーケンスのおかげです。

00:14:16.000 --> 23:59:59.000
SwiftとObjective-Cのランタイムを深く掘り下げて楽しんでいただければ幸いです。ご覧いただきありがとうございます。

