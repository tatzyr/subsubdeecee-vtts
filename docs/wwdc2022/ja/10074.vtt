WEBVTT

00:00:00.000 -> 00:00:10.000
♪ ♪

00:00:10.000 -> 00:00:13.000
ジェフ・ナドー：こんにちは、AppKitの新機能へようこそ。

00:00:13.000 -> 00:00:21.000
私はAppKitチームのエンジニアであるJeff Nadeauで、macOS Ventura用のアプリを構築するための最新かつ最高のものを共有するためにここにいます。

00:00:21.000 -> 00:00:33.000
Apple Siliconのパフォーマンスと効率性、macOSのパワー、そしてこれまで以上に豊かなアプリエコシステムの間で、Macにとってかつてないほどエキサイティングな時期でした。

00:00:33.000 -> 00:00:42.000
あなたのアプリはその物語の重要な部分であり、あなたが最高のアプリを構築し続けることができるように、私たちはAppKitを前進させ続けています。

00:00:42.000 -> 00:00:57.000
ステージマネージャーから始まり、環境設定、続いてコントロール、SFシンボル、共有など、さまざまなトピックをカバーします。

00:00:57.000 -> 00:01:00.000
ステージマネージャーから始めます。

00:01:00.000 -> 00:01:07.000
ステージマネージャーは、アクティブなウィンドウが中心になっている間、ワークスペースの非アクティブなウィンドウをクリーンアップします。

00:01:07.000 -> 00:01:15.000
より高度なワークフローでは、ウィンドウをグループとして交換するセットにまとめることもできます。

00:01:15.000 -> 00:01:19.000
これは、アプリのウィンドウがどのように表示されるかに影響します。

00:01:19.000 -> 00:01:29.000
ステージマネージャーは作業スペースを整頓しようとしているので、新しいウィンドウが表示されると、既存のウィンドウはスペースを作るためにステージを終了します。

00:01:29.000 -> 00:01:33.000
それはあなたの文書のような「プライマリ」ウィンドウに欲しいものです。

00:01:33.000 -> 00:01:43.000
パネル、ポップオーバー、設定などの補助ウィンドウは、既存のウィンドウの上に引き続き表示する必要があります。

00:01:43.000 -> 00:01:51.000
NSWindowには、特定のウィンドウの動作を定義するのに役立つAPIがすでにたくさんあります。

00:01:51.000 -> 00:02:03.000
デフォルトでは、フローティングパネル、モーダルウィンドウ、または環境設定スタイルのツールバーを持つウィンドウを提示した場合、ステージマネージャーは他のウィンドウを交換しません。

00:02:03.000 -> 00:02:07.000
ステージマネージャーは、ウィンドウのコレクションBehaviorも尊重します。

00:02:07.000 -> 00:02:19.000
このOptionSetは、ウィンドウがスペースとフルスクリーンでどのように動作するかを定義し、ステージマネージャーがウィンドウが補助またはフローティングと見なされることを理解するのにも役立ちます。

00:02:19.000 -> 00:02:31.000
ウィンドウのcollectionBehaviorに補助、moveToActiveSpace、固定、または一時的なオプションが含まれている場合、センターステージのアクティブなウィンドウを置き換えることはありません。

00:02:31.000 -> 00:02:42.000
適切なコレクション動作でウィンドウを設定することで、デスクトップスペース、フルスクリーン、ステージマネージャーなど、あらゆるコンテキストでうまく機能することを確認できます。

00:02:42.000 -> 00:02:46.000
次に、環境設定の重要な変更を取り上げたいと思います。

00:02:46.000 -> 00:02:57.000
macOS Venturaでは、システム環境設定アプリは、更新されたナビゲーションスキームとまったく新しいビジュアルデザインで、まったく新しい外観になりました。

00:02:57.000 -> 00:03:05.000
他のオペレーティングシステムの設定体験に合わせて、アプリの名前もシステム設定に変更しました。

00:03:05.000 -> 00:03:08.000
これらの変更は、あなたのアプリケーションにも及びます。

00:03:08.000 -> 00:03:14.000
たとえば、今日システム環境設定アプリに表示される環境設定ペインバンドルがあるかもしれません。

00:03:14.000 -> 00:03:18.000
また、アプリ内に設定エリアがあるかもしれません。

00:03:18.000 -> 00:03:26.000
また、設定インターフェイスや検査官に最適な、制御が豊富なフォーム用の新しい設計システムもあります。

00:03:26.000 -> 00:03:32.000
カスタムprefpaneバンドルを出荷すると、新しい設定アプリで引き続き動作します。

00:03:32.000 -> 00:03:41.000
カスタムペインはサイドバーに表示され、アプリはバンドルをロードし、モントレー以前と同じように設定UIを表示します。

00:03:41.000 -> 00:03:48.000
新しく名前が変更されたシステム設定アプリに合わせて、アプリ内設定も「設定」に変更しました。

00:03:48.000 -> 00:03:57.000
始めるために、最新のSDKに対してビルドすると、AppKitはアプリメニューのメニュー項目である「環境設定」の名前を自動的に更新します。

00:03:57.000 -> 00:04:07.000
ただし、ウィンドウのタイトル、説明ラベル、またはアプリ周辺の他のコントロールなど、他の多くの場所で「環境設定」という単語を使用している可能性があります。

00:04:07.000 -> 00:04:12.000
ローカライズされたテキストを検索して、更新が必要な場所を見つけます。

00:04:12.000 -> 00:04:23.000
たとえば、TextEditの設定ウィンドウは以前は「環境設定」と呼ばれていましたが、システムの残りの部分と一致するように、そのウィンドウの名前を設定に変更することを選択しました。

00:04:23.000 -> 00:04:29.000
システム設定アプリはまた、すべての設定オプションを表示するために新しいインターフェイススタイルを使用します。

00:04:29.000 -> 00:04:40.000
設定インターフェイスはしばしばコントロールが重いため、このスタイルは、多くのコントロールを含むフォームを明確でよく整理された方法で提示するように設計されています。

00:04:40.000 -> 00:04:54.000
フォーム自体は多くの視覚構造を提供するため、多くのシステムコントロールは、ロールオーバーでより顕著なコントロールバッキングを明らかにしながら、より低い視覚的な重みで描画することで、このコンテキストに適応します。

00:04:54.000 -> 00:05:00.000
この新しいデザインを使用するインターフェイスを書きたい場合、SwiftUIはそれを非常に簡単にします。

00:05:00.000 -> 00:05:06.000
コントロールをフォームビューに配置し、「insetGrouped」フォームスタイルを適用します。

00:05:06.000 -> 00:05:16.000
SwiftUIは残りを処理します。ビジュアルスタイル、スクロール動作、およびフォームのレイアウトはすべて自動的に適用されます。

00:05:16.000 -> 00:05:22.000
SwiftUIをまだ使い始めていないなら、これは試してみる絶好の機会です。

00:05:22.000 -> 00:05:30.000
設定ウィンドウは、多くの場合、アプリのインターフェイスのスタンドアロン領域であるため、段階的な採用を行うのに最適な場所です。

00:05:30.000 -> 00:05:37.000
SwiftUIとAppKitを一緒に使用するためのビデオも作成しました。これは、詳細を学ぶのに最適な場所です。

00:05:37.000 -> 00:05:42.000
次に、コントロールの更新をいくつか共有したいと思います。

00:05:42.000 -> 00:05:49.000
NSComboButtonと呼ばれる新しいコントロールから始めて、共有すべきエキサイティングなコントロールの強化がたくさんあります。

00:05:49.000 -> 00:06:02.000
また、NSColorWellを更新し、NSToolbar APIをいくつか強化し、NSAlertの設計を調整し、NSTableViewのパフォーマンスを改善しました。

00:06:02.000 -> 00:06:05.000
まず、NSComboButton。

00:06:05.000 -> 00:06:13.000
NSComboButtonは、即時のボタンアクションと追加オプションのメニューを組み合わせることです。

00:06:13.000 -> 00:06:23.000
今日のコントロールランドスケープでは、伝統的にボタンを使用して即時アクションを実行するか、プルダウンボタンを使用して多くのオプションを含むメニューを表示します。

00:06:23.000 -> 00:06:33.000
NSComboButtonは、両方の要素を1つのコントロールにまとめ、プライマリアクションとプルダウンメニューを結合します。

00:06:33.000 -> 00:06:44.000
このデザインは、Mailのこのようなユースケースで一般的に使用され、予測されたフォルダはワンクリックですが、メニューにアクセスしてどこでもメッセージをファイルすることができます。

00:06:44.000 -> 00:06:53.000
以前は、セグメント化されたコントロールAPIを使用してこのようなものを組み立てたかもしれませんが、今では専用のコントロールがあります。

00:06:53.000 -> 00:07:00.000
NSComboButtonには、ボタンの外観と動作の両方を決定する2つのスタイルがあります。

00:07:00.000 -> 00:07:08.000
デフォルトのスタイルは「分割」と呼ばれ、メニューのためだけに別の矢印部分が含まれています。

00:07:08.000 -> 00:07:13.000
2番目のスタイル「統一」は、普通のボタンのように見えます。

00:07:13.000 -> 00:07:20.000
このスタイルは、クリック時に主要なアクションを実行し、クリックしてホールドするとメニューが表示されます。

00:07:20.000 -> 00:07:21.000
そして、それはNSComboButtonです。

00:07:21.000 -> 00:07:27.000
また、NSColorWellの素晴らしい新しいアップデートも、まったく新しい外観から始めました。

00:07:27.000 -> 00:07:37.000
古典的な正方形のグラデーションの外観の代わりに、色ウェルはシステム全体の他のボタンベゼルを彷彿とさせる新しいスタイルを採用しています。

00:07:37.000 -> 00:07:44.000
この変更は完全に自動なので、このモダンな外観を得るために採用する必要はありません。

00:07:44.000 -> 00:07:55.000
しかし、私たちはカラーピッキングが創造的でプロフェッショナルなアプリケーションの重要な部分であることを知っているので、さらに一歩進んで、NSColorWellに2つの新しいスタイルを導入しました。

00:07:55.000 -> 00:08:11.000
1つ目は、ロールオーバー時に開示矢印を表示する最小限のスタイルで、色のパレットからすぐに選択するポップオーバーを表示することで、迅速なカラーピッキング体験を提供し、完全なNSColorPanelに分割するオプションがあります。

00:08:11.000 -> 00:08:22.000
デフォルトでは、システム標準の色のグリッドを使用しますが、別のUIやパレットを念頭に置いている場合は、ここに表示されるものをカスタマイズできます。

00:08:22.000 -> 00:08:27.000
2つ目は、iWorkアプリから認識できる拡張されたスタイルです。

00:08:27.000 -> 00:08:43.000
このスタイルは、両方のインタラクションモデルを組み合わせたものです。左側のウェルには、クイックピッキングのための同じ開示矢印とポップオーバーがあり、右側のボタンは、より詳細なカラーピッキングのためにフルパネルを引き上げます。

00:08:43.000 -> 00:08:49.000
そして、それに伴い、NSColorWellは現在、色を選択する3つの異なる方法を提供しています。

00:08:49.000 -> 00:09:02.000
NSColorWellの新しいcolorWellStyleプロパティを使用して、これらのスタイルにアクセスできます。これには、デフォルト、展開、最小の各スタイルのケースがあります。

00:09:02.000 -> 00:09:08.000
NSColorWellはまた、その「プルダウンアクション」のための新しいターゲットとアクションのペアを獲得しました。

00:09:08.000 -> 00:09:15.000
このアクションは、最小または展開された色のプルダウン部分をクリックしたときに何が起こるかを決定します。

00:09:15.000 -> 00:09:22.000
デフォルトでは、これらのプロパティはnilであり、NSColorWellがシステム標準のポップオーバーを使用する必要があることを意味します。

00:09:22.000 -> 00:09:32.000
ただし、このアクションをカスタマイズして、独自のカスタムポップオーバーを表示したり、メニューなどの別のピッキングインターフェイスを表示したりすることもできます。

00:09:32.000 -> 00:09:35.000
そして、それは新しいNSColorWellです。

00:09:35.000 -> 00:09:40.000
それは真新しい外観と、色をすばやく選ぶための2つの新しい方法を持っています。

00:09:40.000 -> 00:09:51.000
次に、NSToolbarに関するいくつかのニュースで、カスタマイズをより適切に制御し、レイアウトの柔軟性を高めるために、さまざまなAPI強化を行いました。

00:09:51.000 -> 00:09:59.000
カスタマイズの面では、ツールバーのカスタマイズ性をより適切に制御するために、2つの新しいデリゲートメソッドを追加しました。

00:09:59.000 -> 00:10:03.000
1つ目は「toolbarImmovableItemIdentifiers」です。

00:10:03.000 -> 00:10:16.000
このメソッドを実装して一連のアイテム識別子を返すと、それらのアイテムはユーザーによって移動可能または取り外し可能ではなく、カスタマイズモードに入るとアニメーション化されません。

00:10:16.000 -> 00:10:23.000
たとえば、メールアプリは、フィルターボタンがメッセージリストの上に常に表示されるようにしたいと考えています。

00:10:23.000 -> 00:10:29.000
このAPIを使用すると、この場所から移動されるのを防ぐことができます。

00:10:29.000 -> 00:10:35.000
2番目のメソッドは「toolbar itemIdentifier canBeInsertedAt」と呼ばれています。

00:10:35.000 -> 00:10:43.000
このデリゲートメソッドは、ツールバーからの特定の並べ替え、挿入、または削除に対する拒否権を与えます。

00:10:43.000 -> 00:10:56.000
独自のカスタマイズルールセットを実装するために使用できます。たとえば、ツールバーの1つのセクション内で許可されているツールバーアイテムを作成できますが、別のセクションでは許可されていません。

00:10:56.000 -> 00:11:03.000
新しい centeredItemIdentifiers プロパティを使用して、ツールバーに複数の中央に配置された項目を指定できるようになりました。

00:11:03.000 -> 00:11:12.000
ツールバーがカスタマイズ可能な場合、このセットの項目は引き続きツールバーに追加または削除できますが、中央のグループ内でのみ並べ替えることができます。

00:11:12.000 -> 00:11:23.000
この例では、写真編集ツールはすべて、先頭と末尾のセクションに配置されるアイテムの数に関係なく、ツールバーの中央にまとめられています。

00:11:23.000 -> 00:11:39.000
ツールバーが好きなようにカスタマイズされると、アイテムがシフトしたくないので、クリックすると切り替えるメールのミュートボタンやミュート解除ボタンなど、他の状態に基づいて意味を変更するツールバーアイテムでは難しい場合があります。

00:11:39.000 -> 00:11:48.000
ラベルのサイズが異なるため、ツールバーの他の項目は変更に対応するためにシフトする必要があります。

00:11:48.000 -> 00:11:59.000
このようなシナリオでは、NSToolbarItemの新しいpossibleLabelsプロパティを使用して、アイテムに使用するローカライズされた文字列のセットを提供できます。

00:11:59.000 -> 00:12:08.000
NSToolbarは、最も長いラベルに合うようにアイテムのサイズを自動的に調整するので、アイテムが再構成されてもレイアウトは同じままです。

00:12:08.000 -> 00:12:12.000
次に、アラートのデザイン更新。

00:12:12.000 -> 00:12:20.000
macOSのアラートは、いくつかの明確な選択肢を伴う少量のテキストに最適化されたコンパクトなレイアウトを使用しています。

00:12:20.000 -> 00:12:24.000
そして一般的に、それはアラートをまとめる素晴らしい方法です。

00:12:24.000 -> 00:12:35.000
アラートは、短いテキストで最もよく機能します。メッセージをより直接的に伝えることができ、人々はアラートをプッシュする前にあなたが書いたものを読む可能性が高くなります。

00:12:35.000 -> 00:12:50.000
しかし、特に、ファイルシステムデータに関する本当に重要な選択を伝えるこのディスクユーティリティアラートのように、複雑で微妙なものを伝える必要がある場合は、説明を短くできない場合があります。

00:12:50.000 -> 00:12:54.000
コンパクトなレイアウトは、この状況には最適ではありません。

00:12:54.000 -> 00:13:01.000
これらのケースでは、NSAlertを適応させ、より長いテキストに適したより広いレイアウトを提供しました。

00:13:01.000 -> 00:13:09.000
この適応は、有益なテキストが長すぎてコンパクトなサイズに快適に収まらないアラートに対して自動的に行われます。

00:13:09.000 -> 00:13:16.000
コンパクトなアラートウィンドウに収まるには大きすぎるアクセサリービューがある場合にも、このスタイルを使用します。

00:13:16.000 -> 00:13:22.000
アプリがこの動作をオプトインする必要はありません。システム全体に自動的に適用されます。

00:13:22.000 -> 00:13:33.000
レイアウトはアラートを表示した時点で決定されるため、すでに画面に表示されている間にアラートを変更してもスタイルが交換されないことに注意することが重要です。

00:13:33.000 -> 00:13:43.000
可能な限りアラートテキストの長さを減らすことを目指すべきですが、このデザインの更新は、あなたができない場合のユーザーエクスペリエンスを向上させます。

00:13:43.000 -> 00:13:47.000
次に、NSTableViewの重要な新機能です。

00:13:47.000 -> 00:13:56.000
NSTableViewは、スクロールしながらビューを遅延入力して再利用することで、非常に多数の行を効率的に処理するように設計されています。

00:13:56.000 -> 00:14:11.000
ただし、各行の高さが異なるテーブルの場合、優れたスクロール体験を提供するために、テーブルは総高さとスクロール領域内の各行の位置を知る必要があるため、それは難しい場合があります。

00:14:11.000 -> 00:14:19.000
歴史的に、NSTableViewはテーブル内のすべての行をサイズ変更することでこれを行い、最初のロード時間に影響を与える可能性があります。

00:14:19.000 -> 00:14:27.000
macOS Venturaでは、NSTableViewははるかに優れたパフォーマンスを提供しながら、これらの目標を達成します。

00:14:27.000 -> 00:14:39.000
NSTableViewは、各行の高さを熱心に計算するのではなく、スクロールビューポート内または近くにある行に基づいて行の高さを怠惰に計算するようになりました。

00:14:39.000 -> 00:14:48.000
まだ測定されていない行の場合、NSTableViewは、すでに測定された行の高さに基づいて実行中の推定高さを使用します。

00:14:48.000 -> 00:15:02.000
テーブルをスクロールすると、NSTableViewは必要に応じて行の高さを要求し、推定高さを実際の測定値に置き換え、正しいスクロール位置を維持するように注意します。

00:15:02.000 -> 00:15:07.000
この最適化により、非常に大きなテーブルのロード時間が大幅に改善されます。

00:15:07.000 -> 00:15:18.000
この変更により、「テーブルビュー：行の高さ」などのデリゲート呼び出しのタイミングが変更されるため、NSTableViewがいつ行の高さを要求するかを仮定すべきではありません。

00:15:18.000 -> 00:15:28.000
この最適化は、NSTableViewとSwiftUIのリストビューの両方に適用され、採用を必要とせず、macOS Venturaのすべてのアプリに自動的に使用されます。

00:15:28.000 -> 00:15:32.000
そして、それはNSTableViewのパフォーマンスです。

00:15:32.000 -> 00:15:35.000
次に、SFシンボルに関するいくつかの更新。

00:15:35.000 -> 00:15:45.000
macOS VenturaにはSFシンボル4が含まれており、あらゆる種類の被写体をカバーする450以上の新しいシンボル画像が追加されています。

00:15:45.000 -> 00:15:58.000
これらの新しいシンボルには、月桂樹、あらゆる種類の家庭用品、世界中の通貨シンボル、さらにはさまざまなスポーツ関連のシンボルが含まれます。

00:15:58.000 -> 00:16:07.000
何千ものシンボルのカタログでは、SFシンボルには、あなたが表現したいアイデアのための専門的に設計されたアイコンが含まれている可能性があります。

00:16:07.000 -> 00:16:08.000
しかし、私たちはそこで止まっていません。

00:16:08.000 -> 00:16:14.000
SFシンボル4には、図像をさらに強化するための新機能も含まれています。

00:16:14.000 -> 00:16:21.000
要約すると、シンボル画像は、デザインに応じて選択できる多くのレンダリングモードをサポートしています。

00:16:21.000 -> 00:16:41.000
単一の色を使用するモノクロ、シンボルの特定の部分を強調するために色の異なる不透明度を使用する階層、シンボルの各部分に異なる色を指定できるパレット、シンボルアートワークに直接デザインされた色を使用するマルチカラーがあります。

00:16:41.000 -> 00:16:53.000
これらの選択肢は、さまざまなデザインを実現するための柔軟性を提供しますが、構成を適用することなく、シンボル画像が箱から出してすぐに最高に見えるようにしたいと考えています。

00:16:53.000 -> 00:16:59.000
そのため、macOS Venturaのシンボルに新機能を導入しました。優先レンダリングモードです。

00:16:59.000 -> 00:17:09.000
優先レンダリングモードでは、シンボルは好みのレンダリングスタイルを指定でき、実行時にAppKitは自動的にそのスタイルを使用します。

00:17:09.000 -> 00:17:18.000
これは、これらの細かいディテールの明瞭さを高めるために階層的なスタイルを好むAirPods Proのようなシンボルに最適です。

00:17:18.000 -> 00:17:28.000
もちろん、別のデザインを念頭に置いている場合は、いつでもNSImageSymbolConfigurationオブジェクトを使用して好みのスタイルを選択できます。

00:17:28.000 -> 00:17:38.000
一部のシンボルは、概念を表すだけでなく、Wi-Fi信号強度やオーディオ音量など、何らかの価値や量を伝えるためのものもあります。

00:17:38.000 -> 00:17:44.000
このようなケースでは、「可変シンボル」と呼ばれる新しいタイプのシンボルを導入しました。

00:17:44.000 -> 00:17:56.000
可変シンボルを使用すると、浮動小数点値をNSImageに直接指定し、シンボルには数値のしきい値が埋め込まれ、各パスがその値に基づいてどのように変化するかを決定します。

00:17:56.000 -> 00:17:58.000
これがAPIです。

00:17:58.000 -> 00:18:02.000
変数記号は、新しい初期化子を使用して作成されます。

00:18:02.000 -> 00:18:11.000
これは、既存のシンボル画像初期化子に似ており、0と1の間の浮動小数点数である値パラメータが追加されています。

00:18:11.000 -> 00:18:19.000
シンボル画像が変数のしきい値を定義しない場合、この値は無視され、シンボルは通常どおり描画されます。

00:18:19.000 -> 00:18:26.000
その場合、指定した値に基づいてシンボルパスの描画が異なります。

00:18:26.000 -> 00:18:41.000
各変数シンボルは、独自の方法で値を表すことができ、APIレベルでその値を提供することで、シンボルの構成方法の詳細を知ることなく、これらのバリエーションのすべてにアクセスできます。

00:18:41.000 -> 00:18:50.000
可変シンボルは、パレットカラーやマルチカラーなどのレンダリングスタイルと組み合わせてうまく機能するので、ほとんどすべてのデザインに適応させることができます。

00:18:50.000 -> 00:19:05.000
最後に、macOS Venturaの共有に関するいくつかの大きなアップデートを取り上げたいと思います。Macでの共有体験を高め、提案された人や、コラボレーションしている人を招待して管理する新しい方法などの機能を紹介します。

00:19:05.000 -> 00:19:13.000
アプリがこれらの機能強化を最大限に活用できるように、採用できる新しいAPIがいくつかあります。

00:19:13.000 -> 00:19:18.000
共有体験の最も顕著なアップデートは、新しい共有ポップオーバーです。

00:19:18.000 -> 00:19:28.000
これにより、既存の共有メニューは、共有しているドキュメントに関する詳細情報や、提案された人などの使い慣れた機能を含む豊富なインターフェイスに置き換えられます。

00:19:28.000 -> 00:19:42.000
以前のピッカーと同じAPIとデリゲートメソッドをすべてサポートしているため、共有サービスのリストをフィルタリングしたり、独自のカスタムサービスをピッカーに挿入したりできます。

00:19:42.000 -> 00:19:52.000
ファイルURLを共有する場合、NSSharingServicePickerはファイルに関するアイコン、名前、その他のメタデータをヘッダーに自動的に入力できます。

00:19:52.000 -> 00:20:03.000
しかし、代わりにカスタムタイプを共有している場合は、NSSharingServicePickerがその情報を要求するために使用する新しいプロトコルにアイテムを適合させることができます。

00:20:03.000 -> 00:20:08.000
このプロトコルはNSPreviewRepresentableActivityItemと呼ばれます。

00:20:08.000 -> 00:20:21.000
適合型は、NSItemProviderのように共有する基礎となるアイテムを返すことができなければならず、オプションでタイトル、画像プロバイダー、およびアイコンプロバイダーを返すことができます。

00:20:21.000 -> 00:20:32.000
便宜上、AppKitにはNSPreviewRepresentingActivityItemと呼ばれる適合クラスがあり、既存の共有アイテムとそのメタデータをバンドルするために使用できます。

00:20:32.000 -> 00:20:44.000
各画像パラメータをNSImageとして直接提供することも、これらの画像を事前に生成するにはパフォーマンスが高すぎる場合は、NSItemProviderを使用できます。

00:20:44.000 -> 00:20:57.000
新しい共有ピッカーは、ツールバーボタンのような場所から共有を開始するのに最適ですが、メインメニューバーやアプリ内の選択したビューのコンテキストメニューなどのメニューから共有を開始したい場合があります。

00:20:57.000 -> 00:21:06.000
以前は、共有サービスを列挙し、それぞれのメニュー項目を作成することで、これを処理するために独自のメニューを構築したかもしれません。

00:21:06.000 -> 00:21:13.000
それは機能しますが、標準ピッカーをバイパスするので、これらの新機能をすべて見逃しています。

00:21:13.000 -> 00:21:20.000
macOS Venturaでは、NSSharingServicePickerは「standardShareMenuItem」を作成できます。

00:21:20.000 -> 00:21:24.000
標準項目を任意のメニューに追加して、共有を簡単に開始できます。

00:21:24.000 -> 00:21:34.000
選択すると、メニュー項目は共有ポップオーバーを召喚し、コンテキストメニューの場合、ポップオーバーをメニューを生成したのと同じビューに固定します。

00:21:34.000 -> 00:21:40.000
macOS Venturaでコラボレーションを管理するための新しいサポートがたくさんあります。

00:21:40.000 -> 00:21:52.000
いくつかの追加の採用により、共有可能なアイテムはコラボレーションへの招待状にもなり、ユーザーは共有ピッカー、メッセージへのドラッグアンドドロップ、さらにはFaceTimeを介して開始できます。

00:21:52.000 -> 00:22:00.000
CloudKitまたはiCloud Driveを使用してコンテンツを共有したり、招待フローを独自のコラボレーションサーバーに接続したりできます。

00:22:00.000 -> 00:22:06.000
今、これは本当に大きなトピックなので、私たちはそれをはるかに深く説明するためにいくつかのビデオを作りました。

00:22:06.000 -> 00:22:12.000
アプリがコラボレーションをサポートしているかどうか、または追加を始めたいかどうかは必見です。

00:22:12.000 -> 00:22:19.000
macOS Venturaを使い始めるとき、ステージマネージャーで最適に動作するようにウィンドウを設定していることを確認してください。

00:22:19.000 -> 00:22:27.000
次に、NSComboButtonやNSColorWellなどのコントロール強化からデザインがどのように恩恵を受けるかを検討してください。

00:22:27.000 -> 00:22:33.000
SFシンボルの最新のシンボルと機能を使用して、図像を改善します。

00:22:33.000 -> 00:22:43.000
そして最後に、コラボレーションのために、macOS Venturaの新しい共有体験を最大限に活用できるように、最新のAPIを採用してください。

00:22:43.000 -> 23:59:59.000
見てくれてありがとう、そして素晴らしいMacアプリケーションを構築し続けてくれてありがとう。

