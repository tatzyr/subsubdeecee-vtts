WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:13.000
ポール：こんにちは、SwiftUIでカスタムレイアウトを作成することを歓迎します。

00:00:13.000 --> 00:00:16.000
私はポールで、開発者のドキュメントに取り組んでいます。

00:00:16.000 --> 00:00:22.000
SwiftUIは、アプリのインターフェースを構成するために使用する豊富なビルディングブロックセットを提供します。

00:00:22.000 --> 00:00:31.000
テキスト、画像、グラフィックなどの要素を表示する組み込みビューを組み合わせて、カスタムコンポジットビューを作成できます。

00:00:31.000 --> 00:00:39.000
これらすべての要素をこれまで以上に洗練されたグループに配置するために、SwiftUIはレイアウトツールを提供します。

00:00:39.000 --> 00:00:51.000
水平スタックや垂直スタックなどのコンテナを使用すると、ビューを互いに相対的に配置する場所をSwiftUIに伝えることができますが、ビュー修飾子を使用すると、間隔や配置などをさらに制御できます。

00:00:51.000 --> 00:00:59.000
この講演では、一般的なレイアウトの構築をさらに簡単にし、より複雑なレイアウトを可能にする新しいツールを紹介します。

00:00:59.000 --> 00:01:04.000
その過程で、SwiftUIでレイアウトを操作するためのヒントをいくつか紹介します。

00:01:04.000 --> 00:01:12.000
まず、静的なビューのセットを表示するときに、2次元レイアウトに最適なグリッドファミリーの新しいメンバーをお見せします。

00:01:12.000 --> 00:01:21.000
次に、新しいレイアウトプロトコルを使用して、レイアウトエンジンと直接対話できるカスタムビューコンテナタイプを作成する方法について説明します。

00:01:21.000 --> 00:01:31.000
次に、利用可能なスペースに収まるビューのコレクションから自動的に選択するコンテナタイプであるViewThatFitsについて話します。

00:01:31.000 --> 00:01:38.000
そして最後に、AnyLayoutを使用してレイアウトタイプ間のシームレスなトランジションを追加する方法を紹介します。

00:01:38.000 --> 00:01:44.000
これらすべての新機能の動作を見るために、私が取り組んでいるアプリを見てみましょう。

00:01:44.000 --> 00:01:50.000
近年、誰が最高の毛皮のような仲間を作るかについて、私の同僚の間でいくつかの議論がありました。

00:01:50.000 --> 00:01:58.000
私は自分の意見を持っていますが、コンセンサスに達することができるかどうか興味があったので、世論調査を受けるためのアプリを作ることにしました。

00:01:58.000 --> 00:02:03.000
そして、毛皮アレルギーを持つ人々も含めたいので、私は1つの余分なオプションを投げています。

00:02:03.000 --> 00:02:14.000
今、私はプレビューを使用してプロトタイプを作成するのがとても簡単なので、SwiftUIでインターフェイスデザインのほとんどを行うのが好きですが、出発点として、私が目指しているものの簡単なスケッチを描きました。

00:02:14.000 --> 00:02:20.000
投票は一定期間続くと思うので、真ん中に現在の順位を示すリーダーボードが欲しいです。

00:02:20.000 --> 00:02:22.000
投票用のボタンを一番下に置きます。

00:02:22.000 --> 00:02:28.000
そして、上部には、人々が投票しているものの画像をいくつか表示します。

00:02:28.000 --> 00:02:30.000
さて、私が最初にやりたいことは、リーダーボードを作ることです。

00:02:30.000 --> 00:02:33.000
では、それを詳しく見てみましょう。

00:02:33.000 --> 00:02:43.000
リーダーボードは、各候補の行と、名前、パーセンテージ、投票数を示す列を持つ要素の2次元グリッドです。

00:02:43.000 --> 00:02:47.000
ここで達成したい具体的なことがいくつかあります。

00:02:47.000 --> 00:02:58.000
まず、2つのテキスト列は、パーセンテージを表すプログレスビューができるだけ多くのスペースを取得したいので、それぞれのケースで最も広いセルを収容するために必要な範囲だけにしたい。

00:02:58.000 --> 00:03:09.000
そして、これは、他の言語を話す私の友人や、自分のデバイスで異なるテキストサイズを使用する人にとって、カウントがどれほど大きくても、真実である必要があります。

00:03:09.000 --> 00:03:14.000
第二に、名前をリーディングエッジに整列させたいが、量をトレーリングエッジに整列させたい。

00:03:14.000 --> 00:03:20.000
現在、SwiftUIにはすでに遅延グリッドがあり、スクロール可能なコンテンツに最適です。

00:03:20.000 --> 00:03:27.000
これらのコンテナは、表示されているビュー、または表示されようとしているビューのみをロードするため、多くのビューがある場合に非常に効率的です。

00:03:27.000 --> 00:03:34.000
一方、コンテナは両方の次元でセルを自動的にサイズ調整できないことを意味します。

00:03:34.000 --> 00:03:42.000
たとえば、LazyHGridは、列を描画する前に列内のすべてのビューを測定できるため、各列の幅を把握できます。

00:03:42.000 --> 00:03:46.000
しかし、行の高さを把握するために、行内のすべてのビューを測定することはできません。

00:03:46.000 --> 00:03:53.000
これを機能させるには、遅延グリッドは、初期化時にその次元の1つに関する情報を提供する必要があります。

00:03:53.000 --> 00:04:02.000
遅延グリッドやその他の既存のSwiftUIレイアウトコンテナタイプを詳しく見るには、2020年のスタック、グリッド、アウトライントークを参照してください。

00:04:02.000 --> 00:04:09.000
しかし、私の場合、スクロールする必要はなく、SwiftUIに各セルの高さと幅の両方を把握させたいと思います。

00:04:09.000 --> 00:04:14.000
この種のレイアウトでは、SwiftUIはグリッドビューを提供しています。

00:04:14.000 --> 00:04:25.000
遅延グリッドとは異なり、グリッドはすべてのビューを一度に読み込むため、列と行の両方でセルを自動的にサイズと整列させることができます。

00:04:25.000 --> 00:04:28.000
これのコードを見てみましょう。なぜなら、このコードを見てみましょう

00:04:28.000 --> 00:04:31.000
これは、グリッドとして書かれた私のリーダーボードの基本的なバージョンです。

00:04:31.000 --> 00:04:35.000
この特定のグリッドビューには、3つのGridRowインスタンスが含まれています。

00:04:35.000 --> 00:04:38.000
行内では、各ビューは列に対応します。

00:04:38.000 --> 00:04:49.000
したがって、この例では、各行の最初のテキストビューは最初の列に対応し、進捗ビューは2番目の列にあり、最後のテキストビューは3番目の列です。

00:04:49.000 --> 00:04:55.000
グリッドは、最大のビューを保持するために必要な数のスペースを各行と列に割り当てることに注意してください。

00:04:55.000 --> 00:05:00.000
したがって、最初のテキスト列は、最も長い名前には十分な幅ですが、幅は広くはありません。

00:05:00.000 --> 00:05:09.000
進行状況インジケータのような柔軟なビューは、グリッドが提供するのと同じくらい多くのスペースを取ります。この場合、テキスト列のスペースを割り当てた後に残っているものです。

00:05:09.000 --> 00:05:16.000
これを少し調整したいのですが、まず、基本的なデータモデルを作成して、投票数を保存する場所を与えましょう。

00:05:16.000 --> 00:05:24.000
ネットワーク全体でデータを管理および共有するには、より多くのロジックが必要ですが、インターフェイスをプロトタイピングしている間は、このような単純な構造が必要です。

00:05:24.000 --> 00:05:35.000
識別可能なコンフォーマンスを含めると、このタイプをForEachで使いやすくなり、Equatableコンフォーマンスも含めて変更をアニメーション化できるようにします。

00:05:35.000 --> 00:05:41.000
そして、プロトタイプの作成中にプレビューで使用する一連のサンプルデータを作成します。

00:05:41.000 --> 00:05:46.000
グリッドに戻ると、状態変数を作成し、サンプルデータで初期化できます。

00:05:46.000 --> 00:05:51.000
そして、そのデータを使用して、ForEachで行を作成できるようになりました。

00:05:51.000 --> 00:05:56.000
レンダリングされた出力は、まだ同じデータを表示しているため、変更されていないことに注意してください。

00:05:56.000 --> 00:06:00.000
それはすでにかなり近いですが、セルのアライメントを修正する必要があります。

00:06:00.000 --> 00:06:10.000
現在、すべてのセルは中央に整列されており、これはグリッドのデフォルトですが、覚えていれば、名前を前縁に整列させ、値を後縁に整列させたいです。

00:06:10.000 --> 00:06:14.000
これを行うには、リーディングエッジアライメントでグリッドを初期化します。

00:06:14.000 --> 00:06:18.000
ここで使用する値は、グリッド内のすべてのセルに適用されます。

00:06:18.000 --> 00:06:23.000
それは私の最初の2つのコラムでうまくいきますが、最後のコラムはどうですか？

00:06:23.000 --> 00:06:31.000
単一の列の配置に影響を与えるために、その列の任意の1つのセルにgridColumnAlignmentビュー修飾子を適用できます。

00:06:31.000 --> 00:06:34.000
だから、最後の列のテキストビューでそうします。

00:06:34.000 --> 00:06:41.000
さて、それはそこに着いていますが、今それを見ていると、各行の間に仕切りがある方が良いような気がします。

00:06:41.000 --> 00:06:50.000
仕切りでForEachに新しい行を追加すると、これは正確に私が望むものではありませんが、これはいくつかの興味深いことを示していることに注意してください。

00:06:50.000 --> 00:06:56.000
まず、仕切りは柔軟なビューであるため、最初の列はより多くのスペースを占有します。

00:06:56.000 --> 00:07:03.000
基本的に、グリッドは現在、最後の列に必要なものを与え、最初の2つの列の間で残りのスペースを分割しています。

00:07:03.000 --> 00:07:11.000
第二に、他のグリッド行ほど多くのビューを持っていないグリッド行の場合、不足しているビューは後の列に空のセルを作成するだけです。

00:07:11.000 --> 00:07:23.000
しかし、私が本当に欲しいのは、仕切りがグリッドのすべての列にまたがることであり、SwiftUIにはそれを可能にする新しいビュー修飾子があります。

00:07:23.000 --> 00:07:32.000
gridCellColumns修飾子をビューに追加することで、1つのビューにいくつかの列にまたがるように伝えることができます。この場合、3つすべてです。

00:07:32.000 --> 00:07:41.000
そして実際には、ビューがグリッド全体にまたがる必要がある場合、グリッド行の外側にビューを単独で書くだけでこれを単純化できます。

00:07:41.000 --> 00:07:48.000
さて、私のリーダーボードはかなり良い状態なので、次に投票するために使用されるボタンを見てみましょう。

00:07:48.000 --> 00:07:51.000
一見すると、ここには派手すぎるものはありません。

00:07:51.000 --> 00:07:54.000
しかし、私には特別な要件が1つあります。

00:07:54.000 --> 00:08:00.000
一方で、私は特定の選択肢のために小さなボタンで参加者を偏らせたくありません。

00:08:00.000 --> 00:08:06.000
しかし、私はまた、ボタンがiPadやMacで非常に大きくなる可能性のあるコンテナほど大きくなりたくありません。

00:08:06.000 --> 00:08:11.000
代わりに、ボタンはすべて最も広いボタンのテキストに等しい幅を持つ必要があります。

00:08:11.000 --> 00:08:15.000
では、これをHstackで構築しようとするとどうなりますか?

00:08:15.000 --> 00:08:23.000
私が見つけたのは、各ボタンがテキストラベルに合うようにサイズが小さくなり、HStackはこれらを水平にまとめているということです。

00:08:23.000 --> 00:08:31.000
このデフォルトのスタック動作は、多くの場合、まさにあなたが望むものですが、このプロジェクトの私の仕様にはあまり合いません。

00:08:31.000 --> 00:08:39.000
SwiftUIのレイアウトの基礎に関する復習については、2019年のSwiftUIトークでカスタムビューを構築するを参照してください。

00:08:39.000 --> 00:08:47.000
そのトークの概念を使用して、このビュー階層を見て、私が望む動作を得るために何を変更できるかを見てみましょう。

00:08:47.000 --> 00:08:52.000
まず、スタックのコンテナはスタックのサイズを提案します。

00:08:52.000 --> 00:09:00.000
これに基づいて、スタックは3つのボタンのサイズを提案し、各ボタンはそのサイズをテキストラベルに渡します。

00:09:00.000 --> 00:09:08.000
テキストビューは、含まれている文字列に応じて、実際に必要なサイズを計算し、これをボタンに報告します。

00:09:08.000 --> 00:09:10.000
ボタンは情報を元に戻します。

00:09:10.000 --> 00:09:18.000
スタックは、この情報でそれ自体をサイズし、ボタンをスペースに配置し、独自のサイズをコンテナに報告します。

00:09:18.000 --> 00:09:26.000
さて、ボタンがテキストのサイズを取る場合、各テキストビューを柔軟なフレームでラップして成長させるとどうなりますか?

00:09:26.000 --> 00:09:33.000
テキストは変更されていませんが、ボタンには柔軟なサブビューが表示され、HStackが提供するのと同じくらいのスペースがかかります。

00:09:33.000 --> 00:09:38.000
その後、スタックは、含まれているビュー間でスペースを均等に分配します。

00:09:38.000 --> 00:09:44.000
したがって、ボタンはすべて同じサイズで、これは素晴らしいことですが、実際のサイズはスタックのコンテナによって異なります。

00:09:44.000 --> 00:09:49.000
スタックは、コンテナが提供するスペースを埋めるために拡張されますが、それは私が望むものではありません。

00:09:49.000 --> 00:09:59.000
私が本当に欲しいのは、各ボタンの理想的なサイズを要求し、最も広いものを見つけ、それぞれにその量のスペースを提供するカスタムスタックタイプです。

00:09:59.000 --> 00:10:04.000
幸いなことに、SwiftUIにはそれを可能にする新しいツールがあります。

00:10:04.000 --> 00:10:14.000
レイアウトプロトコルを使用して、私のユースケースに合わせた動作でレイアウトプロセスに直接参加するカスタムレイアウトコンテナを定義できます。

00:10:14.000 --> 00:10:16.000
これがどのように機能するか見てみましょう。

00:10:16.000 --> 00:10:26.000
HStackをもう一度見て、特定の問題を解決するために定義するタイプをEqualWidthHStackに変更させてください。

00:10:26.000 --> 00:10:33.000
このタイプは、最も広いボタンの理想的な幅と同じくらいの幅で、ボタンに均等に幅を割り当てます。

00:10:33.000 --> 00:10:40.000
テキストが狭いボタンが拡張してスタックが提供するスペースを埋めることができるように、柔軟なフレームを維持します。

00:10:40.000 --> 00:10:45.000
しかし、ボタンにはまだ私が測定できる理想的なサイズがあり、それはテキストの幅です。

00:10:45.000 --> 00:10:52.000
では、MyEqualWidthHStackを実装する方法を見てみましょう。

00:10:52.000 --> 00:10:56.000
レイアウトプロトコルに準拠したタイプを作成することから始めます。

00:10:56.000 --> 00:10:59.000
基本的なレイアウトに必要なのは、必要な2つの方法だけです。

00:10:59.000 --> 00:11:02.000
それらにスタブを追加しましょう。

00:11:02.000 --> 00:11:10.000
最初の方法はsizeThatFitsで、レイアウトコンテナの大きさを計算して報告します。

00:11:10.000 --> 00:11:16.000
提案されたビューサイズ入力を取得します。これは、レイアウト独自のコンテナビューからのサイズ提案です。

00:11:16.000 --> 00:11:22.000
また、サブビューパラメータを使用して、レイアウトのサブビューにサイズを提案できます。

00:11:22.000 --> 00:11:25.000
サブビューに直接アクセスできないことに注意してください。

00:11:25.000 --> 00:11:34.000
代わりに、サブビューの入力は、サイズを提案するなど、サブビューと特定の方法で対話できるプロキシのコレクションです。

00:11:34.000 --> 00:11:39.000
各プロキシは、私が行った提案に基づいて具体的なサイズを返します。

00:11:39.000 --> 00:11:49.000
これらすべての回答を収集し、それらを使用していくつかの計算を行い、EqualWidthHStackの具体的なサイズをコンテナに返します。

00:11:49.000 --> 00:11:52.000
私が実装しなければならない2番目の方法はplaceSubviewsです。

00:11:52.000 --> 00:11:56.000
これを使って、レイアウトのサブビューのどこに表示するかを伝えます。

00:11:56.000 --> 00:12:07.000
このメソッドは、同じサイズの提案とサブビューの入力を取り、サブビューを配置する必要がある領域を表す境界入力も取ります。

00:12:07.000 --> 00:12:12.000
Boundsは、私がsizeThatFitsの実装で要求したサイズを持つ長方形です。

00:12:12.000 --> 00:12:19.000
覚えておいて、ビューはSwiftUIで独自のサイズを選択するので、私のレイアウトコンテナはそれが要求するサイズを取得します。

00:12:19.000 --> 00:12:25.000
領域の起源は左上にあり、正のXは右に、正のYは下にあります。

00:12:25.000 --> 00:12:37.000
フレームワークは、その方向にビューをレイアウトするときに各ビューのx位置を自動的に反転するため、右から左の言語環境でも、すべての配置計算でこれを想定できます。

00:12:37.000 --> 00:12:42.000
ただし、長方形の原点が値(0,0)であると仮定しないでください。

00:12:42.000 --> 00:12:52.000
とりわけ、ゼロ以外の原点を許可すると、あるレイアウトのplaceSubviewsメソッドが別のレイアウトの同じメソッドを呼び出すレイアウト構成が可能になります。

00:12:52.000 --> 00:13:05.000
作業を少し簡単にするために、長方形は、各次元の最小点、中心点、最大点など、領域の重要な部分にアクセスするためのプロパティを提供します。

00:13:05.000 --> 00:13:16.000
さて、先に進む前に、これらのメソッドが両方とも持っているもう1つのパラメータに注目してください。メソッド呼び出し間で中間計算の結果を共有するために使用できる双方向キャッシュです。

00:13:16.000 --> 00:13:22.000
多くのシンプルなレイアウトでは、これは必要ありません。今のところキャッシュを無視するだけです。

00:13:22.000 --> 00:13:29.000
ただし、Instrumentsでアプリをプロファイリングすると、レイアウトコードの効率を向上させる必要があることが示されている場合は、追加を検討することができます。

00:13:29.000 --> 00:13:34.000
それの詳細については、ドキュメントを確認してください。

00:13:34.000 --> 00:13:37.000
さて、sizeThatFitsを実装しましょう。

00:13:37.000 --> 00:13:44.000
水平に配置されたすべてのボタンを同じ幅に収まるコンテナのサイズを返したいことを覚えておいてください。

00:13:44.000 --> 00:13:51.000
まず、各ボタンのサイズを尋ねます。これは、サイズを提案し、何が戻ってくるかを見ることです。

00:13:51.000 --> 00:14:01.000
サブビューの柔軟性を測定するには、最小サイズ、最大サイズ、理想的なサイズの特別な提案を使用して複数の測定を行うか、特定のサイズを提案することができます。

00:14:01.000 --> 00:14:08.000
この場合、私は不特定のサイズの提案を使用して、理想的なサイズを求めます。

00:14:08.000 --> 00:14:13.000
その後、私が取り戻したすべてのサイズについて、各次元で最大の値を見つけます。

00:14:13.000 --> 00:14:18.000
この場合、金魚のボタンは幅を設定し、高さはすべて同じです。

00:14:18.000 --> 00:14:23.000
サブビューを配置するときに再び必要になるので、それをメソッドにリファクタリングさせてください。

00:14:23.000 --> 00:14:27.000
次に、ビュー間の間隔を考慮する必要があります。

00:14:27.000 --> 00:14:33.000
10ポイントのような一定の間隔を使用できますが、レイアウトプロトコルにより、より良くすることができます。

00:14:33.000 --> 00:14:42.000
SwiftUIでは、すべてのビューには、ビューと次のビューの間に好むスペースの量を示す間隔設定があります。

00:14:42.000 --> 00:14:48.000
これらの設定は、レイアウトコンテナに使用できるViewSpacingインスタンスに保存されます。

00:14:48.000 --> 00:14:54.000
ビューは、異なるエッジで異なる値、さらには異なる種類の隣接するビューに対して異なる値を好むかもしれません。

00:14:54.000 --> 00:15:02.000
たとえば、ビューは、それ自体と画像の間に望むよりも、自分自身とテキストビューの間に多かれ少なかれスペースが必要になる場合があります。

00:15:02.000 --> 00:15:06.000
また、値はプラットフォームによっても異なる場合があります。

00:15:06.000 --> 00:15:26.000
レイアウトに理にかなっている場合は、これらの設定を無視できます。これは本質的に、カスタム間隔で組み込みスタックを初期化するときに起こることですが、独自のレイアウトでこれらの設定を尊重することは、Appleのインターフェイスガイドラインに自動的に従う結果を得るための良い方法であり、その結果、システムの残りの部分の外観と一致します。

00:15:26.000 --> 00:15:35.000
現在、すべてのビューにはすべてのエッジに環境設定があり、2つのビューをまとめると、共通のエッジの環境設定が一致しない可能性があります。

00:15:35.000 --> 00:15:39.000
これを解決するために、組み込みのレイアウトコンテナは2つの設定のうち大きい方を使用します。

00:15:39.000 --> 00:15:43.000
そして、私は自分のレイアウトで同じことをすることができます。

00:15:43.000 --> 00:15:50.000
サブビュープロキシは、特定の軸に沿った他のボタンに対する各ボタンの好ましい間隔を尋ねる方法を提供します。

00:15:50.000 --> 00:16:05.000
したがって、サブビューをスキャンし、各プロキシの間隔インスタンスの距離メソッドを呼び出して、水平軸に沿って次のビューの間隔インスタンスへの間隔を取得して、値の配列を作成させてください。

00:16:05.000 --> 00:16:11.000
この呼び出しは、共通のエッジに関する両方のビューの好みを考慮に入れます。

00:16:11.000 --> 00:16:22.000
この配列の最初の要素は、猫のボタンが金魚ボタンに水平にどれだけのスペースを望んでいるかを教えてくれ、次の要素は、金魚のボタンが犬のボタンにどれだけのスペースを望んでいるかを教えてくれます。

00:16:22.000 --> 00:16:28.000
比較するボタンがもうないので、配列の最後の要素を強制的にゼロにします。

00:16:28.000 --> 00:16:32.000
さて、それも後でメソッドにリファクタリングさせてください。

00:16:32.000 --> 00:16:41.000
これで、間隔値を組み合わせて合計間隔を見つけ、それを幅と高さの測定値で使用してサイズ値を返すことができます。

00:16:41.000 --> 00:16:49.000
これは、サブビューの理想的なサイズと各サブビューの好ましい間隔を考えると、私のレイアウトが必要とするサイズです。

00:16:49.000 --> 00:16:52.000
私が実装する必要があるもう1つの方法はplaceSubviewsです。

00:16:52.000 --> 00:17:01.000
前に述べたように、私はコンテナの境界と、ボタンを指示するために使用できるサブビュープロキシのコレクションの両方を取得します。

00:17:01.000 --> 00:17:10.000
まず、sizeThatFitsメソッドで行ったように、maxSizeと間隔配列を計算します。なぜなら、ここでもそれらの値が必要になるからです。

00:17:10.000 --> 00:17:18.000
次に、各サブビューに使用できるサイズ提案を作成します。今回は、理想的なサイズではなく、必要なサイズに基づいて作成します。

00:17:18.000 --> 00:17:23.000
すべてのボタンを同じサイズにしたいので、提案は1つだけ必要です。

00:17:23.000 --> 00:17:32.000
そして、私の境界の前縁として計算された最初のサブビューの水平寸法の開始位置と、ボタンの幅の半分を見つけます。

00:17:32.000 --> 00:17:39.000
原点がゼロであることを頼りにしているのではなく、代わりにminX値から始めていることに注意してください。

00:17:39.000 --> 00:17:52.000
最後に、各サブビュープロキシを調べて、ポイント、そのポイントがボタンの観点から何を表すかのステートメント、およびサイズ提案でその場所メソッドを呼び出すことができます。

00:17:52.000 --> 00:18:01.000
ループを通過するたびに、ビューの幅と次のビューペアの間隔で水平位置を更新し、次の反復の準備をします。

00:18:01.000 --> 00:18:02.000
そして、それだけです。

00:18:02.000 --> 00:18:07.000
では、この新しいビューレイアウトタイプを使用するとどうなるか見てみましょう。

00:18:07.000 --> 00:18:08.000
そして、そこにあります。

00:18:08.000 --> 00:18:18.000
組み込みのHStackと同じように、独自のカスタムレイアウトコンテナをインスタンス化し、ボタンはすべて同じ幅で水平に配置されます。

00:18:18.000 --> 00:18:27.000
さて、ここで少し立ち止まって、レイアウトプロトコルが過去にジオメトリリーダーを使用しようとした可能性のある問題をどのように解決するかについて話したいと思います。

00:18:27.000 --> 00:18:31.000
ジオメトリリーダーは、結局のところ、ビューサイズを測定するためのツールです。

00:18:31.000 --> 00:18:35.000
しかし、この場合は最良の選択ではありません。

00:18:35.000 --> 00:18:41.000
これは、ジオメトリリーダーがコンテナビューを測定し、そのサイズをサブビューに報告するように設計されているためです。

00:18:41.000 --> 00:18:45.000
次に、サブビューは情報を使用して独自のコンテンツを描画します。

00:18:45.000 --> 00:18:50.000
ジオメトリリーダーの使用目的では、情報が下方に流れることに注意してください。

00:18:50.000 --> 00:18:55.000
読者が行う測定は、独自のコンテナのレイアウトには影響しません。

00:18:55.000 --> 00:18:59.000
これは、コンテナでスケールするパスを描くなどに最適です。

00:18:59.000 --> 00:19:07.000
ジオメトリリーダーは、作業するスペースの量をパスロジックに伝え、サブビュー内のパスロジックはそれに応じて調整されます。

00:19:07.000 --> 00:19:14.000
コンテナのサイズを変更すると、ジオメトリリーダーが新しいサイズを通過するため、パスも変更されます。

00:19:14.000 --> 00:19:27.000
しかし、私のボタンについては、見やすくするためにここで1つに焦点を当てます。テキストビューを測定し、それを使用して、テキストビューのコンテナであるフレームを設定する方法を決定する必要があります。

00:19:27.000 --> 00:19:38.000
そのため、テキストビューにオーバーレイでジオメトリリーダーを追加して、コンテナを測定し、どういうわけか通常のフローの外で測定データをフレームに送り返すことができます。

00:19:38.000 --> 00:19:43.000
しかし、これを行うと、レイアウトエンジンをバイパスし、ループが発生する可能性があることに注意してください。

00:19:43.000 --> 00:19:51.000
リーダーはレイアウトを測定し、フレームを変更します。これにより、レイアウトが変更される可能性があり、別の測定が必要になる可能性があります。

00:19:51.000 --> 00:19:57.000
これでこれを機能させることは可能ですが、注意しないと、アプリをクラッシュさせる可能性があります。

00:19:57.000 --> 00:20:00.000
その結果、この戦略は推奨されません。

00:20:00.000 --> 00:20:08.000
幸いなことに、レイアウトプロトコルは、レイアウトエンジン内で作業できるようにすることで、この問題を解決するためのより良い方法を提供します。

00:20:08.000 --> 00:20:10.000
さて、ボタンをもう一度見てみましょう。

00:20:10.000 --> 00:20:13.000
ここで他にやりたいことがあります。

00:20:13.000 --> 00:20:18.000
まず、これを少し読みやすくするために、ボタンを独自のサブビューにリファクタリングします。

00:20:18.000 --> 00:20:23.000
今、私はたまたま私の同僚の一人が彼らのデバイスでより大きなタイプを使用していることを知っています。

00:20:23.000 --> 00:20:30.000
デフォルトのフォントを使用しているので、私のアプリは自動的にダイナミックタイプをサポートしているので、私はほとんど無料で正しい動作を得るべきです。

00:20:30.000 --> 00:20:35.000
タイプサイズを大きくしたらどうなるか見てみましょう。

00:20:35.000 --> 00:20:37.000
ああ、ボタンはもう収まりません。

00:20:37.000 --> 00:20:47.000
私のカスタムスタックはボタンの幅を制限するのではなく、理想的なサイズを持つだけで、この場合はディスプレイの幅を超えることを忘れないでください。

00:20:47.000 --> 00:20:48.000
それで、私は何ができますか?

00:20:48.000 --> 00:20:56.000
さて、レイアウトのコンテナからのサイズ提案を考慮して、ビューが収まらないときに、より複雑なことをするためにレイアウトを変更することができます。

00:20:56.000 --> 00:21:01.000
しかし、この場合、新しいViewThatFitsコンテナを使用して、ほとんどの作業を行うことができます。

00:21:01.000 --> 00:21:09.000
この新しいタイプは、私が与えるビューのリストから、利用可能なスペースに収まる最初のビューを選択します。

00:21:09.000 --> 00:21:20.000
カスタムスタックをViewThatFits構造でラップし、同じコンテンツの垂直スタックバージョンを追加することで、SwiftUIにボタンを別の方法で配置する必要があるタイミングを把握させることができます。

00:21:20.000 --> 00:21:31.000
もちろん、組み込みのVStackは、私のカスタム水平スタックと同じ幅プロパティを持っていないので、私は先に進み、カスタムスタックの垂直バージョンも実装しました。

00:21:31.000 --> 00:21:41.000
すでに説明したものと非常によく似ていますが、水平軸ではなく垂直軸に沿って等しい幅の項目を配置します。

00:21:41.000 --> 00:21:47.000
そしてもちろん、動的タイプサイズのオーバーライドを削除すると、水平レイアウトに戻ります。

00:21:47.000 --> 00:21:52.000
さて、私が構築する必要があるアプリの最後の部分があり、それは上部の画像です。

00:21:52.000 --> 00:21:59.000
プロフィール写真のグループを見せるなど、簡単なことをすることができますが、少し楽しめると思いました。

00:21:59.000 --> 00:22:08.000
そこで、円形の配置でビューを描画し、ランキングに従って配置を回転させる別のカスタムレイアウトタイプを作成しました。

00:22:08.000 --> 00:22:13.000
したがって、この構成は金魚が1位で、他の2匹が2位に並んでいることを示しています。

00:22:13.000 --> 00:22:17.000
そして、犬が猫の前を引っ張るなら、私はそれを示すために少し回転することができます。

00:22:17.000 --> 00:22:23.000
または、放射状のレイアウトを回転させることで、もう少し現実的な結果を示すことができます。

00:22:23.000 --> 00:22:27.000
このレイアウトの作成は、実際にはレイアウトプロトコルで非常に簡単です。

00:22:27.000 --> 00:22:30.000
以前と同じように、私は2つの方法が必要です。

00:22:30.000 --> 00:22:37.000
フィットするサイズについては、ビューが利用可能なスペースを埋めたいので、コンテナビューが提案するサイズを返します。

00:22:37.000 --> 00:22:44.000
指定されていない寸法の置き換え方法を使用して、提案を具体的なサイズに変換します。

00:22:44.000 --> 00:22:50.000
このメソッドは、コンテナが理想的なサイズを要求した場合に存在する可能性のあるnil値を自動的に処理します。

00:22:50.000 --> 00:23:03.000
次に、場所サブビューメソッド内で、各サブビューを中央からレイアウト領域のサイズに基づく半径でオフセットし、ビューのインデックスに依存する回転を適用します。

00:23:03.000 --> 00:23:12.000
ベースラインとして、これはビューを円の周りの0、1、および3分の2に配置します。

00:23:12.000 --> 00:23:18.000
現在のランキングを反映するために、すべてのビューに等しく影響するオフセットも適用します。

00:23:18.000 --> 00:23:20.000
しかし、ランキングはどこで入手できますか?

00:23:20.000 --> 00:23:27.000
私のレイアウトはサブビュープロキシにのみアクセスでき、ビューにアクセスできず、データモデルは言うまでもありません。

00:23:27.000 --> 00:23:31.000
さて、レイアウトプロトコルには別のトリックがあることが判明しました。

00:23:31.000 --> 00:23:37.000
これにより、各サブビューに値を格納し、レイアウトプロトコルメソッド内から値を読み取ることができます。

00:23:37.000 --> 00:23:41.000
それを使ってランク情報を伝える方法を見てみましょう。

00:23:41.000 --> 00:23:48.000
まず、LayoutValueKeyプロトコルに準拠した新しい型を宣言し、デフォルト値を与えます。

00:23:48.000 --> 00:23:59.000
明示的に設定していないときにビューに値を提供することに加えて、デフォルト値は関連する値の型を確立します。この場合は整数です。

00:23:59.000 --> 00:24:07.000
次に、Viewに便利なメソッドを作成して、layoutValueビュー修飾子を使用して値を設定します。

00:24:07.000 --> 00:24:13.000
ビュー階層では、便利なランク修飾子をレイアウトのビューに適用できます。

00:24:13.000 --> 00:24:20.000
ここでは、各ペットのランクを計算し、ラジアルレイアウト内のペットの対応するアバタービューに追加します。

00:24:20.000 --> 00:24:31.000
最後に、私の場所のサブビューメソッドに戻って、レイアウト値キーをインデックスとして使用して、各サブビューから値を読み取るためのコードを追加できます。

00:24:31.000 --> 00:24:34.000
そして、ランクを使ってオフセットを計算することができます。

00:24:34.000 --> 00:24:40.000
私はここでその論理を通過しませんが、それは基本的にランキングの任意の可能なセットのための適切な角度を生成します。

00:24:40.000 --> 00:24:43.000
まあ、1つを除いてすべて。

00:24:43.000 --> 00:24:45.000
3ウェイタイがある場合はどうなりますか? どうなりますか?

00:24:45.000 --> 00:24:53.000
レイアウトを回転させてすべてのビューを1行に表示する方法はないので、その場合はまったく異なるレイアウトロジックを置き換える必要があります。

00:24:53.000 --> 00:24:58.000
しかし、これを行うレイアウトタイプはすでにあり、それは組み込みのHStackです。

00:24:58.000 --> 00:25:03.000
だから、私が本当に欲しいのは、3方向のタイを検出したときにHStackに移行することです。

00:25:03.000 --> 00:25:07.000
そして、そのための新しいツールもあることが判明しました。

00:25:07.000 --> 00:25:17.000
AnyLayoutタイプを使用すると、単一のビュー階層に異なるレイアウトを適用できるため、あるレイアウトタイプから別のレイアウトタイプに移行する際にビューのアイデンティティを維持できます。

00:25:17.000 --> 00:25:27.000
だから、ここには私たちが前に見た放射状のレイアウトがあり、私がしなければならないのは、3方向のネクタイがあるかどうかに依存する新しいレイアウトタイプに置き換えることだけです。

00:25:27.000 --> 00:25:36.000
isThreeWayTieプロパティは状態から派生しているため、SwiftUIは変更されたときに気づき、このビューを再描画する必要があることを認識します。

00:25:36.000 --> 00:25:46.000
しかし、ビュー階層の構造的アイデンティティは常に同じままであるため、SwiftUIはこれを新しいビューではなく、変化するビューと見なしています。

00:25:46.000 --> 00:25:52.000
その結果、あと1行だけで、レイアウトタイプ間のスムーズなトランジションを作成できます。

00:25:52.000 --> 00:26:03.000
実際、アニメーションビュー修飾子を追加することで、ラジアルレイアウトの構成は同じデータに依存するため、ラジアルレイアウトのすべての異なる状態間のアニメーションも取得します。

00:26:03.000 --> 00:26:06.000
そして、これがすべての行動のように見えます。

00:26:06.000 --> 00:26:17.000
投票数を変更するためにさまざまなボタンをタップすると、アバターがどのようにスムーズに動き回り、現在の順位を反映しているかがわかります。

00:26:17.000 --> 00:26:23.000
したがって、これらはSwiftUIがアプリのビューレイアウトを作成するための新しいツールの一部です。

00:26:23.000 --> 00:26:28.000
グリッドタイプを使用して、静的情報の高度にカスタマイズ可能な2次元レイアウトを構築できます。

00:26:28.000 --> 00:26:36.000
レイアウトプロトコルを使用して、独自の汎用、再利用可能なレイアウト、または特定のユースケースをターゲットとするレイアウトを定義できます。

00:26:36.000 --> 00:26:43.000
利用可能なスペースに最も合うようにSwiftUIがビューのグループから選択できるようにする場合は、ViewThatFitsを使用できます。

00:26:43.000 --> 00:26:48.000
また、AnyLayoutを使用してレイアウトタイプ間をシームレスに移行できます。

00:26:48.000 --> 23:59:59.000
今日は参加してくれてありがとう、そしてあなたが私と同じくらいこれらの新しいレイアウトツールで遊ぶのを楽しんでいることを願っています。

