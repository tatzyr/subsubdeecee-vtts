WEBVTT

00:00:00.000 -> 00:00:12.000
- こんにちは。私はXcodeチームのデザイナー、ジェイクです。

00:00:12.000 -> 00:00:16.000
マルチプラットフォームアプリ開発は、Xcode 14で次のレベルに引き上げられています。

00:00:16.000 -> 00:00:29.000
単一のアプリターゲットは、単一の共通のコードベースを維持し、デフォルトで設定を共有し、必要に応じて条件付けする新しい方法を可能にしながら、複数のプラットフォームでさらに多くの目的地をサポートできるようになりました。

00:00:29.000 -> 00:00:36.000
まず、マルチプラットフォームアプリのターゲットとは何か、そしてどのケースで最も効果的かについて説明します。

00:00:36.000 -> 00:00:47.000
次に、複数の目的地とプラットフォームをサポートするようにプロジェクトを変更し、プロジェクトを更新して新しいプラットフォームで構築して実行します。

00:00:47.000 -> 00:00:52.000
サポートされている各プラットフォームでアプリが素晴らしく見えるようにします...

00:00:52.000 -> 00:00:57.000
そして最後に、Xcode Cloudをプロジェクトの変更と統合します。

00:00:57.000 -> 00:01:02.000
まず、アプリが複数のプラットフォームをサポートできるようにするために、どのテクニックを使いたいかを理解しましょう。

00:01:02.000 -> 00:01:10.000
Xcode 14の前に、アプリがiOSとmacOSをサポートしたい場合は、2つの別々のターゲットが必要になります。

00:01:10.000 -> 00:01:22.000
これは、プロジェクトが著しく異なるコードベースを必要とする場合、異なるプラットフォーム間で設定をほとんど共有しない場合、または各アプリターゲットが異なる基盤技術に大きく依存している場合に最適です。

00:01:22.000 -> 00:01:29.000
それが今日のあなたのプロジェクトにまだ当てはまるなら、あなたの最善の策は、プラットフォームごとに別々のターゲットを使い続けることです。

00:01:29.000 -> 00:01:37.000
Xcode 14では、単一のアプリターゲットがiPhone、iPad、Mac、Apple TVなどの多くの目的地のサポートを宣言できます。

00:01:37.000 -> 00:01:45.000
これは、共通のコードベースを使用し、必要なときにカスタマイズしながら、すべての目的地でほとんどの設定を共有するアプリに最適です。

00:01:45.000 -> 00:01:49.000
Xcode 14でマルチプラットフォームアプリがどのように機能するかを見てみましょう。

00:01:49.000 -> 00:01:58.000
ゼロから始める場合、始めるのに最適な方法は、Xcodeで新しいプロジェクトを作成するときに、新しく改良されたマルチプラットフォームアプリテンプレートを使用することです。

00:01:58.000 -> 00:02:08.000
マルチプラットフォームアプリテンプレートは、ライフサイクルとインターフェイスにSwiftUIを使用し、iPhone、iPad、Macをサポートするようにデフォルトで設定されたターゲットから始めます。

00:02:08.000 -> 00:02:11.000
これは新しいプロジェクトのための素晴らしい構成です。

00:02:11.000 -> 00:02:22.000
SwiftUIを使用しているため、各プラットフォームのSDKの完全な機能セットにアクセスでき、各プラットフォームが提供するものを利用する素晴らしい新しいアプリを作成できます。

00:02:22.000 -> 00:02:32.000
既存のプロジェクトは、アプリターゲットの複数の宛先のサポートを宣言し、SwiftUIを使用して各プラットフォームのSDKのフルパワーにアクセスすることもできます。

00:02:32.000 -> 00:02:37.000
既存のiOSアプリにMacのデスティネーションを追加する方法を見てみましょう。

00:02:37.000 -> 00:02:42.000
私はフードトラックアプリを構築してきましたが、iPhoneとiPadでうまく機能します。

00:02:42.000 -> 00:02:48.000
私はこのiOSアプリにかなり満足しています、そして今、私はそれをMacに持ち込み、プラットフォームとその機能を取り入れたいです。

00:02:48.000 -> 00:02:54.000
私たちのプロジェクトがXcodeでどのように見えるかを見てみましょう。

00:02:54.000 -> 00:03:00.000
私のアプリのターゲットを見ると、私のアプリがサポートしているすべての目的地のリストを見ることができます。

00:03:00.000 -> 00:03:05.000
あなたは私がすでにMacの目的地を持っていることがわかります - iPad用に設計されています。

00:03:05.000 -> 00:03:09.000
これにより、Appleシリコンを搭載したMacコンピュータは、私の未変更のiOSアプリを実行できます。

00:03:09.000 -> 00:03:15.000
これはMacのサポートを始めるのに最適な方法ですが、Macのサポートを次のレベルに引き上げたいです。

00:03:15.000 -> 00:03:20.000
いわば「Mac用に設計された」体験を追加しましょう。

00:03:20.000 -> 00:03:26.000
サポートされている目的地のリストを簡単に編集し、Macの目的地をアプリに追加できます。

00:03:26.000 -> 00:03:36.000
Macの目的地にはいくつかのオプションがあります：Mac、Mac Catalyst、およびDesigned for iPad、私のアプリはすでにそれをサポートしているため、最後のものはグレー表示されています。

00:03:36.000 -> 00:03:41.000
MacとMac Catalystの選択は、主にどの技術が最も使用に興味があるかに落ち着きます。

00:03:41.000 -> 00:03:52.000
私たちのアプリがアプリの中核でUIKitやストーリーボードを多用した場合、Mac Catalystは既存のiPadアプリを互換性のあるMacアプリに変換する素晴らしい方法です。

00:03:52.000 -> 00:03:59.000
しかし、私たちのアプリはSwiftUIを使用しているため、「Macオプション」は、私たちのMacアプリを作成するための最良の選択になります。

00:03:59.000 -> 00:04:07.000
制限なくmacOS SDKのフルパワーで、箱から出してすぐに素晴らしいMacのルックアンドフィールを手に入れます。

00:04:07.000 -> 00:04:14.000
つまり、その柔軟性が必要な場合は、iOSアプリでUIKitを使用し、macOSアプリでAppKitを自由に使用できます。

00:04:14.000 -> 00:04:19.000
そのすべてを念頭に置いて、SwiftUIで作業するための最良の選択肢であるMacを選びましょう。

00:04:19.000 -> 00:04:26.000
私が選択すると、XcodeはMacサポートのために私のプロジェクトを準備するために必要ないくつかの変更を私に警告します。

00:04:26.000 -> 00:04:32.000
この場合、XcodeはMacでサポートされている依存関係とフレームワークのみを含むようにターゲットを更新します。

00:04:32.000 -> 00:04:40.000
Xcodeが私のコードを変更しないことに注意することが重要ですので、Macで利用できないAPIを呼び出している場合は、それらの問題を自分で解決する必要があります。

00:04:40.000 -> 00:04:45.000
Macのオプションを選択すると、サポートされている目的地のリストに追加されます。

00:04:45.000 -> 00:04:50.000
Xcodeで開発しているときに、複数のMacの目的地を持つことは完全に有効です。

00:04:50.000 -> 00:04:57.000
これは、「Mac Catalyst」または「Designed for iPad」から完全なMacアプリに移行する場合に特に便利です。

00:04:57.000 -> 00:05:02.000
これは、Xcode内で各Mac製品のテストを継続できることを意味します。

00:05:02.000 -> 00:05:07.000
そして、私のアプリを開発するとき、私は必ずしも単一の選択肢に制限されているわけではありません。

00:05:07.000 -> 00:05:19.000
ただし、ネイティブのMacアプリをApp Storeに公開すると、Designed for iPadアプリは顧客が利用できなくなるため、Xcodeはこの目的地を削除する簡単な方法を提供します。

00:05:19.000 -> 00:05:24.000
しかし、ネイティブのMacの経験に満足したら、この目的地を削除することを検討します。

00:05:24.000 -> 00:05:33.000
ゼロから始める場合でも、既存のアプリに新しい目的地を追加する場合でも、Xcodeで単一のターゲットを使用すると、デフォルトでコードとビルド設定を共有できます。

00:05:33.000 -> 00:05:40.000
アプリの表示名や最小展開バージョンなど、個々の設定をカスタマイズしたい場合があります。

00:05:40.000 -> 00:05:45.000
Xcode 14の改良されたターゲットエディタでそれを行う方法を見てみましょう。

00:05:45.000 -> 00:05:50.000
多くのアプリのターゲット設定には、その値を条件付ける方法が含まれるようになりました。

00:05:50.000 -> 00:05:57.000
サポートされている設定では、プロジェクトの各ビルド設定のデフォルト値を設定できるエディタを表示できます。

00:05:57.000 -> 00:06:04.000
追加したカスタムベータ構成と、新しいXcodeプロジェクトに付属する標準のデバッグおよびリリース構成があります。

00:06:04.000 -> 00:06:11.000
ベータ構成で構築されたときにアプリに別の表示名を付けたいので、ここで名前を編集できます。

00:06:11.000 -> 00:06:19.000
入力すると、Xcodeのアプリの表示名が、表示名が持つことができるすべての可能な値の読み出しに置き換えられていることがわかります。

00:06:19.000 -> 00:06:25.000
必要に応じて、条件を追加して、使用されているSDKに基づいて値を指定することもできます。

00:06:25.000 -> 00:06:32.000
これにより、Mac用にビルドするときにベータ設定に特定の名前を設定すると言うことができます。

00:06:32.000 -> 00:06:35.000
さて、一般タブで行いたい編集は終わったと思います。

00:06:35.000 -> 00:06:42.000
その他の変更が必要な場合は、「署名と機能」タブを見てみましょう。 必要な変更はありません。

00:06:42.000 -> 00:06:47.000
良いニュースは、自動署名がオンになっているので、余分な手順がないことです。

00:06:47.000 -> 00:06:53.000
Macの宛先を追加すると、私に代わってMacに必要な署名証明書とプロビジョニングプロファイルが生成されました。

00:06:53.000 -> 00:07:05.000
私のiOSとmacOSの両方のアプリ製品は、デフォルトで同じバンドル識別子を使用しています。これは素晴らしいです。なぜなら、App Storeに公開すると、ユニバーサル購入で利用可能になるからです。

00:07:05.000 -> 00:07:10.000
だから、私のiOSアプリを購入する人々は、私のMacアプリも自動的に取得します。

00:07:10.000 -> 00:07:14.000
私のアプリは、プッシュ通知などの機能も利用しています。

00:07:14.000 -> 00:07:21.000
私のmacOSアプリに適用可能なiOSアプリに使用している機能は、私からの余分な作業なしで適用されます。

00:07:21.000 -> 00:07:25.000
それらは単一の資格ファイルにまとめられたりもします。

00:07:25.000 -> 00:07:31.000
アプリに複数の目的地のサポートを追加したので、次の目標はそれを構築することです。

00:07:31.000 -> 00:07:38.000
特に新しいMacサポートのように、新しいSDKが関与している場合は、新しい目的地のアプリの構築に問題が発生するのが普通です。

00:07:38.000 -> 00:07:41.000
では、これらの一般的な問題のいくつかを見てみましょう。

00:07:41.000 -> 00:07:44.000
一部のフレームワークは、すべてのプラットフォームで利用できるわけではありません。

00:07:44.000 -> 00:07:49.000
利用できないフレームワークをインポートまたはリンクしていないことを確認する必要があります。

00:07:49.000 -> 00:08:00.000
新しい宛先のサポートを追加するとき、Xcodeはコードを変更しないので、アプリの設定を条件付けする方法と同様に、SDKに基づいてコードを条件付けする必要があることを忘れないでください。

00:08:00.000 -> 00:08:02.000
これはAPIにも当てはまります。

00:08:02.000 -> 00:08:06.000
一部の機能は、どのSDKで構築しているかに基づいて利用できないとマークされています。

00:08:06.000 -> 00:08:14.000
Swiftは、コードの一部を条件付けして、構築しているSDKで利用可能な機能のみを含める方法を提供します。

00:08:14.000 -> 00:08:20.000
Xcodeでは、一部のSDK用にビルドするときに個々のファイルをコンパイルする必要があるかどうかを指定することもできます。

00:08:20.000 -> 00:08:24.000
もし私が今プロジェクトを構築したら...

00:08:24.000 -> 00:08:26.000
私は何の問題も見当たりません。

00:08:26.000 -> 00:08:32.000
それは、iOS SDKを使用するツールバーでまだ目的地が選択されているからです。

00:08:32.000 -> 00:08:40.000
macOS SDKに対してビルドするには、リストから「My Mac」を選択する必要があります。

00:08:40.000 -> 00:08:45.000
建物は今、いくつかの新しい問題を明らかにし、私たちが予想したように、それらは主に可用性に関連しています。

00:08:45.000 -> 00:08:51.000
私のファイルの1つで、Macでは利用できないARKitをインポートしています。

00:08:51.000 -> 00:08:58.000
このインポートステートメントを#if canImportでラップして、条件付き化することができます。

00:08:58.000 -> 00:09:06.000
これは、フレームワークが利用可能な既知のプラットフォームのリストを管理したくない場合や、単に利用できない場合は含めないでくださいと言う場合に便利です。

00:09:06.000 -> 00:09:15.000
しかし、私はまだこのファイル全体でARKitを使用しているので、SDKのファイル全体を条件付きにする方が理にかなっている場合があります。

00:09:15.000 -> 00:09:24.000
ターゲットに戻って[ビルドフェーズ]タブに移動すると、ファイルを検索できます。

00:09:24.000 -> 00:09:35.000
そして、iOS用にのみコンパイルする必要があると指定してください。

00:09:35.000 -> 00:09:45.000
ビルド後、これらの変更を加えると、Xcodeは新しい問題を報告します。Macで利用可能なフレームワークであるSwiftUIには、利用できないとマークされている機能があります。

00:09:45.000 -> 00:09:54.000
具体的には、iOSでEditModeを使用して、ユーザーが編集を行い、テーブルとリストのコンテンツを選択できるようにしていますが、macOSではEditModeは存在しません!

00:09:54.000 -> 00:10:01.000
ユーザーはすでにMacでコンテンツの行を自由に選択して編集できるので、このコードがiOSでのみ実行されていることを確認しましょう。

00:10:01.000 -> 00:10:07.000
私は自分の環境プロパティと、以下のEditModeを使用していた場所を条件付きにすることができます。

00:10:07.000 -> 00:10:14.000
さて、このonChange修飾子のように、このプロパティを使用していた場所も条件付けされていることを確認する必要があります。

00:10:14.000 -> 00:10:19.000
修飾子全体を「if os」条件でラップできます。

00:10:19.000 -> 00:10:28.000
そして最後に、ツールバーのEditButtonビューを使用していますが、これもiOSのみです。

00:10:28.000 -> 00:10:33.000
さて、私たちのアプリを実行してみましょう。

00:10:33.000 -> 00:10:37.000
ああ！生きてる！私たちのアプリは現在、Mac上で構築され、実行されています!

00:10:37.000 -> 00:10:42.000
私たちのアプリが新しいプラットフォームで構築され、実行されているからといって、私たちの仕事が終わったわけではありません。

00:10:42.000 -> 00:10:49.000
新しいプラットフォームのユーザーが期待するものに合わせて、アプリ体験を洗練したい場合があります。

00:10:49.000 -> 00:10:53.000
また、iOSのみの機能をトリミングすることは、私たちの旅の終わりではありません。

00:10:53.000 -> 00:10:56.000
これで、macOS SDKのすべての機能で遊べます。

00:10:56.000 -> 00:11:03.000
私のアプリがMacで実行されているのを見たので、新しい文脈では自然に感じられない私のアプリの癖に気づいています。

00:11:03.000 -> 00:11:07.000
このグリッドビューのこれらのドーナツは大きすぎるようです!

00:11:07.000 -> 00:11:10.000
それは、私たちのグリッドアイテムがタッチ用に設計されたからです。

00:11:10.000 -> 00:11:19.000
このような状況は、UI要素のポイントサイズを宣言したり、単一のプラットフォームのみを念頭に置いてコントロールをカスタマイズしたりするときに発生します。

00:11:19.000 -> 00:11:27.000
Macでは、はるかに正確なポインティングデバイスを持っているので、ボタンやサムネイルをそれほど大きくする必要はありません。

00:11:27.000 -> 00:11:33.000
これは、私たちが構築しているSDKに基づいて変化するように、私たちのプロジェクトの定数を条件付ける素晴らしいケースです。

00:11:33.000 -> 00:11:41.000
アプリを他のプラットフォームに持ち込むときは、新しいプラットフォームの期待でこれらの選択肢の多くを再考することが重要です。

00:11:41.000 -> 00:11:45.000
構築するSDKに基づいて、別の値を指定することを見てみましょう。

00:11:45.000 -> 00:11:52.000
私がよく使うテクニックの1つは、定数を計算されたプロパティにし、「#if os」を使用して返されるものを条件付けることです。

00:11:52.000 -> 00:11:58.000
これを計算されたプロパティに変換し、以前は定数だったものを返しましょう...

00:11:58.000 -> 00:12:11.000
しかし、iOSでのみその値を返します。

00:12:11.000 -> 00:12:21.000
ああ、80はもっと自然なサイズに感じます。

00:12:21.000 -> 00:12:29.000
さて、macOS SDKの使用については、SwiftUIには、独自のUI要素をメニューバーに追加できるクールな新機能があります。

00:12:29.000 -> 00:12:34.000
アプリのサマリービューがあり、ユーザーがすばやく簡単にアクセスできるようにしたいと思っています。

00:12:34.000 -> 00:12:41.000
アプリ宣言に行きましょう。ここで、メニューバーエクストラに新しいシーンを追加できます。

00:12:41.000 -> 00:12:48.000
ただし、これはmacOSのみの機能であるため、macOS SDK用に条件付けする必要があります。

00:12:48.000 -> 00:12:54.000
構築して実行して見てみましょう。

00:12:54.000 -> 00:12:57.000
ああ、かっこいい、私のトラックのアイコンがメニューバーに表示されました。

00:12:57.000 -> 00:13:03.000
素晴らしい、今、私のMacユーザーは、メニューバーから直接今日の情報を一目見ることができます。

00:13:03.000 -> 00:13:09.000
SwiftUIを使用すると、各プラットフォームの完全なSDKにアクセスでき、その素晴らしい機能を利用することができます。

00:13:09.000 -> 00:13:18.000
アプリを他のプラットフォームに持ち込むときは、新しいプラットフォームのコンテキストで作業する際に、多くの過去の選択肢を再考する必要があることが多いことに注意することが重要です。

00:13:18.000 -> 00:13:22.000
SwiftUIは、プラットフォームの期待値をAPIに直接焼き込みます。

00:13:22.000 -> 00:13:27.000
多くのインターフェイス要素は、各プラットフォームで見栄えのよい自動外観を得るでしょう。

00:13:27.000 -> 00:13:38.000
逆に、つまり、コントロールやUIの他の部分を大量にカスタマイズすると、自動スタイリングを失う可能性があるので、UIがどこでも素晴らしく見えることを常に再確認する必要があります。

00:13:38.000 -> 00:13:45.000
とはいえ、クールなアプリを構築する際に、ヒューマンインターフェースガイドラインで定められたベストプラクティスに従っていることを確認する必要があります。

00:13:45.000 -> 00:13:56.000
アプリのローカル変更に満足したので、アプリ製品をアーカイブしてApp Store Connectにアップロードします。これはXcodeから行うか、Xcode Cloudで自動化することができます。

00:13:56.000 -> 00:14:02.000
準備ができたら、TestFlightの内部および外部のテスターとアプリを共有し、App Storeにリリースすることができます。

00:14:02.000 -> 00:14:05.000
製品をApp Store Connectにアップロードするには、製品をアーカイブする必要があります。

00:14:05.000 -> 00:14:10.000
単一のターゲットを持っているからといって、単一の製品しかないわけではありません。

00:14:10.000 -> 00:14:15.000
各プラットフォームをアーカイブし、個別にアップロードする必要があります。

00:14:15.000 -> 00:14:22.000
ローカルで構築およびアーカイブする場合は、アーカイブを作成するSDKを持つ宛先を選択する必要があります。

00:14:22.000 -> 00:14:32.000
macOSアプリを作成したい場合は、目的地のリストから「My Mac」を選択する必要があります。それ以外の場合は、iOSアプリを作成するためにiOSデバイスを選択します。

00:14:32.000 -> 00:14:39.000
宛先を選択したら、「製品アーカイブ」を選択してアーカイブを作成できます。

00:14:39.000 -> 00:14:45.000
アーカイブが完了したら、Xcodeのオーガナイザーウィンドウを使用してApp Store Connectにアップロードできます。

00:14:45.000 -> 00:14:51.000
Xcode Cloudを使用している場合は、ワークフローにアクションを追加して、製品を構築、テスト、アーカイブすることができます。

00:14:51.000 -> 00:15:00.000
ワークフローのアクションのリストでは、各製品を構築、テスト、分析、アーカイブするための新しいアイテムを作成できます。

00:15:00.000 -> 00:15:03.000
この場合、私はiOSアプリとmacOSアプリを持っています。

00:15:03.000 -> 00:15:17.000
さらに一歩進んで、App Store Connectへのアプリのアップロードを自動化するための展開準備を含めることができ、それらのビルドをすぐに社内のTestFlightチームに送信し、プレスからホットな変更に関するフィードバックを受け取り始めることもできます。

00:15:17.000 -> 00:15:28.000
要約すると、Xcode 14は、複数のプラットフォームでさらに多くの目的地をサポートできる合理化されたアプリターゲットで、マルチプラットフォームアプリ開発を次のレベルに引き上げます。

00:15:28.000 -> 00:15:34.000
単一のアプリターゲットで、デフォルトで共通のコードベースと共有設定を維持できます。

00:15:34.000 -> 00:15:43.000
実証されたように、私たちはニーズに基づいて設定とコードを条件付けすることができ、プラットフォームの期待に最も合うようにアプリをカスタマイズすることができます。

00:15:43.000 -> 00:15:44.000
残りはあなた次第です。

00:15:44.000 -> 00:15:50.000
今年のXcodeの新機能と改善点の詳細については、「Xcodeの新機能」をご覧ください。

00:15:50.000 -> 23:59:59.000
XcodeとSwiftUIの力で、あなたがどんな素晴らしいアイデアに命を吹き込むかを見るのが待ちきれません。

