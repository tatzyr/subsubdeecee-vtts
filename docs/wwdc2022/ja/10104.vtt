WEBVTT

00:00:00.000 --> 00:00:03.000
♪インストゥルメンタルヒップホップ音楽♪

00:00:03.000 --> 00:00:10.000
♪

00:00:10.000 --> 00:00:14.000
こんにちは、私の名前はJaideep Joshiで、AppleのGPUソフトウェアエンジニアです。

00:00:14.000 --> 00:00:23.000
このセッションでは、ゲームやアプリのリソース読み込みを簡素化および最適化するMetal 3の新機能を紹介します。

00:00:23.000 --> 00:00:30.000
まず、高速リソースロード機能がアプリのアセットローディングパイプラインにどのように適合するかをお見せします。

00:00:30.000 --> 00:00:36.000
Apple製品の新しいストレージ技術を活用するいくつかの重要な機能があります。

00:00:36.000 --> 00:00:43.000
高速リソースの読み込みには、アプリケーションが遭遇する可能性のある興味深いシナリオを解決するいくつかの高度な機能があります。

00:00:43.000 --> 00:00:52.000
アプリでこれらの機能を効果的に使用するのに役立つ、知っておくべきベストプラクティスの推奨事項がいくつかあります。

00:00:52.000 --> 00:01:02.000
アプリに高速なリソースロードを追加すると、Metal System TraceやGPUデバッガなどのツールは、遭遇する可能性のある問題のプロファイリングと修正に役立ちます。

00:01:02.000 --> 00:01:09.000
最後に、高速なリソースの読み込みを示す例を見ていきます。

00:01:09.000 --> 00:01:15.000
メタル3の高速リソースローディングでできることは次のとおりです。

00:01:15.000 --> 00:01:30.000
Metal 3の高速リソースロードにより、ゲームやアプリは、AppleシリコンユニファイドメモリアーキテクチャとAppleプラットフォームに含まれている高速SSDストレージを活用することで、低レイテンシと高スループットでアセットをロードできます。

00:01:30.000 --> 00:01:38.000
ゲームの資産が時間通りに準備ができていることを確認するために、データをストリーミングし、ロード時間を短縮する最良の方法を学びます。

00:01:38.000 --> 00:01:45.000
ロード時間を短縮する重要な側面は、可能な限り最小の粒度で必要なものだけをロードすることです。

00:01:45.000 --> 00:01:56.000
Metal 3の高スループットと低レイテンシにより、アプリはテクスチャ、オーディオ、ジオメトリデータなど、より高品質のアセットをストリーミングできます。

00:01:56.000 --> 00:02:01.000
次に、ゲームでのアセットロードの例を説明します。

00:02:01.000 --> 00:02:10.000
ゲームは通常、最初の起動時、または新しいレベルの開始時にロード画面が表示されるので、ゲームのアセットをメモリにロードできます。

00:02:10.000 --> 00:02:16.000
プレイヤーがレベルを移動するにつれて、ゲームはシーンのより多くのアセットをロードします。

00:02:16.000 --> 00:02:25.000
欠点は、ゲームがアセットを事前にロードするためにストレージシステムに複数の要求をしている間、プレイヤーが長時間待たなければならないことです。

00:02:25.000 --> 00:02:29.000
さらに、これらの資産は大きなメモリフットプリントを持つことができます。

00:02:29.000 --> 00:02:34.000
この経験を改善する方法はいくつかあります。

00:02:34.000 --> 00:02:40.000
ゲームは、プレイヤーがオブジェクトに近づくにつれてオブジェクトを動的にストリーミングすることで、この体験を向上させることができます。

00:02:40.000 --> 00:02:49.000
このようにして、ゲームは最初に必要なものだけをロードし、プレイヤーがレベルを移動するにつれて徐々に他のリソースをストリーミングします。

00:02:49.000 --> 00:03:00.000
たとえば、ゲームは最初にこの黒板を低解像度でロードしますが、プレイヤーがそれに向かって歩くと、ゲームは高解像度バージョンをロードします。

00:03:00.000 --> 00:03:05.000
このアプローチは、プレイヤーがロード画面で待つ時間を短縮します。

00:03:05.000 --> 00:03:16.000
ただし、プレイヤーは、高解像度バージョンを読み込むのに時間がかかりすぎるため、近くにいてもシーン内の低解像度のアイテムが表示される場合があります。

00:03:16.000 --> 00:03:23.000
これに対処する1つの方法は、各資産の小さな部分をストリーミングすることです。

00:03:23.000 --> 00:03:32.000
たとえば、ゲームは、全体のミップレベルではなく、タイルをストリーミングするまばらなテクスチャでシーンの可視領域のみを読み込むことができます。

00:03:32.000 --> 00:03:37.000
これにより、アプリがストリーミングする必要があるデータ量が大幅に削減されます。

00:03:37.000 --> 00:03:41.000
そのアプローチでは、負荷要求は小さくなり、より多くのものがあります。

00:03:41.000 --> 00:03:48.000
しかし、最新のストレージハードウェアは一度に複数のロード要求を実行できるので、それは大丈夫です。

00:03:48.000 --> 00:03:55.000
これは、ゲームプレイを損なうことなく、シーンの解像度とスケールを上げることができることを意味します。

00:03:55.000 --> 00:04:06.000
多数の少量のリクエストを発行するだけでなく、負荷リクエストに優先順位を付けて、優先度の高いリクエストが時間内に完了するようにすることもできます。

00:04:06.000 --> 00:04:16.000
ロード時間を短縮しながらゲームの視覚的忠実度を高める方法を取り上げたので、Metal 3の高速リソースロードがこれを行うのにどのように役立つかをお見せします。

00:04:16.000 --> 00:04:22.000
高速リソースロードは、ストレージからリソースをロードする非同期APIです。

00:04:22.000 --> 00:04:29.000
既存のロードAPIとは異なり、ロードを発行するスレッドは、ロードが完了するのを待つ必要はありません。

00:04:29.000 --> 00:04:36.000
負荷操作は、より高速なストレージのスループットをよりよく活用するために同時に実行されます。

00:04:36.000 --> 00:04:42.000
バッチロード操作により、リソースロードのオーバーヘッドをさらに最小限に抑えることができます。

00:04:42.000 --> 00:04:48.000
そして最後に、Metal 3では、低レイテンシのために負荷操作に優先順位を付けることができます。

00:04:48.000 --> 00:04:56.000
次に、リソースをロードする手順から始めて、アセットローディングパイプラインを構築するのに役立つ主な機能を紹介します。

00:04:56.000 --> 00:05:07.000
リソースをロードするには、ファイルを開き、必要なロードコマンドを発行し、これらのロードコマンドをレンダリング作業と同期させる3つのステップがあります。

00:05:07.000 --> 00:05:10.000
ファイルを開くことから始めて、その方法は次のとおりです。

00:05:10.000 --> 00:05:16.000
既存のファイルは、Metalデバイスインスタンスでファイルハンドルを作成することで開きます。

00:05:16.000 --> 00:05:28.000
たとえば、このコードはMetalデバイスインスタンスを使用して、ファイルパスURLを使用して新しいmakeIOHandleメソッドを呼び出してファイルハンドルを作成します。

00:05:28.000 --> 00:05:33.000
ファイルハンドルを取得したら、それを使用してロードコマンドを発行できます。

00:05:33.000 --> 00:05:40.000
これは、ロード操作を実行し、GPU作業をエンコードするアプリケーションの典型的なシナリオです。

00:05:40.000 --> 00:05:46.000
既存のロードAPIでは、アプリはレンダリング作業をエンコードする前に、ロード作業が完了するのを待たなければなりません。

00:05:46.000 --> 00:05:51.000
Metal 3を使用すると、アプリがロードコマンドを非同期に実行できます。

00:05:51.000 --> 00:05:55.000
Metal IOコマンドキューを作成することから始めます。

00:05:55.000 --> 00:06:02.000
次に、そのキューを使用してIOコマンドバッファを作成し、それらのバッファにロードコマンドをエンコードします。

00:06:02.000 --> 00:06:12.000
ただし、コマンドバッファはコマンドキューで非同期に実行されるため、アプリはロード操作が終了するのを待つ必要はありません。

00:06:12.000 --> 00:06:22.000
実際、IOコマンドバッファ内のすべてのコマンドが同時に実行されるだけでなく、IOコマンドバッファ自体が同時に実行され、順不同で完了します。

00:06:22.000 --> 00:06:30.000
この同時実行モデルは、スループットを最大化することで、より高速なストレージハードウェアをよりよく利用します。

00:06:30.000 --> 00:06:49.000
3種類のIOコマンドをコマンドバッファにエンコードできます。テクスチャストリーミング用のMetalテクスチャにロードされるloadTexture、シーンまたはジオメトリデータをストリーミングするためのMetalバッファにロードされるloadBuffer、およびCPUアクセス可能なメモリにロードされるloadBytesです。

00:06:49.000 --> 00:06:53.000
IOコマンドキューからIOコマンドバッファを作成します。

00:06:53.000 --> 00:06:59.000
キューを作成するには、まずIOコマンドキュー記述子を作成して設定します。

00:06:59.000 --> 00:07:08.000
デフォルトでは、キューは並行していますが、コマンドバッファを連続して完全に順番に実行するように設定することもできます。

00:07:08.000 --> 00:07:16.000
次に、キュー記述子をMetalデバイスインスタンスのmakeIOCommandQueueメソッドに渡します。

00:07:16.000 --> 00:07:22.000
コマンドキューのmakeCommandBufferメソッドを呼び出して、IOコマンドバッファを作成します。

00:07:22.000 --> 00:07:29.000
次に、そのコマンドバッファを使用して、テクスチャとバッファをロードするロードコマンドをエンコードします。

00:07:29.000 --> 00:07:33.000
Metalの検証レイヤーは、実行時にエンコーディングエラーをキャッチします。

00:07:33.000 --> 00:07:39.000
loadコマンドは、以前に作成されたfileHandleインスタンスを使用するものです。

00:07:39.000 --> 00:07:49.000
コマンドバッファへのロードコマンドの追加が完了したら、コマンドバッファのコミットメソッドを呼び出して、実行のためにキューに送信します。

00:07:49.000 --> 00:08:01.000
IOコマンドキュー、コマンドバッファを作成し、ロードコマンドを発行し、キューに送信する方法を説明したので、ロード作業を他のGPU作業と同期させる方法を紹介したいと思います。

00:08:01.000 --> 00:08:08.000
アプリは通常、そのレンダリングのリソースの読み込みが完了した後、レンダリング作業を開始します。

00:08:08.000 --> 00:08:17.000
しかし、高速リソースロードを使用するアプリでは、IOコマンドキューをレンダリングコマンドキューと同期させる方法が必要です。

00:08:17.000 --> 00:08:21.000
これらのキューをMetal共有イベントと同期させることができます。

00:08:21.000 --> 00:08:30.000
Metal haredイベントでは、IOキューのコマンドバッファをレンダリングキューのコマンドバッファと同期させることができます。

00:08:30.000 --> 00:08:35.000
waitEventコマンドをエンコードすることで、共有イベントを待つようにコマンドバッファに指示できます。

00:08:35.000 --> 00:08:42.000
同様に、signalEventコマンドをエンコードすることで、そのコマンドバッファに共有イベントを通知するように指示できます。

00:08:42.000 --> 00:08:50.000
Metalは、共有イベントに信号を送る前に、コマンドバッファ内のすべてのIOコマンドが完了していることを確認します。

00:08:50.000 --> 00:08:55.000
コマンドバッファ間で同期するには、まずMetal共有イベントが必要です。

00:08:55.000 --> 00:09:01.000
waitForEventメソッドを呼び出すことで、共有イベントを待つようにコマンドバッファに指示できます。

00:09:01.000 --> 00:09:07.000
同様に、signalEventメソッドを呼び出すことで、共有イベントにシグナルを送るようにコマンドバッファに指示することができます。

00:09:07.000 --> 00:09:15.000
対応するGPUコマンドバッファに同様のロジックを追加して、IOコマンドバッファが同じ共有イベントにシグナルを送るのを待つことができます。

00:09:15.000 --> 00:09:21.000
要約すると、Metalアプリにリソースをロードする主な機能とAPIを次に示します。

00:09:21.000 --> 00:09:25.000
Metalファイルハンドルを作成してファイルを開きます。

00:09:25.000 --> 00:09:30.000
IOコマンドキューとIOコマンドバッファを作成して、ロードコマンドを発行します。

00:09:30.000 --> 00:09:36.000
次に、ロードコマンドをコマンドバッファにエンコードして、キューで実行します。

00:09:36.000 --> 00:09:43.000
最後に、Metal共有イベントでwaitとsignalEventコマンドを使用して、ロードとレンダリングを同期します。

00:09:43.000 --> 00:09:48.000
さて、あなたが役に立つかもしれないいくつかの高度な機能について説明します。

00:09:48.000 --> 00:09:56.000
これは、ゲームがマップ全体をメモリに収めることができない典型的なシナリオであり、それがマップを地域に細分化する理由です。

00:09:56.000 --> 00:10:02.000
プレイヤーがマップを進むと、ゲームはマップの領域をプリロードし始めます。

00:10:02.000 --> 00:10:10.000
プレイヤーの方向性に基づいて、ゲームはプリロードするのに最適な領域が北西、西、南西の地域であると判断します。

00:10:10.000 --> 00:10:18.000
しかし、プレイヤーが西部地域に移動して南に向かい始めると、北西部地域をプリロードすることはもはや有益ではありません。

00:10:18.000 --> 00:10:25.000
将来の負荷の待ち時間を減らすために、Metal 3では負荷操作のキャンセルを試みることができます。

00:10:25.000 --> 00:10:29.000
実際にそれを行う方法を見てみましょう。

00:10:29.000 --> 00:10:36.000
プレーヤーが中央領域にいるときは、3つの領域のIOコマンドバッファをエンコードしてコミットします。

00:10:36.000 --> 00:10:44.000
次に、プレイヤーが西部地域にいて南に向かうときは、tryCancelメソッドを使用して北西部地域の負荷をキャンセルします。

00:10:44.000 --> 00:10:51.000
キャンセルはコマンドバッファの粒度にあるため、コマンドバッファの実行中にキャンセルできます。

00:10:51.000 --> 00:11:00.000
後で、リージョンが完全にロードされたかどうかを知りたい場合は、コマンドバッファのステータスを確認できます。

00:11:00.000 --> 00:11:05.000
Metal 3では、IO作業に優先順位を付けることもできます。

00:11:05.000 --> 00:11:14.000
プレイヤーがシーンの新しい部分にテレポートし、ゲームが大量のグラフィックアセットでストリーミングを開始するゲームのシナリオを考えてみましょう。

00:11:14.000 --> 00:11:19.000
同時に、ゲームはテレポーテーション効果音を再生する必要があります。

00:11:19.000 --> 00:11:25.000
高速リソース読み込みにより、オーディオデータを含むすべてのアプリのアセットをロードできます。

00:11:25.000 --> 00:11:32.000
オーディオをロードするには、前述のloadBytesコマンドを使用して、アプリケーションに割り当てられたメモリにロードできます。

00:11:32.000 --> 00:11:40.000
この例では、テクスチャとオーディオIOコマンドバッファが単一のIOコマンドキューで同時に実行されています。

00:11:40.000 --> 00:11:45.000
この簡略化された図は、ストレージ層での要求を示しています。

00:11:45.000 --> 00:11:50.000
ストレージシステムは、オーディオとテクスチャの両方のロード要求を並行して実行できます。

00:11:50.000 --> 00:11:58.000
オーディオの遅延を避けるために、ストリーミングシステムがテクスチャ要求よりもオーディオ要求を優先できることが重要です。

00:11:58.000 --> 00:12:06.000
オーディオ要求に優先順位を付けるには、別のIOコマンドキューを作成し、その優先順位を高く設定できます。

00:12:06.000 --> 00:12:15.000
ストレージシステムは、優先度の高いIOリクエストのレイテンシが低く、他のリクエストよりも優先されることを保証します。

00:12:15.000 --> 00:12:28.000
オーディオアセット用に別の優先度の高いキューを作成した後、オーディオロード要求の実行時間は小さくなり、並列テクスチャロード要求の実行時間は大きくなりました。

00:12:28.000 --> 00:12:31.000
優先度の高いキューを作成する方法は次のとおりです。

00:12:31.000 --> 00:12:36.000
コマンドキュー記述子の優先度プロパティをhighに設定するだけです。

00:12:36.000 --> 00:12:44.000
優先順位を通常または低に設定し、通常どおり記述子から新しいIOコマンドキューを作成することもできます。

00:12:44.000 --> 00:12:49.000
作成後にキューの優先度を変更できないことを覚えておいてください。

00:12:49.000 --> 00:12:56.000
アプリに高速なリソース読み込みを追加すると、心に留めておくべきベストプラクティスがいくつかあります。

00:12:56.000 --> 00:12:59.000
まず、資産を圧縮することを検討してください。

00:12:59.000 --> 00:13:05.000
組み込み圧縮またはカスタム圧縮を使用して、アプリのディスクフットプリントを削減できます。

00:13:05.000 --> 00:13:10.000
圧縮を使用すると、ランタイムパフォーマンスをより小さなディスクフットプリントと交換できます。

00:13:10.000 --> 00:13:17.000
さらに、スパーステクスチャを使用するときにスパースページサイズを調整することで、ストレージのスループットを向上させることができます。

00:13:17.000 --> 00:13:22.000
圧縮から始めて、これらのそれぞれをより詳細に説明します。

00:13:22.000 --> 00:13:28.000
Metals 3のAPIを使用して、アセットファイルをオフラインで圧縮できます。

00:13:28.000 --> 00:13:35.000
まず、圧縮コンテキストを作成し、チャンクサイズと圧縮方法で設定します。

00:13:35.000 --> 00:13:42.000
次に、アセットファイルの一部をコンテキストに渡して、すべてのファイルの単一の圧縮バージョンを生成します。

00:13:42.000 --> 00:13:51.000
圧縮コンテキストは、すべてのデータをチャンクすることで機能し、選択したコーデックで圧縮し、パックファイルに保存します。

00:13:51.000 --> 00:14:03.000
この例では、コンテキストは64Kチャンクでデータを圧縮しますが、圧縮するデータのサイズとタイプに基づいて適切なチャンクサイズを選択できます。

00:14:03.000 --> 00:14:08.000
Metal 3での圧縮APIの使用方法は次のとおりです。

00:14:08.000 --> 00:14:16.000
まず、圧縮ファイルを作成するためのパス、圧縮方法、およびチャンクサイズを提供して、圧縮コンテキストを作成します。

00:14:16.000 --> 00:14:20.000
次に、ファイルデータを取得し、コンテキストに追加します。

00:14:20.000 --> 00:14:24.000
ここでは、ファイルデータはNSDataオブジェクトにあります。

00:14:24.000 --> 00:14:31.000
データを追加するために複数の呼び出しを行うことで、異なるファイルからデータを追加できます。

00:14:31.000 --> 00:14:40.000
データの追加が完了したら、フラッシュアンドデバイズ圧縮コンテキスト関数を呼び出して、圧縮ファイルを確定して保存します。

00:14:40.000 --> 00:14:45.000
ファイルハンドルを作成することで、圧縮ファイルを開いてアクセスできます。

00:14:45.000 --> 00:14:49.000
このファイルハンドルは、ロードコマンドを発行するときに使用されます。

00:14:49.000 --> 00:15:00.000
圧縮ファイルの場合、Metal 3は、オフセットを解凍する必要があるチャンクのリストに変換してインライン解凍を実行し、リソースにロードします。

00:15:00.000 --> 00:15:05.000
メタルデバイスインスタンスでファイルハンドルを作成します。

00:15:05.000 --> 00:15:16.000
たとえば、このコードはMetalデバイスインスタンスを使用して、先ほど説明したmakeIOHandleメソッドに圧縮ファイルパスを提供することで、ファイルハンドルを作成します。

00:15:16.000 --> 00:15:21.000
圧縮ファイルの場合、追加のパラメータは圧縮方法です。

00:15:21.000 --> 00:15:26.000
これは、圧縮ファイルの作成時に使用したのと同じ圧縮方法です。

00:15:26.000 --> 00:15:36.000
次に、サポートされているさまざまな圧縮方法とそれぞれの特性について説明しますので、それらの間で選択する方法をよりよく理解できます。

00:15:36.000 --> 00:15:42.000
解凍速度が重要であり、アプリが大きなディスクフットプリントを買える場合は、LZ4を使用してください。

00:15:42.000 --> 00:15:51.000
コーデックの速度と圧縮率のバランスが重要な場合は、ZLib、LZBitmap、またはLZFSEを使用してください。

00:15:51.000 --> 00:15:56.000
バランスの取れたコーデックの中で、ZLibはApple以外のデバイスでよりうまく機能します。

00:15:56.000 --> 00:16:04.000
LZBitmapはエンコードとデコードが速く、LZFSEは圧縮率が高い。

00:16:04.000 --> 00:16:14.000
最適な圧縮率が必要な場合は、アプリがアセットをデコードするのにかかる余分な時間余裕がある場合は、LZMAコーデックの使用を検討してください。

00:16:14.000 --> 00:16:18.000
独自の圧縮スキームを使用することも可能です。

00:16:18.000 --> 00:16:23.000
データがカスタム圧縮コーデックの恩恵を受ける場合があります。

00:16:23.000 --> 00:16:33.000
その場合、圧縮コンテキストを独自のコンプレッサーに置き換え、オフセットを変換し、実行時に解凍を実行できます。

00:16:33.000 --> 00:16:40.000
圧縮を使用してディスクフットプリントを削減する方法を見たので、スパースページサイズのチューニングを見てみましょう。

00:16:40.000 --> 00:16:47.000
以前のバージョンのMetalは、16Kの粒度で希薄なテクスチャにタイルをロードすることをサポートしています。

00:16:47.000 --> 00:16:54.000
メタル3では、64と256Kの2つの新しいスパースタイルサイズを指定できます。

00:16:54.000 --> 00:17:02.000
これらの新しいサイズにより、より大きな粒度でテクスチャをストリーミングして、ストレージハードウェアをより有効に活用し、飽和させることができます。

00:17:02.000 --> 00:17:16.000
より大きなタイルサイズのストリーミングとストリーミングするデータ量の間にはトレードオフがあるため、どのサイズがアプリとそのまばらなテクスチャに最も適しているかを試してみる必要があることに注意してください。

00:17:16.000 --> 00:17:24.000
次に、Metal Developer Toolsのセットを使用して、アプリの高速リソース読み込みをプロファイリングおよびデバッグする方法を見てみましょう。

00:17:24.000 --> 00:17:28.000
Xcode 14には、高速リソース読み込みのフルサポートが含まれています。

00:17:28.000 --> 00:17:39.000
Metal System Traceによるランタイムプロファイリングから、MetalデバッガによるAPIインスペクションと高度な依存関係分析まで。

00:17:39.000 --> 00:17:42.000
ランタイムプロファイリングから始めましょう。

00:17:42.000 --> 00:17:48.000
Xcode 14では、InstrumentsはMetal System Traceテンプレートを使用して高速リソースロードをプロファイリングできます。

00:17:48.000 --> 00:17:56.000
Instrumentsは、Metalアプリで最高のパフォーマンスを達成するのに役立つ強力な分析およびプロファイリングツールです。

00:17:56.000 --> 00:18:02.000
Metal System Traceテンプレートを使用すると、ロード操作がいつエンコードされ、実行されるかを確認できます。

00:18:02.000 --> 00:18:10.000
アプリがCPUとGPUの両方で実行しているアクティビティとどのように相関しているかを理解することができます。

00:18:10.000 --> 00:18:23.000
InstrumentsでMetalアプリをプロファイリングする方法については、以前のセッション「GPUカウンターでMetalアプリとゲームを最適化する」と「Apple GPU用のハイエンドゲームを最適化する」をご覧ください。

00:18:23.000 --> 00:18:26.000
では、ギアをデバッグに切り替えましょう。

00:18:26.000 --> 00:18:33.000
Xcode 14のMetalデバッガを使用すると、新しい高速リソースロードAPIのゲームの使用を分析できるようになりました。

00:18:33.000 --> 00:18:40.000
フレームキャプチャを取得すると、すべての高速リソースロードAPI呼び出しを検査できるようになります。

00:18:40.000 --> 00:18:46.000
作成されたIOコマンドバッファから、発行されたロード操作まで。

00:18:46.000 --> 00:18:53.000
新しい依存関係ビューアを使用して、高速リソース読み込みの依存関係を目視で検査できるようになりました。

00:18:53.000 --> 00:19:01.000
依存関係ビューアは、IOコマンドバッファとMetalパス間のリソース依存関係の詳細な概要を提供します。

00:19:01.000 --> 00:19:13.000
ここから、新しい同期エッジやグラフフィルタリングなど、新しい依存関係ビューアのすべての機能を使用して、リソースの読み込み依存関係を深く掘り下げ、最適化することができます。

00:19:13.000 --> 00:19:22.000
Xcode 14の新しい依存関係ビューアの詳細については、今年の「Go bindless with Metal 3」セッションをご覧ください。

00:19:22.000 --> 00:19:26.000
では、動作中の高速リソースロードを見てみましょう。

00:19:26.000 --> 00:19:35.000
これは、新しい高速リソースロードAPIを使用して、16キロバイトのタイルサイズのスパーステクスチャを使用してテクスチャデータをストリーミングするテストシーンです。

00:19:35.000 --> 00:19:38.000
このビデオは、M1 Proチップを搭載したMacBook Proからのものです。

00:19:38.000 --> 00:19:49.000
ストリーミングシステムは、GPUのスパーステクスチャアクセスカウンタを照会して、サンプリングしたがロードされていないタイルと、アプリが使用していないロードされたタイルの2つのものを識別します。

00:19:49.000 --> 00:19:57.000
アプリはこの情報を使用して、必要なタイルのロードのリストと、必要のないタイルの立ち退きのリストをエンコードします。

00:19:57.000 --> 00:20:03.000
そうすれば、作業セットには、アプリが使用する可能性が高いタイルのみが含まれています。

00:20:03.000 --> 00:20:11.000
プレイヤーがシーンの別の部分に移動することを決定した場合、アプリはまったく新しい高解像度テクスチャのセットでストリーミングする必要があります。

00:20:11.000 --> 00:20:17.000
ストリーミングシステムが十分に高速であれば、プレイヤーはこのストリーミングが発生していることに気付かないでしょう。

00:20:17.000 --> 00:20:21.000
シーンを一時停止すると、画像の違いをより明確に観察できます。

00:20:21.000 --> 00:20:26.000
左側は、pread APIを使用して1つのスレッドにスパースタイルをロードしています。

00:20:26.000 --> 00:20:31.000
右側は、高速リソースロードAPIを使用してスパースタイルをロードしています。

00:20:31.000 --> 00:20:36.000
プレイヤーがシーンに入ると、ほとんどのテクスチャが完全に読み込まれていません。

00:20:36.000 --> 00:20:42.000
ロードが完了すると、テクスチャの最終的な高解像度バージョンが表示されます。

00:20:42.000 --> 00:20:51.000
このシーンの冒頭に戻って速度を落とすと、高速リソースの読み込みが提供する改善に気づきやすくなります。

00:20:51.000 --> 00:20:59.000
違いを強調するために、このレンダリングは、アプリがまだ赤い色合いでロードされていないタイルをマークします。

00:20:59.000 --> 00:21:05.000
最初は、シーンはアプリがほとんどのタイルをロードしていないことを示しています。

00:21:05.000 --> 00:21:18.000
ただし、プレイヤーがシーンに入ると、高速リソースロードは、高解像度タイルのロードを改善し、シングルスレッドのプリアドバージョンと比較して遅延を最小限に抑えます。

00:21:18.000 --> 00:21:28.000
Metal 3の高速リソースロードは、アプリが最新のストレージ技術を活用できる強力で効率的なアセットストリーミングシステムを構築するのに役立ちます。

00:21:28.000 --> 00:21:35.000
高品質の画像を含め、アセットをちょうど間に合うようにストリーミングすることで、ロード時間を短縮するために使用します。

00:21:35.000 --> 00:21:43.000
GPUがシーンをレンダリングしている間、Metalの共有イベントを使用してアセットを非同期にロードします。

00:21:43.000 --> 00:21:51.000
アプリが急いで必要とするアセットについては、優先度の高いコマンドキューを作成することで、待ち時間を最小限に抑えます。

00:21:51.000 --> 00:21:56.000
そして、ロードコマンドを早期に送信することで、ストレージシステムをビジー状態に保つことを忘れないでください。

00:21:56.000 --> 00:22:00.000
必要のないものはいつでもキャンセルできます。

00:22:00.000 --> 00:22:09.000
Metal 3の高速リソースロードは、高スループットの資産ロードのために最新のストレージハードウェアのパワーを活用する新しい方法を導入します。

00:22:09.000 --> 00:22:15.000
これらの機能を使用して、アプリの視覚的な品質と応答性を向上させる方法を見るのが待ちきれません。

00:22:15.000 --> 00:22:17.000
見てくれてありがとう。

00:22:17.000 --> 23:59:59.000
♪

