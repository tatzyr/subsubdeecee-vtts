WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:15.000
Vaibhav Gautam：こんにちは、私はVaibhav Gautamで、ソフトウェアパワーチームのエンジニアです。

00:00:15.000 --> 00:00:22.000
アプリは、使用日を通してさまざまな重要な機能を提供するため、人々の生活を豊かにします。

00:00:22.000 --> 00:00:26.000
しかし、この使用には、バッテリーの消耗というコストがかかる可能性があります。

00:00:26.000 --> 00:00:37.000
したがって、ユーザーがデバイスとアプリをより長く使用できるように、アプリのバッテリー寿命を向上させるために特別な注意を払うことが重要です。

00:00:37.000 --> 00:00:51.000
消費電力を理解するために、さまざまなシステムコンポーネントを深く研究しています。このセッションでは、アプリのバッテリー寿命を大幅に向上させるために実行できる、特定した4つの重要なアクションについて説明します。

00:00:51.000 --> 00:01:03.000
これらは、アプリのダークモード、フレームレートの監査、バックグラウンド時間の制限、アプリの作業の延期です。

00:01:03.000 --> 00:01:06.000
まず、ダークモードについて話します。

00:01:06.000 --> 00:01:14.000
ダークモードはiOS 13で導入され、誰かがより暗いプレゼンテーションでデバイスを設定することができます。

00:01:14.000 --> 00:01:24.000
ダークモードのパーソナライゼーションの利点に精通しているかもしれませんが、バッテリーの寿命にも劇的に影響する可能性があります。

00:01:24.000 --> 00:01:35.000
これは、iPhone 13や13 ProなどのOLEDディスプレイを搭載したデバイスでは、暗いコンテンツが軽いコンテンツよりも消費電力が少ないためです。

00:01:35.000 --> 00:01:45.000
OLEDスクリーンでは、各ピクセルは個々の電力を必要とし、暗い色の場合、ピクセルを照らすのに必要な電力は少なくなります。

00:01:45.000 --> 00:01:52.000
システム内のすべてのコンポーネントの中で、ディスプレイは主要な消費電力源の1つです。

00:01:52.000 --> 00:02:00.000
実際、一般的なユースケースでは、ディスプレイがバッテリーの消耗の主な要因になる可能性があります。

00:02:00.000 --> 00:02:04.000
ディスプレイの消費電力に影響を与える方法があります。

00:02:04.000 --> 00:02:08.000
そして1つの方法は、ダークモードを採用することです。

00:02:08.000 --> 00:02:14.000
私のチームが取り組んでいるフードトラックアプリを例として使用します。

00:02:14.000 --> 00:02:21.000
このアプリは、画面の大部分を占める非常に目立つ背景色を持っています。

00:02:21.000 --> 00:02:29.000
ダークモードで表示すると、この背景色はライトモードバージョンよりもはるかに暗くなり、バッテリーの節約に大きく貢献します。

00:02:29.000 --> 00:02:38.000
実際、このような場合、結果として最大70%のディスプレイ電力節約が予想されます。

00:02:38.000 --> 00:02:41.000
これは大きな節約です!

00:02:41.000 --> 00:02:46.000
そして、画面の明るさが高いと、バッテリーの節約はさらに高くなります。

00:02:46.000 --> 00:02:56.000
ダークモードを好むユーザーにとって、これはバッテリーの消耗を節約する絶好の機会であり、熱負荷も減らすことができます。

00:02:56.000 --> 00:03:03.000
ダークモードを採用するには、ダークモードが有効になっているときにアプリが現在どのように表示されるかを確認することから始めます。

00:03:03.000 --> 00:03:10.000
システムUIによりよく適合するために、アプリのどのコンポーネントを更新する必要があるかを把握してください。

00:03:10.000 --> 00:03:18.000
Xcodeは、アプリを構築するときに外観機能を使用することで、これを簡単にします。

00:03:18.000 --> 00:03:24.000
あなたのアプリはライトモードのみをサポートしているため、色にハードコードされている可能性があります。

00:03:24.000 --> 00:03:32.000
Xcodeで動的色を使用して、ライトモードとダークモードで背景色、画像、テキストをサポートします。

00:03:32.000 --> 00:03:40.000
システムは自動的に正しい色の値を使用し、モードが変更されると更新されます。

00:03:40.000 --> 00:03:46.000
アプリは、ライトモードとダークモードの代替画像もサポートする必要があります。

00:03:46.000 --> 00:03:57.000
ダークモード用のアプリのカスタマイズの詳細については、WWDC 2019の「iOSでのダークモードの実装」をご覧ください。

00:03:57.000 --> 00:04:06.000
アプリでダークモードを採用する方法がわかったので、ウェブコンテンツにダークモードを採用する方法も考える必要があります。

00:04:06.000 --> 00:04:14.000
Safariはウェブコンテンツを自動暗くしないので、ウェブコンテンツにもダークモードを採用してください。

00:04:14.000 --> 00:04:20.000
これを行うには、ウェブサイトのスタイルシートにカラースキームプロパティを実装します。

00:04:20.000 --> 00:04:31.000
これにより、Webページのデフォルトのテキストと背景色が、現在のシステムの外観、標準フォームコントロール、およびスクロールバーに一致させることができます。

00:04:31.000 --> 00:04:38.000
他の名前のシステムカラーは外観を変え、ライトモードとダークモードを切り替えます。

00:04:38.000 --> 00:04:44.000
スタイルシートで色が参照されている場所ならどこでも、スタイルシート変数の使用を開始します。

00:04:44.000 --> 00:04:51.000
これにより、デバイスがライトとダークを切り替えると、ウェブコンテンツの色を更新できます。

00:04:51.000 --> 00:05:00.000
異なるモードごとに異なるバリアントを使用して、Webページ上の画像やその他のメディアアセットに同じロジックを適用します。

00:05:00.000 --> 00:05:11.000
ウェブコンテンツにダークモードを実装する方法の詳細については、WWDC 2019の「ウェブコンテンツでダークモードをサポートする」を参照してください。

00:05:11.000 --> 00:05:17.000
アプリの電力使用量を減らすもう1つの方法は、フレームレートを監査することです。

00:05:17.000 --> 00:05:23.000
ProMotionディスプレイを搭載したデバイスでは、リフレッシュレートが消費電力に影響を与える可能性があります。

00:05:23.000 --> 00:05:26.000
より高いリフレッシュレートは、より高い電力を使用します。

00:05:26.000 --> 00:05:32.000
アプリ内のアニメーションのフレームレートは、ディスプレイのリフレッシュレートを決定します。

00:05:32.000 --> 00:05:42.000
アプリ内のすべてのコンテンツが高フレームレートを必要とするわけではないため、アプリの主要なコンテンツと必要なフレームレートを考慮してください。

00:05:42.000 --> 00:05:48.000
ディスプレイのリフレッシュレートは、アプリでフレームレートが最も高いアニメーションによって決まります。

00:05:48.000 --> 00:06:00.000
アプリには、必要以上に高い速度で更新される二次要素があり、アプリ全体が予想よりも多くのバッテリーを消費する可能性があります。

00:06:00.000 --> 00:06:03.000
ここに再びフードトラックアプリがあります。

00:06:03.000 --> 00:06:08.000
上部の主要なトラックのシーンは、毎秒30フレームでレンダリングされています。

00:06:08.000 --> 00:06:15.000
トラックの下には、水平にスクロールするテキストオーバーレイ「フードトラック」があります。

00:06:15.000 --> 00:06:19.000
このセカンダリテキストは毎秒60フレームでレンダリングされています。

00:06:19.000 --> 00:06:24.000
その結果、画面全体が毎秒60フレームでレンダリングされるようになりました。

00:06:24.000 --> 00:06:33.000
テキストアニメーションを30fpsに変更すると、画面全体が30fpsでレンダリングでき、バッテリーの消耗を最大20%節約できます。

00:06:33.000 --> 00:06:36.000
すごい！

00:06:36.000 --> 00:06:42.000
デバッグし、アプリのフレームレートに関する詳細情報を取得するには、Instrumentsを使用してください。

00:06:42.000 --> 00:06:51.000
CoreAnimation FPSインストゥルメントを使用して、時間の経過とともにアプリのフレームレートを示すタイムラインを表示します。

00:06:51.000 --> 00:06:54.000
主なユーザーシナリオを監査することから始めます。

00:06:54.000 --> 00:07:06.000
フレームが期待どおりにレンダリングされているかどうかを識別するには、画面上の二次要素がプライマリコンテンツよりも高いフレームレートを持っているかどうかを判断します。

00:07:06.000 --> 00:07:16.000
アプリは、iOSのCoreAnimationが提供するCADisplayLinkを使用して、カスタムアニメーションとカスタムレンダリングループを推進している可能性があります。

00:07:16.000 --> 00:07:21.000
CADisplayLinkは、ディスプレイのリフレッシュレートと同期したタイマーです。

00:07:21.000 --> 00:07:30.000
カスタム図面がリフレッシュイベントを認識できるように、必要なタイミング情報をアプリに提供します。

00:07:30.000 --> 00:07:37.000
アプリは、目的の画面のリフレッシュレートについてCADisplayLinkオブジェクトにヒントを与えることができます。

00:07:37.000 --> 00:07:47.000
CADisplayLinkのpreferredFrameRateRangeを設定し、最小、最大、および優先フレームレートを指定します。

00:07:47.000 --> 00:07:55.000
ディスプレイリンクは、システムが処理できるものに基づいて、好みのレートに最も近い利用可能なフレームレートを選択します。

00:07:55.000 --> 00:08:02.000
そのレートを提供できない場合は、指定された範囲内にとどまろうとします。

00:08:02.000 --> 00:08:07.000
表示リンクを設定するには、ターゲットとセレクタで初期化します。

00:08:07.000 --> 00:08:16.000
提供されたセレクターは、カスタムアニメーションを実行し、次に表示するビデオフレームを計算するために使用されます。

00:08:16.000 --> 00:08:20.000
表示リンクが初期化されたら、好みのフレームレート範囲を設定します。

00:08:20.000 --> 00:08:29.000
この例では、優先レートは30ですが、範囲は10から60の間のものを処理できます。

00:08:29.000 --> 00:08:34.000
最後に、現在の実行ループに表示リンクを追加します。

00:08:34.000 --> 00:08:39.000
アプリのバッテリー消費量について考えるときは、リフレッシュレートを念頭に置いてください。

00:08:39.000 --> 00:08:47.000
これは、非常にダイナミックなリフレッシュレートをサポートするProMotionディスプレイを搭載したデバイスにとって特に重要です。

00:08:47.000 --> 00:08:55.000
Instrumentsでアプリのフレームレートを監視し、アプリをリリースする前に問題を検出します。

00:08:55.000 --> 00:09:05.000
最後に、CADisplayLinkを使用してアプリのコンテンツのリフレッシュレートを制限して、システムに情報を提供します。

00:09:05.000 --> 00:09:15.000
フレームレートの最適化の詳細については、WWDC 2021の「可変リフレッシュレート表示の最適化」を参照してください。

00:09:15.000 --> 00:09:21.000
では、バックグラウンドで実行されているときにアプリの電源をダウンする方法について話しましょう。

00:09:21.000 --> 00:09:31.000
誰かがあなたのアプリから別のアプリに切り替えると、あなたのアプリはバックグラウンドで実行し続けるためにバックグラウンド実行APIに依存するかもしれません。

00:09:31.000 --> 00:09:39.000
バックグラウンドで実行している間、アプリは位置情報やオーディオなどの一般的なサービスを引き続き使用する可能性があります。

00:09:39.000 --> 00:09:49.000
これらのサービスを長時間実行するとバッテリーが消耗するので、アプリがバックグラウンドでこれらのサービスを使用している場合は、特に注意する必要があります!

00:09:49.000 --> 00:10:01.000
それでは、これらのモードを使用するときに余分なドレインを回避する方法について話しましょう。ロケーションサービスは、デバイスをスリープ状態に保ち、場所を継続的にストリーミングします。

00:10:01.000 --> 00:10:10.000
アプリはユーザーには見えませんが、バックグラウンドで場所を継続的にストリーミングし、余分なバッテリー消耗を引き起こす可能性があります。

00:10:10.000 --> 00:10:17.000
アプリのバックグラウンドロケーションセッションランタイムの上にいることを確認することが重要です。

00:10:17.000 --> 00:10:25.000
セッションが不要になった場合は、アプリがstopUpdatingLocation()を呼び出してセッションを停止することを確認してください。

00:10:25.000 --> 00:10:34.000
アプリ開発のさまざまな段階では、さまざまなツールを使用して、期待できない背景の場所の使用状況を調べることができます。

00:10:34.000 --> 00:10:43.000
アプリの構築とテスト中に、Xcodeゲージを使用して、システムのエネルギー使用量とバックグラウンドの場所の使用状況を調べることができます。

00:10:43.000 --> 00:10:51.000
リリース前にアプリをテストするときは、MetricKitを使用して、使用日の診断情報を収集できます。

00:10:51.000 --> 00:10:57.000
iOS 16の新機能は、コントロールセンターでの場所の使用です。

00:10:57.000 --> 00:11:05.000
Xcodeゲージは、CPU、ネットワーク、ロケーションの使用状況などのシステム使用状況に関する情報を提供します。

00:11:05.000 --> 00:11:11.000
Xcodeゲージは、アプリの場所の使用状況とエネルギーへの影響のタイムラインを表示します。

00:11:11.000 --> 00:11:20.000
このタイムラインビューを見ることは、停止が予想されるときに場所のランタイムが停止することを確認するのに最適な方法です。

00:11:20.000 --> 00:11:24.000
もう1つのツールは、アプリをテストするときにMetric Kitを使用することです。

00:11:24.000 --> 00:11:34.000
cumulativeBackgroundLocationTimeプロパティを使用して、アプリがバックグラウンドで位置情報サービスを積極的に使用していた期間を調べます。

00:11:34.000 --> 00:11:43.000
iOS 16の新機能で、ユーザーはコントロールセンターに移動することで、現在位置情報サービスを使用しているアプリを監視できます。

00:11:43.000 --> 00:11:49.000
上部のテキストをタップすると、位置情報を使用してアプリを詳細に表示できます。

00:11:49.000 --> 00:11:54.000
これを使用して、ロケーションランタイムに関するデスクからの洞察を得ることができます。

00:11:54.000 --> 00:12:03.000
ここにアプリが表示され、予期しない場合は、アプリにアクティブなロケーションストリーミングセッションがあることを示す指標です。

00:12:03.000 --> 00:12:07.000
オーディオセッションにも同じ原則を適用できます。

00:12:07.000 --> 00:12:15.000
オーディオプレーヤーを使用してファイルを再生し、ユーザーが再生を停止する音楽アプリがあるとしましょう。

00:12:15.000 --> 00:12:26.000
アプリはサウンドを一時停止または停止するだけでなく、アイドル状態の実行を防ぐためにオーディオエンジンを一時停止または停止する必要があります。

00:12:26.000 --> 00:12:35.000
AVAudioEngineクラスのautoShutdownEnabledプロパティを設定することで有効にできる自動シャットダウンモードを使用することをお勧めします。

00:12:35.000 --> 00:12:42.000
このモードでは、オーディオエンジンは一定期間アイドル状態かどうかを継続的に監視し、検出します。

00:12:42.000 --> 00:12:47.000
アイドル状態になると、エンジンはオーディオハードウェアをシャットダウンします。

00:12:47.000 --> 00:12:54.000
そして後で、いずれかのソースが再びアクティブになると、オーディオハードウェアが動的に起動します。

00:12:54.000 --> 00:12:57.000
そして、これはすべてボンネットの下で起こります。

00:12:57.000 --> 00:13:02.000
watchOSの自動シャットダウンモードは強制的な動作です。

00:13:02.000 --> 00:13:07.000
電力を節約するために、使用していないときはオーディオエンジンを必ず停止してください。

00:13:07.000 --> 00:13:13.000
バックグラウンドランタイムを制限する鍵は、完了したらシステムに伝えることを覚えておくことです。

00:13:13.000 --> 00:13:18.000
バッテリー寿命を改善するために取ることができる最後の行動は、作業を延期することです。

00:13:18.000 --> 00:13:24.000
一日を通して、あなたのアプリは多くの異なるタスクやデータを処理するかもしれません。

00:13:24.000 --> 00:13:37.000
この作業の一部は、画面上のコンテンツのレンダリングや、ユーザーがタップするオーディオやビデオの再生など、ユーザーのアクションにサービスを提供するためにすぐに行う必要があります。

00:13:37.000 --> 00:13:45.000
機械学習タスク、分析のアップロード、バックアップなどの他の作業は、それほど時間に敏感ではありません。

00:13:45.000 --> 00:13:56.000
この時間の無神経な作業を、デバイスが充電されているときに、より良い時間に延期すると、バッテリーを節約し、ユーザーが開始したインタラクティブな作業と競合することを避けることができます。

00:13:56.000 --> 00:14:01.000
これを達成するために使用できる3つのAPIについて話しましょう。

00:14:01.000 --> 00:14:07.000
BGProcessingTaskは、長時間実行されるタスクを延期するのに良い選択です。

00:14:07.000 --> 00:14:13.000
裁量的なURLSessionは、遅延可能なネットワーキングをスケジュールするのに最適です。

00:14:13.000 --> 00:14:19.000
また、適切なプッシュ優先度を活用することで、サーバーが適切なタイミングでプッシュを配信するのに役立ちます。

00:14:19.000 --> 00:14:22.000
それぞれについて詳しく説明しましょう。

00:14:22.000 --> 00:14:24.000
まずはBGProcessingTaskです。

00:14:24.000 --> 00:14:34.000
BGProcessingTaskを使用すると、デバイスが充電されているときなど、長時間の処理タスクをより良い時間に延期できます。

00:14:34.000 --> 00:14:41.000
データベースのクリーンアップ、バックアップの作成、機械学習トレーニングの実行などのタスクに最適です。

00:14:41.000 --> 00:14:50.000
それを使用するには、BGProcessingTaskRequest APIを使用してリクエストを作成し、アプリケーション識別子を提供するだけです。

00:14:50.000 --> 00:14:57.000
次に、タスクに外部電源やネットワークが必要かどうかなど、詳細情報を提供します。

00:14:57.000 --> 00:15:03.000
より多くの情報を提供することは、システムがより良い時間枠でタスクをスケジュールするのに役立ちます。

00:15:03.000 --> 00:15:12.000
その後、システムは適切なタイミングでバックグラウンドでアプリを起動し、遅延作業を完了するために数分のランタイムを許可します。

00:15:12.000 --> 00:15:16.000
次は裁量URLSessionです。

00:15:16.000 --> 00:15:22.000
あなたのアプリはすでに一般的なネットワーキングにバックグラウンドURLSessionsを使用している可能性があります。

00:15:22.000 --> 00:15:28.000
バックグラウンドURLセッションは、裁量フラグを使用するとさらに良くなります。

00:15:28.000 --> 00:15:42.000
裁量フラグ付きのURLSessionsは、デバイスが接続されてWi-Fiに接続されている場合など、より最適なタイミングでネットワーキングを実行するためにシステムにオフロードされたネットワークトランザクションです。

00:15:42.000 --> 00:15:54.000
裁量フラグは、テレメトリの収集やテレビ番組の次のエピソードのダウンロードなど、非ユーザーが開始した長時間のネットワーキングに最適です。

00:15:54.000 --> 00:16:03.000
また、ネットワークがオフロードされたため、ネットワークトランザクションが完了している間にアプリを実行する必要がないことを意味します。

00:16:03.000 --> 00:16:14.000
裁量URLセッションを使用するには、バックグラウンドURLセッションを設定し、isDiscretionaryをtrueに設定するだけです。

00:16:14.000 --> 00:16:20.000
システムが適切なタイミングでダウンロードをスケジュールするのに役立つ追加情報を提供できます。

00:16:20.000 --> 00:16:28.000
システムが永遠にダウンロードしようとしないようにタイムアウト間隔を渡し、バッテリーの消耗を引き起こします。

00:16:28.000 --> 00:16:36.000
後でどこかの時点までデータをアップロードまたはダウンロードしたくない場合は、最も早い開始日を渡してください。

00:16:36.000 --> 00:16:48.000
最後に、システムがさまざまなダウンロードタスク間でインテリジェントにロードバランスできるように、予想されるワークロードサイズを渡します。

00:16:48.000 --> 00:17:03.000
BGProcessingTaskと裁量URLセッションで特定の操作の即時性を制御する方法と同様に、異なるプッシュ優先順位を使用することで、プッシュ配信の即時性に影響を与えることができます。

00:17:03.000 --> 00:17:08.000
プッシュの優先順位は、プッシュをデバイスにどれだけ緊急に配信する必要があるかを決定します。

00:17:08.000 --> 00:17:18.000
優先度の高いプッシュの場合、サーバーはすぐにプッシュをデバイスに送信し、デバイスをスリープ解除してバッテリーの消耗を引き起こす可能性があります。

00:17:18.000 --> 00:17:29.000
低優先度プッシュの場合、サーバーは、デバイスが起動しているときや優先度の高いプッシュが通過するなど、適切な時間までプッシュの送信を遅らせます。

00:17:29.000 --> 00:17:34.000
優先度の高いプッシュは、厳しい気象警報のような緊急のメッセージに最適です。

00:17:34.000 --> 00:17:42.000
優先順位の低いプッシュは、緊急ではなく、延期できるより受動的な通知に最適です。

00:17:42.000 --> 00:17:52.000
優先度の低いプッシュを活用して、遅延メッセージの配信を遅らせると、デバイスが頻繁にスリープ状態から目を覚ます必要がないため、バッテリーを節約できます。

00:17:52.000 --> 00:17:59.000
低優先度のプッシュを設定するには、プッシュペイロードでapns-priorityを5に設定するだけです。

00:17:59.000 --> 00:18:06.000
サーバーが残りを処理し、ユーザーはバッテリー寿命の節約に感謝するでしょう。

00:18:06.000 --> 00:18:10.000
それでは、いくつかの最終的な考えと次のステップで締めくくりましょう。

00:18:10.000 --> 00:18:13.000
アプリでダークモードのオプションを提供します。

00:18:13.000 --> 00:18:18.000
ユーザーがダークモードを選択した場合、意図を尊重することでバッテリーを節約できます。

00:18:18.000 --> 00:18:25.000
アニメーションを見直し、フレームレートを必要なものに減らす機会を探してください。

00:18:25.000 --> 00:18:28.000
1つの小さなアニメーションが大きな影響を与える可能性があります。

00:18:28.000 --> 00:18:34.000
完了したらシステムに知らせることで、バックグラウンドランタイムを注意深く監視してください。

00:18:34.000 --> 00:18:42.000
最後に、デバイスが充電器に接続されている場合など、長時間のバックグラウンド作業をより良い時間に延期することを検討してください。

00:18:42.000 --> 00:18:47.000
これらすべてを行うと、本当にアプリの電源が切れます。

00:18:47.000 --> 23:59:59.000
どうもありがとうございます。

