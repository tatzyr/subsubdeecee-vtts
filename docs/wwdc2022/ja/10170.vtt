WEBVTT

00:00:00.000 -> 00:00:03.000
♪(まろやかなインストゥルメンタルヒップホップ音楽) ♪

00:00:03.000 -> 00:00:09.000
♪

00:00:09.000 -> 00:00:11.000
こんにちは、私の名前はマイケル・サムナーです。

00:00:11.000 -> 00:00:15.000
私はSiriとApp Intentsに取り組んでいるソフトウェアエンジニアです。

00:00:15.000 -> 00:00:22.000
このセッションでは、新しいApp Intentsフレームワークを使用して、アプリのアプリショートカットを作成することについてお話ししたいと思います。

00:00:22.000 -> 00:00:28.000
アプリショートカットとは何か、そしてそれらがアプリインテントとどのように関連しているかの概要から始めます。

00:00:28.000 -> 00:00:34.000
次に、Swiftでアプリのショートカットを作成し、パラメータを追加します。

00:00:34.000 -> 00:00:41.000
最後に、ユーザーがあなたのハードワークの恩恵を受けることができるように、アプリのショートカットを検出可能にする方法について説明します。

00:00:41.000 -> 00:00:46.000
アプリインテントフレームワークとアプリショートカットから始めましょう。

00:00:46.000 -> 00:00:53.000
人々はショートカットを使用して、ショートカットアプリやSiriから使用できるアプリでマルチステップのワークフローを作成します。

00:00:53.000 -> 00:01:02.000
今まで、誰かがあなたの意図を使用する前に、最初にSiriに追加ボタンまたはショートカットアプリを介してショートカットを設定しなければなりませんでした。

00:01:02.000 -> 00:01:08.000
ゼロユーザー設定を必要とするアプリショートカットを導入できることを嬉しく思います。

00:01:08.000 -> 00:01:12.000
これにより、人々があなたのショートカットの恩恵を受けることがこれまで以上に簡単になります。

00:01:12.000 -> 00:01:19.000
アプリショートカットと統合することで、アプリがインストールされるとすぐにアプリのインテントが利用可能になります。

00:01:19.000 -> 00:01:24.000
これにより、誰かがあなたのアプリの機能を簡単に発見して使用することができます。

00:01:24.000 -> 00:01:31.000
彼らはもはやショートカットアプリに向かう必要も、Siriに追加ボタンを使って何かを設定する必要もありません。

00:01:31.000 -> 00:01:38.000
アプリショートカットは、ユーザーが作成したショートカットと同様に、ショートカットアプリ、Spotlight、Siriから実行できます。

00:01:38.000 -> 00:01:44.000
これにより、システム内のさまざまな場所からアプリケーションを発見して操作する複数の方法が提供されます。

00:01:44.000 -> 00:01:52.000
たとえば、Spotlightで検索すると、アプリのショートカットが検索結果に表示され、簡単にアクセスできます。

00:01:52.000 -> 00:02:03.000
アプリショートカットを実装することで、ユーザーは迅速かつ軽量なインタラクションでアプリと対話することができ、タスクを完了して自分の道を行くのが簡単になります。

00:02:03.000 -> 00:02:13.000
私のチームは、ユーザーが重要なことに集中できるように、一連の音声プロンプトと音を案内することで、ユーザーが瞑想するのに役立つアプリ「瞑想」に取り組んでいます。

00:02:13.000 -> 00:02:22.000
今日、瞑想を開始するには、ユーザーはアプリを起動し、ログインし、実行したい瞑想セッションを見つける必要があります。

00:02:22.000 -> 00:02:30.000
App Shortcutsと統合することで、ユーザーはSiriに尋ねるだけでどこからでもこれらの機能にすばやくアクセスできます。

00:02:30.000 -> 00:02:43.000
そして、セッションをより速く開始することで、ユーザーは仕事の前の朝または夕方に瞑想を日常生活に統合して、長い一日の後にくつろぐことができます。

00:02:43.000 -> 00:02:51.000
さて、アプリインテントを作成し、それをアプリのショートカットに変えるために必要なコードに飛び込みましょう。

00:02:51.000 -> 00:02:57.000
以前のショートカットとは異なり、App Shortcutsは新しいApp Intentsフレームワークで構築されています。

00:02:57.000 -> 00:03:05.000
App Intentsは、優れたインテントをより迅速かつ簡単に構築するために、ゼロから構築された新しいSwiftのみのフレームワークです。

00:03:05.000 -> 00:03:12.000
App Intentsでは、別のメタデータファイルではなく、すべてがSwiftのソースコードで正しく定義されます。

00:03:12.000 -> 00:03:20.000
これにより、コード生成手順が削除され、ソースエディタとメタデータエディタの間でコンテキストを切り替えることなく集中し続けることができます。

00:03:20.000 -> 00:03:24.000
また、コードレビューやマージの競合を解決するのも簡単です。

00:03:24.000 -> 00:03:35.000
App Shortcutsを構築するには、App Intentを本格的なショートカットに変えるために必要なフレーズやその他のメタデータを一覧表示するAppShortcutsProviderを作成する必要があります。

00:03:35.000 -> 00:03:44.000
また、これらはユーザーの操作なしで設定されるため、トリガーフレーズにアプリケーションの名前を含める必要があることに注意してください。

00:03:44.000 -> 00:03:49.000
意図は、AppIntentプロトコルを実装するSwift構造体として定義されます。

00:03:49.000 -> 00:03:58.000
基本的な意図には、ショートカットアプリで意図を表示するために使用されるタイトルと、performと呼ばれるメソッドの2つの要件しかありません。

00:03:58.000 -> 00:04:03.000
Performメソッドは、インテントのロジックを実行し、結果を返す場所です。

00:04:03.000 -> 00:04:08.000
さらに、ユーザーのプロンプトをトリガーして、ユーザーの応答を待つことができます。

00:04:08.000 -> 00:04:14.000
この意図では、アプリのMeditationServiceを使用してデフォルトの瞑想セッションを開始します。

00:04:14.000 -> 00:04:21.000
Performメソッドは非同期であるため、非同期コードを実行してセッションを開始できます。

00:04:21.000 -> 00:04:25.000
セッションが開始されたら、ユーザーに表示されるダイアログを返します。

00:04:25.000 -> 00:04:32.000
また、アプリがローカライズされている場合は、この文字列をすべてのロケールでローカライズしたいと思うでしょう。

00:04:32.000 -> 00:04:39.000
これまでのところ、私が構築したものでは、ショートカットを作成するときにStartMeditationIntentがショートカットアプリに表示されます。

00:04:39.000 -> 00:04:45.000
やる気のあるユーザーは、この意図を持って、セッションを開始するショートカットを作成できます。

00:04:45.000 -> 00:04:51.000
このショートカットでは、フォーカスを有効にする2番目の意図も追加しました。

00:04:51.000 -> 00:04:56.000
デフォルトでは、私のアプリの意図は、ソースコードで指定したタイトルを使用してレンダリングされます。

00:04:56.000 -> 00:05:04.000
アクションのレンダリングをカスタマイズするには、必ずApp Intentにパラメータサマリーを追加してください。

00:05:04.000 -> 00:05:10.000
パラメータサマリーを使用すると、意図の外観をカスタマイズしたり、値をインラインで表示したりできます。

00:05:10.000 -> 00:05:14.000
しかし、この意図はそれ自体がショートカットとしてうまく機能します。

00:05:14.000 -> 00:05:20.000
理想的には、誰かが最初にショートカットを作成することなく、私の意図を実行することができます。

00:05:20.000 -> 00:05:31.000
アプリのショートカットを作成することで、ユーザーに代わってこのセットアップステップを実行できるため、アプリがインストールされるとすぐに私のインテントの使用を開始できます。

00:05:31.000 -> 00:05:35.000
意図を書いたので、そのためのアプリのショートカットを作成します。

00:05:35.000 -> 00:05:43.000
意図と同様に、App ShortcutsはAppShortcutsProviderプロトコルを実装することにより、Swiftコードで定義されています。

00:05:43.000 -> 00:05:50.000
プロトコルを実装するには、ユーザーのために設定したいすべてのアプリのショートカットを返す単一のゲッターを作成するだけです。

00:05:50.000 -> 00:05:55.000
合計で、あなたのアプリは最大10のアプリショートカットを持つことができることに注意してください。

00:05:55.000 -> 00:06:00.000
しかし、ほとんどのアプリはほんの少ししか必要としません。

00:06:00.000 -> 00:06:05.000
そこで、StartMeditationIntent用に単一のAppShortcutを作成します。

00:06:05.000 -> 00:06:08.000
始めるために、私は自分の意図のインスタンスを渡します。

00:06:08.000 -> 00:06:14.000
私の意図の初期化子がパラメータを取った場合、ここで値を指定できます。

00:06:14.000 -> 00:06:20.000
次に、SiriからAppShortcutを呼び出す音声フレーズの配列を作成します。

00:06:20.000 -> 00:06:27.000
アプリケーションの名前を文字列に直接書くのではなく、特別な.applicationNameトークンを使用したことに気付くでしょう。

00:06:27.000 -> 00:06:35.000
これにより、Siriは私のアプリケーションのメイン名だけでなく、私が設定したアプリ名の同義語も挿入できます。

00:06:35.000 -> 00:06:42.000
ユーザーは瞑想を始めるために異なるフレーズを言うかもしれないので、私はここでさらにいくつかの代替フレーズを提供します。

00:06:42.000 -> 00:06:48.000
アプリがローカライズされている場合は、これらのフレーズもローカライズする必要があります。

00:06:48.000 -> 00:06:55.000
すごい。だから今、誰かが仲介したいとき、彼らはただSiriにとどまり、「瞑想を始めなさい」。

00:06:55.000 -> 00:07:00.000
SiriはStartMeditationIntentを呼び、私が返したダイアログを話します。

00:07:00.000 -> 00:07:08.000
また、誰かがSpotlightで私のアプリを検索すると、私のコードにリストした最初のアプリショートカットが表示されます。

00:07:08.000 -> 00:07:14.000
ユーザーが結果をタップすると、アプリケーションを起動せずにショートカットがすぐに実行されます。

00:07:14.000 -> 00:07:19.000
あなたの意図がアプリの起動をトリガーした場合、Spotlightには表示されないことに注意することが重要です。

00:07:19.000 -> 00:07:28.000
だから、ごく少量のコードで、私は今、私のユーザーが私のアプリで瞑想することをはるかに簡単にしました。

00:07:28.000 -> 00:07:33.000
しかし、今、Siriは私の意図を実行するたびにデフォルトのビューを表示します。

00:07:33.000 -> 00:07:40.000
これは大丈夫ですが、アプリのショートカットを実行するときに、ユーザーにより多くの情報を表示したいと思います。

00:07:40.000 -> 00:07:47.000
これを行うには、私の意図が実行されるたびにSiriが表示できるカスタムビューを実装する必要があります。

00:07:47.000 -> 00:07:54.000
App Intentsフレームワークのビューは、SwiftUIを使用して構築され、ウィジェットと同じビュー技術を活用します。

00:07:54.000 -> 00:08:01.000
これは、開発者として、カスタムビュー用に別のUI拡張機能を構築する必要がないことを意味します。

00:08:01.000 -> 00:08:05.000
代わりに、インテントを実行するときに単にビューを返すことができます。

00:08:05.000 -> 00:08:10.000
これがあなたの見解にもたらす特定の制約について考えることが重要です。

00:08:10.000 -> 00:08:17.000
ウィジェットと同様に、カスタムアプリインテントビューには、インタラクティブ性やアニメーションなどを含めることはできません。

00:08:17.000 -> 00:08:21.000
UIを設計するときは、必ずこれを考慮に入れてください。

00:08:21.000 -> 00:08:31.000
アプリインテントは、値の確認、インテントの確認、インテントが終了した後の3つの段階でカスタムUIの表示をサポートしています。

00:08:31.000 -> 00:08:36.000
私のアプリでは、意図の実行の最後にカスタムビューを返します。

00:08:36.000 -> 00:08:44.000
これらの他のプロンプトを使用している場合は、これらのステップでカスタムUIを統合する方法についても必ず考えてください。

00:08:44.000 -> 00:08:48.000
最後に、私が述べたように、カスタムUIの表示は簡単です。

00:08:48.000 -> 00:08:52.000
あなたは単にあなたの意図からあなたの見解を返す必要があります。

00:08:52.000 -> 00:08:55.000
さて、いくつかのコードに飛び込む時間です。

00:08:55.000 -> 00:08:57.000
カスタムビューの追加は簡単です。

00:08:57.000 -> 00:09:01.000
前述したように、ダイアログの横にビューを返します。

00:09:01.000 -> 00:09:06.000
App Intentsフレームワークは、Siriのスニペット内に私のビューを提示します。

00:09:06.000 -> 00:09:14.000
あなたのビューは、スニペットのタイトルや確認ボタンなど、他のSiriビューと一緒に表示されることを覚えておいてください。

00:09:14.000 -> 00:09:19.000
だから、あなたのスニペットのデザインがSiriの中でくつろいだように感じたいと思うでしょう。

00:09:19.000 -> 00:09:26.000
次に、アプリのショートカットを拡張してパラメータを含める方法を確認しましょう。

00:09:26.000 -> 00:09:32.000
以前の実装では、デフォルトの瞑想セッションを開始することを選択しました。

00:09:32.000 -> 00:09:39.000
しかし、私のアプリには多くの素晴らしいセッションタイプが含まれており、ユーザーは念頭に置いている特定のセッションを開始したいと思うでしょう。

00:09:39.000 -> 00:09:45.000
理想的には、私のユーザーは、私の意図を実行するときに開始したいセッションを指定することができます。

00:09:45.000 -> 00:09:54.000
これらのユースケースをサポートするには、ユーザーが実行したいセッションをキャプチャするパラメータを追加して、意図を拡張する必要があります。

00:09:54.000 -> 00:09:58.000
パラメータを追加するには、まずパラメータのタイプを定義する必要があります。

00:09:58.000 -> 00:10:03.000
セッションの関連情報を含むMeditationSession構造体を作成します。

00:10:03.000 -> 00:10:10.000
名前を含め、UUIDになる可能性のある識別子フィールドを与えます。

00:10:10.000 -> 00:10:16.000
この構造体を私の意図のパラメータとして使用するには、AppEntityプロトコルも実装する必要があります。

00:10:16.000 -> 00:10:27.000
AppEntityプロトコルを実装すると、App Intentsフレームワークに私のタイプについて伝え、エンティティの表示方法などの追加情報を指定できます。

00:10:27.000 -> 00:10:32.000
エンティティプロトコルでは、私のタイプに、私がすでに提供した識別子が必要です。

00:10:32.000 -> 00:10:37.000
整数や文字列など、他のタイプも使用できます。

00:10:37.000 -> 00:10:41.000
また、エンティティの表示方法に関する情報も提供する必要があります。

00:10:41.000 -> 00:10:46.000
これは、ショートカットアプリや私のエンティティが表示されている他の場所で使用されます。

00:10:46.000 -> 00:10:49.000
最後に、デフォルトのクエリを配線する必要があります。

00:10:49.000 -> 00:10:55.000
クエリをMeditationSessionQueryと呼び、次に実装します。

00:10:55.000 -> 00:11:01.000
私のエンティティと連携するために、App Intentsフレームワークは、その識別子に基づいて私のエンティティを検索できる必要があります。

00:11:01.000 -> 00:11:11.000
これを可能にするために、EntityQueryプロトコルは1つの要件のみを定義します。識別子を受け取り、一致するエンティティを返す関数です。

00:11:11.000 -> 00:11:16.000
SessionManagerでセッションを調べて、この機能を実装します。

00:11:16.000 -> 00:11:21.000
次に、StartMeditationIntentを更新してパラメータを追加します。

00:11:21.000 -> 00:11:25.000
パラメータは簡単です。それらは私の構造体上の通常のプロパティです。

00:11:25.000 -> 00:11:31.000
しかし、私のパラメータについてApp Intentsに伝えるには、@Parameterプロパティラッパーも追加する必要があります。

00:11:31.000 -> 00:11:37.000
このプロパティラッパーは、セッションプロパティが私の意図の一部であることをApp Intentsに知らせます。

00:11:37.000 -> 00:11:44.000
表示名など、パラメータプロパティラッパーで追加のメタデータを指定することもできます。

00:11:44.000 -> 00:11:50.000
意図にパラメータを追加したので、どのセッションを実行したいかをユーザーに尋ねる必要があります。

00:11:50.000 -> 00:11:58.000
App Intentsフレームワークは、私のIntentのパラメータの値を収集するために、ユーザーにフォローアップの質問をするための堅牢なサポートを持っています。

00:11:58.000 -> 00:12:02.000
これらのプロンプトは、私の意図が実行されている場所ならどこでも表示されます。

00:12:02.000 -> 00:12:07.000
Siriから逃げると、Siriは質問を声に出し、ユーザーに答えを話すように頼みます。

00:12:07.000 -> 00:12:14.000
Spotlightとショートカットアプリでは、ユーザーにはタッチ駆動型UIで同じプロンプトが表示されます。

00:12:14.000 -> 00:12:19.000
App Intentsは、3種類の値プロンプトをサポートしています。

00:12:19.000 -> 00:12:23.000
曖昧さ回避は、固定リストから選択するようユーザーに求めます。

00:12:23.000 -> 00:12:32.000
曖昧さ回避は、あなたの意図にパラメータのためのオプションの小さな固定セットを持っているときにユーザーに提示するのに最適です。

00:12:32.000 -> 00:12:37.000
値プロンプトを使用すると、ユーザーにオープンエンドの値を尋ねることができます。

00:12:37.000 -> 00:12:42.000
これらは、任意の値を取ることができる文字列や整数などの型に最適です。

00:12:42.000 -> 00:12:53.000
最後に、確認はユーザーに特定の値を確認するように求め、ユーザーの意図を理解していることをユーザーに再確認したい場合に役立ちます。

00:12:53.000 -> 00:13:00.000
値のプロンプトは、意図をより柔軟にする素晴らしい方法であり、ユーザーからより多くの情報を収集することができます。

00:13:00.000 -> 00:13:06.000
しかし、彼らはまた、会話を遅くし、頻繁に使用しすぎるとユーザーをイライラさせる可能性があります。

00:13:06.000 -> 00:13:15.000
偉大な意図を設計するためのより多くの洞察については、Lynnの「Design App Shortcuts」というタイトルのセッションをチェックしてください。

00:13:15.000 -> 00:13:25.000
さて、StartMeditationIntentにセッションパラメータを追加したので、この値を促すために、performメソッドにロジックを追加します。

00:13:25.000 -> 00:13:30.000
私のアプリでは、ユーザーが実行できる少数の固定セッションがあります。

00:13:30.000 -> 00:13:38.000
セッションがまだ指定されていない場合は、SessionManagerからリストを取得し、ユーザーに曖昧さ回避を提示します。

00:13:38.000 -> 00:13:46.000
各セッションの表示表現を使用して、App Intentsはセッションをリスト項目にフォーマットし、ユーザーに表示します。

00:13:46.000 -> 00:13:51.000
ユーザーが1つを選択すると、選択したアイテムが私に返されます。

00:13:51.000 -> 00:13:56.000
選択したセッションをMeditationServiceに渡し、セッションを開始します。

00:13:56.000 -> 00:14:01.000
その後、インテントが開始されたことをユーザーに知らせるダイアログを返すことができます。

00:14:01.000 -> 00:14:11.000
ユーザーがセッションを提供したので、ユーザーが要求を理解したことをユーザーに理解できるように、セッションの名前をダイアログに入れることをお勧めします。

00:14:11.000 -> 00:14:19.000
素晴らしいので、私のユーザーが「瞑想を開始」と言うと、私のアプリは実行したい特定のセッションをユーザーに促すことができます。

00:14:19.000 -> 00:14:26.000
しかし、前に述べたように、ユーザーは迅速かつ的確なSiriのインタラクションを好みます。

00:14:26.000 -> 00:14:35.000
理想的には、フォローアップの質問ではなく、最初のフレーズで実行したいセッションをSiriに伝えることができます。

00:14:35.000 -> 00:14:37.000
さて、良い知らせがあります。

00:14:37.000 -> 00:14:43.000
アプリショートカットは、定義済みのパラメータでトリガーフレーズを拡張することをサポートしています。

00:14:43.000 -> 00:14:52.000
パラメータ化されたフレーズを実装することで、私のアプリは「心を落ち着かせる瞑想を始める」や「ウォーキング瞑想を始める」などの発話をサポートできます。

00:14:52.000 -> 00:15:00.000
パラメータは、事前にSiriに指定できる既知のパラメータ値の固定セットがある場合に最適です。

00:15:00.000 -> 00:15:04.000
私のアプリには、セッション名を使用します。

00:15:04.000 -> 00:15:07.000
パラメータはオープンエンドの値のためのものではありません。

00:15:07.000 -> 00:15:13.000
たとえば、最初の発話でユーザーから任意の文字列を収集することはできません。

00:15:13.000 -> 00:15:22.000
だから、私のアプリは、Xがユーザーからの任意の入力である可能性がある「Xのために私の日記を検索する」のようなフレーズをサポートできませんでした。

00:15:22.000 -> 00:15:27.000
代わりに、アプリが実行されているときに、パラメータ値は事前に指定されます。

00:15:27.000 -> 00:15:30.000
いくつかのパラメータ化されたフレーズを実装しましょう。

00:15:30.000 -> 00:15:35.000
アプリでパラメータ化されたフレーズを実装するには、いくつかの変更を加える必要があります。

00:15:35.000 -> 00:15:45.000
まず、SessionEntityのクエリを更新して、suggestedResults()メソッドを実装して、パラメータ化されたショートカットのエンティティのリストを返します。

00:15:45.000 -> 00:15:51.000
第二に、利用可能なSessionEntitiesのリストが変更されたときに、App Intentsフレームワークに通知する必要があります。

00:15:51.000 -> 00:15:56.000
これにより、App IntentsフレームワークはSiriで使用する新しいショートカットフレーズを作成できます。

00:15:56.000 -> 00:16:03.000
これを行うには、アプリのモデルレイヤーを更新して、セッションリストが変更されるたびにApp Intentsフレームワークに通知します。

00:16:03.000 -> 00:16:12.000
最後に、StartMeditationIntentのセッションパラメータを参照する新しいフレーズをアプリショートカットに追加します。

00:16:12.000 -> 00:16:18.000
まず、suggestedEntities関数を実装してMeditationSessionQueryを更新します。

00:16:18.000 -> 00:16:25.000
App Intentsフレームワークは、この関数から返されたセッションを使用して、パラメータ化されたショートカットを作成します。

00:16:25.000 -> 00:16:34.000
このメソッドはオプションですが、このメソッドを実装しないと、パラメータ化されたショートカットがまったく取得されないことに注意することが重要です。

00:16:34.000 -> 00:16:42.000
次に、セッションのリストが変更されるたびにApp Intentsフレームワークに通知するために、アプリのモデルレイヤーを更新する必要があります。

00:16:42.000 -> 00:16:48.000
私のアプリでは、バックグラウンドでサーバーからフェッチした新しいセッションタイプを公開することがめったにありません。

00:16:48.000 -> 00:16:56.000
新しいセッションを受け取るときはいつでも、updateAppShortcutParameters()メソッドを呼び出すようにSessionModelを更新します。

00:16:56.000 -> 00:17:01.000
この方法は、App Intentsフレームワークによって提供されます。自分で実装する必要はありません。

00:17:01.000 -> 00:17:09.000
呼び出されると、App Intentsはエンティティのクエリを呼び出して、ショートカットフレーズのパラメータのリストを収集します。

00:17:09.000 -> 00:17:15.000
最後に、私の意図に関するセッションキーパスを含むアプリショートカットの新しいフレーズを追加します。

00:17:15.000 -> 00:17:21.000
App Intentsフレームワークは、このフレーズを私のクエリから返されたすべてのセッションと組み合わせます。

00:17:21.000 -> 00:17:29.000
各値に使用されるテキストは、SessionEntityの表示表現のtitleプロパティから取得されます。

00:17:29.000 -> 00:17:35.000
以前と同じように、ユーザーが私のアプリショートカットをフレーズするかもしれないいくつかの異なる方法を含めたいと思います。

00:17:35.000 -> 00:17:41.000
これにより、ユーザーが好みのフレーズを覚えていない場合、よりスムーズな体験が保証されます。

00:17:41.000 -> 00:17:48.000
さて、私は今、素晴らしい、フル機能のアプリショートカットを持っており、ユーザーがそれを試してみるのが待ちきれません。

00:17:48.000 -> 00:17:55.000
しかし、それを実現するためには、ユーザーが私の新しいショートカットを発見するのを助けるためにいくつかの作業を行う必要があります。

00:17:55.000 -> 00:17:59.000
私が最初に話したいのは、素晴らしいフレーズを選ぶことです。

00:17:59.000 -> 00:18:03.000
アプリのショートカットのための素晴らしいフレーズは短くて記憶に残る。

00:18:03.000 -> 00:18:12.000
ユーザーは、アプリのショートカットをサポートする多くのアプリを携帯電話に持っているでしょう。そして実際には、ユーザーはショートカットの言い換え方を正確に覚えるのに苦労する可能性があります。

00:18:12.000 -> 00:18:17.000
だから、可能であれば、フレーズを短く、要点をポイントにしてください。

00:18:17.000 -> 00:18:25.000
これらの線に沿って、アプリ名を名詞や動詞として使用できる場合は、フレーズでそのように使用することを検討してください。

00:18:25.000 -> 00:18:31.000
私のアプリでは、フレーズが短くて記憶に残るように、名詞のように瞑想を使用しました。

00:18:31.000 -> 00:18:36.000
最後に、アプリ名の同義語はユーザーに非常に役立ちます。

00:18:36.000 -> 00:18:44.000
ユーザーがアプリをアプリの表示名以外のものと呼ぶ場合は、アプリ名の同義語を追加することを検討する必要があります。

00:18:44.000 -> 00:18:48.000
iOS 11では、アプリ名の同義語のサポートが追加されました。

00:18:48.000 -> 00:18:53.000
まだ作成していない場合は、今がそうする絶好の機会かもしれません。

00:18:53.000 -> 00:18:58.000
次に話したいのは、Siriのヒントとショートカットのリンクです。

00:18:58.000 -> 00:19:07.000
アプリのショートカットはユーザーの設定を必要としないため、ユーザーがアプリのショートカットを見つけて使用するには、見つけやすさが不可欠です。

00:19:07.000 -> 00:19:13.000
アプリのショートカットを使用すると、ショートカットを追加するためにSiriに追加ボタンが不要になります。

00:19:13.000 -> 00:19:14.000
それはすでに追加されています!

00:19:14.000 -> 00:19:20.000
しかし、Siriに追加ボタンが提供する発見可能性の利点を失いたくありません。

00:19:20.000 -> 00:19:24.000
それを念頭に置いて、新しいSiriチップビューを作成しました。

00:19:24.000 -> 00:19:29.000
このビューは、過去に「Siriに追加」ボタンを使用したことがあればどこでもうまく機能します。

00:19:29.000 -> 00:19:34.000
ヒントビューは、SwiftUIとUIKitの両方で利用できます。

00:19:34.000 -> 00:19:40.000
そして、ヒントがどんなアプリケーションでも素晴らしく見えるように、多くのスタイルを提供しました。

00:19:40.000 -> 00:19:45.000
Siriのヒントは、画面上のコンテンツに関連する場合、文脈的に最もよく配置されます。

00:19:45.000 -> 00:19:52.000
ユーザーがアプリで注文したばかりの場合は、注文状況を示すショートカットのヒントを表示することを検討してください。

00:19:52.000 -> 00:20:00.000
Siriのヒントは、ユーザーが近い将来にアプリショートカットに関与する可能性が高いと感じたときに、思慮深く配置する必要があります。

00:20:00.000 -> 00:20:03.000
Siriのヒントは解雇もサポートしています。

00:20:03.000 -> 00:20:09.000
ビューには却下ボタンが含まれており、タップするとコードにカスタムクロージャがトリガーされます。

00:20:09.000 -> 00:20:16.000
レイアウトからビューを削除し、関連性があると感じるまで表示しないことを検討してください。

00:20:16.000 -> 00:20:22.000
最後に、アプリからショートカットのリストに起動する新しいショートカットリンクも含めました。

00:20:22.000 -> 00:20:30.000
この新しい要素は、アプリに多くのアプリショートカットがあり、ユーザーがそれらをすべて探索できるようにしたい場合に最適です。

00:20:30.000 -> 00:20:36.000
さて、アプリショートカットの素晴らしいところは、アプリがインストールされるとすぐに利用できることです。

00:20:36.000 -> 00:20:44.000
アプリが最初に起動する前でも、ユーザーはSpotlight、Siri、およびショートカットアプリからショートカットを見て実行することができます。

00:20:44.000 -> 00:20:48.000
アプリのショートカットを作成する際には、これを考慮する必要があるかもしれません。

00:20:48.000 -> 00:20:55.000
たとえば、アプリがログインフローを必要とする場合、ユーザーはインテントを実行する前にログインしていない可能性があります。

00:20:55.000 -> 00:21:01.000
あなたの意図は、ログインする必要があることをユーザーに説明するエラーメッセージで優雅に失敗するはずです。

00:21:01.000 -> 00:21:12.000
第二に、アプリショートカットのパラメータ化されたフレーズは、アプリが起動され、新しいパラメータ値があることをApp Intentsフレームワークに通知するまで使用できません。

00:21:12.000 -> 00:21:21.000
アプリのショートカットにパラメータ化されていないフレーズが含まれていない場合、ユーザーは最初にアプリを起動するまでアプリのショートカットをまったく表示しません。

00:21:21.000 -> 00:21:27.000
この問題を回避するために、いくつかの非パラメータ化されたフレーズを追加することを検討してください。

00:21:27.000 -> 00:21:35.000
さらに、Siriは「ここで何ができますか？」のようなフレーズのサポートを追加しました。そして「瞑想で何ができますか?」

00:21:35.000 -> 00:21:41.000
Siriは自動的にアプリショートカットのフレーズを収集して推奨し、あなたに代わって提示します。

00:21:41.000 -> 00:21:46.000
あなたのアプリは、この機能が機能するために追加のことをする必要はありません。

00:21:46.000 -> 00:21:55.000
最後に、Siriとショートカットアプリの両方で、アプリのショートカットが表示される順序は、ソースコードにアプリのショートカットをリストする順序によって決まります。

00:21:55.000 -> 00:22:02.000
あなたは、彼らが最も注目を集めるように、あなたの最良かつ最も有用なアプリショートカットを最初に置くことを検討したいと思うでしょう。

00:22:02.000 -> 00:22:09.000
同様に、フレーズ配列にリストする最初のフレーズは、そのアプリショートカットのプライマリフレーズと見なされます。

00:22:09.000 -> 00:22:18.000
主なフレーズはショートカットタイルのラベルとして使用され、ユーザーがSiriにアプリに助けを求めたときに表示されます。

00:22:18.000 -> 00:22:24.000
さて、アプリインテントフレームワークとアプリショートカットについて多くのことを取り上げました。

00:22:24.000 -> 00:22:27.000
私はあなたに2つの重要な考えを残したい。

00:22:27.000 -> 00:22:40.000
まず、アプリショートカットを使用すると、ユーザーはシステムのどこからでもアプリを簡単に使用できるので、このより軽量なモデルに適合するアプリの最適なユースケースについて考えてください。

00:22:40.000 -> 00:22:46.000
第二に、アプリショートカットを実装すると、あなたが彼らに言わない限り、ユーザーはそれについて知らないでしょう!

00:22:46.000 -> 00:22:50.000
アプリショートカットを発見可能にする方法について真剣に考えてください。

00:22:50.000 -> 00:22:59.000
アプリ内でSiriのヒントを表示できる場所や、ウェブサイトや店舗のサインなどの製品外の場所を検討してください。

00:22:59.000 -> 00:23:05.000
新しいApp Intentsフレームワークで作成したすべての素晴らしいアプリショートカットを見るのが待ちきれません。

00:23:05.000 -> 00:23:12.000
デザインとApp Intentsフレームワークをより深く掘り下げるには、今週の他の講演を必ずチェックしてください。

00:23:12.000 -> 00:23:15.000
ありがとう、そして素晴らしいWWDCをお過ごしください。

00:23:15.000 -> 23:59:59.000
♪

