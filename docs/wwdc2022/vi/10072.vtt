WEBVTT

00:00:00.000 --> 00:00:03.000
♪ Nhạc hip-hop nhạc cụ êm dịu ♪

00:00:03.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:18.000
Xin chào, tôi là Sara Frederixon, một kỹ sư trên ứng dụng Sức khỏe, và tôi ở đây để nói chuyện với bạn về việc sử dụng SwiftUI với UIKit.

00:00:18.000 --> 00:00:22.000
Giống như nhiều người trong số các bạn, tôi làm việc trên một ứng dụng UIKit hiện có.

00:00:22.000 --> 00:00:25.000
Đối với tôi, đây là ứng dụng Sức khỏe.

00:00:25.000 --> 00:00:33.000
Ứng dụng Sức khỏe có nhiều hình ảnh trực quan để giúp mọi người hiểu dữ liệu sức khỏe của họ, nhưng việc xây dựng những chế độ xem này có thể khá phức tạp.

00:00:33.000 --> 00:00:43.000
Tôi đã quan tâm đến việc tận dụng SwiftUI, vì vậy tôi đã làm việc với các nhóm UIKit và SwiftUI để học cách tích hợp cả hai vào cùng một ứng dụng.

00:00:43.000 --> 00:00:50.000
Trong video này, tôi sẽ hướng dẫn bạn cách dễ dàng để bắt đầu sử dụng SwiftUI trong các ứng dụng UIKit của riêng bạn.

00:00:50.000 --> 00:00:58.000
Đầu tiên tôi sẽ đề cập đến UIHostingController hiện có, có một số bản cập nhật mới giúp tăng thêm tính linh hoạt.

00:00:58.000 --> 00:01:11.000
Tiếp theo, tôi sẽ đi sâu vào việc điền các chế độ xem SwiftUI với dữ liệu đã tồn tại trong ứng dụng của bạn và cách đảm bảo các chế độ xem SwiftUI cập nhật khi dữ liệu đó thay đổi.

00:01:11.000 --> 00:01:20.000
Sau đó, tôi sẽ nói về một số chức năng mới thú vị cho phép bạn xây dựng các ô UICollectionView và UITableView bằng SwiftUI.

00:01:20.000 --> 00:01:29.000
Cuối cùng, tôi sẽ đi qua các khía cạnh độc đáo của luồng dữ liệu với chế độ xem bộ sưu tập và bảng khi bạn đang sử dụng SwiftUI bên trong các ô.

00:01:29.000 --> 00:01:33.000
Hãy bắt đầu bằng cách nói về UIHostingController.

00:01:33.000 --> 00:01:39.000
UIHostingController là một UIViewController chứa một hệ thống phân cấp chế độ xem SwiftUI.

00:01:39.000 --> 00:01:45.000
Bạn có thể sử dụng bộ điều khiển lưu trữ ở bất cứ đâu bạn có thể sử dụng bộ điều khiển xem trong UIKit.

00:01:45.000 --> 00:01:50.000
Điều này làm cho UIHostingController trở thành một cách dễ dàng để bắt đầu sử dụng SwiftUI.

00:01:50.000 --> 00:01:53.000
Hãy kiểm tra xem bộ điều khiển lưu trữ hoạt động như thế nào.

00:01:53.000 --> 00:02:01.000
Bộ điều khiển lưu trữ là bộ điều khiển chế độ xem, có nghĩa là nó có UIView được lưu trữ trong thuộc tính chế độ xem của nó.

00:02:01.000 --> 00:02:05.000
Và bên trong chế độ xem đó là nơi nội dung SwiftUI của bạn được hiển thị.

00:02:05.000 --> 00:02:09.000
Hãy xem qua một ví dụ về cách sử dụng bộ điều khiển lưu trữ.

00:02:09.000 --> 00:02:14.000
Ở đây, chúng tôi tạo ra một HeartRateView, một chế độ xem SwiftUI.

00:02:14.000 --> 00:02:21.000
Sau đó, chúng tôi tạo một bộ điều khiển lưu trữ với HeartRateView làm chế độ xem gốc của nó và trình bày nó.

00:02:21.000 --> 00:02:26.000
UIHostingController hoạt động với tất cả các API của UIKit view controller.

00:02:26.000 --> 00:02:30.000
Hãy xem qua một ví dụ khác.

00:02:30.000 --> 00:02:34.000
Chúng tôi có cùng HeartRateView và bộ điều khiển lưu trữ như trước đây.

00:02:34.000 --> 00:02:39.000
Ở đây chúng tôi thêm bộ điều khiển lưu trữ làm bộ điều khiển chế độ xem con.

00:02:39.000 --> 00:02:43.000
Sau đó, chúng tôi có thể định vị và kích thước chế độ xem của bộ điều khiển lưu trữ.

00:02:43.000 --> 00:02:51.000
Khi nội dung SwiftUI của bạn bên trong UIHostingController thay đổi, nó có thể khiến chế độ xem cần được thay đổi kích thước.

00:02:51.000 --> 00:03:03.000
Mới trong iOS 16, UIHostingController cho phép bạn bật cập nhật tự động kích thước nội dung ưa thích của bộ điều khiển chế độ xem và kích thước nội dung nội tại của chế độ xem.

00:03:03.000 --> 00:03:09.000
Bạn có thể kích hoạt điều này bằng cách sử dụng thuộc tính sizingOptions mới trên UIHostingController.

00:03:09.000 --> 00:03:12.000
Hãy xem qua một ví dụ.

00:03:12.000 --> 00:03:18.000
Để bắt đầu, chúng tôi tạo HeartRateView và tạo hostingController.

00:03:18.000 --> 00:03:27.000
Chúng tôi sử dụng sizingOptions API mới để yêu cầu hostingController tự động cập nhật kích thước nội dung ưa thích của nó.

00:03:27.000 --> 00:03:31.000
Sau đó, chúng tôi đặt modalPresentationStyle thành popover.

00:03:31.000 --> 00:03:41.000
Sử dụng sizingOptions API mới đảm bảo rằng cửa sổ bật lên luôn có kích thước phù hợp để phù hợp với nội dung SwiftUI.

00:03:41.000 --> 00:03:55.000
Bây giờ bạn đã quen thuộc với UIHostingController, hãy nói về cách đưa dữ liệu vào SwiftUI từ các phần khác của ứng dụng UIKit của bạn và đảm bảo rằng chế độ xem SwiftUI của bạn cập nhật khi dữ liệu đó thay đổi.

00:03:55.000 --> 00:04:04.000
Đây là sơ đồ của ứng dụng UIKit của bạn, Nó chứa một lớp mô hình hiện có sở hữu và quản lý các đối tượng mô hình dữ liệu của ứng dụng của bạn.

00:04:04.000 --> 00:04:07.000
Ứng dụng của bạn cũng chứa một số bộ điều khiển chế độ xem.

00:04:07.000 --> 00:04:15.000
Nếu bạn muốn bắt đầu sử dụng SwiftUI, bạn sẽ cần một bộ điều khiển lưu trữ với chế độ xem SwiftUI bên trong một trong các bộ điều khiển chế độ xem.

00:04:15.000 --> 00:04:22.000
Bạn sẽ muốn điền vào chế độ xem SwiftUI này với dữ liệu vẫn thuộc sở hữu của lớp mô hình hiện tại của bạn.

00:04:22.000 --> 00:04:30.000
Trong phần này, chúng ta sẽ tập trung vào cách kết nối dữ liệu qua ranh giới giữa UIKit và SwiftUI.

00:04:30.000 --> 00:04:36.000
SwiftUI cung cấp nhiều nguyên thủy luồng dữ liệu để giúp bạn quản lý dữ liệu trong ứng dụng của mình.

00:04:36.000 --> 00:04:39.000
Hãy xem qua các lựa chọn khác nhau.

00:04:39.000 --> 00:04:49.000
Để lưu trữ dữ liệu được tạo và sở hữu bởi chế độ xem SwiftUI, SwiftUI cung cấp trình bao bọc thuộc tính @State và @StateObject.

00:04:49.000 --> 00:04:56.000
Vì chúng tôi tập trung vào dữ liệu được sở hữu bên ngoài SwiftUI, những trình bao bọc tài sản này không phải là lựa chọn đúng đắn.

00:04:56.000 --> 00:04:58.000
Vì vậy, tôi sẽ không đề cập đến những điều này trong video này.

00:04:58.000 --> 00:05:06.000
Xem "Data Essentials trong SwiftUI" để tìm hiểu thêm về dữ liệu thuộc sở hữu của chế độ xem SwiftUI.

00:05:06.000 --> 00:05:12.000
Một cách để xử lý dữ liệu bên ngoài SwiftUI là chuyển trực tiếp các giá trị khi bạn khởi tạo chế độ xem của mình.

00:05:12.000 --> 00:05:25.000
Bởi vì bạn chỉ chuyển dữ liệu thô không thuộc sở hữu hoặc quản lý bởi SwiftUI, bạn có trách nhiệm cập nhật thủ công UIHostingController khi dữ liệu thay đổi.

00:05:25.000 --> 00:05:27.000
Hãy xem qua một ví dụ.

00:05:27.000 --> 00:05:31.000
Đây là chế độ xem SwiftUI có tên HeartRateView.

00:05:31.000 --> 00:05:39.000
Chế độ xem này có một thuộc tính duy nhất - nhịp tim beatsPerMinute được lưu trữ dưới dạng số nguyên - và nó hiển thị giá trị dưới dạng văn bản.

00:05:39.000 --> 00:05:48.000
Chúng tôi đang hiển thị HeartRateView này bằng cách nhúng UIHostingController vào bên trong bộ điều khiển chế độ xem hiện có có tên HeartRateViewController.

00:05:48.000 --> 00:05:53.000
Chúng tôi lưu một tham chiếu đến bộ điều khiển lưu trữ để chúng tôi có thể cập nhật chế độ xem gốc của nó sau.

00:05:53.000 --> 00:06:04.000
Hãy nhớ rằng, SwiftUI HeartRateView là một loại giá trị, vì vậy việc tự lưu trữ nó sẽ tạo ra một bản sao riêng biệt và sẽ không cho phép chúng tôi cập nhật giao diện người dùng.

00:06:04.000 --> 00:06:09.000
HeartRateViewController sở hữu dữ liệu được sử dụng để điền vào HeartRateView.

00:06:09.000 --> 00:06:19.000
Dữ liệu này được lưu trữ trong thuộc tính beatsPerMinute và khi giá trị beatsPerMinute thay đổi, chúng tôi gọi một phương thức để cập nhật chế độ xem.

00:06:19.000 --> 00:06:31.000
Bên trong phương pháp cập nhật, chúng tôi tạo một HeartRateView mới bằng cách sử dụng giá trị beatsPerMinute mới nhất, và sau đó gán chế độ xem đó làm rootView của bộ điều khiển lưu trữ của chúng tôi.

00:06:31.000 --> 00:06:43.000
Đây là một cách đơn giản để lấy dữ liệu từ UIKit vào SwiftUI, nhưng nó yêu cầu cập nhật thủ công rootView của bộ điều khiển lưu trữ bất cứ khi nào dữ liệu thay đổi.

00:06:43.000 --> 00:06:49.000
Hãy xem qua một số nguyên thủy dữ liệu SwiftUI khác để làm cho các bản cập nhật này diễn ra tự động.

00:06:49.000 --> 00:06:59.000
Trình bao bọc thuộc tính @ObservedObject và @EnvironmentObject cho phép bạn tham chiếu một đối tượng mô hình bên ngoài phù hợp với giao thức ObservableObject.

00:06:59.000 --> 00:07:07.000
Khi bạn sử dụng các trình bao bọc thuộc tính này, SwiftUI sẽ tự động cập nhật chế độ xem của bạn khi dữ liệu thay đổi.

00:07:07.000 --> 00:07:18.000
Chúng ta sẽ tập trung vào trình bao bọc thuộc tính @ObservedObject trong video này, nhưng bạn có thể tìm hiểu thêm về EnvironmentObject trong video "Data Essentials trong SwiftUI" đã đề cập trước đó.

00:07:18.000 --> 00:07:22.000
Hãy cùng xem qua cách tạo một @ObservedObject.

00:07:22.000 --> 00:07:31.000
Bước đầu tiên là lấy một đối tượng mô hình thuộc sở hữu của một phần hiện có trong ứng dụng của bạn và làm cho nó phù hợp với giao thức ObservableObject.

00:07:31.000 --> 00:07:38.000
Tiếp theo, chúng tôi lưu trữ mô hình dưới dạng thuộc tính @ObservedObject trong chế độ xem SwiftUI của chúng tôi.

00:07:38.000 --> 00:07:46.000
Kết nối ObservableObject với SwiftUI cho phép nó cập nhật chế độ xem khi một trong các thuộc tính của nó thay đổi.

00:07:46.000 --> 00:07:51.000
Hãy quay lại ví dụ HeartRateView của chúng tôi và kết nối cái này.

00:07:51.000 --> 00:07:56.000
Ứng dụng của chúng tôi có một lớp tên là HeartData chứa thuộc tính beatsPerMinute.

00:07:56.000 --> 00:08:01.000
Chúng tôi biến nó thành một ObservableObject bằng cách tuân thủ giao thức.

00:08:01.000 --> 00:08:06.000
Sau đó, chúng tôi thêm trình bao bọc thuộc tính @Published vào thuộc tính beatsPerMinute.

00:08:06.000 --> 00:08:12.000
Trình bao bọc thuộc tính này là thứ kích hoạt SwiftUI cập nhật quan điểm của chúng tôi về các thay đổi.

00:08:12.000 --> 00:08:20.000
Trong HeartRateView, chúng tôi lưu trữ HeartData trong một thuộc tính được chú thích bằng trình bao bọc thuộc tính @ObservedObject.

00:08:20.000 --> 00:08:26.000
Trong phần thân của chế độ xem, chúng tôi hiển thị beatsPerMinute trực tiếp từ HeartData.

00:08:26.000 --> 00:08:30.000
Bây giờ, hãy sử dụng những thứ này cùng nhau trong bộ điều khiển chế độ xem của chúng ta.

00:08:30.000 --> 00:08:33.000
Đây là HeartRateViewController của chúng tôi.

00:08:33.000 --> 00:08:37.000
Nó lưu trữ HeartData ObservableObject trong một thuộc tính.

00:08:37.000 --> 00:08:44.000
Bởi vì thuộc tính này không nằm trong chế độ xem SwiftUI, chúng tôi không cần sử dụng trình bao bọc thuộc tính ở đây.

00:08:44.000 --> 00:08:54.000
HeartRateViewController được khởi tạo với phiên bản HeartData, được sử dụng để tạo HeartRateView trở thành rootView của bộ điều khiển lưu trữ.

00:08:54.000 --> 00:08:57.000
Sơ đồ minh họa cách điều này kết hợp với nhau.

00:08:57.000 --> 00:09:04.000
Chúng tôi tìm nạp phiên bản HeartData hiện tại, chứa nhịp tim 78 nhịp mỗi phút.

00:09:04.000 --> 00:09:14.000
Sau đó, chúng tôi tạo một HeartRateViewController mới với phiên bản HeartData đó, kết nối nó với SwiftUI HeartRateView.

00:09:14.000 --> 00:09:24.000
Sau vài giây, khi mẫu dữ liệu nhịp tim tiếp theo đến, thuộc tính beatsPerMinute của dữ liệu tim được cập nhật lên 94.

00:09:24.000 --> 00:09:33.000
Bởi vì điều này thay đổi một thuộc tính đã xuất bản trên ObservableObject, HeartRateView được tự động cập nhật để hiển thị giá trị mới.

00:09:33.000 --> 00:09:38.000
Chúng tôi không còn cần cập nhật thủ công bộ điều khiển lưu trữ khi dữ liệu thay đổi.

00:09:38.000 --> 00:09:44.000
Đây là lý do tại sao ObservableObject là một cách tuyệt vời để kết nối dữ liệu từ UIKit sang SwiftUI.

00:09:44.000 --> 00:09:52.000
Tiếp theo, hãy nói về việc sử dụng SwiftUI trong chế độ xem bộ sưu tập và các ô chế độ xem bảng.

00:09:52.000 --> 00:10:03.000
Điểm mới trong iOS 16 là UIHostingConfiguration, cho phép bạn khai thác sức mạnh của SwiftUI bên trong UIKit, bộ sưu tập và chế độ xem bảng hiện có của mình.

00:10:03.000 --> 00:10:13.000
UIHostingConfiguration giúp dễ dàng triển khai các ô tùy chỉnh bằng SwiftUI mà không cần phải lo lắng về việc nhúng thêm chế độ xem hoặc bộ điều khiển chế độ xem.

00:10:13.000 --> 00:10:20.000
Trước khi chúng ta đi sâu hơn vào UIHostingConfiguration, hãy xem lại cấu hình ô trong UIKit.

00:10:20.000 --> 00:10:28.000
Cấu hình ô là một cách hiện đại để xác định nội dung, kiểu dáng và hành vi của các ô trong UIKit.

00:10:28.000 --> 00:10:34.000
Không giống như UIView hoặc UIViewController, cấu hình chỉ là một cấu trúc nhẹ.

00:10:34.000 --> 00:10:36.000
Nó không tốn kém để tạo ra.

00:10:36.000 --> 00:10:45.000
Cấu hình chỉ là mô tả về sự xuất hiện của một ô, vì vậy nó cần được áp dụng cho một ô để có hiệu ứng.

00:10:45.000 --> 00:10:51.000
Các cấu hình có thể kết hợp và hoạt động với cả hai ô UICollectionView và UITableView.

00:10:51.000 --> 00:10:56.000
Để biết thêm chi tiết, bạn có thể xem "Cấu hình ô hiện đại".

00:10:56.000 --> 00:11:02.000
Với ý nghĩ đó, hãy đi sâu vào và bắt đầu sử dụng UIHostingConfiguration!

00:11:02.000 --> 00:11:08.000
UIHostingConfiguration là một cấu hình nội dung được khởi tạo với SwiftUI ViewBuilder.

00:11:08.000 --> 00:11:15.000
Điều đó có nghĩa là chúng ta có thể bắt đầu viết mã SwiftUI để tạo chế độ xem trực tiếp bên trong nó.

00:11:15.000 --> 00:11:23.000
Để hiển thị cấu hình lưu trữ, chúng tôi đặt nó thành thuộc tính contentConfiguration của ô UICollectionView hoặc UITableView.

00:11:23.000 --> 00:11:30.000
Hãy bắt đầu viết một số mã SwiftUI trong cấu hình lưu trữ này để xây dựng một ô nhịp tim tùy chỉnh.

00:11:30.000 --> 00:11:36.000
Chúng ta sẽ bắt đầu bằng cách tạo một nhãn với dòng chữ "Tốc tim" và hình ảnh của một trái tim.

00:11:36.000 --> 00:11:41.000
Chế độ xem SwiftUI nhận được kiểu dáng mặc định dựa trên ngữ cảnh mà chúng được sử dụng.

00:11:41.000 --> 00:11:47.000
Nhưng chúng ta có thể bắt đầu tùy chỉnh kiểu dáng bằng cách sử dụng các công cụ sửa đổi chế độ xem SwiftUI tiêu chuẩn.

00:11:47.000 --> 00:11:55.000
Hãy làm cho hình ảnh và văn bản có màu hồng với phông chữ đậm, bằng cách thêm foregroundStyle và công cụ sửa đổi phông chữ vào nhãn của chúng tôi.

00:11:55.000 --> 00:12:03.000
Vì chúng tôi chỉ viết mã SwiftUI thông thường, chúng tôi có thể đưa mã của mình vào chế độ xem độc lập bất cứ lúc nào chúng tôi muốn.

00:12:03.000 --> 00:12:16.000
Tại đây, chúng tôi tạo một chế độ xem SwiftUI mới có tên HeartRateTitleView, di chuyển mã chúng tôi có vào phần thân của nó và sau đó sử dụng HeartRateTitleView đó trong cấu hình lưu trữ.

00:12:16.000 --> 00:12:22.000
Như được hiển thị trong ô, nó tạo ra kết quả giống hệt nhau.

00:12:22.000 --> 00:12:27.000
Bây giờ chúng ta có thể bắt đầu thêm nhiều lượt xem hơn bên trong HeartRateTitleView.

00:12:27.000 --> 00:12:36.000
Tôi đã đặt nhãn bên trong HStack bằng miếng đệm, sau đó thêm thời gian hiện tại vào chế độ xem Văn bản bên cạnh nó.

00:12:36.000 --> 00:12:38.000
Điều đó trông khá tốt cho đến nay.

00:12:38.000 --> 00:12:44.000
Hãy thêm một số nội dung vào ô tùy chỉnh này bên dưới HeartRateTitleView.

00:12:44.000 --> 00:12:53.000
Để làm điều này, chúng tôi sẽ chèn VStack vào bên trong cấu hình lưu trữ để chúng tôi có thể thêm nhiều nội dung hơn bên dưới HeartRateTitleView.

00:12:53.000 --> 00:13:05.000
Sau đó, chúng tôi sẽ đặt hai chế độ xem Văn bản lại với nhau trong một HStack để hiển thị 90 BPM và sau đó áp dụng một vài công cụ sửa đổi để tạo kiểu cho chúng theo cách chúng tôi muốn.

00:13:05.000 --> 00:13:14.000
Giống như chúng tôi đã làm trước đây với HeartRateTitleView, chúng tôi có thể chuyển mã mới này sang chế độ xem SwiftUI của riêng nó.

00:13:14.000 --> 00:13:20.000
Bây giờ mã tương tự được trích xuất vào phần thân của HeartRateBPMView.

00:13:20.000 --> 00:13:25.000
Phòng giam của chúng tôi trông rất tuyệt, nhưng tôi có một ý tưởng cho một thứ khác mà chúng tôi có thể thêm vào.

00:13:25.000 --> 00:13:35.000
Điểm mới trong iOS 16 là khung Swift Charts, cho phép bạn trực quan hóa dữ liệu với các biểu đồ đẹp chỉ trong một vài dòng mã.

00:13:35.000 --> 00:13:41.000
Hãy thử sử dụng nó để hiển thị một biểu đồ đường nhỏ ngay bên trong ô.

00:13:41.000 --> 00:13:52.000
Sử dụng chế độ xem Biểu đồ mới, chúng tôi tạo một biểu đồ đường nhỏ trực quan hóa các mẫu nhịp tim gần đây và hiển thị bên cạnh chế độ xem BPM trong ô.

00:13:52.000 --> 00:14:01.000
Để tạo biểu đồ, chúng tôi chuyển một bộ sưu tập các mẫu nhịp tim và vẽ một LineMark kết nối tất cả các mẫu.

00:14:01.000 --> 00:14:11.000
Chúng ta có thể thêm một biểu tượng hình tròn để chỉ ra từng mẫu trên dòng và áp dụng kiểu tiền cảnh màu hồng, để tô màu biểu đồ để phù hợp với HeartRateTitleView.

00:14:11.000 --> 00:14:22.000
Chúng tôi chỉ đang tìm hiểu bề mặt về những gì bạn có thể làm với khung Biểu đồ Swift mới, vì vậy hãy nhớ xem video "Xin chào Biểu đồ Swift" để tìm hiểu thêm về nó.

00:14:22.000 --> 00:14:29.000
Tế bào nhịp tim đã hoàn thành của chúng tôi trông không chỉ tuyệt vời mà còn dễ dàng thực hiện chỉ trong vài phút.

00:14:29.000 --> 00:14:35.000
Đó là cách dễ dàng để bắt đầu xây dựng các ô tùy chỉnh với UIHostingConfiguration và SwiftUI.

00:14:35.000 --> 00:14:40.000
Hãy nói về bốn tính năng đặc biệt mà UIHostingConfiguration hỗ trợ.

00:14:40.000 --> 00:14:50.000
Theo mặc định, nội dung SwiftUI cấp gốc được chèn từ các cạnh của ô, dựa trên lề bố cục của ô trong UIKit.

00:14:50.000 --> 00:14:59.000
Điều này đảm bảo rằng nội dung ô được căn chỉnh chính xác với nội dung của các ô liền kề và các yếu tố giao diện người dùng khác, chẳng hạn như thanh điều hướng.

00:14:59.000 --> 00:15:07.000
Đôi khi, bạn có thể muốn sử dụng các lề khác nhau hoặc để nội dung mở rộng đến các cạnh của ô.

00:15:07.000 --> 00:15:15.000
Đối với những trường hợp này, bạn có thể thay đổi lề mặc định bằng cách sử dụng công cụ sửa đổi lề trên UIHostingConfiguration.

00:15:15.000 --> 00:15:24.000
Nếu bạn muốn tùy chỉnh giao diện nền của ô bằng SwiftUI, bạn có thể sử dụng công cụ sửa đổi nền trên UIHostingConfiguration.

00:15:24.000 --> 00:15:31.000
Có một vài điểm khác biệt chính giữa nền của UIHostingConfiguration và nội dung của nó.

00:15:31.000 --> 00:15:39.000
Nền được lưu trữ ở phía sau ô, bên dưới nội dung SwiftUI của bạn trong chế độ xem nội dung của ô.

00:15:39.000 --> 00:15:48.000
Ngoài ra, trong khi nội dung thường được chèn từ các cạnh của ô, nền mở rộng từ cạnh này sang cạnh khác trong ô.

00:15:48.000 --> 00:15:56.000
Cuối cùng, khi sử dụng các tế bào tự định cỡ, chỉ có nội dung tế bào ảnh hưởng đến kích thước của tế bào.

00:15:56.000 --> 00:16:06.000
Tiếp theo, hãy kiểm tra thêm hai tính năng đặc biệt của UIHostingConfiguration mà bạn có thể sử dụng khi bạn có một ô bên trong danh sách xem bộ sưu tập hoặc chế độ xem bảng.

00:16:06.000 --> 00:16:14.000
Trong một danh sách, dấu phân cách bên dưới ô được tự động căn chỉnh với văn bản SwiftUI trong cấu hình lưu trữ của bạn theo mặc định.

00:16:14.000 --> 00:16:23.000
Trong ví dụ này, hãy chú ý cách cạnh đầu của dấu phân cách được đặt qua hình ảnh để nó căn chỉnh với văn bản trong ô.

00:16:23.000 --> 00:16:32.000
Nếu bạn cần căn chỉnh dấu phân cách với chế độ xem SwiftUI khác trong cấu hình lưu trữ của mình, hãy sử dụng công cụ sửa đổi alignmentGuide.

00:16:32.000 --> 00:16:40.000
Khi ở trong danh sách chế độ xem bộ sưu tập hoặc chế độ xem bảng, bạn có thể định cấu hình các hành động vuốt cho một hàng trực tiếp bằng SwiftUI.

00:16:40.000 --> 00:16:49.000
Bằng cách tạo các nút của bạn bên trong công cụ sửa đổi swipeActions, bạn sẽ có thể vuốt ô để hiển thị và thực hiện các hành động tùy chỉnh của mình.

00:16:49.000 --> 00:16:53.000
Tải xuống mã mẫu cho video này để tìm một ví dụ hoàn chỉnh.

00:16:53.000 --> 00:17:01.000
Khi xác định các hành động vuốt, hãy đảm bảo các nút của bạn thực hiện hành động của chúng bằng cách sử dụng mã định danh ổn định cho mục được biểu diễn.

00:17:01.000 --> 00:17:10.000
Không sử dụng đường dẫn chỉ mục, vì nó có thể thay đổi trong khi ô hiển thị, khiến các hành động vuốt hoạt động sai mục.

00:17:10.000 --> 00:17:24.000
Khi bạn đang sử dụng UIHostingConfiguration trong một ô, hãy nhớ rằng các tương tác của ô như xử lý chạm, tô sáng và lựa chọn vẫn sẽ được xử lý bởi chế độ xem bộ sưu tập hoặc chế độ xem bảng.

00:17:24.000 --> 00:17:40.000
Nếu bạn cần tùy chỉnh chế độ xem SwiftUI của mình cho bất kỳ trạng thái ô UIKit nào trong số này, bạn có thể tạo cấu hình lưu trữ của mình bên trong configurationUpdateHandler của ô và sử dụng trạng thái được cung cấp trong mã SwiftUI của bạn.

00:17:40.000 --> 00:17:51.000
ConfigurationUpdateHandler chạy lại bất cứ khi nào trạng thái của ô thay đổi, tạo UIHostingConfiguration mới cho trạng thái mới và áp dụng nó vào ô.

00:17:51.000 --> 00:17:57.000
Trong ví dụ này, chúng tôi sử dụng trạng thái để thêm hình ảnh dấu kiểm khi ô được chọn.

00:17:57.000 --> 00:18:10.000
Bây giờ bạn đã quen thuộc với UIHostingConfiguration, hãy thảo luận về cách quản lý luồng dữ liệu từ lớp mô hình của bạn sang UICollectionView hoặc UITableView chứa đầy các ô bằng SwiftUI.

00:18:10.000 --> 00:18:14.000
Mục tiêu của chúng tôi là xây dựng danh sách các điều kiện y tế này.

00:18:14.000 --> 00:18:22.000
Trong ví dụ này, chúng tôi đang sử dụng UICollectionView, nhưng mọi thứ chúng tôi thảo luận đều áp dụng như nhau cho UITableView.

00:18:22.000 --> 00:18:25.000
Hãy xem qua các thành phần liên quan.

00:18:25.000 --> 00:18:33.000
Ứng dụng của chúng tôi có một bộ sưu tập các đối tượng mô hình MedicalCondition, mà chúng tôi sẽ hiển thị trong chế độ xem bộ sưu tập.

00:18:33.000 --> 00:18:41.000
Đối với mỗi mục trong bộ sưu tập này, chúng tôi muốn tạo một ô trong chế độ xem bộ sưu tập để hiển thị tình trạng y tế đó.

00:18:41.000 --> 00:18:47.000
Để làm điều này, chúng tôi sẽ tạo một nguồn dữ liệu có thể thay đổi được kết nối với chế độ xem bộ sưu tập.

00:18:47.000 --> 00:18:58.000
Sau đó, chúng ta cần điền vào ảnh chụp nhanh nguồn dữ liệu có thể thay đổi với số nhận dạng của các đối tượng mô hình MedicalCondition trong bộ sưu tập dữ liệu.

00:18:58.000 --> 00:19:08.000
Điều quan trọng là ảnh chụp nhanh nguồn dữ liệu có thể thay đổi chứa số nhận dạng duy nhất của mỗi MedicalCondition chứ không phải bản thân các đối tượng MedicalCondition.

00:19:08.000 --> 00:19:20.000
Điều này đảm bảo rằng nguồn dữ liệu có thể thay đổi có thể theo dõi chính xác danh tính của từng mục và tính toán các thay đổi chính xác khi ảnh chụp nhanh mới được áp dụng sau này.

00:19:20.000 --> 00:19:32.000
Bằng cách áp dụng ảnh chụp nhanh với các số nhận dạng mục này cho nguồn dữ liệu có thể thay đổi, nó sẽ tự động cập nhật chế độ xem bộ sưu tập, điều này sẽ tạo ra một ô mới cho mỗi mục.

00:19:32.000 --> 00:19:42.000
Mỗi ô được cấu hình để hiển thị một MedicalCondition, sử dụng chế độ xem SwiftUI trong UIHostingConfiguration.

00:19:42.000 --> 00:19:49.000
Bây giờ chúng tôi đang hiển thị các ô được xây dựng bằng SwiftUI, chúng tôi cần xử lý việc cập nhật giao diện người dùng khi dữ liệu thay đổi.

00:19:49.000 --> 00:19:54.000
Có hai loại thay đổi khác nhau mà chúng ta cần xử lý riêng biệt.

00:19:54.000 --> 00:19:58.000
Loại đầu tiên là khi bộ sưu tập dữ liệu tự thay đổi.

00:19:58.000 --> 00:20:04.000
Ví dụ, khi các mục được chèn, sắp xếp lại hoặc xóa.

00:20:04.000 --> 00:20:10.000
Những thay đổi này được xử lý bằng cách áp dụng ảnh chụp nhanh mới cho nguồn dữ liệu có thể thay đổi.

00:20:10.000 --> 00:20:23.000
Nguồn dữ liệu có thể khuếch tán sẽ phân biệt các ảnh chụp nhanh cũ và mới, đồng thời thực hiện các cập nhật cần thiết cho chế độ xem bộ sưu tập, khiến các ô bị chèn, di chuyển hoặc xóa.

00:20:23.000 --> 00:20:35.000
Bởi vì những thay đổi đối với bản thân việc thu thập dữ liệu không ảnh hưởng đến bất kỳ thứ gì bên trong các ô, bạn cũng xử lý các loại thay đổi này, cho dù bạn xây dựng các ô của mình bằng UIKit hay SwiftUI.

00:20:35.000 --> 00:20:43.000
Loại thay đổi thứ hai mà chúng ta cần xử lý là khi các thuộc tính của các đối tượng mô hình riêng lẻ thay đổi.

00:20:43.000 --> 00:20:48.000
Những thay đổi này thường yêu cầu cập nhật các chế độ xem trong các ô hiện có.

00:20:48.000 --> 00:20:57.000
Bởi vì nguồn dữ liệu có thể khác biệt chỉ chứa số nhận dạng mục trong ảnh chụp nhanh của nó, nó không biết khi nào các thuộc tính của các mục hiện có thay đổi.

00:20:57.000 --> 00:21:08.000
Theo truyền thống, khi sử dụng UIKit, bạn sẽ cần thông báo thủ công nguồn dữ liệu có thể thay đổi về những thay đổi này bằng cách định cấu hình lại hoặc tải lại các mục trong ảnh chụp nhanh.

00:21:08.000 --> 00:21:13.000
Nhưng khi sử dụng SwiftUI trong các ô, điều này không còn cần thiết nữa.

00:21:13.000 --> 00:21:27.000
Bằng cách lưu trữ mô hình ObservableObject trong thuộc tính ObservedObject trong chế độ xem SwiftUI của chúng tôi, các thay đổi đối với các thuộc tính đã xuất bản của mô hình sẽ tự động kích hoạt SwiftUI để làm mới chế độ xem.

00:21:27.000 --> 00:21:34.000
Điều này thiết lập một kết nối trực tiếp giữa mô hình và chế độ xem SwiftUI bên trong ô.

00:21:34.000 --> 00:21:44.000
Khi một thay đổi được thực hiện, các chế độ xem SwiftUI trong ô được cập nhật trực tiếp, mà không cần đi qua nguồn dữ liệu có thể thay đổi hoặc UICollectionView.

00:21:44.000 --> 00:21:51.000
Khi dữ liệu của một tế bào thay đổi, nó có thể khiến tế bào cần phát triển hoặc thu nhỏ để phù hợp với nội dung mới.

00:21:51.000 --> 00:22:00.000
Nhưng nếu nội dung ô SwiftUI đang được cập nhật trực tiếp mà không cần thông qua UIKit, làm thế nào để chế độ xem bộ sưu tập biết để thay đổi kích thước ô?

00:22:00.000 --> 00:22:07.000
UIHostingConfiguration tận dụng tính năng hoàn toàn mới trong UIKit để thực hiện công việc này.

00:22:07.000 --> 00:22:16.000
Trong iOS 16, các ô tự thay đổi kích thước trong UICollectionView và UITableView hiện cũng đang tự thay đổi kích thước!

00:22:16.000 --> 00:22:28.000
Điều này được bật theo mặc định, để khi bạn đang sử dụng UIHostingConfiguration và nội dung SwiftUI thay đổi, ô chứa sẽ tự động thay đổi kích thước nếu cần.

00:22:28.000 --> 00:22:37.000
Bạn có thể tìm hiểu thêm về cách tính năng mới này hoạt động trong video "Có gì mới trong UIKit" từ WWDC 2022.

00:22:37.000 --> 00:22:48.000
Có một khía cạnh nữa của luồng dữ liệu mà bạn có thể cần xử lý và đó là gửi dữ liệu từ chế độ xem SwiftUI trở lại các phần khác trong ứng dụng của bạn.

00:22:48.000 --> 00:22:52.000
Một lần nữa, ObservableObject đã giúp bạn!

00:22:52.000 --> 00:22:57.000
Bạn có thể tạo một liên kết hai chiều với một thuộc tính đã xuất bản của một ObservableObject.

00:22:57.000 --> 00:23:08.000
Dữ liệu không chỉ chảy từ ObservableObject vào SwiftUI, mà SwiftUI còn có thể ghi lại các thay đổi đối với thuộc tính trên đối tượng mô hình.

00:23:08.000 --> 00:23:16.000
Hãy xem qua một ví dụ đơn giản về việc tạo liên kết hai chiều bằng cách làm cho văn bản trong ô MedicalCondition của chúng tôi có thể chỉnh sửa được.

00:23:16.000 --> 00:23:21.000
Đây là Đối tượng có thể quan sát được của chúng tôi, Điều kiện Y tế.

00:23:21.000 --> 00:23:25.000
Nó lưu trữ một mã định danh duy nhất trong một thuộc tính ID.

00:23:25.000 --> 00:23:30.000
Đây là mã định danh được sử dụng để điền vào ảnh chụp nhanh nguồn dữ liệu có thể thay đổi.

00:23:30.000 --> 00:23:35.000
Và tài sản được xuất bản này lưu trữ văn bản của tình trạng y tế.

00:23:35.000 --> 00:23:42.000
Đây là MedicalConditionView hiển thị văn bản tình trạng y tế bên trong mỗi ô.

00:23:42.000 --> 00:23:47.000
Ngay bây giờ văn bản này chỉ đọc, vì vậy hãy làm cho nó có thể chỉnh sửa được.

00:23:47.000 --> 00:23:59.000
Tất cả những gì chúng ta cần làm là thay đổi chế độ xem Văn bản thành TextField và tạo liên kết với thuộc tính văn bản của MedicalCondition của chúng ta bằng cách thêm tiền tố ký hiệu đô la.

00:23:59.000 --> 00:24:07.000
Khi bạn nhập vào trường văn bản, ràng buộc này cho phép SwiftUI ghi lại các thay đổi trực tiếp vào ObservableObject.

00:24:07.000 --> 00:24:14.000
Đó thực sự là cách đơn giản để thiết lập luồng dữ liệu hai chiều với SwiftUI.

00:24:14.000 --> 00:24:21.000
UIHostingController là một cách mạnh mẽ để nhúng nội dung SwiftUI vào ứng dụng UIKit của bạn.

00:24:21.000 --> 00:24:33.000
Chế độ xem SwiftUI của bạn được hiển thị bên trong chế độ xem của bộ điều khiển lưu trữ và bạn có thể sử dụng bộ điều khiển lưu trữ ở bất kỳ đâu mà bạn có thể sử dụng bộ điều khiển chế độ xem trong UIKit.

00:24:33.000 --> 00:24:41.000
Khi sử dụng UIHostingController, hãy đảm bảo luôn thêm bộ điều khiển chế độ xem cùng với chế độ xem vào ứng dụng của bạn.

00:24:41.000 --> 00:25:01.000
Nhiều tính năng SwiftUI, chẳng hạn như thanh công cụ, phím tắt và chế độ xem sử dụng UIViewControllerRepresentable, yêu cầu kết nối với hệ thống phân cấp bộ điều khiển chế độ xem trong UIKit để tích hợp đúng cách, vì vậy không bao giờ tách chế độ xem của bộ điều khiển lưu trữ khỏi chính bộ điều khiển lưu trữ.

00:25:01.000 --> 00:25:11.000
Để so sánh, khi bạn áp dụng UIHostingConfiguration cho một ô, chế độ xem SwiftUI của bạn được lưu trữ trong ô mà không có UIViewController.

00:25:11.000 --> 00:25:16.000
UIHostingConfiguration hỗ trợ phần lớn các tính năng SwiftUI.

00:25:16.000 --> 00:25:23.000
Nhưng hãy nhớ rằng các chế độ xem SwiftUI phụ thuộc vào UIViewControllerRepresentable không thể được sử dụng bên trong các ô.

00:25:23.000 --> 00:25:32.000
Với UIHostingController và UIHostingConfiguration, bạn có hai cách tuyệt vời để kết hợp SwiftUI vào ứng dụng UIKit của mình.

00:25:32.000 --> 00:25:42.000
SwiftUI tích hợp liền mạch vào các ứng dụng UIKit hiện có Sử dụng UIHostingController để thêm SwiftUI trong toàn bộ ứng dụng của bạn.

00:25:42.000 --> 00:25:49.000
Tạo các ô tùy chỉnh trong bộ sưu tập và chế độ xem bảng của bạn bằng cách sử dụng UIHostingConfiguration.

00:25:49.000 --> 00:25:55.000
Và tận dụng ObservableObject, vì vậy dữ liệu và giao diện người dùng của bạn luôn đồng bộ.

00:25:55.000 --> 00:25:59.000
Thêm SwiftUI vào ứng dụng của bạn ngay hôm nay!

00:25:59.000 --> 00:26:00.000
Cảm ơn bạn đã xem!

00:26:00.000 --> 23:59:59.000
♪

