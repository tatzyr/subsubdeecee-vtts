WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:12.000
Chào mừng bạn đến với Hình dung và Tối ưu hóa Đồng thời Nhanh chóng.

00:00:12.000 --> 00:00:16.000
Tên tôi là Mike, và tôi làm việc trên thư viện thời gian chạy Swift.

00:00:16.000 --> 00:00:18.000
Xin chào, tôi là Harjas, và tôi làm việc trên Instruments.

00:00:18.000 --> 00:00:28.000
Cùng nhau, chúng ta sẽ thảo luận về các cách để hiểu rõ hơn về mã Swift Concurrency của bạn và làm cho nó hoạt động nhanh hơn, bao gồm một công cụ trực quan hóa mới có sẵn trong Công cụ 14.

00:00:28.000 --> 00:00:36.000
Hãy bắt đầu với bản tóm tắt thực sự nhanh về các phần khác nhau của Swift Concurrency và cách chúng hoạt động cùng nhau, để đảm bảo bạn bắt kịp tốc độ.

00:00:36.000 --> 00:00:38.000
Sau đó, chúng tôi sẽ giới thiệu công cụ đồng thời mới.

00:00:38.000 --> 00:00:44.000
Chúng tôi sẽ chỉ cho bạn cách chúng tôi sử dụng nó để giải quyết một số vấn đề hiệu suất thực tế với một ứng dụng sử dụng Swift Concurrency.

00:00:44.000 --> 00:00:51.000
Cuối cùng, chúng ta sẽ thảo luận về các vấn đề tiềm ẩn của việc cạn kiệt nhóm chủ đề và tiếp tục lạm dụng và cách tránh chúng.

00:00:51.000 --> 00:00:54.000
Năm ngoái, chúng tôi đã giới thiệu Swift Concurrency.

00:00:54.000 --> 00:01:01.000
Đây là một tính năng ngôn ngữ mới bao gồm async/await, cấu trúc đồng thời và Actors.

00:01:01.000 --> 00:01:07.000
Chúng tôi rất vui khi thấy rất nhiều việc áp dụng các tính năng này kể từ đó, cả bên trong và bên ngoài Apple.

00:01:07.000 --> 00:01:14.000
Swift concurrency bổ sung một số tính năng mới vào ngôn ngữ hoạt động cùng nhau để giúp lập trình đồng thời dễ dàng và an toàn hơn.

00:01:14.000 --> 00:01:19.000
Async/await là các khối xây dựng cú pháp cơ bản cho mã đồng thời.

00:01:19.000 --> 00:01:29.000
Chúng cho phép bạn tạo và gọi các hàm có thể tạm dừng công việc của chúng ở giữa quá trình thực thi, sau đó tiếp tục công việc đó sau, mà không chặn chuỗi thực thi.

00:01:29.000 --> 00:01:32.000
Nhiệm vụ là đơn vị công việc cơ bản trong mã đồng thời.

00:01:32.000 --> 00:01:37.000
Các tác vụ thực thi mã đồng thời và quản lý trạng thái và dữ liệu liên quan của nó.

00:01:37.000 --> 00:01:44.000
Chúng chứa các biến cục bộ, xử lý việc hủy bỏ, và bắt đầu và tạm dừng việc thực thi mã không đồng bộ.

00:01:44.000 --> 00:01:50.000
Đồng thời có cấu trúc giúp dễ dàng tạo ra các tác vụ con để chạy song song và chờ chúng hoàn thành.

00:01:50.000 --> 00:01:59.000
Ngôn ngữ cung cấp cú pháp giữ cho công việc được nhóm lại với nhau và đảm bảo rằng các nhiệm vụ được chờ đợi hoặc tự động hủy nếu không được sử dụng.

00:01:59.000 --> 00:02:03.000
Các diễn viên phối hợp nhiều nhiệm vụ cần truy cập dữ liệu được chia sẻ.

00:02:03.000 --> 00:02:12.000
Chúng cô lập dữ liệu từ bên ngoài và chỉ cho phép một tác vụ tại một thời điểm thao tác trạng thái bên trong của chúng, tránh các cuộc đua dữ liệu từ đột biến đồng thời.

00:02:12.000 --> 00:02:24.000
Tính năng mới trong Công cụ 14, chúng tôi đang giới thiệu một bộ công cụ có thể nắm bắt và trực quan hóa tất cả hoạt động này trong ứng dụng của bạn, giúp bạn hiểu ứng dụng của mình đang làm gì, xác định vị trí sự cố và cải thiện hiệu suất.

00:02:24.000 --> 00:02:34.000
Để thảo luận chuyên sâu hơn về các nguyên tắc cơ bản của Swift Concurrency, chúng tôi có một số video về các tính năng này được liên kết trong phần Video liên quan.

00:02:34.000 --> 00:02:38.000
Hãy cùng xem xét việc tối ưu hóa một ứng dụng bằng cách sử dụng mã Swift Concurrency.

00:02:38.000 --> 00:02:43.000
Đồng thời nhanh giúp dễ dàng viết đúng mã đồng thời và song song.

00:02:43.000 --> 00:02:48.000
Tuy nhiên, vẫn có thể viết mã lạm dụng các cấu trúc đồng thời.

00:02:48.000 --> 00:02:54.000
Cũng có thể sử dụng chúng một cách chính xác nhưng theo cách không mang lại lợi ích hiệu suất mà bạn đang hướng tới.

00:02:54.000 --> 00:03:02.000
Có một vài vấn đề phổ biến có thể phát sinh khi viết mã bằng Swift đồng thời có thể gây ra hiệu suất kém hoặc lỗi.

00:03:02.000 --> 00:03:06.000
Chặn diễn viên chính có thể khiến ứng dụng của bạn bị treo.

00:03:06.000 --> 00:03:13.000
Tranh chấp diễn viên và kiệt sức của nhóm chủ đề làm tổn thương hiệu suất bằng cách giảm thực hiện song song.

00:03:13.000 --> 00:03:17.000
Việc lạm dụng liên tục gây ra rò rỉ hoặc sự cố.

00:03:17.000 --> 00:03:22.000
Công cụ Swift Concurrency mới có thể giúp bạn khám phá và khắc phục những vấn đề này.

00:03:22.000 --> 00:03:26.000
Chúng ta hãy xem xét từng thứ này, bắt đầu với việc chặn Diễn viên chính.

00:03:26.000 --> 00:03:31.000
Chặn Diễn viên chính xảy ra khi một tác vụ chạy lâu dài trên Diễn viên chính.

00:03:31.000 --> 00:03:36.000
Diễn viên chính là một Diễn viên đặc biệt thực hiện tất cả công việc của mình trên chủ đề chính.

00:03:36.000 --> 00:03:43.000
Công việc giao diện người dùng phải được thực hiện trên luồng chính và Diễn viên chính cho phép bạn tích hợp mã giao diện người dùng vào Swift Concurrency.

00:03:43.000 --> 00:03:50.000
Tuy nhiên, vì chủ đề chính rất quan trọng đối với giao diện người dùng, nó cần phải có sẵn và không thể bị chiếm bởi một đơn vị công việc lâu dài.

00:03:50.000 --> 00:03:55.000
Khi điều này xảy ra, ứng dụng của bạn dường như bị khóa và không phản hồi.

00:03:55.000 --> 00:04:04.000
Mã chạy trên Diễn viên chính phải hoàn thành nhanh chóng và hoàn thành công việc của nó hoặc di chuyển tính toán ra khỏi Diễn viên chính và vào nền.

00:04:04.000 --> 00:04:09.000
Công việc có thể được chuyển sang nền bằng cách đặt nó vào một Diễn viên bình thường hoặc trong một nhiệm vụ tách biệt.

00:04:09.000 --> 00:04:16.000
Các đơn vị công việc nhỏ có thể được thực hiện trên Actor chính để cập nhật giao diện người dùng hoặc thực hiện các tác vụ khác phải được thực hiện trên luồng chính.

00:04:16.000 --> 00:04:18.000
Hãy xem bản demo của điều này đang hoạt động.

00:04:18.000 --> 00:04:20.000
Cảm ơn, Mike.

00:04:20.000 --> 00:04:22.000
Ở đây chúng tôi có ứng dụng File Squeezer của chúng tôi.

00:04:22.000 --> 00:04:27.000
Chúng tôi đã xây dựng ứng dụng này để có thể nhanh chóng nén tất cả các tệp trong một thư mục.

00:04:27.000 --> 00:04:30.000
Nó có vẻ hoạt động tốt cho các tệp nhỏ.

00:04:30.000 --> 00:04:39.000
Tuy nhiên, khi tôi sử dụng các tệp lớn hơn, mất nhiều thời gian hơn dự kiến và giao diện người dùng bị đóng băng hoàn toàn và không phản hồi với bất kỳ tương tác nào.

00:04:39.000 --> 00:04:46.000
Hành vi này rất khó chịu đối với người dùng và có thể khiến họ nghĩ rằng ứng dụng đã gặp sự cố hoặc sẽ không bao giờ kết thúc.

00:04:46.000 --> 00:04:51.000
Chúng ta nên cố gắng đảm bảo rằng giao diện người dùng của chúng ta luôn đáp ứng để có trải nghiệm người dùng tốt nhất.

00:04:51.000 --> 00:04:58.000
Để điều tra vấn đề hiệu suất này, chúng ta có thể sử dụng mẫu Swift Concurrency mới trong Instruments.

00:04:58.000 --> 00:05:06.000
Các công cụ Swift Tasks và Swift Actors cung cấp một bộ công cụ đầy đủ để giúp bạn hình dung và tối ưu hóa mã đồng thời của mình.

00:05:06.000 --> 00:05:15.000
Khi bạn mới bắt đầu điều tra một vấn đề về hiệu suất, trước tiên bạn nên xem số liệu thống kê cấp cao nhất do công cụ Swift Tasks cung cấp cho bạn.

00:05:15.000 --> 00:05:22.000
Đầu tiên trong số này là Chạy Nhiệm vụ, cho bạn biết có bao nhiêu nhiệm vụ đang thực hiện đồng thời.

00:05:22.000 --> 00:05:28.000
Tiếp theo, chúng ta có Nhiệm vụ Sống, cho thấy có bao nhiêu nhiệm vụ hiện diện tại một thời điểm nhất định.

00:05:28.000 --> 00:05:36.000
Và cuối cùng, Tổng nhiệm vụ; vẽ biểu đồ tổng số nhiệm vụ đã được tạo cho đến thời điểm đó.

00:05:36.000 --> 00:05:44.000
Khi bạn đang cố gắng giảm dấu chân bộ nhớ ứng dụng của mình, bạn nên xem kỹ số liệu thống kê Alive và Total Tasks.

00:05:44.000 --> 00:05:53.000
Sự kết hợp của tất cả các số liệu thống kê này cung cấp cho bạn một bức tranh tốt về việc mã của bạn song song tốt như thế nào và bạn đang tiêu thụ bao nhiêu tài nguyên.

00:05:53.000 --> 00:06:09.000
Một trong nhiều chế độ xem chi tiết cho công cụ này là Task Forest; được hiển thị ở nửa dưới của cửa sổ này, nó cung cấp một biểu diễn đồ họa về mối quan hệ cha-con giữa các Nhiệm vụ trong mã đồng thời có cấu trúc.

00:06:09.000 --> 00:06:12.000
Tiếp theo, chúng tôi có chế độ xem Tóm tắt Nhiệm vụ của mình.

00:06:12.000 --> 00:06:17.000
Điều này cho thấy mỗi Nhiệm vụ dành bao nhiêu thời gian ở các trạng thái khác nhau.

00:06:17.000 --> 00:06:27.000
Chúng tôi đã tăng cường chế độ xem bằng cách cho phép bạn nhấp chuột phải vào Nhiệm vụ để có thể ghim Bản nhạc chứa tất cả thông tin về Nhiệm vụ đã chọn vào dòng thời gian.

00:06:27.000 --> 00:06:38.000
Điều này cho phép bạn nhanh chóng tìm và tìm hiểu về các Nhiệm vụ quan tâm có thể đang chạy trong một thời gian rất dài hoặc bị mắc kẹt chờ đợi để có quyền truy cập vào một Diễn viên.

00:06:38.000 --> 00:06:43.000
Khi bạn ghim một Nhiệm vụ Swift vào dòng thời gian, bạn sẽ nhận được bốn tính năng chính.

00:06:43.000 --> 00:06:48.000
Đầu tiên, là bản nhạc cho bạn thấy Nhiệm vụ Swift của bạn đang ở trạng thái nào.

00:06:48.000 --> 00:06:53.000
Thứ hai, là dấu vết ngược tạo Nhiệm vụ trong chế độ xem chi tiết mở rộng.

00:06:53.000 --> 00:06:58.000
Thứ ba, là quan điểm tường thuật cung cấp thêm bối cảnh về trạng thái của Nhiệm vụ Nhanh.

00:06:58.000 --> 00:07:04.000
Chẳng hạn như, nếu nó đang chờ một Nhiệm vụ, nó sẽ cho bạn biết bạn đang chờ Nhiệm vụ nào.

00:07:04.000 --> 00:07:10.000
Cuối cùng, bạn có quyền truy cập vào cùng một hành động ghim trong chế độ xem tường thuật như bạn đã làm trong chế độ xem tóm tắt.

00:07:10.000 --> 00:07:16.000
Vì vậy, bạn có thể ghim một Nhiệm vụ con, một chủ đề hoặc thậm chí là một Diễn viên Swift vào dòng thời gian.

00:07:16.000 --> 00:07:26.000
Chế độ xem tường thuật này sẽ là công cụ để tìm ra cách một Nhiệm vụ Swift có liên quan đến các nguyên thủy đồng thời khác của bạn và CPU.

00:07:26.000 --> 00:07:33.000
Bây giờ chúng ta đã thấy tổng quan ngắn gọn về một số tính năng trong công cụ mới, hãy lập hồ sơ ứng dụng của chúng tôi và tối ưu hóa mã của chúng tôi.

00:07:33.000 --> 00:07:38.000
Chúng ta có thể làm điều này bằng cách kéo dự án của mình lên Xcode và nhấn Command-I.

00:07:38.000 --> 00:07:44.000
Điều này sẽ biên dịch ứng dụng của chúng tôi, mở các công cụ và chọn trước mục tiêu cho ứng dụng File Squeezer.

00:07:44.000 --> 00:07:52.000
Từ đây bạn có thể chọn tùy chọn Swift Concurrency trong trình chọn mẫu và bắt đầu ghi âm.

00:07:52.000 --> 00:07:56.000
Một lần nữa, tôi sẽ thả các tệp lớn vào ứng dụng.

00:07:56.000 --> 00:08:01.000
Một lần nữa, chúng tôi thấy rằng ứng dụng bắt đầu quay và giao diện người dùng không phản hồi.

00:08:01.000 --> 00:08:08.000
Chúng tôi sẽ để điều này chạy thêm vài giây nữa để Công cụ có thể nắm bắt tất cả thông tin về ứng dụng của chúng tôi.

00:08:08.000 --> 00:08:11.000
Bây giờ chúng ta đã có dấu vết, chúng ta có thể bắt đầu điều tra.

00:08:11.000 --> 00:08:17.000
Tôi sẽ toàn màn hình dấu vết này để xem rõ hơn tất cả thông tin.

00:08:17.000 --> 00:08:24.000
Chúng ta có thể sử dụng tùy chọn kéo để phóng to khu vực chúng ta quan tâm.

00:08:24.000 --> 00:08:31.000
Trong quá trình theo dõi, Instruments cho chúng ta thấy chính xác nơi treo giao diện người dùng này đã xảy ra.

00:08:31.000 --> 00:08:37.000
Điều này có thể hữu ích cho các trường hợp không rõ khi nào treo xảy ra hoặc kéo dài bao lâu.

00:08:37.000 --> 00:08:42.000
Như tôi đã đề cập trước đó, một nơi tốt để bắt đầu là thống kê Nhiệm vụ Nhanh cấp cao nhất.

00:08:42.000 --> 00:08:46.000
Điều thu hút sự chú ý của tôi ngay lập tức là số lượng Nhiệm vụ Chạy.

00:08:46.000 --> 00:08:49.000
Trong hầu hết thời gian, chỉ có một Nhiệm vụ đang chạy.

00:08:49.000 --> 00:08:55.000
Điều này cho chúng ta biết một phần của vấn đề là tất cả công việc của chúng ta đang bị buộc phải đăng nhiều kỳ.

00:08:55.000 --> 00:09:03.000
Chúng ta có thể sử dụng bản tóm tắt Trạng thái Nhiệm vụ để tìm Nhiệm vụ chạy lâu nhất của mình và sử dụng hành động ghim để ghim nó vào dòng thời gian.

00:09:03.000 --> 00:09:14.000
Chế độ xem tường thuật cho Nhiệm vụ này cho chúng ta biết rằng nó đã chạy trên một luồng nền trong một khoảng thời gian ngắn và sau đó chạy trên Luồng chính trong một thời gian dài.

00:09:14.000 --> 00:09:23.000
Để điều tra thêm, chúng ta có thể ghim Chủ đề chính vào dòng thời gian.

00:09:23.000 --> 00:09:27.000
Chủ đề chính đang bị chặn bởi một số Nhiệm vụ chạy dài.

00:09:27.000 --> 00:09:31.000
Điều này thể hiện vấn đề chặn Diễn viên chính mà Mike đã nói đến.

00:09:31.000 --> 00:09:38.000
Vì vậy, những câu hỏi mà chúng ta phải tự hỏi mình là, "Nhiệm vụ này đang làm gì vậy?" Và "Nhiệm vụ này đến từ đâu?"

00:09:38.000 --> 00:09:43.000
Chúng ta có thể chuyển trở lại chế độ xem tường thuật để trả lời cả hai câu hỏi này.

00:09:43.000 --> 00:09:50.000
Dấu vết ngược tạo trong chế độ xem chi tiết mở rộng cho thấy rằng nhiệm vụ đã được tạo trong chức năng compressAllFiles.

00:09:50.000 --> 00:09:56.000
Câu chuyện cho thấy Nhiệm vụ đang thực hiện đóng cửa số một trong compressAllFiles.

00:09:56.000 --> 00:10:03.000
Bằng cách nhấp chuột phải vào biểu tượng này, chúng ta có thể mở biểu tượng này trong trình xem nguồn.

00:10:03.000 --> 00:10:08.000
Đóng cửa số một bên trong chức năng này đang gọi công việc nén của chúng tôi.

00:10:08.000 --> 00:10:18.000
Bây giờ chúng ta đã biết Nhiệm vụ này được tạo ở đâu và nó đang làm gì, chúng ta có thể mở mã của mình trong Xcode và điều chỉnh nó để chúng ta không chạy các tính toán nặng nề này trên Luồng chính.

00:10:18.000 --> 00:10:24.000
Chức năng nén tệp nằm trong lớp CompressionState.

00:10:24.000 --> 00:10:29.000
Toàn bộ lớp CompressionState được chú thích để chạy trên @MainActor.

00:10:29.000 --> 00:10:32.000
Điều này giải thích tại sao Nhiệm vụ cũng chạy trên Chủ đề Chính.

00:10:32.000 --> 00:10:44.000
Chúng tôi cần toàn bộ lớp này nằm trên MainActor vì thuộc tính @Published ở đây chỉ phải được cập nhật từ Chủ đề chính, nếu không, chúng tôi có thể gặp sự cố về thời gian chạy.

00:10:44.000 --> 00:10:49.000
Vì vậy, thay vào đó chúng ta có thể cố gắng chuyển đổi lớp này thành Diễn viên của riêng nó.

00:10:49.000 --> 00:11:01.000
Tuy nhiên, trình biên dịch sẽ cho chúng tôi biết rằng chúng tôi không thể làm điều này bởi vì về cơ bản chúng tôi sẽ nói rằng trạng thái có thể thay đổi được chia sẻ này cần được bảo vệ bởi hai Diễn viên khác nhau.

00:11:01.000 --> 00:11:04.000
Nhưng điều đó cho chúng ta một gợi ý về giải pháp thực sự là gì.

00:11:04.000 --> 00:11:09.000
Chúng tôi có hai phần khác nhau của trạng thái có thể thay đổi ở đây trong lớp này.

00:11:09.000 --> 00:11:16.000
Một phần của trạng thái, thuộc tính 'tệp', cần được cách ly với MainActor vì nó được SwiftUI quan sát.

00:11:16.000 --> 00:11:27.000
Nhưng quyền truy cập vào phần khác của trạng thái, nhật ký, cần được bảo vệ khỏi sự truy cập đồng thời, nhưng luồng nào truy cập nhật ký tại bất kỳ điểm nhất định nào không quan trọng.

00:11:27.000 --> 00:11:32.000
Do đó, nó không thực sự cần phải có trên Diễn viên chính.

00:11:32.000 --> 00:11:38.000
Tuy nhiên, chúng tôi vẫn muốn bảo vệ nó khỏi sự truy cập đồng thời, vì vậy chúng tôi gói nó trong Diễn viên của chính nó.

00:11:38.000 --> 00:11:45.000
Tất cả những gì chúng ta cần bây giờ là thêm một cách để Nhiệm vụ nhảy giữa hai khi cần thiết.

00:11:45.000 --> 00:11:53.000
Chúng ta có thể tạo một Diễn viên mới và gọi nó là ParallelCompressor.

00:11:53.000 --> 00:12:04.000
Sau đó, chúng ta có thể sao chép trạng thái nhật ký vào Diễn viên mới và thêm một số mã thiết lập bổ sung.

00:12:04.000 --> 00:12:08.000
Từ đây, chúng ta cần làm cho những Diễn viên này giao tiếp với nhau.

00:12:08.000 --> 00:12:27.000
Đầu tiên, hãy xóa mã đề cập đến biến nhật ký khỏi lớp CompressionState và thêm nó vào ParallelCompressor Actor của chúng tôi.

00:12:27.000 --> 00:12:43.000
Sau đó, cuối cùng, chúng ta cần cập nhật CompressionState để gọi compressFile trên ParallelCompressor.

00:12:43.000 --> 00:12:48.000
Với những thay đổi này, hãy kiểm tra lại ứng dụng của chúng tôi.

00:12:48.000 --> 00:12:55.000
Một lần nữa, tôi sẽ thả các tệp lớn vào ứng dụng của chúng tôi.

00:12:55.000 --> 00:13:01.000
Giao diện người dùng không còn bị treo nữa, đó là một cải tiến tuyệt vời, nhưng chúng tôi không đạt được tốc độ mà chúng tôi mong đợi.

00:13:01.000 --> 00:13:08.000
Chúng tôi thực sự muốn tận dụng tối đa tất cả các lõi trong máy để thực hiện công việc này càng nhanh càng tốt.

00:13:08.000 --> 00:13:12.000
Mike, chúng ta nên đề phòng điều gì khác?

00:13:12.000 --> 00:13:19.000
Mike: Chúng tôi đã giải quyết vấn đề của mình bằng cách chuyển công việc ra khỏi Diễn viên chính, nhưng chúng tôi vẫn không đạt được hiệu suất mà chúng tôi muốn.

00:13:19.000 --> 00:13:22.000
Để hiểu tại sao, chúng ta cần xem xét kỹ hơn các Diễn viên.

00:13:22.000 --> 00:13:26.000
Các diễn viên làm cho nó an toàn cho nhiều nhiệm vụ để thao tác trạng thái được chia sẻ.

00:13:26.000 --> 00:13:31.000
Tuy nhiên, họ làm điều này bằng cách tuần tự hóa quyền truy cập vào trạng thái được chia sẻ đó.

00:13:31.000 --> 00:13:38.000
Chỉ một nhiệm vụ tại một thời điểm được phép chiếm giữ Diễn viên và các nhiệm vụ khác cần sử dụng Diễn viên đó sẽ đợi.

00:13:38.000 --> 00:13:45.000
Đồng thời Swift cho phép tính toán song song bằng cách sử dụng các nhiệm vụ phi cấu trúc, nhóm tác vụ và let không đồng bộ.

00:13:45.000 --> 00:13:49.000
Lý tưởng nhất, các cấu trúc này có thể sử dụng nhiều lõi CPU cùng một lúc.

00:13:49.000 --> 00:13:57.000
Khi sử dụng Actors từ mã đó, hãy cẩn thận thực hiện một lượng lớn công việc trên một Actor được chia sẻ giữa các nhiệm vụ này.

00:13:57.000 --> 00:14:04.000
Khi nhiều tác vụ cố gắng sử dụng cùng một Diễn viên cùng một lúc, Diễn viên sẽ tuần tự hóa việc thực hiện các tác vụ đó.

00:14:04.000 --> 00:14:11.000
Bởi vì điều này, chúng ta mất đi lợi ích hiệu suất của tính toán song song.

00:14:11.000 --> 00:14:16.000
Điều này là do mỗi nhiệm vụ phải đợi Diễn viên có sẵn.

00:14:16.000 --> 00:14:23.000
Để khắc phục điều này, chúng tôi cần đảm bảo rằng các tác vụ chỉ chạy trên Diễn viên khi chúng thực sự cần quyền truy cập độc quyền vào dữ liệu của Diễn viên.

00:14:23.000 --> 00:14:25.000
Mọi thứ khác nên chạy trốn khỏi Diễn viên.

00:14:25.000 --> 00:14:28.000
Chúng tôi chia nhiệm vụ thành nhiều phần.

00:14:28.000 --> 00:14:32.000
Một số phần phải chạy trên Diễn viên, và những phần khác thì không.

00:14:32.000 --> 00:14:39.000
Các đoạn bị cô lập không phải của Diễn viên có thể được thực hiện song song, có nghĩa là máy tính có thể hoàn thành công việc nhanh hơn nhiều.

00:14:39.000 --> 00:14:41.000
Hãy xem bản demo của điều này đang hoạt động.

00:14:41.000 --> 00:14:43.000
Harjas: Cảm ơn, Mike.

00:14:43.000 --> 00:14:49.000
Hãy cùng xem dấu vết của ứng dụng "File Squeezer" được cập nhật của chúng tôi và ghi nhớ những gì Mike vừa dạy chúng tôi.

00:14:49.000 --> 00:14:57.000
Chế độ xem Tóm tắt Nhiệm vụ cho chúng ta thấy rằng mã đồng thời của chúng ta đang dành một khoảng thời gian đáng báo động ở trạng thái Enqueued.

00:14:57.000 --> 00:15:02.000
Điều này có nghĩa là chúng tôi có rất nhiều Nhiệm vụ đang chờ để có quyền truy cập độc quyền vào một Diễn viên.

00:15:02.000 --> 00:15:07.000
Hãy ghim một trong những Nhiệm vụ này để tìm hiểu lý do tại sao.

00:15:07.000 --> 00:15:16.000
Nhiệm vụ này dành khá nhiều thời gian để truy cập vào ParallelCompressor Actor trước khi nó chạy công việc nén.

00:15:16.000 --> 00:15:23.000
Hãy tiếp tục và ghim Diễn viên vào dòng thời gian của chúng ta.

00:15:23.000 --> 00:15:28.000
Ở đây chúng tôi có một số dữ liệu cấp cao nhất cho ParallelCompressor Actor.

00:15:28.000 --> 00:15:33.000
Hàng đợi diễn viên này dường như đang bị chặn bởi một số Nhiệm vụ kéo dài.

00:15:33.000 --> 00:15:37.000
Nhiệm vụ thực sự chỉ nên ở trên một Diễn viên miễn là cần thiết.

00:15:37.000 --> 00:15:42.000
Hãy quay lại câu chuyện Nhiệm vụ.

00:15:42.000 --> 00:15:50.000
Sau khi xếp hàng trên ParallelCompressor, Task chạy ở mức đóng số một trong compressAllFiles.

00:15:50.000 --> 00:15:52.000
Vậy hãy bắt đầu cuộc điều tra của chúng ta ở đó.

00:15:52.000 --> 00:15:59.000
Mã nguồn cho chúng ta thấy rằng việc đóng cửa này chủ yếu đang chạy công việc nén của chúng ta.

00:15:59.000 --> 00:16:11.000
Vì hàm compressFile là một phần của ParallelCompressor Actor, toàn bộ việc thực thi hàm này xảy ra trên Actor; chặn tất cả các công việc nén khác.

00:16:11.000 --> 00:16:22.000
Để giải quyết vấn đề này, chúng ta cần kéo hàm compressFile ra khỏi Actor-isolation và vào một nhiệm vụ tách rời.

00:16:22.000 --> 00:16:31.000
Bằng cách này, chúng ta chỉ có thể có nhiệm vụ tách rời trên một Diễn viên miễn là cần thiết để cập nhật trạng thái có thể thay đổi có liên quan.

00:16:31.000 --> 00:16:42.000
Vì vậy, bây giờ chức năng nén có thể được thực thi tự do, trên bất kỳ luồng nào trong nhóm luồng, cho đến khi nó cần truy cập trạng thái được bảo vệ bởi Actor.

00:16:42.000 --> 00:16:48.000
Ví dụ, khi nó cần truy cập thuộc tính 'tệp', nó sẽ chuyển sang Diễn viên chính.

00:16:48.000 --> 00:17:01.000
Nhưng ngay sau khi hoàn thành ở đó, nó sẽ di chuyển vào "biển đồng thời" một lần nữa, cho đến khi nó cần truy cập thuộc tính nhật ký, mà nó chuyển sang ParallelCompressor Actor.

00:17:01.000 --> 00:17:08.000
Nhưng một lần nữa, ngay sau khi nó được hoàn thành ở đó, nó để Diễn viên một lần nữa được thực thi trên nhóm chủ đề.

00:17:08.000 --> 00:17:14.000
Nhưng tất nhiên, chúng tôi không chỉ có một nhiệm vụ thực hiện công việc nén; chúng tôi có rất nhiều.

00:17:14.000 --> 00:17:23.000
Và bằng cách không bị ràng buộc đối với một Diễn viên, tất cả chúng có thể được thực thi đồng thời, chỉ bị giới hạn bởi số lượng luồng.

00:17:23.000 --> 00:17:33.000
Tất nhiên, mỗi Diễn viên chỉ có thể thực hiện một nhiệm vụ tại một thời điểm, nhưng hầu hết thời gian, Nhiệm vụ của chúng ta không cần phải ở trên một Diễn viên.

00:17:33.000 --> 00:17:43.000
Vì vậy, như Mike đã giải thích, điều này cho phép các tác vụ nén của chúng tôi được thực hiện song song và sử dụng tất cả các lõi CPU có sẵn.

00:17:43.000 --> 00:17:47.000
Vậy hãy thay đổi điều này ngay bây giờ.

00:17:47.000 --> 00:17:53.000
Chúng ta có thể đánh dấu hàm compressFile là không cô lập.

00:17:53.000 --> 00:17:56.000
Điều này dẫn đến một vài lỗi trình biên dịch.

00:17:56.000 --> 00:18:04.000
Bằng cách đánh dấu nó là không cô lập, chúng tôi đã nói với trình biên dịch Swift rằng chúng tôi không cần truy cập vào trạng thái được chia sẻ của Diễn viên này.

00:18:04.000 --> 00:18:06.000
Nhưng điều đó không hoàn toàn đúng.

00:18:06.000 --> 00:18:13.000
Chức năng nhật ký này bị cô lập bởi Actor và nó cần quyền truy cập vào trạng thái có thể thay đổi được chia sẻ.

00:18:13.000 --> 00:18:29.000
Để khắc phục điều này, chúng ta cần làm cho hàm này không đồng bộ và sau đó đánh dấu tất cả các lệnh gọi nhật ký của chúng ta bằng từ khóa await.

00:18:29.000 --> 00:18:40.000
Bây giờ chúng ta cần cập nhật việc tạo nhiệm vụ của mình để tạo một nhiệm vụ tách rời.

00:18:40.000 --> 00:18:47.000
Chúng tôi làm điều này để đảm bảo Nhiệm vụ không kế thừa bối cảnh Diễn viên mà nó được tạo ra.

00:18:47.000 --> 00:18:56.000
Đối với các nhiệm vụ tách rời, chúng ta cần nắm bắt bản thân một cách rõ ràng.

00:18:56.000 --> 00:19:05.000
Hãy kiểm tra lại đơn đăng ký của chúng tôi.

00:19:05.000 --> 00:19:12.000
Ứng dụng có thể nén tất cả các tệp cùng một lúc và giao diện người dùng vẫn đáp ứng.

00:19:12.000 --> 00:19:18.000
Để xác minh những cải tiến của chúng tôi, chúng tôi có thể kiểm tra nhạc cụ Swift Actors.

00:19:18.000 --> 00:19:30.000
Nhìn vào Diễn viên ParallelCompressor, hầu hết các tác phẩm được thực hiện trên Diễn viên chỉ trong một khoảng thời gian ngắn và kích thước hàng đợi không bao giờ vượt quá tầm kiểm soát.

00:19:30.000 --> 00:19:42.000
Tóm lại, chúng tôi đã sử dụng Công cụ để cô lập nguyên nhân của giao diện người dùng bị treo, chúng tôi đã cấu trúc lại mã đồng thời của mình để song song tốt hơn và xác minh các cải tiến hiệu suất bằng cách sử dụng dữ liệu.

00:19:42.000 --> 00:19:46.000
Bây giờ Mike sẽ cho chúng tôi biết về một số vấn đề hiệu suất tiềm ẩn khác.

00:19:46.000 --> 00:19:50.000
Mike: Có hai vấn đề phổ biến mà tôi muốn đề cập ngoài những gì chúng ta đã thấy trong bản demo.

00:19:50.000 --> 00:19:53.000
Đầu tiên, hãy nói về sự kiệt sức của bể bơi.

00:19:53.000 --> 00:19:57.000
Sự cạn kiệt của bể bơi có thể làm tổn thương hiệu suất hoặc thậm chí bế tắc một ứng dụng.

00:19:57.000 --> 00:20:02.000
Đồng thời nhanh chóng yêu cầu các tác vụ để tiến hành trước khi chúng đang chạy.

00:20:02.000 --> 00:20:06.000
Khi một nhiệm vụ chờ đợi điều gì đó, nó thường làm như vậy bằng cách tạm dừng.

00:20:06.000 --> 00:20:15.000
Tuy nhiên, mã trong một tác vụ có thể thực hiện cuộc gọi chặn, chẳng hạn như chặn tệp hoặc IO mạng hoặc lấy khóa mà không bị đình chỉ.

00:20:15.000 --> 00:20:20.000
Điều này phá vỡ yêu cầu đối với các nhiệm vụ để tiến bộ.

00:20:20.000 --> 00:20:27.000
Khi điều này xảy ra, nhiệm vụ tiếp tục chiếm chủ đề nơi nó đang thực thi, nhưng nó không thực sự sử dụng lõi CPU.

00:20:27.000 --> 00:20:34.000
Bởi vì nhóm luồng bị giới hạn và một số trong số chúng bị chặn, thời gian chạy đồng thời không thể sử dụng đầy đủ tất cả các lõi CPU.

00:20:34.000 --> 00:20:41.000
Điều này làm giảm số lượng tính toán song song có thể được thực hiện và hiệu suất tối đa của ứng dụng của bạn.

00:20:41.000 --> 00:20:52.000
Trong trường hợp cực đoan, khi toàn bộ nhóm luồng bị chiếm bởi các tác vụ bị chặn và họ đang chờ đợi thứ gì đó yêu cầu một tác vụ mới để chạy trên nhóm luồng, thời gian chạy đồng thời có thể bị bế tắc.

00:20:52.000 --> 00:20:55.000
Đảm bảo tránh chặn các cuộc gọi trong các nhiệm vụ.

00:20:55.000 --> 00:21:00.000
Tệp và mạng IO phải được thực hiện bằng cách sử dụng API không đồng bộ.

00:21:00.000 --> 00:21:03.000
Tránh chờ đợi các biến điều kiện hoặc semaphores.

00:21:03.000 --> 00:21:12.000
Các khóa hạt mịn, được giữ ngắn gọn có thể chấp nhận được nếu cần thiết, nhưng tránh các khóa có nhiều tranh chấp hoặc được giữ trong thời gian dài.

00:21:12.000 --> 00:21:23.000
Nếu bạn có mã cần thực hiện những việc này, hãy di chuyển mã đó ra ngoài nhóm luồng đồng thời - ví dụ: bằng cách chạy nó trên hàng đợi Dispatch - và kết nối nó với thế giới đồng thời bằng cách sử dụng tiếp tục.

00:21:23.000 --> 00:21:30.000
Bất cứ khi nào có thể, hãy sử dụng API không đồng bộ để chặn các hoạt động để giữ cho hệ thống hoạt động trơn tru.

00:21:30.000 --> 00:21:35.000
Khi bạn đang sử dụng tiếp tục, bạn phải cẩn thận để sử dụng chúng một cách chính xác.

00:21:35.000 --> 00:21:40.000
Tiếp tục là cầu nối giữa đồng thời Swift và các dạng mã không đồng bộ khác.

00:21:40.000 --> 00:21:47.000
Việc tiếp tục đình chỉ nhiệm vụ hiện tại và cung cấp một cuộc gọi lại để tiếp tục nhiệm vụ khi được gọi.

00:21:47.000 --> 00:21:51.000
Điều này sau đó có thể được sử dụng với các API không đồng bộ dựa trên gọi lại.

00:21:51.000 --> 00:21:58.000
Từ quan điểm của Swift đồng thời, nhiệm vụ bị đình chỉ, và sau đó nó tiếp tục khi việc tiếp tục được nối lại.

00:21:58.000 --> 00:22:05.000
Từ quan điểm của API không đồng bộ dựa trên gọi lại, công việc bắt đầu và sau đó gọi lại được gọi khi công việc hoàn thành.

00:22:05.000 --> 00:22:14.000
Công cụ Swift Concurrency biết về các lần tiếp tục và sẽ đánh dấu khoảng thời gian cho phù hợp, cho bạn thấy rằng nhiệm vụ đang chờ tiếp tục được gọi.

00:22:14.000 --> 00:22:20.000
Các cuộc gọi lại liên tục có một yêu cầu đặc biệt: chúng phải được gọi chính xác một lần, không hơn không kém.

00:22:20.000 --> 00:22:29.000
Đây là một yêu cầu phổ biến trong các API dựa trên gọi lại, nhưng nó có xu hướng là một yêu cầu không chính thức và không được thực thi bởi ngôn ngữ và các giám sát là phổ biến.

00:22:29.000 --> 00:22:32.000
Đồng thời nhanh chóng làm cho điều này trở thành một yêu cầu khó khăn.

00:22:32.000 --> 00:22:36.000
Nếu cuộc gọi lại được gọi hai lần, chương trình sẽ gặp sự cố hoặc hoạt động sai.

00:22:36.000 --> 00:22:40.000
Nếu cuộc gọi lại không bao giờ được gọi, nhiệm vụ sẽ bị rò rỉ.

00:22:40.000 --> 00:22:45.000
Trong đoạn mã này, chúng tôi sử dụng withCheckedContinuation để tiếp tục.

00:22:45.000 --> 00:22:48.000
Sau đó chúng tôi gọi một API dựa trên gọi lại.

00:22:48.000 --> 00:22:51.000
Trong cuộc gọi lại, chúng tôi tiếp tục tiếp tục.

00:22:51.000 --> 00:22:54.000
Điều này đáp ứng yêu cầu gọi nó chính xác một lần.

00:22:54.000 --> 00:22:58.000
Điều quan trọng là phải cẩn thận khi mã phức tạp hơn.

00:22:58.000 --> 00:23:02.000
Ở bên trái, chúng tôi đã sửa đổi cuộc gọi lại để chỉ tiếp tục tiếp tục thành công.

00:23:02.000 --> 00:23:04.000
Đây là một lỗi.

00:23:04.000 --> 00:23:10.000
Khi thất bại, việc tiếp tục sẽ không được tiếp tục và nhiệm vụ sẽ bị đình chỉ mãi mãi.

00:23:10.000 --> 00:23:13.000
Ở bên phải, chúng tôi đang tiếp tục tiếp tục hai lần.

00:23:13.000 --> 00:23:17.000
Đây cũng là một lỗi, và ứng dụng sẽ hoạt động sai hoặc gặp sự cố.

00:23:17.000 --> 00:23:23.000
Cả hai đoạn mã này đều vi phạm yêu cầu tiếp tục tiếp tục chính xác một lần.

00:23:23.000 --> 00:23:27.000
Hai loại tiếp tục có sẵn: đã kiểm tra và không an toàn.

00:23:27.000 --> 00:23:35.000
Luôn sử dụng withCheckedContinuation API để tiếp tục trừ khi hiệu suất hoàn toàn quan trọng.

00:23:35.000 --> 00:23:40.000
Các tiếp tục được kiểm tra tự động phát hiện việc lạm dụng và gắn cờ lỗi.

00:23:40.000 --> 00:23:44.000
Khi một lần tiếp tục được kiểm tra được gọi hai lần, sự tiếp tục sẽ bẫy.

00:23:44.000 --> 00:23:53.000
Khi phần tiếp tục hoàn toàn không bao giờ được gọi, một thông báo sẽ được in lên bảng điều khiển khi phần tiếp tục bị phá hủy cảnh báo bạn rằng phần tiếp tục bị rò rỉ.

00:23:53.000 --> 00:24:00.000
Công cụ Swift Concurrency sẽ hiển thị nhiệm vụ tương ứng bị mắc kẹt vô thời hạn ở trạng thái tiếp tục.

00:24:00.000 --> 00:24:04.000
Có nhiều thứ hơn để xem xét cho mẫu Swift Concurrency mới trong Instruments.

00:24:04.000 --> 00:24:15.000
Bạn có thể nhận trực quan hóa đồ họa của đồng thời có cấu trúc, xem các calltrees tạo tác vụ và kiểm tra các hướng dẫn lắp ráp chính xác để có được bức tranh đầy đủ về thời gian chạy Swift Concurrency.

00:24:15.000 --> 00:24:22.000
Để tìm hiểu thêm về cách Swift Concurrency hoạt động dưới mui xe, hãy xem phiên năm ngoái trên "Swift Concurrency: Hậu trường."

00:24:22.000 --> 00:24:27.000
Và để tìm hiểu thêm về các cuộc đua dữ liệu, hãy xem "Loại bỏ các cuộc đua dữ liệu bằng Swift Concurrency."

00:24:27.000 --> 00:24:28.000
Cảm ơn vì đã xem!

00:24:28.000 --> 23:59:59.000
Và vui vẻ gỡ lỗi mã đồng thời của bạn.

