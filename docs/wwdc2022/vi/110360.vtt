WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:13.000
Xin chào! Tên tôi là Tom, và tôi là một phần của nhóm Swift tại Apple.

00:00:13.000 --> 00:00:18.000
Hôm nay tôi muốn chia sẻ những gì cần thiết để mở rộng ứng dụng iOS lên đám mây.

00:00:18.000 --> 00:00:24.000
Nhiều ứng dụng của chúng tôi bắt đầu tập trung vào một thiết bị duy nhất, thường là iPhone.

00:00:24.000 --> 00:00:33.000
Khi việc sử dụng tăng lên, chúng tôi thấy mình muốn đưa nó đến các thiết bị bổ sung như Mac, đồng hồ hoặc các nền tảng và thiết bị khác của Apple.

00:00:33.000 --> 00:00:38.000
Xcode giúp chúng tôi tổ chức và xây dựng ứng dụng của mình cho các nền tảng này.

00:00:38.000 --> 00:00:47.000
Chúng tôi có thể chia sẻ mã bằng cách sử dụng các gói trong khi nắm bắt các khía cạnh độc đáo của từng thiết bị trong mã ứng dụng cụ thể của nền tảng.

00:00:47.000 --> 00:00:54.000
Khi các hệ thống tiếp tục phát triển và phát triển, các ứng dụng thường cần bổ sung cho ứng dụng khách hàng bằng một thành phần máy chủ.

00:00:54.000 --> 00:00:59.000
Các thành phần máy chủ này cho phép ứng dụng khách mở rộng chức năng của chúng lên đám mây.

00:00:59.000 --> 00:01:11.000
Ví dụ, các tác vụ giảm tải có thể được thực hiện trong nền, các tác vụ giảm tải nặng về tính toán hoặc các tác vụ yêu cầu quyền truy cập vào dữ liệu không có sẵn trên thiết bị.

00:01:11.000 --> 00:01:21.000
Thông thường, các thành phần máy chủ cần được xây dựng bằng cách sử dụng các công cụ và phương pháp khác nhau từ các đối tác máy khách của chúng, tạo ra sự trùng lặp về nỗ lực và các thách thức tích hợp.

00:01:21.000 --> 00:01:30.000
Sử dụng Swift để xây dựng các thành phần máy chủ giúp thu hẹp khoảng cách công nghệ này, cung cấp một môi trường quen thuộc trên toàn bộ ngăn xếp.

00:01:30.000 --> 00:01:34.000
Hãy xem việc xây dựng một ứng dụng máy chủ trong Swift trông như thế nào.

00:01:34.000 --> 00:01:38.000
Các ứng dụng máy chủ được mô hình hóa như các gói Swift.

00:01:38.000 --> 00:01:43.000
Gói xác định một mục tiêu thực thi ánh xạ điểm vào ứng dụng.

00:01:43.000 --> 00:01:54.000
Để biến ứng dụng thành ứng dụng web, chúng tôi có thể thêm sự phụ thuộc vào khung web giúp chúng tôi cấu trúc mã của mình và cung cấp các tiện ích cơ bản như định tuyến.

00:01:54.000 --> 00:02:03.000
Trong ví dụ này, chúng tôi sử dụng khung web Vapor, một dự án cộng đồng mã nguồn mở phổ biến để xây dựng các dịch vụ web.

00:02:03.000 --> 00:02:10.000
Cũng như các tệp thực thi dựa trên Swift khác, điểm vào của chương trình được mô hình hóa tốt nhất bằng cách sử dụng chú thích @main.

00:02:10.000 --> 00:02:15.000
Để tích hợp khung web, chúng tôi thêm mã bootstrap có liên quan vào chức năng chính.

00:02:15.000 --> 00:02:21.000
Loại ứng dụng được sử dụng trong ví dụ này được cung cấp bởi khung web Vapor.

00:02:21.000 --> 00:02:26.000
Với việc khởi động cơ bản tại chỗ, chúng tôi có thể làm cho ứng dụng của mình làm điều gì đó hữu ích.

00:02:26.000 --> 00:02:31.000
Ví dụ, hãy thêm mã để chào đón người dùng đưa ra yêu cầu đến máy chủ.

00:02:31.000 --> 00:02:38.000
Chúng tôi sử dụng khung web để xác định điểm cuối HTTP và trỏ nó đến một phương thức cung cấp lời chào.

00:02:38.000 --> 00:02:50.000
Tiến thêm một bước nữa, chúng tôi thêm điểm cuối HTTP thứ hai, điểm này xử lý yêu cầu bài đăng HTTP và lặp lại nội dung của nội dung yêu cầu trở lại người gọi.

00:02:50.000 --> 00:02:52.000
Hãy xem điều này đang hoạt động.

00:02:52.000 --> 00:02:55.000
Ở đây chúng tôi có ứng dụng máy chủ của chúng tôi trong Xcode.

00:02:55.000 --> 00:03:01.000
Vì chúng tôi chỉ mới bắt đầu, chúng tôi có thể chạy máy chủ cục bộ trên máy của riêng mình để kiểm tra mọi thứ.

00:03:01.000 --> 00:03:17.000
Để chạy nó cục bộ, chúng tôi chọn sơ đồ "MyServer" được tạo cho chúng tôi bởi Xcode, sử dụng "My Mac" làm đích đến và nhấn "run".

00:03:17.000 --> 00:03:23.000
Khi ứng dụng đã khởi chạy, chúng ta có thể sử dụng bảng điều khiển Xcode để kiểm tra các thông báo nhật ký do máy chủ phát ra.

00:03:23.000 --> 00:03:31.000
Trong trường hợp này, chúng ta có thể thấy rằng máy chủ đã khởi động và lắng nghe trên địa chỉ localhost (127.0.0.1) cổng 8080.

00:03:31.000 --> 00:03:34.000
Chúng tôi có thể sử dụng thông tin này để kiểm tra máy chủ của mình.

00:03:34.000 --> 00:03:39.000
Hãy chuyển sang thiết bị đầu cuối và đưa ra yêu cầu đến địa chỉ máy chủ được quảng cáo.

00:03:39.000 --> 00:03:43.000
Chúng tôi sử dụng một tiện ích gọi là "curl" để đưa ra yêu cầu.

00:03:43.000 --> 00:03:48.000
Sử dụng điểm cuối đầu tiên của chúng tôi.

00:03:48.000 --> 00:03:51.000
Và cái thứ hai của chúng tôi.

00:03:51.000 --> 00:03:59.000
Chuyển một số dữ liệu để lặp lại.

00:03:59.000 --> 00:04:01.000
Tuyệt vời!

00:04:01.000 --> 00:04:08.000
Sử dụng thiết bị đầu cuối chắc chắn rất thú vị, nhưng điều chúng tôi thực sự muốn biết là cách gọi máy chủ của chúng tôi từ ứng dụng iOS.

00:04:08.000 --> 00:04:09.000
Hãy cùng tìm hiểu điều đó.

00:04:09.000 --> 00:04:15.000
Đây là một ví dụ về cấu trúc dữ liệu Swift mà chúng ta có thể sử dụng để trừu tượng hóa sự tương tác với máy chủ.

00:04:15.000 --> 00:04:23.000
Chúng tôi mô hình hóa các API máy chủ như các phương thức không đồng bộ trên sự trừu tượng của chúng tôi, bởi vì mạng vốn không đồng bộ.

00:04:23.000 --> 00:04:32.000
Chúng tôi sử dụng URLSession để thực hiện một yêu cầu không đồng bộ sau đó phân tích cú pháp phản hồi của máy chủ và cuối cùng trả lại cho người gọi.

00:04:32.000 --> 00:04:39.000
Trong trường hợp này, phản hồi của máy chủ là một chuỗi đơn giản, nhưng trên thực tế, nó có thể phức tạp hơn.

00:04:39.000 --> 00:04:47.000
Ví dụ, phản hồi có thể được mã hóa trong JSON, trong trường hợp đó chúng ta có thể giải mã nó bằng hệ thống Codable của Swift.

00:04:47.000 --> 00:04:50.000
Hãy kết hợp tất cả những điều này lại với nhau trong Xcode.

00:04:50.000 --> 00:04:56.000
Chúng tôi đang sử dụng không gian làm việc Xcode để xây dựng và kiểm tra các ứng dụng iOS và máy chủ cạnh nhau.

00:04:56.000 --> 00:05:00.000
Chúng tôi đã có sẵn bản tóm tắt máy chủ ứng dụng iOS.

00:05:00.000 --> 00:05:07.000
Hãy thay đổi SwiftUI ContentView mặc định để tìm nạp lời chào của máy chủ bằng cách sử dụng mã mà chúng tôi đã đặt cùng nhau.

00:05:07.000 --> 00:05:13.000
Đầu tiên chúng tôi tạo ra một biến trạng thái được gọi là serverGreeting.

00:05:13.000 --> 00:05:21.000
Tiếp theo, chúng tôi liên kết máy chủGreeting với màn hình Văn bản.

00:05:21.000 --> 00:05:27.000
Cuối cùng, chúng tôi thêm một nhiệm vụ để gọi API máy chủ và đặt trạng thái.

00:05:27.000 --> 00:05:31.000
Khi mã đã sẵn sàng, chúng ta có thể chạy ứng dụng trong trình giả lập.

00:05:31.000 --> 00:05:42.000
Chúng tôi chọn sơ đồ "MyApp", một trình giả lập và nhấn "chạy".

00:05:42.000 --> 00:05:44.000
Ồ, không! Chúng tôi gặp lỗi!

00:05:44.000 --> 00:05:48.000
Hmm, đây có vẻ là một số loại lỗi kết nối.

00:05:48.000 --> 00:05:52.000
Địa chỉ có vẻ đúng, vì vậy chắc hẳn chúng ta đã quên khởi động máy chủ cục bộ.

00:05:52.000 --> 00:06:07.000
Hãy chuyển trở lại Xcode, chọn sơ đồ máy chủ và chạy máy chủ.

00:06:07.000 --> 00:06:14.000
Bây giờ, hãy khởi động lại ứng dụng của chúng ta, bắt chéo ngón tay của chúng ta...

00:06:14.000 --> 00:06:16.000
Và whoo-hoo! Nó đã hoạt động!

00:06:16.000 --> 00:06:21.000
Để hoàn thành phần này của bản demo, hãy triển khai ứng dụng của chúng tôi lên đám mây.

00:06:21.000 --> 00:06:28.000
Có rất nhiều nhà cung cấp đám mây để lựa chọn, bao gồm AWS, Google Cloud, Azure, Heroku và nhiều nhà cung cấp khác.

00:06:28.000 --> 00:06:31.000
Trong ví dụ này, chúng tôi sẽ sử dụng Heroku.

00:06:31.000 --> 00:06:36.000
Heroku có một git đẩy thuận tiện để triển khai hệ thống cho các dự án nhỏ như ứng dụng demo này.

00:06:36.000 --> 00:06:39.000
Hãy chuyển sang thiết bị đầu cuối để bắt đầu triển khai.

00:06:39.000 --> 00:06:48.000
Sau khi thiết lập tài khoản của chúng tôi và định cấu hình ứng dụng của chúng tôi với dịch vụ Heroku, chúng tôi có thể đẩy mã của mình đến điều khiển từ xa Heroku.

00:06:48.000 --> 00:07:02.000
Và tắt nó đi!

00:07:02.000 --> 00:07:11.000
Heroku sử dụng một công nghệ gọi là buildpacks để biên dịch ứng dụng từ xa, sau đó triển khai các tạo tác nhị phân đến một máy chủ tạm thời.

00:07:11.000 --> 00:07:19.000
Gói xây dựng Heroku swift được xây dựng bởi các thành viên của cộng đồng mã nguồn mở Swift và nó có sẵn cho tất cả người dùng Swift trên Máy chủ.

00:07:19.000 --> 00:07:24.000
Với ứng dụng của chúng tôi được triển khai, chúng tôi có thể kiểm tra nó bằng cách sử dụng curl, như chúng tôi đã làm với máy chủ cục bộ của mình.

00:07:24.000 --> 00:07:28.000
Hãy kiểm tra điểm cuối đầu tiên.

00:07:28.000 --> 00:07:37.000
Sao chép địa chỉ ở đây.

00:07:37.000 --> 00:07:42.000
Và cái thứ hai của chúng tôi.

00:07:42.000 --> 00:07:51.000
Lần này, chúng tôi sẽ gửi một tải trọng khác.

00:07:51.000 --> 00:07:55.000
Ngọt ngào, ứng dụng của chúng tôi đã được triển khai thành công!

00:07:55.000 --> 00:08:00.000
Trước khi chúng ta tiếp tục, hãy tạm dừng ở đây và xem lại những điều rút ra chính từ phần này của cuộc nói chuyện.

00:08:00.000 --> 00:08:08.000
Nếu bạn đã sử dụng Swift để xây dựng Ứng dụng iOS hoặc macOS, bạn cũng có thể sử dụng nó để phát triển phía máy chủ của hệ thống.

00:08:08.000 --> 00:08:15.000
Xcode giúp chúng tôi phát triển và gỡ lỗi các thành phần khác nhau của hệ thống, cả máy khách và máy chủ, tất cả trong một Không gian làm việc.

00:08:15.000 --> 00:08:20.000
Và cuối cùng, bạn có thể lựa chọn các nhà cung cấp đám mây để triển khai các ứng dụng máy chủ dựa trên Swift.

00:08:20.000 --> 00:08:28.000
Thông tin bổ sung về việc triển khai cho các nền tảng đám mây này có thể được tìm thấy trên tài liệu Máy chủ Swift tại swift.org.

00:08:28.000 --> 00:08:33.000
Bây giờ chúng ta đã thấy một thiết lập cơ bản, hãy xem xét một ví dụ thực tế hơn - Xe tải thực phẩm!

00:08:33.000 --> 00:08:36.000
Bạn có thể đã thấy ứng dụng này được sử dụng trong nhiều phiên của chúng tôi.

00:08:36.000 --> 00:08:39.000
Hãy nhìn trộm dưới mui xe và xem dữ liệu được quản lý như thế nào.

00:08:39.000 --> 00:08:43.000
Hmm, có vẻ như danh sách bánh rán được mã hóa cứng.

00:08:43.000 --> 00:08:49.000
Điều này có nghĩa là người dùng ứng dụng có thể thấy một menu bánh rán khác với những gì thực sự có sẵn.

00:08:49.000 --> 00:09:01.000
Mặc dù điều này có thể hữu ích cho một hoạt động Xe tải Thực phẩm nhỏ, một hoạt động có thể làm bất kỳ loại bánh rán nào ngay tại chỗ, chúng tôi muốn xây dựng một đế chế bánh rán nơi thực đơn được tập trung và các xe tải đều hướng đến dịch vụ khách hàng.

00:09:01.000 --> 00:09:06.000
Hãy thiết kế hệ thống Xe tải Thực phẩm tập trung của chúng ta có thể trông như thế nào.

00:09:06.000 --> 00:09:10.000
Chúng tôi đang bắt đầu với ứng dụng iOS của mình, với bộ nhớ trong bộ nhớ.

00:09:10.000 --> 00:09:16.000
Để tập trung menu, chúng ta có thể trích xuất bộ nhớ từ ứng dụng iOS và di chuyển nó đến máy chủ.

00:09:16.000 --> 00:09:22.000
Điều này sẽ cho phép tất cả người dùng ứng dụng chia sẻ cùng một bộ nhớ, và do đó, cùng một menu bánh rán.

00:09:22.000 --> 00:09:28.000
Tương tự như ví dụ trong phần đầu tiên của cuộc nói chuyện, máy chủ của chúng tôi sẽ hiển thị API dựa trên HTTP.

00:09:28.000 --> 00:09:38.000
Ứng dụng iOS sẽ sử dụng một sự trừu tượng để làm việc với các API này, sau đó liên kết chúng lại với nhau với tầng trình bày, trong ví dụ này là SwiftUI.

00:09:38.000 --> 00:09:39.000
Thiết kế của chúng tôi đã hoàn thành.

00:09:39.000 --> 00:09:42.000
Thời gian để viết một số mã ngọt ngào.

00:09:42.000 --> 00:09:47.000
Bạn có thể theo dõi bằng cách tải xuống ứng dụng mẫu Xe tải Thực phẩm từ bộ tài nguyên dành cho nhà phát triển.

00:09:47.000 --> 00:09:59.000
Chúng tôi bắt đầu xây dựng Máy chủ của mình với một khung ứng dụng, sau đó xác định điểm cuối HTTP cho API web "donuts" và trỏ nó đến phương thức "listDonuts" trên máy chủ trừu tượng của chúng tôi.

00:09:59.000 --> 00:10:08.000
Bạn có thể nhận thấy rằng API trả về một Phản hồi thuộc loại Donuts và Phản hồi đó.Donuts phù hợp với một giao thức được gọi là Nội dung.

00:10:08.000 --> 00:10:15.000
Giao thức Nội dung được xác định bởi khung web và giúp chúng tôi mã hóa phản hồi dưới dạng JSON trên dây.

00:10:15.000 --> 00:10:29.000
Bạn cũng có thể nhận thấy rằng API bao gồm một mảng của một Model.Donut bí ẩn, mà chúng tôi vẫn chưa xác định Vì vậy, đây là mô hình dữ liệu của chúng tôi trong tất cả vinh quang của nó: Donut, Dough, Glaze và Topping.

00:10:29.000 --> 00:10:39.000
Một điểm thú vị cần thực hiện ở đây là chúng tôi đã sao chép định nghĩa của mô hình này từ ứng dụng Food Truck iOS của mình, vì chúng tôi cần các mô hình dữ liệu của máy chủ và máy khách để căn chỉnh gần đúng.

00:10:39.000 --> 00:10:43.000
Một điểm thú vị khác là sự phù hợp với giao thức Encodable.

00:10:43.000 --> 00:10:49.000
Điều này là bắt buộc để máy chủ của chúng tôi có thể mã hóa các đối tượng mô hình dưới dạng JSON qua dây.

00:10:49.000 --> 00:10:54.000
Với mô hình dữ liệu và các API cơ bản tại chỗ, chúng ta có thể mở rộng logic của mình để bao gồm sự trừu tượng hóa lưu trữ.

00:10:54.000 --> 00:10:58.000
Việc lưu trữ sẽ cung cấp cho Ứng dụng danh sách các loại bánh rán có sẵn.

00:10:58.000 --> 00:11:01.000
Tại thời điểm này, chúng ta nên có một máy chủ đầy đủ chức năng.

00:11:01.000 --> 00:11:04.000
Nhưng chờ đã! Thực đơn bánh rán của chúng tôi trống rỗng!

00:11:04.000 --> 00:11:07.000
Chúng ta nên lấy thực đơn tập trung từ đâu?

00:11:07.000 --> 00:11:12.000
Lưu trữ luôn là một chủ đề thú vị khi thiết kế các ứng dụng phía máy chủ.

00:11:12.000 --> 00:11:16.000
Có một số chiến lược để lựa chọn, tùy thuộc vào trường hợp sử dụng.

00:11:16.000 --> 00:11:23.000
Nếu dữ liệu ứng dụng tĩnh hoặc thay đổi rất chậm và thủ công, các tệp trên đĩa có thể cung cấp một giải pháp đủ tốt.

00:11:23.000 --> 00:11:32.000
Đối với dữ liệu lấy người dùng làm trung tâm hoặc bộ dữ liệu toàn cầu, iCloud cung cấp một bộ API mà bạn có thể sử dụng trực tiếp từ ứng dụng iOS mà không cần triển khai máy chủ chuyên dụng.

00:11:32.000 --> 00:11:37.000
Khi xử lý dữ liệu động hoặc giao dịch, cơ sở dữ liệu cung cấp một giải pháp tuyệt vời.

00:11:37.000 --> 00:11:42.000
Có rất nhiều công nghệ cơ sở dữ liệu có sẵn cho các ứng dụng phía máy chủ.

00:11:42.000 --> 00:11:48.000
Mỗi công nghệ được thiết kế cho hiệu suất cụ thể, tính nhất quán của dữ liệu và nhu cầu mô hình hóa dữ liệu.

00:11:48.000 --> 00:11:55.000
Trong những năm qua, cộng đồng nguồn mở Swift đã phát triển các trình điều khiển cơ sở dữ liệu giúp tương tác nguyên bản với hầu hết các công nghệ cơ sở dữ liệu.

00:11:55.000 --> 00:12:03.000
Danh sách một phần bao gồm Postgres, MySQL, MongoDB, Redis, DynamoDB, và nhiều danh sách khác.

00:12:03.000 --> 00:12:14.000
Với mục đích đơn giản hóa bản demo này, chúng tôi sẽ chỉ trình diễn chiến lược lưu trữ tệp tĩnh, nhưng bạn có thể tìm hiểu thêm về cách sử dụng cơ sở dữ liệu trên tài liệu Máy chủ Swift tại swift.org.

00:12:14.000 --> 00:12:21.000
Vì chúng tôi đang sử dụng chiến lược lưu trữ tệp tĩnh, chúng tôi bắt đầu bằng cách tạo tệp JSON ghi lại menu bánh rán.

00:12:21.000 --> 00:12:28.000
Sau khi tạo tệp này, chúng tôi có thể làm cho nó có thể truy cập được vào ứng dụng bằng cách sử dụng hỗ trợ tài nguyên của SwiftPM.

00:12:28.000 --> 00:12:33.000
Với điều đó tại chỗ, đã đến lúc làm cho sự trừu tượng lưu trữ của chúng ta trở nên tinh vi hơn.

00:12:33.000 --> 00:12:36.000
Cụ thể, chúng tôi thêm một phương thức "tải".

00:12:36.000 --> 00:12:46.000
Phương pháp này tìm đường dẫn tệp tài nguyên bằng trình truy cập tài nguyên được tạo của SwiftPM, sau đó sử dụng API FileManager để tải nội dung của tệp vào bộ nhớ.

00:12:46.000 --> 00:12:53.000
Cuối cùng, chúng tôi sử dụng JSONDecoder để giải mã nội dung JSON thành mô hình dữ liệu ứng dụng máy chủ.

00:12:53.000 --> 00:12:57.000
Một thay đổi thú vị là Lưu trữ hiện được định nghĩa là một diễn viên.

00:12:57.000 --> 00:13:07.000
Chúng tôi đã chọn sử dụng một diễn viên vì Storage hiện có biến "donuts" có thể thay đổi và các phương thức "load" và "listDonuts" có thể truy cập đồng thời.

00:13:07.000 --> 00:13:16.000
Các diễn viên, lần đầu tiên được giới thiệu trong Swift 5.5, giúp chúng tôi tránh các cuộc đua dữ liệu và xử lý trạng thái có thể thay đổi được chia sẻ một cách an toàn nhưng dễ dàng.

00:13:16.000 --> 00:13:25.000
Trước khi giới thiệu các tác nhân, chúng ta cần phải nhớ và thêm các khối đồng bộ hóa khi truy cập trạng thái có thể thay đổi bằng API như Khóa hoặc Hàng đợi.

00:13:25.000 --> 00:13:28.000
Với các bản cập nhật lưu trữ đã hoàn tất, chúng ta có thể kết hợp tất cả lại với nhau.

00:13:28.000 --> 00:13:33.000
Chúng tôi thêm một phương thức "bootstrap" vào sự trừu tượng hóa máy chủ của chúng tôi và tải bộ nhớ từ đó.

00:13:33.000 --> 00:13:37.000
Sau đó, chúng tôi nối dây bootstrap đến điểm vào thực thi.

00:13:37.000 --> 00:13:42.000
Lưu ý rằng vì lưu trữ bây giờ là một diễn viên, chúng tôi truy cập nó trong một ngữ cảnh không đồng bộ.

00:13:42.000 --> 00:13:43.000
Máy chủ của chúng tôi đã sẵn sàng.

00:13:43.000 --> 00:13:45.000
Hãy chuyển sang phía khách hàng.

00:13:45.000 --> 00:13:52.000
Chúng tôi bắt đầu bằng cách thêm một bản tóm tắt Máy chủ sẽ giúp chúng tôi gói gọn các API của máy chủ.

00:13:52.000 --> 00:14:02.000
Chúng tôi sử dụng URLSession để thực hiện yêu cầu HTTP và JSONDecoder để giải mã phản hồi của máy chủ và chuyển đổi nó từ JSON thành mô hình ứng dụng iOS của chúng tôi.

00:14:02.000 --> 00:14:08.000
Tại thời điểm này, chúng ta có thể xóa menu được mã hóa cứng và thay thế nó bằng một tìm nạp không đồng bộ từ máy chủ.

00:14:08.000 --> 00:14:12.000
Cuối cùng, chúng tôi thực hiện cuộc gọi đến máy chủ từ tác vụ tải ContentView.

00:14:12.000 --> 00:14:14.000
Đến lúc kiểm tra rồi!

00:14:14.000 --> 00:14:17.000
Lần này, đừng quên khởi động máy chủ.

00:14:17.000 --> 00:14:19.000
Chúng tôi sẽ chọn sơ đồ "FoodTruckServer" ở đây.

00:14:19.000 --> 00:14:24.000
Nhấn chạy.

00:14:24.000 --> 00:14:33.000
Và với ứng dụng đang chạy, hãy nhảy vào thiết bị đầu cuối và xem rằng chúng ta có thể truy cập các API.

00:14:33.000 --> 00:14:37.000
Sao chép lại địa chỉ.

00:14:37.000 --> 00:14:43.000
Lần này, chúng ta sẽ sử dụng một tiện ích gọi là jq để in đầu ra JSON đẹp hơn.

00:14:43.000 --> 00:14:46.000
Cái này trông khá ổn.

00:14:46.000 --> 00:14:49.000
Được rồi, đã đến lúc kiểm tra với Ứng dụng của chúng tôi.

00:14:49.000 --> 00:14:52.000
Chuyển sang Xcode.

00:14:52.000 --> 00:14:56.000
Chọn chương trình Xe tải Thực phẩm ở đây.

00:14:56.000 --> 00:14:57.000
Trình mô phỏng.

00:14:57.000 --> 00:15:01.000
Và chạy nó.

00:15:01.000 --> 00:15:05.000
Và ở đó chúng tôi có nó, ba chiếc bánh rán từ thực đơn tập trung của chúng tôi.

00:15:05.000 --> 00:15:08.000
Chúng ta có thể tham chiếu chéo điều đó với những gì chúng ta thấy từ máy chủ.

00:15:08.000 --> 00:15:09.000
Hãy quay trở lại thiết bị đầu cuối.

00:15:09.000 --> 00:15:26.000
Để so sánh dễ dàng, chúng tôi sẽ sử dụng jq để truy vấn chỉ tên của bánh rán.

00:15:26.000 --> 00:15:32.000
Không gian sâu, Sô cô la 2, Cà phê Caramel - chính xác như những gì chúng tôi mong đợi.

00:15:32.000 --> 00:15:34.000
Điều đó thật tuyệt vời!

00:15:34.000 --> 00:15:36.000
Nhưng chúng ta có thể làm tốt hơn nữa.

00:15:36.000 --> 00:15:41.000
Như hiện tại, các ứng dụng máy chủ và máy khách của chúng tôi đều có các bản sao giống hệt nhau của mã mô hình dữ liệu.

00:15:41.000 --> 00:15:48.000
Chúng ta có thể tránh lặp lại và làm cho việc tuần tự hóa an toàn hơn, bằng cách chia sẻ mô hình trên các ứng dụng iOS và máy chủ.

00:15:48.000 --> 00:15:51.000
Hãy xem lại cách thiết lập điều này ở mức cao.

00:15:51.000 --> 00:15:58.000
Đầu tiên, chúng tôi tạo một gói khác cho thư viện có tên "Chia sẻ" và thêm nó vào không gian làm việc Xcode.

00:15:58.000 --> 00:16:10.000
Sau đó, chúng ta có thể di chuyển mã mô hình dữ liệu sang gói Chia sẻ, thêm Chia sẻ dưới dạng phụ thuộc của ứng dụng máy chủ và dưới dạng phụ thuộc của ứng dụng iOS, sử dụng cài đặt Khung mục tiêu và Thư viện.

00:16:10.000 --> 00:16:22.000
Tại thời điểm đó, chúng tôi có thể tái cấu trúc mã máy khách của mình để sử dụng mô hình được chia sẻ và làm tương tự với mã máy chủ.

00:16:22.000 --> 00:16:24.000
Bây giờ mọi thứ trông đẹp hơn nhiều.

00:16:24.000 --> 00:16:29.000
Trước khi chúng tôi kết thúc, đây là một số ý tưởng về nơi chúng tôi có thể nhận đơn đăng ký tiếp theo.

00:16:29.000 --> 00:16:37.000
Để tận dụng tối đa thực tế là chúng tôi có một máy chủ tập trung, chúng tôi có thể muốn và xác định các API để thêm, chỉnh sửa hoặc xóa bánh rán khỏi menu.

00:16:37.000 --> 00:16:42.000
Điều này sẽ yêu cầu chúng tôi chuyển bộ nhớ của mình từ tệp tĩnh sang cơ sở dữ liệu.

00:16:42.000 --> 00:16:46.000
Với một cơ sở dữ liệu tại chỗ, chúng tôi cũng có thể thực hiện các API mua và đặt hàng.

00:16:46.000 --> 00:16:50.000
Những API như vậy có thể giúp chúng tôi kiếm tiền từ việc kinh doanh bánh rán của mình.

00:16:50.000 --> 00:16:58.000
Họ cũng cung cấp một tín hiệu, mà chúng ta có thể sử dụng để thực hiện định giá động, như bán hàng và giảm giá cho những chiếc bánh rán ít phổ biến hơn.

00:16:58.000 --> 00:17:00.000
Cơ hội là vô tận.

00:17:00.000 --> 00:17:24.000
Để kết thúc, trong phiên này, chúng tôi đã thấy rằng Swift là một ngôn ngữ có mục đích chung, hữu ích cho cả ứng dụng máy khách và máy chủ, chia sẻ mã giữa máy chủ và ứng dụng khách có thể làm giảm bản mẫu và làm cho việc tuần tự hóa hệ thống của chúng tôi an toàn hơn, URLSession là một công cụ chính để tương tác với

00:17:24.000 --> 23:59:59.000
Cảm ơn bạn rất nhiều vì đã xem, và tận hưởng phần còn lại của hội nghị.

