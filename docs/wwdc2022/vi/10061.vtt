WEBVTT

00:00:00.000 --> 00:00:03.000
♪ Nhạc cụ hip-hip êm dịu ♪

00:00:03.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:10.000
Xin chào mọi người.

00:00:10.000 --> 00:00:14.000
Tôi là Jeff, một kỹ sư trong nhóm SwiftUI.

00:00:14.000 --> 00:00:22.000
Hôm nay, tôi rất vui được nói chuyện với bạn về việc đưa nhiều cửa sổ vào ứng dụng SwiftUI của bạn trên iPadOS và macOS.

00:00:22.000 --> 00:00:32.000
Trong phiên này, chúng tôi sẽ mở đầu với tổng quan về các loại cảnh khác nhau trong vòng đời SwiftUI, bao gồm một vài loại mới mà chúng tôi đang giới thiệu.

00:00:32.000 --> 00:00:39.000
Tiếp theo là chỉ ra cách các loại cảnh này có thể được sáng tác với nhau, bằng cách thêm các cảnh phụ trợ.

00:00:39.000 --> 00:00:45.000
Sau đó, chúng tôi sẽ đề cập đến một số API mới để mở cửa sổ cho một cảnh cụ thể trong ứng dụng của bạn.

00:00:45.000 --> 00:00:51.000
Và chúng tôi sẽ kết thúc mọi thứ bằng một vài cách để tùy chỉnh các cảnh của ứng dụng.

00:00:51.000 --> 00:00:57.000
Hãy bắt đầu với một cái nhìn tổng quan về các loại cảnh hiện có trước khi đào sâu vào một số loại mới.

00:00:57.000 --> 00:01:03.000
Bạn sẽ nhớ lại từ các phiên trước rằng các ứng dụng trong SwiftUI bao gồm các cảnh và chế độ xem.

00:01:03.000 --> 00:01:08.000
Các cảnh thường thể hiện nội dung của chúng bằng một cửa sổ trên màn hình.

00:01:08.000 --> 00:01:12.000
Ví dụ, đây là một ứng dụng tôi đã xây dựng để theo dõi những cuốn sách tôi đang đọc.

00:01:12.000 --> 00:01:17.000
Nó được định nghĩa là một nhóm cửa sổ duy nhất hiển thị danh sách đọc của tôi theo cách phù hợp với nền tảng.

00:01:17.000 --> 00:01:26.000
Trên các nền tảng hỗ trợ nhiều cửa sổ, chẳng hạn như iPadOS và macOS, một cảnh có thể thể hiện chính nó với một số cửa sổ như vậy.

00:01:26.000 --> 00:01:32.000
Các hành vi và đại diện của một cảnh khác nhau dựa trên loại được sử dụng.

00:01:32.000 --> 00:01:39.000
Ví dụ, một cảnh chỉ có thể đại diện cho chính nó với một trường hợp duy nhất, bất kể khả năng của nền tảng.

00:01:39.000 --> 00:01:43.000
Hãy cùng xem danh sách các loại cảnh hiện tại trong SwiftUI.

00:01:43.000 --> 00:01:49.000
WindowGroup cung cấp một cách để xây dựng các ứng dụng dựa trên dữ liệu trên tất cả các nền tảng của Apple.

00:01:49.000 --> 00:01:54.000
DocumentGroup cho phép bạn xây dựng các ứng dụng dựa trên tài liệu trên iOS và macOS.

00:01:54.000 --> 00:02:01.000
Và Cài đặt xác định một giao diện để đại diện cho các giá trị cài đặt trong ứng dụng trên macOS.

00:02:01.000 --> 00:02:05.000
Các loại cảnh này có thể được kết hợp với nhau để mở rộng chức năng ứng dụng của bạn.

00:02:05.000 --> 00:02:08.000
Chúng tôi đang mở rộng danh sách các cảnh với hai bổ sung mới.

00:02:08.000 --> 00:02:24.000
Đầu tiên trong số đó là Window, một cảnh đại diện cho một cửa sổ duy nhất, duy nhất trên tất cả các nền tảng; cũng như một loại cảnh mới cho macOS: MenuBarExtra, hiển thị như một điều khiển liên tục trong thanh menu hệ thống.

00:02:24.000 --> 00:02:33.000
Cũng như các loại cảnh khác, bạn có thể sử dụng Window và MenuBarExtra như một cảnh độc lập hoặc sáng tác với các cảnh khác trong ứng dụng của mình.

00:02:33.000 --> 00:02:41.000
Không giống như WindowGroup, cảnh Window sẽ chỉ thể hiện nội dung của nó trong một phiên bản cửa sổ duy nhất, duy nhất.

00:02:41.000 --> 00:02:54.000
Đặc điểm này có thể hữu ích khi nội dung cảnh của bạn đại diện cho một số trạng thái ứng dụng toàn cầu không nhất thiết phải phù hợp với phong cách trình bày đa cửa sổ của WindowGroups trên macOS và iPadOS.

00:02:54.000 --> 00:03:01.000
Ví dụ, một trò chơi có thể chỉ muốn cho phép một cửa sổ chính duy nhất hiển thị nội dung của nó.

00:03:01.000 --> 00:03:08.000
MenuBarExtra là một loại cảnh chỉ dành cho macOS mới hoạt động hơi khác so với các cảnh khác của chúng tôi.

00:03:08.000 --> 00:03:19.000
Thay vì hiển thị nội dung của nó trong một cửa sổ, nó sẽ đặt nhãn của nó vào thanh menu và hiển thị nội dung của nó trong một menu hoặc cửa sổ được neo vào nhãn.

00:03:19.000 --> 00:03:27.000
Ngoài ra, nó sẽ có thể sử dụng được miễn là ứng dụng liên quan của nó đang chạy, bất kể ứng dụng đó có ở trên hết hay không.

00:03:27.000 --> 00:03:34.000
MenuBarExtra rất tuyệt vời để tạo các ứng dụng tiện ích độc lập cung cấp quyền truy cập dễ dàng vào chức năng của chúng.

00:03:34.000 --> 00:03:41.000
Hoặc nó có thể được sáng tác với các cảnh khác để cung cấp một cách thay thế để truy cập chức năng ứng dụng của bạn.

00:03:41.000 --> 00:03:56.000
Nó cũng hỗ trợ hai kiểu kết xuất: kiểu mặc định, hiển thị nội dung trong menu kéo xuống từ thanh menu, cũng như kiểu trình bày nội dung của nó trong một cửa sổ không mạ crôm được neo vào thanh menu.

00:03:56.000 --> 00:04:07.000
Với việc bổ sung hai loại cảnh mới này, các ứng dụng SwiftUI có thể đại diện cho một bộ chức năng thậm chí còn phong phú hơn trên tất cả các nền tảng của chúng tôi.

00:04:07.000 --> 00:04:13.000
Hãy xem các API mới này có thể được sử dụng kết hợp với các loại cảnh hiện có của chúng ta như thế nào.

00:04:13.000 --> 00:04:17.000
Đây là định nghĩa của ứng dụng BookClub mà tôi đã trình bày trước đó.

00:04:17.000 --> 00:04:19.000
Nó hiện đang bao gồm một nhóm cửa sổ duy nhất.

00:04:19.000 --> 00:04:27.000
Trên macOS, ứng dụng BookClub của tôi có thể hưởng lợi từ một cửa sổ bổ sung để hiển thị hoạt động đọc của chúng tôi theo thời gian.

00:04:27.000 --> 00:04:37.000
Đây là một ví dụ tuyệt vời về cách các ứng dụng macOS có thể sử dụng bất động sản màn hình bổ sung và các sắp xếp cửa sổ linh hoạt có trên nền tảng đó.

00:04:37.000 --> 00:04:41.000
Chúng tôi sẽ thêm một cảnh phụ trợ vào ứng dụng của mình để đại diện cho giao diện này.

00:04:41.000 --> 00:04:48.000
Dữ liệu cửa sổ Hoạt động của chúng tôi có nguồn gốc từ trạng thái ứng dụng tổng thể của chúng tôi, vì vậy cảnh cửa sổ là lựa chọn lý tưởng cho nó.

00:04:48.000 --> 00:04:52.000
Mở nhiều cửa sổ với cùng một trạng thái sẽ không phù hợp với thiết kế của chúng tôi.

00:04:52.000 --> 00:05:00.000
Tiêu đề được cung cấp cho cảnh của chúng tôi sẽ được sử dụng làm nhãn cho một mục menu được thêm vào một phần của menu Window.

00:05:00.000 --> 00:05:05.000
Khi chọn mục này, cửa sổ của cảnh sẽ được mở ra nếu chưa được mở.

00:05:05.000 --> 00:05:08.000
Nếu không, nó sẽ được đưa ra phía trước.

00:05:08.000 --> 00:05:21.000
Bây giờ chúng tôi đã đề cập đến việc thêm một cảnh phụ trợ vào ứng dụng BookClub của mình, tôi muốn thảo luận về một số API trình bày cảnh mới mà chúng tôi đang thêm và cách bạn có thể tích hợp chúng vào ứng dụng của mình để cung cấp trải nghiệm phong phú hơn.

00:05:21.000 --> 00:05:26.000
Ứng dụng BookClub của chúng tôi có một trình đơn ngữ cảnh có thể được gọi cho bất kỳ cuốn sách nào trong ngăn Danh sách Nội dung của chúng tôi.

00:05:26.000 --> 00:05:31.000
Trình đơn ngữ cảnh này sẽ bao gồm một nút để kích hoạt bản trình bày cửa sổ của chúng tôi.

00:05:31.000 --> 00:05:33.000
Chúng tôi sẽ sớm điền thông tin chi tiết.

00:05:33.000 --> 00:05:41.000
SwiftUI cung cấp một số loại có thể gọi mới thông qua môi trường để trình bày các cửa sổ gắn liền với các cảnh mà ứng dụng của bạn xác định.

00:05:41.000 --> 00:05:49.000
Đầu tiên trong số này là hành động openWindow, có thể trình bày các cửa sổ cho WindowGroup hoặc cảnh cửa sổ.

00:05:49.000 --> 00:05:56.000
Mã định danh được chuyển cho hành động phải khớp với mã định danh cho một cảnh được xác định trong ứng dụng của bạn.

00:05:56.000 --> 00:06:03.000
Hành động openWindow cũng có thể có giá trị trình bày, mà cảnh được trình bày sẽ sử dụng để hiển thị nội dung của nó.

00:06:03.000 --> 00:06:10.000
Hình thức hành động này chỉ được WindowGroup hỗ trợ, sử dụng trình khởi tạo mới mà chúng ta sẽ xem xét trong thời gian ngắn.

00:06:10.000 --> 00:06:15.000
Loại giá trị phải khớp với loại được cung cấp cho trình khởi tạo cảnh.

00:06:15.000 --> 00:06:28.000
Ngoài ra còn có hai loại có thể gọi được trong môi trường để trình bày các cửa sổ tài liệu: hành động newDocument, hỗ trợ mở các cửa sổ tài liệu mới cho cả FileDocuments và ReferenceFileDocuments.

00:06:28.000 --> 00:06:34.000
Hành động này yêu cầu DocumentGroup tương ứng trong ứng dụng của bạn được xác định với vai trò biên tập viên.

00:06:34.000 --> 00:06:39.000
Tài liệu được cung cấp cho hành động này sẽ được tạo ra mỗi khi cửa sổ được trình bày.

00:06:39.000 --> 00:06:48.000
Để trình bày các cửa sổ tài liệu nơi nội dung được cung cấp bởi một tệp hiện có trên đĩa, có hành động openDocument.

00:06:48.000 --> 00:06:51.000
Hành động này lấy một URL đến tệp bạn muốn mở.

00:06:51.000 --> 00:07:01.000
Ứng dụng của bạn phải xác định một DocumentGroup để trình bày cửa sổ và loại tài liệu cho nhóm đó phải cho phép đọc loại tệp tại URL được cung cấp.

00:07:01.000 --> 00:07:06.000
Xem lại nút của chúng tôi, chúng tôi sẽ thêm thuộc tính môi trường openWindow vào chế độ xem của chúng tôi.

00:07:06.000 --> 00:07:11.000
Vì loại này có thể gọi được, chúng ta chỉ có thể gọi nó trực tiếp từ hành động của nút của chúng ta.

00:07:11.000 --> 00:07:18.000
Loại Sách của chúng tôi phù hợp với nhận dạng, vì vậy chúng tôi sẽ chuyển mã định danh của nó làm giá trị để trình bày.

00:07:18.000 --> 00:07:23.000
Bây giờ, trước khi chúng ta tiếp tục, tôi muốn thảo luận về các giá trị được chuyển cho hành động openWindow.

00:07:23.000 --> 00:07:30.000
Tôi lưu ý rằng tôi đang chuyển mã định danh của cuốn sách, đây là giá trị của loại UUID.

00:07:30.000 --> 00:07:37.000
Nói chung, bạn sẽ muốn sử dụng mã định danh mô hình của mình như thế này hơn là chính giá trị đó.

00:07:37.000 --> 00:07:39.000
Lưu ý rằng loại Sách của chúng tôi là một loại giá trị.

00:07:39.000 --> 00:07:47.000
Như vậy, nếu chúng tôi sử dụng nó làm giá trị được trình bày, cửa sổ mới của chúng tôi sẽ nhận được một bản sao của cửa sổ bắt nguồn từ bản trình bày.

00:07:47.000 --> 00:07:50.000
Bất kỳ chỉnh sửa nào cho một trong hai sẽ không ảnh hưởng đến cái kia.

00:07:50.000 --> 00:07:59.000
Thay vào đó, việc sử dụng mã định danh của cuốn sách cho phép cửa hàng mô hình của chúng tôi trở thành nguồn gốc của sự thật cho các giá trị này bằng cách cung cấp nhiều ràng buộc cho một giá trị duy nhất.

00:07:59.000 --> 00:08:03.000
Để biết thêm thông tin về ngữ nghĩa loại giá trị, vui lòng xem tài liệu dành cho nhà phát triển.

00:08:03.000 --> 00:08:10.000
Loại được trình bày cũng phải phù hợp với cả giao thức Hashable và Codable.

00:08:10.000 --> 00:08:21.000
Sự phù hợp có thể băm là cần thiết để liên kết giá trị được trình bày với một cửa sổ đang mở; trong khi sự phù hợp có thể mã hóa là bắt buộc để duy trì giá trị được trình bày để khôi phục trạng thái.

00:08:21.000 --> 00:08:24.000
Tôi sẽ sớm thảo luận chi tiết hơn về cả hai hành vi này.

00:08:24.000 --> 00:08:29.000
Cuối cùng, khi có thể, thích vượt qua các giá trị nhẹ hơn.

00:08:29.000 --> 00:08:32.000
Mã định danh cuốn sách của chúng tôi là một ví dụ tuyệt vời khác về điều này.

00:08:32.000 --> 00:08:41.000
Vì giá trị sẽ được SwiftUI duy trì để khôi phục trạng thái, việc sử dụng các giá trị nhỏ hơn sẽ dẫn đến khả năng phản hồi tốt hơn cho ứng dụng của bạn.

00:08:41.000 --> 00:08:48.000
Bây giờ, nút của chúng tôi bây giờ có các phần cần thiết để trình bày các cửa sổ chi tiết của chúng tôi, nhưng sẽ không có gì hiển thị khi nó được chọn.

00:08:48.000 --> 00:08:56.000
Điều này là do chúng tôi đã yêu cầu SwiftUI trình bày một cửa sổ cho một loại dữ liệu nhất định, nhưng chưa xác định một cảnh nào trong ứng dụng của chúng tôi phản ánh điều đó.

00:08:56.000 --> 00:08:58.000
Hãy quay lại ứng dụng của chúng tôi và thực hiện thay đổi đó ngay bây giờ.

00:08:58.000 --> 00:09:05.000
Cùng với WindowGroup chính và cửa sổ phụ trợ của chúng tôi, chúng tôi sẽ thêm một WindowGroup bổ sung để xử lý chi tiết sách của chúng tôi.

00:09:05.000 --> 00:09:09.000
Chi tiết cuốn sách của chúng tôi WindowGroup sử dụng trình khởi tạo mới.

00:09:09.000 --> 00:09:16.000
Ngoài tiêu đề, chúng tôi lưu ý rằng nhóm này trình bày dữ liệu cho loại Book.ID - trong trường hợp của chúng tôi, UUIDs.

00:09:16.000 --> 00:09:22.000
Loại này phải khớp với giá trị mà chúng tôi đang chuyển cho hành động openWindow mà chúng tôi đã thêm trước đó.

00:09:22.000 --> 00:09:36.000
Khi một giá trị nhất định được cung cấp cho WindowGroup để trình bày, SwiftUI sẽ tạo một cảnh con mới cho giá trị đó và nội dung gốc của cửa sổ cảnh đó sẽ được xác định bởi giá trị đó, sử dụng trình tạo chế độ xem của nhóm.

00:09:36.000 --> 00:09:40.000
Mỗi giá trị được trình bày độc đáo sẽ tạo ra một khung cảnh mới.

00:09:40.000 --> 00:09:48.000
Sự bình đẳng của giá trị sẽ được sử dụng để xác định xem một cửa sổ mới nên được tạo hay liệu một cửa sổ hiện có có có thể được sử dụng lại hay không.

00:09:48.000 --> 00:09:56.000
Khi openWindow trình bày một giá trị mà một cửa sổ đã tồn tại, nhóm sẽ sử dụng cửa sổ đó thay vì tạo một cửa sổ mới.

00:09:56.000 --> 00:10:09.000
Sử dụng ứng dụng BookClub của chúng tôi làm ví dụ, việc chọn hành động menu ngữ cảnh cho một cuốn sách đã được trình bày trong cửa sổ sẽ dẫn đến việc cửa sổ đó được sắp xếp phía trước, thay vì cửa sổ thứ hai hiển thị cùng một cuốn sách.

00:10:09.000 --> 00:10:16.000
Giá trị được trình bày cũng sẽ được SwiftUI tự động duy trì cho mục đích khôi phục trạng thái.

00:10:16.000 --> 00:10:20.000
Quan điểm của bạn sẽ được ràng buộc với giá trị được trình bày ban đầu.

00:10:20.000 --> 00:10:24.000
Ràng buộc này có thể được sửa đổi bất cứ lúc nào trong khi cửa sổ đang mở.

00:10:24.000 --> 00:10:31.000
Khi cảnh được tạo lại để khôi phục trạng thái, SwiftUI sẽ chuyển giá trị gần đây nhất cho chế độ xem Nội dung của cửa sổ.

00:10:31.000 --> 00:10:40.000
Ở đây, chúng tôi đang cung cấp ràng buộc Book.ID cho chế độ xem chi tiết của chúng tôi, có thể tra cứu mặt hàng được chỉ định trong cửa hàng mô hình của chúng tôi để hiển thị.

00:10:40.000 --> 00:10:48.000
Với tất cả các phần của chúng tôi tại chỗ, bây giờ chúng tôi có thể chọn mục menu ngữ cảnh của mình và xem chi tiết sách của chúng tôi trong cửa sổ riêng của nó.

00:10:48.000 --> 00:10:54.000
Cuối cùng, tôi muốn xem qua một số cách mà bạn có thể tùy chỉnh các cảnh trong ứng dụng của mình.

00:10:54.000 --> 00:11:06.000
Bởi vì chúng tôi đã xác định ứng dụng của mình với hai cảnh WindowGroup - một cho cửa sổ người xem chính và một cho cửa sổ chi tiết của chúng tôi - SwiftUI theo mặc định sẽ thêm một mục menu cho mỗi nhóm trong menu Tệp.

00:11:06.000 --> 00:11:10.000
Tuy nhiên, mục menu cho cửa sổ chi tiết của chúng tôi không hoàn toàn phù hợp với trường hợp sử dụng của chúng tôi.

00:11:10.000 --> 00:11:16.000
Tôi muốn các cửa sổ chỉ có thể được mở thông qua menu ngữ cảnh đã được thêm vào trước đó.

00:11:16.000 --> 00:11:26.000
Một công cụ sửa đổi cảnh mới, commandsRemoved, cho phép bạn sửa đổi một cảnh sao cho nó sẽ không còn cung cấp các lệnh mặc định nữa, giống như lệnh trong menu Tệp.

00:11:26.000 --> 00:11:34.000
Sau khi áp dụng công cụ sửa đổi này, menu Tệp của chúng tôi hiện chỉ chứa một mục để mở cửa sổ cho WindowGroup chính.

00:11:34.000 --> 00:11:43.000
Tôi không hoàn toàn hài lòng với bài thuyết trình hiện tại về cảnh cửa sổ phụ trợ để hiển thị hoạt động đọc của mình, vì vậy hãy tập trung vào điều đó tiếp theo.

00:11:43.000 --> 00:11:50.000
Vì tôi sẽ áp dụng một vài công cụ sửa đổi cho nó, tôi sẽ trích xuất nó thành một cảnh tùy chỉnh, điều này sẽ giữ cho định nghĩa ứng dụng của tôi sạch hơn.

00:11:50.000 --> 00:11:57.000
Không có bất kỳ trạng thái nào trước đó cho một cửa sổ, SwiftUI theo mặc định sẽ đặt nó ở giữa màn hình.

00:11:57.000 --> 00:12:03.000
Tuy nhiên, tôi thích nó hơn nếu Hoạt động Đọc được đặt ở một vị trí khác theo mặc định.

00:12:03.000 --> 00:12:11.000
Bằng cách thêm công cụ sửa đổi Vị trí mặc định mới, tôi có thể chỉ định một vị trí sẽ được sử dụng khi không có trạng thái nào trước đó khả dụng.

00:12:11.000 --> 00:12:19.000
Vị trí này liên quan đến kích thước màn hình và sẽ đặt cửa sổ ở vị trí thích hợp có tính đến ngôn ngữ hiện tại.

00:12:19.000 --> 00:12:25.000
Vị trí mới này giúp phân biệt cửa sổ Hoạt động của tôi với các cửa sổ xem khác trên màn hình.

00:12:25.000 --> 00:12:31.000
Tôi cũng muốn cửa sổ Hoạt động của mình hiển thị ở một kích thước nhất định theo mặc định, nhưng vẫn có thể thay đổi kích thước.

00:12:31.000 --> 00:12:36.000
Cùng với Vị trí mặc định, tôi sẽ thêm công cụ sửa đổi Kích thước mặc định.

00:12:36.000 --> 00:12:43.000
Giá trị được cung cấp cho nó sẽ được trao cho hệ thống bố cục để lấy được kích thước ban đầu cho cửa sổ.

00:12:43.000 --> 00:12:49.000
Bây giờ tôi đã tùy chỉnh bản trình bày cửa sổ của mình, hãy thêm một công cụ sửa đổi nữa để tùy chỉnh hành vi của nó.

00:12:49.000 --> 00:12:54.000
Công cụ sửa đổi keyboardShortcut cũng đã được mở rộng để hoạt động trên các loại cảnh.

00:12:54.000 --> 00:12:59.000
Khi được sử dụng ở cấp độ cảnh, công cụ sửa đổi này ảnh hưởng đến lệnh tạo ra một cửa sổ mới.

00:12:59.000 --> 00:13:06.000
Ở đây, tôi đã sửa đổi cửa sổ Hoạt động của mình để nó có thể được mở bằng phím tắt Option-Command-0.

00:13:06.000 --> 00:13:21.000
Đây có thể là một cách tuyệt vời để tùy chỉnh ứng dụng của bạn bằng cách cung cấp các phím tắt cho các cảnh thường được sử dụng và cũng có thể được sử dụng để tùy chỉnh phím tắt mặc định của Command-N, được thêm vào WindowGroup chính trong ứng dụng của bạn.

00:13:21.000 --> 00:13:25.000
Điều này kết thúc chuyến tham quan của chúng tôi về cảnh mới và chức năng cửa sổ trong SwiftUI.

00:13:25.000 --> 00:13:29.000
Chúng tôi thực sự vui mừng về tiềm năng của những API mới này và hy vọng bạn cũng vậy!

00:13:29.000 --> 00:13:44.000
Để biết thêm thông tin tuyệt vời về cách thêm chức năng vào ứng dụng iPadOS và macOS của bạn, vui lòng xem các phiên khác sau: "SwiftUI trên iPad: Sắp xếp giao diện của bạn" và "SwiftUI trên iPad: Thêm thanh công cụ, tiêu đề và hơn thế nữa."

00:13:44.000 --> 00:13:46.000
Cảm ơn vì đã xem.

00:13:46.000 --> 23:59:59.000
♪

