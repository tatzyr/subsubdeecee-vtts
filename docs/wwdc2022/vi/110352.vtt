WEBVTT

00:00:00.000 --> 00:00:03.000
♪ Nhạc hip-hop nhạc cụ êm dịu ♪

00:00:03.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:13.000
Xin chào mọi người, tôi là Holly từ nhóm Swift Compiler.

00:00:13.000 --> 00:00:17.000
Chào mừng đến với "Embrace Swift generics."

00:00:17.000 --> 00:00:26.000
Generics là một công cụ cơ bản để viết mã trừu tượng trong Swift, điều này rất quan trọng để quản lý sự phức tạp khi mã của bạn phát triển.

00:00:26.000 --> 00:00:31.000
Trừu tượng tách biệt các ý tưởng khỏi các chi tiết cụ thể.

00:00:31.000 --> 00:00:36.000
Trong mã, có rất nhiều cách khác nhau để trừu tượng hóa hữu ích.

00:00:36.000 --> 00:00:45.000
Một hình thức trừu tượng mà bạn có thể sử dụng mọi lúc là bao thanh toán mã thành một hàm hoặc một biến cục bộ.

00:00:45.000 --> 00:00:51.000
Điều này có thể thực sự hữu ích nếu bạn cần sử dụng cùng một chức năng hoặc giá trị nhiều lần.

00:00:51.000 --> 00:01:04.000
Khi bạn trích xuất chức năng vào một hàm, các chi tiết sẽ bị trừu tượng hóa và mã sử dụng trừu tượng có thể thể hiện ý tưởng về những gì đang xảy ra mà không cần lặp lại các chi tiết.

00:01:04.000 --> 00:01:09.000
Trong Swift, bạn cũng có thể trừu tượng hóa các loại cụ thể.

00:01:09.000 --> 00:01:18.000
Nếu bạn có một tập hợp các loại có cùng ý tưởng với các chi tiết khác nhau, bạn có thể viết mã trừu tượng để làm việc với tất cả các loại cụ thể đó.

00:01:18.000 --> 00:01:38.000
Hôm nay, chúng ta sẽ xem qua quy trình làm việc của việc mô hình hóa mã với các loại cụ thể, xác định các khả năng phổ biến của một tập hợp các loại cụ thể, xây dựng giao diện để thể hiện các khả năng đó và cuối cùng, chúng ta sẽ đi sâu vào việc viết mã chung bằng giao diện đó.

00:01:38.000 --> 00:01:44.000
Chúng ta sẽ đào sâu vào các công cụ trừu tượng của Swift trong khi xây dựng một số mã để mô phỏng một trang trại.

00:01:44.000 --> 00:01:48.000
Vì vậy, hãy bắt đầu bằng cách viết một số loại cụ thể.

00:01:48.000 --> 00:01:50.000
Chúng ta sẽ bắt đầu với một cấu trúc được gọi là "Cow".

00:01:50.000 --> 00:01:56.000
Bò có một phương pháp gọi là "ăn", chấp nhận một tham số thuộc loại Hay.

00:01:56.000 --> 00:01:58.000
Hay là một cấu trúc khác.

00:01:58.000 --> 00:02:05.000
Nó có một phương pháp tĩnh gọi là "phát triển" để trồng cây trồng tạo ra Cỏ khô, đó là Cỏ linh lăng.

00:02:05.000 --> 00:02:10.000
Cấu trúc Alfalfa có một phương pháp để thu hoạch Hay từ một ví dụ của Alfalfa.

00:02:10.000 --> 00:02:16.000
Cuối cùng, chúng ta sẽ thêm một cấu trúc gọi là "Trang trại" có phương pháp cho bò ăn.

00:02:16.000 --> 00:02:26.000
Phương pháp cho ăn có thể được thực hiện bằng cách đầu tiên trồng một ít cỏ linh lăng để sản xuất cỏ khô, sau đó thu hoạch cỏ khô và cuối cùng là cho bò ăn cỏ khô.

00:02:26.000 --> 00:02:30.000
Và bây giờ, tôi có thể cho bò ăn trong trang trại của mình.

00:02:30.000 --> 00:02:34.000
Nhưng tôi muốn thêm nhiều loại động vật hơn.

00:02:34.000 --> 00:02:39.000
Tôi có thể thêm nhiều cấu trúc hơn để đại diện cho các loài động vật khác, như Ngựa và Gà.

00:02:39.000 --> 00:02:46.000
Và tôi muốn có thể cho bò, ngựa và gà ăn trong trang trại.

00:02:46.000 --> 00:02:56.000
Tôi có thể quá tải phương thức nguồn cấp dữ liệu để chấp nhận từng loại tham số riêng biệt, nhưng mỗi quá tải sẽ có một cách triển khai thực sự giống nhau.

00:02:56.000 --> 00:03:04.000
Điều này sẽ trở thành bản mẫu bổ sung khi tôi thêm nhiều loại động vật hơn và dù sao thì nó cũng chủ yếu là mã lặp lại.

00:03:04.000 --> 00:03:11.000
Nếu bạn thấy mình viết quá tải với việc triển khai lặp đi lặp lại, đó có thể là một dấu hiệu để khái quát hóa.

00:03:11.000 --> 00:03:20.000
Về cơ bản, những triển khai này rất giống nhau vì các loại động vật khác nhau có chức năng tương tự nhau.

00:03:20.000 --> 00:03:25.000
Bước tiếp theo là xác định các khả năng chung giữa các loại động vật.

00:03:25.000 --> 00:03:31.000
Chúng tôi đã xây dựng một tập hợp các loại động vật mà tất cả đều có khả năng ăn một số loại thức ăn.

00:03:31.000 --> 00:03:40.000
Mỗi loại động vật sẽ có một cách ăn khác nhau, vì vậy mỗi lần thực hiện phương pháp ăn sẽ có sự khác biệt trong hành vi.

00:03:40.000 --> 00:03:51.000
Những gì chúng tôi muốn làm là cho phép mã trừu tượng gọi phương thức eat và để mã trừu tượng đó hoạt động khác nhau tùy thuộc vào loại cụ thể mà nó đang hoạt động.

00:03:51.000 --> 00:03:58.000
Khả năng của mã trừu tượng hoạt động khác nhau đối với các loại cụ thể khác nhau được gọi là "đa hình".

00:03:58.000 --> 00:04:07.000
Tính đa hình cho phép một đoạn mã có nhiều hành vi tùy thuộc vào cách mã được sử dụng.

00:04:07.000 --> 00:04:12.000
Một cách thích hợp, bản thân đa hình có nhiều dạng khác nhau.

00:04:12.000 --> 00:04:20.000
Đầu tiên là quá tải hàm, trong đó cùng một lệnh gọi hàm có thể có nghĩa là những thứ khác nhau tùy thuộc vào loại đối số.

00:04:20.000 --> 00:04:26.000
Quá tải được gọi là "đa hình đặc biệt" bởi vì nó không thực sự là một giải pháp chung.

00:04:26.000 --> 00:04:30.000
Chúng tôi vừa thấy tình trạng quá tải có thể dẫn đến mã lặp đi lặp lại như thế nào.

00:04:30.000 --> 00:04:41.000
Tiếp theo là đa hình kiểu con, trong đó mã hoạt động trên một siêu kiểu có thể có hành vi khác nhau dựa trên kiểu con cụ thể mà mã đang sử dụng trong thời gian chạy.

00:04:41.000 --> 00:04:47.000
Cuối cùng, chúng ta có đa hình tham số, đạt được bằng cách sử dụng generics.

00:04:47.000 --> 00:04:58.000
Mã chung sử dụng các tham số kiểu để cho phép viết một đoạn mã hoạt động với các loại khác nhau và bản thân các loại cụ thể được sử dụng làm đối số.

00:04:58.000 --> 00:05:04.000
Chúng tôi đã loại trừ tình trạng quá tải, vì vậy hãy thử sử dụng đa hình kiểu con.

00:05:04.000 --> 00:05:10.000
Một cách để thể hiện các mối quan hệ kiểu con là với hệ thống phân cấp lớp.

00:05:10.000 --> 00:05:14.000
Chúng ta có thể giới thiệu một lớp học gọi là "Động vật".

00:05:14.000 --> 00:05:19.000
Tiếp theo, chúng tôi sẽ thay đổi từng loại động vật từ một cấu trúc thành một lớp.

00:05:19.000 --> 00:05:27.000
Mỗi lớp động vật cụ thể sẽ kế thừa từ siêu lớp Động vật và ghi đè lên phương thức ăn.

00:05:27.000 --> 00:05:35.000
Bây giờ, chúng ta có một Động vật lớp cơ sở trừu tượng có thể đại diện cho tất cả các loại động vật cụ thể của chúng ta.

00:05:35.000 --> 00:05:43.000
Mã gọi eat trên lớp Animal sẽ sử dụng đa hình kiểu con để gọi việc triển khai lớp con.

00:05:43.000 --> 00:05:44.000
Nhưng chúng ta vẫn chưa xong.

00:05:44.000 --> 00:05:52.000
Chúng tôi vẫn chưa điền vào loại tham số cho phương thức ăn trên Animal và có một vài dấu hiệu đỏ khác trong mã này.

00:05:52.000 --> 00:06:04.000
Đầu tiên, việc sử dụng các lớp buộc chúng tôi phải sử dụng ngữ nghĩa tham chiếu, mặc dù chúng tôi không cần hoặc không muốn bất kỳ trạng thái nào được chia sẻ giữa các trường hợp động vật khác nhau.

00:06:04.000 --> 00:06:13.000
Chiến lược này cũng yêu cầu các lớp con ghi đè các phương thức trong lớp cơ sở, nhưng quên làm điều này sẽ không bị bắt cho đến khi thời gian chạy.

00:06:13.000 --> 00:06:26.000
Nhưng vấn đề lớn hơn với mô hình trừu tượng hóa này là mỗi phân nhóm động vật ăn một loại thức ăn khác nhau và sự phụ thuộc này thực sự khó thể hiện với hệ thống phân cấp lớp.

00:06:26.000 --> 00:06:33.000
Một cách tiếp cận mà chúng tôi có thể thực hiện là để phương pháp chấp nhận một loại ít cụ thể hơn, chẳng hạn như Any.

00:06:33.000 --> 00:06:40.000
Nhưng chiến lược này dựa trên việc triển khai lớp con để đảm bảo loại chính xác đã được thông qua trong thời gian chạy.

00:06:40.000 --> 00:06:53.000
Vì vậy, chúng tôi đã áp dụng thêm nồi hơi trong mỗi phương pháp bị ghi đè, nhưng quan trọng hơn, nó cho phép bạn vô tình vượt qua sai loại thực phẩm, khiến bạn gặp một lỗi khác chỉ có thể bị bắt trong thời gian chạy.

00:06:53.000 --> 00:06:56.000
Vì vậy, hãy thử một cái gì đó khác.

00:06:56.000 --> 00:07:06.000
Thay vào đó, chúng tôi có thể thể hiện loại thức ăn của động vật theo cách an toàn bằng cách giới thiệu một tham số loại trên siêu lớp Động vật.

00:07:06.000 --> 00:07:13.000
Tham số loại này đóng vai trò là trình giữ chỗ cho loại nguồn cấp dữ liệu cụ thể cho từng lớp con.

00:07:13.000 --> 00:07:20.000
Với cách tiếp cận này, tham số loại Thực phẩm phải được nâng lên thành tuyên bố của lớp Động vật.

00:07:20.000 --> 00:07:33.000
Điều này có vẻ hơi không tự nhiên bởi vì mặc dù động vật cần thức ăn để hoạt động, ăn thức ăn không phải là mục đích cốt lõi của động vật và rất nhiều mã hoạt động với động vật có thể sẽ không quan tâm đến thức ăn chút nào.

00:07:33.000 --> 00:07:39.000
Mặc dù vậy, tất cả các tham chiếu đến lớp Động vật cần chỉ định loại thức ăn.

00:07:39.000 --> 00:07:48.000
Ví dụ, mỗi lớp con Động vật cần xác định rõ ràng loại thức ăn của nó trong dấu ngoặc nhọn trong mệnh đề kế thừa.

00:07:48.000 --> 00:07:58.000
Tấm nồi hơi này tại mỗi địa điểm sử dụng của lớp Động vật có thể trở nên nặng nề nếu chúng tôi thêm nhiều loại cụ thể cho từng loài động vật.

00:07:58.000 --> 00:08:04.000
Vì vậy, không có cách tiếp cận nào của chúng tôi ở đây có công thái học tốt hoặc ngữ nghĩa phù hợp.

00:08:04.000 --> 00:08:15.000
Vấn đề cơ bản là một lớp là một kiểu dữ liệu và chúng tôi đang cố gắng phức tạp một siêu lớp để làm cho nó đại diện cho những ý tưởng trừu tượng về các kiểu cụ thể.

00:08:15.000 --> 00:08:26.000
Thay vào đó, chúng tôi muốn một cấu trúc ngôn ngữ được thiết kế để thể hiện khả năng của các loại mà không có chi tiết về cách thức hoạt động của khả năng.

00:08:26.000 --> 00:08:29.000
Động vật có hai khả năng chung.

00:08:29.000 --> 00:08:36.000
Mỗi con vật có một loại thức ăn cụ thể, cùng với một hoạt động tiêu thụ một số thức ăn đó.

00:08:36.000 --> 00:08:41.000
Chúng ta có thể xây dựng một giao diện đại diện cho những khả năng đó.

00:08:41.000 --> 00:08:44.000
Trong Swift, điều này được thực hiện bằng cách sử dụng một giao thức.

00:08:44.000 --> 00:08:52.000
Giao thức là một công cụ trừu tượng mô tả chức năng của các loại phù hợp.

00:08:52.000 --> 00:08:59.000
Sử dụng một giao thức, bạn có thể tách các ý tưởng về những gì một loại thực hiện khỏi các chi tiết triển khai.

00:08:59.000 --> 00:09:04.000
Những ý tưởng về những gì một loại làm được thể hiện thông qua một giao diện.

00:09:04.000 --> 00:09:10.000
Hãy dịch các khả năng của một con vật sang giao diện giao thức.

00:09:10.000 --> 00:09:17.000
Tên của giao thức đại diện cho danh mục các loại mà chúng tôi đang mô tả, vì vậy tôi đã gọi giao thức này là "Động vật".

00:09:17.000 --> 00:09:21.000
Mỗi khả năng sẽ ánh xạ đến một yêu cầu giao thức.

00:09:21.000 --> 00:09:28.000
Loại thực phẩm cụ thể sẽ ánh xạ đến một loại liên quan của giao thức Động vật.

00:09:28.000 --> 00:09:34.000
Cũng giống như một tham số loại, một loại liên quan đóng vai trò là trình giữ chỗ cho một loại cụ thể.

00:09:34.000 --> 00:09:40.000
Điều làm cho các loại liên quan trở nên đặc biệt là chúng phụ thuộc vào loại cụ thể phù hợp với giao thức.

00:09:40.000 --> 00:09:49.000
Mối quan hệ này được đảm bảo, vì vậy mỗi trường hợp của một loại động vật cụ thể luôn có cùng một loại thức ăn.

00:09:49.000 --> 00:09:55.000
Tiếp theo, hoạt động tiêu thụ thực phẩm sẽ ánh xạ đến một phương pháp.

00:09:55.000 --> 00:10:00.000
Phương pháp này được gọi là "ăn" và nó chấp nhận một tham số về loại thức ăn của động vật.

00:10:00.000 --> 00:10:08.000
Giao thức không có triển khai phương pháp này và các loại động vật cụ thể được yêu cầu để thực hiện nó.

00:10:08.000 --> 00:10:14.000
Bây giờ chúng ta đã có giao thức Động vật, chúng ta có thể làm cho từng loại động vật cụ thể phù hợp với nó.

00:10:14.000 --> 00:10:22.000
Bạn có thể chú thích một loại cụ thể với sự phù hợp giao thức tại khai báo hoặc trong phần mở rộng.

00:10:22.000 --> 00:10:29.000
Các giao thức không giới hạn ở các lớp, vì vậy chúng ta cũng có thể sử dụng các giao thức có cấu trúc, enums và tác nhân.

00:10:29.000 --> 00:10:38.000
Khi bạn viết chú thích sự phù hợp này, trình biên dịch sẽ kiểm tra xem loại cụ thể có thực hiện từng yêu cầu giao thức hay không.

00:10:38.000 --> 00:10:48.000
Mỗi loại động vật phải thực hiện phương pháp ăn và trình biên dịch có thể suy ra loại nguồn cấp dữ liệu là gì, bởi vì nó được sử dụng trong danh sách tham số.

00:10:48.000 --> 00:10:54.000
Loại nguồn cấp dữ liệu cũng có thể được viết rõ ràng bằng cách sử dụng bí danh loại.

00:10:54.000 --> 00:11:02.000
Chúng tôi đã xác định thành công các khả năng chung của động vật và thể hiện những khả năng đó, sử dụng giao diện giao thức.

00:11:02.000 --> 00:11:06.000
Bây giờ, chúng ta có thể bắt đầu viết mã chung.

00:11:06.000 --> 00:11:10.000
Chúng ta có thể sử dụng giao thức Động vật để thực hiện phương pháp thức ăn trong Trang trại.

00:11:10.000 --> 00:11:15.000
Chúng tôi muốn viết một triển khai phù hợp với tất cả các loại động vật cụ thể.

00:11:15.000 --> 00:11:25.000
Chúng tôi sẽ sử dụng đa hình tham số và giới thiệu một tham số kiểu sẽ được thay thế bằng một kiểu cụ thể khi phương thức được gọi.

00:11:25.000 --> 00:11:30.000
Một tham số kiểu được viết sau tên hàm trong dấu ngoặc nhọn.

00:11:30.000 --> 00:11:37.000
Cũng giống như các biến thông thường và tham số hàm, bạn có thể đặt tên cho một tham số kiểu bất cứ thứ gì bạn thích.

00:11:37.000 --> 00:11:44.000
Và cũng giống như bất kỳ loại nào khác, bạn có thể tham chiếu tham số loại trong suốt chữ ký hàm, sử dụng tên của nó.

00:11:44.000 --> 00:11:51.000
Ở đây, tôi đã khai báo một tham số kiểu gọi là "A", và tôi đã sử dụng A làm loại tham số hàm động vật.

00:11:51.000 --> 00:12:00.000
Chúng tôi luôn muốn loại động vật cụ thể phù hợp với giao thức Động vật, vì vậy chúng tôi chú thích tham số loại với sự phù hợp của giao thức.

00:12:00.000 --> 00:12:13.000
Sự phù hợp của giao thức có thể được viết trong dấu ngoặc nhọn hoặc chúng có thể được viết trong mệnh đề "ở đâu", nơi bạn cũng có thể chỉ định mối quan hệ giữa các tham số loại khác nhau.

00:12:13.000 --> 00:12:22.000
Các tham số kiểu được đặt tên và các mệnh đề "ở đâu" thực sự mạnh mẽ, bởi vì chúng cho phép bạn viết các yêu cầu phức tạp và các mối quan hệ kiểu.

00:12:22.000 --> 00:12:26.000
Nhưng hầu hết các chức năng chung chung không cần tính tổng quát này.

00:12:26.000 --> 00:12:29.000
Hãy tập trung vào phương pháp nguồn cấp dữ liệu.

00:12:29.000 --> 00:12:39.000
Tham số loại A xuất hiện một lần trong danh sách tham số và mệnh đề "ở đâu" liệt kê yêu cầu tuân thủ trên tham số loại.

00:12:39.000 --> 00:12:46.000
Trong trường hợp này, việc đặt tên cho tham số kiểu và sử dụng mệnh đề "ở đâu" làm cho phương thức trông phức tạp hơn thực tế.

00:12:46.000 --> 00:12:52.000
Mô hình chung này thực sự phổ biến, vì vậy có một cách đơn giản hơn để diễn đạt nó.

00:12:52.000 --> 00:13:03.000
Thay vì viết một tham số kiểu một cách rõ ràng, chúng ta có thể diễn đạt kiểu trừu tượng này theo sự phù hợp của giao thức bằng cách viết "một số Động vật".

00:13:03.000 --> 00:13:14.000
Tuyên bố này giống hệt với tuyên bố trước đó, nhưng danh sách tham số loại không cần thiết và mệnh đề "ở đâu" đã biến mất, bởi vì chúng tôi không cần tính biểu cảm mà chúng cung cấp.

00:13:14.000 --> 00:13:27.000
Viết "some Animal" đơn giản hơn, bởi vì nó làm giảm tiếng ồn cú pháp và nó bao gồm thông tin ngữ nghĩa về tham số động vật ngay trong khai báo tham số.

00:13:27.000 --> 00:13:30.000
Hãy chia nhỏ cú pháp Động vật.

00:13:30.000 --> 00:13:37.000
"Một số" trong "một số Động vật" chỉ ra rằng có một loại cụ thể mà bạn đang làm việc cùng.

00:13:37.000 --> 00:13:42.000
Từ khóa "some" luôn được theo sau bởi một yêu cầu phù hợp.

00:13:42.000 --> 00:13:52.000
Trong trường hợp này, loại cụ thể phải phù hợp với giao thức Động vật, điều này sẽ cho phép chúng tôi sử dụng các yêu cầu từ giao thức Động vật trên giá trị tham số.

00:13:52.000 --> 00:13:56.000
Từ khóa "some" có thể được sử dụng trong các loại tham số và kết quả.

00:13:56.000 --> 00:14:05.000
Nếu bạn đã viết mã SwiftUI trước đây, bạn đã sử dụng "một số" ở vị trí kết quả bằng cách sử dụng "một số Chế độ xem".

00:14:05.000 --> 00:14:10.000
Một loại kết quả của "một số Chế độ xem" hoàn toàn giống với khái niệm.

00:14:10.000 --> 00:14:21.000
Trong chế độ xem SwiftUI, thuộc tính nội dung trả về một số loại chế độ xem cụ thể, nhưng mã sử dụng thuộc tính nội dung không cần biết loại cụ thể là gì.

00:14:21.000 --> 00:14:28.000
Hãy lùi lại một bước để hiểu rõ hơn về khái niệm về một loại trừu tượng cụ thể.

00:14:28.000 --> 00:14:36.000
Một loại trừu tượng đại diện cho trình giữ chỗ cho một loại cụ thể cụ thể được gọi là loại mờ đục.

00:14:36.000 --> 00:14:42.000
Loại bê tông cụ thể được thay thế được gọi là loại cơ bản.

00:14:42.000 --> 00:14:48.000
Đối với các giá trị có kiểu mờ đục, loại cơ bản được cố định cho phạm vi của giá trị.

00:14:48.000 --> 00:14:57.000
Bằng cách này, mã chung sử dụng giá trị được đảm bảo nhận được cùng một loại cơ bản mỗi khi giá trị được truy cập.

00:14:57.000 --> 00:15:05.000
Một loại sử dụng từ khóa "some" và tham số loại được đặt tên trong dấu ngoặc nhọn đều khai báo một kiểu không rõ ràng.

00:15:05.000 --> 00:15:15.000
Các loại mờ đục có thể được sử dụng cho cả đầu vào và đầu ra, vì vậy chúng có thể được khai báo ở vị trí tham số hoặc ở vị trí kết quả.

00:15:15.000 --> 00:15:19.000
Mũi tên hàm là đường phân chia giữa các vị trí này.

00:15:19.000 --> 00:15:30.000
Vị trí của một loại mờ đục xác định phần nào của chương trình nhìn thấy loại trừu tượng và phần nào của chương trình xác định loại cụ thể.

00:15:30.000 --> 00:15:41.000
Các tham số loại được đặt tên luôn được khai báo ở phía đầu vào, vì vậy người gọi quyết định loại cơ bản và việc triển khai sử dụng loại trừu tượng.

00:15:41.000 --> 00:15:53.000
Nói chung, một phần của chương trình cung cấp giá trị cho một tham số mờ đục hoặc loại kết quả quyết định loại cơ bản và một phần của chương trình sử dụng giá trị nhìn thấy loại trừu tượng.

00:15:53.000 --> 00:16:00.000
Hãy cùng tìm hiểu cách thức hoạt động của nó, theo trực giác của chúng ta về các giá trị tham số và kết quả.

00:16:00.000 --> 00:16:09.000
Bởi vì kiểu cơ bản được suy ra từ một giá trị, kiểu cơ bản luôn đến từ cùng một vị trí với giá trị.

00:16:09.000 --> 00:16:16.000
Đối với một biến cục bộ, loại cơ bản được suy ra từ giá trị ở phía bên tay phải của phép gán.

00:16:16.000 --> 00:16:27.000
Điều này có nghĩa là các biến cục bộ với kiểu mờ phải luôn có giá trị ban đầu; và nếu bạn không cung cấp, trình biên dịch sẽ báo cáo lỗi.

00:16:27.000 --> 00:16:37.000
Loại cơ bản phải được cố định cho phạm vi của biến, vì vậy việc cố gắng thay đổi loại cơ bản cũng sẽ dẫn đến lỗi.

00:16:37.000 --> 00:16:44.000
Đối với các tham số có kiểu mờ đục, kiểu cơ bản được suy ra từ giá trị đối số tại trang web cuộc gọi.

00:16:44.000 --> 00:16:50.000
Sử dụng "một số" ở vị trí tham số là mới trong Swift 5.7.

00:16:50.000 --> 00:16:58.000
Loại cơ bản chỉ cần được cố định cho phạm vi của tham số, vì vậy mỗi cuộc gọi có thể cung cấp một loại đối số khác nhau.

00:16:58.000 --> 00:17:05.000
Đối với loại kết quả mờ đục, loại cơ bản được suy ra từ giá trị trả về trong quá trình triển khai.

00:17:05.000 --> 00:17:15.000
Một phương thức hoặc thuộc tính được tính toán với kiểu kết quả mờ đục có thể được gọi từ bất kỳ đâu trong chương trình, vì vậy phạm vi của giá trị được đặt tên này là toàn cầu.

00:17:15.000 --> 00:17:28.000
Điều này có nghĩa là kiểu trả về cơ bản phải giống nhau trên tất cả các câu lệnh trả về; và nếu không, trình biên dịch sẽ báo cáo lỗi rằng các giá trị trả về cơ bản có các loại không khớp.

00:17:28.000 --> 00:17:38.000
Đối với chế độ xem SwiftUI mờ đục, ViewBuilder DSL có thể chuyển đổi các câu lệnh luồng điều khiển để có cùng loại trả về cơ bản cho mỗi nhánh.

00:17:38.000 --> 00:17:43.000
Vì vậy, trong trường hợp này, chúng tôi có thể khắc phục sự cố bằng cách sử dụng ViewBuilder DSL.

00:17:43.000 --> 00:17:53.000
Viết chú thích @ViewBuilder trên phương thức và xóa các câu lệnh trả về sẽ cho phép kết quả được xây dựng cho chúng tôi bằng loại ViewBuilder.

00:17:53.000 --> 00:17:56.000
Hãy quay lại phương pháp feedAnimal.

00:17:56.000 --> 00:18:02.000
Tôi có thể sử dụng "một số" trong danh sách tham số vì tôi không cần tham chiếu đến loại mờ ở bất kỳ nơi nào khác.

00:18:02.000 --> 00:18:11.000
Khi bạn cần tham khảo loại mờ đục nhiều lần trong chữ ký hàm, đó là khi tham số loại tên có ích.

00:18:11.000 --> 00:18:23.000
Ví dụ, nếu chúng ta thêm một loại liên quan khác vào giao thức động vật được gọi là "Môi trường sống", chúng ta có thể muốn xây dựng môi trường sống trong trang trại cho một loài động vật nhất định.

00:18:23.000 --> 00:18:34.000
Trong trường hợp này, loại kết quả phụ thuộc vào loại động vật cụ thể, vì vậy chúng ta cần sử dụng tham số loại A trong loại tham số và loại trả về.

00:18:34.000 --> 00:18:41.000
Một nơi phổ biến khác mà bạn cần tham khảo một loại mờ đục nhiều lần là trong các loại chung chung.

00:18:41.000 --> 00:18:52.000
Mã thường khai báo một tham số kiểu trên một kiểu chung, sử dụng tham số kiểu cho một thuộc tính được lưu trữ và một lần nữa trong trình khởi tạo theo thành viên.

00:18:52.000 --> 00:19:01.000
Tham chiếu một loại chung trong một ngữ cảnh khác cũng yêu cầu bạn chỉ định rõ ràng tham số loại trong dấu ngoặc nhọn.

00:19:01.000 --> 00:19:12.000
Dấu ngoặc nhọn tại khai báo có thể giúp làm rõ cách sử dụng kiểu chung, vì vậy các kiểu mờ đục phải luôn được đặt tên cho các kiểu chung.

00:19:12.000 --> 00:19:15.000
Bây giờ, hãy xây dựng việc triển khai phương pháp nguồn cấp dữ liệu.

00:19:15.000 --> 00:19:23.000
Chúng ta có thể sử dụng loại tham số động vật để truy cập loại cây trồng để phát triển thông qua loại liên quan đến Thức ăn chăn nuôi.

00:19:23.000 --> 00:19:28.000
Chúng tôi sẽ gọi Feed.grow() để lấy một phiên bản của cây trồng tạo ra loại nguồn cấp dữ liệu này.

00:19:28.000 --> 00:19:36.000
Tiếp theo, chúng ta cần thu hoạch sản phẩm từ cây trồng, điều mà chúng ta có thể làm bằng cách gọi một phương pháp được cung cấp bởi loại cây trồng được gọi là "thu hoạch".

00:19:36.000 --> 00:19:39.000
Và cuối cùng, chúng ta có thể cho động vật ăn sản phẩm này.

00:19:39.000 --> 00:19:50.000
Bởi vì loại động vật cơ bản là cố định, trình biên dịch biết mối quan hệ giữa loại thực vật, loại sản xuất và loại động vật thông qua các cuộc gọi phương thức khác nhau.

00:19:50.000 --> 00:19:58.000
Những mối quan hệ tĩnh này ngăn cản chúng ta phạm sai lầm khi cho động vật ăn sai loại thức ăn.

00:19:58.000 --> 00:20:07.000
Nếu chúng tôi cố gắng sử dụng một loại không được đảm bảo là loại thức ăn chính xác cho loài động vật này, trình biên dịch sẽ cho chúng tôi biết.

00:20:07.000 --> 00:20:18.000
Để tìm hiểu cách các giao thức trang trại khác được tạo ra để thể hiện mối quan hệ giữa loại thức ăn chăn nuôi và thực vật của nó, hãy xem "Thiết kế giao diện giao thức trong Swift".

00:20:18.000 --> 00:20:23.000
Cuối cùng, hãy thêm một phương pháp để cho tất cả các loài động vật ăn.

00:20:23.000 --> 00:20:26.000
Tôi sẽ thêm một phương thức gọi là feedAll chấp nhận một mảng.

00:20:26.000 --> 00:20:35.000
Tôi biết loại phần tử cần phải phù hợp với giao thức Động vật, nhưng tôi muốn mảng có thể lưu trữ các loại động vật khác nhau.

00:20:35.000 --> 00:20:39.000
Hãy xem liệu một số Động vật có thể giúp chúng ta ở đây không.

00:20:39.000 --> 00:20:44.000
Với "một số" có một loại cơ bản cụ thể không thể thay đổi.

00:20:44.000 --> 00:20:51.000
Bởi vì loại cơ bản là cố định, tất cả các phần tử trong mảng cần phải có cùng một loại.

00:20:51.000 --> 00:20:59.000
Vì vậy, một mảng của một số Động vật không thể hiện điều đúng đắn, bởi vì tôi muốn một mảng có thể chứa các loại động vật khác nhau.

00:20:59.000 --> 00:21:04.000
Ở đây, chúng ta thực sự cần một siêu mẫu có thể đại diện cho bất kỳ loại động vật nào.

00:21:04.000 --> 00:21:11.000
Chúng ta có thể diễn đạt một loại động vật tùy ý bằng cách viết "bất kỳ Động vật nào".

00:21:11.000 --> 00:21:21.000
Từ khóa "bất kỳ" chỉ ra rằng loại này có thể lưu trữ bất kỳ loại động vật tùy ý nào và loại động vật cơ bản có thể thay đổi trong thời gian chạy.

00:21:21.000 --> 00:21:28.000
Cũng giống như với từ khóa "some", từ khóa "any" luôn được theo sau bởi một yêu cầu phù hợp.

00:21:28.000 --> 00:21:40.000
Bất kỳ Động vật nào là một loại tĩnh duy nhất có khả năng lưu trữ bất kỳ loại động vật cụ thể nào một cách linh hoạt, điều này cho phép chúng tôi sử dụng đa hình loại phụ với các loại giá trị.

00:21:40.000 --> 00:21:48.000
Để cho phép lưu trữ linh hoạt này, bất kỳ loại Động vật nào cũng có một đại diện đặc biệt trong bộ nhớ.

00:21:48.000 --> 00:21:52.000
Bạn có thể nghĩ về đại diện này như một cái hộp.

00:21:52.000 --> 00:21:57.000
Đôi khi, một giá trị đủ nhỏ để vừa trực tiếp bên trong hộp.

00:21:57.000 --> 00:22:06.000
Và các giá trị khác quá lớn so với hộp, vì vậy giá trị phải được phân bổ ở nơi khác và hộp lưu trữ một con trỏ đến giá trị đó.

00:22:06.000 --> 00:22:16.000
Loại tĩnh bất kỳ Động vật nào có thể lưu trữ động bất kỳ loại động vật cụ thể nào được gọi chính thức là loại hiện sinh.

00:22:16.000 --> 00:22:23.000
Và chiến lược sử dụng cùng một đại diện cho các loại cụ thể khác nhau được gọi là "xóa loại".

00:22:23.000 --> 00:22:30.000
Loại cụ thể được cho là bị xóa tại thời điểm biên dịch và loại cụ thể chỉ được biết đến trong thời gian chạy.

00:22:30.000 --> 00:22:38.000
Hai trường hợp này của loại hiện sinh mà bất kỳ Động vật nào cũng có cùng loại tĩnh, nhưng các loại động khác nhau.

00:22:38.000 --> 00:22:51.000
Xóa kiểu loại bỏ sự phân biệt cấp kiểu giữa các giá trị động vật khác nhau, điều này cho phép chúng tôi sử dụng các giá trị với các kiểu động khác nhau thay thế cho nhau như cùng một loại tĩnh.

00:22:51.000 --> 00:23:00.000
Chúng ta có thể sử dụng xóa kiểu để viết một mảng không đồng nhất của các loại giá trị, đó chính xác là những gì chúng ta muốn cho phương thức feedAll.

00:23:00.000 --> 00:23:04.000
Vì vậy, chúng tôi sẽ sử dụng một mảng của bất kỳ Động vật nào làm loại tham số.

00:23:04.000 --> 00:23:11.000
Sử dụng từ khóa "bất kỳ" cho các giao thức với các loại liên quan là mới trong Swift 5.7.

00:23:11.000 --> 00:23:17.000
Để thực hiện phương thức feedAll, trước tiên chúng ta sẽ lặp lại mảng của động vật.

00:23:17.000 --> 00:23:22.000
Đối với mỗi con vật, chúng tôi muốn gọi phương thức ăn từ giao thức Động vật.

00:23:22.000 --> 00:23:29.000
Để gọi phương pháp này, chúng ta cần lấy loại thức ăn cụ thể cho động vật bên dưới tại lần lặp này.

00:23:29.000 --> 00:23:35.000
Nhưng ngay khi chúng tôi cố gắng gọi eat trên bất kỳ Động vật nào, chúng tôi sẽ gặp lỗi trình biên dịch.

00:23:35.000 --> 00:23:48.000
Bởi vì chúng tôi đã loại bỏ sự phân biệt cấp độ loại giữa các loại động vật cụ thể, chúng tôi cũng đã loại bỏ tất cả các mối quan hệ loại phụ thuộc vào loại động vật cụ thể, bao gồm các loại liên quan.

00:23:48.000 --> 00:23:53.000
Vì vậy, chúng ta không thể biết loại thức ăn mà con vật này mong đợi.

00:23:53.000 --> 00:24:00.000
Để dựa vào các mối quan hệ kiểu, chúng ta cần quay trở lại bối cảnh mà loại động vật cụ thể được cố định.

00:24:00.000 --> 00:24:08.000
Thay vì gọi ăn trực tiếp trên bất kỳ Động vật nào, chúng ta cần gọi phương thức ăn chấp nhận một số Động vật.

00:24:08.000 --> 00:24:24.000
Bây giờ, bất kỳ Động vật nào là một loại khác với một số Động vật, nhưng trình biên dịch có thể chuyển đổi một thể hiện của bất kỳ Động vật nào thành một Số Động vật bằng cách mở hộp giá trị cơ bản và chuyển nó trực tiếp đến tham số Động vật nào đó.

00:24:24.000 --> 00:24:30.000
Khả năng mở hộp các đối số này là mới trong Swift 5.7.

00:24:30.000 --> 00:24:37.000
Bạn có thể nghĩ đến việc mở hộp khi trình biên dịch mở hộp và lấy ra giá trị được lưu trữ bên trong.

00:24:37.000 --> 00:24:51.000
Đối với phạm vi của một số tham số Động vật, giá trị có một loại cơ bản cố định, vì vậy chúng tôi có quyền truy cập vào tất cả các hoạt động trên loại cơ bản, bao gồm quyền truy cập vào các loại liên quan.

00:24:51.000 --> 00:25:07.000
Điều này thực sự tuyệt vời vì nó cho phép chúng tôi chọn lưu trữ linh hoạt khi chúng tôi cần, trong khi vẫn cho phép chúng tôi quay lại bối cảnh nơi chúng tôi có tính biểu hiện đầy đủ của hệ thống kiểu tĩnh bằng cách sửa loại cơ bản cho phạm vi của một hàm.

00:25:07.000 --> 00:25:20.000
Và hầu hết thời gian, bạn không cần phải suy nghĩ về việc mở hộp vì nó chỉ hoạt động theo cách bạn mong đợi, tương tự như cách gọi một phương thức giao thức trên bất kỳ Động vật nào thực sự gọi phương thức trên loại cơ bản.

00:25:20.000 --> 00:25:31.000
Vì vậy, chúng ta có thể chuyển từng con vật sang phương pháp cho ăn, nơi chúng ta có thể trồng và thu hoạch vụ mùa thích hợp để cho động vật cụ thể ăn ở mỗi lần lặp lại.

00:25:31.000 --> 00:25:38.000
Trong suốt quá trình này, chúng tôi đã thấy rằng "một số" và "bất kỳ" có khả năng khác nhau.

00:25:38.000 --> 00:25:42.000
Với "một số", loại cơ bản được cố định.

00:25:42.000 --> 00:25:54.000
Điều này cho phép bạn dựa vào các mối quan hệ loại với loại cơ bản trong mã chung của mình, vì vậy bạn sẽ có toàn quyền truy cập vào API và các loại liên quan trên giao thức bạn đang làm việc.

00:25:54.000 --> 00:25:59.000
Sử dụng "bất kỳ" khi bạn cần lưu trữ các loại bê tông tùy ý.

00:25:59.000 --> 00:26:12.000
"Bất kỳ" cung cấp xóa kiểu, cho phép bạn đại diện cho các bộ sưu tập không đồng nhất, đại diện cho sự vắng mặt của một loại cơ bản, sử dụng các tùy chọn và làm cho việc trừu tượng hóa trở thành một chi tiết triển khai.

00:26:12.000 --> 00:26:20.000
Nói chung, hãy viết "some" theo mặc định và thay đổi "some" thành "any" khi bạn biết bạn cần lưu trữ các giá trị tùy ý.

00:26:20.000 --> 00:26:30.000
Với cách tiếp cận này, bạn sẽ chỉ phải trả chi phí xóa loại và các giới hạn ngữ nghĩa của nó khi bạn cần sự linh hoạt lưu trữ mà nó cung cấp.

00:26:30.000 --> 00:26:36.000
Quy trình làm việc này tương tự như viết let-constants theo mặc định, cho đến khi bạn biết mình cần đột biến.

00:26:36.000 --> 00:26:44.000
Trong phiên này, chúng tôi đã xem qua quy trình làm việc khái quát hóa mã khi nó phát triển và đạt được nhiều chức năng hơn.

00:26:44.000 --> 00:26:47.000
Chúng tôi bắt đầu bằng cách viết các loại cụ thể.

00:26:47.000 --> 00:26:54.000
Khi mã đạt được nhiều chức năng hơn, chúng tôi nhận thấy sự lặp lại giữa các loại cụ thể khác nhau.

00:26:54.000 --> 00:27:00.000
Từ đó, chúng tôi đã xác định các khả năng chung và khái quát hóa chúng bằng cách sử dụng một giao thức.

00:27:00.000 --> 00:27:09.000
Cuối cùng, chúng tôi đã viết mã trừu tượng bằng cách sử dụng "một số" và "bất kỳ", và chúng tôi đã thảo luận về việc thích "một số" để có mã biểu cảm hơn.

00:27:09.000 --> 00:27:18.000
Để tìm hiểu sâu hơn về chế tạo các giao thức và hiểu cách xóa loại, hãy xem "Thiết kế giao diện giao thức trong Swift".

00:27:18.000 --> 00:27:21.000
Cảm ơn bạn đã tham gia cùng tôi và có một WWDC tuyệt vời.

00:27:21.000 --> 23:59:59.000
♪

