WEBVTT

00:00:00.000 --> 00:00:03.000
♪ Nhạc hip-hop nhạc cụ êm dịu ♪

00:00:03.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:14.000
Xin chào! Tôi là Kendall Bagley, một kỹ sư phần mềm trong nhóm Safari.

00:00:14.000 --> 00:00:32.000
Đã cả năm kể từ lần cuối chúng ta gặp nhau tại WWDC, và hôm nay, chúng ta sẽ nói về tất cả các tính năng và cải tiến tuyệt vời cho Safari và WebKit từ cả những gì mới ở đây tại WWDC năm nay và từ những gì chúng ta đã thấy trong suốt cả năm qua.

00:00:32.000 --> 00:00:35.000
Trên thực tế, đó là một năm khá bận rộn!

00:00:35.000 --> 00:00:44.000
Kể từ mùa thu năm ngoái, mỗi bản phát hành của Safari đã cung cấp các tính năng mới và thú vị mà chúng tôi biết tất cả các bạn với tư cách là nhà phát triển web đã yêu cầu.

00:00:44.000 --> 00:00:51.000
Mỗi cải tiến mới được cung cấp trong năm nay nhằm giải quyết một số điểm phản hồi lớn nhất mà bạn đã chia sẻ với chúng tôi.

00:00:51.000 --> 00:00:59.000
Giống như thêm bộ chọn mẹ với lớp giả :has(), trình kiểm tra flexbox mới và thậm chí cả các truy vấn vùng chứa.

00:00:59.000 --> 00:01:06.000
Chúng tôi muốn làm cho công việc hàng ngày của bạn tốt hơn và dễ dàng hơn nhiều trong khi xây dựng phần mềm tốt nhất và mạnh mẽ nhất cho web.

00:01:06.000 --> 00:01:11.000
Trên thực tế, những gì ở đây chỉ là một số nội dung mới mà chúng ta sẽ xem xét hôm nay.

00:01:11.000 --> 00:01:18.000
Nhưng còn rất nhiều thứ nữa mà chúng tôi sẽ không thể bao quát tất cả trong một phiên này.

00:01:18.000 --> 00:01:27.000
Đã có tổng cộng 162 tính năng và cải tiến nền tảng web mới trên bảy bản phát hành Safari trong năm qua.

00:01:27.000 --> 00:01:34.000
Chúng tôi tự hào cung cấp rất nhiều công cụ mới để bạn sử dụng để tạo trang web và ứng dụng web của mình.

00:01:34.000 --> 00:01:51.000
Và đối với macOS, cách tốt nhất để xem những gì mới và thú vị càng sớm càng tốt là thông qua Safari Technology Preview, nơi bạn có thể thử những điều mới nhất và tuyệt vời nhất cho Safari và WebKit và cũng giúp chúng tôi biết những gì chúng tôi nên làm tiếp theo.

00:01:51.000 --> 00:01:59.000
Nhưng như bạn đã thấy, có rất nhiều tính năng mới, vì vậy chúng ta hãy xem xét mọi thứ mà chúng ta sẽ đề cập đến.

00:01:59.000 --> 00:02:23.000
Hôm nay chúng ta sẽ xem xét các tính năng HTML mới, cải tiến CSS - bao gồm một loạt để giúp kiến trúc mã của bạn - các công cụ Kiểm tra Web mới, nhiều lựa chọn API web mới, các tính năng JavaScript và WebAssembly tuyệt vời và các cải tiến về bảo mật và quyền riêng tư.

00:02:23.000 --> 00:02:32.000
Vì vậy, hãy bắt đầu với những gì mới với HTML bằng cách xem một trang web tôi đang tạo cho đồng nghiệp của mình và tôi sử dụng.

00:02:32.000 --> 00:02:46.000
Cá nhân tôi thực sự thích tiết kiệm và tái sử dụng quần áo của mình như một cách để làm cho tủ quần áo của tôi bền vững hơn, và tôi nghĩ rằng một trang web hoán đổi quần áo cũng sẽ là một cách tuyệt vời để nhóm của tôi dùng thử.

00:02:46.000 --> 00:02:54.000
Thiết kế của tôi cho trang web bao gồm nút Yêu cầu Mặt hàng sẽ hiển thị cho bạn một biểu mẫu để điền vào khi bạn phát hiện ra một bộ quần áo mà bạn thích.

00:02:54.000 --> 00:02:58.000
Và tôi muốn biểu mẫu đó hiển thị trong một lớp phủ trên đầu toàn bộ trang.

00:02:58.000 --> 00:03:08.000
Phần tử hộp thoại mới cung cấp một cách thực sự dễ dàng để tạo lớp phủ một cách mạnh mẽ và dễ tiếp cận mà chúng tôi có thể sử dụng cho biểu mẫu yêu cầu của mình.

00:03:08.000 --> 00:03:16.000
Và phần tử giả phông nền mới trong CSS giúp tạo kiểu nền phía sau phương thức.

00:03:16.000 --> 00:03:19.000
Hãy đưa ra hộp thoại bằng cách yêu cầu một mục.

00:03:19.000 --> 00:03:22.000
Thấy cái bóng và hình ảnh động đó không?

00:03:22.000 --> 00:03:24.000
Nó thực sự trông rất tuyệt!

00:03:24.000 --> 00:03:32.000
Sau đó, khi một mặt hàng được yêu cầu trên trang web của chúng tôi, người đã đăng nó cần có khả năng chấp nhận yêu cầu.

00:03:32.000 --> 00:03:38.000
Ở cuối trang, có một băng chuyền để lướt qua tất cả các yêu cầu bạn nhận được.

00:03:38.000 --> 00:03:49.000
Nhưng tôi không muốn ai đó vô tình tương tác với một nút hoặc trường văn bản cho một trong những mục không phải là mục ở phía trước cùng, bằng cách nhấp chuột hoặc điều hướng bàn phím.

00:03:49.000 --> 00:03:52.000
Tôi có thể sử dụng thuộc tính trơ để khắc phục điều này.

00:03:52.000 --> 00:04:04.000
Bằng cách tự động áp dụng thuộc tính trơ với JavaScript ở đây, tôi sẽ vô hiệu hóa bất kỳ tương tác nào cho các phần tử trên trang trình bày không phải là trang chiếu hiện được chọn khi chúng tôi chuyển đổi giữa chúng.

00:04:04.000 --> 00:04:20.000
Và, sử dụng trơ bao gồm vô hiệu hóa các tương tác cho các công nghệ hỗ trợ và ngăn trình đọc màn hình đọc to các mục bị vô hiệu hóa đó, đưa ra hướng dẫn rõ ràng hơn nhiều về yếu tố nào được dự định cho tương tác.

00:04:20.000 --> 00:04:25.000
Và cuối cùng đối với HTML, có tải chậm mới cho hình ảnh.

00:04:25.000 --> 00:04:44.000
Trên trang web của tôi, có một số biểu tượng trong tiêu đề mà tôi cần tải ngay lập tức, nhưng đối với hình ảnh mặt hàng quần áo nằm ngoài màn hình trong lần tải đầu tiên đó, chúng tôi có thể sử dụng tải chậm cho chúng, vì vậy hình ảnh chỉ tải khi người dùng cuộn đến chúng, làm cho trang cảm thấy nhanh hơn và phản hồi nhanh hơn.

00:04:44.000 --> 00:04:52.000
Tôi thực sự thích cách trang web trông như thế nào cho đến nay và nó cũng sẽ hoạt động tốt cho những người sử dụng công nghệ hỗ trợ.

00:04:52.000 --> 00:05:02.000
Và những tính năng HTML đó chỉ giúp chúng ta bắt đầu, bởi vì cũng có quá nhiều thứ để kiểm tra với CSS trong năm nay.

00:05:02.000 --> 00:05:10.000
Một phần lớn trọng tâm CSS của chúng tôi là làm cho CSS của bạn dễ dàng tái sử dụng hơn thông qua kiến trúc mạnh mẽ hơn.

00:05:10.000 --> 00:05:16.000
Cùng với đó, chúng tôi biết yêu cầu số một cho công nghệ web mới là các truy vấn vùng chứa.

00:05:16.000 --> 00:05:22.000
Và chúng tôi rất vui mừng thông báo rằng các truy vấn container sẽ được giao trong Safari 16!

00:05:22.000 --> 00:05:27.000
Bạn sẽ có thể sử dụng cả truy vấn kích thước và đơn vị truy vấn vùng chứa.

00:05:27.000 --> 00:05:32.000
Ở đây, tôi đang thử nghiệm một bố cục thay thế cho trang web hoán đổi quần áo.

00:05:32.000 --> 00:05:42.000
Tôi đang làm thẻ trình bày một mảnh quần áo thành một thành phần có thể tái sử dụng và thả thành phần đó vào một số vị trí khác nhau trong bố cục trang.

00:05:42.000 --> 00:05:51.000
Ở đây trong thanh bên, không gian có sẵn hơi hẹp, vì vậy tôi muốn tất cả nội dung bên trong thành phần của mình xếp chồng lên nhau theo chiều dọc.

00:05:51.000 --> 00:06:05.000
Trong lưới các mặt hàng chính, tôi muốn giới thiệu cái đầu tiên như một đồ họa anh hùng sẽ chiếm tất cả không gian có sẵn theo chiều ngang và sắp xếp nội dung theo cách có ý nghĩa hơn đối với bố cục rộng.

00:06:05.000 --> 00:06:10.000
Phần còn lại của các mục trong khu vực nội dung chính nên được chia thành các cột nhỏ hơn.

00:06:10.000 --> 00:06:17.000
Vì vậy, tôi đã tạo ra một bố cục khác hoạt động khi có một lượng không gian nằm ngang trung bình.

00:06:17.000 --> 00:06:35.000
Sử dụng các truy vấn vùng chứa để xử lý sự thay đổi trong bố cục, thay vì các truy vấn phương tiện, tôi có thể viết mã bố cục cho thành phần này chỉ một lần và sử dụng thành phần đó ở bất kỳ nơi nào trên trang web của tôi trong vùng chứa có kích thước bất kỳ và bố cục chính xác sẽ luôn được áp dụng.

00:06:35.000 --> 00:06:48.000
Tôi đã chỉ định phần tử nào sẽ sử dụng cho vùng chứa và liệu tôi có muốn đo chỉ dựa trên kích thước nội tuyến hay cả kích thước nội tuyến và khối cùng một lúc hay không, bằng cách sử dụng thuộc tính loại vùng chứa.

00:06:48.000 --> 00:06:58.000
Tôi có thể tùy chọn đặt tên vùng chứa của mình bằng cách sử dụng thuộc tính tên vùng chứa, điều này giúp tôi linh hoạt hơn trong cách cấu trúc HTML.

00:06:58.000 --> 00:07:05.000
Sau đó, tôi sử dụng quy tắc @container để áp dụng các kiểu có điều kiện, dựa trên kích thước của vùng chứa.

00:07:05.000 --> 00:07:14.000
Ở đây, nếu thành phần thẻ quần áo nằm trong một thùng chứa rộng hơn 250 pixel, lưới sẽ thay đổi thành có hai cột thay vì một.

00:07:14.000 --> 00:07:18.000
Tiếp theo với kiến trúc CSS: các lớp xếp tầng.

00:07:18.000 --> 00:07:22.000
Đây là một sự thay đổi mạnh mẽ đối với dòng thác CSS.

00:07:22.000 --> 00:07:28.000
Kể từ khi bắt đầu CSS, dòng thác đã được tạo thành từ các lớp khác nhau này.

00:07:28.000 --> 00:07:39.000
Nhưng bất kể tính đặc thù của bất kỳ bộ chọn nhất định nào bên trong mỗi lớp, các kiểu tác giả - các kiểu bạn viết với tư cách là nhà phát triển web - luôn đánh bại các kiểu UA.

00:07:39.000 --> 00:07:46.000
Phong cách nội tuyến luôn mạnh hơn phong cách tác giả, v.v. với phần còn lại của hệ thống phân cấp.

00:07:46.000 --> 00:07:57.000
Các lớp xếp tầng có cùng khái niệm này và cho phép bạn tạo các lớp tùy chỉnh của riêng mình, nơi tính cụ thể được tính toán độc lập bên trong mỗi lớp.

00:07:57.000 --> 00:08:04.000
Toàn bộ một lớp đánh bại toàn bộ lớp khác, bất kể tính đặc hiệu của các bộ chọn đang được sử dụng là gì.

00:08:04.000 --> 00:08:13.000
Và bạn xác định lớp nào có quyền lực đối với các lớp khác thông qua thứ tự cách bạn xác định các lớp trong CSS của mình.

00:08:13.000 --> 00:08:20.000
Các lớp xếp tầng sẽ là một công cụ hữu ích để kiến trúc CSS trên các dự án lớn và duy trì mã đó theo thời gian.

00:08:20.000 --> 00:08:28.000
Có lẽ nhóm của bạn sẽ sử dụng chúng để tách hệ thống thiết kế khỏi ghi đè hoặc khuôn khổ bạn đang sử dụng cho các kiểu tùy chỉnh cho dự án của mình.

00:08:28.000 --> 00:08:30.000
Nó hoàn toàn phụ thuộc vào bạn!

00:08:30.000 --> 00:08:42.000
Và, để hoàn thiện tất cả các cải tiến mới tuyệt vời cho kiến trúc CSS của bạn là :has(), một lớp giả có thể hoạt động như bộ chọn mẹ mong muốn từ lâu và hơn thế nữa.

00:08:42.000 --> 00:08:51.000
Kết hợp với bất kỳ bộ chọn nào khác trong CSS, :has() có thể tìm kiếm anh chị em, thuộc tính, trạng thái của các trường biểu mẫu và hơn thế nữa.

00:08:51.000 --> 00:08:54.000
Nó thực sự mạnh mẽ.

00:08:54.000 --> 00:09:01.000
Ở đây, tôi muốn đánh dấu toàn bộ hộp tin nhắn bất cứ khi nào ai đó đã chọn "Khẩn cấp?" Hộp kiểm cho một trong những tin nhắn của họ.

00:09:01.000 --> 00:09:12.000
Tôi có thể sử dụng :has pseudo-class ở đây để nói rằng bất cứ khi nào phần tử biểu mẫu có đầu vào của hộp kiểm loại với hộp kiểm đó được chọn, hãy áp dụng CSS này.

00:09:12.000 --> 00:09:16.000
Và tôi thậm chí không cần sử dụng bất kỳ JavaScript nào.

00:09:16.000 --> 00:09:30.000
Chúng tôi hy vọng tất cả những cải tiến tuyệt vời này để xử lý kiến trúc CSS của bạn, với :has(), các lớp xếp tầng và các truy vấn vùng chứa, giúp công việc của bạn với tư cách là một nhà phát triển web tốt hơn nhiều.

00:09:30.000 --> 00:09:35.000
Nhưng đây không phải là những bổ sung CSS duy nhất mà chúng tôi hào hứng.

00:09:35.000 --> 00:09:44.000
Bạn đã muốn một công cụ tương tự như các đơn vị khung nhìn hiện có nhưng sẽ hữu ích hơn trên các thiết bị mà việc cuộn khiến kích thước của khung nhìn thay đổi.

00:09:44.000 --> 00:09:48.000
Và vì điều đó, có các đơn vị khung nhìn mới cho tất cả các bạn.

00:09:48.000 --> 00:09:53.000
Khi bạn muốn biết chiều cao của khung nhìn khi nó nhỏ nhất, hãy sử dụng svh.

00:09:53.000 --> 00:09:57.000
Đối với chiều cao của khung nhìn khi nó lớn nhất, hãy sử dụng lvh.

00:09:57.000 --> 00:10:00.000
Chỉ cần nhớ: s cho nhỏ, l cho lớn.

00:10:00.000 --> 00:10:07.000
Đối với một số động thay đổi để luôn khớp với chiều cao thực tế hiện tại của khung nhìn, hãy sử dụng dvh.

00:10:07.000 --> 00:10:10.000
Và nó không chỉ dành cho chiều cao.

00:10:10.000 --> 00:10:14.000
Chúng tôi đã bảo vệ bạn với nhiều đơn vị khung nhìn hơn nữa.

00:10:14.000 --> 00:10:20.000
Có các đơn vị chiều rộng, rất tốt cho sự hoàn chỉnh để phù hợp với các đơn vị chiều cao được sử dụng nhiều.

00:10:20.000 --> 00:10:28.000
Chúng tôi có khối và nội tuyến - cả hai đều hữu ích khi viết cho nhiều ngôn ngữ với những cách khác nhau mà văn bản có thể chảy.

00:10:28.000 --> 00:10:32.000
Và chúng tôi cũng không quên, tối thiểu và tối đa.

00:10:32.000 --> 00:10:39.000
Nhưng còn khi bạn muốn tạo một số chuyển động trên trang của mình, không chỉ phản ứng với nó thì sao?

00:10:39.000 --> 00:10:48.000
Hoạt hình trước đây rất rõ ràng, nơi bạn có thể chỉ định bắt đầu, kết thúc và thời lượng để khiến các đối tượng chuyển động.

00:10:48.000 --> 00:10:59.000
Nhưng đó là một thách thức đối với việc tạo hiệu ứng động cho các yếu tố trên một trang khi cố gắng làm cho nó đi theo một đường cong hoặc thậm chí chỉ có thể di chuyển nó xung quanh bằng một phần bù.

00:10:59.000 --> 00:11:07.000
Và tôi muốn thêm một hình ảnh động bí mật cho tiêu đề khi bạn nhấp vào nó, Thực sự chỉ nghĩ rằng nó sẽ rất vui.

00:11:07.000 --> 00:11:13.000
Với đường dẫn bù mới, bạn có thể xác định đường dẫn mà bạn muốn đối tượng của mình hoạt hình.

00:11:13.000 --> 00:11:19.000
Đặt đường dẫn bằng đường dẫn bù đắp và sử dụng khoảng cách bù đắp cho hiệu ứng khung hình chính.

00:11:19.000 --> 00:11:30.000
Sau đó sử dụng thuộc tính hoạt ảnh để áp dụng hiệu ứng khung hình chính, cung cấp cho bạn tất cả quyền kiểm soát bạn muốn với hoạt ảnh của mình, tất cả đều bằng CSS.

00:11:30.000 --> 00:11:43.000
Chúng tôi cũng muốn cung cấp cho bạn nhiều quyền kiểm soát hơn đối với trang của mình ngay cả với các phần của trang web thường được xác định bởi chính công cụ trình duyệt và hành vi cuộn chỉ là ví dụ đầu tiên của chúng tôi về điều này.

00:11:43.000 --> 00:11:51.000
Kể từ khi bắt đầu trang web, nếu bạn nhấp vào một liên kết di chuyển bạn đến một phần khác của trang web, nó sẽ xuất hiện trực quan dưới dạng một bước nhảy.

00:11:51.000 --> 00:11:54.000
Đôi khi điều này làm mất phương hướng người dùng của bạn.

00:11:54.000 --> 00:12:01.000
Thuộc tính scroll-behavior trong CSS cung cấp một cách để xác định xem bạn có muốn hành vi này hay không.

00:12:01.000 --> 00:12:06.000
Theo mặc định, nó được đặt thành tự động và nó sẽ xuất hiện dưới dạng bước nhảy đó.

00:12:06.000 --> 00:12:14.000
Bằng cách chỉ định hành vi cuộn là mượt mà, bạn có thể yêu cầu trình duyệt thay vào đó cuộn trơn tru đến vị trí tiếp theo trên trang.

00:12:14.000 --> 00:12:21.000
Bạn cũng có thể làm điều này với các phương thức JavaScript window.scroll(), scrollTo(), hoặc scrollBy().

00:12:21.000 --> 00:12:37.000
Bạn hiểu rõ nhất về khách hàng của mình và có thể xác định trải nghiệm trang web của riêng mình bên ngoài mặc định của công cụ trình duyệt, đây cũng là nơi có thể phát huy tác dụng: lấy nét hiển thị cũng như màu nhấn.

00:12:37.000 --> 00:12:47.000
Bạn có thể đã quen thuộc với bộ chọn tiêu điểm nếu bạn đã từng muốn áp dụng một kiểu cụ thể cho chỉ báo tiêu điểm, có khả năng nó phù hợp hơn với thiết kế tổng thể của bạn.

00:12:47.000 --> 00:12:55.000
Nhưng có một số cạm bẫy về khả năng tiếp cận của việc mất phương pháp suy nghiệm dựa trên trình duyệt khi bạn làm điều đó.

00:12:55.000 --> 00:13:02.000
Và trên trang web của tôi, thay vì các màu biểu mẫu tích hợp, tôi muốn sử dụng màu tùy chỉnh.

00:13:02.000 --> 00:13:09.000
Hãy sử dụng màu xanh mòng két đã có trong tiêu đề của tôi cho cả điểm nổi bật tiêu điểm và hộp kiểm.

00:13:09.000 --> 00:13:21.000
Với lớp giả:focus-visible, bạn có thể tạo kiểu cho chỉ báo lấy nét theo cách bạn chọn trong khi cũng có chỉ báo cách điệu đó chỉ hiển thị nếu nó được trình duyệt hiển thị nguyên bản.

00:13:21.000 --> 00:13:30.000
Và để thêm một lớp tùy chỉnh khác vào biểu mẫu của bạn, bạn có thể sử dụng màu nhấn để thay đổi màu sắc của các phần khác nhau của giao diện người dùng điều khiển biểu mẫu.

00:13:30.000 --> 00:13:35.000
Nó sẽ ảnh hưởng đến hộp kiểm đó cũng như các nút radio, và nhiều hơn thế nữa.

00:13:35.000 --> 00:13:42.000
Ngoài ra với CSS, chúng tôi đã thay thế ngày càng nhiều tiền tố WebKit.

00:13:42.000 --> 00:13:55.000
Đây từng là cách hoàn hảo để thử các tính năng thử nghiệm, nhưng bây giờ, chúng tôi có thể chuyển sang các thuộc tính được xác định theo tiêu chuẩn của chúng để làm cho CSS của bạn dễ viết hơn và dễ tương tác hơn.

00:13:55.000 --> 00:14:04.000
Nhưng đừng lo lắng, CSS hiện tại của bạn với tiền tố WebKit sẽ tiếp tục hoạt động khi bạn chuyển sang các đối tác tiêu chuẩn web của chúng.

00:14:04.000 --> 00:14:14.000
Khả năng hiển thị mặt sau, điều chỉnh màu in và căn chỉnh văn bản: cha mẹ phù hợp đều giống hệt như đối tác tiền tố của chúng.

00:14:14.000 --> 00:14:23.000
Cả mặt nạ và văn bản-kết hợp-phẳng đứng đều đã được cập nhật cú pháp từ phiên bản tiền tố để phù hợp với tiêu chuẩn.

00:14:23.000 --> 00:14:38.000
Và thuộc tính giao diện không có tiền tố cũng bổ sung hỗ trợ cho giá trị tự động mới nhưng đã loại bỏ các giá trị dành riêng cho WebKit trong Safari 16, như dấu mũ hoặc listitem, vì nó được đưa lên các thông số kỹ thuật tiêu chuẩn.

00:14:38.000 --> 00:14:42.000
Cũng có rất nhiều điều cần lưu ý về việc bổ sung kiểu chữ của chúng tôi.

00:14:42.000 --> 00:14:50.000
Đặc biệt, chúng tôi đã thêm thuộc tính font-palette cho phép dễ dàng lựa chọn bảng màu trong phông chữ màu.

00:14:50.000 --> 00:14:55.000
Đó là điều mà tôi nghĩ sẽ rất tuyệt nếu thử với một số logo tiềm năng cho trang web của tôi.

00:14:55.000 --> 00:15:08.000
Chúng ta có thể kiểm tra xem nó trông như thế nào với các bảng màu tối hoặc sáng tích hợp hoặc thậm chí nó sẽ như thế nào để tùy chỉnh nó theo chính xác những gì tôi muốn với ghi đè màu sắc và lấy một số màu vàng trong đó để làm sáng nó.

00:15:08.000 --> 00:15:21.000
Và với kiểu chữ, đã có sự bổ sung của văn bản-trang trí-bỏ qua-mực, cho phép bạn kiểm soát những gì xảy ra khi gạch chân hoặc gạch chân giao nhau với một chữ cái hoặc ký tự.

00:15:21.000 --> 00:15:28.000
Cộng với đơn vị ic, giúp có thể sắp xếp chính xác các ký tự CJK theo hướng khối.

00:15:28.000 --> 00:15:36.000
Nó hữu ích cho việc tạo ra một lưới kiểu chữ sạch sẽ bằng các ngôn ngữ như tiếng Trung, tiếng Nhật và tiếng Hàn.

00:15:36.000 --> 00:15:43.000
Để kết thúc cuộc thảo luận của chúng tôi về tất cả các tính năng CSS tuyệt vời này, chúng tôi chắc chắn phải nói về lưới con.

00:15:43.000 --> 00:15:47.000
Trong nhiều năm, bố cục trên web khá khó khăn.

00:15:47.000 --> 00:15:55.000
CSS Grid đã mang tính cách mạng, nhưng nó chỉ ảnh hưởng đến những đứa con trực tiếp của vùng chứa lưới.

00:15:55.000 --> 00:16:08.000
Ở đây, tôi đang sử dụng CSS Grid để bố trí các thẻ này và tự động điều chỉnh bố cục để phù hợp với chiều rộng khung nhìn bằng cách thêm và xóa các cột mà không cần bất kỳ truy vấn phương tiện nào.

00:16:08.000 --> 00:16:21.000
Nhưng kích thước của nội dung trên mỗi thẻ không giống nhau; một số tiêu đề dài hơn, ảnh có tỷ lệ khung hình khác nhau và điều đó khiến hình ảnh trông thực sự lộn xộn.

00:16:21.000 --> 00:16:35.000
Tôi muốn tất cả các nút Mục Yêu cầu và các hộp tin nhắn xếp hàng trên trang và tôi muốn một tiêu đề dài hơn trên một thẻ ảnh hưởng đến bố cục trên các thẻ khác, vì vậy tất cả chúng đều có cùng khoảng cách.

00:16:35.000 --> 00:16:39.000
Bây giờ, chúng ta có thể thực hiện điều này bằng cách sử dụng lưới điện con.

00:16:39.000 --> 00:16:49.000
Tôi đã đặt một lưới trên mỗi bài báo và tôi đã gắn tất cả các lưới đó với lưới của cha mẹ chúng chỉ bằng cách viết "grid-template-rows: subgrid."

00:16:49.000 --> 00:17:01.000
Bạn có thể thấy tất cả nội dung trên mỗi thẻ quần áo hiện đang xếp hàng hoàn hảo như thế nào bằng cách sử dụng Grid Inspector trong Web Inspector, nơi tôi cũng có thể bật tất cả các lưới mà tôi có thể cần.

00:17:01.000 --> 00:17:06.000
Rất nhiều công việc CSS trở nên dễ dàng hơn khi chúng ta sử dụng Trình kiểm tra Web.

00:17:06.000 --> 00:17:14.000
Trên thực tế, đã có một số bổ sung tuyệt vời cho Web Inspector mà tôi nghĩ bạn sẽ thực sự hào hứng khi thử.

00:17:14.000 --> 00:17:23.000
Trước hết, bố cục dễ viết hơn khi bạn có thể thấy những gì đang diễn ra, đó chính xác là điều khiến Trình kiểm tra web trở nên quan trọng.

00:17:23.000 --> 00:17:30.000
Và với Flexbox Inspector mới, bạn thực sự có thể hình dung khoảng cách giữa các phần tử.

00:17:30.000 --> 00:17:35.000
Ở đây trên trang web của tôi, tôi đã gặp một số sự cố khi thêm các biểu tượng này vào tiêu đề của mình.

00:17:35.000 --> 00:17:51.000
Tất cả những gì tôi cần làm là kiểm tra phần tử và chuyển đến tab Bố cục và vì tôi không quan tâm đến lưới của mình ngay bây giờ, tôi có thể tiếp tục và thu gọn phần đó để đến ngay Trình kiểm tra Flexbox mới.

00:17:51.000 --> 00:17:57.000
Tôi thậm chí có thể bật tất cả các chế độ xem chỉ với một cú nhấp chuột và vẫn có hiệu suất mượt mà.

00:17:57.000 --> 00:18:09.000
Và với tất cả các chế độ xem được bật, tôi có thể thấy rõ với các dấu băm và hộp chứa các yếu tố của tôi đang được sắp xếp như thế nào và không gian trống đang chiếm tầm nhìn như thế nào.

00:18:09.000 --> 00:18:16.000
Vì vậy, bây giờ tôi muốn đảm bảo rằng tôi đang căn chỉnh đúng, mà tôi có thể sử dụng trình chỉnh sửa căn chỉnh mới.

00:18:16.000 --> 00:18:21.000
Tôi có thể vào tab Kiểu dáng để tìm một nút mới bên cạnh các mục căn chỉnh.

00:18:21.000 --> 00:18:30.000
Ở đây, tôi có thể chuyển qua các tùy chọn khác nhau để tìm ra những gì phù hợp nhất với tiêu đề của mình và tôi cũng có thể làm điều tương tự với nội dung biện minh.

00:18:30.000 --> 00:18:39.000
Một lần nữa, chỉ cần chuyển qua từng tùy chọn và sau đó hạ cánh xuống tùy chọn mà tôi nghĩ trông vừa phải.

00:18:39.000 --> 00:18:54.000
Tôi cũng nghĩ rằng các biểu tượng màu vàng hơi quá nhỏ và tôi muốn thử làm cho chúng có cùng kích thước với các biểu tượng màu đỏ, mà tôi tin rằng đang sử dụng một biến có "trung bình" trong tên, nhưng tôi thực sự không thể nhớ tên đầy đủ.

00:18:54.000 --> 00:19:02.000
Tôi có thể thử thay đổi kích thước bằng cách kiểm tra một trong các biểu tượng màu vàng và chỉnh sửa chiều cao của nó trong trình kiểm tra.

00:19:02.000 --> 00:19:14.000
Và, nhờ vào tính năng tự động hoàn thành mờ CSS mới của chúng tôi, tôi có thể tiếp tục và nhập "trung bình" và biến tôi muốn bật lên mặc dù "trung bình" nằm ở cuối tên.

00:19:14.000 --> 00:19:20.000
Và những biểu tượng màu vàng đó chắc chắn không còn quá nhỏ nữa.

00:19:20.000 --> 00:19:29.000
Và khi những biến khác cho các biểu tượng khác nhau không được sử dụng cho phần tử tôi đang kiểm tra, chúng sẽ bị ẩn đi bằng công cụ CSS mới của chúng tôi.

00:19:29.000 --> 00:19:34.000
Nhưng đừng lo lắng, có một nút để hiển thị chúng khi bạn cần.

00:19:34.000 --> 00:19:44.000
Và có lẽ thú vị nhất đối với Trình kiểm tra web trong năm nay, chúng tôi vui mừng thông báo hỗ trợ cho các tiện ích mở rộng công cụ dành cho nhà phát triển cho Trình kiểm tra web Safari.

00:19:44.000 --> 00:19:55.000
Những người tạo ra các tiện ích mở rộng công cụ dành cho nhà phát triển yêu thích của bạn giờ đây sẽ có thể chuyển chúng sang Safari, sử dụng cùng các API cơ bản mà họ sử dụng trong các trình duyệt khác.

00:19:55.000 --> 00:20:12.000
Nếu bạn quan tâm đến việc học cách tạo tiện ích mở rộng cho Trình kiểm tra web, khám phá các API mới và thiết lập để bắt đầu tự mình sử dụng chúng, hãy đảm bảo xem "Tạo Tiện ích mở rộng Trình kiểm tra web Safari" tại WWDC năm nay.

00:20:12.000 --> 00:20:22.000
Bây giờ chúng tôi đã đề cập đến rất nhiều điều mới với các công nghệ front-end của mình, vì vậy hãy chuyển đổi bánh răng và tìm hiểu những gì mới với API web của chúng tôi.

00:20:22.000 --> 00:20:26.000
Chúng tôi rất vui mừng thông báo hỗ trợ cho việc thúc đẩy web.

00:20:26.000 --> 00:20:31.000
Nó sẽ có sẵn trong Safari 16 trên macOS Ventura.

00:20:31.000 --> 00:20:35.000
Nó sẽ đến với iOS và iPadOS vào năm tới.

00:20:35.000 --> 00:20:41.000
Web push cho phép bạn gửi thông báo từ xa đến người dùng từ trang web hoặc ứng dụng web của bạn.

00:20:41.000 --> 00:20:46.000
Đây là một triển khai hoàn toàn có thể tương tác, dựa trên tiêu chuẩn.

00:20:46.000 --> 00:20:55.000
Nếu bạn đã triển khai web push và nó hoạt động trong các trình duyệt khác, nó sẽ chỉ hoạt động trong Safari mà không có bất kỳ sửa đổi nào.

00:20:55.000 --> 00:20:58.000
Và bạn cũng không cần tài khoản Nhà phát triển Apple.

00:20:58.000 --> 00:21:06.000
Để tìm hiểu tất cả về các chi tiết, hãy xem "Gặp gỡ Web Push for Safari" tại đây tại WWDC22.

00:21:06.000 --> 00:21:13.000
Nếu bạn hào hứng với việc đẩy web, thì có lẽ bạn cũng sẽ hào hứng với những cải tiến bản kê khai ứng dụng web mới.

00:21:13.000 --> 00:21:20.000
Bây giờ, bạn có thể xác định biểu tượng được sử dụng khi mọi người lưu ứng dụng web của bạn vào Màn hình chính trong tệp kê khai của bạn.

00:21:20.000 --> 00:21:28.000
Để các biểu tượng trong bản kê khai được ưu tiên, bạn sẽ cần đảm bảo rằng không có biểu tượng cảm ứng táo nào được xác định trong đầu HTML.

00:21:28.000 --> 00:21:44.000
Nếu bạn muốn gửi một biểu tượng cho iOS và iPadOS, trong khi cung cấp một biểu tượng khác cho các nền tảng di động khác, bạn vẫn có thể làm như vậy bằng cách xác định biểu tượng cho các thiết bị Apple trong đầu HTML đó bằng biểu tượng cảm ứng táo.

00:21:44.000 --> 00:21:52.000
Và nếu bạn không khai báo một biểu tượng ở một trong hai nơi, thì khi người dùng lưu trang web của bạn vào Màn hình chính, họ sẽ chỉ nhận được ảnh chụp màn hình trang web của bạn.

00:21:52.000 --> 00:22:11.000
Thật thú vị, chúng tôi cũng không còn chờ đợi người dùng chọn "Thêm vào Màn hình chính" từ menu Chia sẻ để tải tệp kê khai, có nghĩa là bạn có thể sử dụng tệp kê khai đó để xác định các đặc điểm của trang web của mình trên tất cả các trang web của mình và thậm chí giảm hơn nữa nhu cầu sử dụng thẻ meta.

00:22:11.000 --> 00:22:20.000
Tiếp tục với các API của chúng tôi, chúng tôi đã làm rất nhiều để cải thiện việc sử dụng các trang web trong nhiều ngữ cảnh duyệt web có cùng nguồn gốc.

00:22:20.000 --> 00:22:25.000
Các kênh phát sóng cho phép bạn gửi thông báo giữa các ngữ cảnh duyệt web khác nhau đó.

00:22:25.000 --> 00:22:32.000
Hãy tưởng tượng ai đó đang sử dụng trang web trao đổi quần áo và họ mở nó trong hai cửa sổ cùng một lúc.

00:22:32.000 --> 00:22:35.000
Sau đó, họ yêu cầu một bộ quần áo trong một cửa sổ.

00:22:35.000 --> 00:22:43.000
Chúng tôi sẽ có thể đăng một tin nhắn và đồng bộ hóa trạng thái không khả dụng đó với bất kỳ tab hoặc cửa sổ đang mở nào khác.

00:22:43.000 --> 00:22:49.000
Nhưng có thể nó không cập nhật một tab trong nền, mà là cập nhật một tệp được lưu cho trang web của bạn.

00:22:49.000 --> 00:22:54.000
Đối với điều đó, đã có sự bổ sung của API Truy cập Hệ thống Tệp.

00:22:54.000 --> 00:23:05.000
Chúng tôi đã có các bản cập nhật gia tăng cho API này qua nhiều bản phát hành trong năm nay, bắt đầu với hệ thống tệp riêng gốc, là lưu trữ riêng dựa trên nguồn gốc.

00:23:05.000 --> 00:23:13.000
Vì vậy, ví dụ, trang web trao đổi quần áo của tôi sẽ không có các trang web khác, như apple.com, đọc các tệp của nó.

00:23:13.000 --> 00:23:29.000
Sau đó, chúng tôi đã thêm vào API bằng phương thức getFile() của FileSystemFileHandle, phương thức này đọc một tệp hiện có được truy xuất từ thư mục gốc của trang web của bạn, giống như chúng tôi đang làm với một tệp nháp ở đây mà chúng tôi cũng vừa mới tạo.

00:23:29.000 --> 00:23:37.000
Bây giờ chúng ta hãy xem xét bổ sung API rực rỡ nhất của chúng tôi trong năm nay với một số màu sắc phong phú mới.

00:23:37.000 --> 00:23:45.000
Không gian màu Display P3 cho phép thể hiện các màu không tồn tại trong RGB.

00:23:45.000 --> 00:23:48.000
Ở đây, chúng tôi có một số ví dụ về bộ chọn màu.

00:23:48.000 --> 00:23:53.000
Ở bên trái của đường màu trắng vặn vẹo là màu tồn tại trong RGB.

00:23:53.000 --> 00:23:58.000
Và ở bên phải của dòng là các màu chỉ có sẵn trong P3.

00:23:58.000 --> 00:24:03.000
Vào năm 2016, chúng tôi đã thêm hỗ trợ P3 cho video và ảnh.

00:24:03.000 --> 00:24:12.000
Năm ngoái, chúng tôi rất vui mừng khi trở thành công cụ trình duyệt đầu tiên triển khai cú pháp màu mới được xác định trong CSS Color Level 4.

00:24:12.000 --> 00:24:18.000
Năm nay, chúng tôi đã thêm hỗ trợ cho màu P3 cho nội dung bên trong phần tử canvas.

00:24:18.000 --> 00:24:29.000
Vì vậy, không cần phải sử dụng màu sắc dựa trên các thiết bị từ những năm 90, khi bây giờ bạn có thể bắt đầu sử dụng khả năng đầy đủ màu sắc của tất cả các thiết bị tuyệt vời ngày nay.

00:24:29.000 --> 00:24:50.000
Nhưng thậm chí còn có nhiều thứ hơn để kiểm tra với các API Web mới của chúng tôi từ năm ngoái, bao gồm các lĩnh vực bóng tối, khóa web và hỗ trợ cập nhật cho API ResizeObserver cho giao diện ResizeObserverSize, điều này sẽ giúp bạn quan sát các thay đổi đối với các thuộc tính kích thước hộp của một phần tử

00:24:50.000 --> 00:24:58.000
Có rất nhiều thứ để thử trên tất cả các bổ sung API mới của chúng tôi, và tất nhiên, với tất cả các tính năng mới của chúng tôi.

00:24:58.000 --> 00:25:02.000
Trên thực tế, chúng tôi vẫn còn nhiều việc phải làm.

00:25:02.000 --> 00:25:08.000
Vì vậy, tiếp theo chúng ta hãy đi vào tất cả những gì mới trong JavaScript &amp; WebAssembly.

00:25:08.000 --> 00:25:20.000
Nếu trang web của bạn sử dụng công nhân và bạn muốn các trường hợp của những công nhân này được chia sẻ trên các tab và cửa sổ, thì giao diện công nhân được chia sẻ mới chắc chắn sẽ giúp ích và có khả năng giảm mức sử dụng bộ nhớ.

00:25:20.000 --> 00:25:31.000
Thay vì sinh ra những người lao động mới cho mọi nhiệm vụ mà bạn muốn thực hiện trong nền, bạn chỉ có thể có một người lao động được sử dụng cho mỗi ngữ cảnh duyệt web có cùng nguồn gốc.

00:25:31.000 --> 00:25:40.000
Mỗi tập lệnh sẽ tạo ra một công nhân được chia sẻ theo cùng một cách, và sau đó họ có thể nhận và đăng tin nhắn bằng cùng một cổng.

00:25:40.000 --> 00:25:47.000
Nhân viên được chia sẻ sẽ có thể nhận và trả lời các tin nhắn được gửi từ tất cả các tập lệnh khác nhau.

00:25:47.000 --> 00:25:56.000
Điều này sẽ dẫn đến nhu cầu ít hơn trên máy chủ của bạn, đồng thời làm cho trang web của bạn nhanh chóng và đáp ứng cho khách hàng của bạn.

00:25:56.000 --> 00:26:00.000
Chúng tôi cũng có một loạt các tính năng mảng để hiển thị cho bạn.

00:26:00.000 --> 00:26:17.000
Thay vì phải biến đổi một mảng bằng cách sử dụng reverse() khi bạn muốn tìm kiếm từ cuối, bây giờ bạn có thể sử dụng các phương thức findLast() và findLastIndex(), như tôi đã làm ở đây để tìm mục và chỉ mục cho mục cuối cùng có chứa "dây giày".

00:26:17.000 --> 00:26:22.000
Phương thức at() mới cũng giúp việc tìm kiếm từ cuối mảng trở nên dễ dàng hơn.

00:26:22.000 --> 00:26:35.000
Sử dụng dấu ngoặc nhọn hoạt động tốt khi chỉ mục dương, nhưng với at(), chúng tôi nhận được tính năng bổ sung là lập chỉ mục với các giá trị âm giúp mã của bạn ngắn gọn và dễ đọc hơn.

00:26:35.000 --> 00:26:46.000
Nhưng ngay cả với số lượng tốt các tính năng mảng mới đó, không có gì có thể đánh bại số lượng tuyệt đối các tính năng quốc tế hóa mới mà chúng tôi có cho bạn.

00:26:46.000 --> 00:26:54.000
WebKit đã tiếp tục bổ sung các bản cập nhật thường xuyên vào việc triển khai Intl của chúng tôi trong suốt năm qua.

00:26:54.000 --> 00:27:09.000
Đã có thêm hỗ trợ cho các hệ thống đánh số khác nhau với các phương thức mới trong NumberFormat, lịch, nhờ các bản cập nhật với Locale cũng như DisplayNames và tiền tệ với Intl Enumeration API.

00:27:09.000 --> 00:27:24.000
Và như tôi đã nói, có rất nhiều thứ đã được thêm vào triển khai Quốc tế của chúng tôi trong năm nay mà bạn sẽ không thiếu những thứ để thử và khám phá để phục vụ cho người dùng của mình trên toàn thế giới.

00:27:24.000 --> 00:27:38.000
Và đối với tất cả những người có mã hiện có trong tất cả các loại ngôn ngữ mã hóa khác nhau, như C, Objective C hoặc Swift, mà họ muốn đưa lên web, WebAssembly giúp họ chạy mà không cần phải viết lại.

00:27:38.000 --> 00:27:54.000
Và với những cải tiến của năm nay, các ứng dụng web của bạn sử dụng WebAssembly chỉ trở nên mạnh mẽ hơn với bộ nhớ địa chỉ được mở rộng lên 4GB và tăng hiệu suất đi kèm với việc xử lý ngoại lệ chi phí bằng không mới.

00:27:54.000 --> 00:28:01.000
Nhìn chung, chắc chắn có một số thứ thú vị để JavaScript và WebAssembly thử ở đây.

00:28:01.000 --> 00:28:16.000
Và nói về WebAssembly, chúng tôi cũng có một số cải tiến về bảo mật và quyền riêng tư không chỉ bảo vệ người dùng web mà chúng tôi phát triển mà còn mang lại tiềm năng mới cho bạn với tư cách là nhà phát triển.

00:28:16.000 --> 00:28:33.000
Với cả hai tiêu đề phản hồi HTTP của Cross Origin Opener Policy và Cross Origin Embedder Policy mới, trang web của bạn có thể chọn tham gia cách ly quy trình, có nghĩa là trang web của bạn sẽ chạy trong quy trình webContent chuyên dụng của riêng nó.

00:28:33.000 --> 00:28:46.000
Chúng tôi biết rằng rất nhiều ứng dụng có thể được hưởng lợi từ việc chạy song song trên nhiều luồng WebAssembly và với các tiêu đề mới này, bạn có thể làm như vậy một cách an toàn.

00:28:46.000 --> 00:28:55.000
Cải tiến bảo mật thứ hai của chúng tôi cũng liên quan đến các tiêu đề HTTP với sự hỗ trợ được cải thiện của chúng tôi cho chính sách bảo mật nội dung cấp 3.

00:28:55.000 --> 00:29:04.000
CSP cung cấp khả năng kiểm soát bảo mật nâng cao đối với nội dung tải của bạn và giảm thiểu rủi ro kịch bản chéo trang web và các lỗ hổng khác.

00:29:04.000 --> 00:29:11.000
Với các bản cập nhật cấp độ 3, sự bổ sung thú vị nhất là biểu thức nguồn năng động nghiêm ngặt mới.

00:29:11.000 --> 00:29:21.000
Các nhà thiết kế của strict-dynamic nhận ra rằng bạn có thể sử dụng nonces để cho phép một số tập lệnh nhất định, sau đó mở rộng niềm tin đó cho các tập lệnh được tải bởi những tập lệnh đã đáng tin cậy.

00:29:21.000 --> 00:29:24.000
Không cần danh sách cho phép rõ ràng.

00:29:24.000 --> 00:29:26.000
Hãy nhìn xem tiêu đề trở nên đơn giản hơn bao nhiêu.

00:29:26.000 --> 00:29:32.000
Đi từ danh sách dài các tên miền ban đầu có khả năng cho phép quá nhiều.

00:29:32.000 --> 00:29:45.000
Và với điều đó, chúng tôi kết thúc các tính năng bảo mật và quyền riêng tư của mình, điều này cũng đưa chúng tôi đến cuối cùng của tất cả những gì chúng tôi sẽ đề cập đến ngày hôm nay, nhưng thậm chí còn có nhiều điều để bạn tự khám phá.

00:29:45.000 --> 00:30:03.000
Ví dụ: chúng tôi đã có các bản cập nhật phương tiện bao gồm hỗ trợ chụp một cửa sổ Safari cụ thể với API getUserDisplay(), WebRTC Perfect Negotiation, các bản nhạc chương trong băng tần và yêu cầu VideoFrameCallback().

00:30:03.000 --> 00:30:12.000
Cũng như rất nhiều bổ sung thú vị cho các tiện ích mở rộng web với hỗ trợ phiên bản kê khai 3 và một loạt các API tiện ích mở rộng web mới.

00:30:12.000 --> 00:30:41.000
Để đi sâu hơn vào tất cả các tính năng được đề cập ở đây ngày hôm nay và để khám phá tất cả 162 tính năng và cải tiến được phát triển trong Safari và WebKit trong năm qua, hãy đảm bảo tải xuống Bản xem trước công nghệ Safari để cập nhật những gì sắp tới trong tương lai, khám phá công nghệ web bằng cách xem ghi chú phát hành, bài đăng trên

00:30:41.000 --> 00:30:47.000
Và như mọi khi, hãy cho chúng tôi biết suy nghĩ của bạn và những gì bạn muốn xem tiếp theo bằng cách nộp báo cáo lỗi của bạn.

00:30:47.000 --> 00:31:03.000
Nếu bạn gặp một lỗi trong WebKit - điều gì đó về HTML, CSS, JavaScript, DOM APIs hoặc Web Inspector - hãy đảm bảo gửi phản hồi của bạn thông qua hệ thống theo dõi lỗi của WebKit tại bugs.webkit.org.

00:31:03.000 --> 00:31:11.000
Và đối với các đề xuất hoặc lỗi với giao diện Safari, các vấn đề tệp trong Trợ lý Phản hồi của Apple.

00:31:11.000 --> 00:31:24.000
Chúng tôi mong muốn cung cấp nhiều tính năng tuyệt vời hơn giúp công việc của các nhà phát triển web như bạn tốt hơn nhiều với tất cả các bản phát hành Bản xem trước công nghệ Safari và Safari sẽ ra mắt vào năm tới.

00:31:24.000 --> 00:31:30.000
Cảm ơn bạn đã tham gia cùng tôi hôm nay, và tôi hy vọng bạn có khoảng thời gian tuyệt vời nhất ở đây tại WWDC.

00:31:30.000 --> 00:31:32.000
Tạm biệt ngay bây giờ!

00:31:32.000 --> 23:59:59.000
♪

