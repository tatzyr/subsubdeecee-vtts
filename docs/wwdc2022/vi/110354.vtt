WEBVTT

00:00:00.000 --> 00:00:03.000
♪ Nhạc hip-hop nhạc cụ êm dịu ♪

00:00:03.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:11.000
Xin chào, tôi là Angela.

00:00:11.000 --> 00:00:13.000
Và tôi là Becca.

00:00:13.000 --> 00:00:15.000
Chào mừng đến với những gì mới trong Swift!

00:00:15.000 --> 00:00:21.000
Chúng tôi thực sự vui mừng được nói chuyện với bạn hôm nay về tất cả các tính năng mới tuyệt vời trong Swift 5.7.

00:00:21.000 --> 00:00:28.000
Nhiều điều chúng ta sẽ nói hôm nay chứng minh mục tiêu của Swift là giúp cuộc sống của bạn với tư cách là một nhà phát triển dễ dàng hơn.

00:00:28.000 --> 00:00:35.000
Chúng tôi sẽ xem xét công cụ mới để giúp bạn tùy chỉnh quy trình làm việc của mình và một số cải tiến tuyệt vời dưới mui xe.

00:00:35.000 --> 00:00:43.000
Sau đó, chúng ta sẽ nói về mô hình đồng thời mới nhất của Swift và con đường đến Swift 6, bao gồm cả sự an toàn toàn luồng.

00:00:43.000 --> 00:00:54.000
Sau đó, tôi sẽ kết thúc bằng cách đưa bạn qua một số cải tiến ngôn ngữ giúp Swift dễ đọc và viết hơn, bao gồm các loại thuốc generic sạch hơn, đơn giản hơn và các phương tiện xử lý chuỗi mới mạnh mẽ.

00:00:54.000 --> 00:01:02.000
Nhưng trước tiên, hãy bắt đầu bằng cách nói về một trong những điều khiến Swift trở nên đặc biệt - tất cả các bạn.

00:01:02.000 --> 00:01:08.000
Đầu vào và đóng góp của bạn là những gì đã cho phép Swift mở rộng nhanh chóng.

00:01:08.000 --> 00:01:11.000
Sự tham gia của cộng đồng là cốt lõi của Swift.

00:01:11.000 --> 00:01:23.000
Năm nay, nhiều dự án Swift đã có sẵn cho cộng đồng khi docC - công cụ tạo tài liệu được công bố vào năm ngoái - và trang web Swift.org có nguồn mở.

00:01:23.000 --> 00:01:28.000
Nguồn mở hoạt động tốt nhất khi bạn có một cộng đồng tích cực hướng dẫn nó.

00:01:28.000 --> 00:01:38.000
Chúng tôi đã sử dụng mô hình nhóm làm việc cho Swift trên Máy chủ và Đa dạng trong Swift để cung cấp sự quản lý và hỗ trợ cho các thành viên cộng đồng quan tâm đến các lĩnh vực cụ thể.

00:01:38.000 --> 00:01:42.000
Điều này đã hoạt động rất tốt nên chúng tôi đã bắt đầu hai nhóm làm việc mới.

00:01:42.000 --> 00:01:54.000
Một cho việc lặp lại trên trang web Swift và làm cho nó trở thành tài nguyên cộng đồng nhiều hơn, và một cho khả năng tương tác C++, để định hình thiết kế của mô hình giữa C++ và Swift.

00:01:54.000 --> 00:02:00.000
Khi chúng tôi mạo hiểm vào các lĩnh vực mới, tất cả chúng tôi đều cần sự hỗ trợ từ các thành viên trong cộng đồng.

00:02:00.000 --> 00:02:05.000
Là một phần của điều đó, nhóm làm việc Đa dạng trong Swift đã giới thiệu Chương trình Cố vấn Swift vào năm ngoái.

00:02:05.000 --> 00:02:15.000
Chương trình cung cấp các lộ trình để đóng góp cho tất cả các lĩnh vực nhóm làm việc cho những người không biết cách bắt đầu hoặc đang tìm cách đào sâu chuyên môn của họ trong một lĩnh vực cụ thể.

00:02:15.000 --> 00:02:18.000
Chương trình năm ngoái là một thành công lớn.

00:02:18.000 --> 00:02:25.000
Có rất nhiều người được cố vấn quan tâm; và cùng với điều đó, chúng tôi đã có thể tạo ra 41 cặp cố vấn.

00:02:25.000 --> 00:02:30.000
Thành công này là lý do tại sao chương trình được đưa trở lại trong năm thứ hai.

00:02:30.000 --> 00:02:42.000
Chương trình rất muốn bao gồm tất cả những người quan tâm; nhưng để làm điều đó, chúng tôi cần bạn - những nhà phát triển hào hứng và có kinh nghiệm đang lắng nghe, những người sẵn sàng chia sẻ bề rộng kiến thức của họ và tạo ra các kết nối mới.

00:02:42.000 --> 00:02:49.000
Bởi vì chương trình cố vấn không chỉ là về quy tắc mà còn về việc xây dựng các mối quan hệ trong cộng đồng.

00:02:49.000 --> 00:02:52.000
Và một chút hướng dẫn có thể có tác dụng lâu dài.

00:02:52.000 --> 00:02:54.000
Đừng chỉ tin lời tôi.

00:02:54.000 --> 00:03:00.000
Năm ngoái, Amrit đã tham gia vào chương trình cố vấn và tập trung vào trình biên dịch và thiết kế ngôn ngữ.

00:03:00.000 --> 00:03:06.000
Những gì bắt đầu như một âm mưu cho Amrit đã biến thành những đóng góp hữu hình.

00:03:06.000 --> 00:03:09.000
Đi sâu vào một miền mới không hề dễ dàng.

00:03:09.000 --> 00:03:14.000
Mặc dù vậy, cô ấy đã bỏ đi để tìm kiếm thành công và cảm thấy được truyền cảm hứng để đóng góp nhiều hơn.

00:03:14.000 --> 00:03:19.000
Giống như nhiều người khác, trải nghiệm này đã mở ra cánh cửa cho Amrit.

00:03:19.000 --> 00:03:30.000
Ngoài trình biên dịch và thiết kế ngôn ngữ, năm ngoái có một loạt các lĩnh vực trọng tâm có sẵn, từ viết và thử nghiệm kỹ thuật đến đóng góp cho các gói Swift.

00:03:30.000 --> 00:03:36.000
Năm nay, chúng tôi đang bổ sung nhiều hơn nữa và luôn có cơ hội cho các chủ đề mới.

00:03:36.000 --> 00:03:42.000
Nếu bạn không thấy điều gì đó trong danh sách này mà bạn quan tâm, bạn vẫn có thể đề cập đến nó trong đơn đăng ký của mình.

00:03:42.000 --> 00:03:54.000
Một bổ sung khác là chương trình năm nay sẽ cung cấp tư vấn quanh năm cho các đóng góp lỗi khởi đầu để giúp phù hợp với bất kỳ ai có thể có năng lực tham gia thấp hơn nhưng vẫn hào hứng tham gia.

00:03:54.000 --> 00:04:00.000
Nếu bạn quan tâm đến việc đăng ký hoặc chỉ muốn nghe thêm, hãy xem bài đăng trên blog Swift gần đây nhất.

00:04:00.000 --> 00:04:05.000
Ở đó, bạn có thể tìm thấy các liên kết đến các phản ánh chi tiết từ những người được cố vấn được đánh dấu.

00:04:05.000 --> 00:04:10.000
Chương trình cố vấn chỉ là một sáng kiến dưới sự đa dạng trong sự bảo trợ của Swift.

00:04:10.000 --> 00:04:17.000
Để tìm hiểu thêm về chương trình cố vấn và các nỗ lực Đa dạng trong Swift khác, bạn có thể truy cập Swift.org/diversity.

00:04:17.000 --> 00:04:24.000
Để mở cánh cửa xa hơn nữa, chúng tôi muốn làm cho việc sử dụng Swift với các tài nguyên bạn có trở nên dễ dàng nhất có thể!

00:04:24.000 --> 00:04:32.000
Chúng tôi đã sắp xếp hợp lý quy trình phân phối chuỗi công cụ Swift cho nền tảng Linux bằng cách thêm hỗ trợ cho các định dạng gói Linux.

00:04:32.000 --> 00:04:40.000
Với trình cài đặt chuỗi công cụ gốc mới, giờ đây bạn có thể tải xuống RPM cho Amazon Linux 2 và CentOS 7 trực tiếp từ Swift.org.

00:04:40.000 --> 00:04:45.000
Các chuỗi công cụ này là thử nghiệm, vì vậy hãy chắc chắn chia sẻ phản hồi trên diễn đàn Swift.org.

00:04:45.000 --> 00:04:48.000
Swift chủ yếu được sử dụng để xây dựng ứng dụng.

00:04:48.000 --> 00:04:57.000
Tuy nhiên, tầm nhìn luôn là Swift có thể mở rộng - được sử dụng từ mọi thứ từ các tập lệnh cấp cao đến môi trường kim loại trần.

00:04:57.000 --> 00:05:04.000
Để khuyến khích Swift được sử dụng ở nơi nó chưa từng được sử dụng trước đây, Swift đã trải qua một số thay đổi lớn trong năm nay.

00:05:04.000 --> 00:05:17.000
Để làm cho thư viện tiêu chuẩn nhỏ hơn cho các tệp nhị phân độc lập, được liên kết tĩnh, chúng tôi đã bỏ sự phụ thuộc vào thư viện hỗ trợ Unicode bên ngoài, thay thế nó bằng triển khai gốc nhanh hơn.

00:05:17.000 --> 00:05:22.000
Các tệp nhị phân nhỏ hơn, nhanh hơn là một lợi ích to lớn khi chạy trên các giải pháp máy chủ theo sự kiện.

00:05:22.000 --> 00:05:28.000
Bạn nhận được liên kết tĩnh trên Linux theo mặc định để hỗ trợ tốt hơn việc triển khai containerized cho máy chủ.

00:05:28.000 --> 00:05:36.000
Việc giảm kích thước này làm cho Swift phù hợp với cả những môi trường bị hạn chế, điều này cho phép chúng tôi sử dụng nó trong Bộ xử lý Secure Enclave của Apple.

00:05:36.000 --> 00:05:46.000
Swift rất hữu ích từ các ứng dụng đến máy chủ cho đến các bộ xử lý bị hạn chế; gắn tất cả lại với nhau là hệ sinh thái gói.

00:05:46.000 --> 00:05:50.000
Các tính năng mới của năm nay trong các gói Swift sẽ giúp cuộc sống của bạn tốt hơn.

00:05:50.000 --> 00:05:55.000
Để bắt đầu, Swift Package Manager đã giới thiệu TOFU.

00:05:55.000 --> 00:05:58.000
Không, không phải món ăn nhẹ ngon miệng.

00:05:58.000 --> 00:06:01.000
TOFU là từ viết tắt của Trust On First Use.

00:06:01.000 --> 00:06:08.000
Đó là một giao thức bảo mật mới, nơi dấu vân tay của gói hiện đang được ghi lại khi gói được tải xuống lần đầu tiên.

00:06:08.000 --> 00:06:14.000
Các lần tải xuống tiếp theo sẽ xác thực dấu vân tay này và báo cáo lỗi nếu dấu vân tay khác nhau.

00:06:14.000 --> 00:06:23.000
Đây chỉ là một ví dụ về cách niềm tin và bảo mật được tích hợp vào cốt lõi của hệ sinh thái gói để giúp bạn cảm thấy tự tin khi sử dụng nó.

00:06:23.000 --> 00:06:28.000
Trình cắm lệnh là một cách tuyệt vời để cải thiện quy trình làm việc cho các nhà phát triển Swift.

00:06:28.000 --> 00:06:32.000
Chúng là bước đầu tiên trong việc cung cấp các công cụ xây dựng có thể mở rộng và an toàn hơn.

00:06:32.000 --> 00:06:38.000
Các trình cắm lệnh có thể được sử dụng để tạo tài liệu, định dạng lại mã nguồn và hơn thế nữa.

00:06:38.000 --> 00:06:44.000
Thay vì viết tự động hóa của bạn trong một tập lệnh shell và phải duy trì quy trình làm việc riêng biệt, bạn có thể sử dụng Swift!

00:06:44.000 --> 00:06:46.000
Hãy nghĩ đến các nhà định dạng mã nguồn mở và linters.

00:06:46.000 --> 00:06:53.000
Bây giờ, tất cả các công cụ mã nguồn mở đó đều có sẵn trong Xcode và Swift Package Manager.

00:06:53.000 --> 00:06:58.000
Các trình cắm lệnh là chất kết dính giữa các công cụ nguồn mở và Trình quản lý gói Swift.

00:06:58.000 --> 00:07:06.000
Dự án Swift đang áp dụng các công cụ dành cho nhà phát triển trong cộng đồng nguồn mở để cung cấp sự tích hợp liền mạch với quy trình làm việc tự động của bạn.

00:07:06.000 --> 00:07:10.000
docC là công cụ tuyệt vời để tích hợp tài liệu vào mã nguồn của bạn.

00:07:10.000 --> 00:07:14.000
Năm nay, nó thậm chí còn tốt hơn với sự hỗ trợ của Objective-C và C.

00:07:14.000 --> 00:07:19.000
Chúng ta hãy xem những gì cần thiết để tạo một plug-in với docC.

00:07:19.000 --> 00:07:20.000
Các trình cắm chỉ là mã Swift đơn giản.

00:07:20.000 --> 00:07:25.000
Bạn có thể xác định một plug-in bằng cách tạo một cấu trúc phù hợp với giao thức CommandPlugin.

00:07:25.000 --> 00:07:30.000
Và sau đó bạn chỉ cần thêm một chức năng cho trình cắm của bạn biết bạn muốn gọi công cụ nào.

00:07:30.000 --> 00:07:34.000
Trong hàm này là nơi chúng tôi muốn gọi docC.

00:07:34.000 --> 00:07:40.000
Khi bạn đã xác định trình cắm của mình, nó sẽ có sẵn thông qua giao diện dòng lệnh Swift PM và Xcode dưới dạng mục nhập menu.

00:07:40.000 --> 00:07:48.000
Bây giờ, chúng tôi có thể yêu cầu Swift PM tạo tài liệu và nó biết chuyển hành động này đến tệp thực thi docC.

00:07:48.000 --> 00:07:50.000
Nó không dừng lại ở đó.

00:07:50.000 --> 00:07:54.000
Có một trình cắm thứ hai được gọi là trình cắm công cụ xây dựng.

00:07:54.000 --> 00:07:59.000
Các trình cắm này là các gói cho phép bạn tiêm các bước bổ sung trong quá trình xây dựng.

00:07:59.000 --> 00:08:05.000
Khi bạn triển khai một trình cắm công cụ xây dựng, điều đó sẽ tạo ra một lệnh cho hệ thống xây dựng để thực thi trong một hộp cát.

00:08:05.000 --> 00:08:13.000
Chúng khác với các trình cắm lệnh mà bạn thực thi trực tiếp bất cứ lúc nào và có thể được cấp quyền rõ ràng để thay đổi các tệp trong gói của bạn.

00:08:13.000 --> 00:08:20.000
Các trình cắm công cụ xây dựng có thể được sử dụng để tạo mã nguồn hoặc xử lý tùy chỉnh cho các loại tệp đặc biệt.

00:08:20.000 --> 00:08:23.000
Với các trình cắm công cụ xây dựng, đây sẽ là bố cục gói.

00:08:23.000 --> 00:08:29.000
Trong ví dụ này, plugin.Swift là tập lệnh Swift triển khai mục tiêu trình cắm gói.

00:08:29.000 --> 00:08:33.000
Trình cắm được coi là một tệp thực thi Swift.

00:08:33.000 --> 00:08:38.000
Và bạn viết trình cắm giống như cách bạn viết bất kỳ tệp thực thi Swift nào.

00:08:38.000 --> 00:08:48.000
Bạn có thể triển khai trình cắm của mình bằng cách xác định một tập hợp các lệnh xây dựng cho hệ thống xây dựng biết lệnh thực thi nào sẽ chạy và kết quả là kết quả là đầu ra nào.

00:08:48.000 --> 00:08:53.000
Các trình cắm gói là các giải pháp an toàn cung cấp khả năng mở rộng trong các gói của bạn.

00:08:53.000 --> 00:09:03.000
Bạn có thể tìm hiểu thêm về cách các trình cắm hoạt động và cách triển khai trình cắm của riêng bạn, trong hai phiên, "Gặp gỡ các plugin Gói Swift" và "Tạo các plugin Gói Swift".

00:09:03.000 --> 00:09:08.000
Khi bạn mở rộng việc sử dụng các gói của mình, bạn có thể đã gặp phải va chạm mô-đun.

00:09:08.000 --> 00:09:12.000
Đó là khi hai gói riêng biệt xác định một mô-đun có cùng tên.

00:09:12.000 --> 00:09:19.000
Để giải quyết tình huống này, Swift 5.7 giới thiệu định hướng mô-đun.

00:09:19.000 --> 00:09:26.000
Định hướng mô-đun là một tính năng cho phép bạn đổi tên các mô-đun từ bên ngoài các gói xác định chúng.

00:09:26.000 --> 00:09:33.000
Ở đây trong ứng dụng Stunning của chúng tôi, chúng tôi đang đưa vào hai gói xác định mô-đun Ghi nhật ký, vì vậy chúng xung đột.

00:09:33.000 --> 00:09:42.000
Để khắc phục điều này cho ứng dụng Stunning của chúng tôi, bạn chỉ cần thêm từ khóa moduleAliases vào phần phụ thuộc trong bản kê khai gói của bạn.

00:09:42.000 --> 00:09:49.000
Bằng cách đó bạn có thể sử dụng hai tên khác nhau để phân biệt giữa các mô-đun trước đây có cùng tên.

00:09:49.000 --> 00:09:53.000
Swift 5.7 mang đến một số cải tiến hiệu suất tuyệt vời.

00:09:53.000 --> 00:09:56.000
Hãy bắt đầu bằng cách xem xét thời gian xây dựng.

00:09:56.000 --> 00:10:04.000
Năm ngoái, chúng tôi đã nói với bạn về cách chúng tôi đã viết lại Trình điều khiển Swift - chương trình điều phối việc biên dịch mã nguồn Swift trong Swift.

00:10:04.000 --> 00:10:09.000
Kiến trúc lại năm ngoái đã mở ra một số thay đổi thực sự quan trọng giúp tăng tốc độ xây dựng đáng kể.

00:10:09.000 --> 00:10:16.000
Trình điều khiển bây giờ có thể được sử dụng như một khuôn khổ trực tiếp bên trong hệ thống xây dựng Xcode thay vì như một tệp thực thi riêng biệt.

00:10:16.000 --> 00:10:22.000
Điều này cho phép nó phối hợp các bản dựng chặt chẽ hơn với hệ thống xây dựng để cho phép những thứ như song song hóa.

00:10:22.000 --> 00:10:31.000
Nếu bạn là người yêu thích âm thanh của các bản dựng nhanh, bạn có thể biết thêm chi tiết trong phiên "Demystify song song hóa trong các bản dựng Xcode".

00:10:31.000 --> 00:10:39.000
Để cho bạn thấy các bản dựng nhanh hơn bao nhiêu, hãy xem một số ví dụ về việc mất bao lâu để xây dựng một số công cụ chúng tôi thường sử dụng được viết bằng Swift.

00:10:39.000 --> 00:10:46.000
Trên iMac 10 lõi, những cải tiến đã dao động từ 5 phần trăm cho đến 25 phần trăm.

00:10:46.000 --> 00:10:49.000
Tiếp theo, có những cải tiến về tốc độ kiểm tra kiểu.

00:10:49.000 --> 00:11:00.000
Năm nay, chúng tôi đã cải thiện hiệu suất kiểm tra kiểu bằng cách triển khai lại một phần quan trọng của hệ thống generics - phần tính toán chữ ký hàm từ những thứ như giao thức và mệnh đề "ở đâu".

00:11:00.000 --> 00:11:07.000
Trong triển khai cũ, việc sử dụng thời gian và bộ nhớ có thể mở rộng theo cấp số nhân khi có nhiều giao thức tham gia hơn.

00:11:07.000 --> 00:11:16.000
Ví dụ, ở đây, chúng tôi có một tập hợp các giao thức phức tạp xác định một hệ tọa độ, với rất nhiều yêu cầu chung trên nhiều loại liên quan.

00:11:16.000 --> 00:11:20.000
Trước đây, việc này sẽ mất 17 giây để nhập mã này.

00:11:20.000 --> 00:11:28.000
Nhưng bây giờ, trong Swift 5.7, ví dụ này có thể kiểm tra kiểu nhanh hơn đáng kể, trong vòng chưa đầy một giây.

00:11:28.000 --> 00:11:32.000
Chúng tôi cũng có một số cải tiến thời gian chạy ấn tượng không kém.

00:11:32.000 --> 00:11:39.000
Trước Swift 5.7, chúng tôi đã thấy việc kiểm tra giao thức khi khởi động ứng dụng mất đến bốn giây trên iOS.

00:11:39.000 --> 00:11:46.000
Các giao thức cần được tính toán mỗi khi chúng tôi khởi chạy ứng dụng, dẫn đến thời gian khởi chạy càng dài hơn khi bạn thêm nhiều giao thức.

00:11:46.000 --> 00:11:48.000
Bây giờ, chúng đã được lưu vào bộ nhớ cache.

00:11:48.000 --> 00:11:58.000
Tùy thuộc vào cách một ứng dụng được viết và số lượng giao thức được sử dụng, điều này có thể có nghĩa là thời gian khởi chạy bị cắt giảm một nửa trong một số ứng dụng khi chạy trên iOS 16.

00:11:58.000 --> 00:12:07.000
Phiên "Cải thiện kích thước ứng dụng và hiệu suất thời gian chạy" sẽ đi sâu hơn vào cách bạn có thể tận dụng những cải tiến này trong ứng dụng của riêng mình.

00:12:07.000 --> 00:12:12.000
Bây giờ, đã đến lúc cho một cái gì đó mà tôi chắc chắn rằng rất nhiều bạn đã háo hức muốn nghe về nó.

00:12:12.000 --> 00:12:19.000
Năm ngoái, chúng tôi đã giới thiệu mô hình đồng thời mới, tập hợp các diễn viên và không đồng bộ/chờ đợi.

00:12:19.000 --> 00:12:25.000
Điều này có tác động biến đổi đối với kiến trúc đồng thời của các ứng dụng của bạn.

00:12:25.000 --> 00:12:31.000
Async/await và actors an toàn và dễ dàng hơn so với gọi lại và quản lý hàng đợi thủ công.

00:12:31.000 --> 00:12:37.000
Năm nay, chúng tôi tiếp tục bổ sung mô hình với dữ liệu an toàn cuộc đua đi đầu.

00:12:37.000 --> 00:12:48.000
Bởi vì đồng thời là một cải tiến cơ bản và quan trọng đối với cơ sở mã ứng dụng của bạn, chúng tôi đã có thể triển khai lại những thay đổi này cho đến iOS 13 và macOS Catalina.

00:12:48.000 --> 00:12:55.000
Để triển khai cho các hệ điều hành cũ hơn, ứng dụng của bạn gói một bản sao của thời gian chạy đồng thời Swift 5.5 cho các hệ điều hành cũ hơn.

00:12:55.000 --> 00:13:01.000
Điều này tương tự như triển khai lại Swift cho các hệ điều hành trước sự ổn định của ABI.

00:13:01.000 --> 00:13:05.000
Tiếp theo, chúng tôi đã đưa mô hình này theo những hướng mới.

00:13:05.000 --> 00:13:08.000
Chúng tôi đã giới thiệu các tính năng ngôn ngữ và các gói hỗ trợ.

00:13:08.000 --> 00:13:12.000
Đầu tiên, hãy nói về việc tránh chủng tộc dữ liệu.

00:13:12.000 --> 00:13:20.000
Trước khi tôi nhảy vào đó, có lẽ tôi nên lùi lại một bước và nói rằng một trong những tính năng thực sự quan trọng của Swift, là an toàn bộ nhớ theo mặc định.

00:13:20.000 --> 00:13:27.000
Người dùng Swift không thể làm mọi thứ với hành vi không thể đoán trước, như đọc một giá trị trong khi bạn đang sửa đổi nó.

00:13:27.000 --> 00:13:33.000
Trong ví dụ này, chúng tôi đang loại bỏ tất cả các số trong một mảng khớp với số lượng của cùng một mảng.

00:13:33.000 --> 00:13:38.000
Ban đầu, số lượng của mảng là 3, vì vậy chúng tôi sẽ xóa số 3 khỏi mảng.

00:13:38.000 --> 00:13:41.000
Nhưng một khi chúng ta đã làm điều đó, số lượng sẽ là 2.

00:13:41.000 --> 00:13:46.000
Chúng ta loại bỏ số 3 và số 2 khỏi mảng, hay chỉ số 3?

00:13:46.000 --> 00:13:48.000
Câu trả lời là không.

00:13:48.000 --> 00:13:55.000
Swift sẽ ngăn bạn làm điều này vì không an toàn để truy cập số lượng của mảng trong khi bạn đang sửa đổi nó.

00:13:55.000 --> 00:13:58.000
Mục tiêu của chúng tôi là làm điều gì đó tương tự để đảm bảo an toàn cho sợi chỉ.

00:13:58.000 --> 00:14:03.000
Chúng tôi hình dung ra một ngôn ngữ loại bỏ các cuộc đua dữ liệu cấp thấp theo mặc định.

00:14:03.000 --> 00:14:09.000
Nói cách khác, chúng tôi muốn ngăn chặn các lỗi đồng thời có thể gây ra hành vi không thể đoán trước.

00:14:09.000 --> 00:14:10.000
Đây là một ví dụ khác.

00:14:10.000 --> 00:14:20.000
Sử dụng mảng của cùng một số, chúng tôi tạo một tác vụ nền nối thêm 0 vào mảng và sau đó chúng tôi xóa phần tử cuối cùng của mảng.

00:14:20.000 --> 00:14:26.000
Nhưng chờ đã, việc xóa phần tử cuối cùng xảy ra trước hay sau khi chúng ta nối thêm 0?

00:14:26.000 --> 00:14:29.000
Câu trả lời, một lần nữa, là không.

00:14:29.000 --> 00:14:38.000
Swift sẽ chặn bạn làm điều này vì không an toàn khi sửa đổi mảng từ tác vụ nền mà không đồng bộ hóa quyền truy cập với một cái gì đó giống như một diễn viên.

00:14:38.000 --> 00:14:42.000
Các diễn viên là bước quan trọng đầu tiên hướng tới việc loại bỏ các cuộc đua dữ liệu.

00:14:42.000 --> 00:14:49.000
Năm nay chúng tôi đã tinh chỉnh mô hình đồng thời để thúc đẩy chúng tôi tiến xa hơn nữa đến mục tiêu cuối cùng.

00:14:49.000 --> 00:14:56.000
Bạn có thể nghĩ về mỗi diễn viên như hòn đảo riêng của nó, bị cô lập với mọi thứ khác trong biển đồng thời.

00:14:56.000 --> 00:15:03.000
Nhưng điều gì sẽ xảy ra khi các chủ đề khác nhau muốn truy vấn thông tin được lưu trữ bởi mỗi tác nhân bị cô lập?

00:15:03.000 --> 00:15:10.000
Phép ẩn dụ này sẽ được khám phá sâu trong phiên "Loại bỏ các cuộc đua dữ liệu bằng cách sử dụng Swift Concurrency."

00:15:10.000 --> 00:15:16.000
Từ an toàn bộ nhớ đến an toàn luồng theo mặc định; đó là mục tiêu của Swift 6.

00:15:16.000 --> 00:15:23.000
Để đưa chúng tôi đến đó, lần đầu tiên chúng tôi đã cải thiện mô hình đồng thời của năm ngoái với các tính năng ngôn ngữ mới mà tôi vừa đề cập.

00:15:23.000 --> 00:15:30.000
Điều thứ hai tôi chưa đề cập đến là các kiểm tra an toàn chọn tham gia mới để xác định các cuộc đua dữ liệu tiềm năng.

00:15:30.000 --> 00:15:36.000
Bạn có thể thử nghiệm kiểm tra đồng thời chặt chẽ hơn bằng cách bật nó trong cài đặt xây dựng của bạn.

00:15:36.000 --> 00:15:38.000
Hãy cùng xem lại các diễn viên.

00:15:38.000 --> 00:15:44.000
Chúng ta có thể đưa khái niệm về sự cô lập diễn viên này và tiến xa hơn với các diễn viên phân tán.

00:15:44.000 --> 00:15:49.000
Các tác nhân phân tán đặt những hòn đảo đó trên các máy khác nhau với một mạng lưới giữa chúng.

00:15:49.000 --> 00:15:54.000
Tính năng ngôn ngữ mới này giúp việc phát triển các hệ thống phân tán đơn giản hơn nhiều.

00:15:54.000 --> 00:15:59.000
Giả sử bạn muốn tạo một ứng dụng trò chơi; bây giờ bạn có thể dễ dàng viết phần cuối bằng Swift.

00:15:59.000 --> 00:16:04.000
Ở đây, diễn viên phân tán giống như một diễn viên nhưng nó có thể ở trên một cỗ máy khác.

00:16:04.000 --> 00:16:11.000
Trong ví dụ này, chúng tôi đang xem xét trình phát máy tính sẽ duy trì trạng thái trong trò chơi với người dùng.

00:16:11.000 --> 00:16:19.000
Từ khóa phân tán cũng có thể được thêm vào một hàm mà chúng tôi mong đợi sẽ cần được gọi trên một diễn viên có thể ở trên máy từ xa.

00:16:19.000 --> 00:16:22.000
Hãy thêm một hàm khác gọi là endOfRound.

00:16:22.000 --> 00:16:26.000
Nó sẽ lặp qua những người chơi và gọi makeMove trên mỗi người.

00:16:26.000 --> 00:16:33.000
Một số người chơi này có thể là người địa phương hoặc từ xa, nhưng chúng tôi có lợi ích là không cần phải quan tâm đến cái nào.

00:16:33.000 --> 00:16:40.000
Sự khác biệt duy nhất so với cuộc gọi diễn viên thông thường là cuộc gọi diễn viên phân tán có khả năng thất bại do lỗi mạng.

00:16:40.000 --> 00:16:44.000
Trong trường hợp mạng bị lỗi, phương thức diễn viên sẽ gây ra lỗi.

00:16:44.000 --> 00:16:52.000
Vì vậy, bạn cần thêm từ khóa try cũng như từ khóa await thông thường cần thiết khi bạn gọi một hàm bên ngoài diễn viên.

00:16:52.000 --> 00:17:02.000
Dựa trên các nguyên thủy ngôn ngữ cốt lõi này, chúng tôi cũng đã xây dựng một gói Diễn viên phân tán mã nguồn mở tập trung vào việc xây dựng các hệ thống phân tán nhóm, phía máy chủ trong Swift.

00:17:02.000 --> 00:17:11.000
Gói này bao gồm một lớp mạng tích hợp sử dụng SwiftNIO và triển khai giao thức đồng thuận SWIM để quản lý trạng thái trên toàn cụm.

00:17:11.000 --> 00:17:19.000
Phiên "Gặp gỡ các diễn viên phân tán trong Swift" sẽ đi vào chi tiết hơn về cách xây dựng các hệ thống phân tán với các tính năng mới này.

00:17:19.000 --> 00:17:32.000
Chúng tôi cũng đã ra mắt một bộ thuật toán nguồn mở mới để cung cấp các giải pháp dễ dàng cho các hoạt động phổ biến khi xử lý AsyncSequence, được phát hành với Swift 5.5.

00:17:32.000 --> 00:17:40.000
Việc phát hành các API này dưới dạng một gói mang lại cho các nhà phát triển sự linh hoạt trong việc triển khai trên các nền tảng và phiên bản hệ điều hành.

00:17:40.000 --> 00:17:47.000
Có một số cách để kết hợp nhiều chuỗi không đồng bộ và nhóm các giá trị thành các bộ sưu tập.

00:17:47.000 --> 00:17:51.000
Đây chỉ là một số thuật toán được bao gồm trong gói.

00:17:51.000 --> 00:17:58.000
Kiểm tra cuộc nói chuyện "Gặp gỡ các thuật toán không đồng bộ Swift" để xem cách bạn có thể sử dụng API mạnh mẽ mới này.

00:17:58.000 --> 00:18:02.000
Nhưng có một khía cạnh khác của đồng thời, đó là hiệu suất.

00:18:02.000 --> 00:18:08.000
Năm nay, với việc ưu tiên diễn viên, các diễn viên hiện thực hiện công việc ưu tiên cao nhất trước tiên.

00:18:08.000 --> 00:18:20.000
Và tiếp tục tích hợp sâu của chúng tôi với bộ lập lịch hệ điều hành, mô hình có tích hợp ngăn chặn đảo ngược ưu tiên, vì vậy công việc ít quan trọng hơn không thể chặn công việc ưu tiên cao hơn.

00:18:20.000 --> 00:18:26.000
Trong lịch sử, thật khó để hình dung tác động hiệu suất của sự đồng thời trong ứng dụng của bạn.

00:18:26.000 --> 00:18:31.000
Nhưng bây giờ, chúng tôi có một công cụ mới tuyệt vời để làm chính xác điều đó.

00:18:31.000 --> 00:18:36.000
Chế độ xem Swift Concurrency mới trong Instruments có thể giúp bạn điều tra các vấn đề về hiệu suất.

00:18:36.000 --> 00:18:46.000
Các công cụ Swift Tasks và Swift Actors cung cấp một bộ công cụ đầy đủ để giúp bạn hình dung và tối ưu hóa mã đồng thời của mình.

00:18:46.000 --> 00:18:58.000
Ở cấp độ cao nhất, Swift Tasks Instrument cung cấp số liệu thống kê hữu ích, bao gồm số lượng nhiệm vụ chạy đồng thời và tổng số nhiệm vụ đã được tạo cho đến thời điểm đó.

00:18:58.000 --> 00:19:03.000
Ở nửa dưới của cửa sổ này, bạn có thể thấy cái được gọi là Rừng Nhiệm vụ.

00:19:03.000 --> 00:19:11.000
Nó cung cấp một biểu diễn đồ họa về mối quan hệ cha-con giữa các tác vụ trong mã đồng thời có cấu trúc.

00:19:11.000 --> 00:19:16.000
Đây chỉ là một trong những góc nhìn chi tiết cho Swift Actor Instrument.

00:19:16.000 --> 00:19:24.000
Để tìm hiểu cách sử dụng công cụ mới thú vị này, bạn sẽ muốn chuyển sang bài nói chuyện "Trực quan hóa và tối ưu hóa đồng thời Swift."

00:19:24.000 --> 00:19:26.000
Và đừng quên thử những gói hàng mới đó.

00:19:26.000 --> 00:19:29.000
Đừng ngại cho chúng tôi biết nó đang diễn ra như thế nào trên các diễn đàn.

00:19:29.000 --> 00:19:36.000
Bây giờ, tôi sẽ giao nó cho Becca để nói về nhiều cải tiến đối với khả năng sử dụng ngôn ngữ Swift.

00:19:36.000 --> 00:19:42.000
Ngôn ngữ là công cụ, và có một điều buồn cười về các công cụ - chúng thực sự có thể ảnh hưởng đến những thứ bạn xây dựng với chúng.

00:19:42.000 --> 00:19:48.000
Khi tất cả những gì bạn có là một cái búa, bạn sẽ xây dựng mọi thứ bằng đinh thay vì ốc vít.

00:19:48.000 --> 00:19:58.000
Và ngay cả khi bạn có một bộ công cụ đầy đủ, nếu búa của bạn có tay cầm lớn, chắc chắn trong khi tuốc nơ vít của bạn dẻo và khó cầm, bạn vẫn có thể nghiêng về phía đinh.

00:19:58.000 --> 00:19:59.000
Một ngôn ngữ cũng giống như vậy.

00:19:59.000 --> 00:20:05.000
Nếu Swift có một công cụ tốt để thể hiện điều gì đó, mọi người sẽ sử dụng nó thường xuyên hơn.

00:20:05.000 --> 00:20:11.000
Và năm nay, các công cụ của Swift để thể hiện những gì bạn muốn mã của mình làm đã được cải thiện theo nhiều cách.

00:20:11.000 --> 00:20:15.000
Một số thay đổi này là những tiện ích đơn giản cho những việc bạn thường làm.

00:20:15.000 --> 00:20:22.000
Ví dụ, nó thực sự phổ biến trong Swift để sử dụng nếu let có cùng tên ở cả hai bên của dấu bằng nhau.

00:20:22.000 --> 00:20:28.000
Rốt cuộc, có lẽ không có cái tên nào tốt hơn cho giá trị chưa được gói so với cái tên bạn đã đặt cho cái tùy chọn.

00:20:28.000 --> 00:20:33.000
Nhưng khi cái tên thực sự dài, sự lặp lại đó bắt đầu trở nên cồng kềnh.

00:20:33.000 --> 00:20:39.000
Bạn có thể bị cám dỗ để viết tắt tên, nhưng sau đó mã của bạn trở nên khó hiểu.

00:20:39.000 --> 00:20:45.000
Và nếu sau này bạn đổi tên biến tùy chọn, chữ viết tắt có thể không đồng bộ.

00:20:45.000 --> 00:20:49.000
Swift 5.7 giới thiệu một cách viết tắt mới cho mô hình phổ biến này.

00:20:49.000 --> 00:20:55.000
Nếu bạn đang mở gói một tùy chọn và muốn giá trị chưa gói có cùng tên, chỉ cần thả phía bên tay phải.

00:20:55.000 --> 00:20:58.000
Swift sẽ cho rằng nó giống nhau.

00:20:58.000 --> 00:21:04.000
Và tất nhiên, điều này cũng hoạt động với người bảo vệ, và thậm chí trong khi, cho vấn đề đó.

00:21:04.000 --> 00:21:09.000
Chúng tôi cũng đã xem xét những nơi mà một tính năng đột nhiên ngừng hoạt động khi bạn thực hiện một thay đổi nhỏ.

00:21:09.000 --> 00:21:16.000
Ví dụ, Swift luôn có thể tìm ra loại cuộc gọi nào sẽ quay trở lại dựa trên mã được viết bên trong đóng một câu lệnh.

00:21:16.000 --> 00:21:30.000
Trong cuộc gọi compactMap này, việc đóng trả về giá trị của parseLine và hàm parseLine trả về MailmapEntry, vì vậy Swift có thể tìm ra rằng các mục nhập phải là một mảng của MailmapEntry.

00:21:30.000 --> 00:21:35.000
Điều này hiện hoạt động cho các đóng cửa phức tạp hơn có nhiều câu lệnh hoặc tính năng luồng điều khiển.

00:21:35.000 --> 00:21:43.000
Vì vậy, bạn có thể sử dụng do-catch, hoặc if...else, hoặc chỉ cần thêm một cuộc gọi in, mà không cần phải chỉ định thủ công loại kết quả của việc đóng cửa.

00:21:43.000 --> 00:21:49.000
Một điều khác mà chúng tôi đã xem xét là những lá cờ nguy hiểm không thực sự gắn cờ bất kỳ mối nguy hiểm thực sự nào.

00:21:49.000 --> 00:21:52.000
Swift rất quan tâm đến sự an toàn về loại và bộ nhớ.

00:21:52.000 --> 00:22:01.000
Để giữ cho bạn không mắc lỗi, nó không bao giờ tự động chuyển đổi giữa các con trỏ với các loại con trỏ khác nhau, cũng như giữa con trỏ thô và con trỏ đã nhập.

00:22:01.000 --> 00:22:05.000
Điều này rất khác với C, cho phép chuyển đổi nhất định.

00:22:05.000 --> 00:22:15.000
Ví dụ: bạn có thể thay đổi độ ký của con trỏ hoặc truyền bất kỳ con trỏ nào sang ngôi sao ký tự để truy cập nó dưới dạng byte, mà không vi phạm bất kỳ quy tắc con trỏ nào của C.

00:22:15.000 --> 00:22:22.000
Nhưng đôi khi những khác biệt trong hành vi con trỏ này sẽ gây ra vấn đề khi API C được nhập vào Swift.

00:22:22.000 --> 00:22:30.000
Nhà phát triển ban đầu có thể đã thiết kế các API của họ với sự không phù hợp nhỏ được xử lý bởi các chuyển đổi tự động trong C nhưng là các lỗi trong Swift.

00:22:30.000 --> 00:22:39.000
Trong Swift, việc truy cập một con trỏ thuộc một loại như thể nó là một loại khác là rất nguy hiểm, vì vậy bạn phải mô tả những gì bạn đang làm rất rõ ràng.

00:22:39.000 --> 00:22:47.000
Nhưng tất cả đều vô nghĩa nếu chúng ta chuyển con trỏ trực tiếp đến C, bởi vì trong C, sự không khớp của con trỏ đó là hoàn toàn hợp pháp!

00:22:47.000 --> 00:22:52.000
Vì vậy, trong trường hợp này, chúng tôi đã đối xử với một cái gì đó thực sự đơn giản như thể nó nguy hiểm.

00:22:52.000 --> 00:23:00.000
Điều này quan trọng bởi vì, nhiều như Swift coi trọng loại an toàn, nó cũng coi trọng việc dễ dàng truy cập vào mã C-family.

00:23:00.000 --> 00:23:11.000
Đó là lý do tại sao C và Objective-C interop rất phong phú và liền mạch, và đó là lý do tại sao dự án Swift thành lập nhóm làm việc C++ mà Angela đã đề cập trước đó để bắt đầu xây dựng C++ interop có khả năng tương đương.

00:23:11.000 --> 00:23:16.000
Chúng tôi không muốn việc sử dụng các hàm C như thế này gây đau đớn một cách không cần thiết.

00:23:16.000 --> 00:23:21.000
Vì vậy, Swift hiện có một bộ quy tắc riêng biệt cho các cuộc gọi đến các hàm và phương thức đã nhập.

00:23:21.000 --> 00:23:26.000
Nó cho phép chuyển đổi con trỏ sẽ hợp pháp trong C mặc dù chúng thường không có trong Swift.

00:23:26.000 --> 00:23:31.000
Bằng cách đó, mã Swift của bạn có thể sử dụng các API này một cách liền mạch.

00:23:31.000 --> 00:23:35.000
Cho đến nay chúng ta đã nói về những cải tiến nhỏ đối với các công cụ bạn đã có.

00:23:35.000 --> 00:23:41.000
Nhưng năm nay, Swift cũng có một công cụ hoàn toàn mới để trích xuất thông tin từ các chuỗi.

00:23:41.000 --> 00:23:45.000
Đây là một hàm phân tích cú pháp một số thông tin ra khỏi một chuỗi.

00:23:45.000 --> 00:23:48.000
Loại nhiệm vụ này luôn là một chút thách thức trong Swift.

00:23:48.000 --> 00:23:54.000
Cuối cùng bạn sẽ tìm kiếm, tách và cắt đi cắt lại cho đến khi bạn có được thứ bạn muốn.

00:23:54.000 --> 00:24:03.000
Khi mọi người nhận thấy điều này, họ có xu hướng tập trung vào những điều nhỏ nhặt, chẳng hạn như việc thao tác các chỉ mục chuỗi có thể dài dòng như thế nào, nhưng tôi nghĩ điều đó hơi thiếu bức tranh lớn hơn.

00:24:03.000 --> 00:24:15.000
Bởi vì ngay cả khi chúng tôi thay đổi cú pháp này, nó không giúp bạn trả lời câu hỏi cơ bản mà bạn đang hỏi khi bạn nhìn vào mã này - biến dòng được truyền vào nó thực sự trông như thế nào?

00:24:15.000 --> 00:24:18.000
Nó đang cố gắng tháo rời loại dây nào?

00:24:18.000 --> 00:24:29.000
Nếu bạn nhìn chằm chằm vào nó đủ lâu, bạn có thể nhận ra rằng nó đang phân tích cú pháp một phiên bản đơn giản của bản đồ thư - một tệp bạn đặt trong kho lưu trữ git để sửa tên nhà phát triển trong các cam kết cũ.

00:24:29.000 --> 00:24:35.000
Nhưng việc trích xuất thông tin đó bằng cách tìm kiếm và cắt lát có liên quan đến mức khó có thể tìm ra điều đó.

00:24:35.000 --> 00:24:42.000
Bạn bị lạc trong cách cắt chuỗi đến nỗi bạn mất dấu chuỗi đó là gì.

00:24:42.000 --> 00:24:48.000
Vấn đề không phải là hai biểu thức này; vấn đề là toàn bộ sự việc.

00:24:48.000 --> 00:24:52.000
Chúng ta cần xé bỏ tất cả những thứ này và thay thế nó bằng thứ gì đó tốt hơn.

00:24:52.000 --> 00:25:01.000
Chúng tôi cần một cách tiếp cận khác; một cách mà loại mã của bạn vẽ một bức tranh về chuỗi bạn muốn khớp và ngôn ngữ tìm ra cách thực hiện.

00:25:01.000 --> 00:25:05.000
Một cách tiếp cận khai báo, không phải là một cách bắt buộc.

00:25:05.000 --> 00:25:10.000
Trong Swift 5.7, bây giờ bạn có thể làm điều đó bằng cách viết một regex.

00:25:10.000 --> 00:25:14.000
Regex là một cách để mô tả một mẫu trong một chuỗi.

00:25:14.000 --> 00:25:21.000
Trong hơn 50 năm, các ngôn ngữ và công cụ đã cho phép các nhà phát triển viết regexes theo cú pháp dày đặc, chứa nhiều thông tin.

00:25:21.000 --> 00:25:31.000
Một số bạn đã sử dụng chúng trong thanh tìm Xcode, trong các công cụ dòng lệnh như grep, trong lớp NSRegularExpression của Foundation hoặc trong các ngôn ngữ lập trình khác.

00:25:31.000 --> 00:25:37.000
Cú pháp đó hiện được hỗ trợ bởi các ký tự regex của Swift và nó hoạt động giống như trong bất kỳ công cụ nhà phát triển nào khác.

00:25:37.000 --> 00:25:46.000
Nhưng một số bạn chưa từng sử dụng regexes trước đây và có lẽ bạn sẽ nói, "Đó là mã thật hay một con mèo đã đi ngang qua bàn phím của cô ấy?"

00:25:46.000 --> 00:25:47.000
Và tôi không trách bạn.

00:25:47.000 --> 00:25:53.000
Các ký tự Regex được viết bằng các ký hiệu và ghi nhớ mà bạn phải ghi nhớ để đọc chúng.

00:25:53.000 --> 00:26:02.000
Đối với một người biết ngôn ngữ, ngay cả những phần khó hiểu nhất của regex này, như phần phù hợp với tên của nhà phát triển chỉ là sự kết hợp của một số quy tắc kết hợp đơn giản.

00:26:02.000 --> 00:26:06.000
Nhưng đó là rất nhiều hành vi để nhồi nhét thành 11 ký tự.

00:26:06.000 --> 00:26:13.000
Các ký tự Regex nhỏ gọn đến mức ngay cả các nhà phát triển có kinh nghiệm đôi khi cũng cần một phút để hiểu một ký tự phức tạp.

00:26:13.000 --> 00:26:18.000
Nhưng điều gì sẽ xảy ra nếu bạn có thể viết cùng một loại quy tắc phù hợp, chỉ bằng từ ngữ thay vì ký hiệu?

00:26:18.000 --> 00:26:21.000
Điều đó có vẻ như nó sẽ dễ hiểu hơn.

00:26:21.000 --> 00:26:26.000
Trên thực tế, hãy kết hợp tất cả lại với nhau và bạn sẽ nhận được thứ gì đó trông rất giống SwiftUI.

00:26:26.000 --> 00:26:30.000
Đó sẽ là một sự thay thế tuyệt vời cho một regex theo nghĩa đen, phải không?

00:26:30.000 --> 00:26:33.000
Vì vậy, đó là một điều tốt Swift ủng hộ điều đó!

00:26:33.000 --> 00:26:42.000
Thư viện RegexBuilder cung cấp một ngôn ngữ kiểu SwiftUI hoàn toàn mới cho các regexes dễ sử dụng hơn và dễ đọc hơn cú pháp truyền thống.

00:26:42.000 --> 00:26:52.000
Nó có thể làm những điều tương tự mà một nghĩa đen regex có thể, nhưng nó mô tả hành vi của nó bằng những từ mà bạn có thể hiểu hoặc tra cứu, thay vì các ký hiệu và chữ viết tắt bạn phải ghi nhớ.

00:26:52.000 --> 00:26:57.000
Trình tạo Regex rất tuyệt vời cho người mới bắt đầu, nhưng đây không phải là tính năng chỉ dành cho người mới bắt đầu.

00:26:57.000 --> 00:27:01.000
Nó có những khả năng mạnh mẽ vượt xa những gì một regex literal có thể làm.

00:27:01.000 --> 00:27:10.000
Để bắt đầu, bạn có thể biến regex thành thành phần regex có thể tái sử dụng, giống như bạn có thể biến hệ thống phân cấp chế độ xem SwiftUI thành chế độ xem.

00:27:10.000 --> 00:27:17.000
Bạn có thể sử dụng các thành phần này từ các regexe khác được tạo bằng cú pháp trình tạo và thậm chí bạn có thể làm cho chúng đệ quy.

00:27:17.000 --> 00:27:22.000
Các nhà xây dựng Regex cũng hỗ trợ thả một số loại Swift trực tiếp vào regex.

00:27:22.000 --> 00:27:28.000
Ví dụ, các ký tự chuỗi chỉ khớp với văn bản chính xác bên trong chúng - không cần thoát đặc biệt.

00:27:28.000 --> 00:27:32.000
Bạn cũng có thể sử dụng các ký tự regex ở giữa trình tạo regex.

00:27:32.000 --> 00:27:38.000
Vì vậy, bạn có thể đạt được sự cân bằng giữa sự rõ ràng của trình tạo regex và sự đồng nhất của một regex theo nghĩa đen.

00:27:38.000 --> 00:27:48.000
Và các loại khác - như kiểu định dạng ngày Foundation này - có thể tích hợp logic phân tích cú pháp tùy chỉnh với các trình tạo regex và thậm chí chuyển đổi dữ liệu sang loại phong phú hơn trước khi chụp nó.

00:27:48.000 --> 00:27:58.000
Cuối cùng, bất kể bạn sử dụng cú pháp nào, regexes hỗ trợ một loạt các phương pháp kết hợp hữu ích và chụp được nhập mạnh dễ sử dụng.

00:27:58.000 --> 00:28:09.000
Giờ đây, đối với những người mọt sách regex đang vặn vẹo chỗ ngồi của họ, Swift Regex sử dụng công cụ kết hợp mã nguồn mở hoàn toàn mới, với bộ tính năng có thể so sánh với các triển khai regex tiên tiến nhất.

00:28:09.000 --> 00:28:16.000
Cú pháp theo nghĩa đen tương thích với tiêu chuẩn Unicode regex và nó có mức độ chính xác Unicode không phổ biến.

00:28:16.000 --> 00:28:22.000
Ví dụ, dấu chấm khớp với toàn bộ ký tự theo mặc định, không phải Unicode.Scalar hoặc UTF-8 byte.

00:28:22.000 --> 00:28:32.000
Để sử dụng Swift Regex, ứng dụng của bạn sẽ cần phải chạy trên một hệ điều hành với công cụ Swift Regex được tích hợp trong đó, như macOS 13 hoặc iOS 16.

00:28:32.000 --> 00:28:38.000
Swift Regex là toàn bộ ngôn ngữ - tốt, thực sự là hai ngôn ngữ - vì vậy có nhiều điều để nói về nó.

00:28:38.000 --> 00:28:46.000
Hai phiên này - "Gặp gỡ Swift Regex" và "Swift Regex: Beyond The Basics" - sẽ cung cấp cho bạn nhiều chi tiết hơn về việc sử dụng nó.

00:28:46.000 --> 00:28:53.000
Cuối cùng, có một nơi mà chúng tôi đã xem xét toàn diện các công cụ mà chúng tôi có và thực hiện một loạt các thay đổi để cải thiện chúng.

00:28:53.000 --> 00:28:56.000
Đó là trong generics và giao thức.

00:28:56.000 --> 00:29:00.000
Để cho bạn thấy những công cụ này đã được cải thiện như thế nào, tôi sẽ cần một giao thức ví dụ.

00:29:00.000 --> 00:29:05.000
Giả sử bạn đang viết một ứng dụng khách git và bạn phải thể hiện bản đồ thư theo hai cách khác nhau.

00:29:05.000 --> 00:29:11.000
Khi bạn đang hiển thị các cam kết, bạn sử dụng một loại có từ điển để nhanh chóng tra cứu tên.

00:29:11.000 --> 00:29:18.000
Nhưng khi bạn cho phép người dùng chỉnh sửa bản đồ thư, bạn sử dụng một loại có mảng để giữ các mục nhập theo thứ tự ban đầu của chúng.

00:29:18.000 --> 00:29:26.000
Và bạn có một giao thức gọi là Mailmap mà cả hai đều tuân thủ, vì vậy trình phân tích cú pháp mailmap của bạn có thể thêm các mục nhập vào một trong hai loại.

00:29:26.000 --> 00:29:30.000
Nhưng có hai cách mà trình phân tích cú pháp có thể sử dụng giao thức Mailmap.

00:29:30.000 --> 00:29:41.000
Tôi đã viết hai phiên bản khác nhau của hàm addEntries này để minh họa chúng, nhưng thực sự rất khó để giải thích chúng khác nhau như thế nào, bởi vì Swift đang sử dụng cùng một cú pháp cho hai thứ khác nhau.

00:29:41.000 --> 00:29:50.000
Hóa ra từ "Mailmap" có nghĩa là một điều ở đây nhưng nó có nghĩa là một cái gì đó khác biệt tinh tế ở đây.

00:29:50.000 --> 00:30:01.000
Khi bạn đặt tên cho một giao thức trong danh sách kế thừa, danh sách tham số chung, ràng buộc tuân thủ chung hoặc loại kết quả không rõ ràng, nó có nghĩa là "một trường hợp phù hợp với giao thức này."

00:30:01.000 --> 00:30:14.000
Nhưng trong một loại biến, một đối số chung, một ràng buộc cùng loại chung, hoặc một tham số hàm hoặc loại kết quả, nó thực sự có nghĩa là "một hộp chứa một thể hiện phù hợp với giao thức này."

00:30:14.000 --> 00:30:24.000
Sự khác biệt này rất quan trọng vì hộp thường sử dụng nhiều không gian hơn, mất nhiều thời gian hơn để hoạt động và không có tất cả các khả năng của phiên bản bên trong nó.

00:30:24.000 --> 00:30:31.000
Nhưng những nơi bạn đang sử dụng hộp trông giống như những nơi bạn không sử dụng, vì vậy thật khó để tìm hiểu xem bạn có đang sử dụng hộp hay không.

00:30:31.000 --> 00:30:34.000
Swift 5.7 khắc phục sự giám sát này.

00:30:34.000 --> 00:30:41.000
Khi bạn đang sử dụng một trong những hộp này có chứa một loại phù hợp, Swift bây giờ sẽ mong đợi bạn viết bất kỳ từ khóa nào.

00:30:41.000 --> 00:30:53.000
Điều này không bắt buộc trong mã hợp lệ trước Swift 5.7, nhưng nó được khuyến khích và bạn sẽ thấy nó trong các giao diện được tạo và thông báo lỗi, ngay cả khi bạn không viết nó ra một cách rõ ràng.

00:30:53.000 --> 00:30:58.000
Vì vậy, cách ưa thích để viết tất cả những điều đó ở cột bên phải là với bất kỳ từ khóa nào.

00:30:58.000 --> 00:31:03.000
Nếu bạn làm điều đó, bạn sẽ có thể biết khi nào bạn đang sử dụng một trong những hộp này.

00:31:03.000 --> 00:31:10.000
Bây giờ bất kỳ từ khóa nào đánh dấu một trong những tham số trong ví dụ này, việc giải thích sự khác biệt giữa hai hàm này sẽ dễ dàng hơn rất nhiều.

00:31:10.000 --> 00:31:17.000
addEntries1 lấy Mailmap làm loại chung; addEntries2 lấy nó làm bất kỳ loại nào.

00:31:17.000 --> 00:31:23.000
Và nó cũng dễ dàng hơn cho các thông báo lỗi để giải thích những gì đang xảy ra khi bạn gặp một trong những giới hạn của bất kỳ loại nào.

00:31:23.000 --> 00:31:30.000
Ví dụ, hàm mergeMailmaps này cố gắng chuyển bất kỳ Mailmap nào sang tham số Mailmap chung.

00:31:30.000 --> 00:31:37.000
Điều này được sử dụng để tạo ra một lỗi nói rằng Mailmap không thể phù hợp với chính nó, điều này luôn có vẻ nghịch lý.

00:31:37.000 --> 00:31:42.000
Nhưng bây giờ chúng ta đã có khái niệm về bất kỳ loại nào, chúng ta có thể giải thích những gì đang xảy ra rõ ràng hơn.

00:31:42.000 --> 00:31:49.000
Vấn đề là bất kỳ Mailmap nào - hộp chứa mailmap - không phù hợp với giao thức Mailmap.

00:31:49.000 --> 00:31:55.000
Nhưng cái hộp là thứ bạn đang cố gắng vượt qua, và nó không phù hợp với tham số chung.

00:31:55.000 --> 00:32:04.000
Nếu bạn muốn chuyển phiên bản bên trong hộp ở đây, bạn phải bằng cách nào đó mở hộp, lấy bản đồ thư bên trong nó ra và thay vào đó chuyển nó.

00:32:04.000 --> 00:32:10.000
Nhưng thực ra, trong những trường hợp đơn giản như thế này, Swift bây giờ sẽ chỉ làm điều đó cho bạn.

00:32:10.000 --> 00:32:16.000
Mở hộp, lấy ví dụ bên trong nó ra và chuyển nó đến tham số chung.

00:32:16.000 --> 00:32:19.000
Vì vậy, bạn sẽ không thấy thông báo lỗi này nhiều nữa.

00:32:19.000 --> 00:32:23.000
Nhưng có một sự cải tiến thậm chí còn thú vị hơn bất kỳ loại nào so với loại đó.

00:32:23.000 --> 00:32:34.000
Trước đây, một giao thức không thể được sử dụng như một loại nào nếu nó sử dụng loại tự hoặc có các loại liên quan, hoặc thậm chí chỉ phù hợp với một giao thức đã làm, như Equatable.

00:32:34.000 --> 00:32:42.000
Nhưng trong Swift 5.7, lỗi này chỉ - poof - đã biến mất.

00:32:42.000 --> 00:32:47.000
Rất nhiều nhà phát triển đã phải vật lộn với cái này, vì vậy chúng tôi rất vui khi đã sửa nó tại nguồn.

00:32:47.000 --> 00:32:52.000
Bây giờ, điều đó đủ thú vị chỉ cho các giao thức như Mailmap, nhưng điều này thậm chí còn đi xa hơn.

00:32:52.000 --> 00:32:58.000
Bởi vì ngay cả các giao thức rất phức tạp, như Bộ sưu tập, cũng có thể được sử dụng như bất kỳ loại nào.

00:32:58.000 --> 00:33:04.000
Bạn thậm chí có thể chỉ định loại phần tử, nhờ vào một tính năng mới được gọi là "các loại liên kết chính".

00:33:04.000 --> 00:33:08.000
Rất nhiều loại liên quan về cơ bản chỉ là chi tiết triển khai.

00:33:08.000 --> 00:33:16.000
Bạn thường không quan tâm bộ sưu tập sử dụng loại nào cho chỉ mục, trình lặp hoặc trình tự con của nó; bạn chỉ cần sử dụng loại mà nó hỗ trợ.

00:33:16.000 --> 00:33:20.000
Nhưng Yếu tố của nó là một câu chuyện khác.

00:33:20.000 --> 00:33:29.000
Bạn có thể không phải lúc nào cũng quan tâm chính xác loại Element mà một bộ sưu tập sử dụng, nhưng có lẽ bạn sẽ làm gì đó với các yếu tố, vì vậy bạn sẽ cần hạn chế chúng hoặc trả lại chúng hoặc một cái gì đó.

00:33:29.000 --> 00:33:41.000
Khi bạn có một loại liên kết như Element mà gần như mọi người dùng giao thức sẽ quan tâm, bạn có thể đặt tên của nó sau tên của giao thức trong dấu ngoặc nhọn để biến nó thành loại liên kết chính.

00:33:41.000 --> 00:33:52.000
Một khi bạn làm điều đó, bạn có thể hạn chế các loại liên quan chính của giao thức với cú pháp dấu ngoặc nhọn khá nhiều ở bất cứ đâu bạn có thể viết tên của giao thức, bao gồm cả trong bất kỳ Bộ sưu tập nào.

00:33:52.000 --> 00:33:57.000
Bây giờ, một số bạn có thể đang nhìn vào loại này và nói, "Chờ một chút.

00:33:57.000 --> 00:34:03.000
Không phải đã có thứ gọi là AnyCollection, chỉ cần chạy cùng nhau và viết hoa 'bất kỳ' sao? ”

00:34:03.000 --> 00:34:06.000
Và bạn nói đúng, có!

00:34:06.000 --> 00:34:13.000
AnyCollection cũ là một trình bao bọc xóa kiểu - một cấu trúc viết tay phục vụ cùng mục đích với bất kỳ loại nào.

00:34:13.000 --> 00:34:27.000
Sự khác biệt là cấu trúc AnyCollection chỉ là dòng này đến dòng khác của mã mẫu nhàm chán nhất mà bạn từng thấy trong đời; trong khi bất kỳ loại nào cũng là một tính năng ngôn ngữ tích hợp về cơ bản thực hiện điều tương tự - miễn phí!

00:34:27.000 --> 00:34:34.000
Bây giờ, cấu trúc AnyCollection sẽ tồn tại để tương thích ngược và bởi vì nó có một vài tính năng mà bất kỳ loại nào cũng chưa thể sánh được.

00:34:34.000 --> 00:34:44.000
Nhưng nếu bạn có trình bao bọc xóa kiểu của riêng mình trong mã của mình, bạn có thể muốn xem liệu bạn có thể triển khai lại chúng bằng cách sử dụng bất kỳ loại tích hợp nào thay vì các lớp hộp hoặc đóng hay không.

00:34:44.000 --> 00:34:47.000
Hoặc thậm chí có thể chỉ cần thay thế chúng bằng bí danh kiểu.

00:34:47.000 --> 00:34:51.000
Vì vậy Swift đã cải thiện đáng kể bất kỳ loại nào.

00:34:51.000 --> 00:34:55.000
Nó được giới thiệu bất kỳ từ khóa nào để bạn có thể thấy nơi bạn đang sử dụng chúng.

00:34:55.000 --> 00:34:58.000
Nó cho phép bạn chuyển chúng cho các đối số chung chung.

00:34:58.000 --> 00:35:03.000
Nó đã bị bãi bỏ hạn chế khiến nhiều giao thức không được sử dụng với chúng.

00:35:03.000 --> 00:35:08.000
Và nó thậm chí còn cho phép bạn hạn chế các loại liên quan chính của bất kỳ loại nào.

00:35:08.000 --> 00:35:13.000
Nhưng ngay cả với tất cả những cải tiến đó, bất kỳ loại nào vẫn có những hạn chế.

00:35:13.000 --> 00:35:30.000
Ví dụ: mặc dù bây giờ bạn có thể sử dụng bất kỳ Mailmaps nào khi Mailmap phù hợp với Equatable, bạn vẫn không thể sử dụng toán tử equals với chúng, bởi vì toán tử equals yêu cầu cả hai mailmaps phải có cùng một loại cụ thể, nhưng điều đó không được đảm bảo khi bạn đang sử dụng hai Mailmaps bất kỳ

00:35:30.000 --> 00:35:37.000
Vì vậy, mặc dù Swift đã cải thiện bất kỳ loại nào rất nhiều, chúng vẫn có những hạn chế quan trọng, cả về khả năng và hiệu suất.

00:35:37.000 --> 00:35:43.000
Và đó là lý do tại sao rất nhiều lần, bạn không nên sử dụng chúng - thay vào đó bạn nên sử dụng thuốc generic.

00:35:43.000 --> 00:35:48.000
Vì vậy, hãy quay lại hai phiên bản của addEntries và áp dụng sự khôn ngoan đó.

00:35:48.000 --> 00:35:56.000
Cả hai phiên bản đều làm chính xác điều tương tự, nhưng phiên bản ở trên cùng sử dụng các loại chung chung và phiên bản ở dưới cùng sử dụng bất kỳ loại nào.

00:35:56.000 --> 00:36:02.000
Phiên bản chung có thể sẽ hiệu quả hơn và có khả năng hơn, vì vậy bạn nên sử dụng phiên bản đó.

00:36:02.000 --> 00:36:08.000
Tuy nhiên, có lẽ bạn bị cám dỗ để sử dụng bất kỳ loại nào, bởi vì chúng dễ đọc và viết hơn rất nhiều.

00:36:08.000 --> 00:36:18.000
Để viết phiên bản chung, bạn cần khai báo hai tên loại chung, hạn chế cả hai và cuối cùng, sử dụng các tên loại chung đó làm loại tham số.

00:36:18.000 --> 00:36:23.000
Điều đó thật mệt mỏi so với việc viết "bất kỳ Bộ sưu tập nào" và "bất kỳ Bản đồ thư nào".

00:36:23.000 --> 00:36:27.000
Vì vậy, bạn sẽ bị cám dỗ để sử dụng bất kỳ loại nào bất chấp những hạn chế của chúng.

00:36:27.000 --> 00:36:34.000
Nhưng đó là điều tương tự mà tôi đã nói trước đó - sử dụng búa của bạn thay vì tuốc nơ vít của bạn vì búa có tay cầm lớn, chắc chắn.

00:36:34.000 --> 00:36:37.000
Bạn không cần phải đưa ra lựa chọn đó.

00:36:37.000 --> 00:36:42.000
Vì vậy, Swift đang tạo ra các loại thuốc generic dễ sử dụng như bất kỳ loại nào.

00:36:42.000 --> 00:36:48.000
Nếu một tham số chung chỉ được sử dụng ở một nơi, bây giờ bạn có thể viết nó với một số từ khóa dưới dạng tốc ký.

00:36:48.000 --> 00:36:55.000
Và nó thậm chí còn hỗ trợ các loại liên quan chính, vì vậy bạn có thể chấp nhận tất cả các bộ sưu tập các mục nhập bản đồ thư với mã dễ hiểu hơn rất nhiều.

00:36:55.000 --> 00:37:00.000
Với điều đó trong hộp công cụ của bạn, không có lý do gì để tránh thuốc generic nữa.

00:37:00.000 --> 00:37:07.000
Nếu bạn có sự lựa chọn giữa thuốc generic và bất kỳ loại nào, thuốc generic sẽ dễ sử dụng - chỉ cần viết "một số" thay vì "bất kỳ".

00:37:07.000 --> 00:37:11.000
Vì vậy, bạn cũng có thể sử dụng công cụ tốt nhất cho công việc.

00:37:11.000 --> 00:37:15.000
Tôi chỉ làm xước bề mặt của những thay đổi này đối với các giao thức và thuốc generic.

00:37:15.000 --> 00:37:28.000
Để có cái nhìn sâu sắc, cũng như đánh giá tuyệt vời về tất cả các tính năng chung của Swift, chúng tôi có thêm hai cuộc nói chuyện cho bạn trong năm nay: "Nắm bắt chung Swift" và "Thiết kế giao diện giao thức trong Swift".

00:37:28.000 --> 00:37:35.000
Bây giờ, Angela và tôi đã nói về gần hai chục thay đổi đối với Swift, nhưng có rất nhiều điều khác mà chúng tôi không thể phù hợp với phiên này.

00:37:35.000 --> 00:37:43.000
Mọi thay đổi này đều được đưa ra, đề xuất, xem xét và chấp nhận công khai trong bảng Evolution trên Diễn đàn Swift.

00:37:43.000 --> 00:37:48.000
Và tất cả chúng đều được định hình và hiện thực hóa với sự giúp đỡ của các thành viên cộng đồng từ bên ngoài Apple.

00:37:48.000 --> 00:37:55.000
Nếu bạn là một trong những người đó, cảm ơn bạn đã biến Swift 5.7 thành bản phát hành tuyệt vời.

00:37:55.000 --> 00:38:02.000
Và nếu bạn muốn giúp quyết định điều gì sẽ xảy ra tiếp theo, hãy truy cập Swift.org/contributing để tìm hiểu cách tham gia.

00:38:02.000 --> 00:38:03.000
Cảm ơn bạn đã dành thời gian.

00:38:03.000 --> 00:38:06.000
Và mã hóa vui vẻ.

00:38:06.000 --> 23:59:59.000
♪

