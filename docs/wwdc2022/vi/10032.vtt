WEBVTT

00:00:00.000 --> 00:00:03.000
♪ Nhạc hip-hop nhạc cụ êm dịu ♪

00:00:03.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:13.000
Xin chào các bạn. Tên tôi là Michael Gorbach từ Shortcuts Engineering.

00:00:13.000 --> 00:00:22.000
Cảm ơn vì đã điều chỉnh để đi sâu vào App Intents, khuôn khổ mới của chúng tôi để hiển thị chức năng ứng dụng của bạn cho hệ thống.

00:00:22.000 --> 00:00:24.000
Đây là kế hoạch cho chuyến lặn của chúng tôi.

00:00:24.000 --> 00:00:31.000
Sau phần giới thiệu nhanh, tôi sẽ nói về ý định và các thông số của chúng, và cách xác định các thực thể.

00:00:31.000 --> 00:00:38.000
Tôi sẽ xem xét một số tính năng tìm kiếm và lọc mạnh mẽ mà bạn có thể xây dựng và cách ý định của bạn có thể tương tác với người dùng.

00:00:38.000 --> 00:00:43.000
Cuối cùng, tôi sẽ đề cập đến kiến trúc và vòng đời của App Intents.

00:00:43.000 --> 00:00:45.000
Hãy bắt đầu từ đầu.

00:00:45.000 --> 00:00:56.000
Trong iOS 10, chúng tôi đã giới thiệu khung SiriKit Intents, cho phép bạn kết nối chức năng ứng dụng của mình với các miền Siri như nhắn tin, tập luyện và thanh toán.

00:00:56.000 --> 00:01:01.000
Bây giờ chúng tôi đang giới thiệu một khuôn khổ mới được gọi là App Intents.

00:01:01.000 --> 00:01:04.000
Nó có ba thành phần chính.

00:01:04.000 --> 00:01:08.000
Ý định là các hành động được tích hợp trong ứng dụng của bạn có thể được sử dụng trên toàn hệ thống.

00:01:08.000 --> 00:01:12.000
Ý định sử dụng các thực thể để thể hiện các khái niệm ứng dụng của bạn.

00:01:12.000 --> 00:01:18.000
Phím tắt ứng dụng bao bọc ý định của bạn để làm cho chúng tự động và có thể phát hiện được.

00:01:18.000 --> 00:01:26.000
Hãy nói về một vài cách mà App Intents có thể làm cho chức năng ứng dụng của bạn có sẵn ở nhiều nơi hơn và mang lại lợi ích cho khách hàng của bạn.

00:01:26.000 --> 00:01:34.000
Với Phím tắt ứng dụng, mọi người đều có thể sử dụng các tính năng của ứng dụng bằng giọng nói của họ thông qua Siri mà không cần thiết lập bất cứ điều gì trước.

00:01:34.000 --> 00:01:42.000
Việc áp dụng tương tự cũng làm cho ý định của bạn xuất hiện trong Spotlight khi mọi người tìm kiếm ứng dụng của bạn và khi ứng dụng của bạn được đề xuất.

00:01:42.000 --> 00:01:45.000
Điều này sẽ đặt công việc của bạn ở phía trước và trung tâm.

00:01:45.000 --> 00:01:53.000
Sử dụng App Intents, bạn cũng có thể xây dựng Focus Filters, cho phép khách hàng tùy chỉnh ứng dụng của bạn cho một Focus cụ thể.

00:01:53.000 --> 00:02:01.000
Ví dụ, họ có thể thiết lập ứng dụng Lịch của mình để chỉ hiển thị lịch làm việc của họ trong khi họ thực sự đang làm việc.

00:02:01.000 --> 00:02:06.000
Kiểm tra phiên này để tìm hiểu thêm về cách áp dụng Bộ lọc Tiêu điểm.

00:02:06.000 --> 00:02:14.000
Với Phím tắt Ứng dụng, ý định của bạn sẽ tự động hiển thị trong ứng dụng Phím tắt mà không cần thêm thủ công.

00:02:14.000 --> 00:02:25.000
Tích hợp các hành động của bạn vào Phím tắt cực kỳ có giá trị đối với khách hàng vì họ có thể chạy các phím tắt và tận dụng các tính năng của ứng dụng của bạn, từ rất nhiều nơi trên toàn hệ thống.

00:02:25.000 --> 00:02:32.000
Họ có thể chạy các phím tắt chỉ bằng một lần nhấn vào Màn hình chính, từ thanh menu trên macOS và theo nhiều cách khác.

00:02:32.000 --> 00:02:37.000
Họ thậm chí có thể thiết lập các phím tắt để chạy tự động với tự động hóa.

00:02:37.000 --> 00:02:51.000
Các phím tắt hỗ trợ nhân lên sức mạnh và khả năng của ứng dụng của bạn bằng cách kết nối nó với toàn bộ hệ sinh thái Phím tắt, khai thác sức mạnh của một loạt các ứng dụng từ Apple và các nhà phát triển khác.

00:02:51.000 --> 00:03:02.000
Đó là bởi vì một phím tắt có thể kết hợp các hành động từ nhiều ứng dụng, cho phép người dùng phát minh ra các tính năng và khả năng hoàn toàn mới mà bạn không cần phải thực hiện bất kỳ công việc nào.

00:03:02.000 --> 00:03:11.000
Nếu bạn muốn học cách làm cho hành động của mình hoạt động tốt với những người khác và phù hợp liền mạch với hệ sinh thái này, hãy xem buổi nói chuyện về thiết kế của chúng tôi.

00:03:11.000 --> 00:03:16.000
Mục tiêu của chúng tôi trong việc xây dựng App Intents là làm cho nó trở thành một niềm vui để phát triển.

00:03:16.000 --> 00:03:18.000
Ý định ứng dụng ngắn gọn.

00:03:18.000 --> 00:03:27.000
Viết một ý định đơn giản chỉ có thể mất một vài dòng mã, nhưng API cũng mở rộng quy mô thành các hành động sâu hơn và có thể tùy chỉnh hơn.

00:03:27.000 --> 00:03:29.000
App Intents là hiện đại.

00:03:29.000 --> 00:03:36.000
Chúng tôi đã tập trung tất cả vào Swift, tận dụng các trình xây dựng kết quả, trình bao bọc tài sản, lập trình định hướng giao thức và chung chung.

00:03:36.000 --> 00:03:41.000
Những API này không thể tồn tại nếu không có các tính năng ngôn ngữ tiên tiến.

00:03:41.000 --> 00:03:49.000
Việc áp dụng Ý định ứng dụng cũng dễ dàng, bởi vì nó không yêu cầu kiến trúc lại các sản phẩm và mục tiêu của bạn hoặc tạo ra một khuôn khổ.

00:03:49.000 --> 00:03:53.000
Nó không yêu cầu tiện ích mở rộng và có thể được áp dụng ngay trong ứng dụng của bạn.

00:03:53.000 --> 00:03:55.000
Và mã App Intents có thể duy trì được.

00:03:55.000 --> 00:04:04.000
Giống như SwiftUI, App Intents sử dụng mã của bạn làm nguồn cơ bản của sự thật, tránh sự cần thiết của các trình chỉnh sửa hoặc tệp định nghĩa riêng biệt.

00:04:04.000 --> 00:04:12.000
Điều này cho phép bạn nhanh chóng xây dựng và lặp lại việc áp dụng của mình và đơn giản hóa việc bảo trì vì mọi thứ đều tồn tại ở một nơi.

00:04:12.000 --> 00:04:19.000
Như đã nói, hãy khám phá các API mới này, bắt đầu với mục đích, khối xây dựng trung tâm của khuôn khổ mới của chúng tôi.

00:04:19.000 --> 00:04:27.000
Ý định của ứng dụng - hay viết tắt là "ý định" - là một đơn vị chức năng duy nhất, riêng biệt mà ứng dụng của bạn hiển thị cho hệ thống.

00:04:27.000 --> 00:04:34.000
Ví dụ, một ý định có thể tạo một sự kiện lịch mới, mở một màn hình cụ thể hoặc đặt hàng.

00:04:34.000 --> 00:04:45.000
Một ý định có thể được thực hiện bởi người dùng theo yêu cầu - như bằng cách chạy phím tắt hoặc hỏi Siri - hoặc tự động - như sử dụng bộ lọc Focus hoặc tự động hóa Phím tắt.

00:04:45.000 --> 00:04:51.000
Khi một ý định được chạy, nó sẽ trả về kết quả hoặc gây ra lỗi.

00:04:51.000 --> 00:05:09.000
Một ý định bao gồm ba phần chính: siêu dữ liệu hoặc thông tin về ý định, bao gồm tiêu đề được bản địa hóa; các tham số, là đầu vào mà ý định có thể sử dụng khi nó được chạy; và một phương thức thực hiện, thực hiện công việc thực tế khi ý định được thực hiện.

00:05:09.000 --> 00:05:11.000
Điểm khởi đầu của chúng tôi hôm nay là ứng dụng Thư viện này.

00:05:11.000 --> 00:05:18.000
Vì tôi là một con mọt sách khổng lồ, đó là tất cả về việc theo dõi những cuốn sách tôi đã đọc, muốn đọc hoặc hiện đang đọc.

00:05:18.000 --> 00:05:24.000
Mỗi danh mục được hiển thị trong tab riêng biệt của ứng dụng mà tôi gọi là Kệ.

00:05:24.000 --> 00:05:34.000
Người dùng của tôi truy cập kệ Đang đọc mọi lúc, vì vậy tôi sẽ hiển thị một ứng dụng có ý định giúp mở nó nhanh hơn và thuận tiện hơn.

00:05:34.000 --> 00:05:41.000
Tôi sẽ tạo một ý định OpenCurrentlyReading ở đây bằng cách xác định một cấu trúc Swift phù hợp với giao thức AppIntent.

00:05:41.000 --> 00:05:45.000
Tôi chỉ cần thực hiện một phương pháp, được gọi là thực hiện.

00:05:45.000 --> 00:05:52.000
Trong ứng dụng của tôi, tôi đã có một trình điều hướng có thể mở các tab, vì vậy việc thực hiện ý định cho tôi chỉ là một vài dòng mã.

00:05:52.000 --> 00:05:59.000
Tôi sẽ chú thích phương thức thực hiện với @MainActor, vì Navigator của tôi mong đợi luồng chính.

00:05:59.000 --> 00:06:02.000
Ý định của tôi cũng cần một tiêu đề.

00:06:02.000 --> 00:06:09.000
Giống như tất cả các chuỗi khác mà tôi sẽ chỉ cho bạn hôm nay, điều này sẽ được bản địa hóa tự động nếu tôi thêm khóa vào các tệp chuỗi của mình.

00:06:09.000 --> 00:06:13.000
Đây là tất cả những gì tôi cần làm để có được một ý định ứng dụng cơ bản hoạt động.

00:06:13.000 --> 00:06:24.000
Bây giờ nó đã được xác định trong mã của tôi, nó sẽ tự động xuất hiện trong trình chỉnh sửa Phím tắt, nơi người dùng của tôi có thể thêm nó vào một phím tắt.

00:06:24.000 --> 00:06:36.000
Chỉ cần phơi bày ý định này cung cấp đòn bẩy rất lớn, bởi vì một khi khách hàng biến ý định này thành một lối tắt, nó có thể được sử dụng từ rất nhiều nơi trong hệ thống, bao gồm tất cả những thứ này.

00:06:36.000 --> 00:06:41.000
Để làm cho ý định mới của tôi dễ sử dụng và khám phá, tôi cũng sẽ thêm hỗ trợ cho Phím tắt ứng dụng.

00:06:41.000 --> 00:06:53.000
Với một chút mã, tôi có thể làm cho ý định của mình tự động hiển thị trong Spotlight và ứng dụng Phím tắt, và tôi có thể xác định một cụm từ mà mọi người có thể nói với Siri để sử dụng ý định này bằng giọng nói của họ.

00:06:53.000 --> 00:07:00.000
Kiểm tra phiên "Các phím tắt ứng dụng triển khai với ý định ứng dụng" để có được tất cả các chi tiết.

00:07:00.000 --> 00:07:05.000
Cho đến nay, tôi đã tiết lộ ý định mở kệ Đang đọc.

00:07:05.000 --> 00:07:12.000
Tiếp theo, hãy khái quát hóa nó, thêm một tham số để nó có thể mở bất kỳ kệ nào.

00:07:12.000 --> 00:07:15.000
Tôi có một enum đại diện cho các kệ.

00:07:15.000 --> 00:07:21.000
Để nó được sử dụng như một tham số ý định, tôi cần phải phù hợp với giao thức AppEnum.

00:07:21.000 --> 00:07:26.000
AppEnum yêu cầu một giá trị thô Chuỗi, vì vậy tôi sẽ thêm nó trước.

00:07:26.000 --> 00:07:32.000
Nó cũng yêu cầu tôi cung cấp các tiêu đề có thể định vị, có thể đọc được của con người cho mỗi trường hợp liệt kê của tôi.

00:07:32.000 --> 00:07:39.000
Chúng phải được cung cấp dưới dạng từ điển theo nghĩa đen, vì trình biên dịch sẽ đọc mã này tại thời điểm xây dựng.

00:07:39.000 --> 00:07:46.000
Cuối cùng, tôi sẽ thêm một typeDisplayName: một tên hiển thị cho người dùng, có thể định vị cho toàn bộ loại enum này.

00:07:46.000 --> 00:07:49.000
Tôi sẽ sử dụng "Kệ."

00:07:49.000 --> 00:07:58.000
Trong một ý định, mỗi tham số được khai báo bằng cách sử dụng trình bao bọc thuộc tính @Parameter, được khởi tạo với thông tin về tham số, như tiêu đề.

00:07:58.000 --> 00:08:04.000
Ở đây, tôi xác định một tham số kệ mới, mà tôi đã đọc trong phương pháp thực hiện của mình.

00:08:04.000 --> 00:08:13.000
Các thông số hỗ trợ tất cả các loại này, bao gồm số, chuỗi, tệp và hơn thế nữa, cũng như các thực thể và liệt kê từ ứng dụng của bạn.

00:08:13.000 --> 00:08:17.000
Đây là ý định này trông như thế nào trong trình chỉnh sửa Phím tắt.

00:08:17.000 --> 00:08:21.000
Lưu ý rằng tham số kệ xuất hiện trong một hàng bảng.

00:08:21.000 --> 00:08:29.000
Tôi có thể làm cho giao diện người dùng được sắp xếp hợp lý hơn và làm cho nó phù hợp hơn với Phím tắt, bằng cách sử dụng ParameterSummary API.

00:08:29.000 --> 00:08:37.000
Tóm tắt tham số là một câu đại diện cho ý định của bạn và các tham số của nó trong trình chỉnh sửa, như "Mở".

00:08:37.000 --> 00:08:45.000
Để có kết quả tốt nhất trong Phím tắt, bạn nên luôn cung cấp Tóm tắt Tham số cho mọi ý định bạn tạo.

00:08:45.000 --> 00:08:50.000
Bạn cũng có thể xác định thông số nào hiển thị bên dưới nếp gấp và thông số nào bị ẩn.

00:08:50.000 --> 00:09:05.000
Các API này có thể thực hiện một số thứ khá thú vị, như thay đổi bản tóm tắt dựa trên các giá trị thực tế của bất kỳ tham số nào trong ý định của bạn, sử dụng API Khi nào và Khác, hoặc API Chuyển đổi, Trường hợp và Mặc định.

00:09:05.000 --> 00:09:09.000
Để thêm một bản tóm tắt tham số, tôi triển khai thuộc tính tĩnh này.

00:09:09.000 --> 00:09:15.000
Ở đây tôi sẽ trả về chuỗi "Mở", và nội suy tham số kệ.

00:09:15.000 --> 00:09:25.000
Điều cuối cùng tôi cần làm để Open Shelf hoạt động là đảm bảo rằng mục đích mở ứng dụng Thư viện khi nó chạy, như thế này.

00:09:25.000 --> 00:09:30.000
Việc mở ứng dụng được điều khiển bởi thuộc tính tĩnh, openAppWhenRun.

00:09:30.000 --> 00:09:33.000
Nó mặc định là sai, điều này rất tốt cho hầu hết các ý định.

00:09:33.000 --> 00:09:40.000
Nhưng đối với ý định mở một cái gì đó trong giao diện người dùng như thế này, tôi sẽ cần đặt nó thành sự thật.

00:09:40.000 --> 00:09:43.000
Tôi vừa tạo ra một ý định mở kệ.

00:09:43.000 --> 00:09:47.000
Điều này cực kỳ đơn giản vì bộ kệ đã được cố định.

00:09:47.000 --> 00:09:53.000
Nhưng điều gì sẽ xảy ra nếu tôi muốn xây dựng một ý định mở Sách, tập hợp chúng là động, không cố định?

00:09:53.000 --> 00:09:55.000
Đối với điều đó, tôi sẽ cần các thực thể.

00:09:55.000 --> 00:09:59.000
Một thực thể là một khái niệm mà ứng dụng của bạn hiển thị cho App Intents.

00:09:59.000 --> 00:10:09.000
Bạn nên sử dụng một thực thể thay vì một enum khi các giá trị là động, hoặc do người dùng xác định, như một ghi chú trong Ghi chú hoặc một bức ảnh hoặc album trong Ảnh.

00:10:09.000 --> 00:10:17.000
Để cung cấp các trường hợp của các thực thể, ứng dụng của bạn có thể thực hiện các truy vấn và trả về các thực thể dưới dạng kết quả từ ý định.

00:10:17.000 --> 00:10:21.000
Tôi sẽ bắt đầu bằng cách đưa ra ý định mở một cuốn sách trong ứng dụng.

00:10:21.000 --> 00:10:25.000
Trong trình chỉnh sửa Phím tắt, nó sẽ trông như thế này.

00:10:25.000 --> 00:10:34.000
Khi mọi người nhấn vào tham số Sách, họ sẽ nhận được một bộ chọn để chọn một cuốn sách, bao gồm một tập hợp các thực thể được đề xuất mà ứng dụng của tôi đã cung cấp.

00:10:34.000 --> 00:10:41.000
Họ cũng có thể tìm thấy bất kỳ cuốn sách nào trong thư viện của họ với trường tìm kiếm này ở đầu bộ chọn.

00:10:41.000 --> 00:10:47.000
Trước khi tôi tự xây dựng ý định, tôi sẽ cần tạo một thực thể sách và truy vấn tương ứng.

00:10:47.000 --> 00:10:56.000
Một thực thể chứa ít nhất ba thứ: một mã định danh, một biểu diễn hiển thị và một tên loại thực thể.

00:10:56.000 --> 00:11:01.000
Để thêm một thực thể, hãy bắt đầu bằng cách tuân thủ một cấu trúc với giao thức AppEntity.

00:11:01.000 --> 00:11:08.000
Ở đây, tôi sẽ xác định một cấu trúc mới cho BookEntity, nhưng tôi cũng có thể phù hợp với một loại hiện có từ mô hình của mình.

00:11:08.000 --> 00:11:14.000
Bạn cung cấp một mã định danh bằng cách tuân thủ thực thể của bạn với giao thức Nhận dạng.

00:11:14.000 --> 00:11:20.000
App Intents sử dụng mã định danh này để tham chiếu đến thực thể của bạn khi nó được truyền giữa ứng dụng của bạn và các phần khác của hệ thống.

00:11:20.000 --> 00:11:29.000
Mã định danh phải ổn định và liên tục, vì nó có thể được lưu trong một phím tắt do khách hàng của bạn tạo ra.

00:11:29.000 --> 00:11:33.000
Biểu diễn hiển thị được sử dụng để hiển thị thực thể này cho người dùng.

00:11:33.000 --> 00:11:37.000
Điều này có thể đơn giản như một chuỗi văn bản, giống như tiêu đề cuốn sách.

00:11:37.000 --> 00:11:41.000
Bạn cũng có thể cung cấp phụ đề và hình ảnh.

00:11:41.000 --> 00:11:46.000
typeDisplayName là một chuỗi có thể đọc được của con người đại diện cho loại của một thực thể.

00:11:46.000 --> 00:11:49.000
Trong ví dụ này, đó là "Sách".

00:11:49.000 --> 00:11:54.000
Bây giờ, để làm tròn thực thể sách, tôi cần thêm một truy vấn.

00:11:54.000 --> 00:12:00.000
Một truy vấn cung cấp cho hệ thống một giao diện để truy xuất các thực thể từ ứng dụng của bạn.

00:12:00.000 --> 00:12:03.000
Các truy vấn có thể tra cứu các thực thể theo một vài cách.

00:12:03.000 --> 00:12:07.000
Tất cả các truy vấn cần có khả năng tra cứu các thực thể dựa trên số nhận dạng.

00:12:07.000 --> 00:12:09.000
Truy vấn chuỗi hỗ trợ tìm kiếm.

00:12:09.000 --> 00:12:13.000
Và sau đó, bạn sẽ gặp phải các truy vấn về tài sản, linh hoạt hơn.

00:12:13.000 --> 00:12:21.000
Tất cả các truy vấn cũng có thể cung cấp các thực thể được đề xuất, cho phép người dùng chọn từ một danh sách.

00:12:21.000 --> 00:12:29.000
Mỗi thực thể nên được liên kết với một truy vấn để hệ thống có thể tra cứu các trường hợp của thực thể đó.

00:12:29.000 --> 00:12:35.000
Bạn cung cấp một truy vấn bằng cách tạo một cấu trúc Swift phù hợp với giao thức EntityQuery.

00:12:35.000 --> 00:12:42.000
Truy vấn cơ bản chỉ có một phương thức bắt buộc, mà bạn thực hiện để giải quyết các thực thể được cung cấp một mảng các số nhận dạng.

00:12:42.000 --> 00:12:49.000
Tôi đã triển khai điều này bằng cách truy cập cơ sở dữ liệu mô hình của mình và tìm bất kỳ cuốn sách nào khớp với các số nhận dạng đó.

00:12:49.000 --> 00:12:53.000
Bây giờ, tôi cần kết nối truy vấn với thực thể.

00:12:53.000 --> 00:13:03.000
Tôi làm điều này bằng cách triển khai thuộc tính tĩnh defaultQuery trên loại BookEntity và trả về một phiên bản của BookQuery của tôi.

00:13:03.000 --> 00:13:08.000
Khi người dùng chọn một cuốn sách, số nhận dạng của nó sẽ được lưu vào phím tắt.

00:13:08.000 --> 00:13:16.000
Khi phím tắt được chạy, App Intents sẽ chuyển mã định danh cho truy vấn của tôi để truy xuất phiên bản BookEntity.

00:13:16.000 --> 00:13:24.000
Bây giờ loại BookEntity phù hợp với giao thức AppEntity, tôi có thể sử dụng nó như một tham số trong ý định OpenBook của mình.

00:13:24.000 --> 00:13:32.000
Phương pháp thực hiện sử dụng Điều hướng của tôi để điều hướng đến cuốn sách.

00:13:32.000 --> 00:13:38.000
Để hỗ trợ người chọn sách, truy vấn của tôi cũng cần cung cấp các kết quả được đề xuất.

00:13:38.000 --> 00:13:45.000
Để làm điều đó, tôi cần triển khai thêm một phương pháp truy vấn, trả lại tất cả các sách đã thêm vào ứng dụng Thư viện của tôi.

00:13:45.000 --> 00:13:49.000
Các phím tắt sẽ lấp đầy bộ chọn với những kết quả này.

00:13:49.000 --> 00:13:53.000
Lưu ý rằng giao diện người dùng Phím tắt có một trường tìm kiếm ở trên cùng.

00:13:53.000 --> 00:14:00.000
Ứng dụng của tôi có thể có rất nhiều thực thể sách, vì vậy tôi thực sự nên chạy tìm kiếm trong quy trình ứng dụng của mình, trực tiếp với cơ sở dữ liệu của mình.

00:14:00.000 --> 00:14:04.000
StringQuery API cho phép tôi làm điều đó.

00:14:04.000 --> 00:14:13.000
Việc áp dụng giao thức con StringQuery cho tôi thêm một phương thức để triển khai, được gọi là các thực thể (chuỗi khớp:), để trả về kết quả đã cho một chuỗi.

00:14:13.000 --> 00:14:24.000
Ở đây, tôi đã triển khai nó như một kết hợp không phân biệt chữ hoa chữ thường với tiêu đề của cuốn sách, nhưng tôi có thể đã làm những thứ kỳ lạ hơn như tìm kiếm thông qua tác giả hoặc tên sê-ri chẳng hạn.

00:14:24.000 --> 00:14:38.000
Nếu tôi có một danh sách sách lớn và một danh sách yêu thích nhỏ hơn, tôi có thể chỉ trả lại các mục yêu thích trong Thực thể được đề xuất và dựa vào các thực thể (chuỗi khớp:) để cho phép người dùng của tôi tìm kiếm trong danh sách dài hơn.

00:14:38.000 --> 00:14:45.000
Bây giờ tôi đã giới thiệu một cách để mở sách trong ứng dụng của mình và xây dựng một thực thể sách và truy vấn sách trong quá trình này.

00:14:45.000 --> 00:14:49.000
Tôi có thể sử dụng cùng một thực thể và truy vấn để tạo thêm ý định.

00:14:49.000 --> 00:14:53.000
Nhiệm vụ tiếp theo của tôi là xây dựng ý định thêm sách vào thư viện.

00:14:53.000 --> 00:15:03.000
Khách hàng có thể nhanh chóng thêm sách trong khi duyệt trực tuyến bằng cách sử dụng phím tắt chia sẻ hoặc họ có thể yêu cầu Siri trên HomePod thêm sách mà không cần nhìn vào màn hình.

00:15:03.000 --> 00:15:11.000
Xây dựng ý định như thế này thao túng mô hình của bạn trực tiếp mà không hiển thị giao diện người dùng của bạn thực sự có thể trao quyền cho người dùng của bạn.

00:15:11.000 --> 00:15:19.000
Đây là việc thực hiện ý định AddBook của tôi, lấy tiêu đề của cuốn sách làm tham số và tên tùy chọn của tác giả.

00:15:19.000 --> 00:15:24.000
Nó cũng bao gồm một ghi chú tùy chọn để ghi lại người bạn nào đã giới thiệu cuốn sách.

00:15:24.000 --> 00:15:31.000
Phương thức thực hiện sẽ thêm cuốn sách vào thư viện bằng cách tra cứu nó bằng lệnh gọi API bằng cách sử dụng async/await.

00:15:31.000 --> 00:15:36.000
Nó sẽ gây ra lỗi nếu không thể tìm thấy kết quả phù hợp.

00:15:36.000 --> 00:15:43.000
Để bản địa hóa lỗi này, tôi tuân thủ loại lỗi của mình với giao thức CustomLocalizedString ResourceConvertible.

00:15:43.000 --> 00:15:50.000
Tôi sẽ trả về một khóa chuỗi được bản địa hóa từ thuộc tính này và thêm khóa vào các tệp chuỗi của tôi.

00:15:50.000 --> 00:15:56.000
Mục đích Thêm Sách này cực kỳ hữu ích, với Siri, các tiện ích và hơn thế nữa.

00:15:56.000 --> 00:16:01.000
Nhưng nó thậm chí còn linh hoạt hơn nếu nó có thể được kết hợp với các ý định khác.

00:16:01.000 --> 00:16:10.000
Với một chút công việc, tôi có thể cho phép kết hợp ý định Thêm Sách của mình với ý định Mở Sách mà tôi đã xây dựng trước đó, chuyển kết quả từ cái này sang cái kia.

00:16:10.000 --> 00:16:17.000
Để làm như vậy, tôi sẽ có ý định Thêm Sách trả về một giá trị như một phần của kết quả của nó.

00:16:17.000 --> 00:16:23.000
Lưu ý rằng kiểu trả về của phương thức thực hiện của tôi đã chọn một giao thức mới để biểu diễn giá trị tôi đang trả về.

00:16:23.000 --> 00:16:31.000
Giờ đây, người dùng có thể kết nối giá trị kết quả của ý định này với các ý định khác lấy một thực thể sách làm tham số.

00:16:31.000 --> 00:16:41.000
Ý định Thêm Sách và ý định Mở Sách kết hợp khá tự nhiên với nhau, vì vậy bạn có thể tạo một phím tắt thêm một cuốn sách và sau đó ngay lập tức mở nó trong thư viện.

00:16:41.000 --> 00:16:46.000
Đó là một mô hình phổ biến để trả về kết quả từ một ý định và mở nó trong ứng dụng.

00:16:46.000 --> 00:16:51.000
Ý định của ứng dụng có một cách tích hợp để thể hiện điều này được gọi là openIntent.

00:16:51.000 --> 00:16:57.000
Nếu tôi thêm một openIntent, khách hàng sẽ nhận được một công tắc mới trong Phím tắt được gọi là "Open When Run".

00:16:57.000 --> 00:17:04.000
Nếu họ tắt công tắc, họ sẽ có thể sử dụng ý định này như một phần của phím tắt trong nền mà không bị gián đoạn.

00:17:04.000 --> 00:17:12.000
Nếu họ để công tắc bật, cuốn sách mới được thêm vào sẽ được mở ngay lập tức trong ứng dụng Thư viện của tôi.

00:17:12.000 --> 00:17:20.000
Áp dụng openIntent dễ dàng như tạo một ví dụ về ý định Open Book và trả lại nó như một phần của kết quả.

00:17:20.000 --> 00:17:31.000
Khi ý định này được chạy, nếu công tắc Mở Khi Chạy được bật, ý định Mở Sách sẽ tự động được thực hiện sau khi ý định Thêm Sách kết thúc.

00:17:31.000 --> 00:17:35.000
Bạn có thể làm nhiều việc hơn với các thực thể và truy vấn.

00:17:35.000 --> 00:17:43.000
Với bộ API tiếp theo, AppIntents mở ra một số khả năng mạnh mẽ mà bạn chưa từng có trước đây với khung SiriKit Intents.

00:17:43.000 --> 00:17:52.000
Hãy xem cách bạn có thể tiết lộ thêm thông tin từ các thực thể của mình và cho phép khách hàng tìm và lọc dựa trên điều đó.

00:17:52.000 --> 00:17:56.000
Cho đến nay, tôi đã thêm tất cả các yêu cầu cơ bản vào thực thể sách của mình.

00:17:56.000 --> 00:18:05.000
Nhưng để mọi người tích hợp sách sâu hơn vào các phím tắt của họ, tôi sẽ cần tiết lộ thêm một chút về sách của mình.

00:18:05.000 --> 00:18:11.000
Các thực thể hỗ trợ các thuộc tính, chứa thông tin bổ sung về thực thể mà bạn muốn hiển thị cho người dùng.

00:18:11.000 --> 00:18:22.000
Trong trường hợp này, tôi sẽ thêm tác giả của cuốn sách, ngày xuất bản, ngày đọc và ai đã đề xuất nó, để mọi người có thể sử dụng các thuộc tính đó trong các phím tắt của họ.

00:18:22.000 --> 00:18:27.000
Tôi thêm các thuộc tính vào BookEntity của mình bằng cách sử dụng trình bao bọc thuộc tính có tên @Property.

00:18:27.000 --> 00:18:35.000
Các thuộc tính hỗ trợ tất cả các loại giống như các tham số và mỗi loại có một tiêu đề được bản địa hóa.

00:18:35.000 --> 00:18:55.000
Với các thuộc tính mới này, khách hàng của tôi giờ đây có thể sử dụng các biến ma thuật trong Phím tắt để lấy ra từng phần thông tin mới khi làm việc với một thực thể sách Khi sử dụng ý định Thêm Sách trước đó, họ có thể sử dụng tác giả hoặc ngày xuất bản của một cuốn sách mới được thêm vào trong các phím tắt của họ.

00:18:55.000 --> 00:19:06.000
Khi bạn kết hợp các thuộc tính với các truy vấn, ứng dụng của bạn sẽ tự động nhận được các hành động Tìm và Lọc cực kỳ mạnh mẽ này trong Phím tắt, với giao diện người dùng chỉnh sửa vị ngữ linh hoạt này.

00:19:06.000 --> 00:19:13.000
Bây giờ, khách hàng của tôi sẽ có thể tìm và lọc sách dựa trên ngày đọc, tiêu đề, tác giả và hơn thế nữa.

00:19:13.000 --> 00:19:18.000
Ví dụ, đó là một miếng bánh để tìm tất cả những cuốn sách của Delia Owens.

00:19:18.000 --> 00:19:27.000
Sử dụng các tùy chọn Sắp xếp theo và Giới hạn, bạn có thể hỗ trợ các truy vấn nâng cao hơn nữa, như tìm ba cuốn sách được xuất bản gần đây nhất của Delia Owens.

00:19:27.000 --> 00:19:36.000
Một khách hàng có thể sử dụng các khối xây dựng này để làm một số việc khá thú vị, như tìm ba tác giả phổ biến nhất trong bộ sưu tập của họ.

00:19:36.000 --> 00:19:41.000
Để kích hoạt tất cả điều này, tôi sẽ cần áp dụng một loại truy vấn khác được gọi là truy vấn thuộc tính.

00:19:41.000 --> 00:19:50.000
Truy vấn thuộc tính tìm thấy các thực thể không dựa trên chuỗi hoặc mã định danh, mà dựa trên các thuộc tính trong thực thể.

00:19:50.000 --> 00:19:53.000
Có ba bước để thực hiện các truy vấn tài sản.

00:19:53.000 --> 00:20:00.000
Đầu tiên, bạn khai báo các thuộc tính truy vấn, chỉ định cách thực thể của bạn có thể được tìm kiếm bằng cách sử dụng các thuộc tính của nó.

00:20:00.000 --> 00:20:06.000
Sau đó, bạn thêm các tùy chọn sắp xếp, xác định cách sắp xếp kết quả truy vấn.

00:20:06.000 --> 00:20:12.000
Và cuối cùng, bạn triển khai các thực thể (phù hợp:) để chạy tìm kiếm.

00:20:12.000 --> 00:20:19.000
Các thuộc tính truy vấn khai báo mọi cách AppIntents có thể tìm kiếm trên thực thể được liên kết với truy vấn này.

00:20:19.000 --> 00:20:28.000
Mỗi người liệt kê một thuộc tính của thực thể của tôi và các toán tử so sánh - như chứa, bằng hoặc nhỏ hơn - có sẵn cho nó.

00:20:28.000 --> 00:20:38.000
Ở đây, tôi liệt kê các bộ so sánh "ít hơn" và "lớn hơn" cho các thuộc tính ngày của tôi, và "chứa" và "bằng" cho tài sản tiêu đề của tôi.

00:20:38.000 --> 00:20:48.000
Các thuộc tính truy vấn ánh xạ từng tổ hợp thuộc tính và bộ so sánh thành một loại bạn chọn, được gọi là loại ánh xạ bộ so sánh.

00:20:48.000 --> 00:20:51.000
Ở đây, tôi đang sử dụng CoreData, vì vậy tôi sẽ sử dụng NSPredicate.

00:20:51.000 --> 00:21:00.000
Nếu tôi đang sử dụng cơ sở dữ liệu tùy chỉnh hoặc REST API, tôi có thể thiết kế loại bộ so sánh của riêng mình và sử dụng nó thay thế.

00:21:00.000 --> 00:21:04.000
Đây là mã để thiết lập các thuộc tính truy vấn cho sách của tôi.

00:21:04.000 --> 00:21:08.000
Tôi tuân thủ BooksQuery với giao thức EntityPropertyQuery.

00:21:08.000 --> 00:21:15.000
Sau đó, tôi triển khai các thuộc tính var tĩnh bằng cách sử dụng trình tạo kết quả QueryProperties.

00:21:15.000 --> 00:21:24.000
Mỗi mục nhập chỉ định một keyPath của một Thuộc tính có thể được truy vấn và bên trong nó, mỗi bộ so sánh có thể áp dụng cho thuộc tính đó.

00:21:24.000 --> 00:21:31.000
Đối với mỗi bộ so sánh, tôi cung cấp một NSPredicate, bởi vì tôi đã chọn NSPredicate làm loại ánh xạ bộ so sánh của mình.

00:21:31.000 --> 00:21:39.000
Khi hệ thống yêu cầu ứng dụng của tôi trả về kết quả cho truy vấn, nó sẽ cung cấp lại NSPredicates mà tôi đang xây dựng ở đây.

00:21:39.000 --> 00:21:42.000
Có một định nghĩa tương tự để phân loại.

00:21:42.000 --> 00:21:46.000
Đây là danh sách tất cả các thuộc tính mà mô hình của tôi có thể sắp xếp sách theo.

00:21:46.000 --> 00:21:52.000
Trong trường hợp này, tôi cho phép sắp xếp theo tiêu đề, ngày đọc và ngày xuất bản.

00:21:52.000 --> 00:21:59.000
Cuối cùng, tôi triển khai các thực thể (phù hợp:), truy vấn cơ sở dữ liệu của tôi và trả về các thực thể phù hợp.

00:21:59.000 --> 00:22:07.000
Phương pháp này lấy một mảng của loại ánh xạ so sánh mà tôi đã sử dụng trong các tham số truy vấn được xác định trước đó - trong trường hợp này là NSPredicate.

00:22:07.000 --> 00:22:15.000
Những vị ngữ này đang mô tả tiêu chí nào về các thuộc tính của thực thể mà tôi muốn truy vấn.

00:22:15.000 --> 00:22:26.000
Nó cũng có một chế độ, cho biết nên kết hợp các vị ngữ với "và" hay với "hoặc", các đường dẫn chính để sắp xếp và giới hạn tùy chọn cho số lượng kết quả.

00:22:26.000 --> 00:22:34.000
Việc triển khai của tôi sử dụng các tham số này để thực hiện truy vấn đối với cơ sở dữ liệu CoreData của tôi.

00:22:34.000 --> 00:22:37.000
Khách hàng có thể làm gì với truy vấn tài sản này?

00:22:37.000 --> 00:22:40.000
Họ có thể chọn một cuốn sách ngẫu nhiên từ thư viện của họ để đọc.

00:22:40.000 --> 00:22:45.000
Họ có thể tìm thấy tất cả những cuốn sách của họ được xuất bản vào đầu thế kỷ XX.

00:22:45.000 --> 00:22:51.000
Họ có thể tận dụng hệ sinh thái Phím tắt và làm cho ứng dụng của tôi hữu ích hơn bằng cách kết nối nó với những người khác.

00:22:51.000 --> 00:22:57.000
Ví dụ, họ có thể sử dụng ứng dụng bảng tính để xuất tất cả những cuốn sách họ đã đọc trong năm nay sang tệp CSV.

00:22:57.000 --> 00:23:03.000
Hoặc, họ có thể sử dụng một ứng dụng vẽ đồ thị để tạo biểu đồ về số lượng sách họ đã đọc mỗi năm trong 10 cuốn sách qua.

00:23:03.000 --> 00:23:04.000
Và đó mới chỉ là sự khởi đầu.

00:23:04.000 --> 00:23:14.000
Loại áp dụng Ý định ứng dụng sâu sắc này thực sự cho phép khách hàng sử dụng ứng dụng của bạn để làm những gì họ cần, khiến nó trở thành một phần quan trọng trong quy trình làm việc của họ.

00:23:14.000 --> 00:23:21.000
Mỗi tích hợp này - ví dụ như tạo biểu đồ - là một tính năng bạn không cần phải xây dựng.

00:23:21.000 --> 00:23:32.000
Khi ý định của bạn được thực hiện, ứng dụng của bạn có thể cần tương tác với người dùng để hiển thị hoặc nói kết quả hoặc để giải quyết sự mơ hồ, cho dù đó là yêu cầu Siri hay phím tắt.

00:23:32.000 --> 00:23:43.000
App Intents hỗ trợ một số tương tác này: hộp thoại để đưa ra phản hồi bằng văn bản và giọng nói cho người dùng của bạn khi ý định đã hoàn thành và các đoạn để đưa ra phản hồi trực quan.

00:23:43.000 --> 00:23:59.000
Yêu cầu giá trị và định hướng để yêu cầu người dùng làm rõ các giá trị cho các tham số ý định và xác nhận để xác minh các giá trị tham số hoặc kiểm tra với người dùng về các ý định mang tính giao dịch hoặc phá hoại.

00:23:59.000 --> 00:24:04.000
Hộp thoại cung cấp phản hồi bằng lời nói hoặc văn bản cho người đang thực hiện một ý định.

00:24:04.000 --> 00:24:10.000
Điều thực sự quan trọng là cung cấp hộp thoại cho ý định hoạt động tốt trong trải nghiệm giọng nói.

00:24:10.000 --> 00:24:20.000
Trong ý định Thêm Sách của tôi từ trước đó, tôi sẽ thêm needsValueDialog được nói khi yêu cầu tiêu đề sách và hộp thoại kết quả được trả về từ phương thức thực hiện của tôi.

00:24:20.000 --> 00:24:25.000
Những thứ này sẽ được đọc hoặc hiển thị bởi Phím tắt hoặc Siri trên nhiều nền tảng của chúng tôi.

00:24:25.000 --> 00:24:34.000
Bạn có thể nghĩ các đoạn trích là hình ảnh tương đương với hộp thoại, cho phép bạn thêm một biểu diễn trực quan vào kết quả ý định của mình.

00:24:34.000 --> 00:24:42.000
Để sử dụng một đoạn mã, chỉ cần thêm chế độ xem SwiftUI mà bạn chọn làm phần đóng cuối vào kết quả ý định của bạn.

00:24:42.000 --> 00:24:51.000
Giống như với một tiện ích, chế độ xem SwiftUI của bạn sẽ được lưu trữ và gửi đến Phím tắt hoặc Siri.

00:24:51.000 --> 00:24:56.000
App Intents cũng hỗ trợ yêu cầu người dùng cung cấp giá trị bằng cách ném requestValue.

00:24:56.000 --> 00:25:02.000
Ví dụ, điều này có ích khi bạn cần một giá trị cho một tham số đôi khi là tùy chọn.

00:25:02.000 --> 00:25:08.000
Ở đây, requestValue giúp tôi khi tìm kiếm chuỗi của tôi trả về nhiều hơn một cuốn sách.

00:25:08.000 --> 00:25:12.000
Trong trường hợp này, tôi nhắc nhở và yêu cầu một tác giả thu hẹp phạm vi tìm kiếm sách.

00:25:12.000 --> 00:25:21.000
requestValue cho tôi một lỗi mà tôi có thể ném, lỗi này sẽ nhắc người dùng và chạy lại hành động với tên tác giả được cập nhật.

00:25:21.000 --> 00:25:29.000
Trong khi đó, định hướng rất tuyệt khi bạn cần người dùng chọn giữa một tập hợp các giá trị cho một tham số.

00:25:29.000 --> 00:25:35.000
Điều này cho tôi một cách thậm chí còn tốt hơn để xử lý nhiều kết quả có thể có trong hành động Thêm Sách của tôi.

00:25:35.000 --> 00:25:43.000
Ở đây, tôi nhận được một danh sách tên tác giả từ những cuốn sách được tạo ra và yêu cầu định hướng với những giá trị có thể có đó.

00:25:43.000 --> 00:25:49.000
Người dùng sẽ được yêu cầu chọn giữa chúng, và tôi sẽ lấy lại kết quả.

00:25:49.000 --> 00:25:53.000
Cuối cùng, App Intents hỗ trợ hai loại xác nhận khác nhau.

00:25:53.000 --> 00:25:57.000
Loại đầu tiên là xác nhận một giá trị tham số.

00:25:57.000 --> 00:26:04.000
Bạn có thể sử dụng cái này khi bạn đoán được giá trị đó nên là bao nhiêu nhưng bạn muốn xác nhận, chỉ để chắc chắn.

00:26:04.000 --> 00:26:13.000
Khi thêm một cuốn sách, đôi khi dịch vụ web tôi gọi để tra cứu sách theo tiêu đề trả về một vài kết quả phù hợp, nhưng một trong số đó cho đến nay là phổ biến hơn.

00:26:13.000 --> 00:26:21.000
Trong những trường hợp này, tôi sẽ giả định rằng người dùng muốn thêm cuốn sách phổ biến đó, nhưng tôi sẽ thêm xác nhận để đảm bảo rằng tôi đã làm đúng.

00:26:21.000 --> 00:26:26.000
Để làm điều đó, tôi sẽ gọi requestConfirmation trên tham số tiêu đề.

00:26:26.000 --> 00:26:31.000
Loại thứ hai là xác nhận kết quả của một ý định.

00:26:31.000 --> 00:26:33.000
Ví dụ, điều này rất tốt cho việc đặt hàng.

00:26:33.000 --> 00:26:41.000
Nếu tôi muốn kiếm tiền từ ứng dụng Thư viện của mình và thêm đơn đặt hàng thông qua hiệu sách, tôi muốn đảm bảo rằng tôi đã đặt hàng đúng.

00:26:41.000 --> 00:26:47.000
Để làm điều này, tôi có thể gọi requestConfirmation về ý định của mình, chuyển theo thứ tự được đặt.

00:26:47.000 --> 00:26:52.000
Tôi cũng sẽ chỉ định một đoạn mã ở đây, hiển thị bản xem trước của đơn đặt hàng.

00:26:52.000 --> 00:27:00.000
Tôi đặt tiền tố cuộc gọi bằng "thử" vì requestConfirmation sẽ gây ra lỗi nếu người dùng hủy thay vì xác nhận.

00:27:00.000 --> 00:27:09.000
Trước khi tôi rời khỏi bạn, có một vài khía cạnh của kiến trúc App Intents mà tôi muốn đề cập đến, mà bạn nên biết khi áp dụng khuôn khổ.

00:27:09.000 --> 00:27:16.000
Thực tế có hai cách để xây dựng Ý định ứng dụng của bạn: trong ứng dụng của bạn hoặc trong một tiện ích mở rộng riêng biệt.

00:27:16.000 --> 00:27:20.000
Trong số này, việc triển khai ý định trực tiếp trong ứng dụng của bạn là đơn giản nhất.

00:27:20.000 --> 00:27:28.000
Điều này thật tuyệt vì bạn không cần một khuôn khổ hoặc sao chép mã của mình và bạn không cần phối hợp giữa các quy trình.

00:27:28.000 --> 00:27:39.000
Sử dụng ứng dụng của bạn cũng cung cấp một số giới hạn bộ nhớ cao hơn và nó cung cấp cho bạn khả năng thực hiện một số loại công việc khó hơn từ tiện ích mở rộng, như phát âm thanh.

00:27:39.000 --> 00:27:45.000
Ứng dụng của bạn có thể được chạy ở phía trước nếu bạn triển khai openAppWhenRun với ý định trả về true.

00:27:45.000 --> 00:27:48.000
Nếu không, nó sẽ được chạy trong nền.

00:27:48.000 --> 00:27:55.000
Khi chạy ở chế độ nền, ứng dụng của bạn sẽ khởi chạy ở chế độ đặc biệt mà không có cảnh nào được đưa lên để tối đa hóa hiệu suất.

00:27:55.000 --> 00:28:05.000
Trên thực tế, nếu bạn triển khai ý định ứng dụng nền trong ứng dụng của mình, chúng tôi đặc biệt khuyến khích bạn cũng triển khai hỗ trợ cảnh.

00:28:05.000 --> 00:28:08.000
Hoặc, bạn có thể xây dựng ý định ứng dụng của mình trong một tiện ích mở rộng.

00:28:08.000 --> 00:28:10.000
Điều này có một vài lợi thế.

00:28:10.000 --> 00:28:18.000
Nó nhẹ hơn, bởi vì quá trình mở rộng chỉ xử lý ý định của ứng dụng và không yêu cầu quay ứng dụng của bạn.

00:28:18.000 --> 00:28:32.000
Nếu bạn đang xử lý ý định của Focus, sử dụng tiện ích mở rộng cũng có nghĩa là bạn sẽ ngay lập tức nhận được ý định được thực hiện trên tiện ích mở rộng của mình khi Focus thay đổi, mà không yêu cầu ứng dụng của bạn đang chạy ở phía trước.

00:28:32.000 --> 00:28:43.000
Tiện ích mở rộng có nhiều công sức hơn một chút, vì bạn sẽ cần thêm mục tiêu mới, di chuyển một số mã vào khuôn khổ và xử lý sự phối hợp giữa ứng dụng của bạn và tiện ích mở rộng.

00:28:43.000 --> 00:28:52.000
Để tạo phần mở rộng App Intents, hãy vào File &gt; New Target trong Xcode và chọn App Intents Extension.

00:28:52.000 --> 00:28:56.000
Với App Intents, mã của bạn là nguồn duy nhất của sự thật.

00:28:56.000 --> 00:29:06.000
App Intents đạt được trải nghiệm nhà phát triển thanh lịch này bằng cách trích xuất tĩnh thông tin về ý định, thực thể, truy vấn và tham số của bạn tại thời điểm xây dựng.

00:29:06.000 --> 00:29:18.000
Xcode sẽ tạo một tệp siêu dữ liệu bên trong ứng dụng hoặc gói tiện ích mở rộng của bạn trong quá trình xây dựng, chứa thông tin nhận được từ trình biên dịch Swift khi nó chạy trên mã của bạn.

00:29:18.000 --> 00:29:25.000
Để đảm bảo tất cả những điều này hoạt động, hãy giữ các loại Ý định ứng dụng của bạn trực tiếp trong mục tiêu hoặc tiện ích mở rộng, không phải trong một khuôn khổ.

00:29:25.000 --> 00:29:34.000
Tương tự, các chuỗi được bản địa hóa của bạn nên được tìm thấy trong một tệp chuỗi trong cùng một gói nơi các loại Ý định Ứng dụng của bạn tồn tại.

00:29:34.000 --> 00:29:48.000
Đối với những người bạn có các ứng dụng hiện có với Ý định SiriKit mà bạn muốn nâng cấp, nếu bạn áp dụng ý định tích hợp với các tiện ích hoặc miền như nhắn tin hoặc phương tiện, bạn nên tiếp tục sử dụng khung Ý định SiriKit.

00:29:48.000 --> 00:29:55.000
Nhưng nếu bạn thêm ý định tùy chỉnh cho Siri và Phím tắt, bạn nên tiếp tục và nâng cấp lên App Intents.

00:29:55.000 --> 00:30:04.000
Bạn có thể bắt đầu quá trình nâng cấp bằng cách nhấp vào nút Chuyển đổi thành Ý định ứng dụng trong tệp định nghĩa Ý định SiriKit của bạn.

00:30:04.000 --> 00:30:17.000
Tích hợp ứng dụng của bạn vào Phím tắt với Ý định ứng dụng là một cách tuyệt vời để tối đa hóa đòn bẩy của bạn với tư cách là một nhà phát triển, bởi vì bằng cách thực hiện một lượng nhỏ công việc để áp dụng Ý định ứng dụng, bạn tạo ra một lượng lớn giá trị cho khách hàng.

00:30:17.000 --> 00:30:18.000
Cảm ơn bạn đã tham gia!

00:30:18.000 --> 00:30:23.000
Tôi thực sự hy vọng rằng bạn sẽ dùng thử App Intents hôm nay và cho chúng tôi phản hồi của bạn.

00:30:23.000 --> 00:30:29.000
Tôi rất hào hứng về cách khuôn khổ mới này có thể giúp bạn gây bất ngờ, thích thú và trao quyền cho mọi người sử dụng ứng dụng của bạn!

00:30:29.000 --> 00:30:33.000
Chúc bạn đọc vui vẻ và hy vọng WWDC của bạn thật hoành tráng!

00:30:33.000 --> 23:59:59.000
♪

