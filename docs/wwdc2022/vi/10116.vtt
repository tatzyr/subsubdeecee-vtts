WEBVTT

00:00:00.000 --> 00:00:13.000
- Xin chào! Tôi là Kent và tôi là một kỹ sư trong nhóm CloudKit.

00:00:13.000 --> 00:00:18.000
Tôi rất vui được giới thiệu một thư viện mới mà bạn có thể sử dụng để truy cập CloudKit.

00:00:18.000 --> 00:00:21.000
Đầu tiên, tôi sẽ đề cập đến cách cấu hình thư viện mới này.

00:00:21.000 --> 00:00:27.000
Và sau đó bạn sẽ học cách quản lý lược đồ của mình, cũng như cách truy cập dữ liệu người dùng với CKTool JS.

00:00:27.000 --> 00:00:29.000
Hãy bắt đầu nào!

00:00:29.000 --> 00:00:35.000
CloudKit là một công nghệ bền bỉ cho phép bạn lưu trữ dữ liệu ứng dụng của mình trong iCloud trong các vùng chứa.

00:00:35.000 --> 00:00:42.000
Bằng cách sử dụng CloudKit trong ứng dụng của bạn, bạn cũng có thể cập nhật dữ liệu của mình trên các thiết bị và trên web.

00:00:42.000 --> 00:00:51.000
Để xây dựng ứng dụng của bạn, bạn có thể truy cập bộ nhớ iCloud bằng cách sử dụng khung CloudKit trên nền tảng Apple hoặc CloudKit JS trên web.

00:00:51.000 --> 00:00:57.000
Để triển khai tự động hóa và công cụ, Xcode cung cấp cktool để sử dụng trên macOS.

00:00:57.000 --> 00:01:03.000
Và bây giờ bạn có một cách mới để tự động hóa các thay đổi và tương tác với iCloud, sử dụng CKTool JS.

00:01:03.000 --> 00:01:13.000
CKTool JS cho phép bạn thực hiện các thao tác tương tự như tiện ích dòng lệnh cktool được giới thiệu trong Xcode 13 và hỗ trợ các trường hợp sử dụng tương tự.

00:01:13.000 --> 00:01:21.000
Trên thực tế, CKTool JS được sử dụng để triển khai các tính năng trong Bảng điều khiển CloudKit như thêm các loại bản ghi và truy vấn bản ghi.

00:01:21.000 --> 00:01:29.000
Với CKTool JS, bạn có thể quản lý các vùng chứa ứng dụng của mình và thực hiện các thao tác lược đồ, chẳng hạn như đặt lại và áp dụng các bản cập nhật cho lược đồ của mình.

00:01:29.000 --> 00:01:33.000
Đây là điều mà bạn không thể làm từ JavaScript trước đây.

00:01:33.000 --> 00:01:39.000
CKTool JS cho phép bạn tìm nạp các bản ghi hiện có bằng cách sử dụng mã định danh duy nhất của chúng hoặc thông qua các truy vấn phức tạp.

00:01:39.000 --> 00:01:43.000
Và nó cho phép bạn tạo các bản ghi mới và cập nhật chúng.

00:01:43.000 --> 00:01:47.000
CKTool JS đi kèm với các định nghĩa kiểu nghiêm ngặt cho TypeScript.

00:01:47.000 --> 00:01:55.000
Các định nghĩa loại này cho phép kiểm tra thời gian biên dịch có gắn cờ sử dụng thư viện máy khách không chính xác và nó cho phép hoàn thành mã trong các IDE được hỗ trợ.

00:01:55.000 --> 00:02:00.000
Bạn sẽ thấy việc chỉnh sửa mã CKTool JS dễ dàng hơn vì điều này.

00:02:00.000 --> 00:02:05.000
Ngoài ra, thư viện mới này đi kèm với sự hỗ trợ cho cả Node.js và trình duyệt ngay lập tức.

00:02:05.000 --> 00:02:13.000
CKTool JS được phân phối dưới dạng một tập hợp các gói npm, cho phép bạn tích hợp nó như một phần của quy trình xây dựng JavaScript của mình.

00:02:13.000 --> 00:02:18.000
Làm như vậy cho phép các tính năng như rung cây và bó.

00:02:18.000 --> 00:02:26.000
Bạn cũng có thể theo dõi các bản cập nhật cho các gói này vì lịch sử phát hành của chúng có sẵn một cách minh bạch từ npm.

00:02:26.000 --> 00:02:29.000
Các gói sau đây là một phần của bản phân phối CKTool JS.

00:02:29.000 --> 00:02:38.000
Lưu ý rằng các gói này nằm trong phạm vi @apple và tuân theo quy ước sử dụng cktool. ở đầu tên.

00:02:38.000 --> 00:02:42.000
Gói chính mà bạn sẽ sử dụng là cktool.database.

00:02:42.000 --> 00:02:57.000
Để cho phép giao tiếp với iCloud, bạn cũng sẽ cần sử dụng một gói khác cho nền tảng mục tiêu của mình, cktool.target.nodejs cho Node.js hoặc cktool.target.browser cho trình duyệt web.

00:02:57.000 --> 00:03:10.000
Cktool.database tự động kéo thêm ba gói nữa-- cktool.core, cktool.api.base, và cktool.api.database.

00:03:10.000 --> 00:03:15.000
Vì CKTool JS giao tiếp trực tiếp với iCloud, trước tiên nó phải được ủy quyền.

00:03:15.000 --> 00:03:21.000
Tùy thuộc vào hoạt động mà bạn muốn gọi, bạn sẽ cần mã thông báo quản lý hoặc mã thông báo người dùng.

00:03:21.000 --> 00:03:25.000
Cả hai loại mã thông báo đều có thể nhận được từ Bảng điều khiển CloudKit.

00:03:25.000 --> 00:03:31.000
Mã thông báo quản lý được sử dụng để truy cập các hoạt động quản lý và được định phạm vi cho một nhóm và người dùng.

00:03:31.000 --> 00:03:39.000
Các hoạt động như vậy bao gồm cho phép nhập và xuất lược đồ, xác thực lược đồ và đặt lại vùng chứa vào sản xuất.

00:03:39.000 --> 00:03:46.000
Mã thông báo người dùng được định phạm vi cho các nhóm và vùng chứa và cho phép truy cập vào dữ liệu người dùng riêng tư trong các vùng chứa đó.

00:03:46.000 --> 00:03:58.000
Để tìm hiểu cách lấy các mã thông báo ủy quyền này cũng như tích hợp liên tục với CloudKit, hãy xem "Tự động hóa các bài kiểm tra CloudKit với cktool và lược đồ khai báo" từ WWDC21.

00:03:58.000 --> 00:04:03.000
Bất cứ khi nào bạn muốn sử dụng CKTool JS trong tập lệnh của mình, trước tiên bạn sẽ cần cấu hình nó để sử dụng.

00:04:03.000 --> 00:04:09.000
Nhưng trước khi tôi đi sâu vào cấu hình CKTool JS, tôi sẽ xem xét nhanh những gì tạo nên lược đồ CloudKit.

00:04:09.000 --> 00:04:13.000
Trong CloudKit, dữ liệu được lưu trữ theo cách có cấu trúc.

00:04:13.000 --> 00:04:18.000
Dữ liệu có cùng loại giá trị được lưu trữ cùng nhau dưới dạng bản ghi.

00:04:18.000 --> 00:04:25.000
Các bản ghi là các trường hợp của các loại bản ghi và các thuộc tính của bản ghi mà loại bản ghi mô tả được gọi là các trường.

00:04:25.000 --> 00:04:32.000
Ngoài các trường do người dùng xác định của bạn, CloudKit thêm các trường hệ thống như recordName, là ID của bản ghi.

00:04:32.000 --> 00:04:35.000
Tôi sẽ sử dụng các ví dụ từ một ứng dụng thu thập tiền xu mà tôi đang làm việc.

00:04:35.000 --> 00:04:42.000
Tôi muốn lưu trữ một bộ sưu tập các quốc gia, vì vậy tôi có một loại hồ sơ để mô tả loại tài sản tôi cần lưu trữ cho họ.

00:04:42.000 --> 00:04:47.000
Tôi đang lưu trữ tên và mã ISO, và tôi đang đặt tên cho loại bản ghi, "Các quốc gia".

00:04:47.000 --> 00:04:53.000
Mã ISO xác định duy nhất một quốc gia, vì vậy điều quan trọng là phải đưa chúng vào loại hồ sơ của tôi.

00:04:53.000 --> 00:04:58.000
Tôi tạo một số hồ sơ thuộc loại Quốc gia để lưu trữ thông tin này cùng với tên của họ.

00:04:58.000 --> 00:05:03.000
Tôi cũng có một loại kỷ lục cho tiền xu của các quốc gia cụ thể và tôi muốn liên hệ chúng với nhau.

00:05:03.000 --> 00:05:10.000
Loại bản ghi Coins lưu trữ mối quan hệ từ một đồng xu với quốc gia của nó.

00:05:10.000 --> 00:05:13.000
Các loại bản ghi và mối quan hệ kết hợp để tạo thành một lược đồ.

00:05:13.000 --> 00:05:18.000
Tôi có thể coi trạng thái hiện tại của các yếu tố này là phiên bản hiện tại của lược đồ của tôi.

00:05:18.000 --> 00:05:26.000
Khi bạn phát triển các ứng dụng của mình, bạn sẽ phát triển lược đồ của mình và trong suốt vòng đời của ứng dụng, bạn có thể sẽ có một số phiên bản của nó.

00:05:26.000 --> 00:05:33.000
Trong khi lược đồ ứng dụng của tôi mô tả cấu trúc của dữ liệu tôi muốn lưu trữ trong iCloud, vùng chứa ứng dụng của tôi là nơi dữ liệu đó được lưu trữ.

00:05:33.000 --> 00:05:38.000
Một vùng chứa có một mã định danh duy nhất và được liên kết với một nhóm nhà phát triển.

00:05:38.000 --> 00:05:43.000
Có hai môi trường cần ghi nhớ khi làm việc với CloudKit.

00:05:43.000 --> 00:05:47.000
Môi trường phát triển là một nơi an toàn để thực hiện các thay đổi mà không làm gián đoạn người dùng.

00:05:47.000 --> 00:05:51.000
Đây là nơi bạn nên kiểm tra và phát triển các thay đổi đối với lược đồ của mình.

00:05:51.000 --> 00:05:56.000
Khi người dùng tương tác với ứng dụng của bạn, họ sẽ tương tác với môi trường sản xuất.

00:05:56.000 --> 00:05:59.000
Môi trường sản xuất chứa dữ liệu trực tiếp cho ứng dụng của bạn.

00:05:59.000 --> 00:06:05.000
Bây giờ tôi đã xem xét cách CloudKit lưu trữ dữ liệu, tôi sẽ đề cập đến cách định cấu hình CKTool JS.

00:06:05.000 --> 00:06:15.000
Bởi vì CKTool JS nói chuyện với iCloud, bạn sẽ cần thu thập một vài thông tin để nó biết cách làm việc với vùng chứa phù hợp và tập lệnh của bạn được phép làm như vậy.

00:06:15.000 --> 00:06:20.000
Bạn sẽ cần ID nhóm của mình và ID vùng chứa cho vùng chứa mà bạn muốn làm việc cùng.

00:06:20.000 --> 00:06:27.000
Bạn sẽ cần một mã thông báo quản lý để làm việc với các lược đồ và nếu tập lệnh của bạn sẽ truy cập dữ liệu, bạn cũng sẽ cần một mã thông báo người dùng.

00:06:27.000 --> 00:06:30.000
Tất cả các giá trị này có thể được lấy từ Bảng điều khiển CloudKit.

00:06:30.000 --> 00:06:35.000
Bạn cũng sẽ cần chỉ định môi trường, sự phát triển hoặc sản xuất nào, tập lệnh của bạn sẽ chạy.

00:06:35.000 --> 00:06:38.000
Tôi sẽ lấy sự phát triển làm ví dụ trong tương lai.

00:06:38.000 --> 00:06:43.000
Bất cứ khi nào bạn định cấu hình CKTool JS để sử dụng, bạn sẽ cần những giá trị này.

00:06:43.000 --> 00:06:46.000
Đối với các ví dụ của tôi, tôi đang viết kịch bản cho Node.js.

00:06:46.000 --> 00:06:51.000
Bạn nhập các đối tượng và chức năng từ CKTool JS để sử dụng chúng.

00:06:51.000 --> 00:06:56.000
Trong trường hợp này, bạn có thể nhập các ký hiệu này bằng cách sử dụng các câu lệnh yêu cầu CommonJS.

00:06:56.000 --> 00:07:02.000
Khi bạn đã thu thập thông tin cấu hình của mình, bạn sẽ tạo các đối tượng để giữ thông tin đó.

00:07:02.000 --> 00:07:08.000
Để lưu trữ mã thông báo xác thực của bạn, bạn tạo một đối tượng để giữ mã thông báo quản lý của mình và, nếu bạn có, mã thông báo người dùng của bạn.

00:07:08.000 --> 00:07:17.000
Vì teamId, containerId và environment là những giá trị chung được chuyển đến CKTool JS, bạn có thể tạo một đối tượng để giữ các giá trị này.

00:07:17.000 --> 00:07:26.000
Bạn khởi tạo một đối tượng Cấu hình cho CKTool JS biết cách nói chuyện với iCloud bằng cách sử dụng chức năng nhà máy createConfiguration.

00:07:26.000 --> 00:07:28.000
createConfiguration dành riêng cho nền tảng.

00:07:28.000 --> 00:07:35.000
Trong trường hợp này, nó sẽ trả về một cấu hình thích hợp cho Node.js, vì đó là chức năng đã được nhập từ gói đích.

00:07:35.000 --> 00:07:42.000
Sau đó, bạn chuyển đối tượng cấu hình và đối tượng bảo mật được khai báo trước đó để khởi tạo đối tượng API.

00:07:42.000 --> 00:07:47.000
Các đối tượng API chứa các phương thức không đồng bộ cho phép bạn nói chuyện với iCloud.

00:07:47.000 --> 00:07:51.000
Bây giờ bạn đã hoàn thành các bước để sử dụng CKTool JS trong tập lệnh của mình.

00:07:51.000 --> 00:07:56.000
Hãy cùng tìm hiểu về cách bạn có thể sử dụng CKTool JS để quản lý lược đồ vùng chứa của mình.

00:07:56.000 --> 00:08:02.000
Trong ứng dụng của tôi, tôi muốn lưu trữ thông tin như một đồng xu Mỹ được phát hành vào năm 2007.

00:08:02.000 --> 00:08:08.000
Đồng xu này bao gồm đồng và niken và giá trị được đóng dấu trên đó là 1/10 đô la Mỹ.

00:08:08.000 --> 00:08:18.000
Sau khi suy nghĩ về cách lưu trữ dữ liệu này, tôi quyết định lưu trữ thông tin về thành phần của đồng xu dưới dạng hồ sơ tách biệt với các chi tiết khác về đồng xu.

00:08:18.000 --> 00:08:24.000
Vì vậy, tôi lưu trữ tỷ lệ phần trăm đồng cho đồng xu và tỷ lệ phần trăm niken của nó trong các hồ sơ riêng biệt.

00:08:24.000 --> 00:08:28.000
Tôi đã xác định được hai loại bản ghi mà tôi muốn trong lược đồ vùng chứa của mình.

00:08:28.000 --> 00:08:33.000
Tiền xu, lưu trữ tham chiếu quốc gia, năm phát hành và giá trị danh nghĩa.

00:08:33.000 --> 00:08:40.000
Và một loại bản ghi Thành phần lưu trữ tham chiếu đến một đồng xu mà nó mô tả và vật liệu và tỷ lệ phần trăm của nó trong đồng xu.

00:08:40.000 --> 00:08:46.000
Bây giờ tôi đã xác định lược đồ cho ứng dụng của mình, tôi có thể tạo một tệp văn bản trong Ngôn ngữ lược đồ CloudKit để mô tả nó.

00:08:46.000 --> 00:08:52.000
Quy ước là sử dụng phần mở rộng .ckdb cho tệp lược đồ của bạn.

00:08:52.000 --> 00:09:00.000
Để biết thêm thông tin về Ngôn ngữ lược đồ CloudKit, hãy tham khảo bài viết tài liệu "Tích hợp lược đồ dựa trên văn bản vào quy trình làm việc của bạn".

00:09:00.000 --> 00:09:05.000
Tệp lược đồ bạn tạo cho vùng chứa của mình có thể được áp dụng bằng CKTool JS.

00:09:05.000 --> 00:09:12.000
Trước khi bạn áp dụng một lược đồ mới, bạn thường sẽ đặt lại lược đồ phát triển của vùng chứa để khớp với lược đồ đang sản xuất.

00:09:12.000 --> 00:09:15.000
Bạn có thể làm điều này với phương pháp resetToProduction.

00:09:15.000 --> 00:09:20.000
Bạn gọi phương thức này bằng cách chuyển đối tượng defaultArgs mà bạn đã khai báo trước đó.

00:09:20.000 --> 00:09:24.000
Nếu lược đồ của bạn không được sản xuất, tất cả các loại bản ghi sẽ bị xóa.

00:09:24.000 --> 00:09:29.000
Nếu không, điều này sẽ hoàn nguyên sơ đồ phát triển về trạng thái của môi trường sản xuất.

00:09:29.000 --> 00:09:35.000
Lưu ý rằng đây là một cuộc gọi không đồng bộ, vì vậy phương thức này trả về một đối tượng hứa hẹn.

00:09:35.000 --> 00:09:40.000
CKTool JS có các phương thức cho phép bạn xuất và nhập lược đồ vùng chứa của mình.

00:09:40.000 --> 00:09:46.000
Các phương pháp exportSchema và importSchema cho phép bạn làm điều này và được đặt tên từ góc nhìn của vùng chứa.

00:09:46.000 --> 00:09:56.000
Vì vậy, bạn tải xuống một lược đồ được xuất từ vùng chứa bằng exportSchema và bạn tải lên một lược đồ được nhập vào vùng chứa bằng importSchema.

00:09:56.000 --> 00:10:01.000
Cùng với nhau, những thứ này cho phép bạn quản lý sự tiến hóa của lược đồ của mình.

00:10:01.000 --> 00:10:05.000
Bạn có thể tạo một hàm trợ giúp để áp dụng lược đồ vào vùng chứa.

00:10:05.000 --> 00:10:12.000
Đầu tiên, nhập đối tượng Tệp từ CKTool JS, sau đó nhập các mô-đun fs và đường dẫn từ Node.js.

00:10:12.000 --> 00:10:19.000
Bây giờ xác định một hàm không đồng bộ sẽ thực hiện như sau: Nó đọc nội dung của tệp lược đồ vào bộ đệm Node.js.

00:10:19.000 --> 00:10:23.000
Nó tạo ra một phiên bản Tệp CKTool JS để tải lên.

00:10:23.000 --> 00:10:28.000
Cuối cùng, nó tải nội dung của tệp lên máy chủ bằng importSchema.

00:10:28.000 --> 00:10:33.000
Lưu ý rằng đối tượng defaultArgs đã được khai báo trước đó được chuyển đến importSchema.

00:10:33.000 --> 00:10:35.000
Bây giờ bạn có thể ghép nó lại với nhau.

00:10:35.000 --> 00:10:42.000
Bởi vì resetToProduction và hàm trợ giúp được sử dụng để nhập lược đồ là không đồng bộ, bạn cần đảm bảo rằng chúng chạy theo đúng thứ tự.

00:10:42.000 --> 00:10:45.000
Để làm điều đó bạn xâu chuỗi những lời hứa.

00:10:45.000 --> 00:10:48.000
Nếu xảy ra lỗi, lời hứa sẽ từ chối.

00:10:48.000 --> 00:10:55.000
Ngoài khả năng quản lý mà CKTool JS có, nó cũng cho phép bạn làm việc với việc đọc và ghi dữ liệu.

00:10:55.000 --> 00:11:03.000
Các giá trị trường được sử dụng trong các bản ghi CKTool JS được kiểm tra loại và phạm vi ở phía máy khách trước khi chúng được gửi đến máy chủ.

00:11:03.000 --> 00:11:11.000
Nếu giá trị được truyền vào không phải là loại giá trị phù hợp hoặc nằm ngoài phạm vi cho phép của giá trị, một ngoại lệ sẽ được ném ra.

00:11:11.000 --> 00:11:18.000
Đối với những con số lớn không thể được biểu diễn nguyên bản trong JavaScript, có những loại CKTool JS được sử dụng thay thế.

00:11:18.000 --> 00:11:26.000
Ví dụ, để ép một số với CKTool JS Int64, bạn sử dụng hàm toInt64.

00:11:26.000 --> 00:11:30.000
Để ép một số thành giá trị dấu phẩy động Double, bạn sử dụng hàm toDouble.

00:11:30.000 --> 00:11:38.000
Nếu bạn đang viết TypeScript, trình biên dịch sẽ gắn cờ cách sử dụng loại giá trị không chính xác nếu các hàm ép buộc này không được sử dụng.

00:11:38.000 --> 00:11:44.000
Các giá trị trường trong các bản ghi CKTool JS được tạo bằng cách sử dụng các hàm nhà máy giá trị trường.

00:11:44.000 --> 00:11:56.000
Đối với một đồng tiền được phát hành vào năm 2007, tôi sẽ chuyển giá trị đó cho hàm nhà máy makeRecordFieldValue.int64 để tạo giá trị trường bản ghi có chứa Int64.

00:11:56.000 --> 00:12:03.000
Nói chung, nếu một hàm nhà máy không thể tạo giá trị trường bản ghi từ giá trị được truyền vào, nó sẽ ném một ngoại lệ.

00:12:03.000 --> 00:12:09.000
Ở đây, tôi đã tạo một đối tượng để giữ các giá trị chung mà tôi gửi đến các phương thức hoạt động với các bản ghi.

00:12:09.000 --> 00:12:17.000
Vì containerId, môi trường, loại cơ sở dữ liệu và tên vùng thường được yêu cầu, tôi bao gồm những thứ đó trong đối tượng databaseArgs này.

00:12:17.000 --> 00:12:21.000
Để truy vấn các bản ghi, tôi sử dụng phương thức queryRecords.

00:12:21.000 --> 00:12:28.000
Để làm điều này dễ dàng hơn, tôi tạo một hàm trợ giúp để tìm một quốc gia phù hợp với mã ISO 3 ký tự duy nhất của nó.

00:12:28.000 --> 00:12:35.000
Trong trường hợp này, tôi chuyển nội dung của đối tượng databaseArgs, ngoài nội dung chứa truy vấn.

00:12:35.000 --> 00:12:42.000
Đối với đối tượng truy vấn, tôi đang chỉ định giá trị recordType cũng như một đối tượng bộ lọc duy nhất.

00:12:42.000 --> 00:12:50.000
Đối tượng bộ lọc mô tả một truy vấn trong đó isoCode3 của quốc gia bằng với truy vấn mà hàm này đang tìm kiếm.

00:12:50.000 --> 00:12:56.000
Nếu thành công, việc thu thập các bản ghi được tìm thấy sẽ nằm trong thuộc tính response.result.records.

00:12:56.000 --> 00:12:59.000
Tôi trả lại đối tượng đầu tiên từ bộ sưu tập này.

00:12:59.000 --> 00:13:08.000
Để chuyển đổi các giá trị thô thành các giá trị trường mà createRecord có thể sử dụng, tôi có một hàm trợ giúp được gọi là makeCoinFieldValues để thực hiện việc này.

00:13:08.000 --> 00:13:16.000
Đối với mỗi thuộc tính thô cho đồng tiền của tôi mà tôi muốn chuyển đổi thành các giá trị trường, tôi gọi hàm nhà máy RecordFieldValue thích hợp.

00:13:16.000 --> 00:13:20.000
Tuy nhiên, đối với lĩnh vực quốc gia, tôi cần tạo một tài liệu tham khảo.

00:13:20.000 --> 00:13:27.000
Tôi sử dụng tên bản ghi quốc gia được thông qua để tham chiếu từ bản ghi đồng xu này đến bản ghi quốc gia tương ứng.

00:13:27.000 --> 00:13:35.000
Ở đây, tôi tạo một hàm trợ giúp nhận các giá trị trường bản ghi đồng xu và gửi yêu cầu createRecord đến máy chủ.

00:13:35.000 --> 00:13:40.000
Trong chức năng này, tôi đang chuyển nội dung của databaseArgs được khai báo trước đó và một nội dung.

00:13:40.000 --> 00:13:43.000
Từ điển nội dung chứa các giá trị recordType và trường.

00:13:43.000 --> 00:13:48.000
Nếu thành công, response.result.record sẽ được trả về.

00:13:48.000 --> 00:13:55.000
Trước khi gọi hàm trợ giúp, tôi cần tìm nạp bản ghi quốc gia chính xác sẽ được tham chiếu từ đồng tiền này.

00:13:55.000 --> 00:13:58.000
Tôi sử dụng hàm truy vấn quốc gia được xác định trước đó.

00:13:58.000 --> 00:14:08.000
Sau đó tôi gọi coinCreateRecord bằng cách chuyển cho nó một từ điển giá trị trường được tạo bằng hàm trợ giúp makeCoinFieldValues mà tôi đã viết trước đó.

00:14:08.000 --> 00:14:11.000
Các giá trị đồng xu thô được chuyển đến hàm trợ giúp đó.

00:14:11.000 --> 00:14:17.000
Điều này sẽ tạo bản ghi không đồng bộ và trả về bản ghi mới.

00:14:17.000 --> 00:14:20.000
Để cập nhật bản ghi, hãy sử dụng phương pháp updateRecord.

00:14:20.000 --> 00:14:27.000
Tôi tạo một chức năng trợ giúp cập nhật một đồng xu khớp với tên bản ghi với các trường được chuyển cho trình trợ giúp này.

00:14:27.000 --> 00:14:37.000
Sau đó tôi gọi updateRecord với nội dung của đối tượng databaseArgs, recordName và nội dung chứa loại bản ghi và các giá trị trường của bản ghi mới.

00:14:37.000 --> 00:14:45.000
Nếu thành công, bản ghi được cập nhật sẽ nằm trong thuộc tính response.result.record, mà tôi trả về từ hàm trợ giúp.

00:14:45.000 --> 00:14:52.000
Để cập nhật bản ghi đồng xu mà tôi đã tạo trước đó, tôi gọi hàm trợ giúp này chuyển tên bản ghi và giá trị trường của nó để cập nhật.

00:14:52.000 --> 00:14:57.000
Các giá trị trường được tạo bằng makeCoinFieldValues.

00:14:57.000 --> 00:15:02.000
Để xóa một bản ghi, tôi gọi phương thức deleteRecord không đồng bộ trên đối tượng API.

00:15:02.000 --> 00:15:07.000
Tôi chuyển nội dung của đối tượng databaseArgs cũng như recordName của bản ghi để xóa.

00:15:07.000 --> 00:15:10.000
Tôi hy vọng bạn thích làm quen với CKTool JS.

00:15:10.000 --> 00:15:16.000
Hãy tự mình dùng thử: Định cấu hình CKTool JS cho mục đích tự động hóa và công cụ của bạn.

00:15:16.000 --> 00:15:20.000
Đặt lại và nhập lược đồ của bạn cũng như đọc và ghi dữ liệu của bạn bằng JavaScript.

00:15:20.000 --> 00:15:27.000
Để sử dụng CKTool JS trong các tình huống tích hợp liên tục, hãy xem repo mẫu CloudKit trên GitHub.

00:15:27.000 --> 00:15:32.000
Và để có tài liệu chi tiết hơn, hãy xem CKTool JS trên developer.apple.com.

00:15:32.000 --> 23:59:59.000
Cảm ơn vì đã tham gia cùng tôi hôm nay, và tận hưởng phần còn lại của WWDC22.

