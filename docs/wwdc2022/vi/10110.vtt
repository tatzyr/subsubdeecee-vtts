WEBVTT

00:00:09.000 --> 00:00:12.000
Andreas: Xin chào, và chào mừng đến với WWDC.

00:00:12.000 --> 00:00:20.000
Tôi là Andreas từ nhóm bản địa hóa tại Apple và hôm nay tôi muốn chia sẻ với bạn một số ví dụ về cách xây dựng các ứng dụng bản địa hóa, chất lượng cao.

00:00:20.000 --> 00:00:26.000
Quốc tế hóa có nghĩa là chuẩn bị ứng dụng của bạn chạy trên các thiết bị trên toàn thế giới.

00:00:26.000 --> 00:00:33.000
Khi bản địa hóa được thực hiện tốt, mọi người đều có thể tận hưởng trải nghiệm và tiện ích tuyệt vời như nhau - bất kể họ nói ngôn ngữ nào.

00:00:33.000 --> 00:00:41.000
Sử dụng các API mà Apple cung cấp, hầu hết các phần trong ứng dụng của bạn đều thân thiện với quốc tế hóa ngay lập tức.

00:00:41.000 --> 00:00:49.000
Trong buổi nói chuyện này, bạn sẽ học hỏi từ kinh nghiệm của chúng tôi làm cho các ứng dụng của Apple hấp dẫn đối tượng đa dạng, bao gồm một số thách thức và cách chúng tôi giải quyết chúng.

00:00:49.000 --> 00:00:53.000
Tôi sẽ bắt đầu với việc khai báo và tải văn bản bản địa hóa.

00:00:53.000 --> 00:00:57.000
Thật dễ dàng để bao gồm ngày, giờ được định dạng và hơn thế nữa trong chuỗi của chúng tôi.

00:00:57.000 --> 00:01:02.000
Tôi sẽ nêu bật một số lựa chọn, và chúng ta sẽ xem xét một ví dụ phức tạp.

00:01:02.000 --> 00:01:10.000
Gói Swift của bạn cũng có thể bao gồm văn bản được bản địa hóa và bạn sẽ tìm hiểu về những cải tiến đối với quy trình bản địa hóa.

00:01:10.000 --> 00:01:14.000
Cuối cùng, tôi sẽ nói về bố cục và những bổ sung mới tuyệt vời cho SwiftUI.

00:01:14.000 --> 00:01:20.000
Tại Apple, chúng tôi đảm bảo rằng các ứng dụng của chúng tôi đang cung cấp trải nghiệm tuyệt vời cho khán giả quốc tế của chúng tôi.

00:01:20.000 --> 00:01:22.000
Và ứng dụng Thời tiết là một ví dụ về điều này.

00:01:22.000 --> 00:01:30.000
Hàng triệu người dùng mở nó mỗi ngày để kiểm tra dự báo - và đây là ứng dụng trông như thế nào đối với họ, dù họ ở đâu trên thế giới.

00:01:30.000 --> 00:01:34.000
Chú ý cách mọi thứ trong giao diện người dùng được điều chỉnh theo sở thích của họ.

00:01:34.000 --> 00:01:39.000
Chúng tôi bản địa hóa các mô tả về điều kiện thời tiết hiện tại và chúng tôi định dạng các con số.

00:01:39.000 --> 00:01:45.000
Giao diện người dùng cũng được điều chỉnh một cách thích hợp tùy thuộc vào việc ngôn ngữ từ trái sang phải hay từ phải sang trái.

00:01:45.000 --> 00:01:50.000
Chúng ta hãy xem xét kỹ hơn một trong những thứ chúng ta tùy chỉnh bằng cách bắt đầu với bản dịch.

00:01:50.000 --> 00:01:54.000
Khung cảnh này ở đây nói rằng "Gió đang khiến nó cảm thấy mát mẻ hơn" bằng tiếng Anh.

00:01:54.000 --> 00:01:57.000
Và đây là những gì nó trông giống như trong các ngôn ngữ khác.

00:01:57.000 --> 00:02:02.000
Để hỗ trợ chúng đúng cách, tất cả những gì chúng ta phải làm là khai báo chuỗi bằng String(localized).

00:02:02.000 --> 00:02:09.000
Xcode phát hiện ra nó khi xuất để bản địa hóa và chúng tôi có thể gửi kết quả qua các dịch giả của mình.

00:02:09.000 --> 00:02:11.000
Tôi sẽ sử dụng ứng dụng Thư trên máy Mac của mình để làm như vậy.

00:02:11.000 --> 00:02:13.000
Và trong khi chúng ta ở đó, tôi muốn cho bạn xem một cái gì đó.

00:02:13.000 --> 00:02:22.000
Nếu tôi mở menu ngữ cảnh của một email, tôi có thể di chuyển nó đến một thư mục đặc biệt có tên là "Lưu trữ". Nó nằm trong thanh bên của tôi.

00:02:22.000 --> 00:02:25.000
Chú ý cách cả hai từ đều "Lưu trữ" trong tiếng Anh.

00:02:25.000 --> 00:02:31.000
Tuy nhiên, các ngôn ngữ khác như tiếng Tây Ban Nha có các từ khác nhau cho hành động và tên thư mục.

00:02:31.000 --> 00:02:37.000
Mặc dù các từ tiếng Anh giống nhau, nhưng khi chúng xuất hiện trong các ngữ cảnh khác nhau, các ngôn ngữ khác có thể sử dụng các từ khác nhau.

00:02:37.000 --> 00:02:40.000
Bạn nên sử dụng hai chuỗi trong mã trong trường hợp này.

00:02:40.000 --> 00:02:45.000
Và để làm điều đó, chúng tôi đã thêm API mới vào trình khởi tạo chuỗi trong năm nay.

00:02:45.000 --> 00:02:50.000
Bây giờ nó lấy một giá trị mặc định, mà chúng ta có thể sử dụng cho chuỗi tiếng Anh của mình.

00:02:50.000 --> 00:02:55.000
Sau đó, chúng tôi sửa đổi khóa của chuỗi được bản địa hóa để làm rõ sự khác biệt đối với người dịch.

00:02:55.000 --> 00:03:02.000
Bằng cách này, cùng một từ được hiển thị khi chạy ứng dụng bằng tiếng Anh và các dịch giả tiếng Tây Ban Nha có thể cung cấp các từ khác nhau.

00:03:02.000 --> 00:03:11.000
Bài nói chuyện năm ngoái "Hợp lý hóa các chuỗi được bản địa hóa của bạn" giúp bạn hiểu những điều cơ bản về quản lý chuỗi và nó đi xa hơn vào quá trình bản địa hóa.

00:03:11.000 --> 00:03:20.000
Tôi muốn bạn rút ra từ ví dụ này rằng đôi khi cùng một từ tiếng Anh, hoặc thậm chí toàn bộ câu, được hiển thị trong các ngữ cảnh khác nhau trong giao diện người dùng.

00:03:20.000 --> 00:03:25.000
Trong những trường hợp này, hãy đảm bảo sử dụng hai chuỗi khác nhau trong mã của bạn.

00:03:25.000 --> 00:03:27.000
Thời tiết không chỉ là về ứng dụng.

00:03:27.000 --> 00:03:30.000
Nó cũng được tích hợp tốt vào hệ thống.

00:03:30.000 --> 00:03:36.000
Ở đây, chúng tôi thấy hoạt động của người dùng, đề xuất mở ứng dụng để kiểm tra thời tiết tại vị trí hiện tại.

00:03:36.000 --> 00:03:39.000
Chúng ta hãy xem điều đó có thể được thực hiện như thế nào.

00:03:39.000 --> 00:03:45.000
Chuỗi có thể được khai báo và tải như thế này, sử dụng Nội suy chuỗi để chèn bất kỳ tên vị trí nào.

00:03:45.000 --> 00:03:50.000
Và cái tên này có thể là một thành phố hoặc một thuật ngữ cho vị trí hiện tại.

00:03:50.000 --> 00:03:57.000
Kết quả hoạt động tốt bằng tiếng Anh: "Hiển thị thời tiết ở Cupertino" và "Hiển thị thời tiết ở vị trí của tôi," tương ứng.

00:03:57.000 --> 00:04:00.000
Tuy nhiên, trong các ngôn ngữ khác, chúng ta có thể gặp phải các vấn đề về ngữ pháp.

00:04:00.000 --> 00:04:07.000
Ví dụ, trong tiếng Đức, giới từ hoạt động cho một tên thành phố, nhưng sai khi chèn một thuật ngữ cho vị trí hiện tại.

00:04:07.000 --> 00:04:10.000
Thay vào đó chúng ta cần có một bản dịch khác.

00:04:10.000 --> 00:04:15.000
Giải pháp ở đây rất đơn giản: chỉ cần sử dụng hai chuỗi khác nhau.

00:04:15.000 --> 00:04:21.000
Chèn tên thành phố là tốt trong tên đầu tiên và đối với vị trí hiện tại, chúng tôi sử dụng một chuỗi khác.

00:04:21.000 --> 00:04:25.000
Điều này đảm bảo rằng các dịch giả có thể sử dụng ngữ pháp chính xác cho ngôn ngữ của họ.

00:04:25.000 --> 00:04:28.000
Và nó hoạt động tốt trong tiếng Anh và tiếng Đức.

00:04:28.000 --> 00:04:34.000
Tôi đã làm ví dụ này để cho bạn thấy rằng việc chèn một biến có tác động đến toàn bộ câu.

00:04:34.000 --> 00:04:46.000
Nối các chuỗi có thể gây ra những hậu quả đáng ngạc nhiên trong các ngôn ngữ khác: chúng có thể cần phải thay đổi ngữ pháp hoặc có thể gặp rắc rối với việc viết hoa, nhưng biết điều đó trước khi viết mã rất khó.

00:04:46.000 --> 00:04:51.000
Có những người nói ngôn ngữ kiểm tra ứng dụng là một phần quan trọng của quy trình làm việc.

00:04:51.000 --> 00:04:57.000
Hãy ghi nhớ điều đó khi bạn muốn xây dựng một chuỗi theo chương trình.

00:04:57.000 --> 00:05:03.000
Bây giờ chúng ta đã chia sẻ sự hiểu biết tốt về cách các chuỗi được khai báo trong mã, hãy nói về nhận xét của chúng.

00:05:03.000 --> 00:05:07.000
Đây là chuỗi từ ví dụ trước của chúng tôi một lần nữa, với một nhận xét thích hợp.

00:05:07.000 --> 00:05:10.000
Một bình luận thực sự, thực sự quan trọng đối với các dịch giả.

00:05:10.000 --> 00:05:17.000
Bạn nên đảm bảo cung cấp cho họ ngữ cảnh mà họ cần dịch nó, giữ nguyên ý định như bạn đã có khi khai báo chuỗi.

00:05:17.000 --> 00:05:23.000
Một nhận xét tuyệt vời giải thích chuỗi được hiển thị trong phần tử giao diện nào, như nhãn hoặc nút.

00:05:23.000 --> 00:05:28.000
Nó cũng giải thích ngữ cảnh của phần tử giao diện người dùng và nơi nó được hiển thị trên màn hình.

00:05:28.000 --> 00:05:33.000
Đó có thể là tiêu đề phần, menu ngữ cảnh hoặc hoạt động của người dùng.

00:05:33.000 --> 00:05:37.000
Nếu chuỗi chứa các biến, hãy đảm bảo giải thích giá trị của chúng trong thời gian chạy.

00:05:37.000 --> 00:05:42.000
Điều này rất quan trọng để khớp ngữ pháp của câu, như chúng ta đã thấy trong ví dụ.

00:05:42.000 --> 00:05:47.000
Hãy nhớ rằng người dịch có thể không nhìn thấy ứng dụng trong thời gian chạy khi dịch nội dung của bạn.

00:05:47.000 --> 00:05:56.000
Nhưng với những mẹo này, bạn sẽ có thể tạo ra sự hiểu biết chung giữa khai báo và dịch một chuỗi và vai trò của nó trong ứng dụng của bạn.

00:05:56.000 --> 00:06:00.000
Bây giờ, nó có thể chưa bao giờ xảy ra với bạn, nhưng ứng dụng Thời tiết không thực sự kiểm soát thời tiết.

00:06:00.000 --> 00:06:03.000
Thay vào đó, dữ liệu được tải xuống từ một máy chủ.

00:06:03.000 --> 00:06:09.000
Nó có thể được đặt ở bất cứ đâu trên thế giới và thậm chí nó có thể không biết nên gửi nội dung bằng ngôn ngữ nào.

00:06:09.000 --> 00:06:15.000
Khi nội dung được tải xuống thiết bị của người dùng, nó phải luôn được trình bày bằng ngôn ngữ mà người dùng thích.

00:06:15.000 --> 00:06:20.000
Chỉ có một số phần của ứng dụng được bản địa hóa có thể rất khó hiểu.

00:06:20.000 --> 00:06:26.000
Tại đây, ứng dụng Thời tiết hiển thị cảnh báo thời tiết khắc nghiệt, đã được tải từ máy chủ.

00:06:26.000 --> 00:06:32.000
Điều này có vẻ thực sự nghiêm trọng, và nếu nó không được dịch sang ngôn ngữ của tôi, tôi có thể gặp rắc rối sau này.

00:06:32.000 --> 00:06:38.000
Hãy xem bạn có thể làm gì để đảm bảo rằng người dùng của bạn luôn có thể đọc nội dung từ xa.

00:06:38.000 --> 00:06:42.000
Máy chủ của bạn có thể gửi danh sách các ngôn ngữ được hỗ trợ đến ứng dụng.

00:06:42.000 --> 00:06:51.000
Đây phải là một loạt các ID ngôn ngữ và thiết bị có tất cả kiến thức về ngôn ngữ mà người dùng thích, vì vậy bạn không cần phải tự mình kiểm tra so sánh chúng.

00:06:51.000 --> 00:06:55.000
Bạn có thể tận dụng Khung của Apple bằng cách gọi 'Bundle.preferredLocalizations'.

00:06:55.000 --> 00:06:57.000
Và điều này sẽ làm nên trận đấu cho bạn.

00:06:57.000 --> 00:07:03.000
Nó trả về một mảng các ngôn ngữ ứng cử viên, được sắp xếp theo mức độ gần gũi của chúng phù hợp với các lựa chọn ngôn ngữ của người dùng.

00:07:03.000 --> 00:07:08.000
Và cái đầu tiên thường phù hợp nhất, vì vậy bạn sẽ sử dụng cái này.

00:07:08.000 --> 00:07:13.000
Ngôn ngữ đó sau đó nên được sử dụng cho bất kỳ yêu cầu tiếp theo nào đến máy chủ.

00:07:13.000 --> 00:07:19.000
Nó sử dụng nó để tạo phản hồi với nội dung bằng ngôn ngữ mà người dùng của bạn sẽ có thể hiểu được.

00:07:19.000 --> 00:07:27.000
Với kỹ thuật này, bạn có thể tự tin rằng các chuỗi đến từ máy chủ đã sẵn sàng để cập nhật giao diện người dùng và hiển thị cảnh báo cho người dùng.

00:07:27.000 --> 00:07:40.000
Vì vậy, để cứu người dùng của bạn khỏi cơn bão thất vọng khi hiển thị nội dung từ xa, hãy tải xuống các ngôn ngữ có sẵn, khớp với sở thích của người dùng và sử dụng kết quả cho bất kỳ yêu cầu nào tải nội dung hướng đến người dùng.

00:07:40.000 --> 00:07:42.000
Nhưng hãy quay lại thời tiết đẹp hơn ngay bây giờ.

00:07:42.000 --> 00:07:48.000
Dù mưa hay nắng, ứng dụng Thời tiết rất phong phú về dữ liệu và nhiều khía cạnh của nó chứa các con số và số lượng.

00:07:48.000 --> 00:07:51.000
Hãy tập trung vào một trong số chúng.

00:07:51.000 --> 00:08:01.000
Dưới "Lượng mưa" nó nói "0 mm trong 6 giờ qua." Giả sử rằng bạn muốn xây dựng một cái gì đó tương tự, nhưng đánh vần "một giờ" ở đây.

00:08:01.000 --> 00:08:04.000
Đây là cách bạn có thể khai báo chuỗi trong mã.

00:08:04.000 --> 00:08:11.000
Trong tiếng Anh, bạn sẽ cần sử dụng dạng số nhiều nếu số giờ lớn hơn một: một giờ, nhưng hai giờ.

00:08:11.000 --> 00:08:16.000
Các quy tắc khi một biến thể khác nên được sử dụng thậm chí còn phức tạp hơn trong tiếng Ukraina.

00:08:16.000 --> 00:08:22.000
Bạn không muốn triển khai logic đó trong mã của mình và đây là lý do tại sao bạn tận dụng các khuôn khổ của Apple.

00:08:22.000 --> 00:08:29.000
Tất cả những gì bạn phải làm là khai báo chuỗi trong mã và cung cấp tệp stringsdict, mã hóa quy tắc số nhiều.

00:08:29.000 --> 00:08:33.000
Một lựa chọn khác là sử dụng Thỏa thuận ngữ pháp tự động.

00:08:33.000 --> 00:08:45.000
Bạn có thể tìm hiểu thêm về hai kỹ thuật này trong bài nói chuyện năm ngoái "Hợp lý hóa các chuỗi được bản địa hóa của bạn." Mặc dù nó dễ dàng, bạn không nên lúc nào cũng áp dụng quy tắc số nhiều cho tất cả các chuỗi của mình.

00:08:45.000 --> 00:08:52.000
Ví dụ, nếu câu của bạn không tính bất cứ thứ gì và không bao gồm một số, bạn không nên sử dụng quy tắc số nhiều cho nó.

00:08:52.000 --> 00:09:00.000
Ở đây, "Xóa thành phố này khỏi mục yêu thích của bạn" không cần vì không có số và điều tương tự cũng áp dụng cho nhiều thành phố.

00:09:00.000 --> 00:09:05.000
Nhưng nếu chuỗi bao gồm một số, bạn nên cân nhắc việc có các biến thể cho số nhiều.

00:09:05.000 --> 00:09:14.000
Chuỗi của ví dụ trước đã đếm lượng mưa sẽ rơi trong những giờ tới và chúng tôi vừa học được cách dễ dàng để làm cho nó thích nghi với những con số lớn hơn một.

00:09:14.000 --> 00:09:21.000
Tuy nhiên, nếu có một đơn vị trong câu, như thời lượng, thời gian hoặc tỷ lệ phần trăm, bạn nên cân nhắc sử dụng trình định dạng.

00:09:21.000 --> 00:09:24.000
Vậy hãy nói về những người định dạng ngay bây giờ.

00:09:24.000 --> 00:09:28.000
Thời tiết hiển thị độ ẩm hiện tại tính bằng phần trăm trong chế độ xem này.

00:09:28.000 --> 00:09:32.000
Để làm điều này trong SwiftUI, nó chỉ là vấn đề của một dòng mã duy nhất.

00:09:32.000 --> 00:09:37.000
Bạn chỉ cần gói giá trị của mình trong Text() và chỉ định cách bạn muốn số của mình được định dạng.

00:09:37.000 --> 00:09:39.000
Và mã Swift tương đương cũng đơn giản.

00:09:39.000 --> 00:09:43.000
Bạn chỉ cần gọi .định dạng trên giá trị của bạn.

00:09:43.000 --> 00:09:48.000
Đó thực sự là tất cả những gì bạn cần làm, và Formatter lo mọi thứ khác.

00:09:48.000 --> 00:10:00.000
Nó không chỉ đặt dấu phần trăm trước hoặc sau số và thêm khoảng trắng, nó còn phù hợp với hệ thống đánh số ưa thích của người dùng và đó là điều mà người dùng Ả Rập và Hindi mong đợi.

00:10:00.000 --> 00:10:05.000
Nhưng đó thực sự chỉ là khởi đầu của loại dữ liệu bạn có thể định dạng.

00:10:05.000 --> 00:10:19.000
Có các trình định dạng cho hầu hết mọi thứ và tôi khuyến khích bạn tóm tắt lại phiên: "Định dạng: Làm cho dữ liệu thân thiện với con người." Như chúng ta đã thấy, thời tiết không phải lúc nào cũng nắng, và một số ngày sẽ có mưa.

00:10:19.000 --> 00:10:23.000
Tất nhiên, điểm nổi bật này không thể thiếu trong ứng dụng Thời tiết.

00:10:23.000 --> 00:10:32.000
Dưới "Rainfall", nó nói, "50 mm dự kiến trong 24 giờ tới," và tôi thực sự vui vì nó không nhiều như vậy ở nơi tôi đang ở ngay bây giờ.

00:10:32.000 --> 00:10:34.000
Trong tiếng Anh, trường hợp này rất đơn giản.

00:10:34.000 --> 00:10:41.000
Chúng tôi nói "50 mm dự kiến trong 24 giờ tới." Tuy nhiên, trong tiếng Tây Ban Nha, vấn đề phức tạp hơn.

00:10:41.000 --> 00:10:47.000
Chúng ta cần thay đổi bản dịch khi lượng mưa là số ít hoặc số nhiều.

00:10:47.000 --> 00:10:51.000
Chúng ta có thể giải quyết vấn đề này bằng cách kết hợp cả quy tắc Formatter và quy tắc số nhiều.

00:10:51.000 --> 00:10:59.000
Chuỗi "2 mm" được tạo ra bởi một Formatter, và nó được nhúng trong một câu cần được thay đổi cho số nhiều trong tiếng Tây Ban Nha.

00:10:59.000 --> 00:11:03.000
Được rồi, chúng ta hãy xem cách thực hiện điều này trong mã.

00:11:03.000 --> 00:11:10.000
Chúng tôi bắt đầu bằng cách khai báo một hàm nhận một tham số về lượng mưa sẽ tính bằng milimét.

00:11:10.000 --> 00:11:13.000
Có lẽ nó đã được tải xuống từ một máy chủ.

00:11:13.000 --> 00:11:23.000
Đầu tiên, chúng tôi yêu cầu hệ thống cung cấp UnitLength, mã hóa cấu hình của người dùng và nó sẽ chọn đúng cho trường hợp hiển thị lượng mưa của chúng tôi.

00:11:23.000 --> 00:11:31.000
Nếu người dùng chưa định cấu hình hệ thống của họ để sử dụng các số liệu, loại Đo lường có thể dễ dàng chuyển đổi thành đơn vị ưa thích.

00:11:31.000 --> 00:11:38.000
Tiếp theo, API định dạng cho phép chúng tôi tạo ra một chuỗi được định dạng cho giá trị trong một dòng mã duy nhất.

00:11:38.000 --> 00:11:42.000
Đơn vị ưa thích đã có thông tin mà chúng tôi muốn hiển thị lượng mưa.

00:11:42.000 --> 00:11:45.000
Vì vậy, khi định dạng, chúng tôi đặt cách sử dụng thành asProvided.

00:11:45.000 --> 00:11:51.000
Nếu mưa rơi hơn 1 milimet hoặc inch, chúng tôi muốn sử dụng trường hợp số nhiều.

00:11:51.000 --> 00:11:55.000
Chúng tôi chuyển đổi giá trị thành một số nguyên để chúng tôi có thể kiểm tra điều đó.

00:11:55.000 --> 00:12:01.000
Tiếp theo, chúng tôi tải một Chuỗi được bản địa hóa với một khóa nhất định và chúng tôi cũng cung cấp một giá trị mặc định.

00:12:01.000 --> 00:12:07.000
Ở đó, chúng tôi sử dụng Nội suy Chuỗi để bao gồm Giá trị số nguyên, Giá trị được định dạng và số 24.

00:12:07.000 --> 00:12:11.000
Con số được xác định trong mã ở đây, bởi vì nó sẽ luôn là 24 giờ.

00:12:11.000 --> 00:12:17.000
Sử dụng String Interpolation tự động đảm bảo rằng hệ thống đánh số chính xác được sử dụng.

00:12:17.000 --> 00:12:19.000
Khóa được khai báo trong một tệp stringsdict.

00:12:19.000 --> 00:12:22.000
Hãy cùng xem cái đó.

00:12:22.000 --> 00:12:26.000
Stringsdict bắt đầu bằng khóa mà chúng tôi vừa sử dụng trong mã của mình.

00:12:26.000 --> 00:12:33.000
Trong tiếng Anh, chúng tôi không cần thay đổi chuỗi cho số nhiều, vì vậy chúng tôi sử dụng danh mục "Khác" cho nó.

00:12:33.000 --> 00:12:36.000
Tham số đầu tiên xác định danh mục nào được chọn trong thời gian chạy.

00:12:36.000 --> 00:12:39.000
Hãy nhớ rằng, đó là giá trị nguyên.

00:12:39.000 --> 00:12:43.000
Tham số số hai và ba có mặt trong chuỗi được định dạng.

00:12:43.000 --> 00:12:47.000
Điều này xác định câu sẽ trông như thế nào trong thời gian chạy.

00:12:47.000 --> 00:12:56.000
Stringsdict tiếng Tây Ban Nha có cùng cấu trúc, ngoại trừ việc chúng tôi cung cấp bản dịch ở cả số ít và số nhiều.

00:12:56.000 --> 00:13:00.000
Bây giờ chúng tôi đã định dạng dữ liệu trong mã và đặt nó trong một câu.

00:13:00.000 --> 00:13:05.000
Một tệp stringsdict chứa quy tắc số nhiều, do đó bản dịch tiếng Tây Ban Nha đang sử dụng đúng ngữ pháp.

00:13:05.000 --> 00:13:11.000
Đôi khi thật khó để cung cấp một giao diện người dùng được bản địa hóa hoàn toàn hoạt động tốt cho tất cả các ngôn ngữ.

00:13:11.000 --> 00:13:18.000
Một lần nữa, bạn đã học được rằng các chuỗi nối có thể hoạt động đối với tiếng Anh nhưng có thể gây ra những hậu quả đáng ngạc nhiên trong các ngôn ngữ khác.

00:13:18.000 --> 00:13:24.000
Điều này có thể yêu cầu một số mã toàn diện để thực hiện, nhưng bây giờ bạn đã biết cách bạn có thể làm cho nó phù hợp với tất cả người dùng của mình.

00:13:24.000 --> 00:13:31.000
Đôi khi các chuỗi của bạn nằm trong một phụ thuộc hoặc trong một mô-đun mà ứng dụng của bạn sử dụng.

00:13:31.000 --> 00:13:36.000
Hoặc có thể bạn cũng phân phối mã của riêng mình cho các nhà phát triển khác, bằng cách sử dụng Gói Swift.

00:13:36.000 --> 00:13:39.000
Chúng ta hãy xem có gì mới cho bản địa hóa.

00:13:39.000 --> 00:13:45.000
Để xác định một Gói Swift, bạn khai báo cấu trúc và xây dựng cấu hình bằng cách sử dụng chính Swift.

00:13:45.000 --> 00:13:53.000
Nếu bạn có nội dung hướng đến người dùng, bạn có thể sử dụng tham số defaultLocalization để tuyên bố rằng nội dung đang sử dụng tiếng Anh làm ngôn ngữ chính.

00:13:53.000 --> 00:13:58.000
Điều đó tương tự như việc chỉ định ngôn ngữ phát triển của một dự án ứng dụng.

00:13:58.000 --> 00:14:05.000
Xcode hiện đọc tham số đó và nhận ra rằng bạn quan tâm đến việc cung cấp trải nghiệm bản địa hóa.

00:14:05.000 --> 00:14:10.000
Do đó, nó sẽ thêm tùy chọn Xuất bản địa hóa vào menu Sản phẩm.

00:14:10.000 --> 00:14:16.000
Bạn có thể đã quen với việc sử dụng tính năng này cho ứng dụng chính của mình và bây giờ nó cũng hoạt động cho Swift Packages.

00:14:16.000 --> 00:14:21.000
Nếu bạn nhấp vào "Xuất", Xcode sẽ đọc mã của bạn và trích xuất tất cả các chuỗi của bạn.

00:14:21.000 --> 00:14:25.000
Chúng được đặt trong các tệp .xcloc, mà bạn gửi cho người dịch.

00:14:25.000 --> 00:14:34.000
Và để nhập nội dung được bản địa hóa của bạn trở lại gói của bạn, hãy sử dụng Bản địa hóa Nhập khẩu và Xcode sẽ đặt các tệp ở đường dẫn tệp chính xác trong gói của bạn.

00:14:34.000 --> 00:14:41.000
Quy trình làm việc của việc bản địa hóa Gói Swift hiện giống hệt với việc bản địa hóa ứng dụng của bạn.

00:14:41.000 --> 00:14:47.000
Nhưng hãy nhớ rằng, việc tải một chuỗi trong Gói Swift yêu cầu bạn chỉ định đối số 'gói'.

00:14:47.000 --> 00:15:05.000
Bạn có thể tìm hiểu thêm về điều đó trong bài nói chuyện "Gói Swift: tài nguyên và bản địa hóa." Nếu bạn là tác giả của một thư viện được phân phối dưới dạng Gói Swift, bây giờ bạn có một cách dễ dàng để cập nhật dự án của mình và biến bản địa hóa thành một phần thường xuyên trong quy trình làm việc của bạn.

00:15:05.000 --> 00:15:12.000
Bạn đã nỗ lực và quan tâm rất nhiều vào dự án của mình và việc bản địa hóa nó là một công việc tiết kiệm rất nhiều thời gian cho tất cả khách hàng của bạn.

00:15:12.000 --> 00:15:14.000
Nó thực sự có thể làm cho nó nổi bật.

00:15:14.000 --> 00:15:21.000
Làm cho mọi người biết rằng bạn đang đi xa hơn để cung cấp trải nghiệm tốt nhất với phần mềm của mình, vì vậy hãy tiếp tục và nói với họ!

00:15:21.000 --> 00:15:25.000
Hãy cởi mở về những ngôn ngữ mà bạn hỗ trợ ngay lập tức.

00:15:25.000 --> 00:15:32.000
Là một nhà phát triển ứng dụng, bạn đặt những cân nhắc đặc biệt vào các phụ thuộc của mình, không chỉ từ góc độ chất lượng mã.

00:15:32.000 --> 00:15:39.000
Các thành phần mà bạn sử dụng nên hỗ trợ các ngôn ngữ giống nhau và bản dịch chất lượng cao như phần còn lại của ứng dụng của bạn.

00:15:39.000 --> 00:15:48.000
Trong trường hợp mã của bên thứ ba không được bản địa hóa theo ngôn ngữ yêu cầu của bạn, bạn vẫn có thể tạo một bản sao cục bộ của gói và cập nhật các bản địa hóa ở đó.

00:15:48.000 --> 00:15:53.000
Đảm bảo kiểm tra tất cả các phần của ứng dụng của bạn bằng các ngôn ngữ mà nó hỗ trợ.

00:15:53.000 --> 00:15:58.000
Bằng cách này, bạn có thể đảm bảo rằng sẽ không có yếu tố giao diện người dùng nào không phù hợp với ngôn ngữ của người dùng.

00:15:58.000 --> 00:16:06.000
Hầu hết thời gian một chuỗi dịch dài hơn hoặc ngắn hơn chuỗi tương đương tiếng Anh và điều đó luôn ảnh hưởng đến bố cục ứng dụng của bạn.

00:16:06.000 --> 00:16:08.000
Hãy xem điều này có ý nghĩa gì đối với ứng dụng Thời tiết.

00:16:08.000 --> 00:16:14.000
Đây là ứng dụng chạy bằng tiếng Anh, và ở phía bên phải bạn có thể thấy nó chạy bằng tiếng Ả Rập.

00:16:14.000 --> 00:16:22.000
Rõ ràng là không chỉ các bản dịch được điều chỉnh cho phù hợp với ngôn ngữ, mà bố cục cũng tuân theo định hướng thích hợp.

00:16:22.000 --> 00:16:40.000
Nếu bạn muốn tìm hiểu thêm về cách tạo bố cục phù hợp với tất cả các ngôn ngữ, loại ký hiệu nào cung cấp giải pháp thay thế được bản địa hóa và những điều khác cần xem xét cho các ngôn ngữ từ phải sang trái, hãy đảm bảo xem bài nói chuyện "Đưa nó sang phải... sang trái." Ở đây, ứng dụng đang chạy bằng tiếng Hindi ở phía bên phải.

00:16:40.000 --> 00:16:42.000
Hãy phóng to.

00:16:42.000 --> 00:16:45.000
Chữ viết của ngôn ngữ đó nói chung có xu hướng cao hơn.

00:16:45.000 --> 00:16:50.000
Và nếu bạn nhìn kỹ, bạn sẽ thấy rằng chiều cao của nhãn được điều chỉnh để phù hợp với điều đó.

00:16:50.000 --> 00:16:52.000
Hệ thống thực hiện việc này một cách tự động.

00:16:52.000 --> 00:16:57.000
Tất cả những gì bạn phải làm là đảm bảo rằng bạn không cung cấp cho các phần tử giao diện người dùng một chiều cao cố định.

00:16:57.000 --> 00:17:03.000
Đừng cho rằng mọi thứ sẽ vừa trong vòng 44 điểm chỉ vì nó đủ cao để vừa với dây tiếng Anh.

00:17:03.000 --> 00:17:09.000
Vui lòng luôn mong đợi văn bản của bạn cao hơn tùy theo hoàn cảnh.

00:17:09.000 --> 00:17:17.000
Quay trở lại chế độ xem chính và cuộn nó lên, Thời tiết có chế độ xem dự báo 10 ngày, điều này rất tuyệt để kiểm tra vào tuần tới.

00:17:17.000 --> 00:17:24.000
Điều nổi bật trên màn hình này là cách nó tự động điều chỉnh vị trí của các phần tử theo nhãn dài nhất.

00:17:24.000 --> 00:17:28.000
Trong tiếng Anh, "Hôm nay" dài hơn tất cả các tên viết tắt của các ngày trong tuần.

00:17:28.000 --> 00:17:36.000
Tuy nhiên, trong tiếng Tây Ban Nha, tất cả chúng đều rộng ba ký tự và trong tiếng Hy Lạp, bản dịch cho "Today" có kích thước gần gấp đôi.

00:17:36.000 --> 00:17:40.000
Tuy nhiên, trong tất cả các ngôn ngữ, các biểu tượng thời tiết được căn chỉnh theo chiều dọc với nhau.

00:17:40.000 --> 00:17:47.000
Có nghĩa là chúng không có khoảng cách cố định cho các phần tử lân cận của chúng, nhưng chảy theo nhãn các ngày trong tuần dài nhất.

00:17:47.000 --> 00:17:55.000
Khi nói đến việc tạo ra một bố cục phù hợp với quốc tế hóa, bạn nên luôn nhớ rằng các nhãn cần phải linh hoạt.

00:17:55.000 --> 00:18:03.000
Bạn vừa thấy tầm quan trọng của việc làm cho chúng linh hoạt theo chiều dọc, nhưng cũng mong đợi các nhãn phát triển theo chiều ngang với bản dịch dài hơn.

00:18:03.000 --> 00:18:15.000
Có thể là một thách thức để phù hợp với điều đó trong một số bố cục nhất định, chẳng hạn như trong ví dụ này, nhưng năm nay, SwiftUI bổ sung hỗ trợ cho Grid, đây là một chế độ xem mới giúp bạn xây dựng loại bố cục này dễ dàng hơn.

00:18:15.000 --> 00:18:19.000
Chúng ta hãy xem xét kỹ hơn cách sử dụng Grid.

00:18:19.000 --> 00:18:22.000
Bạn bắt đầu bằng cách khai báo Lưới với một căn chỉnh hàng đầu.

00:18:22.000 --> 00:18:31.000
Điều đó có nghĩa là các phần tử giao diện người dùng bắt đầu ở phía bên trái của màn hình bằng ngôn ngữ từ trái sang phải và ở phía bên phải của màn hình bằng ngôn ngữ từ phải sang trái.

00:18:31.000 --> 00:18:35.000
Sau đó, đối với mỗi nhóm nằm ngang, bạn thêm một GridRow.

00:18:35.000 --> 00:18:38.000
Và cuối cùng bạn khai báo nội dung của các hàng.

00:18:38.000 --> 00:18:41.000
Đó là tất cả những gì cần thiết để tạo ra bố cục khá nâng cao này.

00:18:41.000 --> 00:18:48.000
Khi nhãn cần nhiều không gian hơn, Viên nang có thể thu nhỏ kích thước vì nó là yếu tố linh hoạt nhất.

00:18:48.000 --> 00:18:55.000
SwiftUI thực hiện tất cả các công việc nặng nhọc, chẳng hạn như đo lường, định cỡ và định vị chế độ xem - hoàn toàn tự động.

00:18:55.000 --> 00:19:02.000
Một thách thức khác là tạo ra chế độ xem với công việc dịch thuật dài hơn với dung lượng hạn chế, như trên Apple Watch.

00:19:02.000 --> 00:19:07.000
Ở đây, bản dịch tiếng Đức của "Tip Function" quá dài để nằm gọn trong một hàng.

00:19:07.000 --> 00:19:11.000
Để khắc phục điều này, chúng tôi không xóa biểu tượng bên cạnh văn bản để tạo thêm chỗ.

00:19:11.000 --> 00:19:17.000
Giải pháp là sử dụng hai hoặc nhiều dòng văn bản nếu cần, đó là hành vi mặc định.

00:19:17.000 --> 00:19:22.000
Chúng tôi không khuyến khích bạn thay đổi điều đó và ẩn các yếu tố giao diện nếu không có đủ dung lượng.

00:19:22.000 --> 00:19:28.000
Thông thường có một cách để điều chỉnh bố cục, để nó có thể đáp ứng nhu cầu của ngôn ngữ.

00:19:28.000 --> 00:19:32.000
Ứng dụng Mail thực hiện điều này một cách sáng tạo.

00:19:32.000 --> 00:19:37.000
Trong bản trình bày trang tính, có bốn nút để thực hiện hành động trên email này.

00:19:37.000 --> 00:19:43.000
Khi bản dịch của một trong các tiêu đề nút quá dài, chúng tôi không cắt văn bản hoặc bọc nó vào một dòng mới.

00:19:43.000 --> 00:19:45.000
Điều này sẽ làm cho tầm nhìn trông mất cân bằng.

00:19:45.000 --> 00:19:53.000
Thay vào đó, toàn bộ bố cục được chuyển từ ngăn xếp ngang sang ngăn xếp dọc gồm hai hàng.

00:19:53.000 --> 00:20:00.000
Năm nay, SwiftUI bổ sung thêm một công cụ tuyệt vời khác giúp tạo bố cục động này dễ dàng hơn: ViewThatFits.

00:20:00.000 --> 00:20:07.000
Về bản chất, nó cho phép bạn cung cấp các bố cục thay thế nếu không gian bị hạn chế và chế độ xem không phù hợp.

00:20:07.000 --> 00:20:13.000
Bạn chỉ cần tuyên bố quan điểm của mình một cách độc lập với nhau và đặt chúng vào ViewThatFits.

00:20:13.000 --> 00:20:19.000
SwiftUI tự động phát hiện nếu một chế độ xem không vừa mà không bị cắt và chuyển sang chế độ xem tiếp theo được cung cấp.

00:20:19.000 --> 00:20:22.000
Hãy nhớ rằng bạn chỉ nên chuyển đổi bố cục.

00:20:22.000 --> 00:20:26.000
Ẩn một góc nhìn chỉ vì bản dịch quá dài là một thực hành tồi.

00:20:26.000 --> 00:20:30.000
Điều đó khiến người dùng khó định hướng bản thân trong giao diện người dùng hơn.

00:20:30.000 --> 00:20:36.000
Cố gắng nhường chỗ cho tất cả các yếu tố giao diện trước bằng cách có bố cục linh hoạt.

00:20:36.000 --> 00:20:38.000
Điều này không chỉ hữu ích cho việc bản địa hóa.

00:20:38.000 --> 00:20:45.000
Bố cục này cũng hoạt động tốt khi người dùng thích có văn bản nhỏ hơn hoặc lớn hơn và sử dụng các thiết bị khác nhau.

00:20:45.000 --> 00:20:59.000
Để tìm hiểu thêm về các tính năng bố cục mới tuyệt vời của SwiftUI trong năm nay, tôi khuyên bạn nên xem bài nói chuyện "Sán bố cục tùy chỉnh với SwiftUI." Có các tùy chọn khả năng truy cập khác nhau và văn bản bản địa hóa có thể là một thách thức đối với bố cục của bạn.

00:20:59.000 --> 00:21:02.000
Các yếu tố giao diện có thể cao hơn và rộng hơn.

00:21:02.000 --> 00:21:09.000
Điều chỉnh bố cục để phù hợp với điều đó có thể là một thách thức, nhưng với SwiftUI, nó sẽ trở nên dễ dàng hơn rất nhiều trong năm nay.

00:21:09.000 --> 00:21:16.000
Tôi muốn bạn rút ra từ cuộc nói chuyện này rằng việc xây dựng một chuỗi trong mã có thể là một thách thức khi hỗ trợ các ngôn ngữ khác.

00:21:16.000 --> 00:21:23.000
Lắng nghe phản hồi mà người dùng và người thử nghiệm quốc tế của bạn cung cấp cho bạn để đảm bảo nó hoạt động tốt cho mọi người.

00:21:23.000 --> 00:21:27.000
Định dạng các giá trị trong Swift rất dễ dàng và nó thường chỉ mất một dòng mã duy nhất.

00:21:27.000 --> 00:21:33.000
Và làm điều đó, các giá trị được định dạng của bạn tự động tôn trọng sở thích của người dùng.

00:21:33.000 --> 00:21:42.000
Khi bạn đang cung cấp Gói Swift, hãy sử dụng quy trình bản địa hóa Xcode mới để cung cấp trải nghiệm được bản địa hóa hoàn toàn cho khách hàng của bạn.

00:21:42.000 --> 00:21:49.000
Bây giờ, có hoặc không sử dụng SwiftUI, bố cục của bạn sẽ có thể phù hợp với văn bản đã dịch và cài đặt khả năng truy cập.

00:21:49.000 --> 00:21:55.000
Sử dụng các công cụ bố cục của bạn để làm cho bố cục linh hoạt, mà không che giấu các yếu tố giao diện.

00:21:55.000 --> 00:22:03.000
Cuối cùng, người dùng của bạn sẽ biết ơn vì điều đó bởi vì họ mong đợi ứng dụng của bạn phù hợp với cuộc sống của họ và điều đó bao gồm cả việc tôn trọng ngôn ngữ của họ.

00:22:03.000 --> 00:22:06.000
Bây giờ, tôi đang mong chờ một tuần rất nắng.

00:22:06.000 --> 23:59:59.000
Tận hưởng phần còn lại của WWDC, và cảm ơn bạn đã xem.

