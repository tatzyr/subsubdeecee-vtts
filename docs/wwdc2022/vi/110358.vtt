WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:14.000
Xin chào, tôi là Richard, tôi là một kỹ sư trong nhóm Thư viện Tiêu chuẩn Swift.

00:00:14.000 --> 00:00:18.000
Hôm nay, hãy bắt tay vào một cuộc hành trình vượt ra ngoài những điều cơ bản của Swift Regex.

00:00:18.000 --> 00:00:23.000
Swift 5.7 đang đạt được những khả năng mới mạnh mẽ để xử lý chuỗi.

00:00:23.000 --> 00:00:28.000
Họ bắt đầu với loại 'Regex', một loại mới trong Thư viện Tiêu chuẩn Swift.

00:00:28.000 --> 00:00:36.000
Một ngôn ngữ tích hợp cú pháp theo nghĩa đen Regex, làm cho khái niệm mạnh mẽ và quen thuộc này thậm chí còn hạng nhất hơn.

00:00:36.000 --> 00:00:40.000
Và cuối cùng, một API xây dựng kết quả được gọi là RegexBuilder.

00:00:40.000 --> 00:00:54.000
Đây là một ngôn ngữ dành riêng cho miền, hoặc DSL, tận dụng sự đơn giản về cú pháp và khả năng kết hợp của các trình tạo kết quả, đồng thời đẩy khả năng đọc của Regex lên một cấp độ hoàn toàn mới.

00:00:54.000 --> 00:01:04.000
Để biết thông tin cơ bản về lý do tại sao Swift Regex giúp xử lý chuỗi dễ dàng hơn, hãy xem phiên Meet Swift Regex của đồng nghiệp Michael của tôi.

00:01:04.000 --> 00:01:07.000
Hãy xem một ví dụ rất đơn giản về Swift Regex.

00:01:07.000 --> 00:01:14.000
Giả sử tôi có một chuỗi dữ liệu và muốn khớp và trích xuất ID người dùng từ chuỗi này.

00:01:14.000 --> 00:01:21.000
Tôi có thể tạo một biểu thức chính quy từ văn bản như tôi thường làm với 'NSRegularExpression'.

00:01:21.000 --> 00:01:35.000
Nó khớp với dấu hai chấm "user_id" theo sau là không hoặc nhiều khoảng trắng theo sau là một hoặc nhiều chữ số. Điều khác biệt lần này là chúng tôi đang tạo ra một giá trị thuộc loại Regex.

00:01:35.000 --> 00:01:39.000
Đây là một loại mới trong Thư viện Tiêu chuẩn Swift.

00:01:39.000 --> 00:01:50.000
Sau đó, tôi có thể sử dụng thuật toán 'FirstMatch' của chuỗi để tìm sự xuất hiện đầu tiên của mẫu được xác định bởi Regex này và in toàn bộ kết quả khớp, giống như vậy.

00:01:50.000 --> 00:02:03.000
Bởi vì chuỗi Regex của tôi được biết đến tại thời điểm biên dịch, tôi có thể chuyển sang sử dụng ký tự Regex để trình biên dịch kiểm tra lỗi cú pháp và Xcode có thể hiển thị tô sáng cú pháp.

00:02:03.000 --> 00:02:09.000
Nhưng để có khả năng đọc và tùy chỉnh tối ưu, tôi có thể sử dụng trình tạo Regex DSL.

00:02:09.000 --> 00:02:17.000
Với trình tạo Regex, việc đọc nội dung của Regex dễ dàng như đọc Swift API gốc.

00:02:17.000 --> 00:02:23.000
Trong phiên này, tôi sẽ chỉ cho bạn cách Regex hoạt động và cách bạn có thể áp dụng Regex trong quy trình làm việc của mình.

00:02:23.000 --> 00:02:29.000
Regex là một chương trình được thực thi bởi công cụ Regex cơ bản của nó.

00:02:29.000 --> 00:02:38.000
Khi thực thi Regex, công cụ Regex nhận một chuỗi đầu vào và thực hiện khớp từ đầu đến cuối chuỗi.

00:02:38.000 --> 00:02:40.000
Hãy cùng xem một Regex rất đơn giản.

00:02:40.000 --> 00:02:48.000
Regex này khớp với một chuỗi bắt đầu bằng một hoặc nhiều chữ cái "a" theo sau là một hoặc nhiều chữ số.

00:02:48.000 --> 00:02:56.000
Tôi sử dụng một trong các thuật toán kết hợp, 'wholeMatch', để khớp đầu vào "aaa12".

00:02:56.000 --> 00:03:00.000
Công cụ Regex sẽ khởi động từ ký tự đầu tiên của đầu vào.

00:03:00.000 --> 00:03:04.000
Đầu tiên, nó khớp với một hoặc nhiều ký tự a.

00:03:04.000 --> 00:03:11.000
Tại thời điểm này, nó đạt đến ký tự "1" và cố gắng ghép nhân vật này với nhân vật "a".

00:03:11.000 --> 00:03:14.000
Nhưng nó không khớp.

00:03:14.000 --> 00:03:21.000
Vì vậy, công cụ Regex chuyển sang mẫu tiếp theo trong Regex, để khớp với một hoặc nhiều chữ số.

00:03:21.000 --> 00:03:25.000
Khi chúng ta đến cuối chuỗi, việc khớp sẽ thành công.

00:03:25.000 --> 00:03:31.000
Trong phần còn lại của phiên này, tôi sẽ giải thích thêm một chút về mô hình thực thi này.

00:03:31.000 --> 00:03:43.000
Với Regex được xây dựng trên công cụ Regex cơ bản của nó, DSL xây dựng Regex và các thuật toán hỗ trợ Regex mở rộng sức mạnh và tính biểu cảm của Regex.

00:03:43.000 --> 00:04:05.000
Các thuật toán được hỗ trợ bởi Regex là các API dựa trên bộ sưu tập cung cấp một số hoạt động phổ biến nhất như trận đấu đầu tiên, tìm thấy sự xuất hiện đầu tiên của Regex trong chuỗi, 'wholeMatch', khớp toàn bộ chuỗi với Regex, 'prefixMatch', khớp với tiền tố của chuỗi với Regex.

00:04:05.000 --> 00:04:17.000
Bên cạnh việc khớp, thư viện tiêu chuẩn Swift cũng đã thêm các API để dự đoán, thay thế, cắt tỉa và tách dựa trên Regex.

00:04:17.000 --> 00:04:28.000
Ngoài ra, Regex hiện có thể được sử dụng trong cú pháp khớp mẫu của Swift trong các câu lệnh luồng điều khiển, giúp việc chuyển đổi chuỗi dễ dàng hơn bao giờ hết.

00:04:28.000 --> 00:04:40.000
Cuối cùng, ngoài trình tạo Regex và các thuật toán do Regex cung cấp, năm nay, Foundation đã giới thiệu hỗ trợ Regex của riêng mình hoạt động liền mạch với trình tạo Regex.

00:04:40.000 --> 00:04:51.000
Hỗ trợ Regex trong Foundation không ai khác chính là các trình định dạng và trình phân tích cú pháp mà bạn có thể đang sử dụng, chẳng hạn như các trình định dạng và Số.

00:04:51.000 --> 00:04:59.000
Nếu bạn muốn tìm hiểu thêm về các API này, hãy xem phiên Có gì mới trong Foundation từ WWDC21.

00:04:59.000 --> 00:05:05.000
Năm nay, Foundation cũng đang bổ sung hỗ trợ định dạng và phân tích cú pháp URL.

00:05:05.000 --> 00:05:12.000
Với sự hỗ trợ của Regex trong Foundation, bạn có thể nhúng các trình phân tích cú pháp Foundation trực tiếp vào trình tạo Regex.

00:05:12.000 --> 00:05:26.000
Ví dụ: để phân tích cú pháp sao kê ngân hàng như thế này, tôi có thể sử dụng trình phân tích cú pháp ngày do Foundation cung cấp với định dạng tùy chỉnh và trình phân tích cú pháp tiền tệ với chiến lược phân tích cú pháp dành riêng cho miền.

00:05:26.000 --> 00:05:41.000
Đây là một vấn đề thực sự lớn bởi vì bạn có thể tạo Regexes từ các trình phân tích cú pháp được thử nghiệm chiến đấu hiện có để xử lý các trường hợp góc và hỗ trợ bản địa hóa, đồng thời soạn chúng với tính biểu hiện của trình tạo Regex DSL.

00:05:41.000 --> 00:05:47.000
Để chỉ cho bạn cách bạn có thể áp dụng Swift Regex vào quy trình làm việc của mình, hãy cùng nhau tìm ra một ví dụ.

00:05:47.000 --> 00:05:53.000
Tôi đã viết một tập lệnh để phân tích các bản ghi từ việc chạy các bài kiểm tra đơn vị dựa trên XCTest.

00:05:53.000 --> 00:05:58.000
Nhật ký kiểm tra bắt đầu và kết thúc với trạng thái của một bộ kiểm tra.

00:05:58.000 --> 00:06:05.000
Sau đó XCTest chạy mọi trường hợp thử nghiệm và báo cáo trạng thái của trường hợp thử nghiệm.

00:06:05.000 --> 00:06:09.000
Hôm nay chúng ta hãy phân tích cú pháp dòng đầu tiên và dòng cuối cùng của nhật ký.

00:06:09.000 --> 00:06:12.000
Đó là thông tin về một bộ kiểm tra.

00:06:12.000 --> 00:06:16.000
Đầu tiên, tôi nhập RegexBuilder.

00:06:16.000 --> 00:06:23.000
RegexBuilder là một mô-đun mới trong Thư viện Tiêu chuẩn Swift cung cấp RegexBuilder DSL.

00:06:23.000 --> 00:06:30.000
Regex có thể được khởi tạo với một phần đóng cuối đại diện cho phần thân của Regex.

00:06:30.000 --> 00:06:33.000
Hãy xem một thông báo nhật ký ví dụ.

00:06:33.000 --> 00:06:46.000
Có ba chuỗi con biến đổi mà chúng tôi quan tâm trong nhật ký này; tên của bộ kiểm tra, trạng thái, cho dù nó bắt đầu, vượt qua hay thất bại và dấu thời gian.

00:06:46.000 --> 00:06:54.000
Tôi có thể phân tích cú pháp các phần khác của nguyên văn dòng này, trong khi đưa ra một mẫu để phân tích ba chuỗi con biến đổi.

00:06:54.000 --> 00:07:02.000
Thông báo nhật ký bắt đầu bằng từ "bộ kiểm tra", theo sau là dấu cách và một trích dẫn duy nhất.

00:07:02.000 --> 00:07:05.000
Sau đó chúng tôi phân tích cú pháp tên của bộ kiểm tra.

00:07:05.000 --> 00:07:16.000
Tên là một mã định danh, có thể chứa các chữ cái hoặc chữ số viết thường hoặc viết hoa, nhưng ký tự đầu tiên không bao giờ có thể là một chữ số.

00:07:16.000 --> 00:07:21.000
Vì vậy, chúng tôi tạo ra một lớp ký tự tùy chỉnh để khớp một chữ cái làm ký tự đầu tiên.

00:07:21.000 --> 00:07:29.000
Sau đó, tôi khớp số không hoặc nhiều ký tự là một chữ cái hoặc một chữ số từ 0 đến số chín.

00:07:29.000 --> 00:07:34.000
Điều này rất rõ ràng và dễ đọc, nhưng nó hơi cồng kềnh.

00:07:34.000 --> 00:07:38.000
Nhiều người trong số các bạn có thể quen thuộc với cú pháp Regex văn bản.

00:07:38.000 --> 00:07:46.000
Trong RegexBuilder, tôi thực sự có thể nhúng một ký tự Regex súc tích trực tiếp vào cơ thể.

00:07:46.000 --> 00:07:50.000
Một Regex theo nghĩa đen bắt đầu và kết thúc bằng một dấu gạch chéo.

00:07:50.000 --> 00:07:53.000
Swift suy ra loại mạnh chính xác cho nó.

00:07:53.000 --> 00:07:59.000
Ví dụ, Regex này khớp với chuỗi con, "Xin chào, WWDC!".

00:07:59.000 --> 00:08:02.000
Vì vậy, loại đầu ra của nó là chuỗi con.

00:08:02.000 --> 00:08:09.000
Nhưng điều thực sự thú vị về một Regex hạng nhất theo nghĩa đen là các nhóm bắt được đánh máy mạnh mẽ.

00:08:09.000 --> 00:08:15.000
Ví dụ, tôi có thể viết một nhóm chụp để chụp hai chữ số như năm.

00:08:15.000 --> 00:08:19.000
Và đặt tên cho nhóm bắt giữ này, "năm".

00:08:19.000 --> 00:08:24.000
Khi tôi làm điều này, một chuỗi con khác sẽ xuất hiện trong loại đầu ra.

00:08:24.000 --> 00:08:30.000
Sau đó trong bài nói chuyện này, tôi sẽ chỉ cho bạn cách bạn có thể sử dụng ảnh chụp để trích xuất thông tin từ một chuỗi.

00:08:30.000 --> 00:08:41.000
Bên cạnh các ký tự Regex tiêu chuẩn, Swift cũng hỗ trợ các ký tự Regex mở rộng, bắt đầu bằng dấu gạch chéo pound và kết thúc bằng dấu gạch chéo pound.

00:08:41.000 --> 00:08:46.000
Chữ mở rộng cho phép các khoảng trắng không ngữ nghĩa.

00:08:46.000 --> 00:08:51.000
Trong chế độ này, bạn có thể chia các mẫu của mình thành nhiều dòng.

00:08:51.000 --> 00:08:57.000
Với một Regex literal được nhúng trong RegexBuilder của tôi, nó sạch sẽ và quen thuộc.

00:08:57.000 --> 00:09:03.000
Sau khi tôi phân tích cú pháp tên bài kiểm tra, tôi phân tích cú pháp một trích dẫn duy nhất và một khoảng trắng.

00:09:03.000 --> 00:09:05.000
Bây giờ tôi đạt đến trạng thái kiểm tra.

00:09:05.000 --> 00:09:11.000
Có nhiều loại trạng thái kiểm tra: bắt đầu, thất bại và vượt qua.

00:09:11.000 --> 00:09:16.000
Để phù hợp với một trong những tùy chọn này, chúng tôi sử dụng 'ChoiceOf'.

00:09:16.000 --> 00:09:22.000
'ChoiceOf' phù hợp với một trong nhiều mẫu con và đó chính xác là những gì chúng ta cần.

00:09:22.000 --> 00:09:32.000
Tiếp theo, chúng tôi phân tích những gì xuất hiện ngay sau trạng thái, một khoảng trắng theo sau là "at" theo sau là một khoảng trắng.

00:09:32.000 --> 00:09:34.000
Phần còn lại của chuỗi là dấu thời gian.

00:09:34.000 --> 00:09:39.000
Chúng ta có thể kết hợp điều này như một hoặc nhiều nhân vật của bất kỳ nhân vật nào.

00:09:39.000 --> 00:09:45.000
Nhưng khi tôi xem thêm một số ví dụ, một thông báo nhật ký đôi khi kết thúc bằng một dấu chấm.

00:09:45.000 --> 00:09:51.000
Chúng tôi vẫn muốn sử dụng 'Tùy chọn' để khớp với khoảng thời gian khi nó tồn tại.

00:09:51.000 --> 00:09:56.000
Để khớp đầu vào với Regex, hãy sử dụng một trong các thuật toán khớp được cung cấp.

00:09:56.000 --> 00:10:02.000
Hãy sử dụng 'wholeMatch', khớp toàn bộ chuỗi với Regex.

00:10:02.000 --> 00:10:08.000
Với 'wholeMatch', tôi khớp từng thông báo nhật ký này và in nội dung phù hợp.

00:10:08.000 --> 00:10:10.000
Nó phù hợp!

00:10:10.000 --> 00:10:13.000
Nhưng chúng tôi không chỉ muốn biết liệu nó có khớp với các chuỗi hay không.

00:10:13.000 --> 00:10:21.000
Chúng tôi cũng muốn trích xuất thông tin mà chúng tôi quan tâm, chẳng hạn như tên bài kiểm tra, trạng thái và dấu thời gian.

00:10:21.000 --> 00:10:26.000
Vì vậy, hãy tiếp tục và làm điều này với một trong những tính năng thú vị nhất của Regex, Captures!

00:10:26.000 --> 00:10:30.000
A Capture lưu một phần đầu vào trong quá trình khớp.

00:10:30.000 --> 00:10:38.000
Nó có sẵn dưới dạng "Chụp" trong RegexBuilder và dưới dạng một cặp dấu ngoặc đơn trong cú pháp Regex.

00:10:38.000 --> 00:10:44.000
Chụp nối thêm chuỗi con phù hợp vào loại bộ đầu ra.

00:10:44.000 --> 00:10:55.000
Một loại bộ đầu ra bắt đầu với toàn bộ chuỗi con khớp với toàn bộ Regex, tiếp theo là lần chụp đầu tiên, lần chụp thứ hai, v.v.

00:10:55.000 --> 00:11:03.000
Thuật toán kết hợp trả về một Regex Match, từ đó bạn có thể lấy bộ đầu ra.

00:11:03.000 --> 00:11:09.000
Toàn bộ trận đấu, lần chụp đầu tiên và lần chụp thứ hai.

00:11:09.000 --> 00:11:14.000
Hãy để tôi sử dụng ảnh chụp trong bộ kiểm tra của tôi nhật ký Regex.

00:11:14.000 --> 00:11:21.000
Tôi nắm bắt tên của bộ kiểm tra, trạng thái và dấu thời gian.

00:11:21.000 --> 00:11:27.000
Hãy chạy lại Regex này trên một số đầu vào và in ba thứ mà chúng tôi đã chụp được.

00:11:27.000 --> 00:11:30.000
Đó có vẻ là một trận đấu thành công!

00:11:30.000 --> 00:11:36.000
Nó đã in tên, trạng thái và dấu thời gian.

00:11:36.000 --> 00:11:40.000
Nhưng khi tôi nhìn kỹ, một cái gì đó trong buổi hẹn hò hơi khác một chút.

00:11:40.000 --> 00:11:45.000
Nó bao gồm khoảng thời gian trong đầu vào như một phần của việc chụp.

00:11:45.000 --> 00:11:49.000
Vậy hãy để tôi quay lại và kiểm tra Regex xem có lỗi không.

00:11:49.000 --> 00:11:53.000
Tôi muốn tập trung vào dấu thời gian Regex và xem có vấn đề gì với nó.

00:11:53.000 --> 00:12:04.000
Sau đó, tôi nhận ra, mẫu "một hoặc nhiều ký tự bất kỳ" tiêu thụ mọi thứ từ chữ số đầu tiên của dấu thời gian, cho đến cuối dòng.

00:12:04.000 --> 00:12:09.000
Vì vậy, mô hình "Kế đoạn tùy chọn" bên dưới nó không bao giờ khớp.

00:12:09.000 --> 00:12:14.000
Tôi có thể khắc phục điều này bằng cách làm cho OneOrMore này miễn cưỡng.

00:12:14.000 --> 00:12:18.000
"B miễn cưỡng" là một trường hợp của các hành vi lặp lại.

00:12:18.000 --> 00:12:25.000
Một hoặc nhiều, không hoặc nhiều, tùy chọn và lặp lại là những gì Swift Regex gọi là lặp lại.

00:12:25.000 --> 00:12:29.000
Một sự lặp lại là háo hức theo mặc định.

00:12:29.000 --> 00:12:32.000
Nó khớp với càng nhiều lần xuất hiện càng tốt.

00:12:32.000 --> 00:12:35.000
Hãy để tôi sử dụng ví dụ từ trước đó.

00:12:35.000 --> 00:12:48.000
Khi công cụ Regex cố gắng khớp với OneOrMore của bất kỳ ký tự nào một cách háo hức, nó sẽ bắt đầu với ký tự đầu tiên và nó chấp nhận bất kỳ ký tự nào trên đường đi cho đến khi kết thúc đầu vào.

00:12:48.000 --> 00:12:53.000
Sau đó, công cụ Regex chuyển sang khớp với khoảng thời gian Tùy chọn.

00:12:53.000 --> 00:12:59.000
Không còn khoảng thời gian nào để phù hợp nữa, nhưng dù sao nó cũng là tùy chọn, vì vậy nó đã thành công.

00:12:59.000 --> 00:13:08.000
Bởi vì chúng tôi đang chạy thuật toán 'wholeMatch', và cả đầu vào và mẫu Regex đều kết thúc, việc khớp thành công.

00:13:08.000 --> 00:13:18.000
Mặc dù kết hợp đã thành công, giai đoạn này đã được ghi lại một cách bất ngờ như một phần của OneOrMore.

00:13:18.000 --> 00:13:26.000
Khi chúng ta thay đổi hành vi lặp lại thành miễn cưỡng, công cụ Regex khớp với sự lặp lại hơi khác một chút.

00:13:26.000 --> 00:13:30.000
Nó khớp với càng ít ký tự càng tốt.

00:13:30.000 --> 00:13:44.000
Vì vậy, khi công cụ Regex khớp với chuỗi đầu vào lần này, nó cẩn thận tiến về phía trước bằng cách luôn cố gắng khớp với phần còn lại của Regex trước, trước khi tiêu thụ sự xuất hiện lặp lại.

00:13:44.000 --> 00:13:53.000
Khi phần còn lại của Regex không khớp, động cơ quay trở lại sự lặp lại và tiêu thụ một lần xuất hiện bổ sung.

00:13:53.000 --> 00:13:57.000
Hãy nhanh chóng chuyển tiếp đến nhân vật cuối cùng, khoảng thời gian.

00:13:57.000 --> 00:14:08.000
Không giống như hành vi háo hức, công cụ Regex ban đầu không tiêu thụ khoảng thời gian như một phần của OneOrMore, mà thay vào đó cố gắng khớp với mô hình "Kếp thời gian tùy chọn".

00:14:08.000 --> 00:14:13.000
Điều này phù hợp, và công cụ Regex đạt đến cuối mẫu.

00:14:13.000 --> 00:14:21.000
Vì vậy, việc kết hợp thành công, và nó tạo ra sự bắt giữ chính xác mà không có một khoảng thời gian kéo dài trong đó.

00:14:21.000 --> 00:14:30.000
Bởi vì háo hức là hành vi mặc định, khi bạn tạo Regex của mình bằng cách sử dụng sự lặp lại, bạn nên suy nghĩ về ý nghĩa của nó đối với trận đấu dự định của bạn.

00:14:30.000 --> 00:14:45.000
Bạn có thể chỉ định hành vi ở cấp độ lặp lại, bằng cách chuyển một đối số bổ sung hoặc, bạn có thể sử dụng công cụ sửa đổi 'repetitionBehavior' để ghi đè nó cho tất cả các lần lặp lại không chỉ định hành vi.

00:14:45.000 --> 00:14:58.000
Vì chúng tôi đã sửa đổi hành vi lặp lại để dấu thời gian miễn cưỡng, Matching bây giờ trích xuất dấu thời gian phù hợp mà không bao gồm dấu thời gian.

00:14:58.000 --> 00:15:01.000
Hãy quay lại Regex.

00:15:01.000 --> 00:15:08.000
Khi tôi sử dụng Capture để trích xuất trạng thái kiểm tra từ đầu vào, loại của nó là Chuỗi con.

00:15:08.000 --> 00:15:16.000
Nhưng sẽ tốt hơn nhiều nếu tôi có thể chuyển đổi chuỗi con thành thứ gì đó thân thiện hơn với lập trình, như cấu trúc dữ liệu tùy chỉnh.

00:15:16.000 --> 00:15:19.000
Để làm điều này, tôi có thể sử dụng chụp chuyển đổi.

00:15:19.000 --> 00:15:25.000
Chụp biến đổi là Chụp với đóng biến đổi.

00:15:25.000 --> 00:15:36.000
Sau khi khớp, công cụ Regex gọi đóng biến đổi trên chuỗi con được khớp, tạo ra kết quả của loại mong muốn.

00:15:36.000 --> 00:15:41.000
Loại đầu ra Regex tương ứng trở thành kiểu trả về của đóng.

00:15:41.000 --> 00:15:50.000
Ở đây, bằng cách chuyển đổi ảnh chụp bằng trình khởi tạo của Int từ String, tôi nhận được một Int tùy chọn trong loại bộ đầu ra.

00:15:50.000 --> 00:15:55.000
Để có được đầu ra không tùy chọn, TryCapture có thể trợ giúp.

00:15:55.000 --> 00:16:05.000
TryCapture là một biến thể của Capture chấp nhận một biến đổi trả về một tùy chọn và loại bỏ tính tùy chọn trong loại đầu ra.

00:16:05.000 --> 00:16:13.000
Trả về nil trong quá trình khớp sẽ khiến công cụ Regex quay lại và thử một đường dẫn thay thế.

00:16:13.000 --> 00:16:20.000
TryCapture hữu ích nhất khi bạn chuyển đổi ảnh chụp bằng trình khởi tạo không thể thất bại.

00:16:20.000 --> 00:16:25.000
Một sự phù hợp tự nhiên để lưu trữ trạng thái kiểm tra đã chụp, sẽ là một bảng liệt kê.

00:16:25.000 --> 00:16:28.000
Vậy hãy định nghĩa một cái.

00:16:28.000 --> 00:16:34.000
Tôi đã xác định một TestStatus enum với ba trường hợp: bắt đầu, vượt qua và thất bại.

00:16:34.000 --> 00:16:40.000
Các giá trị chuỗi thô làm cho enum này có thể khởi tạo từ một chuỗi.

00:16:40.000 --> 00:16:44.000
Trong Regex, tôi chuyển sang 'TryCapture' với một phép biến đổi.

00:16:44.000 --> 00:16:53.000
Trong phần đóng biến đổi, tôi gọi trình khởi tạo TestStatus để chuyển đổi chuỗi con phù hợp thành giá trị TestStatus.

00:16:53.000 --> 00:16:57.000
Bây giờ loại đầu ra tương ứng là TestStatus.

00:16:57.000 --> 00:17:03.000
Sử dụng cấu trúc dữ liệu tùy chỉnh như thế này làm cho loại đầu ra khớp Regex an toàn.

00:17:03.000 --> 00:17:04.000
Quay lại Regex.

00:17:04.000 --> 00:17:08.000
Có một cải tiến bổ sung mà tôi muốn thực hiện.

00:17:08.000 --> 00:17:12.000
Hiện tại, tôi khớp dấu thời gian bằng cách sử dụng mẫu ký tự đại diện.

00:17:12.000 --> 00:17:15.000
Nó sẽ tạo ra một chuỗi con.

00:17:15.000 --> 00:17:24.000
Điều này có nghĩa là nếu ứng dụng của tôi muốn hiểu dấu thời gian, nó sẽ phải phân tích chuỗi con một lần nữa thành một cấu trúc dữ liệu khác.

00:17:24.000 --> 00:17:33.000
Trước đó trong phiên họp, tôi đã đề cập rằng Foundation hiện hỗ trợ Swift Regex, cung cấp các trình phân tích cú pháp sức mạnh của ngành như Regexes.

00:17:33.000 --> 00:17:45.000
Vì vậy, thay vì phân tích cú pháp ngày như một chuỗi con, tôi có thể chuyển sang trình phân tích cú pháp ngày ISO 8601 của Foundation để phân tích dấu thời gian dưới dạng ngày.

00:17:45.000 --> 00:17:50.000
Bây giờ loại suy ra cho thấy Regex này xuất ra một Ngày.

00:17:50.000 --> 00:17:58.000
Khi tôi chạy 'wholeMatch' trên các đầu vào, tôi có thể thấy rằng chuỗi ngày đã được phân tích cú pháp thành giá trị Ngày nền tảng.

00:17:58.000 --> 00:18:07.000
Có quyền truy cập vào các trình phân tích cú pháp được kiểm tra chiến đấu dưới dạng Regex, giống như trình phân tích cú pháp ngày Foundation, cực kỳ tiện dụng trong các tác vụ xử lý chuỗi hàng ngày.

00:18:07.000 --> 00:18:16.000
Tiếp theo, tôi sẽ chỉ cho bạn một tính năng nâng cao, sử dụng lại trình phân tích cú pháp đã có từ trước được xác định ở nơi khác trong Swift Regex.

00:18:16.000 --> 00:18:20.000
Hãy xem xét một ví dụ mà chúng ta muốn phân tích thời lượng của một trường hợp thử nghiệm.

00:18:20.000 --> 00:18:26.000
Thời lượng là một số dấu phẩy động, chẳng hạn như, 0, 0,001.

00:18:26.000 --> 00:18:34.000
Tất nhiên, cách tốt nhất để làm điều này là sử dụng trình phân tích cú pháp dấu phẩy động do Foundation cung cấp với sự hỗ trợ đầy đủ cho việc bản địa hóa.

00:18:34.000 --> 00:18:46.000
Nhưng hôm nay, tôi muốn chỉ cho bạn những gì dưới mui xe và cách bạn có thể tự kết nối với công cụ Regex để tận dụng trình phân tích cú pháp hiện có để phân tích cú pháp số dấu phẩy động.

00:18:46.000 --> 00:18:51.000
'Strtod' là một hàm từ thư viện chuẩn C.

00:18:51.000 --> 00:19:00.000
Nó lấy một con trỏ chuỗi, phân tích cú pháp chuỗi cơ bản và gán vị trí kết thúc của trận đấu cho con trỏ kết thúc.

00:19:00.000 --> 00:19:03.000
Hãy phân tích thời lượng, cách C.

00:19:03.000 --> 00:19:12.000
Để làm điều này, tôi có thể tự xác định một loại trình phân tích cú pháp và làm cho nó phù hợp với giao thức CustomConsumingRegexComponent.

00:19:12.000 --> 00:19:16.000
Tôi định nghĩa một cấu trúc có tên là CDoubleParser.

00:19:16.000 --> 00:19:22.000
'RegexOutput' của nó là Double, bởi vì chúng tôi đang phân tích cú pháp một số Double.

00:19:22.000 --> 00:19:33.000
Trong phương pháp "tiêu thụ", chúng tôi thực hiện cuộc gọi đến trình phân tích cú pháp kép từ thư viện tiêu chuẩn C, chuyển các con trỏ chuỗi đến nó và lấy lại một số.

00:19:33.000 --> 00:19:41.000
Trong nội dung phương thức, tôi sử dụng phương thức withCString để lấy địa chỉ bắt đầu.

00:19:41.000 --> 00:19:49.000
Sau đó, tôi gọi hàm 'strtod' C, chuyển địa chỉ bắt đầu và con trỏ để nhận địa chỉ kết thúc kết quả.

00:19:49.000 --> 00:19:51.000
Sau đó tôi kiểm tra lỗi.

00:19:51.000 --> 00:19:57.000
Khi phân tích cú pháp thành công, địa chỉ kết thúc lớn hơn địa chỉ bắt đầu.

00:19:57.000 --> 00:20:01.000
Nếu không, đó là một lỗi phân tích cú pháp, vì vậy tôi trả về số không.

00:20:01.000 --> 00:20:07.000
Tôi tính giới hạn trên của trận đấu từ con trỏ được tạo ra bởi C API.

00:20:07.000 --> 00:20:12.000
Và cuối cùng, tôi trả về giới hạn trên của trận đấu và đầu ra số.

00:20:12.000 --> 00:20:19.000
Tôi có thể quay lại Regex và sử dụng 'CDoubleParser' của mình trực tiếp trong Regex.

00:20:19.000 --> 00:20:23.000
Loại đầu ra được suy ra là Double.

00:20:23.000 --> 00:20:30.000
Khi tôi gọi 'wholeMatch' và in số được phân tích cú pháp, nó xuất ra 0,001, như tôi mong đợi.

00:20:30.000 --> 00:20:42.000
Tóm lại, hôm nay chúng ta đã nói về một số cách sử dụng phổ biến và nâng cao của Swift Regex, một tính năng mới trong Swift 5.7 cho phép bạn tích hợp sức mạnh của xử lý chuỗi trong ứng dụng của mình.

00:20:42.000 --> 00:20:53.000
Một phương pháp hay khi sử dụng Swift Regex là cố gắng đạt được sự cân bằng tốt giữa độ chính xác và khả năng đọc, đặc biệt là khi bạn kết hợp các ký tự RegexBuilder DSL và Regex.

00:20:53.000 --> 00:21:07.000
Khi bạn gặp phải các mẫu phổ biến như ngày tháng và URL, hãy luôn thích các trình phân tích cú pháp sức mạnh của ngành do Foundation cung cấp, vì việc phân tích cú pháp các mẫu này bằng mã tùy chỉnh có thể dễ bị lỗi.

00:21:07.000 --> 00:21:14.000
Để biết thêm thông tin về Swift Regex, hãy xem loạt đề xuất xử lý chuỗi khai báo trên Swift Evolution.

00:21:14.000 --> 00:21:18.000
Tôi hy vọng bạn sẽ thích xử lý chuỗi với Swift.

00:21:18.000 --> 23:59:59.000
Cảm ơn bạn, và chúc bạn có một WWDC tuyệt vời.

