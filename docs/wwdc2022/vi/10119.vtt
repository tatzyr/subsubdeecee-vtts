WEBVTT

00:00:01.000 --> 00:00:14.000
Xin chào, tôi là Nick Gillett, một kỹ sư ở đây tại Apple trong nhóm Core Data.

00:00:14.000 --> 00:00:21.000
Trong phiên này, tôi sẽ chỉ cho bạn cách sử dụng các công cụ dành cho nhà phát triển của chúng tôi để tìm hiểu thêm về các ứng dụng của bạn sử dụng NSPersistentCloudKitContainer.

00:00:21.000 --> 00:00:28.000
Chúng ta sẽ bắt đầu với một cái nhìn chi tiết về cách khám phá các ứng dụng một cách hiệu quả và mang tính giáo dục.

00:00:28.000 --> 00:00:33.000
Sau đó, chúng tôi sẽ sử dụng một số công cụ yêu thích của tôi để phân tích cách các ứng dụng hoạt động.

00:00:33.000 --> 00:00:42.000
Và cuối cùng, chúng tôi sẽ xem xét cách bạn có thể cung cấp phản hồi chi tiết, có thể hành động về trải nghiệm của mình với NSPersistentCloudKitContainer.

00:00:42.000 --> 00:00:46.000
Tôi thích nghĩ về kỹ thuật giống như chu trình nước.

00:00:46.000 --> 00:00:51.000
Thông thường, tôi bắt đầu làm việc trên một tính năng bằng cách khám phá không gian mà tính năng tồn tại.

00:00:51.000 --> 00:01:00.000
Sau đó, dựa trên những điều tôi học được, tôi sử dụng kết hợp các công cụ và bài kiểm tra để phân tích công việc của mình trong một môi trường có thể tái tạo.

00:01:00.000 --> 00:01:07.000
Cuối cùng, tôi xem lại kết quả với các đồng nghiệp và đồng nghiệp của mình và thu thập phản hồi của họ.

00:01:07.000 --> 00:01:12.000
Mục tiêu của chu kỳ này là nắm bắt lâu dài những điều tôi học được khi làm việc.

00:01:12.000 --> 00:01:21.000
Các nền tảng của Apple bao gồm nhiều lựa chọn công cụ như Xcode, Instruments và XCTest mà tôi sử dụng để nắm bắt những gì tôi học được.

00:01:21.000 --> 00:01:30.000
Những công cụ đó cũng giúp thu thập vô số thông tin chẩn đoán mà tôi có thể sử dụng để cung cấp phản hồi có thể hành động.

00:01:30.000 --> 00:01:34.000
Phiên này tham khảo rất nhiều kiến thức từ những năm trước.

00:01:34.000 --> 00:01:51.000
Tôi đã thảo luận chi tiết về NSPersistentCloudKitContainer và ứng dụng Core Data CloudKit Sample mà tôi sẽ trình bày chi tiết hôm nay trong các phiên "Xây dựng các ứng dụng chia sẻ dữ liệu thông qua CloudKit và Core Data" và trong phiên "Sử dụng dữ liệu cốt lõi với CloudKit".

00:01:51.000 --> 00:02:00.000
Tôi cũng sẽ trình bày cách sử dụng Xcode và Instruments để chạy các bài kiểm tra và trình tổ chức Thiết bị để thu thập dữ liệu từ các thiết bị.

00:02:00.000 --> 00:02:14.000
Nếu bạn cần, tôi khuyên bạn nên xem lại các phiên "Bắt đầu với các công cụ" và "Chẩn đoán các vấn đề về hiệu suất với Trình tổ chức Xcode" để tìm hiểu thêm về hai phần quan trọng này của chuỗi công cụ.

00:02:14.000 --> 00:02:19.000
Được rồi, hãy bắt đầu với phần đầu tiên của chu kỳ, khám phá.

00:02:19.000 --> 00:02:24.000
Đối với tôi, mục tiêu chính của việc khám phá là học hỏi.

00:02:24.000 --> 00:02:30.000
Tôi muốn thách thức và xác minh tất cả các giả định mà tôi có về cách một ứng dụng sẽ hoạt động.

00:02:30.000 --> 00:02:34.000
Tôi có thể hỏi: Điều gì sẽ xảy ra nếu tôi nhấn vào nút này?

00:02:34.000 --> 00:02:39.000
NSPersistentCloudKitContainer có đồng bộ hóa khi tôi lưu dữ liệu vào một cửa hàng liên tục không?

00:02:39.000 --> 00:02:44.000
Một ứng dụng có hết bộ nhớ khi làm việc với một tập dữ liệu lớn không?

00:02:44.000 --> 00:02:51.000
Từ quan điểm của Core Data, tất cả những câu hỏi này đều bị ảnh hưởng bởi dữ liệu mà ứng dụng làm việc.

00:02:51.000 --> 00:02:58.000
Ví dụ, ứng dụng mẫu Core Data CloudKit sử dụng mô hình dữ liệu này.

00:02:58.000 --> 00:03:04.000
Nó quản lý một tập hợp các bài đăng có một số trường văn bản cho tiêu đề và nội dung.

00:03:04.000 --> 00:03:10.000
Các bài đăng có thể liên quan đến tệp đính kèm, nói chung là hình ảnh, có thể khá lớn.

00:03:10.000 --> 00:03:17.000
Do đó, ImageData được lưu trữ trên mối quan hệ 1-1 để nó có thể được tải theo yêu cầu.

00:03:17.000 --> 00:03:30.000
Và tôi sẽ tập trung khám phá vào tập dữ liệu đó, cụ thể là những gì xảy ra với ứng dụng mẫu khi tôi thay đổi hình dạng, cấu trúc và phương sai của dữ liệu đó.

00:03:30.000 --> 00:03:36.000
Kể từ khi phát hành, ứng dụng mẫu đã bao gồm một cách tích hợp để khám phá nó.

00:03:36.000 --> 00:03:41.000
Nút Tạo 1000 Bài đăng thực hiện chính xác những gì nó ghi trên nhãn.

00:03:41.000 --> 00:03:47.000
Khi được nhấn, nó sẽ tạo ra một bộ dữ liệu mẫu gồm 1.000 bài đăng với tiêu đề ngắn.

00:03:47.000 --> 00:03:50.000
Chế độ xem bảng Bài đăng dễ dàng xử lý mức dữ liệu này.

00:03:50.000 --> 00:03:59.000
Vì vậy, câu hỏi tiếp theo tôi sẽ hỏi là, làm thế nào tôi có thể khám phá một tập dữ liệu có hình dạng hoặc kích thước khác nhau trong ứng dụng này?

00:03:59.000 --> 00:04:05.000
Nút Tạo 1000 Bài đăng chạy cái mà tôi muốn gọi là trình tạo dữ liệu thuật toán.

00:04:05.000 --> 00:04:17.000
Các trình tạo dữ liệu thuật toán tuân theo một tập hợp các quy tắc được xác định trước như "chèn 1000 đối tượng" hoặc "đảm bảo rằng mọi trường đều có giá trị hoặc không có trường nào có giá trị."

00:04:17.000 --> 00:04:21.000
Hóa ra, chúng tôi cũng là những người tạo ra dữ liệu.

00:04:21.000 --> 00:04:34.000
Chúng ta có thể thủ công các bộ dữ liệu cụ thể trong mã, trong SQL hoặc bằng cách tương tác trực tiếp với một ứng dụng và các bộ dữ liệu được tạo này có thể được bảo toàn để sử dụng hoặc phân tích sau này.

00:04:34.000 --> 00:04:46.000
Để khám phá một tập dữ liệu lớn hơn, tôi có thể xác định một trình tạo dữ liệu mới, LargeDataGenerator, và cung cấp cho nó một phương thức duy nhất, generateData, để xây dựng tập dữ liệu mới của tôi.

00:04:46.000 --> 00:04:54.000
Chỉ với hai vòng lặp for, tôi có thể tạo ra một bộ 60 bài đăng mà mỗi bài có 11 tệp đính kèm hình ảnh được liên kết với chúng.

00:04:54.000 --> 00:04:57.000
Đó là tổng cộng 660 hình ảnh.

00:04:57.000 --> 00:05:06.000
Với kích thước trung bình 10-20 megabyte mỗi hình ảnh, tập dữ liệu được tạo ra tiêu thụ gần 10GB dữ liệu.

00:05:06.000 --> 00:05:12.000
Với một giao diện đơn giản như vậy, các trình tạo dữ liệu dễ dàng được gọi trong các bài kiểm tra như thế này.

00:05:12.000 --> 00:05:20.000
Dòng mã duy nhất này tạo ra hơn 10GB dữ liệu đại diện cho bài kiểm tra này để sử dụng.

00:05:20.000 --> 00:05:33.000
Ngoài ra, chúng tôi có thể xây dựng các phương pháp xác thực trong các bài kiểm tra xác minh trình tạo dữ liệu hoạt động chính xác, như khẳng định rằng mỗi bài đăng thực sự nhận được 11 tệp đính kèm hình ảnh.

00:05:33.000 --> 00:05:39.000
Tất nhiên, đây sẽ không phải là cuộc nói chuyện về NSPersistentCloudKitContainer nếu chúng ta không đồng bộ hóa dữ liệu này.

00:05:39.000 --> 00:05:43.000
Vì vậy, hãy tạo ra một bài kiểm tra mới để làm điều đó.

00:05:43.000 --> 00:05:49.000
Điều đầu tiên tôi cần là một phiên bản của NSPersistentCloudKitContainer để sử dụng.

00:05:49.000 --> 00:05:52.000
Tôi đã tạo ra một phương pháp trợ giúp để làm điều đó dễ dàng.

00:05:52.000 --> 00:05:59.000
Tiếp theo, tôi sử dụng LargeDataGenerator để điền vào vùng chứa với tập dữ liệu mong muốn của tôi.

00:05:59.000 --> 00:06:04.000
Và cuối cùng, tôi đợi vùng chứa hoàn thành việc xuất dữ liệu.

00:06:04.000 --> 00:06:11.000
Trong bài kiểm tra cụ thể này, tôi đợi tối đa 20 phút để cung cấp thời gian thiết lập dữ liệu lớn để tải lên.

00:06:11.000 --> 00:06:18.000
Con đại bàng để mắt trong số các bạn có thể nhận thấy rằng bài kiểm tra này dường như đang chờ đợi rất nhiều loại sự kiện khác nhau.

00:06:18.000 --> 00:06:24.000
Ở đây, khi tôi tạo vùng chứa, tôi đợi vùng chứa hoàn tất việc thiết lập.

00:06:24.000 --> 00:06:32.000
Và ở đây, tôi sử dụng một phương pháp trợ giúp mà tôi đã viết để tạo XCTestExpectations cho một sự kiện xuất từ vùng chứa.

00:06:32.000 --> 00:06:34.000
Hãy xem xét điều đó một cách chi tiết.

00:06:34.000 --> 00:06:41.000
Phương pháp này lấy một loại sự kiện mong muốn và một thể hiện của NSPersistentCloudKitContainer làm đối số.

00:06:41.000 --> 00:06:55.000
Nó tạo ra một kỳ vọng cho mỗi cửa hàng liên tục trong vùng chứa bằng cách sử dụng phương thức expectationForNotification của XCTestCase để quan sát thông báo eventChanged của NSPersistentCloudKitContainer.

00:06:55.000 --> 00:07:08.000
Trong khối trình xử lý thông báo, tôi xác minh rằng sự kiện đến thuộc loại chính xác cho cửa hàng cụ thể mà kỳ vọng này dành cho và nó được kết thúc bằng cách kiểm tra endDate không bằng số không.

00:07:08.000 --> 00:07:17.000
Bằng cách sử dụng kỹ thuật này, chúng tôi có thể liên kết mạnh mẽ các điểm kiểm soát trong các bài kiểm tra của mình với các sự kiện từ NSPersistentCloudKitContainer.

00:07:17.000 --> 00:07:24.000
Quay lại bài kiểm tra của mình, tôi thêm một vùng chứa mới để nhập dữ liệu vừa được xuất.

00:07:24.000 --> 00:07:26.000
Kỹ thuật này sử dụng một thủ thuật.

00:07:26.000 --> 00:07:31.000
Nó tạo ra một phiên bản mới của NSPersistentCloudKitContainer với các tệp lưu trữ trống.

00:07:31.000 --> 00:07:42.000
Điều này cho phép thử nghiệm tận dụng lợi thế của lần nhập lần đầu tiên của NSPersistentCloudKitContainer để khám phá điều gì sẽ xảy ra khi tất cả dữ liệu này được tải xuống bởi một thiết bị.

00:07:42.000 --> 00:07:48.000
Bây giờ, các bài kiểm tra rất tuyệt, nhưng đôi khi tôi muốn cảm nhận cách một tập dữ liệu hoạt động trong một ứng dụng.

00:07:48.000 --> 00:07:56.000
Để làm điều đó, tôi có thể liên kết các trình tạo dữ liệu với giao diện người dùng, như chúng tôi đã làm trong ứng dụng mẫu.

00:07:56.000 --> 00:08:02.000
Khi tôi nhấn vào nút Tạo Dữ liệu Lớn, tôi có thể xem trình tạo dữ liệu điền vào tập dữ liệu.

00:08:02.000 --> 00:08:12.000
Trên thiết bị thứ hai, tôi có thể xem chế độ xem bảng được điền khi NSPersistentCloudKitContainer tiến hành tải xuống dữ liệu đã tạo.

00:08:12.000 --> 00:08:22.000
Nhấn vào một bài đăng riêng lẻ cho phép tôi xem các tệp đính kèm tải xuống và điền dần dần, giống như đối với người dùng ứng dụng này.

00:08:22.000 --> 00:08:27.000
Giao diện người dùng cụ thể này được điều khiển bởi một bộ điều khiển cảnh báo.

00:08:27.000 --> 00:08:34.000
Giao diện đơn giản của LargeDataGenerator giúp dễ dàng thêm một hành động cảnh báo mới chỉ với hai dòng mã này.

00:08:34.000 --> 00:08:39.000
Nó rõ ràng, súc tích và dễ hiểu.

00:08:39.000 --> 00:08:46.000
Trong phần này, chúng tôi đã khám phá hành vi của một ứng dụng sử dụng khái niệm về trình tạo dữ liệu.

00:08:46.000 --> 00:09:01.000
Trình tạo dữ liệu có thể được điều khiển trong các ứng dụng của chúng tôi theo bất kỳ cách nào chúng tôi chọn, cho dù đó là bằng các bài kiểm tra hoặc giao diện người dùng tùy chỉnh, như tôi đã chứng minh, hoặc bằng một cái gì đó giống như đối số dòng lệnh hoặc bất kỳ thứ gì khác xảy ra để hoạt động cho trường hợp sử dụng cụ thể của bạn

00:09:01.000 --> 00:09:08.000
Bây giờ chúng tôi đã biết cách điền dữ liệu vào ứng dụng, chúng tôi đã sẵn sàng phân tích cách điều đó thay đổi hành vi của ứng dụng.

00:09:08.000 --> 00:09:16.000
Trong phần này, chúng ta sẽ tìm hiểu về một số công cụ và kỹ thuật để phân tích cách một ứng dụng hoạt động với một tập dữ liệu lớn.

00:09:16.000 --> 00:09:25.000
Cụ thể, chúng tôi sẽ sử dụng Công cụ để phân tích độ phức tạp về thời gian và bộ nhớ của tập dữ liệu do LargeDataGenerator tạo ra.

00:09:25.000 --> 00:09:30.000
Sau đó, chúng tôi sẽ xem xét sự phong phú của thông tin có sẵn cho chúng tôi trong nhật ký hệ thống.

00:09:30.000 --> 00:09:39.000
Ở đó chúng ta có thể tìm thấy bản ghi hoạt động từ NSPersistentCloudKitContainer, CloudKit, bộ lập lịch hệ thống và từ các thông báo đẩy.

00:09:39.000 --> 00:09:42.000
Hãy nhìn chằm chằm vào Nhạc cụ.

00:09:42.000 --> 00:09:49.000
Một lý do tôi thích các bài kiểm tra là Xcode giúp dễ dàng phân tích hành vi của bài kiểm tra.

00:09:49.000 --> 00:09:55.000
Trong trường hợp thử nghiệm của tôi, tôi có thể nhấp chuột phải vào tiết lộ thử nghiệm trong máng xối và chọn Hồ sơ.

00:09:55.000 --> 00:10:00.000
Xcode sẽ xây dựng các bài kiểm tra và sau đó tự động khởi chạy các công cụ.

00:10:00.000 --> 00:10:07.000
Tôi có thể nhấp đúp vào công cụ Time Profiler để kiểm tra xem bài kiểm tra của tôi dành thời gian làm việc ở đâu.

00:10:07.000 --> 00:10:14.000
Khi tôi nhấp vào nút ghi, Instruments sẽ khởi chạy ứng dụng và thực hiện bài kiểm tra đã chọn.

00:10:14.000 --> 00:10:18.000
Bài kiểm tra này dường như mất khá nhiều thời gian để chạy.

00:10:18.000 --> 00:10:21.000
Hãy bỏ qua phía trước và xem tại sao.

00:10:21.000 --> 00:10:30.000
Các công cụ đã chọn chủ đề chính và ở phía bên phải, tôi có thể thấy dấu vết ngăn xếp nặng nhất của quá trình chạy thử.

00:10:30.000 --> 00:10:36.000
Hãy làm cho nó dễ đọc hơn một chút.

00:10:36.000 --> 00:10:38.000
Vậy là xong.

00:10:38.000 --> 00:10:45.000
Bây giờ, nếu tôi cuộn xuống dưới cùng, tôi có thể thấy LargeDataGenerator đang dành rất nhiều thời gian để tạo hình thu nhỏ.

00:10:45.000 --> 00:10:50.000
Chúng ta sẽ quyết định đây là lỗi hay tính năng như thế nào?

00:10:50.000 --> 00:10:56.000
Trong LargeDataGenerator, tôi có dòng mã này tạo ra một hình thu nhỏ mới cho mỗi tệp đính kèm.

00:10:56.000 --> 00:11:01.000
Tuy nhiên, tôi biết từ mô hình dữ liệu của ứng dụng rằng hình thu nhỏ rất đặc biệt.

00:11:01.000 --> 00:11:05.000
Chúng được tính toán theo yêu cầu từ Dữ liệu hình ảnh liên quan.

00:11:05.000 --> 00:11:11.000
Điều đó có nghĩa là dòng này là không cần thiết, và trình tạo dữ liệu của tôi đang lãng phí rất nhiều thời gian cho chúng.

00:11:11.000 --> 00:11:14.000
Vì vậy tôi chỉ có thể loại bỏ nó.

00:11:14.000 --> 00:11:17.000
Hãy xem điều đó thay đổi hiệu suất của bài kiểm tra như thế nào.

00:11:17.000 --> 00:11:23.000
Sau khi xây dựng lại ứng dụng với trình tạo dữ liệu được cập nhật, tôi có thể chạy lại bài kiểm tra trong Instruments.

00:11:23.000 --> 00:11:32.000
Và thành thật mà nói tôi không thấy nhiều thay đổi, nhưng sau vài giây nữa, bài kiểm tra sẽ hoàn thành.

00:11:32.000 --> 00:11:35.000
Điều đó nhanh hơn rất nhiều so với lần chạy trước.

00:11:35.000 --> 00:11:43.000
Hãy xem bài kiểm tra đã dành phần lớn thời gian ở đâu.

00:11:43.000 --> 00:11:55.000
Trong ngăn kéo bên phải, bây giờ tôi thấy rằng dấu vết ngăn xếp nặng nhất đang lưu hình ảnh vào cửa hàng liên tục và đó chính xác là những gì tôi mong đợi cho một bài kiểm tra quản lý nhiều dữ liệu này.

00:11:55.000 --> 00:12:02.000
Một thay đổi đó đã giảm thời gian chạy của bài kiểm tra generateData từ cái này xuống cái này.

00:12:02.000 --> 00:12:05.000
Nó thực hiện trong một phần mười thời gian.

00:12:05.000 --> 00:12:16.000
Phân tích các bài kiểm tra theo cách này không phải lúc nào cũng phát hiện ra lỗi, Đôi khi chúng ta chỉ tìm hiểu thêm về nơi một ứng dụng đang dành thời gian khi làm việc với một tập dữ liệu cụ thể.

00:12:16.000 --> 00:12:19.000
Nhưng dù bằng cách nào, đó cũng là việc học có giá trị.

00:12:19.000 --> 00:12:26.000
Vì vậy, đó là cách công cụ Time Profiler có thể giúp khám phá nơi một ứng dụng dành thời gian với một tập dữ liệu.

00:12:26.000 --> 00:12:33.000
Bây giờ, vì kích thước của tập dữ liệu này, tôi cũng tò mò bài kiểm tra sử dụng bao nhiêu bộ nhớ.

00:12:33.000 --> 00:12:37.000
Vì vậy, hãy chạy nó bằng cách sử dụng công cụ Phân bổ.

00:12:37.000 --> 00:12:42.000
Tôi sẽ sử dụng Xcode để khởi chạy Instruments để lập hồ sơ bài kiểm tra của mình.

00:12:42.000 --> 00:12:51.000
Thay vì chọn công cụ Time Profiler, tôi sẽ nhấp đúp vào Phân bổ...

00:12:51.000 --> 00:13:02.000
Và sau đó nhấp vào Ghi lại.

00:13:02.000 --> 00:13:10.000
Mặc dù bài kiểm tra này đang thực hiện nhanh chóng, nhưng trên thực tế nó đang sử dụng rất nhiều bộ nhớ, trên 10GB.

00:13:10.000 --> 00:13:15.000
Điều này cho tôi biết rằng gần như toàn bộ tập dữ liệu đang được lưu giữ trong bộ nhớ trong quá trình chạy thử.

00:13:15.000 --> 00:13:19.000
Hãy cùng tìm hiểu tại sao.

00:13:19.000 --> 00:13:22.000
Tôi có thể chọn một loạt các phân bổ để xem xét.

00:13:22.000 --> 00:13:27.000
Ở khung dưới cùng, tôi có thể thấy rằng có một số phân bổ lớn.

00:13:27.000 --> 00:13:36.000
Tôi có thể đào sâu vào những thứ đó bằng cách nhấp vào tiết lộ này, và sau đó nhấp vào một trong những đốm màu dữ liệu lớn đã được phân bổ cho bài kiểm tra.

00:13:36.000 --> 00:13:41.000
Đốm màu cụ thể này đã được phân bổ nhưng không được giải phóng trong gần hai giây.

00:13:41.000 --> 00:13:46.000
Đó là một sự vĩnh cửu trong thời gian kiểm tra. Tại sao nó lại sống lâu như vậy?

00:13:46.000 --> 00:13:53.000
Tôi có thể khám phá điều đó bằng cách mở rộng dấu vết ngăn xếp ở bên phải.

00:13:53.000 --> 00:14:05.000
Từ kinh nghiệm, dấu vết ngăn xếp phân bổ và phân bổ vị trí cho tôi biết rằng đối tượng này đã bị CoreData lỗi và sau đó được phát hành khi bối cảnh đối tượng được quản lý hoàn thành công việc của nó.

00:14:05.000 --> 00:14:15.000
Đó thường là một dấu hiệu cho thấy đối tượng đã được giữ lại bởi một tìm nạp, một autoreleasepool hoặc một đối tượng trong bài kiểm tra.

00:14:15.000 --> 00:14:19.000
Phần mã có vấn đề nằm ở đây trong trình xác minh của tôi.

00:14:19.000 --> 00:14:22.000
Tôi tải một hình ảnh từ tệp đính kèm và xác minh nó.

00:14:22.000 --> 00:14:29.000
Tuy nhiên, điều này giữ cho tệp đính kèm và dữ liệu hình ảnh liên quan được đăng ký với ngữ cảnh đối tượng được quản lý.

00:14:29.000 --> 00:14:33.000
Có một số cách chúng tôi có thể cố gắng giải quyết vấn đề này.

00:14:33.000 --> 00:14:41.000
Ví dụ, trong chế độ xem bảng, chúng ta có thể sử dụng tìm nạp theo lô để giải phóng các hình ảnh khi bảng cuộn qua các bài đăng.

00:14:41.000 --> 00:14:46.000
Tuy nhiên, bài kiểm tra này đang được thực hiện quá nhanh để nó có hiệu quả.

00:14:46.000 --> 00:14:48.000
Tôi cần thay đổi cách tiếp cận của mình.

00:14:48.000 --> 00:14:54.000
Thay vì xác minh bằng cách tìm nạp bài đăng, thay vào đó tôi có thể tìm nạp tệp đính kèm.

00:14:54.000 --> 00:15:03.000
Nếu tôi cũng chỉ tìm nạp objectIDs, ngữ cảnh đối tượng được quản lý sẽ không nắm bắt bất kỳ đối tượng đã tải nào cho đến khi tôi yêu cầu.

00:15:03.000 --> 00:15:11.000
Tôi có thể sử dụng phương thức objectWithID của NSManagedObjectContext để tìm nạp các tệp đính kèm khi tôi xác thực.

00:15:11.000 --> 00:15:21.000
Cuối cùng, cứ 10 tệp đính kèm tôi xác thực, tôi đặt lại ngữ cảnh, giải phóng tất cả trạng thái được lưu trong bộ nhớ cache và bộ nhớ liên quan.

00:15:21.000 --> 00:15:30.000
Nếu tôi chạy lại bài kiểm tra với sự thay đổi này, tôi có thể thấy rằng nó dẫn đến mức tiêu thụ bộ nhớ có thể dự đoán và điều chỉnh được nhiều hơn.

00:15:30.000 --> 00:15:38.000
Trên thực tế, trình xác minh sử dụng ít bộ nhớ hơn LargeDataGenerator khi chèn các đối tượng này.

00:15:38.000 --> 00:15:44.000
Hãy đi sâu vào một phân bổ cụ thể để tìm hiểu cách thức hoạt động của bản sửa lỗi.

00:15:44.000 --> 00:15:47.000
Đầu tiên, tôi sẽ chọn một loạt các phân bổ để làm việc.

00:15:47.000 --> 00:16:05.000
Sau đó, tôi sẽ chọn một kích thước cụ thể để kiểm tra, tôi cần cho phép các đối tượng bị phá hủy tìm những đối tượng đã được giải phóng trong thời gian này và sau đó tôi có thể chọn một phân bổ cụ thể để kiểm tra.

00:16:05.000 --> 00:16:15.000
Ở phía bên phải, Instruments hiển thị cho tôi dấu vết ngăn xếp phân bổ, nhưng tôi muốn biết nó được giải phóng ở đâu, vì vậy tôi sẽ chọn sự kiện phân bổ giao dịch.

00:16:15.000 --> 00:16:27.000
Tôi tình cờ biết rằng dấu vết ngăn xếp này có nghĩa là NSManagedObjectContext đang phân bổ không đồng bộ đối tượng giữ lại đốm màu này, giải phóng bộ nhớ đã tiêu thụ.

00:16:27.000 --> 00:16:35.000
Kỹ thuật này cho phép tôi thiết lập một điểm nước cao cho bài kiểm tra, cho phép nó chạy trên các hệ thống có ít bộ nhớ hơn.

00:16:35.000 --> 00:16:43.000
Bằng cách kết hợp các bài kiểm tra với Dụng cụ, tôi đã có thể phát hiện ra rằng bài kiểm tra cụ thể này có một số hành vi không mong muốn.

00:16:43.000 --> 00:16:49.000
Tôi đã thực hiện các thay đổi được nhắm mục tiêu để giải quyết trực tiếp hành vi đó và sau đó xác minh kết quả.

00:16:49.000 --> 00:17:02.000
Ngoài ra, nhật ký hệ thống cũng chứa rất nhiều thông tin về một ứng dụng và các dịch vụ hệ thống mà nó phụ thuộc vào, như CloudKit, lên lịch và thông báo đẩy.

00:17:02.000 --> 00:17:08.000
Tôi sẽ đồng bộ hóa một bài đăng duy nhất giữa MacBook Pro và iPhone của tôi.

00:17:08.000 --> 00:17:18.000
Khi tôi chèn một bài đăng mới trên máy Mac của mình, đưa ra một tiêu đề ngắn và để nó tải lên iCloud, nhật ký hệ thống sẽ ghi lại một số sự kiện.

00:17:18.000 --> 00:17:27.000
Khi nó đồng bộ hóa với iPhone của tôi, đôi khi thậm chí chụp trạng thái trung gian, nhật ký hệ thống sẽ ghi lại một tập hợp các sự kiện tương ứng.

00:17:27.000 --> 00:17:37.000
Trên MacBook Pro, NSPersistentCloudKitContainer hoạt động bên trong quy trình ứng dụng, trong trường hợp này là CoreDataCloudKitDemo.

00:17:37.000 --> 00:17:47.000
Khi dữ liệu được ghi vào một cửa hàng liên tục, nó sẽ hỏi một dịch vụ hệ thống được gọi là DASD liệu bây giờ có phải là thời điểm tốt để xuất dữ liệu đó sang CloudKit hay không.

00:17:47.000 --> 00:17:53.000
Nếu có, DASD sẽ yêu cầu NSPersistentCloudKitContainer chạy một hoạt động.

00:17:53.000 --> 00:18:02.000
NSPersistentCloudKitContainer sau đó sẽ lên lịch làm việc với một quy trình được gọi là cloudd để xuất các đối tượng đã thay đổi sang CloudKit.

00:18:02.000 --> 00:18:07.000
Chúng tôi có thể quan sát nhật ký từ từng quy trình này bằng ứng dụng Bảng điều khiển.

00:18:07.000 --> 00:18:14.000
Đối với nhật ký ứng dụng, chúng tôi chỉ cần tìm kiếm quy trình ứng dụng, CoreDataCloudKitDemo.

00:18:14.000 --> 00:18:18.000
Ở đây, tôi đã chọn một cái hiển thị quá trình xuất hoàn tất.

00:18:18.000 --> 00:18:26.000
Để lên lịch nhật ký, chúng tôi muốn xem nhật ký từ quy trình dasd và từ cửa hàng cụ thể của ứng dụng.

00:18:26.000 --> 00:18:32.000
Ở đây, tôi đã chọn bắt đầu hoạt động xuất cho cửa hàng riêng của ứng dụng.

00:18:32.000 --> 00:18:36.000
Hãy kiểm tra nhật ký này chi tiết hơn một chút.

00:18:36.000 --> 00:18:43.000
Các hoạt động được tạo bởi NSPersistentCloudKitContainer với dasd tuân theo một định dạng cụ thể.

00:18:43.000 --> 00:18:55.000
Mã định danh hoạt động bao gồm một tiền tố cụ thể mà NSPersistentCloudKitContainer sử dụng cùng với mã định danh cửa hàng cho cửa hàng mà hoạt động thuộc về.

00:18:55.000 --> 00:19:01.000
Nhật ký dasd bao gồm thông tin về cách dịch vụ quyết định xem một hoạt động có thể chạy hay không.

00:19:01.000 --> 00:19:10.000
Các chính sách ảnh hưởng đến khả năng thực hiện công việc của ứng dụng sẽ được liệt kê trong nhật ký cùng với quyết định cuối cùng.

00:19:10.000 --> 00:19:19.000
Cuối cùng, quy trình ghi nhật ký được che mờ thông tin từ CloudKit và tôi muốn lọc các nhật ký này theo mã định danh vùng chứa mà tôi đang làm việc.

00:19:19.000 --> 00:19:26.000
Ở đây tôi đã chọn thao tác sửa đổi bản ghi tương ứng cho việc xuất mà tôi đã đề cập trước đó.

00:19:26.000 --> 00:19:33.000
Khi các thay đổi được nhập trên thiết bị nhận, có một quy trình bổ sung cần quan sát.

00:19:33.000 --> 00:19:41.000
Quá trình apsd chịu trách nhiệm nhận thông báo đẩy và chuyển tiếp chúng đến ứng dụng.

00:19:41.000 --> 00:19:48.000
Điều đó khiến NSPersistentCloudKitContainer bắt đầu một loạt các hoạt động tương tự như quy trình xuất.

00:19:48.000 --> 00:20:00.000
Nó yêu cầu dasd về thời gian để thực hiện nhập và sau đó hoạt động với cloudd để tìm nạp tất cả các đối tượng được cập nhật từ CloudKit và nhập chúng vào cửa hàng cục bộ.

00:20:00.000 --> 00:20:10.000
Apsd ghi lại khi nó nhận được thông báo đẩy cho một ứng dụng và nhật ký này ghi lại một số chi tiết quan trọng.

00:20:10.000 --> 00:20:19.000
Thông báo nhật ký bao gồm mã định danh vùng chứa ở đây cũng như tên đăng ký và mã định danh vùng đã kích hoạt thông báo đẩy.

00:20:19.000 --> 00:20:29.000
Chúng được quản lý bởi NSPersistentCloudKitContainer và sẽ luôn bắt đầu với tiền tố com.apple.coredata.cloudkit.

00:20:29.000 --> 00:20:31.000
Bây giờ ứng dụng bảng điều khiển rất tuyệt.

00:20:31.000 --> 00:20:40.000
Nhưng khi tôi đang phát triển trên máy Mac của mình, tôi thích sử dụng lệnh luồng nhật ký trong Terminal để hiển thị các nhật ký này cùng với ứng dụng của mình.

00:20:40.000 --> 00:20:46.000
Tôi mở một cửa sổ hoặc tab thiết bị đầu cuối cho mỗi vị ngữ sau, đầu tiên là ứng dụng.

00:20:46.000 --> 00:20:52.000
Tiếp theo, nhật ký từ cloudd để tôi có thể thấy những gì đang xảy ra với máy chủ CloudKit.

00:20:52.000 --> 00:20:56.000
Tiếp theo, apsd cho nhật ký thông báo đẩy.

00:20:56.000 --> 00:21:04.000
Và cuối cùng, dasd để tôi có thể thấy những gì đang xảy ra với các hoạt động mà NSPersistentCloudKitContainer thay mặt tôi lên lịch.

00:21:04.000 --> 00:21:11.000
Những vị ngữ này cũng có thể được sử dụng để hướng dẫn các truy vấn của bạn trong ứng dụng bảng điều khiển.

00:21:11.000 --> 00:21:15.000
Có rất nhiều thông tin có sẵn cho chúng tôi trên các thiết bị chúng tôi sử dụng.

00:21:15.000 --> 00:21:19.000
Thách thức, thực sự, là biết sử dụng công cụ nào để tìm và phân tích nó.

00:21:19.000 --> 00:21:27.000
Chỉ với Công cụ, chúng ta có thể tìm hiểu về một loạt các chủ đề như thời gian chạy và hiệu suất bộ nhớ và hơn thế nữa.

00:21:27.000 --> 00:21:34.000
Nhật ký hệ thống ghi lại các sự kiện mô tả công việc mà một ứng dụng thực hiện và những gì hệ thống đang làm cho nó đằng sau hậu trường.

00:21:34.000 --> 00:21:40.000
Giai đoạn cuối cùng của chu kỳ phát triển của tôi là thu thập và cung cấp phản hồi có thể hành động.

00:21:40.000 --> 00:21:45.000
Trong phần này, tôi sẽ trình bày cách thu thập thông tin chẩn đoán từ các thiết bị.

00:21:45.000 --> 00:21:52.000
Mục tiêu của chúng tôi là sử dụng thông tin này để tạo ra phản hồi có thể hành động và phù hợp với một mục tiêu cụ thể.

00:21:52.000 --> 00:21:59.000
Những kỹ thuật này có thể giúp bạn thu thập phản hồi từ bất kỳ thiết bị nào, cho dù đó là thiết bị bạn sở hữu hay thiết bị của khách hàng.

00:21:59.000 --> 00:22:04.000
Có ba bước để thu thập thông tin chẩn đoán từ một thiết bị.

00:22:04.000 --> 00:22:13.000
Đầu tiên, chúng ta sẽ cần cài đặt hồ sơ ghi nhật ký CloudKit, cho phép các bản ghi có thể được sử dụng để xác định các vấn đề và phân loại chúng một cách hiệu quả.

00:22:13.000 --> 00:22:17.000
Tiếp theo, chúng tôi sẽ thu thập chẩn đoán hệ thống từ thiết bị bị ảnh hưởng.

00:22:17.000 --> 00:22:25.000
Và cuối cùng, nếu chúng ta có quyền truy cập vật lý vào thiết bị, chúng ta cũng có thể thu thập các tệp lưu trữ liên tục từ Xcode.

00:22:25.000 --> 00:22:31.000
Để cài đặt hồ sơ ghi nhật ký, chúng tôi chỉ cần truy cập trang Hồ sơ và Nhật ký trên cổng thông tin nhà phát triển.

00:22:31.000 --> 00:22:36.000
Tôi có thể tìm kiếm hồ sơ CloudKit và nhấn vào liên kết hồ sơ để tải xuống.

00:22:36.000 --> 00:22:41.000
Trên một số thiết bị, một thông báo sẽ xuất hiện để cài đặt hồ sơ.

00:22:41.000 --> 00:22:47.000
Tuy nhiên, ở đây trên iOS, chúng ta sẽ cần cài đặt nó theo cách thủ công thông qua ứng dụng Cài đặt.

00:22:47.000 --> 00:22:52.000
Trong Cài đặt, tôi có thể điều hướng để nhấn vào ô Hồ sơ đã tải xuống.

00:22:52.000 --> 00:22:56.000
Sau đó tôi có thể nhấn vào hồ sơ đã tải xuống để cài đặt nó.

00:22:56.000 --> 00:23:00.000
Làm theo các bước để hoàn tất cài đặt.

00:23:00.000 --> 00:23:09.000
Sau khi hồ sơ được cài đặt, thiết bị có thể được khởi động lại và nó sẽ có hiệu lực.

00:23:09.000 --> 00:23:16.000
Khi thiết bị đã khởi động lại, chúng ta có thể tái tạo hành vi mà chúng ta muốn nắm bắt và sau đó thực hiện chẩn đoán hệ thống.

00:23:16.000 --> 00:23:21.000
Thực hiện chẩn đoán hệ thống được thực hiện bằng cách sử dụng keychord, một loạt các nút đặc biệt.

00:23:21.000 --> 00:23:25.000
Những thứ này được mô tả trong trang hướng dẫn cho hồ sơ.

00:23:25.000 --> 00:23:33.000
Tôi tình cờ biết rằng đối với một chiếc iPhone, chúng tôi giữ các nút âm lượng và nút bên trong vài giây và sau đó nhả nó ra.

00:23:33.000 --> 00:23:37.000
Sau một thời gian ngắn, chẩn đoán hệ thống sẽ có sẵn trong Cài đặt.

00:23:37.000 --> 00:23:43.000
Các hướng dẫn để tìm nó được bao gồm trong tệp hướng dẫn cho một hồ sơ.

00:23:43.000 --> 00:23:57.000
Trong Cài đặt, tôi điều hướng đến Quyền riêng tư &amp; Bảo mật, Phân tích và Cải tiến, sau đó chọn Dữ liệu Phân tích và cuộn qua nhật ký cho đến khi tôi tìm thấy chẩn đoán hệ thống.

00:23:57.000 --> 00:24:04.000
Nếu tôi nhấn vào chẩn đoán hệ thống và sau đó nhấn vào nút Chia sẻ, tôi có thể chọn một số cách để chia sẻ nó.

00:24:04.000 --> 00:24:08.000
Ví dụ, tôi thích AirDrop chúng vào máy Mac của tôi để phân tích.

00:24:08.000 --> 00:24:14.000
Cuối cùng, nếu có thể, tôi có thể thu thập các tệp lưu trữ từ Xcode bằng Trình tổ chức thiết bị.

00:24:14.000 --> 00:24:30.000
Tôi có thể thu thập các tệp từ iPhone này bằng cách nhấp vào Ứng dụng mẫu trong danh sách ứng dụng đã cài đặt, nhấp vào nút tiết lộ, chọn Bộ chứa tải xuống và lưu nó vào thư mục Tải xuống của tôi.

00:24:30.000 --> 00:24:36.000
Với tất cả những điều đó đã hoàn thành, cả nhật ký hệ thống và tệp lưu trữ hiện có sẵn để phân tích.

00:24:36.000 --> 00:24:45.000
Chúng ta đã nói về lệnh luồng nhật ký, nhưng với chẩn đoán hệ thống, tôi có thể sử dụng lệnh hiển thị nhật ký để in nhật ký từ chẩn đoán hệ thống.

00:24:45.000 --> 00:24:51.000
Ở đây, tôi đã sao chép vị ngữ cho nhật ký apsd mà chúng ta đã nói trước đó.

00:24:51.000 --> 00:24:56.000
Đối số cuối cùng cho lệnh hiển thị nhật ký là lưu trữ nhật ký để sử dụng.

00:24:56.000 --> 00:25:01.000
Nếu không có gì được chỉ định, nó sẽ hiển thị nhật ký hệ thống từ máy đang chạy.

00:25:01.000 --> 00:25:08.000
Ở đây, tôi đã chỉ định system_logs.logarchive để nó đọc nhật ký tôi lấy từ chẩn đoán hệ thống.

00:25:08.000 --> 00:25:16.000
Ví dụ, tôi có thể chỉ định một khoảng thời gian chính xác để tập trung vào thời gian khi một sự kiện mà tôi quan tâm xảy ra.

00:25:16.000 --> 00:25:36.000
Tôi cũng có thể kết hợp nhiều vị ngữ mà chúng ta đã thảo luận trước đó để tạo thành một nhật ký thống nhất của tất cả các hoạt động liên quan đến một ứng dụng, bắt đầu với nhật ký ứng dụng ở đây, nhật ký cloudd ở đây, nhật ký apsd ở đây và cuối cùng là nhật ký dasd ở đây.

00:25:36.000 --> 00:25:46.000
Lệnh mạnh mẽ này có thể được đưa vào báo cáo phản hồi hoặc chia sẻ với đồng đội để cho phép mọi người tập trung vào một bộ nhật ký cụ thể để phân tích.

00:25:46.000 --> 00:26:03.000
Trong phiên này, chúng tôi đã nói về cách bạn có thể khám phá hành vi ứng dụng với trình tạo dữ liệu, phân tích ứng dụng với các công cụ và nhật ký hệ thống và cung cấp hoặc thu thập phản hồi có thể hành động từ các ứng dụng sử dụng NSPersistentCloudKitContainer.

00:26:03.000 --> 00:26:08.000
Tôi là Nick Gillett, và tôi rất hân hạnh được mang đến cho bạn bài thuyết trình này.

00:26:08.000 --> 00:26:14.000
Cảm ơn vì đã xem, duy trì hoạt động, đóng vòng của bạn và có một WWDC tuyệt vời.

00:26:14.000 --> 23:59:59.000
.

