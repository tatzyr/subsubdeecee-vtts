WEBVTT

00:00:00.000 --> 00:00:13.000
- Xin chào, tôi là Michael Ilseman và tôi là một kỹ sư trong nhóm thư viện tiêu chuẩn Swift.

00:00:13.000 --> 00:00:17.000
Tham gia cùng tôi khi chúng ta gặp nhau và làm quen với Regex trong Swift.

00:00:17.000 --> 00:00:21.000
Swift Regex có rất nhiều thứ, và chúng tôi sẽ chỉ nếm trải mọi thứ mà nó cung cấp.

00:00:21.000 --> 00:00:30.000
Giả sử chúng tôi là các nhà phát triển cộng tác với một số nhà điều tra tài chính trên một công cụ để phân tích các giao dịch về những bất thường.

00:00:30.000 --> 00:00:36.000
Bây giờ, bạn sẽ nghĩ rằng đối với một nhiệm vụ quan trọng này, chúng tôi sẽ xử lý dữ liệu có cấu trúc tốt.

00:00:36.000 --> 00:00:40.000
Nhưng thay vào đó, chúng tôi có một loạt các chuỗi.

00:00:40.000 --> 00:00:53.000
Ở đây trường đầu tiên có loại giao dịch, trường thứ hai là ngày giao dịch, trường thứ ba là cá nhân hoặc tổ chức, trường thứ tư và trường cuối cùng là số tiền bằng đô la Mỹ.

00:00:53.000 --> 00:01:06.000
Các trường được phân tách bằng khoảng trắng từ 2 trở lên hoặc tab vì một lý do kỹ thuật rất quan trọng mà không ai liên quan có thể nhớ được.

00:01:06.000 --> 00:01:11.000
Và, vâng, trường ngày đó hoàn toàn mơ hồ.

00:01:11.000 --> 00:01:16.000
Chúng tôi sẽ chỉ hy vọng rằng đó là tháng/ngày/năm và xem điều gì sẽ xảy ra.

00:01:16.000 --> 00:01:26.000
Xử lý các giao dịch này liên quan đến việc xử lý chuỗi và chuỗi là một tập hợp, có nghĩa là chúng tôi có quyền truy cập vào các thuật toán thu thập chung.

00:01:26.000 --> 00:01:34.000
Các thuật toán này về cơ bản có hai loại, những thuật toán hoạt động trên các phần tử và những thuật toán hoạt động trên các chỉ số.

00:01:34.000 --> 00:01:45.000
Chúng ta có thể thử sử dụng các thuật toán dựa trên phần tử bằng cách tách các trường giao dịch, nhưng dấu phân cách trường là tab hoặc khoảng trắng 2 hoặc nhiều hơn khiến điều này trở nên khó khăn.

00:01:45.000 --> 00:01:48.000
Chỉ riêng việc tách trên khoảng trắng không cắt được nó.

00:01:48.000 --> 00:01:55.000
Một cách tiếp cận khác là thả xuống mã thao tác chỉ mục cấp thấp.

00:01:55.000 --> 00:02:01.000
Nhưng thật khó để làm đúng, và ngay cả khi bạn biết mình đang làm gì, nó vẫn cần rất nhiều mã.

00:02:01.000 --> 00:02:02.000
Hãy quay lại để chia tay.

00:02:02.000 --> 00:02:09.000
Lý do cách tiếp cận này không hoạt động là vì nó dựa trên phần tử trong khi dấu phân cách trường là một mẫu phức tạp hơn.

00:02:09.000 --> 00:02:15.000
Một giải pháp được tìm thấy trong nhiều ngôn ngữ khác nhau là viết một biểu thức chính quy.

00:02:15.000 --> 00:02:21.000
Các biểu thức chính quy xuất hiện từ lý thuyết ngôn ngữ chính thức, nơi chúng định nghĩa một ngôn ngữ chính quy.

00:02:21.000 --> 00:02:28.000
Họ đã nhập ứng dụng thực tế để tìm kiếm trong các trình soạn thảo và các công cụ dòng lệnh cũng như phân tích từ vựng trong trình biên dịch.

00:02:28.000 --> 00:02:40.000
Các ứng dụng này đưa các biểu thức chính quy vượt ra ngoài nguồn gốc lý thuyết của chúng, vì chúng cần trích xuất các phần của đầu vào, kiểm soát và thực thi trực tiếp, và thêm sức mạnh biểu cảm.

00:02:40.000 --> 00:02:42.000
Và Swift đang đưa họ đi xa hơn.

00:02:42.000 --> 00:02:45.000
Chúng tôi gọi đây là dẫn xuất Regex.

00:02:45.000 --> 00:02:52.000
Regex là một cấu trúc chung trên Đầu ra của nó, đó là kết quả của việc áp dụng nó, bao gồm cả việc chụp.

00:02:52.000 --> 00:02:58.000
Bạn có thể tạo một cái bằng cách sử dụng một nghĩa đen chứa cú pháp regex ở giữa các dấu phân cách dấu gạch chéo.

00:02:58.000 --> 00:03:07.000
Cú pháp regex của Swift tương thích với Perl, Python, Ruby, Java, NSRegularExpression và nhiều, rất nhiều thứ khác.

00:03:07.000 --> 00:03:10.000
Regex này khớp với một hoặc nhiều chữ số.

00:03:10.000 --> 00:03:20.000
Trình biên dịch biết cú pháp regex, vì vậy bạn sẽ nhận được tô sáng cú pháp, lỗi thời gian biên dịch và thậm chí là chụp được nhập mạnh, mà chúng ta sẽ gặp sau.

00:03:20.000 --> 00:03:25.000
Một regex có thể được tạo trong thời gian chạy từ một chuỗi chứa cùng một cú pháp regex.

00:03:25.000 --> 00:03:29.000
Điều này hữu ích cho các trường tìm kiếm trong trình soạn thảo hoặc công cụ dòng lệnh.

00:03:29.000 --> 00:03:34.000
Điều này sẽ gây ra lỗi trong thời gian chạy nếu đầu vào chứa cú pháp không hợp lệ.

00:03:34.000 --> 00:03:44.000
Loại đầu ra là một AnyRegexOutput hiện hữu, bởi vì các loại và số lần chụp sẽ không được biết cho đến thời gian chạy.

00:03:44.000 --> 00:03:53.000
Và cùng một regex có thể được viết bằng cách sử dụng trình tạo regex khai báo và có cấu trúc tốt, mặc dù dài dòng hơn.

00:03:53.000 --> 00:03:57.000
Hãy điều chỉnh cách tiếp cận phân tách của chúng ta từ trước đó để sử dụng nghĩa đen regex.

00:03:57.000 --> 00:04:03.000
Phần đầu tiên khớp với 2 hoặc nhiều lần xuất hiện của bất kỳ ký tự khoảng trắng nào.

00:04:03.000 --> 00:04:07.000
Phần thứ hai khớp với một tab nằm ngang duy nhất.

00:04:07.000 --> 00:04:17.000
Và ký tự đường ống biểu thị sự lựa chọn giữa các lựa chọn thay thế, cung cấp cho chúng ta một dấu phân cách trường gồm 2 hoặc nhiều khoảng trắng hoặc một tab duy nhất.

00:04:17.000 --> 00:04:29.000
Bây giờ các trường của chúng ta đã được phân chia, hãy đóng góp cho chính nền văn minh và bình thường hóa dấu phân cách trường đó thành một tab duy nhất và hoàn thành nó.

00:04:29.000 --> 00:04:40.000
Chúng ta có thể gọi 'tham gia' trên kết quả sau khi tách, nhưng có một thuật toán tốt hơn cho điều đó: 'thay thế' cho phép chúng ta thay thế tất cả các dấu phân cách trường bằng một tab duy nhất.

00:04:40.000 --> 00:04:46.000
Vì vậy, chúng tôi đi ra ngoài và truyền giáo cách tiếp cận vượt trội rõ ràng của chúng tôi với bất kỳ ai sẽ lắng nghe.

00:04:46.000 --> 00:04:50.000
Việc nhận con nuôi là...chậm nhưng đầy hứa hẹn.

00:04:50.000 --> 00:04:55.000
Nếu bạn quen thuộc với các biểu thức chính quy, bạn cũng có thể biết về danh tiếng hỗn hợp của chúng.

00:04:55.000 --> 00:05:00.000
Như câu nói cũ, "Tôi đã gặp vấn đề, vì vậy tôi đã viết một biểu thức chính quy.

00:05:00.000 --> 00:05:02.000
Bây giờ tôi có hai vấn đề."

00:05:02.000 --> 00:05:05.000
Nhưng Swift regex thì khác.

00:05:05.000 --> 00:05:09.000
Swift thúc đẩy nghệ thuật trong bốn lĩnh vực chính.

00:05:09.000 --> 00:05:15.000
Cú pháp Regex ngắn gọn và biểu cảm, nhưng nó có thể trở nên ngắn gọn và khó đọc.

00:05:15.000 --> 00:05:20.000
Và các tính năng mới hơn phải sử dụng cú pháp ngày càng khó hiểu.

00:05:20.000 --> 00:05:26.000
Swift regexes có thể được cấu trúc và tổ chức theo cách chúng tôi cấu trúc và tổ chức mã nguồn thông qua các trình tạo Regex.

00:05:26.000 --> 00:05:36.000
Chữ viết ngắn gọn, các nhà xây dựng đưa ra cấu trúc và các nghĩa đen có thể được sử dụng trong các nhà xây dựng để tìm ra sự cân bằng hoàn hảo đó.

00:05:36.000 --> 00:05:45.000
Các biểu diễn văn bản cho dữ liệu đã trở nên phức tạp hơn rất nhiều và việc xử lý chúng một cách chính xác đòi hỏi một trình phân tích cú pháp phù hợp với tiêu chuẩn.

00:05:45.000 --> 00:05:52.000
Swift regex cho phép bạn đan xen các trình phân tích cú pháp sức mạnh công nghiệp như các thành phần riêng lẻ của regex.

00:05:52.000 --> 00:05:58.000
Điều này được thực hiện theo kiểu mở rộng thư viện, có nghĩa là bất kỳ trình phân tích cú pháp nào cũng có thể tham gia.

00:05:58.000 --> 00:06:10.000
Phần lớn lịch sử của các biểu thức chính quy được áp dụng diễn ra trong một thế giới mà toàn bộ hệ thống máy tính chỉ hỗ trợ một ngôn ngữ và mã hóa duy nhất, đáng chú ý nhất là ASCII.

00:06:10.000 --> 00:06:13.000
Nhưng thế giới hiện đại là Unicode.

00:06:13.000 --> 00:06:18.000
Swift regex thực hiện Unicode mà không ảnh hưởng đến tính biểu cảm.

00:06:18.000 --> 00:06:25.000
Và cuối cùng, sức mạnh của các biểu thức chính quy có thể mở ra một không gian tìm kiếm rộng lớn phải được khám phá một cách thấu đáo.

00:06:25.000 --> 00:06:28.000
Điều này làm cho việc thực hiện của họ khó lý luận.

00:06:28.000 --> 00:06:35.000
Một số ngôn ngữ hỗ trợ điều khiển, nhưng vì chúng nằm sau cú pháp khó hiểu, chúng có xu hướng bị che khuất.

00:06:35.000 --> 00:06:41.000
Swift regex cung cấp khả năng thực thi có thể dự đoán được và kiểm soát bề mặt một cách nổi bật.

00:06:41.000 --> 00:06:52.000
Hãy quay lại báo cáo tài chính mà chúng tôi đang làm việc và phân tích cú pháp hoàn toàn từng giao dịch bằng cách sử dụng trình tạo Regex, một cách tiếp cận khai báo để xử lý chuỗi trong Swift.

00:06:52.000 --> 00:06:56.000
Chúng tôi sẽ nhập mô-đun RegexBuilder để bắt đầu.

00:06:56.000 --> 00:07:01.000
Chúng ta có thể sử dụng lại dấu phân cách trường regex mà chúng ta vừa xác định.

00:07:01.000 --> 00:07:05.000
Trường đầu tiên rất đơn giản; đó là TÍN DỤNG hoặc NỢ.

00:07:05.000 --> 00:07:10.000
Chúng ta có thể sử dụng cú pháp theo nghĩa đen regex mà chúng ta đã thấy để viết nó.

00:07:10.000 --> 00:07:13.000
Sau đó là một dấu phân cách trường, và sau đó là ngày tháng.

00:07:13.000 --> 00:07:16.000
Phân tích cú pháp ngày tháng bằng tay là một ý tưởng tồi.

00:07:16.000 --> 00:07:25.000
Foundation có trình phân tích cú pháp thực sự tốt cho các loại như ngày tháng, số và URL và chúng ta có thể sử dụng chúng trực tiếp trong Trình tạo Regex.

00:07:25.000 --> 00:07:30.000
Chúng tôi cung cấp một ngôn ngữ rõ ràng, đó là dự đoán tốt nhất của chúng tôi về ý định của tác giả.

00:07:30.000 --> 00:07:35.000
Chúng tôi làm điều này thay vì ngầm sử dụng ngôn ngữ hiện tại của hệ thống.

00:07:35.000 --> 00:07:43.000
Chúng tôi luôn có thể thay đổi nó sau này, và điều đó thật dễ dàng để thực hiện bởi vì chúng tôi đã đưa ra các giả định của mình _rõ ràng_ trong mã.

00:07:43.000 --> 00:07:48.000
Trường thứ ba có thể là "bất cứ thứ gì", vì vậy thật hấp dẫn khi chỉ viết "một hoặc nhiều thứ."

00:07:48.000 --> 00:07:58.000
Và mặc dù điều đó sẽ cho chúng ta câu trả lời đúng, nhưng nó thực hiện rất nhiều công việc không cần thiết trước tiên, bởi vì nó bắt đầu bằng cách kết hợp bất kỳ thứ gì khác xảy ra sau nó.

00:07:58.000 --> 00:08:02.000
Regex sẽ sao lưu từng ký tự một và thử phần còn lại của mẫu.

00:08:02.000 --> 00:08:08.000
Chúng tôi muốn yêu cầu regex dừng lại khi nó nhìn thấy dấu phân cách trường kết thúc.

00:08:08.000 --> 00:08:10.000
Có khá nhiều cách để chúng ta có thể hoàn thành việc này.

00:08:10.000 --> 00:08:20.000
Một cách hay để làm điều này là sử dụng NegativeLookahead để xem qua phần tiếp theo của đầu vào mà không thực sự tiêu thụ nó.

00:08:20.000 --> 00:08:26.000
Ở đây chúng tôi xem qua đầu vào để đảm bảo dấu phân cách trường không xuất hiện trước khi khớp với bất kỳ ký tự nào.

00:08:26.000 --> 00:08:35.000
NegativeLookahead là một trong những công cụ cho phép bạn kiểm soát chính xác cách Regex khớp với các thành phần của nó.

00:08:35.000 --> 00:08:42.000
Cuối cùng, chúng tôi khớp số tiền, một lần nữa sử dụng một trong những trình phân tích cú pháp của Foundation, lần này là tiền tệ.

00:08:42.000 --> 00:08:51.000
Chúng tôi đã giả định rằng dấu phẩy là dấu phân cách hàng nghìn trong khi dấu chấm là dấu phân cách thập phân và chúng tôi đưa ra giả định này rõ ràng.

00:08:51.000 --> 00:08:55.000
Chúng tôi đã xây dựng một regex cho phép chúng tôi phân tích cú pháp một dòng từ sổ cái giao dịch.

00:08:55.000 --> 00:09:01.000
Chúng tôi không chỉ muốn nhận ra các dòng. Chúng tôi muốn trích xuất một số dữ liệu này.

00:09:01.000 --> 00:09:08.000
Để làm điều này, chúng tôi sử dụng captures, trích xuất các phần đầu vào của chúng tôi để xử lý sau này.

00:09:08.000 --> 00:09:17.000
Theo quy ước, chụp 'thứ 0' là một phần của đầu vào mà toàn bộ regex khớp và mỗi lần chụp rõ ràng theo sau.

00:09:17.000 --> 00:09:23.000
Loại giao dịch của chúng tôi được ghi lại dưới dạng Chuỗi con là một phần đầu vào của chúng tôi.

00:09:23.000 --> 00:09:31.000
Đối với ngày tháng, chúng tôi thực sự nắm bắt được giá trị được nhập mạnh đã được phân tích cú pháp mà không cần phải xử lý hậu kỳ văn bản.

00:09:31.000 --> 00:09:41.000
Cá nhân hoặc tổ chức một lần nữa được nắm bắt như một phần đầu vào của chúng tôi và việc nắm bắt thập phân là một giá trị được nhập mạnh khác.

00:09:41.000 --> 00:09:47.000
Để sử dụng nó, chúng tôi trích xuất các giá trị ngày và thập phân từ kết quả khớp và các nhà điều tra lấy nó từ đây.

00:09:47.000 --> 00:09:56.000
Tại thời điểm này, chúng tôi khuyên họ nên đổ dữ liệu vào cơ sở dữ liệu thực để có những lợi ích rõ ràng như truy vấn có cấu trúc.

00:09:56.000 --> 00:09:58.000
Họ có một... ý kiến khác nhau.

00:09:58.000 --> 00:10:01.000
Họ muốn giữ mọi thứ như những sợi dây.

00:10:01.000 --> 00:10:07.000
Đó là tin tốt cho cuộc nói chuyện này bởi vì chúng ta có thể thấy nhiều hơn về Swift Regex.

00:10:07.000 --> 00:10:11.000
Mọi thứ đang diễn ra tốt đẹp cho đến khi đột nhiên nó không diễn ra.

00:10:11.000 --> 00:10:20.000
Chúng tôi vừa biết rằng thứ tự ngày trong văn bản giao dịch, mà chúng tôi đã nói với mọi người là hoàn toàn mơ hồ, trên thực tế là không rõ ràng.

00:10:20.000 --> 00:10:28.000
Nó không phải lúc nào cũng giống nhau, và lý thuyết hàng đầu là nó phụ thuộc vào loại tiền tệ được sử dụng trong giao dịch.

00:10:28.000 --> 00:10:30.000
Bởi vì tất nhiên là có.

00:10:30.000 --> 00:10:40.000
Điều này có nghĩa là đô la Mỹ là tháng/ngày/năm và bảng Anh là ngày/tháng/năm.

00:10:40.000 --> 00:10:44.000
Vì vậy, hãy viết một kịch bản giống như sed để định rõ điều này.

00:10:44.000 --> 00:10:48.000
Đối với regex của chúng tôi, chúng tôi sẽ sử dụng một dấu phân cách mở rộng.

00:10:48.000 --> 00:10:53.000
Điều này cho phép chúng ta có những dấu gạch chéo bên trong mà không cần phải thoát khỏi chúng.

00:10:53.000 --> 00:11:05.000
Điều này cũng cho phép chúng tôi truy cập vào chế độ cú pháp mở rộng trong đó khoảng trắng bị bỏ qua, có nghĩa là chúng tôi có thể sử dụng khoảng trắng để dễ đọc, giống như trong mã thông thường.

00:11:05.000 --> 00:11:11.000
Chúng tôi đã sử dụng các ảnh chụp có tên, hiển thị trong đầu ra của Regex dưới dạng nhãn bộ.

00:11:11.000 --> 00:11:15.000
Và chúng tôi sử dụng Thuộc tính Unicode để nhận dạng các ký hiệu tiền tệ.

00:11:15.000 --> 00:11:23.000
Điều này làm cho regex của chúng tôi dễ thích nghi hơn; chúng tôi sẽ xử lý các ký hiệu cụ thể trong logic ứng dụng.

00:11:23.000 --> 00:11:30.000
Thay vì cố gắng cắt và ghép văn bản theo cách thủ công, chúng tôi sẽ lại sử dụng trình phân tích cú pháp ngày của Foundation.

00:11:30.000 --> 00:11:35.000
pickStrategy nhận biểu tượng tiền tệ và sẽ xác định chiến lược phân tích cú pháp dựa trên nó.

00:11:35.000 --> 00:11:46.000
Tất cả các giả định của chúng tôi đều rõ ràng trong mã, điều này giúp dễ dàng thích nghi và phát triển hơn, điều mà cuối cùng chúng tôi gần như chắc chắn sẽ cần.

00:11:46.000 --> 00:11:58.000
Hãy sử dụng chức năng regex và helper của chúng tôi với thuật toán tìm và thay thế bằng cách cung cấp đóng sử dụng kết quả khớp, bao gồm cả chụp, để xây dựng chuỗi thay thế.

00:11:58.000 --> 00:12:02.000
Chúng tôi chọn một chiến lược dựa trên đồng tiền bị bắt và phân tích ngày bị bắt.

00:12:02.000 --> 00:12:07.000
Chúng ta có thể truy cập các bức ảnh chụp theo tên, thay vì chỉ theo vị trí.

00:12:07.000 --> 00:12:14.000
Đối với đầu ra của chúng tôi, chúng tôi sẽ định dạng ngày mới bằng cách sử dụng ISO-8601, một tiêu chuẩn công nghiệp rõ ràng.

00:12:14.000 --> 00:12:20.000
Công cụ của chúng tôi biến sổ cái này thành một cái rõ ràng.

00:12:20.000 --> 00:12:27.000
Bởi vì chúng tôi đang sử dụng trình phân tích cú pháp và định dạng ngày thực, chúng tôi thích nghi hơn nhiều với các yêu cầu thay đổi.

00:12:27.000 --> 00:12:33.000
Và sử dụng thuộc tính Unicode để nhận dạng các ký hiệu tiền tệ giúp chúng ta phát triển nhanh hơn nhiều.

00:12:33.000 --> 00:12:38.000
Một regex khai báo một thuật toán trên một số mô hình của Chuỗi.

00:12:38.000 --> 00:12:43.000
Swift's String trình bày nhiều mô hình để làm việc với Unicode.

00:12:43.000 --> 00:12:50.000
Chuỗi này, đại diện cho một câu chuyện tình yêu cho các lứa tuổi, chứa 3 nhân vật.

00:12:50.000 --> 00:12:56.000
Những ký tự này là những thực thể phức tạp chính thức được gọi là cụm đồ thị mở rộng Unicode.

00:12:56.000 --> 00:13:02.000
Một ký tự duy nhất bao gồm một hoặc nhiều giá trị vô hướng Unicode.

00:13:02.000 --> 00:13:09.000
Chuỗi cung cấp UnicodeScalarView để truy cập biểu diễn cấp thấp hơn này của nội dung của nó.

00:13:09.000 --> 00:13:15.000
Điều này cho phép sử dụng nâng cao cũng như khả năng tương thích với các hệ thống khác.

00:13:15.000 --> 00:13:27.000
Nhân vật đầu tiên của chúng ta, nhân vật chính trong câu chuyện của chúng ta, bao gồm 4 vô hướng Unicode: ZOMBIE, Zero Width Joiner, FEMALE SIGN, và uh...

00:13:27.000 --> 00:13:35.000
VARIATION SELECTOR-16, trong bối cảnh này báo hiệu một sở thích được hiển thị dưới dạng biểu tượng cảm xúc.

00:13:35.000 --> 00:13:37.000
Tất nhiên rồi!

00:13:37.000 --> 00:13:41.000
Những vô hướng này tạo ra biểu tượng cảm xúc duy nhất mà chúng ta nhìn thấy trực quan.

00:13:41.000 --> 00:13:47.000
Khi các chuỗi được lưu trữ trong bộ nhớ, chúng được mã hóa dưới dạng UTF-8 byte.

00:13:47.000 --> 00:13:50.000
Chúng ta có thể xem các byte này bằng chế độ xem UTF-8.

00:13:50.000 --> 00:14:03.000
UTF-8 là một mã hóa có chiều rộng thay đổi, có nghĩa là nhiều byte có thể cần thiết cho một vô hướng duy nhất và như chúng ta đã thấy, có thể cần nhiều vô hướng cho một ký tự duy nhất.

00:14:03.000 --> 00:14:11.000
Nhân vật chính của câu chuyện của chúng tôi, được đại diện bởi 4 vô hướng Unicode, được mã hóa bằng 13 UTF-8 byte.

00:14:11.000 --> 00:14:20.000
Ngoài việc bao gồm nhiều vô hướng, cùng một ký tự chính xác đôi khi có thể được biểu diễn bằng các bộ vô hướng khác nhau.

00:14:20.000 --> 00:14:24.000
Điều này xuất hiện rất nhiều khi xử lý các ngôn ngữ khác ngoài tiếng Anh.

00:14:24.000 --> 00:14:38.000
Trong ví dụ này, chữ 'e' với trọng âm cấp tính có thể được biểu diễn dưới dạng một vô hướng duy nhất, được tạo sẵn 'e' với trọng âm cấp tính hoặc dưới dạng ASCII 'e' theo sau là giọng cấp tính kết hợp.

00:14:38.000 --> 00:14:43.000
Đây là những ký tự giống nhau, vì vậy so sánh Chuỗi sẽ trả về true.

00:14:43.000 --> 00:14:49.000
Điều này là do String tuân theo cái được gọi chính thức là Unicode Canonical Equivalence.

00:14:49.000 --> 00:14:59.000
Từ góc nhìn của UnicodeScalarView, hoặc chế độ xem UTF-8, nội dung khác nhau và chúng tôi thấy sự khác biệt này khi chúng tôi so sánh trong các chế độ xem cấp thấp hơn này.

00:14:59.000 --> 00:15:05.000
Cũng giống như String, Swift regex bị ám ảnh bởi Unicode chính xác theo mặc định.

00:15:05.000 --> 00:15:09.000
Nhưng nó làm điều này mà không ảnh hưởng đến tính biểu cảm.

00:15:09.000 --> 00:15:11.000
Hãy chuyển qua một cặp dây.

00:15:11.000 --> 00:15:21.000
Đối với chuỗi đầu tiên, chúng ta sẽ khớp với Unicode Scalar SPARKLING HEART có tên được bao quanh bởi bất kỳ ký tự nào được ký hiệu bằng dấu chấm (.).

00:15:21.000 --> 00:15:29.000
Bất kỳ lớp ký tự nào cũng sẽ khớp với bất kỳ ký tự Swift nào; nghĩa là, bất kỳ cụm đồ thị mở rộng Unicode nào.

00:15:29.000 --> 00:15:34.000
Đối với chuỗi thứ hai, các ký tự bằng nhau so sánh bằng nhau...

00:15:34.000 --> 00:15:37.000
Và chúng ta có thể bỏ qua trường hợp.

00:15:37.000 --> 00:15:41.000
Và bây giờ câu chuyện tình yêu đơn giản của chúng ta đã trở nên phức tạp hơn rất nhiều.

00:15:41.000 --> 00:15:49.000
Đôi khi cuộc sống, hoặc trong trường hợp này là cuộc sống, có những phức tạp mà chúng ta cần xử lý.

00:15:49.000 --> 00:16:02.000
Cũng giống như String, nếu bạn cần tự xử lý các giá trị vô hướng Unicode, để tương thích hoặc độ chính xác của cụm đồ thị phụ, bạn có thể bằng cách khớp với ngữ nghĩa 'unicodeScalar'.

00:16:02.000 --> 00:16:09.000
Khi chúng ta khớp ở cấp độ Vô hướng Unicode, dấu chấm khớp với một giá trị Vô hướng Unicode duy nhất thay vì một Ký tự Swift đầy đủ.

00:16:09.000 --> 00:16:14.000
Điều đó có nghĩa là chúng ta có thể gặp lại bạn của mình: VARIATION-SELECTOR 16.

00:16:14.000 --> 00:16:23.000
Bộ chọn nhỏ thân thiện này được khớp bởi dấu chấm và bạn không thể nhìn thấy nó bởi vì khi tất cả chỉ có một mình, nó hiển thị dưới dạng khoảng trắng trống.

00:16:23.000 --> 00:16:26.000
Rất hữu ích.

00:16:26.000 --> 00:16:34.000
Bây giờ chúng ta đã làm việc với độ chính xác và chính xác, hãy làm điều gì đó khác biệt một chút và quay trở lại với tài chính.

00:16:34.000 --> 00:16:40.000
Các nhà điều tra đã quay trở lại, và lần này họ có một yêu cầu thú vị.

00:16:40.000 --> 00:16:48.000
Họ đã sửa đổi công cụ khớp giao dịch của chúng tôi để đánh hơi các giao dịch trực tiếp thay vì xử lý sổ cái sau khi thực tế.

00:16:48.000 --> 00:16:56.000
Nhìn vào mã của họ, họ thực sự đã làm một công việc khá tốt, nhưng họ đang phải đối mặt với các vấn đề về quy mô và cần sự giúp đỡ của chúng tôi.

00:16:56.000 --> 00:17:01.000
Các giao dịch mà họ đang xử lý rất giống nhau, nhưng có những khác biệt nhỏ.

00:17:01.000 --> 00:17:05.000
Thay vì một ngày tháng, thay vào đó họ có một dấu thời gian chính xác.

00:17:05.000 --> 00:17:12.000
Điều này được thể hiện ở một định dạng rõ ràng, rõ ràng và độc quyền gây sốc.

00:17:12.000 --> 00:17:19.000
Họ có một cách diễn đạt chính quy được viết trong một thế kỷ trước phù hợp với điều này.

00:17:19.000 --> 00:17:22.000
Không sao đâu.

00:17:22.000 --> 00:17:26.000
Tiếp theo họ có một trường chi tiết bao gồm các cá nhân và mã nhận dạng.

00:17:26.000 --> 00:17:33.000
Họ lọc các giao dịch dựa trên trường này bằng cách sử dụng regex biên dịch thời gian chạy có nguồn gốc từ đầu vào.

00:17:33.000 --> 00:17:41.000
Bởi vì điều này đang hoạt động, và có nhiều lĩnh vực hơn sau này, họ muốn bảo lãnh sớm cho bất kỳ giao dịch không thú vị nào.

00:17:41.000 --> 00:17:47.000
Sau đó là một số tiền và các trường khác như tổng kiểm tra, mà họ tự xử lý tốt.

00:17:47.000 --> 00:17:55.000
Và tất nhiên, các trường vẫn cách nhau 2 hoặc nhiều khoảng trắng hoặc một tab.

00:17:55.000 --> 00:17:58.000
Người đối sánh giao dịch của họ trông rất giống của chúng tôi.

00:17:58.000 --> 00:18:06.000
Họ có regex riêng cho dấu thời gian, regex chi tiết của họ được biên dịch từ đầu vào và họ xử lý các trường còn lại.

00:18:06.000 --> 00:18:10.000
Họ đã làm một công việc khá tốt. Mọi thứ đều hoạt động về mặt kỹ thuật.

00:18:10.000 --> 00:18:12.000
Nó chỉ không mở rộng quy mô tốt.

00:18:12.000 --> 00:18:19.000
Họ nhận thấy rằng dấu thời gian và các regexe chi tiết của họ thường khớp với nhiều đầu vào hơn các trường của họ.

00:18:19.000 --> 00:18:25.000
Lý tưởng nhất, các regexes này sẽ bị hạn chế chỉ chạy trên một trường duy nhất.

00:18:25.000 --> 00:18:33.000
Chúng tôi đã xử lý một vấn đề tương tự trong dự án của mình bằng cách sử dụng cái nhìn tiêu cực về phía trước, vì vậy hãy kéo regex đó vào.

00:18:33.000 --> 00:18:43.000
'Trường' sẽ khớp hiệu quả với bất kỳ ký tự nào cho đến khi nó gặp dấu phân cách trường và chúng tôi muốn sử dụng nó để chứa các regexes của chúng.

00:18:43.000 --> 00:18:52.000
Chúng tôi có thể làm điều này như một bước xử lý hậu kỳ, nhưng vì điều này đang chạy trực tiếp, chúng tôi muốn bảo lãnh sớm nếu các regexes này không khớp với trường của chúng.

00:18:52.000 --> 00:18:55.000
Chúng ta có thể làm điều này bằng cách sử dụng TryCapture.

00:18:55.000 --> 00:19:05.000
TryCapture vượt qua trường phù hợp để đóng cửa của chúng tôi, nơi chúng tôi kiểm tra theo dấu thời gian của điều tra viên và các quy định chi tiết.

00:19:05.000 --> 00:19:12.000
Nếu chúng khớp, chúng tôi trả về giá trị của trường, có nghĩa là khớp đã thành công và trường được ghi lại.

00:19:12.000 --> 00:19:18.000
Nếu không, chúng tôi trả về số không, báo hiệu rằng việc khớp không thành công.

00:19:18.000 --> 00:19:24.000
Việc đóng cửa của TryCapture tích cực tham gia vào việc kết hợp, đó chính xác là những gì chúng tôi cần.

00:19:24.000 --> 00:19:27.000
Và với điều này, chúng tôi đã giải quyết được một vấn đề mở rộng quy mô lớn.

00:19:27.000 --> 00:19:37.000
Nhưng vẫn còn một vấn đề nữa: khi một cái gì đó sau này trong trình đối sánh giao dịch không thành công, có thể mất nhiều thời gian để thoát.

00:19:37.000 --> 00:19:46.000
FieldSeparator regex của chúng tôi mà chúng tôi đã xác định ngay từ đầu khớp với 2 hoặc nhiều khoảng trắng hoặc một tab, đó là những gì chúng tôi muốn.

00:19:46.000 --> 00:19:53.000
Nếu có 8 ký tự khoảng trắng, nó sẽ khớp với tất cả chúng trước khi thử phần còn lại của regex.

00:19:53.000 --> 00:20:00.000
Nhưng nếu regex sau đó thất bại, nó sẽ sao lưu và chỉ khớp với 7 ký tự khoảng trắng trước khi thử lại.

00:20:00.000 --> 00:20:10.000
Và nếu điều đó không thành công, nó sẽ chỉ khớp với 6 ký tự khoảng trắng, v.v.

00:20:10.000 --> 00:20:15.000
Chỉ sau khi thử tất cả các lựa chọn thay thế thì việc kết hợp mới thất bại.

00:20:15.000 --> 00:20:24.000
Việc sao lưu này để thử các lựa chọn thay thế được gọi là quay lại toàn cầu hoặc, theo logic chính thức, đóng Kleene.

00:20:24.000 --> 00:20:29.000
Đó là những gì mang lại cho các biểu thức chính quy sức mạnh đặc trưng của chúng.

00:20:29.000 --> 00:20:36.000
Nhưng nó mở ra một không gian tìm kiếm rộng lớn để khám phá, và ở đây chúng tôi muốn một không gian tìm kiếm tuyến tính hơn.

00:20:36.000 --> 00:20:40.000
Chúng tôi muốn khớp tất cả các khoảng trắng và không bao giờ từ bỏ bất kỳ khoảng trắng nào.

00:20:40.000 --> 00:20:51.000
Có một vài công cụ mà chúng ta có thể sử dụng; công cụ tổng quát hơn là đặt fieldSeparator trong phạm vi quay lại cục bộ thay vì phạm vi toàn cầu.

00:20:51.000 --> 00:21:02.000
Trình tạo cục bộ tạo ra một phạm vi trong đó, nếu regex chứa khớp thành công, mọi lựa chọn thay thế chưa được thử sẽ bị loại bỏ.

00:21:02.000 --> 00:21:10.000
Ngay cả khi trình đối sánh giao dịch của chúng tôi thất bại sau này, chúng tôi không quay lại để cố gắng tiêu thụ ít không gian hơn.

00:21:10.000 --> 00:21:17.000
Quay lại toàn cầu, mặc định cho regex, rất tốt cho tìm kiếm và kết hợp mờ.

00:21:17.000 --> 00:21:22.000
Local rất hữu ích để khớp các mã thông báo được chỉ định chính xác.

00:21:22.000 --> 00:21:29.000
Dấu phân cách trường, dù nó có thể gây khó chịu, là chính xác.

00:21:29.000 --> 00:21:36.000
Địa phương được biết đến ở những nơi khác như một nhóm không bắt giữ nguyên tử, có thể là một... cái tên đáng sợ.

00:21:36.000 --> 00:21:40.000
Làm cho nó có vẻ như regex của bạn có thể nổ tung.

00:21:40.000 --> 00:21:46.000
Nhưng nó thực sự làm ngược lại-- nó chứa không gian tìm kiếm.

00:21:46.000 --> 00:21:50.000
Và với điều này, chúng tôi đã giúp họ giải quyết các vấn đề mở rộng quy mô của họ.

00:21:50.000 --> 00:21:56.000
Hôm nay chúng tôi phải gặp Swift Regex, nhưng còn rất nhiều thứ nữa mà chúng tôi không thể đề cập đến.

00:21:56.000 --> 00:22:02.000
Hãy chắc chắn kiểm tra Swift Regex: Beyond the Basics của đồng nghiệp Richard của tôi.

00:22:02.000 --> 00:22:05.000
Trước khi chúng ta rời đi, tôi muốn nhấn mạnh một vài điểm.

00:22:05.000 --> 00:22:11.000
Các nhà xây dựng Regex đưa ra cấu trúc. Các ký tự Regex ngắn gọn.

00:22:11.000 --> 00:22:17.000
Sự lựa chọn giữa thời điểm sử dụng cái này và cái kia cuối cùng sẽ mang tính chủ quan.

00:22:17.000 --> 00:22:21.000
Đảm bảo sử dụng trình phân tích cú pháp thực bất cứ khi nào có thể.

00:22:21.000 --> 00:22:27.000
Điều này sẽ giúp bạn tiết kiệm rất nhiều thời gian và tránh đau đầu.

00:22:27.000 --> 00:22:33.000
Chỉ bằng cách sử dụng mặc định của Swift, bạn sẽ nhận được nhiều sự hỗ trợ và tốt đẹp của Unicode hơn bất kỳ nơi nào khác.

00:22:33.000 --> 00:22:40.000
Tìm cách sử dụng những thứ như thuộc tính ký tự một cách hiệu quả, chẳng hạn như khi chúng tôi khớp các ký hiệu tiền tệ.

00:22:40.000 --> 00:22:49.000
Và cuối cùng, đơn giản hóa các thuật toán tìm kiếm và xử lý của bạn bằng cách sử dụng các điều khiển như phạm vi tìm kiếm và quay lại cục bộ.

00:22:49.000 --> 23:59:59.000
Cảm ơn bạn đã xem.

