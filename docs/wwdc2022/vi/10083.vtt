WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:15.000
Vaibhav Gautam: Xin chào, tôi là Vaibhav Gautam, và tôi là một kỹ sư trong nhóm Software Power.

00:00:15.000 --> 00:00:22.000
Các ứng dụng làm phong phú thêm cuộc sống của mọi người, vì chúng cung cấp các chức năng quan trọng khác nhau trong suốt một ngày sử dụng.

00:00:22.000 --> 00:00:26.000
Nhưng việc sử dụng này có thể đi kèm với một chi phí: tiêu hao pin.

00:00:26.000 --> 00:00:37.000
Do đó, điều quan trọng là bạn phải đặc biệt chú ý để cải thiện thời lượng pin của ứng dụng để người dùng của bạn có thể sử dụng thiết bị và ứng dụng của họ lâu hơn.

00:00:37.000 --> 00:00:51.000
Chúng tôi nghiên cứu sâu các thành phần hệ thống khác nhau để hiểu mức tiêu thụ điện năng và trong phiên này, tôi sẽ xem xét bốn hành động chính mà chúng tôi đã xác định mà bạn có thể thực hiện để cải thiện đáng kể thời lượng pin của ứng dụng của mình.

00:00:51.000 --> 00:01:03.000
Đây là Chế độ tối trong ứng dụng của bạn, kiểm tra tốc độ khung hình, giới hạn thời gian nền và trì hoãn công việc trong ứng dụng của bạn.

00:01:03.000 --> 00:01:06.000
Đầu tiên, tôi sẽ nói về Chế độ tối.

00:01:06.000 --> 00:01:14.000
Chế độ tối đã được giới thiệu trong iOS 13 và cho phép ai đó định cấu hình thiết bị của họ trong một bản trình bày tối hơn.

00:01:14.000 --> 00:01:24.000
Bạn có thể quen thuộc với các lợi ích cá nhân hóa của Chế độ tối, nhưng nó cũng có thể ảnh hưởng đáng kể đến thời lượng pin.

00:01:24.000 --> 00:01:35.000
Điều này là do trên các thiết bị có màn hình OLED, như iPhone 13 và 13 Pro, nội dung tối hơn tiêu thụ ít năng lượng hơn nội dung sáng hơn.

00:01:35.000 --> 00:01:45.000
Trên màn hình OLED, mỗi điểm ảnh yêu cầu công suất riêng lẻ và đối với các màu tối hơn, cần ít năng lượng hơn để làm sáng các điểm ảnh.

00:01:45.000 --> 00:01:52.000
Trong số tất cả các thành phần trong hệ thống, màn hình là một trong những nguồn tiêu thụ điện năng chính.

00:01:52.000 --> 00:02:00.000
Trên thực tế, trong các trường hợp sử dụng điển hình, màn hình có thể là yếu tố hàng đầu dẫn đến việc tiêu hao pin.

00:02:00.000 --> 00:02:04.000
Bạn có một cách để ảnh hưởng đến mức tiêu thụ điện năng của màn hình.

00:02:04.000 --> 00:02:08.000
Và một cách là áp dụng Chế độ tối.

00:02:08.000 --> 00:02:14.000
Tôi sẽ sử dụng ứng dụng Food Truck mà nhóm của tôi đang làm việc làm ví dụ.

00:02:14.000 --> 00:02:21.000
Ứng dụng này có màu nền rất nổi bật chiếm phần lớn màn hình.

00:02:21.000 --> 00:02:29.000
Khi trình bày ở Chế độ tối, màu nền này trở nên tối hơn nhiều so với phiên bản Chế độ sáng của nó, góp phần rất nhiều vào việc tiết kiệm pin.

00:02:29.000 --> 00:02:38.000
Trên thực tế, đối với những trường hợp như thế này, kết quả là chúng tôi mong đợi tiết kiệm tới 70% năng lượng hiển thị.

00:02:38.000 --> 00:02:41.000
Đây là một khoản tiết kiệm lớn!

00:02:41.000 --> 00:02:46.000
Và khi độ sáng màn hình cao, mức tiết kiệm pin thậm chí còn cao hơn.

00:02:46.000 --> 00:02:56.000
Đối với những người dùng thích Chế độ tối, đây là một cơ hội to lớn để tiết kiệm pin cho họ và nó cũng có thể giảm tải nhiệt.

00:02:56.000 --> 00:03:03.000
Để áp dụng Chế độ tối, hãy bắt đầu bằng cách xem lại cách ứng dụng của bạn hiện đang xuất hiện khi Chế độ tối được bật.

00:03:03.000 --> 00:03:10.000
Tìm ra những thành phần nào trong ứng dụng bạn nên cập nhật để phù hợp hơn với giao diện người dùng hệ thống.

00:03:10.000 --> 00:03:18.000
Xcode giúp việc này trở nên dễ dàng bằng cách sử dụng tính năng giao diện khi xây dựng ứng dụng của bạn.

00:03:18.000 --> 00:03:24.000
Ứng dụng của bạn có thể có màu được mã hóa cứng vì nó chỉ hỗ trợ Chế độ Ánh sáng.

00:03:24.000 --> 00:03:32.000
Sử dụng màu động trong Xcode để hỗ trợ màu nền, hình ảnh và văn bản ở Chế độ Sáng và Tối.

00:03:32.000 --> 00:03:40.000
Hệ thống sẽ tự động sử dụng các giá trị màu chính xác và sẽ cập nhật khi chế độ thay đổi.

00:03:40.000 --> 00:03:46.000
Ứng dụng của bạn cũng nên hỗ trợ các hình ảnh thay thế cho Chế độ sáng và Chế độ tối.

00:03:46.000 --> 00:03:57.000
Để tìm hiểu thêm về việc tùy chỉnh ứng dụng của bạn cho Chế độ tối, hãy xem "Thực hiện Chế độ tối trên iOS" từ WWDC 2019.

00:03:57.000 --> 00:04:06.000
Bây giờ bạn đã biết cách áp dụng Chế độ tối trong ứng dụng của mình, bạn cũng nên suy nghĩ về cách áp dụng Chế độ tối cho nội dung web của mình.

00:04:06.000 --> 00:04:14.000
Safari không tự động làm tối bất kỳ nội dung web nào, vì vậy hãy đảm bảo rằng bạn cũng áp dụng Chế độ tối cho nội dung web của mình.

00:04:14.000 --> 00:04:20.000
Để làm như vậy, hãy triển khai thuộc tính sơ đồ màu trong biểu định kiểu trang web của bạn.

00:04:20.000 --> 00:04:31.000
Điều này cho phép văn bản mặc định và màu nền của trang web phù hợp với giao diện hệ thống hiện tại, điều khiển biểu mẫu tiêu chuẩn và thanh cuộn.

00:04:31.000 --> 00:04:38.000
Các màu hệ thống được đặt tên khác thay đổi giao diện của chúng, chuyển đổi giữa Chế độ Sáng và Tối.

00:04:38.000 --> 00:04:44.000
Bắt đầu sử dụng các biến biểu định kiểu bất cứ nơi nào màu sắc được tham chiếu trong biểu định kiểu của bạn.

00:04:44.000 --> 00:04:51.000
Điều này cho phép nội dung web của bạn cập nhật màu sắc khi thiết bị chuyển đổi giữa Sáng và Tối.

00:04:51.000 --> 00:05:00.000
Áp dụng logic tương tự cho hình ảnh và các nội dung phương tiện khác trên các trang web của bạn, với các biến thể khác nhau cho các chế độ khác nhau.

00:05:00.000 --> 00:05:11.000
Để tìm hiểu thêm về việc triển khai Chế độ tối cho nội dung web, hãy tham khảo "Hỗ trợ Chế độ tối trong nội dung web của bạn" từ WWDC 2019.

00:05:11.000 --> 00:05:17.000
Một cách khác để giảm mức sử dụng năng lượng của ứng dụng là kiểm tra tốc độ khung hình của bạn.

00:05:17.000 --> 00:05:23.000
Trên các thiết bị có màn hình ProMotion, tốc độ làm mới có thể ảnh hưởng đến mức tiêu thụ điện năng.

00:05:23.000 --> 00:05:26.000
Tốc độ làm mới cao hơn sử dụng năng lượng cao hơn.

00:05:26.000 --> 00:05:32.000
Tốc độ khung hình của hình ảnh động trong ứng dụng của bạn xác định tốc độ làm mới của màn hình.

00:05:32.000 --> 00:05:42.000
Hãy quan tâm đến nội dung chính trong ứng dụng của bạn và tốc độ khung hình mà nó yêu cầu, vì không phải tất cả nội dung trong ứng dụng của bạn đều có thể yêu cầu tốc độ khung hình cao.

00:05:42.000 --> 00:05:48.000
Tốc độ làm mới của màn hình được xác định bởi hình ảnh động có tốc độ khung hình cao nhất trong ứng dụng của bạn.

00:05:48.000 --> 00:06:00.000
Ứng dụng của bạn có thể có các yếu tố thứ cấp làm mới với tốc độ cao hơn mức cần thiết, khiến toàn bộ ứng dụng tiêu thụ nhiều pin hơn dự kiến.

00:06:00.000 --> 00:06:03.000
Ở đây chúng tôi có ứng dụng xe tải thực phẩm một lần nữa.

00:06:03.000 --> 00:06:08.000
Cảnh xe tải chính ở trên cùng đang hiển thị ở tốc độ 30 khung hình mỗi giây.

00:06:08.000 --> 00:06:15.000
Bên dưới xe tải, có một lớp phủ văn bản "Xe tải thực phẩm", đang cuộn theo chiều ngang.

00:06:15.000 --> 00:06:19.000
Văn bản phụ này đang hiển thị ở tốc độ 60 khung hình mỗi giây.

00:06:19.000 --> 00:06:24.000
Kết quả là, toàn bộ màn hình hiện đang hiển thị với tốc độ 60 khung hình mỗi giây.

00:06:24.000 --> 00:06:33.000
Nếu chúng ta thay đổi hoạt ảnh văn bản thành 30 khung hình / giây, thì toàn bộ màn hình có thể hiển thị ở tốc độ 30 khung hình / giây và chúng ta có thể tiết kiệm tới 20% lượng pin.

00:06:33.000 --> 00:06:36.000
Thật tuyệt vời!

00:06:36.000 --> 00:06:42.000
Để gỡ lỗi và nhận thêm thông tin về tốc độ khung hình trong ứng dụng của bạn, hãy sử dụng Công cụ.

00:06:42.000 --> 00:06:51.000
Sử dụng công cụ CoreAnimation FPS để xem dòng thời gian hiển thị tốc độ khung hình của ứng dụng của bạn theo thời gian.

00:06:51.000 --> 00:06:54.000
Bắt đầu bằng cách kiểm tra các kịch bản người dùng chính.

00:06:54.000 --> 00:07:06.000
Để xác định xem các khung hình có được hiển thị với tốc độ bạn mong đợi hay không, hãy xác định xem các yếu tố phụ trên màn hình có tốc độ khung hình cao hơn nội dung chính của bạn hay không.

00:07:06.000 --> 00:07:16.000
Ứng dụng của bạn có thể đang sử dụng CADisplayLink do CoreAnimation cung cấp trên iOS để thúc đẩy hoạt ảnh tùy chỉnh và vòng lặp kết xuất tùy chỉnh.

00:07:16.000 --> 00:07:21.000
CADisplayLink là bộ hẹn giờ được đồng bộ hóa với tốc độ làm mới màn hình.

00:07:21.000 --> 00:07:30.000
Nó cung cấp thông tin thời gian cần thiết cho ứng dụng của bạn để bản vẽ tùy chỉnh của bạn có thể nhận thức được các sự kiện làm mới.

00:07:30.000 --> 00:07:37.000
Ứng dụng của bạn có thể đưa ra gợi ý cho đối tượng CADisplayLink về tốc độ làm mới màn hình mong muốn.

00:07:37.000 --> 00:07:47.000
Đặt phạm vi khung hình ưa thích của CADisplayLink và chỉ định tốc độ khung hình tối thiểu, tối đa và ưa thích của bạn.

00:07:47.000 --> 00:07:55.000
Liên kết hiển thị sau đó sẽ chọn tốc độ khung hình khả dụng gần nhất với tốc độ ưa thích của bạn, dựa trên những gì hệ thống có thể xử lý.

00:07:55.000 --> 00:08:02.000
Nếu nó không thể cung cấp tỷ lệ đó, nó sẽ cố gắng ở trong phạm vi được chỉ định của bạn.

00:08:02.000 --> 00:08:07.000
Để cấu hình liên kết hiển thị của bạn, hãy khởi tạo nó với một mục tiêu và bộ chọn.

00:08:07.000 --> 00:08:16.000
Bộ chọn được cung cấp được sử dụng để thực hiện hoạt ảnh tùy chỉnh và tính toán khung video nào sẽ hiển thị tiếp theo.

00:08:16.000 --> 00:08:20.000
Khi liên kết hiển thị của bạn được khởi tạo, hãy đặt phạm vi tốc độ khung hình ưa thích.

00:08:20.000 --> 00:08:29.000
Trong ví dụ này, tỷ lệ ưu tiên là 30, nhưng phạm vi có thể xử lý bất cứ thứ gì từ 10 đến 60.

00:08:29.000 --> 00:08:34.000
Cuối cùng, thêm liên kết hiển thị vào vòng lặp chạy hiện tại.

00:08:34.000 --> 00:08:39.000
Hãy ghi nhớ tốc độ làm mới khi nghĩ về mức tiêu thụ pin của ứng dụng của bạn.

00:08:39.000 --> 00:08:47.000
Điều này đặc biệt quan trọng đối với các thiết bị có màn hình ProMotion hỗ trợ tốc độ làm mới rất động.

00:08:47.000 --> 00:08:55.000
Theo dõi tốc độ khung hình ứng dụng của bạn với Instruments để khám phá các vấn đề trước khi bạn phát hành ứng dụng của mình.

00:08:55.000 --> 00:09:05.000
Cuối cùng, cung cấp thông tin cho hệ thống, sử dụng CADisplayLink để giới hạn tốc độ làm mới cho nội dung ứng dụng của bạn.

00:09:05.000 --> 00:09:15.000
Để tìm hiểu thêm về tối ưu hóa tốc độ khung hình, hãy tham khảo "Tối ưu hóa cho màn hình tốc độ làm mới thay đổi" từ WWDC 2021.

00:09:15.000 --> 00:09:21.000
Bây giờ, hãy nói về cách bạn có thể tắt nguồn ứng dụng của mình khi nó đang chạy trong nền.

00:09:21.000 --> 00:09:31.000
Khi ai đó chuyển từ ứng dụng của bạn sang một ứng dụng khác, ứng dụng của bạn có thể dựa vào API thực thi nền để tiếp tục chạy trong nền.

00:09:31.000 --> 00:09:39.000
Trong khi chạy ở chế độ nền, ứng dụng của bạn có thể tiếp tục sử dụng các dịch vụ phổ biến như vị trí và âm thanh.

00:09:39.000 --> 00:09:49.000
Chạy các dịch vụ này trong thời gian dài sẽ khiến pin cạn kiệt, vì vậy khi ứng dụng của bạn đang sử dụng các dịch vụ này trong nền, bạn cần đặc biệt cẩn thận!

00:09:49.000 --> 00:10:01.000
Vì vậy, hãy nói về cách tránh thoát nước dư thừa khi sử dụng các chế độ này Dịch vụ định vị giữ cho thiết bị hoạt động để liên tục truyền vị trí.

00:10:01.000 --> 00:10:10.000
Mặc dù ứng dụng không hiển hình đối với người dùng, nhưng nó có thể liên tục phát trực tuyến vị trí trong nền và gây ra sự tiêu hao pin dư thừa.

00:10:10.000 --> 00:10:17.000
Điều quan trọng là phải đảm bảo rằng bạn đang ở trên đỉnh thời gian chạy phiên vị trí nền trong ứng dụng của mình.

00:10:17.000 --> 00:10:25.000
Khi bạn không còn cần phiên nữa, hãy đảm bảo ứng dụng của bạn gọi stopUpdatingLocation() để dừng phiên.

00:10:25.000 --> 00:10:34.000
Trong các giai đoạn phát triển ứng dụng khác nhau, bạn có thể sử dụng các công cụ khác nhau để tìm ra việc sử dụng vị trí nền, điều này có thể không được mong đợi.

00:10:34.000 --> 00:10:43.000
Trong khi xây dựng và thử nghiệm ứng dụng, đồng hồ đo Xcode có thể được sử dụng để tìm ra mức sử dụng năng lượng của hệ thống, cũng như việc sử dụng vị trí nền.

00:10:43.000 --> 00:10:51.000
Khi kiểm tra ứng dụng của bạn trước khi phát hành, bạn có thể sử dụng MetricKit để thu thập thông tin chẩn đoán trong một ngày sử dụng.

00:10:51.000 --> 00:10:57.000
Điểm mới trong iOS 16 là việc sử dụng vị trí trong Trung tâm điều khiển.

00:10:57.000 --> 00:11:05.000
Đồng hồ đo Xcode cung cấp thông tin về việc sử dụng hệ thống như CPU, Mạng và Sử dụng Vị trí.

00:11:05.000 --> 00:11:11.000
Đồng hồ đo Xcode sẽ hiển thị dòng thời gian sử dụng vị trí và tác động năng lượng của ứng dụng của bạn.

00:11:11.000 --> 00:11:20.000
Nhìn vào chế độ xem dòng thời gian này có thể là một cách tuyệt vời để xác minh rằng thời gian chạy vị trí của bạn dừng lại khi bạn mong đợi nó dừng lại.

00:11:20.000 --> 00:11:24.000
Một công cụ khác là sử dụng Metric Kit khi kiểm tra ứng dụng của bạn.

00:11:24.000 --> 00:11:34.000
Sử dụng thuộc tính cumulativeBackgroundLocationTime để tìm hiểu xem ứng dụng của bạn đã tích cực sử dụng các dịch vụ định vị trong nền trong bao lâu.

00:11:34.000 --> 00:11:43.000
Mới trong iOS 16, người dùng có thể theo dõi các ứng dụng hiện đang sử dụng dịch vụ định vị bằng cách điều hướng đến Trung tâm điều khiển.

00:11:43.000 --> 00:11:49.000
Họ có thể nhấn vào văn bản ở trên cùng để xem chi tiết các ứng dụng sử dụng vị trí.

00:11:49.000 --> 00:11:54.000
Sử dụng cái này để có cái nhìn sâu sắc về thời gian chạy vị trí của bạn.

00:11:54.000 --> 00:12:03.000
Nếu bạn thấy ứng dụng của mình ở đây và bạn không mong đợi, đó là một dấu hiệu cho thấy ứng dụng của bạn có phiên phát trực tuyến vị trí đang hoạt động.

00:12:03.000 --> 00:12:07.000
Chúng ta có thể áp dụng các nguyên tắc tương tự cho các phiên âm thanh.

00:12:07.000 --> 00:12:15.000
Giả sử chúng ta có một ứng dụng âm nhạc đang sử dụng trình phát âm thanh để phát lại một số tệp và người dùng dừng phát lại.

00:12:15.000 --> 00:12:26.000
Ứng dụng không chỉ nên tạm dừng hoặc dừng âm thanh mà còn nên tạm dừng hoặc dừng Công cụ âm thanh để ngăn nó chạy không hoạt động.

00:12:26.000 --> 00:12:35.000
Chúng tôi khuyên bạn nên sử dụng chế độ tự động tắt có thể được bật bằng cách đặt thuộc tính autoShutdownEnabled của lớp AVAudioEngine.

00:12:35.000 --> 00:12:42.000
Trong chế độ này, công cụ âm thanh liên tục theo dõi và phát hiện xem nó có nhàn rỗi trong một khoảng thời gian nhất định hay không.

00:12:42.000 --> 00:12:47.000
Khi không hoạt động, động cơ sẽ tắt phần cứng âm thanh.

00:12:47.000 --> 00:12:54.000
Và sau đó, nếu bất kỳ nguồn nào hoạt động trở lại, nó sẽ khởi động phần cứng âm thanh một cách linh hoạt.

00:12:54.000 --> 00:12:57.000
Và tất cả những điều này xảy ra dưới mui xe.

00:12:57.000 --> 00:13:02.000
Trên chế độ tự động tắt watchOS là hành vi bắt buộc.

00:13:02.000 --> 00:13:07.000
Đảm bảo dừng Công cụ Âm thanh khi không sử dụng để tiết kiệm năng lượng.

00:13:07.000 --> 00:13:13.000
Chìa khóa để hạn chế thời gian chạy nền là nhớ thông báo cho hệ thống khi bạn hoàn tất.

00:13:13.000 --> 00:13:18.000
Hành động cuối cùng bạn có thể thực hiện để cải thiện tuổi thọ pin là trì hoãn công việc.

00:13:18.000 --> 00:13:24.000
Trong suốt cả ngày, ứng dụng của bạn có thể xử lý nhiều tác vụ và dữ liệu khác nhau.

00:13:24.000 --> 00:13:37.000
Một số công việc này cần xảy ra ngay lập tức để phục vụ các hành động của người dùng, như hiển thị nội dung trên màn hình hoặc phát âm thanh hoặc video mà người dùng nhấn vào.

00:13:37.000 --> 00:13:45.000
Các công việc khác như nhiệm vụ học máy, tải lên phân tích hoặc sao lưu không nhạy cảm về thời gian.

00:13:45.000 --> 00:13:56.000
Nếu chúng ta trì hoãn công việc không nhạy cảm thời gian này sang thời điểm tốt hơn - khi thiết bị đang sạc - chúng ta có thể tiết kiệm pin và tránh tranh chấp với công việc tương tác và bắt đầu của người dùng.

00:13:56.000 --> 00:14:01.000
Hãy nói về ba API bạn có thể sử dụng để thực hiện điều này.

00:14:01.000 --> 00:14:07.000
BGProcessingTask là một lựa chọn tốt để trì hoãn các nhiệm vụ chạy trong thời gian dài.

00:14:07.000 --> 00:14:13.000
URLSession tùy ý là sự lựa chọn hoàn hảo để lên lịch kết nối mạng có thể trì hoãn.

00:14:13.000 --> 00:14:19.000
Và tận dụng mức độ ưu tiên đẩy phù hợp có thể giúp các máy chủ cung cấp các lần đẩy vào đúng thời điểm.

00:14:19.000 --> 00:14:22.000
Hãy đi vào chi tiết cho từng cái.

00:14:22.000 --> 00:14:24.000
Đầu tiên là BGProcessingTask.

00:14:24.000 --> 00:14:34.000
BGProcessingTask cho phép bạn trì hoãn các tác vụ xử lý lâu dài đến thời điểm tốt hơn, chẳng hạn như khi thiết bị đang sạc.

00:14:34.000 --> 00:14:41.000
Thật tuyệt vời cho các tác vụ như dọn dẹp cơ sở dữ liệu, tạo bản sao lưu và chạy đào tạo học máy.

00:14:41.000 --> 00:14:50.000
Để sử dụng nó, bạn chỉ cần tạo một yêu cầu bằng cách sử dụng BGProcessingTaskRequest API và cung cấp mã định danh ứng dụng.

00:14:50.000 --> 00:14:57.000
Sau đó cung cấp thêm thông tin, chẳng hạn như nếu nhiệm vụ của bạn cần nguồn điện hoặc mạng bên ngoài.

00:14:57.000 --> 00:15:03.000
Cung cấp thêm thông tin sẽ giúp hệ thống lên lịch công việc ở khung thời gian tốt hơn.

00:15:03.000 --> 00:15:12.000
Hệ thống sau đó sẽ khởi chạy ứng dụng của bạn trong nền vào thời điểm thích hợp và cấp vài phút thời gian chạy để hoàn thành công việc có thể trì hoãn.

00:15:12.000 --> 00:15:16.000
Tiếp theo là URLSession tùy ý.

00:15:16.000 --> 00:15:22.000
Ứng dụng của bạn có thể đã sử dụng Background URLSessions cho mạng chung.

00:15:22.000 --> 00:15:28.000
URLSessions nền thậm chí còn tốt hơn khi bạn sử dụng cờ tùy ý.

00:15:28.000 --> 00:15:42.000
URLSessions với cờ tùy ý là các giao dịch mạng được tải xuống hệ thống để thực hiện kết nối mạng vào thời điểm tối ưu hơn, chẳng hạn như khi thiết bị được cắm và kết nối với Wi-Fi.

00:15:42.000 --> 00:15:54.000
Cờ tùy ý rất phù hợp cho mạng dài hạn do người dùng khởi xướng, chẳng hạn như thu thập đo từ xa hoặc tải xuống tập tiếp theo của chương trình truyền hình.

00:15:54.000 --> 00:16:03.000
Và bởi vì mạng đã được giảm tải, điều đó có nghĩa là ứng dụng của bạn không cần phải chạy trong khi giao dịch mạng hoàn tất.

00:16:03.000 --> 00:16:14.000
Để sử dụng các phiên URL tùy ý, bạn chỉ cần thiết lập một phiên URL nền và đặt isDiscretionary thành true.

00:16:14.000 --> 00:16:20.000
Bạn có thể cung cấp thêm thông tin để giúp hệ thống lên lịch tải xuống vào đúng thời điểm.

00:16:20.000 --> 00:16:28.000
Vượt qua các khoảng thời gian chờ để hệ thống không cố gắng tải xuống mãi mãi, khiến pin cạn kiệt.

00:16:28.000 --> 00:16:36.000
Nếu bạn không muốn tải lên hoặc tải xuống dữ liệu cho đến một thời điểm nào đó sau đó trong tương lai, hãy vượt qua ngày bắt đầu sớm nhất.

00:16:36.000 --> 00:16:48.000
Cuối cùng, vượt qua kích thước khối lượng công việc dự kiến để hệ thống có thể cân bằng tải một cách thông minh giữa các tác vụ tải xuống khác nhau của bạn.

00:16:48.000 --> 00:17:03.000
Tương tự như cách bạn có thể kiểm soát tính tức thời của một số hoạt động nhất định với BGProcessingTask và các phiên URL tùy ý, bạn có thể ảnh hưởng đến tính tức thời của phân phối đẩy bằng cách sử dụng các ưu tiên đẩy khác nhau.

00:17:03.000 --> 00:17:08.000
Mức độ ưu tiên đẩy xác định mức độ khẩn cấp của lực đẩy cần được chuyển đến thiết bị.

00:17:08.000 --> 00:17:18.000
Để đẩy ưu tiên cao, máy chủ sẽ gửi đẩy ngay lập tức đến thiết bị, có khả năng đánh thức thiết bị và khiến pin cạn kiệt.

00:17:18.000 --> 00:17:29.000
Đối với các lần đẩy ưu tiên thấp, máy chủ sẽ trì hoãn việc gửi lần đẩy cho đến một thời điểm thích hợp, chẳng hạn như khi thiết bị thức hoặc một lần đẩy ưu tiên cao đi qua.

00:17:29.000 --> 00:17:34.000
Đẩy ưu tiên cao rất tốt cho các tin nhắn khẩn cấp như cảnh báo thời tiết khắc nghiệt.

00:17:34.000 --> 00:17:42.000
Đẩy ưu tiên thấp rất tốt cho các thông báo thụ động hơn mà không khẩn cấp và có thể bị trì hoãn.

00:17:42.000 --> 00:17:52.000
Tận dụng mức độ ưu tiên thấp để trì hoãn việc gửi các tin nhắn có thể trì hoãn sẽ tiết kiệm pin vì thiết bị sẽ không phải thức dậy thường xuyên sau khi ngủ.

00:17:52.000 --> 00:17:59.000
Để định cấu hình đẩy ưu tiên thấp, chỉ cần đặt apns-priority thành 5 trong tải trọng đẩy.

00:17:59.000 --> 00:18:06.000
Máy chủ sẽ lo phần còn lại và người dùng của bạn sẽ đánh giá cao việc tiết kiệm pin.

00:18:06.000 --> 00:18:10.000
Vì vậy, hãy kết thúc nó với một số suy nghĩ cuối cùng và các bước tiếp theo.

00:18:10.000 --> 00:18:13.000
Cung cấp tùy chọn Chế độ tối trong ứng dụng của bạn.

00:18:13.000 --> 00:18:18.000
Nếu người dùng chọn Chế độ tối, việc tôn trọng ý định của họ có thể tiết kiệm pin.

00:18:18.000 --> 00:18:25.000
Xem lại hình ảnh động của bạn và tìm kiếm cơ hội để giảm tốc độ khung hình xuống mức cần thiết.

00:18:25.000 --> 00:18:28.000
Một hình ảnh động nhỏ có thể có tác động lớn.

00:18:28.000 --> 00:18:34.000
Theo dõi chặt chẽ thời gian chạy nền của bạn bằng cách cho hệ thống biết khi nào bạn hoàn thành.

00:18:34.000 --> 00:18:42.000
Cuối cùng, hãy cân nhắc trì hoãn công việc nền lâu dài đến thời điểm tốt hơn, chẳng hạn như khi thiết bị được kết nối với bộ sạc.

00:18:42.000 --> 00:18:47.000
Nếu bạn làm tất cả những điều này, thì bạn sẽ thực sự tắt ứng dụng của mình.

00:18:47.000 --> 23:59:59.000
Cảm ơn bạn rất nhiều.

