WEBVTT

00:00:00.000 --> 00:00:14.000
- Xin chào, và chào mừng đến với Có gì mới trong TextKit và chế độ xem văn bản!

00:00:14.000 --> 00:00:18.000
Tôi là Donna Tom, và tôi là một kỹ sư TextKit.

00:00:18.000 --> 00:00:30.000
Trong iOS 15 và macOS Monterey, chúng tôi đã giới thiệu TextKit 2, một công cụ văn bản mới mạnh mẽ với hiệu suất, độ chính xác và độ an toàn được cải thiện.

00:00:30.000 --> 00:00:40.000
Kiến trúc bố cục dựa trên khung nhìn của TextKit 2 cung cấp bố cục văn bản hiệu suất cao, đặc biệt là đối với các tài liệu có nội dung lớn.

00:00:40.000 --> 00:00:56.000
TextKit 2 cung cấp trải nghiệm văn bản tốt hơn cho khán giả quốc tế bằng cách loại bỏ sự phức tạp không cần thiết khi làm việc với glyphs và nó hỗ trợ đầy đủ cho các công nghệ phông chữ hiện đại như OpenType và Variable Fonts.

00:00:56.000 --> 00:01:10.000
Và TextKit 2 tập trung vào việc với các đối tượng cấp cao hơn để kiểm soát bố cục văn bản giúp bạn dễ dàng tùy chỉnh bố cục văn bản của mình hơn để bạn có thể xây dựng những thứ thú vị hơn với ít mã hơn.

00:01:10.000 --> 00:01:19.000
Trong tương lai, công cụ TextKit 2 tạo thành nền tảng của bố cục văn bản và kết xuất trên tất cả các nền tảng của Apple.

00:01:19.000 --> 00:01:28.000
Các cải tiến, cập nhật và cải tiến hiệu suất trong tương lai đều sẽ tập trung vào công cụ TextKit 2.

00:01:28.000 --> 00:01:34.000
Bằng cách cập nhật lên TextKit 2, ứng dụng của bạn có thể nhận được những lợi ích của những cải tiến này khi chúng tôi triển khai chúng.

00:01:34.000 --> 00:01:39.000
Để có phần giới thiệu chuyên sâu về TextKit2, hãy xem video Meet TextKit2.

00:01:39.000 --> 00:01:47.000
Video đó bao gồm các nguyên tắc cơ bản và cách xây dựng các thành phần bố cục văn bản của riêng bạn bằng TextKit 2.

00:01:47.000 --> 00:01:56.000
Ngược lại, video này đề cập đến những tiến bộ mới nhất trong TextKit 2 và cách tận dụng tối đa chế độ xem văn bản được hỗ trợ 2 của TextKit.

00:01:56.000 --> 00:02:12.000
Đúng vậy, tôi đã nói chế độ xem văn bản, số nhiều, bởi vì bây giờ, kể từ iOS 16 và macOS Ventura, tất cả các điều khiển văn bản trong UIKit và AppKit đang sử dụng TextKit 2, bao gồm UITextView.

00:02:12.000 --> 00:02:17.000
Vì vậy, chúng tôi đang sử dụng TextKit 2 để bố trí và kết xuất tất cả trong toàn hệ thống.

00:02:17.000 --> 00:02:27.000
Điều quan trọng là tất cả các ứng dụng phải chuyển sang TextKit 2 càng sớm càng tốt và chúng tôi đã thêm một số công cụ để giúp bạn chuyển đổi dễ dàng hơn.

00:02:27.000 --> 00:02:31.000
Đối với nhiều ứng dụng, đây có thể là một quá trình chuyển đổi mã bằng không.

00:02:31.000 --> 00:02:36.000
Và chúng tôi hy vọng điều này sẽ đúng với các ứng dụng không thực hiện bất kỳ sửa đổi đặc biệt nào đối với chế độ xem văn bản của chúng.

00:02:36.000 --> 00:02:40.000
Tôi sẽ nói với bạn thêm một chút về điều đó sau.

00:02:40.000 --> 00:02:48.000
Nhưng trước tiên, tôi sẽ bắt đầu bằng cách xem xét những gì mới trong TextKit 2, bao gồm một số công cụ mà tôi vừa đề cập.

00:02:48.000 --> 00:02:54.000
Sau đó, tôi sẽ đi sâu vào chi tiết của chế độ tương thích TextKit 1 cho chế độ xem văn bản.

00:02:54.000 --> 00:03:03.000
Sau đó, tôi sẽ kết thúc với một cuộc thảo luận về các chiến lược hiện đại hóa mà bạn có thể sử dụng khi chuẩn bị chuyển mã của mình sang TextKit 2.

00:03:03.000 --> 00:03:08.000
Vì vậy, đầu tiên là những gì mới trong TextKit 2.

00:03:08.000 --> 00:03:15.000
TextKit 2 lần đầu tiên xuất hiện trên UIKit trong iOS 15, nơi UITextField được nâng cấp để sử dụng nó.

00:03:15.000 --> 00:03:26.000
Trong iOS 16, quá trình chuyển đổi UIKit sang TextKit 2 đã hoàn tất, với tất cả các điều khiển văn bản sử dụng TextKit 2 theo mặc định, bao gồm UITextView.

00:03:26.000 --> 00:03:32.000
Hầu hết các chế độ xem văn bản sẽ được tự động chọn tham gia TextKit 2, không yêu cầu bạn chấp nhận.

00:03:32.000 --> 00:03:42.000
Chỉ có một vài tình huống mà lượt xem văn bản có thể không được chọn tham gia và tôi sẽ đề cập đến điều đó trong phân đoạn tương thích của video này.

00:03:42.000 --> 00:03:44.000
Và đó là một câu chuyện tương tự cho AppKit.

00:03:44.000 --> 00:03:49.000
TextKit 2 lần đầu tiên xuất hiện trên AppKit trong macOS Big Sur.

00:03:49.000 --> 00:03:58.000
Trong macOS Monterey, NSTextField đã được nâng cấp để sử dụng nó theo mặc định và nó có sẵn cho NSTextView bằng cách chọn tham gia.

00:03:58.000 --> 00:04:03.000
Trong macOS Ventura, tất cả các điều khiển văn bản đều sử dụng TextKit 2 theo mặc định.

00:04:03.000 --> 00:04:14.000
Cũng giống như UITextView, hầu hết NSTextViews đều tự động chọn tham gia TextKit 2 và không yêu cầu bạn chấp nhận.

00:04:14.000 --> 00:04:22.000
TextEdit, một trình bao bọc mỏng xung quanh NSTextView, sử dụng TextKit 2 ở mọi nơi trong macOS Ventura.

00:04:22.000 --> 00:04:27.000
TextEdit đã sử dụng TextKit 2 ở chế độ văn bản thuần túy kể từ macOS Big Sur.

00:04:27.000 --> 00:04:34.000
Trong macOS Ventura, chế độ văn bản phong phú cũng sử dụng TextKit 2.

00:04:34.000 --> 00:04:42.000
Vì TextKit 2 là tiêu chuẩn mới, chúng tôi đã thêm một số hàm tạo tiện lợi cho cả UITextView và NSTextView.

00:04:42.000 --> 00:04:49.000
Sử dụng các hàm tạo mới này để chọn vào thời điểm khởi tạo công cụ văn bản nào sẽ sử dụng.

00:04:49.000 --> 00:04:58.000
Để tạo chế độ xem văn bản sử dụng TextKit 2, hãy sử dụng hàm tạo mới và chuyển true cho tham số "UsingTextLayoutManager".

00:04:58.000 --> 00:05:07.000
Nếu chế độ xem văn bản cần sử dụng TextKit 1 để tương thích, hãy chuyển "sai" thay thế.

00:05:07.000 --> 00:05:12.000
Và có một tùy chọn Bố cục Văn bản mới cho các chế độ xem văn bản được tạo trong Trình tạo Giao diện.

00:05:12.000 --> 00:05:18.000
Tùy chọn mới này cung cấp cho bạn quyền kiểm soát hệ thống bố cục nào để sử dụng trên cơ sở từng trường hợp.

00:05:18.000 --> 00:05:23.000
Cài đặt mặc định là hệ thống mặc định, đó là TextKit 2.

00:05:23.000 --> 00:05:30.000
Bạn cũng có thể chọn sử dụng TextKit 2 hoặc TextKit 1 một cách rõ ràng.

00:05:30.000 --> 00:05:34.000
TextKit 2 hiện hỗ trợ các vùng chứa văn bản không đơn giản.

00:05:34.000 --> 00:05:39.000
Các vùng chứa văn bản không đơn giản có thể có lỗ hoặc khoảng trống trong đó.

00:05:39.000 --> 00:05:45.000
Điều này cho phép văn bản bao quanh hình ảnh hoặc nội dung nội tuyến khác.

00:05:45.000 --> 00:05:55.000
Để tạo một vùng chứa văn bản không đơn giản, hãy sử dụng thuộc tính exclusionPaths trên NSTextContainer để xác định các khu vực không nên đặt văn bản.

00:05:55.000 --> 00:06:03.000
Để biết ví dụ về cách thực hiện việc này, hãy xem mã mẫu TextKitAndTextView từ các tài nguyên được liên kết với video này.

00:06:03.000 --> 00:06:10.000
Bạn có thể tìm thấy ví dụ liên quan trên tab "đường dẫn loại trừ".

00:06:10.000 --> 00:06:17.000
Chúng tôi đã cải tiến công cụ ngắt dòng trong TextKit 2 để chọn ngắt dòng đồng đều hơn cho các đoạn văn hợp lý.

00:06:17.000 --> 00:06:23.000
Đây là một thay đổi tinh tế dễ nhận thấy hơn trên các đoạn văn bản dài hơn.

00:06:23.000 --> 00:06:28.000
Ở đây chúng tôi có hai phiên bản của cùng một văn bản, được đặt trong cùng một khu vực.

00:06:28.000 --> 00:06:36.000
Chú ý các dòng kéo dài và khoảng cách giữa các từ lớn với ngắt dòng truyền thống.

00:06:36.000 --> 00:06:40.000
Điều đó ít xảy ra hơn nhiều với việc phá vỡ dòng chẵn mới.

00:06:40.000 --> 00:06:45.000
Điều này làm cho văn bản dễ đọc hơn và bạn nhận được nó miễn phí với TextKit 2.

00:06:45.000 --> 00:06:48.000
Không yêu cầu nhận con nuôi.

00:06:48.000 --> 00:06:53.000
Và cuối cùng, chúng tôi đã thêm hỗ trợ danh sách văn bản trong TextKit 2 cho tất cả các nền tảng.

00:06:53.000 --> 00:07:00.000
Với danh sách văn bản, bạn có thể lập trình tạo danh sách được đánh số hoặc dấu đầu dòng để hiển thị trong chế độ xem văn bản.

00:07:00.000 --> 00:07:07.000
TextKit 2 sử dụng NSTextList để biểu diễn danh sách văn bản, giống như TextKit 1.

00:07:07.000 --> 00:07:15.000
NSTextList từng chỉ khả dụng trong AppKit, nhưng trong iOS 16, nó cũng có sẵn trong UIKit.

00:07:15.000 --> 00:07:25.000
Sử dụng NSTextList cùng với NSmutableParagraphStyle để chỉ định rằng một đoạn văn trong bộ lưu trữ văn bản của bạn nên được định dạng dưới dạng danh sách để hiển thị.

00:07:25.000 --> 00:07:35.000
Chế độ xem văn bản chịu trách nhiệm chọn các thuộc tính này từ bộ lưu trữ văn bản và định dạng lại nội dung đoạn văn để trông giống như một danh sách.

00:07:35.000 --> 00:07:41.000
Mặc dù bản thân NSTextList không phải là mới, nhưng có một vài bổ sung TextKit 2 mới.

00:07:41.000 --> 00:07:47.000
Vì các danh sách có thể có các mục lồng nhau, nên việc biểu diễn chúng như một cấu trúc cây là điều tự nhiên.

00:07:47.000 --> 00:07:58.000
Trong TextKit 2, chúng tôi đã cải tiến NSTextElement để hỗ trợ cấu trúc chúng dưới dạng cây với các thuộc tính để truy cập các phần tử con và mẹ.

00:07:58.000 --> 00:08:02.000
Và chúng tôi đã thêm một lớp con phần tử mới được gọi là NSTextListElement.

00:08:02.000 --> 00:08:14.000
Khi người quản lý nội dung bắt gặp NSTextList trong nội dung văn bản, nó sẽ tạo NSTextListElements để đại diện cho các mục trong danh sách.

00:08:14.000 --> 00:08:22.000
Để có cái nhìn sâu sắc hơn về cách tạo danh sách văn bản và thêm các mục, hãy tham khảo mã mẫu TextKitAndTextView.

00:08:22.000 --> 00:08:27.000
Bạn có thể tìm thấy ví dụ liên quan trên tab "danh sách".

00:08:27.000 --> 00:08:38.000
Và trong khi bạn đang khám phá mã mẫu, đừng bỏ lỡ ví dụ đính kèm văn bản cho thấy cách sử dụng API của nhà cung cấp chế độ xem tệp đính kèm văn bản trong TextKit 2.

00:08:38.000 --> 00:08:47.000
Các API này cho phép bạn sử dụng giao diện người dùng hoặc NSView làm tệp đính kèm văn bản và các sự kiện có thể được xử lý trực tiếp bằng chế độ xem tệp đính kèm.

00:08:47.000 --> 00:08:54.000
Điều này làm cho việc xử lý sự kiện với các tệp đính kèm văn bản dễ dàng hơn rất nhiều và điều đó chỉ có thể thực hiện được với TextKit 2.

00:08:54.000 --> 00:08:57.000
Được rồi, đó là nó cho những gì mới trong TextKit 2.

00:08:57.000 --> 00:09:03.000
Tiếp theo, tôi sẽ đi vào chi tiết của chế độ tương thích TextKit 1.

00:09:03.000 --> 00:09:17.000
Vì TextKit 2 là một sự khởi đầu triệt để so với thiết kế của TextKit 1, chúng tôi hiểu rằng việc áp dụng đầy đủ TextKit 2 có thể mất một thời gian cho các ứng dụng được đầu tư mạnh vào kiến trúc TextKit 1.

00:09:17.000 --> 00:09:28.000
Chúng tôi muốn các ứng dụng này tiếp tục hoạt động tốt cho đến khi quá trình chuyển đổi có thể được thực hiện và đó là lý do tại sao chúng tôi đã thêm chế độ tương thích TextKit 1 đặc biệt cho UITextView và NSTextView.

00:09:28.000 --> 00:09:41.000
Khi bạn gọi rõ ràng NSLayoutManager API, chế độ xem văn bản sẽ thay thế NSTextLayoutManager của nó bằng NSLayoutManager và tự cấu hình lại để sử dụng TextKit 1.

00:09:41.000 --> 00:09:52.000
Điều này cũng có thể xảy ra nếu chế độ xem văn bản gặp phải các thuộc tính chưa được TextKit 2 hỗ trợ, chẳng hạn như bảng hoặc khi in.

00:09:52.000 --> 00:10:01.000
Nếu bạn gặp phải dự phòng thời gian chạy bất ngờ đối với TextKit 1 trong UITextView, hãy kiểm tra nhật ký để biết thông báo cảnh báo về công tắc.

00:10:01.000 --> 00:10:13.000
Đặt điểm dừng trên biểu tượng gạch dưới UITextViewEnablingCompatibilityMode để ghi lại dấu vết ngăn xếp và thông tin gỡ lỗi hữu ích khác.

00:10:13.000 --> 00:10:25.000
Đối với NSTextView, bạn có thể nhận thêm thông tin về dự phòng thời gian chạy bất ngờ bằng cách đăng ký nhận thông báo willSwitch hoặc didSwitchToNSLayoutManager.

00:10:25.000 --> 00:10:34.000
Nếu bạn phải quay lại TextKit 1, tốt nhất bạn nên chọn không tham gia vào thời điểm khởi tạo với chế độ xem văn bản được khởi tạo theo chương trình.

00:10:34.000 --> 00:10:40.000
Làm điều này bằng cách sử dụng vùng chứa văn bản của riêng bạn và trình quản lý bố cục TextKit 1.

00:10:40.000 --> 00:10:49.000
Một lựa chọn khác là sử dụng hàm tạo tiện lợi mới để khởi tạo chế độ xem văn bản TextKit 1 và chuyển sai làm tham số.

00:10:49.000 --> 00:10:54.000
Điều này sẽ làm cho chế độ xem văn bản của bạn sử dụng TextKit 1.

00:10:54.000 --> 00:11:03.000
Và tùy chọn thứ ba là sử dụng Trình tạo giao diện và đặt tùy chọn Bố cục văn bản mới thành TextKit 1 trên chế độ xem văn bản của bạn.

00:11:03.000 --> 00:11:05.000
Đây là điều cần chú ý.

00:11:05.000 --> 00:11:16.000
Nếu bạn đang hoán đổi trình quản lý bố cục của vùng chứa văn bản trong hoặc sau khi khởi tạo, thì chế độ xem văn bản của bạn sẽ quay trở lại TextKit 1 như được thiết kế.

00:11:16.000 --> 00:11:24.000
Thật không hiệu quả khi tạo tất cả các đối tượng TextKit 2 trong quá trình khởi tạo chỉ để vứt chúng đi ngay sau đó.

00:11:24.000 --> 00:11:28.000
Cũng có những tác dụng phụ tiềm ẩn của người dùng, tùy thuộc vào thời gian.

00:11:28.000 --> 00:11:38.000
Nếu nó xảy ra trong khi nhập, chế độ xem văn bản có thể mất tiêu điểm và làm gián đoạn đầu vào, yêu cầu chế độ xem văn bản phải được chọn lại để tiếp tục.

00:11:38.000 --> 00:11:44.000
Tránh điều này bằng cách chọn chế độ xem văn bản tại thời điểm khởi tạo.

00:11:44.000 --> 00:11:54.000
Bây giờ bạn đã biết tất cả về chế độ tương thích, đã đến lúc nói về cách tránh nó hoàn toàn bằng cách hiện đại hóa ứng dụng của bạn và áp dụng TextKit 2.

00:11:54.000 --> 00:11:59.000
Và có một điều thực sự quan trọng mà tôi muốn bạn nhớ.

00:11:59.000 --> 00:12:03.000
Chỉ có thể có một trình quản lý bố cục cho mỗi chế độ xem văn bản.

00:12:03.000 --> 00:12:11.000
Chế độ xem văn bản không thể có cả NSTextLayoutManager và NSLayoutManager cùng một lúc.

00:12:11.000 --> 00:12:17.000
Khi chế độ xem văn bản chuyển sang TextKit 1, không có cách nào tự động quay lại.

00:12:17.000 --> 00:12:25.000
Quá trình chuyển đổi hệ thống bố cục rất tốn kém và bạn sẽ mất bất kỳ trạng thái giao diện người dùng nào có mặt tại thời điểm chuyển đổi.

00:12:25.000 --> 00:12:33.000
Vì vậy, để có hiệu suất và khả năng sử dụng tối ưu, hệ thống sẽ không bao giờ chuyển chế độ xem văn bản trở lại TextKit 2 từ TextKit 1.

00:12:33.000 --> 00:12:36.000
Đó là một hoạt động một chiều.

00:12:36.000 --> 00:12:42.000
Điều này có nghĩa là nó thực sự quan trọng để tránh chế độ tương thích.

00:12:42.000 --> 00:12:46.000
Và có một vài lý do khác nhau khiến chế độ xem văn bản sẽ chuyển sang chế độ tương thích.

00:12:46.000 --> 00:12:55.000
Lý do số một để chế độ xem văn bản vào chế độ tương thích là truy cập thuộc tính Trình quản lý bố cục của chế độ xem văn bản.

00:12:55.000 --> 00:12:59.000
Những lý do khác ít phổ biến hơn nhiều.

00:12:59.000 --> 00:13:05.000
Vì vậy, một chiến lược quan trọng là tránh truy cập vào thuộc tính trình quản lý bố cục của chế độ xem văn bản.

00:13:05.000 --> 00:13:11.000
Cũng tránh truy cập trình quản lý bố cục thông qua vùng chứa văn bản của chế độ xem văn bản.

00:13:11.000 --> 00:13:20.000
Kiểm tra mã của bạn để sử dụng các thuộc tính này và xóa chúng hoặc thay thế chúng bằng các thuộc tính tương đương TextKit 2.

00:13:20.000 --> 00:13:29.000
Nếu bạn đang triển khai ứng dụng của mình cho các phiên bản hệ điều hành cũ hơn không có TextKit 2, bạn có thể không xóa hoàn toàn mã Trình quản lý bố cục của mình.

00:13:29.000 --> 00:13:36.000
Trong trường hợp đó, trước tiên bạn nên kiểm tra NSTextLayoutManager của chế độ xem văn bản.

00:13:36.000 --> 00:13:45.000
Đặt mã TextKit 2 của bạn vào mệnh đề if và đặt mã TextKit 1 vào mệnh đề else, bao gồm quyền truy cập layoutManager.

00:13:45.000 --> 00:13:57.000
Bằng cách này, mã TextKit 1 chỉ chạy khi TextKit 2 không khả dụng và truy vấn layoutManager của bạn sẽ không gây ra dự phòng ngoài ý muốn cho TextKit 1.

00:13:57.000 --> 00:14:09.000
Nếu bạn đã làm theo tất cả lời khuyên này và bạn vẫn gặp phải sự dự phòng bất ngờ đối với TextKit 1 đến từ hệ thống, đó là vấn đề của chúng tôi, vì vậy vui lòng báo cáo sự cố với Trợ lý phản hồi.

00:14:09.000 --> 00:14:25.000
Bao gồm việc nắm bắt dấu vết ngăn xếp tại thời điểm dự phòng, mà bạn có thể nhận được từ việc phá vỡ dấu gạch dưới UITextViewEnablingCompatibilityMode trong UIKit hoặc willSwitchToNSLayoutManagerNotification trong AppKit.

00:14:25.000 --> 00:14:34.000
Được rồi, bây giờ tôi sẽ đi vào chi tiết cụ thể của việc cập nhật mã liên quan đến các loại TextKit 1, bắt đầu với NSLayoutManager.

00:14:34.000 --> 00:14:44.000
Khi bạn đã kiểm tra mã của mình cho các truy vấn NSLayoutManager, bạn sẽ cần tìm ra TextKit 2 tương đương với NSTextLayoutManager.

00:14:44.000 --> 00:14:51.000
Một số API quản lý bố cục có tên tương tự giữa TextKit 1 và 2, và việc thay thế rất đơn giản.

00:14:51.000 --> 00:14:53.000
Đây là một vài ví dụ.

00:14:53.000 --> 00:15:04.000
Trong TextKit 1, bạn gọi usedRect(for: textContainer) trên NSLayoutManager để lấy hình chữ nhật giới hạn cho văn bản bên trong vùng chứa văn bản.

00:15:04.000 --> 00:15:12.000
Trong TextKit 2, bạn nhận được điều này từ thuộc tính usageBoundsForTextContainer trên NSTextLayoutManager.

00:15:12.000 --> 00:15:21.000
Trong TextKit 1, chúng tôi đã sử dụng tên "thuộc tính tạm thời" cho các thuộc tính chỉ ảnh hưởng đến kết xuất chứ không phải bố cục.

00:15:21.000 --> 00:15:27.000
Trong TextKit 2, chúng tôi gọi chính xác hơn những "thuộc tính kết xuất" đó.

00:15:27.000 --> 00:15:33.000
Nhưng có một số API TextKit 1 không có tương đương trực tiếp trong TextKit 2.

00:15:33.000 --> 00:15:43.000
Để hiểu tại sao, bạn cần hiểu rằng không có ký tự chính xác nào để ánh xạ glyph cho nhiều từ trong các chữ viết Ấn Độ như Kannada.

00:15:43.000 --> 00:15:50.000
Trong các tập lệnh này, glyphs có thể được tách ra, sắp xếp lại, kết hợp lại hoặc thậm chí bị xóa.

00:15:50.000 --> 00:16:03.000
Các API dựa trên glyph trên NSLayoutManager giả sử bạn có thể liên kết trực tiếp một phạm vi ký tự liền kề với một phạm vi glyph liền kề và điều đó không đúng với tất cả các tập lệnh.

00:16:03.000 --> 00:16:09.000
Sử dụng các API này có thể dẫn đến bố cục và kết xuất bị hỏng cho văn bản được viết bằng các tập lệnh như Kannada.

00:16:09.000 --> 00:16:14.000
Đó là lý do tại sao không có API glyph trong TextKit 2.

00:16:14.000 --> 00:16:19.000
Bạn không thể chỉ thay thế một TextKit 2 API cho TextKit 1 glyph API.

00:16:19.000 --> 00:16:24.000
Việc thay thế các API này đòi hỏi một cách tiếp cận khác.

00:16:24.000 --> 00:16:28.000
Vì vậy, đây là cách cập nhật mã dựa trên glyph.

00:16:28.000 --> 00:16:33.000
Bước đầu tiên là xác định bạn đang sử dụng API glyph nào.

00:16:33.000 --> 00:16:40.000
Tiếp theo, hãy xem cách bạn đang sử dụng các API đó và xác định những gì bạn đang cố gắng làm ở cấp độ cao.

00:16:40.000 --> 00:16:48.000
Mã dựa trên Glyph ở cấp độ rất thấp và có nhiều chi tiết không liên quan đến nhiệm vụ cấp cao của bạn.

00:16:48.000 --> 00:16:58.000
Khi bạn đã xác định nhiệm vụ cấp cao, hãy kiểm tra các cấu trúc có sẵn cho bạn trong TextKit 2 như các đoạn bố cục, đoạn dòng và lựa chọn văn bản.

00:16:58.000 --> 00:17:02.000
Những thứ này có thể giúp bạn hoàn thành nhiệm vụ của mình.

00:17:02.000 --> 00:17:06.000
Ví dụ, hãy xem xét mã TextKit 1 này.

00:17:06.000 --> 00:17:15.000
Có hai API glyph được sử dụng ở đây: numberOfGlyphs và lineFragmentRect(forGlyphAt: index).

00:17:15.000 --> 00:17:22.000
Mã TextKit 1 này đang lặp lại tất cả các glyph trong tài liệu và đếm các đoạn thẳng dòng.

00:17:22.000 --> 00:17:29.000
Nhiệm vụ cấp cao là đếm số dòng văn bản được bọc trong chế độ xem văn bản.

00:17:29.000 --> 00:17:40.000
Vì mã này đang hoạt động với các đoạn thẳng dòng, các cấu trúc TextKit 2 để sử dụng là NSTextLineFragment và NSTextLayoutFragment.

00:17:40.000 --> 00:17:43.000
Và đây là mã được viết lại để sử dụng TextKit 2.

00:17:43.000 --> 00:17:57.000
Thay vì lặp lại các glyph, nó liệt kê các đoạn bố cục văn bản trong tài liệu và cung cấp một kết thúc đếm tất cả các đoạn dòng văn bản trong mỗi đoạn bố cục.

00:17:57.000 --> 00:18:01.000
Hãy ghi nhớ ví dụ đó khi cập nhật mã của riêng bạn cho TextKit 2.

00:18:01.000 --> 00:18:09.000
Bây giờ tôi sẽ chuyển số và thảo luận về việc cập nhật mã dựa trên NSRange.

00:18:09.000 --> 00:18:19.000
TextKit 1 sử dụng NSRange để lập chỉ mục vào nội dung văn bản và NSRange là một chỉ mục tuyến tính thành một chuỗi.

00:18:19.000 --> 00:18:36.000
Đối với dòng chữ "Xin chào TextKit 2!" Dấu chấm than, NSRange đại diện cho "dấu chấm than Văn bản 2" là vị trí 6 và độ dài 10, vì nó bắt đầu ở ký tự thứ 6 và dài 10 ký tự.

00:18:36.000 --> 00:18:43.000
Mô hình tuyến tính này rất dễ hiểu và nó hoạt động rất tốt để lập chỉ mục thành các chuỗi.

00:18:43.000 --> 00:18:50.000
Nhưng mô hình tuyến tính không hoạt động để lập chỉ mục vào bất kỳ nội dung nào có nhiều cấu trúc hơn một chuỗi.

00:18:50.000 --> 00:18:52.000
Đây là một ví dụ.

00:18:52.000 --> 00:18:58.000
Tài liệu HTML được biểu diễn dưới dạng cấu trúc cây, trong đó mỗi thẻ là một nút trong cây.

00:18:58.000 --> 00:19:10.000
Nếu Hello TextKit 2 của chúng tôi! Văn bản là một phần của tài liệu HTML, không có cách nào để NSRange của chúng tôi cho chúng tôi biết rằng văn bản nằm bên trong thẻ span, lồng sâu 3 cấp độ.

00:19:10.000 --> 00:19:19.000
Mô hình tuyến tính không đủ biểu cảm để lưu trữ thông tin đó, vì vậy chúng ta không thể sử dụng nó để lập chỉ mục thành một cấu trúc lồng nhau như thế này.

00:19:19.000 --> 00:19:26.000
Đây là lý do tại sao TextKit 2 đã thêm các loại mới để biểu diễn các phạm vi trong nội dung văn bản.

00:19:26.000 --> 00:19:33.000
NSTextLocation là một đối tượng đại diện cho một vị trí duy nhất bên trong nội dung văn bản.

00:19:33.000 --> 00:19:38.000
NSTextRange bao gồm một vị trí bắt đầu và kết thúc.

00:19:38.000 --> 00:19:42.000
Vị trí cuối cùng bị loại trừ khỏi phạm vi.

00:19:42.000 --> 00:19:53.000
Các loại mới này có thể đại diện cho cấu trúc lồng nhau của tài liệu HTML này bằng cách xác định vị trí là nút DOM cộng với độ lệch ký tự.

00:19:53.000 --> 00:20:03.000
Vì NSTextLocation là một giao thức, bất kỳ đối tượng tùy chỉnh nào cũng có thể là một vị trí miễn là nó triển khai các phương thức giao thức NSTextLocation.

00:20:03.000 --> 00:20:11.000
Đây là cơ sở hạ tầng quan trọng để làm việc với các loại cửa hàng sao lưu khác nhau hỗ trợ dữ liệu có cấu trúc trong các mô hình của họ.

00:20:11.000 --> 00:20:23.000
Nhưng chế độ xem văn bản được xây dựng trên các cửa hàng sao lưu NSAttributedString không có cấu trúc này và chúng tôi không thể thay đổi điều đó mà không phá vỡ nhiều ứng dụng, bao gồm cả ứng dụng của bạn.

00:20:23.000 --> 00:20:30.000
Vì vậy, bạn sẽ tiếp tục sử dụng NSRange khi sử dụng các API xem văn bản như selectedRange hoặc scrollRangeToVisible.

00:20:30.000 --> 00:20:40.000
Và bạn sẽ cần chuyển đổi giữa NSRange và NSTextRange khi giao tiếp với trình quản lý bố cục TextKit 2 hoặc trình quản lý nội dung.

00:20:40.000 --> 00:20:50.000
Để chuyển đổi NSRange của chế độ xem văn bản thành NSTextRange, hãy xác định vị trí là chỉ mục số nguyên vào chuỗi được gán.

00:20:50.000 --> 00:20:56.000
Sử dụng vị trí NSRange làm vị trí bắt đầu cho NSTextRange.

00:20:56.000 --> 00:21:02.000
Sử dụng vị trí NSRange cộng với độ dài làm vị trí cuối của NSTextRange.

00:21:02.000 --> 00:21:09.000
Về mặt khái niệm, đó là cách ánh xạ từ NSRange sang NSTextRange.

00:21:09.000 --> 00:21:17.000
Trong thực tế, mã trông hơi khác một chút vì NSTextLocations phải là đối tượng.

00:21:17.000 --> 00:21:21.000
Bạn cần thông qua trình quản lý nội dung để tính toán các vị trí.

00:21:21.000 --> 00:21:31.000
Đối với vị trí bắt đầu, hãy hỏi người quản lý nội dung về vị trí bắt đầu tài liệu, sau đó bù đắp nó bằng vị trí của NSRange.

00:21:31.000 --> 00:21:38.000
Sau đó bù đắp vị trí bắt đầu bằng chiều dài của NSRange để có được vị trí kết thúc.

00:21:38.000 --> 00:21:45.000
Để đi theo hướng khác, hãy sử dụng trình quản lý nội dung văn bản để có được hai độ lệch khác nhau.

00:21:45.000 --> 00:21:53.000
Vị trí của NSRange là độ lệch giữa phần đầu của tài liệu và vị trí của NSTextRange.

00:21:53.000 --> 00:22:01.000
Và chiều dài của NSRange là độ lệch giữa vị trí bắt đầu và kết thúc của NSTextRange.

00:22:01.000 --> 00:22:09.000
UITextViews và UITextFields phù hợp với giao thức UITextInput, sử dụng UITextPosition và phạm vi.

00:22:09.000 --> 00:22:19.000
Hầu hết thời gian, bạn sẽ không cần chuyển đổi UITextRange trực tiếp sang NSTextRange khi sử dụng UITextView hoặc UITextField.

00:22:19.000 --> 00:22:26.000
Nhưng nếu bạn làm vậy, hãy sử dụng độ lệch số nguyên làm trung gian giữa hai loại phạm vi.

00:22:26.000 --> 00:22:38.000
Mặt khác, nếu bạn đang sử dụng chế độ xem tùy chỉnh với UITextInput, bạn có quyền kiểm soát trực tiếp các lớp con UITextPosition và UITextRange được sử dụng với chế độ xem của mình.

00:22:38.000 --> 00:22:51.000
Bạn có thể làm cho lớp con UITextPosition của mình phù hợp với NSTextLocation, triển khai phương thức cần thiết và sử dụng lớp con của bạn để tạo trực tiếp NSTextRanges.

00:22:51.000 --> 00:23:02.000
Cuối cùng, đây là một lời nhắc nhở để tránh sử dụng lại các đối tượng UITextPosition trên các chế độ xem khác nhau, ngay cả khi nội dung trong cả hai chế độ xem đều giống nhau.

00:23:02.000 --> 00:23:09.000
Vị trí UIText chỉ hợp lệ cho chế độ xem được sử dụng để tạo nó.

00:23:09.000 --> 00:23:14.000
Được rồi, bây giờ bạn đã có rất nhiều chiến lược theo ý của mình để hiện đại hóa mã của mình.

00:23:14.000 --> 00:23:21.000
Áp dụng các chiến lược này và ứng dụng của bạn sẽ sẵn sàng gặt hái những lợi ích của TextKit 2.

00:23:21.000 --> 00:23:24.000
Và đó là những gì mới trong TextKit và chế độ xem văn bản.

00:23:24.000 --> 00:23:33.000
Tôi đã đề cập đến rất nhiều cải tiến tuyệt vời trong TextKit 2 và chia sẻ một số chiến lược để cập nhật ứng dụng của bạn trong khi vẫn duy trì khả năng tương thích với các phiên bản hệ điều hành cũ hơn.

00:23:33.000 --> 00:23:39.000
Sử dụng TextKit 2 trong các ứng dụng của bạn ngay hôm nay để tận dụng tối đa những cải tiến mới.

00:23:39.000 --> 00:23:44.000
Kiểm tra chế độ xem văn bản của bạn để đảm bảo rằng chúng không vô tình quay trở lại TextKit 1.

00:23:44.000 --> 00:23:50.000
Và cuối cùng, sử dụng các chiến lược hiện đại hóa để tải ứng dụng của bạn trên TextKit 2.

00:23:50.000 --> 00:23:55.000
Chúng tôi nóng lòng muốn đọc những gì bạn sẽ tạo với TextKit 2 và chế độ xem văn bản.

00:23:55.000 --> 23:59:59.000
Cảm ơn vì đã xem!

