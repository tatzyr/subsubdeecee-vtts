WEBVTT

00:00:00.000 --> 00:00:09.000
♪ nhạc cụ hip hop ♪

00:00:09.000 --> 00:00:11.000
Xin chào, tên tôi là Philippe.

00:00:11.000 --> 00:00:15.000
Swift có một danh mục ngày càng tăng các gói mã nguồn mở.

00:00:15.000 --> 00:00:20.000
Tôi vui mừng giới thiệu với bạn một trong những bổ sung mới nhất: Thuật toán Swift Async.

00:00:20.000 --> 00:00:26.000
Gói này nằm cùng với các gói khác, như Bộ sưu tập Swift và Thuật toán Swift.

00:00:26.000 --> 00:00:35.000
Gói Swift Async Algorithms là một tập hợp các thuật toán đặc biệt tập trung vào việc xử lý các giá trị theo thời gian bằng cách sử dụng AsyncSequence.

00:00:35.000 --> 00:00:40.000
Nhưng trước khi chúng ta đi sâu vào nó, chúng ta hãy dành một chút thời gian ngắn để tóm tắt lại AsyncSequence.

00:00:40.000 --> 00:00:45.000
AsyncSequence là một giao thức cho phép bạn mô tả các giá trị được tạo ra không đồng bộ.

00:00:45.000 --> 00:00:50.000
Về cơ bản, nó giống như Sequence, nhưng có hai điểm khác biệt chính.

00:00:50.000 --> 00:00:58.000
Hàm tiếp theo từ trình lặp của nó là không đồng bộ, là nó có thể cung cấp các giá trị bằng cách sử dụng đồng thời Swift.

00:00:58.000 --> 00:01:03.000
Nó cũng cho phép bạn xử lý bất kỳ thất bại tiềm ẩn nào bằng cách sử dụng hiệu ứng ném của Swift.

00:01:03.000 --> 00:01:09.000
Và giống như trình tự, bạn có thể lặp lại nó, sử dụng cú pháp for-await-in.

00:01:09.000 --> 00:01:15.000
Tóm lại, nếu bạn biết cách sử dụng Sequence, bạn đã biết cách sử dụng AsyncSequence.

00:01:15.000 --> 00:01:24.000
Bây giờ, khi AsyncSequence được giới thiệu, chúng tôi đã thêm vào hầu hết các công cụ mà bạn mong đợi tìm thấy với Sequence ngay tại đó với các phiên bản không đồng bộ.

00:01:24.000 --> 00:01:30.000
Bạn có các thuật toán như bản đồ, bộ lọc, giảm và hơn thế nữa.

00:01:30.000 --> 00:01:41.000
Gói Swift Async Algorithms tiến thêm một bước nữa bằng cách kết hợp các thuật toán nâng cao hơn, cũng như tương tác với đồng hồ để cung cấp cho bạn một số thứ thực sự mạnh mẽ.

00:01:41.000 --> 00:01:48.000
Đây là một gói mã nguồn mở của các thuật toán AsyncSequence giúp tăng tính đồng thời của Swift.

00:01:48.000 --> 00:01:51.000
Năm ngoái chúng tôi đã giới thiệu gói Swift Algorithms.

00:01:51.000 --> 00:01:55.000
Để chứng minh việc sử dụng các thuật toán đó, chúng tôi đã tạo một ứng dụng nhắn tin.

00:01:55.000 --> 00:02:00.000
Đây là một ví dụ tuyệt vời về một số thứ phong phú và mạnh mẽ mà bạn có thể làm với gói đó.

00:02:00.000 --> 00:02:07.000
Chúng tôi quyết định có một số cơ hội thực sự tốt để tận dụng lợi thế của việc di chuyển ứng dụng để sử dụng Swift đồng thời.

00:02:07.000 --> 00:02:16.000
Để làm nổi bật chỉ một vài thuật toán không đồng bộ, tôi sẽ đưa bạn qua một số thứ mà chúng tôi đã sử dụng và cách chúng hoạt động.

00:02:16.000 --> 00:02:21.000
Trước hết, chúng tôi có một họ các thuật toán để làm việc với nhiều AsyncSequences đầu vào.

00:02:21.000 --> 00:02:27.000
Đây là những thuật toán tập trung vào việc kết hợp AsyncSequences với nhau theo những cách khác nhau.

00:02:27.000 --> 00:02:36.000
Nhưng tất cả chúng đều có chung một đặc điểm: Chúng lấy nhiều AsyncSequences đầu vào và tạo ra một AsyncSequence đầu ra.

00:02:36.000 --> 00:02:40.000
Một thứ mà bạn có thể đã quen thuộc là Zip.

00:02:40.000 --> 00:02:48.000
Thuật toán Zip lấy nhiều đầu vào và lặp lại chúng sao cho nó tạo ra một bộ kết quả từ mỗi cơ sở.

00:02:48.000 --> 00:02:52.000
Mỗi đầu vào cho Zip là các cơ sở mà Zip được xây dựng từ đó.

00:02:52.000 --> 00:03:04.000
Thuật toán Zip không đồng bộ hoạt động giống như thuật toán Zip trong thư viện tiêu chuẩn, nhưng nó lặp lại đồng thời từng cơ sở và ném lại lỗi nếu xảy ra lỗi khi lặp lại bất kỳ cơ sở nào trong số chúng.

00:03:04.000 --> 00:03:10.000
Bây giờ, việc hoàn thành lần lặp lại đồng thời đó với lỗi ném lại có thể khá liên quan.

00:03:10.000 --> 00:03:15.000
Nhưng gói Swift Async Algorithms đã xử lý tất cả những điều đó cho chúng tôi trong ứng dụng nhắn tin của chúng tôi.

00:03:15.000 --> 00:03:26.000
Trước đây chúng tôi đã có rất nhiều mã điều phối việc tạo ra các bản xem trước không đồng bộ các bản ghi video và chuyển mã video thành nhiều kích cỡ để lưu trữ và truyền tải hiệu quả.

00:03:26.000 --> 00:03:33.000
Bằng cách sử dụng Zip, chúng tôi có thể đảm bảo rằng video được chuyển mã sẽ được xem trước khi chúng tôi gửi nó đến máy chủ.

00:03:33.000 --> 00:03:39.000
Vì Zip là đồng thời, cả chuyển mã hoặc xem trước sẽ không trì hoãn lẫn nhau.

00:03:39.000 --> 00:03:41.000
Nhưng điều này còn đi xa hơn một chút.

00:03:41.000 --> 00:03:55.000
Bản thân Zip không có ưu tiên về mặt nào tạo ra giá trị đầu tiên hay không, vì vậy một video có thể được sản xuất trước hoặc xem trước, và bất kể đó là bên nào, nó sẽ chờ bên kia gửi một bộ hoàn chỉnh.

00:03:55.000 --> 00:04:04.000
Chúng ta có thể chờ các cặp sao cho chúng có thể được tải lên cùng nhau vì Zip đang chờ mỗi bên đồng thời để xây dựng một bộ giá trị.

00:04:04.000 --> 00:04:10.000
Chúng tôi đã đi đến kết luận rằng việc mô hình hóa các tin nhắn đến của chúng tôi như một AsyncSequence có rất nhiều ý nghĩa.

00:04:10.000 --> 00:04:20.000
Vì vậy, chúng tôi quyết định sử dụng AsyncStream để xử lý những tin nhắn đó vì nó giữ nguyên thứ tự và biến các cuộc gọi lại của chúng tôi thành AsyncSequence của các tin nhắn.

00:04:20.000 --> 00:04:25.000
Một trong những tính năng được yêu cầu mà chúng tôi cần giải quyết là chúng tôi muốn hỗ trợ nhiều tài khoản.

00:04:25.000 --> 00:04:36.000
Vì vậy, mỗi tài khoản tạo ra một AsyncStream của các tin nhắn đến, nhưng khi triển khai điều này, chúng ta cần xử lý tất cả chúng cùng nhau như một AsyncSequence đơn lẻ.

00:04:36.000 --> 00:04:41.000
Điều này có nghĩa là chúng tôi cần một thuật toán để hợp nhất các AsyncSequences đó lại với nhau.

00:04:41.000 --> 00:04:49.000
Rất may, gói Swift Async Algorithms có một thuật toán cho chính xác điều đó, được đặt tên một cách khéo léo là "Hợp nhất".

00:04:49.000 --> 00:05:08.000
Nó hoạt động tương tự như Zip ở chỗ nó đồng thời lặp lại nhiều AsyncSequences. Nhưng thay vì tạo các bộ được ghép nối, nó yêu cầu các cơ sở chia sẻ cùng một loại phần tử và hợp nhất AsyncSequences cơ sở thành một AsyncSequence số ít của các phần tử đó.

00:05:08.000 --> 00:05:13.000
Hợp nhất các tác phẩm bằng cách lấy phần tử đầu tiên được tạo ra bởi bất kỳ bên nào khi lặp lại.

00:05:13.000 --> 00:05:23.000
Nó tiếp tục lặp lại cho đến khi không còn giá trị nào có thể được tạo ra, đặc biệt là khi tất cả các AsyncSequences cơ sở trả về số không từ trình lặp của chúng.

00:05:23.000 --> 00:05:27.000
Nếu bất kỳ cơ sở nào tạo ra lỗi, các lần lặp lại khác sẽ bị hủy bỏ.

00:05:27.000 --> 00:05:33.000
Điều này cho phép chúng tôi lấy AsyncSequences của các tin nhắn và hợp nhất chúng.

00:05:33.000 --> 00:05:43.000
Các thuật toán kết hợp này hoạt động đồng thời khi các giá trị được tạo ra, nhưng đôi khi rất hữu ích khi thực sự tương tác với chính thời gian.

00:05:43.000 --> 00:05:51.000
Gói Swift Async Algorithms mang đến một nhóm các thuật toán để làm việc theo thời gian bằng cách tận dụng Clock API mới trong Swift.

00:05:51.000 --> 00:06:06.000
Bản thân thời gian có thể là một chủ đề thực sự phức tạp và tính mới trong Swift (5.7) là một tập hợp các API để làm cho nó an toàn và nhất quán: Đồng hồ, Tức thì và Thời lượng.

00:06:06.000 --> 00:06:13.000
Giao thức Đồng hồ xác định hai nguyên thủy, một cách để thức dậy sau một khoảnh khắc nhất định và một cách để tạo ra một khái niệm về hiện tại.

00:06:13.000 --> 00:06:15.000
Có một vài chiếc đồng hồ tích hợp sẵn.

00:06:15.000 --> 00:06:20.000
Hai trong số những cái phổ biến hơn là ContinuousClock và SuspendingClock.

00:06:20.000 --> 00:06:28.000
Bạn có thể sử dụng ContinuousClock để đo thời gian giống như đồng hồ bấm giờ, nơi thời gian trôi qua bất kể trạng thái của vật đang được đo.

00:06:28.000 --> 00:06:35.000
Mặt khác, SuspendingClock thực hiện những gì tên gọi của nó ngụ ý; nó tạm dừng khi máy được đưa vào chế tạo trạng thái ngủ.

00:06:35.000 --> 00:06:45.000
Chúng tôi đã sử dụng API đồng hồ mới trong ứng dụng của mình để di chuyển từ các sự kiện gọi lại hiện có sang chức năng ngủ đồng hồ để xử lý việc loại bỏ các cảnh báo sau một thời hạn.

00:06:45.000 --> 00:06:55.000
Chúng tôi đã có thể tạo thời hạn bằng cách thêm giá trị thời lượng chỉ ra cụ thể số giây chúng tôi muốn trì hoãn.

00:06:55.000 --> 00:07:00.000
Đồng hồ cũng có một số phương pháp tiện dụng để đo thời gian thực hiện công việc đã trôi qua.

00:07:00.000 --> 00:07:07.000
Ở đây chúng ta có hai đồng hồ phổ biến mà tôi đã đề cập trước đó, SuspendingClock và ContinuousClock.

00:07:07.000 --> 00:07:12.000
Dưới đây là các màn hình hiển thị thời gian làm việc tiềm năng đã trôi qua đang được đo lường.

00:07:12.000 --> 00:07:20.000
Sự khác biệt chính giữa hai đồng hồ này đến từ hành vi của nó khi máy đang ngủ.

00:07:20.000 --> 00:07:36.000
Đối với công việc kéo dài như thế này, công việc có thể bị tạm dừng, giống như chúng tôi đã làm ở đây, nhưng khi chúng tôi tiếp tục thực thi, ContinuousClock đã tiến triển trong khi máy đang ngủ, nhưng SuspendingClock thì không.

00:07:36.000 --> 00:07:46.000
Thông thường, sự khác biệt này có thể là chi tiết chính để đảm bảo những thứ như hoạt ảnh hoạt động như mong đợi bằng cách tạm dừng thời gian thực hiện.

00:07:46.000 --> 00:07:53.000
Nếu bạn cần tương tác với thời gian liên quan đến máy, như đối với hoạt ảnh, hãy sử dụng SuspendingClock.

00:07:53.000 --> 00:07:59.000
Đo lường các nhiệm vụ liên quan đến con người phía trước thiết bị phù hợp hơn với Đồng hồ liên tục.

00:07:59.000 --> 00:08:07.000
Vì vậy, nếu bạn cần trì hoãn một khoảng thời gian tuyệt đối, một cái gì đó liên quan đến con người, hãy sử dụng ContinuousClock.

00:08:07.000 --> 00:08:21.000
Gói Swift Async Algorithms sử dụng các loại Clock, Instant và Duration mới này để xây dựng các thuật toán chung để xử lý nhiều khái niệm về cách các sự kiện được xử lý liên quan đến thời gian.

00:08:21.000 --> 00:08:27.000
Trong ứng dụng nhắn tin của chúng tôi, chúng tôi thấy những thứ này thực sự hữu ích để cung cấp quyền kiểm soát chính xác các sự kiện.

00:08:27.000 --> 00:08:33.000
Nó cho phép chúng tôi đánh giá giới hạn các tương tác và các tin nhắn đệm hiệu quả.

00:08:33.000 --> 00:08:38.000
Có lẽ lĩnh vực nổi bật nhất mà chúng tôi sử dụng thời gian là tìm kiếm tin nhắn.

00:08:38.000 --> 00:08:42.000
Chúng tôi đã tạo ra một bộ điều khiển quản lý một kênh kết quả.

00:08:42.000 --> 00:08:47.000
Kênh sắp xếp kết quả tìm kiếm từ nhiệm vụ tìm kiếm trở lại giao diện người dùng của chúng tôi.

00:08:47.000 --> 00:08:53.000
Bản thân nhiệm vụ tìm kiếm cần phải có một số đặc điểm cụ thể liên quan đến thời gian.

00:08:53.000 --> 00:08:59.000
Chúng tôi muốn đảm bảo giới hạn tốc độ tìm kiếm các tin nhắn đã gửi trên máy chủ.

00:08:59.000 --> 00:09:06.000
Thuật toán Debounce đang chờ đợi một khoảng thời gian tĩnh lặng trước khi nó phát ra các giá trị tiếp theo khi lặp lại.

00:09:06.000 --> 00:09:14.000
Điều đó có nghĩa là các sự kiện có thể đến nhanh chóng, nhưng chúng tôi muốn đảm bảo chờ đợi một khoảng thời gian yên tĩnh trước khi xử lý các giá trị.

00:09:14.000 --> 00:09:22.000
Khi đầu vào của người dùng từ trường tìm kiếm được thay đổi nhanh chóng, chúng tôi không muốn bộ điều khiển tìm kiếm kích hoạt yêu cầu tìm kiếm cho mỗi thay đổi.

00:09:22.000 --> 00:09:29.000
Thay vào đó, chúng tôi muốn đảm bảo đợi một khoảng thời gian yên tĩnh khi chúng tôi chắc chắn rằng việc đánh máy có thể sẽ được thực hiện.

00:09:29.000 --> 00:09:33.000
Theo mặc định, thuật toán Debounce sẽ sử dụng ContinuousClock.

00:09:33.000 --> 00:09:40.000
Trong trường hợp này, chúng ta có thể gỡ bỏ đầu vào sao cho nó chờ một khoảng thời gian xác định trong khi không có gì xảy ra.

00:09:40.000 --> 00:09:46.000
Đồng hồ và thời lượng không chỉ được sử dụng để tháo rời mà còn được sử dụng cho các thuật toán khác.

00:09:46.000 --> 00:09:52.000
Một lĩnh vực mà chúng tôi thấy thực sự hữu ích là gửi hàng loạt tin nhắn đến máy chủ.

00:09:52.000 --> 00:09:58.000
Trong gói thuật toán Swift, có một tập hợp các thuật toán cho các giá trị khối.

00:09:58.000 --> 00:10:06.000
Gói Swift Async Algorithms cung cấp những thứ đó, nhưng cũng thêm một tập hợp các phiên bản tương tác với đồng hồ và thời lượng.

00:10:06.000 --> 00:10:12.000
Họ các thuật toán phân đoạn cho phép kiểm soát các khối theo số lượng, theo thời gian hoặc theo nội dung.

00:10:12.000 --> 00:10:20.000
Nếu một lỗi xảy ra trong bất kỳ lỗi nào trong số này, lỗi đó sẽ được ném lại, vì vậy mã của chúng tôi an toàn khi xảy ra lỗi.

00:10:20.000 --> 00:10:28.000
Chúng tôi đã sử dụng API "chunked(by:)" để đảm bảo rằng các đoạn tin nhắn được tuần tự hóa và gửi đi trong một khoảng thời gian nhất định đã trôi qua.

00:10:28.000 --> 00:10:33.000
Bằng cách đó, máy chủ của chúng tôi nhận được các gói hiệu quả được gửi từ khách hàng.

00:10:33.000 --> 00:10:39.000
Chúng tôi đã có thể sử dụng API này để xây dựng các lô tin nhắn cứ sau 500 mili giây.

00:10:39.000 --> 00:10:47.000
Bằng cách đó, nếu ai đó thực sự hào hứng và gõ rất nhanh, các yêu cầu được gửi đến máy chủ sẽ được nhóm lại.

00:10:47.000 --> 00:10:54.000
Khi làm việc với các bộ sưu tập và trình tự, nó thường hữu ích và hiệu quả để xử lý các yếu tố lười biếng.

00:10:54.000 --> 00:11:00.000
AsyncSequence hoạt động giống như cách các thuật toán lười hoạt động trong thư viện tiêu chuẩn Swift.

00:11:00.000 --> 00:11:08.000
Nhưng cũng giống như những thuật toán lười biếng đó, thường có những lúc bạn cần quay trở lại thế giới của các bộ sưu tập.

00:11:08.000 --> 00:11:15.000
Gói Swift Async Algorithms cung cấp một tập hợp các trình khởi tạo để xây dựng các bộ sưu tập bằng AsyncSequence.

00:11:15.000 --> 00:11:23.000
Những thứ này cho phép bạn xây dựng từ điển, tập hợp hoặc mảng với AsyncSequences đầu vào được biết là hữu hạn.

00:11:23.000 --> 00:11:31.000
Các trình khởi tạo bộ sưu tập cho phép chúng tôi xây dựng các chuyển đổi ngay trong quá trình khởi tạo tin nhắn và giữ các loại dữ liệu của chúng tôi dưới dạng Mảng.

00:11:31.000 --> 00:11:38.000
Điều này thực sự hữu ích vì chúng tôi có nhiều tính năng thực sự có thể sử dụng một số cập nhật để sử dụng Swift đồng thời.

00:11:38.000 --> 00:11:47.000
Và bằng cách giữ các cấu trúc dữ liệu hiện có của chúng tôi, chúng tôi có thể di chuyển các phần của ứng dụng của mình từng bước và nơi nó có ý nghĩa.

00:11:47.000 --> 00:11:52.000
Cho đến nay, chúng tôi chỉ xem qua một số điểm nổi bật của gói Swift Async Algorithms.

00:11:52.000 --> 00:11:55.000
Có rất nhiều thứ hơn những gì chúng ta đã đề cập ngày hôm nay.

00:11:55.000 --> 00:12:13.000
Chúng tôi có các thuật toán khác nhau, từ việc kết hợp nhiều AsyncSequences, giới hạn tốc độ theo thời gian, chia mọi thứ thành nhiều phần, nhưng đó chỉ là những điểm nổi bật mà cuối cùng chúng tôi đã sử dụng rộng rãi trong ứng dụng của mình.

00:12:13.000 --> 00:12:16.000
Gói này có nhiều thứ hơn là chỉ những thứ đó.

00:12:16.000 --> 00:12:27.000
Nó bao gồm từ đệm, giảm, nối, đến tiêm các giá trị không liên tục và hơn thế nữa.

00:12:27.000 --> 00:12:39.000
Gói Swift Async Algorithms lấy tập hợp các thuật toán để xử lý mọi thứ theo thời gian và mở rộng nó thành một loạt các chức năng nâng cao có thể giúp bạn trong các ứng dụng của mình.

00:12:39.000 --> 00:12:40.000
Hãy thử nó.

00:12:40.000 --> 00:12:46.000
Chúng tôi thực sự hào hứng khi khám phá những gì bạn xây dựng với những thứ này và sự phấn khích đó được chia sẻ.

00:12:46.000 --> 00:12:50.000
Gói này đang được phát triển công khai với bạn.

00:12:50.000 --> 00:12:53.000
Cảm ơn vì đã xem, và tận hưởng phần còn lại của hội nghị.

00:12:53.000 --> 23:59:59.000
♪ nhạc cụ hip hop ♪

