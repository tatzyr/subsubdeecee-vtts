WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:15.000
Xin chào, tên tôi là Brett Keating, và tôi rất vui được giới thiệu cho bạn những điều mới mẻ trong khuôn khổ Tầm nhìn.

00:00:15.000 --> 00:00:17.000
Bạn có thể chưa quen với Vision.

00:00:17.000 --> 00:00:21.000
Có lẽ đây là phiên đầu tiên bạn thấy về khuôn khổ Tầm nhìn.

00:00:21.000 --> 00:00:24.000
Nếu vậy, chào mừng.

00:00:24.000 --> 00:00:28.000
Vì lợi ích của bạn, hãy tóm tắt ngắn gọn một số điểm nổi bật về khuôn khổ Tầm nhìn.

00:00:28.000 --> 00:00:31.000
Một số sự thật về khung Tầm nhìn dành cho bạn.

00:00:31.000 --> 00:00:40.000
Vision được giới thiệu lần đầu tiên vào năm 2017, và kể từ đó, hàng nghìn ứng dụng tuyệt vời đã được phát triển với công nghệ mà Vision cung cấp.

00:00:40.000 --> 00:00:52.000
Tầm nhìn là một tập hợp các thuật toán thị giác máy tính tiếp tục phát triển theo thời gian và bao gồm những thứ như phát hiện khuôn mặt, phân loại hình ảnh và phát hiện đường viền.

00:00:52.000 --> 00:00:56.000
Mỗi thuật toán này được cung cấp thông qua một API nhất quán, dễ sử dụng.

00:00:56.000 --> 00:01:01.000
Nếu bạn biết cách chạy một thuật toán trong khung Vision, bạn biết cách chạy tất cả chúng.

00:01:01.000 --> 00:01:10.000
Và Vision tận dụng tối đa Apple Silicon trên tất cả các nền tảng mà nó hỗ trợ, để cung cấp năng lượng cho việc học máy ở cốt lõi của nhiều thuật toán của Vision.

00:01:10.000 --> 00:01:20.000
Vision có sẵn trên tvOS, iOS và macOS; và sẽ tận dụng tối đa Apple Silicon trên Mac.

00:01:20.000 --> 00:01:27.000
Một số bổ sung gần đây cho khuôn khổ Tầm nhìn bao gồm phân đoạn Người, được hiển thị ở đây.

00:01:27.000 --> 00:01:34.000
Cũng ước tính tư thế tay, được hiển thị trong bản demo này.

00:01:34.000 --> 00:01:42.000
Và đây là ứng dụng mẫu Hành động và Tầm nhìn của chúng tôi, sử dụng ước tính tư thế cơ thể và phân tích quỹ đạo.

00:01:42.000 --> 00:01:57.000
Chương trình nghị sự của chúng tôi hôm nay bắt đầu với tổng quan về một số sửa đổi mới, đó là các bản cập nhật cho các yêu cầu hiện có thể cung cấp chức năng tăng lên, cải thiện hiệu suất hoặc cải thiện độ chính xác.

00:01:57.000 --> 00:02:00.000
Đầu tiên, chúng tôi có một bản sửa đổi mới để nhận dạng văn bản.

00:02:00.000 --> 00:02:06.000
Đây là bản sửa đổi thứ ba, được đưa ra bởi VNRecognizeTextRequestRevision3.

00:02:06.000 --> 00:02:10.000
Đây là công cụ nhận dạng văn bản cung cấp năng cho tính năng Văn bản Trực tiếp tuyệt vời.

00:02:10.000 --> 00:02:19.000
Trình nhận dạng văn bản hỗ trợ một số ngôn ngữ và bạn có thể khám phá ngôn ngữ nào được hỗ trợ bằng cách gọi supportedRecognitionLanguages.

00:02:19.000 --> 00:02:23.000
Bây giờ chúng tôi đã thêm một vài ngôn ngữ mới và tôi sẽ chỉ cho bạn một vài ví dụ.

00:02:23.000 --> 00:02:27.000
Chúng tôi hiện đang hỗ trợ ngôn ngữ Hàn Quốc trong Vision.

00:02:27.000 --> 00:02:31.000
Đây là một ví dụ về Vision tại nơi làm việc sao chép biên lai Hàn Quốc.

00:02:31.000 --> 00:02:40.000
Và đây là một ví dụ tương ứng cho tiếng Nhật, cũng hiển thị kết quả nhận dạng văn bản của Vision trên ngôn ngữ hiện được hỗ trợ này.

00:02:40.000 --> 00:02:46.000
Để nhận dạng văn bản, chúng tôi có một nhận dạng ngôn ngữ tự động mới.

00:02:46.000 --> 00:02:53.000
Bạn vẫn có thể chỉ định các ngôn ngữ nhận dạng để sử dụng bằng cách sử dụng thuộc tính recognitionLanguages.

00:02:53.000 --> 00:02:59.000
Nhưng giả sử bạn không biết trước ngôn ngữ mà người dùng ứng dụng của bạn có thể đang cố gắng nhận ra.

00:02:59.000 --> 00:03:12.000
Bây giờ, nhưng chỉ để có chế độ nhận dạng chính xác, bạn có thể yêu cầu trình nhận dạng văn bản tự động phát hiện ngôn ngữ bằng cách đặt tự động Phát hiện Ngôn ngữ thành đúng.

00:03:12.000 --> 00:03:21.000
Tốt nhất là sử dụng cái này chỉ cho một tình huống mà bạn không biết nên nhận ra ngôn ngữ nào, bởi vì việc phát hiện ngôn ngữ đôi khi có thể làm sai điều này.

00:03:21.000 --> 00:03:34.000
Nếu bạn có kiến thức trước về việc nhận dạng ngôn ngữ nào, tốt nhất bạn vẫn nên chỉ định các ngôn ngữ này cho Vision và để tự động tắtDetectsLanguage.

00:03:34.000 --> 00:03:43.000
Tiếp theo, chúng tôi có bản sửa đổi thứ ba mới để phát hiện mã vạch của mình, được gọi là VNDetectBarcodesRequestRevision3.

00:03:43.000 --> 00:03:49.000
Bản sửa đổi này thúc đẩy việc học máy hiện đại dưới mui xe, đây là một sự khởi đầu từ các bản sửa đổi trước đó.

00:03:49.000 --> 00:03:59.000
Mã vạch có nhiều ký hiệu khác nhau, từ mã vạch thường thấy trên các sản phẩm trong cửa hàng, đến mã QR, đến mã đặc biệt được sử dụng trong các ứng dụng chăm sóc sức khỏe.

00:03:59.000 --> 00:04:06.000
Để biết Vision hỗ trợ biểu tượng nào, bạn có thể gọi supportedSymbologies.

00:04:06.000 --> 00:04:08.000
Hãy nói về hiệu suất.

00:04:08.000 --> 00:04:20.000
Một phần vì chúng tôi đang sử dụng ML, chúng tôi đang phát hiện nhiều mã trong một lần chụp thay vì một mã tại một thời điểm, vì vậy yêu cầu sẽ nhanh hơn đối với hình ảnh chứa nhiều mã.

00:04:20.000 --> 00:04:27.000
Ngoài ra, nhiều mã hơn được phát hiện trong một hình ảnh nhất định chứa nhiều mã, do độ chính xác tăng lên.

00:04:27.000 --> 00:04:31.000
Và hơn nữa, có rất ít, nếu có, phát hiện trùng lặp.

00:04:31.000 --> 00:04:39.000
Các hộp giới hạn được cải thiện cho một số mã, đặc biệt là các mã tuyến tính như ean13, mà một dòng trước đây đã được trả về.

00:04:39.000 --> 00:04:45.000
Bây giờ, hộp giới hạn bao quanh toàn bộ mã hiển thị.

00:04:45.000 --> 00:04:56.000
Cuối cùng, mô hình ML có thể bỏ qua những thứ như bề mặt cong, phản xạ và các hiện vật khác đã cản trở độ chính xác của việc phát hiện trong quá khứ.

00:04:56.000 --> 00:05:11.000
Cả hai bản sửa đổi mới này, để nhận dạng văn bản và phát hiện mã vạch, tạo thành nền tảng công nghệ cho API Máy quét dữ liệu VisionKit, đây là một yếu tố giao diện người dùng thả vào thiết lập luồng máy ảnh để quét và trả lại mã vạch và văn bản.

00:05:11.000 --> 00:05:19.000
Nó thực sự là một bổ sung tuyệt vời cho SDK của chúng tôi và tôi thực sự khuyên bạn nên xem phiên về nó để tìm hiểu thêm.

00:05:19.000 --> 00:05:29.000
Bản sửa đổi mới cuối cùng mà tôi sẽ nói với bạn hôm nay là bản sửa đổi mới cho yêu cầu luồng quang học của chúng tôi được gọi là VNGenerateOpticalFlowRequestRevision2.

00:05:29.000 --> 00:05:37.000
Giống như máy dò mã vạch, bản sửa đổi mới này cũng sử dụng máy học hiện đại dưới mui xe.

00:05:37.000 --> 00:05:48.000
Mặc dù luồng quang học là một trong những vấn đề về thị giác máy tính được nghiên cứu lâu nhất, bạn có thể không nhận thức được những gì nó làm, so với việc phát hiện những thứ tạo thành một phần của cuộc sống hàng ngày của chúng ta, như văn bản và mã vạch.

00:05:48.000 --> 00:05:54.000
Luồng quang học phân tích hai hình ảnh liên tiếp, thường là các khung hình từ một video.

00:05:54.000 --> 00:06:04.000
Tùy thuộc vào trường hợp sử dụng của bạn, bạn có thể xem chuyển động giữa hai khung hình liền kề hoặc bỏ qua một vài khung hình ở giữa, nhưng trong mọi trường hợp, hai hình ảnh phải theo thứ tự thời gian.

00:06:04.000 --> 00:06:17.000
Phân tích cung cấp ước tính về hướng và độ lớn của chuyển động, hoặc bằng số lượng phần của hình ảnh đầu tiên cần "di chuyển", có thể nói, để được định vị chính xác trong hình ảnh thứ hai.

00:06:17.000 --> 00:06:23.000
VNPixelBufferObservation là kết quả, đại diện cho chuyển động này ở tất cả các vị trí trong hình ảnh.

00:06:23.000 --> 00:06:25.000
Đó là một hình ảnh hai kênh.

00:06:25.000 --> 00:06:30.000
Một kênh chứa cường độ X, và kênh kia chứa cường độ Y.

00:06:30.000 --> 00:06:41.000
Cùng với nhau, các vectơ 2D này tạo thành các vectơ 2D ở mỗi điểm ảnh được sắp xếp trong hình ảnh 2D này sao cho vị trí của chúng ánh xạ đến các vị trí tương ứng trong các hình ảnh được cung cấp làm đầu vào.

00:06:41.000 --> 00:06:43.000
Hãy xem cái này một cách trực quan.

00:06:43.000 --> 00:06:50.000
Giả sử bạn có một video sắp tới và một số khung hình đang đến, nhưng hãy xem xét hai hình ảnh này một cách cụ thể.

00:06:50.000 --> 00:06:52.000
Ở đây chúng tôi có một con chó đang chạy trên bãi biển.

00:06:52.000 --> 00:06:57.000
Từ hình ảnh bên trái sang hình ảnh bên phải, có vẻ như con chó đã di chuyển một chút sang trái.

00:06:57.000 --> 00:07:01.000
Bạn sẽ ước tính và thể hiện chuyển động này như thế nào?

00:07:01.000 --> 00:07:05.000
Chà, bạn sẽ chạy luồng quang học và đi đến một cái gì đó giống như hình ảnh bên dưới.

00:07:05.000 --> 00:07:12.000
Các khu vực tối hơn là nơi chuyển động đã được tìm thấy và lưu ý rằng nó thực sự trông giống như hình dạng của con chó.

00:07:12.000 --> 00:07:16.000
Đó là bởi vì chỉ có con chó thực sự di chuyển trong cảnh này.

00:07:16.000 --> 00:07:23.000
Chúng tôi đang hiển thị các vectơ chuyển động trong hình ảnh này bằng cách sử dụng "màu sai", ánh xạ x,y từ các vectơ thành bảng màu.

00:07:23.000 --> 00:07:30.000
Trong biểu diễn màu sai này, màu "đỏ" tình cờ biểu thị chuyển động chủ yếu sang trái.

00:07:30.000 --> 00:07:36.000
Bây giờ bạn đã thấy một ví dụ từ một khung hình, hãy xem nó trông như thế nào cho toàn bộ video clip.

00:07:36.000 --> 00:07:42.000
Ở đây chúng tôi tính toán lưu lượng quang học cho một đoạn clip ngắn về chú chó này đang lấy một chai nước trên bãi biển.

00:07:42.000 --> 00:07:45.000
Bên trái là kết quả từ bản sửa đổi 1.

00:07:45.000 --> 00:07:49.000
Bên phải là kết quả từ bản sửa đổi dựa trên ML mới của chúng tôi 2.

00:07:49.000 --> 00:07:52.000
Hy vọng rằng một số cải tiến trong bản sửa đổi 2 là rõ ràng để xem.

00:07:52.000 --> 00:07:58.000
Đối với một điều, có lẽ rõ ràng nhất, chuyển động của chai nước được ghi lại chính xác hơn nhiều.

00:07:58.000 --> 00:08:03.000
Bạn cũng có thể nhận thấy sự cải thiện trong một số chuyển động ước tính của con chó.

00:08:03.000 --> 00:08:10.000
Tôi nhận thấy những cải tiến ở đuôi rõ ràng nhất nhưng cũng có thể thấy chuyển động của tai anh ấy vỗ trong bản sửa đổi mới.

00:08:10.000 --> 00:08:17.000
Bản sửa đổi đầu tiên cũng chứa một chút chuyển động tiếng ồn xung quanh, trong khi bản sửa đổi thứ hai thể hiện chặt chẽ hơn các nền là không di chuyển.

00:08:17.000 --> 00:08:21.000
Hy vọng rằng ví dụ đó đã cho bạn một ý tưởng hay về những gì công nghệ này làm.

00:08:21.000 --> 00:08:25.000
Bây giờ chúng ta hãy đi sâu vào một chút về cách bạn có thể sử dụng nó trong ứng dụng của mình.

00:08:25.000 --> 00:08:29.000
Rõ ràng trường hợp sử dụng chính là phát hiện chuyển động cục bộ trong video.

00:08:29.000 --> 00:08:44.000
Điều này cung cấp trực tiếp vào các trường hợp sử dụng video bảo mật, trong đó điều quan trọng nhất là xác định và bản địa hóa các chuyển động lệch khỏi nền và cần đề cập rằng luồng quang học hoạt động tốt nhất cho các camera cố định, chẳng hạn như hầu hết các camera an ninh.

00:08:44.000 --> 00:08:51.000
Bạn có thể muốn sử dụng trình theo dõi đối tượng của Vision để theo dõi các đối tượng đang di chuyển trong video, nhưng cần biết nơi khởi tạo trình theo dõi.

00:08:51.000 --> 00:08:54.000
Luồng quang học cũng có thể giúp bạn ở đó.

00:08:54.000 --> 00:09:03.000
Nếu bạn có một số kiến thức về thị giác máy tính hoặc xử lý hình ảnh của riêng mình, bạn có thể tận dụng kết quả luồng quang học của chúng tôi để cho phép xử lý video hơn nữa.

00:09:03.000 --> 00:09:10.000
Nội suy video, hoặc phân tích hành động video, có thể được hưởng lợi rất nhiều từ luồng quang học thông tin cung cấp.

00:09:10.000 --> 00:09:16.000
Bây giờ chúng ta hãy tìm hiểu một số khác biệt bổ sung quan trọng giữa bản sửa đổi 1 và bản sửa đổi 2.

00:09:16.000 --> 00:09:22.000
Bản sửa đổi 1 luôn trả về các trường luồng quang học có cùng độ phân giải với đầu vào.

00:09:22.000 --> 00:09:25.000
Bản sửa đổi 2 cũng sẽ làm điều này theo mặc định.

00:09:25.000 --> 00:09:36.000
Tuy nhiên, có một nếp nhăn nhỏ: một phần do thực tế là bản sửa đổi 2 dựa trên ML, đầu ra của mô hình cơ bản có độ phân giải tương đối thấp so với hầu hết các độ phân giải hình ảnh đầu vào.

00:09:36.000 --> 00:09:45.000
Do đó, để phù hợp với hành vi mặc định của bản sửa đổi 1, một số nâng cấp phải được thực hiện và chúng tôi đang sử dụng lấy mẫu nâng cấp song tuyến để thực hiện việc này.

00:09:45.000 --> 00:09:48.000
Đây là một ví dụ trực quan giải thích những gì upsampling làm.

00:09:48.000 --> 00:09:55.000
Ở bên trái, chúng tôi có một phần phóng to đầu ra mạng, có độ phân giải thấp và do đó xuất hiện pixel.

00:09:55.000 --> 00:10:00.000
Trường dòng chảy tổng thể có thể có tỷ lệ khung hình là 7:5.

00:10:00.000 --> 00:10:06.000
Ở bên phải, chúng ta có một vùng tương tự được lấy từ cùng một trường, được lấy mẫu lên độ phân giải hình ảnh ban đầu.

00:10:06.000 --> 00:10:11.000
Có lẽ hình ảnh đó cũng có tỷ lệ khung hình khác nhau, giả sử là 16:9.

00:10:11.000 --> 00:10:18.000
Bạn sẽ nhận thấy rằng các cạnh của trường dòng chảy được làm mịn bằng cách lấy mẫu lên hai tuyến.

00:10:18.000 --> 00:10:30.000
Do tiềm năng các tỷ lệ khung hình khác nhau, hãy nhớ rằng là một phần của quá trình lấy mẫu, hình ảnh luồng sẽ được kéo dài để tương ứng chính xác trường dòng chảy với những gì đang xảy ra trong hình ảnh.

00:10:30.000 --> 00:10:41.000
Khi làm việc trực tiếp với đầu ra mạng, bạn nên tính đến độ phân giải và tỷ lệ khung hình theo cách tương tự khi ánh xạ kết quả luồng đến hình ảnh gốc.

00:10:41.000 --> 00:10:47.000
Bạn có tùy chọn bỏ qua việc lấy mẫu nâng cấp bằng cách bật keepNetworkOutput theo yêu cầu.

00:10:47.000 --> 00:10:50.000
Điều này sẽ cung cấp cho bạn đầu ra mô hình thô.

00:10:50.000 --> 00:10:57.000
Có bốn cài đặt tính toán chính xác mà bạn có thể áp dụng cho yêu cầu để chọn độ phân giải đầu ra có sẵn.

00:10:57.000 --> 00:11:06.000
Bạn có thể thấy độ phân giải cho từng cài đặt độ chính xác trong bảng này, nhưng hãy đảm bảo luôn kiểm tra chiều rộng và chiều cao của bộ đệm pixel có trong quan sát.

00:11:06.000 --> 00:11:10.000
Khi nào bạn nên sử dụng đầu ra mạng và khi nào bạn nên cho phép Vision nâng cấp mẫu?

00:11:10.000 --> 00:11:17.000
Hành vi mặc định là tốt nhất nếu bạn đã sử dụng luồng quang học và muốn hành vi đó vẫn tương thích ngược.

00:11:17.000 --> 00:11:24.000
Nó cũng là một lựa chọn tốt nếu bạn muốn đầu ra được lấy mẫu nâng cấp và bạn có thể chấp nhận được hai tuyến tính và đáng để có thêm bộ nhớ và độ trễ.

00:11:24.000 --> 00:11:33.000
Đầu ra mạng là tốt nhất nếu bạn không cần độ phân giải đầy đủ và có thể hình thành sự tương ứng nhanh chóng hoặc chỉ muốn khởi tạo trình theo dõi.

00:11:33.000 --> 00:11:40.000
Đầu ra mạng cũng có thể là lựa chọn đúng đắn nếu bạn cần một luồng độ phân giải đầy đủ, nhưng muốn sử dụng các phương pháp lấy mẫu của riêng bạn.

00:11:40.000 --> 00:11:44.000
Điều đó bao gồm các bản sửa đổi thuật toán mới cho phiên này.

00:11:44.000 --> 00:11:50.000
Hãy tiếp tục thảo luận về việc dọn dẹp mùa xuân mà chúng tôi đang thực hiện trong khuôn khổ Tầm nhìn và nó có thể ảnh hưởng đến bạn như thế nào.

00:11:50.000 --> 00:11:59.000
Lần đầu tiên chúng tôi giới thiệu tính năng nhận diện khuôn mặt và các mốc khuôn mặt khi Vision ban đầu được phát hành cách đây năm năm, dưới dạng "bản sửa đổi 1" cho mỗi thuật toán.

00:11:59.000 --> 00:12:06.000
Kể từ thời điểm đó, chúng tôi đã phát hành hai bản sửa đổi mới hơn, sử dụng các công nghệ hiệu quả hơn và chính xác hơn.

00:12:06.000 --> 00:12:15.000
Do đó, chúng tôi đang loại bỏ các bản sửa đổi đầu tiên của các thuật toán này khỏi khung Tầm nhìn, trong khi chỉ giữ các bản sửa đổi thứ hai và thứ ba.

00:12:15.000 --> 00:12:18.000
Tuy nhiên, nếu bạn sử dụng bản sửa đổi 1, đừng bao giờ sợ hãi.

00:12:18.000 --> 00:12:26.000
Chúng tôi sẽ tiếp tục hỗ trợ mã chỉ định bản sửa đổi 1 hoặc mã đã được biên dịch dựa trên SDK chỉ chứa bản sửa đổi 1.

00:12:26.000 --> 00:12:28.000
Làm thế nào điều đó có thể xảy ra, bạn có thể hỏi?

00:12:28.000 --> 00:12:36.000
Bản sửa đổi 1 thực hiện một thuật toán dưới mui xe mà tôi đã gọi là "máy dò bản sửa đổi 1" trong sơ đồ này.

00:12:36.000 --> 00:12:40.000
Theo cách tương tự, bản sửa đổi 2 sử dụng máy dò bản sửa đổi 2.

00:12:40.000 --> 00:12:48.000
Những gì chúng tôi đã làm cho bản phát hành Vision này là đáp ứng các yêu cầu sửa đổi 1 với đầu ra của máy dò sửa đổi 2.

00:12:48.000 --> 00:12:52.000
Ngoài ra, yêu cầu sửa đổi 1 sẽ được đánh dấu là không dùng nữa.

00:12:52.000 --> 00:12:59.000
Điều này cho phép chúng tôi loại bỏ hoàn toàn máy dò phiên bản 1 cũ, cho phép khung Vision vẫn được sắp xếp hợp lý.

00:12:59.000 --> 00:13:09.000
Điều này có một số lợi ích, không kém phần quan trọng là tiết kiệm dung lượng trên đĩa, điều này làm cho các bản phát hành hệ điều hành và SDK của chúng tôi ít tốn kém hơn để tải xuống và cài đặt.

00:13:09.000 --> 00:13:18.000
Tất cả các chuyên gia Tầm nhìn ngoài kia của bạn có thể đang nói với chính mình, "Nhưng chờ một chút, "bản sửa đổi 2 trở lại các mặt lộn ngược trong khi bản sửa đổi 1 thì không.

00:13:18.000 --> 00:13:21.000
Sự khác biệt về hành vi này không thể có tác động đến một số ứng dụng sao?"

00:13:21.000 --> 00:13:27.000
Nó chắc chắn sẽ như vậy, ngoại trừ việc chúng tôi sẽ thực hiện các biện pháp phòng ngừa để duy trì hành vi sửa đổi 1.

00:13:27.000 --> 00:13:32.000
Chúng tôi sẽ không trả lại các mặt lộn ngược từ máy dò sửa đổi 2.

00:13:32.000 --> 00:13:40.000
Tương tự, máy dò mốc sửa đổi 2 sẽ trả về kết quả phù hợp với chòm sao mốc sửa đổi 1.

00:13:40.000 --> 00:13:45.000
Thời gian thực hiện ngang bằng và bạn nên trải nghiệm sự gia tăng độ chính xác.

00:13:45.000 --> 00:13:54.000
Trong mọi trường hợp, thay đổi này sẽ không yêu cầu bất kỳ ứng dụng nào thực hiện bất kỳ sửa đổi nào đối với mã của họ và mọi thứ sẽ tiếp tục hoạt động.

00:13:54.000 --> 00:13:57.000
Tuy nhiên, chúng tôi vẫn có lời kêu gọi hành động cho bạn.

00:13:57.000 --> 00:14:02.000
Bạn không nên hài lòng với việc sử dụng bản sửa đổi 1 khi chúng tôi có sẵn các tùy chọn tốt hơn nhiều.

00:14:02.000 --> 00:14:08.000
Chúng tôi luôn khuyên bạn nên sử dụng các bản sửa đổi mới nhất và đối với những yêu cầu này, đó sẽ là bản sửa đổi 3.

00:14:08.000 --> 00:14:18.000
Tất nhiên lý do chính cho đề xuất này là sử dụng công nghệ mới nhất, cung cấp mức độ chính xác và hiệu suất cao nhất hiện có, và ai không muốn điều đó?

00:14:18.000 --> 00:14:31.000
Hơn nữa, chúng tôi đã thiết lập và liên lạc nhiều lần, và chúng tôi nhắc lại một lần nữa ở đây, phương pháp hay nhất là luôn chỉ định rõ ràng các sửa đổi của bạn, thay vì dựa vào các hành vi mặc định.

00:14:31.000 --> 00:14:34.000
Và đó là những gì chúng tôi đã làm cho việc dọn dẹp mùa xuân của mình.

00:14:34.000 --> 00:14:38.000
Bây giờ hãy nói về cách chúng tôi đã giúp gỡ lỗi các ứng dụng sử dụng khung Vision dễ dàng hơn.

00:14:38.000 --> 00:14:41.000
Chúng tôi đã thêm hỗ trợ Xem trước Quick Look vào Vision.

00:14:41.000 --> 00:14:44.000
Điều này có ý nghĩa gì đối với Vision nói riêng?

00:14:44.000 --> 00:14:52.000
Chà, bây giờ bạn có thể di chuột qua VNObservations trong trình gỡ lỗi và chỉ với một cú nhấp chuột, bạn có thể hình dung kết quả trên hình ảnh đầu vào của mình.

00:14:52.000 --> 00:14:55.000
Chúng tôi cũng đã cung cấp cái này trong Xcode Playgrounds.

00:14:55.000 --> 00:15:00.000
Tôi nghĩ cách duy nhất để thực sự giải thích điều này có thể mang lại lợi ích cho việc gỡ lỗi của bạn như thế nào là cho bạn thấy.

00:15:00.000 --> 00:15:04.000
Hãy chuyển sang bản demo Xcode.

00:15:04.000 --> 00:15:11.000
Ở đây chúng tôi có một thói quen đơn giản sẽ phát hiện các mốc khuôn mặt và trả lại các quan sát khuôn mặt.

00:15:11.000 --> 00:15:15.000
Đầu tiên, chúng tôi thiết lập một yêu cầu mốc khuôn mặt.

00:15:15.000 --> 00:15:20.000
Sau đó, nếu chúng tôi có một hình ảnh sẵn sàng để đi trong lớp học của chúng tôi, chúng tôi sẽ hiển thị nó.

00:15:20.000 --> 00:15:26.000
Sau đó, chúng tôi khai báo một mảng để giữ kết quả của chúng tôi.

00:15:26.000 --> 00:15:34.000
Bên trong autoreleasepool, chúng tôi khởi tạo trình xử lý yêu cầu với hình ảnh đó và sau đó thực hiện yêu cầu của mình.

00:15:34.000 --> 00:15:39.000
Giả sử mọi việc suôn sẻ, chúng tôi có thể lấy kết quả từ yêu cầu.

00:15:39.000 --> 00:15:44.000
Tôi sẽ chạy nó và đến điểm dừng sau khi chúng tôi lấy kết quả.

00:15:44.000 --> 00:15:45.000
Vì vậy, bây giờ tôi đang ở trong trình gỡ lỗi.

00:15:45.000 --> 00:15:50.000
Khi tôi di chuột qua kết quả, lớp phủ cho thấy tôi đã phát hiện ra ba khuôn mặt.

00:15:50.000 --> 00:15:53.000
Điều đó thật tuyệt. Tôi có ba khuôn mặt trong hình ảnh đầu vào của mình.

00:15:53.000 --> 00:15:56.000
Nhưng làm thế nào để tôi biết quan sát nào là khuôn mặt nào?

00:15:56.000 --> 00:15:59.000
Đó là nơi hỗ trợ Xem trước Xem nhanh xuất hiện.

00:15:59.000 --> 00:16:07.000
Khi tôi đi vào yêu cầu này, tôi có thể nhấp vào từng biểu tượng "mắt" để hình dung kết quả.

00:16:07.000 --> 00:16:15.000
Hình ảnh xuất hiện với các lớp phủ được vẽ cho chòm sao mốc và cho hộp giới hạn khuôn mặt.

00:16:15.000 --> 00:16:19.000
Bây giờ bạn đã biết quan sát đầu tiên ở đâu trong hình ảnh.

00:16:19.000 --> 00:16:27.000
Tôi có thể nhấp vào cái tiếp theo để vẽ lớp phủ cho lần quan sát thứ hai và cho lần quan sát thứ ba.

00:16:27.000 --> 00:16:34.000
Tiếp tục đến điểm dừng tiếp theo, chúng tôi chạy một số mã in các quan sát khuôn mặt vào bảng điều khiển gỡ lỗi.

00:16:34.000 --> 00:16:48.000
Như bạn có thể tưởng tượng, ở đây trong bảng điều khiển gỡ lỗi nơi thông tin khuôn mặt được in, khá khó để hình dung ngay lập tức trong tâm trí bạn khuôn mặt nào là khuôn mặt nào hoặc liệu kết quả có chính xác chỉ từ các tọa độ được in này hay không.

00:16:48.000 --> 00:16:51.000
Nhưng có một điều nữa để chỉ ra ở đây.

00:16:51.000 --> 00:16:57.000
Lưu ý rằng tôi đã phần nào buộc trình xử lý yêu cầu ra khỏi phạm vi một cách giả tạo bằng cách giới thiệu một bể tự động phát hành.

00:16:57.000 --> 00:17:03.000
Bây giờ trình xử lý yêu cầu đã nằm ngoài phạm vi, hãy sử dụng lại hỗ trợ Xem trước xem nhanh trên kết quả.

00:17:03.000 --> 00:17:09.000
Chà, bạn biết gì không, các lớp phủ vẫn được vẽ, nhưng hình ảnh không có sẵn.

00:17:09.000 --> 00:17:21.000
Đây là điều cần lưu ý: trình xử lý yêu cầu hình ảnh được sử dụng để tạo ra các quan sát vẫn phải nằm trong phạm vi ở đâu đó để hỗ trợ Xem trước xem nhanh sử dụng hình ảnh gốc để hiển thị.

00:17:21.000 --> 00:17:25.000
Đó là bởi vì trình xử lý yêu cầu hình ảnh là nơi chứa hình ảnh đầu vào của bạn.

00:17:25.000 --> 00:17:28.000
Mọi thứ sẽ tiếp tục hoạt động, nhưng hình ảnh sẽ không có sẵn.

00:17:28.000 --> 00:17:37.000
Hỗ trợ xem trước Quick Look này có thể đặc biệt hữu ích trong phiên Xcode Playgrounds, đồng thời thực hiện các thử nghiệm nhanh để xem mọi thứ hoạt động như thế nào.

00:17:37.000 --> 00:17:40.000
Hãy xem xét điều đó ngay bây giờ.

00:17:40.000 --> 00:17:44.000
Ở đây chúng tôi có một Sân chơi đơn giản được thiết lập để phân tích hình ảnh cho mã vạch.

00:17:44.000 --> 00:17:50.000
Thay vì xem qua mã này, chúng ta hãy thực hiện một vài sửa đổi và kiểm tra xem nó ảnh hưởng đến kết quả như thế nào.

00:17:50.000 --> 00:17:56.000
Chúng ta sẽ bắt đầu bằng cách sử dụng bản sửa đổi 2 trên một hình ảnh với hai mã vạch của các ký hiệu khác nhau.

00:17:56.000 --> 00:18:04.000
Tất cả các kết quả cùng một lúc được hiển thị nếu chúng tôi yêu cầu tất cả các kết quả và chỉ kết quả đầu tiên cũng được hiển thị ở cuối.

00:18:04.000 --> 00:18:07.000
Lưu ý rằng bản sửa đổi 2 có một vài vấn đề.

00:18:07.000 --> 00:18:10.000
Đầu tiên, nó đã bỏ lỡ mã vạch đầu tiên.

00:18:10.000 --> 00:18:13.000
Ngoài ra, nó đã phát hiện mã vạch thứ hai hai lần.

00:18:13.000 --> 00:18:19.000
Và nó cung cấp cho bạn một dòng thông qua mã vạch thay vì một hộp giới hạn hoàn chỉnh.

00:18:19.000 --> 00:18:26.000
Điều gì xảy ra nếu chúng ta thay đổi sang bản sửa đổi 3 ngay bây giờ, thay vì bản sửa đổi 2?

00:18:26.000 --> 00:18:28.000
Trước hết, chúng tôi phát hiện cả hai mã vạch.

00:18:28.000 --> 00:18:33.000
Và, thay vì một dòng, chúng tôi được cung cấp các hộp giới hạn hoàn chỉnh.

00:18:33.000 --> 00:18:41.000
Điều tuyệt vời về hỗ trợ Xem trước Xem nhanh này là chúng tôi đã loại bỏ nhu cầu bạn viết nhiều chức năng tiện ích khác nhau để trực quan hóa kết quả.

00:18:41.000 --> 00:18:49.000
Chúng có thể được phủ trực tiếp lên hình ảnh của bạn trong trình gỡ lỗi hoặc trong Sân chơi Xcode.

00:18:49.000 --> 00:18:54.000
Vì vậy, đó là hỗ trợ Xem trước Xem trước Nhanh trong Tầm nhìn.

00:18:54.000 --> 00:18:58.000
Bây giờ bạn có thể dễ dàng biết quan sát nào là quan sát nào.

00:18:58.000 --> 00:19:08.000
Chỉ cần đảm bảo giữ trình xử lý yêu cầu hình ảnh trong phạm vi để sử dụng nó với hình ảnh đầu vào của bạn và hy vọng hỗ trợ Xcode Playground sẽ giúp điều chỉnh trực tiếp mã khung Vision của bạn dễ dàng hơn nhiều.

00:19:08.000 --> 00:19:11.000
Chúng tôi đã đề cập đến một số cập nhật quan trọng cho Vision ngày hôm nay.

00:19:11.000 --> 00:19:21.000
Để nhanh chóng xem xét, chúng tôi đã thêm một số bản sửa đổi mới tuyệt vời vào nhận dạng văn bản, phát hiện mã vạch và luồng quang học.

00:19:21.000 --> 00:19:30.000
Khi chúng tôi tiếp tục thêm các bản sửa đổi được cập nhật, chúng tôi cũng sẽ xóa các bản cũ hơn, vì vậy hãy cập nhật các bản sửa đổi của bạn và sử dụng công nghệ mới nhất và tuyệt vời nhất.

00:19:30.000 --> 00:19:36.000
Chúng tôi cũng đã làm cho việc gỡ lỗi các ứng dụng Vision dễ dàng hơn nhiều trong năm nay với sự hỗ trợ Xem trước Quick Look.

00:19:36.000 --> 23:59:59.000
Tôi hy vọng bạn thích buổi học này, và có một WWDC tuyệt vời. ♪ ♪

