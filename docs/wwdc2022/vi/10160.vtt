WEBVTT

00:00:00.000 --> 00:00:03.000
♪ Nhạc hip-hop nhạc cụ êm dịu ♪

00:00:03.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:14.000
Xin chào, tên tôi là Keyi Yu, và tôi là một kỹ sư từ nhóm Hệ sinh thái kim loại.

00:00:14.000 --> 00:00:17.000
Hôm nay, tôi rất hân hạnh được giới thiệu metal-cpp.

00:00:17.000 --> 00:00:25.000
Chúng tôi đã tạo ra metal-cpp cho bất kỳ ai sử dụng C++ và muốn xây dựng các ứng dụng Metal cho nền tảng Apple.

00:00:25.000 --> 00:00:31.000
Metal-cpp là một thư viện chi phí thấp kết nối các ứng dụng C++ của bạn với Metal.

00:00:31.000 --> 00:00:43.000
Đầu tiên, tôi sẽ bắt đầu với tổng quan về metal-cpp là gì và nó hoạt động như thế nào, và sau đó tôi sẽ đề cập đến một số chi tiết về vòng đời của các đối tượng Objective-C.

00:00:43.000 --> 00:00:52.000
C++ và Objective-C xử lý vòng đời hơi khác một chút và tôi sẽ chỉ cho bạn cách xử lý những khác biệt đó.

00:00:52.000 --> 00:01:01.000
Xcode và metal-cpp có một số tiện ích tuyệt vời có thể giúp bạn quản lý vòng đời đối tượng trong ứng dụng của mình.

00:01:01.000 --> 00:01:09.000
Và cuối cùng, tôi sẽ chỉ cho bạn cách tích hợp mã C++ với các lớp Objective-C.

00:01:09.000 --> 00:01:13.000
Vì vậy, đây là một cái nhìn về metal-cpp và cách nó hoạt động.

00:01:13.000 --> 00:01:23.000
Metal là nền tảng cho đồ họa và tính toán tăng tốc trên nền tảng Apple, cho phép các ứng dụng và trò chơi của bạn khai thác sức mạnh đáng kinh ngạc của GPU.

00:01:23.000 --> 00:01:29.000
Ban đầu nó được thiết kế bằng cách sử dụng các tính năng mạnh mẽ và các quy ước được cung cấp bởi Objective-C.

00:01:29.000 --> 00:01:37.000
Nhưng nếu cơ sở mã của bạn ở C++, bạn có thể cần thứ gì đó để kết nối giữa mã của mình và mã Objective-C của Metal.

00:01:37.000 --> 00:01:39.000
Giới thiệu metal-cpp!

00:01:39.000 --> 00:01:45.000
Nó đóng vai trò là trung tâm giữa ứng dụng C++ của bạn và Objective-C Metal.

00:01:45.000 --> 00:01:56.000
Với metal-cpp trong ứng dụng của bạn, bạn có thể sử dụng các lớp và hàm Metal trong C++, và metal-cpp có thể giúp bạn gọi các hàm Objective-C trong thời gian chạy.

00:01:56.000 --> 00:02:00.000
Metal-cpp là một trình bao bọc Metal C++ nhẹ.

00:02:00.000 --> 00:02:07.000
Tôi nói rằng nó nhẹ, bởi vì nó được triển khai như một thư viện chỉ tiêu đề với các lệnh gọi hàm nội tuyến.

00:02:07.000 --> 00:02:16.000
Nó cung cấp phạm vi bảo hiểm 100 phần trăm của Metal API bằng cách triển khai ánh xạ 1-1 của các lệnh gọi C++ đến API Objective-C.

00:02:16.000 --> 00:02:22.000
Để làm điều này, metal-cpp bao bọc các phần của khung Foundation và CoreAnimation.

00:02:22.000 --> 00:02:29.000
Nó là mã nguồn mở theo Giấy phép Apache 2, vì vậy bạn có thể sửa đổi thư viện và đưa nó vào các ứng dụng của mình một cách dễ dàng.

00:02:29.000 --> 00:02:35.000
Metal-cpp sử dụng C để gọi trực tiếp vào thời gian chạy Objective-C.

00:02:35.000 --> 00:02:42.000
Đây chính xác là cơ chế mà trình biên dịch Objective-C sử dụng để thực thi các phương thức Objective-C.

00:02:42.000 --> 00:02:47.000
Vì vậy, giấy gói này giới thiệu rất ít chi phí.

00:02:47.000 --> 00:02:57.000
Vì metal-cpp thực hiện ánh xạ 1-1 các cuộc gọi C++ sang Objective-C, nó tuân theo các quy tắc quản lý bộ nhớ Cocoa giống nhau.

00:02:57.000 --> 00:02:59.000
Tôi sẽ thảo luận chi tiết hơn về điều này sau.

00:02:59.000 --> 00:03:10.000
Bản đồ 1-1 này cũng cho phép tất cả các công cụ dành cho nhà phát triển hoạt động liền mạch, bao gồm GPU Frame Capture và trình gỡ lỗi Xcode.

00:03:10.000 --> 00:03:15.000
Đây là chuỗi các cuộc gọi cần thiết để vẽ một hình tam giác bằng kim loại-cpp.

00:03:15.000 --> 00:03:22.000
Nếu bạn đã quen thuộc với C++, đây là thời điểm tốt để học Metal, bởi vì bạn không cần phải lo lắng về cú pháp ngôn ngữ.

00:03:22.000 --> 00:03:33.000
Nếu bạn đã sử dụng Metal với Objective-C, về các lệnh gọi hàm, có rất ít sự khác biệt giữa giao diện Objective-C của Metal và metal-cpp.

00:03:33.000 --> 00:03:38.000
Tôi sẽ chứng minh việc sử dụng metal-cpp dễ dàng như thế nào.

00:03:38.000 --> 00:03:45.000
Đầu tiên, tôi tạo một bộ đệm lệnh, mà tôi sẽ điền bằng các lệnh để GPU thực thi.

00:03:45.000 --> 00:03:51.000
Tôi có thể đơn giản sử dụng con trỏ thô trong C++ làm ánh xạ đến ID trong Objective-C.

00:03:51.000 --> 00:03:57.000
Tôi có thể tạo một bộ mã hóa lệnh kết xuất và viết các lệnh kết xuất với bộ đệm lệnh.

00:03:57.000 --> 00:04:06.000
Hàm C++ renderCommandEncoder và phương thức Objective-C renderCommandEncoder WithDescriptor đều giống nhau.

00:04:06.000 --> 00:04:11.000
Sự khác biệt duy nhất là quy ước tên của các ngôn ngữ.

00:04:11.000 --> 00:04:19.000
Sau đó, tôi đặt một đối tượng trạng thái đường ống kết xuất có chứa các bộ đổ bóng đỉnh và phân đoạn và nhiều trạng thái kết xuất khác.

00:04:19.000 --> 00:04:24.000
Sau đó, tôi mã hóa cuộc gọi vẽ của mình để hiển thị một tam giác duy nhất.

00:04:24.000 --> 00:04:29.000
Sau đó tôi chỉ ra rằng tôi đã hoàn thành việc mã hóa các lệnh kết xuất.

00:04:29.000 --> 00:04:33.000
Tôi trình bày bản vẽ, vì vậy hình tam giác được hiển thị trên màn hình.

00:04:33.000 --> 00:04:36.000
Cuối cùng, tôi cam kết bộ đệm lệnh của mình.

00:04:36.000 --> 00:04:40.000
Điều này cho GPU biết rằng nó có thể bắt đầu thực hiện các lệnh của tôi.

00:04:40.000 --> 00:04:45.000
Rõ ràng, metal-cpp và Objective-C Metal gần như giống nhau.

00:04:45.000 --> 00:04:56.000
Bạn không cần phải lo lắng về cú pháp ngôn ngữ bây giờ với metal-cpp, bạn có thể trực tiếp xem tài liệu Metal để tìm hiểu các khái niệm và cách sử dụng của Metal.

00:04:56.000 --> 00:05:00.000
Bạn có thể đã chơi với mẫu ánh sáng hoãn lại này trước đây.

00:05:00.000 --> 00:05:06.000
Bây giờ chúng tôi cung cấp một phiên bản mới của mẫu chiếu sáng hoãn lại này sử dụng metal-cpp.

00:05:06.000 --> 00:05:11.000
Chúng tôi hy vọng điều này có thể giúp bạn học cách viết mã với metal-cpp trong thực tế.

00:05:11.000 --> 00:05:25.000
Tôi cũng rất vui mừng được giới thiệu một loạt các mẫu C++ gia tăng giới thiệu Metal API và chỉ cho bạn cách hoàn thành các nhiệm vụ khác nhau với nó.

00:05:25.000 --> 00:05:30.000
Vậy bây giờ bạn đã biết một chút về metal-cpp, bạn thực sự sử dụng nó như thế nào?

00:05:30.000 --> 00:05:32.000
Chúng tôi đã xuất bản metal-cpp vào năm ngoái.

00:05:32.000 --> 00:05:36.000
Đây là trang web nơi bạn có thể tìm thấy các bản tải xuống và hướng dẫn.

00:05:36.000 --> 00:05:39.000
Hãy để tôi chỉ cho bạn các bước bạn sẽ cần thực hiện.

00:05:39.000 --> 00:05:44.000
Sau khi tải xuống metal-cpp, bạn nên cho Xcode biết nơi để tìm nó.

00:05:44.000 --> 00:05:49.000
Ở đây, tôi đặt metal-cpp theo dự án hiện tại.

00:05:49.000 --> 00:05:56.000
Sau đó, bạn cần đặt C++17 hoặc cao hơn làm phương ngữ ngôn ngữ C++.

00:05:56.000 --> 00:06:03.000
Tiếp theo, thêm ba khuôn khổ vào dự án: Foundation, QuartzCore và Metal.

00:06:03.000 --> 00:06:09.000
Bây giờ chỉ còn một việc phải làm trước khi sử dụng giao diện C++ của các khuôn khổ đó.

00:06:09.000 --> 00:06:12.000
Có ba tiêu đề trong metal-cpp.

00:06:12.000 --> 00:06:19.000
Vì metal-cpp là thư viện chỉ dành cho tiêu đề, bạn cần tạo các triển khai của chúng trước khi nhập các tệp tiêu đề.

00:06:19.000 --> 00:06:29.000
Để làm điều này, hãy xác định ba macro: NS_PRIVATE_IMPLEMENTATION, CA_PRIVATE_IMPLEMENTATION, VÀ MTL_PRIVATE_IMPLEMENTATION.

00:06:29.000 --> 00:06:37.000
Nếu bạn quan tâm đến những gì metal-cpp làm với các macro dưới mui xe, vui lòng xem các tệp cầu nối tiêu đề trong thư mục metal-cpp.

00:06:37.000 --> 00:06:42.000
Bạn có thể sử dụng các tiêu đề riêng biệt hoặc đặt chúng vào một tiêu đề duy nhất.

00:06:42.000 --> 00:06:45.000
Bạn có thể nhập các tệp tiêu đề bất cứ khi nào bạn cần.

00:06:45.000 --> 00:06:52.000
Nhưng hãy nhớ rằng, đừng xác định các macro NS, CA hoặc MTL_PRIVATE_IMPLEMENTATION nhiều lần.

00:06:52.000 --> 00:06:56.000
Nếu không, bạn có thể gây ra lỗi định nghĩa trùng lặp.

00:06:56.000 --> 00:07:12.000
Để sử dụng metal-cpp hiệu quả, bạn sẽ cần biết các quy tắc quản lý bộ nhớ của Cocoa, cách sử dụng các tiện ích tuyệt vời có thể giúp bạn quản lý vòng đời đối tượng và cách thiết kế kiến trúc ứng dụng của bạn khi bạn giao tiếp với các khung khác.

00:07:12.000 --> 00:07:16.000
Tôi sẽ bắt đầu với quản lý vòng đời đối tượng.

00:07:16.000 --> 00:07:21.000
Trong quá trình hoạt động của ứng dụng, bạn thường cần phân bổ và giải phóng bộ nhớ.

00:07:21.000 --> 00:07:27.000
Bạn cũng cần quản lý bộ đệm lệnh, đối tượng đường ống và tài nguyên.

00:07:27.000 --> 00:07:33.000
Để giúp quản lý bộ nhớ này, các đối tượng Objective-C và Cocoa bao gồm số lượng tham chiếu.

00:07:33.000 --> 00:07:36.000
Điều này cũng có mặt trong metal-cpp.

00:07:36.000 --> 00:07:39.000
Đếm tham chiếu giúp bạn quản lý trí nhớ của mình.

00:07:39.000 --> 00:07:43.000
Sử dụng đếm tham chiếu, tất cả các đối tượng đều chứa thuộc tính retainCount.

00:07:43.000 --> 00:07:51.000
Các thành phần trong một ứng dụng tăng số lượng để giữ cho các đối tượng mà chúng đang tương tác tồn tại và giảm nó khi chúng được hoàn thành với chúng.

00:07:51.000 --> 00:07:56.000
Khi retainCount đạt đến 0, thời gian chạy sẽ định vị đối tượng.

00:07:56.000 --> 00:07:59.000
Có hai loại đếm tham chiếu trong Objective-C.

00:07:59.000 --> 00:08:06.000
Một cái được gọi là Phát hành Giữ lại Thủ công - MRR; cái còn lại là Đếm Tham chiếu Tự động - ARC.

00:08:06.000 --> 00:08:16.000
Khi biên dịch mã với tính năng ARC, trình biên dịch nhận các tham chiếu bạn tạo và tự động chèn các cuộc gọi vào cơ chế quản lý bộ nhớ cơ bản.

00:08:16.000 --> 00:08:20.000
Các vật thể kim loại-cpp được giữ lại và giải phóng thủ công.

00:08:20.000 --> 00:08:26.000
Vì vậy, bạn cần hiểu các quy ước của Cocoa để biết khi nào nên giữ lại và giải phóng các đối tượng.

00:08:26.000 --> 00:08:34.000
Không giống như tạo các đối tượng trong C++, các đối tượng metal-cpp không được tạo bằng mới cũng như không bị phá hủy khi xóa.

00:08:34.000 --> 00:08:45.000
Với các quy ước của Cocoa, bạn sở hữu bất kỳ đối tượng nào bạn tạo bằng các phương thức bắt đầu bằng alloc, new, copy, mutableCopy hoặc create.

00:08:45.000 --> 00:08:49.000
Bạn có thể sở hữu một đối tượng bằng cách sử dụng retain.

00:08:49.000 --> 00:08:54.000
Khi bạn không còn cần nó nữa, bạn phải từ bỏ quyền sở hữu đối tượng mà bạn sở hữu.

00:08:54.000 --> 00:08:58.000
Bạn có thể phát hành nó ngay lập tức hoặc phát hành nó sau đó.

00:08:58.000 --> 00:09:05.000
Bạn không được từ bỏ quyền sở hữu đối tượng mà bạn không sở hữu vì bạn có nguy cơ được tự do gấp đôi.

00:09:05.000 --> 00:09:10.000
Tiếp theo, tôi sẽ xem qua một ví dụ về các quy ước Ca cao này.

00:09:10.000 --> 00:09:16.000
Trong lớp A, một phương thức sử dụng alloc để tạo một đối tượng và init để khởi tạo đối tượng này.

00:09:16.000 --> 00:09:20.000
Hãy nhớ rằng, đừng bao giờ gọi init trên một đối tượng hai lần.

00:09:20.000 --> 00:09:25.000
Loại A nắm quyền sở hữu và chịu trách nhiệm phân bổ nó.

00:09:25.000 --> 00:09:29.000
Bây giờ số lượng giữ lại cho đối tượng này là một.

00:09:29.000 --> 00:09:35.000
Tiếp theo, lớp B sử dụng retain để lấy đối tượng và sở hữu đối tượng này.

00:09:35.000 --> 00:09:42.000
Cho đến nay, tôi có hai đối tượng chia sẻ quyền sở hữu đối tượng này được đại diện bởi khối lập phương màu cam.

00:09:42.000 --> 00:09:46.000
Số lượng giữ lại tăng thêm một.

00:09:46.000 --> 00:09:53.000
Lớp A không cần đối tượng này nữa, vì vậy lớp A nên gọi phát hành theo cách thủ công cho nó.

00:09:53.000 --> 00:09:56.000
Kết quả là, số lượng giữ lại giảm đi một.

00:09:56.000 --> 00:10:00.000
Bây giờ, chỉ có lớp B sở hữu đối tượng.

00:10:00.000 --> 00:10:03.000
Được rồi, cuối cùng, lớp B cũng muốn giải phóng đối tượng này.

00:10:03.000 --> 00:10:08.000
Bây giờ số lần giữ bằng 0, vì vậy thời gian chạy giải phóng đối tượng.

00:10:08.000 --> 00:10:13.000
Đây là một tình huống mà một phương thức trong lớp B trả về một đối tượng.

00:10:13.000 --> 00:10:16.000
Bạn vẫn cần đối tượng này trong phần còn lại của các chương trình.

00:10:16.000 --> 00:10:26.000
Nói cách khác, bạn muốn từ bỏ quyền sở hữu một đối tượng trong một phương thức trong lớp B, nhưng bạn không muốn nó được phân bổ ngay lập tức.

00:10:26.000 --> 00:10:30.000
Trong trường hợp này, bạn nên gọi tự động phát hành trong lớp B.

00:10:30.000 --> 00:10:36.000
Số lượng giữ lại vẫn là một sau khi bạn gọi tự động phát hành, và do đó, bạn vẫn có thể sử dụng đối tượng sau này.

00:10:36.000 --> 00:10:44.000
Đây là câu hỏi: vì lớp B không còn sở hữu đối tượng này nữa, ai chịu trách nhiệm phân bổ nó?

00:10:44.000 --> 00:10:49.000
Khung nền tảng cung cấp một đối tượng quan trọng, được gọi là AutoreleasePool.

00:10:49.000 --> 00:10:54.000
API Tự động phát hành đặt đối tượng vào một AutoreleasePool.

00:10:54.000 --> 00:10:58.000
Bây giờ, AutoreleasePool nắm quyền sở hữu đối tượng.

00:10:58.000 --> 00:11:04.000
AutoreleasePool làm giảm số lượng lưu giữ của người nhận khi AutoreleasePool bị phá hủy.

00:11:04.000 --> 00:11:08.000
Bạn không phải là người duy nhất có thể tạo các đối tượng tự động phát hành.

00:11:08.000 --> 00:11:13.000
Metal tạo ra một số vật thể tự động giải phóng như một phần hoạt động của nó.

00:11:13.000 --> 00:11:21.000
Tất cả các phương pháp tạo các đối tượng tạm thời thêm chúng vào AutoreleasePools bằng cách gọi autorelease dưới mui xe.

00:11:21.000 --> 00:11:24.000
Trách nhiệm của AutoreleasePool là phát hành chúng.

00:11:24.000 --> 00:11:30.000
Nói cách khác, với AutoreleasePool, bạn có thể viết mã theo cách thanh lịch hơn.

00:11:30.000 --> 00:11:33.000
Bạn có thể có một AutoreleasePool cho ứng dụng chính.

00:11:33.000 --> 00:11:41.000
Chúng tôi cũng khuyến khích bạn tạo và quản lý các hồ bơi tự động phát hành bổ sung ở phạm vi nhỏ hơn để giảm bộ hoạt động của chương trình.

00:11:41.000 --> 00:11:45.000
Bạn cũng cần AutoreleasePools cho mọi chủ đề bạn tạo.

00:11:45.000 --> 00:11:51.000
Đây là một ví dụ cho thấy cách sử dụng AutoreleasePool và các đối tượng tự động phát hành.

00:11:51.000 --> 00:12:00.000
Trong mẫu này, một AutoreleasePool được tạo bởi alloc, có nghĩa là bạn nắm quyền sở hữu và nó sẽ được phát hành thủ công.

00:12:00.000 --> 00:12:03.000
Bây giờ chúng ta có một AutoreleasePool.

00:12:03.000 --> 00:12:07.000
Như chúng ta đã thảo luận lúc đầu, bạn nên tạo một bộ đệm lệnh.

00:12:07.000 --> 00:12:13.000
Nó không được tạo ra với alloc hoặc create, vì vậy bạn không sở hữu nó.

00:12:13.000 --> 00:12:19.000
Thay vào đó, nó là một đối tượng được tự động phát hành do Metal tạo ra.

00:12:19.000 --> 00:12:22.000
Bộ đệm lệnh này sẽ được đưa vào AutoreleasePool.

00:12:22.000 --> 00:12:26.000
Trách nhiệm của AutoreleasePool là giải quyết nó.

00:12:26.000 --> 00:12:31.000
Bạn có thể sử dụng nó như bạn muốn cho đến khi bạn phát hành AutoreleasePool.

00:12:31.000 --> 00:12:35.000
Sau đó bạn cần tạo một RenderPassDescriptor.

00:12:35.000 --> 00:12:40.000
RenderPassDescriptor này cũng sẽ được đưa vào AutoreleasePool.

00:12:40.000 --> 00:12:43.000
Tương tự với RenderCommandEncoder.

00:12:43.000 --> 00:12:46.000
Nó cũng là một đối tượng được tự động phát hành do Metal tạo ra.

00:12:46.000 --> 00:12:49.000
Đừng quên đối tượng có thể vẽ hiện tại này.

00:12:49.000 --> 00:12:53.000
Nó cũng sẽ được đưa vào AutoreleasePool.

00:12:53.000 --> 00:12:59.000
Ở cuối đoạn mã, tôi sử dụng pPool-&gt;release để phát hành AutoreleasePool.

00:12:59.000 --> 00:13:14.000
Trước khi được phân bổ, AutoreleasePool phát hành mọi thứ mà nó sở hữu, trong trường hợp này, nó phát hành CommandBuffer, RenderPassDescriptor, RenderCommandEncoder và currentDrawable.

00:13:14.000 --> 00:13:16.000
Sau đó AutoreleasePool được phát hành.

00:13:16.000 --> 00:13:22.000
Cho đến nay, bạn đã biết các quy ước của Cocoa, các đối tượng được tự động phát hành và AutoreleasePools.

00:13:22.000 --> 00:13:35.000
Điều quan trọng là phải quản lý chính xác vòng đời của đối tượng để tránh rò rỉ bộ nhớ và các đối tượng zombie, và chúng tôi có các công cụ tuyệt vời để giúp bạn tránh và gỡ lỗi những vấn đề này.

00:13:35.000 --> 00:13:40.000
Tôi sẽ tập trung vào hai tiện ích: NS::SharedPtr và NSZombie.

00:13:40.000 --> 00:13:46.000
NS::SharedPtr là một tiện ích mới có thể giúp bạn quản lý vòng đời của đối tượng.

00:13:46.000 --> 00:13:51.000
Bạn có thể tìm thấy nó trong khung Foundation trong thư mục metal-cpp.

00:13:51.000 --> 00:13:55.000
Lưu ý rằng nó không hoàn toàn giống với std:shared_ptr.

00:13:55.000 --> 00:14:03.000
Vì vậy, không có sự phụ thuộc vào thư viện tiêu chuẩn C++ và không có thêm chi phí lưu trữ số lượng tham chiếu.

00:14:03.000 --> 00:14:05.000
Đây là NS::SharedPtr như thế nào.

00:14:05.000 --> 00:14:11.000
Các chức năng chuyển và giữ lại thể hiện rõ ý định tiêu thụ một đối tượng.

00:14:11.000 --> 00:14:21.000
Chuyển nhượng tạo ra một SharedPtr mà không làm tăng Số tham chiếu của người chỉ điểm, chuyển quyền sở hữu một cách hiệu quả sang SharedPtr.

00:14:21.000 --> 00:14:25.000
Hàm giữ lại gửi một giữ lại đến đối tượng được truyền vào.

00:14:25.000 --> 00:14:36.000
Sử dụng chức năng này để giữ cho các đối tượng sống sót trong AutoreleasePools và để thể hiện rằng chủ sở hữu của con trỏ có quyền lợi trong vòng đời của con trỏ.

00:14:36.000 --> 00:14:42.000
Bạn có thể truy cập đối tượng cơ bản như mong đợi thông qua get và thông qua toán tử-&gt;.

00:14:42.000 --> 00:14:51.000
Chia sẻ Ptr sao chép, di chuyển, xây dựng và phân công công việc như mong đợi, với bản sao tăng số lượng giữ lại.

00:14:51.000 --> 00:14:56.000
Di chuyển nhanh và không ảnh hưởng đến số lượng giữ lại trong trường hợp chung.

00:14:56.000 --> 00:15:02.000
SharedPtrs luôn gửi chính xác một bản phát hành đến pointee khi bị phá hủy.

00:15:02.000 --> 00:15:06.000
Bạn có thể tránh điều này nếu bạn muốn bằng cách gọi hàm tách.

00:15:06.000 --> 00:15:14.000
Quay trở lại đầu trang, điều quan trọng là phải biết sự khác biệt giữa việc tạo một con trỏ bằng cách chuyển hoặc giữ lại nó.

00:15:14.000 --> 00:15:22.000
Vì vậy, đối với TransferPtr, giả sử tôi có một đối tượng MRR, với số tham chiếu là 1.

00:15:22.000 --> 00:15:30.000
Sau khi tôi chuyển nó sang hàm TransferPtr, SharedPtr sẽ nắm quyền sở hữu đối tượng, nhưng retainCount của nó không thay đổi.

00:15:30.000 --> 00:15:40.000
Khi con trỏ đi ra khỏi phạm vi, trình hủy của SharedPtr sẽ chạy và gọi phát hành trên đối tượng MRR, điều này làm giảm retainCount thành 0.

00:15:40.000 --> 00:15:43.000
Một chức năng khác là NS::RetainPtr.

00:15:43.000 --> 00:15:50.000
Khi bạn muốn tránh phân bổ một đối tượng vì bạn muốn sử dụng nó sau này, bạn nên sử dụng NS::RetainPtr.

00:15:50.000 --> 00:15:55.000
Giả sử chúng ta có đối tượng MRR này; retainCount là một.

00:15:55.000 --> 00:16:00.000
Sau khi chúng tôi chuyển nó sang hàm RetainPtr, retainCount tăng thêm một.

00:16:00.000 --> 00:16:06.000
Sau khi hết phạm vi, RetainPtr này gọi phát hành cho đối tượng MRR này.

00:16:06.000 --> 00:16:09.000
Vì vậy, retainCount là một.

00:16:09.000 --> 00:16:13.000
Nói chung, NS::TransferPtr nhận quyền sở hữu một đối tượng cho bạn.

00:16:13.000 --> 00:16:20.000
Nhưng NS::RetainPtr giúp bạn giữ lại một đối tượng khi bạn không muốn nó được phân bổ.

00:16:20.000 --> 00:16:34.000
Khi bạn chuyển một đối tượng đến hai hàm này, NS::TransferPtr không thay đổi số lượng tham chiếu nhưng NS::RetainPtr tăng số lượng tham chiếu lên một khi nó gọi giữ lại cho bạn dưới mui xe.

00:16:34.000 --> 00:16:43.000
Trình hủy của hai hàm này vừa gọi phát hành cho đối tượng được truyền vào và do đó, số lượng tham chiếu giảm đi một.

00:16:43.000 --> 00:16:48.000
Nếu số lượng tham chiếu bằng không, đối tượng sẽ được giải phóng trong thời gian chạy.

00:16:48.000 --> 00:16:51.000
Đây là một ví dụ về NS::TransferPtr.

00:16:51.000 --> 00:16:58.000
Khi tôi nói về đường chuyền kết xuất, đã vẽ một tam giác duy nhất, tôi cần trạng thái đường ống kết xuất này.

00:16:58.000 --> 00:17:02.000
Đây là các cuộc gọi để tạo ra một đối tượng trạng thái đường ống kết xuất.

00:17:02.000 --> 00:17:05.000
Đây là những thuộc tính mà một bộ mô tả đường ống kết xuất cần.

00:17:05.000 --> 00:17:14.000
Theo quy ước của Cocoa, vì những cuộc gọi này bắt đầu bằng new và alloc, tôi sở hữu những đồ vật này.

00:17:14.000 --> 00:17:17.000
Vì vậy, tôi cần gọi phát hành cho những đối tượng này.

00:17:17.000 --> 00:17:27.000
Với NS::SharedPtr, tôi không cần gọi phát hành cho các đối tượng MRR đó vì NS::SharedPtrs nắm quyền sở hữu các đối tượng này.

00:17:27.000 --> 00:17:33.000
Vì vậy, ở đây, tôi chuyển các con trỏ thô đến hàm TransferPtr.

00:17:33.000 --> 00:17:38.000
Sau khi làm điều đó, không cần phải gọi phát hành như tôi đã làm trong slide trước.

00:17:38.000 --> 00:17:46.000
Nếu bạn quen thuộc với ARC, bạn có thể thấy rằng MRR được sử dụng với NS::SharedPtr tương tự như sử dụng ARC.

00:17:46.000 --> 00:17:50.000
Bạn có thể gặp lỗi sử dụng sau khi miễn phí khi xử lý bộ nhớ theo cách thủ công.

00:17:50.000 --> 00:17:55.000
Chúng xảy ra khi bạn đang cố gắng sử dụng một đối tượng đã được phát hành.

00:17:55.000 --> 00:17:58.000
NSZombie là một cách hay để kiểm tra những lỗi đó.

00:17:58.000 --> 00:18:04.000
Khi xảy ra lỗi sử dụng sau khi miễn phí, nó sẽ kích hoạt điểm dừng và cung cấp cho bạn dấu vết ngăn xếp.

00:18:04.000 --> 00:18:08.000
Bạn có thể kích hoạt Zombies rất dễ dàng với một biến môi trường.

00:18:08.000 --> 00:18:11.000
Chỉ cần đặt NSZombieEnabled thành CÓ.

00:18:11.000 --> 00:18:16.000
Hoặc nếu bạn đang sử dụng Xcode, bạn có thể kích hoạt Zombies trong một sơ đồ.

00:18:16.000 --> 00:18:18.000
Đây là cách nó hoạt động.

00:18:18.000 --> 00:18:25.000
Tôi muốn tạo một đối tượng trạng thái đường ống kết xuất mới với cùng cài đặt đường ống kết xuất.

00:18:25.000 --> 00:18:34.000
Vì vậy, trong hàmenderPipelineState mới này, tôi sử dụng lại đối tượng pDesc.

00:18:34.000 --> 00:18:40.000
Sau khi nhấp vào chạy, Xcode kích hoạt điểm dừng và hiển thị cho tôi dấu vết ngăn xếp.

00:18:40.000 --> 00:18:43.000
Điều đó có nghĩa là tôi đã làm sai điều gì đó.

00:18:43.000 --> 00:18:47.000
Hừm, có vấn đề gì vậy?

00:18:47.000 --> 00:18:57.000
Có lẽ NSZombie có thể giúp đỡ ở đây, vì vậy tôi kích hoạt NSZombie trong sơ đồ.

00:18:57.000 --> 00:19:01.000
Khi tôi chạy lại chương trình, NSZombie sẽ kích hoạt một điểm dừng.

00:19:01.000 --> 00:19:09.000
Tôi nhận được một cái gì đó mới trong đầu ra bảng điều khiển: "tin nhắn được gửi đến phiên bản deallocated."

00:19:09.000 --> 00:19:12.000
Ồ, tôi đã sử dụng lại một đối tượng mà tôi đã phát hành.

00:19:12.000 --> 00:19:16.000
Và đó là mô tả đường ống kết xuất.

00:19:16.000 --> 00:19:21.000
Vì vậy, tôi cần sử dụng bộ mô tả đường ống kết xuất này trước khi gọi phát hành.

00:19:21.000 --> 00:19:24.000
Bằng cách đó, tôi đã khắc phục sự cố.

00:19:24.000 --> 00:19:31.000
Nhiều công cụ và chi tiết hơn được đề cập trong bài nói chuyện năm nay, "Hồ sơ và tối ưu hóa bộ nhớ trò chơi của bạn."

00:19:31.000 --> 00:19:37.000
Ví dụ, bạn có thể học cách theo dõi retainCount trong phân bổ trong các công cụ.

00:19:37.000 --> 00:19:40.000
Hãy thoải mái kiểm tra các công cụ khác trên nền tảng Apple.

00:19:40.000 --> 00:19:45.000
Bạn sẽ phát hiện ra rằng họ có thể giúp bạn gỡ lỗi trò chơi của mình và cải thiện hiệu suất.

00:19:45.000 --> 00:19:50.000
Bây giờ bạn đã biết cách quản lý vòng đời đối tượng trong metal-cpp.

00:19:50.000 --> 00:19:56.000
Nhưng bạn vẫn có thể cần giao tiếp với các khuôn khổ khác, như bộ điều khiển trò chơi và âm thanh.

00:19:56.000 --> 00:19:59.000
Những thứ này vẫn còn trong Objective-C.

00:19:59.000 --> 00:20:05.000
Làm thế nào bạn có thể giao tiếp với các API đó và thiết kế một kiến trúc ứng dụng thanh lịch?

00:20:05.000 --> 00:20:13.000
Giả sử bạn đã viết một ViewController trong Objective-C, nhưng bạn đã viết một trình kết xuất trong C++ với metal-cpp.

00:20:13.000 --> 00:20:18.000
Bạn cần gọi các phương thức kết xuất, như vẽ, từ ViewController.

00:20:18.000 --> 00:20:25.000
Thách thức ở đây là tách biệt hai ngôn ngữ một cách độc đáo nhưng để chúng hoạt động cùng nhau.

00:20:25.000 --> 00:20:32.000
Giải pháp là tạo một lớp bộ điều hợp gọi C++ từ các tệp Objective-C.

00:20:32.000 --> 00:20:40.000
Bằng cách này, bạn có thể tập trung vào Objective-C hoặc C++ trong các tệp nơi bạn triển khai các tính năng.

00:20:40.000 --> 00:20:45.000
Ví dụ, tôi có thể tạo một lớp RendererAdapter trong Objective-C.

00:20:45.000 --> 00:20:53.000
Và trong quá trình triển khai, tôi thêm một phương thức Objective-C để tôi có thể gọi nó trực tiếp từ ViewController.

00:20:53.000 --> 00:21:00.000
Bên trong giao diện, tôi khai báo một con trỏ C++ đến một đối tượng kết xuất.

00:21:00.000 --> 00:21:06.000
Bên trong phần thân của phương thức, tôi trực tiếp gọi phương thức C++ của trình kết xuất.

00:21:06.000 --> 00:21:20.000
Phương pháp này cần chuyển MTK::View dưới dạng đối tượng C++ vào phương thức vẽ, vì vậy nó chuyển chế độ xem dưới dạng loại C++ bằng cách sử dụng từ khóa __bridge.

00:21:20.000 --> 00:21:23.000
Tôi sẽ nói nhiều hơn về dàn diễn viên này sau.

00:21:23.000 --> 00:21:32.000
Ngược lại, bạn cần gọi MTKView được viết bằng Objective-C trong Renderer được viết bằng C++.

00:21:32.000 --> 00:21:35.000
Nó cũng đầy thử thách.

00:21:35.000 --> 00:21:39.000
Tương tự, giải pháp là tạo một lớp bộ điều hợp.

00:21:39.000 --> 00:21:47.000
Với lớp này, trong các tệp C++, bạn có thể gọi các phương thức Objective-C bằng giao diện C++.

00:21:47.000 --> 00:21:50.000
Ví dụ, tôi có thể tạo một lớp ViewAdapter.

00:21:50.000 --> 00:21:58.000
Tôi viết các giao diện trong C++, vì vậy trong lớp Renderer, tôi có thể gọi các phương thức xem C++ đó một cách dễ dàng.

00:21:58.000 --> 00:22:08.000
Trong khi triển khai, tôi gọi các phương thức Objective-C từ MTKView, bao gồm currentDrawable và depthStencilTexture.

00:22:08.000 --> 00:22:11.000
Bạn có thể nhận thấy có một số từ khóa __bridge ở đây.

00:22:11.000 --> 00:22:16.000
Tôi sử dụng chúng để đúc giữa các vật kim loại-cpp và các vật thể Objective-C.

00:22:16.000 --> 00:22:27.000
Như bạn đã học lúc đầu, các đối tượng metal-cpp được giữ lại và giải phóng thủ công, nhưng các đối tượng được tạo bởi Objective-C sử dụng tính tham chiếu tự động.

00:22:27.000 --> 00:22:33.000
Bạn cần di chuyển các đối tượng từ MRR sang ARC và từ ARC sang MRR.

00:22:33.000 --> 00:22:39.000
Đây là ba loại đúc cầu nối có thể giúp bạn sử dụng giữa Objective-C và C++.

00:22:39.000 --> 00:22:47.000
Chúng cũng có thể giúp bạn chuyển quyền sở hữu _ đúc cầu giữa các vật thể Objective-C và kim loại-cpp.

00:22:47.000 --> 00:22:52.000
Không có sự chuyển giao quyền sở hữu giữa họ.

00:22:52.000 --> 00:23:00.000
__Bridge_retained casting đúc một con trỏ Objective-C đến một con trỏ kim loại-cpp và lấy quyền sở hữu từ ARC.

00:23:00.000 --> 00:23:07.000
__Bridge_transfer casting di chuyển một con trỏ metal-cpp đến Objective-C và chuyển quyền sở hữu sang ARC.

00:23:07.000 --> 00:23:13.000
Quay trở lại vấn đề, bạn cần đúc giữa các đối tượng kim loại-cpp và các đối tượng Objective-C.

00:23:13.000 --> 00:23:18.000
Nếu không có chuyển quyền sở hữu, bạn có thể sử dụng __bridge cast.

00:23:18.000 --> 00:23:29.000
Nếu bạn muốn truyền từ các đối tượng metal-cpp sang Objective-C và chuyển quyền sở hữu sang Objective-C, bạn nên sử dụng __bridge_transfer cast.

00:23:29.000 --> 00:23:37.000
Nếu bạn muốn truyền từ các đối tượng Objective-C sang metal-cpp và lấy quyền sở hữu ra khỏi ARC, bạn nên sử dụng __bridge_retained cast.

00:23:37.000 --> 00:23:42.000
Đây là một trường hợp khi tôi phải sử dụng MetalKit để tận dụng mã tải tài sản.

00:23:42.000 --> 00:23:53.000
Điều đó có nghĩa là trong ứng dụng C++ của tôi, tôi cần một kết cấu như một đối tượng metal-cpp, nhưng nó được tạo ra bằng các phương thức Objective-C.

00:23:53.000 --> 00:23:59.000
Tôi cần khả năng chuyển quyền sở hữu ra khỏi ARC để tôi có thể phát hành nó theo cách thủ công.

00:23:59.000 --> 00:24:06.000
Và trong trường hợp này, tôi cần chọn __bridge_retained cast.

00:24:06.000 --> 00:24:13.000
Tôi có chức năng C++ này tải một kết cấu từ danh mục và tôi muốn trả lại một kết cấu metal-cpp.

00:24:13.000 --> 00:24:19.000
Nhưng bên trong, tôi đang gọi một số hàm Objective-C trong MetalKit.

00:24:19.000 --> 00:24:23.000
Tôi cần xác định các tùy chọn mà trình tải kết cấu cần.

00:24:23.000 --> 00:24:31.000
Sau đó, tôi tạo một trình tải kết cấu bằng cách gọi phương thức Objective-C từ MetalKit.

00:24:31.000 --> 00:24:38.000
Với trình tải đó, tôi có thể tạo một đối tượng kết cấu và tải một kết cấu từ danh mục.

00:24:38.000 --> 00:24:43.000
Phương pháp này cũng là một phương pháp Objective-C từ MetalKit.

00:24:43.000 --> 00:24:52.000
Bây giờ tôi có một kết cấu loại Objective-C, tôi cần đúc nó vào đối tượng kim loại-cpp và lấy nó ra khỏi ARC.

00:24:52.000 --> 00:24:58.000
Với những bước này, đã đến lúc viết mã và tôi sẽ chỉ cho bạn cách sử dụng trong thực tế.

00:24:58.000 --> 00:25:03.000
Bước đầu tiên là xác định các tùy chọn trình tải kết cấu mà trình tải kết cấu cần.

00:25:03.000 --> 00:25:13.000
Tôi có thể đúc chế độ lưu trữ và cách sử dụng kim loại-cpp một cách an toàn sang loại Objective-C, vì loại kim loại-cpp xác định chúng với cùng giá trị.

00:25:13.000 --> 00:25:16.000
Ở đây tôi tạo ra một trình tải kết cấu.

00:25:16.000 --> 00:25:24.000
Tôi có một thiết bị là một đối tượng metal-cpp, và tôi cần chuyển nó sang phương thức initWithDevice.

00:25:24.000 --> 00:25:31.000
Bởi vì đối tượng kim loại-cpp là một đối tượng Objective-C, tôi có thể đúc nó như một đối tượng miễn phí.

00:25:31.000 --> 00:25:35.000
Không có sự chuyển giao quyền sở hữu.

00:25:35.000 --> 00:25:39.000
Bây giờ tôi sử dụng các tùy chọn trình tải kết cấu và trình tải kết cấu để tạo kết cấu.

00:25:39.000 --> 00:25:44.000
Và tôi muốn trả lại kết cấu đã tải dưới dạng một đối tượng kim loại-cpp.

00:25:44.000 --> 00:25:50.000
Vì vậy, tôi cần lấy nó ra khỏi ARC và chuyển nó sang loại con trỏ tương ứng.

00:25:50.000 --> 00:25:53.000
Điều này được thực hiện với dàn diễn viên __bridge_retained.

00:25:53.000 --> 00:25:57.000
Sau đó, tôi có thể sử dụng kết cấu này như bất kỳ đối tượng kim loại-cpp nào.

00:25:57.000 --> 00:26:00.000
Tôi chịu trách nhiệm phát hành nó.

00:26:00.000 --> 00:26:08.000
Trong phần này, tôi đã cung cấp một mẫu bộ điều hợp có thể giúp bạn xử lý hai ngôn ngữ khác nhau trong chương trình của mình.

00:26:08.000 --> 00:26:15.000
Tôi cũng đã chỉ ra cách giao tiếp với Objective-C và C++ với ba loại diễn viên.

00:26:15.000 --> 00:26:22.000
Tóm lại, metal-cpp là một trình bao bọc Metal C++ nhẹ và rất hiệu quả.

00:26:22.000 --> 00:26:37.000
Tôi đã nói về cách quản lý vòng đời đối tượng khi sử dụng metal-cpp, cách giao tiếp với Objective-C một cách thanh lịch và cách các công cụ dành cho nhà phát triển của chúng tôi có thể giúp bạn gỡ lỗi.

00:26:37.000 --> 00:26:41.000
Tải xuống metal-cpp và chơi với tất cả các mẫu tuyệt vời ngay bây giờ!

00:26:41.000 --> 00:26:44.000
Xem những gì bạn có thể tạo ra với Metal.

00:26:44.000 --> 00:26:49.000
Chúng tôi mong muốn thấy các ứng dụng C++ của bạn chạy trên tất cả các nền tảng của Apple.

00:26:49.000 --> 00:26:51.000
Cảm ơn vì đã xem!

00:26:51.000 --> 23:59:59.000
♪

