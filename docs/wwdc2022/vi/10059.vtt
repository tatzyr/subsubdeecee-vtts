WEBVTT

00:00:09.000 --> 00:00:15.000
Sam Lazarus: Xin chào tên tôi là Sam, và tôi là một kỹ sư trong nhóm SwiftUI.

00:00:15.000 --> 00:00:26.000
Khi thiết kế SwiftUI, chúng tôi luôn cố gắng đưa ra quyết định dựa trên các nguyên tắc được xác định rõ ràng và hôm nay, chúng tôi sẽ nêu bật một trong số đó: tiết lộ tiến bộ.

00:00:26.000 --> 00:00:41.000
Trong nhóm SwiftUI, chúng tôi dành nhiều thời gian để suy nghĩ và xây dựng API mới, nhưng điều bạn có thể không nhận ra là thời điểm bạn xây dựng một thành phần có thể tái sử dụng hoặc trừu tượng, bạn cũng là một nhà thiết kế API.

00:00:41.000 --> 00:00:57.000
Trong buổi nói chuyện này, chúng tôi muốn bóc lại rèm cửa trong quy trình thiết kế của mình và chia sẻ những gì chúng tôi đã học được về tiết lộ tiến bộ, vì vậy lần tới khi bạn xây dựng một thành phần có thể tái sử dụng hoặc trừu tượng, bạn có một công cụ mới trong đai công cụ của mình.

00:00:57.000 --> 00:01:02.000
Hãy bắt đầu bằng cách nói về ý nghĩa thực sự của việc tiết lộ tiến bộ.

00:01:02.000 --> 00:01:06.000
Hóa ra, nó không phải là duy nhất đối với thiết kế của API!

00:01:06.000 --> 00:01:14.000
Trên thực tế, bạn có thể thấy nó đang hoạt động trong một trong những giao diện người dùng macOS phổ biến nhất: hộp thoại lưu.

00:01:14.000 --> 00:01:20.000
Khi bạn lần đầu tiên được hiển thị hộp thoại lưu, có một vị trí mặc định đã được điền cho bạn.

00:01:20.000 --> 00:01:29.000
Ngoài ra, hộp thoại hiển thị cho bạn một danh sách thả xuống với một số vị trí phổ biến, vì vậy các vị trí bạn có thể chọn rất dễ tiếp cận.

00:01:29.000 --> 00:01:40.000
Và cuối cùng, nếu bạn cần duyệt qua hệ thống tệp để tìm đường dẫn phù hợp, bạn có thể mở rộng hộp thoại để hiển thị giao diện người dùng phức tạp hơn nhưng mạnh mẽ hơn.

00:01:40.000 --> 00:01:45.000
Có nhiều lớp phức tạp khác nhau ở đây có thể được tiết lộ khi cần thiết.

00:01:45.000 --> 00:01:51.000
Đây là trải nghiệm tương tự mà chúng tôi muốn cung cấp với các API của mình.

00:01:51.000 --> 00:02:00.000
Mã tương đương với việc cung cấp trải nghiệm giao diện người dùng tốt đang làm cho API của bạn cảm thấy tuyệt vời khi sử dụng.

00:02:00.000 --> 00:02:07.000
Là nhà phát triển, chúng tôi đã quen với việc xem mã của mình từ góc độ nơi chúng tôi viết nó: trang web khai báo.

00:02:07.000 --> 00:02:19.000
Nhưng để làm cho mã cảm thấy tuyệt vời khi sử dụng, chúng ta phải nhìn nó từ một góc độ khác: nơi mã thực sự được sử dụng hoặc những gì chúng ta gọi là trang web cuộc gọi.

00:02:19.000 --> 00:02:28.000
Sau đó, tiết lộ liên tục là thiết kế các API để sự phức tạp của trang web cuộc gọi tăng lên cùng với sự phức tạp của trường hợp sử dụng.

00:02:28.000 --> 00:02:37.000
Một API lý tưởng vừa đơn giản vừa dễ tiếp cận nhưng cũng có thể phù hợp với các trường hợp sử dụng mạnh mẽ.

00:02:37.000 --> 00:02:40.000
Điều này có lợi ích thực sự cho các nhà phát triển.

00:02:40.000 --> 00:02:49.000
Đầu tiên, nó giảm thiểu thời gian xây dựng và chạy lần đầu tiên, cho phép bạn sử dụng API của mình một cách nhanh chóng.

00:02:49.000 --> 00:02:59.000
Nó cũng làm giảm đường cong học tập của mã của bạn, ngăn API bị sa lầy bởi các khái niệm không liên quan trong tất cả các trường hợp sử dụng.

00:02:59.000 --> 00:03:02.000
Cuối cùng, nó tạo ra một vòng phản hồi chặt chẽ.

00:03:02.000 --> 00:03:11.000
Với các API bao gồm tiết lộ liên tục, bạn có thể thêm từng phần một, xem những gì bạn đã tạo ở mỗi bước.

00:03:11.000 --> 00:03:20.000
Tất cả những điều này cùng nhau làm cho việc xây dựng ứng dụng trở thành một chu kỳ tinh chỉnh nhanh chóng thay vì một khoản đầu tư trả trước, lớn, duy nhất.

00:03:20.000 --> 00:03:28.000
Vì vậy, tiết lộ lũy tiến là một ánh sáng hướng dẫn hữu ích, nhưng làm thế nào chúng ta có thể thiết kế API cụ thể để họ nắm lấy nguyên tắc đó?

00:03:28.000 --> 00:03:34.000
Trong nhóm SwiftUI, chúng tôi bắt đầu bằng cách xem xét các trường hợp sử dụng phổ biến.

00:03:34.000 --> 00:03:41.000
Để dần dần tiết lộ chức năng, chúng ta cần xác định những trường hợp đơn giản nên là gì.

00:03:41.000 --> 00:03:49.000
Chúng tôi cũng cố gắng cung cấp các mặc định thông minh, vì vậy những trường hợp phổ biến đó chỉ có thể chỉ định những gì chúng cần.

00:03:49.000 --> 00:03:56.000
Tiếp theo, chúng tôi mong muốn tối ưu hóa trang web cuộc gọi, đảm bảo mọi ký tự trên trang web cuộc gọi của bạn đều có mục đích.

00:03:56.000 --> 00:04:04.000
Và cuối cùng, chúng tôi thiết kế các API của mình để chúng tạo ra các phần thay vì liệt kê các khả năng.

00:04:04.000 --> 00:04:12.000
Hãy đi sâu vào và xem xét một số ví dụ từ SwiftUI, bắt đầu với cách chúng tôi xem xét các trường hợp sử dụng phổ biến.

00:04:12.000 --> 00:04:18.000
Một nơi mà SwiftUI làm điều này đặc biệt tốt là với các nhãn.

00:04:18.000 --> 00:04:24.000
Ví dụ, khi bạn tạo một nút, chúng tôi yêu cầu bạn cung cấp nhãn cho nút đó.

00:04:24.000 --> 00:04:33.000
Hầu hết thời gian, nhãn đó sẽ chỉ là một số văn bản, mô tả mục đích của nút và SwiftUI cung cấp cho bạn một cách ngắn gọn để đánh vần nó.

00:04:33.000 --> 00:04:38.000
Nhưng nếu bạn muốn tùy chỉnh nút hơn nữa, SwiftUI cung cấp một tình trạng quá tải khác.

00:04:38.000 --> 00:04:41.000
Có một cái nhìn tùy ý như một nhãn.

00:04:41.000 --> 00:04:47.000
Điều này cho phép bạn xây dựng chức năng phức tạp từ sự kiểm soát đơn giản này.

00:04:47.000 --> 00:04:56.000
Nhưng bởi vì API này xem xét cẩn thận các trường hợp sử dụng phổ biến của nó, 99% thời gian, bạn chỉ cần phiên bản đơn giản.

00:04:56.000 --> 00:05:00.000
Mẫu nhãn này xuất hiện ở khắp mọi nơi trong SwiftUI.

00:05:00.000 --> 00:05:04.000
Và khi tôi nói ở khắp mọi nơi, tôi thực sự có ý đó.

00:05:04.000 --> 00:05:10.000
Vì vậy, xem xét các trường hợp sử dụng phổ biến là điều chúng tôi làm trên toàn bộ khuôn khổ.

00:05:10.000 --> 00:05:14.000
Tiếp theo, hãy xem xét việc cung cấp các mặc định thông minh.

00:05:14.000 --> 00:05:22.000
Để hợp lý hóa các trường hợp sử dụng phổ biến của chúng tôi, chúng tôi phải cung cấp các mặc định thông minh cho tất cả những thứ chúng tôi không chỉ định rõ ràng.

00:05:22.000 --> 00:05:30.000
Và không có ví dụ nào tốt hơn về điều này hơn một trong những API được sử dụng phổ biến nhất trong tất cả SwiftUI: Text.

00:05:30.000 --> 00:05:42.000
Văn bản là một ví dụ tuyệt vời về mặc định thông minh đến nỗi bạn có thể đã viết mã như thế này hàng trăm lần mà không cần suy nghĩ về mọi thứ bạn không cần phải chỉ định.

00:05:42.000 --> 00:05:50.000
Chỉ với mã này, SwiftUI sẽ bản địa hóa văn bản của bạn bằng cách tra cứu chuỗi được bản địa hóa trong gói ứng dụng của bạn với ngôn ngữ môi trường.

00:05:50.000 --> 00:05:56.000
Nó sẽ tự động thích ứng với bảng màu hiện tại, hỗ trợ chế độ tối ngay khi ra khỏi hộp.

00:05:56.000 --> 00:06:04.000
Và nó sẽ tự động chia tỷ lệ văn bản lên hoặc xuống tùy thuộc vào kích thước loại động khả năng truy cập hiện tại.

00:06:04.000 --> 00:06:11.000
Chúng tôi đã nói về những hành vi này trước đây, nhưng văn bản thậm chí còn làm được nhiều hơn thế đằng sau hậu trường.

00:06:11.000 --> 00:06:23.000
Ví dụ, khi bạn đặt hai văn bản cạnh nhau thành một ngăn xếp, khoảng cách giữa các văn bản sẽ tự động được điều chỉnh thành khoảng cách dòng chính xác cho văn bản trong ngữ cảnh hiện tại.

00:06:23.000 --> 00:06:34.000
Tất cả hành vi đó có thể được chỉ định thủ công, nhưng mặc định thông minh của SwiftUI có nghĩa là khi chúng không liên quan đến trường hợp sử dụng của bạn, chúng sẽ không xuất hiện tại trang web cuộc gọi.

00:06:34.000 --> 00:06:43.000
Văn bản là một ví dụ về API trong đó trường hợp đơn giản nhất là cực kỳ tối thiểu, nhưng mặc định thông minh áp dụng cho tất cả các loại trang web cuộc gọi.

00:06:43.000 --> 00:06:45.000
Lấy thanh công cụ làm ví dụ.

00:06:45.000 --> 00:06:49.000
Ở đây, chúng tôi có một thanh công cụ với một loạt các nút.

00:06:49.000 --> 00:06:57.000
Không cần phải chỉ định rõ ràng vị trí của chúng, các nút thanh công cụ được đặt theo quy ước nền tảng.

00:06:57.000 --> 00:07:07.000
Trên macOS, chúng sẽ xuất hiện ở cạnh trước của thanh công cụ, nhưng trên iOS, chúng sẽ xuất hiện trong thanh điều hướng, bắt đầu từ cạnh sau.

00:07:07.000 --> 00:07:14.000
Và cuối cùng, trên watchOS, chỉ có mục đầu tiên xuất hiện, được ghim dưới thanh điều hướng.

00:07:14.000 --> 00:07:25.000
Điều này hoạt động tốt cho phần lớn các trường hợp, nhưng nếu bạn cần kiểm soát nhiều hơn, chúng tôi cung cấp API bổ sung để chỉ định rõ ràng vị trí của các mục.

00:07:25.000 --> 00:07:33.000
Một lần nữa, tùy chỉnh ở đó nếu bạn cần, nhưng mặc định thông minh xử lý phần lớn các trường hợp.

00:07:33.000 --> 00:07:46.000
Xem xét các trường hợp sử dụng phổ biến và cung cấp các mặc định thông minh tạo ra một số trải nghiệm thực sự tuyệt vời, nhưng nếu việc sử dụng các API đó cảm thấy cồng kềnh hoặc chưa tinh chỉnh, nó có thể làm hỏng toàn bộ hiệu ứng.

00:07:46.000 --> 00:07:50.000
Điều đó đưa chúng ta đến chiến lược cuối cùng của chúng ta: tối ưu hóa trang web cuộc gọi.

00:07:50.000 --> 00:07:55.000
Và đối với điều đó, hãy xem xét một API khác: Bảng.

00:07:55.000 --> 00:08:00.000
Các bảng nhiều cột là một điều khiển rất giàu tính năng.

00:08:00.000 --> 00:08:03.000
Có rất nhiều thứ để cấu hình và rất nhiều chức năng.

00:08:03.000 --> 00:08:09.000
Nhưng phần lớn các bảng đơn giản hơn nhiều và không cần tất cả các tính năng đó.

00:08:09.000 --> 00:08:16.000
Chúng tôi muốn bảng có khả năng thực hiện hành vi phức tạp hơn này và ở định dạng dài dòng nhất của nó, nó có điều đó.

00:08:16.000 --> 00:08:25.000
Nó có hỗ trợ sắp xếp, nhiều cột với nội dung ô phong phú, các hàng được phân đoạn và nhiều, nhiều hơn nữa.

00:08:25.000 --> 00:08:38.000
Nhưng chúng tôi cũng muốn cung cấp trải nghiệm tuyệt vời trong các trường hợp phổ biến hơn, vì vậy chúng ta hãy xem mã được chỉ định đầy đủ cho bảng đơn giản hơn này và xem cách chúng tôi có thể tối ưu hóa trang web cuộc gọi của nó.

00:08:38.000 --> 00:08:42.000
Đầu tiên, hãy chia nhỏ ví dụ này.

00:08:42.000 --> 00:08:48.000
Bảng bắt đầu bằng cách chỉ định cách nó tạo dữ liệu cho mỗi hàng.

00:08:48.000 --> 00:08:56.000
Ở đây, tôi đang lặp lại từng cuốn sách mà chúng tôi hiện đang đọc và tạo một hàng bảng cho mỗi cuốn sách đó.

00:08:56.000 --> 00:09:01.000
Tiếp theo, nó chỉ định cách điền các cột từ dữ liệu cho mỗi hàng.

00:09:01.000 --> 00:09:08.000
Ở đây, tôi tạo một cột Tiêu đề và một cột Tác giả.

00:09:08.000 --> 00:09:18.000
Nó cũng cần một ràng buộc với thứ tự sắp xếp để cho phép bảng thay đổi sắp xếp khi người dùng nhấp vào tiêu đề cột bảng.

00:09:18.000 --> 00:09:25.000
Cuối cùng, tôi đã thêm một số mã sắp xếp lại dữ liệu của bảng bất cứ khi nào thứ tự sắp xếp thay đổi.

00:09:25.000 --> 00:09:33.000
Đó là rất nhiều thông tin, vì vậy chúng ta hãy xem cách tối ưu hóa trang web cuộc gọi này để thực sự nắm lấy tiết lộ liên tục.

00:09:33.000 --> 00:09:38.000
Một trường hợp sử dụng phổ biến nổi bật ngay lập tức liên quan đến các hàng.

00:09:38.000 --> 00:09:48.000
Hầu hết thời gian, trường hàng sẽ trông giống như trong ví dụ này: ForEach trên một bộ sưu tập, cung cấp một hàng bảng cho mỗi mục.

00:09:48.000 --> 00:09:56.000
Nhà phát triển không cần phải tự mình vượt qua tất cả những điều này, vì vậy SwiftUI cung cấp sự tiện lợi để xử lý việc này dưới mui xe.

00:09:56.000 --> 00:10:10.000
Bằng cách chuyển bộ sưu tập trực tiếp đến bảng, hành vi ForEach có thể được cung cấp đằng sau hậu trường, đơn giản hóa đáng kể trang web cuộc gọi của chúng tôi, nhưng điều này vẫn có thể được đơn giản hóa hơn nữa.

00:10:10.000 --> 00:10:12.000
Các trường hợp sử dụng phổ biến khác là gì?

00:10:12.000 --> 00:10:20.000
Chà, hầu hết thời gian, khi một trong những giá trị tôi muốn hiển thị trong bảng là một chuỗi, tôi sẽ chỉ sử dụng một văn bản để hiển thị nó trong cột.

00:10:20.000 --> 00:10:25.000
Chúng tôi cũng tối ưu hóa trang web cuộc gọi cho trường hợp này.

00:10:25.000 --> 00:10:32.000
Bất cứ khi nào đường dẫn khóa giá trị trỏ đến một chuỗi, chúng tôi cho phép bỏ qua chế độ xem được liên kết với TableColumn.

00:10:32.000 --> 00:10:38.000
Đó là một sự đơn giản hóa đáng kể khác, nhưng vẫn còn nhiều thứ để tối ưu hóa!

00:10:38.000 --> 00:10:46.000
Có thông tin trong trang web cuộc gọi mà không phải tất cả các bảng đều cần quan tâm: thứ tự sắp xếp.

00:10:46.000 --> 00:10:50.000
Trường hợp sử dụng đơn giản nhất cho bàn hoàn toàn không quan tâm đến việc phân loại!

00:10:50.000 --> 00:10:55.000
Vì vậy, chúng tôi cung cấp một phiên bản của bảng mà bản thân nó cũng không liên quan đến việc sắp xếp.

00:10:55.000 --> 00:10:59.000
Và điều này đưa chúng ta đến lần lặp lại cuối cùng của chúng ta. Đơn giản hơn nhiều!

00:10:59.000 --> 00:11:14.000
Mỗi ký tự của trang web cuộc gọi này phục vụ một mục đích rõ ràng và chúng tôi đến đây bằng cách tự hỏi mình hai câu hỏi chính ở mỗi bước: "Các trường hợp sử dụng phổ biến nhất mà chúng ta nên xây dựng tiện ích là gì?"

00:11:14.000 --> 00:11:19.000
Và "Thông tin cần thiết phải luôn được yêu cầu là gì?"

00:11:19.000 --> 00:11:26.000
Những câu hỏi hướng dẫn này rất tuyệt vời để giúp bạn tối ưu hóa các trang web cuộc gọi của mình, nhưng chúng cần được áp dụng cẩn thận.

00:11:26.000 --> 00:11:31.000
Nếu bạn không suy nghĩ về ý nghĩa của chúng đối với API của mình, chúng có thể khiến bạn lạc lối.

00:11:31.000 --> 00:11:37.000
Điều đó đưa chúng ta đến chiến lược cuối cùng của chúng ta: Soạn thảo, đừng liệt kê.

00:11:37.000 --> 00:11:46.000
Và để minh họa điều này, hãy nói về thiết kế của một phần hệ thống bố cục của SwiftUI: đặc biệt là các ngăn xếp HStack.

00:11:46.000 --> 00:11:52.000
Đầu tiên, hãy suy nghĩ về thông tin cần thiết cho một HStack là gì.

00:11:52.000 --> 00:12:01.000
Chà, nó cần biết nội dung nào nên có trong ngăn xếp và nội dung đó nên được sắp xếp như thế nào trong ngăn xếp.

00:12:01.000 --> 00:12:08.000
Chúng tôi đã có trình tạo chế độ xem để chỉ định nội dung của HStack, vì vậy hãy tập trung vào sự sắp xếp.

00:12:08.000 --> 00:12:15.000
Quay trở lại các câu hỏi hướng dẫn mà chúng tôi đã nhấn mạnh, các trường hợp sử dụng phổ biến nhất khi sắp xếp các yếu tố trong Hstack là gì?

00:12:15.000 --> 00:12:25.000
Chà, đôi khi tôi muốn hiển thị một ngăn xếp như thế này hiển thị các hộp lần lượt, bắt đầu từ cạnh trước.

00:12:25.000 --> 00:12:28.000
Một trường hợp phổ biến khác là muốn tập trung vào các yếu tố.

00:12:28.000 --> 00:12:34.000
Và cuối cùng, tôi có thể muốn căn chỉnh các yếu tố chống lại cạnh sau.

00:12:34.000 --> 00:12:45.000
VStack đã có một API với các trường hợp tương tự như thế này, căn chỉnh, vì vậy có vẻ hấp dẫn để tạo một enum tương tự cho việc sắp xếp các phần tử trong ngăn xếp.

00:12:45.000 --> 00:12:48.000
Điều này hỗ trợ tất cả các trường hợp mà chúng tôi đã đề cập!

00:12:48.000 --> 00:12:57.000
Bằng cách chỉ định sự sắp xếp của một HStack, tôi có thể chọn một sự sắp xếp hàng đầu, cuối hoặc trung tâm, tùy thuộc vào điều tôi muốn.

00:12:57.000 --> 00:13:08.000
Nhưng bây giờ điều gì sẽ xảy ra nếu tôi muốn đặt khoảng cách đồng đều các phần tử hoặc chỉ đặt khoảng cách giữa các phần tử hoặc chỉ đặt khoảng trắng trước phần tử cuối cùng?

00:13:08.000 --> 00:13:10.000
Điều này đang trở nên thực sự lộn xộn!

00:13:10.000 --> 00:13:13.000
Nhưng quan trọng hơn, nó không bền vững.

00:13:13.000 --> 00:13:20.000
Tôi phải thêm một trường hợp liệt kê cho mọi hành vi chúng tôi muốn, và chúng tôi có thể không nghĩ ra tất cả các trường hợp hữu ích!

00:13:20.000 --> 00:13:35.000
Khi bạn thấy mình liệt kê các trường hợp phổ biến thay vì cung cấp các tiện ích cho chúng, hãy thử chia API của bạn thành các phần có thể kết hợp có thể xây dựng giải pháp: Soạn, không liệt kê.

00:13:35.000 --> 00:13:51.000
Trong trường hợp ngăn xếp, SwiftUI cung cấp Spacer và cho phép bạn soạn nó với các phần tử trong ngăn xếp của mình để xây dựng tất cả các sơ đồ khoảng cách mà chúng tôi đã liệt kê và nhiều, nhiều hơn nữa, đó là cách chúng tôi đến API mà chúng tôi có ngày hôm nay.

00:13:51.000 --> 00:14:07.000
Thiết kế trải nghiệm tốt nhất để tiết lộ liên tục ở đây không chỉ là giảm thiểu trang web cuộc gọi, mà còn liên quan đến việc suy nghĩ cẩn thận về cách trang web cuộc gọi đó nên mở rộng quy mô để xử lý tất cả các trường hợp của nó: trong trường hợp này, thông qua thành phần.

00:14:07.000 --> 00:14:15.000
Khi tự viết mã, có thể cực kỳ hữu ích khi áp dụng cùng một loại cân nhắc cẩn thận cho các thành phần bạn tạo.

00:14:15.000 --> 00:14:20.000
Và tóm lại, điều đó bắt đầu bằng cách xem xét các trường hợp sử dụng phổ biến.

00:14:20.000 --> 00:14:27.000
Bằng cách áp dụng tiết lộ lũy tiến, mã bạn viết sẽ giúp bạn tiết kiệm thời gian trong các trường hợp sử dụng phổ biến nhất.

00:14:27.000 --> 00:14:33.000
Mặc định thông minh có nghĩa là bạn sẽ không phải suy nghĩ về các chi tiết trong những trường hợp phổ biến đó.

00:14:33.000 --> 00:14:38.000
Làm việc để tối ưu hóa các trang web cuộc gọi bạn xây dựng sẽ cho phép bạn lặp lại nhanh chóng.

00:14:38.000 --> 00:14:47.000
Và cuối cùng, việc sử dụng thành phần sẽ cho phép bạn xây dựng các API đủ linh hoạt để phù hợp với tất cả các trường hợp sử dụng của chúng.

00:14:47.000 --> 00:14:58.000
Và bởi vì bạn là một nhà thiết kế API, bạn có thể áp dụng những bài học này vào mã bạn viết hàng ngày, cho dù nó được thiết kế cho người khác hay chỉ để bạn sử dụng.

00:14:58.000 --> 00:15:00.000
Cảm ơn bạn đã xem.

00:15:00.000 --> 23:59:59.000
.

