WEBVTT

00:00:00.000 --> 00:00:09.000
♪ nhạc cụ hip hop ♪

00:00:09.000 --> 00:00:14.000
- Chào mừng đến với "Có gì mới trong UIKit" trong iOS 16.

00:00:14.000 --> 00:00:19.000
Tôi là Dima, và tôi là quản lý kỹ thuật trong nhóm UIKit.

00:00:19.000 --> 00:00:23.000
UIKit là khuôn khổ mạnh mẽ cốt lõi của các ứng dụng của bạn.

00:00:23.000 --> 00:00:29.000
Nó đã được cập nhật để hỗ trợ các tính năng mới trong iOS 16.

00:00:29.000 --> 00:00:50.000
Trong video này, tôi sẽ đề cập đến các cải tiến giao diện người dùng cho năng suất, cải tiến kiểm soát, tinh chỉnh API và tôi sẽ nói về những cách mới thú vị để sử dụng UIKit và SwiftUI cùng nhau.

00:00:50.000 --> 00:01:07.000
Chúng tôi đã giúp UIKit phát triển giao diện người dùng được sắp xếp hợp lý, có thể khám phá dễ dàng hơn với các thanh điều hướng được cải thiện có menu tiêu đề mới, tìm và thay thế và mô phỏng lại các tương tác chỉnh sửa để cắt, sao chép và dán.

00:01:07.000 --> 00:01:11.000
Bạn sẽ có thể nâng cao các ứng dụng dựa trên tài liệu của mình.

00:01:11.000 --> 00:01:22.000
Tôi sẽ bắt đầu bằng cách xem xét kỹ hơn các thanh điều hướng, được cập nhật để hỗ trợ khả năng thanh công cụ lớp máy tính để bàn.

00:01:22.000 --> 00:01:35.000
Trong iOS 16, UIKit giới thiệu hai kiểu điều hướng mới để hỗ trợ tốt hơn nhu cầu của các ứng dụng dựa trên tài liệu: trình duyệt và trình chỉnh sửa.

00:01:35.000 --> 00:01:47.000
Kiểu trình duyệt được thiết kế cho các ứng dụng sử dụng lịch sử hoặc cấu trúc thư mục để điều hướng, như trình duyệt web và tài liệu.

00:01:47.000 --> 00:01:55.000
Trình chỉnh sửa được thiết kế cho các giao diện tập trung vào việc chỉnh sửa tài liệu.

00:01:55.000 --> 00:02:07.000
Trong iOS 16, bạn có thể thêm nhiều mục nút thanh vào ứng dụng của mình, một tập hợp con sẽ được hiển thị ở giữa thanh điều hướng.

00:02:07.000 --> 00:02:17.000
Bằng cách nhấn vào mục "tùy chỉnh thanh công cụ" trong menu, các mục có thể được sắp xếp lại bằng cách kéo đến và đi từ cửa sổ bật lên các mục.

00:02:17.000 --> 00:02:25.000
Kết quả là cấu hình mới vẫn tồn tại trong suốt lần khởi chạy ứng dụng.

00:02:25.000 --> 00:02:42.000
Để thích ứng với sự thay đổi kích thước, ví dụ, khi vào chế độ song song với một ứng dụng khác, hệ thống sẽ tự động cung cấp menu tràn để truy cập bất kỳ mục nào không phù hợp.

00:02:42.000 --> 00:02:57.000
Chúng tôi đã thêm một menu tiêu đề hoạt động với các kiểu điều hướng mới và hỗ trợ một số chức năng tiêu chuẩn: sao chép, di chuyển, đổi tên, xuất và in.

00:02:57.000 --> 00:03:05.000
Chúng được hiển thị tự động trong menu khi các phương thức đại diện tương ứng được triển khai.

00:03:05.000 --> 00:03:15.000
Cũng có thể thêm các mục hoàn toàn tùy chỉnh vào menu tiêu đề.

00:03:15.000 --> 00:03:29.000
Ngoài ra, các ứng dụng được xây dựng bằng Mac Catalyst tận dụng các thanh điều hướng được cải thiện bằng cách tích hợp liền mạch với NSToolbar mà không cần thêm mã.

00:03:29.000 --> 00:03:37.000
iOS 16 giới thiệu những cách mới để thao tác văn bản một cách nhất quán trên các ứng dụng khác nhau.

00:03:37.000 --> 00:03:41.000
Cái đầu tiên là tìm và thay thế mới.

00:03:41.000 --> 00:03:53.000
Về mặt khái niệm, nó khác với tìm kiếm trong ứng dụng cấp cao hơn hoạt động trên các đối tượng mô hình dữ liệu như ảnh hoặc sự kiện lịch.

00:03:53.000 --> 00:03:58.000
Thay vào đó, tìm và thay thế được xây dựng có chủ đích để làm việc với văn bản.

00:03:58.000 --> 00:04:09.000
Chỉ cần đặt cờ để kích hoạt tính năng cho các chế độ xem UIKit tích hợp như UITextView và WKWebView.

00:04:09.000 --> 00:04:17.000
Ngoài ra, nó hoạt động liền mạch trên nhiều chế độ xem và tài liệu đã chọn tham gia vào hệ thống này.

00:04:17.000 --> 00:04:22.000
Tiếp theo, menu chỉnh sửa đã nhận được một bản nâng cấp lớn.

00:04:22.000 --> 00:04:26.000
Bây giờ nó trông khác nhau tùy thuộc vào phương thức đầu vào được sử dụng.

00:04:26.000 --> 00:04:35.000
Khi tương tác cảm ứng, bạn sẽ nhận được một menu được thiết kế lại tương tác nhiều hơn.

00:04:35.000 --> 00:04:42.000
Khi sử dụng một con trỏ, bạn sẽ có một menu ngữ cảnh đầy đủ tính năng hơn.

00:04:42.000 --> 00:04:56.000
Để cung cấp cả hai trải nghiệm này một cách liền mạch, chúng tôi đã giới thiệu UIEditMenuInteraction như một sự thay thế hoàn toàn cho UIMenuController hiện không được chấp nhận.

00:04:56.000 --> 00:05:03.000
Ngoài ra còn có API mới để chèn các hành động vào menu của chế độ xem văn bản.

00:05:03.000 --> 00:05:17.000
Xem "Áp dụng tương tác chỉnh sửa lớp máy tính để bàn" để tìm hiểu tất cả các chi tiết trên menu chỉnh sửa mới và tìm hiểu cách áp dụng tìm tương tác cho các chế độ xem tùy chỉnh.

00:05:17.000 --> 00:05:22.000
Có một bản cập nhật giao diện người dùng trực quan mà tôi muốn đề cập.

00:05:22.000 --> 00:05:31.000
Trong iOS 16, thanh bên ở chế độ trượt qua sẽ tự động trở nên sống động mà không cần bất kỳ mã bổ sung nào.

00:05:31.000 --> 00:05:38.000
Để đạt được điều này, UIKit thay mặt bạn quản lý một tập hợp các chế độ xem riêng tư.

00:05:38.000 --> 00:05:52.000
Đó là những tính năng năng suất mới trong UIKit: các thanh điều hướng có thể tùy chỉnh mới, tìm và thay thế, chỉnh sửa các tương tác, cũng như menu tiêu đề mạnh mẽ.

00:05:52.000 --> 00:05:54.000
Tôi chỉ đang gãi bề mặt ở đây.

00:05:54.000 --> 00:06:13.000
Để tìm hiểu thêm, hãy kiểm tra phiên "Gặp gỡ iPad lớp máy tính để bàn", cũng như "Xây dựng ứng dụng iPad lớp máy tính để bàn" chuyên sâu hơn, nơi bạn sẽ được hướng dẫn cải thiện ứng dụng mẫu với các tính năng UIKit nâng cao mới trong iOS 16.

00:06:13.000 --> 00:06:22.000
Bây giờ tôi sẽ giới thiệu hai điều khiển mới mà chúng tôi đã thêm và thảo luận về một số cải tiến cho UIPageControl.

00:06:22.000 --> 00:06:34.000
Kiểu lịch nội tuyến của UIDatePicker hiện có sẵn dưới dạng một thành phần độc lập đầy đủ tính năng, dưới dạng UICalendarView.

00:06:34.000 --> 00:06:45.000
UICalendarView hỗ trợ các loại hành vi lựa chọn khác nhau, như ngày đơn tùy chọn, cũng như chọn nhiều ngày.

00:06:45.000 --> 00:06:53.000
Ngoài phạm vi ngày có sẵn, nó cũng hỗ trợ vô hiệu hóa các ngày riêng lẻ khỏi lựa chọn.

00:06:53.000 --> 00:07:00.000
Hơn nữa, bạn có thể chú thích các ngày riêng lẻ bằng đồ trang trí.

00:07:00.000 --> 00:07:13.000
Một điểm khác biệt chính giữa UICalendarView và UIDatePicker là UICalendarView đại diện cho các ngày dưới dạng NSDateComponents, thay vì NSDate.

00:07:13.000 --> 00:07:27.000
Không giống như NSDate, các thành phần ngày là một biểu diễn tốt hơn và chính xác hơn của một ngày trong khi NSDate là một đại diện của một thời điểm trong thời gian.

00:07:27.000 --> 00:07:38.000
Bởi vì NSDateComponents cung cấp nhiều tính linh hoạt, bạn nên rất rõ ràng về NSCalendar mà các thành phần được đại diện bởi.

00:07:38.000 --> 00:07:43.000
Lưu ý rằng bạn không nên đưa ra giả định về loại lịch hiện tại.

00:07:43.000 --> 00:07:53.000
Nếu bạn cần lịch là Gregorian, hãy chỉ định rõ ràng lịch Gregorian.

00:07:53.000 --> 00:08:02.000
Để định cấu hình chế độ xem Lịch như chế độ xem được hiển thị trước đó, trước tiên, hãy tạo chế độ xem Lịch và đặt đại diện của nó.

00:08:02.000 --> 00:08:15.000
Để đảm bảo rằng Lịch được hỗ trợ bởi Gregorian NSCalendar, hãy đặt thuộc tính lịch trên calendarView thành Gregorian NSCalendar.

00:08:15.000 --> 00:08:19.000
Tiếp theo, để cấu hình lựa chọn nhiều ngày.

00:08:19.000 --> 00:08:35.000
Tạo một đối tượng UICalendarSelectionMultiDate và đặt thuộc tính ngày đã chọn trên đối tượng lựa chọn thành các ngày hiện có mà bạn có từ mô hình dữ liệu của mình để hiển thị trong chế độ xem Lịch.

00:08:35.000 --> 00:08:44.000
Sau đó, đặt đối tượng lựa chọn thành hành vi lựa chọn của chế độ xem lịch.

00:08:44.000 --> 00:09:00.000
Để ngăn chặn việc lựa chọn các ngày riêng lẻ trong Lịch, hãy triển khai phương thức multiDateSelection:canSelectDate: từ đại diện lựa chọn của lịch để kiểm soát ngày nào có thể được chọn.

00:09:00.000 --> 00:09:07.000
Những ngày không thể chọn sẽ xuất hiện màu xám xịt trong chế độ xem lịch.

00:09:07.000 --> 00:09:19.000
Để chú thích các ngày riêng lẻ bằng đồ trang trí, hãy triển khai lịch của đại biểu lịch Xem:decorationForDateComponents: Phương pháp.

00:09:19.000 --> 00:09:23.000
Để không có đồ trang trí, chỉ cần trả lại số không.

00:09:23.000 --> 00:09:29.000
Đối với một vòng tròn màu xám mặc định, hãy trả về trang trí mặc định.

00:09:29.000 --> 00:09:35.000
Bạn cũng có thể tạo đồ trang trí hình ảnh với các tùy chọn để tùy chỉnh màu sắc của nó.

00:09:35.000 --> 00:09:44.000
Và nếu bạn cần thêm, hãy sử dụng trang trí customView và trả lại chế độ xem của bạn trong nhà cung cấp chế độ xem.

00:09:44.000 --> 00:09:53.000
Xin lưu ý rằng các đồ trang trí chế độ xem tùy chỉnh không cho phép tương tác và được cắt thành không gian có sẵn.

00:09:53.000 --> 00:09:56.000
Việc kiểm soát trang cũng được cải thiện.

00:09:56.000 --> 00:10:08.000
Chúng tôi đã thêm hỗ trợ cho các hình ảnh chỉ báo tùy chỉnh cho trang hiện tại, vì vậy bây giờ bạn có thể chọn các hình ảnh khác nhau tùy thuộc vào việc trang có được chọn hay không.

00:10:08.000 --> 00:10:16.000
Bây giờ bạn cũng có thể tùy chỉnh hoàn toàn cả hướng và hướng điều khiển trang.

00:10:16.000 --> 00:10:27.000
Đây là một ví dụ về việc định cấu hình điều khiển trang dọc có các chỉ số thay đổi giữa các trang hiện tại và không hiện tại.

00:10:27.000 --> 00:10:41.000
Tôi đặt hướng điều khiển trang từ trên xuống dưới và đặt hình ảnh chỉ báo ưa thích và hình ảnh chỉ báo hiện tại ưa thích và thế là xong!

00:10:41.000 --> 00:10:46.000
Apple cam kết bảo vệ quyền riêng tư và bảo mật của người dùng.

00:10:46.000 --> 00:11:00.000
Trong iOS 15, khi một ứng dụng truy cập theo chương trình vào bảng dán mà không sử dụng giao diện Dán do hệ thống cung cấp, một biểu ngữ sẽ xuất hiện để chỉ ra rằng bảng dán đã được truy cập.

00:11:00.000 --> 00:11:04.000
Mới sử dụng iOS 16, hành vi của hệ thống đã thay đổi.

00:11:04.000 --> 00:11:13.000
Bây giờ, thay vì một biểu ngữ, chúng tôi sẽ hiển thị một cảnh báo yêu cầu quyền sử dụng bảng dán.

00:11:13.000 --> 00:11:23.000
Giao diện dán hệ thống mà người dùng tương tác cung cấp quyền truy cập ngầm vào bảng dán và sẽ tránh được cảnh báo.

00:11:23.000 --> 00:11:34.000
Nếu bạn có các điều khiển dán tùy chỉnh, bạn có thể thay thế chúng bằng UIPasteControl mới trông và hoạt động giống như một UIButton đã điền.

00:11:34.000 --> 00:11:43.000
Nó được kích hoạt bất cứ khi nào bảng dán có nội dung tương thích với mục tiêu dán của điều khiển.

00:11:43.000 --> 00:11:53.000
Vì vậy, đó là UICalendarView mạnh mẽ mới, UIPageControl được cải tiến, cũng như UIPasteControl định hướng bảo mật.

00:11:53.000 --> 00:11:57.000
Hãy tiếp tục và thử chúng.

00:11:57.000 --> 00:12:03.000
Bây giờ tôi sẽ hướng dẫn bạn một số cải tiến API mà chúng tôi đã thực hiện.

00:12:03.000 --> 00:12:11.000
Trong iOS 15, các trang tính đã được thêm vào các trang tính cho phép xây dựng giao diện người dùng linh hoạt và năng động.

00:12:11.000 --> 00:12:21.000
Trong iOS 16, chúng tôi đã thêm hỗ trợ cho các trang tính tùy chỉnh để bạn có thể tạo các trang tính bất kỳ kích thước nào.

00:12:21.000 --> 00:12:31.000
Để tận dụng tính năng này, hãy sử dụng chốt ".custom" mới và chỉ định chiều cao của trang tính bằng các điểm trong một khối liên quan.

00:12:31.000 --> 00:12:42.000
Bạn có thể trả về một giá trị không đổi, hoặc một tỷ lệ phần trăm của chiều cao detent tối đa.

00:12:42.000 --> 00:12:57.000
Và bạn cũng có thể cung cấp cho detent tùy chỉnh của mình một mã định danh nếu bạn cần tham khảo nó từ các API khác, ví dụ, để vô hiệu hóa làm mờ phía trên detent tùy chỉnh của bạn.

00:12:57.000 --> 00:13:05.000
Lưu ý rằng giá trị bạn trả về từ khối tùy chỉnh không nên tính đến vùng an toàn phía dưới được chèn vào.

00:13:05.000 --> 00:13:13.000
Điều này là để tính toán tương tự hoạt động cho cả tấm nổi và tấm gắn cạnh.

00:13:13.000 --> 00:13:24.000
Để tìm hiểu thêm về việc tùy chỉnh các trang tính với các tùy chọn hệ thống và các tùy chọn khác, hãy xem video Tùy chỉnh và thay đổi kích thước trang tính trong UIKit.

00:13:24.000 --> 00:13:33.000
Mã mẫu cho video đó cũng đã được cập nhật để hiển thị các API tùy chỉnh mới này.

00:13:33.000 --> 00:13:38.000
Có những tính năng mới cho Biểu tượng SF trong UIKit.

00:13:38.000 --> 00:13:47.000
Các biểu tượng hỗ trợ bốn chế độ kết xuất: đơn sắc, nhiều màu, phân cấp và bảng màu.

00:13:47.000 --> 00:13:55.000
UIKit sẽ sử dụng kết xuất đơn sắc theo mặc định trừ khi biểu tượng được cấu hình với chế độ kết xuất khác.

00:13:55.000 --> 00:14:07.000
Trong iOS 16, UIKit có thể hiển thị các biểu tượng riêng lẻ với chế độ khác với đơn sắc nếu không có chế độ kết xuất nào được chỉ định.

00:14:07.000 --> 00:14:10.000
Lấy các biểu tượng thiết bị này làm ví dụ.

00:14:10.000 --> 00:14:20.000
Trong iOS 15 trở về trước, các biểu tượng này sử dụng kết xuất đơn sắc nếu không có chế độ kết xuất nào được chỉ định.

00:14:20.000 --> 00:14:26.000
Trong iOS 16, những biểu tượng này thay vào đó mặc định là kết xuất phân cấp.

00:14:26.000 --> 00:14:33.000
Nói chung, chế độ kết xuất mặc định của biểu tượng là cách ưa thích để hiển thị biểu tượng.

00:14:33.000 --> 00:14:40.000
Vì vậy, trong trường hợp này, bạn nên cho phép kết xuất phân cấp mặc định có hiệu lực.

00:14:40.000 --> 00:14:55.000
Tuy nhiên, kết xuất đơn sắc có thể được yêu cầu rõ ràng với UIImage.SymbolConfiguration mới. preferringMonochrome() API.

00:14:55.000 --> 00:15:06.000
UIKit đã thêm hỗ trợ cho các biểu tượng biến đổi, cho phép các ứng dụng hiển thị các biến thể của biểu tượng dựa trên giá trị từ 0 đến 1.

00:15:06.000 --> 00:15:11.000
Giả sử một ứng dụng muốn mô tả mức âm lượng hiện tại bằng một biểu tượng.

00:15:11.000 --> 00:15:20.000
Ứng dụng có thể sử dụng biểu tượng speaker.3.wave.fill, đã được cập nhật để hỗ trợ kết xuất biến.

00:15:20.000 --> 00:15:27.000
Ở giá trị 0, sóng loa bị mờ dần, cho thấy mức âm lượng thấp nhất.

00:15:27.000 --> 00:15:37.000
Khi giá trị tăng lên đến 1, sóng loa dần dần lấp đầy, cho thấy mức âm lượng cao hơn.

00:15:37.000 --> 00:15:48.000
Nếu một biểu tượng hỗ trợ kết xuất biến, thì các ứng dụng có thể yêu cầu một phiên bản của biểu tượng phản ánh giá trị từ 0 đến 1.

00:15:48.000 --> 00:15:53.000
Sử dụng các ký hiệu biến đổi rất đơn giản.

00:15:53.000 --> 00:16:03.000
Bạn có thể nhận phiên bản không biến thông thường của một biểu tượng với API Biểu tượng SF tiêu chuẩn trên UIImage.

00:16:03.000 --> 00:16:12.000
Để có được một phiên bản của biểu tượng đó với một giá trị biến cụ thể, chỉ cần thêm tham số variableValue.

00:16:12.000 --> 00:16:20.000
Bạn thậm chí có thể kết hợp kết xuất biến đổi với các chế độ kết xuất khác, chẳng hạn như bảng màu, để tạo thêm phong cách cho biểu tượng.

00:16:20.000 --> 00:16:32.000
Nhiều biểu tượng hệ thống hiện hỗ trợ kết xuất biến và các ứng dụng có thể cập nhật các biểu tượng tùy chỉnh của chúng để hỗ trợ sự thay đổi.

00:16:32.000 --> 00:16:45.000
Để tìm hiểu cách tạo các biểu tượng biến tùy chỉnh, hãy xem các phiên "Nhận màu biến trong Biểu tượng SF" và "Có gì mới trong Biểu tượng SF 4".

00:16:45.000 --> 00:17:03.000
Chúng tôi đã hiện đại hóa UIKit để hoạt động với các tính năng Swift Concurrency mới, bao gồm làm cho các loại bất biến như UIImage và UIColor phù hợp với Sendable, vì vậy bạn có thể gửi chúng giữa MainActor và các tác nhân tùy chỉnh mà không cần cảnh báo trình biên dịch.

00:17:03.000 --> 00:17:16.000
Ví dụ, ở đây chúng ta có một diễn viên tùy chỉnh được gọi là Bộ xử lý và một bộ điều khiển chế độ xem được gọi là ImageViewer được liên kết với MainActor.

00:17:16.000 --> 00:17:28.000
Trong phương pháp sendImageForProcessing, ImageViewer gửi một hình ảnh đến diễn viên Bộ xử lý để xử lý, để làm cho nó trở nên lạ mắt như thêm ánh sáng lấp lánh và cầu vồng vào nó.

00:17:28.000 --> 00:17:38.000
Điều này an toàn vì UIImage không thể thay đổi, vì vậy Bộ xử lý phải tạo bản sao mới để thêm cầu vồng và lấp lánh.

00:17:38.000 --> 00:17:49.000
Bất kỳ mã nào có tham chiếu đến hình ảnh gốc đều không hiển thị những sửa đổi này và trạng thái được chia sẻ không bị đột biến một cách không an toàn.

00:17:49.000 --> 00:17:57.000
Tương phản điều này với UIBezierPath, không thể gửi được vì nó có thể thay đổi được.

00:17:57.000 --> 00:18:09.000
Thật tuyệt vời khi một cái gì đó mà trước đây chỉ có thể được thể hiện trong tài liệu bây giờ có thể được trình biên dịch kiểm tra?

00:18:09.000 --> 00:18:25.000
Để tìm hiểu thêm về Sendable và Swift Concurrency, hãy xem các video "Loại bỏ các cuộc đua dữ liệu bằng Swift Concurrency" và "Trực quan hóa và tối ưu hóa Swift Concurrency".

00:18:25.000 --> 00:18:31.000
iOS 16 có tính năng hỗ trợ mạnh mẽ mới cho màn hình ngoài.

00:18:31.000 --> 00:18:41.000
Tin tuyệt vời là bạn không cần phải cập nhật ứng dụng của mình để tận dụng điều này, trừ khi bạn đang sử dụng các API UIScreen cũ.

00:18:41.000 --> 00:18:46.000
Bạn không còn có thể cho rằng ứng dụng của mình đang ở trên màn hình chính.

00:18:46.000 --> 00:18:55.000
Thay vào đó, hãy trì hoãn các API cụ thể hơn, như bộ sưu tập đặc điểm và API UIScene, để có được thông tin bạn cần.

00:18:55.000 --> 00:19:05.000
Nếu ứng dụng của bạn vẫn không sử dụng UIScene, bây giờ thậm chí còn có nhiều lý do hơn để nâng cấp và hỗ trợ nhiều cửa sổ.

00:19:05.000 --> 00:19:12.000
Các ô tự thay đổi kích thước trong UICollectionView và UITableView đã được nâng cấp lớn.

00:19:12.000 --> 00:19:16.000
Bây giờ các tế bào cũng đang tự thay đổi kích thước!

00:19:16.000 --> 00:19:28.000
Trong iOS 16, khi nội dung bên trong ô hiển thị thay đổi, ô sẽ tự động được thay đổi kích thước để phù hợp với nội dung mới.

00:19:28.000 --> 00:19:43.000
Hành vi mới này được bật theo mặc định và UICollectionView và UITableView đều có thuộc tính selfSizingInvalidation mới cho phép bạn kiểm soát chức năng mới này.

00:19:43.000 --> 00:19:56.000
Đây là cách nó hoạt động: Khi selfSizingInvalidation được bật, các ô có thể yêu cầu được thay đổi kích thước bằng chế độ xem bộ sưu tập hoặc bảng chứa của chúng.

00:19:56.000 --> 00:20:08.000
Nếu bạn đang sử dụng UIListContentConfiguration để định cấu hình các ô, việc vô hiệu hóa sẽ tự động xảy ra bất cứ khi nào cấu hình của ô thay đổi.

00:20:08.000 --> 00:20:20.000
Đối với bất kỳ trường hợp nào khác, bạn có thể gọi phương thức invalidateIntrinsicContentSize trên ô hoặc chế độ xem nội dung của nó để thay đổi kích thước ô.

00:20:20.000 --> 00:20:33.000
Theo mặc định, các ô sẽ được thay đổi kích thước bằng hoạt ảnh, nhưng bạn có thể kết thúc cuộc gọi vô hiệu hóa Nội tại Nội dung Nội dung Kích thước bên trong performWithoutAnimation để thay đổi kích thước mà không có hoạt ảnh.

00:20:33.000 --> 00:20:47.000
UICollectionView và UITableView kết hợp thông minh việc vô hiệu hóa kích thước từ các ô thành một bản cập nhật duy nhất được thực hiện vào thời điểm tối ưu.

00:20:47.000 --> 00:20:57.000
Nếu bạn đang sử dụng Bố cục Tự động trong các ô của mình, bạn có thể chọn tham gia một hành vi thậm chí còn toàn diện hơn bằng cách chọn enabledIncludingConstraints.

00:20:57.000 --> 00:21:15.000
Điều này có nghĩa là khi một ô phát hiện bất kỳ thay đổi bố cục tự động nào bên trong contentView của nó, nó sẽ tự động gọi invalidateIntrinsicContentSize trên chính nó để bộ sưu tập chứa hoặc chế độ xem bảng có thể thay đổi kích thước nếu cần thiết.

00:21:15.000 --> 00:21:25.000
Điều này làm cho việc có các ô tự động điều chỉnh kích thước của chúng để đáp ứng với nội dung hoặc cập nhật bố cục trở nên cực kỳ dễ dàng.

00:21:25.000 --> 00:21:28.000
UIKit mạnh mẽ và linh hoạt.

00:21:28.000 --> 00:21:36.000
Bạn cũng có thể tận dụng tính biểu cảm của việc triển khai giao diện người dùng bằng SwiftUI.

00:21:36.000 --> 00:21:43.000
Chúng tôi đã giúp việc kết hợp cả hai khuôn khổ trong cùng một ứng dụng trở nên dễ dàng hơn nhiều.

00:21:43.000 --> 00:21:55.000
Trong iOS 16, có một cách hoàn toàn mới để xây dựng các ô cho bộ sưu tập và chế độ xem bảng của bạn bằng SwiftUI.

00:21:55.000 --> 00:22:03.000
Điều này được thực hiện bởi một loại cấu hình nội dung mới có tên UIHostingConfiguration.

00:22:03.000 --> 00:22:15.000
Chỉ với một dòng mã, bạn có thể bắt đầu viết SwiftUI ngay bên trong các ô của mình - không cần thêm chế độ xem hoặc bộ điều khiển chế độ xem nào cả.

00:22:15.000 --> 00:22:22.000
Đây là một ô tùy chỉnh đơn giản được viết bằng SwiftUI bằng UIHostingConfiguration.

00:22:22.000 --> 00:22:27.000
Việc xây dựng tế bào này cực kỳ dễ dàng.

00:22:27.000 --> 00:22:43.000
Đây không chỉ là một cách tuyệt vời để bắt đầu tích hợp SwiftUI vào ứng dụng của bạn, bản chất biểu cảm của SwiftUI có nghĩa là chưa bao giờ có cách nào mạnh mẽ hơn để xây dựng các ô tùy chỉnh trong UIKit.

00:22:43.000 --> 00:22:56.000
Chủ đề này còn rất nhiều điều nữa, vì vậy hãy chắc chắn xem video "Sử dụng SwiftUI với UIKit" để tìm hiểu thêm.

00:22:56.000 --> 00:23:02.000
Có một vài thay đổi nhỏ nhưng quan trọng mà bạn nên biết.

00:23:02.000 --> 00:23:14.000
Để ngăn người dùng lấy dấu vân tay, UIDevice.name hiện báo cáo tên kiểu máy thay vì tên thiết bị tùy chỉnh của người dùng.

00:23:14.000 --> 00:23:20.000
Sử dụng tên tùy chỉnh bây giờ yêu cầu nhận được quyền lợi.

00:23:20.000 --> 00:23:24.000
Cài đặt UIDevice.orientation không còn được hỗ trợ nữa.

00:23:24.000 --> 00:23:36.000
Thay vào đó, hãy sử dụng UIViewController APIs như preferredInterfaceOrientation để thể hiện định hướng dự định của giao diện của bạn.

00:23:36.000 --> 00:23:38.000
Tiếp theo là gì?

00:23:38.000 --> 00:23:43.000
Biên dịch ứng dụng của bạn bằng iOS 16 SDK.

00:23:43.000 --> 00:23:50.000
Kiểm tra các tính năng mới như menu chỉnh sửa văn bản và tìm và thay thế.

00:23:50.000 --> 00:23:57.000
Áp dụng các API UIKit mới để sử dụng các tính năng kiểm soát và năng suất nâng cao mới.

00:23:57.000 --> 00:24:05.000
Và thử nghiệm những cách thú vị mới để kết hợp SwiftUI trong ứng dụng UIKit của bạn.

00:24:05.000 --> 23:59:59.000
Cảm ơn bạn. ♪ ♪

