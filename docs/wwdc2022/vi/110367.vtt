WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:13.000
Alex: Xin chào, tên tôi là Alex, và tôi làm việc trên Developer Tools.

00:00:13.000 --> 00:00:20.000
Hôm nay tôi muốn nói chuyện với bạn về các tính năng C++ 20 mới được hỗ trợ trong Xcode 14.

00:00:20.000 --> 00:00:30.000
Tôi sẽ đặc biệt tập trung vào cách các khái niệm C++ 20 đơn giản hóa và cải thiện loại an toàn của mã C++ chung.

00:00:30.000 --> 00:00:37.000
Tôi sẽ trình bày cách sử dụng các khái niệm và cũng sẽ giải thích cách tạo ra các khái niệm của riêng bạn.

00:00:37.000 --> 00:00:55.000
Tôi sẽ kết thúc cuộc nói chuyện bằng cách liệt kê một số tính năng C++20 mới khác được hỗ trợ trong Xcode và sẽ đề cập đến cách một số trong số chúng có thể được sử dụng để cải thiện hiệu suất của các dự án C++ của bạn thông qua sức mạnh của việc biên dịch đánh giá mã thời gian.

00:00:55.000 --> 00:01:03.000
Trước khi đi sâu vào các khái niệm C++, trước tiên chúng ta hãy xem qua tổng quan nhanh về cách viết mã chung trong C++.

00:01:03.000 --> 00:01:08.000
Giả sử tôi muốn viết một hàm kiểm tra xem một số có lẻ hay không.

00:01:08.000 --> 00:01:16.000
Tôi có thể viết một hàm nhận tham số 'int' và nó sẽ hoạt động với bất kỳ giá trị nào có thể được biểu diễn bằng loại 'int'.

00:01:16.000 --> 00:01:22.000
Điều gì sẽ xảy ra nếu tôi chuyển một giá trị nguyên không dấu 64 bit cho nó?

00:01:22.000 --> 00:01:31.000
Một hàm cụ thể như thế này không hoạt động chính xác với các giá trị 64 bit, vì chúng bị cắt ngắn để phù hợp với loại 'int'.

00:01:31.000 --> 00:01:36.000
Để khắc phục điều này, tôi có thể biến 'isOdd' thành một mẫu hàm.

00:01:36.000 --> 00:01:42.000
Bây giờ tôi đã có một mẫu hàm, tôi có thể chuyển giá trị số nguyên không dấu 64 bit cho nó.

00:01:42.000 --> 00:01:53.000
Trình biên dịch bây giờ sẽ tự động tạo ra một chuyên ngành 'isOdd' hoạt động chính xác với loại 'uint64_t'.

00:01:53.000 --> 00:02:00.000
Điều này thực sự hữu ích vì nó có nghĩa là tôi không phải viết hai phiên bản 'isOdd' hoạt động trên hai loại khác nhau.

00:02:00.000 --> 00:02:08.000
Bạn có thể sử dụng các mẫu C++ để viết các hàm chung như 'isOdd' và các lớp vùng chứa chung.

00:02:08.000 --> 00:02:12.000
Hãy cùng xem 'isOdd' có thể được sử dụng như thế nào.

00:02:12.000 --> 00:02:18.000
Chức năng này được kiểm tra với một số trường hợp kiểm tra mà tôi đã thêm vào tệp kiểm tra của mình.

00:02:18.000 --> 00:02:21.000
Thật không may, tôi đã mắc lỗi trong một trong những bài kiểm tra của mình.

00:02:21.000 --> 00:02:31.000
Trình biên dịch đã mắc lỗi, nhưng thay vì chỉ vào nơi tôi đã mắc lỗi, trình biên dịch hiển thị lỗi bên trong mẫu 'isOdd'.

00:02:31.000 --> 00:02:37.000
Có vẻ như tôi đã mắc lỗi đánh máy và viết ra '1.1' trong bài kiểm tra của mình thay vì '11'.

00:02:37.000 --> 00:02:44.000
Do đó, trình biên dịch tạo ra một chuyên ngành 'isOdd' có kiểu 'double'.

00:02:44.000 --> 00:02:55.000
Thật không may, tôi đã mất một thời gian để tìm ra lỗi đánh máy này vì Xcode đã không chỉ cho tôi vị trí cụ thể nơi 'isOdd' được gọi với loại không chính xác.

00:02:55.000 --> 00:03:00.000
Ngôn ngữ và trình biên dịch có thể giúp tôi tìm ra những lỗi như thế này nhanh hơn không?

00:03:00.000 --> 00:03:09.000
Chà, trong ví dụ hiện tại, các yêu cầu đối với loại nào được phép vào 'isOdd' không được chỉ định rõ ràng.

00:03:09.000 --> 00:03:16.000
Chỉ có một nhận xét tài liệu nói rằng tôi phải gọi isOdd bằng cách sử dụng các kiểu số nguyên.

00:03:16.000 --> 00:03:25.000
Trước C++20, các lập trình viên C++ không có cách tốt để chỉ định các yêu cầu mẫu khi viết mã C++ chung.

00:03:25.000 --> 00:03:35.000
Họ thường phải dùng đến nhận xét tài liệu, tên tham số cụ thể hoặc kiểm tra enable_if phức tạp khi chỉ định các yêu cầu mẫu.

00:03:35.000 --> 00:03:42.000
Chà, như bạn có thể đã nghe, C++ 20 giới thiệu một tính năng C++ mới được gọi là các khái niệm.

00:03:42.000 --> 00:03:49.000
Bạn có thể sử dụng các khái niệm để xác thực các yêu cầu mẫu trong mã C++ chung của mình.

00:03:49.000 --> 00:03:56.000
Chúng ta hãy xem các khái niệm có thể giúp tôi xác thực các loại có thể được chuyển thành 'isOdd' như thế nào.

00:03:56.000 --> 00:04:00.000
Đầu tiên, chúng ta hãy quay lại tuyên bố 'isOdd'.

00:04:00.000 --> 00:04:09.000
Hiện tại, tôi sử dụng từ khóa 'lớp' để chỉ định rằng loại 'T' được sử dụng bởi mẫu này có thể là bất kỳ loại nào.

00:04:09.000 --> 00:04:19.000
C++ 20 cho phép tôi sử dụng một khái niệm thay vì từ khóa 'lớp' để hạn chế tập hợp các loại mà mẫu này có thể được sử dụng.

00:04:19.000 --> 00:04:30.000
Tôi có thể sử dụng khái niệm 'không thể thiếu' do thư viện tiêu chuẩn cung cấp để hạn chế mẫu hàm 'isOdd' này chỉ đối với các loại số nguyên tích hợp sẵn.

00:04:30.000 --> 00:04:39.000
Trình biên dịch thậm chí sẽ không cố gắng chuyên môn hóa mẫu hàm này khi T không thỏa mãn khái niệm này.

00:04:39.000 --> 00:04:43.000
Khái niệm tích phân được khai báo trong thư viện chuẩn C++.

00:04:43.000 --> 00:04:48.000
Vì vậy, tôi cần bao gồm tiêu đề khái niệm để sử dụng nó trong mã của mình.

00:04:48.000 --> 00:05:04.000
Bây giờ tôi đã thêm một yêu cầu 'không thể thiếu' vào loại _T_ trong mẫu hàm 'isOdd', trình biên dịch có thể cung cấp chẩn đoán rõ ràng hơn nhiều chỉ trực tiếp vào nơi tôi đã mắc lỗi trong các bài kiểm tra của mình.

00:05:04.000 --> 00:05:11.000
Hóa ra, '1.1' là một cú đúp, và do đó, nó không thỏa mãn khái niệm 'không thể thiếu'.

00:05:11.000 --> 00:05:22.000
Trình biên dịch có thể giải thích điều này cho tôi với một thông báo lỗi rõ ràng giúp tôi tìm và sửa lỗi đánh máy này nhanh hơn nhiều so với trước đây.

00:05:22.000 --> 00:05:41.000
Ngoài việc giúp tôi sửa lỗi, việc hạn chế loại được chuyển thành 'isOdd' giúp tôi yên tâm rằng tất cả các trường hợp kiểm tra mà tôi có là 'isOdd' chỉ hoạt động với các loại số nguyên và chúng thực sự đang kiểm tra hành vi dự định của thuật toán.

00:05:41.000 --> 00:05:48.000
Bạn có thể sử dụng các khái niệm để khai báo mục đích sử dụng các loại mẫu của bạn.

00:05:48.000 --> 00:05:55.000
Trình biên dịch sau đó sẽ xác thực các yêu cầu về loại trước khi các mẫu của bạn được chuyên biệt hóa.

00:05:55.000 --> 00:06:04.000
Chúng ta hãy xem xét kỹ hơn cách các khái niệm có thể được sử dụng và những khái niệm cốt lõi nào được cung cấp bởi thư viện tiêu chuẩn C++.

00:06:04.000 --> 00:06:08.000
Thư viện tiêu chuẩn C++ cung cấp một thư viện khái niệm.

00:06:08.000 --> 00:06:16.000
Nó thực hiện một tập hợp các khái niệm ngôn ngữ cốt lõi mà bạn có thể sử dụng để xác thực hành vi cốt lõi của một loại.

00:06:16.000 --> 00:06:22.000
Bạn có thể truy cập thư viện này bằng cách bao gồm tiêu đề khái niệm trong mã của bạn.

00:06:22.000 --> 00:06:28.000
Tôi đã chỉ ra cách tôi có thể sử dụng khái niệm 'không thể thiếu' trong ví dụ trước đó của mình.

00:06:28.000 --> 00:06:33.000
Bây giờ, chúng ta hãy xem xét các khái niệm khác được cung cấp bởi thư viện này.

00:06:33.000 --> 00:06:42.000
Thư viện này cung cấp một số khái niệm ngôn ngữ cốt lõi hữu ích, như các khái niệm kiểm tra xem một loại có phải là một trong những loại tích hợp sẵn hay không.

00:06:42.000 --> 00:06:48.000
Ví dụ, khái niệm 'floating_point' được thỏa mãn bởi các loại tích hợp sẵn như 'float' và 'double'.

00:06:48.000 --> 00:06:54.000
'Static_assert' được hiển thị ở đây xác nhận rằng đây thực sự là trường hợp.

00:06:54.000 --> 00:07:05.000
Nó cũng cung cấp rất nhiều khái niệm cốt lõi hữu ích khác để kiểm tra xem các loại có thể xây dựng, có thể phá hủy, có thể chuyển đổi hay chúng giống với một loại khác.

00:07:05.000 --> 00:07:12.000
Ví dụ, khái niệm 'convertible_to' kiểm tra xem một loại có thể được chuyển đổi sang loại khác hay không.

00:07:12.000 --> 00:07:21.000
Và khái niệm 'move_constructible' được thỏa mãn bởi các loại có thể được xây dựng trực tiếp từ một giá trị khác cùng loại.

00:07:21.000 --> 00:07:30.000
Thư viện này cũng cung cấp một số khái niệm so sánh để kiểm tra xem các loại có thể được so sánh với các loại khác hay không.

00:07:30.000 --> 00:07:42.000
Ví dụ, khái niệm 'equality_comparable' được thỏa mãn bởi các loại có toán tử '==' hợp lệ hoạt động với giá trị cùng loại.

00:07:42.000 --> 00:07:49.000
Ngoài các khái niệm được đề cập trên trang trình bày này, thư viện này cung cấp nhiều khái niệm ngôn ngữ cốt lõi khác.

00:07:49.000 --> 00:07:54.000
Nó cũng cung cấp các khái niệm kiểm tra xem một loại có thể được di chuyển hoặc sao chép hay không.

00:07:54.000 --> 00:08:02.000
Thêm vào đó, nó cũng cung cấp các khái niệm kiểm tra xem một loại có phải là một đối tượng có thể gọi được hay không.

00:08:02.000 --> 00:08:12.000
Bây giờ chúng ta đã xem qua các khái niệm được cung cấp cho chúng ta bởi thư viện tiêu chuẩn C++, chúng ta hãy xem xét cách các khái niệm có thể được sử dụng để hạn chế các mẫu.

00:08:12.000 --> 00:08:22.000
Như tôi đã trình bày trước đó, bạn có thể sử dụng một khái niệm thay vì từ khóa lớp trong mẫu để hạn chế loại nào được phép cho mẫu này.

00:08:22.000 --> 00:08:31.000
Thêm vào đó, bạn có thể sử dụng mệnh đề 'yêu cầu' trong khai báo mẫu nếu bạn cần hạn chế một loại cho nhiều khái niệm.

00:08:31.000 --> 00:08:37.000
Chúng ta hãy xem xét một ví dụ hơi khác để xem nó có thể được thực hiện như thế nào.

00:08:37.000 --> 00:08:41.000
Ở đây tôi có mẫu hàm 'isDefaultValue'.

00:08:41.000 --> 00:08:47.000
Nó trả về true nếu giá trị đã cho bằng với giá trị mặc định của loại của nó.

00:08:47.000 --> 00:08:56.000
Tôi có thể sử dụng hai khái niệm từ thư viện tiêu chuẩn để kiểm tra xem loại này có hỗ trợ các hoạt động này hay không trước khi mẫu này được chuyên biệt hóa.

00:08:56.000 --> 00:09:03.000
Tôi sẽ thêm mệnh đề 'yêu cầu' để hạn chế tập hợp các loại được phép cho mẫu hàm này.

00:09:03.000 --> 00:09:08.000
Hãy xem những khái niệm nào từ thư viện khái niệm có thể giúp tôi xác thực loại ở đây.

00:09:08.000 --> 00:09:18.000
Đầu tiên, khái niệm 'bình đẳng_có thể so sánh' kiểm tra nếu _T_ có thể được so sánh với một giá trị khác cùng loại.

00:09:18.000 --> 00:09:26.000
Sau đó, khái niệm 'mặc định_có thể xây dựng' kiểm tra nếu _T_ là một loại có hàm tạo mặc định.

00:09:26.000 --> 00:09:32.000
Logic và toán tử giữa chúng hướng dẫn trình biên dịch xác thực cả hai khái niệm.

00:09:32.000 --> 00:09:39.000
Điều này đảm bảo rằng mẫu chức năng này sẽ chỉ chuyên biệt với các loại được hỗ trợ.

00:09:39.000 --> 00:09:43.000
Hãy xem lại những gì chúng ta đã học được cho đến nay về các khái niệm.

00:09:43.000 --> 00:09:48.000
Bạn nên sử dụng các khái niệm để hạn chế các loại được phép sử dụng trong các mẫu của mình.

00:09:48.000 --> 00:09:57.000
Trình biên dịch sau đó sẽ có thể hiển thị chẩn đoán rõ ràng hơn vì mẫu sẽ không phải chuyên biệt hóa nếu xảy ra lỗi loại.

00:09:57.000 --> 00:10:05.000
Bạn nên sử dụng lại các khái niệm từ thư viện khái niệm nếu bạn cần xác thực một số hành vi cốt lõi của một loại.

00:10:05.000 --> 00:10:12.000
Bạn nên thêm mệnh đề 'yêu cầu' vào các mẫu của mình khi bạn cần kiểm tra xem các loại có phù hợp với nhiều yêu cầu hay không.

00:10:12.000 --> 00:10:17.000
Bây giờ chúng ta đã thấy cách sử dụng các khái niệm trong các chương trình C++.

00:10:17.000 --> 00:10:24.000
C++ cho phép chúng tôi khai báo các khái niệm tùy chỉnh xác thực hành vi cụ thể của một loại.

00:10:24.000 --> 00:10:31.000
Chúng ta hãy xem cách tạo ra các khái niệm của riêng chúng ta để xác nhận hành vi loại cụ thể.

00:10:31.000 --> 00:10:41.000
Tuy nhiên, trước khi chúng ta làm điều đó, chúng ta cần xem xét cách xác định các yêu cầu hành vi phải được xác nhận bởi khái niệm mà chúng ta muốn khai báo.

00:10:41.000 --> 00:10:49.000
Tôi sẽ sử dụng một ví dụ mới để minh họa cách xác thực hành vi loại cụ thể bằng cách sử dụng các khái niệm.

00:10:49.000 --> 00:10:57.000
Giả sử tôi đang xây dựng một thư viện C++ có thể hiển thị các hình dạng hai chiều khác nhau cho một hình ảnh.

00:10:57.000 --> 00:11:00.000
Tôi muốn hỗ trợ các hình dạng khác nhau trong thư viện của mình.

00:11:00.000 --> 00:11:05.000
Tôi đang bắt đầu với một hình tròn, vì nó đơn giản nhất để kết xuất.

00:11:05.000 --> 00:11:12.000
Tôi sẽ sử dụng một lớp C++ để lưu trữ các thuộc tính của nó, như vị trí và bán kính.

00:11:12.000 --> 00:11:23.000
Để hiển thị vòng tròn, tôi sẽ sử dụng thuật toán kết xuất dựa trên hàm khoảng cách chạy trên mỗi pixel trong hình ảnh được hiển thị.

00:11:23.000 --> 00:11:30.000
Thuật toán này cần tính toán khoảng cách đến bề mặt của hình dạng để hiển thị nó.

00:11:30.000 --> 00:11:34.000
Phương thức 'getDistanceFrom' trong lớp Circle tính toán nó.

00:11:34.000 --> 00:11:42.000
Nó trả về một khoảng cách âm bên trong vòng tròn, và một khoảng cách dương bên ngoài vòng tròn.

00:11:42.000 --> 00:11:45.000
Ngoài vòng tròn, tôi muốn hiển thị các hình dạng khác.

00:11:45.000 --> 00:11:55.000
Ví dụ, bằng cách trừ đi hình học một hình tròn từ một hình tròn khác, tôi cũng có thể hiển thị một hình lưỡi liềm.

00:11:55.000 --> 00:12:00.000
Tôi sẽ đại diện cho các hình dạng như Crescent mà tôi cũng muốn kết xuất bằng cách sử dụng các lớp học.

00:12:00.000 --> 00:12:06.000
Mỗi lớp hình dạng mới bao gồm phương thức 'getDistanceFrom'.

00:12:06.000 --> 00:12:15.000
Sau khi tạo một số lớp hình dạng, bây giờ tôi muốn thử kết xuất các hình dạng này để xác minh việc thực hiện chúng.

00:12:15.000 --> 00:12:21.000
Tôi có một vài lựa chọn về cách tôi có thể tạo hàm kết xuất hoạt động với bất kỳ hình dạng nào.

00:12:21.000 --> 00:12:29.000
Tôi có thể tạo một hệ thống phân cấp lớp cho các hình dạng và sử dụng một phương pháp ảo để tính toán khoảng cách đến bề mặt của hình dạng.

00:12:29.000 --> 00:12:43.000
Tuy nhiên, tôi sẽ sử dụng mẫu hàm thay vì lý do hiệu suất, vì tôi muốn tránh chi phí cuộc gọi ảo vì hàm này sẽ được gọi hàng triệu lần trong quá trình kết xuất.

00:12:43.000 --> 00:12:47.000
Đây là lý do tại sao tôi tạo ra mẫu chức năng kết xuất này.

00:12:47.000 --> 00:12:55.000
Hàm computePixelColor nhận một giá trị hình dạng và kiểm tra xem điểm ảnh đã cho có nằm trong hình dạng hay không.

00:12:55.000 --> 00:12:59.000
Nếu nó ở bên trong, nó sẽ trả về một màu trắng trơn.

00:12:59.000 --> 00:13:05.000
Điều này bây giờ cho phép tôi xác minh rằng các hình dạng có thể được điền chính xác.

00:13:05.000 --> 00:13:14.000
Hàm này là một mẫu, làm cho nó hoạt động với bất kỳ loại hình dạng nào, có thể là hình tròn, hình lưỡi liềm hoặc bất kỳ loại phù hợp nào khác.

00:13:14.000 --> 00:13:22.000
Mặc dù một mẫu hoạt động tốt ở đây, tôi muốn sử dụng các khái niệm để hạn chế loại có thể được chuyển cho hàm này.

00:13:22.000 --> 00:13:32.000
Hạn chế loại được chuyển đến hàm này sẽ cho phép trình biên dịch tạo ra chẩn đoán rõ ràng hơn khi xảy ra sự không khớp kiểu.

00:13:32.000 --> 00:13:41.000
Thêm vào đó, việc hạn chế loại được truyền cho hàm này cũng sẽ cho phép tôi thêm các quá tải bổ sung của hàm này.

00:13:41.000 --> 00:13:46.000
Để hạn chế kiểu chữ, tôi sẽ tạo ra một khái niệm Hình dạng.

00:13:46.000 --> 00:13:57.000
Khái niệm này sẽ xác nhận hành vi của loại và sẽ chấp nhận các lớp như hình tròn, hình lưỡi liềm và bất kỳ lớp hình dạng nào khác mà tôi có thể muốn thêm vào trong tương lai.

00:13:57.000 --> 00:14:04.000
Để tạo ra một khái niệm như 'Hình dạng', trước tiên tôi cần xác định các yêu cầu phải được xác nhận bởi khái niệm này.

00:14:04.000 --> 00:14:07.000
Hãy xem điều này có thể được thực hiện như thế nào.

00:14:07.000 --> 00:14:11.000
Mẫu chức năng này sử dụng kiểu 'T' làm kiểu chung.

00:14:11.000 --> 00:14:16.000
Một đối số có tên 'hình dạng' của loại 'T' sau đó được chuyển đến hàm này.

00:14:16.000 --> 00:14:24.000
Đối số 'shape' sau đó được sử dụng bên trong hàm, khi tôi gọi phương thức 'getDistanceFrom' trên đó.

00:14:24.000 --> 00:14:35.000
Như bạn có thể thấy, đây là yêu cầu duy nhất tôi muốn xác thực trong khái niệm của mình, vì không có thao tác nào khác được thực hiện trên hình dạng trong chức năng này.

00:14:35.000 --> 00:14:41.000
Bạn có thể sử dụng biểu thức 'yêu cầu' để kiểm tra xem một loại có hoạt động theo một cách cụ thể hay không.

00:14:41.000 --> 00:14:46.000
Hãy xem cách tôi có thể sử dụng 'yêu cầu' để tạo ra khái niệm Hình dạng.

00:14:46.000 --> 00:14:53.000
Tôi cần cung cấp một tập hợp các biểu thức kiểm tra hành vi của một loại bên trong 'yêu cầu'.

00:14:53.000 --> 00:15:03.000
Tôi đã xác định cuộc gọi đến 'getDistanceFrom' là một yêu cầu duy nhất mà tôi cần kiểm tra, vì vậy bây giờ tôi có thể tiếp tục và tạo ra khái niệm 'Hình dạng'.

00:15:03.000 --> 00:15:07.000
Tôi đã tuyên bố khái niệm hình dạng bằng cách sử dụng từ khóa 'khái niệm'.

00:15:07.000 --> 00:15:13.000
Sau đó tôi đã thêm biểu thức 'yêu cầu' vào khái niệm này để xác thực loại.

00:15:13.000 --> 00:15:17.000
Tôi đã thêm một danh sách đối số vào biểu thức 'yêu cầu'.

00:15:17.000 --> 00:15:26.000
Danh sách đối số này cho phép tôi khai báo một giá trị 'hình dạng' của loại 'T' mà sau đó tôi sẽ kiểm tra bên trong 'yêu cầu'.

00:15:26.000 --> 00:15:31.000
Bạn có thể sử dụng danh sách đối số trong biểu thức yêu cầu để khai báo các giá trị thuộc bất kỳ loại nào.

00:15:31.000 --> 00:15:36.000
Sau đó bạn sẽ có thể sử dụng các giá trị này bên trong yêu cầu.

00:15:36.000 --> 00:15:44.000
Phần thân của biểu thức 'yêu cầu' chứa một tập hợp các yêu cầu phải được thông qua để khái niệm này được thỏa mãn.

00:15:44.000 --> 00:15:53.000
Khái niệm 'shape' chỉ có một yêu cầu biểu thức đơn giản để kiểm tra xem một cuộc gọi phương thức đến 'getDistanceFrom' có hợp lệ hay không.

00:15:53.000 --> 00:15:58.000
Biểu thức này sẽ không thực sự được thực thi trong chương trình.

00:15:58.000 --> 00:16:06.000
Nó chỉ cần thiết tại thời điểm biên dịch để xác thực hành vi của loại và nó sẽ bị loại bỏ sau khi xác thực.

00:16:06.000 --> 00:16:15.000
Bạn có thể sử dụng các yêu cầu biểu thức để xác thực hành vi của loại bằng cách kiểm tra xem một biểu thức cụ thể có được biên dịch hay không.

00:16:15.000 --> 00:16:23.000
Tuy nhiên, biểu thức cụ thể này vẫn chưa hoàn chỉnh, vì chúng tôi đang thiếu các đối số cho cuộc gọi phương thức 'getDistanceFrom'.

00:16:23.000 --> 00:16:33.000
Tôi biết rằng tôi muốn phương pháp này lấy hai giá trị của loại 'float', vì vậy tôi có thể sử dụng hai ký tự dấu phẩy động để hoàn thành biểu thức này.

00:16:33.000 --> 00:16:45.000
Tôi sẽ thêm một kiểm tra bổ sung để kiểm tra rằng phương thức 'getDistanceFrom' trả về một giá trị float, vì đó là những gì đang được giả định bởi mã chung của tôi.

00:16:45.000 --> 00:16:53.000
Tôi hiện đang sử dụng một yêu cầu biểu thức đơn giản để kiểm tra xem loại đó có phương thức 'getDistanceFrom' hay không.

00:16:53.000 --> 00:17:01.000
Tuy nhiên, tôi có thể sử dụng yêu cầu ghép thay vì yêu cầu biểu thức để kiểm tra xem nó có trả về giá trị float hay không.

00:17:01.000 --> 00:17:05.000
Toán tử mũi tên có thể tuân theo yêu cầu ghép.

00:17:05.000 --> 00:17:19.000
Toán tử mũi tên mong đợi một ràng buộc ở phía bên tay phải của nó, vì vậy đây là nơi tôi có thể sử dụng khái niệm thư viện tiêu chuẩn như 'giống_as' để xác thực rằng lệnh gọi phương thức 'getDistanceFrom' trả về giá trị float.

00:17:19.000 --> 00:17:23.000
Bây giờ khái niệm này có vẻ đã sẵn sàng đối với tôi.

00:17:23.000 --> 00:17:30.000
Tôi có thể tiếp tục và sử dụng nó để hạn chế các loại có thể được chuyển đến chức năng 'computePixelColor' của tôi.

00:17:30.000 --> 00:17:38.000
Bây giờ chức năng 'computePixelColor' chung của tôi sẽ chỉ hoạt động với các loại đáp ứng khái niệm 'Hình dạng'.

00:17:38.000 --> 00:17:52.000
Điều này có nghĩa là các lớp như Circle và Crescent sẽ được hiển thị bằng cách sử dụng chức năng 'computePixelColor' chung cụ thể này, vì cả hai loại này đều đáp ứng khái niệm 'Shape'.

00:17:52.000 --> 00:18:01.000
Sau khi nhìn thấy các hình dạng đơn giản được hiển thị, tôi muốn tạo một phiên bản khác của 'computePixelColor' để thêm màu sắc cho một số hình dạng của tôi.

00:18:01.000 --> 00:18:07.000
Giả sử tôi muốn thêm một lớp GradientCircle đầy màu sắc vào thư viện hình dạng của mình.

00:18:07.000 --> 00:18:13.000
Bây giờ tôi cần một chức năng mới để tính toán màu điểm ảnh trong hình ảnh.

00:18:13.000 --> 00:18:20.000
C++20 cho phép tôi tạo ra nhiều biến thể của mẫu hàm 'computePixelColor'.

00:18:20.000 --> 00:18:24.000
Mỗi biến thể phải được hạn chế bằng cách sử dụng các khái niệm khác nhau.

00:18:24.000 --> 00:18:31.000
Tôi sẽ tạo ra một khái niệm GradientShape mới sẽ được thỏa mãn bởi các lớp học như GradientCircle.

00:18:31.000 --> 00:18:40.000
Khái niệm này sau đó sẽ hạn chế một biến thể mới của 'computePixelColor' chỉ hoạt động với các hình dạng có độ dốc.

00:18:40.000 --> 00:18:46.000
Khái niệm này được thực hiện bằng cách sử dụng biểu thức 'yêu cầu', giống như khái niệm Hình dạng.

00:18:46.000 --> 00:18:56.000
Tuy nhiên, vì tôi muốn GradientShape cũng đáp ứng khái niệm Hình dạng ban đầu, tôi đưa nó vào yêu cầu đầu tiên trong khái niệm mới.

00:18:56.000 --> 00:19:10.000
Điều này đảm bảo rằng một lớp thỏa mãn khái niệm GradientShape cũng thỏa mãn khái niệm Shape, có nghĩa là tôi vẫn có thể gọi phương thức 'getDistanceFrom' cho các giá trị của lớp đó.

00:19:10.000 --> 00:19:23.000
Sau đó, tôi sử dụng logic và toán tử và biểu thức 'yêu cầu' để đảm bảo rằng khái niệm GradientShape chỉ có thể được thỏa mãn bởi các lớp có phương thức 'getGradientColor'.

00:19:23.000 --> 00:19:31.000
Bây giờ tôi đã tạo ra khái niệm GradientShape, tôi có thể tiếp tục và tạo ra một biến thể mới của 'computePixelColor'.

00:19:31.000 --> 00:19:42.000
Mẫu hàm này chỉ hoạt động với các lớp hình dạng có độ dốc, như lớp GradientCircle, vì nó bị hạn chế bởi khái niệm GradientShape.

00:19:42.000 --> 00:19:49.000
Bây giờ tôi đã có tất cả các mảnh tại chỗ, tôi có thể tiếp tục và thử kết xuất một vòng tròn với độ dốc.

00:19:49.000 --> 00:19:52.000
Ở đây tôi đang kết xuất một GradientCircle.

00:19:52.000 --> 00:20:00.000
Hãy xem trình biên dịch sẽ chọn quá tải nào của 'computePixelColor' bên trong hàm 'kết xuất'.

00:20:00.000 --> 00:20:15.000
Mặc dù GradientCircle có thể được sử dụng một cách an toàn với cả hai biến thể của computePixelColor, trình biên dịch chọn quá tải bị hạn chế với khái niệm GradientShape vì nó cụ thể hơn so với quá tải đầu tiên.

00:20:15.000 --> 00:20:24.000
Bởi vì trình biên dịch chọn quá tải phù hợp nhất của 'computePixelColor', tôi có thể thấy vòng tròn gradient tuyệt đẹp này được hiển thị khi tôi kiểm tra thư viện của mình.

00:20:24.000 --> 00:20:26.000
Thật tuyệt vời!

00:20:26.000 --> 00:20:32.000
Bây giờ chúng ta hãy xem qua những gì chúng ta đã học được về việc tạo ra các khái niệm.

00:20:32.000 --> 00:20:40.000
Bạn có thể tạo các khái niệm bằng cách xác định các yêu cầu hành vi trong mã chung hiện có của bạn.

00:20:40.000 --> 00:20:46.000
Bạn nên sử dụng biểu thức yêu cầu để tạo ra các khái niệm để xác thực hành vi của các loại.

00:20:46.000 --> 00:20:55.000
Bạn cũng có thể sử dụng các khái niệm để tạo ra các biến thể cụ thể hơn của các hàm và lớp chung.

00:20:55.000 --> 00:21:00.000
Bây giờ chúng tôi đã thấy cách nâng cao mã C++ chung của bạn với các khái niệm.

00:21:00.000 --> 00:21:09.000
Ngoài các khái niệm hỗ trợ, Xcode 14 cũng đã cải thiện hỗ trợ cho các tính năng C++20 khác.

00:21:09.000 --> 00:21:19.000
Cụ thể hơn, tôi muốn nhấn mạnh sự hỗ trợ được cải thiện cho việc đánh giá mã C++ thời gian biên dịch trong Xcode 14.

00:21:19.000 --> 00:21:28.000
Đánh giá mã thời gian biên dịch rất hữu ích vì nó có thể giảm chi phí khởi tạo cho các biến trong mã C++ của bạn.

00:21:28.000 --> 00:21:38.000
Điều này có thể giúp giảm thời gian khởi chạy ứng dụng của bạn nếu ứng dụng của bạn có nhiều mã C++ phụ thuộc vào chuỗi khởi tạo phức tạp.

00:21:38.000 --> 00:21:47.000
Thêm vào đó, đánh giá mã thời gian biên dịch có thể giúp bạn xác thực các hằng số yêu cầu xác thực tại thời điểm biên dịch.

00:21:47.000 --> 00:21:52.000
Điều này có thể giúp bạn phát hiện lỗi trước khi mã của bạn chạy.

00:21:52.000 --> 00:21:59.000
Hãy xem một ví dụ để xem cách tôi có thể sử dụng đánh giá mã thời gian biên dịch trong C++.

00:21:59.000 --> 00:22:05.000
Ở đây tôi có một đoạn mã khởi tạo bảng màu trong thư viện kết xuất hình dạng của tôi.

00:22:05.000 --> 00:22:11.000
Thư viện này sau đó được sử dụng trong một ứng dụng iOS hiển thị các hình dạng cho màn hình.

00:22:11.000 --> 00:22:18.000
Mỗi màu trong bảng màu được khởi tạo bằng cách phân tích cú pháp một chuỗi theo nghĩa đen với mã hex HTML của màu.

00:22:18.000 --> 00:22:26.000
Hiện tại, hàm 'fromHexCode' cần phân tích cú pháp ba ký tự chuỗi trong quá trình khởi tạo mảng.

00:22:26.000 --> 00:22:36.000
Các hoạt động khởi tạo liên tục phức tạp như thế này có thể có tác động có thể đo lường được đến thời gian khởi chạy ứng dụng của tôi nếu tôi có nhiều trong số chúng.

00:22:36.000 --> 00:22:44.000
Thay vào đó, tôi có thể sử dụng đánh giá mã thời gian biên dịch để đảm bảo rằng mảng này được khởi tạo với các giá trị màu không đổi.

00:22:44.000 --> 00:22:47.000
Hãy để tôi chỉ cho bạn điều này có thể được thực hiện.

00:22:47.000 --> 00:22:53.000
Từ khóa 'constexpr' cho phép đánh giá mã thời gian biên dịch trong C++.

00:22:53.000 --> 00:23:02.000
Tôi phải thêm nó ở một vài nơi trong ví dụ của mình để đảm bảo rằng bảng màu là một mảng màu không đổi.

00:23:02.000 --> 00:23:07.000
Đầu tiên, tôi cần thêm từ khóa 'constexpr' vào hàm 'fromHexCode'.

00:23:07.000 --> 00:23:16.000
Trình biên dịch bây giờ sẽ có thể thực thi mã trong hàm này tại thời điểm biên dịch khi nó được sử dụng trong chuỗi khởi tạo thời gian biên dịch.

00:23:16.000 --> 00:23:23.000
Bạn nên làm cho các hàm C++ của mình 'constexpr' khi bạn muốn chúng có thể đánh giá được tại thời điểm biên dịch.

00:23:23.000 --> 00:23:34.000
Trình biên dịch sẽ cho bạn biết nếu mã trong hàm như vậy không thể được đánh giá tại thời điểm biên dịch bằng cách hiển thị lỗi khi bạn sử dụng nó trong chuỗi khởi tạo 'constexpr'.

00:23:34.000 --> 00:23:42.000
Tuy nhiên, bạn cũng có thể kiểm tra một hàm trước khi thêm 'constexpr' để xem liệu nó có thể được đánh giá tại thời điểm biên dịch hay không.

00:23:42.000 --> 00:23:51.000
Chúng ta hãy xem qua fromHexCode để xem cách kiểm tra xem một hàm như thế này có thể là ứng cử viên tốt để biên dịch đánh giá mã thời gian hay không.

00:23:51.000 --> 00:24:02.000
Hàm này sử dụng một số cấu trúc ngôn ngữ như câu lệnh if và các phép toán nguyên thủy như toán tử so sánh và toán tử số học.

00:24:02.000 --> 00:24:07.000
Tất cả các hoạt động này có thể được đánh giá tại thời điểm biên dịch.

00:24:07.000 --> 00:24:13.000
Ngoài ra, hàm này thực hiện một số lệnh gọi đến một hàm khác; hexToInt.

00:24:13.000 --> 00:24:22.000
Tôi đã chú thích hàm hexToInt với 'constexpr', vì vậy các cuộc gọi đến hàm này có thể được đánh giá tại thời điểm biên dịch.

00:24:22.000 --> 00:24:34.000
Nhìn chung, có vẻ như fromHexCode chứa mã mà trình biên dịch có thể đánh giá tại thời điểm biên dịch, vì vậy tôi nghĩ sẽ an toàn để tiến hành và sử dụng nó trong trình tự khởi tạo thời gian biên dịch.

00:24:34.000 --> 00:24:45.000
Sau khi đảm bảo rằng fromHexCode có thể được đánh giá tại thời điểm biên dịch, sau đó tôi cần thêm từ khóa 'constexpr' vào khai báo biến 'colorPalette'.

00:24:45.000 --> 00:24:54.000
Trình biên dịch hiện đảm bảo rằng nó sẽ đánh giá toàn bộ chuỗi khởi tạo cho mảng này tại thời điểm biên dịch.

00:24:54.000 --> 00:25:01.000
Cụ thể hơn, trình biên dịch sẽ đánh giá từng cuộc gọi đến hàm fromHexCode.

00:25:01.000 --> 00:25:09.000
Đánh giá sẽ tạo ra một giá trị màu không đổi sẽ thay thế cuộc gọi ban đầu đến hàm trong trình khởi tạo bảng màu.

00:25:09.000 --> 00:25:24.000
Vì tất cả các cuộc gọi đến fromHexCode hiện được thay thế bằng các giá trị màu không đổi, biến 'colorPalette' hiện được đảm bảo được khởi tạo bởi một mảng theo nghĩa đen chứa các giá trị màu không đổi.

00:25:24.000 --> 00:25:33.000
Điều này có nghĩa là bây giờ ứng dụng của tôi không phải trả thêm chi phí cho việc phân tích các giá trị màu khi bảng màu này được khởi tạo.

00:25:33.000 --> 00:25:43.000
Điều này rất tốt cho thời gian khởi chạy ứng dụng của tôi, vì nó làm giảm khối lượng công việc mà thư viện C++ bên trong ứng dụng này phải làm khi khởi động.

00:25:43.000 --> 00:25:51.000
Bạn nên làm cho các biến C++ của mình 'constexpr' khi bạn muốn đảm bảo rằng chúng được khởi tạo với các giá trị không đổi.

00:25:51.000 --> 00:25:59.000
Xcode 14 đã thực sự cải thiện đáng kể hỗ trợ thư viện tiêu chuẩn của nó để đánh giá thời gian biên dịch.

00:25:59.000 --> 00:26:10.000
Năm nay chúng tôi đã thêm hỗ trợ 'constexpr' vào một số loại thư viện và thuật toán tiêu chuẩn khác nhau, hiện có thể được sử dụng trong quá trình đánh giá mã thời gian biên dịch.

00:26:10.000 --> 00:26:17.000
Thêm vào đó, Xcode 14 đã cải thiện đáng kể hỗ trợ tiêu chuẩn C++20 của nó.

00:26:17.000 --> 00:26:23.000
Tất cả các tính năng được hiển thị ở đây hiện có thể được sử dụng ở chế độ C++ 20.

00:26:23.000 --> 00:26:29.000
Bạn nên chuyển sang chế độ C++ 20 ngay hôm nay nếu bạn chưa làm như vậy.

00:26:29.000 --> 00:26:37.000
Bạn có thể sử dụng cài đặt "Phương ngữ ngôn ngữ C++" trong dự án Xcode của mình để nâng cấp lên C++ 20.

00:26:37.000 --> 00:26:43.000
Chuyển sang C++20 sẽ cho phép bạn sử dụng các tính năng như khái niệm trong mã của mình.

00:26:43.000 --> 00:26:53.000
C++20 không yêu cầu mục tiêu triển khai tối thiểu, vì vậy bạn vẫn có thể gửi mã của mình cho cùng một phiên bản hệ điều hành mà bạn hiện đang nhắm mục tiêu.

00:26:53.000 --> 00:26:56.000
Dùng thử C++20 ngay hôm nay.

00:26:56.000 --> 00:26:57.000
Cảm ơn bạn!

00:26:57.000 --> 23:59:59.000
Tận hưởng phần còn lại của hội nghị nhà phát triển.

