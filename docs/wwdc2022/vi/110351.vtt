WEBVTT

00:00:00.000 --> 00:00:03.000
♪ Nhạc hip-hop nhạc cụ êm dịu ♪

00:00:03.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:10.000
Xin chào.

00:00:10.000 --> 00:00:17.000
Tôi là Doug từ nhóm Swift, và tôi ở đây để nói về cách tiếp cận của Swift Concurrency để loại bỏ các cuộc đua dữ liệu.

00:00:17.000 --> 00:00:23.000
Chúng tôi đã giới thiệu Swift Concurrency như một tập hợp các tính năng ngôn ngữ giúp viết các chương trình đồng thời dễ dàng hơn.

00:00:23.000 --> 00:00:32.000
Đối với cơ chế của các tính năng ngôn ngữ riêng lẻ này, chúng tôi giới thiệu bạn đến các cuộc nói chuyện WWDC 2021 bao gồm từng tính năng.

00:00:32.000 --> 00:00:42.000
Bài nói chuyện này có một cái nhìn khác, toàn diện hơn về Swift Concurrency như một cách cấu trúc chương trình của bạn để sử dụng hiệu quả tính đồng thời mà không giới thiệu các cuộc đua dữ liệu.

00:00:42.000 --> 00:00:50.000
Nhưng để làm như vậy, chúng tôi cần một sự tương tự tuyệt vời, vì vậy chúng tôi mời bạn đi thuyền với chúng tôi trên biển đồng thời trên biển đồng thời.

00:00:50.000 --> 00:01:01.000
Biển đồng thời là không thể đoán trước, với nhiều thứ đang diễn ra cùng một lúc, nhưng với bạn ở vị trí lãnh đạo và Swift giúp bạn điều hướng vùng biển, nó có thể tạo ra những điều tuyệt vời.

00:01:01.000 --> 00:01:02.000
Hãy đi sâu vào!

00:01:02.000 --> 00:01:14.000
Chúng ta sẽ bắt đầu bằng cách nói về sự cô lập, đó là một trong những ý tưởng chính của mô hình đồng thời của Swift, đảm bảo rằng dữ liệu không được chia sẻ theo cách có thể giới thiệu các cuộc đua dữ liệu.

00:01:14.000 --> 00:01:17.000
Hãy bắt đầu với việc cô lập nhiệm vụ.

00:01:17.000 --> 00:01:22.000
Trong biển đồng thời của chúng ta, các nhiệm vụ được đại diện bởi những chiếc thuyền.

00:01:22.000 --> 00:01:29.000
Thuyền là công nhân chính của chúng tôi - họ có một công việc phải làm, họ thực hiện tuần tự từ đầu đến cuối.

00:01:29.000 --> 00:01:37.000
Chúng không đồng bộ và công việc của chúng có thể bị đình chỉ bất kỳ số lần nào tại các hoạt động "chờ đợi" trong mã.

00:01:37.000 --> 00:01:48.000
Cuối cùng, chúng khép kín: mỗi nhiệm vụ có tài nguyên riêng, vì vậy nó có thể tự vận hành, độc lập với tất cả các tàu thuyền khác trên biển.

00:01:48.000 --> 00:01:59.000
Nếu thuyền của chúng tôi hoàn toàn độc lập, chúng tôi có sự đồng thời mà không có các cuộc đua dữ liệu, nhưng nó không hữu ích lắm nếu không có một số cách để giao tiếp.

00:01:59.000 --> 00:02:01.000
Hãy thêm một số giao tiếp!

00:02:01.000 --> 00:02:07.000
Ví dụ, một chiếc thuyền có thể có một quả dứa mà nó muốn chia sẻ với một chiếc thuyền khác.

00:02:07.000 --> 00:02:13.000
Vì vậy, những chiếc thuyền gặp nhau trên biển khơi, và chúng tôi chuyển dứa từ thuyền này sang thuyền khác.

00:02:13.000 --> 00:02:22.000
Bây giờ, đây là nơi mà sự tương tự vật lý bị phá vỡ một chút, bởi vì quả dứa này không phải là một vật phẩm vật lý di chuyển từ thuyền này sang thuyền khác.

00:02:22.000 --> 00:02:29.000
Đó là dữ liệu và trong Swift, chúng tôi có một vài cách khác nhau mà chúng tôi có thể biểu diễn dữ liệu đó.

00:02:29.000 --> 00:02:31.000
Chúng ta định nghĩa loại dứa của mình như thế nào?

00:02:31.000 --> 00:02:39.000
Chúng tôi thích các loại giá trị trong Swift, vì vậy hãy biến dứa thành một cấu trúc được xác định bởi trọng lượng và độ chín của nó.

00:02:39.000 --> 00:02:41.000
Hãy xem cái này hoạt động như thế nào.

00:02:41.000 --> 00:02:52.000
Khi những chiếc thuyền gặp nhau trên biển khơi, chúng tôi thực sự đang chuyển một bản sao của ví dụ dứa từ thuyền này sang thuyền khác, và mỗi thuyền biến mất với bản sao riêng của nó.

00:02:52.000 --> 00:03:01.000
Nếu bạn biến đổi các bản sao, chẳng hạn như bằng cách gọi các phương thức slice() và ripen(), nó sẽ không có bất kỳ ảnh hưởng nào đến cái kia.

00:03:01.000 --> 00:03:09.000
Swift luôn ưu tiên các loại giá trị cho chính xác lý do này - đột biến chỉ có tác động cục bộ.

00:03:09.000 --> 00:03:14.000
Nguyên tắc đó giúp các loại giá trị duy trì sự cô lập.

00:03:14.000 --> 00:03:18.000
Bây giờ, hãy mở rộng mô hình dữ liệu của chúng ta một chút và thêm gà!

00:03:18.000 --> 00:03:26.000
Không giống như dứa, loại chỉ tốt để ăn, gà là những sinh vật xinh đẹp với tính cách độc đáo của riêng chúng.

00:03:26.000 --> 00:03:30.000
Vì vậy, chúng tôi sẽ mô hình hóa chúng với một lớp học, như thế này.

00:03:30.000 --> 00:03:34.000
Hãy để những người đi biển gan dạ của chúng ta đổi lấy một con gà.

00:03:34.000 --> 00:03:47.000
Khi thuyền của chúng tôi gặp nhau, chúng tôi chia sẻ con gà, ngoại trừ việc sao chép một loại tham chiếu như gà không cung cấp cho bạn một bản sao đầy đủ khác của con gà, nó cung cấp cho bạn một tham chiếu đến đối tượng cụ thể đó.

00:03:47.000 --> 00:04:00.000
Vì vậy, một khi thuyền của chúng tôi đã đi theo con đường riêng của chúng, chúng tôi có thể thấy rằng chúng tôi có một vấn đề: cả hai thuyền đang thực hiện công việc của chúng đồng thời, nhưng chúng không độc lập vì cả hai đều tham chiếu đến cùng một vật thể gà.

00:04:00.000 --> 00:04:12.000
Dữ liệu có thể thay đổi được chia sẻ đó dễ bị các cuộc đua dữ liệu, chẳng hạn như khi một chiếc thuyền đang cố gắng cho gà ăn và chiếc kia muốn chơi với nó, dẫn đến một con gà rất bối rối.

00:04:12.000 --> 00:04:18.000
Chúng ta cần một cách để biết rằng việc chia sẻ dứa giữa những chiếc thuyền là an toàn, nhưng không phải gà.

00:04:18.000 --> 00:04:27.000
Và sau đó chúng tôi cần một số kiểm tra tại chỗ trong trình biên dịch Swift để đảm bảo rằng gà không vô tình được chuyển từ thuyền này sang thuyền khác.

00:04:27.000 --> 00:04:33.000
Giao thức Swift là một cách tuyệt vời để phân loại các loại để bạn có thể suy luận về hành vi của chúng.

00:04:33.000 --> 00:04:43.000
Giao thức Sendable được sử dụng để mô tả các loại có thể được chia sẻ một cách an toàn trên các miền cách ly khác nhau mà không tạo ra các cuộc đua dữ liệu.

00:04:43.000 --> 00:04:47.000
Một loại có thể được thực hiện Có thể gửi được bằng cách viết một sự phù hợp.

00:04:47.000 --> 00:04:58.000
Cấu trúc Pineapple phù hợp với Sendable vì nó là một loại giá trị, nhưng lớp Chicken thì không vì nó là một loại tham chiếu không đồng bộ.

00:04:58.000 --> 00:05:06.000
Mô hình hóa Sendable như một giao thức cho phép chúng tôi mô tả những nơi dữ liệu sẽ được chia sẻ trên các miền cách ly.

00:05:06.000 --> 00:05:15.000
Ví dụ, khi một nhiệm vụ trả về một giá trị, giá trị này được cung cấp cho bất kỳ nhiệm vụ nào đang chờ giá trị đó.

00:05:15.000 --> 00:05:25.000
Ở đây, chúng tôi đang cố gắng trả lại một con Gà từ Nhiệm vụ của mình và chúng tôi gặp lỗi nói rằng điều này không an toàn vì Gà không thể gửi được.

00:05:25.000 --> 00:05:37.000
Ràng buộc Sendable thực tế xuất phát từ định nghĩa của chính cấu trúc Nhiệm vụ, chỉ định rằng loại kết quả của một Nhiệm vụ, được gọi là Thành công, phải phù hợp với giao thức Có thể gửi được.

00:05:37.000 --> 00:05:45.000
Bạn nên sử dụng các ràng buộc Sendable nơi bạn có các tham số chung có giá trị sẽ được truyền qua các miền cách ly khác nhau.

00:05:45.000 --> 00:05:50.000
Bây giờ, hãy xem lại ý tưởng chia sẻ dữ liệu giữa các tàu thuyền.

00:05:50.000 --> 00:06:00.000
Khi hai chiếc thuyền gặp nhau trên biển cả và muốn chia sẻ dữ liệu, chúng tôi cần ai đó kiểm tra nhất quán tất cả hàng hóa để đảm bảo chúng an toàn để chia sẻ.

00:06:00.000 --> 00:06:09.000
Đó là vai trò của thanh tra hải quan thân thiện của chúng tôi - được thực hiện ở đây bởi trình biên dịch Swift - để đảm bảo rằng chỉ các loại Sendable mới được trao đổi.

00:06:09.000 --> 00:06:14.000
Dứa vẫn ổn và có thể được đổi tự do, bởi vì nó có thể gửi được.

00:06:14.000 --> 00:06:23.000
Tuy nhiên, gà không thể đổi được, và thanh tra hải quan thân thiện của chúng tôi sẽ ngăn chúng tôi phạm sai lầm đó.

00:06:23.000 --> 00:06:28.000
Trình biên dịch có liên quan đến việc kiểm tra tính chính xác của Sendable tại nhiều điểm khác nhau.

00:06:28.000 --> 00:06:35.000
Các loại có thể gửi phải chính xác bằng cách xây dựng và không thể cho phép bất kỳ dữ liệu được chia sẻ nào được nhập lậu qua chúng.

00:06:35.000 --> 00:06:44.000
Enums và cấu trúc thường xác định các loại giá trị, sao chép tất cả dữ liệu thể hiện của chúng cùng với chúng để tạo ra các giá trị độc lập.

00:06:44.000 --> 00:06:51.000
Do đó, chúng có thể được gửi miễn là tất cả dữ liệu phiên bản của chúng cũng có thể gửi được.

00:06:51.000 --> 00:06:57.000
Sendable có thể được truyền bá thông qua các bộ sưu tập và các loại chung khác bằng cách sử dụng sự phù hợp có điều kiện.

00:06:57.000 --> 00:07:04.000
Một mảng các loại Có thể gửi được là Có thể gửi được, vì vậy một Thùng đầy dứa cũng có thể gửi được.

00:07:04.000 --> 00:07:15.000
Tất cả các tuân thủ Sendable này thậm chí có thể được trình biên dịch Swift suy ra cho các loại không công khai, vì vậy Ripeness, Pineapple và Crate đều có thể gửi ngầm.

00:07:15.000 --> 00:07:19.000
Nhưng giả sử chúng ta tạo ra một cái chuồng để nuôi đàn gà của chúng ta.

00:07:19.000 --> 00:07:29.000
Loại này không thể được đánh dấu là Có thể gửi được, bởi vì nó chứa trạng thái không thể gửi được: Gà không thể gửi được, vì vậy mảng gà không thể gửi được.

00:07:29.000 --> 00:07:35.000
Chúng tôi sẽ nhận được thông báo lỗi từ trình biên dịch của chúng tôi để chỉ ra rằng loại này không thể được chia sẻ một cách an toàn.

00:07:35.000 --> 00:07:46.000
Các lớp là các loại tham chiếu, vì vậy chúng chỉ có thể được thực hiện Có thể gửi được trong những trường hợp rất hẹp, chẳng hạn như khi lớp cuối cùng chỉ có bộ nhớ bất biến.

00:07:46.000 --> 00:07:53.000
Nỗ lực của chúng tôi để làm cho lớp Chicken Sendable sẽ gây ra lỗi vì nó chứa trạng thái có thể thay đổi.

00:07:53.000 --> 00:08:01.000
Bây giờ, có thể triển khai các loại tham chiếu thực hiện đồng bộ hóa nội bộ của riêng chúng, ví dụ, bằng cách sử dụng khóa một cách nhất quán.

00:08:01.000 --> 00:08:07.000
Những loại này có thể gửi được về mặt khái niệm, nhưng không có cách nào để Swift lý luận về điều đó.

00:08:07.000 --> 00:08:12.000
Sử dụng Sendable không được chọn để vô hiệu hóa việc kiểm tra của trình biên dịch.

00:08:12.000 --> 00:08:21.000
Hãy cẩn thận với điều này, bởi vì tình trạng có thể thay đổi buôn lậu thông qua @unchecked Sendable làm suy yếu đảm bảo an toàn cuộc đua dữ liệu mà Swift đang cung cấp.

00:08:21.000 --> 00:08:30.000
Tạo nhiệm vụ liên quan đến việc thực hiện việc đóng cửa trong một nhiệm vụ mới, độc lập, như gửi một chiếc thuyền chèo từ thuyền của bạn.

00:08:30.000 --> 00:08:41.000
Khi chúng tôi làm điều này, chúng tôi có thể nắm bắt các giá trị từ nhiệm vụ ban đầu và chuyển chúng vào nhiệm vụ mới, vì vậy chúng tôi cần kiểm tra Sendable để đảm bảo chúng tôi không giới thiệu các cuộc đua dữ liệu.

00:08:41.000 --> 00:08:51.000
Nếu chúng tôi cố gắng chia sẻ một loại không thể gửi qua ranh giới này, trình biên dịch Swift sẽ bảo vệ chúng tôi, tạo ra một thông báo lỗi như thế này.

00:08:51.000 --> 00:08:53.000
Đây không phải là phép thuật để tạo ra nhiệm vụ.

00:08:53.000 --> 00:09:01.000
Việc đóng cửa đang được suy ra là một sự đóng cửa có thể gửi được, có thể được viết rõ ràng với At-Sendable.

00:09:01.000 --> 00:09:07.000
Đóng có thể gửi là các giá trị của loại hàm có thể gửi.

00:09:07.000 --> 00:09:13.000
At-Sendable có thể được viết trên một loại hàm để chỉ ra rằng loại hàm phù hợp với giao thức Sendable.

00:09:13.000 --> 00:09:23.000
Điều đó ngụ ý rằng các giá trị của loại hàm đó có thể được chuyển đến các miền cách ly khác và được gọi ở đó mà không cần giới thiệu các cuộc đua dữ liệu ở trạng thái bị bắt của chúng.

00:09:23.000 --> 00:09:31.000
Thông thường, các loại hàm không thể phù hợp với các giao thức, nhưng Sendable là đặc biệt vì trình biên dịch xác thực các yêu cầu ngữ nghĩa cho nó.

00:09:31.000 --> 00:09:41.000
Có sự hỗ trợ tương tự cho các bộ các loại Sendable phù hợp với giao thức Sendable, cho phép Sendable được sử dụng trong toàn bộ ngôn ngữ.

00:09:41.000 --> 00:09:48.000
Hệ thống mà chúng tôi đã mô tả có nhiều nhiệm vụ thực hiện đồng thời bị cô lập với nhau.

00:09:48.000 --> 00:09:59.000
Giao thức Sendable mô tả các loại có thể được chia sẻ một cách an toàn giữa các tác vụ và trình biên dịch Swift kiểm tra sự phù hợp của Sendable ở mọi cấp độ để duy trì sự cô lập của các tác vụ.

00:09:59.000 --> 00:10:07.000
Tuy nhiên, nếu không có bất kỳ khái niệm nào về dữ liệu có thể thay đổi được chia sẻ ở bất kỳ đâu, thật khó để các nhiệm vụ phối hợp một cách có ý nghĩa.

00:10:07.000 --> 00:10:13.000
Vì vậy, chúng tôi cần một số cách để chia sẻ dữ liệu giữa các nhiệm vụ của chúng tôi mà không giới thiệu lại các cuộc đua dữ liệu.

00:10:13.000 --> 00:10:16.000
Đây là nơi các diễn viên bước vào.

00:10:16.000 --> 00:10:26.000
Các diễn viên cung cấp một cách để cô lập trạng thái có thể được truy cập bởi các nhiệm vụ khác nhau, nhưng theo cách phối hợp để loại bỏ các cuộc đua dữ liệu.

00:10:26.000 --> 00:10:30.000
Diễn viên là những hòn đảo trong biển đồng thời của chúng ta.

00:10:30.000 --> 00:10:38.000
Giống như những chiếc thuyền, mỗi hòn đảo đều khép kín, với trạng thái riêng biệt lập với mọi thứ khác trên biển.

00:10:38.000 --> 00:10:43.000
Để truy cập trạng thái đó, mã của bạn cần phải chạy trên đảo.

00:10:43.000 --> 00:10:47.000
Ví dụ, phương pháp advanceTime bị cô lập với hòn đảo này.

00:10:47.000 --> 00:10:51.000
Nó sống trên đảo và có quyền truy cập vào tất cả các tiểu bang của hòn đảo.

00:10:51.000 --> 00:10:56.000
Để thực sự chạy mã trên một hòn đảo, bạn cần một chiếc thuyền.

00:10:56.000 --> 00:11:02.000
Một chiếc thuyền có thể ghé thăm hòn đảo để chạy mã trên đảo, tại thời điểm đó nó có quyền truy cập vào tiểu bang đó.

00:11:02.000 --> 00:11:11.000
Chỉ có một chiếc thuyền có thể đến thăm hòn đảo để chạy mã tại một thời điểm, điều này đảm bảo rằng không có quyền truy cập đồng thời vào tiểu bang của hòn đảo.

00:11:11.000 --> 00:11:16.000
Nếu những chiếc thuyền khác xuất hiện, họ phải đợi đến lượt mình để đến thăm hòn đảo.

00:11:16.000 --> 00:11:27.000
Và bởi vì có thể mất một thời gian dài trước khi một chiếc thuyền nhất định có cơ hội đến thăm hòn đảo, việc tham gia vào một diễn viên là một điểm đình chỉ tiềm năng được đánh dấu bằng từ khóa "chờ đợi".

00:11:27.000 --> 00:11:34.000
Một khi hòn đảo được giải phóng - một lần nữa, tại một điểm treo - một chiếc thuyền khác có thể ghé thăm.

00:11:34.000 --> 00:11:47.000
Cũng giống như với hai chiếc thuyền gặp nhau trên biển khơi, sự tương tác giữa một chiếc thuyền và một hòn đảo cần duy trì sự cô lập của cả hai, bằng cách đảm bảo rằng các loại không thể gửi được không đi qua giữa hai loại.

00:11:47.000 --> 00:11:52.000
Ví dụ, có lẽ chúng tôi cố gắng thêm một con gà từ thuyền của chúng tôi vào đàn trên đảo.

00:11:52.000 --> 00:12:00.000
Điều này sẽ tạo ra hai tham chiếu đến cùng một đối tượng gà từ các miền cách ly khác nhau, vì vậy trình biên dịch Swift từ chối nó.

00:12:00.000 --> 00:12:11.000
Tương tự, nếu chúng tôi cố gắng nhận nuôi một con gà cưng từ hòn đảo và mang nó đi trên thuyền của chúng tôi, kiểm tra Sendable đảm bảo rằng chúng tôi không thể tạo cuộc đua dữ liệu này.

00:12:11.000 --> 00:12:19.000
Các diễn viên là các loại tham chiếu, nhưng không giống như các lớp, chúng cô lập tất cả các thuộc tính và mã của chúng để ngăn chặn truy cập đồng thời.

00:12:19.000 --> 00:12:25.000
Do đó, có một tham chiếu đến một diễn viên từ một miền cách ly khác là an toàn.

00:12:25.000 --> 00:12:34.000
Nó giống như có một bản đồ đến một hòn đảo: bạn có thể sử dụng bản đồ để đến thăm hòn đảo, nhưng bạn vẫn cần phải trải qua quy trình cập bến để truy cập trạng thái của nó.

00:12:34.000 --> 00:12:40.000
Do đó, tất cả các loại diễn viên đều hoàn toàn có thể gửi được.

00:12:40.000 --> 00:12:46.000
Bạn có thể tự hỏi làm thế nào để biết mã nào bị cô lập với diễn viên và mã nào không.

00:12:46.000 --> 00:12:50.000
Sự cô lập diễn viên được xác định bởi bối cảnh bạn đang ở.

00:12:50.000 --> 00:12:54.000
Các thuộc tính ví dụ của một diễn viên được cô lập với diễn viên đó.

00:12:54.000 --> 00:13:03.000
Các phương thức phiên bản trên diễn viên hoặc phần mở rộng của diễn viên cũng bị cô lập theo mặc định, như phương thức advanceTime này.

00:13:03.000 --> 00:13:14.000
Các đóng không thể gửi được, chẳng hạn như đóng được chuyển đến thuật toán giảm, ở lại trên diễn viên và bị cô lập diễn viên khi chúng ở trong bối cảnh bị cô lập bởi diễn viên.

00:13:14.000 --> 00:13:23.000
Trình khởi tạo nhiệm vụ cũng kế thừa sự cô lập của diễn viên khỏi ngữ cảnh của nó, vì vậy nhiệm vụ đã tạo sẽ được lên lịch trên cùng một diễn viên như nó đã được khởi tạo.

00:13:23.000 --> 00:13:27.000
Ở đây, điều đó cấp quyền truy cập vào đàn.

00:13:27.000 --> 00:13:37.000
Mặt khác, một nhiệm vụ tách rời không kế thừa sự cô lập của diễn viên với bối cảnh của nó, bởi vì nó hoàn toàn độc lập với bối cảnh nơi nó được tạo ra.

00:13:37.000 --> 00:13:46.000
Chúng ta có thể thấy rằng mã trong phần đóng ở đây được coi là bên ngoài diễn viên vì nó cần sử dụng "chờ đợi" để chỉ tài sản "thực phẩm" bị cô lập.

00:13:46.000 --> 00:13:52.000
Chúng tôi có một thuật ngữ cho việc đóng cửa này: đó là mã không bị cô lập.

00:13:52.000 --> 00:13:56.000
Mã không cô lập là mã không chạy trên bất kỳ tác nhân nào cả.

00:13:56.000 --> 00:14:05.000
Bạn có thể tạo một cách rõ ràng một hàm bên trong một diễn viên không bị cô lập bằng cách sử dụng từ khóa không bị cô lập, đặt nó bên ngoài diễn viên.

00:14:05.000 --> 00:14:10.000
Giống như những gì đã xảy ra ngầm với việc đóng cửa được sử dụng cho nhiệm vụ tách rời.

00:14:10.000 --> 00:14:20.000
Điều đó có nghĩa là nếu chúng ta muốn đọc một số tiểu bang bị cô lập với diễn viên, chúng ta sẽ cần sử dụng "chờ đợi" để đến thăm hòn đảo và lấy một bản sao của tiểu bang mà chúng ta cần.

00:14:20.000 --> 00:14:26.000
Mã không đồng bộ không cô lập luôn chạy trên nhóm hợp tác toàn cầu.

00:14:26.000 --> 00:14:33.000
Hãy nghĩ về nó chỉ chạy khi một chiếc thuyền ở ngoài biển khơi, vì vậy bạn phải rời khỏi hòn đảo bạn đang đến thăm để thực hiện công việc.

00:14:33.000 --> 00:14:39.000
Điều đó có nghĩa là kiểm tra để đảm bảo rằng bạn không mang theo bất kỳ dữ liệu không thể gửi nào bên mình!

00:14:39.000 --> 00:14:47.000
Ở đây, trình biên dịch phát hiện cuộc đua dữ liệu tiềm năng, trong đó một trường hợp Gà không thể gửi được đang cố gắng rời khỏi hòn đảo.

00:14:47.000 --> 00:14:52.000
Hãy xem xét thêm một trường hợp mã không bị cô lập.

00:14:52.000 --> 00:14:56.000
Hoạt động "chào mừng" là mã đồng bộ, không cô lập.

00:14:56.000 --> 00:15:00.000
Nó không biết gì về thuyền hoặc đảo hoặc đồng thời nói chung.

00:15:00.000 --> 00:15:05.000
Và ở đây, chúng tôi đang gọi nó từ chức năng greetOne bị cô lập bởi diễn viên, và điều đó không sao cả!

00:15:05.000 --> 00:15:14.000
Mã đồng bộ này, khi được gọi từ đảo, sẽ ở trên đảo, vì vậy nó được tự do hoạt động trên gà từ đàn.

00:15:14.000 --> 00:15:23.000
Thay vào đó, nếu chúng tôi có một hoạt động không đồng bộ không bị cô lập gọi là "chào mừng", thì "chào mừng" sẽ chạy đến đó, trên một chiếc thuyền, trên biển khơi.

00:15:23.000 --> 00:15:35.000
Hầu hết mã Swift là như thế này: đồng bộ, không cô lập với bất kỳ tác nhân nào và chỉ hoạt động trên các tham số mà nó đã được cung cấp, vì vậy nó nằm trong miền cách ly nơi nó được gọi.

00:15:35.000 --> 00:15:40.000
Các diễn viên giữ trạng thái bị cô lập với phần còn lại của chương trình.

00:15:40.000 --> 00:15:47.000
Chỉ có một tác vụ có thể chạy trên một diễn viên tại một thời điểm, vì vậy không có quyền truy cập đồng thời vào trạng thái đó.

00:15:47.000 --> 00:15:56.000
Kiểm tra có thể gửi được áp dụng bất cứ khi nào một tác vụ vào hoặc thoát khỏi một diễn viên để đảm bảo rằng không có trạng thái có thể thay đổi không đồng bộ nào thoát ra.

00:15:56.000 --> 00:16:04.000
Nhìn chung, điều này làm cho các diễn viên trở thành một trong những khối xây dựng cho một chương trình đồng thời trong Swift.

00:16:04.000 --> 00:16:09.000
Có một diễn viên đặc biệt khác mà chúng ta thường nói đến được gọi là diễn viên chính.

00:16:09.000 --> 00:16:13.000
Hãy nghĩ về diễn viên chính như một hòn đảo lớn giữa biển.

00:16:13.000 --> 00:16:19.000
Nó đại diện cho chủ đề chính, nơi xảy ra tất cả các bản vẽ và tương tác cho giao diện người dùng của bạn.

00:16:19.000 --> 00:16:24.000
Vì vậy, nếu bạn muốn vẽ thứ gì đó, bạn cần chạy mã trên đảo của diễn viên chính.

00:16:24.000 --> 00:16:32.000
Nó rất quan trọng đối với giao diện người dùng của bạn, có lẽ chúng ta thậm chí nên gọi nó là "U-I-land".

00:16:32.000 --> 00:16:39.000
Khi chúng tôi nói rằng diễn viên chính là "lớn", ý của chúng tôi là nó chứa rất nhiều trạng thái liên quan đến giao diện người dùng của chương trình.

00:16:39.000 --> 00:16:45.000
Có rất nhiều mã, cả trong khung giao diện người dùng và trong ứng dụng của bạn, cần chạy trên đó.

00:16:45.000 --> 00:16:51.000
Tuy nhiên, nó vẫn là một diễn viên, vì vậy nó chỉ điều hành một công việc tại một thời điểm.

00:16:51.000 --> 00:17:00.000
Vì vậy, bạn phải cẩn thận để không đặt quá nhiều hoặc công việc lâu dài vào diễn viên chính, bởi vì nó có thể làm cho giao diện người dùng của bạn không phản hồi.

00:17:00.000 --> 00:17:04.000
Sự cô lập với diễn viên chính được thể hiện với thuộc tính MainActor.

00:17:04.000 --> 00:17:12.000
Thuộc tính này có thể được áp dụng cho một hàm hoặc đóng để chỉ ra rằng mã phải chạy trên tác nhân chính.

00:17:12.000 --> 00:17:16.000
Sau đó, chúng tôi nói rằng mã này bị cô lập với diễn viên chính.

00:17:16.000 --> 00:17:28.000
Trình biên dịch Swift sẽ đảm bảo rằng mã cách ly diễn viên chính sẽ chỉ được thực thi trên luồng chính, sử dụng cùng một cơ chế đảm bảo quyền truy cập độc quyền lẫn nhau cho các tác nhân khác.

00:17:28.000 --> 00:17:39.000
Nếu một người gọi updateView từ một ngữ cảnh không bị cô lập với diễn viên chính, nó sẽ cần giới thiệu một "chờ đợi" để tính đến việc chuyển sang diễn viên chính.

00:17:39.000 --> 00:17:47.000
Thuộc tính diễn viên chính cũng có thể được áp dụng cho các loại, trong trường hợp đó, các trường hợp của các loại đó sẽ được cách ly với diễn viên chính.

00:17:47.000 --> 00:17:58.000
Một lần nữa, điều này giống như bất kỳ tác nhân nào khác - các thuộc tính chỉ có thể truy cập được khi ở tác nhân chính và các phương thức được cách ly với tác nhân chính trừ khi chúng chọn không tham gia một cách rõ ràng.

00:17:58.000 --> 00:18:07.000
Giống như các diễn viên bình thường, các tham chiếu đến các lớp diễn viên chính tự chúng có thể gửi được, bởi vì dữ liệu của họ bị cô lập.

00:18:07.000 --> 00:18:16.000
Điều này làm cho chú thích diễn viên chính phù hợp với chế độ xem giao diện người dùng và bộ điều khiển chế độ xem của bạn, chúng nhất thiết phải được gắn với luồng chính bởi chính các khuôn khổ.

00:18:16.000 --> 00:18:26.000
Bạn có thể chia sẻ tham chiếu đến bộ điều khiển chế độ xem của mình với các tác vụ và tác nhân khác trong chương trình của mình và họ có thể gọi lại không đồng bộ vào bộ điều khiển chế độ xem để đăng kết quả.

00:18:26.000 --> 00:18:30.000
Điều này có ảnh hưởng trực tiếp đến kiến trúc ứng dụng của bạn.

00:18:30.000 --> 00:18:35.000
Trong ứng dụng của bạn, chế độ xem và bộ điều khiển chế độ xem của bạn sẽ nằm trên diễn viên chính.

00:18:35.000 --> 00:18:45.000
Logic chương trình khác nên được tách ra khỏi tác nhân chính đó, sử dụng các tác nhân khác để mô hình hóa trạng thái và nhiệm vụ được chia sẻ một cách an toàn để mô tả công việc độc lập.

00:18:45.000 --> 00:18:51.000
Và những nhiệm vụ đó có thể chuyển đổi giữa diễn viên chính và các diễn viên khác khi cần thiết.

00:18:51.000 --> 00:18:57.000
Có rất nhiều điều đang diễn ra trong một ứng dụng đồng thời, vì vậy chúng tôi đã xây dựng một số công cụ tuyệt vời để giúp bạn hiểu nó.

00:18:57.000 --> 00:19:03.000
Tôi mời bạn xem bài nói chuyện "Trực quan hóa và Tối ưu hóa Đồng thời Nhanh chóng" để tìm hiểu thêm.

00:19:03.000 --> 00:19:08.000
Hãy đi sâu vào một số vùng nước sâu hơn để nói về tính nguyên tử.

00:19:08.000 --> 00:19:12.000
Mục tiêu của mô hình Swift Concurrency là loại bỏ các cuộc đua dữ liệu.

00:19:12.000 --> 00:19:18.000
Điều đó thực sự có nghĩa là nó loại bỏ các cuộc đua dữ liệu cấp thấp, liên quan đến tham nhũng dữ liệu.

00:19:18.000 --> 00:19:23.000
Bạn vẫn cần phải suy luận về tính nguyên tử ở mức độ cao.

00:19:23.000 --> 00:19:28.000
Như chúng ta đã nói trước đây, các diễn viên chỉ thực hiện một nhiệm vụ tại một thời điểm.

00:19:28.000 --> 00:19:32.000
Tuy nhiên, khi bạn ngừng chạy trên một diễn viên, diễn viên đó có thể chạy các tác vụ khác.

00:19:32.000 --> 00:19:38.000
Điều này đảm bảo rằng chương trình đạt được tiến bộ, loại bỏ khả năng bế tắc.

00:19:38.000 --> 00:19:43.000
Tuy nhiên, nó yêu cầu bạn xem xét các bất biến của diễn viên một cách cẩn thận xung quanh các tuyên bố đang chờ đợi.

00:19:43.000 --> 00:19:52.000
Nếu không, bạn có thể kết thúc với một cuộc đua dữ liệu cấp cao, nơi chương trình ở trạng thái bất ngờ, mặc dù không có dữ liệu nào thực sự bị hỏng.

00:19:52.000 --> 00:19:56.000
Hãy chia nhỏ một ví dụ về điều này.

00:19:56.000 --> 00:20:01.000
Ở đây chúng tôi có một chức năng dự định gửi thêm một số quả dứa trên một hòn đảo.

00:20:01.000 --> 00:20:06.000
Nó nằm ngoài một diễn viên, vì vậy nó là mã không đồng bộ không bị cô lập.

00:20:06.000 --> 00:20:10.000
Điều đó có nghĩa là nó chạy ra đây trên biển khơi.

00:20:10.000 --> 00:20:16.000
Nó đã được tặng một số quả dứa và một bản đồ đến hòn đảo nơi nó nên gửi những quả dứa đó.

00:20:16.000 --> 00:20:22.000
Hoạt động thú vị đầu tiên ở đây lấy một bản sao của mảng thức ăn từ hòn đảo.

00:20:22.000 --> 00:20:27.000
Để làm điều đó, con thuyền cần đến thăm hòn đảo, được báo hiệu bằng từ khóa "chờ đợi".

00:20:27.000 --> 00:20:33.000
Ngay sau khi có một bản sao của thức ăn, con thuyền quay trở lại biển khơi để tiếp tục công việc của mình.

00:20:33.000 --> 00:20:39.000
Điều đó có nghĩa là thêm dứa từ thông số dứa vào hai loại mà nó nhận được từ hòn đảo.

00:20:39.000 --> 00:20:43.000
Bây giờ, chúng ta có thể di chuyển đến dòng cuối cùng của hàm.

00:20:43.000 --> 00:20:50.000
Thuyền của chúng tôi bây giờ cần đến thăm hòn đảo một lần nữa để thiết lập mảng thức ăn của hòn đảo cho ba quả dứa đó.

00:20:50.000 --> 00:20:55.000
Ở đây, mọi thứ đều ổn, và chúng tôi có ba quả dứa trên đảo!

00:20:55.000 --> 00:20:58.000
Nhưng mọi thứ có thể đã diễn ra hơi khác một chút.

00:20:58.000 --> 00:21:07.000
Giả sử một con tàu cướp biển đã lẻn vào và đánh cắp tất cả dứa trong khi chiếc thuyền đầu tiên của chúng tôi đang đợi đến lượt nó đến thăm hòn đảo.

00:21:07.000 --> 00:21:13.000
Bây giờ, con tàu ban đầu của chúng tôi gửi ba quả dứa của nó trên đảo, và chúng tôi nhận thấy một vấn đề.

00:21:13.000 --> 00:21:17.000
Ba quả dứa đột nhiên biến thành năm quả dứa!

00:21:17.000 --> 00:21:19.000
Chuyện gì đã xảy ra ở đây vậy?

00:21:19.000 --> 00:21:32.000
Chà, lưu ý rằng chúng tôi có hai người đang chờ đợi để tiếp cận tiểu bang trên cùng một diễn viên và chúng tôi đang đưa ra giả định ở đây rằng mảng thức ăn trên đảo không thay đổi giữa hai người đang chờ đợi.

00:21:32.000 --> 00:21:42.000
Nhưng những điều này đang chờ đợi, có nghĩa là nhiệm vụ của chúng tôi có thể bị đình chỉ ở đây và diễn viên có thể thực hiện các công việc ưu tiên cao hơn khác, như chiến đấu với cướp biển.

00:21:42.000 --> 00:21:49.000
Trong trường hợp cụ thể này, trình biên dịch Swift sẽ từ chối nỗ lực sửa đổi hoàn toàn trạng thái trên một diễn viên khác.

00:21:49.000 --> 00:21:56.000
Tuy nhiên, chúng ta thực sự nên viết lại hoạt động gửi tiền của mình dưới dạng mã đồng bộ trên tác nhân, như thế này.

00:21:56.000 --> 00:22:01.000
Bởi vì đây là mã đồng bộ, nó sẽ chạy trên diễn viên mà không bị gián đoạn.

00:22:01.000 --> 00:22:09.000
Vì vậy, chúng tôi có thể chắc chắn rằng trạng thái của hòn đảo sẽ không thay đổi bởi bất kỳ ai khác trong toàn bộ chức năng.

00:22:09.000 --> 00:22:17.000
Khi bạn đang viết diễn viên của mình, hãy nghĩ về các hoạt động giao dịch, đồng bộ có thể được xen kẽ theo bất kỳ cách nào.

00:22:17.000 --> 00:22:23.000
Mỗi người trong số họ nên đảm bảo rằng diễn viên ở trong trạng thái tốt khi nó thoát ra.

00:22:23.000 --> 00:22:35.000
Đối với các hoạt động diễn viên không đồng bộ, hãy giữ chúng đơn giản, hình thành chúng chủ yếu từ các hoạt động giao dịch, đồng bộ của bạn và chú ý rằng diễn viên của bạn ở trạng thái tốt ở mỗi hoạt động đang chờ.

00:22:35.000 --> 00:22:42.000
Bằng cách này, bạn có thể tận dụng tối đa các tác nhân để loại bỏ cả các chủng tộc dữ liệu cấp thấp và cấp cao.

00:22:42.000 --> 00:22:51.000
Trong một chương trình đồng thời, nhiều thứ đang xảy ra cùng một lúc, vì vậy thứ tự những điều đó xảy ra có thể thay đổi từ lần thực hiện này sang lần khác.

00:22:51.000 --> 00:22:56.000
Tuy nhiên, các chương trình thường dựa vào việc xử lý các sự kiện theo thứ tự nhất quán.

00:22:56.000 --> 00:23:02.000
Ví dụ, luồng sự kiện đến từ đầu vào của người dùng hoặc tin nhắn từ máy chủ.

00:23:02.000 --> 00:23:07.000
Khi các luồng sự kiện này xuất hiện, chúng tôi hy vọng ảnh hưởng của chúng sẽ xảy ra theo thứ tự.

00:23:07.000 --> 00:23:14.000
Swift Concurrency cung cấp các công cụ để đặt hàng các hoạt động, tuy nhiên, các tác nhân không phải là công cụ để làm như vậy.

00:23:14.000 --> 00:23:20.000
Các diễn viên thực hiện công việc ưu tiên cao nhất trước tiên, để giúp hệ thống tổng thể luôn phản hồi nhanh.

00:23:20.000 --> 00:23:28.000
Điều này loại bỏ các đảo ngược ưu tiên trong đó công việc ưu tiên thấp hơn kết thúc xảy ra trước khi công việc ưu tiên cao hơn trên cùng một tác nhân.

00:23:28.000 --> 00:23:38.000
Lưu ý rằng đây là một sự khác biệt đáng kể so với hàng đợi Dispatch nối tiếp, được thực hiện theo thứ tự vào trước, ra trước một cách nghiêm ngặt.

00:23:38.000 --> 00:23:41.000
Swift Concurrency có một số công cụ để đặt hàng công việc.

00:23:41.000 --> 00:23:45.000
Lần đầu tiên chúng ta đã nói về rất nhiều - nhiệm vụ.

00:23:45.000 --> 00:23:54.000
Các nhiệm vụ được thực hiện từ đầu đến cuối, với quy trình điều khiển bình thường mà bạn đã quen, vì vậy chúng tự nhiên sắp xếp công việc.

00:23:54.000 --> 00:23:58.000
AsyncStream có thể được sử dụng để mô hình hóa một luồng sự kiện thực tế.

00:23:58.000 --> 00:24:05.000
Một nhiệm vụ có thể lặp lại trên luồng sự kiện với vòng lặp chờ đợi, lần lượt xử lý từng sự kiện.

00:24:05.000 --> 00:24:14.000
AsyncStream có thể được chia sẻ với bất kỳ số lượng nhà sản xuất sự kiện nào, có thể thêm các yếu tố vào luồng trong khi vẫn duy trì thứ tự.

00:24:14.000 --> 00:24:26.000
Chúng tôi đã nói rất nhiều về cách mô hình đồng thời của Swift được thiết kế để loại bỏ các cuộc đua dữ liệu bằng cách sử dụng khái niệm cô lập, được duy trì bằng cách kiểm tra Sendable tại nhiệm vụ và ranh giới diễn viên.

00:24:26.000 --> 00:24:32.000
Tuy nhiên, tất cả chúng ta không thể dừng lại những gì chúng ta đang làm để đánh dấu tất cả các loại Có thể gửi được ở mọi nơi.

00:24:32.000 --> 00:24:36.000
Thay vào đó, chúng ta cần một cách tiếp cận gia tăng.

00:24:36.000 --> 00:24:44.000
Swift 5.7 giới thiệu cài đặt xây dựng để xác định mức độ nghiêm ngặt của trình biên dịch Swift nên kiểm tra Sendability.

00:24:44.000 --> 00:24:53.000
Cài đặt mặc định là Tối thiểu có nghĩa là trình biên dịch sẽ chỉ chẩn đoán những nơi mà người ta đã cố gắng đánh dấu rõ ràng thứ gì đó là Có thể gửi được.

00:24:53.000 --> 00:25:00.000
Điều này tương tự như cách Swift 5.5 và 5.6 hoạt động, và đối với những điều trên, sẽ không có bất kỳ cảnh báo hoặc lỗi nào.

00:25:00.000 --> 00:25:09.000
Bây giờ, nếu bạn thêm sự phù hợp có thể gửi được, trình biên dịch sẽ phàn nàn rằng loại Coop không thể gửi được vì Chicken không thể gửi được.

00:25:09.000 --> 00:25:22.000
Tuy nhiên, điều này - và các vấn đề liên quan đến Sendable khác - sẽ được trình bày dưới dạng cảnh báo trong Swift 5, không phải lỗi, để giúp giải quyết từng vấn đề một dễ dàng hơn.

00:25:22.000 --> 00:25:28.000
Để tiến xa hơn về an toàn cuộc đua dữ liệu, hãy bật cài đặt đồng thời nghiêm ngặt "được nhắm mục tiêu".

00:25:28.000 --> 00:25:37.000
Cài đặt này cho phép Sendable kiểm tra mã đã áp dụng các tính năng Swift Concurrency như async/await, tasks hoặc actors.

00:25:37.000 --> 00:25:45.000
Điều này sẽ xác định, ví dụ, các nỗ lực nắm bắt các giá trị của loại không thể gửi được trong một nhiệm vụ mới được tạo.

00:25:45.000 --> 00:25:50.000
Đôi khi các loại không thể gửi đến từ một mô-đun khác.

00:25:50.000 --> 00:25:57.000
Có lẽ đó là một số gói chưa được cập nhật cho Sendable, hoặc thậm chí là mô-đun của riêng bạn mà bạn chưa nhận được.

00:25:57.000 --> 00:26:07.000
Đối với những người đó, bạn có thể tạm thời vô hiệu hóa cảnh báo Sendable cho các loại đến từ mô-đun đó bằng cách sử dụng thuộc tính @preconcurrency.

00:26:07.000 --> 00:26:12.000
Điều này sẽ tắt tiếng các cảnh báo có thể gửi được cho loại Gà trong tệp nguồn này.

00:26:12.000 --> 00:26:17.000
Tại một thời điểm nào đó, mô-đun FarmAnimals sẽ được cập nhật với sự phù hợp của Sendable.

00:26:17.000 --> 00:26:27.000
Sau đó, một trong hai điều sẽ xảy ra: hoặc Chicken trở thành Sendable bằng cách nào đó, trong trường hợp đó, thuộc tính tiền đồng thời có thể bị xóa khỏi mục nhập.

00:26:27.000 --> 00:26:38.000
Hoặc Gà sẽ được biết là không thể gửi được, trong trường hợp đó cảnh báo sẽ quay trở lại, cho thấy rằng các giả định của bạn về Gà có thể gửi được, trên thực tế, không chính xác.

00:26:38.000 --> 00:26:47.000
Cài đặt độ nghiêm ngặt được nhắm mục tiêu cố gắng đạt được sự cân bằng giữa khả năng tương thích với mã hiện có và xác định các chủng tộc dữ liệu tiềm năng.

00:26:47.000 --> 00:26:55.000
Tuy nhiên, nếu bạn muốn thấy ở mọi nơi mà các chủng tộc có thể xảy ra, có một lựa chọn nữa: kiểm tra hoàn chỉnh.

00:26:55.000 --> 00:27:01.000
Kiểm tra hoàn chỉnh gần đúng ngữ nghĩa Swift 6 dự định để loại bỏ hoàn toàn các cuộc đua dữ liệu.

00:27:01.000 --> 00:27:07.000
Nó kiểm tra mọi thứ mà hai chế độ trước đó kiểm tra nhưng làm như vậy cho tất cả mã trong mô-đun.

00:27:07.000 --> 00:27:11.000
Ở đây, chúng tôi hoàn toàn không thực sự sử dụng các tính năng đồng thời của Swift.

00:27:11.000 --> 00:27:17.000
Thay vào đó, nó đang thực hiện công việc trên hàng đợi điều phối, nó sẽ thực thi mã đó đồng thời.

00:27:17.000 --> 00:27:31.000
Thao tác không đồng bộ trên hàng đợi điều phối thực sự được biết là đóng Sendable, vì vậy trình biên dịch tạo ra cảnh báo cho biết rằng có một cuộc đua dữ liệu khi nội dung không thể gửi được mã đang chạy trên hàng đợi điều phối bắt giữ.

00:27:31.000 --> 00:27:36.000
Chúng ta có thể khắc phục điều này bằng cách làm cho tham số nội dung có thể gửi được.

00:27:36.000 --> 00:27:45.000
Sự thay đổi đó loại bỏ cảnh báo này, và bây giờ tất cả những người gọi của doWork đều biết rằng họ cần cung cấp một đóng có thể gửi được.

00:27:45.000 --> 00:27:53.000
Điều đó có nghĩa là chúng tôi kiểm tra tốt hơn các cuộc đua dữ liệu và chúng tôi có thể thấy rằng chức năng truy cập hiện là nguồn của cuộc đua dữ liệu.

00:27:53.000 --> 00:28:00.000
Kiểm tra hoàn chỉnh sẽ giúp loại bỏ các cuộc đua dữ liệu tiềm năng trong chương trình của bạn.

00:28:00.000 --> 00:28:06.000
Để đạt được mục tiêu của Swift là loại bỏ các cuộc đua dữ liệu, cuối cùng chúng ta sẽ cần phải hoàn thành việc kiểm tra.

00:28:06.000 --> 00:28:21.000
Chúng tôi khuyến khích bạn làm việc từng bước hướng tới mục tiêu đó: áp dụng mô hình đồng thời của Swift để kiến trúc ứng dụng của bạn để đảm bảo an toàn cuộc đua dữ liệu, sau đó cho phép kiểm tra đồng thời chặt chẽ hơn dần dần để loại bỏ các loại lỗi khỏi mã của bạn.

00:28:21.000 --> 00:28:27.000
Và đừng lo lắng về việc đánh dấu hàng nhập khẩu của bạn bằng @preconcurrency để ngăn chặn các cảnh báo cho các loại đã nhập khẩu.

00:28:27.000 --> 00:28:33.000
Khi các mô-đun đó áp dụng kiểm tra đồng thời chặt chẽ hơn, trình biên dịch sẽ kiểm tra lại các giả định của bạn.

00:28:33.000 --> 00:28:42.000
Ở cuối con đường này, mã của bạn sẽ được hưởng lợi từ cả an toàn bộ nhớ và an toàn cuộc đua dữ liệu, giúp bạn tập trung vào việc xây dựng các ứng dụng tuyệt vời.

00:28:42.000 --> 00:28:47.000
Và cảm ơn bạn đã đi thuyền với tôi trên biển đồng thời.

00:28:47.000 --> 23:59:59.000
♪

