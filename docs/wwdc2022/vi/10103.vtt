WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:11.000
Xin chào và chào mừng.

00:00:11.000 --> 00:00:14.000
Tên tôi là Kelvin Chiu từ nhóm Phần mềm GPU tại Apple.

00:00:14.000 --> 00:00:20.000
Hôm nay, tôi sẽ nói về cách tăng hiệu suất ứng dụng Metal của bạn với MetalFX Upscaling.

00:00:20.000 --> 00:00:27.000
MetalFX là một API mới cung cấp các hiệu ứng đồ họa được tối ưu hóa nền tảng cho các ứng dụng Metal.

00:00:27.000 --> 00:00:34.000
Nó cho phép nâng cấp hiệu suất cao, điều này sẽ tăng hiệu suất ứng dụng của bạn trong khi vẫn giữ được chất lượng kết xuất của nó.

00:00:34.000 --> 00:00:38.000
Kết xuất một khung hình ở độ phân giải cao tốn thời gian GPU.

00:00:38.000 --> 00:00:42.000
Để giảm thời gian đó, việc kết xuất ở độ phân giải thấp hơn thường sẽ thực hiện thủ thuật.

00:00:42.000 --> 00:00:45.000
Tuy nhiên, sự đánh đổi là chất lượng kết xuất thấp hơn.

00:00:45.000 --> 00:00:55.000
Với MetalFX Upscaling, ứng dụng của bạn giờ đây có thể hiển thị khung hình ở độ phân giải thấp hơn, giảm thời gian kết xuất mà không ảnh hưởng đến chất lượng kết xuất.

00:00:55.000 --> 00:01:00.000
MetalFX Upscaling được tối ưu hóa để chạy tốt nhất trên các thiết bị Apple.

00:01:00.000 --> 00:01:04.000
Và nó cũng dễ dàng áp dụng trong trò chơi của bạn.

00:01:04.000 --> 00:01:09.000
MetalFX cung cấp hai hiệu ứng nâng cấp, mà tôi sẽ mô tả chi tiết.

00:01:09.000 --> 00:01:14.000
Nâng cấp không gian rất đơn giản để sử dụng và giúp tăng hiệu suất tuyệt vời.

00:01:14.000 --> 00:01:22.000
Khử răng cưa tạm thời và nâng cấp tích hợp thông tin từ nhiều khung hình để tạo ra đầu ra chất lượng cao hơn.

00:01:22.000 --> 00:01:27.000
Sau đó tôi sẽ nói về các phương pháp hay nhất để sử dụng những hiệu ứng này.

00:01:27.000 --> 00:01:32.000
Cuối cùng, tôi sẽ kết thúc phiên với các bản demo cho thấy chúng đang hoạt động.

00:01:32.000 --> 00:01:36.000
Hãy bắt đầu với việc nâng cấp không gian.

00:01:36.000 --> 00:01:43.000
MetalFX Spatial upscaling phân tích thông tin không gian của đầu vào để tạo ra các mẫu mới, được nâng cấp.

00:01:43.000 --> 00:01:45.000
Tích hợp mở rộng quy mô không gian rất đơn giản.

00:01:45.000 --> 00:01:51.000
Nó chỉ yêu cầu màu đầu vào khử răng cưa để tạo ra đầu ra màu được nâng cấp theo không gian.

00:01:51.000 --> 00:02:00.000
Trong một quy trình kết xuất trò chơi điển hình, có nhiều đường dẫn kết xuất khác nhau bao gồm kết xuất khử răng cưa và các hiệu ứng xử lý hậu kỳ khác nhau.

00:02:00.000 --> 00:02:05.000
Thêm nâng cấp không gian MetalFX ngay sau khi quá trình ánh xạ giai điệu của trò chơi hoàn tất.

00:02:05.000 --> 00:02:10.000
Nó sẽ hoạt động tốt nhất nếu đầu vào đã được ánh xạ tông màu và nằm trong một không gian màu nhận thức.

00:02:10.000 --> 00:02:15.000
Hãy kiểm tra hoạt động nâng cấp không gian MetalFX.

00:02:15.000 --> 00:02:20.000
Cảnh cờ vua này được sản xuất với trình kết xuất tham chiếu chất lượng cao ở độ phân giải 4K.

00:02:20.000 --> 00:02:26.000
Nó được vạch ra đường dẫn, với các hiệu ứng đồ họa phức tạp, như phản xạ và bóng theo dõi tia.

00:02:26.000 --> 00:02:32.000
Đây là so sánh cạnh nhau, với đầu vào 540p ở bên trái...

00:02:32.000 --> 00:02:38.000
...Và đầu ra 1080p với khả năng nâng cấp không gian MetalFX ở bên phải.

00:02:38.000 --> 00:02:44.000
Nếu tôi phóng to nữ hoàng, ở bên trái, hình ảnh thiếu chi tiết và độ phân giải thấp.

00:02:44.000 --> 00:02:52.000
Ở bên phải, đầu ra được nâng cấp theo không gian có phản xạ sắc nét hơn và các cạnh tinh tế hơn.

00:02:52.000 --> 00:02:57.000
Tiếp theo, tôi sẽ hướng dẫn bạn cách triển khai nâng cấp không gian MetalFX.

00:02:57.000 --> 00:03:04.000
Trong Metal, bạn thường tạo một bộ mã hóa lệnh để mã hóa các lệnh thành bộ đệm lệnh và tạo đầu vào cho hiệu ứng.

00:03:04.000 --> 00:03:12.000
Tương tự, bạn có thể tạo một đối tượng hiệu ứng MetalFX để mã hóa các lệnh vào bộ đệm lệnh và thực hiện hiệu ứng.

00:03:12.000 --> 00:03:17.000
Cuối cùng, tạo bộ mã hóa lệnh thứ ba để mã hóa các lệnh sử dụng đầu ra MetalFX.

00:03:17.000 --> 00:03:27.000
Bạn chỉ nên tạo một đối tượng mở rộng không gian mới khi ứng dụng của bạn khởi động lần đầu tiên hoặc khi màn hình chuyển độ phân giải vì chúng rất tốn kém để tạo.

00:03:27.000 --> 00:03:32.000
Đầu tiên, tạo và cấu hình MTLFXSpatialScalerDescriptor.

00:03:32.000 --> 00:03:37.000
Sau đó, tạo một đối tượng scaler bằng cách gọi phương thức makeSpatialScaler().

00:03:37.000 --> 00:03:41.000
Trong mã khởi tạo, bắt đầu với bộ mô tả.

00:03:41.000 --> 00:03:45.000
Điền vào cả chiều rộng và chiều cao của kết cấu đầu vào và đầu ra.

00:03:45.000 --> 00:03:50.000
Sau đó, đặt định dạng kết cấu cho các kết cấu sẽ được đặt sau này trên đối tượng scaler.

00:03:50.000 --> 00:03:53.000
Đặt chế độ xử lý màu.

00:03:53.000 --> 00:03:57.000
Điều này cho API biết đầu vào và đầu ra nằm trong không gian màu nào.

00:03:57.000 --> 00:04:03.000
Bạn có thể đặt giá trị ở trong không gian màu nhận thức, tuyến tính hoặc HDR.

00:04:03.000 --> 00:04:08.000
Khi bộ mô tả được điền, hãy tạo đối tượng scaler.

00:04:08.000 --> 00:04:18.000
Khi đối tượng scaler được tạo, bạn có thể sửa đổi các thuộc tính của đối tượng thường xuyên như bạn muốn và gọi phương thức encode() để bắt đầu quá trình nâng cấp.

00:04:18.000 --> 00:04:28.000
Trong mã vẽ mỗi khung hình của bạn, hãy đảm bảo kết cấu đầu vào và đầu ra chính xác đang được đặt trên đối tượng scaler trước khi mã hóa hiệu ứng chia tỷ lệ vào bộ đệm lệnh.

00:04:28.000 --> 00:04:32.000
Nâng cấp không gian cung cấp một cách đơn giản để tăng hiệu suất.

00:04:32.000 --> 00:04:39.000
Và khi bạn muốn kết xuất chất lượng cao hơn nữa, đó là nơi MetalFX có khả năng khử răng cưa và nâng cấp tạm thời.

00:04:39.000 --> 00:04:46.000
AA tạm thời và nâng cấp là một kỹ thuật sử dụng dữ liệu từ các khung hình trước đó để tạo ra đầu ra nâng cấp chất lượng cao.

00:04:46.000 --> 00:04:53.000
Điều này có nghĩa là, đầu ra của việc nâng cấp từ khung trước sẽ được sử dụng làm một trong những đầu vào cho việc nâng cấp khung hiện tại.

00:04:53.000 --> 00:05:02.000
Để hiểu rõ hơn tại sao AA tạm thời và nâng cấp yêu cầu dữ liệu từ các khung trước đó, trước tiên tôi sẽ xem xét khái niệm siêu lấy mẫu.

00:05:02.000 --> 00:05:09.000
Trong siêu lấy mẫu, nhiều mẫu được tính toán trên mỗi pixel, sau đó được tích hợp vào một giá trị pixel duy nhất.

00:05:09.000 --> 00:05:14.000
Chúng tôi càng tích hợp nhiều mẫu trên mỗi pixel, kết quả sẽ càng tốt.

00:05:14.000 --> 00:05:21.000
Tuy nhiên, phải trả một chi phí lớn để tính toán nhiều mẫu trên mỗi pixel trong một khung hình duy nhất.

00:05:21.000 --> 00:05:28.000
Thay vì lấy mẫu nhiều vị trí trên mỗi pixel trong một khung hình duy nhất, bạn có thể thực hiện lấy mẫu theo thời gian.

00:05:28.000 --> 00:05:34.000
Lấy mẫu tạm thời là khái niệm hiển thị một vị trí mẫu khác cho tất cả các điểm ảnh trong một khung nhất định.

00:05:34.000 --> 00:05:41.000
Điều này cho phép bạn đạt được chất lượng siêu lấy mẫu trên nhiều khung hình với chi phí thấp hơn đáng kể.

00:05:41.000 --> 00:05:56.000
Bằng cách tích lũy các mẫu từ nhiều khung hình và tính đến các vị trí mẫu, AA thời gian &amp; nâng cấp có thể tích hợp các mẫu một cách thích hợp trong các pixel có độ phân giải mục tiêu, dẫn đến đầu ra được nâng cấp chống răng cưa chất lượng cao.

00:05:56.000 --> 00:06:03.000
Tuy nhiên, vì nội dung thường thay đổi giữa các khung hình, nó sẽ yêu cầu nhiều dữ liệu đầu vào hơn để phát hiện những thay đổi này.

00:06:03.000 --> 00:06:14.000
Bên cạnh đầu ra khung hình trước đó, Temporal AA và nâng cấp cũng yêu cầu đầu vào màu bị rung, cũng như dữ liệu chuyển động và độ sâu từ cảnh.

00:06:14.000 --> 00:06:19.000
Tôi sẽ xem qua từng người trong số họ để giải thích tại sao họ được yêu cầu.

00:06:19.000 --> 00:06:23.000
Hãy bắt đầu với đầu vào màu rung.

00:06:23.000 --> 00:06:26.000
Đây là một hình tam giác màu đỏ được hiển thị mà không bị rung lắc.

00:06:26.000 --> 00:06:30.000
Đường viền màu trắng sáng đại diện cho hình tam giác đang được hiển thị.

00:06:30.000 --> 00:06:33.000
Mỗi hình vuông nhỏ đại diện cho một điểm ảnh.

00:06:33.000 --> 00:06:38.000
Và chấm màu xám ở giữa là nơi lấy mẫu pixel.

00:06:38.000 --> 00:06:43.000
Đây là đầu ra của cùng một tam giác khi được hiển thị với một jitter nhỏ.

00:06:43.000 --> 00:06:47.000
Các chấm màu xám hiển thị vị trí lấy mẫu cho một điểm ảnh nhất định.

00:06:47.000 --> 00:06:54.000
Độ lệch jitter phải là duy nhất cho một số khung hình đã đặt để thu thập đầy đủ số lượng mẫu mong muốn.

00:06:54.000 --> 00:06:58.000
Tôi sẽ đề cập chi tiết về chuỗi jitter sau.

00:06:58.000 --> 00:07:01.000
Tiếp theo là thông tin chuyển động từ hiện trường.

00:07:01.000 --> 00:07:09.000
Dữ liệu chuyển động từ cảnh cho biết các đối tượng đã di chuyển bao nhiêu và hướng nào so với khung hình trước đó.

00:07:09.000 --> 00:07:18.000
AA tạm thời và nâng cấp sử dụng thông tin chuyển động để theo dõi lại và tìm các vị trí tương ứng trong khung trước đó để thu thập chính xác các mẫu.

00:07:18.000 --> 00:07:22.000
Một đầu vào khác là thông tin chiều sâu từ hiện trường.

00:07:22.000 --> 00:07:26.000
Dữ liệu độ sâu từ cảnh chỉ ra những gì ở phía trước và những gì ở phía sau.

00:07:26.000 --> 00:07:37.000
Điều này rất quan trọng khi ưu tiên khử răng cưa cạnh tiền cảnh và cung cấp manh mối về những vật thể khác có thể mới lộ ra khi thu thập các mẫu từ các khung trước đó.

00:07:37.000 --> 00:07:42.000
Phần dữ liệu đầu vào cuối cùng là đầu ra của khung trước đó.

00:07:42.000 --> 00:07:56.000
Đầu ra của khung trước đó chứa tất cả các mẫu đã được tích hợp trước đó và nó sẽ được pha trộn với đầu vào màu rung của khung hiện tại để tăng số lượng mẫu trên mỗi pixel.

00:07:56.000 --> 00:08:02.000
Bằng cách kết hợp thông tin từ cả khung hình hiện tại và trước đó, hình ảnh kết quả giờ đây có nhiều chi tiết hơn.

00:08:02.000 --> 00:08:11.000
MetalFX theo dõi đầu ra được nâng cấp, vì vậy bạn chỉ cần chuyển màu sắc, chuyển động và độ sâu từ khung được hiển thị hiện tại.

00:08:11.000 --> 00:08:24.000
Quay trở lại quy trình kết xuất của một trò chơi điển hình, MetalFX tạm thời AA và nâng cấp nên chạy trước bất kỳ hiệu ứng xử lý hậu kỳ nào, vì những hiệu ứng này sẽ can thiệp vào kết quả của việc nâng cấp.

00:08:24.000 --> 00:08:29.000
Đây là kết xuất cờ vua một lần nữa, lần này sử dụng MetalFX Temporal AA và nâng cấp.

00:08:29.000 --> 00:08:41.000
Đây là so sánh song song giữa đầu vào 1080p ở bên trái và đầu ra được nâng cấp 4K ở bên phải.

00:08:41.000 --> 00:08:55.000
Phóng to gần nữ hoàng hơn, đầu vào có độ phân giải thấp và có bí danh, trong khi đầu ra được nâng cấp tạm thời ở bên phải có độ phân giải cao với đường viền mượt mà và có nhiều chi tiết tốt hơn trong phản xạ.

00:08:55.000 --> 00:09:05.000
Cũng giống như với bộ chia tỷ lệ không gian, việc tạo bộ chia tỷ lệ thời gian mới rất tốn kém và chỉ nên được thực hiện khi ứng dụng của bạn khởi động lần đầu tiên hoặc khi màn hình chuyển độ phân giải.

00:09:05.000 --> 00:09:10.000
Đầu tiên, bạn sẽ cần phân bổ và điền vào MTLFXTemporalScalerDescriptor.

00:09:10.000 --> 00:09:15.000
Sau đó gọi phương thức makeTemporalScaler() để tạo đối tượng scaler.

00:09:15.000 --> 00:09:19.000
Trong mã khởi tạo của bạn, hãy bắt đầu với bộ mô tả.

00:09:19.000 --> 00:09:23.000
Điền vào cả chiều rộng và chiều cao của kết cấu đầu vào và đầu ra.

00:09:23.000 --> 00:09:32.000
Sau đó đặt các định dạng kết cấu màu, độ sâu và chuyển động rung cho các kết cấu sẽ bị ràng buộc sau này trên đối tượng scaler làm đầu vào.

00:09:32.000 --> 00:09:38.000
Cuối cùng, đặt định dạng cho kết cấu đầu ra trong đó MetalFX sẽ lưu trữ đầu ra được nâng cấp.

00:09:38.000 --> 00:09:42.000
Khi bộ mô tả được điền, hãy tạo đối tượng scaler.

00:09:42.000 --> 00:09:45.000
Trên đối tượng scaler, đặt các thuộc tính scale chuyển động.

00:09:45.000 --> 00:09:50.000
Điều này giúp bạn mở rộng dữ liệu chuyển động của ứng dụng theo những gì API mong đợi.

00:09:50.000 --> 00:09:59.000
MetalFX mong đợi dữ liệu chuyển động trong không gian pixel độ phân giải kết xuất với hướng đi từ vị trí của khung hình hiện tại đến vị trí của khung hình trước đó.

00:09:59.000 --> 00:10:03.000
Ví dụ, tôi sẽ sử dụng độ phân giải kết xuất 1080p.

00:10:03.000 --> 00:10:09.000
Giả sử bạn có một vật thể di chuyển từ tọa độ không gian clip (-0.75, -0.75).

00:10:09.000 --> 00:10:12.000
Để kẹp tọa độ không gian (0.25, 0.25).

00:10:12.000 --> 00:10:17.000
Dữ liệu chuyển động được lưu trữ dưới dạng (1, 1).

00:10:17.000 --> 00:10:26.000
Đặt thuộc tính tỷ lệ vectơ chuyển động thành (-960, 540) để MetalFX có thể diễn giải chính xác dữ liệu chuyển động của trò chơi của bạn.

00:10:26.000 --> 00:10:30.000
Bạn có thể sửa đổi các thuộc tính của đối tượng scaler thường xuyên như bạn muốn.

00:10:30.000 --> 00:10:35.000
Và gọi phương thức encode() để bắt đầu quá trình nâng cấp.

00:10:35.000 --> 00:10:39.000
Đối với mã vẽ trên mỗi khung hình của bạn, trước tiên hãy đặt thuộc tính resetHistory.

00:10:39.000 --> 00:10:44.000
Đặt điều này thành true khi ứng dụng của bạn tải khung hình đầu tiên hoặc khi có cảnh bị cắt.

00:10:44.000 --> 00:10:51.000
Sau đó đặt các kết cấu là đầu vào cho hiệu ứng, tiếp theo là kết cấu đầu ra.

00:10:51.000 --> 00:10:57.000
Tiếp theo, đặt thuộc tính reversedDepth để cho biết liệu các giá trị độ sâu có nằm trong ánh xạ reversed-Z hay không.

00:10:57.000 --> 00:11:03.000
Thuộc tính cuối cùng cần đặt trước khi mã hóa hiệu ứng chia tỷ lệ là độ lệch jitter hiện tại.

00:11:03.000 --> 00:11:07.000
Có được độ lệch jitter một cách chính xác là điều cần thiết cho chất lượng của đầu ra.

00:11:07.000 --> 00:11:11.000
Chúng ta hãy xem nhanh cách thiết lập độ lệch jitter.

00:11:11.000 --> 00:11:16.000
Ví dụ, bên trái là một hình tam giác được hiển thị với jitter.

00:11:16.000 --> 00:11:19.000
Ở bên phải là chế độ xem phóng to của một điểm ảnh.

00:11:19.000 --> 00:11:23.000
Mẫu được đặt tại (0.625, 0.78).

00:11:23.000 --> 00:11:26.000
Trung tâm điểm ảnh được biểu thị bằng dấu chấm màu cam.

00:11:26.000 --> 00:11:30.000
Nó nằm ở (0,5, 0,5).

00:11:30.000 --> 00:11:35.000
Trong ví dụ này, độ lệch jitter là (-0.125, -0.28).

00:11:35.000 --> 00:11:40.000
Lưu ý rằng độ lệch jitter luôn nằm trong khoảng từ -0,5 đến 0,5.

00:11:40.000 --> 00:11:49.000
Để xác minh rằng bạn đang cung cấp độ lệch jitter chính xác, hãy hiển thị một cảnh không có chuyển động của máy ảnh và đối tượng bằng cách sử dụng một chuỗi các độ lệch jitter khác nhau.

00:11:49.000 --> 00:11:53.000
Ở bên trái là một ví dụ khi độ lệch jitter không chính xác được chỉ định.

00:11:53.000 --> 00:11:57.000
Các vật thể tĩnh có thể dịch chuyển và các đường nhăn mờ.

00:11:57.000 --> 00:12:01.000
Ở bên phải là đầu ra khi độ lệch jitter chính xác được chỉ định.

00:12:01.000 --> 00:12:05.000
Các đối tượng giữ nguyên vị trí và các đường nhăn được giải quyết dần dần.

00:12:05.000 --> 00:12:16.000
Hiệu ứng MetalFX "AA tạm thời và nâng cấp" giúp tăng hiệu suất ứng dụng của bạn và mang lại chất lượng nâng cấp có thể so sánh với chất lượng của kết xuất độ phân giải mục tiêu gốc.

00:12:16.000 --> 00:12:25.000
Để có được chất lượng và hiệu suất tối ưu khi sử dụng cả hai hiệu ứng nâng cấp, bây giờ tôi sẽ đề cập đến các phương pháp hay nhất về triển khai.

00:12:25.000 --> 00:12:28.000
Bắt đầu với việc nâng cấp không gian.

00:12:28.000 --> 00:12:33.000
Để có chất lượng nâng cấp không gian tốt nhất, đầu vào màu phải được khử răng cưa và không có tiếng ồn.

00:12:33.000 --> 00:12:41.000
Điều này là do hiệu ứng nhiễu và hình ảnh bí danh ngăn cản việc xác định cạnh tốt, điều này sẽ làm xấu đi chất lượng nâng cấp không gian.

00:12:41.000 --> 00:12:46.000
Để có hiệu suất tốt nhất, hãy sử dụng chế độ xử lý màu nhận thức.

00:12:46.000 --> 00:12:53.000
Điều này có nghĩa là, màu đầu vào của bạn phải được ánh xạ tông màu, với các giá trị từ 0-1, trong không gian màu sRGB.

00:12:53.000 --> 00:12:58.000
Và cuối cùng, đặt độ lệch mip âm thích hợp cho chi tiết kết cấu cao hơn.

00:12:58.000 --> 00:13:08.000
Tính toán sai lệch mip được đề xuất để nâng cấp không gian là áp dụng log2 của chiều rộng độ phân giải kết xuất, chia cho chiều rộng độ phân giải mục tiêu.

00:13:08.000 --> 00:13:21.000
Ví dụ, chia tỷ lệ mỗi kích thước độ phân giải kết xuất lên 2x sẽ dẫn đến độ lệch -1 mip, trong khi chia tỷ lệ mỗi kích thước lên 1,5x sẽ dẫn đến độ lệch -0,58 mip.

00:13:21.000 --> 00:13:26.000
Lưu ý rằng mức mip thấp hơn có thể dẫn đến nhấp nháy cho các kết cấu có mẫu tần số cao.

00:13:26.000 --> 00:13:31.000
Bạn nên điều chỉnh độ lệch mip cho một số kết cấu nhất định nếu bạn phát hiện ra các hiện vật như vậy.

00:13:31.000 --> 00:13:36.000
Tôi sẽ nói tiếp theo về TemporalAA và nâng cấp các phương pháp hay nhất.

00:13:36.000 --> 00:13:43.000
Để có được chất lượng tốt nhất từ Temporal AA và nâng cấp, điều quan trọng là chọn một chuỗi rung tốt.

00:13:43.000 --> 00:13:50.000
Hãy tìm một chuỗi jitter sẽ cung cấp sự phân bố tốt các mẫu trên tất cả các điểm ảnh ở độ phân giải mục tiêu được nâng cấp.

00:13:50.000 --> 00:13:57.000
Thông thường, tám mẫu jittered trên mỗi pixel đầu ra tạo ra đầu ra nâng cấp chống răng cưa chất lượng cao.

00:13:57.000 --> 00:14:06.000
Trong trường hợp nâng cấp gấp 2 lần, khuyến nghị là sử dụng chuỗi Halton (2,3) với 32 jitters để tạo ra đầu vào màu jittered của bạn.

00:14:06.000 --> 00:14:15.000
Đây là biểu đồ của 32 vị trí mẫu đầu tiên từ chuỗi Halton (2,3), tạo ra khoảng tám mẫu trên mỗi pixel đầu ra.

00:14:15.000 --> 00:14:20.000
Nó cũng quan trọng để thiết lập độ lệch mip âm thích hợp cho chi tiết kết cấu cao hơn.

00:14:20.000 --> 00:14:31.000
Tính toán sai lệch mip được đề xuất cho AA thời gian và nâng cấp là áp dụng log2 của chiều rộng độ phân giải kết xuất, chia cho chiều rộng độ phân giải mục tiêu, trừ đi 1.

00:14:31.000 --> 00:14:44.000
Ví dụ, chia tỷ lệ mỗi kích thước độ phân giải kết xuất lên 2x sẽ dẫn đến độ lệch -2 mip, trong khi chia tỷ lệ mỗi kích thước lên 1,5x sẽ dẫn đến độ lệch -1,58 mip.

00:14:44.000 --> 00:14:50.000
Tiếp theo, tôi sẽ chỉ cho bạn các ví dụ về cách thiên vị mip ảnh hưởng đến đầu ra của bạn trong các tình huống khác nhau.

00:14:50.000 --> 00:15:00.000
Đây là MetalFX tạm thời AA và các đầu ra nâng cấp của cùng một cảnh bằng cách sử dụng độ lệch mip là 0, -1 và -2.

00:15:00.000 --> 00:15:09.000
Độ lệch Mip của -2 tạo ra đầu ra sắc nét và rõ ràng nhất, trong khi độ lệch mip của 0 tạo ra đầu ra mềm nhất và mờ nhất.

00:15:09.000 --> 00:15:14.000
Đây là ba kết xuất của bảng mạch sử dụng hiệu ứng nâng cấp thời gian.

00:15:14.000 --> 00:15:21.000
Từ trên xuống dưới, các giá trị thiên vị mip được áp dụng khi kết cấu lấy mẫu là 0, -1 và -2.

00:15:21.000 --> 00:15:31.000
Bởi vì kết cấu của bảng mạch có các mẫu tần số cao, chẳng hạn như dây dấu vết nhỏ của nó, độ lệch mip của -2 tạo ra hiệu ứng nhấp nháy và moire.

00:15:31.000 --> 00:15:39.000
Tuy nhiên, thiên vị mip của -1 làm giảm đáng kể những hiệu ứng này và thiên vị mip của 0 loại bỏ hoàn toàn chúng.

00:15:39.000 --> 00:15:43.000
Mức mip thấp hơn thường dẫn đến nhiều chi tiết hơn.

00:15:43.000 --> 00:15:50.000
Sử dụng đề xuất thiên vị mip của chúng tôi làm điểm khởi đầu, nhưng hãy chú ý khi chọn thiên vị mip cho các kết cấu có các mẫu tần số cao.

00:15:50.000 --> 00:16:00.000
Thực hiện theo các phương pháp này để đảm bảo đầu ra nâng cấp chất lượng cao, chống răng cưa từ MetalFX Temporal AA và nâng cấp.

00:16:00.000 --> 00:16:05.000
Cuối cùng, tôi sẽ đề cập đến phương pháp hay nhất về hiệu suất khi sử dụng MetalFX Upscaling.

00:16:05.000 --> 00:16:16.000
Để có được hiệu suất tốt nhất với MetalFX Upscaling, bạn nên cẩn thận tránh ràng buộc cùng một tài nguyên để đọc và viết trong hai kết xuất hoặc tính toán không phụ thuộc.

00:16:16.000 --> 00:16:18.000
Làm như vậy tạo ra sự phụ thuộc sai.

00:16:18.000 --> 00:16:22.000
Trong Metal, luôn luôn là một ý tưởng tốt để tránh sự phụ thuộc sai.

00:16:22.000 --> 00:16:27.000
Nhưng điều này đặc biệt quan trọng đối với MetalFX Upscaling, như tôi sẽ mô tả tiếp theo.

00:16:27.000 --> 00:16:30.000
Trong ví dụ này, có hai khung hình.

00:16:30.000 --> 00:16:37.000
Bóng tối và quá trình xử lý bài đăng hoàn toàn không liên quan và không có sự phụ thuộc vào tài nguyên.

00:16:37.000 --> 00:16:43.000
Kim loại sẽ chồng lên đường chuyền bóng của khung tiếp theo với đường chuyền xử lý sau của khung hiện tại.

00:16:43.000 --> 00:16:59.000
Tuy nhiên, nếu đường chuyền xử lý hậu kỳ ghi vào bộ đệm Metal trong khi đường chuyền bóng cũng đọc từ cùng một bộ đệm, Metal sẽ ngăn GPU chạy song song hai đường chuyền này để tránh nguy cơ tiềm ẩn khi đọc và ghi vào cùng một tài nguyên cùng một lúc.

00:16:59.000 --> 00:17:05.000
Sự phụ thuộc sai giữa các khung hình có thể ảnh hưởng tiêu cực đến hiệu suất của MetalFX Upscaling.

00:17:05.000 --> 00:17:14.000
Lưu ý rằng nếu không có sự phụ thuộc sai giữa các khung hình, đường chuyền bóng của khung tiếp theo có thể trùng lặp với Nâng cấp MetalFX của khung hình trước đó.

00:17:14.000 --> 00:17:23.000
Tuy nhiên, do sự phụ thuộc sai giữa các khung hình, việc mất hiệu suất hiện cũng bao gồm thời gian cần thiết để MetalFX Upscaling hoàn thành quá trình của nó.

00:17:23.000 --> 00:17:35.000
Tốt nhất, bạn nên đảm bảo rằng không có sự phụ thuộc sai giữa các khung để cho phép chồng chéo khối lượng công việc giữa các khung khác nhau, đảm bảo hiệu suất tối ưu nhất khi sử dụng MetalFX Upscaling.

00:17:35.000 --> 00:17:49.000
Trong ví dụ này, thay vào đó, bạn có thể tạo một bộ đệm riêng cho quá trình xử lý bài đăng và các đường chuyền bóng để ngăn chặn sự phụ thuộc sai, dẫn đến việc thực hiện song song các đường chuyền độc lập.

00:17:49.000 --> 00:17:55.000
Tránh các phụ thuộc sai là điều bạn luôn muốn ghi nhớ khi áp dụng MetalFX Upscaling.

00:17:55.000 --> 00:18:01.000
Khi quyết định chọn hiệu ứng nào trong hai hiệu ứng này, có một số cân nhắc bạn cũng nên ghi nhớ.

00:18:01.000 --> 00:18:07.000
Với chi phí che bóng và số điểm ảnh ngày càng tăng, AA tạm thời và nâng cấp vẫn tồn tại.

00:18:07.000 --> 00:18:13.000
Khấu hao các điểm ảnh tạm thời làm tăng độ trung thực của hình ảnh và tăng hiệu suất.

00:18:13.000 --> 00:18:26.000
Nếu bạn chưa có giải pháp AA thời gian tuyệt vời và có thể hiển thị bộ đệm màu sắc, chuyển động và độ sâu rung lắc, MetalFX AA thời gian và nâng cấp cung cấp một giải pháp tối ưu hóa nền tảng hấp dẫn mà bạn nên cân nhắc.

00:18:26.000 --> 00:18:34.000
Nếu bạn không có các đầu vào cần thiết hoặc đã có giải pháp AA được điều chỉnh tốt, hãy cân nhắc sử dụng nâng cấp không gian MetalFX.

00:18:34.000 --> 00:18:39.000
Với điều đó, hy vọng bây giờ bạn đã hiểu rõ hơn về hiệu ứng nâng cấp nào để chọn.

00:18:39.000 --> 00:18:44.000
Tiếp theo tôi sẽ trình bày các ví dụ về cả hai hiệu ứng này đang chạy trực tiếp trong các ứng dụng Metal.

00:18:44.000 --> 00:18:56.000
Đây là so sánh song song về cảnh "Bistro" từ mã mẫu "Kết xuất hiện đại với kim loại" của chúng tôi, có các thuật toán kết xuất thời gian thực, như tắc nghẽn môi trường xung quanh và sương mù thể tích.

00:18:56.000 --> 00:19:02.000
Kết xuất gốc ở 1080p ở bên trái so với đầu ra 4K với việc nâng cấp MetalFX Spatial ở bên phải.

00:19:02.000 --> 00:19:10.000
Lưu ý rằng mẫu này có giải pháp khử răng cưa theo thời gian riêng, mà chúng tôi sử dụng làm đầu vào để nâng cấp không gian MetalFX.

00:19:10.000 --> 00:19:15.000
Phóng to kỹ hơn ở chiếc xe tay ga...

00:19:15.000 --> 00:19:23.000
Ở bên trái, hình ảnh hơi mờ, trong khi ở bên phải, đầu ra được nâng cấp theo không gian dẫn đến hình ảnh sắc nét hơn với các cạnh sạch hơn.

00:19:23.000 --> 00:19:28.000
Đường thẳng trên thanh tay cầm được khử răng cưa độc đáo.

00:19:28.000 --> 00:19:32.000
Đường cong trên cơ thể cũng mượt mà hơn nhiều.

00:19:32.000 --> 00:19:35.000
Hãy so sánh hiệu suất.

00:19:35.000 --> 00:19:38.000
Ở bên trái là kết xuất gốc ở 4K.

00:19:38.000 --> 00:19:44.000
Ở bên phải là đầu ra 4K từ MetalFX Spatial upscaling.

00:19:44.000 --> 00:19:55.000
Khi máy ảnh di chuyển, kết xuất gốc ở bên trái đang chạy với tốc độ khung hình bị xáo trộn, trong khi đầu ra được nâng cấp theo không gian ở bên phải mượt mà hơn nhiều.

00:19:55.000 --> 00:20:01.000
Tiếp theo là so sánh song song của một cảnh dò tia với nhiều phản xạ và bóng tối.

00:20:01.000 --> 00:20:04.000
Ở bên trái là kết xuất gốc ở 1080p.

00:20:04.000 --> 00:20:10.000
Ở bên phải là đầu ra 4K với MetalFX Temporal AA và nâng cấp.

00:20:10.000 --> 00:20:14.000
Phóng to kỹ hơn ở đèn chùm...

00:20:14.000 --> 00:20:22.000
Đầu ra gốc ở bên trái có giao diện bí danh, trong khi đầu ra được nâng cấp tạm thời ở bên phải có các cạnh sắc nét với nhiều chi tiết tốt hơn.

00:20:22.000 --> 00:20:26.000
Cái bóng đẹp và sắc nét hơn là trông mờ.

00:20:26.000 --> 00:20:32.000
Và các chi tiết tốt trên đèn chùm bây giờ có thể được nhận ra.

00:20:32.000 --> 00:20:37.000
Tăng hiệu suất cũng rõ ràng với MetalFX Temporal AA và nâng cấp.

00:20:37.000 --> 00:20:40.000
Ở bên trái là kết xuất gốc ở 4K.

00:20:40.000 --> 00:20:45.000
Ở bên phải là đầu ra 4K với MetalFX Temporal AA và nâng cấp.

00:20:45.000 --> 00:21:06.000
Khi máy ảnh di chuyển, kết xuất gốc ở bên trái đang chạy ở tốc độ khung hình rất thấp, trong khi đầu ra được nâng cấp tạm thời ở bên phải mượt mà hơn nhiều.

00:21:06.000 --> 00:21:18.000
Các nhà phát triển trò chơi hàng đầu rất hào hứng với khả năng của MetalFX Upscaling và sẽ đưa "Grid: Legends", "Resident Evil: Village" và "No Man's Sky" lên Mac vào cuối năm nay.

00:21:18.000 --> 00:21:21.000
Tiếp theo, tôi sẽ chỉ cho bạn một số công việc sớm bằng cách sử dụng khuôn khổ.

00:21:21.000 --> 00:21:33.000
Trong cảnh này, chúng ta có thể thấy hình ảnh đáng kinh ngạc và lối chơi trôi chảy của "No Man's Sky" bằng cách sử dụng MetalFX Temporal AA và Upscaling.

00:21:33.000 --> 00:21:45.000
Tóm lại, MetalFX là một API mới tập trung vào việc nâng cấp quy mô.

00:21:45.000 --> 00:21:54.000
Tăng quy mô không gian rất dễ áp dụng và mang lại hiệu suất đáng kể, và bạn có thể sử dụng Temporal AA và nâng cấp để cung cấp kết xuất chất lượng cao hơn.

00:21:54.000 --> 00:22:01.000
Làm theo các phương pháp hay nhất mà tôi đã nói trước đó sẽ đảm bảo bạn tận dụng tối đa MetalFX Upscaling.

00:22:01.000 --> 00:22:02.000
Cảm ơn bạn đã xem.

00:22:02.000 --> 23:59:59.000
♪ ♪

