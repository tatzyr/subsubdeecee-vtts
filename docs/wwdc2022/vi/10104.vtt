WEBVTT

00:00:00.000 --> 00:00:03.000
♪ nhạc cụ hip hop ♪

00:00:03.000 --> 00:00:10.000
♪

00:00:10.000 --> 00:00:14.000
Xin chào, tên tôi là Jaideep Joshi, và tôi là kỹ sư phần mềm GPU tại Apple.

00:00:14.000 --> 00:00:23.000
Trong phiên này, tôi sẽ giới thiệu một tính năng mới trong Metal 3 sẽ đơn giản hóa và tối ưu hóa việc tải tài nguyên cho các trò chơi và ứng dụng của bạn.

00:00:23.000 --> 00:00:30.000
Tôi sẽ bắt đầu bằng cách chỉ cho bạn cách tính năng tải tài nguyên nhanh có thể phù hợp với quy trình tải tài sản của ứng dụng của bạn.

00:00:30.000 --> 00:00:36.000
Nó có một số tính năng chính khai thác các công nghệ lưu trữ mới trên các sản phẩm của Apple.

00:00:36.000 --> 00:00:43.000
Tải tài nguyên nhanh có một số tính năng nâng cao giải quyết các tình huống thú vị mà ứng dụng của bạn có thể gặp phải.

00:00:43.000 --> 00:00:52.000
Có một vài đề xuất thực hành tốt nhất mà bạn nên biết sẽ giúp bạn sử dụng hiệu quả các tính năng này trong ứng dụng của mình.

00:00:52.000 --> 00:01:02.000
Khi bạn thêm tải tài nguyên nhanh vào ứng dụng của mình, các công cụ như Metal System Trace và trình gỡ lỗi GPU có thể giúp lập hồ sơ và khắc phục các sự cố mà bạn có thể gặp phải.

00:01:02.000 --> 00:01:09.000
Cuối cùng, tôi sẽ xem qua một ví dụ cho thấy việc tải tài nguyên nhanh đang hoạt động.

00:01:09.000 --> 00:01:15.000
Vì vậy, đây là những gì bạn có thể làm với việc tải tài nguyên nhanh của Metal 3.

00:01:15.000 --> 00:01:30.000
Với khả năng tải tài nguyên nhanh của Metal 3, các trò chơi và ứng dụng của bạn có thể tải tài sản với độ trễ thấp và thông lượng cao bằng cách tận dụng kiến trúc bộ nhớ hợp nhất silicon của Apple và bộ nhớ SSD nhanh đi kèm với nền tảng của Apple.

00:01:30.000 --> 00:01:38.000
Bạn sẽ học được những cách tốt nhất để truyền dữ liệu và giảm thời gian tải để đảm bảo rằng nội dung trò chơi của bạn đã sẵn sàng đúng hạn.

00:01:38.000 --> 00:01:45.000
Một khía cạnh quan trọng của việc giảm thời gian tải là chỉ tải những gì bạn cần ở độ chi tiết nhỏ nhất có thể.

00:01:45.000 --> 00:01:56.000
Thông lượng cao và độ trễ thấp trong Metal 3 cho phép các ứng dụng của bạn phát trực tuyến các nội dung chất lượng cao hơn, bao gồm kết cấu, âm thanh và dữ liệu hình học.

00:01:56.000 --> 00:02:01.000
Bây giờ tôi sẽ hướng dẫn bạn một ví dụ về tải tài sản trong một trò chơi.

00:02:01.000 --> 00:02:10.000
Các trò chơi thường hiển thị màn hình tải khi chúng khởi động lần đầu tiên hoặc khi bắt đầu một cấp độ mới, vì vậy chúng có thể tải nội dung của trò chơi vào bộ nhớ.

00:02:10.000 --> 00:02:16.000
Khi người chơi di chuyển qua cấp độ, trò chơi sẽ tải thêm tài sản cho cảnh.

00:02:16.000 --> 00:02:25.000
Nhược điểm là người chơi phải đợi một thời gian dài trong khi trò chơi thực hiện nhiều yêu cầu đến hệ thống lưu trữ để tải tài sản trước.

00:02:25.000 --> 00:02:29.000
Thêm vào đó, những tài sản đó có thể có một dấu chân bộ nhớ lớn.

00:02:29.000 --> 00:02:34.000
Có một vài cách để cải thiện trải nghiệm này.

00:02:34.000 --> 00:02:40.000
Các trò chơi có thể cải thiện trải nghiệm này bằng cách tự động phát trực tuyến các đối tượng khi người chơi đến gần chúng hơn.

00:02:40.000 --> 00:02:49.000
Bằng cách này, trò chơi chỉ tải những gì nó cần lúc đầu và dần dần phát trực tuyến các tài nguyên khác khi người chơi di chuyển qua cấp độ.

00:02:49.000 --> 00:03:00.000
Ví dụ, trò chơi ban đầu tải bảng đen này ở độ phân giải thấp hơn, nhưng khi người chơi đi về phía nó, trò chơi sẽ tải phiên bản có độ phân giải cao hơn.

00:03:00.000 --> 00:03:05.000
Cách tiếp cận này làm giảm thời gian người chơi chờ đợi ở màn hình tải.

00:03:05.000 --> 00:03:16.000
Tuy nhiên, người chơi vẫn có thể nhìn thấy các vật phẩm có độ phân giải thấp hơn trong cảnh ngay cả khi chúng ở gần, vì mất quá nhiều thời gian để tải các phiên bản có độ phân giải cao hơn.

00:03:16.000 --> 00:03:23.000
Một cách để giải quyết vấn đề này là phát trực tuyến các phần nhỏ hơn của mỗi tài sản.

00:03:23.000 --> 00:03:32.000
Ví dụ, trò chơi của bạn chỉ có thể tải các vùng có thể nhìn thấy của cảnh với kết cấu thưa thớt truyền các ô thay vì toàn bộ cấp độ mip.

00:03:32.000 --> 00:03:37.000
Điều này làm giảm đáng kể lượng dữ liệu mà ứng dụng của bạn cần phát trực tuyến.

00:03:37.000 --> 00:03:41.000
Với cách tiếp cận đó, các yêu cầu tải trở nên nhỏ hơn và có nhiều yêu cầu hơn.

00:03:41.000 --> 00:03:48.000
Nhưng không sao, bởi vì phần cứng lưu trữ hiện đại có thể chạy nhiều yêu cầu tải cùng một lúc.

00:03:48.000 --> 00:03:55.000
Điều này có nghĩa là bạn có thể tăng độ phân giải và quy mô cảnh của mình mà không ảnh hưởng đến lối chơi.

00:03:55.000 --> 00:04:06.000
Cùng với việc đưa ra một số lượng lớn các yêu cầu tải nhỏ, bạn cũng có khả năng ưu tiên các yêu cầu tải của mình, để đảm bảo rằng các yêu cầu ưu tiên cao kết thúc kịp thời.

00:04:06.000 --> 00:04:16.000
Bây giờ tôi đã đề cập đến các cách để tăng độ trung thực trực quan của trò chơi trong khi giảm thời gian tải, tôi sẽ chỉ cho bạn cách tải tài nguyên nhanh của Metal 3 giúp bạn làm điều này.

00:04:16.000 --> 00:04:22.000
Tải tài nguyên nhanh là một API không đồng bộ tải tài nguyên từ bộ nhớ.

00:04:22.000 --> 00:04:29.000
Không giống như các API tải hiện có, luồng phát hành tải không cần phải đợi tải kết thúc.

00:04:29.000 --> 00:04:36.000
Các hoạt động tải thực hiện đồng thời để sử dụng tốt hơn thông lượng lưu trữ nhanh hơn.

00:04:36.000 --> 00:04:42.000
Bạn có thể tải hàng loạt các hoạt động để giảm thiểu hơn nữa chi phí tải tài nguyên.

00:04:42.000 --> 00:04:48.000
Và cuối cùng, với Metal 3, bạn có thể ưu tiên các hoạt động tải để có độ trễ thấp hơn.

00:04:48.000 --> 00:04:56.000
Bây giờ tôi sẽ chỉ cho bạn các tính năng chính sẽ giúp bạn xây dựng quy trình tải tài sản của mình, bắt đầu với các bước để tải tài nguyên.

00:04:56.000 --> 00:05:07.000
Có ba bước để tải tài nguyên: mở tệp, đưa ra các lệnh tải cần thiết và sau đó đồng bộ hóa các lệnh tải này với công việc kết xuất.

00:05:07.000 --> 00:05:10.000
Đây là cách bạn làm điều đó, bắt đầu bằng việc mở một tệp.

00:05:10.000 --> 00:05:16.000
Bạn mở một tệp hiện có bằng cách tạo một trình xử lý tệp với phiên bản thiết bị Metal.

00:05:16.000 --> 00:05:28.000
Ví dụ, mã này sử dụng phiên bản thiết bị Metal để tạo trình xử lý tệp bằng cách gọi phương thức makeIOHandle mới của nó với URL đường dẫn tệp.

00:05:28.000 --> 00:05:33.000
Khi bạn có một trình xử lý tệp, bạn có thể sử dụng nó để đưa ra các lệnh tải.

00:05:33.000 --> 00:05:40.000
Đây là một kịch bản điển hình trong một ứng dụng, nơi nó thực hiện các hoạt động tải và mã hóa công việc GPU.

00:05:40.000 --> 00:05:46.000
Với các API tải hiện có, ứng dụng phải đợi công việc tải kết thúc trước khi nó có thể mã hóa công việc kết xuất.

00:05:46.000 --> 00:05:51.000
Metal 3 cho phép ứng dụng của bạn thực hiện không đồng bộ các lệnh tải.

00:05:51.000 --> 00:05:55.000
Bắt đầu bằng cách tạo một hàng đợi lệnh Metal IO.

00:05:55.000 --> 00:06:02.000
Sau đó sử dụng hàng đợi đó để tạo bộ đệm lệnh IO và mã hóa các lệnh tải cho các bộ đệm đó.

00:06:02.000 --> 00:06:12.000
Tuy nhiên, vì bộ đệm lệnh thực thi không đồng bộ trên hàng đợi lệnh, ứng dụng của bạn không cần phải đợi các thao tác tải kết thúc.

00:06:12.000 --> 00:06:22.000
Trên thực tế, không chỉ tất cả các lệnh trong bộ đệm lệnh IO thực hiện đồng thời, các bộ đệm lệnh IO tự thực thi đồng thời và hoàn thành không theo thứ tự.

00:06:22.000 --> 00:06:30.000
Mô hình thực thi đồng thời này sử dụng tốt hơn phần cứng lưu trữ nhanh hơn bằng cách tối đa hóa thông lượng.

00:06:30.000 --> 00:06:49.000
Bạn có thể mã hóa ba loại lệnh IO thành bộ đệm lệnh: loadTexture, tải vào kết cấu Metal để phát trực tuyến kết cấu; loadBuffer, tải vào bộ đệm Metal để phát trực tuyến cảnh hoặc dữ liệu hình học; và loadBytes, tải vào bộ nhớ có thể truy cập CPU.

00:06:49.000 --> 00:06:53.000
Bạn tạo bộ đệm lệnh IO từ hàng đợi lệnh IO.

00:06:53.000 --> 00:06:59.000
Để tạo một hàng đợi, trước tiên hãy tạo và định cấu hình một bộ mô tả hàng đợi lệnh IO.

00:06:59.000 --> 00:07:08.000
Theo mặc định, các hàng đợi là đồng thời, nhưng bạn cũng có thể đặt chúng để chạy bộ đệm lệnh tuần tự và hoàn toàn theo thứ tự.

00:07:08.000 --> 00:07:16.000
Sau đó chuyển bộ mô tả hàng đợi cho phương thức makeIOCommandQueue của phiên bản thiết bị Metal.

00:07:16.000 --> 00:07:22.000
Tạo bộ đệm lệnh IO bằng cách gọi phương thức makeCommandBuffer của hàng đợi lệnh.

00:07:22.000 --> 00:07:29.000
Sau đó sử dụng bộ đệm lệnh đó để mã hóa các lệnh tải tải kết cấu và bộ đệm.

00:07:29.000 --> 00:07:33.000
Lớp xác thực của Metal sẽ bắt lỗi mã hóa trong thời gian chạy.

00:07:33.000 --> 00:07:39.000
Các lệnh tải là những gì sử dụng phiên bản fileHandle được tạo trước đó.

00:07:39.000 --> 00:07:49.000
Khi bạn hoàn tất việc thêm các lệnh tải vào bộ đệm lệnh, hãy gửi nó vào hàng đợi để thực thi bằng cách gọi phương thức cam kết của bộ đệm lệnh.

00:07:49.000 --> 00:08:01.000
Bây giờ tôi đã đề cập đến cách tạo hàng đợi lệnh IO, bộ đệm lệnh, phát hành lệnh tải và gửi chúng vào hàng đợi, tôi muốn chỉ cho bạn cách bạn có thể đồng bộ hóa công việc tải với công việc GPU khác.

00:08:01.000 --> 00:08:08.000
Một ứng dụng thường bắt đầu công việc kết xuất sau khi hoàn thành việc tải tài nguyên cho kết xuất đó.

00:08:08.000 --> 00:08:17.000
Nhưng một ứng dụng sử dụng tải tài nguyên nhanh cần một cách để đồng bộ hóa hàng đợi lệnh IO với hàng đợi lệnh kết xuất.

00:08:17.000 --> 00:08:21.000
Bạn có thể đồng bộ hóa các hàng đợi này với một sự kiện được chia sẻ Metal.

00:08:21.000 --> 00:08:30.000
Các sự kiện hared kim loại cho phép bạn đồng bộ đệm lệnh từ hàng đợi IO của mình với bộ đệm lệnh từ hàng đợi kết xuất của bạn.

00:08:30.000 --> 00:08:35.000
Bạn có thể yêu cầu bộ đệm lệnh chờ sự kiện được chia sẻ bằng cách mã hóa lệnh waitEvent.

00:08:35.000 --> 00:08:42.000
Tương tự, bạn có thể yêu cầu bộ đệm lệnh đó báo hiệu một sự kiện được chia sẻ bằng cách mã hóa lệnh signalEvent.

00:08:42.000 --> 00:08:50.000
Metal đảm bảo rằng tất cả các lệnh IO trong bộ đệm lệnh đã hoàn tất trước khi nó báo hiệu sự kiện được chia sẻ.

00:08:50.000 --> 00:08:55.000
Để đồng bộ hóa giữa các bộ đệm lệnh, trước tiên bạn cần một sự kiện được chia sẻ Metal.

00:08:55.000 --> 00:09:01.000
Bạn có thể yêu cầu bộ đệm lệnh chờ một sự kiện được chia sẻ bằng cách gọi phương thức waitForEvent của nó.

00:09:01.000 --> 00:09:07.000
Tương tự, bạn có thể yêu cầu bộ đệm lệnh báo hiệu một sự kiện được chia sẻ bằng cách gọi phương thức signalEvent của nó.

00:09:07.000 --> 00:09:15.000
Bạn có thể thêm logic tương tự vào bộ đệm lệnh GPU tương ứng để nó chờ bộ đệm lệnh IO báo hiệu cùng một sự kiện được chia sẻ.

00:09:15.000 --> 00:09:21.000
Tóm lại, đây là các tính năng chính và API tải tài nguyên trong các ứng dụng Metal của bạn.

00:09:21.000 --> 00:09:25.000
Mở một tệp bằng cách tạo một tay cầm tệp Metal.

00:09:25.000 --> 00:09:30.000
Phát hành các lệnh tải bằng cách tạo hàng đợi lệnh IO và bộ đệm lệnh IO.

00:09:30.000 --> 00:09:36.000
Sau đó, mã hóa các lệnh tải thành bộ đệm lệnh để thực thi trên hàng đợi.

00:09:36.000 --> 00:09:43.000
Và cuối cùng, sử dụng các lệnh wait và signalEvent với các sự kiện được chia sẻ Metal để đồng bộ hóa việc tải và kết xuất.

00:09:43.000 --> 00:09:48.000
Bây giờ, tôi sẽ xem xét một vài tính năng nâng cao mà bạn có thể thấy hữu ích.

00:09:48.000 --> 00:09:56.000
Đây là một kịch bản điển hình mà một trò chơi không thể đặt toàn bộ bản đồ của nó vào bộ nhớ, đó là lý do tại sao nó chia nhỏ bản đồ thành các khu vực.

00:09:56.000 --> 00:10:02.000
Khi người chơi tiến bộ qua bản đồ, trò chơi bắt đầu tải trước các khu vực của bản đồ.

00:10:02.000 --> 00:10:10.000
Dựa trên hướng của người chơi, trò chơi xác định rằng các khu vực tốt nhất để tải trước là các khu vực tây bắc, tây và tây nam.

00:10:10.000 --> 00:10:18.000
Tuy nhiên, một khi người chơi di chuyển đến khu vực phía tây và bắt đầu đi về phía nam, việc tải trước khu vực phía tây bắc không còn có lợi nữa.

00:10:18.000 --> 00:10:25.000
Để giảm độ trễ của tải trong tương lai, Metal 3 cho phép bạn cố gắng hủy hoạt động tải.

00:10:25.000 --> 00:10:29.000
Hãy xem làm thế nào để làm điều đó trong thực tế.

00:10:29.000 --> 00:10:36.000
Khi người chơi ở khu vực trung tâm, hãy mã hóa và cam kết bộ đệm lệnh IO cho ba khu vực.

00:10:36.000 --> 00:10:44.000
Sau đó, khi người chơi ở khu vực phía tây và đi về phía nam, hãy sử dụng phương pháp tryCancel để hủy tải cho khu vực phía tây bắc.

00:10:44.000 --> 00:10:51.000
Việc hủy bỏ ở độ chi tiết bộ đệm lệnh, vì vậy bạn có thể hủy bộ đệm lệnh giữa quá trình thực thi.

00:10:51.000 --> 00:11:00.000
Nếu tại một thời điểm nào đó sau đó, bạn muốn biết liệu khu vực đã được tải đầy đủ hay chưa, bạn có thể kiểm tra trạng thái của bộ đệm lệnh.

00:11:00.000 --> 00:11:05.000
Metal 3 cũng cho phép bạn ưu tiên công việc IO của mình.

00:11:05.000 --> 00:11:14.000
Hãy xem xét một kịch bản trò chơi trong đó người chơi dịch chuyển tức thời đến một phần mới của cảnh và trò chơi của bạn bắt đầu phát trực tuyến với số lượng lớn tài sản đồ họa.

00:11:14.000 --> 00:11:19.000
Đồng thời, trò chơi cần chơi hiệu ứng âm thanh dịch chuyển tức thời.

00:11:19.000 --> 00:11:25.000
Tải tài nguyên nhanh cho phép bạn tải tất cả tài sản của ứng dụng, bao gồm cả dữ liệu âm thanh.

00:11:25.000 --> 00:11:32.000
Để tải âm thanh, bạn có thể sử dụng lệnh loadBytes đã thảo luận trước đó để tải vào bộ nhớ được phân bổ cho ứng dụng.

00:11:32.000 --> 00:11:40.000
Trong ví dụ này, bộ đệm lệnh IO kết cấu và âm thanh được thực thi đồng thời trên một hàng đợi lệnh IO duy nhất.

00:11:40.000 --> 00:11:45.000
Sơ đồ đơn giản này cho thấy các yêu cầu ở lớp lưu trữ.

00:11:45.000 --> 00:11:50.000
Hệ thống lưu trữ có thể thực hiện song song cả yêu cầu tải âm thanh và kết cấu.

00:11:50.000 --> 00:11:58.000
Để tránh âm thanh bị trì hoãn, điều quan trọng là hệ thống phát trực tuyến có thể ưu tiên các yêu cầu âm thanh hơn các yêu cầu kết cấu.

00:11:58.000 --> 00:12:06.000
Để ưu tiên các yêu cầu âm thanh, bạn có thể tạo một hàng đợi lệnh IO riêng biệt và đặt mức độ ưu tiên của nó ở mức cao.

00:12:06.000 --> 00:12:15.000
Hệ thống lưu trữ sẽ đảm bảo rằng các yêu cầu IO ưu tiên cao có độ trễ thấp hơn và được ưu tiên hơn các yêu cầu khác.

00:12:15.000 --> 00:12:28.000
Sau khi tạo một hàng đợi ưu tiên cao riêng biệt cho các tài sản âm thanh, thời gian thực hiện các yêu cầu tải âm thanh đã nhỏ hơn, trong khi thời gian thực hiện các yêu cầu tải kết cấu song song ngày càng lớn hơn.

00:12:28.000 --> 00:12:31.000
Đây là cách bạn tạo một hàng đợi ưu tiên cao.

00:12:31.000 --> 00:12:36.000
Chỉ cần đặt thuộc tính ưu tiên của bộ mô tả hàng đợi lệnh ở mức cao.

00:12:36.000 --> 00:12:44.000
Bạn cũng có thể đặt mức độ ưu tiên thành bình thường hoặc thấp, sau đó tạo một hàng đợi lệnh IO mới từ bộ mô tả như bình thường.

00:12:44.000 --> 00:12:49.000
Chỉ cần nhớ rằng bạn không thể thay đổi mức độ ưu tiên của hàng đợi sau khi bạn tạo nó.

00:12:49.000 --> 00:12:56.000
Khi bạn thêm tải tài nguyên nhanh vào ứng dụng của mình, đây là một số phương pháp hay nhất cần ghi nhớ.

00:12:56.000 --> 00:12:59.000
Đầu tiên, hãy cân nhắc việc nén tài sản của bạn.

00:12:59.000 --> 00:13:05.000
Bạn có thể giảm dung lượng đĩa của ứng dụng bằng cách sử dụng tính năng nén tích hợp hoặc tùy chỉnh.

00:13:05.000 --> 00:13:10.000
Nén cho phép bạn đánh đổi hiệu suất thời gian chạy lấy dấu chân đĩa nhỏ hơn.

00:13:10.000 --> 00:13:17.000
Ngoài ra, bạn có thể cải thiện thông lượng lưu trữ bằng cách điều chỉnh kích thước trang thưa thớt khi sử dụng kết cấu thưa thớt.

00:13:17.000 --> 00:13:22.000
Tôi sẽ xem xét từng thứ này chi tiết hơn, bắt đầu bằng việc nén.

00:13:22.000 --> 00:13:28.000
Bạn có thể sử dụng API của Metals 3 để nén các tệp tài sản của mình ngoại tuyến.

00:13:28.000 --> 00:13:35.000
Đầu tiên, tạo một ngữ cảnh nén và cấu hình nó với kích thước đoạn và phương pháp nén.

00:13:35.000 --> 00:13:42.000
Sau đó chuyển các phần của tệp nội dung của bạn vào ngữ cảnh để tạo ra một phiên bản nén duy nhất của tất cả các tệp của bạn.

00:13:42.000 --> 00:13:51.000
Bối cảnh nén hoạt động bằng cách phân đoạn tất cả dữ liệu và nén nó bằng codec bạn chọn và lưu trữ nó vào một tệp gói.

00:13:51.000 --> 00:14:03.000
Trong ví dụ này, ngữ cảnh nén dữ liệu thành các đoạn 64K, nhưng bạn có thể chọn kích thước đoạn phù hợp dựa trên kích thước và loại dữ liệu bạn muốn nén.

00:14:03.000 --> 00:14:08.000
Đây là cách bạn sử dụng API nén trong Metal 3.

00:14:08.000 --> 00:14:16.000
Đầu tiên, tạo một ngữ cảnh nén bằng cách cung cấp một đường dẫn để tạo tệp nén, một phương pháp nén và kích thước đoạn.

00:14:16.000 --> 00:14:20.000
Tiếp theo, lấy dữ liệu tệp và thêm nó vào ngữ cảnh.

00:14:20.000 --> 00:14:24.000
Ở đây, dữ liệu tệp nằm trong một đối tượng NSData.

00:14:24.000 --> 00:14:31.000
Bạn có thể nối thêm dữ liệu từ các tệp khác nhau bằng cách thực hiện nhiều cuộc gọi để nối thêm dữ liệu.

00:14:31.000 --> 00:14:40.000
Khi bạn thêm dữ liệu xong, hãy hoàn thiện và lưu tệp nén bằng cách gọi chức năng ngữ cảnh nén tuôn ra và phá hủy.

00:14:40.000 --> 00:14:45.000
Bạn có thể mở và truy cập tệp nén bằng cách tạo một trình xử lý tệp.

00:14:45.000 --> 00:14:49.000
Trình xử lý tệp này được sử dụng khi đưa ra các lệnh tải.

00:14:49.000 --> 00:15:00.000
Đối với các tệp nén, Metal 3 thực hiện giải nén nội tuyến, bằng cách dịch các phần bù thành danh sách các khối cần giải nén và tải chúng vào tài nguyên của bạn.

00:15:00.000 --> 00:15:05.000
Bạn tạo một trình xử lý tệp với một phiên bản thiết bị Metal.

00:15:05.000 --> 00:15:16.000
Ví dụ, mã này sử dụng phiên bản thiết bị Metal để tạo trình xử lý tệp bằng cách cung cấp đường dẫn tệp nén cho phương thức makeIOHandle mà tôi đã đề cập trước đó.

00:15:16.000 --> 00:15:21.000
Đối với các tệp nén, một tham số bổ sung là phương pháp nén.

00:15:21.000 --> 00:15:26.000
Đây là cùng một phương pháp nén mà bạn đã sử dụng tại thời điểm tạo tệp nén.

00:15:26.000 --> 00:15:36.000
Bây giờ, tôi sẽ xem xét các phương pháp nén khác nhau được hỗ trợ và các đặc điểm của từng phương pháp, vì vậy bạn có thể hiểu rõ hơn về cách chọn giữa chúng.

00:15:36.000 --> 00:15:42.000
Sử dụng LZ4 khi tốc độ giải nén là rất quan trọng và ứng dụng của bạn có thể đủ dung lượng đĩa lớn.

00:15:42.000 --> 00:15:51.000
Nếu sự cân bằng giữa tốc độ codec và tỷ lệ nén quan trọng đối với bạn, hãy sử dụng ZLib, LZBitmap hoặc LZFSE.

00:15:51.000 --> 00:15:56.000
Trong số các codec cân bằng, ZLib hoạt động tốt hơn với các thiết bị không phải của Apple.

00:15:56.000 --> 00:16:04.000
LZBitmap mã hóa và giải mã nhanh, và LZFSE có tỷ lệ nén cao.

00:16:04.000 --> 00:16:14.000
Nếu bạn cần tỷ lệ nén tốt nhất, hãy cân nhắc sử dụng codec LZMA, nếu ứng dụng của bạn có thể đủ khả năng thêm thời gian để giải mã tài sản.

00:16:14.000 --> 00:16:18.000
Cũng có thể sử dụng sơ đồ nén của riêng bạn.

00:16:18.000 --> 00:16:23.000
Bạn có thể có những trường hợp mà dữ liệu của bạn được hưởng lợi từ một codec nén tùy chỉnh.

00:16:23.000 --> 00:16:33.000
Trong trường hợp đó, bạn có thể thay thế ngữ cảnh nén bằng máy nén của riêng mình và dịch các phần bù và tự mình thực hiện giải nén trong thời gian chạy.

00:16:33.000 --> 00:16:40.000
Bây giờ bạn đã thấy cách sử dụng nén để giảm dấu chân đĩa, hãy xem xét điều chỉnh kích thước trang thưa thớt.

00:16:40.000 --> 00:16:47.000
Các phiên bản trước của Metal hỗ trợ tải gạch đến kết cấu thưa thớt ở độ chi tiết 16K.

00:16:47.000 --> 00:16:54.000
Với Metal 3, bạn có thể chỉ định hai kích thước gạch thưa thớt mới: 64 và 256K.

00:16:54.000 --> 00:17:02.000
Những kích thước mới này cho phép bạn truyền phát kết cấu ở độ chi tiết lớn hơn để sử dụng tốt hơn và bão hòa phần cứng lưu trữ.

00:17:02.000 --> 00:17:16.000
Lưu ý rằng có sự cân bằng giữa việc phát trực tuyến các kích thước ô lớn hơn và lượng dữ liệu bạn phát trực tuyến, vì vậy bạn sẽ phải thử nghiệm để xem kích thước nào hoạt động tốt nhất với ứng dụng của mình và kết cấu thưa thớt của nó.

00:17:16.000 --> 00:17:24.000
Tiếp theo, hãy xem cách bạn có thể sử dụng bộ Công cụ Nhà phát triển Kim loại để lập hồ sơ và gỡ lỗi tải tài nguyên nhanh trong ứng dụng của mình.

00:17:24.000 --> 00:17:28.000
Xcode 14 bao gồm hỗ trợ đầy đủ cho việc tải tài nguyên nhanh chóng.

00:17:28.000 --> 00:17:39.000
Từ hồ sơ thời gian chạy với Metal System Trace đến kiểm tra API và phân tích phụ thuộc nâng cao với trình gỡ lỗi Metal.

00:17:39.000 --> 00:17:42.000
Hãy bắt đầu với hồ sơ thời gian chạy.

00:17:42.000 --> 00:17:48.000
Trong Xcode 14, Instruments có thể lập hồ sơ tải tài nguyên nhanh chóng với mẫu Metal System Trace.

00:17:48.000 --> 00:17:56.000
Instruments là một công cụ phân tích và lập hồ sơ mạnh mẽ sẽ giúp bạn đạt được hiệu suất tốt nhất trong ứng dụng Metal của mình.

00:17:56.000 --> 00:18:02.000
Mẫu Metal System Trace cho phép bạn kiểm tra khi nào các hoạt động tải được mã hóa và thực thi.

00:18:02.000 --> 00:18:10.000
Bạn sẽ có thể hiểu cách chúng tương quan với hoạt động mà ứng dụng của bạn đang thực hiện trên cả CPU và GPU.

00:18:10.000 --> 00:18:23.000
Để tìm hiểu cách lập hồ sơ ứng dụng Metal của bạn với Instruments, vui lòng xem các phiên trước, "Tối ưu hóa ứng dụng và trò chơi Metal với bộ đếm GPU" và "Tối ưu hóa các trò chơi cao cấp cho GPU của Apple."

00:18:23.000 --> 00:18:26.000
Bây giờ, hãy chuyển bánh răng sang gỡ lỗi.

00:18:26.000 --> 00:18:33.000
Với trình gỡ lỗi Metal trong Xcode 14, giờ đây bạn có thể phân tích việc sử dụng API tải tài nguyên nhanh mới trong trò chơi của mình.

00:18:33.000 --> 00:18:40.000
Khi bạn chụp khung hình, bạn sẽ có thể kiểm tra tất cả các lệnh gọi API tải tài nguyên nhanh.

00:18:40.000 --> 00:18:46.000
Từ bộ đệm lệnh IO được tạo đến các hoạt động tải đã được phát hành.

00:18:46.000 --> 00:18:53.000
Bây giờ bạn có thể kiểm tra trực quan các phụ thuộc tải tài nguyên nhanh với trình xem Phụ thuộc mới.

00:18:53.000 --> 00:19:01.000
Trình xem Phụ thuộc cung cấp tổng quan chi tiết về sự phụ thuộc tài nguyên giữa bộ đệm lệnh IO và thẻ Metal.

00:19:01.000 --> 00:19:13.000
Từ đây, bạn có thể sử dụng tất cả các tính năng trong trình xem Phụ thuộc mới, chẳng hạn như các cạnh đồng bộ hóa mới và lọc đồ thị, để tìm hiểu sâu và tối ưu hóa các phụ thuộc tải tài nguyên của bạn.

00:19:13.000 --> 00:19:22.000
Để tìm hiểu thêm về trình xem Dependency mới trong Xcode 14, vui lòng xem phiên "Go bindless with Metal 3" năm nay.

00:19:22.000 --> 00:19:26.000
Bây giờ, hãy xem xét việc tải tài nguyên nhanh đang hoạt động.

00:19:26.000 --> 00:19:35.000
Đây là một cảnh thử nghiệm sử dụng các API tải tài nguyên nhanh mới để truyền dữ liệu kết cấu bằng cách sử dụng các kết cấu thưa thớt với kích thước ô 16 kilobyte.

00:19:35.000 --> 00:19:38.000
Video này là từ MacBook Pro với chip M1 Pro.

00:19:38.000 --> 00:19:49.000
Hệ thống phát trực tuyến truy vấn các bộ đếm truy cập kết cấu thưa thớt của GPU để xác định hai thứ: các ô mà nó đã lấy mẫu nhưng không tải và các ô đã tải mà ứng dụng không sử dụng.

00:19:49.000 --> 00:19:57.000
Ứng dụng sử dụng thông tin này để mã hóa danh sách tải cho các ô mà nó cần và danh sách các lần trục xuất cho các ô mà nó không cần.

00:19:57.000 --> 00:20:03.000
Bằng cách đó, bộ làm việc chỉ chứa các ô mà ứng dụng hầu như có khả năng sử dụng.

00:20:03.000 --> 00:20:11.000
Nếu người chơi quyết định di chuyển đến một phần khác của cảnh, ứng dụng cần phát trực tuyến trong một bộ kết cấu độ phân giải cao hoàn toàn mới.

00:20:11.000 --> 00:20:17.000
Nếu hệ thống phát trực tuyến đủ nhanh, người chơi sẽ không nhận thấy việc phát trực tuyến này xảy ra.

00:20:17.000 --> 00:20:21.000
Nếu tôi tạm dừng cảnh, bạn có thể quan sát sự khác biệt của hình ảnh rõ ràng hơn.

00:20:21.000 --> 00:20:26.000
Phía bên trái đang tải các ô thưa thớt trên một luồng duy nhất bằng API pread.

00:20:26.000 --> 00:20:31.000
Phía bên phải đang tải các ô thưa thớt bằng cách sử dụng API tải tài nguyên nhanh.

00:20:31.000 --> 00:20:36.000
Khi người chơi bước vào cảnh, hầu hết các kết cấu chưa được tải đầy đủ.

00:20:36.000 --> 00:20:42.000
Sau khi tải xong, phiên bản có độ phân giải cao cuối cùng của kết cấu sẽ hiển thị.

00:20:42.000 --> 00:20:51.000
Nếu tôi quay lại phần đầu của cảnh này và làm chậm nó, sẽ dễ dàng nhận thấy những cải tiến mà việc tải tài nguyên nhanh cung cấp.

00:20:51.000 --> 00:20:59.000
Để làm nổi bật sự khác biệt, kết xuất này đánh dấu các ô mà ứng dụng chưa tải với tông màu đỏ.

00:20:59.000 --> 00:21:05.000
Lúc đầu, cảnh cho thấy ứng dụng chưa tải hầu hết các ô.

00:21:05.000 --> 00:21:18.000
Tuy nhiên, khi người chơi bước vào cảnh, tải tài nguyên nhanh sẽ cải thiện việc tải các ô có độ phân giải cao và giảm thiểu độ trễ so với phiên bản pread đơn luồng.

00:21:18.000 --> 00:21:28.000
Tải tài nguyên nhanh của Metal 3 giúp bạn xây dựng một hệ thống phân luồng tài sản mạnh mẽ và hiệu quả cho phép ứng dụng của bạn tận dụng các công nghệ lưu trữ mới nhất.

00:21:28.000 --> 00:21:35.000
Sử dụng nó để giảm thời gian tải bằng cách phát trực tuyến nội dung kịp thời, bao gồm cả hình ảnh chất lượng cao hơn.

00:21:35.000 --> 00:21:43.000
Sử dụng các sự kiện được chia sẻ của Metal để tải tài sản không đồng bộ trong khi GPU hiển thị cảnh.

00:21:43.000 --> 00:21:51.000
Đối với các tài sản mà ứng dụng của bạn cần vội vàng, hãy giảm thiểu độ trễ bằng cách tạo hàng đợi lệnh với mức độ ưu tiên cao hơn.

00:21:51.000 --> 00:21:56.000
Và hãy nhớ rằng, giữ cho hệ thống lưu trữ bận rộn bằng cách gửi lệnh tải sớm.

00:21:56.000 --> 00:22:00.000
Bạn luôn có thể hủy những thứ bạn không cần.

00:22:00.000 --> 00:22:09.000
Tải tài nguyên nhanh trong Metal 3 giới thiệu những cách mới để khai thác sức mạnh của phần cứng lưu trữ hiện đại để tải tài sản thông lượng cao.

00:22:09.000 --> 00:22:15.000
Tôi nóng lòng muốn xem cách bạn sử dụng các tính năng này để cải thiện chất lượng hình ảnh và khả năng phản hồi của ứng dụng.

00:22:15.000 --> 00:22:17.000
Cảm ơn vì đã xem.

00:22:17.000 --> 23:59:59.000
♪

