WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:13.000
Paul: Xin chào, và chào mừng bạn đến với Soạn Bố cục Tùy chỉnh với SwiftUI.

00:00:13.000 --> 00:00:16.000
Tôi là Paul, và tôi làm việc trên tài liệu dành cho nhà phát triển.

00:00:16.000 --> 00:00:22.000
SwiftUI cung cấp một tập hợp phong phú các khối xây dựng mà bạn sử dụng để soạn giao diện ứng dụng của mình.

00:00:22.000 --> 00:00:31.000
Bạn có thể kết hợp các chế độ xem tích hợp hiển thị các yếu tố như văn bản, hình ảnh và đồ họa để tạo các chế độ xem tổng hợp, tùy chỉnh.

00:00:31.000 --> 00:00:39.000
Để sắp xếp tất cả các yếu tố này trong các nhóm phức tạp hơn bao giờ hết, SwiftUI cung cấp các công cụ bố cục.

00:00:39.000 --> 00:00:51.000
Các vùng chứa như ngăn xếp ngang và dọc cho phép bạn cho SwiftUI biết nơi đặt các chế độ xem tương đối với nhau, trong khi các công cụ sửa đổi chế độ xem cung cấp cho bạn quyền kiểm soát bổ sung đối với những thứ như khoảng cách và căn chỉnh.

00:00:51.000 --> 00:00:59.000
Trong buổi nói chuyện này, tôi sẽ giới thiệu một số công cụ mới giúp một số bố cục phổ biến thậm chí còn dễ xây dựng hơn và có thể tạo ra các bố cục phức tạp hơn.

00:00:59.000 --> 00:01:04.000
Trên đường đi, tôi sẽ cung cấp cho bạn một số mẹo để làm việc với bố cục trong SwiftUI.

00:01:04.000 --> 00:01:12.000
Tôi sẽ bắt đầu bằng cách hiển thị cho bạn một thành viên mới của họ lưới hoàn hảo cho bố cục hai chiều khi bạn có một bộ chế độ xem tĩnh để hiển thị.

00:01:12.000 --> 00:01:21.000
Tiếp theo tôi sẽ nói về cách bạn có thể tạo một loại vùng chứa chế độ xem tùy chỉnh cho phép bạn tương tác trực tiếp với công cụ bố cục, sử dụng giao thức bố cục mới.

00:01:21.000 --> 00:01:31.000
Sau đó, tôi sẽ nói về ViewThatFits, một loại vùng chứa tự động chọn từ một bộ sưu tập các chế độ xem cho chế độ xem, tốt, phù hợp với không gian có sẵn.

00:01:31.000 --> 00:01:38.000
Và cuối cùng, tôi sẽ chỉ cho bạn cách thêm chuyển tiếp liền mạch giữa các loại bố cục bằng AnyLayout.

00:01:38.000 --> 00:01:44.000
Để xem tất cả các tính năng mới này đang hoạt động, chúng ta hãy xem một ứng dụng mà tôi đang làm việc.

00:01:44.000 --> 00:01:50.000
Trong những năm gần đây, đã có một số cuộc tranh luận giữa một số đồng nghiệp của tôi về việc ai là người bạn đồng hành lông xù tốt nhất.

00:01:50.000 --> 00:01:58.000
Tôi có ý kiến của riêng mình, nhưng tôi tò mò muốn xem liệu chúng ta có thể đi đến sự đồng thuận hay không, vì vậy tôi quyết định tạo một ứng dụng để tham gia một cuộc thăm dò ý kiến.

00:01:58.000 --> 00:02:03.000
Và tôi cũng muốn bao gồm những người bị dị ứng lông thú, vì vậy tôi sẽ đưa ra một lựa chọn bổ sung.

00:02:03.000 --> 00:02:14.000
Bây giờ, tôi thích thực hiện hầu hết các thiết kế giao diện của mình trong SwiftUI, bởi vì nó rất dễ dàng để tạo mẫu bằng cách sử dụng các bản xem trước, nhưng như một điểm khởi đầu, tôi đã vẽ một bản phác thảo nhanh về những gì tôi đang hướng tới.

00:02:14.000 --> 00:02:20.000
Tôi hy vọng cuộc bỏ phiếu sẽ diễn ra trong một khoảng thời gian, vì vậy tôi muốn một bảng xếp hạng ở giữa hiển thị bảng xếp hạng hiện tại.

00:02:20.000 --> 00:02:22.000
Tôi sẽ đặt các nút để bỏ phiếu ở dưới cùng.

00:02:22.000 --> 00:02:28.000
Và ở trên cùng, tôi sẽ hiển thị một số hình ảnh về những gì mọi người đang bỏ phiếu.

00:02:28.000 --> 00:02:30.000
Được rồi, điều đầu tiên tôi muốn làm là xây dựng bảng xếp hạng.

00:02:30.000 --> 00:02:33.000
Vì vậy, chúng ta hãy xem xét kỹ hơn về điều đó.

00:02:33.000 --> 00:02:43.000
Bảng xếp hạng là một lưới các phần tử hai chiều với các hàng cho mỗi ứng cử viên và các cột hiển thị tên, tỷ lệ phần trăm và số phiếu bầu.

00:02:43.000 --> 00:02:47.000
Tôi có một vài điều cụ thể mà tôi muốn đạt được ở đây.

00:02:47.000 --> 00:02:58.000
Đầu tiên, tôi muốn hai cột văn bản chỉ rộng như chúng cần để chứa ô rộng nhất trong mỗi trường hợp vì tôi muốn các chế độ xem tiến trình đại diện cho tỷ lệ phần trăm nhận được càng nhiều không gian càng tốt.

00:02:58.000 --> 00:03:09.000
Và điều này cần phải đúng cho dù số lượng lớn đến đâu đối với bạn bè của tôi nói các ngôn ngữ khác hoặc cho bất kỳ ai sử dụng các kích thước văn bản khác nhau trên thiết bị của họ.

00:03:09.000 --> 00:03:14.000
Thứ hai, tôi muốn các tên được căn chỉnh cạnh hàng đầu, nhưng số lượng được căn chỉnh cạnh sau.

00:03:14.000 --> 00:03:20.000
Bây giờ, SwiftUI đã có các lưới lười biếng, rất tốt cho nội dung có thể cuộn.

00:03:20.000 --> 00:03:27.000
Các vùng chứa này rất hiệu quả khi bạn có nhiều chế độ xem, bởi vì chúng chỉ tải các chế độ xem có thể nhìn thấy hoặc sắp hiển thị.

00:03:27.000 --> 00:03:34.000
Mặt khác, điều đó có nghĩa là thùng chứa không thể tự động định cỡ các ô của nó ở cả hai chiều.

00:03:34.000 --> 00:03:42.000
Ví dụ, LazyHGrid có thể tìm ra độ rộng để tạo ra mỗi cột, bởi vì nó có thể đo tất cả các chế độ xem trong một cột trước khi vẽ chúng.

00:03:42.000 --> 00:03:46.000
Nhưng nó không thể đo mọi chế độ xem liên tiếp để tìm ra chiều cao của hàng.

00:03:46.000 --> 00:03:53.000
Để thực hiện công việc này, các lưới lười biếng cần bạn cung cấp thông tin về một trong các kích thước của chúng tại thời điểm khởi tạo.

00:03:53.000 --> 00:04:02.000
Để xem xét kỹ hơn các lưới lười biếng và các loại vùng chứa bố cục SwiftUI hiện có khác, hãy xem các cuộc nói chuyện về Ngăn xếp, lưới và phác thảo từ năm 2020.

00:04:02.000 --> 00:04:09.000
Nhưng trong trường hợp của tôi, tôi không cần cuộn và tôi muốn SwiftUI tìm ra cả chiều cao và chiều rộng cho mỗi ô.

00:04:09.000 --> 00:04:14.000
Đối với loại bố cục này, SwiftUI hiện cung cấp chế độ xem Lưới.

00:04:14.000 --> 00:04:25.000
Không giống như lưới lười, lưới tải tất cả các chế độ xem của nó cùng một lúc, vì vậy nó có thể tự động kích thước và căn chỉnh các ô của nó trên cả cột và hàng của nó.

00:04:25.000 --> 00:04:28.000
Hãy xem mã cho việc này.

00:04:28.000 --> 00:04:31.000
Đây là phiên bản cơ bản của bảng xếp hạng của tôi được viết dưới dạng Lưới.

00:04:31.000 --> 00:04:35.000
Chế độ xem lưới cụ thể này chứa ba trường hợp GridRow.

00:04:35.000 --> 00:04:38.000
Trong một hàng, mỗi chế độ xem tương ứng với một cột.

00:04:38.000 --> 00:04:49.000
Vì vậy, trong ví dụ này, chế độ xem văn bản đầu tiên trong mỗi hàng tương ứng với cột đầu tiên, chế độ xem tiến trình nằm trong cột thứ hai và chế độ xem văn bản cuối cùng là cột thứ ba.

00:04:49.000 --> 00:04:55.000
Lưu ý rằng lưới phân bổ nhiều không gian cho mỗi hàng và cột như nó cần để giữ chế độ xem lớn nhất của nó.

00:04:55.000 --> 00:05:00.000
Vì vậy, cột văn bản đầu tiên đủ rộng cho tên dài nhất, nhưng không rộng hơn.

00:05:00.000 --> 00:05:09.000
Các chế độ xem linh hoạt như chỉ báo tiến độ chiếm nhiều không gian như lưới cung cấp, trong trường hợp này là bất cứ thứ gì còn sót lại sau khi phân bổ không gian cho các cột văn bản.

00:05:09.000 --> 00:05:16.000
Tôi muốn điều chỉnh điều này một chút, nhưng trước tiên, hãy để tôi tạo một mô hình dữ liệu cơ bản để cung cấp cho tôi một nơi nào đó để lưu trữ số phiếu bầu.

00:05:16.000 --> 00:05:24.000
Tôi sẽ cần nhiều logic hơn để quản lý và chia sẻ dữ liệu trên mạng, nhưng trong khi tôi đang tạo mẫu giao diện, tôi chỉ cần một cấu trúc đơn giản như thế này.

00:05:24.000 --> 00:05:35.000
Tôi sẽ bao gồm sự phù hợp có thể nhận dạng, bởi vì điều đó sẽ giúp việc sử dụng loại này dễ dàng hơn trong ForEach và sự phù hợp có thể đánh đồng để có thể tạo hiệu ứng động cho các thay đổi.

00:05:35.000 --> 00:05:41.000
Và tôi sẽ tạo một tập hợp dữ liệu ví dụ để sử dụng trong các bản xem trước của mình trong khi tôi tạo mẫu.

00:05:41.000 --> 00:05:46.000
Quay trở lại lưới của mình, tôi có thể tạo một biến trạng thái và khởi tạo nó bằng dữ liệu ví dụ của mình.

00:05:46.000 --> 00:05:51.000
Và sử dụng dữ liệu đó, bây giờ tôi có thể tạo các hàng với ForEach.

00:05:51.000 --> 00:05:56.000
Lưu ý rằng đầu ra được hiển thị không thay đổi vì nó vẫn hiển thị cùng một dữ liệu.

00:05:56.000 --> 00:06:00.000
Điều đó đã khá gần, nhưng tôi cần sửa căn chỉnh ô.

00:06:00.000 --> 00:06:10.000
Ngay bây giờ, tất cả các ô đều được căn giữa, đây là mặc định cho lưới, nhưng nếu bạn nhớ, tôi muốn các tên được căn chỉnh cạnh hàng đầu và các giá trị được căn chỉnh cạnh sau.

00:06:10.000 --> 00:06:14.000
Để làm điều đó, tôi sẽ khởi tạo lưới với căn chỉnh cạnh trước.

00:06:14.000 --> 00:06:18.000
Giá trị tôi sử dụng ở đây áp dụng cho tất cả các ô trong lưới.

00:06:18.000 --> 00:06:23.000
Điều đó hoạt động tốt cho hai cột đầu tiên của tôi, nhưng còn cột cuối cùng thì sao?

00:06:23.000 --> 00:06:31.000
Để ảnh hưởng đến việc căn chỉnh một cột duy nhất, tôi có thể áp dụng công cụ sửa đổi chế độ xem gridColumnAlignment cho bất kỳ một ô nào trong cột đó.

00:06:31.000 --> 00:06:34.000
Vì vậy, tôi sẽ làm điều đó với chế độ xem văn bản ở cột cuối cùng.

00:06:34.000 --> 00:06:41.000
Được rồi, nó đang đến đó, nhưng bây giờ tôi đang nhìn vào nó, tôi cảm thấy nó sẽ tốt hơn với một dải phân cách giữa mỗi hàng.

00:06:41.000 --> 00:06:50.000
Nếu tôi chỉ thêm một hàng mới vào ForEach bằng một dải phân cách, đây không chính xác là những gì tôi muốn, nhưng lưu ý rằng điều này cho thấy một vài điều thú vị.

00:06:50.000 --> 00:06:56.000
Đầu tiên, bởi vì dải phân cách là một chế độ xem linh hoạt, nó khiến cột đầu tiên chiếm nhiều không gian hơn.

00:06:56.000 --> 00:07:03.000
Về cơ bản, lưới hiện đang cung cấp cho cột cuối cùng những gì nó cần và chia không gian còn lại giữa hai cột đầu tiên.

00:07:03.000 --> 00:07:11.000
Thứ hai, đối với một hàng lưới không có nhiều chế độ xem như các hàng lưới khác, các chế độ xem bị thiếu chỉ tạo các ô trống trong các cột sau.

00:07:11.000 --> 00:07:23.000
Nhưng điều tôi thực sự muốn là có dải phân cách trải dài tất cả các cột của lưới và SwiftUI có một công cụ sửa đổi chế độ xem mới cho phép tôi làm điều đó.

00:07:23.000 --> 00:07:32.000
Bằng cách thêm công cụ sửa đổi gridCellColumns vào chế độ xem, tôi có thể yêu cầu một chế độ xem duy nhất mở rộng một số cột; trong trường hợp này, cả ba.

00:07:32.000 --> 00:07:41.000
Và trên thực tế, đối với trường hợp chế độ xem sẽ mở rộng toàn bộ lưới, tôi có thể đơn giản hóa điều này bằng cách chỉ viết chế độ xem một mình, bên ngoài một hàng lưới.

00:07:41.000 --> 00:07:48.000
Được rồi, bảng xếp hạng của tôi ở trong tình trạng khá tốt vì vậy hãy để tôi xem các nút được sử dụng để bỏ phiếu tiếp theo.

00:07:48.000 --> 00:07:51.000
Thoạt nhìn, không có gì quá lạ mắt ở đây.

00:07:51.000 --> 00:07:54.000
Tuy nhiên, tôi có một yêu cầu đặc biệt.

00:07:54.000 --> 00:08:00.000
Một mặt, tôi không muốn thiên vị những người tham gia của mình với các nút nhỏ hơn cho một số lựa chọn nhất định.

00:08:00.000 --> 00:08:06.000
Nhưng tôi cũng không muốn các nút phát triển lớn như thùng chứa của chúng, có thể rất lớn trên iPad hoặc Mac.

00:08:06.000 --> 00:08:11.000
Thay vào đó, tất cả các nút phải có chiều rộng bằng văn bản nút rộng nhất.

00:08:11.000 --> 00:08:15.000
Vậy điều gì sẽ xảy ra nếu tôi cố gắng xây dựng cái này bằng Hstack?

00:08:15.000 --> 00:08:23.000
Những gì tôi thấy là mỗi nút tự kích thước để phù hợp với nhãn văn bản của nó và HStack đóng gói chúng lại với nhau theo chiều ngang.

00:08:23.000 --> 00:08:31.000
Hành vi ngăn xếp mặc định này chính xác là những gì bạn muốn trong nhiều trường hợp, nhưng nó không hoàn toàn đáp ứng thông số kỹ thuật của tôi cho dự án này.

00:08:31.000 --> 00:08:39.000
Để được bồi dưỡng về các nguyên tắc cơ bản về bố cục trong SwiftUI, hãy xem Chế độ xem tùy chỉnh Xây dựng với SwiftUI talk từ năm 2019.

00:08:39.000 --> 00:08:47.000
Sử dụng các khái niệm từ cuộc nói chuyện đó, chúng ta hãy xem xét hệ thống phân cấp quan điểm này để xem những gì tôi có thể thay đổi để có được hành vi tôi muốn.

00:08:47.000 --> 00:08:52.000
Đầu tiên, thùng chứa của ngăn xếp đề xuất một kích thước cho ngăn xếp.

00:08:52.000 --> 00:09:00.000
Dựa trên điều này, ngăn xếp đề xuất kích thước cho ba nút của nó, và sau đó mỗi nút chuyển kích thước đó qua nhãn văn bản của nó.

00:09:00.000 --> 00:09:08.000
Chế độ xem văn bản tính toán kích thước mà họ thực sự muốn, điều này phụ thuộc vào chuỗi chúng chứa và báo cáo điều này cho nút.

00:09:08.000 --> 00:09:10.000
Nút chuyển thông tin trở lại.

00:09:10.000 --> 00:09:18.000
Ngăn xếp tự định cỡ với thông tin này, đặt các nút trong không gian của nó và sau đó báo cáo kích thước riêng của nó cho vùng chứa của nó.

00:09:18.000 --> 00:09:26.000
Được rồi, vậy nếu các nút có kích thước văn bản của chúng, điều gì sẽ xảy ra nếu tôi bọc mỗi chế độ xem văn bản trong một khung linh hoạt và cho phép nó phát triển?

00:09:26.000 --> 00:09:33.000
Văn bản không thay đổi, nhưng nút nhìn thấy chế độ xem phụ linh hoạt, chiếm nhiều dung lượng như HStack cung cấp.

00:09:33.000 --> 00:09:38.000
Ngăn xếp sau đó phân phối không gian của nó bằng nhau giữa các chế độ xem mà nó chứa.

00:09:38.000 --> 00:09:44.000
Vì vậy, các nút bây giờ đều có cùng kích thước, điều này thật tuyệt, nhưng kích thước thực tế của chúng phụ thuộc vào thùng chứa của ngăn xếp.

00:09:44.000 --> 00:09:49.000
Ngăn xếp sẽ mở rộng để lấp đầy bất kỳ không gian nào mà thùng chứa cung cấp, và đó không phải là điều tôi muốn.

00:09:49.000 --> 00:09:59.000
Những gì tôi thực sự muốn là một loại ngăn xếp tùy chỉnh yêu cầu kích thước lý tưởng của mỗi nút, tìm kích thước rộng nhất và sau đó cung cấp dung lượng đó cho mỗi nút.

00:09:59.000 --> 00:10:04.000
May mắn thay, SwiftUI có một công cụ mới cho phép tôi làm điều đó.

00:10:04.000 --> 00:10:14.000
Sử dụng giao thức Bố cục, tôi có thể xác định một vùng chứa bố cục tùy chỉnh tham gia trực tiếp vào quy trình bố cục với hành vi phù hợp với trường hợp sử dụng của tôi.

00:10:14.000 --> 00:10:16.000
Hãy xem cái này hoạt động như thế nào.

00:10:16.000 --> 00:10:26.000
Nhìn vào HStack một lần nữa, hãy để tôi thay đổi nó thành EqualWidthHStack một loại mà tôi sẽ xác định để giải quyết vấn đề cụ thể của mình.

00:10:26.000 --> 00:10:33.000
Loại này sẽ phân bổ chiều rộng cho các nút bằng nhau, với số lượng rộng bằng chiều rộng lý tưởng của nút rộng nhất.

00:10:33.000 --> 00:10:40.000
Tôi sẽ giữ các khung linh hoạt để các nút có văn bản hẹp hơn có thể mở rộng để lấp đầy khoảng trống mà ngăn xếp cung cấp.

00:10:40.000 --> 00:10:45.000
Nhưng các nút vẫn sẽ có kích thước lý tưởng mà tôi có thể đo, đó là chiều rộng văn bản của chúng.

00:10:45.000 --> 00:10:52.000
Vậy hãy xem làm thế nào tôi có thể triển khai MyEqualWidthHStack.

00:10:52.000 --> 00:10:56.000
Tôi bắt đầu bằng cách tạo ra một loại phù hợp với giao thức Bố cục.

00:10:56.000 --> 00:10:59.000
Đối với bố cục cơ bản, tất cả những gì tôi cần là hai phương pháp bắt buộc.

00:10:59.000 --> 00:11:02.000
Hãy thêm cuống cho những thứ đó.

00:11:02.000 --> 00:11:10.000
Phương pháp đầu tiên là sizeThatFits, nơi tôi sẽ tính toán và báo cáo vùng chứa bố cục của mình lớn như thế nào.

00:11:10.000 --> 00:11:16.000
Tôi nhận được đầu vào kích thước chế độ xem được đề xuất, đó là đề xuất kích thước từ chế độ xem vùng chứa của riêng bố cục của tôi.

00:11:16.000 --> 00:11:22.000
Và tôi có thể đề xuất kích thước cho các chế độ xem con của bố cục của mình bằng cách sử dụng tham số Chế độ xem phụ.

00:11:22.000 --> 00:11:25.000
Lưu ý rằng tôi không thể truy cập trực tiếp vào các chế độ xem phụ.

00:11:25.000 --> 00:11:34.000
Thay vào đó, đầu vào lượt xem con là một tập hợp các proxy cho phép tôi tương tác theo những cách cụ thể với các lượt xem con, như đề xuất kích thước.

00:11:34.000 --> 00:11:39.000
Mỗi proxy trả về một kích thước cụ thể dựa trên đề xuất mà tôi đã đưa ra.

00:11:39.000 --> 00:11:49.000
Tôi sẽ thu thập tất cả những câu trả lời đó và sử dụng chúng để thực hiện một số phép tính và sau đó trả lại kích thước cụ thể cho EqualWidthHStack cho thùng chứa của nó.

00:11:49.000 --> 00:11:52.000
Phương pháp thứ hai mà tôi phải thực hiện là placeSubviews.

00:11:52.000 --> 00:11:56.000
Tôi sẽ sử dụng cái này để cho biết các chế độ xem con của bố cục của tôi nơi xuất hiện.

00:11:56.000 --> 00:12:07.000
Phương pháp này có cùng kích thước đề xuất và đầu vào lượt xem phụ, và nó cũng có đầu vào giới hạn đại diện cho khu vực mà tôi cần đặt chế độ xem con của mình vào.

00:12:07.000 --> 00:12:12.000
Bounds là một hình chữ nhật có kích thước mà tôi đã yêu cầu trong việc triển khai sizeThatFits của mình.

00:12:12.000 --> 00:12:19.000
Hãy nhớ rằng, các chế độ xem chọn kích thước của riêng chúng trong SwiftUI, vì vậy vùng chứa bố cục của tôi sẽ nhận được kích thước mà nó yêu cầu.

00:12:19.000 --> 00:12:25.000
Nguồn gốc của vùng nằm ở trên cùng bên trái, với X dương ở bên phải và Y dương ở dưới.

00:12:25.000 --> 00:12:37.000
Bạn có thể giả định điều này cho tất cả các tính toán vị trí của mình, ngay cả trong môi trường ngôn ngữ từ phải sang trái, bởi vì khung tự động lật vị trí x của mỗi chế độ xem khi bố trí chế độ xem theo hướng đó.

00:12:37.000 --> 00:12:42.000
Tuy nhiên, đừng cho rằng nguồn gốc của hình chữ nhật có giá trị (0,0).

00:12:42.000 --> 00:12:52.000
Trong số những thứ khác, cho phép nguồn gốc khác 0 cho phép bố cục bố cục, trong đó phương thức placeSubviews của một bố cục gọi vào cùng một phương thức của một bố cục khác.

00:12:52.000 --> 00:13:05.000
Để làm việc dễ dàng hơn một chút, hình chữ nhật cung cấp các thuộc tính để truy cập các phần quan trọng của khu vực, như các điểm tối thiểu, trung tâm và tối đa trong mỗi chiều.

00:13:05.000 --> 00:13:16.000
Bây giờ, trước khi tôi tiếp tục, hãy chú ý một tham số khác mà cả hai phương thức này đều có: bộ nhớ cache hai chiều mà tôi có thể sử dụng để chia sẻ kết quả tính toán trung gian qua các cuộc gọi phương thức.

00:13:16.000 --> 00:13:22.000
Đối với nhiều bố cục đơn giản, bạn sẽ không cần cái này, và tôi sẽ bỏ qua bộ nhớ cache ngay bây giờ.

00:13:22.000 --> 00:13:29.000
Tuy nhiên, nếu việc lập hồ sơ ứng dụng của bạn với Công cụ cho thấy rằng bạn cần cải thiện hiệu quả của mã bố cục của mình, bạn có thể xem xét thêm một mã.

00:13:29.000 --> 00:13:34.000
Kiểm tra tài liệu để biết thêm thông tin về điều đó.

00:13:34.000 --> 00:13:37.000
Được rồi, hãy thực hiện sizeThatFits.

00:13:37.000 --> 00:13:44.000
Hãy nhớ rằng, tôi muốn trả lại một kích thước cho thùng chứa của mình phù hợp với tất cả các nút được sắp xếp theo chiều ngang, tất cả đều có cùng chiều rộng.

00:13:44.000 --> 00:13:51.000
Vì vậy, trước tiên, tôi sẽ hỏi mỗi nút về kích thước của nó, điều mà tôi làm bằng cách đề xuất một kích thước và xem những gì quay trở lại.

00:13:51.000 --> 00:14:01.000
Để đo lường tính linh hoạt của chế độ xem phụ, tôi có thể thực hiện nhiều phép đo bằng cách sử dụng các đề xuất đặc biệt cho kích thước tối thiểu, tối đa và lý tưởng hoặc tôi có thể đề xuất một kích thước cụ thể.

00:14:01.000 --> 00:14:08.000
Trong trường hợp này, tôi sử dụng đề xuất kích thước không xác định để yêu cầu kích thước lý tưởng.

00:14:08.000 --> 00:14:13.000
Sau đó, tôi sẽ tìm thấy giá trị lớn nhất trong mỗi chiều cho tất cả các kích thước mà tôi nhận lại.

00:14:13.000 --> 00:14:18.000
Trong trường hợp này, nút cá vàng đặt chiều rộng và chiều cao đều giống nhau.

00:14:18.000 --> 00:14:23.000
Bây giờ hãy để tôi tái cấu trúc nó thành một phương pháp, bởi vì tôi sẽ cần nó một lần nữa khi tôi đặt các chế độ xem phụ của mình.

00:14:23.000 --> 00:14:27.000
Tiếp theo, tôi cần tính đến khoảng cách giữa các chế độ xem.

00:14:27.000 --> 00:14:33.000
Tôi chỉ có thể sử dụng khoảng cách không đổi, như 10 điểm, nhưng giao thức bố cục cho phép tôi làm tốt hơn.

00:14:33.000 --> 00:14:42.000
Trong SwiftUI, tất cả các chế độ xem đều có tùy chọn khoảng cách cho biết dung lượng không gian mà chế độ xem muốn có giữa chính nó và chế độ xem tiếp theo.

00:14:42.000 --> 00:14:48.000
Các tùy chọn này được lưu trữ trong một phiên bản ViewSpacing có sẵn để bố trí các vùng chứa.

00:14:48.000 --> 00:14:54.000
Chế độ xem có thể thích các giá trị khác nhau trên các cạnh khác nhau và thậm chí các giá trị khác nhau cho các loại chế độ xem liền kề khác nhau.

00:14:54.000 --> 00:15:02.000
Ví dụ, một chế độ xem có thể muốn nhiều hoặc ít hơn không gian giữa chính nó và chế độ xem văn bản hơn là nó muốn giữa chính nó và một hình ảnh.

00:15:02.000 --> 00:15:06.000
Và các giá trị cũng có thể thay đổi tùy theo nền tảng.

00:15:06.000 --> 00:15:26.000
Bạn có thể bỏ qua các tùy chọn này nếu nó có ý nghĩa đối với bố cục của bạn, về cơ bản đó là những gì đang xảy ra khi bạn khởi tạo ngăn xếp tích hợp với khoảng cách tùy chỉnh, nhưng tôn trọng các tùy chọn này trong bố cục của riêng bạn là một cách tốt để có được kết quả tự động tuân theo các nguyên tắc giao diện của Apple và kết

00:15:26.000 --> 00:15:35.000
Bây giờ, mọi chế độ xem đều có tùy chọn trên tất cả các cạnh và khi tôi kết hợp hai chế độ xem lại với nhau, các tùy chọn trên một cạnh chung có thể không khớp.

00:15:35.000 --> 00:15:39.000
Để giải quyết vấn đề này, một vùng chứa bố cục tích hợp sử dụng tùy chọn lớn hơn trong hai tùy chọn.

00:15:39.000 --> 00:15:43.000
Và tôi có thể làm điều tương tự trong bố cục của riêng mình.

00:15:43.000 --> 00:15:50.000
Các proxy xem phụ cho tôi một cách để yêu cầu khoảng cách ưa thích của mỗi nút với một số nút khác dọc theo một trục nhất định.

00:15:50.000 --> 00:16:05.000
Vì vậy, hãy để tôi tạo một mảng các giá trị bằng cách quét qua các chế độ xem con và gọi phương thức khoảng cách trên mỗi phiên bản khoảng cách của proxy để đưa khoảng cách đến phiên bản khoảng cách của chế độ xem tiếp theo dọc theo trục ngang.

00:16:05.000 --> 00:16:11.000
Cuộc gọi này tính đến sở thích của cả hai quan điểm trên lợi thế chung của chúng.

00:16:11.000 --> 00:16:22.000
Phần tử đầu tiên trong mảng này cho tôi biết nút mèo muốn có bao nhiêu không gian theo chiều ngang với nút cá vàng và phần tử tiếp theo cho tôi biết nút cá vàng muốn nút chó bao nhiêu.

00:16:22.000 --> 00:16:28.000
Tôi sẽ buộc phần tử cuối cùng trong mảng bằng 0 vì không còn bất kỳ nút nào để so sánh nữa.

00:16:28.000 --> 00:16:32.000
Được rồi, hãy để tôi tái cấu trúc nó thành một phương pháp cho sau này.

00:16:32.000 --> 00:16:41.000
Bây giờ tôi có thể kết hợp các giá trị khoảng cách để tìm tổng khoảng cách và sử dụng nó với các phép đo chiều rộng và chiều cao để trả về giá trị kích thước.

00:16:41.000 --> 00:16:49.000
Đây là kích thước mà bố cục của tôi cần, với kích thước lý tưởng của các chế độ xem phụ và khoảng cách ưa thích của mỗi chế độ xem phụ.

00:16:49.000 --> 00:16:52.000
Phương pháp khác mà tôi cần thực hiện là placeSubviews.

00:16:52.000 --> 00:17:01.000
Như tôi đã đề cập trước đây, tôi nhận được cả giới hạn của vùng chứa và bộ sưu tập các proxy xem phụ mà tôi có thể sử dụng để điều khiển các nút.

00:17:01.000 --> 00:17:10.000
Đầu tiên, tôi tính toán maxSize và mảng khoảng cách giống như tôi đã làm trong phương pháp sizeThatFits, bởi vì tôi cũng sẽ cần những giá trị đó ở đây.

00:17:10.000 --> 00:17:18.000
Sau đó, tôi sẽ tạo một đề xuất kích thước mà tôi có thể sử dụng cho mỗi lượt xem phụ của mình, lần này dựa trên kích thước mà tôi muốn chúng có, thay vì kích thước lý tưởng của chúng.

00:17:18.000 --> 00:17:23.000
Tôi chỉ cần một đề xuất, bởi vì tôi muốn tất cả các nút có cùng kích thước.

00:17:23.000 --> 00:17:32.000
Và tôi sẽ tìm một vị trí bắt đầu trong kích thước ngang cho chế độ xem phụ đầu tiên của mình, được tính là cạnh trước của giới hạn của tôi, cộng với một nửa chiều rộng của nút.

00:17:32.000 --> 00:17:39.000
Lưu ý rằng tôi không dựa vào nguồn gốc bằng 0, mà thay vào đó bắt đầu với giá trị minX.

00:17:39.000 --> 00:17:52.000
Cuối cùng, tôi có thể xem qua từng proxy xem con và gọi phương thức vị trí của nó bằng một điểm, một tuyên bố về những gì điểm đó đại diện về nút và đề xuất kích thước.

00:17:52.000 --> 00:18:01.000
Mỗi lần thông qua vòng lặp, tôi cập nhật vị trí nằm ngang theo chiều rộng của chế độ xem, cộng với khoảng cách cho cặp chế độ xem tiếp theo, để sẵn sàng cho lần lặp tiếp theo.

00:18:01.000 --> 00:18:02.000
Và thế là xong.

00:18:02.000 --> 00:18:07.000
Bây giờ hãy xem điều gì sẽ xảy ra khi tôi sử dụng kiểu bố cục chế độ xem mới này.

00:18:07.000 --> 00:18:08.000
Và nó đây rồi.

00:18:08.000 --> 00:18:18.000
Tôi khởi tạo vùng chứa bố cục tùy chỉnh của riêng mình giống như tôi làm với HStack tích hợp và các nút được sắp xếp theo chiều ngang, tất cả đều có cùng chiều rộng.

00:18:18.000 --> 00:18:27.000
Bây giờ, tôi muốn tạm dừng ở đây một chút và nói về cách giao thức Bố cục giải quyết một vấn đề mà bạn có thể đã thử sử dụng trình đọc hình học trong quá khứ.

00:18:27.000 --> 00:18:31.000
Xét cho cùng, đầu đọc hình học là một công cụ để đo kích thước chế độ xem.

00:18:31.000 --> 00:18:35.000
Tuy nhiên, nó không phải là lựa chọn tốt nhất trong trường hợp này.

00:18:35.000 --> 00:18:41.000
Và đó là bởi vì một trình đọc hình học được thiết kế để đo chế độ xem vùng chứa của nó và báo cáo kích thước đó cho chế độ xem phụ của nó.

00:18:41.000 --> 00:18:45.000
Chế độ xem phụ sau đó sử dụng thông tin để vẽ nội dung của riêng nó.

00:18:45.000 --> 00:18:50.000
Lưu ý rằng đối với mục đích sử dụng của trình đọc hình học, thông tin sẽ chảy xuống dưới.

00:18:50.000 --> 00:18:55.000
Phép đo mà người đọc thực hiện không ảnh hưởng đến cách bố trí vùng chứa của chính nó.

00:18:55.000 --> 00:18:59.000
Điều này thật tuyệt vời cho những thứ như vẽ một con đường có tỷ lệ với vùng chứa của nó.

00:18:59.000 --> 00:19:07.000
Trình đọc hình học cho logic đường dẫn biết nó phải làm việc với bao nhiêu không gian và logic đường dẫn bên trong chế độ xem con điều chỉnh cho phù hợp.

00:19:07.000 --> 00:19:14.000
Nếu vùng chứa thay đổi kích thước, đường dẫn cũng vậy, bởi vì trình đọc hình học đi dọc theo kích thước mới.

00:19:14.000 --> 00:19:27.000
Tuy nhiên, đối với các nút của tôi và tôi sẽ chỉ tập trung vào một nút ở đây để dễ nhìn hơn, tôi cần đo chế độ xem văn bản và sau đó sử dụng nó để quyết định cách đặt khung là vùng chứa của chế độ xem văn bản.

00:19:27.000 --> 00:19:38.000
Vì vậy, tôi có thể thêm một trình đọc hình học trong một lớp phủ vào chế độ xem văn bản - hãy nhớ rằng, nó đo vùng chứa của nó - và sau đó bằng cách nào đó gửi dữ liệu đo trở lại khung, bên ngoài luồng bình thường.

00:19:38.000 --> 00:19:43.000
Nhưng lưu ý rằng nếu tôi làm điều này, tôi sẽ bỏ qua công cụ bố trí, điều này có thể dẫn đến một vòng lặp.

00:19:43.000 --> 00:19:51.000
Người đọc đo bố cục và thay đổi khung, điều này có thể thay đổi bố cục, có thể yêu cầu một phép đo khác, v.v.

00:19:51.000 --> 00:19:57.000
Bây giờ có thể làm cho điều này hoạt động, nhưng nếu tôi không cẩn thận, tôi có thể sẽ làm hỏng ứng dụng của mình.

00:19:57.000 --> 00:20:00.000
Kết quả là, chiến lược này không được khuyến khích.

00:20:00.000 --> 00:20:08.000
May mắn thay, giao thức bố cục cung cấp cho bạn một cách tốt hơn để giải quyết vấn đề này, bằng cách cho phép bạn làm việc trong công cụ bố cục.

00:20:08.000 --> 00:20:10.000
Được rồi, hãy nhìn vào các nút một lần nữa.

00:20:10.000 --> 00:20:13.000
Có điều gì đó khác tôi muốn làm ở đây.

00:20:13.000 --> 00:20:18.000
Đầu tiên, để làm cho điều này dễ đọc hơn một chút, tôi sẽ cấu trúc lại các nút thành chế độ xem phụ của riêng chúng.

00:20:18.000 --> 00:20:23.000
Bây giờ, tôi tình cờ biết rằng một trong những đồng nghiệp của tôi sử dụng loại lớn hơn trên thiết bị của họ.

00:20:23.000 --> 00:20:30.000
Ứng dụng của tôi tự động hỗ trợ Dynamic Type vì tôi đã sử dụng phông chữ mặc định, vì vậy tôi hầu như sẽ nhận được hành vi phù hợp miễn phí.

00:20:30.000 --> 00:20:35.000
Hãy xem điều gì sẽ xảy ra nếu tôi tăng kích thước loại.

00:20:35.000 --> 00:20:37.000
Uh-oh, các nút không vừa nữa.

00:20:37.000 --> 00:20:47.000
Hãy nhớ rằng ngăn xếp tùy chỉnh của tôi không hạn chế độ rộng của nút, mà chỉ cho phép chúng có kích thước lý tưởng, trong trường hợp này vượt quá chiều rộng của màn hình.

00:20:47.000 --> 00:20:48.000
Vậy tôi có thể làm gì?

00:20:48.000 --> 00:20:56.000
Chà, tôi có thể sửa đổi bố cục để làm điều gì đó phức tạp hơn khi chế độ xem không phù hợp, có tính đến đề xuất kích thước từ vùng chứa của bố cục.

00:20:56.000 --> 00:21:01.000
Nhưng trong trường hợp này, tôi có thể sử dụng vùng chứa ViewThatFits mới để thực hiện hầu hết công việc cho mình.

00:21:01.000 --> 00:21:09.000
Loại mới này chọn chế độ xem đầu tiên phù hợp với không gian có sẵn từ danh sách các chế độ xem mà tôi cung cấp cho nó.

00:21:09.000 --> 00:21:20.000
Bằng cách gói ngăn xếp tùy chỉnh của tôi trong cấu trúc ViewThatFits và sau đó thêm phiên bản ngăn xếp dọc của cùng một nội dung, tôi có thể để SwiftUI tìm ra khi nào các nút cần được sắp xếp khác nhau.

00:21:20.000 --> 00:21:31.000
Tất nhiên, VStack tích hợp không có thuộc tính chiều rộng bằng nhau như ngăn xếp ngang tùy chỉnh của tôi, vì vậy tôi cũng đã tiếp tục và triển khai phiên bản dọc của ngăn xếp tùy chỉnh.

00:21:31.000 --> 00:21:41.000
Nó rất giống với cái mà tôi đã mô tả, ngoại trừ việc nó đặt các mục có chiều rộng bằng nhau dọc theo trục dọc thay vì trục ngang.

00:21:41.000 --> 00:21:47.000
Và tất nhiên, khi tôi xóa ghi đè kích thước kiểu động, nó sẽ quay trở lại bố cục ngang.

00:21:47.000 --> 00:21:52.000
Bây giờ, có một phần cuối cùng của ứng dụng tôi cần xây dựng, và đó là những hình ảnh ở trên cùng.

00:21:52.000 --> 00:21:59.000
Tôi có thể làm một cái gì đó đơn giản, như chỉ cho xem một nhóm ảnh đại diện, nhưng tôi nghĩ tôi sẽ có một chút vui vẻ với nó.

00:21:59.000 --> 00:22:08.000
Vì vậy, tôi đã tạo một loại bố cục tùy chỉnh khác vẽ các chế độ xem theo cách sắp xếp tròn và sau đó xoay sắp xếp theo thứ hạng.

00:22:08.000 --> 00:22:13.000
Vì vậy, cấu hình này cho thấy cá vàng ở vị trí đầu tiên và hai con còn lại được buộc cho vị trí thứ hai.

00:22:13.000 --> 00:22:17.000
Và sau đó nếu con chó kéo trước con mèo, tôi có thể xoay một chút để cho thấy điều đó.

00:22:17.000 --> 00:22:23.000
Hoặc tôi có thể hiển thị một kết quả thực tế hơn một chút, tất cả bằng cách xoay bố cục xuyên tâm.

00:22:23.000 --> 00:22:27.000
Tạo bố cục này thực sự khá đơn giản với giao thức bố cục.

00:22:27.000 --> 00:22:30.000
Giống như trước đây, tôi chỉ cần hai phương pháp.

00:22:30.000 --> 00:22:37.000
Đối với kích thước phù hợp, tôi muốn chế độ xem của mình lấp đầy không gian có sẵn, vì vậy tôi sẽ trả lại bất kỳ kích thước nào mà chế độ xem vùng chứa đề xuất.

00:22:37.000 --> 00:22:44.000
Tôi sẽ chuyển đổi đề xuất thành kích thước cụ thể bằng cách sử dụng phương pháp thay thế kích thước không xác định.

00:22:44.000 --> 00:22:50.000
Phương pháp đó tự động xử lý các giá trị nil có thể xuất hiện nếu vùng chứa yêu cầu kích thước lý tưởng.

00:22:50.000 --> 00:23:03.000
Sau đó, bên trong phương pháp xem con vị trí, tôi sẽ bù đắp từng chế độ xem con từ giữa bằng một số bán kính dựa trên kích thước của vùng bố cục và áp dụng một vòng quay phụ thuộc vào chỉ mục của chế độ xem.

00:23:03.000 --> 00:23:12.000
Làm đường cơ sở, điều này đặt các chế độ xem ở 0, 1 và hai phần ba đường xung quanh một vòng tròn.

00:23:12.000 --> 00:23:18.000
Để phản ánh thứ hạng hiện tại, tôi cũng sẽ áp dụng phần bù ảnh hưởng đến tất cả các lượt xem như nhau.

00:23:18.000 --> 00:23:20.000
Nhưng tôi lấy thứ hạng ở đâu?

00:23:20.000 --> 00:23:27.000
Hãy nhớ rằng, bố cục của tôi chỉ có thể truy cập proxy xem phụ chứ không phải chế độ xem, chứ đừng nói đến mô hình dữ liệu của tôi.

00:23:27.000 --> 00:23:31.000
Chà, hóa ra giao thức bố cục có một mẹo khác.

00:23:31.000 --> 00:23:37.000
Nó cho phép bạn lưu trữ các giá trị trên mỗi chế độ xem phụ và đọc các giá trị từ bên trong các phương thức giao thức bố cục.

00:23:37.000 --> 00:23:41.000
Hãy xem làm thế nào tôi có thể sử dụng nó để truyền đạt thông tin xếp hạng.

00:23:41.000 --> 00:23:48.000
Đầu tiên, tôi khai báo một loại mới phù hợp với giao thức LayoutValueKey và cung cấp cho nó một giá trị mặc định.

00:23:48.000 --> 00:23:59.000
Ngoài việc cung cấp giá trị cho chế độ xem khi bạn không đặt rõ ràng, giá trị mặc định sẽ thiết lập loại giá trị liên quan, là số nguyên trong trường hợp này.

00:23:59.000 --> 00:24:07.000
Sau đó, tôi tạo một phương thức tiện lợi trên View để đặt giá trị bằng cách sử dụng công cụ sửa đổi chế độ xem layoutValue.

00:24:07.000 --> 00:24:13.000
Bây giờ trong hệ thống phân cấp chế độ xem của tôi, tôi có thể áp dụng công cụ sửa đổi thứ hạng tiện lợi của mình cho các chế độ xem trong bố cục của mình.

00:24:13.000 --> 00:24:20.000
Ở đây, tôi tính toán thứ hạng của từng thú cưng và thêm nó vào chế độ xem hình đại diện tương ứng của thú cưng bên trong bố cục xuyên tâm của tôi.

00:24:20.000 --> 00:24:31.000
Cuối cùng, trở lại phương pháp xem phụ vị trí của tôi, tôi có thể thêm một số mã để đọc các giá trị từ mỗi chế độ xem phụ bằng cách sử dụng khóa giá trị bố cục làm chỉ mục.

00:24:31.000 --> 00:24:34.000
Và tôi có thể sử dụng các cấp bậc để tính toán độ lệch.

00:24:34.000 --> 00:24:40.000
Tôi sẽ không trải qua logic đó ở đây, nhưng về cơ bản nó tạo ra một góc thích hợp cho bất kỳ bộ thứ hạng nào có thể có.

00:24:40.000 --> 00:24:43.000
Chà, tất cả ngoại trừ một.

00:24:43.000 --> 00:24:45.000
Điều gì xảy ra nếu có một chiếc cà vạt ba chiều?

00:24:45.000 --> 00:24:53.000
Không có cách nào để xoay bố cục để có được tất cả các chế độ xem trong một dòng, vì vậy tôi phải thay thế logic bố cục hoàn toàn khác cho trường hợp đó.

00:24:53.000 --> 00:24:58.000
Tuy nhiên, đã có một loại bố cục thực hiện điều này và đó là HStack tích hợp sẵn.

00:24:58.000 --> 00:25:03.000
Vì vậy, điều tôi thực sự muốn là chuyển sang HStack khi tôi phát hiện ra cà vạt ba chiều.

00:25:03.000 --> 00:25:07.000
Và hóa ra cũng có một công cụ mới cho điều đó.

00:25:07.000 --> 00:25:17.000
Loại AnyLayout cho phép bạn áp dụng các bố cục khác nhau cho một hệ thống phân cấp chế độ xem duy nhất, để bạn duy trì danh tính của các chế độ xem khi bạn chuyển từ loại bố cục này sang loại bố cục khác.

00:25:17.000 --> 00:25:27.000
Vì vậy, ở đây tôi có bố cục xuyên tâm mà chúng ta đã thấy trước đây và tất cả những gì tôi phải làm là thay thế nó bằng một loại bố cục mới phụ thuộc vào việc có cà vạt ba chiều hay không.

00:25:27.000 --> 00:25:36.000
Bởi vì thuộc tính isThreeWayTie có nguồn gốc từ trạng thái, SwiftUI nhận thấy khi nó thay đổi và nhận ra rằng nó cần vẽ lại chế độ xem này.

00:25:36.000 --> 00:25:46.000
Nhưng bởi vì bản sắc cấu trúc của hệ thống phân cấp chế độ xem luôn giữ nguyên, SwiftUI coi đây là một chế độ xem thay đổi, chứ không phải là một chế độ xem mới.

00:25:46.000 --> 00:25:52.000
Kết quả là, chỉ với một dòng nữa, tôi có thể tạo ra sự chuyển tiếp mượt mà giữa các loại bố cục.

00:25:52.000 --> 00:26:03.000
Và trên thực tế, bằng cách thêm công cụ sửa đổi chế độ xem hoạt ảnh, tôi cũng nhận được hoạt ảnh giữa tất cả các trạng thái khác nhau của bố cục xuyên tâm, bởi vì cấu hình của bố cục xuyên tâm phụ thuộc vào cùng một dữ liệu.

00:26:03.000 --> 00:26:06.000
Và đây là tất cả những gì trông giống như trong hành động.

00:26:06.000 --> 00:26:17.000
Khi tôi nhấn vào các nút khác nhau để thay đổi số phiếu bầu, bạn có thể thấy cách các hình đại diện di chuyển trơn tru để phản ánh bảng xếp hạng hiện tại.

00:26:17.000 --> 00:26:23.000
Vì vậy, đó là một số công cụ mới mà SwiftUI có để soạn bố cục chế độ xem ứng dụng của bạn.

00:26:23.000 --> 00:26:28.000
Bạn có thể sử dụng loại Lưới để xây dựng bố cục hai chiều, có thể tùy chỉnh cao của thông tin tĩnh.

00:26:28.000 --> 00:26:36.000
Bạn có thể sử dụng giao thức Bố cục để xác định mục đích chung của riêng bạn, bố cục có thể tái sử dụng hoặc bố cục được nhắm mục tiêu cao đến một trường hợp sử dụng cụ thể.

00:26:36.000 --> 00:26:43.000
Bạn có thể sử dụng ViewThatFits khi bạn muốn SwiftUI chọn từ một nhóm chế độ xem để phù hợp nhất với không gian có sẵn.

00:26:43.000 --> 00:26:48.000
Và bạn có thể chuyển đổi liền mạch giữa các loại bố cục bằng cách sử dụng AnyLayout.

00:26:48.000 --> 23:59:59.000
Cảm ơn vì đã tham gia cùng tôi hôm nay, và tôi hy vọng bạn sẽ vui vẻ khi chơi với những công cụ bố cục mới này như tôi.

