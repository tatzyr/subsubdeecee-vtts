WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:11.000
Xin chào mọi người.

00:00:11.000 --> 00:00:19.000
Tên tôi là Adrian, và tôi sẽ nói chuyện với bạn về cách thiết lập dự án của bạn để có trải nghiệm gỡ lỗi tuyệt vời với LLDB.

00:00:19.000 --> 00:00:23.000
LLDB là công nghệ gỡ lỗi cơ bản đi kèm với Xcode.

00:00:23.000 --> 00:00:35.000
LLDB cho phép bạn đặt điểm dừng trong ứng dụng của mình, tạm dừng thực thi, kiểm tra trạng thái của các biến và đối tượng, khám phá mã của bạn và hơn thế nữa.

00:00:35.000 --> 00:00:46.000
LLDB có thể giúp bạn hiểu mã của bạn đang làm gì và nó cho phép bạn tìm ra điểm mà hành vi của mã của bạn khác với mong đợi của bạn.

00:00:46.000 --> 00:00:51.000
Đó là một công cụ mạnh mẽ để hiểu và khám phá mã.

00:00:51.000 --> 00:00:59.000
Nếu bạn muốn tìm hiểu thêm về LLDB, vui lòng xem các video trước đó, ví dụ "Khám phá các cải tiến điểm dừng" từ WWDC21.

00:00:59.000 --> 00:01:06.000
Hôm nay chúng ta sẽ xem xét một số quy trình làm việc nâng cao có ý nghĩa độc đáo đối với việc gỡ lỗi mã Swift.

00:01:06.000 --> 00:01:10.000
Có thể bạn đang tích hợp khuôn khổ của bên thứ ba vào ứng dụng của mình.

00:01:10.000 --> 00:01:18.000
Có thể ứng dụng của bạn và nhóm của bạn đã phát triển đến mức hầu hết mã của bạn đang được xây dựng bởi một hệ thống tích hợp liên tục.

00:01:18.000 --> 00:01:23.000
Có thể bạn đang sử dụng một hệ thống xây dựng tùy chỉnh để tích hợp với cơ sở hạ tầng của công ty bạn.

00:01:23.000 --> 00:01:28.000
Có thể bạn đang xây dựng phần mềm cho các nhà phát triển phần mềm khác.

00:01:28.000 --> 00:01:30.000
Hoặc bạn chỉ muốn tìm hiểu thêm về LLDB.

00:01:30.000 --> 00:01:40.000
Mục tiêu của tôi là cung cấp sự hiểu biết tốt hơn về cách thức hoạt động của LLDB và thông tin cần thiết từ hệ thống xây dựng để hoạt động.

00:01:40.000 --> 00:01:44.000
Tôi có một dự án nhỏ ở đây mà chúng tôi sẽ sử dụng làm ví dụ đang chạy của mình.

00:01:44.000 --> 00:01:50.000
Tôi là một kỹ sư biên dịch và tôi thích trò chơi, vì vậy trong thời gian rảnh rỗi, tôi viết trình phân tích cú pháp cho các cuộc phiêu lưu văn bản.

00:01:50.000 --> 00:01:54.000
Cái này gần đây tôi đã bắt đầu trong Swift thuần túy.

00:01:54.000 --> 00:01:56.000
Hãy để tôi cho bạn thấy những gì tôi có cho đến nay.

00:01:56.000 --> 00:02:00.000
Trò chơi sử dụng giao diện văn bản nên tôi đang chạy nó trong Terminal.

00:02:00.000 --> 00:02:07.000
Như trong mọi cuộc phiêu lưu hay, chúng ta sẽ bắt đầu bằng cách kiểm tra hàng tồn kho của mình.

00:02:07.000 --> 00:02:10.000
Trò chơi này diễn ra trong một khung cảnh đương đại.

00:02:10.000 --> 00:02:12.000
Tôi thấy rằng tôi có một chiếc iPhone.

00:02:12.000 --> 00:02:17.000
Tiếp theo, chúng ta hãy nhìn vào môi trường xung quanh chúng ta.

00:02:17.000 --> 00:02:21.000
Hmm, cảm biến này trông hấp dẫn.

00:02:21.000 --> 00:02:30.000
Có lẽ chúng ta có thể sử dụng iPhone trên cảm biến?

00:02:30.000 --> 00:02:32.000
Tôi đã đánh rơi chiếc iPhone?

00:02:32.000 --> 00:02:35.000
Uh, đó không phải là những gì tôi muốn cho bạn thấy.

00:02:35.000 --> 00:02:39.000
Tôi nghĩ rằng trò chơi của tôi có một lỗi.

00:02:39.000 --> 00:02:41.000
Điều tốt là đây là một cuộc nói chuyện gỡ lỗi.

00:02:41.000 --> 00:02:51.000
Hãy đặt một điểm dừng trong trình phân tích cú pháp và chạy lại lệnh của chúng ta.

00:02:51.000 --> 00:03:03.000
Trước tiên chúng ta nên xác minh rằng lệnh đã được đọc chính xác.

00:03:03.000 --> 00:03:11.000
Biến "từ" chứa lệnh được mã hóa.

00:03:11.000 --> 00:03:15.000
À, điều này đã không diễn ra như mong đợi.

00:03:15.000 --> 00:03:17.000
Tôi không biết chuyện gì đang xảy ra ở đây.

00:03:17.000 --> 00:03:25.000
Hôm qua tôi đã sử dụng trình gỡ lỗi mà không gặp vấn đề gì, và sau đó đêm qua tôi đã tích hợp khung giao diện người dùng này để tạo kiểu văn bản trên thiết bị đầu cuối.

00:03:25.000 --> 00:03:34.000
Các nhà phát triển của khuôn khổ đó có một hệ thống tích hợp liên tục tạo ra các bản dựng hàng đêm của khuôn khổ và tôi đang liên kết trực tiếp với cái mới nhất.

00:03:34.000 --> 00:03:39.000
Tôi tự hỏi liệu khuôn khổ này có liên quan gì đến những rắc rối gỡ lỗi của tôi không.

00:03:39.000 --> 00:03:47.000
Trường hợp điển hình, tôi đã nhận thấy rằng tôi không thể bước vào mã nguồn của khung, mặc dù tôi đã tải xuống bản dựng gỡ lỗi một cách rõ ràng.

00:03:47.000 --> 00:03:51.000
Nhìn kìa.

00:03:51.000 --> 00:03:54.000
Tôi chỉ thấy việc tháo gỡ.

00:03:54.000 --> 00:04:01.000
Hãy cố gắng hiểu những gì đã xảy ra ở đó, và hãy bắt đầu bằng cách tìm ra lý do tại sao tôi không thể thấy bất kỳ mã nguồn nào.

00:04:01.000 --> 00:04:05.000
LLDB cần gì để hiển thị mã nguồn?

00:04:05.000 --> 00:04:15.000
Khi trình biên dịch biên dịch một hàm, nó sẽ tạo ra mã máy.

00:04:15.000 --> 00:04:24.000
Và nó để lại vụn bánh mì cho trình gỡ lỗi để một địa chỉ trong tệp thực thi có thể được ánh xạ đến tệp nguồn và số dòng và ngược lại.

00:04:24.000 --> 00:04:28.000
Những mẩu bánh mì này được gọi là thông tin gỡ lỗi.

00:04:28.000 --> 00:04:33.000
Trên nền tảng Apple, thông tin gỡ lỗi được lưu trữ trong các tệp đối tượng.

00:04:33.000 --> 00:04:39.000
Để lưu trữ và phân phối, thông tin gỡ lỗi có thể được liên kết thành các gói .dSYM.

00:04:39.000 --> 00:04:43.000
Trình liên kết thông tin gỡ lỗi được gọi là dsymutil.

00:04:43.000 --> 00:04:50.000
LLDB sử dụng Spotlight để định vị các gói .dSYM, vì vậy nó khá linh hoạt về vị trí của chúng trên đĩa.

00:04:50.000 --> 00:04:55.000
Bây giờ chúng ta đã biết thông tin gỡ lỗi hoạt động như thế nào, hãy quay lại ví dụ.

00:04:55.000 --> 00:05:01.000
Đầu tiên, hãy xác minh rằng LLDB đã thực sự tìm thấy dSYM cho khuôn khổ.

00:05:01.000 --> 00:05:04.000
Chúng ta có thể làm điều này với lệnh danh sách hình ảnh.

00:05:04.000 --> 00:05:15.000
Khung giao diện người dùng được gọi là "TerminalInterface".

00:05:15.000 --> 00:05:19.000
Vâng, LLDB đã tìm thấy dSYM cho khuôn khổ.

00:05:19.000 --> 00:05:22.000
Điều đó có nghĩa là nó có quyền truy cập vào thông tin gỡ lỗi.

00:05:22.000 --> 00:05:30.000
Chúng ta có thể sử dụng "tra cứu hình ảnh" để có thêm thông tin về địa chỉ hiện tại.

00:05:30.000 --> 00:05:37.000
Nhân tiện, nếu bạn muốn tìm hiểu thêm về các tùy chọn khác nhau, LLDB có một trợ giúp tích hợp tuyệt vời.

00:05:37.000 --> 00:05:48.000
À, tôi nghĩ tôi hiểu tại sao không có mã nguồn: Đường dẫn nguồn này ở đây chỉ ra vị trí của các nguồn trên máy chủ xây dựng, không phải vị trí của chúng trên máy cục bộ của tôi.

00:05:48.000 --> 00:05:49.000
Chúng ta có thể sửa nó.

00:05:49.000 --> 00:06:04.000
LLDB có một bản đồ nguồn tích hợp mà chúng ta có thể sử dụng để chuyển hướng các đường dẫn này.

00:06:04.000 --> 00:06:09.000
Chúng ta có thể nhập lệnh ngay bây giờ, nhưng tôi muốn làm cho thay đổi này lâu dài hơn.

00:06:09.000 --> 00:06:25.000
Trong trình chỉnh sửa Sơ đồ, bạn có thể hiển thị bằng cách truy cập Sản phẩm, Sơ đồ, Sơ đồ chỉnh sửa hoặc chỉ bằng cách nhấp tùy chọn vào nút phát, bạn có thể xác định tệp init LLDB cho mỗi dự án.

00:06:25.000 --> 00:06:38.000
Tôi đã thêm một cái cho dự án này.

00:06:38.000 --> 00:06:52.000
Bây giờ chúng ta đã thiết lập LLDB, hãy chạy lại dự án của chúng ta.

00:06:52.000 --> 00:06:58.000
Và chúng tôi có mã nguồn.

00:06:58.000 --> 00:07:04.000
LLDB có thể ánh xạ lại các đường dẫn nguồn bằng cách sử dụng "cài đặt đặt target.source-map".

00:07:04.000 --> 00:07:10.000
Bạn có thể đặt lệnh này vào tệp .lldbinit của dự án để nó chạy tự động.

00:07:10.000 --> 00:07:18.000
Ngoài ra, mỗi gói .dSYM chứa một tệp XML .plist nơi bạn có thể đặt một từ điển ánh xạ lại tiền tố đường dẫn.

00:07:18.000 --> 00:07:29.000
Nếu bạn có tập lệnh tải xuống tìm nạp các bản dựng mới nhất từ máy chủ, bạn có thể sửa đổi tập lệnh đó để tự động đưa từ điển ánh xạ lại thích hợp vào .dSYM đã tải xuống.

00:07:29.000 --> 00:07:35.000
Bạn có thể tìm hiểu thêm về quy trình này trên trang web LLDB.

00:07:35.000 --> 00:07:44.000
Đường dẫn nguồn hoàn toàn không dành riêng cho ngôn ngữ, vì vậy phương pháp này hoạt động cho các dự án Swift, C++ và Objective-C.

00:07:44.000 --> 00:07:52.000
Để tìm hiểu thêm về các biểu tượng trên nền tảng của Apple, hãy xem "Biểu tượng: Ngoài những điều cơ bản" từ WWDC21.

00:07:52.000 --> 00:08:00.000
Khi mã nguồn được biên dịch trên trang trại máy chủ xây dựng, các đường dẫn từ xa đến các tệp nguồn có thể khác nhau giữa các máy.

00:08:00.000 --> 00:08:10.000
Để tránh phải xác định một tiền tố ánh xạ lại cho mỗi máy, chúng ta có thể hướng dẫn trình biên dịch chuẩn hóa các đường dẫn nguồn trước khi đưa chúng vào thông tin gỡ lỗi.

00:08:10.000 --> 00:08:14.000
Điều này được thực hiện bằng cách sử dụng tùy chọn -debug-prefix-map.

00:08:14.000 --> 00:08:24.000
Bằng cách này, tiền tố đường dẫn dành riêng cho máy có thể được thay thế bằng một tên giữ chỗ duy nhất, chuẩn, sau đó có thể được ánh xạ lại đến đường dẫn cục bộ trong LLDB.

00:08:24.000 --> 00:08:33.000
Trước khi chúng tôi tiếp xúc nguồn, tôi đã cố gắng in mô tả đối tượng của "từ".

00:08:33.000 --> 00:08:35.000
Điều đó đã không hiệu quả.

00:08:35.000 --> 00:08:45.000
Trên thực tế, thậm chí chỉ đánh giá cụm từ "từ" cũng không hiệu quả.

00:08:45.000 --> 00:08:51.000
Ít nhất chúng ta có thể thấy các biến trong chế độ xem các biến.

00:08:51.000 --> 00:09:05.000
Bảng điều khiển tương đương với chế độ xem biến Xcode là lệnh "biến khung" hoặc "v".

00:09:05.000 --> 00:09:14.000
Nếu bạn muốn tìm hiểu thêm về các sắc thái giữa các lệnh này, hãy xem "LLDB: Beyond 'po'" từ WWDC19.

00:09:14.000 --> 00:09:18.000
Vậy po là gì và tại sao nó vẫn không hoạt động?

00:09:18.000 --> 00:09:21.000
Để hiểu điều này có nghĩa là gì, chúng ta cần tìm hiểu thêm về LLDB.

00:09:21.000 --> 00:09:25.000
Xin nhắc lại, LLDB là một trình gỡ lỗi.

00:09:25.000 --> 00:09:27.000
Nhưng LLDB không chỉ là một trình gỡ lỗi.

00:09:27.000 --> 00:09:30.000
Nó cũng là một trình biên dịch!

00:09:30.000 --> 00:09:37.000
Ngoài chức năng của trình gỡ lỗi, LLDB cũng bao gồm một bản sao đầy đủ chức năng của trình biên dịch Swift và Clang.

00:09:37.000 --> 00:09:45.000
Các trình biên dịch này cung cấp năng lượng cho trình đánh giá biểu thức của LLDB, mà bạn có thể biết thông qua bí danh lệnh p và po.

00:09:45.000 --> 00:09:55.000
Với trình đánh giá biểu thức, chúng ta có thể vượt ra ngoài việc xem xét các biến, chúng ta có thể thực hiện tính toán, gọi các hàm và thậm chí thay đổi trạng thái của chương trình.

00:09:55.000 --> 00:10:04.000
Kiểm tra "Gỡ lỗi nâng cao với Xcode và LLDB" từ WWDC18 để có được một số ý tưởng về những gì có thể với các lệnh đó.

00:10:04.000 --> 00:10:09.000
Trình gỡ lỗi định dạng biến cục bộ như thế nào?

00:10:09.000 --> 00:10:15.000
Thông tin gỡ lỗi do trình biên dịch cung cấp cho trình gỡ lỗi biết nơi lưu trữ một biến trong bộ nhớ.

00:10:15.000 --> 00:10:22.000
Nhưng chỉ với thông tin đó, LLDB sẽ chỉ có thể hiển thị cho chúng ta một loại byte thô ngẫu nhiên.

00:10:22.000 --> 00:10:26.000
Vậy làm thế nào để LLDB biến nó thành đầu ra được định dạng độc đáo?

00:10:26.000 --> 00:10:28.000
Câu trả lời là các loại.

00:10:28.000 --> 00:10:34.000
Thông tin loại cho phép LLDB hiểu cấu trúc và bố cục bộ nhớ của một biến nguồn.

00:10:34.000 --> 00:10:45.000
Với thông tin loại, LLDB biết loại tổng hợp có những trường nào và các loại cho phép LLDB sử dụng các trình định dạng dữ liệu thích hợp để in chúng đẹp mắt.

00:10:45.000 --> 00:10:50.000
Bây giờ hãy xem thông tin loại đến từ đâu.

00:10:50.000 --> 00:10:59.000
Ở phía trình gỡ lỗi, nơi biến khung và lệnh v hoạt động, LLDB lấy thông tin loại từ Thông tin gỡ lỗi.

00:10:59.000 --> 00:11:04.000
Và LLDB cũng nhận được các loại từ siêu dữ liệu phản ánh Swift.

00:11:04.000 --> 00:11:12.000
Về phía trình biên dịch, nơi trình đánh giá biểu thức và po trực tiếp, LLDB lấy thông tin loại từ Mô-đun.

00:11:12.000 --> 00:11:21.000
Sự tách biệt sạch sẽ này là mới trong Xcode 14 và giải thích lý do tại sao chế độ xem biến có thể hoạt động đầy đủ ngay cả khi trình đánh giá biểu thức không có.

00:11:21.000 --> 00:11:24.000
Mô-đun là cách trình biên dịch tổ chức khai báo kiểu.

00:11:24.000 --> 00:11:32.000
Trình biên dịch Swift biết nhiều cách nhập mô-đun, nhưng trước khi chúng ta đi sâu vào đó, tôi muốn cho bạn thấy một tính năng mới tiện dụng.

00:11:32.000 --> 00:11:38.000
Làm thế nào để chúng ta bắt đầu chẩn đoán một vấn đề đang xảy ra ở phía trình biên dịch?

00:11:38.000 --> 00:11:42.000
Năm nay LLDB đã thêm một lệnh "kiểm tra sức khỏe nhanh" mới.

00:11:42.000 --> 00:11:47.000
Đây là điểm dừng đầu tiên của bạn để tìm hiểu xem việc nhập mô-đun có thất bại hay không.

00:11:47.000 --> 00:11:49.000
Để tôi chỉ cho bạn cách thức hoạt động của nó.

00:11:49.000 --> 00:12:05.000
Bằng cách chạy swift-healthcheck sau khi sự cố xảy ra, chúng ta có thể truy cập vào nhật ký của cấu hình trình đánh giá biểu thức Swift.

00:12:05.000 --> 00:12:11.000
Ở cuối nhật ký, chúng tôi thấy rằng LLDB gặp sự cố khi nhập mô-đun Swift "TerminalUI".

00:12:11.000 --> 00:12:18.000
Dựa trên tên, tôi cho rằng đây là một chi tiết triển khai của khung TerminalInterface.

00:12:18.000 --> 00:12:33.000
Mô-đun bị thiếu này là một vấn đề vì loại bản thân là chung chung so với việc triển khai giao diện người dùng và nếu không có mô-đun chứa loại đó, trình đánh giá biểu thức không thể nhận ra loại động của "bản thân".

00:12:33.000 --> 00:12:37.000
Tôi đang gửi một tin nhắn đến các nhà phát triển của khuôn khổ và yêu cầu họ điều tra.

00:12:37.000 --> 00:12:41.000
Theo kinh nghiệm của tôi, họ luôn phản hồi rất nhanh.

00:12:41.000 --> 00:12:45.000
Ai biết được, có lẽ chúng ta thậm chí có thể tìm ra giải pháp trước khi kết thúc video này.

00:12:45.000 --> 00:12:52.000
Trong thời gian chờ đợi, chúng ta hãy xem cách trình biên dịch của LLDB tìm thấy các mô-đun Swift.

00:12:52.000 --> 00:12:55.000
Ứng dụng của tôi có mô-đun Swift riêng.

00:12:55.000 --> 00:13:00.000
Nó có thể nhập một khung hệ thống, chẳng hạn như Foundation.

00:13:00.000 --> 00:13:06.000
Khung hệ thống là các tệp giao diện Swift ổn định về văn bản nằm trong SDK.

00:13:06.000 --> 00:13:16.000
Bất kỳ mô-đun Swift nào cũng có thể nhập mô-đun Clang, đây là tên ưa thích cho một hoặc nhiều tệp tiêu đề được nhóm lại cùng với sự trợ giúp của tệp bản đồ mô-đun.

00:13:16.000 --> 00:13:21.000
Các mô-đun Clang có thể phụ thuộc vào các mô-đun Clang khác.

00:13:21.000 --> 00:13:26.000
Ứng dụng của tôi cũng có thể nhập một mô-đun Swift thuộc về một khuôn khổ được xây dựng cục bộ.

00:13:26.000 --> 00:13:32.000
Nó cũng có thể nhập các tệp giao diện Swift văn bản không phải là một phần của SDK.

00:13:32.000 --> 00:13:39.000
Nếu bạn muốn tìm hiểu cách thực hiện, hãy xem "Khung nhị phân trong Swift" từ WWDC19.

00:13:39.000 --> 00:13:47.000
Ứng dụng của tôi cũng có thể liên kết với một thư viện tĩnh có chứa mã Swift, và sau đó cũng đi kèm với một mô-đun Swift.

00:13:47.000 --> 00:13:49.000
Hmm, chúng ta vẫn chưa xong.

00:13:49.000 --> 00:13:54.000
Tôi nên đề cập rằng cũng có các tiêu đề bắc cầu, cũng có thể nhập các mô-đun Clang.

00:13:54.000 --> 00:14:02.000
Cuối cùng, như một tính năng đặc biệt chỉ trong LLDB, một số nội dung mô-đun có thể được xây dựng lại chỉ từ thông tin gỡ lỗi.

00:14:02.000 --> 00:14:04.000
Đó là rất nhiều nguồn!

00:14:04.000 --> 00:14:07.000
Làm thế nào để LLDB tìm thấy tất cả chúng?

00:14:07.000 --> 00:14:12.000
Công việc của hệ thống xây dựng là đóng gói các mô-đun để LLDB có thể tìm thấy chúng.

00:14:12.000 --> 00:14:16.000
Các mô-đun từ các khung hệ thống vẫn ở trong SDK.

00:14:16.000 --> 00:14:22.000
LLDB sẽ tìm thấy một SDK phù hợp để đọc chúng khi nó được đính kèm vào chương trình của bạn.

00:14:22.000 --> 00:14:29.000
Khi gỡ lỗi trực tiếp từ các tệp đối tượng, LLDB sẽ tìm thấy tất cả các mô-đun không phải SDK nơi chúng đang ở thời điểm xây dựng.

00:14:29.000 --> 00:14:40.000
Dsymutil có thể đóng gói một kho lưu trữ thông tin gỡ lỗi được gọi là a. Gói DSYM cho mọi thư viện động, khung hoặc dylib và có thể thực thi.

00:14:40.000 --> 00:14:49.000
Mỗi gói .dSYM có thể chứa các mô-đun Swift nhị phân, có thể chứa các tiêu đề bắc cầu, tệp giao diện Swift văn bản và quan trọng nhất là thông tin gỡ lỗi.

00:14:49.000 --> 00:14:51.000
Điều đó bao gồm mọi thứ.

00:14:51.000 --> 00:14:53.000
Mọi thứ?

00:14:53.000 --> 00:14:59.000
Tất cả mọi thứ ngoại trừ các mô-đun Swift thuộc về kho lưu trữ tĩnh.

00:14:59.000 --> 00:15:05.000
Để mô-đun Swift được dsymutil chọn, nó cần được đăng ký với trình liên kết.

00:15:05.000 --> 00:15:10.000
Đối với các thư viện động và tệp thực thi, hệ thống xây dựng sẽ tự động thực hiện việc này cho bạn.

00:15:10.000 --> 00:15:18.000
Nhưng các kho lưu trữ tĩnh không được tạo ra bởi trình liên kết, chúng chỉ là tập hợp các tệp đối tượng, giống như tệp zip.

00:15:18.000 --> 00:15:29.000
Điều đó có nghĩa là trách nhiệm đăng ký bất kỳ mô-đun Swift nào với trình liên kết rơi vào mọi thư viện thực thi hoặc động liên kết kho lưu trữ tĩnh.

00:15:29.000 --> 00:15:34.000
Trong nhiều trường hợp, hệ thống xây dựng của Xcode sẽ làm điều này cho bạn.

00:15:34.000 --> 00:15:44.000
Nhưng nếu bạn đang duy trì hệ thống xây dựng tùy chỉnh của riêng mình hoặc nếu bạn đã xác định các quy tắc xây dựng tùy chỉnh, đây là điều cần lưu ý.

00:15:44.000 --> 00:15:52.000
Khi sử dụng trình liên kết Apple, các mô-đun Swift cần được đăng ký với tùy chọn -add-ast-path.

00:15:52.000 --> 00:15:57.000
Kiểm tra nhật ký xây dựng của bạn để xác minh rằng đây là trường hợp.

00:15:57.000 --> 00:16:08.000
Bạn cũng có thể sử dụng dsymutil để đổ bảng biểu tượng của tệp thực thi của mình và grep cho "swiftmodule" để xác minh rằng nó đã hoạt động.

00:16:08.000 --> 00:16:20.000
Trên các nền tảng khác như Linux, trình điều khiển swift hỗ trợ hành động -modulewrap chuyển đổi các tệp mô-đun Swift nhị phân thành các đối tượng mà bạn có thể liên kết thành tệp nhị phân của mình cùng với phần còn lại của thông tin gỡ lỗi.

00:16:20.000 --> 00:16:23.000
LLDB sẽ tìm thấy nó ở đó.

00:16:23.000 --> 00:16:27.000
Các nhà phát triển của khuôn khổ đã phản hồi đáng kinh ngạc.

00:16:27.000 --> 00:16:33.000
Như chúng tôi đã nghi ngờ, hóa ra là một phần của hệ thống xây dựng của khuôn khổ, một kho lưu trữ tĩnh được sử dụng.

00:16:33.000 --> 00:16:38.000
Và đó là mô-đun Swift thuộc về kho lưu trữ tĩnh bị thiếu trong gói dSYM.

00:16:38.000 --> 00:16:41.000
Bây giờ tôi đã cài đặt một phiên bản cố định của khung.

00:16:41.000 --> 00:16:49.000
Nó đã đăng ký mô-đun tĩnh bị thiếu với trình liên kết và vì vậy dsymutil đã có thể thu thập nó.

00:16:49.000 --> 00:16:54.000
Bây giờ bản thân có thể được giải quyết.

00:16:54.000 --> 00:17:01.000
Và chúng ta có thể in mô tả đối tượng của "từ".

00:17:01.000 --> 00:17:12.000
Vì dù sao chúng tôi cũng đang sử dụng bảng điều khiển, tôi đang sử dụng bí danh s để bước vào hàm parseFrom.

00:17:12.000 --> 00:17:26.000
Và bây giờ chúng ta cũng có thể dễ dàng tìm thấy lỗi, đây chỉ là lỗi sao chép và dán ở đây.

00:17:26.000 --> 00:17:53.000
Và cùng với đó, chúng tôi không chỉ giải được câu đố về mô-đun Swift bị thiếu, mà còn là câu đố đầu tiên của trò chơi.

00:17:53.000 --> 00:17:57.000
Trước khi chúng ta kết thúc, tôi có thêm một chi tiết cần chú ý.

00:17:57.000 --> 00:18:04.000
Trình biên dịch Swift sẽ tuần tự hóa các đường dẫn tìm kiếm tiêu đề Clang và các tùy chọn liên quan khác vào các tệp nhị phân .swiftmodule.

00:18:04.000 --> 00:18:11.000
Điều này thật tuyệt vì nó làm cho việc nhập các phụ thuộc mô-đun Clang của họ chỉ hoạt động trong quá trình xây dựng.

00:18:11.000 --> 00:18:16.000
Nhưng khi xây dựng trên một cỗ máy khác, những con đường cục bộ này có thể gây bất lợi.

00:18:16.000 --> 00:18:25.000
Vì vậy, trước khi vận chuyển một mô-đun .swift nhị phân sang một máy khác, hãy cân nhắc xây dựng với cờ Trình biên dịch -no-serialize-debugging-options.

00:18:25.000 --> 00:18:32.000
Trong Xcode, điều này được kiểm soát thông qua cài đặt SWIFT_SERIALIZE_DEBUGGING_OPTIONS.

00:18:32.000 --> 00:18:38.000
Bạn có thể giới thiệu lại các đường dẫn tìm kiếm này trong LLDB với một trong các cài đặt sau.

00:18:38.000 --> 00:18:40.000
Hãy tóm tắt lại những gì chúng ta đã học được.

00:18:40.000 --> 00:18:47.000
Nếu bạn muốn gửi mã từ máy này sang máy khác, bạn nên tự hỏi mình mức độ gỡ lỗi mà bạn mong đợi sẽ làm.

00:18:47.000 --> 00:18:59.000
Ví dụ: nếu bạn gửi một khung nhị phân cho một nhà phát triển khác và bạn không mong đợi họ bước vào mã của bạn trong trình gỡ lỗi, tốt nhất bạn chỉ gửi mô-đun Swift dưới dạng tệp giao diện .swift văn bản.

00:18:59.000 --> 00:19:15.000
Nhưng nếu bạn đang thiết lập một máy chủ xây dựng hoặc một hệ thống tích hợp liên tục, nơi các nhà phát triển dự kiến sẽ gỡ lỗi các tạo tác xây dựng đã tải xuống, bạn sẽ muốn đảm bảo xây dựng một mô-đun Swift nhị phân và xem xét tắt tuần tự hóa đường dẫn tìm kiếm.

00:19:15.000 --> 00:19:21.000
Bạn cũng có thể chuẩn hóa các đường dẫn nguồn trên máy chủ trong thông tin gỡ lỗi bằng cách sử dụng tùy chọn -debug-prefix-map.

00:19:21.000 --> 00:19:24.000
Đó là tất cả những gì tôi dành cho bạn.

00:19:24.000 --> 00:19:30.000
Hôm nay chúng ta đã tìm hiểu về bản chất kép của LLDB như một trình gỡ lỗi và một trình biên dịch.

00:19:30.000 --> 00:19:38.000
Trình gỡ lỗi cần thông tin gỡ lỗi và siêu dữ liệu phản ánh để hoạt động và cung cấp chế độ xem biến Xcode và lệnh v.

00:19:38.000 --> 00:19:43.000
Trình biên dịch cần Mô-đun và nhạy cảm với các đường dẫn tìm kiếm.

00:19:43.000 --> 00:19:47.000
Nó đứng sau các lệnh expr, p và po.

00:19:47.000 --> 00:19:54.000
Một cách tốt để có được chẩn đoán trình biên dịch là lệnh kiểm tra sức khỏe nhanh mới trong LLDB.

00:19:54.000 --> 23:59:59.000
Cảm ơn bạn đã xem! ♪ ♪

