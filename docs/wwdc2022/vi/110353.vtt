WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:12.000
Xin chào, tôi là Slava từ nhóm biên dịch swift.

00:00:12.000 --> 00:00:17.000
Chào mừng đến với Thiết kế Giao diện Giao thức trong Swift.

00:00:17.000 --> 00:00:30.000
Tôi sẽ tiếp tục nơi mà Embrace Swift Generics nói chuyện đã dừng lại và chỉ cho bạn một số kỹ thuật nâng cao để trừu tượng hóa các loại cụ thể và mô hình hóa các mối quan hệ loại bằng cách sử dụng các giao thức.

00:00:30.000 --> 00:00:40.000
Bài nói chuyện này sẽ bao gồm cả các tính năng ngôn ngữ hiện có, cũng như một số khả năng mới được giới thiệu trong Swift 5.7.

00:00:40.000 --> 00:00:53.000
Bài nói chuyện này có ba chủ đề chính: Đầu tiên, tôi sẽ chỉ cho bạn cách các giao thức với các loại liên quan tương tác với các loại 'bất kỳ' hiện sinh, bằng cách giải thích cách hoạt động của 'xóa loại kết quả'.

00:00:53.000 --> 00:01:03.000
Tiếp theo, tôi sẽ giải thích bằng cách sử dụng các loại kết quả mờ đục để cải thiện việc đóng gói bằng cách tách giao diện khỏi việc triển khai.

00:01:03.000 --> 00:01:14.000
Đối với chủ đề cuối cùng, bạn sẽ thấy các yêu cầu cùng loại trong các giao thức có thể mô hình hóa mối quan hệ giữa nhiều bộ loại cụ thể khác nhau như thế nào.

00:01:14.000 --> 00:01:22.000
Hãy bắt đầu bằng cách tìm hiểu cách các giao thức với các loại liên quan tương tác với các loại hiện sinh.

00:01:22.000 --> 00:01:28.000
Ở đây, chúng tôi có một mô hình dữ liệu với một cặp giao thức và bốn loại cụ thể.

00:01:28.000 --> 00:01:35.000
Có hai loại động vật, gà và bò, và hai loại thức ăn, trứng và sữa.

00:01:35.000 --> 00:01:39.000
Gà sản xuất trứng, và bò sản xuất sữa.

00:01:39.000 --> 00:01:46.000
Để tóm tắt việc sản xuất thực phẩm, tôi sẽ thêm một phương thức produce() vào giao thức Animal.

00:01:46.000 --> 00:01:58.000
Bạn có thể nhớ từ bài nói chuyện 'Embrace swift generics' rằng cách tốt nhất để trừu tượng hóa các loại sản phẩm trả về khác nhau () trên Cow and Chicken là sử dụng một loại liên quan.

00:01:58.000 --> 00:02:12.000
Bằng cách sử dụng một loại liên quan, chúng tôi đang tuyên bố rằng: đưa ra một số loại Động vật cụ thể, việc gọi produce() trả về một số loại Thực phẩm cụ thể, phụ thuộc vào loại Động vật cụ thể.

00:02:12.000 --> 00:02:15.000
Chúng ta có thể thể hiện mối quan hệ này bằng một sơ đồ.

00:02:15.000 --> 00:02:22.000
Loại giao thức 'Self' là viết tắt của loại bê tông thực tế phù hợp với giao thức 'Động vật'.

00:02:22.000 --> 00:02:28.000
Loại 'Bản thân' có loại 'Hàng hóa' liên quan, phù hợp với 'Thực phẩm'.

00:02:28.000 --> 00:02:37.000
Hãy xem xét mối quan hệ giữa các loại Gà và Bò cụ thể và sơ đồ loại liên quan cho giao thức Động vật.

00:02:37.000 --> 00:02:42.000
Loại Gà phù hợp với giao thức Động vật với Loại Hàng hóa là 'Trứng'.

00:02:42.000 --> 00:02:48.000
Và loại Bò phù hợp với giao thức Động vật với Loại Hàng hóa là 'Sữa'.

00:02:48.000 --> 00:02:51.000
Bây giờ, giả sử chúng ta có một trang trại đầy động vật.

00:02:51.000 --> 00:02:58.000
Tài sản được lưu trữ 'động vật' trong Trang trại là một mảng không đồng nhất của 'bất kỳ Động vật nào'.

00:02:58.000 --> 00:03:09.000
Khi nắm lấy thuốc generic Swift, chúng tôi đã thấy cách 'bất kỳ loại Động vật nào' có biểu diễn hộp có khả năng lưu trữ bất kỳ loại động vật cụ thể nào một cách linh hoạt.

00:03:09.000 --> 00:03:17.000
Chiến lược sử dụng cùng một biểu diễn cho các loại cụ thể khác nhau được gọi là xóa loại.

00:03:17.000 --> 00:03:24.000
Phương thức produceCommodities() ánh xạ qua mảng động vật, gọi phương thức produce() trên mỗi cái.

00:03:24.000 --> 00:03:37.000
Phương pháp này có vẻ đơn giản, nhưng chúng tôi biết rằng việc xóa kiểu sẽ loại bỏ các mối quan hệ kiểu tĩnh với loại động vật cơ bản, vì vậy bạn nên tìm hiểu sâu hơn để hiểu lý do tại sao loại mã này kiểm tra.

00:03:37.000 --> 00:03:43.000
Tham số 'động vật' trong đóng bản đồ () có loại 'bất kỳ Động vật nào'.

00:03:43.000 --> 00:03:47.000
Kiểu trả về của 'produce()' là một kiểu liên quan.

00:03:47.000 --> 00:03:58.000
Khi bạn gọi một phương thức trả về một kiểu liên quan trên một kiểu hiện sinh, trình biên dịch sẽ sử dụng xóa kiểu để xác định loại kết quả của cuộc gọi.

00:03:58.000 --> 00:04:05.000
Xóa kiểu thay thế các loại liên quan này bằng các loại hiện sinh tương ứng có các ràng buộc tương đương.

00:04:05.000 --> 00:04:16.000
Chúng tôi đã xóa mối quan hệ giữa loại Động vật cụ thể và Loại Hàng hóa liên quan bằng cách thay thế chúng bằng 'bất kỳ Động vật nào' và 'bất kỳ Thực phẩm nào'.

00:04:16.000 --> 00:04:22.000
Loại 'bất kỳ Thực phẩm nào' được gọi là giới hạn trên của Loại Hàng hóa liên quan.

00:04:22.000 --> 00:04:31.000
Vì phương thức produce() được gọi trên 'bất kỳ Động vật nào', giá trị trả về sẽ bị xóa kiểu, cho chúng ta giá trị của loại 'Bất kỳ Thực phẩm nào'.

00:04:31.000 --> 00:04:34.000
Đây chính xác là loại mà chúng tôi mong đợi ở đây.

00:04:34.000 --> 00:04:41.000
Chúng ta hãy xem xét kỹ hơn cách hoạt động của việc xóa kiểu liên kết, đây là một tính năng mới trong Swift 5.7.

00:04:41.000 --> 00:04:56.000
Một loại liên quan xuất hiện trong loại kết quả của một phương thức giao thức - ở phía bên tay phải của mũi tên - được cho là ở 'vị trí sản xuất', bởi vì việc gọi phương thức sẽ tạo ra một giá trị của loại này.

00:04:56.000 --> 00:05:06.000
Khi chúng tôi gọi phương thức này trên 'bất kỳ Động vật nào', chúng tôi không biết loại kết quả cụ thể tại thời điểm biên dịch, nhưng chúng tôi biết rằng nó là một loại phụ của giới hạn trên.

00:05:06.000 --> 00:05:13.000
Ở đây trong ví dụ này, chúng tôi đang gọi produce() trên một 'bất kỳ Động vật nào' giữ một Con bò trong thời gian chạy.

00:05:13.000 --> 00:05:17.000
Trong trường hợp của chúng tôi, phương thức produce() trên Cow trả về Sữa.

00:05:17.000 --> 00:05:27.000
Sữa có thể được lưu trữ bên trong 'bất kỳ Thực phẩm nào', đây là giới hạn trên của Loại Hàng hóa liên quan của giao thức Động vật.

00:05:27.000 --> 00:05:34.000
Điều này luôn an toàn, cho tất cả các loại cụ thể phù hợp với giao thức Động vật.

00:05:34.000 --> 00:05:42.000
Mặt khác, hãy suy nghĩ về điều gì sẽ xảy ra nếu loại liên quan xuất hiện trong danh sách tham số của một phương thức hoặc trình khởi tạo.

00:05:42.000 --> 00:05:49.000
Ở đây, phương thức eat() trên giao thức Animal có FeedType liên quan ở vị trí tiêu thụ.

00:05:49.000 --> 00:05:53.000
Chúng ta cần chuyển một giá trị của loại này để gọi phương thức.

00:05:53.000 --> 00:05:59.000
Vì việc chuyển đổi đi theo hướng khác, việc xóa kiểu không thể được thực hiện.

00:05:59.000 --> 00:06:10.000
Loại hiện sinh giới hạn trên cho loại liên quan không chuyển đổi an toàn sang loại bê tông thực tế, bởi vì loại bê tông không được biết.

00:06:10.000 --> 00:06:11.000
Hãy xem xét một ví dụ.

00:06:11.000 --> 00:06:15.000
Một lần nữa, chúng ta có một 'bất kỳ Động vật nào' đang cất giữ một Con Bò.

00:06:15.000 --> 00:06:19.000
Giả sử rằng phương pháp 'ăn' trên Cow lấy Hay.

00:06:19.000 --> 00:06:25.000
Giới hạn trên của 'FeedType' liên quan đến giao thức Animal là 'bất kỳ AnimalFeed' nào.

00:06:25.000 --> 00:06:34.000
Nhưng với một 'bất kỳ AnimalFeed' tùy ý, không có cách nào để đảm bảo tĩnh rằng nó lưu trữ loại bê tông 'Hay'.

00:06:34.000 --> 00:06:40.000
Xóa loại không cho phép chúng tôi làm việc với các loại liên quan ở vị trí tiêu thụ.

00:06:40.000 --> 00:06:49.000
Thay vào đó, bạn phải mở hộp loại 'bất kỳ' hiện sinh bằng cách chuyển nó đến một hàm có kiểu 'một số' mờ đục.

00:06:49.000 --> 00:06:58.000
Hành vi xóa loại này với các loại liên quan thực sự tương tự như một tính năng ngôn ngữ hiện có mà bạn có thể đã thấy trong Swift 5.6.

00:06:58.000 --> 00:07:02.000
Hãy xem xét một giao thức cho các loại tham chiếu nhân bản.

00:07:02.000 --> 00:07:06.000
Giao thức này xác định một phương thức clone() duy nhất, trả về Self.

00:07:06.000 --> 00:07:16.000
Khi bạn gọi clone() trên một giá trị của loại 'bất kỳ Cloneable', loại kết quả 'Self', sẽ bị xóa vào giới hạn trên của nó.

00:07:16.000 --> 00:07:25.000
Giới hạn trên của loại Self luôn là chính giao thức, vì vậy chúng tôi nhận lại một giá trị mới của loại 'bất kỳ Bản sao nào'.

00:07:25.000 --> 00:07:36.000
Vì vậy, để tóm tắt: bạn có thể sử dụng 'bất kỳ' để tuyên bố rằng loại giá trị là một loại tồn tại lưu trữ một số loại cụ thể phù hợp với giao thức.

00:07:36.000 --> 00:07:40.000
Điều này thậm chí còn hoạt động với các giao thức có các loại liên quan.

00:07:40.000 --> 00:07:54.000
Khi gọi một phương thức giao thức với một kiểu liên quan ở vị trí sản xuất, kiểu liên quan sẽ bị xóa kiểu ở giới hạn trên của nó, đây là một kiểu hiện sinh khác mang các ràng buộc của kiểu liên quan.

00:07:54.000 --> 00:08:07.000
Trừu tượng hóa trên các loại cụ thể không chỉ hữu ích cho các đầu vào hàm - nó cũng hữu ích cho các đầu ra hàm, do đó các loại cụ thể chỉ hiển thị từ việc triển khai.

00:08:07.000 --> 00:08:22.000
Chúng ta hãy xem cách trừu tượng hóa các loại kết quả cụ thể để tách giao diện thiết yếu của một đoạn mã khỏi các chi tiết triển khai của nó, làm cho các phép gán loại tĩnh trở nên mô-đun và mạnh mẽ hơn khi đối mặt với những thay đổi.

00:08:22.000 --> 00:08:27.000
Hãy khái quát hóa giao thức Động vật để cho phép cho Động vật ăn.

00:08:27.000 --> 00:08:30.000
Động vật bị đói, và khi chúng đói chúng cần ăn.

00:08:30.000 --> 00:08:35.000
Hãy thêm một thuộc tính isHungry vào giao thức Animal.

00:08:35.000 --> 00:08:40.000
Phương thức feedAnimals() trên Farm sẽ cung cấp cho tập hợp con động vật đang đói.

00:08:40.000 --> 00:08:47.000
Tôi đã chia nhỏ việc tính toán tập hợp con động vật đói này thành một tài sản hungryAnimals.

00:08:47.000 --> 00:08:56.000
Việc triển khai ban đầu này của hungryAnimals() sử dụng phương thức filter() để chọn tập hợp con của động vật trong đó thuộc tính isHungry là đúng.

00:08:56.000 --> 00:09:03.000
Gọi filter() trên một mảng 'bất kỳ Động vật' nào' trả về một mảng mới của 'bất kỳ Động vật nào'.

00:09:03.000 --> 00:09:13.000
Bây giờ bạn có thể nhận thấy rằng feedAnimals() chỉ lặp lại kết quả của hungryAnimals một lần, và sau đó ngay lập tức loại bỏ mảng tạm thời này.

00:09:13.000 --> 00:09:18.000
Điều này sẽ không hiệu quả nếu trang trại chứa một số lượng lớn động vật đói.

00:09:18.000 --> 00:09:25.000
Một cách để tránh sự phân bổ tạm thời này là sử dụng tính năng bộ sưu tập lười biếng của thư viện tiêu chuẩn.

00:09:25.000 --> 00:09:33.000
Bằng cách thay thế lệnh gọi 'filter' bằng 'lazy.filter', chúng ta có được cái được gọi là bộ sưu tập lười biếng.

00:09:33.000 --> 00:09:43.000
Một bộ sưu tập lười biếng có các phần tử giống như mảng được trả về bởi một cuộc gọi đơn giản đến 'bộ lọc', nhưng nó tránh được sự phân bổ tạm thời.

00:09:43.000 --> 00:09:55.000
Tuy nhiên, bây giờ loại thuộc tính 'hungryAnimals' phải được khai báo là loại cụ thể khá phức tạp này, 'LazyFilterSequence of Array of any Animal'.

00:09:55.000 --> 00:10:00.000
Điều này phơi bày một chi tiết triển khai không cần thiết.

00:10:00.000 --> 00:10:14.000
Khách hàng, feedAnimals(), không quan tâm rằng chúng tôi đã sử dụng 'lazy.filter' trong việc triển khai 'hungryAnimals'; nó chỉ cần biết rằng nó đang nhận được một số bộ sưu tập mà nó có thể lặp lại.

00:10:14.000 --> 00:10:23.000
Một loại kết quả mờ đục có thể được sử dụng để ẩn loại bê tông phức tạp đằng sau giao diện trừu tượng của Bộ sưu tập.

00:10:23.000 --> 00:10:36.000
Bây giờ khách hàng gọi là 'hungryAnimals' chỉ biết rằng họ đang nhận được một số loại cụ thể phù hợp với giao thức Bộ sưu tập, nhưng họ không biết loại bộ sưu tập cụ thể cụ thể.

00:10:36.000 --> 00:10:43.000
Tuy nhiên như đã viết, điều này thực sự che giấu quá nhiều thông tin kiểu tĩnh khỏi khách hàng.

00:10:43.000 --> 00:10:53.000
Chúng tôi đang tuyên bố rằng hungryAnimals xuất ra một số loại cụ thể phù hợp với Bộ sưu tập, nhưng chúng tôi không biết gì về loại Phần tử của Bộ sưu tập này.

00:10:53.000 --> 00:11:06.000
Nếu không biết rằng loại phần tử là 'bất kỳ Động vật nào', tất cả những gì chúng ta có thể làm với loại phần tử là chuyển nó đi; chúng ta không thể gọi bất kỳ phương thức nào của giao thức Động vật.

00:11:06.000 --> 00:11:10.000
Hãy tập trung vào loại kết quả mờ đục 'một số Bộ sưu tập'.

00:11:10.000 --> 00:11:22.000
Chúng ta có thể đạt được sự cân bằng phù hợp giữa việc ẩn các chi tiết triển khai và phơi bày một giao diện đủ phong phú bằng cách sử dụng loại kết quả mờ đục bị hạn chế.

00:11:22.000 --> 00:11:26.000
Các loại kết quả mờ đục bị hạn chế là mới trong Swift 5.7.

00:11:26.000 --> 00:11:34.000
Một loại kết quả mờ đục bị hạn chế được viết bằng cách áp dụng các đối số loại trong dấu ngoặc góc sau tên giao thức.

00:11:34.000 --> 00:11:39.000
Giao thức Bộ sưu tập có một đối số loại duy nhất, loại Phần tử.

00:11:39.000 --> 00:12:03.000
Bây giờ một khi 'hungryAnimals' được khai báo với một loại kết quả mờ đục bị hạn chế, thực tế là nó thực sự là một 'LazyFilterSequence của một mảng của bất kỳ Động vật nào' bị ẩn khỏi khách hàng; nhưng khách hàng vẫn biết rằng đó là một số loại cụ thể phù hợp với Bộ sưu tập, có loại

00:12:03.000 --> 00:12:07.000
Đây chính xác là giao diện mà chúng tôi muốn ở đây.

00:12:07.000 --> 00:12:20.000
Bên trong vòng lặp for trong 'feedAnimals()', biến 'động vật' có loại 'bất kỳ Động vật nào', cho phép các phương thức của giao thức Động vật được gọi trên mỗi động vật đói.

00:12:20.000 --> 00:12:30.000
Tất cả điều này hoạt động vì giao thức Bộ sưu tập tuyên bố rằng loại liên kết Phần tử là loại liên kết chính.

00:12:30.000 --> 00:12:41.000
Bạn có thể khai báo các giao thức của riêng mình với các loại liên quan chính bằng cách đặt tên cho một hoặc nhiều loại liên quan trong dấu ngoặc nhọn sau tên giao thức, như thế này.

00:12:41.000 --> 00:12:58.000
Các loại liên quan hoạt động tốt nhất như các loại liên kết chính là những loại thường được cung cấp bởi người gọi, chẳng hạn như loại Phần tử của bộ sưu tập, trái ngược với chi tiết triển khai, chẳng hạn như loại Trình lặp của bộ sưu tập.

00:12:58.000 --> 00:13:07.000
Thông thường, bạn sẽ thấy sự tương ứng giữa các loại giao thức liên quan chính và các tham số chung của một loại cụ thể phù hợp với giao thức này.

00:13:07.000 --> 00:13:21.000
Tại đây, bạn có thể thấy rằng loại 'Bộ sưu tập' liên quan đến phần tử chính được thực hiện bởi tham số chung 'Phần tử' của Mảng và Bộ, hai loại cụ thể được xác định bởi thư viện tiêu chuẩn mà cả hai đều phù hợp với Bộ sưu tập.

00:13:21.000 --> 00:13:32.000
'Bộ sưu tập của Element' có thể được sử dụng với các loại kết quả mờ đục bằng cách sử dụng từ khóa 'some', cũng như với các loại hiện sinh bị hạn chế bằng cách sử dụng từ khóa 'bất kỳ'.

00:13:32.000 --> 00:13:41.000
Trước Swift 5.7, bạn sẽ cần phải viết kiểu dữ liệu của riêng mình để biểu diễn một kiểu hiện sinh với một đối số chung cụ thể.

00:13:41.000 --> 00:13:48.000
Swift 5.7 xây dựng khái niệm này thành ngôn ngữ với các kiểu hiện sinh bị hạn chế.

00:13:48.000 --> 00:14:06.000
Nếu chúng tôi muốn hungryAnimals có tùy chọn tính toán hungryAnimals một cách lười biếng hay háo hức, việc sử dụng Bộ sưu tập mờ đục của bất kỳ Động vật nào sẽ dẫn đến lỗi mà hàm trả về hai loại cơ bản khác nhau.

00:14:06.000 --> 00:14:16.000
Thay vào đó, chúng tôi có thể khắc phục điều này bằng cách trả về 'bất kỳ Bộ sưu tập nào của bất kỳ Động vật nào', báo hiệu rằng API này có thể trả về các loại khác nhau qua các cuộc gọi.

00:14:16.000 --> 00:14:26.000
Khả năng hạn chế các loại liên quan chính mang lại cho các loại mờ đục và các loại hiện sinh một cấp độ biểu hiện mới.

00:14:26.000 --> 00:14:36.000
Điều này có thể được sử dụng với các giao thức thư viện tiêu chuẩn khác nhau như Bộ sưu tập; bạn cũng có thể khai báo các giao thức của riêng mình có các loại liên quan chính.

00:14:36.000 --> 00:14:43.000
Viết mã chung bằng cách sử dụng các kiểu không rõ ràng phải dựa vào các mối quan hệ kiểu trừu tượng.

00:14:43.000 --> 00:14:54.000
Hãy thảo luận về cách xác định và đảm bảo các mối quan hệ loại cần thiết giữa nhiều loại trừu tượng bằng cách sử dụng các giao thức liên quan.

00:14:54.000 --> 00:15:07.000
Chúng tôi sẽ thêm một loại liên quan mới vào giao thức Động vật cho loại thức ăn chăn nuôi cụ thể mà động vật này ăn, cùng với phương thức eat() yêu cầu động vật tiêu thụ loại thức ăn này.

00:15:07.000 --> 00:15:21.000
Để làm cho mọi thứ thú vị hơn, tôi sẽ giới thiệu một biến chứng bổ sung: trước khi chúng ta có thể cho động vật ăn, chúng ta phải trồng loại cây trồng thích hợp và thu hoạch vụ mùa để sản xuất thức ăn.

00:15:21.000 --> 00:15:24.000
Đây là bộ loại bê tông đầu tiên.

00:15:24.000 --> 00:15:31.000
Một con bò ăn cỏ khô, vì vậy với một con bò, trước tiên chúng ta cần trồng một ít cỏ khô.

00:15:31.000 --> 00:15:40.000
Điều này mang lại cho chúng ta cỏ linh lăng, được thu hoạch và chế biến thành cỏ khô, mà bò có thể ăn.

00:15:40.000 --> 00:15:43.000
Đây là bộ loại bê tông thứ hai.

00:15:43.000 --> 00:15:59.000
Một con gà ăn cào, vì vậy nếu bạn mang cho tôi một con gà, trước tiên chúng ta cần trồng một loại ngũ cốc gọi là kê mà chúng ta thu hoạch và chế biến để tạo ra vết xước gà, thứ mà chúng ta cho gà ăn.

00:15:59.000 --> 00:16:15.000
Tôi muốn tóm tắt hai bộ loại cụ thể liên quan này, vì vậy tôi có thể triển khai phương thức feedAnimal() một lần và cho cả bò và gà ăn, cũng như bất kỳ loại động vật mới nào tôi có thể áp dụng trong tương lai.

00:16:15.000 --> 00:16:33.000
Vì feedAnimal() cần làm việc với phương thức eat() của giao thức Animal, có kiểu liên quan ở vị trí tiêu thụ, tôi sẽ mở hộp hiện sinh bằng cách khai báo rằng phương thức feedAnimal() lấy 'some Animal' làm kiểu tham số.

00:16:33.000 --> 00:16:43.000
Để bắt đầu, tôi sẽ xác định một cặp giao thức, AnimalFeed và Crop, sử dụng những gì chúng ta biết về các giao thức và các loại liên quan cho đến nay.

00:16:43.000 --> 00:16:54.000
AnimalFeed có một CropType liên quan, phù hợp với Crop, và Crop có một FeedType liên quan, phù hợp với AnimalFeed.

00:16:54.000 --> 00:17:00.000
Như trước đây, chúng ta có thể xem xét sơ đồ các tham số loại cho từng giao thức.

00:17:00.000 --> 00:17:03.000
Đầu tiên, hãy nhìn vào AnimalFeed.

00:17:03.000 --> 00:17:09.000
Mỗi giao thức đều có một loại 'Bản thân', viết tắt của loại phù hợp cụ thể.

00:17:09.000 --> 00:17:14.000
Giao thức của chúng tôi có một 'CropType' liên quan, phù hợp với Crop.

00:17:14.000 --> 00:17:27.000
'CropType' liên quan có 'FeedType' liên kết lồng nhau, phù hợp với AnimalFeed, có 'CropType' liên kết lồng nhau phù hợp với Crop, v.v.

00:17:27.000 --> 00:17:39.000
Trên thực tế, việc qua lại này tiếp tục mãi mãi, với sự lồng ghép vô hạn của các loại liên quan xen kẽ giữa việc tuân thủ AnimalFeed và Crop.

00:17:39.000 --> 00:17:45.000
Với giao thức Crop, chúng tôi có một tình huống tương tự, chỉ thay đổi bởi một.

00:17:45.000 --> 00:17:53.000
Chúng tôi bắt đầu với loại 'Bản thân', phù hợp với 'Crop', có 'FeedType' liên quan, phù hợp với AnimalFeed.

00:17:53.000 --> 00:18:02.000
Cái này có một 'CropType' liên quan đến lồng nhau, phù hợp với Crop và vân vân...

00:18:02.000 --> 00:18:04.000
Đến vô tận.

00:18:04.000 --> 00:18:11.000
Hãy xem liệu các giao thức này có mô hình hóa chính xác mối quan hệ giữa các loại cụ thể của chúng ta hay không.

00:18:11.000 --> 00:18:19.000
Nhớ lại rằng trước khi chúng ta có thể cho động vật ăn, chúng ta cần trồng cây trồng sau đó được chế biến thành đúng loại thức ăn chăn nuôi.

00:18:19.000 --> 00:18:32.000
Grow() là một phương thức tĩnh trong giao thức AnimalFeed, có nghĩa là nó phải được gọi trực tiếp trên một kiểu phù hợp với AnimalFeed, chứ không phải trên một giá trị cụ thể có kiểu phù hợp với AnimalFeed.

00:18:32.000 --> 00:18:43.000
Chúng ta cần viết ra tên của một loại phù hợp với AnimalFeed, nhưng tất cả những gì chúng ta có là một giá trị cụ thể, thuộc một số loại phù hợp với Animal, một giao thức khác.

00:18:43.000 --> 00:18:56.000
Chà, chúng ta có thể nhận được loại giá trị này, mà chúng ta biết là một số loại phù hợp với Động vật và Động vật có Loại Thức ăn liên quan, phù hợp với AnimalFeed.

00:18:56.000 --> 00:19:00.000
Loại này có thể được sử dụng làm cơ sở của phương thức gọi grow().

00:19:00.000 --> 00:19:09.000
Phương thức grow() trên AnimalFeed trả về một giá trị có loại là CropType of AnimalFeed được liên kết lồng nhau.

00:19:09.000 --> 00:19:13.000
Chúng tôi biết rằng CropType phù hợp với Crop, vì vậy tôi có thể gọi harvest() trên đó.

00:19:13.000 --> 00:19:15.000
Nhưng tôi phải lấy lại được gì?

00:19:15.000 --> 00:19:21.000
Harvest() được khai báo để trả về FeedType liên quan của giao thức Crop.

00:19:21.000 --> 00:19:37.000
Trong trường hợp của chúng tôi, vì cơ sở của cuộc gọi là (một số Động vật). FeedType.CropType, harvest() sẽ xuất ra một giá trị của loại (một số Động vật). FeedType.CropType.FeedType.

00:19:37.000 --> 00:19:40.000
Thật không may, đây là loại sai.

00:19:40.000 --> 00:19:51.000
Phương thức eat() trên (một số Động vật) mong đợi (một số Động vật). FeedType, và không (một số Động vật). FeedType.CropType.FeedType.

00:19:51.000 --> 00:19:53.000
Chương trình không được đánh máy tốt.

00:19:53.000 --> 00:20:10.000
Các định nghĩa giao thức này, như đã viết, không thực sự đảm bảo rằng nếu chúng ta bắt đầu với một loại thức ăn chăn nuôi, sau đó trồng và thu hoạch vụ này, chúng ta sẽ lấy lại cùng một loại thức ăn chăn nuôi mà chúng ta đã bắt đầu, đó là những gì động vật của chúng ta mong đợi ăn.

00:20:10.000 --> 00:20:21.000
Một cách khác để suy nghĩ về nó là các định nghĩa giao thức này quá chung chung - chúng không mô hình hóa chính xác mối quan hệ mong muốn giữa các loại cụ thể của chúng ta.

00:20:21.000 --> 00:20:26.000
Để hiểu tại sao, hãy xem các loại Hay và Alfalfa của chúng tôi.

00:20:26.000 --> 00:20:33.000
Khi tôi trồng cỏ khô, tôi nhận được cỏ linh lăng, và khi tôi thu hoạch cỏ linh lăng, tôi nhận được cỏ khô, v.v.

00:20:33.000 --> 00:20:43.000
Bây giờ hãy tưởng tượng tôi đang tái cấu trúc mã của mình và tôi vô tình thay đổi kiểu trả về của phương thức harvest() trên Alfalfa để trả về Scratch thay vì Hay.

00:20:43.000 --> 00:21:02.000
Sau sự thay đổi ngẫu nhiên này, các loại bê tông vẫn đáp ứng các yêu cầu của giao thức AnimalFeed và Crop, mặc dù chúng tôi vi phạm bất biến mong muốn của mình rằng việc trồng và thu hoạch một loại cây trồng tạo ra cùng một loại thức ăn chăn nuôi mà chúng tôi đã bắt đầu.

00:21:02.000 --> 00:21:05.000
Hãy xem lại giao thức AnimalFeed một lần nữa.

00:21:05.000 --> 00:21:12.000
Vấn đề thực sự ở đây là theo một nghĩa nào đó, chúng ta có quá nhiều loại liên quan riêng biệt.

00:21:12.000 --> 00:21:19.000
Chúng ta cần viết ra thực tế rằng hai trong số các loại liên quan này thực sự là cùng một loại cụ thể.

00:21:19.000 --> 00:21:30.000
Điều này sẽ ngăn các loại cụ thể được viết không chính xác tuân thủ các giao thức của chúng tôi; nó cũng sẽ cung cấp cho phương thức feedAnimal() sự đảm bảo mà nó cần.

00:21:30.000 --> 00:21:39.000
Chúng ta có thể thể hiện mối quan hệ giữa các loại liên quan này bằng cách sử dụng yêu cầu cùng loại, được viết trong mệnh đề 'ở đâu'.

00:21:39.000 --> 00:21:50.000
Yêu cầu cùng loại thể hiện sự đảm bảo tĩnh rằng hai loại liên quan khác nhau, có thể lồng nhau trên thực tế phải là cùng một loại cụ thể.

00:21:50.000 --> 00:21:58.000
Thêm một yêu cầu cùng loại ở đây áp đặt một hạn chế đối với các loại cụ thể phù hợp với giao thức AnimalFeed.

00:21:58.000 --> 00:22:09.000
Trong yêu cầu cùng loại này ở đây, chúng tôi tuyên bố rằng `Self dot CropType dot FeedType' cùng loại với 'Self'.

00:22:09.000 --> 00:22:12.000
Cái này trông như thế nào trong sơ đồ của chúng ta?

00:22:12.000 --> 00:22:21.000
Chà, đây là cách chúng ta có thể hình dung nó: Mỗi loại bê tông phù hợp với AnimalFeed có một CropType, phù hợp với Crop.

00:22:21.000 --> 00:22:34.000
Tuy nhiên, FeedType của CropType này, không chỉ là một số loại khác phù hợp với AnimalFeed, nó là loại bê tông giống như AnimalFeed ban đầu.

00:22:34.000 --> 00:22:45.000
Thay vì một tòa tháp vô hạn của các loại liên quan lồng nhau, tôi đã thu gọn tất cả các mối quan hệ thành một cặp các loại liên quan duy nhất.

00:22:45.000 --> 00:22:48.000
Còn giao thức 'Cắt' thì sao?

00:22:48.000 --> 00:22:57.000
Ở đây, Crop's FeedType đã giảm xuống còn một cặp loại, nhưng chúng tôi vẫn có quá nhiều loại liên quan.

00:22:57.000 --> 00:23:10.000
Chúng tôi muốn nói rằng Loại cây trồng của FeedType giống với Cây trồng mà chúng tôi bắt đầu ban đầu.

00:23:10.000 --> 00:23:19.000
Bây giờ hai giao thức này đã được trang bị các yêu cầu cùng loại, chúng ta có thể xem lại phương thức 'feedAnimal()' một lần nữa.

00:23:19.000 --> 00:23:22.000
Chúng tôi bắt đầu với loại Động vật nào đó, như trước đây.

00:23:22.000 --> 00:23:29.000
Và chúng tôi nhận được loại thức ăn của động vật, mà chúng tôi biết phù hợp với giao thức AnimalFeed.

00:23:29.000 --> 00:23:35.000
Khi chúng ta trồng loại cây này, chúng ta nhận được loại cây trồng của một số loại thức ăn chăn nuôi.

00:23:35.000 --> 00:23:52.000
Nhưng bây giờ, khi chúng ta thu hoạch vụ mùa này, thay vì nhận được một loại liên quan lồng nhau khác, chúng ta nhận được chính xác loại thức ăn mà động vật của chúng ta mong đợi và động vật hạnh phúc hiện được đảm bảo ăn () đúng loại thức ăn động vật mà chúng ta vừa trồng.

00:23:52.000 --> 00:24:03.000
Cuối cùng, hãy xem xét một sơ đồ loại liên quan cho giao thức Động vật, tập hợp mọi thứ lại với nhau mà chúng ta đã thấy cho đến nay.

00:24:03.000 --> 00:24:10.000
Đây là hai bộ các loại phù hợp: đầu tiên, chúng ta có Cow, Hay và Alfalfa.

00:24:10.000 --> 00:24:13.000
Thứ hai, chúng ta có Chicken, Scratch và Millet.

00:24:13.000 --> 00:24:21.000
Lưu ý cách ba giao thức của chúng tôi mô hình hóa chính xác mối quan hệ giữa mỗi bộ ba loại cụ thể.

00:24:21.000 --> 00:24:31.000
Bằng cách hiểu mô hình dữ liệu của mình, bạn có thể sử dụng các yêu cầu cùng loại để xác định sự tương đương giữa các loại liên quan lồng nhau này.

00:24:31.000 --> 00:24:40.000
Mã chung sau đó có thể dựa vào các mối quan hệ này khi xâu chuỗi nhiều cuộc gọi với nhau đến các yêu cầu giao thức.

00:24:40.000 --> 00:24:49.000
Trong phiên này, chúng tôi đã khám phá khi nào việc xóa loại là an toàn và khi nào chúng tôi cần ở trong bối cảnh mà các mối quan hệ loại được đảm bảo.

00:24:49.000 --> 00:25:05.000
Sau đó, chúng tôi đã thảo luận về cách đạt được sự cân bằng phù hợp giữa việc bảo tồn thông tin loại phong phú và ẩn các chi tiết triển khai bằng cách sử dụng các loại liên quan chính, có thể được sử dụng với cả loại kết quả mờ đục và loại hiện sinh.

00:25:05.000 --> 00:25:18.000
Cuối cùng, chúng tôi đã thấy cách xác định và đảm bảo mối quan hệ loại giữa các bộ loại cụ thể bằng cách sử dụng các yêu cầu cùng loại trên các giao thức đại diện cho các bộ loại liên quan đó.

00:25:18.000 --> 00:25:20.000
Cảm ơn vì đã tham gia cùng tôi.

00:25:20.000 --> 23:59:59.000
Tôi hy vọng bạn có một WWDC tuyệt vời.

