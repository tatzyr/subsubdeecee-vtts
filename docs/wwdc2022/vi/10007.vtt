WEBVTT

00:00:00.000 --> 00:00:03.000
♪ Nhạc hip-hop nhạc cụ êm dịu ♪

00:00:03.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:13.000
Dani Chootong: Xin chào, và chào mừng đến với "Có gì mới với mua hàng trong ứng dụng."

00:00:13.000 --> 00:00:16.000
Tôi là Dani, và tôi là một kỹ sư trong nhóm StoreKit.

00:00:16.000 --> 00:00:23.000
Hôm nay tôi sẽ trình bày với đồng nghiệp Ian của mình và chúng tôi sẽ xem xét những cải tiến mới mà chúng tôi sẽ mang đến để mua hàng trong ứng dụng trong năm nay.

00:00:23.000 --> 00:00:32.000
Năm ngoái, chúng tôi đã giới thiệu StoreKit 2, một bộ API mới được thiết kế từ đầu để giúp việc tích hợp mua hàng trong ứng dụng trở nên đơn giản.

00:00:32.000 --> 00:00:38.000
StoreKit 2 sử dụng các tính năng ngôn ngữ hiện đại, bao gồm Swift đồng thời bằng cách sử dụng mẫu không đồng bộ/chờ đợi.

00:00:38.000 --> 00:00:45.000
Về phía máy chủ, chúng tôi đã bổ sung các tính năng StoreKit mới này với một bộ điểm cuối Máy chủ App Store hoàn toàn mới.

00:00:45.000 --> 00:00:52.000
Các điểm cuối máy chủ này giúp bạn dễ dàng truy xuất thông tin giao dịch và kiểm tra trạng thái đăng ký trên máy chủ của mình.

00:00:52.000 --> 00:01:00.000
Chúng tôi cũng đã phát hành Phiên bản 2 của Thông báo Máy chủ App Store, để giúp việc theo dõi vòng đời đăng ký trên máy chủ của bạn dễ dàng hơn bao giờ hết.

00:01:00.000 --> 00:01:07.000
Hôm nay tôi sẽ xem xét các API mới này, cũng như các cải tiến mà chúng tôi đang đưa vào các mô hình StoreKit mới.

00:01:07.000 --> 00:01:17.000
Sau đó, Ian sẽ hướng dẫn bạn một số cập nhật máy chủ mới thú vị, bao gồm các cải tiến API Máy chủ App Store và API hoàn toàn mới cho Thông báo Máy chủ App Store.

00:01:17.000 --> 00:01:23.000
Đầu tiên, tôi sẽ xem qua API Giao dịch Ứng dụng mới để xác minh việc mua ứng dụng của bạn.

00:01:23.000 --> 00:01:28.000
Tiếp theo, tôi sẽ tìm hiểu một số thuộc tính mới mà chúng tôi đã thêm vào các mô hình StoreKit của mình.

00:01:28.000 --> 00:01:37.000
Tôi sẽ giới thiệu cho bạn các API thân thiện với SwiftUI mới để đổi mã ưu đãi đăng ký và yêu cầu khách hàng xem lại ứng dụng của bạn.

00:01:37.000 --> 00:01:44.000
Sau đó, tôi sẽ giới thiệu cho bạn về StoreKit Messages, một API được sử dụng để hiển thị tin nhắn App Store cho khách hàng của bạn.

00:01:44.000 --> 00:01:52.000
Và cuối cùng, tôi sẽ xem xét một cải tiến mà chúng tôi đang thêm vào để bảo toàn Tên người dùng ứng dụng khi bạn di chuyển từ bản gốc sang API StoreKit hiện đại.

00:01:52.000 --> 00:01:57.000
Trong suốt bài thuyết trình này, tôi sẽ sử dụng ứng dụng yêu thích của mình, Food Truck.

00:01:57.000 --> 00:02:02.000
Trong ứng dụng Food Truck, tôi quản lý một chiếc xe tải thực phẩm bánh rán bật lên đến thăm nhiều thành phố khác nhau để giao bánh rán.

00:02:02.000 --> 00:02:05.000
Vì vậy, hãy bắt đầu nào!

00:02:05.000 --> 00:02:06.000
Gặp gỡ Giao dịch Ứng dụng.

00:02:06.000 --> 00:02:12.000
Giao dịch ứng dụng là API mới của chúng tôi để xác minh việc mua ứng dụng của bạn.

00:02:12.000 --> 00:02:18.000
Giao dịch ứng dụng đại diện cho thông tin đã ký để mua ứng dụng của bạn cho thiết bị mà nó đang chạy.

00:02:18.000 --> 00:02:27.000
Nó được ký bằng JWS và nó thay thế phần chi tiết ứng dụng của biên lai ứng dụng từ StoreKit API ban đầu.

00:02:27.000 --> 00:02:34.000
Cũng giống như xác minh giao dịch, StoreKit thực hiện xác minh tự động giao dịch ứng dụng cho bạn.

00:02:34.000 --> 00:02:39.000
Tuy nhiên, nếu bạn muốn, bạn cũng có thể thực hiện xác nhận của riêng mình.

00:02:39.000 --> 00:02:43.000
Xác thực chữ ký JWS là một tiêu chuẩn được ghi chép đầy đủ.

00:02:43.000 --> 00:02:48.000
Bạn có thể tham khảo tài liệu công khai để thực hiện xác thực của riêng bạn.

00:02:48.000 --> 00:02:52.000
StoreKit đảm nhận việc tự động cập nhật Giao dịch Ứng dụng khi cần thiết.

00:02:52.000 --> 00:02:57.000
Tuy nhiên, trong trường hợp hiếm hoi mà người dùng nghĩ rằng có điều gì đó không ổn, nó có thể được làm mới.

00:02:57.000 --> 00:03:03.000
Bạn nên cung cấp giao diện người dùng trong ứng dụng của mình để cho phép khách hàng của bạn làm mới giao dịch ứng dụng.

00:03:03.000 --> 00:03:11.000
Điều này chỉ nên được sử dụng để đáp ứng với hành động của người dùng, vì việc làm mới Giao dịch Ứng dụng sẽ nhắc người dùng xác thực.

00:03:11.000 --> 00:03:15.000
Ngăn chặn gian lận không phải là lý do duy nhất để yêu thích Giao dịch Ứng dụng.

00:03:15.000 --> 00:03:31.000
Nếu bạn đang tìm cách chuyển đổi mô hình kinh doanh từ ứng dụng trả phí sang ứng dụng miễn phí cung cấp dịch mua hàng trong ứng dụng, nếu bạn tò mò về khách hàng nào đã đặt hàng trước ứng dụng của mình hoặc thậm chí nếu bạn chỉ muốn biết khi nào ứng dụng của mình được mua, đây là tất cả các tình huống bạn có thể xử lý với Giao dịch ứng dụng

00:03:31.000 --> 00:03:39.000
Trong biên lai ứng dụng, tải trọng biên lai kết hợp dữ liệu mua hàng về ứng dụng của bạn cùng với tất cả các giao dịch mua trong ứng dụng đã xảy ra.

00:03:39.000 --> 00:03:43.000
Chúng hiện được chia thành hai thành phần riêng biệt trong StoreKit.

00:03:43.000 --> 00:03:46.000
Đầu tiên trong số này là Lịch sử Giao dịch.

00:03:46.000 --> 00:03:52.000
API giao dịch của StoreKit cung cấp cho bạn cái nhìn sâu sắc về toàn bộ lịch sử mua hàng trong ứng dụng của người dùng, ngay trên thiết bị.

00:03:52.000 --> 00:04:02.000
Các API này cho phép bạn tìm thông tin chính xác mà bạn cần, bao gồm các giao dịch mới nhất của người dùng, các giao dịch chưa hoàn thành và các quyền hiện tại.

00:04:02.000 --> 00:04:09.000
Nếu bạn muốn thực hiện các phép tính này trên máy chủ của mình, bạn cũng có thể lấy lịch sử mua hàng của người dùng từ API Máy chủ App Store.

00:04:09.000 --> 00:04:13.000
Ian sẽ có một số cập nhật thú vị về điều này vào cuối phiên này.

00:04:13.000 --> 00:04:20.000
Và thành phần thứ hai là Giao dịch ứng dụng, chứa dữ liệu bạn cần để đảm bảo rằng ứng dụng của bạn hợp lệ với thiết bị mà nó đang chạy.

00:04:20.000 --> 00:04:28.000
Thật dễ dàng để xác minh việc mua ứng dụng của bạn bằng Giao dịch ứng dụng và chỉ trong giây lát, tôi sẽ xem xét một ví dụ về cách bạn có thể sử dụng nó.

00:04:28.000 --> 00:04:32.000
Nhưng trước tiên, hãy để tôi cung cấp cho bạn một số thông tin cơ bản về ứng dụng yêu thích của tôi.

00:04:32.000 --> 00:04:39.000
Với Food Truck, tôi có thể giao bánh rán, kiểm tra nguồn cấp dữ liệu xã hội cơ bản và hình dung lịch sử bán hàng của mình.

00:04:39.000 --> 00:04:49.000
Giữ tất cả thông tin này trong cơ sở dữ liệu là chi phí liên tục cho ứng dụng của tôi, vì vậy để giúp tôi trang trải chi phí, tôi sẽ biến biểu đồ lịch sử bán hàng hàng năm thành mua hàng một lần.

00:04:49.000 --> 00:04:52.000
Ngoài ra, tôi muốn tăng cường nguồn cấp dữ liệu xã hội.

00:04:52.000 --> 00:04:59.000
Vì vậy, thay vì chỉ nhìn thấy những gì người khác đang nói về xe bán đồ ăn của tôi, tôi muốn cung cấp các công cụ để tôi cũng có thể tương tác với khách hàng của mình.

00:04:59.000 --> 00:05:04.000
Đây sẽ là một dịch vụ đăng ký, và tôi sẽ có một gói hàng tháng và một gói hàng năm.

00:05:04.000 --> 00:05:10.000
Food Truck bắt đầu như một ứng dụng trả phí, nhưng tôi sẽ chuyển sang một ứng dụng miễn phí cung cấp dịch vụ mua hàng trong ứng dụng.

00:05:10.000 --> 00:05:15.000
Nhưng tôi không muốn những khách hàng hiện tại của tôi đã mua Food Truck cảm thấy bị bỏ rơi.

00:05:15.000 --> 00:05:24.000
Vì vậy, tôi sẽ sử dụng Giao dịch ứng dụng để đảm bảo rằng những khách hàng đã mua Food Truck tiếp tục có quyền truy cập vào nội dung cao cấp mà họ đã trả tiền.

00:05:24.000 --> 00:05:26.000
Đây là dòng thời gian cho Xe tải thực phẩm.

00:05:26.000 --> 00:05:31.000
Tại lần phát hành đầu tiên, Food Truck bắt đầu như một ứng dụng trả phí có giá 4,99 đô la.

00:05:31.000 --> 00:05:37.000
Phiên bản 1.0 cung cấp dịch vụ giao bánh rán, nguồn cấp dữ liệu xã hội cơ bản và biểu đồ lịch sử bán hàng.

00:05:37.000 --> 00:05:42.000
Sau đó, khi phát hành phiên bản 8.0, mô hình kinh doanh của tôi đã thay đổi.

00:05:42.000 --> 00:05:47.000
Food Truck hiện miễn phí, nhưng bao gồm nhiều giao dịch mua trong ứng dụng mở khóa các tính năng cao cấp.

00:05:47.000 --> 00:05:58.000
Biểu đồ lịch sử bán hàng hàng năm hiện là giao dịch mua một lần không thể tiêu thụ và bây giờ có dịch vụ đăng ký mới cho nguồn cấp dữ liệu xã hội cao cấp cung cấp cho bạn các công cụ tương tác nâng cao.

00:05:58.000 --> 00:06:03.000
Bây giờ chúng ta hãy xem xét hai loại khách hàng khác nhau có thể bị ảnh hưởng bởi điều này.

00:06:03.000 --> 00:06:11.000
Alice đã tìm hiểu về ứng dụng Food Truck của tôi trong phiên bản 2.5, và cô ấy quyết định muốn chia sẻ niềm đam mê của mình đối với bánh rán trong thế giới kỹ thuật số.

00:06:11.000 --> 00:06:16.000
Vì vậy, cô ấy đã mua ứng dụng của tôi với giá 4,99 đô la và bắt đầu hành trình giao bánh rán của mình.

00:06:16.000 --> 00:06:23.000
Khách hàng thứ hai, Bob, tìm hiểu về ứng dụng Food Truck của tôi mặc dù là một người bạn và tải xuống miễn phí trong App Store ở phiên bản 8.2.

00:06:23.000 --> 00:06:33.000
Trong trường hợp này, Alice, người đã mua ứng dụng của tôi trước khi nó trở nên miễn phí, vẫn có quyền truy cập vào tất cả nội dung cao cấp mà cô ấy đã trả tiền.

00:06:33.000 --> 00:06:42.000
Cô ấy vẫn có tùy chọn mua đăng ký nguồn cấp dữ liệu xã hội cao cấp, nhưng tôi không muốn phủ nhận cô ấy biểu đồ lịch sử bán hàng hàng năm ban đầu được bao gồm.

00:06:42.000 --> 00:06:44.000
Bob, tuy nhiên, đã nhận được ứng dụng của tôi miễn phí.

00:06:44.000 --> 00:06:49.000
Sau đó tôi biết không mở khóa các tính năng và nội dung cho đến khi họ hoàn tất việc mua hàng trong ứng dụng.

00:06:49.000 --> 00:06:53.000
Vì vậy, hãy xem làm thế nào chúng ta có thể đạt được điều này với Giao dịch ứng dụng trong mã.

00:06:53.000 --> 00:06:59.000
Tôi sẽ bắt đầu bằng cách tìm nạp giao dịch ứng dụng bằng cách gọi AppTransaction.shared.

00:06:59.000 --> 00:07:03.000
Cuộc gọi này giúp tôi có được Kết quả Xác minh có chứa giao dịch ứng dụng của tôi.

00:07:03.000 --> 00:07:09.000
Trong kết quả, loại AppTransaction chứa tải trọng JWS.

00:07:09.000 --> 00:07:11.000
Tiếp theo, tôi sẽ bật kết quả lên.

00:07:11.000 --> 00:07:22.000
Nếu kết quả chưa được xác minh, đây sẽ là thời điểm tốt để cảnh báo người dùng rằng việc mua ứng dụng của họ không thể được xác minh bởi App Store, và sau đó, tôi có thể nhắc họ làm mới giao dịch ứng dụng.

00:07:22.000 --> 00:07:26.000
Tại thời điểm này, tôi sẽ cung cấp trải nghiệm tối thiểu cho ứng dụng của mình.

00:07:26.000 --> 00:07:31.000
Nếu kết quả được xác minh, tôi sẽ sử dụng điều này như một cơ hội để kiểm tra xem người dùng đã mua ứng dụng của tôi chưa.

00:07:31.000 --> 00:07:36.000
Khách hàng đã mua ứng dụng của tôi nên được cấp các dịch vụ mà họ đã thanh toán.

00:07:36.000 --> 00:07:39.000
Đối với điều này, tôi sẽ sử dụng thuộc tính phiên bản ứng dụng gốc.

00:07:39.000 --> 00:07:46.000
Thuộc tính này cho tôi biết phiên bản ứng dụng mà khách hàng đã tải xuống ứng dụng của tôi lần đầu tiên.

00:07:46.000 --> 00:07:51.000
Phiên bản 8.0 là phiên bản mà ứng dụng của tôi trở nên miễn phí khi mua hàng trong ứng dụng.

00:07:51.000 --> 00:07:58.000
Tôi sẽ chuyển phiên bản ứng dụng gốc của khách hàng sang chức năng của mình để kiểm tra xem người dùng có mua ứng dụng của tôi trước phiên bản 8.0 hay không.

00:07:58.000 --> 00:08:05.000
Và với điều đó, tôi có thể đưa ra quyết định sáng suốt về cách tôi nên cung cấp nội dung cao cấp cho người dùng của mình.

00:08:05.000 --> 00:08:13.000
Đối với những khách hàng như Alice, người đã mua ứng dụng của tôi, tôi sẽ cung cấp nội dung mà người dùng được hưởng mà họ có tại thời điểm mua.

00:08:13.000 --> 00:08:18.000
Trong trường hợp của tôi, tôi sẽ mở khóa biểu đồ lịch sử bán hàng hàng năm cho việc giao hàng của cô ấy.

00:08:18.000 --> 00:08:25.000
Ngoài ra, tôi muốn kiểm tra bất kỳ giao dịch mua bổ sung nào trong ứng dụng mà họ có thể đã thực hiện để tôi cũng có thể cung cấp điều đó.

00:08:25.000 --> 00:08:31.000
Nếu không, tôi có thể tự tin rằng người dùng đã tải xuống ứng dụng của tôi sau khi tôi chuyển đổi mô hình kinh doanh của mình, như Bob.

00:08:31.000 --> 00:08:37.000
Đây có thể là thời điểm tốt để kiểm tra các quyền hiện tại của người dùng để tôi có thể mở khóa các tính năng và nội dung mà họ đã trả tiền.

00:08:37.000 --> 00:08:52.000
Và chỉ với một vài dòng mã, tôi đã có thể xác minh việc mua ứng dụng của mình, kiểm tra xem người dùng có tải xuống phiên bản trả phí của ứng dụng của tôi hay không và tôi có thể ngay lập tức bắt đầu cung cấp nội dung cao cấp của mình, cho dù khách hàng có mua ứng dụng của tôi hay không.

00:08:52.000 --> 00:08:59.000
Với Giao dịch ứng dụng, bạn có thể dễ dàng hỗ trợ khách hàng của mình cho dù họ là những người ủng hộ sớm hay nếu họ vừa tải xuống ứng dụng của bạn gần đây.

00:08:59.000 --> 00:09:04.000
Bây giờ tôi muốn chuyển sang các thuộc tính mới mà chúng tôi đang thêm vào các mô hình StoreKit của mình.

00:09:04.000 --> 00:09:07.000
Tài sản đầu tiên trong số này là địa phương giá cả.

00:09:07.000 --> 00:09:10.000
Giá địa phương hiện đã được bao gồm trong các sản phẩm StoreKit.

00:09:10.000 --> 00:09:16.000
Bạn có thể đã quen thuộc với ngôn ngữ giá từ giao tiếp với API mua hàng ban đầu của chúng tôi.

00:09:16.000 --> 00:09:19.000
Tiếp theo, tôi sẽ đào sâu vào tài sản môi trường máy chủ.

00:09:19.000 --> 00:09:25.000
Bây giờ, bạn có thể cho môi trường máy chủ biết thông tin giao dịch hoặc gia hạn đã xảy ra.

00:09:25.000 --> 00:09:28.000
Sau đó, tôi sẽ chuyển sang tài sản ngày bắt đầu đăng ký gần đây.

00:09:28.000 --> 00:09:35.000
Bạn có thể sử dụng điều này như một công cụ để đưa ra quyết định sáng suốt cho khách hàng của mình dựa trên mô hình đăng ký của họ.

00:09:35.000 --> 00:09:41.000
Và cuối cùng, tôi sẽ xem xét một số cân nhắc đặc biệt cho các thuộc tính này khi bạn sử dụng chúng với Kiểm tra StoreKit trong Xcode.

00:09:41.000 --> 00:09:48.000
Các thuộc tính này trả về các giá trị trọng điểm trong các hệ điều hành cũ hơn và tôi sẽ giải thích điều này có nghĩa là gì chỉ trong một chút.

00:09:48.000 --> 00:10:01.000
Các API StoreKit được thiết kế linh hoạt, vì vậy tôi tự hào thông báo rằng bạn có thể tận dụng các thuộc tính mới này trên các thiết bị từ các hệ điều hành năm ngoái, mặc dù ban đầu chúng không đi kèm với chúng.

00:10:01.000 --> 00:10:10.000
Tất cả những gì bạn cần để thực hiện điều này là sử dụng Xcode 14 để xây dựng ứng dụng của mình và bạn sẽ có quyền truy cập vào các thuộc tính này trong các hệ điều hành trước đó.

00:10:10.000 --> 00:10:21.000
Điều này có thể thực hiện được vì việc triển khai các thuộc tính này được tổng hợp vào ứng dụng của bạn, vì vậy khi khách hàng của bạn cập nhật lên phiên bản mới, họ sẽ có thể nhận được lợi ích của những cải tiến này mà không cần cập nhật hệ điều hành của họ.

00:10:21.000 --> 00:10:26.000
Tuy nhiên, có một điều cần lưu ý khi sử dụng các thuộc tính này.

00:10:26.000 --> 00:10:32.000
Các thuộc tính này sẽ trả về các giá trị trọng điểm khi bạn đang sử dụng thử nghiệm StoreKit trong Xcode trong các hệ điều hành cũ hơn này.

00:10:32.000 --> 00:10:41.000
Khi tôi nói các giá trị trọng điểm, tôi đang đề cập đến các giá trị giữ chỗ báo hiệu rằng đây không phải là các giá trị thực mà bạn nên làm việc và tôi sẽ giải thích lý do tại sao điều này xảy ra.

00:10:41.000 --> 00:10:48.000
Hộp cát và môi trường sản xuất sử dụng các thuộc tính này bằng cách trích xuất các giá trị từ phản hồi của máy chủ App Store.

00:10:48.000 --> 00:10:54.000
Tuy nhiên, thử nghiệm StoreKit trong Xcode là một môi trường thử nghiệm cục bộ hoạt động độc lập với máy chủ App Store.

00:10:54.000 --> 00:11:00.000
Điều này có nghĩa là chúng tôi không thể chuyển ngược giá trị của các thuộc tính này sang các hệ điều hành trước đó ở đó.

00:11:00.000 --> 00:11:08.000
Bạn có thể dễ dàng vượt qua giới hạn này bằng cách cập nhật thiết bị thử nghiệm của mình lên hệ điều hành mới và bạn sẽ sẵn sàng kiểm tra các giá trị này trong môi trường cục bộ.

00:11:08.000 --> 00:11:15.000
Hãy thảo luận về một số tình huống chứng minh cách bạn có thể bắt đầu sử dụng các thuộc tính mới này, đầu tiên trong số đó là địa phương giá cả.

00:11:15.000 --> 00:11:25.000
Các sản phẩm StoreKit đã có thuộc tính giá hiển thị để gắn nhãn giá mua, nhưng với ngôn ngữ giá, bạn có thể định dạng các số xuất phát từ giá thập phân của sản phẩm.

00:11:25.000 --> 00:11:32.000
Nếu bạn có đăng ký hàng năm, bạn có thể sử dụng điều này như một cơ hội để cho khách hàng của mình thấy họ sẽ phải trả bao nhiêu mỗi tháng.

00:11:32.000 --> 00:11:38.000
Trong ví dụ này, bạn có thể thấy rằng đăng ký hàng năm lên tới 4,17 đô la mỗi tháng.

00:11:38.000 --> 00:11:44.000
Hoặc có lẽ bạn muốn cho họ thấy họ sẽ tiết kiệm được bao nhiêu nếu họ mua dịch vụ hàng năm của bạn thay vì dịch vụ hàng tháng của bạn.

00:11:44.000 --> 00:11:51.000
Với thông tin này, khách hàng của bạn có thể đưa ra quyết định sáng suốt khi họ đang xem xét các lựa chọn mua hàng của bạn.

00:11:51.000 --> 00:11:54.000
Bây giờ, hãy chuyển sang tài sản môi trường.

00:11:54.000 --> 00:11:57.000
Tài sản môi trường có sẵn trong Thông tin Giao dịch và gia hạn.

00:11:57.000 --> 00:12:06.000
Thuộc tính này cho bạn biết môi trường máy chủ nơi thông tin giao dịch hoặc gia hạn bắt nguồn, có thể là Xcode, hộp cát hoặc sản xuất.

00:12:06.000 --> 00:12:13.000
Ứng dụng của bạn có thể truyền đạt thông tin giao dịch đến máy chủ của bạn sau khi khách hàng mua hàng để ghi sổ và phân tích.

00:12:13.000 --> 00:12:18.000
Khi ứng dụng của bạn tạo ra các giao dịch này, nó có thể đến từ bất kỳ một trong những môi trường máy chủ này.

00:12:18.000 --> 00:12:22.000
Giống như hầu hết các bạn, tôi không muốn thêm nhiễu vào phân tích của mình với dữ liệu kiểm tra không liên quan.

00:12:22.000 --> 00:12:29.000
Vì vậy, biết môi trường có thể giúp bạn lọc ra những thông tin không cần thiết được gửi đến máy chủ của bạn.

00:12:29.000 --> 00:12:32.000
Cuối cùng, chúng ta hãy xem ngày bắt đầu đăng ký gần đây.

00:12:32.000 --> 00:12:41.000
Ngày bắt đầu đăng ký gần đây có sẵn trong thông tin đăng ký của sản phẩm và nó đại diện cho giai đoạn đăng ký liên tục gần đây nhất.

00:12:41.000 --> 00:12:48.000
Đăng ký được coi là liên tục nếu không có khoảng cách quá 60 ngày giữa hai giai đoạn đăng ký bất kỳ.

00:12:48.000 --> 00:12:59.000
Hãy nhớ rằng khoảng thời gian này có thể chứa những khoảng trống mà khách hàng không đăng ký sản phẩm của bạn, vì vậy đừng sử dụng điều này làm chỉ báo cho số ngày khách hàng đã đăng ký.

00:12:59.000 --> 00:13:05.000
Ngày bắt đầu đăng ký gần đây có thể giúp bạn xác định mô hình trung thành giữa bạn và khách hàng của bạn.

00:13:05.000 --> 00:13:10.000
Đối với những khách hàng trung thành của bạn, bạn có thể trao cho họ phần thưởng như một cách để giữ cho họ tương tác với sản phẩm của bạn.

00:13:10.000 --> 00:13:21.000
Hoặc nếu bạn nhận thấy rằng một khách hàng đã hủy đăng ký dịch vụ của bạn, bạn có thể sử dụng nó như một cơ hội để giành lại một khách hàng đã hết hạn bằng cách khuyến khích họ bắt đầu sử dụng lại sản phẩm của bạn.

00:13:21.000 --> 00:13:26.000
Tôi đã đề cập trước đó rằng chúng ta sẽ xem xét kỹ hơn các giá trị trọng điểm cho các thuộc tính này.

00:13:26.000 --> 00:13:34.000
Xin nhắc lại, khi tôi nói các giá trị trọng điểm, tôi đang đề cập đến các giá trị giữ chỗ đóng vai trò là chỉ báo về sự vắng mặt của giá trị thực.

00:13:34.000 --> 00:13:38.000
Các giá trị trọng điểm cho các thuộc tính này rất dễ xác định.

00:13:38.000 --> 00:13:45.000
Khi bạn đang xử lý ngôn ngữ giá, giá trị trọng điểm là một ngôn ngữ với mã định danh xx_XX.

00:13:45.000 --> 00:13:49.000
Đối với thuộc tính môi trường, nó sẽ là một chuỗi trống.

00:13:49.000 --> 00:13:54.000
Và cuối cùng, đối với ngày bắt đầu đăng ký gần đây, giá trị này là Date.distantPast.

00:13:54.000 --> 00:14:05.000
May mắn thay, sự xuất hiện của các giá trị trọng điểm này có thể dự đoán được - bạn sẽ chỉ gặp chúng nếu bạn đang sử dụng thử nghiệm StoreKit trong Xcode trong các hệ điều hành cũ hơn và bạn có thể giải quyết vấn đề này bằng cách cập nhật thiết bị thử nghiệm của mình.

00:14:05.000 --> 00:14:09.000
Vì vậy, bây giờ bạn đã thấy những cải tiến mà chúng tôi đã thực hiện cho các mô hình StoreKit của mình.

00:14:09.000 --> 00:14:19.000
Và phần yêu thích của tôi là, chúng tương thích ngược với hệ điều hành nơi các mô hình được giới thiệu, vì vậy khách hàng của bạn có thể thấy các lợi ích ngay lập tức chỉ bằng cách cập nhật ứng dụng của bạn.

00:14:19.000 --> 00:14:26.000
Khi bạn thực hiện số học với các giá trị giá, ngôn ngữ giá sẽ giúp bạn định dạng chính xác để nó khớp với ngôn ngữ của App Store.

00:14:26.000 --> 00:14:37.000
Đối với các giao dịch và thông tin đăng ký, môi trường cho bạn biết chính xác nguồn gốc của chúng, vì vậy nếu bạn lưu trữ dữ liệu này trên máy chủ của mình, bạn có thể hành động tương ứng tùy thuộc vào môi trường.

00:14:37.000 --> 00:14:49.000
Ngày bắt đầu đăng ký gần đây giúp bạn hiểu được lòng trung thành của khách hàng, vì vậy bạn có thể điều chỉnh các ưu đãi cụ thể cho khách hàng lâu năm hoặc có thể bạn có thể cung cấp ưu đãi cho những khách hàng đã hủy đăng ký.

00:14:49.000 --> 00:15:01.000
Và trong trường hợp bạn đang thắc mắc, vâng, môi trường và ngày bắt đầu đăng ký gần đây cũng có sẵn thông qua API Máy chủ App Store và Thông báo Máy chủ Cửa hàng Ứng dụng, mà Ian sẽ thảo luận.

00:15:01.000 --> 00:15:08.000
Bây giờ tôi muốn nói về các API SwiftUI mới mà chúng tôi đang cung cấp để đổi mã ưu đãi và yêu cầu đánh giá.

00:15:08.000 --> 00:15:16.000
Mã ưu đãi có thể giúp bạn có được, giữ chân và giành lại người đăng ký bằng cách cung cấp đăng ký giảm giá hoặc miễn phí trong thời gian giới hạn.

00:15:16.000 --> 00:15:20.000
Bây giờ trong App Store Connect, bạn có thể tạo các mã tùy chỉnh được đặt tên duy nhất.

00:15:20.000 --> 00:15:26.000
Ở đó, bạn có thể đặt giới hạn đổi quà tối đa và bạn có thể chọn có đặt thời hạn sử dụng hay không.

00:15:26.000 --> 00:15:32.000
Hãy xem xét việc triển khai SwiftUI để trình bày bảng đổi mã ưu đãi trực tiếp từ ứng dụng của bạn.

00:15:32.000 --> 00:15:36.000
Ở đây, tôi có chế độ xem SwiftUI với một nút để kích hoạt bảng đổi mã ưu đãi.

00:15:36.000 --> 00:15:42.000
Bảng đổi mã ưu đãi hiện có công cụ sửa đổi chế độ xem riêng trong SwiftUI.

00:15:42.000 --> 00:15:47.000
Công cụ sửa đổi chế độ xem rất dễ sử dụng, nó chỉ cần một Boolean ràng buộc để bắt đầu quá trình.

00:15:47.000 --> 00:15:54.000
Và một khi bảng mã đề nghị bị loại bỏ, bạn sẽ nhận được kết quả đại diện cho việc bảng có được trình bày thành công hay không.

00:15:54.000 --> 00:16:02.000
Khi khách hàng đổi mã ưu đãi cho ứng dụng của bạn, giao dịch kết quả sẽ được gửi đến người nghe giao dịch.

00:16:02.000 --> 00:16:09.000
Vì vậy, hãy đảm bảo thiết lập trình nghe giao dịch ngay khi ứng dụng của bạn khởi chạy để nhận các giao dịch mới và cập nhật trong khi ứng dụng của bạn đang chạy.

00:16:09.000 --> 00:16:14.000
Công cụ sửa đổi chế độ xem mã ưu đãi có sẵn bắt đầu từ iOS 16.

00:16:14.000 --> 00:16:18.000
Tiếp theo, tôi muốn nói về các bản cập nhật để yêu cầu xem xét.

00:16:18.000 --> 00:16:21.000
Nhận phản hồi của khách hàng là điều quan trọng.

00:16:21.000 --> 00:16:27.000
Khách hàng tiềm năng mới có thể sử dụng các đánh giá như một yếu tố quyết định trong quyết định tải xuống ứng dụng của bạn.

00:16:27.000 --> 00:16:32.000
Những người khác có thể muốn để lại đánh giá như một cách để cung cấp phản hồi hoặc đề xuất.

00:16:32.000 --> 00:16:41.000
Dù bằng cách nào, chúng tôi muốn cung cấp cho bạn các công cụ để giúp bạn dễ dàng yêu cầu xếp hạng từ khách hàng của mình, vì vậy bạn có thể cho họ biết bạn đang lắng nghe và bạn có thể tiếp tục tương tác với họ.

00:16:41.000 --> 00:16:44.000
Hãy xem lại mã.

00:16:44.000 --> 00:16:48.000
Ở đây tôi có một cái nhìn rất đơn giản để chứng minh các API Đánh giá Yêu cầu.

00:16:48.000 --> 00:16:52.000
Trong SwiftUI, bây giờ có một giá trị môi trường được gọi là requestReview.

00:16:52.000 --> 00:17:03.000
Bạn có thể sử dụng giá trị này để lấy một phiên bản của RequestReviewAction và khi bạn đã sẵn sàng yêu cầu xếp hạng, chỉ cần gọi phiên bản đó làm hàm để yêu cầu hiển thị lời nhắc đánh giá.

00:17:03.000 --> 00:17:06.000
Bạn có thể quyết định thời điểm thích hợp để yêu cầu đánh giá cho ứng dụng của mình.

00:17:06.000 --> 00:17:14.000
Tuy nhiên, bạn nên lưu ý rằng lời nhắc sẽ chỉ được hiển thị cho khách hàng tối đa ba lần trong khoảng thời gian 365 ngày.

00:17:14.000 --> 00:17:19.000
Và bạn không nên yêu cầu khách hàng xem lại cùng một phiên bản ứng dụng của bạn nhiều lần.

00:17:19.000 --> 00:17:22.000
Tránh làm gián đoạn khách hàng bằng lời nhắc đánh giá.

00:17:22.000 --> 00:17:31.000
Thời điểm tốt để yêu cầu đánh giá có thể là sau khi họ đã có sự tương tác tích cực, chẳng hạn như hoàn thành giao dịch mua trên ứng dụng thương mại điện tử hoặc hoàn thành cấp độ trong trò chơi.

00:17:31.000 --> 00:17:39.000
Cuối cùng, khách hàng có thể vô hiệu hóa các yêu cầu xuất hiện trên thiết bị của họ, vì vậy bạn không nên yêu cầu đánh giá do hành động của người dùng.

00:17:39.000 --> 00:17:43.000
Những API này thực sự sẽ có ích cho các ứng dụng SwiftUI của bạn.

00:17:43.000 --> 00:17:48.000
Tiếp theo, tôi muốn giới thiệu với bạn API mới của chúng tôi cho các tin nhắn StoreKit.

00:17:48.000 --> 00:17:54.000
Thông báo StoreKit đại diện cho một trang tính xuất hiện trên ứng dụng của bạn để hiển thị thông tin quan trọng cho người dùng.

00:17:54.000 --> 00:17:57.000
Tin nhắn được bán bởi App Store.

00:17:57.000 --> 00:18:01.000
Mỗi tin nhắn có một lý do, được bao gồm trong siêu dữ liệu tin nhắn.

00:18:01.000 --> 00:18:05.000
Tin nhắn StoreKit được truy xuất khi ứng dụng của bạn ở phía trước.

00:18:05.000 --> 00:18:10.000
Ví dụ, chúng ta hãy xem xét một trong những lý do thông điệp - sự đồng ý tăng giá.

00:18:10.000 --> 00:18:21.000
Khi bạn tăng giá đăng ký và nó yêu cầu sự đồng ý của người dùng, App Store sẽ thông báo cho những người đăng ký bị ảnh hưởng thông qua email, thông báo đẩy và bảng chấp thuận giá trong ứng dụng.

00:18:21.000 --> 00:18:28.000
Trong trường hợp này, App Store yêu cầu người dùng đồng ý với giá đăng ký mới của bạn trước khi gia hạn ở mức giá cao hơn.

00:18:28.000 --> 00:18:38.000
Vì vậy, nếu bạn quyết định tính phí nhiều hơn cho đăng ký của mình, bảng chấp thuận tăng giá có thể xuất hiện khi người dùng mở ứng dụng của bạn nếu họ chưa phản hồi việc tăng giá của bạn.

00:18:38.000 --> 00:18:46.000
Theo mặc định, thông báo StoreKit xuất hiện trên ứng dụng của bạn khi người dùng đưa ứng dụng của bạn lên nền trước và nó có thể yêu cầu người dùng thực hiện một số hành động liên quan đến ứng dụng của bạn.

00:18:46.000 --> 00:18:48.000
Hãy xem lại cái này.

00:18:48.000 --> 00:18:51.000
Toàn bộ quá trình bắt đầu với ứng dụng của bạn.

00:18:51.000 --> 00:18:56.000
Khi ứng dụng của bạn vào tiền cảnh, StoreKit biết kiểm tra xem có tin nhắn đang chờ xử lý để hiển thị hay không.

00:18:56.000 --> 00:19:00.000
Và nếu có, StoreKit kiểm tra với App Store.

00:19:00.000 --> 00:19:03.000
App Store trả lại thông tin về tin nhắn cho StoreKit.

00:19:03.000 --> 00:19:07.000
Tại thời điểm này, StoreKit kiểm tra xem ứng dụng của bạn có được thiết lập để nhận tin nhắn hay không.

00:19:07.000 --> 00:19:12.000
Bạn có thể làm điều này bằng cách thiết lập trình nghe tin nhắn trong ứng dụng của bạn, tôi sẽ sớm tham gia.

00:19:12.000 --> 00:19:17.000
Nếu ứng dụng của bạn đã thiết lập trình nghe tin nhắn, StoreKit sẽ gửi thông tin về tin nhắn đến ứng dụng của bạn.

00:19:17.000 --> 00:19:25.000
Bây giờ là cơ hội của bạn để quyết định xem đây có phải là thời điểm tốt để ứng dụng của bạn hiển thị tin nhắn hay không, hoặc nếu bạn muốn trì hoãn bài thuyết trình cho sau này.

00:19:25.000 --> 00:19:32.000
Nếu bạn không thiết lập trình nghe tin nhắn, StoreKit sẽ hiển thị tin nhắn ngay lập tức bằng cách trình bày bảng tin nhắn qua ứng dụng của bạn.

00:19:32.000 --> 00:19:34.000
Tôi sẽ xem xét cách làm điều này trong mã.

00:19:34.000 --> 00:19:41.000
Nhưng trước khi tôi làm điều đó, tôi sẽ giải thích một tình huống trong đó sẽ rất hữu ích khi kiểm soát việc trình bày tin nhắn App Store.

00:19:41.000 --> 00:19:45.000
Trong ứng dụng Food Truck, tôi có thể tùy chỉnh bánh rán mà tôi đang giao đến các thành phố khác nhau.

00:19:45.000 --> 00:19:59.000
Nếu một tin nhắn được gửi đến ứng dụng của tôi trong thời gian này, sẽ gây nhầm lẫn cho người dùng nếu họ đột nhiên bị gián đoạn bởi một bảng tin nhắn, vì vậy tôi sẽ triển khai API tin nhắn để đảm bảo điều này không xảy ra bằng cách kiểm soát khi nào tin nhắn đến được hiển bày.

00:19:59.000 --> 00:20:01.000
Bây giờ chúng ta hãy đi vào mã.

00:20:01.000 --> 00:20:04.000
Ở đây, tôi có một cái nhìn đơn giản cho trình chỉnh sửa bánh rán.

00:20:04.000 --> 00:20:09.000
Như tôi đã đề cập trước đó, các tin nhắn đang chờ xử lý được gửi mỗi khi ứng dụng của bạn đến tiền cảnh.

00:20:09.000 --> 00:20:15.000
Vì vậy, tôi muốn thiết lập một trình nghe tin nhắn trong mỗi chế độ xem mà tôi muốn trì hoãn việc trình bày tin nhắn.

00:20:15.000 --> 00:20:20.000
Tôi sẽ thêm một mảng ràng buộc để thu thập tất cả các tin nhắn được gửi đến ứng dụng của tôi trong khi tôi đang ở chế độ xem chỉnh sửa.

00:20:20.000 --> 00:20:28.000
Điều này rất quan trọng, bởi vì nếu tôi không thiết lập trình nghe tin nhắn, StoreKit sẽ hiển thị bảng tin nhắn ngay lập tức khi ứng dụng của tôi ở phía trước.

00:20:28.000 --> 00:20:32.000
Ngay khi chế độ xem xuất hiện, tôi đã thiết lập trình nghe tin nhắn của mình.

00:20:32.000 --> 00:20:37.000
Tôi sẽ làm điều này bằng cách thiết lập một tác vụ lặp lại một thuộc tính tĩnh trên loại tin nhắn.

00:20:37.000 --> 00:20:42.000
Thuộc tính này là một chuỗi không đồng bộ và tôi có thể nhận tin nhắn khi chúng đến.

00:20:42.000 --> 00:20:46.000
Đối với trường hợp sử dụng của tôi, tôi sẽ lưu tin nhắn trong mảng pendingMessages.

00:20:46.000 --> 00:20:56.000
Vì các tin nhắn đang chờ xử lý được gửi mỗi khi ứng dụng của bạn vào tiền cảnh, ứng dụng của bạn có thể nhận được cùng một tin nhắn nhiều lần, vì vậy tôi có điều kiện này để tránh thêm tin nhắn trùng lặp vào mảng của mình.

00:20:56.000 --> 00:21:01.000
Sau đó, khi chế độ xem bị loại bỏ, tôi sẽ hiển thị các tin nhắn trong chế độ xem phụ huynh.

00:21:01.000 --> 00:21:05.000
Đây là chế độ xem mẹ chứa liên kết điều hướng đến trình chỉnh sửa bánh rán.

00:21:05.000 --> 00:21:10.000
Ở đây, tôi đã thu thập tất cả các tin nhắn đang chờ xử lý mà tôi cần hiển thị trong mảng pendingMessages này.

00:21:10.000 --> 00:21:13.000
Vậy làm cách nào để hiển thị những tin nhắn đang chờ xử lý này?

00:21:13.000 --> 00:21:17.000
Chà, bây giờ có một giá trị môi trường displayStoreKitMessage.

00:21:17.000 --> 00:21:23.000
Điều này giúp bạn có được một phiên bản của DisplayMessageAction, sau đó bạn có thể sử dụng để hiển thị một tin nhắn nhất định.

00:21:23.000 --> 00:21:30.000
Khi chế độ xem xuất hiện, tôi sẽ lặp lại các tin nhắn đang chờ xử lý và gọi displayStoreKitMessage chuyển trong tin nhắn tôi muốn hiển thị.

00:21:30.000 --> 00:21:34.000
StoreKit đảm nhận việc trình bày bảng tin nhắn.

00:21:34.000 --> 00:21:38.000
Trước đó, tôi đã đề cập rằng cùng một tin nhắn có thể được gửi đến ứng dụng của bạn nhiều lần.

00:21:38.000 --> 00:21:42.000
Đó là bởi vì một tin nhắn không được đánh dấu là đã đọc cho đến khi nó được trình bày cho người dùng.

00:21:42.000 --> 00:21:48.000
Vì vậy, StoreKit đảm bảo rằng mỗi tin nhắn duy nhất chỉ được trình bày một lần.

00:21:48.000 --> 00:21:52.000
Và đó là một triển khai nhanh chóng của Messages API.

00:21:52.000 --> 00:22:04.000
Hãy nhớ rằng, tin nhắn StoreKit được gửi đến ứng dụng của bạn mỗi khi nó đến tiền cảnh, vì vậy bạn sẽ muốn thiết lập trình nghe tin nhắn trong mỗi chế độ xem mà bạn muốn kiểm soát thời gian khi tin nhắn được hiển bày.

00:22:04.000 --> 00:22:10.000
Bạn có thể đảm bảo khách hàng có trải nghiệm tuyệt vời bằng cách đảm bảo các tờ tin nhắn không xuất hiện vào những thời điểm bất ngờ.

00:22:10.000 --> 00:22:14.000
Hoặc có lẽ bạn muốn điều chỉnh logic của mình cho một số loại tin nhắn nhất định.

00:22:14.000 --> 00:22:23.000
Với thông báo đồng ý tăng giá, bạn có thể muốn giáo dục khách hàng của mình về giá trị bổ sung mà bạn đang cung cấp trước khi bảng chấp thuận tăng giá xuất hiện.

00:22:23.000 --> 00:22:31.000
Cuối cùng, hãy xem lại cách StoreKit bảo quản tên người dùng ứng dụng dưới dạng appAccountToken sau khi người dùng mua hàng.

00:22:31.000 --> 00:22:38.000
Nếu bạn có hệ thống tài khoản người dùng trên máy chủ của mình, rất có thể bạn đã sử dụng thuộc tính Tên người dùng ứng dụng.

00:22:38.000 --> 00:22:45.000
Tên người dùng ứng dụng là một chuỗi mà bạn tạo để liên kết giao dịch với tài khoản người dùng trên dịch vụ của mình.

00:22:45.000 --> 00:22:53.000
Trong API ban đầu để mua hàng trong ứng dụng, bạn đặt giá trị Tên người dùng ứng dụng khi bạn thêm thanh toán vào hàng đợi thanh toán.

00:22:53.000 --> 00:23:01.000
Mặc dù tên người dùng ứng dụng chấp nhận bất kỳ chuỗi nào, chúng tôi khuyên bạn nên cung cấp biểu diễn chuỗi của UUID.

00:23:01.000 --> 00:23:08.000
Khi bạn cung cấp cho nó một chuỗi UUID, StoreKit vẫn duy trì giá trị và bạn sẽ thấy nó trong giao dịch mà hàng đợi cập nhật.

00:23:08.000 --> 00:23:13.000
Nếu bạn không cung cấp chuỗi UUID cho tên người dùng ứng dụng, StoreKit có thể không duy trì nó.

00:23:13.000 --> 00:23:21.000
Không có gì đảm bảo giá trị sẽ tồn tại giữa thời điểm bạn thêm giao dịch thanh toán vào hàng đợi và khi hàng đợi cập nhật giao dịch.

00:23:21.000 --> 00:23:30.000
Khi bạn cung cấp biểu diễn chuỗi của UUID, bạn có thể xác định tài khoản người dùng ứng dụng nào của mình đã bắt đầu và hoàn tất giao dịch.

00:23:30.000 --> 00:23:39.000
Trong các API StoreKit hiện đại, chúng tôi triển khai khái niệm này dưới dạng tùy chọn mua hàng được gọi là appAccountToken và nó yêu cầu định dạng UUID.

00:23:39.000 --> 00:23:47.000
Bây giờ, khi bạn đặt tên người dùng ứng dụng thành chuỗi UUID trong quá trình thanh toán, máy chủ App Store sẽ lưu trữ nó dưới dạng appAccountToken.

00:23:47.000 --> 00:23:57.000
Vì vậy, bạn sẽ thấy UUID của nó xuất hiện trong thông tin giao dịch đã ký được trả về bởi API Máy chủ App Store và trong Thông báo Máy chủ Cửa hàng Ứng dụng V2.

00:23:57.000 --> 00:24:03.000
Và với tư cách là UUID, nó tương thích với appAccountToken trong API giao dịch StoreKit hiện đại.

00:24:03.000 --> 00:24:15.000
Vì vậy, bây giờ bạn có thể chắc chắn rằng khi bạn cập nhật cơ sở mã của mình lên các API StoreKit hiện đại, UUID bạn đã sử dụng cho ứng dụng Tên người dùng được giữ nguyên dưới dạng appAccountToken trong các giao dịch StoreKit.

00:24:15.000 --> 00:24:18.000
Hôm nay chúng tôi đã đề cập đến rất nhiều thứ.

00:24:18.000 --> 00:24:24.000
Trước khi chuyển sang các bản cập nhật máy chủ, hãy xem lại các bản cập nhật StoreKit năm nay.

00:24:24.000 --> 00:24:35.000
Chúng tôi đã thảo luận về việc xác thực giao dịch mua ứng dụng của bạn bằng Giao dịch ứng dụng, đổi mã ưu đãi và yêu cầu đánh giá trong SwiftUI và kiểm soát việc trình bày tin nhắn StoreKit.

00:24:35.000 --> 00:24:41.000
Chúng tôi đã nói về địa phương giá mới, môi trường và các thuộc tính ngày bắt đầu đăng ký gần đây.

00:24:41.000 --> 00:24:50.000
Và, chúng tôi đã xem xét tầm quan trọng của việc sử dụng biểu diễn chuỗi của UUID cho Tên người dùng ứng dụng để duy trì nó dưới dạng mã thông báo tài khoản ứng dụng.

00:24:50.000 --> 00:24:56.000
Tôi thực sự khuyên bạn nên xem phiên khác của chúng tôi "Có gì mới trong thử nghiệm StoreKit."

00:24:56.000 --> 00:25:01.000
Và nếu bạn cần bồi dưỡng về API StoreKit 2, hãy xem phiên năm ngoái "Gặp gỡ StoreKit 2".

00:25:01.000 --> 00:25:06.000
Bây giờ tôi muốn giao nó cho Ian để hướng dẫn bạn các bản cập nhật cho máy chủ App Store.

00:25:06.000 --> 00:25:07.000
Ian Zanger: Cảm ơn, Dani.

00:25:07.000 --> 00:25:12.000
Xin chào mọi người. Tên tôi là Ian, và tôi là một kỹ sư trong nhóm App Store Server.

00:25:12.000 --> 00:25:19.000
Bây giờ bạn đã nghe tin mới nhất về việc mua hàng trong ứng dụng với StoreKit, tôi sẽ chuyển số và nói về máy chủ.

00:25:19.000 --> 00:25:32.000
Đầu tiên, tôi sẽ xem xét một số phát triển gần đây từ năm ngoái trước khi chuyển sang một số bản cập nhật mới thú vị sắp ra mắt cho API Máy chủ App Store và Thông báo Máy chủ App Store Phiên bản 2.

00:25:32.000 --> 00:25:34.000
Hãy bắt đầu nào.

00:25:34.000 --> 00:25:36.000
Năm ngoái thật lớn.

00:25:36.000 --> 00:25:48.000
Chúng tôi đã mang đến cho bạn một bộ điểm cuối hoàn toàn mới với API Máy chủ App Store và Thông báo Máy chủ App Store V2, bao gồm hỗ trợ kiểm tra hộp cát đầy đủ cho tất cả các tính năng mới này.

00:25:48.000 --> 00:26:03.000
Chúng tôi đã chia sẻ cách bạn có thể sử dụng điểm cuối Nhận Lịch sử Giao dịch để nhận toàn bộ lịch sử mua hàng trong ứng dụng của người dùng hoặc điểm cuối Nhận Tất cả Trạng thái Đăng ký để cập nhật trạng thái đăng ký hiện tại của người dùng.

00:26:03.000 --> 00:26:14.000
Cả hai điểm cuối này đều thuận tiện khóa khỏi originalTransactionId của người dùng, vì vậy bạn có thể truy cập kho dữ liệu này bằng cách chỉ lưu trữ một giá trị đơn giản này.

00:26:14.000 --> 00:26:25.000
Chúng tôi cũng đề cập đến cách phiên bản 2 của Thông báo Máy chủ App Store có thể đơn giản hóa việc xử lý sự kiện trên máy chủ của bạn và bổ sung cho API Máy chủ App Store.

00:26:25.000 --> 00:26:33.000
Với thông báo V2, máy chủ App Store gọi trực tiếp cho máy chủ của bạn, cung cấp các bản cập nhật mua hàng trong ứng dụng khi chúng xảy ra.

00:26:33.000 --> 00:26:40.000
Loại thông báo được sắp xếp hợp lý và loại phụ giúp bạn dễ dàng hiểu những gì đang xảy ra.

00:26:40.000 --> 00:26:45.000
Bạn có thể sử dụng những thứ này để theo dõi các thay đổi liên quan đến đăng ký trong ứng dụng và các sự kiện khác.

00:26:45.000 --> 00:26:51.000
Với tất cả các nguồn dữ liệu này, chúng tôi muốn phân tích dữ liệu đó dễ dàng nhất có thể.

00:26:51.000 --> 00:27:04.000
Biên lai bây giờ đã là quá khứ, vì các dịch vụ mới này cung cấp dữ liệu trong ứng dụng ở định dạng JSON đã ký, vì vậy bạn có thể dễ dàng phân tích cú pháp và tin tưởng rằng nó đến từ máy chủ App Store.

00:27:04.000 --> 00:27:07.000
Năm ngoái là một năm trọng đại đối với máy chủ App Store.

00:27:07.000 --> 00:27:15.000
Nó cũng có thể lớn đối với bạn nếu bạn làm việc để cập nhật mã máy chủ của mình để tận dụng tất cả các tính năng mới này.

00:27:15.000 --> 00:27:27.000
Hãy yên tâm rằng nỗ lực sẽ tiếp tục được đền đáp khi chúng tôi mang đến những cải tiến và tính năng mới mạnh mẽ cho API Máy chủ App Store và Thông báo Máy chủ Cửa hàng Ứng dụng V2.

00:27:27.000 --> 00:27:45.000
Đó là năm đánh giá của chúng tôi, nhưng nếu bạn muốn bồi dưỡng thêm sau khi nghe các bản cập nhật năm nay, hãy nhớ xem các phiên WWDC21 có tiêu đề "Quản lý mua hàng trong ứng dụng trên máy chủ của bạn", "Gặp gỡ StoreKit 2" và "Hỗ trợ khách hàng và xử lý hoàn tiền."

00:27:45.000 --> 00:27:53.000
Bây giờ hãy chuyển sang các bản cập nhật hoàn toàn mới đến với máy chủ App Store cho WWDC22.

00:27:53.000 --> 00:27:58.000
Đầu tiên tôi sẽ chia sẻ một số cập nhật cho các trường thông tin giao dịch và gia hạn.

00:27:58.000 --> 00:28:03.000
Tiếp theo tôi sẽ cho bạn biết về những cải tiến mới đối với API Máy chủ App Store.

00:28:03.000 --> 00:28:11.000
Và cuối cùng, tôi sẽ chia sẻ các tính năng mới thú vị sắp ra mắt trên App Store Server Notifications V2.

00:28:11.000 --> 00:28:18.000
Bây giờ chúng ta hãy đi sâu vào chủ đề mới đầu tiên của chúng ta: các trường mới được tìm thấy trong thông tin giao dịch và gia hạn.

00:28:18.000 --> 00:28:26.000
Trước đó, bạn đã nghe từ Dani về một vài lĩnh vực mới đến với thông tin giao dịch và gia hạn của các giao dịch mua trong ứng dụng.

00:28:26.000 --> 00:28:40.000
Các trường này, môi trường và recentSubscriptionStartDate, cũng đang đến với tải trọng thông tin giao dịch và gia hạn mà bạn nhận được từ API Máy chủ App Store và trong Thông báo Máy chủ Cửa hàng Ứng dụng V2.

00:28:40.000 --> 00:28:48.000
Hãy cùng xem xét mới dữ liệu mà bạn có thể mong đợi nhận được từ máy chủ App Store với các trường mới này được bao gồm.

00:28:48.000 --> 00:28:53.000
Đầu tiên là tải trọng thông tin giao dịch, mà chúng ta có thể thấy ở đây sau khi giải mã.

00:28:53.000 --> 00:28:57.000
Ở phía dưới, bạn có thể thấy lĩnh vực mới của chúng tôi: môi trường.

00:28:57.000 --> 00:29:04.000
Bạn có thể sử dụng nó để biết, trong nháy mắt, liệu giao dịch đã diễn ra trong môi trường sản xuất hay hộp cát.

00:29:04.000 --> 00:29:10.000
Tiếp theo là tải trọng thông tin gia hạn, cũng được thấy ở đây sau khi giải mã.

00:29:10.000 --> 00:29:15.000
Như bạn có thể thấy, trường môi trường cũng có sẵn ở đây để bạn tham khảo.

00:29:15.000 --> 00:29:21.000
Ngoài ra, recentSubscriptionStartDate bây giờ sẽ xuất hiện trong mọi tải trọng thông tin gia hạn.

00:29:21.000 --> 00:29:32.000
Đây là ngày bắt đầu mua đăng ký đầu tiên của người dùng trong chuỗi gia hạn gần đây nhất của họ, bỏ qua bất kỳ khoảng trống nào từ 60 ngày trở xuống.

00:29:32.000 --> 00:29:38.000
recentSubscriptionStartDate là một cách dễ dàng để có được ý tưởng về lòng trung thành của khách hàng trong nháy mắt.

00:29:38.000 --> 00:29:51.000
Nhưng nếu bạn muốn biết thêm chi tiết, bao gồm thời gian và độ dài của bất kỳ khoảng trống nào trong dịch vụ, bạn có thể gọi điểm cuối Nhận Lịch sử Giao dịch và kiểm tra toàn bộ lịch sử mua hàng gia hạn đăng ký của người dùng.

00:29:51.000 --> 00:30:03.000
Hoặc để biết thêm chi tiết, với Thông báo Máy chủ App Store V2, máy chủ App Store tự động gửi thông tin cập nhật về đăng ký người dùng đến máy chủ của bạn.

00:30:03.000 --> 00:30:14.000
Những thông báo này cung cấp cho bạn cái nhìn sâu sắc tối đa về thời gian của các sự kiện như thay đổi tùy chọn gia hạn, đổi ưu đãi, thất bại thanh toán và hơn thế nữa.

00:30:14.000 --> 00:30:21.000
Như bạn có thể thấy, recentSubscriptionStartDate làm tròn một bộ tùy chọn để xác định lòng trung thành của khách hàng.

00:30:21.000 --> 00:30:27.000
Sử dụng các công cụ này để nhắm mục tiêu các ưu đãi và thưởng cho những khách hàng trung thành nhất của bạn.

00:30:27.000 --> 00:30:33.000
Bây giờ hãy chuyển sang một số cải tiến mới thuận tiện cho điểm cuối Nhận Lịch sử Giao dịch.

00:30:33.000 --> 00:30:41.000
Với điểm cuối Nhận Lịch sử Giao dịch, bạn có thể tìm nạp toàn bộ lịch sử mua hàng của người dùng trong ứng dụng của mình.

00:30:41.000 --> 00:30:46.000
Phản hồi điểm cuối được phân trang để bạn có thể xử lý dữ liệu này theo các phần hợp lý.

00:30:46.000 --> 00:30:53.000
Mỗi phản hồi chứa một mã thông báo sửa đổi mà bạn cung cấp trong yêu cầu tiếp theo để có được trang tiếp theo.

00:30:53.000 --> 00:31:02.000
Và các trang được sắp xếp theo ngày sửa đổi, có nghĩa là mỗi trang tiếp theo chứa các giao dịch được sửa đổi gần đây hơn.

00:31:02.000 --> 00:31:05.000
Hãy cùng xem cái này hoạt động như thế nào.

00:31:05.000 --> 00:31:12.000
Bạn gọi điểm cuối Get Transaction History và cung cấp originalTransactionId.

00:31:12.000 --> 00:31:18.000
Máy chủ App Store sẽ trả lại tối đa 20 giao dịch đã ký cho người dùng đó.

00:31:18.000 --> 00:31:25.000
Nó cũng sẽ trả về một giá trị sửa đổi cập nhật mà bạn sẽ cung cấp trong yêu cầu trang tiếp theo của mình cho người dùng này.

00:31:25.000 --> 00:31:31.000
Bạn sẽ biết có nhiều dữ liệu hơn khi trường hasMore trong phản hồi là đúng.

00:31:31.000 --> 00:31:35.000
Giả sử trong trường hợp này có một trang dữ liệu khác có sẵn.

00:31:35.000 --> 00:31:41.000
Bạn đưa ra một yêu cầu khác đến điểm cuối và bạn bao gồm giá trị sửa đổi đó từ phản hồi đầu tiên.

00:31:41.000 --> 00:31:46.000
Bạn nhận được trang dữ liệu tiếp theo, bao gồm giá trị sửa đổi được cập nhật.

00:31:46.000 --> 00:31:52.000
hasMore bây giờ là sai, vì vậy bạn biết rằng bạn đã cập nhật dữ liệu giao dịch mới nhất.

00:31:52.000 --> 00:31:58.000
Ngoại trừ lần này, bạn nhận thấy điều gì đó về giao dịch cuối cùng trong phản hồi; bạn đã thấy nó trước đây!

00:31:58.000 --> 00:32:03.000
Đó là một trong 20 ban đầu bạn nhận được để đáp ứng yêu cầu đầu tiên của mình.

00:32:03.000 --> 00:32:10.000
Điều này có nghĩa là giao dịch phải được sửa đổi, vì vậy nó đã được đặt lại ở đầu thứ tự sắp xếp.

00:32:10.000 --> 00:32:15.000
Bây giờ, bạn có thể kiểm tra dữ liệu của giao dịch đó và lưu ý những gì đã thay đổi.

00:32:15.000 --> 00:32:24.000
Trong trường hợp này, bạn nhận thấy các trường revocationDate và revocationReason hiện đã được điền, có nghĩa là giao dịch đã bị thu hồi.

00:32:24.000 --> 00:32:29.000
Bạn có thể thực hiện hành động bằng cách thu hồi bất kỳ nội dung nào liên quan đến giao dịch mua.

00:32:29.000 --> 00:32:39.000
Bạn nên lưu trữ giá trị sửa đổi từ phản hồi cuối cùng này cùng với originalTransactionId mà bạn đã sử dụng để xác định người dùng.

00:32:39.000 --> 00:32:50.000
Lần tới khi bạn gọi điểm cuối cho người dùng này, bạn có thể cung cấp bản sửa đổi đó và biết rằng bạn chỉ nhận lại dữ liệu giao dịch mới đã được sửa đổi kể từ yêu cầu cuối cùng của bạn.

00:32:50.000 --> 00:33:00.000
Như bạn đã thấy, điểm cuối Nhận Lịch sử Giao dịch cung cấp cho bạn một cách đơn giản để truy xuất một bộ dữ liệu mua hàng trong ứng dụng toàn diện.

00:33:00.000 --> 00:33:03.000
Nhưng có lẽ đôi khi nó có thể hơi quá toàn diện.

00:33:03.000 --> 00:33:09.000
Một số người dùng có lịch sử mua hàng dài từ vài năm trước.

00:33:09.000 --> 00:33:16.000
Đối với những người dùng này, điểm cuối này có thể trả lại hàng trăm giao dịch mua thuộc nhiều loại khác nhau.

00:33:16.000 --> 00:33:20.000
Ngay cả với các trang, điều này có thể rất nhiều để xử lý.

00:33:20.000 --> 00:33:27.000
Đó là lý do tại sao năm nay, chúng tôi đang tăng cường điểm cuối này với nhiều tùy chọn sắp xếp và lọc mới.

00:33:27.000 --> 00:33:39.000
Bây giờ, bạn có thể cho chúng tôi biết chính xác dữ liệu bạn muốn ngay từ đầu, tiết kiệm thời gian xử lý trên máy chủ của bạn và giảm số lượng cuộc gọi mạng cần thiết để truy xuất tất cả các trang có sẵn.

00:33:39.000 --> 00:33:47.000
Bạn có thể sắp xếp theo ngày sửa đổi giảm dần nếu bạn muốn xem các giao dịch mua được sửa đổi gần đây nhất trên trang kết quả đầu tiên.

00:33:47.000 --> 00:33:56.000
Bạn cũng có thể lọc theo một số trường hữu ích như loại sản phẩm, ID sản phẩm, trạng thái chia sẻ trong gia đình và hơn thế nữa.

00:33:56.000 --> 00:34:06.000
Để áp dụng các tùy chọn sắp xếp và lọc mới này, chỉ cần thêm chúng dưới dạng tham số truy vấn vào yêu cầu của bạn đến điểm cuối Nhận Lịch sử Giao dịch.

00:34:06.000 --> 00:34:09.000
Chúng ta hãy xem xét kỹ hơn cách thức hoạt động của nó.

00:34:09.000 --> 00:34:12.000
Tại đây bạn có thể thấy tất cả các tùy chọn tham số mới.

00:34:12.000 --> 00:34:18.000
Những thứ này có thể trông quen thuộc, vì hầu hết được lấy trực tiếp từ tải trọng thông tin giao dịch.

00:34:18.000 --> 00:34:22.000
Bạn có thể trộn và kết hợp các thông số này để có được kết quả rất cụ thể.

00:34:22.000 --> 00:34:31.000
Ví dụ, có lẽ chúng tôi chỉ muốn tìm nạp các giao dịch mua không tiêu hao mà người dùng đã thực hiện kể từ đầu năm nay.

00:34:31.000 --> 00:34:34.000
Chúng tôi cũng muốn loại trừ bất kỳ giao dịch mua bị thu hồi nào.

00:34:34.000 --> 00:34:45.000
Chúng tôi sẽ xây dựng yêu cầu tùy chỉnh của mình bằng cách đặt productType thành NON_CONSUMABLE và chỉ định startDate là đầu năm nay được biểu thị bằng mili giây.

00:34:45.000 --> 00:34:49.000
Cuối cùng, chúng tôi sẽ đặt excludeRevoked thành true.

00:34:49.000 --> 00:34:50.000
Và đó là yêu cầu của chúng tôi!

00:34:50.000 --> 00:34:58.000
Vì chúng tôi không chỉ định thứ tự sắp xếp, phản hồi sẽ mặc định sắp xếp theo ngày sửa đổi tăng dần.

00:34:58.000 --> 00:35:04.000
Bây giờ ngay cả với một yêu cầu cụ thể như thế này, có thể có nhiều trang mua hàng để truy xuất.

00:35:04.000 --> 00:35:12.000
Đối với các yêu cầu tiếp theo, chúng ta nên đảm bảo bao gồm các tham số truy vấn giống hệt nhau, ngoài bản sửa đổi từ phản hồi trước đó.

00:35:12.000 --> 00:35:24.000
Để linh hoạt hơn nữa, ba trong số các trường bộ lọc hỗ trợ nhiều giá trị, vì vậy bạn chỉ có thể lọc những giao dịch mua khớp với ít nhất một trong các giá trị được cung cấp.

00:35:24.000 --> 00:35:32.000
Các trường này là productType, productId, và subscriptionGroupIdentifier.

00:35:32.000 --> 00:35:39.000
Để cung cấp nhiều giá trị cho các tham số này, chỉ cần xác định chúng nhiều lần.

00:35:39.000 --> 00:35:44.000
Tiếp theo, hãy chuyển sang cập nhật Thông báo Máy chủ App Store.

00:35:44.000 --> 00:35:50.000
Với App Store Server Notifications V2, bạn có thể đưa máy chủ của mình lên một tầm cao mới.

00:35:50.000 --> 00:35:57.000
Thông báo V2 cung cấp thông tin chi tiết về các sự kiện mua hàng trong ứng dụng mà bạn không thể nhận được ở bất kỳ nơi nào khác.

00:35:57.000 --> 00:36:05.000
Những thứ này đặc biệt hữu ích để theo dõi vòng đời của các đăng ký tự động gia hạn được cung cấp trong ứng dụng của bạn.

00:36:05.000 --> 00:36:15.000
Bạn có thể sử dụng những thông tin chi tiết này để giữ chân khách hàng, giành lại những khách hàng đã khuấy động, giải quyết các yêu cầu hỗ trợ khách hàng và hơn thế nữa.

00:36:15.000 --> 00:36:19.000
Với tất cả những lợi ích này, bạn có thể tự hỏi làm thế nào để bắt đầu.

00:36:19.000 --> 00:36:24.000
Như với bất kỳ tính năng mới nào, môi trường thử nghiệm hộp cát là nơi tốt nhất để bắt đầu.

00:36:24.000 --> 00:36:35.000
Đó là lý do tại sao năm ngoái, chúng tôi đã thêm khả năng đặt URL máy chủ riêng biệt trong App Store Connect để nhận Thông báo Máy chủ App Store trong hộp cát.

00:36:35.000 --> 00:36:43.000
Sau khi đăng ký URL máy chủ của bạn, bạn sẽ muốn xác nhận máy chủ của mình đang nhận thông báo từ máy chủ App Store.

00:36:43.000 --> 00:36:49.000
Bạn có thể thiết lập một tài khoản hộp cát chỉ để kích hoạt thông báo thông qua hành động của người dùng.

00:36:49.000 --> 00:36:56.000
Ví dụ, giả sử bạn thực hiện lần đầu tiên mua đăng ký bằng tài khoản sandbox đó.

00:36:56.000 --> 00:37:03.000
Bạn sẽ nhận được thông báo V2 thuộc loại ĐĂNG KÝ và loại phụ INITIAL_BUY.

00:37:03.000 --> 00:37:05.000
Nhưng nếu thông báo đó không đến thì sao?

00:37:05.000 --> 00:37:12.000
Bạn có thể tự hỏi liệu có vấn đề gì với máy chủ của bạn hay các bước bạn đã thực hiện để kích hoạt thông báo hay không.

00:37:12.000 --> 00:37:16.000
Tình huống này có thể tạo ra rất nhiều điều không chắc chắn ngay khi bạn bắt đầu.

00:37:16.000 --> 00:37:25.000
Chúng tôi muốn đơn giản hóa trải nghiệm này và cung cấp cho bạn cách để dễ dàng xác minh rằng Thông báo Máy chủ App Store có thể đến máy chủ của bạn.

00:37:25.000 --> 00:37:31.000
Đó là lý do tại sao năm nay, chúng tôi giới thiệu điểm cuối Yêu cầu Thông báo Kiểm tra mới.

00:37:31.000 --> 00:37:42.000
Bằng cách gọi điểm cuối đơn giản này, bạn có thể yêu cầu chúng tôi gửi Thông báo V2 thuộc loại KIỂM TRA đến URL máy chủ đã đăng ký cho ứng dụng của bạn trong App Store Connect.

00:37:42.000 --> 00:37:47.000
Loại thông báo TEST mới được sử dụng riêng cho điểm cuối này.

00:37:47.000 --> 00:37:55.000
Bạn có thể gọi điểm cuối trong hộp cát hoặc sản xuất để kiểm tra URL đã lưu của mình cho một trong hai môi trường.

00:37:55.000 --> 00:38:01.000
Sử dụng điểm cuối mới này để nhanh chóng kiểm tra các URL và cấu hình máy chủ mới.

00:38:01.000 --> 00:38:04.000
Hãy xem điều này đơn giản hóa việc thiết lập lần đầu như thế nào.

00:38:04.000 --> 00:38:12.000
Bây giờ, nếu bạn chỉ muốn kích hoạt thông báo đầu tiên của mình, không cần thiết lập tài khoản hộp cát hoặc thực hiện mua hàng.

00:38:12.000 --> 00:38:22.000
Chỉ cần gọi điểm cuối mới trong bất kỳ môi trường nào bạn muốn kiểm tra và bạn sẽ nhận được phản hồi HTTP 200 xác nhận yêu cầu của mình.

00:38:22.000 --> 00:38:31.000
Phản hồi sẽ chứa một trường mới, testNotificationToken, xác định thông báo kiểm tra mà máy chủ của bạn sẽ nhận được.

00:38:31.000 --> 00:38:34.000
Chúng tôi sẽ quay lại lĩnh vực này sau.

00:38:34.000 --> 00:38:43.000
Ngay sau đó, máy chủ của bạn sẽ nhận được thông báo V2 thuộc loại KIỂM TRA tại URL được lưu trong App Store Connect.

00:38:43.000 --> 00:38:46.000
Bây giờ hãy xem cách gọi điểm cuối này.

00:38:46.000 --> 00:38:52.000
Chỉ cần gửi một yêu cầu POST đơn giản đến đường dẫn mới này trên máy chủ App Store.

00:38:52.000 --> 00:38:58.000
Bạn sẽ nhận được phản hồi HTTP 200 và biết rằng yêu cầu của bạn đã được gửi.

00:38:58.000 --> 00:39:03.000
Phản hồi sẽ chứa trường mới mà tôi đã đề cập, testNotificationToken.

00:39:03.000 --> 00:39:06.000
Hãy lưu ý điều này để dùng sau.

00:39:06.000 --> 00:39:10.000
Bạn sẽ sớm nhận được Thông báo KIỂM TRA đã ký.

00:39:10.000 --> 00:39:14.000
Đây là thông báo đó sẽ trông như thế nào khi nó được giải mã.

00:39:14.000 --> 00:39:23.000
Bạn sẽ nhận thấy nó chứa tất cả các trường cấp cao nhất thông thường của thông báo V2, bao gồm Loại thông báo mới, KIỂM TRA.

00:39:23.000 --> 00:39:27.000
Nội dung của đối tượng dữ liệu ngắn hơn một chút so với thông báo thông thường.

00:39:27.000 --> 00:39:40.000
Vì đây chỉ là một bài kiểm tra, không có dữ liệu liên quan đến giao dịch nào để bao gồm, vì vậy chúng tôi bỏ qua các trường giao dịch cụ thể, đáng chú ý nhất là signedTransactionInfo.

00:39:40.000 --> 00:39:48.000
Khi gọi điểm cuối Yêu cầu Thông báo Kiểm tra mới, hãy nhớ rằng Thông báo Máy chủ App Store được gửi không đồng bộ.

00:39:48.000 --> 00:39:59.000
Cuộc gọi thành công của bạn đến điểm cuối sẽ trả về HTTP 200 nhưng thông báo kiểm tra thực tế sẽ đến riêng, một thời gian ngắn sau đó.

00:39:59.000 --> 00:40:07.000
Cho rằng điểm cuối này là tất cả về việc kiểm tra cấu hình máy chủ của bạn, bạn có thể tự hỏi phải làm gì khi kiểm tra đó không thành công.

00:40:07.000 --> 00:40:12.000
Nói cách khác, nếu thông báo kiểm tra không đến thì sao?

00:40:12.000 --> 00:40:24.000
Để nâng cao hơn nữa khả năng kiểm tra của bạn, chúng tôi sẽ phát hành điểm cuối Nhận Trạng thái Thông báo Kiểm tra mà bạn sẽ sử dụng cùng với điểm cuối Yêu cầu Thông báo Kiểm tra.

00:40:24.000 --> 00:40:30.000
Với điểm cuối mới này, bạn có thể kiểm tra trạng thái của thông báo KIỂM TRA được yêu cầu trước đó.

00:40:30.000 --> 00:40:39.000
Phản hồi điểm cuối sẽ cho bạn biết liệu máy chủ App Store có thể tiếp cận máy chủ của bạn và gửi thành công thông báo KIỂM TRA hay không.

00:40:39.000 --> 00:40:46.000
Nếu việc gửi không thành công, nó sẽ cho bạn ý tưởng về lý do tại sao, vì vậy bạn có thể khắc phục sự cố cấu hình máy chủ của mình tốt hơn.

00:40:46.000 --> 00:40:50.000
Hãy kiểm tra xem bạn sẽ sử dụng điểm cuối này như thế nào.

00:40:50.000 --> 00:40:54.000
Gửi yêu cầu GET đến đường dẫn này trên máy chủ App Store.

00:40:54.000 --> 00:41:02.000
Trong đường dẫn, bao gồm testNotificationToken bạn nhận được từ điểm cuối Yêu cầu Thông báo Kiểm tra.

00:41:02.000 --> 00:41:07.000
Điều này sẽ cho chúng tôi biết bạn muốn kiểm tra trạng thái của thông báo kiểm tra nào.

00:41:07.000 --> 00:41:09.000
Bây giờ để phản hồi.

00:41:09.000 --> 00:41:17.000
Trường signedPayload chứa tải trọng thông báo TEST mà máy chủ App Store đã cố gắng gửi đến máy chủ của bạn.

00:41:17.000 --> 00:41:23.000
Và trường firstSendAttemptResult cho biết kết quả của nỗ lực gửi đó.

00:41:23.000 --> 00:41:34.000
Ở đây, SUCCESS chỉ ra rằng việc gửi đã thành công, có nghĩa là máy chủ App Store đã nhận được phản hồi HTTP 200 từ máy chủ của bạn.

00:41:34.000 --> 00:41:40.000
Nếu việc gửi không thành công, thay vào đó bạn sẽ thấy một trong một số giá trị lỗi khác nhau.

00:41:40.000 --> 00:41:48.000
Những giá trị này cho thấy lỗi mà máy chủ App Store gặp phải khi cố gắng tiếp cận máy chủ của bạn bằng thông báo kiểm tra.

00:41:48.000 --> 00:41:58.000
Với thông tin này, bạn có thể khắc phục sự cố máy chủ của mình, yêu cầu thông báo kiểm tra mới khi cần và giúp máy chủ của bạn chạy đáng tin cậy.

00:41:58.000 --> 00:42:11.000
Nói chung, các điểm cuối thông báo thử nghiệm này rất dễ sử dụng và có thể giúp bạn tiết kiệm rất nhiều rắc rối khi thiết lập hoặc cấu hình lại máy chủ của mình để nhận Thông báo Máy chủ V2 App Store.

00:42:11.000 --> 00:42:17.000
Giờ đây với sự trợ giúp của các điểm cuối này, bạn có thể thiết lập máy chủ của mình và xác nhận nó đang chạy trơn tru.

00:42:17.000 --> 00:42:20.000
Nhưng các máy chủ không hoàn hảo và sự cố ngừng hoạt động xảy ra.

00:42:20.000 --> 00:42:26.000
Làm thế nào để bạn khôi phục khi máy chủ của bạn ngừng hoạt động, khiến bạn bỏ lỡ Thông báo Máy chủ App Store?

00:42:26.000 --> 00:42:30.000
Giải pháp hiện tại cho việc này là một hệ thống thử lại.

00:42:30.000 --> 00:42:36.000
Khi máy chủ App Store không đến được máy chủ của bạn, nó sẽ bắt đầu quá trình thử lại.

00:42:36.000 --> 00:42:43.000
Nó sẽ thử gửi lại cùng một thông báo tối đa năm lần, với thời gian chờ đợi lâu hơn giữa mỗi lần thử.

00:42:43.000 --> 00:42:47.000
Những thử lại này chỉ diễn ra trong môi trường sản xuất.

00:42:47.000 --> 00:42:53.000
Các thử lại cuối cùng sẽ giúp bạn phục hồi sau khi mất điện, nhưng chúng không hoàn hảo cho mọi tình huống.

00:42:53.000 --> 00:42:57.000
Ví dụ, một số sự cố mất điện có thể lan rộng.

00:42:57.000 --> 00:43:05.000
Nếu máy chủ của bạn ngừng hoạt động đủ lâu để bỏ lỡ lần thử lại cuối cùng từ máy chủ App Store, thông báo đó sẽ bị mất.

00:43:05.000 --> 00:43:13.000
Hoặc phổ biến hơn, máy chủ của bạn có thể gặp phải một vấn đề rất ngắn, trong thời gian đó nó chỉ bỏ lỡ một số ít thông báo.

00:43:13.000 --> 00:43:20.000
Nhưng bỏ lỡ dù chỉ một thông báo có nghĩa là một số hồ sơ khách hàng của bạn đã lỗi thời trong ít nhất một giờ.

00:43:20.000 --> 00:43:23.000
Tuy nhiên bạn không biết cái nào!

00:43:23.000 --> 00:43:29.000
Rõ ràng, sự cố ngừng hoạt động của máy chủ rất căng thẳng và việc phục hồi từ chúng có thể là một nhiệm vụ phức tạp.

00:43:29.000 --> 00:43:39.000
Đó là lý do tại sao chúng tôi muốn khôi phục Thông báo Máy chủ App Store bị bỏ lỡ dễ dàng nhất có thể, vì vậy bạn có thể đưa máy chủ của mình trở lại đúng hướng càng sớm càng tốt.

00:43:39.000 --> 00:43:45.000
Đó là lý do tại sao năm nay, chúng tôi giới thiệu điểm cuối Nhận Lịch sử Thông báo mới.

00:43:45.000 --> 00:43:53.000
Với điểm cuối này, bạn có thể tìm nạp lịch sử của Thông báo Máy chủ Cửa hàng Ứng dụng V2 được tạo cho ứng dụng của mình.

00:43:53.000 --> 00:44:02.000
Cho dù máy chủ của bạn có nhận được thông báo thành công hay không, thông báo đó sẽ xuất hiện trong phản hồi của điểm cuối này.

00:44:02.000 --> 00:44:08.000
Khi gọi điểm cuối này, bạn sẽ chỉ định một phạm vi ngày của các thông báo để tìm nạp.

00:44:08.000 --> 00:44:18.000
Với WWDC, chúng tôi đã bắt đầu ghi lại dữ liệu này và chúng tôi sẽ xây dựng giới hạn của sáu tháng lịch sử mới nhất hiện có.

00:44:18.000 --> 00:44:29.000
Bạn có thể tùy chọn lọc yêu cầu của mình theo loại và loại phụ hoặc chỉ tìm nạp thông báo của một người dùng bằng cách cung cấp originalTransactionId.

00:44:29.000 --> 00:44:35.000
Và hệ thống thử lại hiện tại vẫn có sẵn, vì vậy bạn có thể sử dụng nó song song với điểm cuối mới này.

00:44:35.000 --> 00:44:39.000
Hãy xem bạn sẽ gọi điểm cuối này như thế nào.

00:44:39.000 --> 00:44:43.000
Bạn sẽ gửi yêu cầu POST đến đường dẫn mới này trên máy chủ App Store.

00:44:43.000 --> 00:44:48.000
Trong nội dung yêu cầu, bạn sẽ bao gồm Ngày bắt đầu và Ngày kết thúc.

00:44:48.000 --> 00:44:54.000
Phản hồi sẽ chỉ chứa các thông báo mà chúng tôi đã cố gắng gửi lần đầu tiên trong cửa sổ này.

00:44:54.000 --> 00:45:02.000
Hãy nhớ rằng các thông báo sớm nhất có sẵn sẽ là những thông báo được gửi sáu tháng trước ngày yêu cầu của bạn.

00:45:02.000 --> 00:45:08.000
Tùy chọn, bạn có thể chỉ định một Loại thông báo và Loại phụ thông báo.

00:45:08.000 --> 00:45:15.000
Nếu bạn làm vậy, lịch sử sẽ chỉ được lọc thành các thông báo khớp với cả hai giá trị này.

00:45:15.000 --> 00:45:19.000
Hãy nhớ rằng một số thông báo không có loại phụ.

00:45:19.000 --> 00:45:28.000
Ngoài ra, bạn có thể cung cấp originalTransactionId của người dùng, để tìm nạp lịch sử thông báo của chỉ người dùng đó.

00:45:28.000 --> 00:45:37.000
Cuối cùng, bạn nên cung cấp mã thông báo phân trang làm tham số truy vấn cho mọi yêu cầu tiếp theo để có được trang tiếp theo.

00:45:37.000 --> 00:45:44.000
Đảm bảo rằng bạn sử dụng cùng một nội dung yêu cầu cho các yêu cầu tiếp theo, chỉ thay đổi mã thông báo phân trang này.

00:45:44.000 --> 00:45:47.000
Bây giờ chúng ta hãy xem phản hồi.

00:45:47.000 --> 00:45:55.000
Mảng notificationHistory chứa tối đa 20 thông báo, với các thông báo cũ nhất trước tiên.

00:45:55.000 --> 00:46:07.000
Mỗi mục nhập trong mảng này đại diện cho một thông báo và bên trong bạn sẽ tìm thấy Payload đã ký, bạn có thể giải mã như bình thường để xem dữ liệu giao dịch.

00:46:07.000 --> 00:46:14.000
Dữ liệu bên trong giống hệt với tải trọng mà máy chủ App Store đã gửi trong thông báo ban đầu.

00:46:14.000 --> 00:46:20.000
Bạn sẽ thấy rằng chúng tôi cũng đã đưa trường firstSendAttemptResult mới vào phản hồi điểm cuối này.

00:46:20.000 --> 00:46:30.000
Bạn có thể sử dụng trường này để tìm kiếm chuỗi thời gian chờ và các lỗi khác để hiểu rõ hơn lý do tại sao máy chủ của bạn bỏ lỡ thông báo trong quá khứ.

00:46:30.000 --> 00:46:36.000
Phản hồi cũng chứa mã thông báo phân trang nếu có nhiều trang hơn để truy xuất.

00:46:36.000 --> 00:46:41.000
Bạn nên cung cấp điều này trong yêu cầu tiếp theo của mình để nhận được trang thông báo tiếp theo.

00:46:41.000 --> 00:46:47.000
Bạn sẽ biết có nhiều trang hơn để truy xuất miễn là trường hasMore là đúng.

00:46:47.000 --> 00:46:52.000
Và đó là tất cả những gì bạn cần biết về điểm cuối mới hữu ích này.

00:46:52.000 --> 00:46:56.000
Điều đó kết thúc các bản cập nhật máy chủ App Store của chúng tôi cho ngày hôm nay.

00:46:56.000 --> 00:47:02.000
Mọi tính năng máy chủ được công bố hôm nay hiện đều có sẵn trong cả hộp cát và sản xuất.

00:47:02.000 --> 00:47:07.000
Chúng tôi hy vọng bạn sẽ tận dụng các tính năng mới này để làm cho máy chủ của bạn tốt nhất có thể.

00:47:07.000 --> 00:47:24.000
Để biết thêm nội dung tuyệt vời về việc sử dụng máy chủ có mua hàng trong ứng dụng, bao gồm cách sử dụng các tính năng mới nhất trong khi hỗ trợ các khách hàng cũ, tôi khuyến khích bạn xem một phiên khác tại WWDC22, "Khám phá tích hợp và di chuyển mua hàng trong ứng dụng."

00:47:24.000 --> 00:47:27.000
Cả hai: Cảm ơn vì đã tham gia cùng chúng tôi tại WWDC22!

00:47:27.000 --> 23:59:59.000
♪

