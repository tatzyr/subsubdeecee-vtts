WEBVTT

00:00:00.000 --> 00:00:03.000
♪ Nhạc hip-hop nhạc cụ êm dịu ♪

00:00:03.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:14.000
Devin Clary: Xin chào. Tôi là Devin, một kỹ sư trong nhóm Tin nhắn.

00:00:14.000 --> 00:00:17.000
Lance Parker: Và tôi là Lance, cũng là một kỹ sư Tin nhắn.

00:00:17.000 --> 00:00:22.000
Devin: Chào mừng đến với "Tích hợp ứng dụng cộng tác tùy chỉnh của bạn với Tin nhắn."

00:00:22.000 --> 00:00:32.000
Cộng tác bắt đầu bằng một cuộc trò chuyện và trong iOS 16 và macOS Ventura, bạn có thể đưa trải nghiệm cộng tác tùy chỉnh của ứng dụng của mình ngay vào kết cấu của cuộc trò chuyện.

00:00:32.000 --> 00:00:36.000
Trong video này, chúng ta sẽ xem xét vòng đời của một sự hợp tác.

00:00:36.000 --> 00:00:42.000
Sau đó, chúng tôi sẽ chỉ cho bạn cách chuẩn bị nội dung cộng tác của ứng dụng để được chia sẻ thông qua Tin nhắn.

00:00:42.000 --> 00:00:52.000
Tiếp theo, chúng tôi sẽ cung cấp cho bạn mọi thứ bạn cần để xác minh ngay lập tức quyền truy cập của người nhận và phản hồi các thay đổi của người tham gia, tất cả mà không ảnh hưởng đến quyền riêng tư.

00:00:52.000 --> 00:00:59.000
Cuối cùng, chúng tôi sẽ chỉ cho bạn cách ứng dụng của bạn có thể đăng thông báo về nội dung ngay trong cuộc trò chuyện Tin nhắn.

00:00:59.000 --> 00:01:06.000
Video này giả định ứng dụng của bạn có cơ sở hạ tầng cộng tác hiện có và đã áp dụng các liên kết chung.

00:01:06.000 --> 00:01:14.000
Chúng tôi cũng sẽ xây dựng dựa trên một số khái niệm được giới thiệu trong "Thêm Chia sẻ với Bạn vào ứng dụng của bạn" và "Nâng cao trải nghiệm cộng tác với Tin nhắn."

00:01:14.000 --> 00:01:24.000
Đầu tiên, tôi sẽ xem xét vòng đời của một thông báo cộng tác tùy chỉnh để minh họa cách API này cho phép người dùng của bạn bắt đầu cộng tác nhanh hơn bao giờ hết.

00:01:24.000 --> 00:01:33.000
Khi người dùng quyết định chia sẻ sự cộng tác từ ứng dụng của bạn thông qua Tin nhắn, trước tiên bạn tạo siêu dữ liệu để thể hiện nội dung.

00:01:33.000 --> 00:01:41.000
Siêu dữ liệu bao gồm các tùy chọn chia sẻ mà người dùng có thể định cấu hình trước khi gửi tin nhắn và một số thuộc tính khác mà bạn có thể tùy chỉnh.

00:01:41.000 --> 00:01:46.000
Tiếp theo, bạn cung cấp siêu dữ liệu đó cho bảng chia sẻ hoặc để kéo và thả.

00:01:46.000 --> 00:01:51.000
Điều này cho phép một bản nháp của nội dung được dàn dựng trong trường soạn Tin nhắn.

00:01:51.000 --> 00:01:55.000
Sự hợp tác cần được thể hiện bằng một liên kết phổ quát.

00:01:55.000 --> 00:02:00.000
Điều đó có thể được tạo ngay lập tức, nhưng tốt nhất nên hoãn lại cho đến ngay trước khi tin nhắn được gửi đi.

00:02:00.000 --> 00:02:08.000
Điều này rất hữu ích nếu việc tạo liên kết ứng dụng của bạn phụ thuộc vào các tùy chọn chia sẻ đã chọn hoặc người nhận, như được định cấu hình trong trường soạn tin nhắn.

00:02:08.000 --> 00:02:14.000
Người dùng chọn người nhận và các tùy chọn chia sẻ và nhấn vào nút gửi.

00:02:14.000 --> 00:02:21.000
Trước khi tin nhắn được gửi đi, Tin nhắn yêu cầu ứng dụng của bạn cung cấp liên kết chung và mã định danh độc lập với thiết bị cho nội dung.

00:02:21.000 --> 00:02:29.000
Sử dụng mã định danh đó, Tin nhắn cung cấp một tập hợp các danh tính mật mã đại diện cho người nhận tin nhắn cộng tác cụ thể đó.

00:02:29.000 --> 00:02:38.000
Ứng dụng của bạn sẽ sử dụng các danh tính này sau này để cho phép người nhận mở liên kết ngay lập tức trên bất kỳ thiết bị nào của họ.

00:02:38.000 --> 00:02:44.000
Ứng dụng của bạn lưu trữ những danh tính đó trên máy chủ của nó và liên kết chúng với nội dung được chia sẻ.

00:02:44.000 --> 00:02:50.000
Khi ứng dụng của bạn hoàn thành bước này, tin nhắn sẽ được gửi đến người nhận.

00:02:50.000 --> 00:02:53.000
Bây giờ, đây là những gì xảy ra trên thiết bị nhận.

00:02:53.000 --> 00:02:59.000
Mục tiêu là xác minh quyền truy cập ngay lập tức, ghép nối danh tính người nhận với tài khoản trên máy chủ của bạn.

00:02:59.000 --> 00:03:08.000
Khi người nhận mở liên kết, ứng dụng của bạn sẽ nhận được cuộc gọi mở URL, giống như đối với bất kỳ liên kết nào khác.

00:03:08.000 --> 00:03:18.000
Khi ứng dụng của bạn phát hiện ra rằng tài khoản người dùng chưa có quyền truy cập vào tài liệu, nó sẽ truy vấn hệ thống để tìm bằng chứng về danh tính người dùng được ký mật mã bởi thiết bị người nhận.

00:03:18.000 --> 00:03:23.000
Ứng dụng của bạn gửi bằng chứng nhận dạng đã ký đó đến máy chủ của bạn để xác thực.

00:03:23.000 --> 00:03:30.000
Nếu chữ ký hợp lệ, máy chủ sẽ so sánh bằng chứng với danh tính được cung cấp trước đó bởi thiết bị gửi.

00:03:30.000 --> 00:03:35.000
Nếu có kết quả khớp, máy chủ của bạn sẽ cấp quyền truy cập vào tài khoản của người dùng.

00:03:35.000 --> 00:03:42.000
Và cùng với đó, người nhận đã có quyền truy cập tức thì và an toàn vào nội dung, tất cả mà không cần trao đổi thông tin tài khoản!

00:03:42.000 --> 00:03:45.000
Và đó là vòng đời của một thông điệp hợp tác!

00:03:45.000 --> 00:03:51.000
Tiếp theo, hãy xem xét kỹ hơn API để bắt đầu cộng tác.

00:03:51.000 --> 00:03:55.000
Hệ thống cần một số siêu dữ liệu về sự hợp tác.

00:03:55.000 --> 00:04:01.000
Và vì điều đó, bạn sử dụng một lớp mới trong khung Chia sẻ với Bạn được gọi là SWCollaborationMetadata.

00:04:01.000 --> 00:04:21.000
Lớp này có một vài thuộc tính để bạn định cấu hình: tiêu đề của nội dung, số nhận dạng cục bộ để tham chiếu nội dung trước khi được chia sẻ; tên người khởi tạo và xử lý tài khoản, để cung cấp sự minh bạch cho người dùng về tài khoản mà họ đang chia sẻ; và các tùy chọn chia sẻ mặc định, để người dùng định cấu hình.

00:04:21.000 --> 00:04:27.000
Đây là cách tạo một đối tượng siêu dữ liệu và định cấu hình các thuộc tính của nó.

00:04:27.000 --> 00:04:33.000
Tạo một mã định danh cục bộ bằng cách sử dụng SWLocalCollaborationIdentifier được khởi tạo bằng một chuỗi.

00:04:33.000 --> 00:04:41.000
Chuỗi chỉ cần đủ để ứng dụng của bạn xác định nội dung cục bộ, không phải trên các thiết bị.

00:04:41.000 --> 00:04:47.000
Khởi tạo một phiên bản siêu dữ liệu mới bằng cách sử dụng mã định danh cục bộ.

00:04:47.000 --> 00:04:57.000
Đặt tiêu đề nội dung, xử lý tài khoản của người khởi tạo và tên của họ bằng cách sử dụng PersonNameComponents từ khuôn khổ nền tảng.

00:04:57.000 --> 00:05:04.000
Tay cầm và tên chỉ được hiển thị cục bộ để người dùng có thể xác nhận tài khoản mà họ đang chia sẻ.

00:05:04.000 --> 00:05:07.000
Tiếp theo, đặt tùy chọn chia sẻ mặc định.

00:05:07.000 --> 00:05:12.000
Trước khi tôi chỉ cho bạn cách làm điều đó, trước tiên tôi sẽ mô tả cách các tùy chọn hoạt động.

00:05:12.000 --> 00:05:18.000
Tùy chọn chia sẻ là cài đặt mà người dùng định cấu hình khi cộng tác trong Tin nhắn hoặc bảng chia sẻ.

00:05:18.000 --> 00:05:23.000
Các tùy chọn do người dùng chọn được cung cấp cho bạn trước khi tin nhắn được gửi đi.

00:05:23.000 --> 00:05:32.000
Các tùy chọn chia sẻ có thể bao gồm các cài đặt như ai có thể chỉnh sửa cộng tác hoặc ai nên có quyền truy cập vào nội dung.

00:05:32.000 --> 00:05:38.000
Bạn sử dụng một vài lớp để xác định các tùy chọn, bắt đầu với SWCollaborationOption.

00:05:38.000 --> 00:05:46.000
Tùy thuộc vào cách chúng được nhóm lại, các tùy chọn đại diện cho các công tắc riêng lẻ hoặc các giá trị loại trừ lẫn nhau cho một cài đặt.

00:05:46.000 --> 00:05:53.000
Các tùy chọn có tiêu đề và số nhận dạng, và chúng được chọn hoặc không được chọn.

00:05:53.000 --> 00:06:04.000
Có hai lớp đại diện cho một nhóm các tùy chọn: SWCollaborationOptionsGroup và SWCollaborationOptions PickerGroup.

00:06:04.000 --> 00:06:16.000
Bạn sử dụng SWCollaborationOptionsGroup để đại diện cho một tập hợp các công tắc, trong khi SWCollaborationOptions PickerGroup đại diện cho các giá trị loại trừ lẫn nhau cho một cài đặt.

00:06:16.000 --> 00:06:25.000
Cuối cùng, SWCollaborationShareOptions xác định toàn bộ tập hợp các nhóm tùy chọn, được đặt trên thuộc tính defaultShareOptions của siêu dữ liệu.

00:06:25.000 --> 00:06:29.000
Bạn cũng có thể cung cấp một chuỗi tóm tắt để mô tả các tùy chọn.

00:06:29.000 --> 00:06:34.000
Bây giờ tôi đã mô tả các lớp tùy chọn, đây là một ví dụ cho thấy cách sử dụng chúng.

00:06:34.000 --> 00:06:38.000
Mã này xác định hai nhóm tùy chọn.

00:06:38.000 --> 00:06:43.000
Nhóm đầu tiên được khởi tạo với một mã định danh và hai tùy chọn khả thi.

00:06:43.000 --> 00:06:50.000
Mã định danh là một chuỗi tùy ý mà sau này bạn sử dụng để xác định tùy chọn nào đã được người dùng chọn.

00:06:50.000 --> 00:06:54.000
Vì đây là một nhóm chọn, các tùy chọn loại trừ lẫn nhau.

00:06:54.000 --> 00:07:00.000
Nhóm này đại diện cho cài đặt quyền cho nội dung: readwrite hoặc readonly.

00:07:00.000 --> 00:07:06.000
Sau đó, tùy chọn đầu tiên trong nhóm đó được chọn theo mặc định.

00:07:06.000 --> 00:07:11.000
Và tiêu đề được đặt thành một chuỗi mô tả nhóm này.

00:07:11.000 --> 00:07:16.000
Nhóm tùy chọn thứ hai được khởi tạo theo cùng một cách và cũng chứa hai tùy chọn.

00:07:16.000 --> 00:07:23.000
Nhưng vì đây là một nhóm tùy chọn chung, người dùng sẽ có thể định cấu hình xem có cho phép đề cập và nhận xét một cách độc lập hay không.

00:07:23.000 --> 00:07:34.000
Cuối cùng, hai nhóm tùy chọn được sử dụng để khởi tạo một phiên bản của SWCollaborationShareOptions, sau đó được đặt trên siêu dữ liệu.

00:07:34.000 --> 00:07:42.000
Tiếp theo, siêu dữ liệu được cung cấp cho bảng chia sẻ hoặc kéo và thả, tùy thuộc vào cách người dùng quyết định chia sẻ nội dung.

00:07:42.000 --> 00:07:49.000
Nếu ứng dụng của bạn sử dụng SwiftUI, SWCollaborationMetadata tương thích với ShareLink API mới.

00:07:49.000 --> 00:07:58.000
Xem "Gặp gỡ có thể chuyển nhượng" và "Có gì mới trong SwiftUI" để tìm hiểu thêm về có thể chuyển nhượng và ShareLink.

00:07:58.000 --> 00:08:05.000
Đây là cách dễ dàng để hỗ trợ cộng tác trên một đại diện proxy trong SwiftUI!

00:08:05.000 --> 00:08:15.000
Từ bên trong một đối tượng mô hình có thể chuyển nhượng, thiết lập ProxyRepresentation để trả về một phiên bản siêu dữ liệu cộng tác.

00:08:15.000 --> 00:08:22.000
Sau đó, từ chế độ xem, khởi tạo ShareLink với đối tượng mô hình đó.

00:08:22.000 --> 00:08:28.000
Đối với các ứng dụng UIKit và AppKit, bạn sử dụng NSItemProvider để hỗ trợ chia sẻ.

00:08:28.000 --> 00:08:33.000
Và SWCollaborationMetadata phù hợp với NSItemProviderReading và writing.

00:08:33.000 --> 00:08:39.000
Vì vậy, bạn chỉ cần đăng ký một phiên bản siêu dữ liệu với một nhà cung cấp mặt hàng, để hỗ trợ cộng tác.

00:08:39.000 --> 00:08:47.000
Bạn cũng nên đăng ký nhiều đại diện của nội dung để hỗ trợ chia sẻ qua càng nhiều kênh càng tốt.

00:08:47.000 --> 00:08:55.000
Ví dụ: Tin nhắn tự động cung cấp tùy chọn gửi nội dung dưới dạng bản sao nếu bạn cung cấp biểu diễn tệp.

00:08:55.000 --> 00:09:08.000
Bạn sẽ sử dụng NSItemProvider API với UIActivityViewController và UIDragItem trên iOS và iPadOS và NSSharingServicePicker trên macOS.

00:09:08.000 --> 00:09:12.000
Đây là cách thiết lập điều đó với bảng chia sẻ trên iOS.

00:09:12.000 --> 00:09:16.000
Tạo một phiên bản NSItemProvider.

00:09:16.000 --> 00:09:25.000
Đăng ký siêu dữ liệu cộng tác được tạo trong ví dụ trước, với khả năng hiển thị được đặt cho tất cả các quy trình trên hệ thống.

00:09:25.000 --> 00:09:36.000
Khởi tạo UIActivityItemsConfiguration với nhà cung cấp mục, sau đó khởi tạo UIActivityViewController với cấu hình đó.

00:09:36.000 --> 00:09:40.000
Và cuối cùng, trình bày bộ điều khiển chế độ xem.

00:09:40.000 --> 00:09:44.000
Nó cũng dễ dàng để hỗ trợ kéo và thả.

00:09:44.000 --> 00:09:58.000
Khởi tạo NSItemProvider và đăng ký siêu dữ liệu theo cùng một cách, sau đó tạo một UIDragItem với nhà cung cấp mục để sử dụng với các API kéo và thả.

00:09:58.000 --> 00:10:03.000
API tương tự trên macOS cho cửa sổ bật lên chia sẻ.

00:10:03.000 --> 00:10:06.000
Một lần nữa, thiết lập nhà cung cấp mặt hàng.

00:10:06.000 --> 00:10:11.000
Và lần này, hãy sử dụng nó để khởi tạo NSSharingServicePicker.

00:10:11.000 --> 00:10:17.000
Và sau đó hiển thị bộ chọn liên quan đến chế độ xem mục tiêu.

00:10:17.000 --> 00:10:22.000
Kéo và thả trên macOS sử dụng NSPasteboardItem thay vì NSItemProvider.

00:10:22.000 --> 00:10:29.000
Để hỗ trợ điều này, SharedWithYou xuất một phần mở rộng NSPasteboardItem.

00:10:29.000 --> 00:10:39.000
Sử dụng tiện ích mở rộng đó, đặt siêu dữ liệu cộng tác trực tiếp trên phiên bản NSPasteboardItem mới để hỗ trợ kéo và thả.

00:10:39.000 --> 00:10:45.000
Và đó là tất cả những gì bạn cần để bản nháp nội dung cộng tác của mình được dàn dựng trong Tin nhắn!

00:10:45.000 --> 00:10:52.000
Tiếp theo, khi người dùng nhấn vào nút gửi, hệ thống sẽ phối hợp với ứng dụng của bạn để thiết lập chia sẻ.

00:10:52.000 --> 00:10:57.000
Nó thực hiện điều này thông qua một lớp mới được gọi là SWCollaborationCoordinator.

00:10:57.000 --> 00:11:03.000
SWCollaborationCoordinator là một singleton, có nghĩa là có một ví dụ được chia sẻ toàn cầu.

00:11:03.000 --> 00:11:09.000
Phiên bản được chia sẻ đó điều phối sự hợp tác thông qua một đại biểu mà bạn xác định được gọi là actionHandler.

00:11:09.000 --> 00:11:15.000
Để đảm bảo ứng dụng của bạn luôn có sẵn để phối hợp cộng tác, nó sẽ được khởi chạy ở chế độ nền khi cần thiết.

00:11:15.000 --> 00:11:22.000
Vì vậy, bạn nên đăng ký đại diện ngay sau khi khởi chạy và xử lý các hành động ngay lập tức để tránh hết thời gian chờ.

00:11:22.000 --> 00:11:28.000
Đây là cách thiết lập điều phối viên cộng tác sau khi ứng dụng của bạn khởi chạy xong.

00:11:28.000 --> 00:11:33.000
Truy cập phiên bản điều phối viên singleton thông qua tài sản được chia sẻ.

00:11:33.000 --> 00:11:44.000
Sau đó, trong phương thức didFinishLaunchingWithOptions của đại diện ứng dụng, đặt thuộc tính actionHandler thành một đối tượng phù hợp với giao thức SWCollaborationActionHandler.

00:11:44.000 --> 00:11:49.000
Giao thức xử lý hành động sử dụng một lớp mới gọi là SWAction.

00:11:49.000 --> 00:11:53.000
SWActions đại diện cho công việc mà ứng dụng của bạn dự kiến sẽ thực hiện.

00:11:53.000 --> 00:11:59.000
Bạn hoàn thành các hành động để đánh dấu chúng là hoàn thành và thất bại nếu không.

00:11:59.000 --> 00:12:03.000
Hành động đầu tiên mà ứng dụng của bạn cần xử lý là hành động cộng tác bắt đầu.

00:12:03.000 --> 00:12:12.000
SWStartCollaborationAction chứa siêu dữ liệu cộng tác mà bạn đã thiết lập trước đó, được cập nhật với các tùy chọn chia sẻ đã chọn của người dùng.

00:12:12.000 --> 00:12:20.000
Khi bạn đã thực hiện thiết lập cần thiết, bạn hoàn thành hành động bắt đầu với liên kết chung và mã định danh độc lập với thiết bị cho sự cộng tác.

00:12:20.000 --> 00:12:26.000
Nếu bạn rõ ràng thất bại trong hành động bắt đầu, tin nhắn sẽ bị hủy.

00:12:26.000 --> 00:12:32.000
Đây là một triển khai để xử lý hành động bắt đầu bằng cách sử dụng một yêu cầu máy chủ ví dụ.

00:12:32.000 --> 00:12:40.000
Đầu tiên, truy xuất mã định danh cục bộ và các tùy chọn chia sẻ do người dùng chọn từ thuộc tính siêu dữ liệu của hành động.

00:12:40.000 --> 00:12:47.000
Thiết lập một yêu cầu máy chủ để chuẩn bị sự cộng tác bằng cách sử dụng mã định danh và các tùy chọn.

00:12:47.000 --> 00:12:50.000
Sau đó, gửi yêu cầu đến máy chủ.

00:12:50.000 --> 00:12:54.000
Ví dụ này sử dụng async await.

00:12:54.000 --> 00:13:01.000
Cuối cùng, hoàn thành hành động với liên kết chung và mã định danh độc lập với thiết bị từ phản hồi.

00:13:01.000 --> 00:13:05.000
Hoặc, nếu có lỗi, không thực hiện hành động hủy tin nhắn.

00:13:05.000 --> 00:13:13.000
Nếu hành động bắt đầu thành công, hệ thống sẽ gửi cho ứng dụng của bạn hành động thứ hai để cập nhật những người tham gia cộng tác.

00:13:13.000 --> 00:13:19.000
SWUpdateCollaboration ParticipantsAction chứa các danh tính mật mã cho những người tham gia.

00:13:19.000 --> 00:13:26.000
Các danh tính được lấy từ mã định danh cộng tác được thực hiện bởi hành động bắt đầu ở bước trước.

00:13:26.000 --> 00:13:30.000
Lưu trữ danh tính trên máy chủ của bạn được liên kết với nội dung.

00:13:30.000 --> 00:13:35.000
Bạn sẽ sử dụng dữ liệu này để xác minh quyền truy cập trên các thiết bị của người nhận.

00:13:35.000 --> 00:13:40.000
Cuối cùng, hoàn thành hành động này sẽ gửi liên kết chung trong Tin nhắn.

00:13:40.000 --> 00:13:45.000
Ví dụ này cho thấy cách xử lý hành động cập nhật của những người tham gia.

00:13:45.000 --> 00:13:49.000
Truy xuất mã định danh cộng tác từ siêu dữ liệu của hành động.

00:13:49.000 --> 00:13:53.000
Đây là số nhận dạng bạn đã hoàn thành trong khi xử lý hành động bắt đầu.

00:13:53.000 --> 00:14:01.000
Tiếp theo, truy xuất dữ liệu người tham gia để lưu trữ trên máy chủ của bạn bằng cách sử dụng thuộc tính addedIdentities của hành động.

00:14:01.000 --> 00:14:05.000
Mỗi danh tính có một thuộc tính Dữ liệu được gọi là hàm băm gốc.

00:14:05.000 --> 00:14:09.000
Đây là dữ liệu bạn nên lưu trữ trên máy chủ của mình để sử dụng sau này.

00:14:09.000 --> 00:14:16.000
Lance sẽ xem xét thêm chi tiết về tài sản này trong phần Xác minh quyền truy cập.

00:14:16.000 --> 00:14:23.000
Thiết lập một yêu cầu máy chủ khác, lần này để thêm những người tham gia vào cộng tác với mã định danh mục tiêu.

00:14:23.000 --> 00:14:29.000
Và giống như trước đây, hãy gửi yêu cầu đến máy chủ của bạn và thực hiện hoặc thất bại trong hành động.

00:14:29.000 --> 00:14:34.000
Lần này, phương pháp thực hiện không nhận bất kỳ tham số nào.

00:14:34.000 --> 00:14:42.000
Bây giờ bạn đã thiết lập cộng tác, ứng dụng của bạn có mọi thứ cần thiết để cấp quyền truy cập ngay lập tức cho người nhận tin nhắn.

00:14:42.000 --> 00:14:44.000
Tôi sẽ giao nó cho Lance để chỉ cho bạn cách làm điều đó!

00:14:44.000 --> 00:14:56.000
Lance: Cảm Ơn, Devin. Trong phần này, tôi sẽ chỉ ra cách cung cấp quyền truy cập ngay lập tức cho người nhận bằng cách sử dụng dữ liệu nhận dạng bạn đã lưu trữ trên máy chủ của mình ở bước trước.

00:14:56.000 --> 00:15:02.000
Thuộc tính rootHash trên SWPersonIdentity được sử dụng để thực hiện xác minh này.

00:15:02.000 --> 00:15:08.000
RootHash là một giá trị an toàn được sử dụng để xác định duy nhất người tham gia trên thiết bị của họ.

00:15:08.000 --> 00:15:14.000
Để thực hiện xác minh, bạn sẽ cần hiểu cách tính toán hàm băm gốc.

00:15:14.000 --> 00:15:16.000
Tôi sẽ đưa bạn qua điều đó ngay bây giờ.

00:15:16.000 --> 00:15:24.000
Khi một tin nhắn cộng tác được gửi đi, nó thực sự được gửi riêng lẻ đến từng thiết bị của một người.

00:15:24.000 --> 00:15:29.000
Tin nhắn xác định từng thiết bị bằng khóa công khai mật mã.

00:15:29.000 --> 00:15:39.000
Vì mục tiêu là chỉ cho phép truy cập trên bộ thiết bị này, hàm băm gốc có nguồn gốc từ tập hợp các khóa công khai được đăng ký cho mỗi người nhận.

00:15:39.000 --> 00:15:45.000
Hàm băm gốc là nút gốc của cấu trúc dữ liệu được gọi là cây Merkle.

00:15:45.000 --> 00:15:51.000
Cây Merkle là một cây nhị phân được xây dựng bằng cách thực hiện một chuỗi các thao tác băm.

00:15:51.000 --> 00:15:59.000
Để lấy được danh tính cho người dùng dựa trên các khóa công khai của họ, các khóa được sử dụng làm lá của cây này.

00:15:59.000 --> 00:16:07.000
Thuật toán băm được sử dụng trong cây Merkle đảm bảo rằng nút gốc chỉ có thể được tính toán từ bộ khóa đó.

00:16:07.000 --> 00:16:15.000
Trong ví dụ này, người dùng này có ba thiết bị và ba khóa công khai.

00:16:15.000 --> 00:16:24.000
Các khóa sẽ là duy nhất cho mỗi mã định danh cộng tác do ứng dụng của bạn cung cấp, sử dụng một quy trình gọi là đa dạng hóa khóa.

00:16:24.000 --> 00:16:31.000
Để ngăn chặn việc theo dõi số lượng thiết bị đã đăng ký cho người dùng, bộ này được đệm bằng các phím ngẫu nhiên lên đến một kích thước cố định.

00:16:31.000 --> 00:16:38.000
Các nút lá của cây được tạo ra bằng cách băm bộ chìa khóa đa dạng có đệm.

00:16:38.000 --> 00:16:44.000
Thuật toán SHA256 được sử dụng cho các hoạt động băm trong cây này.

00:16:44.000 --> 00:16:51.000
Sau đó, mỗi cặp nút lá được nối và sau đó được băm để lấy các nút mẹ của chúng.

00:16:51.000 --> 00:17:00.000
Quá trình này được lặp lại với các nút mẹ và lặp lại cho đến khi một nút gốc duy nhất vẫn còn.

00:17:00.000 --> 00:17:09.000
Đây là hàm băm gốc được sử dụng để thể hiện duy nhất danh tính của người nhận này trên các thiết bị của họ.

00:17:09.000 --> 00:17:17.000
Lưu ý rằng có thể tạo hàm băm gốc bằng cách sử dụng một tập hợp con của các nút từ một cây Merkle hoàn chỉnh.

00:17:17.000 --> 00:17:29.000
Hàm băm gốc trong cây này có thể được tái tạo chỉ bằng cách sử dụng các hàm băm H4, 7 và 11, cùng với khóa công khai đa dạng P3.

00:17:29.000 --> 00:17:35.000
Đầu tiên, băm khóa công khai để lấy nút lá bị thiếu H3.

00:17:35.000 --> 00:17:39.000
Sử dụng H3 và H4 để tạo H8.

00:17:39.000 --> 00:17:44.000
Sử dụng nút H7 đã cho với H8 để tạo H10.

00:17:44.000 --> 00:17:49.000
Và cuối cùng, H10 và H11 tạo ra hàm băm gốc.

00:17:49.000 --> 00:17:59.000
Điều quan trọng cần lưu ý là bạn có thể chứng minh khóa công khai P3 đã được sử dụng để tạo ra một hàm băm gốc nhất định mà không cần phải xây dựng lại toàn bộ cây.

00:17:59.000 --> 00:18:05.000
Tập hợp con các nút cần thiết để làm điều này được gọi là bằng chứng về sự bao gồm.

00:18:05.000 --> 00:18:10.000
Việc xác minh bắt đầu khi một liên kết chung được mở trong ứng dụng của bạn.

00:18:10.000 --> 00:18:15.000
Để làm điều này, trước tiên bạn cần kiểm tra xem liên kết có hợp tác hay không.

00:18:15.000 --> 00:18:22.000
SWCollaborationHighlight đại diện cho một liên kết hợp tác và được truy xuất từ SWHighlightCenter.

00:18:22.000 --> 00:18:28.000
Sử dụng điểm nổi bật của sự hợp tác đó để tạo ra bằng chứng về sự bao gồm.

00:18:28.000 --> 00:18:35.000
Để thể hiện bằng chứng bao gồm, hãy sử dụng một lớp gọi là SWPersonIdentityProof.

00:18:35.000 --> 00:18:43.000
Để thực hiện xác minh, trước tiên bạn sẽ tạo đối tượng này cùng với chữ ký mật mã để gửi đến máy chủ của bạn.

00:18:43.000 --> 00:18:48.000
Truy xuất bằng chứng bằng cách sử dụng phương thức getSignedIdentityProof trên SWHighlightCenter.

00:18:48.000 --> 00:18:57.000
Cần một SWCollaborationHighlight và một số dữ liệu tùy ý để được thiết bị ký.

00:18:57.000 --> 00:19:05.000
Sử dụng chữ ký để đảm bảo yêu cầu không thể được phát lại bởi một tác nhân xấu để có quyền truy cập vào sự hợp tác của bạn.

00:19:05.000 --> 00:19:13.000
Dữ liệu có thể là một thách thức mà bạn yêu cầu từ máy chủ của mình hoặc một nonce được tạo trên thiết bị.

00:19:13.000 --> 00:19:16.000
Ví dụ này sử dụng cách tiếp cận thử thách.

00:19:16.000 --> 00:19:22.000
URL được chuyển đến phương thức này trên UIApplicationDelegate của ứng dụng của bạn.

00:19:22.000 --> 00:19:28.000
URL này là liên kết chung được liên kết với sự hợp tác.

00:19:28.000 --> 00:19:36.000
URL được sử dụng để tìm nạp SWCollaborationHighlight được liên kết từ SWHighlightCenter.

00:19:36.000 --> 00:19:50.000
Tiếp theo, tôi sẽ yêu cầu thử thách từ máy chủ của mình và chuyển dữ liệu tôi nhận được trở lại phương thức getSignedIdentityProof trên SWHighlightCenter, cùng với phần nổi bật.

00:19:50.000 --> 00:19:53.000
Phương pháp này trả về một bằng chứng nhận dạng đã ký.

00:19:53.000 --> 00:19:58.000
Tôi sẽ thảo luận về những gì máy chủ của bạn nên làm để xác thực dữ liệu này sau này.

00:19:58.000 --> 00:20:03.000
Bây giờ tôi có thể gửi bằng chứng đã ký đến máy chủ của mình để xác minh.

00:20:03.000 --> 00:20:09.000
Cuối cùng, tôi cập nhật giao diện người dùng của mình với kết quả.

00:20:09.000 --> 00:20:16.000
Ứng dụng gửi bằng chứng đến máy chủ, cùng với khóa công khai và dữ liệu đã ký.

00:20:16.000 --> 00:20:27.000
Dữ liệu được ký bằng thuật toán chữ ký số đường cong elip trên đường cong elip P-256, sử dụng SHA256 làm hàm băm.

00:20:27.000 --> 00:20:32.000
Xác minh chữ ký trên dữ liệu bằng khóa công khai trong bằng chứng nhận dạng.

00:20:32.000 --> 00:20:38.000
Bạn có thể làm điều này với các thư viện mã hóa được sử dụng phổ biến nhất.

00:20:38.000 --> 00:20:46.000
Khi bạn đã xác minh chữ ký, bạn có thể tin tưởng rằng bằng chứng nhận dạng đã được gửi từ thiết bị được liên kết với khóa công khai đó.

00:20:46.000 --> 00:20:52.000
Tiếp theo, bạn sử dụng bằng chứng nhận dạng để tính toán lại hàm băm gốc.

00:20:52.000 --> 00:20:59.000
Đây là một ví dụ về những gì SWPersonIdentityProof sẽ chứa bằng cách sử dụng cây ví dụ mà chúng tôi đã xem trước đây.

00:20:59.000 --> 00:21:04.000
Sử dụng nó để tái tạo lại hàm băm gốc của cây Merkle.

00:21:04.000 --> 00:21:06.000
Khóa công khai là P3.

00:21:06.000 --> 00:21:12.000
Các hàm băm bao gồm là H4, 7 và 11.

00:21:12.000 --> 00:21:19.000
Chỉ mục khóa cục bộ là 2 cho biết vị trí của khóa công khai trong cây.

00:21:19.000 --> 00:21:26.000
Đây là một ví dụ triển khai tái tạo lại hàm băm gốc từ các thuộc tính trên bằng chứng.

00:21:26.000 --> 00:21:32.000
Một thuật toán đệ quy hoạt động tốt khi làm việc với các cấu trúc dữ liệu cây, vì vậy đó là những gì tôi đã làm ở đây.

00:21:32.000 --> 00:21:44.000
Khi gọi ban đầu, chuyển hàm băm của khóa công khai, tập hợp các hàm băm bao gồm và chỉ mục khóa công khai.

00:21:44.000 --> 00:21:49.000
Tiếp theo, hàm băm bao gồm đầu tiên được rút ra.

00:21:49.000 --> 00:21:56.000
Chỉ mục khóa công khai được kiểm tra để xem khóa ở bên trái hay bên phải của anh chị em của nó.

00:21:56.000 --> 00:22:03.000
Các hàm băm đã chọn được nối theo đúng thứ tự, và sau đó băm.

00:22:03.000 --> 00:22:14.000
Tiếp theo, nút tiêu thụ trong mảng inclusionHashes bị xóa và phần còn lại được chuyển đến một cuộc gọi đệ quy đến cùng một hàm này.

00:22:14.000 --> 00:22:20.000
Chỉ mục khóa công khai cũng được cập nhật để nó sẵn sàng cho nút tiếp theo trong cây.

00:22:20.000 --> 00:22:28.000
Với hàm đơn giản này, bạn có thể nhanh chóng tính toán hàm băm gốc cho bằng chứng nhận dạng.

00:22:28.000 --> 00:22:36.000
Máy chủ hiện có thể kiểm tra xem hàm băm gốc được tạo này có nằm trong danh sách băm gốc mà chủ sở hữu tài liệu được tải lên trong quá trình gửi hay không.

00:22:36.000 --> 00:22:42.000
Hàm băm có mặt trong danh sách các hàm băm đã biết, vì vậy máy chủ có thể cấp quyền truy cập vào tài liệu.

00:22:42.000 --> 00:22:46.000
Bây giờ bạn có thể tự tin cấp quyền truy cập vào tài liệu!

00:22:46.000 --> 00:22:55.000
Để tóm tắt lại các bước bạn sẽ làm theo để xác minh danh tính: trước tiên, hãy tra cứu điểm nổi bật của cộng tác cho nội dung của bạn trong khi xử lý liên kết chung của nó.

00:22:55.000 --> 00:22:59.000
Tiếp theo, ký một số dữ liệu và lấy bằng chứng đưa vào.

00:22:59.000 --> 00:23:04.000
Gửi dữ liệu đã ký và bằng chứng đến máy chủ của bạn.

00:23:04.000 --> 00:23:07.000
Xác minh chữ ký trên dữ liệu.

00:23:07.000 --> 00:23:11.000
Sử dụng bằng chứng bao gồm, tạo ra hàm băm gốc.

00:23:11.000 --> 00:23:19.000
Cuối cùng, so sánh hàm băm gốc với danh sách các danh tính đã biết được liên kết với nội dung đó.

00:23:19.000 --> 00:23:28.000
Bây giờ bạn đã biết tất cả về việc xác minh quyền truy cập vào các liên kết cộng tác của mình, tôi sẽ nói về cách phối hợp các thay đổi của người tham gia với Tin nhắn.

00:23:28.000 --> 00:23:40.000
Khi những người tham gia trong nhóm Tin nhắn thay đổi và nhóm đó đang cộng tác với nhau, người dùng có thể chọn truyền bá những thay đổi đó sang ứng dụng của bạn, ngay từ biểu ngữ trong chuỗi Tin nhắn.

00:23:40.000 --> 00:23:50.000
Trong trường hợp này, ứng dụng của bạn nhận được một Hành động Người tham gia SWUpdateCollaboration khác có chứa danh tính đã thêm và xóa.

00:23:50.000 --> 00:24:00.000
Bạn sẽ sử dụng cùng một mã bạn đã viết để xử lý hành động này khi thiết lập cộng tác, nhưng bạn cũng sẽ cần xử lý những người tham gia đã xóa.

00:24:00.000 --> 00:24:06.000
Để xóa, chỉ cần tra cứu bất kỳ tài khoản nào được liên kết với danh tính đã xóa và thu hồi quyền truy cập của họ.

00:24:06.000 --> 00:24:12.000
Nếu chưa có tài khoản nào được liên kết, chỉ cần xóa hàm băm gốc khỏi cơ sở dữ liệu của bạn.

00:24:12.000 --> 00:24:19.000
Đây là cách triển khai cho hành động cập nhật của những người tham gia mà Devin đã xem xét trước đó.

00:24:19.000 --> 00:24:28.000
Ví dụ này sử dụng thuộc tính danh tính đã xóa trên hành động và chuyển chúng đến một yêu cầu API xóa tương tự.

00:24:28.000 --> 00:24:38.000
Lưu ý rằng mã này chỉ hiển thị việc xử lý các danh tính đã xóa, nhưng việc triển khai hoàn chỉnh sẽ xử lý cả danh tính đã thêm và đã xóa.

00:24:38.000 --> 00:24:42.000
Và đó là tất cả những gì bạn cần để xử lý các thay đổi của người tham gia!

00:24:42.000 --> 00:24:50.000
Cuối cùng, khi các thay đổi được thực hiện đối với cộng tác, ứng dụng của bạn sẽ đăng thông báo về những thay đổi đó được hiển thị trực tiếp trong Tin nhắn.

00:24:50.000 --> 00:24:55.000
Có một vài loại thông báo được hỗ trợ mà tôi sẽ xem xét trong phần này.

00:24:55.000 --> 00:25:01.000
Thông báo được hiển thị dưới dạng biểu ngữ ngay trong cuộc trò chuyện nơi liên kết được chia sẻ.

00:25:01.000 --> 00:25:07.000
Biểu ngữ bao gồm mô tả về những gì đã thay đổi, cũng như ai đã thực hiện thay đổi.

00:25:07.000 --> 00:25:12.000
Trong cuộc trò chuyện này, Charlie đã chỉnh sửa tài liệu Công thức làm bánh.

00:25:12.000 --> 00:25:17.000
Nhấn vào nút hiển thị sẽ kết nối chúng ngay với nội dung.

00:25:17.000 --> 00:25:24.000
Để đại diện cho một thông báo, khung SharedWithYou có một giao thức có tên SWHighlightEvent.

00:25:24.000 --> 00:25:31.000
Các sự kiện nổi bật được khởi tạo với SWHighlights được truy xuất từ SWHighlightCenter API.

00:25:31.000 --> 00:25:36.000
Tin nhắn hỗ trợ một số loại sự kiện.

00:25:36.000 --> 00:25:54.000
Sự kiện thay đổi để cập nhật nội dung hoặc nhận xét, sự kiện thành viên khi người tham gia tham gia hoặc rời đi, sự kiện đề cập khi người dùng được đề cập trong cộng tác và sự kiện kiên trì khi nội dung bị di chuyển hoặc xóa.

00:25:54.000 --> 00:25:59.000
Đây là một ví dụ cho thấy cách đăng một sự kiện thay đổi để chỉnh sửa thành một cộng tác.

00:25:59.000 --> 00:26:06.000
Sử dụng API trung tâm tô sáng, truy xuất điểm nổi bật cộng tác cho mã định danh mục tiêu.

00:26:06.000 --> 00:26:17.000
Hãy nhớ rằng, mã định danh này là số nhận dạng bạn đã xác định trong quá trình bắt đầu cộng tác, vì vậy ứng dụng của bạn sẽ có sẵn mã này để sử dụng khi thay đổi nội dung được thực hiện.

00:26:17.000 --> 00:26:21.000
Tiếp theo, tạo một ví dụ sự kiện thay đổi nổi bật.

00:26:21.000 --> 00:26:30.000
Trình khởi tạo có một điểm nổi bật và một giá trị enum kích hoạt; trong trường hợp này, hãy đặt nó thành loại chỉnh sửa.

00:26:30.000 --> 00:26:36.000
Cuối cùng, một lần nữa sử dụng trung tâm nổi bật, đăng thông báo cho sự kiện đó.

00:26:36.000 --> 00:26:49.000
Tương tự, đối với các thay đổi thành viên, hãy đăng một sự kiện thành viên, lần này vượt qua loại kích hoạt Cộng tác viên đã thêm hoặc loại kích hoạt Cộng tác viên đã xóa.

00:26:49.000 --> 00:26:55.000
Tiếp theo, nếu ứng dụng của bạn hỗ trợ đề cập đến người dùng, bạn có thể đăng một sự kiện đề cập.

00:26:55.000 --> 00:27:00.000
Khởi tạo danh tính một người với hàm băm gốc của người dùng được đề cập.

00:27:00.000 --> 00:27:07.000
Nhớ lại rằng bạn đã liên kết danh tính một người với tài khoản người dùng trong ứng dụng của mình trong khi xác minh quyền truy cập.

00:27:07.000 --> 00:27:15.000
Sau đó, đăng sự kiện đề cập theo cách tương tự, lần này chuyển danh tính được đề cập làm tham số.

00:27:15.000 --> 00:27:21.000
Thông báo này sẽ chỉ được hiển thị trong Tin nhắn cho người dùng được đề cập.

00:27:21.000 --> 00:27:29.000
Cuối cùng, sử dụng loại sự kiện kiên trì khi nội dung được di chuyển, đổi tên hoặc xóa.

00:27:29.000 --> 00:27:37.000
Ở đây, loại kích hoạt được đổi tên được sử dụng, để biểu thị rằng người dùng đã thay đổi tên của nội dung.

00:27:37.000 --> 00:27:46.000
Và đó là cách ứng dụng của bạn có thể thông báo cho cộng tác viên và họ sẽ nhận được những cập nhật đó ngay trong Tin nhắn.

00:27:46.000 --> 00:27:52.000
Devin: Và với điều đó, bạn đã sẵn sàng tích hợp trải nghiệm cộng tác của ứng dụng với tin nhắn bằng cách làm theo một vài bước.

00:27:52.000 --> 00:28:06.000
Thiết lập nội dung của bạn để được chia sẻ cộng tác, xác minh mật mã quyền truy cập của người tham gia, theo dõi các thay đổi của người tham gia và đăng thông báo trong Tin nhắn để kết nối người dùng của bạn ngay với nội dung.

00:28:06.000 --> 00:28:15.000
Hãy chắc chắn xem video "Nâng cao trải nghiệm cộng tác với Tin nhắn" để tìm hiểu thêm về các yếu tố giao diện người dùng mới mà bạn có thể hiển thị cho sự cộng tác.

00:28:15.000 --> 00:28:18.000
Lance: Chúng tôi nóng lòng muốn cộng tác với các ứng dụng của bạn!

00:28:18.000 --> 00:28:20.000
Devin và Lance, đăng xuất bằng mật mã.

00:28:20.000 --> 00:28:22.000
Devin: Cảm ơn vì đã xem!

00:28:22.000 --> 23:59:59.000
♪

