WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:11.000
안녕, 내 이름은 이야.

00:00:11.000 --> 00:00:13.000
안녕하세요, 제 이름은 도미니크입니다.

00:00:13.000 --> 00:00:16.000
그리고 우리는 GPU 소프트웨어 엔지니어입니다.

00:00:16.000 --> 00:00:27.000
오늘, 도미니크와 저는 레이 트레이싱 애플리케이션의 성능을 극대화할 수 있도록 올해 메탈 레이 트레이싱 API에 추가한 성능 향상과 기능에 대해 이야기할 것입니다.

00:00:27.000 --> 00:00:33.000
레이 트레이싱 애플리케이션은 장면 주위를 튕기는 개별 광선을 시뮬레이션합니다.

00:00:33.000 --> 00:00:42.000
이것은 사실적인 반사, 그림자, 글로벌 조명 등을 생성하기 위해 게임과 오프라인 렌더링에 사용됩니다.

00:00:42.000 --> 00:00:47.000
이것은 많은 광선을 시뮬레이션해야 하므로, 성능은 이러한 응용 프로그램에 매우 중요합니다.

00:00:47.000 --> 00:00:54.000
다행히도, 메탈은 모든 Apple 장치에 최적화된 레이 트레이싱에 대한 지원이 내장되어 있다.

00:00:54.000 --> 00:00:57.000
금속에서 레이 트레이싱이 어떻게 작동하는지 간략하게 검토해 봅시다.

00:00:57.000 --> 00:01:05.000
메탈 레이 트레이싱 API는 컴퓨팅 또는 프래그먼트 함수와 같은 셰이더 기능 내에서 사용할 수 있습니다.

00:01:05.000 --> 00:01:09.000
우리는 장면으로 방출되는 광선을 생성하는 것으로 시작한다.

00:01:09.000 --> 00:01:18.000
다음으로, 우리는 인터섹터 객체를 만들고 그것을 사용하여 우리의 광선과 장면의 기하학 사이의 교차점을 확인합니다.

00:01:18.000 --> 00:01:24.000
조금 후에, 나는 교차로 검색 속도를 높이기 위해 올해 우리가 추가한 몇 가지 새로운 기능 중 일부를 설명할 것이다.

00:01:24.000 --> 00:01:32.000
이 과정은 가속 구조라고 불리는 특별한 데이터 구조에 의존하며, 이는 또한 장면의 기하학을 나타낸다.

00:01:32.000 --> 00:01:38.000
나는 또한 오늘 가속 구조에 초점을 맞춘 몇 가지 새로운 기능과 성능 개선에 대해 이야기할 것이다.

00:01:38.000 --> 00:01:45.000
인터섹터는 각 레이 히트의 원시를 설명하는 교차 결과 객체를 반환합니다.

00:01:45.000 --> 00:01:50.000
교차 결과는 출력 이미지에 쓸 색상을 생성하는 데 사용됩니다.

00:01:50.000 --> 00:01:55.000
그것은 또한 그 과정을 다시 거치는 추가적인 광선을 생산하는 데 사용될 수 있다.

00:01:55.000 --> 00:02:01.000
우리는 장면 주변에서 튀는 빛을 시뮬레이션하고 싶은 만큼 이 과정을 반복할 수 있다.

00:02:01.000 --> 00:02:09.000
메탈 레이 트레이싱 API의 기본 사항에 대해 더 알고 싶다면, 이전 WWDC 세션을 검토하는 것이 좋습니다.

00:02:09.000 --> 00:02:19.000
우리는 WWDC20에서 메탈 레이 트레이싱 API를 처음 도입했고, 작년에 모션 블러 지원을 포함한 새로운 기능을 도입했습니다.

00:02:19.000 --> 00:02:22.000
오늘, 나는 세 가지에 대해 이야기할 것이다.

00:02:22.000 --> 00:02:30.000
먼저, 애플리케이션에서 레이 트레이싱 성능을 향상시킬 수 있는 새로운 기능에 대해 알려드리겠습니다.

00:02:30.000 --> 00:02:38.000
다음으로, 저는 가속 구조 API에 추가한 개선 사항과 기능에 대해 이야기할 것입니다.

00:02:38.000 --> 00:02:43.000
마지막으로, 도미니크는 레이 트레이싱을 위한 GPU 도구의 개선에 대해 알려줄 것입니다.

00:02:43.000 --> 00:02:51.000
올해, 우리는 레이 트레이싱 성능을 개선하거나 코드를 단순화하기 위한 세 가지 새로운 기능을 추가했습니다.

00:02:51.000 --> 00:03:01.000
그것들은 원시 데이터, 교차 함수 테이블에서 버퍼를 검색하는 기능, 간접 명령 버퍼에서 레이 트레이싱을 지원합니다.

00:03:01.000 --> 00:03:04.000
원시적인 데이터부터 시작합시다.

00:03:04.000 --> 00:03:13.000
응용 프로그램은 일반적으로 정점 색상, 법선 및 텍스처 좌표와 같은 장면의 기본과 관련된 데이터를 가지고 있다.

00:03:13.000 --> 00:03:21.000
올해, 우리는 각 기본에 대한 소량의 데이터를 가속 구조에 직접 저장할 수 있는 기능을 추가했습니다.

00:03:21.000 --> 00:03:27.000
이 데이터는 더 적은 메모리 간접과 캐시 누락으로 액세스하여 성능을 향상시킬 수 있습니다.

00:03:27.000 --> 00:03:37.000
이것은 또한 일반적으로 프리미티브와 관련된 데이터를 찾는 데 필요한 복잡한 보조 데이터 구조를 저장할 필요성을 줄여줍니다.

00:03:37.000 --> 00:03:39.000
예를 들어 봅시다.

00:03:39.000 --> 00:03:47.000
알파 테스트는 삼각형 수를 늘리지 않고 투명한 기하학에 복잡성을 추가하는 데 사용되는 기술이다.

00:03:47.000 --> 00:03:56.000
이 기술에서, 삼각형에 매핑된 텍스처의 알파 채널은 광선이 삼각형에 부딪혀야 하는지 아니면 더 계속되어야 하는지 결정하는 데 사용된다.

00:03:56.000 --> 00:04:04.000
이를 달성하기 위해, 삼각형이 광선에 부딪힐 때 사용자 지정 교차 함수를 호출하도록 인터섹터를 구성해야 합니다.

00:04:04.000 --> 00:04:13.000
궁극적인 목표는 삼각형과 관련된 텍스처에서 샘플링하고 알파 값이 광선이 원시를 통해 계속될 수 있는지 테스트하는 것이다.

00:04:13.000 --> 00:04:20.000
거기에 가려면, 두 가지 정보가 필요합니다: 텍스처 객체와 UV 좌표.

00:04:20.000 --> 00:04:30.000
알파 테스트의 일반적인 구현에서, 이 정보를 얻으려면 금속 장치 메모리의 여러 중간 버퍼에 액세스해야 합니다.

00:04:30.000 --> 00:04:37.000
먼저, 당신은 원시와 관련된 질감을 일종의 재료 구조에 저장할 것입니다.

00:04:37.000 --> 00:04:41.000
몇몇 재료가 완충액에 포장될 것이다.

00:04:41.000 --> 00:04:48.000
꽤 크고 많은 원시인이 있을 수 있기 때문에 모든 원시인을 위한 재료 구조를 저장하는 것은 비실용적일 것이다.

00:04:48.000 --> 00:04:56.000
대신, 각 기본에 대한 재료 ID만 버퍼에 저장하고 재료를 찾는 데 사용하고 싶을 것입니다.

00:04:56.000 --> 00:05:04.000
다음으로, UV를 계산하려면, 다른 버퍼에서 각 정점에 대한 UV를 로드하고 보간해야 합니다.

00:05:04.000 --> 00:05:07.000
마지막으로, 인스턴스화된 지오메트리를 사용하고 있다고 가정해 봅시다.

00:05:07.000 --> 00:05:12.000
각 인스턴스가 자체 재료와 UV 매핑을 갖기를 원할 수도 있습니다.

00:05:12.000 --> 00:05:22.000
그것을 지원하기 위해, 인스턴스 데이터 버퍼에 UV 및 Material ID 버퍼에 대한 포인터를 저장하여 기능에 또 다른 수준의 간접을 추가합니다.

00:05:22.000 --> 00:05:31.000
이 접근 방식은 상당히 복잡한 버퍼 설정을 유지해야 하며 필요한 데이터에 접근하기 위해 많은 간접 계층을 포함합니다.

00:05:31.000 --> 00:05:37.000
이것은 또한 성능에 부정적인 영향을 미칠 수 있는 캐시 실패로 이어질 수 있다.

00:05:37.000 --> 00:05:40.000
이 다이어그램을 구현하는 데 필요한 코드를 살펴봅시다.

00:05:40.000 --> 00:05:46.000
그런 다음 원시 데이터를 사용하여 단계별로 단순화할 수 있는 방법을 보여드리겠습니다.

00:05:46.000 --> 00:05:50.000
이것은 알파 테스트 교차 함수의 원래 구현이다.

00:05:50.000 --> 00:05:54.000
이 함수는 광선이 알파 테스트 삼각형에 부딪힐 때 호출됩니다.

00:05:54.000 --> 00:05:58.000
이 기능은 메모리에서 인스턴스 데이터를 로드하는 것으로 시작됩니다.

00:05:58.000 --> 00:06:04.000
이것은 인스턴스에서 사용하는 UV 및 재료 버퍼에 대한 포인터를 포함하는 버퍼입니다.

00:06:04.000 --> 00:06:10.000
다음으로, 이 함수는 UV 버퍼에서 UV 좌표를 로드하고 보간합니다.

00:06:10.000 --> 00:06:12.000
이것은 또 다른 메모리 로드이다.

00:06:12.000 --> 00:06:16.000
그런 다음, 함수는 다른 버퍼에서 재료 인덱스를 로드합니다.

00:06:16.000 --> 00:06:20.000
그리고 마지막으로, 그 기능은 재료를 로드하고 해당 질감을 샘플링한다.

00:06:20.000 --> 00:06:26.000
이 시점에서, 그 함수는 필요한 알파 값을 가지고 있으며 임계값과 비교할 수 있다.

00:06:26.000 --> 00:06:33.000
이제, 이 코드를 단순화하고 원시 데이터를 사용하여 성능을 향상시킬 수 있는 방법을 보여드리겠습니다.

00:06:33.000 --> 00:06:45.000
여러 계층의 간접적인 복잡한 버퍼 설정을 사용하는 대신, 교차 함수가 각 프리미티브에 필요한 데이터만 가속 구조에 직접 저장할 수 있습니다.

00:06:45.000 --> 00:06:51.000
이 예에서는 각 프리미티브의 텍스처와 UV 좌표를 포함하는 구조체를 만들 수 있습니다.

00:06:51.000 --> 00:07:00.000
가속 구조를 구축할 때 이 데이터를 제공하고 교차 함수는 광선이 원시에 부딪힐 때 그 데이터에 대한 포인터를 받기만 하면 됩니다.

00:07:00.000 --> 00:07:07.000
원시 데이터에 원하는 것은 무엇이든 저장할 수 있지만, 크기를 작게 유지하면 최상의 성능을 달성하는 데 도움이 될 것입니다.

00:07:07.000 --> 00:07:10.000
나는 교차 함수에 대한 입력으로 시작할 것이다.

00:07:10.000 --> 00:07:19.000
그들 모두에 접근할 수 있는 것은 구현과 관련하여 많은 유연성을 제공하지만, GPU의 레지스터 사용량을 증가시킬 수도 있습니다.

00:07:19.000 --> 00:07:26.000
원시 데이터를 사용하면 모든 버퍼 대신 원시 데이터 포인터에 액세스하기만 하면 됩니다.

00:07:26.000 --> 00:07:30.000
이것은 가속 구조에 직접 저장하는 데이터입니다.

00:07:30.000 --> 00:07:36.000
이 경우, 각 프리미티브는 모든 정점에 대해 자체 텍스처 객체와 UV를 가지고 있다.

00:07:36.000 --> 00:07:41.000
다음은 글로벌 재료 버퍼와 인스턴스 데이터 버퍼의 부하입니다.

00:07:41.000 --> 00:07:43.000
넌 둘 다 필요하지 않을 거야.

00:07:43.000 --> 00:07:47.000
대신, 원시 데이터 포인터에서 하나의 로드를 할 수 있습니다.

00:07:47.000 --> 00:07:51.000
이것은 이 기능에 필요한 유일한 장치 메모리 액세스입니다.

00:07:51.000 --> 00:07:52.000
다음은 자외선이다.

00:07:52.000 --> 00:08:01.000
인스턴스 데이터에서 검색된 포인터를 역참조하는 대신, 원시 데이터 구조에 포함된 데이터에 간단히 액세스할 수 있습니다.

00:08:01.000 --> 00:08:07.000
코드의 변화는 미묘하지만, 추가 메모리 부하가 포함되지 않기 때문에 성능에 중요하다.

00:08:07.000 --> 00:08:10.000
마지막으로, 물질적 특성이 있다.

00:08:10.000 --> 00:08:18.000
필요한 재료의 유일한 부분은 텍스처이기 때문에, 원시 데이터 구조에서 원시의 텍스처를 직접 인코딩할 수 있습니다.

00:08:18.000 --> 00:08:22.000
이것은 당신이 더 이상 재료 및 재료 인덱스 버퍼에 접근할 필요가 없다는 것을 의미합니다.

00:08:22.000 --> 00:08:28.000
추가 메모리 역참조 비용을 지불하지 않고도 텍스처를 직접 사용할 수 있습니다.

00:08:28.000 --> 00:08:33.000
이것은 원시 데이터를 사용할 때 교차 코드가 얼마나 간단할 수 있는지입니다.

00:08:33.000 --> 00:08:39.000
모든 값비싼 메모리 액세스는 기본 데이터 포인터에서 단 하나의 로드로 대체됩니다.

00:08:39.000 --> 00:08:44.000
게다가, 그 코드는 훨씬 간단하고 따르기 쉽다.

00:08:44.000 --> 00:08:49.000
다음으로, 가속 구조에 원시 데이터를 저장하는 방법을 보여드리겠습니다.

00:08:49.000 --> 00:08:53.000
교차로 함수에서 접근하기 전에 이것을 해야 할 것이다.

00:08:53.000 --> 00:08:57.000
가속 구조 기하학 설명자에서 몇 개의 필드를 설정해야 합니다.

00:08:57.000 --> 00:09:01.000
먼저, 모든 데이터가 저장되는 금속 버퍼를 설정하세요.

00:09:01.000 --> 00:09:05.000
다음으로, 각 프리미티브에 대해 저장될 데이터의 크기를 지정하십시오.

00:09:05.000 --> 00:09:13.000
데이터가 버퍼에 단단히 포장되지 않거나 버퍼의 시작 부분에서 시작되지 않는 경우, 보폭과 오프셋을 지정할 수도 있습니다.

00:09:13.000 --> 00:09:17.000
그렇지 않으면, 이 값들은 기본값이 0이므로 설정할 필요가 없습니다.

00:09:17.000 --> 00:09:21.000
당신은 이미 교차 함수에서 원시 데이터를 어떻게 사용할 수 있는지 보았습니다.

00:09:21.000 --> 00:09:24.000
그것은 단순히 포인터로 기능으로 전달된다.

00:09:24.000 --> 00:09:28.000
하지만 그게 전부는 아닙니다. 필요한 곳이면 어디든 이 데이터에 접근할 수 있습니다.

00:09:28.000 --> 00:09:32.000
그것은 인터섹터에 의해 반환된 최종 교차 결과를 포함한다.

00:09:32.000 --> 00:09:39.000
그리고 교차점 쿼리를 사용하는 경우, 원시 데이터는 후보와 커밋된 교차점 모두에서 사용할 수 있습니다.

00:09:39.000 --> 00:09:45.000
이것은 교차로 테스트 외에도 셰이딩을 위해 원시 데이터를 사용할 수 있다는 것을 의미합니다.

00:09:45.000 --> 00:09:54.000
원시 데이터는 메모리 액세스와 간접의 수를 줄임으로써 교차 코드와 셰이딩 코드 모두의 성능을 향상시킬 수 있습니다.

00:09:54.000 --> 00:10:03.000
사실, 우리는 우리 자신의 테스트 응용 프로그램 중 하나에서 원시 데이터를 사용하면 10%에서 16%의 성능이 향상된다는 것을 발견했습니다.

00:10:03.000 --> 00:10:11.000
우리는 당신이 그것을 시도하고 성능과 코드 품질에서 어떤 종류의 개선을 얻을 수 있는지 보기를 기다릴 수 없습니다.

00:10:11.000 --> 00:10:18.000
올해, 우리는 또한 레이 트레이싱 커널을 단순화할 수 있도록 금속 셰이딩 언어에 또 다른 편의 기능을 추가했습니다.

00:10:18.000 --> 00:10:26.000
애플리케이션은 종종 교차점 기능과 주요 레이 트레이싱 커널 모두에 동일한 바인딩 세트를 전달한다.

00:10:26.000 --> 00:10:32.000
예를 들어, 우리의 레이 트레이싱 샘플 코드는 교차 함수를 사용하여 구체를 렌더링합니다.

00:10:32.000 --> 00:10:37.000
이 교차 함수는 각 구에 대한 정보를 포함하는 리소스 버퍼에 액세스합니다.

00:10:37.000 --> 00:10:43.000
이 버퍼를 교차 함수에 전달하기 위해, 앱은 버퍼를 교차 함수 테이블에 바인딩합니다.

00:10:43.000 --> 00:10:50.000
그러나, 메인 레이 트레이싱 커널은 또한 리소스 버퍼에 대한 액세스가 필요하므로, 앱은 버퍼도 바인딩합니다.

00:10:50.000 --> 00:10:57.000
올해 메탈 셰이딩 언어를 사용하면 교차 함수 테이블에 바인딩된 버퍼에 액세스할 수 있습니다.

00:10:57.000 --> 00:11:05.000
이 새로운 기능을 사용하면 커널에 대한 버퍼를 바인딩하는 노력을 절약할 수 있으며, 대신 교차 함수 테이블에서 직접 액세스할 수 있습니다.

00:11:05.000 --> 00:11:11.000
교차점 함수 테이블에서 get_buffer 메소드를 호출하여 포인터 유형을 제공하여 이 작업을 수행할 수 있습니다.

00:11:11.000 --> 00:11:15.000
기능 유형별로 보이는 기능 테이블에 액세스할 수도 있습니다.

00:11:15.000 --> 00:11:24.000
간접 명령 버퍼를 사용하면 GPU에서 GPU 작업을 독립적으로 인코딩하고 GPU 기반 파이프라인의 기본 요소를 나타낼 수 있습니다.

00:11:24.000 --> 00:11:33.000
간접 명령 버퍼와 GPU 기반 렌더링에 대해 자세히 알아보려면, WWDC 2019의 "Metal을 사용한 현대 렌더링" 세션을 검토하는 것이 좋습니다.

00:11:33.000 --> 00:11:37.000
간접 명령 버퍼에서 레이 트레이싱 지원을 활성화하는 것은 쉽다.

00:11:37.000 --> 00:11:42.000
설명자에 supportRayTracing 플래그를 설정하기만 하면 됩니다.

00:11:42.000 --> 00:11:50.000
간접 명령 버퍼는 그래픽과 컴퓨팅 기능을 파견하므로 평소와 같이 해당 기능에서 레이 트레이싱을 사용할 수 있습니다.

00:11:50.000 --> 00:11:58.000
그것은 애플리케이션에서 레이 트레이싱 성능을 개선할 수 있도록 올해 추가한 모든 새로운 기능의 개요입니다.

00:11:58.000 --> 00:12:01.000
다음으로, 가속 구조에 대해 이야기해 봅시다.

00:12:01.000 --> 00:12:08.000
우리는 몇 가지 성능 개선을 구현하고 가속 구조 구축에 중점을 둔 기능을 추가했습니다.

00:12:08.000 --> 00:12:10.000
그들이 무엇을 위해 사용되는지 요약해 봅시다.

00:12:10.000 --> 00:12:15.000
가속 구조는 레이 트레이싱 프로세스를 가속화하는 데이터 구조이다.

00:12:15.000 --> 00:12:23.000
그들은 공간을 재귀적으로 분할하여 우리가 어떤 삼각형이 광선과 교차할 가능성이 있는지 빠르게 찾을 수 있도록 한다.

00:12:23.000 --> 00:12:31.000
복잡한 장면을 지원하기 위해, 메탈은 두 가지 유형의 가속 구조를 지원합니다: 원시 및 인스턴스 가속 구조.

00:12:31.000 --> 00:12:36.000
개별 기하학 조각은 원시 가속 구조를 사용하여 표현된다.

00:12:36.000 --> 00:12:44.000
그것들은 비행기나 큐브와 같은 단순한 것일 수도 있고, 구체나 삼각형 메쉬와 같은 더 복잡한 것일 수도 있다.

00:12:44.000 --> 00:12:48.000
인스턴스 가속 구조를 사용하여 더 복잡한 장면을 만들 수 있습니다.

00:12:48.000 --> 00:12:53.000
인스턴스 가속 구조는 원시 가속 구조의 복사본을 만든다.

00:12:53.000 --> 00:12:58.000
먼저, 장면의 각 개체에 대한 변환 행렬을 정의하세요.

00:12:58.000 --> 00:13:05.000
그런 다음, 변환 행렬과 원시 가속 구조의 배열을 사용하여 인스턴스 가속 구조를 구축하십시오.

00:13:05.000 --> 00:13:09.000
그것이 가속 구조를 사용하여 정적 장면을 만들 수 있는 방법입니다.

00:13:09.000 --> 00:13:16.000
다음으로, 게임과 같은 동적 애플리케이션이 가속 구조를 어떻게 사용하는지 봅시다.

00:13:16.000 --> 00:13:23.000
처음부터 시작합시다: 게임을 처음 시작하거나 새로운 레벨을 로드할 때 해야 할 몇 가지 작업이 있습니다.

00:13:23.000 --> 00:13:27.000
여기에는 모델과 텍스처 로딩과 같은 일반적인 작업이 포함됩니다.

00:13:27.000 --> 00:13:34.000
레이 트레이싱을 사용하면 사용될 모든 모델에 대한 원시 가속 구조를 구축해야 합니다.

00:13:34.000 --> 00:13:42.000
메인 렌더링 루프에서 시간을 절약하기 위해 로드 시간에 가능한 한 많은 원시 가속 구조를 구축하는 것이 좋습니다.

00:13:42.000 --> 00:13:48.000
인스턴스 가속 구조를 사용하여 필요에 따라 장면에서 이러한 개체를 추가하거나 제거할 수 있습니다.

00:13:48.000 --> 00:13:51.000
앱 로딩이 완료되면, 메인 루프에 들어갑니다.

00:13:51.000 --> 00:13:58.000
모든 프레임은 래스터화, 레이 트레이싱 및 후처리의 조합을 사용하여 장면을 렌더링합니다.

00:13:58.000 --> 00:14:05.000
그러나, 게임은 매우 역동적이기 때문에, 가속 구조 중 일부를 업데이트해야 할 것입니다.

00:14:05.000 --> 00:14:11.000
여기에는 일반적으로 피부가 벗겨진 캐릭터와 같은 소수의 변형 또는 애니메이션 모델을 다시 장착하는 것이 포함됩니다.

00:14:11.000 --> 00:14:18.000
기존 가속 구조를 재구축하는 것은 전체 재구축보다 훨씬 빠르므로, 이와 같은 경우에 사용하는 것이 좋습니다.

00:14:18.000 --> 00:14:22.000
당신은 또한 인스턴스 가속 구조를 완전히 재구성해야 합니다.

00:14:22.000 --> 00:14:30.000
이것은 물체가 마지막 프레임 이후 장면에서 추가되거나 제거되었을 수도 있고, 크게 움직였을 수도 있기 때문에 필요하다.

00:14:30.000 --> 00:14:39.000
이 경우 인스턴스 가속 구조가 하나만 있고 보통 최대 수천 개의 객체만 포함하기 때문에 완전한 재구축을 하는 것은 괜찮습니다.

00:14:39.000 --> 00:14:43.000
올해, 우리는 이 모든 경우에 대한 성과를 향상시켰다.

00:14:43.000 --> 00:14:49.000
첫째, 가속 구조 빌드는 이제 Apple Silicon에서 최대 2.3배 더 빠릅니다.

00:14:49.000 --> 00:14:54.000
둘째, 재장비는 또한 최대 38% 더 빠르다.

00:14:54.000 --> 00:14:58.000
이것은 로드 시간과 프레임당 오버헤드가 모두 줄어든다는 것을 의미한다.

00:14:58.000 --> 00:15:00.000
하지만 그건 훨씬 더 좋아져.

00:15:00.000 --> 00:15:05.000
일부 응용 프로그램은 수백 또는 수천 개의 작은 원시 가속 구조를 구축한다.

00:15:05.000 --> 00:15:13.000
이러한 작은 빌드는 GPU를 채우기에 충분한 작업을 수행하지 않아 오랜 기간 동안 GPU 사용률이 낮습니다.

00:15:13.000 --> 00:15:19.000
따라서, 여러 빌드는 이제 애플 실리콘에서 가능할 때마다 자동으로 병렬로 수행됩니다.

00:15:19.000 --> 00:15:24.000
이것은 병렬로 실행될 때 최대 2.8배 더 빠른 빌드를 초래한다.

00:15:24.000 --> 00:15:26.000
이것은 적재 시간을 더욱 줄여준다.

00:15:26.000 --> 00:15:37.000
그리고 이것은 빌드에만 적용되는 것이 아닙니다: 압축 및 재장착을 포함한 모든 가속 구조 작업에 적용되므로 프레임당 오버헤드도 줄어듭니다.

00:15:37.000 --> 00:15:43.000
이 최적화의 혜택을 받을 수 있도록 따라야 할 몇 가지 지침이 있습니다.

00:15:43.000 --> 00:15:46.000
다음은 가속 구조의 배열을 만드는 예입니다.

00:15:46.000 --> 00:15:53.000
그것들을 병렬로 구축하려면, 많은 빌드에 동일한 가속 구조 명령 인코더를 사용해야 합니다.

00:15:53.000 --> 00:15:58.000
또한, 동일한 스크래치 버퍼를 사용하는 빌드는 병렬로 실행할 수 없습니다.

00:15:58.000 --> 00:16:07.000
따라서, 당신은 각 빌드에 대해 동일한 스크래치 버퍼를 사용하는 대신 작은 스크래치 버퍼 풀을 반복하고 있는지 확인하고 싶을 것입니다.

00:16:07.000 --> 00:16:12.000
그것들은 우리가 가속 구조를 구축하기 위해 만든 모든 성능 개선이다.

00:16:12.000 --> 00:16:19.000
우리는 또한 가속 구조를 더 쉽고 효율적으로 만들기 위해 세 가지 새로운 기능을 추가했습니다.

00:16:19.000 --> 00:16:29.000
그것들은 추가 정점 형식, 변환 행렬 및 힙의 가속 구조 할당을 지원합니다.

00:16:29.000 --> 00:16:32.000
정점 형식부터 시작합시다.

00:16:32.000 --> 00:16:41.000
일반적인 성능 최적화는 정점 데이터에 양자화되거나 감소된 정밀도 형식을 사용하여 메모리 사용량을 줄이는 것입니다.

00:16:41.000 --> 00:16:46.000
올해, 당신은 다양한 버텍스 형식으로 가속 구조를 만들 수 있습니다.

00:16:46.000 --> 00:16:57.000
여기에는 반정밀 부동 소수점 형식, 평면 기하학을 위한 두 개의 구성 요소 정점 형식 및 모든 일반적인 정규화된 정수 형식이 포함됩니다.

00:16:57.000 --> 00:17:04.000
이전에, 가속 구조는 세 가지 구성 요소, 고정밀 부동 소수점 정점 데이터가 필요했다.

00:17:04.000 --> 00:17:10.000
이 예에서, 애플리케이션은 반정밀 정점 형식의 정점 데이터를 가지고 있다.

00:17:10.000 --> 00:17:16.000
이 데이터는 가속 구조를 구축하기 위해 압축을 풀고 임시 버퍼로 복사해야 합니다.

00:17:16.000 --> 00:17:27.000
새로운 정점 형식 기능을 통해 가속 구조 빌드는 이제 지원되는 형식의 정점 데이터를 소비할 수 있으므로 임시 복사본을 만들 필요가 없습니다.

00:17:27.000 --> 00:17:29.000
정점 형식을 설정하는 것이 더 간단할 수 없다.

00:17:29.000 --> 00:17:34.000
기하학 설명자에 속성을 설정하기만 하면 됩니다.

00:17:34.000 --> 00:17:37.000
다음으로, 변환 행렬에 대해 이야기해 봅시다.

00:17:37.000 --> 00:17:45.000
이 기능은 새로운 정점 형식을 보완하므로 가속 구조를 구축하기 전에 정점 데이터를 미리 변환할 수 있습니다.

00:17:45.000 --> 00:17:51.000
예를 들어, 그것들을 사용하여 정규화된 형식으로 저장된 복잡한 메쉬의 압축을 풀고 싶을 수도 있습니다.

00:17:51.000 --> 00:17:54.000
이 장면에서 레드 팬더 모델을 생각해 봅시다.

00:17:54.000 --> 00:18:04.000
압축된 형식 중 하나를 사용하도록 지오메트리를 정규화하려면, 메쉬를 가져와 경계를 계산한 다음 0에서 1 범위로 확장합니다.

00:18:04.000 --> 00:18:13.000
그런 다음 정규화된 정수 정점 형식 중 하나를 사용하여 메쉬를 저장하여 디스크와 메모리에서 차지하는 공간을 줄일 수 있습니다.

00:18:13.000 --> 00:18:21.000
런타임에, 당신은 각 정점을 최종 위치로 확장하고 오프셋할 매트릭스를 제공합니다.

00:18:21.000 --> 00:18:25.000
그 매트릭스를 적용하면 원래 모델을 검색합니다.

00:18:25.000 --> 00:18:30.000
이제 변환 매트릭스를 통과하는 가속 구조를 설정하는 방법을 살펴봅시다.

00:18:30.000 --> 00:18:33.000
변환 버퍼를 만드는 것으로 시작합니다.

00:18:33.000 --> 00:18:41.000
이를 수행하는 한 가지 방법은 스케일과 오프셋 변환 매트릭스를 포함하는 MTLPackedFloat4x3 객체를 만드는 것이다.

00:18:41.000 --> 00:18:46.000
그런 다음, 매트릭스를 고정할 수 있을 만큼 큰 금속 버퍼를 만드세요.

00:18:46.000 --> 00:18:49.000
그리고 마지막으로, 매트릭스를 버퍼에 복사하세요.

00:18:49.000 --> 00:18:52.000
다음으로, 가속 구조를 설정하세요.

00:18:52.000 --> 00:18:55.000
먼저, 삼각형 기하학 설명자를 만드세요.

00:18:55.000 --> 00:18:58.000
그런 다음, 변환 매트릭스 버퍼를 지정하세요.

00:18:58.000 --> 00:19:01.000
그리고 마지막으로 버퍼 오프셋.

00:19:01.000 --> 00:19:05.000
그것이 당신이 변환 매트릭스를 설정하기 위해 해야 할 전부입니다.

00:19:05.000 --> 00:19:12.000
이 매트릭스는 또한 레이 트레이싱 성능을 향상시키기 위해 간단한 가속 구조를 결합하는 데 사용될 수 있다.

00:19:12.000 --> 00:19:14.000
예시 장면을 보자.

00:19:14.000 --> 00:19:19.000
여기서, 상자와 구체는 모두 비교적 간단한 메쉬이다.

00:19:19.000 --> 00:19:25.000
이것은 현장 앞에서 이 그룹의 가속 구조를 최적화할 수 있는 기회를 제공한다.

00:19:25.000 --> 00:19:32.000
인스턴스 가속 구조에 초점을 맞추면, 광선이 부딪치는 각 인스턴스에 대한 오버헤드가 있습니다.

00:19:32.000 --> 00:19:38.000
광선을 변환한 다음 인스턴스에서 원시 가속 구조로 전환하는 데 비용이 든다.

00:19:38.000 --> 00:19:42.000
이것은 겹치는 경우에 더 자주 발생한다.

00:19:42.000 --> 00:19:50.000
인스턴스 수를 줄이기 위해, 상자와 구를 모두 포함하는 단일 원시 가속 구조를 생성할 수 있습니다.

00:19:50.000 --> 00:19:57.000
이렇게 하려면, 각 개체에 대한 기하학 설명자를 만들 수 있으며, 각각 고유한 변환 매트릭스를 사용할 수 있습니다.

00:19:57.000 --> 00:20:05.000
결과적인 원시 가속 구조는 인스턴스 가속 구조의 단일 인스턴스이며 상자와 구를 포함한다.

00:20:05.000 --> 00:20:09.000
이것은 더 나은 성능의 가속 구조를 초래해야 한다.

00:20:09.000 --> 00:20:12.000
이것을 코드로 설정하는 방법을 봅시다.

00:20:12.000 --> 00:20:16.000
당신은 구 기하학을 정의하는 설명자로 시작합니다.

00:20:16.000 --> 00:20:24.000
다음으로, 원시 가속 구조에 대해 평소와 같이 정점 버퍼, 인덱스 버퍼 및 기타 속성을 설정하십시오.

00:20:24.000 --> 00:20:32.000
차이점은, 당신은 또한 구의 복사본에 사용되는 변환 행렬을 포함하는 변환 버퍼를 지정한다는 것입니다.

00:20:32.000 --> 00:20:38.000
상자의 경우, 정점과 인덱스 버퍼를 공유하는 여러 지오메트리 설명자가 있습니다.

00:20:38.000 --> 00:20:42.000
각 복사본에 대해 다른 변환 버퍼를 지정하기만 하면 됩니다.

00:20:42.000 --> 00:20:49.000
마지막으로, 원시 가속 구조에 대한 설명자를 만들 때, 모든 기하학 설명자를 추가하세요.

00:20:49.000 --> 00:20:56.000
이것은 신원 변환으로 장면에 인스턴스할 수 있는 원시적인 가속 구조를 초래할 것이다.

00:20:56.000 --> 00:21:04.000
이 원시적인 가속 구조는 별도의 가속 구조보다 구축하는 데 시간이 덜 걸리고 교차하는 것이 더 빠를 것이다.

00:21:04.000 --> 00:21:11.000
마지막으로, 가속 구조의 힙 할당은 우리가 가장 많이 요청한 기능 중 하나였다.

00:21:11.000 --> 00:21:16.000
이 기능을 사용하면 이제 가속 구조 할당을 더 잘 제어할 수 있습니다.

00:21:16.000 --> 00:21:23.000
또한 할당 간에 힙 메모리를 재사용하여 값비싼 버퍼 할당을 피할 수 있습니다.

00:21:23.000 --> 00:21:31.000
힙은 또한 인스턴스 가속 구조를 사용할 때 useResource: 방법에 대한 호출을 줄임으로써 성능을 향상시키는 데 도움이 될 수 있습니다.

00:21:31.000 --> 00:21:39.000
예시 장면으로 돌아가서, 인스턴스 가속 구조는 원시 가속 구조를 간접적으로 참조한다.

00:21:39.000 --> 00:21:49.000
즉, 명령 인코더와 함께 인스턴스 가속 구조를 사용할 때마다 각 기본 가속 구조에 대해 useResource: 메서드를 호출해야 합니다.

00:21:49.000 --> 00:21:56.000
큰 장면의 경우, 인스턴스 가속 구조를 사용할 때마다 Resource를 사용하기 위해 수천 건의 호출이 필요할 수 있습니다.

00:21:56.000 --> 00:22:09.000
useResource: 호출이 너무 많다는 것을 알면, useResources를 호출할 수 있습니다: API 호출 수를 줄이기 위해, 여전히 가속 구조의 배열을 유지해야 하며 Metal은 여전히 배열을 통해 루프해야 합니다.

00:22:09.000 --> 00:22:14.000
대신, 같은 힙에서 이러한 모든 원시 가속 구조를 할당할 수 있습니다.

00:22:14.000 --> 00:22:24.000
인스턴스 가속 구조를 사용하고 싶을 때, useHeap: 메서드를 한 번 호출하여 모든 기본 가속 구조를 참조할 수 있습니다.

00:22:24.000 --> 00:22:32.000
우리는 단순히 useResource에 대한 호출을 UseHeap에 대한 단일 호출로 대체함으로써 하나의 응용 프로그램에서 작은 성능 개선을 보았습니다.

00:22:32.000 --> 00:22:35.000
힙에서 가속 구조를 어떻게 할당할 수 있는지 봅시다.

00:22:35.000 --> 00:22:43.000
가속 구조 설명자를 입력으로 사용하는 힙의 메서드를 호출하여 가속 구조를 직접 할당할 수 있습니다.

00:22:43.000 --> 00:22:52.000
설명자를 사용하여 할당하지 않는 경우, 금속 장치는 힙에서 가속 구조를 할당하기 위한 크기와 정렬 요구 사항을 결정합니다.

00:22:52.000 --> 00:22:59.000
설명자 또는 가속 구조 크기를 제공하여 금속 장치에서 이 정보를 얻을 수 있습니다.

00:22:59.000 --> 00:23:04.000
최종 크기가 결정되면, 힙에서 가속 구조를 할당할 수 있습니다.

00:23:04.000 --> 00:23:07.000
힙을 사용할 때 기억해야 할 몇 가지 사항이 있다.

00:23:07.000 --> 00:23:15.000
먼저, useHeap을 호출하는 것을 잊지 마세요: 레이 트레이싱 패스 기간 동안 힙의 모든 가속 구조를 상주하도록 하세요.

00:23:15.000 --> 00:23:20.000
둘째, 기본적으로, 메탈은 힙에서 할당한 자원을 추적하지 않습니다.

00:23:20.000 --> 00:23:27.000
자원 위험 추적을 선택하거나, 자신의 동기화를 수동으로 관리할 수 있습니다.

00:23:27.000 --> 00:23:35.000
MTLFences를 사용하여 명령 인코더와 MTLEvents를 동기화하여 명령 버퍼를 동기화할 수 있습니다.

00:23:35.000 --> 00:23:40.000
그것들은 올해 메탈 레이 트레이싱 API의 새로운 기능과 성능 개선이다.

00:23:40.000 --> 00:23:49.000
다음으로, 도미니크는 레이 트레이싱 애플리케이션을 개발할 때 생산성을 높일 수 있는 Xcode의 금속 도구 개선에 대해 이야기할 것입니다.

00:23:49.000 --> 00:23:50.000
도미니크: 고마워, 이.

00:23:50.000 --> 00:24:10.000
Xcode 14에는 금속 도구에 대한 많은 개선 사항이 있지만, 여기서는 금속 디버거를 시작으로 레이 트레이싱 애플리케이션을 개발할 때 특히 유용한 몇 가지를 강조하고 싶습니다. 가속 구조 뷰어, 셰이더 프로파일러 및 셰이더 디버거의 개선에 대해 이야기하겠습니다.

00:24:10.000 --> 00:24:16.000
그런 다음 런타임 셰이더 검증으로 반올림하겠습니다.

00:24:16.000 --> 00:24:21.000
먼저, 가속 구조 뷰어를 살펴봅시다.

00:24:21.000 --> 00:24:34.000
금속 디버거의 가속 구조 뷰어를 사용하면 가속 구조를 구성하는 모든 메쉬의 모든 형상과 인스턴스를 매우 자세하게 검사할 수 있습니다.

00:24:34.000 --> 00:24:46.000
Xcode 14는 이제 원시 또는 인스턴스 모션으로 가속 구조 디버깅과 원시 데이터에 대한 인스펙터로 원시를 시각화하기 위한 새로운 하이라이트 모드를 지원합니다.

00:24:46.000 --> 00:24:49.000
그들이 행동하는 걸 보자.

00:24:49.000 --> 00:24:58.000
모션과 함께 가속 구조를 사용하는 경우, 이제 다른 시점에서 가속 구조를 볼 수 있는 하단 막대에 스크러버가 있습니다.

00:24:58.000 --> 00:25:02.000
스크러버 오른쪽에는 "재생" 버튼이 있다.

00:25:02.000 --> 00:25:05.000
당신은 그것을 사용하여 애니메이션을 루프에서 앞뒤로 재생할 수 있습니다.

00:25:05.000 --> 00:25:11.000
이제 가속 구조에서 개별 원시인을 검사하는 방법을 보여드리겠습니다.

00:25:11.000 --> 00:25:15.000
이것은 새로운 원시 데이터 API를 사용하는 경우 특히 유용합니다.

00:25:15.000 --> 00:25:19.000
그래서 이것만을 위한 새로운 하이라이트 모드가 있다.

00:25:19.000 --> 00:25:25.000
원시 하이라이트 모드를 사용하면 모든 원시 데이터에 액세스할 수 있습니다...

00:25:25.000 --> 00:25:30.000
그리고 상세한 검사를 위해 특정 프리미티브를 선택할 수 있습니다.

00:25:30.000 --> 00:25:35.000
왼쪽 사이드바에서 데이터 행 옆에 있는 화살표를 찾을 수 있습니다.

00:25:35.000 --> 00:25:41.000
화살표를 클릭하면 기본에 대한 해당 데이터를 표시하는 팝오버가 표시됩니다.

00:25:41.000 --> 00:25:51.000
가속 구조 뷰어에 대한 이러한 추가는 각 기본까지 가속 구조를 구성하는 모든 구성 요소에 대한 완전한 액세스를 보장합니다.

00:25:51.000 --> 00:25:55.000
다음으로, 셰이더 프로파일러의 개선에 대해 이야기해 봅시다.

00:25:55.000 --> 00:26:13.000
셰이더 프로파일러는 셰이더의 성능에 대한 통찰력을 제공하여 파이프 라인당 실행 타이밍 비용을 제공하며, Apple GPU에서는 소스 수준에서 더 많은 세분성을 제공하여 명령 범주에 분산된 라인당 실행 비용을 보여줍니다.

00:26:13.000 --> 00:26:23.000
Xcode 14에서 프로파일링 GPU 캡처는 교차 기능, 가시 기능 및 동적 라이브러리를 지원하도록 업데이트되었습니다.

00:26:23.000 --> 00:26:28.000
여기에 교차 함수를 사용하는 레이 트레이싱 커널이 있습니다.

00:26:28.000 --> 00:26:33.000
이제 교차 함수 내에서 라인별 프로파일링 결과를 볼 수 있습니다.

00:26:33.000 --> 00:26:41.000
여기에는 비용에 기여하는 교육 범주의 분류가 포함됩니다.

00:26:41.000 --> 00:26:46.000
가시적 기능을 프로파일링하는 것은 같은 방식으로 작동한다.

00:26:46.000 --> 00:26:53.000
그리고 마찬가지로, 이제 연결된 동적 라이브러리의 셰이더 코드에 대한 자세한 프로파일링 정보를 사용할 수 있습니다.

00:26:53.000 --> 00:27:02.000
이러한 추가를 통해, 이제 각 코드 줄까지 파이프라인의 성능에 대한 전체 분석을 할 수 있습니다.

00:27:02.000 --> 00:27:04.000
셰이더 디버거로 이동합니다.

00:27:04.000 --> 00:27:10.000
셰이더 디버거는 셰이더 코드의 정확성을 디버깅하기 위한 독특하고 믿을 수 없을 정도로 생산적인 워크플로우를 제공합니다.

00:27:10.000 --> 00:27:17.000
셰이더 프로파일러와 마찬가지로, 우리는 또한 연결된 함수와 동적 라이브러리의 디버깅을 가능하게 하기 위해 지원을 확장했습니다.

00:27:17.000 --> 00:27:27.000
여기에는 가시 함수 테이블을 통해 전달된 연결된 가시 함수를 호출하는 레이 트레이싱 커널이 있습니다.

00:27:27.000 --> 00:27:37.000
이제 커널의 실행을 보이는 함수 코드까지 추적하여 코드가 예상대로 작동하는지 확인할 수 있습니다.

00:27:37.000 --> 00:27:41.000
다시 말하지만, 동적 라이브러리 디버깅에도 동일하게 적용됩니다.

00:27:41.000 --> 00:27:47.000
또한 파이프라인에 연결된 실행된 동적 라이브러리로 뛰어들 수 있습니다.

00:27:47.000 --> 00:27:55.000
이러한 추가를 통해, 이제 파이프라인의 연결된 기능과 라이브러리에서 셰이더 실행에 대한 완전한 그림을 얻을 수 있습니다.

00:27:55.000 --> 00:28:05.000
이제, 셰이더 디버거를 캡처하고 뛰어들기 전에, 런타임에 셰이더 유효성 검사를 활성화하는 것이 좋습니다.

00:28:05.000 --> 00:28:16.000
셰이더 유효성 검사는 GPU의 런타임 오류를 진단하고, 바운드 외부 메모리 액세스, 널 텍스처 읽기 등과 같은 문제를 포착하는 좋은 방법입니다.

00:28:16.000 --> 00:28:28.000
Xcode에서 셰이더 유효성 검사를 활성화하려면, "계획 편집" 대화 상자로 이동하여 "실행" 작업을 선택하고, "진단" 탭에서 "셰이더 유효성 검사" 확인란을 선택하기만 하면 됩니다.

00:28:28.000 --> 00:28:31.000
그리고 넌 갈 준비가 다 됐어.

00:28:31.000 --> 00:28:40.000
메탈 3에서, 우리는 그렇지 않으면 정의되지 않은 행동을 초래할 수 있는 문제를 빠르게 찾는 데 도움이 되는 스택 오버플로 감지를 추가했습니다.

00:28:40.000 --> 00:28:45.000
나는 금속 셰이더의 기능 스택과 스택 오버플로의 문제에 대해 빠르게 설명할 것이다.

00:28:45.000 --> 00:28:53.000
호출 스택은 메탈이 셰이더 함수에 사용되는 로컬 데이터의 값을 저장하는 장치 메모리의 영역입니다.

00:28:53.000 --> 00:29:01.000
호출된 함수가 컴파일 타임에 알려지지 않은 경우, 메탈은 스택에 필요한 메모리 양을 추정하는 데 당신의 도움이 필요합니다.

00:29:01.000 --> 00:29:08.000
컴파일 시간에 알 수 없는 함수에 대한 호출의 예는 레이 트레이싱 교차 함수일 수 있다.

00:29:08.000 --> 00:29:16.000
사용자 지정 교차 함수를 사용하는 경우, 공간을 할당하기 위해 최대 호출 스택 깊이를 1로 설정해야 합니다.

00:29:16.000 --> 00:29:19.000
이것은 기본값이므로, 더 이상 해야 할 일이 없습니다.

00:29:19.000 --> 00:29:28.000
그러나, 함수 테이블을 사용하여 Visible 함수를 호출하는 경우, 이것은 컴파일 시간에 알 수 없는 함수 호출의 또 다른 예입니다.

00:29:28.000 --> 00:29:36.000
이 예와 같이 교차 함수에서 그러한 호출을 수행한다면, 호출 스택은 두 단계 깊이가 될 것입니다.

00:29:36.000 --> 00:29:43.000
또 다른 예는 동적 라이브러리를 호출하고 함수 포인터를 사용하여 로컬 함수를 호출하는 것이다.

00:29:43.000 --> 00:29:51.000
이 예에서, 우리의 호출 스택에는 셰이더가 컴파일될 때 해결할 수 없는 다양한 유형의 함수에 대한 중첩된 호출이 있는 네 가지 레벨이 있습니다.

00:29:51.000 --> 00:29:59.000
적절한 양의 메모리를 할당하도록 Metal을 올바르게 구성하려면, 최대 호출 스택 깊이 4를 직접 지정해야 합니다.

00:29:59.000 --> 00:30:09.000
기억해야 할 중요한 점은 최대 호출 스택 깊이의 값이 프로그램에 비해 너무 낮게 설정되면 스택 오버플로가 발생하여 정의되지 않은 동작이 발생할 수 있다는 것입니다.

00:30:09.000 --> 00:30:20.000
하지만 셰이더 유효성 검사가 활성화된 상태에서 실행 중인 경우, 이러한 상황은 일찍 포착되며, 스택 오버플로가 발생한 위치에 대한 정보를 Xcode에서 볼 수 있습니다.

00:30:20.000 --> 00:30:26.000
그런 다음 셰이더 코드를 수정하거나 파이프라인 설명자에서 최대 호출 스택 깊이를 조정할 수 있습니다.

00:30:26.000 --> 00:30:37.000
Xcode 14의 금속 도구에 대한 이러한 모든 새로운 개선 사항은 레이 트레이싱 응용 프로그램의 성능과 정확성에 대한 훨씬 더 완전한 그림과 통찰력을 보장합니다.

00:30:37.000 --> 00:30:50.000
디버깅 및 프로파일링을 위한 금속 도구를 최대한 활용하는 방법에 대한 자세한 내용은 다른 세션을 확인하십시오. 이 세션은 애플리케이션의 금속 레이 트레이싱 성능을 극대화하는 것에 관한 것입니다.

00:30:50.000 --> 00:30:57.000
우리는 원시 데이터와 같은 새로운 기능을 사용하여 더 많은 성능을 짜내고 코드를 단순화하는 방법에 대해 이야기했습니다.

00:30:57.000 --> 00:31:05.000
우리는 또한 건물 가속 구조를 그 어느 때보다 빠르고 편리하게 만드는 최적화 기술과 기능을 설명했습니다.

00:31:05.000 --> 00:31:14.000
마지막으로, 우리는 개발 중에 더 깊은 통찰력을 제공할 Xcode 14의 금속 도구에 대한 모든 새로운 개선 사항을 다루었습니다.

00:31:14.000 --> 23:59:59.000
봐줘서 고마워.

