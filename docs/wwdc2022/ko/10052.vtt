WEBVTT

00:00:00.000 --> 00:00:03.000
♪ 기악 힙합 음악 ♪

00:00:03.000 --> 00:00:10.000
♪

00:00:10.000 --> 00:00:12.000
안녕하세요, 저는 닉입니다.

00:00:12.000 --> 00:00:15.000
그리고 저는 프랑크이고, 우리는 SwiftUI 엔지니어입니다.

00:00:15.000 --> 00:00:19.000
오늘, 우리는 "SwiftUI의 새로운 기능"을 다룰 것입니다.

00:00:19.000 --> 00:00:28.000
SwiftUI는 우리의 운영 체제와 함께 성장하고 있으며, 각각은 서로의 경계를 넓히고 있다.

00:00:28.000 --> 00:00:34.000
우리는 당신이 SwiftUI로 만드는 것에 계속 놀라고 기뻐하고 있습니다.

00:00:34.000 --> 00:00:38.000
우리는 지역 사회의 피드백의 모든 맛을 마음에 새기게 한다.

00:00:38.000 --> 00:00:44.000
그것이 우리가 올해 집중한 것을 공유하게 되어 특히 흥분되는 이유입니다.

00:00:44.000 --> 00:00:47.000
올해의 API로, 우리는 더 깊이 파고들었다.

00:00:47.000 --> 00:00:50.000
우리는 더 많은 맞춤 경험을 가능하게 했다.

00:00:50.000 --> 00:00:54.000
우리는 몇 가지 놀라운 새로운 그래픽 기술을 도입했습니다.

00:00:54.000 --> 00:01:01.000
우리는 새로운 SwiftUI 앱 구조 등을 설계했습니다.

00:01:01.000 --> 00:01:07.000
SwiftUI를 통해 우리는 플랫폼의 미래를 반영하는 디자인과 기능을 구축할 수 있었습니다.

00:01:07.000 --> 00:01:14.000
클래식 앱의 재설계부터 완전히 새로운 기능, 심층적인 시스템 통합에 이르기까지.

00:01:14.000 --> 00:01:20.000
애플 내에서의 이러한 포괄적인 채택은 SwiftUI의 진화를 더욱 촉진한다.

00:01:20.000 --> 00:01:29.000
이러한 새로운 디자인과 기능의 대부분은 SwiftUI가 Apple에서 앱을 작성하는 방식을 발전시켰기 때문에 가능합니다.

00:01:29.000 --> 00:01:44.000
오늘 우리는 이 API를 축하하고 있으며, SwiftUI의 생일도 축하하고 있습니다. Franck와 저는 파티 계획 위원회의 행운의 공동 의장입니다.

00:01:44.000 --> 00:01:49.000
우리가 파티를 위해 계획한 활동에 대해 말해줄게.

00:01:49.000 --> 00:02:00.000
모든 플랫폼에서 즐거운 데이터 시각화를 만들 수 있는 스위프트 차트라는 새로운 프레임워크를 소개합니다.

00:02:00.000 --> 00:02:09.000
나는 탐색과 새로운 창 기술을 위한 SwiftUI의 데이터 중심의 강력한 형식의 모델을 보여줄 것이다.

00:02:09.000 --> 00:02:16.000
프랑크는 새로운 컨트롤 제품군과 기존 컨트롤의 더 깊은 사용자 지정을 안내할 것입니다.

00:02:16.000 --> 00:02:24.000
그런 다음 그는 우리가 어떻게 Transferable 프로토콜로 SwiftUI의 우주에 우아하게 공유를 가져왔는지 보여줄 것입니다.

00:02:24.000 --> 00:02:31.000
마지막으로, 저는 기발한 새로운 그래픽 API와 고급 새로운 레이아웃 API로 마무리할 것입니다.

00:02:31.000 --> 00:02:35.000
스위프트 차트로 가자.

00:02:35.000 --> 00:02:42.000
스위프트 차트는 아름다운 국가 기반 차트를 구축하기 위한 선언적 프레임워크이다.

00:02:42.000 --> 00:02:57.000
SwiftUI를 훌륭하게 만드는 기본 설계 원칙과 데이터를 플로팅하는 과정은 세계적 수준의 데이터 시각화 프레임워크인 스위프트 차트를 만들기 위해 조화롭게 구성되었다.

00:02:57.000 --> 00:03:04.000
이것은 프랑크의 파티 작업 수를 플로팅한 막대 차트이며 파티가 시작하기 전에 완료해야 합니다.

00:03:04.000 --> 00:03:11.000
스위프트 차트는 단 몇 줄의 코드로 훌륭하고 사용자 정의 가능한 차트를 만들었습니다.

00:03:11.000 --> 00:03:15.000
스위프트UI와 마찬가지로, 스위프트 차트는 지능형 기본값을 선택합니다.

00:03:15.000 --> 00:03:26.000
여기서, 프레임워크는 y축 값에 대해 만족스럽게 둥근 숫자를 선택했고, 막대 표시에 대한 기본 색상을 제공했다.

00:03:26.000 --> 00:03:33.000
SwiftUI를 알고 있다면, 이미 Swift Charts의 선언적이고 상태 중심적인 구문을 읽을 수 있습니다.

00:03:33.000 --> 00:03:47.000
차트는 단지 일부 보기일 뿐이며, 데이터를 제공한 다음 그 데이터로 차트 콘텐츠를 구축하여 목록과 테이블을 하는 것처럼 선언합니다.

00:03:47.000 --> 00:04:07.000
이 차트에서 BarMark를 선택했지만, LineMark로 전환하고 카테고리별로 그룹화하기 위해 전경 스타일을 추가하면 Swift Charts가 각 카테고리에 대한 개별 선을 그리고 차트에 자동으로 범례를 추가함에 따라 더 많은 이야기를 볼 수 있습니다.

00:04:07.000 --> 00:04:10.000
이 차트에 약간의 개성을 부여하는 것은 재미있다.

00:04:10.000 --> 00:04:16.000
LineMark의 기호 수정자로 선에 점을 추가할 수 있습니다.

00:04:16.000 --> 00:04:21.000
이 수정자는 SwiftUI 수정자와 다르지 않다.

00:04:21.000 --> 00:04:25.000
차트 내에서 SwiftUI 뷰를 사용할 수도 있습니다.

00:04:25.000 --> 00:04:32.000
목록과 마찬가지로, 차트에 대한 데이터 인수는 대신 ForEach로 전달될 수 있다.

00:04:32.000 --> 00:04:41.000
이것은 우리의 일일 목표를 보여주기 위해 RuleMark와 같이 차트 빌더에 더 많은 마크를 추가할 수 있게 해준다.

00:04:41.000 --> 00:04:56.000
스위프트 차트가 현지화, 다크 모드 및 동적 유형을 자동으로 처리하고 물론 모든 플랫폼에서 작동하기 때문에 스위프트UI의 정신은 다시 빛납니다.

00:04:56.000 --> 00:05:01.000
자신만의 차트를 만드는 방법을 보고 싶다면, "Hello Swift Charts"를 확인하세요.

00:05:01.000 --> 00:05:07.000
고급 플로팅 기술에 관심이 있다면, "Raise the bar" 세션으로 진행하세요.

00:05:07.000 --> 00:05:11.000
다음으로, 내비게이션과 창문에 대해 이야기해 봅시다.

00:05:11.000 --> 00:05:31.000
SwiftUI는 이미 몰입형 푸시 앤 팝 내비게이션 스택, 광범위하고 디테일이 풍부한 분할 뷰, 강력한 멀티 윈도우 경험과 같은 가장 일반적인 앱 내비게이션 패턴을 지원합니다.

00:05:31.000 --> 00:05:37.000
올해, SwiftUI는 이 세 가지 패턴 모두에 대한 큰 업데이트를 가지고 있다.

00:05:37.000 --> 00:05:40.000
스택부터 시작하자.

00:05:40.000 --> 00:05:51.000
SwiftUI는 푸시 앤 팝 스타일의 탐색을 지원하기 위해 단순히 NavigationStack이라고 불리는 새로운 컨테이너 뷰를 도입하고 있다.

00:05:51.000 --> 00:05:58.000
NavigationStack은 파티 계획 앱의 음식 재고 목록과 같은 루트 콘텐츠 보기를 래핑합니다.

00:05:58.000 --> 00:06:06.000
예상대로, NavigationLink 및 navigationTitle()과 같은 기존 API와 잘 작동합니다.

00:06:06.000 --> 00:06:14.000
링크를 선택하면, SwiftUI는 스택 위에 세부 보기를 푸시합니다.

00:06:14.000 --> 00:06:25.000
우리 앱에서, 각 세부 보기에는 빠른 브라우징을 위한 관련 식품에 대한 더 많은 링크가 포함되어 있습니다.

00:06:25.000 --> 00:06:28.000
이 접근 방식이 당신이 필요한 전부일 수도 있습니다.

00:06:28.000 --> 00:06:35.000
하지만 견해를 제시하고 제시된 상태를 프로그래밍 방식으로 제어할 수 있는 새로운 방법이 있다.

00:06:35.000 --> 00:06:43.000
내비게이션 스택의 상태를 제어해야 한다면, 새로운 데이터 기반 API를 채택하세요.

00:06:43.000 --> 00:06:54.000
새로운 navigationDestination() 수정자를 사용하면 탐색 대상을 특정 데이터 유형과 연결할 수 있습니다.

00:06:54.000 --> 00:07:04.000
그리고 올해, 우리는 NavigationLink에게 새로운 파티 트릭을 가르쳤습니다: 목적지 보기 대신, 목적지를 나타내는 값을 취할 수 있습니다.

00:07:04.000 --> 00:07:18.000
링크를 탭할 때, SwiftUI는 값의 유형을 사용하여 이전과 마찬가지로 올바른 목적지를 찾고 스택에 푸시합니다.

00:07:18.000 --> 00:07:27.000
우리는 이제 데이터를 사용하여 스택을 구동하기 때문에, 현재 탐색 경로를 명시적인 상태로 나타낼 수 있습니다.

00:07:27.000 --> 00:07:35.000
이 경우, 내비게이션 경로는 단순히 우리가 방문한 모든 식품의 배열이다.

00:07:35.000 --> 00:07:45.000
이 상태에 직접 접근하면, 첫 번째 선택한 항목으로 빠르게 돌아갈 수 있는 버튼을 추가하는 것이 더 쉬울 수 없습니다.

00:07:45.000 --> 00:07:50.000
뷰가 스택에 푸시되면, 항목은 선택된 FoodItems 배열에 추가됩니다.

00:07:50.000 --> 00:08:00.000
버튼의 동작에서, 우리는 첫 번째 항목을 제외한 경로에서 모든 항목을 제거할 수 있습니다.

00:08:00.000 --> 00:08:07.000
그리고 탭으로, 우리는 우리가 시작한 곳으로 바로 돌아왔다.

00:08:07.000 --> 00:08:13.000
이제 다중 열 탐색을 위한 분할 보기에 대해 이야기해 봅시다.

00:08:13.000 --> 00:08:20.000
우리는 다중 열 탐색을 위한 NavigationSplitView라는 또 다른 새로운 컨테이너를 도입하고 있습니다.

00:08:20.000 --> 00:08:25.000
NavigationSplitView는 두 열과 세 열 레이아웃을 선언할 수 있습니다.

00:08:25.000 --> 00:08:37.000
파티 플래너는 간단한 두 열 레이아웃을 사용하여 파티 계획 작업의 사이드바 목록과 선택한 작업으로 내용을 변경하는 세부 보기를 래핑합니다.

00:08:37.000 --> 00:08:49.000
분할 뷰는 이전에 본 새로운 가치 기반 NavigationLinks와 잘 작동하며, 링크의 값을 사용하여 목록 선택을 유도합니다.

00:08:49.000 --> 00:09:02.000
NavigationSplitView는 더 작은 크기의 클래스나 장치에서 자동으로 스택으로 축소되어 적응형 멀티플랫폼 앱을 구축하기 위한 훌륭한 도구가 됩니다.

00:09:02.000 --> 00:09:15.000
NavigationSplitView와 NavigationStack은 함께 작동하도록 설계되었으며 더 복잡한 탐색 구조를 구축하기 위해 직접 구성할 수 있습니다.

00:09:15.000 --> 00:09:35.000
우리는 파티 플래너 앱에서 이것을 사용하여 세부 열을 자체 독립형 내비게이션 스택으로 바꾸며, 이는 또한 macOS의 내비게이션 스택에 대한 새로운 지원을 보여줍니다.

00:09:35.000 --> 00:09:45.000
음, 우리는 음식에 대해 많이 이야기했지만, 내 동료 커트가 그의 강연에서 폭풍우를 요리하고 있다고 들었어, "항법을 위한 스위프트UI 요리책"

00:09:45.000 --> 00:09:51.000
내비게이션 스택과 내비게이션 분할 보기에 대해 더 알아보려면 확인해 보세요.

00:09:51.000 --> 00:09:58.000
하지만 지금은, 상자 밖으로 나가서 새로운 장면 API에 대해 이야기합시다.

00:09:58.000 --> 00:10:10.000
당신은 이미 앱의 메인 인터페이스를 구축하는 좋은 방법인 WindowGroup에 익숙할 것이며, 앱의 데이터에 다른 관점을 허용하기 위해 여러 창을 생성할 수 있습니다.

00:10:10.000 --> 00:10:19.000
올해 새로운, 우리는 당신의 앱에 대한 하나의 고유한 창을 선언하는 창을 추가하고 있습니다.

00:10:19.000 --> 00:10:26.000
여기, 저는 파티의 총 비용을 보여주는 파티 예산 창을 추가했습니다.

00:10:26.000 --> 00:10:34.000
기본적으로 창을 사용할 수 있으며 앱의 창 메뉴에서 이름을 선택하여 표시할 수 있습니다.

00:10:34.000 --> 00:10:43.000
하지만 우리는 창을 열기 위해 Command-0 키보드 단축키를 할당함으로써 그것을 훨씬 더 쉽게 만들 수 있습니다.

00:10:43.000 --> 00:10:50.000
예산에 민감한 파티 플래너를 유지하기 위해, 이 창을 보여주는 작업과 함께 도구 모음 버튼을 추가할 것입니다.

00:10:50.000 --> 00:11:00.000
환경 작업 openWindow를 사용하여 이제 프로그래밍 방식으로 새로운 SwiftUI 관리 창을 열 수 있습니다.

00:11:00.000 --> 00:11:13.000
사실, 우리는 올해 기본 크기, 위치, 크기 조정 가능성 등에 대한 수정자를 포함하여 새로운 창 사용자 지정의 전체 제품군을 추가했습니다.

00:11:13.000 --> 00:11:19.000
나는 파티 예산이 방해가 되는 것을 원하지 않기 때문에, 기본적으로 그것은 작은 코너 창으로 나타난다.

00:11:19.000 --> 00:11:27.000
하지만 위치나 크기를 조정하면, SwiftUI는 앱 실행 전반에 걸쳐 자동으로 기억할 것이다.

00:11:27.000 --> 00:11:40.000
새로운 독립형 창 장면은 Mac에서 이와 같은 작은 보조 창에 좋지만, 파티 플래너는 멀티플랫폼 앱이며, 더 작은 화면을 위한 더 나은 디자인이 필요합니다.

00:11:40.000 --> 00:11:47.000
예를 들어, iOS에서 우리는 대신 크기 조정 가능한 시트에 예산을 표시하도록 선택했습니다.

00:11:47.000 --> 00:11:51.000
이것은 새로운 presentationDetents() 수정자로 가능합니다.

00:11:51.000 --> 00:12:03.000
이 경우, 나는 두 가지 다른 크기로 달라붙는 크기 조정 가능한 시트를 구성했다: 하나는 250 포인트에서, 다른 하나는 시스템 정의 중간 높이에서.

00:12:03.000 --> 00:12:12.000
올해 SwiftUI 기반 앱을 강화하는 Xcode의 멀티 플랫폼 타겟으로 플랫폼 간에 반복하는 것은 간단합니다.

00:12:12.000 --> 00:12:17.000
하나의 목표를 여러 플랫폼에 배치할 수 있다.

00:12:17.000 --> 00:12:23.000
Xcode 도구 모음의 일반적인 풀다운 메뉴에서 플랫폼을 선택하세요.

00:12:23.000 --> 00:12:31.000
"Xcode의 새로운 기능"을 보고 "Xcode를 사용하여 멀티플랫폼 앱 개발"으로 팔로우하여 자세히 알아보세요.

00:12:31.000 --> 00:12:36.000
마지막 새로운 장면 유형을 위해, 우리는 메뉴 표시줄에 주의를 돌릴 수 있다.

00:12:36.000 --> 00:12:44.000
macOS Ventura를 사용하면 이제 SwiftUI에서 MenuBarExtras를 완전히 구축할 수 있습니다!

00:12:44.000 --> 00:12:53.000
이것들은 애플리케이션의 다른 장면 유형과 함께 정의할 수 있으며 앱이 실행되는 동안 항상 메뉴 표시줄에 표시됩니다.

00:12:53.000 --> 00:12:57.000
또는, MenuBarExtra를 사용하여 전체 앱을 만들 수 있습니다!

00:12:57.000 --> 00:13:04.000
이것들은 macOS에서 가장 단순한 아이디어에도 생명을 불어넣는 정말 재미있는 방법이다.

00:13:04.000 --> 00:13:12.000
"SwiftUI 앱에 여러 개의 Windows를 가져오세요"는 모든 새로운 장면 유형과 기능을 활용하는 방법에 대해 더 자세히 설명합니다.

00:13:12.000 --> 00:13:18.000
이제 우리가 창문을 제어할 수 있으니, 창문에 컨트롤을 넣기 위해 프랑크에게 넘길게.

00:13:18.000 --> 00:13:19.000
프랭크: 고마워, 닉!

00:13:19.000 --> 00:13:26.000
올해, 우리는 대화형 콘텐츠를 구축하기 위한 모든 API에서 다양한 개선 사항을 가지고 있습니다.

00:13:26.000 --> 00:13:33.000
우리는 다루어야 할 것이 많으니, 양식에 대한 몇 가지 재미있는 개선으로 이 파티를 시작합시다.

00:13:33.000 --> 00:13:46.000
macOS Ventura는 닉이 방금 안내한 탐색 분할 보기와 스택을 사용하여 구축된 간소화된 탐색 구조를 특징으로 하는 새로운 시스템 설정 앱과 함께 제공됩니다.

00:13:46.000 --> 00:13:50.000
그것은 또한 신선하고 현대적인 인터페이스 스타일을 자랑한다.

00:13:50.000 --> 00:14:02.000
설정 인터페이스는 컨트롤이 많기 때문에, 이 스타일은 일관되고 잘 조직된 방식으로 많은 컨트롤을 포함하는 양식을 제시하도록 특별히 설계되었습니다.

00:14:02.000 --> 00:14:06.000
우리는 또한 파티 플래너 앱에서 이 새로운 디자인을 채택했습니다.

00:14:06.000 --> 00:14:08.000
한 번 보자.

00:14:08.000 --> 00:14:18.000
이벤트 세부 정보 보기는 또한 섹션으로 그룹화된 다양한 유형의 컨트롤을 특징으로 하며, 설정 인터페이스와 유사한 목적을 제공합니다.

00:14:18.000 --> 00:14:25.000
이것은 시스템 설정에서 새로운 시각적 스타일을 채택할 수 있는 훌륭한 후보자이다.

00:14:25.000 --> 00:14:31.000
macOS에서 새로운 그룹화된 formStyle을 사용하여 이 디자인을 활성화할 수 있습니다.

00:14:31.000 --> 00:14:42.000
그리고 SwiftUI의 선언적 API의 유연성 덕분에, 양식 내의 콘텐츠와 컨트롤은 새로운 스타일에 자동으로 적응할 것이다.

00:14:42.000 --> 00:14:54.000
예를 들어, 섹션은 헤더 아래에 콘텐츠를 시각적으로 그룹화할 것이며, 컨트롤은 레이블과 값을 선행 및 후행 가장자리에 일관되게 정렬합니다.

00:14:54.000 --> 00:15:05.000
일부 컨트롤은 일관된 레이아웃과 정렬을 위해 후행 미니 스위치로 디스플레이를 전환하는 방법과 같은 시각적 외관을 조정할 수 있습니다.

00:15:05.000 --> 00:15:18.000
그리고 형태 자체가 많은 시각적 구조를 제공하기 때문에, 다른 컨트롤은 더 가벼운 시각적 외관으로 이 맥락에 적응하고, 롤오버에서 더 눈에 띄는 컨트롤 백킹을 드러낸다.

00:15:18.000 --> 00:15:32.000
SwiftUI를 사용하면 새로운 컨트롤을 구축하거나 읽기 전용 정보를 표시하는 데 사용할 수 있는 새로운 LabeledContent 뷰를 사용하여 다른 유형의 콘텐츠를 이 새로운 스타일에 쉽게 정렬할 수 있습니다.

00:15:32.000 --> 00:15:43.000
이 경우, 우리는 이벤트 위치에 대한 일부 텍스트를 표시하고 있으며, SwiftUI는 자동으로 스타일을 조정하고 해당 텍스트를 선택할 수 있습니다.

00:15:43.000 --> 00:15:54.000
하지만 LabeledContent는 더 많은 전체 주소를 표시하기 위해 사용자 지정 보기를 사용하고 싶은 경우와 같이 모든 종류의 보기를 래핑할 수도 있습니다.

00:15:54.000 --> 00:16:00.000
SwiftUI는 이제 다른 경우에도 텍스트에 기본 스타일을 적용하는 것에 대해 더 똑똑해졌습니다.

00:16:00.000 --> 00:16:10.000
그것은 제목과 자막을 형성하기 위해 컨트롤의 라벨 내에서 여러 텍스트를 계층적으로 포맷할 것이다.

00:16:10.000 --> 00:16:19.000
이 새로운 양식 디자인은 macOS에서 멋지게 보이지만, 앱의 iOS 버전과 동일한 코드를 많이 공유할 수도 있습니다.

00:16:19.000 --> 00:16:37.000
macOS에서 영감을 받은 시각적 스타일을 가진 팝업 메뉴 선택기와 같은 iOS에서도 몇 가지 개선된 디자인을 볼 수 있지만, 상호 작용과 외관은 터치 기반 인터페이스에 아름답게 맞도록 최적화되어 있습니다.

00:16:37.000 --> 00:16:53.000
물론, 동일한 코드는 iPad의 더 큰 화면에서 잘 작동하며, Mac과 함께 SwiftUI의 선언적 모델이 공유 인터페이스를 구축할 때 코드를 공유하는 데 어떻게 도움이 되는지 알 수 있으며, 모든 플랫폼에 당사자를 데려오는 데 도움이 됩니다.

00:16:53.000 --> 00:16:59.000
물론, 우리는 또한 단순한 폼 스타일을 넘어 컨트롤을 개선하고 있다.

00:16:59.000 --> 00:17:06.000
그래서 우리가 파티 플래너 앱에서 사용하고 있는 다른 새로운 제어 기능을 번개처럼 둘러보자.

00:17:06.000 --> 00:17:10.000
iOS 앱의 새로운 활동 페이지부터 시작합시다.

00:17:10.000 --> 00:17:24.000
텍스트 필드는 새로운 축 매개 변수를 사용하여 수직으로 확장하도록 구성할 수 있으며, 텍스트에 맞게 높이를 늘리고, 지정된 경우 높이를 선 제한으로 제한할 수 있습니다.

00:17:24.000 --> 00:17:41.000
하지만 lineLimit 수정자는 이제 최소한의 공간을 예약하고 더 많은 콘텐츠가 추가됨에 따라 확장한 다음 콘텐츠가 상한을 초과하면 스크롤하는 것과 같은 고급 동작을 지원합니다.

00:17:41.000 --> 00:17:55.000
텍스트 필드 아래에는 일주일 내내 파티 활동을 퍼뜨리는 데 도움이 되도록 연속되지 않은 날짜 선택을 지원하는 새로운 MultiDatePicker 컨트롤의 예도 볼 수 있습니다.

00:17:55.000 --> 00:18:01.000
이제 이 시점에서, 아마도 당신은 이 이야기의 파티 주제에 대해 엇갈린 감정을 가지고 있을 것입니다.

00:18:01.000 --> 00:18:08.000
좋은 소식은 이제 혼합 상태 컨트롤을 사용하여 SwiftUI에서 그러한 감정을 표현할 수 있다는 것입니다!

00:18:08.000 --> 00:18:16.000
여기에 단일 집계 토글로 축소될 수 있는 토글 그룹이 있습니다.

00:18:16.000 --> 00:18:30.000
내부 토글은 각각 단일 바인딩을 취하는 반면, 집계 토글은 값이 모두 일치하지 않는 경우 혼합 상태를 표시하는 모든 바인딩의 컬렉션을 취합니다.

00:18:30.000 --> 00:18:32.000
피커도 같은 방식으로 일한다.

00:18:32.000 --> 00:18:38.000
이 장식 테마 선택기는 현재 선택된 장식을 반영하기 위해 값을 변경합니다.

00:18:38.000 --> 00:18:47.000
하지만 우리가 여러 개의 장식을 선택하면, 혼합 상태 지표를 사용하여 모든 것에 대한 테마를 보여줄 것이다.

00:18:47.000 --> 00:18:51.000
이제, iOS 앱으로 다시 전환해 봅시다.

00:18:51.000 --> 00:18:57.000
이벤트 해시태그를 선택하기 위한 몇 가지 버튼 스타일의 토글이 있습니다.

00:18:57.000 --> 00:19:04.000
우리는 단순히 테두리가 있는 버튼 스타일을 추가하여 각 토글을 차별화하는 데 도움을 줄 수 있습니다.

00:19:04.000 --> 00:19:15.000
이와 같은 버튼 스타일은 이제 토글, 메뉴 및 피커를 포함하여 버튼과 같은 모양을 지원하는 모든 컨트롤에 적용됩니다.

00:19:15.000 --> 00:19:20.000
스테퍼로 넘어가면, 이제 그 가치에 대한 형식을 제공할 수 있습니다.

00:19:20.000 --> 00:19:27.000
macOS에서 포맷된 스테퍼는 편집 가능한 필드에 값을 표시합니다.

00:19:27.000 --> 00:19:33.000
그리고 스테퍼는 이제 watchOS에서도 사용할 수 있습니다.

00:19:33.000 --> 00:19:44.000
Apple Watch는 내가 가장 좋아하는 새로운 기능 중 하나를 자랑한다: 손 움켜쥐고 행동을 수행하는 대체 방법인 접근성 빠른 동작.

00:19:44.000 --> 00:19:59.000
빠른 동작은 버튼을 사용하여 다른 UI 동작과 마찬가지로 정의할 수 있으므로, 보이는 버튼과 이에 상응하는 빠른 동작 모두에 대해 동일한 코드를 공유할 수 있습니다.

00:19:59.000 --> 00:20:08.000
좋아요, 우리는 많은 다른 컨트롤을 다루었지만, 물론 컨트롤이 상호 작용의 유일한 원천은 아닙니다.

00:20:08.000 --> 00:20:14.000
그래서 테이블과 목록과 같은 더 큰 대화형 컨테이너의 새로운 기능을 살펴봅시다.

00:20:14.000 --> 00:20:20.000
이제 iPadOS에서 테이블이 지원된다는 것을 공유하게 되어 기쁩니다.

00:20:20.000 --> 00:20:32.000
예상대로, iPadOS의 테이블은 작년에 macOS에 도입한 것과 동일한 테이블 API를 사용하여 정의되므로 플랫폼 간에 코드를 쉽게 공유할 수 있습니다.

00:20:32.000 --> 00:20:45.000
우리의 초대장 표는 iPad의 대형 디스플레이를 활용하여 각 사람의 이름, 도시 및 초대 상태에 대한 세 개의 열을 보여줍니다.

00:20:45.000 --> 00:20:58.000
하지만 이 표는 또한 iPhone을 포함하여 컴팩트한 크기의 클래스에서 적절하게 렌더링되며, 더 작은 화면 공간 내의 기본 열만 보여줍니다.

00:20:58.000 --> 00:21:02.000
컨텍스트를 전환하고 macOS에서 이 표를 확인해 봅시다.

00:21:02.000 --> 00:21:03.000
멋져 보여!

00:21:03.000 --> 00:21:11.000
하지만 문맥에 대해 말하자면, 테이블 내에서 일반적인 작업을 수행하기 위한 몇 가지 문맥 메뉴를 추가하고 싶습니다.

00:21:11.000 --> 00:21:17.000
이것은 새로운 선택 기반 contentMenu 수정자를 위한 작업입니다.

00:21:17.000 --> 00:21:26.000
수정자는 선택 유형을 취하며, 선택을 지원하는 호환 가능한 테이블이나 목록에서 활성화됩니다.

00:21:26.000 --> 00:21:46.000
메뉴 빌더 내에서 현재 선택 모음이 주어지며, 테이블의 빈 영역을 클릭할 때와 같이 선택된 단일 행, 여러 선택된 행 또는 선택된 행에서 작동할 수 있는 고급 컨텍스트 메뉴를 구축할 수 있습니다.

00:21:46.000 --> 00:21:52.000
컨텍스트 메뉴는 테이블 내에서 직접 동작을 나타내며, 이는 속도와 효율성에 좋습니다.

00:21:52.000 --> 00:21:57.000
하지만 나는 또한 이 행동들을 더 발견할 수 있게 만들고 싶다.

00:21:57.000 --> 00:22:12.000
발견 가능성을 향상시키는 좋은 방법은 도구 모음에 버튼으로 일반적인 작업을 표시하는 것이며, iPadOS는 추가 수준의 광택을 달성하는 데 도움이 되는 새롭고 향상된 도구 모음 디자인을 갖추고 있습니다.

00:22:12.000 --> 00:22:28.000
iPad 도구 모음은 이제 사용자 사용자 지정 및 재정렬을 지원할 수 있으며, 앱은 macOS에서 사용할 수 있는 동일한 API인 각 도구 모음 항목에 대한 명시적인 식별자를 제공하여 구현할 수 있습니다.

00:22:28.000 --> 00:22:37.000
이러한 식별자를 통해 SwiftUI는 앱 실행 전반에 걸쳐 사용자 지정 도구 모음 구성을 자동으로 저장하고 복원할 수 있습니다.

00:22:37.000 --> 00:22:44.000
iPadOS에서 모든 도구 모음 항목이 사용자 지정을 허용하는 것은 아닙니다.

00:22:44.000 --> 00:22:58.000
사용자 정의 가능한 작업은 기본적으로 도구 모음의 중앙에 표시되거나 소형 크기의 클래스의 오버플로 메뉴에 표시되는 새로운 secondaryAction 도구 모음 항목 배치를 사용하여 구성됩니다.

00:22:58.000 --> 00:22:59.000
알았어!

00:22:59.000 --> 00:23:06.000
그 단어는 퍼지고 있으며 참석자 수가 기하급수적으로 증가하고 있는 것처럼 보인다.

00:23:06.000 --> 00:23:12.000
검색 지원을 추가하여 테이블이 규모를 관리할 수 있도록 도와드리겠습니다.

00:23:12.000 --> 00:23:17.000
SwiftUI는 이미 검색 가능한 수정자로 기본 검색을 지원합니다.

00:23:17.000 --> 00:23:28.000
그리고 올해 새로운 검색 필드는 토큰화된 입력과 제안을 지원하여 보다 체계적인 검색 쿼리를 구축하는 데 도움을 줄 수 있습니다.

00:23:28.000 --> 00:23:43.000
결과 필터링을 돕기 위해 SwiftUI는 이제 macOS의 도구 모음 아래의 범위 표시줄과 iOS의 탐색 표시줄 내에서 세분화된 컨트롤로 나타나는 검색 범위를 지원합니다.

00:23:43.000 --> 00:23:48.000
우리는 올해 iPad에서 SwiftUI로 가능한 것의 표면만 긁었다.

00:23:48.000 --> 00:23:52.000
"SwiftUI on iPad" 시리즈를 확인하고 더 알아보세요.

00:23:52.000 --> 00:24:00.000
이제 우리는 이벤트 세부 사항과 물류를 좀 더 통제할 수 있게 되었으니, 뉴스를 공유하고 사람들을 더욱 흥분하게 합시다.

00:24:00.000 --> 00:24:09.000
다른 사람들과 콘텐츠를 공유하고 애플리케이션 간에 데이터를 공유하는 것은 많은 앱의 필수적인 부분이다.

00:24:09.000 --> 00:24:16.000
이러한 기능을 활용하면 앱을 사용하는 사람들의 워크플로우에 더욱 통합됩니다.

00:24:16.000 --> 00:24:22.000
올해 우리는 그것을 더 쉽게 만들 수 있는 몇 가지 흥미로운 영역이 있다.

00:24:22.000 --> 00:24:31.000
사진과 비디오를 선택하기 위한 새로운 멀티플랫폼 및 개인 정보 보호 API인 PhotosPicker부터 시작합시다.

00:24:31.000 --> 00:24:43.000
사진은 모든 파티의 필수적인 부분이기 때문에, 저는 파티 플래너 앱에 찍은 사진에 재미있는 생일 효과를 추가하는 기능을 추가했습니다.

00:24:43.000 --> 00:24:57.000
새로운 PhotosPicker 보기는 앱의 어느 곳에나 배치할 수 있으며, 활성화 시 사용자의 라이브러리에서 사진이나 비디오를 선택할 수 있는 표준 사진 선택 UI를 제공합니다.

00:24:57.000 --> 00:25:07.000
PhotosPicker는 실제 사진 및 비디오 데이터에 대한 액세스를 제공하는 선택한 항목에 바인딩합니다.

00:25:07.000 --> 00:25:18.000
또한 콘텐츠 유형 필터링, 선호하는 사진 인코딩 등과 같은 추가적인 풍부한 구성 옵션이 있습니다.

00:25:18.000 --> 00:25:22.000
이건 내가 본 것 중 가장 포토제닉한 컵케이크야.

00:25:22.000 --> 00:25:25.000
하지만 컵케이크 하나로는 충분하지 않아.

00:25:25.000 --> 00:25:29.000
우리가 계속 나아갈 때 특수 효과를 적용합시다.

00:25:29.000 --> 00:25:36.000
이제 맞춤형 사진을 갖게 되었으므로, 새로운 ShareLink API와 공유할 준비가 되었습니다.

00:25:36.000 --> 00:25:43.000
각 플랫폼에는 사람들이 앱의 콘텐츠를 공유할 수 있는 표준 인터페이스가 있습니다.

00:25:43.000 --> 00:25:50.000
watchOS 9를 사용하면 이제 시계 앱 내에서 공유 시트를 표시할 수도 있습니다.

00:25:50.000 --> 00:25:57.000
새로운 ShareLink 보기를 사용하면 앱 내에서 시스템 공유 시트를 표시할 수 있습니다.

00:25:57.000 --> 00:26:10.000
공유할 콘텐츠와 공유 시트에서 사용할 미리보기를 제공하기만 하면 표준 공유 아이콘 버튼이 자동으로 생성됩니다.

00:26:10.000 --> 00:26:15.000
탭하면, 콘텐츠를 보내기 위한 표준 공유 시트를 제공합니다.

00:26:15.000 --> 00:26:23.000
공유 링크는 컨텍스트 메뉴와 플랫폼과 같이 적용되는 컨텍스트에 적응합니다.

00:26:23.000 --> 00:26:37.000
PhotosPicker, ShareLink 등은 모두 애플리케이션 간에 유형이 전송되는 방법을 설명하는 스위프트 우선 선언적 방법인 새로운 Transferable 프로토콜을 활용합니다.

00:26:37.000 --> 00:26:50.000
전송 가능한 유형은 드래그 앤 드롭과 같은 SwiftUI 기능을 강화하는 데 사용되며, 다른 앱의 이미지를 파티 플래너 갤러리로 쉽게 드롭할 수 있습니다.

00:26:50.000 --> 00:26:58.000
이것은 페이로드 유형을 받아들이는 새로운 dropDestination API를 사용하며, 이 경우에는 이미지만 사용합니다.

00:26:58.000 --> 00:27:07.000
완료 블록은 드롭 위치와 함께 수신된 이미지 모음을 제공합니다.

00:27:07.000 --> 00:27:14.000
문자열과 이미지와 같은 많은 표준 유형은 이미 Transferable을 준수합니다.

00:27:14.000 --> 00:27:23.000
그래서 우리 앱에서 공을 굴리는 것은 많은 일이 아니었지만, 당신은 쉽게 더 나아가 자신의 사용자 지정 유형으로 Transferable을 구현할 수 있습니다.

00:27:23.000 --> 00:27:34.000
그렇게 할 때가 되면, 당신의 적합성은 코딩 가능한 지원 및 사용자 지정 콘텐츠 유형을 사용하는 것과 같이 당신의 유형에 적합한 표현을 선언합니다.

00:27:34.000 --> 00:27:44.000
Transferable, 기타 표현, 고급 팁과 트릭에 대해 자세히 알아보려면, "Meet Transferable" 토크를 확인하세요.

00:27:44.000 --> 00:27:49.000
우리가 컵케이크를 준비하는 동안, 닉은 모든 물품을 준비하고 있었다.

00:27:49.000 --> 00:27:51.000
닉, 거기는 어때?

00:27:51.000 --> 00:27:53.000
닉: 거의 끝났어!

00:27:53.000 --> 00:27:59.000
나는 이 파티 뿔을 완전히 맞춤 레이아웃으로 배열하고 있지만, 시간이 조금 더 필요할 것이다.

00:27:59.000 --> 00:28:02.000
먼저 그래픽에 대해 이야기해 봅시다.

00:28:02.000 --> 00:28:08.000
ShapeStyle은 올해 풍부한 그래픽 효과를 얻을 수 있는 새로운 API를 가지고 있다.

00:28:08.000 --> 00:28:14.000
우리는 이 API를 사용하여 이 게스트 카드에 파티 팝을 줄 것입니다!

00:28:14.000 --> 00:28:21.000
색상은 색상에서 파생된 미묘한 그라디언트를 추가하는 새로운 그라디언트 속성을 가지고 있다.

00:28:21.000 --> 00:28:25.000
이것들은 시스템 색상과 잘 어울린다.

00:28:25.000 --> 00:28:30.000
셰이프스타일은 또한 새로운 그림자 수정자를 얻었다.

00:28:30.000 --> 00:28:36.000
흰색 전경 스타일에 추가하면 텍스트와 기호에 그림자가 추가됩니다.

00:28:36.000 --> 00:28:39.000
그리고 이 그림자의 디테일은 놀랍다.

00:28:39.000 --> 00:28:47.000
그림자는 달력 기호의 모든 요소에 적용되었다.

00:28:47.000 --> 00:28:57.000
SF 심볼의 전 세계와 새로운 SwiftUI ShapeStyle 확장으로, 당신은 절대적으로 멋진 아이콘을 만들 수 있습니다.

00:28:57.000 --> 00:29:03.000
이제, SF 심볼의 그리드를 파티에 가져올 시간이다.

00:29:03.000 --> 00:29:10.000
우리는 올해 환상적인 개선 사항이 있는 SwiftUI Previews를 사용하여 빠르게 반복할 것입니다.

00:29:10.000 --> 00:29:17.000
미리보기는 항상 여러 구성에서 동시에 보기를 볼 수 있는 편리한 방법이었다.

00:29:17.000 --> 00:29:23.000
Xcode 14로, 우리는 미리보기 변형으로 이것을 그 어느 때보다 쉽게 만들고 있습니다.

00:29:23.000 --> 00:29:34.000
이를 통해 구성 코드를 작성하지 않고도 동시에 여러 모양, 유형 크기 또는 방향으로 뷰를 개발할 수 있습니다.

00:29:34.000 --> 00:29:41.000
우리는 같은 그라디언트를 다시 사용하거나, 이 이미지에 부드러운 빛을 주기 위해 타원형 그라디언트로 스타일링할 수 있습니다.

00:29:41.000 --> 00:29:46.000
그리고 어둡고 밝은 모습으로 미리 보세요.

00:29:46.000 --> 00:29:50.000
미리보기는 이제 기본적으로 라이브 모드에서 실행됩니다.

00:29:50.000 --> 00:29:57.000
약간의 춤 없이는 멋진 생일 파티가 될 수 없어, 그러니 이 SF 심볼을 춤추게 하자.

00:29:57.000 --> 00:30:01.000
♪ 전자 댄스 음악 ♪

00:30:01.000 --> 00:30:12.000
♪

00:30:12.000 --> 00:30:16.000
그 유쾌한 아이콘들은 심오한 것을 보여준다.

00:30:16.000 --> 00:30:22.000
SwiftUI는 텍스트와 이미지 애니메이션을 한 단계 끌어올렸다.

00:30:22.000 --> 00:30:26.000
그 텍스트가 슬로우 모션으로 다시 움직이는 것을 봅시다.

00:30:26.000 --> 00:30:32.000
텍스트는 이제 가중치, 스타일, 심지어 레이아웃 사이에서 아름답게 애니메이션화될 수 있다.

00:30:32.000 --> 00:30:40.000
그리고 가장 좋은 점: 이것은 SwiftUI의 나머지 부분에서 사용되는 것과 동일한 애니메이션 API를 활용합니다.

00:30:40.000 --> 00:30:49.000
UI 프로그래밍에서 내가 가장 좋아하는 부분, 적용된 기하학 - 또는 우리가 부르는 레이아웃에 대해 이야기하면서 마무리합시다.

00:30:49.000 --> 00:30:53.000
SwiftUI는 뷰를 배치하는 새로운 방법을 추가했다.

00:30:53.000 --> 00:30:59.000
그리드는 2차원 그리드에서 뷰를 배열하는 새로운 컨테이너 뷰이다.

00:30:59.000 --> 00:31:07.000
그리드는 여러 열에 걸친 셀을 활성화하고 행과 열 간의 자동 정렬을 활성화하기 위해 전면의 하위 뷰를 측정할 것이다.

00:31:07.000 --> 00:31:14.000
사실, 당신은 이미 이전에 그리드를 살펴봤습니다.

00:31:14.000 --> 00:31:21.000
Grid, GridRow 및 gridCellColumns 수정자를 사용하면 그리드를 단편적으로 만들 수 있습니다.

00:31:21.000 --> 00:31:27.000
물론, SwiftUI의 모든 레이아웃과 마찬가지로, 그것들은 구성을 위해 만들어졌다.

00:31:27.000 --> 00:31:38.000
우리는 첫 번째 릴리스와 함께 SwiftUI의 레이아웃 모델을 도입하여 가장 일반적인 레이아웃을 달성하기 위한 원시적인 레이아웃 유형의 도구 상자를 제공합니다.

00:31:38.000 --> 00:31:56.000
대부분의 경우, 이러한 원시적인 레이아웃 유형으로 작업을 완료할 수 있지만, 때로는 필수 레이아웃 코드를 원합니다: 크기, minX, frame.origin.x 빼기 frame.midX를 2 더하기 3으로 나눕니다.

00:31:56.000 --> 00:32:03.000
새로운 레이아웃 프로토콜에 도달해야 할 때와 같은 때입니다.

00:32:03.000 --> 00:32:15.000
그것으로, 당신은 SwiftUI의 스택과 그리드를 구현하여 자신만의 일류 레이아웃 추상화를 구축하는 데 사용한 모든 힘과 유연성을 갖게 됩니다.

00:32:15.000 --> 00:32:21.000
레이아웃을 사용하여, 나는 우리의 생일 파티에서 손님들을 위해 이 맞춤형 좌석 차트 레이아웃을 만들었다.

00:32:21.000 --> 00:32:25.000
우리 파티 손님들은 줄에 앉아야 하나요 아니면 포드에 앉아야 하나요?

00:32:25.000 --> 00:32:29.000
레이아웃의 힘으로, 우리는 선택할 필요가 없다.

00:32:29.000 --> 00:32:39.000
레이아웃 프로토콜을 사용하면 뷰 계층의 특정 요구에 맞는 모든 종류의 효율적인 레이아웃을 구축할 수 있습니다.

00:32:39.000 --> 00:32:49.000
레이아웃을 채택하는 방법과 다른 새롭고 훌륭한 레이아웃 기술에 대해 배우려면, "SwiftUI로 사용자 지정 레이아웃 구성" 세션을 확인하세요.

00:32:49.000 --> 00:32:53.000
저는 특별히 당신을 위해 레이아웃의 맛을 준비했습니다.

00:32:53.000 --> 00:33:01.000
새로운 AnyLayout 유형을 사용하면 그리드 레이아웃과 내가 작성한 사용자 지정 분산 레이아웃 사이를 전환할 수 있습니다.

00:33:01.000 --> 00:33:08.000
이 세션이 끝나갈 무렵, 깜짝 선물이 하나 남았습니다: 당신은 초대받았습니다!

00:33:08.000 --> 00:33:10.000
♪

00:33:10.000 --> 00:33:17.000
이번 주에 SwiftUI의 생일과 모든 새로운 API를 축하하도록 초대합니다.

00:33:17.000 --> 00:33:25.000
우리가 다룬 API에서 탐색해야 할 많은 세부 사항이 남아 있으며, 우리가 포함할 시간이 없었던 더 많은 API가 있습니다.

00:33:25.000 --> 00:33:29.000
파티를 즐기고, WWDC 2022를 즐기세요.

00:33:29.000 --> 00:33:36.000
그리고 우리는 케이크를 즐길 거야.

00:33:36.000 --> 00:33:38.000
♪ 기악 힙합 음악 ♪

00:33:38.000 --> 23:59:59.000
♪

