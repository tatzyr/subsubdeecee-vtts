WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:14.000
Souvik Banerjee: 안녕하세요, "DriverKit으로 드라이버를 iPad로 가져오세요"에 오신 것을 환영합니다.

00:00:14.000 --> 00:00:19.000
저는 Souvik이고, 오늘은 DriverKit의 몇 가지 흥미진진한 새로운 개발에 대해 논의할 것입니다.

00:00:19.000 --> 00:00:22.000
우리는 오늘 세 가지 주제에 대해 논의할 것이다.

00:00:22.000 --> 00:00:27.000
먼저, DriverKit에 대한 간략한 개요를 드리겠습니다.

00:00:27.000 --> 00:00:32.000
그런 다음, AudioDriverKit에 대한 몇 가지 업데이트에 대해 논의하겠습니다.

00:00:32.000 --> 00:00:39.000
그리고 드라이버를 iPad로 가져오는 방법부터 시작하겠습니다. 개요부터 시작합시다.

00:00:39.000 --> 00:00:45.000
2019년에, 우리는 IOKit 장치 드라이버를 대체하는 DriverKit을 도입했습니다.

00:00:45.000 --> 00:00:53.000
DriverKit은 사용자 공간에서 실행되는 더 안정적이고 안전한 시스템을 확장하는 새로운 방법을 가져왔다.

00:00:53.000 --> 00:00:58.000
그리고 당신의 프로세스가 커널에 없기 때문에 개발하기가 더 쉽습니다.

00:00:58.000 --> 00:01:09.000
덱스트라고도 알려진 이 드라이버 확장 프로그램은 앱에 번들로 제공되며, Mac App Store에서 앱과 드라이버를 쉽게 배포할 수 있습니다.

00:01:09.000 --> 00:01:17.000
사람들은 검색으로 드라이버를 쉽게 찾을 수 있으며, 드라이버가 더 이상 필요하지 않은 경우, 앱을 삭제하여 제거할 수 있습니다.

00:01:17.000 --> 00:01:23.000
DriverKit을 도입한 이후, 우리는 많은 새로운 운전자 가족에 대한 지원을 추가했습니다.

00:01:23.000 --> 00:01:37.000
우리는 이제 USB, PCI 및 HID와 같은 전송 외에도 네트워킹, 블록 스토리지, 직렬, 오디오 및 SCSI 컨트롤러 및 주변 장치 드라이버를 지원합니다.

00:01:37.000 --> 00:01:54.000
DriverKit으로 구축할 수 있는 드라이버 종류에 대해 자세히 알아보려면 WWDC 2021의 "DriverKit으로 오디오 드라이버 만들기" 세션과 WWDC 2020의 "DriverKit으로 PCI 및 SCSI 드라이버 현대화" 세션을 확인하십시오.

00:01:54.000 --> 00:02:01.000
다음으로, 우리는 최근에 AudioDriverKit에 강조하고 싶은 몇 가지 새로운 기능을 추가했습니다.

00:02:01.000 --> 00:02:04.000
이러한 기능 중 하나는 실시간 운영이다.

00:02:04.000 --> 00:02:11.000
실시간 콜백을 등록할 수 있는 AudioDriverKit의 새로운 기능을 소개하게 되어 기쁩니다.

00:02:11.000 --> 00:02:16.000
이 콜백은 IO 작업이 발생할 때마다 호출됩니다.

00:02:16.000 --> 00:02:25.000
신호 처리와 같은 실시간 스레드에서 오디오 버퍼를 수정해야 하는 경우 이 콜백을 사용할 수 있습니다.

00:02:25.000 --> 00:02:36.000
AudioDriverKit에 실시간 콜백을 등록하려면, IOUserAudioDevice에 설정할 IOOperationHandler 블록을 선언합니다.

00:02:36.000 --> 00:02:47.000
이 블록은 장치의 IOUserAudioStream 버퍼에서 IO 작업이 발생할 때 실시간 컨텍스트에서 호출됩니다.

00:02:47.000 --> 00:02:53.000
블록 내부에서, 우리는 작업이 무엇인지 확인하고, 필요에 따라 데이터를 수정할 수 있습니다.

00:02:53.000 --> 00:02:59.000
마지막으로, 우리는 오디오 장치에 블록을 설정하기 위해 SetIOOperationHandler를 호출합니다.

00:02:59.000 --> 00:03:02.000
이제 자격에 대해 이야기해 봅시다.

00:03:02.000 --> 00:03:11.000
AudioDriverKit을 도입했을 때, 드라이버에서 allow-any-userclient-access 권한을 사용해야 했습니다.

00:03:11.000 --> 00:03:17.000
macOS 12.1에서, 우리는 특별히 AudioDriverKit을 위한 새로운 권한을 도입했습니다.

00:03:17.000 --> 00:03:27.000
Allow-any-userclient-access 권한 대신 새로운 오디오 패밀리 권한을 사용하도록 오디오 드라이버를 업데이트하십시오.

00:03:27.000 --> 00:03:35.000
앱이 드라이버와 통신할 수 있기를 원한다면 allow-any-userclient-access 권한을 유지할 수 있습니다.

00:03:35.000 --> 00:03:43.000
이 새로운 자격은 개발을 위해 공개되므로, 요청을 제출하지 않고도 오늘 이것을 사용할 수 있습니다.

00:03:43.000 --> 00:03:49.000
사실, 모든 DriverKit 제품군 자격은 이제 개발에 사용할 수 있습니다.

00:03:49.000 --> 00:03:57.000
배포를 위해 이 자격을 요청하려면, developer.apple.com의 시스템 확장 페이지를 방문하세요.

00:03:57.000 --> 00:04:02.000
이제, iPad의 DriverKit에 대해 알려드리게 되어 정말 기쁩니다.

00:04:02.000 --> 00:04:06.000
전문가들은 최선을 다하기 위해 점점 더 iPad를 사용하고 있다.

00:04:06.000 --> 00:04:11.000
하지만 많은 사람들이 iPad에서 사용할 수 없는 외부 하드웨어에 의존한다.

00:04:11.000 --> 00:04:17.000
그래서 오늘, 우리는 DriverKit이 iPad에 출시된다는 것을 발표하게 되어 기쁩니다.

00:04:17.000 --> 00:04:26.000
macOS의 DriverKit은 시스템을 안전하고 안전한 방식으로 확장할 수 있게 해주었고, 우리는 같은 기술을 iPad에 도입하고 있습니다.

00:04:26.000 --> 00:04:39.000
사실, 이미 Mac에서 DriverKit으로 드라이버를 만들었다면, 드라이버를 변경하지 않고도 동일한 드라이버를 iPad로 가져올 수 있습니다.

00:04:39.000 --> 00:04:45.000
USB, PCI 및 오디오는 iPadOS 16에서 지원됩니다.

00:04:45.000 --> 00:04:54.000
이것은 처음으로 iPad에서 썬더볼트 오디오 인터페이스와 더 많은 장치를 가능하게 할 것이다.

00:04:54.000 --> 00:04:57.000
이것은 M1 칩의 힘으로 가능해졌다.

00:04:57.000 --> 00:05:00.000
M1이 장착된 모든 iPad는 DriverKit을 지원할 것이다.

00:05:00.000 --> 00:05:05.000
iPadOS의 DriverKit은 macOS와 동일합니다.

00:05:05.000 --> 00:05:13.000
즉, 하나의 DriverKit 드라이버를 구축하고 두 플랫폼 모두에서 작동할 수 있으며, 소스 변경이 필요하지 않습니다.

00:05:13.000 --> 00:05:25.000
또한, Xcode 14의 새로운 멀티플랫폼 앱 기능을 사용하면 단일 앱 대상을 쉽게 만들어 Mac과 iPad 모두에서 드라이버를 제공할 수 있습니다.

00:05:25.000 --> 00:05:34.000
멀티플랫폼 앱에 대한 자세한 내용은 "Xcode를 사용하여 멀티플랫폼 앱 개발" 세션을 확인하세요.

00:05:34.000 --> 00:05:39.000
Xcode는 또한 이제 DriverKit 드라이버의 자동 서명을 지원합니다.

00:05:39.000 --> 00:05:46.000
iPadOS에서 DriverKit을 처리하는 방법을 알고 있으며 Mac과 iPad 모두를 위해 프로비저닝할 수 있습니다.

00:05:46.000 --> 00:05:51.000
더 이상 DriverKit 드라이버에 대한 수동 서명을 구성할 필요가 없습니다.

00:05:51.000 --> 00:05:57.000
iPadOS 앱과 드라이버는 macOS와 마찬가지로 App Store에서 배포할 수 있습니다.

00:05:57.000 --> 00:06:05.000
이것은 당신이 인앱 구매와 같은 기능을 활용하고 사용자가 드라이버를 쉽게 발견할 수 있다는 것을 의미합니다.

00:06:05.000 --> 00:06:12.000
기존 macOS 드라이버와 앱을 iPad로 가져오는 것이 얼마나 쉬운지 봅시다.

00:06:12.000 --> 00:06:15.000
여기 DriverKitSampleApp이라는 앱이 있습니다.

00:06:15.000 --> 00:06:22.000
사용자가 드라이버를 설치할 수 있는 라벨과 버튼이 있는 SwiftUI 보기가 있습니다.

00:06:22.000 --> 00:06:25.000
우리 운전자는 NullDriver라고 불린다.

00:06:25.000 --> 00:06:36.000
운전자가 시작할 때 메시지를 인쇄하고 매초마다 발사하고 timerCount라는 카운터를 증가시키는 타이머를 시작합니다.

00:06:36.000 --> 00:06:45.000
이것을 iPad 앱으로 만들려면, Xcode에서 DriverKitSampleApp 대상을 선택하기만 하면 됩니다...

00:06:45.000 --> 00:06:51.000
그리고 지원되는 목적지에 iPad를 추가하세요.

00:06:51.000 --> 00:06:59.000
이제 달리기 목적지를 Mac에 연결한 iPad로 변경할 수 있습니다.

00:06:59.000 --> 00:07:02.000
이걸 아이패드에서 실행해 보자.

00:07:02.000 --> 00:07:04.000
여기 우리의 아이패드 앱이 있습니다.

00:07:04.000 --> 00:07:09.000
우리는 Xcode에서 본 보기에서 라벨과 버튼을 가지고 있다.

00:07:09.000 --> 00:07:15.000
Dext 설치 버튼을 탭하면 이 새로운 드라이버 링크를 볼 수 있는 설정으로 이동합니다.

00:07:15.000 --> 00:07:20.000
우리는 그 링크를 탭하면, 이 앱에 번들로 제공되는 모든 드라이버 목록을 볼 수 있습니다.

00:07:20.000 --> 00:07:24.000
그러면 우리는 Null Driver를 활성화할 수 있다.

00:07:24.000 --> 00:07:27.000
그래서 당신은 데모에서 몇 가지를 알아차렸을 수도 있습니다.

00:07:27.000 --> 00:07:36.000
Null 드라이버는 iPadOS 앱 내에 번들로 제공되며, 설치 후 시스템에서 자동으로 검색됩니다.

00:07:36.000 --> 00:07:43.000
macOS에서는 SystemExtension 프레임워크를 사용하여 사용자에게 드라이버를 설치하라는 메시지를 표시해야 합니다.

00:07:43.000 --> 00:07:48.000
iPadOS에는 SystemExtensions 프레임워크가 없습니다.

00:07:48.000 --> 00:07:54.000
Xcode 내부에서, 당신은 우리의 드라이버가 우리 앱에 내장되어 있다는 것을 알 수 있습니다.

00:07:54.000 --> 00:08:02.000
드라이버는 낮은 수준의 소프트웨어이며 특권이 있기 때문에, 실행하기 전에 사용자의 승인을 받아야 합니다.

00:08:02.000 --> 00:08:10.000
macOS에서 사용자는 시스템 확장을 허용하려면 보안 및 개인 정보 보호 환경 설정으로 이동해야 합니다.

00:08:10.000 --> 00:08:14.000
iPadOS에서 운전자 승인은 설정 앱에 있습니다.

00:08:14.000 --> 00:08:17.000
운전자 승인에는 두 가지 옵션이 있습니다.

00:08:17.000 --> 00:08:25.000
드라이버가 설치된 앱이 하나 이상 있는 경우, 사용 가능한 모든 드라이버 목록이 있는 일반 설정 내에 메뉴가 있습니다.

00:08:25.000 --> 00:08:29.000
각 운전자는 켜거나 끌 수 있다.

00:08:29.000 --> 00:08:36.000
앱에 설정 번들이 포함되어 있다면, 앱의 설정 안에 드라이버 링크가 있을 것입니다.

00:08:36.000 --> 00:08:40.000
앱은 사용자에게 설정에서 드라이버를 활성화하라는 메시지를 표시해야 합니다.

00:08:40.000 --> 00:08:48.000
macOS 드라이버 프로젝트를 다시 시작하고 앱이 설정에서 드라이버를 활성화하도록 사용자에게 메시지를 표시하도록 할 수 있는 방법을 봅시다.

00:08:48.000 --> 00:08:55.000
우리는 지원되는 목적지에 iPad를 추가하는 것으로 시작합니다.

00:08:55.000 --> 00:09:07.000
SwiftUI 뷰에는 드라이버를 설치하는 버튼이 있으며, 뷰 모델에는 SystemExtensions 프레임워크와 상호 작용하는 상태 기계가 있습니다.

00:09:07.000 --> 00:09:25.000
이 프로젝트는 Mac과 iPad 모두를 위해 구축될 것이기 때문에, 우리는 Mac 보기와 보기 모델을 유지하고 싶지만 iPad에서 사용할 새로운 보기를 만들고 싶습니다.

00:09:25.000 --> 00:09:49.000
그런 다음, 빌드 단계 및 소스 컴파일로 이동하여 iOS 또는 macOS용으로 조건부 컴파일하도록 각 파일의 플랫폼 필터를 변경할 수 있습니다.

00:09:49.000 --> 00:09:52.000
이제, 앱에 설정 번들을 추가해 봅시다.

00:09:52.000 --> 00:10:03.000
지금은 기본 예제 설정을 사용할 것이지만, 나중에 앱이 사용할 수 있는 실제 설정으로 변경할 수 있습니다.

00:10:03.000 --> 00:10:07.000
이제 우리가 방금 만든 iOS 보기를 확인해 봅시다.

00:10:07.000 --> 00:10:13.000
macOS 보기를 iOS 보기로 복사하여 출발점으로 사용할 수 있습니다.

00:10:13.000 --> 00:10:20.000
우리의 iOS 뷰는 뷰 모델을 사용하지 않으므로, 우리는 그것을 제거할 수 있습니다.

00:10:20.000 --> 00:10:24.000
우리는 또한 설정 번들을 열기 위해 버튼 동작을 변경해야 합니다.

00:10:24.000 --> 00:10:40.000
이것은 사용자가 드라이버를 활성화할 수 있도록 설정으로 데려갈 것이다.

00:10:40.000 --> 00:10:52.000
마지막으로, 우리는 사용자가 설정에서 드라이버를 활성화해야 한다는 것을 분명히 하기 위해 버튼 텍스트를 변경합니다.

00:10:52.000 --> 00:10:55.000
이것이 실제로 실행되는지 봅시다.

00:10:55.000 --> 00:11:01.000
우리는 우리가 디자인한 뷰를 가지고 있으며, 버튼을 누르면 설정 번들로 이동합니다.

00:11:01.000 --> 00:11:06.000
그런 다음 우리는 드라이버로 가서 널 드라이버를 활성화합니다.

00:11:06.000 --> 00:11:10.000
운전자가 주문형으로 출시한다는 것을 명심하는 것이 중요하다.

00:11:10.000 --> 00:11:17.000
설정에서 드라이버를 활성화했지만, 하드웨어 장치가 iPad에 연결되어 있을 때만 드라이버가 실행되기 시작합니다.

00:11:17.000 --> 00:11:23.000
드라이버가 실행되기 시작하면, Xcode 무선 디버깅을 사용하여 디버거를 연결할 수 있습니다.

00:11:23.000 --> 00:11:31.000
그렇게 하려면, Xcode의 디버그 메뉴로 이동하여 프로세스에 첨부한 다음 NullDriver 프로세스를 선택합니다.

00:11:31.000 --> 00:11:36.000
일단 첨부되면, 중단점을 설정하거나 실행을 일시 중지할 수 있습니다.

00:11:36.000 --> 00:11:39.000
여기, 나는 우리 타이머에 중단점을 설정했어.

00:11:39.000 --> 00:11:46.000
나는 우리의 타이머가 몇 번이나 호출되었는지 보기 위해 타이머카운트를 인쇄할 것이다.

00:11:46.000 --> 00:11:54.000
디버깅이 완료되면, Xcode의 디버그 메뉴를 사용하여 드라이버 프로세스에서 분리하세요.

00:11:54.000 --> 00:11:57.000
그래서 이제 우리는 운전사가 있어.

00:11:57.000 --> 00:12:00.000
하지만 운전자는 그 자체로는 그다지 유용하지 않다.

00:12:00.000 --> 00:12:03.000
그것은 시스템의 나머지 부분과 통신해야 한다.

00:12:03.000 --> 00:12:07.000
AudioDriverKit과 같은 일부 DriverKit 프레임워크는 이를 처리합니다.

00:12:07.000 --> 00:12:17.000
하지만 하드웨어를 위한 사용자 지정 제어판 앱을 만드는 것과 같이 좀 더 진보된 것을 해야 한다면, 앱이 드라이버와 통신할 수 있어야 합니다.

00:12:17.000 --> 00:12:21.000
이것이 사용자 고객이 당신이 할 수 있도록 허용하는 것입니다.

00:12:21.000 --> 00:12:27.000
그들은 당신이 자신만의 인터페이스를 정의할 수 있게 해주며, 앱과 운전자 통신을 가능하게 합니다.

00:12:27.000 --> 00:12:30.000
앱은 IOKit.framework를 사용하여 사용자 클라이언트를 엽니다.

00:12:30.000 --> 00:12:38.000
이것이 어떻게 작동하는지에 대한 예는 developer.apple.com의 샘플 코드를 참조하십시오.

00:12:38.000 --> 00:12:41.000
그래서 우리는 앱이 드라이버와 통신할 수 있다는 것을 알고 있다.

00:12:41.000 --> 00:12:43.000
하지만 보안을 염두에 두는 것이 중요하다.

00:12:43.000 --> 00:12:50.000
운전자는 특권이 있기 때문에, 우리는 모든 앱이 운전자와 통신하는 것을 허용하고 싶지 않습니다.

00:12:50.000 --> 00:13:01.000
macOS에서 앱은 드라이버킷 사용자 클라이언트 액세스 권한이 필요하며, 값은 허용된 드라이버 번들 식별자의 배열입니다.

00:13:01.000 --> 00:13:07.000
iPadOS에서, 우리는 운전자와 통신이라는 새로운 자격을 추가했습니다.

00:13:07.000 --> 00:13:11.000
그것은 macOS 사용자 클라이언트 자격을 대체합니다.

00:13:11.000 --> 00:13:18.000
이 자격은 앱에 사용자 클라이언트를 드라이버에게 열 수 있는 기능을 부여합니다.

00:13:18.000 --> 00:13:27.000
드라이버와의 통신 권한을 앱에 수동으로 추가하려면, 여기에 XML 권한 문자열이 있습니다.

00:13:27.000 --> 00:13:29.000
우리는 또한 Xcode에서 이 자격을 추가할 수 있습니다.

00:13:29.000 --> 00:13:35.000
Xcode에서, 우리는 서명과 기능으로 이동한 다음, 새로운 기능을 추가합니다.

00:13:35.000 --> 00:13:43.000
그런 다음, 우리는 "운전자와의 소통"을 검색하고 앱에 기능을 추가할 수 있습니다.

00:13:43.000 --> 00:13:50.000
사용자 클라이언트의 또 다른 사용 사례는 다른 개발자의 앱이 드라이버와 상호 작용할 수 있도록 하는 것입니다.

00:13:50.000 --> 00:13:59.000
따라서 이 경우, 앱과 드라이버가 있고 다른 개발자의 앱을 포함한 다른 앱에 서비스를 제공하고 싶다고 가정해 봅시다.

00:13:59.000 --> 00:14:03.000
DriverKit 사용자 클라이언트도 이를 지원합니다.

00:14:03.000 --> 00:14:09.000
운전자와 통신해야 하는 각 앱은 운전자 자격과 통신해야 합니다.

00:14:09.000 --> 00:14:13.000
운전자는 제3자 사용자 클라이언트 권한 허용이 필요합니다.

00:14:13.000 --> 00:14:20.000
이를 통해 다른 팀 식별자로 구축된 앱은 사용자 클라이언트를 드라이버에게 열 수 있습니다.

00:14:20.000 --> 00:14:25.000
이 자격이 없으면, 같은 팀의 앱만 운전자와 통신할 수 있습니다.

00:14:25.000 --> 00:14:34.000
제3자 사용자 클라이언트 권한 허용을 수동으로 드라이버에 추가하려면, 여기에 XML 권한 문자열이 있습니다.

00:14:34.000 --> 00:14:42.000
또는 드라이버의 서명 및 기능으로 이동하여 Xcode에서 이 기능을 추가할 수 있습니다.

00:14:42.000 --> 00:14:51.000
이 새로운 사용자 클라이언트 자격은 개발을 위해 공개되어 있으며, 이는 승인 없이 오늘 사용할 수 있다는 것을 의미합니다.

00:14:51.000 --> 00:14:56.000
배포를 위해 이러한 자격을 요청하려면, 개발자 웹사이트를 참조하십시오.

00:14:56.000 --> 00:15:01.000
DriverKit 드라이버는 또한 앱 업데이트에 중요한 영향을 미친다.

00:15:01.000 --> 00:15:07.000
자동 앱 업데이트는 사용자가 항상 최신 버전의 앱을 받을 수 있도록 합니다.

00:15:07.000 --> 00:15:12.000
그러나, 드라이버가 포함된 앱의 경우, 업데이트 프로세스는 약간 다르게 작동합니다.

00:15:12.000 --> 00:15:18.000
앱 스토어에 앱 버전 1을 배포한다고 가정해 봅시다.

00:15:18.000 --> 00:15:26.000
그런 다음, iPad에 번들 드라이버와 함께 앱을 설치하고 설정에서 드라이버를 활성화하세요.

00:15:26.000 --> 00:15:38.000
드라이버의 하드웨어 장치를 연결하면 드라이버가 실행되기 시작하고, 드라이버가 실행을 시작하면 앱이 사용자 클라이언트를 사용하여 드라이버와 통신을 시작할 수 있습니다.

00:15:38.000 --> 00:15:44.000
이제, 앱에서 버그를 발견하고 버전 2를 App Store에 제출한다고 가정해 봅시다.

00:15:44.000 --> 00:15:52.000
자동 앱 업데이트로 인해, 버전 2 앱은 iPad에 자동으로 다운로드되고 설치됩니다.

00:15:52.000 --> 00:15:58.000
운전자 승인 상태는 업데이트를 통해 유지되므로, 운전자를 다시 승인할 필요가 없습니다.

00:15:58.000 --> 00:16:05.000
그러나, 하드웨어가 여전히 연결되어 있고, 버전 1 드라이버가 여전히 실행되고 있다는 것을 주목하세요.

00:16:05.000 --> 00:16:11.000
드라이버 버전 2는 앱 업데이트와 함께 다운로드되었지만 실행을 시작하지 않습니다.

00:16:11.000 --> 00:16:20.000
이전 드라이버가 계속 실행되기 때문에, 버전 2 앱은 버전 1 드라이버와 통신해야 할 수도 있습니다.

00:16:20.000 --> 00:16:31.000
하드웨어 장치의 플러그를 뽑으면 드라이버가 실행을 멈추므로 이제 드라이버 버전 1이 완료되고 드라이버를 버전 2로 업데이트할 수 있습니다.

00:16:31.000 --> 00:16:41.000
이제, 장치를 다시 연결하면, 버전 2 드라이버를 시작하고, 이제 앱이 새 드라이버와 통신하고 있습니다.

00:16:41.000 --> 00:16:47.000
요약하자면: 앱은 자동 앱 업데이트로 언제든지 업데이트됩니다.

00:16:47.000 --> 00:16:51.000
장치의 플러그를 뽑은 후 드라이버가 업데이트됩니다.

00:16:51.000 --> 00:16:55.000
그리고 당신의 앱은 오래된 운전자와 통신할 수 있습니다.

00:16:55.000 --> 00:17:01.000
앱과 드라이버가 준비되면, App Store에 제출할 수 있습니다.

00:17:01.000 --> 00:17:05.000
드라이버는 DriverKit을 지원하는 장치에서만 실행할 수 있습니다.

00:17:05.000 --> 00:17:16.000
앱이 드라이버만 설치하는 경우와 같이 앱을 해당 장치로 제한하려면, 앱의 UIRequiredDeviceCapabilities에 DriverKit을 추가하십시오.

00:17:16.000 --> 00:17:22.000
이렇게 하면 사용자가 DriverKit을 지원하지 않는 장치에 앱을 설치하는 것을 방지할 수 있습니다.

00:17:22.000 --> 00:17:29.000
또한 앱과 드라이버가 하드웨어 장치에서 어떻게 작동하는지 보여주는 비디오를 앱 리뷰에 제출하는 것이 좋습니다.

00:17:29.000 --> 00:17:32.000
그래서 그것은 iPad의 DriverKit이다.

00:17:32.000 --> 00:17:42.000
이제 USB, PCI 및 오디오 드라이버를 M1로 iPad로 가져오고 App Store의 앱 내부에 해당 드라이버를 제공할 수 있습니다.

00:17:42.000 --> 00:17:46.000
그리고 이미 운전자가 있다면, 그것을 iPad로 가져오는 것은 쉽습니다.

00:17:46.000 --> 00:17:53.000
우리는 개발자들이 iPad에서 DriverKit을 사용해 보고 피드백 어시스턴트를 사용하여 피드백을 제공할 것을 권장합니다.

00:17:53.000 --> 23:59:59.000
봐줘서 고마워.

