WEBVTT

00:00:00.000 --> 00:00:03.000
♪ 부드러운 기악 힙합 음악 ♪

00:00:03.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:13.000
"효율성이 기다리고 있습니다: SwiftUI의 백그라운드 작업"에 오신 것을 환영합니다.

00:00:13.000 --> 00:00:17.000
저는 watchOS 프레임워크 팀의 엔지니어인 존 갤러거입니다.

00:00:17.000 --> 00:00:26.000
이 강연에서, 우리는 Swift Concurrency를 사용하여 모든 Apple 플랫폼에서 일관된 방식으로 백그라운드 작업을 처리하기 위한 새로운 SwiftUI API에 대해 배우게 될 것입니다.

00:00:26.000 --> 00:00:36.000
우리는 배경 작업을 사용하는 폭풍우가 몰아치는 날에 하늘 사진을 찍는 앱인 Stormy라는 샘플 앱을 설명하는 것으로 시작할 것입니다.

00:00:36.000 --> 00:00:44.000
그런 다음, 우리는 앱이 백그라운드 작업을 어떻게 사용하는지, 그리고 백그라운드 작업이 후드 아래에서 어떻게 작동하는지에 대해 자세히 알아볼 것입니다.

00:00:44.000 --> 00:00:52.000
다음으로, 우리는 SwiftUI의 새로운 API를 사용하여 백그라운드 작업을 처리하는 방법을 배울 것입니다.

00:00:52.000 --> 00:01:03.000
그리고 마지막으로, 우리는 API가 Swift Concurrency를 사용하여 백그라운드 작업을 그 어느 때보다 쉽게 처리하는 방법을 검토할 것입니다.

00:01:03.000 --> 00:01:19.000
새로운 API는 Mac에서 실행되는 iOS 앱을 포함하여 watchOS, iOS, tvOS, Mac Catalyst 및 위젯에서 공유되며, 이는 한 플랫폼의 백그라운드 작업을 처리하는 데 배우는 개념과 패턴이 다른 플랫폼에서 수행하는 작업에 적용될 수 있음을 의미합니다.

00:01:19.000 --> 00:01:29.000
스위프트 동시성을 활용하여, 새로운 API는 깊이 중첩된 완료 핸들러와 콜백뿐만 아니라 종종 부작용이었던 많은 변경 가능한 상태의 필요성을 줄인다.

00:01:29.000 --> 00:01:40.000
Swift Concurrency의 기본 작업 취소는 애플리케이션이 시스템에 의해 백그라운드에서 종료되는 것을 피하기 위해 적시에 작업을 정상적으로 완료할 수 있도록 도와줍니다.

00:01:40.000 --> 00:01:49.000
구름 속에 머리를 두는 것을 좋아하는 사람들을 위해, 우리는 사용자가 밖에 폭풍우가 몰아칠 때 하늘의 사진을 찍도록 상기시키는 스토미라는 앱을 만들 것입니다.

00:01:49.000 --> 00:01:56.000
이 앱은 폭풍우가 몰아치는 날 정오에 사용자가 하늘 사진을 찍도록 요청하는 알림을 표시할 것이다.

00:01:56.000 --> 00:02:03.000
사용자가 알림을 탭하면, 그들은 미래의 감탄을 위해 프로필에 업로드하기 위해 하늘 사진을 찍을 것이다.

00:02:03.000 --> 00:02:07.000
우리는 이 사진을 배경에 업로드할 것이다.

00:02:07.000 --> 00:02:11.000
업로드가 완료되면 앱은 또 다른 알림을 보낼 것이다.

00:02:11.000 --> 00:02:15.000
백그라운드 작업이 어떻게 우리가 이것을 할 수 있는지 알아봅시다.

00:02:15.000 --> 00:02:23.000
이 다이어그램에서, 우리는 배경 작업을 활용하여 폭풍우가 몰아치는 날에만 알림이 어떻게 전송되는지 높은 수준에서 검토할 것입니다.

00:02:23.000 --> 00:02:36.000
우리는 왼쪽에 막대가 있는 포그라운드 애플리케이션 런타임을 나타내고, 중앙에 막대가 있는 백그라운드 애플리케이션 런타임을 나타내며, 시스템은 오른쪽에 표시됩니다.

00:02:36.000 --> 00:02:46.000
우리 앱이 사용자에 의해 포그라운드로 처음 출시될 때, 우리는 정오에 백그라운드 앱 새로 고침 작업을 예약할 수 있는 첫 번째 기회를 잡을 수 있습니다.

00:02:46.000 --> 00:02:57.000
그런 다음, 사용자가 앱을 떠나고 앱이 일시 중지되면, 시스템은 우리가 예약한 시간에 백그라운드에서 애플리케이션을 다시 깨우는 것을 알게 될 것입니다.

00:02:57.000 --> 00:03:07.000
우리는 정오에 작업을 예약했기 때문에, 시스템이 백그라운드에서 앱을 깨우고 백그라운드 앱 새로 고침 작업을 보낼 때입니다.

00:03:07.000 --> 00:03:16.000
이 백그라운드 런타임으로, 우리는 외부에 폭풍우가 몰아치는지 알아내야 하며, 만약 그렇다면, 사용자에게 알림을 보내야 합니다.

00:03:16.000 --> 00:03:22.000
우선, 우리는 현재 날씨를 확인하기 위해 기상 서비스에 네트워크 요청을 할 것입니다.

00:03:22.000 --> 00:03:30.000
URLSession이 백그라운드로 예약되면, 애플리케이션은 네트워크 요청이 완료될 때까지 일시 중지하고 기다릴 수 있습니다.

00:03:30.000 --> 00:03:41.000
날씨 데이터에 대한 백그라운드 네트워크 요청이 완료되면, 우리의 애플리케이션은 새로운 URLSession 백그라운드 작업과 함께 백그라운드 런타임을 다시 받게 될 것입니다.

00:03:41.000 --> 00:03:55.000
날씨 데이터 요청의 결과로, 우리의 애플리케이션은 외부에 폭풍우가 몰아치는지 여부를 알고 사용자에게 하늘 사진을 찍으라는 알림을 보낼지 여부를 선택할 수 있습니다.

00:03:55.000 --> 00:04:02.000
이제 URLSession 작업에 대한 작업이 완료되었습니다. 시스템은 다시 한 번 애플리케이션을 일시 중지할 수 있습니다.

00:04:02.000 --> 00:04:07.000
단일 배경 작업의 세부 사항에 대해 자세히 알아보고 어떻게 작동하는지 봅시다.

00:04:07.000 --> 00:04:14.000
그렇게 하기 위해, 우리는 단일 앱 새로 고침 백그라운드 작업의 수명 주기를 자세히 살펴볼 것입니다.

00:04:14.000 --> 00:04:19.000
여기서 조금 확대해 봅시다.

00:04:19.000 --> 00:04:25.000
먼저, 시스템은 애플리케이션을 깨우고 앱 새로 고침 백그라운드 작업을 보낼 것입니다.

00:04:25.000 --> 00:04:32.000
그런 다음, 여전히 백그라운드에서, 우리는 외부에 폭풍우가 몰아치는지 확인하기 위해 네트워크 요청을 한다.

00:04:32.000 --> 00:04:41.000
이상적으로, 우리의 네트워크 요청은 애플리케이션이 앱 새로 고침을 위해 할당된 백그라운드 런타임 내에서 완료됩니다.

00:04:41.000 --> 00:04:47.000
네트워크 응답을 받으면, 즉시 알림을 게시하고 싶습니다.

00:04:47.000 --> 00:04:56.000
알림이 게시됨에 따라, 우리는 앱 새로 고침 중에 해야 할 모든 것을 완료했으며 시스템은 애플리케이션을 다시 일시 중지할 수 있습니다.

00:04:56.000 --> 00:05:02.000
하지만 날씨 데이터에 대한 우리의 네트워크 요청이 제 시간에 완료되지 않을 때는 어떨까요?

00:05:02.000 --> 00:05:13.000
앱이 현재 작업의 백그라운드 런타임에서 부족하면, 시스템은 앱에 시간이 부족하다는 신호를 보내 이 상황을 우아하게 처리할 수 있는 기회를 제공합니다.

00:05:13.000 --> 00:05:24.000
애플리케이션이 런타임이 만료되기 전에 백그라운드 작업을 완료했음을 알리지 않으면, 애플리케이션은 시스템에 의해 종료되고 향후 백그라운드 작업 요청을 위해 제한될 수 있습니다.

00:05:24.000 --> 00:05:39.000
이 경우, 우리는 네트워크 요청이 백그라운드 네트워크 요청인지 확인해야 하며, 이를 통해 앱 새로 고침 작업을 즉시 완료하고 네트워크 요청이 완료되면 추가 백그라운드 런타임을 위해 다시 깨어날 수 있습니다.

00:05:39.000 --> 00:05:45.000
백그라운드 URLSession이 예약되면, 시스템은 애플리케이션을 다시 일시 중지할 수 있습니다.

00:05:45.000 --> 00:05:52.000
이제 SwiftUI의 BackgroundTask API가 Stormy를 구축하는 데 어떻게 도움이 될 수 있는지 알아봅시다.

00:05:52.000 --> 00:05:56.000
시작하려면, 우리는 기본적인 지원서가 필요할 것이다.

00:05:56.000 --> 00:06:02.000
그런 다음, 우리는 내일 정오에 백그라운드 앱 새로 고침을 예약하는 기능을 작성할 것입니다.

00:06:02.000 --> 00:06:07.000
먼저, 우리는 내일 정오를 나타내는 날짜를 만든다.

00:06:07.000 --> 00:06:15.000
그런 다음, 우리는 내일 정오의 가장 빠른 시작 날짜로 백그라운드 앱 새로 고침 요청을 만들고 스케줄러에 제출합니다.

00:06:15.000 --> 00:06:21.000
이것이 시스템이 내일 정오에 우리의 신청서를 깨우라고 말하는 것이다.

00:06:21.000 --> 00:06:29.000
사용자가 처음 애플리케이션을 열고 정오에 매일 폭풍 알림을 요청할 때 이 기능을 호출하고 싶습니다.

00:06:29.000 --> 00:06:38.000
새로운 백그라운드 작업 장면 수정자를 사용하여 예약한 백그라운드 작업에 해당하는 핸들러를 등록할 수 있습니다.

00:06:38.000 --> 00:06:46.000
앱이 백그라운드 작업을 받으면, 수신된 백그라운드 작업과 일치하는 이 수정자로 등록된 모든 블록이 실행됩니다.

00:06:46.000 --> 00:06:57.000
이 경우, 우리는 원하는 날짜에 백그라운드에서 제한된 양의 런타임을 애플리케이션에 제공하기 위해 미리 예약할 수 있는 appRefresh 작업 유형을 사용했습니다.

00:06:57.000 --> 00:07:10.000
백그라운드 작업 수정자에서 요청과 핸들러에 대한 동일한 식별자를 사용하면 애플리케이션에서 해당 작업을 수신할 때 호출할 핸들러를 식별할 수 있습니다.

00:07:10.000 --> 00:07:24.000
우리가 내일로 다시 예정되어 있는지 확인하기 위해, 우리는 내일 정오에 백그라운드 런타임을 다시 예약하기 위해 방금 작성한 scheduleAppRefresh 기능을 호출하여 백그라운드 작업을 시작할 것입니다.

00:07:24.000 --> 00:07:36.000
이제 정오에 백그라운드 런타임이 반복되고 있기 때문에, 우리는 외부에서 폭풍우가 몰아치는지 확인하고 await Swift 키워드를 사용하여 결과를 기다리도록 네트워크 요청을 합니다.

00:07:36.000 --> 00:07:46.000
그런 다음, 우리의 네트워크 요청이 돌아왔고 밖이 실제로 폭풍우가 몰아친다면, 우리는 사용자에게 하늘 사진을 업로드하라는 알림을 보내기를 기다리고 있습니다.

00:07:46.000 --> 00:07:58.000
폐쇄 본문이 돌아오면, 시스템에 의해 애플리케이션에 할당된 기본 백그라운드 작업은 암시적으로 완료로 표시되며, 시스템은 애플리케이션을 다시 일시 중지할 수 있습니다.

00:07:58.000 --> 00:08:08.000
여기서, Swift Concurrency를 사용하면 작업이 완료되었을 때 명시적인 콜백 없이 백그라운드 작업에서 잠재적으로 장기 실행 작업을 수행할 수 있습니다.

00:08:08.000 --> 00:08:16.000
알림 추가와 같은 Apple 플랫폼의 많은 API는 이미 비동기 작업을 위한 Swift Concurrency를 지원합니다.

00:08:16.000 --> 00:08:29.000
여기서, notifyForPhoto 비동기 기능은 UserNotificationCenter에 있는 비동기 addNotification 방법을 사용하여 간단한 방식으로 구현할 수 있습니다.

00:08:29.000 --> 00:08:38.000
Swift Concurrency와 async/await가 어떻게 우리를 위해 힘든 일을 하고 백그라운드 작업을 그 어느 때보다 쉽게 처리할 수 있도록 하는지 알아봅시다.

00:08:38.000 --> 00:08:43.000
우리가 참조해 온 비동기 isStormy 함수를 작성해 봅시다.

00:08:43.000 --> 00:08:49.000
이 비동기 기능은 외부 날씨를 확인하는 네트워크 요청을 해야 할 것이다.

00:08:49.000 --> 00:08:56.000
우선, 우리는 공유 URLSession을 받고 날씨 데이터 요청을 인스턴스화할 것입니다.

00:08:56.000 --> 00:09:06.000
URLSession은 Swift Concurrency를 채택했으며 비동기 컨텍스트에서 기다릴 수 있는 네트워크에서 데이터를 다운로드할 수 있는 방법이 있습니다.

00:09:06.000 --> 00:09:12.000
네트워크 응답을 통해, 우리는 날씨 데이터를 읽고 결과를 반환할 수 있습니다.

00:09:12.000 --> 00:09:19.000
하지만 런타임이 만료되기 전에 애플리케이션이 네트워크 요청을 완료할 수 없을 때는 어떨까요?

00:09:19.000 --> 00:09:34.000
이 경우, 우리는 URLSession을 백그라운드 세션으로 설정하고 URLSession 백그라운드 작업을 사용하여 애플리케이션에 실행 이벤트를 보낼 수 있도록 하고 싶었습니다.

00:09:34.000 --> 00:09:37.000
우리 코드로 돌아가.

00:09:37.000 --> 00:09:41.000
우리는 공유 URLSession을 사용했다.

00:09:41.000 --> 00:09:51.000
대신, sessionSendsLaunchEvents 속성을 true로 설정한 백그라운드 구성에서 URLSession을 만들어야 합니다.

00:09:51.000 --> 00:10:02.000
이것은 앱이 일시 중지된 경우에도 일부 네트워크 요청을 실행해야 하며 요청이 완료되면 URLSession 백그라운드 작업을 위해 앱을 깨워야 한다고 시스템에 알려줍니다.

00:10:02.000 --> 00:10:16.000
watchOS에서 백그라운드에서 실행되는 앱의 모든 네트워크 요청은 백그라운드 URLSessions를 통해 요청되어야 하기 때문에 이것은 watchOS에서 특히 중요합니다.

00:10:16.000 --> 00:10:18.000
하지만 우리는 아직 끝나지 않았어.

00:10:18.000 --> 00:10:28.000
백그라운드 작업 런타임이 만료되면, 시스템은 백그라운드 작업 수정자에 제공된 클로저를 실행하는 비동기 작업을 취소한다는 것을 기억하십시오.

00:10:28.000 --> 00:10:38.000
이것은 우리의 백그라운드 런타임이 만료될 때 여기에서 이루어진 네트워크 요청도 취소된다는 것을 의미합니다.

00:10:38.000 --> 00:10:47.000
취소에 대응하고 처리하기 위해, 우리는 Swift Concurrency에 내장된 withTaskCancellationHandler 기능을 사용할 수 있습니다.

00:10:47.000 --> 00:10:57.000
결과를 직접 기다리는 대신, 우리는 다운로드를 withTaskCancellationHandler 호출에 넣고 이것도 기다립니다.

00:10:57.000 --> 00:11:03.000
withTaskCancellationHandler로 전달된 첫 번째 블록은 우리가 실행하고 기다리고 싶은 비동기 절차입니다.

00:11:03.000 --> 00:11:10.000
두 번째 onCancel 후행 폐쇄는 작업이 취소될 때 실행되는 코드입니다.

00:11:10.000 --> 00:11:26.000
여기서, 런타임 만료로 인해 즉각적인 네트워크 요청이 취소되면, 우리는 네트워크 요청을 백그라운드 다운로드 작업으로 홍보하여 이력서를 호출할 수 있으며, 앱이 일시 중지된 경우에도 지속되는 백그라운드 다운로드를 트리거합니다.

00:11:26.000 --> 00:11:41.000
이 코드는 동일한 URLSession을 사용하여 둘 다 백업하기 때문에 기본 네트워크 요청을 두 번 만들지 않으며, URLSession은 후드 아래의 프로세스 중 요청을 중복 제거합니다.

00:11:41.000 --> 00:11:48.000
마지막으로, 우리는 애플리케이션이 백그라운드 URLSession에서 실행을 처리하도록 설정되어 있는지 확인해야 합니다.

00:11:48.000 --> 00:11:54.000
백그라운드 작업 수정자를 다시 사용할 수 있지만, 이번에는 URLSession 작업 유형으로 사용할 수 있습니다.

00:11:54.000 --> 00:12:08.000
이전에 만든 백그라운드 URLSession 구성에 동일한 식별자를 사용하여 특정 URLSession이 백그라운드 작업을 생성할 때만 이 블록이 호출되도록 할 수 있습니다.

00:12:08.000 --> 00:12:20.000
우리는 백그라운드 작업을 처리하기 위한 새로운 통합 SwiftUI API를 살펴보고 Swift Concurrency가 어떻게 그 어느 때보다 쉽게 작업 완료 및 만료를 관리할 수 있는지 발견했습니다.

00:12:20.000 --> 00:12:29.000
Swift Concurrency에 대한 자세한 내용은 WWDC 2021의 "Meet Async/await in Swift" 토크를 확인하세요.

00:12:29.000 --> 00:12:37.000
그리고 SwiftUI의 동시성에 대해 자세히 알아보려면, WWDC 2021의 "SwiftUI에서 동시성 발견"을 추천합니다.

00:12:37.000 --> 00:12:41.000
"효율성이 기다리고 있습니다: SwiftUI의 백그라운드 작업"을 시청해 주셔서 감사합니다.

00:12:41.000 --> 23:59:59.000
♪

