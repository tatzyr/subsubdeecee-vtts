WEBVTT

00:00:00.000 --> 00:00:09.000
♪ 기악 힙합 음악 ♪

00:00:09.000 --> 00:00:11.000
안녕, 내 이름은 필립이야.

00:00:11.000 --> 00:00:15.000
스위프트는 오픈 소스 패키지 카탈로그가 늘어나고 있다.

00:00:15.000 --> 00:00:20.000
최신 추가 기능 중 하나인 Swift Async Algorithms를 소개하게 되어 기쁩니다.

00:00:20.000 --> 00:00:26.000
이 패키지는 스위프트 컬렉션과 스위프트 알고리즘과 같은 다른 패키지와 함께 있다.

00:00:26.000 --> 00:00:35.000
Swift Async Algorithms 패키지는 AsyncSequence를 사용하여 시간이 지남에 따라 값을 처리하는 데 특별히 초점을 맞춘 알고리즘 세트입니다.

00:00:35.000 --> 00:00:40.000
하지만 우리가 그것에 들어가기 전에, 잠시 시간을 내어 AsyncSequence를 요약해 봅시다.

00:00:40.000 --> 00:00:45.000
AsyncSequence는 비동기적으로 생성된 값을 설명할 수 있는 프로토콜이다.

00:00:45.000 --> 00:00:50.000
기본적으로, 그것은 시퀀스와 비슷하지만, 두 가지 주요 차이점이 있다.

00:00:50.000 --> 00:00:58.000
반복기의 다음 함수는 비동기적이며, 스위프트 동시성을 사용하여 값을 제공할 수 있다.

00:00:58.000 --> 00:01:03.000
또한 스위프트의 던지기 효과를 사용하여 잠재적인 실패를 처리할 수 있습니다.

00:01:03.000 --> 00:01:09.000
그리고 시퀀스와 마찬가지로, for-await-in 구문을 사용하여 반복할 수 있습니다.

00:01:09.000 --> 00:01:15.000
간단히 말해서, 시퀀스를 사용하는 방법을 알고 있다면, 당신은 이미 AsyncSequence를 사용하는 방법을 알고 있습니다.

00:01:15.000 --> 00:01:24.000
이제, AsyncSequence가 도입되었을 때, 우리는 비동기 버전과 함께 Sequence로 찾을 수 있는 거의 모든 도구를 추가했습니다.

00:01:24.000 --> 00:01:30.000
지도, 필터, 감소 등과 같은 알고리즘이 있습니다.

00:01:30.000 --> 00:01:41.000
스위프트 비동기 알고리즘 패키지는 고급 알고리즘을 통합하고 시계와 상호 운용하여 정말 강력한 것을 제공함으로써 한 걸음 더 나아갑니다.

00:01:41.000 --> 00:01:48.000
이것은 스위프트 동시성을 강화하는 AsyncSequence 알고리즘의 오픈 소스 패키지입니다.

00:01:48.000 --> 00:01:51.000
작년에 우리는 스위프트 알고리즘 패키지를 도입했다.

00:01:51.000 --> 00:01:55.000
그 알고리즘의 사용을 보여주기 위해, 우리는 메시징 앱을 만들었다.

00:01:55.000 --> 00:02:00.000
이것은 당신이 그 패키지로 할 수 있는 풍부하고 강력한 것들의 좋은 예였다.

00:02:00.000 --> 00:02:07.000
우리는 스위프트 동시성을 사용하기 위해 앱을 마이그레이션할 수 있는 정말 좋은 기회가 많다고 결정했습니다.

00:02:07.000 --> 00:02:16.000
비동기 알고리즘 중 몇 가지만 강조하기 위해, 우리가 사용한 몇 가지 사항과 작동 방식을 안내해드리겠습니다.

00:02:16.000 --> 00:02:21.000
우선, 우리는 여러 입력 AsyncSequences로 작업하기 위한 알고리즘 제품군을 가지고 있습니다.

00:02:21.000 --> 00:02:27.000
이것들은 AsyncSequences를 다른 방식으로 결합하는 데 초점을 맞춘 알고리즘이다.

00:02:27.000 --> 00:02:36.000
하지만 그들은 모두 하나의 특성을 공유합니다: 그들은 여러 개의 입력 AsyncSequences를 취하고 하나의 출력 AsyncSequence를 생성합니다.

00:02:36.000 --> 00:02:40.000
당신이 이미 익숙할 수도 있는 것은 Zip입니다.

00:02:40.000 --> 00:02:48.000
Zip 알고리즘은 여러 입력을 받아 각 베이스에서 결과의 튜플을 생성하도록 반복합니다.

00:02:48.000 --> 00:02:52.000
Zip에 대한 각 입력은 Zip이 구성된 베이스이다.

00:02:52.000 --> 00:03:04.000
비동기 Zip 알고리즘은 표준 라이브러리의 Zip 알고리즘과 마찬가지로 작동하지만, 각 베이스를 동시에 반복하고 반복할 때 오류가 발생하면 오류를 다시 발생시킨다.

00:03:04.000 --> 00:03:10.000
이제, 재투송 오류로 동시 반복을 달성하는 것은 오히려 관련될 수 있다.

00:03:10.000 --> 00:03:15.000
하지만 스위프트 비동기 알고리즘 패키지는 메시징 앱에서 우리를 위해 모든 것을 처리했다.

00:03:15.000 --> 00:03:26.000
우리는 이전에 비동기적으로 비디오 녹화의 미리보기를 생성하고 효율적인 저장 및 전송을 위해 비디오를 여러 크기로 트랜스코딩하는 많은 코드를 조정했습니다.

00:03:26.000 --> 00:03:33.000
Zip을 사용하면 트랜스코딩된 비디오를 서버로 보낼 때 미리보기를 받을 수 있습니다.

00:03:33.000 --> 00:03:39.000
Zip은 동시이기 때문에, 트랜스코딩이나 미리보기는 서로를 지연시키지 않을 것이다.

00:03:39.000 --> 00:03:41.000
하지만 이것은 조금 더 나아간다.

00:03:41.000 --> 00:03:55.000
Zip 자체는 어느 쪽이 값을 먼저 생성했는지 아닌지에 대한 선호도가 없으므로, 비디오가 먼저 생성되거나 미리보기가 될 수 있으며, 어느 쪽이든, 다른 쪽이 완전한 튜플을 보내기를 기다릴 것입니다.

00:03:55.000 --> 00:04:04.000
Zip은 값의 튜플을 구성하기 위해 각 측면을 동시에 기다리고 있기 때문에 함께 업로드할 수 있도록 쌍을 기다릴 수 있습니다.

00:04:04.000 --> 00:04:10.000
우리는 들어오는 메시지를 AsyncSequence로 모델링하는 것이 많은 의미가 있다는 결론에 도달했습니다.

00:04:10.000 --> 00:04:20.000
그래서 우리는 AsyncStream을 사용하여 그 메시지를 처리하기로 결정했습니다. 왜냐하면 그것은 순서를 보존하고 콜백을 메시지의 AsyncSequence로 바꾸기 때문입니다.

00:04:20.000 --> 00:04:25.000
우리가 해결해야 할 요청된 기능 중 하나는 우리가 여러 계정을 지원하고 싶다는 것이다.

00:04:25.000 --> 00:04:36.000
그래서 각 계정은 들어오는 메시지의 AsyncStream을 생성하지만, 이것을 구현할 때, 우리는 그것들을 모두 하나의 단일 AsyncSequence로 함께 처리해야 합니다.

00:04:36.000 --> 00:04:41.000
이것은 우리가 그 AsyncSequences를 병합하기 위한 알고리즘이 필요하다는 것을 의미한다.

00:04:41.000 --> 00:04:49.000
고맙게도 스위프트 비동기 알고리즘 패키지에는 정확히 "병합"이라는 이름의 알고리즘이 있다.

00:04:49.000 --> 00:05:08.000
그것은 여러 AsyncSequences를 동시에 반복한다는 점에서 Zip과 유사하게 작동한다. 그러나 페어링된 튜플을 만드는 대신, 베이스가 동일한 요소 유형을 공유하고 기본 AsyncSequences를 해당 요소의 단일 AsyncSequence로 병합해야 합니다.

00:05:08.000 --> 00:05:13.000
반복될 때 측면 중 하나에서 생성된 첫 번째 요소를 취하여 작업을 병합합니다.

00:05:13.000 --> 00:05:23.000
특히 모든 기본 AsyncSequences가 반복자에서 nil을 반환할 때 더 이상 생성될 수 있는 값이 없을 때까지 계속 반복됩니다.

00:05:23.000 --> 00:05:27.000
베이스 중 하나라도 오류가 발생하면, 다른 반복은 취소됩니다.

00:05:27.000 --> 00:05:33.000
이것은 우리가 메시지의 AsyncSequences를 가져와 병합할 수 있게 해준다.

00:05:33.000 --> 00:05:43.000
이러한 결합 알고리즘은 값이 생성될 때 동시에 작동하지만, 때로는 실제로 시간 자체와 상호 작용하는 것이 유용하다.

00:05:43.000 --> 00:05:51.000
스위프트 비동기 알고리즘 패키지는 스위프트의 새로운 시계 API를 활용하여 시간과 함께 작동하는 알고리즘 제품군을 제공합니다.

00:05:51.000 --> 00:06:06.000
시간 자체는 정말 복잡한 주제가 될 수 있으며, 스위프트(5.7)의 새로운 기능은 시계, 인스턴트 및 지속 시간을 안전하고 일관성 있게 만드는 일련의 API입니다.

00:06:06.000 --> 00:06:13.000
시계 프로토콜은 주어진 순간 이후에 일어나는 방법과 지금의 개념을 생성하는 방법인 두 가지 기본을 정의한다.

00:06:13.000 --> 00:06:15.000
시계가 몇 개 내장되어 있다.

00:06:15.000 --> 00:06:20.000
더 일반적인 두 가지는 ContinuousClock과 SuspendingClock이다.

00:06:20.000 --> 00:06:28.000
ContinuousClock을 사용하여 측정되는 것의 상태에 관계없이 시간이 진행되는 스톱워치처럼 시간을 측정할 수 있습니다.

00:06:28.000 --> 00:06:35.000
반면에, SuspendingClock은 그 이름이 암시하는 것을 한다; 그것은 기계가 잠들 때 중단된다.

00:06:35.000 --> 00:06:45.000
우리는 앱의 새로운 클럭 API를 사용하여 기존 콜백 이벤트에서 클럭 슬립 기능으로 마이그레이션하여 마감일 이후에 해제 알림을 처리했습니다.

00:06:45.000 --> 00:06:55.000
우리는 우리가 지연시키고 싶은 초 수를 구체적으로 나타내는 기간 값을 추가하여 마감일을 만들 수 있었다.

00:06:55.000 --> 00:07:00.000
시계는 또한 작업 실행의 경과된 기간을 측정하는 몇 가지 편리한 방법을 가지고 있다.

00:07:00.000 --> 00:07:07.000
여기 제가 앞서 언급한 두 개의 일반적인 시계인 SuspendingClock과 ContinuousClock이 있습니다.

00:07:07.000 --> 00:07:12.000
아래는 측정되는 잠재적인 경과된 작업 기간을 보여주는 디스플레이입니다.

00:07:12.000 --> 00:07:20.000
이 두 시계의 주요 차이점은 기계가 잠들었을 때의 행동에서 비롯된다.

00:07:20.000 --> 00:07:36.000
이와 같은 긴 실행 작업의 경우, 우리가 여기서 했던 것처럼 작업을 일시 중지할 수 있지만, 실행을 재개할 때, ContinuousClock은 기계가 잠든 동안 진행되었지만 SuspendingClock은 그렇지 않았다.

00:07:36.000 --> 00:07:46.000
일반적으로, 이 차이는 실행 타이밍을 중단하여 애니메이션과 같은 것이 예상대로 작동하도록 하는 핵심 세부 사항이 될 수 있다.

00:07:46.000 --> 00:07:53.000
애니메이션과 같이 기계와 관련하여 시간과 상호 작용해야 한다면, SuspendingClock을 사용하세요.

00:07:53.000 --> 00:07:59.000
장치 앞에 있는 인간과 관련된 작업을 측정하는 것은 ContinuousClock에 더 적합합니다.

00:07:59.000 --> 00:08:07.000
따라서 인간과 관련된 절대적인 기간으로 지연해야 한다면, ContinuousClock을 사용하세요.

00:08:07.000 --> 00:08:21.000
스위프트 비동기 알고리즘 패키지는 이러한 새로운 시계, 인스턴트 및 기간 유형을 사용하여 시간과 관련하여 이벤트가 어떻게 처리되는지에 대한 많은 개념을 다루기 위한 일반 알고리즘을 구축합니다.

00:08:21.000 --> 00:08:27.000
우리의 메시징 앱에서, 우리는 이것들이 이벤트에 대한 정확한 제어를 제공하는 데 정말 도움이 된다는 것을 알았습니다.

00:08:27.000 --> 00:08:33.000
그것은 우리가 상호 작용을 제한하고 메시지를 효율적으로 버퍼링할 수 있게 해준다.

00:08:33.000 --> 00:08:38.000
아마도 우리가 시간을 활용한 가장 두드러진 영역은 메시지를 검색하는 것이었을 것이다.

00:08:38.000 --> 00:08:42.000
우리는 결과 채널을 관리하는 컨트롤러를 만들었습니다.

00:08:42.000 --> 00:08:47.000
채널 마샬은 검색 작업의 검색 결과를 UI로 되돌립니다.

00:08:47.000 --> 00:08:53.000
검색 작업 자체는 시간과 관련하여 몇 가지 구체적인 특성을 가져야 했다.

00:08:53.000 --> 00:08:59.000
우리는 서버에서 전송된 메시지 검색을 제한하는 것을 확실히 하고 싶었습니다.

00:08:59.000 --> 00:09:06.000
Debounce 알고리즘은 반복될 때 다음 값을 방출하기 전에 정지 기간을 기다린다.

00:09:06.000 --> 00:09:14.000
그것은 사건이 빨리 올 수 있다는 것을 의미하지만, 우리는 가치를 다루기 전에 조용한 기간을 기다리고 싶습니다.

00:09:14.000 --> 00:09:22.000
검색 필드의 사용자 입력이 빠르게 변경되면, 우리는 검색 컨트롤러가 각 변경 사항에 대한 검색 요청을 실행하지 않기를 바랍니다.

00:09:22.000 --> 00:09:29.000
대신, 우리는 타이핑이 완료될 가능성이 있는 조용한 기간을 확실히 기다리고 싶습니다.

00:09:29.000 --> 00:09:33.000
기본적으로, Debounce 알고리즘은 ContinuousClock을 사용합니다.

00:09:33.000 --> 00:09:40.000
이 경우, 우리는 아무 일도 일어나지 않은 동안 지정된 기간을 기다리게 하여 입력을 디바운스할 수 있습니다.

00:09:40.000 --> 00:09:46.000
시계와 지속 시간은 디바운싱에만 사용되는 것이 아니라, 다른 알고리즘에도 사용된다.

00:09:46.000 --> 00:09:52.000
우리가 정말 유용하다는 것을 알게 된 한 가지 영역은 서버로 메시지 배치를 보내는 것이었다.

00:09:52.000 --> 00:09:58.000
스위프트 알고리즘 패키지에는 값에 대한 알고리즘 세트가 있다.

00:09:58.000 --> 00:10:06.000
스위프트 비동기 알고리즘 패키지는 그것들을 제공하지만, 시계와 지속 시간과 상호 운용되는 일련의 버전도 추가합니다.

00:10:06.000 --> 00:10:12.000
청킹 알고리즘 제품군은 카운트, 시간 또는 콘텐츠별로 청크를 제어할 수 있게 해준다.

00:10:12.000 --> 00:10:20.000
이들 중 하나에서 오류가 발생하면, 그 오류는 다시 던져지므로, 우리의 코드는 실패와 관련하여 안전합니다.

00:10:20.000 --> 00:10:28.000
우리는 메시지 덩어리가 직렬화되고 특정 경과된 기간에 의해 전송되도록 하기 위해 "chunked(by:)" API를 사용했습니다.

00:10:28.000 --> 00:10:33.000
그렇게 하면, 우리 서버는 고객으로부터 효율적인 패킷을 받는다.

00:10:33.000 --> 00:10:39.000
우리는 이 API를 사용하여 500밀리초마다 메시지 배치를 만들 수 있었다.

00:10:39.000 --> 00:10:47.000
그렇게 하면, 누군가가 정말 흥분하고 정말 빠르게 타이핑한다면, 서버로 전송된 요청은 그룹화됩니다.

00:10:47.000 --> 00:10:54.000
컬렉션과 시퀀스로 작업할 때, 요소를 게으르게 처리하는 데 종종 유용하고 성능이 있다.

00:10:54.000 --> 00:11:00.000
AsyncSequence는 스위프트 표준 라이브러리에서 게으른 알고리즘이 작동하는 방식과 매우 비슷하게 작동합니다.

00:11:00.000 --> 00:11:08.000
하지만 그 게으른 알고리즘과 마찬가지로, 컬렉션의 세계로 돌아가야 할 때가 종종 있습니다.

00:11:08.000 --> 00:11:15.000
Swift Async Algorithms 패키지는 AsyncSequence를 사용하여 컬렉션을 구성하기 위한 이니셜라이저 세트를 제공합니다.

00:11:15.000 --> 00:11:23.000
이를 통해 유한한 것으로 알려진 입력 AsyncSequences로 사전, 세트 또는 배열을 구축할 수 있습니다.

00:11:23.000 --> 00:11:31.000
컬렉션 이니셜라이저를 사용하면 메시지 초기화로 변환을 구축하고 데이터 유형을 배열로 유지할 수 있습니다.

00:11:31.000 --> 00:11:38.000
스위프트 동시성을 사용하기 위해 업데이트를 사용할 수 있는 수많은 기능이 있었기 때문에 이것은 정말 유용했다.

00:11:38.000 --> 00:11:47.000
그리고 기존 데이터 구조를 유지함으로써, 우리는 앱의 일부를 점진적으로 마이그레이션할 수 있습니다.

00:11:47.000 --> 00:11:52.000
지금까지, 우리는 스위프트 비동기 알고리즘 패키지의 하이라이트 중 몇 가지만 검토했습니다.

00:11:52.000 --> 00:11:55.000
우리가 오늘 다룬 것보다 훨씬 더 많은 것이 있다.

00:11:55.000 --> 00:12:13.000
우리는 여러 비동기 시퀀스를 결합하고, 시간에 따라 속도를 제한하고, 물건을 덩어리로 나누는 것까지 다양한 알고리즘을 가지고 있지만, 그것들은 우리가 앱에서 광범위하게 사용하게 된 하이라이트일 뿐입니다.

00:12:13.000 --> 00:12:16.000
이 패키지는 그것들보다 훨씬 더 많은 것을 가지고 있다.

00:12:16.000 --> 00:12:27.000
그것은 버퍼링, 감소, 결합, 간헐적으로 값을 주입하는 것 등 다양합니다.

00:12:27.000 --> 00:12:39.000
스위프트 비동기 알고리즘 패키지는 시간이 지남에 따라 일을 처리하기 위한 알고리즘 세트를 가져와 앱에서 당신을 도울 수 있는 광범위한 고급 기능으로 확장합니다.

00:12:39.000 --> 00:12:40.000
시도해 봐.

00:12:40.000 --> 00:12:46.000
우리는 당신이 이것들로 무엇을 만드는지 발견하게 되어 정말 기쁘고, 그 흥분은 공유됩니다.

00:12:46.000 --> 00:12:50.000
이 패키지는 당신과 함께 공개적으로 개발되고 있습니다.

00:12:50.000 --> 00:12:53.000
시청해 주셔서 감사드리며, 남은 컨퍼런스를 즐기세요.

00:12:53.000 --> 23:59:59.000
♪ 기악 힙합 음악 ♪

