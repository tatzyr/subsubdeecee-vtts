WEBVTT

00:00:00.000 --> 00:00:13.000
앤디: 안녕.

00:00:13.000 --> 00:00:17.000
"데스크톱 수업 편집 상호 작용 채택"에 오신 것을 환영합니다.

00:00:17.000 --> 00:00:24.000
저는 UIKit 프레임워크 엔지니어인 앤디이고, 나중에 제 동료인 제임스와 합류할 것입니다.

00:00:24.000 --> 00:00:32.000
iPad는 간단하고 사용하기 쉬운 상호 작용을 손상시키지 않으면서 지속적으로 진화하고 있다.

00:00:32.000 --> 00:00:41.000
이 비디오에서는 앱을 더 많은 데스크톱 클래스로 변환할 흥미진진한 새로운 편집 상호 작용에 대해 배우게 될 것입니다.

00:00:41.000 --> 00:00:49.000
먼저, iOS 16에서 주요 안면 성형을 받은 새로운 편집 메뉴를 살펴볼 것입니다.

00:00:49.000 --> 00:00:55.000
나중에, 제임스는 새로운 시스템에 뛰어들어 경험을 찾고 대체할 것이다.

00:00:55.000 --> 00:01:06.000
iOS 16에서 편집 메뉴는 친숙하지만 더 인터랙티브하고 행동을 더 쉽게 발견할 수 있는 완전히 새로운 디자인을 특징으로 한다.

00:01:06.000 --> 00:01:12.000
편집 메뉴에는 이제 사용된 입력 방법에 따라 대체 프레젠테이션이 있습니다.

00:01:12.000 --> 00:01:26.000
터치 상호 작용의 경우, 편집 메뉴는 여전히 친숙한 컴팩트한 외관을 가지고 있지만, 페이징 동작이 개선되어 이전보다 더 많은 작업을 발견할 수 있습니다.

00:01:26.000 --> 00:01:38.000
매직 키보드 또는 트랙패드를 사용하면 더 많은 데스크톱 수업 경험을 위해 컨텍스트 메뉴가 보조 또는 오른쪽 클릭으로 표시됩니다.

00:01:38.000 --> 00:01:46.000
마찬가지로, iPhone의 터치 상호 작용에는 새로운 편집 메뉴가 표시됩니다.

00:01:46.000 --> 00:01:53.000
그리고 Mac Catalyst 앱의 경우, Mac 사용자가 익숙한 컨텍스트 메뉴가 제공됩니다.

00:01:53.000 --> 00:02:02.000
iOS 16에서 텍스트 편집 메뉴는 새로운 데이터 탐지기 통합으로 주요 파워업을 받습니다.

00:02:02.000 --> 00:02:13.000
여기에는 인라인 단위 및 통화 변환뿐만 아니라 선택한 텍스트에 따라 문맥 작업을 표시하는 스마트 조회가 포함됩니다.

00:02:13.000 --> 00:02:27.000
예를 들어, Safari에서 주소를 선택하면 기존 편집 메뉴 작업 위에 "길 찾기" 또는 "지도에서 열기"와 같은 지도 기반 작업을 얻을 수 있습니다.

00:02:27.000 --> 00:02:31.000
가장 좋은 점은, 입양이 필요하지 않다는 것이다!

00:02:31.000 --> 00:02:42.000
이러한 기능은 텍스트 상호 작용 보기, WebKit 및 Safari뿐만 아니라 PDFKit을 포함한 모든 텍스트 편집 메뉴에서 사용할 수 있습니다.

00:02:42.000 --> 00:02:55.000
텍스트 보기의 메뉴에 작업을 삽입하려면, 새로운 TextViewDelegate 방법을 구현하여 시스템 제공 작업으로 주어진 범위의 텍스트에 대해 표시된 메뉴를 사용자 정의하십시오.

00:02:55.000 --> 00:03:01.000
아무것도 사용자 정의할 필요가 없다면, 표준 시스템 메뉴를 얻기 위해 nil을 반환하세요.

00:03:01.000 --> 00:03:08.000
UITextFieldDelegate와 UITextInput에도 메뉴를 사용자 정의할 수 있는 유사한 방법이 있습니다.

00:03:08.000 --> 00:03:27.000
UIMenuController를 사용하여 메뉴 항목을 삽입하는 것은 이제 iOS 16에서 더 이상 사용되지 않으며, 대신 새로운 방법을 사용하여 텍스트 편집 메뉴에 메뉴 요소를 추가해야 합니다. 왜냐하면 우리가 가는 곳은 메뉴 컨트롤러가 필요하지 않기 때문입니다!

00:03:27.000 --> 00:03:32.000
다음은 몇 가지 사용자 지정 작업이 있는 텍스트 보기의 예입니다.

00:03:32.000 --> 00:03:41.000
일부 텍스트 선택에 메뉴가 표시되면, 시스템이 제안한 작업 후에 사용자 지정 "하이라이트" 및 "사진 삽입" 작업이 표시됩니다.

00:03:41.000 --> 00:03:47.000
하이라이트 액션을 선택하면 예상대로 텍스트에 하이라이트가 표시됩니다.

00:03:47.000 --> 00:04:01.000
다음으로, 강조할 것이 없는 텍스트 선택 없이 메뉴가 표시되면, 메뉴는 시스템이 제안한 작업 후에 "사진 삽입" 작업만 표시합니다.

00:04:01.000 --> 00:04:05.000
새로운 API를 사용하여 이러한 작업을 추가하는 방법을 보여드리겠습니다.

00:04:05.000 --> 00:04:29.000
프레젠테이션에서 동적으로 메뉴에 작업을 삽입하려면 UITextViewDelegate 메서드 textView editMenuForTextIn 범위 suggestedActions를 구현하십시오. 이 예제에서는 선택한 텍스트가 있을 때만 "하이라이트" 작업을 추가하고 싶기 때문에 이 방법을 통해 동적으로 작업을 추가할 수 있습니다.

00:04:29.000 --> 00:04:39.000
"사진 삽입" 작업은 항상 유효하므로, 배열에 추가하여 항상 메뉴에 작업을 표시할 수 있습니다.

00:04:39.000 --> 00:04:50.000
마지막으로, 잘라내기, 복사 및 붙여넣기와 같은 항목을 포함하는 시스템 제안 작업에 내 작업을 추가하고 메뉴를 반환할 것입니다.

00:04:50.000 --> 00:04:54.000
그리고 그게 다야!

00:04:54.000 --> 00:05:02.000
UIEditMenuInteraction은 새로운 편집 메뉴를 지원하는 UIInteraction API입니다.

00:05:02.000 --> 00:05:15.000
상호 작용을 통해 자신의 제스처를 기반으로 텍스트 보기 외부에 가벼운 편집 메뉴를 프로그래밍 방식으로 표시할 수 있으며, 보조 클릭 시 컨텍스트 메뉴를 표시할 수 있는 기본 지원이 있습니다.

00:05:15.000 --> 00:05:25.000
iOS 16에서 UIMenuController와 모든 관련 API는 새로운 편집 메뉴 상호 작용으로 대체됩니다.

00:05:25.000 --> 00:05:33.000
처음부터 편집 메뉴를 표시하려면, 먼저 상호 작용을 만들고 보기에 추가하세요.

00:05:33.000 --> 00:05:39.000
다음으로, 메뉴를 표시하도록 제스처 인식기를 구성하세요.

00:05:39.000 --> 00:05:50.000
메뉴가 간접 포인터 클릭이 아닌 직접 터치에만 나타나도록 하려면, 제스처 인식기의 allowedTouchTypes 속성을 직접 터치로만 설정해야 합니다.

00:05:50.000 --> 00:05:56.000
그런 다음, 제스처 인식기를 보기에 추가하세요.

00:05:56.000 --> 00:06:06.000
마지막으로, 제스처 인식기가 실행되면, 메뉴를 표시할 수 있는 제스처 위치에 콘텐츠가 있는지 결정하십시오.

00:06:06.000 --> 00:06:12.000
그런 다음, 제스처의 위치에 소스 포인트로 편집 메뉴 구성을 만드세요.

00:06:12.000 --> 00:06:22.000
소스 포인트는 메뉴에 표시할 상호 작용 보기에서 수행 가능한 작업을 결정하는 데 사용됩니다.

00:06:22.000 --> 00:06:30.000
구성되면, presentEditMenu(with: configuration)를 호출하여 메뉴를 표시하세요.

00:06:30.000 --> 00:06:41.000
선택한 "Jello there!" 내의 아무 곳이나 마우스 오른쪽 버튼으로 클릭하면 보기, 컨텍스트 메뉴에는 앱 콘텐츠에 대한 실행 가능한 시스템 작업이 표시됩니다.

00:06:41.000 --> 00:06:52.000
더군다나, 선택한 보기를 탭하면, 내 터치가 발생한 곳에 편집 메뉴가 표시되며, 상황에 맞는 메뉴와 동일한 동작을 보여줍니다.

00:06:52.000 --> 00:06:55.000
이것은 좋지만, 더 나을 수 있다.

00:06:55.000 --> 00:07:02.000
터치가 발생한 곳에 메뉴가 나타나는 것은 좋지만, 실제로 선택한 보기의 콘텐츠를 차단하고 있습니다.

00:07:02.000 --> 00:07:10.000
게다가, 저는 시스템 기본 작업이 아닌 새로운 "중복" 작업을 메뉴에 삽입하고 싶습니다.

00:07:10.000 --> 00:07:12.000
돌아가서 이걸 바꾸자.

00:07:12.000 --> 00:07:32.000
선택한 보기 주위에 메뉴를 표시하려면 대리자 메서드 editMenuInteraction targetRectFor 구성을 구현하십시오. 이 메서드는 메뉴를 표시할 위치를 결정하는 데 사용되는 CGRect를 반환하고 상호 작용 보기의 좌표 공간에 있습니다.

00:07:32.000 --> 00:07:42.000
방법이 구현되지 않거나 null CGRect가 제공되는 경우, 메뉴는 구성의 소스 지점에서 표시됩니다.

00:07:42.000 --> 00:07:49.000
이 경우, 메뉴가 선택한 보기를 닫는 것을 방지하려면, 프레임을 반환하십시오.

00:07:49.000 --> 00:08:07.000
다음으로, "복제" 작업을 추가하려면, editMenuInteraction 메뉴를 구현하고, 이전에 텍스트 보기의 메뉴에 작업을 삽입하는 방법과 유사하게 시스템이 제안한 작업 후에 사용자 지정 작업을 추가합니다.

00:08:07.000 --> 00:08:15.000
이제, 내가 선택한 보기를 다시 탭하면, 메뉴는 더 이상 "Jello there!"를 막지 않습니다. 그리고 대신 그 주변에 선물해.

00:08:15.000 --> 00:08:22.000
메뉴가 표시될 때 새로운 "중복" 작업도 포함되며, 모두 몇 줄의 코드만 있으면 됩니다.

00:08:22.000 --> 00:08:25.000
훌륭해!

00:08:25.000 --> 00:08:36.000
Mac Catalyst 앱의 경우, 편집 메뉴는 사용자가 상호 작용 보기를 마우스 오른쪽 버튼으로 클릭할 때 Mac에서 기대하는 친숙한 컨텍스트 메뉴로 연결됩니다.

00:08:36.000 --> 00:08:44.000
iPad 관용구 Mac Catalyst 앱의 경우, 프로그래밍 방식으로 제시된 편집 메뉴는 컨텍스트 메뉴로 연결됩니다.

00:08:44.000 --> 00:08:53.000
편집 메뉴의 프로그래밍 방식 프레젠테이션은 Mac 관용구 앱에서 지원되지 않습니다.

00:08:53.000 --> 00:09:03.000
다양한 프레젠테이션 스타일 간의 원활한 브리징을 제공하기 위해, UIEditMenuInteraction은 UIMenuElement API 제품군 위에 구축되었습니다.

00:09:03.000 --> 00:09:10.000
이것들은 하위 메뉴와 이미지에 대한 지원을 포함하여 이전보다 더 많은 유연성과 사용자 정의 가능성을 제공합니다.

00:09:10.000 --> 00:09:20.000
UIMenus를 처음 사용하는 경우, "iOS 13용 UI 현대화"를 시청하여 메뉴와 작업에 대해 자세히 알아보세요.

00:09:20.000 --> 00:09:31.000
UIMenuElement 위에 구축한다는 것은 또한 편집 메뉴가 이미 메뉴를 지원하는 UIMenuSystem과 같은 다양한 API에 액세스할 수 있다는 것을 의미합니다.

00:09:31.000 --> 00:09:38.000
편집 메뉴는 기존 UIMenuSystem.context 시스템을 사용하여 메뉴를 만듭니다.

00:09:38.000 --> 00:09:51.000
메뉴 빌더에 대해 자세히 알아보고 응답자 체인 횡단 및 명령 유효성 검사에 대해 자세히 알아보려면 "iPad 앱을 한 단계 끌어올리기"를 시청하세요.

00:09:51.000 --> 00:09:57.000
메뉴에 대해 말하자면, iOS 16의 UIMenu에는 몇 가지 새로운 개선 사항이 있습니다.

00:09:57.000 --> 00:10:06.000
UIMenu에는 이제 컨텍스트 메뉴에서 다른 레이아웃 중에서 선택할 수 있는 선호하는 요소 크기 속성이 있습니다.

00:10:06.000 --> 00:10:15.000
작은 크기는 메뉴에 더 컴팩트한 나란히 모양을 제공하여 한 줄에 더 많은 동작을 제공합니다.

00:10:15.000 --> 00:10:21.000
중간 크기는 또한 나란히 보이는 동작을 표시하지만 조금 더 자세하게 보여준다.

00:10:21.000 --> 00:10:26.000
이것은 표준 편집 메뉴를 표시하기 위해 텍스트 편집 메뉴에서 사용됩니다.

00:10:26.000 --> 00:10:34.000
그리고 마지막으로, 큰 요소 크기는 메뉴에 기본, 전체 너비 모양을 제공한다.

00:10:34.000 --> 00:10:44.000
또한, 작업이 수행된 후 메뉴를 유지하기 위해 UIMenuElement에 새로운 .keepsMenuPresented 속성이 있습니다.

00:10:44.000 --> 00:10:51.000
이 속성을 사용하면 메뉴를 다시 표시하지 않고도 작업을 여러 번 수행할 수 있습니다.

00:10:51.000 --> 00:10:55.000
그것은 새로운 편집 메뉴의 빙산의 일각에 불과하다.

00:10:55.000 --> 00:11:00.000
텍스트 편집 메뉴를 사용자 정의하여 텍스트 편집 기능을 확장하세요.

00:11:00.000 --> 00:11:08.000
메뉴가 다른 프레젠테이션 스타일로 완벽하게 보이도록 행동에 제목과 이미지가 있는지 확인하세요.

00:11:08.000 --> 00:11:19.000
가장 중요한 것은 플랫폼과 다양한 입력 방법 전반에 걸쳐 더 나은 사용자 정의 가능성과 향상된 일관성을 위해 새로운 UIEditMenuInteraction을 채택하는 것입니다.

00:11:19.000 --> 00:11:24.000
새로운 편집 메뉴에 대한 지원을 추가하는 것은 훌륭한 첫 번째 단계이다.

00:11:24.000 --> 00:11:34.000
데스크톱 수업 편집 경험을 완성하기 위해, 나는 새로운 시스템 찾기 및 교체 경험에 대해 이야기하기 위해 그것을 제임스에게 넘길 것이다.

00:11:34.000 --> 00:11:37.000
제임스 마가헤른: 아, 저기 있어!

00:11:37.000 --> 00:11:44.000
안녕하세요, 저는 UIKit 엔지니어인 James Magahern입니다. 찾기와 교체에 대해 이야기하기 위해 왔습니다.

00:11:44.000 --> 00:11:51.000
iOS 16의 새로운 기능, 우리는 앱에서 텍스트를 찾고 대체하기 위한 새로운 UI 구성 요소를 도입했습니다.

00:11:51.000 --> 00:12:02.000
그것은 시스템 전반에 걸쳐 표준이며 많은 내장 앱에 포함되어 있으며, 사용자가 훨씬 더 일반적으로 사용되는 편집 단축키로 근육 메모리를 조정할 수 있습니다.

00:12:02.000 --> 00:12:06.000
이것은 iPad에서 실행되는 새로운 찾기 패널입니다.

00:12:06.000 --> 00:12:19.000
우리는 하드웨어 키보드가 부착될 때 단축키바와 함께 인라인으로 뜨는 것에서 하드웨어 키보드 없이 사용할 때 소프트웨어 키보드 위에 놓이는 것으로 자동으로 전환할 것입니다.

00:12:19.000 --> 00:12:25.000
iPhone에서, 우리는 더 컴팩트한 레이아웃을 사용하여 더 작은 화면 크기에 적응할 것입니다.

00:12:25.000 --> 00:12:33.000
자동 해고, 최소화 및 키보드 회피는 모두 시스템에 의해 처리됩니다.

00:12:33.000 --> 00:12:46.000
Mac에서 앱을 실행할 때, 우리는 당신의 콘텐츠와 인라인으로 찾기 패널을 제시하고, AppKit 찾기 바처럼 작동하며, 사용자가 Mac에서 기대하는 친숙한 레이아웃을 사용할 것입니다.

00:12:46.000 --> 00:13:02.000
UITextView, WKWebView 또는 PDFViews를 사용하여 앱에 텍스트 콘텐츠를 표시하는 경우, 시작하려면 내장된 찾기 상호 작용에서 isFindInteractionEnabled를 true로 설정하기만 하면 됩니다.

00:13:02.000 --> 00:13:04.000
그렇게 간단해!

00:13:04.000 --> 00:13:14.000
또한, QuickLook을 사용하여 텍스트 콘텐츠를 표시하는 경우, 작업 없이 이미 사용할 수 있습니다.

00:13:14.000 --> 00:13:28.000
하드웨어 키보드를 사용하면 find를 위한 command+F, 다음 찾기를 위한 command+G, 이전 찾기를 위한 command+shift+G 등과 같은 모든 표준 시스템 단축키가 예상대로 작동합니다.

00:13:28.000 --> 00:13:33.000
Mac에서 실행할 때 메뉴 표시줄을 통해 이러한 명령에 액세스할 수 있습니다.

00:13:33.000 --> 00:13:40.000
콘텐츠를 표시하는 보기가 첫 번째 응답자가 될 수 있는지 확인하기만 하면 됩니다.

00:13:40.000 --> 00:13:51.000
하드웨어 키보드를 사용하지 않는 사용자의 경우, 포함된 찾기 상호 작용 속성에서 presentFindNavigator를 통해 프로그래밍 방식으로 찾기 상호 작용을 호출할 수 있습니다.

00:13:51.000 --> 00:13:58.000
예를 들어, 내비게이션 바 항목을 통해 이것을 사용할 수 있도록 하는 것이 좋은 생각일 수 있습니다.

00:13:58.000 --> 00:14:02.000
Mac에서 실행할 때, 명심해야 할 몇 가지 다른 사항이 있습니다.

00:14:02.000 --> 00:14:09.000
예를 들어, iOS에서 찾기 패널은 소프트웨어 키보드 또는 단축키 바의 일부로 표시됩니다.

00:14:09.000 --> 00:14:13.000
Mac에서, 우리는 당신의 콘텐츠와 함께 인라인으로 표시할 것입니다.

00:14:13.000 --> 00:14:25.000
스크롤 보기에 찾기 상호 작용을 설치하는 경우, 찾기 패널을 수용하기 위해 콘텐츠 삽입을 자동으로 조정하고 특성 수집 변경 사항에 자동으로 적응합니다.

00:14:25.000 --> 00:14:33.000
그렇지 않으면 macOS의 UI에서 찾기 패널을 호스팅할 충분한 공간이 있는지 확인해야 합니다.

00:14:33.000 --> 00:14:41.000
또한, 돋보기 아이콘을 탭할 때 사용할 수 있는 표준 찾기 옵션이 포함된 메뉴를 보여줄 것입니다.

00:14:41.000 --> 00:14:49.000
UIFindInteraction의 optionsMenuProvider 속성을 사용하여 이 메뉴의 내용을 사용자 정의할 수 있습니다.

00:14:49.000 --> 00:14:53.000
이것은 사용자 지정 구현에서 더 중요할 것이다.

00:14:53.000 --> 00:14:59.000
그리고 내가 전에 언급한 내장 뷰 중 하나를 사용하는 경우 그것이 필요한 전부입니다.

00:14:59.000 --> 00:15:11.000
앱이 여기에 표시된 완전히 사용자 지정 보기 또는 목록 보기와 같은 다른 방법으로 텍스트 콘텐츠를 표시하는 경우, 여전히 앱에 찾기 상호 작용을 추가할 수 있습니다.

00:15:11.000 --> 00:15:14.000
어떻게 하는지 보여줄게.

00:15:14.000 --> 00:15:21.000
상호 작용을 찾는 것에 대한 좋은 소식은 임의의 보기에 설치할 수 있다는 것입니다.

00:15:21.000 --> 00:15:32.000
앱에 기존 찾기 및 교체 구현이 있다면, UIFindInteraction으로 연결하여 시스템의 UI를 활용할 수 있습니다.

00:15:32.000 --> 00:15:46.000
사용자 지정 보기에 대한 기존 찾기 구현이 아직 없다면, 특히 시스템 키보드로 작업하기 위해 UITextInput 프로토콜을 이미 구현한 경우 시작하기가 매우 쉽습니다.

00:15:46.000 --> 00:15:51.000
UIFindInteraction이 사용자 지정 보기와 함께 작동하는 방법은 다음과 같습니다.

00:15:51.000 --> 00:15:58.000
사용자 지정 보기에 UIFindInteraction을 설치한 후, 찾기 상호 작용 대리자를 설정하십시오.

00:15:58.000 --> 00:16:10.000
찾기 상담 대리인은 찾기 세션이 시작되거나 끝날 때 알림을 받는 것 외에도 UIFindSessions를 처리할 책임이 있습니다.

00:16:10.000 --> 00:16:21.000
UIFindSession은 현재 강조 표시된 결과와 같이 주어진 세션의 모든 상태를 캡슐화하는 추상적인 기본 클래스입니다.

00:16:21.000 --> 00:16:30.000
또한 "다음 결과로 이동" 또는 "이 문자열 검색"과 같이 UI에서 요청된 모든 작업을 제공합니다.

00:16:30.000 --> 00:16:40.000
이 모든 상태를 직접 관리하고 싶다면, 찾기 상호 작용 대리인으로부터 UIFindSession의 하위 클래스를 판매하도록 선택할 수 있습니다.

00:16:40.000 --> 00:16:50.000
앱에 이미 기존 찾기 및 교체 구현이 있고 시스템 UI에 연결하고 싶다면 이것은 좋은 옵션입니다.

00:16:50.000 --> 00:17:05.000
그렇지 않으면, 시스템이 당신을 위해 상태를 처리하도록 하고, 대신 표시되는 문서의 내용을 캡슐화하는 모든 클래스에 UITextSearching 프로토콜을 채택하는 것이 훨씬 더 좋은 생각일 것입니다.

00:17:05.000 --> 00:17:13.000
이렇게 하려면, UITextSearchingFindSession을 반환하고 문서 클래스와 연결해야 합니다.

00:17:13.000 --> 00:17:19.000
아직 사용자 지정 보기에 대한 구현을 찾지 못한 경우 이것이 최선의 선택입니다.

00:17:19.000 --> 00:17:22.000
코드에서 이것을 하는 방법은 다음과 같습니다.

00:17:22.000 --> 00:17:30.000
이 예제에는 사용자 지정 문서 클래스와 이 문서를 표시하는 사용자 지정 보기가 있습니다.

00:17:30.000 --> 00:17:42.000
UIFindInteraction이 이 보기에 설치되며, UITextSearchingFindSession은 이 문서와 함께 "검색 가능한 객체"로 제공됩니다.

00:17:42.000 --> 00:17:51.000
키보드 단축키가 예상대로 작동하도록 뷰 컨트롤러 또는 사용자 지정 뷰가 첫 번째 응답자가 될 수 있는지 확인하십시오.

00:17:51.000 --> 00:17:57.000
찾기 상호 작용을 만들고, 찾기 세션을 처리하기 위해 세션 대리인을 제공하세요.

00:17:57.000 --> 00:18:01.000
여기서, 뷰 컨트롤러는 세션 대리인이다.

00:18:01.000 --> 00:18:12.000
그런 다음, 상호 작용으로 찾기 세션을 요청하면, 문서를 검색 가능한 객체로 제공하는 새로운 UITextSearchingFindSession을 반환하기만 하면 됩니다.

00:18:12.000 --> 00:18:19.000
물론 문서 클래스가 UITextSearching 프로토콜을 준수하는지 확인해야 합니다.

00:18:19.000 --> 00:18:28.000
UITextSearching 프로토콜을 구현하는 클래스는 실제로 문서에서 텍스트를 찾는 역할을 합니다.

00:18:28.000 --> 00:18:36.000
시스템은 performTextSearch를 호출하고 결과를 제공할 수 있는 애그리게이터 객체를 건네줄 것입니다.

00:18:36.000 --> 00:18:42.000
애그리게이터는 UITextRange와 함께 작동하여 문서의 결과를 나타냅니다.

00:18:42.000 --> 00:18:51.000
이것은 텍스트를 저장하는 방법에 맞는 데이터를 캡슐화하는 데 사용할 수 있는 또 다른 추상 클래스입니다.

00:18:51.000 --> 00:18:58.000
예를 들어, 이것은 WebKit을 사용하여 텍스트를 렌더링하는 클라이언트의 DOM 범위를 나타낼 수 있습니다.

00:18:58.000 --> 00:19:04.000
애그리게이터는 또한 스레드로부터 안전하므로, 백그라운드 스레드에서 결과를 제공할 수 있습니다.

00:19:04.000 --> 00:19:16.000
마지막으로, 찾기 상호 작용은 사용자 지정 보기를 사용하여 결과를 표시하는 방법을 모르기 때문에, decorate()가 호출될 때 주어진 스타일에 대한 결과를 장식해야 합니다.

00:19:16.000 --> 00:19:26.000
UITextSearching 찾기 세션과 프로토콜은 또한 동일한 상호 작용을 사용하여 여러 눈에 보이는 문서에서 다중화를 지원합니다.

00:19:26.000 --> 00:19:52.000
즉, 앱이 Mail의 대화 보기와 유사한 방식으로 콘텐츠를 표시하는 경우, 이 경우 각 "문서"가 메일 메시지인 경우, 루트 레벨 컬렉션 보기에 단일 찾기 상호 작용을 설치하고 모든 문서에서 동시에 찾기를 수행하여 사용자가 다른 문서의 결과 사이를 쉽게 이동할 수 있습니다.

00:19:52.000 --> 00:19:57.000
그래서 그것이 iOS 16에서 새로운 찾기 상호 작용을 시작하는 데 필요한 전부입니다.

00:19:57.000 --> 00:20:04.000
많은 텍스트 콘텐츠를 표시하는 시스템 뷰의 경우, isFindInteractionEnabled를 활성화해야 합니다.

00:20:04.000 --> 00:20:08.000
기존 찾기 구현을 UIFindInteraction으로 옮기세요.

00:20:08.000 --> 00:20:16.000
아직 앱에 텍스트 검색이 없다면 UITextSearching을 구현하고 UITextSearchingFindSession을 사용하세요.

00:20:16.000 --> 00:20:22.000
그리고 마지막으로, 앱에 충돌하는 키보드 단축키가 없는지 확인하세요.

00:20:22.000 --> 00:20:31.000
그리고 그것이 iOS 16에 대한 앱의 편집 상호 작용을 새로 고치고 진정한 데스크톱 클래스로 만드는 데 필요한 것입니다.

00:20:31.000 --> 00:20:38.000
앱에서 새로운 텍스트 편집 메뉴를 시도하고, 사용자 지정 UI를 위한 편집 메뉴 상호 작용을 채택하세요.

00:20:38.000 --> 00:20:42.000
그리고 앱의 텍스트 콘텐츠를 검색할 수 있게 하여 생산성을 높이세요.

00:20:42.000 --> 00:20:47.000
저는 당신의 앱에서 이 훌륭한 새로운 기능을 찾기를 고대하고 있습니다.

00:20:47.000 --> 00:20:52.000
봐줘서 고마워! 좋아요를 누르고, 댓글을 달고, 구독하세요.

00:20:52.000 --> 23:59:59.000
.

