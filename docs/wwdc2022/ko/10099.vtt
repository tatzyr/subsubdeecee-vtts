WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:15.000
키아라 로즈: 안녕하세요, 제 이름은 키아라 로즈이고, 저는 사파리 확장 엔지니어로 일하고 있습니다.

00:00:15.000 --> 00:00:22.000
오늘 저는 올해 사파리 웹 확장의 새로운 기능에 대해 여러분 모두에게 이야기하게 되어 매우 기쁩니다.

00:00:22.000 --> 00:00:33.000
오늘 프레젠테이션에 뛰어들기 전에, iOS, iPadOS 및 macOS 확장 프로그램을 App Store에 제출해 주신 모든 분들께 감사드립니다.

00:00:33.000 --> 00:00:42.000
앞으로, 우리의 목표는 사용자에게 더 나은 경험을 제공할 수 있도록 새로운 기능과 API를 계속 구현하는 것입니다.

00:00:42.000 --> 00:00:58.000
그리고 오늘, 저는 확장을 위한 새로운 매니페스트 버전, 업데이트된 API 및 여러 장치에서의 동기화 확장과 같은 지난 한 해 동안 구현한 흥미로운 새로운 기능 중 일부를 강조할 것입니다.

00:00:58.000 --> 00:01:02.000
매니페스트 버전 3을 시작합시다.

00:01:02.000 --> 00:01:06.000
매니페스트 버전 3은 웹 확장 플랫폼의 다음 반복이다.

00:01:06.000 --> 00:01:13.000
성능 및 보안 개선을 소개하고 인기 있는 확장 API를 통합합니다.

00:01:13.000 --> 00:01:23.000
버전 3을 사용하도록 확장 프로그램을 이미 업데이트한 사람들을 위해, 확장 프로그램은 이제 Safari 15.4 이상에서 작동합니다.

00:01:23.000 --> 00:01:32.000
아직 하지 않은 분들을 위해, 우리는 사파리에서 매니페스트 버전 2를 사용하는 확장을 계속 지원할 것이기 때문에 걱정할 필요가 없습니다.

00:01:32.000 --> 00:01:39.000
매니페스트 버전 3의 주요 새로운 기능 중 하나는 확장 프로그램이 배경 페이지 대신 서비스 작업자를 사용할 수 있다는 것입니다.

00:01:39.000 --> 00:01:43.000
만약 당신이 웹 개발자라면, 당신은 아마 서비스 직원들에게 익숙할 것입니다.

00:01:43.000 --> 00:01:50.000
addEventListener API를 사용하여 리스너를 등록할 수 있는 이벤트 기반 페이지입니다.

00:01:50.000 --> 00:01:55.000
이 페이지들은 매니페스트 버전 3을 지원하는 다른 브라우저와도 호환됩니다.

00:01:55.000 --> 00:02:03.000
확장 프로그램에 배경 페이지를 계속 사용하는 것을 선호한다면, 그렇게 하는 것을 환영하지만, 지속적이지 않아야 합니다.

00:02:03.000 --> 00:02:15.000
버전 3의 또 다른 개선 사항은 웹 페이지에서 자바스크립트와 스타일링을 실행하기 위한 API가 탭 API에서 새로운 스크립팅 API로 이동했다는 것이다.

00:02:15.000 --> 00:02:36.000
이러한 방법의 대부분의 기능은 동일하게 유지되지만, 웹 페이지에 코드를 삽입하는 새로운 방법, 코드가 실행되어야 하는 페이지의 프레임에 대한 더 많은 옵션, 코드를 실행해야 하는 실행 환경을 결정하는 기능과 같은 스크립팅이 제공하는 몇 가지 새로운 추가 기능이 있습니다.

00:02:36.000 --> 00:02:42.000
새로운 스크립팅 API의 코드가 탭 API와 어떻게 다른지 살펴봅시다.

00:02:42.000 --> 00:02:51.000
이 코드 스니펫에서 tabs.executeScript API를 사용하여 웹 페이지의 배경색을 파란색으로 변경하고 있습니다.

00:02:51.000 --> 00:03:05.000
그리고 이 API를 사용하면 "코드" 속성을 전달하여 문자열에 포함된 코드만 삽입할 수 있지만, 이제 새로운 스크립팅 API를 사용하면 이 코드를 포함하는 함수 객체를 전달할 수 있습니다.

00:03:05.000 --> 00:03:10.000
그리고 다른 함수와 마찬가지로, 그것은 전달될 수 있는 인수를 포함할 수 있다.

00:03:10.000 --> 00:03:17.000
이것은 문자열로 코드를 작성하는 데 국한되지 않기 때문에 스크립트를 실행하는 훨씬 더 개선된 방법입니다.

00:03:17.000 --> 00:03:22.000
그리고 스크립팅과 함께, 타겟이라는 새로운 속성이 있다는 점에 유의하세요.

00:03:22.000 --> 00:03:26.000
이 속성은 스크립트가 실행되어야 하는 위치를 지정하는 데 사용됩니다.

00:03:26.000 --> 00:03:33.000
스크립트를 실행하려면, 스크립트를 실행할 탭의 ID를 지정해야 합니다.

00:03:33.000 --> 00:03:37.000
이 API는 탭 ID가 지정되지 않으면 오류를 반환합니다.

00:03:37.000 --> 00:03:45.000
그런 다음, 코드를 삽입할 웹 페이지의 프레임을 선택하려면, 프레임 ID를 지정할 수 있습니다.

00:03:45.000 --> 00:03:50.000
탭 API를 사용하면 하나의 ID만 지정할 수 있습니다.

00:03:50.000 --> 00:03:55.000
하지만 스크립팅을 사용하면 여러 ID를 지정할 수 있습니다.

00:03:55.000 --> 00:04:02.000
하지만 내가 훨씬 더 많은 코드를 가지고 있고 여러 파일에 포함할 수 있다면 훨씬 더 깨끗해 보일 것이라고 가정해 봅시다.

00:04:02.000 --> 00:04:13.000
tabs.executeScript API에서는 하나의 파일만 지정할 수 있지만, scripting.executeScript에서는 여러 파일을 지정할 수 있습니다.

00:04:13.000 --> 00:04:26.000
마찬가지로, 웹 페이지에 스타일을 삽입할 수 있는 insertCSS에 대해서도 동일하게 수행할 수 있으며, 웹 페이지에서 삽입된 스타일을 제거할 수 있는 removeCSS에 대해서도 동일하게 수행할 수 있습니다.

00:04:26.000 --> 00:04:31.000
이 API는 매니페스트 버전 2와 3 모두에서 사용할 수 있습니다.

00:04:31.000 --> 00:04:37.000
그러나, tabs.executeScript API는 버전 3에서 사용할 수 없습니다.

00:04:37.000 --> 00:04:43.000
새로운 스크립팅 API 외에도, 몇 가지 다른 API에도 약간의 수정이 있었다.

00:04:43.000 --> 00:04:48.000
이러한 수정 사항 중 하나는 web_accessible_resources를 위한 것이다.

00:04:48.000 --> 00:04:58.000
매니페스트 버전 2에서 리소스를 포함하려면 웹 페이지에 액세스할 수 있는 파일 배열을 전달하여 그렇게 할 수 있습니다.

00:04:58.000 --> 00:05:07.000
하지만 이것은 당신이 매니페스트에서 지정한 모든 리소스에 대한 웹 페이지에 접근할 수 있기 때문에 문제가 될 수 있습니다.

00:05:07.000 --> 00:05:14.000
버전 3의 새로운 형식을 사용하면 주어진 사이트에서 사용할 수 있는 리소스를 제어할 수 있습니다.

00:05:14.000 --> 00:05:17.000
예를 들어 봅시다.

00:05:17.000 --> 00:05:23.000
이전에는 확장자가 접근할 수 있는 모든 사이트에서 쿠키와 파이 이미지를 사용할 수 있었다.

00:05:23.000 --> 00:05:34.000
하지만 이제 버전 3에서는 apple.com URL에서만 파이 이미지를 사용할 수 있고 webkit.org 페이지에서만 쿠키 이미지를 사용할 수 있습니다.

00:05:34.000 --> 00:05:41.000
이제 browser_action과 page_action API의 수정 사항을 살펴봅시다.

00:05:41.000 --> 00:05:46.000
매니페스트 버전 2에서, 그 행동은 다음과 같이 명확하게 명시되었다.

00:05:46.000 --> 00:05:56.000
하지만 이러한 API는 비슷한 역할을 수행하기 때문에, 버전 3에서 하나의 API만 사용하도록 통합되었습니다.

00:05:56.000 --> 00:06:01.000
우리는 또한 확장 프로그램에 대한 콘텐츠 보안 정책을 선언하는 방법을 업데이트했습니다.

00:06:01.000 --> 00:06:06.000
버전 2에서, 확장의 정책은 문자열을 사용하여 정의되었다.

00:06:06.000 --> 00:06:15.000
그러나, 버전 3에서, 정책은 "extension_pages" 키를 가진 객체를 사용하여 정의됩니다.

00:06:15.000 --> 00:06:21.000
스크립트의 원격 소스는 더 이상 버전 3에서 허용되지 않는다는 점에 유의하는 것이 중요합니다.

00:06:21.000 --> 00:06:28.000
최종 API 변경은 더 이상 사용되지 않는 browser.extension.getURL API로 변경되었습니다.

00:06:28.000 --> 00:06:31.000
이 API는 버전 3에서 더 이상 지원되지 않습니다.

00:06:31.000 --> 00:06:35.000
대신, browser.runtime에서 동등한 API를 사용하세요.

00:06:35.000 --> 00:06:47.000
그래서 저는 매니페스트 버전 3에 도입된 새로운 기능에 대해 이야기했습니다. 이제 이러한 새로운 기능을 사용할 수 있도록 확장 프로그램을 업데이트하는 과정을 진행해 봅시다.

00:06:47.000 --> 00:06:54.000
매니페스트 버전 3을 사용하기 위해 작년 프레젠테이션에서 Sea Creator 확장 프로그램을 업데이트할 것입니다.

00:06:54.000 --> 00:07:00.000
이 확장 프로그램은 물고기라는 단어의 모든 발생을 이모티콘으로 바꿉니다.

00:07:00.000 --> 00:07:06.000
내가 가장 먼저 할 일은 버전 번호를 2에서 3으로 바꾸는 것이다.

00:07:06.000 --> 00:07:19.000
그리고 버전 3에서 비영구 백그라운드 페이지를 여전히 사용할 수 있지만, 확장 프로그램이 크롬과 호환되도록 서비스 작업자를 사용하도록 업데이트할 것입니다.

00:07:19.000 --> 00:07:25.000
마지막으로, 나는 browser_action을 행동으로 바꿀 것이다.

00:07:25.000 --> 00:07:34.000
그리고 매니페스트의 구조 측면에서, 이것들은 이 확장이 버전 3의 새로운 사양과 호환되도록 하기 위해 필요한 주요 변경 사항입니다.

00:07:34.000 --> 00:07:47.000
그래서 이것을 테스트하기 위해, 나는 확장 프로그램을 만들고, 사파리에서 활성화할 것이다.

00:07:47.000 --> 00:07:59.000
그런 다음 webkit.org 블로그 페이지로 이동하여 이 확장 프로그램을 사용하여 물고기 단어의 모든 인스턴스를 물고기 이모티콘으로 바꿀 것입니다.

00:07:59.000 --> 00:08:01.000
하지만 뭔가 잘못된 것 같아.

00:08:01.000 --> 00:08:05.000
보시다시피, 이 페이지의 단어 중 어느 것도 이모티콘으로 대체되지 않았습니다.

00:08:05.000 --> 00:08:15.000
오류 메시지가 있는지 확인하기 위해 팝오버를 점검해 봅시다.

00:08:15.000 --> 00:08:22.000
콘솔 탭에서 browser.tabs.executeScript가 정의되지 않았다는 오류 메시지가 표시됩니다.

00:08:22.000 --> 00:08:31.000
이 API는 버전 3에서 더 이상 사용할 수 없기 때문에, 대신 새로운 스크립팅 API를 사용하도록 확장 프로그램을 업데이트해야 합니다.

00:08:31.000 --> 00:08:42.000
Xcode에서, 나는 popup.js 파일로 돌아가서, 대신 스크립팅을 사용하도록 이 줄을 바꿀 것이다.

00:08:42.000 --> 00:08:50.000
스크립트를 어디에 삽입해야 하는지 지정하는 데 사용되는 대상 속성을 추가할 것입니다.

00:08:50.000 --> 00:08:54.000
그리고 새로운 스크립팅 API를 사용하면 탭의 ID를 지정해야 합니다.

00:08:54.000 --> 00:09:08.000
tabs.getCurrent API를 사용하여 현재 탭의 정보가 포함된 객체를 얻을 수 있습니다.

00:09:08.000 --> 00:09:15.000
그런 다음 그 객체를 사용하여 탭 ID를 검색할 수 있습니다.

00:09:15.000 --> 00:09:21.000
다음으로, 실행할 스크립트가 포함된 파일을 추가하겠습니다.

00:09:21.000 --> 00:09:29.000
마지막으로, 제가 할 마지막 변경 사항은 매니페스트에 스크립팅 권한을 추가하는 것입니다.

00:09:29.000 --> 00:09:38.000
나는 확장 프로그램을 만들고 사파리에서 이러한 변경 사항을 사용할 것이다.

00:09:38.000 --> 00:09:44.000
그리고 보시다시피, 이 확장 프로그램은 이제 매니페스트 버전 3의 새로운 기능을 사용하여 Safari에서 작동합니다.

00:09:44.000 --> 00:09:47.000
그래서 확장 프로그램을 업그레이드하는 것이 얼마나 간단한지.

00:09:47.000 --> 00:09:56.000
하지만 이러한 새로운 변경 사항에 아직 익숙하지 않다면, 스크립팅 및 서비스 작업자와 같은 많은 기능을 버전 2에서도 사용할 수 있습니다.

00:09:56.000 --> 00:10:03.000
이제 선언적 순 요청을 시작으로 올해 업데이트한 API 중 일부를 살펴봅시다.

00:10:03.000 --> 00:10:15.000
선언적 순 요청은 규칙 집합을 사용하여 네트워크 요청을 차단하거나 수정할 수 있는 빠르고 개인 정보 보호 방식으로 웹 확장을 제공하는 콘텐츠 차단 API입니다.

00:10:15.000 --> 00:10:26.000
이 API를 사용하면 요청을 가로채고 수정하는 모든 작업을 Safari에 위임할 수 있으며 적용해야 하는 콘텐츠 차단 규칙을 지정하기만 하면 됩니다.

00:10:26.000 --> 00:10:30.000
매니페스트에서 규칙 집합을 지정할 수 있습니다.

00:10:30.000 --> 00:10:40.000
여기에 선언적 순 요청 권한을 추가했고, declarative_net_request 키를 사용하여 모든 페이지에 적용되어야 하는 하나의 규칙 집합을 추가했습니다.

00:10:40.000 --> 00:10:45.000
이전에, 나는 매니페스트에서 최대 10개의 규칙 세트만 선언할 수 있었다.

00:10:45.000 --> 00:10:54.000
하지만 이제 이 기능에 대한 새로운 업데이트를 통해 최대 50개의 규칙 세트를 선언할 수 있습니다. 즉, 확장 프로그램을 더 사용자 정의할 수 있습니다.

00:10:54.000 --> 00:10:59.000
하지만 이 규칙 세트 중 10개만 한 번에 활성화할 수 있다는 것을 명심하세요.

00:10:59.000 --> 00:11:09.000
규칙 세트를 만드는 방법에 대한 자세한 내용은 이 API에 대해 더 자세히 알아보는 Safari Web Extensions에 대한 작년 프레젠테이션을 확인하세요.

00:11:09.000 --> 00:11:13.000
선언적 순 요청을 위한 몇 가지 새로운 기능으로 넘어갑시다.

00:11:13.000 --> 00:11:25.000
이전에는 매니페스트에서만 규칙 집합을 선언할 수 있었지만, 이제 규칙을 동적으로 업데이트할 수 있는 다음 두 가지 API를 구현했습니다.

00:11:25.000 --> 00:11:31.000
첫 번째 API는 updateSessionRules로, 확장에 대한 규칙을 추가하거나 제거할 수 있습니다.

00:11:31.000 --> 00:11:39.000
하지만 이러한 규칙은 브라우저 세션이나 확장 업데이트에서 지속되지 않는다는 점에 유의하는 것이 중요합니다.

00:11:39.000 --> 00:11:45.000
지속될 규칙을 업데이트하려면, 대신 updateDynamicRules API를 사용하세요.

00:11:45.000 --> 00:11:50.000
이를 통해 전체 확장 프로그램을 업데이트하지 않고도 차단 규칙을 업데이트할 수 있습니다.

00:11:50.000 --> 00:11:57.000
이 API 중 하나를 사용하여 규칙 집합을 수정할 수 있는 방법을 살펴봅시다.

00:11:57.000 --> 00:12:06.000
바다 제작자 확장 프로그램을 사용하여 웹 페이지의 일부 콘텐츠를 차단한 다음, 새로운 API를 사용하여 선택한 페이지의 콘텐츠를 차단 해제할 것입니다.

00:12:06.000 --> 00:12:15.000
확장 매니페스트에서, 내가 가장 먼저 할 일은 선언적 순 요청 권한을 추가하는 것이다.

00:12:15.000 --> 00:12:24.000
그런 다음, 나는 선언적 순 요청 키를 사용하여 규칙 집합을 추가할 것이다.

00:12:24.000 --> 00:12:30.000
적용되는 규칙은 rules.json 파일에 있습니다.

00:12:30.000 --> 00:12:36.000
이 파일에서, 나는 모든 URL의 모든 이미지를 차단하는 하나의 규칙을 선언했다.

00:12:36.000 --> 00:12:43.000
확장 프로그램을 만들고 이 규칙이 사파리에서 어떻게 적용되는지 봅시다.

00:12:43.000 --> 00:12:47.000
보시다시피, 이 페이지의 이미지가 사라졌습니다.

00:12:47.000 --> 00:12:49.000
그게 정확히 우리가 기대했던 거야.

00:12:49.000 --> 00:12:54.000
이것은 사파리가 우리의 콘텐츠 차단 규칙을 성공적으로 적용했다는 것을 보여준다.

00:12:54.000 --> 00:13:01.000
그리고 물고기에 대한 이 위키피디아 페이지로 이동하면, 이 사이트의 이미지도 차단된 것을 볼 수 있습니다.

00:13:01.000 --> 00:13:09.000
하지만 webkit.org 블로그 페이지를 기대하는 모든 페이지의 이미지를 차단하기 위해 규칙을 업데이트하고 싶다고 가정해 봅시다.

00:13:09.000 --> 00:13:16.000
선언적 순 요청을 위해 업데이트된 API 중 하나를 사용하여, 우리는 바로 그것을 할 수 있다.

00:13:16.000 --> 00:13:20.000
Xcode로 돌아가서 몇 가지 변경을 합시다.

00:13:20.000 --> 00:13:28.000
Popup.js 파일에서 콘텐츠 차단 규칙을 업데이트하는 기능을 선언할 것입니다.

00:13:28.000 --> 00:13:33.000
Webkit.org/blog-files 페이지에서 이미지를 허용하는 규칙을 설정하겠습니다.

00:13:33.000 --> 00:13:40.000
그런 다음, updateSessionRules API를 사용하여 이 규칙을 규칙 세트에 추가하겠습니다.

00:13:40.000 --> 00:13:48.000
마지막으로, 나는 확장 프로그램을 만들고 사파리에서 우리의 변경 사항을 테스트할 것이다.

00:13:48.000 --> 00:13:56.000
보시다시피, 이 블로그 게시물의 이미지가 로드되어 이 사이트의 이미지를 허용하는 새로운 규칙이 작동했음을 보여줍니다.

00:13:56.000 --> 00:14:05.000
그리고 내가 위키피디아 사이트에 가면, 우리는 이 페이지의 이미지가 여전히 차단되어 새로운 규칙이 이 페이지에 적용되지 않았다는 것을 보여줄 것이다.

00:14:05.000 --> 00:14:12.000
그래서 그것이 새로운 선언적 순 요청 API를 사용하여 콘텐츠 차단 규칙을 업데이트할 수 있는 방법입니다.

00:14:12.000 --> 00:14:17.000
이제, 확장 프로그램이 웹 페이지와 어떻게 통신할 수 있는지 살펴봅시다.

00:14:17.000 --> 00:14:24.000
이 멋진 기능을 사용하면 사용자가 확장 프로그램을 활성화한 경우 웹사이트가 사용자 지정 동작을 만들 수 있습니다.

00:14:24.000 --> 00:14:28.000
API는 외부 연결 가능이라고 불린다.

00:14:28.000 --> 00:14:32.000
그것을 사용하기 위해, 당신은 매니페스트에서 일치 패턴을 선언합니다.

00:14:32.000 --> 00:14:39.000
이러한 일치 패턴은 확장 프로그램과 통신할 수 있는 페이지를 결정합니다.

00:14:39.000 --> 00:14:46.000
그리고 주목해야 할 중요한 점은 이 기능이 브라우저 네임스페이스를 통해서만 작동한다는 것입니다.

00:14:46.000 --> 00:14:54.000
그리고 마지막으로, 사용자는 메시지를 보내거나 받기 전에 페이지에 대한 확장 액세스 권한을 부여해야 합니다.

00:14:54.000 --> 00:14:59.000
이 기능을 사용하기 위해 웹 페이지에 추가할 코드를 살펴봅시다.

00:14:59.000 --> 00:15:02.000
먼저, 확장 ID를 받아야 합니다.

00:15:02.000 --> 00:15:08.000
이 형식의 확장과 팀 식별자의 번들 식별자입니다.

00:15:08.000 --> 00:15:15.000
계정 설정의 멤버십 탭에서 developer.apple.com에서 팀 식별자를 찾을 수 있습니다.

00:15:15.000 --> 00:15:21.000
그런 다음 메시지 보내기 API를 사용하여 확장 프로그램에 메시지를 게시할 것입니다.

00:15:21.000 --> 00:15:27.000
함수를 전달하여 확장에서 받을 응답을 처리할 수 있습니다.

00:15:27.000 --> 00:15:32.000
이제 확장 프로그램이 메시지를 수신해야 하는 코드를 살펴봅시다.

00:15:32.000 --> 00:15:38.000
확장 프로그램은 onMessageExternal이라는 이벤트를 듣고 웹 페이지에서 메시지를 받을 수 있습니다.

00:15:38.000 --> 00:15:45.000
확장 프로그램은 이벤트 리스너에 전달된 방법을 사용하여 웹 페이지로 메시지를 다시 보낼 수 있습니다.

00:15:45.000 --> 00:15:52.000
다른 브라우저를 위한 다른 확장 웹 스토어가 있기 때문에, 확장은 많은 다른 식별자를 가질 수 있다.

00:15:52.000 --> 00:16:01.000
따라서 크롬이나 엣지 확장 프로그램이 아닌 사파리 웹 확장 프로그램에 메시지를 보내고 있는지 확인하기 위해 사용할 올바른 것을 결정해야 합니다.

00:16:01.000 --> 00:16:10.000
이렇게 하려면, Promise.all을 호출하여 browser.runtime.sendMessage API를 사용할 수 있습니다.

00:16:10.000 --> 00:16:16.000
다음으로, 당신이 이것을 하는 데 도움이 될 몇 가지 예제 코드를 살펴봅시다.

00:16:16.000 --> 00:16:21.000
웹 페이지에서 여러 확장 ID를 사용하여 여러 메시지를 브로드캐스트할 수 있습니다.

00:16:21.000 --> 00:16:30.000
확장 프로그램에서 정확히 하나의 응답을 받게 되며 추가 통신을 위해 어떤 확장 ID를 사용할지 알 수 있습니다.

00:16:30.000 --> 00:16:36.000
여기, 저는 determineExtensionID라는 함수가 있습니다.

00:16:36.000 --> 00:16:43.000
이 기능은 browser.runtime.sendMessage API를 사용하여 확장 프로그램에 메시지를 보냅니다.

00:16:43.000 --> 00:16:55.000
여러 ID가 있고 사용할 올바른 ID를 결정하려면 Promise.all을 사용하여 determineExtensionID 기능을 사용하여 여러 번 호출할 수 있습니다.

00:16:55.000 --> 00:17:03.000
Promise.all은 약속 배열을 가져간 다음 해결된 모든 값의 배열과 함께 단일 약속을 반환합니다.

00:17:03.000 --> 00:17:08.000
이 배열을 사용하여 사용자가 설치한 확장 프로그램을 찾을 수 있습니다.

00:17:08.000 --> 00:17:14.000
확장 프로그램의 배경 페이지에서, 당신은 웹 페이지의 메시지를 들어야 할 것입니다.

00:17:14.000 --> 00:17:20.000
메시지를 받으면, 확장 프로그램이 설치되었다는 것을 웹 페이지에 알리기 위해 다시 보내야 합니다.

00:17:20.000 --> 00:17:28.000
그래서 그것이 새로운 외부 연결 API를 사용하여 확장 프로그램이 웹 페이지와 통신할 수 있도록 하는 방법입니다.

00:17:28.000 --> 00:17:33.000
우리가 업데이트한 다음 기능은 내가 개인적으로 가장 좋아하는 기능이며, 그것은 unlimitedStorage이다.

00:17:33.000 --> 00:17:37.000
그리고 저는 unlimitedStorage가 실제로 무제한이라는 것을 발표하게 되어 매우 기쁩니다!

00:17:37.000 --> 00:17:46.000
이 기능이 당신에 의해 매우 높게 요청되었다는 점을 감안할 때, 우리는 당신의 확장 프로그램에 더 이상 10MB 할당량이 없다는 것을 공유하게 되어 기쁩니다.

00:17:46.000 --> 00:17:50.000
당신은 당신이 적합하다고 생각하는 만큼의 데이터를 자유롭게 사용할 수 있습니다.

00:17:50.000 --> 00:17:59.000
하지만, 사용자가 주어진 시간에 확장 프로그램에서 사용하는 데이터를 지울 수 있다는 점에 유의하는 것이 중요합니다.

00:17:59.000 --> 00:18:06.000
따라서 사용자가 데이터를 지우고 싶지 않도록 꼭 필요한 데이터만 저장해야 합니다.

00:18:06.000 --> 00:18:14.000
이 기능을 사용하려면, 매니페스트에서 스토리지 및 무제한 스토리지 권한을 요청하기만 하면 됩니다.

00:18:14.000 --> 00:18:19.000
그래서 그것들은 우리가 작년에 웹 확장을 위해 업데이트한 모든 API였다.

00:18:19.000 --> 00:18:27.000
마지막으로, 사용자가 모든 장치에서 확장 프로그램을 쉽게 얻을 수 있는 새로운 기능에 대해 이야기해 봅시다.

00:18:27.000 --> 00:18:33.000
사파리 16에서, 우리는 확장 프로그램을 더 원활하게 사용하는 경험을 만들었습니다.

00:18:33.000 --> 00:18:40.000
사용자가 장치 중 하나에서 확장 프로그램을 켜면, 모든 장치에서 켜집니다.

00:18:40.000 --> 00:18:46.000
게다가, 우리는 당신의 확장 프로그램을 훨씬 더 간단하게 다운로드하는 과정을 만들었습니다.

00:18:46.000 --> 00:18:49.000
이것이 어떻게 작동하는지 살펴봅시다.

00:18:49.000 --> 00:18:53.000
사용자가 Mac에서 확장 프로그램 중 하나를 활성화했다고 가정해 봅시다.

00:18:53.000 --> 00:19:00.000
다른 장치의 확장 설정에서 확장 프로그램을 다운로드할 수 있는 옵션이 제공됩니다.

00:19:00.000 --> 00:19:07.000
일단 다운로드되면, 장치에서 자동으로 활성화되어 사용자 경험을 향상시킵니다.

00:19:07.000 --> 00:19:13.000
이제, 웹 확장과 콘텐츠 차단기를 위해 이것을 설정하는 방법에 대해 알아봅시다.

00:19:13.000 --> 00:19:22.000
먼저, App Store에 제출할 때 iOS, iPadOS 및 macOS용 확장 프로그램을 나열하는 것이 좋습니다.

00:19:22.000 --> 00:19:28.000
이렇게 하면, 모든 사용자의 장치에서 확장 프로그램을 사용할 수 있습니다.

00:19:28.000 --> 00:19:35.000
그런 다음, 확장 프로그램이 장치 간에 동기화되도록 하려면, 다음 두 가지 방법 중 하나를 사용해야 합니다.

00:19:35.000 --> 00:19:41.000
가장 간단하고 권장되는 방법은 보편적 구매를 채택하는 것이다.

00:19:41.000 --> 00:19:49.000
유니버설 구매를 통해 사용자는 한 번만 구매하여 모든 플랫폼에서 확장 프로그램을 즐길 수 있습니다.

00:19:49.000 --> 00:19:52.000
이 방법을 사용하면, 모든 준비가 다 됩니다.

00:19:52.000 --> 00:19:59.000
사용자는 확장 프로그램을 한 번 다운로드한 후 제가 보여준 모든 기능을 얻을 수 있습니다.

00:19:59.000 --> 00:20:11.000
범용 구매를 설정하려면, App Store Connect에서 동일한 앱 레코드와 연결할 수 있도록 확장 프로그램에서 단일 번들 식별자를 사용해야 합니다.

00:20:11.000 --> 00:20:19.000
이를 수행하는 방법에 대한 자세한 내용은 확장 프로그램에 대한 범용 구매를 설정하는 방법에 대한 문서를 확인하십시오.

00:20:19.000 --> 00:20:24.000
하지만 유니버설 구매를 설정하지 않기로 선택한 경우, 앱을 수동으로 연결할 수 있습니다.

00:20:24.000 --> 00:20:32.000
이렇게 하려면 Xcode를 사용하여 동기화하려는 앱과 확장 프로그램에 대한 정보 plist에 번들 식별자를 추가할 수 있습니다.

00:20:32.000 --> 00:20:40.000
iOS 앱과 확장 프로그램을 macOS 앱과 동기화하려면, 정보 목록의 특정 키를 사용해야 합니다.

00:20:40.000 --> 00:20:48.000
이 키를 macOS 앱 plist에 넣고, 이 키를 macOS 확장 plist에 넣을 것입니다.

00:20:48.000 --> 00:20:53.000
마찬가지로, 당신은 macOS 앱을 동기화하기 위해 동일한 과정을 따를 것입니다.

00:20:53.000 --> 00:21:01.000
이 키를 iOS 앱 plist에 추가하고 이 키를 iOS 확장 plist에 추가함으로써.

00:21:01.000 --> 00:21:04.000
이것이 Xcode에서 어떻게 작동하는지 봅시다.

00:21:04.000 --> 00:21:14.000
Xcode에서 가장 먼저 해야 할 일은 동기화하려는 확장 프로그램과 앱의 번들 식별자를 포함하도록 각 대상의 설정을 업데이트하는 것입니다.

00:21:14.000 --> 00:21:24.000
iOS 앱의 정보 목록에 해당 macOS 앱의 번들 식별자를 추가하는 것으로 시작하겠습니다.

00:21:24.000 --> 00:21:31.000
그리고 보시다시피, 저는 iOS 앱 번들 식별자를 추가하여 macOS 앱에 대해 동일한 프로세스를 수행했습니다.

00:21:31.000 --> 00:21:37.000
그리고 macOS 확장 번들 식별자를 추가하여 iOS 확장의 경우와 유사합니다.

00:21:37.000 --> 00:21:43.000
그리고 마지막으로, iOS 확장 번들 식별자를 추가하여 macOS 확장을 위해.

00:21:43.000 --> 00:21:50.000
그리고 사용자가 어디에서나 사용할 수 있도록 앱과 확장 프로그램을 연결하는 것이 얼마나 간단한지입니다.

00:21:50.000 --> 00:22:04.000
요약하자면, 범용 구매를 설정하거나 Xcode에서 각 iOS 및 macOS 앱 및 확장 프로그램에 대한 번들 식별자를 추가하여 사용자가 이 기능을 사용할 수 있도록 할 수 있습니다.

00:22:04.000 --> 00:22:14.000
오늘 우리는 매니페스트 버전 3, 우리가 업데이트한 API, 그리고 여러 장치에서 확장을 동기화하는 것에 대해 논의했습니다.

00:22:14.000 --> 00:22:20.000
저는 당신이 사파리 웹 확장을 위한 이 모든 새로운 기능에 대해 나만큼 흥분하기를 바랍니다.

00:22:20.000 --> 00:22:28.000
오늘 세션의 코드가 포함된 샘플 프로젝트를 자유롭게 다운로드하고 우리가 소개한 API 중 일부를 가지고 놀아보세요.

00:22:28.000 --> 00:22:30.000
다음으로, 우리는 당신이 어떻게 생각하는지 알고 싶습니다.

00:22:30.000 --> 00:22:40.000
피드백 어시스턴트를 사용하여 버그를 제출하거나 사파리 개발자 포럼에서 우리와 채팅하여 확장 프로그램을 더 잘 개발할 수 있는 방법에 대한 피드백을 제공하십시오.

00:22:40.000 --> 00:22:43.000
아니, 정말. 우리는 네가 어떻게 생각하는지 알고 싶어!

00:22:43.000 --> 00:22:49.000
웹 확장의 미래를 형성하기 위해 WebExtensions 커뮤니티 그룹에 가입하는 것을 고려해 보세요.

00:22:49.000 --> 00:22:55.000
마지막으로, 웹 인스펙터 확장을 만드는 것에 대한 WWDC 프레젠테이션을 확인하세요.

00:22:55.000 --> 23:59:59.000
이 세션을 시청해 주셔서 감사드리며, 남은 WWDC에서 즐거운 시간 보내세요.

