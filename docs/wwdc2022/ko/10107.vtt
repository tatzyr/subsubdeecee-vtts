WEBVTT

00:00:00.000 --> 00:00:14.000
리치 길람: 안녕하세요, 저는 리치입니다, 그리고 저는 당신이 오른쪽에서 왼쪽으로 갈 수 있도록 돕기 위해 왔습니다.

00:00:14.000 --> 00:00:22.000
그래서 당신은 이미 가장 일반적인 유럽 언어, 가장 일반적인 아시아 언어를 포함한 많은 언어에 대한 응용 프로그램을 현지화했습니다.

00:00:22.000 --> 00:00:25.000
그리고 이제 당신은 그것을 아랍어와 히브리어로 현지화하고 싶습니다.

00:00:25.000 --> 00:00:35.000
이것은 좋은 선택입니다; 아랍어는 우리 플랫폼에서 가장 많이 사용되는 10가지 언어 중 하나이지만, 다른 언어로 개발할 때 직면하지 않는 몇 가지 문제를 수반합니다.

00:00:35.000 --> 00:00:44.000
그것이 이 이야기의 내용이며, 아랍어와 히브리어와 같은 언어로 현지화될 수 있도록 응용 프로그램을 개발하는 방법입니다.

00:00:44.000 --> 00:00:51.000
아랍어와 히브리어는 소위 "우파에서 좌파 언어" 중 가장 일반적으로 사용된다. 그들은 왜 이렇게 불리나요?

00:00:51.000 --> 00:01:00.000
영어, 프랑스어, 중국어, 태국어 및 기타 많은 언어는 문자가 이렇게 왼쪽에서 오른쪽으로 흐르도록 쓰여져 있다.

00:01:00.000 --> 00:01:04.000
히브리어로, 문자들은 이렇게 오른쪽에서 왼쪽으로 달린다.

00:01:04.000 --> 00:01:10.000
그들은 아랍어로 같은 일을 하고, 아랍어에서는 문자도 필기체로 결합되어 있다.

00:01:10.000 --> 00:01:15.000
"살람"의 네 글자는 따로 쓰여졌을 때 이렇게 보인다.

00:01:15.000 --> 00:01:18.000
그건 그렇고, 그것은 단지 아랍어와 히브리어가 아니다.

00:01:18.000 --> 00:01:24.000
애플은 실제로 15개의 오른쪽에서 왼쪽 언어에 대한 글꼴과 키보드를 지원합니다.

00:01:24.000 --> 00:01:26.000
여기 히브리어 텍스트의 단락이 있습니다.

00:01:26.000 --> 00:01:32.000
이것은 숫자에 대한 "공식 및 함수 도움말" 페이지의 히브리어 버전에서 가져온 것입니다.

00:01:32.000 --> 00:01:41.000
텍스트가 오른쪽에 정렬되어 있고 왼쪽에 들쭉날쭉하며, 마지막 줄을 포함한 많은 줄이 왼쪽에 구두점이 있다는 것을 주목하세요.

00:01:41.000 --> 00:01:43.000
이 단락에도 숫자가 있다.

00:01:43.000 --> 00:01:45.000
그 숫자는 여전히 왼쪽에서 오른쪽으로 간다.

00:01:45.000 --> 00:01:50.000
이것은 우리에게 숫자가 250개 이상의 기능을 지원한다고 말하고 있다.

00:01:50.000 --> 00:02:01.000
다른 단락을 포함하도록 시야를 넓히면, 이 단락에는 영어 단어, iWork의 이름 및 구성 응용 프로그램, Pages, Numbers 및 Keynote가 있다는 것을 알 수 있습니다.

00:02:01.000 --> 00:02:05.000
이것들은 또한 히브리어 단락에서도 왼쪽에서 오른쪽으로 쓰여졌다.

00:02:05.000 --> 00:02:09.000
그래서 많은 단락에서, 그 텍스트는 양방향이다.

00:02:09.000 --> 00:02:17.000
이것은 아랍어와 히브리어의 고유한 특성이며, 종종 "비디" 언어라고도 불리는 이유이다.

00:02:17.000 --> 00:02:22.000
우리가 시야를 더 넓히면, 전체 페이지가 오른쪽에서 왼쪽으로 배치된 것을 볼 수 있다.

00:02:22.000 --> 00:02:29.000
여기에 테이블이 있고, 텍스트는 왼쪽이 아닌 이미지의 오른쪽에 있습니다.

00:02:29.000 --> 00:02:35.000
그리고 우리가 사파리의 창틀을 보기 위해 그것을 더 넓히면, 우리는 그것이 콘텐츠로 멈추지 않는다는 것을 알 수 있다.

00:02:35.000 --> 00:02:43.000
아랍어와 히브리어 텍스트의 줄은 오른쪽에서 시작하여 왼쪽으로 진행되므로, 다른 UI 요소도 똑같이 할 것으로 예상하는 것은 당연합니다.

00:02:43.000 --> 00:02:50.000
독자들이 왼쪽에서 시작하여 오른쪽으로 진행하기를 기대하는 것처럼, 아랍어와 히브리어 독자들은 그 반대를 기대한다.

00:02:50.000 --> 00:03:00.000
그래서 여기서, 사파리의 도구 모음은 오른쪽 상단 모서리에 신호등 버튼이 있고 버튼이 왼쪽으로 진행되면서 오른쪽에서 왼쪽으로 실행됩니다.

00:03:00.000 --> 00:03:05.000
그리고 우리가 전체 화면을 포함하도록 초점을 넓히면, 우리는 그것이 모든 곳으로 확장된다는 것을 알 수 있다.

00:03:05.000 --> 00:03:10.000
이것은 숫자의 도움말 화면이며, 우리는 숫자의 모든 요소도 뒤집혔다는 것을 알 수 있습니다.

00:03:10.000 --> 00:03:12.000
사이드바는 왼쪽에 있습니다.

00:03:12.000 --> 00:03:16.000
탭 바는 오른쪽에서 왼쪽으로 이어진다. 심지어 문서 자체도 뒤집혔다.

00:03:16.000 --> 00:03:21.000
그리고 맥 메뉴 바와 독도 오른쪽에서 왼쪽으로 달린다.

00:03:21.000 --> 00:03:27.000
이 모든 것을 올바르게 하는 것은 복잡할 수 있지만, 좋은 소식은 우리가 당신을 위해 대부분의 무거운 일을 한다는 것입니다.

00:03:27.000 --> 00:03:30.000
오른쪽에서 왼쪽으로의 대부분의 지원은 무료로 제공됩니다.

00:03:30.000 --> 00:03:32.000
하지만 명심해야 할 것들이 있다.

00:03:32.000 --> 00:03:41.000
그래서 그것이 우리가 이야기할 것입니다, 시스템이 당신을 위해 무엇을 하는지, 당신이 옵트인 또는 옵트아웃을 해야 할 때, 그리고 자신의 right to left 지원을 구현할 때 무엇을 생각해야 하는지에 대해 이야기할 것입니다.

00:03:41.000 --> 00:03:47.000
우리는 텍스트, 이미지, 제어 방향 및 UI 레이아웃에 대해 이야기할 것입니다.

00:03:47.000 --> 00:03:50.000
우리는 또한 아랍어로 숫자를 표시하는 것을 다룰 것이다.

00:03:50.000 --> 00:03:57.000
그리고 마지막으로, 우리는 당신의 앱이 오른쪽에서 왼쪽으로 올바르게 처리되고 있는지 테스트하는 방법에 대해 조금 이야기할 것입니다.

00:03:57.000 --> 00:03:59.000
그럼 뛰어들자.

00:03:59.000 --> 00:04:04.000
먼저, 우리는 텍스트가 어떻게 작동하는지에 대해 조금 더 이야기하고 몇 가지 용어를 소개할 것입니다.

00:04:04.000 --> 00:04:07.000
방향 작성의 개념부터 시작합시다.

00:04:07.000 --> 00:04:16.000
우리가 이미 보았듯이, 영어는 왼쪽에서 오른쪽으로 쓰여지고, 히브리어는 오른쪽에서 왼쪽으로 쓰여졌다.

00:04:16.000 --> 00:04:21.000
하지만 우리가 그것들을 섞으면 어떻게 되나요?

00:04:21.000 --> 00:04:38.000
이와 같은 다국어 문장이 있다면, 개별 구성 요소는 여전히 쓰기 방향을 유지하지만, 이것은 이 문장들 각각이 이제 세 가지 구성 요소로 구성되어 있다는 것을 의미합니다: 하나의 스니펫을 다른 언어로 샌드위치하는 모국어로 된 두 개의 별도의 텍스트 스니펫.

00:04:38.000 --> 00:04:44.000
우리가 단락의 쓰기 방향에 대해 이야기할 때, 우리는 이러한 개별 스니펫의 순서에 대해 이야기하고 있다.

00:04:44.000 --> 00:05:00.000
우리가 영어 문장이 왼쪽에서 오른쪽으로 쓰기 방향이라고 말할 때, 그것은 이 세 개의 상자가 왼쪽에서 오른쪽으로 실행되기 때문이고, 히브리어 문장이 오른쪽에서 왼쪽으로 쓰기 방향이 있다고 말할 때, 그것은 그 세 개의 상자가 오른쪽에서 왼쪽으로 실행되기 때문이다.

00:05:00.000 --> 00:05:03.000
다르지만 관련된 개념은 텍스트 정렬이다.

00:05:03.000 --> 00:05:09.000
왼쪽에서 오른쪽으로 언어를 읽으면, 당신의 눈은 페이지의 왼쪽으로 가서 오른쪽으로 진행합니다.

00:05:09.000 --> 00:05:13.000
만약 당신이 오른쪽에서 왼쪽으로 언어를 읽는다면, 그 반대입니다.

00:05:13.000 --> 00:05:18.000
그래서 텍스트는 오른쪽에서 왼쪽 언어로 오른쪽에 정렬된다.

00:05:18.000 --> 00:05:23.000
좋은 소식은 대부분의 경우, 당신은 이것들 중 어느 것에 대해서도 걱정할 필요가 없다는 것입니다.

00:05:23.000 --> 00:05:38.000
CoreText는 다른 방향의 텍스트가 한 줄에 섞일 때를 포함하여 텍스트의 한 줄이나 단락에 모든 문자를 올바르게 정렬할 뿐만 아니라 모든 UI 프레임워크는 자동으로 쓰기 방향과 정렬을 설정합니다.

00:05:38.000 --> 00:05:44.000
모든 UI 위젯은 "자연스러운 글쓰기 방향"과 "자연스러운 정렬"이라고 불리는 것으로 기본 설정됩니다.

00:05:44.000 --> 00:05:50.000
텍스트 위젯의 쓰기 방향은 기본적으로 사용자의 UI 언어의 일반적인 쓰기 방향과 일치합니다.

00:05:50.000 --> 00:05:57.000
즉, UI가 히브리어 또는 아랍어인 경우, 텍스트 위젯의 쓰기 방향은 오른쪽에서 왼쪽으로 기본 설정됩니다.

00:05:57.000 --> 00:06:00.000
자연스러운 정렬은 글쓰기 방향을 따른다.

00:06:00.000 --> 00:06:07.000
즉, 텍스트 위젯의 쓰기 방향이 오른쪽에서 왼쪽으로 있다면, 그것은 또한 오른쪽 정렬될 것이다.

00:06:07.000 --> 00:06:11.000
대부분의 경우, 이것은 당신이 원하는 것이지만, 기본값을 재정의할 수 있습니다.

00:06:11.000 --> 00:06:15.000
우리는 제어 방향 섹션에서 이것에 대해 더 이야기할 것이다.

00:06:15.000 --> 00:06:19.000
이제 당신이 마주치게 될 용어의 작은 차트를 시작하기에 좋은 시간인 것 같습니다.

00:06:19.000 --> 00:06:28.000
우리가 여기서 말하는 것은 자연 정렬이 왼쪽에서 오른쪽 언어의 왼쪽 정렬과 오른쪽에서 왼쪽 언어의 오른쪽 정렬에 해당한다는 것입니다.

00:06:28.000 --> 00:06:30.000
우리는 이 차트에 추가할 것이다.

00:06:30.000 --> 00:06:33.000
하지만 물론, 그것은 단지 당신이 걱정해야 하는 문자가 아닙니다.

00:06:33.000 --> 00:06:40.000
반대 방향으로 읽는 텍스트는 텍스트 이외의 응용 프로그램의 요소에 지대한 영향을 미칩니다.

00:06:40.000 --> 00:06:45.000
그것이 아이콘과 다른 그림 요소에 어떤 영향을 미칠 수 있는지에 대해 이야기해 봅시다.

00:06:45.000 --> 00:06:49.000
이것은 영어와 아랍어로 된 페이지 도구 모음입니다.

00:06:49.000 --> 00:06:52.000
도구 모음의 몇 가지 아이콘을 자세히 살펴봅시다.

00:06:52.000 --> 00:06:57.000
"페이지 추가"와 "미디어" 버튼과 같은 많은 것들은 두 언어 모두에서 동일하게 보입니다.

00:06:57.000 --> 00:07:05.000
이것은 그들이 대칭적이거나 방향성이 언어와 관련이 없기 때문이며, 두 언어 모두에서 괜찮아 보이기 때문이다.

00:07:05.000 --> 00:07:11.000
"보기" 및 "문서" 버튼과 같은 다른 버튼은 아랍어로 된 미러 이미지로 전환됩니다.

00:07:11.000 --> 00:07:20.000
"보기" 버튼은 아랍어로 창의 반대편에 나타나는 페이지 사이드바를 표시하므로, 아이콘을 반영하기 위해 변경해야 합니다.

00:07:20.000 --> 00:07:27.000
"문서" 버튼은 사용자가 아랍어로 글을 쓰고 있다면 페이지가 반대 방향으로 회전한다는 것을 보여주기 위해 바뀝니다.

00:07:27.000 --> 00:07:30.000
그리고 아이콘이 완전히 바뀌는 상황을 가질 수 있습니다.

00:07:30.000 --> 00:07:38.000
"텍스트 상자 삽입" 버튼의 문자는 사용자의 언어를 반영하기 위해 다른 문자로 바뀝니다.

00:07:38.000 --> 00:07:42.000
다시 한 번, 좋은 소식은 이 중 많은 것들이 당신을 위해 처리된다는 것입니다.

00:07:42.000 --> 00:07:50.000
일반적으로 텍스트 쓰기 방향에 대해 생각하는 것보다 이미지 방향에 대해 조금 더 생각해야 하지만, 일을 올바르게 하는 것은 꽤 간단합니다.

00:07:50.000 --> 00:07:54.000
이것은 영어와 아랍어로 된 Mac 페이지의 "보기" 메뉴입니다.

00:07:54.000 --> 00:07:57.000
"룰러 표시" 아이콘이 역전된다는 점에 유의하세요.

00:07:57.000 --> 00:08:02.000
오른쪽에서 왼쪽 언어에서, 수직 눈금자는 오른쪽에 있다.

00:08:02.000 --> 00:08:08.000
눈금자 아이콘과 같은 사용자 지정 이미지의 경우, 오른쪽에서 왼쪽 동작은 Xcode 이미지 세트 편집기에서 제어됩니다.

00:08:08.000 --> 00:08:13.000
만약 당신의 이미지가 왼쪽에서 오른쪽으로 그리고 오른쪽에서 왼쪽으로 동일하다면, 당신은 특별한 것을 할 필요가 없습니다.

00:08:13.000 --> 00:08:22.000
이 시스템은 또한 앱이 개발 언어와 반대되는 쓰기 방향을 가진 언어로 실행될 때 이미지를 알고리즘으로 미러링할 수 있습니다.

00:08:22.000 --> 00:08:25.000
Xcode의 이미지 세트 편집기에서 이 기능을 요청할 수 있습니다.

00:08:25.000 --> 00:08:32.000
사이드바에서 "방향"으로 표시된 컨트롤을 찾을 수 있습니다. 이것을 클릭하면, 네 가지 선택지가 있는 메뉴를 얻을 수 있습니다.

00:08:32.000 --> 00:08:41.000
UI 언어에 관계없이 이미지가 동일하다면, "고정"을 선택하세요. 알고리즘 미러링을 원한다면, "거울" 옵션 중 하나를 선택하여 선택하세요.

00:08:41.000 --> 00:08:45.000
어느 것이 당신의 개발 언어의 쓰기 방향에 달려 있는지.

00:08:45.000 --> 00:09:06.000
알고리즘으로 미러링할 수 없는 이미지가 있는 경우, UI가 방향을 변경할 때 다르게 작동하는 여러 요소가 있거나 이동하고 싶지 않은 음영이 있는 경우, "둘 다"를 선택하고 세 개의 새로운 우물이 이미지 세트 편집기에 추가되어 왼쪽에서 오른쪽으로, 오른쪽에서 왼쪽 컨텍스트에 사용할 별도의 이미지를 만들 수 있습니다.

00:09:06.000 --> 00:09:12.000
하지만 페이지 도구 모음처럼 SF 심볼의 이미지를 사용한다면, 일이 훨씬 더 쉬워집니다.

00:09:12.000 --> 00:09:14.000
거의 모든 일이 당신을 위해 완료되었습니다.

00:09:14.000 --> 00:09:19.000
오른쪽에서 왼쪽으로 변경해야 하는 기호는 자동으로 변경됩니다.

00:09:19.000 --> 00:09:22.000
예를 들어 이 글머리 기호 목록 아이콘을 생각해 보세요.

00:09:22.000 --> 00:09:30.000
많은 이미지의 경우, SF Symbols의 사이드바에는 선택한 이미지의 현지화된 버전을 보여주는 "현지화" 섹션이 있습니다.

00:09:30.000 --> 00:09:35.000
이 경우, 글머리 기호 목록 아이콘은 왼쪽에서 오른쪽으로, 오른쪽에서 왼쪽으로 버전이 다릅니다.

00:09:35.000 --> 00:09:38.000
그것은 자동으로 반영된다.

00:09:38.000 --> 00:09:42.000
현지화 기능은 오른쪽에서 왼쪽 언어에 대한 미러링을 넘어설 수 있다.

00:09:42.000 --> 00:09:46.000
여기 "텍스트 상자 삽입" 아이콘의 현지화 탭이 있습니다.

00:09:46.000 --> 00:09:53.000
그것은 라틴어와 아랍 문자뿐만 아니라 다양한 다른 것들도 현지화된 버전을 가지고 있다.

00:09:53.000 --> 00:10:00.000
아랍어 지원에 특히 중요한 한 가지 사례는 종종 "도움말" 아이콘으로 사용되는 물음표이다.

00:10:00.000 --> 00:10:04.000
아랍어에서, 물음표는 라틴어 물음표의 반대이다.

00:10:04.000 --> 00:10:11.000
도움말 아이콘으로 SF 심볼의 아이콘을 사용하면 추가 작업 없이 이 버전을 얻을 수 있습니다.

00:10:11.000 --> 00:10:17.000
신중하게 생각해야 할 이미지의 한 종류는 화살표와 다른 방향 표시기입니다.

00:10:17.000 --> 00:10:20.000
여기 네 개의 화살표 아이콘이 있습니다.

00:10:20.000 --> 00:10:22.000
당신은 그들이 두 쌍으로 있다는 것을 알게 될 것입니다.

00:10:22.000 --> 00:10:25.000
두 개는 왼쪽을 가리키고 두 개는 오른쪽을 가리키고 있습니다.

00:10:25.000 --> 00:10:35.000
왼쪽에 있는 두 개만 보면, "arrow.backward.circle"이라고 불리는 것을 볼 수 있습니다. 이것은 오른쪽에서 왼쪽으로 오른쪽을 가리키기 위해 뒤집힌다.

00:10:35.000 --> 00:10:41.000
다른 하나는 "arrow.left..circle"이라고 불리며 오른쪽에서 왼쪽으로 뒤집지 않습니다.

00:10:41.000 --> 00:10:48.000
SF 기호는 오른쪽에서 왼쪽으로 뒤집고 싶을 수도 있고 원하지 않을 수도 있는 아이콘과 함께 이 명명 규칙을 따릅니다.

00:10:48.000 --> 00:10:52.000
"앞으로"와 "뒤로"는 뒤집히고, "왼쪽"과 "오른쪽"은 그렇지 않다.

00:10:52.000 --> 00:11:06.000
"앞으로" 또는 "뒤로"의 아이디어를 전달하기 위해 화살표나 다른 모양을 사용하는 경우, 뒤집기 버전을 사용하고 싶고, 절대 방향을 전달하기 위해 화살표를 사용하는 경우, 뒤집지 않는 버전을 사용하고 싶습니다.

00:11:06.000 --> 00:11:08.000
그리고 "용어" 차트에 행을 추가해 봅시다.

00:11:08.000 --> 00:11:19.000
SF 기호에서 이미지를 선택할 때, "왼쪽"과 "오른쪽"은 항상 그 방향을 가리키고 "앞으로"와 "뒤로"는 UI 언어에 따라 다른 방향으로 가리키고 있다는 것을 기억하십시오.

00:11:19.000 --> 00:11:25.000
이제 컨트롤과 다른 UI 위젯이 오른쪽에서 왼쪽으로 어떻게 처리되는지에 대해 이야기해 봅시다.

00:11:25.000 --> 00:11:31.000
이것은 모양에 대한 형식 검사기를 보여주는 영어와 아랍어로 된 Mac Keynote 사이드바입니다.

00:11:31.000 --> 00:11:35.000
모든 것이 오른쪽에서 왼쪽으로 바뀌었다는 것을 주목하세요.

00:11:35.000 --> 00:11:41.000
메뉴 표시기가 오른쪽에서 왼쪽으로 이동하는 팝업 메뉴 버튼이 많이 있습니다.

00:11:41.000 --> 00:11:45.000
아랍어로 체크박스가 몇 개 있는데, 체크박스는 라벨 오른쪽에 있습니다.

00:11:45.000 --> 00:11:52.000
불투명도 슬라이더가 아랍어로 변경되어 최소값은 오른쪽에 있고 최대값은 왼쪽에 있습니다.

00:11:52.000 --> 00:11:56.000
그리고 이 검사관의 다른 모든 컨트롤을 통해.

00:11:56.000 --> 00:11:59.000
좋은 소식은 당신이 이 행동을 무료로 받는다는 것입니다.

00:11:59.000 --> 00:12:06.000
모든 UI 프레임워크의 모든 표준 UI 컨트롤은 오른쪽에서 왼쪽 언어의 모양을 자동으로 반전합니다.

00:12:06.000 --> 00:12:12.000
그러나, 당신이 이것을 원하지 않거나 그것이 어떻게 일어나는지 어느 정도 통제해야 하는 상황이 있습니다.

00:12:12.000 --> 00:12:16.000
몇 가지 흥미로운 사례를 살펴봅시다.

00:12:16.000 --> 00:12:21.000
텍스트 라벨과 아이콘이 모두 있는 버튼에 대해 이야기해 봅시다.

00:12:21.000 --> 00:12:26.000
이것은 "이동" 애니메이션의 컨트롤을 보여주는 키노트 애니메이션 검사기입니다.

00:12:26.000 --> 00:12:30.000
이 검사기에는 라벨과 아이콘이 있는 두 개의 버튼이 있습니다.

00:12:30.000 --> 00:12:38.000
미리보기 버튼의 화살표는 UI 방향의 변화와 함께 뒤집히지만, 애니메이션 방향 메뉴의 화살표는 그렇지 않습니다.

00:12:38.000 --> 00:12:48.000
UI 방향이 있는 양면 모두 있지만, 방향 제어가 메뉴 대신 버튼 그룹이었다면, 측면을 바꾸고 싶지 않은 이미지를 만들 수 있습니다.

00:12:48.000 --> 00:12:55.000
이것을 제어하는 방법을 보여주기 위해, 나는 그 두 가지 예를 작은 장난감 응용 프로그램으로 분리했다.

00:12:55.000 --> 00:12:59.000
여기 SwiftUI에서 UI를 구축하는 코드가 있습니다.

00:12:59.000 --> 00:13:01.000
여기에 주목해야 할 몇 가지 흥미로운 것들이 있다.

00:13:01.000 --> 00:13:02.000
우리는 그것들을 한 번에 하나씩 볼 거야.

00:13:02.000 --> 00:13:06.000
이미지 이름부터 시작합시다.

00:13:06.000 --> 00:13:12.000
우리가 전에 보았듯이, SF 심볼의 이미지의 경우, 반전되는 아이콘이나 그렇지 않은 아이콘을 선택합니다.

00:13:12.000 --> 00:13:16.000
여기서 우리는 "미리보기" 버튼에 "arrowtriangle.forward.fill"을 사용했습니다.

00:13:16.000 --> 00:13:20.000
이름의 "앞으로"는 오른쪽에서 왼쪽으로 뒤집힌다는 것을 알려줍니다.

00:13:20.000 --> 00:13:24.000
우리는 방향 버튼에 "arrow.left"와 "arrow.right"를 사용했습니다.

00:13:24.000 --> 00:13:29.000
이름의 "왼쪽"과 "오른쪽"은 그들이 오른쪽에서 왼쪽으로 뒤집지 않는다는 것을 알려줍니다.

00:13:29.000 --> 00:13:33.000
AppKit 또는 UIKit에서 작업하는 경우, 이것은 같은 방식으로 작동합니다.

00:13:33.000 --> 00:13:37.000
여기 "미리보기" 버튼이 선택된 Xcode의 스토리보드 편집기에 있는 제 앱이 있습니다.

00:13:37.000 --> 00:13:43.000
속성 관리자의 "이미지" 컨트롤로 버튼의 아이콘을 제어합니다.

00:13:43.000 --> 00:13:52.000
그리고 코드에서, 버튼의 "이미지" 속성으로 이것을 설정하면, AppKit과 UIKit 모두에서 기본적으로 같은 방식으로 작동합니다.

00:13:52.000 --> 00:13:59.000
SwiftUI 예제로 돌아가서, 다음 질문은 아이콘이 라벨의 어느 쪽으로 가는지 제어하는 방법입니다.

00:13:59.000 --> 00:14:02.000
라벨 스타일을 설정하여 이것을 합니다.

00:14:02.000 --> 00:14:09.000
내장된 TitleAndIconLabelStyle은 사용자의 읽기 방향으로 라벨 앞에 아이콘을 놓습니다.

00:14:09.000 --> 00:14:11.000
우리는 이것을 "왼쪽" 버튼에 사용할 수 있습니다.

00:14:11.000 --> 00:14:17.000
다른 두 버튼의 경우, 우리는 아이콘이 사용자의 읽기 방향의 라벨 뒤에 가기를 원합니다.

00:14:17.000 --> 00:14:22.000
이렇게 하려면, 사용자 지정 라벨 스타일이 필요하지만, 그렇게 하는 것은 꽤 쉽습니다.

00:14:22.000 --> 00:14:28.000
라벨 스타일의 makeBody() 메서드는 HStack을 만들고 제목과 아이콘을 추가하기만 하면 됩니다.

00:14:28.000 --> 00:14:37.000
다른 HStack과 마찬가지로, 추가한 순서는 표시되는 순서를 결정하며, UI 방향에 적절할 때 순서가 자동으로 역전됩니다.

00:14:37.000 --> 00:14:42.000
이 기술은 버튼뿐만 아니라 라벨을 취할 수 있는 모든 보기에서 작동합니다.

00:14:42.000 --> 00:14:47.000
물론, 당신은 아이콘이 "오른쪽" 버튼의 측면을 바꾸는 것을 원하지 않습니다.

00:14:47.000 --> 00:14:51.000
당신은 UI 방향에 관계없이 항상 오른쪽에 있기를 원합니다.

00:14:51.000 --> 00:14:55.000
그것은 우리를 이 코드 스니펫의 마지막 흥미로운 것으로 이끈다.

00:14:55.000 --> 00:15:01.000
SwiftUI의 뷰는 수정할 수 있는 SwiftUI 환경에서 방향성을 선택합니다.

00:15:01.000 --> 00:15:09.000
보기에 "환경" 수정자를 추가하고 변경하려는 속성에 대한 키와 새로운 값을 제공하여 이를 수행하십시오.

00:15:09.000 --> 00:15:19.000
여기서 우리는 부모로부터 어떤 가치를 물려받을 수 있는지에 관계없이 환경의 layoutDirection 속성을 항상 오른쪽으로 재정의하고 있습니다.

00:15:19.000 --> 00:15:25.000
이러한 방식으로 환경을 변경하는 것은 사용자의 UI 방향에 반응하는 모든 SwiftUI 보기에서 작동합니다.

00:15:25.000 --> 00:15:31.000
"왼쪽"과 "오른쪽" 버튼이 포함된 HStack에 수정자를 적용했습니다.

00:15:31.000 --> 00:15:46.000
뷰의 환경에 대한 모든 변경 사항은 자식 뷰에 의해 상속되므로, 여기에 두는 것은 HStack이 버튼의 순서를 뒤집는 것을 방지할 뿐만 아니라 두 버튼 모두 라벨의 레이아웃을 뒤집는 것을 방지합니다.

00:15:46.000 --> 00:15:57.000
그리고 물론, 우리는 "미리보기" 버튼에 대한 부모 체인의 어떤 것에도 환경 수정자 수정자를 적용하지 않았기 때문에, 우리가 원하는 대로 적절할 때 여전히 반전됩니다.

00:15:57.000 --> 00:16:13.000
요약하자면, "왼쪽" 버튼은 내장된 TitleAndIconLabelStyle을 사용했기 때문에 왼쪽에 아이콘이 있고, "미리보기"와 "오른쪽" 버튼은 IconOnRightLabelStyle이라고 불리는 사용자 지정 라벨 스타일을 사용했기 때문에 오른쪽에 아이콘이 있습니다.

00:16:13.000 --> 00:16:25.000
"왼쪽"과 "오른쪽" 버튼은 라벨이 포함된 HStack에 환경 수정자를 추가하여 레이아웃 방향을 왼쪽에서 오른쪽으로 설정했기 때문에 라벨의 순서나 내부 배열을 변경하지 않습니다.

00:16:25.000 --> 00:16:32.000
"미리보기" 버튼은 수정자가 없기 때문에 라벨의 내부 배열을 뒤집습니다.

00:16:32.000 --> 00:16:35.000
이것은 AppKit과 UIKit에서 다르게 작동합니다.

00:16:35.000 --> 00:16:44.000
두 프레임워크 모두에서 라벨에 대한 아이콘의 위치는 Xcode의 속성 관리자의 "위치" 컨트롤로 제어됩니다.

00:16:44.000 --> 00:16:53.000
이 컨트롤을 클릭하면, 메뉴에 다른 옵션 중에서 라벨과 아이콘을 수평으로 정렬하는 두 쌍의 옵션이 있다는 것을 알 수 있습니다.

00:16:53.000 --> 00:17:03.000
당신은 "리딩"과 "왼쪽"이 있고, "트레일링"과 "오른쪽"이 있습니다. "리딩"과 "트레일링"은 UI 방향에 따라 의미를 바꾸고, "왼쪽"과 "오른쪽"은 그렇지 않습니다.

00:17:03.000 --> 00:17:07.000
AppKit에서, 버튼의 imagePosition 속성으로 이것을 제어할 수 있습니다.

00:17:07.000 --> 00:17:16.000
UIKit에서는 버튼 구성의 imagePlacement 속성으로, 먼저 버튼 구성을 설정해야 할 수도 있습니다.

00:17:16.000 --> 00:17:31.000
"미리보기" 버튼의 아이콘은 위치를 "트레일링"으로 설정했기 때문에 측면을 변경하고, "오른쪽" 버튼의 아이콘은 위치를 "오른쪽"으로 설정했기 때문에 측면을 변경하지 않습니다. 이것은 또한 우리가 "용어" 차트의 마지막 행을 채울 수 있게 해준다.

00:17:31.000 --> 00:17:35.000
"리딩"과 "트레일링"이라는 용어는 UI 레이아웃을 논의할 때 많이 나올 것이다.

00:17:35.000 --> 00:17:51.000
"앞으로"와 "뒤로"처럼, 당신은 종종 "왼쪽"과 "오른쪽"과 대조적으로 사용되는 것을 보게 될 것입니다. 무언가의 "선도" 가장자리는 줄의 시작 부분 또는 독자가 읽기 시작할 화면이나 창의 측면에 가장 가까운 가장자리이며, 왼쪽에서 오른쪽으로, 오른쪽에서 오른쪽에서 왼쪽으로.

00:17:51.000 --> 00:17:59.000
후행 가장자리는 반대편이며, 선의 끝에 가장 가깝고, 오른쪽은 왼쪽에서 오른쪽으로, 왼쪽은 오른쪽에서 왼쪽으로.

00:17:59.000 --> 00:18:08.000
대부분의 경우, 당신은 "왼쪽"과 "오른쪽" 대신 이것들을 사용하고, 절대적인 방향에 묶여 있는 것들에 대해서만 "왼쪽"과 "오른쪽"을 저장하고 싶습니다.

00:18:08.000 --> 00:18:10.000
또 다른 흥미로운 사례를 살펴봅시다.

00:18:10.000 --> 00:18:16.000
이것은 영어와 아랍어로 된 iPhone의 Keynote의 텍스트 형식 관리자의 일부입니다.

00:18:16.000 --> 00:18:20.000
이 특정 스크린샷에는 네 개의 분할된 컨트롤이 있습니다.

00:18:20.000 --> 00:18:30.000
상위 두 개, 인스펙터의 페이지 선택기와 표준 "볼드/이탈릭/밑줄" 스타일 버튼은 UI 언어에 따라 세그먼트의 순서를 반전합니다.

00:18:30.000 --> 00:18:34.000
아랍어를 읽지 않는다면, 페이지 선택기에서 나를 믿어야 할 것이다.

00:18:34.000 --> 00:18:40.000
우리가 살펴본 다른 컨트롤과 마찬가지로, 이것은 기본값입니다; 당신은 이 동작을 무료로 얻을 수 있습니다.

00:18:40.000 --> 00:18:45.000
다른 두 개의 분할된 컨트롤인 정렬 컨트롤은 세그먼트의 순서를 바꾸지 않는다.

00:18:45.000 --> 00:18:48.000
이것은 그들이 절대적인 방향으로 움직이기 때문이다.

00:18:48.000 --> 00:18:54.000
왼쪽 정렬은 그것이 선의 시작인지 끝인지에 관계없이 왼쪽 정렬이다.

00:18:54.000 --> 00:18:58.000
이러한 컨트롤이 어떻게 반전되는 것을 막는지 살펴봅시다.

00:18:58.000 --> 00:19:01.000
우리는 이미 SwiftUI에서 이것을 하는 방법을 알고 있다.

00:19:01.000 --> 00:19:06.000
환경의 layoutDirection 속성을 왼쪽에서 오른쪽으로 변경하는 "환경" 수정자를 적용하면 됩니다.

00:19:06.000 --> 00:19:16.000
여기서, 우리는 정렬 제어가 반전되는 것을 막기 위해 이 기술을 사용하고 있지만, 스타일 컨트롤이 평소처럼 반전되도록 하고 있습니다.

00:19:16.000 --> 00:19:18.000
UIKit에서, 이것은 다르게 작동한다.

00:19:18.000 --> 00:19:24.000
다음은 세분화된 제어 동작을 시뮬레이션하도록 설계된 Xcode의 장난감 응용 프로그램입니다.

00:19:24.000 --> 00:19:32.000
나는 두 개의 분할된 컨트롤을 가지고 있는데, 하나는 볼드/이탈릭/밑줄 동작을 모방하는 것이고 다른 하나는 정렬 컨트롤을 모방하는 것이다.

00:19:32.000 --> 00:19:34.000
정렬 제어가 선택되었습니다.

00:19:34.000 --> 00:19:42.000
속성 관리자에서 "시맨틱"이라고 표시된 메뉴를 찾을 수 있습니다. 그 메뉴를 클릭하면, 다섯 가지 선택을 할 수 있습니다.

00:19:42.000 --> 00:19:46.000
이 메뉴는 의미론적 콘텐츠 속성이라고 불리는 것을 제어한다.

00:19:46.000 --> 00:19:55.000
당신은 이것을 사용하여 이것이 어떤 종류의 제어인지 말하고, 시스템은 그것을 사용하여 UI 방향에 따라 모양을 뒤집는지 결정합니다.

00:19:55.000 --> 00:20:00.000
기본값은 "Unspecified"이며, 이는 컨트롤이 모양을 뒤집게 한다.

00:20:00.000 --> 00:20:06.000
"재생"은 컨트롤이 미디어 재생 컨트롤 또는 재생 컨트롤 그룹의 일부라고 말한다.

00:20:06.000 --> 00:20:11.000
"공간"은 제어가 공간 제어 또는 그들 그룹의 일부라고 말한다.

00:20:11.000 --> 00:20:16.000
공간 제어는 우주에서 절대 방향으로 물건을 움직인다.

00:20:16.000 --> 00:20:23.000
그리고 마지막으로, 당신은 컨트롤이 항상 왼쪽에서 오른쪽으로 또는 오른쪽에서 왼쪽으로 배치하도록 강요할 수 있습니다.

00:20:23.000 --> 00:20:43.000
따라서 굵은/이탤릭/밑줄 컨트롤은 의미론적 콘텐츠 속성이 "Unspecified"로 설정되어 있기 때문에 오른쪽에서 왼쪽으로 세그먼트를 뒤집고, 정렬 컨트롤은 의미론적 콘텐츠 속성이 "공간적"으로 설정되어 있기 때문에 세그먼트를 뒤집지 않습니다. 이것의 좋은 점은 UISegmentedControl에서만 작동하지 않는다는 것이다.

00:20:43.000 --> 00:20:50.000
모든 UIViews에는 의미론적 콘텐츠 속성이 있으며, 모든 컨트롤의 오른쪽에서 왼쪽 동작을 제어합니다.

00:20:50.000 --> 00:21:02.000
하위 구성 요소가 있는 표준 UIKit 뷰의 경우, 의미론적 콘텐츠 속성은 해당 뷰의 하위 구성 요소의 위치가 UI 언어에 따라 역전되는지 여부를 결정합니다.

00:21:02.000 --> 00:21:05.000
AppKit에서, 당신은 이런 종류의 일을 다르게 합니다.

00:21:05.000 --> 00:21:21.000
모든 NSControls의 Xcode 속성 속성 속성에는 "레이아웃"과 "미러"로 표시된 두 개의 메뉴가 포함되어 있습니다. "레이아웃" 메뉴는 컨트롤이 왼쪽에서 오른쪽으로 또는 오른쪽에서 왼쪽 레이아웃을 사용해야 하는지 여부를 말하는 컨트롤의 userInterfaceLayoutDirection 속성에 해당합니다.

00:21:21.000 --> 00:21:24.000
인터페이스 빌더에서 작업할 때 일반적으로 이것을 변경하지 않습니다.

00:21:24.000 --> 00:21:27.000
대신, 당신은 "거울" 메뉴를 사용합니다.

00:21:27.000 --> 00:21:42.000
"항상"으로 설정하면 사용자의 UI 언어가 오른쪽에서 왼쪽으로 있을 때 펜촉이 로드될 때 userInterfaceLayoutDirection과 컨트롤의 레이아웃이 뒤집히고, "Never"로 설정하면 이 동작을 물리치고 레이아웃을 동일하게 유지합니다.

00:21:42.000 --> 00:21:48.000
이 값을 "절대"로 설정하여 정렬 컨트롤의 레이아웃을 동일하게 유지합니다.

00:21:48.000 --> 00:21:57.000
인터페이스 빌더에서 작업하지 않는다면, 컨트롤의 userInterfaceLayoutDirection을 왼쪽에서 오른쪽으로 직접 설정하여 코드에서 동일한 작업을 수행할 수 있습니다.

00:21:57.000 --> 00:22:12.000
그건 그렇고, userInterfaceLayoutDirection은 NSView의 속성이지만, NSControl의 인스턴스에서만 Interface Builder에 나타나므로, NSControl이 아닌 것을 되돌리고 싶다면, 여기에 보여주는 것과 같은 코드가 필요합니다.

00:22:12.000 --> 00:22:15.000
우리가 넘어가기 전에, 나는 문자에 대해 조금 더 이야기하고 싶다.

00:22:15.000 --> 00:22:20.000
이것은 Mac용 iWork의 "문서 비밀번호 설정" 대화상자입니다.

00:22:20.000 --> 00:22:23.000
아랍어 버전에서, 당신은 모든 것이 반전된 것을 보게 될 것입니다.

00:22:23.000 --> 00:22:25.000
하지만 라벨에 무슨 일이 일어났는지 주목하세요.

00:22:25.000 --> 00:22:29.000
영어로, 그들은 편집 텍스트 필드에 가까울 수 있도록 올바르게 정렬되었다.

00:22:29.000 --> 00:22:32.000
아랍어로, 그들은 왼쪽 정렬되어 있다.

00:22:32.000 --> 00:22:38.000
다시 말해서, 당신이 원한다면, 당신은 자연 정렬, 트레일링 엣지 정렬의 반대를 가지고 있습니다.

00:22:38.000 --> 00:22:42.000
Mac의 SwiftUI에서 이 레이아웃을 얻는 것은 매우 쉽다.

00:22:42.000 --> 00:22:45.000
양식을 사용하여 텍스트 필드를 함께 모으세요.

00:22:45.000 --> 00:22:51.000
하지만 우리의 예에서와 같이 라벨 중 하나가 여러 줄이라면 이것은 흥미로울 수 있다.

00:22:51.000 --> 00:22:56.000
우리가 마지막 라벨을 두 줄로 확장하면, 우리는 이것을 얻을 수 있다.

00:22:56.000 --> 00:23:01.000
두 개의 한 줄 라벨은 올바르게 정렬되어 있지만, 두 줄 라벨은 그렇지 않다.

00:23:01.000 --> 00:23:04.000
문제는, 하단 라벨이 정말로 정렬되어 있다는 것이다.

00:23:04.000 --> 00:23:11.000
경계 상자가 그 경계 상자 내의 개별 텍스트 줄이 아니라 오른쪽으로 정렬되어 있다는 것이다.

00:23:11.000 --> 00:23:17.000
마지막 라벨에 multilineTextAlignment 수정자를 추가하여 이 문제를 해결합니다.

00:23:17.000 --> 00:23:23.000
SwiftUI의 텍스트 정렬은 한 줄 이상의 텍스트 개체에서만 작동됩니다.

00:23:23.000 --> 00:23:32.000
한 줄 텍스트 개체의 경우, 경계 상자는 텍스트 자체를 단단히 감싸고, 전체 텍스트 개체를 정렬하여 정렬합니다.

00:23:32.000 --> 00:23:45.000
또한 텍스트의 경계 상자를 정렬하든 경계 상자 내부의 여러 줄의 텍스트를 정렬하든, 사용자의 UI 방향에 따라 의미를 변경하는 선행 및 후행 정렬을 선택할 수 있습니다.

00:23:45.000 --> 00:23:55.000
UI 방향에 관계없이 정렬을 동일하게 유지하려면, 이전에 본 것처럼 환경 수정자를 사용하여 환경의 레이아웃 방향을 변경합니다.

00:23:55.000 --> 00:24:02.000
UIKit에서 텍스트는 기본적으로 자연스럽게 정렬되지만, 필요한 경우 절대 방향 중 하나로 변경할 수 있습니다.

00:24:02.000 --> 00:24:10.000
인터페이스 빌더에서 컨트롤은 다음과 같이 보이며 UILabel과 UITextView의 textAlignment 속성에 해당합니다.

00:24:10.000 --> 00:24:16.000
맨 오른쪽에 점선이 있는 버튼은 자연스럽거나 최첨단 정렬을 제공합니다.

00:24:16.000 --> 00:24:20.000
라벨의 정렬은 라벨의 의미론적 콘텐츠 속성을 따를 것이다.

00:24:20.000 --> 00:24:28.000
다른 버튼은 UI 방향이나 라벨의 의미 콘텐츠 속성에 관계없이 왼쪽, 오른쪽 또는 중앙 정렬을 고정합니다.

00:24:28.000 --> 00:24:31.000
후행 가장자리 정렬을 위한 내장 설정은 없습니다.

00:24:31.000 --> 00:24:34.000
넌 그걸 코드로 해야 해.

00:24:34.000 --> 00:24:36.000
AppKit에서, 그것은 조금 다르다.

00:24:36.000 --> 00:24:44.000
당신은 여전히 정렬 컨트롤을 가지고 있으며, 기본적으로 UIKit과 동일하게 작동하지만, userInterfaceLayoutDirection과 상호 작용하는 방식은 다릅니다.

00:24:44.000 --> 00:24:54.000
"Mirror"를 "Automatically"로 설정하고 시스템이 userInterfaceLayoutDirection을 오른쪽에서 왼쪽으로 설정하면 모든 정렬 설정의 의미가 반전됩니다.

00:24:54.000 --> 00:25:03.000
따라서 "미러"가 "자동으로"로 설정되면, 왼쪽 정렬은 정말 최첨단 정렬이고, 오른쪽 정렬은 정말 최첨단 정렬입니다.

00:25:03.000 --> 00:25:13.000
그래서 우리는 모든 표준 UI 위젯이 사용자의 쓰기 방향에 맞게 레이아웃을 자동으로 되돌리는 방법에 대해 이야기했지만, 필요할 때 그것을 방지하는 것은 꽤 쉽습니다.

00:25:13.000 --> 00:25:18.000
이것은 화면에 개별 UI 위젯을 배열하는 것으로 확장됩니다.

00:25:18.000 --> 00:25:29.000
하위 뷰의 위치를 처리하는 표준 뷰 또는 뷰 컨트롤러 중 하나를 사용하는 경우, 모두 아무것도 할 필요 없이 필요할 때 자동으로 레이아웃을 반전합니다.

00:25:29.000 --> 00:25:34.000
테이블 뷰와 컬렉션 뷰는 오른쪽에서 왼쪽 언어로도 올바르게 스크롤을 처리합니다.

00:25:34.000 --> 00:25:45.000
UINavigationController는 사용자의 쓰기 방향을 반영하도록 segue 애니메이션의 방향을 자동으로 변경하고, "뒤로" 버튼도 일치하도록 변경합니다.

00:25:45.000 --> 00:25:53.000
그리고 UIPageViewController는 페이징 방향과 스와이프 제스처의 의미도 자동으로 반전합니다.

00:25:53.000 --> 00:26:06.000
일반적으로 자식 뷰를 배치하기 위해 스택 뷰를 사용하는 경우를 제외하고는 이러한 것들을 재정의하고 싶지 않지만, 모든 뷰는 의미론적 콘텐츠 속성을 존중하고 하위 뷰를 배치하는 방법을 알려주는 데 사용합니다.

00:26:06.000 --> 00:26:13.000
표준 AppKit 뷰도 마찬가지이며, 테이블과 컬렉션 뷰는 오른쪽에서 왼쪽으로 스크롤도 처리합니다.

00:26:13.000 --> 00:26:21.000
인터페이스 빌더는 설정할 수 없지만, 모든 뷰는 서브뷰를 배치하는 방법을 결정할 때 userInterfaceLayoutDirection 속성을 존중합니다.

00:26:21.000 --> 00:26:24.000
넌 그걸 코드로 해야 해.

00:26:24.000 --> 00:26:32.000
표준 SwiftUI 뷰는 또한 환경의 layoutDirection 속성을 반영한다.

00:26:32.000 --> 00:26:41.000
스택 및 그리드 뷰 대신 자동 레이아웃을 사용하여 뷰를 배치하는 경우, 자동 레이아웃은 UI 방향을 설명하기 위해 자동으로 반전합니다.

00:26:41.000 --> 00:26:53.000
수평적 제약이 있다면, 선행 및 후행 가장자리에 자동으로 연결되는 것을 볼 수 있으며, 우리가 보았듯이, "리딩"과 "트레일링"은 UI 방향에 따라 다른 의미를 가지고 있습니다.

00:26:53.000 --> 00:26:58.000
필요한 경우 자동 레이아웃 제약 조건을 절대 왼쪽과 오른쪽 방향으로 설정할 수 있습니다.

00:26:58.000 --> 00:27:06.000
제약 조건의 한쪽 방향을 클릭하고 팝업 메뉴에서 "언어 방향 존중"을 끄면 이 작업을 수행할 수 있습니다.

00:27:06.000 --> 00:27:17.000
그것은 제약의 양쪽 끝의 방향을 "리딩"과 "트레일링"에서 "왼쪽"과 "오른쪽"으로 바꿀 것이다. 코드에서 자동 레이아웃 제약 조건을 설정하는 방법에는 여러 가지가 있습니다.

00:27:17.000 --> 00:27:19.000
여기 그들 중 하나가 있어.

00:27:19.000 --> 00:27:34.000
당신이 어떻게 하든, 기억해야 할 것은 UI 언어의 쓰기 방향에 관계없이 동일한 레이아웃 방향을 원하는 비교적 드문 상황을 제외하고는 "왼쪽"과 "오른쪽" 대신 "선도"과 "추적"을 사용하는 것입니다.

00:27:34.000 --> 00:27:37.000
좋아, 그건 받아들일 게 많았어, 그러니 숨을 쉬자.

00:27:37.000 --> 00:27:45.000
주요 요점은 우리가 당신을 위해 오른쪽에서 왼쪽 언어를 다루는 대부분의 작업을 하고 당신이 그것을 무시해야 할 때, 그렇게 할 수 있는 방법이 있다는 것입니다.

00:27:45.000 --> 00:27:48.000
용어 슬라이드를 한 번 더 살펴봅시다.

00:27:48.000 --> 00:27:58.000
"왼쪽"과 "오른쪽"은 항상 왼쪽과 오른쪽이며 다른 용어들은 전반적인 UI 방향에 따라 의미를 뒤집는다는 것을 기억하세요.

00:27:58.000 --> 00:28:04.000
마무리하기 전에, 한 가지 더 중요한 문제를 살펴봅시다. 그것이 숫자를 표시하는 방법입니다.

00:28:04.000 --> 00:28:15.000
그것은 엄격하게 오른쪽에서 왼쪽의 문제는 아니지만, 많은 개발자들에게 아랍어는 영어에서 사용되는 것과 다른 숫자 문자를 사용하여 현지화할 첫 번째 언어이다.

00:28:15.000 --> 00:28:17.000
그 숫자들은 이렇게 생겼습니다.

00:28:17.000 --> 00:28:27.000
숫자에는 많은 다른 명명 규칙이 있지만, 나는 대부분의 유럽 언어에 사용되는 것을 "라틴" 숫자와 아랍어 "아랍어-인도" 숫자와 함께 사용되는 것을 부를 것이다.

00:28:27.000 --> 00:28:30.000
그들만의 숫자를 가진 다른 언어들이 있다.

00:28:30.000 --> 00:28:36.000
이것들은 힌디어와 함께 사용되는 데바나가리 숫자이다; 힌디어는 다른 숫자를 사용하는 다른 공통 언어이다.

00:28:36.000 --> 00:28:43.000
명심해야 할 한 가지 중요한 것은 아랍어도 힌디어도 항상 모국어자리를 사용하지 않는다는 것이다.

00:28:43.000 --> 00:28:53.000
아랍어의 경우, 사우디 아라비아와 같은 일부는 기본 숫자를 사용하고 아랍에미리트와 같은 다른 일부는 라틴 숫자를 사용하는 국가에 따라 다릅니다.

00:28:53.000 --> 00:28:57.000
개별 사용자는 또한 선호하는 숫자를 선택할 수 있습니다.

00:28:57.000 --> 00:29:05.000
힌디어의 경우, 우리는 기본적으로 라틴 숫자를 사용하지만, 사용자는 대신 기본 숫자를 사용하도록 선택할 수 있습니다.

00:29:05.000 --> 00:29:09.000
당신은 이미 이와 같은 UI 문자열을 구성하는 것이 나쁜 생각이라는 것을 알고 있습니다.

00:29:09.000 --> 00:29:15.000
문자열은 하드 코딩되어 있으며 번역할 수 없으며, 메시지는 복수형 등을 처리하도록 변경되지 않습니다.

00:29:15.000 --> 00:29:23.000
하지만 이것이 좋지 않은 또 다른 이유는 "peopleInChat"의 가치가 항상 라틴 숫자로 렌더링된다는 것이다.

00:29:23.000 --> 00:29:36.000
당신은 또한 그것에 대한 해결책이 String에서 "로컬화된" init 메소드를 사용하는 것이라는 것을 이미 알고 있을 것입니다. 이는 애플리케이션 번들에서 실제 문자열을 조회하고 stringsdict 파일이 있는 경우 복수형을 올바르게 처리합니다.

00:29:36.000 --> 00:29:39.000
좋은 소식은 그것이 또한 숫자를 올바르게 처리한다는 것이다.

00:29:39.000 --> 00:29:47.000
여기에 있는 "peopleInChat" 보간 값은 사용자의 로케일과 선호도에 대한 올바른 현지화된 숫자로 렌더링됩니다.

00:29:47.000 --> 00:29:50.000
이것은 SwiftUI의 텍스트 보기에서도 바로 작동합니다.

00:29:50.000 --> 00:29:57.000
텍스트 뷰 이니셜라이저는 또한 적절하게 현지화된 숫자로 문자열 보간을 렌더링할 것이다.

00:29:57.000 --> 00:30:01.000
사용자가 볼 수 있는 문자열을 구성할 때 항상 String(localized:)을 사용하세요.

00:30:01.000 --> 00:30:12.000
+stringWithFormat:와 숫자를 사용하는 String init 함수를 포함하여 숫자를 포맷할 수 있는 문자열의 다른 많은 API는 항상 라틴 숫자를 사용합니다.

00:30:12.000 --> 00:30:17.000
알아야 할 한 가지 주름은 이와 같은 숫자를 포함하는 정적 문자열이다.

00:30:17.000 --> 00:30:19.000
뭐가 문제야?

00:30:19.000 --> 00:30:23.000
당신은 그것을 번역가들에게 보내고, 그들은 그것을 번역하고, 당신은 이것을 얻는다.

00:30:23.000 --> 00:30:33.000
이것은 많은 곳에서 정확하지만, 사우디 아라비아와 다른 나라에서는 이것을 보고 싶어합니다. 텍스트는 3에 사용된 문자를 제외하고는 동일합니다.

00:30:33.000 --> 00:30:43.000
물론, 아랍어-인도 숫자를 사용하는 아랍어 사용 지역과 라틴 숫자를 사용하는 지역에 대한 별도의 현지화를 가질 수 있지만, 아무도 그렇게 하지 않으며, 낭비가 될 것입니다.

00:30:43.000 --> 00:30:55.000
더 나쁜 것은, 아랍어와 힌디어 모두에서 사용자가 사용하고 싶은 숫자를 선택할 수 있으므로, 로케일뿐만 아니라 사용자의 선호도에 따라 현지화를 선택해야 합니다.

00:30:55.000 --> 00:31:04.000
해결책은 여전히 하나의 아랍어 또는 힌디어 현지화를 가지고 있지만, 컴파일 시간에 값을 알고 있음에도 불구하고 런타임에 숫자를 대체하는 것입니다.

00:31:04.000 --> 00:31:10.000
스위프트에서는 문자열 보간을 사용하여 이것을 할 수 있습니다.

00:31:10.000 --> 00:31:16.000
숫자와 함께 여행하는 다른 요소가 있다면, 숫자와 관련된 배치도 어려울 수 있습니다.

00:31:16.000 --> 00:31:19.000
그것은 심지어 모든 권리에서 좌파 언어에 대해서도 같지 않다.

00:31:19.000 --> 00:31:25.000
빼기 기호와 퍼센트 기호는 아랍어와 히브리어로 숫자의 다른 면에 있다는 것을 주목하세요.

00:31:25.000 --> 00:31:28.000
사실, 그것은 전혀 오른쪽에서 왼쪽으로의 언어일 필요는 없다.

00:31:28.000 --> 00:31:34.000
왼쪽에서 오른쪽 언어인 터키어에서는 퍼센트 기호도 왼쪽에 있습니다.

00:31:34.000 --> 00:31:41.000
그리고 물론, 네이티브 아랍어 숫자를 사용하는 경우, 완전히 다른 퍼센트 기호를 사용한다는 것을 명심하세요.

00:31:41.000 --> 00:31:51.000
다시 말해서, 당신은 퍼센트 기호, 통화 기호, 단위 약어 등을 추가하는 이런 종류의 일을 하고 싶지 않습니다.

00:31:51.000 --> 00:31:56.000
대신, 숫자 포맷터를 사용하여 퍼센트 기호나 통화 기호 등을 추가하세요.

00:31:56.000 --> 00:32:01.000
스위프트에서, 이것은 모든 숫자 유형에서 formatted() 메소드로 쉽게 할 수 있다.

00:32:01.000 --> 00:32:21.000
이 예제와 같이 더 큰 문자열의 일부인 경우, String(localized:)은 포맷된 숫자 또는 다른 문자열을 포함하여 런타임에 문자열로 대체된 다른 것이 포맷된 숫자와 주변 메시지의 쓰기 방향을 유지하는 마크업으로 둘러싸여 있는지 확인합니다.

00:32:21.000 --> 00:32:28.000
마지막으로, 저는 당신이 오른쪽에서 왼쪽으로 옳은 일을 하고 있는지 확인하기 위해 앱을 테스트하기 위한 한 가지 팁을 남기고 싶습니다.

00:32:28.000 --> 00:32:34.000
오른쪽에서 왼쪽으로 앱을 테스트하기 위해 실행 파일에 아랍어 또는 히브리어 현지화가 있을 필요가 없습니다.

00:32:34.000 --> 00:32:38.000
당신은 실제로 개발 언어로 오른쪽에서 왼쪽으로 행동을 테스트할 수 있습니다.

00:32:38.000 --> 00:32:42.000
이렇게 하려면, Xcode에서 계획 편집기를 불러와.

00:32:42.000 --> 00:32:46.000
이제 옵션 탭으로 가서 "앱 언어" 메뉴를 찾으세요.

00:32:46.000 --> 00:32:50.000
이 메뉴의 하단에는 많은 "의사 언어" 옵션이 있습니다.

00:32:50.000 --> 00:32:59.000
이것들은 실제 현지화 없이 현지화 문제를 확인할 수 있도록 다양한 방법으로 UI를 변환하는 가짜 언어입니다.

00:32:59.000 --> 00:33:10.000
"오른쪽에서 왼쪽으로의 의사 언어" 옵션을 선택하고 실행을 클릭하면 앱은 여전히 영어 또는 개발 언어로 되어 있지만, UI는 모두 오른쪽에서 왼쪽으로 뒤집힐 것입니다.

00:33:10.000 --> 00:33:11.000
그리고 그게 내가 가진 전부야.

00:33:11.000 --> 00:33:21.000
오른쪽에서 왼쪽으로 언어를 현지화하는 것은 글쓰기 방향의 변화와 관련된 몇 가지 문제에 대한 관심을 수반하지만, 시스템은 당신을 위해 대부분의 무거운 일을 합니다.

00:33:21.000 --> 00:33:28.000
보통 절대 방향 주변에서 이 행동을 선택하고 싶을 수도 있는 경우가 있으며, 그것은 항상 가능합니다.

00:33:28.000 --> 00:33:33.000
그리고 모든 언어가 숫자를 렌더링하기 위해 라틴 숫자를 사용하는 것은 아니라는 것을 기억하세요.

00:33:33.000 --> 00:33:38.000
이러한 것들을 명심하세요, 그리고 일을 바로 왼쪽으로 하는 것은 어렵지 않아야 합니다.

00:33:38.000 --> 23:59:59.000
.

