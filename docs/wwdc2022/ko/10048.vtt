WEBVTT

00:00:00.000 --> 00:00:03.000
♪ 부드러운 기악 힙합 음악 ♪

00:00:03.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:14.000
안녕! 저는 사파리 팀의 소프트웨어 엔지니어인 켄달 배글리입니다.

00:00:14.000 --> 00:00:32.000
WWDC에서 마지막으로 모인 지 1년이 지났고, 오늘, 우리는 올해 WWDC의 새로운 기능과 지난 한 해 내내 본 것에서 Safari와 WebKit의 모든 놀라운 기능과 개선 사항에 대해 이야기할 것입니다.

00:00:32.000 --> 00:00:35.000
사실, 꽤 바쁜 한 해였어!

00:00:35.000 --> 00:00:44.000
지난 가을부터, 사파리의 각 릴리스는 웹 개발자로서 우리가 알고 있는 새롭고 흥미로운 기능을 제공했습니다.

00:00:44.000 --> 00:00:51.000
올해 전달된 각각의 새로운 개선 사항은 당신이 우리와 공유한 피드백의 가장 큰 요점을 해결하는 것을 목표로 했습니다.

00:00:51.000 --> 00:00:59.000
:Has() 의사 클래스, 새로운 플렉스박스 인스펙터, 심지어 컨테이너 쿼리로 부모 선택기를 추가하는 것과 같습니다.

00:00:59.000 --> 00:01:06.000
우리는 웹을 위한 최고의 가장 강력한 소프트웨어를 구축하면서 당신의 일상 업무를 훨씬 더 좋고 쉽게 만들고 싶습니다.

00:01:06.000 --> 00:01:11.000
사실, 여기에 있는 것은 우리가 오늘 검토할 새로운 콘텐츠 중 일부일 뿐입니다.

00:01:11.000 --> 00:01:18.000
하지만 우리가 이 한 세션에서 모든 것을 다룰 수 없을 만큼 훨씬 더 많다.

00:01:18.000 --> 00:01:27.000
지난 해 7개의 사파리 릴리스에서 총 162개의 새로운 웹 플랫폼 기능과 개선 사항이 있었습니다.

00:01:27.000 --> 00:01:34.000
우리는 당신이 웹사이트와 웹 앱을 만드는 데 사용할 수 있는 많은 새로운 도구를 제공하게 된 것을 자랑스럽게 생각합니다.

00:01:34.000 --> 00:01:51.000
그리고 macOS의 경우, 가능한 한 빨리 새롭고 흥미로운 것을 볼 수 있는 가장 좋은 방법은 Safari 기술 미리보기를 통해 Safari와 WebKit에 대한 최신의 최고를 시험해보고 다음에 무엇을 해야 하는지 알 수 있도록 도와주는 것입니다.

00:01:51.000 --> 00:01:59.000
하지만 보시다시겠지만, 많은 새로운 기능이 있으니, 우리가 다룰 모든 것을 살펴봅시다.

00:01:59.000 --> 00:02:23.000
오늘 우리는 새로운 HTML 기능, 코드 아키텍처에 도움이 되는 많은 것을 포함한 CSS 개선 사항, 새로운 웹 인스펙터 도구, 다양한 새로운 웹 API, 훌륭한 자바스크립트 및 웹어셈블리 기능, 보안 및 개인 정보 보호 개선 사항을 살펴볼 것입니다.

00:02:23.000 --> 00:02:32.000
그래서, 동료들과 내가 사용할 수 있도록 만들고 있는 웹 페이지를 살펴보고 HTML의 새로운 기능을 시작합시다.

00:02:32.000 --> 00:02:46.000
나는 개인적으로 내 옷장을 더 지속 가능하게 만드는 방법으로 옷을 절약하고 용도를 바꾸는 것을 정말 좋아하며, 의류 교환 웹사이트가 우리 팀도 그것을 시험해 볼 수 있는 좋은 방법이라고 생각했다.

00:02:46.000 --> 00:02:54.000
사이트에 대한 내 디자인에는 당신이 좋아하는 옷을 발견할 때 작성할 양식을 보여줘야 하는 아이템 요청 버튼이 포함되어 있습니다.

00:02:54.000 --> 00:02:58.000
그리고 나는 그 양식이 전체 페이지 상단의 오버레이에 나타나기를 원한다.

00:02:58.000 --> 00:03:08.000
새로운 대화 요소는 요청 양식에 사용할 수 있는 강력하고 접근 가능한 방식으로 오버레이를 만드는 정말 쉬운 방법을 제공합니다.

00:03:08.000 --> 00:03:16.000
그리고 CSS의 새로운 배경 의사 요소는 모달 뒤의 배경을 스타일링할 수 있게 해준다.

00:03:16.000 --> 00:03:19.000
항목을 요청하여 대화상자를 불러봅시다.

00:03:19.000 --> 00:03:22.000
그 그림자와 애니메이션이 보이니?

00:03:22.000 --> 00:03:24.000
정말 멋져 보여!

00:03:24.000 --> 00:03:32.000
그런 다음, 일단 우리 사이트에 항목이 요청되면, 그것을 게시한 사람은 요청을 수락할 수 있어야 합니다.

00:03:32.000 --> 00:03:38.000
페이지 하단에는 받은 모든 요청을 훑어볼 수 있는 회전목마가 있습니다.

00:03:38.000 --> 00:03:49.000
하지만 나는 누군가가 클릭이나 키보드 탐색으로 가장 앞이 아닌 항목 중 하나에 대해 실수로 버튼이나 텍스트 필드와 상호 작용하는 것을 원하지 않는다.

00:03:49.000 --> 00:03:52.000
나는 이것을 고치기 위해 불활성 속성을 사용할 수 있다.

00:03:52.000 --> 00:04:04.000
여기서 자바스크립트로 불활성 속성을 동적으로 적용함으로써, 현재 선택된 슬라이드가 아닌 슬라이드의 요소에 대한 상호 작용을 비활성화하고 있습니다.

00:04:04.000 --> 00:04:20.000
그리고, inert를 사용하는 것은 보조 기술에 대한 상호 작용을 비활성화하는 것을 포함하며 화면 판독기가 비활성화된 항목을 큰 소리로 읽는 것을 방지하여 상호 작용을 위한 요소에 대한 훨씬 더 명확한 지침을 제공합니다.

00:04:20.000 --> 00:04:25.000
그리고 마지막으로 HTML의 경우, 이미지에 대한 새로운 게으른 로딩이 있습니다.

00:04:25.000 --> 00:04:44.000
내 사이트에는 헤더에 바로 로드해야 하는 몇 가지 아이콘이 있지만, 첫 번째 로드 시 오프스크린에 있는 의류 아이템 이미지의 경우, 우리는 그들을 위해 게으른 로딩을 활용할 수 있으므로, 이미지가 사용자가 스크롤할 때만 로드되어 페이지가 더 빠르고 반응이 빠른 것처럼 느껴집니다.

00:04:44.000 --> 00:04:52.000
나는 그 사이트가 지금까지 어떻게 생겼는지 정말 마음에 들어, 그리고 보조 기술을 사용하는 사람들에게도 잘 작동할 거야.

00:04:52.000 --> 00:05:02.000
그리고 그 HTML 기능은 이제 막 시작하고 있습니다. 왜냐하면 올해도 CSS로 확인할 것이 너무 많기 때문입니다.

00:05:02.000 --> 00:05:10.000
우리의 CSS 초점의 큰 부분은 더 강력한 아키텍처를 통해 CSS를 더 쉽게 재사용할 수 있도록 하는 것입니다.

00:05:10.000 --> 00:05:16.000
그것으로, 우리는 새로운 웹 기술에 대한 첫 번째 요청이 컨테이너 쿼리였다는 것을 알고 있다.

00:05:16.000 --> 00:05:22.000
그리고 우리는 컨테이너 쿼리가 사파리 16에서 배송될 것이라고 발표하게 되어 기쁩니다!

00:05:22.000 --> 00:05:27.000
크기 쿼리와 컨테이너 쿼리 단위를 모두 사용할 수 있습니다.

00:05:27.000 --> 00:05:32.000
여기, 저는 의류 교환 웹사이트를 위한 대체 레이아웃을 실험하고 있습니다.

00:05:32.000 --> 00:05:42.000
나는 옷을 재사용 가능한 구성 요소로 제시하고 그 구성 요소를 페이지 레이아웃의 여러 다른 장소에 떨어뜨리는 카드를 만들고 있다.

00:05:42.000 --> 00:05:51.000
여기 사이드바에서 사용 가능한 공간이 약간 좁아서 구성 요소 내부의 모든 콘텐츠가 수직으로 쌓이기를 원합니다.

00:05:51.000 --> 00:06:05.000
항목의 주요 그리드에서, 저는 첫 번째 것을 모든 사용 가능한 공간을 수평으로 차지하고 넓은 레이아웃에 더 적합한 방식으로 콘텐츠를 배열해야 하는 영웅 그래픽으로 선보이고 싶습니다.

00:06:05.000 --> 00:06:10.000
주요 콘텐츠 영역의 나머지 항목은 더 작은 열로 나누어야 합니다.

00:06:10.000 --> 00:06:17.000
그래서 나는 중간 정도의 수평 공간이 있을 때 작동하는 또 다른 레이아웃을 만들었다.

00:06:17.000 --> 00:06:35.000
미디어 쿼리가 아닌 레이아웃 변경을 처리하기 위해 컨테이너 쿼리를 사용하면 이 구성 요소에 대한 레이아웃 코드를 한 번만 작성하고 모든 크기의 컨테이너에서 내 사이트의 어느 곳에서나 해당 구성 요소를 사용할 수 있으며 올바른 레이아웃이 항상 적용됩니다.

00:06:35.000 --> 00:06:48.000
컨테이너에 사용할 요소와 컨테이너 유형 속성을 사용하여 인라인 크기 또는 인라인 및 블록 크기를 동시에 측정할지 여부를 지정했습니다.

00:06:48.000 --> 00:06:58.000
선택적으로 컨테이너 이름 속성을 사용하여 컨테이너의 이름을 지정할 수 있으며, 이는 HTML을 구성하는 방법에 더 많은 유연성을 제공합니다.

00:06:58.000 --> 00:07:05.000
그런 다음 @container 규칙을 사용하여 컨테이너의 크기에 따라 조건부로 스타일을 적용합니다.

00:07:05.000 --> 00:07:14.000
여기서, 의류 카드 구성 요소가 250픽셀보다 넓은 컨테이너에 있다면, 그리드는 하나가 아닌 두 개의 열로 바뀔 것이다.

00:07:14.000 --> 00:07:18.000
다음은 CSS 아키텍처입니다: 캐스케이드 레이어.

00:07:18.000 --> 00:07:22.000
이것은 CSS 캐스케이드에 대한 강력한 변화이다.

00:07:22.000 --> 00:07:28.000
CSS가 시작된 이래로, 캐스케이드는 이러한 다른 레이어로 구성되어 있다.

00:07:28.000 --> 00:07:39.000
하지만 각 레이어 내부의 주어진 선택기의 특이성에 상관없이, 웹 개발자로서 작성하는 스타일인 저자 스타일은 항상 UA 스타일을 능가합니다.

00:07:39.000 --> 00:07:46.000
인라인 스타일은 항상 저자 스타일보다 더 강력하며, 나머지 계층 구조도 마찬가지입니다.

00:07:46.000 --> 00:07:57.000
캐스케이드 레이어는 동일한 개념을 취하며 각 레이어 내에서 특이성이 독립적으로 계산되는 자신만의 사용자 지정 레이어를 만들 수 있습니다.

00:07:57.000 --> 00:08:04.000
사용되는 선택기의 특이성이 무엇이든, 하나의 전체 레이어가 다른 전체 레이어를 이긴다.

00:08:04.000 --> 00:08:13.000
그리고 CSS에서 레이어를 정의하는 순서를 통해 어떤 레이어가 다른 레이어보다 더 강력한지 결정합니다.

00:08:13.000 --> 00:08:20.000
캐스케이드 레이어는 대규모 프로젝트에서 CSS를 설계하고 시간이 지남에 따라 코드를 유지하는 데 유용한 도구가 될 것이다.

00:08:20.000 --> 00:08:28.000
아마도 당신의 팀은 그것들을 사용하여 디자인 시스템을 오버라이드 또는 프로젝트의 사용자 지정 스타일에 사용하는 프레임워크와 분리할 것입니다.

00:08:28.000 --> 00:08:30.000
그건 전적으로 너에게 달렸어!

00:08:30.000 --> 00:08:42.000
그리고, CSS 아키텍처에 대한 모든 놀라운 새로운 개선 사항을 마무리하는 것은 :has()이며, 오랫동안 원하는 부모 선택기 역할을 할 수 있는 의사 클래스입니다.

00:08:42.000 --> 00:08:51.000
CSS의 다른 선택기와 결합하여, :has()는 형제자매, 속성, 양식 필드의 상태 등을 찾을 수 있습니다.

00:08:51.000 --> 00:08:54.000
그건 정말 강력해.

00:08:54.000 --> 00:09:01.000
여기, 누군가가 "긴급"을 체크할 때마다 전체 메시지 상자를 강조하고 싶습니다. 그들의 메시지 중 하나에 대한 체크박스.

00:09:01.000 --> 00:09:12.000
여기서 :has 의사 클래스를 사용하여 양식 요소에 해당 체크박스가 선택된 유형 체크박스 입력이 있을 때마다 이 CSS를 적용할 수 있습니다.

00:09:12.000 --> 00:09:16.000
그리고 나는 심지어 자바스크립트를 사용할 필요조차 없다.

00:09:16.000 --> 00:09:30.000
:Has(), 캐스케이드 레이어 및 컨테이너 쿼리를 통해 CSS 아키텍처를 처리하는 데 이러한 모든 큰 개선이 웹 개발자로서의 작업을 훨씬 더 좋게 만들기를 바랍니다.

00:09:30.000 --> 00:09:35.000
하지만 이것들은 우리가 흥분하는 유일한 CSS 추가 사항이 아니다.

00:09:35.000 --> 00:09:44.000
기존 뷰포트 장치와 유사한 도구를 원했지만 스크롤로 인해 뷰포트의 크기가 변경되는 장치에서 더 유용할 것입니다.

00:09:44.000 --> 00:09:48.000
그리고 그것을 위해, 너희 모두를 위한 새로운 뷰포트 유닛이 있다.

00:09:48.000 --> 00:09:53.000
가장 작을 때 뷰포트의 높이를 알고 싶을 때, svh를 사용하세요.

00:09:53.000 --> 00:09:57.000
가장 큰 뷰포트의 높이를 위해, lvh를 사용하세요.

00:09:57.000 --> 00:10:00.000
그냥 기억하세요: 작은 것은 s, 큰 것은 l.

00:10:00.000 --> 00:10:07.000
뷰포트의 현재 실제 높이와 항상 일치하도록 변경되는 동적 숫자의 경우, dvh를 사용하세요.

00:10:07.000 --> 00:10:10.000
그리고 그것은 단지 키만을 위한 것이 아니다.

00:10:10.000 --> 00:10:14.000
우리는 당신을 더 많은 뷰포트 유닛으로 덮었습니다.

00:10:14.000 --> 00:10:20.000
고도로 사용되는 높이 단위와 일치하도록 완성도에 좋은 너비 단위가 있습니다.

00:10:20.000 --> 00:10:28.000
우리는 블록과 인라인을 가지고 있습니다. 둘 다 텍스트가 흐를 수 있는 다른 방식으로 여러 언어로 작성할 때 유용합니다.

00:10:28.000 --> 00:10:32.000
그리고 우리는 미니와 맥스도 잊지 않았다.

00:10:32.000 --> 00:10:39.000
하지만 그냥 반응하는 것이 아니라 페이지에 움직임을 만들고 싶을 때는 어떨까요?

00:10:39.000 --> 00:10:48.000
애니메이션은 이전에 물체를 움직이게 하기 위해 시작, 끝 및 기간을 지정할 수 있는 매우 선언적이었습니다.

00:10:48.000 --> 00:10:59.000
하지만 곡선 경로를 따르거나 오프셋으로 이동할 수 있을 때 페이지의 요소를 애니메이션화하는 것은 어려운 일이었다.

00:10:59.000 --> 00:11:07.000
그리고 당신이 그것을 클릭할 때 헤더에 대한 비밀 애니메이션을 추가하고 싶습니다, 정말 재미있을 것이라고 생각했습니다.

00:11:07.000 --> 00:11:13.000
새로운 오프셋 경로를 사용하면 개체가 애니메이션화할 경로를 정의할 수 있습니다.

00:11:13.000 --> 00:11:19.000
오프셋 경로로 경로를 설정하고 키프레임 효과를 위해 오프셋 거리를 사용하세요.

00:11:19.000 --> 00:11:30.000
그런 다음 애니메이션 속성을 사용하여 키프레임 효과를 적용하여 CSS에서 애니메이션으로 원하는 모든 컨트롤을 제공합니다.

00:11:30.000 --> 00:11:43.000
우리는 또한 일반적으로 브라우저 엔진 자체에 의해 정의된 웹의 부분에서도 페이지에 대한 더 많은 제어를 제공하고자 하며, 스크롤 행동은 이것의 첫 번째 예일 뿐입니다.

00:11:43.000 --> 00:11:51.000
웹이 시작된 이래로, 웹 페이지의 다른 부분으로 이동하는 링크를 클릭하면 시각적으로 점프로 나타납니다.

00:11:51.000 --> 00:11:54.000
때때로 이것은 당신의 사용자들에게 혼란을 잃습니다.

00:11:54.000 --> 00:12:01.000
CSS의 스크롤 행동 속성은 이 동작을 원하는지 여부를 지정할 수 있는 방법을 제공합니다.

00:12:01.000 --> 00:12:06.000
기본적으로, 그것은 자동으로 설정되어 있으며, 그 점프로 나타날 것이다.

00:12:06.000 --> 00:12:14.000
스크롤 동작을 부드럽게 지정하면, 브라우저에 대신 페이지의 다음 위치로 부드럽게 스크롤하도록 요청할 수 있습니다.

00:12:14.000 --> 00:12:21.000
자바스크립트 메소드 window.scroll(), scrollTo() 또는 scrollBy()로도 할 수 있습니다.

00:12:21.000 --> 00:12:37.000
당신은 고객을 가장 잘 알고 있으며 브라우저 엔진 기본값 밖에서 자신의 웹 페이지 경험을 정의할 수 있어야 하며, 이는 또한 :focus-visible과 악센트 색상을 사용할 수 있는 곳이기도 합니다.

00:12:37.000 --> 00:12:47.000
초점 표시기에 특정 스타일을 적용하고 싶다면 초점 선택기에 익숙할 것이며, 전반적인 디자인과 더 일치할 가능성이 높습니다.

00:12:47.000 --> 00:12:55.000
하지만 그렇게 할 때 브라우저 기반 휴리스틱을 잃는 몇 가지 접근성 함정이 있습니다.

00:12:55.000 --> 00:13:02.000
그리고 제 사이트에서는, 내장된 양식 색상 대신 사용자 지정 색상을 사용하고 싶습니다.

00:13:02.000 --> 00:13:09.000
포커스 하이라이트와 체크박스 모두에 이미 내 헤더에 있는 청록색을 사용합시다.

00:13:09.000 --> 00:13:21.000
:Focus-visible pseudo-class를 사용하면 브라우저에서 기본적으로 표시되는 경우에만 스타일화된 표시기를 표시하면서 포커스 표시기를 선택할 수 있습니다.

00:13:21.000 --> 00:13:30.000
그리고 양식에 또 다른 사용자 지정 레이어를 추가하려면, 악센트 색상을 사용하여 양식 제어 UI의 다른 부분의 색상을 변경할 수 있습니다.

00:13:30.000 --> 00:13:35.000
그것은 그 체크박스와 라디오 버튼 등에 영향을 미칠 것이다.

00:13:35.000 --> 00:13:42.000
또한 CSS와 함께, 우리는 점점 더 많은 WebKit 접두사를 대체하고 있습니다.

00:13:42.000 --> 00:13:55.000
이것들은 실험적인 기능을 시험해 볼 수 있는 완벽한 방법이었지만, 이제 우리는 CSS를 더 쉽게 작성하고 상호 운용할 수 있도록 표준 정의 속성으로 이동할 수 있습니다.

00:13:55.000 --> 00:14:04.000
하지만 걱정하지 마세요, WebKit 접두사가 있는 기존 CSS는 웹 표준으로 전환할 때 계속 작동할 것입니다.

00:14:04.000 --> 00:14:14.000
뒷면 가시성, 인쇄 색상 조정 및 텍스트 정렬: 일치 부모는 모두 접두사와 정확히 동일합니다.

00:14:14.000 --> 00:14:23.000
마스크와 text-combine-upright는 모두 표준과 일치하도록 접두사 버전에서 구문을 업데이트했습니다.

00:14:23.000 --> 00:14:38.000
그리고 접두사가 없는 외관 속성은 또한 새로운 자동 값에 대한 지원을 추가하지만, 표준 사양에 따라 caret 또는 listitem과 같은 Safari 16의 WebKit 특정 값을 제거했습니다.

00:14:38.000 --> 00:14:42.000
우리의 타이포그래피 추가에 대해서도 주목할 것이 많았다.

00:14:42.000 --> 00:14:50.000
특히, 우리는 컬러 글꼴 내에서 컬러 팔레트를 쉽게 선택할 수 있는 글꼴 팔레트 속성을 추가했습니다.

00:14:50.000 --> 00:14:55.000
내 사이트에 잠재적인 로고로 시도해 보는 것은 정말 멋질 것이라고 생각한다.

00:14:55.000 --> 00:15:08.000
우리는 내장된 어둡거나 밝은 팔레트로 어떻게 보이는지 또는 색상 오버라이드로 내가 원하는 것을 정확히 사용자 정의하고 거기에 노란색을 넣어 밝게 할 수 있는지 테스트할 수 있습니다.

00:15:08.000 --> 00:15:21.000
그리고 타이포그래피를 통해 텍스트 장식 건너뛰기 잉크가 추가되어 밑줄이나 오버라인이 문자나 문자와 교차할 때 어떤 일이 일어나는지 제어할 수 있습니다.

00:15:21.000 --> 00:15:28.000
게다가 ic 유닛은 CJK 문자를 블록 방향으로 정확하게 정렬할 수 있게 해준다.

00:15:28.000 --> 00:15:36.000
중국어, 일본어, 한국어와 같은 언어로 깨끗한 타이포그래피 그리드를 만드는 데 유용합니다.

00:15:36.000 --> 00:15:43.000
이 모든 훌륭한 CSS 기능에 대한 논의를 마무리하기 위해, 우리는 확실히 서브그리드에 대해 이야기해야 합니다.

00:15:43.000 --> 00:15:47.000
몇 년 동안, 웹의 레이아웃은 꽤 어려웠다.

00:15:47.000 --> 00:15:55.000
CSS 그리드는 혁명적이었지만, 그리드 컨테이너의 직접적인 자식에만 영향을 미친다.

00:15:55.000 --> 00:16:08.000
여기서, 저는 CSS 그리드를 사용하여 이 카드를 레이아웃하고, 미디어 쿼리 없이 열을 추가 및 제거하여 뷰포트 너비에 맞게 레이아웃을 자동으로 조정하고 있습니다.

00:16:08.000 --> 00:16:21.000
하지만 각 카드의 콘텐츠 크기는 동일하지 않습니다. 일부 헤드라인은 더 길고, 사진은 종횡비가 다르기 때문에 비주얼이 정말 지저분해 보입니다.

00:16:21.000 --> 00:16:35.000
모든 요청 항목 버튼과 메시지 상자가 페이지를 가로질러 정렬되고, 다른 카드의 레이아웃에 영향을 미치기 위해 한 카드의 더 긴 제목을 원하므로 모두 같은 간격을 얻을 수 있습니다.

00:16:35.000 --> 00:16:39.000
이제, 우리는 서브그리드를 사용하여 이것을 달성할 수 있다.

00:16:39.000 --> 00:16:49.000
나는 각 기사에 그리드를 넣었고, 단순히 "grid-template-rows: subgrid"라고 써서 그 모든 그리드를 부모의 그리드에 묶었다.

00:16:49.000 --> 00:17:01.000
내가 필요할 수 있는 모든 그리드를 켤 수 있는 웹 인스펙터의 그리드 인스펙터를 사용하여 각 의류 카드의 모든 콘텐츠가 어떻게 완벽하게 정렬되는지 볼 수 있습니다.

00:17:01.000 --> 00:17:06.000
웹 인스펙터를 사용하면 많은 CSS 작업이 더 쉬워집니다.

00:17:06.000 --> 00:17:14.000
사실, 웹 인스펙터에 몇 가지 놀라운 추가 사항이 있어서 시도해 볼 수 있어서 정말 신날 것 같아요.

00:17:14.000 --> 00:17:23.000
우선, 레이아웃은 무슨 일이 일어나고 있는지 볼 수 있을 때 쓰기가 더 쉬우며, 이것이 바로 웹 인스펙터를 매우 중요하게 만드는 것입니다.

00:17:23.000 --> 00:17:30.000
그리고 새로운 Flexbox Inspector를 사용하면 실제로 요소 간의 간격을 시각화할 수 있습니다.

00:17:30.000 --> 00:17:35.000
여기 내 웹사이트에서, 나는 이 아이콘들을 내 헤더에 추가하는 데 어려움을 겪고 있었다.

00:17:35.000 --> 00:17:51.000
요소를 검사하고 레이아웃 탭으로 이동하기만 하면 됩니다. 지금은 그리드에 관심이 없기 때문에 그 섹션을 축소하여 새로운 플렉스박스 인스펙터로 바로 갈 수 있습니다.

00:17:51.000 --> 00:17:57.000
한 번의 클릭으로 모든 뷰를 켤 수 있고 여전히 부드러운 성능을 발휘할 수 있습니다.

00:17:57.000 --> 00:18:09.000
그리고 모든 보기를 켜면, 해시 마크와 컨테이너 상자로 내 요소가 어떻게 배열되고 있는지, 그리고 빈 공간이 어떻게 보기를 차지하는지 명확하게 볼 수 있습니다.

00:18:09.000 --> 00:18:16.000
그래서 이제 저는 새로운 정렬 편집기를 사용할 수 있는 정렬을 올바르게 하고 있는지 확인하고 싶습니다.

00:18:16.000 --> 00:18:21.000
스타일 탭으로 이동하여 정렬 항목 옆에 있는 새 버튼을 찾을 수 있습니다.

00:18:21.000 --> 00:18:30.000
여기서, 나는 내 헤더에 가장 적합한 것을 찾기 위해 다양한 옵션을 전환할 수 있으며, justify-content에서도 똑같이 할 수 있다.

00:18:30.000 --> 00:18:39.000
다시 말하지만, 각 옵션을 전환한 다음 내가 옳다고 생각하는 것에 착륙한다.

00:18:39.000 --> 00:18:54.000
나는 또한 노란색 아이콘이 너무 작다고 생각하며, 이름에 "중간"이 있는 변수를 사용하고 있다고 믿는 빨간색 아이콘과 같은 크기로 만들고 싶지만, 전체 이름이 정말 기억나지 않는다.

00:18:54.000 --> 00:19:02.000
노란색 아이콘 중 하나를 검사하고 인스펙터에서 높이를 편집하여 크기를 변경할 수 있습니다.

00:19:02.000 --> 00:19:14.000
그리고, 우리의 새로운 CSS 퍼지 자동 완성 덕분에, 나는 계속해서 "중간"을 입력할 수 있고 "중간"이 이름의 끝에 있어도 내가 원하는 변수가 팝업된다.

00:19:14.000 --> 00:19:20.000
그리고 그 노란색 아이콘들은 확실히 더 이상 너무 작지 않다.

00:19:20.000 --> 00:19:29.000
그리고 다른 아이콘에 대한 다른 변수가 내가 검사하고 있는 요소에 사용되지 않을 때, 그들은 우리의 새로운 CSS 도구로 숨겨진다.

00:19:29.000 --> 00:19:34.000
하지만 걱정하지 마세요, 필요할 때 그것들을 드러낼 수 있는 버튼이 있습니다.

00:19:34.000 --> 00:19:44.000
그리고 아마도 올해 웹 인스펙터에게 가장 흥미롭게도, 우리는 사파리 웹 인스펙터의 개발자 도구 확장에 대한 지원을 발표하게 되어 기쁩니다.

00:19:44.000 --> 00:19:55.000
좋아하는 개발자 도구 확장 프로그램의 제작자는 이제 다른 브라우저에서 사용하는 것과 동일한 기본 API를 사용하여 Safari로 이식할 수 있습니다.

00:19:55.000 --> 00:20:12.000
웹 인스펙터를 확장하는 방법을 배우고, 새로운 API를 탐색하고, 직접 사용할 수 있도록 설정하는 데 관심이 있다면, 올해 WWDC에서 "Safari 웹 인스펙터 확장 만들기"를 시청하세요.

00:20:12.000 --> 00:20:22.000
이제 우리는 프론트엔드 기술의 새로운 것을 많이 다루었으니, 기어를 바꾸고 웹 API의 새로운 기능에 대해 알아봅시다.

00:20:22.000 --> 00:20:26.000
웹 푸시에 대한 지원을 발표하게 되어 매우 기쁩니다.

00:20:26.000 --> 00:20:31.000
macOS Ventura의 Safari 16에서 사용할 수 있습니다.

00:20:31.000 --> 00:20:35.000
그것은 내년에 iOS와 iPadOS에 출시될 것이다.

00:20:35.000 --> 00:20:41.000
웹 푸시를 사용하면 웹사이트나 웹 앱에서 사용자에게 원격으로 알림을 보낼 수 있습니다.

00:20:41.000 --> 00:20:46.000
이것은 완전히 상호 운용 가능한 표준 기반 구현이다.

00:20:46.000 --> 00:20:55.000
이미 웹 푸시를 구현했고 다른 브라우저에서 작동한다면, 수정 없이 사파리에서 작동해야 합니다.

00:20:55.000 --> 00:20:58.000
그리고 당신은 애플 개발자 계정도 필요하지 않습니다.

00:20:58.000 --> 00:21:06.000
자세한 내용을 보려면, WWDC22에서 "Meet Web Push for Safari"를 시청하세요.

00:21:06.000 --> 00:21:13.000
웹 푸시에 대해 흥분한다면, 새로운 웹 앱 매니페스트 개선에 대해서도 흥분할 것입니다.

00:21:13.000 --> 00:21:20.000
이제 사람들이 웹 앱을 매니페스트 파일의 홈 화면에 저장할 때 사용되는 아이콘을 정의할 수 있습니다.

00:21:20.000 --> 00:21:28.000
매니페스트의 아이콘이 우선하려면, HTML 헤드에 정의된 애플 터치 아이콘이 없는지 확인해야 합니다.

00:21:28.000 --> 00:21:44.000
iOS와 iPadOS에 하나의 아이콘을 전달하고 다른 모바일 플랫폼에 다른 아이콘을 전달하려면, apple-touch-icon을 사용하여 HTML 헤드에서 Apple 장치의 아이콘을 정의하여 그렇게 할 수 있습니다.

00:21:44.000 --> 00:21:52.000
그리고 어느 곳에서도 아이콘을 선언하지 않으면, 사용자가 사이트를 홈 화면에 저장하면 사이트의 스크린샷을 얻을 수 있습니다.

00:21:52.000 --> 00:22:11.000
흥미롭게도, 우리는 더 이상 사용자가 공유 메뉴에서 "홈 화면에 추가"를 선택하여 매니페스트 파일을 로드할 때까지 기다리지 않습니다. 즉, 매니페스트 파일을 사용하여 모든 사이트에서 웹 페이지의 특성을 정의하고 메타 태그를 사용할 필요성을 더욱 줄일 수 있습니다.

00:22:11.000 --> 00:22:20.000
API를 계속하면서, 우리는 같은 기원을 가진 여러 브라우징 컨텍스트에서 웹 페이지의 사용을 개선하기 위해 많은 일을 했습니다.

00:22:20.000 --> 00:22:25.000
방송 채널을 사용하면 서로 다른 브라우징 컨텍스트 간에 알림을 보낼 수 있습니다.

00:22:25.000 --> 00:22:32.000
누군가가 의류 교환 웹사이트를 사용하고 있고 동시에 두 개의 창문에서 열려 있다고 상상해 봅시다.

00:22:32.000 --> 00:22:35.000
그리고 나서 그들은 한 창문에 옷 한 조각을 요구한다.

00:22:35.000 --> 00:22:43.000
우리는 메시지를 게시하고 사용할 수 없는 상태를 다른 열린 탭이나 창에 동기화할 수 있습니다.

00:22:43.000 --> 00:22:49.000
하지만 백그라운드에서 탭을 업데이트하는 것이 아니라 사이트에 저장된 파일을 업데이트하는 것일 수도 있습니다.

00:22:49.000 --> 00:22:54.000
그것을 위해, 파일 시스템 액세스 API가 추가되었다.

00:22:54.000 --> 00:23:05.000
우리는 오리진을 기반으로 하는 개인 저장소인 오리진 개인 파일 시스템을 시작으로 올해 여러 릴리스에서 이 API에 대한 점진적인 업데이트를 했습니다.

00:23:05.000 --> 00:23:13.000
그래서 예를 들어, 내 의류 교환 사이트에는 파일을 읽는 apple.com과 같은 다른 사이트가 없을 것이다.

00:23:13.000 --> 00:23:29.000
그런 다음 우리가 방금 만든 초안 파일로 하는 것처럼 사이트의 루트 디렉토리에서 검색된 기존 파일을 읽는 FileSystemFileHandle의 getFile() 메소드로 API에 추가했습니다.

00:23:29.000 --> 00:23:37.000
이제 새로운 색상으로 올해 가장 생동감 넘치는 API 추가를 살펴봅시다.

00:23:37.000 --> 00:23:45.000
디스플레이 P3 색 공간은 RGB에 존재하지 않는 색상을 나타낼 수 있게 해준다.

00:23:45.000 --> 00:23:48.000
여기, 색상 선택기의 몇 가지 예가 있습니다.

00:23:48.000 --> 00:23:53.000
구불구불한 흰색 선의 왼쪽에는 RGB에 존재하는 색상이 있다.

00:23:53.000 --> 00:23:58.000
그리고 선 오른쪽에는 P3에서만 사용할 수 있는 색상이 있습니다.

00:23:58.000 --> 00:24:03.000
2016년에, 우리는 비디오와 사진에 대한 P3 지원을 추가했습니다.

00:24:03.000 --> 00:24:12.000
작년에, 우리는 CSS 색상 레벨 4에 정의된 새로운 색상 구문을 구현한 최초의 브라우저 엔진이 되어 매우 기뻤습니다.

00:24:12.000 --> 00:24:18.000
올해, 우리는 캔버스 요소 내부의 콘텐츠에 대한 P3 색상에 대한 지원을 추가했습니다.

00:24:18.000 --> 00:24:29.000
따라서, 오늘날의 모든 놀라운 장치의 풀 컬러 기능을 활용하기 시작할 수 있는 90년대부터 장치를 기반으로 한 색상을 사용할 필요가 없습니다.

00:24:29.000 --> 00:24:50.000
하지만 그림자 영역, 웹 잠금 및 ResizeObserverSize 인터페이스에 대한 ResizeObserver API에 대한 업데이트된 지원을 포함하여 지난 해의 새로운 웹 API로 확인할 수 있는 것이 훨씬 더 많습니다. 이는 요소의 상자 크기 속성에 대한 변경 사항을 관찰하는 데 도움이 될 것입니다.

00:24:50.000 --> 00:24:58.000
우리의 모든 새로운 API 추가 사항과 물론 우리의 모든 새로운 기능에서도 시도해 볼 것이 너무 많습니다.

00:24:58.000 --> 00:25:02.000
사실, 우리는 여전히 다루어야 할 것이 더 많다.

00:25:02.000 --> 00:25:08.000
이제 자바스크립트와 웹어셈블리의 새로운 모든 것에 대해 알아봅시다.

00:25:08.000 --> 00:25:20.000
만약 당신의 웹사이트가 작업자를 사용하고, 이러한 작업자의 인스턴스가 탭과 창에서 공유되기를 원한다면, 새로운 공유 작업자 인터페이스는 확실히 도움이 될 것이며 잠재적으로 메모리 사용량을 줄일 수 있습니다.

00:25:20.000 --> 00:25:31.000
백그라운드에서 발생하고 싶은 모든 작업에 대해 새로운 작업자를 생성하는 대신, 동일한 출처를 가진 각 브라우징 컨텍스트에 대해 한 명의 작업자만 사용할 수 있습니다.

00:25:31.000 --> 00:25:40.000
각 스크립트는 같은 방식으로 공유 작업자를 만든 다음, 동일한 포트를 사용하여 메시지를 수신하고 게시할 수 있습니다.

00:25:40.000 --> 00:25:47.000
공유 작업자는 모든 다른 스크립트에서 보낸 메시지를 받고 응답할 수 있을 것이다.

00:25:47.000 --> 00:25:56.000
이로 인해 서버에 대한 수요가 줄어들 뿐만 아니라 웹 페이지가 고객에게 빠르고 빠르게 반응할 수 있습니다.

00:25:56.000 --> 00:26:00.000
우리는 또한 당신에게 보여줄 일련의 배열 기능을 가지고 있습니다.

00:26:00.000 --> 00:26:17.000
끝에서 검색할 때 reverse()를 사용하여 배열을 변경해야 하는 대신, 이제 "shoestring"을 포함하는 마지막 항목에 대한 항목과 인덱스를 찾기 위해 여기서 한 것처럼 findLast() 및 findLastIndex() 메서드를 사용할 수 있습니다.

00:26:17.000 --> 00:26:22.000
새로운 at() 메서드는 또한 배열의 끝에서 더 쉽게 검색할 수 있게 해준다.

00:26:22.000 --> 00:26:35.000
중괄호를 사용하면 인덱스가 긍정적일 때 잘 작동하지만, at()를 사용하면 음수 값으로 인덱싱하는 추가 기능을 통해 코드를 더 간결하고 읽을 수 있습니다.

00:26:35.000 --> 00:26:46.000
하지만 그 많은 수의 새로운 배열 기능에도 불구하고, 우리가 당신을 위해 얻은 새로운 국제화 기능의 수를 능가할 수 있는 것은 없습니다.

00:26:46.000 --> 00:26:54.000
WebKit은 지난 한 해 동안 Intl 구현에 정기적인 업데이트를 계속 추가해 왔습니다.

00:26:54.000 --> 00:27:09.000
Locale 및 DisplayNames의 업데이트와 Intl Enumeration API의 통화 덕분에 NumberFormat, 캘린더의 새로운 방법으로 다양한 번호 매기기 시스템에 대한 지원이 추가되었습니다.

00:27:09.000 --> 00:27:24.000
그리고 제가 말했듯이, 올해 국제 구현에 추가된 많은 것들이 있습니다. 전 세계 사용자들을 수용하기 위해 시도하고 탐구할 것들이 부족하지 않을 것입니다.

00:27:24.000 --> 00:27:38.000
그리고 웹에 가져오고 싶은 C, Objective C 또는 Swift와 같은 모든 종류의 다른 코딩 언어의 기존 코드가 있는 모든 사람들을 위해, WebAssembly는 다시 쓸 필요 없이 실행할 수 있습니다.

00:27:38.000 --> 00:27:54.000
그리고 올해의 개선으로, WebAssembly를 사용하는 웹 앱은 주소 지정 가능한 메모리가 4GB로 확장되고 새로운 무비용 예외 처리와 함께 제공되는 성능 향상으로 더욱 강력해지고 있습니다.

00:27:54.000 --> 00:28:01.000
전반적으로, 자바스크립트와 웹어셈블리가 여기서 시도해 볼 수 있는 흥미로운 것들이 있습니다.

00:28:01.000 --> 00:28:16.000
그리고 웹어셈블리에 대해 말하자면, 우리는 또한 우리가 개발하는 웹 사용자를 보호할 뿐만 아니라 개발자로서 당신에게 새로운 잠재력을 가져다 줄 몇 가지 보안 및 개인 정보 보호 개선 사항을 가지고 있습니다.

00:28:16.000 --> 00:28:33.000
새로운 크로스 오리진 오프너 정책과 크로스 오리진 임베더 정책 HTTP 응답 헤더를 모두 사용하면 사이트가 프로세스 격리를 선택할 수 있습니다. 즉, 사이트가 자체 전용 웹 콘텐츠 프로세스에서 실행됩니다.

00:28:33.000 --> 00:28:46.000
우리는 많은 앱이 웹어셈블리 스레딩을 사용하여 여러 스레드에서 병렬로 실행함으로써 이익을 얻을 수 있다는 것을 알고 있으며, 이러한 새로운 헤더를 사용하면 안전하게 실행할 수 있습니다.

00:28:46.000 --> 00:28:55.000
우리의 두 번째 보안 향상은 또한 콘텐츠 보안 정책 레벨 3에 대한 향상된 지원과 함께 HTTP 헤더를 포함합니다.

00:28:55.000 --> 00:29:04.000
CSP는 로딩 콘텐츠에 대한 향상된 보안 제어를 제공하고 크로스 사이트 스크립팅 및 기타 취약점의 위험을 완화합니다.

00:29:04.000 --> 00:29:11.000
레벨 3 업데이트와 함께, 가장 흥미로운 추가는 새로운 엄격하고 역동적인 소스 표현이었다.

00:29:11.000 --> 00:29:21.000
엄격한 동적 디자이너들은 nonces를 사용하여 특정 스크립트를 허용한 다음, 이미 신뢰할 수 있는 스크립트가 로드한 스크립트로 신뢰를 확장할 수 있다는 것을 깨달았습니다.

00:29:21.000 --> 00:29:24.000
명시적인 허용 목록은 필요하지 않습니다.

00:29:24.000 --> 00:29:26.000
헤더가 얼마나 간단해지는지 보세요.

00:29:26.000 --> 00:29:32.000
잠재적으로 너무 많은 것을 허용할 수 있는 원래의 긴 도메인 목록에서 벗어나는 것.

00:29:32.000 --> 00:29:45.000
그리고 그것으로, 우리는 보안 및 개인 정보 보호 기능을 마무리하며, 이는 또한 우리가 오늘 다룰 모든 것을 끝내게 하지만, 당신이 스스로 탐구할 수 있는 더 많은 것이 있습니다.

00:29:45.000 --> 00:30:03.000
예를 들어, getUserDisplay() API, WebRTC Perfect Negotiation, 인밴드 챕터 트랙 및 requestVideoFrameCallback()을 사용하여 특정 사파리 창을 캡처하는 지원을 포함한 미디어 업데이트가 있었습니다.

00:30:03.000 --> 00:30:12.000
매니페스트 버전 3을 지원하는 웹 확장을 위한 많은 멋진 추가 사항과 많은 새로운 웹 확장 API.

00:30:12.000 --> 00:30:41.000
오늘 여기에서 다루는 이러한 모든 기능을 더 깊이 파고들고, 지난 한 해 동안 Safari와 WebKit에서 개발된 모든 162개의 기능과 개선 사항을 탐구하려면, Safari Technology Preview를 다운로드하여 미래에 일어날 일을 따라잡고, 릴리스 노트, 블로그 게시물 및 Web Inspector에 대한 광범위한 문서를 포함하여 webkit.org의 모든 훌륭한 콘텐츠를 확인하여 웹 기술을 탐색하십시오.

00:30:41.000 --> 00:30:47.000
그리고 항상 그렇듯이, 버그 보고서를 제출하여 당신이 생각하는 것과 다음에 보고 싶은 것을 알려주세요.

00:30:47.000 --> 00:31:03.000
HTML, CSS, JavaScript, DOM API 또는 Web Inspector와 같은 WebKit에서 버그가 발견되면 bugs.webkit.org에서 WebKit의 버그 추적 시스템을 통해 피드백을 보내십시오.

00:31:03.000 --> 00:31:11.000
그리고 사파리 인터페이스의 제안이나 버그의 경우, 애플의 피드백 어시스턴트의 파일 문제.

00:31:11.000 --> 00:31:24.000
우리는 내년에 출시될 모든 Safari 및 Safari Technology Preview 릴리스를 통해 당신과 같은 웹 개발자의 작업을 훨씬 더 좋게 만드는 놀라운 기능을 더 많이 제공하기를 기대합니다.

00:31:24.000 --> 00:31:30.000
오늘 저와 함께 해주셔서 감사드리며, WWDC에서 최고의 시간을 보내시길 바랍니다.

00:31:30.000 --> 00:31:32.000
이제 안녕!

00:31:32.000 --> 23:59:59.000
♪

