WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:13.000
아메드: 안녕하세요, 제 이름은 아메드이고, 저는 클랑과 스위프트 컴파일러에서 일합니다.

00:00:13.000 --> 00:00:25.000
이 세션에서 우리는 앱의 크기와 런타임 성능을 개선할 수 있도록 일반적인 Swift 및 Objective-C 작업을 더 빠르고 효율적으로 만들기 위해 만든 변경 사항에 대해 깊이 파고들 것입니다.

00:00:25.000 --> 00:00:30.000
Swift 또는 Objective-C로 코드를 작성할 때, 당신은 항상 두 가지 주요 구성 요소와 상호 작용하고 있습니다.

00:00:30.000 --> 00:00:35.000
먼저, Xcode를 사용하여 빌드하고, Swift와 Clang 컴파일러를 사용합니다.

00:00:35.000 --> 00:00:41.000
하지만 앱을 실행할 때, 많은 무거운 일이 Swift와 Objective-C 런타임에서 이루어집니다.

00:00:41.000 --> 00:00:45.000
런타임은 모든 플랫폼의 운영 체제에 내장되어 있습니다.

00:00:45.000 --> 00:00:50.000
컴파일러가 빌드 타임에 할 수 없는 것, 런타임은 런타임에 잘 한다.

00:00:50.000 --> 00:00:54.000
우리는 컴파일러와 런타임 모두에서 몇 가지 개선 사항을 살펴볼 것입니다.

00:00:54.000 --> 00:01:00.000
이제, 이 세션은 조금 특이합니다; 새로운 API, 언어 변경 또는 새로운 빌드 설정이 없습니다.

00:01:00.000 --> 00:01:05.000
코드를 변경할 필요가 없으므로, 이러한 모든 개선 사항은 개발자인 당신에게 투명합니다.

00:01:05.000 --> 00:01:06.000
뛰어들자.

00:01:06.000 --> 00:01:08.000
우리는 네 가지 개선 사항을 살펴볼 것이다.

00:01:08.000 --> 00:01:21.000
우리는 Swift에서 프로토콜 검사를 더 효율적으로 만들었고, 또한 Objective-C 메시지 전송 호출을 더 작게 만들었고, 마지막으로 자동 해제 제거를 더 빠르고 작게 만들었습니다.

00:01:21.000 --> 00:01:23.000
좀 더 자세히 살펴보자.

00:01:23.000 --> 00:01:27.000
스위프트에서 프로토콜 검사부터 시작합시다.

00:01:27.000 --> 00:01:30.000
여기 CustomLoggable 프로토콜이 있습니다.

00:01:30.000 --> 00:01:38.000
그것은 읽기 전용 계산 속성 customLogString을 가지고 있으며, CustomLoggable 객체에 대한 특별한 처리가 있는 로그 함수에서 사용할 수 있습니다.

00:01:38.000 --> 00:01:42.000
나중에, 우리는 이름과 날짜 필드가 있는 이벤트 유형을 정의하고 있습니다.

00:01:42.000 --> 00:01:49.000
그리고 우리는 customLogString 속성에 대한 게터를 정의함으로써 CustomLoggable 프로토콜을 준수하고 있습니다.

00:01:49.000 --> 00:01:53.000
그리고 이것은 우리가 이벤트 객체를 '로그' 함수에 전달할 수 있게 해준다.

00:01:53.000 --> 00:01:59.000
우리가 이 코드를 실행할 때, '로그' 함수는 우리가 전달한 값이 프로토콜을 준수하는지 확인해야 합니다.

00:01:59.000 --> 00:02:05.000
그리고 그것은 'as' 연산자를 사용하여 그것을 한다. 당신은 또한 'is' 운영자를 보았을 수도 있습니다.

00:02:05.000 --> 00:02:09.000
가능할 때마다, 이 검사는 컴파일러에서 빌드 시간에 최적화됩니다.

00:02:09.000 --> 00:02:13.000
하지만, 우리는 아직 충분한 정보를 가지고 있지는 않다.

00:02:13.000 --> 00:02:20.000
그래서 이것은 종종 우리가 이전에 계산한 프로토콜 확인 메타데이터의 도움으로 런타임에서 일어나야 한다.

00:02:20.000 --> 00:02:29.000
이 메타데이터를 사용하면, 런타임은 이 특정 객체가 실제로 프로토콜을 준수하는지 여부를 알고, 검사는 성공한다.

00:02:29.000 --> 00:02:36.000
메타데이터의 일부는 컴파일 시간에 구축되지만, 특히 제네릭을 사용할 때 많은 것은 출시 시간에만 구축될 수 있다.

00:02:36.000 --> 00:02:40.000
많은 프로토콜을 사용할 때, 이것은 수백 밀리초까지 추가될 수 있습니다.

00:02:40.000 --> 00:02:45.000
실제 앱에서, 우리는 이것이 출시 시간의 절반까지 걸리는 것을 보았다.

00:02:45.000 --> 00:02:54.000
새로운 스위프트 런타임으로, 우리는 이제 앱 실행 파일과 출시 시 사용하는 모든 딜리브에 대한 딜드 클로저의 일부로 이것들을 미리 미리 계산합니다.

00:02:54.000 --> 00:03:01.000
무엇보다도, 이것은 iOS 16, tvOS 16 또는 watchOS 9에서 실행할 때 기존 앱에서도 활성화됩니다.

00:03:01.000 --> 00:03:07.000
딜드와 출시 폐쇄에 대해 더 알고 싶다면, "앱 스타트업 시간: 과거, 현재, 미래"라는 강연을 보세요.

00:03:07.000 --> 00:03:10.000
그것은 스위프트의 프로토콜 검사였다.

00:03:10.000 --> 00:03:14.000
메시지 보내기로 넘어가자.

00:03:14.000 --> 00:03:22.000
Xcode 14의 새로운 컴파일러와 링커를 통해, 우리는 ARM64에서 12바이트에서 최대 8바이트 더 작은 메시지 전송 호출을 만들었습니다.

00:03:22.000 --> 00:03:30.000
잠시 후에 볼 수 있듯이, 메시지 전송은 정말 어디에나 있으므로, 이것은 더해지며, 우리는 바이너리에서 최대 2%의 코드 크기 개선을 보았습니다.

00:03:30.000 --> 00:03:38.000
이것은 이전 OS 릴리스를 배포 대상으로 사용하더라도 Xcode 14로 빌드할 때 자동으로 활성화됩니다.

00:03:38.000 --> 00:03:46.000
기본적으로 크기 승리와 성능의 균형이지만, objc_stubs_small 링커 플래그를 사용하여 크기만 최적화하도록 선택할 수 있습니다.

00:03:46.000 --> 00:03:49.000
이제 무엇이 바뀌었는지 살펴봅시다.

00:03:49.000 --> 00:03:50.000
그럼 예시부터 시작합시다.

00:03:50.000 --> 00:03:54.000
여기서 우리는 회의 시작일을 위한 NSDate를 만들려고 노력하고 있습니다.

00:03:54.000 --> 00:04:01.000
우리는 NSCalendar를 만드는 것으로 시작한 다음, NSDateComponents를 작성하고, 그것으로 날짜를 만들고, 마침내 그것을 반환합니다.

00:04:01.000 --> 00:04:05.000
이제 컴파일러가 생성하는 어셈블리를 살펴봅시다.

00:04:05.000 --> 00:04:07.000
이제, 조립의 세부 사항은 그다지 중요하지 않다.

00:04:07.000 --> 00:04:11.000
우리 컴파일러 사람들은 당신이 그럴 필요가 없도록 하루 종일 그것을 응시합니다.

00:04:11.000 --> 00:04:21.000
중요한 것은 여기에 있는 거의 모든 줄이 날짜 구성 요소에 대해 하는 것처럼 속성 액세스를 할 때에도 objc_msgSend를 호출하라는 명령이 필요하다는 것입니다.

00:04:21.000 --> 00:04:26.000
이것은 컴파일 타임에 어떤 메소드를 호출해야 할지 모르기 때문이며, objc 런타임만 호출할 뿐이다.

00:04:26.000 --> 00:04:32.000
그래서 우리는 objc_msgSend를 사용하여 런타임을 호출하여 올바른 방법을 찾도록 요청합니다.

00:04:32.000 --> 00:04:34.000
이 전화들 중 하나에 집중합시다.

00:04:34.000 --> 00:04:37.000
우리는 이미 objc_msgSend를 호출하라는 지시를 언급했다.

00:04:37.000 --> 00:04:38.000
하지만 더 있어.

00:04:38.000 --> 00:04:44.000
런타임에 어떤 메소드를 호출해야 하는지 알려주려면, 이 objc_msgSend 호출에 선택기를 전달해야 합니다.

00:04:44.000 --> 00:04:48.000
그것은 선택기를 준비하기 위해 몇 가지 지침이 더 필요하다.

00:04:48.000 --> 00:04:52.000
우리가 바이너리를 볼 때, 이 지침들 각각은 약간의 공간을 차지한다.

00:04:52.000 --> 00:04:55.000
ARM64에서, 그것은 각각 4바이트이다.

00:04:55.000 --> 00:05:04.000
그래서 이러한 각 objc_msgSend 호출에 대해, 우리는 12바이트를 사용하고 있으며, 이러한 모든 호출에 대해 필요합니다. 그것은 실제로 합산됩니다.

00:05:04.000 --> 00:05:08.000
그것을 개선하기 위해 우리가 무엇을 할 수 있는지 봅시다.

00:05:08.000 --> 00:05:13.000
이제, 우리가 전에 보았듯이, 그 중 8바이트는 선택기를 준비하는 데 전념하고 있다.

00:05:13.000 --> 00:05:17.000
흥미로운 점은, 주어진 선택기에 대해, 그것은 항상 같은 코드라는 것이다.

00:05:17.000 --> 00:05:21.000
그리고 이것이 우리의 최적화가 들어오는 곳이다.

00:05:21.000 --> 00:05:27.000
이것은 항상 같은 코드이기 때문에, 우리는 그것을 공유할 수 있으며 메시지를 보낼 때마다 대신 선택기당 한 번만 방출할 수 있습니다.

00:05:27.000 --> 00:05:33.000
우리는 그것을 꺼내서 작은 도우미 함수에 넣고, 대신 그 함수를 호출할 수 있다.

00:05:33.000 --> 00:05:38.000
동일한 선택기를 사용하는 많은 호출을 통해, 우리는 이 모든 명령 바이트를 저장할 수 있습니다.

00:05:38.000 --> 00:05:42.000
우리는 이 도우미 기능을 "선택자 스텁"이라고 부른다.

00:05:42.000 --> 00:05:47.000
하지만 우리는 여전히 실제 objc_msgSend 함수를 호출해야 하므로, 우리는 그것을 계속한다.

00:05:47.000 --> 00:05:53.000
그리고 다시, 그것은 함수 자체의 주소를 로드하고 호출하는 또 다른 간접적인 것을 가지고 있다.

00:05:53.000 --> 00:05:59.000
세부 사항은 중요하지 않지만, 중요한 것은 우리가 그것을 하기 위해 또 다른 몇 바이트의 코드가 필요하다는 것이다.

00:05:59.000 --> 00:06:03.000
그리고 이것은 내가 앞서 언급했듯이, 당신이 원하는 모드를 선택할 수 있는 곳이다.

00:06:03.000 --> 00:06:07.000
우리는 여기서 했던 것처럼 이 두 개의 작은 스텁 기능을 분리할 수 있다.

00:06:07.000 --> 00:06:11.000
우리는 가장 많은 코드를 공유하고, 이러한 기능을 가능한 한 작게 만들 수 있다.

00:06:11.000 --> 00:06:17.000
하지만 불행하게도, 이것은 공연에 이상적이지 않은 두 번의 전화를 연달아 할 것이다.

00:06:17.000 --> 00:06:20.000
그래서 우리는 대체 버전으로 이것을 더 개선할 수 있다.

00:06:20.000 --> 00:06:25.000
우리는 우리가 만든 이 두 가지 스텁 함수를 하나로 결합할 수 있습니다.

00:06:25.000 --> 00:06:29.000
그렇게 하면, 우리는 코드를 더 가깝게 유지하고 많은 전화가 필요하지 않습니다.

00:06:29.000 --> 00:06:32.000
그리고 그건 여기 오른쪽에 있어.

00:06:32.000 --> 00:06:33.000
그래서 이것들은 두 가지 옵션이다.

00:06:33.000 --> 00:06:38.000
크기만 최적화할지 여부를 선택할 수 있으며, 사용 가능한 최대 크기를 절약할 수 있습니다.

00:06:38.000 --> 00:06:48.000
-Objc_stubs_small 링커 플래그를 사용하여 활성화하거나, 최고의 성능을 유지하면서 크기 이점을 제공하는 코드 생성을 사용할 수 있습니다.

00:06:48.000 --> 00:06:54.000
그리고 당신이 크기에 심각한 제약을 받지 않는 한, 우리는 이것을 사용하는 것을 권장하며, 그것이 기본값인 이유입니다.

00:06:54.000 --> 00:06:57.000
그리고 그것은 스텁을 사용하여 보내는 더 작은 메시지였다.

00:06:57.000 --> 00:07:01.000
우리가 만든 또 다른 개선은 유지/해방을 더 저렴하게 만드는 것이다.

00:07:01.000 --> 00:07:08.000
Xcode 14의 새로운 컴파일러를 사용하면, 유지/릴리스 호출은 이제 ARM64의 8에서 최대 4바이트 더 작아집니다.

00:07:08.000 --> 00:07:13.000
잠시 후에 볼 수 있듯이, 메시지 전송과 마찬가지로, 유지/해제도 어디에나 있습니다.

00:07:13.000 --> 00:07:18.000
그래서 이것은 더해졌고, 우리는 바이너리에서 최대 2% 더 많은 코드 크기 개선을 보았다.

00:07:18.000 --> 00:07:28.000
이제 메시지 전송 스텁과 달리 런타임 지원이 필요하므로 iOS 16, tvOS 16 또는 watchOS 9의 배포 대상으로 마이그레이션할 때 자동으로 이를 받을 수 있습니다.

00:07:28.000 --> 00:07:31.000
이제 무엇이 바뀌었는지 살펴봅시다.

00:07:31.000 --> 00:07:32.000
우리의 예시로 돌아가자.

00:07:32.000 --> 00:07:42.000
우리는 msgSend 호출에 대해 이야기했지만, 자동 참조 계산 또는 ARC를 사용하면 컴파일러에 의해 삽입된 많은 유지/해제 호출로 끝납니다.

00:07:42.000 --> 00:07:49.000
매우 높은 수준에서, 우리가 물체에 대한 포인터의 복사본을 만들 때마다, 우리는 그것을 유지하기 위해 유지 수를 증가시켜야 한다.

00:07:49.000 --> 00:07:53.000
그리고 여기서, 이것은 우리의 변수 cal, dateComponent 및 theDate에서 발생합니다.

00:07:53.000 --> 00:07:57.000
우리는 objc_retain을 사용하여 런타임을 호출하여 그것을 한다.

00:07:57.000 --> 00:08:03.000
변수가 범위를 벗어나면, objc_release를 사용하여 보유 수를 감소시켜야 합니다.

00:08:03.000 --> 00:08:10.000
물론, ARC의 이점 중 일부는 이러한 호출을 최소한으로 유지하기 위해 이러한 많은 호출을 제거하는 모든 컴파일러 마법이다.

00:08:10.000 --> 00:08:13.000
그리고 우리는 조금 후에 이 마술 트릭 중 하나에 들어갈 것이다.

00:08:13.000 --> 00:08:17.000
하지만 모든 마법에도 불구하고, 우리는 여전히 종종 이러한 전화가 필요하다.

00:08:17.000 --> 00:08:24.000
이 예에서, 우리는 결국 달력과 dateComponents의 로컬 복사본을 공개해야 합니다.

00:08:24.000 --> 00:08:32.000
후드 아래에서, 이 objc_retain/release 함수는 단순한 C 함수일 뿐입니다; 하나의 인수, 해제될 객체를 가져가세요.

00:08:32.000 --> 00:08:38.000
따라서 ARC를 사용하면 컴파일러는 이러한 C 함수에 대한 호출을 삽입하여 적절한 객체 포인터를 전달합니다.

00:08:38.000 --> 00:08:46.000
그 때문에, 이러한 호출은 플랫폼 애플리케이션 바이너리 인터페이스 또는 ABI에 의해 정의된 C 호출 규칙을 존중해야 합니다.

00:08:46.000 --> 00:08:53.000
구체적으로, 그것이 의미하는 바는 우리가 이러한 호출을 하고, 올바른 레지스터에 포인터를 전달하기 위해 더 많은 코드가 필요하다는 것이다.

00:08:53.000 --> 00:08:57.000
그래서 우리는 그것을 위해 몇 가지 추가적인 '이동' 지침으로 끝난다.

00:08:57.000 --> 00:09:00.000
그리고 그것이 우리의 새로운 최적화가 들어오는 곳이다.

00:09:00.000 --> 00:09:11.000
사용자 지정 호출 규칙으로 유지/해제 전문화함으로써, 우리는 객체 포인터가 이미 어디에 있는지에 따라 기회적으로 올바른 변형을 사용할 수 있으므로 이동할 필요가 없습니다.

00:09:11.000 --> 00:09:17.000
구체적으로, 이것이 의미하는 바는, 우리는 이 모든 호출에 대해 많은 중복 코드를 제거한다는 것이다.

00:09:17.000 --> 00:09:23.000
그리고 다시 말하지만, 이것은 이 작은 지침에 대해 많은 것처럼 보이지 않을 수도 있지만, 전체 앱에 걸쳐, 그것은 정말로 추가된다.

00:09:23.000 --> 00:09:26.000
그것이 우리가 보유/해방 작업을 더 저렴하게 만든 방법이다.

00:09:26.000 --> 00:09:29.000
마지막으로, 자동 방출 제거에 대해 이야기해 봅시다.

00:09:29.000 --> 00:09:32.000
이제 이것은 훨씬 더 흥미롭다.

00:09:32.000 --> 00:09:36.000
Objc 런타임 변경으로, 우리는 자동 해제 제거를 더 빠르게 만들었습니다.

00:09:36.000 --> 00:09:41.000
그것은 새로운 OS 릴리스에서 실행할 때 기존 앱에 대해 자동으로 발생합니다.

00:09:41.000 --> 00:09:47.000
그 위에, 추가적인 컴파일러 변경과 함께, 우리는 또한 코드를 더 작게 만들었다.

00:09:47.000 --> 00:09:55.000
그리고 iOS 16, tvOS 16 또는 watchOS 9의 배포 대상으로 마이그레이션할 때 이 크기의 혜택을 자동으로 얻을 수 있습니다.

00:09:55.000 --> 00:09:59.000
이제 이것은 모두 훌륭하지만, 애초에 자동 방출 제거는 무엇입니까?

00:09:59.000 --> 00:10:02.000
우리의 예시로 돌아가자.

00:10:02.000 --> 00:10:07.000
나는 앞서 ARC가 이미 우리에게 유지와 출시를 최적화하기 위해 많은 컴파일러 마법을 제공한다고 언급했다.

00:10:07.000 --> 00:10:11.000
그래서 여기서 한 가지 사례에 집중합시다: 자동 해제된 반환 값.

00:10:11.000 --> 00:10:15.000
이 예에서, 우리는 임시 객체를 만들었고, 그것을 발신자에게 돌려주고 있다.

00:10:15.000 --> 00:10:17.000
그래서 그게 어떻게 작동하는지 보자.

00:10:17.000 --> 00:10:24.000
그래서 우리는 임시 theDate를 가지고 있고, 그것을 반환하고, 호출이 완료되고, 호출자는 그것을 자체 변수에 저장합니다.

00:10:24.000 --> 00:10:28.000
그래서 그것이 ARC와 어떻게 작동하는지 봅시다.

00:10:28.000 --> 00:10:32.000
ARC는 호출자에게 유지를 삽입하고, 호출된 함수에 해제를 삽입한다.

00:10:32.000 --> 00:10:39.000
여기서, 우리가 임시 객체를 반환할 때, 범위를 벗어나기 때문에 함수에서 먼저 해제해야 합니다.

00:10:39.000 --> 00:10:43.000
하지만 아직 다른 참고 문헌이 없기 때문에 우리는 아직 그것을 할 수 없다.

00:10:43.000 --> 00:10:48.000
만약 우리가 그것을 공개했다면, 그것은 우리가 돌아오기도 전에 파괴될 것이고, 그것은 좋지 않다.

00:10:48.000 --> 00:10:51.000
그래서 임시를 반환할 수 있도록 특별한 관습이 사용된다.

00:10:51.000 --> 00:10:56.000
우리는 발신자가 그것을 유지할 수 있도록 반환하기 전에 그것을 자동 해제합니다.

00:10:56.000 --> 00:11:02.000
당신은 전에 자동 릴리스와 자동 릴리스 풀을 본 적이 있을 것입니다: 그것은 단순히 나중 시점까지 출시를 연기하는 방법입니다.

00:11:02.000 --> 00:11:12.000
런타임은 출시가 언제 발생하는지에 대해 어떤 보장도 하지 않지만, 지금 당장 여기에 있지 않는 한, 이 임시 객체를 반환할 수 있기 때문에 편리합니다.

00:11:12.000 --> 00:11:13.000
이제, 이건 공짜가 아니야.

00:11:13.000 --> 00:11:16.000
자동 출시를 하는 데 약간의 오버헤드가 있다.

00:11:16.000 --> 00:11:19.000
여기가 자동 방출 생략이 들어오는 곳이다.

00:11:19.000 --> 00:11:24.000
그래서 그것이 어떻게 작동하는지 이해하기 위해, 조립을 살펴보고 이 수익을 되짚어봅시다.

00:11:24.000 --> 00:11:30.000
우리가 자동 릴리스를 부를 때, 그것은 objc 런타임으로 들어가고, 그것이 재미가 시작되는 곳이다.

00:11:30.000 --> 00:11:35.000
런타임은 무슨 일이 일어나고 있는지 인식하려고 한다: 우리는 자동 출시 값을 반환하고 있다.

00:11:35.000 --> 00:11:40.000
그것을 돕기 위해, 컴파일러는 우리가 절대 사용하지 않는 특별한 마커를 방출한다.

00:11:40.000 --> 00:11:45.000
그것은 런타임에 이것이 자동 방출 제거 자격이 있다는 것을 알리기 위해 거기에 있다.

00:11:45.000 --> 00:11:48.000
그리고 우리가 나중에 실행할 유지가 뒤따른다.

00:11:48.000 --> 00:11:59.000
하지만 지금, 우리는 여전히 자동 해제에 있으며, 우리가 그것을 할 때, 런타임은 특수 마커 명령을 데이터로 로드하고, 그것이 기대하는 특수 마커 값인지 확인하기 위해 비교합니다.

00:11:59.000 --> 00:12:05.000
만약 그렇다면, 그것은 컴파일러가 런타임에 우리가 즉시 유지될 임시를 반환하고 있다고 말했다는 것을 의미한다.

00:12:05.000 --> 00:12:09.000
그리고 이것은 우리가 일치하는 자동 해제를 제거하거나 제거하고 통화를 유지할 수 있게 해준다.

00:12:09.000 --> 00:12:12.000
그리고 그건 자동 방출 제거야.

00:12:12.000 --> 00:12:20.000
그러나, 이것도 무료가 아닙니다: 데이터로 코드를 로드하는 것은 매우 흔한 것이 아니므로, CPU에서 최적이 아닙니다.

00:12:20.000 --> 00:12:21.000
우리는 더 잘할 수 있어.

00:12:21.000 --> 00:12:26.000
그러니 이번에는 새로운 방법을 사용하여 반환 순서를 다시 추적해 봅시다.

00:12:26.000 --> 00:12:28.000
우리는 자동 출시에서 시작했다.

00:12:28.000 --> 00:12:30.000
그것은 여전히 Objective-C 런타임에 들어간다.

00:12:30.000 --> 00:12:35.000
이 시점에서, 우리는 실제로 이미 귀중한 정보를 가지고 있다: 반송 주소.

00:12:35.000 --> 00:12:41.000
이 기능이 실행을 완료한 후 어디로 돌아가야 하는지 알려줍니다.

00:12:41.000 --> 00:12:42.000
그래서 우리는 그것을 추적할 수 있다.

00:12:42.000 --> 00:12:45.000
고맙게도, 반송 주소를 얻는 것은 매우 저렴하다.

00:12:45.000 --> 00:12:48.000
그것은 단지 포인터일 뿐이고, 우리는 그것을 측면에 보관할 수 있다.

00:12:48.000 --> 00:12:51.000
그런 다음 런타임 자동 해제 호출을 남깁니다.

00:12:51.000 --> 00:12:56.000
우리는 발신자에게 돌아가서, 유지를 할 때 런타임에 다시 들어간다.

00:12:56.000 --> 00:12:59.000
그리고 여기가 새로운 마법이 일어나는 곳이다.

00:12:59.000 --> 00:13:04.000
그 시점에서, 우리는 우리가 어디에 있는지 보고 현재 반환 주소에 대한 포인터를 얻을 수 있다.

00:13:04.000 --> 00:13:12.000
런타임에, 우리는 유지를 하는 동안 방금 얻은 이 포인터를 우리가 자동 해제를 할 때 이전에 저장한 포인터와 비교할 수 있습니다.

00:13:12.000 --> 00:13:14.000
그리고 우리는 단지 두 개의 포인터를 비교하고 있기 때문에, 이것은 매우 저렴하다.

00:13:14.000 --> 00:13:17.000
우리는 값비싼 메모리 액세스를 할 필요가 없다.

00:13:17.000 --> 00:13:25.000
비교가 성공하면, 우리는 자동 해제/유지 쌍을 피할 수 있다는 것을 알고 있으며, 성능을 향상시킬 수 있습니다.

00:13:25.000 --> 00:13:32.000
게다가, 이제 우리는 이 특별한 마커 명령을 더 이상 데이터와 비교할 필요가 없기 때문에, 우리는 그것을 필요로 하지 않기 때문에, 우리는 그것을 제거할 수 있다.

00:13:32.000 --> 00:13:34.000
그리고 그것은 우리가 코드 크기도 저장할 수 있게 해준다.

00:13:34.000 --> 00:13:38.000
그것이 우리가 자동 방출 제거를 더 빠르고 작게 만든 방법이다.

00:13:38.000 --> 00:13:42.000
우리는 몇 가지 Swift와 Objective-C 런타임 개선을 거쳤다.

00:13:42.000 --> 00:13:43.000
마무리하자.

00:13:43.000 --> 00:13:50.000
앱이 새로운 OS에서 실행될 때, 런타임의 개선 덕분에 Swift 프로토콜 검사가 더 효율적입니다.

00:13:50.000 --> 00:13:55.000
우리가 자동 방출 제거를 하려고 할 때마다, 그것도 더 빠르다.

00:13:55.000 --> 00:14:02.000
Xcode 14의 새로운 컴파일러와 링커와 메시지 전송 스텁 덕분에 앱을 재구성하여 코드 크기를 최대 2%까지 절약할 수 있습니다.

00:14:02.000 --> 00:14:12.000
그리고 마지막으로, 배포 대상을 iOS 16, tvOS 16 또는 watchOS 9로 업데이트하면 유지/해제 통화를 줄임으로써 2%를 더 절약할 수 있습니다.

00:14:12.000 --> 00:14:16.000
더군다나, 더 작은 자동 방출 제거 시퀀스 덕분에.

00:14:16.000 --> 23:59:59.000
Swift와 Objective-C 런타임에 대한 깊은 다이빙을 즐겼기를 바라며, 시청해 주셔서 감사합니다.

