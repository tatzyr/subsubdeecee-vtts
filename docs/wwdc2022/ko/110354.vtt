WEBVTT

00:00:00.000 --> 00:00:03.000
♪ 부드러운 기악 힙합 음악 ♪

00:00:03.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:11.000
안녕, 난 안젤라야.

00:00:11.000 --> 00:00:13.000
그리고 난 베카야.

00:00:13.000 --> 00:00:15.000
스위프트의 새로운 기능에 오신 것을 환영합니다!

00:00:15.000 --> 00:00:21.000
우리는 오늘 Swift 5.7의 모든 훌륭한 새로운 기능에 대해 당신과 이야기하게 되어 정말 기쁩니다.

00:00:21.000 --> 00:00:28.000
오늘 우리가 이야기할 많은 것들은 개발자로서의 삶을 더 쉽게 만드는 스위프트의 목표를 보여줍니다.

00:00:28.000 --> 00:00:35.000
우리는 당신이 작업 흐름과 놀라운 개선 사항을 사용자 정의하는 데 도움이 되는 새로운 도구를 살펴볼 것입니다.

00:00:35.000 --> 00:00:43.000
그런 다음 우리는 스위프트의 최신 동시성 모델과 전체 스레드 안전을 포함한 스위프트 6으로 가는 길에 대해 이야기할 것입니다.

00:00:43.000 --> 00:00:54.000
그런 다음 더 깨끗하고 간단한 제네릭과 강력한 새로운 문자열 처리 기능을 포함하여 Swift를 더 쉽게 읽고 쓸 수 있는 몇 가지 언어 개선 사항을 안내해 드리겠습니다.

00:00:54.000 --> 00:01:02.000
하지만 먼저, 스위프트를 특별하게 만드는 것들 중 하나에 대해 이야기하는 것으로 시작합시다 - 여러분 모두.

00:01:02.000 --> 00:01:08.000
당신의 의견과 기여는 스위프트가 매우 빠르게 확장할 수 있게 해준 것입니다.

00:01:08.000 --> 00:01:11.000
지역 사회 참여는 스위프트의 핵심이다.

00:01:11.000 --> 00:01:23.000
올해, 작년에 발표된 문서 생성 도구인 docC와 Swift.org 웹사이트가 오픈 소스가 되었을 때 더 많은 스위프트 프로젝트를 커뮤니티에서 사용할 수 있게 되었다.

00:01:23.000 --> 00:01:28.000
오픈 소스는 활발한 커뮤니티가 있을 때 가장 잘 작동합니다.

00:01:28.000 --> 00:01:38.000
우리는 특정 분야에 관심이 있는 지역 사회 구성원들에게 청지기직과 지원을 제공하기 위해 서버의 스위프트와 다양성에 대한 작업 그룹 모델을 사용해 왔습니다.

00:01:38.000 --> 00:01:42.000
이것은 정말 잘 작동하고 있어서 우리는 두 개의 새로운 작업 그룹을 시작했다.

00:01:42.000 --> 00:01:54.000
하나는 스위프트 웹사이트에서 반복하고 커뮤니티 리소스로 만들고, 다른 하나는 C++ 상호 운용성을 위해 C++와 스위프트 사이의 모델 디자인을 형성하기 위한 것이다.

00:01:54.000 --> 00:02:00.000
우리가 새로운 분야로 모험할 때, 우리 모두는 지역 사회 내의 회원들의 지원이 필요하다.

00:02:00.000 --> 00:02:05.000
그 일환으로, 스위프트 워크그룹의 다양성은 작년에 스위프트 멘토링 프로그램을 도입했다.

00:02:05.000 --> 00:02:15.000
이 프로그램은 시작하는 방법을 모르거나 특정 분야에서 전문 지식을 심화시키려는 사람들을 위해 모든 작업 그룹 영역에 기여할 수 있는 경로를 제공합니다.

00:02:15.000 --> 00:02:18.000
작년의 프로그램은 큰 성공을 거두었다.

00:02:18.000 --> 00:02:25.000
많은 관심 있는 멘티들이 있었다; 그리고 그것으로, 우리는 41개의 멘토링 쌍을 만들 수 있었다.

00:02:25.000 --> 00:02:30.000
이 성공은 그 프로그램이 2년차에 돌아오는 이유이다.

00:02:30.000 --> 00:02:42.000
이 프로그램은 관심 있는 모든 사람들을 포함시키고 싶습니다. 하지만 그렇게 하려면, 우리는 당신이 필요합니다. 지금 듣고 있는 흥분되고 경험이 풍부한 개발자들은 그들의 광범위한 지식을 공유하고 새로운 관계를 맺을 준비가 되어 있습니다.

00:02:42.000 --> 00:02:49.000
왜냐하면 멘토링 프로그램은 단지 코드에 관한 것이 아니라 지역 사회 내에서 관계를 구축하는 것이기 때문이다.

00:02:49.000 --> 00:02:52.000
그리고 약간의 지침은 지속적인 영향을 미칠 수 있다.

00:02:52.000 --> 00:02:54.000
내 말을 믿지 마.

00:02:54.000 --> 00:03:00.000
작년에, Amrit는 멘토링 프로그램에 참여했고 컴파일러와 언어 디자인에 집중했다.

00:03:00.000 --> 00:03:06.000
암릿에 대한 음모로 시작된 것은 실질적인 기여로 바뀌었다.

00:03:06.000 --> 00:03:09.000
새로운 도메인에 뛰어드는 것은 쉽지 않다.

00:03:09.000 --> 00:03:14.000
그럼에도 불구하고, 그녀는 성공을 찾고 더 많은 기여를 하도록 영감을 받았다.

00:03:14.000 --> 00:03:19.000
다른 많은 사람들처럼, 이 경험은 Amrit에게 문을 열었다.

00:03:19.000 --> 00:03:30.000
컴파일러와 언어 디자인 외에도, 작년에는 기술 작성과 테스트에서 스위프트 패키지에 기여하는 것에 이르기까지 다양한 초점 영역이 있었다.

00:03:30.000 --> 00:03:36.000
올해, 우리는 더 많은 것을 추가하고 있으며 항상 새로운 주제에 대한 기회가 있습니다.

00:03:36.000 --> 00:03:42.000
이 목록에서 관심 있는 것이 보이지 않는다면, 여전히 지원서에서 언급할 수 있습니다.

00:03:42.000 --> 00:03:54.000
또 다른 추가 사항은 올해의 프로그램이 참여 능력이 낮을 수 있지만 여전히 참여하게 되어 흥분되는 사람을 수용할 수 있도록 스타터 버그 기여를 위해 일년 내내 멘토링을 제공할 것이라는 것입니다.

00:03:54.000 --> 00:04:00.000
지원에 관심이 있거나 더 듣고 싶다면, 가장 최근의 스위프트 블로그 게시물을 확인하세요.

00:04:00.000 --> 00:04:05.000
그곳에서, 당신은 강조된 멘티의 상세한 성찰에 대한 링크를 찾을 수 있습니다.

00:04:05.000 --> 00:04:10.000
멘토링 프로그램은 Swift의 다양성에 따른 하나의 이니셔티브일 뿐이다.

00:04:10.000 --> 00:04:17.000
멘토링 프로그램과 스위프트 노력의 다른 다양성에 대해 자세히 알아보려면, Swift.org/diversity를 방문하세요.

00:04:17.000 --> 00:04:24.000
문을 더 열기 위해, 우리는 당신이 가진 자원으로 스위프트를 가능한 한 쉽게 사용하고 싶습니다!

00:04:24.000 --> 00:04:32.000
우리는 리눅스 패키지 형식에 대한 지원을 추가하여 리눅스 플랫폼의 스위프트 툴체인 배포 프로세스를 간소화했습니다.

00:04:32.000 --> 00:04:40.000
새로운 네이티브 툴체인 설치 프로그램을 사용하면 이제 Swift.org에서 직접 Amazon Linux 2 및 CentOS 7용 RPM을 다운로드할 수 있습니다.

00:04:40.000 --> 00:04:45.000
이 툴체인은 실험적이므로, Swift.org 포럼에서 피드백을 공유하세요.

00:04:45.000 --> 00:04:48.000
스위프트는 주로 앱을 만드는 데 사용된다.

00:04:48.000 --> 00:04:57.000
그러나, 비전은 항상 스위프트가 확장 가능한 것이었다 - 높은 수준의 스크립트부터 베어메탈 환경에 이르기까지 모든 것에 사용되었다.

00:04:57.000 --> 00:05:04.000
스위프트가 이전에 사용된 적이 없는 곳에서 사용되도록 장려하기 위해, 스위프트는 올해 몇 가지 주요 변화를 겪었다.

00:05:04.000 --> 00:05:17.000
독립형 정적으로 연결된 바이너리를 위해 표준 라이브러리를 더 작게 만들기 위해, 우리는 외부 유니코드 지원 라이브러리에 대한 의존성을 줄여 더 빠른 네이티브 구현으로 대체했습니다.

00:05:17.000 --> 00:05:22.000
더 작고 빠른 바이너리는 이벤트 기반 서버 솔루션에서 실행할 때 큰 이점이다.

00:05:22.000 --> 00:05:28.000
서버에 대한 컨테이너화된 배포를 더 잘 지원하기 위해 기본적으로 리눅스에서 정적 링크를 얻을 수 있습니다.

00:05:28.000 --> 00:05:36.000
이 크기 축소로 인해 스위프트는 제한된 환경에도 적합하여 Apple의 Secure Enclave 프로세서에서 사용할 수 있었습니다.

00:05:36.000 --> 00:05:46.000
스위프트는 앱에서 서버, 제한된 프로세서에 이르기까지 유용하다; 모든 것을 하나로 묶는 것이 패키지 생태계이다.

00:05:46.000 --> 00:05:50.000
올해 스위프트 패키지의 새로운 기능은 당신의 삶을 더 좋게 만들 것입니다.

00:05:50.000 --> 00:05:55.000
우선, Swift Package Manager는 TOFU를 도입했다.

00:05:55.000 --> 00:05:58.000
아니, 맛있는 간식은 아니야.

00:05:58.000 --> 00:06:01.000
TOFU는 Trust On First Use의 약자이다.

00:06:01.000 --> 00:06:08.000
패키지가 처음 다운로드되었을 때 패키지의 지문이 기록되는 새로운 보안 프로토콜입니다.

00:06:08.000 --> 00:06:14.000
후속 다운로드는 이 지문을 검증하고 지문이 다른 경우 오류를 보고할 것입니다.

00:06:14.000 --> 00:06:23.000
이것은 당신이 그것을 사용하는 데 자신감을 가질 수 있도록 패키지 생태계의 핵심에 신뢰와 보안이 어떻게 내장되어 있는지에 대한 한 가지 예일 뿐입니다.

00:06:23.000 --> 00:06:28.000
명령 플러그인은 스위프트 개발자를 위한 워크플로우를 개선하는 좋은 방법입니다.

00:06:28.000 --> 00:06:32.000
그것들은 더 확장 가능하고 안전한 빌드 도구를 제공하는 첫 번째 단계이다.

00:06:32.000 --> 00:06:38.000
명령 플러그인은 문서 생성, 소스 코드 재포맷 등에 사용할 수 있습니다.

00:06:38.000 --> 00:06:44.000
셸 스크립트로 자동화를 작성하고 별도의 워크플로우를 유지해야 하는 대신, Swift를 사용할 수 있습니다!

00:06:44.000 --> 00:06:46.000
오픈 소스 포맷터와 린터를 생각해 보세요.

00:06:46.000 --> 00:06:53.000
이제, 이러한 모든 오픈 소스 도구는 Xcode와 Swift Package Manager에서 사용할 수 있습니다.

00:06:53.000 --> 00:06:58.000
명령 플러그인은 오픈 소스 도구와 스위프트 패키지 관리자 사이의 접착제이다.

00:06:58.000 --> 00:07:06.000
스위프트 프로젝트는 자동화된 워크플로우와의 원활한 통합을 제공하기 위해 오픈 소스 커뮤니티의 개발자 도구를 수용하고 있습니다.

00:07:06.000 --> 00:07:10.000
docC는 문서를 소스 코드에 통합하는 훌륭한 도구입니다.

00:07:10.000 --> 00:07:14.000
올해는 Objective-C와 C 지원으로 훨씬 더 좋아졌다.

00:07:14.000 --> 00:07:19.000
docC로 플러그인을 만드는 데 무엇이 필요할지 살펴봅시다.

00:07:19.000 --> 00:07:20.000
플러그인은 단순한 스위프트 코드일 뿐이다.

00:07:20.000 --> 00:07:25.000
CommandPlugin 프로토콜을 준수하는 구조자를 만들어 플러그인을 정의할 수 있습니다.

00:07:25.000 --> 00:07:30.000
그런 다음 플러그인에 어떤 도구를 호출하고 싶은지 알려주는 기능을 추가하기만 하면 됩니다.

00:07:30.000 --> 00:07:34.000
이 함수 내에서 우리가 docC를 호출하고 싶은 곳이다.

00:07:34.000 --> 00:07:40.000
플러그인을 정의하면, Swift PM 명령줄 인터페이스와 Xcode를 통해 메뉴 항목으로 사용할 수 있습니다.

00:07:40.000 --> 00:07:48.000
이제, 우리는 Swift PM에게 문서를 생성하라고 말할 수 있으며 이 작업을 docC 실행 파일에 전달하는 것을 알고 있습니다.

00:07:48.000 --> 00:07:50.000
그건 거기서 멈추지 않아.

00:07:50.000 --> 00:07:54.000
빌드 도구 플러그인으로 알려진 두 번째 플러그인이 있습니다.

00:07:54.000 --> 00:07:59.000
이 플러그인은 빌드 중에 추가 단계를 삽입할 수 있는 패키지입니다.

00:07:59.000 --> 00:08:05.000
빌드 도구 플러그인을 구현하면 빌드 시스템이 샌드박스에서 실행할 수 있는 명령을 생성합니다.

00:08:05.000 --> 00:08:13.000
그것들은 언제든지 직접 실행하는 명령 플러그인과 다르며 패키지의 파일을 변경할 수 있는 명시적인 권한을 부여받을 수 있습니다.

00:08:13.000 --> 00:08:20.000
빌드 도구 플러그인은 소스 코드 생성 또는 특수 유형의 파일에 대한 사용자 지정 처리에 사용할 수 있습니다.

00:08:20.000 --> 00:08:23.000
빌드 도구 플러그인을 사용하면, 이것은 패키지 레이아웃이 될 것이다.

00:08:23.000 --> 00:08:29.000
이 예에서, plugin.Swift는 패키지 플러그인 대상을 구현하는 Swift 스크립트입니다.

00:08:29.000 --> 00:08:33.000
플러그인은 스위프트 실행 파일로 취급된다.

00:08:33.000 --> 00:08:38.000
그리고 당신은 Swift 실행 파일을 작성하는 것과 같은 방식으로 플러그인을 작성합니다.

00:08:38.000 --> 00:08:48.000
빌드 시스템에 실행할 실행 명령과 결과적으로 예상되는 출력을 알려주는 빌드 명령 세트를 정의하여 플러그인을 구현할 수 있습니다.

00:08:48.000 --> 00:08:53.000
패키지 플러그인은 패키지의 확장성을 제공하는 안전한 솔루션입니다.

00:08:53.000 --> 00:09:03.000
"스위프트 패키지 플러그인 만나기"와 "스위프트 패키지 플러그인 만들기"라는 두 세션에서 플러그인 작동 방식과 자체 플러그인을 구현하는 방법에 대해 자세히 알아볼 수 있습니다.

00:09:03.000 --> 00:09:08.000
패키지 사용을 확장할 때, 모듈 충돌이 발생했을 수 있습니다.

00:09:08.000 --> 00:09:12.000
그것은 두 개의 개별 패키지가 같은 이름의 모듈을 정의할 때이다.

00:09:12.000 --> 00:09:19.000
이 상황을 해결하기 위해, 스위프트 5.7은 모듈 명확성을 도입한다.

00:09:19.000 --> 00:09:26.000
모듈 명확성은 모듈을 정의하는 패키지 외부에서 모듈의 이름을 바꿀 수 있는 기능입니다.

00:09:26.000 --> 00:09:33.000
여기 우리의 멋진 응용 프로그램에서, 우리는 로깅 모듈을 정의하는 두 개의 패키지를 가져오고 있으므로 충돌합니다.

00:09:33.000 --> 00:09:42.000
멋진 애플리케이션을 위해 이 문제를 해결하려면, 패키지 매니페스트의 종속성 섹션에 moduleAliases 키워드를 추가하기만 하면 됩니다.

00:09:42.000 --> 00:09:49.000
그렇게 하면 이전에 같은 이름을 가진 모듈을 구별하기 위해 두 개의 다른 이름을 사용할 수 있습니다.

00:09:49.000 --> 00:09:53.000
스위프트 5.7은 몇 가지 환상적인 성능 향상을 제공합니다.

00:09:53.000 --> 00:09:56.000
빌드 시간을 살펴보는 것으로 시작합시다.

00:09:56.000 --> 00:10:04.000
작년에, 우리는 스위프트에서 스위프트 소스 코드의 편집을 조정하는 프로그램인 스위프트 드라이버를 어떻게 다시 작성했는지에 대해 이야기했습니다.

00:10:04.000 --> 00:10:09.000
작년의 재건축은 빌드 속도를 크게 높이는 몇 가지 정말 중요한 변화를 잠금 해제했다.

00:10:09.000 --> 00:10:16.000
드라이버는 이제 별도의 실행 파일 대신 Xcode 빌드 시스템 내에서 직접 프레임워크로 사용할 수 있습니다.

00:10:16.000 --> 00:10:22.000
이것은 병렬화와 같은 것들을 허용하기 위해 빌드 시스템과 더 밀접하게 빌드를 조정할 수 있게 해준다.

00:10:22.000 --> 00:10:31.000
빠른 빌드의 사운드를 좋아하는 사람이라면, "Xcode 빌드에서 병렬화를 신비화" 세션에서 자세한 내용을 얻을 수 있습니다.

00:10:31.000 --> 00:10:39.000
빌드가 얼마나 빠른지 보여주기 위해, 스위프트로 작성된 우리가 자주 사용하는 도구 중 일부를 구축하는 데 얼마나 걸리는지에 대한 몇 가지 예를 살펴보겠습니다.

00:10:39.000 --> 00:10:46.000
10코어 아이맥에서, 개선은 5%에서 25%까지 다양했다.

00:10:46.000 --> 00:10:49.000
다음으로, 유형 검사의 속도에 대한 개선이 있다.

00:10:49.000 --> 00:11:00.000
올해, 우리는 프로토콜과 "어디" 절과 같은 것에서 함수 서명을 계산하는 부분인 제네릭 시스템의 핵심 부분을 다시 구현하여 유형 검사기 성능을 개선했습니다.

00:11:00.000 --> 00:11:07.000
이전 구현에서, 시간과 메모리 사용은 더 많은 프로토콜이 관련됨에 따라 기하급수적으로 확장될 수 있다.

00:11:07.000 --> 00:11:16.000
예를 들어, 여기서, 우리는 좌표계를 정의하는 복잡한 프로토콜 세트를 가지고 있으며, 많은 관련 유형에 대한 많은 일반적인 요구 사항이 있습니다.

00:11:16.000 --> 00:11:20.000
이전에는 이 코드를 입력하는 데 17초가 걸릴 것이다.

00:11:20.000 --> 00:11:28.000
하지만 이제, 스위프트 5.7에서, 이 예제는 1초 이내에 훨씬 더 빠르게 입력할 수 있다.

00:11:28.000 --> 00:11:32.000
우리는 또한 똑같이 인상적인 런타임 개선을 가지고 있다.

00:11:32.000 --> 00:11:39.000
스위프트 5.7 이전에, 우리는 iOS에서 앱 시작에 대한 프로토콜 검사가 4초 정도 걸리는 것을 보았습니다.

00:11:39.000 --> 00:11:46.000
우리가 앱을 출시할 때마다 프로토콜을 계산해야 했기 때문에, 더 많은 프로토콜을 추가할수록 출시 시간이 길어집니다.

00:11:46.000 --> 00:11:48.000
이제, 그들은 캐시되었다.

00:11:48.000 --> 00:11:58.000
앱이 작성된 방법과 얼마나 많은 프로토콜을 사용했는지에 따라, 이는 iOS 16에서 실행할 때 일부 앱에서 시작 시간이 절반으로 단축된다는 것을 의미할 수 있습니다.

00:11:58.000 --> 00:12:07.000
"앱 크기와 런타임 성능 개선" 세션은 자신의 애플리케이션에서 이러한 개선 사항을 어떻게 활용할 수 있는지에 대해 더 깊이 파고들 것입니다.

00:12:07.000 --> 00:12:12.000
이제, 여러분 중 많은 사람들이 듣고 싶어했던 무언가를 할 때입니다.

00:12:12.000 --> 00:12:19.000
작년에, 우리는 배우와 비동기/기다림을 한데 모으는 새로운 동시성 모델을 도입했습니다.

00:12:19.000 --> 00:12:25.000
이것은 당신의 애플리케이션의 동시성 아키텍처에 혁신적인 영향을 미쳤습니다.

00:12:25.000 --> 00:12:31.000
비동기/대기 및 액터들은 콜백과 수동 대기열 관리보다 안전하고 쉽다.

00:12:31.000 --> 00:12:37.000
올해, 우리는 데이터 경주 안전을 최전선에 두고 모델을 더욱 구체화했다.

00:12:37.000 --> 00:12:48.000
동시성은 앱의 코드베이스에 대한 근본적이고 중요한 개선이었기 때문에, 우리는 이러한 변경 사항을 iOS 13과 macOS Catalina로 되돌려 배포할 수 있었습니다.

00:12:48.000 --> 00:12:55.000
구형 운영 체제에 배포하기 위해, 앱은 구형 OS용 Swift 5.5 동시성 런타임 복사본을 번들로 제공합니다.

00:12:55.000 --> 00:13:01.000
이것은 ABI 안정성 이전에 운영 체제에 Swift를 다시 배포하는 것과 유사하다.

00:13:01.000 --> 00:13:05.000
다음으로, 우리는 이 모델을 새로운 방향으로 이끌었다.

00:13:05.000 --> 00:13:08.000
우리는 언어 기능과 지원 패키지를 도입했습니다.

00:13:08.000 --> 00:13:12.000
먼저, 데이터 경쟁 회피에 대해 이야기해 봅시다.

00:13:12.000 --> 00:13:20.000
내가 그것에 뛰어들기 전에, 나는 아마도 한 걸음 물러서서 스위프트의 정말 중요한 기능 중 하나는 기본적으로 메모리 안전이라고 말해야 할 것이다.

00:13:20.000 --> 00:13:27.000
스위프트 사용자는 수정하는 동안 값을 읽는 것과 같이 예측할 수 없는 행동으로 일을 할 수 없습니다.

00:13:27.000 --> 00:13:33.000
이 예에서, 우리는 같은 배열의 수와 일치하는 배열의 모든 숫자를 제거하고 있습니다.

00:13:33.000 --> 00:13:38.000
처음에, 배열의 수는 3이므로, 우리는 배열에서 3을 제거할 것이다.

00:13:38.000 --> 00:13:41.000
하지만 일단 우리가 그걸 하면, 카운트는 2가 될 거야.

00:13:41.000 --> 00:13:46.000
배열에서 3과 2를 제거할까요, 아니면 3만 제거할까요?

00:13:46.000 --> 00:13:48.000
답은 둘 다 아니야.

00:13:48.000 --> 00:13:55.000
스위프트는 당신이 그것을 수정하는 동안 배열의 수에 접근하는 것이 안전하지 않기 때문에 당신이 이것을 하는 것을 막을 것입니다.

00:13:55.000 --> 00:13:58.000
우리의 목표는 실 안전을 위해 비슷한 일을 하는 것이다.

00:13:58.000 --> 00:14:03.000
우리는 기본적으로 낮은 수준의 데이터 경쟁을 제거하는 언어를 구상한다.

00:14:03.000 --> 00:14:09.000
즉, 우리는 예측할 수 없는 행동을 일으킬 수 있는 동시성 버그를 방지하고 싶습니다.

00:14:09.000 --> 00:14:10.000
여기 또 다른 예가 있습니다.

00:14:10.000 --> 00:14:20.000
같은 숫자의 배열을 사용하여 배열에 0을 추가하는 백그라운드 작업을 만든 다음 배열의 마지막 요소를 제거합니다.

00:14:20.000 --> 00:14:26.000
하지만 잠깐만요, 마지막 요소를 제거하는 것은 0을 추가하기 전이나 후에 발생하나요?

00:14:26.000 --> 00:14:29.000
다시 말하지만, 답은 둘 다 아니다.

00:14:29.000 --> 00:14:38.000
스위프트는 액터와 같은 것과 같은 것과 액세스를 동기화하지 않고 백그라운드 작업에서 배열을 수정하는 것이 안전하지 않기 때문에 이것을 하는 것을 차단할 것입니다.

00:14:38.000 --> 00:14:42.000
배우들은 데이터 경쟁을 없애기 위한 첫 번째 주요 단계였다.

00:14:42.000 --> 00:14:49.000
올해 우리는 최종 목표를 향해 더 나아가기 위해 동시성 모델을 개선했습니다.

00:14:49.000 --> 00:14:56.000
당신은 각 배우를 동시성의 바다에서 다른 모든 것과 고립된 자신의 섬으로 생각할 수 있습니다.

00:14:56.000 --> 00:15:03.000
하지만 다른 스레드가 각 고립된 행위자에 의해 저장된 정보를 쿼리하고 싶을 때 어떻게 되나요?

00:15:03.000 --> 00:15:10.000
이 은유는 "스위프트 동시성을 사용하여 데이터 경쟁을 제거" 세션에서 깊이 탐구될 것이다.

00:15:10.000 --> 00:15:16.000
기본적으로 메모리 안전에서 스레드 안전까지; 그것이 스위프트 6의 목표이다.

00:15:16.000 --> 00:15:23.000
우리가 거기에 도착하기 위해, 우리는 먼저 내가 방금 언급한 새로운 언어 기능으로 작년의 동시성 모델을 개선했다.

00:15:23.000 --> 00:15:30.000
내가 아직 언급하지 않은 두 번째 것은 잠재적인 데이터 경쟁을 식별하는 새로운 옵트인 안전 점검이다.

00:15:30.000 --> 00:15:36.000
빌드 설정에서 활성화하여 더 엄격한 동시성 검사를 실험할 수 있습니다.

00:15:36.000 --> 00:15:38.000
배우들을 다시 한 번 보자.

00:15:38.000 --> 00:15:44.000
우리는 배우의 고립이라는 개념을 받아들일 수 있고, 분산된 배우들과 함께 더 나아갈 수 있다.

00:15:44.000 --> 00:15:49.000
분산된 배우들은 그 섬들을 그들 사이에 네트워크가 있는 다른 기계에 놓았다.

00:15:49.000 --> 00:15:54.000
이 새로운 언어 기능은 분산 시스템 개발을 훨씬 간단하게 만든다.

00:15:54.000 --> 00:15:59.000
게임 앱을 만들고 싶다고 가정해 봅시다. 이제 스위프트에서 백엔드를 쉽게 작성할 수 있습니다.

00:15:59.000 --> 00:16:04.000
여기서, 분산된 배우는 배우와 같지만 다른 기계에 있을 수도 있다.

00:16:04.000 --> 00:16:11.000
이 예에서, 우리는 사용자와 함께 게임하는 동안 상태를 유지할 컴퓨터 플레이어를 보고 있습니다.

00:16:11.000 --> 00:16:19.000
분산 키워드는 또한 원격 기계에 있을 수 있는 액터에서 호출되어야 할 것으로 예상되는 함수에 추가될 수 있습니다.

00:16:19.000 --> 00:16:22.000
endOfRound라는 또 다른 함수를 추가해 봅시다.

00:16:22.000 --> 00:16:26.000
그것은 플레이어들을 반복하고 각각에 대해 makeMove를 호출할 것이다.

00:16:26.000 --> 00:16:33.000
이 선수들 중 일부는 지역적이거나 멀리 떨어져 있을 수 있지만, 우리는 어느 것이 어느 것인지 신경 쓸 필요가 없다는 이점이 있다.

00:16:33.000 --> 00:16:40.000
일반 액터 호출과의 유일한 차이점은 네트워크 오류로 인해 분산 액터 호출이 잠재적으로 실패할 수 있다는 것이다.

00:16:40.000 --> 00:16:44.000
네트워크 장애가 발생할 경우, 액터 방법은 오류를 발생시킬 것이다.

00:16:44.000 --> 00:16:52.000
따라서, 배우 외부의 함수를 호출할 때 필요한 일반적인 대기 키워드뿐만 아니라 try 키워드를 추가해야 합니다.

00:16:52.000 --> 00:17:02.000
이러한 핵심 언어 프리미티브를 기반으로, 우리는 또한 스위프트에서 서버 측의 클러스터형 분산 시스템을 구축하는 데 중점을 둔 오픈 소스 분산 액터 패키지를 구축했습니다.

00:17:02.000 --> 00:17:11.000
이 패키지에는 SwiftNIO를 사용하는 통합 네트워킹 계층이 포함되어 있으며 클러스터 전체의 상태를 관리하기 위해 SWIM 합의 프로토콜을 구현합니다.

00:17:11.000 --> 00:17:19.000
"스위프트에서 분산된 배우를 만나다" 세션은 이러한 새로운 기능으로 분산 시스템을 구축하는 방법에 대해 더 자세히 설명할 것이다.

00:17:19.000 --> 00:17:32.000
우리는 또한 Swift 5.5와 함께 출시된 AsyncSequence를 다룰 때 일반적인 작업에 쉽게 사용할 수 있는 솔루션을 제공하기 위해 새로운 오픈 소스 알고리즘 세트를 출시했습니다.

00:17:32.000 --> 00:17:40.000
이러한 API를 패키지로 출시하면 개발자가 플랫폼과 운영 체제 버전에 유연하게 배포할 수 있습니다.

00:17:40.000 --> 00:17:47.000
여러 비동기 시퀀스를 결합하고 값을 컬렉션으로 그룹화하는 방법에는 여러 가지가 있습니다.

00:17:47.000 --> 00:17:51.000
이것들은 패키지에 포함된 알고리즘 중 일부일 뿐입니다.

00:17:51.000 --> 00:17:58.000
이 새로운 강력한 API를 어떻게 사용할 수 있는지 보려면 "Meet Swift Async Algorithms"를 확인하세요.

00:17:58.000 --> 00:18:02.000
하지만 동시성의 또 다른 측면이 있는데, 그것은 성과이다.

00:18:02.000 --> 00:18:08.000
올해, 배우의 우선순위와 함께, 배우들은 이제 가장 우선순위가 높은 작업을 먼저 수행한다.

00:18:08.000 --> 00:18:20.000
그리고 운영 체제 스케줄러와의 깊은 통합을 계속하면서, 이 모델에는 우선 순위 반전 방지가 내장되어 있으므로 덜 중요한 작업은 우선 순위가 높은 작업을 차단할 수 없습니다.

00:18:20.000 --> 00:18:26.000
역사적으로, 앱에서 동시성의 성능 영향을 시각화하는 것은 정말 어려웠습니다.

00:18:26.000 --> 00:18:31.000
하지만 이제, 우리는 정확히 그것을 할 수 있는 훌륭한 새로운 도구를 가지고 있다.

00:18:31.000 --> 00:18:36.000
Instruments의 새로운 Swift Concurrency 보기는 성능 문제를 조사하는 데 도움이 될 수 있습니다.

00:18:36.000 --> 00:18:46.000
Swift Tasks와 Swift Actors 악기는 동시성 코드를 시각화하고 최적화하는 데 도움이 되는 전체 도구 모음을 제공합니다.

00:18:46.000 --> 00:18:58.000
최상위 수준에서, Swift Tasks Instrument는 동시에 실행되는 작업의 수와 그 시점까지 생성된 총 작업을 포함하여 유용한 통계를 제공합니다.

00:18:58.000 --> 00:19:03.000
이 창의 아래쪽 절반에서, 당신은 작업 숲이라고 불리는 것을 볼 수 있습니다.

00:19:03.000 --> 00:19:11.000
그것은 구조화된 동시 코드에서 작업 간의 부모-자식 관계에 대한 그래픽 표현을 제공한다.

00:19:11.000 --> 00:19:16.000
이것은 스위프트 액터 악기의 상세한 견해 중 하나일 뿐이다.

00:19:16.000 --> 00:19:24.000
이 흥미진진한 새로운 도구를 사용하는 방법을 배우려면, "스위프트 동시성 시각화 및 최적화"에 대한 이야기로 넘어가야 합니다.

00:19:24.000 --> 00:19:26.000
그리고 그 새로운 패키지를 시도해 보는 것을 잊지 마세요.

00:19:26.000 --> 00:19:29.000
포럼에서 어떻게 진행되고 있는지 알려주는 것을 부끄러워하지 마세요.

00:19:29.000 --> 00:19:36.000
이제, 나는 스위프트 언어 유용성에 대한 많은 개선 사항에 대해 이야기하기 위해 그것을 베카에게 넘길 것이다.

00:19:36.000 --> 00:19:42.000
언어는 도구이며, 도구에는 재미있는 점이 있습니다. 그것들은 당신이 그것들로 만드는 것에 정말로 영향을 미칠 수 있습니다.

00:19:42.000 --> 00:19:48.000
당신이 가진 모든 것이 망치일 때, 당신은 나사 대신 못으로 물건을 만들 것입니다.

00:19:48.000 --> 00:19:58.000
그리고 전체 도구 세트가 있더라도, 스크루드라이버가 플라스틱이고 잡기 어려운 동안 망치가 크고 꽉 끼는 손잡이를 가지고 있다면, 당신은 여전히 못을 향해 기울어질 수 있습니다.

00:19:58.000 --> 00:19:59.000
언어는 같은 방식이다.

00:19:59.000 --> 00:20:05.000
스위프트가 무언가를 표현하기 위한 좋은 도구를 가지고 있다면, 사람들은 그것을 더 자주 사용할 것이다.

00:20:05.000 --> 00:20:11.000
그리고 올해, 코드가 원하는 것을 표현하기 위한 스위프트의 도구는 여러 면에서 개선되었습니다.

00:20:11.000 --> 00:20:15.000
이러한 변화 중 일부는 당신이 자주 하는 일에 대한 간단한 편의입니다.

00:20:15.000 --> 00:20:22.000
예를 들어, 스위프트에서는 등호의 양쪽에 같은 이름으로 사용하는 것이 정말 일반적이다.

00:20:22.000 --> 00:20:28.000
결국, 당신이 선택적으로 준 이름보다 포장되지 않은 값에 더 좋은 이름은 없을 것입니다.

00:20:28.000 --> 00:20:33.000
하지만 이름이 정말 길면, 그 반복은 번거로워지기 시작한다.

00:20:33.000 --> 00:20:39.000
당신은 그 이름을 축약하고 싶은 유혹을 받을 수도 있지만, 그러면 당신의 코드는 일종의 비밀스러워집니다.

00:20:39.000 --> 00:20:45.000
그리고 나중에 선택적 변수의 이름을 바꾸면, 약어가 동기화되지 않을 수 있습니다.

00:20:45.000 --> 00:20:49.000
스위프트 5.7은 이 일반적인 패턴에 대한 새로운 속기를 소개합니다.

00:20:49.000 --> 00:20:55.000
옵션을 풀고 포장되지 않은 값이 같은 이름을 갖길 원한다면, 오른쪽을 놓기만 하면 됩니다.

00:20:55.000 --> 00:20:58.000
스위프트는 그것이 똑같다고 가정할 것이다.

00:20:58.000 --> 00:21:04.000
그리고 물론, 이것은 경비원과도 함께, 그리고 심지어 그 문제에 대해서도 작동한다.

00:21:04.000 --> 00:21:09.000
우리는 또한 당신이 사소한 변화를 만들 때 기능이 갑자기 작동을 멈추는 곳을 살펴보았습니다.

00:21:09.000 --> 00:21:16.000
예를 들어, 스위프트는 항상 하나의 문 닫힘 안에 쓰여진 코드를 기반으로 호출이 어떤 유형을 반환할지 알아낼 수 있었다.

00:21:16.000 --> 00:21:30.000
이 compactMap 호출에서 클로저는 parseLine의 값을 반환하고 parseLine 함수는 MailmapEntry를 반환하므로 Swift는 항목이 MailmapEntry의 배열이어야 한다는 것을 알아낼 수 있습니다.

00:21:30.000 --> 00:21:35.000
이것은 이제 여러 문이나 제어 흐름 기능이 있는 더 복잡한 폐쇄에 적합합니다.

00:21:35.000 --> 00:21:43.000
따라서 폐쇄의 결과 유형을 수동으로 지정하지 않고도 do-catch를 사용하거나... 그렇지 않으면 인쇄 호출을 추가할 수 있습니다.

00:21:43.000 --> 00:21:49.000
우리가 살펴본 또 다른 것은 실제 위험을 표시하지 않는 위험 깃발이다.

00:21:49.000 --> 00:21:52.000
스위프트는 유형과 메모리 안전에 매우 관심이 있다.

00:21:52.000 --> 00:22:01.000
실수를 막기 위해, 그것은 다른 포인터 유형을 가진 포인터 사이, 또는 원시 포인터와 입력된 포인터 사이를 자동으로 변환하지 않습니다.

00:22:01.000 --> 00:22:05.000
이것은 특정 전환을 허용하는 C와 매우 다르다.

00:22:05.000 --> 00:22:15.000
예를 들어, C의 포인터 규칙을 위반하지 않고 포인터의 서명을 변경하거나 포인터를 char star로 전환하여 바이트로 액세스할 수 있습니다.

00:22:15.000 --> 00:22:22.000
하지만 때때로 포인터 동작의 이러한 차이는 C API를 Swift로 가져올 때 문제를 일으킬 것이다.

00:22:22.000 --> 00:22:30.000
원래 개발자는 C의 자동 변환으로 처리되지만 Swift의 오류인 약간의 불일치로 API를 설계했을 수 있습니다.

00:22:30.000 --> 00:22:39.000
스위프트에서, 마치 다른 유형인 것처럼 한 유형의 포인터에 접근하는 것은 매우 위험하므로, 당신이 하고 있는 일을 매우 명시적으로 설명해야 합니다.

00:22:39.000 --> 00:22:47.000
하지만 우리가 포인터를 C에게 직접 전달한다면 그것은 모두 무의미합니다. 왜냐하면 C에서 그 포인터 불일치는 완벽하게 합법적이기 때문입니다!

00:22:47.000 --> 00:22:52.000
그래서 이 경우, 우리는 정말 간단한 것을 마치 위험한 것처럼 취급했다.

00:22:52.000 --> 00:23:00.000
이것은 스위프트가 유형 안전을 중시하는 만큼, C-패밀리 코드에 대한 쉬운 접근도 중요하기 때문에 중요하다.

00:23:00.000 --> 00:23:11.000
그것이 C와 Objective-C 상호 작용이 매우 풍부하고 원활한 이유이며, 스위프트 프로젝트가 앞서 언급한 C++ 작업 그룹을 형성한 이유입니다. 안젤라는 동등하게 유능한 C++ 상호 작용 구축을 시작했습니다.

00:23:11.000 --> 00:23:16.000
우리는 이와 같은 C 기능을 불필요하게 고통스럽게 사용하는 것을 원하지 않는다.

00:23:16.000 --> 00:23:21.000
그래서 스위프트는 이제 가져온 함수와 메소드 호출에 대한 별도의 규칙 세트를 가지고 있다.

00:23:21.000 --> 00:23:26.000
일반적으로 스위프트에 있지 않더라도 C로 합법적인 포인터 변환을 허용합니다.

00:23:26.000 --> 00:23:31.000
그렇게 하면, 당신의 스위프트 코드는 이러한 API를 원활하게 사용할 수 있습니다.

00:23:31.000 --> 00:23:35.000
지금까지 우리는 당신이 이미 가지고 있던 도구에 대한 작은 개선에 대해 이야기했습니다.

00:23:35.000 --> 00:23:41.000
하지만 올해, 스위프트는 또한 문자열에서 정보를 추출하기 위한 새로운 도구를 가지고 있다.

00:23:41.000 --> 00:23:45.000
여기 문자열에서 일부 정보를 구문 분석하는 함수가 있습니다.

00:23:45.000 --> 00:23:48.000
이런 종류의 작업은 항상 스위프트에서 약간의 도전이었다.

00:23:48.000 --> 00:23:54.000
당신은 결국 당신이 원하는 것을 얻을 때까지 계속해서 검색하고, 나누고, 슬라이스하게 됩니다.

00:23:54.000 --> 00:24:03.000
사람들이 이것을 알아차릴 때, 그들은 문자열 인덱스를 조작하는 것이 얼마나 장황할 수 있는지와 같은 작은 것들에 집중하는 경향이 있지만, 나는 그것이 더 큰 그림을 놓치고 있다고 생각한다.

00:24:03.000 --> 00:24:15.000
왜냐하면 우리가 이 구문을 변경하더라도, 이 코드를 볼 때 묻는 기본적인 질문에 대답하는 데 도움이 되지 않기 때문입니다. 그 안에 전달된 줄 변수는 실제로 어떻게 생겼나요?

00:24:15.000 --> 00:24:18.000
어떤 종류의 끈을 분해하려고 하나요?

00:24:18.000 --> 00:24:29.000
충분히 오래 응시하면, 이전 커밋에서 개발자의 이름을 수정하기 위해 git 저장소에 넣은 파일인 메일맵의 단순화된 버전을 구문 분석하고 있다는 것을 알 수 있습니다.

00:24:29.000 --> 00:24:35.000
하지만 검색과 슬라이스로 그 정보를 추출하는 것은 너무 복잡해서 그것을 알아내기가 어렵다.

00:24:35.000 --> 00:24:42.000
당신은 끈을 자르는 방법에 너무 빠져서 그 끈이 무엇인지 잊어버려.

00:24:42.000 --> 00:24:48.000
문제는 이 두 표현이 아니다; 문제는 모든 것이다.

00:24:48.000 --> 00:24:52.000
우리는 이 모든 것을 뜯어내고 더 나은 것으로 교체해야 한다.

00:24:52.000 --> 00:25:01.000
우리는 다른 접근 방식이 필요합니다; 당신의 코드가 당신이 일치시키고 싶은 문자열의 그림을 그리고 언어가 그것을 하는 방법을 알아내는 것입니다.

00:25:01.000 --> 00:25:05.000
필수적인 접근 방식이 아니라 선언적인 접근 방식.

00:25:05.000 --> 00:25:10.000
스위프트 5.7에서, 당신은 이제 정규식을 작성하여 그것을 할 수 있습니다.

00:25:10.000 --> 00:25:14.000
정규 표현식은 문자열의 패턴을 설명하는 방법이다.

00:25:14.000 --> 00:25:21.000
50년 넘게, 언어와 도구는 개발자들이 조밀하고 정보로 가득 찬 구문으로 정규 표현식을 작성할 수 있게 해주었다.

00:25:21.000 --> 00:25:31.000
여러분 중 일부는 이미 Xcode 찾기 표시줄, grep과 같은 명령줄 도구, Foundation의 NSRegularExpression 클래스 또는 다른 프로그래밍 언어에서 그것들을 사용합니다.

00:25:31.000 --> 00:25:37.000
그 구문은 이제 스위프트의 정규식 리터럴에 의해 지원되며, 다른 개발자 도구에서와 마찬가지로 작동합니다.

00:25:37.000 --> 00:25:46.000
하지만 여러분 중 몇몇은 전에 정규 표현식을 사용해 본 적이 없고 아마 "그게 진짜 코드인가요 아니면 고양이가 키보드를 가로질러 걸었나요?"라고 할 것입니다.

00:25:46.000 --> 00:25:47.000
그리고 난 널 탓하지 않아.

00:25:47.000 --> 00:25:53.000
Regex 리터럴은 당신이 그것들을 읽기 위해 외워야 하는 기호와 니모닉으로 쓰여진다.

00:25:53.000 --> 00:26:02.000
언어를 아는 사람에게는, 개발자의 이름과 일치하는 부분과 같은 이 정규 표현식의 가장 끔찍한 부분조차도 몇 가지 간단한 일치 규칙의 조합일 뿐입니다.

00:26:02.000 --> 00:26:06.000
하지만 그것은 11개의 캐릭터로 쑤셔 넣는 많은 행동이다.

00:26:06.000 --> 00:26:13.000
Regex 리터럴은 너무 작아서 숙련된 개발자조차도 때때로 복잡한 것을 이해하는 데 1분이 필요하다.

00:26:13.000 --> 00:26:18.000
하지만 기호 대신 단어로 같은 종류의 일치하는 규칙을 쓸 수 있다면 어떨까요?

00:26:18.000 --> 00:26:21.000
그건 이해하기 더 쉬울 것 같아.

00:26:21.000 --> 00:26:26.000
사실, 모든 것을 합치면, SwiftUI와 매우 닮은 것을 얻을 수 있습니다.

00:26:26.000 --> 00:26:30.000
그건 정규 문자에 대한 훌륭한 대안이 될 거야, 그렇지 않니?

00:26:30.000 --> 00:26:33.000
그래서 스위프트가 그걸 지원하는 건 좋은 일이야!

00:26:33.000 --> 00:26:42.000
RegexBuilder 라이브러리는 전통적인 구문보다 사용하기 쉽고 읽기 쉬운 정규 표현식을 위한 완전히 새로운 SwiftUI 스타일의 언어를 제공합니다.

00:26:42.000 --> 00:26:52.000
그것은 정규식 리터럴이 할 수 있는 것과 같은 일을 할 수 있지만, 기억해야 하는 기호와 약어 대신 이해하거나 찾아볼 수 있는 단어로 그 행동을 설명합니다.

00:26:52.000 --> 00:26:57.000
Regex 빌더는 초보자에게 좋지만, 이것은 초보자 전용 기능과는 거리가 멀다.

00:26:57.000 --> 00:27:01.000
그것은 정규 문자가 할 수 있는 것을 훨씬 뛰어넘는 강력한 기능을 가지고 있다.

00:27:01.000 --> 00:27:10.000
우선, SwiftUI 뷰 계층 구조를 뷰로 바꿀 수 있는 것처럼 정규식을 재사용 가능한 정규식 구성 요소로 바꿀 수 있습니다.

00:27:10.000 --> 00:27:17.000
빌더 구문으로 만든 다른 정규 표현식에서 이러한 구성 요소를 사용할 수 있으며, 심지어 재귀적으로 만들 수도 있습니다.

00:27:17.000 --> 00:27:22.000
Regex 빌더는 또한 일부 Swift 유형을 regex로 직접 삭제하는 것을 지원합니다.

00:27:22.000 --> 00:27:28.000
예를 들어, 문자열 리터럴은 그 안에 있는 정확한 텍스트와 일치합니다 - 특별한 이스케이프가 필요하지 않습니다.

00:27:28.000 --> 00:27:32.000
정규식 빌더 중간에 정규식 리터럴을 사용할 수도 있습니다.

00:27:32.000 --> 00:27:38.000
그래서 당신은 정규식 빌더의 명확성과 정규식 리터럴의 간결함 사이에서 균형을 잡을 수 있습니다.

00:27:38.000 --> 00:27:48.000
그리고 이 파운데이션 날짜 형식 스타일과 같은 다른 유형은 사용자 지정 구문 분석 논리를 정규 표현식 빌더와 통합할 수 있으며, 심지어 데이터를 캡처하기 전에 더 풍부한 유형으로 변환할 수도 있습니다.

00:27:48.000 --> 00:27:58.000
마지막으로, 어떤 구문을 사용하든, 정규 표현형은 사용하기 쉬운 유용한 매칭 방법과 강력한 형식의 캡처를 지원합니다.

00:27:58.000 --> 00:28:09.000
이제, 자리에서 꿈틀거리는 정규 표현식 괴짜들을 위해, Swift Regex는 가장 진보된 정규 표현식 구현과 비교할 수 있는 기능 세트를 갖춘 새로운 오픈 소스 매칭 엔진을 사용합니다.

00:28:09.000 --> 00:28:16.000
리터럴 구문은 유니코드 정규 표현식 표준과 호환되며, 흔치 않은 수준의 유니코드 정확성을 가지고 있다.

00:28:16.000 --> 00:28:22.000
예를 들어, dot은 기본적으로 Unicode.Scalar 또는 UTF-8 바이트가 아닌 전체 문자와 일치합니다.

00:28:22.000 --> 00:28:32.000
Swift Regex를 사용하려면 macOS 13 또는 iOS 16과 같은 Swift Regex 엔진이 내장된 OS에서 앱을 실행해야 합니다.

00:28:32.000 --> 00:28:38.000
Swift Regex는 전체 언어입니다 -- 음, 두 개의 언어, 정말로 -- 그래서 그것에 대해 할 말이 훨씬 더 많습니다.

00:28:38.000 --> 00:28:46.000
이 두 세션 - "Swift Regex를 만나다"와 "Swift Regex: Beyond The Basics"는 사용에 대한 더 많은 세부 사항을 제공할 것입니다.

00:28:46.000 --> 00:28:53.000
마지막으로, 우리가 가지고 있는 도구를 포괄적으로 살펴보고 그것들을 개선하기 위해 많은 변화를 만든 곳이 하나 있다.

00:28:53.000 --> 00:28:56.000
그건 제네릭과 프로토콜에 있어.

00:28:56.000 --> 00:29:00.000
이 도구들이 어떻게 개선되었는지 보여주기 위해, 나는 예시 프로토콜이 필요할 것이다.

00:29:00.000 --> 00:29:05.000
당신이 git 클라이언트를 작성하고 있고 두 가지 다른 방식으로 메일맵을 표현해야 한다고 가정해 봅시다.

00:29:05.000 --> 00:29:11.000
커밋을 표시할 때, 사전이 있는 유형을 사용하여 이름을 빠르게 조회합니다.

00:29:11.000 --> 00:29:18.000
하지만 사용자가 메일맵을 편집하도록 할 때, 배열이 있는 유형을 사용하여 항목을 원래 순서대로 유지합니다.

00:29:18.000 --> 00:29:26.000
그리고 둘 다 준수하는 메일맵이라는 프로토콜이 있으므로 메일맵 파서는 두 유형에 항목을 추가할 수 있습니다.

00:29:26.000 --> 00:29:30.000
하지만 파서가 메일맵 프로토콜을 사용할 수 있는 두 가지 방법이 있다.

00:29:30.000 --> 00:29:41.000
나는 그것들을 설명하기 위해 이 addEntries 함수의 두 가지 다른 버전을 작성했지만, Swift가 두 가지 다른 것에 대해 동일한 구문을 사용하고 있기 때문에 실제로 그들이 어떻게 다른지 설명하기는 것은 어렵습니다.

00:29:41.000 --> 00:29:50.000
"메일맵"이라는 단어는 여기서 한 가지를 의미하지만 여기서는 미묘하게 다른 것을 의미한다.

00:29:50.000 --> 00:30:01.000
상속 목록, 일반 매개 변수 목록, 일반 적합성 제약 조건 또는 불투명한 결과 유형에서 프로토콜의 이름을 지정할 때, 그것은 "이 프로토콜을 준수하는 인스턴스"를 의미합니다.

00:30:01.000 --> 00:30:14.000
그러나 변수 유형, 일반 인수, 일반 동일 유형 제약 조건 또는 함수 매개 변수 또는 결과 유형에서, 그것은 실제로 "이 프로토콜을 준수하는 인스턴스를 포함하는 상자"를 의미합니다.

00:30:14.000 --> 00:30:24.000
이 구별은 상자는 일반적으로 더 많은 공간을 사용하고, 작동하는 데 더 많은 시간이 걸리며, 그 안에 인스턴스의 모든 기능을 가지고 있지 않기 때문에 중요하다.

00:30:24.000 --> 00:30:31.000
하지만 당신이 상자를 사용하고 있는 곳은 당신이 사용하지 않는 곳과 똑같이 보이기 때문에, 당신이 상자를 사용하고 있는지 알아내는 것은 어렵습니다.

00:30:31.000 --> 00:30:34.000
스위프트 5.7은 이 감독을 수정한다.

00:30:34.000 --> 00:30:41.000
일치하는 유형이 포함된 이 상자 중 하나를 사용할 때, 스위프트는 이제 당신이 모든 키워드를 쓸 것으로 예상할 것입니다.

00:30:41.000 --> 00:30:53.000
이것은 스위프트 5.7 이전에 유효한 코드에서 필수는 아니지만, 명시적으로 작성하지 않더라도 생성된 인터페이스와 오류 메시지에서 볼 수 있습니다.

00:30:53.000 --> 00:30:58.000
그래서 오른쪽 열에 그 모든 것을 쓰는 선호하는 방법은 모든 키워드를 사용하는 것이다.

00:30:58.000 --> 00:31:03.000
그렇게 하면, 이 상자들 중 하나를 언제 사용하는지 알 수 있을 것이다.

00:31:03.000 --> 00:31:10.000
이제 키워드가 이 예제의 매개 변수 중 하나를 표시하기 때문에, 이 두 함수의 차이점을 설명하는 것이 훨씬 쉬워졌습니다.

00:31:10.000 --> 00:31:17.000
addEntries1은 메일맵을 일반 유형으로 사용합니다; addEntries2는 모든 유형으로 사용합니다.

00:31:17.000 --> 00:31:23.000
그리고 오류 메시지는 모든 유형의 한계 중 하나에 도달했을 때 무슨 일이 일어나고 있는지 설명하는 것이 더 쉽습니다.

00:31:23.000 --> 00:31:30.000
예를 들어, 이 mergeMailmaps 함수는 모든 Mailmap을 일반 Mailmap 매개 변수에 전달하려고 시도합니다.

00:31:30.000 --> 00:31:37.000
이것은 메일맵이 그 자체를 준수할 수 없다는 오류를 일으키는 데 사용되었는데, 이는 항상 역설적으로 보였다.

00:31:37.000 --> 00:31:42.000
하지만 이제 우리는 모든 유형의 개념을 가지고 있기 때문에, 무슨 일이 일어나고 있는지 더 명확하게 설명할 수 있다.

00:31:42.000 --> 00:31:49.000
문제는 메일맵이 포함된 상자인 모든 메일맵이 메일맵 프로토콜을 준수하지 않는다는 것이다.

00:31:49.000 --> 00:31:55.000
하지만 그 상자는 당신이 통과하려고 하는 것이며, 일반적인 매개 변수에 맞지 않습니다.

00:31:55.000 --> 00:32:04.000
여기 상자 안에 있는 인스턴스를 전달하려면, 어떻게든 상자를 열고, 그 안에 있는 메일맵을 꺼내고, 대신 전달해야 합니다.

00:32:04.000 --> 00:32:10.000
하지만 사실, 이와 같은 간단한 경우에, 스위프트는 이제 당신을 위해 그것을 할 것입니다.

00:32:10.000 --> 00:32:16.000
상자를 열고, 그 안에 있는 인스턴스를 꺼내서, 일반 매개 변수에 전달하세요.

00:32:16.000 --> 00:32:19.000
그래서 당신은 더 이상 이 오류 메시지를 거의 볼 수 없을 것입니다.

00:32:19.000 --> 00:32:23.000
하지만 그것보다 어떤 유형에도 훨씬 더 흥미로운 개선이 있다.

00:32:23.000 --> 00:32:34.000
이전에는 프로토콜이 자체 유형을 사용하거나 관련 유형이 있거나 Equatable과 같은 프로토콜을 준수하는 경우 어떤 유형으로도 사용할 수 없습니다.

00:32:34.000 --> 00:32:42.000
하지만 스위프트 5.7에서, 이 오류는 그냥 사라졌다.

00:32:42.000 --> 00:32:47.000
많은 개발자들이 이것으로 어려움을 겪었기 때문에, 우리는 소스에서 그것을 수정하게 되어 기쁩니다.

00:32:47.000 --> 00:32:52.000
이제, 그것은 메일맵과 같은 프로토콜만으로도 충분히 흥미롭지만, 이것은 훨씬 더 나아간다.

00:32:52.000 --> 00:32:58.000
컬렉션과 같은 매우 정교한 프로토콜조차도 어떤 유형으로도 사용될 수 있기 때문이다.

00:32:58.000 --> 00:33:04.000
"기본 관련 유형"이라는 새로운 기능 덕분에 요소 유형을 지정할 수도 있습니다.

00:33:04.000 --> 00:33:08.000
많은 관련 유형은 기본적으로 구현 세부 사항일 뿐이다.

00:33:08.000 --> 00:33:16.000
당신은 보통 컬렉션이 인덱스, 반복자 또는 하위 시퀀스에 어떤 유형을 사용하는지 신경 쓰지 않습니다. 지원하는 유형을 사용하기만 하면 됩니다.

00:33:16.000 --> 00:33:20.000
하지만 그 요소는 다른 이야기이다.

00:33:20.000 --> 00:33:29.000
컬렉션이 어떤 요소 유형을 사용하는지 항상 정확히 신경 쓰지 않을 수도 있지만, 아마도 요소로 무언가를 할 것이므로, 그것들을 제한하거나 반환해야 할 것입니다.

00:33:29.000 --> 00:33:41.000
프로토콜의 거의 모든 사용자가 관심을 가질 Element와 같은 관련 유형이 있을 때, 프로토콜의 이름 뒤에 각괄호 안에 이름을 넣어 기본 관련 유형으로 만들 수 있습니다.

00:33:41.000 --> 00:33:52.000
그렇게 하면, 모든 컬렉션을 포함하여 프로토콜의 이름을 쓸 수 있는 거의 모든 곳에서 괄호 구문으로 프로토콜의 기본 관련 유형을 제한할 수 있습니다.

00:33:52.000 --> 00:33:57.000
이제, 여러분 중 몇몇은 이 유형을 보고 "잠깐만요"라고 할 수도 있습니다.

00:33:57.000 --> 00:34:03.000
이미 AnyCollection이라고 불리는 것이 있지 않나요? 그냥 'any' 대문자로 함께 실행하세요?"

00:34:03.000 --> 00:34:06.000
그리고 네 말이 맞아, 있어!

00:34:06.000 --> 00:34:13.000
오래된 AnyCollection은 모든 유형과 동일한 목적을 제공하는 손글씨 구조체인 유형 지우기 래퍼입니다.

00:34:13.000 --> 00:34:27.000
차이점은 AnyCollection 구조체가 당신이 인생에서 본 것 중 가장 지루한 상용구 코드의 한 줄 한 줄이라는 것입니다; 반면 모든 유형은 기본적으로 같은 일을 하는 내장 언어 기능입니다 - 무료로!

00:34:27.000 --> 00:34:34.000
이제 AnyCollection 구조체는 이전 버전과의 호환성을 위해 유지될 것이며 어떤 유형도 아직 일치할 수 없는 몇 가지 기능이 있기 때문입니다.

00:34:34.000 --> 00:34:44.000
하지만 코드에 자신만의 유형 지우기 래퍼가 있다면, 박스 클래스나 클로저 대신 내장된 모든 유형을 사용하여 다시 구현할 수 있는지 확인하고 싶을 수도 있습니다.

00:34:44.000 --> 00:34:47.000
아니면 그냥 유형 별칭으로 바꿀 수도 있습니다.

00:34:47.000 --> 00:34:51.000
그래서 스위프트는 모든 유형을 극적으로 개선했다.

00:34:51.000 --> 00:34:55.000
그것은 모든 키워드를 도입했기 때문에 당신이 그것들을 어디에 사용하고 있는지 볼 수 있습니다.

00:34:55.000 --> 00:34:58.000
그것은 당신이 그것들을 일반적인 주장으로 전달할 수 있게 해준다.

00:34:58.000 --> 00:35:03.000
많은 프로토콜이 그들과 함께 사용되는 것을 막는 제한을 폐지했다.

00:35:03.000 --> 00:35:08.000
그리고 그것은 심지어 당신이 모든 유형의 주요 관련 유형을 제한할 수 있게 해준다.

00:35:08.000 --> 00:35:13.000
하지만 이러한 모든 개선에도 불구하고, 모든 유형에는 여전히 한계가 있다.

00:35:13.000 --> 00:35:30.000
예를 들어, 메일맵이 Equatable을 준수할 때 이제 모든 메일맵을 사용할 수 있지만, 등호 연산자는 두 메일맵이 동일한 구체적인 유형을 갖도록 요구하기 때문에 여전히 등호 연산자를 사용할 수 없지만, 두 개의 메일맵을 사용할 때는 보장되지 않습니다.

00:35:30.000 --> 00:35:37.000
따라서 스위프트는 모든 유형을 많이 개선했지만, 기능과 성능 모두에서 여전히 중요한 한계가 있다.

00:35:37.000 --> 00:35:43.000
그리고 그것이 많은 시간 동안, 당신은 그것들을 사용해서는 안 됩니다 - 대신 제네릭을 사용해야 합니다.

00:35:43.000 --> 00:35:48.000
그러니 addEntries의 두 버전으로 돌아가서 그 지혜를 적용합시다.

00:35:48.000 --> 00:35:56.000
두 버전 모두 정확히 같은 일을 하지만, 상단의 버전은 일반 유형을 사용하고, 하단의 버전은 모든 유형을 사용합니다.

00:35:56.000 --> 00:36:02.000
일반 버전은 더 효율적이고 더 유능할 것이므로, 당신은 그것을 사용해야 합니다.

00:36:02.000 --> 00:36:08.000
그럼에도 불구하고, 당신은 아마 어떤 유형이든 사용하고 싶은 유혹을 받을 것입니다. 왜냐하면 그것들은 읽고 쓰기가 훨씬 쉽기 때문입니다.

00:36:08.000 --> 00:36:18.000
제네릭 버전을 작성하려면, 두 개의 제네릭 유형 이름을 선언하고, 둘 다 제한하고, 마지막으로 그 제네릭 유형 이름을 매개 변수 유형으로 사용해야 합니다.

00:36:18.000 --> 00:36:23.000
그것은 "모든 컬렉션"과 "모든 메일맵"을 쓰는 것에 비하면 지친다.

00:36:23.000 --> 00:36:27.000
그래서 당신은 그들의 단점에도 불구하고 어떤 유형이든 사용하고 싶은 유혹을 받을 것입니다.

00:36:27.000 --> 00:36:34.000
하지만 그건 내가 전에 말했던 것과 같은 거야 - 망치가 크고 꽉 끼는 손잡이를 가지고 있기 때문에 스크루드라이버 대신 망치를 사용해.

00:36:34.000 --> 00:36:37.000
너는 그 선택을 할 필요가 없어.

00:36:37.000 --> 00:36:42.000
그래서 스위프트는 제네릭을 어떤 유형과 마찬가지로 사용하기 쉽게 만들고 있다.

00:36:42.000 --> 00:36:48.000
일반 매개 변수가 한 곳에서만 사용되는 경우, 이제 일부 키워드를 약어로 쓸 수 있습니다.

00:36:48.000 --> 00:36:55.000
그리고 기본 관련 유형도 지원하므로, 훨씬 이해하기 쉬운 코드로 모든 메일맵 항목 컬렉션을 수락할 수 있습니다.

00:36:55.000 --> 00:37:00.000
도구 상자에 있는 그것으로, 더 이상 제네릭을 피할 이유가 없습니다.

00:37:00.000 --> 00:37:07.000
제네릭과 모든 유형 중에서 선택할 수 있다면, 제네릭은 사용하기 쉬울 것입니다. "any" 대신 "some"이라고 쓰세요.

00:37:07.000 --> 00:37:11.000
그래서 당신은 그 일에 가장 적합한 도구를 사용하는 것이 좋습니다.

00:37:11.000 --> 00:37:15.000
나는 프로토콜과 제네릭에 대한 이러한 변화의 표면만 긁었다.

00:37:15.000 --> 00:37:28.000
스위프트의 모든 제네릭 기능에 대한 훌륭한 검토뿐만 아니라 심층적인 검토를 위해, 우리는 올해 당신을 위한 두 가지 회담이 더 있습니다: "스위프트 제네릭 포용"과 "스위프트의 프로토콜 인터페이스 디자인."

00:37:28.000 --> 00:37:35.000
이제, 안젤라와 나는 스위프트에 대한 거의 24개의 변화에 대해 이야기했지만, 우리가 이 세션에 들어갈 수 없는 것이 훨씬 더 많다.

00:37:35.000 --> 00:37:43.000
이러한 모든 변경 사항은 스위프트 포럼의 에볼루션 보드에서 공개적으로 제안, 제안, 검토 및 받아들여졌다.

00:37:43.000 --> 00:37:48.000
그리고 그들 모두는 애플 외부의 지역 사회 구성원들의 도움으로 형성되고 실현되었다.

00:37:48.000 --> 00:37:55.000
만약 당신이 그 사람들 중 한 명이라면, 스위프트 5.7을 훌륭한 릴리스로 만들어 주셔서 감사합니다.

00:37:55.000 --> 00:38:02.000
그리고 다음에 무엇이 올지 결정하는 것을 돕고 싶다면, Swift.org/contributing을 방문하여 참여 방법을 알아보세요.

00:38:02.000 --> 00:38:03.000
시간 내줘서 고마워.

00:38:03.000 --> 00:38:06.000
그리고 행복한 코딩.

00:38:06.000 --> 23:59:59.000
♪

