WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:10.000
안녕 그리고 환영해.

00:00:10.000 --> 00:00:13.000
저는 GPU 소프트웨어의 엔지니어링 관리자인 갈로 아빌라입니다.

00:00:13.000 --> 00:00:19.000
이 세션에서 Eylon과 저는 Metal 3으로 앱의 GPU 바이너리 생성을 개선할 수 있는 방법을 공유하게 되어 기쁩니다.

00:00:19.000 --> 00:00:26.000
먼저, 오프라인 편집이 앱 끊김, 첫 번째 실행 및 새로운 수준의 로드 시간을 줄이는 데 어떻게 도움이 될 수 있는지 설명하겠습니다.

00:00:26.000 --> 00:00:35.000
그런 다음 Eylon은 크기 컴파일러 옵션에 대한 최적화를 사용하여 변환을 확장하는 코드를 조정하고 컴파일 시간을 개선하는 방법을 설명할 것입니다.

00:00:35.000 --> 00:00:39.000
오프라인 컴파일을 사용하면 GPU 바이너리 생성을 프로젝트 빌드 시간으로 이동할 수 있습니다.

00:00:39.000 --> 00:00:47.000
채택이 Metal 애플리케이션에 가져올 수 있는 이점을 완전히 이해하기 위해, 이미 GPU 바이너리를 생성할 수 있는 방법을 검토하는 것으로 시작하겠습니다.

00:00:47.000 --> 00:00:52.000
메탈 앱에서 GPU 바이너리 생성은 빌드 시간과 런타임 모두에서 발생합니다.

00:00:52.000 --> 00:00:56.000
예를 들어, 소스에서 금속 라이브러리를 인스턴스화한다고 가정해 봅시다.

00:00:56.000 --> 00:01:02.000
이것은 앱 런타임에 AIR라고도 알려진 Apple의 중간 표현을 생성합니다.

00:01:02.000 --> 00:01:11.000
이것은 CPU 집약적인 작업이 될 수 있으며, 소스를 Metal 라이브러리로 미리 컴파일하고 대신 파일에서 인스턴스화하여 앱 빌드 시간으로 이동할 수 있습니다.

00:01:11.000 --> 00:01:18.000
메탈 라이브러리가 메모리에 있으면, 상태와 기능을 포함하는 파이프라인 상태 설명자를 만드는 것은 가벼운 작업입니다.

00:01:18.000 --> 00:01:28.000
적시 GPU 바이너리 생성이 이루어지는 또 다른 CPU 집약적인 작업이 될 수 있는 파이프라인 상태 객체를 만들 때까지.

00:01:28.000 --> 00:01:36.000
런타임에 GPU 바이너리 생성은 CPU 집약적인 작업이 될 수 있기 때문에, 메탈은 파이프라인 상태 객체 생성 속도를 높이는 데 도움을 줍니다.

00:01:36.000 --> 00:01:41.000
PSO를 인스턴스화할 때, 메탈은 GPU 바이너리를 파일 시스템 캐시에 저장합니다.

00:01:41.000 --> 00:01:46.000
그리고 새로운 PSO가 생성될 때마다, 새로 생성된 기능이 추가됩니다.

00:01:46.000 --> 00:01:52.000
따라서 참조된 이전에 생성된 바이너리는 캐시에서 로드됩니다.

00:01:52.000 --> 00:01:58.000
메탈은 또한 이진 아카이브를 사용하여 GPU 바이너리가 캐시되는 시기와 장소를 명시적으로 제어할 수 있게 해준다.

00:01:58.000 --> 00:02:05.000
PSO 설명자를 사용하여 필요한 만큼 아카이브에 GPU 바이너리를 캐시하기만 하면 됩니다.

00:02:05.000 --> 00:02:09.000
그러면 당신의 PSO 생성은 가벼운 작업이 됩니다.

00:02:09.000 --> 00:02:14.000
바이너리 아카이브는 더 유연한 캐싱을 가능하게 하지만, 여전히 런타임에 생성되어야 한다.

00:02:14.000 --> 00:02:20.000
많은 경우에, 당신이 정말로 원하는 것은 빌드 시간에 그 아카이브를 생성하는 것이며, 이제 마침내 할 수 있습니다.

00:02:20.000 --> 00:02:29.000
오프라인 바이너리 생성을 사용하면 프로젝트 빌드 시간에 메탈 소스 또는 메탈 라이브러리와 함께 메탈 파이프라인 스크립트라고 불리는 새로운 아티팩트를 지정할 수 있습니다.

00:02:29.000 --> 00:02:35.000
파이프라인 스크립트는 API의 파이프라인 설명자 모음과 동등한 컴파일러 툴체인입니다.

00:02:35.000 --> 00:02:38.000
컴파일 프로세스의 출력은 바이너리 아카이브입니다.

00:02:38.000 --> 00:02:42.000
앱 런타임에는 더 이상 GPU 코드 생성이 이루어지지 않습니다.

00:02:42.000 --> 00:02:48.000
PSO 생성을 가속화하기 위해 오프라인으로 구축된 바이너리 아카이브를 로드하기만 하면 됩니다.

00:02:48.000 --> 00:02:55.000
오프라인 컴파일은 Metal을 낮은 수준의 API로 만드는 핵심인 런타임 CPU 오버헤드를 줄임으로써 앱에 도움이 됩니다.

00:02:55.000 --> 00:03:00.000
게다가, 채택은 두 가지 눈에 띄는 방법으로 앱의 경험을 향상시킬 수 있습니다.

00:03:00.000 --> 00:03:07.000
첫 번째 출시와 새로운 수준의 로딩 시간은 극적으로 빨라질 수 있으며, 잠재적으로 더 큰 참여와 상호 작용을 초래할 수 있다.

00:03:07.000 --> 00:03:15.000
런타임 컴파일로 인한 끊김 또는 프레임 속도 감소는 사전 워밍 프레임의 메모리 또는 CPU 비용 없이 마침내 제거될 수 있습니다.

00:03:15.000 --> 00:03:19.000
나는 다음에 이러한 이점들을 더 자세히 살펴볼 것이다.

00:03:19.000 --> 00:03:22.000
여기에 전통적인 앱 런타임 바이너리 생성이 있습니다.

00:03:22.000 --> 00:03:31.000
이 예에서, 앱은 상호 작용을 시작하기 전에 로딩 화면 뒤에서 GPU 바이너리를 컴파일하는 데 약 2/3의 시간을 소비합니다.

00:03:31.000 --> 00:03:43.000
하지만 오프라인 컴파일을 사용하면 런타임 셰이더 생성이 앱 빌드 시간으로 이동하고, PSO 생성은 짧은 시간 안에 이루어지며, 로드 화면에서 공회전하는 대신 앱과 더 빨리 상호 작용할 수 있습니다.

00:03:43.000 --> 00:03:47.000
오프라인 편집은 또한 말더듬을 줄이는 데 도움이 된다.

00:03:47.000 --> 00:03:56.000
전통적인 런타임 바이너리 생성을 사용하면 로드 시간에 생성하기에는 너무 많은 파이프라인 상태가 있을 수 있으므로 대신 just-in-time을 만들 수 있습니다.

00:03:56.000 --> 00:04:03.000
그리고 그런 일이 발생하면, 명령 인코딩을 일시적으로 중단하는 컴파일로 인해 프레임 드롭이 발생할 수 있습니다.

00:04:03.000 --> 00:04:10.000
오프라인 컴파일은 앱 빌드 시간에 더 많은 셰이더를 컴파일할 수 있기 때문에 성가신 거품을 제거합니다.

00:04:10.000 --> 00:04:16.000
다음으로, 오프라인 편집의 이점을 활용할 수 있도록 새로운 개발자 워크플로우를 공유하겠습니다.

00:04:16.000 --> 00:04:21.000
다음 워크플로우에서는 새로운 툴체인 기능을 사용하여 GPU 바이너리를 오프라인으로 구축하는 방법을 배우게 됩니다.

00:04:21.000 --> 00:04:25.000
새로운 파이프라인 스크립트 입력 아티팩트를 생성하는 방법을 보여드리겠습니다.

00:04:25.000 --> 00:04:29.000
그런 다음, 툴체인을 호출하여 GPU 바이너리를 생성하는 방법.

00:04:29.000 --> 00:04:38.000
파이프라인 스크립트 아티팩트는 하나 이상의 API 파이프라인 상태 설명자에 대한 JSON 형식의 설명이며 여러 가지 방법으로 생성될 수 있습니다.

00:04:38.000 --> 00:04:46.000
예를 들어, 좋아하는 JSON 편집기에서 작성하거나, 개발 및 테스트 중에 직렬화된 바이너리 아카이브에서 수확하세요.

00:04:46.000 --> 00:04:54.000
여기에 상태와 함수와 동등한 JSON 표현이 있는 렌더링 파이프라인 설명자를 생성하는 금속 코드 스니펫이 있습니다.

00:04:54.000 --> 00:04:59.000
먼저, API 금속 라이브러리 파일은 라이브러리 경로 속성으로 지정됩니다.

00:04:59.000 --> 00:05:04.000
그런 다음 API는 설명자 함수 이름을 렌더링 파이프라인 속성으로 렌더링합니다.

00:05:04.000 --> 00:05:11.000
마지막으로, raster_sample_count 또는 픽셀 형식과 같은 다른 파이프라인 상태도 스크립트 속성으로 캡처됩니다.

00:05:11.000 --> 00:05:16.000
Metal의 개발자 문서에서 더 많은 JSON 스키마 세부 사항을 찾아보세요.

00:05:16.000 --> 00:05:22.000
또한 JSON 스크립트 생성을 시작하고 싶을 수도 있으며, Metal 런타임을 사용하면 도움이 될 수 있습니다.

00:05:22.000 --> 00:05:27.000
런타임에 바이너리 아카이브를 생성하고, 개발 및 테스트 과정에서 직렬화하기만 하면 됩니다.

00:05:27.000 --> 00:05:32.000
이제 Metal API로 이것을 어떻게 달성할 수 있는지 보여드리겠습니다.

00:05:32.000 --> 00:05:48.000
상태와 기능으로 파이프라인 설명자를 만들고, GPU 바이너리를 생성하는 아카이브에 추가하고, 앱 번들로 가져오고 로드하기 위해 파일 시스템에 직렬화하여 런타임 수확 프로세스를 시작합니다.

00:05:48.000 --> 00:05:52.000
메탈 3 런타임은 GPU 바이너리와 함께 파이프라인 설명자를 저장합니다.

00:05:52.000 --> 00:05:55.000
이제 그것들을 추출하는 방법을 보여드리겠습니다.

00:05:55.000 --> 00:06:00.000
메탈 소스를 사용하면 기존 아카이브에서 JSON 파이프라인 스크립트를 추출할 수 있습니다.

00:06:00.000 --> 00:06:05.000
이것은 바이너리 생성을 런타임에서 앱 빌드 시간으로 마이그레이션하는 데 편리합니다.

00:06:05.000 --> 00:06:10.000
플랫버퍼와 출력 디렉토리 옵션으로 메탈 소스를 호출하세요.

00:06:10.000 --> 00:06:14.000
결과는 추가 바이너리를 생성하기 위해 편집할 수 있는 파이프라인 스크립트 파일입니다.

00:06:14.000 --> 00:06:18.000
이제 툴체인을 호출하는 방법을 보여드리겠습니다.

00:06:18.000 --> 00:06:23.000
Xcode 프로젝트 빌드 단계에서 GPU 바이너리를 생성하는 것은 쉽다.

00:06:23.000 --> 00:06:29.000
소스, 파이프라인 스크립트 및 출력 파일로 터미널에서 금속을 호출하기만 하면 됩니다.

00:06:29.000 --> 00:06:36.000
출력 금속 라이브러리에는 이제 GPU 바이너리가 포함되어 있으며, 모든 툴체인 지원 장치에 배포할 수 있습니다.

00:06:36.000 --> 00:06:42.000
그리고 소스 대신 메탈 라이브러리가 있다면, 툴체인에도 전달할 수 있습니다.

00:06:42.000 --> 00:06:48.000
기존 금속 라이브러리에서 바이너리를 생성하는 것은 금속 번역기 도구와 마찬가지로 쉽습니다.

00:06:48.000 --> 00:06:53.000
터미널에서 소스, 파이프라인 스크립트 및 출력 파일로 metal-tt를 호출하세요.

00:06:53.000 --> 00:07:00.000
결과 메탈 라이브러리에는 이제 모든 툴체인 지원 장치에 대한 GPU 바이너리가 포함되어 있습니다.

00:07:00.000 --> 00:07:05.000
이제 오프라인에서 바이너리를 만드는 방법을 알았으니, 그것들을 로드하는 방법을 검토하겠습니다.

00:07:05.000 --> 00:07:10.000
아카이브 설명자를 만들 때 이진 URL을 제공하고 아카이브를 인스턴스화하는 데 사용하세요.

00:07:10.000 --> 00:07:12.000
그게 다야!

00:07:12.000 --> 00:07:18.000
메탈의 바이너리 아카이브 API에 대한 자세한 내용은 지난 몇 년간의 회담을 참조하십시오.

00:07:18.000 --> 00:07:25.000
마지막으로, 메탈이 오프라인에서 생성된 아티팩트에 대한 GPU 바이너리 호환성을 처리하는 방법에 대한 메모.

00:07:25.000 --> 00:07:30.000
오프라인에서 생성된 바이너리가 향후 OS 버전 및 제품과 호환되도록 하기 위해.

00:07:30.000 --> 00:07:34.000
메탈은 OS 업데이트 또는 앱 설치 시간에 바이너리 아카이브를 우아하게 업그레이드합니다.

00:07:34.000 --> 00:07:38.000
그것은 매우 비동기적으로, 그리고 백그라운드에서 한다.

00:07:38.000 --> 00:07:45.000
나는 당신이 오프라인 컴파일의 이점을 활용하여 런타임 끊김을 제거하고 첫 번째 실행과 새로운 수준의 로드 시간을 줄이기를 기다릴 수 없습니다.

00:07:45.000 --> 00:07:49.000
이러한 개선은 다른 사람들에게 가시적일 수 있으며 전반적인 앱 경험을 향상시킬 수 있다.

00:07:49.000 --> 00:07:51.000
이제, Eylon으로 넘어가.

00:07:51.000 --> 00:07:53.000
에이론: 고마워, 갈로.

00:07:53.000 --> 00:07:58.000
다음으로, 크기에 맞게 최적화하는 새로운 컴파일 옵션을 소개하겠습니다.

00:07:58.000 --> 00:08:02.000
메탈 컴파일러는 런타임 성능을 위해 코드를 공격적으로 최적화한다.

00:08:02.000 --> 00:08:09.000
일부 최적화는 GPU 프로그램 크기를 확장하여 예상치 못한 비용을 초래할 수 있다.

00:08:09.000 --> 00:08:14.000
예를 들어, 함수 인라인은 함수 호출의 오버헤드를 피하기 위한 최적화이다.

00:08:14.000 --> 00:08:19.000
그것은 호출된 함수의 본문을 호출 사이트에 인라인함으로써 작동한다.

00:08:19.000 --> 00:08:34.000
이 예제 커널은 많은 코드처럼 보이지 않지만, 인라인 후, 함수 'f'와 'g'의 복사본을 포함할 것이며, 잠재적으로 도우미와 비원적 라이브러리 함수와 같은 'f'와 'g'에서 호출된 함수도 포함할 것이다.

00:08:34.000 --> 00:08:44.000
또 다른 최적화는 반복 전반에 걸쳐 병렬성을 노출하고 오버헤드 분기를 피하기 위해 루프 본문의 추가 복사본을 인라인하는 루프 언롤링이다.

00:08:44.000 --> 00:08:53.000
컴파일러는 루프의 두 번의 반복 또는 고정된 경계가 있는 루프의 모든 반복을 풀 수 있다.

00:08:53.000 --> 00:09:04.000
이와 같은 최적화가 매우 큰 프로그램을 만들 때, 컴파일러는 컴파일하는 데 더 많은 시간을 소비해야 하며, 어떤 상황에서는 그러한 비용을 피하는 것을 선호할 수 있습니다.

00:09:04.000 --> 00:09:10.000
Xcode 14는 새로운 금속 최적화 모드를 소개합니다: 크기에 맞게 최적화하세요.

00:09:10.000 --> 00:09:18.000
이 모드는 컴파일러가 성능 최적화를 적용할 때 인라인 및 루프 언롤링과 같은 크기 확장 변환을 제한합니다.

00:09:18.000 --> 00:09:27.000
의도된 이점은 기본 최적화가 너무 비싼 것으로 판명될 경우 GPU 바이너리를 더 작게 유지하고 컴파일 시간을 더 짧게 유지하는 것이다.

00:09:27.000 --> 00:09:32.000
크기를 최적화할 때, 런타임 성능이 더 낮을 수 있습니다.

00:09:32.000 --> 00:09:39.000
그것이 실제로 발생하는지 여부는 프로그램에 따라 다르므로, 최적화 모드를 모두 시도하고 비교해야 합니다.

00:09:39.000 --> 00:09:43.000
크기 최적화는 모든 셰이더의 크기와 컴파일 시간을 개선하지 못할 수 있습니다.

00:09:43.000 --> 00:09:50.000
인라인과 언롤링이 일반적인 딥 콜 경로와 루프가 있는 대규모 프로그램에 도움이 될 가능성이 가장 높다.

00:09:50.000 --> 00:09:57.000
이 옵션은 기본 최적화에서 예기치 않게 긴 컴파일 시간이 발생할 때마다 시도해 볼 가치가 있습니다.

00:09:57.000 --> 00:10:02.000
이 옵션은 프로젝트 빌드 시간에 컴파일하든 앱 런타임에 컴파일하든 사용할 수 있습니다.

00:10:02.000 --> 00:10:06.000
여기에 크기 최적화가 차이를 만들 수 있는 경우가 있습니다.

00:10:06.000 --> 00:10:15.000
사이클은 블렌더 3D 디자인 환경을 위한 프로덕션 렌더러를 구현하는 오픈 소스 프로젝트이며, 최근 메탈을 지원하기 위해 업데이트되었습니다.

00:10:15.000 --> 00:10:28.000
애플은 최근 블렌더 개발 기금에 가입했고, 우리가 배운 것 중 하나는 블렌더의 경로 추적 알고리즘이 많은 도우미 함수와 루프가 있는 대규모 컴퓨팅 셰이더를 사용하며, 컴파일 시간은 몇 분까지 추가될 수 있다는 것이다.

00:10:28.000 --> 00:10:36.000
그것들은 정확히 메탈 3의 새로운 크기 최적화 옵션의 혜택을 받을 수 있는 셰이더의 종류라는 것이 밝혀졌다.

00:10:36.000 --> 00:10:48.000
Apple Silicon GPU에서 이러한 장면을 렌더링할 때, 셰이더 파이프라인 컴파일을 포함하는 블렌더의 설정 시간을 최대 1.4배까지 최적화할 수 있습니다.

00:10:48.000 --> 00:10:52.000
그리고 그것은 렌더링 시간에 거의 또는 전혀 저하되지 않은 속도 향상을 제공했다.

00:10:52.000 --> 00:10:57.000
일부 렌더링은 4%까지 느려졌고, 일부는 전혀 느려지지 않았다.

00:10:57.000 --> 00:11:00.000
그래서 더 낮은 런타임 성능이 가능하다.

00:11:00.000 --> 00:11:04.000
하지만 어떤 경우에는 크기 최적화도 런타임 성능을 향상시킬 수 있다.

00:11:04.000 --> 00:11:07.000
여기 예시가 있어.

00:11:07.000 --> 00:11:14.000
이것들은 인텔 GPU의 크기에 대한 최적화를 가능하게 하는 동일한 장면에 대한 렌더링 시간 속도 향상입니다.

00:11:14.000 --> 00:11:20.000
이점은 더 빠른 컴파일뿐만 아니라 최대 1.6배의 더 빠른 렌더링이었다.

00:11:20.000 --> 00:11:21.000
어떻게?

00:11:21.000 --> 00:11:35.000
더 작은 GPU 프로그램은 큰 크기와 함께 제공되는 런타임 페널티를 피할 수 있기 때문에: 더 적은 명령 캐시 누락을 즐기거나 더 적은 레지스터가 필요할 수 있으며, 이는 메모리로의 유출이 적거나 병렬로 더 많은 스레드로 변환됩니다.

00:11:35.000 --> 00:11:40.000
이러한 결과는 모든 셰이더와 장면의 전형적인 것은 아니며, 성능 저하가 가능하다는 것을 명심하세요.

00:11:40.000 --> 00:11:47.000
프로젝트의 경우, 컴파일 시간과 런타임 성능 모두에 대한 실제 영향을 평가해야 합니다.

00:11:47.000 --> 00:11:53.000
세 가지 다른 환경에서 금속 소스에서 컴파일할 때 크기를 최적화할 수 있습니다.

00:11:53.000 --> 00:11:58.000
Xcode 14 사용자 인터페이스에서, 빌드 설정으로 크기 최적화를 지정하십시오.

00:11:58.000 --> 00:12:03.000
"금속 컴파일러 - 빌드 옵션"에서 "최적화 수준" 설정을 찾으십시오.

00:12:03.000 --> 00:12:07.000
레벨 "기본값"은 메탈이 과거에 했던 것처럼 성능을 위해 최적화된다.

00:12:07.000 --> 00:12:11.000
레벨 "크기"는 크기를 최적화할 수 있게 해준다.

00:12:11.000 --> 00:12:18.000
명령줄로 금속 소스를 컴파일할 때, 옵션 '-Os'를 사용하여 크기 최적화를 지정하십시오.

00:12:18.000 --> 00:12:23.000
첫 번째 예제는 단일 컴파일 및 링크 명령에 대한 옵션을 지정합니다.

00:12:23.000 --> 00:12:30.000
두 번째 예에는 두 개의 컴파일 명령이 있으며 일부 셰이더에서만 활성화할 수 있는 옵션을 지정합니다.

00:12:30.000 --> 00:12:34.000
이 옵션은 링크 명령이나 후속 명령으로 전달될 필요가 없습니다.

00:12:34.000 --> 00:12:44.000
그리고 이 이야기의 앞부분에 제시된 명령을 사용하여 GPU 바이너리를 생성하거나 생성하지 않고 크기 최적화를 사용할 수 있습니다.

00:12:44.000 --> 00:12:57.000
마지막으로, 'newLibraryWithSource'와 같은 Metal Framework API로 앱 런타임에 Metal 소스를 컴파일할 때, 속성 'optimizationLevel'을 사용하여 'MTLCompileOptions' 객체의 크기 최적화를 지정하십시오.

00:12:57.000 --> 00:13:02.000
최적화 수준은 '기본값' 또는 '크기'일 수 있습니다.

00:13:02.000 --> 00:13:08.000
당신의 프로젝트가 메탈 컴파일러의 새로운 최적화 모드의 혜택을 받기를 바랍니다.

00:13:08.000 --> 00:13:18.000
갈로: 마무리하기 위해, 저는 앱 내 끊김, 첫 번째 실행 및 새로운 수준의 로드 시간을 줄이기 위해 앱 빌드 시간에 GPU 바이너리를 완전히 생성하는 새로운 워크플로우인 오프라인 컴파일을 발표했습니다.

00:13:18.000 --> 00:13:27.000
Eylon: 그런 다음 프로그램 크기와 컴파일 시간을 줄이기 위해 소스에서 컴파일할 때 새로운 금속 최적화 모드인 크기 최적화를 제시했습니다.

00:13:27.000 --> 00:13:31.000
갈로: 우리는 이러한 개선이 당신의 앱이나 게임이 향상된 사용자 경험을 제공하는 데 도움이 되기를 바랍니다.

00:13:31.000 --> 00:13:39.000
Eylon: 런타임에 더 낮은 컴파일 비용 덕분에 더 짧은 설정 및 로드 시간, 더 적은 끊김, 새로운 워크플로우로.

00:13:39.000 --> 23:59:59.000
봐줘서 고마워. ♪ ♪

