WEBVTT

00:00:00.000 --> 00:00:03.000
♪ 부드러운 기악 힙합 음악 ♪

00:00:03.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:13.000
안녕하세요 여러분, 저는 스위프트 컴파일러 팀의 홀리입니다.

00:00:13.000 --> 00:00:17.000
"Embrace Swift generics"에 오신 것을 환영합니다.

00:00:17.000 --> 00:00:26.000
제네릭은 Swift에서 추상 코드를 작성하는 기본 도구이며, 코드가 진화함에 따라 복잡성을 관리하는 데 중요합니다.

00:00:26.000 --> 00:00:31.000
추상화는 아이디어를 구체적인 세부 사항과 분리한다.

00:00:31.000 --> 00:00:36.000
코드에는 추상화가 유용한 다양한 방법이 있다.

00:00:36.000 --> 00:00:45.000
항상 사용할 수 있는 추상화의 한 형태는 코드를 함수나 지역 변수로 분해하는 것이다.

00:00:45.000 --> 00:00:51.000
같은 기능이나 가치를 여러 번 사용해야 하는 경우 이것은 정말 유용할 수 있습니다.

00:00:51.000 --> 00:01:04.000
기능을 함수로 추출하면 세부 사항이 추상화되며, 추상화를 사용하는 코드는 세부 사항을 반복하지 않고 무슨 일이 일어나고 있는지에 대한 아이디어를 표현할 수 있습니다.

00:01:04.000 --> 00:01:09.000
스위프트에서는 구체적인 유형을 추상화할 수도 있습니다.

00:01:09.000 --> 00:01:18.000
세부 사항이 다른 모두 같은 아이디어인 유형 집합이 있다면, 모든 구체적인 유형으로 작업하기 위해 추상 코드를 작성할 수 있습니다.

00:01:18.000 --> 00:01:38.000
오늘, 우리는 구체적인 유형으로 코드를 모델링하는 워크플로우를 살펴보고, 일련의 구체적인 유형의 공통 기능을 식별하고, 그 기능을 나타내는 인터페이스를 구축하고, 마지막으로, 그 인터페이스를 사용하여 일반 코드를 작성하는 데 뛰어들 것입니다.

00:01:38.000 --> 00:01:44.000
우리는 농장을 시뮬레이션하기 위한 코드를 구축하면서 스위프트의 추상화 도구를 파헤칠 것이다.

00:01:44.000 --> 00:01:48.000
그래서, 몇 가지 구체적인 유형을 쓰는 것으로 시작합시다.

00:01:48.000 --> 00:01:50.000
우리는 "소"라고 불리는 하나의 구조체로 시작할 것이다.

00:01:50.000 --> 00:01:56.000
소는 헤이 유형의 매개 변수를 받아들이는 "먹다"라는 방법을 가지고 있다.

00:01:56.000 --> 00:01:58.000
건초는 또 다른 구조이다.

00:01:58.000 --> 00:02:05.000
그것은 알팔파인 건초를 생산하는 작물을 재배하기 위해 "성장"이라는 정적 방법을 가지고 있다.

00:02:05.000 --> 00:02:10.000
알팔파 구조체는 알팔파의 사례에서 건초를 수확하는 방법을 가지고 있다.

00:02:10.000 --> 00:02:16.000
마지막으로, 우리는 소에게 먹이를 주는 방법이 있는 "농장"이라는 구조를 추가할 것이다.

00:02:16.000 --> 00:02:26.000
사료 방법은 먼저 알팔파를 재배하여 건초를 생산한 다음 건초를 수확하고 마지막으로 소에게 건초를 먹임으로써 구현할 수 있다.

00:02:26.000 --> 00:02:30.000
그리고 이제, 나는 내 농장에서 소들에게 먹이를 줄 수 있다.

00:02:30.000 --> 00:02:34.000
하지만 나는 더 많은 종류의 동물을 추가하고 싶어.

00:02:34.000 --> 00:02:39.000
나는 말과 닭과 같은 다른 동물을 대표하기 위해 더 많은 구조를 추가할 수 있다.

00:02:39.000 --> 00:02:46.000
그리고 나는 농장에서 소, 말, 닭에게 먹이를 주고 싶다.

00:02:46.000 --> 00:02:56.000
나는 각 유형의 매개 변수를 별도로 받아들이기 위해 피드 방법을 오버로드할 수 있지만, 각 오버로드는 정말 비슷한 구현을 가질 것이다.

00:02:56.000 --> 00:03:04.000
이것은 내가 더 많은 종류의 동물을 추가함에 따라 추가 상용구가 될 것이며, 어쨌든 대부분 반복되는 코드이다.

00:03:04.000 --> 00:03:11.000
반복적인 구현으로 과부하를 작성하는 자신을 발견한다면, 그것은 일반화하기 위한 신호일 수 있다.

00:03:11.000 --> 00:03:20.000
근본적으로, 이러한 구현은 다른 유형의 동물이 기능면에서 비슷하기 때문에 매우 유사하다.

00:03:20.000 --> 00:03:25.000
다음 단계는 동물 유형 간의 공통된 능력을 식별하는 것이다.

00:03:25.000 --> 00:03:31.000
우리는 모두 어떤 종류의 음식을 먹을 수 있는 동물 유형을 만들었습니다.

00:03:31.000 --> 00:03:40.000
각 유형의 동물은 다른 먹는 방식을 가질 것이므로, 먹는 방법의 각 구현에는 행동에 차이가 있을 것이다.

00:03:40.000 --> 00:03:51.000
우리가 하고 싶은 것은 추상 코드가 eat 메소드를 호출하고 추상 코드가 작동하는 구체적인 유형에 따라 다르게 작동하도록 하는 것이다.

00:03:51.000 --> 00:03:58.000
추상적인 코드가 다른 구체적인 유형에 대해 다르게 행동하는 능력은 "다형성"이라고 불린다.

00:03:58.000 --> 00:04:07.000
다형성은 코드가 어떻게 사용되는지에 따라 하나의 코드가 많은 행동을 가질 수 있게 해준다.

00:04:07.000 --> 00:04:12.000
적절하게, 다형성 자체는 다른 형태로 나타난다.

00:04:12.000 --> 00:04:20.000
첫 번째는 함수 오버로드이며, 동일한 함수 호출은 인수 유형에 따라 다른 것을 의미할 수 있다.

00:04:20.000 --> 00:04:26.000
과부하는 실제로 일반적인 해결책이 아니기 때문에 "ad-hoc polymorphism"이라고 불린다.

00:04:26.000 --> 00:04:30.000
우리는 방금 과부하가 어떻게 반복적인 코드로 이어질 수 있는지 보았다.

00:04:30.000 --> 00:04:41.000
다음은 하위 유형 다형성이며, 슈퍼타입에서 작동하는 코드는 런타임에 코드가 사용하는 특정 하위 유형에 따라 다른 동작을 가질 수 있습니다.

00:04:41.000 --> 00:04:47.000
마지막으로, 우리는 제네릭을 사용하여 달성되는 파라메트릭 다형성을 가지고 있다.

00:04:47.000 --> 00:04:58.000
일반 코드는 유형 매개 변수를 사용하여 다른 유형으로 작동하는 하나의 코드를 작성할 수 있으며, 구체적인 유형 자체가 인수로 사용됩니다.

00:04:58.000 --> 00:05:04.000
우리는 이미 과부하를 배제했으니, 하위 유형 다형성을 사용해 봅시다.

00:05:04.000 --> 00:05:10.000
하위 유형 관계를 나타내는 한 가지 방법은 클래스 계층 구조를 사용하는 것이다.

00:05:10.000 --> 00:05:14.000
우리는 "동물"이라는 수업을 소개할 수 있다.

00:05:14.000 --> 00:05:19.000
다음으로, 우리는 각 동물 유형을 구조체에서 클래스로 바꿀 것이다.

00:05:19.000 --> 00:05:27.000
각 특정 동물 클래스는 동물 슈퍼클래스에서 상속되며, 먹는 방법을 무시할 것이다.

00:05:27.000 --> 00:05:35.000
이제, 우리는 우리의 모든 특정 동물 유형을 대표할 수 있는 추상적인 기본급 동물을 가지고 있다.

00:05:35.000 --> 00:05:43.000
동물 클래스에서 eat를 호출하는 코드는 하위 클래스 구현을 호출하기 위해 하위 유형 다형성을 사용할 것이다.

00:05:43.000 --> 00:05:44.000
하지만 우리는 아직 끝나지 않았어.

00:05:44.000 --> 00:05:52.000
우리는 여전히 동물의 먹는 방법에 대한 매개 변수 유형을 작성하지 않았고, 이 코드에는 몇 가지 다른 붉은 깃발이 있습니다.

00:05:52.000 --> 00:06:04.000
첫째, 클래스를 사용하는 것은 우리가 다른 동물 인스턴스 간에 어떤 상태도 공유될 필요가 없거나 원하지 않더라도 참조 의미론을 강요했다.

00:06:04.000 --> 00:06:13.000
이 전략은 또한 기본 클래스의 메소드를 재정의하기 위해 하위 클래스를 요구하지만, 이것을 하는 것을 잊어버리는 것은 런타임까지 잡히지 않을 것이다.

00:06:13.000 --> 00:06:26.000
하지만 이 추상화 모델의 더 큰 문제는 각 동물 하위 유형이 다른 유형의 음식을 먹는다는 것이며, 이 의존성은 계급 계층 구조로 표현하기가 정말 어렵다는 것이다.

00:06:26.000 --> 00:06:33.000
우리가 취할 수 있는 한 가지 접근 방식은 Any와 같은 덜 구체적인 유형을 받아들이도록 하는 것이다.

00:06:33.000 --> 00:06:40.000
하지만 이 전략은 런타임에 올바른 유형이 전달되었는지 확인하기 위해 서브클래스 구현에 의존한다.

00:06:40.000 --> 00:06:53.000
그래서, 우리는 각 재정의된 방법에 추가 상용구를 부과했지만, 더 중요한 것은 실수로 잘못된 유형의 음식을 전달할 수 있으며, 런타임에만 잡힐 수 있는 또 다른 버그를 남깁니다.

00:06:53.000 --> 00:06:56.000
그래서, 다른 걸 시도해 보자.

00:06:56.000 --> 00:07:06.000
우리는 대신 동물 슈퍼클래스에 유형 매개 변수를 도입하여 동물 사료 유형을 유형에 안전한 방식으로 표현할 수 있다.

00:07:06.000 --> 00:07:13.000
이 유형 매개 변수는 각 하위 클래스의 특정 피드 유형에 대한 자리 표시자 역할을 합니다.

00:07:13.000 --> 00:07:20.000
이 접근 방식을 통해, 식품 유형 매개 변수는 동물 등급의 선언으로 높아져야 한다.

00:07:20.000 --> 00:07:33.000
동물이 작동하기 위해 음식이 필요하지만, 음식을 먹는 것은 동물의 핵심 목적이 아니며, 동물과 함께 작동하는 많은 코드는 아마도 음식에 전혀 신경 쓰지 않을 것이기 때문에 이것은 조금 부자연스러워 보인다.

00:07:33.000 --> 00:07:39.000
그럼에도 불구하고, 동물 등급에 대한 모든 언급은 음식 유형을 명시해야 한다.

00:07:39.000 --> 00:07:48.000
예를 들어, 각 동물 하위 클래스는 상속 절의 괄호 안에 음식 유형을 명시적으로 지정해야 합니다.

00:07:48.000 --> 00:07:58.000
동물 클래스의 각 사용 현장의 이 상용구에는 각 동물에 특정한 유형을 더 추가하면 번거로워질 수 있습니다.

00:07:58.000 --> 00:08:04.000
그래서, 여기서 우리의 접근 방식 중 어느 것도 좋은 인체 공학이나 올바른 의미를 가지고 있지 않다.

00:08:04.000 --> 00:08:15.000
근본적인 문제는 클래스가 데이터 유형이라는 것이며, 우리는 구체적인 유형에 대한 추상적인 아이디어를 나타내기 위해 슈퍼클래스를 복잡하게 만들려고 노력하고 있다.

00:08:15.000 --> 00:08:26.000
대신, 우리는 기능이 어떻게 작동하는지에 대한 세부 사항 없이 유형의 기능을 나타내도록 설계된 언어 구성을 원합니다.

00:08:26.000 --> 00:08:29.000
동물들은 두 가지 공통된 능력을 가지고 있다.

00:08:29.000 --> 00:08:36.000
각 동물은 그 음식의 일부를 섭취하기 위한 수술과 함께 특정 유형의 음식을 가지고 있다.

00:08:36.000 --> 00:08:41.000
우리는 그러한 기능을 나타내는 인터페이스를 구축할 수 있다.

00:08:41.000 --> 00:08:44.000
스위프트에서, 이것은 프로토콜을 사용하여 이루어진다.

00:08:44.000 --> 00:08:52.000
프로토콜은 준수 유형의 기능을 설명하는 추상화 도구이다.

00:08:52.000 --> 00:08:59.000
프로토콜을 사용하면 유형이 무엇을 하는지에 대한 아이디어를 구현 세부 사항과 분리할 수 있습니다.

00:08:59.000 --> 00:09:04.000
유형이 무엇을 하는지에 대한 아이디어는 인터페이스를 통해 표현된다.

00:09:04.000 --> 00:09:10.000
동물의 기능을 프로토콜 인터페이스로 번역해 봅시다.

00:09:10.000 --> 00:09:17.000
프로토콜의 이름은 우리가 설명하고 있는 유형의 범주를 나타내기 때문에, 나는 이 프로토콜을 "동물"이라고 불렀다.

00:09:17.000 --> 00:09:21.000
각 기능은 프로토콜 요구 사항에 매핑될 것이다.

00:09:21.000 --> 00:09:28.000
특정 유형의 음식은 동물 프로토콜의 관련 유형에 매핑될 것이다.

00:09:28.000 --> 00:09:34.000
유형 매개 변수와 마찬가지로, 관련 유형은 구체적인 유형의 자리 표시자 역할을 한다.

00:09:34.000 --> 00:09:40.000
관련 유형을 특별하게 만드는 것은 그들이 프로토콜을 준수하는 특정 유형에 의존한다는 것이다.

00:09:40.000 --> 00:09:49.000
이 관계는 보장되므로, 특정 유형의 동물의 각 사례는 항상 같은 종류의 음식을 가지고 있다.

00:09:49.000 --> 00:09:55.000
다음으로, 음식을 소비하는 작업은 방법으로 매핑될 것이다.

00:09:55.000 --> 00:10:00.000
이 방법은 "먹기"라고 불리며, 동물의 사료 유형의 매개 변수를 받아들인다.

00:10:00.000 --> 00:10:08.000
프로토콜에는 이 방법의 구현이 없으며, 이를 구현하려면 구체적인 동물 유형이 필요합니다.

00:10:08.000 --> 00:10:14.000
이제 우리는 동물 프로토콜을 가지고 있으므로, 각 콘크리트 동물 유형을 그것에 맞게 만들 수 있습니다.

00:10:14.000 --> 00:10:22.000
선언이나 확장에서 프로토콜 적합성으로 구체적인 유형에 주석을 달 수 있습니다.

00:10:22.000 --> 00:10:29.000
프로토콜은 클래스에 국한되지 않으므로 구조체, 열거형 및 행위자와 함께 프로토콜을 사용할 수 있습니다.

00:10:29.000 --> 00:10:38.000
이 적합성 주석을 작성하면, 컴파일러는 구체적인 유형이 각 프로토콜 요구 사항을 구현하는지 확인할 것입니다.

00:10:38.000 --> 00:10:48.000
각 동물 유형은 먹는 방법을 구현해야 하며, 컴파일러는 매개 변수 목록에서 사용되기 때문에 사료 유형이 무엇인지 추론할 수 있다.

00:10:48.000 --> 00:10:54.000
피드 유형은 또한 유형 별칭을 사용하여 명시적으로 작성할 수 있습니다.

00:10:54.000 --> 00:11:02.000
우리는 프로토콜 인터페이스를 사용하여 동물의 공통 기능을 성공적으로 식별하고 그 능력을 표현했습니다.

00:11:02.000 --> 00:11:06.000
이제, 우리는 일반 코드를 작성하기 시작할 수 있다.

00:11:06.000 --> 00:11:10.000
우리는 농장에서 사료 방법을 구현하기 위해 동물 프로토콜을 사용할 수 있다.

00:11:10.000 --> 00:11:15.000
우리는 모든 구체적인 동물 유형에 적합한 하나의 구현을 작성하고 싶습니다.

00:11:15.000 --> 00:11:25.000
우리는 파라메트릭 다형성을 사용하고 메서드가 호출될 때 구체적인 유형으로 대체될 유형 매개 변수를 도입할 것입니다.

00:11:25.000 --> 00:11:30.000
유형 매개 변수는 괄호 안의 함수 이름 뒤에 쓰여진다.

00:11:30.000 --> 00:11:37.000
일반 변수와 함수 매개 변수와 마찬가지로, 원하는 대로 유형 매개 변수의 이름을 지정할 수 있습니다.

00:11:37.000 --> 00:11:44.000
그리고 다른 유형과 마찬가지로, 이름을 사용하여 함수 서명 전반에 걸쳐 유형 매개 변수를 참조할 수 있습니다.

00:11:44.000 --> 00:11:51.000
여기서, 나는 "A"라는 유형 매개 변수를 선언했고, 동물 함수 매개 변수의 유형으로 A를 사용했다.

00:11:51.000 --> 00:12:00.000
우리는 항상 구체적인 동물 유형이 동물 프로토콜을 준수하기를 원하므로, 프로토콜 준수로 유형 매개 변수에 주석을 달 수 있습니다.

00:12:00.000 --> 00:12:13.000
프로토콜 적합성은 괄호로 작성하거나, 다른 유형 매개 변수 간의 관계를 지정할 수 있는 후행 "어디" 절로 작성할 수 있습니다.

00:12:13.000 --> 00:12:22.000
명명된 유형 매개 변수와 후행 "어디" 절은 정교한 요구 사항과 유형 관계를 작성할 수 있기 때문에 정말 강력합니다.

00:12:22.000 --> 00:12:26.000
하지만 대부분의 일반적인 기능은 이 일반성을 필요로 하지 않는다.

00:12:26.000 --> 00:12:29.000
사료 방법에 집중합시다.

00:12:29.000 --> 00:12:39.000
유형 매개 변수 A는 매개 변수 목록에 한 번 나타나며, "어디" 절은 유형 매개 변수에 대한 적합성 요구 사항을 나열합니다.

00:12:39.000 --> 00:12:46.000
이 경우, 유형 매개 변수의 이름을 지정하고 "어디" 절을 사용하면 메소드가 실제보다 더 복잡해 보입니다.

00:12:46.000 --> 00:12:52.000
이 일반적인 패턴은 정말 흔하기 때문에, 그것을 표현하는 더 간단한 방법이 있다.

00:12:52.000 --> 00:13:03.000
유형 매개 변수를 명시적으로 작성하는 대신, 우리는 "일부 동물"을 작성하여 프로토콜 적합성 측면에서 이 추상적인 유형을 표현할 수 있습니다.

00:13:03.000 --> 00:13:14.000
이 선언은 이전 선언과 동일하지만, 불필요한 유형 매개 변수 목록과 "어디" 절은 사라졌습니다. 왜냐하면 우리는 그들이 제공하는 표현력이 필요하지 않았기 때문입니다.

00:13:14.000 --> 00:13:27.000
"일부 동물"을 쓰는 것은 구문 소음을 줄이고 매개 변수 선언에 동물 매개 변수에 대한 의미 정보를 포함하기 때문에 더 간단합니다.

00:13:27.000 --> 00:13:30.000
동물 구문을 분해해 봅시다.

00:13:30.000 --> 00:13:37.000
"일부 동물"의 "일부"는 당신이 함께 작업하고 있는 특정 유형이 있음을 나타냅니다.

00:13:37.000 --> 00:13:42.000
"일부" 키워드에는 항상 적합성 요구 사항이 뒤따른다.

00:13:42.000 --> 00:13:52.000
이 경우, 특정 유형은 동물 프로토콜을 준수해야 하며, 이를 통해 매개 변수 값에 대한 동물 프로토콜의 요구 사항을 사용할 수 있습니다.

00:13:52.000 --> 00:13:56.000
"일부" 키워드는 매개 변수와 결과 유형에 사용될 수 있다.

00:13:56.000 --> 00:14:05.000
이전에 SwiftUI 코드를 작성한 적이 있다면, 이미 "일부 보기"를 사용하여 결과 위치에 "일부"를 사용했습니다.

00:14:05.000 --> 00:14:10.000
"일부 뷰"의 결과 유형은 정확히 같은 개념이다.

00:14:10.000 --> 00:14:21.000
SwiftUI 보기에서 본문 속성은 특정 유형의 보기를 반환하지만, 본문 속성을 사용하는 코드는 특정 유형이 무엇인지 알 필요가 없습니다.

00:14:21.000 --> 00:14:28.000
특정 추상적인 유형의 개념을 더 잘 이해하기 위해 한 걸음 물러서자.

00:14:28.000 --> 00:14:36.000
특정 구체적인 유형의 자리 표시자를 나타내는 추상 유형은 불투명한 유형이라고 불린다.

00:14:36.000 --> 00:14:42.000
대체되는 특정 콘크리트 유형은 기본 유형이라고 불린다.

00:14:42.000 --> 00:14:48.000
불투명한 유형의 값의 경우, 기본 유형은 값의 범위에 대해 고정됩니다.

00:14:48.000 --> 00:14:57.000
이렇게 하면, 값을 사용하는 일반 코드는 값에 액세스할 때마다 동일한 기본 유형을 얻을 수 있습니다.

00:14:57.000 --> 00:15:05.000
"일부" 키워드와 괄호 안의 명명된 유형 매개 변수를 사용하는 유형은 모두 불투명한 유형을 선언합니다.

00:15:05.000 --> 00:15:15.000
불투명한 유형은 입력과 출력 모두에 사용할 수 있으므로 매개 변수 위치 또는 결과 위치에서 선언할 수 있습니다.

00:15:15.000 --> 00:15:19.000
함수 화살표는 이 위치들 사이의 경계선이다.

00:15:19.000 --> 00:15:30.000
불투명한 유형의 위치는 프로그램의 어느 부분이 추상적인 유형을 보고 프로그램의 어느 부분이 구체적인 유형을 결정하는지를 결정한다.

00:15:30.000 --> 00:15:41.000
명명된 유형 매개 변수는 항상 입력 측에서 선언되므로 호출자는 기본 유형을 결정하고 구현은 추상 유형을 사용합니다.

00:15:41.000 --> 00:15:53.000
일반적으로, 불투명한 매개 변수 또는 결과 유형에 대한 값을 제공하는 프로그램의 일부는 기본 유형을 결정하고, 값을 사용하는 프로그램의 부분은 추상 유형을 본다.

00:15:53.000 --> 00:16:00.000
매개 변수와 결과 값에 대한 우리의 직관에 따라 이것이 어떻게 작동하는지 살펴봅시다.

00:16:00.000 --> 00:16:09.000
기본 유형은 값에서 추론되기 때문에, 기본 유형은 항상 값과 같은 장소에서 온다.

00:16:09.000 --> 00:16:16.000
지역 변수의 경우, 기본 유형은 할당의 오른쪽에 있는 값에서 추론된다.

00:16:16.000 --> 00:16:27.000
이것은 불투명한 유형의 지역 변수가 항상 초기 값을 가져야 한다는 것을 의미합니다. 그리고 당신이 하나를 제공하지 않으면, 컴파일러는 오류를 보고할 것입니다.

00:16:27.000 --> 00:16:37.000
기본 유형은 변수의 범위에 대해 고정되어야 하므로, 기본 유형을 변경하려고 하면 오류가 발생합니다.

00:16:37.000 --> 00:16:44.000
불투명한 유형을 가진 매개 변수의 경우, 기본 유형은 호출 사이트의 인수 값에서 추론됩니다.

00:16:44.000 --> 00:16:50.000
매개 변수 위치에서 "일부"를 사용하는 것은 스위프트 5.7에서 새로운 것이다.

00:16:50.000 --> 00:16:58.000
기본 유형은 매개 변수의 범위에 대해서만 고정되어야 하므로, 각 호출은 다른 인수 유형을 제공할 수 있습니다.

00:16:58.000 --> 00:17:05.000
불투명한 결과 유형의 경우, 기본 유형은 구현의 반환 값에서 추론됩니다.

00:17:05.000 --> 00:17:15.000
불투명한 결과 유형을 가진 메서드 또는 계산된 속성은 프로그램의 어느 곳에서나 호출될 수 있으므로, 이 명명된 값의 범위는 전역입니다.

00:17:15.000 --> 00:17:28.000
이것은 기본 반환 유형이 모든 반환 문에서 동일해야 한다는 것을 의미합니다. 그렇지 않은 경우, 컴파일러는 기본 반환 값이 일치하지 않는 유형이 있다는 오류를 보고할 것입니다.

00:17:28.000 --> 00:17:38.000
불투명한 SwiftUI 뷰의 경우, ViewBuilder DSL은 각 브랜치에 대해 동일한 기본 반환 유형을 갖도록 control-flow 문을 변환할 수 있습니다.

00:17:38.000 --> 00:17:43.000
그래서 이 경우, 우리는 ViewBuilder DSL을 사용하여 문제를 해결할 수 있습니다.

00:17:43.000 --> 00:17:53.000
메소드에 @ViewBuilder 주석을 작성하고 반환 문을 제거하면 ViewBuilder 유형으로 결과를 만들 수 있습니다.

00:17:53.000 --> 00:17:56.000
feedAnimal 방법으로 돌아가자.

00:17:56.000 --> 00:18:02.000
다른 곳에서는 불투명한 유형을 참조할 필요가 없기 때문에 매개 변수 목록에서 "일부"를 사용할 수 있습니다.

00:18:02.000 --> 00:18:11.000
함수 서명에서 불투명한 유형을 여러 번 참조해야 할 때, 이름 유형 매개 변수가 유용할 때 유용합니다.

00:18:11.000 --> 00:18:23.000
예를 들어, 우리가 "해비타트"라고 불리는 동물 프로토콜에 또 다른 관련 유형을 추가한다면, 우리는 주어진 동물을 위해 농장에 서식지를 건설할 수 있기를 원할 것이다.

00:18:23.000 --> 00:18:34.000
이 경우, 결과 유형은 특정 동물 유형에 따라 다르므로, 매개 변수 유형과 반환 유형에서 유형 매개 변수 A를 사용해야 합니다.

00:18:34.000 --> 00:18:41.000
불투명한 유형을 여러 번 참조해야 하는 또 다른 일반적인 장소는 일반 유형입니다.

00:18:41.000 --> 00:18:52.000
코드는 종종 일반 유형에 대한 유형 매개 변수를 선언하고, 저장된 속성에 대한 유형 매개 변수를 사용하고, 다시 멤버와이즈 이니셜라이저에서 사용합니다.

00:18:52.000 --> 00:19:01.000
다른 맥락에서 일반 유형을 참조하려면 괄호 안에 유형 매개 변수를 명시적으로 지정해야 합니다.

00:19:01.000 --> 00:19:12.000
선언의 앵글 괄호는 일반 유형을 사용하는 방법을 명확히 하는 데 도움이 될 수 있으므로, 불투명한 유형은 항상 일반 유형의 이름을 지정해야 합니다.

00:19:12.000 --> 00:19:15.000
이제, 피드 방법의 구현을 구축해 봅시다.

00:19:15.000 --> 00:19:23.000
우리는 동물 매개 변수의 유형을 사용하여 사료 관련 유형을 통해 성장하기 위해 작물 유형에 접근할 수 있습니다.

00:19:23.000 --> 00:19:28.000
우리는 이러한 유형의 피드를 생산하는 작물의 인스턴스를 얻기 위해 Feed.grow()를 호출할 것이다.

00:19:28.000 --> 00:19:36.000
다음으로, 우리는 작물에서 농산물을 수확해야 하며, 이는 "수확"이라는 작물 유형에서 제공하는 방법을 호출하여 할 수 있습니다.

00:19:36.000 --> 00:19:39.000
그리고 마지막으로, 우리는 이 농산물을 동물에게 먹일 수 있다.

00:19:39.000 --> 00:19:50.000
기본 동물 유형이 고정되어 있기 때문에, 컴파일러는 다양한 방법 호출에서 식물 유형, 생산 유형 및 동물 유형 간의 관계를 알고 있다.

00:19:50.000 --> 00:19:58.000
이러한 정적인 관계는 우리가 동물에게 잘못된 종류의 음식을 먹이는 실수를 저지르는 것을 방지한다.

00:19:58.000 --> 00:20:07.000
만약 우리가 이 동물에게 올바른 음식 유형이 보장되지 않는 유형을 사용하려고 시도한다면, 컴파일러는 우리에게 말할 것이다.

00:20:07.000 --> 00:20:18.000
동물 사료 유형과 식물 간의 관계를 표현하기 위해 다른 농장 프로토콜이 어떻게 만들어졌는지 알아보려면, "스위프트의 디자인 프로토콜 인터페이스"를 확인하세요.

00:20:18.000 --> 00:20:23.000
마지막으로, 모든 동물에게 먹이를 주는 방법을 추가해 봅시다.

00:20:23.000 --> 00:20:26.000
배열을 받아들이는 feedAll이라는 메소드를 추가할 것이다.

00:20:26.000 --> 00:20:35.000
요소 유형이 동물 프로토콜을 준수해야 한다는 것을 알고 있지만, 배열이 다른 유형의 동물을 저장할 수 있기를 바랍니다.

00:20:35.000 --> 00:20:39.000
어떤 동물이 여기서 우리를 도울 수 있는지 보자.

00:20:39.000 --> 00:20:44.000
"일부"에는 변화할 수 없는 특정 기본 유형이 있다.

00:20:44.000 --> 00:20:51.000
기본 유형이 고정되어 있기 때문에, 배열의 모든 요소는 동일한 유형을 가져야 한다.

00:20:51.000 --> 00:20:59.000
그래서, 일부 동물의 배열은 옳은 것을 표현하지 않는다. 왜냐하면 나는 다른 동물 유형을 수용할 수 있는 배열을 원하기 때문이다.

00:20:59.000 --> 00:21:04.000
여기서, 우리는 모든 종류의 동물을 대표할 수 있는 슈퍼타입이 정말 필요하다.

00:21:04.000 --> 00:21:11.000
우리는 "모든 동물"이라고 써서 임의의 유형의 동물을 표현할 수 있다.

00:21:11.000 --> 00:21:21.000
"Any" 키워드는 이 유형이 임의의 유형의 동물을 저장할 수 있으며, 기본 유형의 동물은 런타임에 따라 달라질 수 있음을 나타냅니다.

00:21:21.000 --> 00:21:28.000
"일부" 키워드와 마찬가지로, "any" 키워드에는 항상 적합성 요구 사항이 뒤따른다.

00:21:28.000 --> 00:21:40.000
모든 동물은 모든 구체적인 동물 유형을 동적으로 저장할 수 있는 단일 정적 유형으로, 값 유형과 함께 하위 유형 다형성을 사용할 수 있습니다.

00:21:40.000 --> 00:21:48.000
이 유연한 저장을 허용하기 위해, 모든 동물 유형은 메모리에 특별한 표현을 가지고 있다.

00:21:48.000 --> 00:21:52.000
당신은 이 표현을 상자처럼 생각할 수 있습니다.

00:21:52.000 --> 00:21:57.000
때때로, 가치는 상자 안에 직접 들어갈 만큼 충분히 작다.

00:21:57.000 --> 00:22:06.000
그리고 다른 값은 상자에 비해 너무 크기 때문에 값은 다른 곳에 할당되어야 하며, 상자는 그 값에 대한 포인터를 저장합니다.

00:22:06.000 --> 00:22:16.000
모든 구체적인 동물 유형을 동적으로 저장할 수 있는 정적 유형은 공식적으로 실존적 유형이라고 불린다.

00:22:16.000 --> 00:22:23.000
그리고 다른 구체적인 유형에 대해 동일한 표현을 사용하는 전략은 "유형 삭제"라고 불린다.

00:22:23.000 --> 00:22:30.000
콘크리트 유형은 컴파일 타임에 지워진다고 하며, 콘크리트 유형은 런타임에만 알려져 있다.

00:22:30.000 --> 00:22:38.000
실존적 유형의 이 두 사례는 모든 동물은 같은 정적 유형을 가지고 있지만, 다른 동적 유형을 가지고 있다.

00:22:38.000 --> 00:22:51.000
유형 삭제는 다른 동물 값 간의 유형 수준 구별을 제거하여 다른 동적 유형을 가진 값을 동일한 정적 유형으로 상호 교환하여 사용할 수 있습니다.

00:22:51.000 --> 00:23:00.000
우리는 유형 삭제를 사용하여 값 유형의 이기종 배열을 작성할 수 있으며, 이는 정확히 우리가 feedAll 메소드에 대해 원하는 것입니다.

00:23:00.000 --> 00:23:04.000
그래서 우리는 모든 동물의 배열을 매개 변수 유형으로 사용할 것이다.

00:23:04.000 --> 00:23:11.000
관련 유형의 프로토콜에 "any" 키워드를 사용하는 것은 Swift 5.7에서 새로운 것이다.

00:23:11.000 --> 00:23:17.000
feedAll 방법을 구현하기 위해, 우리는 먼저 동물의 배열을 반복할 것이다.

00:23:17.000 --> 00:23:22.000
각 동물에 대해, 우리는 동물 프로토콜에서 먹는 방법을 부르고 싶다.

00:23:22.000 --> 00:23:29.000
이 방법을 호출하려면, 이 반복에서 기본 동물에 대한 특정 사료 유형을 얻어야 합니다.

00:23:29.000 --> 00:23:35.000
하지만 우리가 어떤 동물에게 먹으려고 하자마자, 컴파일러 오류가 발생할 것이다.

00:23:35.000 --> 00:23:48.000
우리는 특정 동물 유형 간의 유형 수준의 구별을 제거했기 때문에, 관련 유형을 포함하여 특정 동물 유형에 의존하는 모든 유형 관계도 제거했습니다.

00:23:48.000 --> 00:23:53.000
그래서, 우리는 이 동물이 어떤 종류의 먹이를 기대하는지 알 수 없다.

00:23:53.000 --> 00:24:00.000
유형 관계에 의존하기 위해, 우리는 특정 유형의 동물이 고정된 맥락으로 돌아가야 한다.

00:24:00.000 --> 00:24:08.000
어떤 동물에게 직접 먹으라고 부르는 대신, 우리는 어떤 동물을 받아들이는 사료 방법을 불러야 한다.

00:24:08.000 --> 00:24:24.000
이제, 모든 동물은 일부 동물과 다른 유형이지만, 컴파일러는 기본 값을 언박싱하고 일부 동물 매개 변수에 직접 전달하여 모든 동물의 인스턴스를 일부 동물로 변환할 수 있습니다.

00:24:24.000 --> 00:24:30.000
이 언박싱 인수 기능은 Swift 5.7에서 새로운 것이다.

00:24:30.000 --> 00:24:37.000
언박싱은 컴파일러가 상자를 열고 내부에 저장된 값을 꺼내는 것으로 생각할 수 있습니다.

00:24:37.000 --> 00:24:51.000
일부 동물 매개 변수의 범위에 대해, 그 값은 고정된 기본 유형을 가지고 있으므로, 우리는 관련 유형에 대한 액세스를 포함하여 기본 유형에 대한 모든 작업에 액세스할 수 있습니다.

00:24:51.000 --> 00:25:07.000
이것은 우리가 필요할 때 유연한 스토리지를 선택할 수 있게 해주면서, 기능의 범위에 대한 기본 유형을 수정하여 정적 유형 시스템의 완전한 표현력을 가진 맥락으로 돌아갈 수 있기 때문에 정말 멋지다.

00:25:07.000 --> 00:25:20.000
그리고 대부분의 경우, 어떤 동물에서 프로토콜 메소드를 호출하는 것이 실제로 기본 유형의 메소드를 호출하는 것과 유사하게 당신이 기대하는 방식으로 작동하기 때문에 언박싱에 대해 생각할 필요가 없습니다.

00:25:20.000 --> 00:25:31.000
그래서, 우리는 각 동물을 각 반복에서 특정 동물에게 먹이를 주기 위해 적절한 작물을 재배하고 수확할 수 있는 사료 방법으로 전달할 수 있다.

00:25:31.000 --> 00:25:38.000
이 과정을 통해, 우리는 "일부"와 "모든"가 다른 능력을 가지고 있다는 것을 보았다.

00:25:38.000 --> 00:25:42.000
"일부"로, 기본 유형은 고정되어 있다.

00:25:42.000 --> 00:25:54.000
이를 통해 일반 코드의 기본 유형에 대한 유형 관계에 의존할 수 있으므로 작업 중인 프로토콜의 API 및 관련 유형에 완전히 액세스할 수 있습니다.

00:25:54.000 --> 00:25:59.000
임의의 콘크리트 유형을 저장해야 할 때 "any"를 사용하세요.

00:25:59.000 --> 00:26:12.000
"Any"는 이질적인 컬렉션을 나타내고, 기본 유형의 부재를 나타내고, 옵션을 사용하고, 추상화를 구현 세부 사항으로 만들 수 있는 유형 삭제를 제공합니다.

00:26:12.000 --> 00:26:20.000
일반적으로, 기본적으로 "some"을 쓰고, 임의의 값을 저장해야 한다는 것을 알 때 "some"을 "any"로 변경하세요.

00:26:20.000 --> 00:26:30.000
이 접근 방식을 사용하면, 제공하는 스토리지 유연성이 필요할 때만 유형 삭제 비용과 의미 제한 사항을 지불하게 됩니다.

00:26:30.000 --> 00:26:36.000
이 워크플로우는 돌연변이가 필요하다는 것을 알기 전까지는 기본적으로 let-constants를 작성하는 것과 비슷합니다.

00:26:36.000 --> 00:26:44.000
이 세션에서, 우리는 코드가 진화하고 더 많은 기능을 확보함에 따라 코드를 일반화하는 워크플로우를 살펴보았다.

00:26:44.000 --> 00:26:47.000
우리는 구체적인 유형을 쓰는 것으로 시작했다.

00:26:47.000 --> 00:26:54.000
코드가 더 많은 기능을 얻음에 따라, 우리는 다른 구체적인 유형 간의 반복을 발견했다.

00:26:54.000 --> 00:27:00.000
거기에서, 우리는 공통의 기능을 확인하고 프로토콜을 사용하여 일반화했다.

00:27:00.000 --> 00:27:09.000
마지막으로, 우리는 "some"과 "any"를 사용하여 추상적인 코드를 작성했고, 더 표현적인 코드를 위해 "some"을 선호하는 것에 대해 논의했다.

00:27:09.000 --> 00:27:18.000
프로토콜을 만들고 유형 삭제를 이해하는 데 더 깊이 들어가려면, "스위프트에서 프로토콜 인터페이스 설계"를 확인하세요.

00:27:18.000 --> 00:27:21.000
저와 함께 해주셔서 감사드리며 멋진 WWDC를 보내세요.

00:27:21.000 --> 23:59:59.000
♪

