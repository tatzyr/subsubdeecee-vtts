WEBVTT

00:00:00.000 --> 00:00:03.000
♪ 부드러운 기악 힙합 음악 ♪

00:00:03.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:10.000
안녕하세요, 여러분.

00:00:10.000 --> 00:00:14.000
저는 SwiftUI 팀의 엔지니어인 Jeff입니다.

00:00:14.000 --> 00:00:22.000
오늘, 저는 iPadOS와 macOS의 SwiftUI 앱에 여러 개의 창을 가져오는 것에 대해 이야기하게 되어 기쁩니다.

00:00:22.000 --> 00:00:32.000
이 세션에서, 우리는 우리가 소개하는 몇 가지 새로운 유형을 포함하여 SwiftUI 수명 주기의 다양한 장면 유형에 대한 개요를 열 것입니다.

00:00:32.000 --> 00:00:39.000
보조 장면을 추가하여 이러한 장면 유형을 어떻게 함께 구성할 수 있는지 보여줍니다.

00:00:39.000 --> 00:00:45.000
그런 다음 앱의 특정 장면에 대한 창을 열기 위한 몇 가지 새로운 API를 다룰 것입니다.

00:00:45.000 --> 00:00:51.000
그리고 우리는 앱의 장면을 사용자 정의하는 몇 가지 방법으로 마무리할 것입니다.

00:00:51.000 --> 00:00:57.000
새로운 장면 유형을 파헤치기 전에 기존 장면 유형에 대한 개요부터 시작합시다.

00:00:57.000 --> 00:01:03.000
이전 세션에서 SwiftUI의 앱은 장면과 보기로 구성되어 있다는 것을 기억할 수 있습니다.

00:01:03.000 --> 00:01:08.000
장면은 일반적으로 화면의 창으로 내용을 나타낸다.

00:01:08.000 --> 00:01:12.000
예를 들어, 여기 제가 읽고 있는 책을 추적하기 위해 만든 앱이 있습니다.

00:01:12.000 --> 00:01:17.000
그것은 플랫폼에 적합한 방식으로 내 독서 목록을 보여주는 단일 창 그룹으로 정의된다.

00:01:17.000 --> 00:01:26.000
iPadOS 및 macOS와 같은 여러 창을 지원하는 플랫폼에서 장면은 여러 창으로 자신을 나타낼 수 있습니다.

00:01:26.000 --> 00:01:32.000
장면의 행동과 표현은 사용된 유형에 따라 다르다.

00:01:32.000 --> 00:01:39.000
예를 들어, 장면은 플랫폼 기능에 관계없이 단일 인스턴스로만 자신을 나타낼 수 있다.

00:01:39.000 --> 00:01:43.000
SwiftUI의 현재 장면 유형 목록을 살펴봅시다.

00:01:43.000 --> 00:01:49.000
WindowGroup은 모든 Apple 플랫폼에서 데이터 기반 애플리케이션을 구축하는 방법을 제공합니다.

00:01:49.000 --> 00:01:54.000
DocumentGroup을 사용하면 iOS와 macOS에서 문서 기반 앱을 구축할 수 있습니다.

00:01:54.000 --> 00:02:01.000
그리고 설정은 macOS에서 앱 내 설정 값을 나타내는 인터페이스를 정의합니다.

00:02:01.000 --> 00:02:05.000
이러한 장면 유형은 앱의 기능을 확장하기 위해 함께 구성할 수 있습니다.

00:02:05.000 --> 00:02:08.000
우리는 두 개의 새로운 추가 사항으로 장면 목록을 확장하고 있습니다.

00:02:08.000 --> 00:02:24.000
첫 번째는 모든 플랫폼에서 하나의 고유한 창을 나타내는 장면인 창입니다. macOS의 새로운 장면 유형인 MenuBarExtra는 시스템 메뉴 표시줄에서 영구 컨트롤로 렌더링됩니다.

00:02:24.000 --> 00:02:33.000
다른 장면 유형과 마찬가지로, Window와 MenuBarExtra를 독립형 장면으로 사용하거나 앱의 다른 장면으로 구성할 수 있습니다.

00:02:33.000 --> 00:02:41.000
WindowGroup과 달리, 창 장면은 하나의 고유한 창 인스턴스에서만 내용을 나타낼 것이다.

00:02:41.000 --> 00:02:54.000
이 특성은 장면의 내용이 macOS 및 iPadOS에서 WindowGroups의 다중 창 프레젠테이션 스타일과 반드시 적합하지 않은 글로벌 앱 상태를 나타낼 때 유용할 수 있습니다.

00:02:54.000 --> 00:03:01.000
예를 들어, 게임은 하나의 메인 창만 내용을 렌더링할 수 있도록 허용할 수 있습니다.

00:03:01.000 --> 00:03:08.000
MenuBarExtra는 다른 장면과 약간 다르게 작동하는 새로운 macOS 전용 장면 유형입니다.

00:03:08.000 --> 00:03:19.000
창에 내용을 렌더링하는 대신, 메뉴 표시줄에 라벨을 배치하고 라벨에 고정된 메뉴나 창에 내용을 표시합니다.

00:03:19.000 --> 00:03:27.000
또한, 해당 앱이 최전방인지 여부에 관계없이 관련 앱이 실행되는 한 사용할 수 있습니다.

00:03:27.000 --> 00:03:34.000
MenuBarExtra는 기능에 쉽게 접근할 수 있는 독립형 유틸리티 앱을 만드는 데 적합합니다.

00:03:34.000 --> 00:03:41.000
또는 앱의 기능에 액세스할 수 있는 다른 방법을 제공하기 위해 다른 장면으로 구성할 수 있습니다.

00:03:41.000 --> 00:03:56.000
또한 두 가지 렌더링 스타일을 지원합니다: 메뉴 표시줄에서 아래로 당기는 메뉴의 내용을 보여주는 기본 스타일과 메뉴 표시줄에 고정된 크롬 없는 창에 내용을 표시하는 스타일.

00:03:56.000 --> 00:04:07.000
이 두 가지 새로운 장면 유형이 추가됨에 따라, SwiftUI 앱은 모든 플랫폼에서 훨씬 더 풍부한 기능 세트를 나타낼 수 있습니다.

00:04:07.000 --> 00:04:13.000
이 새로운 API가 기존 장면 유형과 함께 어떻게 사용될 수 있는지 봅시다.

00:04:13.000 --> 00:04:17.000
여기 제가 이전에 보여준 BookClub 앱의 정의가 있습니다.

00:04:17.000 --> 00:04:19.000
그것은 현재 단일 창 그룹으로 구성되어 있다.

00:04:19.000 --> 00:04:27.000
macOS에서, 내 BookClub 앱은 시간이 지남에 따라 우리의 독서 활동을 표시할 수 있는 추가 창의 이점을 누릴 수 있다.

00:04:27.000 --> 00:04:37.000
이것은 macOS 앱이 추가 화면 부동산과 해당 플랫폼에 존재하는 유연한 창 배열을 어떻게 활용할 수 있는지 보여주는 좋은 예입니다.

00:04:37.000 --> 00:04:41.000
우리는 이 인터페이스를 표현하기 위해 앱에 보조 장면을 추가할 것입니다.

00:04:41.000 --> 00:04:48.000
활동 창의 데이터는 전체 앱 상태에서 파생되므로 창 장면이 이상적인 선택입니다.

00:04:48.000 --> 00:04:52.000
같은 상태로 여러 개의 창문을 여는 것은 우리의 디자인과 잘 맞지 않을 것이다.

00:04:52.000 --> 00:05:00.000
우리 장면에 제공된 제목은 창 메뉴의 섹션에 추가된 메뉴 항목의 라벨로 사용될 것입니다.

00:05:00.000 --> 00:05:05.000
이 항목을 선택할 때, 아직 열리지 않았다면 장면의 창이 열릴 것이다.

00:05:05.000 --> 00:05:08.000
그렇지 않으면, 그것은 앞으로 옮겨질 것이다.

00:05:08.000 --> 00:05:21.000
이제 BookClub 앱에 보조 장면을 추가하는 것을 다루었으므로, 우리가 추가하고 있는 새로운 장면 프레젠테이션 API 중 일부와 더 풍부한 경험을 제공하기 위해 앱에 통합할 수 있는 방법에 대해 논의하고 싶습니다.

00:05:21.000 --> 00:05:26.000
BookClub 앱에는 콘텐츠 목록 창의 모든 책에 대해 호출할 수 있는 컨텍스트 메뉴가 있습니다.

00:05:26.000 --> 00:05:31.000
이 상황에 맞는 메뉴에는 창 프레젠테이션을 트리거하기 위한 버튼이 포함될 것입니다.

00:05:31.000 --> 00:05:33.000
우리는 곧 세부 사항을 작성할 것이다.

00:05:33.000 --> 00:05:41.000
SwiftUI는 앱이 정의하는 장면과 연결된 창을 제시하기 위해 환경을 통해 몇 가지 새로운 호출 가능한 유형을 제공합니다.

00:05:41.000 --> 00:05:49.000
이 중 첫 번째는 WindowGroup 또는 창 장면에 대한 창을 표시할 수 있는 openWindow 동작입니다.

00:05:49.000 --> 00:05:56.000
작업에 전달된 식별자는 앱에 정의된 장면의 식별자와 일치해야 합니다.

00:05:56.000 --> 00:06:03.000
openWindow 액션은 또한 제시된 장면이 내용을 표시하는 데 사용할 프레젠테이션 값을 취할 수 있다.

00:06:03.000 --> 00:06:10.000
이 형태의 작업은 우리가 곧 살펴볼 새로운 이니셜라이저를 사용하여 WindowGroup에서만 지원됩니다.

00:06:10.000 --> 00:06:15.000
값의 유형은 장면의 이니셜라이저에 제공된 유형과 일치해야 합니다.

00:06:15.000 --> 00:06:28.000
또한 문서 창을 표시하기 위한 두 가지 호출 가능한 유형이 있습니다: FileDocuments와 ReferenceFileDocuments 모두에 대해 새 문서 창을 여는 것을 지원하는 newDocument 작업.

00:06:28.000 --> 00:06:34.000
이 작업은 앱의 해당 DocumentGroup이 편집기 역할로 정의되어야 합니다.

00:06:34.000 --> 00:06:39.000
이 작업에 제공된 문서는 창이 표시될 때마다 생성됩니다.

00:06:39.000 --> 00:06:48.000
디스크의 기존 파일에 의해 내용이 제공되는 문서 창을 표시하기 위해, openDocument 작업이 있습니다.

00:06:48.000 --> 00:06:51.000
이 작업은 당신이 열고 싶은 파일의 URL을 가져옵니다.

00:06:51.000 --> 00:07:01.000
앱은 창을 표시하기 위해 DocumentGroup을 정의해야 하며, 해당 그룹의 문서 유형은 제공된 URL에서 파일 유형을 읽을 수 있어야 합니다.

00:07:01.000 --> 00:07:06.000
버튼을 다시 방문하면, 우리는 openWindow 환경 속성을 우리의 보기에 추가할 것입니다.

00:07:06.000 --> 00:07:11.000
이 유형은 호출 가능하기 때문에, 우리는 버튼의 동작에서 직접 호출할 수 있습니다.

00:07:11.000 --> 00:07:18.000
우리의 책 유형은 식별 가능한 것을 준수하므로, 우리는 그 식별자를 제시할 값으로 전달할 것입니다.

00:07:18.000 --> 00:07:23.000
이제, 우리가 넘어가기 전에, 저는 openWindow 액션으로 전달된 값에 대해 논의하고 싶습니다.

00:07:23.000 --> 00:07:30.000
나는 UUID 유형의 값인 책의 식별자를 전달하고 있다는 것을 알아챘다.

00:07:30.000 --> 00:07:37.000
일반적으로, 당신은 값 자체보다 이와 같은 모델의 식별자를 사용하는 것을 선호할 것입니다.

00:07:37.000 --> 00:07:39.000
우리의 책 유형은 값 유형이라는 점에 유의하십시오.

00:07:39.000 --> 00:07:47.000
따라서, 우리가 그것을 제시된 값으로 사용한다면, 우리의 새 창은 프레젠테이션을 시작한 것의 복사본을 얻을 것이다.

00:07:47.000 --> 00:07:50.000
둘 중 하나에 대한 편집은 다른 것에 영향을 미치지 않을 것이다.

00:07:50.000 --> 00:07:59.000
책의 식별자를 사용하면 모델 저장소가 단일 값에 여러 바인딩을 제공함으로써 이러한 값에 대한 진실의 원천이 될 수 있습니다.

00:07:59.000 --> 00:08:03.000
값 유형 의미론에 대한 자세한 정보는 개발자 문서를 참조하십시오.

00:08:03.000 --> 00:08:10.000
제시된 유형은 또한 Hashable 및 Codable 프로토콜을 모두 준수해야 합니다.

00:08:10.000 --> 00:08:21.000
제시된 값을 열린 창과 연결하려면 해시 가능한 적합성이 필요합니다. 상태 복원을 위해 제시된 값을 유지하기 위해서는 코딩 가능한 적합성이 필요합니다.

00:08:21.000 --> 00:08:24.000
나는 이 두 가지 행동에 대해 더 자세히 논의할 것이다.

00:08:24.000 --> 00:08:29.000
마지막으로, 가능하다면, 가벼운 값을 통과하는 것을 선호한다.

00:08:29.000 --> 00:08:32.000
우리 책의 식별자는 이것의 또 다른 좋은 예이다.

00:08:32.000 --> 00:08:41.000
값은 상태 복원을 위해 SwiftUI에 의해 유지되기 때문에, 더 작은 값을 사용하면 앱의 반응성이 높아집니다.

00:08:41.000 --> 00:08:48.000
이제, 우리의 버튼은 이제 세부 창을 표시하는 데 필요한 부분을 가지고 있지만, 선택되면 아무것도 표시되지 않습니다.

00:08:48.000 --> 00:08:56.000
이것은 우리가 SwiftUI에게 특정 데이터 유형에 대한 창을 제시하라고 말했지만, 앱에서 그것을 반영하는 장면을 정의하지 않았기 때문입니다.

00:08:56.000 --> 00:08:58.000
우리 앱으로 돌아가서 지금 그 변화를 만들어 봅시다.

00:08:58.000 --> 00:09:05.000
기본 WindowGroup 및 보조 창과 함께, 우리는 책 세부 사항을 처리하기 위해 추가 WindowGroup을 추가할 것입니다.

00:09:05.000 --> 00:09:09.000
우리의 책 세부 사항 WindowGroup은 새로운 이니셜라이저를 사용합니다.

00:09:09.000 --> 00:09:16.000
제목 외에도, 우리는 이 그룹이 Book.ID 유형에 대한 데이터를 제공한다는 것을 알아캀하고 있습니다 -- 우리의 경우, UUID.

00:09:16.000 --> 00:09:22.000
이 유형은 이전에 추가한 openWindow 작업에 전달되는 값과 일치해야 합니다.

00:09:22.000 --> 00:09:36.000
주어진 값이 프레젠테이션을 위해 WindowGroup에 제공되면, SwiftUI는 해당 값에 대한 새로운 하위 장면을 만들고, 해당 장면 창의 루트 콘텐츠는 그룹의 뷰 빌더를 사용하여 해당 값으로 정의됩니다.

00:09:36.000 --> 00:09:40.000
각각의 독특한 가치는 새로운 장면을 만들 것이다.

00:09:40.000 --> 00:09:48.000
값의 같음은 새 창을 만들어야 하는지 또는 기존 창을 재사용할 수 있는지 결정하는 데 사용됩니다.

00:09:48.000 --> 00:09:56.000
openWindow가 창이 이미 존재하는 값을 제시할 때, 그룹은 새 창을 만드는 대신 그 창을 사용할 것이다.

00:09:56.000 --> 00:10:09.000
BookClub 앱을 예로 들 때, 이미 창에 제시된 책에 대한 상황에 맞는 메뉴 작업을 선택하면 같은 책을 보여주는 두 번째 창이 아닌 그 창이 전면에 정렬됩니다.

00:10:09.000 --> 00:10:16.000
제시된 값은 또한 상태 복원을 목적으로 SwiftUI에 의해 자동으로 유지될 것이다.

00:10:16.000 --> 00:10:20.000
당신의 견해는 초기 제시된 값에 대한 구속력이 주어질 것입니다.

00:10:20.000 --> 00:10:24.000
이 바인딩은 창이 열려 있는 동안 언제든지 수정할 수 있습니다.

00:10:24.000 --> 00:10:31.000
상태 복원을 위해 장면이 다시 생성되면, SwiftUI는 가장 최근의 값을 창의 콘텐츠 보기로 전달합니다.

00:10:31.000 --> 00:10:40.000
여기서, 우리는 디스플레이를 위해 모델 스토어에서 지정된 항목을 찾을 수 있는 세부 보기에 Book.ID 바인딩을 제공합니다.

00:10:40.000 --> 00:10:48.000
모든 조각이 제자리에 있으면, 이제 상황에 맞는 메뉴 항목을 선택하고 자체 창에서 책 세부 사항을 볼 수 있습니다.

00:10:48.000 --> 00:10:54.000
마지막으로, 앱에서 장면을 사용자 정의할 수 있는 몇 가지 방법을 살펴보고 싶습니다.

00:10:54.000 --> 00:11:06.000
기본 뷰어 창과 세부 창을 위한 두 개의 WindowGroup 장면으로 앱을 정의했기 때문에 SwiftUI는 기본적으로 파일 메뉴의 각 그룹에 대한 메뉴 항목을 추가합니다.

00:11:06.000 --> 00:11:10.000
그러나, 우리의 세부 사항 창의 메뉴 항목은 우리의 사용 사례에 맞지 않습니다.

00:11:10.000 --> 00:11:16.000
나는 이전에 추가된 컨텍스트 메뉴를 통해서만 창문을 열 수 있는 것을 선호한다.

00:11:16.000 --> 00:11:26.000
새로운 장면 수정자인 commandsRemoved를 사용하면 파일 메뉴와 같은 기본 명령을 더 이상 제공하지 않도록 장면을 수정할 수 있습니다.

00:11:26.000 --> 00:11:34.000
이 수정자를 적용한 후, 파일 메뉴에는 이제 기본 WindowGroup의 창을 여는 항목만 포함되어 있습니다.

00:11:34.000 --> 00:11:43.000
나는 내 독서 활동을 보여주는 보조 창 장면의 현재 프레젠테이션에 그다지 만족하지 않으므로, 다음에 그것에 집중합시다.

00:11:43.000 --> 00:11:50.000
몇 가지 수정자를 적용할 것이기 때문에, 앱 정의를 더 깨끗하게 유지할 수 있는 사용자 지정 장면으로 추출할 것입니다.

00:11:50.000 --> 00:11:57.000
창의 이전 상태가 없다면, SwiftUI는 기본적으로 화면 중앙에 배치할 것이다.

00:11:57.000 --> 00:12:03.000
하지만, 나는 독서 활동이 기본적으로 다른 위치에 배치되었다면 그것을 선호한다.

00:12:03.000 --> 00:12:11.000
새로운 defaultPosition 수정자를 추가함으로써, 이전 상태를 사용할 수 없을 때 사용할 위치를 지정할 수 있습니다.

00:12:11.000 --> 00:12:19.000
이 위치는 화면 크기와 관련이 있으며 현재 로케일을 고려하여 창을 적절한 위치에 배치할 것입니다.

00:12:19.000 --> 00:12:25.000
이 새로운 위치는 내 활동 창을 화면의 다른 보기 창과 구별하는 데 도움이 된다.

00:12:25.000 --> 00:12:31.000
또한 내 활동 창이 기본적으로 특정 크기로 표시되기를 원하지만, 여전히 크기를 조정할 수 있습니다.

00:12:31.000 --> 00:12:36.000
defaultPosition과 함께, 나는 defaultSize 수정자를 추가할 것이다.

00:12:36.000 --> 00:12:43.000
제공된 값은 창의 초기 크기를 도출하기 위해 레이아웃 시스템에 주어질 것이다.

00:12:43.000 --> 00:12:49.000
이제 창의 프레젠테이션을 사용자 정의했으니, 동작을 사용자 정의하기 위해 수정자를 하나 더 추가해 봅시다.

00:12:49.000 --> 00:12:54.000
키보드 단축키 수정자는 장면 유형에서도 작동하도록 확장되었습니다.

00:12:54.000 --> 00:12:59.000
장면 수준에서 사용될 때, 이 수정자는 새 창을 만드는 명령에 영향을 미친다.

00:12:59.000 --> 00:13:06.000
여기서, 단축키 Option-Command-0으로 열 수 있도록 활동 창을 수정했습니다.

00:13:06.000 --> 00:13:21.000
이것은 일반적으로 사용되는 장면에 대한 단축키를 제공하여 앱을 사용자 정의할 수 있는 좋은 방법이 될 수 있으며, 앱의 기본 WindowGroup에 추가되는 Command-N의 기본 단축키를 사용자 정의하는 데에도 사용할 수 있습니다.

00:13:21.000 --> 00:13:25.000
이것은 SwiftUI의 새로운 장면과 윈도우 기능에 대한 투어를 닫습니다.

00:13:25.000 --> 00:13:29.000
우리는 이 새로운 API의 잠재력에 대해 정말 흥분하고 있으며 당신도 그러길 바랍니다!

00:13:29.000 --> 00:13:44.000
iPadOS 및 macOS 앱에 기능을 추가하는 방법에 대한 자세한 정보는 다음과 같은 다른 세션을 확인하세요: "iPad의 SwiftUI: 인터페이스 구성" 및 "iPad의 SwiftUI: 도구 모음, 제목 등 추가."

00:13:44.000 --> 00:13:46.000
봐줘서 고마워.

00:13:46.000 --> 23:59:59.000
♪

