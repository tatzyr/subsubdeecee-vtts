WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:14.000
Raj Ramamurthy: 안녕하세요, "iPad의 SwiftUI: 인터페이스 구성"에 오신 것을 환영합니다.

00:00:14.000 --> 00:00:17.000
저는 Raj이고 SwiftUI에서 일하고 있습니다.

00:00:17.000 --> 00:00:25.000
iPadOS 16에는 풍부한 기능을 갖춘 보다 생산적이고 전문적인 수준의 앱을 구축할 수 있도록 많은 업데이트가 있습니다.

00:00:25.000 --> 00:00:34.000
이 세션에서, 저는 그 중 몇 가지에 대해 논의하고 iPad에서 빛나도록 SwiftUI 앱의 인터페이스를 구성하는 것에 대해 이야기할 것입니다.

00:00:34.000 --> 00:00:38.000
우선, 내가 너를 목록과 테이블 투어에 데려갈게.

00:00:38.000 --> 00:00:44.000
그런 다음, SwiftUI 선택 모델과 선택과 메뉴를 통합하는 방법에 대해 이야기하겠습니다.

00:00:44.000 --> 00:00:50.000
마지막으로, 분할 뷰를 사용하여 iPad용 앱의 내비게이션을 구성하는 방법에 대해 논의하겠습니다.

00:00:50.000 --> 00:00:52.000
하지만 잠깐만, 더 있어.

00:00:52.000 --> 00:00:55.000
이것은 실제로 두 부분으로 구성된 시리즈의 첫 번째 세션이다.

00:00:55.000 --> 00:01:01.000
두 번째 부분에서, 내 동료 해리는 도구 모음, 제목 등을 둘러본다.

00:01:01.000 --> 00:01:10.000
해리는 SwiftUI iPad 앱을 다음 단계로 끌어올리는 정말 중요한 추가 사항을 다루므로, 두 세션을 모두 시청하세요.

00:01:10.000 --> 00:01:14.000
목록과 테이블부터 시작합시다.

00:01:14.000 --> 00:01:18.000
나는 최근에 몇몇 북클럽에 가입했지만, 꽤 뒤쳐지고 있다.

00:01:18.000 --> 00:01:20.000
읽을 수 있는 조용한 장소를 찾는 것은 너무 어렵다.

00:01:20.000 --> 00:01:26.000
그래서 내가 독서에 집중할 수 있도록, 나는 이 신화적인 조용한 장소를 찾기 위해 앱을 만들기 시작했다.

00:01:26.000 --> 00:01:30.000
조용한 곳은 페이지가 날아다니는 독서의 오아시스와 같다.

00:01:30.000 --> 00:01:35.000
그리고 이 앱은 내가 찾은 모든 조용한 장소를 추적하는 데 도움을 준다.

00:01:35.000 --> 00:01:42.000
나는 iPhone용 앱을 만들었지만, 더 큰 디스플레이를 활용하기 위해 iPad용으로 업데이트하는 것은 재미있는 운동이 될 것이라고 생각한다.

00:01:42.000 --> 00:01:48.000
iPad를 위한 앱을 더 좋게 함으로써, 나는 결국 그것을 Mac으로 가져올 때 더 나아갈 것이다.

00:01:48.000 --> 00:01:54.000
나는 이 세션에서 Mac을 명시적으로 다루지 않을 것이지만, 표시된 많은 API는 macOS에도 적용된다.

00:01:54.000 --> 00:01:58.000
여기 제가 지금까지 찾은 모든 조용한 장소의 목록이 있습니다.

00:01:58.000 --> 00:02:02.000
이 목록은 앱 업데이트로 시작하기에 좋은 장소입니다.

00:02:02.000 --> 00:02:04.000
나는 아이패드 버전 작업을 시작했다.

00:02:04.000 --> 00:02:08.000
끔찍하지는 않지만, 더 큰 화면을 이용하지는 않는다.

00:02:08.000 --> 00:02:12.000
꽤 많은 낭비된 공간이 있고, 정보 밀도는 낮다.

00:02:12.000 --> 00:02:21.000
고맙게도, iPadOS 16에는 이러한 종류의 정보 밀도 시나리오에 대한 훌륭한 해결책이 있습니다: 다중 열 테이블.

00:02:21.000 --> 00:02:24.000
그들이 어떻게 생겼는지 보여줄게.

00:02:24.000 --> 00:02:29.000
다음은 다중 열 테이블에 SwiftUI API를 채택한 후의 "모든 장소" 보기입니다.

00:02:29.000 --> 00:02:33.000
나는 앞으로 몇 분 동안 이 스크린샷을 위해 노력할 것이다.

00:02:33.000 --> 00:02:42.000
SwiftUI의 다중 열 테이블은 macOS Monterey에서 처음 도입되었으며, iPadOS 16부터 동일한 테이블 API를 iPad에서 사용할 수 있습니다.

00:02:42.000 --> 00:02:48.000
Mac과 마찬가지로, iPad의 테이블은 여러 열과 정렬을 지원합니다.

00:02:48.000 --> 00:02:55.000
iPad의 테이블 도입과 함께, SwiftUI는 이제 iPad와 Mac의 테이블 섹션을 지원합니다.

00:02:55.000 --> 00:03:07.000
이전 세션 "SwiftUI on the Mac: Build the fundamentals"의 테이블에 대한 일반적인 지침은 여전히 iPad에 적용되므로, 아직 시청하지 않았다면 해당 세션을 시청하도록 초대합니다.

00:03:07.000 --> 00:03:10.000
iPhone 목록에서 시작하여 이전에 표시된 표를 구성해 봅시다.

00:03:10.000 --> 00:03:15.000
여기 이전 장소 목록의 코드가 있습니다.

00:03:15.000 --> 00:03:18.000
먼저, 나는 목록에서 테이블로 바꿀 것이다.

00:03:18.000 --> 00:03:21.000
테이블은 목록과 다른 구조를 가지고 있다.

00:03:21.000 --> 00:03:26.000
뷰 빌더 대신, 테이블은 열 빌더를 받아들인다.

00:03:26.000 --> 00:03:29.000
내가 추가할 첫 번째 열은 장소의 이름이다.

00:03:29.000 --> 00:03:35.000
열은 컬렉션의 각 요소에 대한 뷰를 생성하기 위해 헤더의 이름과 뷰 빌더가 필요합니다.

00:03:35.000 --> 00:03:41.000
나는 또한 값 키 경로를 지정했는데, 이는 나중에 테이블에 정렬을 추가할 때 중요할 것이다.

00:03:41.000 --> 00:03:45.000
뷰 빌더가 목록 기반 건설과 얼마나 비슷한지 주목하세요.

00:03:45.000 --> 00:03:50.000
사실, 나는 심지어 이전의 플레이스셀 유형을 재사용할 수도 있다.

00:03:50.000 --> 00:04:00.000
컴팩트 사이즈 클래스에서, 테이블은 첫 번째 열만 보여주며, 이는 내 테이블이 여전히 iPhone과 iPad에서 슬라이드 오버에서 멋지게 보인다는 것을 의미합니다.

00:04:00.000 --> 00:04:03.000
당신은 이것이 외관상 목록과 비슷하다는 것을 알 수 있습니다.

00:04:03.000 --> 00:04:12.000
하지만 테이블을 목록으로 대체한 것은 아니지만, 테이블을 재사용하면 크기 클래스 간에 전환할 때 스크롤 위치와 선택을 유지할 수 있기 때문입니다.

00:04:12.000 --> 00:04:23.000
일반적으로, 컴팩트한 특정 외관을 위해 첫 번째 열을 사용하고, 슬라이드 오버와 같은 다양한 환경에서 iPad 앱을 항상 테스트해야 합니다.

00:04:23.000 --> 00:04:25.000
알았어, 계속해.

00:04:25.000 --> 00:04:28.000
편안함과 소음 수준을 위해 기둥을 추가하겠습니다.

00:04:28.000 --> 00:04:36.000
텍스트 콘텐츠만 있는 열의 경우, TableColumn은 값이 문자열을 가리킬 때 뷰 빌더를 생략할 수 있는 편리한 API를 제공합니다.

00:04:36.000 --> 00:04:42.000
그리고 이 경우, 나는 편안함 수준이 많은 공간을 필요로 하지 않을 것이라는 것을 알고 있기 때문에, 고정된 너비를 적용했다.

00:04:42.000 --> 00:04:45.000
비교기를 사용하여 테이블에 정렬을 추가할 수도 있습니다.

00:04:45.000 --> 00:04:48.000
나는 비교기를 저장할 주를 만들 것이다.

00:04:48.000 --> 00:04:53.000
여기 상태는 테이블의 모든 비교기를 나타내기 때문에 배열이다.

00:04:53.000 --> 00:05:00.000
그리고 초기 값을 이름 비교기로 설정하면 테이블이 처음 표시될 때 정렬된 것처럼 보일 수 있습니다.

00:05:00.000 --> 00:05:06.000
다음으로, 나는 모든 것을 연결하기 위해 내 상태에 대한 바인딩을 테이블에 전달할 것이다.

00:05:06.000 --> 00:05:12.000
열은 각각 비교 가능한 필드의 키 경로로 값을 지정하기 때문에 기본적으로 정렬할 수 있습니다.

00:05:12.000 --> 00:05:18.000
그리고 이제 테이블은 이름, 편안함 수준 및 소음으로 완전히 정렬할 수 있습니다.

00:05:18.000 --> 00:05:20.000
테이블은 자체적으로 정렬을 처리하지 않는다는 점에 유의하십시오.

00:05:20.000 --> 00:05:22.000
그건 나한테 달렸어.

00:05:22.000 --> 00:05:27.000
정렬 순서가 변경될 때 onChange 수정자를 사용하여 데이터를 정렬할 수 있습니다.

00:05:27.000 --> 00:05:30.000
좋아, 한 번 해 보자.

00:05:30.000 --> 00:05:37.000
그 테이블은 멋져 보이며, 모든 장소 데이터를 보여주고 실제로 더 큰 화면을 활용한다.

00:05:37.000 --> 00:05:43.000
Mac과 달리, iPad의 테이블은 수평으로 스크롤하지 않으므로, 열 수를 제한하는 것이 중요합니다.

00:05:43.000 --> 00:05:47.000
이것은 모든 열이 한 번에 표시될 수 있도록 한다.

00:05:47.000 --> 00:05:49.000
각 열은 헤더에 라벨을 보여준다.

00:05:49.000 --> 00:05:52.000
그리고 라벨을 탭하면 그 열이 정렬됩니다.

00:05:52.000 --> 00:05:57.000
나는 심지어 소음 수준별로 분류할 수 있다.

00:05:57.000 --> 00:06:03.000
그리고 슬라이드 오버에서, 테이블은 모든 정보를 더 압축된 형식으로 나타내는 단일 열로 축소된다.

00:06:03.000 --> 00:06:07.000
이제 목록을 테이블로 업데이트했으니, 선택에 뛰어들자.

00:06:07.000 --> 00:06:14.000
이 섹션에서는 SwiftUI 선택 모델을 검토하고 선택과 메뉴를 통합하는 것에 대해 논의할 것입니다.

00:06:14.000 --> 00:06:18.000
그 과정에서, 나는 풍부한 기능으로 장소 테이블을 과급할 것이다.

00:06:18.000 --> 00:06:22.000
하지만 먼저, 저는 SwiftUI에서 선택이 어떻게 작동하는지에 대해 이야기하겠습니다.

00:06:22.000 --> 00:06:27.000
SwiftUI에는 목록과 테이블 선택을 관리하기 위한 강력한 API가 포함되어 있습니다.

00:06:27.000 --> 00:06:30.000
여기 몇 개의 행이 포함된 목록이 있는 다이어그램이 있습니다.

00:06:30.000 --> 00:06:32.000
각 줄에는 태그가 있다.

00:06:32.000 --> 00:06:37.000
이 태그는 목록이 선택을 관리하는 데 도움이 되는 각 행의 고유한 값입니다.

00:06:37.000 --> 00:06:41.000
이 다이어그램에서, 태그는 녹색 원으로 표시됩니다.

00:06:41.000 --> 00:06:45.000
태그와 함께, 선택을 유지하는 몇 가지 상태도 있다.

00:06:45.000 --> 00:06:48.000
이것은 태그 값을 보유하는 유형이다.

00:06:48.000 --> 00:06:54.000
예를 들어, 다중 선택의 경우, 이것은 선택된 각 행의 태그를 보유하는 세트입니다.

00:06:54.000 --> 00:06:58.000
목록의 작업은 각 행의 태그와 선택 상태 사이를 조정하는 것이다.

00:06:58.000 --> 00:07:02.000
그리고 그것은 선택 바인딩을 통해 이것을 한다.

00:07:02.000 --> 00:07:09.000
따라서 두 번째 행과 같은 행이 선택되면, 목록은 선택 바인딩을 통해 세트에 추가합니다.

00:07:09.000 --> 00:07:20.000
그리고 마찬가지로, 앱의 다른 부분이 프로그래밍 방식으로 세트를 변경하면, 여기에 표시된 것처럼 세 개를 추가하면, 선택 바인딩이 변경되기 때문에 목록이 선택합니다.

00:07:20.000 --> 00:07:24.000
이 일반 모델은 iOS와 macOS에서 동일합니다.

00:07:24.000 --> 00:07:29.000
그래서 선택에는 두 부분이 있다: 태그와 일부 상태.

00:07:29.000 --> 00:07:32.000
다음으로, 저는 태그가 어디에서 왔는지에 대해 이야기하고 싶습니다.

00:07:32.000 --> 00:07:40.000
태그는 해당 뷰가 선택되었는지 여부를 추적하는 데 사용되는 선택 가능한 컨테이너의 뷰 값일 뿐입니다.

00:07:40.000 --> 00:07:45.000
많은 경우, SwiftUI는 당신을 대신하여 태그를 자동으로 합성할 수 있습니다.

00:07:45.000 --> 00:07:49.000
태그는 식별자와 비슷하지만, 완전히 같지는 않다.

00:07:49.000 --> 00:07:55.000
ForEach를 사용할 때, SwiftUI는 명시적인 ID에서 뷰에 대한 태그를 자동으로 파생합니다.

00:07:55.000 --> 00:08:00.000
그리고 테이블은 행 값의 식별자를 선택 태그로 사용할 것이다.

00:08:00.000 --> 00:08:04.000
장소 앱에서, 그것은 장소 구조체의 식별자 유형이 사용될 것이라는 것을 의미합니다.

00:08:04.000 --> 00:08:11.000
명시적인 신원에 대한 자세한 내용은 "SwiftUI의 신비화"를 확인하세요.

00:08:11.000 --> 00:08:14.000
뷰를 수동으로 태그하려면, 태그 수정자를 사용하세요.

00:08:14.000 --> 00:08:16.000
이것이 ForEach가 후드 아래에서 하는 일이다.

00:08:16.000 --> 00:08:19.000
태그 수정자는 해시블 값을 취한다.

00:08:19.000 --> 00:08:27.000
그러나 태그 수정자를 사용할 때 주의하십시오. 선택 가능한 컨테이너의 모든 뷰가 동일한 태그 유형을 공유하는 것이 중요합니다.

00:08:27.000 --> 00:08:31.000
그렇지 않으면, SwiftUI는 보기를 선택하는 방법을 모를 수도 있다.

00:08:31.000 --> 00:08:35.000
ID 수정자를 사용하면 태그가 설정되지 않는다는 점에 유의하십시오.

00:08:35.000 --> 00:08:40.000
그래서 그것은 태그의 개요이다. 이전 다이어그램을 다시 가져오자.

00:08:40.000 --> 00:08:47.000
이제 이 다이어그램의 태그 부분을 설명했으므로, 선택 방정식의 나머지 절반인 선택 상태에 초점을 맞추고 싶습니다.

00:08:47.000 --> 00:08:52.000
이전 예시에서, 나는 세트를 사용했지만, 다른 옵션도 있다.

00:08:52.000 --> 00:08:56.000
이러한 데이터 구조를 사용하여 선택을 나타낼 수 있습니다.

00:08:56.000 --> 00:09:06.000
SwiftUI는 단일 선택, macOS Ventura의 새로운 기능, macOS 사이드바의 필수 선택 및 다중 선택을 지원합니다.

00:09:06.000 --> 00:09:11.000
iPadOS 16은 또한 가벼운 다중 선택을 도입한다.

00:09:11.000 --> 00:09:18.000
이제 키보드가 부착되어 있으므로 여러 행을 선택하기 위해 편집 모드로 들어갈 필요가 없어 양식을 피할 수 있습니다.

00:09:18.000 --> 00:09:24.000
키보드를 사용할 때, 시프트 및 명령과 같은 일반적인 단축키를 사용하여 선택을 확장하고 수정할 수 있습니다.

00:09:24.000 --> 00:09:26.000
그리고 이것은 포인터와 잘 작동한다.

00:09:26.000 --> 00:09:29.000
선택을 채택한 후 장소 테이블은 다음과 같습니다.

00:09:29.000 --> 00:09:36.000
이 예에서는 키보드와 트랙패드가 부착되어 있으므로 행이 들여쓰기되지 않았지만 여전히 선택되어 있습니다.

00:09:36.000 --> 00:09:42.000
그러나, 터치를 사용할 때, 나는 여전히 두 손가락 팬을 사용하여 가속화되는 편집 모드로 들어가야 할 것이다.

00:09:42.000 --> 00:09:45.000
SwiftUI는 이 제스처를 자동으로 지원합니다.

00:09:45.000 --> 00:09:50.000
편집 모드에 대해 말하자면, 단일 선택과 편집 모드로 몇 가지 업데이트가 있습니다.

00:09:50.000 --> 00:09:56.000
iOS 16에서 iPhone과 iPad의 목록 선택은 더 이상 단일 행을 선택할 때 편집 모드가 필요하지 않습니다.

00:09:56.000 --> 00:10:01.000
그리고 이것은 업데이트된 내비게이션 API와 조정하는 데 매우 유용합니다.

00:10:01.000 --> 00:10:08.000
이 모든 업데이트를 통해 편집 모드를 위한 새 열을 추가하여 이전 테이블을 기반으로 하는 이 테이블로 우리를 데려옵니다.

00:10:08.000 --> 00:10:12.000
편집 모드는 키보드 없이 다중 선택을 사용할 때만 필요합니다.

00:10:12.000 --> 00:10:16.000
그래서 그것으로, 나는 선택을 지원하기 위해 장소 테이블을 업데이트할 것이다.

00:10:16.000 --> 00:10:22.000
선택을 저장하기 위해 상태를 추가하여 장소 테이블에 선택을 쉽게 추가할 수 있습니다.

00:10:22.000 --> 00:10:27.000
상태를 만든 후, 나는 테이블의 이니셜라이저에 바인딩을 전달할 것이다.

00:10:27.000 --> 00:10:34.000
테이블은 선택 유형이 행 식별자와 일치하도록 강제하므로, 저는 장소 ID 유형을 선택 유형으로 사용했습니다.

00:10:34.000 --> 00:10:38.000
나는 다중 선택을 원하기 때문에, 선택 상태에 대한 세트를 사용했다.

00:10:38.000 --> 00:10:44.000
테이블은 자동으로 행을 태그하기 때문에, 내가 직접 아무것도 태그할 필요가 없다.

00:10:44.000 --> 00:10:46.000
그리고 이제 표에서 행을 선택할 수 있습니다.

00:10:46.000 --> 00:10:49.000
하지만 나는 그 선택에 대해 정말 아무것도 하지 않았어.

00:10:49.000 --> 00:10:56.000
내 북클럽에서 다른 사람들과 공유할 수 있는 가이드에 선택한 장소를 추가할 수 있는 버튼을 추가하는 것이 좋을 것 같아.

00:10:56.000 --> 00:10:59.000
이것은 도구 모음 버튼을 추가하는 코드입니다.

00:10:59.000 --> 00:11:03.000
비어 있지 않은 선택이 있다면, 이제 버튼이 나타날 것이다.

00:11:03.000 --> 00:11:12.000
또한 기존의 경량 선택 지원을 보완하는 편집 버튼을 추가했지만, 키보드가 없을 때 편집 모드로 들어가고 종료할 수 있는 이점을 제공합니다.

00:11:12.000 --> 00:11:21.000
좋은 iPad 앱은 키보드 유무에 관계없이 모두 빛나므로, 편집 모드로 들어가고 종료할 수 있는 컨트롤을 제공하는 것이 중요합니다.

00:11:21.000 --> 00:11:22.000
우리는 거기에 가고 있어.

00:11:22.000 --> 00:11:28.000
이제 행을 선택할 때 나타나는 버튼과 편집 모드로 들어가고 종료하는 버튼이 있습니다.

00:11:28.000 --> 00:11:33.000
도구 모음에 대한 자세한 내용은 이 시리즈의 두 번째 세션을 꼭 보세요.

00:11:33.000 --> 00:11:36.000
나는 여기 도구 모음 버튼에 꽤 만족하지만, 우리는 더 많은 것을 할 수 있다.

00:11:36.000 --> 00:11:41.000
선택에 대한 행동의 경우, 가능한 한 쉽게 접근할 수 있도록 하는 것이 좋습니다.

00:11:41.000 --> 00:11:50.000
이것이 iOS 16, iPadOS 16 및 macOS Ventura에서 SwiftUI가 다중 선택 컨텍스트 메뉴에 대한 지원을 추가하는 이유입니다.

00:11:50.000 --> 00:11:57.000
다중 선택 컨텍스트 메뉴를 사용하면 선택한 식별자 세트에서 작동하는 컨텍스트 메뉴를 표시할 수 있습니다.

00:11:57.000 --> 00:12:02.000
더 많은 것을 이해하기 위해 이 테이블의 해부학을 살펴봅시다.

00:12:02.000 --> 00:12:05.000
항목 기반 컨텍스트 메뉴에는 세 가지 변형이 있다.

00:12:05.000 --> 00:12:10.000
먼저, 상단의 선택과 같은 여러 항목에 메뉴를 표시할 수 있습니다.

00:12:10.000 --> 00:12:15.000
개별 항목에 상황에 맞는 메뉴를 표시할 수도 있습니다.

00:12:15.000 --> 00:12:21.000
그리고 마지막으로, 콘텐츠가 없는 빈 영역에 상황에 맞는 메뉴를 표시할 수 있습니다.

00:12:21.000 --> 00:12:25.000
우리 장소 테이블에 이것에 대한 지원을 추가합시다.

00:12:25.000 --> 00:12:30.000
컨텍스트 메뉴에 집중할 수 있도록 이전 코드 예제에서 몇 가지 세부 사항을 생략했습니다.

00:12:30.000 --> 00:12:34.000
선택 유형을 취하는 새로운 컨텍스트 메뉴 수정자를 추가했습니다.

00:12:34.000 --> 00:12:43.000
이것은 목록이나 테이블의 선택 유형과 일치해야 하므로, 테이블을 사용하고 있기 때문에 PlaceID 유형을 사용할 것입니다.

00:12:43.000 --> 00:12:49.000
폐쇄는 행동할 항목 세트가 전달되므로, 비어 있다면, 메뉴가 빈 영역을 위한 것이라는 것을 알고 있습니다.

00:12:49.000 --> 00:12:52.000
나는 새로운 장소를 추가하는 버튼이 빈 공간에 잘 어울릴 것이라고 생각한다.

00:12:52.000 --> 00:12:58.000
그렇게 하면, 내가 이동 중에 읽을 수 있는 새로운 조용한 장소를 찾을 때, 나는 그것을 빠르게 추가할 수 있다.

00:12:58.000 --> 00:13:05.000
빈 항목 세트의 뷰 빌더가 뷰로 해결되지 않으면, SwiftUI는 빈 영역에 메뉴를 표시하지 않습니다.

00:13:05.000 --> 00:13:08.000
다음으로, 단일 선택을 처리해 봅시다.

00:13:08.000 --> 00:13:13.000
세트에 단 하나의 항목만 있다면, 나는 메뉴가 한 장소에 표시되고 있다는 것을 알고 있다.

00:13:13.000 --> 00:13:21.000
그리고 단일 및 다중 선택 모두에 대해, 저는 이 장소들을 가이드에 추가하고 싶기 때문에, 메뉴에 다른 보기를 추가할 것입니다.

00:13:21.000 --> 00:13:23.000
우리의 진행 상황을 확인해 봅시다.

00:13:23.000 --> 00:13:25.000
여기 작동하는 새로운 컨텍스트 메뉴 지원이 있습니다.

00:13:25.000 --> 00:13:29.000
빈 영역을 클릭하면 새 장소를 추가할 수 있는 메뉴 항목이 표시됩니다.

00:13:29.000 --> 00:13:33.000
단일 행을 선택하면 해당 행에 대한 상황에 맞는 메뉴가 표시됩니다.

00:13:33.000 --> 00:13:38.000
그리고 키보드로 선택을 확장하여 이 파란색 하이라이트를 만들 수 있습니다.

00:13:38.000 --> 00:13:45.000
그런 다음 여러 행에서 컨텍스트 메뉴를 활성화하여 가이드에 장소를 쉽게 추가할 수 있습니다.

00:13:45.000 --> 00:13:50.000
이 테이블은 지금 꽤 멋져 보여, 그래서 나는 그 주위에 구조를 추가할 때가 된 것 같아.

00:13:50.000 --> 00:13:52.000
그렇게 하려면, 나는 분할 보기가 필요할 것이다.

00:13:52.000 --> 00:13:55.000
내비게이션은 아이패드 경험의 근본적인 부분이다.

00:13:55.000 --> 00:14:04.000
그리고 분할 뷰는 드릴 뚫을 필요 없이 한 번에 더 많은 정보를 보여줌으로써 iPad의 더 큰 디스플레이에서 양식을 피할 수 있는 좋은 방법입니다.

00:14:04.000 --> 00:14:09.000
이 섹션에서는 탐색 및 분할 보기에 대한 SwiftUI에 대한 몇 가지 업데이트를 다룰 것입니다.

00:14:09.000 --> 00:14:16.000
이전 섹션에서는 장소 테이블을 만들고 선택 및 편집 모드와 같은 풍부한 기능을 추가했습니다.

00:14:16.000 --> 00:14:18.000
하지만 나는 장소 앱이 약간의 구조가 부족하다고 생각한다.

00:14:18.000 --> 00:14:25.000
그래서 이 섹션에서는 내비게이션 분할 보기를 활용하여 앱 구조의 기초를 구축할 것입니다.

00:14:25.000 --> 00:14:32.000
iPadOS 16과 macOS Ventura의 새로운 기능인 SwiftUI는 NavigationSplitView 유형의 분할 보기에 대한 지원을 개선했습니다.

00:14:32.000 --> 00:14:41.000
SwiftUI는 두 개 또는 세 개의 열 분할 보기를 지원하며 열이 표시되는 방식을 복잡하게 제어할 수 있는 여러 스타일이 있습니다.

00:14:41.000 --> 00:14:48.000
저는 이 세션에서 내비게이션 콘텐츠를 제시하는 방법을 완전히 다루지 않을 것이므로, 내비게이션을 위한 SwiftUI 요리책을 확인하도록 초대합니다.

00:14:48.000 --> 00:14:53.000
커트는 정말 맛있는 내비게이션 경험을 요리하기 위한 꽤 많은 레시피를 가지고 있다.

00:14:53.000 --> 00:14:56.000
대신, 나는 분할된 견해에 더 집중할 것이다.

00:14:56.000 --> 00:15:00.000
여기 iPad의 두 열 분할 보기를 보여주는 다이어그램이 있습니다.

00:15:00.000 --> 00:15:07.000
SwiftUI에서 선행 열은 사이드바 열이라고 하고 후행 열은 세부 열이라고 합니다.

00:15:07.000 --> 00:15:10.000
여기서 기둥들이 서로 어떻게 균형을 이루는지 주목하세요.

00:15:10.000 --> 00:15:13.000
풍경에서, SwiftUI는 기본적으로 이것을 제공한다.

00:15:13.000 --> 00:15:19.000
그러나 초상화에서 사이드바는 세부 사항 열만 보여주며 방해가 되지 않는다.

00:15:19.000 --> 00:15:27.000
사이드바 버튼을 탭하면 세부 사항 열 위에 나타나는 사이드바가 표시되며, 아래에서 흐리게 표시됩니다.

00:15:27.000 --> 00:15:37.000
일반적으로, 두 열 분할 보기는 공간이 제한될 때 세부 열만 표시하는 것을 선호합니다. 왜냐하면 세부 열은 종종 사이드바 열보다 더 중요한 정보를 보여주기 때문입니다.

00:15:37.000 --> 00:15:48.000
이 동작을 사용자 정의하려면, 항상 눈에 띄는 세부 사항 탐색 분할 보기 스타일로 세부 열을 선호하거나 균형 잡힌 NavigationSplitView 스타일로 가중치의 균형을 맞출 수 있습니다.

00:15:48.000 --> 00:15:53.000
NavigationSplitView는 또한 세 개의 열 레이아웃을 지원합니다.

00:15:53.000 --> 00:15:59.000
세 개의 열로, 사이드바와 콘텐츠 열이라고 불리는 세부 사항 사이에 추가 열이 있습니다.

00:15:59.000 --> 00:16:02.000
UIKit에서 왔다면, 이것을 보충 열로 알 수 있습니다.

00:16:02.000 --> 00:16:09.000
가로에서, 내용과 세부 사항 열이 표시되고, 사이드바를 전환할 수 있습니다.

00:16:09.000 --> 00:16:16.000
도구 모음 버튼을 탭한 후, 세부 사항 열이 미끄러져 사이드바와 콘텐츠를 위한 공간을 만듭니다.

00:16:16.000 --> 00:16:23.000
세로에서는 세부 사항 열만 표시되며, 도구 모음 버튼을 탭하면 내용이 표시됩니다.

00:16:23.000 --> 00:16:26.000
거기에서, 다시 탭하면 사이드바가 표시됩니다.

00:16:26.000 --> 00:16:31.000
사이드바와 콘텐츠는 모두 세부 사항을 오버레이한다.

00:16:31.000 --> 00:16:40.000
일반적으로, 사용 가능한 공간을 최대한 활용하고 더 큰 디스플레이에 특화되어 있기 때문에 세 개의 열 분할 보기에 대한 자동 스타일을 고수하는 것이 좋습니다.

00:16:40.000 --> 00:16:46.000
두 열 분할 보기와 마찬가지로, 세 열 분할 보기는 컴팩트한 크기 클래스의 스택으로 축소됩니다.

00:16:46.000 --> 00:16:51.000
이제 분할 뷰의 기본 사항을 다뤘으니, 장소 앱에 하나를 추가할 때입니다.

00:16:51.000 --> 00:16:53.000
여기 콘텐츠 보기가 있습니다.

00:16:53.000 --> 00:16:56.000
저는 여기에 두 개의 열이 있는 NavigationSplitView를 만들었습니다.

00:16:56.000 --> 00:17:00.000
첫 번째 열은 사이드바 열이고 두 번째 열은 세부 열이다.

00:17:00.000 --> 00:17:10.000
세부 열은 사이드바 열의 링크로 채워지지만, 아무것도 표시되지 않으면 "장소 선택"이 있는 자리 표시자가 대신 표시됩니다.

00:17:10.000 --> 00:17:13.000
여기 자리 표시자의 스크린샷이 있습니다. 꽤 훌륭해.

00:17:13.000 --> 00:17:20.000
이것은 가로로 사이드바를 보여주는 자동 스타일을 사용하여 초상화에서 숨기고 있다.

00:17:20.000 --> 00:17:24.000
사이드바의 행을 탭하면 세부 열에서 해당 행이 표시됩니다.

00:17:24.000 --> 00:17:28.000
그리고 슬라이드 오버를 사용할 때, 열은 자동으로 무너진다.

00:17:28.000 --> 00:17:38.000
이것은 빙산의 일각에 불과합니다. 국가 복원, 딥 링크, 심지어 더 풍부한 프로그래밍 제어에 대한 더 나은 지원을 포함하여 많은 흥미로운 내비게이션 추가 사항이 있습니다.

00:17:38.000 --> 00:17:44.000
다시 한 번, 더 많은 것을 위해 내비게이션 요리책 세션을 확인해 보시기 바랍니다.

00:17:44.000 --> 00:17:50.000
저는 앱에 멋진 iPad 기능을 구축했고, 읽을 수 있는 평화로운 장소를 찾게 되어 기쁩니다.

00:17:50.000 --> 00:17:53.000
바라건대 나는 곧 내 북클럽을 따라잡을 수 있을 거야.

00:17:53.000 --> 00:18:05.000
이 세션에서, 저는 풍부한 데이터 표시를 위해 테이블을 활용하는 방법, 정교한 선택 상호 작용을 관리하는 방법, 분할 뷰로 양식을 피하는 방법을 다루었습니다.

00:18:05.000 --> 00:18:11.000
관련 세션을 확인하고 SwiftUI 앱을 개선하여 iPad의 힘을 활용하세요.

00:18:11.000 --> 00:18:13.000
고마워.

00:18:13.000 --> 23:59:59.000
♪ ♪

