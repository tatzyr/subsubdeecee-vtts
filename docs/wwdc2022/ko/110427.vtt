WEBVTT

00:00:00.000 --> 00:00:02.000
♪ 기악 힙합 음악 ♪

00:00:02.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:12.000
안녕하세요, 여러분. 저는 조나단 마입니다.

00:00:12.000 --> 00:00:13.000
그리고 저는 리사 샤오입니다.

00:00:13.000 --> 00:00:17.000
그리고 우리는 당신에게 Xcode 14의 새로운 기능을 소개하고 싶습니다.

00:00:17.000 --> 00:00:28.000
오늘, 우리는 소스 편집 및 SwiftUI 미리보기, 멀티 플랫폼 애플리케이션, TestFlight 피드백 및 성능 개선을 포함하여 Xcode 전반에 걸쳐 새로운 기능과 개선 사항을 살펴볼 것입니다.

00:00:28.000 --> 00:00:31.000
다뤄야 할 게 많으니까, 그렇게 하자.

00:00:31.000 --> 00:00:34.000
당신이 가장 먼저 알아차릴 것은 그것이 얼마나 빨리 시작되고 있는지입니다.

00:00:34.000 --> 00:00:37.000
Xcode 14는 30% 더 작다.

00:00:37.000 --> 00:00:40.000
그것은 훨씬 더 빨리 다운로드하고 설치한다.

00:00:40.000 --> 00:00:44.000
필요에 따라 추가 플랫폼과 시뮬레이터를 다운로드할 수 있습니다.

00:00:44.000 --> 00:00:51.000
만약 당신이 그것들을 즉시 필요로 한다면, 당신은 그것들을 여기에서 얻을 수 있습니다 -- 또는 나중에, 당신이 그것들을 처음 사용하려고 할 때.

00:00:51.000 --> 00:00:58.000
우리는 음식 배달 응용 프로그램인 푸드 트럭을 만들고 있습니다.

00:00:58.000 --> 00:01:03.000
라이브 미리보기가 있는 SwiftUI는 훌륭한 워크플로우이며, 점점 더 좋아지고 있다.

00:01:03.000 --> 00:01:10.000
이제 미리보기 캔버스는 기본적으로 상호 작용하므로, 변경 사항은 즉시 실행됩니다.

00:01:10.000 --> 00:01:16.000
캔버스에는 코드를 작성하지 않고도 각 미리보기의 추가 변형을 만들 수 있는 새로운 컨트롤이 있습니다.

00:01:16.000 --> 00:01:24.000
색 구성표, 텍스트 크기 또는 장치 방향을 변경한 다음 각 시나리오에서 렌더링된 인터페이스를 즉시 볼 수 있습니다.

00:01:24.000 --> 00:01:37.000
우리의 관점이 다른 동적 유형 크기로 어떻게 보이는지 봅시다.

00:01:37.000 --> 00:01:43.000
이러한 미리보기를 나란히 사용하면 인터페이스를 쉽게 검증하고 올바르게 보이는지 확인할 수 있습니다.

00:01:43.000 --> 00:01:51.000
더 큰 사이즈를 확인해 봅시다.

00:01:51.000 --> 00:01:56.000
첫 번째 아이콘은 매우 넓고 텍스트를 어색하게 감싸게 한다.

00:01:56.000 --> 00:02:00.000
운 좋게도, 내 디자이너가 방금 나에게 그것을 바꾸라고 요청했지만, 헤더에서만.

00:02:00.000 --> 00:02:07.000
CardView는 아직 헤더에 대한 다른 아이콘을 지원하지 않으므로, 그 기능을 추가하는 것으로 시작합시다.

00:02:07.000 --> 00:02:15.000
나는 실행으로 전환할 것이다.

00:02:15.000 --> 00:02:22.000
헤더와 콘텐츠 요소는 둘 다 같은 이미지를 사용한다.

00:02:22.000 --> 00:02:36.000
헤더를 위해 특별히 다른 이미지 속성을 추가해 봅시다.

00:02:36.000 --> 00:02:41.000
대부분의 카드에서, 두 장소 모두에서 같은 이미지를 사용하는 것은 멋져 보인다.

00:02:41.000 --> 00:02:53.000
기본값으로 사용자 지정 이니셜라이저를 추가하여 각 기존 호출을 업데이트하는 시간을 절약할 수 있습니다.

00:02:53.000 --> 00:02:59.000
이니셜라이저를 입력하기 시작할 때, Xcode 14는 이제 모든 것을 완료할 수 있도록 제공합니다!

00:02:59.000 --> 00:03:07.000
기본값을 사용자 지정의 시작점으로 받아들일 수 있어 많은 시간을 절약할 수 있습니다.

00:03:07.000 --> 00:03:10.000
이것은 또한 성문화 가능한 방법에서도 작동한다.

00:03:10.000 --> 00:03:24.000
headerIcon 매개 변수에 기본값을 부여합시다.

00:03:24.000 --> 00:03:36.000
이제, 우리는 CardStack 보기로 돌아가서 이 새로운 기능을 사용할 것입니다.

00:03:36.000 --> 00:03:39.000
내 디자이너는 나에게 여기서 달력 기호를 사용하라고 요청했다.

00:03:39.000 --> 00:03:54.000
도서관에는 이제 모든 SF 심볼이 포함되어 있으므로, 내가 올바른 것을 사용하고 있는지 확인하는 것은 쉽다.

00:03:54.000 --> 00:04:06.000
Return을 눌러 기호를 사용할 올바른 코드를 삽입할 수 있습니다.

00:04:06.000 --> 00:04:08.000
이 상징은 멋져 보여.

00:04:08.000 --> 00:04:17.000
미리보기 변형에서 얻은 새로운 나란히 비교를 통해 사용자가 선택한 모든 설정으로 앱이 잘 보이도록 쉽게 할 수 있습니다.

00:04:17.000 --> 00:04:26.000
이니셜라이저와 코다블 정의 외에도, Xcode 14는 더 지능적인 권장 사항을 제공하므로 아이디어를 더 빠르고 쉽게 작성할 수 있습니다.

00:04:26.000 --> 00:04:33.000
내가 좀 더 보여줄게.

00:04:33.000 --> 00:04:43.000
다른 CardView를 추가하기 시작하면, 이니셜라이저는 이제 완료 목록에 직접 나타납니다.

00:04:43.000 --> 00:04:45.000
headerIcon 매개 변수는 이탤릭체로 되어 있다.

00:04:45.000 --> 00:04:48.000
그것은 기본값을 가지고 있기 때문이다.

00:04:48.000 --> 00:04:55.000
내가 지금 완료를 수락한다면, 그것은 headerIcon 라벨을 포함하지 않을 것이며, 우리가 방금 추가한 기본값을 사용할 것이다.

00:04:55.000 --> 00:05:03.000
여기서, 저는 아이콘을 다시 전문화하고 싶습니다, 그래서 옵트인할 이름의 일부를 입력할 수 있습니다.

00:05:03.000 --> 00:05:14.000
내 새 카드에 몇 가지 값을 줄게.

00:05:14.000 --> 00:05:17.000
새 카드 앞에 디바이더를 원합니다.

00:05:17.000 --> 00:05:29.000
VStack에 디바이더를 추가하면 전체 너비에 걸쳐 선이 됩니다.

00:05:29.000 --> 00:05:36.000
더 미묘하게 만들기 위해, 나는 프레임을 사용하여 최대 너비를 설정할 것이다.

00:05:36.000 --> 00:05:40.000
프레임 수정자는 많은 선택적 인수를 가지고 있다.

00:05:40.000 --> 00:05:51.000
새로운 완성 기능은 내가 필요한 논쟁만 쉽게 얻을 수 있게 해준다.

00:05:51.000 --> 00:05:54.000
그것은 Xcode 14의 코드 완성이다.

00:05:54.000 --> 00:05:57.000
이 첫 번째 카드의 제목은 방법에서 비롯되었다.

00:05:57.000 --> 00:06:01.000
나는 그것이 모든 숫자를 올바르게 처리하지 않는다고 들었으니, 그것이 어떻게 구현되는지 봅시다.

00:06:01.000 --> 00:06:11.000
Command-클릭하고 Jump to Definition을 선택하겠습니다.

00:06:11.000 --> 00:06:17.000
재설계된 정의 목록은 각 결과에 대해 다른 점을 강조하여 원하는 것을 빠르게 선택할 수 있습니다.

00:06:17.000 --> 00:06:22.000
우리의 텍스트(for:) 방법은 프로토콜에서 나온 것이기 때문에, 여러 옵션이 있습니다.

00:06:22.000 --> 00:06:29.000
이 목록은 방법을 정의하는 특정 유형을 보여줍니다: 우리는 프로토콜의 선언과 두 가지 구현을 가지고 있습니다.

00:06:29.000 --> 00:06:36.000
나는 서버 기반 구현으로 이동할 것이다.

00:06:36.000 --> 00:06:44.000
이 클래스는 Swift 5.7의 새로운 정규 표현식 리터럴을 사용하여 구문 분석을 구현합니다.

00:06:44.000 --> 00:06:48.000
내 동료는 그 문제가 우리의 단위 테스트에 의해 포착되고 있다고 말했다.

00:06:48.000 --> 00:07:02.000
지금 그것들을 실행하자.

00:07:02.000 --> 00:07:03.000
응, 우리는 몇 가지 실패가 있어.

00:07:03.000 --> 00:07:09.000
한 번 보자.

00:07:09.000 --> 00:07:12.000
이벤트 수를 추출하는 데 문제가 있는 것 같다.

00:07:12.000 --> 00:07:15.000
이 함수가 어떻게 호출되는지 확인해 봅시다.

00:07:15.000 --> 00:07:20.000
Command-clicking으로 이 방법의 호출자를 열면 직접 볼 수 있습니다.

00:07:20.000 --> 00:07:38.000
정의 목록과 마찬가지로, 호출자 목록은 각 호출 사이트의 미리보기와 함께 이 메서드에 대한 호출을 포함하는 다양한 파일과 기능을 보여줍니다.

00:07:38.000 --> 00:07:40.000
여기 실패한 테스트 방법의 전화가 있습니다.

00:07:40.000 --> 00:07:47.000
미리보기는 테스트가 "0 레코드" 문자열을 통과하고 있다는 것을 보여주며, 이는 문제에 대한 힌트를 준다.

00:07:47.000 --> 00:07:55.000
그리고 이제 나는 버그를 발견할 수 있다: 정규 표현식은 숫자 1-9와 일치하지만, 나는 0을 포함하는 것을 잊었다!

00:07:55.000 --> 00:08:11.000
0-9를 사용하도록 문자 범위를 업데이트하거나 더 설명적인 숫자 문자 클래스로 전환하여 이 문제를 해결할 수 있습니다.

00:08:11.000 --> 00:08:16.000
뭔가가 여전히 옳지 않지만, 이제 컴파일러가 그 이유를 말해주고 있다.

00:08:16.000 --> 00:08:20.000
정규 표현식은 스위프트 5.7의 일류 기능이다.

00:08:20.000 --> 00:08:26.000
컴파일러는 다른 코드와 마찬가지로 내 정규식을 확인하고, Xcode는 내 오타를 즉시 강조한다.

00:08:26.000 --> 00:08:41.000
내가 표현식을 수정할 때, 두 가지 일이 일어난다는 것을 알아두세요: 정규 표현식의 구문 강조 표시는 내 편집을 확인하고, 오류는 회색을 어둡게 합니다.

00:08:41.000 --> 00:08:45.000
이 새로운 디밍은 Xcode가 진단을 재평가하고 있음을 보여준다.

00:08:45.000 --> 00:08:52.000
잠시 일시 중지하면 파일이 재처리되고 Xcode는 오류가 해결되었는지 확인합니다.

00:08:52.000 --> 00:09:02.000
이 디밍은 긴 빌드 중에도 발생하므로, 어떤 문제가 최신 빌드에서 발생하고 어떤 문제가 이전 빌드에서 발생했는지 쉽게 알 수 있습니다.

00:09:02.000 --> 00:09:15.000
시험 보러 가자.

00:09:15.000 --> 00:09:19.000
이것은 나를 시험 방법의 한가운데에 있는 전화에 바로 뛰어들었다.

00:09:19.000 --> 00:09:21.000
편집자의 상단을 보세요.

00:09:21.000 --> 00:09:32.000
Xcode 14는 시야에서 스크롤된 경우에도 보이는 코드가 포함된 정의를 보여줍니다.

00:09:32.000 --> 00:09:44.000
나는 테스트를 재실행하기 위해 상단의 테스트 다이아몬드를 사용할 수 있다.

00:09:44.000 --> 00:09:49.000
굉장해, 그 수정은 모든 테스트를 통과해.

00:09:49.000 --> 00:10:02.000
Xcode 14를 사용하면 새로운 코드 완성으로 코드를 더 빠르게 작성하고, SwiftUI 미리보기 변형으로 유동적으로 설계하고, 향상된 오류 프레젠테이션으로 더 많은 정보를 얻고, 정의로 점프하여 자신 있게 탐색할 수 있습니다.

00:10:02.000 --> 00:10:04.000
그리고 훨씬 더 있어. 여기 리사야.

00:10:04.000 --> 00:10:05.000
고마워, 조나단.

00:10:05.000 --> 00:10:10.000
빌드 성능 개선을 살펴봅시다.

00:10:10.000 --> 00:10:20.000
Xcode가 프레임워크와 애플리케이션과 같은 여러 대상을 구축할 때, 먼저 프레임워크 소스를 컴파일합니다.

00:10:20.000 --> 00:10:23.000
그런 다음 모듈을 생성합니다.

00:10:23.000 --> 00:10:27.000
그것은 애플리케이션 소스를 연결하고 컴파일할 수 있게 해준다.

00:10:27.000 --> 00:10:31.000
그리고 나서 그것은 애플리케이션을 연결하여 빌드를 완료합니다.

00:10:31.000 --> 00:10:36.000
Xcode 14는 향상된 병렬 처리를 위해 빌드를 재정렬합니다.

00:10:36.000 --> 00:10:44.000
Swift 모듈을 열심히 생산함으로써, Xcode는 빌드 작업을 차단 해제하고 병렬성을 증가시킨다.

00:10:44.000 --> 00:10:53.000
그것은 기계의 동시 사용을 더 존중하면서 빌드의 모든 중요한 경로를 단축합니다.

00:10:53.000 --> 00:10:55.000
하지만 우리는 거기서 멈추지 않았어.

00:10:55.000 --> 00:11:00.000
우리는 또한 증가된 병렬 처리를 통해 링커를 최대 두 배 더 빠르게 만들었다.

00:11:00.000 --> 00:11:12.000
모두 함께, Xcode 14는 최대 25% 더 빠르게 프로젝트를 구축하며, 가장 많은 코어를 가진 기계가 가장 큰 개선을 볼 수 있습니다.

00:11:12.000 --> 00:11:21.000
스케줄링을 구축하기 위한 개선에도 불구하고, 때때로 당신의 프로젝트는 긴 동기 작업에 대한 내부 의존성을 가질 수 있습니다.

00:11:21.000 --> 00:11:27.000
시각화 없이는 이것이 일어나고 있다고 말하기 어려울 수 있다.

00:11:27.000 --> 00:11:31.000
좋은 소식입니다, 우리는 그것을 Xcode 14에 포함시켰습니다!

00:11:31.000 --> 00:11:36.000
빌드 로그 또는 결과 번들에서 새 빌드 타임라인을 열 수 있습니다.

00:11:36.000 --> 00:11:42.000
그것은 당신이 예기치 않게 긴 작업과 병목 현상을 식별하는 데 도움이 될 것입니다.

00:11:42.000 --> 00:11:44.000
여기 푸드 트럭의 빌드 타임라인이 있습니다.

00:11:44.000 --> 00:11:49.000
나는 빌드를 단일 코어로 제한하는 스크립트 단계를 볼 수 있다.

00:11:49.000 --> 00:11:57.000
새로운 빌드 타임라인을 통해 중요한 통찰력을 얻고 빌드에서 성과 기회를 식별할 수 있습니다.

00:11:57.000 --> 00:12:10.000
"Xcode 빌드에서 병렬화" 및 "빠른 링크: 빌드 및 실행 개선"에서 병렬화 빌드, 새로운 빌드 타임라인 및 링크에 대한 모든 것을 배울 수 있습니다.

00:12:10.000 --> 00:12:16.000
Xcode의 병렬 테스트는 테스트를 더 빨리 실행할 수 있는 좋은 방법이었습니다.

00:12:16.000 --> 00:12:19.000
Xcode 14에서는 훨씬 더 낫다.

00:12:19.000 --> 00:12:25.000
우리는 내가 방금 보여준 빌드 성능을 개선하기 위해 같은 기술을 사용했다.

00:12:25.000 --> 00:12:34.000
Xcode 14는 테스트 중에 병렬성을 높이기 위해 대상과 테스트 클래스 간의 스케줄링 종속성을 제거합니다.

00:12:34.000 --> 00:12:45.000
다른 테스트 클래스와 대상에서 장기 실행 테스트가 있는 경우, 이 기능은 테스트 실행 시간을 최대 30%까지 향상시킬 수 있습니다.

00:12:45.000 --> 00:12:55.000
테스트 속도와 신뢰성을 개선하는 방법에 대해 알아보려면, "Xcode Cloud에 대한 빠르고 신뢰할 수 있는 테스트 작성자"를 확인하세요.

00:12:55.000 --> 00:13:03.000
구축이 더 빠르고, 테스트가 더 빠르며, 배포를 위해 macOS 앱을 준비하는 것도 더 빠릅니다.

00:13:03.000 --> 00:13:09.000
우리는 Xcode 14에서 공증 속도를 네 번 가속화했습니다.

00:13:09.000 --> 00:13:14.000
인터페이스 빌더를 사용하는 프로젝트의 경우, 더 좋은 소식이 있습니다!

00:13:14.000 --> 00:13:23.000
문서 로딩은 최대 50% 더 빠르며, 장치 바에서 iPhone과 iPad 사이를 전환하는 것은 최대 30% 더 빠릅니다.

00:13:23.000 --> 00:13:34.000
캔버스 편집 작업은 점진적이며 당신이 보고 있는 장면의 우선 순위를 지정하여 큰 스토리보드에서도 즉각적인 피드백을 제공합니다.

00:13:34.000 --> 00:13:38.000
Xcode 14는 더 빠르고, 사용하기도 쉽다.

00:13:38.000 --> 00:13:41.000
어떻게 하는지 보여줄게.

00:13:41.000 --> 00:13:45.000
Xcode 14를 사용하면 앱을 다른 플랫폼으로 쉽게 가져올 수 있습니다.

00:13:45.000 --> 00:13:52.000
단일 대상을 사용하여 앱을 정의하고 지원하는 플랫폼을 나열할 수 있습니다.

00:13:52.000 --> 00:14:01.000
이렇게 하면 설정과 파일을 동기화할 필요가 없으므로, 각 플랫폼에서 고유한 것만 설명하면 됩니다.

00:14:01.000 --> 00:14:09.000
프로젝트에서 이 기능을 활용하려면 "Xcode를 사용하여 멀티 플랫폼 앱 구축"을 확인하세요.

00:14:09.000 --> 00:14:13.000
Xcode는 또한 앱을 더 작게 만들기 위한 훌륭한 도구를 가지고 있습니다.

00:14:13.000 --> 00:14:19.000
메모리 디버거는 항상 애플리케이션의 누수를 탐색하는 데 훌륭했습니다.

00:14:19.000 --> 00:14:29.000
루트 객체에서 예기치 않게 살아있는 객체로 가는 가장 짧은 경로에 초점을 맞추므로 왜 유출되었는지 조사할 수 있습니다.

00:14:29.000 --> 00:14:37.000
Xcode 14는 이러한 기능을 확장하여 객체 안팎의 모든 참조 경로를 볼 수 있습니다.

00:14:37.000 --> 00:14:47.000
누출에 대한 더 철저한 설명 외에도, 이제 물체의 총 무게를 측정할 수 있습니다.

00:14:47.000 --> 00:14:53.000
Xcode 14에서는 Swift 패키지 플러그인으로 Xcode 자체를 확장할 수도 있습니다.

00:14:53.000 --> 00:15:05.000
이제 패키지는 린터와 포맷터와 같은 코드를 처리하는 플러그인을 통합할 수 있으며, 프로젝트 네비게이터에서 직접 호출할 수 있습니다.

00:15:05.000 --> 00:15:12.000
빌드하는 동안 코드 또는 프로세스 리소스를 생성하는 빌드 도구를 통합할 수도 있습니다.

00:15:12.000 --> 00:15:21.000
예를 들어, 빌드 중에 원격 프로시저 호출 인터페이스에 대한 높은 수준의 설명을 낮은 수준의 접착제 코드로 번역할 수 있습니다.

00:15:21.000 --> 00:15:26.000
구축하는 동안 자원을 압축하거나 최적화할 수도 있습니다.

00:15:26.000 --> 00:15:36.000
패키지 플러그인을 자세히 보려면, "스위프트 패키지 플러그인 만나기"와 "스위프트 패키지 플러그인 만들기"를 확인하세요.

00:15:36.000 --> 00:15:40.000
애플리케이션과 마찬가지로 패키지 리소스를 현지화할 수도 있습니다.

00:15:40.000 --> 00:15:50.000
이제 패키지의 기본 현지화를 설정하고, 현지화 카탈로그를 내보내고, 번역하고, 다시 가져올 수 있습니다.

00:15:50.000 --> 00:15:58.000
현지화에 대해 자세히 알아보려면, "글로벌 앱 구축: 예시에 의한 현지화"를 확인하세요.

00:15:58.000 --> 00:16:03.000
다음으로, 실행 대상 선택기로 넘어가자.

00:16:03.000 --> 00:16:13.000
장치 사이를 전환하는 것은 내가 항상 하는 일이며, 이제 업데이트된 실행 대상 선택기로 필요한 장치를 얻는 것이 훨씬 더 쉬워졌습니다.

00:16:13.000 --> 00:16:18.000
한 번 보자.

00:16:18.000 --> 00:16:26.000
실행 대상 선택기를 열면, 선택한 계획에 대해 사용 가능한 모든 실행 대상을 보여줍니다.

00:16:26.000 --> 00:16:30.000
나는 종종 아이폰과 아이패드 사이를 바꾼다.

00:16:30.000 --> 00:16:39.000
새로운 실행 목적지 선택기는 최근의 선택을 우선시하며, 이는 이것을 정말 편리하게 만든다.

00:16:39.000 --> 00:16:44.000
최근에 사용하지 않은 다른 장치를 선택하는 것도 쉽다.

00:16:44.000 --> 00:16:56.000
여기서 목록을 필터링하고, "max"를 입력하여 모든 Max 장치를 모으고 내가 원하는 것을 쉽게 선택할 수 있습니다.

00:16:56.000 --> 00:17:00.000
이 같은 기능은 모두 Scheme 선택기에서도 사용할 수 있습니다.

00:17:00.000 --> 00:17:04.000
다음으로, 주최자 창을 살펴봅시다.

00:17:04.000 --> 00:17:12.000
우리는 당신이 새로운 문제를 식별하고 앱을 개선할 수 있도록 주최자를 크게 개선했습니다.

00:17:12.000 --> 00:17:21.000
주최자에는 앱이 사용자의 장치에서 어떻게 작동하는지 이해하는 데 도움이 되는 두 가지 새로운 보고서가 있습니다: 피드백과 중단.

00:17:21.000 --> 00:17:26.000
뛰어들자.

00:17:26.000 --> 00:17:31.000
피드백 주최자는 모든 TestFlight 피드백을 Xcode에서 직접 보여줍니다.

00:17:31.000 --> 00:17:39.000
우리의 TestFlight 사용자들은 우리의 최근 빌드에 대한 훌륭한 의견과 스크린샷을 보냈습니다.

00:17:39.000 --> 00:17:49.000
검사관은 근본적인 문제를 식별하는 데 도움이 될 수 있는 테스터 정보 및 장치 구성과 같은 추가 세부 사항을 보여줍니다.

00:17:49.000 --> 00:17:57.000
좀 더 맥락이 필요하다면, 이 버튼으로 테스터에게 직접 이메일을 보낼 수 있습니다.

00:17:57.000 --> 00:18:05.000
TestFlight 피드백은 베타 사용자의 것이지만, 테스트를 지나서 App Store에 들어갈 수 있는 몇 가지 문제가 있습니다.

00:18:05.000 --> 00:18:11.000
이와 같은 가장 흔한 유형의 버그 중 하나는 교수형이다.

00:18:11.000 --> 00:18:17.000
앱은 사용자 입력을 처리하기 위해 휴식을 취하지 않고 메인 스레드를 사용할 때 중단됩니다.

00:18:17.000 --> 00:18:26.000
당신의 코드는 중요한 작업을 하고 있을 수 있지만, 사용자는 응답하지 않는 앱을 경험합니다.

00:18:26.000 --> 00:18:38.000
이 새로운 Hangs 보고서는 App Store 사용자로부터 가장 큰 영향을 미치는 중단을 보여 주므로 가장 큰 영향을 미치기 위해 어떤 코드를 재구성해야 하는지 알 수 있습니다.

00:18:38.000 --> 00:18:43.000
왼쪽에는 심각도에 따라 정렬된 중단 목록이 있습니다.

00:18:43.000 --> 00:18:49.000
각각은 문제가 있는 코드를 보여주는 가중치가 있는 추적을 가지고 있다.

00:18:49.000 --> 00:18:53.000
저희 앱은 많은 장치와 OS 버전을 지원합니다.

00:18:53.000 --> 00:18:57.000
어떤 것들은 다른 것들보다 특정 구성에 더 많은 영향을 미친다.

00:18:57.000 --> 00:19:05.000
검사관에서, 이 중단이 주로 iOS 15.3에서 발생한다는 것을 발견하는 것이 도움이 된다.

00:19:05.000 --> 00:19:13.000
이 작업을 할 준비가 되면, 이 Open in Project 버튼으로 코드로 바로 뛰어들 수 있습니다.

00:19:13.000 --> 00:19:20.000
새로운 중단 및 피드백 보고서는 문제를 분류하고 사용자에게 올바른 수정을 신속하게 받을 수 있도록 도와줍니다.

00:19:20.000 --> 00:19:28.000
중단 수정에 대해 자세히 알아보려면, "Xcode 및 장치 내 감지로 중단 추적"을 확인하세요.

00:19:28.000 --> 00:19:33.000
다음으로, 아이콘을 살펴봅시다.

00:19:33.000 --> 00:19:46.000
우리의 앱 아이콘은 모든 크기에서 멋지게 보입니다. 왜냐하면 우리는 픽셀 힌트와 모든 해상도에 적합한 수의 줄무늬를 선택하여 항상 선명하게 보이기 때문입니다.

00:19:46.000 --> 00:19:54.000
이 모든 픽셀 힌트는 일부 아이콘에게는 완전히 필수적일 수 있고 다른 아이콘에게는 불필요할 수 있다.

00:19:54.000 --> 00:19:56.000
이제 우리는 새로운 아이콘이 생겼어.

00:19:56.000 --> 00:19:59.000
한 번 보자.

00:19:59.000 --> 00:20:07.000
이 단순한 질감은 힌트가 필요하지 않으며, 어떤 크기에서도 멋지게 그려질 것이다.

00:20:07.000 --> 00:20:14.000
두 번 클릭하면 새 이미지를 선택할 수 있습니다.

00:20:14.000 --> 00:20:19.000
Xcode 14에서, 당신에게 맞는 세부 수준을 선택할 수 있습니다.

00:20:19.000 --> 00:20:22.000
이 아이콘의 경우, 우리의 단일 이미지는 멋져 보인다.

00:20:22.000 --> 00:20:32.000
나는 새로운 단일 크기 기능을 사용하여 Xcode에 이것과 다른 모든 크기를 자동으로 만들라고 말할 것이다.

00:20:32.000 --> 00:20:39.000
그렇게 하기 위해, 나는 인스펙터에서 싱글 사이즈를 선택할 수 있다.

00:20:39.000 --> 00:20:42.000
그리고 그게 다야!

00:20:42.000 --> 00:20:46.000
그것은 Xcode 14의 새로운 기능에 대한 간략한 개요였다.

00:20:46.000 --> 00:20:49.000
당신의 발전을 돕는 것이 더 빠르고 쉽습니다.

00:20:49.000 --> 00:20:51.000
봐줘서 고마워!

00:20:51.000 --> 00:20:53.000
조나단: 가서 다운로드하고 오늘 시작하세요!

00:20:53.000 --> 23:59:59.000
♪

