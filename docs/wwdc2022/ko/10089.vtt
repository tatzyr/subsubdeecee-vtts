WEBVTT

00:00:01.000 --> 00:00:14.000
콘래드: 저는 콘래드 칼렌이고, 오늘은 PDFKit의 새로운 기능에 대해 이야기할 것입니다.

00:00:14.000 --> 00:00:15.000
여기 우리의 의제가 있습니다.

00:00:15.000 --> 00:00:30.000
먼저 PDFKit에 대한 빠른 검토를 한 다음, 라이브 텍스트와 양식, 이미지에서 PDF 페이지를 만드는 새로운 방법, 그리고 마지막으로 오버레이 뷰를 포함한 새로운 기능을 살펴보세요.

00:00:30.000 --> 00:00:34.000
PDFKit이 어떻게 작동하는지에 대한 빠른 재교육부터 시작합시다.

00:00:34.000 --> 00:00:41.000
PDFKit은 앱이 PDF 파일을 보고, 편집하고, 작성하는 데 도움이 되는 모든 기능을 갖춘 프레임워크입니다.

00:00:41.000 --> 00:00:54.000
iOS, macOS 및 Mac Catalyst에서 사용할 수 있으며, UI 뷰를 앱에 통합할 수 있는 래퍼인 UIViewRepresentable을 통해 SwiftUI에서 사용할 수도 있습니다.

00:00:54.000 --> 00:01:00.000
PDFKit은 앱에 필요한 대부분의 기능을 다루는 4개의 핵심 클래스로 구성되어 있습니다.

00:01:00.000 --> 00:01:05.000
PDFView는 SwiftUI 또는 Interface Builder를 사용하여 레이아웃에 포함하는 위젯입니다.

00:01:05.000 --> 00:01:13.000
PDF 문서의 내용을 표시하고 사람들이 탐색하고, 확대/축소 수준을 설정하고, 텍스트를 붙여넣기 보드에 복사할 수 있습니다.

00:01:13.000 --> 00:01:16.000
PDFDocument는 PDF 파일을 나타냅니다.

00:01:16.000 --> 00:01:20.000
PDFDocument를 서브클래스하는 것은 일반적이지 않지만, 당신은 항상 하나를 사용할 것입니다.

00:01:20.000 --> 00:01:24.000
그것은 PDF 객체 그래프의 뿌리 또는 나무의 줄기이다.

00:01:24.000 --> 00:01:28.000
이것들 중 하나 없이는 나무를 가질 수 없다.

00:01:28.000 --> 00:01:32.000
각 문서에는 하나 이상의 PDFPage 객체가 포함되어 있습니다.

00:01:32.000 --> 00:01:38.000
페이지는 콘텐츠를 렌더링하고 해당 페이지에 고유한 글꼴과 이미지와 같은 리소스를 저장합니다.

00:01:38.000 --> 00:01:42.000
객체 그래프의 잎에는 PDFAnnotations가 있습니다.

00:01:42.000 --> 00:01:43.000
이것들은 선택 사항입니다.

00:01:43.000 --> 00:01:50.000
PDF페이지의 내용은 편집할 수 없는 반면, 주석은 본질적으로 상호 작용하며 종종 편집할 수 있다.

00:01:50.000 --> 00:01:53.000
이 물건들 각각은 내가 오늘 다룰 것에서 역할을 할 것이다.

00:01:53.000 --> 00:02:01.000
PDFKit의 기본 사항에 대해 자세히 알아보려면, 아래 링크에서 훌륭한 프레젠테이션 "PDFKit 소개"를 확인하세요.

00:02:01.000 --> 00:02:08.000
이제, iOS 16과 macOS Ventura에 도입된 새로운 기능에 대해 이야기해 봅시다.

00:02:08.000 --> 00:02:11.000
PDFKit은 이제 라이브 텍스트를 지원합니다.

00:02:11.000 --> 00:02:16.000
텍스트가 종종 탭하여 복사할 수 있는 소량인 사진과는 다릅니다.

00:02:16.000 --> 00:02:25.000
사진과 달리, PDF와 함께, 텍스트를 본다면, 그것은 일반적으로 텍스트이며, 사람들은 특별한 일을 하지 않고 그렇게 행동하기를 기대합니다.

00:02:25.000 --> 00:02:30.000
이제 라이브 텍스트를 사용하면 이와 같은 PDF 문서에서 텍스트를 선택하고 검색할 수 있습니다.

00:02:30.000 --> 00:02:34.000
그것은 텍스트가 전혀 없는 스캔된 비트맵일 뿐이다.

00:02:34.000 --> 00:02:36.000
물론, PDF는 많은 페이지를 가질 수 있다.

00:02:36.000 --> 00:02:47.000
PDF 문서를 열 때 PDF 문서의 모든 페이지에서 OCR을 검토하고 싶지 않으므로, PDFKit은 각 페이지와 상호 작용할 때 필요에 따라 수행합니다.

00:02:47.000 --> 00:02:52.000
OCR은 제자리에 완료되므로, 문서의 복사본을 만들 필요가 없습니다.

00:02:52.000 --> 00:02:58.000
그리고, 전체 문서에 대한 텍스트를 저장하기로 선택하면, 저장할 때 그렇게 할 수 있는 옵션이 있습니다.

00:02:58.000 --> 00:03:02.000
라이브 텍스트 외에도, PDFKit은 양식 처리를 개선했다.

00:03:02.000 --> 00:03:08.000
양식 필드가 포함된 문서는 내장된 텍스트 필드를 포함하지 않더라도 자동으로 인식됩니다.

00:03:08.000 --> 00:03:14.000
예상대로 이 텍스트 필드를 탭하고 텍스트를 입력할 수 있습니다.

00:03:14.000 --> 00:03:20.000
다음으로, 이미지에서 PDF 페이지를 만들기 위한 새로운 API에 대해 이야기해 봅시다.

00:03:20.000 --> 00:03:28.000
iOS 16과 macOS Ventura에는 앱이 이미지를 입력으로 사용하여 PDF 페이지를 만들 수 있는 새롭고 유연한 API가 있습니다.

00:03:28.000 --> 00:03:32.000
당신의 앱은 CGImageRef를 사용하여 이미지를 제공합니다.

00:03:32.000 --> 00:03:38.000
PDFKit은 당신이 제공하는 CGImageRef를 가져와 고품질 JPEG 인코딩을 사용하여 압축합니다.

00:03:38.000 --> 00:03:44.000
CGImageRef는 CoreGraphics의 기본 데이터 유형이기 때문에 추가 변환은 필요하지합니다.

00:03:44.000 --> 00:03:49.000
가장 일반적인 경우를 처리하는 데 도움이 되는 몇 가지 옵션이 있습니다.

00:03:49.000 --> 00:03:52.000
미디어박스는 페이지의 크기를 지정합니다.

00:03:52.000 --> 00:03:58.000
이미지에 정확히 맞도록 선택하거나, 편지와 같은 용지 크기를 선택할 수 있습니다.

00:03:58.000 --> 00:04:03.000
회전을 통해 세로 또는 가로 방향을 지정할 수 있습니다.

00:04:03.000 --> 00:04:04.000
UpscaleIfSmaller.

00:04:04.000 --> 00:04:09.000
기본적으로, 이미지가 MediaBox보다 크면, 이미지는 맞게 축소됩니다.

00:04:09.000 --> 00:04:18.000
UpscaleIfSmaller가 지정되면 여전히 적용되지만, 이미지가 작으면 페이지를 채우기 위해 업스케일됩니다.

00:04:18.000 --> 00:04:28.000
그리고 이제, 여러분 중 많은 사람들이 물어본 질문에 답하기 위해 - "펜슬킷을 사용하여 PDF 페이지를 어떻게 그릴 수 있나요?" - 답은 오버레이 뷰를 사용하는 것입니다.

00:04:28.000 --> 00:04:37.000
과거에는 PDF에서 추가 드로잉을 할 수 있는 유일한 방법은 PDFPage를 서브클래스하고 드로잉 방법을 재정의하거나 사용자 지정 PDF 주석을 사용하는 것이었습니다.

00:04:37.000 --> 00:04:44.000
하지만 iOS 16과 macOS Ventura부터, 이제 각 PDF 페이지 위에 자신의 보기를 오버레이할 수 있습니다.

00:04:44.000 --> 00:04:50.000
이를 통해 앱은 PDF 페이지 상단에 나타나는 완전한 대화형 라이브 뷰를 만들 수 있습니다.

00:04:50.000 --> 00:04:54.000
여기 오버레이 뷰에 대해 알아야 할 3가지가 있습니다.

00:04:54.000 --> 00:05:00.000
먼저, 새로운 프로토콜을 사용하여 PDF 페이지에 오버레이 보기를 설치할 것입니다.

00:05:00.000 --> 00:05:06.000
저장할 때가 되면, 콘텐츠를 PDF에 통합해야 합니다.

00:05:06.000 --> 00:05:13.000
그리고, 저장에 대해 말하자면, 우리는 PDF 문서를 저장할 때 몇 가지 모범 사례를 다룰 것입니다.

00:05:13.000 --> 00:05:17.000
PDF 페이지에 오버레이 뷰를 설치하는 것은 간단합니다.

00:05:17.000 --> 00:05:25.000
PDF는 수천 페이지는 아니더라도 수백 페이지를 포함할 수 있기 때문에, PDF를 열 때 모든 페이지에 대한 뷰를 만들고 싶은 방법이 없습니다.

00:05:25.000 --> 00:05:28.000
그리고 사용자가 빠르게 앞뒤로 스크롤하면 어떻게 되나요?

00:05:28.000 --> 00:05:31.000
언제 당신의 견해를 만들어야 하는지 어떻게 알 수 있나요?

00:05:31.000 --> 00:05:38.000
다행히도, PDFKit은 이미 사람들이 페이지를 스크롤하기 전에 콘텐츠를 지능적으로 준비하도록 설계되었습니다.

00:05:38.000 --> 00:05:41.000
그래서 오버레이 뷰를 요청할 때를 가장 잘 알고 있다.

00:05:41.000 --> 00:05:47.000
당신의 앱은 새로운 프로토콜을 통해 이루어진 요청에 응답하기만 하면 됩니다.

00:05:47.000 --> 00:05:51.000
PDFPageOverlayViewProvider는 새로운 프로토콜이다.

00:05:51.000 --> 00:05:59.000
그건 그렇고, PDFKitPlatformView는 플랫폼에 따라 UIView 또는 NSView의 정의일 뿐입니다.

00:05:59.000 --> 00:06:04.000
구현해야 할 가장 중요한 방법은 overlayViewForPage입니다.

00:06:04.000 --> 00:06:10.000
보기의 인스턴스를 제공하기만 하면, PDFKit은 적절한 제약 조건을 적용하여 크기를 조정할 것입니다.

00:06:10.000 --> 00:06:14.000
페이지에 회전이 0이 아닌 경우 또한 회전할 것이다.

00:06:14.000 --> 00:06:16.000
다음 두 가지 방법은 선택 사항입니다.

00:06:16.000 --> 00:06:25.000
willDisplayOverlayView는 자신만의 제스처 핸들러를 설치하거나 PDFKit과의 실패 관계를 설정하는 데 사용할 수 있습니다.

00:06:25.000 --> 00:06:32.000
willEndDisplayingOverlayView는 페이지가 시야에서 스크롤되었기 때문에 PDFKit이 당신의 보기로 완료되면 호출됩니다.

00:06:32.000 --> 00:06:37.000
여기서 당신의 견해를 공개할 수 있지만, 이 방법에는 또 다른 중요한 용도가 있습니다.

00:06:37.000 --> 00:06:44.000
당신의 뷰에 그것이 그리는 것을 나타내는 데이터가 있다고 가정하면, 이 방법을 사용하여 그 데이터를 가져오고 따로 설정할 수 있습니다.

00:06:44.000 --> 00:06:53.000
우리는 PencilKit의 예에서 그렇게 할 것이지만, 보기 데이터가 다른 곳에 있다면, 이것을 구현할 필요가 없습니다.

00:06:53.000 --> 00:06:57.000
예를 들어, 이것은 우리가 공급자로 사용하고 있는 수업이다.

00:06:57.000 --> 00:07:01.000
그것은 PDFPageOverlayViewProvider 프로토콜을 구현한다.

00:07:01.000 --> 00:07:05.000
이것은 iOS이므로, PDFKitPlatformView는 UIView입니다.

00:07:05.000 --> 00:07:09.000
PDFPage에서 UIView로 이동하려면 지도를 사용합니다.

00:07:09.000 --> 00:07:12.000
여기 자리 표시자 프로토콜 방법이 있습니다.

00:07:12.000 --> 00:07:15.000
다음으로, 구현을 살펴봅시다.

00:07:15.000 --> 00:07:20.000
overlayViewForPage는 pageToView 지도를 확인하여 주어진 페이지에 대한 뷰가 이미 만들어졌는지 확인합니다.

00:07:20.000 --> 00:07:23.000
그렇지 않다면, 그것은 새로운 관점을 만들어낸다.

00:07:23.000 --> 00:07:28.000
두 경우 모두, 우리는 페이지에서 그림을 가져와 캔버스 보기에 설정합니다.

00:07:28.000 --> 00:07:32.000
이 예에서, 저는 PDFPage의 하위 클래스를 사용하고 있습니다.

00:07:32.000 --> 00:07:37.000
그것이 하는 일은 "그림" 속성을 추가하는 것이다.

00:07:37.000 --> 00:07:44.000
그리고 이제, 다음 방법에 집중합시다: WillEndDisplayingOverlay.

00:07:44.000 --> 00:07:46.000
willEndDisplayingOverlayView는 간단합니다.

00:07:46.000 --> 00:07:51.000
그것은 뷰에서 그림을 얻고 우리의 사용자 지정 페이지 클래스에 저장합니다.

00:07:51.000 --> 00:07:56.000
이제 우리가 그것을 했으니, 그것을 실제로 보는 것을 봅시다.

00:07:56.000 --> 00:08:07.000
보통, 올해 이맘때쯤, 나는 메인에서 낚시를 할 것이지만, 대신, 나는 여기 WWDC에 있어, 그래서 다른 사람이 여행에서 내 자리를 차지하고 있고, 나는 그에게 내가 가장 좋아하는 장소 몇 곳을 보여줄 거야.

00:08:07.000 --> 00:08:12.000
나는 오버레이 보기에서 PencilKit을 사용하는 이 앱으로 그것을 할 것이다.

00:08:12.000 --> 00:08:16.000
이 앱은 우리가 방금 본 코드와 다른 것들로 구성되어 있다.

00:08:16.000 --> 00:08:21.000
화면에서 오버레이 뷰를 얻기 위한 코드 전체는 약 30줄입니다!

00:08:21.000 --> 00:08:25.000
그래서, 그랜드 레이크 스트림. 여기는 댐 수영장이야.

00:08:25.000 --> 00:08:28.000
거기에는 항상 많은 물고기가 있다. 그곳은 대부분의 행동이 있는 곳이다.

00:08:28.000 --> 00:08:33.000
숲을 통해 이 트레일을 따라 내려가서 낚시를 하면 댐 수영장에 갈 수 있습니다.

00:08:33.000 --> 00:08:41.000
당신은 그 모든 것을 낚시할 수 있습니다, 아니면 이 길을 타고, 댐을 넘어, 그리고 이곳을 통해 내려갈 수 있습니다.

00:08:41.000 --> 00:08:49.000
거기에서, 당신은 여기로 낚시를 할 수 있고, 섬을 돌고, 여기로 내려갈 수 있지만, 당신이 무엇을 하든, 여기를 지나치지 마세요.

00:08:49.000 --> 00:08:52.000
물은 깊고 빨라진다.

00:08:52.000 --> 00:08:58.000
그것을 피하고 여기로 내려와, 부화장으로 오세요.

00:08:58.000 --> 00:09:04.000
부화장 옆으로 걸어 내려가서 이 수영장으로 들어가세요.

00:09:04.000 --> 00:09:10.000
당신은 이곳을 통해 모든 것을 던질 수 있습니다. 이곳은 좋은 장소입니다. 난 항상 여기서 물고기를 잡아.

00:09:10.000 --> 00:09:17.000
좋아, 이제 페이지에 몇 개의 표시가 있으니, 확대/축소 및 스크롤을 연습해 봅시다.

00:09:17.000 --> 00:09:25.000
그게 얼마나 반응하는지 알아?

00:09:25.000 --> 00:09:26.000
그리고 거기에 우리가 가지고 있어.

00:09:26.000 --> 00:09:28.000
PDFKit의 오버레이 보기.

00:09:28.000 --> 00:09:31.000
그래서, 이제 이 스케치를 가지고 있으니, 어떻게 저장하나요?

00:09:31.000 --> 00:09:34.000
우리는 이것을 하기 위해 PDFAnnotation 수업을 사용할 것이다.

00:09:34.000 --> 00:09:43.000
저장할 때 달성하고 싶은 두 가지가 있습니다: 우리는 화면상의 외관을 높은 충실도와 일치시키고 싶고, 왕복 편집을 하고 싶습니다.

00:09:43.000 --> 00:09:47.000
PDF 주석에는 이를 용이하게 할 수 있는 몇 가지 기능이 있습니다.

00:09:47.000 --> 00:09:52.000
PDF 주석은 PDF 그리기 명령의 흐름인 "출시 스트림"을 가질 수 있다.

00:09:52.000 --> 00:09:57.000
Quartz2D를 사용하여 그릴 수 있는 거의 모든 것은 외관 스트림에 기록될 수 있습니다.

00:09:57.000 --> 00:10:02.000
다른 모든 것은 이미지로 렌더링될 수 있으며, 그것은 기록될 수 있다.

00:10:02.000 --> 00:10:04.000
우리가 금속을 사용한다면 그것이 우리가 하는 방법이다.

00:10:04.000 --> 00:10:11.000
그리고, PDF 도면으로 기록되기 때문에, 어도비 리더, 크롬 등에서 동일하게 보일 것이다.

00:10:11.000 --> 00:10:14.000
PDF 주석은 PDF 문서에 사전으로 저장됩니다.

00:10:14.000 --> 00:10:19.000
그것은 우리가 또한 사용자 지정 데이터를 개인 키/값 쌍에 저장할 수 있다는 것을 의미합니다.

00:10:19.000 --> 00:10:22.000
그럼 코드가 어떻게 생겼는지 봅시다.

00:10:22.000 --> 00:10:26.000
PDFAnnotation의 하위 클래스를 만드는 것으로 시작하세요.

00:10:26.000 --> 00:10:29.000
우리는 draw() 메서드를 재정의하기 위해 이것을 한다.

00:10:29.000 --> 00:10:36.000
PDFKit은 마지막 슬라이드에서 언급한 모양 스트림을 저장할 때 이 방법을 호출할 것이다.

00:10:36.000 --> 00:10:39.000
문서를 저장하기 위해, 우리는 UIDocument의 내용을 재정의합니다.

00:10:39.000 --> 00:10:43.000
다음은 나중에 컨텍스트를 위해 기능에 대한 개요입니다.

00:10:43.000 --> 00:10:47.000
우리는 PDFDocument의 모든 페이지를 반복합니다.

00:10:47.000 --> 00:10:51.000
우리는 다음에 루프를 구체화할 것이다.

00:10:51.000 --> 00:11:02.000
우리는 각 페이지에 대해 다음을 수행합니다: 사용자 지정 클래스의 주석을 만들고, 그림을 데이터로 인코딩하고, 주석에 데이터를 추가합니다.

00:11:02.000 --> 00:11:11.000
다음에 이 문서를 열 때 value:forAnnotationKey를 사용하여 저장된 도면 데이터를 다시 읽고 오버레이 보기에 넣을 수 있습니다.

00:11:11.000 --> 00:11:15.000
마지막으로, 페이지에 주석을 추가하세요.

00:11:15.000 --> 00:11:16.000
우리의 내용() 재정의로 돌아가세요.

00:11:16.000 --> 00:11:26.000
이제 페이지에 주석을 추가했으므로 PDFDocument의 dataRepresentation()을 사용하고 결과를 반환합니다.

00:11:26.000 --> 00:11:31.000
콘텐츠가 주석으로 저장되면, 문서의 수신자는 문서를 이동하거나, 크기를 조정하거나, 삭제할 수 있습니다.

00:11:31.000 --> 00:11:33.000
종종, 그게 네가 원하는 거야.

00:11:33.000 --> 00:11:38.000
하지만 때때로, 당신은 당신의 주석이 페이지의 일부로 "소화"되기를 원합니다.

00:11:38.000 --> 00:11:44.000
iOS 16과 macOS Ventura에는 이것을 쉽게 만드는 새로운 PDFDocumentWriteOption이 있습니다.

00:11:44.000 --> 00:11:50.000
저장 옵션에 burnInAnnotationsOption = true를 추가하면 됩니다.

00:11:50.000 --> 00:11:56.000
PDF 작성 옵션에 대해 말하자면, iOS 16과 macOS Ventura에서 사용할 수 있는 몇 가지가 있습니다.

00:11:56.000 --> 00:11:58.000
그들을 보자.

00:11:58.000 --> 00:12:07.000
CoreGraphics는 항상 PDF에 이미지를 최대한 충실하게 저장하기 위해 노력해왔기 때문에, 이미지는 무손실 압축으로 전체 해상도로 저장됩니다.

00:12:07.000 --> 00:12:10.000
PDF가 대형 프린터로 인쇄된다면 좋습니다.

00:12:10.000 --> 00:12:18.000
하지만, 그것은 화면에 표시될 가능성이 더 높으며, 그 모든 하이파이 이미지 데이터는 매우 큰 파일을 초래할 것이다.

00:12:18.000 --> 00:12:21.000
그것을 해결하기 위해, 나는 다음 두 가지 옵션을 소개한다.

00:12:21.000 --> 00:12:25.000
saveAllImagesAsJPEG는 그것이 말하는 대로 한다.

00:12:25.000 --> 00:12:31.000
이미지가 어떻게 만들어졌는지에 상관없이, PDF에 JPEG 인코딩으로 저장됩니다.

00:12:31.000 --> 00:12:37.000
optimizeImagesForScreen은 이미지를 최대 HiDPI 화면 해상도로 다운샘플링합니다.

00:12:37.000 --> 00:12:41.000
이 두 가지 옵션은 함께 사용될 수 있다.

00:12:41.000 --> 00:12:46.000
createLinearizedPDF는 인터넷에 최적화된 특별한 종류의 PDF를 만들 것입니다.

00:12:46.000 --> 00:12:53.000
인터넷이 나오기 직전에 원래 설계된 PDF 형식은 파일 끝에서 읽힌다.

00:12:53.000 --> 00:12:57.000
그것은 모든 것이 표시되기 전에 전체를 먼저 다운로드해야 한다는 것을 의미합니다.

00:12:57.000 --> 00:13:08.000
선형화된 PDF는 파일의 시작 부분에 첫 번째 페이지를 표시하는 데 필요한 모든 것을 갖추고 있으므로, 웹 브라우저는 나머지가 로드되는 동안 빠르게 표시할 수 있습니다.

00:13:08.000 --> 00:13:14.000
이러한 옵션을 PDFDocument의 dataRepresentation 또는 writeToURL 메소드에 전달할 수 있습니다.

00:13:14.000 --> 00:13:25.000
그리고 거기에 우리가 가지고 있어. PDFKit은 강력하면서도 사용하기 쉽고, 오늘날 iOS와 macOS의 많은 앱에서 사용되며, 이제 iOS 16과 macOS Ventura의 새로운 기능을 갖추고 있습니다.

00:13:25.000 --> 00:13:28.000
네가 그들과 뭘 하는지 보게 되어 신나!

00:13:28.000 --> 00:13:32.000
더 알아보려면, 아래의 세션에서 추가 정보를 확인하세요.

00:13:32.000 --> 00:13:33.000
봐줘서 고마워!

00:13:33.000 --> 23:59:59.000
.

