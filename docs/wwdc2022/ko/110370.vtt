WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:11.000
안녕하세요, 여러분.

00:00:11.000 --> 00:00:19.000
제 이름은 아드리안이고, LLDB로 훌륭한 디버깅 경험을 위해 프로젝트를 설정하는 방법에 대해 이야기하겠습니다.

00:00:19.000 --> 00:00:23.000
LLDB는 Xcode와 함께 제공되는 기본 디버깅 기술이다.

00:00:23.000 --> 00:00:35.000
LLDB를 사용하면 애플리케이션에서 중단점을 설정하고, 실행을 일시 중지하고, 변수와 객체의 상태를 검사하고, 코드를 탐색할 수 있습니다.

00:00:35.000 --> 00:00:46.000
LLDB는 코드가 무엇을 하고 있는지 이해하는 데 도움을 줄 수 있으며 코드의 동작이 기대와 다른 지점을 찾을 수 있습니다.

00:00:46.000 --> 00:00:51.000
그것은 코드를 이해하고 탐구하기 위한 강력한 도구이다.

00:00:51.000 --> 00:00:59.000
LLDB에 대해 더 알고 싶다면, WWDC21의 "중지점 개선 발견"과 같은 이전 비디오를 확인하세요.

00:00:59.000 --> 00:01:06.000
오늘 우리는 스위프트 코드 디버깅에 독특한 영향을 미치는 몇 가지 고급 워크플로우를 살펴볼 것입니다.

00:01:06.000 --> 00:01:10.000
아마도 당신은 타사 프레임워크를 앱에 통합하고 있을 것입니다.

00:01:10.000 --> 00:01:18.000
아마도 당신의 앱과 팀은 대부분의 코드가 지속적인 통합 시스템에 의해 구축되는 지점까지 성장했을 것입니다.

00:01:18.000 --> 00:01:23.000
아마도 당신은 회사의 인프라와 통합하기 위해 맞춤형 빌드 시스템을 사용하고 있을 것입니다.

00:01:23.000 --> 00:01:28.000
아마도 당신은 다른 소프트웨어 개발자들을 위한 소프트웨어를 만들고 있을 것입니다.

00:01:28.000 --> 00:01:30.000
아니면 그냥 LLDB에 대해 더 알고 싶으세요.

00:01:30.000 --> 00:01:40.000
내 목표는 LLDB가 어떻게 작동하는지, 그리고 작동하기 위해 빌드 시스템에서 어떤 정보가 필요한지에 대한 더 나은 이해를 제공하는 것이다.

00:01:40.000 --> 00:01:44.000
나는 여기에 우리가 실행 예시로 사용할 작은 프로젝트가 있다.

00:01:44.000 --> 00:01:50.000
저는 컴파일러 엔지니어이고, 게임을 좋아하기 때문에, 여가 시간에 텍스트 모험을 위한 파서를 작성합니다.

00:01:50.000 --> 00:01:54.000
이것은 내가 최근에 순수한 스위프트에서 시작한 것이다.

00:01:54.000 --> 00:01:56.000
내가 지금까지 가진 걸 보여줄게.

00:01:56.000 --> 00:02:00.000
그 게임은 텍스트 인터페이스를 사용하기 때문에 터미널에서 실행하고 있다.

00:02:00.000 --> 00:02:07.000
모든 좋은 모험과 마찬가지로, 우리는 재고를 확인하는 것으로 시작할 것이다.

00:02:07.000 --> 00:02:10.000
이 게임은 현대적인 환경에서 일어난다.

00:02:10.000 --> 00:02:12.000
내가 아이폰을 가지고 있는 걸 봤어.

00:02:12.000 --> 00:02:17.000
다음으로, 우리 주변을 살펴봅시다.

00:02:17.000 --> 00:02:21.000
흠, 이 센서는 흥미로워 보여.

00:02:21.000 --> 00:02:30.000
센서에서 아이폰을 사용할 수 있을까요?

00:02:30.000 --> 00:02:32.000
내가 아이폰을 떨어뜨렸어?

00:02:32.000 --> 00:02:35.000
어, 그건 내가 너에게 보여주고 싶었던 게 아니야.

00:02:35.000 --> 00:02:39.000
내 생각에 내 게임에 버그가 있는 것 같아.

00:02:39.000 --> 00:02:41.000
이게 디버거 토크라는 게 다행이야.

00:02:41.000 --> 00:02:51.000
파서에서 중단점을 설정하고 명령을 다시 실행합시다.

00:02:51.000 --> 00:03:03.000
우리는 먼저 그 명령이 올바르게 읽혔는지 확인해야 한다.

00:03:03.000 --> 00:03:11.000
"단어" 변수에는 토큰화된 명령이 포함되어 있습니다.

00:03:11.000 --> 00:03:15.000
아, 이건 예상대로 되지 않았어.

00:03:15.000 --> 00:03:17.000
여기서 무슨 일이 일어나고 있는지 모르겠어.

00:03:17.000 --> 00:03:25.000
어제 나는 문제 없이 디버거를 사용하고 있었고, 어젯밤에 터미널에서 텍스트를 스타일링하기 위해 이 UI 프레임워크를 통합했다.

00:03:25.000 --> 00:03:34.000
그 프레임워크의 개발자들은 프레임워크의 야간 빌드를 만드는 지속적인 통합 시스템을 가지고 있으며, 나는 최신 프레임워크에 대해 직접 연결하고 있다.

00:03:34.000 --> 00:03:39.000
이 프레임워크가 내 디버깅 문제와 관련이 있는지 궁금하다.

00:03:39.000 --> 00:03:47.000
예를 들어, 나는 디버그 빌드를 명시적으로 다운로드했음에도 불구하고 프레임워크의 소스 코드에 들어갈 수 없다는 것을 이미 알아차렸다.

00:03:47.000 --> 00:03:51.000
그거 봐.

00:03:51.000 --> 00:03:54.000
분해만 보여.

00:03:54.000 --> 00:04:01.000
거기서 무슨 일이 일어났는지 이해하려고 노력하자, 그리고 내가 왜 소스 코드를 볼 수 없었는지 알아내는 것부터 시작하자.

00:04:01.000 --> 00:04:05.000
LLDB는 소스 코드를 보여주기 위해 무엇이 필요합니까?

00:04:05.000 --> 00:04:15.000
컴파일러가 함수를 컴파일할 때, 기계 코드를 생성합니다.

00:04:15.000 --> 00:04:24.000
그리고 그것은 디버거를 위한 빵 부스러기를 남기므로 실행 파일의 주소는 소스 파일과 줄 번호에 매핑될 수 있으며 그 반대의 경우도 마찬가지입니다.

00:04:24.000 --> 00:04:28.000
이 빵 부스러기를 디버그 정보라고 부른다.

00:04:28.000 --> 00:04:33.000
애플 플랫폼에서 디버그 정보는 객체 파일에 저장됩니다.

00:04:33.000 --> 00:04:39.000
보관 및 배포를 위해, 디버그 정보는 .dSYM 번들에 연결될 수 있습니다.

00:04:39.000 --> 00:04:43.000
디버그 정보 링커는 dsymutil이라고 불린다.

00:04:43.000 --> 00:04:50.000
LLDB는 스포트라이트를 사용하여 .dSYM 번들을 찾기 때문에, 디스크의 위치와 관련하여 매우 유연하다.

00:04:50.000 --> 00:04:55.000
이제 디버그 정보가 어떻게 작동하는지 알았으니, 예시로 돌아가 봅시다.

00:04:55.000 --> 00:05:01.000
먼저, LLDB가 실제로 프레임워크의 dSYM을 찾았는지 확인해 봅시다.

00:05:01.000 --> 00:05:04.000
우리는 이미지 목록 명령으로 이것을 할 수 있다.

00:05:04.000 --> 00:05:15.000
UI 프레임워크는 "터미널 인터페이스"라고 불린다.

00:05:15.000 --> 00:05:19.000
네, LLDB는 프레임워크에 대한 dSYM을 찾았습니다.

00:05:19.000 --> 00:05:22.000
그것은 디버그 정보에 접근할 수 있다는 것을 의미한다.

00:05:22.000 --> 00:05:30.000
우리는 현재 주소에 대한 더 많은 정보를 얻기 위해 "이미지 조회"를 사용할 수 있습니다.

00:05:30.000 --> 00:05:37.000
그건 그렇고, 다양한 옵션에 대해 더 알고 싶다면, LLDB는 훌륭한 내장 도움말을 가지고 있습니다.

00:05:37.000 --> 00:05:48.000
아, 나는 왜 소스 코드가 없는지 알 것 같아: 이 소스 경로는 내 로컬 컴퓨터에 있는 곳이 아니라 소스가 빌드 서버에 있던 곳을 가리키고 있어.

00:05:48.000 --> 00:05:49.000
우리는 그걸 고칠 수 있어.

00:05:49.000 --> 00:06:04.000
LLDB에는 이러한 경로를 리디렉션하는 데 사용할 수 있는 소스 맵이 내장되어 있습니다.

00:06:04.000 --> 00:06:09.000
우리는 지금 당장 명령을 입력할 수 있지만, 나는 차라리 이 변화를 더 영구적으로 만들고 싶다.

00:06:09.000 --> 00:06:25.000
제품, 구성표, 구성표 편집으로 이동하거나 재생 버튼을 옵션으로 클릭하여 불러올 수 있는 구성표 편집기에서 프로젝트별 LLDB init 파일을 정의할 수 있습니다.

00:06:25.000 --> 00:06:38.000
나는 이미 이 프로젝트를 위해 하나를 추가했다.

00:06:38.000 --> 00:06:52.000
이제 LLDB를 설정했으니, 프로젝트를 다시 실행합시다.

00:06:52.000 --> 00:06:58.000
그리고 우리는 소스 코드가 있어.

00:06:58.000 --> 00:07:04.000
LLDB는 "sets set target.source-map"을 사용하여 소스 경로를 다시 매핑할 수 있습니다.

00:07:04.000 --> 00:07:10.000
이 명령을 프로젝트의 .lldbinit 파일에 넣어 자동으로 실행할 수 있습니다.

00:07:10.000 --> 00:07:18.000
또는, 각 .dSYM 번들에는 경로 접두사 리매핑 사전을 넣을 수 있는 XML .plist 파일이 포함되어 있습니다.

00:07:18.000 --> 00:07:29.000
서버에서 최신 빌드를 가져오는 다운로드 스크립트가 있는 경우, 해당 스크립트를 수정하여 다운로드한 .dSYM에 적절한 리매핑 사전을 자동으로 삽입할 수 있습니다.

00:07:29.000 --> 00:07:35.000
LLDB 웹사이트에서 이 과정에 대해 자세히 알아볼 수 있습니다.

00:07:35.000 --> 00:07:44.000
소스 경로는 전혀 언어에 국한되지 않으므로, 이 방법은 Swift, C++ 및 Objective-C 프로젝트에서 모두 작동합니다.

00:07:44.000 --> 00:07:52.000
Apple 플랫폼의 기호에 대해 자세히 알아보려면 WWDC21의 "Symbolication: Beyond the basics"를 확인하세요.

00:07:52.000 --> 00:08:00.000
소스 코드가 빌드 서버 팜에서 컴파일될 때, 소스 파일에 대한 원격 경로는 기계마다 다를 수 있습니다.

00:08:00.000 --> 00:08:10.000
기계당 하나의 리맵 접두사를 정의할 필요가 없도록, 컴파일러에게 디버그 정보에 넣기 전에 소스 경로를 정규화하도록 지시할 수 있습니다.

00:08:10.000 --> 00:08:14.000
이것은 -debug-prefix-map 옵션을 사용하여 수행됩니다.

00:08:14.000 --> 00:08:24.000
이런 식으로 기계별 경로 접두사는 LLDB의 로컬 경로로 다시 매핑할 수 있는 고유한 표준 자리 표시자 이름으로 대체될 수 있습니다.

00:08:24.000 --> 00:08:33.000
우리가 소스 탄젠트에 가기 전에, 나는 "단어"의 객체 설명을 인쇄하려고 했다.

00:08:33.000 --> 00:08:35.000
그건 효과가 없었어.

00:08:35.000 --> 00:08:45.000
사실, "단어"라는 표현을 평가하는 것만으로도 효과가 없었다.

00:08:45.000 --> 00:08:51.000
적어도 우리는 변수 보기에서 변수를 볼 수 있다.

00:08:51.000 --> 00:09:05.000
Xcode 변수 보기와 동등한 콘솔은 "프레임 변수" 또는 "v" 명령이다.

00:09:05.000 --> 00:09:14.000
이 명령들 사이의 뉘앙스에 대해 더 알고 싶다면, WWDC19의 "LLDB: Beyond 'po'"를 확인하세요.

00:09:14.000 --> 00:09:18.000
그래서 포는 무엇이고 왜 여전히 작동하지 않나요?

00:09:18.000 --> 00:09:21.000
이것이 무엇을 의미하는지 이해하기 위해, 우리는 LLDB에 대해 더 배워야 한다.

00:09:21.000 --> 00:09:25.000
상기시켜 드리자면, LLDB는 디버거입니다.

00:09:25.000 --> 00:09:27.000
하지만 LLDB는 단순한 디버거가 아니다.

00:09:27.000 --> 00:09:30.000
그것도 컴파일러야!

00:09:30.000 --> 00:09:37.000
디버거의 기능 외에도, LLDB는 Swift와 Clang 컴파일러의 완전한 기능을 갖춘 복사본을 포함한다.

00:09:37.000 --> 00:09:45.000
이 컴파일러는 p와 po 명령 별칭을 통해 알 수 있는 LLDB의 표현식 평가자를 강화합니다.

00:09:45.000 --> 00:09:55.000
표현식 평가자를 사용하면 변수를 보는 것 이상으로 계산을 수행하고, 함수를 호출하고, 심지어 프로그램의 상태를 변경할 수 있습니다.

00:09:55.000 --> 00:10:04.000
WWDC18의 "Xcode 및 LLDB를 사용한 고급 디버깅"을 확인하여 이러한 명령으로 가능한 것에 대한 아이디어를 얻으십시오.

00:10:04.000 --> 00:10:09.000
디버거는 지역 변수를 어떻게 포맷하나요?

00:10:09.000 --> 00:10:15.000
컴파일러가 제공하는 디버그 정보는 디버거에게 메모리에 변수가 저장되는 위치를 알려줍니다.

00:10:15.000 --> 00:10:22.000
하지만 그 정보만으로, LLDB는 우리에게 임의의 원시 바이트만 보여줄 수 있을 것이다.

00:10:22.000 --> 00:10:26.000
그렇다면 LLDB는 어떻게 그것을 멋지게 포맷된 출력으로 바꾸나요?

00:10:26.000 --> 00:10:28.000
답은 유형이다.

00:10:28.000 --> 00:10:34.000
유형 정보를 통해 LLDB는 소스 변수의 구조와 메모리 레이아웃을 이해할 수 있다.

00:10:34.000 --> 00:10:45.000
유형 정보를 통해 LLDB는 집계 유형에 어떤 필드가 있는지 알고 있으며 유형은 LLDB가 적절한 데이터 포맷터를 사용하여 예쁘게 인쇄할 수 있도록 합니다.

00:10:45.000 --> 00:10:50.000
이제 유형 정보가 어디에서 오는지 살펴봅시다.

00:10:50.000 --> 00:10:59.000
프레임 변수와 v 명령이 있는 디버거 측에서 LLDB는 디버그 정보에서 유형 정보를 가져옵니다.

00:10:59.000 --> 00:11:04.000
그리고 LLDB는 또한 스위프트 반사 메타데이터에서 유형을 얻는다.

00:11:04.000 --> 00:11:12.000
표현식 평가자와 po가 있는 컴파일러 측에서 LLDB는 모듈에서 유형 정보를 얻는다.

00:11:12.000 --> 00:11:21.000
이 깨끗한 분리는 Xcode 14의 새로운 기능이며 표현식 평가자가 아니더라도 변수 보기가 완전히 작동할 수 있는 이유를 설명합니다.

00:11:21.000 --> 00:11:24.000
모듈은 컴파일러가 유형 선언을 구성하는 방법이다.

00:11:24.000 --> 00:11:32.000
스위프트 컴파일러는 모듈을 가져오는 많은 방법을 알고 있지만, 우리가 그것에 뛰어들기 전에, 나는 당신에게 편리한 새로운 기능을 보여주고 싶다.

00:11:32.000 --> 00:11:38.000
컴파일러 측에서 일어나고 있는 문제를 어떻게 진단하기 시작할 수 있을까요?

00:11:38.000 --> 00:11:42.000
올해 LLDB는 새로운 "신속한 건강 점검" 명령을 추가했다.

00:11:42.000 --> 00:11:47.000
모듈 가져오기가 실패했는지 알아내기 위한 첫 번째 정류장입니다.

00:11:47.000 --> 00:11:49.000
이게 어떻게 작동하는지 보여줄게.

00:11:49.000 --> 00:12:05.000
문제가 발생한 후 swift-healthcheck를 실행하면 Swift 표현식 평가자 구성의 로그에 액세스할 수 있습니다.

00:12:05.000 --> 00:12:11.000
로그의 끝에서 우리는 LLDB가 "TerminalUI" Swift 모듈을 가져오는 데 문제가 있었다는 것을 알 수 있다.

00:12:11.000 --> 00:12:18.000
이름을 바탕으로, 나는 이것이 TerminalInterface 프레임워크의 구현 세부 사항이라고 생각한다.

00:12:18.000 --> 00:12:33.000
이 누락된 모듈은 self의 유형이 UI 구현에 대해 일반적이며 해당 유형을 포함하는 모듈이 없으면 표현식 평가자가 "self"의 동적 유형을 실현할 수 없기 때문에 문제가 됩니다.

00:12:33.000 --> 00:12:37.000
저는 프레임워크 개발자들에게 메시지를 보내고 그들에게 조사를 요청하고 있습니다.

00:12:37.000 --> 00:12:41.000
내 경험상, 그들은 항상 매우 반응이 좋았다.

00:12:41.000 --> 00:12:45.000
누가 알겠어, 어쩌면 우리는 이 비디오가 끝나기 전에 해결책을 찾을 수 있을지도 몰라.

00:12:45.000 --> 00:12:52.000
그 동안, LLDB의 컴파일러가 Swift 모듈을 어떻게 찾는지 살펴봅시다.

00:12:52.000 --> 00:12:55.000
내 앱에는 자체 스위프트 모듈이 있다.

00:12:55.000 --> 00:13:00.000
재단과 같은 시스템 프레임워크를 가져올 수 있다.

00:13:00.000 --> 00:13:06.000
시스템 프레임워크는 SDK에 있는 텍스트로 안정적인 스위프트 인터페이스 파일이다.

00:13:06.000 --> 00:13:16.000
모든 Swift 모듈은 모듈 맵 파일의 도움으로 함께 그룹화된 하나 이상의 헤더 파일의 멋진 이름인 Clang 모듈을 가져올 수 있습니다.

00:13:16.000 --> 00:13:21.000
클랑 모듈은 다른 클랑 모듈에 의존할 수 있다.

00:13:21.000 --> 00:13:26.000
내 앱은 로컬로 구축된 프레임워크에 속하는 스위프트 모듈을 가져올 수도 있다.

00:13:26.000 --> 00:13:32.000
또한 SDK의 일부가 아닌 텍스트 스위프트 인터페이스 파일을 가져올 수 있습니다.

00:13:32.000 --> 00:13:39.000
방법을 배우고 싶다면, WWDC19의 "바이너리 프레임워크 인 스위프트"를 확인하세요.

00:13:39.000 --> 00:13:47.000
내 앱은 또한 스위프트 코드가 포함된 정적 라이브러리에 연결할 수 있으며, 스위프트 모듈도 함께 제공됩니다.

00:13:47.000 --> 00:13:49.000
흠, 하지만 우리는 아직 끝나지 않았어.

00:13:49.000 --> 00:13:54.000
Clang 모듈을 가져올 수 있는 브리징 헤더도 있다는 것을 언급해야 한다.

00:13:54.000 --> 00:14:02.000
마지막으로, LLDB만의 특수 기능으로, 일부 모듈 내용은 디버그 정보만으로 재구성할 수 있습니다.

00:14:02.000 --> 00:14:04.000
그건 많은 출처야!

00:14:04.000 --> 00:14:07.000
LLDB는 그들 모두를 어떻게 찾나요?

00:14:07.000 --> 00:14:12.000
LLDB가 모듈을 찾을 수 있도록 모듈을 패키징하는 것은 빌드 시스템의 일이다.

00:14:12.000 --> 00:14:16.000
시스템 프레임워크의 모듈은 SDK에 남아 있다.

00:14:16.000 --> 00:14:22.000
LLDB는 프로그램에 첨부할 때 읽을 수 있는 일치하는 SDK를 찾을 것입니다.

00:14:22.000 --> 00:14:29.000
객체 파일에서 바로 디버깅할 때, LLDB는 빌드 당시의 모든 비 SDK 모듈을 찾을 것이다.

00:14:29.000 --> 00:14:40.000
Dsymutil은 a라고 불리는 디버그 정보 아카이브를 패키징할 수 있다. 모든 동적 라이브러리, 프레임워크 또는 dylib 및 실행 파일을 위한 DSYM 번들.

00:14:40.000 --> 00:14:49.000
각 .dSYM 번들은 브리징 헤더, 텍스트 스위프트 인터페이스 파일 및 가장 중요한 디버그 정보를 포함할 수 있는 이진 스위프트 모듈을 포함할 수 있습니다.

00:14:49.000 --> 00:14:51.000
그건 모든 걸 커버해.

00:14:51.000 --> 00:14:53.000
모든 것?

00:14:53.000 --> 00:14:59.000
정적 아카이브에 속하는 스위프트 모듈을 제외한 모든 것.

00:14:59.000 --> 00:15:05.000
Dsymutil이 스위프트 모듈을 픽업하려면, 링커에 등록해야 합니다.

00:15:05.000 --> 00:15:10.000
동적 라이브러리와 실행 파일의 경우, 빌드 시스템은 당신을 위해 자동으로 이것을 할 것입니다.

00:15:10.000 --> 00:15:18.000
하지만 정적 아카이브는 링커에 의해 생성되지 않으며, zip 파일과 같은 개체 파일의 모음일 뿐입니다.

00:15:18.000 --> 00:15:29.000
즉, 스위프트 모듈을 링커에 등록하는 책임은 정적 아카이브를 연결하는 모든 실행 파일 또는 동적 라이브러리에 있습니다.

00:15:29.000 --> 00:15:34.000
많은 경우에, Xcode의 빌드 시스템은 당신을 위해 이것을 할 것입니다.

00:15:34.000 --> 00:15:44.000
하지만 자신만의 사용자 지정 빌드 시스템을 유지하거나 사용자 지정 빌드 규칙을 정의한 경우, 이것은 알아야 할 것입니다.

00:15:44.000 --> 00:15:52.000
Apple 링커를 사용할 때, Swift 모듈은 -add-ast-path 옵션으로 등록되어야 합니다.

00:15:52.000 --> 00:15:57.000
이것이 사실인지 확인하려면 빌드 로그를 확인하세요.

00:15:57.000 --> 00:16:08.000
또한 dsymutil을 사용하여 실행 파일의 심볼 테이블을 덤프하고 "swiftmodule"에 대한 grep을 사용하여 작동하는지 확인할 수 있습니다.

00:16:08.000 --> 00:16:20.000
리눅스와 같은 다른 플랫폼에서 스위프트 드라이버는 바이너리 스위프트 모듈 파일을 나머지 디버그 정보와 함께 바이너리에 연결할 수 있는 객체로 변환하는 -modulewrap 동작을 지원합니다.

00:16:20.000 --> 00:16:23.000
LLDB가 거기서 찾을 거야.

00:16:23.000 --> 00:16:27.000
그 프레임워크의 개발자들은 믿을 수 없을 정도로 반응이 좋았다.

00:16:27.000 --> 00:16:33.000
우리가 의심했듯이, 프레임워크의 빌드 시스템의 일부로 정적 아카이브가 사용된다는 것이 밝혀졌다.

00:16:33.000 --> 00:16:38.000
그리고 그것은 dSYM 번들에서 누락된 정적 아카이브에 속한 스위프트 모듈이었다.

00:16:38.000 --> 00:16:41.000
나는 이제 고정된 버전의 프레임워크를 설치했다.

00:16:41.000 --> 00:16:49.000
그것은 누락된 정적 모듈을 링커에 등록했기 때문에 dsymutil은 그것을 수집할 수 있었다.

00:16:49.000 --> 00:16:54.000
이제 스스로 해결할 수 있다.

00:16:54.000 --> 00:17:01.000
그리고 우리는 "단어"의 객체 설명을 인쇄할 수 있다.

00:17:01.000 --> 00:17:12.000
어쨌든 콘솔을 사용하고 있기 때문에, 저는 parseFrom 함수에 들어가기 위해 별칭을 사용하고 있습니다.

00:17:12.000 --> 00:17:26.000
그리고 이제 우리는 여기서 복사 및 붙여넣기 오류인 버그를 쉽게 찾을 수 있습니다.

00:17:26.000 --> 00:17:53.000
그리고 그것으로, 우리는 누락된 스위프트 모듈의 퍼즐뿐만 아니라 게임의 첫 번째 퍼즐도 풀었다.

00:17:53.000 --> 00:17:57.000
우리가 마무리하기 전에, 나는 조심해야 할 세부 사항이 하나 더 있다.

00:17:57.000 --> 00:18:04.000
스위프트 컴파일러는 Clang 헤더 검색 경로 및 기타 관련 옵션을 이진 .swiftmodule 파일로 직렬화합니다.

00:18:04.000 --> 00:18:11.000
이것은 Clang 모듈 종속성을 가져오는 것이 빌드 중에만 작동하도록 하기 때문에 좋습니다.

00:18:11.000 --> 00:18:16.000
하지만 다른 기계에 건물을 지을 때, 이 지역 경로는 해로울 수 있다.

00:18:16.000 --> 00:18:25.000
따라서 바이너리 .swiftmodule을 다른 기계로 배송하기 전에, -no-serialize-debugging-options 컴파일러 플래그로 빌드하는 것을 고려해 보세요.

00:18:25.000 --> 00:18:32.000
Xcode에서 이것은 SWIFT_SERIALIZE_DEBUGGING_OPTIONS 설정을 통해 제어됩니다.

00:18:32.000 --> 00:18:38.000
다음 설정 중 하나로 LLDB에서 이러한 검색 경로를 다시 도입할 수 있습니다.

00:18:38.000 --> 00:18:40.000
우리가 배운 것을 요약해 봅시다.

00:18:40.000 --> 00:18:47.000
한 컴퓨터에서 다른 컴퓨터로 코드를 보내고 싶다면, 어떤 수준의 디버깅을 할 것으로 예상하는지 스스로에게 물어봐야 합니다.

00:18:47.000 --> 00:18:59.000
예를 들어, 바이너리 프레임워크를 다른 개발자에게 배송하고 디버거에서 코드에 들어갈 것으로 예상하지 않는다면, Swift 모듈을 텍스트 .swiftinterface 파일로 배송하는 것이 가장 좋습니다.

00:18:59.000 --> 00:19:15.000
하지만 개발자가 다운로드한 빌드 아티팩트를 디버깅할 것으로 예상되는 빌드 서버 또는 지속적인 통합 시스템을 설정하는 경우, 이진 스위프트 모듈을 구축하고 검색 경로 직렬화를 끄는 것을 고려해야 합니다.

00:19:15.000 --> 00:19:21.000
-Debug-prefix-map 옵션을 사용하여 디버그 정보에서 서버의 소스 경로를 정규화할 수도 있습니다.

00:19:21.000 --> 00:19:24.000
그게 내가 널 위해 가진 전부야.

00:19:24.000 --> 00:19:30.000
오늘 우리는 디버거와 컴파일러로서의 LLDB의 이중 특성에 대해 배웠습니다.

00:19:30.000 --> 00:19:38.000
디버거는 작동하기 위해 디버그 정보와 반사 메타데이터가 필요하며 Xcode 변수 보기와 v 명령을 제공합니다.

00:19:38.000 --> 00:19:43.000
컴파일러는 모듈이 필요하며 검색 경로에 민감하다.

00:19:43.000 --> 00:19:47.000
그것은 expr, p, po 명령 뒤에 있다.

00:19:47.000 --> 00:19:54.000
컴파일러 진단을 얻는 좋은 방법은 LLDB의 새로운 swift-healthcheck 명령이다.

00:19:54.000 --> 23:59:59.000
봐줘서 고마워! ♪ ♪

