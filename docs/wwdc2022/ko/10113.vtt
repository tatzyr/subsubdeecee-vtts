WEBVTT

00:00:00.000 --> 00:00:03.000
♪ 부드러운 기악 힙합 음악 ♪

00:00:03.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:14.000
안녕하세요, 제 이름은 데니스이고, 저는 여기 애플의 디스플레이 및 컬러 테크놀로지 팀의 일원입니다.

00:00:14.000 --> 00:00:19.000
오늘 저는 EDR에 대한 흥미로운 업데이트와 iOS 개발자에게 미치는 영향을 탐구할 것입니다.

00:00:19.000 --> 00:00:29.000
작년 프레젠테이션을 본 적이 있다면 이미 EDR에 익숙할 수도 있지만, 간단히 요약하자면, EDR은 확장된 다이내믹 레인지를 의미하며, 애플의 HDR 기술입니다.

00:00:29.000 --> 00:00:40.000
EDR은 렌더링 기술과 픽셀 표현을 모두 말하며, EDR의 픽셀 표현은 표준 및 높은 다이내믹 레인지 콘텐츠를 일관되게 나타내기 때문에 특히 중요합니다.

00:00:40.000 --> 00:00:51.000
잘 노출된 콘텐츠에서, 이 예에서 야영객의 주제는 이미지의 표준 동적 범위에 속해야 하는 반면, 캠프파이어와 같은 반사 및 방출 하이라이트는 더 높은 범위에 속할 것이다.

00:00:51.000 --> 00:00:58.000
표준 범위 표현에서, 이러한 요소들은 결국 잘릴 것이지만, EDR을 사용하면 표현 가능한 상태로 남아 있다.

00:00:58.000 --> 00:01:07.000
다른 픽셀 표현은 고정된 범위의 밝기 값을 나타내도록 설계되었지만, EDR의 표현은 진정으로 역동적이며 임의의 값을 설명할 수 있다.

00:01:07.000 --> 00:01:15.000
또한 사용하지 않는 백라이트를 활용하여 EDR을 사용하면 디스플레이의 피크에 관계없이 모든 디스플레이가 높은 다이내믹 레인지 콘텐츠를 렌더링할 수 있습니다.

00:01:15.000 --> 00:01:22.000
그리고 HDR 콘텐츠가 훨씬 더 널리 퍼지고 접근하기 쉬워짐에 따라, macOS에서 EDR을 채택한 응용 프로그램 목록도 있습니다.

00:01:22.000 --> 00:01:29.000
"Baldur's Gate 3", "Divinity: Original Sin 2", "Shadow of the Tomb Raider"는 이미 macOS에서 EDR과 함께 배송되고 있다.

00:01:29.000 --> 00:01:37.000
EDR을 채택함으로써, 게임은 더 밝고 포화된 색상을 렌더링할 수 있을 뿐만 아니라, 더 사실적인 조명, 반사 및 더 다채로운 콘텐츠를 생성할 수 있다.

00:01:37.000 --> 00:01:45.000
밝은 요소가 SDR 피크 화이트로 제한되는 경우, EDR을 사용하면 저자가 의도한 대로 활기와 깊이를 되찾는다.

00:01:45.000 --> 00:01:50.000
EDR은 사파리와 퀵타임 플레이어를 포함한 애플 생태계 전반에 통합되어 있다.

00:01:50.000 --> 00:02:02.000
결과적으로, Apple TV 및 Netflix와 같은 주문형 비디오 앱과 서비스는 HDR10, Dolby Vision 및 ProRes 콘텐츠의 끊임없이 확장되는 카탈로그를 소비자에게 제공할 수 있는 능력을 얻습니다.

00:02:02.000 --> 00:02:15.000
EDR을 채택한 프로 앱을 통해 사용자는 HDR 스틸과 비디오를 정확하게 편집, 등급, 마스터 및 검토할 수 있는 다양한 전문 워크플로우를 제공하여 놀라운 HDR 콘텐츠를 만들 수 있습니다.

00:02:15.000 --> 00:02:20.000
macOS에서 EDR 채택에 대한 모든 흥분과 함께, 우리는 EDR에 몇 가지 새로운 업데이트를 가져오게 되어 기쁩니다.

00:02:20.000 --> 00:02:26.000
무엇보다도, 우리는 이제 iOS와 iPadOS에서 EDR API를 사용할 수 있다는 것을 발표하게 되어 기쁩니다.

00:02:26.000 --> 00:02:36.000
또한, 프로 사용자를 지원하기 위한 Apple의 노력의 일환으로, 올해 우리는 Liquid Retina XDR 디스플레이가 장착된 12.9인치 iPad Pro에 두 가지 새로운 프로 컬러 기능을 소개합니다.

00:02:36.000 --> 00:02:40.000
사이드카를 통한 참조 모드 및 EDR 렌더링.

00:02:40.000 --> 00:02:53.000
참조 모드는 macOS의 참조 사전 설정과 유사한 다양한 일반적인 비디오 형식에 대한 참조 응답을 제공하여 색상 등급, 편집 및 콘텐츠 검토와 같은 색상에 중요한 워크플로우를 활성화하도록 설계된 새로운 디스플레이 모드입니다.

00:02:53.000 --> 00:03:02.000
이를 위해, 레퍼런스 모드는 SDR 피크 밝기를 100니트, HDR 피크 밝기를 1000니트에서 수정하여 10배의 EDR 헤드룸을 제공합니다.

00:03:02.000 --> 00:03:06.000
참조 모드는 또한 매핑을 표시하기 위한 일대일 미디어를 제공한다.

00:03:06.000 --> 00:03:16.000
그리고 True Tone, Auto-Brightness 및 Night Shift와 같은 주변 서라운드에 대한 모든 동적 디스플레이 조정을 비활성화하여 사용자가 수동으로 화이트 포인트를 미세하게 보정할 수 있도록 합니다.

00:03:16.000 --> 00:03:22.000
이렇게 하면 디스플레이는 각각의 사양에 설명된 대로 정확하게 색상을 생성할 것이다.

00:03:22.000 --> 00:03:26.000
이 차트는 참조 모드가 지원하는 형식 목록을 제공합니다.

00:03:26.000 --> 00:03:37.000
macOS의 참조 프리셋과 달리, 참조 모드는 가장 일반적인 다섯 가지 HDR 및 SDR 비디오 형식을 지원하는 단일 토글이며, 미디어 유형 전반에 걸쳐 일관된 참조 응답을 제공합니다.

00:03:37.000 --> 00:03:41.000
그리고 이 표에 나열되지 않은 형식의 콘텐츠가 있다면 걱정하지 마세요.

00:03:41.000 --> 00:03:46.000
지원되지 않는 모든 형식은 기본 디스플레이 모드에서와 마찬가지로 색상으로 관리됩니다.

00:03:46.000 --> 00:03:49.000
예를 들어, 참조 모드에서 LumaFusion을 살펴봅시다.

00:03:49.000 --> 00:03:55.000
iOS에서 참조 모드를 활성화함으로써, LumaFusion은 비디오 포스트 프로덕션을 위한 더 강력한 도구가 된다.

00:03:55.000 --> 00:04:05.000
HDR 비디오를 표시할 때, 최대 1000니트 피크의 P3 색재현율 내의 색상이 정확하게 렌더링되므로 사용자는 비디오가 항상 정확하고 일관되게 표시되고 있다고 확신할 수 있습니다.

00:04:05.000 --> 00:04:12.000
참조 모드와 LumaFusion의 새로운 비디오 스코프 기능의 조합으로, 이제 iPad Pro에서 색상에 중요한 워크플로우가 가능합니다.

00:04:12.000 --> 00:04:19.000
참조 모드를 비활성화하면 EDR 헤드룸이 동적으로 변경될 수 있으며, iOS가 비디오의 밝기를 조절할 때 여기에서 볼 수 있습니다.

00:04:19.000 --> 00:04:29.000
사용자는 LumaFusion 프로젝트를 XML로 내보낼 수 있으며, 다른 인기 있는 Mac 포스트 프로덕션 앱에서 가져올 수 있으므로 콘텐츠 제작자 팀이 두 플랫폼에서 쉽게 협업할 수 있습니다.

00:04:29.000 --> 00:04:37.000
LumaFusion이 프로 콘텐츠 제작자에게 제공하는 가치와 유연성과 함께 참조 모드를 채택하는 것을 보는 것은 매우 흥미롭습니다.

00:04:37.000 --> 00:04:39.000
하지만 참조 모드가 유일한 새로운 기능은 아니다.

00:04:39.000 --> 00:04:46.000
2019년에, 우리는 Mac 사용자가 iPad를 보조 디스플레이로 사용할 수 있는 기술인 Sidecar를 도입했습니다.

00:04:46.000 --> 00:05:02.000
그리고 이제, 레퍼런스 모드의 도입과 함께, 우리는 사이드카를 통한 EDR 렌더링에 대한 지원을 추가하고 있으며, 이는 레퍼런스 모드가 레퍼런스 등급 SDR 및 HDR 콘텐츠를 지원할 때 사이드카의 기능을 확장하여 프로 콘텐츠 제작자가 iPad Pro를 Apple 실리콘 Mac의 보조 레퍼런스 디스플레이로 사용할 수 있도록 합니다.

00:05:02.000 --> 00:05:11.000
사이드카를 통해 렌더링된 콘텐츠는 참조 모드에서 네이티브 iOS와 동일한 모든 비디오 형식에 대한 참조 응답을 제공한다는 것은 말할 필요도 없다.

00:05:11.000 --> 00:05:20.000
예를 들어, HDR 비디오 프리셋에서 Mac에서 렌더링된 이 HDR10 테스트 패턴을 살펴보고 Sidecar를 사용하여 iPad Pro의 변환과 비교해 봅시다.

00:05:20.000 --> 00:05:29.000
이 구성에서, 두 장치 모두 P3 색상과 D65 화이트 포인트가 있는 참조 디스플레이 역할을 합니다. 이는 두 디스플레이의 사양이기 때문입니다.

00:05:29.000 --> 00:05:37.000
P3 기본 및 보조 색상 막대에서 볼 수 있듯이, Mac과 iPad 모두 우리가 예상했던 것과 비슷한 반응을 냅니다.

00:05:37.000 --> 00:05:47.000
또한, 두 구성 모두 1000니트의 최고 휘도를 지원하며, 그라디언트에서 볼 수 있듯이, 1000니트를 초과하는 값이 클리핑되는 동안 그 값은 충실하게 렌더링됩니다.

00:05:47.000 --> 00:05:52.000
우리는 사이드카를 통한 EDR 렌더링이 프로 사용자에게 제공하는 전망과 새로운 기회에 흥분하고 있습니다.

00:05:52.000 --> 00:05:58.000
우리는 또한 더 많은 개발자들이 자신의 앱에서 EDR을 채택하여 이러한 기능을 활용하는 것을 기대합니다.

00:05:58.000 --> 00:06:04.000
그 메모에서, EDR 렌더링을 자신의 iOS 및 iPadOS 앱에 통합하는 방법을 살펴봅시다.

00:06:04.000 --> 00:06:09.000
우리는 EDR의 픽셀 표현과 렌더링 파이프라인의 의미를 살펴보는 것으로 시작할 것이다.

00:06:09.000 --> 00:06:17.000
전통적으로, SDR의 부동 소수점 표현은 0에서 1 범위의 값이었고, 0은 검은색이고 1은 SDR 흰색이었다.

00:06:17.000 --> 00:06:24.000
EDR의 경우, SDR 콘텐츠는 여전히 0에서 1 범위로 표시되는 반면, 1 이상의 값은 SDR보다 밝은 콘텐츠를 나타냅니다.

00:06:24.000 --> 00:06:32.000
EDR은 선형 공간에서 표현되며, 이는 2.0 EDR이 1.0보다 두 배 더 밝지 않다는 것을 의미합니다.

00:06:32.000 --> 00:06:39.000
다른 HDR 형식과 달리, EDR은 값을 0에서 1 범위로 매핑하지 않으며, 이는 렌더링에 영향을 미친다.

00:06:39.000 --> 00:06:45.000
이와 관련하여, EDR은 SDR 콘텐츠 또는 0에서 1까지의 값이 항상 렌더링되도록 보장합니다.

00:06:45.000 --> 00:06:50.000
그리고 1 이상의 값은 현재 EDR 헤드룸에 톤 매핑 없이 적절하게 렌더링될 것이다.

00:06:50.000 --> 00:06:53.000
그러나, 더 밝은 값은 잘릴 것이다.

00:06:53.000 --> 00:07:07.000
처음에는 이 행동이 이상적으로 보일 수 있지만, HDR로 작성된 모든 콘텐츠는 가능한 한 의도에 가깝게 렌더링되며, 일반적으로 기존 표현처럼 너무 밝게 잘린 하이라이트가 있습니다.

00:07:07.000 --> 00:07:11.000
분명히, 헤드룸이 높을수록, 당신의 콘텐츠는 더 밝고 역동적일 수 있습니다.

00:07:11.000 --> 00:07:13.000
하지만 우리는 얼마나 많은 헤드룸을 가지고 있나요?

00:07:13.000 --> 00:07:26.000
음, 순간 EDR 헤드룸은 동적 값이며 장치의 특정 디스플레이 기술과 현재 디스플레이 밝기를 포함하되 이에 국한되지 않는 많은 요소를 기반으로 한다는 점에 유의해야 합니다.

00:07:26.000 --> 00:07:35.000
하지만 지나치게 단순화하기 위해, 현재 EDR 헤드룸은 현재 SDR 밝기로 나눈 디스플레이의 최대 밝기와 거의 같습니다.

00:07:35.000 --> 00:07:47.000
그래서 앞서, 내가 레퍼런스 모드가 10배의 EDR 헤드룸을 제공한다고 언급했을 때, 그것은 우리가 EDR 1.0(또는 SDR 밝기)을 100니트까지 고정하고 HDR 피크 밝기를 1000니트까지 고정하기 때문이다.

00:07:47.000 --> 00:07:53.000
따라서 1000니트를 100니트로 나누면 EDR의 10배의 일정한 헤드룸을 제공합니다.

00:07:53.000 --> 00:07:58.000
이 표는 다양한 장치와 최대 잠재적 헤드룸의 몇 가지 예를 더 제공합니다.

00:07:58.000 --> 00:08:06.000
이것이 잠재적인 헤드룸이며 진정한 헤드룸은 현재 디스플레이 밝기를 포함한 다양한 다른 요인에 의존한다는 점에 유의하십시오.

00:08:06.000 --> 00:08:13.000
이 이야기의 뒷부분에서, 우리는 헤드룸에 대해 더 자세히 살펴보고, 렌더링에 대한 정보에 입각한 결정을 내리기 위해 헤드룸을 쿼리하고 사용하는 방법에 대한 예를 보여줄 것입니다.

00:08:13.000 --> 00:08:18.000
하지만 현재로서는, 당신은 EDR과 당신이 그것을 원할 때를 잘 이해해야 합니다.

00:08:18.000 --> 00:08:21.000
이제, 실제로 EDR 콘텐츠를 렌더링하는 것으로 기어를 바꾸자.

00:08:21.000 --> 00:08:26.000
이 섹션에서는 HDR 콘텐츠를 렌더링 가능한 형식으로 읽는 방법을 살펴볼 것입니다.

00:08:26.000 --> 00:08:34.000
우리가 다룰 구체적인 예는 이미지 I/O 워크플로우이지만, 다른 프레임워크를 찾고 있다면, 올해 다른 EDR 회담 중 하나를 살펴보세요.

00:08:34.000 --> 00:08:38.000
스틸 미디어의 경우, 우리는 로드하고 싶은 이미지 파일로 시작합니다.

00:08:38.000 --> 00:08:42.000
이 이미지는 일반적으로 이중 평면 YUV 공간에서 인코딩될 것이다.

00:08:42.000 --> 00:08:47.000
처음에 로드할 때, 이미지와 버퍼는 원래 형식이 될 것이다.

00:08:47.000 --> 00:08:52.000
불행히도, 그 형식에서는 의미 있는 방식으로 이미지를 해석하고 작업하는 것은 어려울 수 있다.

00:08:52.000 --> 00:08:57.000
그래서 CGBitmapContext의 도움으로 우리는 이미지를 디코딩하고 더 사용 가능한 형식으로 변환할 것입니다.

00:08:57.000 --> 00:09:05.000
어느 시점에서, 우리는 컨텍스트의 백업 픽셀 데이터에서 MTLTexture를 만든 다음 금속 엔진으로 렌더링할 수 있습니다.

00:09:05.000 --> 00:09:09.000
더 구체적으로, 이것을 달성하기 위해, 우리가 다루어야 할 네 가지 단계가 있다.

00:09:09.000 --> 00:09:24.000
우리는 HDR 스틸을 위한 CGImage를 만들고, CGImage를 비트맵 컨텍스트에 매핑하고, 메탈 텍스처를 만들고, 마지막으로 비트맵의 데이터를 새로 생성된 텍스처에 로드하는 것으로 시작할 것입니다.

00:09:24.000 --> 00:09:28.000
첫 번째 단계에서, 우리는 이미지를 읽고 약간의 설정을 할 것이다.

00:09:28.000 --> 00:09:35.000
먼저, 우리는 URL에서 CGImageSource로 이미지를 읽은 다음, 그 소스에서 CGImage를 만듭니다.

00:09:35.000 --> 00:09:39.000
이 경우, 우리는 nil 옵션 사전을 전달하여 이미지를 만들었습니다.

00:09:39.000 --> 00:09:48.000
그러나, 특정 HDR 형식의 부동 소수점 버퍼를 원한다면, 설정할 수 있는 새로운 kCGImageSourceShouldAllowFloat 옵션이 있습니다.

00:09:48.000 --> 00:09:51.000
이제 CGBitmapInfo를 인스턴스화할 것입니다.

00:09:51.000 --> 00:09:56.000
이 경우, 우리는 미리 곱한 알파로 16비트 부동 소수점 컨텍스트를 만들고 있습니다.

00:09:56.000 --> 00:10:01.000
우리는 우리의 금속 질감이 같은 형식을 사용하기를 원하기 때문에 이것을 기억하세요.

00:10:01.000 --> 00:10:08.000
다음으로, 우리는 방금 만든 비트맵 정보를 사용하여 CGImage의 너비와 높이와 함께 CGBitmapContext를 구성할 것입니다.

00:10:08.000 --> 00:10:14.000
컨텍스트의 색상 공간이 렌더링할 CAMetalLayer의 색상 공간과 일치하기를 원할 것입니다.

00:10:14.000 --> 00:10:18.000
그렇지 않으면, 당신은 적절한 색상 관리를 직접 수행해야 할 것입니다.

00:10:18.000 --> 00:10:23.000
마지막으로, 우리는 CGImage를 비트맵 컨텍스트에 그릴 것입니다.

00:10:23.000 --> 00:10:28.000
이 시점에서, 우리는 맥락에서 금속 질감을 만드는 것으로 넘어갈 수 있다.

00:10:28.000 --> 00:10:32.000
금속 텍스처를 만들기 위해, 우리는 먼저 MTLTextureDescriptor를 인스턴스화할 것입니다.

00:10:32.000 --> 00:10:45.000
이전에 비트맵 컨텍스트에 하프 플로트를 사용하기로 선택했지만, EDR을 렌더링할 때 10비트 파란색, 녹색, 빨간색, 2비트 알파가 있는 32비트 포장 픽셀 형식으로 2D 텍스처를 가질 수도 있습니다.

00:10:45.000 --> 00:10:55.000
우리는 다음 섹션에서 더 자세히 설명할 것이지만, 현재로서는 텍스처의 픽셀 형식이 콘텐츠의 픽셀 형식과 일치해야 한다는 것을 아는 것으로 충분합니다. 우리의 경우, 하프 플로트.

00:10:55.000 --> 00:11:02.000
이 시점에서, 우리는 금속 레이어의 장치와 새로 생성된 텍스처 설명자로 텍스처를 인스턴스화할 것입니다.

00:11:02.000 --> 00:11:08.000
마지막으로, 우리는 비트맵 컨텍스트에서 데이터를 가져와 텍스처로 복사할 것입니다.

00:11:08.000 --> 00:11:14.000
그것으로, 우리는 렌더링을 위해 금속 파이프라인으로 보낼 수 있는 EDR 값을 포함하는 금속 텍스처를 가지고 있습니다.

00:11:14.000 --> 00:11:21.000
이 섹션에서는 URL에서 시작하여 금속 텍스처까지 HDR 스틸 이미지를 소싱하기 위한 샘플 워크플로우를 다루었습니다.

00:11:21.000 --> 00:11:27.000
다음으로, 우리는 iOS와 iPadOS에서 그러한 텍스처를 렌더링하는 데 필요한 최소 코드 변경 사항을 살펴볼 것입니다.

00:11:27.000 --> 00:11:33.000
새로운 iOS 및 iPadOS API로 EDR을 선택하는 과정은 macOS의 과정과 동일합니다.

00:11:33.000 --> 00:11:39.000
따라서, 이미 앱의 macOS 빌드에 대한 EDR 지원이 있다면, 변경할 필요가 없습니다.

00:11:39.000 --> 00:11:52.000
EDR을 선택하려면 CAMetalLayer를 사용하고 있는지, 해당 레이어에 적절한 플래그와 태그를 설정하고, 지원되는 EDR 형식으로 밝은 콘텐츠가 있는지 확인해야 합니다.

00:11:52.000 --> 00:11:56.000
먼저, 콘텐츠를 렌더링할 CAMetalLayer를 가져가세요.

00:11:56.000 --> 00:12:02.000
그 레이어에서 wantsExtendedDynamicRange Content 플래그를 활성화하고 싶을 것입니다.

00:12:02.000 --> 00:12:08.000
그런 다음, 같은 레이어에서 픽셀 형식과 CGColorSpace의 지원되는 조합을 설정해야 합니다.

00:12:08.000 --> 00:12:14.000
어떤 종류의 콘텐츠와 어떻게 소싱하는지에 따라, 특정 픽셀 형식과 색상 공간은 다를 것입니다.

00:12:14.000 --> 00:12:22.000
우리의 경우, 우리는 이미지를 16비트 부동 소수점 버퍼에 로드했고, 여기서 확장된 선형 디스플레이 P3 색상 공간과 일치하도록 선택했습니다.

00:12:22.000 --> 00:12:28.000
iOS는 선형 색상 공간과 결합된 16비트 부동 소수점 픽셀 버퍼에서 EDR 렌더링을 지원합니다.

00:12:28.000 --> 00:12:33.000
하지만 이러한 조합 중 하나를 사용하기로 선택한다면, 색 공간의 확장된 변형을 사용해야 합니다.

00:12:33.000 --> 00:12:36.000
그렇지 않으면, 당신의 콘텐츠는 SDR로 잘릴 것입니다.

00:12:36.000 --> 00:12:42.000
iOs는 또한 앞서 간단히 언급한 10비트 패키지 BGRA 픽셀 버퍼를 지원합니다.

00:12:42.000 --> 00:12:48.000
이러한 버퍼는 이 차트에 설명된 대로 PQ 또는 HLG 색상 공간으로 렌더링할 수 있습니다.

00:12:48.000 --> 00:13:01.000
이 섹션에서는 wantsExtendedDynamicRangeContent 플래그와 EDR을 지원하는 다양한 픽셀 형식 및 색상 공간을 포함하여 EDR 렌더링을 지원하기 위해 렌더링 레이어에 필요한 최소 코드 변경 사항을 다루었습니다.

00:13:01.000 --> 00:13:08.000
이 시점에서, 만약 당신이 메탈 텍스처를 렌더링한다면, 우리는 이전 섹션에서 이 섹션의 CAMetalLayer로 공급했고, 우리는 EDR을 렌더링할 것입니다.

00:13:08.000 --> 00:13:11.000
하지만 우리가 할 수 있는 몇 가지 트릭이 더 있다.

00:13:11.000 --> 00:13:16.000
개요에서 언급했듯이, EDR의 기본 동작은 현재 EDR 헤드룸에 고정하는 것이다.

00:13:16.000 --> 00:13:23.000
헤드룸이 EDR 콘텐츠를 렌더링하는 것을 정당화할 만큼 충분히 높지 않다고 결정하고 대신 SDR 경로로 내려갈 수 있는 경우가 있습니다.

00:13:23.000 --> 00:13:28.000
또는 표시하기 전에 현재 헤드룸을 사용하여 콘텐츠를 톤 매핑하고 싶을 때.

00:13:28.000 --> 00:13:38.000
두 경우 모두, iOS에는 이제 헤드룸 쿼리를 지원하는 새로운 API가 있으며, 이 섹션에서는 통화와 macOS와 어떻게 다른지 검토하여 그러한 결정을 더 잘 내릴 수 있습니다.

00:13:38.000 --> 00:13:42.000
macOS에서는 NSScreen에서 헤드룸 쿼리를 찾을 수 있습니다.

00:13:42.000 --> 00:13:52.000
NSScreen에는 디스플레이가 지원할 수 있는 최대 EDR 헤드룸, 현재 참조 프리셋의 최대 EDR 헤드룸 및 현재 EDR 헤드룸에 대한 쿼리가 있습니다.

00:13:52.000 --> 00:13:57.000
또한, macOS는 EDR 헤드룸이 변경될 때마다 알림을 제공합니다.

00:13:57.000 --> 00:14:09.000
그러나 iOS에서는 헤드룸 쿼리가 UIScreen에서 발견되며, NSScreen과 달리 디스플레이가 지원하는 최대 EDR 헤드룸과 현재 EDR 헤드룸에 대한 쿼리가 있습니다.

00:14:09.000 --> 00:14:17.000
또한, UIScreen은 참조 모드가 지원되고 참여되는지 여부를 나타내는 데 사용되는 참조 디스플레이 모드 상태를 제공합니다.

00:14:17.000 --> 00:14:24.000
UIScreen은 EDR 헤드룸 변경에 대한 알림을 제공하지 않지만 참조 모드 상태가 변경될 때마다 알림을 보냅니다.

00:14:24.000 --> 00:14:29.000
당신은 또한 최대 참조 헤드룸 쿼리가 목록에서 누락되었다는 것을 알 수 있습니다.

00:14:29.000 --> 00:14:37.000
전용 쿼리를 사용하는 대신, 참조 모드 상태가 참조 모드가 활성화되었음을 나타낼 때 잠재적인 최대 헤드룸을 쿼리하여 값을 결정할 수 있습니다.

00:14:37.000 --> 00:14:42.000
헤드룸을 쿼리하는 방법에 대한 더 나은 느낌을 얻기 위해 샘플 코드를 살펴봅시다.

00:14:42.000 --> 00:14:48.000
UIScreen에서 디스플레이의 가능한 최대 헤드룸을 보기 위해 potentialEDRHeadroom을 쿼리할 수 있습니다.

00:14:48.000 --> 00:14:55.000
이 값이 너무 낮다고 결정하면, 대신 SDR 경로를 렌더링하여 처리 능력을 절약할 수 있습니다.

00:14:55.000 --> 00:15:01.000
그런 다음, EDR 경로를 결정했다면, 렌더링 대리자 또는 정기적으로 예약된 드로우 콜을 가질 수 있습니다.

00:15:01.000 --> 00:15:10.000
이 통화에서, 우리는 currentEDRHeadroom을 쿼리하고 그 중 어느 것도 헤드룸을 초과하지 않도록 콘텐츠를 톤 맵으로 매핑하여 클립하지 않을 수 있습니다.

00:15:10.000 --> 00:15:21.000
참조 모드 상태를 알고 싶다면, UIScreen.referenceDisplayMode StatusDidChangeNotification을 사용하여 상태가 변경될 때마다 알림을 받기 위해 등록할 수 있습니다.

00:15:21.000 --> 00:15:30.000
그런 다음 상태가 바뀔 때마다 새로운 상태와 새로운 잠재적 EDR 헤드룸을 얻고 렌더링에 대한 추가 결정을 내리는 데 사용할 수 있습니다.

00:15:30.000 --> 00:15:35.000
참조 모드 상태와 관련하여, 당신이 알아야 할 네 가지 고유한 상태가 있습니다.

00:15:35.000 --> 00:15:40.000
StatusEnabled는 참조 모드가 활성화되어 있고 예상대로 렌더링되고 있음을 나타냅니다.

00:15:40.000 --> 00:15:46.000
StatusLimited는 참조 모드가 활성화되어 있지만 어떤 이유로 일시적으로 참조 응답을 달성할 수 없음을 나타냅니다.

00:15:46.000 --> 00:15:55.000
이 상태가 발생하면, 사용자에게 참조 응답이 손상되었음을 알리는 참조 외 UI 알림이 수반됩니다.

00:15:55.000 --> 00:16:01.000
StatusNotEnabled는 이 장치에서 참조 모드가 지원되지만 활성화되지 않았음을 나타냅니다.

00:16:01.000 --> 00:16:06.000
그리고 마지막으로, StatusNotSupported는 이 장치에서 참조 모드가 지원되지 않음을 나타냅니다.

00:16:06.000 --> 00:16:16.000
이러한 새로운 API는 개발자에게 디스플레이의 현재 상태에 대한 더 깊은 통찰력을 제공하고 EDR 콘텐츠를 렌더링하는 방법에 대한 정보에 입각한 결정을 내리는 데 필요한 도구를 제공해야 합니다.

00:16:16.000 --> 00:16:24.000
이전 섹션에서는 콘텐츠를 톤 매핑하고 클리핑을 피하는 데 사용할 수 있는 현재 EDR 헤드룸을 포함한 다양한 헤드룸 매개 변수를 쿼리하는 방법을 다루었습니다.

00:16:24.000 --> 00:16:28.000
하지만 자신만의 톤 매핑 알고리즘을 파고들거나 구현하고 싶지 않다면 어떨까요?

00:16:28.000 --> 00:16:33.000
음, 비디오 콘텐츠의 경우, Apple의 내장 톤 매핑을 활용하고 싶을 수도 있습니다.

00:16:33.000 --> 00:16:44.000
콘텐츠에서 Apple의 톤 매핑을 활성화하려면, HDR10과 HLG 모두에 대한 메타데이터 생성자를 포함하는 CAEDR 메타데이터 인터페이스를 사용하여 그렇게 할 수 있습니다.

00:16:44.000 --> 00:16:51.000
톤 매핑이 모든 플랫폼에서 지원되지는 않지만 플랫폼에 이 지원이 있는지 확인할 수 있는 쿼리가 있다는 점에 유의하십시오.

00:16:51.000 --> 00:16:57.000
플랫폼이 톤 매핑을 지원하는지 확인하려면, CAEDRMetadata.isAvailable에 문의하세요.

00:16:57.000 --> 00:17:01.000
가능하다면, CAEDRMetadata를 인스턴스화해야 합니다.

00:17:01.000 --> 00:17:06.000
우리는 잠시 후에 특정 구성자를 검토할 것이지만, 지금은 이 단계를 건너뛰자.

00:17:06.000 --> 00:17:10.000
EDR 메타데이터가 있으면, 렌더링 중인 레이어에 적용하세요.

00:17:10.000 --> 00:17:16.000
이것은 제공된 메타데이터를 기반으로 시스템 톤 매퍼에 의해 처리되는 레이어를 선택할 것입니다.

00:17:16.000 --> 00:17:23.000
언급했듯이, HDR 비디오 형식에 특화된 많은 EDR 메타데이터 생성자가 있습니다.

00:17:23.000 --> 00:17:29.000
여기에 매개 변수를 받지 않는 HLG 메타데이터의 생성자가 있습니다.

00:17:29.000 --> 00:17:32.000
다음으로, 사용 가능한 두 개의 HDR10 생성자 중 하나입니다.

00:17:32.000 --> 00:17:45.000
이것은 세 가지 매개 변수를 사용합니다: 니트 단위의 마스터링 디스플레이의 최소 휘도, 니트 단위의 마스터링 디스플레이의 최대 휘도, 그리고 니트 단위의 밝기에 대한 EDR 1.0의 콘텐츠 매핑을 나타내는 광학 출력 스케일.

00:17:45.000 --> 00:17:48.000
일반적으로, 우리는 이것을 100으로 설정했다.

00:17:48.000 --> 00:18:03.000
마지막으로, 우리는 MasterDisplayColourVolume SEI 메시지, ContentLightLevelInformation SEI 메시지 및 광학 출력 스케일을 취하는 두 번째 HDR10 생성자를 가지고 있으며, 이는 앞서 언급한 바와 같이 일반적으로 100니트로 설정됩니다.

00:18:03.000 --> 00:18:09.000
이 생성자 중 하나를 사용하여 CAEDRMetadata 객체를 만든 후, 애플리케이션의 CAMetalLayer에 설정하십시오.

00:18:09.000 --> 00:18:18.000
이로 인해 이 레이어에서 렌더링된 모든 콘텐츠가 시스템 톤 매퍼에 의해 처리되므로 매핑을 직접 수행하지 않고도 클리핑을 피할 수 있습니다.

00:18:18.000 --> 00:18:29.000
사용할 생성자는 전적으로 콘텐츠가 어떻게 제공되거나 작성되었는지에 따라 다르지만, 일반적으로 콘텐츠가 HLG 색상 공간에 있다면 HLG 생성자를 사용하고 싶을 것입니다.

00:18:29.000 --> 00:18:34.000
그리고 그것이 PQ 색상 공간에 있다면, HDR10 생성자를 사용하고 싶을 것입니다.

00:18:34.000 --> 00:18:41.000
콘텐츠가 이미 첨부된 SEI 메시지와 함께 제공되는 경우, 저자의 의도를 가장 잘 준수하기 위해 두 번째 HDR10 생성자를 사용하는 것이 좋습니다.

00:18:41.000 --> 00:18:45.000
그렇지 않으면, 당신은 첫 번째 생성자를 사용해야 할 것입니다.

00:18:45.000 --> 00:18:51.000
선형 색 공간을 사용하는 경우, 어떤 생성자를 사용하는지는 콘텐츠가 어떻게 작성되었는지에 따라 전적으로 달라집니다.

00:18:51.000 --> 00:19:00.000
따라서 Apple의 톤 매핑과 함께 사용하려는 경우, HDR10 및 HLG 메타데이터에 관한 개발자 문서를 읽는 것이 좋습니다.

00:19:00.000 --> 00:19:03.000
이제 Pixelmator와 EDR의 채택을 살펴봅시다.

00:19:03.000 --> 00:19:07.000
EDR 덕분에, 우리는 더 생생하고 사실적인 방식으로 이미지를 렌더링할 수 있습니다.

00:19:07.000 --> 00:19:18.000
예를 들어, RAW 사진을 열고 노출과 하이라이트를 늘리면, 가장 밝은 영역의 세부 사항은 SDR이라고도 알려진 디스플레이의 표준 동적 범위를 사용하여 렌더링할 수 없습니다.

00:19:18.000 --> 00:19:23.000
이제, 우리가 EDR을 켜면, SDR 흰색을 넘어선 모든 세부 사항을 볼 수 있습니다.

00:19:23.000 --> 00:19:28.000
캔버스의 SDR 색상에 비해 EDR 콘텐츠가 얼마나 더 생생하게 나타나는지 주목하세요.

00:19:28.000 --> 00:19:34.000
EDR을 끄면 SDR과 EDR의 시각적 차이를 더욱 분명하게 만들 것이다.

00:19:34.000 --> 00:19:37.000
그리고 그것으로, 그 세션은 끝났다.

00:19:37.000 --> 00:19:41.000
이 강연에서, 우리는 iOS와 iPadOS에 제공되는 몇 가지 새롭고 흥미로운 기능을 다루었습니다.

00:19:41.000 --> 00:19:54.000
우리는 EDR에 대한 빠른 재교육을 제공하고, 이미지 I/O로 HDR 이미지를 읽고 금속 텍스처로 변환하기 위한 샘플 워크플로우를 살펴보고, SDR로 클리핑하지 않고 텍스처를 렌더링할 수 있도록 EDR을 선택하는 방법을 살펴보았습니다.

00:19:54.000 --> 00:20:06.000
우리는 또한 헤드룸 쿼리 API와 EDR 렌더링에 대한 정보에 입각한 결정을 내리는 데 있어 유용성, 그리고 인기 있는 HDR 형식에 대한 Apple의 시스템 제공 톤 매핑을 선택하는 방법에 대해 간략하게 언급했습니다.

00:20:06.000 --> 00:20:12.000
EDR에 대한 더 나은 이해와 iOS 및 iPadOS 앱에서 채택하는 방법을 통해 이 이야기에서 벗어나기를 바랍니다.

00:20:12.000 --> 00:20:22.000
일반적으로 HDR 또는 EDR 콘텐츠 작업에 대해 더 알고 싶다면, 전년도의 몇 가지 세션과 제가 추천하고 싶은 몇 가지 세션이 있습니다.

00:20:22.000 --> 00:20:25.000
그렇긴 하지만, "iOS에서 EDR 탐색" 세션에 참석해 주셔서 감사합니다.

00:20:25.000 --> 00:20:27.000
그리고 멋진 WWDC를 보내세요!

00:20:27.000 --> 23:59:59.000
♪

