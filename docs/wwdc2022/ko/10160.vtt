WEBVTT

00:00:00.000 --> 00:00:03.000
♪ 부드러운 기악 힙합 음악 ♪

00:00:03.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:14.000
안녕하세요, 제 이름은 Keyi Yu이고, 저는 Metal Ecosystem 팀의 엔지니어입니다.

00:00:14.000 --> 00:00:17.000
오늘, metal-cpp를 소개하게 되어 기쁩니다.

00:00:17.000 --> 00:00:25.000
우리는 C++를 사용하고 Apple 플랫폼용 Metal 애플리케이션을 구축하고자 하는 모든 사람을 위해 metal-cpp를 만들었습니다.

00:00:25.000 --> 00:00:31.000
Metal-cpp는 C++ 애플리케이션을 Metal에 연결하는 낮은 오버헤드 라이브러리입니다.

00:00:31.000 --> 00:00:43.000
먼저, metal-cpp가 무엇이고 어떻게 작동하는지에 대한 개요부터 시작한 다음, Objective-C 객체의 수명 주기에 대한 몇 가지 세부 사항을 다룰 것입니다.

00:00:43.000 --> 00:00:52.000
C++와 Objective-C는 수명 주기를 약간 다르게 처리하며, 이러한 차이점을 처리하는 방법을 보여드리겠습니다.

00:00:52.000 --> 00:01:01.000
Xcode와 metal-cpp에는 앱에서 객체 수명 주기를 관리하는 데 도움이 되는 훌륭한 유틸리티가 있습니다.

00:01:01.000 --> 00:01:09.000
그리고 마지막으로, C++ 코드를 Objective-C 클래스와 통합하는 방법을 보여드리겠습니다.

00:01:09.000 --> 00:01:13.000
그래서 여기 metal-cpp와 그것이 어떻게 작동하는지 살펴보겠습니다.

00:01:13.000 --> 00:01:23.000
메탈은 Apple 플랫폼에서 가속화된 그래픽과 컴퓨팅의 기초이며, 앱과 게임이 GPU의 놀라운 힘을 활용할 수 있도록 합니다.

00:01:23.000 --> 00:01:29.000
그것은 원래 Objective-C가 제공하는 강력한 기능과 관습을 사용하여 설계되었다.

00:01:29.000 --> 00:01:37.000
하지만 코드 베이스가 C++에 있다면, 코드와 Metal의 Objective-C 코드 사이에 연결할 무언가가 필요할 수 있습니다.

00:01:37.000 --> 00:01:39.000
메탈-cpp를 소개합니다!

00:01:39.000 --> 00:01:45.000
그것은 당신의 C++ 애플리케이션과 Objective-C Metal 사이의 허브 역할을 합니다.

00:01:45.000 --> 00:01:56.000
애플리케이션에서 metal-cpp를 사용하면 C++에서 Metal 클래스와 함수를 사용할 수 있으며, metal-cpp는 런타임에 Objective-C 함수를 호출하는 데 도움이 될 수 있습니다.

00:01:56.000 --> 00:02:00.000
Metal-cpp는 가벼운 Metal C++ 래퍼이다.

00:02:00.000 --> 00:02:07.000
인라인 함수 호출이 있는 헤더 전용 라이브러리로 구현되기 때문에 가볍다고 말합니다.

00:02:07.000 --> 00:02:16.000
Objective-C API에 대한 C++ 호출의 일대일 매핑을 구현하여 Metal API의 100% 커버리지를 제공합니다.

00:02:16.000 --> 00:02:22.000
이를 위해, metal-cpp는 Foundation과 CoreAnimation 프레임워크의 일부를 포장한다.

00:02:22.000 --> 00:02:29.000
아파치 2 라이선스에 따라 오픈 소스이므로 라이브러리를 수정하고 애플리케이션에 쉽게 포함할 수 있습니다.

00:02:29.000 --> 00:02:35.000
Metal-cpp는 C를 사용하여 Objective-C 런타임으로 직접 호출합니다.

00:02:35.000 --> 00:02:42.000
이것은 Objective-C 컴파일러가 Objective-C 메소드를 실행하는 데 사용하는 것과 정확히 동일한 메커니즘이다.

00:02:42.000 --> 00:02:47.000
그래서 이 포장지에는 오버헤드가 거의 없다.

00:02:47.000 --> 00:02:57.000
Metal-cpp는 C++와 Objective-C 호출의 일대일 매핑을 구현하기 때문에, 동일한 코코아 메모리 관리 규칙을 따른다.

00:02:57.000 --> 00:02:59.000
나는 이것을 나중에 더 자세히 논의할 것이다.

00:02:59.000 --> 00:03:10.000
이 일대일 매핑은 또한 GPU 프레임 캡처와 Xcode 디버거를 포함한 모든 개발자 도구가 원활하게 작동할 수 있게 해준다.

00:03:10.000 --> 00:03:15.000
이것들은 metal-cpp로 삼각형을 그리는 데 필요한 일련의 호출이다.

00:03:15.000 --> 00:03:22.000
C++에 익숙하다면, 언어 구문에 대해 걱정할 필요가 없기 때문에 메탈을 배우기에 좋은 시기입니다.

00:03:22.000 --> 00:03:33.000
이미 Objective-C와 함께 Metal을 사용했다면, 함수 호출 측면에서 Metal과 metal-cpp의 Objective-C 인터페이스 사이에는 거의 차이가 없습니다.

00:03:33.000 --> 00:03:38.000
나는 metal-cpp를 사용하는 것이 얼마나 쉬운지 보여줄 것이다.

00:03:38.000 --> 00:03:45.000
먼저, 나는 명령 버퍼를 만들고, GPU가 실행할 명령으로 채울 것이다.

00:03:45.000 --> 00:03:51.000
C++의 원시 포인터를 Objective-C의 ID 매핑으로 사용할 수 있습니다.

00:03:51.000 --> 00:03:57.000
렌더링 명령 인코더를 만들고 명령 버퍼로 렌더링 명령을 작성할 수 있습니다.

00:03:57.000 --> 00:04:06.000
C++ 함수 renderCommandEncoder와 Objective-C 메서드 renderCommandEncoder WithDescriptor는 동일합니다.

00:04:06.000 --> 00:04:11.000
유일한 차이점은 언어의 이름 규칙이다.

00:04:11.000 --> 00:04:19.000
그런 다음 정점과 프래그먼트 셰이더 및 기타 다양한 렌더링 상태를 포함하는 렌더링 파이프라인 상태 객체를 설정합니다.

00:04:19.000 --> 00:04:24.000
그런 다음 나는 단일 삼각형을 렌더링하기 위해 그리기 호출을 인코딩한다.

00:04:24.000 --> 00:04:29.000
그런 다음 나는 렌더링 명령 인코딩을 마쳤다는 것을 나타낸다.

00:04:29.000 --> 00:04:33.000
나는 드로어블을 제시하므로, 삼각형이 화면에 표시됩니다.

00:04:33.000 --> 00:04:36.000
마지막으로, 나는 명령 버퍼를 커밋한다.

00:04:36.000 --> 00:04:40.000
이것은 GPU에 내 명령을 실행하기 시작할 수 있다고 말한다.

00:04:40.000 --> 00:04:45.000
분명히, metal-cpp와 Objective-C Metal은 거의 동일하다.

00:04:45.000 --> 00:04:56.000
이제 metal-cpp로 언어 구문에 대해 걱정할 필요가 없습니다. Metal 문서를 직접 살펴보고 Metal의 개념과 사용법을 배울 수 있습니다.

00:04:56.000 --> 00:05:00.000
당신은 이미 이 지연된 조명 샘플을 가지고 놀았을 수도 있습니다.

00:05:00.000 --> 00:05:06.000
우리는 이제 금속 cpp를 사용하는 이 지연 조명 샘플의 새 버전을 제공합니다.

00:05:06.000 --> 00:05:11.000
우리는 이것이 당신이 실제로 metal-cpp로 코딩하는 방법을 배우는 데 도움이 되기를 바랍니다.

00:05:11.000 --> 00:05:25.000
또한 Metal API를 소개하고 다양한 작업을 수행하는 방법을 보여주는 일련의 증분 C++ 샘플을 소개하게 되어 기쁩니다.

00:05:25.000 --> 00:05:30.000
이제 metal-cpp에 대해 조금 알게 되었으니, 실제로 어떻게 사용하나요?

00:05:30.000 --> 00:05:32.000
우리는 작년에 metal-cpp를 출판했다.

00:05:32.000 --> 00:05:36.000
여기 다운로드와 지침을 찾을 수 있는 웹 페이지가 있습니다.

00:05:36.000 --> 00:05:39.000
네가 취해야 할 단계를 보여줄게.

00:05:39.000 --> 00:05:44.000
Metal-cpp를 다운로드한 후, Xcode에게 어디서 찾을 수 있는지 말해야 합니다.

00:05:44.000 --> 00:05:49.000
여기, 나는 현재 프로젝트에 metal-cpp를 넣었다.

00:05:49.000 --> 00:05:56.000
그런 다음, C++17 이상을 C++ 언어 방언으로 설정해야 합니다.

00:05:56.000 --> 00:06:03.000
다음으로, 프로젝트에 세 가지 프레임워크를 추가하세요: 파운데이션, 쿼츠코어, 메탈.

00:06:03.000 --> 00:06:09.000
이제 그 프레임워크의 C++ 인터페이스를 사용하기 전에 해야 할 일은 단 하나뿐이다.

00:06:09.000 --> 00:06:12.000
Metal-cpp에는 세 개의 헤더가 있다.

00:06:12.000 --> 00:06:19.000
Metal-cpp는 헤더 전용 라이브러리이기 때문에, 헤더 파일을 가져오기 전에 구현을 생성해야 합니다.

00:06:19.000 --> 00:06:29.000
이렇게 하려면, 세 개의 매크로를 정의하세요: NS_PRIVATE_IMPLEMENTATION, CA_PRIVATE_IMPLEMENTATION, 그리고 MTL_PRIVATE_IMPLEMENTATION.

00:06:29.000 --> 00:06:37.000
Metal-cpp가 후드 아래의 매크로로 무엇을 하는지에 관심이 있다면, metal-cpp 폴더에 있는 헤더 브리지 파일을 확인하세요.

00:06:37.000 --> 00:06:42.000
헤더를 별도로 사용하거나 단일 헤더에 넣을 수 있습니다.

00:06:42.000 --> 00:06:45.000
필요할 때마다 헤더 파일을 가져올 수 있습니다.

00:06:45.000 --> 00:06:52.000
하지만 NS, CA 또는 MTL_PRIVATE_IMPLEMENTATION 매크로를 두 번 이상 정의하지 마세요.

00:06:52.000 --> 00:06:56.000
그렇지 않으면, 중복 정의 오류가 발생할 수 있습니다.

00:06:56.000 --> 00:07:12.000
Metal-cpp를 효과적으로 사용하려면 코코아의 메모리 관리 규칙, 객체 수명 주기를 관리하는 데 도움이 되는 훌륭한 유틸리티를 사용하는 방법, 다른 프레임워크와 인터페이스할 때 애플리케이션 아키텍처를 설계하는 방법을 알아야 합니다.

00:07:12.000 --> 00:07:16.000
나는 객체 수명 주기 관리부터 시작할 것이다.

00:07:16.000 --> 00:07:21.000
애플리케이션이 작동하는 동안, 당신은 일반적으로 메모리를 할당하고 해제해야 합니다.

00:07:21.000 --> 00:07:27.000
또한 명령 버퍼, 파이프라인 객체 및 리소스를 관리해야 합니다.

00:07:27.000 --> 00:07:33.000
이 메모리를 관리하기 위해, 오브젝티브-C와 코코아 객체는 참조 수를 포함한다.

00:07:33.000 --> 00:07:36.000
이것은 금속 cpp에도 존재한다.

00:07:36.000 --> 00:07:39.000
참조 계산은 기억을 관리하는 데 도움이 됩니다.

00:07:39.000 --> 00:07:43.000
참조 카운팅을 사용하여, 모든 객체는 retainCount 속성을 포함한다.

00:07:43.000 --> 00:07:51.000
앱의 구성 요소는 상호 작용하는 물체를 유지하기 위해 수를 늘리고 완료되면 개체 수를 줄입니다.

00:07:51.000 --> 00:07:56.000
retainCount가 0에 도달하면, 런타임은 객체의 할당을 해제한다.

00:07:56.000 --> 00:07:59.000
Objective-C에는 두 가지 유형의 참조 계산이 있습니다.

00:07:59.000 --> 00:08:06.000
하나는 수동 유지-릴리스 -- MRR이라고 불린다; 다른 하나는 자동 참조 계산 -- ARC이다.

00:08:06.000 --> 00:08:16.000
ARC 기능으로 코드를 컴파일할 때, 컴파일러는 당신이 만든 참조를 가져와 기본 메모리 관리 메커니즘에 대한 호출을 자동으로 삽입합니다.

00:08:16.000 --> 00:08:20.000
금속-cpp 물체는 수동으로 유지되고 방출된다.

00:08:20.000 --> 00:08:26.000
따라서 언제 물체를 유지하고 방출해야 하는지 알기 위해서는 코코아의 규칙을 이해해야 합니다.

00:08:26.000 --> 00:08:34.000
C++에서 객체를 만드는 것과는 달리, metal-cpp 객체는 새로 생성되거나 삭제로 파괴되지 않습니다.

00:08:34.000 --> 00:08:45.000
코코아의 규칙을 사용하면 alloc, new, copy, mutableCopy 또는 create로 시작하는 메서드로 만드는 모든 객체를 소유할 수 있습니다.

00:08:45.000 --> 00:08:49.000
유지를 사용하여 물체의 소유권을 가질 수 있습니다.

00:08:49.000 --> 00:08:54.000
더 이상 필요하지 않을 때, 소유한 물건의 소유권을 포기해야 합니다.

00:08:54.000 --> 00:08:58.000
즉시 출시하거나 나중에 출시할 수 있습니다.

00:08:58.000 --> 00:09:05.000
이중 자유의 위험을 감수하기 때문에 소유하지 않은 물건의 소유권을 포기해서는 안 됩니다.

00:09:05.000 --> 00:09:10.000
다음으로, 나는 이 코코아 컨벤션의 예를 살펴보겠습니다.

00:09:10.000 --> 00:09:16.000
클래스 A에서, 메서드는 alloc을 사용하여 객체를 만들고 init를 사용하여 이 객체를 초기화합니다.

00:09:16.000 --> 00:09:20.000
기억하세요, 물체에 대해 두 번 호출하지 마세요.

00:09:20.000 --> 00:09:25.000
클래스 A는 소유권을 가지고 그것을 할당할 책임이 있다.

00:09:25.000 --> 00:09:29.000
이제 이 물체의 보유 수는 하나입니다.

00:09:29.000 --> 00:09:35.000
다음으로, 클래스 B는 객체를 얻기 위해 retain을 사용하고 이 객체의 소유권을 갖는다.

00:09:35.000 --> 00:09:42.000
지금까지, 나는 오렌지 큐브로 대표되는 이 물체의 소유권을 공유하는 두 개의 물체를 가지고 있다.

00:09:42.000 --> 00:09:46.000
보유 횟수는 하나 증가한다.

00:09:46.000 --> 00:09:53.000
클래스 A는 더 이상 이 객체가 필요하지 않으므로, 클래스 A는 수동으로 릴리스를 호출해야 합니다.

00:09:53.000 --> 00:09:56.000
결과적으로, 보유 수는 하나 감소한다.

00:09:56.000 --> 00:10:00.000
이제, 클래스 B만이 객체를 소유하고 있다.

00:10:00.000 --> 00:10:03.000
좋아, 마침내, 클래스 B도 이 객체를 공개하고 싶어해.

00:10:03.000 --> 00:10:08.000
이제 유지 카운트가 0이므로, 런타임은 객체를 해제합니다.

00:10:08.000 --> 00:10:13.000
다음은 클래스 B의 메서드가 객체를 반환하는 상황입니다.

00:10:13.000 --> 00:10:16.000
당신은 여전히 나머지 프로그램에서 이 객체가 필요합니다.

00:10:16.000 --> 00:10:26.000
즉, 클래스 B의 메소드에서 객체의 소유권을 포기하고 싶지만, 즉시 할당되는 것을 원하지 않습니다.

00:10:26.000 --> 00:10:30.000
이 경우, 클래스 B에서 자동 릴리스를 호출해야 합니다.

00:10:30.000 --> 00:10:36.000
유지 수는 자동 해제를 호출한 후에도 여전히 하나이므로, 나중에 객체를 사용할 수 있습니다.

00:10:36.000 --> 00:10:44.000
여기 질문이 있습니다: 클래스 B가 더 이상 이 객체를 소유하지 않기 때문에, 누가 그것을 할당할 책임이 있습니까?

00:10:44.000 --> 00:10:49.000
파운데이션 프레임워크는 AutoreleasePool이라고 불리는 중요한 객체를 제공한다.

00:10:49.000 --> 00:10:54.000
Autorelease API는 객체를 AutoreleasePool에 넣습니다.

00:10:54.000 --> 00:10:58.000
이제, AutoreleasePool은 객체의 소유권을 차지한다.

00:10:58.000 --> 00:11:04.000
AutoreleasePool은 AutoreleasePool이 파괴될 때 수신기의 보유 수를 감소시킨다.

00:11:04.000 --> 00:11:08.000
당신은 자동 해제된 객체를 만들 수 있는 유일한 사람이 아닙니다.

00:11:08.000 --> 00:11:13.000
금속은 작동의 일환으로 여러 개의 자동 방출 물체를 만든다.

00:11:13.000 --> 00:11:21.000
임시 객체를 만드는 모든 방법은 후드 아래에서 자동 해제를 호출하여 자동 해제 풀에 추가합니다.

00:11:21.000 --> 00:11:24.000
그것들을 풀어주는 것은 AutoreleasePool의 책임이다.

00:11:24.000 --> 00:11:30.000
즉, AutoreleasePool을 사용하면 더 우아한 방식으로 코딩할 수 있습니다.

00:11:30.000 --> 00:11:33.000
주요 애플리케이션을 위한 자동 해제 풀을 가질 수 있습니다.

00:11:33.000 --> 00:11:41.000
또한 프로그램의 작업 세트를 줄이기 위해 더 작은 범위에서 추가 AutoreleasePool을 만들고 관리하는 것이 좋습니다.

00:11:41.000 --> 00:11:45.000
또한 당신이 만드는 모든 스레드에 대해 자동 해제 풀이 필요합니다.

00:11:45.000 --> 00:11:51.000
다음은 자동 해제 풀과 자동 해제된 객체를 사용하는 방법을 보여주는 예입니다.

00:11:51.000 --> 00:12:00.000
이 샘플에서, AutoreleasePool은 alloc에 의해 생성되며, 이는 당신이 소유권을 가지고 수동으로 해제되어야 함을 의미합니다.

00:12:00.000 --> 00:12:03.000
이제 우리는 AutoreleasePool을 가지고 있다.

00:12:03.000 --> 00:12:07.000
처음에 논의했듯이, 명령 버퍼를 만들어야 합니다.

00:12:07.000 --> 00:12:13.000
그것은 alloc이나 create로 만들어지지 않았기 때문에, 당신은 그것을 소유하지 않습니다.

00:12:13.000 --> 00:12:19.000
대신, 그것은 메탈이 만든 자동 방출된 물체이다.

00:12:19.000 --> 00:12:22.000
이 명령 버퍼는 AutoreleasePool에 넣을 것이다.

00:12:22.000 --> 00:12:26.000
그것을 할당 해제하는 것은 AutoreleasePool의 책임이다.

00:12:26.000 --> 00:12:31.000
AutoreleasePool을 출시할 때까지 원하는 대로 사용할 수 있습니다.

00:12:31.000 --> 00:12:35.000
그런 다음 RenderPassDescriptor를 만들어야 합니다.

00:12:35.000 --> 00:12:40.000
이 RenderPassDescriptor는 AutoreleasePool에도 들어갈 것이다.

00:12:40.000 --> 00:12:43.000
RenderCommandEncoder와 동일합니다.

00:12:43.000 --> 00:12:46.000
그것은 또한 메탈이 만든 자동 방출 물체이기도 하다.

00:12:46.000 --> 00:12:49.000
이 currentDrawable 객체를 잊지 마세요.

00:12:49.000 --> 00:12:53.000
그것은 AutoreleasePool에도 들어갈 것이다.

00:12:53.000 --> 00:12:59.000
코드의 끝에서, 나는 pPool-&gt;release를 사용하여 AutoreleasePool을 출시한다.

00:12:59.000 --> 00:13:14.000
할당 해제되기 전에 AutoreleasePool은 소유한 모든 것을 해제하며, 이 경우 CommandBuffer, RenderPassDescriptor, RenderCommandEncoder 및 currentDrawable을 해제합니다.

00:13:14.000 --> 00:13:16.000
그런 다음 AutoreleasePool이 출시됩니다.

00:13:16.000 --> 00:13:22.000
지금까지, 당신은 코코아의 관습, 자동 해제 객체, 그리고 자동 해제 풀을 알게 되었다.

00:13:22.000 --> 00:13:35.000
메모리 누수와 좀비 객체를 피하기 위해 객체 수명 주기를 올바르게 관리하는 것이 중요하며, 이러한 문제를 피하고 디버깅하는 데 도움이 되는 훌륭한 도구가 있습니다.

00:13:35.000 --> 00:13:40.000
나는 두 가지 유틸리티에 집중할 것이다: NS::SharedPtr와 NSZombie.

00:13:40.000 --> 00:13:46.000
NS::SharedPtr은 객체 수명 주기를 관리하는 데 도움이 되는 새로운 유틸리티입니다.

00:13:46.000 --> 00:13:51.000
금속-cpp 폴더의 재단 프레임워크에서 찾을 수 있습니다.

00:13:51.000 --> 00:13:55.000
Std:shared_ptr와 정확히 같지 않다는 점에 유의하세요.

00:13:55.000 --> 00:14:03.000
따라서 C++ 표준 라이브러리에 의존하지 않으며 참조 수를 저장하는 데 추가 비용이 들지 않습니다.

00:14:03.000 --> 00:14:05.000
NS::SharedPtr의 내용은 다음과 같습니다.

00:14:05.000 --> 00:14:11.000
전송 및 유지 기능은 물체를 소비하려는 의도를 명확하게 표현한다.

00:14:11.000 --> 00:14:21.000
전송은 포인티의 참조 횟수를 늘리지 않고 SharedPtr을 생성하여 소유권을 SharedPtr로 효과적으로 이전합니다.

00:14:21.000 --> 00:14:25.000
유지 함수는 전달된 객체에 유지를 보낸다.

00:14:25.000 --> 00:14:36.000
이 기능을 사용하여 AutoreleasePools에 있는 개체를 유지하고 포인터의 소유자가 포인터의 수명 주기에 기득권을 가지고 있음을 표현하십시오.

00:14:36.000 --> 00:14:42.000
Get과 운영자-&gt;를 통해 예상대로 기본 객체에 액세스할 수 있습니다.

00:14:42.000 --> 00:14:51.000
SharedPtr 복사, 이동, 건설 및 할당 작업은 예상대로이며, 복사는 retainCount를 증가시킵니다.

00:14:51.000 --> 00:14:56.000
이동은 빠르며 일반적인 경우 보유 횟수에 영향을 미치지 않습니다.

00:14:56.000 --> 00:15:02.000
SharedPtrs는 항상 파괴 시 포인티에게 정확히 하나의 릴리스를 보냅니다.

00:15:02.000 --> 00:15:06.000
원한다면 분리 함수를 호출하여 이것을 피할 수 있습니다.

00:15:06.000 --> 00:15:14.000
맨 위로 돌아가서, 포인터를 전송하거나 유지하여 포인터를 만드는 것의 차이점을 아는 것이 중요합니다.

00:15:14.000 --> 00:15:22.000
그래서 TransferPtr의 경우, 참조 수가 1인 MRR 객체가 있다고 가정해 봅시다.

00:15:22.000 --> 00:15:30.000
TransferPtr 함수에 전달한 후, SharedPtr은 객체의 소유권을 차지하지만, retainCount는 변경되지 않습니다.

00:15:30.000 --> 00:15:40.000
포인터가 범위를 벗어나면, SharedPtr의 소멸자가 실행되고 MRR 객체에서 release를 호출하여 retainCount를 0으로 감소시킨다.

00:15:40.000 --> 00:15:43.000
또 다른 기능은 NS::RetainPtr이다.

00:15:43.000 --> 00:15:50.000
나중에 사용하고 싶기 때문에 객체의 할당을 피하고 싶다면, NS::RetainPtr을 사용해야 합니다.

00:15:50.000 --> 00:15:55.000
우리가 이 MRR 객체를 가지고 있다고 가정해 봅시다; retainCount는 하나입니다.

00:15:55.000 --> 00:16:00.000
RetainPtr 함수에 전달한 후, retainCount는 하나씩 증가합니다.

00:16:00.000 --> 00:16:06.000
범위가 부족한 후, 이 RetainPtr은 이 MRR 객체에 대한 릴리스를 호출합니다.

00:16:06.000 --> 00:16:09.000
그래서 리테이트카운트는 하나이다.

00:16:09.000 --> 00:16:13.000
일반적으로, NS::TransferPtr은 당신을 위해 객체의 소유권을 차지합니다.

00:16:13.000 --> 00:16:20.000
하지만 NS::RetainPtr은 할당 해제를 원하지 않을 때 객체를 유지하는 데 도움을 줍니다.

00:16:20.000 --> 00:16:34.000
이 두 함수에 객체를 전달할 때, NS::TransferPtr는 참조 수를 변경하지 않지만 NS::RetainPtr은 후드 아래에서 당신을 위해 유지를 호출할 때 참조 수를 하나씩 증가시킵니다.

00:16:34.000 --> 00:16:43.000
이 두 함수의 소멸자는 전달된 객체에 대한 릴리스를 호출하므로 참조 수가 하나 감소합니다.

00:16:43.000 --> 00:16:48.000
참조 수가 0에 도달하면, 객체는 런타임에 해제될 것이다.

00:16:48.000 --> 00:16:51.000
다음은 NS::TransferPtr의 예입니다.

00:16:51.000 --> 00:16:58.000
단일 삼각형을 그린 렌더링 패스에 대해 이야기했을 때, 나는 이 렌더링 파이프라인 상태가 필요했다.

00:16:58.000 --> 00:17:02.000
다음은 렌더링 파이프라인 상태 객체를 만들기 위한 호출입니다.

00:17:02.000 --> 00:17:05.000
이것들은 렌더링 파이프라인 설명자가 필요로 하는 속성이다.

00:17:05.000 --> 00:17:14.000
코코아의 관습에 따르면, 이러한 호출은 새로운 것으로 시작되기 때문에, 나는 이 물건들을 소유하고 있다.

00:17:14.000 --> 00:17:17.000
그래서 나는 이 물건들에 대한 석방을 요청해야 한다.

00:17:17.000 --> 00:17:27.000
NS::SharedPtr을 사용하면 NS::SharedPtrs가 이러한 객체의 소유권을 차지하기 때문에 MRR 객체에 대한 릴리스를 요청할 필요가 없습니다.

00:17:27.000 --> 00:17:33.000
그래서 여기서, 나는 TransferPtr 함수에 원시 포인터를 전달한다.

00:17:33.000 --> 00:17:38.000
그렇게 한 후, 이전 슬라이드에서 했던 것처럼 릴리스를 호출할 필요가 없습니다.

00:17:38.000 --> 00:17:46.000
ARC에 익숙하다면, NS::SharedPtr와 함께 사용되는 MRR이 ARC를 사용하는 것과 유사하다는 것을 알 수 있습니다.

00:17:46.000 --> 00:17:50.000
메모리를 수동으로 처리할 때 사용 후 버그가 발생할 수 있습니다.

00:17:50.000 --> 00:17:55.000
그것들은 당신이 이미 출시된 물체를 사용하려고 할 때 발생합니다.

00:17:55.000 --> 00:17:58.000
NSZombie는 그 버그를 확인하는 좋은 방법이다.

00:17:58.000 --> 00:18:04.000
Use-after-free 버그가 발생하면, 중단점을 트리거하고 스택 추적을 제공합니다.

00:18:04.000 --> 00:18:08.000
환경 변수로 좀비를 매우 쉽게 활성화할 수 있습니다.

00:18:08.000 --> 00:18:11.000
그냥 NSZombieEnabled를 YES로 설정하세요.

00:18:11.000 --> 00:18:16.000
또는 Xcode를 사용하는 경우, 계획에서 좀비를 활성화할 수 있습니다.

00:18:16.000 --> 00:18:18.000
이게 작동하는 방식이야.

00:18:18.000 --> 00:18:25.000
동일한 렌더링 파이프라인 설정으로 새로운 렌더링 파이프라인 상태 객체를 만들고 싶습니다.

00:18:25.000 --> 00:18:34.000
그래서 이 새로운RenderPipelineState 함수에서, 나는 pDesc 객체를 재사용한다.

00:18:34.000 --> 00:18:40.000
실행을 클릭한 후, Xcode는 중단점을 트리거하고 스택 추적을 보여줍니다.

00:18:40.000 --> 00:18:43.000
그건 내가 뭔가 잘못되었다는 뜻이야.

00:18:43.000 --> 00:18:47.000
흠, 뭐가 문제야?

00:18:47.000 --> 00:18:57.000
아마도 NSZombie가 여기서 도울 수 있기 때문에, 나는 계획에서 NSZombie를 활성화한다.

00:18:57.000 --> 00:19:01.000
내가 프로그램을 다시 실행할 때, NSZombie는 중단점을 트리거한다.

00:19:01.000 --> 00:19:09.000
나는 콘솔 출력에서 새로운 것을 얻는다: "해제된 인스턴스로 전송된 메시지."

00:19:09.000 --> 00:19:12.000
오, 나는 이미 출시한 물건을 재사용했어.

00:19:12.000 --> 00:19:16.000
그리고 그것은 렌더링 파이프라인 설명자이다.

00:19:16.000 --> 00:19:21.000
그래서 나는 릴리스를 호출하기 전에 이 렌더링 파이프라인 설명자를 사용해야 한다.

00:19:21.000 --> 00:19:24.000
그렇게 함으로써, 나는 문제를 해결한다.

00:19:24.000 --> 00:19:31.000
더 많은 도구와 세부 사항은 올해의 강연인 "게임의 메모리를 프로파일하고 최적화하세요"에서 다룹니다.

00:19:31.000 --> 00:19:37.000
예를 들어, 악기의 할당에서 retainCount를 추적하는 방법을 배울 수 있습니다.

00:19:37.000 --> 00:19:40.000
Apple 플랫폼에서 다른 도구를 자유롭게 확인하세요.

00:19:40.000 --> 00:19:45.000
당신은 그들이 당신의 게임을 디버깅하고 성능을 향상시키는 데 도움을 줄 수 있다는 것을 알게 될 것입니다.

00:19:45.000 --> 00:19:50.000
이제 당신은 metal-cpp에서 객체 수명 주기를 관리하는 방법을 알고 있습니다.

00:19:50.000 --> 00:19:56.000
하지만 당신은 여전히 게임 컨트롤러와 오디오와 같은 다른 프레임워크와 인터페이스해야 할 수도 있습니다.

00:19:56.000 --> 00:19:59.000
이것들은 여전히 Objective-C에 있다.

00:19:59.000 --> 00:20:05.000
어떻게 그 API와 인터페이스하고 우아한 애플리케이션 아키텍처를 설계할 수 있나요?

00:20:05.000 --> 00:20:13.000
Objective-C에서 ViewController를 작성했지만, metal-cpp로 C++로 렌더러를 작성했다고 가정해 봅시다.

00:20:13.000 --> 00:20:18.000
ViewController에서 draw과 같은 렌더러 메소드를 호출해야 합니다.

00:20:18.000 --> 00:20:25.000
여기서의 도전은 두 언어를 멋지게 분리하지만 함께 작동하도록 하는 것이다.

00:20:25.000 --> 00:20:32.000
해결책은 Objective-C 파일에서 C++를 호출하는 어댑터 클래스를 만드는 것이다.

00:20:32.000 --> 00:20:40.000
이렇게 하면 기능을 구현하는 파일에서 Objective-C 또는 C++에 집중할 수 있습니다.

00:20:40.000 --> 00:20:45.000
예를 들어, Objective-C에서 RendererAdapter 클래스를 만들 수 있습니다.

00:20:45.000 --> 00:20:53.000
그리고 구현에서, 나는 ViewController에서 직접 호출할 수 있도록 Objective-C 메소드를 추가한다.

00:20:53.000 --> 00:21:00.000
인터페이스 내부에서, 나는 렌더러 객체에 대한 C++ 포인터를 선언한다.

00:21:00.000 --> 00:21:06.000
메소드의 본문 안에서, 나는 렌더러의 C++ 메소드를 직접 부른다.

00:21:06.000 --> 00:21:20.000
이 메서드는 MTK::View를 C++ 객체로 드로우 메서드로 전달해야 하므로 __bridge 키워드를 사용하여 뷰를 C++ 유형으로 캐스팅합니다.

00:21:20.000 --> 00:21:23.000
나중에 이 출연진에 대해 더 얘기할게.

00:21:23.000 --> 00:21:32.000
대조적으로, C++로 작성된 렌더러에서 Objective-C로 작성된 MTKView를 호출해야 합니다.

00:21:32.000 --> 00:21:35.000
그것도 도전적이야.

00:21:35.000 --> 00:21:39.000
마찬가지로, 해결책은 어댑터 클래스를 만드는 것이다.

00:21:39.000 --> 00:21:47.000
이 클래스를 사용하면 C++ 파일에서 C++ 인터페이스를 사용하여 Objective-C 메서드를 호출할 수 있습니다.

00:21:47.000 --> 00:21:50.000
예를 들어, 나는 ViewAdapter 클래스를 만들 수 있다.

00:21:50.000 --> 00:21:58.000
저는 C++로 인터페이스를 작성하므로, Renderer 클래스에서 C++ 뷰 메소드를 쉽게 호출할 수 있습니다.

00:21:58.000 --> 00:22:08.000
구현하는 동안, 나는 currentDrawable과 depthStencilTexture를 포함하여 MTKView에서 Objective-C 메소드를 부른다.

00:22:08.000 --> 00:22:11.000
여기에 __bridge 키워드가 있다는 것을 알 수 있습니다.

00:22:11.000 --> 00:22:16.000
나는 그것들을 사용하여 금속-cpp 물체와 Objective-C 물체 사이를 주조한다.

00:22:16.000 --> 00:22:27.000
처음에 배웠듯이, metal-cpp 객체는 수동으로 유지되고 해제되지만, Objective-C에 의해 생성된 객체는 자동 참조 계수를 사용합니다.

00:22:27.000 --> 00:22:33.000
물체를 MRR에서 ARC로 그리고 ARC에서 MRR로 이동해야 합니다.

00:22:33.000 --> 00:22:39.000
여기 Objective-C와 C++ 사이에서 캐스팅하는 데 도움이 될 수 있는 세 가지 유형의 브리지 캐스팅이 있습니다.

00:22:39.000 --> 00:22:47.000
그들은 또한 당신이 Objective-C와 metal-cpp 객체 사이에서 소유권을 이전하는 데 도움을 줄 수 있습니다.

00:22:47.000 --> 00:22:52.000
그들 사이에 소유권 이전은 없다.

00:22:52.000 --> 00:23:00.000
__Bridge_retained 캐스팅은 Objective-C 포인터를 metal-cpp 포인터에 캐스팅하고 ARC에서 소유권을 가져간다.

00:23:00.000 --> 00:23:07.000
__Bridge_transfer 캐스팅은 metal-cpp 포인터를 Objective-C로 옮기고 소유권을 ARC로 이전합니다.

00:23:07.000 --> 00:23:13.000
문제로 돌아가서, 당신은 금속-cpp 물체와 Objective-C 물체 사이를 던져야 합니다.

00:23:13.000 --> 00:23:18.000
소유권 이전이 없다면, __bridge cast를 사용할 수 있습니다.

00:23:18.000 --> 00:23:29.000
Metal-cpp에서 Objective-C 객체로 캐스팅하고 소유권을 Objective-C로 이전하려면, __bridge_transfer 캐스트를 사용해야 합니다.

00:23:29.000 --> 00:23:37.000
Objective-C에서 metal-cpp 객체로 캐스팅하고 ARC에서 소유권을 빼앗고 싶다면, __bridge_retained 캐스트를 사용해야 합니다.

00:23:37.000 --> 00:23:42.000
자산 로딩 코드를 활용하기 위해 MetalKit을 사용해야 하는 경우가 있습니다.

00:23:42.000 --> 00:23:53.000
그것은 내 C++ 응용 프로그램에서 금속-cpp 객체로 텍스처가 필요하지만, Objective-C 메소드에 의해 생성된다는 것을 의미합니다.

00:23:53.000 --> 00:23:59.000
수동으로 해제할 수 있도록 ARC에서 소유권을 이전할 수 있는 능력이 필요합니다.

00:23:59.000 --> 00:24:06.000
그리고 이 경우, 나는 __bridge_retained 캐스트를 선택해야 한다.

00:24:06.000 --> 00:24:13.000
카탈로그에서 텍스처를 로드하는 이 C++ 함수가 있으며 metal-cpp 텍스처를 반환하고 싶습니다.

00:24:13.000 --> 00:24:19.000
하지만 내부에서, 나는 MetalKit에서 몇 가지 Objective-C 기능을 호출하고 있다.

00:24:19.000 --> 00:24:23.000
텍스처 로더가 필요로 하는 옵션을 정의해야 합니다.

00:24:23.000 --> 00:24:31.000
그런 다음 MetalKit에서 Objective-C 메서드를 호출하여 텍스처 로더를 만듭니다.

00:24:31.000 --> 00:24:38.000
그 로더로, 나는 텍스처 객체를 만들고 카탈로그에서 텍스처를 로드할 수 있다.

00:24:38.000 --> 00:24:43.000
이 방법은 MetalKit의 Objective-C 방법이기도 하다.

00:24:43.000 --> 00:24:52.000
이제 나는 Objective-C 타입의 질감을 가지고 있어, 나는 그것을 금속-cpp 물체에 캐스팅하고 ARC에서 꺼내야 해.

00:24:52.000 --> 00:24:58.000
이 단계들을 염두에 두고, 코딩할 시간이며, 실제로 캐스팅이 어떻게 작동하는지 보여드리겠습니다.

00:24:58.000 --> 00:25:03.000
첫 번째 단계는 텍스처 로더에 필요한 텍스처 로더 옵션을 정의하는 것입니다.

00:25:03.000 --> 00:25:13.000
Metal-cpp 유형이 동일한 값으로 정의하기 때문에 metal-cpp 저장 모드와 사용을 Objective-C 유형으로 안전하게 캐스팅할 수 있습니다.

00:25:13.000 --> 00:25:16.000
여기서 나는 텍스처 로더를 만든다.

00:25:16.000 --> 00:25:24.000
나는 금속-cpp 객체인 장치를 가지고 있으며, 그것을 initWithDevice 방법으로 전달해야 한다.

00:25:24.000 --> 00:25:31.000
금속-cpp 물체는 Objective-C 물체이기 때문에, 나는 그것을 수신자 부담 물체처럼 던질 수 있다.

00:25:31.000 --> 00:25:35.000
소유권 이전은 없다.

00:25:35.000 --> 00:25:39.000
이제 저는 텍스처 로더 옵션과 텍스처 로더를 사용하여 텍스처를 만듭니다.

00:25:39.000 --> 00:25:44.000
그리고 나는 로드된 질감을 금속-cpp 객체로 반환하고 싶다.

00:25:44.000 --> 00:25:50.000
그래서 나는 그것을 ARC에서 꺼내서 해당 포인터 유형으로 캐스팅해야 한다.

00:25:50.000 --> 00:25:53.000
이것은 __bridge_retained 캐스트로 이루어집니다.

00:25:53.000 --> 00:25:57.000
이 후에, 나는 이 질감을 모든 금속-cpp 물체로 사용할 수 있다.

00:25:57.000 --> 00:26:00.000
나는 그것을 풀어줄 책임이 있다.

00:26:00.000 --> 00:26:08.000
이 섹션에서는 프로그램에서 두 가지 다른 언어를 처리하는 데 도움이 되는 어댑터 패턴을 제공했습니다.

00:26:08.000 --> 00:26:15.000
나는 또한 세 가지 유형의 캐스트로 Objective-C와 C++와 인터페이스하는 방법을 보여주었다.

00:26:15.000 --> 00:26:22.000
요약하자면, metal-cpp는 가볍고 매우 효율적인 Metal C++ 래퍼이다.

00:26:22.000 --> 00:26:37.000
저는 metal-cpp를 사용할 때 객체 수명 주기를 관리하는 방법, 우아한 방식으로 Objective-C와 인터페이스하는 방법, 그리고 개발자 도구가 디버깅하는 데 어떻게 도움이 될 수 있는지에 대해 이야기했습니다.

00:26:37.000 --> 00:26:41.000
Metal-cpp를 다운로드하고 지금 모든 놀라운 샘플을 가지고 플레이하세요!

00:26:41.000 --> 00:26:44.000
금속으로 무엇을 만들 수 있는지 보세요.

00:26:44.000 --> 00:26:49.000
우리는 당신의 C++ 애플리케이션이 모든 Apple 플랫폼에서 실행되기를 기대합니다.

00:26:49.000 --> 00:26:51.000
봐줘서 고마워!

00:26:51.000 --> 23:59:59.000
♪

