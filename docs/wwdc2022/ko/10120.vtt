WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:13.000
David Stites: 안녕하세요, "핵심 데이터 스키마를 발전시키세요"에 오신 것을 환영합니다.

00:00:13.000 --> 00:00:17.000
제 이름은 David Stites이고 저는 Core Data 팀의 엔지니어입니다.

00:00:17.000 --> 00:00:24.000
이 세션에서는 앱에서 핵심 데이터 스키마를 업데이트하고 마이그레이션하는 방법에 대해 이야기하게 되어 기쁩니다.

00:00:24.000 --> 00:00:41.000
이 세션의 의제는 스키마 마이그레이션이 무엇인지, 데이터 모델을 업데이트한 후 앱이 수행해야 하는 이유, 기존 스키마를 마이그레이션하는 방법, CloudKit과 스키마 마이그레이션이 어떻게 상호 작용하는지 배우는 것입니다.

00:00:41.000 --> 00:00:49.000
먼저, 스키마 마이그레이션은 무엇이며 데이터 모델을 업데이트할 때 앱이 마이그레이션해야 하는 이유.

00:00:49.000 --> 00:00:54.000
애플리케이션이 발전함에 따라, 데이터 모델을 변경해야 할 수도 있습니다.

00:00:54.000 --> 00:01:00.000
데이터 모델을 업데이트하려면 이러한 변경 사항이 기본 스토리지 스키마에서 구체화되어야 합니다.

00:01:00.000 --> 00:01:02.000
이 데이터 모델을 고려하세요.

00:01:02.000 --> 00:01:09.000
그것은 두 가지 속성, 유형 및 엔진 수를 가진 항공기 엔티티를 가지고 있다.

00:01:09.000 --> 00:01:13.000
이러한 속성은 기본 저장소에 반영됩니다.

00:01:13.000 --> 00:01:20.000
많은 승객 속성을 추가하면, 해당 저장소를 추가해야 합니다.

00:01:20.000 --> 00:01:25.000
마이그레이션 후, 변경 사항은 기본 저장소에 완전히 반영됩니다.

00:01:25.000 --> 00:01:36.000
기본 스토리지의 변경 사항을 마이그레이션하지 않고, Core Data는 새로 변경된 모델이 스토리지에 사용된 모델과 일치하지 않기 때문에 영구 저장소를 여는 것을 거부할 것입니다.

00:01:36.000 --> 00:01:45.000
호환되지 않는 저장소를 열려고 하면 NSPersistentStore- IncompatibleVersionHashError 코드로 오류가 발생합니다.

00:01:45.000 --> 00:01:51.000
이 오류를 받으면, 마이그레이션이 필요하다는 표시가 되어야 합니다.

00:01:51.000 --> 00:01:59.000
이제 스키마 마이그레이션이 무엇이고 앱을 발전시키는 데 왜 필수적인지 설명했으니, 마이그레이션이 어떻게 이루어지는지 알려드리겠습니다.

00:01:59.000 --> 00:02:08.000
Core Data에는 앱의 데이터 저장소를 현재 데이터 모델로 최신 상태로 유지하는 데 도움이 되는 데이터 마이그레이션 도구가 내장되어 있습니다.

00:02:08.000 --> 00:02:14.000
총체적으로, 이 도구들은 "경량 이동"이라고 불린다.

00:02:14.000 --> 00:02:17.000
경량 이동은 선호되는 이동 방법이다.

00:02:17.000 --> 00:02:27.000
경량 마이그레이션은 소스와 대상 관리 객체 모델의 차이점에서 마이그레이션을 자동으로 분석하고 추론합니다.

00:02:27.000 --> 00:02:36.000
런타임에, Core Data는 NSBundle 클래스의 .allBundles 및 .allFrameworks 메소드에서 반환된 번들에서 모델을 찾습니다.

00:02:36.000 --> 00:02:45.000
그런 다음 경량 마이그레이션은 매핑 모델을 생성하여 데이터베이스 스키마에서 앱의 변경 사항을 구체화합니다.

00:02:45.000 --> 00:02:54.000
경량 마이그레이션을 사용하려면 명백한 마이그레이션 패턴에 맞게 데이터 모델을 변경해야 합니다.

00:02:54.000 --> 00:03:11.000
속성과 관련된 가벼운 작업에는 속성을 추가하고, 속성을 제거하고, 선택 사항이 아닌 속성을 선택적으로 만들고, 선택 속성을 선택 사항이 아닌 것으로 만들고, 기본값을 정의하고, 속성의 이름을 바꾸는 것이 포함됩니다.

00:03:11.000 --> 00:03:20.000
속성의 이름을 바꾸려면, 대상 모델의 이름 바꾸기 식별자를 소스 모델의 해당 속성의 이름으로 설정하십시오.

00:03:20.000 --> 00:03:26.000
이름 바꾸기 식별자는 Xcode 데이터 모델 편집기의 속성 관리자에서 찾을 수 있습니다.

00:03:26.000 --> 00:03:32.000
예를 들어, 항공기 엔티티 색상 속성의 이름을 paintColor로 바꿀 수 있습니다.

00:03:32.000 --> 00:03:43.000
이름 바꾸기 식별자는 표준 이름을 생성하므로, 해당 속성에 이미 이름 바꾸기 식별자가 없는 한, 이름 바꾸기 식별자를 소스 모델의 속성 이름으로 설정하십시오.

00:03:43.000 --> 00:03:50.000
즉, 모델의 버전 2에서 속성의 이름을 바꾼 다음, 버전 3에서 다시 이름을 바꿀 수 있습니다.

00:03:50.000 --> 00:04:00.000
이름 변경은 버전 2에서 버전 3으로, 또는 버전 1에서 버전 3으로 올바르게 작동합니다.

00:04:00.000 --> 00:04:05.000
가벼운 이동은 또한 땀을 흘리지 않고 관계의 변화를 처리할 수 있다.

00:04:05.000 --> 00:04:10.000
새로운 관계를 추가하거나 기존 관계를 삭제할 수 있습니다.

00:04:10.000 --> 00:04:16.000
속성과 마찬가지로 이름 바꾸기 식별자를 사용하여 관계의 이름을 바꿀 수도 있습니다.

00:04:16.000 --> 00:04:29.000
또한, 관계 카디널리티를 변경할 수 있습니다. 예를 들어, a to-one에서 a to-many로, 또는 정렬되지 않은 to-many에서 주문 to-many로 마이그레이션하거나, 그 반대의 경우도 마찬가지입니다.

00:04:29.000 --> 00:04:34.000
엔티티도 경량 마이그레이션을 받을 자격이 있다고 추측했다면, 당신 말이 맞습니다.

00:04:34.000 --> 00:04:40.000
새 엔티티를 추가하고, 기존 엔티티를 제거하고, 엔티티의 이름을 바꿀 수 있습니다.

00:04:40.000 --> 00:04:48.000
또한 새로운 부모 또는 자식 엔티티를 만들고 엔티티 계층 내에서 속성을 위아래로 이동할 수 있습니다.

00:04:48.000 --> 00:04:53.000
엔티티를 계층 구조 안팎으로 옮길 수 있습니다.

00:04:53.000 --> 00:04:56.000
그러나 엔티티 계층을 병합할 수는 없습니다.

00:04:56.000 --> 00:05:03.000
두 개의 기존 엔티티가 소스에서 공통 부모를 공유하지 않으면, 대상에서 공통 부모를 공유할 수 없습니다.

00:05:03.000 --> 00:05:16.000
경량 마이그레이션은 두 가지 옵션 키로 제어됩니다: NSMigratePersistent- StoresAutomaticallyOption 및 NSInferMappingModelAutomaticallyOption.

00:05:16.000 --> 00:05:31.000
저장소가 영구 코디네이터에 추가될 때 이 두 키의 존재가 실제 값으로 설정되면 Core Data는 영구 저장소가 더 이상 현재 모델과 일치하지 않는 것을 감지하면 자동으로 경량 마이그레이션을 수행하게 됩니다.

00:05:31.000 --> 00:05:41.000
NSPersistentContainer 또는 NSPersistentStoreDescription을 사용하는 경우, 이러한 옵션은 자동으로 설정되며 아무것도 할 필요가 없습니다.

00:05:41.000 --> 00:06:08.000
NSPersistentStoreCoordinator .addPersistentStore (type:configuration:at:options:)와 같은 대체 API를 사용하는 경우, NSMigratePersistent- StoresAutomaticallyOption 및 NSInferMappingModelAutomaticallyOption을 YES 값으로 설정하여 옵션 사전을 설정하고 전달하여 경량 마이그레이션을 요청할 수

00:06:08.000 --> 00:06:16.000
Core Data는 영구 저장소가 더 이상 현재 모델과 일치하지 않는 것을 감지하면 자동으로 경량 마이그레이션을 수행합니다.

00:06:16.000 --> 00:06:19.000
이것이 코드에서 작동하는 방식은 다음과 같습니다.

00:06:19.000 --> 00:06:23.000
먼저, 나는 CoreData를 가져오고 관리되는 객체 모델을 만들 것이다.

00:06:23.000 --> 00:06:29.000
그런 다음, 방금 만든 모델을 사용하여 지속적인 매장 코디네이터를 만들 것입니다.

00:06:29.000 --> 00:06:36.000
내가 만든 옵션 사전을 참고하고 영구 코디네이터에 상점을 추가할 때 전달할 것이다.

00:06:36.000 --> 00:06:43.000
마지막으로, 필요한 경우 마이그레이션이 자동으로 발생하는 코디네이터에 상점을 추가할 것입니다.

00:06:43.000 --> 00:06:52.000
어떤 API를 사용하든, 데이터 모델의 변경은 응용 프로그램과 함께 배송되는 동일한 모델에서 직접 이루어질 수 있습니다.

00:06:52.000 --> 00:06:56.000
변경하기 위해 새 버전의 모델을 만들 필요가 없습니다.

00:06:56.000 --> 00:07:11.000
Core Data가 실제로 마이그레이션 작업을 수행하지 않고 소스와 대상 모델 간의 매핑 모델을 추론할 수 있는지 여부를 미리 결정하려면 NSMappingModel .inferredMappingModel 방법을 사용할 수 있습니다.

00:07:11.000 --> 00:07:16.000
이 방법은 Core Data가 만들 수 있다면 추론된 모델을 반환합니다.

00:07:16.000 --> 00:07:19.000
그렇지 않으면, 그것은 0을 반환한다.

00:07:19.000 --> 00:07:25.000
때때로, 스키마의 결합된 변화는 경량 마이그레이션 기능을 초과할 수 있다.

00:07:25.000 --> 00:07:31.000
나는 그 문제를 어떻게 처리하고 여전히 경량 마이그레이션을 사용하는지 설명할 것이다.

00:07:31.000 --> 00:07:46.000
이전 예제 모델로 돌아가서, 이전에 FLIGHT_DATA에 저장된 파일 경로로 표시된 이진 데이터에 외부 저장소를 사용하는 "flightData"라는 속성을 추가했다고 가정합니다.

00:07:46.000 --> 00:07:53.000
또한, 내부적으로 데이터를 저장하고 외부 저장소를 제거하기 위해 그 속성을 변경할 필요가 있다고 가정해 봅시다.

00:07:53.000 --> 00:08:00.000
이 마이그레이션이 경량 마이그레이션의 기능에 맞는지 확인하면서, 그렇지 않다는 것이 밝혀졌다.

00:08:00.000 --> 00:08:05.000
겉으로 보기에, 우리는 갇혀서 이 변화를 만들 수 없는 것처럼 보인다.

00:08:05.000 --> 00:08:06.000
하지만, 두려워하지 마!

00:08:06.000 --> 00:08:16.000
경량 마이그레이션은 여러 단계임에도 불구하고 더 복잡하고 부적합한 마이그레이션을 수행하는 데 여전히 사용될 수 있다.

00:08:16.000 --> 00:08:28.000
목표는 경량 마이그레이션을 받을 수 없는 마이그레이션 작업을 경량 마이그레이션을 받을 수 있는 최소 일련의 마이그레이션으로 분해하는 것입니다.

00:08:28.000 --> 00:08:46.000
일반적으로, 원래 모델이 A이고 목표 모델이 B이지만, 모델 B에 경량 마이그레이션을 적용할 수 없는 변경 사항이 있는 경우, 이러한 변경 사항을 분해하는 하나 이상의 모델 버전을 도입하여 브리지를 만들 수 있습니다.

00:08:46.000 --> 00:08:55.000
도입된 각 모델은 부적합한 변화를 구성하는 기능 내에 있는 하나 이상의 작업을 가질 것이다.

00:08:55.000 --> 00:09:05.000
이것은 각 모델이 이제 경량으로 마이그레이션할 수 있지만 부적합한 마이그레이션과 동등한 일련의 마이그레이션을 초래한다.

00:09:05.000 --> 00:09:11.000
경량 마이그레이션을 받을 수 없었던 내 예로 돌아가서, 우리의 원래 모델은 모델 A이다.

00:09:11.000 --> 00:09:26.000
새로운 모델 버전인 A 프라임을 도입하여 작업을 분해하기 시작하고 외부 파일에서 가져온 데이터를 저장하는 데 일시적으로 사용될 새로운 속성 "tmpStorage"를 추가할 것입니다.

00:09:26.000 --> 00:09:31.000
다음으로, 나는 외부 파일의 데이터를 우리의 새로운 속성으로 가져올 것이다.

00:09:31.000 --> 00:09:37.000
이 데이터를 가져오는 코드는 코어 데이터에서 제공하는 기능과는 별개입니다.

00:09:37.000 --> 00:09:42.000
이 수입의 실행은 이주 사이에 끼어 있다.

00:09:42.000 --> 00:09:50.000
데이터가 안전하게 가져오면, 나는 A 프라임에서 A 더블 프라임 모델의 또 다른 새 버전을 만들 것이다.

00:09:50.000 --> 00:09:58.000
더블 프라임에서, 나는 새로운 속성의 이름을 바꾸면서 동시에 오래된 외부 저장소 속성을 삭제할 것이다.

00:09:58.000 --> 00:10:04.000
설명된 각 단계는 경량 마이그레이션 기능 내에 있습니다.

00:10:04.000 --> 00:10:19.000
직관적으로, 가벼운 마이그레이션 옵션으로 설정된 영구 저장소를 열고 연속 순서로 처리되지 않은 각 모델을 반복적으로 단계하는 이벤트 루프를 구축할 수 있으며, Core Data는 저장소를 마이그레이션할 것입니다.

00:10:19.000 --> 00:10:34.000
이전 예제에서 외부 파일에서 데이터를 가져온 방법과 같이 마이그레이션 중에 앱별 로직을 수행하는 경우, 프로세스 종료로 인해 마이그레이션이 중단되는 경우 해당 로직은 "재시작 가능"해야 합니다.

00:10:34.000 --> 00:10:42.000
앱이 Core Data와 CloudKit을 사용하는 경우, Core Data에서 데이터 모델을 설계할 때 명심해야 할 몇 가지 중요한 사항이 있습니다.

00:10:42.000 --> 00:10:51.000
코어 데이터 저장소와 CloudKit 데이터베이스 간에 레코드를 전달하려면 데이터 모델에 대한 공유된 이해가 필요합니다.

00:10:51.000 --> 00:10:55.000
코어 데이터 모델 편집기에서 이 모델을 정의합니다.

00:10:55.000 --> 00:10:59.000
그 모델은 나중에 CloudKit 스키마를 생성하는 데 사용된다.

00:10:59.000 --> 00:11:07.000
생성된 스키마는 처음에 개발 환경에서 생성된 다음 생산으로 승격된다.

00:11:07.000 --> 00:11:12.000
CloudKit이 Core Data 모델의 모든 기능을 지원하지 않는다는 점에 유의해야 합니다.

00:11:12.000 --> 00:11:18.000
모델을 설계할 때, 다음과 같은 제한 사항을 인식하고 호환 가능한 데이터 모델을 만드세요.

00:11:18.000 --> 00:11:23.000
예를 들어, 엔티티에 대한 고유한 제약은 지원되지 않습니다.

00:11:23.000 --> 00:11:28.000
정의되지 않은 개체 ID 속성 유형은 속성 유형으로 지원되지 않습니다.

00:11:28.000 --> 00:11:34.000
그리고 관계는 선택 사항이어야 하며 역관계가 있어야 한다.

00:11:34.000 --> 00:11:38.000
또한, CloudKit은 삭제 거부 규칙을 지원하지 않습니다.

00:11:38.000 --> 00:11:43.000
앱을 개발할 때, 당신은 개발 환경을 사용하게 될 것입니다.

00:11:43.000 --> 00:11:48.000
CloudKit 스키마는 이 환경에서 자유롭게 수정할 수 있습니다.

00:11:48.000 --> 00:11:54.000
그러나, 스키마를 프로덕션으로 홍보한 후, 레코드 유형과 필드는 변경할 수 없습니다.

00:11:54.000 --> 00:12:02.000
경량 마이그레이션은 다양한 시나리오를 처리하지만, CloudKit은 지원하는 것이 더 제한적이다.

00:12:02.000 --> 00:12:07.000
앞서 설명한 많은 경량 작업은 지원되지 않습니다.

00:12:07.000 --> 00:12:16.000
특히, CloudKit에서 지원되는 것은 기존 레코드 유형에 새로운 필드를 추가하고 새로운 레코드 유형을 추가하는 것입니다.

00:12:16.000 --> 00:12:21.000
기존 레코드 유형이나 필드를 수정하거나 삭제할 수 없습니다.

00:12:21.000 --> 00:12:26.000
모델 스키마를 수정할 때 이러한 제한 사항을 고려하십시오.

00:12:26.000 --> 00:12:35.000
데이터 모델을 업데이트할 때가 되면, 가벼운 마이그레이션은 로컬 저장소 파일의 스키마 변경만 구체화한다는 것을 명심하세요.

00:12:35.000 --> 00:12:45.000
특정 저장소가 CloudKit과 함께 사용되는지 여부에 관계없이, 마이그레이션은 디스크의 저장소만 변경하고 CloudKit 스키마를 변경하지 않습니다.

00:12:45.000 --> 00:12:58.000
스키마 이니셜라이저를 실행한 다음 CloudKit 콘솔을 사용하여 개발의 변경 사항을 프로덕션으로 홍보하여 개발 데이터베이스에서 이러한 변경 사항을 구체화해야 합니다.

00:12:58.000 --> 00:13:04.000
앱 사용자는 이전 버전과 새 버전을 사용할 것이라는 점을 명심하세요.

00:13:04.000 --> 00:13:09.000
최신 버전의 앱은 물론 스키마에 새로 추가된 것에 대해 알게 될 것이다.

00:13:09.000 --> 00:13:15.000
이전 버전의 앱은 새로운 필드나 레코드 유형에 대해 알지 못할 것이다.

00:13:15.000 --> 00:13:24.000
CloudKit 스키마는 본질적으로 추가적이기 때문에, 이전 버전의 앱을 실행하는 장치에 대한 스키마 마이그레이션의 영향을 고려하십시오.

00:13:24.000 --> 00:13:33.000
예를 들어, 한 가지 일반적인 함정은 이전 버전의 앱이 사용하지만 최신 버전은 사용하지 않는 오래된 필드를 업데이트하는 것을 잊어버리는 것입니다.

00:13:33.000 --> 00:13:37.000
다음은 CloudKit 스키마를 마이그레이션하기 위한 몇 가지 전략입니다.

00:13:37.000 --> 00:13:43.000
첫 번째 옵션은 기존 레코드 유형에 새로운 필드를 점진적으로 추가하는 것이다.

00:13:43.000 --> 00:13:52.000
이 접근 방식을 채택하면, 이전 버전의 앱은 사용자가 만드는 모든 레코드에 액세스할 수 있지만, 모든 필드는 아닙니다.

00:13:52.000 --> 00:14:04.000
두 번째 옵션은 버전 속성을 포함하여 엔티티를 버전한 다음, 가져오기 요청을 사용하여 현재 버전의 앱과 호환되는 레코드만 선택하는 것입니다.

00:14:04.000 --> 00:14:15.000
이 접근 방식을 채택하면, 이전 버전의 앱은 사용자가 최신 버전으로 만든 레코드를 가져오지 않아 해당 장치에 효과적으로 숨깁니다.

00:14:15.000 --> 00:14:25.000
마지막 전략은 NSPersistentCloudKitContainerOptions를 사용하여 완전히 새로운 컨테이너를 만들어 새 저장소를 새 컨테이너와 연결하는 것입니다.

00:14:25.000 --> 00:14:33.000
사용자가 큰 데이터 세트를 가지고 있다면, 데이터 세트를 iCloud에 업로드하는 데 오랜 시간이 걸릴 수 있습니다.

00:14:33.000 --> 00:14:37.000
어떤 방법을 사용하든, 데이터 모델을 설계할 때 주의하세요.

00:14:37.000 --> 00:14:44.000
교차 버전 호환성 문제를 고려하고 다른 버전의 데이터 모델을 함께 테스트하십시오.

00:14:44.000 --> 00:14:51.000
이제 데이터 모델, 마이그레이션 및 CloudKit에 대해 철저히 논의했으므로, 저는 이것을 실제로 시연할 것입니다.

00:14:51.000 --> 00:14:54.000
짐작하셨겠지만, 저는 조종사입니다.

00:14:54.000 --> 00:14:57.000
나는 비행 시간을 기록하기 위해 작은 앱을 만들었다.

00:14:57.000 --> 00:14:59.000
여기 그 앱의 데이터 모델이 있습니다.

00:14:59.000 --> 00:15:14.000
저는 "LogEntry"라는 단일 엔티티를 가지고 있으며 필요한 경험 정보를 기록할 수 있도록 항공기 유형, 비행 기간, 출발지, 목적지 및 꼬리 번호와 같은 여러 속성을 추가했습니다.

00:15:14.000 --> 00:15:21.000
내가 이 애플리케이션을 처음 실행할 때, Core Data는 저장소를 만들고 그 저장소에서 스키마를 구체화할 것이다.

00:15:21.000 --> 00:15:34.000
애플리케이션을 실행하기 전에 com.apple.CoreData.SQLDebug와 com.apple.CoreData.MigrationDebug 환경 변수를 켤 것입니다.

00:15:34.000 --> 00:15:37.000
이것은 Core Data가 취하고 있는 단계를 기록하게 할 것이다.

00:15:37.000 --> 00:15:42.000
이러한 논쟁이 제자리에 있으면, 나는 앱을 실행할 것이다.

00:15:42.000 --> 00:15:52.000
앱이 실행됨에 따라, Core Data는 파일을 만들고, 저장소의 메타데이터를 만들고, 스키마를 구체화하는 단계를 기록하고 있습니다.

00:15:52.000 --> 00:15:56.000
SQLite는 우리의 스키마와 함께 ZLOGENTRY 테이블을 만들었다.

00:15:56.000 --> 00:16:02.000
이것은 또한 sqlite3 명령줄 도구를 사용하여 저장소 파일을 보고 확인할 수 있습니다.

00:16:02.000 --> 00:16:10.000
여기 LogEntry 테이블이 있으며, 데이터 모델에서 만든 속성에 해당하는 열이 있습니다.

00:16:10.000 --> 00:16:14.000
이제 나는 가벼운 변화를 만들 거야.

00:16:14.000 --> 00:16:18.000
나는 새로운 단체, 항공기, 조종사, 그리고 공항을 추가하고 있다.

00:16:18.000 --> 00:16:21.000
이것은 내가 스키마를 정상화하는 데 도움이 될 것이다.

00:16:21.000 --> 00:16:26.000
나는 LogEntry 엔티티의 속성 중 일부를 관계로 바꾸고 있다.

00:16:26.000 --> 00:16:34.000
예를 들어, 목적지와 출발지는 문자열 속성에서 공항과의 관계로 이동한다.

00:16:34.000 --> 00:16:40.000
공항 법인은 또한 icaoIdentifier와 faaIdentifier라는 두 가지 새로운 속성을 가지고 있다.

00:16:40.000 --> 00:16:49.000
유형 속성은 새로운 엔티티로 승격됩니다; 항공기와 저는 두 개의 새로운 속성인 tailNumber와 registrationNumber를 추가하고 있습니다.

00:16:49.000 --> 00:16:56.000
LogEntry에서, 나는 LogEntry에서 항공기와 일대일 관계를 맺고 있다.

00:16:56.000 --> 00:17:02.000
마지막으로, 이름과 인증서 ID가 있는 파일럿 엔티티를 추가했습니다.

00:17:02.000 --> 00:17:06.000
각 로그 항목은 파일럿 엔티티와 관련이 있을 것이다.

00:17:06.000 --> 00:17:15.000
이제 데이터 모델에 대한 변경을 완료했으므로, 앱을 다시 실행할 것입니다.

00:17:15.000 --> 00:17:19.000
이런! 앱을 실행하는 동안 오류가 발생했습니다.

00:17:19.000 --> 00:17:24.000
코드를 검사하면, NSPersistentStore- IncompatibleVersionHashError입니다.

00:17:24.000 --> 00:17:30.000
그 오류는 내 현재 모델이 더 이상 매장의 모델 스키마와 일치하지 않는다는 것을 의미한다.

00:17:30.000 --> 00:17:32.000
나는 상점 스키마를 마이그레이션해야 해.

00:17:32.000 --> 00:17:35.000
나는 세 가지 방법 중 하나로 그것을 할 수 있다.

00:17:35.000 --> 00:17:45.000
첫 번째 방법을 사용하면 경량 마이그레이션 옵션이 자동으로 설정되므로 코드를 NSPersistentContainer로 변환할 수 있습니다.

00:17:45.000 --> 00:17:55.000
두 번째 방법을 사용하면 NSPersistentStoreDescription을 사용할 수 있습니다. 다시 말하지만, 가벼운 마이그레이션 옵션이 자동으로 설정되기 때문입니다.

00:17:55.000 --> 00:18:06.000
마지막으로, 세 번째 방법을 사용하여 옵션 사전에서 경량 마이그레이션 옵션을 수동으로 설정하고 상점을 열 때 해당 사전을 코디네이터에게 전달할 수 있습니다.

00:18:06.000 --> 00:18:11.000
나는 NSPersistentContainer를 사용하여 첫 번째 옵션을 선택할 것이라고 생각한다.

00:18:11.000 --> 00:18:32.000
이제 NSPersistentContainer를 사용하기 위해 코드를 변환했으므로, 앱을 실행하고 Core Data가 저장소 파일의 스키마를 마이그레이션하는 것을 다시 관찰할 것입니다.

00:18:32.000 --> 00:18:36.000
다시 말하지만, 이것은 sqlite3 명령줄 도구를 사용하여 확인할 수 있습니다.

00:18:36.000 --> 00:18:42.000
새로운 스키마는 경량 마이그레이션을 사용하여 Core Data에 의해 자동으로 구체화되었습니다.

00:18:42.000 --> 00:18:44.000
뭐가 더 쉬울 수 있을까?

00:18:44.000 --> 00:18:48.000
데모를 끝내기 전에, 나는 옵션 번호 3을 보여주고 싶었다.

00:18:48.000 --> 00:18:58.000
이 옵션을 기억하세요, 저는 옵션 사전에서 경량 마이그레이션 옵션을 수동으로 설정한 다음 상점을 열 때 그 사전을 코디네이터에게 전달하고 있습니다.

00:18:58.000 --> 00:19:03.000
최종 결과는 상점이 새로운 스키마로 마이그레이션된다는 점에서 동일합니다.

00:19:03.000 --> 00:19:07.000
데이터 모델을 변경할 때, 가벼운 마이그레이션을 사용하여 도움을 받으세요.

00:19:07.000 --> 00:19:14.000
경량 마이그레이션은 대부분의 데이터 모델 변경에 매우 유연하고 사용하기 쉽습니다.

00:19:14.000 --> 00:19:22.000
더 복잡한 데이터 모델이 있다면, 그 모델을 가벼운 변화로 구성된 모델로 나누세요.

00:19:22.000 --> 00:19:29.000
마지막으로, 앱과 함께 CloudKit을 사용하는 경우, 데이터 모델 변경의 영향을 신중하게 고려하십시오.

00:19:29.000 --> 00:19:32.000
데이터 모델 변경 사항을 철저히 테스트하세요.

00:19:32.000 --> 00:19:40.000
이 정보가 유용하고 멋진 새로운 기능을 구축하기 위해 프로젝트의 모델을 업데이트하는 것을 고려하기를 바랍니다.

00:19:40.000 --> 23:59:59.000
나와 함께 비행해줘서 고마워, 그리고 멋진 WWDC를 보내.

