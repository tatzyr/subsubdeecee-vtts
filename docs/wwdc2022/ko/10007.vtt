WEBVTT

00:00:00.000 --> 00:00:03.000
♪ 부드러운 기악 힙합 음악 ♪

00:00:03.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:13.000
Dani Chootong: 안녕하세요, "인앱 구매의 새로운 기능"에 오신 것을 환영합니다.

00:00:13.000 --> 00:00:16.000
저는 Dani이고, StoreKit 팀의 엔지니어입니다.

00:00:16.000 --> 00:00:23.000
오늘 저는 제 동료 이안과 함께 발표할 것이며, 우리는 올해 인앱 구매에 가져올 새로운 개선 사항을 검토할 것입니다.

00:00:23.000 --> 00:00:32.000
작년에, 우리는 인앱 구매를 쉽게 통합할 수 있도록 처음부터 설계된 새로운 API 세트인 StoreKit 2를 도입했습니다.

00:00:32.000 --> 00:00:38.000
StoreKit 2는 async/await 패턴을 사용하는 Swift 동시성을 포함한 최신 언어 기능을 사용합니다.

00:00:38.000 --> 00:00:45.000
서버 측면에서, 우리는 완전히 새로운 App Store 서버 엔드포인트 세트로 이러한 새로운 StoreKit 기능을 보완했습니다.

00:00:45.000 --> 00:00:52.000
이러한 서버 엔드포인트를 사용하면 거래 정보를 쉽게 검색하고 서버의 구독 상태를 확인할 수 있습니다.

00:00:52.000 --> 00:01:00.000
우리는 또한 서버의 구독 수명 주기를 그 어느 때보다 쉽게 추적할 수 있도록 App Store 서버 알림 버전 2를 출시했습니다.

00:01:00.000 --> 00:01:07.000
오늘 저는 이 새로운 API와 새로운 StoreKit 모델에 가져올 개선 사항을 검토할 것입니다.

00:01:07.000 --> 00:01:17.000
그런 다음, 이안은 App Store 서버 API 향상과 App Store 서버 알림을 위한 새로운 API를 포함한 몇 가지 흥미로운 새로운 서버 업데이트를 안내할 것입니다.

00:01:17.000 --> 00:01:23.000
먼저, 앱 구매를 확인하기 위해 새로운 앱 거래 API를 검토하겠습니다.

00:01:23.000 --> 00:01:28.000
다음으로, StoreKit 모델에 추가한 몇 가지 새로운 속성을 파헤칠 것입니다.

00:01:28.000 --> 00:01:37.000
구독 제안 코드를 교환하고 고객에게 앱을 검토하도록 요청하는 새로운 SwiftUI 친화적인 API를 소개하겠습니다.

00:01:37.000 --> 00:01:44.000
그런 다음, 고객에게 App Store 메시지를 표시하는 데 사용되는 API인 StoreKit Messages를 소개합니다.

00:01:44.000 --> 00:01:52.000
그리고 마지막으로, 원본에서 최신 StoreKit API로 마이그레이션할 때 애플리케이션 사용자 이름을 보존하기 위해 추가하는 개선 사항을 검토하겠습니다.

00:01:52.000 --> 00:01:57.000
이 프레젠테이션을 통해, 나는 내가 가장 좋아하는 앱인 푸드 트럭을 사용할 것이다.

00:01:57.000 --> 00:02:02.000
푸드 트럭 앱에서, 나는 도넛 배달을 하기 위해 다양한 도시를 방문하는 팝업 도넛 푸드 트럭을 관리한다.

00:02:02.000 --> 00:02:05.000
그럼, 시작하자!

00:02:05.000 --> 00:02:06.000
앱 거래를 만나보세요.

00:02:06.000 --> 00:02:12.000
앱 거래는 앱 구매를 확인하기 위한 새로운 API입니다.

00:02:12.000 --> 00:02:18.000
앱 거래는 실행 중인 장치에 대한 앱 구매를 위한 서명된 정보를 나타냅니다.

00:02:18.000 --> 00:02:27.000
JWS를 사용하여 서명되었으며, 원래 StoreKit API에서 앱 영수증의 앱 세부 정보 부분을 대체합니다.

00:02:27.000 --> 00:02:34.000
거래 확인과 마찬가지로, StoreKit은 앱 거래의 자동 확인을 수행합니다.

00:02:34.000 --> 00:02:39.000
그러나, 당신이 원한다면, 당신은 또한 당신 자신의 검증을 수행할 수 있습니다.

00:02:39.000 --> 00:02:43.000
JWS 서명을 검증하는 것은 잘 문서화된 표준이다.

00:02:43.000 --> 00:02:48.000
자신의 검증을 구현하기 위해 공개 문서를 참조할 수 있습니다.

00:02:48.000 --> 00:02:52.000
StoreKit은 필요할 때 앱 트랜잭션을 자동으로 업데이트합니다.

00:02:52.000 --> 00:02:57.000
그러나, 사용자가 뭔가 잘못되었다고 생각하는 드문 경우, 새로 고칠 수 있습니다.

00:02:57.000 --> 00:03:03.000
고객이 앱 거래를 새로 고칠 수 있도록 앱에 UI를 제공해야 합니다.

00:03:03.000 --> 00:03:11.000
이것은 앱 트랜잭션을 새로 고치면 사용자에게 인증하라는 메시지가 표시되기 때문에 사용자 행동에 대한 응답으로만 사용해야 합니다.

00:03:11.000 --> 00:03:15.000
사기를 예방하는 것이 앱 거래를 사랑하는 유일한 이유는 아니다.

00:03:15.000 --> 00:03:31.000
유료 앱에서 인앱 구매를 제공하는 무료 앱으로 비즈니스 모델을 전환하고 싶다면, 어떤 고객이 앱을 선주문했는지 궁금하거나, 앱을 언제 구매했는지 알고 싶다면, 앱 거래로 처리할 수 있는 모든 상황입니다.

00:03:31.000 --> 00:03:39.000
앱 영수증에서, 영수증 페이로드는 발생한 모든 인앱 구매와 함께 애플리케이션에 대한 구매 데이터를 결합합니다.

00:03:39.000 --> 00:03:43.000
이것들은 이제 StoreKit에서 두 개의 별도의 구성 요소로 나뉩니다.

00:03:43.000 --> 00:03:46.000
이것들 중 첫 번째는 거래 내역이다.

00:03:46.000 --> 00:03:52.000
StoreKit의 거래 API는 장치에서 바로 사용자의 전체 인앱 구매 내역에 대한 통찰력을 제공합니다.

00:03:52.000 --> 00:04:02.000
이 API를 사용하면 사용자의 최신 거래, 미완성 거래 및 현재 자격을 포함하여 필요한 정확한 정보를 찾을 수 있습니다.

00:04:02.000 --> 00:04:09.000
서버에서 이러한 계산을 수행하는 것을 선호한다면, App Store Server API에서 사용자의 구매 내역을 얻을 수도 있습니다.

00:04:09.000 --> 00:04:13.000
이안은 나중에 이 세션에 대해 흥미로운 업데이트를 할 것이다.

00:04:13.000 --> 00:04:20.000
그리고 두 번째 구성 요소는 앱이 실행 중인 장치에 유효한지 확인하는 데 필요한 데이터가 포함된 앱 트랜잭션입니다.

00:04:20.000 --> 00:04:28.000
앱 트랜잭션을 사용하여 앱 구매를 확인하는 것은 쉬우며, 잠시 후에 어떻게 사용할 수 있는지에 대한 예를 살펴볼 것입니다.

00:04:28.000 --> 00:04:32.000
하지만 먼저, 제가 가장 좋아하는 앱에 대한 배경을 알려드리겠습니다.

00:04:32.000 --> 00:04:39.000
푸드 트럭으로, 나는 도넛 배달을 하고, 기본적인 소셜 피드를 확인하고, 내 판매 내역을 시각화할 수 있다.

00:04:39.000 --> 00:04:49.000
이 모든 정보를 데이터베이스에 보관하는 것은 내 앱의 지속적인 비용이므로, 비용을 충당하기 위해 연간 판매 이력 차트를 일회성 구매로 바꿀 것입니다.

00:04:49.000 --> 00:04:52.000
게다가, 나는 소셜 피드를 향상시키고 싶다.

00:04:52.000 --> 00:04:59.000
그래서 다른 사람들이 내 푸드 트럭에 대해 말하는 것을 보는 대신, 나는 고객과도 소통할 수 있도록 도구를 제공하고 싶다.

00:04:59.000 --> 00:05:04.000
이것은 구독 서비스가 될 것이며, 나는 월간 및 연간 계획을 세울 것이다.

00:05:04.000 --> 00:05:10.000
푸드 트럭은 유료 앱으로 시작했지만, 인앱 구매를 제공하는 무료 앱으로 전환할 것이다.

00:05:10.000 --> 00:05:15.000
하지만 나는 이미 푸드 트럭을 구매한 기존 고객들이 소외감을 느끼는 것을 원하지 않는다.

00:05:15.000 --> 00:05:24.000
그래서, 나는 푸드 트럭을 구매한 고객들이 그들이 지불한 프리미엄 콘텐츠에 계속 접근할 수 있도록 앱 거래를 사용할 것이다.

00:05:24.000 --> 00:05:26.000
여기 푸드 트럭의 타임라인이 있습니다.

00:05:26.000 --> 00:05:31.000
초기 출시에서, 푸드 트럭은 4.99달러의 유료 앱으로 시작했다.

00:05:31.000 --> 00:05:37.000
버전 1.0은 도넛 배달, 기본 소셜 피드 및 판매 이력 차트를 제공했다.

00:05:37.000 --> 00:05:42.000
나중에, 버전 8.0이 출시되었을 때, 내 비즈니스 모델이 바뀌었다.

00:05:42.000 --> 00:05:47.000
푸드 트럭은 이제 무료이지만, 프리미엄 기능을 잠금 해제하는 다양한 인앱 구매가 포함되어 있습니다.

00:05:47.000 --> 00:05:58.000
연간 판매 이력 차트는 이제 비소모성 일회성 구매이며, 이제 고급 참여 도구를 제공하는 프리미엄 소셜 피드를 위한 새로운 구독 서비스가 있습니다.

00:05:58.000 --> 00:06:03.000
이제 이것의 영향을 받을 수 있는 두 가지 유형의 고객을 살펴봅시다.

00:06:03.000 --> 00:06:11.000
앨리스는 버전 2.5에서 내 푸드 트럭 앱에 대해 알게 되었고, 디지털 세계에서 도넛에 대한 열정을 공유하고 싶다고 결정했다.

00:06:11.000 --> 00:06:16.000
그래서, 그녀는 내 앱을 4.99달러에 구매하고 도넛 배달 여행을 시작했다.

00:06:16.000 --> 00:06:23.000
두 번째 고객인 밥은 친구를 통해 내 푸드 트럭 앱에 대해 알아냈고 버전 8.2의 앱 스토어에서 무료로 다운로드한다.

00:06:23.000 --> 00:06:33.000
이 시나리오에서, 내 앱이 무료가 되기 전에 구매한 앨리스는 여전히 그녀가 이미 지불한 모든 프리미엄 콘텐츠에 접근할 수 있어야 한다.

00:06:33.000 --> 00:06:42.000
그녀는 여전히 프리미엄 소셜 피드 구독을 구매할 수 있는 옵션이 있지만, 나는 그녀에게 처음에 포함된 연간 판매 이력 차트를 부정하고 싶지 않다.

00:06:42.000 --> 00:06:44.000
하지만 밥은 내 앱을 무료로 받았다.

00:06:44.000 --> 00:06:49.000
나는 그들이 인앱 구매를 완료할 때까지 기능과 콘텐츠를 잠금 해제하지 않는다는 것을 알고 있다.

00:06:49.000 --> 00:06:53.000
그래서, 코드에서 앱 트랜잭션으로 이것을 어떻게 달성할 수 있는지 봅시다.

00:06:53.000 --> 00:06:59.000
AppTransaction.shared를 호출하여 앱 거래를 가져오는 것으로 시작하겠습니다.

00:06:59.000 --> 00:07:03.000
이 전화는 내 앱 거래가 포함된 VerificationResult를 얻는다.

00:07:03.000 --> 00:07:09.000
결과 내에서, AppTransaction 유형은 JWS 페이로드를 포함한다.

00:07:09.000 --> 00:07:11.000
다음으로, 나는 결과를 켤 것이다.

00:07:11.000 --> 00:07:22.000
결과가 확인되지 않은 경우, 앱 구매를 App Store에서 확인할 수 없다는 것을 사용자에게 알리기에 좋은 시기이며, 앱 거래를 새로 고치라는 메시지를 표시할 수 있습니다.

00:07:22.000 --> 00:07:26.000
이때, 나는 내 앱에 최소한의 경험을 제공할 것이다.

00:07:26.000 --> 00:07:31.000
결과가 확인되면, 나는 이것을 사용자가 내 앱을 구매했는지 확인할 기회로 사용할 것이다.

00:07:31.000 --> 00:07:36.000
내 앱을 구매한 고객은 그들이 지불한 서비스를 받아야 한다.

00:07:36.000 --> 00:07:39.000
이를 위해, 나는 원래 앱 버전 속성을 사용할 것이다.

00:07:39.000 --> 00:07:46.000
이 속성은 고객이 처음으로 내 앱을 다운로드한 앱 버전을 알려줍니다.

00:07:46.000 --> 00:07:51.000
버전 8.0은 내 앱이 인앱 구매로 무료로 제공되는 버전이다.

00:07:51.000 --> 00:07:58.000
나는 고객이 버전 8.0 이전에 내 앱을 구매했는지 확인하는 내 기능에 고객의 원래 앱 버전을 전달할 것이다.

00:07:58.000 --> 00:08:05.000
그리고 그것으로, 나는 사용자에게 프리미엄 콘텐츠를 제공하는 방법에 대해 정보에 입각한 결정을 내릴 수 있다.

00:08:05.000 --> 00:08:13.000
내 앱을 구매한 앨리스와 같은 고객을 위해, 나는 사용자가 구매 당시 가질 수 있는 콘텐츠를 제공할 것이다.

00:08:13.000 --> 00:08:18.000
내 경우, 나는 그녀의 배달에 대한 연간 판매 이력 차트를 잠금 해제할 것이다.

00:08:18.000 --> 00:08:25.000
또한, 나는 그들이 할 수 있는 추가적인 인앱 구매를 확인하고 싶어서 그것도 제공할 수 있다.

00:08:25.000 --> 00:08:31.000
그렇지 않으면, 나는 밥처럼 비즈니스 모델을 바꾼 후 사용자가 내 앱을 다운로드했다고 확신할 수 있다.

00:08:31.000 --> 00:08:37.000
이것은 그들이 지불한 기능과 콘텐츠를 잠금 해제할 수 있도록 사용자의 현재 자격을 확인할 수 있는 좋은 시간이 될 수 있습니다.

00:08:37.000 --> 00:08:52.000
그리고 단 몇 줄의 코드로, 나는 내 앱의 구매를 확인할 수 있었고, 사용자가 내 앱의 유료 버전을 다운로드했는지 확인할 수 있었고, 고객이 내 앱을 구매했는지 여부에 관계없이 즉시 프리미엄 콘텐츠를 제공할 수 있었다.

00:08:52.000 --> 00:08:59.000
앱 트랜잭션을 사용하면 초기 지지자이든 최근에 앱을 다운로드했든 고객을 쉽게 지원할 수 있습니다.

00:08:59.000 --> 00:09:04.000
이제 StoreKit 모델에 추가하고 있는 새로운 속성으로 넘어가고 싶습니다.

00:09:04.000 --> 00:09:07.000
이 부동산들 중 첫 번째는 가격 지역이다.

00:09:07.000 --> 00:09:10.000
가격 지역은 이제 StoreKit 제품에 포함되어 있습니다.

00:09:10.000 --> 00:09:16.000
당신은 이미 우리의 원래 구매 API와의 인터페이스에서 가격 로케일에 익숙할 수 있습니다.

00:09:16.000 --> 00:09:19.000
다음으로, 나는 서버 환경 속성을 파헤칠 것이다.

00:09:19.000 --> 00:09:25.000
이제 서버 환경에 거래 또는 갱신 정보가 발생했음을 알 수 있습니다.

00:09:25.000 --> 00:09:28.000
그런 다음, 나는 최근 구독 시작일 속성으로 넘어갈 것이다.

00:09:28.000 --> 00:09:35.000
이것을 도구로 사용하여 구독 패턴을 기반으로 고객을 위해 정보에 입각한 결정을 내릴 수 있습니다.

00:09:35.000 --> 00:09:41.000
그리고 마지막으로, Xcode에서 StoreKit 테스트와 함께 사용할 때 이러한 속성에 대한 몇 가지 특별한 고려 사항을 검토하겠습니다.

00:09:41.000 --> 00:09:48.000
이러한 속성은 구형 운영 체제에서 센티넬 값을 반환하며, 이것이 무엇을 의미하는지 잠시 설명하겠습니다.

00:09:48.000 --> 00:10:01.000
StoreKit API는 유연성을 염두에 두고 설계되었으므로, 원래 함께 제공되지 않았음에도 불구하고 작년 운영 체제로 거슬러 올라가는 장치에서 이러한 새로운 속성을 활용할 수 있다는 것을 발표하게 된 것을 자랑스럽게 생각합니다.

00:10:01.000 --> 00:10:10.000
Xcode 14를 사용하여 앱을 빌드하기만 하면 이전 운영 체제에서 이러한 속성에 액세스할 수 있습니다.

00:10:10.000 --> 00:10:21.000
이것은 이러한 속성의 구현이 앱에 컴파일되기 때문에 가능하므로 고객이 새 버전으로 업데이트하면 운영 체제를 업데이트하지 않고도 이러한 개선 사항의 이점을 얻을 수 있습니다.

00:10:21.000 --> 00:10:26.000
하지만, 이 속성들을 사용할 때 명심해야 할 한 가지가 있다.

00:10:26.000 --> 00:10:32.000
이러한 속성은 이러한 이전 운영 체제에서 Xcode에서 StoreKit 테스트를 사용할 때 센티넬 값을 반환합니다.

00:10:32.000 --> 00:10:41.000
내가 센티넬 값을 말할 때, 나는 이것들이 당신이 작업해야 할 실제 값이 아니라는 것을 나타내는 자리 표시자 값을 언급하고 있으며, 왜 이런 일이 발생하는지 설명하겠습니다.

00:10:41.000 --> 00:10:48.000
샌드박스와 프로덕션 환경은 App Store 서버 응답에서 값을 추출하여 이러한 속성을 사용합니다.

00:10:48.000 --> 00:10:54.000
그러나 Xcode의 StoreKit 테스트는 App Store 서버와 독립적으로 작동하는 로컬 테스트 환경입니다.

00:10:54.000 --> 00:11:00.000
이것은 우리가 이러한 속성의 가치를 이전 운영 체제로 백포트할 수 없다는 것을 의미합니다.

00:11:00.000 --> 00:11:08.000
테스트 장치를 새로운 운영 체제로 업데이트하여 이 제한을 쉽게 해결할 수 있으며, 로컬 환경에서 이러한 값을 테스트할 수 있습니다.

00:11:08.000 --> 00:11:15.000
이 새로운 부동산을 어떻게 사용할 수 있는지 보여주는 몇 가지 상황에 대해 논의해 봅시다. 첫 번째는 가격 로케일입니다.

00:11:15.000 --> 00:11:25.000
StoreKit 제품에는 이미 구매 가격을 표시하는 표시 가격 속성이 있지만, 가격 로케일을 사용하면 제품의 소수점 가격에서 파생된 숫자를 포맷할 수 있습니다.

00:11:25.000 --> 00:11:32.000
연간 구독이 있다면, 이것을 고객에게 한 달에 얼마의 비용이 드는지 보여줄 수 있는 기회로 사용할 수 있습니다.

00:11:32.000 --> 00:11:38.000
이 예에서, 당신은 연간 구독이 한 달에 4.17달러에 달한다는 것을 알 수 있습니다.

00:11:38.000 --> 00:11:44.000
아니면 그들이 당신의 월간 서비스보다 연간 서비스를 구매하면 얼마나 절약할 수 있는지 보여주고 싶을 수도 있습니다.

00:11:44.000 --> 00:11:51.000
이 정보를 통해 고객은 구매 옵션을 고려할 때 정보에 입각한 결정을 내릴 수 있습니다.

00:11:51.000 --> 00:11:54.000
이제, 환경 재산으로 넘어가자.

00:11:54.000 --> 00:11:57.000
환경 재산은 거래 및 갱신 정보에서 사용할 수 있습니다.

00:11:57.000 --> 00:12:06.000
이 속성은 거래 또는 갱신 정보가 시작된 서버 환경을 알려주며, Xcode, 샌드박스 또는 프로덕션이 될 수 있습니다.

00:12:06.000 --> 00:12:13.000
고객이 부기 및 분석을 위해 구매한 후 앱이 거래 정보를 서버에 전달할 수 있습니다.

00:12:13.000 --> 00:12:18.000
앱이 이러한 트랜잭션을 생성할 때, 이러한 서버 환경 중 하나에서 발생할 수 있습니다.

00:12:18.000 --> 00:12:22.000
여러분 대부분과 마찬가지로, 저는 관련 없는 테스트 데이터로 분석에 소음을 추가하고 싶지 않습니다.

00:12:22.000 --> 00:12:29.000
따라서, 환경을 알면 불필요한 정보가 서버로 전송되는 것을 걸러내는 데 도움이 될 수 있습니다.

00:12:29.000 --> 00:12:32.000
마지막으로, 최근 구독 시작일을 살펴봅시다.

00:12:32.000 --> 00:12:41.000
최근 구독 시작일은 제품의 구독 정보 내에서 사용할 수 있으며, 가장 최근의 지속적인 구독 기간을 나타냅니다.

00:12:41.000 --> 00:12:48.000
두 구독 기간 사이에 60일 이상의 간격이 없는 경우 구독은 지속적인 것으로 간주됩니다.

00:12:48.000 --> 00:12:59.000
이 기간은 고객이 제품을 구독하지 않은 격차를 포함할 수 있으므로, 이것을 고객이 구독한 일수에 대한 지표로 사용하지 마십시오.

00:12:59.000 --> 00:13:05.000
최근 구독 시작일은 귀하와 고객 간의 충성도 패턴을 결정하는 데 도움이 될 수 있습니다.

00:13:05.000 --> 00:13:10.000
당신의 충성스러운 고객을 위해, 당신은 그들이 당신의 제품에 계속 참여하도록 하는 방법으로 그들에게 보상을 제공할 수 있습니다.

00:13:10.000 --> 00:13:21.000
또는 고객이 서비스 구독을 취소했다는 것을 알게 된 경우, 제품을 다시 사용할 수 있는 인센티브를 제공하여 만료된 고객을 되찾을 수 있는 기회로 사용할 수 있습니다.

00:13:21.000 --> 00:13:26.000
나는 앞서 우리가 이 속성들에 대한 센티넬 값을 자세히 살펴볼 것이라고 언급했다.

00:13:26.000 --> 00:13:34.000
상기시켜 드리자면, 제가 센티넬 값을 말할 때, 저는 실제 값의 부재를 나타내는 지표 역할을 하는 자리 표시자 값을 언급하고 있습니다.

00:13:34.000 --> 00:13:38.000
이러한 속성에 대한 센티넬 값은 식별하기 쉽다.

00:13:38.000 --> 00:13:45.000
가격 로케일을 다룰 때, 센티넬 값은 식별자 xx_XX가 있는 로케일입니다.

00:13:45.000 --> 00:13:49.000
환경 속성의 경우, 그것은 빈 문자열이 될 것이다.

00:13:49.000 --> 00:13:54.000
그리고 마지막으로, 최근 구독 시작일의 경우, 이 값은 Date.distantPast입니다.

00:13:54.000 --> 00:14:05.000
운 좋게도, 이러한 센티넬 값의 발생은 예측 가능합니다. 이전 운영 체제의 Xcode에서 StoreKit 테스트를 사용하는 경우에만 발생할 수 있으며, 테스트 장치를 업데이트하여 이 문제를 해결할 수 있습니다.

00:14:05.000 --> 00:14:09.000
그래서 이제 당신은 우리가 StoreKit 모델에 대한 개선 사항을 보았습니다.

00:14:09.000 --> 00:14:19.000
그리고 제가 가장 좋아하는 부분은 모델이 도입된 운영 체제와 역호환되므로 고객이 앱을 업데이트하는 것만으로도 바로 이점을 볼 수 있다는 것입니다.

00:14:19.000 --> 00:14:26.000
가격 값으로 산술을 수행할 때, 가격 로케일은 App Store의 로케일과 일치하도록 올바르게 포맷하는 데 도움이 됩니다.

00:14:26.000 --> 00:14:37.000
거래 및 구독 정보의 경우, 환경은 그들이 어디에서 왔는지 정확히 알려주므로, 이 데이터를 서버에 저장하면 환경에 따라 그에 따라 조치를 취할 수 있습니다.

00:14:37.000 --> 00:14:49.000
최근 구독 시작일은 고객 충성도를 이해하는 데 도움이 되므로, 장기 고객에게 특정 제안을 맞춤화하거나, 구독을 취소한 고객에게 인센티브를 제공할 수 있습니다.

00:14:49.000 --> 00:15:01.000
그리고 만약 당신이 궁금하다면, 네, 환경과 최근 구독 시작 날짜는 이안이 논의할 앱 스토어 서버 API와 앱 스토어 서버 알림을 통해서도 사용할 수 있습니다.

00:15:01.000 --> 00:15:08.000
이제 저는 제안 코드를 교환하고 검토를 요청하기 위해 제공하는 새로운 SwiftUI API에 대해 이야기하고 싶습니다.

00:15:08.000 --> 00:15:16.000
제안 코드는 제한된 시간 동안 할인 또는 무료로 구독을 제공하여 구독자를 획득, 유지 및 되찾는 데 도움이 될 수 있습니다.

00:15:16.000 --> 00:15:20.000
이제 App Store Connect에서 고유한 이름의 사용자 지정 코드를 만들 수 있습니다.

00:15:20.000 --> 00:15:26.000
그곳에서 최대 상환 한도를 설정할 수 있으며 만료를 설정할지 여부를 선택할 수 있습니다.

00:15:26.000 --> 00:15:32.000
SwiftUI 구현을 살펴보고 앱에서 바로 제안 코드 상환 시트를 제시해 봅시다.

00:15:32.000 --> 00:15:36.000
여기, 제안 코드 상환 시트를 트리거하는 버튼이 있는 SwiftUI 보기가 있습니다.

00:15:36.000 --> 00:15:42.000
제안 코드 상환 시트에는 이제 SwiftUI에 자체 보기 수정자가 있습니다.

00:15:42.000 --> 00:15:47.000
뷰 수정자는 사용하기 쉽고, 프로세스를 시작하려면 바인딩 부울만 있으면 됩니다.

00:15:47.000 --> 00:15:54.000
그리고 제안 코드 시트가 기각되면, 시트가 성공적으로 제시되었는지 여부를 나타내는 결과를 얻을 수 있습니다.

00:15:54.000 --> 00:16:02.000
고객이 앱에 대한 제안 코드를 사용하면, 결과 거래가 거래 리스너로 전송됩니다.

00:16:02.000 --> 00:16:09.000
따라서, 앱이 실행되는 동안 새롭고 업데이트된 거래를 받기 위해 앱이 실행되자마자 거래 리스너를 설정해야 합니다.

00:16:09.000 --> 00:16:14.000
제안 코드 보기 수정자는 iOS 16부터 사용할 수 있습니다.

00:16:14.000 --> 00:16:18.000
다음으로, 검토를 요청하기 위한 업데이트에 대해 이야기하고 싶습니다.

00:16:18.000 --> 00:16:21.000
고객 피드백을 받는 것은 중요하다.

00:16:21.000 --> 00:16:27.000
잠재적인 신규 고객은 앱을 다운로드하기로 한 결정의 결정 요소로 리뷰를 사용할 수 있습니다.

00:16:27.000 --> 00:16:32.000
다른 사람들은 피드백이나 제안을 제공하는 방법으로 리뷰를 남기고 싶을 수도 있다.

00:16:32.000 --> 00:16:41.000
어느 쪽이든, 우리는 당신이 고객에게 평가를 쉽게 요청할 수 있는 도구를 제공하고자 합니다. 그래서 당신은 그들에게 당신이 듣고 있다는 것을 알리고 그들과 계속 참여할 수 있습니다.

00:16:41.000 --> 00:16:44.000
코드를 검토해 봅시다.

00:16:44.000 --> 00:16:48.000
여기서 저는 요청 검토 API를 시연하기 위한 매우 간단한 견해를 가지고 있습니다.

00:16:48.000 --> 00:16:52.000
SwiftUI에는 이제 requestReview라는 환경 값이 있습니다.

00:16:52.000 --> 00:17:03.000
이 값을 사용하여 RequestReviewAction의 인스턴스를 얻을 수 있으며, 등급을 요청할 준비가 되면 인스턴스를 함수로 호출하여 검토 프롬프트를 표시하도록 요청할 수 있습니다.

00:17:03.000 --> 00:17:06.000
앱에 대한 검토를 요청할 적절한 시간을 결정할 수 있습니다.

00:17:06.000 --> 00:17:14.000
그러나, 프롬프트는 365일 기간 내에 고객에게 최대 세 번만 표시된다는 것을 알아야 합니다.

00:17:14.000 --> 00:17:19.000
그리고 고객에게 같은 버전의 앱을 여러 번 검토하도록 요청해서는 안 됩니다.

00:17:19.000 --> 00:17:22.000
검토 프롬프트로 고객을 방해하지 마세요.

00:17:22.000 --> 00:17:31.000
리뷰를 요청하기에 좋은 시기는 전자상거래 앱에서 구매를 완료하거나 게임에서 레벨을 완료하는 것과 같은 긍정적인 상호 작용을 한 후일 수 있습니다.

00:17:31.000 --> 00:17:39.000
마지막으로, 고객은 장치에 나타나는 요청을 비활성화할 수 있으므로, 사용자 행동의 결과로 검토를 요청해서는 안 됩니다.

00:17:39.000 --> 00:17:43.000
이 API는 SwiftUI 앱에 정말 유용할 것입니다.

00:17:43.000 --> 00:17:48.000
다음으로, StoreKit 메시지를 위한 새로운 API를 소개하고 싶습니다.

00:17:48.000 --> 00:17:54.000
StoreKit 메시지는 사용자에게 중요한 정보를 표시하기 위해 앱 위에 나타나는 시트를 나타냅니다.

00:17:54.000 --> 00:17:57.000
메시지는 App Store에서 판매됩니다.

00:17:57.000 --> 00:18:01.000
각 메시지에는 메시지 메타데이터에 포함된 이유가 있다.

00:18:01.000 --> 00:18:05.000
앱이 포그라운드에 오면 StoreKit 메시지가 검색됩니다.

00:18:05.000 --> 00:18:10.000
예를 들어, 메시지 이유 중 하나인 가격 인상 동의를 살펴봅시다.

00:18:10.000 --> 00:18:21.000
구독 가격을 인상하고 사용자 동의가 필요한 경우, App Store는 이메일, 푸시 알림 및 인앱 가격 동의서를 통해 영향을 받는 구독자에게 알릴 것입니다.

00:18:21.000 --> 00:18:28.000
이 경우, App Store는 사용자가 더 높은 가격으로 갱신하기 전에 구독의 새로운 가격에 동의할 것을 요구합니다.

00:18:28.000 --> 00:18:38.000
따라서, 구독에 대해 더 많은 비용을 청구하기로 결정한 경우, 사용자가 가격 인상에 아직 응답하지 않은 경우 앱을 열 때 가격 인상 동의서가 나타날 수 있습니다.

00:18:38.000 --> 00:18:46.000
기본적으로, StoreKit 메시지는 사용자가 앱을 포그라운드로 가져올 때 앱 위에 나타나며, 사용자에게 앱과 관련된 조치를 취하도록 요청할 수 있습니다.

00:18:46.000 --> 00:18:48.000
이걸 검토해 보자.

00:18:48.000 --> 00:18:51.000
전체 과정은 당신의 앱으로 시작됩니다.

00:18:51.000 --> 00:18:56.000
앱이 전경에 들어가면, StoreKit은 표시할 보류 중인 메시지가 있는지 확인하는 것을 알고 있습니다.

00:18:56.000 --> 00:19:00.000
그리고 만약 있다면, StoreKit은 App Store에서 체크인합니다.

00:19:00.000 --> 00:19:03.000
App Store는 메시지에 대한 정보를 StoreKit에 반환합니다.

00:19:03.000 --> 00:19:07.000
이때, StoreKit은 앱이 메시지를 수신하도록 설정되어 있는지 확인합니다.

00:19:07.000 --> 00:19:12.000
앱에서 메시지 리스너를 설정하여 이것을 할 수 있으며, 곧 들어가겠습니다.

00:19:12.000 --> 00:19:17.000
앱이 메시지 리스너를 설정한 경우, StoreKit은 메시지에 대한 정보를 앱으로 보냅니다.

00:19:17.000 --> 00:19:25.000
이제 앱이 메시지를 표시하기에 좋은 시간인지, 아니면 나중에 프레젠테이션을 연기하고 싶은지 결정할 수 있는 기회입니다.

00:19:25.000 --> 00:19:32.000
메시지 리스너를 설정하지 않으면, StoreKit은 앱 위에 메시지 시트를 표시하여 메시지를 즉시 표시합니다.

00:19:32.000 --> 00:19:34.000
나는 코드에서 이것을 하는 방법을 살펴볼 것이다.

00:19:34.000 --> 00:19:41.000
하지만 그렇게 하기 전에, App Store 메시지의 프레젠테이션을 제어하는 것이 유용한 상황을 설명하겠습니다.

00:19:41.000 --> 00:19:45.000
푸드 트럭 앱에서, 나는 다른 도시로 배달하는 도넛을 커스터마이징할 수 있다.

00:19:45.000 --> 00:19:59.000
이 시간 동안 메시지가 내 앱에 전달되면, 갑자기 메시지 시트에 의해 중단되면 사용자에게 혼란스러울 수 있으므로, 수신 메시지가 표시될 때를 제어하여 이런 일이 발생하지 않도록 메시지 API를 구현할 것입니다.

00:19:59.000 --> 00:20:01.000
이제 코드로 들어가자.

00:20:01.000 --> 00:20:04.000
여기, 도넛 편집기에 대한 간단한 견해가 있습니다.

00:20:04.000 --> 00:20:09.000
앞서 언급했듯이, 앱이 포그라운드에 올 때마다 보류 중인 메시지가 전송됩니다.

00:20:09.000 --> 00:20:15.000
그래서, 저는 메시지 발표를 연기하고 싶은 각 보기에서 메시지 리스너를 설정하고 싶습니다.

00:20:15.000 --> 00:20:20.000
편집 보기에 있는 동안 내 앱으로 전달되는 모든 메시지를 수집하기 위해 바인딩 배열을 추가할 것입니다.

00:20:20.000 --> 00:20:28.000
이것은 중요하다. 왜냐하면 내가 메시지 리스너를 설정하지 않으면, StoreKit은 내 앱이 포그라운드에 올 때 바로 메시지 시트를 표시할 것이기 때문이다.

00:20:28.000 --> 00:20:32.000
보기가 나타나자마자, 나는 메시지 리스너를 설정했다.

00:20:32.000 --> 00:20:37.000
나는 메시지 유형의 정적 속성을 반복하는 작업을 설정하여 이것을 할 것이다.

00:20:37.000 --> 00:20:42.000
이 속성은 비동기 시퀀스이며, 들어오는 메시지를 받을 수 있습니다.

00:20:42.000 --> 00:20:46.000
내 사용 사례를 위해, 나는 pendingMessages 배열에 메시지를 저장할 것이다.

00:20:46.000 --> 00:20:56.000
앱이 포그라운드에 들어갈 때마다 보류 중인 메시지가 전달되기 때문에, 앱은 같은 메시지를 두 번 이상 받을 수 있으므로, 내 배열에 중복 메시지를 추가하는 것을 피하기 위해 이 조건이 있습니다.

00:20:56.000 --> 00:21:01.000
그런 다음, 보기가 해제되면, 상위 보기에 메시지를 표시할 것입니다.

00:21:01.000 --> 00:21:05.000
이것은 도넛 편집기에 대한 탐색 링크가 있는 상위 보기입니다.

00:21:05.000 --> 00:21:10.000
여기서, 저는 이 pendingMessages 배열에 표시해야 하는 모든 보류 중인 메시지를 수집했습니다.

00:21:10.000 --> 00:21:13.000
그렇다면 이 보류 중인 메시지는 어떻게 표시하나요?

00:21:13.000 --> 00:21:17.000
음, 이제 환경 값 displayStoreKitMessage가 있습니다.

00:21:17.000 --> 00:21:23.000
이렇게 하면 DisplayMessageAction의 인스턴스를 얻을 수 있으며, 이를 사용하여 주어진 메시지를 표시할 수 있습니다.

00:21:23.000 --> 00:21:30.000
보기가 나타나면, 보류 중인 메시지를 반복하고 표시하고 싶은 메시지를 전달하는 displayStoreKitMessage를 호출할 것입니다.

00:21:30.000 --> 00:21:34.000
StoreKit은 메시지 시트를 제시합니다.

00:21:34.000 --> 00:21:38.000
이전에, 저는 같은 메시지가 당신의 앱에 두 번 이상 전달될 수 있다고 언급했습니다.

00:21:38.000 --> 00:21:42.000
그것은 메시지가 사용자에게 제시될 때까지 읽은 것으로 표시되지 않기 때문이다.

00:21:42.000 --> 00:21:48.000
그래서, StoreKit은 각 고유한 메시지가 한 번만 표시되도록 합니다.

00:21:48.000 --> 00:21:52.000
그리고 그것은 메시지 API의 빠른 구현이었다.

00:21:52.000 --> 00:22:04.000
기억하세요, StoreKit 메시지는 전경에 올 때마다 앱으로 전송되므로, 메시지가 표시되는 타이밍을 제어하려는 각 보기에서 메시지 리스너를 설정하고 싶을 것입니다.

00:22:04.000 --> 00:22:10.000
메시지 시트가 예상치 못한 순간에 나타나지 않도록 함으로써 고객이 훌륭한 경험을 할 수 있도록 할 수 있습니다.

00:22:10.000 --> 00:22:14.000
아니면 특정 메시지 유형에 맞게 논리를 조정하고 싶을 수도 있습니다.

00:22:14.000 --> 00:22:23.000
가격 인상 동의 메시지를 통해, 가격 인상 동의서가 나타나기 전에 제공하는 추가 가치에 대해 고객에게 교육하고 싶을 수도 있습니다.

00:22:23.000 --> 00:22:31.000
마지막으로, 사용자가 구매한 후 StoreKit이 applicationUsername을 appAccountToken으로 보존하는 방법을 검토해 봅시다.

00:22:31.000 --> 00:22:38.000
서버에 사용자 계정 시스템이 있다면, 이미 applicationUsername 속성을 사용하고 있을 가능성이 있습니다.

00:22:38.000 --> 00:22:45.000
applicationUsername은 거래와 서비스의 사용자 계정을 연결하기 위해 만드는 문자열입니다.

00:22:45.000 --> 00:22:53.000
인앱 구매를 위한 원래 API에서, 결제 대기열에 결제를 추가할 때 애플리케이션 사용자 이름 값을 설정합니다.

00:22:53.000 --> 00:23:01.000
applicationUsername은 모든 문자열을 허용하지만, UUID의 문자열 표현을 제공하는 것이 좋습니다.

00:23:01.000 --> 00:23:08.000
UUID 문자열을 제공할 때, StoreKit은 값을 유지하며 대기열이 업데이트하는 거래에서 볼 수 있습니다.

00:23:08.000 --> 00:23:13.000
applicationUsername에 대한 UUID 문자열을 제공하지 않으면, StoreKit은 이를 지속하지 않을 수 있습니다.

00:23:13.000 --> 00:23:21.000
결제 거래를 대기열에 추가하는 시간과 대기열이 거래를 업데이트할 때 사이에 값이 지속될 것이라는 보장은 없습니다.

00:23:21.000 --> 00:23:30.000
UUID의 문자열 표현을 제공할 때, 어떤 앱의 사용자 계정이 거래를 시작하고 완료했는지 식별할 수 있습니다.

00:23:30.000 --> 00:23:39.000
최신 StoreKit API에서, 우리는 이 개념을 appAccountToken이라는 구매 옵션으로 구현하며 UUID 형식이 필요합니다.

00:23:39.000 --> 00:23:47.000
이제 결제 중에 applicationUsername을 UUID 문자열로 설정하면, App Store 서버는 이를 appAccountToken으로 저장합니다.

00:23:47.000 --> 00:23:57.000
따라서 App Store Server API가 반환한 서명된 거래 정보와 V2 App Store 서버 알림에 UUID가 나타나는 것을 볼 수 있습니다.

00:23:57.000 --> 00:24:03.000
그리고 UUID로서, 그것은 최신 StoreKit 거래 API의 appAccountToken과 호환됩니다.

00:24:03.000 --> 00:24:15.000
따라서 이제 코드베이스를 최신 StoreKit API로 업데이트할 때 애플리케이션 사용자 이름에 사용한 UUID가 StoreKit 거래에서 appAccountToken으로 보존된다는 것을 확신할 수 있습니다.

00:24:15.000 --> 00:24:18.000
우리는 오늘 많은 것을 다루었다.

00:24:18.000 --> 00:24:24.000
서버 업데이트로 넘어가기 전에, 올해의 StoreKit 업데이트를 검토해 봅시다.

00:24:24.000 --> 00:24:35.000
우리는 앱 거래로 앱의 구매를 검증하고, 제안 코드를 교환하고, SwiftUI에서 검토를 요청하고, StoreKit 메시지의 프레젠테이션을 제어하는 것에 대해 논의했습니다.

00:24:35.000 --> 00:24:41.000
우리는 새로운 가격 로케일, 환경 및 최근 구독 시작일 속성에 대해 이야기했습니다.

00:24:41.000 --> 00:24:50.000
그리고, 우리는 애플리케이션 사용자 이름을 앱 계정 토큰으로 유지하기 위해 UUID의 문자열 표현을 사용하는 것의 중요성을 검토했습니다.

00:24:50.000 --> 00:24:56.000
다른 세션인 "StoreKit 테스트의 새로운 기능"을 확인하는 것이 좋습니다.

00:24:56.000 --> 00:25:01.000
그리고 StoreKit 2 API에 대한 재교육이 필요하다면, 작년 세션 "Meet StoreKit 2"를 확인하세요.

00:25:01.000 --> 00:25:06.000
이제 App Store 서버에 대한 업데이트를 안내하기 위해 Ian에게 넘겨주고 싶습니다.

00:25:06.000 --> 00:25:07.000
이안 잔거: 고마워, 대니.

00:25:07.000 --> 00:25:12.000
안녕하세요, 여러분. 제 이름은 이안이고, 저는 앱 스토어 서버 팀의 엔지니어입니다.

00:25:12.000 --> 00:25:19.000
이제 StoreKit의 인앱 구매에 대한 최신 소식을 들었으니, 저는 기어를 바꾸고 서버에 대해 이야기할 것입니다.

00:25:19.000 --> 00:25:32.000
먼저, App Store Server API 및 App Store Server Notifications Version 2에 대한 흥미진진한 새로운 업데이트로 넘어가기 전에 지난 해의 최근 개발을 검토하겠습니다.

00:25:32.000 --> 00:25:34.000
시작하자.

00:25:34.000 --> 00:25:36.000
작년은 컸어.

00:25:36.000 --> 00:25:48.000
우리는 이러한 모든 새로운 기능에 대한 완전한 샌드박스 테스트 지원을 포함하여 App Store Server API 및 App Store Server Notifications V2와 함께 완전히 새로운 엔드포인트 제품군을 가져왔습니다.

00:25:48.000 --> 00:26:03.000
거래 내역 가져오기 엔드포인트를 사용하여 사용자의 인앱 구매의 전체 기록을 얻거나 모든 구독 상태 가져오기 엔드포인트를 사용하여 사용자 구독의 현재 상태를 최신 상태로 유지하는 방법을 공유했습니다.

00:26:03.000 --> 00:26:14.000
이 두 엔드포인트 모두 사용자의 원래TransactionId를 편리하게 키하므로, 이 하나의 간단한 값만 저장하여 이 데이터에 액세스할 수 있습니다.

00:26:14.000 --> 00:26:25.000
우리는 또한 App Store 서버 알림 버전 2가 서버에서 이벤트 처리를 단순화하고 App Store Server API를 보완하는 방법을 다루었습니다.

00:26:25.000 --> 00:26:33.000
V2 알림을 통해 App Store 서버는 서버를 직접 호출하여 인앱 구매 업데이트를 제공합니다.

00:26:33.000 --> 00:26:40.000
간소화된 알림 유형과 하위 유형은 무슨 일이 일어나고 있는지 쉽게 이해할 수 있게 해준다.

00:26:40.000 --> 00:26:45.000
이를 사용하여 인앱 구독 및 기타 이벤트와 관련된 변경 사항을 추적할 수 있습니다.

00:26:45.000 --> 00:26:51.000
이러한 모든 데이터 소스를 통해, 우리는 그 데이터를 가능한 한 쉽게 분석할 수 있도록 하고 싶었다.

00:26:51.000 --> 00:27:04.000
영수증은 이제 과거의 일입니다. 이러한 새로운 서비스는 서명된 JSON 형식으로 인앱 데이터를 제공하므로 쉽게 구문 분석하고 App Store 서버에서 왔다고 신뢰할 수 있습니다.

00:27:04.000 --> 00:27:07.000
작년은 App Store 서버에게 큰 해였다.

00:27:07.000 --> 00:27:15.000
이 모든 새로운 기능을 활용하기 위해 서버 코드를 업데이트하기 위해 노력했다면 당신에게도 컸을 수도 있습니다.

00:27:15.000 --> 00:27:27.000
App Store Server API 및 App Store Server Notifications V2에 강력한 새로운 개선 사항과 기능을 제공함에 따라 노력이 계속될 것이라는 점을 안심하십시오.

00:27:27.000 --> 00:27:45.000
그것은 우리의 검토 중인 해이지만, 올해의 업데이트를 들은 후 더 많은 재교육을 원한다면, "서버에서 인앱 구매 관리", "StoreKit 2를 만나다", "고객 지원 및 환불 처리"라는 제목의 WWDC21 세션을 확인하십시오.

00:27:45.000 --> 00:27:53.000
이제 WWDC22용 App Store 서버에 오는 새로운 업데이트로 넘어가자.

00:27:53.000 --> 00:27:58.000
먼저 거래 및 갱신 정보 필드에 대한 몇 가지 업데이트를 공유하겠습니다.

00:27:58.000 --> 00:28:03.000
다음으로 App Store Server API의 새로운 개선 사항에 대해 알려드리겠습니다.

00:28:03.000 --> 00:28:11.000
그리고 마지막으로, 저는 App Store 서버 알림 V2에 오는 흥미진진한 새로운 기능을 공유할 것입니다.

00:28:11.000 --> 00:28:18.000
이제 우리의 새로운 주제 중 첫 번째에 대해 알아봅시다: 거래 및 갱신 정보에서 발견된 새로운 분야.

00:28:18.000 --> 00:28:26.000
이전에, 당신은 Dani로부터 인앱 구매의 거래 및 갱신 정보에 오는 몇 가지 새로운 필드에 대해 들었습니다.

00:28:26.000 --> 00:28:40.000
이러한 필드, 환경 및 recentSubscriptionStartDate는 App Store Server API와 V2 App Store Server 알림에서 받는 거래 및 갱신 정보 페이로드에도 제공됩니다.

00:28:40.000 --> 00:28:48.000
이 새로운 필드가 포함된 App Store 서버에서 받을 수 있는 데이터를 새롭게 살펴봅시다.

00:28:48.000 --> 00:28:53.000
첫 번째는 디코딩 후 여기에서 볼 수 있는 거래 정보 페이로드입니다.

00:28:53.000 --> 00:28:57.000
아래에서, 당신은 우리의 새로운 분야를 볼 수 있습니다: 환경.

00:28:57.000 --> 00:29:04.000
거래가 생산 환경에서 이루어졌는지 샌드박스 환경에서 이루어졌는지 한 눈에 알 수 있습니다.

00:29:04.000 --> 00:29:10.000
다음은 디코딩 후 여기에서 볼 수 있는 갱신 정보 페이로드입니다.

00:29:10.000 --> 00:29:15.000
보시다시피, 환경 필드도 참고용으로 사용할 수 있습니다.

00:29:15.000 --> 00:29:21.000
또한, recentSubscriptionStartDate는 이제 모든 갱신 정보 페이로드에 나타날 것이다.

00:29:21.000 --> 00:29:32.000
이것은 60일 이하의 격차를 무시하고 가장 최근의 갱신 문자열에서 사용자의 첫 번째 구독 구매의 시작일입니다.

00:29:32.000 --> 00:29:38.000
recentSubscriptionStartDate는 고객의 충성도를 한 눈에 파악할 수 있는 쉬운 방법입니다.

00:29:38.000 --> 00:29:51.000
하지만 서비스 격차의 타이밍과 길이를 포함하여 더 자세한 내용을 원한다면, Get Transaction History 엔드포인트에 전화하여 사용자의 구독 갱신 구매의 전체 기록을 검토할 수 있습니다.

00:29:51.000 --> 00:30:03.000
또는 더 자세한 내용은 App Store 서버 알림 V2를 통해 App Store 서버가 사용자 구독에 대한 업데이트를 자동으로 전송합니다.

00:30:03.000 --> 00:30:14.000
이러한 알림은 갱신 선호도 변경, 제안 상환, 청구 실패 등과 같은 이벤트의 타이밍에 대한 최대한의 통찰력을 제공합니다.

00:30:14.000 --> 00:30:21.000
보시다시피, recentSubscriptionStartDate는 고객 충성도를 결정하기 위한 일련의 옵션을 마무리합니다.

00:30:21.000 --> 00:30:27.000
이 도구를 사용하여 제안을 타겟팅하고 가장 충성도가 높은 고객에게 보상하세요.

00:30:27.000 --> 00:30:33.000
이제 Get Transaction History 엔드포인트에 대한 몇 가지 편리한 새로운 개선 사항으로 넘어가겠습니다.

00:30:33.000 --> 00:30:41.000
거래 기록 가져오기 엔드포인트를 사용하면 앱에서 사용자의 전체 구매 내역을 가져올 수 있습니다.

00:30:41.000 --> 00:30:46.000
엔드포인트 응답은 페이지가 매겨지므로 이 데이터를 합리적인 덩어리로 처리할 수 있습니다.

00:30:46.000 --> 00:30:53.000
각 응답에는 다음 페이지를 얻기 위해 다음 요청에서 제공하는 개정 토큰이 포함되어 있습니다.

00:30:53.000 --> 00:31:02.000
그리고 페이지는 수정된 날짜별로 정렬됩니다. 즉, 각 후속 페이지에는 최근에 수정된 거래가 포함되어 있습니다.

00:31:02.000 --> 00:31:05.000
이것이 어떻게 작동하는지 살펴봅시다.

00:31:05.000 --> 00:31:12.000
Get Transaction History 엔드포인트를 호출하고, originalTransactionId를 제공합니다.

00:31:12.000 --> 00:31:18.000
App Store 서버는 해당 사용자에게 최대 20개의 서명된 거래를 반환합니다.

00:31:18.000 --> 00:31:25.000
또한 이 사용자에 대한 다음 페이지 요청에서 제공할 업데이트된 수정 값을 반환합니다.

00:31:25.000 --> 00:31:31.000
응답의 hasMore 필드가 참일 때 더 많은 데이터를 사용할 수 있다는 것을 알게 될 것입니다.

00:31:31.000 --> 00:31:35.000
이 경우 사용 가능한 다른 데이터 페이지가 있다고 가정해 봅시다.

00:31:35.000 --> 00:31:41.000
엔드포인트에 또 다른 요청을 하고, 첫 번째 응답에서 수정 값을 포함합니다.

00:31:41.000 --> 00:31:46.000
업데이트된 수정 값을 포함한 다음 데이터 페이지를 받게 됩니다.

00:31:46.000 --> 00:31:52.000
hasMore는 이제 거짓이므로, 당신은 최신 거래 데이터를 최신 상태로 알고 있습니다.

00:31:52.000 --> 00:31:58.000
이 시간을 제외하고, 당신은 응답에서 최종 거래에 대해 무언가를 알아차렸습니다; 당신은 전에 그것을 본 적이 있습니다!

00:31:58.000 --> 00:32:03.000
그것은 당신의 첫 번째 요청에 대한 응답으로 받은 원래 20개 중 하나였습니다.

00:32:03.000 --> 00:32:10.000
이것은 거래가 수정되었음에 틀림없다는 것을 의미하며, 그래서 그것은 정렬 순서의 맨 위에 다시 놓였다.

00:32:10.000 --> 00:32:15.000
이제, 당신은 그 거래의 데이터를 검토하고 무엇이 변경되었는지 기록할 수 있습니다.

00:32:15.000 --> 00:32:24.000
이 경우, revocationDate와 revocationReason 필드가 이제 채워져 있으며, 이는 거래가 취소되었음을 의미합니다.

00:32:24.000 --> 00:32:29.000
구매와 관련된 모든 콘텐츠를 취소하여 조치를 취할 수 있습니다.

00:32:29.000 --> 00:32:39.000
사용자를 식별하는 데 사용한 원본TransactionId와 함께 이 최종 응답의 수정 값을 저장하는 것이 좋습니다.

00:32:39.000 --> 00:32:50.000
다음에 이 사용자의 엔드포인트를 호출할 때, 해당 수정본을 제공하고 마지막 요청 이후 수정된 새로운 거래 데이터만 다시 받고 있다는 것을 알 수 있습니다.

00:32:50.000 --> 00:33:00.000
보시다시피, Get Transaction History 엔드포인트는 포괄적인 인앱 구매 데이터 세트를 검색할 수 있는 간단한 방법을 제공합니다.

00:33:00.000 --> 00:33:03.000
하지만 가끔은 너무 포괄적일 수도 있어.

00:33:03.000 --> 00:33:09.000
일부 사용자들은 몇 년 전으로 거슬러 올라가는 긴 구매 내역을 가지고 있다.

00:33:09.000 --> 00:33:16.000
이 사용자들을 위해, 이 엔드포인트는 다양한 유형의 수백 건의 구매를 반환할 수 있다.

00:33:16.000 --> 00:33:20.000
페이지가 있더라도, 이것은 처리해야 할 일이 많을 수 있다.

00:33:20.000 --> 00:33:27.000
그것이 올해 우리가 다양한 새로운 종류와 필터 옵션으로 이 엔드포인트를 강화하는 이유입니다.

00:33:27.000 --> 00:33:39.000
이제 처음부터 원하는 데이터를 정확히 알려주면 서버의 처리 시간을 절약하고 사용 가능한 모든 페이지를 검색하는 데 필요한 네트워크 호출 수를 줄일 수 있습니다.

00:33:39.000 --> 00:33:47.000
결과의 첫 페이지에서 가장 최근에 수정된 구매를 보고 싶다면 수정된 날짜를 내림차순으로 정렬할 수 있습니다.

00:33:47.000 --> 00:33:56.000
제품 유형, 제품 ID, 가족 공유 상태 등과 같은 몇 가지 유용한 필드로 필터링할 수도 있습니다.

00:33:56.000 --> 00:34:06.000
이러한 새로운 정렬 및 필터 옵션을 적용하려면, 거래 내역 가져오기 엔드포인트에 대한 요청에 쿼리 매개 변수로 추가하기만 하면 됩니다.

00:34:06.000 --> 00:34:09.000
그것이 어떻게 작동하는지 자세히 살펴봅시다.

00:34:09.000 --> 00:34:12.000
여기서 모든 새로운 매개 변수 옵션을 볼 수 있습니다.

00:34:12.000 --> 00:34:18.000
대부분은 거래 정보 페이로드에서 직접 가져온 것이기 때문에, 이것들은 친숙해 보일 수 있다.

00:34:18.000 --> 00:34:22.000
이러한 매개 변수를 혼합하고 일치시켜 매우 구체적인 결과를 얻을 수 있습니다.

00:34:22.000 --> 00:34:31.000
예를 들어, 우리는 올해 초부터 사용자가 구매한 비소비화 구매만 가져오고 싶을 수도 있습니다.

00:34:31.000 --> 00:34:34.000
우리는 또한 취소된 구매를 제외하고 싶습니다.

00:34:34.000 --> 00:34:45.000
우리는 productType을 NON_CONSUMABLE로 설정하고 밀리초 단위로 표시된 올해의 시작으로 startDate를 지정하여 사용자 지정 요청을 작성할 것입니다.

00:34:45.000 --> 00:34:49.000
마지막으로, 우리는 excludeRevoked를 true로 설정할 것이다.

00:34:49.000 --> 00:34:50.000
그리고 그게 우리의 요청이야!

00:34:50.000 --> 00:34:58.000
우리가 정렬 순서를 지정하지 않았기 때문에, 응답은 수정된 날짜를 오름차순으로 정렬하는 것으로 기본 설정됩니다.

00:34:58.000 --> 00:35:04.000
이제 이와 같은 구체적인 요청에도 불구하고, 검색할 구매 페이지가 여러 개 있을 수 있습니다.

00:35:04.000 --> 00:35:12.000
후속 요청의 경우, 우리는 이전 응답의 수정 사항 외에도 정확히 동일한 쿼리 매개 변수를 포함해야 합니다.

00:35:12.000 --> 00:35:24.000
더 많은 유연성을 위해, 세 개의 필터 필드는 여러 값을 지원하므로, 제공된 값 중 적어도 하나와 일치하는 구매로만 필터링할 수 있습니다.

00:35:24.000 --> 00:35:32.000
이 필드는 productType, productId 및 subscriptionGroupIdentifier입니다.

00:35:32.000 --> 00:35:39.000
이러한 매개 변수에 대해 여러 값을 제공하려면, 여러 번 정의하기만 하면 됩니다.

00:35:39.000 --> 00:35:44.000
다음으로 App Store 서버 알림 업데이트로 넘어가겠습니다.

00:35:44.000 --> 00:35:50.000
App Store Server Notifications V2를 사용하면 서버를 한 단계 끌어올릴 수 있습니다.

00:35:50.000 --> 00:35:57.000
V2 알림은 다른 곳에서는 얻을 수 없는 인앱 구매 이벤트에 대한 자세한 통찰력을 제공합니다.

00:35:57.000 --> 00:36:05.000
이것들은 앱에서 제공되는 자동 갱신 구독의 수명 주기를 추적하는 데 특히 유용합니다.

00:36:05.000 --> 00:36:15.000
이러한 통찰력을 사용하여 고객을 유지하고, 이탈한 사람들을 되찾고, 고객 지원 요청을 해결하는 등 많은 것을 할 수 있습니다.

00:36:15.000 --> 00:36:19.000
이러한 모든 혜택으로, 당신은 어떻게 시작해야 할지 궁금할 것입니다.

00:36:19.000 --> 00:36:24.000
다른 새로운 기능과 마찬가지로, 샌드박스 테스트 환경은 시작하기에 가장 좋은 장소입니다.

00:36:24.000 --> 00:36:35.000
그래서 작년에 우리는 샌드박스에서 App Store 서버 알림을 받기 위해 App Store Connect에서 별도의 서버 URL을 설정할 수 있는 기능을 추가했습니다.

00:36:35.000 --> 00:36:43.000
서버 URL을 등록한 후, 서버가 App Store 서버로부터 알림을 받고 있는지 확인해야 합니다.

00:36:43.000 --> 00:36:49.000
사용자 작업을 통해 알림을 트리거하기 위해 샌드박스 계정을 설정할 수 있습니다.

00:36:49.000 --> 00:36:56.000
예를 들어, 샌드박스 계정을 사용하여 구독을 처음 구매한다고 가정해 봅시다.

00:36:56.000 --> 00:37:03.000
SUBSCRIBED 유형과 INITIAL_BUY 유형의 V2 알림을 받아야 합니다.

00:37:03.000 --> 00:37:05.000
하지만 그 알림이 오지 않으면 어떡하지?

00:37:05.000 --> 00:37:12.000
서버에 문제가 있었는지 또는 알림을 트리거하기 위해 취한 단계가 있는지 궁금할 수 있습니다.

00:37:12.000 --> 00:37:16.000
이 상황은 당신이 시작할 때 많은 불확실성을 유발할 수 있습니다.

00:37:16.000 --> 00:37:25.000
우리는 이 경험을 단순화하고 App Store 서버 알림이 서버에 도달할 수 있는지 쉽게 확인할 수 있는 방법을 제공하고자 합니다.

00:37:25.000 --> 00:37:31.000
그것이 우리가 올해 새로운 테스트 알림 요청 엔드포인트를 도입하는 이유입니다.

00:37:31.000 --> 00:37:42.000
이 간단한 엔드포인트를 호출하면, App Store Connect에서 앱에 등록된 서버 URL로 TEST 유형의 V2 알림을 보내도록 요청할 수 있습니다.

00:37:42.000 --> 00:37:47.000
새로운 테스트 알림 유형은 이 엔드포인트에만 사용됩니다.

00:37:47.000 --> 00:37:55.000
샌드박스 또는 프로덕션에서 엔드포인트를 호출하여 두 환경에 저장된 URL을 테스트할 수 있습니다.

00:37:55.000 --> 00:38:01.000
이 새로운 엔드포인트를 사용하여 새로운 서버 URL과 구성을 빠르게 테스트하세요.

00:38:01.000 --> 00:38:04.000
이것이 어떻게 첫 번째 설정을 단순화하는지 봅시다.

00:38:04.000 --> 00:38:12.000
이제, 첫 번째 알림을 트리거하고 싶다면, 샌드박스 계정을 설정하거나 구매를 수행할 필요가 없습니다.

00:38:12.000 --> 00:38:22.000
테스트하려는 환경에서 새 엔드포인트를 호출하면 요청을 확인하는 HTTP 200 응답을 받게 됩니다.

00:38:22.000 --> 00:38:31.000
응답에는 서버가 받을 테스트 알림을 식별하는 새로운 필드인 testNotificationToken이 포함됩니다.

00:38:31.000 --> 00:38:34.000
우리는 나중에 이 분야로 돌아올 것이다.

00:38:34.000 --> 00:38:43.000
얼마 지나지 않아, 서버는 App Store Connect에 저장된 URL에서 TEST 유형의 V2 알림을 받아야 합니다.

00:38:43.000 --> 00:38:46.000
이제 이 엔드포인트를 어떻게 부르는지 봅시다.

00:38:46.000 --> 00:38:52.000
App Store 서버의 이 새로운 경로로 간단한 POST 요청을 보내세요.

00:38:52.000 --> 00:38:58.000
당신은 HTTP 200 응답을 받게 될 것이며 당신의 요청이 제출되었음을 알게 될 것입니다.

00:38:58.000 --> 00:39:03.000
응답에는 내가 언급한 새로운 필드인 testNotificationToken이 포함될 것이다.

00:39:03.000 --> 00:39:06.000
나중을 위해 이것을 기록하세요.

00:39:06.000 --> 00:39:10.000
곧 서명된 테스트 알림을 받게 될 것입니다.

00:39:10.000 --> 00:39:14.000
디코딩되면 알림의 모습은 다음과 같습니다.

00:39:14.000 --> 00:39:23.000
새로운 notificationType, TEST를 포함하여 V2 알림의 모든 일반적인 최상위 필드가 포함되어 있다는 것을 알게 될 것입니다.

00:39:23.000 --> 00:39:27.000
데이터 객체의 내용은 일반 알림보다 약간 짧다.

00:39:27.000 --> 00:39:40.000
이것은 단지 테스트이기 때문에, 포함할 거래 관련 데이터가 없기 때문에, 우리는 거래 관련 필드, 특히 signedTransactionInfo를 생략합니다.

00:39:40.000 --> 00:39:48.000
새로운 테스트 알림 요청 엔드포인트를 호출할 때, App Store 서버 알림은 비동기적으로 전송된다는 것을 명심하십시오.

00:39:48.000 --> 00:39:59.000
엔드포인트에 대한 성공적인 호출은 HTTP 200을 반환하지만 실제 테스트 알림은 잠시 후에 별도로 도착합니다.

00:39:59.000 --> 00:40:07.000
이 엔드포인트가 서버 구성을 테스트하는 것에 관한 것이라는 점을 감안할 때, 테스트가 실패하면 어떻게 해야 할지 궁금할 수 있습니다.

00:40:07.000 --> 00:40:12.000
즉, 테스트 알림이 도착하지 않으면 어떻게 되나요?

00:40:12.000 --> 00:40:24.000
테스트 기능을 더욱 향상시키기 위해, 테스트 알림 요청 엔드포인트와 함께 사용할 테스트 알림 상태 가져오기 엔드포인트를 출시합니다.

00:40:24.000 --> 00:40:30.000
이 새로운 엔드포인트를 사용하면 이전에 요청한 테스트 알림의 상태를 확인할 수 있습니다.

00:40:30.000 --> 00:40:39.000
엔드포인트 응답은 App Store 서버가 서버에 도달하여 테스트 알림을 성공적으로 보낼 수 있었는지 알려줍니다.

00:40:39.000 --> 00:40:46.000
전송이 실패하면, 그 이유에 대한 아이디어를 얻을 수 있으므로 서버 구성 문제를 더 잘 해결할 수 있습니다.

00:40:46.000 --> 00:40:50.000
이 엔드포인트를 어떻게 사용할지 확인해 봅시다.

00:40:50.000 --> 00:40:54.000
App Store 서버의 이 경로로 GET 요청을 보내세요.

00:40:54.000 --> 00:41:02.000
경로에 테스트 알림 요청 엔드포인트에서 받은 testNotificationToken을 포함하세요.

00:41:02.000 --> 00:41:07.000
이것은 당신이 어떤 테스트 알림을 확인하고 싶은지 알려줄 것입니다.

00:41:07.000 --> 00:41:09.000
이제 답변을 위해.

00:41:09.000 --> 00:41:17.000
서명된 페이로드 필드에는 App Store 서버가 서버로 보내려고 시도한 테스트 알림 페이로드가 포함되어 있습니다.

00:41:17.000 --> 00:41:23.000
그리고 첫 번째 SendAttemptResult 필드는 전송 시도의 결과를 나타냅니다.

00:41:23.000 --> 00:41:34.000
여기서, SUCCESS는 전송이 성공했음을 나타내며, 이는 App Store 서버가 서버로부터 HTTP 200 응답을 받았다는 것을 의미합니다.

00:41:34.000 --> 00:41:40.000
전송이 실패하면, 대신 몇 가지 다른 오류 값 중 하나를 볼 수 있습니다.

00:41:40.000 --> 00:41:48.000
이 값은 App Store 서버가 테스트 알림으로 서버에 도달하려고 시도한 오류를 나타냅니다.

00:41:48.000 --> 00:41:58.000
이 정보를 통해 서버 문제를 해결하고, 필요에 따라 새로운 테스트 알림을 요청하고, 서버를 안정적으로 실행할 수 있습니다.

00:41:58.000 --> 00:42:11.000
총체적으로, 이러한 테스트 알림 엔드포인트는 사용하기 쉽고 V2 App Store 서버 알림을 받기 위해 서버를 설정하거나 재구성할 때 많은 문제를 줄일 수 있습니다.

00:42:11.000 --> 00:42:17.000
이제 이러한 엔드포인트의 도움으로 서버를 설정하고 원활하게 실행되고 있는지 확인할 수 있습니다.

00:42:17.000 --> 00:42:20.000
하지만 서버는 완벽하지 않고 정전이 발생한다.

00:42:20.000 --> 00:42:26.000
서버가 다운되어 App Store 서버 알림을 놓칠 때 어떻게 복구하나요?

00:42:26.000 --> 00:42:30.000
이것에 대한 현재 해결책은 재시도 시스템이다.

00:42:30.000 --> 00:42:36.000
App Store 서버가 서버에 도달하지 못하면, 재시도 프로세스를 시작합니다.

00:42:36.000 --> 00:42:43.000
그것은 같은 알림을 최대 다섯 번까지 다시 보내려고 시도할 것이며, 각 시도 사이에 더 오래 기다릴 것이다.

00:42:43.000 --> 00:42:47.000
이러한 재시도들은 생산 환경에서만 이루어진다.

00:42:47.000 --> 00:42:53.000
재시도 결국 정전에서 회복하는 데 도움이 되지만, 모든 상황에 완벽하지는 않습니다.

00:42:53.000 --> 00:42:57.000
예를 들어, 일부 정전은 광범위할 수 있다.

00:42:57.000 --> 00:43:05.000
서버가 App Store 서버에서 최종 재시도 시도를 놓칠 만큼 충분히 오래 다운된 경우, 해당 알림은 손실됩니다.

00:43:05.000 --> 00:43:13.000
또는 더 일반적으로, 당신의 서버는 소수의 알림만 놓치는 매우 짧은 문제를 경험할 수 있습니다.

00:43:13.000 --> 00:43:20.000
하지만 단 하나의 알림이라도 누락되었다는 것은 고객 기록 중 일부가 적어도 한 시간 동안 오래되었다는 것을 의미합니다.

00:43:20.000 --> 00:43:23.000
하지만 넌 어떤 건지 몰라!

00:43:23.000 --> 00:43:29.000
분명히, 서버 중단은 스트레스가 많으며, 그로부터 회복하는 것은 복잡한 작업이 될 수 있다.

00:43:29.000 --> 00:43:39.000
그렇기 때문에 우리는 놓친 App Store 서버 알림을 가능한 한 쉽게 복구하여 가능한 한 빨리 서버를 정상으로 되돌릴 수 있도록 하고 싶습니다.

00:43:39.000 --> 00:43:45.000
그것이 우리가 올해 새로운 Get Notification History 엔드포인트를 도입하는 이유입니다.

00:43:45.000 --> 00:43:53.000
이 엔드포인트를 사용하면 앱에 대해 생성된 V2 App Store 서버 알림의 기록을 가져올 수 있습니다.

00:43:53.000 --> 00:44:02.000
서버가 알림을 성공적으로 받았는지 여부에 관계없이, 그 알림은 이 엔드포인트의 응답에 나타날 것입니다.

00:44:02.000 --> 00:44:08.000
이 엔드포인트를 호출할 때, 가져올 알림의 날짜 범위를 지정하게 됩니다.

00:44:08.000 --> 00:44:18.000
WWDC와 함께, 우리는 이 데이터를 기록하기 시작했고, 최근 6개월 동안의 롤링 역사의 상한선을 구축할 것입니다.

00:44:18.000 --> 00:44:29.000
선택적으로 유형과 하위 유형별로 요청을 필터링하거나, originalTransactionId를 제공하여 단일 사용자의 알림만 가져올 수 있습니다.

00:44:29.000 --> 00:44:35.000
그리고 기존 재시도 시스템은 여전히 사용할 수 있으므로, 이 새로운 엔드포인트와 함께 사용할 수 있습니다.

00:44:35.000 --> 00:44:39.000
이 엔드포인트를 어떻게 부를지 살펴봅시다.

00:44:39.000 --> 00:44:43.000
App Store 서버의 이 새로운 경로로 POST 요청을 보낼 것입니다.

00:44:43.000 --> 00:44:48.000
요청 본문에 시작 날짜와 종료 날짜를 포함할 것입니다.

00:44:48.000 --> 00:44:54.000
응답에는 이 창에서 처음 보내려고 시도한 알림만 포함됩니다.

00:44:54.000 --> 00:45:02.000
사용 가능한 가장 빠른 알림은 요청 날짜 6개월 전에 전송된다는 것을 명심하세요.

00:45:02.000 --> 00:45:08.000
선택적으로, notificationType과 notificationSubtype을 지정할 수 있습니다.

00:45:08.000 --> 00:45:15.000
그렇게 하면, 기록은 이 두 값과 일치하는 알림으로만 필터링됩니다.

00:45:15.000 --> 00:45:19.000
일부 알림에는 하위 유형이 없다는 것을 명심하세요.

00:45:19.000 --> 00:45:28.000
또는, 사용자의 원본 트랜잭션 ID를 제공하여 해당 사용자의 알림 기록만 가져올 수 있습니다.

00:45:28.000 --> 00:45:37.000
마지막으로, 다음 페이지를 얻으려면 모든 후속 요청에 대한 쿼리 매개 변수로 paginationToken을 제공해야 합니다.

00:45:37.000 --> 00:45:44.000
후속 요청에 동일한 요청 본문을 사용하고, 이 paginationToken만 변경하십시오.

00:45:44.000 --> 00:45:47.000
이제 답변을 살펴봅시다.

00:45:47.000 --> 00:45:55.000
notificationHistory 배열에는 최대 20개의 알림이 포함되어 있으며, 가장 오래된 알림이 먼저 있습니다.

00:45:55.000 --> 00:46:07.000
이 배열의 각 항목은 알림을 나타내며 내부에서 서명된 페이로드를 찾을 수 있으며, 평소와 같이 디코딩하여 거래 데이터를 볼 수 있습니다.

00:46:07.000 --> 00:46:14.000
내부의 데이터는 App Store 서버가 원래 알림에서 보낸 페이로드와 동일합니다.

00:46:14.000 --> 00:46:20.000
당신은 우리가 이 엔드포인트 응답에 새로운 firstSendAttemptResult 필드를 가져왔다는 것을 알게 될 것입니다.

00:46:20.000 --> 00:46:30.000
이 필드를 사용하여 시간 초과 및 기타 오류 시퀀스를 찾아 서버가 과거에 알림을 놓친 이유를 더 잘 이해할 수 있습니다.

00:46:30.000 --> 00:46:36.000
검색할 페이지가 더 있다면 응답에는 paginationToken도 포함되어 있습니다.

00:46:36.000 --> 00:46:41.000
다음 알림 페이지를 받으려면 다음 요청에서 이것을 제공해야 합니다.

00:46:41.000 --> 00:46:47.000
hasMore 필드가 참인 한 검색할 페이지가 더 많다는 것을 알게 될 것입니다.

00:46:47.000 --> 00:46:52.000
그리고 그것이 당신이 이 유용한 새로운 엔드포인트에 대해 알아야 할 모든 것입니다.

00:46:52.000 --> 00:46:56.000
이것으로 오늘의 App Store 서버 업데이트를 마칩니다.

00:46:56.000 --> 00:47:02.000
오늘 발표된 모든 서버 기능은 이제 샌드박스와 프로덕션 모두에서 사용할 수 있습니다.

00:47:02.000 --> 00:47:07.000
우리는 당신이 이 새로운 기능을 활용하여 서버를 최고로 만들기를 바랍니다.

00:47:07.000 --> 00:47:24.000
레거시 클라이언트를 지원하면서 최신 기능을 사용하는 방법을 포함하여 인앱 구매와 함께 서버를 사용하는 더 훌륭한 콘텐츠를 보려면 WWDC22의 다른 세션인 "인앱 구매 통합 및 마이그레이션 탐색"을 확인하는 것이 좋습니다.

00:47:24.000 --> 00:47:27.000
둘 다: WWDC22에 참여해 주셔서 감사합니다!

00:47:27.000 --> 23:59:59.000
♪

