WEBVTT

00:00:00.000 --> 00:00:14.000
- 안녕하세요, TextKit의 새로운 기능 및 텍스트 보기에 오신 것을 환영합니다!

00:00:14.000 --> 00:00:18.000
저는 도나 톰이고, 텍스트킷 엔지니어입니다.

00:00:18.000 --> 00:00:30.000
iOS 15와 macOS Monterey에서, 우리는 성능, 정확성 및 안전성이 향상된 강력한 새로운 텍스트 엔진인 TextKit 2를 도입했습니다.

00:00:30.000 --> 00:00:40.000
TextKit 2의 뷰포트 기반 레이아웃 아키텍처는 특히 내용이 큰 문서에 고성능 텍스트 레이아웃을 제공합니다.

00:00:40.000 --> 00:00:56.000
TextKit 2는 글리프 작업의 불필요한 복잡성을 제거하여 국제 청중에게 더 나은 텍스트 경험을 제공하며, OpenType 및 가변 글꼴과 같은 최신 글꼴 기술을 완벽하게 지원합니다.

00:00:56.000 --> 00:01:10.000
그리고 텍스트 레이아웃을 제어하기 위해 더 높은 수준의 객체로 작업하는 TextKit 2의 초점은 텍스트 레이아웃을 더 쉽게 사용자 정의할 수 있으므로 더 적은 코드로 더 멋진 것을 만들 수 있습니다.

00:01:10.000 --> 00:01:19.000
앞으로, TextKit 2 엔진은 모든 Apple 플랫폼에서 텍스트 레이아웃과 렌더링의 기초를 형성합니다.

00:01:19.000 --> 00:01:28.000
향후 성능 향상, 업데이트 및 개선은 모두 TextKit 2 엔진에 초점을 맞출 것이다.

00:01:28.000 --> 00:01:34.000
TextKit 2로 업데이트함으로써, 당신의 앱은 우리가 출시할 때 이러한 개선의 이점을 얻을 수 있습니다.

00:01:34.000 --> 00:01:39.000
TextKit2에 대한 심층적인 소개를 보려면, Meet TextKit2 비디오를 보세요.

00:01:39.000 --> 00:01:47.000
그 비디오는 기본 사항과 TextKit 2를 사용하여 자신만의 텍스트 레이아웃 구성 요소를 만드는 방법을 다룹니다.

00:01:47.000 --> 00:01:56.000
대조적으로, 이 비디오는 TextKit 2의 최신 발전과 TextKit 2 기반 텍스트 뷰를 최대한 활용하는 방법을 다룹니다.

00:01:56.000 --> 00:02:12.000
맞습니다, 저는 텍스트 보기, 복수형이라고 말했습니다. 왜냐하면 이제 iOS 16과 macOS Ventura부터 UIKit과 AppKit의 모든 텍스트 컨트롤은 UITextView를 포함하여 TextKit 2를 사용하고 있기 때문입니다.

00:02:12.000 --> 00:02:17.000
그래서 우리는 시스템 전체의 레이아웃과 렌더링을 위해 TextKit 2를 사용하고 있습니다.

00:02:17.000 --> 00:02:27.000
모든 앱이 가능한 한 빨리 TextKit 2로 전환하는 것이 중요하며, 더 쉽게 전환할 수 있도록 많은 도구를 추가했습니다.

00:02:27.000 --> 00:02:31.000
많은 앱의 경우, 이것은 제로 코드 전환이 될 수 있다.

00:02:31.000 --> 00:02:36.000
그리고 우리는 이것이 텍스트 보기를 특별히 수정하지 않는 앱에 대해 사실일 것으로 기대합니다.

00:02:36.000 --> 00:02:40.000
나중에 그것에 대해 조금 더 말해줄게.

00:02:40.000 --> 00:02:48.000
하지만 먼저, 제가 방금 언급한 도구 중 일부를 포함하여 TextKit 2의 새로운 기능을 검토하는 것으로 시작하겠습니다.

00:02:48.000 --> 00:02:54.000
그 후, 나는 텍스트 보기를 위한 TextKit 1 호환성 모드의 세부 사항에 대해 자세히 알아볼 것이다.

00:02:54.000 --> 00:03:03.000
그런 다음 코드를 TextKit 2로 전환할 준비를 할 때 사용할 수 있는 현대화 전략에 대한 논의를 마치겠습니다.

00:03:03.000 --> 00:03:08.000
그래서 첫 번째는 TextKit 2의 새로운 기능입니다.

00:03:08.000 --> 00:03:15.000
TextKit 2는 UITextField가 사용하도록 업그레이드된 iOS 15에서 UIKit에 처음 등장했다.

00:03:15.000 --> 00:03:26.000
iOS 16에서는 UITextView를 포함하여 기본적으로 TextKit 2를 사용하는 모든 텍스트 컨트롤과 함께 TextKit 2로의 UIKit 전환이 완료됩니다.

00:03:26.000 --> 00:03:32.000
대부분의 텍스트 보기는 TextKit 2에 자동으로 선택되며, 채택이 전혀 필요하지 않습니다.

00:03:32.000 --> 00:03:42.000
텍스트 보기가 선택되지 않을 수 있는 몇 가지 상황이 있으며, 이 비디오의 호환성 부분에서 다룰 것입니다.

00:03:42.000 --> 00:03:44.000
그리고 그것은 AppKit과 비슷한 이야기이다.

00:03:44.000 --> 00:03:49.000
TextKit 2는 macOS Big Sur에서 AppKit에 처음 등장했다.

00:03:49.000 --> 00:03:58.000
macOS Monterey에서 NSTextField는 기본적으로 사용하도록 업그레이드되었으며, 옵트인하여 NSTextView에서 사용할 수 있었습니다.

00:03:58.000 --> 00:04:03.000
macOS Ventura에서 모든 텍스트 컨트롤은 기본적으로 TextKit 2를 사용합니다.

00:04:03.000 --> 00:04:14.000
UITextView와 마찬가지로, 대부분의 NSTextView는 TextKit 2를 자동으로 선택하며 채택이 전혀 필요하지 않습니다.

00:04:14.000 --> 00:04:22.000
NSTextView 주변의 얇은 래퍼인 TextEdit는 macOS Ventura의 모든 곳에서 TextKit 2를 사용합니다.

00:04:22.000 --> 00:04:27.000
TextEdit는 macOS Big Sur 이후 일반 텍스트 모드에서 TextKit 2를 사용하고 있다.

00:04:27.000 --> 00:04:34.000
macOS Ventura에서 리치 텍스트 모드는 TextKit 2도 사용합니다.

00:04:34.000 --> 00:04:42.000
TextKit 2가 새로운 표준이기 때문에, 우리는 UITextView와 NSTextView 모두를 위한 몇 가지 편의 생성자를 추가했습니다.

00:04:42.000 --> 00:04:49.000
이 새로운 생성자를 사용하여 초기화 시간에 사용할 텍스트 엔진을 선택하세요.

00:04:49.000 --> 00:04:58.000
TextKit 2를 사용하는 텍스트 뷰를 만들려면, 새 생성자를 사용하고 "UsingTextLayoutManager" 매개 변수에 대해 true를 전달하십시오.

00:04:58.000 --> 00:05:07.000
텍스트 보기가 호환성을 위해 TextKit 1을 사용해야 하는 경우, 대신 "false"를 전달하세요.

00:05:07.000 --> 00:05:12.000
그리고 인터페이스 빌더에서 생성된 텍스트 보기를 위한 새로운 텍스트 레이아웃 옵션이 있습니다.

00:05:12.000 --> 00:05:18.000
이 새로운 옵션을 사용하면 인스턴스별로 사용할 레이아웃 시스템을 제어할 수 있습니다.

00:05:18.000 --> 00:05:23.000
기본 설정은 시스템 기본값인 TextKit 2입니다.

00:05:23.000 --> 00:05:30.000
TextKit 2 또는 TextKit 1을 명시적으로 사용하도록 선택할 수도 있습니다.

00:05:30.000 --> 00:05:34.000
TextKit 2는 이제 단순하지 않은 텍스트 컨테이너를 지원합니다.

00:05:34.000 --> 00:05:39.000
단순하지 않은 텍스트 컨테이너에는 구멍이나 틈이 있을 수 있다.

00:05:39.000 --> 00:05:45.000
이것은 텍스트가 이미지나 다른 인라인 콘텐츠를 감싸는 것을 가능하게 한다.

00:05:45.000 --> 00:05:55.000
간단하지 않은 텍스트 컨테이너를 만들려면, NSTextContainer의 exclusionPaths 속성을 사용하여 텍스트를 배치해서는 안 되는 영역을 정의하십시오.

00:05:55.000 --> 00:06:03.000
이를 수행하는 방법의 예를 보려면, 이 비디오와 관련된 리소스에서 TextKitAndTextView 샘플 코드를 확인하세요.

00:06:03.000 --> 00:06:10.000
"배제 경로" 탭에서 관련 예시를 찾을 수 있습니다.

00:06:10.000 --> 00:06:17.000
우리는 정당화된 단락에 대해 더 많은 줄 바꿈을 선택하기 위해 TextKit 2의 줄 바꿈 엔진을 강화했습니다.

00:06:17.000 --> 00:06:23.000
이것은 더 긴 텍스트 단락에서 더 쉽게 알아차릴 수 있는 미묘한 변화이다.

00:06:23.000 --> 00:06:28.000
여기에 같은 영역에 배치된 같은 텍스트의 두 가지 버전이 있습니다.

00:06:28.000 --> 00:06:36.000
전통적인 줄 바꿈이 있는 늘어진 선과 큰 인터워드 간격에 주목하세요.

00:06:36.000 --> 00:06:40.000
새로운 짝수 라인 브레이킹과 함께 일어나는 일이 훨씬 적다.

00:06:40.000 --> 00:06:45.000
이것은 텍스트를 더 쉽게 읽을 수 있게 해주며, TextKit 2로 무료로 받을 수 있습니다.

00:06:45.000 --> 00:06:48.000
입양은 필요하지 않습니다.

00:06:48.000 --> 00:06:53.000
그리고 마지막으로, 우리는 모든 플랫폼에 대해 TextKit 2에 텍스트 목록 지원을 추가했습니다.

00:06:53.000 --> 00:07:00.000
텍스트 목록을 사용하면 텍스트 보기에 표시할 번호 또는 글머리 기호 목록을 프로그래밍 방식으로 만들 수 있습니다.

00:07:00.000 --> 00:07:07.000
TextKit 2는 TextKit 1과 마찬가지로 NSTextList를 사용하여 텍스트 목록을 나타냅니다.

00:07:07.000 --> 00:07:15.000
NSTextList는 AppKit에서만 사용할 수 있었지만, iOS 16에서는 UIKit에서도 사용할 수 있습니다.

00:07:15.000 --> 00:07:25.000
NSmutableParagraphStyle과 함께 NSTextList를 사용하여 텍스트 저장소의 단락이 표시 목록으로 포맷되도록 지정하십시오.

00:07:25.000 --> 00:07:35.000
텍스트 보기는 텍스트 저장소에서 이러한 속성을 선택하고 단락 내용을 목록처럼 보이도록 다시 포맷할 책임이 있습니다.

00:07:35.000 --> 00:07:41.000
NSTextList 자체는 새로운 것이 아니지만, 몇 가지 새로운 TextKit 2가 추가되었습니다.

00:07:41.000 --> 00:07:47.000
목록에는 중첩된 항목이 있을 수 있기 때문에, 그것들을 나무 구조로 표현하는 것은 당연하다.

00:07:47.000 --> 00:07:58.000
TextKit 2에서, 우리는 NSTextElement를 강화하여 자식 및 부모 요소에 액세스하기 위한 속성이 있는 트리로 구조화할 수 있도록 지원했습니다.

00:07:58.000 --> 00:08:02.000
그리고 우리는 NSTextListElement라는 새로운 요소 서브클래스를 추가했습니다.

00:08:02.000 --> 00:08:14.000
콘텐츠 관리자가 텍스트 콘텐츠에서 NSTextList를 발견하면, 목록의 항목을 나타내기 위해 NSTextListElements를 생성합니다.

00:08:14.000 --> 00:08:22.000
텍스트 목록을 만들고 항목을 추가하는 방법에 대해 더 자세히 알아보려면 TextKitAndTextView 샘플 코드를 참조하십시오.

00:08:22.000 --> 00:08:27.000
"목록" 탭에서 관련 예시를 찾을 수 있습니다.

00:08:27.000 --> 00:08:38.000
그리고 샘플 코드를 탐색하는 동안, TextKit 2에서 텍스트 첨부 파일 보기 공급자 API를 사용하는 방법을 보여주는 텍스트 첨부 파일 예제를 놓치지 마세요.

00:08:38.000 --> 00:08:47.000
이 API를 사용하면 UI 또는 NSView를 텍스트 첨부 파일로 사용할 수 있으며, 이벤트는 첨부 파일 보기에서 직접 처리할 수 있습니다.

00:08:47.000 --> 00:08:54.000
이를 통해 텍스트 첨부 파일로 이벤트를 훨씬 쉽게 처리할 수 있으며, TextKit 2에서만 가능합니다.

00:08:54.000 --> 00:08:57.000
좋아, 그게 TextKit 2의 새로운 기능이야.

00:08:57.000 --> 00:09:03.000
다음으로, TextKit 1 호환성 모드에 대해 자세히 알아보겠습니다.

00:09:03.000 --> 00:09:17.000
TextKit 2는 TextKit 1의 디자인에서 매우 급진적인 출발이기 때문에, 우리는 TextKit 2의 완전한 채택이 TextKit 1 아키텍처에 많이 투자된 앱에 시간이 좀 걸릴 수 있다는 것을 알고 있습니다.

00:09:17.000 --> 00:09:28.000
우리는 전환이 이루어질 때까지 이러한 앱이 계속 잘 작동하기를 원하며, 그것이 우리가 UITextView와 NSTextView를 위한 특별한 TextKit 1 호환성 모드를 추가한 이유입니다.

00:09:28.000 --> 00:09:41.000
NSLayoutManager API를 명시적으로 호출할 때, 텍스트 뷰는 NSTextLayoutManager를 NSLayoutManager로 대체하고 TextKit 1을 사용하도록 재구성합니다.

00:09:41.000 --> 00:09:52.000
이것은 텍스트 보기가 테이블과 같은 TextKit 2에서 아직 지원되지 않는 속성이나 인쇄할 때 발생할 수도 있습니다.

00:09:52.000 --> 00:10:01.000
UITextView에서 TextKit 1에 대한 예상치 못한 런타임 폴백이 발생하면, 로그에서 스위치에 대한 메시지 경고를 확인하십시오.

00:10:01.000 --> 00:10:13.000
기호 밑줄 UITextViewEnablingCompatibilityMode에 중단점을 설정하여 스택 추적 및 기타 유용한 디버깅 정보를 캡처하십시오.

00:10:13.000 --> 00:10:25.000
NSTextView의 경우, willSwitch 또는 didSwitchToNSLayoutManager 알림을 구독하여 예상치 못한 런타임 대체에 대한 자세한 정보를 얻을 수 있습니다.

00:10:25.000 --> 00:10:34.000
TextKit 1로 돌아가야 하는 경우, 프로그래밍 방식으로 초기화된 텍스트 보기로 초기화 시간에 옵트아웃하는 것이 가장 좋습니다.

00:10:34.000 --> 00:10:40.000
자신만의 텍스트 컨테이너와 TextKit 1 레이아웃 관리자를 사용하여 이것을 하세요.

00:10:40.000 --> 00:10:49.000
또 다른 옵션은 새로운 편의 생성자를 사용하여 TextKit 1 텍스트 뷰를 초기화하고 false를 매개 변수로 전달하는 것입니다.

00:10:49.000 --> 00:10:54.000
이렇게 하면 텍스트 보기가 TextKit 1을 사용할 수 있습니다.

00:10:54.000 --> 00:11:03.000
그리고 세 번째 옵션은 인터페이스 빌더를 사용하고 텍스트 보기에서 새로운 텍스트 레이아웃 옵션을 TextKit 1로 설정하는 것입니다.

00:11:03.000 --> 00:11:05.000
여기 조심해야 할 것이 있습니다.

00:11:05.000 --> 00:11:16.000
초기화 중 또는 초기화 후에 텍스트 컨테이너의 레이아웃 관리자를 교체하는 경우, 텍스트 보기는 설계된 대로 TextKit 1로 돌아갑니다.

00:11:16.000 --> 00:11:24.000
초기화 중에 모든 TextKit 2 객체를 만들어 잠시 후에 버리는 것은 비효율적이다.

00:11:24.000 --> 00:11:28.000
타이밍에 따라 잠재적인 사용자 부작용도 있습니다.

00:11:28.000 --> 00:11:38.000
타이핑 중에 발생하면 텍스트 보기가 초점을 잃고 입력을 중단할 수 있으며, 재개하려면 텍스트 보기를 다시 선택해야 합니다.

00:11:38.000 --> 00:11:44.000
초기화 시간에 텍스트 보기를 선택하여 이것을 피하세요.

00:11:44.000 --> 00:11:54.000
이제 호환성 모드에 대한 모든 것을 알았으니, 앱을 현대화하고 TextKit 2를 채택하여 완전히 피하는 방법에 대해 이야기할 때입니다.

00:11:54.000 --> 00:11:59.000
그리고 네가 기억했으면 하는 정말 중요한 게 하나 있어.

00:11:59.000 --> 00:12:03.000
텍스트 보기당 하나의 레이아웃 관리자만 있을 수 있습니다.

00:12:03.000 --> 00:12:11.000
텍스트 보기는 NSTextLayoutManager와 NSLayoutManager를 동시에 가질 수 없습니다.

00:12:11.000 --> 00:12:17.000
텍스트 보기가 TextKit 1로 전환되면, 자동으로 돌아갈 방법이 없습니다.

00:12:17.000 --> 00:12:25.000
레이아웃 시스템을 전환하는 과정은 비용이 많이 들고, 전환 당시에 존재했던 UI 상태를 잃게 될 것입니다.

00:12:25.000 --> 00:12:33.000
따라서 최적의 성능과 유용성을 위해, 시스템은 텍스트 보기를 TextKit 1에서 TextKit 2로 다시 전환하지 않습니다.

00:12:33.000 --> 00:12:36.000
그건 일방통행이야.

00:12:36.000 --> 00:12:42.000
이것은 호환성 모드를 피하는 것이 정말 중요하다는 것을 의미합니다.

00:12:42.000 --> 00:12:46.000
그리고 텍스트 보기가 호환성 모드로 들어가는 몇 가지 다른 이유가 있습니다.

00:12:46.000 --> 00:12:55.000
텍스트 보기가 호환성 모드로 들어가는 가장 큰 이유는 텍스트 보기의 layoutManager 속성에 액세스하는 것입니다.

00:12:55.000 --> 00:12:59.000
다른 이유들은 훨씬 덜 흔하다.

00:12:59.000 --> 00:13:05.000
따라서 중요한 전략은 텍스트 뷰의 레이아웃 관리자 속성에 접근하지 않는 것이다.

00:13:05.000 --> 00:13:11.000
또한 텍스트 보기의 텍스트 컨테이너를 통해 레이아웃 관리자에 접근하지 마세요.

00:13:11.000 --> 00:13:20.000
이러한 속성의 사용에 대한 코드를 감사하고, 제거하거나 TextKit 2 등가물로 바꾸세요.

00:13:20.000 --> 00:13:29.000
TextKit 2가 없는 이전 OS 버전에 앱을 배포하는 경우, layoutManager 코드를 완전히 제거하지 못할 수도 있습니다.

00:13:29.000 --> 00:13:36.000
이 경우, 먼저 텍스트 보기의 NSTextLayoutManager를 확인해야 합니다.

00:13:36.000 --> 00:13:45.000
TextKit 2 코드를 if 절에 넣고 TextKit 1 코드를 layoutManager 액세스를 포함하여 else 절에 넣으세요.

00:13:45.000 --> 00:13:57.000
이렇게 하면, TextKit 1 코드는 TextKit 2를 사용할 수 없을 때만 실행되며, layoutManager 쿼리는 TextKit 1에 대한 의도하지 않은 대체를 일으키지 않습니다.

00:13:57.000 --> 00:14:09.000
이 모든 조언을 따랐지만 여전히 시스템에서 오는 TextKit 1에 대한 예상치 못한 대체가 발생한다면, 그것은 우리의 문제이므로 피드백 어시스턴트에 문제를 보고하십시오.

00:14:09.000 --> 00:14:25.000
UIKit의 Underscore UITextViewEnablingCompatibilityMode 또는 AppKit의 willSwitchToNSLayoutManagerNotification에서 얻을 수 있는 폴백 시 스택 추적 캡처를 포함합니다.

00:14:25.000 --> 00:14:34.000
좋아요, 이제 NSLayoutManager부터 시작하여 TextKit 1 유형과 관련된 코드 업데이트에 대해 자세히 설명하겠습니다.

00:14:34.000 --> 00:14:44.000
NSLayoutManager 쿼리에 대한 코드를 감사하면, NSTextLayoutManager로 TextKit 2 등가물을 알아내야 합니다.

00:14:44.000 --> 00:14:51.000
일부 레이아웃 관리자 API는 TextKit 1과 2 사이에 비슷한 이름을 가지고 있으며, 대체는 간단합니다.

00:14:51.000 --> 00:14:53.000
여기 몇 가지 예가 있습니다.

00:14:53.000 --> 00:15:04.000
TextKit 1에서 NSLayoutManager에서 usedRect(for: textContainer)를 호출하여 텍스트 컨테이너 내부의 텍스트에 대한 경계 사각형을 가져옵니다.

00:15:04.000 --> 00:15:12.000
TextKit 2에서는 NSTextLayoutManager의 usageBoundsForTextContainer 속성에서 이것을 얻을 수 있습니다.

00:15:12.000 --> 00:15:21.000
TextKit 1에서, 우리는 레이아웃이 아닌 렌더링에만 영향을 미치는 속성에 대해 "임시 속성"이라는 이름을 사용했습니다.

00:15:21.000 --> 00:15:27.000
TextKit 2에서, 우리는 그것들을 더 정확하게 "렌더링 속성"이라고 부른다.

00:15:27.000 --> 00:15:33.000
하지만 TextKit 2에는 직접적인 등가물이 없는 일부 TextKit 1 API가 있습니다.

00:15:33.000 --> 00:15:43.000
이유를 이해하려면, 칸나다와 같은 인도 문자의 많은 단어에 대한 글리프 매핑에 올바른 문자가 없다는 것을 이해해야 합니다.

00:15:43.000 --> 00:15:50.000
이 스크립트에서 글리프는 분할, 재정렬, 재결합 또는 삭제할 수 있습니다.

00:15:50.000 --> 00:16:03.000
NSLayoutManager의 글리프 기반 API는 연속적인 범위의 문자를 연속적인 글리프 범위와 직접 연결할 수 있다고 가정하며, 이는 모든 스크립트에 해당되지 않습니다.

00:16:03.000 --> 00:16:09.000
이러한 API를 사용하면 칸나다어와 같은 스크립트로 작성된 텍스트의 레이아웃과 렌더링이 중단될 수 있습니다.

00:16:09.000 --> 00:16:14.000
그것이 TextKit 2에 글리프 API가 없는 이유입니다.

00:16:14.000 --> 00:16:19.000
TextKit 1 글리프 API를 단일 TextKit 2 API로 대체할 수 없습니다.

00:16:19.000 --> 00:16:24.000
이러한 API를 교체하려면 다른 접근 방식이 필요합니다.

00:16:24.000 --> 00:16:28.000
글리프 기반 코드를 업데이트하는 방법은 다음과 같습니다.

00:16:28.000 --> 00:16:33.000
첫 번째 단계는 어떤 글리프 API를 사용하고 있는지 식별하는 것입니다.

00:16:33.000 --> 00:16:40.000
다음으로, 그 API를 어떻게 사용하고 있는지 살펴보고 높은 수준에서 하려고 하는 것을 정의하세요.

00:16:40.000 --> 00:16:48.000
글리프 기반 코드는 매우 낮은 수준이며, 높은 수준의 작업과 관련이 없는 많은 세부 사항이 있습니다.

00:16:48.000 --> 00:16:58.000
고급 작업을 정의한 다음, 레이아웃 조각, 선 조각 및 텍스트 선택과 같은 TextKit 2에서 사용할 수 있는 구조를 검토하십시오.

00:16:58.000 --> 00:17:02.000
이것들은 당신이 임무를 완수하는 데 도움이 될 수 있습니다.

00:17:02.000 --> 00:17:06.000
예를 들어, 이 TextKit 1 코드를 고려해 보세요.

00:17:06.000 --> 00:17:15.000
여기에는 두 개의 글리프 API가 사용됩니다: numberOfGlyphs와 lineFragmentRect(forGlyphAt: index).

00:17:15.000 --> 00:17:22.000
이 TextKit 1 코드는 문서의 모든 글리프를 반복하고 라인 조각 rects를 계산합니다.

00:17:22.000 --> 00:17:29.000
높은 수준의 작업은 텍스트 보기에서 래핑된 텍스트의 줄 수를 세는 것이다.

00:17:29.000 --> 00:17:40.000
이 코드는 라인 조각 rects에서 작동하기 때문에, 사용할 TextKit 2 구조는 NSTextLineFragment와 NSTextLayoutFragment입니다.

00:17:40.000 --> 00:17:43.000
그리고 여기 TextKit 2를 사용하기 위해 다시 작성된 코드가 있습니다.

00:17:43.000 --> 00:17:57.000
글리프를 반복하는 대신, 문서의 텍스트 레이아웃 조각을 열거하고 각 레이아웃 조각 내의 모든 텍스트 줄 조각을 계산하는 클로저를 제공합니다.

00:17:57.000 --> 00:18:01.000
TextKit 2에 대한 자신의 코드를 업데이트할 때 그 예시를 명심하세요.

00:18:01.000 --> 00:18:09.000
이제 나는 기어를 바꾸고 NSRange를 기반으로 한 코드 업데이트에 대해 논의할 것이다.

00:18:09.000 --> 00:18:19.000
TextKit 1은 NSRange를 사용하여 텍스트 콘텐츠에 인덱싱하며, NSRange는 문자열에 대한 선형 인덱스입니다.

00:18:19.000 --> 00:18:36.000
"Hello TextKit 2!"라는 텍스트 느낌표, "TextKit 2 느낌표"를 나타내는 NSRange는 6번째 문자에서 시작하여 10자 길이이기 때문에 위치 6과 길이 10입니다.

00:18:36.000 --> 00:18:43.000
이 선형 모델은 이해하기 쉽고, 문자열에 인덱싱하는 데 적합합니다.

00:18:43.000 --> 00:18:50.000
하지만 선형 모델은 문자열보다 더 많은 구조를 가진 콘텐츠에 인덱싱하는 데 작동하지 않습니다.

00:18:50.000 --> 00:18:52.000
여기 예시가 있어.

00:18:52.000 --> 00:18:58.000
HTML 문서는 트리 구조로 표시되며, 각 태그는 트리의 노드입니다.

00:18:58.000 --> 00:19:10.000
만약 우리의 Hello TextKit 2라면! 텍스트는 HTML 문서의 일부이며, NSRange는 텍스트가 3단계 깊이 중첩된 스팬 태그 안에 있다고 말할 방법이 없습니다.

00:19:10.000 --> 00:19:19.000
선형 모델은 그 정보를 저장할 만큼 충분히 표현력이 없기 때문에, 우리는 그것을 이것과 같은 중첩된 구조에 인덱싱하는 데 사용할 수 없다.

00:19:19.000 --> 00:19:26.000
이것이 TextKit 2가 텍스트 콘텐츠의 범위를 나타내기 위한 새로운 유형을 추가한 이유입니다.

00:19:26.000 --> 00:19:33.000
NSTextLocation은 텍스트 콘텐츠 내부의 단일 위치를 나타내는 객체이다.

00:19:33.000 --> 00:19:38.000
NSTextRange는 시작과 끝 위치로 구성되어 있다.

00:19:38.000 --> 00:19:42.000
최종 위치는 범위에서 제외됩니다.

00:19:42.000 --> 00:19:53.000
이러한 새로운 유형은 DOM 노드와 문자 오프셋으로 위치를 정의하여 이 HTML 문서의 중첩된 구조를 나타낼 수 있습니다.

00:19:53.000 --> 00:20:03.000
NSTextLocation은 프로토콜이기 때문에, 모든 사용자 지정 객체는 NSTextLocation 프로토콜 방법을 구현하는 한 위치가 될 수 있습니다.

00:20:03.000 --> 00:20:11.000
이것은 모델에서 구조화된 데이터를 지원하는 다양한 유형의 백업 스토어와 협력하기 위한 중요한 인프라이다.

00:20:11.000 --> 00:20:23.000
하지만 텍스트 뷰는 이 구조가 없는 NSAttributedString 백업 저장소를 기반으로 하며, 당신을 포함한 많은 앱을 깨뜨리지 않고는 변경할 수 없습니다.

00:20:23.000 --> 00:20:30.000
따라서 selectedRange 또는 scrollRangeToVisible과 같은 텍스트 보기 API를 사용할 때 NSRange를 계속 사용할 수 있습니다.

00:20:30.000 --> 00:20:40.000
그리고 TextKit 2 레이아웃 관리자 또는 콘텐츠 관리자와 통신할 때 NSRange와 NSTextRange 간에 변환해야 합니다.

00:20:40.000 --> 00:20:50.000
텍스트 뷰의 NSRange를 NSTextRange로 변환하려면, 위치를 속성 문자열에 대한 정수 인덱스로 정의하십시오.

00:20:50.000 --> 00:20:56.000
NSRange 위치를 NSTextRange의 시작 위치로 사용하세요.

00:20:56.000 --> 00:21:02.000
NSRange 위치와 길이를 NSTextRange의 끝 위치로 사용하세요.

00:21:02.000 --> 00:21:09.000
개념적으로, 그것은 NSRange에서 NSTextRange로 매핑하는 방법이다.

00:21:09.000 --> 00:21:17.000
실제로, NSTextLocations는 객체여야 하기 때문에 코드는 조금 다르게 보인다.

00:21:17.000 --> 00:21:21.000
위치를 계산하려면 콘텐츠 관리자를 거쳐야 합니다.

00:21:21.000 --> 00:21:31.000
시작 위치의 경우, 콘텐츠 관리자에게 문서의 시작 위치를 요청한 다음 NSRange의 위치로 오프셋하십시오.

00:21:31.000 --> 00:21:38.000
그런 다음 시작 위치를 NSRange의 길이로 상쇄하여 최종 위치를 얻으십시오.

00:21:38.000 --> 00:21:45.000
다른 방향으로 가려면, 텍스트 콘텐츠 관리자를 사용하여 두 개의 다른 오프셋을 얻으세요.

00:21:45.000 --> 00:21:53.000
NSRange의 위치는 문서의 시작 부분과 NSTextRange의 위치 사이의 오프셋이다.

00:21:53.000 --> 00:22:01.000
그리고 NSRange의 길이는 NSTextRange의 시작과 끝 위치 사이의 오프셋이다.

00:22:01.000 --> 00:22:09.000
UITextViews와 UITextFields는 UITextPosition과 범위를 사용하는 UITextInput 프로토콜을 준수합니다.

00:22:09.000 --> 00:22:19.000
대부분의 경우, UITextView 또는 UITextField를 사용할 때 UITextRange를 NSTextRange로 직접 변환할 필요가 없습니다.

00:22:19.000 --> 00:22:26.000
하지만 그렇게 한다면, 정수 오프셋을 두 범위 유형 사이의 중개자로 사용하세요.

00:22:26.000 --> 00:22:38.000
반면에, UITextInput과 함께 사용자 지정 보기를 사용하는 경우, 보기와 함께 사용되는 UITextPosition 및 UITextRange 하위 클래스를 직접 제어할 수 있습니다.

00:22:38.000 --> 00:22:51.000
UITextPosition 서브클래스를 NSTextLocation에 적합하게 하고, 필요한 메소드를 구현하고, 서브클래스를 사용하여 NSTextRanges를 직접 만들 수 있습니다.

00:22:51.000 --> 00:23:02.000
마지막으로, 두 뷰의 콘텐츠가 비슷하더라도 다른 뷰에서 UITextPosition 객체를 재사용하지 않도록 상기시켜 드립니다.

00:23:02.000 --> 00:23:09.000
UITextPosition은 그것을 만드는 데 사용된 보기에만 유효합니다.

00:23:09.000 --> 00:23:14.000
좋아요, 이제 당신은 코드를 현대화하기 위한 많은 전략을 가지고 있습니다.

00:23:14.000 --> 00:23:21.000
이러한 전략을 적용하면, 당신의 앱은 TextKit 2의 이점을 얻을 준비가 될 것입니다.

00:23:21.000 --> 00:23:24.000
그리고 그것이 TextKit과 텍스트 보기의 새로운 기능입니다.

00:23:24.000 --> 00:23:33.000
저는 TextKit 2의 많은 개선 사항을 다루었고 이전 OS 버전과의 호환성을 유지하면서 앱을 업데이트하기 위한 몇 가지 전략을 공유했습니다.

00:23:33.000 --> 00:23:39.000
오늘 앱에서 TextKit 2를 사용하여 새로운 개선 사항을 최대한 활용하세요.

00:23:39.000 --> 00:23:44.000
텍스트 보기를 확인하여 의도치 않게 TextKit 1로 돌아가지 않았는지 확인하세요.

00:23:44.000 --> 00:23:50.000
그리고 마지막으로, TextKit 2에서 앱을 얻기 위해 현대화 전략을 사용하세요.

00:23:50.000 --> 00:23:55.000
우리는 당신이 TextKit 2와 텍스트 보기로 만들 것을 빨리 읽고 싶습니다.

00:23:55.000 --> 23:59:59.000
봐줘서 고마워!

