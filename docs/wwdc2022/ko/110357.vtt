WEBVTT

00:00:00.000 --> 00:00:13.000
- 안녕하세요, 저는 Michael Ilseman이고 Swift 표준 라이브러리 팀의 엔지니어입니다.

00:00:13.000 --> 00:00:17.000
우리가 만나서 스위프트에서 Regex에 대해 알게 되면서 저와 함께 하세요.

00:00:17.000 --> 00:00:21.000
스위프트 레게스에는 많은 것이 있으며, 우리는 그것이 제공하는 모든 것을 맛볼 것이다.

00:00:21.000 --> 00:00:30.000
우리가 불규칙성에 대한 거래를 분석하는 도구에 대해 일부 금융 조사관과 협력하는 개발자라고 가정해 봅시다.

00:00:30.000 --> 00:00:36.000
이제, 당신은 이 중요한 작업을 위해 우리가 잘 구조화된 데이터를 처리하고 있다고 생각할 것입니다.

00:00:36.000 --> 00:00:40.000
하지만 대신에, 우리는 많은 끈을 가지고 있다.

00:00:40.000 --> 00:00:53.000
여기서 첫 번째 필드에는 거래 종류, 두 번째 필드는 거래 날짜, 세 번째 필드는 개인 또는 기관, 네 번째 및 최종 필드는 미국 달러 금액입니다.

00:00:53.000 --> 00:01:06.000
필드는 아무도 기억할 수 없는 매우 중요한 기술적 이유로 2개 이상의 공백이나 탭으로 구분됩니다.

00:01:06.000 --> 00:01:11.000
그리고, 네, 그 날짜 필드는 완전히 모호합니다.

00:01:11.000 --> 00:01:16.000
우리는 단지 그것이 월/일/년이기를 바라고 무슨 일이 일어나는지 볼 것이다.

00:01:16.000 --> 00:01:26.000
이러한 트랜잭션을 처리하는 것은 문자열을 처리하는 것을 포함하며, 문자열은 컬렉션이며, 이는 우리가 일반 컬렉션 알고리즘에 접근할 수 있다는 것을 의미합니다.

00:01:26.000 --> 00:01:34.000
이 알고리즘은 기본적으로 요소를 통해 작동하는 것과 인덱스를 통해 작동하는 두 가지 종류로 제공됩니다.

00:01:34.000 --> 00:01:45.000
우리는 거래 필드를 분할하여 요소 기반 알고리즘을 사용하려고 시도할 수 있지만, 필드 구분 기호가 탭 또는 2개 이상의 공백이기 때문에 이것이 어렵습니다.

00:01:45.000 --> 00:01:48.000
공백만으로 나누는 것은 그것을 자르지 않는다.

00:01:48.000 --> 00:01:55.000
또 다른 접근 방식은 낮은 수준의 인덱스 조작 코드로 내려가는 것이다.

00:01:55.000 --> 00:02:01.000
하지만 제대로 하는 것은 어렵고, 당신이 무엇을 하고 있는지 알더라도, 여전히 많은 코드가 필요합니다.

00:02:01.000 --> 00:02:02.000
다시 헤어지자.

00:02:02.000 --> 00:02:09.000
이 접근 방식이 작동하지 않는 이유는 필드 구분 기호가 더 복잡한 패턴인 동안 요소 기반이기 때문이다.

00:02:09.000 --> 00:02:15.000
다양한 언어에서 발견되는 해결책은 정규 표현식을 쓰는 것이다.

00:02:15.000 --> 00:02:21.000
정규 표현식은 정규 언어를 정의하는 공식 언어 이론에서 나왔다.

00:02:21.000 --> 00:02:28.000
그들은 편집기와 명령줄 도구의 검색과 컴파일러의 어휘 분석을 위한 실용적인 응용 프로그램을 입력했다.

00:02:28.000 --> 00:02:40.000
이러한 응용 프로그램은 입력, 제어 및 직접 실행의 일부를 추출하고 표현력을 추가해야 하기 때문에 이론적 뿌리를 넘어 정규 표현식을 사용합니다.

00:02:40.000 --> 00:02:42.000
그리고 스위프트는 그들을 더 멀리 데려가고 있다.

00:02:42.000 --> 00:02:45.000
우리는 이것을 파생 Regex라고 부른다.

00:02:45.000 --> 00:02:52.000
Regex는 캡처를 포함하여 그것을 적용한 결과인 출력에 대한 일반적인 구조체이다.

00:02:52.000 --> 00:02:58.000
슬래시 구분 기호 사이에 정규식 구문을 포함하는 리터럴을 사용하여 하나를 만들 수 있습니다.

00:02:58.000 --> 00:03:07.000
스위프트의 정규식 구문은 펄, 파이썬, 루비, 자바, NSRegularExpression 등과 호환됩니다.

00:03:07.000 --> 00:03:10.000
이 정규 표현식은 하나 이상의 숫자와 일치한다.

00:03:10.000 --> 00:03:20.000
컴파일러는 정규식 구문을 알고 있으므로, 구문 강조 표시, 컴파일 시간 오류, 심지어 강력하게 입력된 캡처를 얻을 수 있으며, 이는 나중에 만날 것입니다.

00:03:20.000 --> 00:03:25.000
정규 표현식 구문은 동일한 정규식 구문을 포함하는 문자열에서 런타임에 만들 수 있습니다.

00:03:25.000 --> 00:03:29.000
이것은 편집기나 명령줄 도구의 검색 필드에 유용합니다.

00:03:29.000 --> 00:03:34.000
입력에 잘못된 구문이 포함되어 있으면 런타임에 오류가 발생합니다.

00:03:34.000 --> 00:03:44.000
캡처의 유형과 수는 런타임까지 알려지지 않기 때문에 출력 유형은 실존적 AnyRegexOutput이다.

00:03:44.000 --> 00:03:53.000
그리고 같은 정규 표현식은 더 장황하지만 선언적이고 잘 구조화된 정규 표현식 빌더를 사용하여 작성할 수 있다.

00:03:53.000 --> 00:03:57.000
정규식 리터럴을 사용하기 위해 이전부터 분할 접근 방식을 적용합시다.

00:03:57.000 --> 00:04:03.000
첫 번째 부분은 공백 문자의 2개 이상의 발생과 일치한다.

00:04:03.000 --> 00:04:07.000
두 번째 부분은 하나의 수평 탭과 일치한다.

00:04:07.000 --> 00:04:17.000
그리고 파이프 문자는 대안 사이의 선택을 나타내며, 우리에게 2개 이상의 공백 또는 단일 탭의 필드 구분 기호를 제공합니다.

00:04:17.000 --> 00:04:29.000
이제 우리의 필드가 분할되었습니다. 문명 자체에 기여하고 필드 구분 기호를 단일 탭으로 정상화하고 완료합시다.

00:04:29.000 --> 00:04:40.000
분할 후 결과에 대해 'join'을 호출할 수 있지만, 더 나은 알고리즘이 있습니다: '교체'를 사용하면 모든 필드 구분 기호를 단일 탭으로 바꿀 수 있습니다.

00:04:40.000 --> 00:04:46.000
그래서 우리는 나가서 우리의 분명히 우월한 접근 방식을 듣는 사람에게 전도한다.

00:04:46.000 --> 00:04:50.000
입양은... 느리지만 유망하다.

00:04:50.000 --> 00:04:55.000
정규 표현식에 익숙하다면, 그들의 엇갈린 평판을 알 수도 있습니다.

00:04:55.000 --> 00:05:00.000
옛 속담처럼, "나는 문제가 있어서 정규 표현식을 썼다.

00:05:00.000 --> 00:05:02.000
이제 나는 두 가지 문제가 있어."

00:05:02.000 --> 00:05:05.000
하지만 스위프트 정규 표현식은 다르다.

00:05:05.000 --> 00:05:09.000
스위프트는 네 가지 핵심 영역에서 예술을 발전시킨다.

00:05:09.000 --> 00:05:15.000
Regex 구문은 간결하고 표현력이 있지만, 간결하고 읽기 어려울 수 있다.

00:05:15.000 --> 00:05:20.000
그리고 새로운 기능은 점점 더 모호한 구문을 사용해야 한다.

00:05:20.000 --> 00:05:26.000
Swift regexes는 Regex 빌더를 통해 소스 코드를 구조화하고 구성하는 방식으로 구조화하고 구성할 수 있습니다.

00:05:26.000 --> 00:05:36.000
리터럴은 간결하고, 건축업자는 구조를 제공하며, 리터럴은 건축업자 내에서 완벽한 균형을 찾기 위해 사용할 수 있다.

00:05:36.000 --> 00:05:45.000
데이터에 대한 텍스트 표현은 훨씬 더 복잡해졌고, 그것들을 올바르게 처리하려면 표준을 준수하는 파서가 필요하다.

00:05:45.000 --> 00:05:52.000
Swift regex를 사용하면 산업 강도 파서를 regex의 개별 구성 요소로 엮을 수 있습니다.

00:05:52.000 --> 00:05:58.000
이것은 라이브러리 확장 가능한 방식으로 이루어지며, 이는 모든 파서가 참여할 수 있다는 것을 의미한다.

00:05:58.000 --> 00:06:10.000
적용된 정규 표현식의 역사의 대부분은 전체 컴퓨터 시스템이 단일 언어와 인코딩, 특히 ASCII만 지원하는 세계에서 일어났다.

00:06:10.000 --> 00:06:13.000
하지만 현대 세계는 유니코드이다.

00:06:13.000 --> 00:06:18.000
스위프트 정규 표현은 표현력을 손상시키지 않으면서 유니코드를 한다.

00:06:18.000 --> 00:06:25.000
그리고 마지막으로, 정규 표현식의 힘은 철저하게 탐구되어야 하는 광범위한 검색 공간을 열 수 있다.

00:06:25.000 --> 00:06:28.000
이것은 그들의 실행을 추론하기 어렵게 만든다.

00:06:28.000 --> 00:06:35.000
일부 언어는 컨트롤을 지원하지만, 암호 구문 뒤에 있기 때문에 모호한 경향이 있다.

00:06:35.000 --> 00:06:41.000
스위프트 정규 표현식스는 예측 가능한 실행과 표면 컨트롤을 눈에 띄게 제공한다.

00:06:41.000 --> 00:06:52.000
우리가 작업해온 재무제표로 돌아가서 스위프트에서 문자열 처리에 대한 선언적 접근 방식인 Regex 빌더를 사용하여 각 거래를 완전히 구문 분석해 봅시다.

00:06:52.000 --> 00:06:56.000
우리는 시작하기 위해 RegexBuilder 모듈을 가져올 것이다.

00:06:56.000 --> 00:07:01.000
우리는 방금 정의한 필드 구분 기호 정규식을 재사용할 수 있다.

00:07:01.000 --> 00:07:05.000
첫 번째 필드는 간단하다; 그것은 신용 또는 차변이다.

00:07:05.000 --> 00:07:10.000
우리는 그것을 쓰기 위해 이미 본 정규 문자 구문을 사용할 수 있다.

00:07:10.000 --> 00:07:13.000
그 후에 필드 구분 기호가 나오고, 그 다음에 날짜가 온다.

00:07:13.000 --> 00:07:16.000
손으로 날짜를 분석하는 것은 나쁜 생각이다.

00:07:16.000 --> 00:07:25.000
재단은 날짜, 숫자 및 URL과 같은 유형에 대해 정말 좋은 파서를 가지고 있으며, Regex Builder에서 직접 사용할 수 있습니다.

00:07:25.000 --> 00:07:30.000
우리는 저자의 의도에 대한 최선의 추측인 명시적인 로케일을 제공한다.

00:07:30.000 --> 00:07:35.000
우리는 시스템의 현재 로케일을 암시적으로 사용하는 대신 이것을 한다.

00:07:35.000 --> 00:07:43.000
우리는 항상 나중에 그것을 바꿀 수 있으며, 코드에서 우리의 가정을 명백하게 했기 때문에 쉽게 할 수 있다.

00:07:43.000 --> 00:07:48.000
세 번째 필드는 "무엇이든"일 수 있으므로, 그냥 "무엇이든 하나 이상"이라고 쓰고 싶은 유혹이 있다.

00:07:48.000 --> 00:07:58.000
그리고 그것이 우리에게 올바른 답을 줄 것이지만, 그것은 먼저 많은 불필요한 일을 한다. 왜냐하면 그것은 그 이후에 오는 다른 모든 것을 일치시키는 것으로 시작하기 때문이다.

00:07:58.000 --> 00:08:02.000
정규 표현식 표현식은 한 번에 한 문자씩 백업하고 나머지 패턴을 시도할 것이다.

00:08:02.000 --> 00:08:08.000
우리는 종단 필드 구분자를 볼 때 정규 표현식에서 멈추라고 말하고 싶습니다.

00:08:08.000 --> 00:08:10.000
우리가 이것을 성취할 수 있는 꽤 많은 방법이 있다.

00:08:10.000 --> 00:08:20.000
이것을 하는 한 가지 좋은 방법은 실제로 소비하지 않고 입력의 다음 부분을 엿보는 NegativeLookahead를 사용하는 것이다.

00:08:20.000 --> 00:08:26.000
여기서 우리는 어떤 문자와도 일치하기 전에 필드 구분 기호가 나오지 않는지 확인하기 위해 입력을 엿봅니다.

00:08:26.000 --> 00:08:35.000
NegativeLookahead는 Regex가 구성 요소와 어떻게 일치하는지 정확하게 제어할 수 있는 도구 제품군 중 하나입니다.

00:08:35.000 --> 00:08:42.000
마지막으로, 우리는 이번에는 통화를 위해 재단의 파서 중 하나를 사용하여 금액을 일치시킵니다.

00:08:42.000 --> 00:08:51.000
우리는 쉼표가 수천 구분 기호이고 마침표는 십진수 구분 기호라고 가정해 왔으며, 이 가정을 명시적으로 합니다.

00:08:51.000 --> 00:08:55.000
우리는 거래 원장에서 줄을 구문 분석할 수 있는 정규식을 만들었습니다.

00:08:55.000 --> 00:09:01.000
우리는 단지 선을 인식하고 싶지 않다. 우리는 이 데이터 중 일부를 추출하고 싶다.

00:09:01.000 --> 00:09:08.000
이를 위해, 우리는 나중에 처리를 위해 입력의 일부를 추출하는 캡처를 사용합니다.

00:09:08.000 --> 00:09:17.000
관례에 따라, '0번째' 캡처는 전체 정규 표현식과 일치하는 입력의 일부이며, 각 명시적 캡처가 뒤따른다.

00:09:17.000 --> 00:09:23.000
우리의 거래 종류는 우리의 입력의 한 조각인 부분 문자열로 캡처됩니다.

00:09:23.000 --> 00:09:31.000
날짜의 경우, 우리는 실제로 텍스트를 후처리할 필요 없이 구문 분석된 강력한 입력 값을 캡처합니다.

00:09:31.000 --> 00:09:41.000
개인이나 기관은 우리의 입력의 일부로 다시 캡처되며, 십진수 캡처는 또 다른 강력한 형식의 값이다.

00:09:41.000 --> 00:09:47.000
그것을 사용하기 위해, 우리는 일치 결과에서 날짜와 십진수 값을 추출하고, 조사관들은 여기에서 그것을 가져간다.

00:09:47.000 --> 00:09:56.000
이 시점에서 우리는 그들이 구조화된 쿼리와 같은 명백한 이점을 위해 데이터를 실제 데이터베이스에 덤프할 것을 권장합니다.

00:09:56.000 --> 00:09:58.000
그들은... 다른 의견을 가지고 있다.

00:09:58.000 --> 00:10:01.000
그들은 모든 것을 끈으로 유지하고 싶어 한다.

00:10:01.000 --> 00:10:07.000
우리가 Swift Regex를 더 많이 볼 수 있기 때문에 이 이야기에 좋은 소식이다.

00:10:07.000 --> 00:10:11.000
갑자기 그렇지 않을 때까지 모든 것이 잘 되고 있다.

00:10:11.000 --> 00:10:20.000
우리는 방금 우리가 모두에게 완전히 모호하다고 말한 거래 텍스트의 날짜 순서가 사실 모호하다는 것을 알게 되었다.

00:10:20.000 --> 00:10:28.000
그것은 항상 같은 것은 아니며, 주요 이론은 그것이 거래에 사용되는 통화에 달려 있다는 것이다.

00:10:28.000 --> 00:10:30.000
왜냐하면 당연히 그렇거든.

00:10:30.000 --> 00:10:40.000
이것은 미국 달러는 월/일/년이고 영국 파운드는 일/월/년이라는 것을 의미한다.

00:10:40.000 --> 00:10:44.000
그러니 이것을 명확하게 하기 위해 sed와 같은 대본을 쓰자.

00:10:44.000 --> 00:10:48.000
우리의 정규 표현식의 경우, 우리는 확장 구분 기호를 사용할 것이다.

00:10:48.000 --> 00:10:53.000
이것은 우리가 탈출할 필요 없이 안에 슬래시를 가질 수 있게 해준다.

00:10:53.000 --> 00:11:05.000
이것은 또한 공백이 무시되는 확장된 구문 모드에 대한 액세스를 제공하며, 이는 일반 코드와 마찬가지로 가독성을 위해 공백을 사용할 수 있음을 의미합니다.

00:11:05.000 --> 00:11:11.000
우리는 Regex의 출력에 튜플 라벨로 표시되는 명명된 캡처를 사용했습니다.

00:11:11.000 --> 00:11:15.000
그리고 우리는 통화 기호를 인식하기 위해 유니코드 속성을 사용합니다.

00:11:15.000 --> 00:11:23.000
이것은 우리의 정규식을 더 적응력 있게 만든다; 우리는 애플리케이션 논리에서 특정 기호를 다룰 것이다.

00:11:23.000 --> 00:11:30.000
텍스트를 수동으로 자르고 접합하는 대신, 우리는 재단의 날짜 파서를 다시 사용할 것입니다.

00:11:30.000 --> 00:11:35.000
pickStrategy는 통화 기호를 받고 이를 기반으로 구문 분석 전략을 결정할 것이다.

00:11:35.000 --> 00:11:46.000
우리의 모든 가정은 코드에서 명백하며, 이는 적응하고 진화하는 것을 더 쉽게 만들며, 우리가 거의 확실하게 필요로 할 것이다.

00:11:46.000 --> 00:11:58.000
대체 문자열을 구성하기 위해 캡처를 포함한 일치 결과를 사용하는 클로저를 제공하여 찾기 및 교체 알고리즘과 함께 정규 표현식과 도우미 함수를 사용합시다.

00:11:58.000 --> 00:12:02.000
우리는 캡처된 통화를 기반으로 전략을 선택하고 캡처된 날짜를 구문 분석합니다.

00:12:02.000 --> 00:12:07.000
우리는 위치만 아닌 이름으로 캡처에 접근할 수 있습니다.

00:12:07.000 --> 00:12:14.000
우리의 출력을 위해, 우리는 명확한 산업 표준인 ISO-8601을 사용하여 새로운 날짜를 포맷할 것이다.

00:12:14.000 --> 00:12:20.000
우리의 도구는 이 원장을 모호하지 않은 것으로 바꾼다.

00:12:20.000 --> 00:12:27.000
우리는 실제 날짜 파서와 포맷터를 사용하고 있기 때문에, 변화하는 요구 사항에 훨씬 더 잘 적응할 수 있습니다.

00:12:27.000 --> 00:12:33.000
그리고 통화 기호를 인식하기 위해 유니코드 속성을 사용하면 훨씬 더 빨리 진화하는 데 도움이 됩니다.

00:12:33.000 --> 00:12:38.000
정규 표현식은 문자열의 일부 모델에 대한 알고리즘을 선언한다.

00:12:38.000 --> 00:12:43.000
스위프트의 문자열은 유니코드 작업을 위한 여러 모델을 제공한다.

00:12:43.000 --> 00:12:50.000
오랜 세월의 사랑 이야기를 나타내는 이 문자열에는 3명의 캐릭터가 포함되어 있다.

00:12:50.000 --> 00:12:56.000
이 문자들은 공식적으로 유니코드 확장 문자 클러스터라고 불리는 복잡한 실체이다.

00:12:56.000 --> 00:13:02.000
단일 문자는 하나 이상의 유니코드 스칼라 값으로 구성되어 있다.

00:13:02.000 --> 00:13:09.000
문자열은 내용의 하위 수준 표현에 액세스할 수 있는 UnicodeScalarView를 제공합니다.

00:13:09.000 --> 00:13:15.000
이것은 고급 사용과 다른 시스템과의 호환성을 가능하게 한다.

00:13:15.000 --> 00:13:27.000
우리 이야기의 주인공인 우리의 첫 번째 캐릭터는 4개의 유니코드 스칼라로 구성되어 있습니다: 좀비, 제로 너비 조이너, 여성 사인, 그리고 어...

00:13:27.000 --> 00:13:35.000
이 맥락에서 이모티콘으로 렌더링되는 선호도를 나타내는 VARIATION SELECTOR-16.

00:13:35.000 --> 00:13:37.000
당연하지!

00:13:37.000 --> 00:13:41.000
이 스칼라들은 우리가 시각적으로 보는 단일 이모티콘을 만들어낸다.

00:13:41.000 --> 00:13:47.000
문자열이 메모리에 저장되면, UTF-8 바이트로 인코딩됩니다.

00:13:47.000 --> 00:13:50.000
우리는 UTF-8 뷰를 사용하여 이 바이트를 볼 수 있다.

00:13:50.000 --> 00:14:03.000
UTF-8은 가변 너비 인코딩으로, 단일 스칼라에 여러 바이트가 필요할 수 있으며, 우리가 보았듯이 단일 문자에 여러 스칼라가 필요할 수 있습니다.

00:14:03.000 --> 00:14:11.000
4개의 유니코드 스칼라로 대표되는 우리 이야기의 주인공은 13 UTF-8 바이트를 사용하여 인코딩됩니다.

00:14:11.000 --> 00:14:20.000
여러 스칼라로 구성된 것 외에도, 같은 정확한 문자는 때때로 다른 스칼라 세트로 표현될 수 있다.

00:14:20.000 --> 00:14:24.000
이것은 영어 이외의 언어를 다룰 때 많이 나온다.

00:14:24.000 --> 00:14:38.000
이 예에서, 급성 억양이 있는 'e'는 급성 억양이 있는 단일 스칼라, 미리 구성된 'e' 또는 급성 억양을 결합한 ASCII 'e'로 표현될 수 있다.

00:14:38.000 --> 00:14:43.000
이것들은 같은 문자이므로, 문자열 비교는 true를 반환할 것이다.

00:14:43.000 --> 00:14:49.000
이것은 문자열이 공식적으로 유니코드 표준 등가라고 불리는 것에 복종하기 때문이다.

00:14:49.000 --> 00:14:59.000
UnicodeScalarView 또는 UTF-8 뷰의 관점에서 볼 때, 내용은 다르며, 이러한 하위 레벨 뷰 내에서 비교할 때 이러한 차이를 볼 수 있습니다.

00:14:59.000 --> 00:15:05.000
문자열과 마찬가지로, 스위프트 정규 표현은 기본적으로 강박적으로 유니코드가 정확하다.

00:15:05.000 --> 00:15:09.000
하지만 그것은 표현력을 손상시키지 않고 이것을 한다.

00:15:09.000 --> 00:15:11.000
한 쌍의 문자열을 바꾸자.

00:15:11.000 --> 00:15:21.000
첫 번째 문자열의 경우, 점(.)으로 표시된 문자로 둘러싸인 명명된 유니코드 스칼라 스파클링 하트를 일치시킬 것입니다.

00:15:21.000 --> 00:15:29.000
모든 문자 클래스는 모든 스위프트 문자와 일치할 것이다; 즉, 모든 유니코드 확장 문자 클러스터.

00:15:29.000 --> 00:15:34.000
두 번째 문자열의 경우, 같은 문자는 같은 것으로 비교된다...

00:15:34.000 --> 00:15:37.000
그리고 우리는 사건을 무시할 수 있어.

00:15:37.000 --> 00:15:41.000
그리고 이제 우리의 단순한 사랑 이야기는 훨씬 더 복잡해졌다.

00:15:41.000 --> 00:15:49.000
때때로 삶, 또는 이 경우 비생명은 우리가 처리해야 할 복잡성을 가지고 있다.

00:15:49.000 --> 00:16:02.000
문자열과 마찬가지로, 호환성이나 하위 그래프 클러스터 정밀도를 위해 유니코드 스칼라 값을 직접 처리해야 하는 경우, 'unicodeScalar' 의미와 일치시킬 수 있습니다.

00:16:02.000 --> 00:16:09.000
유니코드 스칼라 수준에서 일치할 때, 그 점들은 전체 스위프트 문자 대신 단일 유니코드 스칼라 값과 일치한다.

00:16:09.000 --> 00:16:14.000
그것은 우리가 친구를 다시 볼 수 있다는 것을 의미한다: VARIATION-SELECTOR 16.

00:16:14.000 --> 00:16:23.000
이 친근한 작은 선택기는 점과 일치하며, 혼자일 때 빈 공백으로 렌더링되기 때문에 볼 수 없습니다.

00:16:23.000 --> 00:16:26.000
정말 도움이 됐어.

00:16:26.000 --> 00:16:34.000
이제 우리는 정확성과 정확성으로 일했으니, 조금 다른 것을 하고, 금융으로 돌아가자.

00:16:34.000 --> 00:16:40.000
수사관들이 돌아왔고, 이번에는 흥미로운 요청이 있다.

00:16:40.000 --> 00:16:48.000
그들은 사실 이후에 원장을 처리하는 대신 와이어에서 라이브 거래를 냄새 맡도록 거래 매칭 도구를 수정했습니다.

00:16:48.000 --> 00:16:56.000
그들의 코드를 보면, 그들은 실제로 꽤 잘 해냈지만, 스케일링 문제에 직면해 있고 우리의 도움이 필요하다.

00:16:56.000 --> 00:17:01.000
그들이 처리하고 있는 거래는 매우 비슷하지만, 약간의 차이가 있다.

00:17:01.000 --> 00:17:05.000
날짜 대신에, 그들은 정확한 타임스탬프를 가지고 있다.

00:17:05.000 --> 00:17:12.000
이것은 명확하고, 명확하며, 충격적으로 독점적인 형식으로 표현된다.

00:17:12.000 --> 00:17:19.000
그들은 이것과 잘 일치하는 이전 세기에 쓰여진 정규 표현식을 가지고 있다.

00:17:19.000 --> 00:17:22.000
괜찮아.

00:17:22.000 --> 00:17:26.000
다음으로 그들은 개인과 식별 코드를 포함하는 세부 사항 필드를 가지고 있다.

00:17:26.000 --> 00:17:33.000
그들은 입력에서 파생된 런타임 컴파일 정규식을 사용하여 이 필드에 대한 거래를 필터링합니다.

00:17:33.000 --> 00:17:41.000
이것은 라이브이고, 나중에 더 많은 분야가 있기 때문에, 그들은 흥미롭지 않은 거래를 일찍 구제하는 것을 좋아한다.

00:17:41.000 --> 00:17:47.000
그런 다음 양과 체크섬과 같은 다른 필드가 나오는데, 그들은 스스로 잘 처리한다.

00:17:47.000 --> 00:17:55.000
그리고 물론, 필드는 여전히 2개 이상의 공백이나 탭으로 구분된다.

00:17:55.000 --> 00:17:58.000
그들의 거래 매처는 우리와 많이 닮았다.

00:17:58.000 --> 00:18:06.000
그들은 타임스탬프에 대한 그들만의 정규 표현식을 가지고 있으며, 그들의 세부 정규 표현은 입력에서 컴파일되며, 나머지 필드를 처리합니다.

00:18:06.000 --> 00:18:10.000
그들은 꽤 잘 했어. 모든 것이 기술적으로 작동한다.

00:18:10.000 --> 00:18:12.000
그건 그냥 잘 확장되지 않아.

00:18:12.000 --> 00:18:19.000
그들은 그들의 타임스탬프와 세부 사항 정규 표현이 종종 필드보다 훨씬 더 많은 입력과 일치한다는 것을 알아차렸다.

00:18:19.000 --> 00:18:25.000
이상적으로, 이러한 정규 표현은 단일 필드에서만 실행되도록 제한될 것이다.

00:18:25.000 --> 00:18:33.000
우리는 부정적인 앞을 사용하여 프로젝트에서 비슷한 문제를 처리했으니, 그 정규 표현식을 끌어내자.

00:18:33.000 --> 00:18:43.000
'필드'는 필드 구분 기호를 만날 때까지 모든 문자와 효율적으로 일치하며, 우리는 그것을 사용하여 정규 표현식을 포함하고 싶습니다.

00:18:43.000 --> 00:18:52.000
우리는 이것을 후처리 단계로 할 수 있지만, 이것이 라이브로 실행되고 있기 때문에, 이 정규 표현식들이 필드와 일치하지 않으면 일찍 보석금을 내고 싶습니다.

00:18:52.000 --> 00:18:55.000
우리는 TryCapture를 사용하여 이것을 할 수 있다.

00:18:55.000 --> 00:19:05.000
TryCapture는 일치하는 필드를 클로저로 전달하며, 여기서 우리는 조사관의 타임스탬프와 세부 정규 표현식에 대해 테스트합니다.

00:19:05.000 --> 00:19:12.000
그들이 일치하면, 우리는 필드의 값을 반환합니다. 즉, 매칭이 성공하고 필드가 캡처됩니다.

00:19:12.000 --> 00:19:18.000
그렇지 않으면 우리는 일치가 실패했다는 신호인 nil을 반환합니다.

00:19:18.000 --> 00:19:24.000
TryCapture의 폐쇄는 매칭에 적극적으로 참여하며, 이것이 정확히 우리가 필요로 하는 것이다.

00:19:24.000 --> 00:19:27.000
그리고 이것으로, 우리는 주요 스케일링 문제를 해결했다.

00:19:27.000 --> 00:19:37.000
하지만 여전히 한 가지 문제가 더 있습니다: 나중에 거래 매처에서 무언가가 실패하면, 종료하는 데 오랜 시간이 걸릴 수 있습니다.

00:19:37.000 --> 00:19:46.000
우리가 처음에 정의한 필드 분리 정규 표현은 우리가 원하는 2개 이상의 공백이나 탭과 일치합니다.

00:19:46.000 --> 00:19:53.000
8개의 공백 문자가 있다면, 나머지 정규 표현식을 시도하기 전에 모두 일치할 것이다.

00:19:53.000 --> 00:20:00.000
하지만 정규 표현식 표현식에 실패하면, 다시 시도하기 전에 백업되고 7개의 공백 문자만 일치합니다.

00:20:00.000 --> 00:20:10.000
그리고 그것이 실패하면, 그것은 6개의 공백 문자와만 일치할 것이다.

00:20:10.000 --> 00:20:15.000
모든 대안을 시도한 후에야 매칭이 실패한다.

00:20:15.000 --> 00:20:24.000
대안을 시도하기 위한 이 백업은 글로벌 백트래킹 또는 공식적인 논리에서 Kleene 폐쇄라고 불린다.

00:20:24.000 --> 00:20:29.000
그것은 정규 표현에 특징적인 힘을 주는 것이다.

00:20:29.000 --> 00:20:36.000
하지만 그것은 탐험할 수 있는 광범위한 검색 공간을 열어주며, 여기서 우리는 더 선형적인 검색 공간을 원한다.

00:20:36.000 --> 00:20:40.000
우리는 모든 공백을 일치시키고 절대 포기하지 않기를 원한다.

00:20:40.000 --> 00:20:51.000
우리가 사용할 수 있는 몇 가지 도구가 있습니다. 더 일반적인 도구는 fieldSeparator를 글로벌 범위 대신 로컬 역추적 범위에 넣는 것입니다.

00:20:51.000 --> 00:21:02.000
로컬 빌더는 포함된 정규 표현식과 성공적으로 일치하면 시도되지 않은 대안이 폐기되는 범위를 만듭니다.

00:21:02.000 --> 00:21:10.000
우리의 거래 매처가 나중에 실패하더라도, 우리는 더 적은 공간을 소비하기 위해 돌아가지 않는다.

00:21:10.000 --> 00:21:17.000
정규 표현식의 기본값인 글로벌 역추적은 검색과 퍼지 매칭에 적합합니다.

00:21:17.000 --> 00:21:22.000
로컬은 정확하게 지정된 토큰을 일치시키는 데 유용하다.

00:21:22.000 --> 00:21:29.000
필드 분리기는, 성가 될 수 있지만, 정확하다.

00:21:29.000 --> 00:21:36.000
로컬은 다른 곳에서는 원자 비포획 그룹으로 알려져 있으며, 이는... 무서운 이름이 될 수 있다.

00:21:36.000 --> 00:21:40.000
네 정규 표현이 폭발할 것 같아.

00:21:40.000 --> 00:21:46.000
하지만 그것은 실제로 그 반대를 한다-- 그것은 검색 공간을 포함한다.

00:21:46.000 --> 00:21:50.000
그리고 이것으로, 우리는 그들이 스케일링 문제를 해결할 수 있도록 도왔습니다.

00:21:50.000 --> 00:21:56.000
오늘 우리는 Swift Regex를 만나야 했지만, 우리가 다룰 수 없었던 것이 훨씬 더 많다.

00:21:56.000 --> 00:22:02.000
제 동료 Richard의 Swift Regex: Beyond the Basics를 꼭 확인하세요.

00:22:02.000 --> 00:22:05.000
우리가 떠나기 전에, 나는 몇 가지 점을 강조하고 싶다.

00:22:05.000 --> 00:22:11.000
Regex 건축업자는 구조를 제공한다. 정규 문자는 간결하다.

00:22:11.000 --> 00:22:17.000
둘 중 하나를 사용할 때 사이의 선택은 궁극적으로 주관적일 것이다.

00:22:17.000 --> 00:22:21.000
가능할 때마다 실제 파서를 사용하세요.

00:22:21.000 --> 00:22:27.000
이렇게 하면 엄청난 시간을 절약하고 두통을 피할 수 있습니다.

00:22:27.000 --> 00:22:33.000
스위프트의 기본값을 사용하면 다른 어느 곳보다 훨씬 더 많은 유니코드 지원과 장점을 얻을 수 있습니다.

00:22:33.000 --> 00:22:40.000
통화 기호와 일치할 때와 같이 문자 속성과 같은 것을 효과적으로 사용하는 방법을 찾으세요.

00:22:40.000 --> 00:22:49.000
그리고 마지막으로, 미리 보기 및 로컬 백트래킹 범위와 같은 컨트롤을 사용하여 검색 및 처리 알고리즘을 단순화하십시오.

00:22:49.000 --> 23:59:59.000
봐줘서 고마워.

