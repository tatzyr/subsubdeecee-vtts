WEBVTT

00:00:00.000 --> 00:00:09.000
♪ 기악 힙합 음악 ♪

00:00:09.000 --> 00:00:14.000
안녕하세요, 제 이름은 보리스입니다. "스위프트 패키지 플러그인 만들기" 세션에 오신 것을 환영합니다.

00:00:14.000 --> 00:00:22.000
우리는 라이브러리를 소스 코드로 배포하는 간단한 접근 방식을 제공하기 위해 Xcode 11에서 Swift 패키지에 대한 지원을 도입했습니다.

00:00:22.000 --> 00:00:34.000
Xcode 14에서, 우리는 스위프트 패키지 플러그인을 사용하여 소스 코드 생성 또는 릴리스 작업 자동화와 같은 개발 워크플로우에 구성 요소를 구조화하고 공유하는 동일한 훌륭한 방법을 가져오고 싶습니다.

00:00:34.000 --> 00:00:36.000
먼저, 이야기에 대한 간략한 개요.

00:00:36.000 --> 00:00:42.000
플러그인의 기초를 배운 후, 우리는 데모에서 첫 번째 사용자 지정 명령 플러그인을 구축할 것입니다.

00:00:42.000 --> 00:00:51.000
다음으로, 우리는 플러그인 생성에 대한 자세한 내용을 살펴보고, 추가 데모에서 빌드 내 플러그인과 사전 빌드 명령 플러그인을 모두 구축할 것입니다.

00:00:51.000 --> 00:00:58.000
패키지 플러그인은 패키지 매니페스트와 유사한 PackagePlugin API를 사용하는 스위프트 코드입니다.

00:00:58.000 --> 00:01:06.000
플러그인은 잘 정의된 확장 지점을 통해 Xcode 또는 Swift Package Manager의 기능을 확장할 수 있습니다.

00:01:06.000 --> 00:01:09.000
패키지 플러그인은 어떻게 작동하나요?

00:01:09.000 --> 00:01:24.000
Xcode는 사용 가능한 실행 파일과 입력 파일에 대한 정보를 사용하여 필요에 따라 실행하기 위해 Xcode와 다시 통신하는 명령을 구성할 수 있는 플러그인을 컴파일하고 실행합니다.

00:01:24.000 --> 00:01:33.000
패키지 플러그인은 소스 코드 또는 리소스 파일을 생성하기 위해 빌드 전이나 도중에 실행되는 사용자 지정 빌드 작업에 기여할 수 있습니다.

00:01:33.000 --> 00:01:39.000
또한 SwiftPM의 명령줄 인터페이스 또는 메뉴 항목에 사용자 지정 명령을 Xcode에 추가할 수 있습니다.

00:01:39.000 --> 00:01:53.000
플러그인의 기본 사항에 대한 자세한 내용은 "Meet swift package plugins"를 먼저 보는 것이 좋습니다. 패키지를 완전히 처음 접하는 경우 WWDC19 세션 Creating Swift Packages를 볼 수 있습니다.

00:01:53.000 --> 00:01:58.000
첫 번째 사용자 지정 명령 플러그인을 만드는 것을 살펴봅시다.

00:01:58.000 --> 00:02:06.000
저는 스위프트 오픈 소스의 도구 지원 코어 패키지를 작업하고 있으며, 프로젝트의 모든 기여자를 나열하는 텍스트 파일을 추가하고 싶습니다.

00:02:06.000 --> 00:02:12.000
나는 또한 패키지의 Git 역사에서 필요에 따라 그것을 재생성하고 싶다.

00:02:12.000 --> 00:02:22.000
이전에는 이를 위해 셸 스크립트나 makefile을 작성했을 수도 있지만, Xcode를 떠나지 않고도 파일을 다시 생성할 수 있도록 사용자 지정 명령 플러그인을 만들고 싶습니다.

00:02:22.000 --> 00:02:26.000
먼저, 우리는 플러그인의 디렉토리 구조를 만들어야 합니다.

00:02:26.000 --> 00:02:43.000
패키지의 컨텍스트 메뉴를 열고 새 폴더를 선택하여 기존 소스 및 테스트와 유사한 플러그인이라는 최상위 폴더를 만듭니다.

00:02:43.000 --> 00:02:57.000
다음으로, 우리는 "GenerateContributors"라는 플러그인 대상을 위한 또 다른 중첩된 폴더를 만들 것입니다.

00:02:57.000 --> 00:03:12.000
그리고 그 안에서, 우리는 새 파일을 만들고 그것을 "plugin.swift"라고 부른다.

00:03:12.000 --> 00:03:18.000
다음으로, 우리는 새로운 목표를 선언하기 위해 패키지 매니페스트를 변경해야 합니다.

00:03:18.000 --> 00:03:33.000
하지만 먼저, 플러그인은 해당 버전 이후에만 사용할 수 있기 때문에 패키지의 도구 버전을 5.6으로 늘려야 합니다.

00:03:33.000 --> 00:03:44.000
다음으로, 우리는 플러그인 대상을 삽입할 수 있습니다.

00:03:44.000 --> 00:03:49.000
여기서 새로운 매니페스트 API를 살펴봅시다.

00:03:49.000 --> 00:03:56.000
우리는 소스 모듈 대상과 유사하게 플러그인 폴더 내부의 폴더에 해당하는 플러그인 대상을 만들고 있습니다.

00:03:56.000 --> 00:04:03.000
그것은 Xcode의 메뉴 항목뿐만 아니라 폴더의 이름과 관련된 이름을 얻습니다.

00:04:03.000 --> 00:04:07.000
우리는 기능을 지정하므로, 어떤 유형의 확장 지점을 사용하고 싶은지 지정합니다.

00:04:07.000 --> 00:04:12.000
이 경우, 우리는 사용자 지정 명령을 만들고 있다.

00:04:12.000 --> 00:04:24.000
의도는 SwiftPM 명령줄의 동사와 플러그인이 하는 일에 대한 설명을 정의할 수 있으며, 마지막으로 플러그인에 필요한 권한을 선언할 수 있습니다.

00:04:24.000 --> 00:04:30.000
이 경우, 우리는 패키지의 루트에 새 파일을 쓰고 싶기 때문에, 그 디렉토리에 쓸 수 있는 권한이 필요합니다.

00:04:30.000 --> 00:04:39.000
이유 문자열은 플러그인 사용자에게 표시되므로 OS 자체에서 권한이 작동하는 방식과 유사하게 권한을 부여할지 여부를 알 수 있습니다.

00:04:39.000 --> 00:04:45.000
이제 플러그인을 선언했으니, 실제로 구현하기 위해 다시 돌아가자.

00:04:45.000 --> 00:04:49.000
플러그인은 커밋 기록을 얻기 위해 Git으로 셸 아웃될 것이다.

00:04:49.000 --> 00:04:59.000
외부 Git 명령의 standardout에서 기록을 읽고 결과를 구문 분석하여 마침내 텍스트 파일에 기록할 것입니다.

00:04:59.000 --> 00:05:09.000
우리는 이전에 만든 플러그인 소스 파일을 열고 PackagePlugin을 가져올 것입니다.

00:05:09.000 --> 00:05:17.000
이것은 PackageDescription과 매우 비슷한 내장 모듈로, 플러그인을 구현하는 데 사용할 수 있는 API에 액세스할 수 있습니다.

00:05:17.000 --> 00:05:32.000
우리는 구조체 GenerateContributors를 정의하고 CommandPlugin에 따릅니다.

00:05:32.000 --> 00:05:39.000
우리는 프로토콜을 구현하기 위한 누락된 스텁을 얻기 위해 여기서 수정을 받아들일 것이다.

00:05:39.000 --> 00:05:46.000
우리는 또한 플러그인 실행 파일의 주요 기능이 될 것이기 때문에 구조를 @main으로 표시해야 합니다.

00:05:46.000 --> 00:06:00.000
performCommand는 명령의 진입점이며, 우리는 두 개의 인수를 받습니다: 컨텍스트, 이는 해결된 패키지 그래프와 우리가 실행 중인 컨텍스트에 대한 기타 정보와 인수에 대한 액세스를 제공합니다.

00:06:00.000 --> 00:06:06.000
사용자 지정 명령은 사용자에 의해 호출되기 때문에, 그들은 인수의 형태로 입력을 제공할 수 있다.

00:06:06.000 --> 00:06:20.000
우리는 간단한 명령을 만들고 있으므로, 현재 사용자에게 어떤 옵션도 제공하지 않을 것입니다.

00:06:20.000 --> 00:06:35.000
커밋 기록에 대한 정보를 얻기 위해 Git에 셸을 하고 싶기 때문에, 프로세스 API를 사용하고 싶기 때문에 Foundation을 가져오고 있습니다.

00:06:35.000 --> 00:06:45.000
다음으로, 우리는 프로세스 인스턴스를 정의하고 몇 가지 서식 인수로 Git 로그를 실행하도록 설정할 것입니다.

00:06:45.000 --> 00:06:48.000
우리는 공정 출력을 포착하기 위해 파이프를 만들어야 한다.

00:06:48.000 --> 00:06:55.000
그러면 우리는 그것을 실행하고 그것이 나올 때까지 기다릴 수 있다.

00:06:55.000 --> 00:07:05.000
프로세스가 끝난 후, 우리는 파이프의 모든 데이터를 읽고 모든 git 로그 출력을 가진 문자열로 변환합니다.

00:07:05.000 --> 00:07:22.000
우리는 중복 없이 출력을 목록으로 다듬기 위해 문자열 조작을 하고, 마지막으로 "CONTRIBUTORS.txt"라는 파일에 쓸 수 있으며, 사용자 지정 명령이 패키지의 루트 디렉토리에서 실행되기 때문에 거기에 파일을 저장할 것입니다.

00:07:22.000 --> 00:07:32.000
이제 프로젝트 네비게이터에서 패키지를 저장하고 마우스 오른쪽 버튼으로 클릭하면 컨텍스트 메뉴에 명령에 대한 새 항목이 있습니다.

00:07:32.000 --> 00:07:37.000
실행하자!

00:07:37.000 --> 00:07:51.000
다음 대화 상자에서, 우리는 플러그인의 입력이 되어야 하는 패키지나 대상과 인수를 선택할 수 있지만, 플러그인은 이러한 옵션에 반응하지 않기 때문에 실행을 클릭할 수 있습니다.

00:07:51.000 --> 00:07:55.000
다음으로 우리는 앞서 매니페스트에서 정의한 대로 허가를 요청받을 것이다.

00:07:55.000 --> 00:08:08.000
우리가 방금 플러그인을 직접 작성했기 때문에, 우리는 계속해서 실행할 수 있지만, 신뢰할 수 있는 플러그인에만 추가 권한을 부여해야 합니다.

00:08:08.000 --> 00:08:14.000
실행 후, CONTRIBUTORS.txt 파일이 프로젝트 네비게이터에 나타납니다.

00:08:14.000 --> 00:08:26.000
이제 첫 번째 플러그인으로 Xcode를 확장한 후, 플러그인이 어떻게 작동하는지, 그리고 플러그인을 만들 때 무엇을 찾아야 하는지 좀 더 자세히 알아보겠습니다.

00:08:26.000 --> 00:08:31.000
패키지 플러그인은 패키지 자체 평가와 유사하게 샌드박스에서 실행됩니다.

00:08:31.000 --> 00:08:38.000
플러그인의 자체 작업 디렉토리 이외의 비임시 위치에 대한 네트워크 액세스 및 쓰기는 금지되어 있습니다.

00:08:38.000 --> 00:08:45.000
사용자 지정 명령은 앞서 표시된 것처럼 패키지의 루트 디렉토리에 쓰고 싶다고 선택적으로 선언할 수 있습니다.

00:08:45.000 --> 00:08:55.000
기존 타사 도구를 래핑하는 경우, 예를 들어 생성된 파일이 기록되는 위치를 구성하여 샌드박스 모델에 국한하는 방법을 살펴봐야 할 수도 있습니다.

00:08:55.000 --> 00:09:07.000
나는 소개에서 다양한 유형의 플러그인에 대해 이야기했고, 문제가 사용자 지정 명령이나 빌드 도구로 더 잘 해결되는지 분명해야 하지만, 빌드 도구 플러그인의 구조를 살펴봅시다.

00:09:07.000 --> 00:09:19.000
이 플러그인을 사용하면 빌드 중에 실행할 실행 파일에 대한 설명을 제공하고 빌드 중에 적절한 시간에 작업을 예약하는 데 도움이 되는 입력과 출력을 지정하여 빌드 시스템을 확장할 수 있습니다.

00:09:19.000 --> 00:09:26.000
Xcode 프로젝트에서 실행 스크립트 단계를 만들고 있다면 여기에서 기본 사항에 익숙할 수 있습니다.

00:09:26.000 --> 00:09:29.000
또한 두 가지 유형의 빌드 도구 플러그인이 있습니다.

00:09:29.000 --> 00:09:34.000
여기서 구별되는 요소는 당신의 도구에 정의된 출력 세트가 있는지 여부입니다.

00:09:34.000 --> 00:09:43.000
만약 그렇다면, 출력이 입력에 비해 오래된 경우 빌드 시스템에서 자동으로 다시 실행되는 빌드 내 명령을 만들어야 합니다.

00:09:43.000 --> 00:09:49.000
명확한 출력 세트가 없다면, 모든 빌드의 시작 부분에서 실행되는 사전 빌드 명령을 만들 수 있습니다.

00:09:49.000 --> 00:10:02.000
이 때문에, 사전 빌드 명령에서 값비싼 작업을 하거나 사용 사례에 적합한 결과를 캐싱하기 위한 사용자 지정 전략을 생각해 내야 합니다.

00:10:02.000 --> 00:10:11.000
두 번째 데모를 위해, 저는 제가 작업하고 있는 다른 도구들 사이에서 공유하고 싶은 아이콘을 캡슐화하는 새로운 라이브러리를 만들고 싶습니다.

00:10:11.000 --> 00:10:15.000
시작해서 템플릿에서 새 패키지를 만들고 "IconLibrary"라고 부르자.

00:10:15.000 --> 00:10:20.000
그리고 나는 이미 가지고 있는 몇 가지 아이콘 자산을 내 도서관의 타겟으로 드래그할 것이다.

00:10:20.000 --> 00:10:24.000
또한 기본 SwiftUI 보기와 미리보기를 내 라이브러리에 추가해 봅시다.

00:10:24.000 --> 00:10:33.000
먼저, 우리는 매니페스트에 필요한 최소 배치 목표를 추가해야 합니다.

00:10:33.000 --> 00:10:37.000
다음으로, 실제로 기본 보기와 미리보기를 추가해 봅시다.

00:10:37.000 --> 00:10:44.000
여기서 우리는 이전에 끌어들인 자산을 사용할 수 있다.

00:10:44.000 --> 00:10:52.000
여기서 문자열을 다루는 대신, 이 이미지들을 참조할 수 있는 형식에 안전한 방법이 있다면 좋을 것 같아요.

00:10:52.000 --> 00:10:59.000
이것은 자산 카탈로그를 보고 이를 기반으로 일부 Swift 코드를 생성하는 빌드 내 명령 플러그인의 훌륭한 사용 사례처럼 보인다.

00:10:59.000 --> 00:11:06.000
파인더의 자산 카탈로그를 살펴보고 플러그인에 필요한 정보를 추출하는 방법을 알아봅시다.

00:11:06.000 --> 00:11:15.000
각 이미지는 자산의 이름과 함께 자체 이미지셋 디렉토리를 얻습니다...

00:11:15.000 --> 00:11:21.000
그리고 기본 내용을 설명하는 JSON 파일이 있습니다.

00:11:21.000 --> 00:11:30.000
빌드 내 명령은 입력 및 출력뿐만 아니라 실행할 실행 파일에 대한 설명을 제공한다는 점에서 사용자 지정 명령과 약간 다르게 작동합니다.

00:11:30.000 --> 00:11:36.000
실행 파일은 시스템, 타사 패키지에서 제공하거나 플러그인을 위해 맞춤 제작한 것을 만들 수 있습니다.

00:11:36.000 --> 00:11:40.000
우리는 여기서 세 번째 접근 방식을 취하고 싶다.

00:11:40.000 --> 00:11:46.000
플러그인은 빌드 그래프 계산에 참여하기 위해 빌드 프로세스가 시작될 때 실행됩니다.

00:11:46.000 --> 00:11:52.000
이를 바탕으로, 실행 파일은 빌드 실행의 일부로 예약됩니다.

00:11:52.000 --> 00:11:54.000
이제 우리가 만들고 있는 실행 파일로 돌아가세요.

00:11:54.000 --> 00:12:07.000
우리는 자산 카탈로그의 각 이미지에 대한 컴파일 시간 상수를 갖고 싶습니다. 그래서 각 이미지에 대한 올바른 문자열을 기억해야 하는 대신 스위프트 기호로 자동 완성되도록 합니다.

00:12:07.000 --> 00:12:12.000
우리는 모든 이미지 세트를 찾기 위해 자산 카탈로그의 디렉토리 내용을 반복하고 싶습니다.

00:12:12.000 --> 00:12:21.000
각 이미지 세트에 대해, 우리는 메타데이터를 구문 분석하여 실제로 이미지가 포함되어 있는지 결정하므로 코드를 생성해야 합니다.

00:12:21.000 --> 00:12:24.000
그런 다음 우리는 코드를 생성하고 파일에 쓸 수 있습니다.

00:12:24.000 --> 00:12:33.000
우리가 그 파일들을 플러그인의 출력으로 선언했기 때문에, 그것들은 플러그인이 적용되는 대상의 빌드에 자동으로 통합될 것이다.

00:12:33.000 --> 00:12:40.000
그것이 우리가 플러그인과 실행 파일 간에 통신하는 방법이기 때문에 논쟁을 처리할 방법이 필요할 것이다.

00:12:40.000 --> 00:12:51.000
첫 번째 인수는 우리가 처리 중인 자산 카탈로그의 경로가 될 것이며, 두 번째 인수는 생성된 코드에 대한 플러그인이 제공하는 경로가 될 것입니다.

00:12:51.000 --> 00:12:57.000
다음으로 content.json 파일을 디코딩하기 위한 모델 객체가 필요합니다.

00:12:57.000 --> 00:13:02.000
우리는 스위프트의 내장 JSON 디코딩을 활용하기 위해 Decodable을 사용합니다.

00:13:02.000 --> 00:13:13.000
우리가 관심 있는 유일한 정보는 이미지 목록과 파일 이름이며, 각 픽셀 밀도에 대한 이미지가 없을 수 있기 때문에 선택 사항입니다.

00:13:13.000 --> 00:13:17.000
우리는 문자열을 만들어 단순한 방식으로 코드를 생성할 것이다.

00:13:17.000 --> 00:13:23.000
우리는 우리가 필요로 하는 프레임워크, Foundation과 SwiftUI의 수입으로 시작합니다.

00:13:23.000 --> 00:13:32.000
우리는 자산 카탈로그의 디렉토리 내용을 반복하여 다음에 JSON을 구문 분석해야 하는 모든 이미지 세트를 찾고 싶습니다.

00:13:32.000 --> 00:13:35.000
파일 이름은 입력 매개 변수를 사용합니다.

00:13:35.000 --> 00:13:41.000
그리고 우리는 재단의 'JSONDecoder' API를 사용하여 디코딩합니다.

00:13:41.000 --> 00:13:54.000
우리가 관심 있는 주요 정보는 주어진 이미지 세트에 정의된 이미지가 있는지 여부이며, 비어 있지 않은 파일 이름을 가진 이미지가 하나 이상 있는지 확인하여 결정합니다.

00:13:54.000 --> 00:14:02.000
주어진 이미지 세트에 이미지가 있다면, 패키지 번들에서 해당 이미지를 로드하는 SwiftUI 이미지를 생성하고 싶습니다.

00:14:02.000 --> 00:14:13.000
우리는 빌드 시스템이 리소스가 있는 각 패키지에 대해 만드는 리소스 번들인 모듈 번들에서 주어진 이미지를 로드하는 각 이미지의 기본 이름으로 문자열을 구축하여 그렇게 합니다.

00:14:13.000 --> 00:14:21.000
우리는 인수에 의해 우리에게 주어진 대로 생성된 코드를 파일에 작성하여 실행 파일의 작업을 마무리할 수 있습니다.

00:14:21.000 --> 00:14:30.000
Xcode로 돌아가서 실행 파일을 만들어 봅시다.

00:14:30.000 --> 00:14:40.000
우리는 그것을 "AssetConstantsExec"이라고 부릅니다...

00:14:40.000 --> 00:14:51.000
그리고 메인 파일을 추가하세요.

00:14:51.000 --> 00:15:00.000
이제 우리는 그것을 패키지 매니페스트에 선언해야 한다.

00:15:00.000 --> 00:15:09.000
그리고 우리는 방금 논의한 코드를 메인 파일에 추가할 수 있습니다.

00:15:09.000 --> 00:15:41.000
이제 코드를 생성할 수 있는 실행 파일이 있으므로, 플러그인을 사용하여 빌드 시스템으로 가져올 수 있습니다.

00:15:41.000 --> 00:16:09.000
필요한 대상을 추가하고 라이브러리 대상에서 플러그인 사용을 추가합시다.

00:16:09.000 --> 00:16:37.000
이전과 마찬가지로, 우리는 PackagePlugin 라이브러리를 가져오고 구조자를 만들고 있으며, 이번에는 BuildTool 플러그인 프로토콜을 준수합니다.

00:16:37.000 --> 00:16:42.000
진입점은 비슷해 보이지만, 사용자 인수 대신, 우리는 여기에 목표를 제시하고 있다.

00:16:42.000 --> 00:16:55.000
이것은 플러그인이 적용되는 대상이며, 진입점은 주어진 플러그인을 사용하는 대상당 한 번 호출됩니다.

00:16:55.000 --> 00:17:05.000
이 플러그인은 예를 들어 바이너리 대상과 달리 실제로 소스 파일을 운반하는 대상인 소스 모듈 대상에 특히 신경을 쓸 것이다.

00:17:05.000 --> 00:17:11.000
빌드 명령 배열을 구축하기 위해, 우리는 대상의 모든 xcasset 번들을 반복합니다.

00:17:11.000 --> 00:17:19.000
우리는 빌드 로그에 표시될 표시 이름의 문자열을 추출하고 적절한 입력 및 출력 경로를 구성할 것입니다.

00:17:19.000 --> 00:17:27.000
우리는 또한 플러그인 API를 사용하여 실행 파일을 찾은 다음 빌드 명령을 함께 넣을 수 있습니다.

00:17:27.000 --> 00:17:29.000
이것으로, 우리는 프로젝트를 다시 구축할 준비가 되었다.

00:17:29.000 --> 00:17:40.000
우리는 일어나고 있는 새로운 빌드 단계에 대한 빌드 로그를 살펴볼 수 있습니다.

00:17:40.000 --> 00:17:52.000
플러그인은 빌드 시작 시 컴파일되고 실행되며, 여기서 생성된 명령을 빌드 그래프에 추가합니다.

00:17:52.000 --> 00:17:59.000
목표를 보면, 우리의 새로운 빌드 명령이 실행되었다.

00:17:59.000 --> 00:18:05.000
그리고 마지막으로, 생성된 소스 파일은 스위프트 파일 컴파일의 일부로 표시됩니다.

00:18:05.000 --> 00:18:20.000
문자열로 입력된 이미지 구성을 새로운 상수로 대체할 수 있는 미리보기로 돌아가 봅시다.

00:18:20.000 --> 00:18:28.000
우리는 또한 다른 이미지 이름에 대한 자동 완성을 얻는다.

00:18:28.000 --> 00:18:39.000
이거 좋네. 상대적으로 적은 코드로, 우리는 친숙한 Swift API를 사용하고 Xcode를 떠나지 않고도 워크플로우를 개선할 수 있었습니다.

00:18:39.000 --> 00:18:53.000
지금까지, 우리는 이미 작업하고 있던 라이브러리의 일부로 우리 자신의 사용을 위한 플러그인을 만드는 것을 조사했지만, 플러그인의 또 다른 강력한 속성은 라이브러리와 유사한 간단한 방식으로 공유할 수 있다는 것입니다.

00:18:53.000 --> 00:18:59.000
다음 데모를 위해, Xcode와 함께 제공되는 genstrings 도구를 사용하여 사전 빌드 처리를 자동화하고 싶습니다.

00:18:59.000 --> 00:19:05.000
이 도구는 추가 사용을 위해 코드에서 현지화된 문자열을 현지화 디렉토리로 추출합니다.

00:19:05.000 --> 00:19:12.000
일반적으로 유용해 보이기 때문에, 독립적으로 공유할 수 있도록 플러그인을 별도의 패키지로 만들고 싶습니다.

00:19:12.000 --> 00:19:20.000
패키지의 자원과 현지화에 대해 더 알고 싶다면, 그 주제에 대한 WWDC20 세션을 추천합니다.

00:19:20.000 --> 00:19:28.000
일반적으로 현지화에 대한 자세한 내용은 WWDC21에서 SwiftUI 앱을 현지화하세요.

00:19:28.000 --> 00:19:34.000
이 플러그인의 경우, 우리는 현지화를 위한 출력 디렉토리를 계산하는 것으로 시작할 것입니다.

00:19:34.000 --> 00:19:46.000
주어진 대상의 모든 Swift 또는 Objective-C 소스 파일인 입력 파일을 계산한 다음 Xcode에서 제공하는 genstrings 도구를 실행하기 위한 사전 빌드 명령을 구성할 것입니다.

00:19:46.000 --> 00:19:56.000
사전 및 빌드 내 명령의 가장 큰 차이점은 잘 정의된 출력 세트를 선언하지 않는다는 것입니다. 즉, 이러한 명령은 모든 빌드에서 실행됩니다.

00:19:56.000 --> 00:20:11.000
이 도구는 사용자의 소스 코드에서 모든 현지화된 문자열을 추출한 다음 모든 문자열을 현지화 디렉토리에 작성하여 사용자 프로젝트의 실제 현지화 작업의 기초로 사용할 수 있습니다.

00:20:11.000 --> 00:20:13.000
우선, 나는 이미 여기에 비계를 만들었다.

00:20:13.000 --> 00:20:29.000
이제 패키지 매니페스트에서 이전과 같이 대상을 추가하자, 하지만 플러그인 제품도 추가할 것이다.

00:20:29.000 --> 00:20:38.000
라이브러리 제품과 마찬가지로, 이것은 개인적으로가 아닌 패키지의 클라이언트가 플러그인을 사용할 수 있도록 하는 방법입니다.

00:20:38.000 --> 00:20:50.000
우리는 이전에 논의한 코드를 작성할 수 있습니다...

00:20:50.000 --> 00:21:00.000
이제 플러그인을 구축했으므로, 별도의 예제 패키지로 테스트하고 싶습니다.

00:21:00.000 --> 00:21:04.000
그것을 위해, 템플릿에서 새로운 패키지를 만들어 봅시다.

00:21:04.000 --> 00:21:14.000
우리는 패키지에 현지화된 문자열을 제공하는 API를 추가할 것입니다...

00:21:14.000 --> 00:21:35.000
그리고 생성된 테스트에 그것의 사용을 추가하세요.

00:21:35.000 --> 00:21:40.000
예상대로, 우리의 API가 문자열 "World"를 반환하기 때문에 테스트가 작동합니다.

00:21:40.000 --> 00:21:51.000
플러그인 패키지에 경로 기반 종속성을 추가합시다...

00:21:51.000 --> 00:22:03.000
그리고 라이브러리 대상에 대한 플러그인 사용.

00:22:03.000 --> 00:22:10.000
우리는 이제 다시 달릴 수 있어...

00:22:10.000 --> 00:22:38.000
그리고 빌드 로그를 보면, 플러그인은 빌드 시작 시 실행되고 생성된 파일이 대상에 추가되므로, 마치 리소스가 처음부터 대상의 일부인 것처럼 리소스 번들이 생성되고 리소스 접근자가 생성됩니다.

00:22:38.000 --> 00:22:53.000
이제 리소스 번들을 실제로 사용하도록 코드를 변경해 봅시다.

00:22:53.000 --> 00:23:10.000
마지막으로, 우리가 코드를 바꾸면...

00:23:10.000 --> 00:23:26.000
그리고 생성된 번들을 엿보세요...

00:23:26.000 --> 00:23:30.000
우리는 여기에 반영된 변화를 볼 수 있다.

00:23:30.000 --> 00:23:37.000
이제 플러그인을 위한 테스트 베드가 있으니, 테스트 스위트를 구체화하고 결국 플러그인 패키지를 다른 사람들과 공유할 수 있습니다.

00:23:37.000 --> 00:23:51.000
요약하자면, 플러그인을 사용하여 개발자 도구를 자동화하고 공유할 수 있으며, 사용자 지정 명령은 일반적인 작업을 자동화하는 방법을 제공하며, 빌드 프로세스를 통해 파일을 생성하는 데 빌드 도구를 사용할 수 있습니다.

00:23:51.000 --> 00:23:53.000
들어줘서 고마워!

00:23:53.000 --> 23:59:59.000
♪ 기악 힙합 음악 ♪

