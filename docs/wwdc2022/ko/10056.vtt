WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:13.000
폴: 안녕하세요, SwiftUI로 사용자 지정 레이아웃을 작성하는 것을 환영합니다.

00:00:13.000 --> 00:00:16.000
저는 폴이고, 개발자 문서 작업을 하고 있습니다.

00:00:16.000 --> 00:00:22.000
SwiftUI는 앱의 인터페이스를 구성하는 데 사용하는 풍부한 빌딩 블록 세트를 제공합니다.

00:00:22.000 --> 00:00:31.000
텍스트, 이미지 및 그래픽과 같은 요소를 표시하는 내장 뷰를 결합하여 사용자 지정 복합 뷰를 만들 수 있습니다.

00:00:31.000 --> 00:00:39.000
이러한 모든 요소를 더욱 정교한 그룹으로 정렬하기 위해 SwiftUI는 레이아웃 도구를 제공합니다.

00:00:39.000 --> 00:00:51.000
수평 및 수직 스택과 같은 컨테이너를 사용하면 SwiftUI에 서로 상대적인 뷰를 어디에 둘지 알려줄 수 있으며, 뷰 수정자는 간격과 정렬과 같은 것을 추가로 제어할 수 있습니다.

00:00:51.000 --> 00:00:59.000
이 강연에서, 저는 일반적인 레이아웃을 더 쉽게 만들고, 더 복잡한 레이아웃을 가능하게 할 수 있는 몇 가지 새로운 도구를 소개할 것입니다.

00:00:59.000 --> 00:01:04.000
그 과정에서, SwiftUI에서 레이아웃으로 작업하기 위한 몇 가지 팁을 드리겠습니다.

00:01:04.000 --> 00:01:12.000
표시할 정적 뷰 세트가 있을 때 2차원 레이아웃에 완벽한 그리드 제품군의 새로운 구성원을 보여주는 것으로 시작하겠습니다.

00:01:12.000 --> 00:01:21.000
다음으로 새로운 레이아웃 프로토콜을 사용하여 레이아웃 엔진과 직접 상호 작용할 수 있는 사용자 지정 보기 컨테이너 유형을 만드는 방법에 대해 이야기하겠습니다.

00:01:21.000 --> 00:01:31.000
그런 다음 사용 가능한 공간에 맞는 뷰 모음에서 자동으로 선택하는 컨테이너 유형인 ViewThatFits에 대해 이야기하겠습니다.

00:01:31.000 --> 00:01:38.000
그리고 마지막으로, AnyLayout을 사용하여 레이아웃 유형 간에 원활한 전환을 추가하는 방법을 보여드리겠습니다.

00:01:38.000 --> 00:01:44.000
이 모든 새로운 기능을 실제로 보려면, 제가 작업하고 있는 앱을 살펴봅시다.

00:01:44.000 --> 00:01:50.000
최근 몇 년 동안, 내 동료들 사이에서 누가 최고의 털복숭이 동반자를 만드는지에 대한 논쟁이 있었다.

00:01:50.000 --> 00:01:58.000
나는 내 자신의 의견을 가지고 있지만, 우리가 합의에 도달 할 수 있는지 궁금해서, 여론 조사를 위한 앱을 만들기로 결정했다.

00:01:58.000 --> 00:02:03.000
그리고 나는 모피 알레르기가 있는 사람들도 포함시키고 싶어, 그래서 나는 하나의 추가 옵션을 던지고 있어.

00:02:03.000 --> 00:02:14.000
이제, 나는 미리보기를 사용하여 프로토타입을 만들기가 매우 쉽기 때문에 SwiftUI에서 대부분의 인터페이스 디자인을 하는 것을 좋아하지만, 출발점으로, 나는 내가 목표로 하는 것에 대한 빠른 스케치를 그렸다.

00:02:14.000 --> 00:02:20.000
나는 투표가 일정 기간 동안 계속될 것으로 예상하기 때문에, 나는 현재 순위를 보여주는 중간에 있는 리더보드를 원한다.

00:02:20.000 --> 00:02:22.000
나는 하단에 투표 버튼을 놓을 것이다.

00:02:22.000 --> 00:02:28.000
그리고 맨 위에, 나는 사람들이 투표하는 것에 대한 몇 가지 이미지를 보여줄 것이다.

00:02:28.000 --> 00:02:30.000
좋아, 내가 가장 먼저 하고 싶은 일은 리더보드를 만드는 거야.

00:02:30.000 --> 00:02:33.000
그러니 그것을 좀 더 자세히 살펴봅시다.

00:02:33.000 --> 00:02:43.000
리더보드는 각 경쟁자에 대한 행과 이름, 백분율 및 투표 수를 보여주는 열이 있는 요소의 2차원 그리드입니다.

00:02:43.000 --> 00:02:47.000
나는 여기서 성취하고 싶은 몇 가지 구체적인 것들이 있다.

00:02:47.000 --> 00:02:58.000
먼저, 나는 두 개의 텍스트 열이 각각의 경우에 가장 넓은 셀을 수용하기 위해 필요한 만큼만 넓기를 원한다. 왜냐하면 나는 백분율을 나타내는 진행 뷰가 가능한 한 많은 공간을 얻기를 원하기 때문이다.

00:02:58.000 --> 00:03:09.000
그리고 이것은 다른 언어를 사용하는 내 친구들이나 장치에서 다른 텍스트 크기를 사용하는 사람에게 얼마나 큰지 상관없이 사실이어야 한다.

00:03:09.000 --> 00:03:14.000
둘째, 나는 이름이 앞쪽 가장자리가 정렬되기를 원하지만, 양은 뒤쪽 가장자리가 정렬되기를 원한다.

00:03:14.000 --> 00:03:20.000
이제, SwiftUI에는 이미 스크롤 가능한 콘텐츠에 적합한 게으른 그리드가 있습니다.

00:03:20.000 --> 00:03:27.000
이 컨테이너는 볼 수 있거나 곧 볼 수 있는 보기만 로드하기 때문에 많은 뷰가 있을 때 매우 효율적입니다.

00:03:27.000 --> 00:03:34.000
반면에, 그것은 컨테이너가 두 차원 모두에서 셀의 크기를 자동으로 조정할 수 없다는 것을 의미한다.

00:03:34.000 --> 00:03:42.000
예를 들어, LazyHGrid는 열을 그리기 전에 열의 모든 뷰를 측정할 수 있기 때문에 각 열을 얼마나 넓게 만들 수 있는지 알아낼 수 있다.

00:03:42.000 --> 00:03:46.000
하지만 행의 높이를 알아내기 위해 연속으로 모든 뷰를 측정할 수는 없다.

00:03:46.000 --> 00:03:53.000
이 작업을 하기 위해, 게으른 그리드는 초기화 시간에 치수 중 하나에 대한 정보를 제공해야 합니다.

00:03:53.000 --> 00:04:02.000
게으른 그리드 및 기타 기존 SwiftUI 레이아웃 컨테이너 유형을 자세히 살펴보면 2020년부터 스택, 그리드 및 개요 토크를 참조하십시오.

00:04:02.000 --> 00:04:09.000
하지만 제 경우에는 스크롤이 필요하지 않으며, SwiftUI가 각 셀의 높이와 너비를 모두 알아내도록 하고 싶습니다.

00:04:09.000 --> 00:04:14.000
이러한 종류의 레이아웃을 위해, SwiftUI는 이제 그리드 보기를 제공한다.

00:04:14.000 --> 00:04:25.000
게으른 그리드와 달리, 그리드는 모든 뷰를 한 번에 로드하므로 열과 행 모두에서 셀의 크기를 자동으로 조정하고 정렬할 수 있습니다.

00:04:25.000 --> 00:04:28.000
이것에 대한 코드를 살펴봅시다.

00:04:28.000 --> 00:04:31.000
여기 그리드로 작성된 내 리더보드의 기본 버전이 있습니다.

00:04:31.000 --> 00:04:35.000
이 특정 그리드 뷰에는 세 개의 GridRow 인스턴스가 포함되어 있습니다.

00:04:35.000 --> 00:04:38.000
행 내에서, 각 보기는 열에 해당한다.

00:04:38.000 --> 00:04:49.000
그래서 이 예에서, 각 행의 첫 번째 텍스트 보기는 첫 번째 열에 해당하고, 진행 보기는 두 번째 열에 있으며, 마지막 텍스트 보기는 세 번째 열입니다.

00:04:49.000 --> 00:04:55.000
그리드는 가장 큰 보기를 유지하는 데 필요한 만큼 각 행과 열에 많은 공간을 할당한다는 점에 유의하십시오.

00:04:55.000 --> 00:05:00.000
그래서 첫 번째 텍스트 열은 가장 긴 이름을 위해 충분히 넓지만, 더 넓지는 않다.

00:05:00.000 --> 00:05:09.000
진행률 표시기와 같은 유연한 보기는 그리드가 제공하는 만큼의 공간을 차지하며, 이 경우 텍스트 열에 공간을 할당한 후 남은 것입니다.

00:05:09.000 --> 00:05:16.000
저는 이것을 조금 조정하고 싶지만, 먼저, 투표 수를 저장할 수 있는 장소를 제공하기 위해 기본 데이터 모델을 만들겠습니다.

00:05:16.000 --> 00:05:24.000
네트워크를 통해 데이터를 관리하고 공유하려면 더 많은 논리가 필요하지만, 인터페이스를 프로토타이핑하는 동안 이와 같은 간단한 구조가 필요합니다.

00:05:24.000 --> 00:05:35.000
나는 식별 가능한 적합성을 포함할 것이다. 왜냐하면 그것은 ForEach에서 이 유형을 더 쉽게 사용할 수 있고, 변화를 애니메이션화할 수 있도록 Equatable 적합성을 포함할 것이기 때문이다.

00:05:35.000 --> 00:05:41.000
그리고 나는 프로토타입을 만드는 동안 미리보기에서 사용할 예시 데이터 세트를 만들 것이다.

00:05:41.000 --> 00:05:46.000
그리드로 돌아가서, 상태 변수를 만들고 예제 데이터로 초기화할 수 있습니다.

00:05:46.000 --> 00:05:51.000
그리고 그 데이터를 사용하여, 나는 이제 ForEach로 행을 만들 수 있다.

00:05:51.000 --> 00:05:56.000
렌더링된 출력은 여전히 동일한 데이터를 표시하고 있기 때문에 변경되지 않았다는 점에 유의하십시오.

00:05:56.000 --> 00:06:00.000
그것은 이미 꽤 가깝지만, 나는 세포 정렬을 고쳐야 한다.

00:06:00.000 --> 00:06:10.000
지금 당장, 모든 셀은 중앙 정렬되어 있으며, 이는 그리드의 기본값이지만, 당신이 기억한다면, 나는 이름이 앞 가장자리를 정렬하고, 값이 후행 가장자리를 정렬하기를 원합니다.

00:06:10.000 --> 00:06:14.000
그렇게 하기 위해, 나는 앞 가장자리 정렬로 그리드를 초기화할 것이다.

00:06:14.000 --> 00:06:18.000
내가 여기서 사용하는 값은 그리드의 모든 셀에 적용된다.

00:06:18.000 --> 00:06:23.000
그건 내 처음 두 열에 잘 작동하지만, 마지막 칼럼은 어때?

00:06:23.000 --> 00:06:31.000
단일 열의 정렬에 영향을 미치기 위해, 그 열의 한 셀에 gridColumnAlignment 보기 수정자를 적용할 수 있습니다.

00:06:31.000 --> 00:06:34.000
그래서 나는 마지막 열의 텍스트 보기로 그것을 할 것이다.

00:06:34.000 --> 00:06:41.000
좋아, 거기로 가고 있어, 하지만 지금 보고 있으니, 각 줄 사이에 칸막이가 있는 게 더 나을 것 같아.

00:06:41.000 --> 00:06:50.000
디바이더로 ForEach에 새 행을 추가하면, 이것은 정확히 내가 원하는 것이 아니지만, 이것이 몇 가지 흥미로운 것을 보여준다는 것을 주목하세요.

00:06:50.000 --> 00:06:56.000
첫째, 디바이더는 유연한 보기이기 때문에, 첫 번째 열이 더 많은 공간을 차지하게 한다.

00:06:56.000 --> 00:07:03.000
기본적으로, 그리드는 이제 마지막 열에 필요한 것을 제공하고, 나머지 공간을 처음 두 열로 나누고 있다.

00:07:03.000 --> 00:07:11.000
둘째, 다른 그리드 행만큼 많은 뷰가 없는 그리드 행의 경우, 누락된 뷰는 이후 열에 빈 셀을 만듭니다.

00:07:11.000 --> 00:07:23.000
하지만 내가 정말로 원하는 것은 디바이더가 그리드의 모든 열에 걸쳐 있도록 하는 것이며, SwiftUI는 내가 그것을 할 수 있는 새로운 뷰 수정자를 가지고 있다.

00:07:23.000 --> 00:07:32.000
gridCellColumns 수정자를 뷰에 추가함으로써, 나는 단일 뷰가 몇 개의 열에 걸쳐 있다고 말할 수 있다; 이 경우, 세 개 모두.

00:07:32.000 --> 00:07:41.000
그리고 실제로, 뷰가 전체 그리드에 걸쳐야 하는 경우, 그리드 행 외부에서 뷰를 자체적으로 작성함으로써 이것을 단순화할 수 있습니다.

00:07:41.000 --> 00:07:48.000
좋아, 내 리더보드는 상태가 꽤 좋아서 다음에 투표에 사용된 버튼을 한 번 볼게.

00:07:48.000 --> 00:07:51.000
언뜻 보기에, 여기에 너무 화려한 것은 없다.

00:07:51.000 --> 00:07:54.000
하지만, 나는 한 가지 특별한 요구 사항이 있다.

00:07:54.000 --> 00:08:00.000
한편으로, 나는 특정 선택을 위해 더 작은 버튼으로 참가자들을 편향시키고 싶지 않다.

00:08:00.000 --> 00:08:06.000
하지만 나는 또한 버튼이 iPad나 Mac에서 매우 클 수 있는 컨테이너만큼 커지는 것을 원하지 않는다.

00:08:06.000 --> 00:08:11.000
대신, 버튼은 모두 가장 넓은 버튼 텍스트와 같은 너비를 가져야 한다.

00:08:11.000 --> 00:08:15.000
그래서 내가 Hstack으로 이것을 만들려고 하면 어떻게 되나요?

00:08:15.000 --> 00:08:23.000
내가 찾은 것은 각 버튼이 텍스트 라벨에 맞게 크기가 조정되고, HStack은 이것들을 수평으로 함께 포장한다는 것이다.

00:08:23.000 --> 00:08:31.000
이 기본 스택 동작은 많은 경우에 정확히 당신이 원하는 것이지만, 이 프로젝트에 대한 내 사양을 충족시키지 못한다.

00:08:31.000 --> 00:08:39.000
SwiftUI의 레이아웃 기본 사항에 대한 재교육은 2019년부터 SwiftUI 토크로 사용자 지정 보기 구축을 참조하십시오.

00:08:39.000 --> 00:08:47.000
그 이야기의 개념을 사용하여, 이 뷰 계층 구조를 살펴보고 내가 원하는 행동을 얻기 위해 무엇을 바꿀 수 있는지 봅시다.

00:08:47.000 --> 00:08:52.000
먼저, 스택의 컨테이너는 스택의 크기를 제안한다.

00:08:52.000 --> 00:09:00.000
이를 바탕으로, 스택은 세 개의 버튼에 크기를 제안한 다음, 각 버튼은 그 크기를 텍스트 라벨로 전달한다.

00:09:00.000 --> 00:09:08.000
텍스트 뷰는 포함된 문자열에 따라 실제로 원하는 크기를 계산하고 이를 버튼에 보고합니다.

00:09:08.000 --> 00:09:10.000
그 버튼은 정보를 다시 전달한다.

00:09:10.000 --> 00:09:18.000
스택은 이 정보로 크기를 조정하고, 버튼을 공간에 배치한 다음, 컨테이너에 자체 크기를 보고합니다.

00:09:18.000 --> 00:09:26.000
좋아요, 그래서 버튼이 텍스트의 크기를 취한다면, 각 텍스트 보기를 유연한 프레임으로 감싸서 성장할 수 있다면 어떨까요?

00:09:26.000 --> 00:09:33.000
텍스트는 변경되지 않았지만, 버튼은 HStack이 제공하는 만큼의 공간을 차지하는 유연한 하위 뷰를 본다.

00:09:33.000 --> 00:09:38.000
그런 다음 스택은 포함된 보기 사이에 공간을 균등하게 분배한다.

00:09:38.000 --> 00:09:44.000
그래서 버튼은 이제 모두 같은 크기이지만, 실제 크기는 스택의 컨테이너에 따라 다릅니다.

00:09:44.000 --> 00:09:49.000
스택은 컨테이너가 제공하는 공간을 채우기 위해 확장될 것이며, 그것은 내가 원하는 것이 아니다.

00:09:49.000 --> 00:09:59.000
내가 정말로 원하는 것은 각 버튼의 이상적인 크기를 요구하고, 가장 넓은 것을 찾은 다음, 각 버튼에 그 정도의 공간을 제공하는 사용자 지정 스택 유형이다.

00:09:59.000 --> 00:10:04.000
다행히도, SwiftUI에는 내가 그것을 할 수 있는 새로운 도구가 있다.

00:10:04.000 --> 00:10:14.000
레이아웃 프로토콜을 사용하여, 내 사용 사례에 맞는 동작으로 레이아웃 프로세스에 직접 참여하는 사용자 지정 레이아웃 컨테이너를 정의할 수 있습니다.

00:10:14.000 --> 00:10:16.000
이게 어떻게 작동하는지 보자.

00:10:16.000 --> 00:10:26.000
HStack을 다시 살펴보면, 특정 문제를 해결하기 위해 정의할 유형인 EqualWidthHStack으로 변경하겠습니다.

00:10:26.000 --> 00:10:33.000
이 유형은 가장 넓은 버튼의 이상적인 너비만큼 넓은 양으로 버튼에 너비를 동등하게 할당할 것이다.

00:10:33.000 --> 00:10:40.000
더 좁은 텍스트가 있는 버튼이 스택이 제공하는 공간을 채우기 위해 확장될 수 있도록 유연한 프레임을 유지할 것입니다.

00:10:40.000 --> 00:10:45.000
하지만 버튼은 여전히 내가 측정할 수 있는 이상적인 크기를 가질 것이며, 이는 텍스트의 너비이다.

00:10:45.000 --> 00:10:52.000
그래서 내가 MyEqualWidthHStack을 어떻게 구현할 수 있는지 보자.

00:10:52.000 --> 00:10:56.000
나는 레이아웃 프로토콜을 준수하는 유형을 만드는 것으로 시작한다.

00:10:56.000 --> 00:10:59.000
기본 레이아웃의 경우, 필요한 두 가지 방법만 있으면 됩니다.

00:10:59.000 --> 00:11:02.000
그것들을 위한 스텁을 추가하자.

00:11:02.000 --> 00:11:10.000
첫 번째 방법은 sizeThatFits로, 레이아웃 컨테이너가 얼마나 큰지 계산하고 보고할 것이다.

00:11:10.000 --> 00:11:16.000
나는 내 레이아웃의 자체 컨테이너 뷰에서 크기 제안인 제안된 뷰 크기 입력을 받는다.

00:11:16.000 --> 00:11:22.000
그리고 서브뷰 매개 변수를 사용하여 레이아웃의 서브뷰에 크기를 제안할 수 있습니다.

00:11:22.000 --> 00:11:25.000
서브뷰에 직접 접근할 수 없다는 것을 주목하세요.

00:11:25.000 --> 00:11:34.000
대신, 서브뷰 입력은 크기를 제안하는 것과 같이 서브뷰와 특정 방식으로 상호 작용할 수 있는 프록시 모음입니다.

00:11:34.000 --> 00:11:39.000
각 프록시는 내가 만든 제안에 따라 구체적인 크기를 반환한다.

00:11:39.000 --> 00:11:49.000
나는 그 모든 응답을 수집하고 그것들을 사용하여 몇 가지 계산을 한 다음 EqualWidthHStack의 구체적인 크기를 컨테이너로 반환할 것이다.

00:11:49.000 --> 00:11:52.000
내가 구현해야 하는 두 번째 방법은 placeSubviews이다.

00:11:52.000 --> 00:11:56.000
나는 이것을 사용하여 내 레이아웃의 하위 뷰가 어디에 나타날지 말할 것이다.

00:11:56.000 --> 00:12:07.000
이 방법은 동일한 크기의 제안과 서브뷰 입력을 취하며, 서브뷰를 배치해야 하는 영역을 나타내는 경계 입력도 취합니다.

00:12:07.000 --> 00:12:12.000
경계는 내가 sizeThatFits 구현에서 요청한 크기를 가진 직사각형이다.

00:12:12.000 --> 00:12:19.000
기억하세요, 보기는 SwiftUI에서 자신의 크기를 선택하므로, 내 레이아웃 컨테이너는 요구하는 크기를 얻을 것입니다.

00:12:19.000 --> 00:12:25.000
그 지역의 기원은 왼쪽 상단에 있으며, 오른쪽에는 양의 X가 있고, Y는 아래에 있다.

00:12:25.000 --> 00:12:37.000
오른쪽에서 왼쪽 언어 환경에서도 모든 배치 계산에 대해 이것을 가정할 수 있습니다. 왜냐하면 프레임워크는 해당 방향으로 뷰를 배치할 때 각 뷰의 x 위치를 자동으로 뒤집기 때문입니다.

00:12:37.000 --> 00:12:42.000
그러나, 직사각형의 원점이 (0,0) 값을 가지고 있다고 가정하지 마세요.

00:12:42.000 --> 00:12:52.000
무엇보다도, 0이 아닌 원본을 허용하는 것은 한 레이아웃의 placeSubviews 메서드가 다른 레이아웃의 동일한 메서드를 호출하는 레이아웃 구성을 가능하게 한다.

00:12:52.000 --> 00:13:05.000
작업을 조금 더 쉽게 하기 위해, 직사각형은 각 차원의 최소, 중심 및 최대 지점과 같은 지역의 중요한 부분에 접근할 수 있는 속성을 제공합니다.

00:13:05.000 --> 00:13:16.000
이제, 다음으로 넘어가기 전에, 이 두 가지 방법이 모두 가지고 있는 또 다른 매개 변수에 주목하세요: 메소드 호출에서 중간 계산 결과를 공유하는 데 사용할 수 있는 양방향 캐시.

00:13:16.000 --> 00:13:22.000
많은 간단한 레이아웃의 경우, 당신은 이것이 필요하지 않을 것이며, 지금은 캐시를 무시할 것입니다.

00:13:22.000 --> 00:13:29.000
그러나, Instruments로 앱을 프로파일링하여 레이아웃 코드의 효율성을 개선해야 한다는 것을 보여준다면, 추가를 살펴볼 수 있습니다.

00:13:29.000 --> 00:13:34.000
그것에 대한 더 많은 정보는 문서를 확인하세요.

00:13:34.000 --> 00:13:37.000
좋아, SizeThatFits를 구현하자.

00:13:37.000 --> 00:13:44.000
기억하세요, 저는 같은 너비로 수평으로 배열된 모든 버튼에 맞는 컨테이너의 크기를 반환하고 싶습니다.

00:13:44.000 --> 00:13:51.000
그래서 먼저, 나는 각 버튼에 크기를 물어볼 것이고, 크기를 제안하고 무엇이 돌아오는지 확인함으로써 그렇게 할 것이다.

00:13:51.000 --> 00:14:01.000
하위 뷰의 유연성을 측정하기 위해, 최소, 최대 및 이상적인 크기에 대한 특별 제안을 사용하여 여러 측정을 하거나 특정 크기를 제안할 수 있습니다.

00:14:01.000 --> 00:14:08.000
이 경우, 나는 이상적인 크기를 요청하기 위해 불특정 크기 제안을 사용한다.

00:14:08.000 --> 00:14:13.000
그러면 나는 내가 돌아오는 모든 크기에 대해 각 차원에서 가장 큰 가치를 찾을 것이다.

00:14:13.000 --> 00:14:18.000
이 경우, 금붕어 버튼은 너비를 설정하고, 높이는 모두 동일합니다.

00:14:18.000 --> 00:14:23.000
이제 그것을 방법으로 리팩토링하겠습니다. 왜냐하면 서브뷰를 배치할 때 다시 필요할 것이기 때문입니다.

00:14:23.000 --> 00:14:27.000
다음으로, 나는 뷰 사이의 간격을 고려해야 한다.

00:14:27.000 --> 00:14:33.000
나는 10점과 같은 일정한 간격을 사용할 수 있지만, 레이아웃 프로토콜은 내가 더 잘할 수 있게 해준다.

00:14:33.000 --> 00:14:42.000
SwiftUI에서, 모든 보기에는 보기가 자신과 다음 보기 사이에 선호하는 공간의 양을 나타내는 간격 환경 설정이 있습니다.

00:14:42.000 --> 00:14:48.000
이러한 환경 설정은 컨테이너 레이아웃에 사용할 수 있는 ViewSpacing 인스턴스에 저장됩니다.

00:14:48.000 --> 00:14:54.000
뷰는 다른 가장자리에서 다른 값을 선호할 수 있으며, 심지어 다른 종류의 인접한 뷰에 대해 다른 값을 선호할 수도 있다.

00:14:54.000 --> 00:15:02.000
예를 들어, 뷰는 자신과 이미지 사이에서 원하는 것보다 자신과 텍스트 뷰 사이에 더 많거나 적은 공간을 원할 수 있다.

00:15:02.000 --> 00:15:06.000
그리고 그 가치는 플랫폼에 따라 다를 수 있다.

00:15:06.000 --> 00:15:26.000
레이아웃에 의미가 있다면 이러한 기본 설정을 무시할 수 있습니다. 이는 본질적으로 사용자 지정 간격으로 내장 스택을 초기화할 때 일어나는 일이지만, 자신의 레이아웃에서 이러한 기본 설정을 존중하는 것은 Apple의 인터페이스 지침을 자동으로 따르는 결과를 얻을 수 있는 좋은 방법이며, 결과적으로 시스템의 나머지 부분과 일치합니다.

00:15:26.000 --> 00:15:35.000
이제, 모든 뷰는 모든 가장자리에 선호도를 가지고 있으며, 두 뷰를 함께 가져올 때, 공통 가장자리의 선호도가 일치하지 않을 수 있습니다.

00:15:35.000 --> 00:15:39.000
이 문제를 해결하기 위해, 내장된 레이아웃 컨테이너는 두 가지 기본 설정 중 더 큰 것을 사용합니다.

00:15:39.000 --> 00:15:43.000
그리고 나는 내 레이아웃에서 같은 일을 할 수 있다.

00:15:43.000 --> 00:15:50.000
서브뷰 프록시는 주어진 축을 따라 다른 버튼에 대한 각 버튼의 선호하는 간격을 요청할 수 있는 방법을 제공합니다.

00:15:50.000 --> 00:16:05.000
따라서 하위 뷰를 스캔하고 각 프록시의 간격 인스턴스에서 거리 메서드를 호출하여 수평 축을 따라 다음 뷰의 간격 인스턴스에 대한 간격을 얻는 값 배열을 만들겠습니다.

00:16:05.000 --> 00:16:11.000
이 전화는 공통의 가장자리에 대한 두 견해의 선호도를 고려한다.

00:16:11.000 --> 00:16:22.000
이 배열의 첫 번째 요소는 고양이 버튼이 금붕어 버튼에 수평으로 얼마나 많은 공간을 원하는지 알려주고, 다음 요소는 금붕어 버튼이 개 버튼에 얼마나 원하는지 알려줍니다.

00:16:22.000 --> 00:16:28.000
비교할 버튼이 더 이상 없기 때문에 배열의 마지막 요소를 0으로 강제할 것이다.

00:16:28.000 --> 00:16:32.000
좋아, 내가 그걸 나중을 위한 방법으로 리팩토링할게.

00:16:32.000 --> 00:16:41.000
이제 간격 값을 결합하여 총 간격을 찾고 너비 및 높이 측정과 함께 사용하여 크기 값을 반환할 수 있습니다.

00:16:41.000 --> 00:16:49.000
이것은 하위 뷰의 이상적인 크기와 각 하위 뷰의 선호하는 간격을 감안할 때 내 레이아웃이 필요로 하는 크기이다.

00:16:49.000 --> 00:16:52.000
내가 구현해야 할 또 다른 방법은 placeSubviews이다.

00:16:52.000 --> 00:17:01.000
전에 언급했듯이, 나는 컨테이너의 경계와 버튼을 지시하는 데 사용할 수 있는 서브뷰 프록시 컬렉션을 모두 얻는다.

00:17:01.000 --> 00:17:10.000
먼저, sizeThatFits 메소드에서 했던 것처럼 maxSize와 간격 배열을 계산합니다. 왜냐하면 여기에도 그 값이 필요하기 때문입니다.

00:17:10.000 --> 00:17:18.000
그런 다음 이번에는 이상적인 크기가 아닌 내가 원하는 크기를 기반으로 각 하위 뷰에 사용할 수 있는 크기 제안서를 만들 것입니다.

00:17:18.000 --> 00:17:23.000
나는 모든 버튼이 같은 크기로 되기를 원하기 때문에 하나의 제안만 필요하다.

00:17:23.000 --> 00:17:32.000
그리고 나는 내 경계의 앞쪽 가장자리와 버튼 너비의 절반으로 계산된 첫 번째 서브뷰의 수평 차원에서 시작 위치를 찾을 것이다.

00:17:32.000 --> 00:17:39.000
내가 원점이 0이 되는 것에 의존하지 않고, 대신 minX 값으로 시작한다는 것을 알아두세요.

00:17:39.000 --> 00:17:52.000
마지막으로, 나는 각 하위 뷰 프록시를 살펴보고 포인트, 버튼 측면에서 그 포인트가 무엇을 나타내는지에 대한 진술, 그리고 크기 제안으로 그 장소 메소드를 호출할 수 있다.

00:17:52.000 --> 00:18:01.000
루프를 통해 매번, 나는 다음 반복을 준비하기 위해 뷰의 너비와 다음 뷰 쌍의 간격으로 수평 위치를 업데이트합니다.

00:18:01.000 --> 00:18:02.000
그리고 그게 다야.

00:18:02.000 --> 00:18:07.000
이제 이 새로운 뷰 레이아웃 유형을 사용할 때 어떤 일이 일어나는지 봅시다.

00:18:07.000 --> 00:18:08.000
그리고 저기 있어.

00:18:08.000 --> 00:18:18.000
내장 HStack처럼 나만의 사용자 지정 레이아웃 컨테이너를 인스턴스화하며, 버튼은 모두 같은 너비로 수평으로 정렬됩니다.

00:18:18.000 --> 00:18:27.000
이제, 저는 여기서 잠시 멈추고 레이아웃 프로토콜이 과거에 지오메트리 리더를 사용하려고 시도했을 수도 있는 문제를 어떻게 해결하는지에 대해 이야기하고 싶습니다.

00:18:27.000 --> 00:18:31.000
결국, 기하학 리더는 보기 크기를 측정하는 도구이다.

00:18:31.000 --> 00:18:35.000
그러나, 이 경우에는 최선의 선택이 아니다.

00:18:35.000 --> 00:18:41.000
그리고 그것은 지오메트리 리더가 컨테이너 뷰를 측정하고 그 크기를 하위 뷰에 보고하도록 설계되었기 때문입니다.

00:18:41.000 --> 00:18:45.000
그런 다음 하위 뷰는 정보를 사용하여 자체 콘텐츠를 그립니다.

00:18:45.000 --> 00:18:50.000
기하학 리더의 의도된 사용을 위해, 정보가 아래쪽으로 흐른다는 것을 주목하세요.

00:18:50.000 --> 00:18:55.000
독자가 하는 측정은 자체 컨테이너의 레이아웃에 영향을 미치지 않는다.

00:18:55.000 --> 00:18:59.000
이것은 컨테이너로 확장되는 경로를 그리는 것과 같은 것들에 좋습니다.

00:18:59.000 --> 00:19:07.000
지오메트리 리더는 경로 논리에 얼마나 많은 공간을 작업해야 하는지 알려주고, 하위 뷰 내부의 경로 논리는 그에 따라 조정됩니다.

00:19:07.000 --> 00:19:14.000
컨테이너가 크기를 바꾸면, 지오메트리 리더가 새로운 크기를 따라 통과하기 때문에 경로도 변경됩니다.

00:19:14.000 --> 00:19:27.000
그러나, 내 버튼의 경우, 더 쉽게 볼 수 있도록 여기에 초점을 맞출 것입니다. 텍스트 보기를 측정한 다음, 그것을 사용하여 텍스트 보기의 컨테이너인 프레임을 설정하는 방법을 결정해야 합니다.

00:19:27.000 --> 00:19:38.000
그래서 나는 텍스트 뷰에 오버레이에 지오메트리 리더를 추가할 수 있습니다. 컨테이너를 측정한 다음 어떻게든 측정 데이터를 정상적인 흐름 외부의 프레임으로 다시 보낼 수 있습니다.

00:19:38.000 --> 00:19:43.000
하지만 내가 이것을 하면, 나는 레이아웃 엔진을 우회하고 있으며, 이는 루프를 초래할 수 있다.

00:19:43.000 --> 00:19:51.000
독자는 레이아웃을 측정하고 프레임을 변경하여 레이아웃을 변경할 수 있으며, 이는 다른 측정이 필요할 수 있습니다.

00:19:51.000 --> 00:19:57.000
이제 이 일을 할 수 있지만, 조심하지 않으면, 결국 내 앱을 망가뜨릴 수 있다.

00:19:57.000 --> 00:20:00.000
결과적으로, 이 전략은 권장되지 않는다.

00:20:00.000 --> 00:20:08.000
다행히도, 레이아웃 프로토콜은 레이아웃 엔진 내에서 작업할 수 있도록 하여 이 문제를 해결할 수 있는 더 나은 방법을 제공합니다.

00:20:08.000 --> 00:20:10.000
좋아, 버튼을 다시 보자.

00:20:10.000 --> 00:20:13.000
내가 여기서 하고 싶은 다른 일이 있어.

00:20:13.000 --> 00:20:18.000
먼저, 이것을 좀 더 쉽게 읽을 수 있도록, 나는 버튼을 그들만의 하위 보기로 리팩토링할 것이다.

00:20:18.000 --> 00:20:23.000
이제, 나는 내 동료 중 한 명이 그들의 장치에서 더 큰 유형을 사용한다는 것을 알게 되었다.

00:20:23.000 --> 00:20:30.000
내 앱은 기본 글꼴을 사용했기 때문에 동적 유형을 자동으로 지원하므로, 대부분 무료로 올바른 동작을 받아야 합니다.

00:20:30.000 --> 00:20:35.000
내가 타입 사이즈를 늘리면 어떻게 되는지 보자.

00:20:35.000 --> 00:20:37.000
어-오, 버튼이 더 이상 맞지 않아.

00:20:37.000 --> 00:20:47.000
내 사용자 지정 스택은 버튼 너비를 제한하지 않지만, 이 경우 디스플레이의 너비를 초과하는 이상적인 크기를 가질 수 있다는 것을 기억하십시오.

00:20:47.000 --> 00:20:48.000
그래서 내가 뭘 할 수 있을까?

00:20:48.000 --> 00:20:56.000
음, 레이아웃 컨테이너의 크기 제안을 고려하여 뷰가 맞지 않을 때 더 복잡한 일을 하도록 레이아웃을 수정할 수 있습니다.

00:20:56.000 --> 00:21:01.000
하지만 이 경우, 나는 새로운 ViewThatFits 컨테이너를 사용하여 대부분의 일을 할 수 있다.

00:21:01.000 --> 00:21:09.000
이 새로운 유형은 내가 제공하는 뷰 목록에서 사용 가능한 공간에 맞는 첫 번째 뷰를 선택합니다.

00:21:09.000 --> 00:21:20.000
사용자 지정 스택을 ViewThatFits 구조로 래핑한 다음 동일한 콘텐츠의 수직 스택 버전을 추가하면 SwiftUI가 언제 버튼을 다르게 배열해야 하는지 알아낼 수 있습니다.

00:21:20.000 --> 00:21:31.000
물론, 내장된 VStack은 내 사용자 지정 수평 스택과 동일한 너비 속성을 가지고 있지 않기 때문에, 나는 사용자 지정 스택의 수직 버전도 구현했다.

00:21:31.000 --> 00:21:41.000
그것은 수평 축 대신 수직 축을 따라 동일한 너비의 항목을 배치한다는 점을 제외하고는 내가 이미 설명한 것과 매우 유사하다.

00:21:41.000 --> 00:21:47.000
그리고 물론, 동적 유형 크기 재정의를 제거하면 수평 레이아웃으로 돌아갑니다.

00:21:47.000 --> 00:21:52.000
이제, 내가 만들어야 할 앱의 마지막 부분이 하나 있는데, 그것은 상단의 이미지이다.

00:21:52.000 --> 00:21:59.000
나는 프로필 사진 그룹을 보여주는 것과 같은 간단한 것을 할 수 있지만, 나는 그것으로 조금 재미있을 것이라고 생각했다.

00:21:59.000 --> 00:22:08.000
그래서 나는 원형 배열로 뷰를 그린 다음 순위에 따라 배열을 회전하는 또 다른 사용자 지정 레이아웃 유형을 만들었다.

00:22:08.000 --> 00:22:13.000
그래서 이 구성은 1위의 금붕어를 보여주고, 다른 두 개는 2위를 차지한다.

00:22:13.000 --> 00:22:17.000
그리고 만약 개가 고양이보다 앞서 당긴다면, 나는 그것을 보여주기 위해 조금 회전할 수 있다.

00:22:17.000 --> 00:22:23.000
또는 방사형 레이아웃을 회전하여 약간 더 현실적인 결과를 보여줄 수 있습니다.

00:22:23.000 --> 00:22:27.000
이 레이아웃을 만드는 것은 실제로 레이아웃 프로토콜로 꽤 간단하다.

00:22:27.000 --> 00:22:30.000
예전처럼, 나는 두 가지 방법이 필요해.

00:22:30.000 --> 00:22:37.000
맞는 크기를 위해, 나는 내 뷰가 사용 가능한 공간을 채우기를 원하기 때문에, 컨테이너 뷰가 제안하는 모든 크기를 반환할 것이다.

00:22:37.000 --> 00:22:44.000
나는 지정되지 않은 치수 교체 방법을 사용하여 제안서를 구체적인 크기로 변환할 것이다.

00:22:44.000 --> 00:22:50.000
그 방법은 컨테이너가 이상적인 크기를 요구하는 경우 존재할 수 있는 nil 값을 자동으로 처리합니다.

00:22:50.000 --> 00:23:03.000
그런 다음 장소 서브뷰 방법 내부에서, 나는 레이아웃 영역의 크기에 기반한 반경으로 중간에서 각 서브뷰를 오프셋하고, 뷰의 인덱스에 따라 회전을 적용할 것이다.

00:23:03.000 --> 00:23:12.000
기준선으로, 이것은 뷰를 원의 0, 1, 그리고 3분의 2에 둔다.

00:23:12.000 --> 00:23:18.000
현재 순위를 반영하기 위해, 나는 또한 모든 견해에 동등하게 영향을 미치는 오프셋을 적용할 것이다.

00:23:18.000 --> 00:23:20.000
하지만 순위는 어디서 얻을 수 있나요?

00:23:20.000 --> 00:23:27.000
기억하세요, 내 레이아웃은 내 데이터 모델은 고사하고 뷰가 아닌 서브뷰 프록시에만 접근할 수 있습니다.

00:23:27.000 --> 00:23:31.000
음, 레이아웃 프로토콜에는 또 다른 트릭이 있다는 것이 밝혀졌습니다.

00:23:31.000 --> 00:23:37.000
각 하위 뷰에 값을 저장하고 레이아웃 프로토콜 방법 내부에서 값을 읽을 수 있습니다.

00:23:37.000 --> 00:23:41.000
순위 정보를 전달하기 위해 그것을 어떻게 사용할 수 있는지 봅시다.

00:23:41.000 --> 00:23:48.000
먼저, LayoutValueKey 프로토콜을 준수하는 새로운 유형을 선언하고 기본값을 부여합니다.

00:23:48.000 --> 00:23:59.000
명시적으로 설정하지 않을 때 뷰에 대한 값을 제공하는 것 외에도, 기본값은 이 경우 정수인 관련 값의 유형을 설정합니다.

00:23:59.000 --> 00:24:07.000
그런 다음, layoutValue 뷰 수정자를 사용하여 값을 설정하기 위해 View에서 편리한 방법을 만듭니다.

00:24:07.000 --> 00:24:13.000
이제 내 뷰 계층에서, 나는 내 레이아웃의 뷰에 편의 순위 수정자를 적용할 수 있다.

00:24:13.000 --> 00:24:20.000
여기서, 나는 각 애완 동물의 순위를 계산하고 내 방사형 레이아웃 안에 있는 애완 동물의 해당 아바타 보기에 추가한다.

00:24:20.000 --> 00:24:31.000
마지막으로, 내 장소 서브뷰 메소드로 돌아가서, 레이아웃 값 키를 인덱스로 사용하여 각 서브뷰의 값을 읽을 수 있는 코드를 추가할 수 있습니다.

00:24:31.000 --> 00:24:34.000
그리고 나는 오프셋을 계산하기 위해 순위를 사용할 수 있다.

00:24:34.000 --> 00:24:40.000
나는 여기서 그 논리를 거치지 않을 것이지만, 그것은 기본적으로 가능한 순위 세트에 적합한 각도를 만들어낸다.

00:24:40.000 --> 00:24:43.000
음, 하나만 빼고 다.

00:24:43.000 --> 00:24:45.000
3자 동점이 있으면 어떻게 되나요?

00:24:45.000 --> 00:24:53.000
한 줄의 모든 뷰를 얻기 위해 레이아웃을 회전할 방법이 없으므로, 그 경우 완전히 다른 레이아웃 논리를 대체해야 합니다.

00:24:53.000 --> 00:24:58.000
그러나, 이미 이것을 하는 레이아웃 유형이 있으며, 그것은 내장된 HStack이다.

00:24:58.000 --> 00:25:03.000
그래서 내가 정말 원하는 것은 3방향 타이를 감지할 때 HStack으로 전환하는 것이다.

00:25:03.000 --> 00:25:07.000
그리고 그것을 위한 새로운 도구도 있다는 것이 밝혀졌다.

00:25:07.000 --> 00:25:17.000
AnyLayout 유형을 사용하면 단일 뷰 계층에 다른 레이아웃을 적용할 수 있으므로 한 레이아웃 유형에서 다른 레이아웃 유형으로 전환할 때 뷰의 ID를 유지할 수 있습니다.

00:25:17.000 --> 00:25:27.000
그래서 여기 우리가 전에 본 방사형 레이아웃이 있는데, 내가 해야 할 일은 3방향 타이가 있는지 여부에 따라 새로운 레이아웃 유형으로 교체하는 것뿐입니다.

00:25:27.000 --> 00:25:36.000
isThreeWayTie 속성은 상태에서 파생되기 때문에, SwiftUI는 변경될 때 알아차리고 이 뷰를 다시 그려야 한다는 것을 인식합니다.

00:25:36.000 --> 00:25:46.000
하지만 뷰 계층의 구조적 정체성은 항상 동일하게 유지되기 때문에, SwiftUI는 이것을 새로운 관점이 아닌 변화하는 관점으로 본다.

00:25:46.000 --> 00:25:52.000
결과적으로, 한 줄만 더 있으면 레이아웃 유형 간에 원활한 전환을 만들 수 있습니다.

00:25:52.000 --> 00:26:03.000
그리고 사실, 애니메이션 뷰 수정자를 추가함으로써, 나는 또한 방사형 레이아웃의 모든 다른 상태 사이의 애니메이션을 얻는다. 왜냐하면 방사형 레이아웃의 구성은 동일한 데이터에 의존하기 때문이다.

00:26:03.000 --> 00:26:06.000
그리고 여기 그 모든 것이 실제로 보이는 것이 있습니다.

00:26:06.000 --> 00:26:17.000
투표 수를 변경하기 위해 다른 버튼을 탭하면, 아바타가 현재 순위를 반영하기 위해 어떻게 부드럽게 움직이는지 볼 수 있습니다.

00:26:17.000 --> 00:26:23.000
그래서 그것들은 SwiftUI가 앱의 뷰 레이아웃을 구성하기 위한 새로운 도구 중 일부입니다.

00:26:23.000 --> 00:26:28.000
그리드 유형을 사용하여 고도로 사용자 정의 가능한 정적 정보의 2차원 레이아웃을 만들 수 있습니다.

00:26:28.000 --> 00:26:36.000
레이아웃 프로토콜을 사용하여 자신의 범용, 재사용 가능한 레이아웃 또는 특정 사용 사례를 대상으로 하는 레이아웃을 정의할 수 있습니다.

00:26:36.000 --> 00:26:43.000
SwiftUI가 사용 가능한 공간에 가장 잘 맞도록 뷰 그룹에서 선택하게 하고 싶을 때 ViewThatFits를 사용할 수 있습니다.

00:26:43.000 --> 00:26:48.000
그리고 AnyLayout을 사용하여 레이아웃 유형 간에 원활하게 전환할 수 있습니다.

00:26:48.000 --> 23:59:59.000
오늘 나와 함께 해줘서 고마워, 그리고 나는 네가 나만큼 이 새로운 레이아웃 도구를 가지고 노는 것을 즐기길 바라.

