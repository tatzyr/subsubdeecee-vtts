WEBVTT

00:00:00.000 --> 00:00:03.000
♪ 부드러운 기악 힙합 음악 ♪

00:00:03.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:15.000
안녕하세요, 저는 인증 경험 팀의 엔지니어인 Garrett입니다.

00:00:15.000 --> 00:00:23.000
그리고 이 비디오에서, 저는 차세대 인증 기술인 패스키에 대해 이야기하게 되어 기쁩니다.

00:00:23.000 --> 00:00:28.000
하지만 먼저, 저는 오늘날의 인증 기술에 대해 이야기해야 합니다: 비밀번호.

00:00:28.000 --> 00:00:33.000
당신은 아마 그들과 함께 거의 모든 앱과 웹사이트에 로그인하는 데 익숙할 것입니다.

00:00:33.000 --> 00:00:37.000
비밀번호는 안전하게 사용하기가 정말 어렵다.

00:00:37.000 --> 00:00:45.000
우리 모두는 모든 계정에 대해 강력하고 고유한 비밀번호를 만들어야 한다는 것을 알고 있지만, 실제로 그렇게 하는 사람은 많지 않다.

00:00:45.000 --> 00:00:55.000
앱과 웹사이트를 디자인할 때, 계정을 안전하게 유지하는 것과 좋은 경험을 디자인하는 것 사이에는 끊임없는 절충점이 있습니다.

00:00:55.000 --> 00:01:06.000
그리고 당신의 앱과 웹사이트가 모든 것을 올바르게 하더라도, 피싱과 비밀번호 재사용과 같은 문제는 여전히 계정 손상으로 이어질 수 있습니다.

00:01:06.000 --> 00:01:16.000
macOS Monterey와 iOS 15에서 우리는 솔루션의 개발자 미리보기인 암호키를 발표했고 많은 훌륭한 피드백을 받았습니다.

00:01:16.000 --> 00:01:23.000
macOS Ventura와 iOS 16에서, 우리는 모든 사람이 암호키를 사용할 수 있게 되어 기쁩니다.

00:01:23.000 --> 00:01:26.000
지금이 그들을 입양할 때이다.

00:01:26.000 --> 00:01:42.000
암호 키를 사용하면 사용자 경험이 비밀번호보다 나을 뿐만 아니라 약하고 재사용된 자격 증명, 자격 증명 유출 및 피싱과 같은 전체 범주의 보안 문제도 더 이상 불가능합니다.

00:01:42.000 --> 00:01:45.000
그리고 그것들은 정말 사용하기 쉬워.

00:01:45.000 --> 00:01:47.000
내가 보여줄게.

00:01:47.000 --> 00:01:51.000
우리가 가장 좋아하는 데모 앱인 샤이니부터 시작합시다.

00:01:51.000 --> 00:01:59.000
이 앱을 사용하면 하루에 한 장의 귀여운 사진을 볼 수 있으며 일반적인 비밀번호 기반 로그인 흐름이 있습니다.

00:01:59.000 --> 00:02:04.000
사용자 이름 필드를 탭하여 내 계정에 대한 자동 완성 제안을 볼 수 있습니다.

00:02:04.000 --> 00:02:08.000
내가 그걸 선택할게, 로그인해.

00:02:08.000 --> 00:02:12.000
그럼, 난 내 비밀번호를 입력할 수 있어.

00:02:12.000 --> 00:02:20.000
그런 다음, 나는 SMS 메시지가 내 일회성 코드와 함께 올 때까지 조금 기다린다.

00:02:20.000 --> 00:02:22.000
저기 있어.

00:02:22.000 --> 00:02:25.000
그리고 결국, 나는 로그인했어.

00:02:25.000 --> 00:02:33.000
몇 단계가 걸렸지만, AutoFill과 비밀번호 관리자의 도움으로, 나는 거기에 도착할 수 있었다.

00:02:33.000 --> 00:02:37.000
이제 로그인했으니, 이 계정에 비밀번호를 추가하겠습니다.

00:02:37.000 --> 00:02:41.000
계정 관리, 비밀번호를 추가하세요.

00:02:41.000 --> 00:02:45.000
여기, 저는 암호키를 만들기 위한 시스템 시트를 가지고 있습니다.

00:02:45.000 --> 00:02:47.000
계속해.

00:02:47.000 --> 00:02:48.000
끝났어!

00:02:48.000 --> 00:03:06.000
단 몇 번의 탭으로, 내 장치는 내 계정에 대해 독특하고 암호화적으로 강력한 키 쌍을 생성하여 iCloud 키체인에 저장했기 때문에 macOS Ventura와 iOS 16을 실행하는 모든 장치에서 동기화되고 작동합니다.

00:03:06.000 --> 00:03:11.000
이제 패스키가 있으니, 얼마나 사용하기 쉬운지 보여드리겠습니다.

00:03:11.000 --> 00:03:18.000
나는 로그아웃할 거야, 그리고 내가 전에 사용했던 것과 같은 로그인 양식으로 돌아왔어.

00:03:18.000 --> 00:03:21.000
나는 이전처럼 사용자 이름 필드에 초점을 맞출 것이다.

00:03:21.000 --> 00:03:28.000
이제 내 계정에 대한 암호키를 저장했으므로, QuickType 표시줄에 표시됩니다.

00:03:28.000 --> 00:03:31.000
내가 해야 할 일은 그것을 탭하는 것뿐이고 나는 로그인했다.

00:03:31.000 --> 00:03:34.000
한 걸음.

00:03:34.000 --> 00:03:42.000
비밀번호를 저장할 때, 나는 새로운 비밀번호를 생각해내거나 복잡성 요구 사항을 충족시키려고 노력할 필요가 없었다.

00:03:42.000 --> 00:03:52.000
각 암호키는 시스템에 의해 생성되며 강력하고 단일 계정에서만 사용하도록 보장됩니다.

00:03:52.000 --> 00:04:00.000
그리고 내가 그것으로 로그인할 때, 그것은 내가 익숙한 기존 로그인 흐름에 표시될 수 있으며, 한 번의 탭으로 사용할 수 있다.

00:04:00.000 --> 00:04:10.000
그리고 그 시스템은 강력한 내장 피싱 저항과 함께 올바른 앱이나 웹사이트에서만 사용할 수 있도록 처리할 것이다.

00:04:10.000 --> 00:04:14.000
물론, 암호키는 웹에서도 작동한다.

00:04:14.000 --> 00:04:17.000
여기 저는 사파리의 샤이니 웹사이트에 있습니다.

00:04:17.000 --> 00:04:27.000
내 휴대폰과 마찬가지로, 사용자 이름 필드에 초점을 맞출 때, 내 패스키는 이미 거기에 있고 iCloud 키체인 덕분에 사용할 준비가 되어 있다.

00:04:27.000 --> 00:04:30.000
내가 해야 할 일은 터치 ID뿐이고 로그인했다.

00:04:30.000 --> 00:04:32.000
그게 다야.

00:04:32.000 --> 00:04:37.000
애플의 암호 구현은 개방형 표준을 기반으로 한다.

00:04:37.000 --> 00:04:49.000
우리는 패스키 구현이 크로스 플랫폼과 호환되고 가능한 한 많은 장치에서 작동할 수 있도록 FIDO 얼라이언스 내의 다른 플랫폼 공급 업체와 협력해 왔습니다.

00:04:49.000 --> 00:04:57.000
패스키를 사용하기 위해 계정을 업그레이드한 후에도, 나는 여전히 친구의 PC에서 로그인할 수 있다.

00:04:57.000 --> 00:05:05.000
물론, 내 친구의 PC에는 로컬에 저장된 암호키가 없지만, 나는 여전히 여기에 내 사용자 이름을 입력할 수 있다.

00:05:05.000 --> 00:05:11.000
로그인을 누르면, 휴대폰을 사용할 수 있는 시트가 들어 있습니다.

00:05:11.000 --> 00:05:16.000
그러면 나는 QR 코드를 받는다. 내가 그걸 스캔할게.

00:05:16.000 --> 00:05:22.000
내 핸드폰은 이 QR 코드가 암호키로 로그인하기 위한 것임을 인식한다.

00:05:22.000 --> 00:05:29.000
이 옵션을 선택하면, 내 휴대폰과 브라우저가 서로 안전하게 연결됩니다.

00:05:29.000 --> 00:05:34.000
이제 난 그냥 계속할 수 있고, 로그인했어.

00:05:34.000 --> 00:05:43.000
이 크로스 플랫폼 로그인 경험은 패스키 뒤에 있는 표준의 일부인 일류 시스템 기능입니다.

00:05:43.000 --> 00:05:49.000
표면적으로, 그것은 믿을 수 없을 정도로 간단해 보이지만, 이것은 단순한 QR 코드가 아니다.

00:05:49.000 --> 00:06:07.000
무대 뒤에서, 장치는 로컬 키 계약을 수행하고, 근접성을 증명하고, 종단간 암호화 통신 채널을 구축하며, 모두 쉬운 방식으로 로그인할 수 있지만 암호 키의 강력한 피싱 저항을 유지할 수 있습니다.

00:06:07.000 --> 00:06:14.000
그것은 내가 모든 장치에서 내 계정에 안전하게 로그인할 수 있도록 하는 데 잘 작동한다.

00:06:14.000 --> 00:06:22.000
비밀번호 교체를 위한 또 다른 중요한 기능은 두 명 이상의 사람들 간에 계정을 공유할 수 있는 기능입니다.

00:06:22.000 --> 00:06:28.000
다른 사람과 패스키를 공유하려면, AirDrop을 사용할 수 있습니다.

00:06:28.000 --> 00:06:35.000
내 파트너와 나는 또한 우리가 공유하는 Shiny 계정을 가지고 있는데, 나는 이미 패스키를 사용하도록 업그레이드했다.

00:06:35.000 --> 00:06:43.000
암호로, 자격 증명은 내가 입력할 수 있는 것이 아니지만, 나는 여전히 내가 신뢰하는 사람들과 공유할 수 있다.

00:06:43.000 --> 00:06:48.000
내 핸드폰에서, 나는 계좌 세부 정보를 열 것이다.

00:06:48.000 --> 00:06:54.000
여기 비밀번호와 비밀번호를 모두 사용하는 제 모든 계정이 있습니다.

00:06:54.000 --> 00:06:58.000
공유 계정을 탭하여 더 많은 세부 사항을 확인할 수 있습니다.

00:06:58.000 --> 00:07:04.000
여기서, 저장된 비밀번호에 대한 정보를 얻거나 이 계정에 메모를 추가할 수 있습니다.

00:07:04.000 --> 00:07:08.000
나도 내 비밀번호를 공유할 수 있어.

00:07:08.000 --> 00:07:09.000
내 파트너의 핸드폰이 있어.

00:07:09.000 --> 00:07:14.000
내가 가서 그걸 선택할게.

00:07:14.000 --> 00:07:19.000
이제 내 파트너도 비밀번호를 가지고 있어.

00:07:19.000 --> 00:07:25.000
그리고 그것이 모든 곳에서 패스키를 사용하는 것이 얼마나 쉬운지이다.

00:07:25.000 --> 00:07:29.000
나는 방금 패스키를 사용한 경험을 검토했다.

00:07:29.000 --> 00:07:36.000
다음으로, 나는 암호키가 무엇인지와 그것들을 사용할 때 몇 가지 인터페이스 지침에 대해 이야기할 것이다.

00:07:36.000 --> 00:07:52.000
그런 다음 자동 완성을 활용하여 앱과 웹사이트의 기존 로그인 흐름에 암호키를 통합하는 방법을 보여드리고, 로그인 프로세스를 더욱 간소화할 수 있는 몇 가지 추가 옵션을 보여드리겠습니다.

00:07:52.000 --> 00:08:04.000
그 후, 나는 패스키가 어떻게 작동하는지에 대한 좀 더 기술적인 세부 사항을 살펴보고 마지막으로 패스키와 다단계 인증에 대해 논의할 것이다.

00:08:04.000 --> 00:08:07.000
먼저, 패스키를 위한 디자인.

00:08:07.000 --> 00:08:15.000
비밀번호에 대해 이야기할 때, 무엇보다도, 비밀번호는 비밀번호를 대체하는 것이다.

00:08:15.000 --> 00:08:23.000
그들은 로그인하기가 더 빠르고, 사용하기 쉽고, 훨씬 더 안전합니다.

00:08:23.000 --> 00:08:29.000
다음은 앱과 웹사이트에서 암호키를 참조하는 방법에 대한 몇 가지 지침입니다.

00:08:29.000 --> 00:08:33.000
"패스키"는 일반적이고 사용자가 볼 수 있는 용어이다.

00:08:33.000 --> 00:08:45.000
이 비디오는 애플의 구현에 초점을 맞추고 있지만, 방금 보여 주었듯이, 다른 주요 플랫폼은 이미 암호키에 대한 자체 지원을 구축하기 시작했습니다.

00:08:45.000 --> 00:08:49.000
"암호"는 또한 "암호"와 같은 일반적인 명사이다.

00:08:49.000 --> 00:08:54.000
영어로, 이것은 소문자이고 "비밀번호"처럼 복수화된다는 것을 의미한다.

00:08:54.000 --> 00:09:03.000
저는 제 계정에 대한 암호키를 가지고 있으며, 설정으로 이동하여 암호키로 모든 계정을 볼 수 있습니다.

00:09:03.000 --> 00:09:15.000
Apple 플랫폼에서는 SF Symbol person.key.badge와 .fill 변형을 사용하여 시스템과 일치하는 아이콘을 제공할 수도 있습니다.

00:09:15.000 --> 00:09:24.000
앱과 웹사이트에서 패스키를 제공할 때, 완전히 새로운 인터페이스를 디자인할 필요가 없습니다.

00:09:24.000 --> 00:09:30.000
사용자 이름 필드는 오늘날 대부분의 앱과 웹사이트 로그인의 중심 지점입니다.

00:09:30.000 --> 00:09:40.000
거의 모든 사람들이 그것을 사용하는 방법을 알고 있으며, 많은 앱과 웹사이트는 이미 계정당 로그인 경험을 맞춤화하기 위해 그것을 활용하고 있다.

00:09:40.000 --> 00:09:45.000
이제 사용자 이름 필드에는 또 다른 큰 기능이 있다.

00:09:45.000 --> 00:09:55.000
암호키는 로그인이 어떻게 작동하는지에 대한 새로운 패러다임을 가져오지만, 비밀번호로부터의 전환도 매끄럽고 쉬워야 한다.

00:09:55.000 --> 00:10:10.000
이제 자동 완성을 일류 기능으로 사용하여 암호키를 제시할 수 있으며, 친숙하고 사람들이 사용하는 방법을 알고 있는 인터페이스에서 기존 로그인 흐름에 바로 넣을 수 있습니다.

00:10:10.000 --> 00:10:15.000
자동 완성으로 패스키를 제시하는 것이 당신이 그것들을 사용해야 하는 주요 방법입니다.

00:10:15.000 --> 00:10:25.000
하지만 고급 사용을 위해, 애플 플랫폼에는 패스키로 로그인할 수 있는 다양한 추가 UI 옵션이 있습니다.

00:10:25.000 --> 00:10:30.000
패스키를 사용하고 자동 완성으로 제시하는 방법은 다음과 같습니다.

00:10:30.000 --> 00:10:37.000
암호키는 WebAuthentication 또는 WebAuthn 표준을 기반으로 하며 공개 키 암호화를 사용합니다.

00:10:37.000 --> 00:10:46.000
타이핑 가능한 단어나 문자열을 갖는 대신, 모든 계정에 대해 고유한 암호화 키 쌍이 생성됩니다.

00:10:46.000 --> 00:10:52.000
암호 로그인을 수행하려면 서버 백엔드에서 WebAuthn을 채택해야 합니다.

00:10:52.000 --> 00:10:59.000
모든 표준 WebAuthn 서버 구현은 암호키와 함께 작동해야 합니다.

00:10:59.000 --> 00:11:08.000
Apple 플랫폼의 앱에서 암호키는 AuthenticationServices 프레임워크의 ASAuthorization API 제품군의 일부입니다.

00:11:08.000 --> 00:11:17.000
이것은 비밀번호, 보안 키 및 Apple로 로그인을 포함한 모든 종류의 자격 증명으로 작업하기 위한 API입니다.

00:11:17.000 --> 00:11:30.000
우리는 또한 이 API를 더욱 유연하게 만들고 기존 로그인 흐름에 원활하게 맞출 수 있도록 자동 완성 지원과 같이 사용할 수 있는 몇 가지 새로운 방법을 추가했습니다.

00:11:30.000 --> 00:11:39.000
앱에서 암호키 사용을 시작하려면, 먼저 webcredentials 서비스를 사용하여 관련 도메인을 설정해야 합니다.

00:11:39.000 --> 00:11:47.000
"앱용 비밀번호 자동 완성 소개" 및 "유니버설 링크의 새로운 기능" 비디오에서 자세한 내용을 확인할 수 있습니다.

00:11:47.000 --> 00:11:54.000
앱의 인터페이스에서 사용자 이름 필드가 사용자 이름 textContentTtype을 사용하고 있는지 확인하세요.

00:11:54.000 --> 00:11:59.000
이것은 시스템이 어디에서 암호 제안을 제공해야 하는지 알 수 있게 해준다.

00:11:59.000 --> 00:12:05.000
그것이 구성되면, 여기 자동 완성 지원 암호 요청을 시작하는 데 필요한 코드가 있습니다.

00:12:05.000 --> 00:12:09.000
당신이 그것을 무너뜨릴 때 그것은 단지 몇 가지 간단한 단계일 뿐입니다.

00:12:09.000 --> 00:12:16.000
모든 WebAuthn 요청과 마찬가지로, 먼저 서버에서 챌린지를 가져와야 합니다.

00:12:16.000 --> 00:12:19.000
그런 다음 공급자와 요청을 만드세요.

00:12:19.000 --> 00:12:28.000
ASAuthorizationPlatformPublicKey CredentialProvider는 암호 요청 작업을 위한 ASAuthorizationProvider입니다.

00:12:28.000 --> 00:12:38.000
WebAuthn 용어에서는 로그인할 때 어설션이 사용되므로, 여기서는 기존 암호키로 로그인하기 위한 어설션 요청을 만들고 있습니다.

00:12:38.000 --> 00:12:42.000
ASAuthorizationController는 실제로 요청을 처리하는 것이다.

00:12:42.000 --> 00:12:50.000
패스키 요청으로 인스턴스를 만들고 대리인과 presentationContextProvider를 구성하세요.

00:12:50.000 --> 00:12:56.000
그리고 마지막으로, performAutoFillAssistedRequests를 호출하여 요청을 시작하세요.

00:12:56.000 --> 00:13:05.000
이 요청이 앱에서 실행되는 동안, 사용자 이름 필드에 초점을 맞출 때마다, 시스템은 QuickType 바에서 사용 가능한 패스키를 제공합니다.

00:13:05.000 --> 00:13:15.000
사용자 이름 필드가 집중되기 전에 보기 수명 초기에 이 요청을 시작해야 하므로 키보드가 나타날 때 암호키가 준비됩니다.

00:13:15.000 --> 00:13:26.000
QuickType 표시줄의 항목이 선택되면, Face ID가 호출되고, 로그인을 완료하기 위해 ASAuthorizationController Delegate 콜백을 받게 됩니다.

00:13:26.000 --> 00:13:29.000
당신의 텍스트 필드에는 실제로 아무것도 채워지지 않습니다.

00:13:29.000 --> 00:13:37.000
자격 증명 유형에 대한 인증이 성공하면, didCompleteWithAuthorization 콜백을 받게 됩니다.

00:13:37.000 --> 00:13:41.000
가장 먼저 해야 할 일은 당신이 받은 자격 증명의 유형을 확인하는 것입니다.

00:13:41.000 --> 00:13:50.000
암호 로그인의 경우, ASAuthorizationPlatformPublicKey CredentialAssertion이 될 것입니다.

00:13:50.000 --> 00:13:55.000
어설션 객체는 백엔드에서 로그인을 확인하는 데 필요한 필드를 포함합니다.

00:13:55.000 --> 00:14:01.000
값을 읽고, 서버로 확인하고, 로그인을 완료해야 합니다.

00:14:01.000 --> 00:14:04.000
자동 완성 보조 패스키 요청은 강력하다.

00:14:04.000 --> 00:14:11.000
그 작은 코드 변경으로, 앱의 로그인 흐름은 이제 많은 유연성을 제공합니다.

00:14:11.000 --> 00:14:19.000
물론 주요 사례는 QuickType 표시줄에서 암호키 제안을 선택하여 해당 암호키로 빠르게 로그인하는 것입니다.

00:14:19.000 --> 00:14:24.000
이것이 당신이 가장 자주 일어날 것으로 예상해야 하는 것입니다.

00:14:24.000 --> 00:14:26.000
하지만 다른 선택지가 있어.

00:14:26.000 --> 00:14:33.000
방금 보여준 코드는 추가 변경 없이 주변 장치에서 암호로 로그인할 수 있습니다.

00:14:33.000 --> 00:14:43.000
키 아이콘을 탭하여 사용 가능한 모든 암호와 비밀번호를 나열하는 보기를 표시하고 가까운 장치로 로그인할 수 있는 옵션을 볼 수 있습니다.

00:14:43.000 --> 00:14:47.000
그런 다음 교차 장치 암호 로그인을 수행할 수 있습니다.

00:14:47.000 --> 00:14:55.000
두 경우 모두, 암호키를 사용하면 동일한 ASAuthorizationController 위임 콜백을 받게 됩니다.

00:14:55.000 --> 00:14:59.000
이것을 지원하기 위해 당신이 해야 할 특별한 일은 없습니다.

00:14:59.000 --> 00:15:05.000
사용자가 아직 암호키가 없다면, 익숙한 것처럼 로그인 양식을 사용할 수 있습니다.

00:15:05.000 --> 00:15:11.000
그들은 QuickType 바에서 비밀번호 제안을 받거나, 필드에 입력할 수 있습니다.

00:15:11.000 --> 00:15:21.000
비밀번호 항목을 선택하면, 자격 증명은 여전히 텍스트 필드에 채워질 것이며, 실행 중인 요청을 취소할 수 있습니다.

00:15:21.000 --> 00:15:30.000
우리는 당신이 기존 로그인 흐름에 바로 드롭하고 사용자가 매우 쉽게 할 수 있도록 이 API를 설계했습니다.

00:15:30.000 --> 00:15:46.000
이미 암호키를 사용하도록 업그레이드한 사람이 자동 완성 제안을 사용하는 대신 사용자 이름을 입력하기로 결정한 경우, 자동 완성 요청을 취소하고 ASAuthorizationController를 사용하여 모달 암호키 로그인 시트를 제시해야 합니다.

00:15:46.000 --> 00:15:53.000
여기에서, 그것은 여전히 한 번의 탭이며, 당신은 동일한 ASAuthorizationController Delegate 콜백을 받게 될 것입니다.

00:15:53.000 --> 00:15:56.000
여기 이전의 코드가 있습니다.

00:15:56.000 --> 00:16:07.000
이것을 자동 완성 요청에서 모달 요청으로 전환하려면, 이 performAutoFillAssistedRequests 메소드 호출을 performRequests() 호출로 바꾸세요.

00:16:07.000 --> 00:16:16.000
이것은 사용 가능한 모든 암호키와 인근 장치의 암호키를 사용할 수 있는 옵션이 있는 모달 시트를 제시할 것이다.

00:16:16.000 --> 00:16:22.000
그것들은 암호키를 지원하기 위해 앱에 필요한 유일한 코드 변경 사항입니다.

00:16:22.000 --> 00:16:28.000
웹 플랫폼은 또한 자동 완성 지원 및 모달 패스키 요청을 모두 지원합니다.

00:16:28.000 --> 00:16:36.000
웹에서 암호키는 보안 키에도 사용되는 표준 WebAuthn API를 통해 사용됩니다.

00:16:36.000 --> 00:16:54.000
앱과 마찬가지로, 자동 완성 지원 요청을 채택하면 터치 ID로 빠르게 로그인하거나, 사용 가능한 모든 암호키와 비밀번호를 확인하거나, 가까운 장치에서 암호키를 사용할 수 있습니다.

00:16:54.000 --> 00:17:10.000
우선, 사용자 이름과 webauthn 자동 완성 세부 토큰으로 웹 페이지의 사용자 이름 필드에 주석을 달면 비밀번호와 암호 제안이 모두 올바른 위치에 표시되도록 하십시오.

00:17:10.000 --> 00:17:16.000
완료되면, 자바스크립트에서 일반적인 WebAuthn 로그인이 있습니다.

00:17:16.000 --> 00:17:22.000
WebAuthn에서, 자동 완성 스타일 요청은 조건부 중재를 사용하여 호출됩니다.

00:17:22.000 --> 00:17:29.000
표준 자바스크립트 기능 감지를 사용하여 사용 가능한지 확인해야 합니다.

00:17:29.000 --> 00:17:33.000
만약 그렇다면, 당신은 당신의 요청을 진행할 수 있습니다.

00:17:33.000 --> 00:17:40.000
네이티브 API와 마찬가지로, 서버에서 가져온 챌린지를 사용하여 요청하는 것으로 시작할 것입니다.

00:17:40.000 --> 00:17:47.000
자동 완성 지원 요청으로 만들려면, 중재: "조건부" 매개 변수를 옵션에 추가하십시오.

00:17:47.000 --> 00:17:53.000
그런 다음, navigator.credentials .get을 사용하여 요청을 시작하세요.

00:17:53.000 --> 00:17:56.000
.Get call은 약속을 돌려준다.

00:17:56.000 --> 00:18:04.000
해결되면, 확인을 위해 서버로 다시 보낼 수 있는 어설션 객체를 받은 다음 로그인을 완료합니다.

00:18:04.000 --> 00:18:15.000
앱과 마찬가지로, 누군가가 암호키로 계정의 사용자 이름을 수동으로 입력하는 경우, API를 사용하여 모달 로그인 시트를 제시해야 합니다.

00:18:15.000 --> 00:18:22.000
모달 요청으로 전환하려면, 중재를 제거하기만 하면 됩니다: "조건부" 매개 변수.

00:18:22.000 --> 00:18:29.000
WebAuthn을 사용할 때 주의해야 할 한 가지는 Apple 플랫폼이 사용자 확인 또는 UV를 처리하는 방법입니다.

00:18:29.000 --> 00:18:39.000
UV는 Authenator가 현재 사용자가 장치의 소유자인지 확인하려고 시도했는지 여부를 나타내는 WebAuthn 응답의 부울 필드입니다.

00:18:39.000 --> 00:18:47.000
Apple 장치에서, 1의 값은 생체 인식 또는 암호 또는 암호가 사용되었다는 것을 나타냅니다.

00:18:47.000 --> 00:18:55.000
Apple 플랫폼은 생체 인식을 사용할 수 있을 때 항상 암호에 UV를 요구하므로, 그것에 대해 걱정할 필요가 없습니다.

00:18:55.000 --> 00:19:02.000
WebAuthn 요청을 할 때, 사용자 확인 요구 사항을 지정할 수 있는 옵션이 있습니다.

00:19:02.000 --> 00:19:06.000
기본값은 userVerification: "preferred"입니다.

00:19:06.000 --> 00:19:14.000
생체 인식이 없는 장치에서 나쁜 경험을 하지 않으려면 항상 기본값을 사용하세요.

00:19:14.000 --> 00:19:18.000
다음은 웹에서 암호키를 사용하기 위한 몇 가지 추가 참고 사항입니다.

00:19:18.000 --> 00:19:25.000
자동 완성 지원 요청을 할 때, 앱과 마찬가지로 페이지 수명 초기에 요청해야 합니다.

00:19:25.000 --> 00:19:32.000
모달 WebAuthn 요청의 경우, 버튼 클릭과 같은 사용자 제스처 이벤트에서 트리거해야 합니다.

00:19:32.000 --> 00:19:44.000
모달 요청은 사용자 제스처 이벤트 외부에서 페이지 로드당 한 번 트리거될 수 있지만, WebKit은 그렇게 하면 해당 페이지에서 후속 호출을 제한할 수 있습니다.

00:19:44.000 --> 00:19:52.000
자동 완성 요청은 모달이 아니므로 사용자 제스처가 필요하지 않으며 타임아웃이 훨씬 더 길다.

00:19:52.000 --> 00:19:58.000
마지막으로, 암호키는 사파리의 레거시 플랫폼 인증기를 대체하고 있다.

00:19:58.000 --> 00:20:08.000
기존 자격 증명은 여전히 작동하며 생성된 장치에 바인딩되지만, 새로운 플랫폼 자격 증명은 암호키로 생성됩니다.

00:20:08.000 --> 00:20:17.000
패스키는 증명 진술을 제공하지 않기 때문에 등록 중에 레거시 자격 증명과 구별될 수 있습니다.

00:20:17.000 --> 00:20:19.000
그건 비밀번호와 자동 완성이야.

00:20:19.000 --> 00:20:26.000
다음으로, 로그인 경험을 더욱 간소화할 수 있는 몇 가지 추가 플랫폼 기능을 검토하겠습니다.

00:20:26.000 --> 00:20:34.000
자동 완성 지원 로그인 외에도, ASAuthorization API는 더 많은 유용한 기능을 제공합니다.

00:20:34.000 --> 00:20:39.000
저는 API의 세 가지 추가 기능과 당신이 그것들을 사용하고 싶을 때를 다룰 것입니다.

00:20:39.000 --> 00:20:43.000
패스키 허용 목록으로 시작합니다.

00:20:43.000 --> 00:20:52.000
사용자 이름을 입력한 후 모달 패스키 시트를 제시할 때, 장치에 저장된 여러 계정에 대한 패스키가 있을 수 있습니다.

00:20:52.000 --> 00:20:56.000
사용 가능한 모든 암호키는 기본적으로 시트에 표시됩니다.

00:20:56.000 --> 00:21:05.000
암호 허용 목록을 사용하여 시트에 표시되는 암호 키를 제한하여 일치하는 계정만 제공할 수 있습니다.

00:21:05.000 --> 00:21:10.000
모달 요청에 허용 목록을 추가하려면, 먼저 사용자 이름이 필요합니다.

00:21:10.000 --> 00:21:17.000
해당 사용자 이름을 사용하여 일치하는 자격 증명 ID 목록을 가져와 허용 목록으로 바꿀 수 있습니다.

00:21:17.000 --> 00:21:22.000
자격 증명 ID는 암호키의 고유 식별자이다.

00:21:22.000 --> 00:21:28.000
Webauthn 서버는 주어진 사용자 이름에 대한 자격 증명 ID를 찾을 수 있는 방법이 있어야 합니다.

00:21:28.000 --> 00:21:32.000
여기서부터, 이전과 같이 당신의 요청을 진행하세요.

00:21:32.000 --> 00:21:42.000
이제, 암호키를 사용하는 세 개의 샤이니 계정이 있는 내 장치에서, 시트는 내가 사용하려고 하는 단일 계정만 제공한다.

00:21:42.000 --> 00:21:54.000
모달 요청을 할 때, 이미 사용자 이름을 입력한 경우와 같이 사용자가 로그인하려는 계정에 대한 추가 컨텍스트가 있을 때 허용 목록을 사용해야 합니다.

00:21:54.000 --> 00:22:02.000
다음으로, 현재 장치에 저장된 암호키가 없는 경우 모달 암호키 요청이 어떻게 되는지 다루겠습니다.

00:22:02.000 --> 00:22:08.000
이것은 허용 목록을 사용하고 저장된 암호키 중 어느 것도 그 목록과 일치하지 않는 경우에도 적용됩니다.

00:22:08.000 --> 00:22:23.000
기본적으로, 모달 암호 요청을 할 때, 일치하는 암호가 없는 경우, 모달 시트가 표시되고 인근 장치에서 암호로 로그인하기 위한 QR 코드가 즉시 표시됩니다.

00:22:23.000 --> 00:22:30.000
이것은 로그인할 때 가장 유연성을 제공하며 암호키가 사용되고 있다는 것을 알 때 최선의 선택입니다.

00:22:30.000 --> 00:22:39.000
하지만 API에는 즉시 사용할 수 있는 자격 증명을 선호하고 없는 경우 대리자 콜백으로 조용히 후퇴하는 새로운 옵션이 있습니다.

00:22:39.000 --> 00:22:47.000
이것은 전통적인 로그인 양식을 보여주기 전에 가능한 경우 기존 자격 증명을 빠르게 제공하는 데 사용할 수 있습니다.

00:22:47.000 --> 00:22:56.000
기본 옵션을 사용하는 이 모달 요청은 현재 장치에 일치하는 암호키가 없는 경우 QR 코드를 보여주는 것으로 되돌아갑니다.

00:22:56.000 --> 00:23:07.000
QR 코드를 받는 대신 preferImmediately AvailableCredentials 옵션을 사용하면 오류가 있는 대리자 콜백을 받게 됩니다.

00:23:07.000 --> 00:23:23.000
취소된 코드로 ASAuthorizationError를 받는 경우, 이는 사용자가 시트를 보고 수동으로 해제했거나 preferImmediately AvailableCredentials를 통과하고 자격 증명을 즉시 사용할 수 없다는 것을 의미합니다.

00:23:23.000 --> 00:23:28.000
당신이 여기서 하는 일은 당신이 이것을 부르는 맥락에 달려 있습니다.

00:23:28.000 --> 00:23:40.000
예를 들어, 일반 로그인 양식을 표시하기 전에 로컬 자격 증명을 테스트하는 방법으로 이 옵션을 사용하는 경우, 이것은 양식을 표시하는 트리거됩니다.

00:23:40.000 --> 00:23:48.000
장치에 일치하는 자격 증명이 하나 이상 있는 경우, 사용된 옵션에 관계없이 전체 모달 시트가 표시됩니다.

00:23:48.000 --> 00:24:06.000
현재 장치에 암호키가 없는 경우 주변 장치로 로그인하는 옵션이 여전히 연결될 수 있도록 앱 어딘가에서 기본 대체가 있는 자동 완성 지원 요청 또는 모달 요청을 사용하고 있는지 확인하십시오.

00:24:06.000 --> 00:24:13.000
내가 다룰 ASAuthorization API의 마지막 기능은 결합된 자격 증명 요청을 하는 것이다.

00:24:13.000 --> 00:24:21.000
이 예에서, 앱은 암호키, 비밀번호 및 Apple로 로그인을 요청했습니다.

00:24:21.000 --> 00:24:29.000
내 장치에는 세 개의 다른 계정에 대한 세 개의 다른 자격 증명이 저장되어 있으므로, 모두 여기에 표시됩니다.

00:24:29.000 --> 00:24:34.000
하지만 더 가능성이 높은 시나리오는 누군가가 하나의 계정만 가지고 있다는 것이다.

00:24:34.000 --> 00:24:40.000
이 경우, 이 동일한 결합된 자격 증명 요청은 시트에서 하나의 계정만 제공할 것이다.

00:24:40.000 --> 00:24:47.000
기존 ASAuthorization 요청에 추가 자격 증명 유형을 추가하는 것은 정말 쉽습니다.

00:24:47.000 --> 00:24:56.000
추가 요청 유형에 대한 공급자와 요청을 만든 다음, 새로운 요청을 컨트롤러에 전달하기만 하면 됩니다.

00:24:56.000 --> 00:25:02.000
이제, 모달 시트는 이러한 자격 증명 유형에서 사용할 수 있는 모든 자격 증명을 제공할 것이다.

00:25:02.000 --> 00:25:07.000
어떤 자격 증명 유형이 사용되는지에 관계없이 동일한 대리자 콜백을 받게 될 것입니다.

00:25:07.000 --> 00:25:15.000
받은 자격 증명 유형을 확인하고 해당 자격 증명 유형에 적합한 로그인을 완료해야 합니다.

00:25:15.000 --> 00:25:21.000
그래서 그것은 ASAuthorization API 제품군의 몇 가지 고급 기능을 다룹니다.

00:25:21.000 --> 00:25:29.000
이제, 나는 패스키가 실제로 어떻게 작동하는지 그리고 무엇이 그것들을 그렇게 안전하게 만드는지에 대한 좀 더 기술적인 세부 사항을 파헤칠 것이다.

00:25:29.000 --> 00:25:44.000
오늘 비밀번호로 로그인할 때, 일반적으로 실제로 일어나는 일은 비밀번호를 입력한 후 해시되고 소금에 절여지고, 그 결과 난독화된 값이 서버로 전송되어 이를 저장합니다.

00:25:44.000 --> 00:25:51.000
나중에, 동일한 해시 소금에 절인 값을 생산할 수 있다면, 계정에 들어갈 수 있습니다.

00:25:51.000 --> 00:25:59.000
이것은 서버가 공격자에게 매우 가치 있는 비밀번호의 파생물을 저장할 책임이 있다는 것을 의미합니다.

00:25:59.000 --> 00:26:06.000
그들이 그것을 얻을 수 있다면, 당신의 비밀번호가 무엇인지 알아내고 당신의 계정에 접근할 수 있습니다.

00:26:06.000 --> 00:26:10.000
그러나 비밀번호는 매우 다르게 작동한다.

00:26:10.000 --> 00:26:16.000
입력 가능한 단일 문자열을 갖는 대신, 암호키는 실제로 한 쌍의 관련 키이다.

00:26:16.000 --> 00:26:23.000
이 키들은 당신의 장치에 의해 모든 계정에 대해 안전하고 독특하게 생성됩니다.

00:26:23.000 --> 00:26:27.000
하나는 공용이며 서버에 저장됩니다.

00:26:27.000 --> 00:26:33.000
다른 하나는 비공개이며 로그인할 때에도 장치에 남아 있습니다.

00:26:33.000 --> 00:26:36.000
공개 키는 비밀이 아니다.

00:26:36.000 --> 00:26:40.000
그것은 당신의 사용자 이름만큼 공개됩니다.

00:26:40.000 --> 00:26:44.000
개인 키는 실제로 로그인하는 데 필요한 것이다.

00:26:44.000 --> 00:26:50.000
서버는 당신의 개인 키가 무엇인지 절대 배우지 않으며, 당신의 장치는 그것을 안전하게 유지합니다.

00:26:50.000 --> 00:26:57.000
로그인할 때, 서버는 장치에 일회용 챌린지를 보냅니다.

00:26:57.000 --> 00:27:07.000
WebAuthn은 다양한 도전-응답 알고리즘을 허용하지만, Apple 플랫폼의 암호키는 표준 ES256을 사용합니다.

00:27:07.000 --> 00:27:14.000
오직 당신의 개인 키만이 당신의 계정에 대한 도전에 대한 유효한 해결책을 만들 수 있습니다.

00:27:14.000 --> 00:27:23.000
당신의 장치는 서명이라고 불리는 이 솔루션을 로컬로 생성하고, 솔루션을 서버로 다시 보냅니다.

00:27:23.000 --> 00:27:28.000
당신의 개인 키는 당신의 장치에만 비밀로 유지됩니다.

00:27:28.000 --> 00:27:34.000
그런 다음 서버는 공개 키를 사용하여 솔루션을 검증합니다.

00:27:34.000 --> 00:27:39.000
장치가 제공한 솔루션이 유효하다면, 로그인한 것입니다!

00:27:39.000 --> 00:27:47.000
공개 키는 해결책이 유효하지만 해결책 자체를 생성할 수 없는지 확인하는 데 사용될 수 있다.

00:27:47.000 --> 00:27:55.000
이것은 서버가 개인 키가 실제로 무엇인지 모른 채 올바른 개인 키를 가지고 있는지 확인할 수 있다는 것을 의미합니다.

00:27:55.000 --> 00:28:06.000
그리고 서버는 개인 키를 모르기 때문에, 유출할 사용자 자격 증명이 없기 때문에 공격자에게 덜 가치 있는 표적이다.

00:28:06.000 --> 00:28:13.000
이 모든 암호화와 키 보호는 완전히 투명하며 장치에 의해 수행됩니다.

00:28:13.000 --> 00:28:17.000
당신의 고객들은 그것에 대해 알거나 생각할 필요가 없습니다.

00:28:17.000 --> 00:28:23.000
그들의 관점에서 볼 때, 비밀번호는 매우 간단하고 모든 곳에서 작동합니다.

00:28:23.000 --> 00:28:30.000
암호키는 또한 안전하고 피싱 방지 방식으로 여러 장치에서 로그인하는 데 사용할 수 있습니다.

00:28:30.000 --> 00:28:33.000
그게 작동하는 방법은 다음과 같습니다.

00:28:33.000 --> 00:28:34.000
여기에 두 개의 장치가 있습니다.

00:28:34.000 --> 00:28:44.000
내가 로그인하는 장치 또는 웹 브라우저인 클라이언트와 내 암호키가 있는 장치인 인증자.

00:28:44.000 --> 00:28:49.000
먼저, 고객은 인증자가 스캔하는 QR 코드를 보여준다.

00:28:49.000 --> 00:28:56.000
이 QR 코드에는 한 쌍의 일회용 암호화 키를 인코딩하는 URL이 포함되어 있습니다.

00:28:56.000 --> 00:29:04.000
그런 다음, 인증자는 네트워크 릴레이 서버에 대한 라우팅 정보가 포함된 블루투스 광고를 생성합니다.

00:29:04.000 --> 00:29:13.000
이 로컬 교환을 통해 서버를 선택하고 라우팅 정보를 공유할 수 있지만, 두 가지 추가 기능도 제공합니다.

00:29:13.000 --> 00:29:25.000
서버가 볼 수 없는 대역외 키 계약을 수행하므로, 네트워크를 통해 가는 모든 것은 종단간 암호화되며 서버는 아무것도 읽을 수 없습니다.

00:29:25.000 --> 00:29:31.000
그것은 또한 이 두 장치가 물리적으로 근접해 있다는 강력한 주장을 제공한다.

00:29:31.000 --> 00:29:47.000
이는 원격 공격자가 블루투스 광고를 수신하고 로컬 교환을 완료할 수 없기 때문에 이메일로 전송되거나 가짜 웹사이트에서 생성된 QR 코드가 작동하지 않는다는 것을 의미합니다.

00:29:47.000 --> 00:29:49.000
그래서 그게 지역 부분이야.

00:29:49.000 --> 00:29:57.000
로컬 교환과 키 계약이 이루어지면, 두 장치는 전화로 선택한 릴레이 서버에 연결됩니다.

00:29:57.000 --> 00:30:09.000
거기에서, 그들은 이전의 키를 사용하여 암호화된 표준 FIDO CTAP 작업을 수행하므로 릴레이 서버는 진행 중인 것을 볼 수 없습니다.

00:30:09.000 --> 00:30:14.000
이 전체 과정은 장치와 웹 브라우저에 의해 수행된다.

00:30:14.000 --> 00:30:19.000
그 웹사이트는 교차 장치 통신의 어느 시점에서도 관여하지 않는다.

00:30:19.000 --> 00:30:28.000
크로스 디바이스 크로스 플랫폼 로그인은 암호키를 사용할 수 있는 모든 곳에서 작동하는 시스템 기능입니다.

00:30:28.000 --> 00:30:37.000
그래서 그것은 패스키가 어떻게 작동하는지, 그리고 장치 전반에 걸쳐 어떻게 강력한 보안 보장을 할 수 있는지에 대한 보다 기술적인 시각이다.

00:30:37.000 --> 00:30:40.000
다음은 다단계 인증입니다.

00:30:40.000 --> 00:30:46.000
오늘날 인증에 대해 생각하는 일반적인 방법은 요인의 관점에서이다.

00:30:46.000 --> 00:30:55.000
다른 요인들은 다른 종류의 공격에 대해 강하거나 약하며, 요인을 결합하면 더 나은 집단적 범위를 제공할 수 있다.

00:30:55.000 --> 00:30:59.000
하지만 패스키로, 당신은 더 이상 그렇게 생각할 필요가 없습니다.

00:30:59.000 --> 00:31:04.000
여기 오늘 로그인하는 데 사용되는 가장 일반적인 방법 중 몇 가지가 있습니다.

00:31:04.000 --> 00:31:08.000
머릿속의 비밀번호는 거의 모든 것에 취약합니다.

00:31:08.000 --> 00:31:20.000
비밀번호 관리자는 독특하고 엔트로피가 높은 문자열을 생성하는 데 능숙하며, 장치 도난에 대한 로컬 보호 기능을 가질 수 있으며, 피싱에 대한 몇 가지 힌트를 제공합니다.

00:31:20.000 --> 00:31:29.000
SMS 또는 시간 기반 코드를 추가하면 어떤 상황에서는 도난이나 피싱에 도움이 될 수 있지만 실제로 해결되지는 않습니다.

00:31:29.000 --> 00:31:36.000
하지만 암호키를 사용하면, 모든 암호키는 장치로 생성된 고유한 키 쌍이다.

00:31:36.000 --> 00:31:42.000
Apple 장치에서, 그것들은 로컬 장치 보호의 강력한 기반을 기반으로 구축되었다.

00:31:42.000 --> 00:31:48.000
암호는 또한 피싱에서 인적 요소를 완전히 제거한다.

00:31:48.000 --> 00:31:55.000
그리고 서버에는 개인 키가 없기 때문에 앱이나 웹사이트 서버에 의해 유출될 수 없습니다.

00:31:55.000 --> 00:32:05.000
비밀번호 기반 로그인 흐름에 요소를 추가하는 것은 비밀번호 자체보다 더 많은 유형의 공격으로부터 보호할 수 있기 때문에 의미가 있습니다.

00:32:05.000 --> 00:32:12.000
하지만 암호 키만으로도 추가 요인이 필요하지 않을 정도로 훨씬 더 많은 것을 보호합니다.

00:32:12.000 --> 00:32:16.000
나는 비밀번호가 없는 미래를 기대하고 있어.

00:32:16.000 --> 00:32:20.000
그렇게 하기 시작하는 방법은 다음과 같습니다.

00:32:20.000 --> 00:32:26.000
우선, 아직 그렇게 하지 않았다면, 서버에 WebAuthn을 채택해야 합니다.

00:32:26.000 --> 00:32:32.000
암호키는 표준 WebAuthn 서버 구현과 함께 작동해야 합니다.

00:32:32.000 --> 00:32:38.000
서버가 준비되면, 앱과 웹사이트에 새로운 API를 채택하세요.

00:32:38.000 --> 00:32:50.000
자동 완성 지원 패스키 요청은 기존 로그인 흐름에 바로 드롭할 수 있으며, 필요한 경우 다양한 고급 UI 옵션도 있습니다.

00:32:50.000 --> 00:32:56.000
그리고 마지막으로, 사용자를 비밀번호에서 벗어나게 하세요.

00:32:56.000 --> 00:33:05.000
패스키는 앱과 웹사이트에 안전하게 로그인하는 편의성과 보안 문제에 대한 업계 표준 솔루션입니다.

00:33:05.000 --> 00:33:18.000
고객에게 암호키와 비밀번호에서 멀어지도록 안내함으로써, 모든 사람의 보안 기준을 높이면서 믿을 수 없을 정도로 빠르고 편리한 로그인 경험을 제공할 수 있습니다.

00:33:18.000 --> 00:33:19.000
고마워.

00:33:19.000 --> 23:59:59.000
♪

