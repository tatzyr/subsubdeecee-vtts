WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:14.000
안녕하세요, 저는 리차드입니다. 저는 스위프트 스탠다드 라이브러리 팀의 엔지니어입니다.

00:00:14.000 --> 00:00:18.000
오늘, Swift Regex의 기초를 넘어서는 여행을 시작합시다.

00:00:18.000 --> 00:00:23.000
스위프트 5.7은 문자열 처리를 위한 강력한 새로운 기능을 얻고 있다.

00:00:23.000 --> 00:00:28.000
그들은 스위프트 표준 라이브러리의 새로운 유형인 'Regex' 유형으로 시작한다.

00:00:28.000 --> 00:00:36.000
언어에 내장된 Regex 리터럴 구문은 이 강력하고 친숙한 개념을 더욱 일류로 만든다.

00:00:36.000 --> 00:00:40.000
그리고 마지막으로, RegexBuilder라는 결과 빌더 API.

00:00:40.000 --> 00:00:54.000
결과 빌더의 구문적 단순성과 구성성을 활용하고 Regex의 가독성을 완전히 새로운 수준으로 끌어올리는 도메인별 언어 또는 DSL입니다.

00:00:54.000 --> 00:01:04.000
Swift Regex가 문자열을 더 쉽게 처리할 수 있는 이유에 대한 배경을 보려면, 제 동료 Michael의 Meet Swift Regex 세션을 확인하세요.

00:01:04.000 --> 00:01:07.000
Swift Regex의 아주 간단한 예를 살펴봅시다.

00:01:07.000 --> 00:01:14.000
데이터 문자열이 있고, 이 문자열에서 사용자 ID를 일치시키고 추출하고 싶다고 가정해 봅시다.

00:01:14.000 --> 00:01:21.000
나는 보통 'NSRegularExpression'으로 하는 것처럼 텍스트에서 정규 표현식을 만들 수 있다.

00:01:21.000 --> 00:01:35.000
그것은 "user_id" 콜론과 0개 이상의 공백과 하나 이상의 숫자와 일치합니다. 이번에 다른 점은 Regex 유형의 값을 만들고 있다는 것입니다.

00:01:35.000 --> 00:01:39.000
이것은 스위프트 표준 라이브러리의 새로운 유형이다.

00:01:39.000 --> 00:01:50.000
그런 다음 문자열의 'firstMatch' 알고리즘을 사용하여 이 Regex에 의해 정의된 패턴의 첫 번째 발생을 찾고 전체 일치 항목을 인쇄할 수 있습니다.

00:01:50.000 --> 00:02:03.000
내 Regex 문자열은 컴파일 타임에 알려져 있기 때문에, 컴파일러가 구문 오류를 확인하고 Xcode가 구문 강조 표시를 표시할 수 있도록 Regex 리터럴을 사용하도록 전환할 수 있습니다.

00:02:03.000 --> 00:02:09.000
하지만 궁극적인 가독성과 사용자 정의를 위해, 저는 Regex 빌더 DSL을 사용할 수 있습니다.

00:02:09.000 --> 00:02:17.000
Regex 빌더를 사용하면 Regex의 내용을 읽는 것은 네이티브 Swift API를 읽는 것만큼 쉽습니다.

00:02:17.000 --> 00:02:23.000
이 세션에서는 Regex가 어떻게 작동하는지 그리고 워크플로우에 Regex를 어떻게 적용할 수 있는지 보여드리겠습니다.

00:02:23.000 --> 00:02:29.000
Regex는 기본 Regex 엔진에 의해 실행되는 프로그램입니다.

00:02:29.000 --> 00:02:38.000
Regex를 실행할 때, Regex 엔진은 입력 문자열을 취하고, 문자열의 처음부터 끝까지 일치를 수행합니다.

00:02:38.000 --> 00:02:40.000
아주 간단한 Regex를 살펴봅시다.

00:02:40.000 --> 00:02:48.000
이 Regex는 하나 이상의 문자 "a"와 하나 이상의 숫자로 시작하는 문자열과 일치합니다.

00:02:48.000 --> 00:02:56.000
나는 입력 "aaa12"를 일치시키기 위해 매칭 알고리즘 중 하나인 'wholeMatch'를 사용한다.

00:02:56.000 --> 00:03:00.000
Regex 엔진은 입력의 첫 번째 문자부터 시작할 것이다.

00:03:00.000 --> 00:03:04.000
먼저, 그것은 하나 이상의 캐릭터 a와 일치한다.

00:03:04.000 --> 00:03:11.000
이 시점에서, 그것은 캐릭터 "1"에 도달하고 이 캐릭터를 캐릭터 "a"와 일치시키려고 한다.

00:03:11.000 --> 00:03:14.000
하지만 그건 일치하지 않아.

00:03:14.000 --> 00:03:21.000
그래서 Regex 엔진은 하나 이상의 숫자와 일치하도록 Regex의 다음 패턴으로 이동합니다.

00:03:21.000 --> 00:03:25.000
우리가 문자열의 끝에 도달하면, 매칭이 성공한다.

00:03:25.000 --> 00:03:31.000
이 세션의 나머지 부분에서, 나는 이 실행 모델에 대해 조금 더 설명할 것이다.

00:03:31.000 --> 00:03:43.000
Regex가 기본 Regex 엔진에 구축됨에 따라, Regex 빌더 DSL 및 Regex 기반 알고리즘은 Regex의 힘과 표현력을 확장합니다.

00:03:43.000 --> 00:04:05.000
Regex 기반 알고리즘은 문자열에서 Regex의 첫 번째 발생을 찾는 첫 번째 일치와 같은 가장 일반적인 작업 중 일부를 제공하는 컬렉션 기반 API입니다. 'wholeMatch'는 전체 문자열을 Regex와 일치시키고, 문자열의 접두사와 일치하는 'prefixMatch'는 Regex와 일치합니다.

00:04:05.000 --> 00:04:17.000
매칭 외에도, 스위프트 표준 라이브러리는 Regex 기반 예측, 교체, 트리밍 및 분할을 위한 API를 추가했다.

00:04:17.000 --> 00:04:28.000
또한, Regex는 이제 제어 흐름 문에서 Swift의 패턴 매칭 구문에서 사용할 수 있어 그 어느 때보다 쉽게 문자열을 전환할 수 있습니다.

00:04:28.000 --> 00:04:40.000
마지막으로, Regex 빌더와 Regex 기반 알고리즘 위에, 올해 재단은 Regex 빌더와 원활하게 작동하는 자체 Regex 지원을 도입했습니다.

00:04:40.000 --> 00:04:51.000
재단의 Regex 지원은 날짜와 번호와 같이 이미 사용하고 있는 포맷터와 파서에 불과합니다.

00:04:51.000 --> 00:04:59.000
이 API에 대해 더 알고 싶다면, WWDC21의 Foundation 세션의 새로운 기능을 시청하세요.

00:04:59.000 --> 00:05:05.000
올해 재단은 URL 포맷 및 구문 분석에 대한 지원을 추가하고 있다.

00:05:05.000 --> 00:05:12.000
Foundation의 Regex 지원을 통해 Foundation 파서를 Regex 빌더에 직접 삽입할 수 있습니다.

00:05:12.000 --> 00:05:26.000
예를 들어, 이와 같은 은행 명세서를 구문 분석하기 위해, 사용자 지정 형식의 재단 제공 날짜 파서와 도메인별 구문 분석 전략을 가진 통화 파서를 사용할 수 있습니다.

00:05:26.000 --> 00:05:41.000
코너 케이스를 처리하고 현지화를 지원하는 기존 전투 테스트를 거친 파서에서 Regexes를 만들고 Regex 빌더 DSL의 표현력으로 구성할 수 있기 때문에 이것은 정말 큰 일입니다.

00:05:41.000 --> 00:05:47.000
Swift Regex를 워크플로우에 적용하는 방법을 보여주기 위해, 함께 예시를 만들어 봅시다.

00:05:47.000 --> 00:05:53.000
나는 XCTest 기반 단위 테스트를 실행하여 로그를 구문 분석하기 위한 스크립트를 작성하고 있다.

00:05:53.000 --> 00:05:58.000
테스트 로그는 테스트 스위트의 상태로 시작하고 끝납니다.

00:05:58.000 --> 00:06:05.000
그런 다음 XCTest는 모든 테스트 사례를 실행하고 테스트 사례의 상태를 보고합니다.

00:06:05.000 --> 00:06:09.000
오늘은 로그의 첫 번째와 마지막 줄을 구문 분석해 봅시다.

00:06:09.000 --> 00:06:12.000
그것은 테스트 스위트에 대한 정보이다.

00:06:12.000 --> 00:06:16.000
먼저, 저는 RegexBuilder를 가져옵니다.

00:06:16.000 --> 00:06:23.000
RegexBuilder는 RegexBuilder DSL을 제공하는 Swift Standard Library의 새로운 모듈입니다.

00:06:23.000 --> 00:06:30.000
Regex는 Regex의 본문을 나타내는 후행 폐쇄로 초기화될 수 있다.

00:06:30.000 --> 00:06:33.000
로그 메시지 예시를 살펴봅시다.

00:06:33.000 --> 00:06:46.000
이 로그에는 우리가 신경 쓰는 세 가지 변수 부분 문자열이 있습니다; 테스트 스위트의 이름, 상태, 시작, 통과 또는 실패 여부, 그리고 타임스탬프.

00:06:46.000 --> 00:06:54.000
나는 세 개의 변수 부분 문자열을 구문 분석하는 패턴을 생각해내는 동안 이 줄의 다른 부분을 그대로 구문 분석할 수 있다.

00:06:54.000 --> 00:07:02.000
로그 메시지는 "테스트 스위트"라는 단어로 시작하고, 공백과 작은 따옴표가 뒤따른다.

00:07:02.000 --> 00:07:05.000
그런 다음 우리는 테스트 스위트의 이름을 구문 분석합니다.

00:07:05.000 --> 00:07:16.000
이름은 소문자 또는 대문자 또는 숫자를 포함할 수 있는 식별자이지만, 첫 번째 문자는 절대 숫자가 될 수 없습니다.

00:07:16.000 --> 00:07:21.000
그래서 우리는 문자를 첫 번째 문자와 일치시키는 사용자 지정 문자 클래스를 만듭니다.

00:07:21.000 --> 00:07:29.000
그런 다음 나는 0에서 9까지의 문자 또는 숫자인 0개 이상의 문자를 일치시킨다.

00:07:29.000 --> 00:07:34.000
이것은 매우 명확하고 읽기 되지만, 조금 번거롭다.

00:07:34.000 --> 00:07:38.000
여러분 중 많은 사람들이 텍스트 Regex 구문에 익숙할 것입니다.

00:07:38.000 --> 00:07:46.000
RegexBuilder에서, 나는 실제로 간결한 Regex 리터럴을 본문에 직접 포함할 수 있다.

00:07:46.000 --> 00:07:50.000
정규 문자는 슬래시로 시작하고 끝난다.

00:07:50.000 --> 00:07:53.000
스위프트는 그것에 대한 올바른 강한 유형을 추론한다.

00:07:53.000 --> 00:07:59.000
예를 들어, 이 Regex는 "Hello, WWDC!"라는 하위 문자열과 일치합니다.

00:07:59.000 --> 00:08:02.000
그래서 그것의 출력 유형은 부분 문자열이다.

00:08:02.000 --> 00:08:09.000
하지만 일류 Regex 리터럴의 정말 멋진 점은 강하게 타이핑된 캡처 그룹이다.

00:08:09.000 --> 00:08:15.000
예를 들어, 나는 연도로 두 자리 숫자를 캡처하기 위해 캡처 그룹을 작성할 수 있다.

00:08:15.000 --> 00:08:19.000
그리고 이 포획 그룹에 "년"이라는 이름을 지어주세요.

00:08:19.000 --> 00:08:24.000
내가 이것을 할 때, 다른 부분 문자열이 출력 유형에 나타날 것이다.

00:08:24.000 --> 00:08:30.000
이 이야기의 뒷부분에서, 캡처를 사용하여 문자열에서 정보를 추출하는 방법을 보여드리겠습니다.

00:08:30.000 --> 00:08:41.000
표준 Regex 리터럴 외에도, Swift는 파운드 슬래시로 시작하여 슬래시 파운드로 끝나는 확장 Regex 리터럴을 지원합니다.

00:08:41.000 --> 00:08:46.000
확장된 리터럴은 의미 없는 공백을 허용한다.

00:08:46.000 --> 00:08:51.000
이 모드에서는 패턴을 여러 줄로 나눌 수 있습니다.

00:08:51.000 --> 00:08:57.000
RegexBuilder에 Regex 리터럴이 내장되어 있어, 깨끗하면서도 친숙하다.

00:08:57.000 --> 00:09:03.000
테스트 이름을 구문 분석한 후, 단일 따옴표와 공백을 구문 분석합니다.

00:09:03.000 --> 00:09:05.000
이제 나는 시험 상태에 도달했다.

00:09:05.000 --> 00:09:11.000
여러 유형의 테스트 상태가 있습니다: 시작, 실패, 통과.

00:09:11.000 --> 00:09:16.000
이러한 옵션 중 하나를 일치시키기 위해, 우리는 'ChoiceOf'를 사용합니다.

00:09:16.000 --> 00:09:22.000
'ChoiceOf'는 여러 하위 패턴 중 하나와 일치하며 정확히 우리가 필요로 하는 것이다.

00:09:22.000 --> 00:09:32.000
다음으로 우리는 상태 직후에 오는 것, 공백 다음에 "at" 다음에 공백을 구문 분석합니다.

00:09:32.000 --> 00:09:34.000
문자열의 나머지 부분은 타임스탬프이다.

00:09:34.000 --> 00:09:39.000
우리는 이것을 하나 이상의 캐릭터로 일치시킬 수 있다.

00:09:39.000 --> 00:09:45.000
하지만 몇 가지 예를 더 살펴보면, 로그 메시지는 때때로 마침표로 끝납니다.

00:09:45.000 --> 00:09:51.000
우리는 여전히 그것이 존재하는 기간과 일치하도록 '선택적으로'를 사용하고 싶습니다.

00:09:51.000 --> 00:09:56.000
Regex와 입력을 일치시키려면, 제공된 매칭 알고리즘 중 하나를 사용하세요.

00:09:56.000 --> 00:10:02.000
전체 문자열을 Regex와 일치시키는 'wholeMatch'를 사용합시다.

00:10:02.000 --> 00:10:08.000
'wholeMatch'로, 나는 이 각각의 로그 메시지를 일치시키고, 일치하는 콘텐츠를 인쇄한다.

00:10:08.000 --> 00:10:10.000
그건 일치했어!

00:10:10.000 --> 00:10:13.000
하지만 우리는 그것이 문자열과 일치하는지 알고 싶지 않다.

00:10:13.000 --> 00:10:21.000
우리는 또한 테스트 이름, 상태 및 타임스탬프와 같은 우리가 신경 쓰는 정보를 추출하고 싶습니다.

00:10:21.000 --> 00:10:26.000
그러니 Regex의 가장 멋진 기능 중 하나인 Captures로 이것을 합시다!

00:10:26.000 --> 00:10:30.000
캡처는 매칭하는 동안 입력의 일부를 저장합니다.

00:10:30.000 --> 00:10:38.000
RegexBuilder에서 "캡처"와 Regex 구문에서 한 쌍의 괄호로 사용할 수 있습니다.

00:10:38.000 --> 00:10:44.000
캡처는 일치하는 하위 문자열을 출력 튜플 유형에 추가합니다.

00:10:44.000 --> 00:10:55.000
출력 튜플 유형은 전체 Regex와 일치하는 전체 부분 문자열로 시작하여 첫 번째 캡처, 두 번째 캡처 등입니다.

00:10:55.000 --> 00:11:03.000
매칭 알고리즘은 출력 튜플을 얻을 수 있는 Regex Match를 반환합니다.

00:11:03.000 --> 00:11:09.000
전체 경기, 첫 번째 캡처, 그리고 두 번째 캡처.

00:11:09.000 --> 00:11:14.000
테스트 스위트 로그 Regex에서 캡처를 사용하겠습니다.

00:11:14.000 --> 00:11:21.000
나는 테스트 스위트의 이름, 상태 및 타임스탬프를 포착한다.

00:11:21.000 --> 00:11:27.000
몇 가지 입력에서 이 Regex를 다시 실행하고, 우리가 캡처한 세 가지를 인쇄합시다.

00:11:27.000 --> 00:11:30.000
그건 성공적인 경기처럼 보여!

00:11:30.000 --> 00:11:36.000
그것은 이름, 상태, 그리고 타임스탬프를 인쇄했다.

00:11:36.000 --> 00:11:40.000
하지만 내가 자세히 살펴보면, 날짜의 무언가가 조금 어울린다.

00:11:40.000 --> 00:11:45.000
그것은 캡처의 일부로 입력에 기간을 포함했다.

00:11:45.000 --> 00:11:49.000
그래서 내가 돌아가서 Regex에 오류가 있는지 확인해 볼게.

00:11:49.000 --> 00:11:53.000
나는 타임스탬프 Regex에 집중하고 무엇이 잘못되었는지 보고 싶다.

00:11:53.000 --> 00:12:04.000
그런 다음 나는 "하나 이상의 문자" 패턴이 타임스탬프의 첫 번째 숫자부터 줄 끝까지 모든 것을 소비한다는 것을 깨달았다.

00:12:04.000 --> 00:12:09.000
그래서 그 아래의 "선택적 기간" 패턴은 결코 일치하지 않았다.

00:12:09.000 --> 00:12:14.000
나는 이것을 OneOrMore 꺼려하게 만들어서 이것을 고칠 수 있다.

00:12:14.000 --> 00:12:18.000
" 꺼리는"은 반복적인 행동의 경우이다.

00:12:18.000 --> 00:12:25.000
하나 이상, 0 이상, 선택적으로, 그리고 반복은 Swift Regex가 반복이라고 부르는 것이다.

00:12:25.000 --> 00:12:29.000
반복은 기본적으로 열망한다.

00:12:29.000 --> 00:12:32.000
그것은 가능한 한 많은 사건과 일치한다.

00:12:32.000 --> 00:12:35.000
이전 예시를 사용하겠습니다.

00:12:35.000 --> 00:12:48.000
Regex 엔진이 모든 문자의 OneOrMore를 열심히 일치시키려고 할 때, 첫 번째 문자로 시작하고, 입력이 끝날 때까지 모든 문자를 받아들인다.

00:12:48.000 --> 00:12:53.000
그런 다음 Regex 엔진은 선택적으로 주기와 일치하도록 움직인다.

00:12:53.000 --> 00:12:59.000
더 이상 일치할 기간은 없지만, 어쨌든 선택 사항이므로 성공합니다.

00:12:59.000 --> 00:13:08.000
우리는 'wholeMatch' 알고리즘을 실행하고 있고, 입력과 Regex 패턴이 모두 끝에 도달하기 때문에, 매칭은 성공한다.

00:13:08.000 --> 00:13:18.000
매칭은 성공했지만, 그 기간은 이미 OneOrMore의 일부로 예기치 않게 포착되었다.

00:13:18.000 --> 00:13:26.000
우리가 반복 행동을 꺼리는 것으로 바꿀 때, Regex 엔진은 반복과 약간 다르게 일치한다.

00:13:26.000 --> 00:13:30.000
그것은 가능한 한 적은 수의 문자와 일치한다.

00:13:30.000 --> 00:13:44.000
따라서 Regex 엔진이 이번에 입력 문자열과 일치할 때, 반복 발생을 소비하기 전에 항상 Regex의 나머지 부분과 먼저 일치하려고 노력함으로써 조심스럽게 앞으로 나아갑니다.

00:13:44.000 --> 00:13:53.000
Regex의 나머지 부분이 일치하지 않을 때, 엔진은 반복으로 되돌아가며 추가 발생을 소비한다.

00:13:53.000 --> 00:13:57.000
마지막 캐릭터인 마침표로 빨리 감기합시다.

00:13:57.000 --> 00:14:08.000
열렬한 행동과 달리, Regex 엔진은 처음에 OneOrMore의 일부로 기간을 소비하지 않았지만, 대신 "선택적으로 기간" 패턴과 일치하려고 시도한다.

00:14:08.000 --> 00:14:13.000
이것은 일치하고, Regex 엔진은 패턴의 끝에 도달한다.

00:14:13.000 --> 00:14:21.000
그래서 매칭은 성공하고, 후행 기간 없이 올바른 캡처를 생성합니다.

00:14:21.000 --> 00:14:30.000
열망이 기본 행동이기 때문에, 반복을 사용하여 Regex를 만들 때, 의도한 일치에 미치는 영향에 대해 생각해야 합니다.

00:14:30.000 --> 00:14:45.000
추가 인수를 전달하여 반복당 수준에서 행동을 지정하거나, 'repetitionBehavior' 수정자를 사용하여 행동을 지정하지 않은 모든 반복에 대해 재정의할 수 있습니다.

00:14:45.000 --> 00:14:58.000
타임스탬프가 꺼리기 위해 반복 동작을 수정했기 때문에, 매칭은 이제 마침표를 포함하지 않고 올바른 타임스탬프를 추출합니다.

00:14:58.000 --> 00:15:01.000
Regex로 돌아가자.

00:15:01.000 --> 00:15:08.000
캡처를 사용하여 입력에서 테스트 상태를 추출할 때, 그 유형은 Substring입니다.

00:15:08.000 --> 00:15:16.000
하지만 하위 문자열을 사용자 지정 데이터 구조와 같이 더 프로그래밍 친화적인 것으로 변환할 수 있다면 훨씬 더 좋을 것이다.

00:15:16.000 --> 00:15:19.000
이것을 하기 위해, 나는 변형 캡처를 사용할 수 있다.

00:15:19.000 --> 00:15:25.000
변형 캡처는 변형 폐쇄가 있는 캡처이다.

00:15:25.000 --> 00:15:36.000
일치하면, Regex 엔진은 일치하는 부분 문자열의 변환 클로저를 호출하여 원하는 유형의 결과를 생성합니다.

00:15:36.000 --> 00:15:41.000
해당 Regex 출력 유형은 클로저의 반환 유형이 됩니다.

00:15:41.000 --> 00:15:50.000
여기서, 문자열에서 Int의 이니셜라이저로 캡처를 변환함으로써, 출력 튜플 유형에서 선택적 Int를 얻을 수 있습니다.

00:15:50.000 --> 00:15:55.000
선택 사항이 아닌 출력을 얻으려면, TryCapture가 도움이 될 수 있습니다.

00:15:55.000 --> 00:16:05.000
TryCapture는 선택 사항을 반환하고 출력 유형의 선택 사항을 제거하는 변환을 받아들이는 Capture의 변형입니다.

00:16:05.000 --> 00:16:13.000
매칭 중에 nil을 반환하면 Regex 엔진이 역추적하고 다른 경로를 시도하게 될 것이다.

00:16:13.000 --> 00:16:20.000
TryCapture는 실패 가능한 이니셜라이저로 캡처를 변환할 때 가장 유용합니다.

00:16:20.000 --> 00:16:25.000
캡처된 테스트 상태를 저장하기 위한 자연스러운 적합성은 열거일 것이다.

00:16:25.000 --> 00:16:28.000
그러니 하나를 정의해 봅시다.

00:16:28.000 --> 00:16:34.000
나는 세 가지 사례로 TestStatus 열거형을 정의했다: 시작, 통과, 실패.

00:16:34.000 --> 00:16:40.000
원시 문자열 값은 이 열거형을 문자열에서 초기화할 수 있게 한다.

00:16:40.000 --> 00:16:44.000
Regex에서, 나는 변환으로 'TryCapture'로 전환한다.

00:16:44.000 --> 00:16:53.000
변환 클로저에서, 나는 일치하는 부분 문자열을 TestStatus 값으로 변환하기 위해 TestStatus 이니셜라이저를 호출한다.

00:16:53.000 --> 00:16:57.000
이제 해당 출력 유형은 TestStatus입니다.

00:16:57.000 --> 00:17:03.000
이와 같은 사용자 지정 데이터 구조를 사용하면 Regex 일치 출력 유형이 안전합니다.

00:17:03.000 --> 00:17:04.000
Regex로 돌아가.

00:17:04.000 --> 00:17:08.000
내가 하고 싶은 개선 사항이 하나 더 있다.

00:17:08.000 --> 00:17:12.000
현재, 나는 와일드카드 패턴을 사용하여 타임스탬프를 일치시킨다.

00:17:12.000 --> 00:17:15.000
그것은 부분 문자열을 생산할 것이다.

00:17:15.000 --> 00:17:24.000
이것은 내 앱이 타임스탬프를 이해하고 싶다면, 부분 문자열을 다른 데이터 구조로 다시 구문 분석해야 한다는 것을 의미한다.

00:17:24.000 --> 00:17:33.000
세션 초반에, 나는 재단이 이제 Swift Regex를 지원하며, 업계 강도의 파서를 Regexes로 제공한다고 언급했다.

00:17:33.000 --> 00:17:45.000
따라서 날짜를 하위 문자열로 구문 분석하는 대신, 타임스탬프를 날짜로 구문 분석하기 위해 재단의 ISO 8601 날짜 파서로 전환할 수 있습니다.

00:17:45.000 --> 00:17:50.000
이제 추론된 유형은 이 Regex가 날짜를 출력한다는 것을 보여준다.

00:17:50.000 --> 00:17:58.000
입력에서 'wholeMatch'를 실행할 때, 날짜 문자열이 Foundation Date 값으로 구문 분석된 것을 볼 수 있습니다.

00:17:58.000 --> 00:18:07.000
Foundation 날짜 파서와 같은 Regex로 전투 테스트를 거친 파서에 액세스하는 것은 일상적인 문자열 처리 작업에서 매우 편리합니다.

00:18:07.000 --> 00:18:16.000
다음으로, Swift Regex의 다른 곳에서 정의된 기존 파서를 재사용하는 고급 기능을 보여드리겠습니다.

00:18:16.000 --> 00:18:20.000
테스트 케이스의 지속 시간을 구문 분석하고 싶은 예를 살펴봅시다.

00:18:20.000 --> 00:18:26.000
지속 시간은 0.001과 같은 부동 소수점이다.

00:18:26.000 --> 00:18:34.000
물론, 이것을 하는 가장 좋은 방법은 현지화를 완벽하게 지원하는 재단이 제공하는 부동 소수점 파서를 사용하는 것이다.

00:18:34.000 --> 00:18:46.000
하지만 오늘, 저는 후드 아래에 무엇이 있는지, 그리고 기존 파서를 활용하여 기간 부동 소수점 숫자를 구문 분석하기 위해 Regex 엔진에 직접 연결할 수 있는 방법을 보여주고 싶습니다.

00:18:46.000 --> 00:18:51.000
'Strtod'는 C 표준 라이브러리의 함수이다.

00:18:51.000 --> 00:19:00.000
문자열 포인터를 취하고, 기본 문자열을 구문 분석하고, 일치의 끝 위치를 끝 포인터에 할당합니다.

00:19:00.000 --> 00:19:03.000
기간, C 방식을 구문 분석해 봅시다.

00:19:03.000 --> 00:19:12.000
이렇게 하기 위해, 나는 파서 유형을 직접 정의하고 CustomConsumingRegexComponent 프로토콜을 준수하도록 할 수 있다.

00:19:12.000 --> 00:19:16.000
나는 CDoubleParser라는 구조를 정의한다.

00:19:16.000 --> 00:19:22.000
그것의 'RegexOutput'은 Double이다, 왜냐하면 우리는 Double 숫자를 구문 분석하고 있기 때문이다.

00:19:22.000 --> 00:19:33.000
"소중" 방법에서, 우리는 C 표준 라이브러리에서 이중 파서를 호출하고, 문자열 포인터를 전달하고, 숫자를 다시 받는다.

00:19:33.000 --> 00:19:41.000
메소드 본문에서, 나는 시작 주소를 얻기 위해 withCString 메소드를 사용한다.

00:19:41.000 --> 00:19:49.000
그런 다음 'strtod' C 함수를 호출하여 시작 주소와 포인터를 전달하여 결과 끝 주소를 수신합니다.

00:19:49.000 --> 00:19:51.000
그리고 나서 나는 오류를 확인한다.

00:19:51.000 --> 00:19:57.000
구문 분석이 성공하면, 끝 주소가 시작 주소보다 크다.

00:19:57.000 --> 00:20:01.000
그렇지 않으면, 그것은 구문 분석 실패이므로, 나는 nil을 반환한다.

00:20:01.000 --> 00:20:07.000
나는 C API에 의해 생성된 포인터에서 일치의 상한을 계산한다.

00:20:07.000 --> 00:20:12.000
그리고 마지막으로, 나는 일치의 상한과 숫자 출력을 반환한다.

00:20:12.000 --> 00:20:19.000
Regex로 돌아가서 Regex에서 직접 'CDoubleParser'를 사용할 수 있습니다.

00:20:19.000 --> 00:20:23.000
출력 유형은 Double으로 추론된다.

00:20:23.000 --> 00:20:30.000
내가 'wholeMatch'를 호출하고 구문 분석된 번호를 인쇄할 때, 내가 예상했던 것처럼 0.001을 출력한다.

00:20:30.000 --> 00:20:42.000
요약하자면, 오늘 우리는 앱에 문자열 처리의 힘을 통합할 수 있는 Swift 5.7의 새로운 기능인 Swift Regex의 일반적이고 고급 사용에 대해 이야기했습니다.

00:20:42.000 --> 00:20:53.000
Swift Regex를 사용할 때 좋은 방법은 특히 RegexBuilder DSL과 Regex 리터럴을 혼합할 때 간결함과 가독성 사이의 균형을 맞추는 것입니다.

00:20:53.000 --> 00:21:07.000
날짜와 URL과 같은 일반적인 패턴을 접할 때, 사용자 지정 코드로 이러한 패턴을 구문 분석하는 것은 오류가 발생하기 쉽기 때문에 항상 재단에서 제공하는 업계 수준의 파서를 선호하십시오.

00:21:07.000 --> 00:21:14.000
Swift Regex에 대한 자세한 내용은 Swift Evolution에 대한 일련의 선언적 문자열 처리 제안을 확인하세요.

00:21:14.000 --> 00:21:18.000
스위프트로 문자열을 처리하는 것을 즐기시기 바랍니다.

00:21:18.000 --> 23:59:59.000
고마워, 그리고 멋진 WWDC 보내.

