WEBVTT

00:00:01.000 --> 00:00:11.000
- 안녕! 내 이름은 안드레이야.

00:00:11.000 --> 00:00:15.000
저는 메탈 프레임워크 팀의 GPU 소프트웨어 엔지니어입니다.

00:00:15.000 --> 00:00:19.000
오늘, 저는 당신에게 메탈 메쉬 셰이더를 소개하게 되어 기쁩니다.

00:00:19.000 --> 00:00:26.000
메쉬 셰이더는 GPU 기반 지오메트리 생성 및 처리를 위한 금속의 새로운 유연한 파이프라인이다.

00:00:26.000 --> 00:00:35.000
그것은 정점/조각 파이프라인을 개선하여 많은 유연성을 추가하고 정점당 처리의 한계를 제거합니다.

00:00:35.000 --> 00:00:52.000
그것은 여러 응용 프로그램을 가지고 있지만, 이에 국한되지는 않습니다: 세밀한 지오메트리 컬링, GPU에서 확장 가능한 절차 지오메트리 생성, 압축된 정점 스트림, 메쉬릿 및 복잡한 절차 알고리즘과 같은 사용자 지정 지오메트리 입력을 허용합니다.

00:00:52.000 --> 00:00:55.000
나는 오늘 이 세 가지를 다루고 싶다.

00:00:55.000 --> 00:00:59.000
먼저, 나는 금속 메쉬 셰이더가 무엇인지 살펴볼 것이다.

00:00:59.000 --> 00:01:03.000
그럼, 두 개의 메쉬 셰이더 사용 사례에 대해 말씀드리고 싶습니다.

00:01:03.000 --> 00:01:09.000
메쉬 셰이더는 절차적 머리카락을 렌더링하는 것과 같은 절차적 형상을 생성하는 데 좋습니다.

00:01:09.000 --> 00:01:13.000
메쉬 셰이더는 또한 장면 처리와 렌더링을 개선하는 데 도움을 준다.

00:01:13.000 --> 00:01:19.000
이것의 주요 예는 메쉬 셰이더를 사용하여 GPU 기반 메쉬 컬링을 구현하는 것이다.

00:01:19.000 --> 00:01:21.000
메쉬 셰이더를 소개하는 것부터 시작합시다.

00:01:21.000 --> 00:01:27.000
여기 GPU에서 렌더링할 수 있는 전형적인 메쉬를 나타내는 스탠포드 버니가 있습니다.

00:01:27.000 --> 00:01:34.000
이 메쉬를 렌더링하려면, 정점과 인덱스 데이터를 먼저 장치 메모리에 배치해야 합니다.

00:01:34.000 --> 00:01:39.000
그런 다음 그리기 호출을 실행하려면 렌더링 명령 인코더를 사용해야 합니다.

00:01:39.000 --> 00:01:52.000
전통적인 렌더링 파이프라인은 세 가지 기본 단계로 구성되어 있다: 프로그래밍 가능한 정점 셰이더 단계, 고정 함수 래스터화 단계, 프로그래밍 가능한 조각 셰이더 단계.

00:01:52.000 --> 00:01:57.000
버텍스 셰이더 단계는 장치 메모리의 지오메트리를 입력으로 받아 처리할 것이다.

00:01:57.000 --> 00:02:04.000
래스터라이저는 화면 공간 조각을 생성하고, 조각 셰이더는 최종 이미지를 생성하기 위해 음영 처리합니다.

00:02:04.000 --> 00:02:08.000
이 파이프라인은 그 목적을 매우 잘 해왔고, 지금도 하고 있다.

00:02:08.000 --> 00:02:13.000
그러나, 그것은 유연성이 부족하고 특정한 한계가 있다.

00:02:13.000 --> 00:02:15.000
예를 들어 봅시다.

00:02:15.000 --> 00:02:19.000
GPU에서 절차적 지오메트리를 생성하고 싶다고 상상해 보세요.

00:02:19.000 --> 00:02:25.000
예를 들어, 당신은 이 토끼에게 절차적 모피를 추가하기로 결정했습니다.

00:02:25.000 --> 00:02:30.000
이 작업이 전통적인 기하학 파이프라인에 의해 어떻게 처리되는지 보여드리겠습니다.

00:02:30.000 --> 00:02:40.000
전통적으로, 절차적 지오메트리를 생성하려면, 컴퓨팅 커널 디스패치를 수행하는 컴퓨팅 명령 인코더가 있어야 합니다.

00:02:40.000 --> 00:02:49.000
컴퓨팅 커널은 원래 메쉬를 입력으로 받아 절차적 형상을 생성하고 장치 메모리로 다시 출력할 것이다.

00:02:49.000 --> 00:02:57.000
그런 다음 렌더링 명령 인코더를 사용하여 절차적 지오메트리를 입력으로 사용하고 최종 이미지를 생성하는 그리기 호출을 실행할 것입니다.

00:02:57.000 --> 00:03:05.000
이 접근 방식은 두 개의 명령 인코더가 필요할 뿐만 아니라, 절차 지오메트리를 저장하기 위해 추가 메모리를 할당해야 합니다.

00:03:05.000 --> 00:03:13.000
간접적인 무승부 호출이나 높은 확장 인자의 경우, 이 메모리의 양은 꽤 높고 예측하기 어려울 수 있다.

00:03:13.000 --> 00:03:18.000
또한 두 인코더 사이에는 GPU에서 작업을 직렬화하는 장벽이 있다.

00:03:18.000 --> 00:03:21.000
금속 메쉬 셰이더는 이러한 모든 문제를 해결합니다.

00:03:21.000 --> 00:03:32.000
메쉬 셰이더는 버텍스 셰이더 단계를 두 개의 새로운 프로그래밍 가능한 단계인 오브젝트 셰이더 단계와 메쉬 셰이더 단계로 대체하는 새로운 지오메트리 파이프라인입니다.

00:03:32.000 --> 00:03:41.000
이 예에서, 객체 셰이더는 지오메트리를 입력으로 받아들이고, 처리하고, 우리가 "페이로드"라고 부르는 일부 데이터를 메쉬 셰이더에 출력합니다.

00:03:41.000 --> 00:03:45.000
이 데이터가 무엇인지 결정하는 것은 당신에게 달려 있습니다.

00:03:45.000 --> 00:03:50.000
메쉬 셰이더는 차례로 이 데이터를 사용하여 절차적 기하학을 생성할 것이다.

00:03:50.000 --> 00:03:58.000
이 절차적 지오메트리는 드로우 호출 내부에만 존재하므로 장치 메모리를 할당할 필요가 없습니다.

00:03:58.000 --> 00:04:06.000
그것은 래스터라이저로 바로 파이프라인된 다음 최종 이미지를 생성할 조각 셰이더로 파이프라인될 것이다.

00:04:06.000 --> 00:04:12.000
메쉬 드로우 호출은 전통적인 드로우 호출과 동일한 유형의 렌더링 명령 인코더를 사용하여 수행됩니다.

00:04:12.000 --> 00:04:16.000
메쉬 드로우 호출과 전통적인 드로우 호출은 혼합되고 일치할 수 있다.

00:04:16.000 --> 00:04:22.000
이제, 두 개의 새로운 프로그래밍 가능한 단계를 살펴봅시다.

00:04:22.000 --> 00:04:27.000
정점 셰이더와 달리, 객체와 메쉬 셰이더는 컴퓨팅 커널과 유사하다.

00:04:27.000 --> 00:04:30.000
그것들은 스레드 그룹의 그리드에서 발사된다.

00:04:30.000 --> 00:04:37.000
각 스레드 그룹은 컴퓨팅 스레드와 같이 서로 통신할 수 있는 개별 스레드의 그리드입니다.

00:04:37.000 --> 00:04:48.000
또한, 각 개체 스레드 그룹은 메쉬 그리드를 생성하고 프로그래밍 방식으로 시작하는 메쉬 그리드의 크기를 정의하여 충분한 유연성을 제공합니다.

00:04:48.000 --> 00:04:53.000
각 객체 스레드 그룹은 페이로드 데이터를 생성되는 메쉬 그리드로 전달합니다.

00:04:53.000 --> 00:04:57.000
이름에서 알 수 있듯이, 물체 단계는 물체를 처리한다.

00:04:57.000 --> 00:05:01.000
객체는 당신의 필요에 따라 정의할 수 있는 추상적인 개념이다.

00:05:01.000 --> 00:05:09.000
그것은 장면 모델, 장면 모델의 일부 또는, 예를 들어 절차적 기하학을 생성하려는 공간 영역이 될 수 있습니다.

00:05:09.000 --> 00:05:15.000
메쉬 스테이지는 메쉬를 구축하고 지오메트리 데이터를 래스터라이저로 직접 보내도록 설계되었습니다.

00:05:15.000 --> 00:05:20.000
다음 두 가지 예는 물체와 메쉬 사이의 관계를 다룰 것이다.

00:05:20.000 --> 00:05:23.000
첫 번째는 메쉬 셰이더를 사용하여 헤어 렌더링을 구현하는 것이다.

00:05:23.000 --> 00:05:28.000
이 작업을 단순화하기 위해, 나는 버니 모델 대신 간단한 비행기를 사용할 것이다.

00:05:28.000 --> 00:05:41.000
머리카락 패치를 생성하기 위해, 나는 입력 지오메트리를 타일로 나눌 것이며, 여기서 각 타일은 세부 수준과 생산해야 하는 가닥의 수를 계산한 다음, 각 개별 머리카락 가닥을 생성할 것이다.

00:05:41.000 --> 00:05:46.000
메쉬 셰이더를 사용하여 이 비행기에서 절차적으로 머리카락을 생성하는 방법을 보여드리겠습니다.

00:05:46.000 --> 00:05:52.000
평면은 각 타일이 객체 스레드 그룹에 해당하는 타일로 나눌 수 있다.

00:05:52.000 --> 00:05:59.000
각 개체 스레드 그룹은 머리카락 가닥의 수를 계산하고 각 가닥에 대한 곡선 제어점을 생성합니다.

00:05:59.000 --> 00:06:01.000
이것은 페이로드가 될 것이다.

00:06:01.000 --> 00:06:08.000
그런 다음 우리의 객체 스레드 그룹은 각 메쉬 스레드 그룹이 머리카락 한 가닥을 나타내는 메쉬 그리드를 시작합니다.

00:06:08.000 --> 00:06:11.000
각 메쉬 스레드 그룹은 메쉬를 래스터라이저로 출력합니다.

00:06:11.000 --> 00:06:21.000
새로운 지오메트리 파이프라인을 사용하면 지오메트리 처리를 하드웨어와 밀접하게 매핑할 수 있으며 GPU가 제공하는 모든 스레드를 최대한 활용할 수 있습니다.

00:06:21.000 --> 00:06:27.000
메쉬 렌더링 파이프라인에서, 입력 지오메트리는 오브젝트 셰이더 그리드의 타일로 나뉩니다.

00:06:27.000 --> 00:06:33.000
각 객체 셰이더 스레드 그룹은 독립적으로 페이로드를 생성하고 메쉬 그리드를 실행할 수 있습니다.

00:06:33.000 --> 00:06:41.000
그리드의 각 메쉬 셰이더 스레드 그룹은 렌더링 파이프라인의 나머지 부분에서 추가로 처리되는 금속::mesh를 생성합니다.

00:06:41.000 --> 00:06:46.000
각 단계에서 생성된 데이터를 자세히 살펴봅시다.

00:06:46.000 --> 00:06:48.000
페이로드는 객체 셰이더에 정의되어 있다.

00:06:48.000 --> 00:06:55.000
각 개체 스레드 그룹은 사용자 지정 페이로드를 개체 스레드 그룹이 생성하는 생성된 메쉬 그리드로 전달합니다.

00:06:55.000 --> 00:07:00.000
헤어 렌더링의 경우, 페이로드는 곡선 제어점으로 구성되어 있다.

00:07:00.000 --> 00:07:09.000
한편, 메쉬 셰이더는 새로운 금속::메쉬 유형을 통해 정점과 원시 데이터를 출력하며, 조금 더 자세히 논의할 것입니다.

00:07:09.000 --> 00:07:15.000
객체와 메쉬 스테이지는 나머지 파이프라인에서 소비되는 메쉬 데이터를 출력한다.

00:07:15.000 --> 00:07:25.000
전통적인 파이프라인의 정점 출력과 유사하게, 메쉬 데이터는 먼저 래스터라이저에 의해 소비된 다음, 프래그먼트 셰이더가 실행된다.

00:07:25.000 --> 00:07:30.000
헤어 렌더링 메쉬 파이프라인을 설정하는 방법에 대해 더 자세히 알아봅시다.

00:07:30.000 --> 00:07:38.000
첫째, 머리카락으로 덮일 비행기는 타일로 나뉘며, 각 타일은 물체 스레드 그룹에 해당한다.

00:07:38.000 --> 00:07:45.000
객체 스레드 그룹은 메쉬 그리드 크기를 결정하고 메쉬 그리드로 전달하는 페이로드 데이터를 초기화합니다.

00:07:45.000 --> 00:07:54.000
이 경우, 타일은 여섯 가닥의 머리카락을 가지고 있으며 각 가닥에 대한 곡선 페이로드 데이터와 함께 3x2 메쉬 그리드를 생성합니다.

00:07:54.000 --> 00:07:57.000
각 스레드 그룹은 고유한 메쉬 그리드 크기를 생성할 수 있습니다.

00:07:57.000 --> 00:08:07.000
다음 스레드 그룹의 경우, 네 가닥의 머리카락만 생성해야 하므로, 4 가닥에 대한 곡선 페이로드 데이터를 초기화하는 것과 함께 2x2 메쉬 그리드가 설정됩니다.

00:08:07.000 --> 00:08:11.000
이것이 이 접근 방식을 구현하는 객체 셰이더의 모습이다.

00:08:11.000 --> 00:08:17.000
객체 속성은 어떤 코드가 객체 셰이더인지 지정하기 위해 Metal에 추가되었습니다.

00:08:17.000 --> 00:08:26.000
페이로드 속성과 object_data 주소 공간 외에도 셰이더에서 페이로드 인수를 사용할 수 있습니다.

00:08:26.000 --> 00:08:31.000
메쉬 그리드 속성 인수는 메쉬 그리드 크기를 인코딩하는 데 사용됩니다.

00:08:31.000 --> 00:08:34.000
다음 단계는 파이프라인 초기화이다.

00:08:34.000 --> 00:08:47.000
먼저, 메쉬 렌더링 파이프라인 설명자를 할당한 다음, 객체 함수를 초기화하고 스레드 그룹당 최대 스레드 수와 함께 원하는 페이로드 길이를 지정하십시오.

00:08:47.000 --> 00:08:50.000
객체 셰이더에는 특정 제약이 있다.

00:08:50.000 --> 00:08:54.000
페이로드 형식과 내용은 완전히 사용자 정의할 수 있습니다.

00:08:54.000 --> 00:08:58.000
그러나, 페이로드 크기는 16킬로바이트의 한도를 초과할 수 없다.

00:08:58.000 --> 00:09:06.000
또한, 각 객체 스레드 그룹이 생성하는 메쉬 스레드 그룹의 최대 수는 1024개를 초과할 수 없습니다.

00:09:06.000 --> 00:09:11.000
오브젝트 셰이더 단계를 준비한 다음 단계는 메쉬 셰이더 단계를 초기화하는 것입니다.

00:09:11.000 --> 00:09:15.000
메쉬 셰이더는 사용자가 입력으로 정의한 페이로드를 가지고 있다.

00:09:15.000 --> 00:09:19.000
이 예에서, 페이로드는 곡선 제어점의 집합이다.

00:09:19.000 --> 00:09:25.000
각 메쉬 스레드 그룹은 머리카락의 한 가닥인 금속::메시를 생산한다.

00:09:25.000 --> 00:09:29.000
메쉬 셰이더의 출력 메쉬에는 금속::메시 유형이 있어야 합니다.

00:09:29.000 --> 00:09:38.000
메탈::메쉬는 래스터라이저와 프래그먼트 셰이더에 정점과 원시 데이터를 출력할 수 있는 인터페이스를 제공하는 메탈의 내장 구조입니다.

00:09:38.000 --> 00:09:57.000
각 금속::mesh는 정점 셰이더의 출력 유형, 원시 데이터 유형, 최대 정점 수, 최대 원시 수, 그리고 마지막으로 메쉬 토폴로지(점, 선 또는 삼각형)와 마찬가지로 정점 데이터 유형을 정의합니다.

00:09:57.000 --> 00:10:04.000
메쉬 속성은 어떤 코드가 메쉬 셰이더인지 지정하기 위해 메탈 셰이딩 언어에 추가되었습니다.

00:10:04.000 --> 00:10:09.000
금속::메시는 메쉬 셰이더의 출력 구조로 사용됩니다.

00:10:09.000 --> 00:10:18.000
메쉬 셰이더는 래스터라이저가 소비할 수 있는 이러한 금속::메시를 즉시 생산할 수 있기 때문에 GPU 기반 형상 처리에 적합합니다.

00:10:18.000 --> 00:10:27.000
메쉬 셰이더는 금속::mesh를 활용하므로 추가 컴퓨팅 패스 없이 렌더링 명령에 더 많은 처리를 할 수 있습니다.

00:10:27.000 --> 00:10:31.000
메쉬 인코딩은 동일한 스레드 그룹 내의 스레드에서 수행됩니다.

00:10:31.000 --> 00:10:39.000
이 예에서, 스레드 그룹의 처음 9개의 스레드는 이 머리 가닥의 정점, 인덱스 및 원시 데이터를 인코딩할 것이다.

00:10:39.000 --> 00:10:45.000
0부터 4까지의 스레드는 각각 메쉬에서 하나의 정점을 인코딩합니다.

00:10:45.000 --> 00:10:50.000
스레드 그룹의 나머지 스레드는 메쉬의 정점을 인코딩하지 않습니다.

00:10:50.000 --> 00:10:57.000
다음으로, 9개의 스레드는 모두 하나의 인덱스를 메쉬 인덱스로 인코딩합니다.

00:10:57.000 --> 00:11:03.000
다음으로, 처음 세 개의 스레드는 세 개의 삼각형에 대한 원시 데이터를 인코딩한다.

00:11:03.000 --> 00:11:07.000
나머지 스레드는 원시 데이터를 인코딩하지 않습니다.

00:11:07.000 --> 00:11:12.000
그리고 마지막으로, 하나의 실은 금속::mesh의 원시 카운트를 인코딩해야 한다.

00:11:12.000 --> 00:11:16.000
이 메쉬 셰이더의 소스 코드를 보여드리겠습니다.

00:11:16.000 --> 00:11:30.000
메쉬 셰이더는 가능한 한 많은 스레드의 발산을 피하기 위해 구성되어 있습니다. 정점, 인덱스 및 원시 데이터, 그리고 마지막으로 원시 카운트를 인코딩하는 동일한 단계를 따릅니다.

00:11:30.000 --> 00:11:34.000
메쉬 파이프라인 설명자를 초기화하는 것으로 다시 전환합시다.

00:11:34.000 --> 00:11:41.000
메쉬 파이프라인 설명자에서, 메쉬 스레드 그룹당 최대 스레드와 함께 메쉬 기능이 설정됩니다.

00:11:41.000 --> 00:11:45.000
금속::메쉬 구조가 준수해야 하는 한계가 있다.

00:11:45.000 --> 00:11:54.000
금속::메쉬 셰이더에는 다음과 같은 제한이 있습니다: 금속::메쉬는 최대 256개의 정점과 최대 512개의 프리미티브를 지원합니다.

00:11:54.000 --> 00:11:58.000
금속의 총 크기는 16킬로바이트를 초과할 수 없습니다.

00:11:58.000 --> 00:12:06.000
이제 메쉬 그리드가 금속::메시를 생성했으므로, 이것들은 래스터라이저에 공급되고 마침내 프래그먼트 셰이더가 실행됩니다.

00:12:06.000 --> 00:12:13.000
그래서, 전통적인 렌더링 파이프라인과 유사하게, 조각 함수는 메쉬 파이프라인 설명자에 설정됩니다.

00:12:13.000 --> 00:12:23.000
이제 설명자가 초기화되었으므로, 파이프라인 상태는 금속 장치에서 "메시 설명자로 파이프라인 상태 렌더링" 방법을 통해 생성됩니다.

00:12:23.000 --> 00:12:29.000
메쉬 파이프라인을 인코딩하는 것은 전통적인 드로우 호출을 인코딩하는 것과 매우 유사하다.

00:12:29.000 --> 00:12:31.000
파이프라인 상태는 인코더에 설정되어 있다.

00:12:31.000 --> 00:12:34.000
파이프라인의 각 단계는 자원을 묶을 수 있다.

00:12:34.000 --> 00:12:46.000
이 예에서 바인딩된 리소스는 객체 단계에 대한 객체 버퍼, 메쉬 단계에 대한 텍스처, 조각 단계에 대한 조각 버퍼입니다.

00:12:46.000 --> 00:13:04.000
다음으로, 메쉬 파이프라인을 시작하는 데 필요한 몇 가지 상수를 정의하고 있습니다: 개체 그리드 치수, 개체 스레드 그룹당 스레드 수, 메쉬 스레드 그룹당 스레드 수, 그리고 이러한 상수를 사용하여 새로운 "드로우 메쉬 스레드 그룹" 방법을 통해 그리기를 인코딩합니다.

00:13:04.000 --> 00:13:13.000
머리카락을 렌더링하는 데 사용되는 것과 동일한 접근 방식은 전체 토끼에 적용하여 메쉬 파이프라인을 통해 절차적으로 모피를 생성할 수 있다.

00:13:13.000 --> 00:13:16.000
다음으로, 메쉬 셰이더를 사용하는 또 다른 방법을 살펴봅시다.

00:13:16.000 --> 00:13:23.000
메쉬 셰이더는 메쉬 컬링을 사용하여 많은 양의 지오메트리를 효율적으로 처리하고 렌더링하는 데 사용할 수 있습니다.

00:13:23.000 --> 00:13:33.000
이 기술의 기초는 장면 메쉬를 메쉬렛이라고 불리는 더 작은 조각으로 나누는 것이다.

00:13:33.000 --> 00:13:39.000
장면 지오메트리를 메슬릿으로 분할하면 장면의 세분성이 증가하여 더 효율적이고 미세한 컬링을 가능하게 합니다.

00:13:39.000 --> 00:13:42.000
이를 통해 기하학 오버헤드를 크게 줄일 수 있습니다.

00:13:42.000 --> 00:13:51.000
Meshlet 입도 처리를 활용하여 스크린 공간 폐색 컬링 및 일반 필터링과 같은 효율적인 폐색 및 컬링 알고리즘을 가능하게 합니다.

00:13:51.000 --> 00:13:56.000
메쉬 셰이더를 사용하여 완전히 GPU 기반 컬링 및 렌더링 파이프라인을 구현할 수 있습니다.

00:13:56.000 --> 00:14:05.000
다음은 하나의 컴퓨팅과 하나의 렌더링 패스를 사용하여 장면 처리 및 렌더링을 수행하는 전통적인 GPU 기반 파이프라인입니다.

00:14:05.000 --> 00:14:17.000
장면 데이터는 메쉬렛으로 분할되어 프러스텀 컬링, LOD 선택 및 장치 메모리에 대한 인코딩을 담당하는 컴퓨팅 패스로 공급됩니다.

00:14:17.000 --> 00:14:23.000
그런 다음 렌더링 패스는 장면에 대한 그리기 명령을 실행하고 최종 이미지를 생성합니다.

00:14:23.000 --> 00:14:33.000
메쉬 셰이더를 사용하면 동기화 지점을 제거하고 두 개의 패스를 단일 메쉬 셰이더 디스패치로 병합하여 중간 드로우 명령을 피할 수 있습니다.

00:14:33.000 --> 00:14:35.000
어떻게 할 수 있는지 보여줄게.

00:14:35.000 --> 00:14:39.000
여기 메쉬 셰이더 디스패치를 실행하는 단일 렌더링 패스가 있습니다.

00:14:39.000 --> 00:14:45.000
오브젝트 셰이더는 프루스텀 컬링을 수행하고 눈에 보이는 각 메슬릿에 대한 LOD를 계산합니다.

00:14:45.000 --> 00:14:50.000
메쉬 셰이더의 페이로드는 인코딩되어야 하는 메쉬렛 ID 목록이다.

00:14:50.000 --> 00:14:55.000
그런 다음 메쉬 셰이더는 래스터화되고 음영 처리되어야 하는 금속::메시 개체를 인코딩합니다.

00:14:55.000 --> 00:15:00.000
그런 다음 최종 이미지는 전통적인 파이프라인과 동일한 조각 셰이더에 음영 처리됩니다.

00:15:00.000 --> 00:15:06.000
지오메트리 처리는 메쉬 스레드 그룹 명령과 단일 인코더 내에서 완전히 수행됩니다.

00:15:06.000 --> 00:15:13.000
삼각형 데이터가 메쉬 셰이더에 인코딩되기 때문에 이러한 그리기 명령을 저장하기 위해 더 이상 중간 버퍼가 필요하지 않습니다.

00:15:13.000 --> 00:15:19.000
이제 컬링에 관심을 돌리자 - 특히, 메쉬렛 컬링의 구현.

00:15:19.000 --> 00:15:22.000
그 장면은 이곳의 모양으로 표현된 모델로 구성되어 있다.

00:15:22.000 --> 00:15:27.000
이 구현에서, 장면의 각 모델은 객체 그리드의 일부가 될 것이다.

00:15:27.000 --> 00:15:35.000
객체 셰이더 스레드 그룹에 의해 생성된 메쉬 그리드는 모델의 표면을 구성하는 삼각형 패치인 메쉬렛으로 구성됩니다.

00:15:35.000 --> 00:15:38.000
새로운 기하학 파이프라인은 매우 유연하다.

00:15:38.000 --> 00:15:41.000
당신의 장면을 물체 그리드에 매핑하는 방법을 결정하는 것은 당신에게 달려 있습니다.

00:15:41.000 --> 00:15:49.000
이 예에서, 저는 각 모델을 객체 스레드 그룹에 매핑하고 있지만, 작업에 더 잘 맞는 매핑을 사용할 수 있습니다.

00:15:49.000 --> 00:15:58.000
이제, 객체 셰이더는 보기 frustum을 사용하여 메쉬렛의 가시성을 결정하고 최종 이미지에 표시될 것에 대해서만 작업을 파견할 것입니다.

00:15:58.000 --> 00:16:00.000
현장의 두 모델에 집중합시다.

00:16:00.000 --> 00:16:04.000
오브젝트 셰이더는 결정된 가시성을 기반으로 메쉬 그리드를 시작합니다.

00:16:04.000 --> 00:16:09.000
그런 다음 메쉬 셰이더는 메쉬렛을 처리하고 금속::메시를 구성합니다.

00:16:09.000 --> 00:16:16.000
프로그래밍 가능한 메쉬 그리드 크기는 유연한 디스패치를 가능하게 하므로 눈에 보이는 메쉬만 메쉬 셰이더로 처리됩니다.

00:16:16.000 --> 00:16:21.000
이것은 나중에 파이프라인에서 보이지 않는 기하학을 처리하는 데 소요되는 시간을 줄인다.

00:16:21.000 --> 00:16:30.000
고정 기능 래스터라이저는 보이는 것으로 알려진 표면만 수신하고 보이지 않는 형상을 처리하고 잘라내는 데 소요되는 시간을 줄입니다.

00:16:30.000 --> 00:16:35.000
마지막으로, 프로그래밍 가능한 조각 셰이더가 호출되어 최종 이미지를 생성합니다.

00:16:35.000 --> 00:16:48.000
보시다시피, 이 메쉬렛 컬링 예제에서 입증된 바와 같이, 새로운 지오메트리 파이프라인이 절차적 메쉬를 만들거나 드로우 호출을 더 효율적으로 만드는 것과 같이 해결할 수 있는 다양한 문제가 있습니다.

00:16:48.000 --> 00:16:52.000
금속은 이제 현대적이고 유연한 새로운 기하학 파이프라인을 포함한다.

00:16:52.000 --> 00:16:59.000
헤어 렌더링 예제에서 입증된 바와 같이, 이제 절차적 기하학을 만드는 것이 그 어느 때보다 쉬워졌습니다.

00:16:59.000 --> 00:17:11.000
또한, 메쉬렛 컬링 데모에서 볼 수 있듯이 단일 렌더링 패스에서 GPU 기반 작업의 가능성은 추가 컴퓨팅 패스 또는 중간 버퍼 없이 확장되었습니다.

00:17:11.000 --> 00:17:18.000
이 새로운 지오메트리 파이프라인은 Family7 및 Mac2 장치에서 사용할 수 있습니다.

00:17:18.000 --> 00:17:27.000
메쉬 셰이더를 배우고 실험할 수 있도록, 새로운 API를 사용하는 방법을 보여주는 Apple 개발자 웹 사이트에서 샘플 코드를 사용할 수 있습니다.

00:17:27.000 --> 00:17:35.000
이 기능을 어떻게 사용하고 지오메트리 처리 요구에 맞게 Apple GPU의 대규모 병렬 특성을 활용하는 방법을 보게 되어 기쁩니다.

00:17:35.000 --> 23:59:59.000
봐줘서 정말 고마워!

