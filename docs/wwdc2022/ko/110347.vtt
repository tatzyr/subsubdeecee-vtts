WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:13.000
안녕하세요, WWDC에 오신 것을 환영합니다.

00:00:13.000 --> 00:00:18.000
제 이름은 데이비드이고, MusicKit으로 더 많은 콘텐츠를 탐색할 수 있는 방법에 대해 말씀드리고 싶습니다.

00:00:18.000 --> 00:00:25.000
MusicKit 프레임워크는 2021년에 출시되었으며, 스위프트에서 기본적으로 음악에 액세스하고 재생할 수 있는 API 세트를 제공합니다.

00:00:25.000 --> 00:00:32.000
이 프레임워크를 사용하면 앱이 Apple Music과 쉽게 통합되어 전체 Apple Music 카탈로그에 액세스할 수 있습니다.

00:00:32.000 --> 00:00:36.000
오늘, 저는 우리가 MusicKit에 만든 몇 가지 주요 개선 사항에 대해 이야기하고 싶습니다.

00:00:36.000 --> 00:00:46.000
새로운 음악 항목 유형, 새로운 요청 및 새로운 메타데이터와 함께 Apple Music 카탈로그에서 더 많은 것을 얻기 위해 몇 가지 추가 사항으로 시작하겠습니다.

00:00:46.000 --> 00:00:53.000
그 후, 각 사용자에게 맞춤형 경험을 제공하기 위해 개인화된 콘텐츠를 가져오는 방법에 대해 논의하겠습니다.

00:00:53.000 --> 00:00:56.000
다음으로, 나는 애플 뮤직 카탈로그를 넘어설 것이다.

00:00:56.000 --> 00:01:02.000
올해는 사용자 라이브러리의 음악을 포함하여 앱을 완전히 새로운 차원으로 끌어올릴 수 있습니다.

00:01:02.000 --> 00:01:12.000
마지막으로, 라이브러리나 재생 목록에 항목을 추가하고 재생 목록을 만들고 편집하는 것과 같이 라이브러리와 적극적으로 상호 작용하는 방법에 대해 논의할 것입니다.

00:01:12.000 --> 00:01:14.000
카탈로그 콘텐츠 추가에 대해 자세히 알아봅시다.

00:01:14.000 --> 00:01:22.000
MusicKit의 초기 출시는 노래, 앨범 및 재생 목록과 같은 핵심 유형을 포함한 음악의 새로운 모델 레이어를 도입했다.

00:01:22.000 --> 00:01:32.000
올해, 우리는 큐레이터와 라디오 쇼라는 두 가지 새로운 유형을 추가하여 MusicKit으로 새로운 음악을 더 쉽게 발견할 수 있도록 하고 있습니다.

00:01:32.000 --> 00:01:49.000
그 외에도, MusicKit을 사용하면 카탈로그를 검색할 수 있는 훌륭한 UI를 구축하고, 상위 차트에 액세스하여 가장 인기 있는 노래, 앨범 등을 얻고, Dolby Atmos의 Spatial Audio와 같은 고품질 오디오 메타데이터와 같은 새로운 속성을 가져올 수 있습니다.

00:01:49.000 --> 00:01:54.000
음악 발견을 위한 환상적인 자료인 큐레이터와 라디오 쇼부터 시작합시다.

00:01:54.000 --> 00:01:58.000
여기서, 우리는 큐레이터인 나이키의 예시를 살펴보고 있습니다.

00:01:58.000 --> 00:02:02.000
큐레이터의 다른 예로는 Shazam과 Beats by Dr.가 있다. 드레.

00:02:02.000 --> 00:02:07.000
여기서, 우리는 이 큐레이터가 생성한 모든 재생 목록을 쉽게 찾을 수 있습니다.

00:02:07.000 --> 00:02:14.000
이 기능을 통해 사람들은 그들이 좋아할 수 있는 재생 목록에 빠르게 접근하거나, 새로운 노래를 찾거나, 오래된 즐겨찾기를 다시 방문할 수 있습니다.

00:02:14.000 --> 00:02:18.000
이제 더 기술적인 세부 사항에 대해 자세히 알아봅시다.

00:02:18.000 --> 00:02:20.000
큐레이터는 다양한 속성을 호스팅한다.

00:02:20.000 --> 00:02:28.000
이 새로운 큐레이터 유형의 주요 속성 중 일부는 이름, URL, 삽화 및 종류입니다.

00:02:28.000 --> 00:02:38.000
종류의 재산은 주어진 큐레이터가 Apple 큐레이터인지 제3자 큐레이터인지를 나타내는 "편집" 또는 "외부"가 될 수 있는 열거형이다.

00:02:38.000 --> 00:02:47.000
큐레이터는 또한 그 큐레이터가 만든 재생 목록을 보여주는 재생 목록 관계를 가지고 있으며, 우리가 방금 본 음악 발견 개념을 진정으로 제공한다.

00:02:47.000 --> 00:02:50.000
다음으로, 우리는 라디오 쇼 유형이 있다.

00:02:50.000 --> 00:02:59.000
"New Music Daily by Zane Lowe"와 "Pop Hits Radio by Brooke Reese"와 같은 라디오 쇼는 노련한 전문가를 통해 새로운 음악을 발견하는 또 다른 방법입니다.

00:02:59.000 --> 00:03:06.000
큐레이터 유형과 마찬가지로, 라디오 쇼는 라디오 쇼가 특징으로 하는 음악을 찾기 위한 재생 목록 관계를 가지고 있다.

00:03:06.000 --> 00:03:23.000
이 두 가지 새로운 유형이 재생 목록과 관계를 유지하는 것처럼, 우리는 또한 반전된 논리를 위해 재생 목록 유형, "Curator"와 "RadioShow"에 대한 두 가지 새로운 관계를 노출하고 있습니다: 재생 목록이 주어지면, 우리는 어떤 엔티티가 재생 목록을 생성했는지의 구조를 쉽게 얻을 수 있습니다.

00:03:23.000 --> 00:03:31.000
MusicKit을 사용하면 카탈로그에서 다양한 유형의 콘텐츠를 검색할 수 있으며, 이제 큐레이터 및 라디오 쇼와 같은 새로운 항목 유형에 대한 지원을 추가하고 있습니다.

00:03:31.000 --> 00:03:37.000
그 목록은 계속 성장하고 있으며, 결과적으로 좋은 UI를 구축하는 것은 점점 더 어려워진다.

00:03:37.000 --> 00:03:43.000
그것이 올해 우리가 최고의 결과와 제안을 통해 당신을 훨씬 더 쉽게 만드는 이유입니다.

00:03:43.000 --> 00:03:47.000
이러한 개선 사항이 UI에 가져오는 유틸리티를 살펴봅시다.

00:03:47.000 --> 00:03:53.000
콘텐츠를 검색하기 위해 입력할 때, 강력한 음악 관련 자동 완성 지원을 제공할 수 있습니다.

00:03:53.000 --> 00:03:59.000
그것이 제안이 작용하는 곳이며, 사람들이 도달하려고 할 수 있는 용어를 제공한다.

00:03:59.000 --> 00:04:06.000
한 걸음 더 나아가 사람들이 검색할 수 있는 것에 빠르게 접근할 수 있는 최고의 결과를 표시할 수도 있습니다.

00:04:06.000 --> 00:04:12.000
최상의 결과를 위해, 당신은 항목의 유형에 신경 쓰지 않고, 대신 관련성에 집중하고 싶을 수도 있습니다.

00:04:12.000 --> 00:04:15.000
이것이 최고의 결과의 힘이다.

00:04:15.000 --> 00:04:20.000
이제, 최고 결과부터 시작하여 이것을 구현하는 것이 어떤 모습일지 살펴봅시다.

00:04:20.000 --> 00:04:28.000
여기에는 검색어와 표현하고 싶은 항목 유형이 필요한 카탈로그 검색 요청을 만드는 기존 방법이 있습니다.

00:04:28.000 --> 00:04:35.000
응답에는 요청된 유형별로 분류된 컬렉션이 포함되어 있으며, 이는 유형별 결과의 여러 목록을 의미합니다.

00:04:35.000 --> 00:04:41.000
이것은 훌륭하지만, 우리는 유형에 구애받지 않는 가장 관련성이 높은 결과의 단일 목록을 공개하고 싶습니다.

00:04:41.000 --> 00:04:45.000
그리고 이 정보를 요청하는 것은 한 줄을 추가하는 것만큼 간단합니다.

00:04:45.000 --> 00:04:53.000
여기서 우리는 요청에 대한 includeTopResults 속성을 true로 설정하고 있으며, 새로운 속성이 응답에 채워집니다.

00:04:53.000 --> 00:04:58.000
이 새로운 속성의 이름은 요청된 유형의 항목을 포함하는 topResults입니다.

00:04:58.000 --> 00:05:02.000
인쇄 명세서의 출력은 다음과 같습니다.

00:05:02.000 --> 00:05:11.000
우리는 반환된 최고의 결과가 단일 컬렉션의 노래, 아티스트 및 앨범의 혼합이며 관련성에 따라 정렬된다는 것을 알 수 있습니다.

00:05:11.000 --> 00:05:16.000
이제 제안으로 사람들이 검색 목적지에 더 빨리 도착할 수 있도록 돕는 방법을 보여드리겠습니다.

00:05:16.000 --> 00:05:20.000
문자열 용어로 제안 요청을 만들기만 하면 됩니다.

00:05:20.000 --> 00:05:25.000
응답에 전화하면, 당신은 제안 응답을 다시 받게 될 것입니다.

00:05:25.000 --> 00:05:27.000
그 응답에는 일련의 제안이 포함되어 있다.

00:05:27.000 --> 00:05:34.000
그리고 각 제안에는 UI에 적합한 표시 용어와 검색어가 포함되어 있습니다.

00:05:34.000 --> 00:05:41.000
사람들이 제안을 선택하면, 검색어로 검색 요청을 수행하여 해당 결과를 가져올 수 있습니다.

00:05:41.000 --> 00:05:46.000
카탈로그 차트는 가장 인기 있는 노래를 최신 상태로 유지할 수 있는 좋은 방법입니다.

00:05:46.000 --> 00:05:50.000
MusicKit은 트렌드를 볼 수 있는 다양한 유형의 차트를 제공합니다.

00:05:50.000 --> 00:06:01.000
제공되는 차트의 유형은 가장 많이 재생되는 음악, 도시 차트 및 일일 상위 100에 해당하는 Top Songs 또는 Top Albums와 같은 Top 차트입니다.

00:06:01.000 --> 00:06:06.000
특정 장르별로 필터링할 요청된 차트를 지정할 수도 있습니다.

00:06:06.000 --> 00:06:09.000
코드를 통해 이 차트를 검색하는 것은 매우 간단합니다.

00:06:09.000 --> 00:06:15.000
카탈로그 차트 요청은 카탈로그 검색 요청에 이미 사용된 확립된 패턴을 따릅니다.

00:06:15.000 --> 00:06:18.000
먼저, 차트 요청을 초기화하세요.

00:06:18.000 --> 00:06:22.000
그런 다음 원하는 차트 종류를 지정할 수 있습니다.

00:06:22.000 --> 00:06:30.000
기본적으로, 이것은 가장 많이 재생된 콘텐츠를 가져오지만, 일일 글로벌 상위 차트와 도시 상위 차트를 포함할 수도 있습니다.

00:06:30.000 --> 00:06:33.000
마지막으로, 차트에 포함할 유형을 지정하기만 하면 됩니다.

00:06:33.000 --> 00:06:35.000
그리고 그게 다야.

00:06:35.000 --> 00:06:43.000
응답에서 첫 번째 재생 목록 차트에 액세스하면, 일일 글로벌 상위 차트를 나타내는 MusicCatalogChart를 받게 됩니다.

00:06:43.000 --> 00:06:48.000
그 항목은 "Top 100: Global"과 "Top 100: USA"와 같은 재생 목록이다.

00:06:48.000 --> 00:06:58.000
과거에 MusicDataRequest를 사용하여 카탈로그 차트를 가져온 적이 있다면, MusicKit이 당신을 위해 작업을 수행할 것이기 때문에 더 이상 할 필요가 없습니다.

00:06:58.000 --> 00:07:09.000
2021년에, 우리는 진정한 다차원 사운드와 선명도를 갖춘 획기적인 오디오 경험을 도입했습니다: 돌비 아트모스를 지원하는 공간 오디오.

00:07:09.000 --> 00:07:15.000
이 몰입형 경험은 이미 수천 곡의 노래에서 사용할 수 있으며, 이제 이 데이터에 액세스할 수 있습니다.

00:07:15.000 --> 00:07:25.000
MusicKit은 오디오 변형을 통해 모든 노래나 앨범에 사용할 수 있는 오디오 리소스를 노출하므로, 이제 이 정보를 다른 사람들에게 전달할 수 있습니다.

00:07:25.000 --> 00:07:34.000
오디오 변형의 예로는 이전에 언급된 돌비 아트모스가 있는 공간 오디오, 무손실 오디오 등이 있습니다.

00:07:34.000 --> 00:07:43.000
우리는 또한 오디오 변형과 함께 새로운 부울 속성을 노출하고 있으며, 지원되는 최고 품질의 마스터인 Apple Digital Master입니다.

00:07:43.000 --> 00:07:51.000
이 메타데이터는 항목 수준에서 노출되기 때문에, 오디오 변형은 세부 보기에 완벽하며, 이와 같은 UI를 달성할 수 있습니다.

00:07:51.000 --> 00:07:54.000
여기 앨범의 상세 보기가 있습니다.

00:07:54.000 --> 00:08:02.000
그리고 여기서, 우리는 앞서 언급한 오디오 변형 속성을 기반으로 적절한 배지를 볼 수 있으며, 사용자가 어떤 오디오 품질을 기대할 수 있는지 알 수 있습니다.

00:08:02.000 --> 00:08:08.000
이 경우, 공간 오디오와 무손실 오디오는 이 특정 앨범에서 사용할 수 있습니다.

00:08:08.000 --> 00:08:11.000
이제 우리가 이것을 달성하기 위해 어떻게 코드를 작성할 수 있는지 봅시다.

00:08:11.000 --> 00:08:14.000
오디오 변형을 로드하는 것은 다른 확장 속성을 로드하는 것과 같다.

00:08:14.000 --> 00:08:22.000
기존 앨범이나 노래, 이 경우 앨범을 가져와서 with 방법을 사용하여 audioVariants 확장 속성을 로드하세요.

00:08:22.000 --> 00:08:27.000
이제 당신의 상세한 앨범에는 audioVariants 속성이 채워져 있습니다.

00:08:27.000 --> 00:08:32.000
여기서 우리는 요소가 AudioVariant인 배열인 오디오 변형 속성을 볼 수 있습니다.

00:08:32.000 --> 00:08:40.000
이러한 값을 사용하면 앞서 본 것처럼 UI에 특정 요소에 대한 사용 가능한 오디오 리소스를 표시할 수 있습니다.

00:08:40.000 --> 00:08:45.000
이제, 이것은 훌륭하지만, 이 오디오 배지를 최고 수준이나 세부 보기 이상으로 보여주고 싶을 수도 있습니다.

00:08:45.000 --> 00:08:52.000
그것이 우리가 한 걸음 더 나아가 음악 플레이어의 활성 오디오 변형을 노출하는 이유입니다.

00:08:52.000 --> 00:09:01.000
활성 오디오 변형에 액세스하면 이 보기에서 Dolby Atmos와 같이 현재 재생 중인 항목의 오디오 품질을 시각적으로 표시할 수 있습니다.

00:09:01.000 --> 00:09:09.000
그리고 MusicKit 플레이어 API는 사용자 설정과 네트워크 조건에 따라 올바른 오디오 품질을 자동으로 선택합니다.

00:09:09.000 --> 00:09:17.000
플레이어의 활성 특성에 액세스하려면, 먼저 관찰된 개체에서 ApplicationMusicPlayer의 재생 상태에 액세스합니다.

00:09:17.000 --> 00:09:27.000
그런 다음 재생 상태에서 직접 활성 audioVariant에 액세스할 수 있습니다. 이제 audioVariant 속성을 확인하여 dolbyAtmos인지 확인하고 추가 UI를 추가하면 됩니다.

00:09:27.000 --> 00:09:37.000
재생 상태는 관찰된 객체이기 때문에, 이 보기는 현재 재생 중인 항목이 변경될 때마다 자동으로 업데이트되어 보기가 항상 최신 상태인지 확인합니다.

00:09:37.000 --> 00:09:42.000
이제 몇 가지 카탈로그 추가 사항을 검토했으니, 개인화된 콘텐츠를 가져오는 것에 대해 알아봅시다.

00:09:42.000 --> 00:09:49.000
개인화된 콘텐츠는 구독자와 관련된 데이터로, 앱의 모든 사용자에게 독특하고 맞춤화된 경험을 제공합니다.

00:09:49.000 --> 00:09:59.000
일반적으로 개인화된 콘텐츠에는 특별한 인증과 사용자 토큰이 필요하지만, MusicKit 프레임워크에서는 이 모든 것을 자동으로 만들었으므로 번거로움을 처리할 필요가 없습니다.

00:09:59.000 --> 00:10:06.000
우리가 개발자들에게 제공하는 개인화된 콘텐츠는 최근에 재생된 아이템과 개인 추천에 대한 접근이다.

00:10:06.000 --> 00:10:12.000
최근에 재생된 콘텐츠는 사람의 음악 소비 경험을 위한 귀중한 데이터이다.

00:10:12.000 --> 00:10:16.000
그것은 당신이 그들이 즐기는 음악 아이템에 빠르고 쉽게 접근할 수 있게 해준다.

00:10:16.000 --> 00:10:22.000
그리고 새로운 음악을 들을 때, 그것은 사람들이 나중에 돌아가서 그들의 역사를 참조할 수 있게 해준다.

00:10:22.000 --> 00:10:29.000
앨범, 재생 목록 및 스테이션과 같은 최근에 재생된 컨테이너를 가져오려면, 최근에 재생된 컨테이너 요청을 만들 수 있습니다.

00:10:29.000 --> 00:10:34.000
재생 목록이나 앨범에서 노래를 재생하면 컨테이너 유형이 검색됩니다.

00:10:34.000 --> 00:10:43.000
응답에서, 제목, 자막 및 삽화에 대한 편리한 접근자를 제공하는 최근에 재생된 음악 항목을 찾을 수 있습니다.

00:10:43.000 --> 00:10:48.000
노래나 방송국과 같은 더 구체적인 유형의 최근에 재생된 항목을 가져올 수도 있습니다.

00:10:48.000 --> 00:10:56.000
여기서, 우리는 앵글 괄호로 표시된 일반 매개 변수를 통해 노래 유형을 지정하여 최근에 재생된 요청을 만듭니다.

00:10:56.000 --> 00:10:59.000
우리의 반응은 이제 우리가 연주한 노래만 포함한다.

00:10:59.000 --> 00:11:02.000
이제, 개인적인 추천으로.

00:11:02.000 --> 00:11:11.000
개인 추천을 통해 앱 경험을 사용자의 라이브러리와 청취 기록을 기반으로 생성되기 때문에 더 친밀하고 매력적으로 느낄 수 있습니다.

00:11:11.000 --> 00:11:20.000
추천은 테마별로 잘 정리되어 장르, 예술가, "Made for You"와 같은 컬렉션 등으로 그룹화됩니다.

00:11:20.000 --> 00:11:25.000
개인 추천을 가져오려면, 개인 추천 요청을 만들기만 하면 됩니다.

00:11:25.000 --> 00:11:28.000
그 응답은 추천의 모음이다.

00:11:28.000 --> 00:11:34.000
우리가 첫 번째 추천을 기록할 때, 우리는 이 특정 요소가 "Made for You" 추천을 나타낸다는 것을 알 수 있다.

00:11:34.000 --> 00:11:38.000
추천에는 ID, 제목 및 nextRefreshDate가 있습니다.

00:11:38.000 --> 00:11:45.000
nextRefreshDate는 최신 제안을 위해 이 추천을 새로 고쳐야 하는 날짜 시간을 나타냅니다.

00:11:45.000 --> 00:11:49.000
재생 목록 속성에는 나를 위해 만들어진 모든 재생 목록이 포함되어 있습니다.

00:11:49.000 --> 00:11:52.000
추천의 또 다른 예를 살펴봅시다.

00:11:52.000 --> 00:11:56.000
여기서 우리는 권장 사항 응답의 두 번째 요소를 인쇄할 것입니다.

00:11:56.000 --> 00:12:04.000
나는 수많은 대체 음악을 듣고, 이 추천에는 다양한 유형, 이 경우 앨범과 재생 목록이 혼합되어 있다.

00:12:04.000 --> 00:12:11.000
그것들은 카탈로그 검색의 상위 결과와 마찬가지로 관련성에 따라 정렬된 단일 항목 모음으로 그룹화됩니다.

00:12:11.000 --> 00:12:21.000
이제, 한 걸음 더 나아가 사용자 라이브러리의 콘텐츠를 앱에 통합하여 음악에 대해 훨씬 더 관련성 있는 경험을 만들 수 있는 방법에 대해 이야기해 봅시다.

00:12:21.000 --> 00:12:39.000
올해 MusicKit을 사용하면 앱이 두 가지 유형의 요청으로 라이브러리에서 항목을 가져올 수 있습니다: 라이브러리 요청과 라이브러리 섹션 요청, 사용자 라이브러리의 콘텐츠 검색, 특히 라이브러리에서 확장된 속성과 관계를 로드할 수 있습니다.

00:12:39.000 --> 00:12:45.000
기술적 세부 사항을 보기 전에, 라이브러리 콘텐츠를 사용하여 앱을 향상시키는 방법을 봅시다.

00:12:45.000 --> 00:12:50.000
저는 당신의 야외 달리기를 추적할 Music Marathon이라는 피트니스 앱을 개발하고 있습니다.

00:12:50.000 --> 00:12:59.000
프로젝트에 MusicKit을 통합함으로써, 우리는 사람들이 Apple Music 앱과 이 앱 사이의 컨텍스트를 전환하는 대신 앱을 통해 직접 음악을 재생할 수 있도록 합니다.

00:12:59.000 --> 00:13:04.000
새로운 운동을 시작하고 음악 콘텐츠를 찾아봅시다.

00:13:04.000 --> 00:13:12.000
여기서 우리는 사람들이 우리가 좋아할 것이라고 생각하는 재생 목록에 빠르게 접근할 수 있도록 개인 추천 요청에서 검색된 몇 가지 추천 재생 목록을 볼 수 있습니다.

00:13:12.000 --> 00:13:17.000
도서관 탭으로 가면, 우리는 그것이 빈 시야라는 것을 알 수 있다.

00:13:17.000 --> 00:13:21.000
내 모든 개인 재생 목록을 볼 수 있다면 좋을 것이므로, 그 기능을 작성해 봅시다.

00:13:21.000 --> 00:13:29.000
저는 이미 이 보기의 기본 사항을 처리하기 위해 UI를 설정했고, 이제 제 라이브러리에서 재생 목록을 로드하고 싶습니다.

00:13:29.000 --> 00:13:33.000
먼저, 내가 도서관을 요청할게...

00:13:33.000 --> 00:13:42.000
사용자의 라이브러리에서 재생 목록을 원한다는 것을 나타내기 위해 일반 매개 변수에서 재생 목록을 지정합니다.

00:13:42.000 --> 00:13:47.000
그리고 나는 그것을 지역 변수에 저장할 것이다. 나는 "요청"이라고 부를 것이다.

00:13:47.000 --> 00:13:53.000
다음으로 나는 이 요청을 받고 응답 기능을 호출할 것이다.

00:13:53.000 --> 00:13:58.000
이 방법은 비동기 던지기 방법이므로, try and await 키워드를 추가해 봅시다.

00:13:58.000 --> 00:14:04.000
그리고 다시 한 번 그것을 응답 변수에 저장하세요.

00:14:04.000 --> 00:14:11.000
그런 다음, 이 응답을 받기 위해 상태 객체를 업데이트하겠습니다.

00:14:11.000 --> 00:14:17.000
이제 내 UI에서 재생 목록을 볼 수 있도록 목록을 업데이트하기만 하면 된다.

00:14:17.000 --> 00:14:25.000
나는 ForEach를 사용하여 응답의 항목을 반복할 것이다...

00:14:25.000 --> 00:14:30.000
그리고 MusicItemCollection에서 각 재생 목록을 검색하세요.

00:14:30.000 --> 00:14:35.000
이제 재생 목록이 있으니, 내가 이미 만든 PlaylistCell에 전달할게.

00:14:35.000 --> 00:14:44.000
이제 우리가 다시 달리면...

00:14:44.000 --> 00:14:50.000
그리고 앱으로 돌아가면, 라이브러리에서 내 모든 개인 재생 목록을 볼 수 있습니다.

00:14:50.000 --> 00:14:57.000
이제, 저는 개인 추천, Apple Music 카탈로그의 모든 것, 그리고 제 개인 라이브러리를 들을 수 있습니다.

00:14:57.000 --> 00:15:02.000
이제 도서관 콘텐츠에 접근하는 것이 얼마나 쉬운지 보았으니, 도서관 요청이 무엇을 더 할 수 있는지 살펴봅시다.

00:15:02.000 --> 00:15:07.000
음악 라이브러리 요청은 사용자의 라이브러리에서 항목을 가져오는 강력한 API입니다.

00:15:07.000 --> 00:15:15.000
iOS에서는 음악 카탈로그에서 콘텐츠를 가져오려는 다른 요청과 달리 MusicLibraryRequest는 실제로 네트워크에서 데이터를 로드하지 않습니다.

00:15:15.000 --> 00:15:21.000
대신, 그것은 장치에 저장된 사용자 라이브러리의 복사본에서 항목을 로드할 것이다.

00:15:21.000 --> 00:15:27.000
이 요청의 기본 사항은 원하는 음악 항목 유형을 지정하기만 하면 됩니다.

00:15:27.000 --> 00:15:32.000
이 항목 유형은 MusicLibraryRequest의 일반 매개 변수를 통해 전달됩니다.

00:15:32.000 --> 00:15:39.000
요구 사항에 맞게 통화를 미세하게 조정하기 위해 요청에 다양한 필터와 정렬 옵션을 적용할 수 있습니다.

00:15:39.000 --> 00:15:46.000
이 요청은 또한 이미 다운로드한 콘텐츠를 가져올 수 있으며, 완전한 오프라인 경험을 지원합니다.

00:15:46.000 --> 00:15:55.000
우리가 뮤직 마라톤 앱에 쓴 것과 같은 간단한 기본 요청으로 시작하지만, 이번에는 라이브러리에 있는 앨범을 요청하세요.

00:15:55.000 --> 00:15:58.000
앨범 유형은 일반 매개 변수를 통해 지정됩니다.

00:15:58.000 --> 00:16:01.000
요청을 수행하려면, 응답 기능을 호출하세요.

00:16:01.000 --> 00:16:11.000
출력을 보면, 우리는 MusicLibraryResponse를 가지고 있으며, 그 항목은 사용자의 음악 라이브러리에 있는 모든 앨범의 MusicItemCollection입니다.

00:16:11.000 --> 00:16:19.000
여기서 우리는 이 앨범들이 당신이 우리의 다양한 카탈로그 요청 중 하나에서 얻을 수 있는 것과 동일한 앨범 구조이며 동일한 기능을 가지고 있다는 것을 알 수 있습니다.

00:16:19.000 --> 00:16:27.000
이 예에서 우리는 라이브러리의 모든 앨범을 가져오는 반면, 앨범의 특정 하위 집합만 원하는 시나리오가 있다는 것을 알고 있습니다.

00:16:27.000 --> 00:16:34.000
그렇기 때문에 MusicLibraryRequest를 사용하면 라이브러리에서 가져오고 싶은 항목에 대해 더 구체적으로 알 수 있습니다.

00:16:34.000 --> 00:16:38.000
우리가 전에 썼던 것과 같은 요청을 받고 필터를 추가합시다.

00:16:38.000 --> 00:16:44.000
여기서, 우리는 isCompilation 속성이 true와 같은 모든 앨범을 로드하고 싶습니다.

00:16:44.000 --> 00:16:52.000
필터 메소드를 호출할 때, Xcode의 자동 완성은 요청하는 항목 유형에 대해 지원되는 특정 키 경로만 제공합니다.

00:16:52.000 --> 00:16:56.000
이제, 응답에는 편집된 앨범만 있다.

00:16:56.000 --> 00:16:59.000
하지만 그것이 MusicLibraryRequest가 제공하는 전부는 아니다.

00:16:59.000 --> 00:17:04.000
여러 필터를 연결하여 추가할 때마다 더 세련된 요청을 할 수 있습니다.

00:17:04.000 --> 00:17:08.000
만약 우리가 특정 장르의 모든 편집을 원한다면 어떨까요?

00:17:08.000 --> 00:17:11.000
우리는 요청에 다른 필터를 추가할 수 있습니다.

00:17:11.000 --> 00:17:15.000
예를 들어, 여기에 "댄스"라는 장르의 사례가 있습니다.

00:17:15.000 --> 00:17:22.000
장르의 관계별로 필터링하여 이 특정 장르를 포함하는 편집만 포함하도록 결과를 제한할 수 있습니다.

00:17:22.000 --> 00:17:25.000
이제 우리의 응답에는 댄스 편집만 포함되어 있습니다.

00:17:25.000 --> 00:17:29.000
이미 다운로드한 댄스 컴필레이션만 포함하는 건 어때?

00:17:29.000 --> 00:17:33.000
그렇게 하려면, 요청 시 includeOnlyDownloadedContent를 true로 설정하기만 하면 됩니다.

00:17:33.000 --> 00:17:34.000
그리고 그게 다야.

00:17:34.000 --> 00:17:41.000
응답은 동일한 MusicLibraryResponse이지만, 항목은 이제 다운로드된 요소만 포함합니다.

00:17:41.000 --> 00:17:50.000
보시다시피, 음악 라이브러리 요청은 매우 강력하며 사용자 지정 MusicDataRequest로 불가능했던 새로운 기능을 잠금 해제합니다.

00:17:50.000 --> 00:17:54.000
하지만 MusicKit은 사용자의 라이브러리에서 데이터를 가져올 수 있는 더 많은 옵션을 제공합니다.

00:17:54.000 --> 00:17:57.000
도서관 섹션 요청을 충족하세요.

00:17:57.000 --> 00:18:02.000
섹션 요청은 섹션별로 그룹화된 항목을 가져올 수 있습니다.

00:18:02.000 --> 00:18:07.000
결과적으로, 분할된 요청은 두 개의 뚜렷한 일반 매개 변수를 취한다.

00:18:07.000 --> 00:18:11.000
첫 번째는 섹션 유형을 나타내고, 두 번째는 항목 유형을 나타냅니다.

00:18:11.000 --> 00:18:23.000
라이브러리 섹션 요청은 섹션이나 항목에 적용할 수 있는 다양한 필터 및 정렬 방법과 같은 일반 라이브러리 요청과 동일한 기능을 지원합니다.

00:18:23.000 --> 00:18:29.000
라이브러리 섹션 요청을 사용하여 장르별로 섹션된 모든 앨범을 가져오는 방법은 다음과 같습니다.

00:18:29.000 --> 00:18:38.000
섹션된 응답은 각 요소가 요청의 첫 번째 일반 매개 변수인 이 경우 장르에 해당하는 "섹션"이라는 속성을 보유하고 있습니다.

00:18:38.000 --> 00:18:46.000
각 장르는 자체 속성을 노출할 뿐만 아니라 아이템 속성을 통해 접근할 수 있는 앨범 모음도 포함한다.

00:18:46.000 --> 00:18:50.000
그 항목들은 두 번째 일반적인 주장에 해당한다.

00:18:50.000 --> 00:18:53.000
여기서, 하이라이트는 장르가 대안인 앨범을 보여준다.

00:18:53.000 --> 00:18:59.000
그리고 앞서 언급했듯이, 이 섹션 요청은 필터링 및 정렬 기능도 사용할 수 있습니다.

00:18:59.000 --> 00:19:06.000
우리가 장르별로 분류된 같은 앨범을 원하지만, 앨범은 아티스트의 이름으로 정렬되었다고 가정해 봅시다.

00:19:06.000 --> 00:19:07.000
우리는 정렬 필터를 추가합니다.

00:19:07.000 --> 00:19:15.000
앨범에 artistName keyPath를 지정하고 이것들이 오름차순이기를 원한다고 말함으로써, 우리는 응답을 정렬하고 있습니다.

00:19:15.000 --> 00:19:21.000
섹션이 아닌 항목에 적용할 정렬을 지정하고 있기 때문에 그 방법은 sortItems입니다.

00:19:21.000 --> 00:19:27.000
우리가 섹션을 지정하고 싶었다면, 필터 섹션과 정렬 섹션 방법 세트를 사용할 수 있습니다.

00:19:27.000 --> 00:19:32.000
새로운 반응을 살펴봅시다.

00:19:32.000 --> 00:19:37.000
우리는 이제 우리의 앨범이 제목이 아닌 아티스트 이름으로 알파벳순으로 정렬된다는 것을 알 수 있다.

00:19:37.000 --> 00:19:48.000
라이브러리 요청과 라이브러리 섹션 요청은 모두 매우 강력하지만, 사용자의 라이브러리에서 검색 결과를 추가하여 음악 검색 UI를 보완할 수도 있습니다.

00:19:48.000 --> 00:19:59.000
그래서 우리는 카탈로그 검색과 거의 동일하게 작동하는 새로운 구조화된 요청을 추가했지만, 카탈로그에서 결과를 로드하는 대신 사용자의 라이브러리에서 관련 항목을 찾습니다.

00:19:59.000 --> 00:20:06.000
카탈로그와 마찬가지로, 도서관 검색 요청은 검색어와 유형 배열만 필요합니다.

00:20:06.000 --> 00:20:13.000
이제 사용자 라이브러리에서 항목을 검색하는 다양한 방법을 보았으니, 확장된 속성과 관계를 로드하는 것은 어떻습니까?

00:20:13.000 --> 00:20:22.000
아시다시피, MusicKit의 초기 릴리스는 Apple Music API에서 이러한 속성을 간단한 방식으로 로드하는 with 방법을 도입했습니다.

00:20:22.000 --> 00:20:28.000
올해, 우리는 선호하는 소스 매개 변수를 사용하는 방법으로 전류를 보강하고 있습니다.

00:20:28.000 --> 00:20:38.000
이 기본 소스는 Apple Music 카탈로그와 사용자 라이브러리 모두에서 사용할 수 있는 확장된 속성과 관계를 위해 데이터를 로드할 위치를 나타냅니다.

00:20:38.000 --> 00:20:47.000
그리고 카탈로그나 라이브러리에만 있는 속성의 경우, 아무것도 무시되지 않도록 선호하는 소스에 관계없이 여전히 가져올 것입니다.

00:20:47.000 --> 00:20:56.000
또한, 카탈로그 요청, 라이브러리 요청 또는 다른 곳이든 초기 항목이 어디에서 왔는지에 관계없이 이 기능을 사용할 수 있습니다.

00:20:56.000 --> 00:20:58.000
그냥 다 작동해.

00:20:58.000 --> 00:21:02.000
여기서 우리는 음악 아이템의 관계를 받는 알려진 방법을 가지고 있다.

00:21:02.000 --> 00:21:09.000
우리는 앨범의 트랙을 로드하고 있으며, 출력을 표시할 때, 그 앨범의 모든 트랙을 볼 수 있습니다.

00:21:09.000 --> 00:21:17.000
그러나, preferredSource 속성의 새로운 추가와 함께, 우리는 라이브러리에서 이 관계를 가져오고 싶다는 것을 지정할 수 있습니다.

00:21:17.000 --> 00:21:22.000
이제 우리의 출력에는 라이브러리에서 찾은 앨범의 트랙만 포함되어 있습니다.

00:21:22.000 --> 00:21:31.000
이제 사용자의 라이브러리에서 항목을 가져올 수 있는 다양한 방법으로, 사용자가 MusicKit을 통해 라이브러리와 직접 상호 작용할 수 있도록 하는 것이 합리적입니다.

00:21:31.000 --> 00:21:37.000
내 샘플 앱인 뮤직 마라톤으로 돌아가서 도서관이 제공하는 기능 중 일부를 봅시다.

00:21:37.000 --> 00:21:43.000
운동하는 동안, 나는 내 개인적인 추천 중 일부를 살펴보고 싶다.

00:21:43.000 --> 00:21:48.000
트랙을 살펴보면서, 나는 이 노래들 중 하나가 내 운동 재생 목록에 완벽할 것이라는 것을 깨달았다.

00:21:48.000 --> 00:21:53.000
이 셀 중 하나를 누르고 있으면 상황에 맞는 메뉴가 나타나서 이 노래를 재생 목록에 추가할 수 있습니다.

00:21:53.000 --> 00:21:57.000
우리가 그것을 누르면, 내 모든 재생 목록의 팝업이 다시 나타난다.

00:21:57.000 --> 00:22:01.000
내가 선택한 재생 목록에 선택한 트랙을 추가하는 코드를 작성해 봅시다.

00:22:01.000 --> 00:22:13.000
이미 선택한 항목을 AddToPlaylistCell 셀로 파이프로 연결했으므로, 공유 인스턴스를 통해 MusicLibrary에 액세스하기만 하면 됩니다.

00:22:13.000 --> 00:22:23.000
우리는 선택한 트랙과 추가하고 싶은 재생 목록을 지정하는 "추가" 방법을 호출할 것입니다.

00:22:23.000 --> 00:22:31.000
이 방법은 또한 비동기 던지기 함수이므로, 우리는 다시 한 번 try and await 키워드를 추가합니다.

00:22:31.000 --> 00:22:38.000
마지막으로, 우리는 isShowingPlaylistPicker 바인딩 변수를 false로 설정하여 피커를 해제할 것입니다.

00:22:38.000 --> 00:22:47.000
이제 재생 목록에 트랙을 다시 실행하고 추가하고 재생 목록 중 하나를 선택하면, 이 항목이 추가될 것으로 예상됩니다.

00:22:47.000 --> 00:22:53.000
앱 내의 라이브러리 탭으로 돌아가서, 이제 노래가 운동 재생 목록에 추가된 것을 볼 수 있습니다.

00:22:53.000 --> 00:22:56.000
그리고 그것이 재생 목록에 항목을 추가하는 것이 얼마나 간단한지이다.

00:22:56.000 --> 00:22:59.000
도서관이 제공하는 다른 기능 중 일부를 살펴봅시다.

00:22:59.000 --> 00:23:10.000
라이브러리와 상호 작용하는 다양한 방법은 라이브러리에 콘텐츠를 추가하고, 재생 목록을 만들고, 재생 목록의 메타데이터와 트랙 목록을 편집하는 것입니다.

00:23:10.000 --> 00:23:24.000
사용자의 음악 라이브러리에 콘텐츠를 추가하면 Apple Music 앱의 라이브러리 탭에서 특정 노래나 앨범을 찾을 수 있으며, 설정에서 "라이브러리 동기화"가 켜져 있을 때 모든 장치에서 동기화할 수 있습니다.

00:23:24.000 --> 00:23:34.000
앱에서 이 기능을 직접 제공하면 사람들이 Apple Music 앱과 당신의 앱 간의 컨텍스트 전환에서 벗어날 수 있으므로, 그들이 당신이 제공하는 콘텐츠에 계속 참여할 수 있습니다.

00:23:34.000 --> 00:23:46.000
또한, 새로 도입된 라이브러리 요청과 함께 라이브러리에 추가를 통합함으로써, 앱은 이러한 결과로부터 즉시 혜택을 받을 수 있으며, 사용자가 좋아하는 콘텐츠에 쉽게 접근할 수 있습니다.

00:23:46.000 --> 00:23:51.000
이 강력한 서비스에도 불구하고, 당신은 여전히 특정한 음악적 경험을 만들고 싶을 수도 있습니다.

00:23:51.000 --> 00:23:56.000
그래서 올해, 우리는 재생 목록 제작과 편집을 MusicKit에 가져올 것입니다.

00:23:56.000 --> 00:23:59.000
이제 사용자를 대신하여 재생 목록을 만들 수 있습니다.

00:23:59.000 --> 00:24:07.000
우리는 또한 노래나 전체 앨범과 같은 항목을 사용자 라이브러리의 적격 재생 목록에 추가할 수 있도록 허용하고 있습니다.

00:24:07.000 --> 00:24:14.000
재생 목록을 만드는 것은 사람들이 좋아하는 콘텐츠를 그룹화하거나 앱이 설정하고 싶은 분위기에 맞추는 데 환상적입니다.

00:24:14.000 --> 00:24:22.000
그리고 기존 재생 목록에 콘텐츠를 추가함으로써, MusicKit이 제공하는 다양한 음악 발견 도구가 사람들에게 직접적인 영향을 미칠 수 있습니다.

00:24:22.000 --> 00:24:30.000
이제 만든 재생 목록을 편집할 수 있으며, 트랙 목록과 메타데이터를 편집하여 모든 것이 원하는 대로인지 확인할 수 있습니다.

00:24:30.000 --> 00:24:35.000
그리고 그것들은 앱 내에서 사용자의 라이브러리와 상호 작용할 수 있는 방법입니다.

00:24:35.000 --> 00:24:39.000
마무리로, MusicKit은 올해 몇 가지 주요 업그레이드를 받았다.

00:24:39.000 --> 00:24:49.000
더 나은 경험을 위해 새로운 유형, 속성 및 검색 확장에 대한 카탈로그 향상을 기존 앱에 쉽게 통합하세요.

00:24:49.000 --> 00:24:57.000
라이브러리 콘텐츠와 기능을 통합하여 새로운 기능을 잠금 해제하고 사용자가 자신의 경험을 제어할 수 있도록 합니다.

00:24:57.000 --> 00:25:00.000
그리고 MusicKit을 사용하면 다양한 유형의 앱을 향상시킬 수 있습니다.

00:25:00.000 --> 00:25:08.000
피트니스 앱, 게임, 소셜 미디어 앱, 매핑 앱 등은 모두 음악을 재생하거나 공유함으로써 이익을 얻을 수 있습니다.

00:25:08.000 --> 00:25:12.000
더 나아가려면, 몇 가지 관련 세션을 꼭 확인하세요.

00:25:12.000 --> 00:25:19.000
Swift에 대해 더 깊이 파고들고 MusicKit 및 기타 Apple 프레임워크를 최대한 활용하기 위해 언어에 새로 추가된 것에 대해 알아보세요.

00:25:19.000 --> 00:25:28.000
2021년부터 MusicKit 세션을 확인하여 프레임워크를 사용하고, 재생을 시작하고, 구독 제안을 제시하도록 앱을 설정하는 방법을 알아보세요.

00:25:28.000 --> 00:25:37.000
그리고 Android 또는 웹에서 Apple Music과 통합하는 데 관심이 있다면, Apple Music API를 직접 사용하는 방법을 검토하는 또 다른 세션이 있습니다.

00:25:37.000 --> 00:25:42.000
나는 당신이 우리의 세션을 즐겼기를 바라며, 우리의 개발자 포럼을 통해 계속 업데이트하고 참여하기를 바랍니다.

00:25:42.000 --> 23:59:59.000
시청해 주셔서 감사드리며, WWDC 2022를 즐기세요.

