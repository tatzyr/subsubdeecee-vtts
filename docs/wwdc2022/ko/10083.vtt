WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:15.000
Vaibhav Gautam: 안녕하세요, 저는 Vaibhav Gautam이고, 소프트웨어 파워 팀의 엔지니어입니다.

00:00:15.000 --> 00:00:22.000
앱은 하루 종일 다양한 중요한 기능을 제공하기 때문에 사람들의 삶을 풍요롭게 한다.

00:00:22.000 --> 00:00:26.000
하지만 이 사용은 비용이 들 수 있다: 배터리 소모.

00:00:26.000 --> 00:00:37.000
따라서 사용자가 장치와 앱을 더 오래 사용할 수 있도록 앱의 배터리 수명을 개선하기 위해 특별한 주의를 기울이는 것이 중요합니다.

00:00:37.000 --> 00:00:51.000
우리는 전력 소비를 이해하기 위해 다양한 시스템 구성 요소를 깊이 연구하며, 이 세션에서는 앱의 배터리 수명을 크게 개선하기 위해 취할 수 있는 네 가지 주요 조치를 살펴보겠습니다.

00:00:51.000 --> 00:01:03.000
이것들은 앱의 다크 모드, 프레임 속도 감사, 백그라운드 시간 제한, 앱의 작업 연기입니다.

00:01:03.000 --> 00:01:06.000
먼저, 다크 모드에 대해 이야기하겠습니다.

00:01:06.000 --> 00:01:14.000
다크 모드는 iOS 13에 도입되었으며, 누군가가 더 어두운 프레젠테이션에서 장치를 구성할 수 있게 해준다.

00:01:14.000 --> 00:01:24.000
다크 모드의 개인화 이점에 익숙할 수도 있지만, 배터리 수명에 큰 영향을 미칠 수도 있습니다.

00:01:24.000 --> 00:01:35.000
이것은 iPhone 13 및 13 Pro와 같은 OLED 디스플레이가 있는 장치에서 어두운 콘텐츠가 더 가벼운 콘텐츠보다 더 적은 전력을 소비하기 때문입니다.

00:01:35.000 --> 00:01:45.000
OLED 화면에서 각 픽셀은 개별 전력이 필요하며, 어두운 색상의 경우 픽셀을 밝히는 데 더 적은 전력이 필요합니다.

00:01:45.000 --> 00:01:52.000
시스템의 모든 구성 요소 중에서, 디스플레이는 전력 소비의 주요 원천 중 하나이다.

00:01:52.000 --> 00:02:00.000
사실, 일반적인 사용 사례에서, 디스플레이는 배터리 소모의 주요 원인이 될 수 있다.

00:02:00.000 --> 00:02:04.000
디스플레이의 전력 소비에 영향을 미칠 수 있는 방법이 있습니다.

00:02:04.000 --> 00:02:08.000
그리고 한 가지 방법은 다크 모드를 채택하는 것이다.

00:02:08.000 --> 00:02:14.000
나는 우리 팀이 예를 들어 작업해 온 푸드 트럭 앱을 사용할 것이다.

00:02:14.000 --> 00:02:21.000
이 앱은 화면의 대부분을 차지하는 매우 눈에 띄는 배경색을 가지고 있다.

00:02:21.000 --> 00:02:29.000
다크 모드로 표시할 때, 이 배경색은 라이트 모드 버전보다 훨씬 어두워져 배터리 절약에 크게 기여합니다.

00:02:29.000 --> 00:02:38.000
사실, 이와 같은 경우, 우리는 결과적으로 최대 70%의 디스플레이 전력 절감을 예상한다.

00:02:38.000 --> 00:02:41.000
이건 엄청난 저축이야!

00:02:41.000 --> 00:02:46.000
그리고 화면 밝기가 높을 때, 배터리 절약은 훨씬 더 높다.

00:02:46.000 --> 00:02:56.000
다크 모드를 선호하는 사용자의 경우, 이것은 배터리 소모를 절약할 수 있는 엄청난 기회이며 열 부하도 줄일 수 있습니다.

00:02:56.000 --> 00:03:03.000
다크 모드를 채택하려면, 다크 모드가 활성화되었을 때 앱이 현재 어떻게 나타나는지 검토하는 것부터 시작하세요.

00:03:03.000 --> 00:03:10.000
시스템 UI에 더 잘 맞도록 업데이트해야 하는 앱의 구성 요소를 파악하세요.

00:03:10.000 --> 00:03:18.000
Xcode는 앱을 빌드할 때 외관 기능을 사용하여 이를 쉽게 만듭니다.

00:03:18.000 --> 00:03:24.000
당신의 앱은 라이트 모드만 지원하기 때문에 하드 코딩된 색상을 가질 수 있습니다.

00:03:24.000 --> 00:03:32.000
Xcode에서 동적 색상을 사용하여 라이트 및 다크 모드에서 배경색, 이미지 및 텍스트를 지원하십시오.

00:03:32.000 --> 00:03:40.000
시스템은 자동으로 올바른 색상 값을 사용하며, 모드가 변경되면 업데이트됩니다.

00:03:40.000 --> 00:03:46.000
당신의 앱은 또한 라이트 모드와 다크 모드의 대체 이미지를 지원해야 합니다.

00:03:46.000 --> 00:03:57.000
다크 모드용 앱을 사용자 정의하는 방법에 대해 자세히 알아보려면, WWDC 2019의 "iOS에서 다크 모드 구현"을 확인하세요.

00:03:57.000 --> 00:04:06.000
이제 앱에서 다크 모드를 채택하는 방법을 알았으니, 웹 콘텐츠에 다크 모드를 채택하는 방법에 대해서도 생각해야 합니다.

00:04:06.000 --> 00:04:14.000
사파리는 웹 콘텐츠를 자동으로 어둡게 하지 않으므로, 웹 콘텐츠에도 다크 모드를 채택해야 합니다.

00:04:14.000 --> 00:04:20.000
그렇게 하려면, 웹사이트의 스타일시트에 색상 체계 속성을 구현하세요.

00:04:20.000 --> 00:04:31.000
이를 통해 웹 페이지의 기본 텍스트와 배경색이 현재 시스템 모양, 표준 양식 컨트롤 및 스크롤바와 일치할 수 있습니다.

00:04:31.000 --> 00:04:38.000
다른 명명된 시스템 색상은 라이트 모드와 다크 모드 사이를 전환하여 모양을 바꿉니다.

00:04:38.000 --> 00:04:44.000
스타일시트에서 색상이 참조되는 곳마다 스타일시트 변수를 사용하기 시작하세요.

00:04:44.000 --> 00:04:51.000
이를 통해 장치가 라이트와 다크 사이를 전환할 때 웹 콘텐츠가 색상을 업데이트할 수 있습니다.

00:04:51.000 --> 00:05:00.000
다른 모드에 대한 다른 변형으로 웹 페이지의 이미지 및 기타 미디어 자산에 동일한 논리를 적용하십시오.

00:05:00.000 --> 00:05:11.000
웹 콘텐츠에 다크 모드 구현에 대한 자세한 내용은 WWDC 2019의 "웹 콘텐츠에서 다크 모드 지원"을 참조하십시오.

00:05:11.000 --> 00:05:17.000
앱의 전력 사용량을 줄이는 또 다른 방법은 프레임 속도를 감사하는 것입니다.

00:05:17.000 --> 00:05:23.000
ProMotion 디스플레이가 있는 장치에서, 재생률은 전력 소비에 영향을 미칠 수 있다.

00:05:23.000 --> 00:05:26.000
더 높은 재생률은 더 높은 전력을 사용한다.

00:05:26.000 --> 00:05:32.000
앱의 애니메이션 프레임 속도는 디스플레이의 재생률을 결정합니다.

00:05:32.000 --> 00:05:42.000
앱의 모든 콘텐츠가 높은 프레임 속도를 필요로 하는 것은 아니기 때문에 앱의 기본 콘텐츠와 필요한 프레임 속도를 고려하십시오.

00:05:42.000 --> 00:05:48.000
디스플레이의 재생률은 앱에서 프레임 속도가 가장 높은 애니메이션에 의해 결정됩니다.

00:05:48.000 --> 00:06:00.000
앱에 필요한 것보다 더 높은 속도로 새로 고침되는 2차 요소가 있을 수 있으며, 이로 인해 앱 전체가 예상보다 더 많은 배터리를 소모할 수 있습니다.

00:06:00.000 --> 00:06:03.000
여기 푸드 트럭 앱이 다시 있습니다.

00:06:03.000 --> 00:06:08.000
상단의 주요 트럭 장면은 초당 30프레임으로 렌더링되고 있다.

00:06:08.000 --> 00:06:15.000
트럭 아래에는 수평으로 스크롤하는 텍스트 오버레이 "푸드 트럭"이 있습니다.

00:06:15.000 --> 00:06:19.000
이 보조 텍스트는 초당 60프레임으로 렌더링되고 있다.

00:06:19.000 --> 00:06:24.000
결과적으로, 전체 화면은 이제 초당 60프레임으로 렌더링되고 있다.

00:06:24.000 --> 00:06:33.000
텍스트 애니메이션을 30fps로 변경하면 전체 화면을 30fps로 렌더링할 수 있으며 배터리 소모의 최대 20%를 절약할 수 있습니다.

00:06:33.000 --> 00:06:36.000
굉장해!

00:06:36.000 --> 00:06:42.000
앱의 프레임 속도에 대한 자세한 정보를 디버깅하고 얻으려면, Instruments를 사용하세요.

00:06:42.000 --> 00:06:51.000
CoreAnimation FPS 도구를 사용하여 시간이 지남에 따라 앱의 프레임 속도를 보여주는 타임라인을 보세요.

00:06:51.000 --> 00:06:54.000
주요 사용자 시나리오를 감사하는 것으로 시작하세요.

00:06:54.000 --> 00:07:06.000
프레임이 예상 속도로 렌더링되고 있는지 확인하려면, 화면의 보조 요소가 기본 콘텐츠보다 프레임 속도가 높은지 결정하십시오.

00:07:06.000 --> 00:07:16.000
앱은 iOS에서 CoreAnimation에서 제공하는 CADisplayLink를 사용하여 사용자 지정 애니메이션과 사용자 지정 렌더링 루프를 구동할 수 있습니다.

00:07:16.000 --> 00:07:21.000
CADisplayLink는 디스플레이 재생률과 동기화된 타이머입니다.

00:07:21.000 --> 00:07:30.000
사용자 지정 도면이 새로 고침 이벤트를 인식할 수 있도록 앱에 필요한 타이밍 정보를 제공합니다.

00:07:30.000 --> 00:07:37.000
당신의 앱은 CADisplayLink 객체에 원하는 화면 재생률에 대한 힌트를 줄 수 있습니다.

00:07:37.000 --> 00:07:47.000
CADisplayLink의 기본 프레임 범위 설정을 설정하고 최소, 최대 및 기본 프레임 속도를 지정하십시오.

00:07:47.000 --> 00:07:55.000
그런 다음 디스플레이 링크는 시스템이 처리할 수 있는 것에 따라 원하는 속도에 가장 가까운 사용 가능한 프레임 속도를 선택합니다.

00:07:55.000 --> 00:08:02.000
만약 그것이 그 요금을 제공할 수 없다면, 그것은 당신의 지정된 범위 내에 머물려고 노력할 것입니다.

00:08:02.000 --> 00:08:07.000
디스플레이 링크를 구성하려면, 대상과 선택기로 초기화하세요.

00:08:07.000 --> 00:08:16.000
제공된 선택기는 사용자 지정 애니메이션을 수행하고 다음에 표시할 비디오 프레임을 계산하는 데 사용됩니다.

00:08:16.000 --> 00:08:20.000
디스플레이 링크가 초기화되면, 선호하는 프레임 속도 범위를 설정하세요.

00:08:20.000 --> 00:08:29.000
이 예에서, 선호하는 비율은 30이지만, 범위는 10에서 60 사이의 모든 것을 처리할 수 있다.

00:08:29.000 --> 00:08:34.000
마지막으로, 현재 실행 루프에 디스플레이 링크를 추가하세요.

00:08:34.000 --> 00:08:39.000
앱의 배터리 소비를 생각할 때 재생률을 염두에 두세요.

00:08:39.000 --> 00:08:47.000
이것은 매우 역동적인 재생률을 지원하는 ProMotion 디스플레이가 있는 장치에서 특히 중요합니다.

00:08:47.000 --> 00:08:55.000
앱을 출시하기 전에 Instruments로 앱의 프레임 속도를 모니터링하여 문제를 발견하십시오.

00:08:55.000 --> 00:09:05.000
마지막으로, CADisplayLink를 사용하여 앱에 대한 새로 고침 빈도를 제한하여 시스템에 정보를 제공하십시오.

00:09:05.000 --> 00:09:15.000
프레임 속도 최적화에 대해 자세히 알아보려면 WWDC 2021의 "가변 재생률 디스플레이 최적화"를 참조하십시오.

00:09:15.000 --> 00:09:21.000
이제, 백그라운드에서 실행될 때 앱의 전원을 뻄 수 있는 방법에 대해 이야기해 봅시다.

00:09:21.000 --> 00:09:31.000
누군가가 당신의 앱에서 다른 앱으로 전환할 때, 당신의 앱은 백그라운드 실행 API에 의존하여 백그라운드에서 계속 실행될 수 있습니다.

00:09:31.000 --> 00:09:39.000
백그라운드에서 실행하는 동안, 앱은 위치 및 오디오와 같은 일반적인 서비스를 계속 사용할 수 있습니다.

00:09:39.000 --> 00:09:49.000
이러한 서비스를 장기간 실행하면 배터리가 소모되므로, 앱이 백그라운드에서 이러한 서비스를 사용할 때 특히 주의해야 합니다!

00:09:49.000 --> 00:10:01.000
따라서 이러한 모드 위치 서비스를 사용할 때 과도한 드레인을 피하는 방법에 대해 이야기해 봅시다.

00:10:01.000 --> 00:10:10.000
앱이 사용자에게 보이지 않지만, 백그라운드에서 지속적으로 위치를 스트리밍할 수 있으며, 과도한 배터리 소모를 유발할 수 있습니다.

00:10:10.000 --> 00:10:17.000
앱에서 백그라운드 위치 세션 런타임 위에 있는지 확인하는 것이 중요합니다.

00:10:17.000 --> 00:10:25.000
세션이 더 이상 필요하지 않을 때, 앱이 stopUpdatingLocation()을 호출하여 세션을 중지하도록 하십시오.

00:10:25.000 --> 00:10:34.000
앱 개발의 다른 단계에서, 당신은 다른 도구를 사용하여 예상되지 않을 수도 있는 백그라운드 위치 사용을 찾을 수 있습니다.

00:10:34.000 --> 00:10:43.000
앱을 구축하고 테스트하는 동안, Xcode 게이지는 시스템 에너지 사용량과 백그라운드 위치 사용량을 알아내는 데 사용할 수 있습니다.

00:10:43.000 --> 00:10:51.000
출시 전에 앱을 테스트할 때, MetricKit을 사용하여 하루 동안 진단 정보를 수집할 수 있습니다.

00:10:51.000 --> 00:10:57.000
iOS 16의 새로운 기능은 제어 센터의 위치 사용이다.

00:10:57.000 --> 00:11:05.000
Xcode 게이지는 CPU, 네트워크 및 위치 사용과 같은 시스템 사용에 대한 정보를 제공합니다.

00:11:05.000 --> 00:11:11.000
Xcode 게이지는 앱의 위치 사용과 에너지 영향에 대한 타임라인을 표시합니다.

00:11:11.000 --> 00:11:20.000
이 타임라인 보기를 보는 것은 위치 런타임이 멈출 것으로 예상할 때 멈추는지 확인하는 좋은 방법이 될 수 있습니다.

00:11:20.000 --> 00:11:24.000
또 다른 도구는 앱을 테스트할 때 Metric Kit를 사용하는 것입니다.

00:11:24.000 --> 00:11:34.000
cumulativeBackgroundLocationTime 속성을 사용하여 앱이 백그라운드에서 위치 서비스를 얼마나 오랫동안 적극적으로 사용했는지 알아보세요.

00:11:34.000 --> 00:11:43.000
iOS 16의 새로운 기능, 사용자는 제어 센터로 이동하여 현재 위치 서비스를 사용하는 앱을 모니터링할 수 있습니다.

00:11:43.000 --> 00:11:49.000
그들은 위치를 사용하여 앱의 자세한 보기를 위해 상단의 텍스트를 탭할 수 있습니다.

00:11:49.000 --> 00:11:54.000
이것을 사용하여 위치 런타임에 대한 통찰력을 얻으세요.

00:11:54.000 --> 00:12:03.000
여기에 앱을 보고 예상하지 않는다면, 앱에 활성 위치 스트리밍 세션이 있다는 지표입니다.

00:12:03.000 --> 00:12:07.000
우리는 오디오 세션에 같은 원칙을 적용할 수 있다.

00:12:07.000 --> 00:12:15.000
일부 파일을 재생하기 위해 오디오 플레이어를 사용하는 음악 앱이 있고 사용자가 재생을 중단한다고 가정해 봅시다.

00:12:15.000 --> 00:12:26.000
앱은 사운드를 일시 중지하거나 중지해야 할 뿐만 아니라, 유휴 상태에서 실행되는 것을 방지하기 위해 오디오 엔진을 일시 중지하거나 중지해야 합니다.

00:12:26.000 --> 00:12:35.000
AVAudioEngine 클래스의 autoShutdownEnabled 속성을 설정하여 활성화할 수 있는 자동 종료 모드를 사용하는 것이 좋습니다.

00:12:35.000 --> 00:12:42.000
이 모드에서, 오디오 엔진은 특정 기간 동안 유휴 상태인지 지속적으로 모니터링하고 감지합니다.

00:12:42.000 --> 00:12:47.000
유휴 상태일 때, 엔진은 오디오 하드웨어를 종료할 것이다.

00:12:47.000 --> 00:12:54.000
그리고 나중에, 소스 중 하나라도 다시 활성화되면, 오디오 하드웨어를 동적으로 시작할 것이다.

00:12:54.000 --> 00:12:57.000
그리고 이 모든 것은 후드 아래에서 일어난다.

00:12:57.000 --> 00:13:02.000
watchOS에서 자동 종료 모드는 시행된 동작이다.

00:13:02.000 --> 00:13:07.000
전력을 절약하기 위해 사용하지 않을 때 오디오 엔진을 멈추세요.

00:13:07.000 --> 00:13:13.000
백그라운드 런타임을 제한하는 열쇠는 완료되면 시스템에 알려주는 것을 기억하는 것입니다.

00:13:13.000 --> 00:13:18.000
배터리 수명을 개선하기 위해 취할 수 있는 마지막 조치는 작업을 연기하는 것입니다.

00:13:18.000 --> 00:13:24.000
하루 동안, 당신의 앱은 다양한 작업과 데이터를 처리할 수 있습니다.

00:13:24.000 --> 00:13:37.000
이 작업 중 일부는 화면에 콘텐츠를 렌더링하거나 사용자가 탭하는 오디오 또는 비디오를 재생하는 것과 같은 사용자 작업을 서비스하기 위해 즉시 발생해야 합니다.

00:13:37.000 --> 00:13:45.000
기계 학습 작업, 분석 업로드 또는 백업과 같은 다른 작업은 시간에 민감하지 않습니다.

00:13:45.000 --> 00:13:56.000
이 시간에 민감하지 않은 작업을 장치가 충전 중일 때 더 나은 시간으로 연기하면 배터리를 절약하고 사용자가 시작한 대화형 작업과 경쟁하는 것을 피할 수 있습니다.

00:13:56.000 --> 00:14:01.000
이것을 달성하는 데 사용할 수 있는 세 가지 API에 대해 이야기해 봅시다.

00:14:01.000 --> 00:14:07.000
BGProcessingTask는 장기간 실행되는 작업을 연기하는 좋은 선택입니다.

00:14:07.000 --> 00:14:13.000
임의 URLSession은 연기 가능한 네트워킹을 예약할 수 있는 완벽한 선택입니다.

00:14:13.000 --> 00:14:19.000
그리고 올바른 푸시 우선 순위를 활용하면 서버가 적시에 푸시를 전달하는 데 도움이 될 수 있습니다.

00:14:19.000 --> 00:14:22.000
각각에 대해 자세히 살펴봅시다.

00:14:22.000 --> 00:14:24.000
첫 번째는 BGProcessingTask입니다.

00:14:24.000 --> 00:14:34.000
BGProcessingTask를 사용하면 장치가 충전 중일 때와 같이 장기 실행 처리 작업을 더 나은 시간으로 연기할 수 있습니다.

00:14:34.000 --> 00:14:41.000
데이터베이스 정리, 백업 생성, 기계 학습 교육 실행과 같은 작업에 적합합니다.

00:14:41.000 --> 00:14:50.000
그것을 사용하려면, BGProcessingTaskRequest API를 사용하여 요청을 만들고 애플리케이션 식별자를 제공하기만 하면 됩니다.

00:14:50.000 --> 00:14:57.000
그런 다음 작업에 외부 전원이나 네트워크가 필요한지와 같은 더 많은 정보를 제공하십시오.

00:14:57.000 --> 00:15:03.000
더 많은 정보를 제공하는 것은 시스템이 더 나은 시간대에 작업 일정을 잡는 데 도움이 될 것이다.

00:15:03.000 --> 00:15:12.000
그런 다음 시스템은 적절한 시간에 백그라운드에서 앱을 실행하고 지연 가능한 작업을 완료하기 위해 몇 분의 런타임을 부여합니다.

00:15:12.000 --> 00:15:16.000
다음은 임의 URL세션입니다.

00:15:16.000 --> 00:15:22.000
당신의 앱은 이미 일반 네트워킹을 위해 백그라운드 URLSessions를 사용하고 있을 수 있습니다.

00:15:22.000 --> 00:15:28.000
배경 URLSessions는 임의 플래그를 사용하면 훨씬 더 좋아집니다.

00:15:28.000 --> 00:15:42.000
임의 플래그가 있는 URLSessions는 장치가 연결되고 Wi-Fi에 연결될 때와 같이 보다 최적의 시간에 네트워킹을 수행하기 위해 시스템에 오프로드된 네트워킹 트랜잭션입니다.

00:15:42.000 --> 00:15:54.000
임의 플래그는 원격 측정 수집이나 TV 쇼의 다음 에피소드 다운로드와 같은 비사용자가 시작한 장기 실행 네트워킹에 적합합니다.

00:15:54.000 --> 00:16:03.000
그리고 네트워킹이 오프로드되었기 때문에, 네트워크 거래가 완료되는 동안 앱을 실행할 필요가 없다는 것을 의미합니다.

00:16:03.000 --> 00:16:14.000
임의 URL 세션을 사용하려면, 백그라운드 URL 세션을 설정하고 isDiscretionary를 true로 설정하기만 하면 됩니다.

00:16:14.000 --> 00:16:20.000
시스템이 적시에 다운로드 일정을 잡는 데 도움이 되는 추가 정보를 제공할 수 있습니다.

00:16:20.000 --> 00:16:28.000
시스템이 영원히 다운로드를 시도하지 않도록 시간 초과 간격을 전달하여 배터리가 소모됩니다.

00:16:28.000 --> 00:16:36.000
나중에 어느 시점까지 데이터를 업로드하거나 다운로드하고 싶지 않다면, 가장 빠른 시작 날짜를 전달하세요.

00:16:36.000 --> 00:16:48.000
마지막으로, 시스템이 다양한 다운로드 작업 간에 지능적으로 균형을 잡을 수 있도록 예상 작업량 크기를 전달하십시오.

00:16:48.000 --> 00:17:03.000
BGProcessingTask 및 임의 URL 세션으로 특정 작업의 즉각성을 제어할 수 있는 방법과 마찬가지로, 다른 푸시 우선 순위를 사용하여 푸시 전달의 즉각성에 영향을 미칠 수 있습니다.

00:17:03.000 --> 00:17:08.000
푸시 우선 순위는 푸시가 장치에 얼마나 긴급하게 전달되어야 하는지를 결정합니다.

00:17:08.000 --> 00:17:18.000
우선 순위가 높은 푸시의 경우, 서버는 즉시 푸시를 장치로 보내 잠재적으로 장치를 깨우고 배터리 소모를 일으킬 수 있습니다.

00:17:18.000 --> 00:17:29.000
우선 순위가 낮은 푸시의 경우, 서버는 장치가 깨어 있거나 우선 순위가 높은 푸시가 올 때와 같은 적절한 시간까지 푸시를 보내는 것을 지연시킬 것이다.

00:17:29.000 --> 00:17:34.000
우선 순위가 높은 푸시는 악천후 경고와 같은 긴급 메시지에 좋습니다.

00:17:34.000 --> 00:17:42.000
우선 순위가 낮은 푸시는 긴급하지 않고 연기될 수 있는 수동적인 알림에 적합합니다.

00:17:42.000 --> 00:17:52.000
지연 가능한 메시지의 전달을 지연시키기 위해 우선 순위가 낮은 푸시를 사용하면 장치가 수면에서 자주 깨어날 필요가 없으므로 배터리를 절약할 수 있습니다.

00:17:52.000 --> 00:17:59.000
우선 순위가 낮은 푸시를 구성하려면, 푸시 페이로드에서 apns-priority를 5로 설정하기만 하면 됩니다.

00:17:59.000 --> 00:18:06.000
서버가 나머지를 처리할 것이며, 사용자는 배터리 수명 절감에 감사할 것입니다.

00:18:06.000 --> 00:18:10.000
그래서 몇 가지 최종 생각과 다음 단계로 마무리합시다.

00:18:10.000 --> 00:18:13.000
앱에서 다크 모드 옵션을 제공하세요.

00:18:13.000 --> 00:18:18.000
사용자가 다크 모드를 선택하면, 그들의 의도를 존중하면 배터리를 절약할 수 있다.

00:18:18.000 --> 00:18:25.000
애니메이션을 검토하고 프레임 속도를 필요한 것으로 줄일 수 있는 기회를 찾으세요.

00:18:25.000 --> 00:18:28.000
하나의 작은 애니메이션은 큰 영향을 미칠 수 있다.

00:18:28.000 --> 00:18:34.000
완료되면 시스템에 알려줌으로써 배경 런타임을 면밀히 주시하세요.

00:18:34.000 --> 00:18:42.000
마지막으로, 장치가 충전기에 연결되어 있을 때와 같이 장기간 실행되는 백그라운드 작업을 더 나은 시간으로 연기하는 것을 고려하십시오.

00:18:42.000 --> 00:18:47.000
이 모든 것을 한다면, 당신은 진정으로 앱의 전원을 껄 것입니다.

00:18:47.000 --> 23:59:59.000
정말 고마워.

