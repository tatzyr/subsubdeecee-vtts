WEBVTT

00:00:00.000 --> 00:00:03.000
♪ 기악 힙합 음악 ♪

00:00:03.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:12.000
"AppKit과 함께 SwiftUI 사용"에 오신 것을 환영합니다.

00:00:12.000 --> 00:00:16.000
저는 단축키를 작업하는 엔지니어 이안입니다.

00:00:16.000 --> 00:00:20.000
macOS Monterey에서 단축키는 macOS에 왔다.

00:00:20.000 --> 00:00:23.000
단축키는 Mac에서 SwiftUI를 많이 사용한다.

00:00:23.000 --> 00:00:31.000
SwiftUI는 iOS 및 watchOS의 앱과 공통 뷰를 공유하면서 플랫폼의 경험을 사용자 정의하는 데 도움을 줍니다.

00:00:31.000 --> 00:00:40.000
이 비디오에서는 단축키의 몇 가지 예를 보고 Mac 앱에서 SwiftUI를 채택하는 방법을 보여드리겠습니다.

00:00:40.000 --> 00:00:50.000
먼저, 앱에서 SwiftUI 뷰를 호스팅하는 방법의 예를 보여준 다음, AppKit과 SwiftUI 간에 데이터를 전달하는 방법에 대해 이야기하겠습니다.

00:00:50.000 --> 00:01:12.000
또한 컬렉션 또는 테이블 뷰의 셀에서 SwiftUI 뷰 호스팅, AppKit에 포함될 때 SwiftUI 뷰의 레이아웃 및 크기 조정을 처리하는 방법, SwiftUI 뷰가 응답자 체인에 참여하고 집중할 수 있도록 하는 방법, 마지막으로 SwiftUI에서 AppKit 뷰를 호스팅하는 방법을 다룰 것입니다.

00:01:12.000 --> 00:01:16.000
좋아요, AppKit에서 SwiftUI를 호스팅하는 방법부터 시작하겠습니다.

00:01:16.000 --> 00:01:28.000
단축키에서 메인 창에는 AppKit 분할 보기 컨트롤러가 포함되어 있으며 왼쪽의 사이드바는 SwiftUI를 사용하여 작성됩니다.

00:01:28.000 --> 00:01:38.000
사이드바 보기는 SwiftUI 목록으로 구현되며, 목록에는 앱에서 탐색할 수 있는 모든 장소의 행이 있는 섹션이 표시됩니다.

00:01:38.000 --> 00:01:45.000
보기는 선택한 항목 바인딩을 통해 선택한 항목을 추적합니다.

00:01:45.000 --> 00:01:53.000
선택할 수 있는 가능한 항목은 SidebarItem 유형의 사례로 표시됩니다.

00:01:53.000 --> 00:01:56.000
이 경우, 이미 분할 뷰 컨트롤러가 있기 때문에.

00:01:56.000 --> 00:02:03.000
이 사이드바 뷰를 호스팅하기 위해, 우리는 NSHostingController라는 SwiftUI의 클래스를 사용합니다.

00:02:03.000 --> 00:02:10.000
SwiftUI 사이드바 보기는 해당 호스팅 컨트롤러의 루트 보기로 전달됩니다.

00:02:10.000 --> 00:02:23.000
호스팅 컨트롤러는 다른 뷰 컨트롤러와 마찬가지로 사용할 수 있기 때문에, 여기서 우리는 그것을 splitViewItem으로 구성하고 splitViewController에 추가합니다.

00:02:23.000 --> 00:02:35.000
이제 사이드바는 분할 보기에서 호스팅되지만, 선택이 변경될 때 작동하려면 분할 보기의 오른쪽에 다른 페이지를 표시해야 합니다.

00:02:35.000 --> 00:02:40.000
현재, 선택된 항목 상태는 SwiftUI 내에만 존재합니다.

00:02:40.000 --> 00:02:47.000
우리가 해야 할 일은 그것을 분할 보기와 사이드바 사이에서 공유할 수 있는 장소로 옮기는 것이다.

00:02:47.000 --> 00:02:56.000
이를 수행하는 좋은 방법은 SwiftUI 외부에 저장하고 공유해야 하는 상태를 포함할 수 있는 모델 객체를 만드는 것입니다.

00:02:56.000 --> 00:02:59.000
나는 이 객체를 SelectionModel이라고 부를 것이다.

00:02:59.000 --> 00:03:05.000
이제, 사이드바는 여전히 SelectionModel의 상태를 읽고 쓸 수 있습니다.

00:03:05.000 --> 00:03:11.000
코드에서, SelectionModel은 ObservableObject를 준수하는 클래스이다.

00:03:11.000 --> 00:03:18.000
관찰 가능한 객체이기 때문에 SwiftUI는 모델에 저장된 상태가 변경될 때 뷰를 다시 로드할 수 있습니다.

00:03:18.000 --> 00:03:23.000
현재 선택된 사이드바 항목을 저장합니다.

00:03:23.000 --> 00:03:31.000
이 속성은 선택한 항목이 변경될 때 SwiftUI 사이드바 보기를 업데이트할 수 있도록 게시됩니다.

00:03:31.000 --> 00:03:39.000
누군가가 사이드바에서 선택을 변경할 때마다, 모델은 세부 보기에 새 페이지를 표시할 수 있습니다.

00:03:39.000 --> 00:03:46.000
이제 AppKit에서 SwiftUI를 호스팅하는 방법을 다루었으니, 컬렉션과 테이블 셀로 넘어가겠습니다.

00:03:46.000 --> 00:04:00.000
다른 플랫폼에서 macOS로 단축키를 가져올 때, 이미 컬렉션 뷰 셀이나 홈 화면 위젯에 단축키를 표시하도록 만들어진 상징적인 SwiftUI 뷰가 있었다.

00:04:00.000 --> 00:04:06.000
macOS에서, 이러한 동일한 보기는 NSCollectionView의 셀에 표시됩니다.

00:04:06.000 --> 00:04:17.000
많은 항목이 있는 컬렉션이나 테이블 뷰에서, 각 셀 뷰는 스크롤할 때 재활용되어 시간이 지남에 따라 다른 콘텐츠를 보여줍니다.

00:04:17.000 --> 00:04:26.000
셀 재사용이 수행되는지 확인하려면, 사용자가 스크롤할 때 셀에서 하위 뷰를 추가하거나 제거하는 것을 피해야 합니다.

00:04:26.000 --> 00:04:37.000
각 셀에 SwiftUI 뷰를 표시할 때, 단일 호스팅 뷰를 사용하고 셀의 콘텐츠를 변경해야 할 때 다른 루트 뷰로 업데이트하십시오.

00:04:37.000 --> 00:04:42.000
SwiftUI를 호스팅하기 위해 컬렉션 뷰 셀을 만드는 데 필요한 모든 것은 다음과 같습니다.

00:04:42.000 --> 00:04:47.000
여기 예시에서, 저는 바로 가기 보기를 표시하는 셀을 만들고 있습니다.

00:04:47.000 --> 00:04:52.000
각 셀에는 SwiftUI를 호스팅하기 위한 NSHostingView가 포함되어 있습니다.

00:04:52.000 --> 00:05:03.000
셀은 콘텐츠로 구성되기 전에 생성되기 때문에, 이것은 nil로 시작되며, 바로 가기가 처음 표시될 준비가 되면 설정됩니다.

00:05:03.000 --> 00:05:10.000
displayShortcut 메서드는 단축키를 표시하도록 셀을 구성할 때 데이터 소스에 의해 호출됩니다.

00:05:10.000 --> 00:05:14.000
이 방법은 SwiftUI ShortcutView를 만듭니다.

00:05:14.000 --> 00:05:21.000
그런 다음, 이미 hostingView가 있다면, 그 hostingView의 rootView는 새 보기로 설정됩니다.

00:05:21.000 --> 00:05:30.000
그렇지 않으면, 처음이라면, newHostingView가 생성되고 셀의 하위 뷰로 추가됩니다.

00:05:30.000 --> 00:05:34.000
여기 SwiftUI를 호스팅하는 셀의 수명 주기가 있습니다.

00:05:34.000 --> 00:05:41.000
먼저, 셀은 초기화되고 아직 표시할 바로 가기가 없기 때문에 하위 뷰 없이 시작됩니다.

00:05:41.000 --> 00:05:49.000
displayShortcut이 처음 호출될 때, hostingView는 표시할 shortcutView로 생성됩니다.

00:05:49.000 --> 00:05:59.000
이것은 VStack, 이미지, 스페이서 및 두 개의 텍스트 뷰를 포함하는 SwiftUI 뷰 계층 구조를 만듭니다.

00:05:59.000 --> 00:06:08.000
이 셀이 화면에서 스크롤되면, 잠재적으로 시스템에 의해 중단되고 다른 단축키를 표시해야 합니다.

00:06:08.000 --> 00:06:15.000
이런 일이 발생하면, 새로운 ShortcutView가 만들어지고 HostingView에 제공됩니다.

00:06:15.000 --> 00:06:30.000
HostingView는 이미 다른 바로 가기 보기를 표시하고 있었기 때문에 VStack과 스페이서를 포함한 보기의 전체 구조를 재사용하고 변경된 이미지, 텍스트 및 배경만 업데이트합니다.

00:06:30.000 --> 00:06:35.000
좋아, 다음으로, 레이아웃과 크기에 대해 이야기해 보자.

00:06:35.000 --> 00:06:43.000
호스팅 컨트롤러와 호스팅 뷰는 SwiftUI 뷰의 이상적인 너비와 높이에 따라 본질적인 크기를 가지고 있습니다.

00:06:43.000 --> 00:06:53.000
SwiftUI는 AppKit 레이아웃 시스템이 보기의 크기를 적절하게 조정하는 데 사용하는 자동 레이아웃 제약을 자동으로 만들고 업데이트합니다.

00:06:53.000 --> 00:07:00.000
견해는 또한 유연하며, 이는 최소와 최대 사이의 다양한 크기를 지원한다는 것을 의미한다.

00:07:00.000 --> 00:07:05.000
SwiftUI는 이것들에 대한 제약도 만든다.

00:07:05.000 --> 00:07:15.000
계층 구조에 SwiftUI 호스팅 뷰를 포함할 때, 슈퍼뷰 또는 다른 인접한 뷰에 자체 자동 레이아웃 제약 조건을 적용해야 합니다.

00:07:15.000 --> 00:07:28.000
프레임 수정자 또는 기타 SwiftUI 레이아웃을 사용하면 너비를 고정 크기로 재정의하는 것과 같이 생성된 제약 조건이 업데이트됩니다.

00:07:28.000 --> 00:07:35.000
윈도우는 사용자가 크기를 조정할 수 있기 때문에, 최소 및 최대 크기를 가지고 있다.

00:07:35.000 --> 00:07:47.000
HostingViews가 창의 최상위 contentView로 설정되면, SwiftUI는 표시되는 콘텐츠에 따라 해당 창의 최소 및 최대 크기를 자동으로 업데이트합니다.

00:07:47.000 --> 00:07:55.000
그리고 이것은 콘텐츠에 따라 창의 크기를 수직, 수평 또는 둘 다 조정할 수 있게 해준다.

00:07:55.000 --> 00:08:02.000
호스팅 컨트롤러에 배치된 SwiftUI 뷰는 모달 방식으로 제시될 때 콘텐츠에 따라 크기가 조정됩니다.

00:08:02.000 --> 00:08:15.000
예를 들어, 여기에 표시된 것처럼 NSViewController에서 팝오버 프레젠테이션 API를 사용하여 호스팅 컨트롤러를 제시하여 SwiftUI 뷰를 AppKit 팝오버에 쉽게 배치할 수 있습니다.

00:08:15.000 --> 00:08:20.000
presentAsSheet 방법을 사용하여 SwiftUI 뷰를 시트로 표시할 수도 있습니다.

00:08:20.000 --> 00:08:30.000
그리고 마지막으로, 모달 창의 경우, presentAsModalWindow 방법을 사용하여 닫힐 때까지 상호 작용을 차단하는 창을 제시할 수 있습니다.

00:08:30.000 --> 00:08:34.000
창문은 내용에 맞게 크기가 조정되었다.

00:08:34.000 --> 00:08:45.000
macOS Ventura에는 NSHostingView와 NSHostingController에 자동으로 추가되는 제약 조건을 사용자 정의할 수 있는 새로운 API가 있습니다.

00:08:45.000 --> 00:08:53.000
기본적으로 호스팅 컨트롤러와 뷰는 최소 크기, 고유 크기 및 최대 크기에 대한 제약을 만듭니다.

00:08:53.000 --> 00:09:05.000
보기를 항상 유연하게 조정하거나 AppKit의 주변 보기에 제약이 이미 추가된 경우 성능상의 이유로 이들 중 일부를 비활성화할 수 있습니다.

00:09:05.000 --> 00:09:15.000
호스팅 컨트롤러의 경우, 이상적인 보기 크기가 선호하는 콘텐츠 크기를 결정하도록 하려면, preferredContentSize 옵션을 활성화할 수 있습니다.

00:09:15.000 --> 00:09:26.000
앱에 SwiftUI 뷰를 추가하기 시작하면, 앱의 다른 뷰와 마찬가지로 응답자 체인과 포커스 시스템에 참여하는 것이 중요합니다.

00:09:26.000 --> 00:09:32.000
단축키에서, 우리의 편집기는 SwiftUI 뷰로 구현됩니다.

00:09:32.000 --> 00:09:40.000
하지만 편집기는 AppKit에서 구현된 메인 메뉴에 정의된 메뉴 표시줄 명령을 처리해야 합니다.

00:09:40.000 --> 00:09:45.000
이러한 명령에는 잘라내기, 복사, 붙여넣기 등이 포함됩니다.

00:09:45.000 --> 00:09:52.000
우리는 작업을 위아래로 이동하기 위해 몇 가지 사용자 지정 메뉴 항목도 구현했습니다.

00:09:52.000 --> 00:09:58.000
AppKit에서 뷰 계층 구조는 "응답자 체인"이라고 불리는 뷰 체인을 구성합니다.

00:09:58.000 --> 00:10:02.000
집중된 응답자는 첫 번째 응답자라고 불린다.

00:10:02.000 --> 00:10:08.000
메뉴 항목이 선택되면, 해당 항목의 선택기가 첫 번째 응답자에게 전송됩니다.

00:10:08.000 --> 00:10:20.000
하지만 첫 번째 응답자가 그 셀렉터에 응답하지 않으면, 셀렉터는 무언가가 셀렉터를 처리하거나 앱에 도달할 때까지 각 다음 응답자에게 전송됩니다.

00:10:20.000 --> 00:10:26.000
SwiftUI의 첫 번째 응답자와 동등한 것은 집중된 관점이다.

00:10:26.000 --> 00:10:35.000
집중 가능한 SwiftUI 뷰는 키보드 입력에 응답하고 응답자 체인으로 전송된 핸들 선택기를 처리할 수 있습니다.

00:10:35.000 --> 00:10:46.000
텍스트 필드와 같은 일부 보기는 이미 초점을 맞출 수 있지만, 초점을 맞출 수 있는 수정자를 사용하여 다른 보기도 초점을 맞출 수 있습니다.

00:10:46.000 --> 00:10:52.000
SwiftUI에는 복사, 잘라내기 및 붙여넣기와 같은 일반적인 명령을 처리하는 몇 가지 수정자가 있습니다.

00:10:52.000 --> 00:11:00.000
이것들은 페이스트보드 안팎으로 값을 전달하며, 사람들이 앱 안팎으로 데이터를 전송할 수 있는 쉬운 방법입니다.

00:11:00.000 --> 00:11:09.000
단축키 편집기는 onMoveCommand 및 onExit 명령 수정자를 사용하여 화살표 키와 이스케이프 키를 처리합니다.

00:11:09.000 --> 00:11:17.000
onCommand 수정자는 AppKit의 일반적인 선택기 또는 앱에 정의된 사용자 지정 선택기를 처리하는 데 사용할 수 있습니다.

00:11:17.000 --> 00:11:28.000
여기서, 우리는 AppKit의 selectAll 명령과 단축키 앱에 정의된 moveActionUp 및 moveActionDown 명령을 처리합니다.

00:11:28.000 --> 00:11:44.000
앱에서 초점과 키보드 탐색성을 테스트할 때, 키보드 시스템 설정을 열고 전체 키보드 탐색을 켜고 끄고 테스트해야 합니다. 많은 컨트롤이 활성화된 경우에만 초점을 맞출 수 있기 때문입니다.

00:11:44.000 --> 00:11:48.000
앱이 키보드로 잘 작동하도록 하기 위해 할 수 있는 일이 훨씬 더 많습니다.

00:11:48.000 --> 00:11:58.000
예를 들어, FocusState와 같은 API와 포커스된 뷰를 프로그래밍 방식으로 변경할 수 있는 포커스 수정자가 있습니다.

00:11:58.000 --> 00:12:06.000
초점과 키보드에 대해 자세히 알아보려면, "SwiftUI에서 직접 및 초점 반영" 비디오를 시청해야 합니다.

00:12:06.000 --> 00:12:11.000
마지막으로, SwiftUI에서 AppKit 뷰를 호스팅하는 것에 대해 이야기해 봅시다.

00:12:11.000 --> 00:12:24.000
단축키가 SwiftUI 레이아웃 내에서 AppKit 뷰를 호스팅하는 경우가 있으며, 앱에서 SwiftUI를 채택할 때 AppKit 뷰를 호스팅해야 할 수도 있습니다.

00:12:24.000 --> 00:12:37.000
한 가지 예는 SwiftUI 단축키 편집기 내부에 있으며, macOS의 다른 몇 가지 시스템 앱과 공유되는 AppKit 컨트롤인 AppleScript 편집기 보기가 내장되어 있습니다.

00:12:37.000 --> 00:12:48.000
SwiftUI는 AppKit 뷰와 뷰 컨트롤러가 SwiftUI 뷰 계층에 포함될 수 있는 두 가지 표현 가능한 프로토콜을 제공합니다.

00:12:48.000 --> 00:12:57.000
SwiftUI 뷰와 마찬가지로, representables는 AppKit 뷰를 만들고 업데이트하는 방법에 대한 설명입니다.

00:12:57.000 --> 00:13:15.000
AppKit의 많은 클래스에는 대의원, 관찰자 또는 KVO 또는 관찰할 알림에 의존하기 때문에, 프로토콜에는 뷰 또는 뷰 컨트롤러와 함께 구현할 수 있는 선택적 코디네이터 객체도 포함되어 있습니다.

00:13:15.000 --> 00:13:20.000
여기 호스팅된 객체와 코디네이터의 수명 주기가 있습니다.

00:13:20.000 --> 00:13:23.000
우리는 호스팅된 뷰가 초기화되는 것으로 시작합니다.

00:13:23.000 --> 00:13:28.000
이것은 뷰가 처음으로 표시될 때 발생한다.

00:13:28.000 --> 00:13:33.000
SwiftUI가 초기화하는 동안 가장 먼저 하는 일은 코디네이터를 만드는 것이다.

00:13:33.000 --> 00:13:41.000
이것은 선택 사항이지만, 위임 또는 국가 관리를 위해 필요한 경우 자신만의 유형을 정의하고 makeCoordinator에서 반환할 수 있습니다.

00:13:41.000 --> 00:13:47.000
코디네이터의 단일 인스턴스는 뷰의 평생 동안 주변에 머무를 것이다.

00:13:47.000 --> 00:13:53.000
둘째, makeNSView 또는 makeNSViewController 메소드가 호출됩니다.

00:13:53.000 --> 00:14:00.000
이것은 당신이 SwiftUI에 당신의 뷰의 새로운 인스턴스를 만드는 방법을 설명하는 곳입니다.

00:14:00.000 --> 00:14:13.000
문맥에는 방금 만들어진 코디네이터가 포함되어 있으므로, 여기에 코디네이터를 뷰의 대리인 또는 다른 유형의 관찰자로 할당하기에 좋은 장소가 있습니다.

00:14:13.000 --> 00:14:22.000
뷰가 생성되면, SwiftUI 상태나 환경이 변경될 때마다 업데이트 뷰 메소드가 호출됩니다.

00:14:22.000 --> 00:14:33.000
여기서, AppKit 보기에 저장된 속성이나 상태를 업데이트하여 주변 SwiftUI 상태 및 환경과 동기화하는 것은 귀하의 책임입니다.

00:14:33.000 --> 00:14:40.000
업데이트 방법은 자주 호출될 수 있으므로, 보기에 대한 변경 사항은 가능한 한 최소화되어야 합니다.

00:14:40.000 --> 00:14:47.000
무엇이 변경되었는지 확인하고 변경될 때만 보기의 영향을 받는 부분을 다시 로드해야 합니다.

00:14:47.000 --> 00:14:53.000
SwiftUI가 호스팅된 보기를 표시하면, 해체될 것이다.

00:14:53.000 --> 00:14:57.000
호스팅된 뷰와 코디네이터는 둘 다 할당될 것이다.

00:14:57.000 --> 00:15:06.000
이것들이 할당되기 전에, 표현 가능한 프로토콜은 필요한 경우 상태를 정리할 수 있는 선택적 구현 방법을 제공합니다.

00:15:06.000 --> 00:15:18.000
좋아요, 이제 수명 주기를 알고 있고 표현 가능한 프로토콜에 익숙해졌으니, 단축키가 앱에서 사용자 지정 스크립트 편집기 보기를 호스팅하는 방법을 보여드리겠습니다.

00:15:18.000 --> 00:15:22.000
스크립트 편집기는 ScriptEditorView라고 불리는 NSView이다.

00:15:22.000 --> 00:15:32.000
편집기에 작성된 코드는 sourceCode 속성을 통해 액세스하고 수정할 수 있으며, 변경되지 않도록 보기를 비활성화할 수 있습니다.

00:15:32.000 --> 00:15:40.000
스크립트 편집기에는 또한 누군가가 소스 코드를 수정할 때마다 알림을 받는 대리인이 있다.

00:15:40.000 --> 00:15:50.000
AppKit 뷰를 호스팅할 때, 먼저 SwiftUI에서 뷰가 어디에 배치될지, 그리고 어떤 데이터를 전달해야 하는지 생각해 보세요.

00:15:50.000 --> 00:15:57.000
단축키에서, 이 보기는 컴파일 버튼 옆에 있는 컨테이너 보기에 배치됩니다.

00:15:57.000 --> 00:16:03.000
컴파일 버튼의 핸들러는 뷰에 입력된 소스 코드에 액세스해야 합니다.

00:16:03.000 --> 00:16:08.000
소스 코드는 State 속성 래퍼를 사용하여 SwiftUI에 저장됩니다.

00:16:08.000 --> 00:16:13.000
대표자는 이 상태를 읽고 써야 할 것이다.

00:16:13.000 --> 00:16:22.000
대표성을 구축하려면, NSViewRepresentable을 호스팅하기 때문에 NSViewRepresentable을 준수하는 유형을 만드는 것으로 시작하세요.

00:16:22.000 --> 00:16:28.000
SwiftUI에서 구성해야 하는 각 것에 대한 속성을 추가하세요.

00:16:28.000 --> 00:16:36.000
소스 코드의 경우 바인딩이 사용되며, 이는 SwiftUI에 저장된 상태를 읽고 쓸 것이다.

00:16:36.000 --> 00:16:40.000
구현해야 할 첫 번째 방법은 makeNSView입니다.

00:16:40.000 --> 00:16:47.000
다음은 뷰의 새로운 인스턴스를 만드는 방법과 필요한 일회성 설정을 수행해야 하는 곳입니다.

00:16:47.000 --> 00:16:51.000
여기서, 대리인은 코디네이터에게 배정되었다.

00:16:51.000 --> 00:16:55.000
조금 있다가 코디네이터에 대해 더 얘기할게.

00:16:55.000 --> 00:16:58.000
다음으로, updateNSView를 구현하세요.

00:16:58.000 --> 00:17:05.000
이것은 소스 코드가 변경되거나 SwiftUI 환경이 변경될 때 호출됩니다.

00:17:05.000 --> 00:17:17.000
스크립트 편집기는 소스코드 속성이 설정될 때 많은 작업을 하기 때문에, 우리는 이미 뷰에 있는 값을 비교하고, 불필요한 작업을 피하기 위해 변경되는 경우에만 속성을 설정합니다.

00:17:17.000 --> 00:17:23.000
updateNSView에 전달된 컨텍스트에는 SwiftUI 환경이 포함되어 있습니다.

00:17:23.000 --> 00:17:35.000
isEnabled 환경 키는 스크립트 편집기의 isEditable 속성으로 전달되므로 나머지 SwiftUI 뷰 계층 구조가 있으면 편집이 비활성화됩니다.

00:17:35.000 --> 00:17:42.000
누군가가 뷰에서 소스 코드를 수정할 때마다, 소스 코드 바인딩은 새로운 값을 캡처해야 합니다.

00:17:42.000 --> 00:17:49.000
이를 위해, 우리는 ScriptEditorViewDelegate를 준수하는 코디네이터를 만들 것입니다.

00:17:49.000 --> 00:17:56.000
코디네이터는 업데이트해야 하는 소스 코드 바인딩이 포함된 표현 가능한 값을 저장할 것이다.

00:17:56.000 --> 00:18:04.000
그리고 sourceCodeDidChange 메소드에서 바인딩은 뷰에서 새 문자열 값으로 설정됩니다.

00:18:04.000 --> 00:18:10.000
마지막으로, 우리는 SwiftUI에게 코디네이터를 만들고 업데이트하는 방법을 말해야 합니다.

00:18:10.000 --> 00:18:17.000
먼저, 새로운 코디네이터를 만들기 위해 makeCoordinator 방법을 구현해야 합니다.

00:18:17.000 --> 00:18:29.000
코디네이터는 호스팅된 뷰와 같은 수명을 가지며, 호스팅된 뷰와 마찬가지로 코디네이터에 추가하는 속성은 표현 가능한 변경 사항으로 최신 상태로 유지되어야 합니다.

00:18:29.000 --> 00:18:40.000
updateNSView는 표현 가능한 변경에 저장된 값이 있을 때 호출되기 때문에, 여기서 코디네이터의 표현 가능한 속성이 업데이트됩니다.

00:18:40.000 --> 00:18:50.000
이제 SwiftUI에 AppKit을 추가하고 AppKit에 SwiftUI를 추가하는 방법을 알았으므로 SwiftUI를 앱에 통합하기 시작해야 합니다.

00:18:50.000 --> 00:18:55.000
시작하기에 좋은 곳은 사이드바 또는 테이블 및 컬렉션 보기 셀에 있습니다.

00:18:55.000 --> 00:19:01.000
당신의 견해가 정확하게 크기를 조정하고 일반적인 명령과 초점을 다루고 있는지 확인하세요.

00:19:01.000 --> 23:59:59.000
시간 내줘서 고마워, 그리고 네가 뭘 만드는지 빨리 보고 싶어 ♪

