WEBVTT

00:00:00.000 --> 00:00:13.000
- 안녕! 저는 켄트이고 CloudKit 팀의 엔지니어입니다.

00:00:13.000 --> 00:00:18.000
CloudKit에 액세스하는 데 사용할 수 있는 새로운 라이브러리를 소개하게 되어 기쁩니다.

00:00:18.000 --> 00:00:21.000
먼저, 이 새로운 라이브러리를 구성하는 방법을 다루겠습니다.

00:00:21.000 --> 00:00:27.000
그런 다음 스키마를 관리하는 방법과 CKTool JS로 사용자 데이터에 액세스하는 방법을 배우게 될 것입니다.

00:00:27.000 --> 00:00:29.000
시작하자!

00:00:29.000 --> 00:00:35.000
CloudKit은 앱의 데이터를 컨테이너 내의 iCloud에 저장할 수 있는 지속성 기술입니다.

00:00:35.000 --> 00:00:42.000
앱에서 CloudKit을 사용하면 장치와 웹에서 데이터를 최신 상태로 유지할 수 있습니다.

00:00:42.000 --> 00:00:51.000
앱을 구축하기 위해, Apple 플랫폼의 CloudKit 프레임워크 또는 웹의 CloudKit JS를 사용하여 iCloud 스토리지에 액세스할 수 있습니다.

00:00:51.000 --> 00:00:57.000
자동화와 툴링을 구현하기 위해, Xcode는 macOS에서 사용할 수 있는 cktool을 제공합니다.

00:00:57.000 --> 00:01:03.000
그리고 이제 CKTool JS를 사용하여 변경 사항을 자동화하고 iCloud와 상호 작용할 수 있는 새로운 방법이 있습니다.

00:01:03.000 --> 00:01:13.000
CKTool JS를 사용하면 Xcode 13에 도입된 cktool 명령줄 유틸리티와 동일한 작업을 수행할 수 있으며 유사한 사용 사례를 지원합니다.

00:01:13.000 --> 00:01:21.000
사실, CKTool JS는 레코드 유형을 추가하고 레코드를 쿼리하는 것과 같은 CloudKit 콘솔의 기능을 구현하는 데 사용됩니다.

00:01:21.000 --> 00:01:29.000
CKTool JS를 사용하면 앱 컨테이너를 관리하고 스키마에 대한 업데이트 재설정 및 적용과 같은 스키마 작업을 수행할 수 있습니다.

00:01:29.000 --> 00:01:33.000
이것은 이전에 자바스크립트에서 할 수 없었던 일입니다.

00:01:33.000 --> 00:01:39.000
CKTool JS를 사용하면 고유 식별자를 사용하거나 복잡한 쿼리를 통해 기존 레코드를 가져올 수 있습니다.

00:01:39.000 --> 00:01:43.000
그리고 새 레코드를 만들고 업데이트할 수 있습니다.

00:01:43.000 --> 00:01:47.000
CKTool JS는 TypeScript에 대한 엄격한 유형 정의와 함께 제공됩니다.

00:01:47.000 --> 00:01:55.000
이러한 유형 정의는 클라이언트 라이브러리의 잘못된 사용을 플래그하는 컴파일 타임 검사를 가능하게 하고 지원되는 IDE에서 코드 완성을 가능하게 합니다.

00:01:55.000 --> 00:02:00.000
이것 때문에 CKTool JS 코드를 더 쉽게 편집할 수 있습니다.

00:02:00.000 --> 00:02:05.000
또한, 이 새로운 라이브러리는 Node.js와 브라우저를 모두 지원합니다.

00:02:05.000 --> 00:02:13.000
CKTool JS는 자바스크립트 빌드 파이프라인의 일부로 통합할 수 있는 npm 패키지 세트로 배포됩니다.

00:02:13.000 --> 00:02:18.000
그렇게 하면 나무를 흔들고 묶는 것과 같은 기능을 사용할 수 있다.

00:02:18.000 --> 00:02:26.000
릴리스 기록이 npm에서 투명하게 제공되기 때문에 이러한 패키지에 대한 업데이트를 추적할 수도 있습니다.

00:02:26.000 --> 00:02:29.000
다음 패키지는 CKTool JS 배포판의 일부입니다.

00:02:29.000 --> 00:02:38.000
이 패키지들은 @apple 범위 내에 있으며 이름의 시작 부분에서 cktool을 사용하는 규칙을 따릅니다.

00:02:38.000 --> 00:02:42.000
당신이 사용할 주요 패키지는 cktool.database입니다.

00:02:42.000 --> 00:02:57.000
iCloud와의 통신을 활성화하려면, 대상 플랫폼에 다른 패키지, Node.js용 cktool.target.nodejs 또는 웹 브라우저용 cktool.target.browser를 사용해야 합니다.

00:02:57.000 --> 00:03:10.000
Cktool.database는 cktool.core, cktool.api.base 및 cktool.api.database의 세 가지 패키지를 자동으로 가져옵니다.

00:03:10.000 --> 00:03:15.000
CKTool JS는 iCloud와 직접 통신하기 때문에, 먼저 승인을 받아야 합니다.

00:03:15.000 --> 00:03:21.000
호출하려는 작업에 따라 관리 토큰이나 사용자 토큰이 필요합니다.

00:03:21.000 --> 00:03:25.000
두 종류의 토큰 모두 CloudKit 콘솔에서 얻을 수 있습니다.

00:03:25.000 --> 00:03:31.000
관리 토큰은 관리 작업에 액세스하는 데 사용되며 팀과 사용자에게 적용됩니다.

00:03:31.000 --> 00:03:39.000
이러한 작업에는 스키마 가져오기 및 내보내기, 스키마 유효성 검사, 컨테이너를 생산으로 재설정하는 것이 포함됩니다.

00:03:39.000 --> 00:03:46.000
사용자 토큰은 팀과 컨테이너로 범위가 지정되며 해당 컨테이너 내의 개인 사용자 데이터에 액세스할 수 있습니다.

00:03:46.000 --> 00:03:58.000
이러한 인증 토큰과 CloudKit과의 지속적인 통합을 얻는 방법을 배우려면, WWDC21의 "cktool 및 선언적 스키마로 CloudKit 테스트 자동화"를 확인하세요.

00:03:58.000 --> 00:04:03.000
스크립트에서 CKTool JS를 사용하고 싶을 때마다, 먼저 사용하도록 구성해야 합니다.

00:04:03.000 --> 00:04:09.000
하지만 CKTool JS를 구성하기 전에, CloudKit 스키마를 구성하는 것에 대한 빠른 검토를 할 것이다.

00:04:09.000 --> 00:04:13.000
CloudKit에서 데이터는 구조화된 방식으로 저장됩니다.

00:04:13.000 --> 00:04:18.000
같은 종류의 값을 가진 데이터는 레코드로 함께 저장됩니다.

00:04:18.000 --> 00:04:25.000
레코드는 레코드 유형의 인스턴스이며, 레코드 유형이 설명하는 레코드의 속성은 필드로 알려져 있다.

00:04:25.000 --> 00:04:32.000
CloudKit은 사용자 정의 필드 외에도 레코드의 ID인 recordName과 같은 시스템 필드를 추가합니다.

00:04:32.000 --> 00:04:35.000
나는 내가 작업하고 있는 동전 수집 앱의 예시를 사용할 것이다.

00:04:35.000 --> 00:04:42.000
나는 국가 컬렉션을 저장하고 싶기 때문에, 어떤 종류의 자산을 저장해야 하는지 설명할 수 있는 기록 유형이 있다.

00:04:42.000 --> 00:04:47.000
저는 이름과 ISO 코드를 저장하고 있으며, 레코드 유형을 "국가"라고 명명하고 있습니다.

00:04:47.000 --> 00:04:53.000
ISO 코드는 국가를 고유하게 식별하므로, 내 기록 유형에 포함시키는 것이 중요합니다.

00:04:53.000 --> 00:04:58.000
나는 그들의 이름과 함께 이 정보를 저장하기 위해 국가 유형의 기록을 만든다.

00:04:58.000 --> 00:05:03.000
나는 또한 특정 국가의 동전에 대한 기록 유형을 가지고 있으며, 그것들을 서로 연관시키고 싶다.

00:05:03.000 --> 00:05:10.000
동전 기록 유형은 동전에서 국가와의 관계를 저장한다.

00:05:10.000 --> 00:05:13.000
레코드 유형과 관계가 결합되어 스키마를 만든다.

00:05:13.000 --> 00:05:18.000
나는 이 요소들의 현재 상태를 내 스키마의 현재 버전으로 간주할 수 있다.

00:05:18.000 --> 00:05:26.000
앱을 개발할 때, 스키마를 발전시킬 것이며, 앱의 수명 동안 여러 버전을 갖게 될 것입니다.

00:05:26.000 --> 00:05:33.000
내 앱의 스키마는 내가 iCloud에 저장하고 싶은 데이터의 구조를 설명하지만, 내 앱 컨테이너는 그 데이터가 저장되는 곳이다.

00:05:33.000 --> 00:05:38.000
컨테이너는 고유 식별자를 가지고 있으며 개발자 팀과 연결되어 있다.

00:05:38.000 --> 00:05:43.000
CloudKit으로 작업할 때 명심해야 할 두 가지 환경이 있습니다.

00:05:43.000 --> 00:05:47.000
개발 환경은 사용자를 방해하지 않고 변경할 수 있는 안전한 장소이다.

00:05:47.000 --> 00:05:51.000
이것은 당신이 당신의 스키마에 대한 변경 사항을 테스트하고 개발해야 하는 곳입니다.

00:05:51.000 --> 00:05:56.000
사용자가 당신의 앱과 상호 작용할 때, 그들은 생산 환경과 상호 작용할 것입니다.

00:05:56.000 --> 00:05:59.000
프로덕션 환경에는 앱의 라이브 데이터가 포함되어 있습니다.

00:05:59.000 --> 00:06:05.000
이제 CloudKit이 데이터를 저장하는 방법을 검토했으므로, CKTool JS를 구성하는 방법을 다루겠습니다.

00:06:05.000 --> 00:06:15.000
CKTool JS는 iCloud와 대화하기 때문에, 올바른 컨테이너로 작업하는 방법과 스크립트가 그렇게 할 수 있도록 몇 가지 정보를 수집해야 합니다.

00:06:15.000 --> 00:06:20.000
작업하고 싶은 컨테이너의 팀 ID와 컨테이너 ID가 필요합니다.

00:06:20.000 --> 00:06:27.000
스키마로 작업하려면 관리 토큰이 필요하며, 스크립트가 데이터에 액세스하는 경우 사용자 토큰도 필요합니다.

00:06:27.000 --> 00:06:30.000
이 모든 값은 CloudKit 콘솔에서 얻을 수 있습니다.

00:06:30.000 --> 00:06:35.000
또한 스크립트가 실행될 환경, 개발 또는 프로덕션을 지정해야 합니다.

00:06:35.000 --> 00:06:38.000
나는 개발을 앞으로의 예로 사용할 것이다.

00:06:38.000 --> 00:06:43.000
CKTool JS를 사용하도록 구성할 때마다, 이 값이 필요합니다.

00:06:43.000 --> 00:06:46.000
예를 들어, 저는 Node.js를 위한 스크립트를 쓰고 있습니다.

00:06:46.000 --> 00:06:51.000
그것들을 사용하기 위해 CKTool JS에서 객체와 함수를 가져옵니다.

00:06:51.000 --> 00:06:56.000
이 경우, CommonJS require 문을 사용하여 이러한 기호를 가져올 수 있습니다.

00:06:56.000 --> 00:07:02.000
구성 정보를 수집하면, 그 정보를 보관할 개체를 만들 수 있습니다.

00:07:02.000 --> 00:07:08.000
인증 토큰을 저장하려면 관리 토큰을 보관할 개체를 만들고, 있는 경우 사용자 토큰을 만듭니다.

00:07:08.000 --> 00:07:17.000
teamId, containerId 및 환경은 CKTool JS에 전달되는 공통 값이므로, 이러한 값을 보유할 객체를 만들 수 있습니다.

00:07:17.000 --> 00:07:26.000
createConfiguration 공장 기능을 사용하여 CKTool JS에게 iCloud와 대화하는 방법을 알려주는 구성 객체를 인스턴스화합니다.

00:07:26.000 --> 00:07:28.000
createConfiguration은 플랫폼에 따라 다릅니다.

00:07:28.000 --> 00:07:35.000
이 경우, 대상 패키지에서 가져온 함수이기 때문에 Node.js에 대한 적절한 구성을 반환합니다.

00:07:35.000 --> 00:07:42.000
그런 다음 구성 객체와 이전에 선언된 보안 객체를 전달하여 API 객체를 초기화합니다.

00:07:42.000 --> 00:07:47.000
API 객체에는 iCloud와 대화할 수 있는 비동기 메서드가 포함되어 있습니다.

00:07:47.000 --> 00:07:51.000
이제 스크립트에서 CKTool JS를 사용하는 단계를 완료했습니다.

00:07:51.000 --> 00:07:56.000
CKTool JS를 사용하여 컨테이너의 스키마를 관리하는 방법에 대해 알아봅시다.

00:07:56.000 --> 00:08:02.000
제 앱에는 2007년에 발행된 미국 동전과 같은 정보를 저장하고 싶습니다.

00:08:02.000 --> 00:08:08.000
이 동전은 구리와 니켈로 구성되어 있으며 그 위에 찍힌 가치는 미국 달러의 1/10이다.

00:08:08.000 --> 00:08:18.000
이 데이터를 저장하는 방법에 대해 생각한 후, 나는 동전의 구성에 대한 정보를 동전에 대한 다른 세부 사항과 별도의 기록으로 저장하기로 결정했다.

00:08:18.000 --> 00:08:24.000
그래서 나는 10센트의 구리 백분율과 니켈 백분율을 별도의 기록에 저장한다.

00:08:24.000 --> 00:08:28.000
나는 컨테이너의 스키마에서 원하는 두 가지 레코드 유형을 확인했다.

00:08:28.000 --> 00:08:33.000
국가 참조, 발행 연도 및 명목 가치를 저장하는 동전.

00:08:33.000 --> 00:08:40.000
그리고 그것이 설명하는 동전에 대한 참조와 동전의 재료와 비율을 저장하는 구성 요소 레코드 유형.

00:08:40.000 --> 00:08:46.000
이제 앱의 스키마를 결정했으므로, CloudKit 스키마 언어로 텍스트 파일을 만들어 설명할 수 있습니다.

00:08:46.000 --> 00:08:52.000
규칙은 스키마 파일에 .ckdb 확장자를 사용하는 것입니다.

00:08:52.000 --> 00:09:00.000
CloudKit 스키마 언어에 대한 자세한 내용은 "텍스트 기반 스키마를 워크플로우에 통합" 문서 문서를 참조하십시오.

00:09:00.000 --> 00:09:05.000
컨테이너에 대해 만든 스키마 파일은 CKTool JS를 사용하여 적용할 수 있습니다.

00:09:05.000 --> 00:09:12.000
새로운 스키마를 적용하기 전에, 일반적으로 컨테이너의 개발 스키마를 프로덕션의 것과 일치하도록 재설정합니다.

00:09:12.000 --> 00:09:15.000
resetToProduction 방법으로 이것을 할 수 있습니다.

00:09:15.000 --> 00:09:20.000
이전에 선언한 defaultArgs 객체를 전달하여 이 메서드를 호출합니다.

00:09:20.000 --> 00:09:24.000
스키마가 생산되지 않으면, 모든 레코드 유형이 삭제됩니다.

00:09:24.000 --> 00:09:29.000
그렇지 않으면, 이것은 개발 스키마를 생산 환경의 상태로 되돌릴 것이다.

00:09:29.000 --> 00:09:35.000
이것은 비동기 호출이므로, 이 메서드는 약속 객체를 반환합니다.

00:09:35.000 --> 00:09:40.000
CKTool JS에는 컨테이너의 스키마를 내보내고 가져올 수 있는 방법이 있습니다.

00:09:40.000 --> 00:09:46.000
exportSchema와 importSchema 메소드는 당신이 이것을 할 수 있게 해주며 컨테이너의 관점에서 명명됩니다.

00:09:46.000 --> 00:09:56.000
그래서 exportSchema를 사용하여 컨테이너에서 내보낼 스키마를 다운로드하고, importSchema를 사용하여 컨테이너로 가져올 스키마를 업로드합니다.

00:09:56.000 --> 00:10:01.000
이것들은 함께 스키마의 진화를 관리할 수 있게 해준다.

00:10:01.000 --> 00:10:05.000
스키마를 컨테이너에 적용하는 도움말 함수를 만들 수 있습니다.

00:10:05.000 --> 00:10:12.000
먼저, CKTool JS에서 파일 객체를 가져온 다음, Node.js에서 fs 및 경로 모듈을 가져옵니다.

00:10:12.000 --> 00:10:19.000
이제 다음을 수행할 비동기 함수를 정의하십시오: 스키마 파일의 내용을 Node.js 버퍼로 읽습니다.

00:10:19.000 --> 00:10:23.000
업로드를 위한 CKTool JS 파일 인스턴스를 만듭니다.

00:10:23.000 --> 00:10:28.000
마지막으로, importSchema를 사용하여 파일의 내용을 서버에 업로드합니다.

00:10:28.000 --> 00:10:33.000
이전에 선언된 defaultArgs 객체는 importSchema에 전달된다는 점에 유의하십시오.

00:10:33.000 --> 00:10:35.000
이제 넌 그걸 조립할 수 있어.

00:10:35.000 --> 00:10:42.000
resetToProduction과 스키마를 가져오는 데 사용되는 도우미 기능은 비동기이기 때문에 올바른 순서로 실행되도록 해야 합니다.

00:10:42.000 --> 00:10:45.000
그렇게 하기 위해 당신은 약속을 묶습니다.

00:10:45.000 --> 00:10:48.000
오류가 발생하면, 그 약속은 거절될 것이다.

00:10:48.000 --> 00:10:55.000
CKTool JS가 가지고 있는 관리 기능 외에도 데이터를 읽고 쓸 수 있습니다.

00:10:55.000 --> 00:11:03.000
CKTool JS 레코드에 사용되는 필드 값은 서버로 전송되기 전에 클라이언트 측에서 유형 및 범위가 확인됩니다.

00:11:03.000 --> 00:11:11.000
전달된 값이 올바른 종류의 값이 아니거나 허용된 값 범위를 벗어나면 예외가 발생합니다.

00:11:11.000 --> 00:11:18.000
자바스크립트에서 기본적으로 표현할 수 없는 큰 숫자의 경우, 대신 사용되는 CKTool JS 유형이 있습니다.

00:11:18.000 --> 00:11:26.000
예를 들어, CKTool JS Int64에 숫자를 강요하려면 toInt64 함수를 사용합니다.

00:11:26.000 --> 00:11:30.000
숫자를 Double 부동 소수점 값으로 강제하려면, toDouble 함수를 사용합니다.

00:11:30.000 --> 00:11:38.000
TypeScript를 작성하는 경우, 이러한 강제 함수가 사용되지 않으면 컴파일러가 잘못된 값 유형 사용에 플래그를 지정할 것입니다.

00:11:38.000 --> 00:11:44.000
CKTool JS 레코드의 필드 값은 필드 값 팩토리 함수를 사용하여 생성됩니다.

00:11:44.000 --> 00:11:56.000
2007년에 발행된 동전의 경우, 나는 Int64를 포함하는 레코드 필드 값을 만들기 위해 그 값을 makeRecordFieldValue.int64 공장 함수에 전달할 것이다.

00:11:56.000 --> 00:12:03.000
일반적으로, 공장 함수가 전달된 값에서 레코드 필드 값을 만들 수 없다면, 예외가 발생합니다.

00:12:03.000 --> 00:12:09.000
여기서, 나는 레코드와 함께 작동하는 방법으로 보내는 공통 값을 보유하기 위한 객체를 만들었다.

00:12:09.000 --> 00:12:17.000
containerId, environment, databaseType 및 zoneName이 종종 필요하기 때문에, 저는 이 databaseArgs 객체에 그것들을 포함하고 있습니다.

00:12:17.000 --> 00:12:21.000
레코드를 쿼리하기 위해, 저는 queryRecords 메소드를 사용합니다.

00:12:21.000 --> 00:12:28.000
이것을 더 쉽게 하기 위해, 나는 독특한 3자 ISO 코드와 일치하는 국가를 찾는 도우미 기능을 만든다.

00:12:28.000 --> 00:12:35.000
이 경우, 쿼리가 포함된 본문 외에도 databaseArgs 객체의 내용을 전달합니다.

00:12:35.000 --> 00:12:42.000
쿼리 객체의 경우, recordType 값과 단일 필터 객체를 지정하고 있습니다.

00:12:42.000 --> 00:12:50.000
필터 객체는 국가의 isoCode3가 이 함수가 찾고 있는 것과 같은 쿼리를 설명합니다.

00:12:50.000 --> 00:12:56.000
성공하면, 발견된 기록의 수집은 response.result.records 속성에 있을 것이다.

00:12:56.000 --> 00:12:59.000
나는 이 컬렉션의 첫 번째 물건을 돌려줘.

00:12:59.000 --> 00:13:08.000
원시 값을 createRecord가 사용할 수 있는 필드 값으로 변환하기 위해, makeCoinFieldValues라는 도우미 함수가 있습니다.

00:13:08.000 --> 00:13:16.000
필드 값으로 변환하고 싶은 동전의 각 원시 속성에 대해 적절한 RecordFieldValue 공장 함수를 호출합니다.

00:13:16.000 --> 00:13:20.000
그러나, 국가 분야의 경우, 나는 레퍼런스를 만들어야 한다.

00:13:20.000 --> 00:13:27.000
나는 이 동전 기록에서 해당 국가 기록으로 참조하기 위해 전달된 국가 기록 이름을 사용한다.

00:13:27.000 --> 00:13:35.000
여기서, 저는 코인 레코드 필드 값을 취하고 createRecord 요청을 서버에 보내는 도우미 함수를 만듭니다.

00:13:35.000 --> 00:13:40.000
이 기능에서, 나는 이전에 선언된 databaseArgs의 내용과 본문을 전달하고 있다.

00:13:40.000 --> 00:13:43.000
본문 사전에는 recordType과 필드 값이 포함되어 있습니다.

00:13:43.000 --> 00:13:48.000
성공하면, response.result.record가 반환됩니다.

00:13:48.000 --> 00:13:55.000
도우미 기능을 호출하기 전에, 이 동전에서 참조될 올바른 국가 기록을 가져와야 합니다.

00:13:55.000 --> 00:13:58.000
나는 이전에 정의된 국가 쿼리 기능을 사용한다.

00:13:58.000 --> 00:14:08.000
그런 다음 이전에 작성한 makeCoinFieldValues 도우미 함수로 만든 필드 값 사전을 전달하여 coinCreateRecord를 호출합니다.

00:14:08.000 --> 00:14:11.000
원시 동전 값은 그 도우미 함수로 전달된다.

00:14:11.000 --> 00:14:17.000
이것은 비동기적으로 기록을 만들고 새 기록을 반환할 것이다.

00:14:17.000 --> 00:14:20.000
레코드를 업데이트하려면, updateRecord 방법을 사용하세요.

00:14:20.000 --> 00:14:27.000
이 도우미에게 전달된 필드와 레코드 이름과 일치하는 동전을 업데이트하는 도우미 함수를 만듭니다.

00:14:27.000 --> 00:14:37.000
그런 다음 databaseArgs 객체, recordName 및 레코드 유형과 새 레코드의 필드 값을 포함하는 본문의 내용으로 updateRecord를 호출합니다.

00:14:37.000 --> 00:14:45.000
성공하면, 업데이트된 레코드는 내가 도우미 함수에서 반환하는 response.result.record 속성에 있을 것이다.

00:14:45.000 --> 00:14:52.000
이전에 만든 코인 레코드를 업데이트하기 위해, 이 도우미 함수를 호출하여 레코드 이름과 필드 값을 업데이트합니다.

00:14:52.000 --> 00:14:57.000
필드 값은 makeCoinFieldValues로 생성됩니다.

00:14:57.000 --> 00:15:02.000
레코드를 삭제하려면, API 객체에서 비동기 deleteRecord 메소드를 호출합니다.

00:15:02.000 --> 00:15:07.000
삭제할 레코드의 recordName뿐만 아니라 databaseArgs 객체의 내용을 전달합니다.

00:15:07.000 --> 00:15:10.000
CKTool JS를 알아가는 것을 즐겼기를 바랍니다.

00:15:10.000 --> 00:15:16.000
직접 사용해 보세요: 자동화 및 툴링 목적으로 CKTool JS를 구성하세요.

00:15:16.000 --> 00:15:20.000
스키마를 재설정하고 가져오고 자바스크립트를 사용하여 데이터를 읽고 쓰세요.

00:15:20.000 --> 00:15:27.000
지속적인 통합 시나리오에서 CKTool JS를 사용하려면, GitHub의 CloudKit 샘플 저장소를 확인하세요.

00:15:27.000 --> 00:15:32.000
그리고 더 자세한 문서는 developer.apple.com에서 CKTool JS를 확인하세요.

00:15:32.000 --> 23:59:59.000
오늘 나와 함께 해줘서 고마워, 그리고 남은 WWDC22를 즐겨.

