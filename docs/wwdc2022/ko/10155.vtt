WEBVTT

00:00:00.000 --> 00:00:03.000
♪ 부드러운 기악 힙합 음악 ♪

00:00:03.000 --> 00:00:10.000
♪

00:00:10.000 --> 00:00:15.000
멩 양: 안녕하세요, 제 이름은 애플의 GPU 소프트웨어 엔지니어인 멩 양입니다.

00:00:15.000 --> 00:00:26.000
오늘 저는 ScreenCaptureKit에 대한 몇 가지 고급 주제와 앱의 화면 공유 경험을 한 단계 끌어올릴 수 있는 방법을 다룰 것입니다.

00:00:26.000 --> 00:00:32.000
나중에, 내 동료 드류는 이 흥미진진한 새로운 API를 시연할 것이다.

00:00:32.000 --> 00:00:55.000
화면 캡처는 Zoom, Google Meet, SharePlay 및 Twitch와 같은 인기 있는 게임 스트리밍 서비스와 같은 화면 공유 응용 프로그램의 핵심이며, 이는 지난 몇 년 동안 우리가 일하고, 공부하고, 협력하고, 사교하는 방식의 새로운 표준이 되었습니다.

00:00:55.000 --> 00:01:05.000
ScreenCaptureKit은 강력한 기능 세트로 처음부터 구축된 새로운 고성능 화면 캡처 프레임워크입니다.

00:01:05.000 --> 00:01:21.000
풍부한 기능 세트에는 캡처할 창, 응용 프로그램 및 디스플레이의 조합을 쉽게 선택하고 선택할 수 있는 고도로 사용자 정의 가능한 콘텐츠 제어가 포함되어 있습니다.

00:01:21.000 --> 00:01:28.000
화면 콘텐츠의 기본 해상도와 프레임 속도까지 캡처할 수 있는 능력.

00:01:28.000 --> 00:01:34.000
해상도, 프레임 속도, 픽셀 형식과 같은 동적 스트림 속성 제어.

00:01:34.000 --> 00:01:40.000
그리고 이러한 컨트롤은 스트림을 재현하지 않고도 즉시 수정할 수 있습니다.

00:01:40.000 --> 00:01:47.000
메모리 복사본을 줄이기 위해 GPU 메모리 백업된 버퍼를 캡처하세요.

00:01:47.000 --> 00:01:59.000
하드웨어 가속 콘텐츠 캡처, 스케일링, 픽셀 및 색상 형식 변환으로 CPU 사용량을 줄이면서 고성능 캡처를 달성합니다.

00:01:59.000 --> 00:02:07.000
마지막으로, 비디오와 오디오 캡처 모두에 대한 지원.

00:02:07.000 --> 00:02:17.000
시작하기 전에, 이 강연은 당신이 이미 프레임워크가 어떻게 작동하는지에 대한 기본 개념, 빌딩 블록 및 워크플로우에 익숙하다고 가정합니다.

00:02:17.000 --> 00:02:23.000
자세한 내용은 소개 세션 "Meet ScreenCaptureKit"을 방문하세요.

00:02:23.000 --> 00:02:30.000
이 세션에서, 나는 하나의 창을 캡처하고 표시하는 방법에 대해 이야기할 것이다.

00:02:30.000 --> 00:02:36.000
다음으로, 전체 디스플레이 캡처에 화면 콘텐츠를 추가하는 방법.

00:02:36.000 --> 00:02:40.000
디스플레이 캡처에서 콘텐츠를 제거하는 방법.

00:02:40.000 --> 00:02:48.000
그런 다음 다양한 사용 사례에 맞게 스트림을 구성하는 몇 가지 방법을 보여드리겠습니다.

00:02:48.000 --> 00:03:03.000
그리고 마지막으로, ScreenCaptureKit이 인기 있는 오픈 소스 화면 캡처 앱인 OBS Studio의 화면 및 오디오 캡처 경험을 어떻게 변화시켰는지에 대한 데모를 볼 수 있습니다.

00:03:03.000 --> 00:03:14.000
이제, 첫 번째 예시와 아마도 가장 일반적인 사용 사례로 시작합시다: 단일 창을 캡처하세요.

00:03:14.000 --> 00:03:30.000
이 예제는 단일 창 필터를 설정하는 방법을 다룰 것입니다. 캡처된 창의 크기가 조정되거나, 차단되거나, 화면 밖으로 이동되거나, 최소화될 때 스트림 출력에서 기대할 수 있는 것.

00:03:30.000 --> 00:03:38.000
또한 프레임별 메타데이터를 사용하는 방법과 캡처된 창을 올바르게 표시하는 방법을 배우게 될 것입니다.

00:03:38.000 --> 00:03:40.000
뛰어들자.

00:03:40.000 --> 00:03:54.000
어떤 디스플레이와 독립적인 단일 창을 캡처하려면, 단일 창 필터를 사용하여 시작하고 하나의 창으로 필터를 초기화할 수 있습니다.

00:03:54.000 --> 00:04:01.000
이 예에서, 필터는 단일 사파리 창을 포함하도록 구성되어 있습니다.

00:04:01.000 --> 00:04:06.000
비디오 출력은 그 창만 포함하고 다른 것은 포함하지 않는다.

00:04:06.000 --> 00:04:13.000
사파리의 어린이, 팝업 또는 다른 창은 포함되지 않습니다.

00:04:13.000 --> 00:04:20.000
반면에 ScreenCaptureKit의 오디오 캡처 정책은 항상 앱 수준에서 작동합니다.

00:04:20.000 --> 00:04:36.000
단일 창 필터를 사용하면, 비디오 출력에 없는 창에서도 창이 포함된 응용 프로그램의 모든 오디오 콘텐츠가 캡처됩니다.

00:04:36.000 --> 00:04:40.000
이제 코드 샘플을 살펴봅시다.

00:04:40.000 --> 00:04:50.000
단일 창으로 스트림을 만들려면, SCShareableContent를 통해 사용 가능한 모든 콘텐츠를 공유하는 것으로 시작하세요.

00:04:50.000 --> 00:04:58.000
다음으로, windowID와 일치하여 SCShareableContent에서 공유하고 싶은 창을 받으세요.

00:04:58.000 --> 00:05:08.000
그런 다음, 지정된 SCWindow로 desktopIndependentWindow 유형으로 SCContentFilter를 만드세요.

00:05:08.000 --> 00:05:15.000
스트림 출력의 일부로 오디오를 포함하도록 스트림을 추가로 구성할 수 있습니다.

00:05:15.000 --> 00:05:21.000
이제 contentFilter와 streamConfig로 스트림을 만들 준비가 되었습니다.

00:05:21.000 --> 00:05:27.000
그런 다음 StreamOutput을 추가하고 스트림을 시작할 수 있습니다.

00:05:27.000 --> 00:05:31.000
다음으로 스트림 출력을 살펴봅시다.

00:05:31.000 --> 00:05:40.000
이 예에서, 소스 디스플레이는 왼쪽에 있고 스트림 출력은 오른쪽에 있습니다.

00:05:40.000 --> 00:05:45.000
스트림 필터에는 하나의 사파리 창이 포함되어 있습니다.

00:05:45.000 --> 00:05:52.000
이제 나는 캡처되고 있는 사파리 창을 스크롤하기 시작할 것이다.

00:05:52.000 --> 00:06:06.000
스트림 출력은 단일 사파리 창의 라이브 콘텐츠를 포함하며 소스 디스플레이의 기본 프레임 속도까지 소스 창과 동일한 케이던스로 업데이트됩니다.

00:06:06.000 --> 00:06:20.000
예를 들어, 소스 창이 120Hz 디스플레이에서 지속적으로 업데이트될 때, 스트림 출력은 최대 120fps의 업데이트를 달성할 수 있습니다.

00:06:20.000 --> 00:06:24.000
창문의 크기가 조정되면 어떻게 되는지 궁금할 수도 있습니다.

00:06:24.000 --> 00:06:36.000
스트림의 출력 치수를 자주 변경하면 추가 메모리 할당으로 이어질 수 있으므로 권장되지 않습니다.

00:06:36.000 --> 00:06:44.000
스트림의 출력 치수는 대부분 고정되어 있으며 소스 창으로 크기를 조정하지 않습니다.

00:06:44.000 --> 00:06:51.000
이제 소스 창의 크기를 조정하고 스트림의 출력이 어떻게 되는지 봅시다.

00:06:51.000 --> 00:07:03.000
ScreenCaptureKit은 항상 캡처된 창에서 하드웨어 스케일링을 수행하므로 소스 창의 크기를 조정할 때 프레임 출력을 초과하지 않습니다.

00:07:03.000 --> 00:07:07.000
다른 창문으로 덮인 창문은 어때?

00:07:07.000 --> 00:07:19.000
소스 창이 차단되거나 부분적으로 차단될 때, 스트림 출력은 항상 창의 전체 내용을 포함합니다.

00:07:19.000 --> 00:07:28.000
그리고 이것은 창이 완전히 꺼져 있거나 다른 디스플레이로 옮겨진 경우에도 적용됩니다.

00:07:28.000 --> 00:07:41.000
그리고 최소화된 창의 경우, 소스 창이 최소화되면 스트림 출력이 일시 중지되고 소스 창이 더 이상 최소화되지 않을 때 재개됩니다.

00:07:41.000 --> 00:07:45.000
다음으로, 오디오 출력으로 넘어가자.

00:07:45.000 --> 00:07:55.000
이 예제에는 오디오 트랙이 있는 두 개의 사파리 창이 있으며, 왼쪽 창이 캡처되고 있습니다.

00:07:55.000 --> 00:08:05.000
비디오 출력에는 첫 번째 창만 포함되며, 두 사파리 창의 오디오 트랙은 오디오 출력에 포함됩니다.

00:08:05.000 --> 00:08:07.000
한번 보고 들어보자.

00:08:07.000 --> 00:08:12.000
♪ 전자 댄스 음악 ♪

00:08:12.000 --> 00:08:16.000
셰프: 그리고 내가 가장 좋아하는 과카몰리 레시피를 적었어.

00:08:16.000 --> 00:08:19.000
아보카도 네 개가 필요해.

00:08:19.000 --> 00:08:27.000
멩: 스트림이 실행되면, 앱은 새로운 프레임을 사용할 수 있을 때마다 프레임 업데이트를 받습니다.

00:08:27.000 --> 00:08:36.000
프레임의 출력에는 캡처된 프레임과 프레임별 메타데이터를 나타내는 IOSurface가 포함되어 있습니다.

00:08:36.000 --> 00:08:42.000
나는 메타데이터에 대해 이야기하는 데 시간을 보내고 싶다.

00:08:42.000 --> 00:08:48.000
당신의 앱에 꽤 유용할 수 있는 메타데이터의 예를 보여드리겠습니다.

00:08:48.000 --> 00:08:58.000
그리고 여기에는 더러운 rects, 콘텐츠 rect, 콘텐츠 스케일 및 스케일 요소가 포함됩니다.

00:08:58.000 --> 00:09:01.000
더러운 직장부터 시작하자.

00:09:01.000 --> 00:09:06.000
더러운 직장은 이전 프레임에서 새로운 콘텐츠가 어디에 있는지를 나타냅니다.

00:09:06.000 --> 00:09:15.000
여기 예시에서, 더러운 rects는 프레임 업데이트의 영역을 설명하기 위해 강조되고 있다.

00:09:15.000 --> 00:09:38.000
항상 전체 프레임을 인코딩하거나 인코더의 두 프레임 사이의 델타를 계산하는 대신, 더러운 rects를 사용하여 새로운 업데이트로 영역을 인코딩하고 전송하고 수신기 측의 이전 프레임에 업데이트를 복사하여 새 프레임을 생성할 수 있습니다.

00:09:38.000 --> 00:09:49.000
Dirty rects는 일치하는 키를 사용하여 출력 CMSampleBuffer의 메타데이터 사전에서 검색할 수 있습니다.

00:09:49.000 --> 00:09:54.000
이제 콘텐츠 rect와 콘텐츠 규모로 넘어가자.

00:09:54.000 --> 00:10:02.000
캡처할 소스 창은 왼쪽에 있고 스트림 출력은 오른쪽에 있습니다.

00:10:02.000 --> 00:10:13.000
창의 크기를 조정할 수 있기 때문에, 소스 창의 기본 백업 표면 크기는 종종 스트림 출력의 치수와 일치하지 않습니다.

00:10:13.000 --> 00:10:22.000
여기 예에서, 캡처된 창은 프레임의 출력과 종횡비가 다르며 더 큽니다.

00:10:22.000 --> 00:10:29.000
캡처된 창은 출력에 맞게 축소됩니다.

00:10:29.000 --> 00:10:40.000
여기서 녹색으로 강조 표시된 콘텐츠 rect는 스트림 출력에서 캡처된 콘텐츠의 관심 영역을 나타냅니다.

00:10:40.000 --> 00:10:46.000
그리고 콘텐츠 스케일은 콘텐츠가 얼마나 맞게 조정되었는지를 나타냅니다.

00:10:46.000 --> 00:10:55.000
여기서 캡처된 사파리 창은 프레임 안에 맞도록 0.77 축소됩니다.

00:10:55.000 --> 00:11:06.000
이제 방금 논의한 메타데이터를 사용하여 캡처된 창을 가능한 한 기본 모양에 가깝게 올바르게 표시할 수 있습니다.

00:11:06.000 --> 00:11:13.000
먼저, 콘텐츠 rect를 사용하여 출력에서 콘텐츠를 자르는 것으로 시작합시다.

00:11:13.000 --> 00:11:20.000
다음으로, 콘텐츠 스케일을 나누어 콘텐츠를 다시 확장하세요.

00:11:20.000 --> 00:11:28.000
이제 캡처된 콘텐츠는 픽셀 크기에서 소스 창과 일대일로 일치하도록 조정됩니다.

00:11:28.000 --> 00:11:33.000
하지만 캡처된 창은 대상 디스플레이에서 어떻게 보이나요?

00:11:33.000 --> 00:11:40.000
그 질문에 답하기 위해, 나는 스케일 팩터가 어떻게 작동하는지 설명하는 것으로 시작하고 싶다.

00:11:40.000 --> 00:11:53.000
디스플레이의 스케일 계수는 디스플레이 또는 창의 논리적 포인트 크기와 백킹 표면의 픽셀 크기 사이의 스케일 비율을 나타냅니다.

00:11:53.000 --> 00:12:03.000
스케일 팩터 2 또는 2x 모드는 화면의 모든 지점이 뒷면 표면의 4픽셀과 같다는 것을 의미합니다.

00:12:03.000 --> 00:12:17.000
창은 여기 예와 같이 스케일 팩터 2가 있는 레티나 디스플레이에서 캡처되는 동안 스케일 팩터 1이 있는 비 레티나 디스플레이로 이동할 수 있습니다.

00:12:17.000 --> 00:12:26.000
스케일 팩터 1의 경우, 화면의 각 논리적 점은 백킹 표면의 한 픽셀에 해당합니다.

00:12:26.000 --> 00:12:38.000
또한, 소스 디스플레이는 캡처된 콘텐츠가 표시될 대상 디스플레이에서 스케일 계수가 일치하지 않을 수 있습니다.

00:12:38.000 --> 00:12:52.000
이 예에서, 창은 왼쪽의 레티나 디스플레이에서 스케일 팩터 2로 캡처되고 있으며 오른쪽의 비 레티나 디스플레이에 표시됩니다.

00:12:52.000 --> 00:13:06.000
캡처된 창이 한 지점에서 한 픽셀 매핑으로 대상 비 망막 디스플레이에서 스케일링하지 않고 그대로 표시되면, 창은 네 배 더 커 보일 것입니다.

00:13:06.000 --> 00:13:16.000
이 문제를 해결하려면, 항상 대상 디스플레이의 스케일 팩터에 대해 프레임의 메타데이터에서 스케일 팩터를 확인해야 합니다.

00:13:16.000 --> 00:13:24.000
불일치가 있을 때, 캡처된 콘텐츠의 크기를 표시하기 전에 스케일 요소로 크기를 조정하세요.

00:13:24.000 --> 00:13:34.000
스케일링 후, 대상 디스플레이의 캡처된 창은 이제 소스 창과 같은 크기로 보입니다.

00:13:34.000 --> 00:13:39.000
이제 코드를 살펴봅시다, 그리고 그것은 꽤 간단합니다.

00:13:39.000 --> 00:13:51.000
콘텐츠 rect, 콘텐츠 스케일 및 스케일 팩터는 출력 CMSampleBuffer의 메타데이터 첨부 파일에서도 검색할 수 있습니다.

00:13:51.000 --> 00:14:00.000
그런 다음 이러한 메타데이터를 사용하여 캡처된 콘텐츠를 자르고 크기를 조정하여 올바르게 표시할 수 있습니다.

00:14:00.000 --> 00:14:11.000
요약하자면, 단일 창 필터는 소스 창이 화면 밖이거나 가려진 경우에도 항상 전체 창 콘텐츠를 포함합니다.

00:14:11.000 --> 00:14:14.000
그것은 전시와 공간 독립적이다.

00:14:14.000 --> 00:14:20.000
출력은 항상 왼쪽 상단 모서리에서 오프셋됩니다.

00:14:20.000 --> 00:14:25.000
팝업 또는 어린이 창은 포함되어 있지 않습니다.

00:14:25.000 --> 00:14:29.000
콘텐츠를 가장 잘 표시하기 위해 메타데이터를 사용하는 것을 고려해 보세요.

00:14:29.000 --> 00:14:35.000
그리고 오디오는 전체 포함 앱의 트랙을 포함한다.

00:14:35.000 --> 00:14:46.000
이제 단일 창을 캡처하고 표시하는 방법에 대해 배웠으니, 디스플레이 기반 콘텐츠 필터의 다음 클래스로 넘어가겠습니다.

00:14:46.000 --> 00:15:00.000
다음 예에서, 당신은 윈도우나 앱으로 디스플레이 기반 필터를 만드는 방법을 배우게 될 것이며, 저는 비디오와 오디오 필터링 규칙의 몇 가지 차이점을 보여줄 것입니다.

00:15:00.000 --> 00:15:07.000
디스플레이 기반 포함 필터는 콘텐츠를 캡처할 디스플레이를 지정합니다.

00:15:07.000 --> 00:15:11.000
기본적으로, 어떤 창도 캡처되지 않습니다.

00:15:11.000 --> 00:15:15.000
창으로 캡처하고 싶은 콘텐츠를 선택할 수 있습니다.

00:15:15.000 --> 00:15:23.000
이 예에서, 사파리 창과 키노트 창이 디스플레이 필터에 추가됩니다.

00:15:23.000 --> 00:15:37.000
비디오 출력에는 디스플레이 공간에 배치된 이 두 개의 창만 포함되어 있으며 오디오 출력에는 Keynote 및 Safari 앱의 모든 사운드트랙이 포함되어 있습니다.

00:15:37.000 --> 00:15:44.000
이 코드 샘플은 포함된 창으로 디스플레이 기반 필터를 만드는 방법을 보여줍니다.

00:15:44.000 --> 00:15:52.000
SCShareableContent와 windowID를 사용하여 SCWindows 목록을 만드는 것으로 시작하세요.

00:15:52.000 --> 00:16:01.000
그런 다음, 주어진 디스플레이와 포함된 창 목록으로 디스플레이 기반 SCContentFilter를 만드세요.

00:16:01.000 --> 00:16:13.000
그런 다음 데스크톱 독립 창과 같은 방식으로 필터와 구성을 사용하여 스트림을 만들고 스트림을 시작할 수 있습니다.

00:16:13.000 --> 00:16:18.000
스트림이 가동되고 실행되면, 스트림의 출력을 살펴봅시다.

00:16:18.000 --> 00:16:30.000
필터는 두 개의 사파리 창, 메뉴 표시줄 및 배경화면 창을 포함하도록 구성되어 있습니다.

00:16:30.000 --> 00:16:37.000
창이 화면 밖으로 이동되면, 스트림 출력에서 제거됩니다.

00:16:37.000 --> 00:16:48.000
새 사파리 창이 생성되면, 새 창이 필터에 없기 때문에 새 창이 스트림 출력에 나타나지 않습니다.

00:16:48.000 --> 00:16:56.000
스트림의 출력에 나타나지 않는 자식 또는 팝업 창에도 같은 규칙이 적용됩니다.

00:16:56.000 --> 00:17:07.000
하위 창이 스트림 출력에 자동으로 포함되도록 하려면, 포함된 앱과 함께 디스플레이 기반 필터를 사용할 수 있습니다.

00:17:07.000 --> 00:17:36.000
이 예에서, 사파리와 키노트 앱을 필터에 추가하면 이 두 앱의 모든 창과 사운드트랙의 오디오 및 비디오 출력이 출력 창 예외 필터에 포함되도록 하는 것은 필터가 포함된 앱과 함께 디스플레이로 지정될 때 출력에서 특정 창을 제외하는 강력한 방법입니다.

00:17:36.000 --> 00:17:42.000
예를 들어, 단일 사파리 창이 출력에서 제거됩니다.

00:17:42.000 --> 00:17:57.000
ScreenCaptureKit은 앱 수준에서 오디오 캡처를 가능하게 하므로, 단일 Safari 창에서 오디오를 제외하는 것은 모든 Safari 앱의 오디오 트랙을 제거하는 것과 같습니다.

00:17:57.000 --> 00:18:13.000
스트림의 비디오 출력에는 여전히 Safari 창이 포함되어 있지만, Safari 앱의 모든 사운드 트랙은 제거되고 오디오 출력에는 Keynote의 사운드트랙만 포함됩니다.

00:18:13.000 --> 00:18:23.000
여기 코드 예제에서, 우리는 SCWindows 대신 SCRunningApplications 목록을 포함하도록 SCContentFilter를 변경합니다.

00:18:23.000 --> 00:18:41.000
추가로 제외하려는 개별 창이 있는 경우, SCWindows 목록을 만든 다음 제외할 제외할 창 목록과 함께 SCApplications 목록을 사용하여 SCContentFilter를 만드세요.

00:18:41.000 --> 00:18:51.000
포함된 앱을 지정하여 새 창 또는 자식 창을 만들 때 스트림 출력이 어떻게 생겼는지 살펴봅시다.

00:18:51.000 --> 00:18:58.000
이번에는 사파리 앱과 시스템 창이 필터에 추가됩니다.

00:18:58.000 --> 00:19:08.000
새로운 사파리 창은 이제 스트림 출력에 자동으로 포함되며 자식 및 팝업 창에도 동일한 규칙이 적용됩니다.

00:19:08.000 --> 00:19:19.000
이것은 튜토리얼을 하고 팝업이나 새 창을 호출하는 것을 포함한 전체 작업을 시연하고 싶을 때 매우 유용할 수 있습니다.

00:19:19.000 --> 00:19:26.000
나는 방금 몇 가지 다른 방법을 통해 스트림 출력에 콘텐츠를 추가하는 방법을 시연했다.

00:19:26.000 --> 00:19:32.000
다음 예제는 스트림 출력에서 콘텐츠를 제거하는 방법을 보여줄 것입니다.

00:19:32.000 --> 00:19:43.000
이 예에는 공유 중인 디스플레이의 미리보기가 포함된 화상 회의 앱을 에뮬레이트하는 테스트 앱이 포함되어 있습니다.

00:19:43.000 --> 00:19:52.000
테스트 앱은 미리보기에서 재귀적으로 나타나기 때문에, 소위 미러 홀 효과를 만들고 있다.

00:19:52.000 --> 00:20:10.000
전체 디스플레이 공유 중에도 화면 공유 응용 프로그램이 자체 창, 미리보기 캡처, 참가자 카메라 보기를 제거하여 미러 홀 효과 또는 알림 창과 같은 다른 시스템 UI를 제거하는 것이 일반적입니다.

00:20:10.000 --> 00:20:21.000
ScreenCaptureKit은 디스플레이 캡처에서 콘텐츠를 빠르게 제거할 수 있는 제외 기반 필터 세트를 제공합니다.

00:20:21.000 --> 00:20:28.000
제외 기반 디스플레이 필터는 기본적으로 주어진 디스플레이에서 모든 창을 캡처합니다.

00:20:28.000 --> 00:20:35.000
그런 다음 제외 필터에 추가하여 개별 창이나 앱을 제거하기 시작할 수 있습니다.

00:20:35.000 --> 00:20:46.000
예를 들어, 콘텐츠 캡처 테스트 앱과 알림 센터를 제외된 애플리케이션 목록에 추가할 수 있습니다.

00:20:46.000 --> 00:20:59.000
응용 프로그램 목록을 제외한 디스플레이 기반 필터를 만들려면, 번들 ID를 일치시켜 제외할 SCApplications를 검색하는 것으로 시작하세요.

00:20:59.000 --> 00:21:10.000
스트림 출력으로 다시 선택하고 싶은 개별 창이 있다면, SCWindows를 제외한 선택적 목록을 만들 수도 있습니다.

00:21:10.000 --> 00:21:22.000
그런 다음 주어진 디스플레이, 제외할 응용 프로그램 목록 및 제외 창 목록을 사용하여 콘텐츠 필터를 만드세요.

00:21:22.000 --> 00:21:26.000
결과를 살펴봅시다.

00:21:26.000 --> 00:21:36.000
미러 홀 문제를 일으키는 콘텐츠 캡처 테스트 앱과 알림 창은 모두 스트림 출력에서 제거됩니다.

00:21:36.000 --> 00:21:43.000
이 앱의 새 창이나 자식 창도 자동으로 제거됩니다.

00:21:43.000 --> 00:21:50.000
이러한 제거된 앱에 오디오가 포함되어 있다면, 오디오는 오디오 출력에서 제거됩니다.

00:21:50.000 --> 00:21:58.000
우리는 방금 단일 창을 캡처하는 방법, 디스플레이 필터에서 창을 추가하고 제거하는 방법을 보았습니다.

00:21:58.000 --> 00:22:02.000
다음으로 스트림 구성으로 넘어갑시다.

00:22:02.000 --> 00:22:18.000
다음 몇 가지 예에서는 구성할 수 있는 다양한 스트림 속성, 화면 캡처 및 스트리밍을 위한 스트림을 설정하는 방법, 라이브 미리보기로 창 선택기를 만드는 방법에 대해 배우게 됩니다.

00:22:18.000 --> 00:22:22.000
구성 속성부터 시작합시다.

00:22:22.000 --> 00:22:43.000
이것들은 스트림 출력 치수, 소스 및 대상 rects, 색상 공간, 색상 매트릭스 및 픽셀 형식, 커서 포함 여부 및 프레임 속도 제어와 같이 구성할 수 있는 일반적인 스트림 속성 중 일부입니다.

00:22:43.000 --> 00:22:48.000
우리는 다음에 각 부동산을 자세히 살펴볼 것이다.

00:22:48.000 --> 00:22:56.000
픽셀 단위로 너비와 높이로 지정할 수 있는 출력 치수부터 시작합시다.

00:22:56.000 --> 00:23:04.000
소스 디스플레이의 치수와 종횡비가 항상 출력 치수와 일치하지는 않습니다.

00:23:04.000 --> 00:23:13.000
그리고 전체 디스플레이를 캡처하는 동안 이 불일치가 발생하면, 스트림 출력에 기둥이나 우편함이 있을 것이다.

00:23:13.000 --> 00:23:26.000
캡처할 영역을 정의하는 소스 rect를 지정할 수도 있으며 결과는 프레임 출력의 대상 rect로 렌더링되고 확장됩니다.

00:23:26.000 --> 00:23:36.000
ScreenCaptureKit은 하드웨어 가속 색 공간, 색상 매트릭스 및 픽셀 형식 변환을 지원합니다.

00:23:36.000 --> 00:23:41.000
일반적인 BGRA 및 YUV 형식이 지원됩니다.

00:23:41.000 --> 00:23:46.000
전체 목록을 보려면 개발자 페이지를 방문하세요.

00:23:46.000 --> 00:23:54.000
쇼 커서가 활성화되면, 스트림 출력에는 프레임에 미리 렌더링된 커서가 포함됩니다.

00:23:54.000 --> 00:24:02.000
이것은 모든 시스템 커서에 적용되며, 심지어 카메라 모양의 커서와 같은 사용자 지정 커서에도 적용됩니다.

00:24:02.000 --> 00:24:08.000
최소 프레임 간격을 사용하여 원하는 출력 프레임 속도를 제어할 수 있습니다.

00:24:08.000 --> 00:24:16.000
예를 들어, 60fps를 요청할 때, 최소 간격을 1/60으로 설정하세요.

00:24:16.000 --> 00:24:26.000
프레임 업데이트는 60fps를 넘지 않으며, 콘텐츠의 기본 프레임 속도를 넘지 않습니다.

00:24:26.000 --> 00:24:34.000
서버 측 표면 풀의 표면 수를 결정하기 위해 대기열 깊이를 지정할 수 있습니다.

00:24:34.000 --> 00:24:50.000
풀의 더 많은 표면은 더 나은 프레임 속도와 성능으로 이어질 수 있지만, 더 높은 시스템 메모리 사용량과 잠재적으로 대기 시간 절충을 초래하며, 나중에 더 자세히 논의할 것입니다.

00:24:50.000 --> 00:24:59.000
ScreenCaptureKit은 기본 대기열 깊이가 3에서 8 사이의 대기열 깊이 범위를 허용합니다.

00:24:59.000 --> 00:25:09.000
이 예에서, 표면 풀은 ScreenCaptureKit이 렌더링할 수 있는 네 개의 표면을 포함하도록 구성되어 있습니다.

00:25:09.000 --> 00:25:19.000
현재 활성 표면은 표면 1이고 ScreenCaptureKit은 다음 프레임을 렌더링하고 있다.

00:25:19.000 --> 00:25:26.000
표면 1이 완료되면, ScreenCaptureKit은 표면 1을 앱으로 보냅니다.

00:25:26.000 --> 00:25:35.000
앱이 표면 1을 처리하고 유지하는 동안 ScreenCaptureKit은 표면 2로 렌더링됩니다.

00:25:35.000 --> 00:25:43.000
Surface 1은 앱이 여전히 사용하고 있기 때문에 이제 풀에서 사용할 수 없는 것으로 표시됩니다.

00:25:43.000 --> 00:25:51.000
표면 2가 완료되면 앱으로 전송되고 ScreenCaptureKit은 이제 표면 3으로 렌더링됩니다.

00:25:51.000 --> 00:26:03.000
하지만 앱이 여전히 표면 1을 처리하고 있다면, 프레임이 처리할 수 있는 것보다 더 빨리 제공되기 때문에 뒤쳐지기 시작할 것입니다.

00:26:03.000 --> 00:26:15.000
표면 풀에 많은 수의 표면이 포함되어 있다면, 새로운 표면이 쌓이기 시작할 것이며, 따라잡기 위해 프레임을 떨어뜨리기 시작하는 것을 고려해야 할 수도 있습니다.

00:26:15.000 --> 00:26:22.000
이 경우, 수영장의 더 많은 표면은 잠재적으로 더 높은 대기 시간으로 이어질 수 있다.

00:26:22.000 --> 00:26:34.000
ScreenCaptureKit이 사용할 수 있도록 풀에 남아 있는 표면의 수는 대기열 깊이에서 앱이 보유한 표면 수를 뺀 것과 같습니다.

00:26:34.000 --> 00:26:40.000
여기 예시에서, 표면 1과 2는 여전히 당신의 앱에 의해 유지됩니다.

00:26:40.000 --> 00:26:45.000
표면 수영장에는 2개의 표면이 남아 있다.

00:26:45.000 --> 00:26:54.000
표면 3이 완료되어 앱으로 전송된 후, 풀에 남은 유일한 표면은 표면 4입니다.

00:26:54.000 --> 00:27:07.000
앱이 표면 1, 2, 3을 계속 유지한다면, ScreenCaptureKit은 곧 렌더링할 표면이 부족하고 프레임 손실과 결함을 보기 시작할 것입니다.

00:27:07.000 --> 00:27:20.000
앱은 프레임 손실을 피하기 위해 ScreenCaptureKit이 표면 4 이후의 다음 프레임을 렌더링하기 전에 표면 1을 완료하고 해제해야 합니다.

00:27:20.000 --> 00:27:27.000
이제 앱이 surface 1을 출시하고 ScreenCaptureKit을 다시 사용할 수 있습니다.

00:27:27.000 --> 00:27:35.000
요약하자면: 프레임 지연과 프레임 손실을 피하기 위해 앱이 따라야 하는 두 가지 규칙이 있습니다.

00:27:35.000 --> 00:27:42.000
지연된 프레임을 피하려면, MinimumFrameInterval 내에서 프레임을 처리할 수 있어야 합니다.

00:27:42.000 --> 00:28:04.000
프레임 손실을 피하려면, 앱이 표면을 풀로 다시 해제하는 데 걸리는 시간은 MinimumFrameInterval 시간 QueueDepth 빼기 1보다 작아야 하며, 그 후 ScreenCaptureKit은 사용할 표면이 부족하고, 스톨에 들어가며, 새 프레임을 놓치기 시작합니다.

00:28:04.000 --> 00:28:15.000
이제 구성할 수 있는 다양한 속성을 보았으니, 화면 캡처 및 스트리밍을 위한 스트림을 구성하기 위한 몇 가지 예를 살펴보겠습니다.

00:28:15.000 --> 00:28:26.000
일부 화면 콘텐츠에는 지속적으로 업데이트되고 더 높은 프레임 속도가 필요한 비디오, 게임 또는 애니메이션이 포함되어 있습니다.

00:28:26.000 --> 00:28:45.000
다른 것들은 프레임 속도보다 더 높은 해상도를 우선시하는 키노트 창과 같은 정적 텍스트를 포함하지만, 공유되는 콘텐츠와 네트워킹 조건에 따라 스트림의 구성을 실시간으로 조정할 수 있습니다.

00:28:45.000 --> 00:28:55.000
이 코드 예제에서는 4K, 60fps 게임을 스트리밍하도록 캡처를 구성하는 방법을 보게 될 것입니다.

00:28:55.000 --> 00:29:01.000
스트림 출력 치수를 픽셀 크기로 4K로 설정하여 시작할 수 있습니다.

00:29:01.000 --> 00:29:10.000
그런 다음, 최소 프레임 간격을 1/60으로 설정하여 출력 프레임 속도를 60fps로 설정하십시오.

00:29:10.000 --> 00:29:18.000
다음으로, 인코딩과 스트리밍을 위해 픽셀 형식 YUV420을 사용하세요.

00:29:18.000 --> 00:29:25.000
화면의 일부만 캡처하도록 선택적 소스 rect를 설정하세요.

00:29:25.000 --> 00:29:33.000
다음으로, 배경 채우기 색상을 검은색으로 변경한 다음, 프레임 출력에 커서를 포함하세요.

00:29:33.000 --> 00:29:39.000
최적의 프레임 속도와 성능을 위해 표면 대기열 깊이를 5로 구성하세요.

00:29:39.000 --> 00:29:45.000
마지막으로, 출력 스트림에서 오디오를 활성화하세요.

00:29:45.000 --> 00:29:55.000
이전 예제에서 방금 본 모든 스트림 구성은 스트림을 다시 만들지 않고도 즉시 동적으로 변경할 수 있습니다.

00:29:55.000 --> 00:30:07.000
예를 들어, 출력 차원과 같은 일부 속성을 실시간으로 조정하고, 프레임 속도를 동적으로 변경하고, 스트림 필터를 업데이트할 수 있습니다.

00:30:07.000 --> 00:30:14.000
다음은 출력 치수를 4K에서 720p로 전환하는 예입니다.

00:30:14.000 --> 00:30:21.000
그리고 프레임 속도를 60fps에서 15fps로 다운그레이드하세요.

00:30:21.000 --> 00:30:31.000
그런 다음 updateConfiguration을 호출하여 스트림을 중단하지 않고 즉시 새 설정을 적용할 수 있습니다.

00:30:31.000 --> 00:30:39.000
마지막 예에서, 라이브 미리보기로 윈도우 피커를 만드는 과정을 안내하고 싶습니다.

00:30:39.000 --> 00:30:45.000
다음은 전형적인 윈도우 피커가 어떻게 생겼는지에 대한 예입니다.

00:30:45.000 --> 00:30:55.000
웹 회의 화면 공유 앱은 사용자에게 공유할 정확한 창을 선택할 수 있는 옵션을 제공하는 것이 일반적입니다.

00:30:55.000 --> 00:31:09.000
ScreenCaptureKit은 라이브 콘텐츠 업데이트로 많은 수의 썸네일 크기의 스트림을 만들 수 있는 효율적이고 고성능 솔루션을 제공하며, 구현하기 쉽습니다.

00:31:09.000 --> 00:31:17.000
ScreenCaptureKit을 사용하여 이와 같은 창 선택기를 만드는 데 무엇이 필요한지 알아보기 위해 그것을 분해해 봅시다.

00:31:17.000 --> 00:31:31.000
피커를 설정하려면, 앱이 사용자가 데스크톱 독립 창을 필터 유형으로 선택할 수 있는 각 적격 창에 대해 하나의 단일 창 필터를 만드는 것으로 시작할 수 있습니다.

00:31:31.000 --> 00:31:48.000
다음으로, 화면 디스플레이를 위한 BGRA 픽셀 형식, 기본 대기열 깊이, 커서 또는 오디오가 없는 썸네일 크기의 5fps의 스트림 구성을 설정하십시오.

00:31:48.000 --> 00:31:57.000
단일 창 필터와 스트림 구성을 사용하여 각 창에 대해 하나의 스트림을 만드세요.

00:31:57.000 --> 00:32:07.000
코드에서 이것을 하려면, 데스크톱과 시스템 창을 제외하고 SCShareableContent를 얻는 것으로 시작할 수 있습니다.

00:32:07.000 --> 00:32:16.000
다음으로, 각 적격 창에 대해 데스크톱 독립 창 유형의 콘텐츠 필터를 만드세요.

00:32:16.000 --> 00:32:21.000
그런 다음, 스트림 구성 부분으로 이동하세요.

00:32:21.000 --> 00:32:33.000
적절한 썸네일 크기를 선택하십시오 -- 이 예에서는 284 x 182입니다 -- 그런 다음 최소 프레임 간격을 5개 중 1로 설정하십시오.

00:32:33.000 --> 00:32:45.000
화면 디스플레이를 위한 BGRA의 픽셀 포맷으로, 미리보기에 필요하지 않기 때문에 오디오와 커서를 비활성화하세요.

00:32:45.000 --> 00:32:52.000
그리고 너무 자주 업데이트를 기대하지 않기 때문에 대기열 깊이를 3으로 설정하세요.

00:32:52.000 --> 00:32:59.000
스트림 콘텐츠 필터와 구성을 만들면, 이제 스트림을 만들 준비가 되었습니다.

00:32:59.000 --> 00:33:08.000
각 창에 대해 하나의 스트림을 만들고, 각 스트림에 대한 스트림 출력을 추가한 다음, 스트림을 시작하세요.

00:33:08.000 --> 00:33:13.000
마지막으로, 스트림 목록에 추가하세요.

00:33:13.000 --> 00:33:20.000
이것은 우리가 이전에 본 샘플 코드를 사용하여 생성된 라이브 미리보기가 있는 창 선택기입니다.

00:33:20.000 --> 00:33:29.000
각 썸네일은 실시간으로 업데이트된 다음 단일 창 필터가 있는 개별 스트림에 의해 백업됩니다.

00:33:29.000 --> 00:33:44.000
ScreenCaptureKit을 사용하면 시스템에 부담을 주지 않고도 많은 라이브 화면 콘텐츠를 동시에 캡처할 수 있는 이와 같은 라이브 미리보기 선택기를 쉽게 만들 수 있습니다.

00:33:44.000 --> 00:33:54.000
이제 제 동료인 드류에게 넘겨드리겠습니다. 드류는 당신에게 ScreenCaptureKit의 OBS 채택에 대한 흥미로운 데모를 제공할 것입니다.

00:33:54.000 --> 00:33:56.000
드류 밀스: 고마워, 멩.

00:33:56.000 --> 00:33:59.000
안녕하세요, 제 이름은 드류이고, 저는 여기 애플의 파트너 엔지니어입니다.

00:33:59.000 --> 00:34:05.000
OBS Studio는 사용자가 컴퓨터에서 녹화 및 스트리밍 콘텐츠를 관리할 수 있는 오픈 소스 응용 프로그램입니다.

00:34:05.000 --> 00:34:11.000
여기에는 올 봄에 통합하는 프로젝트와 함께 작업한 ScreenCaptureKit의 구현이 포함되어 있습니다.

00:34:11.000 --> 00:34:18.000
ScreenCaptureKit은 OBS의 기존 CGDisplayStream 기반 캡처와 유사한 코드를 활용하여 구현하기 쉬웠다.

00:34:18.000 --> 00:34:24.000
ScreenCaptureKit 구현은 "Meet ScreenCaptureKit" 세션에서 논의된 많은 기능을 보여줍니다.

00:34:24.000 --> 00:34:30.000
여기에는 전체 데스크톱, 응용 프로그램의 모든 창 또는 하나의 특정 창만 캡처하는 것이 포함됩니다.

00:34:30.000 --> 00:34:36.000
ScreenCaptureKit은 OBS의 CGWindowListCreateImage 기반 캡처보다 오버헤드가 낮습니다.

00:34:36.000 --> 00:34:43.000
즉, 화면의 일부를 캡처할 때 콘텐츠를 제작하는 데 사용할 수 있는 더 많은 리소스가 남아 있습니다.

00:34:43.000 --> 00:34:46.000
우리가 실제로 논의하고 있는 것을 보기 위해 데모에 뛰어들어 봅시다.

00:34:46.000 --> 00:34:51.000
왼쪽에는 OBS의 윈도우 캡처의 최악의 사례가 있다.

00:34:51.000 --> 00:34:56.000
이 캡처는 CGWindowListCreateImage API를 사용하며, 상당한 말더듬이 있다.

00:34:56.000 --> 00:35:01.000
우리의 테스트에서, 우리는 프레임 속도가 7fps만큼 낮아진 것을 보았다.

00:35:01.000 --> 00:35:09.000
한편, 오른쪽의 ScreenCaptureKit 구현은 훨씬 더 부드러운 결과를 가지고 있으며, 훨씬 더 부드러운 동작으로 출력 비디오를 제공합니다.

00:35:09.000 --> 00:35:13.000
이 경우, 60fps를 제공한다.

00:35:13.000 --> 00:35:19.000
OBS는 윈도우 캡처보다 최대 15% 적은 RAM을 사용한다.

00:35:19.000 --> 00:35:28.000
그리고 OBS의 윈도우 캡처 대신 ScreenCaptureKit을 사용할 때 OBS의 CPU 사용률이 최대 절반으로 줄어드는 동안.

00:35:28.000 --> 00:35:33.000
ScreenCaptureKit이 OBS 사용자에게 제공해야 하는 다른 개선 사항을 살펴봅시다.

00:35:33.000 --> 00:35:37.000
나는 여전히 사요나라 와일드 하트의 모든 골드 랭크를 추적하려고 노력하고 있다.

00:35:37.000 --> 00:35:40.000
나는 내 최고의 달리기를 자랑하고 싶어서, 내 게임플레이를 녹화하고 있다.

00:35:40.000 --> 00:35:50.000
ScreenCaptureKit 덕분에 이제 게임에서 직접 오디오 스트림을 캡처할 수 있으므로 Mac에서 알림을 받으면 녹음의 오디오나 비디오를 망치지 않습니다.

00:35:50.000 --> 00:35:54.000
그리고 이것은 추가적인 오디오 라우팅 소프트웨어를 설치할 필요 없이 가능합니다.

00:35:54.000 --> 00:35:56.000
♪

00:35:56.000 --> 00:36:06.000
이제 Apple Silicon의 ScreenCaptureKit에서 제공하는 모든 개선 사항을 사용하여 Taiko no Tatsujin Pop Tap Beat와 같은 게임을 Mac에서 인기 있는 스트리밍 서비스로 스트리밍할 수 있습니다.

00:36:06.000 --> 00:36:17.000
애플 실리콘의 하드웨어 인코더를 위한 새로운 일정한 비트레이트 옵션은 게임의 성능에 큰 영향을 미치지 않고 일정한 비트레이트가 필요한 서비스에 대한 스트리밍 콘텐츠를 인코딩할 수 있다는 것을 의미합니다.

00:36:17.000 --> 00:36:24.000
이제, ScreenCaptureKit의 낮은 리소스 사용량과 인코딩 오프로드 덕분에, 저는 중요한 콘텐츠에 대해 훨씬 더 많은 성능을 사용할 수 있습니다.

00:36:24.000 --> 00:36:25.000
너에게 돌아가, 멩.

00:36:25.000 --> 00:36:28.000
멩: 고마워, 드류.

00:36:28.000 --> 00:36:34.000
데모와 예제를 통해 고급 화면 콘텐츠 필터에 대해 배웠습니다.

00:36:34.000 --> 00:36:38.000
다양한 사용 사례에 맞게 스트림을 구성하는 몇 가지 방법.

00:36:38.000 --> 00:36:44.000
그리고 프레임별 메타데이터를 사용하고 캡처된 콘텐츠를 올바르게 표시하는 방법.

00:36:44.000 --> 00:36:49.000
최고의 성과를 달성하는 데 도움이 되는 몇 가지 모범 사례.

00:36:49.000 --> 00:36:59.000
그리고 마지막으로, 드류는 OBS에 가져온 중요한 기능과 성능 개선 ScreenCaptureKit을 선보였다.

00:36:59.000 --> 00:37:09.000
ScreenCaptureKit을 사용하여 앱의 화면 공유, 스트리밍 및 협업 경험을 어떻게 재정의하는지 빨리 보고 싶습니다.

00:37:09.000 --> 00:37:11.000
봐줘서 고마워!

00:37:11.000 --> 23:59:59.000
♪

