WEBVTT

00:00:00.000 --> 00:00:03.000
♪ 부드러운 기악 힙합 음악 ♪

00:00:03.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:13.000
안녕하세요, "Meet Transferable" 세션에 오신 것을 환영합니다.

00:00:13.000 --> 00:00:26.000
제 이름은 줄리아입니다. 저는 SwiftUI 엔지니어이며, 앱에서 드래그 앤 드롭, 복사/붙여넣기 및 기타 기능을 지원하는 선언적인 방법인 Transferable을 소개하게 되어 기쁩니다.

00:00:26.000 --> 00:00:34.000
SwiftUI와 Mac용 응용 프로그램 개발 외에도, 저는 컴퓨터 과학 분야의 여성들의 이야기에도 관심이 있습니다.

00:00:34.000 --> 00:00:38.000
나는 우리가 우리의 영웅을 아는 것이 중요하다고 생각한다.

00:00:38.000 --> 00:00:50.000
그래서 나는 여성 발명가, 엔지니어 및 과학자 프로필 목록을 보고, 추가하고, 편집할 수 있는 카탈로그 애플리케이션을 만들기로 결정했다.

00:00:50.000 --> 00:01:04.000
저는 이 응용 프로그램이 과학자들의 초상화를 앱으로 드래그 앤 드롭하여 클립보드 콘텐츠를 사용하여 흥미로운 사실을 붙여넣을 수 있기를 바랍니다.

00:01:04.000 --> 00:01:10.000
그리고 처음으로, 내 앱은 watchOS에서 공유를 지원할 수 있습니다!

00:01:10.000 --> 00:01:17.000
내 잠재적인 사용자들은 그들의 시계에서 성격 프로필을 공유할 수 있기를 좋아한다고 말한다.

00:01:17.000 --> 00:01:29.000
또한, SwiftUI를 통해 iOS와 Mac에서 공유를 사용할 수 있으며, 올해 ShareSheet의 새로운 디자인도 있습니다.

00:01:29.000 --> 00:01:42.000
이러한 모든 기능을 활성화하려면 앱 내부의 수신기 또는 다른 응용 프로그램에서 수신기로 전송되는 것을 이미 지원해야 하는 모델이 필요합니다.

00:01:42.000 --> 00:01:49.000
프로필 구조는 우리가 가진 단일 성격에 대한 모든 정보를 포함한다.

00:01:49.000 --> 00:01:54.000
아카이브에 포장된 모든 프로필은 친구들 사이에서 공유할 수 있습니다.

00:01:54.000 --> 00:02:01.000
우리는 성격에 대한 재미있는 사실을 문자열로 저장하고 심지어 비디오를 첨부할 수도 있습니다.

00:02:01.000 --> 00:02:07.000
그리고 이 모든 모델 유형을 공유할 수 있는 새롭고 쉬운 방법이 있습니다.

00:02:07.000 --> 00:02:09.000
양도 가능한 것을 만나세요!

00:02:09.000 --> 00:02:20.000
공유 및 데이터 전송을 위해 모델을 직렬화하고 역직렬화할 수 있는 방법을 설명하는 스위프트 우선 선언적 방법입니다.

00:02:20.000 --> 00:02:40.000
오늘, 우리는 Transferable이 무엇인지, 그리고 우리가 그것을 사용할 때 무대 뒤에서 무슨 일이 일어나고 있는지에 대해 이야기할 것입니다; 사용자 지정 유형을 준수하는 방법; 그리고 마지막에, 나는 당신이 필요한 것을 정확히 하기 위해 Transferable을 사용자 정의하는 데 도움이 될 수 있는 몇 가지 고급 팁과 트릭을 공유할 것입니다.

00:02:40.000 --> 00:02:43.000
시작하자!

00:02:43.000 --> 00:02:58.000
두 개의 응용 프로그램이 실행 중이며, 사용자가 복사/붙여넣기, ShareSheet, 드래그 또는 다른 앱 기능을 통해 한 앱에서 다른 앱으로 정보를 전달하고 싶다고 가정해 봅시다.

00:02:58.000 --> 00:03:05.000
두 개의 다른 앱 사이에 무언가를 보낼 때, 가로지르는 이 모든 이진 데이터가 있습니다.

00:03:05.000 --> 00:03:12.000
이 데이터를 보내는 중요한 부분은 그것이 무엇에 해당하는지 결정하는 것이다.

00:03:12.000 --> 00:03:21.000
그것은 텍스트, 비디오, 내가 가장 좋아하는 여성 엔지니어 프로필 또는 전체 아카이브일 수 있다.

00:03:21.000 --> 00:03:26.000
그리고 데이터가 무엇을 위한 것인지 설명하는 UTType이 있습니다.

00:03:26.000 --> 00:03:31.000
앱이 이 바이너리 데이터를 어떻게 생성하는지 자세히 살펴봅시다.

00:03:31.000 --> 00:03:55.000
다른 앱 또는 단일 애플리케이션 내에서 공유할 수 있는 모든 유형은 두 가지 정보를 제공해야 합니다: 바이너리 데이터로 변환하는 방법과 바이너리 데이터의 구조에 대응하고 수신자에게 실제로 얻은 것을 알려주는 콘텐츠 유형.

00:03:55.000 --> 00:04:07.000
균일한 유형 식별자로 알려진 콘텐츠 유형은 추상적인 개념뿐만 아니라 다른 이진 구조에 대한 식별자를 설명하는 Apple 특정 기술이다.

00:04:07.000 --> 00:04:13.000
식별자는 트리를 형성하며, 사용자 지정 식별자를 정의할 수도 있습니다.

00:04:13.000 --> 00:04:18.000
예를 들어, 우리 프로필에서 사용하는 이진 구조를 위한 것.

00:04:18.000 --> 00:04:26.000
사용자 지정 식별자를 선언하려면, 먼저 Info.plist 파일에 선언을 추가하십시오.

00:04:26.000 --> 00:04:30.000
파일 확장자를 추가하는 것도 좋은 생각이다.

00:04:30.000 --> 00:04:37.000
데이터가 디스크에 저장되면, 시스템은 앱이 그 파일을 열 수 있다는 것을 알게 될 것입니다.

00:04:37.000 --> 00:04:40.000
두 번째로, 그것을 코드로 선언하세요.

00:04:40.000 --> 00:04:49.000
콘텐츠 유형에 대해 자세히 알아보려면, "Uniform Type Identifiers -- A reintroduction"이라는 비디오를 시청하도록 초대합니다.

00:04:49.000 --> 00:04:58.000
개인적으로, 나는 그것을 좋아하고, 그것은 균일한 유형 식별자가 무엇이며 어떻게 사용하는지에 대한 명확한 아이디어를 제공한다.

00:04:58.000 --> 00:05:10.000
좋은 소식은 많은 표준 유형이 이미 Transferable을 준수한다는 것입니다; 예를 들어, 문자열, 데이터, URL, 속성 문자열, 이미지.

00:05:10.000 --> 00:05:27.000
새로운 SwiftUI 붙여넣기 버튼 인터페이스로 프로필에 재미있는 사실을 붙여넣거나, 보기에서 이미지를 드래그하거나, Finder 또는 다른 앱에서 삭제된 이미지를 수신하려면 몇 줄의 코드만 있으면 됩니다.

00:05:27.000 --> 00:05:34.000
Br과 새로운 ShareLink를 사용하여, 우리는 이제 시계에서 공유 경험을 구현할 수 있습니다.

00:05:34.000 --> 00:05:40.000
우리는 기본 사항을 다루었고, 이제 당신은 Transferable을 사용하는 방법과 그것이 무엇인지에 대한 아이디어를 갖게 되었습니다.

00:05:40.000 --> 00:05:47.000
응용 프로그램의 모델에 양도 가능한 적합성을 추가하는 방법을 봅시다.

00:05:47.000 --> 00:05:54.000
앞서 언급했듯이, 우리 앱에는 공유될 네 가지 모델 유형이 있습니다.

00:05:54.000 --> 00:06:01.000
그 중 하나인 문자열은 이미 Transferable을 준수합니다. 우리는 더 이상 아무것도 할 필요가 없습니다.

00:06:01.000 --> 00:06:09.000
하지만 단일 프로필, ProfilesArchive, 그리고 제가 공유하고 싶은 비디오는 어떤가요?

00:06:09.000 --> 00:06:17.000
Transferable에 유형을 적용하기 위해, 구현해야 할 속성은 단 하나뿐입니다: TransferRepresentation.

00:06:17.000 --> 00:06:22.000
그것은 모델이 어떻게 이전될 것인지를 설명한다.

00:06:22.000 --> 00:06:31.000
알아야 할 세 가지 중요한 표현이 있습니다: CodableRepresentation, DataRepresentation 및 FileRepresentation.

00:06:31.000 --> 00:06:34.000
우리는 그들 각각에 대해 이야기할 거야.

00:06:34.000 --> 00:06:39.000
하지만 먼저, 우리의 중심 모델인 프로필 구조를 만나세요.

00:06:39.000 --> 00:06:46.000
그것은 신분증, 이름, 약력, 아마도 재미있는 사실, 초상화, 그리고 비디오가 있다.

00:06:46.000 --> 00:06:48.000
그것은 이미 Codable에 부합한다.

00:06:48.000 --> 00:06:56.000
그 때문에, 우리는 양도 가능한 적합성에 CodableRepresentation을 포함시킬 수 있다.

00:06:56.000 --> 00:07:05.000
코딩 가능한 표현은 인코더를 사용하여 프로필을 이진 데이터로 변환하고 디코더를 사용하여 다시 변환합니다.

00:07:05.000 --> 00:07:12.000
기본적으로 JSON을 사용하지만, 자신만의 인코더/디코더 쌍을 제공할 수도 있습니다.

00:07:12.000 --> 00:07:26.000
코딩 가능한 프로토콜과 인코더와 디코더의 작동 방식에 대해 자세히 알아보려면, 이 프로토콜이 처음 도입된 WWDC 세션을 시청하도록 초대합니다: "신뢰할 수 있는 데이터."

00:07:26.000 --> 00:07:28.000
우리 프로필로 돌아가.

00:07:28.000 --> 00:07:34.000
Codable이 요구하는 유일한 것은 원하는 콘텐츠 유형을 아는 것이다.

00:07:34.000 --> 00:07:41.000
이것은 사용자 지정 형식이 될 것이기 때문에, 우리는 사용자 지정 선언된 균일 유형 식별자를 사용할 것이다.

00:07:41.000 --> 00:07:45.000
프로필 콘텐츠 유형을 추가한 후, 우리는 갈 수 있습니다.

00:07:45.000 --> 00:07:49.000
프로필은 이제 Transferable에 부합합니다!

00:07:49.000 --> 00:07:54.000
이제, 다른 사례를 살펴봅시다: ProfilesArchive.

00:07:54.000 --> 00:07:58.000
그것은 이미 CSV 데이터로의 변환을 지원합니다.

00:07:58.000 --> 00:08:08.000
CSV 파일에서 여성 프로필 목록을 내보낸 다음 친구들과 공유하거나 다른 컴퓨터로 가져올 수 있습니다.

00:08:08.000 --> 00:08:18.000
아카이브는 데이터로 변환될 수 있으며, 이는 우리가 DataRepresentation을 사용할 수 있다는 것을 의미합니다.

00:08:18.000 --> 00:08:30.000
내부를 들여다보면, DataRepresentation이 변환 함수를 사용하여 이진 표현을 직접 만들고 수신기의 값을 재구성한다는 것을 알 수 있습니다.

00:08:30.000 --> 00:08:36.000
이것은 DataRepresentation을 사용하여 Transferable을 준수하는 것이 얼마나 쉬운지이다.

00:08:36.000 --> 00:08:46.000
우리가 이미 가지고 있는 두 가지 기능을 호출하기만 하면 됩니다: 이니셜라이저와 CSV 변환기.

00:08:46.000 --> 00:08:53.000
성격 프로필에 비디오가 첨부되어 있다면, 나도 그것을 드래그하거나 공유하고 싶다.

00:08:53.000 --> 00:08:58.000
하지만 비디오는 클 수 있다; 나는 그것을 메모리에 넣고 싶지 않다.

00:08:58.000 --> 00:09:02.000
이것이 FileRepresentation이 들어오는 곳이다.

00:09:02.000 --> 00:09:14.000
그리고 다시, 커튼을 들어 올리면 FileRepresentation이 제공된 URL을 수신자에게 전달하고 이를 사용하여 전송 가능한 항목을 재구성하는 것을 볼 수 있습니다.

00:09:14.000 --> 00:09:23.000
FileRepresentation을 사용하면 디스크에 기록된 이진 표현으로 뒷받침되는 항목을 공유할 수 있습니다: 파일.

00:09:23.000 --> 00:09:25.000
요약하자.

00:09:25.000 --> 00:09:37.000
간단한 사용 사례에 대해 하나의 표현만 선택하고 싶다면, 먼저 모델에 코딩 가능한 적합성이 있고 특정 이진 형식 요구 사항이 없는지 확인하십시오.

00:09:37.000 --> 00:09:40.000
그렇다면 CodableRepresentation을 사용하세요.

00:09:40.000 --> 00:09:45.000
그렇지 않다면, 메모리나 디스크에 저장되어 있는지 확인하세요.

00:09:45.000 --> 00:09:51.000
DataRepresentation은 전자에 가장 잘 작동하고, FileRepresetnation은 후자에 가장 잘 작동한다.

00:09:51.000 --> 00:09:57.000
양도 가능한 것은 간단한 사용 사례뿐만 아니라 복잡한 사용 사례도 다루기 위한 것이다.

00:09:57.000 --> 00:10:01.000
그리고 대부분의 경우, 단지 몇 줄의 코드로.

00:10:01.000 --> 00:10:04.000
직접 봐!

00:10:04.000 --> 00:10:10.000
이전에, 우리는 프로필에 양도 가능한 적합성을 추가했지만, 더 나아가자.

00:10:10.000 --> 00:10:19.000
프로필을 붙여넣기 보드에 복사하여 텍스트 필드에 붙여넣으면, 프로필 이름을 붙여넣고 싶습니다.

00:10:19.000 --> 00:10:23.000
이것은 우리가 다른 표현을 추가해야 한다는 것을 의미한다.

00:10:23.000 --> 00:10:29.000
ProxyRepresentation은 다른 양도 가능한 유형이 우리의 모델을 나타낼 수 있게 해준다.

00:10:29.000 --> 00:10:34.000
한 줄, 그리고 프로필은 텍스트로 붙여넣을 수 있습니다.

00:10:34.000 --> 00:10:41.000
Codable 이후에 ProxyRepresentation을 추가했습니다. 주문이 중요합니다.

00:10:41.000 --> 00:10:47.000
수신자는 그들이 지원하는 콘텐츠 유형으로 첫 번째 표현을 사용할 것이다.

00:10:47.000 --> 00:10:52.000
수신자가 우리의 사용자 지정 콘텐츠 유형 프로필을 알고 있다면, 그들은 그것을 사용해야 합니다.

00:10:52.000 --> 00:11:00.000
그렇지 않다면, 그들이 텍스트를 지원한다면, 그들이 대신 ProxyRepresentation을 사용하도록 하세요.

00:11:00.000 --> 00:11:07.000
이제, 프로필은 인코더/디코더 변환과 텍스트 변환을 모두 지원합니다.

00:11:07.000 --> 00:11:15.000
이 경우 ProxyRepresentation은 텍스트로 내보내기만 설명하지만, 프로필을 재구성하지는 않습니다.

00:11:15.000 --> 00:11:20.000
어떤 표현이든 두 가지 변환 또는 하나만 설명할 수 있다.

00:11:20.000 --> 00:11:28.000
이제, 우리가 ProxyRepresentations에 대해 알게 되면, 비디오에 FileRepresentation이 정말 필요한가요?

00:11:28.000 --> 00:11:31.000
우리는 URL이 있는 프록시를 가질 수 있다.

00:11:31.000 --> 00:11:33.000
그 차이는 미묘하다.

00:11:33.000 --> 00:11:46.000
FileRepresentation은 디스크에 쓰여진 URL로 작업하고, 임시 샌드박스 확장을 부여하여 수신자가 이 파일 또는 복사본에 액세스할 수 있도록 하기 위한 것입니다.

00:11:46.000 --> 00:11:53.000
ProxyRepresentation은 문자열과 같은 다른 전송 가능한 항목과 같은 방식으로 URL을 취급합니다.

00:11:53.000 --> 00:11:58.000
그것은 우리가 파일에 필요한 이러한 추가 기능 중 어느 것도 가지고 있지 않다.

00:11:58.000 --> 00:12:01.000
그건 우리가 둘 다 가질 수 있다는 뜻이야.

00:12:01.000 --> 00:12:08.000
첫 번째인 FileRepresentation은 수신기가 내용과 함께 영화 파일에 액세스할 수 있게 해준다.

00:12:08.000 --> 00:12:15.000
두 번째는 복사된 비디오를 텍스트 필드에 붙여넣을 때 작동할 것이다.

00:12:15.000 --> 00:12:21.000
따라서 URL은 파일과 프록시 표현에 의해 매우 다르게 취급됩니다.

00:12:21.000 --> 00:12:35.000
첫 번째 경우, 실제 페이로드는 디스크의 자산이고, 두 번째 경우, 페이로드는 원격 웹사이트를 가리킬 수 있는 URL 구조 자체이다.

00:12:35.000 --> 00:12:39.000
내가 업그레이드하고 싶은 또 다른 모델은 ProfilesArchive이다.

00:12:39.000 --> 00:12:46.000
CSV로 변환을 지원하지 않는 경우가 있으며, 저는 그것을 코드에 반영하고 싶습니다.

00:12:46.000 --> 00:12:48.000
어디 보자.

00:12:48.000 --> 00:12:57.000
우리는 CSV로 내보낼 수 있는지와 데이터를 데이터로 변환할 수 있는지 알려주는 부울 속성을 추가합니다.

00:12:57.000 --> 00:13:03.000
이 아이디어를 코드로 표현하기 위해, 우리는 .exportingCondition을 사용할 수 있다.

00:13:03.000 --> 00:13:09.000
주어진 아카이브가 CSV를 지원하지 않는다면, 이 형식으로 내보내지지 않을 것이다.

00:13:09.000 --> 00:13:16.000
이 API를 사용하면 SwiftUI의 사용자 지정 뷰와 마찬가지로 사용자 지정 TransferRepresentation을 구축할 수도 있습니다.

00:13:16.000 --> 00:13:24.000
유일한 요구 사항은 필요한 방식으로 다른 표현을 구성할 수 있는 신체 속성을 제공하는 것입니다.

00:13:24.000 --> 00:13:35.000
표현의 조합을 재사용하거나 공개적으로 노출하고 싶지 않은 개인 데이터 표현이 있는 경우 유용합니다.

00:13:35.000 --> 00:13:42.000
Transferable은 내가 원하는 모든 기능으로 이 애플리케이션을 빠르게 구축하는 데 도움이 되었다.

00:13:42.000 --> 00:13:49.000
그 어느 때보다 짧은 시간에 기능이 풍부한 앱을 만드는 데 도움이 되기를 바랍니다.

00:13:49.000 --> 00:13:54.000
이 세션에 참여해 주시고 놀라운 앱을 계속 만들어 주셔서 감사합니다!

00:13:54.000 --> 23:59:59.000
♪

