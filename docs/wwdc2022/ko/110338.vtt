WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:12.000
안녕하세요, 제 이름은 닉이고, 저는 비디오 팀의 엔지니어입니다.

00:00:12.000 --> 00:00:17.000
오늘 저는 미디어 메타데이터 게시 및 재생 상호 작용에 대해 이야기하게 되어 기쁩니다.

00:00:17.000 --> 00:00:19.000
그래서 그게 정확히 무슨 뜻이야?

00:00:19.000 --> 00:00:25.000
Apple 장치에는 재생 정보가 표시되고 재생을 제어할 수 있는 많은 장소가 있습니다.

00:00:25.000 --> 00:00:32.000
예를 들어, 제어 센터의 지금 재생 중 섹션은 현재 장치에서 재생 중인 미디어의 삽화, 제목 및 진행 상황을 표시합니다.

00:00:32.000 --> 00:00:36.000
또한 연주하거나, 일시 정지하거나, 앞뒤로 건너뛸 수 있습니다.

00:00:36.000 --> 00:00:40.000
지금 재생 중인 타일을 확장하면 작품과 진행 상황과 같은 더 많은 세부 사항이 표시됩니다.

00:00:40.000 --> 00:00:45.000
그것은 또한 당신이 스크럽하고 볼륨을 늘리거나 줄일 수 있게 해준다.

00:00:45.000 --> 00:00:57.000
잠금 화면은 또한 동일한 정보와 컨트롤을 표시하여 사용자가 잠금을 해제할 필요 없이 진행 상황, 일시 정지 또는 AirPlay를 다른 장치로 확인할 수 있는 편리한 장소를 제공합니다.

00:00:57.000 --> 00:01:01.000
어떤 장치가 재생되든, Apple Watch의 Now Playing 앱은 동일한 경험을 제공합니다.

00:01:01.000 --> 00:01:05.000
심지어 Apple TV 리모컨도 내장되어 있다.

00:01:05.000 --> 00:01:11.000
AVKit을 사용할 때 tvOS에서 컨트롤이 표시될 때 정보 오버레이에 제목과 장 정보가 표시됩니다.

00:01:11.000 --> 00:01:17.000
정보 창으로 쓸어내리면, 삽화와 설명과 같은 더 많은 세부 사항이 표시됩니다.

00:01:17.000 --> 00:01:25.000
Apple TV 리모컨의 TV 버튼을 누르면 iOS와 같이 확장 가능한 지금 재생 중인 타일이 있는 제어 센터가 표시됩니다.

00:01:25.000 --> 00:01:38.000
오디오 콘텐츠가 tvOS의 백그라운드에서 재생되기 시작하면, 리모컨의 재생 버튼을 누르거나 다른 장치에서 음악 앱에서 트랙을 선택하면 지금 재생 중 정보가 포함된 알림이 표시됩니다.

00:01:38.000 --> 00:01:48.000
또한, 오디오를 재생할 때 tvOS에서 잠시 동안 활동하지 않으면, 현재 재생 중인 것을 보여주는 전체 화면 오버레이가 표시됩니다.

00:01:48.000 --> 00:01:58.000
마지막으로, iOS에서 다른 스피커와 TV 제어 버튼을 사용하면 모든 장치에서 지금 재생 중 정보를 보고 재생을 제어할 수 있습니다.

00:01:58.000 --> 00:02:08.000
지금 재생 정보가 표시되고 재생을 제어할 수 있는 장치와 UI가 증가함에 따라, 지금 재생 정보를 올바르게 게시하고 원격 명령에 응답하는 것이 그 어느 때보다 중요합니다.

00:02:08.000 --> 00:02:18.000
이 세션의 나머지 기간 동안, 우리는 원격 명령, 자동 메타데이터 게시, AVKit을 사용한 게시 및 수동 게시의 형태로 재생 상호 작용에 대한 응답을 다룰 것입니다.

00:02:18.000 --> 00:02:28.000
미디어 재생을 위해 AVFoundation을 사용할 때, 지금 재생 중 메타데이터를 게시하고 재생 상호 작용에 응답하는 가장 좋은 방법은 MPNowPlayingSession 클래스를 사용하는 것입니다.

00:02:28.000 --> 00:02:36.000
역사적으로, 이 수업은 tvOS에서만 사용할 수 있었지만, 지금은 iOS 16에서 사용할 수 있습니다.

00:02:36.000 --> 00:02:44.000
그것은 뚜렷한 재생 세션을 나타내는 데 사용되며, 앱에 여러 활성 세션이 포함된 경우 지금 재생 중 상태에 대한 제어를 제공합니다.

00:02:44.000 --> 00:02:52.000
수동 메타데이터 게시와 iOS 및 tvOS 16에서 사용할 수 있는 새로운 자동 게시를 모두 지원합니다.

00:02:52.000 --> 00:03:00.000
MPNowPlayingSession은 세션 후반부에서 다룰 자체 자동 게시 메커니즘이 있는 AVKit을 사용할 때 tvOS에서 사용해서는 안 됩니다.

00:03:00.000 --> 00:03:10.000
"지금 재생 중" 앱이 된다는 것은 앱이 제어 센터, 잠금 화면 등을 채우고, 예를 들어 사용자가 이러한 인터페이스 중 하나에서 일시 정지를 누를 때 재생 컨트롤을 받는다는 것을 의미합니다.

00:03:10.000 --> 00:03:15.000
MPNowPlayingSession을 사용하면 단일 앱 내에서 여러 동시 재생 세션을 나타낼 수 있습니다.

00:03:15.000 --> 00:03:22.000
그러나, 여러 세션을 사용할 때, 앱은 앱을 원격으로 제어할 때 시스템 전체에 나타나는 활성 세션으로 하나를 홍보해야 합니다.

00:03:22.000 --> 00:03:30.000
예를 들어, Picture in Picture를 사용하면 두 개의 동시 재생 세션을 가질 수 있으며, 전체 화면 재생은 활성 재생 중인 세션으로 간주되어야 합니다.

00:03:30.000 --> 00:03:34.000
이 시스템에는 또한 앱을 Now Playing 적격으로 인정하기 위한 몇 가지 휴리스틱이 있습니다.

00:03:34.000 --> 00:03:38.000
먼저, 적어도 하나의 원격 명령에 대해 핸들러를 등록해야 합니다.

00:03:38.000 --> 00:03:45.000
상상할 수 있듯이, 재생 상호 작용에 응답하지 않는 앱은 지금 재생 중인 앱으로 나타나기에 이상적인 후보가 아닐 가능성이 큽니다.

00:03:45.000 --> 00:03:52.000
둘째, 앱 AVAudioSession은 혼합할 수 없는 카테고리와 카테고리 옵션으로 구성되어야 합니다.

00:03:52.000 --> 00:04:01.000
혼합 가능한 재생 카테고리와 옵션은 일반적으로 알림을 재생할 때 사용되며, 따라서 이것은 재생 중인 것이 무엇이든 지금 재생하기에 좋은 후보가 아니라는 시스템에 좋은 표시입니다.

00:04:01.000 --> 00:04:04.000
재생 세션을 이해하는 데 도움이 되는 몇 가지 예가 있습니다.

00:04:04.000 --> 00:04:10.000
이 예에서는 하나의 콘텐츠 재생이 있으므로, 이것은 단일 MPNowPlayingSession을 사용하여 표현될 것이다.

00:04:10.000 --> 00:04:17.000
앱이 PiP를 지원하는 경우, 두 개의 MPNowPlayingSessions가 있습니다: 하나는 메인 플레이어용이고 다른 하나는 PiP 재생용입니다.

00:04:17.000 --> 00:04:22.000
더 복잡한 시나리오는 여러 플레이어가 있는 단일 MPNowPlayingSession일 것이다.

00:04:22.000 --> 00:04:27.000
이 예에서, 우리는 같은 인종에 대해 다른 관점을 보여주는 각 사분면에 한 명씩 네 명의 선수가 있다.

00:04:27.000 --> 00:04:33.000
동일한 MPNowPlayingSession에 추가된 플레이어는 항상 동일한 콘텐츠의 일부여야 합니다.

00:04:33.000 --> 00:04:36.000
그리고 이 예시 세션들 각각이 인스턴스화되는 방법은 다음과 같습니다.

00:04:36.000 --> 00:04:41.000
첫 번째, 우리는 단지 하나의 콘텐츠를 재생하고 있으므로, 싱글 플레이어와 단일 세션이 있습니다.

00:04:41.000 --> 00:04:46.000
두 번째 예는 Picture-in-Picture를 사용하는 것이므로, 각각 한 명의 플레이어가 있는 두 개의 세션이 있습니다.

00:04:46.000 --> 00:04:50.000
첫 번째는 전체 화면 콘텐츠이고, 두 번째는 PiP의 콘텐츠이다.

00:04:50.000 --> 00:04:57.000
마지막 예인 멀티뷰 레이스는 네 명의 선수로 구성된 단일 세션으로 표현된다.

00:04:57.000 --> 00:05:02.000
앱에 여러 세션이 있는 경우, 해당되는 경우 주어진 세션을 활성 상태로 홍보하는 것은 앱의 책임입니다.

00:05:02.000 --> 00:05:13.000
예를 들어, 미디어가 Picture-in-Picture에서 재생되는 경우, 사용자가 전체 화면으로 확장하면, 이전 전체 화면 세션은 더 이상 활성화되지 않거나 지금 재생 중이어야 하며, 현재 전체 화면인 PiP 세션이 활성화되어야 합니다.

00:05:13.000 --> 00:05:20.000
이 전환은 MPNowPlayingSession에서 becomeActiveIfPossible을 호출하여 수행할 수 있습니다.

00:05:20.000 --> 00:05:31.000
이제 MPNowPlayingSession의 인스턴스를 설정하고 지금 재생 중 세션을 제어하는 기본 사항을 다루었으므로, 잠금 화면이나 다른 방의 HomePod에서 원격 명령을 수신하고 응답하는 것에 대해 이야기해 봅시다.

00:05:31.000 --> 00:05:35.000
재생 및 일시 정지 명령에 등록하는 기본적인 예부터 시작합시다.

00:05:35.000 --> 00:05:43.000
그렇게 하면 사용자가 다른 장치에서 재생 또는 일시 정지를 누르거나 Siri를 사용하여 명령을 실행할 때 앱이 콜백을 받을 수 있습니다.

00:05:43.000 --> 00:05:46.000
먼저, 우리는 MPNowPlayingSession을 인스턴스화합니다.

00:05:46.000 --> 00:05:50.000
세션이 하나밖에 없기 때문에, 'becomeActiveIfPossible' 메소드를 호출할 필요가 없습니다.

00:05:50.000 --> 00:05:56.000
세션이 하나만 있을 때, 앱이 지금 재생 중인 앱일 때 기본 세션이 됩니다.

00:05:56.000 --> 00:06:04.000
각 MPNowPlayingSession 인스턴스에는 재생 세션이 응답할 수 있는 원격 명령을 선언하는 데 사용되는 자체 MPRemoteCommandCenter 인스턴스가 있습니다.

00:06:04.000 --> 00:06:11.000
다음으로 우리는 플레이어의 플레이 메소드를 호출하는 playCommand의 핸들러를 추가하고 성공을 반환합니다.

00:06:11.000 --> 00:06:14.000
그러면 우리는 일시 정지 명령에 대해서도 똑같이 한다.

00:06:14.000 --> 00:06:20.000
앱이 지원하고 현재 재생 중인 콘텐츠에 적용되는 모든 명령에 대해 핸들러를 추가해야 합니다.

00:06:20.000 --> 00:06:23.000
또 다른 예는 앞으로 건너뛰고 뒤로 건너뛰는 명령이다.

00:06:23.000 --> 00:06:30.000
이 명령은 대부분의 콘텐츠에 사용되어야 하며, 예를 들어 앞으로 점프할 수 없는 라이브 스트림은 적용되지 않습니다.

00:06:30.000 --> 00:06:36.000
먼저 우리는 우리가 선호하는 간격이 무엇인지, 또는 어느 방향으로든 점프하는 것을 선호하는 초 수를 표시해야 합니다.

00:06:36.000 --> 00:06:38.000
이 경우, 우리는 15초를 사용한다.

00:06:38.000 --> 00:06:47.000
그런 다음 우리가 재생 및 일시 정지 명령을 위해 한 것과 마찬가지로, 우리는 사용자가 앞으로 건너뛰기 버튼을 누르거나 Siri에게 앞으로 건너뛰라고 요청할 때 호출될 핸들러를 추가합니다.

00:06:47.000 --> 00:06:54.000
핸들러에서 MPSkipIntervalCommandEvent를 받게 될 것이므로, 먼저 이벤트를 해당 유형으로 캐스팅할 것입니다.

00:06:54.000 --> 00:07:05.000
그런 다음 우리는 현재 시간과 MPSkipIntervalCommandEvent에서 우리에게 제공된 간격을 취하여 새로운 경과 시간을 계산하고, 그것을 찾고, 우리가 새로운 위치로 뛰어들었다는 것을 나타내기 위해 성공을 반환합니다.

00:07:05.000 --> 00:07:11.000
광고에서 앞으로 건너뛰는 것과 같이 앱이 명령이 일시적으로 허용되지 않는 상황이 있을 수도 있습니다.

00:07:11.000 --> 00:07:14.000
이 경우, skipForwardCommand를 비활성화할 수 있습니다.

00:07:14.000 --> 00:07:19.000
이제 원격 명령에 응답하고 있으니, 자동 메타데이터 게시를 다룰 것입니다.

00:07:19.000 --> 00:07:31.000
자동 게시는 지속 시간, 현재 경과 시간, 재생 상태 및 재생 진행 상황과 같은 플레이어에서 직접 관찰할 수 있는 메타데이터 속성을 자동으로 유지함으로써 메타데이터를 정확하게 유지하는 데 어려움을 겪습니다.

00:07:31.000 --> 00:07:39.000
콘텐츠에 총 기간과 경과 시간에 기여해서는 안 되는 광고가 있다면, 순 시간을 계산하고 대신 보고할 수도 있습니다.

00:07:39.000 --> 00:07:47.000
제목, 설명 및 삽화와 같은 다른 메타데이터는 nowPlayingInfo 속성을 사용하여 AVPlayerItems에 직접 추가할 수 있습니다.

00:07:47.000 --> 00:07:52.000
이 예에서, 우리는 자동 출판을 사용하여 대부분의 작업을 하고 제목과 작품을 직접 설정할 것이다.

00:07:52.000 --> 00:07:57.000
먼저, 우리는 아트워크 이미지를 전달하는 새로운 MPMediaItemArtwork 인스턴스를 만듭니다.

00:07:57.000 --> 00:08:00.000
대부분의 앱은 이것을 가져오기 위해 네트워크 요청을 수행할 것이다.

00:08:00.000 --> 00:08:03.000
그런 다음 우리는 내용의 문자열 제목을 설정합니다.

00:08:03.000 --> 00:08:12.000
그런 다음 작품과 제목을 가져와 MPMediaItemPropertyTitle과 MPMediaItemPropertyArtwork를 사용하여 현재 플레이어 항목의 nowPlayingInfo 사전으로 설정합니다.

00:08:12.000 --> 00:08:19.000
Now Playing 메타데이터는 MPMediaItemProperty와 MPNowPlayingInfoProperty로 구성될 수 있습니다.

00:08:19.000 --> 00:08:26.000
마지막으로, 우리는 플레이어에 전달되는 MPNowPlayingSession 인스턴스를 만들고, automaticallyPublishNowPlayingInfo를 true로 설정합니다.

00:08:26.000 --> 00:08:37.000
자동으로PublishNowPlayingInfo가 true로 설정되면, MPNowPlayingSession 인스턴스는 스크러빙, 재생/일시 정지 이벤트 또는 현재 플레이어 항목 변경과 같은 상태 변경에 대해 플레이어를 관찰하기 시작합니다.

00:08:37.000 --> 00:08:47.000
다음은 광고가 자산에 구워지고 총 기간이나 현재 경과 시간이 광고 시간을 포함하는 것을 원하지 않는 경우에 자동 게시를 사용하는 방법을 보여주는 또 다른 예입니다.

00:08:47.000 --> 00:08:52.000
이를 위해, 우리는 우리가 구운 모든 광고에 대해 MPAdTimeRange의 인스턴스를 만들 것입니다.

00:08:52.000 --> 00:08:56.000
이 예에서, 우리는 처음부터 시작하는 30초짜리 광고가 있습니다.

00:08:56.000 --> 00:09:01.000
그래서 우리는 0의 시작점과 30초의 지속 시간으로 그것을 만든다.

00:09:01.000 --> 00:09:14.000
이전에 제목과 작품을 했던 것과 마찬가지로, MPNowPlayingInfoPropertyAdTimeRanges를 사용하여 플레이어 항목의 nowPlayingInfo 사전에 MPAdTimeRange 배열을 추가하기만 하면 됩니다.

00:09:14.000 --> 00:09:20.000
그런 다음 이전과 마찬가지로, MPNowPlayingSession을 만들고 자동 게시를 활성화하세요.

00:09:20.000 --> 00:09:22.000
다음은 AVKit으로 메타데이터를 게시하는 것입니다.

00:09:22.000 --> 00:09:34.000
tvOS에서 AVKit으로 재생 중인 메타데이터는 MPNowPlayingSession과 매우 유사하게 작동합니다. 메타데이터는 AVPlayerItem에 직접 추가되며 경과 시간, 지속 시간 및 재생 상태와 같은 값이 게시되고 최신 상태로 유지됩니다.

00:09:34.000 --> 00:09:43.000
AVPlayerItem의 앱에서 제공하는 메타데이터와 결합된 플레이어와 자산에서 직접 수집된 메타데이터는 플레이어 UI의 정보 창을 채우는 데에도 사용됩니다.

00:09:43.000 --> 00:09:47.000
AVKit은 또한 원격 명령에 등록하고 응답하는 것을 처리합니다.

00:09:47.000 --> 00:09:55.000
AVKit을 사용하는 것은 우리가 지금까지 논의한 플랫폼 기능뿐만 아니라 AirPlay 및 Picture-in-Picture와 같은 다른 기능과 통합하는 가장 좋고 쉬운 방법입니다.

00:09:55.000 --> 00:10:05.000
AVKit을 사용할 때 메타데이터 설정은 콘텐츠를 설명하기 위해 AVMetadataItem 인스턴스로 구성된 AVPlayerItem의 externalMetadata 배열을 사용하여 수행됩니다.

00:10:05.000 --> 00:10:08.000
당신은 보통 각 AVMetadataItem에 세 가지 값을 설정합니다.

00:10:08.000 --> 00:10:14.000
먼저, AVMetadataItem이 나타내는 메타데이터를 나타내는 열쇠인 식별자.

00:10:14.000 --> 00:10:23.000
예를 들어, 콘텐츠 제목의 AVMetadataCommonIdentifierTitle 또는 작품의 AVMetadataCommonIdentifierArtwork.

00:10:23.000 --> 00:10:25.000
두 번째는 가치이다.

00:10:25.000 --> 00:10:27.000
제목의 경우, 이것은 제목을 포함하는 문자열이 될 것이다.

00:10:27.000 --> 00:10:31.000
작품의 경우, 이것은 이미지 데이터를 포함하는 NSData 인스턴스가 될 것이다.

00:10:31.000 --> 00:10:34.000
dataType은 제공된 작품의 형식을 나타내는 데 사용됩니다.

00:10:34.000 --> 00:10:40.000
JPEG 데이터가 포함되어 있다면, kCMMetadatabaseDataType_JPEG가 사용될 것이다.

00:10:40.000 --> 00:10:47.000
마지막으로, extendedLanguageTag는 제목과 설명과 같은 문자열에 사용되는 언어를 나타내는 데 사용됩니다.

00:10:47.000 --> 00:10:52.000
대부분의 경우, 모든 청중이 동일한 가치를 볼 수 있도록 "und" 값을 여기에 사용해야 합니다.

00:10:52.000 --> 00:11:02.000
값이 영어로 되어 있다면 "en-us"를 사용하고 싶은 유혹을 받을 수 있지만, 그렇게 하면 스페인어와 같은 다른 언어로 설정된 장치가 메타데이터를 표시하지 않을 수 있습니다.

00:11:02.000 --> 00:11:05.000
여기 우리가 작품과 제목을 설정하는 예시가 있습니다.

00:11:05.000 --> 00:11:08.000
먼저, 우리는 번들에서 작품 이미지 데이터를 수집합니다.

00:11:08.000 --> 00:11:11.000
대부분의 앱은 네트워크 리소스에서 이것을 가져올 것이다.

00:11:11.000 --> 00:11:15.000
그런 다음 우리는 새로운 변경 가능한 AVMetadataItem을 인스턴스화합니다.

00:11:15.000 --> 00:11:18.000
우리는 식별자를 .commonIdentifierArtwork로 설정했습니다.

00:11:18.000 --> 00:11:23.000
그런 다음 값을 원시 아트워크 이미지 데이터로 NSData로 설정합니다.

00:11:23.000 --> 00:11:28.000
이미지 데이터가 JPEG이기 때문에, 우리는 dataType을 kCMMetadataBaseDataType_JPEG로 설정했습니다.

00:11:28.000 --> 00:11:33.000
만약 당신의 작품이 대신 PNG였다면, kCMMetadataBaseDataType_PNG를 사용할 것입니다.

00:11:33.000 --> 00:11:40.000
이 메타데이터가 모든 언어로 설정된 장치가 있는 사용자가 볼 수 있기를 원하기 때문에, extendedLanguageTag를 "und" 또는 "undefined"로 설정합니다.

00:11:40.000 --> 00:11:49.000
그런 다음 .commonIdentifierTitle과 값에 대한 문자열 제목을 사용하여 제목에 대해 동일한 단계를 반복하고, extendedLanguageTag에 대해 다시 한 번 "und"를 반복합니다.

00:11:49.000 --> 00:11:57.000
모든 메타데이터 항목을 설정하면, 배열에 추가하고 AVPlayerItem의 externalMetadata 속성으로 설정합니다.

00:11:57.000 --> 00:12:05.000
이제 플레이어 아이템에 아트워크와 타이틀이 추가되었으므로, iOS의 제어 센터 및 잠금 화면에 표시되는 것과 어떻게 매핑되는지 볼 수 있습니다.

00:12:05.000 --> 00:12:11.000
삽화와 마찬가지로, 설명, 자막 정보 및 콘텐츠 등급과 같이 설정할 수 있는 다른 메타데이터 유형이 있습니다.

00:12:11.000 --> 00:12:17.000
당신의 앱은 사용자에게 가능한 한 풍부한 경험을 제공하기 위해 가능한 한 많은 것을 설정해야 합니다.

00:12:17.000 --> 00:12:22.000
지금까지 우리는 MPNowPlayingSession으로 자동 게시와 AVKit으로 게시를 다루었습니다.

00:12:22.000 --> 00:12:27.000
하지만 MPNowPlayingSession과 자동 게시 기능은 AVPlayer 인스턴스를 전달해야 합니다.

00:12:27.000 --> 00:12:31.000
그것은 모든 앱에 대한 옵션이 아닐 수도 있으며, 수동 출판은 여전히 가능하다.

00:12:31.000 --> 00:12:35.000
수동으로 게시하려면 모든 메타데이터에 대한 값을 제공해야 합니다.

00:12:35.000 --> 00:12:40.000
자동 게시와 달리, 경과 시간 및 재생 속도와 같은 정보는 시스템에 의해 결정될 수 없습니다.

00:12:40.000 --> 00:12:48.000
즉, 낮은 수준의 재생 상태에 대한 수동 미세 입자 제어가 있으며, 앱은 재생이 변경됨에 따라 시간이 지남에 따라 정확하게 유지할 책임이 있습니다.

00:12:48.000 --> 00:12:58.000
원격 명령에 등록하고 응답하는 것도 여전히 필요하며, MPNowPlayingSession을 사용하지 않기 때문에 MPRemoteCommandCenter의 공유 인스턴스를 사용해야 합니다.

00:12:58.000 --> 00:13:02.000
다음은 Now Playing Info 사전을 업데이트하는 방법을 보여주는 기본적인 예입니다.

00:13:02.000 --> 00:13:08.000
먼저, 우리는 자동 게시를 위해 했던 것과 유사한 이미지를 포함하는 MPMediaItemArtwork 인스턴스를 만듭니다.

00:13:08.000 --> 00:13:12.000
그런 다음, 우리는 사용 가능한 메타데이터가 포함된 사전을 만듭니다.

00:13:12.000 --> 00:13:19.000
이 경우, 우리는 제목, 삽화 및 플레이어 값 기간, 경과 시간 및 재생 속도를 설정합니다.

00:13:19.000 --> 00:13:23.000
그런 다음 MPNowPlayingInfoCenter 기본 인스턴스에서 설정합니다.

00:13:23.000 --> 00:13:32.000
이 메타데이터에 대한 업데이트는 재생 또는 일시 정지, 사용자가 앞뒤로 스크럽하거나, 새로운 콘텐츠가 재생되기 시작하는 것과 같은 중요한 변경 사항이 발생할 때마다 이루어져야 합니다.

00:13:32.000 --> 00:13:34.000
경과 시간을 주기적으로 업데이트할 필요가 없습니다.

00:13:34.000 --> 00:13:41.000
시스템은 항상 마지막 업데이트 이후 얼마나 많은 시간이 지났는지에 따라 정확한 경과 시간을 추론할 것이다.

00:13:41.000 --> 00:13:50.000
이제 지금 재생 중 메타데이터를 게시하고 다른 장치와 인터페이스의 원격 명령에 응답하는 모든 다양한 방법에 익숙해졌으므로 사용자 경험을 극대화하기 위해 통합해야 합니다.

00:13:50.000 --> 00:13:51.000
그 어느 때보다 쉬워.

00:13:51.000 --> 00:13:59.000
기존 통합도 도움이 될 수 있습니다. 자동 게시로 전환하는 것은 미래의 회귀를 방지하고 유지해야 하는 코드의 양을 최소화하는 쉬운 방법입니다.

00:13:59.000 --> 00:14:03.000
자세한 내용은 developer.apple.com의 MediaPlayer를 참조하십시오.

00:14:03.000 --> 23:59:59.000
봐줘서 고마워.

