WEBVTT

00:00:00.000 --> 00:00:03.000
♪ 부드러운 기악 힙합 음악 ♪

00:00:03.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:13.000
안녕하세요, 저는 Jared Marsau이고 Apple의 Game Technologies에서 일하고 있습니다.

00:00:13.000 --> 00:00:21.000
오늘, 엄선된 Apple 프레임워크를 사용하여 Unity 기반 게임에 새로운 기능을 추가하는 방법에 대해 이야기하겠습니다.

00:00:21.000 --> 00:00:27.000
우리는 여러분 중 많은 사람들이 게임을 만들기 위해 Unity와 같은 도구를 사용하고 있다는 것을 알고 있습니다.

00:00:27.000 --> 00:00:32.000
우리의 목표는 당신이 어떤 도구를 사용하든 최신 기능을 제공하는 것입니다.

00:00:32.000 --> 00:00:37.000
오늘부터, 새로운 유니티 플러그인 세트로 게임을 향상시키세요.

00:00:37.000 --> 00:00:43.000
Game Center 플러그인을 사용하여 플레이어 인증, 리더보드 및 매치메이킹과 같은 GameKit 기능을 추가하세요.

00:00:43.000 --> 00:00:51.000
MFi 및 타사 컨트롤러 지원과 함께 입력 사용자 지정 및 글리프를 위해 게임 컨트롤러 플러그인을 사용하세요.

00:00:51.000 --> 00:00:58.000
접근성 플러그인을 사용하여 VoiceOver 및 Dynamic Type과 같은 시스템 기능을 통해 접근성을 개선하십시오.

00:00:58.000 --> 00:01:04.000
Apple의 데이터 기반 풍부한 햅틱 피드백 시스템을 Core Haptics 플러그인과 통합하세요.

00:01:04.000 --> 00:01:09.000
PHASE 플러그인으로 고급 기하학 인식 공간 오디오를 추가하세요.

00:01:09.000 --> 00:01:16.000
마지막으로, Apple.Core 플러그인을 사용하여 빌드 설정을 관리하고 빌드 프로세스를 단순화하십시오.

00:01:16.000 --> 00:01:27.000
이 초기 플러그인 세트를 사용하면 새로운 게임플레이 메커니즘을 추가하고, 게임에 더 쉽게 접근할 수 있으며, 최신 기능과 서비스를 더 빠르게 활용할 수 있습니다.

00:01:27.000 --> 00:01:32.000
저는 당신이 이 새로운 유니티 플러그인 세트로 만드는 놀라운 게임을 보게 되어 매우 기쁩니다.

00:01:32.000 --> 00:01:35.000
이제, 나는 그 프로젝트의 세부 사항에 대해 알아볼 것이다.

00:01:35.000 --> 00:01:38.000
먼저, 나는 그 프로젝트의 설계 원칙에 대해 논의할 것이다.

00:01:38.000 --> 00:01:42.000
그런 다음, 나는 프로젝트 개념과 조직을 다룰 것이다.

00:01:42.000 --> 00:01:47.000
다음으로, 프로젝트 저장소와의 상호 작용에 대한 몇 가지 주요 포인터를 제공하겠습니다.

00:01:47.000 --> 00:01:50.000
그리고 마지막으로, 각 플러그인에 대해 자세히 설명하겠습니다.

00:01:50.000 --> 00:01:56.000
아시다시피, Apple 프레임워크는 모듈식 방식으로 기능을 캡슐화합니다.

00:01:56.000 --> 00:02:03.000
이를 통해 작고 효율적인 코드를 유지하면서 앱에 적합한 기술을 선택하고 선택할 수 있습니다.

00:02:03.000 --> 00:02:10.000
유니티 플러그인을 사용하면 비슷한 패턴을 따른다. 각 플러그인은 하나의 기본 프레임워크에 매핑된다.

00:02:10.000 --> 00:02:15.000
이를 통해 게임의 필요에 따라 사용하려는 플러그인 세트를 선택하고 선택할 수 있습니다.

00:02:15.000 --> 00:02:23.000
각 플러그인은 가능한 한 기본 프레임워크에 직접 매핑되는 C# 기반 Unity 스크립트를 노출합니다.

00:02:23.000 --> 00:02:29.000
이렇게 하는 것은 기본 프레임워크에 익숙할 수 있는 모든 것이 플러그인으로 이어진다는 것을 의미합니다.

00:02:29.000 --> 00:02:35.000
개념과 많은 경우 프레임워크 API는 직접 전달된다.

00:02:35.000 --> 00:02:42.000
반대로, 이것은 또한 플러그인을 학습함으로써, 당신은 암묵적으로 기본 프레임워크를 배울 수 있다는 것을 의미합니다.

00:02:42.000 --> 00:02:48.000
또 다른 중요한 세부 사항은 이 플러그인이 Apple 플랫폼 네이티브 라이브러리로 구축되었다는 것이다.

00:02:48.000 --> 00:02:55.000
이 라이브러리들은 C# 스크립트와 기본 프레임워크 API 사이의 접착제 역할을 한다.

00:02:55.000 --> 00:03:05.000
Apple Unity 플러그인은 Unity 패키지로 구성되어 있으므로 Unity Editor의 내장 패키지 관리자로 프로젝트 통합을 관리할 수 있습니다.

00:03:05.000 --> 00:03:18.000
경우에 따라 플러그인에는 플러그인 작업을 더 쉽게 하고 이미 익숙한 유니티 검사기 기반 워크플로우와 일치하는 추가 편집기 기능도 포함되어 있습니다.

00:03:18.000 --> 00:03:28.000
물론, 각 플러그인은 자세한 readmes, 샘플 및 관련 Apple Developer 문서와 같은 추가 리소스에 대한 링크와 페어링됩니다.

00:03:28.000 --> 00:03:35.000
다음으로, 당신이 시작하는 데 도움이 되는 몇 가지 주요 워크플로우 개념을 간략하게 검토하겠습니다.

00:03:35.000 --> 00:03:38.000
첫 번째 단계는 GitHub에서 소스를 복제하는 것이다.

00:03:38.000 --> 00:03:42.000
그곳에서 모든 프로젝트 소스와 문서를 찾을 수 있습니다.

00:03:42.000 --> 00:03:47.000
이것은 Apple Unity 플러그인을 사용할 모든 사람들을 위한 출발점이다.

00:03:47.000 --> 00:03:52.000
저장소를 복제하면, 플러그인을 구축하는 것이 첫 번째 작업 중 하나가 될 것입니다.

00:03:52.000 --> 00:03:59.000
이 과정을 단순화하기 위해, 저장소는 저장소 루트에 파이썬 스크립트를 포함합니다: build.py.

00:03:59.000 --> 00:04:10.000
이 스크립트는 네이티브 라이브러리를 구축하고, 올바른 위치에 복사하고, 유니티 메타 파일을 업데이트하고, 플러그인을 포장하고, 플러그인 테스트를 작성합니다.

00:04:10.000 --> 00:04:22.000
스크립트는 가장 간단한 호출이 모든 플러그인을 빌드하고, 타르볼로 패키징하고, 유니티 프로젝트에 통합할 준비가 된 빌드 폴더에 저장하도록 구성되어 있습니다.

00:04:22.000 --> 00:04:32.000
플러그인을 완전히 구축하고 포장하려면 Xcode, Python3, npm 및 Unity가 필요하다는 점에 유의하는 것이 중요합니다.

00:04:32.000 --> 00:04:38.000
마지막으로, 우리는 프로젝트 저장소에서 build.py를 사용하기 위한 자세한 문서를 가지고 있습니다.

00:04:38.000 --> 00:04:42.000
이제 각 플러그인에 대해 자세히 알아볼 시간입니다.

00:04:42.000 --> 00:04:57.000
각 플러그인에 대해 유니티 프로젝트에 추가하는 방법, 포함된 기능에 대한 간략한 개요, 주요 스크립팅 개념, 유니티 편집기의 일부 코드 스니펫 또는 예제를 살펴보겠습니다.

00:04:57.000 --> 00:05:01.000
기본 플러그인인 Apple.Core부터 시작합시다.

00:05:01.000 --> 00:05:09.000
Apple.Core는 각 플러그인의 빌드 설정을 Unity의 프로젝트 설정 창 내의 단일 기본 설정 창으로 통합합니다.

00:05:09.000 --> 00:05:21.000
각 플러그인의 기본 라이브러리를 컴파일하기 때문에, Apple.Core에는 각 플러그인 라이브러리가 가져오기 시 적절한 플랫폼에 맞게 구성되도록 하는 자산 프로세서도 포함되어 있습니다.

00:05:21.000 --> 00:05:32.000
프로젝트를 빌드할 때, Apple.Core에는 네이티브 라이브러리가 중간 Xcode 프로젝트에서 올바르게 참조되도록 빌드에 대한 사후 프로세스로 실행되는 스크립트도 포함되어 있습니다.

00:05:32.000 --> 00:05:44.000
각 플러그인은 기본 프레임워크와 상호 작용하기 때문에, Apple.Core는 또한 C# 스크립트와 네이티브 코드 레이어 간의 데이터 전달을 용이하게 하는 소수의 런타임 인터옵 유형을 정의합니다.

00:05:44.000 --> 00:05:49.000
마지막으로, Apple.Core는 다른 모든 Apple Unity 플러그인에 대한 종속성이다.

00:05:49.000 --> 00:05:55.000
이것은 다른 플러그인보다 먼저 Apple.Core를 프로젝트로 가져와야 한다는 것을 의미합니다.

00:05:55.000 --> 00:06:04.000
이 데모에서는 Apple.Core 플러그인을 새 프로젝트로 가져오는 방법을 보여주고 Apple 빌드 설정 환경 설정을 간략하게 살펴보겠습니다.

00:06:04.000 --> 00:06:11.000
플러그인이 빌드되고 포장되면, Unity Package Manager로 Apple.Core를 가져올 수 있습니다.

00:06:11.000 --> 00:06:23.000
타르볼에서 패키지를 추가하는 옵션을 선택하고 패키지된 플러그인으로 이동하기만 하면 됩니다.

00:06:23.000 --> 00:06:26.000
그런 다음 편집기는 패키지를 로드하고 스크립트를 컴파일할 것이다.

00:06:26.000 --> 00:06:34.000
완료되면, Apple.Core를 사용할 준비가 되었습니다.

00:06:34.000 --> 00:06:46.000
Apple.Core의 주요 사용자 대면 기능은 편집기의 프로젝트 설정 창에 Apple 빌드 설정 탭을 추가하는 것입니다.

00:06:46.000 --> 00:06:52.000
Apple Unity 플러그인을 가져오면, 사용 가능한 모든 빌드 옵션이 여기에서 볼 수 있습니다.

00:06:52.000 --> 00:07:00.000
Apple.Core는 최소 지원 OS 버전과 같은 몇 가지 기본 구성 옵션과 함께 제공됩니다.

00:07:00.000 --> 00:07:10.000
또한 모든 플러그인에 대한 사후 프로세스 빌드 단계를 비활성화할 수 있다는 점에 유의하는 것이 유용합니다.

00:07:10.000 --> 00:07:18.000
마지막으로, 중간 Xcode 프로젝트에 전파될 공통 보안 설정을 구성할 수 있습니다.

00:07:18.000 --> 00:07:26.000
Game Center 플러그인을 사용하여 Apple의 소셜 게임 네트워크인 Game Center로 게임에 더 많은 재미와 연결을 가져오세요.

00:07:26.000 --> 00:07:41.000
Game Center를 통해 플레이어는 Apple 플랫폼에서 신원을 구축하고 안전하고 안전한 플레이어 인증, 게임 내 업적, 공유 리더보드, 플레이어 간에 전송되는 도전 과제 및 멀티플레이어 매치메이킹과 같은 기능을 가능하게 합니다.

00:07:41.000 --> 00:07:49.000
게임에 통합할 게임 센터 기능을 선택하고 선택할 수 있지만, 모든 것은 플레이어 인증으로 시작됩니다.

00:07:49.000 --> 00:07:57.000
게임에 Game Center 플레이어 인증을 추가하면 Game Center 위젯은 플레이어의 홈 화면이나 App Store 내에서 게임을 선보일 수 있습니다.

00:07:57.000 --> 00:08:02.000
또한 플레이어 인증을 추가하는 데 코드가 거의 필요하지 않습니다.

00:08:02.000 --> 00:08:06.000
첫 번째 단계는 Apple.Core와 GameKit 플러그인을 프로젝트에 추가하는 것입니다.

00:08:06.000 --> 00:08:10.000
GameKit 플러그인은 Game Center 서비스를 연결합니다.

00:08:10.000 --> 00:08:16.000
인증할 때, Game Center 서비스와 연결하고 GKLocalPlayer 객체를 초기화하세요.

00:08:16.000 --> 00:08:22.000
초기화되면, 로컬 플레이어의 프로필을 기반으로 플레이어 제한을 쿼리하세요.

00:08:22.000 --> 00:08:34.000
이러한 제한에는 미성년자 플레이어의 성인 또는 노골적인 콘텐츠에 대한 액세스를 제한하거나, 멀티플레이어 기능에 대한 액세스를 제한하거나, 게임 내 통신을 비활성화하는 것이 포함됩니다.

00:08:34.000 --> 00:08:43.000
GKLocalPlayer를 관리하고 Game Center 서비스와 상호 작용하는 간단한 방법은 Unity 내에서 구성 요소를 정의하는 것입니다.

00:08:43.000 --> 00:08:47.000
예를 들어, 여기에 간단한 게임 관리자 구성 요소 정의가 있습니다.

00:08:47.000 --> 00:08:50.000
이 구성 요소는 GKLocalPlayer에 대한 참조를 보유하고 있다.

00:08:50.000 --> 00:09:01.000
또한 시작 방법에서 플레이어 제한에 대한 인증과 쿼리를 모두 처리합니다. 플레이어 인증은 게임 수명 동안 한 번만 발생하면 됩니다.

00:09:01.000 --> 00:09:04.000
이것은 GameManager 구성 요소의 스크립트입니다.

00:09:04.000 --> 00:09:07.000
여기 GKLocalPlayer를 캐싱하기 위한 필드가 있습니다.

00:09:07.000 --> 00:09:17.000
구성 요소의 시작 메서드 내에는 GKLocalPlayer 인스턴스를 반환하는 정적 메서드인 GKLocalPlayer.Authenticate에 대한 일회성 호출이 있습니다.

00:09:17.000 --> 00:09:22.000
로컬 플레이어가 성공적으로 인증되면, 플레이어 제한을 확인할 때입니다.

00:09:22.000 --> 00:09:31.000
코드에서 플레이어 제한을 확인하는 것은 일련의 부울 검사로 해결되며 GameManager 구성 요소의 스크립트에서 try 블록에 추가할 수 있습니다.

00:09:31.000 --> 00:09:36.000
여기서는 로컬 플레이어가 노골적인 콘텐츠에 대한 접근이 제한되어야 한다는 것을 의미합니다.

00:09:36.000 --> 00:09:40.000
여기서 진실은 당신의 지역 플레이어가 제한된 멀티플레이어 경험을 가져야 한다는 것을 의미합니다.

00:09:40.000 --> 00:09:46.000
그리고 마지막으로, 여기서 진실은 게임 내 통신이 비활성화되어야 한다는 것을 의미한다.

00:09:46.000 --> 00:09:51.000
그리고 그것이 당신의 게임에 플레이어 인증을 추가하는 데 필요한 모든 코드 변경입니다.

00:09:51.000 --> 00:09:58.000
여기에서, 게임 센터를 활용하기 위해 게임을 완전히 준비하는 데 필요한 두 가지 추가 단계가 있습니다.

00:09:58.000 --> 00:10:04.000
먼저, 중간 Xcode 프로젝트에 Game Center 기능을 추가해야 합니다.

00:10:04.000 --> 00:10:07.000
이것은 Xcode 프로젝트 UI 내에서 이루어집니다.

00:10:07.000 --> 00:10:14.000
더 많은 정보는 Apple Developer 문서 "Enabling and Configuring Game Center"에서 찾을 수 있습니다.

00:10:14.000 --> 00:10:20.000
다음으로, App Store Connect를 사용하여 앱에 Game Center 기능을 추가해야 합니다.

00:10:20.000 --> 00:10:23.000
자세한 내용은 App Store Connect 포털을 확인하세요.

00:10:23.000 --> 00:10:30.000
이 단계가 완료되면, 플레이어를 인증하고 안전한 게임 환경을 보장할 준비가 되었습니다.

00:10:30.000 --> 00:10:37.000
플레이어 인증은 Game Center Unity 플러그인에서 사용할 수 있는 기능의 표면만 긁습니다.

00:10:37.000 --> 00:10:45.000
게임의 발견 가능성 향상에 대해 자세히 알아보려면, "게임 센터 대시보드로 새로운 플레이어에게 다가가세요" 세션을 확인하세요.

00:10:45.000 --> 00:10:52.000
멀티플레이어와 매치메이킹에 대해 자세히 알아보려면, 작년의 "게임 센터의 새로운 기능" 세션을 보세요.

00:10:52.000 --> 00:10:58.000
컨트롤러는 플레이어가 당신이 만들 세계와 상호 작용할 수 있는 주요 방법입니다.

00:10:58.000 --> 00:11:04.000
게임 컨트롤러 플러그인으로 게임에 안정적이고 유연한 게임 컨트롤러 지원을 쉽게 제공합니다.

00:11:04.000 --> 00:11:15.000
게임 컨트롤러 플러그인은 플레이어가 모든 게임에 대해 한 곳에서 버튼을 다시 매핑할 수 있는 게임 컨트롤러 사용자 지정 지원과 같은 몇 가지 기능을 제공합니다.

00:11:15.000 --> 00:11:19.000
일관된 사용자 경험을 보장하기 위한 버튼 글리프.

00:11:19.000 --> 00:11:27.000
그리고 모든 MFi 컨트롤러와 엄선된 소니 및 마이크로소프트 컨트롤러와 같은 타사 컨트롤러를 지원합니다.

00:11:27.000 --> 00:11:34.000
다른 플러그인과 마찬가지로, 패키지 관리자를 사용하여 Apple.Core 및 Game Controller 플러그인을 프로젝트에 추가하십시오.

00:11:34.000 --> 00:11:40.000
게임 컨트롤러 플러그인이 로드되면, 첫 번째 단계는 GCControllerService를 초기화하는 것입니다.

00:11:40.000 --> 00:11:46.000
곧 볼 수 있듯이, 이 서비스는 컨트롤러와 연결 이벤트에 액세스하는 방법입니다.

00:11:46.000 --> 00:11:52.000
초기화되면, 현재 시스템에 연결된 모든 컨트롤러에 대해 GCControllerService를 쿼리하십시오.

00:11:52.000 --> 00:11:58.000
연결된 컨트롤러는 게임 컨트롤러 플러그인의 GCController 객체로 표시됩니다.

00:11:58.000 --> 00:12:03.000
연결된 각 GCController에 대해 업데이트된 컨트롤러 상태를 폴링합니다.

00:12:03.000 --> 00:12:11.000
투표는 게임에 필요한 만큼 적게 또는 자주 일어날 수 있지만, 시작하기에 좋은 곳은 유니티의 정기적인 업데이트 루프입니다.

00:12:11.000 --> 00:12:20.000
컨트롤러 상태가 업데이트되면, 버튼, 엄지 스틱 등과 같은 각 컨트롤러의 개별 요소에 대한 입력을 테스트하십시오.

00:12:20.000 --> 00:12:30.000
잊지 말아야 할 것은, 컨트롤러는 게임의 수명 주기 동안 왔다가 갈 수 있습니다 - 컨트롤러 연결 및 연결 해제 이벤트를 처리하기 위해 콜백을 등록하십시오.

00:12:30.000 --> 00:12:36.000
게임 컨트롤러 플러그인을 통합하는 빠른 방법은 간단한 입력 관리자 구성 요소를 만드는 것입니다.

00:12:36.000 --> 00:12:50.000
이 구성 요소에는 세 가지 핵심 요소가 있습니다: 현재 연결된 모든 컨트롤러를 수용하는 컨테이너, 초기화를 위한 시작 방법, 입력에 대한 폴링 및 테스트를 처리하기 위한 업데이트 방법.

00:12:50.000 --> 00:12:53.000
먼저, 시작 방법을 자세히 살펴봅시다.

00:12:53.000 --> 00:12:58.000
이곳은 필요한 모든 일회성 설정 작업을 할 수 있는 좋은 장소입니다.

00:12:58.000 --> 00:13:11.000
게임 컨트롤러 서비스의 초기화는 연결된 컨트롤러에 대한 초기 확인과 연결 및 연결 해제 이벤트에 대한 콜백 등록과 함께 여기에서 이루어져야 합니다.

00:13:11.000 --> 00:13:14.000
다음은 입력 관리자 구성 요소의 스크립트입니다.

00:13:14.000 --> 00:13:23.000
모든 일회성 설정 코드는 GCControllerService에 대한 호출을 포함하여 구성 요소의 시작 방법에 들어갑니다. 초기화().

00:13:23.000 --> 00:13:30.000
GetConnectedControllers를 호출하면 현재 연결된 모든 컨트롤러의 열거 가능한 컨테이너를 가져옵니다.

00:13:30.000 --> 00:13:37.000
최종 초기화 단계는 컨트롤러 연결 및 연결 해제 이벤트에 대한 콜백을 등록하는 것입니다.

00:13:37.000 --> 00:13:50.000
이제 초기화가 완료되었습니다. 입력 관리자는 연결된 각 컨트롤러를 폴링하여 입력 상태를 업데이트하고 각 컨트롤러의 입력에 대한 입력 상태를 처리하기 위해 업데이트 방법이 필요합니다.

00:13:50.000 --> 00:13:55.000
입력을 위해 폴링하려면, 연결된 컨트롤러 세트를 반복하여 시작하세요.

00:13:55.000 --> 00:13:59.000
GCController의 Poll 메소드를 호출하여 최신 상태를 수집하세요.

00:13:59.000 --> 00:14:05.000
그런 다음 각 버튼 상태를 확인하고 그에 따라 응답하세요.

00:14:05.000 --> 00:14:12.000
그리고 그것은 게임 컨트롤러 플러그인을 사용하여 연결된 컨트롤러에 액세스하고 컨트롤러 입력을 얻는 방법을 빠르게 살펴봅니다.

00:14:12.000 --> 00:14:27.000
게임 컨트롤러 프레임워크에 대해 더 자세히 알아보고 타사 컨트롤러 및 비표준 입력과 같은 주제에 대해 알아보려면, 이전 연도의 세션인 "새로운 게임 컨트롤러 지원"과 "게임 컨트롤러의 발전"을 확인하세요.

00:14:27.000 --> 00:14:32.000
접근성은 모든 사람이 기술을 이용할 수 있도록 하는 것이다.

00:14:32.000 --> 00:14:41.000
접근성 플러그인을 사용하여 다양한 Apple의 보조 기술을 Unity 기반 게임에 통합하세요.

00:14:41.000 --> 00:15:07.000
접근성 플러그인은 프로그래밍 방식으로 태그된 콘텐츠를 사용자에게 읽을 수 있는 VoiceOver와 같은 주요 기능을 추가할 수 있는 기능을 제공합니다; 다양한 보조 입력 장치를 허용하는 스위치 제어; 사용자 선호도에 따라 게임 내 텍스트와 UI를 쉽게 확장할 수 있는 동적 유형; 시스템 차원의 접근성 선호도를 준수하기 위한 UI 숙박 설정.

00:15:07.000 --> 00:15:18.000
접근성 플러그인으로 다룰 것이 많기 때문에, 접근성 유니티 플러그인에 대해 자세히 알아보려면 "유니티 게임에 접근성 추가" 세션을 확인하는 것이 좋습니다.

00:15:18.000 --> 00:15:28.000
그 세션에서 당신은 예시와 사용 사례를 얻을 뿐만 아니라, Apple 플랫폼에서 접근성으로 무엇이 가능한지에 대한 이해를 쌓을 것입니다.

00:15:28.000 --> 00:15:32.000
기회가 되는 대로 꼭 확인해 보세요.

00:15:32.000 --> 00:15:38.000
게임에 햅틱 피드백을 추가하는 것은 몰입도를 높이고 게임플레이 경험을 향상시키는 좋은 방법입니다.

00:15:38.000 --> 00:15:43.000
Apple의 고급 햅틱 기능을 Core Haptics 플러그인과 통합하세요.

00:15:43.000 --> 00:15:49.000
Core Haptics 플러그인을 사용하여 일련의 햅틱 및 오디오 이벤트에서 사용자 지정 햅틱 패턴을 구축하십시오.

00:15:49.000 --> 00:15:52.000
동기화된 사용자 지정 오디오와 햅틱을 재생하세요.

00:15:52.000 --> 00:15:58.000
실시간으로 매개 변수를 조정하여 햅틱 피드백을 프로그래밍 방식으로 정의하거나 업데이트하세요.

00:15:58.000 --> 00:16:07.000
패턴을 자산으로 설계하고 저장하는 파일 기반 접근 방식을 위해 Apple Haptic and Audio Pattern 파일 형식 또는 AHAP를 사용하세요.

00:16:07.000 --> 00:16:12.000
검사관 지원과 함께 유니티 편집기에서 핵심 햅틱 패턴을 조정하세요.

00:16:12.000 --> 00:16:20.000
Core Haptics 플러그인을 최대한 활용하려면, Core Haptics의 네 가지 기본 요소와 서로의 관계를 이해해야 합니다.

00:16:20.000 --> 00:16:24.000
최고 수준의 요소는 CHHapticEngine이다.

00:16:24.000 --> 00:16:31.000
햅틱 엔진은 장치의 햅틱 서버에 대한 링크를 나타내며 햅틱 패턴을 재생하는 데 필요합니다.

00:16:31.000 --> 00:16:35.000
CHHapticEngine은 CHHapticPatternPlayers를 만든다.

00:16:35.000 --> 00:16:44.000
패턴 플레이어는 시작, 중지, 일시 정지 및 재개와 같은 컨트롤이 있는 CHHapticPatterns를 재생하는 데 사용됩니다.

00:16:44.000 --> 00:16:50.000
CHHapticPattern은 하나 이상의 햅틱 및 오디오 이벤트의 논리적 그룹화이다.

00:16:50.000 --> 00:16:54.000
CHHapticEngine은 패턴을 사용하여 플레이어를 만든다.

00:16:54.000 --> 00:17:00.000
CHHapticEvents는 햅틱 경험을 정의하는 데 사용되는 빌딩 블록이다.

00:17:00.000 --> 00:17:11.000
Core Haptics는 햅틱 패턴을 프로그래밍 방식으로, 스크립트에서 직접 또는 AHAP 파일을 활용하여 정의할 수 있는 데이터 기반 API입니다.

00:17:11.000 --> 00:17:20.000
프로젝트에 Core Haptics 지원을 추가하는 쉬운 방법 중 하나는 필요한 각 Core Haptics 객체를 관리하는 Haptics 구성 요소를 만드는 것입니다.

00:17:20.000 --> 00:17:29.000
다음은 CHHapticEngine, CHHapticPatternPlayer 및 AHAP 자산이 포함된 햅틱 구성 요소의 예입니다.

00:17:29.000 --> 00:17:34.000
AHAP 자산은 Core Haptics 플러그인에 의해 정의된 사용자 지정 Unity 자산입니다.

00:17:34.000 --> 00:17:43.000
이를 통해 AHAP 파일로 쉽게 가져오고 내보낼 수 있을 뿐만 아니라 패턴 생성 및 사용자 지정을 관리할 수 있는 사용자 지정 편집기 확장을 사용할 수 있습니다.

00:17:43.000 --> 00:17:46.000
좀 더 자세히 살펴보자.

00:17:46.000 --> 00:17:52.000
제 프로젝트에 Apple.Core와 Core Haptics 플러그인이 모두 설치되어 있는지 확인하는 것으로 시작하겠습니다.

00:17:52.000 --> 00:17:59.000
그것들을 추가하면, 나는 햅틱으로 내 게임을 향상시키기 시작할 수 있다.

00:17:59.000 --> 00:18:03.000
여기 제가 이전 다이어그램을 기반으로 만든 햅틱 구성 요소가 있습니다.

00:18:03.000 --> 00:18:12.000
우리는 잠시 후에 구현을 확인할 것이지만, 지금은 그것을 내 비행기에 첨부할 것이다.

00:18:12.000 --> 00:18:20.000
일단 첨부되면, 나는 이제 구성 요소에 AHAP 자산이 필요하다는 것을 알지만, 내 AHAP 자산 폴더는 비어 있다.

00:18:20.000 --> 00:18:29.000
자산 &gt; 만들기 &gt; Apple &gt; CoreHaptics &gt; AHAP로 이동하여 새로운 것을 만들 것입니다.

00:18:29.000 --> 00:18:39.000
일단 만들어지면, 나는 환상적이고 독창적인 이름을 줄 것이다: MyHapticPattern.

00:18:39.000 --> 00:18:46.000
Core Haptics 플러그인은 관리자 창에서 바로 새 패턴을 조정할 수 있는 편집기 확장과 함께 제공됩니다.

00:18:46.000 --> 00:18:53.000
이것은 내가 연주할 수 있는 CHHapticPattern의 일부인 CHHapticEvents를 정의하는 곳이다.

00:18:53.000 --> 00:19:01.000
기본적으로 일시적인 이벤트가 있지만, 지속적인 이벤트도 쉽게 추가할 수 있습니다.

00:19:01.000 --> 00:19:06.000
UI에는 가져오기, 내보내기 및 재설정 버튼도 있습니다.

00:19:06.000 --> 00:19:13.000
재설정은 내가 추가한 모든 이벤트를 지우고 패턴을 기본 상태로 되돌린다.

00:19:13.000 --> 00:19:16.000
가져오기와 내보내기는 훌륭한 기능이다.

00:19:16.000 --> 00:19:23.000
이를 통해 프로젝트가 AHAP 파일을 로드하고 저장할 수 있습니다.

00:19:23.000 --> 00:19:34.000
여기서 나는 좋은 진동 효과를 유발하는 럼블이라는 미리 정의된 AHAP를 가져왔지만, 조금 조정해야 한다고 생각한다.

00:19:34.000 --> 00:19:51.000
이제 패턴을 업데이트했으므로, 이 개선된 햅틱 패턴을 나머지 팀과 공유하기 위해 새로운 AHAP 파일로 내보낼 수 있습니다.

00:19:51.000 --> 00:19:59.000
이제 내 자산이 생성되고 조정되면, 나는 비행기로 돌아가서 MyHapticPattern을 가리킬 것이다.

00:19:59.000 --> 00:20:03.000
좋아! 모든 것이 연결되어 있다.

00:20:03.000 --> 00:20:11.000
햅틱 패턴이 정의되고 적절하게 참조되면, 남은 것은 햅틱 패턴을 재생할 수 있도록 햅틱 구성 요소에 논리를 추가하는 것입니다.

00:20:11.000 --> 00:20:17.000
이것은 두 가지 방법으로 나눌 수 있다: PrepareHaptics와 Play.

00:20:17.000 --> 00:20:24.000
PrepareHaptics는 햅틱 엔진이 초기화되고 햅틱 패턴 플레이어가 만들어지는 곳이다.

00:20:24.000 --> 00:20:30.000
재생은 단순히 CHHapticPatternPlayer의 시작 방법을 호출하여 재생을 시작합니다.

00:20:30.000 --> 00:20:34.000
그리고 여기 햅틱스 구성 요소 스크립트가 있습니다.

00:20:34.000 --> 00:20:39.000
필드는 햅틱 엔진과 햅틱 플레이어를 위해 정의된다.

00:20:39.000 --> 00:20:46.000
중요한 것은, 편집기 UI에서 AHAP 자산을 설정할 수 있도록 serializeField 속성을 추가하는 것입니다.

00:20:46.000 --> 00:20:56.000
다음으로, 코드를 추가하여 CHHapticEngine을 만들고, 시작하고, 참조된 자산에서 직접 AHAP에 액세스하여 햅틱 패턴 플레이어를 만드세요.

00:20:56.000 --> 00:21:02.000
물론, 플레이어에게 Start를 호출하면 햅틱 패턴이 재생될 것이다.

00:21:02.000 --> 00:21:08.000
Core Haptics Unity 플러그인은 게임에 완전히 새로운 수준의 몰입도를 추가하는 데 필요한 도구를 제공합니다.

00:21:08.000 --> 00:21:15.000
Core Haptics 플러그인을 사용하여 실제처럼 보이고, 들리고, 느껴지는 마법의 게임 순간을 만드세요.

00:21:15.000 --> 00:21:21.000
코어 햅틱에 대해 자세히 알아보시피, "코어 햅틱 소개" 세션을 확인하세요.

00:21:21.000 --> 00:21:32.000
매력적인 햅틱 경험 디자인에 대한 자세한 내용은 "오디오 햅틱 경험 디자인"과 "오디오 햅틱 디자인 연습"을 시청하세요.

00:21:32.000 --> 00:21:37.000
몰입형 오디오는 훌륭한 게임 경험의 매우 중요한 측면이다.

00:21:37.000 --> 00:21:45.000
PHASE Unity 플러그인을 사용하여 창의적인 잠재력을 발휘하고 게임 세계에 무성한 사운드스케이프를 구축하세요.

00:21:45.000 --> 00:21:51.000
PHASE를 사용하면 게임에 복잡하고 역동적인 오디오 경험을 제공할 수 있습니다.

00:21:51.000 --> 00:21:57.000
기하학 인식 오디오는 소리가 장면의 메쉬에서 방출되고 상호 작용한다는 것을 의미합니다.

00:21:57.000 --> 00:22:02.000
게임의 환경은 잔향과 반사를 통해 더 현실적으로 들릴 것입니다.

00:22:02.000 --> 00:22:14.000
게임 플레이 중에 동적 오디오 제어를 허용하는 계층적 오디오 그래프를 만들 수 있습니다. PHASE 플러그인에는 게임 준비가 된 미리 정의된 구성 요소 세트가 포함되어 있습니다.

00:22:14.000 --> 00:22:21.000
게임 개체에 부착하기만 하면 한 줄의 코드를 작성하지 않고도 PHASE를 사용할 수 있습니다.

00:22:21.000 --> 00:22:24.000
첫 번째 구성 요소는 PHASEListener 구성 요소이다.

00:22:24.000 --> 00:22:33.000
그것은 게임 장면의 "귀" 역할을 하며 위치, 방향 및 잔향 프리셋에 따라 오디오를 처리합니다.

00:22:33.000 --> 00:22:36.000
다음은 PHASEOccluder 구성 요소입니다.

00:22:36.000 --> 00:22:46.000
PHASEOccluders는 기하학 데이터로 게임 객체에 부착하고 소스와 장면의 청취자 사이에 올 때 오디오를 감쇠합니다.

00:22:46.000 --> 00:22:48.000
다음은 PHASESource 구성 요소입니다.

00:22:48.000 --> 00:22:55.000
이것들은 게임 물체에 부착되어 있으며 물체의 변환을 사용하여 게임 세계에서 소리를 배치합니다.

00:22:55.000 --> 00:23:02.000
내장 구성 요소 외에도, PHASE 플러그인은 사용자 지정 자산인 SoundEvent 자산을 정의합니다.

00:23:02.000 --> 00:23:09.000
사운드 이벤트는 오디오 재생 이벤트를 설명하고 장면의 소스에서 재생되는 오디오를 정의하는 객체입니다.

00:23:09.000 --> 00:23:17.000
PHASE 플러그인을 사용하기 시작하려면, 첫 번째 단계는 Apple.Core와 PHASE 플러그인이 모두 프로젝트에 추가되었는지 확인하는 것입니다.

00:23:17.000 --> 00:23:22.000
일단 설치되면, 포함된 구성 요소를 장면에 추가할 수 있습니다.

00:23:22.000 --> 00:23:31.000
이 예시 프로젝트에서, 나는 세 가지 관심 있는 게임 객체를 가지고 있다: 비행기, 건물, 그리고 카메라.

00:23:31.000 --> 00:23:36.000
먼저, PHASEListener 구성 요소를 카메라에 부착하겠습니다.

00:23:36.000 --> 00:23:40.000
그렇게함으로써, 나는 그 장면에 "귀"를 추가했다.

00:23:40.000 --> 00:23:48.000
다음으로, 나는 PHASEOccluder 구성 요소를 부착하여 건물을 occluder로 만들 것이다.

00:23:48.000 --> 00:23:55.000
마지막으로, 비행기에 PHASESource 구성 요소를 추가하여 장면에 소스를 추가할 것입니다.

00:23:55.000 --> 00:24:04.000
이제 소스를 추가했으니 재생하려면 오디오가 필요하므로 사운드 이벤트를 첨부해야 하지만, 사운드 이벤트 폴더는 비어 있습니다.

00:24:04.000 --> 00:24:14.000
Assets &gt; Create &gt; Apple &gt; PHASE &gt; SoundEvent로 이동하여 하나를 만들 수 있습니다.

00:24:14.000 --> 00:24:20.000
사운드 이벤트를 만든 후, PHASE 플러그인은 즉시 PHASE 사운드 이벤트 작곡가 창을 엽니다.

00:24:20.000 --> 00:24:24.000
이것은 사운드 이벤트를 만드는 데 사용되는 캔버스이다.

00:24:24.000 --> 00:24:27.000
나는 창의 아무 곳이나 마우스 오른쪽 버튼으로 클릭하는 것으로 시작한다.

00:24:27.000 --> 00:24:31.000
이것은 내가 이벤트에 노드를 추가할 수 있는 팝업을 보여준다.

00:24:31.000 --> 00:24:36.000
클립을 재생하고 싶기 때문에 샘플러 노드를 만들 것이다.

00:24:36.000 --> 00:24:45.000
나는 이미 공회전 비행기의 오디오 클립을 프로젝트에 추가했기 때문에, 여기에서 참조할 수 있다.

00:24:45.000 --> 00:24:50.000
나는 비행기가 계속 윙윙거릴 수 있도록 계속 반복할 것이다.

00:24:50.000 --> 00:24:53.000
비행기를 들으려면, 나는 그것을 믹서로 라우팅해야 한다.

00:24:53.000 --> 00:25:05.000
출력 라인을 이벤트 작곡가의 캔버스로 드래그하여 믹서를 만들 수 있으며, 믹서를 만드는 옵션을 보여줍니다.

00:25:05.000 --> 00:25:10.000
내 사운드 이벤트는 이제 완료되었고 사용할 준비가 되었다.

00:25:10.000 --> 00:25:16.000
사운드 이벤트를 클릭하면, 인스펙터에서 직접 설정을 볼 수 있습니다.

00:25:16.000 --> 00:25:22.000
이것은 내가 사운드 이벤트 작곡가로 돌아갈 필요 없이 값을 조정할 수 있게 해준다.

00:25:22.000 --> 00:25:30.000
사운드 이벤트가 생성됨에 따라, 이제 이전에 비행기에 부착한 PHASESource 구성 요소에서 참조할 수 있습니다.

00:25:30.000 --> 00:25:35.000
그리고 그것으로, 장면의 오디오는 재생을 위해 라우팅되고 구성된다.

00:25:35.000 --> 00:25:41.000
PHASE Unity 플러그인은 게임 내 오디오 디자인에 대한 완전히 새로운 가능성을 열어줍니다.

00:25:41.000 --> 00:25:54.000
PHASE에 대해 자세히 알아보고 오늘 소개한 개념에 대해 자세히 알아보려면, Apple Developer 문서 사이트와 작년의 입문 WWDC 세션 비디오를 확인하십시오.

00:25:54.000 --> 00:25:59.000
그리고 그것은 새로운 Apple Unity 플러그인에 대한 우리의 개요를 마칩니다.

00:25:59.000 --> 00:26:09.000
나는 오늘 많은 것을 다루었지만, Apple Unity 플러그인에 대해 더 알고 싶다면, GitHub의 저장소가 시작하기에 가장 좋은 장소입니다.

00:26:09.000 --> 00:26:17.000
그곳에서 각 플러그인에 대한 소스, 자세한 문서 및 샘플을 찾을 수 있습니다.

00:26:17.000 --> 00:26:32.000
"유니티 게임에 접근성 추가" 세션을 통해 유니티 게임에 접근성을 통합하는 방법에 대해 자세히 알아보고 "게임 센터 대시보드로 새로운 플레이어에게 다가가기"를 확인하여 게임의 가시성을 높이는 방법을 알아보세요.

00:26:32.000 --> 00:26:34.000
봐줘서 고마워.

00:26:34.000 --> 23:59:59.000
♪

