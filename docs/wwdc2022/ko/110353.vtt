WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:12.000
안녕하세요, 저는 스위프트 컴파일러 팀의 Slava입니다.

00:00:12.000 --> 00:00:17.000
스위프트의 프로토콜 인터페이스 디자인에 오신 것을 환영합니다.

00:00:17.000 --> 00:00:30.000
저는 Embrace Swift Generics의 이야기가 중단된 곳에서부터, 구체적인 유형을 추상화하고 프로토콜을 사용하여 유형 관계를 모델링하기 위한 몇 가지 고급 기술을 보여줄 것입니다.

00:00:30.000 --> 00:00:40.000
이 강연은 기존 언어 기능과 Swift 5.7에 도입된 새로운 기능 중 일부를 다룰 것이다.

00:00:40.000 --> 00:00:53.000
이 강연에는 세 가지 주요 주제가 있습니다. 첫째, '결과 유형 삭제'가 어떻게 작동하는지 설명함으로써 관련 유형의 프로토콜이 실존적 '모든' 유형과 어떻게 상호 작용하는지 보여드리겠습니다.

00:00:53.000 --> 00:01:03.000
다음으로, 인터페이스와 구현을 분리하여 캡슐화를 개선하기 위해 불투명한 결과 유형을 사용하는 것을 설명하겠습니다.

00:01:03.000 --> 00:01:14.000
마지막 주제의 경우, 프로토콜의 동일한 유형의 요구 사항이 여러 가지 다른 유형의 구체적인 유형 간의 관계를 어떻게 모델링할 수 있는지 알게 될 것입니다.

00:01:14.000 --> 00:01:22.000
관련 유형의 프로토콜이 실존적 유형과 어떻게 상호 작용하는지 배우는 것으로 시작합시다.

00:01:22.000 --> 00:01:28.000
여기에 한 쌍의 프로토콜과 네 가지 구체적인 유형이 있는 데이터 모델이 있습니다.

00:01:28.000 --> 00:01:35.000
두 종류의 동물, 닭과 소, 그리고 두 종류의 음식, 계란과 우유가 있다.

00:01:35.000 --> 00:01:39.000
닭은 달걀을 생산하고, 소는 우유를 생산한다.

00:01:39.000 --> 00:01:46.000
음식 생산을 추상화하기 위해, 나는 동물 프로토콜에 produce() 방법을 추가할 것이다.

00:01:46.000 --> 00:01:58.000
당신은 'Embrace swift generics' 이야기에서 Cow and Chicken에서 생산()의 다른 반환 유형을 추상화하는 가장 좋은 방법은 관련 유형을 사용하는 것임을 기억할 것입니다.

00:01:58.000 --> 00:02:12.000
관련 유형을 사용함으로써, 우리는 다음과 같이 선언합니다: 특정 유형의 동물이 주어지면, produce()를 호출하면 구체적인 동물 유형에 따라 특정 유형의 음식을 반환합니다.

00:02:12.000 --> 00:02:15.000
우리는 다이어그램으로 이 관계를 보여줄 수 있다.

00:02:15.000 --> 00:02:22.000
프로토콜 '셀프' 유형은 '동물' 프로토콜을 준수하는 실제 콘크리트 유형을 의미합니다.

00:02:22.000 --> 00:02:28.000
'자기' 유형에는 '음식'에 부합하는 관련 '상품' 유형이 있다.

00:02:28.000 --> 00:02:37.000
구체적인 닭과 소 유형 간의 관계와 동물 프로토콜의 관련 유형 다이어그램을 살펴봅시다.

00:02:37.000 --> 00:02:42.000
치킨 유형은 '달걀'의 CommodityType을 가진 동물 프로토콜을 준수한다.

00:02:42.000 --> 00:02:48.000
그리고 소 유형은 '우유'의 CommodityType을 가진 동물 프로토콜을 준수합니다.

00:02:48.000 --> 00:02:51.000
이제, 우리가 동물들로 가득 찬 농장을 가지고 있다고 가정해 봅시다.

00:02:51.000 --> 00:02:58.000
농장에 저장된 '동물' 재산은 '모든 동물'의 이질적인 배열이다.

00:02:58.000 --> 00:03:09.000
스위프트 제네릭을 포용하면서, 우리는 '모든 동물' 유형이 어떻게 구체적인 유형의 동물을 동적으로 저장할 수 있는 상자 표현을 가지고 있는지 보았다.

00:03:09.000 --> 00:03:17.000
다른 구체적인 유형에 대해 동일한 표현을 사용하는 이 전략은 유형 삭제라고 불린다.

00:03:17.000 --> 00:03:24.000
produceCommodities() 메서드는 동물 배열을 매핑하여 각 동물에 대한 produce() 메서드를 호출합니다.

00:03:24.000 --> 00:03:37.000
이 방법은 간단해 보이지만, 우리는 유형 삭제가 기본 유형의 동물에 대한 정적 유형 관계를 제거할 것이라는 것을 알고 있으므로, 이 코드 유형이 왜 검사하는지 이해하기 위해 더 깊이 파고들 가치가 있다.

00:03:37.000 --> 00:03:43.000
Map() 클로저의 '동물' 매개 변수는 '모든 동물' 유형을 가지고 있다.

00:03:43.000 --> 00:03:47.000
'Produce()'의 반환 유형은 연관된 유형이다.

00:03:47.000 --> 00:03:58.000
실존적 유형에서 관련 유형을 반환하는 메서드를 호출할 때, 컴파일러는 형식 삭제를 사용하여 호출의 결과 유형을 결정합니다.

00:03:58.000 --> 00:04:05.000
유형 삭제는 이러한 관련 유형을 동등한 제약이 있는 해당 실존적 유형으로 대체합니다.

00:04:05.000 --> 00:04:16.000
우리는 콘크리트 동물 유형과 관련 CommodityType 사이의 관계를 '모든 동물'과 '모든 음식'으로 대체하여 지웠습니다.

00:04:16.000 --> 00:04:22.000
'모든 음식' 유형은 관련 CommodityType의 상한선이라고 불린다.

00:04:22.000 --> 00:04:31.000
Produce() 메서드가 'any Animal'에서 호출되기 때문에, 반환 값은 유형이 지워져 'any Food' 유형의 값을 제공합니다.

00:04:31.000 --> 00:04:34.000
이것이 바로 우리가 여기서 기대하는 유형이다.

00:04:34.000 --> 00:04:41.000
Swift 5.7의 새로운 기능인 관련 유형 삭제가 어떻게 작동하는지 자세히 살펴봅시다.

00:04:41.000 --> 00:04:56.000
화살표의 오른쪽에 있는 프로토콜 메서드의 결과 유형에 나타나는 관련 유형은 메서드를 호출하면 이 유형의 값을 생성하기 때문에 '생산 위치'에 있다고 합니다.

00:04:56.000 --> 00:05:06.000
우리가 이 방법을 '모든 동물'이라고 부를 때, 우리는 컴파일 시간에 구체적인 결과 유형을 알지 못하지만, 그것이 상한의 하위 유형이라는 것을 알고 있다.

00:05:06.000 --> 00:05:13.000
이 예에서, 우리는 런타임에 소를 보유하고 있는 '모든 동물'에서 produce()를 호출하고 있습니다.

00:05:13.000 --> 00:05:17.000
우리의 경우, 소에 대한 produce() 방법은 우유를 반환한다.

00:05:17.000 --> 00:05:27.000
우유는 동물 프로토콜의 관련 CommodityType의 상한선인 '모든 식품' 안에 저장될 수 있다.

00:05:27.000 --> 00:05:34.000
이것은 동물 프로토콜을 준수하는 모든 콘크리트 유형에 대해 항상 안전합니다.

00:05:34.000 --> 00:05:42.000
반면에, 관련 유형이 메서드 또는 이니셜라이저의 매개 변수 목록에 나타나면 어떻게 되는지 생각해 봅시다.

00:05:42.000 --> 00:05:49.000
여기서, 동물 프로토콜의 eat() 방법은 소비 위치에 관련된 FeedType을 가지고 있다.

00:05:49.000 --> 00:05:53.000
우리는 그 메소드를 호출하기 위해 이 유형의 값을 전달해야 한다.

00:05:53.000 --> 00:05:59.000
변환이 다른 방향으로 진행되기 때문에, 유형 삭제를 수행할 수 없습니다.

00:05:59.000 --> 00:06:10.000
관련 유형의 상한 실존 유형은 콘크리트 유형을 알 수 없기 때문에 실제 콘크리트 유형으로 안전하게 변환되지 않습니다.

00:06:10.000 --> 00:06:11.000
예를 들어 봅시다.

00:06:11.000 --> 00:06:15.000
다시 한번, 우리는 소를 저장하는 '모든 동물'을 가지고 있다.

00:06:15.000 --> 00:06:19.000
소에 대한 '먹는' 방법이 건초를 취한다고 가정해 봅시다.

00:06:19.000 --> 00:06:25.000
동물 프로토콜과 관련된 'FeedType'의 상한은 '모든 AnimalFeed'이다.

00:06:25.000 --> 00:06:34.000
하지만 임의의 '모든 AnimalFeed'를 감안할 때, 그것이 'Hay' 콘크리트 유형을 저장한다는 것을 정적으로 보장할 수 있는 방법은 없다.

00:06:34.000 --> 00:06:40.000
유형 삭제는 우리가 소비 위치에서 관련 유형으로 작업하는 것을 허용하지 않습니다.

00:06:40.000 --> 00:06:49.000
대신, 불투명한 '일부' 유형을 취하는 함수에 전달하여 실존적 'any' 유형을 개봉해야 합니다.

00:06:49.000 --> 00:06:58.000
관련 유형의 이 유형 삭제 동작은 실제로 Swift 5.6에서 볼 수 있는 기존 언어 기능과 유사합니다.

00:06:58.000 --> 00:07:02.000
참조 유형을 복제하기 위한 프로토콜을 고려하세요.

00:07:02.000 --> 00:07:06.000
이 프로토콜은 Self를 반환하는 단일 clone() 메서드를 정의합니다.

00:07:06.000 --> 00:07:16.000
'Any Cloneable' 유형의 값으로 clone()을 호출하면 결과 유형 'Self'가 상한으로 지워집니다.

00:07:16.000 --> 00:07:25.000
셀프 유형의 상한은 항상 프로토콜 자체이므로, 우리는 '모든 복제 가능' 유형의 새로운 값을 다시 얻는다.

00:07:25.000 --> 00:07:36.000
요약하자면: 'any'를 사용하여 값의 유형이 프로토콜을 준수하는 구체적인 유형을 저장하는 실존적 유형임을 선언할 수 있습니다.

00:07:36.000 --> 00:07:40.000
이것은 심지어 관련 유형이 있는 프로토콜에서도 작동한다.

00:07:40.000 --> 00:07:54.000
생산 위치에서 관련 유형을 가진 프로토콜 메서드를 호출할 때, 관련 유형은 상한으로 유형이 지워지며, 이는 관련 유형의 제약을 전달하는 또 다른 실존적 유형입니다.

00:07:54.000 --> 00:08:07.000
구체적인 유형을 추상화하는 것은 함수 입력에만 유용할 뿐만 아니라 함수 출력에도 유용하므로 구체적인 유형은 구현에서만 볼 수 있습니다.

00:08:07.000 --> 00:08:22.000
코드의 필수 인터페이스를 구현 세부 사항에서 분리하기 위해 구체적인 결과 유형을 추상화하는 방법을 살펴보고, 변화에 직면하여 정적 유형 할당을 더 모듈화되고 견고하게 만들어 봅시다.

00:08:22.000 --> 00:08:27.000
동물에게 먹이를 줄 수 있도록 동물 프로토콜을 일반화합시다.

00:08:27.000 --> 00:08:30.000
동물들은 배고프고, 배고플 때 먹어야 한다.

00:08:30.000 --> 00:08:35.000
동물 프로토콜에 isHungry 속성을 추가합시다.

00:08:35.000 --> 00:08:40.000
농장의 feedAnimals() 방법은 배고픈 동물의 하위 집합을 먹일 것이다.

00:08:40.000 --> 00:08:47.000
나는 배고픈 동물의 이 하위 집합의 계산을 배고픈 동물 재산으로 나누었다.

00:08:47.000 --> 00:08:56.000
hungryAnimals()의 초기 구현은 filter() 메서드를 사용하여 isHungry 속성이 참인 동물의 하위 집합을 선택합니다.

00:08:56.000 --> 00:09:03.000
'Any Animal' 배열에서 filter()를 호출하면 'any Animal'의 새로운 배열이 반환됩니다.

00:09:03.000 --> 00:09:13.000
이제 feedAnimals()가 hungryAnimals의 결과를 한 번만 반복한 다음 즉시 이 임시 배열을 폐기한다는 것을 알 수 있습니다.

00:09:13.000 --> 00:09:18.000
농장에 많은 수의 굶주린 동물들이 있다면 이것은 비효율적이다.

00:09:18.000 --> 00:09:25.000
이 임시 할당을 피하는 한 가지 방법은 표준 라이브러리의 게으른 컬렉션 기능을 사용하는 것이다.

00:09:25.000 --> 00:09:33.000
'필터' 호출을 'lazy.filter'로 대체함으로써, 우리는 게으른 컬렉션으로 알려진 것을 얻는다.

00:09:33.000 --> 00:09:43.000
게으른 컬렉션은 '필터'에 대한 일반 호출에 의해 반환된 배열과 동일한 요소를 가지고 있지만, 임시 할당을 피한다.

00:09:43.000 --> 00:09:55.000
그러나, 이제 'hungryAnimals' 속성의 유형은 다소 복잡한 콘크리트 유형인 'LazyFilterSequence of Array of any Animal'으로 선언되어야 한다.

00:09:55.000 --> 00:10:00.000
이것은 불필요한 구현 세부 사항을 드러낸다.

00:10:00.000 --> 00:10:14.000
클라이언트인 feedAnimals()는 우리가 'hungryAnimals'의 구현에서 'lazy.filter'를 사용했다는 것을 신경 쓰지 않습니다. 반복할 수 있는 컬렉션을 얻고 있다는 것만 알면 됩니다.

00:10:14.000 --> 00:10:23.000
불투명한 결과 유형은 컬렉션의 추상적인 인터페이스 뒤에 복잡한 콘크리트 유형을 숨기는 데 사용될 수 있다.

00:10:23.000 --> 00:10:36.000
이제 'hungryAnimals'라고 부르는 고객들은 컬렉션 프로토콜에 부합하는 구체적인 유형을 얻고 있다는 것만 알고 있지만, 구체적인 유형의 컬렉션을 알지 못한다.

00:10:36.000 --> 00:10:43.000
그러나 쓰여진 대로, 이것은 실제로 클라이언트로부터 너무 많은 정적 유형 정보를 숨긴다.

00:10:43.000 --> 00:10:53.000
우리는 hungryAnimals가 컬렉션에 부합하는 구체적인 유형을 출력한다고 선언하고 있지만, 이 컬렉션의 요소 유형에 대해서는 아무것도 모릅니다.

00:10:53.000 --> 00:11:06.000
요소 유형이 '모든 동물'이라는 지식이 없다면, 우리가 요소 유형으로 할 수 있는 것은 그것을 전달하는 것뿐입니다; 우리는 동물 프로토콜의 어떤 방법도 호출할 수 없습니다.

00:11:06.000 --> 00:11:10.000
불투명한 결과 유형 '일부 컬렉션'에 집중합시다.

00:11:10.000 --> 00:11:22.000
우리는 제한된 불투명한 결과 유형을 사용하여 구현 세부 사항을 숨기는 것과 충분히 풍부한 인터페이스를 노출하는 것 사이의 적절한 균형을 맞출 수 있습니다.

00:11:22.000 --> 00:11:26.000
제한된 불투명한 결과 유형은 Swift 5.7의 새로운 기능이다.

00:11:26.000 --> 00:11:34.000
제한된 불투명한 결과 유형은 프로토콜 이름 뒤에 괄호 안에 유형 인수를 적용하여 작성됩니다.

00:11:34.000 --> 00:11:39.000
컬렉션 프로토콜에는 단일 유형 인수인 요소 유형이 있습니다.

00:11:39.000 --> 00:12:03.000
이제 'hungryAnimals'가 제한된 불투명한 결과 유형으로 선언되면, 실제로 '모든 동물의 배열의 LazyFilterSequence'라는 사실은 클라이언트로부터 숨겨져 있습니다. 그러나 클라이언트는 여전히 컬렉션에 부합하는 구체적인 유형이라는 것을 알고 있으며, 그 요소 관련 유형은 '모든 동물'과 같습니다.

00:12:03.000 --> 00:12:07.000
이것이 바로 우리가 여기서 원하는 인터페이스이다.

00:12:07.000 --> 00:12:20.000
'feedAnimals()'의 for 루프 내부에서, '동물' 변수는 '모든 동물' 유형을 가지고 있으며, 각 굶주린 동물에 대해 동물 프로토콜의 메서드를 호출할 수 있습니다.

00:12:20.000 --> 00:12:30.000
이 모든 것은 컬렉션 프로토콜이 요소 관련 유형이 기본 관련 유형이라고 선언하기 때문에 작동합니다.

00:12:30.000 --> 00:12:41.000
다음과 같이 프로토콜 이름 뒤에 괄호 안에 하나 이상의 관련 유형을 지정하여 기본 관련 유형으로 자체 프로토콜을 선언할 수 있습니다.

00:12:41.000 --> 00:12:58.000
기본 관련 유형으로 가장 잘 작동하는 관련 유형은 컬렉션의 반복자 유형과 같은 구현 세부 사항과 달리 컬렉션의 요소 유형과 같이 일반적으로 호출자가 제공하는 유형입니다.

00:12:58.000 --> 00:13:07.000
종종, 당신은 프로토콜의 주요 관련 유형과 이 프로토콜을 준수하는 구체적인 유형의 일반적인 매개 변수 사이의 대응을 보게 될 것입니다.

00:13:07.000 --> 00:13:21.000
여기서, '컬렉션'의 요소 기본 관련 유형이 배열과 세트의 '요소' 일반 매개 변수에 의해 구현된다는 것을 알 수 있으며, 둘 다 컬렉션을 준수하는 표준 라이브러리에 의해 정의된 두 가지 구체적인 유형입니다.

00:13:21.000 --> 00:13:32.000
'요소 모음'은 '일부' 키워드를 사용하는 불투명한 결과 유형과 'any' 키워드를 사용하는 제한된 실존 유형과 함께 사용할 수 있습니다.

00:13:32.000 --> 00:13:41.000
스위프트 5.7 이전에는 특정 일반적인 인수로 실존적 유형을 나타내기 위해 자신만의 데이터 유형을 작성해야 했을 것입니다.

00:13:41.000 --> 00:13:48.000
스위프트 5.7은 이 개념을 제한된 실존적 유형을 가진 언어로 구축한다.

00:13:48.000 --> 00:14:06.000
만약 우리가 hungryAnimals가 hungryAnimals를 게으르게 또는 열심히 계산할지 여부를 선택할 수 있기를 원한다면, 어떤 동물의 불투명한 컬렉션을 사용하면 함수가 두 가지 다른 기본 유형을 반환하는 오류가 발생할 것이다.

00:14:06.000 --> 00:14:16.000
우리는 대신 '모든 동물의 컬렉션'을 반환하여 이 문제를 해결할 수 있으며, 이 API가 호출에서 다른 유형을 반환할 수 있다는 신호를 보냅니다.

00:14:16.000 --> 00:14:26.000
주요 관련 유형을 제한하는 능력은 불투명한 유형과 실존적 유형에 새로운 수준의 표현력을 제공한다.

00:14:26.000 --> 00:14:36.000
이것은 컬렉션과 같은 다양한 표준 라이브러리 프로토콜과 함께 사용할 수 있습니다. 기본 관련 유형을 갖도록 자체 프로토콜을 선언할 수도 있습니다.

00:14:36.000 --> 00:14:43.000
불투명한 유형을 사용하여 일반 코드를 작성하는 데는 추상적인 유형 관계에 의존해야 합니다.

00:14:43.000 --> 00:14:54.000
관련 프로토콜을 사용하여 여러 추상 유형 간의 필요한 유형 관계를 식별하고 보장하는 방법에 대해 논의해 봅시다.

00:14:54.000 --> 00:15:07.000
우리는 동물에게 이러한 유형의 사료를 섭취하도록 지시하는 eat() 방법과 함께 이 동물이 먹는 구체적인 유형의 동물 사료에 대한 동물 프로토콜에 새로운 관련 유형을 추가할 것입니다.

00:15:07.000 --> 00:15:21.000
일을 더 흥미롭게 만들기 위해, 나는 추가적인 합병증을 소개할 것이다: 우리가 동물에게 먹이를 주기 전에, 우리는 적절한 유형의 작물을 재배하고, 사료를 생산하기 위해 작물을 수확해야 한다.

00:15:21.000 --> 00:15:24.000
여기 콘크리트 유형의 첫 번째 세트가 있습니다.

00:15:24.000 --> 00:15:31.000
소는 건초를 먹기 때문에, 소가 주어진다면, 우리는 먼저 건초를 키워야 한다.

00:15:31.000 --> 00:15:40.000
이것은 우리에게 수확되어 건초로 가공되어 소가 먹을 수 있는 알팔파를 준다.

00:15:40.000 --> 00:15:43.000
여기 두 번째 콘크리트 유형 세트가 있습니다.

00:15:43.000 --> 00:15:59.000
닭은 스크래치를 먹기 때문에, 당신이 나에게 닭을 가져오면, 우리는 먼저 우리가 수확하고 가공하여 닭에게 먹이를 주는 기장이라는 종류의 곡물을 재배해야 합니다.

00:15:59.000 --> 00:16:15.000
저는 이 두 세트의 관련 구체적인 유형을 추상화하고 싶습니다. 그래서 저는 feedAnimal() 방법을 한 번 구현할 수 있고, 소와 닭뿐만 아니라 미래에 입양할 수 있는 새로운 유형의 동물에게도 먹이를 줄 수 있습니다.

00:16:15.000 --> 00:16:33.000
feedAnimal()은 소비 위치에 관련 유형이 있는 Animal 프로토콜의 eat() 메서드와 함께 작동해야 하기 때문에, feedAnimal() 메서드가 '일부 동물'을 매개 변수 유형으로 취한다고 선언함으로써 실존적을 개봉할 것입니다.

00:16:33.000 --> 00:16:43.000
우선, 지금까지 프로토콜과 관련 유형에 대해 알고 있는 것을 사용하여 한 쌍의 프로토콜인 AnimalFeed와 Crop을 정의할 것입니다.

00:16:43.000 --> 00:16:54.000
AnimalFeed에는 Crop을 준수하는 관련 CropType이 있으며, Crop에는 AnimalFeed를 준수하는 관련 FeedType이 있습니다.

00:16:54.000 --> 00:17:00.000
이전과 마찬가지로, 우리는 각 프로토콜에 대한 유형 매개 변수의 다이어그램을 볼 수 있습니다.

00:17:00.000 --> 00:17:03.000
먼저, AnimalFeed를 살펴봅시다.

00:17:03.000 --> 00:17:09.000
모든 프로토콜에는 구체적인 적합성 유형을 나타내는 '셀프' 유형이 있다.

00:17:09.000 --> 00:17:14.000
우리의 프로토콜에는 Crop을 준수하는 관련 'CropType'이 있습니다.

00:17:14.000 --> 00:17:27.000
관련 'CropType'에는 AnimalFeed를 준수하는 중첩된 관련 'FeedType'이 있으며, Crop에 부합하는 중첩된 관련 'CropType'이 있습니다.

00:17:27.000 --> 00:17:39.000
사실, 이 앞뒤는 AnimalFeed와 Crop을 번갈아 가며 관련 유형의 무한한 중첩과 함께 영원히 계속된다.

00:17:39.000 --> 00:17:45.000
작물 프로토콜과 함께, 우리는 비슷한 상황을 가지고 있으며, 단지 하나씩 바뀌었다.

00:17:45.000 --> 00:17:53.000
우리는 AnimalFeed와 관련된 'FeedType'이 있는 'Crop'을 준수하는 'Self' 유형으로 시작합니다.

00:17:53.000 --> 00:18:02.000
이것은 자르기 등과 일치하는 중첩된 관련 'CropType'을 가지고 있습니다...

00:18:02.000 --> 00:18:04.000
무한대로.

00:18:04.000 --> 00:18:11.000
이 프로토콜들이 우리의 구체적인 유형 간의 관계를 올바르게 모델링하는지 봅시다.

00:18:11.000 --> 00:18:19.000
우리가 동물에게 먹이를 주기 전에, 우리는 올바른 유형의 동물 사료로 가공되는 작물을 재배해야 한다는 것을 기억하세요.

00:18:19.000 --> 00:18:32.000
Grow()는 AnimalFeed 프로토콜의 정적 메서드입니다. 즉, 유형이 AnimalFeed를 준수하는 특정 값이 아닌 AnimalFeed를 준수하는 유형에서 직접 호출되어야 합니다.

00:18:32.000 --> 00:18:43.000
우리는 AnimalFeed를 준수하는 유형의 이름을 적어야 하지만, 우리가 가진 모든 것은 Animal을 준수하는 어떤 유형의 특정 값, 다른 프로토콜이다.

00:18:43.000 --> 00:18:56.000
음, 우리는 Animal에 부합하는 일부 유형이라는 것을 알고 있는 이 값의 유형을 얻을 수 있으며, Animal은 AnimalFeed를 준수하는 관련 FeedType을 가지고 있습니다.

00:18:56.000 --> 00:19:00.000
이 유형은 메소드 호출 grow()의 기초로 사용될 수 있다.

00:19:00.000 --> 00:19:09.000
AnimalFeed의 grow() 메서드는 AnimalFeed의 중첩된 관련 CropType인 값을 반환합니다.

00:19:09.000 --> 00:19:13.000
우리는 CropType이 Crop에 부합한다는 것을 알고 있으므로, 나는 그것에 대해 harvest()를 호출할 수 있다.

00:19:13.000 --> 00:19:15.000
하지만 내가 뭘 돌려받을까?

00:19:15.000 --> 00:19:21.000
Harvest()는 Crop 프로토콜의 관련 FeedType을 반환하도록 선언됩니다.

00:19:21.000 --> 00:19:37.000
우리의 경우, 통화의 기반은 (일부 동물)이기 때문에. FeedType.CropType, harvest()는 유형(일부 동물)의 값을 출력합니다. FeedType.CropType.FeedType.

00:19:37.000 --> 00:19:40.000
불행히도, 이것은 잘못된 유형이다.

00:19:40.000 --> 00:19:51.000
(일부 동물)의 eat() 방법은 (일부 동물)을 기대한다. FeedType, 그리고 아닌 (일부 동물). FeedType.CropType.FeedType.

00:19:51.000 --> 00:19:53.000
그 프로그램은 잘 타이핑되지 않았다.

00:19:53.000 --> 00:20:10.000
이 프로토콜 정의는, 쓰여진 바와 같이, 우리가 동물 사료의 종류로 시작한 다음, 이 작물을 재배하고 수확한다면, 우리가 시작한 것과 같은 종류의 동물 사료를 되찾을 것이라는 것을 실제로 보장하지 않으며, 이는 우리 동물이 먹기를 기대하는 것이다.

00:20:10.000 --> 00:20:21.000
그것에 대해 생각하는 또 다른 방법은 이러한 프로토콜 정의가 너무 일반적이라는 것이다 - 그들은 우리의 구체적인 유형 간의 원하는 관계를 정확하게 모델링하지 않는다.

00:20:21.000 --> 00:20:26.000
이유를 이해하기 위해, 우리의 건초와 알팔파 유형을 살펴봅시다.

00:20:26.000 --> 00:20:33.000
내가 건초를 키울 때, 나는 알팔파를 얻고, 알팔파를 수확할 때, 나는 건초를 얻는다.

00:20:33.000 --> 00:20:43.000
이제 제가 코드를 리팩토링하고 있다고 상상해 보세요. 그리고 실수로 Alfalfa의 harvest() 메서드의 반환 유형을 변경하여 Hay 대신 Scratch를 반환합니다.

00:20:43.000 --> 00:21:02.000
이러한 우발적인 변화 이후, 우리가 작물을 재배하고 수확하는 것이 우리가 시작한 것과 동일한 유형의 동물 사료를 생산한다는 우리가 원하는 불변성을 위반했음에도 불구하고, 구체적인 유형은 여전히 AnimalFeed 및 Crop 프로토콜의 요구 사항을 충족합니다.

00:21:02.000 --> 00:21:05.000
AnimalFeed 프로토콜을 다시 살펴봅시다.

00:21:05.000 --> 00:21:12.000
여기서 진짜 문제는 어떤 의미에서, 우리는 너무 많은 뚜렷한 관련 유형을 가지고 있다는 것이다.

00:21:12.000 --> 00:21:19.000
우리는 이러한 관련 유형 중 두 가지가 실제로 같은 구체적인 유형이라는 사실을 적어야 한다.

00:21:19.000 --> 00:21:30.000
이것은 잘못 작성된 구체적인 유형이 우리의 프로토콜을 준수하는 것을 방지할 것이다; 그것은 또한 feedAnimal() 메소드에 필요한 보증을 제공할 것이다.

00:21:30.000 --> 00:21:39.000
우리는 '어디' 절에 쓰여진 동일한 유형의 요구 사항을 사용하여 이러한 관련 유형 간의 관계를 표현할 수 있습니다.

00:21:39.000 --> 00:21:50.000
동일한 유형의 요구 사항은 두 개의 다른, 아마도 중첩된 관련 유형이 실제로 동일한 콘크리트 유형이어야 한다는 정적 보증을 표현한다.

00:21:50.000 --> 00:21:58.000
여기에 동일한 유형의 요구 사항을 추가하면 AnimalFeed 프로토콜을 준수하는 구체적인 유형에 제한이 적용됩니다.

00:21:58.000 --> 00:22:09.000
이 동일한 유형의 요구 사항에서, 우리는 'Self dot CropType dot FeedType'이 'Self'와 같은 유형이라고 선언하고 있습니다.

00:22:09.000 --> 00:22:12.000
우리 다이어그램에서 이게 어떻게 생겼어?

00:22:12.000 --> 00:22:21.000
음, 우리가 그것을 시각화할 수 있는 방법은 다음과 같습니다: AnimalFeed에 부합하는 각 콘크리트 유형에는 Crop에 부합하는 CropType이 있습니다.

00:22:21.000 --> 00:22:34.000
그러나, 이 CropType의 FeedType은 AnimalFeed를 준수하는 다른 유형이 아니라, 원래 AnimalFeed와 동일한 콘크리트 유형이다.

00:22:34.000 --> 00:22:45.000
중첩된 관련 유형의 무한한 타워 대신, 나는 모든 관계를 한 쌍의 관련 관련 유형으로 무너뜨렸다.

00:22:45.000 --> 00:22:48.000
'Crop' 프로토콜은 어떤가요?

00:22:48.000 --> 00:22:57.000
여기서, 작물의 FeedType은 한 쌍의 유형으로 축소되었지만, 우리는 여전히 너무 많은 관련 유형을 가지고 있다.

00:22:57.000 --> 00:23:10.000
우리는 작물의 FeedType의 작물 유형이 우리가 원래 시작한 작물과 같은 유형이라고 말하고 싶습니다.

00:23:10.000 --> 00:23:19.000
이제 이 두 프로토콜이 동일한 유형의 요구 사항을 갖추고 있으므로, 우리는 'feedAnimal()' 메소드를 다시 방문할 수 있습니다.

00:23:19.000 --> 00:23:22.000
우리는 이전과 같이 어떤 동물의 종류로 시작한다.

00:23:22.000 --> 00:23:29.000
그리고 우리는 AnimalFeed 프로토콜을 준수하는 것으로 알고 있는 동물의 사료 유형을 얻는다.

00:23:29.000 --> 00:23:35.000
우리가 이 작물을 재배할 때, 우리는 동물의 사료 유형의 작물 유형을 얻는다.

00:23:35.000 --> 00:23:52.000
하지만 이제, 우리가 이 작물을 수확할 때, 또 다른 중첩된 관련 유형을 얻는 대신, 우리는 우리 동물이 기대하는 사료 유형을 정확히 얻고, 행복한 동물은 이제 우리가 방금 키운 올바른 유형의 동물 사료를 먹을 수 있습니다.

00:23:52.000 --> 00:24:03.000
마지막으로, 우리가 지금까지 본 모든 것을 하나로 모으는 동물 프로토콜의 관련 유형 다이어그램을 살펴봅시다.

00:24:03.000 --> 00:24:10.000
여기 두 가지 유형의 적합성 유형이 있습니다: 첫째, 우리는 소, 건초, 알팔파가 있습니다.

00:24:10.000 --> 00:24:13.000
둘째, 우리는 치킨, 스크래치, 밀레가 있다.

00:24:13.000 --> 00:24:21.000
우리의 세 가지 프로토콜이 세 가지 구체적인 유형의 각 세트 간의 관계를 어떻게 정확하게 모델링하는지 주목하세요.

00:24:21.000 --> 00:24:31.000
데이터 모델을 이해함으로써, 동일한 유형의 요구 사항을 사용하여 이러한 서로 다른 중첩된 관련 유형 간의 동등성을 정의할 수 있습니다.

00:24:31.000 --> 00:24:40.000
그런 다음 일반 코드는 프로토콜 요구 사항에 대한 여러 호출을 연결할 때 이러한 관계에 의존할 수 있습니다.

00:24:40.000 --> 00:24:49.000
이 세션에서, 우리는 유형 삭제가 안전할 때, 그리고 유형 관계가 보장되는 상황에 있어야 할 때를 탐구했습니다.

00:24:49.000 --> 00:25:05.000
그런 다음, 우리는 풍부한 유형 정보를 보존하는 것과 불투명한 결과 유형과 실존적 유형 모두에 모두 사용할 수 있는 기본 관련 유형을 사용하여 구현 세부 사항을 숨기는 것 사이의 올바른 균형을 맞추는 방법에 대해 논의했습니다.

00:25:05.000 --> 00:25:18.000
마지막으로, 우리는 관련 유형 세트를 나타내는 프로토콜 전반에 걸쳐 동일한 유형 요구 사항을 사용하여 구체적인 유형 세트 간의 유형 관계를 식별하고 보장하는 방법을 보았습니다.

00:25:18.000 --> 00:25:20.000
나와 함께 해줘서 고마워.

00:25:20.000 --> 23:59:59.000
나는 네가 멋진 WWDC를 보내길 바라.

