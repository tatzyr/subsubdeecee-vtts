WEBVTT

00:00:00.000 --> 00:00:03.000
♪ 부드러운 기악 힙합 음악 ♪

00:00:03.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:14.000
데빈 클라리: 안녕. 저는 메시지 팀의 엔지니어인 데빈입니다.

00:00:14.000 --> 00:00:17.000
랜스 파커: 그리고 저는 메시지 엔지니어인 랜스입니다.

00:00:17.000 --> 00:00:22.000
데빈: "사용자 지정 협업 앱을 메시지와 통합"에 오신 것을 환영합니다.

00:00:22.000 --> 00:00:32.000
협업은 대화로 시작되며, iOS 16과 macOS Ventura에서는 앱의 사용자 지정 협업 경험을 대화의 구조로 바로 가져올 수 있습니다.

00:00:32.000 --> 00:00:36.000
이 비디오에서, 우리는 협업의 수명 주기를 살펴볼 것이다.

00:00:36.000 --> 00:00:42.000
그런 다음, 메시지를 통해 공유할 앱의 협업 콘텐츠를 준비하는 방법을 보여드리겠습니다.

00:00:42.000 --> 00:00:52.000
다음으로, 개인 정보를 손상시키지 않으면서 수신자 액세스를 즉시 확인하고 참가자 변경 사항에 응답하는 데 필요한 모든 것을 제공할 것입니다.

00:00:52.000 --> 00:00:59.000
마지막으로, 앱이 메시지 대화에 바로 콘텐츠에 대한 공지를 게시할 수 있는 방법을 보여드리겠습니다.

00:00:59.000 --> 00:01:06.000
이 비디오는 앱이 기존 협업 인프라를 가지고 있으며 이미 범용 링크를 채택했다고 가정합니다.

00:01:06.000 --> 00:01:14.000
우리는 또한 "앱에 당신과 공유 추가"와 "메시지와의 협업 경험 강화"에 도입된 몇 가지 개념을 기반으로 할 것입니다.

00:01:14.000 --> 00:01:24.000
먼저, 이 API를 통해 사용자가 그 어느 때보다 빠르게 협업을 시작할 수 있는 방법을 설명하기 위해 사용자 지정 협업 메시지의 수명 주기를 살펴볼 것입니다.

00:01:24.000 --> 00:01:33.000
사용자가 메시지를 통해 앱의 협업을 공유하기로 결정하면, 먼저 콘텐츠를 나타내는 메타데이터를 만듭니다.

00:01:33.000 --> 00:01:41.000
메타데이터에는 사용자가 메시지를 보내기 전에 구성할 수 있는 공유 옵션과 사용자 정의할 수 있는 다른 많은 속성이 포함되어 있습니다.

00:01:41.000 --> 00:01:46.000
다음으로, 메타데이터를 공유 시트에 제공하거나 드래그 앤 드롭하세요.

00:01:46.000 --> 00:01:51.000
이것은 메시지 작성 필드에서 콘텐츠의 초안을 준비할 수 있게 해준다.

00:01:51.000 --> 00:01:55.000
협력은 보편적인 링크로 대표되어야 한다.

00:01:55.000 --> 00:02:00.000
그것은 즉시 만들 수 있지만, 메시지가 전송되기 직전까지 연기하는 것이 가장 좋습니다.

00:02:00.000 --> 00:02:08.000
이것은 앱의 링크 생성이 메시지 작성 필드에 구성된 선택된 공유 옵션 또는 수신자에 의존하는 경우에 유용합니다.

00:02:08.000 --> 00:02:14.000
사용자는 수신자와 공유 옵션을 선택하고 보내기 버튼을 탭합니다.

00:02:14.000 --> 00:02:21.000
메시지가 전송되기 전에, 메시지는 앱에 범용 링크와 콘텐츠에 대한 장치 독립적인 식별자를 요청합니다.

00:02:21.000 --> 00:02:29.000
그 식별자를 사용하여, 메시지는 특정 협업 메시지의 수신자를 나타내는 암호화 신원 세트를 제공한다.

00:02:29.000 --> 00:02:38.000
당신의 앱은 나중에 이러한 신원을 사용하여 수신자가 모든 장치에서 링크를 즉시 열 수 있도록 합니다.

00:02:38.000 --> 00:02:44.000
앱은 이러한 신원을 서버에 저장하고 공유 콘텐츠와 연결합니다.

00:02:44.000 --> 00:02:50.000
앱이 이 단계를 마치면, 메시지가 수신자에게 전송됩니다.

00:02:50.000 --> 00:02:53.000
이제, 수신 장치에서 일어나는 일은 다음과 같습니다.

00:02:53.000 --> 00:02:59.000
목표는 수신자 신원을 서버의 계정과 페어링하여 즉시 액세스를 확인하는 것입니다.

00:02:59.000 --> 00:03:08.000
수신자가 링크를 열면, 앱은 다른 링크와 마찬가지로 URL을 열라는 호출을 받습니다.

00:03:08.000 --> 00:03:18.000
앱이 사용자 계정이 아직 문서에 액세스할 수 없다는 것을 감지하면, 수신자 장치가 암호화로 서명한 사용자 신원 증명을 위해 시스템에 쿼리합니다.

00:03:18.000 --> 00:03:23.000
앱은 검증을 위해 서명된 신원 증명을 서버로 보냅니다.

00:03:23.000 --> 00:03:30.000
서명이 유효한 경우, 서버는 증거를 전송 장치에서 이전에 제공한 신원과 비교합니다.

00:03:30.000 --> 00:03:35.000
일치하는 것이 있다면, 당신의 서버는 사용자의 계정에 대한 접근 권한을 부여합니다.

00:03:35.000 --> 00:03:42.000
그리고 그것으로, 수신자는 계정 정보를 교환하지 않고도 콘텐츠에 즉각적이고 안전하게 접근할 수 있습니다!

00:03:42.000 --> 00:03:45.000
그리고 그것이 협업 메시지의 수명 주기입니다!

00:03:45.000 --> 00:03:51.000
다음으로, 협업을 시작하기 위한 API를 더 자세히 살펴봅시다.

00:03:51.000 --> 00:03:55.000
그 시스템은 협업에 대한 메타데이터가 필요하다.

00:03:55.000 --> 00:04:01.000
그리고 이를 위해, 당신은 SWCollaborationMetadata라는 Shared with You 프레임워크의 새로운 클래스를 사용합니다.

00:04:01.000 --> 00:04:21.000
이 클래스에는 구성할 수 있는 몇 가지 속성이 있습니다: 콘텐츠의 제목, 공유되기 전에 콘텐츠를 참조하는 로컬 식별자; 사용자가 공유하는 계정에 대한 투명성을 제공하기 위한 이니시에이터 이름과 계정 핸들; 그리고 사용자가 구성할 수 있는 기본 공유 옵션.

00:04:21.000 --> 00:04:27.000
메타데이터 객체를 만들고 속성을 구성하는 방법은 다음과 같습니다.

00:04:27.000 --> 00:04:33.000
문자열로 초기화된 SWLocalCollaborationIdentifier를 사용하여 로컬 식별자를 만드세요.

00:04:33.000 --> 00:04:41.000
문자열은 앱이 장치가 아닌 로컬에서 콘텐츠를 식별하는 데 충분하기만 하면 됩니다.

00:04:41.000 --> 00:04:47.000
로컬 식별자를 사용하여 새로운 메타데이터 인스턴스를 초기화하세요.

00:04:47.000 --> 00:04:57.000
기초 프레임워크에서 PersonNameComponents를 사용하여 콘텐츠 제목, 개시자의 계정 핸들 및 이름을 설정하십시오.

00:04:57.000 --> 00:05:04.000
핸들과 이름은 로컬에만 표시되므로 사용자가 공유하는 계정을 확인할 수 있습니다.

00:05:04.000 --> 00:05:07.000
다음으로, defaultShareOptions를 설정하세요.

00:05:07.000 --> 00:05:12.000
어떻게 하는지 보여주기 전에, 먼저 옵션이 어떻게 작동하는지 설명하겠습니다.

00:05:12.000 --> 00:05:18.000
공유 옵션은 사용자가 메시지 또는 공유 시트의 협업에서 구성하는 설정입니다.

00:05:18.000 --> 00:05:23.000
사용자가 선택한 옵션은 메시지가 전송되기 전에 제공됩니다.

00:05:23.000 --> 00:05:32.000
공유 옵션에는 누가 협업을 편집할 수 있는지 또는 누가 콘텐츠에 접근할 수 있어야 하는지와 같은 설정이 포함될 수 있습니다.

00:05:32.000 --> 00:05:38.000
SWCollaborationOption부터 시작하여 몇 가지 클래스를 사용하여 옵션을 정의합니다.

00:05:38.000 --> 00:05:46.000
그룹화 방법에 따라, 옵션은 개별 스위치 또는 설정에 대한 상호 배타적인 값을 나타냅니다.

00:05:46.000 --> 00:05:53.000
옵션에는 제목과 식별자가 있으며, 선택되거나 선택되지 않습니다.

00:05:53.000 --> 00:06:04.000
옵션 그룹을 나타내는 두 가지 클래스가 있습니다: SWCollaborationOptionsGroup과 SWCollaborationOptions PickerGroup.

00:06:04.000 --> 00:06:16.000
SWCollaborationOptionsGroup을 사용하여 스위치 컬렉션을 나타내는 반면, SWCollaborationOptions PickerGroup은 설정에 대해 상호 배타적인 값을 나타냅니다.

00:06:16.000 --> 00:06:25.000
마지막으로, SWCollaborationShareOptions는 메타데이터의 defaultShareOptions 속성에 설정될 전체 옵션 그룹 세트를 정의합니다.

00:06:25.000 --> 00:06:29.000
옵션을 설명하기 위해 요약 문자열을 제공할 수도 있습니다.

00:06:29.000 --> 00:06:34.000
이제 옵션 클래스를 설명했으므로, 여기에 그것들을 사용하는 방법을 보여주는 예가 있습니다.

00:06:34.000 --> 00:06:38.000
이 코드는 두 개의 옵션 그룹을 정의한다.

00:06:38.000 --> 00:06:43.000
첫 번째 그룹은 식별자와 두 가지 가능한 옵션으로 초기화됩니다.

00:06:43.000 --> 00:06:50.000
식별자는 나중에 사용자가 선택한 옵션을 식별하는 데 사용하는 임의의 문자열입니다.

00:06:50.000 --> 00:06:54.000
이것은 피커 그룹이기 때문에, 옵션은 상호 배타적이다.

00:06:54.000 --> 00:07:00.000
이 그룹은 콘텐츠에 대한 권한 설정을 나타냅니다: 읽기 쓰기 또는 읽기 전용.

00:07:00.000 --> 00:07:06.000
그런 다음, 그 그룹의 첫 번째 옵션은 기본적으로 선택된다.

00:07:06.000 --> 00:07:11.000
그리고 제목은 이 그룹을 설명하는 문자열로 설정되어 있다.

00:07:11.000 --> 00:07:16.000
두 번째 옵션 그룹은 같은 방식으로 초기화되며, 두 가지 옵션도 포함되어 있습니다.

00:07:16.000 --> 00:07:23.000
하지만 이것은 일반적인 옵션 그룹이기 때문에, 사용자는 멘션과 댓글을 독립적으로 허용할지 여부를 구성할 수 있습니다.

00:07:23.000 --> 00:07:34.000
마지막으로, 두 옵션 그룹은 메타데이터에 설정된 SWCollaborationShareOptions의 인스턴스를 초기화하는 데 사용됩니다.

00:07:34.000 --> 00:07:42.000
다음으로, 메타데이터는 사용자가 콘텐츠를 공유하기로 결정한 방법에 따라 공유 시트 또는 드래그 앤 드롭에 제공됩니다.

00:07:42.000 --> 00:07:49.000
앱이 SwiftUI를 사용하는 경우, SWCollaborationMetadata는 새로운 ShareLink API와 호환됩니다.

00:07:49.000 --> 00:07:58.000
Transferable 및 ShareLink에 대해 자세히 알아보려면 "Meet Transferable"과 "SwiftUI의 새로운 기능"을 시청하세요.

00:07:58.000 --> 00:08:05.000
SwiftUI에서 프록시 표현에 대한 협업을 지원하는 것이 얼마나 쉬운지는 다음과 같습니다!

00:08:05.000 --> 00:08:15.000
전송 가능한 모델 객체 내에서 협업 메타데이터 인스턴스를 반환하기 위해 ProxyRepresentation을 설정하십시오.

00:08:15.000 --> 00:08:22.000
그런 다음, 보기에서, 그 모델 객체로 ShareLink를 초기화하세요.

00:08:22.000 --> 00:08:28.000
UIKit 및 AppKit 앱의 경우, NSItemProvider를 사용하여 공유를 지원합니다.

00:08:28.000 --> 00:08:33.000
그리고 SWCollaborationMetadata는 NSItemProviderReading and writing을 준수합니다.

00:08:33.000 --> 00:08:39.000
따라서 협업을 지원하기 위해 항목 공급자에게 메타데이터 인스턴스를 등록하기만 하면 됩니다.

00:08:39.000 --> 00:08:47.000
가능한 한 많은 채널을 통해 공유를 지원하기 위해 콘텐츠의 여러 표현을 등록하는 것도 좋습니다.

00:08:47.000 --> 00:08:55.000
예를 들어, 메시지는 파일 표현을 제공하는 경우 콘텐츠를 복사본으로 보낼 수 있는 옵션을 자동으로 제공합니다.

00:08:55.000 --> 00:09:08.000
iOS 및 iPadOS의 UIActivityViewController 및 UIDragItem 및 macOS의 NSSharingServicePicker와 함께 NSItemProvider API를 사용할 수 있습니다.

00:09:08.000 --> 00:09:12.000
iOS의 공유 시트로 설정하는 방법은 다음과 같습니다.

00:09:12.000 --> 00:09:16.000
NSItemProvider 인스턴스를 만드세요.

00:09:16.000 --> 00:09:25.000
시스템의 모든 프로세스에 대한 가시성을 설정하여 이전 예제에서 생성된 협업 메타데이터를 등록하십시오.

00:09:25.000 --> 00:09:36.000
항목 제공자로 UIActivityItemsConfiguration을 초기화한 다음, 해당 구성으로 UIActivityViewController를 초기화하십시오.

00:09:36.000 --> 00:09:40.000
그리고 마지막으로, 뷰 컨트롤러를 제시하세요.

00:09:40.000 --> 00:09:44.000
드래그 앤 드롭을 지원하는 것은 쉽다.

00:09:44.000 --> 00:09:58.000
NSItemProvider를 초기화하고 같은 방식으로 메타데이터를 등록한 다음, 드래그 앤 드롭 API와 함께 사용할 항목 공급자와 함께 UIDragItem을 만드세요.

00:09:58.000 --> 00:10:03.000
API는 공유 팝오버를 위해 macOS에서 유사하다.

00:10:03.000 --> 00:10:06.000
다시, 아이템 제공자를 설정하세요.

00:10:06.000 --> 00:10:11.000
그리고 이번에는 NSSharingServicePicker를 초기화하는 데 사용하세요.

00:10:11.000 --> 00:10:17.000
그런 다음 대상 보기와 관련된 피커를 보여주세요.

00:10:17.000 --> 00:10:22.000
macOS에서 드래그 앤 드롭은 NSItemProvider가 아닌 NSPasteboardItem을 사용합니다.

00:10:22.000 --> 00:10:29.000
이를 지원하기 위해, SharedWithYou는 NSPasteboardItem 확장을 내보냅니다.

00:10:29.000 --> 00:10:39.000
이 확장 프로그램을 사용하여 드래그 앤 드롭을 지원하기 위해 새로운 NSPasteboardItem 인스턴스에서 직접 협업 메타데이터를 설정하십시오.

00:10:39.000 --> 00:10:45.000
그리고 그것이 당신의 협업 콘텐츠 초안이 메시지에 상연되는 데 필요한 전부입니다!

00:10:45.000 --> 00:10:52.000
다음으로, 사용자가 보내기 버튼을 탭하면, 시스템은 앱과 조정하여 공유를 설정합니다.

00:10:52.000 --> 00:10:57.000
그것은 SWCollaborationCoordinator라고 불리는 새로운 수업을 통해 이것을 한다.

00:10:57.000 --> 00:11:03.000
SWCollaborationCoordinator는 싱글톤이며, 이는 글로벌 공유 인스턴스가 있다는 것을 의미한다.

00:11:03.000 --> 00:11:09.000
그 공유 인스턴스는 actionHandler라고 불리는 당신이 정의한 대리인을 통해 협업을 조정합니다.

00:11:09.000 --> 00:11:15.000
앱이 항상 협업을 조정할 수 있도록, 필요할 때 백그라운드에서 실행됩니다.

00:11:15.000 --> 00:11:22.000
따라서 출시 직후에 대리인을 등록하고 시간 초과를 피하기 위해 즉시 조치를 처리해야 합니다.

00:11:22.000 --> 00:11:28.000
앱 실행이 끝난 후 협업 코디네이터를 설정하는 방법은 다음과 같습니다.

00:11:28.000 --> 00:11:33.000
공유 자산을 통해 싱글톤 코디네이터 인스턴스에 액세스하세요.

00:11:33.000 --> 00:11:44.000
그런 다음, 앱 대리인의 didFinishLaunchingWithOptions 메소드에서 actionHandler 속성을 SWCollaborationActionHandler 프로토콜을 준수하는 객체로 설정하십시오.

00:11:44.000 --> 00:11:49.000
액션 핸들러 프로토콜은 SWAction이라는 새로운 클래스를 사용한다.

00:11:49.000 --> 00:11:53.000
SWActions는 앱이 수행할 것으로 예상되는 작업을 나타냅니다.

00:11:53.000 --> 00:11:59.000
당신은 그것들을 완료로 표시하기 위한 행동을 이행하고, 그렇지 않으면 실패합니다.

00:11:59.000 --> 00:12:03.000
앱이 처리해야 할 첫 번째 작업은 협업 작업을 시작하는 것입니다.

00:12:03.000 --> 00:12:12.000
SWStartCollaborationAction에는 사용자가 선택한 공유 옵션으로 업데이트된 이전에 설정한 협업 메타데이터가 포함되어 있습니다.

00:12:12.000 --> 00:12:20.000
필요한 설정을 수행하면, 범용 링크와 협업을 위한 장치 독립적인 식별자로 시작 작업을 수행합니다.

00:12:20.000 --> 00:12:26.000
시작 작업에 명시적으로 실패하면, 메시지는 취소됩니다.

00:12:26.000 --> 00:12:32.000
다음은 예제 서버 요청을 사용하여 시작 작업을 처리하는 구현입니다.

00:12:32.000 --> 00:12:40.000
먼저, 작업의 메타데이터 속성에서 로컬 식별자와 사용자가 선택한 공유 옵션을 검색하십시오.

00:12:40.000 --> 00:12:47.000
식별자와 옵션을 사용하여 협업을 준비하기 위해 서버 요청을 설정하세요.

00:12:47.000 --> 00:12:50.000
그런 다음, 서버에 요청을 보내세요.

00:12:50.000 --> 00:12:54.000
이 예시는 비동기 대기를 사용한다.

00:12:54.000 --> 00:13:01.000
마지막으로, 응답에서 범용 링크와 장치 독립적인 식별자로 작업을 수행하십시오.

00:13:01.000 --> 00:13:05.000
또는, 오류가 있다면, 메시지를 취소하는 작업에 실패하세요.

00:13:05.000 --> 00:13:13.000
시작 작업이 성공하면, 시스템은 협업 참가자를 업데이트하기 위해 앱에 두 번째 작업을 보냅니다.

00:13:13.000 --> 00:13:19.000
SWUpdateCollaboration ParticipantsAction에는 참가자의 암호화 신원이 포함되어 있습니다.

00:13:19.000 --> 00:13:26.000
신원은 이전 단계의 시작 작업에 의해 충족된 협업 식별자에서 파생됩니다.

00:13:26.000 --> 00:13:30.000
콘텐츠와 관련된 서버에 신원을 저장하세요.

00:13:30.000 --> 00:13:35.000
수신자 장치에 대한 액세스를 확인하기 위해 이 데이터를 사용할 것입니다.

00:13:35.000 --> 00:13:40.000
마지막으로, 이 행동을 이행하면 메시지의 보편적인 링크를 보낼 것이다.

00:13:40.000 --> 00:13:45.000
이 예제는 업데이트 참가자 작업을 처리하는 방법을 보여줍니다.

00:13:45.000 --> 00:13:49.000
작업의 메타데이터에서 협업 식별자를 검색하세요.

00:13:49.000 --> 00:13:53.000
이것은 시작 작업을 처리하는 동안 당신이 이행한 식별자입니다.

00:13:53.000 --> 00:14:01.000
다음으로, 작업의 addedIdentities 속성을 사용하여 서버에 저장할 참가자 데이터를 검색하십시오.

00:14:01.000 --> 00:14:05.000
각 신원에는 루트 해시라고 불리는 데이터 속성이 있다.

00:14:05.000 --> 00:14:09.000
이것은 나중에 사용하기 위해 서버에 저장해야 하는 데이터입니다.

00:14:09.000 --> 00:14:16.000
Lance는 Verifying Access 섹션에서 이 속성에 대한 자세한 내용을 검토할 것이다.

00:14:16.000 --> 00:14:23.000
이번에는 대상 식별자와의 협업에 참가자를 추가하기 위해 다른 서버 요청을 설정하십시오.

00:14:23.000 --> 00:14:29.000
그리고 이전과 마찬가지로, 서버에 요청을 보내고, 작업을 이행하거나 실패하세요.

00:14:29.000 --> 00:14:34.000
이번에는, 이행 방법은 어떤 매개 변수도 취하지 않는다.

00:14:34.000 --> 00:14:42.000
이제 협업을 설정했으므로, 앱은 메시지 수신자에게 즉각적인 액세스 권한을 부여하는 데 필요한 모든 것을 갖추고 있습니다.

00:14:42.000 --> 00:14:44.000
내가 그걸 랜스에게 넘겨서 어떻게 하는지 보여줄게!

00:14:44.000 --> 00:14:56.000
랜스: 고마워, 데빈. 이 섹션에서는 이전 단계에서 서버에 저장한 신원 데이터를 사용하여 수신자에게 즉각적인 액세스를 제공하는 방법을 보여 드리겠습니다.

00:14:56.000 --> 00:15:02.000
SWPersonIdentity의 rootHash 속성은 이 검증을 수행하는 데 사용됩니다.

00:15:02.000 --> 00:15:08.000
루트해시는 장치에서 참가자를 고유하게 식별하는 데 사용되는 안전한 값이다.

00:15:08.000 --> 00:15:14.000
검증을 수행하려면, 루트 해시를 계산하는 방법을 이해해야 합니다.

00:15:14.000 --> 00:15:16.000
내가 지금 그걸 통해 너를 데려갈게.

00:15:16.000 --> 00:15:24.000
협업 메시지가 전송되면, 실제로 각 사람의 장치에 개별적으로 전송됩니다.

00:15:24.000 --> 00:15:29.000
메시지는 암호화 공개 키를 사용하여 각 장치를 식별합니다.

00:15:29.000 --> 00:15:39.000
목표는 이 장치 세트에서만 액세스를 허용하는 것이기 때문에, 루트 해시는 각 수신자에게 등록된 공개 키 세트에서 파생됩니다.

00:15:39.000 --> 00:15:45.000
루트 해시는 머클 트리라고 불리는 데이터 구조의 루트 노드이다.

00:15:45.000 --> 00:15:51.000
머클 트리는 일련의 해싱 작업을 수행하여 만들어진 이진 트리이다.

00:15:51.000 --> 00:15:59.000
공개 키를 기반으로 사용자의 신원을 도출하기 위해, 키는 이 트리의 잎으로 사용됩니다.

00:15:59.000 --> 00:16:07.000
머클 트리에 사용되는 해싱 알고리즘은 루트 노드가 해당 키 세트에서만 계산될 수 있도록 합니다.

00:16:07.000 --> 00:16:15.000
이 예에서, 이 사용자는 세 개의 장치와 세 개의 공개 키를 가지고 있다.

00:16:15.000 --> 00:16:24.000
키는 키 다양화라는 프로세스를 사용하여 앱에서 제공하는 각 협업 식별자에 대해 고유합니다.

00:16:24.000 --> 00:16:31.000
사용자에게 등록된 장치의 수를 추적하는 것을 방지하기 위해, 세트는 고정된 크기까지 임의의 키로 채워집니다.

00:16:31.000 --> 00:16:38.000
트리의 리프 노드는 패딩된 다양한 키 세트를 해싱하여 생성됩니다.

00:16:38.000 --> 00:16:44.000
SHA256 알고리즘은 이 트리의 해싱 작업에 사용됩니다.

00:16:44.000 --> 00:16:51.000
그런 다음, 각 리프 노드 쌍은 연결된 다음 상위 노드를 도출하기 위해 해시됩니다.

00:16:51.000 --> 00:17:00.000
이 과정은 부모 노드와 함께 반복되고 단일 루트 노드가 남을 때까지 다시 반복됩니다.

00:17:00.000 --> 00:17:09.000
이것은 장치에서 이 수신자의 신원을 고유하게 나타내는 데 사용되는 루트 해시입니다.

00:17:09.000 --> 00:17:17.000
완전한 머클 트리에서 노드의 하위 집합을 사용하여 루트 해시를 생성할 수 있습니다.

00:17:17.000 --> 00:17:29.000
이 트리의 루트 해시는 다양한 공개 키 P3와 함께 해시 H4, 7, 11만 사용하여 재현할 수 있습니다.

00:17:29.000 --> 00:17:35.000
먼저, 누락된 리프 노드 H3를 얻기 위해 공개 키를 해시하세요.

00:17:35.000 --> 00:17:39.000
H3와 H4를 사용하여 H8을 생성하세요.

00:17:39.000 --> 00:17:44.000
H8과 함께 주어진 H7 노드를 사용하여 H10을 생성하세요.

00:17:44.000 --> 00:17:49.000
그리고 마지막으로, H10과 H11은 루트 해시를 생성한다.

00:17:49.000 --> 00:17:59.000
전체 트리를 재구성할 필요 없이 공개 키 P3가 주어진 루트 해시를 생성하는 데 사용되었다는 것을 증명할 수 있다는 점에 유의하는 것이 중요합니다.

00:17:59.000 --> 00:18:05.000
이것을 하는 데 필요한 노드의 하위 집합은 포함 증명이라고 불린다.

00:18:05.000 --> 00:18:10.000
앱에서 범용 링크가 열리면 확인이 시작됩니다.

00:18:10.000 --> 00:18:15.000
이렇게 하려면, 먼저 링크가 협업인지 확인해야 합니다.

00:18:15.000 --> 00:18:22.000
SWCollaborationHighlight는 협업 링크를 나타내며 SWHighlightCenter에서 검색됩니다.

00:18:22.000 --> 00:18:28.000
그 협업 하이라이트를 사용하여 포용의 증거를 생성하세요.

00:18:28.000 --> 00:18:35.000
포함 증명을 나타내려면, SWPersonIdentityProof라는 클래스를 사용하세요.

00:18:35.000 --> 00:18:43.000
검증을 수행하려면, 먼저 서버로 보낼 암호화 서명과 함께 이 개체를 생성해야 합니다.

00:18:43.000 --> 00:18:48.000
SWHighlightCenter에서 getSignedIdentityProof 방법을 사용하여 증거를 검색하십시오.

00:18:48.000 --> 00:18:57.000
SWCollaborationHighlight와 일부 임의의 데이터가 장치에 의해 서명되어야 합니다.

00:18:57.000 --> 00:19:05.000
당신의 협업에 접근하기 위해 나쁜 행위자가 요청을 재생할 수 없도록 서명을 사용하세요.

00:19:05.000 --> 00:19:13.000
데이터는 서버에서 요청한 도전이거나 장치에서 생성된 nonce일 수 있습니다.

00:19:13.000 --> 00:19:16.000
이 예시는 도전적인 접근 방식을 사용한다.

00:19:16.000 --> 00:19:22.000
URL은 앱의 UIApplicationDelegate에서 이 방법으로 전달됩니다.

00:19:22.000 --> 00:19:28.000
이 URL은 협업과 관련된 범용 링크입니다.

00:19:28.000 --> 00:19:36.000
URL은 SWHighlightCenter에서 관련 SWCollaborationHighlight를 가져오는 데 사용됩니다.

00:19:36.000 --> 00:19:50.000
다음으로, 서버에서 챌린지를 요청하고, 하이라이트와 함께 SWHighlightCenter의 getSignedIdentityProof 방법으로 다시 가져온 데이터를 전달할 것입니다.

00:19:50.000 --> 00:19:53.000
이 방법은 서명된 신원 증명을 반환합니다.

00:19:53.000 --> 00:19:58.000
나중에 이 데이터를 검증하기 위해 당신의 서버가 무엇을 해야 하는지 논의하겠습니다.

00:19:58.000 --> 00:20:03.000
이제 확인을 위해 서명된 증거를 서버에 보낼 수 있습니다.

00:20:03.000 --> 00:20:09.000
마지막으로, 나는 결과로 사용자 인터페이스를 업데이트한다.

00:20:09.000 --> 00:20:16.000
앱은 공개 키와 서명된 데이터와 함께 증거를 서버로 보냅니다.

00:20:16.000 --> 00:20:27.000
데이터는 SHA256을 해시 함수로 사용하여 P-256 타원 곡선을 통해 타원 곡선 디지털 서명 알고리즘을 사용하여 서명됩니다.

00:20:27.000 --> 00:20:32.000
신원 증명의 공개 키를 사용하여 데이터의 서명을 확인하세요.

00:20:32.000 --> 00:20:38.000
가장 일반적으로 사용되는 암호화 라이브러리로 이것을 할 수 있습니다.

00:20:38.000 --> 00:20:46.000
서명을 확인하면, 신원 증명이 해당 공개 키와 관련된 장치에서 전송되었다는 것을 신뢰할 수 있습니다.

00:20:46.000 --> 00:20:52.000
다음으로, 신원 증명을 사용하여 루트 해시를 다시 계산합니다.

00:20:52.000 --> 00:20:59.000
다음은 우리가 전에 살펴본 예제 트리를 사용하여 SWPersonIdentityProof가 무엇을 포함할 것인지에 대한 예입니다.

00:20:59.000 --> 00:21:04.000
머클 트리의 루트 해시를 재구성하는 데 사용하세요.

00:21:04.000 --> 00:21:06.000
공개 키는 P3이다.

00:21:06.000 --> 00:21:12.000
포함 해시는 H4, 7, 11이다.

00:21:12.000 --> 00:21:19.000
2의 로컬 키 인덱스는 트리에서 공개 키의 위치를 나타냅니다.

00:21:19.000 --> 00:21:26.000
다음은 증명의 속성에서 루트 해시를 재구성하는 구현의 예입니다.

00:21:26.000 --> 00:21:32.000
재귀 알고리즘은 트리 데이터 구조로 작업할 때 잘 작동하므로, 그것이 제가 여기서 한 일입니다.

00:21:32.000 --> 00:21:44.000
초기 호출에서, 공개 키의 해시, 포함 해시 세트 및 공개 키 인덱스를 전달하십시오.

00:21:44.000 --> 00:21:49.000
다음으로, 첫 번째 포함 해시를 꺼냈다.

00:21:49.000 --> 00:21:56.000
공개 키 인덱스는 키가 형제의 왼쪽이나 오른쪽에 있는지 확인하기 위해 확인됩니다.

00:21:56.000 --> 00:22:03.000
선택된 해시는 올바른 순서로 연결된 다음 해시됩니다.

00:22:03.000 --> 00:22:14.000
다음으로, inclusionHashes 배열에서 소비된 노드가 제거되고, 나머지는 동일한 함수에 대한 재귀 호출로 전달됩니다.

00:22:14.000 --> 00:22:20.000
공개 키 인덱스도 트리의 다음 노드를 위해 준비되도록 업데이트됩니다.

00:22:20.000 --> 00:22:28.000
이 간단한 함수를 사용하면 신원 증명이 주어진 루트 해시를 빠르게 계산할 수 있습니다.

00:22:28.000 --> 00:22:36.000
서버는 이제 생성된 루트 해쉬가 전송 중에 업로드된 문서의 소유자인 루트 해시 목록에 있는지 확인할 수 있습니다.

00:22:36.000 --> 00:22:42.000
해시는 알려진 해시 목록에 있으므로, 서버는 문서에 대한 액세스 권한을 부여할 수 있습니다.

00:22:42.000 --> 00:22:46.000
이제 당신은 자신 있게 문서에 대한 접근 권한을 부여할 수 있습니다!

00:22:46.000 --> 00:22:55.000
신원을 확인하기 위해 따라야 할 단계를 요약하려면: 먼저, 유니버설 링크를 처리하는 동안 콘텐츠의 협업 하이라이트를 찾아보세요.

00:22:55.000 --> 00:22:59.000
다음으로, 데이터에 서명하고 포함 증명을 검색하세요.

00:22:59.000 --> 00:23:04.000
서명된 데이터와 증거를 서버로 보내세요.

00:23:04.000 --> 00:23:07.000
데이터의 서명을 확인하세요.

00:23:07.000 --> 00:23:11.000
포함 증명을 사용하여 루트 해시를 생성하세요.

00:23:11.000 --> 00:23:19.000
마지막으로, 루트 해시를 해당 콘텐츠와 관련된 알려진 신원 목록과 비교하세요.

00:23:19.000 --> 00:23:28.000
이제 협업 링크에 대한 액세스 확인에 대한 모든 것을 알았으니, 메시지로 참가자 변경 사항을 조정하는 방법에 대해 이야기하겠습니다.

00:23:28.000 --> 00:23:40.000
메시지 그룹의 참가자가 변경되고 해당 그룹이 함께 협업할 때, 사용자는 메시지 스레드의 배너에서 바로 해당 변경 사항을 앱에 전파하도록 선택할 수 있습니다.

00:23:40.000 --> 00:23:50.000
이 시나리오에서, 당신의 앱은 추가 및 제거된 신원을 포함하는 또 다른 SWUpdateCollaboration ParticipantsAction을 받습니다.

00:23:50.000 --> 00:24:00.000
협업을 설정할 때 이 작업을 처리하기 위해 작성한 것과 동일한 코드를 사용하지만, 제거된 참가자도 처리해야 합니다.

00:24:00.000 --> 00:24:06.000
제거하려면, 제거된 신원과 관련된 계정을 찾아 액세스를 취소하기만 하면 됩니다.

00:24:06.000 --> 00:24:12.000
아직 연결된 계정이 없다면, 데이터베이스에서 루트 해시를 삭제하기만 하면 됩니다.

00:24:12.000 --> 00:24:19.000
여기 데빈이 이전에 검토한 업데이트 참가자 행동에 대한 구현이 있습니다.

00:24:19.000 --> 00:24:28.000
이 예제는 작업에서 제거된 ID 속성을 사용하고 유사한 제거 API 요청에 전달합니다.

00:24:28.000 --> 00:24:38.000
이 코드는 제거된 ID 처리만 보여주지만, 완전한 구현은 추가 및 제거된 ID를 모두 처리해야 합니다.

00:24:38.000 --> 00:24:42.000
그리고 그것이 당신이 참가자 변화를 처리하는 데 필요한 전부입니다!

00:24:42.000 --> 00:24:50.000
마지막으로, 협업이 변경되면, 앱은 메시지에 직접 표시될 변경 사항에 대한 공지를 게시합니다.

00:24:50.000 --> 00:24:55.000
이 섹션에서 검토할 몇 가지 유형의 지원되는 공지가 있습니다.

00:24:55.000 --> 00:25:01.000
알림은 링크가 공유된 대화에서 바로 배너로 표시됩니다.

00:25:01.000 --> 00:25:07.000
배너에는 무엇이 바뀌었는지, 그리고 누가 변경했는지에 대한 설명이 포함되어 있다.

00:25:07.000 --> 00:25:12.000
이 대화에서, 찰리는 베이킹 레시피 문서를 편집했다.

00:25:12.000 --> 00:25:17.000
쇼 버튼을 탭하면 콘텐츠에 바로 다시 연결됩니다.

00:25:17.000 --> 00:25:24.000
공지를 나타내기 위해, SharedWithYou 프레임워크에는 SWHighlightEvent라는 프로토콜이 있습니다.

00:25:24.000 --> 00:25:31.000
하이라이트 이벤트는 SWHighlightCenter API에서 검색된 SWHighlights로 초기화됩니다.

00:25:31.000 --> 00:25:36.000
메시지는 여러 범주의 이벤트를 지원합니다.

00:25:36.000 --> 00:25:54.000
콘텐츠 업데이트 또는 댓글에 대한 변경 이벤트, 참가자가 가입하거나 떠날 때 멤버십 이벤트, 사용자가 협업에서 언급될 때 언급 이벤트, 콘텐츠가 이동되거나 삭제될 때의 지속성 이벤트.

00:25:54.000 --> 00:25:59.000
다음은 협업 편집을 위해 변경 이벤트를 게시하는 방법을 보여주는 예입니다.

00:25:59.000 --> 00:26:06.000
하이라이트 센터 API를 사용하여 대상 식별자에 대한 협업 하이라이트를 검색하십시오.

00:26:06.000 --> 00:26:17.000
기억하세요, 이 식별자는 협업 시작 중에 정의한 것이므로, 앱은 콘텐츠가 변경될 때 사용할 수 있어야 합니다.

00:26:17.000 --> 00:26:21.000
다음으로, 하이라이트 변경 이벤트 인스턴스를 만드세요.

00:26:21.000 --> 00:26:30.000
이니셜라이저는 하이라이트와 트리거 열거형 값을 취합니다. 이 경우 편집 유형으로 설정하십시오.

00:26:30.000 --> 00:26:36.000
마지막으로, 다시 하이라이트 센터를 사용하여, 그 행사에 대한 공지를 게시하세요.

00:26:36.000 --> 00:26:49.000
마찬가지로, 멤버십 변경의 경우, 멤버십 이벤트를 게시하고, 이번에는 추가된 공동 작업자 또는 제거된 공동 작업자 트리거 유형을 통과합니다.

00:26:49.000 --> 00:26:55.000
다음으로, 앱이 사용자 멘션을 지원하는 경우, 멘션 이벤트를 게시할 수 있습니다.

00:26:55.000 --> 00:27:00.000
언급된 사용자의 루트 해시로 사람 신원을 초기화하세요.

00:27:00.000 --> 00:27:07.000
액세스를 확인하는 동안 앱의 사용자 계정과 개인 신원을 연결했다는 것을 기억하세요.

00:27:07.000 --> 00:27:15.000
그런 다음, 같은 방식으로 멘션 이벤트를 게시하고, 이번에는 언급된 신원을 매개 변수로 전달합니다.

00:27:15.000 --> 00:27:21.000
이 통지는 언급된 사용자에게 보내는 메시지에만 표시됩니다.

00:27:21.000 --> 00:27:29.000
마지막으로, 콘텐츠가 이동, 이름 변경 또는 삭제될 때 지속성 이벤트 유형을 사용하세요.

00:27:29.000 --> 00:27:37.000
여기서, 이름이 바뀐 트리거 유형은 사용자가 콘텐츠의 이름을 변경했다는 것을 나타내기 위해 사용됩니다.

00:27:37.000 --> 00:27:46.000
그리고 그것이 당신의 앱이 공동 작업자에게 알릴 수 있는 방법이며, 그들은 메시지에서 바로 업데이트를 받을 것입니다.

00:27:46.000 --> 00:27:52.000
데빈: 그리고 그것으로, 당신은 몇 가지 단계를 따라 앱의 협업 경험을 메시지와 통합할 준비가 되었습니다.

00:27:52.000 --> 00:28:06.000
콘텐츠를 공동으로 공유하도록 설정하고, 참가자 액세스를 암호화하여 확인하고, 참가자 변경 사항을 추적하고, 메시지에 공지를 게시하여 사용자를 콘텐츠에 바로 연결하세요.

00:28:06.000 --> 00:28:15.000
"메시지와 협업 경험 향상" 비디오를 확인하여 협업을 위해 표시할 수 있는 새로운 UI 요소에 대해 자세히 알아보세요.

00:28:15.000 --> 00:28:18.000
랜스: 우리는 당신의 앱과 협력하기를 기다릴 수 없습니다!

00:28:18.000 --> 00:28:20.000
데빈과 랜스는 암호로 서명했다.

00:28:20.000 --> 00:28:22.000
데빈: 봐줘서 고마워!

00:28:22.000 --> 23:59:59.000
♪

