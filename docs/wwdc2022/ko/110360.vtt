WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:13.000
안녕! 제 이름은 톰이고, 저는 애플의 스위프트 팀의 일원입니다.

00:00:13.000 --> 00:00:18.000
오늘 저는 iOS 애플리케이션을 클라우드로 확장하는 데 필요한 것을 공유하고 싶습니다.

00:00:18.000 --> 00:00:24.000
우리의 많은 응용 프로그램은 단일 장치, 보통 iPhone에 초점을 맞추기 시작합니다.

00:00:24.000 --> 00:00:33.000
사용량이 증가함에 따라, 우리는 Mac, 시계 또는 기타 Apple 플랫폼 및 장치와 같은 추가 장치로 가져오고 싶어합니다.

00:00:33.000 --> 00:00:38.000
Xcode는 우리가 이러한 플랫폼을 위한 애플리케이션을 구성하고 구축하는 데 도움을 준다.

00:00:38.000 --> 00:00:47.000
우리는 플랫폼별 애플리케이션 코드에서 각 장치의 고유한 측면을 수용하면서 패키지를 사용하여 코드를 공유할 수 있습니다.

00:00:47.000 --> 00:00:54.000
시스템이 계속 성장하고 발전함에 따라, 애플리케이션은 종종 서버 구성 요소로 클라이언트 애플리케이션을 보완해야 한다.

00:00:54.000 --> 00:00:59.000
이러한 서버 구성 요소는 클라이언트 애플리케이션이 기능을 클라우드로 확장할 수 있게 해준다.

00:00:59.000 --> 00:01:11.000
예를 들어, 백그라운드에서 수행할 수 있는 오프로드 작업, 계산이 많은 작업 오프로드 또는 장치에서 사용할 수 없는 데이터에 액세스해야 하는 작업.

00:01:11.000 --> 00:01:21.000
종종, 서버 구성 요소는 고객의 다른 도구와 방법론을 사용하여 구축되어야 하며, 노력과 통합 문제를 중복해야 합니다.

00:01:21.000 --> 00:01:30.000
서버 구성 요소를 구축하기 위해 스위프트를 사용하면 이러한 기술 격차를 해소하여 스택 전반에 걸쳐 친숙한 환경을 제공합니다.

00:01:30.000 --> 00:01:34.000
스위프트에서 서버 애플리케이션을 구축하는 것이 어떻게 생겼는지 봅시다.

00:01:34.000 --> 00:01:38.000
서버 애플리케이션은 스위프트 패키지로 모델링된다.

00:01:38.000 --> 00:01:43.000
이 패키지는 애플리케이션 진입점을 매핑하는 실행 대상을 정의합니다.

00:01:43.000 --> 00:01:54.000
애플리케이션을 웹 애플리케이션으로 만들기 위해, 우리는 코드를 구조화하고 라우팅과 같은 기본 유틸리티를 제공하는 데 도움이 되는 웹 프레임워크에 대한 종속성을 추가할 수 있습니다.

00:01:54.000 --> 00:02:03.000
이 예에서, 우리는 웹 서비스를 구축하는 데 인기 있는 오픈 소스 커뮤니티 프로젝트인 Vapor 웹 프레임워크를 사용합니다.

00:02:03.000 --> 00:02:10.000
다른 스위프트 기반 실행 파일과 마찬가지로, 프로그램의 진입점은 @main 주석을 사용하여 가장 잘 모델링됩니다.

00:02:10.000 --> 00:02:15.000
웹 프레임워크를 통합하기 위해, 우리는 주요 기능에 관련 부트스트랩 코드를 추가합니다.

00:02:15.000 --> 00:02:21.000
이 예제에서 사용된 애플리케이션 유형은 Vapor 웹 프레임워크에 의해 제공됩니다.

00:02:21.000 --> 00:02:26.000
기본 부트스트랩을 통해, 우리는 응용 프로그램이 유용한 일을 하도록 할 수 있습니다.

00:02:26.000 --> 00:02:31.000
예를 들어, 서버에 요청하는 사용자를 맞이하기 위해 코드를 추가해 봅시다.

00:02:31.000 --> 00:02:38.000
우리는 웹 프레임워크를 사용하여 HTTP 엔드포인트를 정의하고 인사를 제공하는 방법을 가리킵니다.

00:02:38.000 --> 00:02:50.000
한 걸음 더 나아가, 우리는 두 번째 HTTP 엔드포인트를 추가하고, 이것은 HTTP 포스트 요청을 처리하고, 요청 본문의 내용을 발신자에게 되풀이합니다.

00:02:50.000 --> 00:02:52.000
이것이 실제로 실행되는지 봅시다.

00:02:52.000 --> 00:02:55.000
여기 Xcode의 서버 애플리케이션이 있습니다.

00:02:55.000 --> 00:03:01.000
이제 막 시작했기 때문에, 우리는 자체 컴퓨터에서 서버를 로컬로 실행하여 테스트할 수 있습니다.

00:03:01.000 --> 00:03:17.000
로컬에서 실행하려면, Xcode에 의해 생성된 "MyServer" 구성표를 선택하고, "My Mac"을 대상으로 사용하고, "실행"을 누르십시오.

00:03:17.000 --> 00:03:23.000
애플리케이션이 실행되면, Xcode 콘솔을 사용하여 서버에서 방출되는 로그 메시지를 검사할 수 있습니다.

00:03:23.000 --> 00:03:31.000
이 경우, 우리는 서버가 로컬 호스트 주소(127.0.0.1) 포트 8080에서 시작되고 수신하는 것을 볼 수 있습니다.

00:03:31.000 --> 00:03:34.000
우리는 이 정보를 사용하여 서버를 테스트할 수 있습니다.

00:03:34.000 --> 00:03:39.000
터미널로 전환하고, 광고된 서버 주소로 요청합시다.

00:03:39.000 --> 00:03:43.000
우리는 요청을 하기 위해 "curl"이라는 유틸리티를 사용합니다.

00:03:43.000 --> 00:03:48.000
우리의 첫 번째 엔드포인트를 사용하세요.

00:03:48.000 --> 00:03:51.000
그리고 우리의 두 번째 것.

00:03:51.000 --> 00:03:59.000
에코에 몇 가지 데이터를 전달하세요.

00:03:59.000 --> 00:04:01.000
좋아!

00:04:01.000 --> 00:04:08.000
터미널을 사용하는 것은 확실히 재미있었지만, 우리가 정말로 알고 싶은 것은 iOS 앱에서 서버를 호출하는 방법입니다.

00:04:08.000 --> 00:04:09.000
그걸 파헤치자.

00:04:09.000 --> 00:04:15.000
다음은 서버와의 상호 작용을 추상화하는 데 사용할 수 있는 스위프트 데이터 구조의 예입니다.

00:04:15.000 --> 00:04:23.000
네트워킹은 본질적으로 비동기적이기 때문에 서버 API를 추상화에 대한 비동기 메서드로 모델링합니다.

00:04:23.000 --> 00:04:32.000
우리는 URLSession을 사용하여 비동기 요청을 한 다음 서버 응답을 구문 분석하고 마지막으로 호출자에게 반환합니다.

00:04:32.000 --> 00:04:39.000
이 경우, 서버 응답은 평범한 문자열이지만, 실제로는 더 정교할 가능성이 높다.

00:04:39.000 --> 00:04:47.000
예를 들어, 응답은 JSON으로 인코딩될 수 있으며, 이 경우 Swift의 Codable 시스템을 사용하여 디코딩할 수 있습니다.

00:04:47.000 --> 00:04:50.000
이 모든 것을 Xcode에 합치자.

00:04:50.000 --> 00:04:56.000
우리는 Xcode 작업 공간을 사용하여 iOS와 서버 애플리케이션을 나란히 구축하고 테스트하고 있습니다.

00:04:56.000 --> 00:05:00.000
우리는 이미 iOS 애플리케이션 서버 추상화를 준비했습니다.

00:05:00.000 --> 00:05:07.000
우리가 모은 코드를 사용하여 서버 인사말을 가져오도록 기본 SwiftUI ContentView를 변경합시다.

00:05:07.000 --> 00:05:13.000
먼저 우리는 serverGreeting이라는 상태 변수를 만듭니다.

00:05:13.000 --> 00:05:21.000
다음으로, 우리는 서버 인사말을 텍스트 디스플레이에 바인딩합니다.

00:05:21.000 --> 00:05:27.000
마지막으로, 우리는 서버 API를 호출하는 작업을 추가하고 상태를 설정합니다.

00:05:27.000 --> 00:05:31.000
코드가 준비되면, 우리는 시뮬레이터에서 애플리케이션을 실행할 수 있습니다.

00:05:31.000 --> 00:05:42.000
우리는 시뮬레이터인 "MyApp" 계획을 선택하고 "실행"을 눌렀다.

00:05:42.000 --> 00:05:44.000
오, 안 돼! 오류가 발생했어!

00:05:44.000 --> 00:05:48.000
흠, 이건 일종의 연결 오류인 것 같아.

00:05:48.000 --> 00:05:52.000
주소가 맞는 것 같아서, 우리는 로컬 서버를 시작하는 것을 잊어버렸을 것이다.

00:05:52.000 --> 00:06:07.000
Xcode로 다시 전환하고, 서버 계획을 선택하고, 서버를 실행합시다.

00:06:07.000 --> 00:06:14.000
이제, 응용 프로그램을 다시 시작하고, 행운을 빌어요...

00:06:14.000 --> 00:06:16.000
그리고 후후! 그건 효과가 있었어!

00:06:16.000 --> 00:06:21.000
데모의 이 부분을 완료하려면, 애플리케이션을 클라우드에 배포합시다.

00:06:21.000 --> 00:06:28.000
AWS, Google Cloud, Azure, Heroku 등을 포함하여 선택할 수 있는 많은 클라우드 제공 업체가 있습니다.

00:06:28.000 --> 00:06:31.000
이 예시에서, 우리는 헤로쿠를 사용할 것이다.

00:06:31.000 --> 00:06:36.000
헤로쿠는 이 데모 애플리케이션과 같은 소규모 프로젝트를 위한 시스템을 배포하기 위한 편리한 git 푸시를 가지고 있다.

00:06:36.000 --> 00:06:39.000
배치를 시작하기 위해 터미널로 전환합시다.

00:06:39.000 --> 00:06:48.000
계정을 설정하고 헤로쿠 서비스로 애플리케이션을 구성한 후, 코드를 헤로쿠 리모컨으로 푸시할 수 있습니다.

00:06:48.000 --> 00:07:02.000
그리고 꺼져!

00:07:02.000 --> 00:07:11.000
헤로쿠는 빌드팩이라는 기술을 사용하여 애플리케이션을 원격으로 컴파일한 다음, 이진 아티팩트를 임시 호스트에 배포합니다.

00:07:11.000 --> 00:07:19.000
헤로쿠 스위프트 빌드팩은 스위프트 오픈 소스 커뮤니티의 구성원에 의해 만들어졌으며, 모든 스위프트 온 서버 사용자가 사용할 수 있습니다.

00:07:19.000 --> 00:07:24.000
애플리케이션이 배포되면, 로컬 서버에서 했던 것처럼 컬을 사용하여 테스트할 수 있습니다.

00:07:24.000 --> 00:07:28.000
첫 번째 엔드포인트를 테스트해 봅시다.

00:07:28.000 --> 00:07:37.000
여기에 주소를 복사하세요.

00:07:37.000 --> 00:07:42.000
그리고 우리의 두 번째 것.

00:07:42.000 --> 00:07:51.000
이번에는, 우리는 다른 페이로드를 보낼 것이다.

00:07:51.000 --> 00:07:55.000
좋아, 우리 애플리케이션이 성공적으로 배포됐어!

00:07:55.000 --> 00:08:00.000
우리가 계속하기 전에, 여기서 잠시 멈추고 이야기의 이 부분에서 주요 요점을 검토해 봅시다.

00:08:00.000 --> 00:08:08.000
이미 Swift를 사용하여 iOS 또는 macOS 애플리케이션을 구축하고 있다면, 시스템의 서버 측을 개발하는 데 사용할 수도 있습니다.

00:08:08.000 --> 00:08:15.000
Xcode는 클라이언트와 서버 모두 하나의 작업 공간에서 시스템의 다양한 구성 요소를 개발하고 디버깅하는 데 도움을 줍니다.

00:08:15.000 --> 00:08:20.000
그리고 마지막으로, Swift 기반 서버 애플리케이션을 배포하기 위한 클라우드 공급자를 선택할 수 있습니다.

00:08:20.000 --> 00:08:28.000
이러한 클라우드 플랫폼에 배포하는 것에 대한 추가 정보는 swift.org의 Swift Server 문서에서 찾을 수 있습니다.

00:08:28.000 --> 00:08:33.000
이제 기본 설정을 보았으니, 더 실제적인 예를 들어 봅시다 - 푸드 트럭!

00:08:33.000 --> 00:08:36.000
당신은 아마 이 응용 프로그램이 많은 세션에서 사용되는 것을 보았을 것입니다.

00:08:36.000 --> 00:08:39.000
후드 아래를 들여다보고 데이터가 어떻게 관리되는지 봅시다.

00:08:39.000 --> 00:08:43.000
흠, 도넛 목록이 하드 코딩된 것 같아.

00:08:43.000 --> 00:08:49.000
이것은 응용 프로그램의 사용자가 실제로 사용할 수 있는 것과 다른 도넛 메뉴를 볼 수 있다는 것을 의미합니다.

00:08:49.000 --> 00:09:01.000
이것은 그 자리에서 모든 종류의 도넛을 만들 수 있는 작은 푸드 트럭 운영에 유용할 수 있지만, 우리는 메뉴가 중앙 집중화되고 트럭이 고객 서비스에 관한 도넛 제국을 건설하고 싶습니다.

00:09:01.000 --> 00:09:06.000
우리의 중앙 집중식 푸드 트럭 시스템이 어떻게 생겼는지 설계해 봅시다.

00:09:06.000 --> 00:09:10.000
우리는 인메모리 스토리지가 있는 iOS 앱으로 시작합니다.

00:09:10.000 --> 00:09:16.000
메뉴를 중앙 집중화하기 위해, iOS 앱에서 저장소를 추출하여 서버로 이동할 수 있습니다.

00:09:16.000 --> 00:09:22.000
이를 통해 앱의 모든 사용자가 동일한 저장소를 공유할 수 있으며, 따라서 동일한 도넛 메뉴를 공유할 수 있습니다.

00:09:22.000 --> 00:09:28.000
이야기의 첫 번째 부분의 예와 마찬가지로, 우리 서버는 HTTP 기반 API를 노출할 것이다.

00:09:28.000 --> 00:09:38.000
iOS 앱은 이러한 API로 작업하기 위해 추상화를 사용한 다음, 이 예에서 SwiftUI에서 프레젠테이션 계층에 다시 연결합니다.

00:09:38.000 --> 00:09:39.000
우리의 디자인은 완성되었다.

00:09:39.000 --> 00:09:42.000
달콤한 코드를 쓸 시간이야.

00:09:42.000 --> 00:09:47.000
개발자 리소스 키트에서 푸드 트럭 샘플 앱을 다운로드하여 따라갈 수 있습니다.

00:09:47.000 --> 00:09:59.000
우리는 애플리케이션 스켈레톤으로 서버를 구축하기 시작한 다음, "도너츠" 웹 API에 대한 HTTP 엔드포인트를 정의하고, 서버 추상화에서 "listDonuts" 메소드를 가리킵니다.

00:09:59.000 --> 00:10:08.000
API가 Donuts 유형의 응답을 반환하고 Response.Donuts가 Content라는 프로토콜을 준수한다는 것을 눈치챘을 것입니다.

00:10:08.000 --> 00:10:15.000
콘텐츠 프로토콜은 웹 프레임워크에 의해 정의되며 응답을 와이어에서 JSON으로 인코딩하는 데 도움을 준다.

00:10:15.000 --> 00:10:29.000
당신은 또한 API가 우리가 아직 정의하지 않은 신비한 모델. 도넛의 배열을 포함한다는 것을 알아차렸을 것입니다. 그래서 여기에 우리의 모든 영광의 데이터 모델이 있습니다: 도넛, 반죽, 글레이즈, 토핑.

00:10:29.000 --> 00:10:39.000
여기서 한 가지 흥미로운 점은 서버와 클라이언트의 데이터 모델을 대략 정렬해야 하기 때문에 푸드 트럭 iOS 앱에서 이 모델의 정의를 복사했다는 것입니다.

00:10:39.000 --> 00:10:43.000
또 다른 흥미로운 점은 Encodable 프로토콜에 대한 적합성이다.

00:10:43.000 --> 00:10:49.000
이것은 우리 서버가 와이어를 통해 모델 객체를 JSON으로 인코딩할 수 있도록 필요합니다.

00:10:49.000 --> 00:10:54.000
데이터 모델과 기본 API를 사용하면 스토리지 추상화를 포함하도록 논리를 확장할 수 있습니다.

00:10:54.000 --> 00:10:58.000
저장소는 응용 프로그램에 사용 가능한 도넛 목록을 제공할 것이다.

00:10:58.000 --> 00:11:01.000
이 시점에서, 우리는 완전한 기능을 갖춘 서버를 가져야 한다.

00:11:01.000 --> 00:11:04.000
하지만 기다려! 우리 도넛 메뉴는 비어 있어!

00:11:04.000 --> 00:11:07.000
중앙 집중식 메뉴는 어디서 구할 수 있을까요?

00:11:07.000 --> 00:11:12.000
스토리지는 서버 측 애플리케이션을 설계할 때 항상 흥미로운 주제이다.

00:11:12.000 --> 00:11:16.000
사용 사례에 따라 선택할 수 있는 몇 가지 전략이 있습니다.

00:11:16.000 --> 00:11:23.000
응용 프로그램 데이터가 정적이거나 매우 느리고 수동으로 변경되는 경우, 디스크의 파일은 충분한 해결책을 제공할 수 있습니다.

00:11:23.000 --> 00:11:32.000
사용자 중심 데이터 또는 글로벌 데이터 세트의 경우, iCloud는 전용 서버를 배포하지 않고도 iOS 애플리케이션에서 직접 사용할 수 있는 API 세트를 제공합니다.

00:11:32.000 --> 00:11:37.000
동적 또는 거래 데이터를 다룰 때, 데이터베이스는 훌륭한 해결책을 제공한다.

00:11:37.000 --> 00:11:42.000
서버 측 애플리케이션에 사용할 수 있는 다양한 데이터베이스 기술이 있다.

00:11:42.000 --> 00:11:48.000
각 기술은 특정 성능, 데이터 일관성 및 데이터 모델링 요구를 위해 설계되었습니다.

00:11:48.000 --> 00:11:55.000
수년에 걸쳐, 스위프트 오픈 소스 커뮤니티는 대부분의 데이터베이스 기술과 기본적으로 상호 작용하는 데 도움이 되는 데이터베이스 드라이버를 개발했습니다.

00:11:55.000 --> 00:12:03.000
부분 목록에는 Postgres, MySQL, MongoDB, Redis, DynamoDB 등이 포함됩니다.

00:12:03.000 --> 00:12:14.000
이 데모를 단순화하기 위해, 우리는 정적 파일 저장 전략만 시연할 것이지만, swift.org의 스위프트 서버 문서에서 데이터베이스 사용에 대해 자세히 알아볼 수 있습니다.

00:12:14.000 --> 00:12:21.000
우리는 정적 파일 저장 전략을 사용하고 있기 때문에, 도넛 메뉴를 캡처하는 JSON 파일을 만드는 것으로 시작합니다.

00:12:21.000 --> 00:12:28.000
이 파일을 만든 후, SwiftPM의 리소스 지원을 사용하여 애플리케이션에 액세스할 수 있도록 할 수 있습니다.

00:12:28.000 --> 00:12:33.000
그것이 제자리에 있으면, 우리의 스토리지 추상화를 더 정교하게 만들 때이다.

00:12:33.000 --> 00:12:36.000
즉, 우리는 "로드" 방법을 추가합니다.

00:12:36.000 --> 00:12:46.000
이 방법은 SwiftPM의 생성된 리소스 접근자를 사용하여 리소스 파일 경로를 찾은 다음 FileManager API를 사용하여 파일의 내용을 메모리에 로드합니다.

00:12:46.000 --> 00:12:53.000
마지막으로, 우리는 JSONDecoder를 사용하여 JSON 콘텐츠를 서버 애플리케이션 데이터 모델로 디코딩합니다.

00:12:53.000 --> 00:12:57.000
한 가지 흥미로운 변화는 스토리지가 이제 배우로 정의된다는 것이다.

00:12:57.000 --> 00:13:07.000
우리는 저장소에 이제 가변적인 "도너츠" 변수가 있고 "load"와 "listDonuts" 메소드가 동시에 액세스할 수 있기 때문에 액터 사용을 선택했습니다.

00:13:07.000 --> 00:13:16.000
스위프트 5.5에서 처음 도입된 배우들은 우리가 데이터 경쟁을 피하고 안전하지만 쉬운 방법으로 공유된 가변 상태를 처리하는 데 도움을 준다.

00:13:16.000 --> 00:13:25.000
배우를 도입하기 전에, 우리는 잠금이나 대기열과 같은 API를 사용하여 가변 상태에 액세스할 때 동기화 블록을 기억하고 추가해야 했을 것이다.

00:13:25.000 --> 00:13:28.000
스토리지 업데이트가 완료되면, 우리는 모든 것을 하나로 묶을 수 있습니다.

00:13:28.000 --> 00:13:33.000
우리는 서버 추상화에 "부트스트랩" 방법을 추가하고 거기에서 스토리지를 로드합니다.

00:13:33.000 --> 00:13:37.000
그런 다음 우리는 부트스트랩을 실행 가능한 진입점으로 연결한다.

00:13:37.000 --> 00:13:42.000
스토리지는 이제 액터이기 때문에, 우리는 비동기 컨텍스트에서 액세스합니다.

00:13:42.000 --> 00:13:43.000
우리 서버는 준비됐어.

00:13:43.000 --> 00:13:45.000
고객 측으로 전환합시다.

00:13:45.000 --> 00:13:52.000
우리는 서버 API를 캡슐화하는 데 도움이 되는 서버 추상화를 추가하는 것으로 시작합니다.

00:13:52.000 --> 00:14:02.000
우리는 URLSession을 사용하여 HTTP 요청을 만들고 JSONDecoder를 사용하여 서버 응답을 디코딩하고 JSON에서 iOS 애플리케이션 모델로 변환합니다.

00:14:02.000 --> 00:14:08.000
이 시점에서, 우리는 하드 코딩된 메뉴를 제거하고 서버에서 비동기 가져오기로 대체할 수 있습니다.

00:14:08.000 --> 00:14:12.000
마지막으로, 우리는 ContentView 로드 작업에서 서버에 호출합니다.

00:14:12.000 --> 00:14:14.000
시험할 시간이야!

00:14:14.000 --> 00:14:17.000
이번에는 서버를 시작하는 것을 잊지 말자.

00:14:17.000 --> 00:14:19.000
우리는 여기서 "FoodTruckServer" 계획을 선택할 것입니다.

00:14:19.000 --> 00:14:24.000
쳐.

00:14:24.000 --> 00:14:33.000
그리고 애플리케이션이 실행되면, 터미널에 뛰어들어 API에 접근할 수 있는지 봅시다.

00:14:33.000 --> 00:14:37.000
주소를 다시 복사하세요.

00:14:37.000 --> 00:14:43.000
이번에는 jq라는 유틸리티를 사용하여 JSON 출력을 더 잘 인쇄할 것입니다.

00:14:43.000 --> 00:14:46.000
이거 꽤 좋아 보여.

00:14:46.000 --> 00:14:49.000
좋아, 우리 앱으로 테스트할 시간이야.

00:14:49.000 --> 00:14:52.000
Xcode로 전환하세요.

00:14:52.000 --> 00:14:56.000
여기서 푸드 트럭 계획을 고르세요.

00:14:56.000 --> 00:14:57.000
시뮬레이터.

00:14:57.000 --> 00:15:01.000
그리고 실행해.

00:15:01.000 --> 00:15:05.000
그리고 거기에는 중앙 집중식 메뉴의 도넛 세 개가 있습니다.

00:15:05.000 --> 00:15:08.000
우리는 서버에서 보는 것과 그것을 상호 참조할 수 있다.

00:15:08.000 --> 00:15:09.000
터미널로 다시 바꾸자.

00:15:09.000 --> 00:15:26.000
비교를 쉽게 하기 위해, 우리는 jq를 사용하여 도넛의 이름만 쿼리할 것이다.

00:15:26.000 --> 00:15:32.000
딥 스페이스, 초콜릿 2, 커피 캐러멜 - 정확히 우리가 예상했던 것.

00:15:32.000 --> 00:15:34.000
그거 정말 멋졌어!

00:15:34.000 --> 00:15:36.000
하지만 우리는 더 잘할 수 있어.

00:15:36.000 --> 00:15:41.000
현재로서는, 우리의 서버와 클라이언트 애플리케이션 모두 데이터 모델 코드의 동일한 복사본을 가지고 있다.

00:15:41.000 --> 00:15:48.000
우리는 iOS와 서버 애플리케이션에서 모델을 공유함으로써 반복을 피하고 직렬화를 더 안전하게 만들 수 있습니다.

00:15:48.000 --> 00:15:51.000
이것을 높은 수준에서 설정하는 방법을 검토해 봅시다.

00:15:51.000 --> 00:15:58.000
먼저, 우리는 "공유"라는 이름의 라이브러리를 위한 또 다른 패키지를 만들고 Xcode 작업 공간에 추가합니다.

00:15:58.000 --> 00:16:10.000
그런 다음 데이터 모델 코드를 공유 패키지로 이동하고, 공유를 서버 애플리케이션의 종속성으로 추가하고, 대상 프레임워크 및 라이브러리 설정을 사용하여 iOS 애플리케이션의 종속성으로 추가할 수 있습니다.

00:16:10.000 --> 00:16:22.000
어느 시점에서, 우리는 클라이언트 코드를 리팩토링하여 공유 모델을 사용하고 서버 코드에도 똑같이 할 수 있습니다.

00:16:22.000 --> 00:16:24.000
지금은 상황이 훨씬 더 좋아 보인다.

00:16:24.000 --> 00:16:29.000
우리가 결론을 내리기 전에, 다음에 지원서를 어디로 가져갈 수 있는지에 대한 몇 가지 아이디어가 있습니다.

00:16:29.000 --> 00:16:37.000
중앙 집중식 서버가 있다는 사실을 최대한 활용하기 위해, 우리는 메뉴에서 도넛을 추가, 편집 또는 삭제하기 위한 API를 원하고 정의할 것입니다.

00:16:37.000 --> 00:16:42.000
이것은 우리가 스토리지를 정적 파일에서 데이터베이스로 옮겨야 할 것이다.

00:16:42.000 --> 00:16:46.000
데이터베이스가 있으면, 우리는 또한 구매 및 주문 API를 구현할 수 있습니다.

00:16:46.000 --> 00:16:50.000
그러한 API는 우리가 도넛 사업으로 수익을 창출하는 데 도움이 될 수 있다.

00:16:50.000 --> 00:16:58.000
그들은 또한 우리가 덜 인기 있는 도넛의 판매 및 할인과 같은 동적 가격을 구현하는 데 사용할 수 있는 신호를 제공한다.

00:16:58.000 --> 00:17:00.000
기회는 끝이 없다.

00:17:00.000 --> 00:17:24.000
마무리하기 위해, 이 세션에서 우리는 Swift가 클라이언트와 서버 애플리케이션 모두에 유용한 범용 언어이며, 서버와 클라이언트 애플리케이션 간에 코드를 공유하면 상용구를 줄이고 시스템 직렬화를 더 안전하게 만들 수 있으며, URLSession은 서버와 비동기적으로 상호 작용하기 위한 핵심 도구이며, 마지막으로 Xcode는 전체 시스템을 위한 강력한 개발 환경입니다.

00:17:24.000 --> 23:59:59.000
시청해 주셔서 정말 감사드리며, 남은 컨퍼런스를 즐기세요.

