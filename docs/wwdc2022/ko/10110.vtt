WEBVTT

00:00:09.000 --> 00:00:12.000
안드레아스: 안녕하세요, WWDC에 오신 것을 환영합니다.

00:00:12.000 --> 00:00:20.000
저는 애플의 현지화 팀의 안드레아스이며, 오늘 고품질의 현지화된 앱을 만드는 방법에 대한 몇 가지 예를 공유하고 싶습니다.

00:00:20.000 --> 00:00:26.000
국제화는 전 세계 모든 장치에서 실행되도록 앱을 준비하는 것을 의미합니다.

00:00:26.000 --> 00:00:33.000
현지화가 잘 완료되면, 모든 사람들은 그들이 말하는 언어에 관계없이 동일한 훌륭한 경험과 유용성을 즐길 수 있다.

00:00:33.000 --> 00:00:41.000
Apple이 제공하는 API를 사용하면, 앱의 대부분의 부분은 즉시 국제화 친화적입니다.

00:00:41.000 --> 00:00:49.000
이 강연에서, 당신은 몇 가지 도전과 우리가 해결한 방법을 포함하여 Apple의 앱을 다양한 청중에게 매력적으로 만드는 우리의 경험을 통해 배우게 될 것입니다.

00:00:49.000 --> 00:00:53.000
나는 현지화된 텍스트를 선언하고 로딩하는 것으로 시작할 것이다.

00:00:53.000 --> 00:00:57.000
형식이 지정된 날짜, 시간 등을 문자열에 포함하는 것은 쉽습니다.

00:00:57.000 --> 00:01:02.000
나는 몇 가지 옵션을 강조할 것이고, 우리는 정교한 예를 살펴볼 것이다.

00:01:02.000 --> 00:01:10.000
스위프트 패키지에는 현지화된 텍스트도 포함될 수 있으며, 현지화 워크플로우 개선에 대해 배우게 될 것입니다.

00:01:10.000 --> 00:01:14.000
마지막으로, 나는 SwiftUI의 레이아웃과 훌륭한 새로운 추가 사항에 대해 이야기할 것이다.

00:01:14.000 --> 00:01:20.000
애플에서, 우리는 우리의 앱이 국제 청중에게 훌륭한 경험을 제공하고 있는지 확인합니다.

00:01:20.000 --> 00:01:22.000
그리고 날씨 앱은 이것의 한 예이다.

00:01:22.000 --> 00:01:30.000
수백만 명의 사용자가 예측을 확인하기 위해 매일 그것을 엽니다. 그리고 이것은 그들이 세계 어디에 있든 앱이 그들에게 보이는 모습입니다.

00:01:30.000 --> 00:01:34.000
UI의 모든 것이 그들의 선호도에 어떻게 조정되는지 주목하세요.

00:01:34.000 --> 00:01:39.000
우리는 현재 기상 조건에 대한 설명을 현지화하고 숫자를 포맷합니다.

00:01:39.000 --> 00:01:45.000
UI는 또한 언어가 왼쪽에서 오른쪽인지 오른쪽에서 왼쪽인지에 따라 적절하게 조정된다.

00:01:45.000 --> 00:01:50.000
번역부터 시작하여 사용자 정의하는 것 중 하나를 자세히 살펴봅시다.

00:01:50.000 --> 00:01:54.000
이 견해는 영어로 "바람이 더 시원하게 만들고 있다"라고 말한다.

00:01:54.000 --> 00:01:57.000
그리고 이것이 다른 언어로 보이는 것이다.

00:01:57.000 --> 00:02:02.000
그것들을 제대로 지원하기 위해, 우리가 해야 할 일은 String(localized)을 사용하여 문자열을 선언하는 것뿐입니다.

00:02:02.000 --> 00:02:09.000
Xcode는 현지화를 위해 내보낼 때 그것을 발견하며, 우리는 번역가를 통해 결과를 보낼 수 있습니다.

00:02:09.000 --> 00:02:11.000
나는 그렇게 하기 위해 내 Mac에서 메일 앱을 사용할 것이다.

00:02:11.000 --> 00:02:13.000
그리고 우리가 거기 있는 동안, 나는 너에게 뭔가를 보여주고 싶어.

00:02:13.000 --> 00:02:22.000
이메일의 상황에 맞는 메뉴를 열면, "아카이브"라는 특별한 폴더로 옮길 수 있습니다. 그건 내 사이드바에 있어.

00:02:22.000 --> 00:02:25.000
두 단어 모두 영어로 "아카이브"인지 주목하세요.

00:02:25.000 --> 00:02:31.000
그러나 스페인어와 같은 다른 언어들은 행동과 폴더 이름에 대해 다른 단어를 가지고 있다.

00:02:31.000 --> 00:02:37.000
영어 단어는 동일하지만, 다른 맥락에서 나타날 때, 다른 언어는 다른 단어를 사용할 수 있다.

00:02:37.000 --> 00:02:40.000
이 경우 코드에서 두 개의 문자열을 사용해야 합니다.

00:02:40.000 --> 00:02:45.000
그리고 그렇게 하기 위해, 우리는 올해 문자열 이니셜라이저에 새로운 API를 추가했습니다.

00:02:45.000 --> 00:02:50.000
이제 영어 문자열에 사용할 수 있는 기본값이 필요합니다.

00:02:50.000 --> 00:02:55.000
그런 다음, 우리는 번역가들에게 구별을 명확하게 하기 위해 지역화된 문자열의 키를 수정합니다.

00:02:55.000 --> 00:03:02.000
이렇게 하면, 영어로 앱을 실행할 때 같은 단어가 표시되며, 스페인어 번역가는 다른 단어를 제공할 수 있습니다.

00:03:02.000 --> 00:03:11.000
작년의 강연 "현지화된 문자열 간소화"는 문자열 관리의 기초를 이해하는 데 도움이 되며, 현지화 프로세스로 더 나아갑니다.

00:03:11.000 --> 00:03:20.000
나는 당신이 때때로 같은 영어 단어 또는 심지어 전체 문장이 UI의 다른 맥락에서 표시되는 이 예에서 벗어나기를 바랍니다.

00:03:20.000 --> 00:03:25.000
이러한 경우, 코드에서 두 개의 다른 문자열을 사용해야 합니다.

00:03:25.000 --> 00:03:27.000
날씨는 단지 앱에 관한 것이 아니다.

00:03:27.000 --> 00:03:30.000
그것은 또한 시스템에 잘 통합되어 있다.

00:03:30.000 --> 00:03:36.000
여기서, 우리는 현재 위치에서 날씨를 확인하기 위해 앱을 열 것을 제안하는 사용자 활동을 봅니다.

00:03:36.000 --> 00:03:39.000
그것이 어떻게 시행될 수 있는지 살펴봅시다.

00:03:39.000 --> 00:03:45.000
문자열 보간을 사용하여 위치 이름을 삽입하여 문자열을 다음과 같이 선언하고 로드할 수 있습니다.

00:03:45.000 --> 00:03:50.000
그리고 이 이름은 도시나 현재 위치에 대한 용어일 수 있다.

00:03:50.000 --> 00:03:57.000
그 결과는 영어로 잘 작동한다: 각각 "쿠퍼티노의 날씨 표시"와 "내 위치의 날씨 표시".

00:03:57.000 --> 00:04:00.000
그러나 다른 언어에서는 문법 문제에 부딪힐 수 있다.

00:04:00.000 --> 00:04:07.000
예를 들어, 독일어에서 전치사는 도시 이름에 대해 작동하지만, 현재 위치에 대한 용어를 삽입할 때 잘못되었다.

00:04:07.000 --> 00:04:10.000
우리는 대신 다른 번역이 필요하다.

00:04:10.000 --> 00:04:15.000
여기서 해결책은 간단합니다: 두 개의 다른 문자열을 사용하세요.

00:04:15.000 --> 00:04:21.000
첫 번째에서 도시 이름을 삽입하는 것은 괜찮으며, 현재 위치에 대해서는 다른 문자열을 사용합니다.

00:04:21.000 --> 00:04:25.000
이것은 번역가들이 그들의 언어에 올바른 문법을 사용할 수 있도록 보장한다.

00:04:25.000 --> 00:04:28.000
그리고 그것은 영어와 독일어로 잘 작동한다.

00:04:28.000 --> 00:04:34.000
변수를 삽입하는 것이 전체 문장에 영향을 미친다는 것을 보여주기 위해 이 예시를 만들었습니다.

00:04:34.000 --> 00:04:46.000
문자열을 결합하는 것은 다른 언어에서 놀라운 결과를 초래할 수 있습니다: 문법을 굴절해야 하거나 대문자에 문제가 있을 수 있지만, 코드를 작성할 때 미리 아는 것은 어렵습니다.

00:04:46.000 --> 00:04:51.000
앱을 테스트하는 언어를 사용하는 사람들을 갖는 것은 워크플로우의 상당 부분이다.

00:04:51.000 --> 00:04:57.000
프로그래밍 방식으로 문자열을 구성하고 싶을 때 그것을 명심하세요.

00:04:57.000 --> 00:05:03.000
이제 문자열이 코드에서 어떻게 선언되는지에 대한 좋은 이해를 공유했으니, 그들의 의견에 대해 이야기해 봅시다.

00:05:03.000 --> 00:05:07.000
여기 적절한 주석과 함께 이전 예제의 문자열이 있습니다.

00:05:07.000 --> 00:05:10.000
댓글은 번역가들에게 정말, 정말 중요하다.

00:05:10.000 --> 00:05:17.000
문자열을 선언할 때와 같은 의도를 유지하면서 번역하는 데 필요한 맥락을 제공해야 합니다.

00:05:17.000 --> 00:05:23.000
훌륭한 주석은 라벨이나 버튼과 같이 문자열이 표시되는 인터페이스 요소를 설명합니다.

00:05:23.000 --> 00:05:28.000
그것은 또한 UI 요소의 맥락과 그것이 화면에 표시되는 위치를 설명한다.

00:05:28.000 --> 00:05:33.000
그것은 섹션 헤더, 컨텍스트 메뉴 또는 사용자 활동일 수 있다.

00:05:33.000 --> 00:05:37.000
문자열에 변수가 포함되어 있다면, 런타임에 그 값을 설명해야 합니다.

00:05:37.000 --> 00:05:42.000
이것은 우리가 예시에서 보았듯이 문장의 문법을 일치시키는 데 매우 중요하다.

00:05:42.000 --> 00:05:47.000
번역가들은 당신의 콘텐츠를 번역할 때 런타임에 앱을 보지 못할 수도 있다는 것을 기억하세요.

00:05:47.000 --> 00:05:56.000
하지만 이러한 팁을 통해 문자열의 선언과 번역, 그리고 앱에서 어떤 역할을 하는지에 대한 공통된 이해를 만들 수 있어야 합니다.

00:05:56.000 --> 00:06:00.000
이제, 그것은 당신에게 전혀 일어나지 않았을 수도 있지만, 날씨 앱은 실제로 날씨를 제어하지 않습니다.

00:06:00.000 --> 00:06:03.000
대신, 데이터는 서버에서 다운로드됩니다.

00:06:03.000 --> 00:06:09.000
그것은 세계 어느 곳에나 위치할 수 있으며 어떤 언어로 콘텐츠를 보내야 할지 모를 수도 있다.

00:06:09.000 --> 00:06:15.000
콘텐츠가 사용자의 장치에 다운로드될 때, 항상 사용자가 선호하는 언어로 표시되어야 합니다.

00:06:15.000 --> 00:06:20.000
앱의 일부만 현지화하는 것은 매우 혼란스러울 수 있다.

00:06:20.000 --> 00:06:26.000
여기서, 날씨 앱은 서버에서 로드된 악천후 경보를 보여줍니다.

00:06:26.000 --> 00:06:32.000
이것은 정말 심각해 보이고, 만약 그것이 내 언어로 번역되지 않았다면, 나는 나중에 곤경에 처할 수도 있다.

00:06:32.000 --> 00:06:38.000
사용자가 항상 원격 콘텐츠를 읽을 수 있도록 하기 위해 무엇을 할 수 있는지 살펴봅시다.

00:06:38.000 --> 00:06:42.000
서버는 지원되는 언어 목록을 앱으로 보낼 수 있습니다.

00:06:42.000 --> 00:06:51.000
이것은 언어 ID의 배열이어야 하며, 장치는 사용자가 선호하는 언어에 대한 모든 지식을 가지고 있으므로, 직접 비교를 확인할 필요가 없습니다.

00:06:51.000 --> 00:06:55.000
'Bundle.preferredLocalizations'를 호출하여 Apple의 프레임워크를 활용할 수 있습니다.

00:06:55.000 --> 00:06:57.000
그리고 이것은 당신을 위해 경기를 할 것입니다.

00:06:57.000 --> 00:07:03.000
사용자의 언어 선택과 얼마나 밀접하게 일치하는지에 따라 정렬된 후보 언어 배열을 반환합니다.

00:07:03.000 --> 00:07:08.000
그리고 첫 번째 것이 보통 가장 잘 맞기 때문에, 당신은 이것을 사용할 것입니다.

00:07:08.000 --> 00:07:13.000
그 언어는 서버에 대한 후속 요청에 사용되어야 한다.

00:07:13.000 --> 00:07:19.000
그것은 사용자가 이해할 수 있는 언어로 된 콘텐츠로 응답을 생성하는 데 사용합니다.

00:07:19.000 --> 00:07:27.000
이 기술을 사용하면 서버에서 오는 문자열이 UI를 업데이트하고 사용자에게 경고를 표시할 준비가 되었다고 확신할 수 있습니다.

00:07:27.000 --> 00:07:40.000
따라서 원격 콘텐츠를 표시할 때 좌절의 폭풍으로부터 사용자를 구하려면, 사용 가능한 언어를 다운로드하고, 사용자의 선호도와 일치시키고, 사용자 대면 콘텐츠를 로드하는 모든 요청에 결과를 사용하세요.

00:07:40.000 --> 00:07:42.000
하지만 이제 더 좋은 날씨로 돌아가자.

00:07:42.000 --> 00:07:48.000
비가 오든 눈이 오든, 날씨 앱은 데이터가 매우 풍부하며 많은 측면에는 숫자와 카운트가 포함되어 있습니다.

00:07:48.000 --> 00:07:51.000
그들 중 하나에 집중하자.

00:07:51.000 --> 00:08:01.000
"강수량" 아래에는 "지난 6시간 동안 0mm"라고 쓰여 있다. 당신이 비슷한 것을 만들고 싶다고 가정해 봅시다, 하지만 여기서 "한 시간"이라고 철자하세요.

00:08:01.000 --> 00:08:04.000
이것이 코드에서 문자열을 선언할 수 있는 방법입니다.

00:08:04.000 --> 00:08:11.000
영어로, 시간 수가 1시간보다 크면 복수형을 사용해야 합니다: 1시간, 하지만 2시간.

00:08:11.000 --> 00:08:16.000
다른 변형을 사용해야 하는 규칙은 우크라이나어에서 훨씬 더 복잡하다.

00:08:16.000 --> 00:08:22.000
당신은 코드에서 그 논리를 구현하고 싶지 않으며, 이것이 당신이 애플의 프레임워크를 활용하는 이유입니다.

00:08:22.000 --> 00:08:29.000
코드로 문자열을 선언하고 복수 규칙을 인코딩하는 stringsdict 파일을 제공하기만 하면 됩니다.

00:08:29.000 --> 00:08:33.000
또 다른 옵션은 자동 문법 계약을 사용하는 것이다.

00:08:33.000 --> 00:08:45.000
작년 강연 "현지화된 문자열 간소화"에서 이 두 가지 기술에 대해 더 많이 배울 수 있습니다. 비록 쉽지만, 모든 문자열에 항상 복수 규칙을 적용해서는 안 됩니다.

00:08:45.000 --> 00:08:52.000
예를 들어, 문장이 아무것도 계산하지 않고 숫자를 포함하지 않는다면, 복수 규칙을 사용해서는 안 됩니다.

00:08:52.000 --> 00:09:00.000
여기서, "즐겨찾기에서 이 도시를 제거하세요"는 숫자가 없기 때문에 필요하지 않으며, 여러 도시에도 동일하게 적용됩니다.

00:09:00.000 --> 00:09:05.000
하지만 문자열에 숫자가 포함되어 있다면, 복수형에 대한 변형을 고려해야 합니다.

00:09:05.000 --> 00:09:14.000
이전 예제의 문자열은 다음 몇 시간 동안 얼마나 많은 비가 내릴지 계산했고, 우리는 하나보다 큰 숫자에 적응하는 것이 얼마나 쉬운지 방금 배웠습니다.

00:09:14.000 --> 00:09:21.000
그러나, 문장에 기간, 시간 또는 백분율과 같은 단위가 있다면, 포맷터를 사용하는 것을 고려해야 합니다.

00:09:21.000 --> 00:09:24.000
그럼 이제 포맷터에 대해 이야기해 봅시다.

00:09:24.000 --> 00:09:28.000
날씨는 이 보기에서 현재 습도를 퍼센트로 보여준다.

00:09:28.000 --> 00:09:32.000
SwiftUI에서 이것을 하기 위해, 그것은 단지 한 줄의 코드의 문제일 뿐이다.

00:09:32.000 --> 00:09:37.000
값을 Text()로 감싸고 번호를 어떻게 포맷할지 지정하기만 하면 됩니다.

00:09:37.000 --> 00:09:39.000
그리고 동등한 스위프트 코드도 간단하다.

00:09:39.000 --> 00:09:43.000
당신은 당신의 가치에 따라 .formatted를 호출합니다.

00:09:43.000 --> 00:09:48.000
그것이 당신이 해야 할 전부이며, 포맷터는 다른 모든 것을 처리합니다.

00:09:48.000 --> 00:10:00.000
그것은 숫자 앞이나 뒤에 퍼센트 기호를 배치하고 공간을 추가할 뿐만 아니라, 사용자가 선호하는 번호 매기 시스템을 수용하며, 아랍어와 힌디어 사용자가 기대하는 것입니다.

00:10:00.000 --> 00:10:05.000
하지만 그것은 당신이 포맷할 수 있는 데이터 유형의 시작에 불과합니다.

00:10:05.000 --> 00:10:19.000
거의 모든 것에 대한 포맷터가 있으며, 세션을 요약하는 것이 좋습니다: "포맷: 데이터를 인간 친화적으로 만드세요." 우리가 보았듯이, 날씨가 항상 화창한 것은 아니며, 어떤 날은 비가 올 것이다.

00:10:19.000 --> 00:10:23.000
물론, 이 하이라이트는 날씨 앱에서 놓칠 수 없다.

00:10:23.000 --> 00:10:32.000
"Rainfall" 아래에는 "다음 24시간 안에 50mm가 예상됨"이라고 쓰여 있고, 지금 내가 있는 곳이 그렇게 많지 않아서 정말 기쁘다.

00:10:32.000 --> 00:10:34.000
영어로, 그 사건은 간단하다.

00:10:34.000 --> 00:10:41.000
우리는 "다음 24시간 안에 50밀리미터가 예상된다"고 말한다. 그러나 스페인어로, 그 문제는 더 복잡하다.

00:10:41.000 --> 00:10:47.000
우리는 강수량이 단수 또는 복수일 때 번역을 변경해야 한다.

00:10:47.000 --> 00:10:51.000
우리는 포맷터와 복수 규칙을 결합하여 이 문제를 해결할 수 있다.

00:10:51.000 --> 00:10:59.000
문자열 "2mm"는 포맷터에 의해 생성되며, 스페인어로 복수형으로 변경해야 하는 문장에 포함되어 있습니다.

00:10:59.000 --> 00:11:03.000
좋아, 코드에서 이것을 하는 방법을 살펴봅시다.

00:11:03.000 --> 00:11:10.000
우리는 강수량이 밀리미터로 얼마나 될지에 대한 매개 변수를 취하는 함수를 선언하는 것으로 시작합니다.

00:11:10.000 --> 00:11:13.000
아마 서버에서 다운로드되었을 거야.

00:11:13.000 --> 00:11:23.000
먼저, 우리는 시스템에 사용자의 구성을 인코딩하는 UnitLength를 요청하고, 강우량을 보여주는 경우에 적합한 것을 선택할 것입니다.

00:11:23.000 --> 00:11:31.000
사용자가 메트릭을 사용하도록 시스템을 구성하지 않은 경우, 측정 유형을 선호하는 단위로 쉽게 변환할 수 있습니다.

00:11:31.000 --> 00:11:38.000
다음으로, 서식 API를 사용하면 한 줄의 코드에서 값에 대한 형식이 지정된 문자열을 생성할 수 있습니다.

00:11:38.000 --> 00:11:42.000
선호 유닛은 이미 우리가 강우량을 표시하고 싶은 정보를 가지고 있다.

00:11:42.000 --> 00:11:45.000
그래서 포맷할 때, 우리는 사용법을 asProvided로 설정합니다.

00:11:45.000 --> 00:11:51.000
1밀리미터 또는 인치 이상의 비가 내린다면, 우리는 복수의 경우를 사용하고 싶습니다.

00:11:51.000 --> 00:11:55.000
우리는 그것을 확인할 수 있도록 값을 정수로 변환한다.

00:11:55.000 --> 00:12:01.000
다음으로, 우리는 주어진 키로 현지화된 문자열을 로드하고, 기본값도 제공합니다.

00:12:01.000 --> 00:12:07.000
거기서, 우리는 문자열 보간을 사용하여 integerValue, formattedValue 및 숫자 24를 포함합니다.

00:12:07.000 --> 00:12:11.000
그 숫자는 항상 24시간이 될 것이기 때문에 여기 코드에 정의되어 있다.

00:12:11.000 --> 00:12:17.000
문자열 보간을 사용하면 올바른 번호 매기 시스템이 자동으로 사용되는지 확인합니다.

00:12:17.000 --> 00:12:19.000
키는 stringsdict 파일에 선언되어 있다.

00:12:19.000 --> 00:12:22.000
그거 한 번 보자.

00:12:22.000 --> 00:12:26.000
Stringsdict는 우리가 방금 코드에서 사용한 키로 시작합니다.

00:12:26.000 --> 00:12:33.000
영어로, 우리는 복수형의 문자열을 변경할 필요가 없으므로, "기타"의 범주를 사용합니다.

00:12:33.000 --> 00:12:36.000
첫 번째 매개 변수는 런타임에 어떤 카테고리가 선택될지 정의한다.

00:12:36.000 --> 00:12:39.000
기억하세요, 그것은 정수 값이었습니다.

00:12:39.000 --> 00:12:43.000
두 번째와 세 번째 매개 변수는 포맷된 문자열에 존재한다.

00:12:43.000 --> 00:12:47.000
이것은 런타임에 문장이 어떻게 보일지 정의한다.

00:12:47.000 --> 00:12:56.000
스페인어 stringsdict는 우리가 단수와 복수로 번역을 제공한다는 점을 제외하고는 같은 구조를 가지고 있다.

00:12:56.000 --> 00:13:00.000
우리는 이제 데이터를 코드로 포맷하고 문장에 배치했습니다.

00:13:00.000 --> 00:13:05.000
Stringsdict 파일에는 복수 규칙이 포함되어 있으므로 스페인어 번역은 올바른 문법을 사용합니다.

00:13:05.000 --> 00:13:11.000
때로는 모든 언어에서 잘 작동하는 완전히 현지화된 UI를 제공하는 것이 어렵다.

00:13:11.000 --> 00:13:18.000
다시 말하지만, 당신은 문자열을 결합하는 것이 영어에서 작동할 수 있지만 다른 언어에서는 놀라운 결과를 초래할 수 있다는 것을 배웠습니다.

00:13:18.000 --> 00:13:24.000
이것은 포괄적인 코드가 필요할 수도 있지만, 이제 모든 사용자에게 어떻게 올바르게 만들 수 있는지 알 수 있습니다.

00:13:24.000 --> 00:13:31.000
때때로 당신의 문자열은 종속성이나 앱이 사용하는 모듈에 있습니다.

00:13:31.000 --> 00:13:36.000
또는 스위프트 패키지를 사용하여 다른 개발자에게 자신의 코드를 배포할 수도 있습니다.

00:13:36.000 --> 00:13:39.000
현지화를 위한 새로운 것을 살펴봅시다.

00:13:39.000 --> 00:13:45.000
스위프트 패키지를 정의하려면 스위프트 자체를 사용하여 구조를 선언하고 구성을 빌드합니다.

00:13:45.000 --> 00:13:53.000
사용자 대면 콘텐츠가 있는 경우, defaultLocalization 매개 변수를 사용하여 콘텐츠가 영어를 기본 언어로 사용하고 있음을 선언할 수 있습니다.

00:13:53.000 --> 00:13:58.000
그것은 앱 프로젝트의 개발 언어를 지정하는 것과 비슷하다.

00:13:58.000 --> 00:14:05.000
Xcode는 이제 그 매개 변수를 읽고 현지화된 경험을 제공하는 데 관심이 있다는 것을 인식합니다.

00:14:05.000 --> 00:14:10.000
그것 때문에, 그것은 제품 메뉴에 현지화를 내보내는 옵션을 추가할 것이다.

00:14:10.000 --> 00:14:16.000
당신은 아마도 메인 앱에 이 기능을 사용하는 데 익숙할 것이며, 이제 스위프트 패키지에서도 작동합니다.

00:14:16.000 --> 00:14:21.000
"내보내기"를 클릭하면, Xcode는 코드를 읽고 모든 문자열을 추출합니다.

00:14:21.000 --> 00:14:25.000
그것들은 당신이 번역가에게 보내는 .xcloc 파일에 배치됩니다.

00:14:25.000 --> 00:14:34.000
그리고 현지화된 콘텐츠를 패키지로 다시 가져오려면, 현지화 가져오기를 사용하면, Xcode는 파일을 패키지의 올바른 파일 경로에 배치합니다.

00:14:34.000 --> 00:14:41.000
스위프트 패키지를 현지화하는 워크플로우는 이제 앱을 현지화하는 것과 동일합니다.

00:14:41.000 --> 00:14:47.000
하지만 스위프트 패키지에서 문자열을 로드하려면 '번들' 인수를 지정해야 합니다.

00:14:47.000 --> 00:15:05.000
"스위프트 패키지: 자원과 현지화" 강연에서 그것에 대해 더 배울 수 있습니다. 스위프트 패키지로 배포되는 라이브러리의 저자라면, 이제 프로젝트를 업데이트하고 현지화를 워크플로우의 정기적인 부분으로 만드는 쉬운 방법이 있습니다.

00:15:05.000 --> 00:15:12.000
당신은 당신의 프로젝트에 많은 노력과 관심을 기울이며, 그것을 현지화하는 것은 모든 고객에게 엄청난 시간을 절약할 수 있습니다.

00:15:12.000 --> 00:15:14.000
그건 정말 돋보이게 할 수 있어.

00:15:14.000 --> 00:15:21.000
당신이 당신의 소프트웨어로 최고의 경험을 제공하기 위해 더 많은 노력을 하고 있다는 것을 사람들에게 알리세요, 그러니 가서 그들에게 말하세요!

00:15:21.000 --> 00:15:25.000
즉시 어떤 언어를 지원하는지 공개하세요.

00:15:25.000 --> 00:15:32.000
앱 개발자로서, 당신은 코드 품질 관점에서뿐만 아니라 의존성에 특별한 고려 사항을 적용합니다.

00:15:32.000 --> 00:15:39.000
사용하는 구성 요소는 앱의 나머지 부분과 동일한 언어와 고품질 번역을 지원해야 합니다.

00:15:39.000 --> 00:15:48.000
타사 코드가 필요한 언어로 현지화되지 않은 경우, 여전히 패키지의 로컬 복사본을 만들고 현지화를 업데이트할 수 있습니다.

00:15:48.000 --> 00:15:53.000
지원하는 언어로 앱의 모든 부분을 테스트해야 합니다.

00:15:53.000 --> 00:15:58.000
이렇게 하면 사용자의 언어에 맞지 않는 UI 요소가 없도록 할 수 있습니다.

00:15:58.000 --> 00:16:06.000
대부분의 경우 번역된 문자열은 영어보다 길거나 짧으며, 이는 항상 앱의 레이아웃에 영향을 미칩니다.

00:16:06.000 --> 00:16:08.000
이것이 날씨 앱에 무엇을 의미하는지 살펴봅시다.

00:16:08.000 --> 00:16:14.000
이것은 영어로 실행되는 앱이며, 오른쪽에서 아랍어로 실행되는 것을 볼 수 있습니다.

00:16:14.000 --> 00:16:22.000
번역이 언어에 적응할 뿐만 아니라 레이아웃도 적절한 방향성을 따르는 것이 분명하다.

00:16:22.000 --> 00:16:40.000
모든 언어에서 작동하는 레이아웃을 만드는 방법, 어떤 유형의 기호가 현지화된 대안을 제공하는지, 그리고 오른쪽에서 왼쪽 언어에 대해 고려해야 할 다른 것에 대해 더 알고 싶다면, "Get it right... to left"라는 강연을 시청하세요. 여기서, 앱은 오른쪽에서 힌디어로 실행되고 있다.

00:16:40.000 --> 00:16:42.000
확대하자.

00:16:42.000 --> 00:16:45.000
그 언어의 대본은 일반적으로 더 큰 경향이 있다.

00:16:45.000 --> 00:16:50.000
그리고 자세히 살펴보면, 라벨의 높이가 그것을 수용하도록 조정되었다는 것을 알 수 있습니다.

00:16:50.000 --> 00:16:52.000
그 시스템은 이것을 자동으로 한다.

00:16:52.000 --> 00:16:57.000
UI 요소에 고정된 높이를 부여하지 않도록 하기만 하면 됩니다.

00:16:57.000 --> 00:17:03.000
영어 줄에 맞을 만큼 키가 크다고 해서 모든 것이 44점 안에 맞을 것이라고 가정하지 마세요.

00:17:03.000 --> 00:17:09.000
상황에 따라 항상 당신의 문자가 더 클 것으로 예상하세요.

00:17:09.000 --> 00:17:17.000
메인 뷰로 돌아가서 위로 스크롤하면, 날씨는 다음 주에 확인하기에 좋은 10일 예측 보기를 가지고 있다.

00:17:17.000 --> 00:17:24.000
이 화면에서 눈에 띄는 것은 가장 긴 라벨에 따라 요소의 위치를 동적으로 조정하는 방법입니다.

00:17:24.000 --> 00:17:28.000
영어로, "오늘"은 모든 축약된 평일 이름보다 길다.

00:17:28.000 --> 00:17:36.000
그러나 스페인어에서는 모두 세 글자 너비이며, 그리스어로 "오늘"의 번역은 거의 두 배 크기이다.

00:17:36.000 --> 00:17:40.000
하지만, 모든 언어에서, 날씨 아이콘은 서로 수직으로 정렬되어 있다.

00:17:40.000 --> 00:17:47.000
즉, 그들은 이웃 요소에 고정된 간격이 없지만, 가장 긴 평일 라벨에 따라 흐른다.

00:17:47.000 --> 00:17:55.000
국제화와 잘 어울리는 레이아웃을 만들 때, 라벨은 유연해야 한다는 것을 항상 명심해야 합니다.

00:17:55.000 --> 00:18:03.000
당신은 그것들을 수직으로 유연하게 만드는 것이 얼마나 중요한지 보았지만, 라벨이 더 긴 번역으로 수평으로 성장할 것으로 기대합니다.

00:18:03.000 --> 00:18:15.000
이 예와 같은 특정 레이아웃에서 그것을 수용하는 것은 어려울 수 있지만, 올해 SwiftUI는 이러한 종류의 레이아웃을 더 쉽게 구축하는 데 도움이 되는 새로운 뷰인 그리드에 대한 지원을 추가합니다.

00:18:15.000 --> 00:18:19.000
그리드를 사용하는 방법을 자세히 살펴봅시다.

00:18:19.000 --> 00:18:22.000
선행 정렬로 그리드를 선언하는 것으로 시작합니다.

00:18:22.000 --> 00:18:31.000
즉, UI 요소는 왼쪽에서 오른쪽 언어로 화면의 왼쪽과 오른쪽에서 왼쪽 언어로 화면의 오른쪽에서 시작됩니다.

00:18:31.000 --> 00:18:35.000
그런 다음, 각 수평 그룹에 대해 GridRow를 추가합니다.

00:18:35.000 --> 00:18:38.000
그리고 마지막으로 당신은 행의 내용을 선언합니다.

00:18:38.000 --> 00:18:41.000
그것이 이 다소 고급 레이아웃을 만드는 데 필요한 전부입니다.

00:18:41.000 --> 00:18:48.000
라벨에 더 많은 공간이 필요할 때, 캡슐은 가장 유연한 요소이기 때문에 크기가 줄어들 수 있다.

00:18:48.000 --> 00:18:55.000
SwiftUI는 뷰 측정, 크기 조정 및 포지셔닝과 같은 모든 무거운 작업을 완전히 자동으로 수행합니다.

00:18:55.000 --> 00:19:02.000
또 다른 과제는 Apple Watch와 같이 제한된 공간의 더 긴 번역 작업으로 보는 것이다.

00:19:02.000 --> 00:19:07.000
여기서, "팁 기능"의 독일어 번역은 한 줄에 맞추기에는 너무 길다.

00:19:07.000 --> 00:19:11.000
이 문제를 해결하기 위해, 우리는 더 많은 공간을 만들기 위해 텍스트 옆에 있는 아이콘을 제거하지 않습니다.

00:19:11.000 --> 00:19:17.000
해결책은 필요한 경우 두 줄 이상의 텍스트를 사용하는 것이며, 이는 기본 동작이다.

00:19:17.000 --> 00:19:22.000
공간이 충분하지 않다면 그것을 변경하고 인터페이스 요소를 숨기는 것을 권장하지 않습니다.

00:19:22.000 --> 00:19:28.000
보통 언어의 요구를 수용할 수 있도록 레이아웃을 조정하는 방법이 있다.

00:19:28.000 --> 00:19:32.000
메일 앱은 이것을 창의적인 방식으로 한다.

00:19:32.000 --> 00:19:37.000
시트 프레젠테이션에는 이 이메일에 대한 조치를 취할 수 있는 네 개의 버튼이 있습니다.

00:19:37.000 --> 00:19:43.000
버튼 제목 중 하나의 번역이 너무 길면, 우리는 텍스트를 자르거나 새 줄로 감싸지 않습니다.

00:19:43.000 --> 00:19:45.000
이것은 시야를 불균형하게 보이게 할 것이다.

00:19:45.000 --> 00:19:53.000
대신, 전체 레이아웃은 수평 스택에서 두 줄의 수직 스택으로 전환된다.

00:19:53.000 --> 00:20:00.000
올해 SwiftUI는 이 동적 레이아웃을 더 쉽게 만들 수 있는 또 다른 훌륭한 도구를 추가합니다: ViewThatFits.

00:20:00.000 --> 00:20:07.000
본질적으로, 공간이 제한되고 보기가 맞지 않는 경우 대체 레이아웃을 제공할 수 있습니다.

00:20:07.000 --> 00:20:13.000
당신은 단순히 서로 독립적으로 당신의 견해를 선언하고, 그것들을 ViewThatFits에 배치하세요.

00:20:13.000 --> 00:20:19.000
SwiftUI는 클리핑 없이 보기가 맞지 않는지 자동으로 감지하고, 제공된 다음 보기로 전환합니다.

00:20:19.000 --> 00:20:22.000
레이아웃만 바꿔야 한다는 것을 명심하세요.

00:20:22.000 --> 00:20:26.000
번역이 너무 길다고 해서 시야를 숨기는 것은 나쁜 관행이다.

00:20:26.000 --> 00:20:30.000
그것은 사용자가 UI에서 방향을 잡는 것을 더 어렵게 만든다.

00:20:30.000 --> 00:20:36.000
유연한 레이아웃을 통해 먼저 모든 인터페이스 요소를 위한 공간을 만드세요.

00:20:36.000 --> 00:20:38.000
이것은 현지화에만 도움이 되는 것이 아니다.

00:20:38.000 --> 00:20:45.000
이 레이아웃은 또한 사용자가 더 작거나 큰 텍스트를 선호하고 다른 장치를 사용할 때 잘 작동합니다.

00:20:45.000 --> 00:20:59.000
올해 SwiftUI의 새로운 레이아웃 기능에 대해 자세히 알아보려면, "SwiftUI로 사용자 지정 레이아웃 구성" 강연을 보는 것이 좋습니다. 다른 접근성 환경 설정과 현지화된 텍스트를 갖는 것은 레이아웃에 문제가 될 수 있습니다.

00:20:59.000 --> 00:21:02.000
인터페이스 요소는 더 크고 넓을 수 있다.

00:21:02.000 --> 00:21:09.000
그것을 수용하기 위해 레이아웃을 조정하는 것은 어려울 수 있지만, SwiftUI를 사용하면 올해는 훨씬 쉬워집니다.

00:21:09.000 --> 00:21:16.000
다른 언어를 지원할 때 코드로 문자열을 구성하는 것이 어려울 수 있다는 이 이야기에서 벗어나길 바랍니다.

00:21:16.000 --> 00:21:23.000
모든 사람에게 잘 작동하는지 확인하기 위해 국제 사용자와 테스터가 제공하는 피드백을 들어보세요.

00:21:23.000 --> 00:21:27.000
스위프트에서 값을 포맷하는 것은 쉽고 종종 한 줄의 코드만 필요합니다.

00:21:27.000 --> 00:21:33.000
그리고 그렇게 하면, 포맷된 값은 사용자의 선호도를 자동으로 존중합니다.

00:21:33.000 --> 00:21:42.000
스위프트 패키지를 제공할 때, 새로운 Xcode 현지화 워크플로우를 사용하여 고객에게 완전히 현지화된 경험을 제공하십시오.

00:21:42.000 --> 00:21:49.000
이제, SwiftUI를 사용하거나 사용하지 않고, 레이아웃은 번역된 텍스트와 접근성 설정을 수용할 수 있어야 합니다.

00:21:49.000 --> 00:21:55.000
레이아웃 도구를 사용하여 인터페이스 요소를 숨기지 않고 레이아웃을 유연하게 만드세요.

00:21:55.000 --> 00:22:03.000
결국, 당신의 사용자들은 당신의 앱이 그들의 삶에 맞기를 기대하기 때문에 그것에 감사할 것이며, 그것은 그들의 언어를 존중하는 것을 포함합니다.

00:22:03.000 --> 00:22:06.000
이제, 나는 매우 화창한 한 주를 기대하고 있어.

00:22:06.000 --> 23:59:59.000
남은 WWDC를 즐기세요, 시청해 주셔서 감사합니다.

