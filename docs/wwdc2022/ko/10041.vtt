WEBVTT

00:00:00.000 --> 00:00:03.000
♪ 부드러운 기악 힙합 음악 ♪

00:00:03.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:11.000
Lais Minchillo: 안녕하세요, 제 이름은 Lais입니다.

00:00:11.000 --> 00:00:17.000
데이비드 실버: 그리고 저는 데이비드입니다. 그리고 우리는 지갑과 애플 페이에서 올해의 새로운 기능을 선보일 것입니다.

00:00:17.000 --> 00:00:27.000
우리는 2014년에 Apple Pay를 출시하여 매장, 온라인 및 인앱에서 빠르고 안전한 비공개 결제를 위한 새로운 벤치마크를 설정했습니다.

00:00:27.000 --> 00:00:31.000
그 이후로, 우리는 전 세계에 Apple Pay를 확장했습니다.

00:00:31.000 --> 00:00:38.000
Apple Pay는 현재 72개 국가와 지역에서 사용할 수 있으며 매일 백만 건 이상의 거래를 처리합니다.

00:00:38.000 --> 00:00:43.000
오늘 우리는 지갑과 애플 페이에 흥미진진한 새로운 기능과 API를 도입하고 있습니다.

00:00:43.000 --> 00:00:45.000
Lais가 너에게 더 말해줄 거야.

00:00:45.000 --> 00:00:47.000
라이스: 고마워, 데이비드!

00:00:47.000 --> 00:00:50.000
오늘의 주요 안건을 살펴봅시다.

00:00:50.000 --> 00:00:53.000
먼저, 우리는 몇 가지 빠른 업데이트에 대해 이야기할 것이다.

00:00:53.000 --> 00:00:59.000
우리는 단일 거래에서 여러 상인에 대한 지불 지원을 추가하고 있습니다.

00:00:59.000 --> 00:01:10.000
우리는 또한 구독을 포함한 자동 결제에 대한 지원을 크게 개선하고 있으며, 주문 추적을 통해 고객의 구매 후 경험을 향상시킬 수 있습니다.

00:01:10.000 --> 00:01:17.000
그리고 마지막으로, 데이비드는 지갑에 있는 ID로 신원 확인에 대해 이야기할 것이다.

00:01:17.000 --> 00:01:20.000
우리는 공유할 몇 가지 흥미로운 업데이트가 있습니다.

00:01:20.000 --> 00:01:27.000
iPhone의 Tap to Pay는 올해 초에 발표되었고 미국에서 iOS 15.4로 출시되었다.

00:01:27.000 --> 00:01:33.000
iPhone에서 탭하여 결제하면 비접촉식 결제를 수락할 수 있는 안전하고 비공개이며 쉬운 방법을 제공합니다.

00:01:33.000 --> 00:01:39.000
이것을 앱에 쉽게 통합하여 비접촉식 결제를 원활하고 안전하게 수락할 수 있습니다.

00:01:39.000 --> 00:01:45.000
여기에는 Apple Pay, 비접촉식 신용 카드 및 직불 카드 및 기타 디지털 지갑이 포함됩니다.

00:01:45.000 --> 00:01:53.000
거래는 iPhone에 대한 간단한 탭을 통해 완료되며, 추가 하드웨어 또는 결제 단말기의 필요성을 제거합니다.

00:01:53.000 --> 00:01:58.000
한편, macOS 13에서 우리는 Apple Pay 경험을 재설계했다.

00:01:58.000 --> 00:02:06.000
작년에 iOS 결제 시트 재설계는 큰 성공을 거두었으며 올해는 macOS와 비슷한 경험을 제공하고 있습니다.

00:02:06.000 --> 00:02:13.000
우리는 SwiftUI를 사용하여 이것을 구현하여 iOS와 동시에 macOS에 새로운 기능을 도입하는 데 도움이 되었습니다.

00:02:13.000 --> 00:02:19.000
오늘 우리가 소개하는 모든 Apple Pay 기능은 Mac에서도 지원됩니다.

00:02:19.000 --> 00:02:23.000
우리는 새로운 SwiftUI API를 소개하고 있습니다.

00:02:23.000 --> 00:02:29.000
SwiftUI 앱에서 Apple Wallet 또는 Apple Pay 버튼에 추가를 통합하는 것이 훨씬 쉬울 것입니다.

00:02:29.000 --> 00:02:33.000
이 새로운 API는 당신이 작성해야 하는 코드의 양을 크게 줄일 것입니다.

00:02:33.000 --> 00:02:39.000
사용자에게 항공사 패스를 추가하라는 버튼을 추가하는 방법을 살펴봅시다.

00:02:39.000 --> 00:02:41.000
먼저, 패스를 만드세요.

00:02:41.000 --> 00:02:45.000
성공적으로 로드되지 않은 경우를 처리해야 합니다.

00:02:45.000 --> 00:02:51.000
예를 들어, 패스 데이터가 잘못되었거나 제대로 서명되지 않은 경우 발생할 수 있습니다.

00:02:51.000 --> 00:02:56.000
다음으로, 패스 배열로 AddPassToWalletButton을 호출하세요.

00:02:56.000 --> 00:03:02.000
이 예에서는 하나의 요소만 있는 배열이 있지만, 같은 버튼에 여러 개의 패스를 가질 수 있습니다.

00:03:02.000 --> 00:03:12.000
결과는 Bool로 전달되며, 사용자가 패스를 추가했는지 여부에 따라 앱에서 다른 작업을 저장, 기록 또는 트리거할 수 있습니다.

00:03:12.000 --> 00:03:15.000
이 예에서, 나는 그것을 주 변수에 저장하고 있다.

00:03:15.000 --> 00:03:16.000
그리고 그게 다야!

00:03:16.000 --> 00:03:21.000
최소 값 세트 내에서 버튼의 크기와 스타일을 사용자 정의할 수도 있습니다.

00:03:21.000 --> 00:03:28.000
이것은 기본 크기입니다: 너비 250과 높이 50.

00:03:28.000 --> 00:03:32.000
당신은 또한 그것을 더 넓게 만들 수 있습니다...

00:03:32.000 --> 00:03:35.000
...또는 더 큰.

00:03:35.000 --> 00:03:40.000
이것은 SwiftUI에서 Apple Wallet에 추가 버튼을 추가하는 방법을 마무리합니다.

00:03:40.000 --> 00:03:45.000
이제, Apple Pay 버튼으로 결제를 어떻게 추가할 수 있는지 봅시다.

00:03:45.000 --> 00:03:52.000
먼저, PKPaymentRequest 클래스를 사용하여 지불 요청을 만들고, 일반적인 구성을 설정하세요.

00:03:52.000 --> 00:03:57.000
그런 다음, authorizationChange 메소드를 만드세요.

00:03:57.000 --> 00:04:01.000
이제 이 두 조각이 준비되었으니, 버튼을 보여줄 코드를 추가해 봅시다.

00:04:01.000 --> 00:04:10.000
PayWithApplePayButton에 호출을 추가하고, 라벨, paymentRequest 객체 및 authorizationChange 방법을 전달하십시오.

00:04:10.000 --> 00:04:16.000
현재 장치에서 Apple Pay가 지원되지 않는 경우를 처리하려면, 대체 보기로 전달할 수 있습니다.

00:04:16.000 --> 00:04:23.000
패스 추가 버튼과 마찬가지로, 크기와 스타일을 사용자 정의할 수도 있습니다.

00:04:23.000 --> 00:04:31.000
총 17개의 다른 라벨이 있으므로, 사용 사례에 맞게 지불 버튼을 사용자 정의할 수 있습니다.

00:04:31.000 --> 00:04:38.000
이것들은 iOS, iPadOS, macOS 및 watchOS에서 사용할 수 있습니다.

00:04:38.000 --> 00:04:42.000
이제, 멀티머천트 결제를 살펴봅시다.

00:04:42.000 --> 00:04:50.000
iOS 16에서는 동일한 거래에서 다른 상인에 대해 여러 지불 토큰을 요청할 수 있는 기능을 도입하고 있습니다.

00:04:50.000 --> 00:04:56.000
이것은 온라인 마켓플레이스, 여행 예약 및 발권 서비스와 같은 것들에 유용합니다.

00:04:56.000 --> 00:04:59.000
예시를 좀 더 자세히 살펴봅시다.

00:04:59.000 --> 00:05:01.000
앨리슨이 여행을 계획하고 있다고 상상해봐.

00:05:01.000 --> 00:05:12.000
그녀는 여행사의 웹사이트에 가서 그녀가 예약해야 할 모든 것, 즉 항공권, 호텔 숙박, 렌터카를 편리하게 제공한다.

00:05:12.000 --> 00:05:16.000
앨리슨은 총 500달러를 지불하면 된다.

00:05:16.000 --> 00:05:20.000
앨리슨은 여행사에 그녀의 전체 신용카드 정보를 제공한다.

00:05:20.000 --> 00:05:29.000
이제, 당신은 여행사가 앨리슨의 신용 카드에 500달러를 청구하고 관련된 다른 회사들에게 지불할 것이라고 상상할 수 있습니다.

00:05:29.000 --> 00:05:38.000
하지만 일반적으로 일어나는 일은 여행사가 개별 요금을 부과하기 위해 신용 카드 정보를 각 회사에 전달하는 것이다.

00:05:38.000 --> 00:05:46.000
이것은 작동하지만, 앨리슨의 개인 정보 보호와 보안이 그녀의 신용 카드 정보를 공유하는 것은 좋지 않다.

00:05:46.000 --> 00:05:55.000
이제, 새로운 멀티머천트 결제 API를 사용하면 거래와 관련된 각 가맹점에 대한 결제 토큰을 요청할 수 있습니다.

00:05:55.000 --> 00:06:03.000
이 지불 토큰을 사용하여, 관련된 여러 회사는 각각 앨리슨이 승인한 관련 금액을 청구할 수 있다.

00:06:03.000 --> 00:06:12.000
앨리슨은 이제 Apple Pay가 제공하는 개인 정보 보호 및 보안 혜택을 이용하면서 여행을 예약하고 지불할 수 있습니다.

00:06:12.000 --> 00:06:18.000
지불 시트는 고객에게 거래와 관련된 수매자의 내역을 보여주기 위해 업데이트되었습니다.

00:06:18.000 --> 00:06:22.000
고객은 총 필드를 탭하여 결제 요약으로 이동할 수 있습니다.

00:06:22.000 --> 00:06:30.000
여기서, 고객은 각각에 대해 승인된 금액과 함께 거래에 관련된 모든 상인의 내역을 볼 수 있습니다.

00:06:30.000 --> 00:06:35.000
이제, 앱에 멀티머천트 결제를 추가하는 방법을 살펴봅시다.

00:06:35.000 --> 00:06:43.000
먼저, PKPaymentRequest 클래스를 사용하여 지불 요청을 만들고, 일반적인 구성을 설정하세요.

00:06:43.000 --> 00:06:48.000
그런 다음 총액을 포함하여 결제에 대한 요약 항목을 추가하세요.

00:06:48.000 --> 00:06:58.000
다음으로, 새로운 PKPaymentTokenContext 클래스를 사용하여 거래와 관련된 각 추가 판매자에 대한 지불 토큰 컨텍스트를 만드세요.

00:06:58.000 --> 00:07:04.000
각 상인에 대한 세부 사항과 각각에 대해 승인할 금액을 제공하십시오.

00:07:04.000 --> 00:07:09.000
마지막으로, 지불 요청에 대한 지불 토큰 컨텍스트를 설정하세요.

00:07:09.000 --> 00:07:19.000
모든 지불 토큰 컨텍스트에 대한 금액의 합계는 지불 요청 자체의 총 금액보다 작거나 같아야 합니다.

00:07:19.000 --> 00:07:28.000
또한, 앱에서 해당 판매자에 대한 지불 토큰을 요청할 때마다 항상 동일한 판매자에 대해 동일한 외부 식별자를 사용해야 합니다.

00:07:28.000 --> 00:07:36.000
웹에서 Apple Pay로 다중 상인 결제를 채택하려면, Apple Pay JS API 문서를 확인하세요.

00:07:36.000 --> 00:07:41.000
이제, 자동 결제에 대한 개선 사항을 살펴봅시다.

00:07:41.000 --> 00:07:50.000
iOS 16에서는 사람들이 지갑 앱에서 바로 가맹점과 설정한 자동 결제를 보고 관리할 수 있는 기능을 도입하고 있습니다.

00:07:50.000 --> 00:08:05.000
이 릴리스에서, 우리는 두 가지 유형의 자동 결제를 지원합니다: 구독, 할부 또는 반복 청구와 같은 것을 포함하는 반복 결제; 그리고 스토어 카드 잔액 충전과 같은 자동 리로드 결제.

00:08:05.000 --> 00:08:12.000
결제 요청을 할 때 자동 결제 설정을 요청할 수 있도록 새로운 API를 도입하고 있습니다.

00:08:12.000 --> 00:08:24.000
우리는 또한 고객의 Apple ID와 연결된 새로운 종류의 결제 토큰인 Apple Pay 가맹점 토큰을 도입하여 지속적으로 고객에게 더 안정적으로 청구할 수 있습니다.

00:08:24.000 --> 00:08:29.000
Apple Pay 가맹점 토큰이 어떻게 유용할 수 있는지 자세히 살펴봅시다.

00:08:29.000 --> 00:08:34.000
줄리가 iPhone에서 Apple Pay를 사용하여 북클럽 멤버십 비용을 지불하고 있다고 상상해 보세요.

00:08:34.000 --> 00:08:46.000
북 클럽은 지불 요청을 하고, 줄리가 지불을 승인하면, 북 클럽은 지불 토큰을 받고, 매달 줄리에게 회비를 청구하는 데 사용할 수 있다.

00:08:46.000 --> 00:08:51.000
이 결제 토큰은 줄리가 결제를 승인하는 데 사용한 장치와 연결되어 있습니다.

00:08:51.000 --> 00:08:55.000
하지만 줄리가 새 아이폰을 받으면 어떻게 되나요?

00:08:55.000 --> 00:09:04.000
새로운 자동 결제 기능을 통해, 줄리의 결제 네트워크가 지원하는 경우, 북 클럽은 대신 Apple Pay 상인 토큰을 받게 될 것이다.

00:09:04.000 --> 00:09:14.000
이 결제 토큰은 iPhone이 아닌 Julie의 Apple ID와 연결되어 있으며, 이는 지속적인 인증에 대한 더 나은 보증을 제공합니다.

00:09:14.000 --> 00:09:23.000
이것은 줄리가 아이폰을 업그레이드하거나 현재 휴대폰을 재설정하면, 북클럽이 줄리의 월 회비를 계속 안정적으로 청구할 수 있다는 것을 의미한다.

00:09:23.000 --> 00:09:36.000
이러한 유형의 결제에 대해 Apple Pay를 수락하는 경우, 고객에게 안정적으로 요금을 계속 청구하고 서비스 중단을 피할 수 있도록 자동 결제를 채택하는 것이 좋습니다.

00:09:36.000 --> 00:09:41.000
이 릴리스에서 우리가 지원하는 첫 번째 자동 결제 유형은 반복 결제입니다.

00:09:41.000 --> 00:09:51.000
반복 지불에는 매주, 매월 또는 매년과 같은 정기적인 일정에 따라 청구되는 고정 또는 가변 금액이 있습니다.

00:09:51.000 --> 00:09:57.000
이러한 지불은 특정 날짜에 종료되거나 취소될 때까지 계속될 수 있습니다.

00:09:57.000 --> 00:10:01.000
시험 또는 입문 기간도 지원됩니다.

00:10:01.000 --> 00:10:08.000
구독, 할부 계획 및 정기 청구는 이러한 유형의 지불에 완벽한 용도입니다.

00:10:08.000 --> 00:10:14.000
자동 결제를 사용하여 앱에서 반복 결제를 설정하는 방법을 살펴봅시다.

00:10:14.000 --> 00:10:22.000
PKRecurringPaymentSummaryItem 클래스를 사용하여 반복 지불의 금액과 기간을 지정하는 것으로 시작하세요.

00:10:22.000 --> 00:10:30.000
반복 결제의 경우, 정기 청구 기간과 입문 또는 시험 기간을 모두 지정할 수 있습니다.

00:10:30.000 --> 00:10:40.000
startDate와 endDate 속성을 사용하여 시험 기간이 언제 끝나고 정규 청구 기간이 언제 시작되는지 표시할 수 있습니다.

00:10:40.000 --> 00:10:47.000
다음으로, 새로운 PKRecurringPaymentRequest 클래스를 사용하여 recurringPaymentRequest를 만드세요.

00:10:47.000 --> 00:10:59.000
고객이 반복 결제에 대한 지불 방법을 업데이트하거나 삭제할 수 있는 웹 페이지에 지불, 일반 청구 기간 및 관리 URL에 대한 설명을 제공하십시오.

00:10:59.000 --> 00:11:09.000
또한 고객에게 지불 조건을 설명하는 데 도움이 되는 청구 계약 텍스트뿐만 아니라 평가판 청구 기간을 선택적으로 제공할 수 있습니다.

00:11:09.000 --> 00:11:21.000
마지막으로, 서버가 지불에 대한 Apple Pay 판매자 토큰에 대한 수명 주기 알림을 받을 수 있는 tokenNotificationURL을 선택적으로 제공할 수 있습니다.

00:11:21.000 --> 00:11:27.000
예를 들어, 카드 발급사나 사용자가 토큰을 삭제하면 알림을 받을 수 있습니다.

00:11:27.000 --> 00:11:36.000
판매자 토큰 수명 주기 알림에 대한 자세한 내용은 Apple Pay 판매자 토큰 관리 API 문서를 참조하십시오.

00:11:36.000 --> 00:11:42.000
마지막으로, paymentRequest 객체에 recurringPaymentRequest를 설정하세요.

00:11:42.000 --> 00:11:49.000
요약 항목에 대한 빠른 메모, 반복 결제는 지불 요청의 요약 항목에 자동으로 추가되지 않습니다.

00:11:49.000 --> 00:11:54.000
그러니 반드시 요약 항목 배열에 항목을 추가하세요.

00:11:54.000 --> 00:11:59.000
지불 요청의 총액은 고객에게 청구될 첫 번째 금액이어야 합니다.

00:11:59.000 --> 00:12:07.000
그래서 이 예에서, 총액은 고객에게 청구될 첫 번째 금액이기 때문에 시험 기간 금액을 표시하도록 설정되어 있습니다.

00:12:07.000 --> 00:12:17.000
결제 시트에는 고객에게 반복 결제에 대한 세부 사항이 표시되며, 청구 세부 정보 섹션을 탭하여 더 자세히 읽을 수 있습니다.

00:12:17.000 --> 00:12:24.000
이제, 우리가 이 릴리스에서 지원하는 두 번째 유형의 자동 결제를 살펴봅시다: 자동 재장전 결제.

00:12:24.000 --> 00:12:32.000
이러한 유형의 결제로, 잔액은 잔액이 특정 임계값 이하로 떨어질 때마다 고정 금액으로 자동으로 추가됩니다.

00:12:32.000 --> 00:12:39.000
자동 재장전 결제는 매장 카드 충전 및 선불 잔액과 같은 것에 완벽합니다.

00:12:39.000 --> 00:12:51.000
자동 재장전 결제 설정을 요청하려면, 새로운 PKAutomatic ReloadPaymentSummaryItem 클래스를 사용하여 재장전 및 임계값을 지정하는 것으로 시작하십시오.

00:12:51.000 --> 00:13:06.000
다음으로, 반복 결제와 마찬가지로 결제, 청구 및 관리 URL에 대한 설명을 전달하는 새로운 PKAutomatic ReloadPaymentRequest 클래스를 사용하여 automaticReloadPaymentRequest를 만드세요.

00:13:06.000 --> 00:13:13.000
청구 계약 텍스트와 토큰 알림 URL을 선택적으로 제공할 수도 있습니다.

00:13:13.000 --> 00:13:19.000
마지막으로, 지불 요청 객체에 대한 자동 재장전 지불 요청을 설정하세요.

00:13:19.000 --> 00:13:27.000
다시 말하지만, 요약 항목에 자동 재장전 결제를 포함하고 결제 요청 총액을 적절하게 설정해야 합니다.

00:13:27.000 --> 00:13:35.000
웹에서 Apple Pay로 자동 결제를 채택하려면, Apple Pay JS API 문서를 확인하세요.

00:13:35.000 --> 00:13:41.000
자동 재장전 결제가 고객을 위한 결제 시트에 나타나는 방법은 다음과 같습니다.

00:13:41.000 --> 00:13:50.000
마지막으로, 앱에서 자동 결제를 채택할 때 고객에게 최상의 경험을 제공하기 위해 기억해야 할 몇 가지 사항이 있습니다.

00:13:50.000 --> 00:13:56.000
자동 결제를 위한 요약 항목이 추가되지 않기 때문에 요약 항목을 포함하는 것을 잊지 마세요.

00:13:56.000 --> 00:14:02.000
지불 요청의 총 금액은 고객에게 청구될 첫 번째 금액이어야 합니다.

00:14:02.000 --> 00:14:05.000
청구 계약 텍스트를 짧게 유지해야 합니다.

00:14:05.000 --> 00:14:09.000
지불 시트는 처음 500자만 보여줄 것이다.

00:14:09.000 --> 00:14:14.000
청구 계약 텍스트는 일반 청구 및 법적 계약을 대체하기 위한 것이 아닙니다.

00:14:14.000 --> 00:14:19.000
현지 반복 청구법을 준수하는 것은 당신에게 달려 있습니다.

00:14:19.000 --> 00:14:27.000
고객에게 보여주기 위한 법적 동의가 있다면, 결제 시트를 제시하기 전에 고객에게 보여주는 것을 의미할 수 있습니다.

00:14:27.000 --> 00:14:32.000
단일 거래에서 한 가지 유형의 자동 결제만 요청할 수 있습니다.

00:14:32.000 --> 00:14:37.000
또한, 자동 결제는 다중 상인 결제와 함께 사용할 수 없습니다.

00:14:37.000 --> 00:14:52.000
마지막으로, 결제를 위해 발행된 Apple Pay 판매자 토큰에 대한 수명 주기 알림을 받으려면, 토큰 알림 URL을 제공하고 서버에서 Apple Pay 판매자 토큰 관리 API를 채택해야 합니다.

00:14:52.000 --> 00:14:57.000
우리는 당신이 이 새로운 API와 Apple Pay 상인 토큰의 이점을 좋아할 것이라고 생각합니다.

00:14:57.000 --> 00:15:03.000
여기 자동 결제에 대한 지원을 채택할 파트너 중 몇 명만 있습니다.

00:15:03.000 --> 00:15:14.000
Apple Pay 가맹점 토큰은 American Express, Discover, Mastercard 및 Visa에서 지원되며 향후 다른 결제 네트워크를 지원합니다.

00:15:14.000 --> 00:15:20.000
우리는 구매 후 경험을 향상시키기 위해 주문 추적을 소개하게 되어 기쁩니다.

00:15:20.000 --> 00:15:26.000
iOS 16의 새로운 기능, 주문 추적을 통해 사용자는 참여 상인과의 주문을 추적할 수 있습니다.

00:15:26.000 --> 00:15:34.000
지갑은 이제 활성 주문, 최근 완료된 주문 및 과거 주문에 대한 직관적인 개요를 제공합니다.

00:15:34.000 --> 00:15:38.000
나는 현재 몇몇 베이커리 상품에 대한 단일 활성 주문이 있다.

00:15:38.000 --> 00:15:42.000
내 주문은 아직 처리 중이야; 나중에 다시 연락할게.

00:15:42.000 --> 00:15:47.000
지금은 펫 애비뉴에서 고양이를 위한 장난감과 액세서리를 사고 싶어요.

00:15:47.000 --> 00:15:50.000
나는 Apple Pay로 체크아웃하기로 선택했다.

00:15:50.000 --> 00:15:55.000
결제를 승인한 직후, 지갑에서 주문을 추적하라는 알림을 받습니다.

00:15:55.000 --> 00:16:02.000
그 알림과 상호 작용하면 현재 상태를 확인할 수 있는 주문의 세부 사항으로 이동합니다.

00:16:02.000 --> 00:16:09.000
배송 및 추적 정보를 포함한 주문 상태와 제가 주문한 품목 목록을 볼 수 있습니다.

00:16:09.000 --> 00:16:18.000
아래에서, Pet Avenue에 연락하고, 결제 정보를 확인하고, Pet Avenue의 앱으로 돌아갈 수 있는 여러 옵션이 있습니다.

00:16:18.000 --> 00:16:25.000
이제, 펫 애비뉴가 들어오는 주문을 처리하는 데 정말 빠르다고 상상해 보세요. 그리고 그들은 방금 내 물건을 배송했습니다.

00:16:25.000 --> 00:16:30.000
펫 애비뉴가 내 주문을 배송하자마자, 그들은 사용 가능한 정보를 업데이트했다.

00:16:30.000 --> 00:16:36.000
예상 배송일이 6월 10일인 "On the Way"로 상태가 변경된 것을 볼 수 있습니다.

00:16:36.000 --> 00:16:41.000
그들은 또한 선적에 대한 사용자 지정 메시지와 추적 정보를 포함했다.

00:16:41.000 --> 00:16:43.000
오, 내 베이킹 제품 기억나?

00:16:43.000 --> 00:16:46.000
나는 방금 그들이 픽업할 준비가 되었다는 알림을 받았다.

00:16:46.000 --> 00:16:48.000
확인해 보자.

00:16:48.000 --> 00:16:50.000
나는 픽업을 위해 베이커리 상품을 주문했다.

00:16:50.000 --> 00:16:52.000
그들은 픽업할 준비가 됐어, 잘됐다!

00:16:52.000 --> 00:16:59.000
Bake My Breath Away는 픽업 창구, 픽업 지침 및 도착 시 제시할 바코드를 제공했습니다.

00:16:59.000 --> 00:17:03.000
우리는 주문 추적이 Apple Pay와 원활하게 작동하는 것을 보았다.

00:17:03.000 --> 00:17:08.000
주문 추적을 고객 경험에 어떻게 통합할 수 있는지 살펴봅시다.

00:17:08.000 --> 00:17:15.000
주문 추적을 시작하려면, 먼저 개발자 계정에 주문 유형 ID를 만들어야 합니다.

00:17:15.000 --> 00:17:22.000
주문 유형 ID는 조직을 주문 정보를 제공하는 법인으로 식별합니다.

00:17:22.000 --> 00:17:29.000
예를 들어, 여러 상인을 대신하여 주문 정보를 제공하기 위해 여러 주문 유형 ID를 등록할 수 있습니다.

00:17:29.000 --> 00:17:32.000
또한 주문 유형 ID 인증서를 만드세요.

00:17:32.000 --> 00:17:38.000
인증서를 사용하여 주문 패키지를 만들고 주문을 업데이트할 것입니다.

00:17:38.000 --> 00:17:41.000
주문은 주문 패키지로 배포됩니다.

00:17:41.000 --> 00:17:46.000
주문 패키지에는 주문에 대한 모든 메타데이터와 정보가 포함되어 있습니다.

00:17:46.000 --> 00:17:53.000
그것은 배송, 픽업 및 다중 이행 주문을 포함한 광범위한 시나리오를 나타낼 수 있다.

00:17:53.000 --> 00:17:58.000
주문 패키지에는 로고와 품목 이미지와 같은 이미지도 포함되어 있습니다.

00:17:58.000 --> 00:18:03.000
또한 다양한 고객을 지원하기 위해 현지화를 추가할 수 있습니다.

00:18:03.000 --> 00:18:08.000
모든 주문 패키지는 출처를 확인하기 위해 암호화 서명되어야 합니다.

00:18:08.000 --> 00:18:14.000
모든 것이 준비되면, 주문 패키지는 배포를 위해 압축됩니다.

00:18:14.000 --> 00:18:17.000
이 세션에 첨부된 샘플 주문 패키지를 확인하세요.

00:18:17.000 --> 00:18:22.000
그리고 주문 패키지에 대한 자세한 내용은 개발자 문서를 참조하십시오.

00:18:22.000 --> 00:18:25.000
지갑에 주문을 추가하는 것은 Apple Pay와 원활하게 작동합니다.

00:18:25.000 --> 00:18:34.000
고객이 결제를 승인하면, 앱이나 웹 페이지는 결제 정보를 받은 다음 처리를 위해 서버로 보냅니다.

00:18:34.000 --> 00:18:41.000
결제 정보 처리가 성공하면, 서버는 주문과 일부 메타데이터를 생성합니다.

00:18:41.000 --> 00:18:47.000
그런 다음 서버는 그 주문에 대한 세부 정보를 앱이나 웹 페이지로 반환하여 결과에 포함합니다.

00:18:47.000 --> 00:18:53.000
주문 세부 사항을 통해 장치는 서버에서 비동기적으로 주문을 요청할 수 있습니다.

00:18:53.000 --> 00:18:57.000
그런 다음 서버는 주문 패키지를 장치로 반환합니다.

00:18:57.000 --> 00:19:04.000
서버가 주문을 만들 때, 주문 유형 ID의 네임스페이스 내에서 고유한 주문 ID를 할당하십시오.

00:19:04.000 --> 00:19:08.000
당신의 서버는 또한 안전한 인증 토큰을 생성해야 합니다.

00:19:08.000 --> 00:19:12.000
이것은 주문 세부 사항의 일부인 공유된 비밀이다.

00:19:12.000 --> 00:19:17.000
장치는 주문을 요청할 때 토큰을 사용하여 스스로를 인증할 것이다.

00:19:17.000 --> 00:19:22.000
지불 승인 결과를 반환하기 위한 예를 살펴봅시다.

00:19:22.000 --> 00:19:29.000
고객이 결제를 승인하면, 앱은 결제 정보를 서버로 보내고 주문을 생성하도록 요청합니다.

00:19:29.000 --> 00:19:36.000
서버 결과가 성공을 나타내는지 확인하고 서버에서 반환한 오류를 처리하십시오.

00:19:36.000 --> 00:19:44.000
서버 결과가 성공을 나타내는 경우, 적절한 승인 결과로 결제를 완료하십시오.

00:19:44.000 --> 00:19:51.000
주문 세부 사항과 함께 지불 승인 결과를 반환하려면, 먼저 서버 결과에서 추출하십시오.

00:19:51.000 --> 00:20:03.000
그런 다음 Order Ttype ID, Order ID, 서버 URL 및 authenticationToken으로 PKPaymentOrderDetails 객체를 만드세요.

00:20:03.000 --> 00:20:12.000
PKPaymentOrderDetails 객체를 PKPaymentAuthorizationResult의 새 orderDetails 속성에 할당하십시오.

00:20:12.000 --> 00:20:13.000
그게 다야!

00:20:13.000 --> 00:20:17.000
웹에서도 주문 세부 사항으로 결제를 완료할 수 있습니다.

00:20:17.000 --> 00:20:22.000
이전과 마찬가지로, 서버 결과에서 주문 세부 사항을 추출하세요.

00:20:22.000 --> 00:20:27.000
그런 다음 결제를 완료한 데이터에 주문 세부 사항을 포함하세요.

00:20:27.000 --> 00:20:34.000
주문을 업데이트하려면, 자동 업데이트 지원을 나타내는 주문 패키지를 만드세요.

00:20:34.000 --> 00:20:38.000
주문이 추가되면, 장치는 업데이트를 위해 등록될 것이다.

00:20:38.000 --> 00:20:42.000
당신의 서버는 등록에 대한 정보를 저장해야 합니다.

00:20:42.000 --> 00:20:52.000
나중에, 서버가 주문을 업데이트할 때, 등록 정보를 사용하여 업데이트를 위해 등록한 장치에 알리십시오.

00:20:52.000 --> 00:20:58.000
장치가 푸시 알림을 받으면, 서버에서 주문을 다시 요청할 것입니다.

00:20:58.000 --> 00:21:03.000
그런 다음 서버는 업데이트된 주문 패키지를 장치로 반환합니다.

00:21:03.000 --> 00:21:07.000
오직 당신의 고객과 당신만이 그들이 무엇을 주문했는지 알아야 합니다.

00:21:07.000 --> 00:21:10.000
우리는 프라이버시를 염두에 두고 주문 추적을 설계했습니다.

00:21:10.000 --> 00:21:15.000
주문 정보는 장치와 서버 간에 직접 교환됩니다.

00:21:15.000 --> 00:21:20.000
주문이 iCloud를 통해 동기화되면, 종단간 암호화됩니다.

00:21:20.000 --> 00:21:24.000
가능한 최고의 고객 경험을 제공하기 위해 이러한 관행을 따르세요.

00:21:24.000 --> 00:21:27.000
당신의 앱을 당신이 제공하는 주문과 연결하세요.

00:21:27.000 --> 00:21:34.000
앱이 알림을 전달하고 설치된 경우, 주문 추적 알림을 비활성화할 수 있습니다.

00:21:34.000 --> 00:21:37.000
이것은 중복 알림을 방지하는 데 도움이 된다.

00:21:37.000 --> 00:21:44.000
관련 현지화만 제공하기 위해 고객 선호도에 대한 지식을 사용하세요.

00:21:44.000 --> 00:21:46.000
주문 패키지 크기에 유의하세요.

00:21:46.000 --> 00:21:51.000
비싼 네트워킹 비용을 줄이기 위해 크기를 작게 유지하세요.

00:21:51.000 --> 00:21:56.000
주문을 업데이트할 때, 업데이트를 위해 등록된 장치에 즉시 알리십시오.

00:21:56.000 --> 00:22:00.000
지갑의 주문은 주문의 실제 상태와 일치해야 합니다.

00:22:00.000 --> 00:22:05.000
주문 추적을 위해 HIG도 꼭 확인하세요.

00:22:05.000 --> 00:22:09.000
플랫폼은 주문 추적의 통합을 훨씬 간단하게 만들 수 있습니다.

00:22:09.000 --> 00:22:15.000
우리는 Shopify, Narvar 및 Route가 가을까지 주문 추적을 지원할 것이라고 발표하게 되어 기쁩니다.

00:22:15.000 --> 00:22:19.000
앞으로 몇 달 안에 주문 추적을 지원하는 더 많은 플랫폼을 찾아보세요.

00:22:19.000 --> 00:22:24.000
주문 추적은 고객의 구매 후 경험을 향상시킬 수 있는 좋은 방법입니다.

00:22:24.000 --> 00:22:31.000
자동 업데이트를 통해, 당신의 고객들은 항상 주문 상태에 대한 최신 정보를 제공할 것입니다.

00:22:31.000 --> 00:22:36.000
우리는 당신의 고객들이 이 경험을 좋아할 것이라고 믿으며 곧 당신과 함께 주문하기를 기대합니다!

00:22:36.000 --> 00:22:39.000
이제, 나는 데이비드에게 넘어갈 거야.

00:22:39.000 --> 00:22:41.000
데이비드: 고마워, 라이스!

00:22:41.000 --> 00:22:48.000
iOS 16에서 지갑의 ID에 추가한 새로운 기능에 대해 이야기하게 되어 매우 기쁩니다.

00:22:48.000 --> 00:22:52.000
우리는 올해 초 iOS 15.4에서 지갑에 ID를 출시했습니다.

00:22:52.000 --> 00:22:58.000
지원되는 미국 주의 사용자는 운전면허증이나 주 ID를 지갑에 추가할 수 있습니다.

00:22:58.000 --> 00:23:04.000
지갑의 ID는 사용자의 실제 ID와 동일한 발급 기관에서 발급됩니다.

00:23:04.000 --> 00:23:10.000
미국에서, 그것은 그들의 주 자동차 부서 또는 이와 동등한 조직이다.

00:23:10.000 --> 00:23:21.000
iOS 16에서는 앱과 앱 클립이 사용자의 연령이나 신원을 확인하기 위해 지갑의 ID에서 정보를 요청할 수 있는 새로운 API를 추가했습니다.

00:23:21.000 --> 00:23:32.000
앱은 정보를 요청하고, 사용자는 요청을 검토하고 승인한 다음, 앱은 암호 해독 및 확인을 위해 서버에 응답을 보냅니다.

00:23:32.000 --> 00:23:35.000
사용자 ID에서 여러 데이터 요소를 요청할 수 있습니다.

00:23:35.000 --> 00:23:54.000
여기에는 이름, 주소, 생년월일, 초상화로 알려진 사진, 신분증을 발급한 발급 기관, 실제 신분증의 번호 및 만료일, 신분증으로 부여된 운전 특권이 포함됩니다.

00:23:54.000 --> 00:23:58.000
신분증의 매우 일반적인 사용 사례는 누군가의 나이를 확인하는 것이다.

00:23:58.000 --> 00:24:02.000
물리적 신분증으로, 그것은 그들의 생년월일을 보는 것을 의미한다.

00:24:02.000 --> 00:24:08.000
하지만 생년월일은 나이를 확인하는 데 필요한 것보다 훨씬 더 많은 정보를 보여준다.

00:24:08.000 --> 00:24:14.000
만약 당신이 내 나이를 확인한다면, 당신은 실제로 내가 태어난 정확한 날짜나 연도, 심지어 내가 몇 살인지 알 필요가 없습니다.

00:24:14.000 --> 00:24:17.000
넌 그냥 내가 충분히 늙었는지 알아야 해.

00:24:17.000 --> 00:24:21.000
지갑에 있는 ID로, 당신은 그 질문을 직접 할 수 있습니다.

00:24:21.000 --> 00:24:33.000
앱은 사용자가 특정 연령 이상인지 여부를 나타내는 부울 데이터 요소를 요청할 수 있으며, 전체 생년월일을 확인하는 것보다 연령 확인을 위한 개인 정보 보호 방법을 제공합니다.

00:24:33.000 --> 00:24:39.000
앱이 API를 호출하면, 시트는 사용자가 요청하는 정보를 보여줍니다.

00:24:39.000 --> 00:24:44.000
그것은 또한 당신이 그 정보를 저장할 것인지, 그리고 얼마나 오랫동안 저장할 것인지를 보여줄 것입니다.

00:24:44.000 --> 00:24:49.000
이를 통해 사용자는 앱과 정보를 공유할지 여부에 대해 정보에 입각한 결정을 내릴 수 있습니다.

00:24:49.000 --> 00:24:56.000
Face ID 또는 Touch ID를 사용하여 명시적으로 승인할 때까지 어떠한 정보도 공유되지 않습니다.

00:24:56.000 --> 00:25:00.000
당신이 받은 응답에는 당신이 요청한 요소만 포함되어 있습니다.

00:25:00.000 --> 00:25:07.000
실제 신분증 스캔과 같은 다른 신원 확인 메커니즘은 신분증에 있는 모든 것을 공유합니다.

00:25:07.000 --> 00:25:18.000
공유를 필요한 것으로 제한함으로써, 지갑의 ID는 사용자를 위해 더 많은 개인 정보를 보존하고 서버에서 보안을 유지하는 데 필요한 민감한 정보의 양을 줄입니다.

00:25:18.000 --> 00:25:26.000
응답은 ID 발급 기관에 의해 서명되므로 응답의 정보가 진짜인지 쉽게 확인할 수 있습니다.

00:25:26.000 --> 00:25:32.000
발급 기관은 ID를 생성하지만 API를 호출할 때 관여하지 않는다는 점에 유의하십시오.

00:25:32.000 --> 00:25:39.000
그들은 사용자가 자신의 정보를 공유하거나 누구와 공유할지 배우지 않는다.

00:25:39.000 --> 00:25:44.000
API를 사용하려면, 개발자 계정을 통해 자격을 요청해야 합니다.

00:25:44.000 --> 00:25:48.000
그런 다음 판매자 ID와 암호화 인증서를 설정해야 합니다.

00:25:48.000 --> 00:25:53.000
이 과정은 Apple Pay로 인앱 결제를 설정하는 것과 매우 유사합니다.

00:25:53.000 --> 00:25:58.000
우리는 신분증과 인증서를 사용하는 방법에 대해 조금 더 이야기할 것이다.

00:25:58.000 --> 00:26:01.000
지금은 검증 흐름에 대해 이야기해 봅시다.

00:26:01.000 --> 00:26:04.000
높은 수준에서, 그것은 네 단계로 구성되어 있다.

00:26:04.000 --> 00:26:11.000
먼저, 앱은 PassKit 프레임워크에서 API를 호출하고 요청하는 정보를 지정합니다.

00:26:11.000 --> 00:26:16.000
그런 다음 시스템은 사용자에게 요청을 승인하라는 시트를 표시할 것이다.

00:26:16.000 --> 00:26:21.000
일단 그들이 그렇게 하면, 당신의 앱은 암호화된 응답을 받게 될 것입니다.

00:26:21.000 --> 00:26:27.000
그런 다음 앱은 암호 해독 및 확인을 위해 해당 응답을 서버에 전달합니다.

00:26:27.000 --> 00:26:32.000
먼저, PassKit에서 API를 사용하는 방법에 대해 이야기해 봅시다.

00:26:32.000 --> 00:26:37.000
앱이 SwiftUI를 사용하는 경우, VerifyIdentityWithWalletButton SwiftUI 보기를 사용해야 합니다.

00:26:37.000 --> 00:26:43.000
이것은 누를 때 신원 확인 흐름을 트리거하는 버튼을 표시합니다.

00:26:43.000 --> 00:26:54.000
Apple Pay로 결제 및 지갑에 패스 추가 버튼과 마찬가지로, 지갑으로 신원 확인 버튼은 API를 사용하는 앱 전반에 걸쳐 친숙하고 일관된 경험을 제공합니다.

00:26:54.000 --> 00:26:58.000
네 개의 다른 라벨 중에서 선택하여 사용 사례에 맞는 버튼을 표시할 수 있습니다.

00:26:58.000 --> 00:27:05.000
사용 가능한 공간에 따라 단일 및 다중 라인 버전 간에 자동으로 전환됩니다.

00:27:05.000 --> 00:27:15.000
버튼을 만들 때, 요청하려는 정보와 반환 방법을 설명하는 PKIdentityRequest 객체를 지정해야 합니다.

00:27:15.000 --> 00:27:18.000
그것을 만드는 방법을 살펴봅시다.

00:27:18.000 --> 00:27:26.000
찾고 있는 데이터 요소를 설명하는 PKIdentityDrivers LicenseDescriptor를 만드는 것으로 시작합니다.

00:27:26.000 --> 00:27:32.000
addElements 메소드를 사용하여 요청하려는 요소를 저장할지 여부와 함께 지정하십시오.

00:27:32.000 --> 00:27:39.000
addElements 메소드를 여러 번 호출하여 저장할 의도가 다른 요소 세트를 지정할 수 있습니다.

00:27:39.000 --> 00:27:42.000
이 예에서, 나는 그것을 두 번 부르고 있다.

00:27:42.000 --> 00:27:48.000
먼저, 나는 나이(최소: 저장되지 않을 요소)를 추가한다.

00:27:48.000 --> 00:27:58.000
그런 다음, addElements 메소드를 다시 호출하여 사용자의 주어진 이름, 가족 이름 및 초상화를 요청하며, 모두 최대 30일 동안 저장할 수 있습니다.

00:27:58.000 --> 00:28:03.000
그런 다음 설명자는 PKIdentityRequest로 들어간다.

00:28:03.000 --> 00:28:07.000
다음 단계는 사용할 merchantIdentifier를 지정하는 것이다.

00:28:07.000 --> 00:28:13.000
merchantIdentifier는 API 응답이 암호화될 암호화 인증서를 나타냅니다.

00:28:13.000 --> 00:28:19.000
개발자 계정을 통해 merchantIdentifier와 암호화 인증서를 모두 구성할 수 있습니다.

00:28:19.000 --> 00:28:25.000
마지막으로, API에서 받은 응답과 연결된 nonce를 지정해야 합니다.

00:28:25.000 --> 00:28:32.000
응답의 재생을 방지하고 특정 사용자 세션에 바인딩하는 데 사용되는 중요한 보안 기능입니다.

00:28:32.000 --> 00:28:37.000
정확히 당신이 nonce를 어떻게 관리하는지는 당신 자신의 보안 요구 사항에 따라 당신에게 달려 있습니다.

00:28:37.000 --> 00:28:45.000
종종, 그것은 당신의 서버에서 나옵니다. 왜냐하면 나중에, 당신의 서버는 nonce가 유효하다는 것을 강요할 책임이 있기 때문입니다.

00:28:45.000 --> 00:28:50.000
이 모든 속성이 설정되면, PKIdentityRequest가 있습니다.

00:28:50.000 --> 00:28:52.000
이제, 버튼으로 돌아가자.

00:28:52.000 --> 00:29:02.000
신원 확인이 가능한 경우, 버튼이 앱에 표시되며, 탭하면 요청과 함께 신원 확인 흐름이 시작됩니다.

00:29:02.000 --> 00:29:08.000
신원 확인을 사용할 수 없는 경우, 지정한 대체 보기가 대신 표시됩니다.

00:29:08.000 --> 00:29:12.000
예를 들어, 이 아이폰의 지갑에 ID가 없다면 이런 일이 일어날 것이다.

00:29:12.000 --> 00:29:18.000
대체 보기를 사용하여 신원을 확인하는 다른 방법을 제공할 수 있습니다.

00:29:18.000 --> 00:29:22.000
신원 확인이 가능하다고 가정하고, 사용자가 버튼을 탭합니다.

00:29:22.000 --> 00:29:30.000
그런 다음 시스템은 당신이 요청한 요소와 그것들을 저장하려는 의도를 포함하여 당신의 요청이 포함된 시트를 보여줄 것입니다.

00:29:30.000 --> 00:29:37.000
사용자는 Face ID 또는 Touch ID로 요청을 승인하거나 승인하지 않고 시트를 닫을 수 있습니다.

00:29:37.000 --> 00:29:42.000
그러면 당신의 코드는 요청의 결과가 포함된 결과 객체를 받게 될 것입니다.

00:29:42.000 --> 00:29:46.000
요청이 승인되면, 성공적인 결과를 받게 될 것입니다.

00:29:46.000 --> 00:29:56.000
이것은 앱이 암호 해독 및 확인을 위해 서버로 보낼 암호화된 응답을 포함하는 PKIdentityDocument 객체와 함께 제공됩니다.

00:29:56.000 --> 00:30:00.000
요청이 성공하지 못하면, 실패 결과를 받게 될 것입니다.

00:30:00.000 --> 00:30:07.000
실패의 가장 흔한 원인은 요청이 승인되지 않았다는 것이며, 이 경우 취소된 오류를 받게 될 것입니다.

00:30:07.000 --> 00:30:12.000
그것은 API의 SwiftUI 버전인 VerifyIdentityWithWalletButton이었다.

00:30:12.000 --> 00:30:19.000
그것을 사용하여 신원 확인 흐름을 시작하고 지갑의 ID에서 정보를 요청하는 버튼을 표시하세요.

00:30:19.000 --> 00:30:31.000
앱에서 SwiftUI를 사용하지 않는 경우, PKIdentityButton 및 PKIdentityAuthorization Controller 클래스를 사용하여 동일한 작업을 수행할 수도 있습니다.

00:30:31.000 --> 00:30:40.000
좋아요, 이제 당신은 정보를 요청했고, 사용자는 요청을 승인했고, 앱은 암호화된 응답을 서버로 보냈습니다.

00:30:40.000 --> 00:30:46.000
이제, 당신의 서버가 그 응답을 해독하고 확인하기 위해 무엇을 해야 하는지에 대해 이야기해 봅시다.

00:30:46.000 --> 00:30:53.000
저는 이 주제에 대한 표면만 훑어볼 것이므로, 자세한 내용은 개발자 문서를 확인하세요.

00:30:53.000 --> 00:31:01.000
응답 형식은 여러 국제 표준을 사용하므로, 그것들에 익숙해지는 것이 좋습니다.

00:31:01.000 --> 00:31:06.000
당신이 받게 될 응답 데이터는 CBOR로 인코딩된 암호화 봉투에 있습니다.

00:31:06.000 --> 00:31:10.000
CBOR는 RFC 8949에 정의된 데이터 형식이다.

00:31:10.000 --> 00:31:14.000
JSON과 비슷하지만 이진 데이터를 사용하여 객체를 인코딩합니다.

00:31:14.000 --> 00:31:21.000
암호화 봉투에는 암호화된 데이터 자체와 함께 암호 해독 프로세스에 필요한 메타데이터가 포함되어 있습니다.

00:31:21.000 --> 00:31:28.000
데이터는 RFC 9180에 정의된 암호화 체계인 HPKE를 사용하여 암호화됩니다.

00:31:28.000 --> 00:31:32.000
당신의 서버는 개인 키를 사용하여 이 데이터를 해독할 것입니다.

00:31:32.000 --> 00:31:35.000
일단 해독되면, 당신은 mdoc 응답 객체를 받게 될 것입니다.

00:31:35.000 --> 00:31:44.000
Mdoc 응답은 모바일 운전면허증 및 주 ID에 대한 ISO 표준인 ISO 18013 파트 5에 정의되어 있습니다.

00:31:44.000 --> 00:31:48.000
Mdoc 응답 객체는 당신이 요청한 데이터 요소를 포함합니다.

00:31:48.000 --> 00:31:55.000
또한 응답이 진짜인지 확인하기 위해 서버가 검증해야 하는 많은 보안 기능이 포함되어 있습니다.

00:31:55.000 --> 00:31:59.000
서버가 암호 해독과 검증 자체를 수행할 것이라는 점에 유의하십시오.

00:31:59.000 --> 00:32:04.000
애플 서버나 발행 기관의 서버는 관련이 없다.

00:32:04.000 --> 00:32:09.000
암호 해독과 응답 검증에 대해 이야기하기 전에, 우리는 세션 기록에 대해 이야기해야 한다.

00:32:09.000 --> 00:32:16.000
이것은 응답 페이로드를 특정 앱의 특정 요청에 바인딩하는 CBOR 구조입니다.

00:32:16.000 --> 00:32:23.000
당신의 서버는 이 구조를 구축하고 암호 해독과 유효성 검사 중에 사용해야 할 것입니다.

00:32:23.000 --> 00:32:37.000
세션 기록에는 PKIdentityRequest에서 이전에 사용한 것과 동일한 nonce 및 판매자 ID와 개발자 팀의 팀 ID 및 암호화 인증서 공개 키의 SHA256 해시가 포함되어 있습니다.

00:32:37.000 --> 00:32:43.000
세션 기록을 작성할 때, 서버는 사용 중인 입력이 모두 유효한지 확인해야 합니다.

00:32:43.000 --> 00:32:47.000
그것은 nonce가 이미 사용되어서는 안 되었으며, 현재 사용자와 연결되어야 한다는 것을 의미합니다.

00:32:47.000 --> 00:32:52.000
다른 값은 개발자 계정에서 예상되는 것과 일치해야 합니다.

00:32:52.000 --> 00:32:55.000
이제 암호화된 데이터를 해독하는 것에 대해 이야기해 봅시다.

00:32:55.000 --> 00:33:01.000
암호화 봉투의 메타데이터와 함께 방금 만든 세션 성적표가 필요합니다.

00:33:01.000 --> 00:33:03.000
개인 키도 필요할 거야.

00:33:03.000 --> 00:33:09.000
이것은 개발자 계정에서 이전에 설정한 인증서에 해당하는 개인 키입니다.

00:33:09.000 --> 00:33:15.000
사용자 정보의 기밀성을 보호하려면, 개인 키가 비공개로 유지되도록 해야 합니다.

00:33:15.000 --> 00:33:19.000
서버에 안전하게 저장하고 앱에 절대 포함하지 마세요.

00:33:19.000 --> 00:33:25.000
개인 키가 손상된 경우, 개발자 계정의 인증서를 즉시 취소하십시오.

00:33:25.000 --> 00:33:34.000
암호화된 데이터를 해독한 후, 두 개의 암호화 서명과 요청한 데이터 요소가 포함된 mdoc 응답 객체를 받게 됩니다.

00:33:34.000 --> 00:33:39.000
데이터 요소를 사용하기 전에 mdoc 응답에서 두 서명을 모두 확인해야 합니다.

00:33:39.000 --> 00:33:42.000
먼저, 발행인 서명을 확인해야 합니다.

00:33:42.000 --> 00:33:46.000
이것은 사용자 ID 발급 기관의 서명입니다.

00:33:46.000 --> 00:33:54.000
이 서명을 확인함으로써, 당신은 응답의 데이터가 실제 발행 기관에서 왔고 변조되지 않았는지 확인하는 것입니다.

00:33:54.000 --> 00:34:01.000
서명이 유효할 뿐만 아니라 신뢰할 수 있는 발급자 인증서에 의해 서명되었는지 확인해야 합니다.

00:34:01.000 --> 00:34:07.000
지갑의 ID에 사용되는 발급자 인증서에 대한 자세한 내용은 문서를 살펴보세요.

00:34:07.000 --> 00:34:11.000
다음으로, 장치 서명을 확인해야 합니다.

00:34:11.000 --> 00:34:15.000
이것은 사용자 iPhone의 보안 요소의 키로 생성된 서명입니다.

00:34:15.000 --> 00:34:22.000
그것은 당신이 받은 응답이 발급 기관이 원래 ID를 발급한 것과 동일한 iPhone에서 왔다는 것을 증명합니다.

00:34:22.000 --> 00:34:29.000
여기서, 당신은 발행인 서명이 다루는 몇 가지 정보와 함께 세션 성적표를 다시 사용해야 합니다.

00:34:29.000 --> 00:34:33.000
마지막으로, 요청한 데이터 요소를 사용할 준비가 되었습니다.

00:34:33.000 --> 00:34:44.000
먼저 발행인과 장치 서명을 확인하지 않고는 이러한 요소를 사용해서는 안 됩니다. 그렇지 않으면 받은 데이터가 진짜인지 알 수 없기 때문입니다.

00:34:44.000 --> 00:34:46.000
그리고 그 모든 단계가 완료되면, 당신은 끝났습니다!

00:34:46.000 --> 00:34:52.000
당신의 앱은 정보를 요청했고, 당신의 서버는 응답을 해독하고 확인했습니다.

00:34:52.000 --> 00:34:57.000
지갑에 ID가 없다면 구현을 테스트하는 방법이 궁금할 수도 있습니다.

00:34:57.000 --> 00:35:01.000
우리는 당신이 그것을 할 수 있도록 몇 가지 메커니즘을 제공했습니다.

00:35:01.000 --> 00:35:07.000
먼저, API가 모의 응답을 반환하는 iOS 시뮬레이터에서 테스트할 수 있습니다.

00:35:07.000 --> 00:35:12.000
이 반응은 실제 반응과 비슷하지만, 실제 서명이 부족하다.

00:35:12.000 --> 00:35:21.000
마찬가지로, iPhone의 지갑에 ID가 없더라도 테스트 프로필을 사용하여 실제 iPhone에서 모의 응답을 받을 수 있습니다.

00:35:21.000 --> 00:35:24.000
이것을 하는 방법에 대한 자세한 내용은 문서를 참조하십시오.

00:35:24.000 --> 00:35:30.000
당신의 서버는 이러한 모의 응답 중 어느 것도 실제 응답처럼 취급해서는 안 된다는 점에 유의하십시오.

00:35:30.000 --> 00:35:41.000
서버 구현을 돕기 위해, 문서에는 암호 해독하고 검증하는 데 필요한 모든 것과 함께 예제 응답도 포함되어 있습니다.

00:35:41.000 --> 00:35:47.000
그리고 그것이 iOS 16의 지갑에서 ID로 신원 확인을 수행할 수 있는 방법입니다.

00:35:47.000 --> 00:35:54.000
앱에서 API를 사용하는 방법, 서버에서 응답을 처리하는 방법, 구현을 테스트하는 방법에 대해 논의했습니다.

00:35:54.000 --> 00:35:59.000
Lais: 올해, 우리는 지갑과 Apple Pay에 많은 훌륭한 새로운 기능을 도입했습니다.

00:35:59.000 --> 00:36:07.000
여기에는 다중 상인 결제, 자동 결제에 대한 향상된 지원, 주문 추적 및 신원 확인이 포함됩니다.

00:36:07.000 --> 00:36:10.000
자세한 내용은 개발자 문서를 확인하세요.

00:36:10.000 --> 00:36:14.000
데이비드: 봐줘서 고마워, 그리고 멋진 WWDC 보내!

00:36:14.000 --> 23:59:59.000
♪

