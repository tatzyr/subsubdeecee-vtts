WEBVTT

00:00:02.000 --> 00:00:14.000
Xin chào, tôi là Jacob, và chào mừng đến với "Thêm đồ họa phong phú vào ứng dụng SwiftUI của bạn."

00:00:14.000 --> 00:00:18.000
Tôi đang làm việc trên một ứng dụng để xây dựng gradient với một vài đồng nghiệp của mình.

00:00:18.000 --> 00:00:21.000
Năm nay, màu sắc là thứ nóng bỏng trong đội của chúng tôi.

00:00:21.000 --> 00:00:24.000
Hầu hết việc triển khai đã được thực hiện.

00:00:24.000 --> 00:00:27.000
Bây giờ tôi chỉ cần hoàn thành nó bằng cách thêm một số đồ họa phong phú.

00:00:27.000 --> 00:00:42.000
Khi chúng tôi tùy chỉnh ứng dụng, chúng tôi sẽ thấy một vài khu vực khác nhau: làm việc với khu vực an toàn, bao gồm tùy chỉnh nó; hỗ trợ phong cách tiền cảnh mới; một bộ vật liệu mới phong phú; và vẽ bằng Canvas, một chế độ xem mới mạnh mẽ.

00:00:42.000 --> 00:00:44.000
Vậy hãy bắt đầu nào.

00:00:44.000 --> 00:00:47.000
Tôi sẽ cho bạn thấy những gì có trong ứng dụng cho đến nay.

00:00:47.000 --> 00:00:51.000
Chúng tôi có một thư viện các gradient, và tôi có thể xem các gradient đó.

00:00:51.000 --> 00:00:53.000
Có điều gì đó về cái này mà tôi thực sự thích.

00:00:53.000 --> 00:00:55.000
Tôi chỉ không thể đặt ngón tay của mình lên nó.

00:00:55.000 --> 00:00:58.000
Tôi cũng có thể chỉnh sửa một gradient...

00:00:58.000 --> 00:01:06.000
Điều đó cho phép tôi thay đổi màu sắc dừng lại.

00:01:06.000 --> 00:01:10.000
Và tôi có thể thêm một gradient mới.

00:01:10.000 --> 00:01:14.000
Tôi cũng có thể sử dụng các gradient này trong một số trình hiển thị...

00:01:14.000 --> 00:01:18.000
Nhưng từng bước một. Chúng ta sẽ xem xét chúng một lát sau.

00:01:18.000 --> 00:01:22.000
Hiện tại, hãy tập trung vào chế độ xem chi tiết gradient này.

00:01:22.000 --> 00:01:28.000
Nó có chức năng, nhưng nội dung thực tế của chúng tôi khá nhỏ so với chrome và không gian trống.

00:01:28.000 --> 00:01:31.000
Tôi muốn độ dốc thực sự chiếm lĩnh màn hình này.

00:01:31.000 --> 00:01:35.000
Vậy hãy bắt đầu chỉnh sửa nó trong Xcode.

00:01:35.000 --> 00:01:40.000
Đây là chế độ xem chi tiết chính của chúng tôi và nó cũng được sử dụng cho chế độ chỉnh sửa của chúng tôi.

00:01:40.000 --> 00:01:44.000
Hãy bắt đầu với isEditing false, và chúng ta sẽ xem xét chế độ chỉnh sửa sau.

00:01:44.000 --> 00:01:51.000
Hãy làm cho gradient của chúng ta sử dụng càng nhiều không gian càng tốt bằng cách xóa khung này.

00:01:51.000 --> 00:01:57.000
Và bây giờ độ dốc đang chiếm hết chiều cao, chúng ta không còn cần miếng đệm này nữa.

00:01:57.000 --> 00:02:04.000
Chúng ta có thể tiến xa hơn nữa bằng cách đặt các điều khiển của mình lên trên gradient này bằng cách thay đổi điều này thành ZStack.

00:02:04.000 --> 00:02:11.000
Nếu bạn chưa từng nhìn thấy ZStack trước đây, nó sẽ đặt các yếu tố chồng lên nhau thay vì cạnh nhau.

00:02:11.000 --> 00:02:18.000
Hãy di chuyển các điều khiển chỉnh sửa của chúng ta xuống dưới cùng.

00:02:18.000 --> 00:02:22.000
Và chúng ta chỉ cần đệm trên các điều khiển, không phải trên gradient của chúng ta...

00:02:22.000 --> 00:02:26.000
Vậy hãy di chuyển cái này.

00:02:26.000 --> 00:02:33.000
Bạn có thể tự hỏi tại sao vẫn còn khoảng trống ở trên cùng và dưới cùng của gradient, ngay cả sau khi chúng tôi đã loại bỏ phần đệm.

00:02:33.000 --> 00:02:43.000
Theo mặc định, SwiftUI định vị nội dung của bạn trong khu vực an toàn, tránh mọi thứ có thể che khuất hoặc cắt chế độ xem của bạn, như chỉ báo Trang chủ hoặc bất kỳ thanh nào đang được hiển thị.

00:02:43.000 --> 00:02:50.000
Khu vực an toàn được thể hiện dưới dạng khu vực được chèn vào từ khu vực đầy đủ ngoài cùng nơi hiển thị chế độ xem.

00:02:50.000 --> 00:02:57.000
Nội dung trong khu vực an toàn được tự động bố trí trong các nội dung thích hợp để tránh những khu vực mà nó sẽ bị che khuất.

00:02:57.000 --> 00:03:02.000
Khu vực an toàn cũng là cách SwiftUI giúp bạn tránh vẽ nội dung dưới bàn phím.

00:03:02.000 --> 00:03:07.000
Vì vậy, trong ứng dụng của chúng tôi, các điều khiển của chúng tôi sẽ tự động nhấc ra khỏi bàn phím.

00:03:07.000 --> 00:03:13.000
Điều này hoạt động theo cùng một cách, và nếu chúng ta xem xét kỹ hơn về cách thức, đó là bởi vì có nhiều khu vực an toàn khác nhau.

00:03:13.000 --> 00:03:21.000
Cái phổ biến nhất là khu vực an toàn container, được điều khiển bởi container, chế độ xem được hiển thị bên trong và bao gồm những thứ như thanh và thiết bị mạ crôm.

00:03:21.000 --> 00:03:25.000
Ngoài ra, có một khu vực an toàn cho bàn phím để tránh bàn phím.

00:03:25.000 --> 00:03:30.000
Và lưu ý rằng khu vực an toàn bàn phím luôn là khu vực trong khu vực an toàn thùng chứa.

00:03:30.000 --> 00:03:36.000
Nó giữ nội dung an toàn từ cùng khu vực với khu vực an toàn thùng chứa ngoài bàn phím.

00:03:36.000 --> 00:03:39.000
Có thể chọn không tham gia các khu vực an toàn.

00:03:39.000 --> 00:03:44.000
Thông thường bạn sẽ không cần phải làm điều này, vì hầu hết nội dung phải nằm trong khu vực an toàn để nó không bị cắt xén.

00:03:44.000 --> 00:03:46.000
Rốt cuộc thì nó an toàn.

00:03:46.000 --> 00:03:52.000
Nhưng bỏ qua khu vực an toàn có thể có ý nghĩa đối với hình nền hoặc nội dung khác mà bạn muốn đi hết cạnh này sang cạnh khác.

00:03:52.000 --> 00:04:01.000
Bạn có thể sử dụng mã này để chọn không tham gia tất cả các khu vực an toàn hoặc chỉ định khu vực bàn phím để chọn không tham gia khu vực an toàn bàn phím.

00:04:01.000 --> 00:04:09.000
Hãy thêm ignoresSafeArea vào gradient tuyến tính của chúng tôi để có được hiệu ứng chảy máu đầy đủ đó.

00:04:09.000 --> 00:04:19.000
Nút Chỉnh sửa này không hiển thị rõ trên đỉnh gradient của chúng tôi, vì vậy hãy bỏ qua khu vực an toàn ở cạnh dưới.

00:04:19.000 --> 00:04:31.000
Bây giờ, để đảm bảo rằng chúng ta không gặp phải vấn đề tương tự với văn bản dưới cùng này không đọc được từ gradient, hãy thêm một nền đằng sau nó.

00:04:31.000 --> 00:04:50.000
Chúng tôi sẽ tùy chỉnh nền trong một phút, nhưng hãy bắt đầu với mặc định đơn giản nhất, cho chúng tôi nền trắng tự động thay đổi trong Chế độ tối.

00:04:50.000 --> 00:04:54.000
Và nền này cũng tự động mở rộng ra ngoài khu vực an toàn.

00:04:54.000 --> 00:05:00.000
Phiên bản nền này và hành vi của nó là mới trong iOS 15 và các bản phát hành hệ điều hành phù hợp.

00:05:00.000 --> 00:05:01.000
Hãy xem nó hoạt động như thế nào.

00:05:01.000 --> 00:05:05.000
Hãy bắt đầu với chế độ xem container và khu vực an toàn của nó.

00:05:05.000 --> 00:05:11.000
Sau đó, chúng tôi có chế độ xem nội dung của mình, nó sẽ chỉ nằm trong khu vực an toàn để giữ cho nó dễ đọc.

00:05:11.000 --> 00:05:16.000
Nếu chúng ta ngây thơ thêm một nền có cùng giới hạn vào chế độ xem mà nó được áp dụng, chúng ta sẽ nhận được điều này.

00:05:16.000 --> 00:05:26.000
Nhưng nếu chúng ta áp dụng công cụ sửa đổi ignoresSafeArea chỉ cho chế độ xem nền, thì nó sẽ mở rộng ra ngoài khu vực an toàn trong khi vẫn giữ cho nội dung chính đẹp và an toàn.

00:05:26.000 --> 00:05:31.000
Công cụ sửa đổi nền mới tự động cung cấp cho bạn hành vi này.

00:05:31.000 --> 00:05:34.000
Hãy quay lại nền tảng của chúng ta và bắt đầu tùy chỉnh nó.

00:05:34.000 --> 00:05:42.000
Chúng ta có thể vượt qua một phong cách cụ thể, có thể là một màu hoặc bất kỳ phong cách nào khác, như một gradient.

00:05:42.000 --> 00:05:47.000
Nó không thực sự có ý nghĩa trong ứng dụng này, nhưng hãy nhìn vào thứ gì đó màu pastel.

00:05:47.000 --> 00:05:51.000
Tôi cũng có thể chuyển một hình dạng để cắt nền này để...

00:05:51.000 --> 00:05:58.000
Ví dụ, một hình chữ nhật tròn.

00:05:58.000 --> 00:06:05.000
Lưu ý rằng khi tôi sử dụng một hình dạng tùy chỉnh, nền không còn mở rộng ra khỏi khu vực an toàn để hình dạng phù hợp với giới hạn nội dung của bạn.

00:06:05.000 --> 00:06:09.000
Những gì tôi nghĩ sẽ phù hợp với ứng dụng của chúng tôi hơn là làm mờ nền của chúng tôi.

00:06:09.000 --> 00:06:13.000
Chúng ta có thể sử dụng một API mới khác để làm điều đó: Vật liệu.

00:06:13.000 --> 00:06:17.000
Vật liệu là một tập hợp các kiểu làm mờ tiêu chuẩn mà bạn có thể áp dụng.

00:06:17.000 --> 00:06:22.000
Và hãy làm cho nền này quay trở lại chiếm toàn bộ khu vực.

00:06:22.000 --> 00:06:27.000
Tài liệu rất tuyệt vời cho những nơi mà chúng tôi muốn hiển thị thông qua nội dung đầy màu sắc như thế này.

00:06:27.000 --> 00:06:32.000
Có một bộ vật liệu khác nhau mà bạn có thể lựa chọn, từ Siêu Mỏng đến Siêu Dày.

00:06:32.000 --> 00:06:38.000
Và tất cả những thứ này tự động hiển thị thiết kế phù hợp trên mọi nền tảng.

00:06:38.000 --> 00:06:41.000
Tôi sẽ sử dụng một vật liệu mỏng ở đây.

00:06:41.000 --> 00:06:43.000
Tiếp theo, tôi muốn tùy chỉnh văn bản của chúng tôi.

00:06:43.000 --> 00:06:51.000
Hãy làm cho số lượng màu ít nổi bật hơn một chút để cho thấy rằng tên là thông tin chính ở đây.

00:06:51.000 --> 00:06:58.000
Tôi có thể làm điều đó bằng cách thiết lập một phong cách tiền cảnh của thứ cấp.

00:06:58.000 --> 00:07:05.000
Bạn có thể nhận thấy rằng nội dung phụ được hiển thị tự động với một hiệu ứng gọi là Vibrancy, kết hợp màu sắc đằng sau nó.

00:07:05.000 --> 00:07:08.000
Trong SwiftUI, không có API bổ sung cho hiệu ứng này.

00:07:08.000 --> 00:07:14.000
Nó xảy ra tự động khi bạn sử dụng các kiểu Trung học thông qua Đệ tứ mới trong bối cảnh vật chất.

00:07:14.000 --> 00:07:24.000
Điều đó có thể xảy ra khi bạn thêm rõ ràng một nền với một tài liệu, như chúng tôi vừa làm, hoặc khi nội dung của bạn nằm trong một thành phần hệ thống, như thanh bên, thêm tài liệu cho bạn.

00:07:24.000 --> 00:07:27.000
Và những phong cách này có rất nhiều thông minh tự động.

00:07:27.000 --> 00:07:34.000
Chúng cũng tự động làm điều đúng đắn khi được sử dụng trong bối cảnh không bị mờ, nơi chúng không sử dụng hiệu ứng sống động.

00:07:34.000 --> 00:07:40.000
Chúng cũng tự động thay đổi hành vi của chúng khi bạn đặt màu lên chúng, đặt các phiên bản màu cho từng cấp độ.

00:07:40.000 --> 00:07:45.000
Và hỗ trợ tương tự hoạt động để thiết lập bất kỳ kiểu tiền cảnh cơ bản nào, ngay cả những thứ như độ dốc.

00:07:45.000 --> 00:07:47.000
Vui lòng sử dụng một cách trang nhã.

00:07:47.000 --> 00:07:54.000
Một điều cần lưu ý: Bất kỳ văn bản nhất định nào cũng có thể có một kiểu tiền cảnh duy nhất được áp dụng cho nó, nhưng nhiều màu trong phạm vi của nó.

00:07:54.000 --> 00:08:03.000
Vì vậy, ví dụ, tôi có thể sử dụng phép nội suy chuỗi để nhúng một Văn bản bên trong...

00:08:03.000 --> 00:08:08.000
Và sau đó áp dụng màu nền trước của màu đỏ...

00:08:08.000 --> 00:08:09.000
Đến từ "màu sắc."

00:08:09.000 --> 00:08:18.000
Và nó sẽ hiển thị màu đó, tự động chọn không tham gia sự sống động cho phạm vi đó.

00:08:18.000 --> 00:08:28.000
Thậm chí quan trọng hơn, với những phong cách tiền cảnh này, lần đầu tiên, bạn có được hành vi đúng đắn với biểu tượng cảm xúc được nhúng, nơi chúng hoạt động.

00:08:28.000 --> 00:08:30.000
Cái này trông ổn đấy.

00:08:30.000 --> 00:08:41.000
Hãy chạy lại và thử chế độ Chỉnh sửa với những thay đổi này.

00:08:41.000 --> 00:08:43.000
Nó hầu như đã hoạt động rồi.

00:08:43.000 --> 00:08:47.000
Và những màu này bị mờ, điều đó thật tuyệt.

00:08:47.000 --> 00:08:51.000
Nhưng nếu bạn nhìn kỹ, nó không làm điều hoàn toàn đúng đắn.

00:08:51.000 --> 00:08:56.000
Khi tôi cuộn xuống hết cỡ, có một chút danh sách ẩn đằng sau vết mờ.

00:08:56.000 --> 00:08:58.000
Hãy xem xét kỹ hơn những gì đang xảy ra.

00:08:58.000 --> 00:09:03.000
Hãy lấy đi chrome và chỉ nhìn vào các quan điểm có liên quan, tại đây.

00:09:03.000 --> 00:09:11.000
Nếu chúng ta trượt các chế độ xem này ra xa nhau một chút theo chiều ngang, chúng ta có thể thấy điều này là do thanh chỉ được xếp chồng lên trên nội dung của chúng ta.

00:09:11.000 --> 00:09:17.000
Bây giờ chúng ta muốn xem tất cả các chế độ xem ở phía sau, đó không phải là hành vi đúng đắn.

00:09:17.000 --> 00:09:25.000
Chúng tôi có thể thay đổi thành VStack ở đây, nhưng nếu không có danh sách dưới phần mờ, chúng tôi sẽ không nhận được bất kỳ màu nào hiển thị khi cuộn xuống.

00:09:25.000 --> 00:09:31.000
Chúng tôi muốn nền của danh sách và khu vực có thể cuộn của nó mở rộng dưới thanh nhưng không phải nội dung chính của nó.

00:09:31.000 --> 00:09:34.000
Và đây chính xác là mục đích của khu vực an toàn.

00:09:34.000 --> 00:09:40.000
Nếu chúng ta làm cho khu vực an toàn bị chèn vào bởi thanh này, thì bất kỳ nội dung quan trọng nào sẽ không bị che khuất.

00:09:40.000 --> 00:09:46.000
Để tùy chỉnh khu vực an toàn trong chế độ xem của riêng chúng tôi, chúng tôi có thể sử dụng công cụ sửa đổi mới: safeAreaInset.

00:09:46.000 --> 00:09:51.000
Điều này cho phép chúng tôi thêm nội dung phụ trợ, như thanh của chúng tôi, qua nội dung chính.

00:09:51.000 --> 00:09:56.000
Tôi sẽ thay thế ZStack của chúng ta...

00:09:56.000 --> 00:10:03.000
Với một khu vực an toàn bên trong...

00:10:03.000 --> 00:10:07.000
Sử dụng một cạnh của.đáy...

00:10:07.000 --> 00:10:10.000
Và đặt sự kiểm soát của chúng tôi vào đó.

00:10:10.000 --> 00:10:17.000
Hãy chạy lại lần nữa để kiểm tra.

00:10:17.000 --> 00:10:20.000
Khung cảnh này trông vẫn như cũ, điều đó thật tốt.

00:10:20.000 --> 00:10:24.000
Đó là bởi vì nó đang bỏ qua khu vực an toàn.

00:10:24.000 --> 00:10:27.000
Và trong chế độ Chỉnh sửa...

00:10:27.000 --> 00:10:30.000
Chúng ta vẫn có thể cuộn dưới thanh để làm mờ nó.

00:10:30.000 --> 00:10:34.000
Nhưng khi chúng ta cuộn xuống dưới cùng, không có gì bị che khuất.

00:10:34.000 --> 00:10:35.000
Tuyệt vời.

00:10:35.000 --> 00:10:39.000
Tiếp theo, hãy xem các trình hiển thị của chúng tôi.

00:10:39.000 --> 00:10:44.000
Hãy bắt đầu với trình hiển thị Shapes, đã được viết sẵn.

00:10:44.000 --> 00:10:49.000
Nó hiển thị một số lượng lớn các biểu tượng hình dạng ngẫu nhiên, mỗi biểu tượng được vẽ bằng một trong các gradient từ ứng dụng.

00:10:49.000 --> 00:10:55.000
Tôi có thể nhấn vào một biểu tượng để phóng to nó...

00:10:55.000 --> 00:11:00.000
Hoặc nhấn vào nền để định vị lại tất cả các biểu tượng.

00:11:00.000 --> 00:11:05.000
Và nếu bạn đã xem các bản trình diễn hoạt hình SwiftUI của chúng tôi trước đây, bạn biết rằng nó luôn tương tác và có thể bị gián đoạn.

00:11:05.000 --> 00:11:09.000
Vì vậy tôi có thể tiếp tục sắp xếp lại...

00:11:09.000 --> 00:11:15.000
Và thậm chí nhấn để chọn và bỏ chọn các hình dạng trong khi điều đó đang diễn ra.

00:11:15.000 --> 00:11:19.000
Nếu tôi đi xem mã...

00:11:19.000 --> 00:11:23.000
Nó đang sử dụng một kỹ thuật phổ biến để vẽ đồ họa trong SwiftUI.

00:11:23.000 --> 00:11:33.000
Có một GeometryReader để tôi có thể đọc kích thước của chế độ xem để bố trí tất cả các đồ họa này và ZStack để giúp tôi định vị chúng.

00:11:33.000 --> 00:11:38.000
Và ở cuối phần thân, có một công cụ sửa đổi mà bạn có thể đã thấy trước đây: drawingGroup.

00:11:38.000 --> 00:11:44.000
Một drawingGroup yêu cầu SwiftUI kết hợp tất cả các chế độ xem mà nó chứa trong một lớp duy nhất để vẽ.

00:11:44.000 --> 00:11:51.000
Điều này hoạt động tốt cho các yếu tố đồ họa như thế này nhưng không nên được sử dụng với các điều khiển giao diện người dùng như trường văn bản và danh sách.

00:11:51.000 --> 00:11:57.000
Đây là một kỹ thuật tuyệt vời để sử dụng khi bạn muốn hiển thị một số lượng lớn các yếu tố đồ họa như chúng tôi đang làm ở đây.

00:11:57.000 --> 00:12:07.000
Và một trong những lợi ích của drawingGroup là mặc dù các chế độ xem này được vẽ khác nhau, bạn vẫn có thể sử dụng cùng một chức năng từ SwiftUI mà bạn sử dụng ở mọi nơi khác trong ứng dụng của mình.

00:12:07.000 --> 00:12:18.000
Ví dụ, ở đây, chúng tôi có một cử chỉ được áp dụng cho mỗi biểu tượng để chạm vào chúng và cũng là một hình ảnh động áp dụng khi chúng tôi thay đổi lựa chọn hoặc định vị lại chúng.

00:12:18.000 --> 00:12:26.000
Thông tin khả năng truy cập có trong các chế độ xem này cũng được thông qua bình thường - ví dụ: các hành động khả năng truy cập này trên mỗi biểu tượng.

00:12:26.000 --> 00:12:31.000
Tuy nhiên, để hỗ trợ tất cả các tính năng này, có một số sổ sách kế toán và lưu trữ cần thiết cho mỗi chế độ xem.

00:12:31.000 --> 00:12:36.000
Nếu bạn có số lượng yếu tố đủ cao, thì ngay cả chi phí bổ sung đó cũng có thể là quá nhiều.

00:12:36.000 --> 00:12:39.000
Và đối với những trường hợp đó, chúng tôi đã giới thiệu một chế độ xem Canvas mới.

00:12:39.000 --> 00:12:44.000
Trình hiển thị tiếp theo của chúng tôi sẽ hiển thị một hệ thống hạt phức tạp và nó vẫn chưa được viết.

00:12:44.000 --> 00:12:46.000
Hãy đi xây dựng nó.

00:12:46.000 --> 00:12:52.000
Hãy bắt đầu với chế độ xem Canvas của chúng tôi để vẽ nó.

00:12:52.000 --> 00:12:58.000
Điều này cho phép chúng tôi thực hiện một kết thúc chạy mỗi khi khung vẽ được vẽ và chứa các lệnh vẽ của chúng tôi.

00:12:58.000 --> 00:13:03.000
Nếu bạn đã quen thuộc với drawRect trong UIKit hoặc AppKit, điều này hoạt động khá giống nhau.

00:13:03.000 --> 00:13:12.000
Việc đóng cửa này cung cấp cho chúng ta một ngữ cảnh, đó là những gì chúng ta gửi lệnh vẽ đến và một kích thước mà chúng ta có thể sử dụng để có được kích thước của toàn bộ khung vẽ.

00:13:12.000 --> 00:13:15.000
Hãy bắt đầu bằng cách vẽ một hình ảnh.

00:13:15.000 --> 00:13:22.000
Tôi có thể tạo một cái bằng cách sử dụng cùng một loại Hình ảnh mà tôi sử dụng trong phần còn lại của mã SwiftUI của mình.

00:13:22.000 --> 00:13:32.000
Và hãy nói với bối cảnh để vẽ hình ảnh của chúng ta.

00:13:32.000 --> 00:13:37.000
Khi chúng ta vẽ nó ở 0,0, nó ở trên đây, tập trung vào điểm gốc, nơi nó không thể nhìn thấy rõ lắm.

00:13:37.000 --> 00:13:51.000
Vì chúng ta có sẵn kích thước của toàn bộ khung vẽ, thay vào đó hãy sử dụng nó để vẽ nó ở giữa.

00:13:51.000 --> 00:13:58.000
Và một điều bạn có thể thấy nếu tôi thay đổi bản xem trước của chúng tôi để ở Chế độ tối...

00:13:58.000 --> 00:14:05.000
Đó có phải là hình ảnh của chúng tôi tự động lật để vẽ màu trắng, vì nó sử dụng cùng một kiểu tiền cảnh mà chúng tôi đã thấy trước đó.

00:14:05.000 --> 00:14:10.000
Vì chúng ta muốn xây dựng một hệ thống hạt, hãy vẽ hình ảnh này thêm vài lần nữa.

00:14:10.000 --> 00:14:13.000
Lưu ý rằng việc đóng cửa này dành cho mã mệnh lệnh.

00:14:13.000 --> 00:14:14.000
Nó không phải là ViewBuilder.

00:14:14.000 --> 00:14:21.000
Vì vậy, tôi chỉ có thể sử dụng một vòng lặp bình thường.

00:14:21.000 --> 00:14:32.000
Và hãy thay đổi từng hình ảnh một chút để chúng ta thực sự có thể nhìn thấy chúng.

00:14:32.000 --> 00:14:43.000
Bây giờ, chúng tôi đang vẽ hình ảnh này nhiều lần, nhưng mỗi lần, bối cảnh cần phải giải quyết nó để đánh giá nó dựa trên những thứ như môi trường hiện tại, mặc dù mỗi lần, đó là cùng một hình ảnh.

00:14:43.000 --> 00:14:52.000
Chúng ta có thể cải thiện điều này bằng cách tự giải quyết hình ảnh trước khi vẽ nó.

00:14:52.000 --> 00:15:00.000
Bây giờ chúng tôi có hiệu suất tốt hơn vì chúng tôi đang chia sẻ cùng một hình ảnh được giải quyết, nhưng hình ảnh được giải quyết cũng cho phép chúng tôi làm một số việc khác.

00:15:00.000 --> 00:15:03.000
Bây giờ chúng ta có thể yêu cầu kích thước và đường cơ sở của nó.

00:15:03.000 --> 00:15:17.000
Trong trường hợp của chúng tôi, chúng tôi sẽ sử dụng kích thước của nó để thay đổi từng cái với số lượng phù hợp.

00:15:17.000 --> 00:15:20.000
Tiếp theo, hãy thêm các hình elip phía sau lấp lánh của chúng ta.

00:15:20.000 --> 00:15:22.000
Tôi sẽ vẽ chúng trong cùng một khu vực.

00:15:22.000 --> 00:15:29.000
Vì vậy, hãy kéo ra một khung để vẽ cả hai vào.

00:15:29.000 --> 00:15:45.000
Tôi sẽ tạo một CGRect với cùng giá trị X và Y và sử dụng imageSize của chúng tôi cho chiều rộng và chiều cao...

00:15:45.000 --> 00:15:50.000
Sau đó vẽ hình ảnh của chúng tôi trong khung đó.

00:15:50.000 --> 00:15:56.000
Bởi vì mỗi thao tác vẽ được thực hiện theo thứ tự, để đặt hình elip của chúng ta phía sau hình ảnh, chúng ta cần vẽ nó trước.

00:15:56.000 --> 00:16:00.000
Và chúng ta có thể vẽ nó với ngữ cảnh. điền vào...

00:16:00.000 --> 00:16:02.000
Cái nào có một con đường và một bóng râm.

00:16:02.000 --> 00:16:16.000
Bạn có thể xây dựng một đường dẫn với các đường cong bezier tiêu chuẩn, nhưng đây là một mẹo: Bạn cũng có thể sử dụng các hình dạng như hình elip và yêu cầu chúng cung cấp đường dẫn của chúng trong một hình chữ nhật nhất định.

00:16:16.000 --> 00:16:19.000
Lập luận khác là một bóng râm, đó là thứ để lấp đầy con đường của chúng ta.

00:16:19.000 --> 00:16:23.000
Và điều này có thể sử dụng các kiểu tương tự như phần còn lại của ứng dụng SwiftUI của chúng tôi.

00:16:23.000 --> 00:16:28.000
Hãy sử dụng màu lục lam.

00:16:28.000 --> 00:16:30.000
Và có những hình elip.

00:16:30.000 --> 00:16:32.000
Tuy nhiên, không có nhiều sự tương phản với những hình ảnh.

00:16:32.000 --> 00:16:33.000
Hãy sửa nó đi.

00:16:33.000 --> 00:16:40.000
Bối cảnh đồ họa có nhiều thuộc tính vẽ tiêu chuẩn, như độ mờ, chế độ hòa trộn, biến đổi và hơn thế nữa.

00:16:40.000 --> 00:16:42.000
Hãy đặt độ mờ ở đây.

00:16:42.000 --> 00:16:48.000
Và chúng ta có thể xem xét một lĩnh vực mà bối cảnh này hoạt động hơi khác so với những gì bạn có thể đã quen.

00:16:48.000 --> 00:16:52.000
Nếu tôi chỉ đặt độ mờ đục trên ngữ cảnh, thì nó sẽ hoạt động như bạn mong đợi.

00:16:52.000 --> 00:16:57.000
Nó ảnh hưởng đến tất cả các hoạt động xảy ra sau đó.

00:16:57.000 --> 00:17:07.000
Trước đây, nếu tôi muốn thay đổi ngữ cảnh đồ họa chỉ áp dụng cho một số thao tác vẽ của mình, tôi sẽ phải đặt các thao tác đó trong cuộc gọi lưu và khôi phục.

00:17:07.000 --> 00:17:19.000
Nhưng với ngữ cảnh SwiftUI, tất cả những gì tôi phải làm là thực hiện các thay đổi trên một bản sao.

00:17:19.000 --> 00:17:23.000
Và những thay đổi đó chỉ ảnh hưởng đến bản vẽ được thực hiện với ngữ cảnh đã sửa đổi.

00:17:23.000 --> 00:17:28.000
Bản vẽ được thực hiện trên bối cảnh ban đầu không bị ảnh hưởng.

00:17:28.000 --> 00:17:31.000
Hãy thêm một số màu sắc vào hình ảnh của chúng ta nữa.

00:17:31.000 --> 00:17:41.000
Một điều khác mà chúng ta có thể làm với một hình ảnh được phân giải là đặt một bóng để kiểm soát cách các biểu tượng được vẽ.

00:17:41.000 --> 00:17:47.000
Hãy đặt một màu xanh ở đây.

00:17:47.000 --> 00:17:50.000
Điều đó trông kém sáng hơn một chút so với những gì tôi mong đợi.

00:17:50.000 --> 00:17:54.000
Đôi khi khi bạn đang vẽ, chế độ hòa trộn phù hợp có thể tạo ra sự khác biệt lớn.

00:17:54.000 --> 00:18:02.000
Các chế độ pha trộn kiểm soát cách kết hợp màu sắc, đặc biệt là với độ mờ một phần, như chúng ta có ở đây.

00:18:02.000 --> 00:18:04.000
Hãy thiết lập chế độ hòa trộn màn hình.

00:18:04.000 --> 00:18:08.000
Điều đó kết hợp màu sắc để chúng luôn sáng hơn.

00:18:08.000 --> 00:18:10.000
Điều đó có vẻ tốt hơn.

00:18:10.000 --> 00:18:13.000
Có rất nhiều thao tác vẽ khác mà bạn có thể làm.

00:18:13.000 --> 00:18:17.000
Kiểm tra loại GraphicsContext để xem mọi thứ có thể.

00:18:17.000 --> 00:18:20.000
Bây giờ, để làm cho điều này giống như một mô phỏng, nó cần phải thực sự di chuyển.

00:18:20.000 --> 00:18:24.000
Có một vài công cụ để thay đổi theo thời gian trong SwiftUI.

00:18:24.000 --> 00:18:30.000
Ảnh động là phổ biến nhất và chúng thường chỉ xảy ra tự động khi bạn thực hiện thay đổi.

00:18:30.000 --> 00:18:38.000
Năm nay, chúng tôi sẽ giới thiệu một công cụ cấp thấp mới được gọi là TimelineView khi bạn muốn kiểm soát chính xác cách mọi thứ thay đổi theo thời gian.

00:18:38.000 --> 00:18:49.000
Tôi có thể sử dụng TimelineView bằng cách quấn nó xung quanh chế độ xem mà tôi muốn thay đổi.

00:18:49.000 --> 00:18:56.000
Và tôi có thể cấu hình nó với một lịch trình, cho biết tần suất cập nhật.

00:18:56.000 --> 00:19:04.000
Có lịch trình cho những thứ như bộ hẹn giờ, nhưng chúng tôi sẽ sử dụng lịch trình hoạt hình để nhận thông tin cập nhật nhanh nhất có thể.

00:19:04.000 --> 00:19:07.000
Nếu bạn đã quen thuộc với một liên kết hiển thị, liên kết này hoạt động rất giống nhau.

00:19:07.000 --> 00:19:09.000
Và nếu bạn không, điều đó hoàn toàn ổn.

00:19:09.000 --> 00:19:16.000
Chúng tôi được thông qua một bối cảnh dòng thời gian cung cấp cho chúng tôi thông tin về những gì chúng tôi nên hiển thị.

00:19:16.000 --> 00:19:26.000
Tôi có thể rút ra thời gian trong vài giây mà chúng ta sẽ sử dụng để tạo hiệu ứng động cho hình ảnh của mình xung quanh.

00:19:26.000 --> 00:19:29.000
Hãy làm cho hình ảnh của chúng ta di chuyển theo dao động quay.

00:19:29.000 --> 00:19:36.000
Vì vậy, tôi sẽ tạo ra một góc nhìn từ thời điểm hiện tại.

00:19:36.000 --> 00:19:42.000
Hãy lặp lại nó ba giây một lần bằng cách sử dụng phần còn lại...

00:19:42.000 --> 00:19:47.000
Và nhân nó với 120 để đạt 360 độ.

00:19:47.000 --> 00:19:50.000
Và chúng ta sẽ nhận được giá trị X với cosin.

00:19:50.000 --> 00:19:51.000
Hay đó là sine?

00:19:51.000 --> 00:19:56.000
Tôi hy vọng bạn nhớ lượng giác của mình.

00:19:56.000 --> 00:20:01.000
Bây giờ hãy sử dụng giá trị đó để thay đổi phần bù của chúng ta...

00:20:01.000 --> 00:20:06.000
Và xem trước trực tiếp các bản xem trước của chúng tôi để xem nó trông như thế nào.

00:20:06.000 --> 00:20:09.000
Tốt. Xem làm thế nào khi chúng chồng lên nhau, chúng thậm chí còn sáng hơn?

00:20:09.000 --> 00:20:11.000
Đó là chế độ hòa trộn màn hình của chúng tôi tại nơi làm việc.

00:20:11.000 --> 00:20:14.000
Tiếp theo, hãy thêm một số tương tác.

00:20:14.000 --> 00:20:19.000
Trước đó, chúng tôi đã xem xét một số tương tác mà chúng tôi có thể thực hiện bằng cách thêm cử chỉ vào chế độ xem cá nhân.

00:20:19.000 --> 00:20:26.000
Hãy nhớ rằng một trong những sự đánh đổi của việc sử dụng canvas là các yếu tố riêng lẻ bên trong nó được kết hợp thành một bản vẽ duy nhất.

00:20:26.000 --> 00:20:31.000
Vì vậy, chúng tôi không thể, ví dụ, gắn một cử chỉ vào những hình ảnh riêng lẻ này.

00:20:31.000 --> 00:20:34.000
Tuy nhiên, chúng ta vẫn có thể thêm một cử chỉ vào toàn bộ chế độ xem.

00:20:34.000 --> 00:20:38.000
Hãy thêm khả năng tăng số lượng lấp lánh được hiển thị.

00:20:38.000 --> 00:20:45.000
Chúng tôi sẽ thêm một số trạng thái để hiển thị bao nhiêu.

00:20:45.000 --> 00:20:48.000
Và hãy để nó bắt đầu với hai.

00:20:48.000 --> 00:20:55.000
Hãy sử dụng số đếm để kiểm soát vòng lặp của chúng ta.

00:20:55.000 --> 00:21:02.000
Sau đó, chúng tôi sẽ thêm một TapGesture để tăng số lượng.

00:21:02.000 --> 00:21:07.000
Hãy cập nhật bản xem trước của chúng tôi.

00:21:07.000 --> 00:21:13.000
Và bây giờ chúng ta có thể nhấn để thêm lấp lánh.

00:21:13.000 --> 00:21:22.000
Một khía cạnh quan trọng khác của việc sử dụng canvas là, vì nó là một đồ họa duy nhất, không có bất kỳ thông tin nào về nội dung của nó có sẵn cho Accessibility.

00:21:22.000 --> 00:21:37.000
Để làm cho điều này có thể truy cập được, chúng tôi sẽ sử dụng các công cụ sửa đổi khả năng truy cập tiêu chuẩn để thêm thông tin về chế độ xem của chúng tôi.

00:21:37.000 --> 00:21:49.000
Và đối với các trường hợp nâng cao hơn, có một công cụ sửa đổi .accessibilityChildren mới mạnh mẽ cho phép bạn chỉ định một hệ thống phân cấp chế độ xem SwiftUI tùy ý để sử dụng để tạo thông tin khả năng truy cập về chế độ xem.

00:21:49.000 --> 00:21:55.000
Xem "SwiftUI Accessibility: Beyond the Basics" để biết thêm thông tin về cách sử dụng nó.

00:21:55.000 --> 00:22:02.000
Chúng tôi đã xây dựng một cách sử dụng Canvas tương đối đơn giản, nhưng nó được thiết kế để hỗ trợ các mục đích sử dụng phức tạp hơn nhiều, vì vậy hãy thêm gia vị cho mọi thứ một chút.

00:22:02.000 --> 00:22:09.000
Một trong những đồng nghiệp của tôi đã viết một số mã mô phỏng cho tôi hoạt động giống như những gì chúng ta có ở đây, nhưng với nhiều yếu tố hơn làm những điều thú vị hơn.

00:22:09.000 --> 00:22:22.000
Tôi có tệp mà anh ấy đã gửi cho tôi ở đây mà tôi sẽ dán vào chế độ xem của chúng tôi.

00:22:22.000 --> 00:22:26.000
Mã này có cấu trúc giống như những gì chúng tôi vừa làm.

00:22:26.000 --> 00:22:33.000
Bây giờ chúng tôi có một đối tượng mô hình tồn tại lâu dài mà chúng tôi đang cập nhật theo thời gian để theo dõi tất cả các hạt của chúng tôi.

00:22:33.000 --> 00:22:38.000
Chúng tôi có cùng một TimelineView và Canvas để tạo hiệu ứng động và vẽ nội dung của chúng tôi.

00:22:38.000 --> 00:22:50.000
Chúng tôi đang cập nhật mô hình của mình với ngày mới, đặt chế độ hòa trộn màn hình đó và yêu cầu mỗi hạt đang hoạt động tự vẽ giống như hình elip mà chúng tôi vừa có.

00:22:50.000 --> 00:22:55.000
Và cuối cùng, chúng tôi có các công cụ sửa đổi tương tự được áp dụng, chỉ với một cử chỉ phức tạp hơn một chút.

00:22:55.000 --> 00:23:04.000
Vậy hãy xem nó trông như thế nào.

00:23:04.000 --> 00:23:10.000
Nó tạo ra một vụ nổ pháo hoa mới theo định kỳ, và chúng ta cũng có thể chạm để thêm nhiều vụ nổ hơn.

00:23:10.000 --> 00:23:16.000
Và chúng được tạo ra bằng cách sử dụng hình elip với màu sắc từ độ dốc của ứng dụng.

00:23:16.000 --> 00:23:24.000
Một điều tuyệt vời khác về vẽ trong Canvas là nó cũng hoạt động trên watchOS, tvOS và macOS.

00:23:24.000 --> 00:23:27.000
Nó có sẵn trên tất cả các nền tảng SwiftUI.

00:23:27.000 --> 00:23:29.000
Được rồi. Chúng tôi đã hoàn thành ứng dụng của mình.

00:23:29.000 --> 00:23:46.000
Và trên đường đi, chúng tôi đã xem xét làm việc và sửa đổi các khu vực an toàn, cách sử dụng các kiểu tiền cảnh để kiểm soát cách vẽ nội dung, cách sử dụng vật liệu để làm mờ và sống động, và chúng tôi đã sử dụng Canvas và TimelineView để xây dựng đồ họa hoạt hình phức tạp.

00:23:46.000 --> 00:23:50.000
Tôi nóng lòng muốn xem bạn xây dựng đồ họa tuyệt vời nào trong ứng dụng của mình.

00:23:50.000 --> 23:59:59.000
[Âm nhạc].

