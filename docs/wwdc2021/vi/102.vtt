WEBVTT

00:00:17.000 --> 00:00:21.000
Chào mừng đến với nền tảng WWDC2021 của công đoàn.

00:00:21.000 --> 00:00:28.000
WWDC là thời điểm chúng tôi đến với nhau với tư cách là một cộng đồng nhà phát triển để xem xét những gì tương lai gần nắm giữ cho các nền tảng của chúng tôi.

00:00:28.000 --> 00:00:36.000
Tôi cũng muốn suy ngẫm một chút về công việc mà bạn đã làm đã giúp tất cả chúng ta vượt qua năm qua như thế nào.

00:00:36.000 --> 00:00:45.000
Các ứng dụng và sự sáng tạo của bạn đã cho phép mọi người tìm ra những cách mới để giữ cho mọi thứ chuyển động trong những hoàn cảnh phi thường.

00:00:45.000 --> 00:00:55.000
Có rất nhiều ví dụ tuyệt vời về việc các nhà phát triển tạo ra sự khác biệt và chúng tôi biết chúng tôi có thể làm nhiều hơn nữa để giúp bạn làm cho thế giới tốt đẹp hơn nhanh hơn.

00:00:55.000 --> 00:01:03.000
Vì vậy, năm nay chúng tôi sẽ cung cấp các công cụ, công nghệ và API được thiết kế để giúp bạn hoàn thành nhiều việc hơn.

00:01:03.000 --> 00:01:07.000
Và hôm nay chúng ta sẽ nói về ba lĩnh vực lớn mà chúng ta đang biến điều đó thành hiện thực.

00:01:07.000 --> 00:01:15.000
Đầu tiên, chúng ta sẽ nói về những thứ giúp bạn xây dựng các ứng dụng tuyệt vời: Xcode và Xcode Cloud, Swift và các khung giao diện người dùng của chúng tôi.

00:01:15.000 --> 00:01:25.000
Sau đó, chúng tôi sẽ xem xét cách các công nghệ của Apple có thể giúp bạn xây dựng các ứng dụng giúp bạn có thể thực tế tăng cường và công nghệ đồ họa của chúng tôi để người dùng nhìn thế giới theo những cách mới.

00:01:25.000 --> 00:01:39.000
Cuối cùng, với các tính năng mới như Focus, Screen Time API, Widgets và Share Play, chúng ta sẽ thấy những cách mà các ứng dụng bạn xây dựng có thể giúp người dùng kết nối tốt hơn với nhau và ưu tiên những gì quan trọng nhất đối với họ.

00:01:39.000 --> 00:01:41.000
Hãy bắt đầu với việc phát triển các ứng dụng.

00:01:41.000 --> 00:01:48.000
Để cho bạn biết thêm, đây là Alison, Rhonda và Andrew.

00:01:48.000 --> 00:01:57.000
Phát triển một ứng dụng ngày nay là một quá trình khá phức tạp và bạn dựa vào các công cụ của mình để giữ cho bạn tập trung và hiệu quả.

00:01:57.000 --> 00:02:04.000
Phần thiết yếu nhất của quy trình là mã hóa, nhưng việc xây dựng một ứng dụng chất lượng ngày nay bao gồm một số bước và công cụ chuyên biệt.

00:02:04.000 --> 00:02:08.000
Bạn cần kiểm tra mã của mình trên nhiều cấu hình khác nhau.

00:02:08.000 --> 00:02:13.000
Nhóm của bạn xem xét mã của bạn và bạn tích hợp các thay đổi vào kho lưu trữ được chia sẻ.

00:02:13.000 --> 00:02:15.000
Bạn giao hàng cho những người thử nghiệm beta.

00:02:15.000 --> 00:02:19.000
Và dựa trên phản hồi của họ, bạn liên tục tinh chỉnh ứng dụng của mình.

00:02:19.000 --> 00:02:23.000
Tất cả các bước này đều quan trọng và điều quan trọng là phải làm cho tất cả chúng đúng.

00:02:23.000 --> 00:02:30.000
Bạn thường phải chuyển đổi giữa các ứng dụng, trang web và dịch vụ khác nhau để hoàn thành mọi thứ.

00:02:30.000 --> 00:02:36.000
Tất cả việc chuyển đổi ngữ cảnh này làm gián đoạn sự tập trung của bạn và kéo bạn ra khỏi mã của mình.

00:02:36.000 --> 00:02:47.000
Đã đến lúc làm điều gì đó về điều đó, để loại bỏ ma sát và mang mọi thứ lại với nhau, để bạn và nhóm của bạn có thể tập trung vào việc tạo ra những trải nghiệm tuyệt vời.

00:02:47.000 --> 00:02:56.000
Đó là lý do tại sao chúng tôi tạo ra Xcode Cloud: một dịch vụ tích hợp và phân phối liên tục mới được tích hợp ngay trong Xcode và được lưu trữ trên đám mây.

00:02:56.000 --> 00:03:04.000
Nó giúp bạn quản lý mọi giai đoạn trong quá trình phát triển của mình và giúp bạn dễ dàng làm đúng những điều quan trọng.

00:03:04.000 --> 00:03:10.000
Xcode Cloud được thiết kế và xây dựng từ đầu để hỗ trợ phát triển cho tất cả các nền tảng của Apple.

00:03:10.000 --> 00:03:16.000
Nó được tích hợp sâu vào Xcode, giúp bạn tiết kiệm thời gian bằng cách giữ cho bạn tập trung ở một nơi.

00:03:16.000 --> 00:03:23.000
Nó tận dụng cơ sở hạ tầng đám mây của Apple để giảm tải các bản dựng, thử nghiệm và thậm chí ký mã của bạn để phân phối.

00:03:23.000 --> 00:03:30.000
Nó tích hợp với các dịch vụ của Apple như Test Flight và App Store Connect, cũng như mọi nhà cung cấp kiểm soát nguồn dựa trên git chính.

00:03:30.000 --> 00:03:35.000
Nó thậm chí còn có REST APIs để giúp kết nối với các khía cạnh khác trong quá trình phát triển của bạn.

00:03:35.000 --> 00:03:40.000
Và nó được xây dựng với bảo mật tiên tiến để bảo vệ bạn và các dự án của bạn.

00:03:40.000 --> 00:03:50.000
Đây là khoản đầu tư lớn nhất mà chúng tôi đã thực hiện vào các công cụ dành cho nhà phát triển của mình kể từ khi phát hành Xcode ban đầu và tất cả đều nằm trong trải nghiệm mà bạn đã biết.

00:03:50.000 --> 00:04:00.000
Bạn tạo và quản lý quy trình làm việc Xcode Cloud trong Xcode 13, cho phép bạn ở trong mã của mình trong khi các bộ thử nghiệm, ký mã và phân phối TestFlight được xử lý cho bạn.

00:04:00.000 --> 00:04:05.000
Và khi Xcode Cloud hoàn thành một bản dựng, kết quả của bạn nằm ngay bên trong Xcode.

00:04:05.000 --> 00:04:08.000
Điều này sẽ thay đổi cách bạn làm việc.

00:04:08.000 --> 00:04:10.000
Nó đã thay đổi cách chúng ta làm việc.

00:04:10.000 --> 00:04:23.000
Nhiều nhóm tại Apple đã kết hợp Xcode Cloud vào quá trình phát triển của họ, bao gồm cả nhóm đứng sau chính Xcode.

00:04:23.000 --> 00:04:26.000
Thật dễ dàng để bắt đầu với Xcode Cloud.

00:04:26.000 --> 00:04:36.000
Chỉ mất bốn bước: chọn sản phẩm, xác nhận quy trình làm việc của bạn, cấp quyền truy cập vào mã nguồn của bạn và liên kết với App Store Connect.

00:04:36.000 --> 00:04:41.000
Hãy cùng xem qua quy trình với Fruta, một ứng dụng mẫu SwiftUI.

00:04:41.000 --> 00:04:47.000
Xcode Cloud tự động phát hiện các sản phẩm và nền tảng cho dự án của tôi, vì vậy tôi sẽ nhấp vào tiếp theo.

00:04:47.000 --> 00:04:55.000
Sau đó, tôi sẽ xem xét quy trình làm việc được đề xuất, cho Xcode Cloud biết phải làm gì và khi nào nên làm.

00:04:55.000 --> 00:05:00.000
Các hành động mặc định xây dựng mọi thay đổi tôi thực hiện, đó chính xác là những gì tôi muốn.

00:05:00.000 --> 00:05:05.000
Bây giờ, Xcode Cloud sẽ kết nối an toàn với tài khoản được lưu trữ cho mã nguồn của tôi.

00:05:05.000 --> 00:05:10.000
Tôi đã cấp quyền truy cập bằng thông tin đăng nhập của mình, vì vậy tôi có thể tiếp tục.

00:05:10.000 --> 00:05:17.000
Cuối cùng, Xcode Cloud nhận ra rằng Fruta đã tồn tại trên App Store và yêu cầu tôi xác nhận thông tin.

00:05:17.000 --> 00:05:22.000
Nếu ứng dụng của bạn chưa được đăng ký, Xcode Cloud sẽ làm điều đó cho bạn.

00:05:22.000 --> 00:05:27.000
Tôi sẽ nhấp vào Hoàn thành và bắt đầu bản dựng đầu tiên của mình trên Đám mây.

00:05:27.000 --> 00:05:31.000
Khi quá trình xây dựng hoàn tất, tôi sẽ có thể xem kết quả trong trình điều hướng báo cáo.

00:05:31.000 --> 00:05:40.000
Và cứ như vậy, tôi đã thiết lập tích hợp và phân phối liên tục cho ứng dụng của mình trong một phút tất cả từ bên trong Xcode.

00:05:40.000 --> 00:05:44.000
Chúng ta hãy xem xét kỹ hơn cách trình bày kết quả.

00:05:44.000 --> 00:05:52.000
Trong tab Đám mây trong trình điều hướng báo cáo, các bản dựng đã được chạy cho mỗi quy trình làm việc sẽ được nhóm theo nhánh hoặc Yêu cầu kéo.

00:05:52.000 --> 00:06:03.000
Chọn một bản dựng riêng lẻ sẽ hiển thị tổng quan của nó với thông tin như cách thức và thời điểm nó được bắt đầu, phiên bản Xcode và macOS nào đã được sử dụng và trạng thái của tất cả các hành động.

00:06:03.000 --> 00:06:07.000
Bạn thậm chí có thể kiểm tra nguồn hoặc bắt đầu xây dựng lại.

00:06:07.000 --> 00:06:18.000
Mặc dù quy trình làm việc mặc định rất phù hợp để bắt đầu, Xcode Cloud cung cấp cho bạn nhiều sức mạnh hơn để hoàn thành các mục tiêu như phân tích ứng dụng hoặc triển khai các bản phát hành mới cho Test Flight hoặc App Store.

00:06:18.000 --> 00:06:27.000
Nhóm của tôi muốn chạy các bài kiểm tra iOS của chúng tôi trên mỗi Yêu cầu Kéo mới, vì vậy hãy thiết lập quy trình làm việc đó ngay bây giờ.

00:06:27.000 --> 00:06:34.000
Tôi sẽ quay lại menu sản phẩm Xcode Cloud, chọn Quản lý quy trình làm việc lần này và tôi sẽ nhấp vào Plus để thêm một cái mới.

00:06:34.000 --> 00:06:44.000
Tôi sẽ đặt tên cho quy trình làm việc Pull Requests, sau đó chỉnh sửa các điều kiện bắt đầu của nó để chạy trên mọi Pull Request nhắm vào nhánh chính.

00:06:44.000 --> 00:06:51.000
Tôi muốn các thử nghiệm của chúng tôi chạy trên các phiên bản beta công khai của Xcode và macOS, vì vậy tôi sẽ đặt nó ở đây.

00:06:51.000 --> 00:07:02.000
Tiếp theo, tôi sẽ xem xét các hành động của quy trình làm việc, nơi tôi sẽ thêm một hành động thử nghiệm, sau đó chọn một kế hoạch thử nghiệm iOS hiện có từ dự án.

00:07:02.000 --> 00:07:08.000
Để có được phạm vi thử nghiệm rộng rãi cho ứng dụng của tôi, Xcode Cloud đề xuất các trình mô phỏng cho tôi sử dụng.

00:07:08.000 --> 00:07:14.000
Chỉ với hai cú nhấp chuột, tôi nhận được một bộ iPhone và iPad được tuyển chọn cho quy trình làm việc của mình.

00:07:14.000 --> 00:07:16.000
Bây giờ điều đó khá gọn gàng.

00:07:16.000 --> 00:07:19.000
Nhóm của chúng tôi cũng cần được thông báo khi một bản dựng thành công hoặc thất bại.

00:07:19.000 --> 00:07:25.000
Vì vậy, tôi sẽ thêm một hành động đăng Thông báo và thêm kênh Slack của nhóm chúng tôi.

00:07:25.000 --> 00:07:29.000
Bằng cách nhấp vào Lưu, quy trình làm việc của chúng tôi đã được thêm vào sản phẩm của chúng tôi trên Xcode Cloud.

00:07:29.000 --> 00:07:34.000
Bây giờ, nhóm của tôi sẽ thêm tự tin vào những thay đổi mà chúng tôi đang thực hiện.

00:07:34.000 --> 00:07:46.000
Bạn có thể làm nhiều việc hơn với quy trình làm việc, bao gồm chạy các tập lệnh xây dựng tùy chỉnh và sử dụng các móc web và API của Xcode Cloud để tích hợp với các hệ thống khác mà bạn và nhóm của bạn phụ thuộc vào.

00:07:46.000 --> 00:07:53.000
Và quản lý quy trình làm việc và xây dựng các báo cáo bạn vừa thấy trong Xcode cũng có sẵn trong App Store Connect trên web.

00:07:53.000 --> 00:07:59.000
Điều này giúp bạn hoặc các thành viên khác trong nhóm của bạn dễ dàng sử dụng Xcode Cloud từ mọi nơi.

00:07:59.000 --> 00:08:07.000
Bây giờ bạn đã thấy những điều cơ bản khi làm việc với Xcode Cloud, hãy xem nó giúp bạn như thế nào trong từng lĩnh vực cụ thể trong chu kỳ phát triển của bạn.

00:08:07.000 --> 00:08:13.000
Viết các bài kiểm tra tốt và chạy chúng nhiều lần là rất quan trọng để tạo ra một ứng dụng chất lượng.

00:08:13.000 --> 00:08:21.000
Với Xcode Cloud, bạn sẽ kiểm tra mã của mình kỹ lưỡng hơn, nhất quán hơn và hiệu quả hơn.

00:08:21.000 --> 00:08:31.000
Bạn có thể định cấu hình quy trình làm việc Xcode Cloud của mình để chạy song song nhiều kế hoạch thử nghiệm trên nhiều nền tảng, trình mô phỏng thiết bị và phiên bản hệ điều hành.

00:08:31.000 --> 00:08:39.000
Bạn cũng có thể chạy các bài kiểm tra của mình trong Xcode Cloud trên các bản phát hành hệ điều hành beta trước khi bạn tải các bản beta xuống máy của riêng mình.

00:08:39.000 --> 00:08:50.000
Vì vậy Xcode Cloud sẽ giúp bạn kiểm tra nhiều hơn và Xcode 13 sẽ giúp bạn kiểm tra tốt hơn.

00:08:50.000 --> 00:08:59.000
Ứng dụng Fruta của chúng tôi hỗ trợ giao diện Sáng và Tối, định hướng dọc và ngang, đồng thời bản địa hóa thành hai ngôn ngữ.

00:08:59.000 --> 00:09:07.000
Tôi đang làm việc trên một bộ kiểm tra trải nghiệm người dùng thực hiện các tính năng phổ biến nhất của Fruta.

00:09:07.000 --> 00:09:18.000
Ở đây trong mã kiểm tra của tôi, tôi sẽ áp dụng API kiểm tra XC đơn giản này để làm cho các thử nghiệm này tiến xa hơn nữa bằng cách tự động chạy từng thử nghiệm trong mỗi biến thể.

00:09:18.000 --> 00:09:26.000
Hãy xem xét phạm vi kiểm tra đó trong Xcode Cloud bằng cách chọn bản dựng gần đây nhất và hành động kiểm tra quy trình làm việc mà tôi đã định cấu hình.

00:09:26.000 --> 00:09:30.000
Kết quả được hiển thị trong báo cáo kiểm tra Xcode quen thuộc.

00:09:30.000 --> 00:09:41.000
Các thử nghiệm này chạy qua một bộ mô phỏng iPad được đề xuất chạy iOS 15, một lần cho mỗi cấu hình, chụp ảnh màn hình trên suốt chặng đường.

00:09:41.000 --> 00:09:45.000
Xcode 13 có một cách mới tuyệt vời để xem lại những kết quả đó.

00:09:45.000 --> 00:09:50.000
Từ menu tùy chọn trình chỉnh sửa, tôi sẽ bật chế độ xem thư viện mới.

00:09:50.000 --> 00:09:58.000
Ảnh chụp màn hình từ các bài kiểm tra của tôi được hiển thị trong mọi biến thể và hình ảnh từ mỗi bài kiểm tra được trình bày cùng nhau.

00:09:58.000 --> 00:10:08.000
Tôi có thể thu nhỏ hơn nữa để xem tất cả các hình ảnh và khi tôi tìm thấy một hình ảnh mà tôi thực sự quan tâm, tôi có thể nhìn thấy nó ở độ phân giải đầy đủ bằng cách sử dụng giao diện nhanh.

00:10:08.000 --> 00:10:16.000
Chế độ xem thư viện giúp dễ dàng xác nhận ứng dụng của chúng tôi trông tuyệt vời trên mọi điều kiện, ngôn ngữ và bố cục.

00:10:16.000 --> 00:10:22.000
Trong các bài kiểm tra đơn vị của tôi, tôi có một bài kiểm tra thất bại mà tôi chắc chắn bạn sẽ liên quan đến.

00:10:22.000 --> 00:10:26.000
Đôi khi bài kiểm tra vượt qua và đôi khi nó thất bại.

00:10:26.000 --> 00:10:27.000
Tất cả chúng ta đều đã từng ở đây trước đây.

00:10:27.000 --> 00:10:31.000
Và Xcode 13 ở đây để giúp đỡ.

00:10:31.000 --> 00:10:38.000
Tôi điều hướng đến nguồn thử nghiệm, nhấp vào đá quý thử nghiệm và chọn Chạy thử nghiệm lặp đi lặp lại.

00:10:38.000 --> 00:10:43.000
Hãy hiểu rõ hơn về độ tin cậy bằng cách chạy nó 100 lần.

00:10:43.000 --> 00:10:48.000
Nếu tôi muốn làm điều này trước đây, tôi sẽ phải tự mình chạy bài kiểm tra nhiều, rất nhiều lần.

00:10:48.000 --> 00:10:53.000
Bây giờ, tôi có thể ngồi lại vì các công cụ thực hiện tất cả công việc.

00:10:53.000 --> 00:10:59.000
Như tôi đã nghi ngờ, Xcode đang cho thấy bài kiểm tra này rất không đáng tin cậy.

00:10:59.000 --> 00:11:01.000
Chắc hẳn có một vấn đề trong mã của tôi.

00:11:01.000 --> 00:11:10.000
Nhưng cho đến khi tôi có thể sửa nó, tôi sẽ áp dụng API thất bại dự kiến mới và bao gồm một thông báo về độ tin cậy cho phần còn lại trong nhóm của tôi xem.

00:11:10.000 --> 00:11:18.000
Để đảm bảo mọi thứ đúng như tôi mong đợi, tôi sẽ sử dụng tính năng Kiểm tra lại, có sẵn từ menu sản phẩm.

00:11:18.000 --> 00:11:22.000
Xcode nhớ lại những gì nó đã làm lần trước nên nó thực sự dễ dàng.

00:11:22.000 --> 00:11:27.000
Bài kiểm tra của tôi vẫn đang đưa ra những khẳng định, nhưng nó không thất bại nữa.

00:11:27.000 --> 00:11:30.000
Và tôi có một lời nhắc nhở nhẹ nhàng để sửa nó trên đường.

00:11:30.000 --> 00:11:33.000
Đó chính xác là những gì tôi cần.

00:11:33.000 --> 00:11:43.000
Như bạn có thể thấy, Xcode 13 và Xcode Cloud giúp bạn tìm và giải quyết các vấn đề trong ứng dụng hoặc các bài kiểm tra của bạn nhanh hơn bao giờ hết.

00:11:43.000 --> 00:11:45.000
Các bài kiểm tra là một hình thức hiểu biết sâu sắc về mã của bạn.

00:11:45.000 --> 00:11:49.000
Một cái khác là đầu vào từ các đồng nghiệp của bạn thông qua đánh giá mã và Yêu cầu kéo.

00:11:49.000 --> 00:11:58.000
Để giúp bạn tập trung vào mã của mình, Xcode 13 đưa các cuộc thảo luận này với nhóm của bạn trực tiếp vào trình chỉnh sửa.

00:11:58.000 --> 00:12:01.000
Tôi đã tạo một Yêu cầu Kéo từ nhánh tính năng mà tôi đang làm việc.

00:12:01.000 --> 00:12:06.000
Tính năng của tôi cho phép người dùng yêu thích những ly sinh tố ngon nhất.

00:12:06.000 --> 00:12:11.000
Trong trình điều hướng bên trái, bạn có thể thấy tab thay đổi điều khiển nguồn mới.

00:12:11.000 --> 00:12:16.000
Nó hiển thị tất cả các tệp tôi đã sửa đổi cục bộ, Yêu cầu kéo của tôi và các thay đổi được bao gồm.

00:12:16.000 --> 00:12:22.000
Khi tôi chọn Yêu cầu kéo, tôi sẽ có cái nhìn tổng quan đầy đủ về tất cả các hoạt động và cuộc trò chuyện đang diễn ra.

00:12:22.000 --> 00:12:30.000
Và khi tôi cuộn, tôi thấy mô tả của mình và các sự kiện và thời gian thú vị, cũng như bất kỳ phản hồi mã nào từ nhóm của tôi và các cam kết mới mà tôi thực hiện.

00:12:30.000 --> 00:12:37.000
Nhưng chúng tôi đang sử dụng Xcode Cloud và quy trình làm việc Pull Request của chúng tôi đang xây dựng và kiểm tra mọi cam kết mà tôi thực hiện.

00:12:37.000 --> 00:12:43.000
Ở trên cùng, tôi nhận được trạng thái trực tiếp từ tất cả các quy trình làm việc của mình.

00:12:43.000 --> 00:12:47.000
Rhonda có một vài gợi ý để làm cho mã của tôi thậm chí còn tốt hơn.

00:12:47.000 --> 00:12:53.000
Khi tôi điều hướng đến mã nguồn, tôi thấy nhận xét từ Rhonda trong trình chỉnh sửa của mình.

00:12:53.000 --> 00:12:55.000
Mã này yêu cầu người dùng phải đăng nhập.

00:12:55.000 --> 00:13:00.000
Vì vậy, nó cần được làm lại để cho phép đăng nhập trước khi yêu thích một công thức.

00:13:00.000 --> 00:13:10.000
Tôi sẽ trả lời để cho Rhonda biết rằng tôi đang thực hiện một sự thay đổi và cũng thông báo cho cô ấy: Điều này có thể gặp sự cố trong bản dựng nếu cô ấy không đăng nhập trước.

00:13:10.000 --> 00:13:17.000
Ngoài Yêu cầu Kéo, Xcode 13 cũng giúp việc xem xét các thay đổi cục bộ thực sự dễ dàng.

00:13:17.000 --> 00:13:28.000
Khi tôi điều hướng đến một tệp mà tôi đang làm việc, Xcode sẽ tự động hiển thị sự khác biệt về các thay đổi của tôi so với bản sửa đổi mới nhất trong bản trình bày nội tuyến mới tuyệt đẹp này.

00:13:28.000 --> 00:13:35.000
Tôi có thể sử dụng các bộ chọn sửa đổi được cập nhật để so sánh các thay đổi cục bộ của mình với bất kỳ chi nhánh hoặc thẻ nào trong lịch sử.

00:13:35.000 --> 00:13:44.000
Trên hết, tôi có thể sử dụng đánh giá mã trong bất kỳ trình chỉnh sửa nào, ngay cả khi tôi đang sử dụng nhiều trình chỉnh sửa được phân tách trên các tệp khác nhau trong cửa sổ của mình.

00:13:44.000 --> 00:13:53.000
Và bây giờ với hai lựa chọn - so sánh nội tuyến và cạnh nhau - tôi có thể chọn bản trình bày hoàn hảo cho những gì tôi đang làm.

00:13:53.000 --> 00:14:02.000
Với một thay đổi mã và nhận xét cuối cùng, không thể dễ dàng hơn để xem xét và trả lời thông tin chi tiết từ nhóm của tôi.

00:14:02.000 --> 00:14:08.000
Một phần của việc cung cấp trải nghiệm tuyệt vời là đưa ứng dụng của bạn vào tay nhóm của bạn và những người thử nghiệm beta.

00:14:08.000 --> 00:14:12.000
Xcode Cloud làm cho quá trình đó trở nên dễ dàng.

00:14:12.000 --> 00:14:19.000
Xcode 13 hiện sử dụng đám mây để lấy và quản lý an toàn mọi thứ bạn cần để ký mã ứng dụng của mình.

00:14:19.000 --> 00:14:27.000
Điều này có nghĩa là bạn không còn phải lo lắng về việc cập nhật chứng chỉ và hồ sơ của mình trên máy Mac.

00:14:27.000 --> 00:14:34.000
Hành động lưu trữ trong quy trình làm việc Xcode Cloud của bạn sử dụng cùng một hệ thống để ký ứng dụng của bạn để phân phối.

00:14:34.000 --> 00:14:46.000
Và bằng cách thêm một postaction vào quy trình làm việc Xcode Cloud của bạn, bạn sẽ tự động phân phối các bản beta thông qua Test Flight cho tất cả các nền tảng của Apple, bao gồm macOS với Test Flight mới cho Mac.

00:14:46.000 --> 00:14:52.000
Khi bạn đã cung cấp bản dựng mới nhất của mình, bạn sẽ nhận được nhiều thông tin chi tiết hơn từ những người thử nghiệm beta của mình.

00:14:52.000 --> 00:15:00.000
Xcode 13 bao gồm những cải tiến lớn để kết nối bạn tốt hơn với cùng một chẩn đoán và phản hồi được tìm thấy trong App Store Connect.

00:15:00.000 --> 00:15:06.000
Nhật ký sự cố từ các ứng dụng Chuyến bay Thử nghiệm hiện được gửi trực tiếp đến Ban tổ chức trong vòng vài phút.

00:15:06.000 --> 00:15:11.000
Và Ban tổ chức hiện hiển thị phản hồi bằng văn bản mà người dùng đính kèm vào báo cáo sự cố.

00:15:11.000 --> 00:15:17.000
Điều này cung cấp cho bạn bối cảnh có giá trị khi phân tích sự cố và cái nhìn rộng hơn về việc sử dụng ứng dụng của bạn.

00:15:17.000 --> 00:15:24.000
Sau khi bài kiểm tra của Andrew vượt qua, Xcode Cloud đã gửi bản dựng trực tiếp đến Test Flight.

00:15:24.000 --> 00:15:32.000
Tôi vừa nhận được thông báo trên điện thoại của mình về bản dựng iOS mới của Fruta và có phiên bản Mac từ Test Flight cho Mac.

00:15:32.000 --> 00:15:39.000
Vì Fruta là một dự án đa nền tảng, tôi sẽ nhận được bản dựng mới này ở cả hai nơi cùng một lúc.

00:15:39.000 --> 00:15:43.000
Tôi thực sự hào hứng khi cài đặt bản dựng này và xem tính năng mới cảm thấy như thế nào.

00:15:43.000 --> 00:15:45.000
Vì vậy tôi sẽ làm điều đó ngay bây giờ.

00:15:45.000 --> 00:15:48.000
Tôi nghi ngờ vẫn còn một vài cạnh thô.

00:15:48.000 --> 00:15:52.000
Có lẽ ứng dụng sẽ gặp sự cố nếu tôi cố gắng yêu thích món sinh tố này.

00:15:52.000 --> 00:15:54.000
Và chắc chắn rồi, nó có.

00:15:54.000 --> 00:16:00.000
Tôi có thể sử dụng giao diện người dùng phản hồi sự cố của Test Flight để cho Andrew biết.

00:16:00.000 --> 00:16:10.000
Tôi sẽ giải thích những gì tôi đã làm khi ứng dụng gặp sự cố và anh ấy sẽ có thể khắc phục sự cố và thêm một bài kiểm tra để đảm bảo điều này được phát hiện sớm hơn vào lần sau.

00:16:10.000 --> 00:16:24.000
Tôi đã xem các bản phát hành ứng dụng gần đây nhất của chúng tôi trong Organizer Khi tôi lọc đến ngày cuối cùng, đây là một sự cố mà Rhonda đã trải qua chỉ một lúc trước, hoàn toàn mang tính biểu tượng và sẵn sàng để điều tra.

00:16:24.000 --> 00:16:31.000
Thanh tra phản hồi Chuyến bay Thử nghiệm mới bao gồm nhận xét, thông tin về bản dựng ứng dụng, phiên bản và thiết bị của cô ấy.

00:16:31.000 --> 00:16:34.000
Và tôi thậm chí có thể liên hệ với cô ấy để tìm hiểu thêm về trải nghiệm của cô ấy.

00:16:34.000 --> 00:16:40.000
Điều thậm chí còn tốt hơn: Xcode biết sự cố này đến từ đâu trong mã của tôi.

00:16:40.000 --> 00:16:44.000
Vì vậy, chỉ với một cú nhấp chuột, tôi có thể mở nó trong dự án của mình.

00:16:44.000 --> 00:16:48.000
Trình điều hướng gỡ lỗi có dấu vết phía sau đầy đủ.

00:16:48.000 --> 00:16:54.000
Trình chỉnh sửa nguồn của tôi làm nổi bật khẳng định và cuộc trò chuyện Yêu cầu Kéo của tôi cũng hiển thị.

00:16:54.000 --> 00:17:01.000
Thật thú vị khi có những gì tôi cần để khắc phục sự cố này ngay tại đây trong Xcode.

00:17:01.000 --> 00:17:15.000
Chúng tôi đã đưa mọi thứ bạn cần vào các công cụ bạn sử dụng hàng ngày - kết quả kiểm tra, nhận xét từ đồng nghiệp và phản hồi của người dùng - tất cả để cung cấp cho bạn cái nhìn sâu sắc hơn và giúp bạn cung cấp phiên bản tuyệt vời tiếp theo của ứng dụng của mình.

00:17:15.000 --> 00:17:20.000
Xcode Cloud được xây dựng với sự riêng tư và bảo mật của bạn.

00:17:20.000 --> 00:17:26.000
Dữ liệu của bạn - bao gồm nguồn, mã thông báo truy cập, khóa đăng nhập và tạo tác xây dựng - được xử lý an toàn.

00:17:26.000 --> 00:17:30.000
Và chúng tôi sử dụng ít dữ liệu nhất có thể để chạy dịch vụ.

00:17:30.000 --> 00:17:34.000
Đây là một năm trọng đại đối với các công cụ dành cho nhà phát triển của chúng tôi.

00:17:34.000 --> 00:17:46.000
Với Xcode 13 và Xcode Cloud, bạn sẽ xây dựng và cung cấp các ứng dụng chất lượng trên tất cả các nền tảng của Apple trong thời gian ngắn hơn và ít nỗ lực hơn bao giờ hết.

00:17:46.000 --> 00:17:50.000
Xcode Cloud ban đầu sẽ có sẵn dưới dạng bản beta giới hạn, miễn phí.

00:17:50.000 --> 00:17:56.000
Chủ tài khoản Chương trình Nhà phát triển có thể đăng ký ngay bây giờ tại developer.apple.com.

00:17:56.000 --> 00:18:03.000
Chúng tôi sẽ dần dần bổ sung thêm nhiều nhóm hơn khi chúng tôi làm việc hướng tới việc cung cấp điều này cho tất cả các nhà phát triển vào năm tới.

00:18:03.000 --> 00:18:07.000
Chúng tôi sẽ cung cấp thêm thông tin chi tiết về giá cả và tình trạng sẵn có vào mùa thu này.

00:18:07.000 --> 00:18:14.000
Bạn có thể kiểm tra trạng thái đăng ký của mình từ bên trong Xcode 13 hoặc tab Xcode Cloud trong App Store Connect.

00:18:14.000 --> 00:18:28.000
Ngoài mọi thứ bạn đã thấy ở đây, chúng tôi có một danh sách khổng lồ các cải tiến và tính năng trong các công cụ dành cho nhà phát triển của chúng tôi mà bạn có thể tìm hiểu trong các phiên năm nay, bao gồm một số cải tiến tuyệt vời để hỗ trợ Swift trong Xcode.

00:18:28.000 --> 00:18:32.000
Đó chỉ là khởi đầu của một câu chuyện thú vị cho Swift trong năm nay.

00:18:32.000 --> 00:18:39.000
Để cho bạn biết thêm, đây là Josh, Holly và Matt.

00:18:39.000 --> 00:18:45.000
Swift đã trở thành một ngôn ngữ quan trọng đối với các nhà phát triển trên các nền tảng của Apple và hơn thế nữa.

00:18:45.000 --> 00:18:56.000
Nó đã kích hoạt các công nghệ hiện đại nhất của chúng tôi, đóng vai trò là nền tảng cho một thế hệ khung mới như SwiftUI, CreateML và StoreKit 2 mới.

00:18:56.000 --> 00:19:07.000
Nó cung cấp một ngôn ngữ hiện đại, an toàn để tạo ra các ứng dụng phức tạp nhất của bạn với các công cụ mạnh mẽ như Xcode Previews và Swift Package Manager để đẩy nhanh quá trình phát triển của bạn.

00:19:07.000 --> 00:19:15.000
Và nó thân thiện và dễ tiếp cận đối với những người mới đến, với nội dung hấp dẫn và các bài học có sẵn trong Swift Playgrounds để học cách viết mã.

00:19:15.000 --> 00:19:20.000
Bây giờ, một phần quan trọng để đảm bảo rằng một công nghệ tuyệt vời cho bạn là tự mình áp dụng nó.

00:19:20.000 --> 00:19:31.000
Các ứng dụng cao cấp như Music đã được viết bằng Swift trong nhiều năm nay và các tính năng trên toàn hệ thống như Widgets đã được thiết kế từ đầu với SwiftUI.

00:19:31.000 --> 00:19:42.000
Học Swift và SwiftUI cung cấp cho bạn một bộ công cụ và API phổ biến, mạnh mẽ để xây dựng các ứng dụng gốc hoàn toàn cho tất cả các nền tảng của chúng tôi.

00:19:42.000 --> 00:19:52.000
Và bởi vì bản thân Swift là mã nguồn mở, chúng tôi đã có thể làm việc cùng với nhiều bạn để cung cấp hàng tấn tính năng và khả năng mới trong vài năm qua.

00:19:52.000 --> 00:19:59.000
Bây giờ, một trong những khả năng đó, rất quan trọng để xây dựng bất kỳ ứng dụng nào, là hỗ trợ đồng thời.

00:19:59.000 --> 00:20:04.000
Và đây là Holly để kể cho bạn tất cả về nó.

00:20:04.000 --> 00:20:09.000
Cho dù bạn có nghĩ về nó hay không, bạn đang viết mã đồng thời ngày hôm nay.

00:20:09.000 --> 00:20:23.000
Đồng thời cho phép các ứng dụng của bạn thực hiện nhiều tác vụ cùng một lúc, điều này giúp ứng dụng của bạn luôn phản hồi với đầu vào của người dùng trong khi thực hiện công việc ở chế độ nền, như ứng dụng thời tiết tìm nạp dữ liệu dự báo trong khi người dùng chọn thành phố.

00:20:23.000 --> 00:20:35.000
Và điều cần thiết là tận dụng các bộ xử lý đa lõi để đạt được hiệu suất cao cho tính toán nặng, như hiển thị các hiệu ứng hình ảnh phức tạp trong ứng dụng video.

00:20:35.000 --> 00:20:42.000
Nhưng nếu không có sự hỗ trợ ngôn ngữ, việc viết mã đồng thời thực sự rất khó để làm đúng.

00:20:42.000 --> 00:20:47.000
Vì vậy, chúng tôi đang mang lại sự hỗ trợ hạng nhất cho sự đồng thời cho Swift.

00:20:47.000 --> 00:21:01.000
Cách tiếp cận của chúng tôi để xây dựng tính đồng thời vào ngôn ngữ tuân theo các nguyên tắc cốt lõi giống nhau của chính Swift, giúp viết mã hiện đại, an toàn và nhanh chóng dễ dàng hơn để loại bỏ toàn bộ các lớp lỗi lập trình.

00:21:01.000 --> 00:21:07.000
Đầu tiên, hãy nói về cách chúng ta đã thực hiện một cách tiếp cận hiện đại để xây dựng sự đồng thời vào Swift.

00:21:07.000 --> 00:21:14.000
Ngày nay, chúng tôi nghĩ mã hiện đại có cấu trúc và dễ dàng thể hiện những gì bạn muốn làm.

00:21:14.000 --> 00:21:22.000
Thật không may, hầu hết mã không đồng bộ ngày nay đều sử dụng trình xử lý hoàn thành không có cấu trúc và khó thể hiện.

00:21:22.000 --> 00:21:29.000
Để làm cho việc thể hiện các hàm không đồng bộ dễ dàng hơn, chúng tôi đã xây dựng mẫu async/await hiện đại thành Swift.

00:21:29.000 --> 00:21:34.000
Bây giờ bạn có thể đánh dấu một hàm không đồng bộ bằng từ khóa không đồng bộ.

00:21:34.000 --> 00:21:43.000
Khi hàm được gọi, bạn sử dụng từ khóa await để chỉ ra rằng công việc khác có thể được thực hiện trong khi người gọi chờ kết quả của hàm không đồng bộ.

00:21:43.000 --> 00:21:50.000
Để hiểu những cải tiến mà async/await mang lại cho các trình xử lý hoàn thành, hãy xem qua một ví dụ.

00:21:50.000 --> 00:21:54.000
Khi tôi không làm việc trên trình biên dịch Swift, tôi thích nhảy.

00:21:54.000 --> 00:22:02.000
Để chuẩn bị cho một buổi biểu diễn, một công ty khiêu vũ trước tiên phải khởi động, đoàn làm phim sẽ lấy phong cảnh và đạo cụ từ kho, và sau đó sân khấu được thiết lập.

00:22:02.000 --> 00:22:07.000
Một khi tất cả những điều đó được thực hiện, các vũ công có thể di chuyển vào vị trí mở đầu của họ.

00:22:07.000 --> 00:22:13.000
Đây là một triển khai không đồng bộ của "prepareForShow" sử dụng trình xử lý hoàn thành.

00:22:13.000 --> 00:22:18.000
Những gì mã này đang cố gắng hoàn thành thực sự đơn giản, nhưng mã phức tạp.

00:22:18.000 --> 00:22:26.000
Nó sử dụng các trình xử lý hoàn thành lồng nhau làm cho luồng thực thi không tự nhiên, vì vậy mã thực sự khó đọc.

00:22:26.000 --> 00:22:32.000
Việc áp dụng async/await trong ví dụ này để lại cho chúng ta mã hiện đang ở một đường thẳng.

00:22:32.000 --> 00:22:36.000
Mã này dễ hiểu hơn rất nhiều.

00:22:36.000 --> 00:22:40.000
Luồng điều khiển đi từ trên xuống dưới, giống như bất kỳ chức năng nào khác.

00:22:40.000 --> 00:22:45.000
Bạn xử lý lỗi và trả về các giá trị giống như cách bạn đã quen trong Swift.

00:22:45.000 --> 00:22:49.000
Bạn cũng có thể sử dụng tất cả các cấu trúc luồng điều khiển thông thường.

00:22:49.000 --> 00:22:55.000
Vì vậy, thật dễ dàng để thêm logic có điều kiện, vì vậy hàm hoạt động khác nhau trong một buổi diễn tập.

00:22:55.000 --> 00:23:02.000
Async/await giúp việc viết mã không đồng bộ dễ dàng hơn bằng cách tận dụng các công cụ bạn đã biết.

00:23:02.000 --> 00:23:08.000
Việc giới thiệu đồng thời ở nơi bạn cần bằng cách sử dụng Đồng thời có cấu trúc cũng dễ dàng hơn.

00:23:08.000 --> 00:23:15.000
Đồng thời có cấu trúc là một cách tổ chức các nhiệm vụ đồng thời để giúp chúng dễ suy luận hơn.

00:23:15.000 --> 00:23:18.000
Hãy giới thiệu tính đồng thời vào prepareForShow.

00:23:18.000 --> 00:23:28.000
Ngay bây giờ, chức năng này đợi cho đến khi các vũ công hoàn thành việc khởi động trước khi bắt đầu tìm kiếm phong cảnh, nhưng những nhiệm vụ này có thể được thực hiện song song.

00:23:28.000 --> 00:23:38.000
Với Đồng thời có cấu trúc, bạn có thể dễ dàng tạo các tác vụ con đồng thời bằng cách sử dụng async/await với các biến cục bộ, như thế này.

00:23:38.000 --> 00:23:46.000
Bây giờ, mã sử dụng các biến 'async let' để tạo các tác vụ con thực thi đồng thời với cha mẹ.

00:23:46.000 --> 00:23:53.000
Vì vậy, công ty khởi động và tìm kiếm phong cảnh sẽ chạy đồng thời với phần còn lại của prepareForShow.

00:23:53.000 --> 00:23:58.000
Khi chúng ta cần kết quả của những nhiệm vụ trẻ con đó, chúng ta chờ đợi kết quả.

00:23:58.000 --> 00:24:12.000
Bởi vì fetchStageScenery thực thi đồng thời, có thể kết quả chưa sẵn sàng khi prepareForShow cần sử dụng nó, vì vậy việc truy cập kết quả phải được thực hiện không đồng bộ.

00:24:12.000 --> 00:24:16.000
Mô hình đồng thời của Swift cũng được thiết kế để an toàn.

00:24:16.000 --> 00:24:31.000
Giống như Swift loại bỏ các lỗi con trỏ rỗng bằng các tùy chọn, trình biên dịch giờ đây sẽ giúp loại bỏ các vấn đề đồng thời phổ biến bằng cách đảm bảo rằng quyền truy cập vào trạng thái được chia sẻ được phối hợp an toàn giữa các tác vụ đồng thời.

00:24:31.000 --> 00:24:36.000
Một phần cốt lõi của mô hình đồng thời an toàn này được xây dựng xung quanh các diễn viên.

00:24:36.000 --> 00:24:43.000
Diễn viên là một mô hình đã được chứng minh trong ngành để lập trình đồng thời an toàn và nguyên thủy đồng bộ hóa mạnh mẽ.

00:24:43.000 --> 00:24:52.000
Về mặt khái niệm, một tác nhân là một đối tượng bảo vệ trạng thái của chính nó bằng cách chỉ cung cấp quyền truy cập loại trừ lẫn nhau.

00:24:52.000 --> 00:24:58.000
Điều này loại bỏ hoàn toàn quyền truy cập đồng thời và các cuộc đua dữ liệu cấp thấp đi kèm với nó.

00:24:58.000 --> 00:25:08.000
Khái niệm này nghe có vẻ quen thuộc, bởi vì nó tương tự như một mô hình mà bạn có thể đã sử dụng cho các lớp học với hàng đợi điều phối, bản thân nó được lấy cảm hứng từ các diễn viên.

00:25:08.000 --> 00:25:17.000
Trong mẫu này, các thuộc tính thể hiện trong một lớp được truy cập cẩn thận bằng cách sử dụng hàng đợi điều phối nối tiếp để duy trì loại trừ lẫn nhau.

00:25:17.000 --> 00:25:21.000
Nhưng mô hình này dễ bị sai lầm.

00:25:21.000 --> 00:25:30.000
Có rất nhiều bản mẫu và quá dễ dàng để quên sử dụng hàng đợi theo cách thủ công chỉ một lần và đưa điều kiện cuộc đua vào mã của bạn.

00:25:30.000 --> 00:25:39.000
Để giải quyết những vấn đề này, chúng tôi đã quay trở lại ý tưởng cốt lõi của các diễn viên và xây dựng nó thành Swift như một cấu trúc hạng nhất.

00:25:39.000 --> 00:25:44.000
Bây giờ, bạn có thể khai báo một loại diễn viên trong Swift với một từ khóa đơn giản.

00:25:44.000 --> 00:25:52.000
Nó có cấu trúc giống như các cấu trúc mà bạn đã biết và không cần đồng bộ hóa thủ công.

00:25:52.000 --> 00:25:59.000
Với các diễn viên được tích hợp trong ngôn ngữ Swift, việc đồng bộ hóa quyền truy cập vào trạng thái diễn viên có thể được quản lý tự động cho bạn.

00:25:59.000 --> 00:26:10.000
Một diễn viên có thể truy cập trực tiếp các thuộc tính của chính nó và tương tác với một diễn viên bên ngoài sử dụng async/await để đảm bảo loại trừ lẫn nhau.

00:26:10.000 --> 00:26:21.000
Khái niệm diễn viên mạnh mẽ đến mức nó cũng giải quyết một nguồn phổ biến khác của các vấn đề đồng thời, đó là sử dụng đúng luồng chính cho những thứ như hoạt động giao diện người dùng.

00:26:21.000 --> 00:26:30.000
Hôm nay, bạn phải gửi thủ công đến hàng đợi chính mỗi khi bạn gọi một API phải chạy trên luồng chính.

00:26:30.000 --> 00:26:39.000
Bây giờ, chúng tôi đang giới thiệu một cách để nói rằng API luôn được chạy trên luồng chính bằng cách sử dụng tác nhân chính.

00:26:39.000 --> 00:26:48.000
Đảm bảo rằng một API luôn chạy trên tác nhân chính dễ dàng như chú thích khai báo với thuộc tính MainActor.

00:26:48.000 --> 00:26:55.000
Cũng giống như các diễn viên khác, việc gọi một hàm chạy trên diễn viên chính chỉ là một sự chờ đợi.

00:26:55.000 --> 00:27:03.000
Nhìn chung, điều này có nghĩa là viết mã đồng thời an toàn dễ dàng hơn mà bạn không cần phải tự quản lý.

00:27:03.000 --> 00:27:12.000
Khi chúng tôi xây dựng hỗ trợ đồng thời trực tiếp sang ngôn ngữ, nó cho chúng tôi cơ hội tối ưu hóa tốt hơn hiệu suất của mã đồng thời của bạn.

00:27:12.000 --> 00:27:20.000
Với async/await, trình biên dịch hiểu được tính đồng thời của mã của bạn, điều này cho phép tối ưu hóa hiệu quả hơn.

00:27:20.000 --> 00:27:29.000
Điều này bao gồm giảm số lượng tham chiếu và nội tuyến cũng như giải quyết các vấn đề hiệu suất cụ thể đồng thời như chuyển đổi ngữ cảnh quá mức.

00:27:29.000 --> 00:27:36.000
Và tất nhiên, mã đồng thời của bạn sẽ còn nhanh hơn khi trình biên dịch trở nên thông minh hơn trong những năm tới.

00:27:36.000 --> 00:27:42.000
Có rất nhiều API không đồng bộ trong SDK mà bạn đã sử dụng trong các ứng dụng của mình.

00:27:42.000 --> 00:27:53.000
Chúng tôi đã tinh chỉnh SDK để cho phép không đồng bộ/chờ đợi với các API không đồng bộ này, vì vậy bạn có thể ngay lập tức áp dụng async/await trong mã hiện có của mình.

00:27:53.000 --> 00:27:55.000
Và chúng tôi đã không dừng lại ở đó.

00:27:55.000 --> 00:28:10.000
Chúng tôi đã thêm các API được tạo có chủ đích mới tận dụng lợi thế của async/await khi bạn làm việc với URL, khi bạn đang thực hiện I/O không đồng bộ và chúng tôi thậm chí còn thêm hỗ trợ lặp lại không đồng bộ từng dòng thông qua một tệp.

00:28:10.000 --> 00:28:23.000
Async/await giúp thể hiện mã không đồng bộ một cách tự nhiên, đồng thời có cấu trúc giúp mã đồng thời dễ suy luận hơn và các tác nhân giúp bạn mô hình hóa trạng thái được chia sẻ một cách an toàn trong một chương trình đồng thời.

00:28:23.000 --> 00:28:34.000
Mô hình đồng thời Swift tập hợp các phần cơ bản này để giúp bạn hiệu quả hơn, cung cấp cho bạn nhiều năng lượng hơn và cho phép bạn có nhiều niềm vui hơn khi xây dựng các ứng dụng đồng thời.

00:28:34.000 --> 00:28:39.000
Tất nhiên, ngôn ngữ chỉ là một phần của câu đố.

00:28:39.000 --> 00:28:43.000
Các khuôn khổ được xây dựng bằng Swift cũng quan trọng không kém.

00:28:43.000 --> 00:28:45.000
Bây giờ, trở lại với Josh.

00:28:45.000 --> 00:28:49.000
Swift là nền tảng cho thế hệ API tiếp theo.

00:28:49.000 --> 00:29:03.000
Với các tính năng mới như Đồng thời, chúng tôi đang cùng nhau phát triển ngôn ngữ và khuôn khổ, vì vậy bạn sẽ thấy những lợi ích ngay lập tức trên SDK, bao gồm cả các công nghệ chính như SwiftUI.

00:29:03.000 --> 00:29:08.000
Hai năm trước, chúng tôi bắt đầu phát minh lại sự phát triển giao diện người dùng trên nền tảng của mình.

00:29:08.000 --> 00:29:17.000
Chúng tôi bắt đầu nhỏ, với một API cốt lõi cho phép bạn áp dụng SwiftUI từng bước trong các ứng dụng hiện có của mình.

00:29:17.000 --> 00:29:26.000
Năm ngoái, chúng tôi đã thêm API để mô tả vòng đời ứng dụng của bạn, cho phép bạn phát triển các ứng dụng hoàn toàn bằng SwiftUI từ dòng mã đầu tiên của mình.

00:29:26.000 --> 00:29:37.000
Và năm nay, SwiftUI đang thực hiện một bước tiến lớn khác, giúp bạn mang lại trải nghiệm tuyệt vời cho tất cả người dùng của mình trên tất cả các nền tảng của Apple.

00:29:37.000 --> 00:29:44.000
Chúng tôi tập trung vào các API mà chúng tôi biết là rất quan trọng đối với các ứng dụng của bạn, bởi vì chúng tôi cũng cần chúng để xây dựng ứng dụng của chúng tôi.

00:29:44.000 --> 00:29:51.000
Và phản hồi của bạn đã giúp chúng tôi nâng cao các API quan trọng nhất, đồng thời tinh chỉnh trải nghiệm phát triển.

00:29:51.000 --> 00:29:57.000
Năm nay, chúng tôi đã bắt đầu sử dụng SwiftUI trong các ứng dụng như Bản đồ, Ảnh và Phím tắt.

00:29:57.000 --> 00:30:08.000
Và chúng tôi đã xây dựng lại các ứng dụng iOS như Thời tiết, giao diện hệ thống như bảng thanh toán Apple Pay và các ứng dụng watchOS hoàn toàn mới như Find My, hoàn toàn bằng SwiftUI.

00:30:08.000 --> 00:30:14.000
Để xem chỉ một vài cải tiến giúp điều này trở nên khả thi, chúng ta hãy xem xét một số cách mà chúng ta có thể cải thiện Fruta.

00:30:14.000 --> 00:30:20.000
Chúng ta sẽ bắt đầu với List, thành phần phổ biến nhất trên tất cả các nền tảng của chúng ta.

00:30:20.000 --> 00:30:25.000
Bây giờ chúng ta có thể dễ dàng thêm một hành động vuốt để đánh dấu một ly sinh tố là yêu thích.

00:30:25.000 --> 00:30:28.000
Thêm pull-to-refresh chỉ là một dòng nữa.

00:30:28.000 --> 00:30:37.000
Và Swift giờ đây giúp dễ dàng giới hạn công cụ sửa đổi ở một nền tảng duy nhất - trong trường hợp này là iOS.

00:30:37.000 --> 00:30:40.000
Thêm một trường Tìm kiếm chỉ là một dòng nữa.

00:30:40.000 --> 00:30:47.000
Bây giờ, chúng ta có thể dừng lại ở đó, nhưng chúng ta cũng hãy thêm một số đề xuất tìm kiếm, sẽ được hiển thị trong khi chúng ta đang nhập.

00:30:47.000 --> 00:30:51.000
Và hãy kiểm tra nó ngay tại đây trong Xcode.

00:30:51.000 --> 00:31:02.000
Bây giờ chúng tôi có một hành động vuốt, kéo để làm mới và hỗ trợ tìm kiếm đầy đủ bao gồm các đề xuất, tất cả chỉ trong một vài dòng mã.

00:31:02.000 --> 00:31:06.000
Tiếp theo, hãy tinh chỉnh hỗ trợ khả năng tiếp cận của Fruta.

00:31:06.000 --> 00:31:15.000
Đầu tiên, một công cụ sửa đổi mới bổ sung các cánh quạt khả năng truy cập có thể giúp ứng dụng của chúng tôi điều hướng nhanh hơn với VoiceOver.

00:31:15.000 --> 00:31:20.000
Và thứ hai, chúng tôi sẽ cải thiện khả năng tiếp cận của điều khiển bước tùy chỉnh này.

00:31:20.000 --> 00:31:30.000
Các điều khiển tùy chỉnh thường là nguồn gốc của khả năng tiếp cận kém, nhưng bây giờ chúng ta có thể đơn giản kế thừa việc triển khai khả năng truy cập đầy đủ từ Stepper tiêu chuẩn.

00:31:30.000 --> 00:31:40.000
Hầu hết các API SwiftUI đều có sẵn trên tất cả các nền tảng, nhưng chúng tôi cũng đang chuyển các nền tảng về phía trước khi thích hợp.

00:31:40.000 --> 00:31:44.000
Hãy thêm một bảng nhiều cột vào ứng dụng macOS của chúng ta.

00:31:44.000 --> 00:31:50.000
Tôi đã thêm một tệp mới cho việc này, vì vậy chúng tôi sẽ chỉ thêm thành phần Bảng mới ở đây.

00:31:50.000 --> 00:31:54.000
Và sau đó bên trong nó, chúng ta sẽ chỉ thêm ba cột dữ liệu.

00:31:54.000 --> 00:31:58.000
Bây giờ hãy chạy phiên bản macOS của ứng dụng của chúng tôi.

00:31:58.000 --> 00:32:05.000
Chúng tôi sẽ tìm thấy một trường tìm kiếm được đặt ngay tại nơi bạn mong đợi trên thanh công cụ và các đề xuất xuất hiện ngay bên dưới nó trong khi chúng tôi nhập.

00:32:05.000 --> 00:32:12.000
Chúng ta có thể chuyển sang bảng nhiều cột mới mà chúng ta đã thêm vào và chúng ta cũng sẽ thấy nó hiển thị kết quả tìm kiếm.

00:32:12.000 --> 00:32:17.000
Và tất nhiên, chúng ta có thể xóa tìm kiếm để lấy lại tất cả chúng.

00:32:17.000 --> 00:32:22.000
Bây giờ hãy chuyển sang công thức nấu ăn và bật VoiceOver.

00:32:22.000 --> 00:32:29.000
Với VoiceOver, chúng tôi có thể dễ dàng truy cập vào rôto mà chúng tôi đã thêm vào để nhanh chóng chọn một ly sinh tố từ danh sách.

00:32:29.000 --> 00:32:38.000
Và tương tác VoiceOver với bước tùy chỉnh của chúng tôi giờ đây hoạt động chính xác như một bước tiêu chuẩn, giúp tất cả người dùng của chúng tôi dễ dàng sử dụng.

00:32:38.000 --> 00:32:46.000
Chúng tôi đang xây dựng các ứng dụng của mình bằng cách sử dụng các khả năng mới này, vì vậy chúng tôi biết rằng bạn cũng sẽ thấy chúng hữu ích trong các ứng dụng của mình.

00:32:46.000 --> 00:32:50.000
Và chúng tôi vừa làm xước bề mặt của những gì mới.

00:32:50.000 --> 00:32:55.000
Ví dụ, bạn sẽ thích sự hỗ trợ tài liệu mới của SwiftUI.

00:32:55.000 --> 00:33:07.000
Trong ứng dụng Fruta, các chế độ xem như thế này được làm cho thú vị hơn bằng cách thêm hình nền và chúng được giữ dễ đọc bằng cách áp dụng một trong những kiểu vật liệu mới đằng sau nội dung.

00:33:07.000 --> 00:33:24.000
Nội dung phản hồi linh hoạt với nền này, vì vậy thay vì màu xám thường được sử dụng cho nội dung phụ trong ngữ cảnh mờ đục, SwiftUI sẽ tự động áp dụng kết xuất sống động cho văn bản, ký hiệu và thậm chí cả giao diện người dùng tiêu chuẩn như dấu phân cách.

00:33:24.000 --> 00:33:30.000
Vì vậy, chỉ với một dòng mã, bạn có thể tự động nhận được kết quả tuyệt vời như thế này.

00:33:30.000 --> 00:33:33.000
Và còn rất nhiều nữa.

00:33:33.000 --> 00:33:41.000
Với tất cả những cải tiến này, SwiftUI là cách tốt nhất để xây dựng trải nghiệm tuyệt vời cho tất cả người dùng của bạn trên tất cả các nền tảng của chúng tôi.

00:33:41.000 --> 00:33:48.000
Và năm nay, chúng tôi sẽ đưa phát triển ứng dụng với SwiftUI lên iPad trong Swift Playgrounds.

00:33:48.000 --> 00:33:56.000
Nó rất vui, và Matt sẽ chỉ cho bạn tất cả về cách nó hoạt động.

00:33:56.000 --> 00:34:03.000
Bạn biết đấy Swift Playgrounds cung cấp một cách tuyệt vời để học cách viết mã và nó đã được hàng triệu người sử dụng để mở rộng kiến thức của họ về Swift.

00:34:03.000 --> 00:34:14.000
Và ngoài việc là một cách học tuyệt vời, chúng tôi biết rất nhiều bạn đã sử dụng Swift Playgrounds để thử nghiệm, phác thảo những ý tưởng mới và chơi với các tính năng mới nhất trong iPadOS SDK.

00:34:14.000 --> 00:34:24.000
Năm nay, Swift Playgrounds 4 đang tiến một bước lớn bằng cách cho phép bạn xây dựng các ứng dụng và thậm chí gửi chúng đến App Store ngay từ iPad của bạn.

00:34:24.000 --> 00:34:34.000
Với khả năng tạo ứng dụng trên iPad, bạn có thể làm việc hiệu quả hơn trong Swift Playgrounds hơn bao giờ hết, cho phép bạn thực hiện ý tưởng của mình mọi lúc mọi nơi, trên bất kỳ thiết bị nào bạn thích.

00:34:34.000 --> 00:34:41.000
Và với định dạng dự án dựa trên gói mới, bạn có thể liên tục đưa công việc của mình giữa Swift Playgrounds và Xcode.

00:34:41.000 --> 00:34:43.000
Hãy đi sâu vào và xem qua.

00:34:43.000 --> 00:34:46.000
Đây là Swift Playgrounds 4.

00:34:46.000 --> 00:34:56.000
Nó có tất cả nội dung Learn to Code tuyệt vời đã giúp truyền cảm hứng cho các nhà phát triển mới trên khắp thế giới và bây giờ, bạn có thể tạo các dự án cho phép bạn xây dựng các ứng dụng SwiftUI.

00:34:56.000 --> 00:35:00.000
Hãy làm một cái mới ngay bây giờ và xem những gì chúng ta có thể xây dựng.

00:35:00.000 --> 00:35:03.000
Tôi sẽ mở dự án mới mà tôi đã tạo.

00:35:03.000 --> 00:35:10.000
Trong một dự án ứng dụng ở Swift Playgrounds, mã của tôi ở bên trái và kết quả công việc của tôi ở bên phải, giống như tôi đã quen.

00:35:10.000 --> 00:35:19.000
Có gì mới là hỗ trợ tích hợp sâu cho SwiftUI, với các bản xem trước tương tác trực tiếp được cung cấp bởi cùng một công nghệ được sử dụng trong Xcode.

00:35:19.000 --> 00:35:26.000
Mẫu dự án mới của tôi đi kèm với trình giữ chỗ Hello World, mà tôi có thể dễ dàng thay thế bằng chế độ xem văn bản của riêng mình.

00:35:26.000 --> 00:35:36.000
Tôi sẽ bắt đầu nhập Văn bản và ngay lập tức, tôi nhận được các đề xuất hữu ích từ việc hoàn thành mã, mới trong bản phát hành này, xuất hiện ngay bên dưới điểm chèn của tôi.

00:35:36.000 --> 00:35:40.000
Tôi sẽ chấp nhận hoàn thành và viết tin nhắn chào của riêng tôi.

00:35:40.000 --> 00:35:45.000
Trong khi tôi đang gõ, ứng dụng của tôi cập nhật trực tiếp để hiển thị các thay đổi của tôi với mỗi lần nhấn phím.

00:35:45.000 --> 00:35:47.000
Bây giờ, chúng ta hãy vui vẻ một chút.

00:35:47.000 --> 00:35:51.000
Tôi sẽ thay thế văn bản tĩnh này bằng một nút.

00:35:51.000 --> 00:35:56.000
Tôi sẽ chọn chế độ xem văn bản của mình, và sau đó thêm một nút từ thư viện.

00:35:56.000 --> 00:36:07.000
Ở đây trong thư viện, tôi có thể duyệt và tìm kiếm thông qua các nội dung trong dự án của mình, cũng như chế độ xem SwiftUI, công cụ sửa đổi, màu sắc và Biểu tượng SF do iPadOS cung cấp.

00:36:07.000 --> 00:36:11.000
Hiện tại, tôi sẽ chỉ thêm nút của mình.

00:36:11.000 --> 00:36:17.000
Tôi sẽ điền vào hành động bằng một tuyên bố in đơn giản.

00:36:17.000 --> 00:36:22.000
Đối với cơ thể, tôi sẽ sử dụng Nhãn với hình ảnh hệ thống.

00:36:22.000 --> 00:36:26.000
Văn bản sẽ là "Nói xin chào."

00:36:26.000 --> 00:36:30.000
Và hình ảnh sẽ là Biểu tượng SF cho Swift.

00:36:30.000 --> 00:36:34.000
Bây giờ tôi đã có một nút tương tác trong ứng dụng của mình.

00:36:34.000 --> 00:36:39.000
Khi tôi nhấn vào nó, tin nhắn in tôi đã viết xuất hiện dưới dạng bong bóng tin nhắn ở cuối màn hình của tôi.

00:36:39.000 --> 00:36:50.000
Nếu tôi mở bảng điều khiển, tôi có thể thấy lịch sử các câu lệnh in đã được thực thi kể từ khi tôi mở dự án này và nó cập nhật theo thời gian thực khi tôi tương tác với ứng dụng của mình.

00:36:50.000 --> 00:36:57.000
Bây giờ, nút này có màu tím vì đó là màu nhấn của ứng dụng của tôi, mà Swift Playgrounds đã chọn cho tôi khi tôi tạo dự án của mình.

00:36:57.000 --> 00:37:05.000
Nếu tôi mở thanh bên tài liệu, tôi có thể truy cập tất cả các cài đặt cấp cao nhất của ứng dụng, như tên, màu nhấn và biểu tượng của ứng dụng.

00:37:05.000 --> 00:37:18.000
Nhiều như tôi yêu màu tím, tôi nghĩ khuôn mặt cười này sẽ trông to và sáng màu cam, vì vậy tôi sẽ thay đổi màu nhấn của mình ở đây, và cả biểu tượng ứng dụng của tôi và màu sắc của nút tôi vừa thực hiện sẽ cập nhật để phản ánh sự thay đổi.

00:37:18.000 --> 00:37:24.000
Điều này thực sự rất thú vị, nhưng Swift Playgrounds không chỉ để thử nghiệm.

00:37:24.000 --> 00:37:27.000
Tôi có một ứng dụng khác mà tôi đã làm việc được một thời gian.

00:37:27.000 --> 00:37:34.000
Tôi sử dụng ứng dụng này để theo dõi lượng thời gian tôi dành cho sở thích yêu thích của mình và tôi nghĩ những người khác cũng có thể thấy nó hữu ích.

00:37:34.000 --> 00:37:39.000
Tôi có thể cảm nhận được ứng dụng đã cài đặt sẽ trông như thế nào bằng cách sử dụng nó toàn màn hình.

00:37:39.000 --> 00:37:45.000
Bây giờ tôi có thể khám phá ứng dụng của mình trong bố cục hai hoặc ba cột có chiều rộng đầy đủ của nó.

00:37:45.000 --> 00:37:51.000
Tôi có thể nhảy ra khỏi toàn màn hình và quay lại mã của mình bất cứ khi nào tôi muốn.

00:37:51.000 --> 00:37:57.000
Điều này cảm thấy tuyệt vời, và tôi nghĩ rằng công việc khó khăn của tôi đã sẵn sàng để chia sẻ với bạn bè và gia đình của tôi với TestFlight.

00:37:57.000 --> 00:38:04.000
Bất kỳ ai có Tài khoản Nhà phát triển đều có thể tải lên ứng dụng của họ từ khu vực Cài đặt Ứng dụng khi họ đã sẵn sàng cho App Store Connect.

00:38:04.000 --> 00:38:09.000
Khi tôi nhấn vào nút tải lên, Swift Playgrounds sẽ xây dựng, đóng gói và tải lên ứng dụng của tôi.

00:38:09.000 --> 00:38:19.000
Sau đó, tôi có thể truy cập trang web App Store Connect và cung cấp ứng dụng của mình thông qua TestFlight và khi nó sẵn sàng, hãy gửi nó đến App Store và chia sẻ nó với thế giới.

00:38:19.000 --> 00:38:26.000
Và đó là một cái nhìn nhanh về Swift Playgrounds 4, với khả năng tạo ứng dụng bằng SwiftUI ngay trên iPad của bạn.

00:38:26.000 --> 00:38:29.000
Swift Playgrounds 4 sẽ có mặt vào cuối năm nay.

00:38:29.000 --> 00:38:36.000
Chúng tôi biết bạn sẽ thích có quyền tự do phát triển ý tưởng ứng dụng của mình mọi lúc mọi nơi, trên bất kỳ thiết bị nào bạn thích.

00:38:36.000 --> 00:38:43.000
Và bây giờ, tôi sẽ trả lại nó cho Susan.

00:38:43.000 --> 00:38:51.000
Rất nhiều cách chúng ta trải nghiệm thế giới là thông qua giao tiếp trực quan và đó là một phần quan trọng trong việc sử dụng các thiết bị của Apple.

00:38:51.000 --> 00:39:08.000
Các công nghệ của chúng tôi cho đồ họa, màn hình và thực tế tăng cường ở phía trước và trung tâm, cho dù bạn đang liếc nhìn Luôn hiển thị trên Apple Watch, thưởng thức ProMotion khi bạn làm việc với các công cụ video trên iPad Pro, chơi trò chơi trên iPhone của bạn hoặc tạo nội dung 3D nhập vai trên máy Mac của bạn.

00:39:08.000 --> 00:39:15.000
Và bây giờ Myra và Eric sẽ đưa bạn qua những gì mới trong năm nay bắt đầu với thực tế tăng cường.

00:39:15.000 --> 00:39:23.000
AR là một công nghệ mạnh mẽ và hàng nghìn bạn đã sử dụng nó trong các ứng dụng của mình để thay đổi cách tất cả chúng ta làm việc, chơi và thể hiện bản thân.

00:39:23.000 --> 00:39:33.000
Với hơn một tỷ iPhone và iPad hỗ trợ AR trên khắp thế giới ngày nay, chưa bao giờ có thời điểm tốt hơn để bắt đầu thêm trải nghiệm AR vào ứng dụng của bạn hoặc xây dựng những trải nghiệm hoàn toàn mới.

00:39:33.000 --> 00:39:41.000
Trong lịch sử, việc xây dựng các ứng dụng AR tuyệt vời đòi hỏi kiến thức sâu rộng về mô hình 3D và thành thạo các công cụ kết xuất tinh vi.

00:39:41.000 --> 00:39:47.000
Tuy nhiên, chúng tôi muốn tất cả các bạn có thể tạo ra những trải nghiệm AR tuyệt vời.

00:39:47.000 --> 00:39:52.000
Đây là lý do tại sao chúng tôi đã phát hành một bộ công nghệ để giúp bạn dễ dàng bắt đầu với AR.

00:39:52.000 --> 00:40:01.000
Một trong số đó là RealityKit, công cụ kết xuất 3D, âm thanh, hoạt hình và vật lý của chúng tôi được xây dựng từ đầu cho AR.

00:40:01.000 --> 00:40:10.000
RealityKit làm cho việc kết xuất trải nghiệm AR nhập vai trở nên đơn giản, có tính năng kết xuất ảnh chân thực và các hiệu ứng máy ảnh như nhiễu và chuyển động mờ.

00:40:10.000 --> 00:40:21.000
RealityKit cũng tận dụng phần cứng mới nhất của chúng tôi như Máy quét LiDAR, cho phép các đối tượng ảo hoạt động giống như chúng thực sự ở đó với con người và sự tắc đối tượng.

00:40:21.000 --> 00:40:23.000
Và tất cả đều được viết bằng Swift.

00:40:23.000 --> 00:40:37.000
Hôm nay, chúng tôi công bố RealityKit 2, một bản cập nhật lớn cung cấp cho bạn khả năng kiểm soát hình ảnh, âm thanh và hoạt hình nhiều hơn và giải quyết phần khó khăn nhất trong việc tạo ra các ứng dụng AR tuyệt vời - tạo ra các mô hình 3D.

00:40:37.000 --> 00:40:44.000
Nếu bạn đã từng tạo ra một cái trước đây, bạn biết một mô hình duy nhất có thể mất hàng giờ và hàng nghìn đô la để tạo ra.

00:40:44.000 --> 00:40:58.000
Giờ đây, với Object Capture, bạn sẽ có thể tạo các mô hình 3D trong vài phút bằng cách sử dụng iPhone của mình để chụp ảnh 2D của một đối tượng và Object Capture API trên Mac để biến những hình ảnh này thành các mô hình 3D sống động như thật, được tối ưu hóa cho AR.

00:40:58.000 --> 00:41:00.000
Quá trình này thật đơn giản.

00:41:00.000 --> 00:41:11.000
Bạn bắt đầu bằng cách chụp một loạt ảnh bằng iPhone hoặc iPad của mình để chụp tất cả các góc của đối tượng, bao gồm cả phía dưới, bởi vì chúng tôi hỗ trợ lật đối tượng và phân đoạn tiền cảnh tự động.

00:41:11.000 --> 00:41:17.000
Bạn có thể sử dụng các ứng dụng như Qlone, cung cấp các hướng dẫn tuyệt vời để giúp hợp lý hóa quy trình làm việc của bạn.

00:41:17.000 --> 00:41:23.000
Sau đó, sử dụng Object Capture API, chỉ cần một vài dòng mã để tạo mô hình 3D của bạn.

00:41:23.000 --> 00:41:30.000
Bạn bắt đầu một phiên photogrammetry mới trong RealityKit trỏ đến thư mục hình ảnh đã chụp của bạn.

00:41:30.000 --> 00:41:36.000
Sau đó, gọi hàm quy trình để tạo mô hình ở mức độ chi tiết mong muốn.

00:41:36.000 --> 00:41:37.000
Thật dễ dàng!

00:41:37.000 --> 00:41:49.000
Object Capture cho phép bạn tạo các tệp USDZ được tối ưu hóa cho AR Quick Look, vì vậy người dùng có thể xem chúng trong Tin nhắn, Thư, Safari và các ứng dụng khác.

00:41:49.000 --> 00:41:59.000
Bạn cũng có thể tạo các gói tài sản USD hoặc OBJ từ API Object Capture có thể được sử dụng để dò tia và các quy trình làm việc hậu kỳ khác.

00:41:59.000 --> 00:42:03.000
Biến các vật thể trong thế giới thực thành mô hình 3D chưa bao giờ dễ dàng hơn thế.

00:42:03.000 --> 00:42:21.000
Bạn có thể bắt đầu sử dụng Object Capture ngay hôm nay với mã mẫu của chúng tôi và chúng tôi đang làm việc với một số công cụ tạo nội dung 3D hàng đầu để đưa quy trình làm việc này vào nhiều ứng dụng chuyên nghiệp mà bạn đã sử dụng như Unity Mars, Cinema 4D và Qlone, có sẵn vào cuối năm nay.

00:42:21.000 --> 00:42:29.000
Thật dễ dàng để đưa các mô hình Object Capture vào Xcode và sử dụng RealityKit APIs mới để thêm hiệu ứng.

00:42:29.000 --> 00:42:39.000
Nhóm của tôi và tôi đã thử nghiệm Object Capture bằng cách quét các món ăn yêu thích của chúng tôi và chúng tôi đã xây dựng một AR App Clip để chia sẻ công thức nấu ăn của mình, bao gồm bản xem trước AR của món ăn.

00:42:39.000 --> 00:42:52.000
Bánh sừng bò sô cô la mà chúng tôi đã chụp bằng Qlone thực sự là một bản sao ảo của một chiếc bánh sừng bò mà ai đó trong nhóm của tôi đã nướng và tôi muốn thêm nó như một công thức khác vào App Clip của chúng tôi.

00:42:52.000 --> 00:42:58.000
Tôi sẽ bắt đầu bằng cách kéo mô hình 3D của bánh sừng bò vào dự án ARApp của mình.

00:42:58.000 --> 00:43:06.000
Tiếp theo, tôi sẽ neo nó vào Mã clip ứng dụng của mình bằng ARKit và khởi tạo ModelEntity cho tài sản.

00:43:06.000 --> 00:43:15.000
Tôi luôn có thể kiểm tra đầy đủ mô hình 3D trực tiếp trong Xcode Quicklook bất cứ lúc nào trong khi xây dựng dự án của mình, trước khi triển khai clip ứng dụng của tôi.

00:43:15.000 --> 00:43:24.000
Chúng tôi đã sử dụng RealityKit APIs mới trong App Clip của mình để thêm hiệu ứng vào mỗi đĩa AR để làm cho nó thực tế hơn.

00:43:24.000 --> 00:43:32.000
Bởi vì RealityKit là một công cụ kết xuất gốc, chúng tôi có thể phù hợp nhiều cảnh AR hoặc công thức nấu ăn vào App Clip.

00:43:32.000 --> 00:43:39.000
Hãy kiểm tra nó.

00:43:39.000 --> 00:43:46.000
Khi tôi quét Mã Clip Ứng dụng, nó sẽ khởi chạy Clip Ứng dụng và sau đó neo bánh sừng bò sô cô la ngay trên đầu.

00:43:46.000 --> 00:43:55.000
Để làm cho bánh sừng bò chân thực hơn, chúng tôi đã sử dụng bộ đổ bóng bề mặt tùy chỉnh RealityKit mới để thêm ánh sáng phát xạ và kéo lại sự tắc nghẽn xung quanh.

00:43:55.000 --> 00:43:59.000
Chúng ta hãy xem thêm một vài món ăn từ nhóm, như bít tết nướng.

00:43:59.000 --> 00:44:08.000
Ở đây chúng tôi đã thêm vào bộ đổ bóng bề mặt tùy chỉnh bằng cách tạo hiệu ứng hơi nước với API Hình học Thủ tục mới để xếp lớp trong bộ đổ bóng sách lật.

00:44:08.000 --> 00:44:13.000
Bởi vì hơi nước là thủ tục, chúng ta có thể sử dụng hiệu ứng tương tự trên nhiều công thức nấu ăn, như chiếc bánh pizza này.

00:44:13.000 --> 00:44:19.000
Chú ý cách hiệu ứng hơi nước mở rộng theo thủ tục theo kích thước của bánh pizza.

00:44:19.000 --> 00:44:26.000
Đối với món gà nướng này, chúng tôi đã thêm hiệu ứng lửa sau chế biến toàn màn hình để cho biết món này có vị cay.

00:44:26.000 --> 00:44:36.000
Và cuối cùng, chúng tôi đã thả ngọn lửa và thay vào đó sử dụng bộ đổ bóng tính toán mới và công cụ sửa đổi hình học để thêm một số hoa giấy kỷ niệm xung quanh chiếc bánh sinh nhật.

00:44:36.000 --> 00:44:47.000
Như bạn có thể thấy, chúng tôi đã mở kết xuất RealityKit cho nhiều tùy chỉnh hơn và chúng tôi nóng lòng muốn thấy sự sáng tạo của bạn trong cách bạn sử dụng các API mới này.

00:44:47.000 --> 00:44:59.000
Đây chỉ là một số cải tiến mới thú vị mà chúng tôi có cho AR cho phép tất cả các nhà phát triển tạo ra các mô hình 3D để xây dựng trải nghiệm AR nhập vai và sống động như thật hơn.

00:44:59.000 --> 00:45:05.000
Một trong những khía cạnh nền tảng của những gì chúng tôi làm trong ARKit và RealityKit là công nghệ đồ họa của chúng tôi.

00:45:05.000 --> 00:45:09.000
Và Eric sẽ cung cấp cho chúng tôi thông tin cập nhật về những gì mới.

00:45:09.000 --> 00:45:18.000
Ý tưởng cốt lõi về cách chúng tôi xây dựng sản phẩm tại Apple là chúng tôi tập hợp phần cứng và phần mềm tuyệt vời nhất và cách tiếp cận đồ họa của chúng tôi phản ánh lý tưởng đó.

00:45:18.000 --> 00:45:30.000
Trong nhiều năm, chúng tôi đã cung cấp GPU mạnh mẽ do Apple thiết kế cho iPhone và iPad, kết hợp với đồ họa Kim loại và API tính toán của chúng tôi để giúp bạn tận dụng tối đa các sản phẩm của chúng tôi.

00:45:30.000 --> 00:45:52.000
Và bây giờ, với chip M1, chúng tôi không chỉ đang cung cấp mức hiệu suất đồ họa và hiệu suất năng lượng chưa từng có trong các máy Mac và iPad Pro mới nhất của mình, mà chúng tôi còn tạo ra một nền tảng đồ họa thống nhất của Apple với kiến trúc chung dựa trên Metal, GPU của Apple và bộ nhớ thống nhất, trải dài từ iPhone, đến iPad,

00:45:52.000 --> 00:45:55.000
Và nền tảng này cho phép một sự thay đổi cơ bản.

00:45:55.000 --> 00:46:05.000
Khối lượng công việc đồ họa trước đây yêu cầu máy trạm cao cấp hoặc máy tính chơi game GPU rời rạc, giờ đây có thể thực hiện được trên các sản phẩm phổ biến nhất của chúng tôi.

00:46:05.000 --> 00:46:17.000
Ví dụ, hiệu suất cấp bảng điều khiển của nền tảng thống nhất này đã cho phép các nhà phát triển như Larian mang trò chơi AAA của họ, Divinity Original Sin 2, lên Mac và bây giờ là iPad.

00:46:17.000 --> 00:46:27.000
Và Deep Silver đang sử dụng đường ống đổ bóng hiện đại của M1 và Metal để cho phép đồ họa nhập vai, hiệu suất cao trong trò chơi sinh tồn Metro Exodus cho Mac của họ.

00:46:27.000 --> 00:46:31.000
Nhưng nền tảng đồ họa này không chỉ dành cho các trò chơi.

00:46:31.000 --> 00:46:46.000
Các API tính toán kim loại hiện đang tăng tốc thế hệ trình kết xuất GPU chuyên nghiệp tiếp theo, như Octane X hoàn toàn mới từ OTOY và trình kết xuất Redshift của Maxon trong Cinema 4D, lần đầu tiên chạy Metal-accelerated trên Mac.

00:46:46.000 --> 00:47:00.000
Vì vậy, để giúp bạn mang các ứng dụng và trò chơi đồ họa của mình lên tất cả các thiết bị mạnh mẽ của Apple, chúng tôi tập trung vào hai lĩnh vực lớn trong năm nay: các tính năng đồ họa và trò chơi nâng cao và các công cụ phát triển đồ họa mạnh mẽ.

00:47:00.000 --> 00:47:27.000
Đầu tiên, chúng tôi tập trung vào ba tính năng chính cần thiết cho các trò chơi cao cấp hiện đại và các thuật toán kết xuất GPU Để tăng tốc các hoạt động toán học phức tạp, mô hình hóa hành vi của ánh sáng và thể hiện các bề mặt thực tế, các trình kết xuất GPU hiện đại cần xen kẽ đồ họa Metal và các lệnh tính toán trong cùng một đường ống

00:47:27.000 --> 00:47:34.000
Và bạn có thể tạo ra nhiều kết xuất ảnh chân thực hơn nữa với chức năng Stochastic Motion Blur mới trong Metal Ray Tracing API.

00:47:34.000 --> 00:47:42.000
Để các trò chơi đạt được tốc độ khung hình cao hơn với độ trễ thấp hơn và ít rung hơn, các nhà phát triển cần kiểm soát màn hình nhiều hơn.

00:47:42.000 --> 00:47:57.000
Để thực hiện điều này và tận dụng hiệu suất đồ họa tuyệt vời của iPad Pro mới nhất, trò chơi của bạn có thể sử dụng API thời gian trình bày Metal và màn hình ProMotion để tự động điều chỉnh tốc độ khung hình ứng dụng của bạn dựa trên độ trễ mong muốn giữa kết xuất và đầu vào.

00:47:57.000 --> 00:48:02.000
Và macOS Monterey bổ sung hỗ trợ cho Màn hình đồng bộ hóa thích ứng.

00:48:02.000 --> 00:48:10.000
Điều này có nghĩa là bây giờ bạn cũng có thể tận dụng các màn hình độ làm mới có độ trễ cực thấp và thay đổi này cho các trò chơi Mac của mình.

00:48:10.000 --> 00:48:16.000
Giờ đây, các trò chơi cao cấp với đồ họa nâng cao thường được thiết kế xung quanh việc sử dụng bộ điều khiển trò chơi làm đầu vào.

00:48:16.000 --> 00:48:23.000
Và thêm hỗ trợ bộ điều khiển trò chơi là một cách mạnh mẽ và dễ dàng để sử dụng mô hình đầu vào chung để đưa trò chơi của bạn lên nền tảng đồ họa thống nhất của chúng tôi.

00:48:23.000 --> 00:48:35.000
Khung Bộ điều khiển trò chơi của chúng tôi hiện hỗ trợ các bộ điều khiển phổ biến nhất, Bao gồm hỗ trợ Bộ điều khiển không dây Xbox Series X mới nhất và Bộ điều khiển cảm biến kép PlayStation 5, hoàn chỉnh với hỗ trợ xúc giác.

00:48:35.000 --> 00:48:46.000
Để giúp bạn dễ dàng mang các trò chơi dựa trên bộ điều khiển của mình lên iPhone và iPad hơn, chúng tôi đã thêm một API mới để bạn có thể bật Bộ điều khiển trò chơi ảo trên màn hình, chỉ với một vài dòng mã.

00:48:46.000 --> 00:49:04.000
Và hỗ trợ bộ điều khiển trò chơi có giá trị hơn bao giờ hết, bởi vì trong macOS Monterey và iPadOS 15, người chơi có thể tìm thấy các trò chơi mà bạn bè của họ đang chơi, điều hướng trực tiếp đến thư viện ứng dụng để khởi chạy trò chơi và sau đó nhấn nút "Chia sẻ" để ghi lại các điểm nổi bật của trò chơi yêu thích

00:49:04.000 --> 00:49:18.000
Giờ đây, cùng với các API và tính năng nâng cao mới này, Xcode 13 bổ sung các công cụ phát triển đồ họa mới mạnh mẽ để bạn tối ưu hóa và gỡ lỗi mã GPU của mình, mỗi công cụ được thiết kế để đưa các trò chơi và ứng dụng đồ họa cao cấp hiện đại của bạn lên một tầm cao mới.

00:49:18.000 --> 00:49:23.000
Đầu tiên, khi xây dựng các trình kết xuất GPU và trò chơi tiên tiến, các trình đổ bóng GPU có thể trở nên thực sự lớn.

00:49:23.000 --> 00:49:30.000
Gỡ lỗi 10.000 dòng mã đổ bóng trên hàng nghìn nhóm làm việc, tất cả đều chạy song song có thể mất rất nhiều thời gian.

00:49:30.000 --> 00:49:34.000
Để giúp bạn hợp lý hóa quy trình này, Xcode 13 bổ sung tính năng gỡ lỗi Shader có chọn lọc.

00:49:34.000 --> 00:49:41.000
Ở đây, chúng tôi đang sử dụng Gỡ lỗi Shader Chọn lọc để chọn chính xác chức năng nào cần gỡ lỗi, trong một trình tạo bóng GPU lớn hơn nhiều.

00:49:41.000 --> 00:49:51.000
Điều này có thể giảm đáng kể thời gian bạn cần để lặp lại và gỡ lỗi các bộ đổ bóng lớn nhất của mình, cho phép bạn phát triển nhanh hơn và tập trung vào việc thêm các tính năng và hiệu suất vào mã GPU của mình.

00:49:51.000 --> 00:50:18.000
Tiếp theo, các trò chơi AAA cao cấp cũng yêu cầu hỗ trợ nén kết cấu hiện đại mới nhất, đó là lý do tại sao chúng tôi đã cập nhật Công cụ chuyển đổi kết cấu kim loại mạnh mẽ của mình để cung cấp cho bạn quyền kiểm soát trực tiếp đối với quy trình nén chuyển đổi kết cấu, thêm các biến đổi pixel nhận biết gamma hoàn toàn mới và hỗ trợ mở

00:50:18.000 --> 00:50:23.000
Điều này giúp việc tối ưu hóa nội dung kết cấu trò chơi của bạn cho từng thiết bị của Apple trở nên dễ dàng hơn.

00:50:23.000 --> 00:50:33.000
Cuối cùng, để giúp bạn đạt được hiệu suất cao nhất với kết xuất tiên tiến nhất của mình, Xcode 13 bổ sung chế độ xem Dòng thời gian GPU hoàn toàn mới trong Trình gỡ lỗi kim loại.

00:50:33.000 --> 00:50:47.000
Chế độ xem mới mạnh mẽ này cho phép bạn kết hợp tốt nhất việc gỡ lỗi trực quan các lệnh, tài nguyên và bộ đệm Metal của mình, trên dòng thời gian của các sự kiện, ngoài các bộ đếm hiệu suất mạnh mẽ và thông tin phân tích nút cổ chai.

00:50:47.000 --> 00:51:05.000
Với CPU, GPU và Metal của Apple, chúng tôi đã tạo ra một nền tảng đồ họa thống nhất với hơn một tỷ thiết bị, với các tính năng và công cụ phát triển mới nhất để cho phép bạn giải phóng các cấp độ khả năng và hiệu suất hoàn toàn mới cho đồ họa, ứng dụng chuyên nghiệp và trò chơi của mình.

00:51:05.000 --> 00:51:13.000
Và bây giờ trở lại với bạn, Susan.

00:51:13.000 --> 00:51:21.000
Ứng dụng của bạn có thể giúp kết nối mọi người với các ý tưởng, dịch vụ, công cụ và quan trọng nhất là những người khác.

00:51:21.000 --> 00:51:43.000
Tìm kiếm sự cân bằng cũng quan trọng như kết nối, vì vậy năm nay chúng tôi cho phép bạn giúp người dùng tập trung vào ứng dụng của bạn vào đúng thời điểm, quản lý thiết bị của những người thân yêu trong khi tôn trọng quyền riêng tư của họ và biến nội dung ứng dụng của bạn thành trung tâm của những trải nghiệm mới, được chia sẻ, thân mật được xây dựng

00:51:43.000 --> 00:51:49.000
Chúng tôi đã tạo ra một bộ API mới mạnh mẽ sẽ giúp ứng dụng của bạn tạo ra những loại mối quan hệ đó.

00:51:49.000 --> 00:51:53.000
Hãy bắt đầu với Heena và Matt để cho chúng tôi biết về Focus.

00:51:53.000 --> 00:52:00.000
iOS 15 giới thiệu một bộ công cụ mới mạnh mẽ để giúp mọi người tập trung.

00:52:00.000 --> 00:52:04.000
Những công cụ này giúp giảm bớt phiền nhiễu, để mọi người có thể ở trong thời điểm này.

00:52:04.000 --> 00:52:08.000
Và nó bắt đầu với một cách tiếp cận hoàn toàn mới đối với các thông báo.

00:52:08.000 --> 00:52:11.000
Đây là một số thông báo đã chồng chất trên màn hình Khóa của tôi.

00:52:11.000 --> 00:52:14.000
Mức độ khẩn cấp của họ rõ ràng là khác nhau.

00:52:14.000 --> 00:52:17.000
Nhưng tất cả họ đều cư xử giống hệt nhau.

00:52:17.000 --> 00:52:21.000
Họ có cùng một cái nhìn, cùng một xúc giác, cùng một mức độ quan trọng rõ ràng.

00:52:21.000 --> 00:52:29.000
Giờ đây, với API Cấp độ Gián đoạn mới, có nhiều cách sắc thái hơn để các ứng dụng truyền đạt các mức độ cấp bách khác nhau.

00:52:29.000 --> 00:52:32.000
Thông báo có thể được chỉ định một trong bốn cấp độ gián đoạn.

00:52:32.000 --> 00:52:36.000
Gián đoạn thụ động là im lặng và không đánh thức thiết bị.

00:52:36.000 --> 00:52:39.000
Mọi người sẽ gặp họ vào lần tới khi họ nhấc điện thoại lên.

00:52:39.000 --> 00:52:43.000
Bạn có thể muốn sử dụng những thứ này cho các thông báo không nhạy cảm về thời gian.

00:52:43.000 --> 00:52:48.000
Sự gián đoạn chủ động sẽ phát ra âm thanh hoặc xúc giác giống như thông báo hôm nay.

00:52:48.000 --> 00:52:55.000
Gián đoạn nhạy cảm với thời gian được thiết kế để nổi bật một cách trực quan và đi chơi trên màn hình Khóa lâu hơn một chút nếu người dùng chưa nhấn vào nó.

00:52:55.000 --> 00:52:59.000
Chúng cũng sẽ được Siri thông báo nếu ai đó đang đeo AirPods.

00:52:59.000 --> 00:53:04.000
Và bạn sẽ muốn sử dụng cái này cho các thông báo cần chú ý ngay lập tức.

00:53:04.000 --> 00:53:06.000
Cảnh báo quan trọng là loại khẩn cấp nhất.

00:53:06.000 --> 00:53:09.000
Họ sẽ phát âm thanh ngay cả khi thiết bị bị tắt tiếng.

00:53:09.000 --> 00:53:17.000
Những điều này chỉ dành riêng cho những lo ngại nghiêm trọng về sức khỏe và an toàn, và yêu cầu một quyền được phê duyệt.

00:53:17.000 --> 00:53:22.000
Có một loại thông báo khác đáng được chú ý đặc biệt: thông tin liên lạc từ mọi người.

00:53:22.000 --> 00:53:28.000
Nếu bạn có một ứng dụng liên lạc, điều quan trọng là bạn phải thông báo cho hệ thống về tin nhắn và thông báo cuộc gọi của mình.

00:53:28.000 --> 00:53:34.000
Sau đó, hệ thống sẽ sử dụng thông tin này để điều chỉnh giao diện và hành vi của thông báo của bạn, điều này sẽ giúp mọi người diễn giải chúng tốt hơn.

00:53:34.000 --> 00:53:47.000
Sau khi được triển khai, các thông báo của bạn sẽ chuyển từ giao diện tiêu chuẩn sang trông như thế này, có hình đại diện nổi bật với biểu tượng ứng dụng của bạn được đặt chồng lên nhau và các hình đại diện tương tự sẽ được sử dụng ở những nơi khác trong hệ thống, như trong Bảng chia sẻ.

00:53:47.000 --> 00:53:50.000
Tôi rất hào hứng khi thấy những hình đại diện đó!

00:53:50.000 --> 00:53:55.000
Được rồi, vì vậy thông báo là một cách thực sự hiệu quả để thu hút sự chú ý của mọi người.

00:53:55.000 --> 00:53:57.000
Nhưng chúng cũng có thể là một loại phù du.

00:53:57.000 --> 00:54:00.000
Nếu họ không đúng lúc, mọi người có thể dễ dàng bỏ lỡ họ.

00:54:00.000 --> 00:54:12.000
Để giúp người dùng tương tác với các thông báo vào thời gian riêng của họ, chúng tôi đang giới thiệu Tóm tắt thông báo, cung cấp thông báo như một gói hữu ích vào những thời điểm người dùng chọn, để họ có thể nhanh chóng bắt kịp khi nào tốt nhất cho họ.

00:54:12.000 --> 00:54:20.000
Bản tóm tắt gói các thông báo Thụ động và Chủ động từ các ứng dụng do người dùng chọn và trình bày chúng trong một bố cục đẹp mắt.

00:54:20.000 --> 00:54:23.000
Sau đó nó dính xung quanh màn hình Khóa một lúc cho đến khi nó được nhìn thấy.

00:54:23.000 --> 00:54:27.000
Bản tóm tắt cũng được cá nhân hóa cho từng người dùng.

00:54:27.000 --> 00:54:30.000
Như bạn có thể thấy, có hai khe marquee ở trên cùng.

00:54:30.000 --> 00:54:38.000
Những gì nổi bật ở đó dựa trên một vài yếu tố: Đầu tiên, để cung cấp sự đa dạng, hai ứng dụng đó được lấy mẫu từ bên trong bản tóm tắt.

00:54:38.000 --> 00:54:41.000
Từ đó, chúng tôi thực hiện một số trọng số bổ sung.

00:54:41.000 --> 00:54:45.000
Một thông báo có hình thu nhỏ lớn sẽ luôn được chọn thay vì một hình thu nhỏ không có.

00:54:45.000 --> 00:54:52.000
Và thông báo có điểm liên quan cao nhất - đó là điều mà bạn xác định - sẽ được chọn thay vì những thông báo khác từ cùng một ứng dụng.

00:54:52.000 --> 00:55:00.000
Được rồi, vì vậy bạn có thể tự hỏi, "Làm thế nào để ứng dụng của tôi kết thúc trong bản tóm tắt?" Chà, trước tiên, nó hoàn toàn phụ thuộc vào người dùng nếu họ muốn sử dụng bản tóm tắt thông báo.

00:55:00.000 --> 00:55:05.000
Và nếu họ làm vậy, các ứng dụng gửi nhiều thông báo nhất sẽ được đề xuất.

00:55:05.000 --> 00:55:10.000
Sau đó, người dùng có thể tùy chỉnh ứng dụng nào trong bản tóm tắt cùng với thời gian họ sẽ nhận được chúng.

00:55:10.000 --> 00:55:16.000
Nếu ứng dụng của bạn được đặt trong bản tóm tắt đã lên lịch, vẫn có cách để bạn tiếp cận người dùng trong thời gian thực.

00:55:16.000 --> 00:55:20.000
Đó là nơi các thông báo Nhạy cảm về Thời gian xuất hiện.

00:55:20.000 --> 00:55:24.000
Các thông báo sử dụng mức độ gián đoạn này sẽ được gửi ngay lập tức.

00:55:24.000 --> 00:55:31.000
Hãy nhớ rằng, bạn chỉ nên đánh dấu các thông báo là Nhạy cảm với thời gian nếu chúng yêu cầu sự chú ý ngay lập tức và có liên quan vào lúc này.

00:55:31.000 --> 00:55:35.000
Không có tính năng nào loại bỏ phiền nhiễu nhiều hơn Không làm phiền.

00:55:35.000 --> 00:55:40.000
Nhưng Do Not Disturb tắt tiếng tất cả các thông báo và chúng tôi muốn cung cấp cho người dùng sự linh hoạt hơn.

00:55:40.000 --> 00:55:47.000
Với Focus, người dùng có thể chọn các ứng dụng và những người mà họ cần để nhận thông báo dựa trên những gì họ hiện đang làm.

00:55:47.000 --> 00:55:53.000
Họ có thể dành cả ngày của mình cho công việc hoặc tạo Focus cho một hoạt động như chơi game, đọc sách hoặc tập thể dục.

00:55:53.000 --> 00:55:59.000
Trong khi ở Focus, người dùng có thể chia sẻ trạng thái của họ với những người khác, vì vậy họ biết không được làm gián đoạn.

00:55:59.000 --> 00:56:04.000
Nhưng nếu nó thực sự khẩn cấp, dù sao thì một tin nhắn cũng có thể ngắt qua và thông báo.

00:56:04.000 --> 00:56:09.000
Ứng dụng giao tiếp của bạn cũng có thể yêu cầu quyền truy cập vào trạng thái Focus của người dùng.

00:56:09.000 --> 00:56:16.000
Nếu được cấp, hệ thống sẽ thông báo cho ứng dụng của bạn khi nó thay đổi, vì vậy ứng dụng của bạn có thể giữ trạng thái của nó đồng bộ với phần còn lại của hệ thống.

00:56:16.000 --> 00:56:21.000
Ứng dụng của bạn thậm chí có thể cung cấp cho người dùng khả năng đột phá để liên lạc khẩn cấp.

00:56:21.000 --> 00:56:26.000
Chúng tôi đang cung cấp cho người dùng nhiều quyền kiểm soát và linh hoạt hơn bao giờ hết để quản lý thông báo của họ.

00:56:26.000 --> 00:56:34.000
Và để giúp đảm bảo các công cụ này đang hoạt động cho chúng, hệ thống sẽ định kỳ kiểm tra xem liệu một điều chỉnh cụ thể đối với cài đặt của chúng có thể hữu ích hay không.

00:56:34.000 --> 00:56:38.000
Nó dựa trên cách người dùng tương tác với ứng dụng và thông báo của bạn.

00:56:38.000 --> 00:56:46.000
Vì vậy, nếu người dùng thường sử dụng một ứng dụng trong khi ở Focus, thì hệ thống có thể đề xuất cho phép thông báo của ứng dụng đó trong Focus đó.

00:56:46.000 --> 00:56:53.000
Hoặc nếu người dùng đang tương tác với các thông báo Nhạy cảm về Thời gian của ứng dụng, thì hệ thống có thể đề nghị hoàn nguyên chúng trở lại các thông báo đang hoạt động.

00:56:53.000 --> 00:56:59.000
Điều tương tự cũng xảy ra khi một ứng dụng gửi hết thông báo này đến thông báo khác và người dùng không tương tác.

00:56:59.000 --> 00:57:07.000
Hệ thống có thể đề xuất tắt tiếng tất cả các thông báo từ ứng dụng đó hoặc có thể chỉ một cuộc trò chuyện duy nhất trong một khoảng thời gian giới hạn.

00:57:07.000 --> 00:57:11.000
Vì vậy, để tận dụng tối đa các tính năng mới này, có một vài điều quan trọng mà bạn cần làm.

00:57:11.000 --> 00:57:21.000
Bạn có thể giúp đảm bảo nội dung phù hợp được giới thiệu trong các vị trí marquee ở đầu bản tóm tắt bằng cách đặt điểm liên quan trên thông báo của bạn và đính kèm các hình thu nhỏ thích hợp.

00:57:21.000 --> 00:57:26.000
Bạn nên suy nghĩ cẩn thận về mức độ gián đoạn nào có ý nghĩa đối với các thông báo của bạn.

00:57:26.000 --> 00:57:33.000
Nếu bạn có một ứng dụng liên lạc, bạn nên áp dụng API Thông báo Người dùng mới để thông báo cho hệ thống về thông báo tin nhắn và cuộc gọi của bạn.

00:57:33.000 --> 00:57:39.000
Bạn cũng nên phản ánh Tiêu điểm của người dùng trong ứng dụng của mình bằng cách sử dụng API Trạng thái Tiêu điểm mới.

00:57:39.000 --> 00:57:45.000
Chúng tôi nghĩ rằng những công cụ này, với sự giúp đỡ của bạn, sẽ đi một chặng đường dài trong việc giúp người dùng giảm bớt phiền nhiễu.

00:57:45.000 --> 00:57:49.000
Tiếp theo, Martin sẽ cho chúng tôi biết về API Screen Time mới.

00:57:49.000 --> 00:57:50.000
Cảm ơn, Matt.

00:57:50.000 --> 00:57:55.000
Được rồi, hãy chuyển sang bánh răng để nói về Thời gian sử dụng thiết bị và kiểm soát của phụ huynh.

00:57:55.000 --> 00:58:04.000
Chúng tôi nhận ra rằng cha mẹ cần các giải pháp hiện đại, sáng tạo để giúp con cái họ xây dựng cuộc sống kỹ thuật số lành mạnh và họ cũng coi trọng quyền riêng tư của gia đình.

00:58:04.000 --> 00:58:09.000
Và chúng tôi đã thấy sự thèm muốn từ nhiều người trong số các bạn để đáp ứng những nhu cầu của người dùng này.

00:58:09.000 --> 00:58:18.000
Vì vậy, hôm nay, chúng tôi sẽ phát hành Screen Time API, một tập hợp các khuôn khổ kiểm soát của phụ huynh được thiết kế riêng dựa trên cam kết sâu sắc của chúng tôi đối với quyền riêng tư.

00:58:18.000 --> 00:58:22.000
Chúng tôi đã có ba mục tiêu chính trong đầu với API Thời gian sử dụng.

00:58:22.000 --> 00:58:26.000
Để cung cấp cho bạn các giải pháp hiện đại để phát triển các ứng dụng kiểm soát của phụ huynh.

00:58:26.000 --> 00:58:32.000
Để trao quyền cho bạn xây dựng những trải nghiệm năng động và đổi mới vượt xa những gì mà Screen Time cung cấp ngày nay.

00:58:32.000 --> 00:58:35.000
Và để bảo vệ quyền riêng tư của người dùng.

00:58:35.000 --> 00:58:47.000
Cuối cùng, chúng tôi đã thêm ba khung Swift mới vào SDK iOS cho phép bạn đổi mới trong thế giới kiểm soát của phụ huynh: Cài đặt được quản lý, Kiểm soát gia đình và Hoạt động thiết bị.

00:58:47.000 --> 00:58:50.000
Đầu tiên, hãy nói về Cài đặt được Quản lý.

00:58:50.000 --> 00:59:01.000
Về cơ bản, ứng dụng kiểm soát của phụ huynh của bạn cần một cách để hạn chế những gì trẻ có thể làm trên các thiết bị của chúng và đảm bảo rằng những hạn chế đó vẫn được giữ nguyên cho đến khi phụ huynh nói khác.

00:59:01.000 --> 00:59:14.000
Với Cài đặt được quản lý, ứng dụng của bạn có thể đặt một số hạn chế như khóa tài khoản tại chỗ, ngăn chặn thay đổi mật khẩu, lọc lưu lượng truy cập web và giới hạn quyền truy cập vào các ứng dụng, giống như Thời gian sử dụng.

00:59:14.000 --> 00:59:18.000
Được tùy chỉnh với thương hiệu và chức năng của ứng dụng của bạn.

00:59:18.000 --> 00:59:24.000
Bằng cách tận dụng khuôn khổ này, ứng dụng của bạn sẽ có thể quản lý tất cả những hạn chế này.

00:59:24.000 --> 00:59:33.000
Ngoài các hạn chế, bạn sẽ có thể giới hạn quyền truy cập vào các ứng dụng và trang web khi thích hợp và cung cấp một tập hợp các hành động duy nhất cho các trường hợp sử dụng của bạn.

00:59:33.000 --> 00:59:43.000
Và cuối cùng, chúng tôi khóa ứng dụng tại chỗ để nó chỉ có thể được xóa khi có sự chấp thuận rõ ràng của phụ huynh.

00:59:43.000 --> 00:59:50.000
Giờ đây, khung Kiểm soát Gia đình là trung tâm của mô hình quyền riêng tư của chúng tôi và nó phục vụ hai trải nghiệm chính đối mặt với người dùng.

00:59:50.000 --> 00:59:58.000
Đầu tiên, nó cho phép phụ huynh ủy quyền cho ứng dụng của bạn quản lý với thông tin đăng nhập iCloud của họ, đảm bảo rằng thiết bị dành cho một đứa trẻ trong gia đình đó.

00:59:58.000 --> 01:00:10.000
Và nó cung cấp trải nghiệm được cá nhân hóa thông qua công cụ chọn Ứng dụng &amp; Trang web hệ thống, cho phép phụ huynh chọn ứng dụng và trang web nào nên bị hạn chế, đồng thời bảo vệ quyền riêng tư của người dùng.

01:00:10.000 --> 01:00:21.000
Chúng tôi muốn cho phép phụ huynh quản lý và hạn chế các ứng dụng và trang web mà con cái họ sử dụng, nhưng làm như vậy theo cách không tiết lộ ứng dụng riêng tư và chi tiết duyệt web của họ.

01:00:21.000 --> 01:00:28.000
Vì vậy, thay vì trả về một lựa chọn các ID và URL gói thô, thay vào đó, trình chọn sẽ trả về các mã thông báo mờ đục.

01:00:28.000 --> 01:00:40.000
Những mã thông báo này cho phép ứng dụng của bạn theo dõi những ứng dụng và trang web mà phụ huynh muốn quản lý, đồng thời đảm bảo rằng phụ huynh là những người duy nhất có thể truy cập thông tin nhạy cảm cao này.

01:00:40.000 --> 01:00:44.000
Và những mã thông báo này cho phép chức năng trên tất cả các khuôn khổ này.

01:00:44.000 --> 01:00:58.000
Sử dụng mã thông báo để giới hạn quyền truy cập vào một ứng dụng hoặc trang web cụ thể với Cài đặt được quản lý hoặc hiểu rõ hơn về hoạt động của ứng dụng và trang web, điều không thể thực hiện được trên iOS cho đến ngày hôm nay, với khung Hoạt động thiết bị.

01:00:58.000 --> 01:01:06.000
Với các mã thông báo được cung cấp bởi Trình chọn hoạt động trong Kiểm soát gia đình, bạn đã sẵn sàng tận dụng sức mạnh của Hoạt động thiết bị.

01:01:06.000 --> 01:01:15.000
Bạn có thể đăng ký các cửa sổ thời gian duy nhất cho các ứng dụng và hoạt động khác nhau, mỗi cửa sổ phát ra một cảnh báo như, "Cài năm phút nữa" và một sự kiện hoàn thành.

01:01:15.000 --> 01:01:25.000
Khi ứng dụng của bạn nhận được những sự kiện này, nó có thể phản ứng tương ứng bằng cách thay đổi các hạn chế, hạn chế quyền truy cập vào các ứng dụng và trang web có liên quan hoặc...

01:01:25.000 --> 01:01:28.000
Khuyến khích trẻ em làm bài tập về nhà.

01:01:28.000 --> 01:01:33.000
Bất kỳ trải nghiệm nào bạn đang cố gắng cung cấp cho người dùng của mình.

01:01:33.000 --> 01:01:46.000
Khái niệm xem hoạt động của thiết bị, không chỉ hoạt động của trình duyệt, mà trên tất cả các ứng dụng trên thiết bị là hoàn toàn mới và là cơ hội duy nhất để bạn đổi mới trong thế giới kiểm soát của phụ huynh.

01:01:46.000 --> 01:01:57.000
Với API Thời gian sử dụng màn hình, bạn có thể bật thời gian chết trên toàn gia đình hoặc thậm chí tạo động lực để làm điều gì đó thú vị sau một cái gì đó mang tính giáo dục, như mở khóa một số trò chơi sau khi làm một số bài tập về nhà.

01:01:57.000 --> 01:02:05.000
Chúng tôi rất vui khi thấy bạn sẽ xây dựng như thế nào trên các API này để giúp phụ huynh và gia đình quản lý cách họ sử dụng thiết bị của chúng tôi.

01:02:05.000 --> 01:02:09.000
Và bây giờ đến Vi để cho chúng tôi biết có gì mới với Widgets.

01:02:09.000 --> 01:02:13.000
Năm ngoái, chúng tôi đã giới thiệu Widgets trên Màn hình chính.

01:02:13.000 --> 01:02:15.000
Và mọi người yêu thích chúng.

01:02:15.000 --> 01:02:24.000
Tiện ích cung cấp cá nhân hóa sâu sắc với chế độ xem thú vị và kịp thời về nội dung phù hợp nhất từ ứng dụng của bạn.

01:02:24.000 --> 01:02:27.000
Tất cả đều là về khả năng nhìn thoáng qua.

01:02:27.000 --> 01:02:36.000
Mọi người thích cách các tiện ích trình bày thông tin hữu ích nhất từ ứng dụng của bạn, trong nháy mắt, vào đúng thời điểm.

01:02:36.000 --> 01:02:39.000
Một cú chạm có thể liên kết sâu ngay đến phần bên phải của ứng dụng của bạn.

01:02:39.000 --> 01:02:46.000
Trong năm qua, bạn đã tạo ra một số trải nghiệm tiện ích tuyệt vời đã thực sự truyền cảm hứng cho chúng tôi.

01:02:46.000 --> 01:02:52.000
Các tiện ích tốt nhất được tập trung, năng động và cung cấp chế độ xem độc đáo của ứng dụng suốt cả ngày.

01:02:52.000 --> 01:02:54.000
Giống như cái này, từ Ngày đầu tiên.

01:02:54.000 --> 01:02:57.000
Đó là tôi và các con tôi trong chuyến đi đến Santa Cruz.

01:02:57.000 --> 01:03:06.000
Hiển thị đúng phần nội dung trong đúng ngữ cảnh giúp người dùng khám phá sự kỳ diệu của các ứng dụng của bạn.

01:03:06.000 --> 01:03:12.000
Và chúng tôi đã thấy rằng các tiện ích khuyến khích mọi người sử dụng ứng dụng của bạn nhiều hơn.

01:03:12.000 --> 01:03:20.000
Năm nay, chúng tôi đang thực hiện bước tiếp theo trong việc làm cho các ứng dụng của bạn hữu ích hơn và dễ khám phá hơn với các tiện ích.

01:03:20.000 --> 01:03:28.000
Và nó bắt đầu với việc cho phép mọi người đặt các tiện ích giữa các ứng dụng của bạn trên Màn hình chính của iPad.

01:03:28.000 --> 01:03:36.000
Để tận dụng lợi thế của màn hình lớn, chúng tôi đang giới thiệu một kích thước cực lớn mới cho các vật dụng.

01:03:36.000 --> 01:03:45.000
Điều này có nghĩa là một tập hợp các cơ hội hoàn toàn mới cho các loại tiện ích hoàn toàn mới hoạt động tốt nhất trên iPad.

01:03:45.000 --> 01:03:56.000
Để giúp việc truy cập các tiện ích trở nên dễ dàng hơn, chúng tôi đang thêm bố cục Màn hình chính mặc định mới với các tiện ích trên iPhone và iPad.

01:03:56.000 --> 01:04:02.000
Chúng bao gồm các tiện ích từ các ứng dụng mà mọi người sử dụng nhiều nhất, được sắp xếp trong Smart Stacks.

01:04:02.000 --> 01:04:07.000
Các ngăn xếp cho phép bạn tiết kiệm không gian bằng cách đặt nhiều vật dụng chồng lên nhau.

01:04:07.000 --> 01:04:14.000
Smart Stacks sử dụng trí thông minh trên thiết bị để hiển thị tiện ích phù hợp nhất hiện nay.

01:04:14.000 --> 01:04:24.000
Dựa trên nền tảng của TimelineRelevance API năm ngoái, chúng tôi không chỉ đơn giản là xoay ngăn xếp với trí thông minh trên thiết bị.

01:04:24.000 --> 01:04:32.000
Bây giờ chúng tôi có thể cung cấp cho tiện ích của bạn nhiều tiếp xúc hơn bằng cách đề xuất nó ngay cả khi nó chưa có trong ngăn xếp.

01:04:32.000 --> 01:04:33.000
Và làm thế nào để chúng ta làm điều này?

01:04:33.000 --> 01:04:36.000
Nhập đề xuất tiện ích.

01:04:36.000 --> 01:04:43.000
Cách mọi người tương tác với ứng dụng của bạn, cũng như những gì bạn có thể cho chúng tôi biết, giúp chúng tôi đề xuất tiện ích của bạn trong một ngăn xếp.

01:04:43.000 --> 01:04:48.000
Hãy để chúng tôi xem điều này hoạt động như thế nào với ứng dụng ví dụ Fruta của chúng tôi.

01:04:48.000 --> 01:04:55.000
Nếu người dùng gọi nước ép xanh mỗi sáng, trí thông minh trên thiết bị sẽ học cách đề xuất nó.

01:04:55.000 --> 01:05:00.000
Để chọn tham gia, bạn sẽ cần áp dụng khung ý định và quyên góp Tương tác.

01:05:00.000 --> 01:05:01.000
Thế là xong!

01:05:01.000 --> 01:05:07.000
Giờ đây tiện ích của bạn có thể được đề xuất tự động dựa trên cách mọi người sử dụng ứng dụng của bạn.

01:05:07.000 --> 01:05:13.000
Khi bạn muốn cung cấp thông tin mới cho người dùng, bạn cũng có thể quyên góp bằng cách sử dụng Intents API.

01:05:13.000 --> 01:05:20.000
Ví dụ, ứng dụng Fruta có thể áp dụng điều này để cung cấp sinh tố sinh nhật miễn phí.

01:05:20.000 --> 01:05:30.000
Cả hành vi sử dụng trong quá khứ, cũng như các khoản đóng góp có ý định liên quan mới sau đó có thể giúp chúng tôi đề xuất tiện ích của bạn trong một ngăn xếp vào đúng thời điểm.

01:05:30.000 --> 01:05:36.000
Và nếu người dùng thấy tiện ích của bạn hữu ích, họ có thể dễ dàng thêm nó vĩnh viễn chỉ bằng cách nhấn và giữ.

01:05:36.000 --> 01:05:40.000
Vì vậy, đó là bản cập nhật lớn của chúng tôi cho các tiện ích trong năm nay.

01:05:40.000 --> 01:05:44.000
Hữu ích hơn và dễ khám phá hơn bao giờ hết.

01:05:44.000 --> 01:05:48.000
Tiếp theo là một số tin tức trên SharePlay.

01:05:48.000 --> 01:05:50.000
Đến chỗ Ryan và Juan.

01:05:50.000 --> 01:05:55.000
Năm nay, tất cả chúng ta đã phải ứng biến để tìm ra những cách kết nối mới.

01:05:55.000 --> 01:06:02.000
Và thật ấn tượng khi thấy nhiều người trong số các bạn đổi mới và xây dựng những cách mới tuyệt vời để mọi người cảm nhận được cảm giác đoàn kết khi ở xa.

01:06:02.000 --> 01:06:13.000
Và với những người dựa vào FaceTime và iMessage hơn bao giờ hết để duy trì kết nối, việc chúng tôi xây dựng dựa trên những trải nghiệm đó là điều tự nhiên, để giúp mọi người cảm thấy bên nhau hơn khi họ xa nhau.

01:06:13.000 --> 01:06:21.000
Một số khoảnh khắc ý nghĩa nhất mà mọi người có với nhau không chỉ là chia sẻ một cuộc trò chuyện mà còn là chia sẻ kinh nghiệm.

01:06:21.000 --> 01:06:26.000
Vì vậy, để nuôi dưỡng cảm giác gần gũi đó, chúng tôi cần xây dựng một cái gì đó hoàn toàn mới.

01:06:26.000 --> 01:06:28.000
Và chúng tôi đã có một mục tiêu đầy tham vọng.

01:06:28.000 --> 01:06:36.000
Chúng tôi muốn FaceTime cảm thấy như một cổng thông tin đưa mọi người vào cùng một không gian với một số người bạn thân nhất và gia đình của họ.

01:06:36.000 --> 01:06:38.000
Vì vậy chúng tôi đã xây dựng SharePlay.

01:06:38.000 --> 01:06:44.000
Và chúng tôi đã cung cấp cho bạn các công cụ bạn cần để tạo ra trải nghiệm SharePlay kỳ diệu với khuôn khổ GroupActivities mới.

01:06:44.000 --> 01:06:47.000
Chúng tôi mang nhóm đến, bạn mang đến các hoạt động.

01:06:47.000 --> 01:06:51.000
Và tất cả đều phụ thuộc vào khái niệm hoạt động này.

01:06:51.000 --> 01:07:03.000
Khi ai đó trong cuộc gọi FaceTime bắt đầu một hoạt động, SharePlay sẽ đưa nhóm trực tiếp vào ứng dụng của bạn, cho phép trải nghiệm tương tác phong phú nơi người dùng có thể giao tiếp, giống như họ đã quen.

01:07:03.000 --> 01:07:07.000
Có rất nhiều khả năng để khám phá với khuôn khổ Hoạt động Nhóm.

01:07:07.000 --> 01:07:16.000
Và còn hoạt động nào tốt hơn để làm trong phòng khách ảo của bạn hơn là xem các chương trình yêu thích của bạn với một số người bạn thân nhất của bạn.

01:07:16.000 --> 01:07:21.000
Này, Juan, vì nhóm của bạn vừa hoàn thành việc tích hợp SharePlay vào ứng dụng TV, tại sao bạn không chỉ cho chúng tôi xung quanh?

01:07:21.000 --> 01:07:23.000
Chắc chắn rồi! Bạn muốn xem gì?

01:07:23.000 --> 01:07:25.000
Làm thế nào về một chút "Ted Lasso"?

01:07:25.000 --> 01:07:27.000
Nghe hay đấy.

01:07:27.000 --> 01:07:32.000
Tôi nhấn phát và hệ thống hỏi tôi có muốn bắt đầu phát lại được chia sẻ hay thay vào đó phát cục bộ không.

01:07:32.000 --> 01:07:34.000
Đây là nơi bạn bước vào.

01:07:34.000 --> 01:07:40.000
Chúng tôi đang cung cấp các API mới để bắt đầu phát lại được thiết kế để phù hợp với trải nghiệm video hiện có của ứng dụng của bạn.

01:07:40.000 --> 01:07:49.000
Bây giờ vì tôi đã chọn phát lại được chia sẻ, hệ thống đang phối hợp video trên thiết bị của tôi và Ryan cùng lúc với Core Media và Group Activities đang thực hiện công việc nặng nhọc.

01:07:49.000 --> 01:07:55.000
Điều đó có nghĩa là khi tôi nhấn tạm dừng, video của Juan sẽ tạm dừng vào cùng một thời điểm.

01:07:55.000 --> 01:08:01.000
Tôi thậm chí có thể nhảy đến một cảnh yêu thích và mọi người đi cùng tôi, như thể tất cả chúng ta đều ở trong cùng một phòng.

01:08:01.000 --> 01:08:03.000
Được chứ? Ý tôi là, này, Higgins và tôi đang ăn trưa hôm nay.

01:08:03.000 --> 01:08:06.000
Tôi thích cảnh này!

01:08:06.000 --> 01:08:11.000
Điều kỳ diệu đằng sau sự phối hợp phát lại này có nghĩa là phương tiện của bạn không được truyền lại theo bất kỳ cách nào.

01:08:11.000 --> 01:08:17.000
Mọi người sẽ nhận được video toàn bộ độ trung thực của bạn vì nó đang phát trong ứng dụng của bạn và phát trực tuyến từ máy chủ của bạn như mọi khi.

01:08:17.000 --> 01:08:25.000
Bây giờ, hãy xem việc áp dụng Hoạt động Nhóm trong một ứng dụng đa phương tiện đơn giản dễ dàng như thế nào và tận dụng tối đa khuôn khổ.

01:08:25.000 --> 01:08:28.000
Chỉ có một vài bước để chuẩn bị sẵn sàng ứng dụng của bạn để phát lại được chia sẻ.

01:08:28.000 --> 01:08:32.000
Đầu tiên, chúng ta cần xác định Hoạt động Nhóm của mình.

01:08:32.000 --> 01:08:38.000
Chúng tôi sẽ tạo một loại mới phù hợp với giao thức Hoạt động Nhóm và cung cấp URL cho mọi người trong nhóm tải.

01:08:38.000 --> 01:08:43.000
Nếu ứng dụng của bạn đã hỗ trợ các liên kết sâu đến nội dung, bạn có thể sử dụng chúng ở đây.

01:08:43.000 --> 01:08:51.000
Chúng tôi cũng sẽ cung cấp một số siêu dữ liệu cơ bản cho hệ thống để tùy chỉnh giao diện người dùng hệ thống như hộp thoại xác nhận và thông báo.

01:08:51.000 --> 01:08:54.000
Tiếp theo, chúng ta cần kết nối các nút phát của mình.

01:08:54.000 --> 01:08:59.000
Trong hàm play() của chúng tôi, chúng tôi sẽ tạo một hoạt động mới và gọi .prepareForActivation() trên đó.

01:08:59.000 --> 01:09:03.000
Đây là khi hệ thống trình bày hộp thoại xác nhận mà bạn đã thấy trước đó.

01:09:03.000 --> 01:09:05.000
Bạn có thể gọi cái này mà không cần thêm bất kỳ điều kiện nào.

01:09:05.000 --> 01:09:08.000
Nó sẽ quay lại ngay lập tức nếu người dùng không thực hiện cuộc gọi FaceTime.

01:09:08.000 --> 01:09:12.000
Bây giờ chúng ta hãy chuyển sự chú ý của chúng ta sang việc xử lý các hoạt động sắp tới.

01:09:12.000 --> 01:09:18.000
Người khởi xướng tham gia phiên họp giống như những người tham gia khác, vì vậy mã trông giống nhau đối với mọi người.

01:09:18.000 --> 01:09:24.000
Ở đây, tôi đang sử dụng Swift concurrency để tạo ra một mô hình mới với mỗi phiên được phân phối.

01:09:24.000 --> 01:09:28.000
Sau đó chúng tôi sẽ tham gia phiên mới khi người chơi xuất hiện.

01:09:28.000 --> 01:09:33.000
Bạn có thể quan sát phiên cho các thay đổi trạng thái khác để cập nhật giao diện người dùng của chúng tôi cho phù hợp.

01:09:33.000 --> 01:09:36.000
Cuối cùng, hãy đảm bảo rằng chúng tôi đồng bộ hóa người chơi của mình.

01:09:36.000 --> 01:09:43.000
Bước 1: Lấy AVPlayer của bạn và gọi .playbackCoordinator.coordinate WithSession vượt qua trong phiên của bạn.

01:09:43.000 --> 01:09:46.000
Bước 2: Không có bước 2.

01:09:46.000 --> 01:09:47.000
Thế là xong!

01:09:47.000 --> 01:09:53.000
Đó là tất cả những gì bạn cần làm để đồng bộ AV chính xác với khung hình Hoạt động nhóm và AVPlayer.

01:09:53.000 --> 01:09:55.000
Hệ thống xử lý phần còn lại.

01:09:55.000 --> 01:09:59.000
Bây giờ chúng ta đã nói rất nhiều về trải nghiệm truyền thông được chia sẻ.

01:09:59.000 --> 01:10:06.000
Nhưng chúng tôi muốn Hoạt động Nhóm cung cấp một nền tảng có thể cung cấp năng lượng cho ngay cả những trải nghiệm tham vọng nhất mà bạn có thể mơ ước.

01:10:06.000 --> 01:10:14.000
Vì vậy, chúng tôi đã bắt đầu xây dựng trên kết cấu cung cấp năng lượng cho FaceTime Nhóm ngày hôm nay, cung cấp cho ứng dụng của bạn một kênh dữ liệu nhanh và đáng tin cậy.

01:10:14.000 --> 01:10:20.000
Bằng cách đảm nhận công việc là trưởng nhóm, các máy chủ của chúng tôi sắp xếp một trạng thái tập trung cho toàn bộ nhóm.

01:10:20.000 --> 01:10:26.000
Các máy chủ này không nhìn thấy dữ liệu người dùng của bạn, bởi vì tất cả đều được mã hóa đầu cuối để nó luôn ở chế độ riêng tư.

01:10:26.000 --> 01:10:38.000
Và sử dụng kênh dữ liệu nhanh chóng và an toàn này, bạn có thể tạo ra những trải nghiệm nhập vai, từ lật trang trên một cuốn sách được chia sẻ, đến việc xem trực tiếp những nét vẽ mà ai đó đã vẽ trên bảng trắng được chia sẻ.

01:10:38.000 --> 01:10:45.000
Chúng tôi muốn thực sự truyền cảm hứng cho bạn tận dụng tối đa các API của chúng tôi và mang người dùng của bạn lại với nhau hơn bao giờ hết.

01:10:45.000 --> 01:10:53.000
Nhưng trước khi chúng tôi cho bạn xem bản demo, chúng tôi sẽ cần gọi thêm một chút trợ giúp với bản demo này.

01:10:53.000 --> 01:10:55.000
Này, mọi người. Cảm ơn vì đã tham gia.

01:10:55.000 --> 01:11:00.000
Chúng tôi sẽ cần sự giúp đỡ của bạn với bản demo cuối cùng này để thực sự chứng minh sức mạnh của Hoạt động Nhóm.

01:11:00.000 --> 01:11:06.000
Được rồi, chúng tôi có một ứng dụng demo bảng trắng để cho bạn thấy những gì có thể được thực hiện với Hoạt động Nhóm.

01:11:06.000 --> 01:11:12.000
Bây giờ, bằng cách mở một bức tranh được chia sẻ, tôi đang bắt đầu một hoạt động mới với nhóm để vẽ cùng nhau.

01:11:12.000 --> 01:11:17.000
Bây giờ tất cả chúng ta đang nhìn vào cùng một bức tranh và chúng ta có thể tương tác với nhau theo một cách hoàn toàn mới.

01:11:17.000 --> 01:11:22.000
Nếu tôi vẽ ở đâu đó trên khung vẽ, mọi người có thể thấy những gì tôi đang vẽ trực tiếp.

01:11:22.000 --> 01:11:32.000
Bây giờ ứng dụng này đang sử dụng cùng một API mà bạn đã thấy trước đây, nhưng thay vì đồng bộ hóa phương tiện, nó đang sử dụng GroupSessionMessenger để gửi các nét của tôi đến thiết bị của mọi người.

01:11:32.000 --> 01:11:34.000
Và đây không phải là chia sẻ màn hình.

01:11:34.000 --> 01:11:39.000
Bởi vì ứng dụng đang chạy nguyên bản trên iPad của mọi người, tôi cũng có thể vẽ trên khung vẽ.

01:11:39.000 --> 01:11:49.000
Tất cả chúng ta hãy thử nó.

01:11:49.000 --> 01:11:53.000
Vì vậy, chúng ta có thể tập hợp xung quanh một bức tranh được chia sẻ bất kể chúng ta cách nhau bao xa.

01:11:53.000 --> 01:11:59.000
Và nó mang chúng ta lại với nhau hơn bao giờ hết.

01:11:59.000 --> 01:12:02.000
Cảm ơn vì sự giúp đỡ, mọi người.

01:12:02.000 --> 01:12:14.000
Phần hay nhất là, mọi thứ bạn vừa thấy - các hoạt động SharePlay, đồng bộ hóa phát lại và kênh dữ liệu nhanh, an toàn - bạn nhận được tất cả những lợi ích này chỉ bằng cách tích hợp ứng dụng của mình với khung GroupActivities.

01:12:14.000 --> 01:12:20.000
SharePlay là một cách mới tuyệt vời để nâng cao nội dung ứng dụng của bạn và giúp bạn tạo ra trải nghiệm nhập vai hơn cho người dùng của mình.

01:12:20.000 --> 01:12:26.000
Chúng tôi rất háo hức được xem những trải nghiệm được chia sẻ mới mà bạn sẽ nghĩ ra bằng cách sử dụng Hoạt động nhóm.

01:12:26.000 --> 01:12:33.000
Bây giờ, hãy đến Susan để kết thúc mọi thứ.

01:12:33.000 --> 01:12:39.000
Chúng tôi tin rằng những tiến bộ mà bạn thấy hôm nay sẽ giúp bạn tiếp tục xây dựng các ứng dụng tạo ra sự khác biệt.

01:12:39.000 --> 01:12:45.000
Chúng tôi đang xây dựng các công cụ hợp lý hóa quy trình làm việc của bạn và giúp xây dựng các ứng dụng tuyệt vời nhanh hơn dễ dàng hơn.

01:12:45.000 --> 01:12:50.000
Chúng tôi đã giúp việc xây dựng nội dung, trò chơi và công cụ nhập vai cho những người sáng tạo chuyên nghiệp trở nên dễ dàng hơn.

01:12:50.000 --> 01:12:57.000
Chúng tôi đã chỉ cho bạn cách các ứng dụng của bạn có thể giúp người dùng kết nối trong khi vẫn tập trung vào những điều quan trọng nhất.

01:12:57.000 --> 01:13:00.000
Những gì bạn đã thấy hôm nay chỉ là sự khởi đầu.

01:13:00.000 --> 01:13:06.000
Có rất nhiều thứ để kiểm tra trong tuần này mà chúng tôi thậm chí còn chưa có cơ hội để chạm vào.

01:13:06.000 --> 23:59:59.000
Chúng tôi biết bạn sẽ xây dựng một cái gì đó tuyệt vời, và chúng tôi nóng lòng muốn xem nó.

