WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:14.000
Xin chào! Tôi là Nicole, và chào mừng đến với "Có gì mới trong Swift."

00:00:14.000 --> 00:00:17.000
Swift 5.5 là bản phát hành tốt nhất của chúng tôi!

00:00:17.000 --> 00:00:33.000
Ngôn ngữ Swift tiếp tục phát triển với tốc độ nhanh chóng, với nhiều tính năng mới, bao gồm Swift Concurrency, một mô hình mới cho lập trình không đồng bộ và đồng thời được thiết kế để làm cho lập trình đồng thời trong Swift thuận tiện, hiệu quả và an toàn.

00:00:33.000 --> 00:00:46.000
Ngoài ra, chúng tôi đã giúp phát triển Swift dễ dàng hơn bao giờ hết, nhờ những tiến bộ trong trải nghiệm gói, các gói thư viện tiêu chuẩn mới và các tính năng nâng cao trải nghiệm của nhà phát triển.

00:00:46.000 --> 00:00:56.000
Quan trọng như những tiến bộ này, trọng tâm của dự án Swift không phải là mã, mà là một cộng đồng những người làm việc hướng tới các mục tiêu của dự án Swift.

00:00:56.000 --> 00:01:01.000
Đây là lý do tại sao điều quan trọng là chúng tôi đầu tư vào cộng đồng cũng như phần mềm của mình.

00:01:01.000 --> 00:01:06.000
Tôi muốn bắt đầu mọi thứ bằng cách nói về một sáng kiến cộng đồng Swift quan trọng.

00:01:06.000 --> 00:01:10.000
Sự đa dạng là giá trị cốt lõi của cộng đồng Swift.

00:01:10.000 --> 00:01:16.000
Nghiên cứu cho thấy các dự án nguồn mở đa dạng có năng suất cao hơn và đưa ra quyết định tốt hơn.

00:01:16.000 --> 00:01:23.000
Bao gồm mọi người từ mọi nguồn gốc và với quan điểm đa dạng giúp cộng đồng phát triển.

00:01:23.000 --> 00:01:35.000
Chúng tôi, và các thành viên khác của cộng đồng Swift, đã nhìn thấy cơ hội để khuyến khích sự tham gia tích cực vào hệ sinh thái và cộng đồng Swift từ nhiều nhà phát triển hơn với sáng kiến Đa dạng trong Swift của chúng tôi.

00:01:35.000 --> 00:01:50.000
Nhiệm vụ của Đa dạng trong Swift là thúc đẩy một cộng đồng Swift hòa nhập bằng cách nâng cao nhiều tiếng nói khác nhau và giúp các nhà phát triển bắt đầu học hỏi hoặc đóng góp cho Swift dễ dàng hơn, bất kể nền tảng của họ.

00:01:50.000 --> 00:02:01.000
Là một phần của sáng kiến này, chúng tôi đã mở rộng blog swift.org để bao gồm các bài đăng ghi nhận và làm nổi bật những đóng góp từ nhiều nhà phát triển trong cộng đồng của chúng tôi.

00:02:01.000 --> 00:02:10.000
Chúng tôi cũng đã tạo ra các nhóm cộng đồng trong diễn đàn Swift để các nhà phát triển kết nối với những người khác có thể đã có trải nghiệm tương tự hoặc phải đối mặt với những rào cản tương tự.

00:02:10.000 --> 00:02:18.000
Để tham gia vào Diversity in Swift, hoặc tìm hiểu thêm, vui lòng truy cập swift.org/diversity.

00:02:18.000 --> 00:02:24.000
Chúng tôi cũng muốn giúp các nhà phát triển đã có trong cộng đồng phát triển và đạt được mục tiêu của họ với Swift.

00:02:24.000 --> 00:02:35.000
Để giúp việc đóng góp cho các dự án nguồn mở Swift trở nên dễ tiếp cận hơn, gần đây chúng tôi đã công bố chương trình cố vấn Swift để giúp những người mới đến nhận được sự hỗ trợ và hướng dẫn trực tiếp từ những người đóng góp thường xuyên.

00:02:35.000 --> 00:02:38.000
Chương trình này không giới hạn trong các dự án của Apple.

00:02:38.000 --> 00:02:44.000
Nó cũng bao gồm toàn bộ hệ sinh thái của các gói Swift và các công cụ nguồn mở.

00:02:44.000 --> 00:02:48.000
Tiếp theo, tôi muốn nói về các gói hàng.

00:02:48.000 --> 00:02:56.000
Các gói là một khối xây dựng cơ bản để xây dựng phần mềm, cho phép bạn tận dụng một cách thuận tiện một mảng mã nguồn mở ngày càng phát triển.

00:02:56.000 --> 00:03:04.000
Các thành viên của cộng đồng Swift đã đưa ra một số giải pháp tuyệt vời để giúp các nhà phát triển tìm thấy các gói, như Chỉ mục Gói Swift.

00:03:04.000 --> 00:03:12.000
Chỉ mục gói Swift là một trang được tạo bởi cộng đồng giúp bạn tìm các gói hỗ trợ Trình quản lý gói Swift.

00:03:12.000 --> 00:03:32.000
Bây giờ, trong Swift 5.5 và Xcode 13, chúng tôi đang cung cấp các cách bổ sung để bạn tìm và truy cập các gói, bằng cách cung cấp hỗ trợ công cụ Xcode tích hợp để giúp việc sử dụng các gói trong dự án của bạn nhanh hơn và dễ dàng hơn như một phần của quy trình phát triển của bạn.

00:03:32.000 --> 00:03:42.000
Năm nay, chúng tôi sẽ giới thiệu Bộ sưu tập Gói Swift, danh sách các gói Swift được sắp xếp mà bạn có thể sử dụng cả từ dòng lệnh và từ Xcode 13.

00:03:42.000 --> 00:03:50.000
Với các bộ sưu tập gói, bạn không còn cần phải tìm kiếm các gói trên Internet, hoặc sao chép và dán URL để thêm chúng.

00:03:50.000 --> 00:03:55.000
Bây giờ bạn có thể chỉ cần duyệt qua một bộ sưu tập và thêm các gói từ màn hình tìm kiếm gói mới trong Xcode.

00:03:55.000 --> 00:04:00.000
Bộ sưu tập gói là các tệp JSON đơn giản mà bạn có thể xuất bản ở bất cứ đâu.

00:04:00.000 --> 00:04:06.000
Bộ sưu tập gói có nghĩa là cho phép bất kỳ ai xây dựng danh sách các gói được sắp xếp cho các trường hợp sử dụng khác nhau.

00:04:06.000 --> 00:04:22.000
Ví dụ, một người hướng dẫn cho một lớp khoa học máy tính có thể tập hợp một tập hợp các gói giúp dạy các khái niệm của lớp đó, hoặc ai đó có thể tập hợp một bộ sưu tập các gói tốt cho một lĩnh vực hoặc nhiệm vụ cụ thể hoặc được tổ chức của họ sử dụng.

00:04:22.000 --> 00:04:27.000
Chúng tôi rất vui khi thấy tất cả những cách khác nhau mà mọi người sẽ sử dụng các bộ sưu tập.

00:04:27.000 --> 00:04:33.000
Chúng tôi có một bài thuyết trình tuyệt vời về các bộ sưu tập bao bì mà tôi khuyên bạn nên kiểm tra để tìm hiểu thêm.

00:04:33.000 --> 00:04:37.000
Bộ sưu tập gói bao gồm một số hỗ trợ công cụ mạnh mẽ trong Xcode.

00:04:37.000 --> 00:04:41.000
Bây giờ bạn chỉ cần nhập khẩu từ việc sử dụng các API yêu thích của mình.

00:04:41.000 --> 00:04:54.000
Khi bạn cố gắng nhập một mô-đun không thể tìm thấy, Xcode sẽ kiểm tra xem có bất kỳ gói nào trong bộ sưu tập gói mà bạn đã định cấu hình cung cấp mô-đun đó không và cung cấp cho bạn cơ hội tự động bắt đầu sử dụng gói đó.

00:04:54.000 --> 00:05:01.000
Khi bạn chọn sử dụng một gói, tất cả cấu hình sẽ được xử lý cho bạn dựa trên thông tin trong bộ sưu tập gói.

00:05:01.000 --> 00:05:08.000
Các bộ sưu tập gói cũng có thể tìm kiếm được, giúp bạn dễ dàng tìm thấy các gói hàng để đáp ứng trường hợp sử dụng của mình.

00:05:08.000 --> 00:05:18.000
Nếu bạn quan tâm đến việc dùng thử các bộ sưu tập gói ngay hôm nay, có một số bộ sưu tập đã có sẵn, bao gồm bộ sưu tập gói Swift mà Apple xuất bản trên GitHub.

00:05:18.000 --> 00:05:23.000
Xcode được kết nối sẵn để sử dụng bộ sưu tập Apple.

00:05:23.000 --> 00:05:34.000
Nếu bạn quan tâm đến việc tìm hiểu thêm về các bộ sưu tập trọn gói, bao gồm các bộ sưu tập đã có sẵn từ cộng đồng, hãy xem bài đăng trên blog swift.org mới về các bộ sưu tập trọn gói.

00:05:34.000 --> 00:05:42.000
Nói về các API yêu thích của bạn, Apple xuất bản một nhóm các gói Swift mã nguồn mở đang phát triển.

00:05:42.000 --> 00:05:48.000
Ngoài một số cải tiến lớn cho các gói yêu thích của bạn, năm nay, chúng tôi đã tung ra thêm bốn gói mới.

00:05:48.000 --> 00:05:55.000
Đầu tiên, tôi muốn kể cho bạn nghe về Bộ sưu tập Swift.

00:05:55.000 --> 00:06:04.000
Swift Collections là một gói cấu trúc dữ liệu mã nguồn mở mới bổ sung cho những cấu trúc có sẵn trong Thư viện Tiêu chuẩn Swift.

00:06:04.000 --> 00:06:16.000
Phiên bản ban đầu của Swift Collections đi kèm với việc triển khai cho ba trong số các cấu trúc dữ liệu được yêu cầu thường xuyên nhất: Deque, OrderedSet và OrderedDictionary.

00:06:16.000 --> 00:06:24.000
Deque giống như một Mảng, ngoại trừ việc nó hỗ trợ chèn và xóa hiệu quả ở cả hai đầu.

00:06:24.000 --> 00:06:29.000
OrderedSet là sự kết hợp mạnh mẽ giữa Mảng và Tập hợp.

00:06:29.000 --> 00:06:34.000
Giống như Array, OrderedSet duy trì các phần tử của nó theo thứ tự và hỗ trợ truy cập ngẫu nhiên.

00:06:34.000 --> 00:06:43.000
Giống như một Set, OrderedSet đảm bảo mỗi phần tử chỉ xuất hiện một lần và cung cấp kiểm tra thành viên hiệu quả.

00:06:43.000 --> 00:06:52.000
Và cuối cùng là OrderedDictionary, đây là một giải pháp thay thế hữu ích cho Từ điển khi thứ tự quan trọng hoặc chúng ta cần truy cập ngẫu nhiên vào các phần tử.

00:06:52.000 --> 00:06:56.000
Tiếp theo, hãy nói về các thuật toán Swift.

00:06:56.000 --> 00:07:03.000
Swift Algorithms là một gói mã nguồn mở mới của các thuật toán Trình tự và Bộ sưu tập.

00:07:03.000 --> 00:07:29.000
Chúng tôi đã thêm hơn 40 thuật toán vào Thuật toán Swift cho những thứ như tạo ra tất cả các kết hợp hoặc hoán vị của một tập hợp các phần tử hoặc lặp lại các phần tử của một chuỗi bằng hai hoặc ba hoặc trong các nhóm được xác định bởi một vị ngữ hoặc chọn năm phần tử nhỏ nhất trong một bộ sưu tập, năm phần tử lớn nhất hoặc chỉ năm phần tử

00:07:29.000 --> 00:07:38.000
Phải mất một chút đầu tư để học từ vựng, nhưng một khi bạn làm vậy, có thể rất ấn tượng khi khám phá ra có bao nhiêu thuật toán đang ẩn trong tầm nhìn rõ ràng.

00:07:38.000 --> 00:07:49.000
Nếu bạn muốn tìm hiểu thêm, chúng tôi có một phiên mô tả cách các gói Thuật toán và Bộ sưu tập Swift mới có thể giúp bạn làm cho mã của mình rõ ràng hơn, nhanh hơn và chính xác hơn.

00:07:49.000 --> 00:07:51.000
Bây giờ, hãy nói về Hệ thống Swift.

00:07:51.000 --> 00:08:00.000
Mùa thu năm ngoái, chúng tôi đã mở Swift System, một thư viện cung cấp các giao diện thành ngữ, cấp thấp cho các cuộc gọi hệ thống.

00:08:00.000 --> 00:08:05.000
Hệ thống có sẵn trên các nền tảng Apple, Linux và thậm chí cả Windows.

00:08:05.000 --> 00:08:12.000
Gần đây chúng tôi đã thêm các API mới mạnh mẽ vào loại FilePath của Hệ thống để thực hiện các hoạt động thao tác đường dẫn phổ biến.

00:08:12.000 --> 00:08:21.000
Chúng bao gồm khả năng truy vấn hoặc đặt tiện ích mở rộng, thêm và xóa các thành phần và thực hiện chuẩn hóa đường dẫn.

00:08:21.000 --> 00:08:27.000
Một đường dẫn có thể được phân tách thành gốc và các thành phần tương đối của nó.

00:08:27.000 --> 00:08:38.000
ComponentView của FilePath là một tập hợp các thành phần đường dẫn có cấu trúc, có nghĩa là nó đi kèm với sự hỗ trợ cho nhiều thuật toán chung của Swift ngay lập tức.

00:08:38.000 --> 00:08:47.000
Và khi nhắm mục tiêu Windows, các đường dẫn Windows, với các thành phần gốc phức tạp của chúng, được hỗ trợ đầy đủ bởi tất cả các API FilePath mới.

00:08:47.000 --> 00:08:51.000
Tiếp theo, hãy nói về Swift Numerics.

00:08:51.000 --> 00:08:55.000
Swift Numerics đã nhận được một số bổ sung lớn trong năm nay.

00:08:55.000 --> 00:09:00.000
Chúng tôi đã đưa Float16 lên iOS, tvOS và watchOS vào năm ngoái.

00:09:00.000 --> 00:09:09.000
Năm nay, chúng tôi đã thêm hỗ trợ Float16 cho Apple Silicon Macs và khả năng tạo ra các số phức dựa trên Float16.

00:09:09.000 --> 00:09:18.000
Một bổ sung khác trong năm nay là hỗ trợ số phức cho tất cả các hàm cơ bản, như log, sin và cosin.

00:09:18.000 --> 00:09:28.000
Bởi vì các triển khai này được viết bằng Swift, chúng thường hiệu quả hơn thư viện C truyền thống và cho phép tối ưu hóa mà nếu không sẽ không thể thực hiện được.

00:09:28.000 --> 00:09:32.000
Cuối cùng, hãy nói về Swift ArgumentParser.

00:09:32.000 --> 00:09:44.000
Chúng tôi đã tiếp tục tinh chỉnh Swift ArgumentParser trong năm nay, với các cải tiến như khả năng tạo các tập lệnh hoàn thành mã cho vỏ Cá, tham gia các tùy chọn ngắn và các thông báo lỗi được cải thiện.

00:09:44.000 --> 00:09:53.000
Chúng tôi cũng đã vượt qua một cột mốc quan trọng vào mùa xuân này khi ArgumentParser được Trình quản lý gói Swift thông qua trong Xcode 12.5.

00:09:53.000 --> 00:09:54.000
Đúng rồi!

00:09:54.000 --> 00:10:01.000
Nếu bạn đã sử dụng công cụ dòng lệnh Swift Package Manager gần đây, bạn đã sử dụng Swift ArgumentParser.

00:10:01.000 --> 00:10:07.000
Tiếp theo, tôi muốn nói về một số công việc chúng tôi đã làm để hỗ trợ Swift phát triển máy chủ.

00:10:07.000 --> 00:10:12.000
Năm ngoái, chúng tôi đã thêm hỗ trợ cho một số nền tảng, bao gồm Amazon Linux.

00:10:12.000 --> 00:10:21.000
Năm nay, chúng tôi đã theo dõi công việc đó bằng cách đầu tư vào hiệu suất và chức năng cho các ứng dụng máy chủ Swift.

00:10:21.000 --> 00:10:32.000
Chúng tôi bắt đầu bằng cách cho phép liên kết tĩnh trên Linux, giúp cải thiện thời gian khởi động ứng dụng, cũng như đơn giản hóa việc triển khai các ứng dụng máy chủ, hiện có thể được triển khai dưới dạng một tệp duy nhất.

00:10:32.000 --> 00:10:44.000
Ngoài ra, trong Swift 5.5, mã hóa và giải mã JSON được sử dụng trên Linux đã được triển khai lại từ đầu, dẫn đến tăng hiệu suất cho hầu hết các trường hợp sử dụng phổ biến.

00:10:44.000 --> 00:10:51.000
Cuối cùng, chúng tôi đã nâng cao và tối ưu hóa hiệu suất của chính thư viện thời gian chạy AWS Lambda.

00:10:51.000 --> 00:11:06.000
Tất cả công việc này đã làm cho các chương trình Swift chạy trên AWS Lambda bắt đầu nhanh hơn 33%, cũng như thời gian gọi nhanh hơn 40% cho một lambda được định tuyến qua AWS API Gateway.

00:11:06.000 --> 00:11:16.000
Ngoài việc tối ưu hóa hiệu suất thư viện thời gian chạy AWS, chúng tôi đã cấu trúc lại nó để sử dụng mô hình không đồng bộ/chờ đợi mới của mình thay vì đóng cửa.

00:11:16.000 --> 00:11:21.000
Cải thiện trải nghiệm của nhà phát triển Swift là một trọng tâm quan trọng khác trong Swift 5.5.

00:11:21.000 --> 00:11:25.000
Tôi muốn bắt đầu bằng cách nói về tài liệu.

00:11:25.000 --> 00:11:33.000
Cung cấp tài liệu tuyệt vời là chìa khóa để tạo ra trải nghiệm mượt mà và thú vị cho người dùng khuôn khổ.

00:11:33.000 --> 00:11:45.000
Năm nay, chúng tôi sẽ giới thiệu DocC, một trình biên dịch tài liệu được tích hợp sâu bên trong Xcode 13, để giúp bạn dạy các nhà phát triển cách sử dụng khung hoặc gói Swift của mình.

00:11:45.000 --> 00:11:51.000
Giờ đây, việc viết và chia sẻ tài liệu tuyệt vời trở nên dễ dàng hơn bao giờ hết.

00:11:51.000 --> 00:12:04.000
DocC được xây dựng từ đầu, sử dụng các công cụ và công nghệ mà bạn đã biết và yêu thích, chẳng hạn như nhận xét đánh dấu trong mã nguồn Swift của bạn, để bạn có thể dễ dàng viết và phân biệt tài liệu của mình.

00:12:04.000 --> 00:12:10.000
Chúng tôi có bốn phiên tuyệt vời để hiển thị cho bạn mọi khía cạnh của tài liệu DocC trong Xcode.

00:12:10.000 --> 00:12:13.000
Tôi thực sự khuyên bạn nên kiểm tra chúng.

00:12:13.000 --> 00:12:20.000
Và bây giờ, tôi rất vui mừng thông báo rằng Swift DocC sẽ được mở nguồn vào cuối năm nay.

00:12:20.000 --> 00:12:30.000
Swift DocC nguồn mở sẽ cho phép các nhà phát triển dễ dàng tạo ra tài liệu tuyệt vời hơn trên tất cả các nền tảng được hỗ trợ của Swift.

00:12:30.000 --> 00:12:36.000
Trong Swift 5.5, chúng tôi đã đầu tư vào việc cải thiện chất lượng và hiệu suất trong trình kiểm tra loại.

00:12:36.000 --> 00:12:43.000
Một kết quả của việc này là bạn sẽ thấy ít lỗi "biểu thức quá phức tạp" hơn khi biên dịch mã của mình.

00:12:43.000 --> 00:12:48.000
Chúng tôi cũng tăng tốc hiệu suất để kiểm tra loại các ký tự mảng.

00:12:48.000 --> 00:12:56.000
Trong bản phát hành này, chúng tôi cũng đang nâng cao năng suất của nhà phát triển với ba cải tiến chính để tăng tốc độ xây dựng gia tăng.

00:12:56.000 --> 00:13:06.000
Trước hết, bây giờ chúng tôi hỗ trợ nhập gia tăng, có nghĩa là bây giờ chúng tôi không còn xây dựng lại mọi tệp nguồn nhập mô-đun khi mô-đun đó thay đổi.

00:13:06.000 --> 00:13:15.000
Ngoài ra, bây giờ chúng tôi tính toán biểu đồ phụ thuộc mô-đun trước để chúng tôi có thể nhanh chóng bắt đầu các bản dựng gia tăng chỉ những gì đã thay đổi.

00:13:15.000 --> 00:13:25.000
Cuối cùng, chúng tôi đã mở rộng biên dịch lại có chọn lọc để hoạt động với các tiện ích mở rộng, có nghĩa là ít biên dịch lại hơn khi bạn thay đổi nội dung của tiện ích mở rộng.

00:13:25.000 --> 00:13:43.000
Sử dụng dự án mã nguồn mở SwiftDriver làm ví dụ, trung bình, với việc nhập gia tăng trong Swift 5.5, giờ đây chúng tôi biên dịch lại ít hơn một phần mười số tệp khi các mô-đun được nhập thay đổi và thời gian xây dựng giảm khoảng một phần ba.

00:13:43.000 --> 00:13:52.000
Những cải tiến hiệu suất từ việc nhập khẩu gia tăng có nghĩa là bây giờ bạn có thể mô đun hóa dự án của mình và thay đổi một mô-đun đã nhập mà không bị phạt lớn trong hiệu suất xây dựng.

00:13:52.000 --> 00:14:04.000
Và nhân tiện, một số cải tiến hiệu suất này đã được thực hiện bởi một cột mốc quan trọng cho dự án Swift, phần đầu tiên của trình biên dịch được viết bằng Swift.

00:14:04.000 --> 00:14:10.000
Đây là Trình điều khiển Swift, chương trình điều phối việc biên dịch mã nguồn Swift.

00:14:10.000 --> 00:14:17.000
Dự án này bắt đầu vào cuối năm 2019 và, kể từ Xcode 13, hiện là mặc định cho việc biên dịch Swift.

00:14:17.000 --> 00:14:27.000
Cuối cùng, hãy nói về những cải tiến mà chúng tôi đã thực hiện để giúp quản lý bộ nhớ trong Swift hiệu quả hơn, vì vậy các chương trình Swift lấy lại bộ nhớ nhanh hơn.

00:14:27.000 --> 00:14:37.000
Các trường hợp lớp Swift sử dụng Đếm tham chiếu tự động, ARC, để theo dõi có bao nhiêu tham chiếu đến một đối tượng cụ thể tại bất kỳ thời điểm nào.

00:14:37.000 --> 00:14:46.000
Trong hầu hết các trường hợp, điều này có nghĩa là quản lý bộ nhớ chỉ hoạt động trong Swift và bạn không cần phải tự nghĩ về việc quản lý bộ nhớ.

00:14:46.000 --> 00:14:52.000
ARC tự động giải phóng bộ nhớ được sử dụng bởi các phiên bản lớp khi các phiên bản đó không còn cần thiết nữa.

00:14:52.000 --> 00:15:04.000
Để làm điều này, trình biên dịch Swift chèn một thao tác giữ lại bất cứ khi nào một tham chiếu mới được tạo và một thao tác phát hành bất cứ khi nào một tham chiếu mới ngừng được sử dụng.

00:15:04.000 --> 00:15:14.000
Năm nay, chúng tôi đã giới thiệu một cách mới để theo dõi các tham chiếu bên trong trình biên dịch cho phép trình biên dịch giảm đáng kể số lượng hoạt động lưu giữ và phát hành.

00:15:14.000 --> 00:15:20.000
Chúng tôi đã thấy những cải tiến về hiệu suất và kích thước mã có thể đo lường được từ sự thay đổi này.

00:15:20.000 --> 00:15:30.000
Chúng tôi đã thêm cài đặt Xcode, Tối ưu hóa tuổi thọ đối tượng, điều đó sẽ cho phép bạn thấy hiệu quả của việc tối ưu hóa ARC mới, tích cực hơn này đối với mã của mình.

00:15:30.000 --> 00:15:36.000
Để biết thêm thông tin về ARC, vui lòng xem phiên "ARC trong Swift".

00:15:36.000 --> 00:15:40.000
Đây chỉ là một số cải tiến do Swift 5.5 mang lại cho bạn.

00:15:40.000 --> 00:15:46.000
Tiếp theo, Tim sẽ nói chuyện với bạn về Swift Concurrency và các diễn biến khác trong ngôn ngữ Swift.

00:15:46.000 --> 00:15:48.000
Cảm ơn, Nicole.

00:15:48.000 --> 00:15:59.000
Tất cả chúng ta đều rất hào hứng với Swift Concurrency, nhưng trước khi tôi làm điều đó, tôi muốn thảo luận về một số thay đổi khác mà chúng tôi đã thực hiện đối với Swift để đơn giản hóa và cải thiện chương trình hàng ngày.

00:15:59.000 --> 00:16:02.000
Đây là danh sách các cải tiến công thái học mà chúng tôi đã thực hiện trong năm nay.

00:16:02.000 --> 00:16:06.000
Các số SE xác định các đề xuất Swift Evolution.

00:16:06.000 --> 00:16:16.000
Mỗi đề xuất này được viết bởi một thành viên của cộng đồng, được thảo luận trên diễn đàn Swift Evolution và được Nhóm Swift Core chấp thuận trước khi được chấp nhận vào ngôn ngữ.

00:16:16.000 --> 00:16:25.000
Tất cả các đề xuất SE, cho dù được chấp nhận, từ chối hay vẫn đang được thảo luận, đều có thể được tìm thấy trong kho lưu trữ Swift Evolution trên GitHub.

00:16:25.000 --> 00:16:27.000
Hãy xem xét một vài trong số những thay đổi này.

00:16:27.000 --> 00:16:30.000
Đầu Tiên, Những Người Xây Dựng Kết Quả.

00:16:30.000 --> 00:16:39.000
Khi SwiftUI lần đầu tiên được công bố, nó đã giới thiệu một cú pháp mới có thể được sử dụng để mô tả nhanh chóng và dễ dàng các hệ thống phân cấp đối tượng phức tạp.

00:16:39.000 --> 00:16:49.000
Năm vừa qua, cú pháp đó đã được chuẩn hóa và tinh chỉnh thông qua quy trình Swift Evolution để nó có thể được sử dụng dễ dàng hơn trong nhiều bối cảnh khác nhau.

00:16:49.000 --> 00:16:57.000
Nếu bạn muốn tận dụng công nghệ mạnh mẽ này, chúng tôi có một phiên dành riêng cho việc sử dụng Trình tạo kết quả.

00:16:57.000 --> 00:17:04.000
Giao thức Codable là một cách thuận tiện để tuần tự hóa dữ liệu của bạn, nhưng từ lâu nó đã bị thiếu sót đáng chú ý.

00:17:04.000 --> 00:17:07.000
Hãy xem xét Enum hai trường hợp này.

00:17:07.000 --> 00:17:15.000
Để làm cho nó phù hợp với Codable, bạn đã từng phải thực hiện thủ công tất cả các bản mẫu này.

00:17:15.000 --> 00:17:22.000
Bây giờ, bạn chỉ cần khai báo sự phù hợp của Codable và trình biên dịch sẽ thực hiện tất cả công việc đó cho bạn.

00:17:22.000 --> 00:17:26.000
Chúng tôi cũng đã thực hiện một số cải tiến quan trọng đối với trình kiểm tra kiểu của Swift.

00:17:26.000 --> 00:17:31.000
Như bạn đã biết, suy luận kiểu trong Swift có nghĩa là bạn có thể bỏ qua thông tin kiểu dư thừa.

00:17:31.000 --> 00:17:37.000
Ở đây, nó cho phép bạn rút ngắn Coffee.regular xuống chỉ còn .regular.

00:17:37.000 --> 00:17:40.000
Nhưng các cấu trúc giống Enum cũng được thể hiện theo những cách khác.

00:17:40.000 --> 00:17:50.000
Ví dụ, bạn có thể có một tập hợp các loại phù hợp với giao thức và muốn sử dụng các trường hợp của các loại đó trong API của bạn.

00:17:50.000 --> 00:18:00.000
Bây giờ bạn có thể tham khảo các trường hợp của các loại đó bằng cách sử dụng cùng một ký hiệu dấu chấm mà bạn sử dụng cho Enums, bằng cách khai báo một vài thuộc tính tĩnh trên giao thức của bạn.

00:18:00.000 --> 00:18:12.000
Điều này được kích hoạt bởi những cải tiến đối với trình kiểm tra kiểu của Swift cho phép nó suy luận tổng quát hơn về các thuộc tính tĩnh trong ngữ cảnh chung, bao gồm các tham chiếu thuộc tính được xâu chuỗi như .large ở đây.

00:18:12.000 --> 00:18:23.000
Điều này cho phép các tác giả thư viện xây dựng các mô hình dữ liệu chung tinh vi với các API giống như Enum tự nhiên và dễ sử dụng.

00:18:23.000 --> 00:18:27.000
Giấy gói tài sản cũng đã được cải thiện trong năm nay.

00:18:27.000 --> 00:18:31.000
Giấy gói thuộc tính là một công cụ thuận tiện để áp dụng ngữ nghĩa phổ biến cho các thuộc tính.

00:18:31.000 --> 00:18:37.000
Nhiều người trong số các bạn đã triển khai trình bao bọc tài sản của riêng mình bằng cách sử dụng chú thích @propertyWrapper trên một cấu trúc.

00:18:37.000 --> 00:18:42.000
Đây là một ví dụ bổ sung yêu cầu rằng tài sản không được để trống.

00:18:42.000 --> 00:18:52.000
Với việc triển khai SE-0293, các trình bao bọc thuộc tính tương tự đó hiện có thể được sử dụng trên các tham số hàm và đóng.

00:18:52.000 --> 00:18:58.000
Tích lũy, những thay đổi này và những thay đổi khác đối với ngôn ngữ có thể đơn giản hóa rất nhiều vấn đề mã hóa phổ biến.

00:18:58.000 --> 00:19:03.000
Hãy cùng nhau xem xét chúng trong bối cảnh của một mẫu mã SwiftUI đơn giản.

00:19:03.000 --> 00:19:16.000
Đây là Chế độ xem SwiftUI có một thuộc tính duy nhất, chứa một mảng cài đặt và nội dung trình bày danh sách các cài đặt đó, với một nút chuyển đổi bên cạnh mỗi cài đặt.

00:19:16.000 --> 00:19:22.000
Hãy xem lại mã này và xem các tính năng Swift 5.5 mới có thể đơn giản hóa nó như thế nào.

00:19:22.000 --> 00:19:26.000
Đầu tiên, trình khởi tạo Toggle() rõ ràng là trùng lặp.

00:19:26.000 --> 00:19:40.000
Sự trùng lặp này từng là cần thiết, nhưng chúng tôi đã nới lỏng việc sử dụng #if để cho phép nó bao quanh các biểu thức hậu tố, chẳng hạn như các công cụ sửa đổi toggleStyle ở đây, cho phép chúng tôi tính đến yếu tố dự phòng đó.

00:19:40.000 --> 00:19:46.000
SwiftUI cũng đã được cập nhật để tận dụng các cải tiến trình kiểm tra kiểu mới mà tôi đã đề cập trước đó.

00:19:46.000 --> 00:19:51.000
Vì vậy, bạn có thể sử dụng ký hiệu chấm tự nhiên ở nhiều nơi hơn.

00:19:51.000 --> 00:19:58.000
Nó - hơi khó xử khi chỉ định các chỉ mục cho mảng cài đặt và sau đó lập chỉ mục mảng trong phần đóng.

00:19:58.000 --> 00:20:01.000
Chúng tôi chỉ muốn bước qua các giá trị.

00:20:01.000 --> 00:20:08.000
Bây giờ bạn có thể chuyển liên kết dự kiến trực tiếp vào hàm tạo Danh sách, sau đó có thể lặp lại các giá trị mảng.

00:20:08.000 --> 00:20:16.000
Hỗ trợ mới cho các đối số trình bao bọc thuộc tính cho phép chúng tôi viết đối số đóng với ký hiệu đô la, điều này sẽ cung cấp cho chúng tôi cài đặt ràng buộc trong đóng của chúng tôi.

00:20:16.000 --> 00:20:21.000
Điều đó, đến lượt nó, cho phép chúng tôi truy cập cả giá trị được bọc và ràng buộc.

00:20:21.000 --> 00:20:33.000
Và cuối cùng, trình biên dịch Swift hiện chuyển đổi minh bạch giữa CGFloat và Double, cho phép bạn loại bỏ nhiều chuyển đổi số dư thừa khi làm việc với API nền tảng Apple.

00:20:33.000 --> 00:20:46.000
Như bạn thấy, nỗ lực liên tục của chúng tôi để tinh chỉnh ngôn ngữ cốt lõi đang làm cho mã bạn viết mỗi ngày đơn giản hơn bao giờ hết và tạo ra nhiều cơ hội hơn cho các tác giả thư viện xây dựng các API phong phú và dễ sử dụng.

00:20:46.000 --> 00:20:54.000
Để biết thêm thông tin về một số cách mà lập trình SwiftUI đã được cải thiện trong năm nay, vui lòng xem phiên "Có gì mới trong SwiftUI".

00:20:54.000 --> 00:21:03.000
Tất nhiên, điểm nổi bật của Swift 5.5 là một tập hợp các tính năng lồng vào nhau để hỗ trợ lập trình không đồng bộ và đồng thời.

00:21:03.000 --> 00:21:10.000
Tôi sẽ giới thiệu những điều này trong giây lát, nhưng trước tiên, hãy để tôi giải thích ngắn gọn ý của tôi khi nói "đồng bộ" và "đồng thời".

00:21:10.000 --> 00:21:15.000
Các dự án phần mềm được cấu tạo từ các khối mã thực thi theo một số thứ tự.

00:21:15.000 --> 00:21:20.000
Trong trường hợp đơn giản nhất, các khối đó thực thi, lần lượt từng khối một theo một chuỗi đơn giản.

00:21:20.000 --> 00:21:22.000
Nhưng các cấu trúc khác cũng phổ biến.

00:21:22.000 --> 00:21:29.000
Ví dụ, các API mạng thường được thiết kế theo phong cách không đồng bộ.

00:21:29.000 --> 00:21:37.000
Trong các API này, sau khi bạn đã gửi yêu cầu đến máy chủ từ xa, có thể có một sự chậm trễ kéo dài cho đến khi bạn nhận được phản hồi và cần phải làm nhiều việc hơn.

00:21:37.000 --> 00:21:46.000
Lý tưởng nhất, mã của bạn sẽ bị đình chỉ trong thời gian trì hoãn này để nó không sử dụng bất kỳ tài nguyên nào cho đến khi bạn có thể hành động theo phản hồi.

00:21:46.000 --> 00:21:54.000
Ngược lại, mã đồng thời là khi bạn có hai hoặc nhiều khối mã mà bạn muốn chạy cùng một lúc.

00:21:54.000 --> 00:21:57.000
Đây thường là những hoạt động độc lập nhưng có liên quan.

00:21:57.000 --> 00:22:07.000
Ví dụ, xử lý một số khung hình của video hoặc chạy lần lặp tiếp theo của trình phân loại ML cùng lúc bạn đang cập nhật giao diện người dùng với bộ kết quả trước đó.

00:22:07.000 --> 00:22:17.000
Với những ý tưởng đó trong đầu, hãy xem xét một ví dụ lập trình không đồng bộ đơn giản mà không cần sử dụng các tính năng mới của Swift.

00:22:17.000 --> 00:22:24.000
Nếu bạn đã thực hiện nhiều chương trình iOS hoặc macOS, bạn có thể đã viết mã tương tự như thế này nhiều lần.

00:22:24.000 --> 00:22:27.000
Điều này sử dụng lớp URLSession của Foundation để thực hiện cuộc gọi mạng.

00:22:27.000 --> 00:22:30.000
Phương pháp dataTask là một thao tác không đồng bộ.

00:22:30.000 --> 00:22:32.000
Bạn gọi nó với một lập luận kết thúc.

00:22:32.000 --> 00:22:37.000
Khi kết quả có sẵn, việc đóng cửa của bạn sẽ được gọi với kết quả để xử lý.

00:22:37.000 --> 00:22:47.000
Tuy nhiên, việc sử dụng các đóng cửa theo cách này để thể hiện mã không đồng bộ dẫn đến một thứ tự hoạt động hơi khó xử, như bạn có thể thấy bằng cách xem qua mã này.

00:22:47.000 --> 00:22:53.000
Đầu tiên, có một số thiết lập ban đầu và phương pháp dataTask cung cấp cho chúng ta một xử lý nhiệm vụ.

00:22:53.000 --> 00:22:57.000
Sau đó, chúng tôi tiếp tục xử lý nhiệm vụ để bắt đầu thao tác nền.

00:22:57.000 --> 00:23:01.000
Hàm fetchImage thực sự trả về tại thời điểm này.

00:23:01.000 --> 00:23:08.000
Bất cứ ai gọi cho chúng tôi phải sẵn sàng tiếp tục, mặc dù chúng tôi chưa thực sự hoàn thành công việc mà chúng tôi được yêu cầu làm.

00:23:08.000 --> 00:23:13.000
Sau đó, sau khi hoạt động mạng kết thúc, việc đóng cửa này sẽ có cơ hội xử lý kết quả.

00:23:13.000 --> 00:23:20.000
Hy vọng rằng, mọi thứ diễn ra tốt đẹp, và chúng ta có thể gọi cho người xử lý hoàn thành của mình với kết quả cuối cùng.

00:23:20.000 --> 00:23:28.000
Bên cạnh thứ tự thực hiện hơi khó xử, việc sử dụng trình xử lý hoàn thành cũng ngăn chúng tôi sử dụng xử lý lỗi thử/bắt.

00:23:28.000 --> 00:23:38.000
Lưu ý cách dataTask cung cấp một tham số lỗi bổ sung cho trình xử lý hoàn thành của nó và cách chúng tôi phải gọi trình xử lý hoàn thành của mình với mọi lỗi có thể xảy ra.

00:23:38.000 --> 00:23:44.000
Để xem Swift 5.5 cải thiện điều này như thế nào, chúng ta hãy xem một dòng mã này.

00:23:44.000 --> 00:23:51.000
Lưu ý cách cuộc gọi này trả về một nhiệm vụ, một xử lý trừu tượng đại diện cho hoạt động nền.

00:23:51.000 --> 00:23:53.000
Đó không thực sự là những gì chúng tôi muốn.

00:23:53.000 --> 00:23:55.000
Chúng tôi chỉ muốn lấy dữ liệu.

00:23:55.000 --> 00:23:59.000
Vì vậy, hãy thúc đẩy ý tưởng đó một chút và xem chúng ta kết thúc ở đâu.

00:23:59.000 --> 00:24:03.000
Vì chúng tôi đang xử lý HTTP, chúng tôi cũng cần nắm bắt một số siêu dữ liệu phản hồi.

00:24:03.000 --> 00:24:11.000
Vì vậy, chức năng thực sự sẽ trả về một cặp, với dữ liệu thực tế là mục đầu tiên và thông tin bổ sung là mục thứ hai.

00:24:11.000 --> 00:24:21.000
Bằng cách cấu trúc điều này như một lệnh gọi hàm trả về dữ liệu, giờ đây chúng ta có thể sử dụng xử lý lỗi thử/bắt để loại bỏ rất nhiều mẫu từ ví dụ trước.

00:24:21.000 --> 00:24:34.000
Chúng tôi chỉ cần một chút cú pháp để thông báo cho trình biên dịch rằng hàm của chúng tôi có thể bị đình chỉ ngay khi phương thức dữ liệu bắt đầu và chúng tôi sẽ không thể hoàn thành bài tập cho đến khi thao tác đó hoàn tất.

00:24:34.000 --> 00:24:37.000
Đó chính xác là những gì từ khóa await mới làm.

00:24:37.000 --> 00:24:40.000
Hãy xem xét điều đó trong ngữ cảnh.

00:24:40.000 --> 00:24:43.000
Đây là chức năng fetchImage của chúng tôi bây giờ trông như thế nào.

00:24:43.000 --> 00:24:46.000
Như bạn thấy, mã này bây giờ dễ theo dõi hơn nhiều.

00:24:46.000 --> 00:24:53.000
Kiểm soát luồng từ trên xuống dưới, chúng ta không còn cần đóng lồng nhau nữa và chúng ta có thể sử dụng xử lý lỗi thử/bắt.

00:24:53.000 --> 00:25:05.000
Từ khóa await chỉ ra một điểm mà hàm fetchImage này có thể bị đình chỉ, được đặt sang một bên để không chạy cho đến khi một số sự kiện xảy ra cho phép nó tiếp tục.

00:25:05.000 --> 00:25:15.000
Trong trường hợp này, ngay sau khi URLSession bắt đầu yêu cầu, chức năng của chúng tôi sẽ bị đình chỉ bởi thời gian chạy Swift trong khi thao tác được thực hiện ở nơi khác.

00:25:15.000 --> 00:25:23.000
Khi kết quả cuối cùng đã sẵn sàng, cho dù đó là phản hồi thành công hay lỗi ném, chỉ khi đó chức năng của chúng tôi mới được nối lại.

00:25:23.000 --> 00:25:28.000
Nếu đó là phản hồi thành công, chúng tôi sẽ hoàn thành việc khởi tạo dữ liệu và các biến phản hồi.

00:25:28.000 --> 00:25:32.000
Nếu đó là một lỗi bị ném, chúng tôi sẽ chuyển lại cho bất kỳ ai đã gọi cho chúng tôi.

00:25:32.000 --> 00:25:37.000
Một chức năng không đồng bộ không sử dụng bất kỳ tài nguyên nào trong khi nó bị đình chỉ.

00:25:37.000 --> 00:25:40.000
Đặc biệt, nó không chặn một chủ đề.

00:25:40.000 --> 00:25:46.000
Điều này cho phép thời gian chạy Swift sử dụng lại luồng mà hàm này đang chạy cho công việc khác.

00:25:46.000 --> 00:25:52.000
Điều này cho phép một vài chủ đề được chia sẻ giữa nhiều quy trình không đồng bộ.

00:25:52.000 --> 00:25:58.000
Về mặt cú pháp, các từ khóa không đồng bộ và chờ đợi được sử dụng tương tự như ném và thử.

00:25:58.000 --> 00:26:05.000
Async trang trí khai báo hàm để chỉ ra rằng hàm này phải được biên dịch để hỗ trợ đình chỉ.

00:26:05.000 --> 00:26:11.000
Sử dụng từ khóa await để đánh dấu bất kỳ cuộc gọi nào đến hàm, phương thức hoặc đóng không đồng bộ.

00:26:11.000 --> 00:26:15.000
Tất nhiên, cơ chế đầy đủ thú vị hơn rất nhiều so với những gì tôi đã trình bày ở đây.

00:26:15.000 --> 00:26:23.000
Bạn có thể xem các phiên "Gặp gỡ không đồng bộ/chờ đợi trong Swift" và "Swift concurrency: Hậu trường" để tìm hiểu thêm về cách thức hoạt động của tất cả những điều này.

00:26:23.000 --> 00:26:30.000
Tiếp theo, chúng ta hãy xem xét hỗ trợ đồng thời mới của Swift, được xây dựng dựa trên các khái niệm không đồng bộ/chờ đợi mà tôi vừa mô tả.

00:26:30.000 --> 00:26:35.000
Đây là một chức năng hiển thị ba hình ảnh khác nhau và sau đó kết hợp chúng.

00:26:35.000 --> 00:26:39.000
Như đã viết ở đây, các hoạt động này là tuần tự.

00:26:39.000 --> 00:26:48.000
Hình nền, tiền cảnh và tiêu đề sẽ được hiển thị lần lượt, với mỗi hình ảnh chỉ bắt đầu sau khi hình ảnh trước đó hoàn thành.

00:26:48.000 --> 00:26:51.000
Chúng tôi muốn các hoạt động kết xuất diễn ra song song.

00:26:51.000 --> 00:27:00.000
Nhưng chỉ chạy chúng trong các luồng khác nhau là không đủ: chúng ta cũng cần tổ chức thao tác hợp nhất, cho đến khi chúng ta có cả ba kết quả.

00:27:00.000 --> 00:27:04.000
Điều này tương tự, ở một số khía cạnh, với mã hóa không đồng bộ mà tôi vừa nói đến.

00:27:04.000 --> 00:27:11.000
Vì vậy, chúng tôi đánh dấu chức năng này là "không đồng bộ" để nó có thể tạm dừng nếu nó cần đợi kết quả đang được tính toán trong các luồng khác.

00:27:11.000 --> 00:27:17.000
Tiếp theo, chúng tôi sử dụng cú pháp let không đồng bộ để chạy song song hai thao tác đầu tiên.

00:27:17.000 --> 00:27:22.000
Async let trông rất giống một khởi tạo biến, và về cơ bản đó là những gì nó là.

00:27:22.000 --> 00:27:28.000
Nhưng việc khởi tạo này sẽ chạy song song với mã khác cho đến khi bạn cố gắng sử dụng kết quả.

00:27:28.000 --> 00:27:40.000
Bởi vì các biến nền và tiền cảnh đang được khởi tạo với let không đồng bộ, thời gian chạy của Swift, nếu cần, sẽ tạm dừng hoạt động hợp nhất cho đến khi các giá trị đó sẵn sàng.

00:27:40.000 --> 00:27:46.000
Chúng tôi đánh dấu hàm hợp nhất bằng từ khóa đang chờ để chỉ ra điều này.

00:27:46.000 --> 00:27:52.000
Điểm quan trọng nhất về mã này là các tác vụ nền không thể tồn tại lâu hơn chức năng này.

00:27:52.000 --> 00:28:00.000
Nói cách khác, chức năng này không thể và sẽ không quay lại nếu một trong hai tác vụ nền vẫn đang chạy.

00:28:00.000 --> 00:28:07.000
Nếu một lỗi được ném từ bất kỳ đâu bên trong hàm này, thời gian chạy Swift vẫn sẽ chờ các tác vụ nền hoàn thành.

00:28:07.000 --> 00:28:17.000
Ở đây, tôi đã đánh dấu một điểm đánh dấu thử cho biết tính toán của hình ảnh tiêu đề có thể ném, nhưng điều tương tự cũng áp dụng cho tất cả các lỗi ném, ngay cả khi chúng xảy ra trong một chuỗi riêng biệt.

00:28:17.000 --> 00:28:25.000
Để giữ cho mọi thứ phản hồi nhanh, khi có lỗi ném, thời gian chạy Swift sẽ báo hiệu các tác vụ chưa hoàn thành để chúng có cơ hội hoàn thành sớm.

00:28:25.000 --> 00:28:36.000
Phiên của chúng tôi về đồng thời có cấu trúc cung cấp thêm chi tiết, bao gồm thảo luận đầy đủ về cơ chế hủy này và các lựa chọn thay thế linh hoạt hơn cho cú pháp cho phép không đồng bộ mà tôi đã thảo luận ở đây.

00:28:36.000 --> 00:28:45.000
Trong phần trước, tôi đã chỉ ra cách Swift 5.5 giúp dễ dàng chạy các thao tác trên nhiều luồng một cách có cấu trúc, có kỷ luật.

00:28:45.000 --> 00:28:48.000
Tất nhiên, điều đó không hoàn toàn đủ.

00:28:48.000 --> 00:28:55.000
Bất cứ khi nào hai luồng riêng biệt chia sẻ dữ liệu, bạn có nguy cơ dữ liệu sẽ không nhất quán hoặc thậm chí bị hỏng.

00:28:55.000 --> 00:28:59.000
Cấu trúc diễn viên mới của Swift giúp bảo vệ dữ liệu của bạn chống lại những vấn đề như vậy.

00:28:59.000 --> 00:29:04.000
Một lần nữa, hãy bắt đầu với một ví dụ về mã mà bạn có thể đã tự viết.

00:29:04.000 --> 00:29:06.000
Đây là một lớp học thu thập số liệu thống kê.

00:29:06.000 --> 00:29:14.000
Nó chứa một bộ đếm và nhiều mã khác sẽ gọi phương thức tăng để cập nhật bộ đếm đó bất cứ khi nào có điều gì đó thú vị xảy ra.

00:29:14.000 --> 00:29:18.000
Thật không may, mã này không hoạt động tốt trong một hệ thống đa luồng.

00:29:18.000 --> 00:29:24.000
Nếu hai hoặc nhiều luồng gọi phương thức tăng cùng một lúc, bạn có thể kết thúc với một số lượng bị hỏng nặng.

00:29:24.000 --> 00:29:30.000
Thay đổi lớp học này thành một diễn viên Swift bảo vệ chống lại sự tham nhũng như vậy.

00:29:30.000 --> 00:29:37.000
Các diễn viên làm việc bằng cách đình chỉ bất kỳ hoạt động nào có thể gây hỏng dữ liệu cho đến khi an toàn để thực hiện thay đổi cụ thể đó.

00:29:37.000 --> 00:29:44.000
Điều này có nghĩa là bạn thường cần sử dụng await khi bạn gọi một phương thức diễn viên từ bên ngoài diễn viên.

00:29:44.000 --> 00:29:47.000
Các diễn viên cũng làm việc liền mạch với async/await.

00:29:47.000 --> 00:29:53.000
Đánh dấu phương thức xuất bản này là không đồng bộ cho phép nó bị đình chỉ trong khi chờ hoạt động mạng.

00:29:53.000 --> 00:30:01.000
Trong khi nó bị đình chỉ, các phương pháp khác có thể chạy trên tác nhân này mà không cần đợi hoạt động mạng hoàn tất và không có nguy cơ hỏng dữ liệu.

00:30:01.000 --> 00:30:10.000
Diễn viên là các loại tham chiếu, giống như các lớp học, nhưng chúng tuân theo một số quy tắc được thiết kế để đảm bảo rằng các diễn viên an toàn để sử dụng trong môi trường đa luồng.

00:30:10.000 --> 00:30:22.000
Bằng cách đóng gói dữ liệu của bạn thành các tác nhân, bạn đang nói rõ rằng bạn mong đợi dữ liệu này được truy cập đồng thời và bạn muốn trình biên dịch Swift và thời gian chạy phối hợp truy cập để không thể bị hỏng.

00:30:22.000 --> 00:30:27.000
Và, tất nhiên, chúng tôi có một phiên đầy đủ dành riêng cho cấu trúc diễn viên mới của Swift.

00:30:27.000 --> 00:30:32.000
Ở đó, bạn có thể tìm ra cách tận dụng đầy đủ các khả năng mà điều này mang lại.

00:30:32.000 --> 00:30:39.000
Trước khi chúng ta kết thúc, hãy nói một chút về tương lai của Swift.

00:30:39.000 --> 00:30:51.000
Chúng tôi tin rằng ba khái niệm chính mà chúng tôi đã giới thiệu trong Swift 5.5 - các chức năng không đồng bộ, đồng thời có cấu trúc và các tác nhân - là cơ sở tốt để tạo mã an toàn và hiệu suất cao.

00:30:51.000 --> 00:31:02.000
Đối với Swift 6, chúng tôi đã nghiên cứu các cách để trình biên dịch phát hiện nhiều loại lỗi đồng thời sớm hơn trong quá trình phát triển và cung cấp cho bạn các lỗi và hướng dẫn chi tiết hơn trong việc khắc phục các vấn đề đó.

00:31:02.000 --> 00:31:15.000
Mục tiêu của chúng tôi, khá đơn giản, là loại bỏ hoàn toàn các loại lỗi đồng thời phổ biến nhất, để làm cho lập trình không đồng bộ và đồng thời không phức tạp hơn bất kỳ loại lập trình nào khác.

00:31:15.000 --> 00:31:27.000
Và, tất nhiên, khi chúng tôi tiếp tục cải thiện sự hiểu biết của trình biên dịch về các khái niệm này, chúng tôi cũng hy vọng mã sử dụng các cấu trúc mới này sẽ trở nên hiệu quả hơn so với ngày nay.

00:31:27.000 --> 00:31:32.000
Swift là một nỗ lực cởi mở, hợp tác chào đón ý kiến đóng góp của bạn.

00:31:32.000 --> 00:31:37.000
Để giúp Swift 6 trở nên tốt hơn, hãy cho chúng tôi biết về trải nghiệm của bạn với Swift 5.5.

00:31:37.000 --> 00:31:42.000
Những tính năng mới này hoạt động tốt như thế nào đối với bạn trong việc phát triển ứng dụng trong thế giới thực?

00:31:42.000 --> 00:31:45.000
Hãy thử một trong những ảnh chụp nhanh trình biên dịch mà bạn có thể tìm thấy trên swift.org.

00:31:45.000 --> 00:31:52.000
Chúng tôi cung cấp những ảnh chụp nhanh này để bạn có thể cài đặt chúng vào Xcode và thử các tính năng mới khi chúng tôi đang phát triển chúng.

00:31:52.000 --> 00:31:57.000
Bằng cách sử dụng các ảnh chụp nhanh này, bạn có thể giúp hướng dẫn phiên bản Swift tiếp theo.

00:31:57.000 --> 00:32:01.000
Các diễn đàn Swift là mạch máu của dự án.

00:32:01.000 --> 00:32:09.000
Mỗi tính năng mà tôi đã thảo luận đều bắt đầu cuộc sống bằng cách được giới thiệu trên diễn đàn Swift Evolution, nơi một nhóm người đa dạng đã giúp tinh chỉnh nó thành một đề xuất làm việc.

00:32:09.000 --> 00:32:19.000
Chúng tôi cũng có các diễn đàn dành cho nhiều khía cạnh khác của Swift, bao gồm khu vực trợ giúp cho người dùng mới và nơi trao đổi tin tức quan tâm đến cộng đồng Swift.

00:32:19.000 --> 00:32:29.000
Có nhiều cách khác để bạn có thể làm cho Swift tốt hơn và chúng tôi mong muốn thu hút nhiều người hơn nữa, chẳng hạn như thông qua Chương trình Cố vấn mới mà Nicole đã đề cập vào đầu phiên này.

00:32:29.000 --> 00:32:35.000
Yêu cầu duy nhất là mong muốn chân thành giúp cải thiện Swift cho mọi người trong cộng đồng của chúng tôi.

00:32:35.000 --> 00:32:38.000
Tôi mong nhận được phản hồi từ bạn, và tôi hy vọng bạn thích hội nghị.

00:32:38.000 --> 23:59:59.000
[Nhạc lạc quan].

