WEBVTT

00:00:02.000 --> 00:00:10.000
Xin chào.

00:00:10.000 --> 00:00:14.000
Tôi là Nick Gillett, một kỹ sư ở đây tại Apple trong nhóm Core Data.

00:00:14.000 --> 00:00:23.000
Trong phiên này, tôi sẽ chỉ cho bạn cách dễ dàng xây dựng các ứng dụng sử dụng NSPersistentCloudKitContainer để chia sẻ dữ liệu với nhiều người dùng iCloud.

00:00:23.000 --> 00:00:32.000
Đầu tiên, chúng ta sẽ thảo luận về ý nghĩa của việc chia sẻ với NSPersistentCloudKitContainer và điều đó ảnh hưởng như thế nào đến các loại trải nghiệm bạn có thể xây dựng.

00:00:32.000 --> 00:00:37.000
Tiếp theo, chúng ta sẽ đi sâu vào cơ chế chia sẻ.

00:00:37.000 --> 00:00:46.000
Và cuối cùng, chúng ta sẽ thảo luận ngắn gọn về cách NSPersistentCloudKitContainer có thể giúp bạn kích hoạt một số biện pháp bảo vệ bổ sung cho dữ liệu nhạy cảm được lưu trữ trong iCloud.

00:00:46.000 --> 00:00:50.000
Hãy bắt đầu với việc chia sẻ.

00:00:50.000 --> 00:00:56.000
Để thảo luận, hãy tưởng tượng tôi muốn chia sẻ bức ảnh này với một số người bạn của tôi.

00:00:56.000 --> 00:00:57.000
Làm thế nào tôi có thể làm điều đó?

00:00:57.000 --> 00:01:03.000
Trên các nền tảng của Apple, có một số cách chúng tôi có thể chia sẻ dữ liệu mà các ứng dụng của chúng tôi tạo ra.

00:01:03.000 --> 00:01:10.000
Photos thực hiện kiểm soát hệ thống ở đây ở phía dưới bên trái cho phép tôi gọi một bảng Hành động.

00:01:10.000 --> 00:01:16.000
Nó có rất nhiều hành động mà tôi có thể thực hiện, bao gồm một số cách để chia sẻ.

00:01:16.000 --> 00:01:22.000
Ví dụ, tôi có thể gửi nó cho bạn bè của mình dưới dạng iMessage hoặc email.

00:01:22.000 --> 00:01:31.000
Nhưng lý tưởng nhất, chúng tôi sẽ có một vị trí duy nhất trực tiếp trong ứng dụng Ảnh nơi bạn bè của tôi và tôi có thể chia sẻ ảnh của chúng tôi với nhau.

00:01:31.000 --> 00:01:38.000
Khi tôi đăng nhập vào iCloud, Photos hỗ trợ một tùy chọn khác để chia sẻ: album được chia sẻ.

00:01:38.000 --> 00:01:46.000
Album chia sẻ ảnh tạo ra một bộ sưu tập hình ảnh được chia sẻ mà những người dùng khác có thể xem và, nếu muốn, đóng góp.

00:01:46.000 --> 00:01:53.000
Tôi chỉ cần đặt tiêu đề cho album mới và sau đó nhấn Tiếp theo để chọn nhóm người tham gia.

00:01:53.000 --> 00:01:56.000
Ở đây tôi đã chọn bốn người bạn để chia sẻ bức ảnh.

00:01:56.000 --> 00:02:05.000
Heather, Jermaine, Percy và Mary đều là những tài khoản thử nghiệm mà tôi thường xuyên làm việc khi xây dựng các tính năng chia sẻ.

00:02:05.000 --> 00:02:10.000
Khi tôi nhấn Tiếp theo, tôi có thể thấy album mới của mình với bức ảnh tôi đã chia sẻ.

00:02:10.000 --> 00:02:17.000
Ảnh cũng cho phép tôi xem những người tham gia trong album bằng cách nhấn vào biểu tượng người này ở phía trên bên phải.

00:02:17.000 --> 00:02:21.000
Nhấn vào điều đó sẽ hiển thị nhóm người tham gia.

00:02:21.000 --> 00:02:27.000
Ở đây tôi có thể thấy trạng thái lời mời của họ và một số quyền trên album được chia sẻ.

00:02:27.000 --> 00:02:30.000
Làm thế nào chúng ta có thể xây dựng một trải nghiệm như thế này?

00:02:30.000 --> 00:02:35.000
Và quan trọng hơn, trải nghiệm như vậy sẽ thay đổi các ứng dụng mà chúng ta xây dựng như thế nào?

00:02:35.000 --> 00:02:37.000
Chà, để tôi chỉ cho bạn.

00:02:37.000 --> 00:02:47.000
Để chứng minh cách chia sẻ hoạt động với NSPersistentCloudKitContainer, tôi sẽ sử dụng ứng dụng mẫu của chúng tôi, Đồng bộ hóa Kho dữ liệu cốt lõi với Đám mây.

00:02:47.000 --> 00:02:51.000
Tôi đã sửa đổi nó để hỗ trợ chia sẻ bài đăng với những người dùng iCloud khác nhau.

00:02:51.000 --> 00:03:00.000
Và ở đây trên bàn, tôi có một nhóm nhỏ các thiết bị bên mình, mỗi thiết bị đã đăng nhập vào một tài khoản iCloud thuộc về Heather, Jermaine hoặc Mary.

00:03:00.000 --> 00:03:09.000
Tôi sẽ bắt đầu bằng cách khởi chạy ứng dụng của mình trên thiết bị của Jermaine và nhấn vào dấu cộng (+) này ở góc trên bên phải để tạo một bài đăng mới.

00:03:09.000 --> 00:03:17.000
Tôi sẽ cho nó một tiêu đề đơn giản-- "Chia sẻ bản demo thật tuyệt"-- và nhấn Xong.

00:03:17.000 --> 00:03:22.000
Và sau đó tôi sẽ nhấn vào nút Hành động mới này mà tôi đã thêm để hiển thị bộ điều khiển chia sẻ.

00:03:22.000 --> 00:03:26.000
Tôi muốn gửi cho mỗi người một lời mời làm việc trên bài đăng này với tôi qua email.

00:03:26.000 --> 00:03:31.000
Vì vậy, tôi sẽ nhấn vào Thư và sau đó nhập thông tin cho bạn bè của tôi.

00:03:31.000 --> 00:03:36.000
Tôi đã lưu Heather và Mary vào sổ địa chỉ của mình, vì vậy chúng rất dễ tìm.

00:03:36.000 --> 00:03:40.000
Cuối cùng, tôi sẽ nhấn Gửi để gửi email.

00:03:40.000 --> 00:03:48.000
Bây giờ, trên thiết bị của Heather, tôi sẽ mở Thư và nhấn vào liên kết bên trong email tôi đã gửi, liên kết này sẽ mở ứng dụng của tôi.

00:03:48.000 --> 00:03:59.000
Sau một thời gian ngắn chờ đợi, bài đăng tôi đã tạo trên thiết bị của Jermaine hiện đã hiển thị trên thiết bị này.

00:03:59.000 --> 00:04:07.000
Trên thiết bị của Mary, tôi sẽ mở Mail và nhấn vào liên kết bên trong email tôi đã gửi, mở ứng dụng của tôi.

00:04:07.000 --> 00:04:14.000
Sau một thời gian chờ đợi ngắn, bài đăng tôi đã tạo trên thiết bị của Jermaine hiện cũng hiển thị trên thiết bị này.

00:04:14.000 --> 00:04:16.000
Nhưng tất cả những thứ này hoạt động như thế nào?

00:04:16.000 --> 00:04:20.000
Và chính xác thì tôi đã phải thay đổi bao nhiêu trong đơn đăng ký mẫu?

00:04:20.000 --> 00:04:23.000
Câu trả lời là, "Không nhiều."

00:04:23.000 --> 00:04:29.000
Chia sẻ cho đến nay là tính năng phức tạp nhất mà chúng tôi đã tích hợp vào NSPersistentCloudKitContainer.

00:04:29.000 --> 00:04:37.000
Nó tập hợp một lượng lớn kiến thức miền về cách CloudKit hoạt động và cách hoạt động trên các bản ghi và đối tượng.

00:04:37.000 --> 00:04:45.000
Đương nhiên, kiến thức về miền này được phản ánh trong các API mà chúng tôi đã xây dựng cho NSPersistentCloudKitContainer.

00:04:45.000 --> 00:04:51.000
Vì vậy, chúng ta hãy xem chính xác cách NSPersistentCloudKitContainer chia sẻ các đối tượng.

00:04:51.000 --> 00:05:00.000
Trong bản demo ngắn gọn của mình, tôi đã trình bày một ứng dụng sử dụng hai cơ sở dữ liệu CloudKit, cơ sở dữ liệu .private và .shared.

00:05:00.000 --> 00:05:09.000
Mỗi cái trong số này được phản chiếu đến một kho lưu trữ liên tục trong ứng dụng của tôi, một cái sử dụng phạm vi cơ sở dữ liệu .private và cái còn lại sử dụng phạm vi cơ sở dữ liệu .shared.

00:05:09.000 --> 00:05:16.000
Sử dụng một ngữ cảnh đối tượng được quản lý duy nhất, ứng dụng của tôi có thể truy cập dữ liệu trong cả hai cửa hàng.

00:05:16.000 --> 00:05:21.000
Hãy xem xét sự thay đổi đó chi tiết hơn một chút.

00:05:21.000 --> 00:05:30.000
Thay đổi đầu tiên tôi phải thực hiện là yêu cầu NSPersistentCloudKitContainer phản chiếu cơ sở dữ liệu .shared CloudKit sang một cửa hàng liên tục mới.

00:05:30.000 --> 00:05:41.000
Tôi đã làm điều này bằng cách sửa đổi CoreDataStack, thêm mô tả cửa hàng liên tục mới - đây chỉ là một bản sao của cửa hàng .private với một URL khác.

00:05:41.000 --> 00:05:46.000
Sau đó, tôi đặt thuộc tính databaseScope của các tùy chọn vùng chứa CloudKit thành .shared.

00:05:46.000 --> 00:05:56.000
Đây là iOS 15 mới và cho phép NSPersistentCloudKitContainer được cấu hình để phản chiếu các cửa hàng liên tục với cơ sở dữ liệu .shared CloudKit.

00:05:56.000 --> 00:06:01.000
Để hoàn thành bản demo, tôi đã phải thực hiện hai thay đổi khác.

00:06:01.000 --> 00:06:06.000
Tôi đã áp dụng một phương pháp mới trên NSPersistentCloudKitContainer để tạo phần chia sẻ.

00:06:06.000 --> 00:06:15.000
Share(_ managedObjects: to share: completion:) là một phương pháp mới được thiết kế để ghép nối trực tiếp với UICloudSharingController.

00:06:15.000 --> 00:06:21.000
Tôi chỉ cần thêm một thao tác nút để khởi tạo một phiên bản của UICloudSharingController.

00:06:21.000 --> 00:06:30.000
Share(_ managedObjects: to share: completion:) có nghĩa là được gọi trong giai đoạn tạo-chia sẻ của quy trình làm việc của UICloudSharingController.

00:06:30.000 --> 00:06:40.000
Nó thực hiện rất nhiều công việc dưới vỏ bọc để xác định tất cả các đối tượng cần được chia sẻ và tạo một phần chia sẻ cho chúng nếu cần.

00:06:40.000 --> 00:06:52.000
Cuối cùng, tôi gọi khối hoàn thành của UICloudSharingController với kết quả được cung cấp bởi NSPersistentCloudKitContainer, cho biết rằng tôi đã sẵn sàng để tiếp tục luồng chia sẻ.

00:06:52.000 --> 00:06:59.000
Điều này có nghĩa là bạn có thể chia sẻ các đối tượng bằng cách sử dụng NSPersistentCloudKitContainer chỉ trong một vài dòng mã.

00:06:59.000 --> 00:07:27.000
Thay đổi cuối cùng tôi phải thực hiện là có thể chấp nhận lời mời chia sẻ, điều mà tôi thực hiện bằng cách sử dụng phương pháp mới này trên NSPersistentCloudKitContainer: acceptShareInvitations (từ siêu dữ liệu: vào persistentStore: Tôi đã sử dụng phương pháp này trong ứng dụng userDelegeate userDidAcceptCloudKit

00:07:27.000 --> 00:07:38.000
Phương pháp này chấp nhận chia sẻ với máy chủ CloudKit trong vùng chứa được liên kết với cửa hàng liên tục mà tôi cung cấp - ở đây, cửa hàng được chia sẻ cho ứng dụng của tôi.

00:07:38.000 --> 00:07:46.000
Sau khi chia sẻ được chấp nhận, NSPersistentCloudKitContainer sẽ tự động đồng bộ hóa tất cả các đối tượng được chia sẻ vào cửa hàng cục bộ.

00:07:46.000 --> 00:07:57.000
Vì vậy, đó là cách chúng tôi sử dụng NSPersistentCloudKitContainer để kết hợp cơ sở dữ liệu .private và .shared, tạo chia sẻ cho các đối tượng và chấp nhận lời mời chia sẻ.

00:07:57.000 --> 00:08:02.000
Nhưng các ứng dụng của chúng tôi thường được thiết kế để quản lý các bộ sưu tập dữ liệu lớn.

00:08:02.000 --> 00:08:16.000
Để giúp dễ dàng xây dựng các ứng dụng sử dụng dữ liệu được chia sẻ này, NSPersistentCloudKitContainer cũng phải giúp chúng tôi hiểu được tất cả các đối tượng này để chúng tôi có thể xây dựng giao diện người dùng thông tin cho người dùng của mình.

00:08:16.000 --> 00:08:24.000
Để hiểu những thách thức này rõ ràng hơn một chút, chúng ta cần xác định hai khái niệm quan trọng để chia sẻ.

00:08:24.000 --> 00:08:28.000
Đầu tiên là khái niệm về một tập hợp các diễn viên.

00:08:28.000 --> 00:08:31.000
Chúng tôi gọi họ là chủ sở hữu và những người tham gia.

00:08:31.000 --> 00:08:35.000
Chủ sở hữu là tài khoản iCloud thực sự sở hữu một đối tượng.

00:08:35.000 --> 00:08:40.000
Chủ sở hữu tạo và chia sẻ các đối tượng với một nhóm người tham gia.

00:08:40.000 --> 00:08:47.000
Người tham gia là bất kỳ tài khoản iCloud nào khác được phép hoạt động trên các đối tượng đó theo một cách nào đó.

00:08:47.000 --> 00:09:05.000
Những người tham gia có thể có các vai trò và quyền khác nhau hạn chế cách họ có thể hành động trên một tập hợp các đối tượng cụ thể, điều này đưa chúng ta đến khái niệm chính thứ hai: cách NSPersistentCloudKitContainer và CloudKit cấu trúc các đối tượng được chia sẻ này.

00:09:05.000 --> 00:09:10.000
Trong Core Data, chúng tôi nghĩ về các đối tượng của mình dưới dạng NSManagedObject.

00:09:10.000 --> 00:09:19.000
NSPersistentCloudKitContainer biến các đối tượng được quản lý đó thành các trường hợp của CKRecord được lưu trữ trong CloudKit.

00:09:19.000 --> 00:09:29.000
Nếu bạn đã từng làm việc với việc chia sẻ trước đây, có lẽ bạn đã quen thuộc với việc chia sẻ phân cấp, trong đó các bản ghi này được liên kết với một bản ghi gốc được gọi là chia sẻ.

00:09:29.000 --> 00:09:33.000
Nhưng đây không phải là cách NSPersistentCloudKitContainer hoạt động.

00:09:33.000 --> 00:09:44.000
NSPersistentCloudKitContainer sử dụng một tính năng mới trong CloudKit được gọi là Record Zone Sharing, được đề cập chi tiết hơn trong phiên "Có gì mới trong CloudKit".

00:09:44.000 --> 00:09:53.000
Nhưng chúng ta hãy xem cách NSPersistentCloudKitContainer sử dụng Record Zone Sharing để chia sẻ các đối tượng được quản lý.

00:09:53.000 --> 00:10:04.000
Ví dụ, trong cơ sở dữ liệu CloudKit--, cơ sở dữ liệu .private-- NSPersistentCloudKitContainer thường quản lý một vùng riêng tư để lưu trữ các đối tượng mà ứng dụng tạo ra.

00:10:04.000 --> 00:10:11.000
Trong Record Zone Sharing, các CKRecords được chia sẻ được chứa bên trong một CKRecordZone được chia sẻ.

00:10:11.000 --> 00:10:17.000
Các vùng bản ghi được chia sẻ được xác định bởi sự hiện diện của một bản ghi CKShare duy nhất.

00:10:17.000 --> 00:10:29.000
Như với việc chia sẻ phân cấp, bản ghi này chứa tất cả thông tin cần thiết để làm việc với khu vực, như chủ sở hữu, người tham gia, và quyền và vai trò của họ.

00:10:29.000 --> 00:10:35.000
NSPersistentCloudKitContainer quản lý các vùng này và tự động gán các bản ghi cho chúng.

00:10:35.000 --> 00:10:47.000
Bởi vì không có bản ghi gốc, NSPersistentCloudKitContainer cũng phải hiểu cách các khái niệm về chủ sở hữu và người tham gia áp dụng cho toàn bộ vùng bản ghi.

00:10:47.000 --> 00:10:52.000
Hãy tưởng tượng tôi có một bộ sưu tập những người mà tôi muốn chia sẻ cùng.

00:10:52.000 --> 00:11:02.000
Chia sẻ với một người khác rất thú vị, nhưng NSPersistentCloudKitContainer được thiết kế để tạo điều kiện chia sẻ cho các quần thể lớn hơn nhiều.

00:11:02.000 --> 00:11:08.000
Mỗi người tham gia này sẽ có thể truy cập và vận hành trên các đối tượng mà tôi chia sẻ với họ.

00:11:08.000 --> 00:11:14.000
Và tôi sẽ có thể truy cập và vận hành trên các đối tượng mà họ chia sẻ với tôi.

00:11:14.000 --> 00:11:19.000
Mỗi người tham gia cũng sẽ có bộ sưu tập thiết bị của riêng họ.

00:11:19.000 --> 00:11:26.000
Với NSPersistentCloudKitContainer, các ứng dụng có thể hoạt động trên các đối tượng được chia sẻ từ bất kỳ thiết bị Apple nào.

00:11:26.000 --> 00:11:37.000
Đối với mỗi người tham gia, NSPersistentCloudKitContainer quản lý các đối tượng trong hai cơ sở dữ liệu CloudKit, cơ sở dữ liệu .private và .shared.

00:11:37.000 --> 00:11:45.000
Trong cơ sở dữ liệu .private của tôi, tôi sẽ thấy các bản ghi và vùng mà tôi sở hữu cho dù các vùng đó có được chia sẻ hay không.

00:11:45.000 --> 00:11:50.000
Ví dụ, vùng mà NSPersistentCloudKitContainer quản lý.

00:11:50.000 --> 00:12:03.000
Với việc chia sẻ, NSPersistentCloudKitContainer cũng sẽ tạo các vùng được chia sẻ cho tôi với bản ghi CKShare kiểm soát ai có thể truy cập các vùng này mà tôi sở hữu.

00:12:03.000 --> 00:12:11.000
Tôi và, nếu được cho phép, những người tham gia khác có thể thêm và sửa đổi các bản ghi trong các khu vực được chia sẻ này.

00:12:11.000 --> 00:12:17.000
Trong cơ sở dữ liệu .shared của tôi, tôi sẽ thấy các vùng bản ghi mà những người dùng khác đã chia sẻ với tôi.

00:12:17.000 --> 00:12:27.000
Nếu tôi được phép, tôi có thể thêm các bản ghi mà tôi sở hữu vào bất kỳ khu vực nào trong số đó giống như chúng có thể trong các khu vực mà tôi sở hữu.

00:12:27.000 --> 00:12:37.000
Một người dùng khác sẽ thấy một tập hợp các vùng khác nhau trong cơ sở dữ liệu .private và .shared của họ, tùy thuộc vào việc họ có phải là chủ sở hữu của các vùng đó hay không.

00:12:37.000 --> 00:12:45.000
Ví dụ, người dùng này có thể có một vùng riêng tư và một vùng chia sẻ mà họ sở hữu trong cơ sở dữ liệu .private của họ.

00:12:45.000 --> 00:12:56.000
Ngoài ra, họ sẽ thấy hai khu vực của tôi mà tôi chia sẻ với họ và bất kỳ khu vực nào khác mà họ là người tham gia vào cơ sở dữ liệu .shared của họ.

00:12:56.000 --> 00:13:02.000
Vậy làm thế nào để NSPersistentCloudKitContainer biết nơi lưu giữ hồ sơ của bạn?

00:13:02.000 --> 00:13:09.000
Trong nhiều trường hợp, nó có thể suy ra nơi các bản ghi thuộc về dựa trên mối quan hệ mà chúng có với các đối tượng khác.

00:13:09.000 --> 00:13:20.000
Nhưng bạn cũng có thể yêu cầu share(_ managedObjects: to share: completion:) lưu trữ các đối tượng trong một vùng được chia sẻ cụ thể bằng cách chuyển cho nó một CKShare không-nil.

00:13:20.000 --> 00:13:32.000
Ví dụ: nếu tôi thay đổi dòng mã này để sử dụng một chia sẻ hiện có, NSPersistentCloudKitContainer sẽ cố gắng gán đối tượng bài đăng được cung cấp cho chia sẻ đó.

00:13:32.000 --> 00:13:45.000
Đây là tất cả những thay đổi tôi phải thực hiện cho bản demo đầu tiên của mình, nhưng ứng dụng của tôi cũng cần truyền đạt hiệu quả những đối tượng nào được chia sẻ, chúng được chia sẻ với ai và những người tham gia đó có thể làm gì.

00:13:45.000 --> 00:13:53.000
Người dùng của chúng tôi cần tất cả thông tin đó để họ có thể đưa ra quyết định đúng đắn về các đối tượng mà họ chọn chia sẻ.

00:13:53.000 --> 00:13:58.000
Vì vậy, hãy xem cách tôi đã thay đổi đơn đăng ký của mình để truyền đạt các trạng thái và đặc quyền này.

00:13:58.000 --> 00:14:08.000
Quay trở lại ứng dụng mẫu, tôi có thể thấy dữ liệu từ bản demo đầu tiên hiện được hiển thị với một số trang trí giao diện người dùng mới để chỉ ra rằng bài đăng đã được chia sẻ.

00:14:08.000 --> 00:14:18.000
Nếu tôi nhấn vào nó, tôi cũng có thể thấy những người tham gia được hiển thị ở cuối bộ điều khiển chế độ xem chi tiết với vai trò, quyền và trạng thái chấp nhận của họ.

00:14:18.000 --> 00:14:25.000
Chúng ta có thể thấy ở đây rằng Jermaine là chủ sở hữu của phần chia sẻ có chứa bài đăng và Heather là một người tham gia tư nhân.

00:14:25.000 --> 00:14:37.000
Bây giờ tôi sẽ thêm một bài đăng mới, đặt tiêu đề cho nó và nhấn Xong.

00:14:37.000 --> 00:14:48.000
Tôi sẽ nhấn vào nút Hành động để hiển thị bộ điều khiển chia sẻ, nhưng lần này, tôi muốn chia sẻ chỉ được đọc để những người tham gia không thể chỉnh sửa hoặc sửa đổi nội dung của chia sẻ.

00:14:48.000 --> 00:14:52.000
Vì vậy, tôi sẽ thay đổi các tùy chọn chia sẻ để đánh dấu chia sẻ là Chỉ xem.

00:14:52.000 --> 00:14:59.000
Tiếp theo, tôi sẽ nhấn vào Thư và mời Jermaine và Mary.

00:14:59.000 --> 00:15:03.000
Cuối cùng, tôi sẽ gửi email.

00:15:03.000 --> 00:15:08.000
Trên thiết bị của Mary, tôi sẽ chấp nhận chia sẻ mới và bây giờ tôi có thể xem bài đăng mới.

00:15:08.000 --> 00:15:18.000
Nếu tôi nhấn vào nó, tôi có thể thấy rằng nút Chỉnh sửa bị vô hiệu hóa và mục nhập của người tham gia cho Mary cho thấy rằng cô ấy là người tham gia Chỉ đọc trên chia sẻ.

00:15:18.000 --> 00:15:30.000
Tương tự như vậy, tôi không thể vuốt để xóa bài đăng này và nếu tôi đặt chế độ xem bảng ở chế độ chỉnh sửa bằng cách nhấn vào nút Chỉnh sửa, tôi không thể xóa bài đăng này.

00:15:30.000 --> 00:15:37.000
Trên thiết bị của Jermaine bây giờ, tôi sẽ chấp nhận chia sẻ mới.

00:15:37.000 --> 00:15:42.000
Và bây giờ tôi có thể xem bài đăng mới.

00:15:42.000 --> 00:15:56.000
Nếu tôi nhấn vào nó, tôi có thể thấy rằng nút Chỉnh sửa bị vô hiệu hóa và mục nhập của người tham gia cho Jermaine cho thấy anh ấy là người tham gia Chỉ đọc trên chia sẻ.

00:15:56.000 --> 00:16:05.000
Ngay cả trong ứng dụng mẫu khiêm tốn này, tôi đã phải thực hiện một số thay đổi đối với giao diện người dùng để trình bày thông tin về các đối tượng được chia sẻ.

00:16:05.000 --> 00:16:10.000
Tôi đã phải trang trí các ô bảng bài đăng để chỉ ra những ô nào được chia sẻ.

00:16:10.000 --> 00:16:19.000
Tôi cũng phải thêm logic để bật hoặc tắt các điều khiển chỉnh sửa, tùy thuộc vào các quyền được gán cho người tham gia người dùng hiện tại.

00:16:19.000 --> 00:16:28.000
Và cuối cùng, tôi đã phải xây dựng các yếu tố giao diện người dùng mới để hiển thị thông tin về những người tham gia trên một chia sẻ cá nhân.

00:16:28.000 --> 00:16:35.000
Tất cả công việc này yêu cầu truy cập một số siêu dữ liệu về CKShare một bài đăng cụ thể nằm trong đó.

00:16:35.000 --> 00:16:42.000
NSPersistentCloudKitContainer bao gồm một số phương thức API để phù hợp với từng mối quan tâm này.

00:16:42.000 --> 00:16:50.000
fetchShares (matching objectIDs:) là mới trong iOS 15 và cho phép tôi lấy CKShare cho một bài đăng cụ thể.

00:16:50.000 --> 00:17:00.000
Nhưng ba phương pháp chỉnh sửa có điều kiện này đã được giới thiệu cùng với sự hỗ trợ cơ sở dữ liệu công khai của chúng tôi tại WWDC vào năm 2020.

00:17:00.000 --> 00:17:05.000
Bạn có thể sử dụng các phương pháp này trong các ứng dụng của mình ở bất cứ nơi nào bạn cần để tùy chỉnh giao diện người dùng của mình.

00:17:05.000 --> 00:17:10.000
Nhưng trong đơn đăng ký của tôi, tôi đã có một cách tiếp cận hơi khác.

00:17:10.000 --> 00:17:21.000
Thay vì gọi trực tiếp các phương thức trên NSPersistentCloudKitContainer, tôi đã xây dựng một giao thức hiển thị một phương thức cụ thể cho mỗi tùy chỉnh mà tôi cần.

00:17:21.000 --> 00:17:23.000
Nó được gọi là SharingProvider.

00:17:23.000 --> 00:17:29.000
SharingProvider có các phương thức liên kết trực tiếp với các trang web cuộc gọi cụ thể trong ứng dụng của tôi.

00:17:29.000 --> 00:17:34.000
Ví dụ, tôi có thể cần biết liệu một đối tượng có được chia sẻ hay không.

00:17:34.000 --> 00:17:44.000
Nếu nó được chia sẻ, tôi có thể cần tìm nạp CKShare hoặc những người tham gia để đối tượng đó hiển thị thêm thông tin trong giao diện người dùng của mình.

00:17:44.000 --> 00:17:52.000
Cuối cùng, một đối tượng có thể không phải lúc nào cũng có thể thay đổi và những người tham gia cá nhân có thể có các quyền khác nhau trên cùng một đối tượng.

00:17:52.000 --> 00:17:58.000
Giao thức này giúp dễ dàng thêm logic cụ thể vào mã ứng dụng của tôi.

00:17:58.000 --> 00:18:05.000
Và tôi muốn chỉ cho bạn một trang web cuộc gọi cụ thể trong MainViewController, nơi tôi cần biết liệu một đối tượng có được chia sẻ hay không.

00:18:05.000 --> 00:18:18.000
Ở đây tôi đã sử dụng isShared để quyết định có chuyển đổi tiêu đề của bài đăng thành chuỗi được gán hay không và đặt tiền tố nó bằng biểu tượng person.circle để cho thấy rằng bài đăng là một phần của chia sẻ.

00:18:18.000 --> 00:18:26.000
Các tùy chỉnh như thế này nhất thiết phải yêu cầu mã phức tạp hơn nếu tôi chọn không hỗ trợ chia sẻ.

00:18:26.000 --> 00:18:38.000
Sau khi thêm một vài trong số các tùy chỉnh này, rõ ràng là tôi cần một cách để đảm bảo tất cả chúng hoạt động chính xác, điều này đưa tôi đến lý do chính mà SharingProvider tồn tại: thử nghiệm.

00:18:38.000 --> 00:18:44.000
Giao thức SharingProvider giúp dễ dàng kiểm tra các điểm quyết định này bằng cách tiêm.

00:18:44.000 --> 00:18:54.000
Đoạn mã này là một phần của trường hợp thử nghiệm mà tôi đã viết cho MainViewController để đảm bảo rằng các ô bảng của nó cho biết chính xác nếu một bài đăng được chia sẻ.

00:18:54.000 --> 00:19:08.000
Tôi đã bỏ qua giàn giáo để tạo dữ liệu mẫu, nhưng bài kiểm tra tạo ra một tập hợp hỗn hợp các đối tượng được quản lý mà nó xác định là được chia sẻ hoặc không được chia sẻ bởi sự hiện diện của objectID của chúng trong tập hợp này.

00:19:08.000 --> 00:19:23.000
Tiếp theo, tôi định cấu hình một phiên bản của BlockBasedShareProvider, một lớp được viết riêng để thử nghiệm, cho phép tôi đưa logic tùy chỉnh một cách tầm thường vào sharingProvider mà MainViewController sử dụng.

00:19:23.000 --> 00:19:30.000
Ở đây tôi đang thiết lập isSharedBlock để gọi phương thức chứa của tập hợp tôi đã tạo.

00:19:30.000 --> 00:19:38.000
Đây là một thủ thuật dễ thương trong Swift cho phép tôi chỉ cần kiểm tra xem objectID được cung cấp có trong sharedObjectIDs hay không.

00:19:38.000 --> 00:19:45.000
Sau đó, tôi đặt BlockBasedProvider làm nhà cung cấp cho bộ điều khiển chế độ xem, hoàn tất việc tiêm.

00:19:45.000 --> 00:20:02.000
Cuối cùng, bài kiểm tra này yêu cầu MainViewController cung cấp các ô bảng của nó, xác minh rằng những ô tôi đã đưa vào bộ sharedObjectIDs có tiền tố dự kiến và các ô tương ứng với các đối tượng không được chia sẻ thì không.

00:20:02.000 --> 00:20:10.000
Việc triển khai thực tế cho isShared nằm trong CoreDataStack, nơi quản lý vùng chứa CloudKit liên tục cho ứng dụng của tôi.

00:20:10.000 --> 00:20:16.000
Và bạn có thể thấy nó phức tạp hơn một chút so với mũi tiêm đơn giản mà tôi đã sử dụng trong bài kiểm tra.

00:20:16.000 --> 00:20:22.000
Bây giờ, tôi có thể thực hiện từng dòng một, nhưng đó không phải là điều quan trọng ở đây.

00:20:22.000 --> 00:20:36.000
Điều quan trọng là nó phức tạp hơn tôi có thể dễ dàng tập thể dục mỗi khi tôi muốn xác minh thay đổi chế độ xem bảng và cố gắng làm như vậy sẽ tạo thêm nhiều ma sát cho quá trình phát triển.

00:20:36.000 --> 00:20:47.000
Mặt khác, kỹ thuật tiêm này giúp dễ dàng và nhanh chóng kiểm tra các cấu hình khác nhau của các đối tượng được chia sẻ mà không cần nói chuyện với máy chủ CloudKit.

00:20:47.000 --> 00:21:01.000
Trước tiên cần thêm một chút mã để viết tất cả các bài kiểm tra này và cấu trúc ứng dụng theo cách tạo điều kiện cho loại tiêm này, nhưng kết quả là sự tự tin và độ tin cậy rất xứng đáng.

00:21:01.000 --> 00:21:15.000
Như tôi đã đề cập, SharingProvider bao gồm một số phương pháp quan trọng khác cho ứng dụng mẫu và tôi khuyến khích bạn kiểm tra việc triển khai của chúng và các bài kiểm tra mà tôi đã viết về cách chúng tác động đến giao diện người dùng.

00:21:15.000 --> 00:21:25.000
Nói chung, tôi đã thêm hơn 1200 dòng mã kiểm tra và tôi hy vọng những ví dụ này giúp bạn thực sự dễ dàng xây dựng các bài kiểm tra trong các ứng dụng của riêng mình.

00:21:25.000 --> 00:21:35.000
Chủ đề cuối cùng tôi muốn đề cập hôm nay là hỗ trợ cho một tính năng mới khác trong CloudKit: các giá trị CKRecord được mã hóa.

00:21:35.000 --> 00:21:44.000
Các giá trị này được lưu trữ trong một tải trọng mới trên CKRecord được gọi là encryptedValues, được giới thiệu trong phiên "Có gì mới trong CloudKit".

00:21:44.000 --> 00:21:51.000
Tải trọng mới này trên CKRecord cho phép các giá trị được mã hóa bằng vật liệu chính từ móc khóa của người dùng.

00:21:51.000 --> 00:22:03.000
Các giá trị này được giải mã cục bộ trên thiết bị sau khi chúng được tải xuống từ máy chủ CloudKit và chúng được mã hóa cục bộ trên thiết bị trước khi chúng được tải lên máy chủ CloudKit.

00:22:03.000 --> 00:22:09.000
Chúng tôi đã cho phép áp dụng các giá trị được mã hóa chỉ với một cú nhấp chuột trong Xcode.

00:22:09.000 --> 00:22:13.000
Hãy xem điều đó trong hành động.

00:22:13.000 --> 00:22:19.000
Ở đây trong Xcode, tôi đã mở ứng dụng mẫu của chúng tôi, Đồng bộ hóa Kho dữ liệu cốt lõi với Đám mây.

00:22:19.000 --> 00:22:29.000
Tôi sẽ mở mô hình đối tượng được quản lý CoreDataCloudKitDemo và có một thuộc tính cụ thể trên thực thể bài đăng mà tôi muốn hiển thị cho bạn được gọi là vị trí.

00:22:29.000 --> 00:22:36.000
Nếu tôi chọn thuộc tính vị trí, tôi có thể thấy cấu hình của nó trong trình kiểm tra mô hình dữ liệu ở bên phải.

00:22:36.000 --> 00:22:44.000
Tôi đã định cấu hình nó thành một thuộc tính Transformable tùy chọn và chọn hộp kiểm Cho phép mã hóa đám mây mới này.

00:22:44.000 --> 00:22:55.000
Hộp kiểm mới này cho NSPersistentCloudKitContainer biết rằng giá trị cho thuộc tính này nên được lưu trữ trong tải trọng Giá trị được mã hóa của CKRecord kết quả.

00:22:55.000 --> 00:23:07.000
Nếu bạn thích đọc ma trận dưới dạng mã, có một boolean mới - cho phép CloudEncryption - trên NSAttributeDescription mà bạn có thể sử dụng để định cấu hình thuộc tính này trong mã mô hình của mình.

00:23:07.000 --> 00:23:13.000
Bây giờ, mã hóa với CloudKit là một quyết định tại thời điểm giới thiệu.

00:23:13.000 --> 00:23:20.000
Điều đó có nghĩa là chúng ta không thể thay đổi suy nghĩ của mình sau này và chọn mã hóa các trường chưa được mã hóa ngày nay trong quá trình sản xuất.

00:23:20.000 --> 00:23:26.000
Tương tự như vậy, bạn không thể chọn hủy mã hóa một trường đã được mã hóa.

00:23:26.000 --> 00:23:32.000
Một khi lược đồ CloudKit được đẩy vào sản xuất, chúng tôi không thể thay đổi bất kỳ loại trường nào.

00:23:32.000 --> 00:23:44.000
Vì vậy, hãy đảm bảo sử dụng phương pháp initializeSchema của NSPersistentCloudKitContainer để đảm bảo rằng tất cả các trường của bạn đều có mặt và được nhập chính xác trước khi triển khai lược đồ của bạn vào sản xuất.

00:23:44.000 --> 00:23:52.000
Tôi rất hân hạnh được giới thiệu một số thay đổi mà chúng tôi đã thực hiện cho NSPersistentCloudKitContainer để hỗ trợ chia sẻ.

00:23:52.000 --> 00:23:54.000
Có rất nhiều API mới để tìm hiểu.

00:23:54.000 --> 00:24:11.000
Vì vậy, chúng tôi đã cập nhật ứng dụng mẫu của mình và tài liệu để chứng minh cách bạn có thể sử dụng nó trong các ứng dụng của riêng mình, bao gồm cách bạn có thể viết các bài kiểm tra để xác minh cách ứng dụng của bạn phản hồi với các trạng thái khác nhau mà các đối tượng có thể có khi làm việc với CloudKit.

00:24:11.000 --> 00:24:17.000
Và hãy chắc chắn cho chúng tôi biết nếu bạn gặp phải bất kỳ vấn đề nào bằng cách nộp lỗi với Trợ lý Phản hồi.

00:24:17.000 --> 00:24:22.000
Như mọi khi, tôi nóng lòng muốn xem những gì bạn xây dựng với NSPersistentCloudKitContainer.

00:24:22.000 --> 00:24:28.000
Duy trì hoạt động, đóng vòng của bạn và có một WWDC 2021 tuyệt vời.

00:24:28.000 --> 23:59:59.000
[Âm nhạc].

