WEBVTT

00:00:00.000 --> 00:00:05.000
♪ Nhạc bass đang phát ♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:13.000
Wil Addario-Turner: Xin chào, chào mừng đến với "Nắm bắt những thất bại dự kiến trong XCTest."

00:00:13.000 --> 00:00:21.000
Tên tôi là Wil, và trong phiên này, tôi sẽ thảo luận về các cách cải thiện dữ liệu bạn nhận được khi bạn chạy các bài kiểm tra dự án của mình.

00:00:21.000 --> 00:00:25.000
Để bắt đầu, hãy xem xét lý do tại sao chúng tôi kiểm tra mã của mình ngay từ đầu.

00:00:25.000 --> 00:00:29.000
Tất nhiên, ở cấp độ cao, đó là cách chúng tôi đảm bảo chất lượng của sản phẩm.

00:00:29.000 --> 00:00:37.000
Nhưng nói một cách cụ thể hơn, tôi sẽ nói rằng đó là phát hiện ra lỗi trước khi chúng tôi giao hàng chứ không phải sau đó.

00:00:37.000 --> 00:00:39.000
Bây giờ, thử nghiệm là một khoản đầu tư.

00:00:39.000 --> 00:00:44.000
Cần có tài nguyên để tạo, chạy và duy trì các bài kiểm tra.

00:00:44.000 --> 00:00:50.000
Như với bất kỳ khoản đầu tư nào, chúng tôi muốn tối đa hóa lợi nhuận của mình trong khi giảm thiểu chi phí.

00:00:50.000 --> 00:00:54.000
Phiên này tập trung vào các công cụ để giảm chi phí bảo trì.

00:00:54.000 --> 00:01:02.000
Bằng cách bảo trì, tôi chủ yếu đề cập đến cách bạn xử lý các lỗi khi chúng xảy ra trong bộ thử nghiệm của bạn.

00:01:02.000 --> 00:01:07.000
Khi một bài kiểm tra đã vượt qua bắt đầu thất bại, đó là một thông tin mới có giá trị.

00:01:07.000 --> 00:01:21.000
Điều này cho thấy một lỗ hổng trong sản phẩm, một vấn đề trong chính bài kiểm tra hoặc một số vấn đề ở một trong những phụ thuộc - nghĩa là, tất cả các khuôn khổ và hệ thống con mà sản phẩm nằm trên đó.

00:01:21.000 --> 00:01:34.000
Bất kể loại vấn đề nào, một khi thất bại đó đã được đăng ký, các báo cáo tiếp theo về cùng một thất bại sẽ ít có giá trị hơn đáng kể, bởi vì chúng đại diện cho thông tin mà bạn đã có.

00:01:34.000 --> 00:01:38.000
Lý tưởng nhất, bất kỳ lỗi mới nào cũng được phân loại và khắc phục nhanh chóng.

00:01:38.000 --> 00:01:50.000
Tuy nhiên, nhóm của bạn có thể không thể giải quyết vấn đề ngay lập tức, điều đó có nghĩa là thất bại nhanh chóng chuyển từ một phần thông tin mới có giá trị sang một sự phân tâm ồn ào.

00:01:50.000 --> 00:01:58.000
Với một thất bại đã biết trong các bài kiểm tra của bạn mà không thể được giải quyết ngay lập tức, những công cụ nào có sẵn để quản lý tiếng ồn?

00:01:58.000 --> 00:02:03.000
Hai cách tiếp cận có thể xuất hiện trong đầu là vô hiệu hóa và bỏ qua.

00:02:03.000 --> 00:02:13.000
Hãy xem xét sự đánh đổi cho những thứ này và sau đó chúng ta sẽ nói về công cụ tốt nhất - và chủ đề của phiên này - API ExpectedFailures của XCTest.

00:02:13.000 --> 00:02:17.000
Xcode cho phép bạn vô hiệu hóa các bài kiểm tra trong kế hoạch hoặc sơ đồ kiểm tra.

00:02:17.000 --> 00:02:23.000
Bạn có thể sử dụng điều này cho các lỗi kiểm tra đã biết và một lợi thế là mã kiểm tra của bạn sẽ tiếp tục được biên dịch.

00:02:23.000 --> 00:02:27.000
Tuy nhiên, vì mã sẽ không thực thi, bạn sẽ không thấy nó trong báo cáo thử nghiệm.

00:02:27.000 --> 00:02:34.000
Khả năng hiển thị giảm này khiến việc theo dõi như một vấn đề cần được giải quyết trở nên khó khăn hơn.

00:02:34.000 --> 00:02:44.000
Trường hợp tính năng này - khả năng chọn bài kiểm tra nào được bật hoặc tắt - thực sự tỏa sáng là để quản lý các bộ sưu tập bài kiểm tra cho các mục đích cụ thể.

00:02:44.000 --> 00:02:49.000
Nhưng nó hiếm khi là cách tốt nhất để xử lý một thất bại đã biết.

00:02:49.000 --> 00:02:54.000
XCTSkip là một cách khác để bạn có thể quản lý bài kiểm tra không thành công.

00:02:54.000 --> 00:03:03.000
Với cách tiếp cận này, mã không chỉ tiếp tục được xây dựng với các bài kiểm tra của bạn, nó còn thực thi cho đến khi XCTSkip được gọi.

00:03:03.000 --> 00:03:10.000
Điều này có nghĩa là nó được bao gồm trong báo cáo thử nghiệm, giúp bạn có khả năng hiển thị vấn đề tốt hơn nhiều.

00:03:10.000 --> 00:03:21.000
Tuy nhiên, nó không thực hiện tất cả các bài kiểm tra của bạn, điều đó có nghĩa là bạn mất đi thông tin hữu ích tiềm ẩn dưới dạng các vấn đề mới và thay đổi đối với vấn đề hiện có.

00:03:21.000 --> 00:03:31.000
XCTSkip là một công cụ tuyệt vời để quản lý các giới hạn dựa trên cấu hình trong bài kiểm tra của bạn, chẳng hạn như yêu cầu một phiên bản hệ điều hành hoặc loại thiết bị cụ thể.

00:03:31.000 --> 00:03:37.000
Trong ví dụ ở đây, bài kiểm tra sẽ bị bỏ qua nếu nó không chạy trên iPad.

00:03:37.000 --> 00:03:46.000
Điều này đưa chúng ta đến XCTExpectFailure, một tập hợp các chức năng trong XCTest được thiết kế đặc biệt để quản lý các lỗi đã biết.

00:03:46.000 --> 00:03:55.000
Trong Swift, nó có một số quá tải cho các trường hợp sử dụng khác nhau và Objective-C cung cấp các khả năng tương tự với một số chức năng riêng biệt.

00:03:55.000 --> 00:04:05.000
Với API này, bài kiểm tra của bạn thực hiện bình thường, nhưng kết quả được thay đổi như sau: Thất bại trong bài kiểm tra sẽ được báo cáo là thất bại dự kiến.

00:04:05.000 --> 00:04:15.000
Thất bại trong bộ kiểm tra chứa bài kiểm tra đó sẽ được báo cáo là vượt qua, tất nhiên trừ khi một số bài kiểm tra khác trong đó không thành công.

00:04:15.000 --> 00:04:23.000
Điều này giúp loại bỏ tiếng ồn do lỗi tạo ra, giúp bạn dễ dàng xem liệu có bất kỳ vấn đề nào khác trong các bài kiểm tra của bạn hay không.

00:04:23.000 --> 00:04:27.000
Tất nhiên, việc ngăn chặn tiếng ồn không giải quyết được vấn đề tiềm ẩn.

00:04:27.000 --> 00:04:31.000
Vì vậy, để giúp bạn theo dõi nó, API có lý do thất bại.

00:04:31.000 --> 00:04:40.000
Chuỗi này ghi lại sự cố trong mã của bạn và thậm chí bạn có thể nhúng URL cho hệ thống theo dõi sự cố của mình.

00:04:40.000 --> 00:04:47.000
Giao diện người dùng báo cáo thử nghiệm của Xcode hiển thị các lỗi dự kiến giống như các lỗi thông thường hoặc các bài kiểm tra bị bỏ qua.

00:04:47.000 --> 00:04:56.000
Khi bạn di chuột, nếu lý do thất bại có chứa URL, một nút theo dõi sự cố sẽ xuất hiện cho phép bạn chuyển ra liên kết.

00:04:56.000 --> 00:04:59.000
Vậy hãy xem cái này hoạt động như thế nào!

00:04:59.000 --> 00:05:04.000
Tôi có ở đây một dự án đơn giản với một số bài kiểm tra đơn vị cho lớp VendorAccount của tôi.

00:05:04.000 --> 00:05:12.000
Tôi sẽ chạy các bài kiểm tra, và khi chúng kết thúc, chúng ta sẽ thấy rằng cái này đang thất bại trong khi cái kia đang vượt qua.

00:05:12.000 --> 00:05:16.000
Bạn có thể thấy ba biểu tượng kết quả kiểm tra, một cho mỗi bài kiểm tra.

00:05:16.000 --> 00:05:29.000
Một dấu X màu đỏ cho bài kiểm tra thất bại và một dấu kiểm tra màu xanh lá cây cho bài kiểm tra vượt qua, và một cho bộ bài kiểm tra; một dấu X màu đỏ vì một trong những bài kiểm tra trong bộ đã thất bại, vì vậy chúng tôi cho rằng bản thân bộ đã thất bại.

00:05:29.000 --> 00:05:37.000
Bây giờ tôi sẽ thêm một cuộc gọi đến XCTExpectFailure khi bắt đầu bài kiểm tra thất bại.

00:05:37.000 --> 00:05:45.000
Bạn có thể thấy lý do thất bại bắt đầu bằng một URL tham chiếu đến lỗi tôi đã gửi để theo dõi lỗi này.

00:05:45.000 --> 00:05:50.000
Bây giờ tôi sẽ chạy lại các bài kiểm tra và chúng ta sẽ xem điều này ảnh hưởng đến kết quả như thế nào.

00:05:50.000 --> 00:05:58.000
Được rồi, vì vậy biểu tượng X màu đỏ cho bài kiểm tra thất bại đã thay đổi thành X màu xám, đây là chỉ báo cho một thất bại dự kiến.

00:05:58.000 --> 00:06:05.000
Điều thú vị hơn nữa là biểu tượng bộ kiểm tra đã thay đổi từ dấu X màu đỏ sang dấu gạch ngang màu xanh lá cây.

00:06:05.000 --> 00:06:17.000
Biểu tượng này chỉ ra rằng bộ bài kiểm tra đã vượt qua với trạng thái hỗn hợp, có nghĩa là một hoặc nhiều bài kiểm tra của nó không vượt qua, mà là bỏ qua hoặc thất bại dự kiến.

00:06:17.000 --> 00:06:22.000
Vì vậy, đó là cách dễ dàng để sử dụng XCTExpectFailure để xử lý một bài kiểm tra thất bại.

00:06:22.000 --> 00:06:29.000
Bây giờ chúng ta hãy xem xét kỹ hơn API.

00:06:29.000 --> 00:06:35.000
Cân nhắc đầu tiên khi sử dụng XCTExpectFailure là biến thể API nào cần gọi.

00:06:35.000 --> 00:06:52.000
Có hai cách tiếp cận: một cách tiếp cận trạng thái trong đó bạn gọi XCTExpectFailure và bất kỳ lỗi tiếp theo nào trong bài kiểm tra đều được xử lý như mong đợi; cách khác, bạn có thể sử dụng cách tiếp cận có phạm vi, trong đó bạn bọc mã không thành công trong một đóng được chuyển đến XCTExpectFailure.

00:06:52.000 --> 00:06:55.000
Hãy xem xét một số ví dụ.

00:06:55.000 --> 00:06:59.000
Đây là một bài kiểm tra rất đơn giản gọi một số chức năng trong dự án của tôi.

00:06:59.000 --> 00:07:04.000
Bài kiểm tra bắt đầu thất bại vì hàm không còn trả về true nữa.

00:07:04.000 --> 00:07:11.000
Đây là những gì nó trông giống như để sử dụng cách tiếp cận thất bại dự kiến trạng thái, giống như chúng tôi đã làm trong bản demo.

00:07:11.000 --> 00:07:19.000
Ngoài ra, chúng ta có thể sử dụng cách tiếp cận có phạm vi bằng cách gói mã không thành công trong một kết thúc theo sau cuộc gọi đến XCTExpectFailure.

00:07:19.000 --> 00:07:25.000
Điều này có nghĩa là bất kỳ lỗi nào trong mã bên ngoài việc đóng cửa sẽ được báo cáo bình thường.

00:07:25.000 --> 00:07:28.000
API cũng hỗ trợ lồng nhau.

00:07:28.000 --> 00:07:36.000
Nói cách khác, bạn có thể gọi API nhiều lần trong một bài kiểm tra, bao gồm cả bên trong phần đóng từ một cuộc gọi khác.

00:07:36.000 --> 00:07:41.000
Đây là một cân nhắc quan trọng khi sử dụng API trong mã thư viện thử nghiệm.

00:07:41.000 --> 00:07:53.000
Ví dụ, nếu một chức năng tiện ích chung bắt đầu thất bại, nhiều bài kiểm tra có thể bị ảnh hưởng, một số trong đó có thể đã sử dụng XCTExpectFailure cho các vấn đề khác nhau.

00:07:53.000 --> 00:08:11.000
Khi xảy ra lỗi trong ngữ cảnh các cuộc gọi lồng nhau đến XCTExpectFailure, vấn đề sẽ được khớp với trang web cuộc gọi gần nhất trước và nếu bị người đối sánh từ chối, sẽ được chuyển sang cuộc gọi tiếp theo, v.v. với ngữ nghĩa ngăn xếp cho các cuộc gọi đến XCTExpectFailure.

00:08:11.000 --> 00:08:19.000
Vì lý do này, với mã được chia sẻ, tốt nhất bạn nên sử dụng API dựa trên đóng để hạn chế ảnh hưởng đến trạng thái thử nghiệm.

00:08:19.000 --> 00:08:24.000
Điều tiếp theo cần xem xét là làm thế nào chính xác để phù hợp với vấn đề.

00:08:24.000 --> 00:08:32.000
Theo mặc định, bất kỳ lỗi nào trong phạm vi bị ảnh hưởng đều bị phát hiện, nhưng bạn có thể chọn lọc hơn bằng cách chỉ định bộ lọc khớp vấn đề.

00:08:32.000 --> 00:08:41.000
Trong ví dụ này, chúng tôi xây dựng một đối tượng thuộc loại XCTExpectedFailure.Options và xác định issueMatcher của nó.

00:08:41.000 --> 00:08:50.000
Trình kết hợp được chuyển qua đối tượng XCTIssue với các chi tiết lỗi, vì vậy bạn có toàn quyền truy cập vào thông tin đó để xác định xem có khớp hay không.

00:08:50.000 --> 00:08:55.000
Nếu người đối sánh từ chối thất bại, thì nó sẽ không được xử lý như một thất bại dự kiến.

00:08:55.000 --> 00:09:01.000
Điều này có thể hữu ích trong việc phát hiện khi các vấn đề mới xuất hiện trong mã đang được kiểm tra.

00:09:01.000 --> 00:09:07.000
Đối tượng tùy chọn cũng có một thuộc tính có thể được sử dụng để vô hiệu hóa lỗi dự kiến trong các cấu hình nhất định.

00:09:07.000 --> 00:09:15.000
Ví dụ, bài kiểm tra của tôi có thể vượt qua macOS nhưng thất bại trên iOS, vì vậy tôi chỉ muốn mong đợi thất bại trên iOS.

00:09:15.000 --> 00:09:23.000
Để đạt được điều đó, tôi vô hiệu hóa lỗi dự kiến thông qua các tùy chọn, nhưng chỉ dành cho các nền tảng mà tôi không cần nó.

00:09:23.000 --> 00:09:27.000
Vậy điều gì sẽ xảy ra khi những thất bại dự kiến của bạn ngừng thất bại?

00:09:27.000 --> 00:09:31.000
Thông thường điều này có nghĩa là vấn đề cơ bản đã được giải quyết, điều này thật tuyệt.

00:09:31.000 --> 00:09:34.000
Nhưng XCTExpectFailure hoạt động như thế nào?

00:09:34.000 --> 00:09:41.000
Nếu bạn vẫn đang gọi API và không có lỗi nào xảy ra, nó sẽ tạo ra một lỗi mới và khác biệt.

00:09:41.000 --> 00:09:50.000
Chúng tôi gọi đây là "thất bại dự kiến chưa từng có" và đó là một phần của hành vi nghiêm ngặt là mặc định cho XCTExpectFailure.

00:09:50.000 --> 00:09:57.000
Hành vi này giúp bạn duy trì mã của mình bằng cách nhắc bạn xóa các cuộc gọi không cần thiết đến API.

00:09:57.000 --> 00:10:02.000
Nhưng còn những bài kiểm tra chỉ thất bại một thời gian thì sao?

00:10:02.000 --> 00:10:06.000
Có những trường hợp trong đó một bài kiểm tra đôi khi có thể thất bại nhưng không phải những lần khác.

00:10:06.000 --> 00:10:19.000
Chúng được chia thành hai loại, loại đầu tiên là xác định và bao gồm các điều kiện môi trường hoặc các điều kiện có thể biết khác như ví dụ trước đó về thử nghiệm chỉ thất bại trên một số nền tảng nhất định.

00:10:19.000 --> 00:10:23.000
Mặt khác, một số thất bại vốn đã không xác định.

00:10:23.000 --> 00:10:29.000
Những điều này có thể được gây ra bởi các vấn đề về thời gian, sự phụ thuộc đặt hàng không đáng tin cậy hoặc lỗi đồng thời.

00:10:29.000 --> 00:10:36.000
Đối với những thất bại không xác định, hành vi nghiêm ngặt không hữu ích; nó chỉ tạo ra tiếng ồn.

00:10:36.000 --> 00:10:40.000
Một lần nữa, đối tượng tùy chọn cung cấp một cách để kiểm soát điều này.

00:10:40.000 --> 00:10:45.000
Cờ isStrict, mặc định là true, có thể được tắt.

00:10:45.000 --> 00:10:51.000
Sau đó, nếu XCTExpectFailure không thất bại, nó vẫn sẽ cho phép bài kiểm tra vượt qua.

00:10:51.000 --> 00:10:58.000
Trong Swift, bạn cũng có thể chỉ định hành vi nghiêm ngặt như một tham số trực tiếp đến XCTExpectFailure.

00:10:58.000 --> 00:11:04.000
Vô hiệu hóa hành vi nghiêm ngặt là cách tuyệt vời để xử lý các bài kiểm tra không xác định hoặc không xác định trong dự án của bạn.

00:11:04.000 --> 00:11:15.000
Ngoài ra, khi bạn cần điều tra một lỗi không xác định, Xcode giúp bạn dễ dàng chạy thử nghiệm nhiều lần, dừng lại khi nó không thành công hoặc một số điều kiện khác được đáp ứng.

00:11:15.000 --> 00:11:19.000
Điều này có thể thực sự hữu ích trong việc theo dõi các lỗi trong các bài kiểm tra không ổn định.

00:11:19.000 --> 00:11:25.000
Để biết thêm về điều này, hãy xem phiên "Chẩn đoán mã không đáng tin cậy với các lần lặp lại kiểm tra."

00:11:25.000 --> 00:11:33.000
Vì vậy, đó là XCTExpectFailure - API trong XCTest để cải thiện tín hiệu thành nhiễu trong kết quả bộ thử nghiệm của bạn.

00:11:33.000 --> 00:11:38.000
Điều này giúp bạn xác định các vấn đề mới hiệu quả hơn, dẫn đến mã chất lượng cao hơn.

00:11:38.000 --> 00:11:40.000
Cảm ơn vì đã xem!

00:11:40.000 --> 23:59:59.000
♪

