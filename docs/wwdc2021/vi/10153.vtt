WEBVTT

00:00:00.000 --> 00:00:05.000
♪ Nhạc bass đang phát ♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:11.000
Eugene Zhidkov: Xin chào và chào mừng đến với WWDC.

00:00:11.000 --> 00:00:14.000
Tên tôi là Eugene Zhidkov. Tôi đến từ phần mềm GPU.

00:00:14.000 --> 00:00:24.000
Và cùng với, với Harsh Patil từ kiến trúc hệ thống Mac, chúng tôi sẽ chỉ cho bạn cách tạo các ứng dụng xử lý hình ảnh được cung cấp bởi Metal trên Apple silicon.

00:00:24.000 --> 00:00:35.000
Đầu tiên, tôi sẽ tập trung vào các phương pháp hay nhất và bài học kinh nghiệm, tối ưu hóa các ứng dụng xử lý hình ảnh cho M1 dựa trên các cam kết của nhà phát triển mà chúng tôi đã có trong năm qua.

00:00:35.000 --> 00:00:44.000
Và sau đó Harsh sẽ cung cấp cho bạn hướng dẫn từng bước về cách bạn có thể thiết kế lại quy trình xử lý hình ảnh của mình để có hiệu suất tối ưu trên Apple silicon.

00:00:44.000 --> 00:00:46.000
Vậy hãy nhảy ngay vào!

00:00:46.000 --> 00:00:52.000
Để bắt đầu, hãy xem lại ngắn gọn kiến trúc hệ thống trên chip của Apple và những lợi ích của nó.

00:00:52.000 --> 00:00:57.000
Nhiều ứng dụng xử lý hình ảnh và chỉnh sửa video được thiết kế với GPU rời rạc.

00:00:57.000 --> 00:01:02.000
Vì vậy, điều quan trọng là phải làm nổi bật những gì khác biệt về GPU của Apple.

00:01:02.000 --> 00:01:06.000
Đầu tiên, tất cả các chip của Apple đều sử dụng Kiến trúc Bộ nhớ Hợp nhất.

00:01:06.000 --> 00:01:15.000
Tất cả các khối - chẳng hạn như công cụ CPU, GPU, Neural và Media - đều có quyền truy cập vào cùng một bộ nhớ hệ thống bằng giao diện bộ nhớ thống nhất.

00:01:15.000 --> 00:01:21.000
Và thứ hai, GPU của chúng tôi là Trình kết xuất hoãn lại dựa trên ô, hoặc TBDR.

00:01:21.000 --> 00:01:35.000
TBDR có hai giai đoạn chính: ốp lát, trong đó toàn bộ bề mặt kết xuất tách thành gạch và hình học được xử lý sau đó được xử lý độc lập; và kết xuất, nơi tất cả các điểm ảnh sẽ được xử lý cho mỗi ô.

00:01:35.000 --> 00:01:51.000
Vì vậy, để hiệu quả nhất trên Apple silicon, ứng dụng xử lý hình ảnh của bạn nên bắt đầu tận dụng bộ nhớ thống nhất - để tránh bất kỳ bản sao nào mà đường ống của bạn từng có - và kiến trúc TBDR bằng cách khai thác bộ nhớ lát gạch và khối hình ảnh cục bộ.

00:01:51.000 --> 00:02:00.000
Để tìm hiểu thêm về cách Apple TBDR hoạt động ở mức thấp và cách nhắm mục tiêu lõi đổ bóng của chúng tôi, vui lòng xem các phiên này từ năm ngoái.

00:02:00.000 --> 00:02:08.000
Và bây giờ, hãy nói về những điều chính xác mà chúng ta sẽ làm để tối ưu hóa khối lượng công việc tính toán xử lý hình ảnh cho Apple silicon.

00:02:08.000 --> 00:02:14.000
Năm ngoái, chúng tôi đã hợp tác chặt chẽ với nhiều nhà phát triển tuyệt vời trong quá trình chuyển đổi đường ống hình ảnh của họ.

00:02:14.000 --> 00:02:17.000
Chúng tôi đã chọn sáu mẹo bổ ích nhất để chia sẻ.

00:02:17.000 --> 00:02:22.000
Đầu tiên, chúng ta sẽ thảo luận về cách tránh các bản sao hoặc âm vật bộ nhớ không cần thiết.

00:02:22.000 --> 00:02:27.000
Điều này thực sự quan trọng vì chúng tôi hiện đang làm việc với hình ảnh lên đến 8K.

00:02:27.000 --> 00:02:38.000
Sau đó, chúng tôi muốn làm nổi bật những lợi ích của việc sử dụng đường ống kết xuất và kết cấu thay vì sử dụng tính toán trên bộ đệm và cách bạn có thể làm điều đó trong quy trình xử lý hình ảnh của riêng mình.

00:02:38.000 --> 00:02:46.000
Khi chúng tôi đã thiết lập và chạy các đường dẫn kết xuất và kết cấu, chúng tôi muốn cho bạn thấy tầm quan trọng của các hành động tải/lưu trữ thích hợp và các tệp đính kèm không cần nhớ.

00:02:46.000 --> 00:02:50.000
Điều này sẽ giúp bạn tận dụng tối đa bộ nhớ gạch.

00:02:50.000 --> 00:03:03.000
Sau đó, chúng ta sẽ nói về cách tiếp cận tốt nhất các máy hủy Uber với luồng điều khiển động của nó và cũng như cách tận dụng các loại dữ liệu nhỏ hơn - chẳng hạn như ngắn và một nửa - để cải thiện hiệu suất và hiệu quả.

00:03:03.000 --> 00:03:08.000
Và chúng tôi sẽ kết thúc với lời khuyên quan trọng về định dạng kết cấu để có được thông lượng tốt nhất.

00:03:08.000 --> 00:03:09.000
Được rồi.

00:03:09.000 --> 00:03:15.000
Vì vậy, hãy bắt đầu với một trong những mẹo bổ ích nhất: tránh các vết bẩn không cần thiết trên Apple silicon.

00:03:15.000 --> 00:03:20.000
Hầu hết các ứng dụng xử lý hình ảnh được thiết kế xung quanh các GPU rời rạc.

00:03:20.000 --> 00:03:25.000
Với GPU rời, bạn có bộ nhớ hệ thống và bộ nhớ video riêng biệt.

00:03:25.000 --> 00:03:31.000
Để làm cho hình ảnh khung hiển thị hoặc cư trú trên GPU, cần phải có bản sao rõ ràng.

00:03:31.000 --> 00:03:37.000
Hơn nữa, nó thường được yêu cầu hai lần; để tải lên dữ liệu cho GPU để xử lý nó và để kéo nó trở lại.

00:03:37.000 --> 00:03:43.000
Hãy xem xét chúng ta đang giải mã một video 8K, xử lý nó và lưu nó vào đĩa.

00:03:43.000 --> 00:03:48.000
Vì vậy, đây là một chuỗi CPU, giải mã, trong trường hợp này.

00:03:48.000 --> 00:03:53.000
Đó là nơi chúng ta cần sao chép khung được giải mã sang GPU VRAM.

00:03:53.000 --> 00:03:58.000
Và đây là dòng thời gian GPU, nơi tất cả các hiệu ứng và bộ lọc được áp dụng.

00:03:58.000 --> 00:04:03.000
Hãy tiến thêm một bước nữa và hãy nhớ lại rằng chúng ta cần lưu kết quả vào đĩa, phải không?

00:04:03.000 --> 00:04:12.000
Vì vậy, chúng ta cũng phải xem xét đưa khung đã xử lý trở lại bộ nhớ hệ thống và mã hóa thực tế của khung.

00:04:12.000 --> 00:04:21.000
Vì vậy, chúng được gọi là "sao chép" hoặc "khoảng trống bóng bay", và các ứng dụng xử lý hình ảnh tiên tiến phải thực hiện đường ống sâu và những thứ thông minh khác để lấp đầy chúng.

00:04:21.000 --> 00:04:28.000
Chà, tin tốt là trên Apple GPUs, việc làm việc vì mục đích cư trú không còn cần thiết nữa.

00:04:28.000 --> 00:04:33.000
Vì bộ nhớ được chia sẻ, cả CPU và GPU đều có thể truy cập trực tiếp vào nó.

00:04:33.000 --> 00:04:40.000
Vì vậy, vui lòng thêm một kiểm tra đơn giản để phát hiện xem bạn có đang chạy trên hệ thống bộ nhớ thống nhất hay không và tránh các bản sao không cần thiết.

00:04:40.000 --> 00:04:45.000
Nó sẽ giúp bạn tiết kiệm trí nhớ, thời gian và là bước đầu tiên tuyệt đối cần làm.

00:04:45.000 --> 00:04:51.000
Vì vậy, đây là nơi chúng tôi hạ cánh trên Kiến trúc Bộ nhớ Thống nhất với các âm vật bị loại bỏ.

00:04:51.000 --> 00:04:58.000
Bằng cách loại bỏ các khe hở, chúng tôi hoàn toàn tránh được các khoảng trống sao chép và có thể bắt đầu xử lý ngay lập tức.

00:04:58.000 --> 00:05:03.000
Điều này cũng mang lại đường ống CPU và GPU tốt hơn với ít rắc rối hơn.

00:05:03.000 --> 00:05:07.000
Hãy đảm bảo rằng bạn triển khai đường dẫn bộ nhớ thống nhất mà không có bản sao nào liên quan.

00:05:07.000 --> 00:05:18.000
Nếu bạn chỉ để lại các bản sao âm vật chính xác như trên GPU rời, bạn sẽ thanh toán bằng băng thông bộ nhớ hệ thống, thời gian GPU ít hơn để xử lý thực tế và chi phí lập lịch tiềm năng.

00:05:18.000 --> 00:05:24.000
Chưa kể chúng tôi không còn cần phân bổ hình ảnh VRAM riêng biệt nữa.

00:05:24.000 --> 00:05:28.000
Chụp khung GPU có thể giúp bạn phát hiện ra các âm vật lớn.

00:05:28.000 --> 00:05:34.000
Vui lòng kiểm tra các bản sao ứng dụng của bạn và đảm bảo rằng bạn chỉ thực hiện các bản sao được yêu cầu.

00:05:34.000 --> 00:05:40.000
Bây giờ, hãy nói về cách chính xác chúng ta nên bắt đầu tận dụng kiến trúc Apple GPU TBDR để xử lý hình ảnh.

00:05:40.000 --> 00:05:47.000
Hầu hết các ứng dụng xử lý hình ảnh hoạt động trên bộ đệm hình ảnh bằng cách gửi hàng loạt hạt nhân tính toán.

00:05:47.000 --> 00:05:55.000
Khi bạn gửi một hạt nhân tính toán ở chế độ nối tiếp mặc định, Metal đảm bảo rằng tất cả các công văn tiếp theo sẽ thấy tất cả các ghi bộ nhớ.

00:05:55.000 --> 00:06:06.000
Sự đảm bảo này ngụ ý sự kết hợp bộ nhớ cho tất cả các lõi đổ bóng, vì vậy mọi ghi bộ nhớ đều được hiển thị cho tất cả các lõi khác vào thời điểm công văn tiếp theo bắt đầu.

00:06:06.000 --> 00:06:12.000
Điều này cũng có nghĩa là lưu lượng bộ nhớ có thể thực sự cao; toàn bộ hình ảnh phải được đọc và ghi vào.

00:06:12.000 --> 00:06:17.000
Với M1, Apple GPUs cho phép công văn gạch trên MacOS.

00:06:17.000 --> 00:06:23.000
Trái ngược với tính toán thông thường, chúng hoạt động trong bộ nhớ ô với các điểm đồng bộ hóa chỉ có ô.

00:06:23.000 --> 00:06:29.000
Một số bộ lọc - như tích chập - không thể được ánh xạ đến mô hình ô, nhưng nhiều bộ lọc khác thì có!

00:06:29.000 --> 00:06:35.000
Trì hoãn bộ nhớ hệ thống tuôn ra cho đến khi điểm cuối bộ mã hóa mang lại hiệu quả vững chắc.

00:06:35.000 --> 00:06:41.000
Bạn có thể thực hiện công việc GPU hữu ích hơn khi không bị giới hạn bởi băng thông bộ nhớ hệ thống.

00:06:41.000 --> 00:06:52.000
Để tiến xa hơn nữa, hãy lưu ý rằng nhiều thao tác trên mỗi pixel không yêu cầu quyền truy cập vào các pixel lân cận, vì vậy điểm đồng bộ hóa ô là không cần thiết.

00:06:52.000 --> 00:06:55.000
Điều này lập bản đồ thực sự tốt để phân mảnh các chức năng.

00:06:55.000 --> 00:07:05.000
Các hàm phân đoạn có thể được thực thi mà không cần đồng bộ hóa ô ngầm, chỉ yêu cầu đồng bộ hóa tại ranh giới bộ mã hóa hoặc khi hạt nhân ô được gửi nối tiếp sau hạt nhân phân đoạn.

00:07:05.000 --> 00:07:11.000
Bây giờ chúng ta đã biết rằng GPU của Apple cho phép các chức năng phân đoạn và hạt nhân lát gạch để xử lý hình ảnh hiệu quả hơn.

00:07:11.000 --> 00:07:14.000
Hãy xem làm thế nào chúng ta có thể sử dụng nó.

00:07:14.000 --> 00:07:21.000
Chúng tôi làm điều đó bằng cách chuyển đổi các công văn tính toán thông thường trên bộ đệm để hiển thị bộ mã hóa lệnh trên kết cấu.

00:07:21.000 --> 00:07:25.000
Như chúng ta vừa thảo luận, quy tắc ngón tay cái như sau.

00:07:25.000 --> 00:07:31.000
Các hoạt động trên mỗi pixel không phụ thuộc vào điểm ảnh nên được thực hiện bằng cách sử dụng các chức năng phân đoạn.

00:07:31.000 --> 00:07:39.000
Bất kỳ bộ lọc nào có hoạt động phạm vi nhóm luồng nên được thực hiện với đổ bóng ô, vì cần phải truy cập các pixel lân cận trong ô.

00:07:39.000 --> 00:07:49.000
Các bộ lọc thu thập phân tán và tích chập không thể được ánh xạ đến mô hình gạch vì chúng yêu cầu truy cập ngẫu nhiên, vì vậy chúng vẫn nên vẫn là công văn tính toán.

00:07:49.000 --> 00:07:56.000
Bộ mã hóa lệnh kết xuất cũng cho phép tính năng GPU độc đáo của Apple: nén băng thông không mất dữ liệu cho kết cấu và mục tiêu kết xuất.

00:07:56.000 --> 00:08:04.000
Đây là một trình tiết kiệm băng thông thực sự tuyệt vời, đặc biệt là đối với quy trình xử lý hình ảnh, vì vậy hãy xem chúng ta nên sử dụng nó như thế nào.

00:08:04.000 --> 00:08:10.000
Chà, nói về việc cho phép nén không mất dữ liệu, việc nói những gì bạn không nên làm thực sự dễ dàng hơn.

00:08:10.000 --> 00:08:15.000
Đầu tiên, các định dạng kết cấu đã được nén không thể hưởng lợi từ việc không mất dữ liệu.

00:08:15.000 --> 00:08:24.000
Thứ hai, có ba cờ kết cấu cụ thể không thể hoạt động với tính năng nén này, vì vậy hãy đảm bảo rằng bạn không đặt chúng một cách tình cờ.

00:08:24.000 --> 00:08:31.000
Và thứ ba, kết cấu tuyến tính - hoặc được hỗ trợ bởi MTLBuffer - cũng không được phép.

00:08:31.000 --> 00:08:41.000
Một số xử lý đặc biệt cũng được yêu cầu cho các kết cấu không riêng tư; đảm bảo gọi optimizeContentsForGPUAccess để luôn đi trên con đường nhanh nhất.

00:08:41.000 --> 00:08:49.000
Khung Tóm tắt chụp khung GPU hiện hiển thị cho bạn các cảnh báo nén không mất dữ liệu và làm nổi bật lý do tại sao kết cấu đã chọn không tham gia.

00:08:49.000 --> 00:08:54.000
Trong ví dụ này, cờ PixelFormatView đã được đặt.

00:08:54.000 --> 00:08:58.000
Trong nhiều trường hợp, các nhà phát triển đang vô tình đặt những lá cờ này.

00:08:58.000 --> 00:09:05.000
Đừng đặt PixelFormatView nếu tất cả những gì bạn cần là swizzle thành phần hoặc chuyển đổi sRGB.

00:09:05.000 --> 00:09:08.000
Được rồi, chúng tôi đã thiết lập và chạy đường dẫn kết xuất và kết cấu.

00:09:08.000 --> 00:09:11.000
Bây giờ, hãy đảm bảo rằng chúng ta sử dụng bộ nhớ gạch đúng cách.

00:09:11.000 --> 00:09:19.000
Các khái niệm TBDR bộ nhớ gạch - chẳng hạn như hành động tải/lưu trữ và tệp đính kèm không bộ nhớ - hoàn toàn mới đối với thế giới máy tính để bàn.

00:09:19.000 --> 00:09:22.000
Vì vậy, hãy đảm bảo rằng chúng ta sử dụng chúng đúng cách.

00:09:22.000 --> 00:09:25.000
Hãy bắt đầu với các hành động tải/lưu trữ!

00:09:25.000 --> 00:09:29.000
Như chúng ta đã biết, toàn bộ mục tiêu kết xuất được chia thành các ô.

00:09:29.000 --> 00:09:36.000
Tải/lưu trữ là các hành động hàng loạt trên mỗi gạch được đảm bảo để thực hiện con đường tối ưu nhất thông qua hệ thống phân cấp bộ nhớ.

00:09:36.000 --> 00:09:48.000
Chúng được thực thi ở đầu đường chuyền kết xuất - nơi chúng tôi cho GPU biết cách khởi tạo bộ nhớ gạch - và ở cuối đường chuyền để thông báo cho GPU những tệp đính kèm nào cần được ghi lại.

00:09:48.000 --> 00:09:52.000
Điều quan trọng ở đây là tránh tải những gì chúng ta không cần.

00:09:52.000 --> 00:09:59.000
Nếu chúng ta đang ghi đè lên toàn bộ hình ảnh hoặc tài nguyên là tạm thời, hãy đặt hành động tải thành LoadActionDontCare.

00:09:59.000 --> 00:10:09.000
Với bộ mã hóa kết xuất, bạn không còn cần phải xóa đầu ra hoặc dữ liệu tạm thời của mình nữa, như bạn có thể đã làm trước đây với thẻ tính toán chuyên dụng hoặc cuộc gọi fillBuffer.

00:10:09.000 --> 00:10:14.000
Bằng cách cài đặt LoadActionClear, bạn có thể chỉ định giá trị rõ ràng một cách hiệu quả.

00:10:14.000 --> 00:10:16.000
Và hành động của cửa hàng cũng vậy.

00:10:16.000 --> 00:10:23.000
Đảm bảo chỉ lưu trữ dữ liệu bạn cần sau này - như tệp đính kèm chính - và không lưu trữ bất cứ thứ gì tạm thời.

00:10:23.000 --> 00:10:30.000
Bên cạnh các hành động tải và lưu trữ rõ ràng, Apple GPUs lưu dấu chân bộ nhớ của bạn với các tệp đính kèm không bộ nhớ.

00:10:30.000 --> 00:10:35.000
Chúng ta có thể định nghĩa rõ ràng tệp đính kèm là có chế độ lưu trữ không bộ nhớ.

00:10:35.000 --> 00:10:43.000
Điều này cho phép phân bổ bộ nhớ chỉ có ô, có nghĩa là tài nguyên của bạn sẽ tồn tại cho từng ô chỉ trong vòng đời của bộ mã hóa.

00:10:43.000 --> 00:10:51.000
Điều này có thể làm giảm đáng kể dung lượng bộ nhớ của bạn, đặc biệt là đối với hình ảnh 6K/8K, nơi mỗi khung hình chiếm hàng trăm megabyte.

00:10:51.000 --> 00:10:54.000
Hãy xem tất cả điều này có thể được thực hiện như thế nào trong mã.

00:10:54.000 --> 00:11:00.000
Chúng tôi bắt đầu bằng cách tạo textureDescriptor và sau đó tạo outputTexture.

00:11:00.000 --> 00:11:02.000
Sau đó chúng tôi tạo ra một kết cấu tạm thời.

00:11:02.000 --> 00:11:07.000
Lưu ý rằng tôi đã đánh dấu nó là không có bộ nhớ, vì chúng tôi không muốn bất kỳ bộ nhớ nào ở đây.

00:11:07.000 --> 00:11:14.000
Sau đó, chúng tôi tạo đường chuyền kết xuất bằng cách trước tiên mô tả các tệp đính kèm là gì và sau đó là các hành động tải/lưu trữ là gì.

00:11:14.000 --> 00:11:20.000
Chúng tôi không quan tâm đến việc tải đầu ra vì nó bị ghi đè hoàn toàn, nhưng chúng tôi cần lưu trữ nó.

00:11:20.000 --> 00:11:26.000
Đối với kết cấu tạm thời, chúng tôi không tải nhưng xóa nó, và chúng tôi cũng không cần lưu trữ nó.

00:11:26.000 --> 00:11:31.000
Cuối cùng, chúng tôi tạo ra renderPass của mình từ bộ mô tả.

00:11:31.000 --> 00:11:32.000
Thế là xong.

00:11:32.000 --> 00:11:41.000
Vì vậy, chúng tôi đang sử dụng bộ nhớ thống nhất, di chuyển quy trình xử lý hình ảnh của mình để hiển thị bộ mã hóa lệnh và đang tận dụng đúng bộ nhớ ô.

00:11:41.000 --> 00:11:44.000
Bây giờ, hãy nói về uber-shaders.

00:11:44.000 --> 00:11:50.000
Uber-shaders, hay uber-kernels, là một cách khá phổ biến để giúp cuộc sống của các nhà phát triển dễ dàng hơn.

00:11:50.000 --> 00:12:03.000
Mã máy chủ thiết lập cấu trúc điều khiển và bộ đổ bóng chỉ lặp qua một loạt các câu lệnh if/else, ví dụ: nếu ánh xạ âm được bật hoặc nếu đầu vào ở định dạng HDR hoặc SDR.

00:12:03.000 --> 00:12:11.000
Cách tiếp cận này còn được gọi là "ubers-shader" và thực sự tốt trong việc giảm tổng số đối tượng trạng thái đường ống xuống.

00:12:11.000 --> 00:12:14.000
Tuy nhiên, nó có nhược điểm.

00:12:14.000 --> 00:12:19.000
Cái chính là tăng áp lực đăng ký để theo kịp dòng điều khiển phức tạp hơn.

00:12:19.000 --> 00:12:25.000
Sử dụng nhiều thanh ghi hơn có thể dễ dàng hạn chế công suất tối đa mà bộ đổ bóng của bạn đang chạy.

00:12:25.000 --> 00:12:29.000
Hãy xem xét một hạt nhân đơn giản nơi chúng ta vượt qua trong cấu trúc điều khiển.

00:12:29.000 --> 00:12:33.000
Chúng tôi sử dụng cờ bên trong cấu trúc để kiểm soát những gì chúng tôi làm.

00:12:33.000 --> 00:12:38.000
Chúng tôi có hai tính năng ở đây: nếu đầu vào ở chế độ HDR và nếu ánh xạ tông màu được bật.

00:12:38.000 --> 00:12:40.000
Tất cả trông ổn, phải không?

00:12:40.000 --> 00:12:44.000
Chà, đây là những gì xảy ra trên GPU.

00:12:44.000 --> 00:12:54.000
Vì chúng tôi không thể suy ra bất cứ điều gì tại thời điểm biên dịch, chúng tôi phải giả định rằng chúng tôi có thể đi cả hai con đường - HDR và không phải HDR - và sau đó kết hợp dựa trên cờ.

00:12:54.000 --> 00:12:56.000
Ánh xạ âm thanh cũng vậy.

00:12:56.000 --> 00:13:02.000
Chúng tôi đánh giá nó và sau đó che nó vào hoặc ra, dựa trên cờ đầu vào.

00:13:02.000 --> 00:13:04.000
Vấn đề ở đây là đăng ký.

00:13:04.000 --> 00:13:07.000
Mọi đường dẫn luồng điều khiển đều cần đăng ký trực tiếp.

00:13:07.000 --> 00:13:10.000
Đây là nơi mà uber-shaders không tốt lắm.

00:13:10.000 --> 00:13:17.000
Như bạn nhớ lại, các thanh ghi được sử dụng bởi hạt nhân xác định công suất tối đa mà bộ đổ bóng có thể chạy.

00:13:17.000 --> 00:13:22.000
Điều đó xảy ra bởi vì tệp đăng ký được chia sẻ bởi tất cả các simdlanes trên lõi đổ bóng.

00:13:22.000 --> 00:13:30.000
Nếu chúng ta chỉ có thể chạy những gì chỉ cần thiết, điều đó sẽ cho phép sử dụng đồng thời và GPU simdgroup cao hơn.

00:13:30.000 --> 00:13:32.000
Hãy nói về cách khắc phục điều này.

00:13:32.000 --> 00:13:37.000
Metal API có công cụ phù hợp cho công việc và nó được gọi là "function_constants".

00:13:37.000 --> 00:13:43.000
Chúng tôi xác định cả hai tham số điều khiển là function_constants và chúng tôi sửa đổi mã cho phù hợp.

00:13:43.000 --> 00:13:46.000
Ở đây, chúng tôi đang hiển thị mã hạt nhân đã sửa đổi.

00:13:46.000 --> 00:13:52.000
Phía máy chủ cũng phải được cập nhật để cung cấp giá trị function_constant tại thời điểm tạo đường ống.

00:13:52.000 --> 00:13:59.000
Một cách tuyệt vời khác để giảm áp suất đăng ký là sử dụng các loại 16-bit trong bộ đổ bóng của bạn.

00:13:59.000 --> 00:14:03.000
GPU của Apple có hỗ trợ loại 16-bit gốc.

00:14:03.000 --> 00:14:10.000
Vì vậy, khi sử dụng các kiểu dữ liệu nhỏ hơn, bộ đổ bóng của bạn sẽ yêu cầu ít thanh ghi hơn, tăng công suất.

00:14:10.000 --> 00:14:16.000
Các loại một nửa và ngắn cũng đòi hỏi ít năng lượng hơn và có thể đạt được tỷ lệ cao nhất.

00:14:16.000 --> 00:14:24.000
Vì vậy, vui lòng sử dụng các loại một nửa và ngắn thay vì float và int khi có thể, vì chuyển đổi kiểu thường miễn phí.

00:14:24.000 --> 00:14:32.000
Trong ví dụ này, hãy xem xét một hạt nhân sử dụng thread_position trong threadgroup cho một số tính toán.

00:14:32.000 --> 00:14:40.000
Chúng tôi đang sử dụng int không dấu, nhưng kích thước nhóm luồng tối đa được Metal hỗ trợ có thể dễ dàng phù hợp với short không dấu.

00:14:40.000 --> 00:14:46.000
Threadgroup_position_in_grid, tuy nhiên, có khả năng yêu cầu một kiểu dữ liệu lớn hơn.

00:14:46.000 --> 00:14:54.000
Nhưng đối với kích thước lưới mà chúng tôi đang sử dụng trong xử lý hình ảnh - lên đến 8K hoặc 16K - short không dấu cũng đủ.

00:14:54.000 --> 00:15:02.000
Nếu chúng ta sử dụng các loại 16-bit thay thế, mã kết quả sẽ sử dụng số lượng thanh ghi nhỏ hơn, có khả năng làm tăng công suất sử dụng.

00:15:02.000 --> 00:15:07.000
Bây giờ, hãy để tôi chỉ cho bạn nơi bạn có thể có tất cả các chi tiết trên sổ đăng ký.

00:15:07.000 --> 00:15:15.000
Trình gỡ lỗi khung GPU trong Xcode13 hiện có chế độ xem đối tượng trạng thái đường ống nâng cao để hiển thị, gạch và tính toán PSO.

00:15:15.000 --> 00:15:22.000
Bạn có thể kiểm tra số liệu thống kê đường ống chi tiết - ngay bây giờ với việc sử dụng thanh ghi - và tinh chỉnh tất cả các bộ đổ bóng của bạn.

00:15:22.000 --> 00:15:28.000
Với các mối quan tâm về đăng ký được đề cập, hãy nói về các định dạng kết cấu.

00:15:28.000 --> 00:15:33.000
Đầu tiên, chúng tôi muốn lưu ý rằng các định dạng pixel khác nhau có thể có tốc độ lấy mẫu khác nhau.

00:15:33.000 --> 00:15:40.000
Tùy thuộc vào việc tạo phần cứng và số lượng kênh, các loại dấu phẩy động rộng hơn có thể đã giảm tốc độ lấy mẫu điểm.

00:15:40.000 --> 00:15:49.000
Đặc biệt là các định dạng dấu phẩy động như RGBA32F sẽ chậm hơn các biến thể FP16 khi lấy mẫu các giá trị được lọc.

00:15:49.000 --> 00:15:53.000
Các loại nhỏ hơn cũng làm giảm dung lượng lưu trữ bộ nhớ, băng thông và dấu chân bộ nhớ cache.

00:15:53.000 --> 00:15:59.000
Vì vậy, một lần nữa, chúng tôi khuyến khích sử dụng loại nhỏ nhất có thể, nhưng trong trường hợp này, để lưu trữ kết cấu.

00:15:59.000 --> 00:16:12.000
Đây thực sự là một trường hợp phổ biến đối với LUT 3D trong xử lý hình ảnh; hầu hết các ứng dụng mà chúng tôi đã làm việc đều sử dụng RGBA nổi cho giai đoạn ứng dụng 3D LUT với tính năng lọc song tuyến được bật.

00:16:12.000 --> 00:16:17.000
Vui lòng xem xét liệu ứng dụng của bạn có thể sử dụng một nửa hay không và độ chính xác là đủ.

00:16:17.000 --> 00:16:22.000
Nếu đúng như vậy, hãy chuyển sang FP16 ngay lập tức để có được tỷ lệ lấy mẫu cao nhất.

00:16:22.000 --> 00:16:39.000
Nếu độ chính xác một nửa là không đủ, chúng tôi phát hiện ra rằng short không dấu điểm cố định cung cấp phạm vi giá trị đồng nhất tuyệt vời, vì vậy mã hóa LUT của bạn ở quy mô đơn vị và cung cấp phạm vi LUT cho bộ đổ bóng là một cách tuyệt vời để có được cả tốc độ lấy mẫu đỉnh và độ chính xác số đủ.

00:16:39.000 --> 00:16:48.000
Được rồi, vì vậy chúng tôi vừa xem xét cách chúng tôi nên tận dụng kiến trúc GPU của Apple để làm cho đường ống xử lý hình ảnh của bạn chạy hiệu quả nhất có thể.

00:16:48.000 --> 00:16:50.000
Để áp dụng tất cả ngay lập tức, hãy gặp Harsh!

00:16:50.000 --> 00:16:52.000
Harsh Patil: Cảm ơn, Eugene.

00:16:52.000 --> 00:16:59.000
Bây giờ chúng ta hãy đi qua việc thiết kế lại một đường ống xử lý hình ảnh cho Apple silicon dựa trên tất cả các phương pháp hay nhất mà chúng ta đã học được cho đến nay.

00:16:59.000 --> 00:17:05.000
Cụ thể, chúng tôi sẽ điều chỉnh giai đoạn xử lý hình ảnh của đường ống xử lý video cho GPU của Apple.

00:17:05.000 --> 00:17:10.000
Xử lý hình ảnh thời gian thực rất tốn nhiều tính toán GPU và băng thông bộ nhớ.

00:17:10.000 --> 00:17:16.000
Đầu tiên chúng ta sẽ hiểu nó thường được thiết kế như thế nào và sau đó là cách chúng ta có thể tối ưu hóa nó cho silicon của Apple.

00:17:16.000 --> 00:17:22.000
Chúng tôi sẽ không đi sâu vào chi tiết về quy trình chỉnh sửa video trong phần này, vì vậy vui lòng tham khảo bài nói chuyện của chúng tôi từ hai năm trước.

00:17:22.000 --> 00:17:27.000
Chúng tôi sẽ chỉ tập trung vào việc chuyển đổi phần tính toán của quá trình xử lý hình ảnh sang đường dẫn kết xuất.

00:17:27.000 --> 00:17:33.000
Trước khi chúng ta bắt đầu, hãy bắt đầu nhanh chóng, hãy xem giai đoạn xử lý hình ảnh đứng ở đâu trong một quy trình xử lý video điển hình.

00:17:33.000 --> 00:17:37.000
Chúng tôi sẽ lấy tệp đầu vào được mã hóa ProRes làm ví dụ.

00:17:37.000 --> 00:17:41.000
Đầu tiên chúng ta đọc khung được mã hóa ProRes từ đĩa hoặc bộ nhớ ngoài.

00:17:41.000 --> 00:17:50.000
Sau đó, chúng tôi giải mã khung trên CPU và bây giờ giai đoạn xử lý hình ảnh thực hiện trên khung được giải mã này trên GPU và hiển thị khung đầu ra cuối cùng.

00:17:50.000 --> 00:17:53.000
Cuối cùng, chúng tôi hiển thị khung đầu ra này.

00:17:53.000 --> 00:17:57.000
Chúng tôi cũng có thể mã hóa khung được hiển thị cuối cùng để giao hàng.

00:17:57.000 --> 00:18:02.000
Tiếp theo, chúng ta hãy xem xét những gì bao gồm một quy trình xử lý hình ảnh.

00:18:02.000 --> 00:18:09.000
Quá trình xử lý hình ảnh bắt đầu bằng việc giải nén các kênh khác nhau của hình ảnh nguồn RGB trong alpha thành các bộ đệm riêng biệt ngay từ đầu.

00:18:09.000 --> 00:18:15.000
Chúng tôi sẽ xử lý từng kênh này trong quy trình xử lý hình ảnh của mình, cùng nhau hoặc riêng biệt.

00:18:15.000 --> 00:18:21.000
Tiếp theo, có thể có các chuyển đổi không gian màu để hoạt động trong môi trường được quản lý màu mong muốn.

00:18:21.000 --> 00:18:31.000
Sau đó, chúng tôi áp dụng LUT 3D; thực hiện hiệu chỉnh màu sắc; và sau đó áp dụng giảm nhiễu không gian-thời gian, tích chập, làm mờ và các hiệu ứng khác.

00:18:31.000 --> 00:18:36.000
Và cuối cùng, chúng tôi đóng gói các kênh được xử lý riêng lẻ lại với nhau để có đầu ra cuối cùng.

00:18:36.000 --> 00:18:39.000
Những bước được chọn này có điểm gì chung?

00:18:39.000 --> 00:18:43.000
Chúng đều là các bộ lọc điểm, chỉ hoạt động trên một điểm ảnh duy nhất mà không phụ thuộc vào điểm ảnh giữa các điểm ảnh.

00:18:43.000 --> 00:18:47.000
Những bản đồ này tốt để phân mảnh việc triển khai đổ bóng.

00:18:47.000 --> 00:18:54.000
Các hoạt động kiểu không gian và tích chập yêu cầu quyền truy cập vào bán kính lớn của các điểm ảnh và chúng tôi cũng có các mẫu truy cập đọc-ghi rải rác.

00:18:54.000 --> 00:18:57.000
Những thứ này rất phù hợp cho các hạt nhân tính toán.

00:18:57.000 --> 00:18:58.000
Chúng ta sẽ sử dụng kiến thức này sau.

00:18:58.000 --> 00:19:02.000
Hiện tại, hãy xem các thao tác này được thực hiện như thế nào.

00:19:02.000 --> 00:19:06.000
Các ứng dụng đại diện cho chuỗi hiệu ứng được áp dụng cho một hình ảnh dưới dạng biểu đồ bộ lọc.

00:19:06.000 --> 00:19:12.000
Mỗi bộ lọc là hạt nhân riêng của nó, xử lý các đầu vào từ giai đoạn trước và tạo ra đầu ra cho giai đoạn tiếp theo.

00:19:12.000 --> 00:19:20.000
Mỗi mũi tên ở đây có nghĩa là một bộ đệm được ghi vào/từ đầu ra của một giai đoạn và được đọc làm đầu vào trong giai đoạn tiếp theo.

00:19:20.000 --> 00:19:26.000
Vì bộ nhớ bị hạn chế, các ứng dụng thường tuyến tính hóa biểu đồ bằng cách sắp xếp tôpô.

00:19:26.000 --> 00:19:33.000
Điều này được thực hiện để giữ tổng số tài nguyên trung gian ở mức thấp nhất có thể đồng thời tránh các điều kiện chủng tộc.

00:19:33.000 --> 00:19:41.000
Biểu đồ bộ lọc đơn giản này trong ví dụ đó sẽ cần hai bộ đệm trung gian để có thể hoạt động mà không cần điều kiện đua và tạo ra đầu ra cuối cùng.

00:19:41.000 --> 00:19:46.000
Biểu đồ tuyến tính hóa ở đây đại khái cũng đại diện cho mã hóa bộ đệm lệnh GPU.

00:19:46.000 --> 00:19:52.000
Hãy xem xét kỹ hơn lý do tại sao biểu đồ bộ lọc này lại sử dụng nhiều băng thông bộ nhớ thiết bị.

00:19:52.000 --> 00:20:01.000
Mọi thao tác của bộ lọc phải tải toàn bộ hình ảnh từ bộ nhớ thiết bị vào thanh ghi và ghi kết quả trở lại bộ nhớ thiết bị.

00:20:01.000 --> 00:20:03.000
Và đó là khá nhiều lưu lượng bộ nhớ.

00:20:03.000 --> 00:20:11.000
Hãy ước tính dấu chân bộ nhớ cho việc xử lý hình ảnh khung hình 4K dựa trên biểu đồ xử lý hình ảnh ví dụ của chúng tôi.

00:20:11.000 --> 00:20:25.000
Bản thân khung được giải mã 4K mất 67 megabyte bộ nhớ cho độ chính xác dấu phẩy động 16 hoặc 135 megabyte bộ nhớ cho độ chính xác dấu phẩy động 32 và quy trình làm việc chuyên nghiệp hoàn toàn cần độ chính xác dấu phẩy động 32.

00:20:25.000 --> 00:20:36.000
Để xử lý một khung 4K với độ chính xác dấu phẩy động 32 thông qua biểu đồ xử lý hình ảnh này, chúng ta đang nói về hơn hai gigabyte lưu lượng đọc-ghi vào bộ nhớ thiết bị.

00:20:36.000 --> 00:20:43.000
Ngoài ra, ghi vào bộ đệm giữ đầu ra trung gian sẽ ngăn chặn hệ thống phân cấp bộ nhớ cache và cũng tác động đến các khối khác trên chip.

00:20:43.000 --> 00:20:48.000
Hạt nhân tính toán thông thường không được hưởng lợi từ bộ nhớ gạch trên chip một cách ngầm định.

00:20:48.000 --> 00:20:54.000
Hạt nhân có thể phân bổ rõ ràng bộ nhớ có phạm vi nhóm luồng, bộ nhớ này sẽ được hỗ trợ bởi bộ nhớ ô trên chip.

00:20:54.000 --> 00:21:00.000
Tuy nhiên, bộ nhớ ô đó không liên tục giữa các công văn trong bộ mã hóa tính toán.

00:21:00.000 --> 00:21:06.000
Ngược lại, bộ nhớ ô thực sự liên tục trên các đường rút trong một bộ mã hóa lệnh kết xuất.

00:21:06.000 --> 00:21:12.000
Hãy xem cách chúng ta có thể thiết kế lại quy trình xử lý hình ảnh đại diện này để tận dụng bộ nhớ gạch.

00:21:12.000 --> 00:21:15.000
Chúng tôi sẽ giải quyết vấn đề này bằng cách làm theo ba bước.

00:21:15.000 --> 00:21:21.000
Đầu tiên chúng tôi thay đổi đường chuyền tính toán để hiển thị đường chuyền và tất cả các bộ đệm đầu ra trung gian thành kết cấu.

00:21:21.000 --> 00:21:34.000
Sau đó, chúng tôi mã hóa các hoạt động trên mỗi pixel mà không có sự phụ thuộc giữa các pixel dưới dạng các lệnh gọi đổ bóng phân đoạn trong một bộ mã hóa lệnh kết xuất, đảm bảo tính đến tất cả các kết quả trung gian và thiết lập các hành động tải/lưu trữ thích hợp.

00:21:34.000 --> 00:21:40.000
Và cuối cùng, chúng tôi thảo luận về những gì chúng tôi làm trong tình huống phức tạp hơn là chỉ các bộ lọc điểm.

00:21:40.000 --> 00:21:45.000
Bước đầu tiên của chúng tôi là sử dụng MTLRenderCommandEncoder riêng biệt để mã hóa các bộ đổ bóng đủ điều kiện.

00:21:45.000 --> 00:21:59.000
Trong biểu đồ bộ lọc này, các bộ lọc giải nén, chuyển đổi không gian màu, LUT và hiệu chỉnh màu là tất cả các bộ lọc điểm trên mỗi pixel mà chúng ta có thể chuyển đổi thành bộ đổ bóng phân đoạn và mã hóa chúng bằng cách sử dụng một bộ mã hóa lệnh kết xuất.

00:21:59.000 --> 00:22:11.000
Tương tự, bộ trộn và bộ đổ bóng gói - nằm ở cuối đường ống xử lý hình ảnh này - cũng có thể được chuyển đổi thành bộ đổ bóng phân đoạn và được mã hóa bằng cách sử dụng một MTLRenderCommandEncoder khác.

00:22:11.000 --> 00:22:15.000
Sau đó, chúng ta có thể gọi các bộ đổ bóng này trong các đường dẫn kết xuất tương ứng của chúng.

00:22:15.000 --> 00:22:22.000
Khi bạn tạo đường chuyền kết xuất, tất cả các tài nguyên được đính kèm với các tệp đính kèm màu trong đường chuyền kết xuất đó được gạch ngầm cho bạn.

00:22:22.000 --> 00:22:29.000
Bộ đổ bóng phân đoạn chỉ có thể cập nhật dữ liệu khối hình ảnh được liên kết với vị trí của phân đoạn trong ô.

00:22:29.000 --> 00:22:35.000
Bộ đổ bóng tiếp theo trong cùng một lần kết xuất có thể nhận đầu ra của bộ đổ bóng trước đó trực tiếp từ bộ nhớ ô.

00:22:35.000 --> 00:22:41.000
Trong phần tiếp theo, chúng ta sẽ xem xét cách chúng ta có thể cấu trúc các bộ đổ bóng phân đoạn ánh xạ đến các bộ lọc này.

00:22:41.000 --> 00:22:50.000
Chúng tôi cũng sẽ xem xét những cấu trúc nào chúng tôi cần xác định và sử dụng để cho phép truy cập vào bộ nhớ gạch bên dưới từ bên trong các bộ đổ bóng phân đoạn này.

00:22:50.000 --> 00:23:02.000
Và cuối cùng, chúng ta sẽ xem xét cách đầu ra được tạo ra trong bộ nhớ ô bằng bộ đổ bóng một đoạn có thể được tiêu thụ trực tiếp từ bộ nhớ ô bằng bộ đổ bóng đoạn tiếp theo trong cùng một bộ mã hóa lệnh kết xuất.

00:23:02.000 --> 00:23:05.000
Đây là những gì bạn phải làm trong mã của mình.

00:23:05.000 --> 00:23:11.000
Ở đây tôi đã đính kèm hình ảnh đầu ra dưới dạng kết cấu được đính kèm với tệp đính kèm màu 0 của bộ mô tả vượt qua kết xuất.

00:23:11.000 --> 00:23:17.000
Tôi đã đính kèm kết cấu giữ kết quả trung gian vào tệp đính kèm màu 1 của bộ mô tả vượt qua kết xuất.

00:23:17.000 --> 00:23:21.000
Cả hai thứ này sẽ được lát gạch ngầm cho bạn.

00:23:21.000 --> 00:23:26.000
Vui lòng đặt các thuộc tính tải/lưu trữ thích hợp như đã thảo luận trước đó trong bài nói chuyện.

00:23:26.000 --> 00:23:30.000
Bây giờ, thiết lập một cấu trúc để truy cập các kết cấu này trong bộ đổ bóng phân đoạn của bạn.

00:23:30.000 --> 00:23:35.000
Trong các ví dụ sắp tới, chúng tôi sẽ chỉ ra cách sử dụng cấu trúc này trong các bộ đổ bóng phân đoạn của bạn.

00:23:35.000 --> 00:23:43.000
Bạn chỉ cần truy cập đầu ra và kết cấu trung gian trong bộ đổ bóng phân đoạn của mình như được tô sáng bằng cách sử dụng cấu trúc mà chúng tôi đã xác định trước đó.

00:23:43.000 --> 00:23:49.000
Việc ghi vào các kết cấu này được thực hiện đến vị trí bộ nhớ gạch thích hợp tương ứng với đoạn.

00:23:49.000 --> 00:23:57.000
Đầu ra được tạo ra bởi bộ đổ bóng giải nén được tiêu thụ dưới dạng đầu vào bởi bộ đổ bóng chuyển đổi không gian màu bằng cách sử dụng cùng một cấu trúc mà chúng tôi đã xác định trước đó.

00:23:57.000 --> 00:24:06.000
Bộ đổ bóng phân đoạn này có thể tự xử lý và cập nhật kết cấu đầu ra và trung gian, một lần nữa, sẽ cập nhật vị trí bộ nhớ ô tương ứng.

00:24:06.000 --> 00:24:12.000
Bạn phải tiếp tục các bước tương tự cho tất cả các bộ đổ bóng phân đoạn khác trong cùng một đường chuyền bộ mã hóa kết xuất.

00:24:12.000 --> 00:24:17.000
Tiếp theo, hãy hình dung chuỗi hoạt động này trông như thế nào với những thay đổi này.

00:24:17.000 --> 00:24:30.000
Như bạn có thể thấy, bây giờ bạn đã giải nén, chuyển đổi không gian màu, ứng dụng LUT 3D và các bước hiệu chỉnh màu sắc, tất cả được thực hiện trên bộ nhớ gạch bằng cách sử dụng một đường kết xuất mà không có bộ nhớ thiết bị nào chuyển ở giữa.

00:24:30.000 --> 00:24:36.000
Khi kết thúc quá trình kết xuất, các mục tiêu kết xuất không phải là không có bộ nhớ sẽ được xả vào bộ nhớ thiết bị.

00:24:36.000 --> 00:24:39.000
Sau đó bạn có thể thực hiện lớp bộ lọc tiếp theo.

00:24:39.000 --> 00:24:43.000
Hãy nói một chút về các bộ lọc có các mẫu truy cập thu thập phân tán.

00:24:43.000 --> 00:24:49.000
Các hạt nhân đại diện cho các bộ lọc như vậy có thể hoạt động trực tiếp trên dữ liệu trong bộ nhớ thiết bị.

00:24:49.000 --> 00:24:54.000
Các bộ lọc tích chập rất phù hợp cho các hoạt động dựa trên ô trong hạt nhân tính toán.

00:24:54.000 --> 00:25:00.000
Tại đây, bạn có thể thể hiện ý định sử dụng bộ nhớ ô bằng cách khai báo bộ nhớ có phạm vi nhóm luồng.

00:25:00.000 --> 00:25:11.000
Bây giờ, bạn đưa khối pixel vào bộ nhớ ô cùng với tất cả các điểm ảnh hào quang cần thiết, tùy thuộc vào bán kính bộ lọc và thực hiện thao tác tích chập trực tiếp trên bộ nhớ ô.

00:25:11.000 --> 00:25:17.000
Hãy nhớ rằng, bộ nhớ ô không liên tục trên các công văn tính toán trong bộ mã hóa tính toán.

00:25:17.000 --> 00:25:23.000
Vì vậy, sau khi thực hiện Filter1, bạn phải xóa rõ ràng nội dung bộ nhớ gạch vào bộ nhớ thiết bị.

00:25:23.000 --> 00:25:27.000
Bằng cách đó, Filter2 có thể tiêu thụ đầu ra của Filter1.

00:25:27.000 --> 00:25:30.000
Vậy chúng ta hạ cánh ở đâu một khi chúng ta thực hiện tất cả những thay đổi này?

00:25:30.000 --> 00:25:39.000
Để xử lý một khung 4K ở độ chính xác dấu phẩy động 32 thông qua biểu đồ xử lý hình ảnh được cấu trúc lại ví dụ của chúng tôi, đây là những gì chúng tôi có bây giờ.

00:25:39.000 --> 00:25:48.000
Băng thông giảm từ 2,16 gigabyte xuống chỉ tải và lưu trữ trị giá 810 megabyte, và đó là giảm 62% lưu lượng bộ nhớ đến bộ nhớ thiết bị.

00:25:48.000 --> 00:25:54.000
Chúng tôi không cần hai bộ đệm thiết bị trung gian tiết kiệm 270 megabyte bộ nhớ trên mỗi khung hình.

00:25:54.000 --> 00:26:02.000
Và cuối cùng, chúng tôi đã giảm việc đập bộ nhớ cache, và đó là bởi vì tất cả các bộ đổ bóng phân đoạn trong đường chuyền kết xuất đó đang hoạt động trực tiếp trên bộ nhớ gạch.

00:26:02.000 --> 00:26:07.000
Một trong những tính năng chính của Apple silicon là Kiến trúc Bộ nhớ Thống nhất.

00:26:07.000 --> 00:26:15.000
Hãy xem một ví dụ về cách tận dụng Kiến trúc Bộ nhớ Hợp nhất này để tương tác giữa các khối khác nhau trên silicon Apple.

00:26:15.000 --> 00:26:21.000
Chúng tôi sẽ lấy mã hóa HEVC của khung hình video cuối cùng được hiển thị bởi GPU làm nghiên cứu điển hình.

00:26:21.000 --> 00:26:27.000
Mã hóa này được thực hiện bằng cách sử dụng các công cụ đa phương tiện phần cứng chuyên dụng trên Apple silicon.

00:26:27.000 --> 00:26:33.000
Khung đầu ra cuối cùng được hiển thị bởi GPU có thể được tiêu thụ trực tiếp bởi các công cụ phương tiện của chúng tôi mà không cần thêm bản sao bộ nhớ.

00:26:33.000 --> 00:26:43.000
Trong phần sắp tới, chúng ta sẽ đi qua một ví dụ về cách thiết lập đường ống để mã hóa HEVC của khung đầu ra cuối cùng do GPU tạo ra một cách hiệu quả nhất.

00:26:43.000 --> 00:26:51.000
Đối với điều đó, trước tiên chúng tôi sẽ tận dụng CoreVideo API để tạo ra một nhóm bộ đệm pixel được hỗ trợ bởi IOSurfaces.

00:26:51.000 --> 00:26:59.000
Sau đó, sử dụng Metal API, chúng tôi kết xuất các khung hình cuối cùng thành các kết cấu Metal được hỗ trợ bởi IOSurfaces từ nhóm mà chúng tôi vừa tạo.

00:26:59.000 --> 00:27:09.000
Và cuối cùng, chúng tôi gửi các bộ đệm pixel này trực tiếp đến công cụ phương tiện để mã hóa mà không cần bất kỳ bản sao bổ sung nào của các khung đầu ra do GPU tạo ra, do đó tận dụng Kiến trúc Bộ nhớ Hợp nhất.

00:27:09.000 --> 00:27:15.000
Hãy cùng xem qua cách thực hiện từng bước và bao gồm tất cả các cấu trúc mà chúng ta cần để kích hoạt luồng này.

00:27:15.000 --> 00:27:21.000
Đầu tiên, chúng tôi tạo một CVPixelBufferPool được hỗ trợ bởi IOSurface ở định dạng pixel mong muốn.

00:27:21.000 --> 00:27:28.000
Ở đây, chúng tôi sẽ sử dụng định dạng pixel lấy mẫu phụ sắc độ hai mặt phẳng để mã hóa HEVC.

00:27:28.000 --> 00:27:32.000
Bây giờ, bạn nhận được CVPixelBuffer từ CVPixelBufferPool này.

00:27:32.000 --> 00:27:39.000
Chuyển CVPixelBuffer này đến MetalTextureCache với chỉ mục mặt phẳng phù hợp để lấy CVMetalTextureReference.

00:27:39.000 --> 00:27:45.000
Vì chúng tôi đang sử dụng định dạng pixel hai mặt phẳng, bạn cần thực hiện bước này cho cả hai mặt phẳng của bộ đệm pixel hai mặt phẳng.

00:27:45.000 --> 00:27:50.000
Tiếp theo, lấy kết cấu Kim loại bên dưới từ đối tượng CVMetalTextureReference.

00:27:50.000 --> 00:27:53.000
Thực hiện bước này cho cả mặt phẳng độ sáng và sắc độ.

00:27:53.000 --> 00:28:00.000
Hãy nhớ rằng các kết cấu Kim loại này được hỗ trợ bởi cùng một bề mặt IOS cũng đang hỗ trợ các mặt phẳng CVPixelBuffer.

00:28:00.000 --> 00:28:06.000
Sử dụng Metal API, kết xuất thành các kết cấu tương ứng với mặt phẳng độ sáng và sắc độ.

00:28:06.000 --> 00:28:10.000
Điều này sẽ cập nhật bề mặt IOS cũng hỗ trợ các kết cấu Kim loại này.

00:28:10.000 --> 00:28:18.000
Chúng tôi thực sự khuyên bạn nên thực hiện bước lấy mẫu phụ sắc độ trên các mặt phẳng sắc độ trên chính GPU như một đường chuyền đổ bóng trong quy trình xử lý hình ảnh của bạn.

00:28:18.000 --> 00:28:29.000
Một điều quan trọng cần lưu ý là cả CVPixelBuffer và kết cấu Kim loại - mà chúng tôi vừa kết xuất vào - đều được hỗ trợ bởi cùng một bản sao bề mặt IOS cơ bản trong bộ nhớ hệ thống.

00:28:29.000 --> 00:28:33.000
Bây giờ bạn có thể gửi CVPixelBuffer này trực tiếp đến công cụ phương tiện để mã hóa.

00:28:33.000 --> 00:28:41.000
Như bạn có thể thấy, do Kiến trúc bộ nhớ hợp nhất, chúng ta có thể di chuyển dữ liệu liền mạch giữa GPU và khối công cụ phương tiện mà không cần bản sao bộ nhớ.

00:28:41.000 --> 00:28:48.000
Và cuối cùng, hãy nhớ phát hành tham chiếu CVPixelBuffer và CVMetalTexture sau mỗi khung hình.

00:28:48.000 --> 00:28:53.000
Phát hành CVPixelBuffer cho phép tái chế bộ đệm này cho các khung trong tương lai.

00:28:53.000 --> 00:29:16.000
Để kết thúc, chúng tôi khuyến khích bạn một lần nữa làm như sau: tận dụng Kiến trúc bộ nhớ hợp nhất, sử dụng MTLRenderCommandEncoder thay vì tính toán khi áp dụng, hợp nhất tất cả các thẻ kết xuất đủ điều kiện của bạn trong bộ mã hóa lệnh kết xuất đơn, đặt hành động tải / lưu trữ thích hợp, sử dụng không bộ

00:29:16.000 --> 00:29:19.000
Chúng tôi muốn cảm ơn bạn vì đã tham gia phiên họp này hôm nay.

00:29:19.000 --> 00:29:22.000
Tận hưởng phần còn lại của WWDC 2021!

00:29:22.000 --> 23:59:59.000
♪

