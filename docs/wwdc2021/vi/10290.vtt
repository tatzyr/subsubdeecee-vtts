WEBVTT

00:00:00.000 --> 00:00:05.000
♪ Nhạc bass đang phát ♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:11.000
Marty Pye: Chào mừng đến với "Có gì mới trong AVKit".

00:00:11.000 --> 00:00:14.000
Tên tôi là Marty Pye và tôi là một kỹ sư trong nhóm AVKit.

00:00:14.000 --> 00:00:23.000
Hôm nay, tôi muốn nói về một số cải tiến mà chúng tôi đã thực hiện cho Picture in Picture - hoặc ngắn gọn, PiP - cũng như trải nghiệm toàn màn hình trên macOS.

00:00:23.000 --> 00:00:27.000
Hãy bắt đầu với Picture in Picture.

00:00:27.000 --> 00:00:33.000
Với Picture in Picture, người dùng có thể tiếp tục thưởng thức nội dung video của họ trong khi đa nhiệm với thiết bị của họ.

00:00:33.000 --> 00:00:41.000
Ví dụ: nếu bạn đang xem video toàn màn hình và nhận được tin nhắn, bạn có thể trả lời ngắn gọn tin nhắn đó trong khi tiếp tục xem nội dung của mình.

00:00:41.000 --> 00:00:48.000
Video sẽ tự động nhập PiP và khi bạn trả lời xong, bạn có thể nhanh chóng tiếp tục phát lại toàn màn hình.

00:00:48.000 --> 00:00:55.000
Điều này tạo ra trải nghiệm xem thực sự liền mạch và chúng tôi nghĩ rằng người dùng sẽ mong đợi hành vi này bất cứ khi nào họ xem video.

00:00:55.000 --> 00:01:05.000
Để biết thêm thông tin về cách tích hợp PiP vào các ứng dụng của riêng bạn, tôi khuyến khích bạn xem phiên 2019 này về việc cung cấp phát lại phương tiện trực quan với AVKit.

00:01:05.000 --> 00:01:14.000
Mới trong năm nay, nếu video của bạn đang phát nội tuyến, bạn có thể tùy chọn cho phép nó tự động nhập PiP khi người dùng vuốt trở lại Màn hình chính.

00:01:14.000 --> 00:01:21.000
Kích hoạt hành vi này đạt được thông qua thuộc tính canStartPictureInPicture AutomaticallyFromInline.

00:01:21.000 --> 00:01:31.000
Thuộc tính này có sẵn cả trên AVPlayerViewController cho các ứng dụng sử dụng các điều khiển gốc của chúng tôi và trên AVPictureInPictureController cho các ứng dụng triển khai giao diện người dùng tùy chỉnh của riêng họ.

00:01:31.000 --> 00:01:39.000
Đảm bảo chỉ đặt cờ này thành true khi nội dung phát được dự định là trọng tâm chính của người dùng.

00:01:39.000 --> 00:01:44.000
Nếu bạn đang sử dụng AVPlayerViewController để trình bày nội dung video, PiP sẽ được xử lý cho bạn.

00:01:44.000 --> 00:01:46.000
Bạn không cần phải làm gì cả.

00:01:46.000 --> 00:01:54.000
Nếu bạn không sử dụng AVPlayerViewController, bạn vẫn có thể sử dụng AVPictureInPictureController để mang trải nghiệm PiP gốc vào ứng dụng của mình.

00:01:54.000 --> 00:02:01.000
Trước tiên, bạn cần định cấu hình danh mục phiên âm thanh của ứng dụng để phát lại và bật chế độ nền PiP.

00:02:01.000 --> 00:02:08.000
Sau đó, tất cả những gì bạn cần làm là tạo một pictureInPictureController, chuyển một tham chiếu đến playerLayer.

00:02:08.000 --> 00:02:17.000
Sau đó, khi người dùng cố gắng chuyển đổi Ảnh trong Ảnh bằng nút bạn cung cấp, bạn chỉ cần gọi bắt đầu hoặc dừng PiP trên đối tượng bộ điều khiển.

00:02:17.000 --> 00:02:22.000
Cho đến nay, trải nghiệm Picture in Picture của chúng tôi được xây dựng dựa trên nội dung dựa trên AVPlayer.

00:02:22.000 --> 00:02:28.000
Hôm nay, tôi vui mừng thông báo mức độ hỗ trợ tương tự cho AVSampleBufferDisplayLayer.

00:02:28.000 --> 00:02:40.000
Thay vì tạo bộ điều khiển Picture in Picture với lớp trình phát, trước tiên bạn tạo ContentSource, mà bạn đã thiết lập với AVPlayerLayer hoặc - như được hiển thị ở đây - bằng AVSampleBufferDisplayLayer.

00:02:40.000 --> 00:02:43.000
Đối với người dùng, trải nghiệm Picture in Picture sẽ giống hệt nhau.

00:02:43.000 --> 00:02:51.000
Đối với bạn với tư cách là nhà phát triển, có một số trách nhiệm mới liên quan đến việc hỗ trợ PiP cho AVSampleBufferDisplayLayer.

00:02:51.000 --> 00:02:53.000
Hãy cùng xem đại diện phát lại này.

00:02:53.000 --> 00:03:06.000
Chúng tôi phải dựa vào thông tin trạng thái phát lại được cung cấp thông qua AVPictureInPictureSample BufferPlaybackDelegate mới để hiển thị giao diện người dùng PiP, vì phát lại phương tiện không được quản lý bởi AVPlayer.

00:03:06.000 --> 00:03:12.000
Khi người dùng cố gắng kiểm soát phương tiện từ giao diện người dùng PiP, chúng tôi chuyển tiếp các lệnh đó đến đại diện để xử lý.

00:03:12.000 --> 00:03:16.000
Hãy xem qua năm cuộc gọi lại riêng lẻ từng cái một.

00:03:16.000 --> 00:03:21.000
Chức năng setPlaying được gọi khi người dùng nhấn nút Phát/Tạm dừng trong cửa sổ PiP.

00:03:21.000 --> 00:03:25.000
Chức năng skipByInterval được gọi khi người dùng nhấn một trong các nút bỏ qua.

00:03:25.000 --> 00:03:29.000
Sử dụng các cuộc gọi lại này để kiểm soát phương tiện của bạn cho phù hợp.

00:03:29.000 --> 00:03:34.000
Chức năng timeRangeForPlayback cho phép bạn chỉ định phạm vi thời gian hiện có thể chơi được.

00:03:34.000 --> 00:03:39.000
Điều này cho phép chúng tôi hiển thị dòng thời gian và hiển thị vị trí hiện tại của đầu phát.

00:03:39.000 --> 00:03:45.000
Phạm vi thời gian với thời lượng hữu hạn phải luôn chứa thời gian hiện tại của cơ sở thời gian của lớp hiển thị bộ đệm mẫu.

00:03:45.000 --> 00:03:50.000
Sử dụng phạm vi thời gian với thời lượng vô hạn để chỉ ra nội dung trực tiếp.

00:03:50.000 --> 00:03:57.000
Hàm didTransitionToRenderSize được gọi khi cửa sổ Picture in Picture thay đổi kích thước, chẳng hạn như trong quá trình pinch-to-zoom.

00:03:57.000 --> 00:04:04.000
Hãy tính đến kích thước kết xuất này khi chọn các biến thể phương tiện để tránh chi phí giải mã không cần thiết.

00:04:04.000 --> 00:04:12.000
Chức năng isPlaybackPaused được gọi định kỳ và thông báo cho Picture in Picture UI xem có phản ánh trạng thái tạm dừng hay đang phát hay không.

00:04:12.000 --> 00:04:17.000
Về mặt khái niệm, điều này tương đương với timeControlStatus trên AVPlayer.

00:04:17.000 --> 00:04:23.000
Tiếp theo, chúng ta hãy xem xét một số cải tiến mà chúng tôi đã thực hiện đối với trải nghiệm toàn màn hình trên macOS.

00:04:23.000 --> 00:04:31.000
Trong Big Sur, khi bạn quay video toàn màn hình trong ứng dụng Mac Catalyst, video sẽ lấp đầy toàn bộ cửa sổ nhưng không phải toàn bộ màn hình.

00:04:31.000 --> 00:04:36.000
Bây giờ trong macOS Monterey, video sẽ chiếm toàn bộ màn hình.

00:04:36.000 --> 00:04:42.000
Bạn kết thúc với trải nghiệm toàn màn hình thực sự cho cả ứng dụng macOS gốc và Mac Catalyst.

00:04:42.000 --> 00:04:44.000
Các điều khiển phát lại trông giống nhau cho cả hai.

00:04:44.000 --> 00:04:48.000
Tất cả các ứng dụng Mac Catalyst sẽ tự động nhận được hành vi mới này.

00:04:48.000 --> 00:04:54.000
Giống như trong bất kỳ trải nghiệm toàn màn hình macOS gốc nào, người dùng có thể vuốt trở lại cửa sổ ứng dụng.

00:04:54.000 --> 00:05:00.000
Trình giữ chỗ sẽ được hiển thị thay vì video gốc, cho biết nội dung đang phát toàn màn hình.

00:05:00.000 --> 00:05:06.000
Điều này rất giống với trình giữ chỗ được hiển thị khi video đang phát trong Ảnh trong Ảnh.

00:05:06.000 --> 00:05:15.000
Trong trường hợp bạn trình bày bộ điều khiển chế độ xem toàn màn hình của người chơi sau khi người dùng chọn một số nội dung, bộ điều khiển chế độ xem sẽ vẫn hiển thị trong toàn bộ cửa sổ.

00:05:15.000 --> 00:05:25.000
Tuy nhiên, mới trong macOS Monterey, người dùng có thể tách ra trải nghiệm phát lại toàn màn hình thực sự bằng cách nhấn nút toàn màn hình màu xanh lá cây ở trên cùng bên trái của cửa sổ.

00:05:25.000 --> 00:05:32.000
Vòng đời toàn màn hình có thể được quản lý rõ ràng để cung cấp trải nghiệm người dùng tốt hơn dựa trên nhu cầu ứng dụng của bạn.

00:05:32.000 --> 00:05:35.000
Hãy xem xét một ví dụ.

00:05:35.000 --> 00:05:43.000
Như chúng tôi đã chỉ ra, người dùng sẽ có thể quay video toàn màn hình và sau đó vuốt trở lại ứng dụng của bạn trong khi phát lại tiếp tục.

00:05:43.000 --> 00:05:50.000
Họ sẽ có thể điều hướng ứng dụng của bạn một cách tự do, ngay cả khi điều đó dẫn đến việc bộ điều khiển chế độ xem của người chơi bị xóa khỏi hệ thống phân cấp chế độ xem của bạn.

00:05:50.000 --> 00:05:57.000
Tại bất kỳ thời điểm nào, họ sẽ có thể vuốt hoặc sử dụng Mission Control để điều hướng trở lại video toàn màn hình.

00:05:57.000 --> 00:05:59.000
Vì vậy, chúng ta hãy xem làm thế nào để làm cho nó hoạt động.

00:05:59.000 --> 00:06:03.000
Bạn chịu trách nhiệm về vòng đời của playerViewController.

00:06:03.000 --> 00:06:12.000
Để đạt được trải nghiệm tối ưu, bạn cần đảm bảo giữ cho playerViewController hoạt động ngay cả khi nó không nằm trong hệ thống phân cấp chế độ xem của ứng dụng của bạn.

00:06:12.000 --> 00:06:20.000
Nếu không, khi người dùng điều hướng ra khỏi trang có video, việc phát lại toàn màn hình sẽ kết thúc khi trình phátViewController được phát hành.

00:06:20.000 --> 00:06:27.000
Tất cả những gì bạn cần làm là giữ một tham chiếu mạnh mẽ đến playerViewController khi bạn nhận được lệnh gọi lại willBeginFullScreenPresentation.

00:06:27.000 --> 00:06:34.000
Sau đó, khi người dùng thoát khỏi toàn màn hình, bạn sẽ nhận được cuộc gọi lại willEndFullScreenPresentation.

00:06:34.000 --> 00:06:43.000
Đây là cơ hội của bạn để buông bỏ trình phátViewController mà bạn đang giữ sống, giả sử người dùng đã điều hướng ra khỏi chế độ xem ban đầu mà nó được trình bày.

00:06:43.000 --> 00:06:46.000
Điều tương tự cũng áp dụng cho macOS gốc.

00:06:46.000 --> 00:06:54.000
Bạn có thể sử dụng playerViewDelegate mới để giữ cho playerView tồn tại cho đến khi bạn nhận được cuộc gọi lại playerViewWillExitFullScreen.

00:06:54.000 --> 00:07:00.000
Khi người dùng thoát khỏi toàn màn hình, bạn cũng sẽ nhận được cuộc gọi lại restoreUserInterface này.

00:07:00.000 --> 00:07:08.000
Đây là cơ hội để ứng dụng của bạn điều hướng trở lại trang gốc chứa video, giả sử điều đó phù hợp với trường hợp sử dụng của bạn.

00:07:08.000 --> 00:07:14.000
Điều này rất giống với cuộc gọi lại hiện tại mà bạn nhận được khi người dùng dừng Picture in Picture.

00:07:14.000 --> 00:07:21.000
Đảm bảo quay lại từ Trình xử lý hoàn thành này càng nhanh càng tốt để không chặn quá trình chuyển đổi từ toàn màn hình sang nội tuyến.

00:07:21.000 --> 00:07:29.000
Trả về false chỉ ra rằng việc khôi phục không thành công hoặc không thể thực hiện được, trong trường hợp đó nội dung thoát toàn màn hình mà không có hình ảnh động.

00:07:29.000 --> 00:07:32.000
Với điều đó, tôi muốn kết thúc phiên hôm nay.

00:07:32.000 --> 00:07:41.000
Chúng tôi đã thấy cách sử dụng API nguồn nội dung mới để thêm hỗ trợ Picture in Picture vào ứng dụng của bạn khi sử dụng AVSampleBufferDisplayLayer thay vì AVPlayerLayer.

00:07:41.000 --> 00:07:50.000
Đối với macOS và Mac Catalyst, chúng tôi đã xem xét trải nghiệm toàn màn hình nâng cao và phác thảo các bước cần thiết để mã của bạn tích hợp liền mạch.

00:07:50.000 --> 00:07:56.000
Tôi hy vọng bạn thích phiên hôm nay và tôi mong muốn thấy một số tính năng này được tích hợp vào ứng dụng của bạn.

00:07:56.000 --> 00:07:58.000
Tận hưởng phần còn lại của hội nghị.

00:07:58.000 --> 23:59:59.000
♪

