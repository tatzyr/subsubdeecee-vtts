WEBVTT

00:00:00.000 --> 00:00:05.000
♪ Nhạc bass đang phát ♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:10.000
Alejandro Lucena: Xin chào mọi người.

00:00:10.000 --> 00:00:13.000
Cảm ơn bạn đã tham dự phiên họp này về biểu tượng.

00:00:13.000 --> 00:00:22.000
Mặc dù biểu tượng hóa có vẻ như là một thuật ngữ mơ hồ, chúng ta sẽ thấy vai trò công cụ của nó trong việc giúp bạn nhanh chóng xác định nguyên nhân gốc rễ của lỗi, sự cố và tắc nghẽn hiệu suất.

00:00:22.000 --> 00:00:30.000
Chúng tôi sẽ có được trực giác sâu sắc hơn về cách thức hoạt động của biểu tượng và bao gồm một số công cụ mà bạn có theo ý của mình để làm theo trực tiếp.

00:00:30.000 --> 00:00:43.000
Trên đường đi, chúng ta sẽ thảo luận về các nguồn thông tin gỡ lỗi khác nhau cần thiết cho trải nghiệm biểu tượng phong phú và cách bạn có thể định cấu hình ứng dụng của mình để sử dụng tốt nhất thông tin này.

00:00:43.000 --> 00:00:49.000
Hãy bắt đầu bằng cách làm quen với một định nghĩa và ví dụ cụ thể về biểu tượng.

00:00:49.000 --> 00:01:03.000
Về cơ bản, biểu tượng hóa là một cơ chế để chuyển đổi hoặc dịch cách các thiết bị của chúng ta nhìn thấy các ứng dụng của chúng ta trong thời gian chạy - đó là về địa chỉ bộ nhớ và hướng dẫn - trở lại cách chúng ta với tư cách là nhà phát triển nhìn thấy ứng dụng của mình - đó là về chức năng, tên và tệp.

00:01:03.000 --> 00:01:11.000
Nếu không có lớp bắc cầu này, nó sẽ làm phức tạp đáng kể việc chẩn đoán lỗi ngay cả đối với một vài dòng mã.

00:01:11.000 --> 00:01:13.000
Ví dụ, hãy xem xét mã Swift này.

00:01:13.000 --> 00:01:20.000
Ở đây tôi có một hàm, `generateMagicNumber()`, chọn một số cụ thể từ danh sách các số ứng cử viên.

00:01:20.000 --> 00:01:27.000
Để làm điều này, trước tiên chúng tôi gọi vào `numberChoices()` trả về một mảng gồm 10 số được tạo ngẫu nhiên.

00:01:27.000 --> 00:01:33.000
Sau đó, chúng tôi chuyển mảng đó vào `selectMagicNumber(choices:)`, trả về số tại một chỉ mục cụ thể.

00:01:33.000 --> 00:01:37.000
Đây có vẻ là một chương trình hợp lý, nhưng tôi gặp sự cố khi lần đầu tiên chạy nó.

00:01:37.000 --> 00:01:42.000
Cách truy đòi đầu tiên của tôi là kiểm tra nhật ký sự cố, điều này khá không có kết quả.

00:01:42.000 --> 00:01:47.000
Tất cả những gì tôi có thể nói từ backtrace chủ đề là ứng dụng MagicNumbers của tôi bị lỗi ở đâu đó.

00:01:47.000 --> 00:01:49.000
Cảm ơn, nhưng tôi đã biết điều đó rồi.

00:01:49.000 --> 00:01:54.000
Tôi cũng không biết bất kỳ sổ đăng ký nào đang đề cập đến điều gì.

00:01:54.000 --> 00:02:02.000
Tôi có thể thử bước qua ứng dụng với trình gỡ lỗi và xác định sự cố, nhưng điều gì sẽ xảy ra nếu điều này chỉ xảy ra trong những trường hợp cụ thể mà tôi không thể tái tạo?

00:02:02.000 --> 00:02:07.000
Sử dụng trình gỡ lỗi sẽ không nhất thiết phải xác định chính xác vấn đề đối với tôi trong trường hợp đó.

00:02:07.000 --> 00:02:13.000
Hoặc tôi có thể cố gắng nhìn vào việc tháo gỡ, nhưng việc theo dõi mọi thứ khó khăn hơn nhiều.

00:02:13.000 --> 00:02:22.000
Đây rõ ràng không phải là một cách khả thi để chẩn đoán vấn đề, và quan trọng hơn, với sự trợ giúp của biểu tượng, chúng ta không phải gỡ lỗi từ điểm bắt đầu này.

00:02:22.000 --> 00:02:28.000
Xcode Organizer cho tôi biết tôi có thể tải xuống dSYM cho ứng dụng này, ứng dụng này sẽ xử lý lại nhật ký sự cố.

00:02:28.000 --> 00:02:44.000
Khi làm như vậy, Xcode áp dụng các khái niệm về biểu tượng để tôi có thể chẩn đoán sự cố bằng nhật ký sự cố đẹp hơn nhiều, nơi tôi không chỉ có thể thấy tất cả các chức năng của mình thực sự được gọi mà còn có thể xác định tệp và số dòng để tham chiếu lại trong mã của mình.

00:02:44.000 --> 00:02:49.000
Nhật ký sự cố được cập nhật này cũng cho tôi biết rằng chúng tôi đã cố gắng truy cập một chỉ mục ngoài phạm vi.

00:02:49.000 --> 00:02:56.000
Ngoài ra, nếu tôi đã có dSYM, tôi có thể sử dụng lệnh `atos` để lấy thông tin tương tự.

00:02:56.000 --> 00:03:03.000
Nhìn lại mã của mình, tôi nhận ra rằng `MAGIC_CHOICE` nằm ngoài giới hạn của mảng 10 phần tử của chúng ta.

00:03:03.000 --> 00:03:04.000
Rất tiếc.

00:03:04.000 --> 00:03:10.000
Trong một trường hợp khác, tôi quan tâm đến việc lập hồ sơ ứng dụng của mình để mang lại trải nghiệm người dùng nhanh nhất.

00:03:10.000 --> 00:03:16.000
Ở đây, Công cụ cho tôi thấy rằng ứng dụng chu kỳ qua các giai đoạn sử dụng cao và sử dụng thấp.

00:03:16.000 --> 00:03:22.000
Nếu chúng ta tập trung vào khoảng thời gian sử dụng thấp, Instruments cho chúng ta biết rằng ứng dụng đang ghi một số nội dung vào một tệp.

00:03:22.000 --> 00:03:28.000
Tuy nhiên, khi tôi kiểm tra một khoảng thời gian sử dụng cao, tôi nhận được cùng một dấu vết ngược chính xác.

00:03:28.000 --> 00:03:29.000
Làm thế nào điều này có thể xảy ra?

00:03:29.000 --> 00:03:32.000
Cái này không thực thi cùng một mã chính xác sao?

00:03:32.000 --> 00:03:36.000
Như chúng ta sẽ thấy, dấu vết Dụng cụ này chỉ được tượng trưng một phần.

00:03:36.000 --> 00:03:42.000
Ví dụ, tôi không thấy bất kỳ tên tệp hoặc số dòng nào trong dấu vết ngược như tôi đã làm với nhật ký sự cố được cập nhật.

00:03:42.000 --> 00:03:45.000
Kết quả là, nó thiếu một số thông tin.

00:03:45.000 --> 00:03:49.000
Với ý nghĩ đó, tôi có thể xác định vị trí tương tự dSYM của mình trong Instruments.

00:03:49.000 --> 00:04:00.000
Sau khi làm điều này, dấu vết Công cụ mới của tôi cho thấy các vùng sử dụng cao thực sự đang ghi vào một tệp, nhưng chúng đặc biệt nằm trong đường dẫn mã gỡ lỗi mà tôi đã để lại trong chương trình.

00:04:00.000 --> 00:04:05.000
Các khu vực sử dụng thấp tránh điều này và thể hiện cách ứng dụng của tôi hoạt động trong sản xuất.

00:04:05.000 --> 00:04:19.000
Giống như Xcode đã sử dụng dSYM để tượng trưng cho một nhật ký sự cố khá thiếu thông tin, Instruments cũng đã sử dụng dSYM để làm phong phú thêm một dấu vết được tượng trưng một phần và cho tôi biết nguyên nhân chính xác của vấn đề hiệu suất.

00:04:19.000 --> 00:04:26.000
Bây giờ, mặc dù thật tuyệt khi những công cụ này tận dụng tính biểu tượng để xác định các khu vực có vấn đề trong mã của tôi, nhưng nó tự nhiên đặt ra một vài câu hỏi.

00:04:26.000 --> 00:04:28.000
Tất cả những thứ này hoạt động như thế nào?

00:04:28.000 --> 00:04:29.000
Tôi có thể áp dụng cái này ở đâu khác?

00:04:29.000 --> 00:04:32.000
Và đây có phải là tất cả về dSYMs không?

00:04:32.000 --> 00:04:38.000
Để trả lời những câu hỏi này và mở khóa khả năng của biểu tượng, chúng ta sẽ cần đi sâu hơn vào các chi tiết.

00:04:38.000 --> 00:04:43.000
Điều này có vẻ hơi quá sức, nhưng đây là những khái niệm quan trọng cần hiểu.

00:04:43.000 --> 00:04:48.000
Có rất nhiều công cụ để hỗ trợ gỡ lỗi và lập hồ sơ dựa trên biểu tượng.

00:04:48.000 --> 00:04:54.000
Chỉ riêng `atos` đã cho chúng tôi nguyên nhân gốc rễ chính xác của sự cố và có nhiều công cụ khác được tích hợp trong Xcode.

00:04:54.000 --> 00:05:00.000
Hơn nữa, chúng tôi đã chỉ định các cờ như `o`, `l` và `i` cho `atos`, nhưng chúng có nghĩa là gì?

00:05:00.000 --> 00:05:02.000
Chúng ta có luôn sử dụng cùng một bộ cờ không?

00:05:02.000 --> 00:05:05.000
Điều gì sẽ xảy ra nếu chúng ta không có sẵn một trong những giá trị?

00:05:05.000 --> 00:05:15.000
Bạn cũng sẽ có được một nền tảng tốt trong việc hiểu khi nào và tại sao dấu vết ngược của bạn có thể không được tượng trưng hóa hoàn toàn và làm thế nào để khắc phục điều đó, như chúng ta đã thấy trong trường hợp Dụng cụ.

00:05:15.000 --> 00:05:21.000
Cuối cùng, có một số cài đặt xây dựng mà bạn đang kiểm soát ảnh hưởng đến sự phong phú của biểu tượng.

00:05:21.000 --> 00:05:26.000
Chúng tôi sẽ xem xét các cài đặt xây dựng này để bạn có trực giác vững chắc về cách chúng được sử dụng.

00:05:26.000 --> 00:05:30.000
Cuối cùng, tôi muốn giới thiệu quy trình hai bước để tượng trưng hóa.

00:05:30.000 --> 00:05:36.000
Bước số một sẽ quay lại tệp và bước số hai là tham khảo thông tin gỡ lỗi.

00:05:36.000 --> 00:05:44.000
Như chúng ta sẽ thấy, quay lại tệp là tất cả về việc chuyển đổi hoặc dịch các địa chỉ bộ nhớ thời gian chạy thành một dạng ổn định hơn, có thể sử dụng được.

00:05:44.000 --> 00:05:52.000
Điều này cho phép chúng tôi giao tiếp với thông tin gỡ lỗi của mình để tạo kết nối có ý nghĩa giữa địa chỉ bộ nhớ thô và mã nguồn.

00:05:52.000 --> 00:05:57.000
Hãy bắt đầu bằng cách thảo luận về bước số một, quay lại tệp.

00:05:57.000 --> 00:06:07.000
Mục tiêu cuối cùng trong bước này là dịch địa chỉ bộ nhớ thời gian chạy, chẳng hạn như những địa chỉ chúng ta đã thấy trong nhật ký sự cố ban đầu, sang một địa chỉ tương ứng trong tệp nhị phân của bạn trên đĩa.

00:06:07.000 --> 00:06:13.000
Giống như chúng tôi có địa chỉ thời gian chạy, các ứng dụng và khuôn khổ của bạn cũng có không gian địa chỉ trên đĩa!

00:06:13.000 --> 00:06:23.000
Không gian địa chỉ trên đĩa khác với không gian địa chỉ mà ứng dụng của bạn chiếm trong thời gian chạy và chúng tôi cần một cơ chế để tìm ra những khác biệt đó.

00:06:23.000 --> 00:06:27.000
Đầu tiên, chúng ta nên hiểu chính xác địa chỉ trên đĩa là gì.

00:06:27.000 --> 00:06:31.000
Những địa chỉ này được chỉ định bởi trình liên kết khi bạn xây dựng ứng dụng của mình.

00:06:31.000 --> 00:06:34.000
Cụ thể, trình liên kết nhóm nhị phân của bạn thành các phân đoạn.

00:06:34.000 --> 00:06:41.000
Mỗi phân đoạn chứa dữ liệu liên quan và có các thuộc tính như tên, kích thước và địa chỉ được chỉ định của chúng.

00:06:41.000 --> 00:06:52.000
Ví dụ, đoạn `__TEXT` của tệp nhị phân của bạn chứa tất cả các hàm và phương thức bạn đã viết và đoạn `__DATA` chứa trạng thái toàn chương trình như các biến toàn cục.

00:06:52.000 --> 00:06:57.000
Mỗi phân đoạn này được chỉ định một địa chỉ khác nhau sao cho chúng không trùng lặp.

00:06:57.000 --> 00:07:03.000
Trình liên kết ghi lại thông tin này ngay từ đầu tệp thực thi của bạn như một phần của tiêu đề Mach-O.

00:07:03.000 --> 00:07:10.000
Mach-O là định dạng được sử dụng cho tất cả các tệp nhị phân và thư viện thực thi, và hệ thống biết rằng nó cần đọc tiêu đề này để chạy ứng dụng của bạn.

00:07:10.000 --> 00:07:17.000
Nhìn kỹ hơn một chút, tiêu đề Mach-O chứa một số lệnh tải giữ các thuộc tính phân đoạn.

00:07:17.000 --> 00:07:21.000
Hệ thống sử dụng các lệnh tải này để tải các phân đoạn vào bộ nhớ.

00:07:21.000 --> 00:07:28.000
Lưu ý rằng nếu ứng dụng của bạn là Universal 2, thì ứng dụng sẽ có một tiêu đề và một tập hợp các phân đoạn cho mỗi kiến trúc.

00:07:28.000 --> 00:07:35.000
Chúng ta có thể tự xem bằng cách sử dụng lệnh `otool -l`, lệnh này in các lệnh tải cho một tệp được chỉ định.

00:07:35.000 --> 00:07:41.000
Ở đây, chúng tôi đang tìm kiếm một lệnh tải phân đoạn được xác định bằng `LC_SEGMENT_64`.

00:07:41.000 --> 00:07:48.000
Các lệnh tải này nói rằng đoạn `__TEXT` bắt đầu tại địa chỉ trong `vmaddr` và dài `vmsize` byte.

00:07:48.000 --> 00:07:57.000
Vì vậy, nếu hạt nhân tuân theo các lệnh tải này để tải các phân đoạn vào bộ nhớ, chính xác thì sự khác biệt giữa thời gian chạy và địa chỉ liên kết là gì?

00:07:57.000 --> 00:08:04.000
Chà, trước khi hạt nhân thực sự tải các phân đoạn, nó khởi tạo một giá trị ngẫu nhiên được gọi là slide ASLR.

00:08:04.000 --> 00:08:09.000
Hạt nhân sau đó thêm slide ASLR vào các địa chỉ trong các lệnh tải.

00:08:09.000 --> 00:08:21.000
Vì vậy, thay vì tải phân đoạn `__TEXT` tại địa chỉ A và phân đoạn `__DATA` tại địa chỉ B, hạt nhân thay vào đó tải chúng vào A+S và B+S, trong đó S là trang chiếu ASLR.

00:08:21.000 --> 00:08:28.000
Vì A+S và B+S là những địa chỉ thực sự mà hệ thống sử dụng, chúng còn được gọi là địa chỉ tải.

00:08:28.000 --> 00:08:36.000
Với ý nghĩ đó, bây giờ chúng ta biết rằng sự khác biệt giữa địa chỉ thời gian chạy và địa chỉ liên kết là slide ASLR.

00:08:36.000 --> 00:08:48.000
Chúng ta có thể tính toán slide ASLR với phương trình sau: S = L-A, trong đó S là slide ASLR, L là địa chỉ tải và A là địa chỉ liên kết.

00:08:48.000 --> 00:08:57.000
Chúng ta sẽ sớm thấy các ví dụ về phương trình này, nhưng điểm mấu chốt là chúng ta luôn có thể quay lại không gian địa chỉ tệp khi chúng ta biết trang chiếu ASLR.

00:08:57.000 --> 00:09:04.000
Phương trình trượt ASLR yêu cầu hai địa chỉ - địa chỉ tải và địa chỉ liên kết - vậy chúng ta lấy chúng từ đâu?

00:09:04.000 --> 00:09:11.000
Chúng tôi đã thấy cách chúng tôi có thể truy vấn các lệnh tải để biết địa chỉ liên kết bằng `otool`.

00:09:11.000 --> 00:09:21.000
Để biết địa chỉ thời gian chạy, hệ thống truy vấn ứng dụng của bạn tại thời điểm xảy ra sự cố hoặc khi nó được Công cụ lập hồ sơ cho không gian địa chỉ thời gian chạy của nó.

00:09:21.000 --> 00:09:27.000
Thông tin này được phản ánh trong danh sách Hình ảnh nhị phân trong nhật ký sự cố của bạn.

00:09:27.000 --> 00:09:35.000
Bạn cũng có thể xem các địa chỉ tải tương tác với công cụ `vmmap`, công cụ này liệt kê các vùng bộ nhớ đang hoạt động trong chương trình của bạn.

00:09:35.000 --> 00:09:40.000
Hãy tự tính giá trị slide ASLR từ nhật ký sự cố ban đầu.

00:09:40.000 --> 00:09:44.000
Trong danh sách Hình ảnh nhị phân, tôi có địa chỉ tải của phân đoạn `__TEXT`.

00:09:44.000 --> 00:09:49.000
Tôi cũng có địa chỉ liên kết cho tệp nhị phân trên đĩa khi tôi xem các lệnh tải.

00:09:49.000 --> 00:09:54.000
Trừ hai cái này tạo ra giá trị trượt ASLR là 0x45c000.

00:09:54.000 --> 00:10:04.000
Điều này có nghĩa là mọi địa chỉ trong phân đoạn `__TEXT` thời gian chạy của chương trình của tôi đều cách địa chỉ phân đoạn `__TEXT` của trình liên kết 0x45c000 byte.

00:10:04.000 --> 00:10:15.000
Vì vậy, để xem địa chỉ backtrace từ nhật ký sự cố tương ứng với những gì trong tệp, tôi có thể trừ 0x45c000 khỏi nó để lấy địa chỉ trên đĩa.

00:10:15.000 --> 00:10:21.000
Vì địa chỉ này hiện là một phần của không gian địa chỉ trên đĩa, tôi có thể kiểm tra ứng dụng của mình để xem những gì nằm ở đó.

00:10:21.000 --> 00:10:31.000
Nhật ký sự cố cho tôi biết rằng một luồng bị lỗi trong khi thực hiện bất kỳ thứ gì tại địa chỉ này, vì vậy chúng ta có thể sử dụng lại `otool` để xem hướng dẫn có vấn đề.

00:10:31.000 --> 00:10:37.000
Lần này, tôi đã chỉ định cờ `-tV` cho `otool`, cờ này sẽ in phần tháo gỡ.

00:10:37.000 --> 00:10:41.000
Lưu ý rằng tôi cũng đang chỉ định kiến trúc là arm64.

00:10:41.000 --> 00:10:48.000
Điều này là để otool biết tiêu đề và phân đoạn Mach-O nào cần xem xét vì ứng dụng được xây dựng dưới dạng Universal 2.

00:10:48.000 --> 00:10:52.000
Đầu ra của `otool` hiển thị một hướng dẫn `brk` tại địa chỉ.

00:10:52.000 --> 00:10:56.000
`brk` báo hiệu một ngoại lệ hoặc một vấn đề trong ứng dụng.

00:10:56.000 --> 00:11:03.000
Các công cụ như `atos` cũng tính toán slide ASLR bằng cách sử dụng cùng một kỹ thuật mà chúng tôi đã trải qua cùng nhau.

00:11:03.000 --> 00:11:11.000
`atos` sẽ đọc các lệnh tải cho tệp được chỉ định bởi cờ `-o` và chúng tôi cho nó biết về địa chỉ tải với cờ `-l`.

00:11:11.000 --> 00:11:16.000
Như tôi đã đề cập, `vmmap` cũng có thể cho chúng ta biết về địa chỉ tải của một ứng dụng đang chạy.

00:11:16.000 --> 00:11:24.000
Hãy thử tính toán này một lần nữa, nhưng lần này chúng ta sẽ sử dụng `vmmap` thay vì danh sách hình ảnh nhị phân để xác định slide ASLR.

00:11:24.000 --> 00:11:31.000
Tôi đã chạy lại chương trình MagicNumbers và nhận được địa chỉ tải phân đoạn `__TEXT` trước khi chương trình gặp sự cố.

00:11:31.000 --> 00:11:38.000
Sử dụng công thức trước đó, tôi có thể xác định rằng lần này giá trị slide ASLR là 0x104d14000.

00:11:38.000 --> 00:11:43.000
Một lần nữa, để quay lại tệp, tôi cần trừ đi giá trị slide ASLR.

00:11:43.000 --> 00:11:52.000
Nếu tôi trừ 0x104d14000 từ mục nhập trên cùng trong nhật ký sự cố mới, tôi sẽ nhận được địa chỉ tệp chính xác như trước đây.

00:11:52.000 --> 00:12:00.000
Và điều này không phải ngẫu nhiên; hạt nhân chỉ chọn một giá trị ASLR khác nên địa chỉ tải của chúng tôi đã thay đổi giữa các bản ghi sự cố.

00:12:00.000 --> 00:12:06.000
Tuy nhiên, chúng tôi vẫn có thể xác định địa chỉ tệp chịu trách nhiệm cho sự cố.

00:12:06.000 --> 00:12:16.000
Điều quan trọng ở đây là chúng tôi có một cơ chế để hiểu chính xác những gì ứng dụng của chúng tôi đang làm ở cấp độ hướng dẫn, bất kể địa chỉ thời gian chạy của nó.

00:12:16.000 --> 00:12:24.000
Và với ánh xạ đó, sau đó chúng ta có thể tham khảo thông tin gỡ lỗi của mình để biết mã nguồn được biên dịch theo các hướng dẫn đó.

00:12:24.000 --> 00:12:30.000
Trước khi chúng tôi tiếp tục, tôi muốn trình bày một bản tóm tắt về những gì chúng tôi đã đề cập và các công cụ chúng tôi đã sử dụng.

00:12:30.000 --> 00:12:33.000
Các tệp nhị phân và khuôn khổ ứng dụng là các tệp Mach-O.

00:12:33.000 --> 00:12:37.000
Điều này có nghĩa là họ có nội dung liên quan trong các phân đoạn khác nhau của họ.

00:12:37.000 --> 00:12:40.000
Các phân đoạn này được tạo bởi trình liên kết.

00:12:40.000 --> 00:12:45.000
Các lệnh tải tiêu đề Mach-O mô tả các thuộc tính của các phân đoạn đó, bao gồm một địa chỉ.

00:12:45.000 --> 00:12:50.000
Chúng tôi đã sử dụng `otool` với cờ `-l` để in ra các lệnh tải.

00:12:50.000 --> 00:12:57.000
Tiếp theo, chúng tôi biết rằng hạt nhân thêm một giá trị ngẫu nhiên, được gọi là slide ASLR, vào các địa chỉ liên kết.

00:12:57.000 --> 00:13:02.000
Việc bổ sung slide ASLR và địa chỉ liên kết được gọi là địa chỉ tải.

00:13:02.000 --> 00:13:12.000
Chúng ta có thể kiểm tra danh sách hình ảnh nhị phân trong nhật ký sự cố để xem địa chỉ tải trong trường hợp xảy ra sự cố hoặc chúng ta có thể sử dụng `vmmap` để xem địa chỉ tải cho một ứng dụng đang chạy.

00:13:12.000 --> 00:13:19.000
Cuối cùng, chúng tôi đã xem qua một số ví dụ về tính toán trang chiếu ASLR để quay lại không gian địa chỉ tệp.

00:13:19.000 --> 00:13:26.000
Bây giờ chúng ta có thể thảo luận về thông tin gỡ lỗi, trong đó có các liên kết quan trọng giữa địa chỉ tệp và mã nguồn.

00:13:26.000 --> 00:13:35.000
Xcode tạo thông tin gỡ lỗi khi bạn xây dựng ứng dụng của mình và sẽ nhúng nó trực tiếp vào các tệp nhị phân ứng dụng của bạn hoặc lưu trữ nó dưới dạng một tệp riêng biệt, chẳng hạn như dSYM.

00:13:35.000 --> 00:13:39.000
Có một vài danh mục hoặc loại thông tin gỡ lỗi.

00:13:39.000 --> 00:13:43.000
Mỗi người cung cấp một mức độ chi tiết khác nhau cho một địa chỉ tệp nhất định.

00:13:43.000 --> 00:13:47.000
Hôm nay chúng ta sẽ xem xét ba loại thông tin gỡ lỗi khác nhau.

00:13:47.000 --> 00:13:54.000
Đầu tiên, chúng ta sẽ đề cập đến hàm bắt đầu, bản thân nó không thêm quá nhiều giá trị, nhưng nó là một điểm khởi đầu phổ biến.

00:13:54.000 --> 00:13:58.000
Tiếp theo chúng ta sẽ thấy các bảng ký hiệu nlist, thêm tên hàm và phương thức.

00:13:58.000 --> 00:14:03.000
Cuối cùng, chúng ta sẽ xem xét DWARF, xuất phát từ dSYMs và các thư viện tĩnh.

00:14:03.000 --> 00:14:09.000
DWARF bổ sung nhiều chi tiết nhất, bao gồm tên tệp, số dòng và bản ghi tối ưu hóa.

00:14:09.000 --> 00:14:16.000
Vì DWARF cung cấp nhiều chi tiết nhất, chúng tôi thực sự muốn cố gắng có loại thông tin gỡ lỗi này bất cứ khi nào có thể.

00:14:16.000 --> 00:14:21.000
Chúng ta sẽ tìm hiểu về từng thứ này và cách chúng có thể được sử dụng để xây dựng nhật ký sự cố mang tính biểu tượng đầy đủ.

00:14:21.000 --> 00:14:24.000
Hãy bắt đầu với chức năng bắt đầu.

00:14:24.000 --> 00:14:29.000
Như chúng ta đã thấy trong bảng, chức năng bắt đầu cung cấp ít chi tiết mã nguồn nhất.

00:14:29.000 --> 00:14:38.000
Cũng đúng với tên của nó, loại thông tin gỡ lỗi này chỉ cho chúng ta biết về địa chỉ đầu tiên - hoặc bắt đầu theo nghĩa đen - của các chức năng của chúng ta.

00:14:38.000 --> 00:14:44.000
Ví dụ, điều này sẽ cho chúng ta biết rằng một hàm bắt đầu và tồn tại tại một địa chỉ nhất định.

00:14:44.000 --> 00:14:51.000
Tuy nhiên, nó không cho chúng ta biết chức năng nào bắt đầu từ những địa chỉ đó, chỉ có điều chúng tồn tại.

00:14:51.000 --> 00:14:57.000
Chức năng bắt đầu gỡ lỗi thông tin thực hiện điều này bằng cách mã hóa danh sách các địa chỉ trong phân đoạn `__LINKEDIT` của ứng dụng của bạn.

00:14:57.000 --> 00:15:07.000
Vì cái này được nhúng trực tiếp vào ứng dụng của bạn, tiêu đề Mach-O cũng có lệnh tải để thông báo cho chúng tôi nơi chúng tôi có thể tìm thấy nó, đó là `LC_FUNCTION_STARTS`.

00:15:07.000 --> 00:15:13.000
Bạn có thể tự mình xem những thứ này bằng lệnh `symbols` và cờ `-onlyFuncStartsData`.

00:15:13.000 --> 00:15:17.000
Ở đây chúng tôi lấy lại danh sách các địa chỉ và trình giữ chỗ rỗng.

00:15:17.000 --> 00:15:24.000
Những trình giữ chỗ này lý tưởng sẽ có tên hàm và phương thức thay vì null, nhưng hàm bắt đầu dữ liệu không cung cấp tên.

00:15:24.000 --> 00:15:28.000
Một lần nữa, đây không phải là dữ liệu mô tả nhiều nhất.

00:15:28.000 --> 00:15:32.000
Tuy nhiên, nó cho phép cập nhật nhẹ nhật ký sự cố.

00:15:32.000 --> 00:15:35.000
Bây giờ chúng ta có thể xem các địa chỉ tệp dưới dạng phần bù từ một hàm.

00:15:35.000 --> 00:15:43.000
Ví dụ, trước tiên chúng ta quay lại tệp bằng cách trừ đi giá trị slide ASLR.

00:15:43.000 --> 00:15:48.000
Sau đó, chúng tôi tìm thấy giá trị bắt đầu hàm có thể chứa địa chỉ tệp.

00:15:48.000 --> 00:15:56.000
Trong trường hợp này, chỉ có giá trị đầu tiên mới có thể chứa địa chỉ vì tất cả các giá trị khác đều lớn hơn địa chỉ.

00:15:56.000 --> 00:16:04.000
Cuối cùng, chúng tôi có thể khẳng định rằng địa chỉ tệp của chúng tôi thực sự là 264 byte trong chức năng này.

00:16:04.000 --> 00:16:11.000
Điều này chủ yếu hữu ích cho những người gỡ lỗi, vì họ có thể hiểu chi tiết về cách chức năng này được thiết lập và thanh ghi nào đã được sửa đổi.

00:16:11.000 --> 00:16:21.000
Tuy nhiên, điều này có ý nghĩa đối với bạn là nếu bạn gặp nhật ký sự cố thiếu tên hàm, có lẽ bạn đang xử lý thông tin gỡ lỗi ở mức thấp nhất này.

00:16:21.000 --> 00:16:29.000
Đây là tin tốt vì nó có nghĩa là có rất nhiều cơ hội để làm phong phú nhật ký sự cố với thông tin gỡ lỗi tốt hơn.

00:16:29.000 --> 00:16:34.000
Đương nhiên, cấp độ chi tiết tiếp theo mà chúng tôi muốn thấy là tên hàm.

00:16:34.000 --> 00:16:43.000
Điều này mang lại cho chúng tôi cơ hội thực sự đầu tiên để lấy nhật ký sự cố hoặc dấu vết của Công cụ và sử dụng nó để theo dõi sự cố trong mã nguồn của chúng tôi.

00:16:43.000 --> 00:16:46.000
Điều này dẫn chúng ta đến các bảng biểu tượng nlist.

00:16:46.000 --> 00:16:55.000
Các bảng ký hiệu được xây dựng dựa trên ý tưởng bắt đầu hàm và cũng mã hóa danh sách thông tin trong phân đoạn `__LINKEDIT` và cũng có lệnh tải riêng.

00:16:55.000 --> 00:17:00.000
Tuy nhiên, thay vì chỉ mã hóa địa chỉ, chúng mã hóa các cấu trúc C.

00:17:00.000 --> 00:17:06.000
Điều này cho phép chúng tôi thêm nhiều chi tiết hơn cho bất kỳ mục nhập nhất định nào so với chức năng bắt đầu.

00:17:06.000 --> 00:17:10.000
Cụ thể, họ mã hóa cấu trúc `nlist_64`.

00:17:10.000 --> 00:17:13.000
Ở đây chúng ta có định nghĩa của cấu trúc đó.

00:17:13.000 --> 00:17:18.000
Một cái nhìn lướt qua cho thấy rằng chúng ta có quyền truy cập vào một tên và một số thuộc tính.

00:17:18.000 --> 00:17:24.000
Các giá trị của các trường cấu trúc này được xác định bởi `n_type` của nlist.

00:17:24.000 --> 00:17:30.000
Có ba loại n_ chính mà chúng tôi quan tâm, nhưng hiện tại chúng tôi sẽ chỉ tập trung vào hai.

00:17:30.000 --> 00:17:33.000
Cái đầu tiên được gọi là biểu tượng trực tiếp.

00:17:33.000 --> 00:17:38.000
Đây là những chức năng và phương pháp mà bạn đã xác định đầy đủ trong các ứng dụng và khuôn khổ của mình.

00:17:38.000 --> 00:17:43.000
Các ký hiệu trực tiếp có tên và địa chỉ trong cấu trúc `nlist_64`.

00:17:43.000 --> 00:17:49.000
Ngoài ra, chúng được biểu diễn bằng một mẫu bit cụ thể trong trường `n_type`.

00:17:49.000 --> 00:17:55.000
Cụ thể, `n_type` sẽ có bộ bit ít quan trọng thứ hai, thứ ba và thứ tư.

00:17:55.000 --> 00:17:59.000
Những bit này còn được gọi là `N_SECT`.

00:17:59.000 --> 00:18:05.000
Chúng ta có thể thấy những thứ này với `nm` và chỉ định cờ `-defined-only` và `--numeric-sort`.

00:18:05.000 --> 00:18:13.000
Ở đây, `nm` đã xem qua các biểu tượng được xác định của chương trình MagicNumbers và liệt kê chúng theo thứ tự địa chỉ.

00:18:13.000 --> 00:18:16.000
Những cái tên chúng tôi lấy lại có vẻ khó hiểu.

00:18:16.000 --> 00:18:20.000
Đó là bởi vì những cái tên thực sự được lưu trữ trong các bảng biểu tượng là những cái tên bị xáo trộn.

00:18:20.000 --> 00:18:29.000
Những cái tên bị xáo trộn này giúp trình biên dịch và trình liên kết xác định duy nhất một hàm, nhưng chúng không dễ hiểu trừ khi chúng bị gỡ rối.

00:18:29.000 --> 00:18:34.000
Để có được một phiên bản thân thiện hơn của những cái tên này, tôi đã chuyển đầu ra cho `swift-demangle`.

00:18:34.000 --> 00:18:41.000
Bây giờ chúng tôi nhận được một số tên quen thuộc, chẳng hạn như `main` và `numberChoices`, bởi vì chúng được xác định trực tiếp trong ứng dụng của tôi.

00:18:41.000 --> 00:18:49.000
Tương tự, công cụ `symbols` có một tùy chọn để hiển thị dữ liệu nlist và nó cũng tự động gỡ rối các tên.

00:18:49.000 --> 00:18:55.000
Bây giờ chúng ta có thể liên kết tên hàm với một địa chỉ, điều này cho phép chúng ta cập nhật nhật ký sự cố một lần nữa.

00:18:55.000 --> 00:19:05.000
Ở đây chúng ta có thể quan sát thấy rằng biểu thức bù đắp mà chúng ta nhận được từ dữ liệu bắt đầu hàm cũng khớp với một mục nhập từ các ký hiệu trực tiếp và mục nhập đó có tên.

00:19:05.000 --> 00:19:11.000
Kết hợp hai thứ này lại với nhau, bây giờ chúng ta có thể nói rằng sự cố của chúng ta đã xảy ra ở mức 264 byte vào chính.

00:19:11.000 --> 00:19:18.000
Điều này vẫn để lại một số chi tiết mong muốn, vì chúng tôi biết một thực tế rằng main không phải là chức năng duy nhất liên quan.

00:19:18.000 --> 00:19:21.000
Và nó cũng sẽ giúp có một số dòng chính xác.

00:19:21.000 --> 00:19:29.000
Chúng tôi đã gặp phải một cái gì đó tương tự như thế này trong ví dụ theo dõi Công cụ - chúng tôi có sẵn một số tên hàm, nhưng nó đã bỏ lỡ những tên khác.

00:19:29.000 --> 00:19:36.000
Một lý do cho điều này là bảng biểu tượng chỉ có các mục nhập biểu tượng trực tiếp cho các chức năng liên quan đến liên kết.

00:19:36.000 --> 00:19:42.000
Đây là những chức năng mà bạn sử dụng trên các mô-đun hoặc chức năng mà bạn xuất từ các khuôn khổ của mình.

00:19:42.000 --> 00:19:46.000
Điều này làm cho nó hữu ích cho việc xác định ranh giới API.

00:19:46.000 --> 00:19:54.000
Và nó cũng có nghĩa là nó có dữ liệu cần thiết để cung cấp năng lượng tải động với các chức năng như `dlsym()` và `dladdr()`.

00:19:54.000 --> 00:20:03.000
Tuy nhiên, một nhược điểm là các hàm cục bộ hoặc tĩnh không được biểu diễn trong bảng ký hiệu vì chúng không được tham chiếu bên ngoài mô-đun của chúng.

00:20:03.000 --> 00:20:09.000
Điều này cuối cùng bỏ qua các chức năng triển khai nơi chúng ta có thể có một phần đáng kể của logic ứng dụng.

00:20:09.000 --> 00:20:14.000
Hơn nữa, thông thường các tệp nhị phân được xây dựng ở chế độ Phát hành để loại bỏ bảng biểu tượng của chúng.

00:20:14.000 --> 00:20:21.000
Điều này có nghĩa là các mục nhập không cần thiết sẽ bị xóa khỏi bảng biểu tượng, giúp giảm kích thước ứng dụng của bạn.

00:20:21.000 --> 00:20:32.000
Nếu chúng ta nghĩ về nó, việc trình điều khiển chính của ứng dụng của chúng ta xuất chức năng ở bất cứ đâu là không phổ biến, vì vậy chúng ta sẽ lãng phí không gian để giữ các mục nhập bảng biểu tượng đó xung quanh.

00:20:32.000 --> 00:20:44.000
Đối với các khuôn khổ và thư viện của chúng tôi, chúng tôi chắc chắn đã xuất các chức năng mà khách hàng nên sử dụng, nhưng không cần phải giữ các chức năng được chia sẻ cục bộ vì chúng không thể được sử dụng ở bất kỳ nơi nào khác.

00:20:44.000 --> 00:20:50.000
Việc loại bỏ các tệp thực thi ứng dụng chính của chúng tôi hầu như sẽ luôn để trống bảng biểu tượng.

00:20:50.000 --> 00:20:54.000
Việc loại bỏ các khuôn khổ và thư viện của chúng tôi chỉ để lại các chức năng đã xuất.

00:20:54.000 --> 00:21:02.000
Bạn có thể đã bắt gặp các cài đặt xây dựng trong Xcode như Sản phẩm được liên kết dải, Kiểu dải và Biểu tượng dải Swift.

00:21:02.000 --> 00:21:06.000
Các cài đặt xây dựng này kiểm soát cách ứng dụng của bạn bị loại bỏ trong quá trình xây dựng.

00:21:06.000 --> 00:21:12.000
Nếu Sản phẩm Liên kết Dải được bật, thì nhị phân sẽ bị tước theo Kiểu Dải.

00:21:12.000 --> 00:21:19.000
Ví dụ, Tất cả các Biểu tượng sẽ thực hiện loại bỏ xâm lấn nhất và chỉ để lại những yếu tố cần thiết.

00:21:19.000 --> 00:21:28.000
Non Globals loại bỏ các biểu tượng trực tiếp được sử dụng trong các mô-đun khác nhau của ứng dụng của bạn nhưng không được xuất để sử dụng trong các ứng dụng khác.

00:21:28.000 --> 00:21:35.000
Biểu tượng gỡ lỗi loại bỏ loại thứ ba của loại nlist mà chúng ta sẽ thảo luận sau khi chúng ta đến DWARF.

00:21:35.000 --> 00:21:39.000
Tuy nhiên, phong cách dải này vẫn giữ được các biểu tượng trực tiếp.

00:21:39.000 --> 00:21:46.000
Ví dụ, ở đây tôi có một khuôn khổ xác định hai giao diện công khai và một chức năng triển khai được chia sẻ nội bộ.

00:21:46.000 --> 00:21:52.000
Vì tất cả các chức năng này đóng một vai trò trong việc liên kết, tất cả chúng đều có các mục nhập biểu tượng trực tiếp.

00:21:52.000 --> 00:21:56.000
Nếu tôi loại bỏ các giao diện không toàn cầu, thì tôi chỉ còn lại với các giao diện của mình.

00:21:56.000 --> 00:22:02.000
Chức năng triển khai được chia sẻ chỉ được sử dụng trong khuôn khổ của tôi, vì vậy nó không được coi là toàn cầu.

00:22:02.000 --> 00:22:10.000
Tương tự, việc loại bỏ tất cả các biểu tượng vẫn rời khỏi giao diện vì những điều này được yêu cầu cho các ứng dụng khác để sử dụng khung.

00:22:10.000 --> 00:22:19.000
Bạn cũng có thể nhận thấy trong đầu ra `symbols --onlyNListData` rằng có các địa chỉ bắt đầu hàm xen kẽ giữa các ký hiệu trực tiếp.

00:22:19.000 --> 00:22:25.000
Những địa chỉ này đại diện cho các chức năng không bao giờ có trong các ký hiệu trực tiếp hoặc đã bị tước bỏ.

00:22:25.000 --> 00:22:30.000
Bạn có thể điều chỉnh các cài đặt dải này theo mức độ hiển thị bảng biểu tượng mong muốn của mình.

00:22:30.000 --> 00:22:34.000
Với thông tin này, chúng tôi có thể xác định khi nào chúng tôi làm việc với các biểu tượng trực tiếp.

00:22:34.000 --> 00:22:46.000
Một số dấu hiệu nhận biết về điều này là có tên hàm nhưng không có số dòng hoặc tên tệp; hoặc có sự kết hợp giữa tên hàm và địa chỉ bắt đầu hàm, như chúng ta có ở đây với ví dụ khung.

00:22:46.000 --> 00:22:54.000
Loại cấu trúc nlist thứ hai mà chúng ta sẽ phân tích được gọi là biểu tượng gián tiếp, trái ngược với biểu tượng trực tiếp.

00:22:54.000 --> 00:22:59.000
Đây là khi `n_type` chỉ khớp với mẫu bit `N_EXT`.

00:22:59.000 --> 00:23:05.000
Đây là các hàm và phương thức mà bạn đang sử dụng từ các khung hoặc thư viện khác, chẳng hạn như `print()`.

00:23:05.000 --> 00:23:12.000
Bạn có thể thấy những thứ này với `nm`, chỉ lần này chúng tôi sẽ chỉ định `--chỉ không xác định` thay vì `--chỉ xác định`.

00:23:12.000 --> 00:23:19.000
Chúng tôi cũng sẽ thêm cờ `-m`, cờ này sẽ cho bạn thấy các khung hoặc thư viện mà các chức năng nên được tìm thấy trong đó.

00:23:19.000 --> 00:23:27.000
Ví dụ, ứng dụng MagicNumbers phụ thuộc vào nhiều chức năng Swift được xác định trong libswiftCore.

00:23:27.000 --> 00:23:34.000
Bây giờ chúng tôi đã đề cập đến hai trong số ba danh mục thông tin gỡ lỗi, hãy đảm bảo rằng chúng tôi hiểu các thuộc tính của chúng.

00:23:34.000 --> 00:23:41.000
Chức năng bắt đầu là một danh sách các địa chỉ, vì vậy chúng thiếu tên, nhưng cho phép chúng tôi xác định độ lệch.

00:23:41.000 --> 00:23:48.000
Các bảng ký hiệu nlist mã hóa toàn bộ cấu trúc thông tin và có thể liên kết tên với một địa chỉ.

00:23:48.000 --> 00:23:55.000
Chúng mô tả các biểu tượng trực tiếp - được xác định trong ứng dụng của bạn - và các biểu tượng gián tiếp, được cung cấp bởi các phụ thuộc.

00:23:55.000 --> 00:24:03.000
Các biểu tượng trực tiếp thường được dành riêng cho các chức năng liên quan đến liên kết và cài đặt xây dựng dải ảnh hưởng đến các biểu tượng trực tiếp nào có sẵn.

00:24:03.000 --> 00:24:10.000
Cuối cùng, cả chức năng bắt đầu và bảng biểu tượng nlist đều được nhúng trực tiếp vào ứng dụng của bạn.

00:24:10.000 --> 00:24:16.000
Những gì chúng ta chưa thấy là mức độ chi tiết phong phú hơn, chẳng hạn như tên tệp và số dòng.

00:24:16.000 --> 00:24:18.000
Cái này được cung cấp cho chúng tôi bởi DWARF.

00:24:18.000 --> 00:24:23.000
DWARF đưa các khái niệm về bảng biểu tượng nlist lên một cấp độ hoàn toàn khác.

00:24:23.000 --> 00:24:29.000
Thay vì chỉ giữ lại một tập hợp con các chức năng, DWARF cố gắng mô tả mọi thứ.

00:24:29.000 --> 00:24:35.000
Chúng tôi thấy rằng các bảng biểu tượng nlist đã bổ sung rất nhiều thông tin so với hàm bắt đầu.

00:24:35.000 --> 00:24:37.000
Nó đã hoàn thành điều đó bằng cách thêm một chiều.

00:24:37.000 --> 00:24:44.000
Hãy nhớ rằng, chúng ta bắt đầu chỉ với một chiều duy nhất, đó là địa chỉ, khi chúng ta nhìn vào hàm bắt đầu.

00:24:44.000 --> 00:24:51.000
Sau đó, chúng tôi đã nâng cấp lên hai chiều bằng cách mã hóa một cấu trúc đầy đủ thông tin trong bảng ký hiệu nlist.

00:24:51.000 --> 00:24:54.000
DWARF thêm một chiều thứ ba, đó là về các mối quan hệ.

00:24:54.000 --> 00:24:58.000
DWARF nhận ra rằng các chức năng không bị cô lập.

00:24:58.000 --> 00:25:05.000
Chúng gọi các hàm khác, chúng có các tham số, trả về dữ liệu có ý nghĩa và được xác định trong một tệp cụ thể.

00:25:05.000 --> 00:25:10.000
Mã hóa các mối quan hệ này mở ra các khía cạnh mạnh mẽ nhất của biểu tượng.

00:25:10.000 --> 00:25:15.000
Khi chúng tôi phân tích DWARF, chúng tôi chủ yếu đề cập đến một gói dSYM.

00:25:15.000 --> 00:25:22.000
Ngoài các siêu dữ liệu khác như plists, gói dSYM chứa một tệp nhị phân với DWARF.

00:25:22.000 --> 00:25:24.000
Điều gì khiến hệ nhị phân này trở nên đặc biệt?

00:25:24.000 --> 00:25:29.000
Hệ nhị phân chứa dữ liệu của nó trong một phân đoạn `__DWARF` đặc biệt.

00:25:29.000 --> 00:25:35.000
Thông số kỹ thuật của DWARF đề cập đến ba luồng dữ liệu trong phân khúc mà chúng tôi sẽ tập trung vào.

00:25:35.000 --> 00:25:45.000
`debug_info` chứa dữ liệu thô, `debug_abbrev` gán cấu trúc cho dữ liệu và `debug_line` chứa tên tệp và số dòng.

00:25:45.000 --> 00:25:51.000
DWARF cũng định nghĩa hai loại từ vựng mà chúng ta sẽ nghiên cứu đầu tiên: đơn vị biên dịch và chương trình con.

00:25:51.000 --> 00:25:54.000
Chúng tôi sẽ giới thiệu cái thứ ba sau.

00:25:54.000 --> 00:26:00.000
Một đơn vị biên dịch đại diện cho một tệp nguồn duy nhất đã đi vào việc xây dựng sản phẩm.

00:26:00.000 --> 00:26:06.000
Ví dụ, chúng tôi có thể mong đợi có một đơn vị biên dịch cho mỗi tệp Swift trong dự án của chúng tôi.

00:26:06.000 --> 00:26:16.000
DWARF gán các thuộc tính cho một đơn vị biên dịch, chẳng hạn như tên của tệp, SDK, phần của phân đoạn `__TEXT` mà các chức năng của nó chiếm và hơn thế nữa.

00:26:16.000 --> 00:26:29.000
Đơn vị biên dịch main.swift chứa các thuộc tính này trong luồng `debug_info` ở bên trái và nó có một mục nhập tương ứng trong luồng `debug _abbrev` ở bên phải cho chúng ta biết các giá trị đại diện cho điều gì.

00:26:29.000 --> 00:26:37.000
Ở đây chúng ta thấy tên tệp, ngôn ngữ được viết và một cặp thấp/cao đại diện cho phạm vi phân đoạn `__TEXT`.

00:26:37.000 --> 00:26:40.000
Một chương trình con đại diện cho một hàm được xác định.

00:26:40.000 --> 00:26:48.000
Chúng tôi đã thấy các hàm được xác định trong bảng ký hiệu nlist, nhưng chương trình con cũng có thể mô tả các hàm tĩnh và cục bộ.

00:26:48.000 --> 00:26:53.000
Một chương trình con cũng có tên và phạm vi địa chỉ phân đoạn `__TEXT` của nó.

00:26:53.000 --> 00:27:02.000
Một mối quan hệ cơ bản giữa các đơn vị biên dịch và các chương trình con là các chương trình con được xác định trong một đơn vị biên dịch.

00:27:02.000 --> 00:27:05.000
DWARF đại diện cho điều này bằng một cái cây.

00:27:05.000 --> 00:27:11.000
Đơn vị biên dịch nằm ở gốc của cây và nó có các mục nhập chương trình con khi còn nhỏ.

00:27:11.000 --> 00:27:15.000
Những đứa trẻ có thể tìm kiếm bằng cách theo dõi phạm vi địa chỉ của chúng.

00:27:15.000 --> 00:27:19.000
Chúng ta có thể kiểm tra những điều này chi tiết hơn bằng lệnh `dwarfdump`.

00:27:19.000 --> 00:27:21.000
Đầu tiên chúng ta sẽ xem xét một đơn vị biên dịch.

00:27:21.000 --> 00:27:25.000
Điều này khớp với một số thuộc tính của một đơn vị biên dịch mà tôi đã đề cập trước đó.

00:27:25.000 --> 00:27:35.000
`dwarfdump` kết hợp hữu ích nội dung `debug_ info` và `debug _abbrev` để hiển thị cho bạn cấu trúc và nội dung của dữ liệu trong dSYMs của bạn.

00:27:35.000 --> 00:27:40.000
Và nếu chúng ta cuộn xuống đầu ra, chúng ta sẽ gặp một chương trình con.

00:27:40.000 --> 00:27:47.000
Phạm vi địa chỉ mà nó chiếm nằm trong giới hạn của đơn vị biên dịch và chúng ta cũng có thể thấy tên của hàm.

00:27:47.000 --> 00:27:50.000
Tôi đã đề cập rằng DWARF mô tả dữ liệu của nó cực kỳ chi tiết.

00:27:50.000 --> 00:27:56.000
Mặc dù chúng ta sẽ không dành nhiều thời gian cho tất cả các chi tiết này, nhưng tôi nghĩ thật thú vị khi thấy các chi tiết như các tham số hàm.

00:27:56.000 --> 00:28:02.000
Họ có loại từ vựng riêng mô tả tên và loại tham số.

00:28:02.000 --> 00:28:07.000
Theo mô hình cây, một tham số là con của một chương trình con.

00:28:07.000 --> 00:28:12.000
Ở đây chúng ta bắt gặp mục nhập cho tham số lựa chọn mà chúng ta cung cấp cho một hàm.

00:28:12.000 --> 00:28:17.000
Tiếp theo, tên tệp và số dòng đến từ luồng `debug_line`.

00:28:17.000 --> 00:28:19.000
Dòng suối này không có cấu trúc cây.

00:28:19.000 --> 00:28:27.000
Thay vào đó, nó định nghĩa một chương trình bảng dòng trong đó các địa chỉ tệp riêng lẻ có thể được ánh xạ trở lại một dòng mã chính xác.

00:28:27.000 --> 00:28:33.000
Điều này cuối cùng tạo ra một danh sách các chi tiết mã nguồn mà chúng ta có thể tìm kiếm để tìm tệp và dòng.

00:28:33.000 --> 00:28:41.000
Nếu chúng ta phân tích cú pháp cây `debug_info` và tạo danh sách `debug_line`, chúng ta sẽ kết thúc với một cấu trúc như sau.

00:28:41.000 --> 00:28:45.000
Vì vậy, nếu muốn khớp với một địa chỉ tệp, chúng ta có thể đi qua cây.

00:28:45.000 --> 00:28:49.000
Đầu tiên, chúng ta sẽ bắt đầu từ đơn vị biên dịch và theo dõi các nhánh.

00:28:49.000 --> 00:28:53.000
Sau đó, chúng tôi sẽ chọn bất kỳ mục nhập `debug_line` nào khớp.

00:28:53.000 --> 00:29:01.000
Chúng ta có thể tự động hóa điều này một lần nữa với `atos`, chỉ lần này tôi đặc biệt bỏ cờ `-i`.

00:29:01.000 --> 00:29:03.000
Chú ý bất cứ điều gì hơi kỳ lạ ở đây?

00:29:03.000 --> 00:29:08.000
Vâng, chúng tôi có tên hàm và số dòng, vì vậy chúng tôi chắc chắn đang sử dụng DWARF.

00:29:08.000 --> 00:29:13.000
Tuy nhiên, ngoài điều này không quá khác biệt so với bản cập nhật bảng biểu tượng nlist.

00:29:13.000 --> 00:29:22.000
Trên thực tế, khi chúng tôi so sánh nó với lần đầu tiên chúng tôi sử dụng `atos`, có vẻ như chúng tôi vẫn đang thiếu rất nhiều chức năng và chi tiết có giá trị!

00:29:22.000 --> 00:29:24.000
Chuyện gì đã xảy ra ở đây vậy?

00:29:24.000 --> 00:29:30.000
Điều duy nhất thay đổi là lần này chúng tôi đã không chỉ định `-i` cho `atos`.

00:29:30.000 --> 00:29:34.000
Lá cờ đó là viết tắt của "các chức năng nội tuyến."

00:29:34.000 --> 00:29:38.000
Inlining là một tối ưu hóa thông thường mà trình biên dịch thực hiện.

00:29:38.000 --> 00:29:43.000
Điều này liên quan đến việc thay thế trực tiếp một cuộc gọi hàm bằng phần thân của hàm.

00:29:43.000 --> 00:29:47.000
Một hiệu ứng thú vị mà nó có là làm cho mã dường như biến mất.

00:29:47.000 --> 00:29:55.000
Chúng ta có thể nghĩ về nó vì, thay vì gọi `numberChoices()`, toàn bộ mã cho `numberChoices()` đã bị bỏ vào vị trí.

00:29:55.000 --> 00:30:00.000
Đột nhiên không còn lệnh gọi hàm nào đến `numberChoices()` nữa!

00:30:00.000 --> 00:30:03.000
DWARF đại diện cho điều này với một chương trình con nội tuyến.

00:30:03.000 --> 00:30:07.000
Đây là loại từ vựng thứ ba và cuối cùng cho DWARF mà chúng ta sẽ thảo luận hôm nay.

00:30:07.000 --> 00:30:15.000
Một chương trình con nội tuyến là một chương trình con - vì vậy nó là một hàm - được nội tuyến vào một chương trình con khác.

00:30:15.000 --> 00:30:24.000
Vì một hàm nội tuyến hoàn toàn bị nhấn chìm bởi một nút khác trong cây mối quan hệ, chương trình con nội tuyến là con của nút đó.

00:30:24.000 --> 00:30:32.000
Định nghĩa này cũng áp dụng đệ quy, có nghĩa là một chương trình con nội tuyến có thể có những đứa trẻ nội tuyến khác.

00:30:32.000 --> 00:30:36.000
Một lần nữa, với `dwarfdump`, chúng ta có thể tìm kiếm các chương trình con nội tuyến.

00:30:36.000 --> 00:30:42.000
Chúng được liệt kê là con của các nút khác và có các thuộc tính tương tự như các chương trình con, chẳng hạn như tên và địa chỉ.

00:30:42.000 --> 00:30:50.000
Tuy nhiên, trong DWARF, các thuộc tính này thường được truy cập thông qua một nút chung, được gọi là nguồn gốc trừu tượng.

00:30:50.000 --> 00:31:00.000
Nếu có nhiều bản sao nội tuyến của một hàm cụ thể, thì các thuộc tính chung, được chia sẻ của chúng được giữ trong nguồn gốc trừu tượng để chúng không bị sao chép ở mọi nơi.

00:31:00.000 --> 00:31:05.000
Một thuộc tính duy nhất mà các chương trình con nội tuyến có là một trang web cuộc gọi.

00:31:05.000 --> 00:31:12.000
Đây là vị trí trong mã nguồn của chúng tôi, nơi chúng tôi đã viết lệnh gọi hàm thực tế, nhưng trình tối ưu hóa đã thay thế nó.

00:31:12.000 --> 00:31:18.000
Ví dụ ở đây, chúng tôi đã thực hiện cuộc gọi đến `generateANumber` trên dòng 36 của tệp main.swift.

00:31:18.000 --> 00:31:22.000
Điều này cho phép chúng tôi cập nhật cây của mình với các nút con mới.

00:31:22.000 --> 00:31:27.000
Và bây giờ điều này trông giống như một cái nhìn toàn diện hơn nhiều về chương trình của chúng tôi.

00:31:27.000 --> 00:31:35.000
Các chi tiết tối ưu hóa cho các chức năng nội tuyến là các chi tiết chính trong việc đưa chúng ta đến nhật ký sự cố được tượng trưng hóa hoàn toàn.

00:31:35.000 --> 00:31:41.000
Cờ `-i` cho `atos` hướng dẫn công cụ xem xét chúng trong quá trình biểu tượng hóa.

00:31:41.000 --> 00:31:44.000
Chúng cũng là những chi tiết còn thiếu từ dấu vết Dụng cụ của chúng tôi.

00:31:44.000 --> 00:31:54.000
Lý do tại sao chúng tôi cần một dSYM cho cả Công cụ và nhật ký sự cố chính xác là để chúng tôi có thể trích xuất tất cả nội dung này.

00:31:54.000 --> 00:32:00.000
Có một nguồn khác mà bạn sẽ tìm thấy DWARF, và đó là từ các thư viện tĩnh và các tệp đối tượng.

00:32:00.000 --> 00:32:07.000
Trong trường hợp không có dSYM, bạn vẫn có thể thu thập DWARF cho các hàm mà bạn đã liên kết từ thư viện tĩnh hoặc tệp đối tượng.

00:32:07.000 --> 00:32:12.000
Trong những trường hợp đó, bạn sẽ tìm thấy các loại nlist Biểu tượng gỡ lỗi.

00:32:12.000 --> 00:32:15.000
Đây là một trong những loại biểu tượng có thể bị tước bỏ.

00:32:15.000 --> 00:32:18.000
Tuy nhiên, họ không tự mình giữ DWARF.

00:32:18.000 --> 00:32:22.000
Thay vào đó, họ liên kết một hàm trở lại tệp mà họ đến.

00:32:22.000 --> 00:32:28.000
Nếu thư viện được xây dựng với thông tin gỡ lỗi, thì mục nhập nlist có thể trỏ chúng ta đến DWARF đó.

00:32:28.000 --> 00:32:35.000
Những loại mục nhập nlist này có thể được nhìn thấy chi tiết với `dsymutil -dump-debug-map`.

00:32:35.000 --> 00:32:39.000
Ở đây chúng tôi có danh sách các chức năng khác nhau và nơi chúng được lấy từ.

00:32:39.000 --> 00:32:42.000
Những vị trí đó có thể được quét và xử lý cho DWARF.

00:32:42.000 --> 00:32:47.000
Tóm lại, DWARF là một nguồn quan trọng của dữ liệu biểu tượng chuyên sâu.

00:32:47.000 --> 00:32:52.000
DWARF phơi bày các mối quan hệ quan trọng giữa các chức năng và tệp.

00:32:52.000 --> 00:33:00.000
Các tối ưu hóa như nội tuyến chức năng có tác động rất lớn đến chất lượng biểu tượng và DWARF có thể thể hiện nó rất tốt.

00:33:00.000 --> 00:33:04.000
Chúng tôi cũng thấy rằng dSYM và thư viện tĩnh chứa DWARF.

00:33:04.000 --> 00:33:12.000
Tuy nhiên, vui lòng ưu tiên dSYM vì bạn có thể dễ dàng chuyển chúng cho người khác và có hỗ trợ tích hợp từ một số công cụ.

00:33:12.000 --> 00:33:18.000
Cuối cùng, tôi muốn chia sẻ các công cụ và mẹo khác nhau mà bạn có thể sử dụng để tạo điều kiện tượng trưng.

00:33:18.000 --> 00:33:25.000
Đối với các bản dựng phát triển cục bộ, bạn thường sẽ có rất nhiều thông tin gỡ lỗi nếu bạn xây dựng ở chế độ gỡ lỗi.

00:33:25.000 --> 00:33:32.000
Đối với chế độ phát hành, bạn có thể đảm bảo rằng Xcode tạo ra dSYM bằng cách kiểm tra cài đặt xây dựng Định dạng Thông tin Gỡ lỗi.

00:33:32.000 --> 00:33:36.000
Đảm bảo Bản phát hành được đặt thành DWARF với Tệp dSYM.

00:33:36.000 --> 00:33:41.000
Đối với các ứng dụng đã được gửi đến App Store, bạn có thể tải xuống dSYM của mình thông qua App Store Connect.

00:33:41.000 --> 00:33:45.000
Điều này cũng bao gồm bất kỳ ứng dụng nào có bật mã bit.

00:33:45.000 --> 00:33:51.000
Nếu bạn muốn kiểm tra xem một dSYM nhất định đã có trên thiết bị của mình chưa, bạn có thể sử dụng lệnh `mdfind`.

00:33:51.000 --> 00:33:58.000
Chuỗi chữ và số ở đây là UUID nhị phân của bạn, là một mã định danh duy nhất được xác định trong lệnh tải.

00:33:58.000 --> 00:34:03.000
Bạn có thể xem UUID cho dSYM của mình với `biểu tượng -uuid`.

00:34:03.000 --> 00:34:07.000
Đôi khi, một chuỗi công cụ có thể tạo ra DWARF không hợp lệ.

00:34:07.000 --> 00:34:09.000
Bạn có thể kiểm tra điều này với `dwarfdump -verify`.

00:34:09.000 --> 00:34:13.000
Nếu bạn thấy bất kỳ lỗi nào được báo cáo, vui lòng gửi lỗi!

00:34:13.000 --> 00:34:17.000
Dữ liệu DWARF cũng có giới hạn bốn gigabyte trên mỗi nhị phân.

00:34:17.000 --> 00:34:28.000
Nếu bạn đang gặp sự cố với dSYM của mình và thấy rằng chúng vượt quá bốn gigabyte, hãy cân nhắc chia dự án thành các thành phần riêng biệt để mỗi thành phần có dSYM nhỏ hơn của riêng mình.

00:34:28.000 --> 00:34:36.000
Bạn có thể đảm bảo rằng dSYM bạn đang sử dụng khớp với bản dựng cụ thể của ứng dụng mà bạn quan tâm bằng cách so sánh UUID.

00:34:36.000 --> 00:34:43.000
UUID của ứng dụng nằm trong phần danh sách Hình ảnh nhị phân của các báo cáo sự cố và bạn cũng có thể xem nó bằng lệnh `biểu tượng`.

00:34:43.000 --> 00:34:49.000
Bạn nên đảm bảo rằng cả ứng dụng và dSYM của bạn đều có cùng UUID.

00:34:49.000 --> 00:34:55.000
Công cụ `symbols` cũng cho phép bạn kiểm tra các loại thông tin gỡ lỗi mà ứng dụng của bạn có sẵn.

00:34:55.000 --> 00:35:02.000
Chúng tôi đã thấy các ví dụ về điều này, nhưng đó là một lời nhắc nhở hữu ích rằng các thẻ này trong ngoặc vuông cho bạn biết nguồn thông tin.

00:35:02.000 --> 00:35:07.000
Sẽ rất hữu ích nếu bạn không chắc chắn mình có thể đang xử lý thông tin gỡ lỗi nào.

00:35:07.000 --> 00:35:16.000
Nếu bạn chắc chắn rằng bạn có sẵn dSYM nhưng vẫn không nhận được tên cho các chức năng của mình trong dấu vết Công cụ, vui lòng kiểm tra quyền lợi và ký mã của bạn.

00:35:16.000 --> 00:35:23.000
Cụ thể, với lệnh `codesign`, bạn có thể xác minh rằng bạn có chữ ký mã thích hợp.

00:35:23.000 --> 00:35:28.000
Bạn cũng nên xác minh rằng các ứng dụng được xây dựng cục bộ để phát triển có quyền `get-task-allow`.

00:35:28.000 --> 00:35:34.000
Quyền này cấp quyền cho các công cụ như Công cụ để tượng trưng cho ứng dụng của bạn.

00:35:34.000 --> 00:35:41.000
Xcode nên tự động đặt quyền này với hành động Hồ sơ, nhưng nó rất hữu ích để xác minh.

00:35:41.000 --> 00:35:52.000
Nếu bạn chưa bật quyền `get-task-allow`, bạn nên kiểm tra cài đặt xây dựng Quyền cơ sở tiêm ký mã của mình và đảm bảo rằng nó được bật khi bạn đang phát triển.

00:35:52.000 --> 00:36:00.000
Cuối cùng, đối với các ứng dụng Universal 2, bạn nên chỉ định kiến trúc mà bạn quan tâm cho các công cụ.

00:36:00.000 --> 00:36:07.000
`symbols`, `otool` và `dwarfdump` đều có cờ `-arch` chỉ hoạt động trên một lát kiến trúc cụ thể.

00:36:07.000 --> 00:36:11.000
Điều này kết luận "Biểu tượng: Vượt ra ngoài những điều cơ bản."

00:36:11.000 --> 00:36:15.000
Nếu không có gì khác, tôi muốn thực sự nhấn mạnh một vài điểm chính.

00:36:15.000 --> 00:36:25.000
UUID và địa chỉ tệp là một cách nhất quán và đáng tin cậy để xác định ứng dụng của bạn đang làm gì vì chúng độc lập với slide ASLR.

00:36:25.000 --> 00:36:28.000
Chúng cũng là chìa khóa của chúng tôi để truy vấn thông tin gỡ lỗi.

00:36:28.000 --> 00:36:31.000
Bạn cũng nên sử dụng dSYM bất cứ khi nào có thể.

00:36:31.000 --> 00:36:38.000
dSYMs chứa thông tin gỡ lỗi phong phú nhất dưới dạng DWARF và được hỗ trợ bởi Xcode và Instruments.

00:36:38.000 --> 00:36:42.000
Cuối cùng, chúng tôi đã đề cập đến một số công cụ.

00:36:42.000 --> 00:36:47.000
Những công cụ này có sẵn cho bạn trong Xcode và chúng cung cấp các chẩn đoán và thông tin chi tiết mạnh mẽ.

00:36:47.000 --> 00:36:54.000
Bạn nên cố gắng kết hợp chúng vào quy trình làm việc của mình để gỡ lỗi và tối ưu hóa.

00:36:54.000 --> 00:37:08.000
Nếu bạn quan tâm đến việc tìm hiểu thêm, tôi khuyên bạn nên sử dụng hai phiên này từ WWDC18 để tìm hiểu cách các ứng dụng của bạn trở nên sống động khi ra mắt: "Tối ưu hóa thời gian khởi động ứng dụng" và "Thời gian khởi động ứng dụng: Quá khứ, hiện tại và tương lai".

00:37:08.000 --> 00:37:11.000
Cảm ơn tất cả các bạn rất nhiều vì đã tham gia cùng tôi để tìm hiểu về biểu tượng hóa!

00:37:11.000 --> 00:37:13.000
Chúc bạn có một phần còn lại tuyệt vời trong tuần.

00:37:13.000 --> 23:59:59.000
♪

