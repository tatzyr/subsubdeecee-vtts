WEBVTT

00:00:00.000 --> 00:00:05.000
♪ Nhạc bass đang phát ♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:11.000
Kyle Macomber: Xin chào, tôi là Kyle.

00:00:11.000 --> 00:00:20.000
Nhóm Thư viện Tiêu chuẩn Swift duy trì một danh sách ngày càng tăng các gói mã nguồn mở bao gồm Swift ArgumentParser, Swift Numerics và Swift System.

00:00:20.000 --> 00:00:28.000
Hôm nay, chúng tôi vui mừng giới thiệu hai bổ sung mới lớn cho gia đình: Thuật toán Swift và Bộ sưu tập Swift!

00:00:28.000 --> 00:00:35.000
Swift Algorithms là một gói mã nguồn mở gồm các thuật toán trình tự và bộ sưu tập giúp tăng cường thư viện tiêu chuẩn Swift.

00:00:35.000 --> 00:00:41.000
Một trong những tính năng mạnh mẽ nhất của Swift là phân loại phong phú của các thuật toán được tích hợp sẵn.

00:00:41.000 --> 00:00:53.000
Phải mất một chút đầu tư để học từ vựng, nhưng một khi bạn làm vậy, có thể rất ấn tượng khi khám phá ra có bao nhiêu thuật toán đang ẩn trong tầm nhìn rõ ràng và bạn có thể cải thiện chất lượng mã của mình đến mức nào bằng cách áp dụng chúng.

00:00:53.000 --> 00:00:59.000
Để hiểu ý tôi, chúng ta hãy xem một số mã từ ứng dụng nhắn tin mà tôi đang làm việc.

00:00:59.000 --> 00:01:10.000
Hãy xem xét vòng lặp này lặp lại trên các đường dẫn chỉ mục cho các hàng đã chọn trong chế độ xem bảng, thu thập tất cả các thông báo tương ứng để chuyển tiếp hoặc xóa.

00:01:10.000 --> 00:01:14.000
Đây chỉ là một bản đồ.

00:01:14.000 --> 00:01:24.000
Sử dụng bản đồ làm cho mã này rõ ràng hơn cho người đọc vì nó cung cấp thêm ngữ cảnh rằng phần thân của phần đóng, bất kể độ dài hay độ phức tạp của nó, chỉ đang chuyển đổi đầu vào.

00:01:24.000 --> 00:01:36.000
Sử dụng bản đồ cũng làm cho mã này nhanh hơn vì nó tránh phân bổ trung gian do thay đổi kích thước mảng bằng cách đặt trước dung lượng - điều mà vòng lặp thô của chúng tôi không bận tâm làm.

00:01:36.000 --> 00:01:48.000
Hoặc xem xét vòng lặp này, nếu người dùng nhấn vào một hình ảnh, lặp lại các tin nhắn trong bảng điểm, thu thập tất cả các tệp đính kèm để hiển thị bằng Quick Look.

00:01:48.000 --> 00:01:51.000
Đây chỉ là một bản đồ và một bộ lọc!

00:01:51.000 --> 00:02:06.000
Trên thực tế, mô hình lọc ra nils và ánh xạ để mở gói các tùy chọn phổ biến đến mức chúng tôi có một tên và thuật toán đặc biệt cho nó: compactMap.

00:02:06.000 --> 00:02:08.000
Tiếp theo, hãy xem xét mã này.

00:02:08.000 --> 00:02:14.000
Tôi có một mảng tin nhắn, và tôi muốn chuyển đổi nó thành một mảng các mục bảng điểm.

00:02:14.000 --> 00:02:22.000
Điều khó khăn là bất kỳ tin nhắn nhất định nào cũng có thể tương ứng với nhiều mục trong bảng điểm trò chuyện.

00:02:22.000 --> 00:02:25.000
Sử dụng bản đồ ở đây tạo ra một mảng.

00:02:25.000 --> 00:02:29.000
Nhưng đó không phải là điều tôi muốn; Tôi chỉ muốn một mảng phẳng.

00:02:29.000 --> 00:02:33.000
Điều này có nghĩa là tôi phải quay lại sử dụng vòng lặp thô?

00:02:33.000 --> 00:02:37.000
Tất nhiên là không; chúng tôi có một thuật toán khác cho điều đó.

00:02:37.000 --> 00:02:39.000
Nó được gọi là "đã tham gia".

00:02:39.000 --> 00:02:45.000
Những gì nó làm là kết hợp tất cả các mảng bên trong lại với nhau thành một tập hợp các phần tử phẳng, duy nhất.

00:02:45.000 --> 00:02:55.000
Mô hình lập bản đồ và nối này phổ biến đến mức chúng tôi xác định một loại bản đồ đặc biệt khác cho nó: flatMap.

00:02:55.000 --> 00:02:59.000
Tất nhiên, bản đồ và bộ lọc chỉ là phần nổi của tảng băng trôi.

00:02:59.000 --> 00:03:03.000
Hãy xem xét vòng lặp thô này từ màn hình chi tiết trò chuyện trong ứng dụng của tôi.

00:03:03.000 --> 00:03:08.000
Tôi muốn hiển thị sáu bức ảnh cuối cùng trong một cuộc trò chuyện, từ mới nhất đến cũ nhất.

00:03:08.000 --> 00:03:16.000
Vì vậy, tôi lặp lại bảng điểm ngược lại - từ mới nhất đến cũ nhất - và nếu mục đó là ảnh, tôi thêm nó vào mảng.

00:03:16.000 --> 00:03:19.000
Và một khi tôi có sáu, tôi dừng lại.

00:03:19.000 --> 00:03:35.000
Chúng ta có thể diễn đạt điều này ngắn gọn hơn bằng cách xâu chuỗi các thuật toán lại với nhau từ thư viện tiêu chuẩn - đảo ngược, compactMap và tiền tố - để lấy không quá sáu cái đầu tiên.

00:03:35.000 --> 00:03:42.000
Chuỗi các thuật toán lại với nhau cũng giúp chúng ta linh hoạt hơn để thể hiện mã này rõ ràng hơn.

00:03:42.000 --> 00:03:52.000
Ví dụ, tôi thấy tự nhiên hơn khi nghĩ về thao tác này dưới dạng hậu tố của bảng điểm hơn là tiền tố của bảng điểm đảo ngược.

00:03:52.000 --> 00:03:58.000
Vì vậy, chuỗi thuật toán rõ ràng và súc tích hơn vòng lặp thô, nhưng hiệu suất so sánh như thế nào?

00:03:58.000 --> 00:04:06.000
Nếu mỗi bước trong chuỗi phân bổ một mảng trung gian, không phải nó sẽ chậm hơn vòng lặp thô sao?

00:04:06.000 --> 00:04:13.000
Câu trả lời sẽ là có nếu thư viện tiêu chuẩn không chơi một số thủ thuật thông minh ở đây.

00:04:13.000 --> 00:04:19.000
Hãy quay lại thuật toán đã tham gia mà chúng ta đã thấy trước đó để xem xét kỹ hơn những gì đang diễn ra.

00:04:19.000 --> 00:04:23.000
Hóa ra tham gia không thực sự phân bổ và trả về một mảng mới ở đây.

00:04:23.000 --> 00:04:26.000
Thay vào đó, nó trả về một FlattenSequence.

00:04:26.000 --> 00:04:30.000
FlattenSequence là cái mà chúng ta gọi là "bộ chuyển đổi lười biếng".

00:04:30.000 --> 00:04:37.000
Đối với hầu hết các mục đích, nó hoạt động giống như một mảng, nhưng nó chỉ là một trình bao bọc mỏng, vì vậy nó có hiệu quả miễn phí để tạo.

00:04:37.000 --> 00:04:43.000
Và nó lười biếng, vì vậy nó xử lý các yếu tố của nó theo yêu cầu, thay vì làm tất cả công việc trước.

00:04:43.000 --> 00:04:51.000
Các bộ điều hợp lười biếng như FlattenSequence là những gì cho phép các chuỗi thuật toán có hiệu suất cạnh tranh với các vòng lặp thô.

00:04:51.000 --> 00:04:59.000
Hãy quay lại màn hình chi tiết và xem xét kỹ hơn thuật toán của chúng tôi để tính toán sáu bức ảnh cuối cùng trong một cuộc trò chuyện.

00:04:59.000 --> 00:05:14.000
Chúng tôi thấy rằng hậu tố thực sự chỉ trả về một lát mảng - thật thông minh - và sự đảo ngược đó cũng được triển khai như một bộ điều hợp lười biếng, một bộ chuyển đổi can thiệp để bắt đầu ở cuối và kết thúc khi bắt đầu.

00:05:14.000 --> 00:05:17.000
Còn compactMap thì sao?

00:05:17.000 --> 00:05:20.000
Nó vẫn đang trả về một mảng. Điều đó có thể lười biếng không?

00:05:20.000 --> 00:05:22.000
Nó có thể.

00:05:22.000 --> 00:05:31.000
Bạn chỉ cần thêm một .lazy vào đầu chuỗi, và nó làm cho bất kỳ thuật toán nào đóng cửa, như bản đồ và bộ lọc, lười biếng!

00:05:31.000 --> 00:05:41.000
Chuỗi thuật toán lười biếng rất phù hợp với các trường hợp sử dụng như thế này, nơi bạn chỉ xử lý một số lượng nhỏ các yếu tố từ một bộ sưu tập có khả năng rất lớn.

00:05:41.000 --> 00:05:45.000
Tất nhiên, đôi khi bạn cần hoặc muốn có một mảng.

00:05:45.000 --> 00:05:50.000
Và trong trường hợp đó, bạn luôn có thể bọc chuỗi thuật toán của mình trong trình khởi tạo mảng.

00:05:50.000 --> 00:05:55.000
Đây là một lý do nữa tại sao, trong nhóm Thư viện Tiêu chuẩn, chúng tôi là một fan hâm mộ lớn của các thuật toán lười biếng.

00:05:55.000 --> 00:06:02.000
Thật dễ dàng để biến một thuật toán lười biếng thành một kết quả háo hức, nhưng không thể đi theo hướng khác.

00:06:02.000 --> 00:06:08.000
Vì vậy, tôi đã đạt được tiến bộ lớn trên ứng dụng nhắn tin của mình và nhà thiết kế của tôi tiếp cận tôi với một yêu cầu tính năng.

00:06:08.000 --> 00:06:15.000
Họ muốn bao gồm dấu thời gian trong bảng điểm, nếu hơn một giờ trôi qua giữa hai tin nhắn liên tiếp.

00:06:15.000 --> 00:06:16.000
Có vẻ hợp lý.

00:06:16.000 --> 00:06:20.000
Phải có một thuật toán khác mà tôi có thể sử dụng cho việc này, phải không?

00:06:20.000 --> 00:06:26.000
Có. Nhưng để truy cập nó, tôi sẽ cần nhập gói Swift Algorithms.

00:06:26.000 --> 00:06:33.000
Thỉnh thoảng, bạn sẽ gặp phải những trường hợp sử dụng như thế này mà thư viện tiêu chuẩn Swift chưa có phạm vi bảo hiểm.

00:06:33.000 --> 00:06:45.000
Mục đích của gói Thuật toán là cung cấp một địa điểm ma sát thấp cho chúng tôi - với sự giúp đỡ của bạn - để ươm tạo các họ thuật toán bị thiếu mới để cuối cùng đưa vào thư viện tiêu chuẩn.

00:06:45.000 --> 00:06:49.000
Chúng tôi đã thêm hơn 40 thuật toán vào Swift Algorithms.

00:06:49.000 --> 00:07:07.000
Đối với những thứ như tạo ra tất cả các kết hợp hoặc hoán vị của một tập hợp các phần tử; hoặc lặp lại các phần tử của một chuỗi bằng hai hoặc ba hoặc trong các nhóm được xác định bởi một vị ngữ; hoặc chọn năm phần tử nhỏ nhất trong một bộ sưu tập, năm phần tử lớn nhất hoặc chỉ năm bất kỳ ngẫu nhiên.

00:07:07.000 --> 00:07:13.000
Chúng ta hãy xem xét kỹ hơn một số công cụ lặp lại mạnh mẽ đi kèm với Thuật toán Swift.

00:07:13.000 --> 00:07:20.000
windows(ofCount:) cung cấp một cửa sổ trượt, ở đây có kích thước 3, vào các yếu tố của một bộ sưu tập.

00:07:20.000 --> 00:07:30.000
Đối với mỗi vòng lặp, cửa sổ chỉ là một chuỗi con của bộ sưu tập cơ sở - đây là ArraySlice - tránh bất kỳ sự phân bổ trung gian nào.

00:07:30.000 --> 00:07:35.000
windows(ofCount: 2) đặc biệt phổ biến và vì vậy chúng tôi có một sự tiện lợi cho nó.

00:07:35.000 --> 00:07:37.000
Nó được gọi là "cặp liền kề".

00:07:37.000 --> 00:07:44.000
Các cặp liền kề chứa một bộ thay vì một dãy con, cho phép truy cập phần tử thuận tiện hơn.

00:07:44.000 --> 00:07:49.000
Một công cụ lặp lại mạnh mẽ khác là chunks(ofCount:).

00:07:49.000 --> 00:07:54.000
Không giống như các cửa sổ, các khối không chồng lên nhau.

00:07:54.000 --> 00:08:01.000
Nếu một bộ sưu tập không chia hết cho số lượng đoạn, đoạn cuối cùng trong chuỗi sẽ chứa phần còn lại.

00:08:01.000 --> 00:08:07.000
Và cũng giống như các cửa sổ, các khối là chuỗi con của bộ sưu tập cơ sở, vì vậy chúng rất rẻ để tạo ra.

00:08:07.000 --> 00:08:12.000
Đôi khi bạn muốn chia nhỏ một bộ sưu tập thành các yếu tố tương tự.

00:08:12.000 --> 00:08:15.000
Ở đây chúng tôi đang chia nhỏ isPrime.

00:08:15.000 --> 00:08:22.000
Điều này có nghĩa là chúng ta sẽ lặp lại các phần tử liên tiếp trả về cùng một giá trị cho isPrime.

00:08:22.000 --> 00:08:29.000
Để thuận tiện, chunked(on:) định vị một bộ của cả chunk và giá trị được chunk trên.

00:08:29.000 --> 00:08:37.000
Bạn đã bao giờ thấy mình viết một vòng lặp thô như thế này mà chỉ hoạt động nếu các yếu tố trước đó và hiện tại khác nhau chưa?

00:08:37.000 --> 00:08:39.000
Cái này chỉ là chunked!

00:08:39.000 --> 00:08:48.000
Bây giờ chúng ta hãy quay lại yêu cầu tính năng đó từ nhà thiết kế của tôi để bao gồm dấu thời gian trong bảng điểm bất cứ khi nào hơn một giờ trôi qua giữa các tin nhắn.

00:08:48.000 --> 00:08:55.000
Nếu bạn nhớ lại, chúng tôi tạo bảng điểm bằng cách ánh xạ phẳng trên các tin nhắn để tạo các mục bảng điểm.

00:08:55.000 --> 00:09:00.000
Chà, mọi mục bảng điểm đều có quyền truy cập vào ngày của nó.

00:09:00.000 --> 00:09:07.000
Chúng ta có thể chia nhỏ ngày để nhóm các mục bảng điểm lại với nhau nếu ít hơn một giờ trôi qua giữa chúng.

00:09:07.000 --> 00:09:11.000
Chúng tôi đã thấy cách chia nhỏ một bộ sưu tập thành các phần tử tương tự.

00:09:11.000 --> 00:09:17.000
Các thuật toán Swift đi kèm với một biến thể khác của chunked cho phép bạn cung cấp một vị ngữ tùy chỉnh.

00:09:17.000 --> 00:09:24.000
Nó chuyển cho bạn các cặp phần tử liền kề và bạn trả về true nếu chúng thuộc cùng một nhóm.

00:09:24.000 --> 00:09:32.000
Ở đây, chúng tôi trả về true nếu khoảng thời gian giữa các mục bảng điểm nhỏ hơn một giờ.

00:09:32.000 --> 00:09:39.000
Tiếp theo, chúng ta cần tạo dấu thời gian và kết hợp mọi thứ lại với nhau thành một bộ sưu tập phẳng duy nhất.

00:09:39.000 --> 00:09:44.000
Trước đó, chúng tôi đã từng tham gia để làm phẳng một bộ sưu tập lồng nhau.

00:09:44.000 --> 00:09:50.000
Thư viện tiêu chuẩn đi kèm với một biến thể khác của tham gia có thể chèn dấu phân cách.

00:09:50.000 --> 00:09:57.000
Nó thực sự phổ biến khi sử dụng thuật toán này để nối các chuỗi với nhau với nhau, giả sử, một dòng mới hoặc một dấu phân cách dấu phẩy.

00:09:57.000 --> 00:10:02.000
Tuy nhiên, trong trường hợp này, một dấu phân cách không đổi là không đủ.

00:10:02.000 --> 00:10:09.000
Chúng tôi cần quyền truy cập vào ngày đầu tiên trong đoạn tiếp theo để xây dựng dấu thời gian.

00:10:09.000 --> 00:10:18.000
Chà, gói Thuật toán bao gồm một biến thể khác của tham gia cho phép bạn tính toán dấu phân cách từ các đoạn trước và tiếp theo.

00:10:18.000 --> 00:10:25.000
Chúng ta có thể sử dụng nó ở đây để nối lại với nhau các đoạn của các mục bảng điểm, hiện được phân tách bằng dấu thời gian.

00:10:25.000 --> 00:10:28.000
Khá thỏa mãn, phải không?

00:10:28.000 --> 00:10:33.000
Tất nhiên, chúng tôi không cần phải trả tiền cho bất kỳ phân bổ trung gian nào trong số này.

00:10:33.000 --> 00:10:38.000
Tất cả những điều này có thể được tính toán theo yêu cầu chỉ bằng cách thêm một .lazy.

00:10:38.000 --> 00:10:40.000
Voilà!

00:10:40.000 --> 00:10:44.000
Tuy nhiên, tôi muốn cảnh báo rằng sự lười biếng không phải là một viên đạn bạc.

00:10:44.000 --> 00:10:51.000
Khi bạn chỉ lặp lại một chuỗi một lần duy nhất, tính toán theo yêu cầu có thể tiết kiệm công việc và tránh phân bổ.

00:10:51.000 --> 00:11:08.000
Nhưng khi bạn lặp đi lặp lại một chuỗi - giống như tôi với bảng điểm trong ứng dụng nhắn tin của mình - máy tính theo yêu cầu sẽ lặp đi lặp lại cùng một công việc - lập bản đồ, phân đoạn và tham gia mỗi khi người dùng vào chế độ chỉnh sửa, nhấn vào hình ảnh hoặc truy cập màn hình chi tiết.

00:11:08.000 --> 00:11:11.000
Trong những trường hợp như thế này, bạn vẫn nên sử dụng một chuỗi thuật toán lười biếng.

00:11:11.000 --> 00:11:19.000
Chỉ là bước cuối cùng, sẽ hiệu quả hơn nếu bạn lưu công việc của mình bằng cách thu thập mọi thứ lại với nhau thành một mảng.

00:11:19.000 --> 00:11:24.000
Chúng tôi đã xem xét hơn một chục thuật toán khác nhau từ thư viện tiêu chuẩn Swift và gói Thuật toán.

00:11:24.000 --> 00:11:37.000
Tất cả chúng không chỉ hoạt động trên mảng, mà còn cả chuỗi và mọi loại Swift khác phù hợp với các giao thức trình tự và bộ sưu tập - bao gồm mọi cấu trúc dữ liệu trong gói Bộ sưu tập Swift mới.

00:11:37.000 --> 00:11:42.000
Chuỗi các thuật toán với nhau làm cho mã của bạn rõ ràng hơn, nhanh hơn và chính xác hơn.

00:11:42.000 --> 00:11:48.000
Và trở nên thành thạo nó không phức tạp; nó chỉ là xây dựng vốn từ vựng của bạn.

00:11:48.000 --> 00:11:58.000
Vì vậy, lần tới khi bạn thấy mình đọc hoặc viết một vòng lặp thô, hãy dừng lại và suy nghĩ xem đó là bản đồ, bộ lọc hay một trong những thuật toán khác mà bạn vừa thấy.

00:11:58.000 --> 00:12:12.000
Nếu không có gì xuất hiện trong đầu, hãy tìm kiếm tài liệu về các giao thức trình tự và bộ sưu tập, hoặc đọc các hướng dẫn trong kho lưu trữ GitHub của Swift Algorithms hoặc ghé thăm chúng tôi trên các diễn đàn Swift, nơi chúng tôi có thể cùng nhau tìm ra nó.

00:12:12.000 --> 00:12:17.000
Ai biết được, nó có thể là nguồn cảm hứng cho một bổ sung mới cho gói Thuật toán!

00:12:17.000 --> 00:12:24.000
Tiếp theo, Karoy sẽ dạy bạn về các cấu trúc dữ liệu linh hoạt đi kèm với gói Swift Collections mới.

00:12:24.000 --> 00:12:25.000
Karoy?

00:12:25.000 --> 00:12:26.000
Karoy Lorentey: Cảm ơn, Kyle!

00:12:26.000 --> 00:12:29.000
Hãy nói về cấu trúc dữ liệu.

00:12:29.000 --> 00:12:42.000
Như hiện nay, thư viện tiêu chuẩn Swift chỉ triển khai ba cấu trúc dữ liệu có mục đích chung chính: nó cung cấp mảng, bộ không có thứ tự và từ điển không có thứ tự.

00:12:42.000 --> 00:12:51.000
Những thứ này đã chứng minh những lựa chọn tuyệt vời như các loại bộ sưu tập phổ quát và chúng đặc biệt tốt cho việc truyền dữ liệu qua các ranh giới mô-đun.

00:12:51.000 --> 00:13:08.000
Tất cả chúng đều triển khai ngữ nghĩa giá trị sao chép khi ghi, cung cấp các hoạt động đột biến tại chỗ hiệu quả đồng thời đảm bảo rằng các giá trị bộ sưu tập an toàn để vượt qua mà không có những đột biến này dẫn đến những thay đổi bất ngờ trong bất kỳ bản sao nào được tạo.

00:13:08.000 --> 00:13:11.000
Tuy nhiên, có rất nhiều cấu trúc dữ liệu ngoài kia.

00:13:11.000 --> 00:13:16.000
Sẽ rất hữu ích nếu có nhiều lựa chọn hơn để lựa chọn.

00:13:16.000 --> 00:13:22.000
Đầu năm nay, chúng tôi đã phát hành gói Swift Collections, với việc triển khai cấu trúc dữ liệu mới.

00:13:22.000 --> 00:13:35.000
Gói này cho phép các nhà phát triển Swift có được trải nghiệm sản xuất thực tế với các loại bộ sưu tập mới trước khi cuối cùng chúng tôi đề xuất chúng để đưa vào thư viện tiêu chuẩn Swift.

00:13:35.000 --> 00:13:40.000
Bằng cách nhập gói Swift Collections, chúng tôi có quyền truy cập vào các loại bổ sung.

00:13:40.000 --> 00:13:46.000
Phiên bản ban đầu của gói triển khai ba trong số các cấu trúc dữ liệu được yêu cầu thường xuyên nhất.

00:13:46.000 --> 00:13:51.000
Đây là những biến thể mới của ba loại bộ sưu tập tiêu chuẩn.

00:13:51.000 --> 00:13:59.000
Chúng tôi có một hàng đợi hai đầu, một OrderedSet, và một OrderedDictionary.

00:13:59.000 --> 00:14:08.000
Chúng tương tự như mảng, bộ và từ điển; chúng là các biến thể của cùng một chủ đề, thêm các tính năng mới vào các cấu trúc hiện có.

00:14:08.000 --> 00:14:15.000
Điều đó nói rằng, những loại mới này không thay thế cho những loại hiện có; chúng bổ sung cho chúng.

00:14:15.000 --> 00:14:18.000
Đối với một số trường hợp sử dụng, các loại mới sẽ phù hợp hơn.

00:14:18.000 --> 00:14:23.000
Tuy nhiên, đối với nhiều người khác, các loại hiện có tiếp tục là lựa chọn đúng đắn.

00:14:23.000 --> 00:14:30.000
Để biết cấu trúc dữ liệu nào cần tiếp cận, chúng ta cần tìm hiểu xem chúng khác với các loại hiện có như thế nào.

00:14:30.000 --> 00:14:38.000
Vì vậy, chúng ta hãy xem xét ngắn gọn từng thứ này, bắt đầu với hàng đợi hai đầu - hay đúng hơn là hàng đợi nói chung.

00:14:38.000 --> 00:14:51.000
Hàng đợi bật lên ở khắp mọi nơi cần xử lý từng mặt hàng tùy ý, từ khách hàng xếp hàng chờ trong siêu thị đến các nhiệm vụ không đồng bộ trong ứng dụng.

00:14:51.000 --> 00:15:06.000
Ở dạng trừu tượng nhất của chúng, hàng đợi cung cấp hai thao tác chính: chúng ta có thể đẩy các mục ra phía sau hàng đợi và chúng ta có thể bật các phần tử ra khỏi phía trước.

00:15:06.000 --> 00:15:10.000
Một hàng đợi hai đầu làm cho các hoạt động hàng đợi này đối xứng.

00:15:10.000 --> 00:15:16.000
Nó hỗ trợ đẩy các mặt hàng mới lên đầu hàng đợi một cách hiệu quả...

00:15:16.000 --> 00:15:23.000
...Cũng như các yếu tố bật ra khỏi mặt sau.

00:15:23.000 --> 00:15:30.000
Cái tên "hàng đợi hai đầu" khá hấp dẫn đối với một loại hữu ích như vậy, vì vậy chúng tôi muốn rút ngắn nó thành "deque".

00:15:30.000 --> 00:15:37.000
Và để loại bỏ thêm một âm tiết nữa, điều này theo truyền thống được phát âm là "bộ bài", giống như một bộ bài.

00:15:37.000 --> 00:15:45.000
Trong gói Bộ sưu tập, deque có API gần giống với loại mảng quen thuộc và nó triển khai nhiều giao thức giống nhau.

00:15:45.000 --> 00:15:51.000
Ví dụ, chúng ta có thể sử dụng một mảng theo nghĩa đen để tạo một deque.

00:15:51.000 --> 00:15:54.000
Deque phù hợp với giao thức RandomAccessCollection.

00:15:54.000 --> 00:16:00.000
Giống như mảng, deque sử dụng các chỉ số nguyên được đo lệch từ đầu bộ sưu tập.

00:16:00.000 --> 00:16:04.000
Điều này giúp dễ dàng truy cập bất kỳ yếu tố nào dựa trên vị trí của nó.

00:16:04.000 --> 00:16:11.000
Ví dụ, phần tử ở chỉ mục 1 trong deque này là chữ E.

00:16:11.000 --> 00:16:17.000
Bây giờ, tôi chắc chắn rằng tôi không phải là người duy nhất bị làm phiền bởi chữ thường f ở cuối bộ sưu tập này.

00:16:17.000 --> 00:16:28.000
May mắn thay, deque phù hợp với giao thức MutableCollection, vì vậy chúng tôi có thể khắc phục điều này bằng cách gán thông qua chỉ mục 2, thay thế chữ thường f bằng chữ hoa.

00:16:28.000 --> 00:16:30.000
À, trông đẹp hơn rất nhiều!

00:16:30.000 --> 00:16:42.000
Deque cũng triển khai giao thức RangeReplaceableCollection, vì vậy nó cung cấp tất cả các thao tác quen thuộc để chèn, xóa hoặc thay thế các dải con của các phần tử.

00:16:42.000 --> 00:16:50.000
Ví dụ, chúng ta có thể chèn một chuỗi ở phía trước deque của mình bằng cách gọi phương thức insert(contentsOf:) với chỉ mục bằng 0.

00:16:50.000 --> 00:16:55.000
Cách nó thực thi điều này là nơi deque bắt đầu khác với một mảng.

00:16:55.000 --> 00:17:06.000
Nếu chúng ta sử dụng một mảng để lưu trữ các mặt hàng của mình, thì việc chèn các phần tử mới ở phía trước sẽ cần phải bắt đầu bằng cách di chuyển các phần tử hiện có để nhường chỗ cho các phần tử mới.

00:17:06.000 --> 00:17:15.000
Để làm cho việc truy cập trở nên đơn giản nhất có thể, các mảng giữ các phần tử của chúng trong một bộ đệm liền kề duy nhất, bắt đầu từ đầu lưu trữ của chúng.

00:17:15.000 --> 00:17:30.000
Nếu mảng lớn, điều này làm cho việc chuẩn bị các phần tử mới tương đối tốn kém; vì vậy việc chèn một phần tử mới ở phía trước mất thời gian tỷ lệ thuận với số lượng phần tử đã có trong mảng.

00:17:30.000 --> 00:17:32.000
Một deque hoạt động khác nhau.

00:17:32.000 --> 00:17:41.000
Nó bọc bộ đệm lưu trữ của nó xung quanh ranh giới của nó để nó có thể thêm các yếu tố mới mà không cần di chuyển bất kỳ yếu tố nào hiện có.

00:17:41.000 --> 00:17:51.000
Các chỉ số vẫn được bù đắp từ phần bắt đầu hợp lý của bộ sưu tập, vì vậy sau khi chèn, phần tử ở chỉ mục 1 bây giờ là B.

00:17:51.000 --> 00:18:03.000
Điều này có nghĩa là deques cần thực hiện một số công việc để dịch giữa các chỉ số logic và vị trí lưu trữ thực tế của chúng, nhưng việc truy cập các yếu tố vẫn khá hiệu quả.

00:18:03.000 --> 00:18:12.000
Và bởi vì việc chuẩn bị cho một deque không liên quan đến việc trượt bất kỳ thành viên hiện có nào, họ có thể thực hiện thao tác này nhanh hơn hoàn toàn so với mảng.

00:18:12.000 --> 00:18:20.000
Việc chèn một phần tử mới ở phía trước mất một khoảng thời gian không đổi, bất kể có bao nhiêu phần tử đã có trong bộ sưu tập.

00:18:20.000 --> 00:18:23.000
Đây là sức mạnh của cấu trúc dữ liệu.

00:18:23.000 --> 00:18:28.000
Khi chúng ta có chúng trong hộp công cụ của mình, chúng ta có thể sử dụng chúng để giải quyết các vấn đề mà trước đây nằm ngoài tầm với.

00:18:28.000 --> 00:18:32.000
Chuyển sang cấu trúc dữ liệu phù hợp có thể tạo ra tất cả sự khác biệt.

00:18:32.000 --> 00:18:39.000
Nó có thể biến một ứng dụng chậm không sử dụng được thành một kỳ quan đáp ứng, đó là một niềm vui khi sử dụng.

00:18:39.000 --> 00:18:46.000
Tất nhiên, deques cũng có thể thông minh về cách họ thực hiện các hoạt động ở giữa kho lưu trữ của họ.

00:18:46.000 --> 00:19:00.000
Ví dụ, khi loại bỏ một loạt các phần tử, deque có tùy chọn thu hẹp khoảng cách kết quả bằng cách di chuyển các phần tử trước đó thay vì các phần tử tiếp theo và điều này có thể làm giảm số lượng phần tử cần được di chuyển.

00:19:00.000 --> 00:19:10.000
Đây không phải là một cải tiến mạnh mẽ như việc chuẩn bị trước một phần tử, nhưng khi chúng tôi loại bỏ các phần tử một cách ngẫu nhiên, nó làm cho mọi thứ nhanh gấp đôi trung bình.

00:19:10.000 --> 00:19:12.000
Vì vậy, đó là deque.

00:19:12.000 --> 00:19:17.000
Bây giờ, chúng ta hãy xem các bộ đã đặt hàng.

00:19:17.000 --> 00:19:23.000
Loại bộ tiêu chuẩn, đã có từ trước là một bộ sưu tập đảm bảo rằng tất cả các yếu tố của nó là duy nhất.

00:19:23.000 --> 00:19:27.000
Tuy nhiên, nó không giữ nguyên đơn đặt hàng ban đầu của họ.

00:19:27.000 --> 00:19:33.000
Trên thực tế, thứ tự của các phần tử trong một tập hợp là ngẫu nhiên một cách hiệu quả.

00:19:33.000 --> 00:19:43.000
Điều này có nghĩa là hai trường hợp của cùng một tập hợp thường liệt kê chúng trong hai hoán vị hoàn toàn khác nhau.

00:19:43.000 --> 00:19:51.000
Mặc dù vậy, hai tập hợp chứa các yếu tố giống nhau được coi là bằng nhau; thứ tự không quan trọng.

00:19:51.000 --> 00:19:59.000
Điều này thật tuyệt vời khi tất cả những gì chúng tôi muốn là đảm bảo tính độc đáo, nhưng đôi khi chúng tôi cũng muốn kiểm soát cách các yếu tố được sắp xếp.

00:19:59.000 --> 00:20:11.000
Ví dụ: nếu chúng tôi đang viết một ứng dụng danh sách việc cần làm, chúng tôi có thể muốn đảm bảo rằng nó chỉ liệt kê từng mục một lần, nhưng chúng tôi cũng cần giữ chúng theo thứ tự cụ thể do người dùng đặt ra.

00:20:11.000 --> 00:20:14.000
Vì vậy, đó là những gì một bộ được đặt hàng làm.

00:20:14.000 --> 00:20:26.000
Tùy thuộc vào quan điểm của chúng tôi, nó hoạt động giống như một mảng giữ cho các phần tử của nó là duy nhất hoặc chúng tôi có thể xem nó như một tập hợp duy trì thứ tự mà chúng tôi thiết lập trên các thành viên của nó.

00:20:26.000 --> 00:20:32.000
Giống như các mảng và tập hợp, các tập hợp có thứ tự cũng có thể được thể hiện bằng các ký tự mảng.

00:20:32.000 --> 00:20:38.000
Tuy nhiên, không giống như một tập hợp, thứ tự của các phần tử được đảm bảo tồn.

00:20:38.000 --> 00:20:49.000
Thứ tự cũng rất quan trọng; hai bộ có thứ tự so sánh bằng nhau nếu chúng không chỉ chứa cùng một thành viên, mà chúng cũng phải theo cùng một thứ tự.

00:20:49.000 --> 00:20:57.000
Nếu chúng ta chỉ cần biết liệu hai bộ có thứ tự có chứa các phần tử giống nhau hay không, theo bất kỳ thứ tự nào, thì chúng ta có thể so sánh chúng thông qua chế độ xem không có thứ tự đặc biệt.

00:20:57.000 --> 00:21:05.000
Chế độ xem nhẹ này bỏ qua thứ tự phần tử, vì vậy nó cung cấp một giao diện giống như bộ, thông thường hơn.

00:21:05.000 --> 00:21:09.000
Tuy nhiên, theo mặc định, các tập hợp có thứ tự giống với cách các mảng hoạt động.

00:21:09.000 --> 00:21:16.000
Điều này được củng cố bởi thực tế là các tập hợp có thứ tự là các bộ sưu tập truy cập ngẫu nhiên với các chỉ số bù số nguyên.

00:21:16.000 --> 00:21:23.000
Chúng ta có thể sử dụng chỉ số con số nguyên để truy cập các mục, giống như trong một mảng hoặc một deque.

00:21:23.000 --> 00:21:32.000
Như mong đợi từ một tập hợp, chúng ta cũng có thể thêm và xóa các yếu tố, mặc dù các hoạt động này cần phải tính đến vị trí.

00:21:32.000 --> 00:21:40.000
Ví dụ, chúng tôi có một thao tác nối thêm thêm một phần tử mới vào cuối tập hợp nếu nó chưa phải là thành viên.

00:21:40.000 --> 00:21:48.000
Giá trị trả về của nó cho biết liệu phần tử có cần được thêm vào hay không và nó cũng báo cáo chỉ mục của mục.

00:21:48.000 --> 00:21:53.000
Chúng tôi cũng có một thao tác chèn đặt phần tử mới tại vị trí được chỉ định.

00:21:53.000 --> 00:22:01.000
Trong trường hợp này, chữ B đã tồn tại, vì vậy thao tác chỉ đơn giản trả về chỉ mục của thành viên hiện tại.

00:22:01.000 --> 00:22:11.000
Loại bỏ một phần tử để lại một lỗ hổng trong tập hợp được sắp xếp và các thành viên còn lại cần được di chuyển để lấp đầy nó, giống như trong một mảng.

00:22:11.000 --> 00:22:17.000
Các bộ được đặt hàng cần giữ cho các yếu tố của chúng độc đáo, vì vậy chúng không thể hỗ trợ thay thế mặt hàng tùy ý.

00:22:17.000 --> 00:22:24.000
Điều này có nghĩa là không giống như các mảng, chúng không thể phù hợp với các giao thức MutableCollection hoặc RangeReplaceableCollection.

00:22:24.000 --> 00:22:32.000
Tuy nhiên, chúng hỗ trợ các hoạt động sắp xếp lại tiêu chuẩn như phân loại hoặc xáo trộn.

00:22:32.000 --> 00:22:42.000
Các bộ có thứ tự cũng thực hiện tất cả các hoạt động tập hợp cấp cao từ giao thức SetAlgebra, theo cách bảo toàn thứ tự.

00:22:42.000 --> 00:22:51.000
Ví dụ, hình thành một liên minh nối thêm bất kỳ phần tử còn thiếu nào, theo thứ tự chúng xuất hiện trong tập thứ hai.

00:22:51.000 --> 00:22:56.000
Trừ đi một tập hợp giữ các phần tử còn lại theo thứ tự ban đầu của chúng.

00:22:56.000 --> 00:23:08.000
Mặc dù các bộ có thứ tự thực hiện hầu hết các hoạt động SetAlgebra, chúng không thể chính thức phù hợp với giao thức đó vì nó yêu cầu thứ tự của các phần tử không được quan trọng.

00:23:08.000 --> 00:23:13.000
Tuy nhiên, quan điểm không có trật tự của họ có một khái niệm không nhạy cảm với trật tự về sự bình đẳng.

00:23:13.000 --> 00:23:16.000
Vì vậy, nó có thể và thực sự phù hợp với SetAlgebra.

00:23:16.000 --> 00:23:23.000
Chúng ta có thể sử dụng nó để chuyển các giá trị OrderedSet cho bất kỳ hàm nào yêu cầu giá trị SetAlgebra.

00:23:23.000 --> 00:23:34.000
Nhìn dưới mui xe, loại tập hợp tiêu chuẩn, không có thứ tự lưu trữ các phần tử của nó trực tiếp trong bảng băm phẳng bằng cách sử dụng hàm băm phổ quát được gieo hạt ngẫu nhiên.

00:23:34.000 --> 00:23:40.000
Điều này cung cấp hiệu suất tra cứu tuyệt vời cho các phần tử, nhưng nó loại bỏ thứ tự ban đầu của chúng.

00:23:40.000 --> 00:23:50.000
Để hỗ trợ các thứ tự phần tử tùy ý, do người dùng chỉ định, thay vào đó, một tập hợp có thứ tự lưu trữ các phần tử của nó trong một phiên bản mảng thông thường.

00:23:50.000 --> 00:24:01.000
Bộ được sắp xếp vẫn sử dụng cùng một triển khai bảng băm nhanh và an toàn, nhưng trong trường hợp này, bảng chỉ cần lưu trữ các chỉ số nguyên vào mảng lưu trữ.

00:24:01.000 --> 00:24:11.000
Phạm vi của các số nguyên này bị ràng buộc bởi kích thước của bảng băm, vì vậy chúng ta có thể nén bảng bằng cách đóng gói các giá trị số nguyên thành càng ít bit càng tốt.

00:24:11.000 --> 00:24:22.000
Điều này đôi khi có thể tiết kiệm một lượng bộ nhớ đáng kể so với một bộ thông thường trong khi vẫn duy trì hiệu suất cạnh tranh cho hầu hết các hoạt động.

00:24:22.000 --> 00:24:25.000
Hiệu suất tra cứu có thể so sánh với bộ tiêu chuẩn.

00:24:25.000 --> 00:24:31.000
Việc tìm kiếm một thành viên ngẫu nhiên mất khoảng thời gian gần như không đổi, bất kể kích thước của bộ sưu tập.

00:24:31.000 --> 00:24:38.000
Mảng cần phải xem xét từng yếu tố một cách tốn nhiều công sức, điều này mất nhiều thời gian hơn khi bộ sưu tập phát triển.

00:24:38.000 --> 00:24:46.000
Thêm một phần tử mới vào một tập hợp được sắp xếp cũng thực hiện gần như tương đương với việc chèn một phần tử vào một tập hợp tiêu chuẩn.

00:24:46.000 --> 00:24:57.000
Điều này vẫn cần băm mục mới và nó cũng bao gồm kiểm tra xem phần tử đã tồn tại chưa, vì vậy đây là một thao tác phức tạp hơn nhiều so với việc trực tiếp thêm một phần tử vào một mảng đơn giản.

00:24:57.000 --> 00:25:03.000
Nhưng những thứ này vẫn mất thời gian không đổi, bất kể các bộ sưu tập trở nên lớn đến mức nào.

00:25:03.000 --> 00:25:15.000
Tuy nhiên, trong khi OrderedSet có thể nhanh chóng tra cứu các phần tử hiện có và thêm các phần tử mới, nó không thể thực hiện hiệu quả việc xóa hoặc chèn một mục ở mặt trước hoặc giữa bộ.

00:25:15.000 --> 00:25:24.000
Giống như mảng, các hoạt động này cần trượt các phần tử xung quanh trong mảng lưu trữ, nhưng chúng cũng cần đánh số lại các chỉ số tiếp theo trong bảng băm.

00:25:24.000 --> 00:25:34.000
Điều này có nghĩa là việc loại bỏ và chèn biến thành các hoạt động với độ phức tạp tuyến tính, làm cho chúng chậm hơn so với tập hợp thông thường.

00:25:34.000 --> 00:25:36.000
Luôn luôn có một sự đánh đổi!

00:25:36.000 --> 00:25:50.000
Nhưng một khi chúng ta làm quen với cách các cấu trúc dữ liệu này hoạt động, chúng ta sẽ có thể tự tin chọn đúng để giải quyết bất kỳ vấn đề nào, dựa trên các yêu cầu chúng ta cần đáp ứng và các hoạt động quan trọng cần tối ưu hóa.

00:25:50.000 --> 00:25:59.000
Chọn cấu trúc dữ liệu phù hợp có thể dẫn đến cải tiến thuật toán có thể dẫn đến mã nhanh hơn hàng trăm hoặc thậm chí hàng nghìn lần.

00:25:59.000 --> 00:26:01.000
Chọn sai có thể làm ngược lại.

00:26:01.000 --> 00:26:10.000
Vì vậy, tôi nghĩ rằng thật hữu ích khi tìm hiểu về những điều này bởi vì, cuối cùng, nó mang lại những ứng dụng tuyệt vời và những người dùng hài lòng.

00:26:10.000 --> 00:26:16.000
Loại OrderedSet mới này là một biến thể Swift thuần túy của loại NSOrderedSet hiện có trong Foundation.

00:26:16.000 --> 00:26:22.000
Tuy nhiên, vì OrderedSet được triển khai trong một gói, nó không kết nối với NSOrderedSet.

00:26:22.000 --> 00:26:29.000
Điều này có nghĩa là các API Objective-C hiện tại sẽ không được nhập tự động để sử dụng loại mới.

00:26:29.000 --> 00:26:33.000
Đây là những thứ riêng biệt.

00:26:33.000 --> 00:26:42.000
Cấu trúc dữ liệu thứ ba được cung cấp bởi gói Bộ sưu tập là một cấu trúc tương tự có thứ tự của loại từ điển tiêu chuẩn.

00:26:42.000 --> 00:26:52.000
Giống như từ điển tiêu chuẩn, đây là một chuỗi các cặp khóa-giá trị cho phép chúng tôi sử dụng khóa làm chỉ số con để nhanh chóng tra cứu giá trị tương ứng của nó.

00:26:52.000 --> 00:26:57.000
Không giống như từ điển thông thường, thứ tự của các cặp khóa-giá trị được xác định rõ ràng.

00:26:57.000 --> 00:27:03.000
Theo mặc định, nó tuân theo thứ tự mà các phím ban đầu được chèn vào.

00:27:03.000 --> 00:27:09.000
Để thêm một phần tử mới, chúng ta có thể gán một giá trị cho một khóa mới.

00:27:09.000 --> 00:27:14.000
Chúng ta có thể loại bỏ các phần tử bằng cách gán nil cho một khóa hiện có.

00:27:14.000 --> 00:27:23.000
Trong suốt các hoạt động này, từ điển được sắp xếp duy trì nội dung của nó theo thứ tự được xác định rõ ràng.

00:27:23.000 --> 00:27:30.000
Từ điển có thứ tự sử dụng các chỉ số nguyên giống như mảng, nhưng điều này giới thiệu một vấn đề thú vị.

00:27:30.000 --> 00:27:37.000
Trong từ điển ví dụ của chúng tôi, thao tác chỉ số con lập chỉ mục xung đột với chỉ số con chính.

00:27:37.000 --> 00:27:49.000
Khi chúng ta đăng ký bằng số không, chúng ta có nghĩa là truy cập giá trị cho khóa 0 hay chúng ta có nghĩa là truy xuất cặp khóa-giá trị ở độ lệch 0?

00:27:49.000 --> 00:28:00.000
Chúng tôi nghĩ rằng chỉ số con dựa trên khóa là thao tác chính cho một loại từ điển, vì vậy để ngăn chặn sự mơ hồ này, đăng ký một từ điển có thứ tự luôn có nghĩa là chỉ số con khóa.

00:28:00.000 --> 00:28:06.000
OrderedDictionary hoàn toàn không cung cấp hoạt động chỉ số lập chỉ mục.

00:28:06.000 --> 00:28:14.000
Điều này có nghĩa là OrderedDictionary không thể là một bộ sưu tập, bởi vì giao thức bộ sưu tập yêu cầu một chỉ số con như vậy.

00:28:14.000 --> 00:28:19.000
Do đó, OrderedDictionary chỉ phù hợp với giao thức trình tự.

00:28:19.000 --> 00:28:27.000
Tuy nhiên, đối với các trường hợp mong muốn sự phù hợp của bộ sưu tập, OrderedDictionary cung cấp chế độ xem các yếu tố đặc biệt.

00:28:27.000 --> 00:28:35.000
Elements là một bộ sưu tập truy cập ngẫu nhiên cung cấp chỉ số con lập chỉ mục trả về một cặp khóa-giá trị.

00:28:35.000 --> 00:28:52.000
Nhìn vào việc triển khai cơ bản, trong khi loại từ điển thông thường sử dụng hai bảng băm riêng biệt để lưu trữ các khóa và giá trị tương ứng, một từ điển có thứ tự sử dụng một bảng băm nén duy nhất và hai mảng song song thay thế.

00:28:52.000 --> 00:28:56.000
Điều này có thể tiết kiệm nhiều dung lượng hơn các bộ đã đặt hàng.

00:28:56.000 --> 00:29:01.000
Vì vậy, đây là ba cấu trúc dữ liệu mới có sẵn trong gói Bộ sưu tập.

00:29:01.000 --> 00:29:17.000
Bằng cách sử dụng các cấu trúc này, chúng tôi có thể tăng hiệu suất của các ứng dụng của mình hoặc giảm việc sử dụng bộ nhớ hoặc - cũng quan trọng không kém - chúng tôi có thể hiện các ràng buộc mà chúng tôi không thể dễ dàng đáp ứng với các loại tiêu chuẩn, chẳng hạn như duy trì thứ tự phần tử trong một tập hợp.

00:29:17.000 --> 00:29:30.000
Bởi vì tất cả các loại mới này đều phù hợp với một số giao thức trình tự và bộ sưu tập, chúng cũng tương tác với các thuật toán được cung cấp bởi thư viện tiêu chuẩn cũng như gói Thuật toán mới mà Kyle đã chỉ cho chúng ta trước đó.

00:29:30.000 --> 00:29:38.000
Bộ sưu tập Swift và Thuật toán Swift chỉ là hai trong số các thành viên mới trong danh sách các gói mã nguồn mở đang phát triển của chúng tôi.

00:29:38.000 --> 00:29:45.000
Tương lai của hệ sinh thái thư viện Swift đang được định hình ngay bây giờ, khi chúng tôi đẩy mạnh các nền tảng mới và vào các miền mới.

00:29:45.000 --> 00:29:51.000
Và điều này đang được thực hiện trong tầm nhìn rõ ràng khi chúng tôi ngày càng tận dụng các gói mã nguồn mở.

00:29:51.000 --> 00:30:01.000
Chúng tôi đang cố tình phát hành các gói này sớm, trong khi chúng vẫn mềm dẻo và chúng tôi đang phát triển chúng như những nỗ lực cộng đồng trên GitHub.

00:30:01.000 --> 00:30:02.000
Vì vậy hãy thử chúng.

00:30:02.000 --> 00:30:05.000
Nộp một vấn đề. Mở một yêu cầu kéo.

00:30:05.000 --> 00:30:11.000
Đây chưa bao giờ là thời điểm tốt hơn, và việc tham gia và tạo ra tác động chưa bao giờ dễ dàng hơn thế.

00:30:11.000 --> 00:30:16.000
Tôi hy vọng bạn cũng hào hứng với những gói Swift mới này như chúng tôi.

00:30:16.000 --> 00:30:19.000
Chúng tôi nóng lòng muốn xem bạn xây dựng những gì với những thứ này!

00:30:19.000 --> 00:30:23.000
Cảm ơn bạn đã xem, và tận hưởng phần còn lại của hội nghị!

00:30:23.000 --> 23:59:59.000
♪

