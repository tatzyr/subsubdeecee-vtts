WEBVTT

00:00:02.000 --> 00:00:12.000
Xin chào, tên tôi là Tony, và tôi là một kỹ sư trong nhóm Foundation.

00:00:12.000 --> 00:00:19.000
Chào mừng đến với "Có gì mới trong Foundation." Khung nền tảng cung cấp chức năng cơ bản cho tất cả các ứng dụng và khuôn khổ.

00:00:19.000 --> 00:00:25.000
Nó có rất nhiều tính năng, bao gồm mọi thứ từ xử lý tệp đến kết nối mạng và thông báo.

00:00:25.000 --> 00:00:31.000
Hôm nay tôi muốn tập trung vào thứ mà tất cả các ứng dụng cần: quốc tế hóa và bản địa hóa.

00:00:31.000 --> 00:00:36.000
Trong các bản phát hành năm nay, chúng tôi có một số tiến bộ lớn nhất từ trước đến nay trong API này.

00:00:36.000 --> 00:00:43.000
Chúng tôi bắt đầu ở mức thấp, suy nghĩ lại về chuỗi được quy cho là gì trong Swift.

00:00:43.000 --> 00:00:50.000
Chúng tôi đã xây dựng lại các trình định dạng của mình cho Swift, giúp chúng nhanh hơn, dễ sử dụng hơn và thêm các tính năng mới.

00:00:50.000 --> 00:00:55.000
Và cuối cùng, chúng tôi có một tính năng hoàn toàn mới được gọi là thỏa thuận ngữ pháp tự động.

00:00:55.000 --> 00:01:02.000
Nó làm giảm đáng kể số lượng chuỗi bản địa hóa mà bạn cần cung cấp đồng thời làm cho mã của bạn đơn giản hơn.

00:01:02.000 --> 00:01:05.000
Hãy nhảy ngay vào các chuỗi được quy kết.

00:01:05.000 --> 00:01:12.000
Một chuỗi được gán là sự kết hợp của các ký tự, một tập hợp các phạm vi và một từ điển.

00:01:12.000 --> 00:01:20.000
Các chuỗi thuộc tính cho phép bạn liên kết các thuộc tính, là các cặp khóa-giá trị, với một phạm vi cụ thể của một chuỗi.

00:01:20.000 --> 00:01:25.000
Các thuộc tính phổ biến nhất được xác định bởi SDK, nhưng bạn cũng có thể tạo thuộc tính của riêng mình.

00:01:25.000 --> 00:01:30.000
Bạn sẽ thường tìm thấy các chuỗi được gán trong API hỗ trợ văn bản phong phú.

00:01:30.000 --> 00:01:32.000
Hãy xem xét một ví dụ.

00:01:32.000 --> 00:01:34.000
Đây là một ứng dụng tôi đang làm việc có tên là Caffé.

00:01:34.000 --> 00:01:36.000
Đó là một thực đơn đơn giản.

00:01:36.000 --> 00:01:42.000
Tôi chọn thức ăn mà tôi muốn, kích thước, số lượng.

00:01:42.000 --> 00:01:47.000
Và cuối cùng, nó cho tôi thấy một biên lai với danh sách mọi thứ tôi đã đặt hàng.

00:01:47.000 --> 00:01:52.000
Ở phía dưới đây, tôi quyết định thêm một lời cảm ơn ngắn gọn.

00:01:52.000 --> 00:01:54.000
Đây là một chuỗi được quy cho.

00:01:54.000 --> 00:01:58.000
Một phần của chuỗi được in đậm và một phần in nghiêng.

00:01:58.000 --> 00:02:00.000
Từ cuối cùng cũng có một liên kết.

00:02:00.000 --> 00:02:04.000
Như bạn có thể nói ở đây, các thuộc tính có thể trùng lặp.

00:02:04.000 --> 00:02:09.000
Kể từ khi bắt đầu Foundation, chúng tôi đã có một loại tham chiếu được gọi là NSAttributedString.

00:02:09.000 --> 00:02:17.000
Năm nay, chúng tôi giới thiệu một cấu trúc mới AttributedString, tận dụng tối đa tất cả các tính năng mà Swift cung cấp cho chúng tôi.

00:02:17.000 --> 00:02:21.000
Đầu tiên và quan trọng nhất, đó là một loại giá trị.

00:02:21.000 --> 00:02:26.000
Nó cũng có hành vi đếm ký tự giống như Swift String.

00:02:26.000 --> 00:02:34.000
Là một phần trong cam kết của chúng tôi để giúp dễ dàng viết phần mềm bao gồm, AttributedString hiện có thể bản địa hóa hoàn toàn.

00:02:34.000 --> 00:02:37.000
Cuối cùng, nó được xây dựng với sự an toàn và bảo mật trong tâm trí.

00:02:37.000 --> 00:02:45.000
Điều này bao gồm cả an toàn thời gian biên dịch bằng cách sử dụng đánh máy mạnh và cũng an toàn trong quá trình hủy lưu trữ bằng Codable.

00:02:45.000 --> 00:02:51.000
Hãy cùng tham quan ngắn gọn về những gì bạn có thể làm với AttributedString mới.

00:02:51.000 --> 00:02:54.000
Chúng tôi sẽ xây dựng thông điệp cảm ơn của mình.

00:02:54.000 --> 00:02:58.000
Đầu tiên, chúng tôi tạo một chuỗi được quy kết bằng cách sử dụng một trình khởi tạo đơn giản.

00:02:58.000 --> 00:03:01.000
Tôi muốn đặt một thuộc tính trên toàn bộ chuỗi này.

00:03:01.000 --> 00:03:03.000
Điều đó đơn giản như thiết lập thuộc tính phông chữ.

00:03:03.000 --> 00:03:10.000
Trong cấu trúc AttributedString, tất cả các thuộc tính đều có sẵn trực tiếp và chúng sử dụng đúng loại.

00:03:10.000 --> 00:03:14.000
Ví dụ, thuộc tính này là Phông chữ SwiftUI.

00:03:14.000 --> 00:03:17.000
Tiếp theo, chúng tôi tạo ra một chuỗi quy kết khác.

00:03:17.000 --> 00:03:23.000
Đây là một tham chiếu đến trang web của chúng tôi, vì vậy chúng tôi đặt thuộc tính liên kết thành một URL.

00:03:23.000 --> 00:03:26.000
Ở đây tôi đang thiết lập phông chữ và liên kết trên toàn bộ chuỗi.

00:03:26.000 --> 00:03:30.000
Chúng ta sẽ xem xét cách thay đổi chỉ một phần của chuỗi sau.

00:03:30.000 --> 00:03:33.000
Một công cụ hữu ích khác là vùng chứa thuộc tính.

00:03:33.000 --> 00:03:38.000
Đó là nơi bạn có thể tự giữ các thuộc tính và giá trị mà không cần chuỗi.

00:03:38.000 --> 00:03:44.000
Ở đây, tôi tạo một vùng chứa và đặt một số thuộc tính trên đó, tùy thuộc vào tầm quan trọng của tin nhắn của tôi.

00:03:44.000 --> 00:03:49.000
Và cuối cùng, tôi hợp nhất các thuộc tính đó thành cả hai chuỗi được gán.

00:03:49.000 --> 00:03:55.000
Như tôi đã đề cập, chuỗi quy kết là sự kết hợp của các ký tự, phạm vi và từ điển.

00:03:55.000 --> 00:03:59.000
Bản thân chuỗi được quy cho không phải là tập hợp của bất kỳ thứ gì trong số đó.

00:03:59.000 --> 00:04:05.000
Thay vào đó, để có quyền truy cập vào các thuộc tính này, nó có cái mà chúng ta gọi là chế độ xem.

00:04:05.000 --> 00:04:12.000
Hai chế độ xem quan trọng nhất là các ký tự, cung cấp quyền truy cập vào chuỗi và chạy, cung cấp quyền truy cập vào các thuộc tính.

00:04:12.000 --> 00:04:20.000
Những chế độ xem này là bộ sưu tập Swift, có nghĩa là các chức năng bạn quen thuộc từ các loại như Mảng cũng có sẵn ở đây.

00:04:20.000 --> 00:04:23.000
Hãy xem xét một ví dụ khác.

00:04:23.000 --> 00:04:30.000
Giả sử các nhà thiết kế của chúng tôi đã yêu cầu chúng tôi thêm một chút thú vị vào thông điệp cảm ơn của chúng tôi bằng cách làm cho tất cả các dấu câu trở thành một màu cam vui nhộn.

00:04:30.000 --> 00:04:35.000
Để làm điều này, trước tiên tôi cần tìm dấu câu ở đâu trong chuỗi được gán.

00:04:35.000 --> 00:04:43.000
Giống như các bộ sưu tập Swift khác, các chế độ xem chuỗi được quy kết sử dụng các chỉ mục, chỉ đơn giản là một vị trí cho một số phần tử trong bộ sưu tập.

00:04:43.000 --> 00:04:48.000
Để lặp lại theo chỉ mục, tôi sử dụng hàm chỉ mục thư viện tiêu chuẩn.

00:04:48.000 --> 00:04:55.000
Tiếp theo, tôi sử dụng hàm isPunctuation để kiểm tra xem ký tự này có phải là ký tự mà chúng ta cần thay đổi hay không.

00:04:55.000 --> 00:05:02.000
Cuối cùng, tôi sử dụng một tính năng khác của chuỗi được quy kết, cắt lát, để áp dụng một thuộc tính chỉ cho một phạm vi con của toàn bộ chuỗi.

00:05:02.000 --> 00:05:09.000
Phạm vi bắt đầu từ chỉ mục này và tiếp tục cho đến chỉ mục tiếp theo sau đó, vì vậy một ký tự.

00:05:09.000 --> 00:05:11.000
Và bây giờ dấu câu là màu cam.

00:05:11.000 --> 00:05:13.000
Hãy nhìn vào một góc nhìn khác, chạy.

00:05:13.000 --> 00:05:19.000
Chạy là vị trí bắt đầu, độ dài và giá trị của một thuộc tính cụ thể.

00:05:19.000 --> 00:05:22.000
Chúng ta có thể bắt đầu bằng cách đếm tất cả các lần chạy trong tin nhắn của mình.

00:05:22.000 --> 00:05:26.000
Điều này sẽ lặp lại từng phạm vi giá trị thuộc tính liền kề trong chuỗi.

00:05:26.000 --> 00:05:29.000
Có bốn lần chạy trong chuỗi này.

00:05:29.000 --> 00:05:32.000
Mỗi lần chạy có một giá trị hoặc nil cho mỗi thuộc tính.

00:05:32.000 --> 00:05:40.000
Phạm vi từ các ký tự và lần chạy có thể hoán đổi cho nhau, vì vậy bạn có thể tìm thấy chuỗi cho một thuộc tính hoặc ngược lại.

00:05:40.000 --> 00:05:48.000
Ở đây tôi sử dụng phạm vi của thuộc tính trong chỉ số con để xem các ký tự, chuyển đổi kết quả thành một chuỗi độc lập.

00:05:48.000 --> 00:05:53.000
Nó thường hữu ích nhất khi xem xét các lần chạy bằng cách tập trung vào một thuộc tính cụ thể.

00:05:53.000 --> 00:05:58.000
Ở đây, chúng tôi sử dụng liên kết đường dẫn chính để kết hợp chỉ cho thuộc tính liên kết.

00:05:58.000 --> 00:06:07.000
Mỗi phần tử của bộ sưu tập kết quả sẽ cung cấp cho chúng ta giá trị của thuộc tính liên kết, không tính đến các thuộc tính khác có thể được đặt trong chuỗi.

00:06:07.000 --> 00:06:19.000
Nếu chúng ta chỉ nhìn vào các liên kết, chúng ta có ba lần chạy: lần đầu tiên, nơi nó không được đặt; lần thứ hai, nơi nó được đặt thành một giá trị; và lần thứ ba, khoảng thời gian cuối cùng trong câu, nơi nó không được đặt lại.

00:06:19.000 --> 00:06:23.000
Lặp lại các lần chạy cho chúng ta một bộ giá trị và phạm vi.

00:06:23.000 --> 00:06:32.000
Vì các giá trị là loại an toàn, chúng ta có thể sử dụng API, như lược đồ, tồn tại trên URL, mà không cần truyền hoặc lo lắng về việc nhập sai.

00:06:32.000 --> 00:06:37.000
Ở đây tôi đang kiểm tra xem mọi liên kết trong chuỗi được gán có phải là https hay không.

00:06:37.000 --> 00:06:43.000
Một kỹ thuật hữu ích khác là tìm kiếm một chuỗi con và sử dụng phạm vi đó để chỉnh sửa các ký tự hoặc thuộc tính.

00:06:43.000 --> 00:06:48.000
Giả sử tôi muốn thay thế từ "ghé thăm" bằng thứ gì đó có sự rung cảm trở lại nhiều hơn.

00:06:48.000 --> 00:06:51.000
Đầu tiên, tôi tìm phạm vi của một chuỗi con.

00:06:51.000 --> 00:06:58.000
Tiếp theo, tôi sử dụng phạm vi đó để đặt các thuộc tính và ký tự chỉ trên phạm vi con đó.

00:06:58.000 --> 00:07:02.000
Kết quả là một chuỗi được quy cho với sáu lần chạy, như thế này.

00:07:02.000 --> 00:07:05.000
Tiếp theo, hãy nói về bản địa hóa.

00:07:05.000 --> 00:07:08.000
AttributedString hoàn toàn có thể định vị được.

00:07:08.000 --> 00:07:12.000
Chúng tôi cũng đã thêm hỗ trợ bản địa hóa cho NSAttributedString trong Objective-C.

00:07:12.000 --> 00:07:18.000
Các chuỗi thuộc tính được đặt trong các tệp chuỗi ứng dụng của bạn, giống như một chuỗi thông thường.

00:07:18.000 --> 00:07:27.000
Trong Swift, giờ đây chúng tôi hỗ trợ định dạng bản địa hóa của Chuỗi và AttributedString bằng cách sử dụng nội suy chuỗi giống như chế độ xem văn bản của SwiftUI.

00:07:27.000 --> 00:07:29.000
Đây là một ví dụ đơn giản.

00:07:29.000 --> 00:07:35.000
Hàm này trả về một chuỗi được bản địa hóa được tùy chỉnh với tên tài liệu của người dùng.

00:07:35.000 --> 00:07:44.000
Thay vì sử dụng các chỉ định định dạng như %@ hoặc %d và gọi một hàm định dạng, bây giờ bạn có thể chuyển trực tiếp giá trị.

00:07:44.000 --> 00:07:49.000
Cách tiếp cận tương tự hoạt động cho AttributedString.

00:07:49.000 --> 00:07:53.000
Xcode có thể tạo các tệp chuỗi của bạn từ các trình khởi tạo mới này bằng trình biên dịch.

00:07:53.000 --> 00:08:02.000
Để bật nó lên, hãy chuyển đến cài đặt xây dựng của bạn, tìm cài đặt bản địa hóa và bật Sử dụng Trình biên dịch để trích xuất chuỗi Swift.

00:08:02.000 --> 00:08:06.000
Bạn có thể tự hỏi làm thế nào chuỗi được quy kết được bản địa hóa có được các thuộc tính của nó.

00:08:06.000 --> 00:08:10.000
Tôi rất vui được nói với bạn rằng chúng tôi đã thêm hỗ trợ cho Markdown vào AttributedString.

00:08:10.000 --> 00:08:15.000
Đây là một ví dụ về việc sử dụng chuỗi được quy kết được bản địa hóa, ngay trong Văn bản SwiftUI.

00:08:15.000 --> 00:08:18.000
Tôi bắt đầu chỉ với một sợi dây đơn giản.

00:08:18.000 --> 00:08:25.000
Bằng cách thêm hai dấu hoa thị xung quanh văn bản, tôi nhấn mạnh nó, mà SwiftUI hiển thị là in đậm.

00:08:25.000 --> 00:08:32.000
Tôi có thể sử dụng dấu gạch dưới để làm cho văn bản được nhấn mạnh, mà SwiftUI hiển thị dưới dạng in nghiêng.

00:08:32.000 --> 00:08:34.000
Chúng tôi cũng hỗ trợ các liên kết.

00:08:34.000 --> 00:08:41.000
Đây là một cơ hội tuyệt vời để người bản địa hóa cung cấp các URL tùy chỉnh cho các ngôn ngữ khác nhau.

00:08:41.000 --> 00:08:45.000
Chúng tôi cũng hỗ trợ các phong cách nội tuyến khác như gạch ngang và giọng nói mã.

00:08:45.000 --> 00:08:49.000
Cuối cùng, hãy nói về việc lưu trữ các chuỗi được gán.

00:08:49.000 --> 00:08:55.000
Đầu tiên, chúng ta cần khả năng chuyển đổi sang và từ loại tham chiếu NSAttributedString.

00:08:55.000 --> 00:09:01.000
Các chuỗi thuộc tính có thể là một phần của mô hình dữ liệu của bạn, có nghĩa là chúng ta cần có khả năng mã hóa và giải mã chúng.

00:09:01.000 --> 00:09:06.000
Cuối cùng, chúng tôi muốn có một cách để chỉ định các thuộc tính tùy chỉnh trong Markdown.

00:09:06.000 --> 00:09:08.000
Tất cả các hoạt động này đều liên quan đến nhau.

00:09:08.000 --> 00:09:12.000
Hãy bắt đầu bằng cách xem xét chuyển đổi.

00:09:12.000 --> 00:09:20.000
Tất cả chúng tôi đều đã viết rất nhiều mã sử dụng NSAttributedString, vì vậy chúng tôi đã giúp dễ dàng chuyển đổi từ cấu trúc sang loại lớp.

00:09:20.000 --> 00:09:24.000
Đây là một chế độ xem có thuộc tính NSAttributedString.

00:09:24.000 --> 00:09:30.000
Để chuyển đổi, chỉ cần chuyển cấu trúc AttributedString của chúng tôi sang trình khởi tạo NSAttributedString.

00:09:30.000 --> 00:09:35.000
Đối với các thuộc tính là một phần của SDK, đây là tất cả những gì tôi cần làm.

00:09:35.000 --> 00:09:38.000
Bây giờ hãy xem xét mã hóa và giải mã.

00:09:38.000 --> 00:09:41.000
Đây là một cấu trúc chứa biên lai từ ứng dụng Caffé của chúng tôi.

00:09:41.000 --> 00:09:48.000
Một lần nữa, tôi đang sử dụng các thuộc tính được cung cấp bởi SwiftUI, UIKit, AppKit và Foundation.

00:09:48.000 --> 00:09:53.000
Điều đó có nghĩa là việc triển khai Codable mặc định của AttributedString là tất cả những gì tôi cần.

00:09:53.000 --> 00:09:58.000
Tôi chỉ cần thêm sự phù hợp của Codable vào Biên lai, và tôi đã hoàn tất.

00:09:58.000 --> 00:10:02.000
Hãy đi xa hơn một chút và thêm hỗ trợ để mã hóa một thuộc tính tùy chỉnh.

00:10:02.000 --> 00:10:05.000
Chúng ta sẽ bắt đầu bằng cách nói về bản thân thuộc tính.

00:10:05.000 --> 00:10:09.000
Một thuộc tính là hai phần: một khóa và một giá trị.

00:10:09.000 --> 00:10:13.000
Khóa là một loại phù hợp với giao thức AttributedStringKey mới.

00:10:13.000 --> 00:10:19.000
Điều đó xác định loại giá trị mà nó yêu cầu và tên để lưu trữ.

00:10:19.000 --> 00:10:25.000
Khóa này cũng có thể phù hợp với các giao thức khác để tùy chỉnh cách giá trị được mã hóa hoặc giải mã.

00:10:25.000 --> 00:10:30.000
Giả sử chúng ta muốn xác định một phạm vi của một chuỗi được quy kết để có thêm một số màu sắc.

00:10:30.000 --> 00:10:35.000
Hiệu ứng cầu vồng này có ba cấp độ: đơn giản, vui vẻ hoặc cực đoan.

00:10:35.000 --> 00:10:41.000
Chúng tôi sẽ sử dụng một enum để biểu diễn giá trị đó và đặt tên thành cầu vồng.

00:10:41.000 --> 00:10:47.000
Xác định loại và tên là những yêu cầu duy nhất của giao thức này.

00:10:47.000 --> 00:10:53.000
Bây giờ, giả sử chúng tôi muốn tạo thuộc tính này Codable để nó sẽ là một phần của chuỗi được gán được mã hóa.

00:10:53.000 --> 00:10:57.000
Tất cả những gì tôi phải làm là thêm sự phù hợp của Codable, như thế này.

00:10:57.000 --> 00:11:02.000
Cuối cùng, giả sử chúng ta muốn mức cầu vồng là một phần của chuỗi cục bộ của chúng ta.

00:11:02.000 --> 00:11:08.000
Điều đó có nghĩa là nó có thể được áp dụng cho phần bên phải của chuỗi, bất kể nó ở đâu, trong bất kỳ ngôn ngữ nào.

00:11:08.000 --> 00:11:14.000
Tất cả những gì chúng ta cần là thêm một sự phù hợp giao thức để chọn tham gia.

00:11:14.000 --> 00:11:22.000
Khi chúng ta nói rằng một thuộc tính là Markdown có thể giải mã được, thì chúng ta có thể giải mã nó trực tiếp từ Markdown và chèn nó vào một chuỗi được gán.

00:11:22.000 --> 00:11:25.000
Tất cả những gì được yêu cầu là giá trị là Codable.

00:11:25.000 --> 00:11:29.000
Tiếp theo, chúng ta hãy xem cú pháp thuộc tính tùy chỉnh cho Markdown.

00:11:29.000 --> 00:11:32.000
Trong ví dụ đầu tiên này, chúng tôi có một tham chiếu đến một liên kết.

00:11:32.000 --> 00:11:39.000
Nó sử dụng dấu ngoặc vuông cho văn bản liên kết và dấu ngoặc đơn cho đích liên kết, một URL.

00:11:39.000 --> 00:11:42.000
Trong ví dụ thứ hai này, chúng ta có một tham chiếu đến một hình ảnh.

00:11:42.000 --> 00:11:50.000
Nó bắt đầu bằng một dấu chấm than, sau đó sử dụng dấu ngoặc vuông cho mô tả hình ảnh và dấu ngoặc đơn cho nguồn hình ảnh.

00:11:50.000 --> 00:11:53.000
Hai ví dụ đầu tiên này phổ biến trong Markdown.

00:11:53.000 --> 00:11:57.000
Ví dụ thứ ba cho thấy cú pháp của chúng tôi cho các thuộc tính tùy chỉnh.

00:11:57.000 --> 00:12:03.000
Nó bắt đầu bằng dấu mũ, sau đó sử dụng dấu ngoặc vuông cho văn bản và dấu ngoặc đơn cho các thuộc tính của nó.

00:12:03.000 --> 00:12:06.000
Các thuộc tính được thể hiện bằng JSON 5.

00:12:06.000 --> 00:12:13.000
JSON 5 tương thích với JSON và cho phép các phím không được trích dẫn, nhận xét và một vài tính năng khác.

00:12:13.000 --> 00:12:17.000
Nó phù hợp với một sợi dây thân thiện với con người như thế này.

00:12:17.000 --> 00:12:22.000
Chúng tôi cũng đã thêm hỗ trợ JSON 5 vào API JSON khác của chúng tôi trong Foundation.

00:12:22.000 --> 00:12:31.000
Bởi vì các thuộc tính tùy chỉnh sử dụng JSON, mọi thứ có thể được giải mã bằng JSONDecoder sẽ tự động tương thích với cú pháp Markdown tùy chỉnh mới.

00:12:31.000 --> 00:12:39.000
Ở đây chúng ta có một thuộc tính duy nhất, hai thuộc tính, một chuỗi và một số, và một thuộc tính duy nhất với nhiều thuộc tính.

00:12:39.000 --> 00:12:45.000
Chỉ có một phần bổ sung ở đây, đó là cách chúng tôi kết nối những cái tên này trong Markdown với một loại Swift.

00:12:45.000 --> 00:12:47.000
Mảnh đó được gọi là phạm vi thuộc tính.

00:12:47.000 --> 00:12:50.000
Phạm vi là một nhóm các khóa thuộc tính.

00:12:50.000 --> 00:13:00.000
Phạm vi rất hữu ích khi giải mã từ JSON hoặc Markdown, bởi vì chúng cho chúng ta biết thuộc tính nào chúng ta mong đợi tìm thấy, tên của chúng và cách giải mã chúng.

00:13:00.000 --> 00:13:06.000
Chúng tôi xác định mỗi phạm vi cho Foundation, UIKit, AppKit và SwiftUI.

00:13:06.000 --> 00:13:10.000
Bạn cũng có thể xác định phạm vi thuộc tính của riêng mình.

00:13:10.000 --> 00:13:13.000
Hãy xác định phạm vi cho Ứng dụng Caffé của chúng tôi.

00:13:13.000 --> 00:13:19.000
Chúng tôi sẽ lồng phạm vi bên trong AttributeScopes và phù hợp với giao thức AttributeScope.

00:13:19.000 --> 00:13:28.000
Sau đó, tất cả những gì chúng ta cần làm là liệt kê các thuộc tính bên trong phạm vi của chúng ta với "cho thuê". Cho đến nay, chúng tôi chỉ có thuộc tính cầu vồng của mình.

00:13:28.000 --> 00:13:32.000
Tiếp theo, chúng tôi sẽ bao gồm phạm vi SwiftUI bên trong phạm vi của chúng tôi.

00:13:32.000 --> 00:13:36.000
Điều đó cho phép tất cả các thuộc tính đó ngoài thuộc tính của chúng ta.

00:13:36.000 --> 00:13:40.000
Phạm vi lồng nhau đệ quy, vì vậy điều này cũng bao gồm các thuộc tính Nền tảng.

00:13:40.000 --> 00:13:43.000
Thật hữu ích khi xác định một thuộc tính cho phạm vi mới của chúng tôi.

00:13:43.000 --> 00:13:48.000
Điều đó cho phép chúng tôi sử dụng cú pháp đường dẫn chính trong các hàm lấy phạm vi làm đối số.

00:13:48.000 --> 00:13:54.000
Cuối cùng, bây giờ chúng ta có thể tải chuỗi được quy kết được bản địa hóa và đầy màu sắc của mình từ Markdown tùy chỉnh.

00:13:54.000 --> 00:14:00.000
Bạn cũng sẽ tìm thấy các chức năng lấy phạm vi để lưu trữ và chuyển đổi đến và từ NSAttributedString.

00:14:00.000 --> 00:14:04.000
Điều này cho phép tùy chỉnh hành vi ở mọi bước.

00:14:04.000 --> 00:14:10.000
Đây là màn hình đầu tiên của ứng dụng Caffé một lần nữa, nơi bạn có thể thấy thuộc tính cầu vồng tùy chỉnh của chúng tôi trong tiêu đề.

00:14:10.000 --> 00:14:21.000
Sau khi chuỗi được bản địa hóa được chuyển đổi từ Markdown thành chuỗi được gán, ứng dụng sẽ tìm thuộc tính và áp dụng hiệu ứng thú vị cho chỉ phạm vi đó của chuỗi.

00:14:21.000 --> 00:14:29.000
Bởi vì thuộc tính đến từ tệp chuỗi được bản địa hóa của chúng tôi, điều này hoạt động chính xác cho tất cả các ngôn ngữ mà Caffé hỗ trợ, như tiếng Tây Ban Nha.

00:14:29.000 --> 00:14:31.000
Tuy nhiên, chúng tôi chỉ mới bắt đầu.

00:14:31.000 --> 00:14:35.000
Chúng tôi cũng có một Formatter API hoàn toàn mới.

00:14:35.000 --> 00:14:38.000
Formatters là một tính năng Foundation lâu năm khác.

00:14:38.000 --> 00:14:47.000
Họ chịu trách nhiệm lấy dữ liệu, như số, ngày tháng, giờ và hơn thế nữa và chuyển đổi nó thành một chuỗi được bản địa hóa và có thể trình bày bởi người dùng.

00:14:47.000 --> 00:14:54.000
Các trình định dạng được hỗ trợ bởi khá nhiều dữ liệu cấu hình, vì vậy đây là một mẫu phổ biến để lưu trữ và sử dụng lại chúng.

00:14:54.000 --> 00:14:57.000
Tuy nhiên, các ứng dụng bao gồm nhiều đoạn mã riêng biệt.

00:14:57.000 --> 00:15:02.000
Có thể không phải lúc nào cũng có ý nghĩa khi chia sẻ một trình định dạng giữa tất cả chúng.

00:15:02.000 --> 00:15:14.000
Ngoài ra, vì có rất nhiều cách mà mọi người đọc ngày và giờ, cộng với mong muốn của chúng tôi với tư cách là tác giả ứng dụng để trình bày dữ liệu này theo cách phù hợp với thiết kế của chúng tôi, có rất nhiều cơ hội cho các trường hợp cạnh tranh.

00:15:14.000 --> 00:15:21.000
Năm nay, chúng tôi đã cải thiện cả hiệu suất và khả năng sử dụng bằng cách xem xét lại API Formatter của chúng tôi từ đầu.

00:15:21.000 --> 00:15:25.000
Tóm lại, các API mới của chúng tôi tập trung vào định dạng.

00:15:25.000 --> 00:15:31.000
Chúng ta hãy xem mã này từ ứng dụng mẫu Động đất, nơi chúng ta có thể thấy mẫu bộ nhớ đệm đang hoạt động.

00:15:31.000 --> 00:15:34.000
Nó có một quy trình gồm hai bước.

00:15:34.000 --> 00:15:37.000
Đầu tiên, tạo và cấu hình một bộ định dạng.

00:15:37.000 --> 00:15:41.000
Tiếp theo, cung cấp cho người định dạng ngày của chúng tôi và lấy một chuỗi.

00:15:41.000 --> 00:15:43.000
Làm thế nào nó có thể đơn giản hơn?

00:15:43.000 --> 00:15:47.000
Chà, hãy bắt đầu bằng cách loại bỏ yêu cầu tạo trình định dạng ngày của riêng chúng ta.

00:15:47.000 --> 00:15:54.000
Thật dễ dàng để quên rằng điều này cần được lưu vào bộ nhớ cache, điều này sẽ dẫn đến việc tạo lại cùng một trình định dạng cho mọi ô trong bảng.

00:15:54.000 --> 00:15:56.000
Tiếp theo, bước định dạng.

00:15:56.000 --> 00:16:01.000
Thay vì chuyển ngày của chúng ta qua trình định dạng, hãy sử dụng chính ngày đó.

00:16:01.000 --> 00:16:03.000
Bây giờ nó chỉ là một dòng mã.

00:16:03.000 --> 00:16:07.000
Bạn chỉ định định dạng bạn muốn, và thế là xong.

00:16:07.000 --> 00:16:10.000
Hãy nói nhiều hơn về định dạng số này.

00:16:10.000 --> 00:16:15.000
Nó không có nhiều mã, nhưng nó đang che giấu một số phức tạp và có một vài cạm bẫy cần lưu ý.

00:16:15.000 --> 00:16:21.000
Nếu đối số không phải là số dấu phẩy động, bạn sẽ nhận được đầu ra hoàn toàn sai ở đây.

00:16:21.000 --> 00:16:30.000
Người đọc phải nhận thức được cú pháp trường hợp đặc biệt để định dạng số dấu phẩy động, cùng với một tập hợp các công cụ sửa đổi chỉ là hằng số chuỗi.

00:16:30.000 --> 00:16:35.000
Chúng tôi nghĩ rằng mã này dễ hiểu, bảo trì và dễ đọc hơn.

00:16:35.000 --> 00:16:40.000
Nó sử dụng các hàm Swift thông thường để xác định chính xác cách chúng tôi muốn số của mình được định dạng.

00:16:40.000 --> 00:16:44.000
Bạn cũng nhận được sự tự động hoàn thành và loại an toàn.

00:16:44.000 --> 00:16:48.000
Chúng tôi đã áp dụng cách tiếp cận mới này cho tất cả mười người định dạng trong Foundation.

00:16:48.000 --> 00:16:57.000
Chúng tôi đã dọn dẹp và đơn giản hóa các giao diện, thực hiện các thay đổi để giúp tránh những cạm bẫy phổ biến và thêm một loạt các tính năng mới trên đường đi.

00:16:57.000 --> 00:17:04.000
Chúng ta hãy xem xét chi tiết hai trong số các loại được định dạng phổ biến nhất: ngày tháng và số.

00:17:04.000 --> 00:17:13.000
Định dạng ngày là về việc sử dụng lịch và múi giờ để chuyển đổi một thời điểm tuyệt đối thành thứ mà con người hiểu là ngày.

00:17:13.000 --> 00:17:20.000
Và thậm chí còn hơn thế nữa, nó tính đến tất cả các sở thích mà con người có về cách họ thích ngày tháng của chính họ trông như thế nào.

00:17:20.000 --> 00:17:23.000
Chúng tôi gọi những địa phương ưu tiên đó.

00:17:23.000 --> 00:17:28.000
Chúng ta hãy xem một lượng mã nhỏ bạn cần để định dạng một ngày.

00:17:28.000 --> 00:17:33.000
Đầu tiên, tôi sẽ có được thời điểm hiện tại bằng cách sử dụng Date.now.

00:17:33.000 --> 00:17:35.000
Tiếp theo, tôi gọi hàm được định dạng.

00:17:35.000 --> 00:17:37.000
Thế là xong.

00:17:37.000 --> 00:17:42.000
Tất nhiên, như chúng ta vừa thấy trong ví dụ của mình, định dạng ngày là thứ có rất nhiều lựa chọn.

00:17:42.000 --> 00:17:45.000
Vì vậy, hãy mở rộng điều này ra một chút.

00:17:45.000 --> 00:17:51.000
Chức năng được định dạng có thể được cấu hình để chỉ hiển thị ngày hoặc chỉ thời gian.

00:17:51.000 --> 00:17:55.000
Cả hai lập luận đó đều có một số lựa chọn để lựa chọn.

00:17:55.000 --> 00:18:03.000
Một mục tiêu quan trọng cho API định dạng mới này là cung cấp càng nhiều thời gian biên dịch càng tốt trong việc tạo ra các định dạng chính xác.

00:18:03.000 --> 00:18:16.000
Định dạng bằng cách sử dụng các giá trị chuỗi ma thuật nổi tiếng với việc tạo ra những cạm bẫy, trong đó định dạng có vẻ chính xác trong các trường hợp bình thường nhưng tạo ra giá trị hoàn toàn sai trong các trường hợp cạnh, như vào cuối năm.

00:18:16.000 --> 00:18:19.000
Đây lại là định dạng mặc định của chúng tôi.

00:18:19.000 --> 00:18:24.000
Đây là một phiên bản ngắn của kiểu yêu cầu ngày và giờ, như thế này.

00:18:24.000 --> 00:18:29.000
Đối với cả phiên bản không tranh luận và phong cách đơn giản, chúng tôi chọn một định dạng mặc định cho bạn.

00:18:29.000 --> 00:18:36.000
Tuy nhiên, nếu bạn thực sự muốn tùy chỉnh ngày, bạn chỉ cần đi từ đây và thêm các trường bạn quan tâm.

00:18:36.000 --> 00:18:41.000
Trong ví dụ này, tôi xây dựng một định dạng bằng cách thêm các trường vào kiểu.

00:18:41.000 --> 00:18:45.000
Tôi chỉ muốn năm, ngày và tháng.

00:18:45.000 --> 00:18:49.000
Các khả năng khác bao gồm giờ, phút, giây, v.v.

00:18:49.000 --> 00:18:55.000
Định dạng đầu ra sẽ tự động điều chỉnh theo ngôn ngữ của người dùng.

00:18:55.000 --> 00:18:57.000
Những trường này cũng có thể cấu hình được.

00:18:57.000 --> 00:19:04.000
Trong trường hợp này, tôi thay đổi tháng sang định dạng rộng, có nghĩa là tên tháng đầy đủ được in.

00:19:04.000 --> 00:19:08.000
Định dạng chỉ một phần của ngày cũng dễ dàng với API này.

00:19:08.000 --> 00:19:10.000
Ở đây tôi chỉ muốn có được ngày trong tuần.

00:19:10.000 --> 00:19:13.000
Ngày tháng cũng có thể được định dạng thành các phong cách khác nhau.

00:19:13.000 --> 00:19:24.000
Ở đây tôi chọn sử dụng định dạng ISO 8601 và iso8601, nhưng chỉ với năm, tháng và ngày, và được phân tách bằng dấu gạch ngang.

00:19:24.000 --> 00:19:28.000
Với những ví dụ này, mẫu định dạng trở nên rõ ràng.

00:19:28.000 --> 00:19:30.000
Chúng tôi bắt đầu với giá trị mà chúng tôi muốn định dạng.

00:19:30.000 --> 00:19:35.000
Chúng tôi gọi hàm được định dạng và đối số là kiểu.

00:19:35.000 --> 00:19:38.000
Có thể có nhiều hơn một loại phong cách cho mỗi loại.

00:19:38.000 --> 00:19:42.000
Ngày, ví dụ, có cả dateTime và iso8601.

00:19:42.000 --> 00:19:47.000
Phong cách có thể được sử dụng trong cấu hình mặc định hoặc tùy chỉnh.

00:19:47.000 --> 00:19:54.000
API định dạng này hoạt động bằng cách chỉ định một danh sách các trường, một số trong đó có các tùy chọn bổ sung.

00:19:54.000 --> 00:19:57.000
Thứ tự của các trường bạn cung cấp không quan trọng.

00:19:57.000 --> 00:20:04.000
Mỗi trường chỉ cho người định dạng biết những giá trị nào nên được bao gồm ở đâu đó trong đầu ra cuối cùng.

00:20:04.000 --> 00:20:11.000
Chúng tôi chọn một mặc định hợp lý cho các phiên bản ngắn nhất của API, những phiên bản không có đối số hoặc chỉ là tên kiểu.

00:20:11.000 --> 00:20:22.000
Khi bạn bắt đầu thêm các trường vào đó, đầu ra sẽ được tùy chỉnh và chỉ phản ánh những gì bạn chọn hiển thị, giống như văn bản giữ chỗ trong giao diện người dùng của bạn.

00:20:22.000 --> 00:20:26.000
Ngoài ra còn có một API mới để định dạng hai ngày có liên quan đến nhau.

00:20:26.000 --> 00:20:29.000
Đây là một số ví dụ.

00:20:29.000 --> 00:20:32.000
Đầu tiên, định dạng hai ngày trong một phạm vi.

00:20:32.000 --> 00:20:38.000
Bạn chỉ có thể sử dụng cú pháp dải Swift thông thường với hai ngày.

00:20:38.000 --> 00:20:45.000
Phạm vi định dạng cho phép cấu hình hiển thị ngày và giờ, giống như chúng tôi đã làm với một ngày duy nhất.

00:20:45.000 --> 00:20:53.000
Bạn có thể định dạng phạm vi này dưới dạng thời lượng hoặc dưới dạng các thành phần hoặc một ngày duy nhất liên quan đến ngay bây giờ.

00:20:53.000 --> 00:20:56.000
Một tính năng mới khác trong định dạng là đầu ra được quy cho.

00:20:56.000 --> 00:21:05.000
Điều này cho phép bạn tìm vị trí mà trình định dạng đặt một phần cụ thể của giá trị được định dạng sau khi sắp xếp lại xong để phù hợp với sở thích của người dùng.

00:21:05.000 --> 00:21:09.000
Tất nhiên, điều này sử dụng cấu trúc mới của chúng tôi AttributedString.

00:21:09.000 --> 00:21:13.000
Áp dụng kiểu dáng cho đầu ra được định dạng hiển thị ở tất cả các loại nơi.

00:21:13.000 --> 00:21:17.000
Trên watchOS, nhiều biến chứng là các chuỗi được định dạng.

00:21:17.000 --> 00:21:30.000
Vì Apple Watch là một thiết bị cá nhân như vậy, điều quan trọng là phải tính đến sở thích của người dùng, nhưng đây cũng là nơi chúng tôi muốn áp dụng một loại ngôn ngữ thiết kế nhất định, chẳng hạn như cho một phần của ngày một màu do người dùng lựa chọn.

00:21:30.000 --> 00:21:34.000
Thiết lập điều này thực sự khá thú vị trong SwiftUI.

00:21:34.000 --> 00:21:36.000
Hãy cùng nhau xem xét nó trong một bản demo.

00:21:36.000 --> 00:21:42.000
Ở đây tôi có điểm khởi đầu cho ứng dụng đồng hành Caffé của mình, ứng dụng này hiển thị khi nào cà phê miễn phí tiếp theo của bạn.

00:21:42.000 --> 00:21:48.000
Tôi có chế độ xem SwiftUI chỉ hiển thị ngày được định dạng.

00:21:48.000 --> 00:21:56.000
Tôi đã đặt ngôn ngữ trên định dạng để tôi có thể kiểm soát nó bằng bản xem trước SwiftUI của mình tại đây.

00:21:56.000 --> 00:22:02.000
Đó là một khởi đầu khá tốt, nhưng tôi muốn tùy chỉnh nó nhiều hơn một chút.

00:22:02.000 --> 00:22:06.000
Hãy bắt đầu bằng cách làm cho điều này cụ thể hơn một chút cho ứng dụng của tôi.

00:22:06.000 --> 00:22:15.000
Tôi chỉ quan tâm đến phút, giờ và các ngày trong tuần.

00:22:15.000 --> 00:22:20.000
Được rồi, trông khá ổn. Bây giờ hãy thêm một chút màu sắc.

00:22:20.000 --> 00:22:33.000
Đầu tiên, chúng tôi sẽ thay đổi loại trả về thành AttributedString và yêu cầu đầu ra được quy cho.

00:22:33.000 --> 00:22:36.000
Tiếp theo, chúng ta sẽ sử dụng một vùng chứa thuộc tính.

00:22:36.000 --> 00:22:40.000
Chúng có thể giữ các thuộc tính mà không cần gắn vào bất kỳ ký tự cụ thể nào trong một chuỗi.

00:22:40.000 --> 00:22:46.000
Chúng tôi sẽ tạo một cái cho thuộc tính các ngày trong tuần mà các định dạng ngày đưa vào đầu ra của chúng.

00:22:46.000 --> 00:22:52.000
Nó được đặt trên phạm vi của chuỗi chứa các ngày trong tuần.

00:22:52.000 --> 00:23:00.000
Tiếp theo, chúng tôi sẽ tạo một vùng chứa cho thuộc tính màu mà chúng tôi muốn đặt.

00:23:00.000 --> 00:23:13.000
Và cuối cùng, chúng tôi sẽ sử dụng một hàm chuỗi được gán để thay thế các thuộc tính khớp với các thuộc tính trong vùng chứa đầu tiên bằng các giá trị trong vùng chứa thứ hai trên chuỗi được gán của chúng tôi.

00:23:13.000 --> 00:23:26.000
Bởi vì AttributedString là một loại giá trị và thay thế là một hàm đột biến, chúng ta cần thay đổi "let" của mình thành "var". Trông thật tuyệt.

00:23:26.000 --> 00:23:28.000
Thậm chí tốt hơn, nó hoạt động cho tất cả các địa phương.

00:23:28.000 --> 00:23:37.000
Hãy thêm một vài thứ nữa vào bản xem trước của chúng tôi để kiểm tra lại.

00:23:37.000 --> 00:23:43.000
Bạn có thể thấy ở đây rằng các ngày trong tuần có màu cam bất kể nó ở đâu trong ngày được định dạng cho các ngôn ngữ này.

00:23:43.000 --> 00:23:46.000
Hãy tiếp tục tìm hiểu về nhiều API định dạng mới hơn nữa.

00:23:46.000 --> 00:23:53.000
Bây giờ chúng ta đã thấy cách biến ngày tháng thành chuỗi, hãy nói về cách xâu chuỗi thành ngày tháng.

00:23:53.000 --> 00:23:57.000
Date bây giờ có một trình khởi tạo lấy một lập luận chiến lược.

00:23:57.000 --> 00:24:02.000
Chiến lược được sử dụng để cho trình phân tích cú pháp biết những lĩnh vực nào sẽ xảy ra trong đầu vào.

00:24:02.000 --> 00:24:06.000
Đối với ngày tháng, định dạng cũng là một loại chiến lược.

00:24:06.000 --> 00:24:14.000
Điều đó hữu ích cho các ngày quay tròn, như trong trường văn bản vừa hiển thị đầu ra vừa cho phép người dùng nhập ngày mới.

00:24:14.000 --> 00:24:16.000
Đây là một ví dụ về chuyến đi khứ hồi.

00:24:16.000 --> 00:24:18.000
Bạn sẽ nhận thấy rằng việc phân tích cú pháp có thể ném.

00:24:18.000 --> 00:24:23.000
Điều này là do, tùy thuộc vào đầu vào, phân tích cú pháp có thể thất bại.

00:24:23.000 --> 00:24:27.000
Một số chiến lược có các tùy chọn nâng cao hơn để phân tích cú pháp.

00:24:27.000 --> 00:24:34.000
Ở đây, chúng tôi phân tích cú pháp một định dạng cố định, điều này rất hữu ích khi định dạng ngày là thứ nhận được từ máy chủ.

00:24:34.000 --> 00:24:37.000
Để sử dụng nó, hãy khởi tạo một chiến lược với một chuỗi định dạng.

00:24:37.000 --> 00:24:42.000
Tuy nhiên, thay vì sử dụng các giá trị chuỗi ma thuật, chúng tôi sử dụng phép nội suy chuỗi.

00:24:42.000 --> 00:24:48.000
Trong trường hợp này, chúng tôi mong đợi một chuỗi định dạng năm-tháng-ngày.

00:24:48.000 --> 00:24:55.000
Mỗi phép nội suy được xác định rõ ràng theo trường và mỗi nội suy chỉ định chính xác định dạng mong đợi.

00:24:55.000 --> 00:24:59.000
Một điều thực sự tuyệt vời về điều này là trải nghiệm tự động hoàn thành.

00:24:59.000 --> 00:25:07.000
Nếu tôi muốn sử dụng một định dạng ngày khác, tự động hoàn thành sẽ hiển thị cho tôi các tùy chọn hợp lệ cùng với tài liệu về ý nghĩa của từng tùy chọn.

00:25:07.000 --> 00:25:12.000
Không, đoán xem bạn nên sử dụng bao nhiêu ký tự Y để phân tích cú pháp một năm.

00:25:12.000 --> 00:25:13.000
Hãy chuyển sang những con số.

00:25:13.000 --> 00:25:20.000
Định dạng số là chuyển đổi một giá trị số nguyên hoặc dấu phẩy động thành thứ gì đó mà con người có thể đọc được.

00:25:20.000 --> 00:25:24.000
Giống như tất cả các định dạng, nó tính đến các tùy chọn về cách hiển thị các con số.

00:25:24.000 --> 00:25:30.000
Điều này bao gồm mọi thứ từ loại chữ số được sử dụng đến ký tự nào được sử dụng để nhóm các chữ số.

00:25:30.000 --> 00:25:37.000
Như với định dạng ngày, việc có được đầu ra tuyệt vời thật dễ dàng mà không cần thêm thông số nào.

00:25:37.000 --> 00:25:40.000
Có nhiều loại tùy chọn và đầu ra được hỗ trợ.

00:25:40.000 --> 00:25:47.000
Ở đây chúng tôi hiển thị tỷ lệ phần trăm, ký hiệu khoa học và tiền tệ.

00:25:47.000 --> 00:25:50.000
Cuối cùng, hãy đặt một vài định dạng lại với nhau.

00:25:50.000 --> 00:25:54.000
Định dạng danh sách bây giờ chỉ là định dạng một mảng.

00:25:54.000 --> 00:25:59.000
Đối số kiểu thành viên này chỉ định kiểu định dạng của từng phần tử trong mảng.

00:25:59.000 --> 00:26:02.000
Đây là những con số, vì vậy tôi muốn sử dụng một tỷ lệ phần trăm.

00:26:02.000 --> 00:26:05.000
Đầu ra chính xác cho mọi ngôn ngữ của người dùng.

00:26:05.000 --> 00:26:08.000
Cho đến nay chúng tôi đã tập trung vào việc định dạng các giá trị trực tiếp.

00:26:08.000 --> 00:26:13.000
SwiftUI cũng hỗ trợ đính kèm kiểu định dạng vào TextField.

00:26:13.000 --> 00:26:22.000
Vì các kiểu định dạng có thông tin kiểu về các loại giá trị mà chúng định dạng, chúng ta có thể sử dụng cú pháp có thể đọc được nhưng an toàn cho tỷ lệ phần trăm tiền boa trên biên lai của tôi tại đây.

00:26:22.000 --> 00:26:28.000
Hãy xem lại ứng dụng Caffé của chúng tôi và xem có bao nhiêu địa điểm định dạng hiển thị.

00:26:28.000 --> 00:26:31.000
Chúng tôi sử dụng định dạng danh sách cho các thành phần.

00:26:31.000 --> 00:26:34.000
Chúng tôi sử dụng định dạng tiền tệ cho giá cả.

00:26:34.000 --> 00:26:39.000
Chúng tôi sử dụng định dạng số cho số lượng và cũng để bản địa hóa số lượng trong nút đặt hàng.

00:26:39.000 --> 00:26:43.000
Chúng tôi không thể quên định dạng ngày mà bạn luôn thấy ở góc trên đây.

00:26:43.000 --> 00:26:50.000
Bạn sẽ tìm thấy đầu ra được định dạng ở khắp mọi nơi và chúng tôi nghĩ rằng API mới này cũng sẽ làm cho nó dễ dàng, thậm chí thú vị, trong ứng dụng của bạn.

00:26:50.000 --> 00:26:54.000
Có rất nhiều tài nguyên có sẵn để trợ giúp với các chuỗi và định dạng được bản địa hóa.

00:26:54.000 --> 00:27:07.000
Chúng tôi có thêm hai phiên về chủ đề này, "Địa phương hóa ứng dụng SwiftUI của bạn" và "Hợp lý hóa các chuỗi được bản địa hóa của bạn." Tiếp theo, hãy nói về một tính năng mới được gọi là thỏa thuận ngữ pháp tự động.

00:27:07.000 --> 00:27:15.000
Những người bản địa hóa bằng các ngôn ngữ như tiếng Tây Ban Nha đã bị hạn chế về khả năng diễn đạt các bản dịch tự nhiên, đôi khi dẫn đến cuộc đối thoại khó xử.

00:27:15.000 --> 00:27:27.000
Những ngôn ngữ này yêu cầu chuyển đổi để đạt được thỏa thuận về giới tính và số nhiều giữa các phần khác nhau của bài phát biểu và đôi khi thậm chí yêu cầu kiến thức về thuật ngữ địa chỉ ưa thích của người dùng.

00:27:27.000 --> 00:27:33.000
Tiếng Anh cũng có đặc điểm này, với các danh từ có dạng khác nhau cho số ít và số nhiều.

00:27:33.000 --> 00:27:37.000
Tôi đã ném ra rất nhiều biệt ngữ ngôn ngữ ở đó, vì vậy chúng ta hãy xem qua một ví dụ.

00:27:37.000 --> 00:27:42.000
Trong ứng dụng Caffé của tôi, tôi có thể chọn một mặt hàng thực phẩm, kích thước và số lượng.

00:27:42.000 --> 00:27:46.000
Tôi chọn 1 món salad nhỏ.

00:27:46.000 --> 00:27:51.000
Bây giờ bạn tôi nói rằng cô ấy sẽ tham gia cùng tôi, vì vậy tôi tăng số lượng lên 2.

00:27:51.000 --> 00:27:56.000
Trong tiếng Anh, từ "salad" phải thay đổi để khớp với số 2.

00:27:56.000 --> 00:27:58.000
Đây được gọi là thỏa thuận.

00:27:58.000 --> 00:28:03.000
Tất cả những gì có nghĩa là các từ trong câu này phải khớp với nhau.

00:28:03.000 --> 00:28:07.000
Trong tiếng Anh, sửa chữa các từ do số nhiều là một loại thỏa thuận phổ biến.

00:28:07.000 --> 00:28:16.000
Bây giờ hãy chuyển ứng dụng của chúng tôi sang tiếng Tây Ban Nha và gọi 1 ensalada pequeña, hoặc 1 món salad nhỏ.

00:28:16.000 --> 00:28:23.000
Khi tôi đặt hàng cho bạn tôi, nút đặt hàng này cần số nhiều giống như trong tiếng Anh nhưng có một sự thay đổi.

00:28:23.000 --> 00:28:31.000
Trong tiếng Tây Ban Nha, cả tính từ, pequeña và danh từ, ensalada, đều phải đồng ý với count, dos.

00:28:31.000 --> 00:28:37.000
Vì vậy, thay vì ensalada pequeña, nút nói ensaladas pequeñas.

00:28:37.000 --> 00:28:40.000
Tiếp theo, tôi chuyển sang uống rượu.

00:28:40.000 --> 00:28:49.000
Đối với câu này, nút không chỉ cần số nhiều chính xác mà còn cần sự đồng ý về giới tính ngữ pháp của những từ này.

00:28:49.000 --> 00:28:52.000
Nước trái cây, jugo, là nam tính.

00:28:52.000 --> 00:28:56.000
Tính từ pequeño cũng phải khớp.

00:28:56.000 --> 00:29:02.000
Để bản địa hóa văn bản như thế này một cách chính xác, chúng tôi kết thúc với một vụ nổ tổ hợp.

00:29:02.000 --> 00:29:07.000
Cần có một chuỗi cục bộ khác nhau cho mỗi sự kết hợp của thực phẩm, kích thước và số lượng.

00:29:07.000 --> 00:29:15.000
Trong mã, nó thường trông như thế này, nơi chúng ta cần chuyển đổi từng mặt hàng, sau đó chuyển đổi từng kích cỡ, v.v.

00:29:15.000 --> 00:29:21.000
Ngoài ra còn có một tệp stringsdict, có thể đa số hóa từng chuỗi này một cách chính xác để đếm.

00:29:21.000 --> 00:29:31.000
Giờ đây, bằng cách tận dụng cùng một công nghệ hỗ trợ các đề xuất trong bàn phím, chúng tôi đã tạo ra một API mới có thể dễ dàng xử lý tất cả các trường hợp này và hơn thế nữa.

00:29:31.000 --> 00:29:41.000
Chúng tôi gọi tính năng này là thỏa thuận ngữ pháp tự động, bởi vì hệ thống tự động sửa các chuỗi được bản địa hóa để chúng có ngữ pháp chính xác.

00:29:41.000 --> 00:29:43.000
Bây giờ mã trở nên đơn giản hơn nhiều.

00:29:43.000 --> 00:29:48.000
Bạn có thể kết hợp số lượng, kích thước và thức ăn trong một chuỗi.

00:29:48.000 --> 00:29:53.000
Thỏa thuận ngữ pháp tự động sẽ sửa chuỗi cho bạn bằng cách sử dụng một quy trình gọi là biến tố.

00:29:53.000 --> 00:29:54.000
Hãy phá vỡ nó.

00:29:54.000 --> 00:29:59.000
Để biến đổi, chúng ta cần biết phần nào của chuỗi cần được cố định.

00:29:59.000 --> 00:30:05.000
May mắn thay, chúng tôi có một loại trong Swift có thể làm điều đó, AttributedString và một thuộc tính tùy chỉnh trong Markdown.

00:30:05.000 --> 00:30:12.000
Trong chuỗi này, tôi sử dụng cú pháp đó để bọc thức ăn, kích thước và số lượng với thuộc tính biến tố của chúng tôi.

00:30:12.000 --> 00:30:15.000
Giá trị của thuộc tính là đúng.

00:30:15.000 --> 00:30:28.000
Khi chúng tôi xuất bản địa hóa của dự án này, chúng tôi sẽ nhận được một tệp chuỗi chứa chuỗi chú thích của chúng tôi cũng như các chuỗi bản địa hóa khác trong mã nguồn của chúng tôi, như tên của các loại thực phẩm và kích cỡ.

00:30:28.000 --> 00:30:30.000
Đây là các chuỗi cho tiếng Tây Ban Nha Mỹ Latinh.

00:30:30.000 --> 00:30:40.000
Trình bản địa hóa đã sử dụng cú pháp sắp xếp lại đối số %1, %3, %2, bởi vì một tính từ như "nhỏ" hoặc "lớn" đi trước danh từ trong tiếng Tây Ban Nha.

00:30:40.000 --> 00:30:48.000
Họ giữ cú pháp thuộc tính tùy chỉnh để biến đổi vùng này của chuỗi và cung cấp bản dịch cho thực phẩm và kích cỡ.

00:30:48.000 --> 00:30:51.000
Công cụ ngữ pháp tự động đảm nhận việc sửa chữa phần còn lại.

00:30:51.000 --> 00:30:59.000
Một số ngôn ngữ có sự đồng ý không chỉ giữa các từ trong chính văn bản bản địa hóa mà còn giữa văn bản đó và người đọc nó.

00:30:59.000 --> 00:31:02.000
Thỏa thuận ngữ pháp tự động cũng có thể giúp ích cho điều đó.

00:31:02.000 --> 00:31:05.000
Ví dụ, chúng ta hãy xem màn hình chào mừng này cho Ghi chú.

00:31:05.000 --> 00:31:17.000
Trong tiếng Anh, chúng tôi nói "Chào mừng đến với Ghi chú." Trong tiếng Tây Ban Nha, chúng tôi nói "Te damos la bienvenida a Notas," hoặc "Chúng tôi chào mừng bạn đến với Notes." Chúng tôi muốn có trải nghiệm tiếng Tây Ban Nha giống như chúng tôi làm bằng tiếng Anh.

00:31:17.000 --> 00:31:24.000
Tuy nhiên, trong tiếng Tây Ban Nha, từ "bienvenido" phải khớp với thuật ngữ địa chỉ ưa thích của người dùng.

00:31:24.000 --> 00:31:29.000
Thuật ngữ này có thể là một trong nhiều lựa chọn và lựa chọn đó sẽ thay đổi văn bản.

00:31:29.000 --> 00:31:34.000
Sử dụng thuật ngữ địa chỉ chính xác dẫn đến trải nghiệm cá nhân và toàn diện hơn.

00:31:34.000 --> 00:31:40.000
Trong các bản phát hành năm nay, chúng tôi đã giúp những người sử dụng tiếng Tây Ban Nha có thể chỉ định thời hạn địa chỉ của họ.

00:31:40.000 --> 00:31:44.000
Trong cài đặt Ngôn ngữ &amp; Khu vực, có một tùy chọn Điều khoản Địa chỉ mới.

00:31:44.000 --> 00:31:51.000
Khi bạn chọn nó, bạn có thể chọn sở thích của mình và cũng có thể chọn chia sẻ nó với tất cả các ứng dụng.

00:31:51.000 --> 00:31:55.000
Tại đây, bạn thấy màn hình chào mừng mới trong Ghi chú cho một thuật ngữ địa chỉ nữ tính.

00:31:55.000 --> 00:31:57.000
Và đây là một thuật ngữ địa chỉ nam tính.

00:31:57.000 --> 00:32:03.000
Nếu chúng tôi không biết hoặc người dùng không muốn chỉ định, chúng tôi giữ chuỗi ban đầu của mình như một giải pháp thay thế.

00:32:03.000 --> 00:32:09.000
Thuộc tính biến tố tương tự mà chúng ta đã thấy trước đó cũng được sử dụng trong các chuỗi cục bộ đề cập đến người dùng.

00:32:09.000 --> 00:32:14.000
Trong trường hợp "chào mừng đến" của chúng tôi, chúng tôi áp dụng thuộc tính biến tố cho từ bienvenido.

00:32:14.000 --> 00:32:17.000
Chuỗi tiếng Anh không cần thay đổi.

00:32:17.000 --> 00:32:25.000
Tôi cũng có thể thêm một giải pháp thay thế uốn, đó là một chuỗi thay thế mà công cụ sẽ sử dụng nếu nó không có thông tin về sở thích của người dùng.

00:32:25.000 --> 00:32:29.000
Năm nay, chúng tôi hỗ trợ thỏa thuận tự động cho tiếng Tây Ban Nha và tiếng Anh.

00:32:29.000 --> 00:32:34.000
Chúng tôi đã áp dụng nó ở một số nơi trên hệ điều hành, như màn hình chào mừng trong Ghi chú.

00:32:34.000 --> 00:32:36.000
Bạn cũng có thể áp dụng nó trong các ứng dụng của mình.

00:32:36.000 --> 00:32:41.000
Những thay đổi mã được yêu cầu chủ yếu chỉ là xóa rất nhiều logic để chọn các chuỗi khác nhau.

00:32:41.000 --> 00:32:50.000
Các hướng dẫn về những gì cần biến đổi là một phần của chính chuỗi được bản địa hóa, cho phép người bản địa hóa kiểm soát nhiều hơn cách chuỗi xuất hiện trong ngôn ngữ của họ.

00:32:50.000 --> 00:32:54.000
Hãy cùng xem xét thỏa thuận ngữ pháp tự động đang hoạt động cho ứng dụng Caffé của chúng tôi.

00:32:54.000 --> 00:32:57.000
Hãy xem qua ứng dụng Caffé đang chạy bằng tiếng Anh.

00:32:57.000 --> 00:33:02.000
Tôi sẽ bắt đầu bằng cách thêm một ít bánh pizza vào đơn đặt hàng.

00:33:02.000 --> 00:33:05.000
Tôi nghĩ tôi sẽ có một cái lớn. Và chỉ 1.

00:33:05.000 --> 00:33:10.000
Chú ý cách văn bản trên nút đã thay đổi từ 0 bánh pizza lớn thành 1 bánh pizza lớn.

00:33:10.000 --> 00:33:12.000
Điều đó đã được thực hiện tự động.

00:33:12.000 --> 00:33:16.000
Nếu tôi chọn 2, nó sẽ sửa nó một lần nữa.

00:33:16.000 --> 00:33:19.000
Tôi sẽ chỉ có một cái.

00:33:19.000 --> 00:33:23.000
Ở cuối màn hình này, nút đặt hàng đã thay đổi thành 1 mặt hàng.

00:33:23.000 --> 00:33:27.000
Uống gì đó thì sao?

00:33:27.000 --> 00:33:31.000
Nhỏ là ổn, và chỉ 1 trong số này.

00:33:31.000 --> 00:33:35.000
Chú ý cách nút đã thay đổi để nói "mục" thay vì "mục"?

00:33:35.000 --> 00:33:37.000
Chuỗi đó đã được thay đổi tự động.

00:33:37.000 --> 00:33:41.000
Hãy kiểm tra.

00:33:41.000 --> 00:33:43.000
Đây là biên lai của chúng tôi.

00:33:43.000 --> 00:33:46.000
Nó liệt kê pizza và nước trái cây của chúng tôi, cùng với giá định dạng.

00:33:46.000 --> 00:33:51.000
Ở dưới cùng là chuỗi được quy cho của chúng tôi, với phông chữ tùy chỉnh và liên kết đến trang web.

00:33:51.000 --> 00:33:54.000
Hãy quay lại Xcode và xem nguồn.

00:33:54.000 --> 00:34:01.000
Tôi sẽ bắt đầu trong chế độ xem chi tiết đồ ăn.

00:34:01.000 --> 00:34:04.000
Đây là chế độ xem hiển thị màn hình lựa chọn kích thước.

00:34:04.000 --> 00:34:15.000
Hãy thêm một kích thước mới để chúng ta có thể thấy điều đó chỉ yêu cầu chúng ta thêm một chuỗi bản địa hóa cho tiếng Tây Ban Nha thay vì một chuỗi cho mỗi loại thực phẩm, mỗi kích thước và mỗi lần đếm.

00:34:15.000 --> 00:34:17.000
Dòng này hiển thị danh sách.

00:34:17.000 --> 00:34:19.000
Danh sách đến từ đối tượng mô hình của chúng tôi.

00:34:19.000 --> 00:34:24.000
Hãy đến đó.

00:34:24.000 --> 00:34:27.000
Kích thước enum đã có kích thước nhỏ và lớn.

00:34:27.000 --> 00:34:38.000
Tôi sẽ thêm một kích thước mới cho những khách hàng khao khát nhất của chúng tôi, được gọi là "khổng lồ". Để làm điều đó, tôi sẽ thêm một trường hợp mới, cùng với một chuỗi được bản địa hóa.

00:34:38.000 --> 00:34:41.000
Bây giờ tôi chỉ cần thêm giá cho kích thước lớn.

00:34:41.000 --> 00:34:44.000
Đối với bản demo này, tôi vừa đưa chúng vào trình khởi tạo.

00:34:44.000 --> 00:34:47.000
Bây giờ tôi chỉ cần thêm giá cho kích thước lớn.

00:34:47.000 --> 00:34:57.000
Đối với bản demo này, tôi vừa đưa chúng vào trình khởi tạo của chúng tôi.

00:34:57.000 --> 00:35:03.000
Hãy kiểm tra lại quan điểm của chúng ta.

00:35:03.000 --> 00:35:06.000
Ở đây trong bản xem trước là kích thước mới của chúng tôi.

00:35:06.000 --> 00:35:08.000
Nguồn của chúng tôi đã chứa một chuỗi tiếng Anh.

00:35:08.000 --> 00:35:10.000
Tôi chỉ cần một cái tiếng Tây Ban Nha bây giờ.

00:35:10.000 --> 00:35:24.000
Để tạo các chuỗi mới, tôi sẽ sử dụng trình biên dịch để tìm chuỗi bản địa hóa mới cho "khổng lồ". Để làm điều đó, tôi chọn Sản phẩm &gt; Xuất bản địa hóa và lưu các chuỗi tiếng Tây Ban Nha.

00:35:24.000 --> 00:35:34.000
Bây giờ hãy thêm một bản dịch cho tiếng Tây Ban Nha.

00:35:34.000 --> 00:35:45.000
Tôi có thể lọc chuỗi mới của chúng tôi và nhập từ tiếng Tây Ban Nha của chúng tôi.

00:35:45.000 --> 00:35:57.000
Tiếp theo, tôi nhập các bản địa hóa này để đưa chúng vào ứng dụng của mình.

00:35:57.000 --> 00:36:01.000
Bây giờ tôi sẽ chạy lại ứng dụng của chúng tôi nhưng bằng tiếng Tây Ban Nha.

00:36:01.000 --> 00:36:08.000
Để làm điều đó, tôi chọn Sản phẩm &gt; Sơ đồ &gt; Chỉnh sửa Sơ đồ.

00:36:08.000 --> 00:36:17.000
Trong Tùy chọn, tôi có thể chọn ngôn ngữ tôi muốn kiểm tra.

00:36:17.000 --> 00:36:20.000
Và chạy.

00:36:20.000 --> 00:36:23.000
Bạn có thể biết từ tiêu đề của chúng tôi rằng chúng tôi hiện đang chạy bằng tiếng Tây Ban Nha.

00:36:23.000 --> 00:36:27.000
Hãy làm một đơn hàng khác, bắt đầu với salad.

00:36:27.000 --> 00:36:32.000
Lưu ý khi tôi thay đổi số lượng, nút đặt hàng đã được cố định.

00:36:32.000 --> 00:36:37.000
Kích thước khổng lồ mới của chúng tôi được số nhiều chính xác cho 2 món salad.

00:36:37.000 --> 00:36:43.000
Thêm vào đó, nó phù hợp với giới tính ngữ pháp cho "ensalada", tất cả chỉ với một chuỗi.

00:36:43.000 --> 00:36:51.000
Có rất nhiều tính năng mới tuyệt vời trong Foundation năm nay và chúng đã sẵn sàng để bạn thử trong các ứng dụng của mình ngay hôm nay.

00:36:51.000 --> 00:36:59.000
AttributedString cung cấp giao diện nhanh chóng, dễ sử dụng và Swift đầu tiên để thêm các cặp khóa-giá trị vào phạm vi của một chuỗi.

00:36:59.000 --> 00:37:05.000
Bạn có thể sử dụng nó với SwiftUI trong văn bản và bắt đầu sử dụng Markdown trong các chuỗi được bản địa hóa của mình.

00:37:05.000 --> 00:37:12.000
Formatter API mới của chúng tôi tập trung vào định dạng, đơn giản hóa mã của bạn và cải thiện hiệu suất.

00:37:12.000 --> 00:37:17.000
Sử dụng các định dạng ở tất cả những nơi bạn trình bày dữ liệu trong ứng dụng của mình.

00:37:17.000 --> 00:37:28.000
Cuối cùng, thỏa thuận ngữ pháp tự động sẽ sửa chữa một cách thông minh các chuỗi được bản địa hóa để chúng khớp với giới tính ngữ pháp, số lượng và thuật ngữ địa chỉ của chính người dùng.

00:37:28.000 --> 00:37:30.000
Tôi hy vọng bạn sẽ thích những tính năng mới này.

00:37:30.000 --> 00:37:32.000
Chúng tôi rất mong được tìm thấy chúng trong các ứng dụng của bạn.

00:37:32.000 --> 00:37:34.000
Cảm ơn bạn.

00:37:34.000 --> 23:59:59.000
[Âm nhạc].

