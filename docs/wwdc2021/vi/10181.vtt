WEBVTT

00:00:00.000 --> 00:00:10.000
Xin chào mọi người.

00:00:10.000 --> 00:00:15.000
Tên tôi là Shefali Saboo, và tôi là một kỹ sư công cụ hiệu suất ở đây tại Apple.

00:00:15.000 --> 00:00:19.000
Tôi sẽ là người hướng dẫn bạn khi chúng ta cùng nhau điều hướng hiệu suất ứng dụng.

00:00:19.000 --> 00:00:23.000
Hành trình hôm nay sẽ là một chuyến tham quan ly kỳ qua thế giới biểu diễn.

00:00:23.000 --> 00:00:29.000
Các ứng dụng của bạn đóng một vai trò quan trọng trong trải nghiệm phần mềm tổng thể trên các thiết bị của chúng tôi.

00:00:29.000 --> 00:00:40.000
Tiếp tục tối ưu hóa ứng dụng của bạn và cải thiện hiệu suất có nghĩa là người dùng của bạn sẽ sử dụng ứng dụng của bạn thường xuyên hơn, tương tác nhiều hơn và sẽ sử dụng ứng dụng của bạn trong một khoảng thời gian dài hơn.

00:00:40.000 --> 00:00:46.000
Tối ưu hóa hiệu suất có vẻ như là một nhiệm vụ khó khăn với nhiều số liệu để theo dõi và các công cụ để sử dụng.

00:00:46.000 --> 00:00:47.000
Nhưng đừng sợ.

00:00:47.000 --> 00:00:59.000
Hướng dẫn sinh tồn này sẽ giúp bạn tăng tốc về công cụ, số liệu và mô hình có thể giúp đưa sự phát triển của bạn lên một tầm cao mới và đảm bảo trải nghiệm khách hàng tốt nhất có thể.

00:00:59.000 --> 00:01:07.000
Tôi rất vui khi được hướng dẫn bạn khi chúng tôi đi qua các công cụ hiệu suất của mình và những điều tuyệt vời mà bạn có thể làm với chúng.

00:01:07.000 --> 00:01:18.000
Sẽ có năm công cụ chính mà chúng ta sẽ đề cập đến ngày hôm nay: Xcode Organizer, MetricKit, Instruments, XCTest và App Store Connect API.

00:01:18.000 --> 00:01:23.000
Chúng ta sẽ bắt đầu với phần giới thiệu nhanh về các chỉ số chính.

00:01:23.000 --> 00:01:31.000
Sau đó, bước qua một số vấn đề phổ biến trong từng lĩnh vực miền và cách giải quyết và ngăn chặn chúng.

00:01:31.000 --> 00:01:34.000
Và cuối cùng, chúng ta sẽ kết thúc với một số bước tiếp theo.

00:01:34.000 --> 00:01:38.000
Tối ưu hóa hiệu suất giống như một dòng sông dài với nhiều điểm dừng.

00:01:38.000 --> 00:01:44.000
Có một vài công cụ khác nhau cần thiết để điều hướng và tại mỗi điểm dừng, có một cái gì đó mới để học.

00:01:44.000 --> 00:01:47.000
Hãy thực hiện một chuyến đi xuôi dòng sông.

00:01:47.000 --> 00:01:49.000
Đầu tiên, giới thiệu nhanh.

00:01:49.000 --> 00:01:54.000
Chúng ta hãy xem xét các chỉ số hiệu suất khác nhau mà chúng ta sẽ đề cập hôm nay.

00:01:54.000 --> 00:02:07.000
Hiện tại có tám điều chính cần theo dõi hiệu suất ứng dụng: Sử dụng pin, Thời gian khởi chạy, Tốc độ treo, Bộ nhớ, Ghi đĩa, Cuộn, Chấm dứt và MXSignposts.

00:02:07.000 --> 00:02:10.000
Tất cả những thứ này có thể được theo dõi thông qua bộ công cụ của chúng tôi.

00:02:10.000 --> 00:02:19.000
Tôi là nhà phát triển cho một ứng dụng có tên MealPlanner cho phép người dùng theo dõi bữa ăn của họ trong tuần và lưu các công thức nấu ăn thú vị.

00:02:19.000 --> 00:02:26.000
Đây là một ví dụ về trải nghiệm người dùng kém trong ứng dụng của tôi, đặc biệt là ở dạng quá giang cuộn.

00:02:26.000 --> 00:02:31.000
Chú ý đến cuộn chậm, bỏ qua và bồn chồn?

00:02:31.000 --> 00:02:38.000
Mặt khác, đây là cùng một ứng dụng với trải nghiệm người dùng liền mạch và không gặp trở ngại nào.

00:02:38.000 --> 00:02:49.000
Chúng tôi đã có thể thấy rằng có sự khác biệt khá lớn giữa hai trải nghiệm và cuộn mượt mà này là những gì chúng tôi muốn giúp bạn đạt được thông qua tối ưu hóa hiệu suất.

00:02:49.000 --> 00:02:54.000
Mỗi chỉ số hiệu suất có bộ mô hình độc đáo và công cụ chung riêng.

00:02:54.000 --> 00:03:00.000
Hãy cùng tìm hiểu ngay một số vấn đề phổ biến trong từng lĩnh vực miền và cách giải quyết và ngăn chặn chúng.

00:03:00.000 --> 00:03:05.000
Điểm dừng chân đầu tiên của chúng tôi dọc theo con sông là sử dụng pin.

00:03:05.000 --> 00:03:09.000
Nếu ứng dụng của bạn đang tiêu hao nhiều pin, đây là những gì người dùng sẽ thấy ở phía họ.

00:03:09.000 --> 00:03:12.000
Đây là giao diện người dùng pin.

00:03:12.000 --> 00:03:22.000
Nó cho người dùng thấy mức độ tiêu hao pin tổng thể của một ứng dụng trên thiết bị của họ, cũng như hoạt động tiền cảnh và nền của nó.

00:03:22.000 --> 00:03:24.000
Tại sao bạn nên quan tâm đến việc cải thiện tuổi thọ pin?

00:03:24.000 --> 00:03:26.000
Dễ dàng.

00:03:26.000 --> 00:03:32.000
Người dùng ưu tiên sử dụng các ứng dụng cho phép họ sử dụng thiết bị của mình suốt cả ngày mà không cần sạc lại.

00:03:32.000 --> 00:03:38.000
Bằng cách tối ưu hóa thời lượng pin, người dùng có thể sử dụng thiết bị của họ và ứng dụng của bạn trong một khoảng thời gian dài hơn.

00:03:38.000 --> 00:03:41.000
Bản thân điều đó là một chiến thắng.

00:03:41.000 --> 00:03:47.000
Có nhiều hệ thống con khác nhau cần chú ý khi tối ưu hóa thời lượng pin.

00:03:47.000 --> 00:03:53.000
Ba điều hàng đầu cần lưu ý là CPU, Mạng và Vị trí.

00:03:53.000 --> 00:04:01.000
Tôi có thể theo dõi và phân loại thời lượng pin của ứng dụng của mình bằng một vài công cụ khác nhau trong quá trình phát triển hoặc sau khi một phiên bản đã được phát hành.

00:04:01.000 --> 00:04:15.000
Trong khi tôi đang phát triển và thử nghiệm một tính năng mới tại bàn làm việc của mình, tôi sẽ xây dựng và chạy mã của mình thông qua Xcode và nhấp vào trình điều hướng gỡ lỗi, trông giống như một bình xịt nhỏ, để xem các đồng hồ đo khác nhau mà Xcode cung cấp.

00:04:15.000 --> 00:04:18.000
Cái mà tôi sẽ chú ý đến là Máy đo năng lượng.

00:04:18.000 --> 00:04:30.000
Máy đo năng lượng cho phép tôi theo dõi mức sử dụng CPU của mình khi tôi đang thử nghiệm ứng dụng của mình và hiển thị cho tôi các khu vực sử dụng CPU cao và Chi phí đánh thức CPU.

00:04:30.000 --> 00:04:42.000
Việc sử dụng CPU cao là khi mức sử dụng CPU lớn hơn 20% và CPU Wake Overhead là những khu vực mà CPU thức dậy từ trạng thái nhàn rỗi và có chi phí năng lượng phát sinh.

00:04:42.000 --> 00:05:00.000
Người ta thường thấy CPU tăng đột biến khi ứng dụng của tôi đang vẽ giao diện người dùng, xử lý dữ liệu từ mạng hoặc thực hiện các phép tính, nhưng một khi các tác vụ đó hoàn tất và ứng dụng của tôi đang chờ người dùng thực hiện hành động tiếp theo của họ, tôi sẽ thấy mức sử dụng CPU ở mức hoặc gần bằng không.

00:05:00.000 --> 00:05:11.000
Từ đây, tôi cũng có thể nhấp vào Hồ sơ thời gian để lập hồ sơ ứng dụng của mình trong Công cụ và xem trạng thái nhiệt, mức sử dụng CPU và ngăn xếp cuộc gọi đang hoạt động trong thời lượng được lập hồ sơ.

00:05:11.000 --> 00:05:20.000
Tôi cũng có thể sử dụng Mô hình Năng lượng Vị trí để đo lường tác động của Vị trí Cốt lõi và đảm bảo ứng dụng của tôi không sử dụng vị trí khi không nên.

00:05:20.000 --> 00:05:31.000
Thỉnh thoảng, có thể có một lỗi trong phiên bản beta hoặc phiên bản phát hành của ứng dụng của tôi khó tái tạo tại bàn làm việc của tôi hoặc có thể cần thêm nhật ký và ngữ cảnh để gỡ lỗi.

00:05:31.000 --> 00:05:45.000
MetricKit, hoạt động trên thiết bị như một khung đo từ xa hiệu suất tất cả trong một, có thể giúp tôi thu hẹp nguyên nhân gốc rễ và cung cấp cho tôi những hiểu biết có giá trị về các vấn đề mà khách hàng của tôi đang phải đối mặt.

00:05:45.000 --> 00:05:57.000
Để sử dụng MetricKit, tất cả những gì tôi cần làm là thêm và triển khai một lớp tùy chỉnh được gọi là AppMetrics trong ứng dụng của tôi và phù hợp lớp mới này với giao thức MXMetricManagerSubscriber.

00:05:57.000 --> 00:06:02.000
Sau đó tôi có thể thêm một tham chiếu đến lớp tùy chỉnh của mình cho người quản lý.

00:06:02.000 --> 00:06:08.000
Và xóa tham chiếu đến lớp tùy chỉnh của tôi trên deinit, đây là phương pháp hay nhất được đề xuất.

00:06:08.000 --> 00:06:13.000
Tôi có thể xử lý dữ liệu này theo các phương pháp didReceive tương ứng.

00:06:13.000 --> 00:06:25.000
Nếu được thực hiện một cách chiến lược, tôi có thể tăng thêm nhiều dữ liệu tương tự mà tôi sẽ tìm thấy trong Trình tổ chức, chẳng hạn như nhật ký năng lượng và số liệu CPU, với dữ liệu theo ngữ cảnh từ MetricKit về những gì có thể đã xảy ra khi sự cố xảy ra.

00:06:25.000 --> 00:06:33.000
Một phiên bản đơn giản của dữ liệu này có sẵn cho bạn, mà không cần nỗ lực thêm, nhờ vào quy trình phân tích trên thiết bị của chúng tôi.

00:06:33.000 --> 00:06:38.000
Khi người dùng sử dụng ứng dụng của bạn, chúng tôi thu thập dữ liệu hiệu suất từ các thiết bị được đồng ý.

00:06:38.000 --> 00:06:45.000
Dữ liệu này sau đó được tổng hợp trên máy chủ của chúng tôi và gửi lại cho bạn thông qua một trong nhiều công cụ của chúng tôi, như Xcode Organizer.

00:06:45.000 --> 00:07:00.000
Truy cập Xcode Organizer để xem dữ liệu hiệu suất cho phiên bản ứng dụng của tôi đã có trong cửa hàng ứng dụng dễ dàng như điều hướng đến thanh menu trong khi Xcode đang mở, chuyển đến cửa sổ và nhấp vào Organizer để khởi chạy.

00:07:00.000 --> 00:07:13.000
Khi tôi ở đây, tôi có thể nhấp vào số liệu sử dụng pin để xem dữ liệu tổng hợp cho ứng dụng của mình trên 16 phiên bản ứng dụng gần đây nhất, cũng như phân tích chi tiết theo thành phần phụ chính ở bên phải biểu đồ.

00:07:13.000 --> 00:07:25.000
Nếu phiên bản mới nhất của ứng dụng của tôi có hồi quy lớn, tôi sẽ biết về nó ngay sau khi một phiên bản xuất hiện trong Trình tổ chức, nếu tôi điều hướng đến ngăn Hồi quy, mới trong Xcode 13.

00:07:25.000 --> 00:07:36.000
Khung hồi quy mới này cô lập tất cả các số liệu đã tăng đáng kể trong phiên bản mới nhất của ứng dụng của tôi để tôi có thể thấy tất cả những thứ tôi cần tập trung vào ở một nơi.

00:07:36.000 --> 00:07:49.000
Để xác định những khu vực nào trong ứng dụng của tôi gây ra sự cố, tôi cũng có thể sử dụng Energy Organizer trong Báo cáo để xem các khu vực sử dụng CPU cao và nhật ký được thu thập từ các thiết bị người dùng được đồng ý.

00:07:49.000 --> 00:07:53.000
Điều này cung cấp cái nhìn chi tiết hơn về những gì đang xảy ra trong ứng dụng của tôi.

00:07:53.000 --> 00:08:04.000
Tôi có thể lấy tất cả dữ liệu này bằng cách truy vấn API Kết nối App Store và chạy phân tích của riêng tôi trên tải trọng JSON được trả về cùng với dữ liệu được yêu cầu của tôi.

00:08:04.000 --> 00:08:11.000
Tất cả các công cụ này sẽ giúp tôi dễ dàng nắm bắt và giải quyết nhiều hồi quy sử dụng pin trong ứng dụng của mình.

00:08:11.000 --> 00:08:25.000
Để tìm hiểu thêm về tối ưu hóa tuổi thọ pin, hãy xem bài nói chuyện "Cải thiện tuổi thọ và hiệu suất pin" từ năm 2019 và để tìm hiểu thêm về cách sử dụng Công cụ, hãy xem bài nói chuyện "Phân tích lưu lượng HTTP trong Công cụ" trong năm nay.

00:08:25.000 --> 00:08:32.000
Điểm dừng tiếp theo của chúng tôi là Hang Rate và Scrolling, hai chỉ số truyền đạt rằng ứng dụng của tôi không phản hồi.

00:08:32.000 --> 00:08:40.000
Treo là khi ứng dụng không phản hồi với đầu vào hoặc hành động của người dùng trong ít nhất 250 mili giây.

00:08:40.000 --> 00:08:54.000
Việc treo trong ứng dụng có thể khiến khách hàng buộc thoát khỏi ứng dụng khỏi trình chuyển đổi ứng dụng và là một trở ngại lớn đối với trải nghiệm của người dùng trong ứng dụng của bạn và nên được ưu tiên.

00:08:54.000 --> 00:09:00.000
Cuộn nói lắp xảy ra khi nội dung mới chưa sẵn sàng cho lần làm mới màn hình tiếp theo.

00:09:00.000 --> 00:09:08.000
Những điều này sẽ dẫn đến trải nghiệm người dùng không thú vị và sự thất vọng tổng thể, dẫn đến việc người dùng dành ít thời gian hơn cho ứng dụng của bạn.

00:09:08.000 --> 00:09:18.000
Là một nhà phát triển ứng dụng, mục tiêu là tối đa hóa mức độ tương tác của người dùng, vì vậy đây là một nơi tuyệt vời để bắt đầu tối ưu hóa.

00:09:18.000 --> 00:09:20.000
Bạn có nhớ cuộn giấy mượt mà chúng tôi đã cho bạn xem trước đó không?

00:09:20.000 --> 00:09:24.000
Nhắm đến điều này là lợi ích tốt nhất của người dùng của bạn.

00:09:24.000 --> 00:09:32.000
Tôi có thể theo dõi các số liệu treo và cuộn của mình trong Trình tổ chức Xcode bằng cách điều hướng đến các chế độ xem tương ứng của chúng.

00:09:32.000 --> 00:09:48.000
Một dấu hiệu cho thấy tôi cần chú ý đến những gì ứng dụng của mình đang làm là nếu tôi nhận thấy một trong hai biểu đồ có xu hướng tăng lên hoặc, trong trường hợp cuộn, nếu tôi nhận thấy rằng biểu đồ đang hiển thị nhiều thanh màu vàng và đỏ hơn thay vì các thanh màu xanh lá cây, như trong biểu đồ này ở đây.

00:09:48.000 --> 00:09:58.000
Theo chìa khóa bên phải của biểu đồ, thanh màu đỏ là dấu hiệu cho thấy trải nghiệm cuộn kém mà chúng ta đã thấy trong video trước đó và cần được sửa ngay lập tức.

00:09:58.000 --> 00:10:03.000
Dữ liệu này hiện cũng có sẵn thông qua App Store Connect API.

00:10:03.000 --> 00:10:09.000
Tôi có thể sử dụng Công cụ để phát hiện nguyên nhân gây treo cổ của mình bằng cách sử dụng Trạng thái luồng hoặc Dấu vết cuộc gọi hệ thống.

00:10:09.000 --> 00:10:17.000
Công cụ Theo dõi Trạng thái Luồng hiển thị dòng thời gian của trạng thái luồng và khi nào hệ điều hành đã lên lịch chạy luồng.

00:10:17.000 --> 00:10:22.000
Tôi có thể thấy một chủ đề đã bị chặn trong bao lâu trong phần chi tiết.

00:10:22.000 --> 00:10:29.000
System Call Trace hiển thị một câu chuyện chi tiết các cuộc gọi hệ thống đã nhập và thời gian chúng mất.

00:10:29.000 --> 00:10:41.000
Để xác minh rằng tôi không phát hành các phiên bản ứng dụng có lỗi sẽ ảnh hưởng đến trải nghiệm cuộn của người dùng, tôi có thể viết một bài kiểm tra hiệu suất với XCTest để khởi chạy và cuộn qua ứng dụng của tôi.

00:10:41.000 --> 00:10:52.000
Trong bài kiểm tra này, tôi chỉ định rằng tôi muốn đo tham số con scrollDeceleration và trong phần thân của khối đo, tôi đang vuốt lên với vận tốc cuộn mà tôi mong đợi trong ứng dụng của mình.

00:10:52.000 --> 00:11:01.000
Vì khối đo lường này chạy năm lần theo mặc định, tôi sẽ đặt lại trạng thái ứng dụng giữa các lần chạy bằng cách sử dụng XCTMeasureOptions.

00:11:01.000 --> 00:11:09.000
Tôi có thể chuyển cái này vào khối đo của mình, dừng đo và sau đó đặt lại trạng thái ứng dụng của mình.

00:11:09.000 --> 00:11:14.000
Đôi khi, việc tái tạo các vấn đề về khả năng đáp ứng trong các trường hợp thử nghiệm cưỡng bức có thể không dễ dàng.

00:11:14.000 --> 00:11:25.000
May mắn thay, MetricKit, khi được triển khai trong ứng dụng sản xuất của tôi, có thể cho phép tôi thu thập phép đo từ xa và chẩn đoán cho những vấn đề này tại thời điểm chúng xảy ra.

00:11:25.000 --> 00:11:32.000
Trong trường hợp bị treo, trong iOS 14, MetricKit sẽ cung cấp những chẩn đoán này cho tôi với nhịp 24 giờ.

00:11:32.000 --> 00:11:42.000
Mới trong iOS 15 và macOS 12, bây giờ tôi sẽ nhận được tất cả các chẩn đoán, bao gồm cả treo, trong ứng dụng của mình ngay sau khi sự cố xảy ra.

00:11:42.000 --> 00:11:51.000
Sử dụng các chẩn đoán tức thì này kết hợp với phép đo từ xa của riêng tôi, tôi có thể nhanh chóng root nguyên nhân và giải quyết các vấn đề phản hồi cấp bách nhất.

00:11:51.000 --> 00:12:00.000
Trong trường hợp quá giang cuộn, iOS 15 giới thiệu một API mới trong MetricKit để gắn thẻ hoạt ảnh tùy chỉnh bằng MXSignpost.

00:12:00.000 --> 00:12:09.000
MXSignpost là một trình bao bọc API được vận chuyển với MetricKit cho phép tôi đánh dấu các phần mã quan trọng để đo từ xa.

00:12:09.000 --> 00:12:17.000
Sử dụng MXSignpostAnimation- IntervalBegin API, tôi sẽ có thể đánh dấu chiến lược sự khởi đầu của các hình ảnh động tùy chỉnh.

00:12:17.000 --> 00:12:26.000
Sử dụng MXSignpost end API, tôi có thể đánh dấu sự kết thúc của hình ảnh động và thu thập phép đo từ xa tốc độ quá giang trong khoảng thời gian đó.

00:12:26.000 --> 00:12:34.000
Hai chức năng này sẽ không chỉ thu thập dữ liệu hiệu suất chi tiết cho khoảng thời gian này mà còn ghi lại bất kỳ trở ngại nào xảy ra.

00:12:34.000 --> 00:12:43.000
Để tìm hiểu thêm về cách hiểu và loại bỏ treo, tôi khuyên bạn nên xem bài nói chuyện "Hiểu và loại bỏ treo khỏi ứng dụng của bạn" trong năm nay.

00:12:43.000 --> 00:12:56.000
Để biết chi tiết chuyên sâu về cách xác định các vấn đề về quá giang cuộn, tôi khuyên bạn nên xem bài nói chuyện "Loại bỏ quá giang bằng cách sử dụng XCTest" và các cuộc nói chuyện công nghệ "Khám phá quá giang hoạt hình giao diện người dùng và vòng lặp kết xuất" từ năm 2020.

00:12:56.000 --> 00:13:01.000
Bây giờ chúng ta đang tiến gần đến nửa chặng đường khi chúng ta chuyển sang thảo luận về Disk Writes.

00:13:01.000 --> 00:13:06.000
Ghi vào đĩa có thể làm hao mòn NAND của người dùng của tôi, điều này sẽ dẫn đến tình trạng thiết bị kém.

00:13:06.000 --> 00:13:18.000
Việc ghi cũng mất rất nhiều thời gian và có thể dẫn đến trải nghiệm người dùng kém và hiệu suất chậm nếu được thực hiện thường xuyên, vì vậy điều quan trọng là phải ghi hàng loạt các lần này.

00:13:18.000 --> 00:13:24.000
Trước khi phát hành phiên bản ứng dụng của mình, tôi có thể lập hồ sơ ứng dụng của mình bằng cách sử dụng mẫu Hoạt động Tệp trong Công cụ.

00:13:24.000 --> 00:13:33.000
Điều này ghi lại việc sử dụng hệ thống tệp dưới dạng các cuộc gọi hệ thống, vì vậy tôi có thể dễ dàng xác định các vị trí trong mã ứng dụng của mình nơi tôi đang truy cập hệ thống tệp.

00:13:33.000 --> 00:13:37.000
Có nhiều cách để trở thành công dân tốt của hệ thống và hạn chế ghi vào đĩa.

00:13:37.000 --> 00:13:46.000
Một số hoạt động phổ biến là trộn các hoạt động ghi của bạn, sử dụng Dữ liệu cốt lõi để thay đổi dữ liệu thường xuyên và tránh tạo và xóa tệp nhanh chóng.

00:13:46.000 --> 00:13:59.000
Ngoài việc lập hồ sơ ứng dụng của mình, tôi cũng có thể viết các bài kiểm tra hiệu suất với XCTest để đo lường mức sử dụng đĩa của ứng dụng của mình nhằm ngăn mã có Ghi đĩa quá mức chạy trên thiết bị người dùng.

00:13:59.000 --> 00:14:09.000
Điều này đơn giản như chuyển một phiên bản của XCTStorageMetric đến measureWithMetric API và sau đó gọi mã ghi vào đĩa.

00:14:09.000 --> 00:14:16.000
Bài kiểm tra đo lượng dữ liệu được ghi vào đĩa bởi mã trong khối và hiển thị cho tôi kết quả trong chính Xcode.

00:14:16.000 --> 00:14:25.000
Tôi có thể đặt đường cơ sở về lượng dữ liệu mà tôi mong đợi được ghi vào đĩa để bài kiểm tra không thành công nếu mã trong khối vượt quá mức đó.

00:14:25.000 --> 00:14:30.000
Điều này sẽ giúp tôi đảm bảo rằng tôi không đưa ra bất kỳ mã lỗi nào.

00:14:30.000 --> 00:14:39.000
Nếu tôi đã phát hành phiên bản ứng dụng của mình với Ghi đĩa cao, tôi có thể sử dụng Trình tổ chức để theo dõi hiệu suất của nó trên các thiết bị của người dùng.

00:14:39.000 --> 00:14:47.000
Chỉ số Disk Writes cho tôi thấy xu hướng có bao nhiêu lần ghi mà phiên bản hiện tại của ứng dụng của tôi đang thực hiện so với các phiên bản đã phát hành trước đó.

00:14:47.000 --> 00:14:52.000
Các đột biến trong biểu đồ có thể chỉ ra rằng ứng dụng của tôi có lỗi gây ra số lượng ghi cao.

00:14:52.000 --> 00:15:00.000
Tôi nên xác định các nguồn hàng đầu của những văn bản này, hiểu chúng và tìm cách giảm thiểu chúng.

00:15:00.000 --> 00:15:05.000
Tôi có thể tìm kiếm nguồn gốc của những bài viết này bằng cách xem Báo cáo Ghi đĩa.

00:15:05.000 --> 00:15:12.000
Đây là một tập hợp các báo cáo ngoại lệ được tạo ra khi ứng dụng của tôi ghi hơn 1 GB trong khoảng thời gian 24 giờ.

00:15:12.000 --> 00:15:31.000
Dấu vết ngăn xếp cho tôi thấy nơi nào trong mã của tôi, tôi đã viết quá nhiều và, mới trong Xcode 13, tôi cũng có thể nhận được các chi tiết bổ sung được gọi là Insights, điều này chỉ cho tôi một số tối ưu hóa dễ dàng mà tôi có thể thực hiện để trở thành một công dân tốt của hệ thống và giảm một số ghi trong ứng dụng của mình

00:15:31.000 --> 00:15:37.000
Tất cả dữ liệu này hiện cũng có sẵn cho tôi thông qua App Store Connect API.

00:15:37.000 --> 00:15:42.000
Tôi cũng có thể lấy các báo cáo này trong MetricKit tại thời điểm chúng xuất hiện trong ứng dụng của tôi.

00:15:42.000 --> 00:15:56.000
Nếu tôi đang sử dụng MetricKit để theo dõi việc sử dụng đĩa của ứng dụng, tôi có thể đặt các đường dẫn Ghi đĩa quan trọng với các khoảng MXSignpost để thu thập phép đo từ xa chi tiết hơn, điều này có thể giúp tôi khám phá các cơ hội tối ưu hóa.

00:15:56.000 --> 00:16:06.000
Để tìm hiểu thêm về cách xác định và giải quyết liền mạch các vấn đề Ghi đĩa, hãy nhớ theo dõi cuộc nói chuyện "Chẩn đoán năng lượng và hồi quy hiệu suất trong ứng dụng của bạn" trong năm nay.

00:16:06.000 --> 00:16:11.000
Khi chúng ta tiếp cận điểm dừng tiếp theo, chúng ta sẽ thảo luận về thời gian ra mắt và việc chấm dứt.

00:16:11.000 --> 00:16:20.000
Thời gian khởi chạy là khoảng thời gian giữa khi người dùng nhấn vào biểu tượng ứng dụng của bạn và khi khung đầu tiên được hiển thị trong ứng dụng của bạn.

00:16:20.000 --> 00:16:33.000
Nếu người dùng của bạn dành nhiều thời gian chờ đợi ứng dụng của bạn khởi chạy, điều đó có thể dẫn đến sự thất vọng không chủ ý cho người dùng và thời gian khởi chạy kéo dài có thể dẫn đến việc hệ thống chấm dứt ứng dụng của bạn.

00:16:33.000 --> 00:16:44.000
Khi hệ thống chấm dứt ứng dụng của bạn, người dùng của bạn sẽ trải nghiệm toàn bộ luồng khởi chạy ngay từ đầu, mất nhiều thời gian hơn so với việc tiếp tục từ trạng thái chạy nền.

00:16:44.000 --> 00:16:53.000
Quá trình thoát có thể xảy ra vì nhiều lý do khác nhau, như nhấn và vượt quá giới hạn bộ nhớ hệ thống hoặc hết thời gian khi khởi chạy.

00:16:53.000 --> 00:17:11.000
Mỗi khi ứng dụng của bạn chấm dứt vì một trong những lý do này, nó sẽ trải qua toàn bộ quá trình khởi chạy vào lần tiếp theo khi người dùng của bạn nhấn vào biểu tượng ứng dụng của bạn và điều đó không chỉ mất nhiều thời gian mà còn là một trải nghiệm khó chịu, đặc biệt nếu nó xảy ra thường xuyên.

00:17:11.000 --> 00:17:20.000
Nếu bạn không khôi phục trạng thái, điều này cũng có thể làm tăng thêm sự thất vọng khi người dùng phải tìm lại vị trí của họ hoặc tạo lại công việc bị mất.

00:17:20.000 --> 00:17:29.000
Tôi vừa phát hành một phiên bản mới của ứng dụng của mình với một tính năng cho phép người dùng của tôi thêm hình ảnh và công thức nấu ăn chi tiết cho bữa ăn của họ.

00:17:29.000 --> 00:17:36.000
Hãy xem thời gian khởi chạy ứng dụng của tôi trông như thế nào với tính năng mới này và nó trông như thế nào trước đây.

00:17:36.000 --> 00:17:42.000
Đây là những gì người dùng sẽ thấy khi họ cố gắng khởi chạy ứng dụng của tôi bây giờ khi nó có tính năng mới trong đó.

00:17:42.000 --> 00:17:47.000
Chú ý đã dành bao nhiêu thời gian để cố gắng kết xuất khung hình đầu tiên?

00:17:47.000 --> 00:17:51.000
Ứng dụng của tôi đã bị đình chỉ trước khi chúng tôi có cơ hội sử dụng nó.

00:17:51.000 --> 00:17:56.000
Để so sánh, đây là sự ra mắt trông như thế nào trước khi tính năng đó được thêm vào.

00:17:56.000 --> 00:18:01.000
Nó gần giống như ứng dụng của tôi dự đoán sẽ ra mắt và có khung hình đầu tiên sẵn sàng để hiển thị.

00:18:01.000 --> 00:18:10.000
Từ hai ví dụ này, tôi đã biết rằng lần khởi chạy cực kỳ chậm đầu tiên không phải là điều tôi muốn người dùng nhớ khi họ nghĩ về ứng dụng của tôi.

00:18:10.000 --> 00:18:14.000
Vì vậy tôi sẽ cần sửa cái này càng sớm càng tốt.

00:18:14.000 --> 00:18:25.000
Vì vấn đề khởi chạy đã có trong phiên bản ứng dụng của tôi mà người dùng đang sử dụng, tôi có thể bắt đầu bằng cách truy cập Ban tổ chức và xem Thời gian khởi chạy và các ngăn Chấm dứt mới.

00:18:25.000 --> 00:18:37.000
Nhìn vào thời gian ra mắt sẽ cho tôi ý tưởng về "thời gian đến khung hình đầu tiên" trung bình của ứng dụng của tôi là bao nhiêu trong 16 phiên bản gần đây, vì vậy tôi có thể thấy tốc độ nhanh như thế nào trước khi tính năng mới của tôi được thêm vào.

00:18:37.000 --> 00:18:47.000
Tôi cũng có thể vào ngăn Chấm dứt để xem ứng dụng của tôi bị hệ thống chấm dứt thường xuyên như thế nào vì mất bao lâu để khởi chạy.

00:18:47.000 --> 00:18:56.000
Sau khi xem Bộ tổ chức, có vẻ như đây là một lỗi khá tệ đã được giới thiệu với tính năng mới của tôi và nó đang tấn công rất nhiều người dùng của tôi.

00:18:56.000 --> 00:19:00.000
Hãy xem làm thế nào tôi có thể sửa cái này.

00:19:00.000 --> 00:19:07.000
Tôi có thể kiểm tra vấn đề này tại bàn làm việc của mình bằng cách sử dụng mẫu Khởi chạy Ứng dụng trong Công cụ để lập hồ sơ thời gian khởi chạy ứng dụng của mình.

00:19:07.000 --> 00:19:21.000
Mẫu này chạy ứng dụng của tôi trong năm giây, trong thời gian đó nó thu thập hồ sơ thời gian và Dấu vết trạng thái luồng về những gì đang diễn ra trong khi ứng dụng đang khởi chạy, vì vậy tôi có thể tìm ra lý do tại sao các chủ đề bị chặn và khắc phục điều đó.

00:19:21.000 --> 00:19:31.000
Tôi cũng có thể đo thời gian khởi chạy trong XCTest hiệu suất bằng cách sử dụng XCTApplicationsLaunchMetric trong một khối đo tương tự như những gì chúng ta đã thấy trước đó.

00:19:31.000 --> 00:19:41.000
Nếu tôi muốn thực hiện phân tích của riêng mình, với MetricKit được triển khai trong ứng dụng của mình, tôi sẽ nhận được phép đo từ xa chấm dứt như một phần của tải trọng số liệu hàng ngày theo mặc định.

00:19:41.000 --> 00:19:51.000
Để biết thêm thông tin về khôi phục trạng thái để tránh mất dữ liệu khi ứng dụng của bạn bị chấm dứt, hãy xem "Tại sao ứng dụng của tôi bị giết?" Nói chuyện từ năm 2020.

00:19:51.000 --> 00:19:53.000
Yay, chúng tôi đã làm nó.

00:19:53.000 --> 00:19:56.000
Chúng tôi đang ở điểm dừng chân cuối cùng trước khi kết thúc hành trình của mình.

00:19:56.000 --> 00:19:59.000
Điểm dừng chân cuối cùng của chúng tôi là Ký ức.

00:19:59.000 --> 00:20:04.000
Bộ nhớ là một tài nguyên được chia sẻ giữa các ứng dụng, hệ điều hành và hạt nhân.

00:20:04.000 --> 00:20:17.000
Nếu ứng dụng của bạn vượt quá giới hạn bộ nhớ, nó sẽ bị hệ thống chấm dứt và lần sau khi người dùng khởi chạy nó, nó sẽ khởi chạy ngay từ đầu, mất nhiều thời gian hơn so với việc tiếp tục từ trạng thái chạy nền.

00:20:17.000 --> 00:20:26.000
Tính năng mới trong ứng dụng của tôi cho phép các nhà phát triển thêm hình ảnh và mô tả vào bữa ăn của họ, điều đó có nghĩa là khả năng việc sử dụng bộ nhớ sẽ tăng lên một chút.

00:20:26.000 --> 00:20:39.000
Nếu điều này xảy ra, có khả năng ứng dụng của tôi có thể bị chấm dứt vì vượt quá giới hạn bộ nhớ, vì vậy tôi nên theo dõi các chỉ số Bộ nhớ và Chấm dứt trong Trình tổ chức để đảm bảo rằng đó không phải là trường hợp.

00:20:39.000 --> 00:20:51.000
Có vẻ như nó không bị chấm dứt, nhưng có sự gia tăng đột biến trong việc sử dụng bộ nhớ trong phiên bản ứng dụng mới này của tôi, theo bộ nhớ cao nhất và bộ nhớ ở biểu đồ treo trong Trình tổ chức.

00:20:51.000 --> 00:20:59.000
Tôi có thể lập hồ sơ sử dụng bộ nhớ của ứng dụng của mình bằng cách sử dụng các mẫu Rò rỉ, Phân bổ và Trình theo dõi VM trong Công cụ.

00:20:59.000 --> 00:21:04.000
Rò rỉ sẽ kiểm tra đống quy trình của tôi và kiểm tra bộ nhớ bị rò rỉ.

00:21:04.000 --> 00:21:08.000
Phân bổ sẽ phân tích vòng đời bộ nhớ của ứng dụng của tôi.

00:21:08.000 --> 00:21:13.000
Và VM Tracker sẽ hiển thị không gian bộ nhớ ảo của ứng dụng của tôi theo thời gian.

00:21:13.000 --> 00:21:18.000
Tôi cũng có thể sử dụng MetricKit để có được thông tin tương tự và chạy phân tích của riêng tôi về nó.

00:21:18.000 --> 00:21:33.000
Ngoài việc sử dụng tải trọng số liệu hàng ngày của tôi có chứa kết thúc và đo từ xa bộ nhớ, tôi cũng có thể thiết bị MXSignpost xung quanh các phần mã quan trọng để nắm bắt phép đo từ xa chi tiết hơn về việc sử dụng bộ nhớ.

00:21:33.000 --> 00:21:44.000
Để tìm hiểu thêm về cách phát hiện và hiểu cách giải quyết hồi quy bộ nhớ trước khi chúng được đưa vào ứng dụng của bạn, hãy xem bài nói chuyện "Nhận thức và Chẩn đoán các vấn đề về bộ nhớ" trong năm nay.

00:21:44.000 --> 00:21:51.000
Trước khi tôi gửi bạn trên đường đi, hãy kết thúc những gì chúng ta đã thấy ở đây hôm nay và xem qua một số bước tiếp theo.

00:21:51.000 --> 00:21:56.000
Chúng tôi hiểu việc xác định tối ưu hóa hiệu suất có thể khó khăn như thế nào.

00:21:56.000 --> 00:22:05.000
Trong vài năm qua, các nhà phát triển đã sử dụng những công cụ tương tự mà chúng tôi cung cấp cho bạn để tối ưu hóa hiệu suất đáng kể.

00:22:05.000 --> 00:22:11.000
Một ví dụ tuyệt vời là Snapchat, một ứng dụng mà hàng triệu người sử dụng mỗi ngày.

00:22:11.000 --> 00:22:19.000
Snapchat có một sự cống hiến lâu dài để cải thiện trải nghiệm khởi chạy ứng dụng của họ và giảm việc chấm dứt.

00:22:19.000 --> 00:22:25.000
Trong năm ngoái, chúng tôi đã thấy giảm 99% các trường hợp chấm dứt không mong muốn đối với Snapchat.

00:22:25.000 --> 00:22:34.000
Chúng tôi nghĩ điều đó thật đáng kinh ngạc, và sử dụng các công cụ và dữ liệu hiệu suất mà chúng tôi đã thảo luận ở đây hôm nay, bạn cũng có thể thực hiện điều này.

00:22:34.000 --> 00:22:55.000
Nếu bạn chưa quen với các công cụ hiệu suất, tôi khuyên bạn nên dành một chút thời gian để xem các cuộc nói chuyện "Chẩn đoán các vấn đề về hiệu suất với Xcode Organizer" và "Có gì mới trong MetricKit" từ năm 2020, cũng như cuộc nói chuyện "Xác định xu hướng với API năng lượng và hiệu suất" từ năm 2020 và cuộc nói chuyện "

00:22:55.000 --> 00:23:04.000
Sau khi đào sâu vào tất cả các số liệu và công cụ này, chúng tôi hy vọng rằng bạn được trang bị tốt các tài nguyên bạn sẽ cần để vận chuyển các ứng dụng hiệu quả nhất trong App Store.

00:23:04.000 --> 00:23:09.000
Người dùng của bạn sẽ cảm ơn bạn vì điều này vì họ tận hưởng trải nghiệm người dùng liền mạch.

00:23:09.000 --> 00:23:22.000
Có rất nhiều tài liệu được đề cập ở đây, vì vậy như một bài tập thú vị, tôi khuyên bạn nên sử dụng Xcode Organizer để xem dữ liệu xu hướng về hiệu suất ứng dụng của mình.

00:23:22.000 --> 00:23:26.000
Khám phá và chơi với các mẫu khác nhau được cung cấp trong Nhạc cụ.

00:23:26.000 --> 00:23:32.000
Thử thách bản thân viết XCTests để nắm bắt các vấn đề trước khi chúng được phát hành.

00:23:32.000 --> 00:23:37.000
Và mở rộng phạm vi phân tích của bạn với MetricKit.

00:23:37.000 --> 00:23:47.000
Có rất nhiều công cụ của chúng tôi phải cung cấp khi nói đến việc tối ưu hóa hiệu suất, vì vậy đừng ngần ngại làm bẩn tay và khám phá tất cả những gì đi kèm với chúng.

00:23:47.000 --> 00:23:54.000
Cảm ơn bạn đã tham gia cùng tôi trong hành trình hôm nay, và tôi hy vọng bạn có một khoảng thời gian tuyệt vời tại hội nghị năm nay.

00:23:54.000 --> 23:59:59.000
[Nhạc lạc quan].

