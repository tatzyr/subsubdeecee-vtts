WEBVTT

00:00:00.000 --> 00:00:05.000
♪ Nhạc bass đang phát ♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:10.000
Tanu Singhal: Xin chào mọi người.

00:00:10.000 --> 00:00:15.000
Tên tôi là Tanu, và tôi là một kỹ sư SwiftUI trong nhóm Apple TV.

00:00:15.000 --> 00:00:21.000
Hôm nay, chúng ta sẽ nói về một số cách làm việc tập trung mới trong SwiftUI.

00:00:21.000 --> 00:00:27.000
Một trong những điều tuyệt vời về SwiftUI là bạn nhận được bao nhiêu chức năng miễn phí, ngay lập tức.

00:00:27.000 --> 00:00:38.000
Các thành phần tích hợp dựa trên hành vi mặc định của chúng dựa trên kiến thức của SwiftUI về các quy ước nền tảng, dẫn đến trải nghiệm tổng thể hợp lý và quen thuộc trong các bối cảnh khác nhau.

00:00:38.000 --> 00:00:44.000
Chúng ta thấy trí thông minh này trong công việc khi chúng ta nhìn vào sự tập trung.

00:00:44.000 --> 00:01:00.000
Focus là hệ thống cho phép ứng dụng của bạn lấy đầu vào từ bàn phím, điều khiển từ xa, bộ điều khiển trò chơi, điều khiển chuyển đổi có thể truy cập và các nguồn khác - không giống như đầu vào cảm ứng - không bị ràng buộc với tọa độ màn hình cụ thể.

00:01:00.000 --> 00:01:09.000
Thông thường, chế độ xem trọng tâm được vẽ bằng các tô điểm đặc biệt, giúp mọi người dễ dàng dự đoán nơi đầu vào của họ sẽ được hướng đến.

00:01:09.000 --> 00:01:14.000
Phần lớn, SwiftUI quản lý sự tập trung thay mặt bạn.

00:01:14.000 --> 00:01:29.000
Khi ai đó nhấp vào trường văn bản hoặc nhấn phím Tab hoặc khi ai đó nhấn vào biến chứng đồng hồ có thể điều chỉnh hoặc vuốt trên Siri Remote, SwiftUI sẽ quyết định cách tiêu điểm bị ảnh hưởng và vị trí tiếp theo của nó được chỉ định như thế nào.

00:01:29.000 --> 00:01:35.000
Điều này rất tốt cho những trường hợp đơn giản mà hành vi đúng đắn có thể được quyết định theo quy ước.

00:01:35.000 --> 00:01:43.000
Tuy nhiên, có một số trường hợp bạn có thể muốn trải nghiệm tăng tốc hơn xung quanh việc tập trung.

00:01:43.000 --> 00:01:52.000
Trong ví dụ này từ ứng dụng Ghi chú, khi chúng tôi chọn nút ghi chú mới, chúng tôi muốn tập trung tự động di chuyển đến ghi chú mới được tạo.

00:01:52.000 --> 00:01:58.000
Loại hành vi này chắc chắn yêu cầu triển khai tùy chỉnh.

00:01:58.000 --> 00:02:09.000
Ở đây, chúng tôi có một kịch bản trong đó chúng tôi muốn di chuyển tiêu điểm từ một nút ở phía dưới bên trái sang nội dung gần đầu màn hình khi người dùng vuốt sang phải trên điều khiển từ xa.

00:02:09.000 --> 00:02:18.000
Vì nút Nhạc và các ô Ứng dụng không liền kề nhau, SwiftUI không thể tự động đoán được nơi để di chuyển tiêu điểm.

00:02:18.000 --> 00:02:23.000
Nó cần thêm thông tin trước khi các mục tiêu tiêu điểm từ xa có thể được liên kết.

00:02:23.000 --> 00:02:30.000
Và trong ví dụ này từ iOS, chúng tôi chỉ đơn giản muốn bàn phím biến mất khi người dùng chọn một sự kiện.

00:02:30.000 --> 00:02:36.000
Nhờ các API mới mà chúng tôi giới thiệu trong năm nay, giờ đây bạn có thể thực hiện tất cả những điều này trong SwiftUI.

00:02:36.000 --> 00:02:40.000
Trong buổi nói chuyện này, chúng ta sẽ tập trung vào hai loại trường hợp sử dụng.

00:02:40.000 --> 00:02:54.000
Chúng ta sẽ xem cách chúng ta có thể di chuyển tiêu điểm đến một chế độ xem cụ thể mà không cần bất kỳ đầu vào trực tiếp nào và chúng ta sẽ tạo các mục tiêu điều hướng lớn từ các chế độ xem nhỏ để không có gì nằm ngoài tầm với của người dùng.

00:02:54.000 --> 00:03:01.000
Trước tiên chúng ta hãy xem một ví dụ mà chúng ta có thể muốn chuyển trọng tâm để giúp hướng sự chú ý của người dùng.

00:03:01.000 --> 00:03:06.000
Chúng tôi đã rất sẵn sàng để đi nghỉ và chúng tôi đã bắt đầu làm việc trên một ứng dụng lập kế hoạch kỳ nghỉ.

00:03:06.000 --> 00:03:14.000
Ứng dụng này hoạt động trên tất cả các nền tảng của Apple và nó cho phép bạn duyệt các điểm đến cũng như đặt các chuyến đi.

00:03:14.000 --> 00:03:23.000
Khi bạn khởi chạy ứng dụng này, chúng tôi sẽ trình bày trường email, trường mật khẩu và nút Đăng nhập bằng Apple để bạn có thể đăng nhập vào tài khoản của mình.

00:03:23.000 --> 00:03:33.000
Trên màn hình đăng nhập này, nếu chúng tôi phát hiện ra rằng email đã nhập không ở định dạng chính xác, chúng tôi muốn lập trình di chuyển tiêu điểm trở lại trường email.

00:03:33.000 --> 00:03:38.000
Để thực hiện hành vi này, chúng tôi sẽ sử dụng FocusState APIs.

00:03:38.000 --> 00:03:46.000
Mã hiện có cho chế độ xem đăng nhập của chúng tôi chứa VStack có TextField và SecureField.

00:03:46.000 --> 00:03:50.000
Bây giờ, chúng ta sẽ thêm một trình bao bọc thuộc tính FocusState vào chế độ xem này.

00:03:50.000 --> 00:03:55.000
FocusState là một API mới mà chúng tôi đã giới thiệu trong năm nay!

00:03:55.000 --> 00:04:01.000
Đây là một loại trạng thái đặc biệt thay đổi tùy thuộc vào vị trí tập trung hiện tại.

00:04:01.000 --> 00:04:06.000
Chúng tôi sẽ sử dụng FocusState để giữ một mã định danh cho trường được tập trung.

00:04:06.000 --> 00:04:10.000
Biến focusedField thuộc loại enum mà chúng tôi đã tạo cho ví dụ này.

00:04:10.000 --> 00:04:17.000
Bạn có thể sử dụng chuỗi, số nguyên hoặc bất kỳ loại giá trị có thể băm nào khác cho FocusState.

00:04:17.000 --> 00:04:20.000
Lưu ý rằng giá trị FocusState là tùy chọn.

00:04:20.000 --> 00:04:32.000
Nói chung, các loại được sử dụng cho FocusState phải vừa có thể băm vừa tùy chọn, không được sử dụng cho các trường hợp tiêu điểm ở một phần không liên quan của màn hình.

00:04:32.000 --> 00:04:38.000
Tiếp theo chúng ta sẽ thêm một công cụ sửa đổi tập trung vào TextField và SecureField.

00:04:38.000 --> 00:04:46.000
Cũng mới trong năm nay, công cụ sửa đổi này tạo ra một liên kết giữa vị trí lấy nét và giá trị của thuộc tính focusField.

00:04:46.000 --> 00:04:55.000
Liên kết đơn giản này là một công cụ mạnh mẽ, bởi vì nó có nghĩa là bạn có thể sử dụng vị trí tập trung hiện tại để đưa ra các quyết định khác trong ứng dụng của mình.

00:04:55.000 --> 00:04:59.000
Chúng ta có thể xem diễn ra trong biểu mẫu đăng nhập của mình.

00:04:59.000 --> 00:05:06.000
Khi màn hình xuất hiện lần đầu tiên, không có gì lấy nét, vì vậy giá trị của trường lấy nét là không.

00:05:06.000 --> 00:05:14.000
Nhưng nếu ai đó nhấn vào trường văn bản email, trường đó sẽ lấy nét và bàn phím sẽ xuất hiện.

00:05:14.000 --> 00:05:27.000
Vì trường văn bản tập trung được liên kết với giá trị FocusState, giá trị của focusedField sẽ tự động được cập nhật để giữ mã định danh cho trường văn bản email.

00:05:27.000 --> 00:05:31.000
Liên kết giữa vị trí tập trung và FocusState hoạt động theo cả hai cách.

00:05:31.000 --> 00:05:41.000
Điều này có nghĩa là chúng ta không bị giới hạn trong việc phản ứng với các thay đổi tiêu điểm; chúng ta có thể di chuyển tiêu điểm theo chương trình chỉ bằng cách cập nhật thuộc tính FocusState của chúng ta.

00:05:41.000 --> 00:05:58.000
Vì vậy, ví dụ, nếu chúng tôi lập trình đặt giá trị của focusedField thành .password, SwiftUI sẽ biết rằng SecureField của chúng tôi được liên kết với giá trị mới mà chúng tôi đang thiết lập và focus sẽ tự động di chuyển đến trường mật khẩu.

00:05:58.000 --> 00:06:06.000
Bây giờ các ràng buộc trọng tâm của chúng tôi đã được đặt đúng chỗ, chúng tôi có thể đưa chúng vào hoạt động.

00:06:06.000 --> 00:06:11.000
Trong ứng dụng Vacation Planner, khi người dùng gửi dữ liệu của họ, chúng tôi muốn xác thực nó.

00:06:11.000 --> 00:06:17.000
Nếu email không ở định dạng mong đợi, chúng tôi đặt Trường tập trung thành email.

00:06:17.000 --> 00:06:24.000
Điều này sẽ gửi tiêu điểm trở lại trường văn bản email, nếu nó chưa có ở đó.

00:06:24.000 --> 00:06:30.000
Hơn nữa, chúng tôi muốn làm nổi bật trường email bằng đường viền nếu email không hợp lệ.

00:06:30.000 --> 00:06:35.000
Chúng tôi muốn đường viền này chỉ xuất hiện khi trọng tâm là trường email.

00:06:35.000 --> 00:06:42.000
Để làm điều đó, chúng ta có thể dễ dàng đọc giá trị của focusedField khi chúng ta tạo đường viền.

00:06:42.000 --> 00:06:45.000
Hãy xem tất cả điều này kết hợp với nhau như thế nào.

00:06:45.000 --> 00:06:48.000
Lưu ý rằng trường email không có địa chỉ hợp lệ.

00:06:48.000 --> 00:06:51.000
Trọng tâm hiện đang ở trường mật khẩu.

00:06:51.000 --> 00:06:57.000
Khi chúng tôi nhấn Go, cuộc gọi lại onSubmit được kích hoạt ở nơi focusedField được đặt.

00:06:57.000 --> 00:07:01.000
Điều này khiến con trỏ di chuyển trở lại trường email.

00:07:01.000 --> 00:07:05.000
Trong khi trường email được tập trung, chúng tôi thấy đường viền màu đỏ xung quanh nó.

00:07:05.000 --> 00:07:17.000
Tuy nhiên, một khi chúng tôi di chuyển tiêu điểm ra khỏi trường email, Trường tập trung của chúng tôi không còn bằng số nhận dạng email nữa, và do đó đường viền màu đỏ biến mất.

00:07:17.000 --> 00:07:23.000
Trong trường hợp tất cả dữ liệu biểu mẫu hợp lệ, chúng tôi chỉ muốn loại bỏ bàn phím.

00:07:23.000 --> 00:07:28.000
Để loại bỏ bàn phím, chúng tôi sẽ đặt biến FocusState thành nil.

00:07:28.000 --> 00:07:35.000
Vì focusField là một tùy chọn, chúng tôi sử dụng nil để chỉ ra rằng focus đã rời khỏi chế độ xem này.

00:07:35.000 --> 00:07:39.000
Trong video, lưu ý rằng địa chỉ email đã được cập nhật.

00:07:39.000 --> 00:07:46.000
Lần này khi chúng tôi gửi, bàn phím bị loại bỏ vì chúng tôi đã đặt biến FocusState thành số không.

00:07:46.000 --> 00:07:52.000
Chúng tôi đã thấy cách có thể hữu ích khi kiểm soát tiêu điểm theo chương trình khi ứng dụng của chúng tôi có các trường văn bản.

00:07:52.000 --> 00:07:56.000
Tuy nhiên, FocusStates không chỉ dành cho các trường văn bản.

00:07:56.000 --> 00:08:05.000
Chúng có thể được sử dụng để điều khiển tiêu điểm theo chương trình cho bất kỳ chế độ xem có thể lấy nét nào trên iOS, tvOS, watchOS hoặc macOS!

00:08:05.000 --> 00:08:11.000
Trong phần tiếp theo, chúng ta sẽ thảo luận về vai trò của điều hướng dựa trên tiêu điểm trong các ứng dụng của chúng ta.

00:08:11.000 --> 00:08:16.000
Hãy cùng xem phiên bản tvOS của ứng dụng Vacation Planner của chúng tôi.

00:08:16.000 --> 00:08:23.000
Chúng tôi đã tận dụng thêm không gian trên TV bằng cách thêm ảnh từ một số điểm đến mà bạn có thể muốn ghé thăm.

00:08:23.000 --> 00:08:30.000
Bạn có thể xem nhiều ảnh hơn bằng cách nhấp vào nút Duyệt ảnh ngay cả trước khi đăng nhập.

00:08:30.000 --> 00:08:34.000
Lưu ý rằng trọng tâm ban đầu là trường Email.

00:08:34.000 --> 00:08:40.000
Nếu chúng ta vuốt sang phải trên Siri Remote, chúng ta mong đợi trọng tâm sẽ chuyển sang nút Duyệt ảnh.

00:08:40.000 --> 00:08:44.000
Tuy nhiên, điều đó không hoạt động theo mặc định.

00:08:44.000 --> 00:08:49.000
Điều này là do điều hướng tiêu điểm định hướng dựa trên các mối quan hệ liền kề.

00:08:49.000 --> 00:08:57.000
Khi vuốt để di chuyển tiêu điểm, tiêu điểm sẽ chỉ di chuyển nếu có thứ gì đó liền kề và có thể lấy nét theo hướng đã cho.

00:08:57.000 --> 00:09:00.000
Hãy xem các chế độ xem có thể tập trung trong ứng dụng này.

00:09:00.000 --> 00:09:09.000
Vì không có chế độ xem có thể lấy nét liền kề với các trường đăng nhập ở bên trái, nút ở phía dưới không thể truy cập được.

00:09:09.000 --> 00:09:17.000
Để làm cho màn hình này có thể điều hướng được, chúng tôi sẽ mở rộng khu vực có thể tập trung của nút Duyệt, để nó trở nên liền kề với các trường đăng nhập.

00:09:17.000 --> 00:09:21.000
Điều này được thực hiện bằng cách sử dụng FocusSections API mới.

00:09:21.000 --> 00:09:23.000
Hãy xem điều đó dễ dàng như thế nào.

00:09:23.000 --> 00:09:29.000
Ở đây chúng tôi có một phiên bản đơn giản của mã Vacation Planner cho TV.

00:09:29.000 --> 00:09:37.000
Nó chứa một HStack với hai VStacks; một cho các trường đăng nhập, và một VStack khác cho hình ảnh và nút.

00:09:37.000 --> 00:09:47.000
Chúng tôi muốn tạo một mục tiêu tiêu điểm logic lớn hơn xung quanh nút để tiêu điểm có thể hoạt động như thể nút liền kề với các trường đăng nhập.

00:09:47.000 --> 00:09:54.000
Điều này có thể được thực hiện bằng cách chỉ cần thêm một công cụ sửa đổi focusSection() vào VStack có chứa nút.

00:09:54.000 --> 00:10:05.000
Khi công cụ sửa đổi focusSection() được thêm vào bất kỳ chế độ xem nào, khung của chế độ xem đó có khả năng chấp nhận tiêu điểm nếu nó chứa bất kỳ chế độ xem phụ có thể tập trung nào.

00:10:05.000 --> 00:10:16.000
Vì chúng tôi cũng muốn di chuyển tiêu điểm trở lại các trường đăng nhập khi vuốt sang trái trên nút, chúng tôi sẽ thêm một công cụ sửa đổi focusSection() khác vào VStack đầu tiên.

00:10:16.000 --> 00:10:25.000
Bây giờ khi chúng tôi chạy ứng dụng này, người dùng có thể di chuyển tiêu điểm giữa các trường nhập và nút Duyệt bằng cách vuốt sang trái và phải trên điều khiển từ xa.

00:10:25.000 --> 00:10:33.000
Khi chúng ta kết thúc mọi thứ, tôi khuyến khích bạn suy nghĩ về sự tập trung, thường có thể trông khác nhau trên các nền tảng khác nhau.

00:10:33.000 --> 00:10:38.000
SwiftUI có các hành vi mặc định tuyệt vời được tích hợp sẵn cho hầu hết các trường hợp.

00:10:38.000 --> 00:10:47.000
Các trạng thái tập trung mới và API FocusSections có thể giúp bạn tận dụng sự tập trung để tạo ra những trải nghiệm hợp lý hơn nữa.

00:10:47.000 --> 00:10:55.000
Khi bạn làm việc trên các ứng dụng của mình, hãy dành một chút thời gian để quan sát nhiều cách mà sự tập trung tác động đến hành vi của người dùng.

00:10:55.000 --> 00:11:01.000
Chúng tôi hy vọng phiên này đã trang bị cho bạn các công cụ giúp người dùng tập trung vào những gì quan trọng nhất.

00:11:01.000 --> 00:11:04.000
Cảm ơn vì đã xem, và chúc bạn có một WWDC tuyệt vời!

00:11:04.000 --> 23:59:59.000
♪

