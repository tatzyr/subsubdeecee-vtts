WEBVTT

00:00:00.000 --> 00:00:05.000
♪ Nhạc bass đang phát ♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:14.000
Matt Ricketson: Xin chào, tôi là Matt, và sau này tôi sẽ được tham gia bởi Luca và Raj.

00:00:14.000 --> 00:00:17.000
Hôm nay, chúng ta sẽ làm sáng tỏ SwiftUI.

00:00:17.000 --> 00:00:24.000
Bây giờ, chúng tôi đã nghe nhiều lần trước đây rằng SwiftUI là một khung giao diện người dùng khai báo.

00:00:24.000 --> 00:00:32.000
Điều đó có nghĩa là bạn mô tả những gì bạn muốn cho ứng dụng của mình ở cấp độ cao và SwiftUI quyết định chính xác cách biến nó thành hiện thực.

00:00:32.000 --> 00:00:34.000
Bây giờ, hầu hết thời gian, điều này hoạt động rất tốt!

00:00:34.000 --> 00:00:37.000
Và đó là khi SwiftUI cảm thấy kỳ diệu.

00:00:37.000 --> 00:00:42.000
Nhưng sẽ luôn có những khoảnh khắc khi SwiftUI làm điều gì đó mà bạn có thể không ngờ tới.

00:00:42.000 --> 00:00:54.000
Và trong những khoảnh khắc đó, nó giúp hiểu thêm một chút về những gì SwiftUI đang làm đằng sau hậu trường để xây dựng trực giác tốt hơn về cách đạt được kết quả mà bạn đang tìm kiếm.

00:00:54.000 --> 00:00:59.000
Vậy câu hỏi hôm nay là, Khi SwiftUI nhìn vào mã của bạn, nó sẽ thấy gì?

00:00:59.000 --> 00:01:06.000
Câu trả lời là ba điều: danh tính, cuộc sống và sự phụ thuộc.

00:01:06.000 --> 00:01:15.000
Nhận dạng là cách SwiftUI nhận ra các yếu tố giống nhau hoặc khác biệt trên nhiều bản cập nhật ứng dụng của bạn.

00:01:15.000 --> 00:01:21.000
Trọn đời là cách SwiftUI theo dõi sự tồn tại của các chế độ xem và dữ liệu theo thời gian.

00:01:21.000 --> 00:01:28.000
Và sự phụ thuộc là cách SwiftUI hiểu khi giao diện của bạn cần được cập nhật và tại sao.

00:01:28.000 --> 00:01:40.000
Cùng với nhau, ba khái niệm này thông báo cách SwiftUI quyết định những gì cần thay đổi, như thế nào và khi nào, dẫn đến giao diện người dùng động mà bạn nhìn thấy trên màn hình.

00:01:40.000 --> 00:01:46.000
Hôm nay, chúng ta sẽ nói về từng khái niệm trong ba khái niệm này sâu hơn.

00:01:46.000 --> 00:01:51.000
Hãy bắt đầu với danh tính, và tôi có một vài người bạn ở đây để giúp tôi.

00:01:51.000 --> 00:01:59.000
Những chú chó Ruby Spaniel này rất đáng yêu, nhưng chúng cũng là chủ đề của một câu hỏi triết học sâu sắc.

00:01:59.000 --> 00:02:01.000
Hai con chó này có khác nhau không?

00:02:01.000 --> 00:02:06.000
Hay đây, trên thực tế, là hai bức ảnh của cùng một con chó?

00:02:06.000 --> 00:02:09.000
Sự thật là, không thể nói được!

00:02:09.000 --> 00:02:11.000
Chúng tôi chỉ không có đủ thông tin.

00:02:11.000 --> 00:02:19.000
Nhưng câu hỏi về việc mọi thứ giống nhau hay khác nhau là trọng tâm của cái mà chúng ta gọi là "danh tính".

00:02:19.000 --> 00:02:21.000
Tuy nhiên, danh tính không chỉ quan trọng đối với chó.

00:02:21.000 --> 00:02:27.000
Nó cũng là một khía cạnh quan trọng trong cách SwiftUI hiểu ứng dụng của bạn.

00:02:27.000 --> 00:02:30.000
Hãy xem xét một ví dụ.

00:02:30.000 --> 00:02:37.000
Đây là một ứng dụng tôi đã tạo ra có tên là "Good Dog, Bad Dog", giúp tôi theo dõi xem liệu người bạn lông xù của tôi có cư xử tốt nhất hay không.

00:02:37.000 --> 00:02:38.000
Nó khá đơn giản.

00:02:38.000 --> 00:02:43.000
Tôi chỉ có thể chạm vào bất cứ đâu trên màn hình để lật giữa trạng thái tốt và xấu.

00:02:43.000 --> 00:02:47.000
Vậy danh tính có liên quan gì đến ứng dụng của tôi?

00:02:47.000 --> 00:02:53.000
Chà, nó thực sự rất giống với câu hỏi triết học mà chúng tôi vừa hỏi về những con chó.

00:02:53.000 --> 00:02:59.000
Nhìn vào những biểu tượng đó, chúng có vẻ giống như hai góc nhìn khác nhau, hoàn toàn khác biệt với nhau không?

00:02:59.000 --> 00:03:04.000
Hay chúng có thể là cùng một góc nhìn, chỉ ở một nơi khác và với một màu sắc khác?

00:03:04.000 --> 00:03:13.000
Sự khác biệt đó thực sự rất quan trọng vì nó thay đổi cách giao diện của chúng ta chuyển từ trạng thái này sang trạng thái khác.

00:03:13.000 --> 00:03:17.000
Giả sử những biểu tượng đó, trên thực tế, là những góc nhìn khác nhau.

00:03:17.000 --> 00:03:24.000
Điều đó có nghĩa là các biểu tượng nên chuyển đổi độc lập, chẳng hạn như mờ dần vào và ra.

00:03:24.000 --> 00:03:27.000
Nhưng điều gì sẽ xảy ra nếu họ, trên thực tế, cùng một quan điểm?

00:03:27.000 --> 00:03:37.000
Thay vào đó, điều đó ngụ ý rằng chế độ xem sẽ trượt trên màn hình trong quá trình chuyển đổi vì đó là cùng một chế độ xem di chuyển từ vị trí này sang vị trí khác.

00:03:37.000 --> 00:03:45.000
Vì vậy, việc kết nối các chế độ xem giữa các trạng thái khác nhau là rất quan trọng, bởi vì đó là cách SwiftUI hiểu cách chuyển đổi giữa chúng.

00:03:45.000 --> 00:03:50.000
Đây là khái niệm chính đằng sau nhận dạng chế độ xem.

00:03:50.000 --> 00:03:57.000
Các chế độ xem có cùng bản sắc đại diện cho các trạng thái khác nhau của cùng một yếu tố giao diện người dùng khái niệm.

00:03:57.000 --> 00:04:03.000
Ngược lại, các chế độ xem đại diện cho các yếu tố giao diện người dùng riêng biệt sẽ luôn có các danh tính khác nhau.

00:04:03.000 --> 00:04:11.000
Sau đó trong buổi nói chuyện, Luca và Raj sẽ nói về những tác động thực tế của nhận dạng chế độ xem đối với dữ liệu ứng dụng của bạn và chu kỳ cập nhật.

00:04:11.000 --> 00:04:21.000
Hiện tại, hãy xem danh tính được thể hiện như thế nào trong mã của bạn, tập trung vào hai loại danh tính khác nhau được SwiftUI sử dụng.

00:04:21.000 --> 00:04:27.000
Đầu tiên, nhận dạng rõ ràng: sử dụng các số nhận dạng tùy chỉnh hoặc dựa trên dữ liệu.

00:04:27.000 --> 00:04:35.000
Và thứ hai, bản sắc cấu trúc: phân biệt các quan điểm theo loại và vị trí của chúng trong hệ thống phân cấp chế độ xem.

00:04:35.000 --> 00:04:40.000
Bây giờ, để giúp hiểu những khái niệm này, hãy để tôi giới thiệu bạn với một số người bạn khác của tôi.

00:04:40.000 --> 00:04:47.000
Được rồi, hãy nhớ rằng có thể khó phân biệt những con chó, đặc biệt là khi chúng trông giống nhau.

00:04:47.000 --> 00:04:52.000
Vậy loại thông tin bổ sung nào sẽ giúp chúng ta xác định những chú chó của mình?

00:04:52.000 --> 00:04:56.000
Một cách đơn giản là hỏi tên của họ.

00:04:56.000 --> 00:05:04.000
Nếu hai con chó trông giống nhau và cũng có cùng tên, thì tôi sẽ nói rằng trên thực tế, chúng rất có thể là cùng một con chó.

00:05:04.000 --> 00:05:10.000
Nhưng nếu chúng có tên khác nhau, thì chúng tôi có thể đảm bảo rằng trên thực tế, chúng là những con chó khác nhau.

00:05:10.000 --> 00:05:16.000
Gán tên hoặc số nhận dạng như thế này là một hình thức nhận dạng rõ ràng.

00:05:16.000 --> 00:05:24.000
Danh tính rõ ràng rất mạnh mẽ và linh hoạt, nhưng yêu cầu ai đó, ở đâu đó theo dõi tất cả những cái tên đó.

00:05:24.000 --> 00:05:32.000
Một dạng nhận dạng rõ ràng mà bạn có thể đã quen thuộc là nhận dạng con trỏ, được sử dụng trong suốt UIKit và AppKit.

00:05:32.000 --> 00:05:40.000
Bây giờ, SwiftUI không sử dụng nhận dạng con trỏ, nhưng tìm hiểu về nó sẽ giúp bạn hiểu rõ hơn về cách thức và lý do SwiftUI hoạt động khác nhau.

00:05:40.000 --> 00:05:42.000
Hãy xem nhanh.

00:05:42.000 --> 00:05:45.000
Hãy xem xét hệ thống phân cấp chế độ xem UIKit hoặc AppKit, như thế này.

00:05:45.000 --> 00:05:53.000
Vì UIViews và NSViews là các lớp, mỗi lớp đều có một con trỏ duy nhất để phân bổ bộ nhớ của chúng.

00:05:53.000 --> 00:05:56.000
Con trỏ là một nguồn tự nhiên của danh tính rõ ràng.

00:05:56.000 --> 00:06:07.000
Chúng ta có thể tham khảo các chế độ xem riêng lẻ chỉ bằng cách sử dụng con trỏ của chúng và nếu hai chế độ xem chia sẻ cùng một con trỏ, chúng ta có thể đảm bảo rằng chúng thực sự là cùng một chế độ xem.

00:06:07.000 --> 00:06:16.000
Nhưng SwiftUI không sử dụng con trỏ vì chế độ xem SwiftUI là các loại giá trị, thường được biểu diễn dưới dạng cấu trúc thay vì các lớp.

00:06:16.000 --> 00:06:27.000
Trong bài nói chuyện "SwiftUI essentials" từ năm 2019, chúng tôi đã thảo luận về lý do tại sao SwiftUI sử dụng các loại giá trị thay vì các lớp học cho quan điểm của nó, vì vậy tôi khuyên bạn nên xem cuộc nói chuyện đó để tìm hiểu thêm.

00:06:27.000 --> 00:06:37.000
Hiện tại, điều quan trọng cần biết là các loại giá trị không có tham chiếu chuẩn mà SwiftUI có thể sử dụng như một danh tính liên tục cho các quan điểm của nó.

00:06:37.000 --> 00:06:42.000
Thay vào đó, SwiftUI dựa vào các hình thức nhận dạng rõ ràng khác.

00:06:42.000 --> 00:06:46.000
Ví dụ, hãy xem xét danh sách những chú chó cứu hộ này.

00:06:46.000 --> 00:06:51.000
Tham số id được sử dụng ở đây là một dạng nhận dạng rõ ràng.

00:06:51.000 --> 00:06:58.000
ID thẻ chó của mỗi con chó cứu hộ được sử dụng để xác định rõ ràng chế độ xem tương ứng của nó trong danh sách.

00:06:58.000 --> 00:07:08.000
Nếu bộ sưu tập chó cứu hộ thay đổi, SwiftUI có thể sử dụng các ID đó để hiểu chính xác những gì đã thay đổi và tạo ra các hình ảnh động chính xác trong danh sách.

00:07:08.000 --> 00:07:15.000
Trong trường hợp này, SwiftUI thậm chí còn có thể tạo hiệu ứng động chính xác cho các chế độ xem di chuyển giữa các phần khác nhau.

00:07:15.000 --> 00:07:18.000
Hãy xem xét một ví dụ nâng cao hơn.

00:07:18.000 --> 00:07:25.000
Ở đây, chúng tôi đang sử dụng ScrollViewReader để nhảy lên trên cùng của chế độ xem bằng cách sử dụng một nút ở dưới cùng.

00:07:25.000 --> 00:07:35.000
Công cụ sửa đổi id(_:) cung cấp một cách để xác định rõ ràng chế độ xem bằng cách sử dụng mã định danh tùy chỉnh - trong trường hợp này, chế độ xem tiêu đề của chúng tôi ở đầu trang.

00:07:35.000 --> 00:07:45.000
Sau đó, chúng ta có thể chuyển mã định danh đó cho phương thức scrollTo(_:) của proxy chế độ xem cuộn để yêu cầu SwiftUI chuyển đến chế độ xem cụ thể đó.

00:07:45.000 --> 00:07:55.000
Điều tuyệt vời về điều này là chúng ta không cần phải xác định rõ ràng mọi chế độ xem, chỉ là những chế độ xem mà chúng ta cần tham khảo ở nơi khác trong mã, như văn bản tiêu đề của chúng ta.

00:07:55.000 --> 00:08:03.000
Bằng cách so sánh, ScrollViewReader, ScrollView, backstory Text và Bbutton không cần số nhận dạng rõ ràng.

00:08:03.000 --> 00:08:15.000
Nhưng chỉ vì danh tính của họ không rõ ràng, điều đó không có nghĩa là những quan điểm này hoàn toàn không có danh tính vì mọi quan điểm đều có danh tính, ngay cả khi nó không rõ ràng.

00:08:15.000 --> 00:08:18.000
Đây là nơi bản sắc cấu trúc xuất hiện.

00:08:18.000 --> 00:08:27.000
SwiftUI sử dụng cấu trúc của hệ thống phân cấp chế độ xem của bạn để tạo danh tính ngầm cho chế độ xem của bạn để bạn không phải làm vậy.

00:08:27.000 --> 00:08:32.000
Bây giờ, hãy để tôi mang thêm một số bạn bè của mình đến để giúp giải thích ý tôi về điều đó.

00:08:32.000 --> 00:08:38.000
Giả sử chúng ta có hai con chó giống nhau nhưng chúng ta không biết tên của chúng, nhưng chúng ta vẫn cần xác định từng con.

00:08:38.000 --> 00:08:44.000
Chà, giả sử đây là những con chó rất ngoan và chúng có khả năng ngồi rất yên.

00:08:44.000 --> 00:08:54.000
Nếu chúng tôi có thể đảm bảo họ không di chuyển, chúng tôi có thể xác định họ chỉ dựa trên nơi họ đang ngồi, như "Con chó bên trái" hoặc "Con chó bên phải".

00:08:54.000 --> 00:09:02.000
Chúng tôi đang sử dụng sự sắp xếp tương đối của các đối tượng của mình để phân biệt chúng với nhau - đó là bản sắc cấu trúc.

00:09:02.000 --> 00:09:11.000
SwiftUI tận dụng nhận dạng cấu trúc trong toàn bộ API của nó và một ví dụ kinh điển là khi bạn sử dụng các câu lệnh if và logic có điều kiện khác trong mã Xem của mình.

00:09:11.000 --> 00:09:18.000
Cấu trúc của tuyên bố có điều kiện cho chúng ta một cách rõ ràng để xác định từng chế độ xem.

00:09:18.000 --> 00:09:25.000
Chế độ xem đầu tiên chỉ hiển thị khi điều kiện là đúng, trong khi chế độ xem thứ hai chỉ hiển thị khi điều kiện sai.

00:09:25.000 --> 00:09:31.000
Điều đó có nghĩa là chúng ta luôn có thể biết quan điểm nào là cái nào, ngay cả khi chúng tình cờ trông giống nhau.

00:09:31.000 --> 00:09:39.000
Tuy nhiên, điều này chỉ hoạt động nếu SwiftUI có thể đảm bảo tĩnh rằng các chế độ xem này vẫn ở nguyên vị trí của chúng và không bao giờ đổi chỗ.

00:09:39.000 --> 00:09:45.000
SwiftUI hoàn thành điều này bằng cách xem xét cấu trúc loại của hệ thống phân cấp chế độ xem của bạn.

00:09:45.000 --> 00:09:58.000
Khi SwiftUI nhìn vào quan điểm của bạn, nó sẽ thấy các loại chung của chúng - trong trường hợp này, câu lệnh if của chúng tôi được dịch thành chế độ xem _ConditionalContent, là chung chung so với nội dung đúng và sai của nó.

00:09:58.000 --> 00:10:05.000
Bản dịch này được cung cấp bởi ViewBuilder, đây là một loại trình tạo kết quả trong Swift.

00:10:05.000 --> 00:10:15.000
Giao thức View ngầm bọc thuộc tính cơ thể của nó trong ViewBuilder, xây dựng một chế độ xem chung duy nhất từ các câu lệnh logic trong thuộc tính của chúng tôi.

00:10:15.000 --> 00:10:25.000
Loại trả về some View của thuộc tính cơ thể của chúng ta là một trình giữ chỗ đại diện cho loại tổng hợp tĩnh này, ẩn nó đi để nó không làm lộn xộn mã của chúng ta.

00:10:25.000 --> 00:10:42.000
Sử dụng loại chung này, SwiftUI có thể đảm bảo rằng chế độ xem thực sẽ luôn là Thư mục nhận con nuôi, trong khi chế độ xem Sai sẽ luôn là DogList, cho phép chúng được gán một danh tính ngầm, ổn định đằng sau hậu trường.

00:10:42.000 --> 00:10:48.000
Trên thực tế, đây là chìa khóa để hiểu ứng dụng Good Dog, Bad Dog từ trước đó.

00:10:48.000 --> 00:10:55.000
Với mã ở trên cùng, chúng tôi có một câu lệnh if xác định các chế độ xem khác nhau cho mỗi nhánh có điều kiện.

00:10:55.000 --> 00:11:06.000
Điều này sẽ khiến các chế độ xem chuyển đổi vào và ra vì SwiftUI hiểu rằng mỗi nhánh của câu lệnh if đại diện cho một chế độ xem khác nhau với một danh tính riêng biệt.

00:11:06.000 --> 00:11:13.000
Ngoài ra, chúng ta chỉ có thể có một PawView duy nhất thay đổi bố cục và màu sắc của nó.

00:11:13.000 --> 00:11:19.000
Khi nó chuyển sang một trạng thái khác, chế độ xem sẽ trượt trơn tru đến vị trí tiếp theo.

00:11:19.000 --> 00:11:24.000
Đó là bởi vì chúng tôi đang sửa đổi một chế độ xem duy nhất với một danh tính nhất quán.

00:11:24.000 --> 00:11:30.000
Cả hai chiến lược này đều có thể hiệu quả, nhưng SwiftUI thường đề xuất cách tiếp cận thứ hai.

00:11:30.000 --> 00:11:34.000
Theo mặc định, cố gắng bảo tồn danh tính và cung cấp nhiều chuyển tiếp trôi chảy hơn.

00:11:34.000 --> 00:11:41.000
Điều này cũng giúp duy trì tuổi thọ và trạng thái quan điểm của bạn, điều mà Luca sẽ nói chi tiết hơn sau này.

00:11:41.000 --> 00:11:48.000
Bây giờ chúng ta đã hiểu bản sắc cấu trúc, chúng ta cần nói về kẻ thù độc ác của nó, AnyView.

00:11:48.000 --> 00:11:55.000
Để hiểu tác động của việc sử dụng AnyView, hãy xem xét ảnh hưởng của nó đối với cấu trúc quan điểm của bạn.

00:11:55.000 --> 00:12:00.000
Trước đó chúng tôi đã viết câu lệnh if này để chuyển đổi giữa AdoptionDirectory và DogList.

00:12:00.000 --> 00:12:06.000
Khi SwiftUI nhìn vào mã này, nó sẽ thấy cấu trúc loại chung ở bên phải.

00:12:06.000 --> 00:12:11.000
Bây giờ hãy xem xét một ví dụ khác, một ví dụ sử dụng AnyView rộng rãi.

00:12:11.000 --> 00:12:17.000
Đây là một chức năng trợ giúp mà tôi đã viết để có được một cái nhìn đại diện cho giống chó.

00:12:17.000 --> 00:12:28.000
Mỗi nhánh có điều kiện trong hàm trả về một loại chế độ xem khác nhau, vì vậy tôi đã gói tất cả chúng trong AnyViews vì Swift yêu cầu một loại trả về duy nhất cho toàn bộ hàm.

00:12:28.000 --> 00:12:34.000
Thật không may, điều này cũng có nghĩa là SwiftUI không thể nhìn thấy cấu trúc có điều kiện của mã của tôi.

00:12:34.000 --> 00:12:39.000
Thay vào đó, nó chỉ xem AnyView như một loại trả về của hàm.

00:12:39.000 --> 00:12:49.000
Điều này là do AnyView được gọi là "loại trình bao bọc xóa kiểu" - nó ẩn loại chế độ xem mà nó đang gói khỏi chữ ký chung của nó.

00:12:49.000 --> 00:12:56.000
Nhưng có lẽ quan trọng hơn, mã này cũng thực sự khó đọc đối với chúng ta chỉ là con người.

00:12:56.000 --> 00:13:03.000
Hãy xem liệu chúng ta có thể đơn giản hóa mã này và cũng hiển thị nhiều cấu trúc của nó hơn cho SwiftUI hay không.

00:13:03.000 --> 00:13:12.000
Đầu tiên, có vẻ như nhánh này đang thêm SheepView có điều kiện cùng với BorderCollieView của chúng tôi nếu có cừu gần đó.

00:13:12.000 --> 00:13:22.000
Chúng ta có thể đơn giản hóa điều này bằng cách thêm có điều kiện chế độ xem bên trong HStack thay vì thêm HStack có điều kiện xung quanh chế độ xem của chúng ta.

00:13:22.000 --> 00:13:31.000
Với sự thay đổi đó, giờ đây thật dễ dàng để thấy rằng chúng tôi chỉ trả về một chế độ xem duy nhất từ mỗi nhánh, vì vậy biến dogView cục bộ của chúng tôi là không cần thiết.

00:13:31.000 --> 00:13:36.000
Thay vào đó, chúng ta có thể thay thế nó bằng các câu lệnh trả về bên trong mỗi nhánh.

00:13:36.000 --> 00:13:44.000
Như chúng ta đã thấy trước đó, mã SwiftUI View thông thường có thể sử dụng nếu các câu lệnh trả về các loại chế độ xem khác nhau.

00:13:44.000 --> 00:13:52.000
Nhưng nếu chúng ta chỉ thử xóa các câu lệnh trả về và AnyViews khỏi mã của mình, chúng ta sẽ thấy một số lỗi và cảnh báo xuất hiện.

00:13:52.000 --> 00:13:57.000
Điều này là do SwiftUI yêu cầu một loại trả về duy nhất từ chức năng trợ giúp của chúng tôi.

00:13:57.000 --> 00:14:00.000
Vậy làm thế nào chúng ta có thể tránh được những lỗi này?

00:14:00.000 --> 00:14:08.000
Nhớ lại rằng thuộc tính nội dung của chế độ xem là đặc biệt, bởi vì giao thức Chế độ xem ngầm bọc nó trong ViewBuilder.

00:14:08.000 --> 00:14:14.000
Điều này chuyển logic trong thuộc tính thành một cấu trúc xem chung, duy nhất.

00:14:14.000 --> 00:14:24.000
Bây giờ, Swift không suy ra các chức năng trợ giúp là trình tạo chế độ xem theo mặc định, nhưng chúng ta có thể chọn tham gia bằng cách tự áp dụng thủ công thuộc tính ViewBuilder.

00:14:24.000 --> 00:14:32.000
Và điều đó cho phép chúng tôi xóa các câu lệnh trả về và trình bao bọc AnyView mà không có bất kỳ cảnh báo hoặc lỗi nào.

00:14:32.000 --> 00:14:35.000
Được rồi, mã của chúng tôi bây giờ trông khá ổn!

00:14:35.000 --> 00:14:40.000
Chúng tôi đã loại bỏ tất cả AnyViews, giúp nó dễ đọc hơn trước.

00:14:40.000 --> 00:14:57.000
Và nếu chúng ta nhìn vào chữ ký loại của kết quả, bây giờ nó sao chép chính xác logic có điều kiện của chức năng của chúng ta với một cây nội dung có điều kiện, cung cấp cho SwiftUI một góc nhìn phong phú hơn nhiều về chế độ xem và danh tính của các thành phần của nó.

00:14:57.000 --> 00:15:00.000
Nhưng có một cải tiến nhỏ nữa mà chúng ta có thể thực hiện.

00:15:00.000 --> 00:15:05.000
Cấp độ cao nhất của chức năng của chúng tôi chỉ phù hợp với các trường hợp khác nhau của giống chó.

00:15:05.000 --> 00:15:12.000
Đây có vẻ như là một trường hợp sử dụng tuyệt vời cho một câu lệnh chuyển đổi, cũng được hỗ trợ bởi các trình tạo chế độ xem.

00:15:12.000 --> 00:15:17.000
Bây giờ thậm chí còn dễ dàng hơn để nhanh chóng hiểu tất cả các trường hợp khác nhau trong quan điểm của chúng tôi.

00:15:17.000 --> 00:15:27.000
Và bởi vì các câu lệnh chuyển đổi thực sự chỉ là đường cú pháp cho các câu lệnh có điều kiện, chữ ký loại của chế độ xem kết quả của chúng tôi ở bên phải vẫn giữ nguyên.

00:15:27.000 --> 00:15:38.000
Quay trở lại, chúng tôi vừa chỉ cho bạn cách AnyViews xóa thông tin loại khỏi mã của bạn và hướng dẫn cách loại bỏ AnyViews không cần thiết bằng cách tận dụng các trình tạo chế độ xem.

00:15:38.000 --> 00:15:43.000
Nói chung, chúng tôi khuyên bạn nên tránh AnyViews bất cứ khi nào có thể.

00:15:43.000 --> 00:15:48.000
Có quá nhiều AnyViews thường sẽ khiến mã khó đọc và dễ hiểu hơn.

00:15:48.000 --> 00:15:56.000
Các câu lệnh luồng điều khiển truyền thống như if/else và switch giúp dễ dàng nhìn thấy các trạng thái khác nhau có thể có của chế độ xem.

00:15:56.000 --> 00:16:06.000
Và bởi vì AnyView ẩn thông tin loại tĩnh khỏi trình biên dịch, đôi khi nó có thể ngăn chặn các lỗi chẩn đoán hữu ích và cảnh báo xuất hiện trong mã của bạn.

00:16:06.000 --> 00:16:13.000
Cuối cùng, hãy nhớ rằng sử dụng AnyView khi bạn không cần có thể dẫn đến hiệu suất kém hơn.

00:16:13.000 --> 00:16:20.000
Khi có thể, hãy sử dụng generics để bảo toàn thông tin loại tĩnh thay vì chuyển AnyViews xung quanh mã của bạn.

00:16:20.000 --> 00:16:26.000
Và cùng với đó, chúng tôi đã hoàn thành việc giới thiệu các loại nhận dạng chế độ xem cơ bản trong SwiftUI.

00:16:26.000 --> 00:16:35.000
Với danh tính rõ ràng, chúng tôi có thể liên kết danh tính của các chế độ xem với dữ liệu của mình hoặc cung cấp số nhận dạng tùy chỉnh để tham chiếu đến các chế độ xem cụ thể.

00:16:35.000 --> 00:16:44.000
Và với bản sắc cấu trúc, chúng tôi đã học được cách SwiftUI có thể xác định quan điểm của chúng tôi chỉ dựa trên loại và vị trí của chúng trong hệ thống phân cấp chế độ xem.

00:16:44.000 --> 00:16:51.000
Và bây giờ tôi sẽ giao mọi thứ cho Luca để thảo luận về bản sắc quan điểm của bạn liên quan đến cuộc đời và trạng thái của họ như thế nào.

00:16:51.000 --> 00:16:53.000
Luca Bernardi: Cảm ơn, Matt.

00:16:53.000 --> 00:17:03.000
Bây giờ chúng tôi đã hiểu cách SwiftUI xác định quan điểm của bạn, hãy khám phá cách nhận dạng liên quan đến tuổi thọ của quan điểm và dữ liệu của bạn.

00:17:03.000 --> 00:17:07.000
Điều này sẽ giúp bạn hiểu rõ hơn về cách SwiftUI hoạt động.

00:17:07.000 --> 00:17:12.000
Để giúp minh họa điều này, tôi cũng sẽ mang theo một người bạn.

00:17:12.000 --> 00:17:13.000
Đây là Theseus.

00:17:13.000 --> 00:17:15.000
Anh ấy cũng không đáng yêu sao?

00:17:15.000 --> 00:17:18.000
Ai đó sẽ nói đáng yêu hơn, nhưng tôi lạc đề.

00:17:18.000 --> 00:17:31.000
Chúng ta rất trực quan khi nghĩ rằng một khi chúng ta đặt tên cho thú cưng yêu thích của mình, nó sẽ luôn là cùng một con mèo đáng yêu, ngay cả khi nó ở các trạng thái khác nhau và nó di chuyển suốt cả ngày.

00:17:31.000 --> 00:17:44.000
Khi chúng tôi nhìn anh ấy một lúc, anh ấy có thể buồn ngủ và một lúc sau, là một con mèo thích hợp, anh ấy khó chịu vì sự hiện diện của tôi - nhưng anh ấy sẽ luôn là Theseus.

00:17:44.000 --> 00:17:48.000
Đây là bản chất của việc kết nối bản sắc với cuộc sống.

00:17:48.000 --> 00:17:55.000
Danh tính cho phép chúng tôi xác định một yếu tố ổn định cho các giá trị khác nhau theo thời gian.

00:17:55.000 --> 00:18:00.000
Nói cách khác, nó cho phép chúng tôi giới thiệu tính liên tục theo thời gian.

00:18:00.000 --> 00:18:04.000
Bạn có thể tự hỏi, điều này áp dụng cho SwiftUI như thế nào?

00:18:04.000 --> 00:18:10.000
Vì vậy, hãy mang về một phiên bản thân thiện với mèo của ứng dụng mà Matt đang làm việc.

00:18:10.000 --> 00:18:21.000
Giống như Theseus có thể ở các trạng thái khác nhau vào những thời điểm khác nhau, quan điểm của chúng ta cũng ở các trạng thái khác nhau trong suốt cuộc đời của chúng.

00:18:21.000 --> 00:18:26.000
Mỗi trạng thái là một giá trị khác nhau đối với quan điểm của chúng tôi.

00:18:26.000 --> 00:18:33.000
Danh tính kết nối các giá trị khác nhau này như một thực thể duy nhất - một chế độ xem - theo thời gian.

00:18:33.000 --> 00:18:36.000
Hãy xem xét một số mã để làm rõ điều này.

00:18:36.000 --> 00:18:41.000
Ở đây chúng tôi có một cái nhìn đơn giản hiển thị cường độ của tiếng rừ rừ.

00:18:41.000 --> 00:18:44.000
Spoiler: Theseus khá ồn ào.

00:18:44.000 --> 00:18:54.000
Thông qua việc đánh giá cơ thể, SwiftUI sẽ tạo ra một giá trị mới cho chế độ xem này; trong trường hợp này, với giá trị cường độ là 25.

00:18:54.000 --> 00:18:58.000
Theseus đang đói và muốn được chú ý nhiều hơn.

00:18:58.000 --> 00:19:05.000
Phần thân được gọi lại với cường độ cao hơn và giá trị mới cho chế độ xem được tạo ra.

00:19:05.000 --> 00:19:11.000
Đây là hai giá trị riêng biệt được tạo ra từ cùng một định nghĩa quan điểm.

00:19:11.000 --> 00:19:19.000
SwiftUI sẽ giữ xung quanh một bản sao của giá trị để thực hiện so sánh và biết liệu chế độ xem có thay đổi hay không.

00:19:19.000 --> 00:19:23.000
Nhưng sau đó, giá trị bị phá hủy.

00:19:23.000 --> 00:19:30.000
Điều quan trọng cần hiểu ở đây là giá trị chế độ xem khác với danh tính chế độ xem.

00:19:30.000 --> 00:19:34.000
Các giá trị chế độ xem là phù du và bạn không nên dựa vào cuộc sống của chúng.

00:19:34.000 --> 00:19:39.000
Nhưng những gì bạn có thể kiểm soát là danh tính của họ.

00:19:39.000 --> 00:19:49.000
Khi một chế độ xem được tạo lần đầu tiên và nó xuất hiện, SwiftUI sẽ gán cho nó một danh tính bằng cách sử dụng kết hợp các kỹ thuật đã thảo luận trước đó.

00:19:49.000 --> 00:19:55.000
Theo thời gian, được thúc đẩy bởi các bản cập nhật, các giá trị mới cho chế độ xem được tạo ra.

00:19:55.000 --> 00:20:01.000
Nhưng từ quan điểm của SwiftUI, những thứ này đại diện cho cùng một quan điểm.

00:20:01.000 --> 00:20:08.000
Khi danh tính của chế độ xem thay đổi hoặc chế độ xem bị xóa, tuổi thọ của nó sẽ kết thúc.

00:20:08.000 --> 00:20:17.000
Bất cứ khi nào chúng ta nói về thời gian tồn tại của một chế độ xem, chúng ta đang đề cập đến thời lượng của danh tính liên quan đến chế độ xem đó.

00:20:17.000 --> 00:20:27.000
Có thể kết nối danh tính của một chế độ xem với vòng đời của nó là điều cơ bản để hiểu cách SwiftUI duy trì trạng thái của bạn.

00:20:27.000 --> 00:20:31.000
Vì vậy, hãy đưa State và StateObject vào bức tranh.

00:20:31.000 --> 00:20:43.000
Khi SwiftUI đang nhìn vào chế độ xem của bạn và thấy một Trạng thái hoặc một Đối tượng Trạng thái, nó biết rằng nó cần duy trì phần dữ liệu đó trong suốt vòng đời của chế độ xem.

00:20:43.000 --> 00:20:52.000
Nói cách khác, State và StateObject là bộ nhớ liên tục được liên kết với danh tính chế độ xem của bạn.

00:20:52.000 --> 00:21:05.000
Khi bắt đầu nhận dạng của chế độ xem, khi nó được tạo lần đầu tiên, SwiftUI sẽ phân bổ dung lượng lưu trữ trong bộ nhớ cho State và StateObject bằng cách sử dụng các giá trị ban đầu của chúng.

00:21:05.000 --> 00:21:09.000
Ở đây chúng tôi đang tập trung vào trạng thái tiêu đề.

00:21:09.000 --> 00:21:19.000
Trong suốt vòng đời của chế độ xem, SwiftUI sẽ duy trì bộ nhớ này khi nó bị đột biến và phần thân của chế độ xem được đánh giá lại.

00:21:19.000 --> 00:21:25.000
Hãy xem xét một ví dụ cụ thể về những thay đổi trong bản sắc ảnh hưởng như thế nào đến sự tồn tại của nhà nước.

00:21:25.000 --> 00:21:31.000
Đây là một ví dụ thú vị vì chúng ta có cùng quan điểm nhưng ở hai nhánh riêng biệt.

00:21:31.000 --> 00:21:40.000
Nếu bạn nhớ từ trước, vì bản sắc cấu trúc, hai quan điểm được coi là có bản sắc khác nhau.

00:21:40.000 --> 00:21:49.000
Matt đã thảo luận về việc điều này ảnh hưởng đến hoạt ảnh như thế nào, nhưng điều này cũng có tác động sâu sắc đến sự tồn tại của tiểu bang bạn.

00:21:49.000 --> 00:21:51.000
Hãy xem điều này trong thực tế.

00:21:51.000 --> 00:22:03.000
Khi chúng tôi đánh giá nội dung lần đầu tiên và chúng tôi nhập nhánh thực, SwiftUI sẽ phân bổ bộ nhớ liên tục cho trạng thái với giá trị ban đầu của nó.

00:22:03.000 --> 00:22:11.000
Trong suốt vòng đời của quan điểm này, SwiftUI vẫn duy trì trạng thái khi nó bị đột biến bởi nhiều hành động khác nhau.

00:22:11.000 --> 00:22:17.000
Nhưng điều gì sẽ xảy ra nếu giá trị của dayTime thay đổi và chúng ta nhập nhánh sai?

00:22:17.000 --> 00:22:23.000
SwiftUI biết đây là một quan điểm khác với một bản sắc riêng biệt.

00:22:23.000 --> 00:22:35.000
Nó tạo ra bộ nhớ mới cho chế độ xem sai, bắt đầu với giá trị ban đầu của trạng thái và bộ nhớ cho chế độ xem thực được phân bổ ngay sau đó.

00:22:35.000 --> 00:22:38.000
Nhưng nếu chúng ta quay trở lại chi nhánh thực sự thì sao?

00:22:38.000 --> 00:22:47.000
Chà, đó là một chế độ xem mới một lần nữa, vì vậy SwiftUI tạo bộ nhớ mới, bắt đầu lại từ giá trị ban đầu của tiểu bang.

00:22:47.000 --> 00:22:54.000
Điều rút ra ở đây là bất cứ khi nào danh tính thay đổi, trạng thái sẽ được thay thế.

00:22:54.000 --> 00:23:07.000
Hãy để tôi tạm dừng ở đây một chút và đảm bảo rằng bạn hiểu điểm quan trọng này: sự tồn tại của tiểu bang của bạn gắn liền với cuộc đời quan điểm của bạn.

00:23:07.000 --> 00:23:17.000
Đây là một khái niệm rất mạnh mẽ bởi vì chúng ta có thể tách biệt rõ ràng bản chất của một quan điểm - trạng thái của nó - và gắn nó với bản sắc của nó.

00:23:17.000 --> 00:23:21.000
Mọi thứ khác đều có thể bắt nguồn từ nó.

00:23:21.000 --> 00:23:35.000
Và dữ liệu của bạn quan trọng đến mức SwiftUI có một tập hợp các cấu trúc dựa trên dữ liệu sử dụng danh tính dữ liệu của bạn như một dạng nhận dạng rõ ràng cho quan điểm của bạn.

00:23:35.000 --> 00:23:39.000
Ví dụ kinh điển về điều này là ForEach.

00:23:39.000 --> 00:23:44.000
Bây giờ chúng ta hãy xem xét tất cả các cách khác nhau mà bạn có thể khởi tạo ForEach.

00:23:44.000 --> 00:23:49.000
Điều này sẽ giúp chúng ta xây dựng trực giác tốt hơn xung quanh loại này.

00:23:49.000 --> 00:23:54.000
Dạng đơn giản nhất của ForEach là dạng có phạm vi không đổi.

00:23:54.000 --> 00:24:00.000
Đây là một trình khởi tạo rất tiện lợi, đặc biệt là khi bạn đang bắt đầu tạo mẫu một số giao diện người dùng mới.

00:24:00.000 --> 00:24:07.000
SwiftUI sẽ sử dụng độ lệch trong phạm vi này để xác định các chế độ xem do trình tạo chế độ xem tạo ra.

00:24:07.000 --> 00:24:16.000
Bằng cách yêu cầu một phạm vi không đổi, chúng tôi đảm bảo rằng các danh tính ổn định trong suốt vòng đời của chế độ xem.

00:24:16.000 --> 00:24:23.000
Trên thực tế, việc sử dụng trình khởi tạo này với dải động là một lỗi.

00:24:23.000 --> 00:24:29.000
Và mới trong năm nay, bạn sẽ thấy cảnh báo khi cung cấp phạm vi không liên tục.

00:24:29.000 --> 00:24:35.000
Hãy làm cho mọi thứ thú vị hơn và mang đến một bộ sưu tập dữ liệu năng động.

00:24:35.000 --> 00:24:41.000
Trình khởi tạo này lấy một bộ sưu tập và một đường dẫn khóa đến một thuộc tính đóng vai trò là số nhận dạng.

00:24:41.000 --> 00:24:55.000
Thuộc tính này phải có thể băm được vì SwiftUI sẽ sử dụng giá trị của nó để gán danh tính cho tất cả các chế độ xem được tạo từ các phần tử của bộ sưu tập.

00:24:55.000 --> 00:25:05.000
Sau đó, Raj sẽ chỉ cho bạn một số ví dụ về cách chọn một danh tính ổn định ảnh hưởng đến hiệu suất và tính chính xác của ứng dụng của bạn.

00:25:05.000 --> 00:25:18.000
Ý tưởng cung cấp danh tính ổn định cho dữ liệu của bạn quan trọng đến mức thư viện tiêu chuẩn xác định giao thức Nhận dạng để mô tả khả năng này.

00:25:18.000 --> 00:25:34.000
Và SwiftUI tận dụng tối đa giao thức này, cho phép bạn bỏ qua đường dẫn chính và sử dụng mã định danh được cung cấp bởi yêu cầu giao thức để xác định danh tính được liên kết với dữ liệu và quan điểm của bạn.

00:25:34.000 --> 00:25:45.000
Một điều mà tôi thực sự yêu thích ở Swift là chúng ta có thể tận dụng hệ thống loại của nó để mô tả chính xác những hạn chế của vấn đề mà chúng ta đang giải quyết.

00:25:45.000 --> 00:25:51.000
Vì vậy, hãy thưởng thức với tôi khi xem định nghĩa của trình khởi tạo mà chúng tôi đang sử dụng ở đây.

00:25:51.000 --> 00:25:58.000
Có rất nhiều điều thú vị trong định nghĩa ngắn gọn này, vì vậy hãy thử giải nén chúng.

00:25:58.000 --> 00:26:10.000
ForEach cần hai phần chính: một bộ sưu tập - ở đây được biểu thị bằng đối số chung Dữ liệu - và một cách để tạo chế độ xem từ mỗi phần tử của bộ sưu tập.

00:26:10.000 --> 00:26:21.000
Hình dạng của trình khởi tạo này sẽ cung cấp cho bạn trực giác rằng ForEach xác định mối quan hệ giữa một tập hợp dữ liệu và một tập hợp các quan điểm.

00:26:21.000 --> 00:26:29.000
Nhưng trên thực tế, phần thú vị nhất ở đây là chúng tôi hạn chế các yếu tố của bộ sưu tập có thể nhận dạng được.

00:26:29.000 --> 00:26:43.000
Một lần nữa, mục đích của giao thức Nhận dạng là cho phép loại của bạn cung cấp khái niệm nhận dạng ổn định để SwiftUI có thể theo dõi dữ liệu của bạn trong suốt vòng đời của nó.

00:26:43.000 --> 00:26:50.000
Trên thực tế, điều này rất giống với các khái niệm về bản sắc và cuộc sống mà chúng ta đã thảo luận trước đó.

00:26:50.000 --> 00:26:57.000
Chế độ xem SwiftUI có loại có thể nhận dạng và trình tạo chế độ xem là các thành phần dựa trên dữ liệu.

00:26:57.000 --> 00:27:06.000
Những chế độ xem này sử dụng danh tính của dữ liệu mà bạn cung cấp để xác định phạm vi vòng đời của các chế độ xem được liên kết với nó.

00:27:06.000 --> 00:27:14.000
Chọn một mã định danh tốt là cơ hội để bạn kiểm soát tuổi thọ của lượt xem và dữ liệu của mình.

00:27:14.000 --> 00:27:19.000
Vì vậy, hãy tóm tắt lại những gì chúng ta đã thảo luận trong phần này.

00:27:19.000 --> 00:27:24.000
Các giá trị quan điểm là phù du và bạn không nên dựa vào cuộc sống của chúng.

00:27:24.000 --> 00:27:31.000
Nhưng danh tính của họ thì không, và là thứ mang lại cho họ sự liên tục theo thời gian.

00:27:31.000 --> 00:27:39.000
Bạn đang kiểm soát danh tính quan điểm của mình và bạn có thể sử dụng danh tính để xác định phạm vi rõ ràng tuổi thọ của nhà nước.

00:27:39.000 --> 00:27:51.000
Và cuối cùng, SwiftUI tận dụng tối đa giao thức Nhận dạng cho các thành phần dựa trên dữ liệu, vì vậy điều quan trọng là chọn một mã định danh ổn định cho dữ liệu của bạn.

00:27:51.000 --> 00:27:56.000
Và bây giờ tiếp tục truyền thống, tôi sẽ giao nó cho Raj. Raj?

00:27:56.000 --> 00:27:58.000
Raj Ramamurthy: Cảm ơn, Luca!

00:27:58.000 --> 00:28:03.000
Cho đến nay, chúng tôi đã giải thích danh tính là gì và nó liên quan đến cuộc đời của một quan điểm như thế nào.

00:28:03.000 --> 00:28:07.000
Tiếp theo, tôi sẽ đi sâu vào cách SwiftUI cập nhật giao diện người dùng.

00:28:07.000 --> 00:28:12.000
Mục tiêu là cung cấp cho bạn một mô hình tinh thần tốt hơn về cách cấu trúc mã SwiftUI.

00:28:12.000 --> 00:28:17.000
Tôi cũng sẽ đưa ra một vài ví dụ phác thảo mọi thứ ở cuối.

00:28:17.000 --> 00:28:21.000
Để bắt đầu cuộc thảo luận về sự phụ thuộc này, chúng ta hãy xem xét một cái nhìn.

00:28:21.000 --> 00:28:22.000
Đây là một cái nhìn đơn giản.

00:28:22.000 --> 00:28:26.000
Nó hiển thị một nút thưởng cho một chú chó một món ăn.

00:28:26.000 --> 00:28:29.000
Xin lỗi, Luca, nhưng tôi là một người thích chó hơn.

00:28:29.000 --> 00:28:32.000
Hãy tập trung vào cấu trúc của chế độ xem.

00:28:32.000 --> 00:28:34.000
Đầu tiên, hãy nhìn vào phần trên.

00:28:34.000 --> 00:28:40.000
Có hai thuộc tính: một cho chó và một cho một món ăn.

00:28:40.000 --> 00:28:43.000
Những thuộc tính này là sự phụ thuộc của chế độ xem.

00:28:43.000 --> 00:28:47.000
Sự phụ thuộc chỉ là một đầu vào cho chế độ xem.

00:28:47.000 --> 00:28:53.000
Khi một sự phụ thuộc thay đổi, chế độ xem được yêu cầu để tạo ra một cơ thể mới.

00:28:53.000 --> 00:28:56.000
Phần thân là nơi bạn xây dựng hệ thống phân cấp cho tầm nhìn.

00:28:56.000 --> 00:29:03.000
Đi sâu vào hệ thống phân cấp của chế độ xem này, chúng tôi có một nút với một hành động.

00:29:03.000 --> 00:29:07.000
Hành động là những gì kích hoạt các thay đổi đối với sự phụ thuộc của chế độ xem.

00:29:07.000 --> 00:29:11.000
Hãy hoán đổi mã cho một sơ đồ tương đương.

00:29:11.000 --> 00:29:13.000
Đây là sơ đồ của DogView của chúng tôi.

00:29:13.000 --> 00:29:18.000
Khi chúng tôi nhấn vào nút, nó sẽ gửi một hành động để thưởng cho con chó.

00:29:18.000 --> 00:29:21.000
Con chó của chúng tôi nuốt chửi món ăn trong nháy mắt.

00:29:21.000 --> 00:29:25.000
Và điều đó dẫn đến một sự thay đổi đối với con chó - có lẽ nó muốn một con khác.

00:29:25.000 --> 00:29:31.000
Bởi vì sự phụ thuộc đã thay đổi, DogView tạo ra một cơ thể mới.

00:29:31.000 --> 00:29:40.000
Để tìm hiểu thêm về các khái niệm chung về luồng dữ liệu trong SwiftUI, hãy xem "Các yếu tố cần thiết về dữ liệu trong SwiftUI" từ WWDC 2020.

00:29:40.000 --> 00:29:43.000
Tiếp theo, hãy đơn giản hóa sơ đồ này một chút.

00:29:43.000 --> 00:29:48.000
Tập trung vào hệ thống phân cấp chế độ xem, hãy chú ý cách các chế độ xem của chúng ta tạo thành một cấu trúc giống như cây.

00:29:48.000 --> 00:29:55.000
Và nếu chúng ta thêm con chó và xử lý các phụ thuộc trở lại ở trên cùng, nó vẫn trông giống như một cái cây.

00:29:55.000 --> 00:29:59.000
Tuy nhiên, DogView không phải là chế độ xem duy nhất có phụ thuộc.

00:29:59.000 --> 00:30:04.000
Trong SwiftUI, mỗi chế độ xem có thể có tập hợp các phụ thuộc riêng.

00:30:04.000 --> 00:30:06.000
Cho đến nay, cái này vẫn trông giống như một cái cây.

00:30:06.000 --> 00:30:12.000
Nhưng lưu ý, có thể có nhiều chế độ xem phụ thuộc vào cùng một trạng thái hoặc dữ liệu khác.

00:30:12.000 --> 00:30:17.000
Ví dụ, một trong những hậu duệ cũng có thể phụ thuộc vào con chó.

00:30:17.000 --> 00:30:20.000
Và điều này có thể xảy ra với một trong những phụ thuộc khác của chúng tôi.

00:30:20.000 --> 00:30:25.000
Vì vậy, chúng tôi bắt đầu với một cái cây, nhưng cấu trúc này bây giờ chỉ giống một cái cây một cách lỏng lẻo.

00:30:25.000 --> 00:30:36.000
Trên thực tế, nếu chúng ta sắp xếp lại nó để tránh các đường chồng chéo, chúng ta sẽ kết thúc với cấu trúc này, điều này cho thấy rằng đây thực sự là một biểu đồ, không phải một cái cây.

00:30:36.000 --> 00:30:42.000
Trên thực tế, chúng tôi gọi cấu trúc này là "biểu đồ phụ thuộc".

00:30:42.000 --> 00:30:49.000
Cấu trúc này rất quan trọng vì nó cho phép SwiftUI chỉ cập nhật hiệu quả những chế độ xem yêu cầu nội dung mới.

00:30:49.000 --> 00:30:53.000
Lấy ví dụ, sự phụ thuộc ở phía dưới.

00:30:53.000 --> 00:30:57.000
Nếu chúng ta kiểm tra sự phụ thuộc này, nó có hai quan điểm phụ thuộc.

00:30:57.000 --> 00:31:04.000
Bí mật của biểu đồ là nếu sự phụ thuộc thay đổi, chỉ những chế độ xem đó sẽ bị vô hiệu.

00:31:04.000 --> 00:31:10.000
SwiftUI sẽ gọi nội dung của mỗi chế độ xem, tạo ra một giá trị nội dung mới cho mỗi chế độ xem.

00:31:10.000 --> 00:31:14.000
SwiftUI sẽ khởi tạo các giá trị của mỗi nội dung của chế độ xem bị vô hiệu.

00:31:14.000 --> 00:31:19.000
Điều đó có thể dẫn đến nhiều sự phụ thuộc thay đổi hơn, nhưng không phải lúc nào cũng vậy!

00:31:19.000 --> 00:31:26.000
Bởi vì các lượt xem là các loại giá trị, SwiftUI có thể so sánh chúng một cách hiệu quả để chỉ cập nhật tập hợp con các chế độ xem phù hợp.

00:31:26.000 --> 00:31:30.000
Đây là một cách khác để xem xét những gì Luca đã thảo luận trước đó.

00:31:30.000 --> 00:31:32.000
Giá trị của chế độ xem chỉ tồn tại trong thời gian ngắn.

00:31:32.000 --> 00:31:38.000
Giá trị cấu trúc chỉ được sử dụng để so sánh, nhưng bản thân chế độ xem có tuổi thọ dài hơn.

00:31:38.000 --> 00:31:43.000
Và đó là cách chúng ta có thể tránh tạo ra một cơ thể mới cho tầm nhìn ở trung tâm.

00:31:43.000 --> 00:31:47.000
Danh tính là xương sống của biểu đồ phụ thuộc.

00:31:47.000 --> 00:31:54.000
Như Matt đã nói, mọi quan điểm đều có danh tính, cho dù được chỉ định rõ ràng hay có cấu trúc.

00:31:54.000 --> 00:32:01.000
Danh tính đó là cách SwiftUI định tuyến thay đổi sang chế độ xem phù hợp và cập nhật giao diện người dùng một cách hiệu quả.

00:32:01.000 --> 00:32:03.000
Có nhiều loại phụ thuộc.

00:32:03.000 --> 00:32:15.000
Chúng tôi đã thấy một vài ví dụ trước đó với thuộc tính xử lý và ràng buộc chó, nhưng bạn cũng có thể hình thành các phụ thuộc bằng cách sử dụng môi trường, trạng thái hoặc bất kỳ trình bao bọc thuộc tính đối tượng có thể quan sát được nào.

00:32:15.000 --> 00:32:20.000
Tiếp theo, tôi muốn nói về cách cải thiện việc sử dụng danh tính trong quan điểm của bạn.

00:32:20.000 --> 00:32:25.000
Điều này sẽ giúp SwiftUI hiểu rõ hơn về mã của bạn.

00:32:25.000 --> 00:32:33.000
Như Luca đã nói, tuổi thọ của một chế độ xem là thời gian nhận dạng của nó và điều đó có nghĩa là sự ổn định của một định danh là rất quan trọng.

00:32:33.000 --> 00:32:37.000
Một mã định danh không ổn định có thể dẫn đến tuổi thọ xem ngắn hơn.

00:32:37.000 --> 00:32:46.000
Và có một mã định danh ổn định cũng giúp hiệu suất, vì SwiftUI không cần phải liên tục tạo bộ nhớ cho chế độ xem và khuấy động thông qua việc cập nhật biểu đồ.

00:32:46.000 --> 00:32:56.000
Như bạn đã thấy trước đó, SwiftUI sử dụng tuổi thọ để quản lý lưu trữ liên tục, vì vậy các số nhận dạng ổn định cũng rất quan trọng để tránh mất trạng thái.

00:32:56.000 --> 00:33:03.000
Hãy chuyển sang một ví dụ mã để giải thích tầm quan trọng của sự ổn định danh.

00:33:03.000 --> 00:33:06.000
Trong ví dụ này, tôi có một danh sách những thú cưng yêu thích của tôi.

00:33:06.000 --> 00:33:09.000
Chúng tôi có một mã định danh trên cấu trúc thú cưng của mình.

00:33:09.000 --> 00:33:18.000
Nhưng thực sự có một lỗi; mỗi khi tôi có một con thú cưng mới, mọi thứ trên màn hình sẽ nhấp nháy!

00:33:18.000 --> 00:33:21.000
Hãy dừng lại một chút và xem mã này.

00:33:21.000 --> 00:33:24.000
Bạn có thể phát hiện ra lỗi ở đâu không?

00:33:24.000 --> 00:33:27.000
Lỗi ở đây, trong sự phù hợp có thể nhận dạng của chúng tôi.

00:33:27.000 --> 00:33:32.000
Nếu bạn không vượt qua bài kiểm tra, đừng lo lắng; không có món ăn nào trong phần này.

00:33:32.000 --> 00:33:40.000
Vấn đề là mã định danh này không ổn định, vì vậy bất cứ khi nào dữ liệu thay đổi, chúng tôi sẽ nhận được mã định danh mới.

00:33:40.000 --> 00:33:44.000
Điều gì sẽ xảy ra nếu thay vào đó, chúng ta sử dụng các chỉ số của mảng thú cưng của chúng ta?

00:33:44.000 --> 00:33:47.000
Thật không may, điều này có một vấn đề tương tự.

00:33:47.000 --> 00:33:54.000
Bằng cách sử dụng các chỉ số, các chế độ xem hiện được xác định bởi vị trí của thú cưng tương ứng của chúng trong bộ sưu tập.

00:33:54.000 --> 00:34:02.000
Nếu tôi quyết định tôi có một con thú cưng yêu thích đầu tiên mới, tất cả những thú cưng khác sẽ thay đổi danh tính của chúng, điều này có thể gây ra một lỗi xấu.

00:34:02.000 --> 00:34:16.000
Trong ví dụ này, nút chèn một phần tử mới ở chỉ mục 0, nhưng vì chỉ mục cuối cùng là chỉ mục mới, chúng tôi nhận được một phần chèn ở cuối thay vì bắt đầu.

00:34:16.000 --> 00:34:23.000
Điều này là do, giống như các số nhận dạng ngẫu nhiên được tính toán, các chỉ số không phải là một dạng nhận dạng ổn định.

00:34:23.000 --> 00:34:31.000
Trong ví dụ này, chúng ta cần sử dụng một mã định danh ổn định, như một mã định danh từ cơ sở dữ liệu hoặc có nguồn gốc từ các thuộc tính ổn định của thú cưng.

00:34:31.000 --> 00:34:34.000
Bất kỳ số nhận dạng liên tục nào cũng là một lựa chọn tuyệt vời.

00:34:34.000 --> 00:34:39.000
Bây giờ hoạt hình của chúng tôi trông thật tuyệt!

00:34:39.000 --> 00:34:45.000
Nhưng sự ổn định không phải là tài sản duy nhất chúng ta cần cho các số nhận dạng tốt.

00:34:45.000 --> 00:34:49.000
Một thuộc tính khác của số nhận dạng tốt là tính độc đáo.

00:34:49.000 --> 00:34:52.000
Mỗi mã định danh nên ánh xạ đến một chế độ xem duy nhất.

00:34:52.000 --> 00:35:00.000
Điều này đảm bảo rằng hình ảnh động trông tuyệt vời, hiệu suất mượt mà và sự phụ thuộc của hệ thống phân cấp của bạn được phản ánh ở dạng hiệu quả nhất.

00:35:00.000 --> 00:35:04.000
Hãy xem xét một ví dụ khác.

00:35:04.000 --> 00:35:09.000
Trong ví dụ này, tôi đang làm việc trên một khung cảnh với tất cả các món ăn yêu thích của thú cưng của tôi.

00:35:09.000 --> 00:35:13.000
Mỗi món ăn đều có tên, biểu tượng cảm xúc và ngày hết hạn.

00:35:13.000 --> 00:35:18.000
Tôi đã chọn xác định từng món ăn bằng tên của nó.

00:35:18.000 --> 00:35:22.000
Tại thời điểm này - tôi chắc rằng bạn có thể đoán được - chúng tôi cũng có một lỗi ở đây.

00:35:22.000 --> 00:35:26.000
Điều gì xảy ra khi chúng ta có nhiều hơn một loại điều trị giống nhau?

00:35:26.000 --> 00:35:30.000
Tôi không biết bạn thế nào, nhưng tôi thích mua bánh quy cho chó với số lượng lớn.

00:35:30.000 --> 00:35:33.000
Khi tôi thêm chúng vào lọ, chúng có thể không xuất hiện!

00:35:33.000 --> 00:35:39.000
Vấn đề là tên của một món ăn không phải là một mã định danh duy nhất cho nó.

00:35:39.000 --> 00:35:44.000
Thay vào đó, chúng ta có thể sử dụng số sê-ri hoặc ID duy nhất khác cho mỗi điều trị.

00:35:44.000 --> 00:35:48.000
Và điều này đảm bảo tất cả dữ liệu phù hợp được hiển thị trong lọ của chúng tôi.

00:35:48.000 --> 00:35:52.000
Nó cũng sẽ đảm bảo hình ảnh động tốt hơn và hiệu suất tốt hơn.

00:35:52.000 --> 00:35:56.000
Khi SwiftUI cần một mã định danh, nó cần sự giúp đỡ của bạn!

00:35:56.000 --> 00:36:01.000
Vui lòng cẩn thận khi sử dụng các số nhận dạng ngẫu nhiên, đặc biệt là trong các thuộc tính được tính toán.

00:36:01.000 --> 00:36:06.000
Nói chung, bạn muốn tất cả các số nhận dạng của mình ổn định.

00:36:06.000 --> 00:36:13.000
Một mã định danh không nên thay đổi theo thời gian; một mã định danh mới đại diện cho một mặt hàng mới với vòng đời mới.

00:36:13.000 --> 00:36:16.000
Và cuối cùng, số nhận dạng cần phải là duy nhất.

00:36:16.000 --> 00:36:20.000
Nhiều chế độ xem không thể chia sẻ một mã định danh.

00:36:20.000 --> 00:36:25.000
SwiftUI dựa vào các thuộc tính này để làm cho ứng dụng của bạn chạy trơn tru và không có lỗi.

00:36:25.000 --> 00:36:31.000
Bây giờ chúng ta đã nói về bản sắc rõ ràng, tôi muốn chuyển sang bản sắc cấu trúc.

00:36:31.000 --> 00:36:35.000
Trong ví dụ này, tôi đang làm việc trên lọ xử lý từ trước đó.

00:36:35.000 --> 00:36:41.000
Là một người yêu thú cưng có trách nhiệm, tôi chỉ cho thú cưng ăn những thức ăn ngon nhất, chưa hết hạn.

00:36:41.000 --> 00:36:49.000
Để giúp tôi biết khi nào các món ăn trở nên tồi tệ, tôi đã thêm một công cụ sửa đổi mới tùy chọn làm mờ tế bào điều trị khi điều trị hết hạn.

00:36:49.000 --> 00:36:52.000
Tôi đã làm nổi bật ô bị mờ đi.

00:36:52.000 --> 00:36:55.000
Hãy đi sâu vào công cụ sửa đổi.

00:36:55.000 --> 00:37:03.000
Bạn có thể thấy rằng trong công cụ sửa đổi, tôi có một ngày và so sánh nó với ngày hiện tại để biết khi nào nên làm mờ chế độ xem.

00:37:03.000 --> 00:37:07.000
Điều này thoạt đầu có vẻ ổn, nhưng có một vấn đề tinh tế ở đây.

00:37:07.000 --> 00:37:15.000
Nếu điều kiện thay đổi và điều trị của chúng tôi hết hạn, chúng tôi sẽ có một danh tính mới vì có một chi nhánh ở đây.

00:37:15.000 --> 00:37:20.000
Như Matt đã thảo luận, các nhánh là một hình thức nhận dạng cấu trúc.

00:37:20.000 --> 00:37:26.000
Điều này có nghĩa là chúng tôi có hai bản sao của nội dung thay vì một bản sao duy nhất, được sửa đổi tùy chọn.

00:37:26.000 --> 00:37:29.000
Lưu ý rằng nhánh ở đây nằm trong một công cụ sửa đổi.

00:37:29.000 --> 00:37:39.000
Để rõ ràng, tôi đã đặt công cụ sửa đổi và trang web sử dụng của nó trên cùng một trang chiếu, nhưng trong dự án của bạn, bạn có thể có các nhánh như thế này trên các tệp mà không hề biết về nó!

00:37:39.000 --> 00:37:46.000
Tất nhiên, mọi thứ chúng ta đã thảo luận ở đây đều áp dụng cho các công cụ sửa đổi chế độ xem và chế độ xem.

00:37:46.000 --> 00:37:48.000
Vậy làm thế nào chúng ta có thể tránh được điều này?

00:37:48.000 --> 00:37:56.000
Chà, một cách là gấp các nhánh lại với nhau và di chuyển điều kiện bên trong công cụ sửa đổi độ mờ đục, như vậy.

00:37:56.000 --> 00:38:01.000
Bằng cách loại bỏ nhánh này, chúng tôi đã mô tả chính xác chế độ xem này là có một danh tính duy nhất.

00:38:01.000 --> 00:38:09.000
Hơn nữa, việc di chuyển điều kiện bên trong công cụ sửa đổi độ mờ có thể giúp hiệu suất, bởi vì chúng tôi đã xác định phạm vi chặt chẽ mã phụ thuộc.

00:38:09.000 --> 00:38:16.000
Bây giờ khi điều kiện thay đổi, chỉ có độ mờ đục cần thay đổi.

00:38:16.000 --> 00:38:23.000
Bí quyết cho điều này là khi điều kiện là đúng, chúng ta có độ mờ đục là 1, trông như thế này.

00:38:23.000 --> 00:38:26.000
Độ mờ của 1 không có tác dụng.

00:38:26.000 --> 00:38:31.000
Chúng tôi gọi các công cụ sửa đổi như thế này là "các công cụ sửa đổi trơ", bởi vì chúng không ảnh hưởng đến kết quả được hiển thị.

00:38:31.000 --> 00:38:36.000
Công cụ sửa đổi SwiftUI rẻ, vì vậy có rất ít chi phí cố hữu với mẫu này.

00:38:36.000 --> 00:38:44.000
Bởi vì không có hiệu ứng hình ảnh kết quả, khuôn khổ có thể cắt giảm hiệu quả công cụ sửa đổi, giảm chi phí hơn nữa.

00:38:44.000 --> 00:38:48.000
Các chi nhánh rất tuyệt, và chúng tồn tại trong SwiftUI là có lý do.

00:38:48.000 --> 00:38:56.000
Nhưng khi được sử dụng một cách không cần thiết, chúng có thể gây ra hiệu suất kém, hình ảnh động đáng ngạc nhiên và, như Luca đã cho thấy, thậm chí mất trạng thái.

00:38:56.000 --> 00:39:05.000
Khi bạn giới thiệu một nhánh, hãy tạm dừng một giây và xem xét liệu bạn đang đại diện cho nhiều chế độ xem hay hai trạng thái của cùng một chế độ xem.

00:39:05.000 --> 00:39:12.000
Như chúng ta đã thấy, nó thường hoạt động tốt hơn để sử dụng một công cụ sửa đổi trơ thay vì một nhánh để xác định một chế độ xem duy nhất.

00:39:12.000 --> 00:39:16.000
Đây chỉ là một vài ví dụ về công cụ sửa đổi trơ.

00:39:16.000 --> 00:39:21.000
Tôi đặc biệt thích transformEnvironment để viết có điều kiện cho môi trường.

00:39:21.000 --> 00:39:27.000
Kết hợp mọi thứ lại với nhau, hôm nay chúng tôi đã cho bạn thấy rằng danh tính là một trong những bí mật để có màn trình diễn tuyệt vời.

00:39:27.000 --> 00:39:34.000
Chúng tôi đã thảo luận về bản sắc rõ ràng và cấu trúc, và cách bạn có thể tận dụng từng loại để cải thiện ứng dụng của mình.

00:39:34.000 --> 00:39:42.000
Từ danh tính, chúng ta có thể lấy được tuổi thọ của chế độ xem, kiểm soát việc lưu trữ liên quan, chuyển tiếp và hơn thế nữa.

00:39:42.000 --> 00:39:53.000
Và chúng tôi cũng đã giải thích rằng SwiftUI sử dụng danh tính và tuổi thọ để hình thành các phụ thuộc, được biểu thị bằng một biểu đồ có thể cập nhật giao diện người dùng một cách hiệu quả.

00:39:53.000 --> 00:40:01.000
Cùng với việc làm sáng tỏ SwiftUI, chúng tôi đã cung cấp cho bạn một số mẹo và thủ thuật để tránh lỗi và cải thiện hiệu suất trong ứng dụng của bạn.

00:40:01.000 --> 00:40:06.000
Và bây giờ bạn đã học được những thủ thuật này, hãy tham quan mã của bạn để xem liệu chúng có thể giúp bạn không.

00:40:06.000 --> 00:40:10.000
Cảm ơn bạn, và tiếp tục xây dựng các ứng dụng tuyệt vời!

00:40:10.000 --> 23:59:59.000
♪

