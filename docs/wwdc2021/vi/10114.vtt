WEBVTT

00:00:00.000 --> 00:00:05.000
♪ Nhạc bass đang phát ♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:12.000
Ross LeBeau: Xin chào, và chào mừng đến với WWDC21.

00:00:12.000 --> 00:00:16.000
Tên tôi là Ross LeBeau, và tôi là một kỹ sư trong nhóm StoreKit.

00:00:16.000 --> 00:00:27.000
Hôm nay, chúng ta sẽ nói về StoreKit, và đây thực sự là một trong ba phiên được thiết kế để giúp bạn triển khai mã phía máy khách, xây dựng máy chủ của bạn để mua hàng trong ứng dụng và hỗ trợ khách hàng của bạn và xử lý hoàn lại tiền.

00:00:27.000 --> 00:00:33.000
Phiên này là Meet StoreKit 2, và bạn có thể tìm thấy hai phiên còn lại ở đây tại WWDC21.

00:00:33.000 --> 00:00:36.000
Phiên này sẽ tập trung vào các tính năng và triển khai phía máy khách.

00:00:36.000 --> 00:00:39.000
Vậy hãy bắt đầu nào!

00:00:39.000 --> 00:00:44.000
Kể từ khi StoreKit được giới thiệu trong iOS 3, nó đã tạo ra những cơ hội tuyệt vời cho bạn và doanh nghiệp của bạn.

00:00:44.000 --> 00:00:52.000
Ngày nay, nó tồn tại trên bốn nền tảng của Apple và hỗ trợ mọi thứ từ trò chơi đến ứng dụng tin tức, tựa game độc lập đến các bản hit quốc tế.

00:00:52.000 --> 00:00:58.000
Trong những năm qua, chúng tôi đã giới thiệu các tính năng tuyệt vời như mã ưu đãi, Chia sẻ trong gia đình và thử nghiệm StoreKit trong Xcode.

00:00:58.000 --> 00:01:02.000
Nhưng năm nay, chúng tôi quyết định quay trở lại từ đầu.

00:01:02.000 --> 00:01:06.000
Hôm nay, tôi rất vui được giới thiệu với StoreKit 2!

00:01:06.000 --> 00:01:17.000
StoreKit 2 là một bộ hoàn toàn mới các API Swift hiện đại và linh hoạt để làm việc với Mua hàng trong ứng dụng trên iOS, macOS, tvOS và watchOS.

00:01:17.000 --> 00:01:21.000
Chúng tôi đã có một cái nhìn mới về StoreKit với tư duy Swift đầu tiên.

00:01:21.000 --> 00:01:29.000
Chúng tôi đã chấp nhận một số tính năng ngôn ngữ mới nhất, như Swift đồng thời bằng cách sử dụng mẫu không đồng bộ/chờ đợi, để tạo các API đơn giản nhưng mạnh mẽ.

00:01:29.000 --> 00:01:39.000
Chúng tôi cũng đã thực hiện một số cập nhật lớn cho các giao dịch mua hàng trong ứng dụng, giúp chúng dễ làm việc hơn nhiều, đồng thời cung cấp thêm thông tin và bảo mật cao.

00:01:39.000 --> 00:01:47.000
Và chúng tôi đã thêm các API mạnh mẽ hơn dành riêng cho đăng ký để cung cấp cho bạn cái nhìn sâu sắc hơn mà bạn có thể sử dụng để phát triển doanh nghiệp của mình.

00:01:47.000 --> 00:01:57.000
StoreKit 2 APIs sống bên trong cùng một khung StoreKit tồn tại ngày nay và tập trung vào trải nghiệm mua hàng cốt lõi trong ứng dụng thay vì thay thế mọi API.

00:01:57.000 --> 00:02:09.000
Các API StoreKit 2 mới bao gồm năm lĩnh vực chính: Sản phẩm, Mua hàng, Thông tin giao dịch, Lịch sử giao dịch và trạng thái đăng ký.

00:02:09.000 --> 00:02:18.000
Hôm nay tôi sẽ cung cấp cho bạn cái nhìn tổng quan về từng lĩnh vực này và đồng nghiệp Jakob của tôi sẽ chỉ cho bạn cách sử dụng API StoreKit 2 tương ứng trong mã thực.

00:02:18.000 --> 00:02:24.000
Vì vậy, trước tiên, hãy bắt đầu với các khối xây dựng của StoreKit: sản phẩm và mua hàng.

00:02:24.000 --> 00:02:29.000
Cấu trúc sản phẩm StoreKit 2 là phiên bản tăng áp của đối tượng sản phẩm StoreKit mà bạn đã quen.

00:02:29.000 --> 00:02:36.000
Để bắt đầu, chúng tôi đã thêm dữ liệu bổ sung vào nó, chẳng hạn như loại sản phẩm và thông tin đăng ký mở rộng.

00:02:36.000 --> 00:02:43.000
Với StoreKit 2, chúng tôi đang giúp việc tìm hiểu xem khách hàng có đủ điều kiện nhận ưu đãi giới thiệu của bạn trở nên dễ dàng hơn hay không.

00:02:43.000 --> 00:02:47.000
Chúng tôi cũng đang làm cho các sản phẩm StoreKit 2 tương thích chuyển tiếp với các tính năng mới.

00:02:47.000 --> 00:02:56.000
Chúng tôi đã hoàn thành điều này bằng cách thêm một loại gói có tên BackingValue cho phép bạn truy xuất dữ liệu có trong sản phẩm bằng cách đăng ký trực tiếp các sản phẩm.

00:02:56.000 --> 00:03:06.000
Điều này có nghĩa là nếu chúng tôi thêm dữ liệu vào các sản phẩm trong tương lai, bạn sẽ luôn có thể truy cập chúng trong StoreKit 2, ngay cả trên SDK và các thiết bị chạy hệ điều hành có phiên bản StoreKit 2 cũ hơn.

00:03:06.000 --> 00:03:13.000
Điều này có nghĩa là bạn có thể sử dụng các tính năng mới nhất để cung cấp chức năng mới cho một phần lớn hơn trong cơ sở khách hàng của bạn.

00:03:13.000 --> 00:03:18.000
Với StoreKit 2, bạn yêu cầu các sản phẩm bằng cách gọi một hàm tĩnh trên chính loại sản phẩm đó.

00:03:18.000 --> 00:03:24.000
Điều này yêu cầu siêu dữ liệu sản phẩm từ App Store giống như SKProductsRequest hiện có.

00:03:24.000 --> 00:03:31.000
Nhưng nhờ vào mẫu Swift đồng bộ/chờ đợi đồng thời Swift mới, yêu cầu sản phẩm StoreKit 2 chỉ yêu cầu một dòng mã.

00:03:31.000 --> 00:03:37.000
Tương tự, mua một sản phẩm trong StoreKit 2 là một nhiệm vụ đơn giản, một dòng khác.

00:03:37.000 --> 00:03:44.000
Mua hàng bây giờ là một phương pháp ví dụ trên loại sản phẩm, có nghĩa là bạn có thể lấy những sản phẩm bạn vừa truy xuất và gọi mua trực tiếp trên chúng.

00:03:44.000 --> 00:03:51.000
Vì phương thức mua hàng cũng sử dụng async/await, bạn sẽ nhận được kết quả mua hàng nội tuyến trong mã của mình.

00:03:51.000 --> 00:03:54.000
Bây giờ chúng tôi biết rằng không phải mọi giao dịch mua đều giống nhau.

00:03:54.000 --> 00:04:01.000
Nếu bạn muốn sửa đổi hành vi mua hàng ngoài cài đặt mặc định, StoreKit 2 có các tùy chọn Mua hàng.

00:04:01.000 --> 00:04:06.000
Tùy chọn Mua hàng là một mặt hàng mô tả một tài sản duy nhất của giao dịch mua.

00:04:06.000 --> 00:04:11.000
Bạn có thể soạn các tùy chọn Mua hàng thành một tập hợp mà bạn chuyển vào phương thức mua hàng.

00:04:11.000 --> 00:04:16.000
StoreKit 2 bao gồm các tùy chọn mua hàng cho những thứ như số lượng và ưu đãi khuyến mại.

00:04:16.000 --> 00:04:20.000
Và trong StoreKit 2, chúng tôi đang thêm một tùy chọn mới gọi là mã thông báo tài khoản ứng dụng.

00:04:20.000 --> 00:04:27.000
Mã thông báo tài khoản Ứng dụng là một cách để bạn theo dõi tài khoản người dùng ứng dụng nào đã bắt đầu và hoàn tất giao dịch.

00:04:27.000 --> 00:04:33.000
Đó là một mã thông báo mờ đục mà bạn tạo ra mà bạn có thể liên kết với các tài khoản mà ứng dụng của bạn sở hữu.

00:04:33.000 --> 00:04:39.000
Thật dễ dàng để tạo mã thông báo tài khoản Ứng dụng, bởi vì yêu cầu duy nhất là nó phải phù hợp với định dạng UUID.

00:04:39.000 --> 00:04:47.000
Bạn gửi mã thông báo tài khoản Ứng dụng khi mua hàng dưới dạng tùy chọn Mua hàng và mã thông báo này được trả lại trong thông tin giao dịch cho giao dịch mua đó.

00:04:47.000 --> 00:04:51.000
Mã thông báo tài khoản Ứng dụng tồn tại trong thông tin giao dịch mãi mãi, ngay cả trên các thiết bị.

00:04:51.000 --> 00:05:02.000
Nếu ứng dụng của bạn hỗ trợ hệ thống tài khoản của riêng nó, điều này có thể giúp bạn theo dõi những giao dịch mua mà mỗi tài khoản trong ứng dụng đã thực hiện, bất kể ID Apple hoặc thiết bị được sử dụng để mua chúng.

00:05:02.000 --> 00:05:09.000
Vì vậy, chúng ta đã nói về việc nhận sản phẩm từ App Store và bắt đầu mua hàng; bây giờ điều gì sẽ xảy ra khi giao dịch mua đó hoàn tất?

00:05:09.000 --> 00:05:15.000
Như bạn có thể mong đợi, StoreKit sẽ trả lại một giao dịch thành công cho bạn cùng với thông tin được ký bằng mật mã.

00:05:15.000 --> 00:05:17.000
Nghe có vẻ quen thuộc, phải không?

00:05:17.000 --> 00:05:22.000
Chà, StoreKit 2 đang mang đến bản cập nhật lớn nhất cho các giao dịch mua hàng trong ứng dụng từ trước đến nay.

00:05:22.000 --> 00:05:28.000
Để bắt đầu, StoreKit 2 sẽ cung cấp một đối tượng được ký riêng cho mỗi giao dịch.

00:05:28.000 --> 00:05:37.000
Không chỉ vậy, bắt đầu từ StoreKit 2, thông tin giao dịch mua hàng trong ứng dụng giờ đây sẽ được cung cấp ở một định dạng rất phổ biến, dễ làm việc: JSON.

00:05:37.000 --> 00:05:47.000
Và vì chúng tôi biết rằng ký mật mã an toàn là một phần quan trọng trong việc mua StoreKit, chúng tôi hiện đang sử dụng một tiêu chuẩn chung được sử dụng trên web được gọi là Chữ ký web JSON.

00:05:47.000 --> 00:05:56.000
Thêm vào đó, tất cả thông tin chứa trong đối tượng đã ký giờ đây sẽ có sẵn thông qua các API StoreKit gốc, giúp bạn dễ dàng làm việc với dữ liệu này trong mã ứng dụng của mình.

00:05:56.000 --> 00:05:59.000
Trên thực tế, chúng tôi sẽ cho bạn thấy nó dễ dàng như thế nào.

00:05:59.000 --> 00:06:03.000
Đây là Jakob với một minh chứng về các API này trong mã thực.

00:06:03.000 --> 00:06:04.000
Jakob Swank: Xin chào, tôi là Jakob.

00:06:04.000 --> 00:06:07.000
Tôi là một kỹ sư trong nhóm StoreKit.

00:06:07.000 --> 00:06:13.000
Hôm nay tôi thực sự vui mừng được cho bạn thấy việc bắt đầu và chạy dễ dàng như thế nào với StoreKit 2 trong ứng dụng của bạn.

00:06:13.000 --> 00:06:17.000
Ở bên phải, tôi có một ứng dụng mà tôi đang xây dựng có tên là Pocket Cars.

00:06:17.000 --> 00:06:24.000
Bạn có thể tải xuống mã mẫu cho ứng dụng này trong phần tài nguyên của phiên này và làm theo.

00:06:24.000 --> 00:06:26.000
Ứng dụng có hai chế độ xem chính.

00:06:26.000 --> 00:06:30.000
Có một cái nhìn cho những chiếc xe thu thập của tôi và một cái nhìn cho cửa hàng của tôi.

00:06:30.000 --> 00:06:33.000
Chúng ta hãy đi qua cửa hàng.

00:06:33.000 --> 00:06:38.000
Hiện tại, cửa hàng của tôi trống rỗng vì tôi không có sản phẩm nào có sẵn để bán.

00:06:38.000 --> 00:06:41.000
Tôi sẽ tiếp tục và thực hiện những điều đó ngay bây giờ.

00:06:41.000 --> 00:06:46.000
Để bắt đầu và chạy nhanh chóng, tôi đang sử dụng thử nghiệm StoreKit trong Xcode.

00:06:46.000 --> 00:06:53.000
Điều này cho phép tôi xây dựng và kiểm tra cửa hàng của mình trước khi xác định các sản phẩm trong App Store Connect.

00:06:53.000 --> 00:07:02.000
Trong dự án Xcode của mình, tôi đã tạo một tệp cấu hình StoreKit xác định các sản phẩm tôi muốn bán.

00:07:02.000 --> 00:07:10.000
Đây là cùng một tệp cấu hình mà tôi đã sử dụng cho StoreKit; Tôi không cần thay đổi hoặc di chuyển bất cứ thứ gì.

00:07:10.000 --> 00:07:16.000
Ở đây, tôi cũng có một plist chứa tất cả các số nhận dạng sản phẩm của tôi.

00:07:16.000 --> 00:07:23.000
Nó được bao gồm như một tệp tài nguyên được tích hợp trong ứng dụng của tôi để tôi có thể sử dụng nó trong thời gian chạy.

00:07:23.000 --> 00:07:32.000
Để hiển thị các sản phẩm này trong cửa hàng của tôi, trước tiên tôi cần thực hiện yêu cầu sản phẩm bằng cách sử dụng một bộ số nhận dạng sản phẩm mà tôi muốn hiển thị.

00:07:32.000 --> 00:07:39.000
Với StoreKit 2, tôi có thể làm điều này đơn giản bằng cách gọi một phương thức tĩnh trên cấu trúc Sản phẩm.

00:07:39.000 --> 00:07:50.000
Sau khi tôi nhận được các sản phẩm từ App Store, tôi muốn tách chúng theo loại.

00:07:50.000 --> 00:08:04.000
Tôi có thể làm điều này một cách dễ dàng với StoreKit 2 vì loại Sản phẩm hiện cung cấp một thuộc tính cho loại như được xác định trên máy chủ App Store.

00:08:04.000 --> 00:08:10.000
Trong ứng dụng của tôi, tôi đang bán ba loại sản phẩm: nhiên liệu, ô tô và gói điều hướng.

00:08:10.000 --> 00:08:19.000
Nhiên liệu là một sản phẩm tiêu hao - một khi tôi sử dụng nó, nó sẽ biến mất - vì vậy tôi sẽ đưa tất cả các vật tư tiêu hao vào mảng nhiên liệu.

00:08:19.000 --> 00:08:29.000
Ô tô là một thứ không thể tiêu thụ được.

00:08:29.000 --> 00:08:31.000
Một khi tôi mua một chiếc xe hơi, tôi sẽ sở hữu nó mãi mãi.

00:08:31.000 --> 00:08:36.000
Vì vậy, tôi sẽ đưa tất cả các vật tư tiêu hao vào mảng ô tô.

00:08:36.000 --> 00:08:49.000
Gói điều hướng là một sản phẩm đăng ký với ba cấp độ dịch vụ.

00:08:49.000 --> 00:08:55.000
Khách hàng của tôi có thể đăng ký một cấp độ dịch vụ tại một thời điểm và họ được lập hóa đơn định kỳ.

00:08:55.000 --> 00:09:00.000
Ngoài ra, họ có thể nâng cấp hoặc hạ cấp bất cứ lúc nào nếu họ muốn thay đổi mức độ dịch vụ của mình.

00:09:00.000 --> 00:09:10.000
App Store sẽ trả lại một Sản phẩm cho mỗi cấp độ dịch vụ, vì vậy tôi sẽ đưa tất cả các đăng ký tự động gia hạn vào mảng đăng ký.

00:09:10.000 --> 00:09:21.000
Tôi cũng muốn sắp xếp các sản phẩm của mình trong từng loại theo giá, từ thấp nhất đến cao nhất.

00:09:21.000 --> 00:09:34.000
Hãy chạy ứng dụng của tôi và kiểm tra những gì tôi đã làm cho đến nay.

00:09:34.000 --> 00:09:36.000
Bây giờ tôi sẽ điều hướng đến cửa hàng.

00:09:36.000 --> 00:09:37.000
Ồ!

00:09:37.000 --> 00:09:43.000
Trước đây, cửa hàng của tôi trống rỗng, nhưng bây giờ nó trông khá tuyệt vời với tất cả các sản phẩm của tôi được trưng bày.

00:09:43.000 --> 00:09:57.000
Chỉ với một dòng mã, tôi có thể yêu cầu các sản phẩm ứng dụng của mình từ App Store, sau đó tôi có thể nhóm và sắp xếp các sản phẩm đó chỉ dựa trên siêu dữ liệu tôi nhận được giúp dễ dàng xây dựng giao diện người dùng cửa hàng của mình.

00:09:57.000 --> 00:10:02.000
Bây giờ các sản phẩm của tôi trông rất tuyệt, nhưng nếu tôi nhấn vào nút mua, không có gì xảy ra.

00:10:02.000 --> 00:10:07.000
Đó là bởi vì phương thức mua hàng trong cửa hàng của tôi không làm được gì cả.

00:10:07.000 --> 00:10:10.000
Nó nên bắt đầu mua hàng với StoreKit.

00:10:10.000 --> 00:10:15.000
Chúng tôi có thể làm điều này đơn giản bằng cách gọi phương thức mua hàng trên sản phẩm.

00:10:15.000 --> 00:10:32.000
Như Ross đã đề cập, StoreKit 2 được xây dựng từ đầu để sử dụng các khả năng đồng thời mới của Swift.

00:10:32.000 --> 00:10:43.000
Điều này cho phép ứng dụng của tôi giữ mã để mua và xử lý kết quả của giao dịch mua đó trong cùng một ngữ cảnh để giữ cho mã của tôi dễ đọc.

00:10:43.000 --> 00:10:47.000
Khi giao dịch mua hoàn tất, PurchaseResult sẽ được trả lại.

00:10:47.000 --> 00:11:03.000
PurchaseResult này cho tôi biết liệu giao dịch mua đã thành công hay chưa hoặc nếu nó hoàn thành ở một số trạng thái không có lỗi khác, chẳng hạn như người dùng đã hủy giao dịch mua hoặc giao dịch mua cần một số xác thực hoặc phê duyệt ngân hàng bổ sung từ phụ huynh.

00:11:03.000 --> 00:11:06.000
Để xử lý từng trường hợp, tôi sẽ chỉ chuyển qua chúng.

00:11:06.000 --> 00:11:19.000
Nếu PurchaseResult ở trạng thái thành công, tôi cũng nhận được kết quả xác minh.

00:11:19.000 --> 00:11:25.000
Kết quả xác minh bao gồm hai trường hợp: đã xác minh và chưa được xác minh.

00:11:25.000 --> 00:11:34.000
Trong StoreKit 2, loại giao dịch chứa tải trọng JWS đại diện cho giao dịch đã ký.

00:11:34.000 --> 00:11:48.000
Mỗi khi ứng dụng của tôi nhận được giao dịch từ StoreKit 2, giao dịch đã trải qua quá trình xác minh để xác nhận xem tải trọng có được App Store ký cho ứng dụng của tôi cho thiết bị này hay không.

00:11:48.000 --> 00:11:49.000
Bạn đã nghe đúng điều đó.

00:11:49.000 --> 00:11:53.000
StoreKit 2 thực hiện xác minh giao dịch cho bạn.

00:11:53.000 --> 00:12:01.000
Tất nhiên, cách tôi chọn xử lý kết quả xác minh hoàn toàn phụ thuộc vào tôi và nhu cầu kinh doanh của tôi.

00:12:01.000 --> 00:12:07.000
Đối với ứng dụng của tôi, tôi sẽ đảm bảo rằng giao dịch này tôi nhận được từ StoreKit đã được xác minh.

00:12:07.000 --> 00:12:14.000
Ở đây trong cửa hàng của tôi, tôi sẽ tạo một phương pháp checkVerified mà tôi có thể sử dụng cho bất kỳ VerificationResult nào.

00:12:14.000 --> 00:12:26.000
Nếu kết quả chưa được xác minh, tôi sẽ ném lỗi Xác minh không thành công của chính mình để cảnh báo các phần khác trong ứng dụng của mình.

00:12:26.000 --> 00:12:32.000
Nếu kết quả được xác minh, tôi sẽ mở gói giao dịch và trả lại cho người gọi.

00:12:32.000 --> 00:12:37.000
Bây giờ tôi có thể sử dụng phương pháp checkVerified này trên kết quả mua hàng.

00:12:37.000 --> 00:12:55.000
Cuối cùng, với giao dịch của tôi đã được xác minh, tôi cung cấp nội dung cho người dùng của mình.

00:12:55.000 --> 00:13:09.000
Sau khi người dùng có nội dung, tôi cần đảm bảo rằng tôi đã nói với StoreKit để hoàn tất giao dịch.

00:13:09.000 --> 00:13:19.000
Sau đó tôi cần trả lại nó để giao diện người dùng của tôi có thể được cập nhật.

00:13:19.000 --> 00:13:26.000
Ứng dụng của tôi có một cơ sở dữ liệu tài khoản mà tôi duy trì.

00:13:26.000 --> 00:13:37.000
Tôi muốn bao gồm người dùng đã đăng nhập hiện tại của ứng dụng của mình với giao dịch mua StoreKit để thông tin này luôn có sẵn cho ứng dụng của tôi khi nó nhận được giao dịch đã ký trên App Store.

00:13:37.000 --> 00:13:49.000
Tôi có thể làm điều này bằng cách tạo tùy chọn mua appAccountToken bằng cách sử dụng phiên bản mã thông báo của tài khoản đã đăng nhập của tôi và chuyển tùy chọn đó sang phương thức mua hàng.

00:13:49.000 --> 00:14:00.000
Được rồi.

00:14:00.000 --> 00:14:03.000
Tất cả chúng ta đã sẵn sàng với việc triển khai phương thức mua hàng của tôi.

00:14:03.000 --> 00:14:13.000
Hãy chạy lại ứng dụng của tôi.

00:14:13.000 --> 00:14:16.000
Bây giờ chúng tôi đã trở lại cửa hàng của tôi, và tôi cảm thấy khá mạo hiểm.

00:14:16.000 --> 00:14:22.000
Vì vậy, tôi sẽ mua một chiếc xe máy vì tôi luôn muốn có một chiếc.

00:14:22.000 --> 00:14:27.000
Có bảng thanh toán từ StoreKit cho tôi thấy việc mua hàng đã được bắt đầu đúng cách.

00:14:27.000 --> 00:14:32.000
Tôi sẽ nhấn để xác nhận việc mua hàng.

00:14:32.000 --> 00:14:36.000
StoreKit sau đó hiển thị một cảnh báo cho thấy việc mua hàng đã thành công.

00:14:36.000 --> 00:14:47.000
Sau khi tôi bỏ qua cảnh báo đó, nút mua của tôi thay đổi thành dấu kiểm màu xanh lá cây cho thấy ứng dụng của tôi tin tưởng giao dịch và xe máy của tôi đã được giao.

00:14:47.000 --> 00:14:50.000
Có một điều quan trọng nữa tôi muốn lưu ý ở đây.

00:14:50.000 --> 00:15:00.000
Như tôi đã nói trước đây, đôi khi khách hàng sẽ phải thực hiện một số xác minh bổ sung trên tài khoản của họ hoặc họ sẽ cần sự chấp thuận của phụ huynh trước khi giao dịch mua hoàn tất.

00:15:00.000 --> 00:15:08.000
Trong những trường hợp này, kết quả mua hàng tôi nhận được từ product.purchase() sẽ ở trạng thái chờ xử lý.

00:15:08.000 --> 00:15:19.000
Điều này có nghĩa là sau khi khách hàng hoàn tất xác minh tài khoản hoặc phụ huynh của họ phê duyệt, ứng dụng của tôi sẽ cập nhật giao diện người dùng để phản ánh giao dịch mua đã hoàn thành.

00:15:19.000 --> 00:15:31.000
Để lắng nghe những cập nhật giao dịch này, tôi cần lặp lại một thuộc tính tĩnh trên loại giao dịch.

00:15:31.000 --> 00:15:38.000
Thuộc tính này là một chuỗi không đồng bộ vô hạn.

00:15:38.000 --> 00:15:48.000
Điều đó có nghĩa là nó sẽ tiếp tục lặp lại các bản cập nhật giao dịch khi chúng đến từ StoreKit cho đến khi tôi chọn hủy hoặc thoát ra khỏi vòng lặp for.

00:15:48.000 --> 00:15:59.000
Ở đây tôi đang tạo một tác vụ tách rời sẽ trả về một xử lý tác vụ mà tôi có thể sử dụng để hủy rõ ràng trình nghe cập nhật của mình khi cửa hàng được phân bổ.

00:15:59.000 --> 00:16:09.000
Cũng giống như tất cả các giao dịch tôi nhận được từ StoreKit 2, tôi muốn kiểm tra xem kết quả xác minh có được xác minh hay không trước khi gửi nội dung cho người dùng.

00:16:09.000 --> 00:16:14.000
Tôi có thể sử dụng phương pháp checkVerified đã được xác định trước đó của mình.

00:16:14.000 --> 00:16:35.000
Và, giống như với phản hồi mua hàng, một khi tôi đã xác minh giao dịch của mình, tôi cần cung cấp nội dung cho người dùng của mình.

00:16:35.000 --> 00:16:47.000
Và tất nhiên, tôi luôn cần hoàn thành các giao dịch của mình.

00:16:47.000 --> 00:16:54.000
Điều rất quan trọng là tôi bắt đầu cập nhật trình nghe giao dịch của mình ngay khi ứng dụng của tôi khởi chạy để tôi không bỏ lỡ một ứng dụng nào.

00:16:54.000 --> 00:17:00.000
Tôi sẽ làm điều này ngay khi cửa hàng của tôi được tạo, điều này xảy ra ngay khi khởi chạy ứng dụng.

00:17:00.000 --> 00:17:19.000
Để kiểm tra trình nghe cập nhật của mình, tôi sẽ bật Ask To Buy trong môi trường kiểm tra Xcode của mình để mô phỏng phản hồi mua hàng ở trạng thái đang chờ xử lý.

00:17:19.000 --> 00:17:29.000
Để làm điều này, tôi chọn tệp cấu hình StoreKit của mình và trong menu Trình chỉnh sửa, tôi chọn Bật Yêu cầu Mua.

00:17:29.000 --> 00:17:43.000
Hãy chạy lại ứng dụng của tôi và mua hàng.

00:17:43.000 --> 00:17:52.000
Lần này, sau khi tôi xác nhận trên bảng thanh toán, tôi thấy một cảnh báo mới từ StoreKit nói rằng tôi cần xin phép để hoàn tất giao dịch mua.

00:17:52.000 --> 00:17:56.000
Tôi sẽ tiếp tục và nhấn Hỏi.

00:17:56.000 --> 00:18:00.000
Phản hồi mua hàng được trả lại cho ứng dụng của tôi ở trạng thái đang chờ xử lý.

00:18:00.000 --> 00:18:13.000
Để phê duyệt giao dịch mua, tôi sẽ mở thử nghiệm StoreKit trong trình quản lý giao dịch Xcode và nhấp vào nút Phê duyệt ở góc trên cùng bên phải.

00:18:13.000 --> 00:18:14.000
Tuyệt vời!

00:18:14.000 --> 00:18:25.000
Ngay sau khi tôi phê duyệt giao dịch, trình nghe cập nhật của tôi đã nhận được kết quả xác minh và giao diện người dùng ngay lập tức thay đổi để hiển thị giao dịch mua đã được phê duyệt.

00:18:25.000 --> 00:18:30.000
Bây giờ tôi có một chiếc 5 chỗ tiêu chuẩn hoàn toàn mới để đi vòng quanh.

00:18:30.000 --> 00:18:46.000
Tôi vừa cho bạn thấy việc yêu cầu sản phẩm, bắt đầu mua hàng, phản ứng với các kết quả mua hàng khác nhau dễ dàng như thế nào, xác minh tính toàn vẹn của giao dịch và nhận thông tin cập nhật từ App Store cho các giao dịch đang chờ xử lý, tất cả đều sử dụng StoreKit 2.

00:18:46.000 --> 00:18:53.000
Bây giờ chúng ta hãy quay lại Ross để được giới thiệu về cách làm việc với lịch sử giao dịch và trạng thái đăng ký của người dùng của bạn.

00:18:53.000 --> 00:18:57.000
Ross: Ồ! Thật tuyệt vời khi thấy những API mới này đang hoạt động.

00:18:57.000 --> 00:19:01.000
Và xác thực tự động, bạn còn muốn gì hơn nữa?

00:19:01.000 --> 00:19:02.000
Cái gì vậy?

00:19:02.000 --> 00:19:05.000
Bạn yêu thích mật mã và bạn vẫn muốn tự xác thực dữ liệu?

00:19:05.000 --> 00:19:07.000
Đừng lo lắng.

00:19:07.000 --> 00:19:14.000
Xác thực tự động của StoreKit 2 nâng cao tiêu chuẩn bảo mật, nhưng nó không có nghĩa là thay thế hoàn toàn xác thực của chính bạn.

00:19:14.000 --> 00:19:19.000
Như mọi khi, bảo mật nằm trên phạm vi sức mạnh, thời gian và sự phức tạp.

00:19:19.000 --> 00:19:22.000
Tôi sẽ cung cấp cho bạn tin sốt dẻo về xác nhận một lát sau.

00:19:22.000 --> 00:19:30.000
Đầu tiên, nếu bạn hào hứng với các giao dịch StoreKit 2 như tôi, bạn sẽ rất muốn biết rằng chúng tôi đang cung cấp cho bạn rất nhiều cách mới để làm việc với chúng.

00:19:30.000 --> 00:19:36.000
Chúng tôi đang thêm một bộ API mới để truy vấn các giao dịch đã hoàn thành trong lịch sử giao dịch của người dùng.

00:19:36.000 --> 00:19:42.000
Trong StoreKit 2, bạn có thể truy cập tất cả các giao dịch trước đây của người dùng chỉ bằng một lệnh gọi API duy nhất.

00:19:42.000 --> 00:19:45.000
Bạn cũng có thể truy cập giao dịch mới nhất cho một sản phẩm.

00:19:45.000 --> 00:19:49.000
Vì vậy, nếu bạn muốn xem lần gia hạn đăng ký gần đây nhất, bạn có thể.

00:19:49.000 --> 00:19:57.000
Và chúng tôi biết rằng điều số một bạn cần biết là những sản phẩm mà người dùng đã trả tiền để truy cập ngay bây giờ.

00:19:57.000 --> 00:20:02.000
Vì vậy, chúng tôi đã chắt lọc thông tin đó thành một hàm duy nhất được gọi là CurrentEntitlements.

00:20:02.000 --> 00:20:10.000
Các quyền lợi hiện tại chứa tất cả các vật tư không tiêu hao trong lịch sử giao dịch của người dùng, cũng như tất cả các giao dịch đăng ký hiện đang hoạt động.

00:20:10.000 --> 00:20:16.000
Với điều này, bạn có tất cả thông tin bạn cần để mở khóa mọi thứ mà người dùng đã trả tiền trong ứng dụng của bạn.

00:20:16.000 --> 00:20:24.000
Và vì điều này chỉ đại diện cho những thứ mà người dùng nên có quyền truy cập ngay bây giờ, bất kỳ giao dịch nào đã bị thu hồi đều không được bao gồm trong phản hồi.

00:20:24.000 --> 00:20:30.000
Hàng tiêu dùng cũng không được bao gồm, vì chúng không phải là một phần liên tục của lịch sử giao dịch.

00:20:30.000 --> 00:20:32.000
Bây giờ, chắc hẳn bạn đang nghĩ, "Tôi không thể chờ đợi!

00:20:32.000 --> 00:20:35.000
Khi nào tôi có thể bắt đầu gọi những thứ này trong ứng dụng của mình?"

00:20:35.000 --> 00:20:41.000
Chà, với StoreKit 2, mọi giao dịch mà người dùng đã từng hoàn thành đều có sẵn cho ứng dụng của bạn ngay khi bạn yêu cầu.

00:20:41.000 --> 00:20:50.000
Điều này có nghĩa là khi người dùng cài đặt ứng dụng của bạn trên một thiết bị mới, bạn sẽ có thể biết họ có quyền truy cập vào sản phẩm nào ngay lần đầu tiên ứng dụng của bạn được mở.

00:20:50.000 --> 00:20:56.000
Hơn nữa, lịch sử giao dịch sẽ tự động cập nhật trên các thiết bị của người dùng.

00:20:56.000 --> 00:21:04.000
Khi khách hàng của bạn mua hàng trên một thiết bị, ứng dụng của bạn sẽ có thể xem giao dịch mua trên mọi thiết bị khác mà nó được cài đặt.

00:21:04.000 --> 00:21:10.000
Trên thực tế, nếu ứng dụng của bạn đang chạy khi giao dịch mua được thực hiện trên một thiết bị khác, bạn sẽ được thông báo về giao dịch mới.

00:21:10.000 --> 00:21:17.000
Jakob đã đề cập rằng điều quan trọng là phải lắng nghe các giao dịch ngay khi ứng dụng của bạn khởi động và đây chỉ là một lý do nữa là đúng.

00:21:17.000 --> 00:21:24.000
Vì vậy, tất cả những điều này có nghĩa là người dùng sẽ không cần khôi phục các giao dịch đã hoàn thành khi ứng dụng của bạn được cài đặt lại hoặc tải xuống trên một thiết bị mới.

00:21:24.000 --> 00:21:28.000
Mọi thứ sẽ tự động được StoreKit tìm nạp và luôn cập nhật.

00:21:28.000 --> 00:21:33.000
Nhưng mọi người sử dụng thiết bị Apple của họ theo hàng triệu cách ở hàng triệu nơi.

00:21:33.000 --> 00:21:39.000
Trong trường hợp hiếm hoi mà người dùng nghĩ rằng họ nên có một giao dịch nhưng bạn không thấy nó, bạn có thể sử dụng API đồng bộ hóa App Store.

00:21:39.000 --> 00:21:44.000
Điều này ngay lập tức đồng bộ hóa lại tất cả các giao dịch StoreKit 2.

00:21:44.000 --> 00:21:51.000
Đây là sự thay thế cho API restoreCompletedTransactions và bạn nên cung cấp giao diện người dùng trong ứng dụng của mình cho phép người dùng bắt đầu đồng bộ hóa.

00:21:51.000 --> 00:21:58.000
Tuy nhiên, nhờ đồng bộ hóa tự động của StoreKit 2, rất hiếm khi người dùng cần bắt đầu đồng bộ hóa theo cách thủ công.

00:21:58.000 --> 00:22:02.000
Đồng bộ hóa tự động sẽ bao gồm phần lớn các trường hợp.

00:22:02.000 --> 00:22:07.000
Nếu người dùng cần bắt đầu đồng bộ hóa thủ công, họ sẽ được yêu cầu xác thực tài khoản của mình.

00:22:07.000 --> 00:22:13.000
Vì lý do này, bạn chỉ nên sử dụng API này để phản hồi đầu vào của người dùng.

00:22:13.000 --> 00:22:20.000
Cuối cùng, tất cả các giao dịch được thực hiện bằng API StoreKit 2 đều có sẵn trong API StoreKit ban đầu và ngược lại.

00:22:20.000 --> 00:22:27.000
Vì vậy, nếu ứng dụng của bạn có các giao dịch hiện có, bạn sẽ có thể thấy chúng trong StoreKit 2 APIs ngay khi bạn bắt đầu sử dụng chúng.

00:22:27.000 --> 00:22:38.000
Các giao dịch mua mới được thực hiện bằng API StoreKit ban đầu sẽ có sẵn thông qua API StoreKit 2 ngay lập tức và các giao dịch mua được thực hiện với StoreKit 2 cũng sẽ có sẵn bên trong biên lai thống nhất khi nó được làm mới.

00:22:38.000 --> 00:22:47.000
Ngoài lịch sử giao dịch, StoreKit 2 cũng đang bổ sung các cách để bạn có được thông tin chi tiết về trạng thái đăng ký của người dùng.

00:22:47.000 --> 00:22:50.000
Trạng thái đăng ký có ba phần.

00:22:50.000 --> 00:22:52.000
Đầu tiên là giao dịch mới nhất.

00:22:52.000 --> 00:23:01.000
Điều này thuận tiện cho phép bạn truy cập giao dịch cuối cùng xảy ra cho đăng ký này và nó giống như khi bạn gọi giao dịch mới nhất mà chúng ta đã nói trước đó.

00:23:01.000 --> 00:23:03.000
Thứ hai là trạng thái đổi mới.

00:23:03.000 --> 00:23:07.000
Đây là một bảng liệt kê cho bạn biết trạng thái hiện tại của đăng ký.

00:23:07.000 --> 00:23:12.000
Nếu bạn chỉ muốn biết điều gì đang xảy ra với đăng ký ngay bây giờ, chỉ cần nhìn vào giá trị này.

00:23:12.000 --> 00:23:18.000
Nó sẽ cho bạn biết nếu nó hiện đang được đăng ký, hết hạn, trong thời gian gia hạn và hơn thế nữa.

00:23:18.000 --> 00:23:24.000
Chúng tôi đã thiết kế nó để cung cấp cho bạn một nơi duy nhất để tìm kiếm nhằm giúp bạn dễ dàng dựa trên logic ứng dụng dựa trên giá trị này.

00:23:24.000 --> 00:23:28.000
Và phần cuối cùng của trạng thái đăng ký là thông tin gia hạn.

00:23:28.000 --> 00:23:32.000
Đây là nơi bạn có thể xem tất cả các chi tiết về đăng ký của người dùng.

00:23:32.000 --> 00:23:39.000
Nó chứa tất cả các loại thông tin không có trong thông tin giao dịch vì dữ liệu này thực sự có thể thay đổi mà không cần giao dịch.

00:23:39.000 --> 00:23:48.000
Ví dụ: trong thông tin gia hạn, bạn có thể tìm thấy trạng thái tự động gia hạn, cho bạn biết người dùng đã bật hoặc tắt tính năng tự động gia hạn cho đăng ký này.

00:23:48.000 --> 00:23:52.000
Bạn thậm chí có thể thấy ID sản phẩm mà tính năng tự động gia hạn của họ được thiết lập.

00:23:52.000 --> 00:24:01.000
Vì vậy, nếu một người dùng gần đây đã hạ cấp đăng ký của họ, bạn có thể thấy điều đó ngay tại đây và có thể sử dụng điều đó như một cơ hội để giới thiệu cho họ một đề nghị giành lại để ở cấp cao hơn.

00:24:01.000 --> 00:24:06.000
Nếu đăng ký đã hết hạn, bạn có thể sử dụng thông tin gia hạn để xem lý do hết hạn.

00:24:06.000 --> 00:24:11.000
Và thông tin gia hạn đầy đủ có tất cả dữ liệu này và hơn thế nữa, cộng với một tính năng quan trọng khác.

00:24:11.000 --> 00:24:16.000
Đúng vậy, tất cả những người yêu thích mật mã, thông tin gia hạn được ký bằng JWS!

00:24:16.000 --> 00:24:22.000
Cũng giống như thông tin giao dịch, thông tin gia hạn là một phần quan trọng trong việc mở khóa dịch vụ và đưa ra quyết định tiếp thị.

00:24:22.000 --> 00:24:26.000
Vì vậy, chúng tôi đang cho bạn sự tự tin để biết rằng nó hợp lệ và trực tiếp từ Apple.

00:24:26.000 --> 00:24:35.000
Và, để trả lời câu hỏi mà tôi chắc chắn đang chạy qua đầu bạn ngay bây giờ, vâng, StoreKit 2 sẽ tự động xác thực thông tin gia hạn cho bạn.

00:24:35.000 --> 00:24:41.000
Một điều cuối cùng cần biết về API trạng thái đăng ký là chúng trả về một loạt các trạng thái.

00:24:41.000 --> 00:24:46.000
Điều này là do, trong một số trường hợp, người dùng có thể có nhiều đăng ký cho cùng một sản phẩm.

00:24:46.000 --> 00:24:53.000
Ví dụ: người dùng có thể đã đăng ký sản phẩm của bạn và sau đó cũng nhận được đăng ký thông qua Chia sẻ trong gia đình.

00:24:53.000 --> 00:24:57.000
Bạn nên kiểm tra mảng để xem mức dịch vụ cao nhất mà họ được hưởng là gì.

00:24:57.000 --> 00:25:05.000
Bây giờ tôi sẽ đưa nó lại cho Jakob để cho bạn thấy nó trông như thế nào khi làm việc với các API lịch sử giao dịch và trạng thái đăng ký này trong mã ứng dụng của bạn.

00:25:05.000 --> 00:25:07.000
Jakob: Cảm ơn, Ross.

00:25:07.000 --> 00:25:15.000
Hãy quay lại ứng dụng mà tôi đang làm việc và cập nhật nó để sử dụng lịch sử giao dịch mới và API trạng thái đăng ký mà Ross vừa nói đến.

00:25:15.000 --> 00:25:27.000
Bạn sẽ nhận thấy chiếc xe máy tôi đã mua trước đây không có séc màu xanh lá cây và sau khi tôi điều hướng ra khỏi chế độ xem cửa hàng của mình, sau đó quay lại, chiếc xe 5 chỗ tiêu chuẩn cũng không có séc màu xanh lá cây.

00:25:27.000 --> 00:25:31.000
Là một người dùng, tôi không thể biết mình đã mua gì.

00:25:31.000 --> 00:25:34.000
Đây là một vấn đề dễ dàng giải quyết với StoreKit 2.

00:25:34.000 --> 00:25:43.000
Bất cứ lúc nào, ứng dụng của tôi có thể truy vấn StoreKit về những sản phẩm đã được mua để tôi có thể luôn cập nhật giao diện người dùng của ứng dụng của mình.

00:25:43.000 --> 00:25:49.000
Trong tệp Store.swift của tôi, phương thức isPurchased hiện chỉ trả về false.

00:25:49.000 --> 00:25:54.000
Hãy khắc phục điều đó bằng một cuộc gọi đơn giản đến Transaction.latest(for:).

00:25:54.000 --> 00:26:03.000
Sau đó chuyển mã định danh sản phẩm của tôi để nhận giao dịch gần đây nhất.

00:26:03.000 --> 00:26:12.000
Phương thức StoreKit này trả về một kết quả xác minh khác cho tôi biết giao dịch đã được thông qua kiểm tra xác minh của StoreKit 2.

00:26:12.000 --> 00:26:19.000
Tôi sẽ xác nhận giao dịch đã được xác minh và mở gói bằng phương pháp checkVerified mà tôi đã viết trước đó.

00:26:19.000 --> 00:26:38.000
Sau đó, tôi sẽ đảm bảo rằng ứng dụng của tôi không cung cấp nội dung cho một giao dịch đã được hoàn trả bằng cách kiểm tra revocationDate bằng nil.

00:26:38.000 --> 00:26:58.000
Ngoài ra, các đăng ký mà khách hàng của tôi đã nâng cấp lên cấp độ dịch vụ cao hơn vào giữa kỳ sẽ có cờ isUpgraded được đặt thành true.

00:26:58.000 --> 00:27:08.000
Tôi muốn đảm bảo rằng ứng dụng của tôi đang cung cấp dịch vụ ở mức cao nhất mà khách hàng của tôi đã đăng ký, vì vậy phương thức isPurchased nên bỏ qua bất kỳ giao dịch nâng cấp nào.

00:27:08.000 --> 00:27:20.000
Đối với một sản phẩm đăng ký, loại giao dịch chỉ kể một phần của câu chuyện.

00:27:20.000 --> 00:27:38.000
Ngoài ngày giao dịch và ngày hết hạn đăng ký, tôi cũng muốn biết khi nào là ngày gia hạn tiếp theo và liệu khách hàng của tôi có tắt tính năng tự động gia hạn cho đăng ký của họ hay liệu thời gian gia hạn tiếp theo của họ có thay đổi mức độ dịch vụ mà họ đã đăng ký hay không.

00:27:38.000 --> 00:27:44.000
Để có được tất cả thông tin này, StoreKit 2 cung cấp API trạng thái đăng ký.

00:27:44.000 --> 00:27:56.000
Trong tệp SubscriptionsView.swift của tôi, phương thức updateSubscriptionStatus chịu trách nhiệm lấy trạng thái đăng ký từ StoreKit và hiển thị nó cho người dùng.

00:27:56.000 --> 00:28:04.000
Bởi vì tất cả các sản phẩm đăng ký của tôi thuộc cùng một nhóm, tôi có thể sử dụng bất kỳ sản phẩm nào trong số chúng để có được trạng thái hiện tại cho nhóm.

00:28:04.000 --> 00:28:08.000
Tôi sẽ chỉ chọn sản phẩm đăng ký đầu tiên từ cửa hàng.

00:28:08.000 --> 00:28:17.000
Khi tôi có một sản phẩm, tôi có thể nhận được thuộc tính trạng thái từ đăng ký.

00:28:17.000 --> 00:28:22.000
Thật dễ dàng.

00:28:22.000 --> 00:28:31.000
Như Ross đã đề cập, người dùng có thể trả tiền cho đăng ký cá nhân của riêng họ trong khi họ cũng có đăng ký được chia sẻ bởi một thành viên trong gia đình.

00:28:31.000 --> 00:28:38.000
Vì vậy, thuộc tính trạng thái sẽ trả về một mảng chứa tất cả các trạng thái cho mỗi đăng ký.

00:28:38.000 --> 00:28:46.000
Bây giờ, họ có thể có một cấp tiêu chuẩn được chia sẻ với họ trong khi cá nhân họ đã đăng ký cấp chuyên nghiệp.

00:28:46.000 --> 00:28:54.000
Tôi muốn đảm bảo rằng người dùng của tôi có thể nhận được mức dịch vụ cao nhất mà họ có quyền truy cập, vì vậy tôi sẽ lặp lại từng trạng thái.

00:28:54.000 --> 00:29:08.000
Tiếp theo, tôi sẽ kiểm tra xem trạng thái đã hết hạn hay bị thu hồi.

00:29:08.000 --> 00:29:13.000
Tôi muốn bỏ qua những trường hợp này và không hiển thị bất cứ thứ gì cho người dùng.

00:29:13.000 --> 00:29:22.000
Đối với tất cả các trường hợp khác, tôi sẽ nhận được Thông tin gia hạn và đảm bảo rằng nó được xác minh bằng phương pháp checkVerified trên cửa hàng của tôi.

00:29:22.000 --> 00:29:45.000
Khi tôi xác nhận thông tin gia hạn đã được xác minh, tôi sẽ so sánh mức độ dịch vụ với các sản phẩm trước đó.

00:29:45.000 --> 00:30:01.000
Kiểm tra này sẽ nhận được sản phẩm tương ứng cho trạng thái đăng ký, sau đó nó sẽ so sánh với bất kỳ sản phẩm nào trước đó và nếu đó là cấp cao hơn, chúng tôi đặt Trạng thái cao nhất và Sản phẩm cao nhất cho đăng ký mới.

00:30:01.000 --> 00:30:10.000
Khi tôi đã kiểm tra tất cả các trạng thái của mình và tôi đã xác định mức dịch vụ cao nhất, tôi sẽ đặt trạng thái và đăng ký hiện tại theo quan điểm của mình.

00:30:10.000 --> 00:30:32.000
Hãy xây dựng và chạy ngay bây giờ.

00:30:32.000 --> 00:30:41.000
Trong chế độ xem cửa hàng của tôi, các sản phẩm tôi đã mua trước đây hiện hiển thị dấu kiểm màu xanh lá cây cho biết tôi đã sở hữu chúng và tôi không cần phải mua lại chúng.

00:30:41.000 --> 00:30:49.000
Hãy xem điều gì sẽ xảy ra khi tôi mua một trong những sản phẩm đăng ký của mình.

00:30:49.000 --> 00:30:54.000
Sau khi tôi xác nhận mua hàng, trạng thái được hiển thị ngay trong cửa hàng của tôi.

00:30:54.000 --> 00:31:03.000
Tôi có thể cho người dùng của mình biết những gì họ đã đăng ký và khi nào đăng ký của họ sẽ gia hạn tất cả bằng cách sử dụng các API được tích hợp trong StoreKit 2.

00:31:03.000 --> 00:31:06.000
Bây giờ chế độ xem Ô tô của tôi thì sao?

00:31:06.000 --> 00:31:11.000
Nó sẽ hiển thị tất cả các sản phẩm đã mua của tôi, nhưng hiện tại nó trống rỗng.

00:31:11.000 --> 00:31:23.000
Để điền thông tin này, tôi có thể lặp lại tất cả các sản phẩm của mình, sau đó nhận giao dịch mới nhất cho mỗi sản phẩm, kiểm tra ngày hết hạn của giao dịch và liệu nó đã được hoàn lại chưa, nhưng điều đó nghe có vẻ rất nhiều.

00:31:23.000 --> 00:31:34.000
Rất may, tôi có thể sử dụng sức mạnh của StoreKit 2 và một API mới, đơn giản và thuận tiện để nhận tất cả các giao dịch hợp lệ của người dùng được gọi là currentEntitlements.

00:31:34.000 --> 00:31:41.000
Trong chế độ xem Ô tô của tôi, tôi có phương pháp này để làm mới các sản phẩm đã mua của mình khi chế độ xem được tải.

00:31:41.000 --> 00:31:46.000
Cũng giống như với các bản cập nhật giao dịch, tôi lặp lại các quyền hiện tại.

00:31:46.000 --> 00:32:02.000
Nhưng không giống như cập nhật giao dịch, chuỗi không đồng bộ của quyền lợi hiện tại là hữu hạn, vì vậy nó sẽ không chờ đợi trong vòng lặp mãi mãi, cung cấp các quyền mới khi người dùng mua nhiều hơn.

00:32:02.000 --> 00:32:09.000
Đối với mỗi quyền lợi, tôi muốn kiểm tra kết quả xác minh như tôi làm với mọi giao dịch khác.

00:32:09.000 --> 00:32:22.000
Khi tôi biết chúng đã được xác minh, tôi sẽ lọc các quyền lợi thành các mảng khác nhau bằng cách chuyển đổi thuộc tính productType, giống như tôi đã làm với yêu cầu sản phẩm ban đầu của mình.

00:32:22.000 --> 00:32:32.000
Các quyền lợi hiện tại sẽ chỉ trả lại các giao dịch cho các sản phẩm không tiêu dùng và tự động tái tạo.

00:32:32.000 --> 00:32:39.000
Tôi có thể bỏ qua bất kỳ loại sản phẩm nào khác để hoàn thành câu lệnh chuyển đổi của mình và giữ cho trình biên dịch Swift hài lòng.

00:32:39.000 --> 00:32:46.000
Khi tôi có giao dịch, tôi cần làm cho sản phẩm liên quan hiển thị trong giao diện người dùng của mình.

00:32:46.000 --> 00:32:57.000
Đối với các giao dịch không tiêu hao, tôi sẽ tìm kiếm mảng sản phẩm ô tô để tìm số nhận dạng sản phẩm phù hợp với giao dịch này.

00:32:57.000 --> 00:33:07.000
Và tương tự như vậy, tôi sẽ tìm kiếm mảng sản phẩm đăng ký để phù hợp với bất kỳ giao dịch tự động gia hạn nào.

00:33:07.000 --> 00:33:16.000
Hãy chạy lại và kiểm tra giao diện người dùng của tôi.

00:33:16.000 --> 00:33:21.000
Bây giờ, khi tôi đi vào chế độ xem Ô tô của tôi, tôi thấy mọi thứ tôi đã mua.

00:33:21.000 --> 00:33:26.000
Tất cả những chiếc xe của tôi được nhóm lại với nhau ở trên cùng và đăng ký của tôi ở bên dưới.

00:33:26.000 --> 00:33:30.000
Bây giờ ứng dụng của tôi có một cửa hàng hoạt động đầy đủ và nó trông thật tuyệt vời!

00:33:30.000 --> 00:33:40.000
Và đó là cách bạn có thể sử dụng lịch sử giao dịch và API trạng thái đăng ký để đưa ra quyết định sáng suốt trong ứng dụng của mình về những gì giao diện người dùng mà người dùng của bạn nhìn thấy.

00:33:40.000 --> 00:33:46.000
Bây giờ chúng ta hãy quay lại với Ross, người sẽ nói sâu hơn về đối tượng Chữ ký Web JSON.

00:33:46.000 --> 00:33:49.000
Ross: Cảm ơn một lần nữa vì bản demo tuyệt vời, Jakob.

00:33:49.000 --> 00:33:54.000
Bạn thực sự có thể thấy các API giao dịch và đăng ký mới có ích như thế nào.

00:33:54.000 --> 00:34:03.000
Bây giờ chúng ta đã thấy hai cách mà StoreKit 2 sử dụng JWS để bảo mật, tôi đã hứa chúng ta sẽ xem xét kỹ hơn về nó và cách bạn có thể tự xác thực.

00:34:03.000 --> 00:34:06.000
Chữ ký web JSON bao gồm ba phần.

00:34:06.000 --> 00:34:10.000
Đầu tiên là tiêu đề, chứa siêu dữ liệu về đối tượng.

00:34:10.000 --> 00:34:18.000
Điều này chứa thông tin quan trọng như thuật toán nào được sử dụng để ký và nơi tìm chứng chỉ được sử dụng để xác thực chữ ký.

00:34:18.000 --> 00:34:25.000
StoreKit 2 hiện đang sử dụng thuật toán ECDSA, được hỗ trợ nguyên bản trong Swift với CryptoKit.

00:34:25.000 --> 00:34:33.000
Đối với chứng chỉ, StoreKit 2 sử dụng tiêu đề x5c, cho biết rằng toàn bộ chuỗi chứng chỉ được bao gồm trong dữ liệu JWS.

00:34:33.000 --> 00:34:40.000
Điều này có nghĩa là không cần kết nối internet để xác thực các chữ ký JWS này.

00:34:40.000 --> 00:34:43.000
Phần tiếp theo của dữ liệu JWS là tải trọng.

00:34:43.000 --> 00:34:50.000
Đây là thông tin chính như ID giao dịch, ID sản phẩm, ngày mua hàng, v.v.

00:34:50.000 --> 00:34:57.000
Khi bạn đã xác thực chữ ký, đây là nơi bạn đến để đọc tất cả dữ liệu bạn muốn biết về giao dịch hoặc đăng ký.

00:34:57.000 --> 00:35:01.000
Và phần cuối cùng của dữ liệu JWS là chính chữ ký.

00:35:01.000 --> 00:35:05.000
Điều này được tạo ra bằng cách sử dụng cả tiêu đề và tải trọng.

00:35:05.000 --> 00:35:14.000
Xác thực chữ ký JWS là một phần được ghi chép đầy đủ của tiêu chuẩn, vì vậy tôi khuyên bạn nên đi thẳng đến nguồn gốc nếu bạn quan tâm đến việc viết triển khai của riêng mình.

00:35:14.000 --> 00:35:18.000
Tôi đã bao gồm một liên kết đến tài liệu này trong các tài nguyên được liên kết với phiên này.

00:35:18.000 --> 00:35:27.000
Khi bạn đã xác thực chữ ký từ dữ liệu JWS, chỉ có một vài điều nữa bạn nên làm để đảm bảo thông tin đã ký hợp lệ cho ứng dụng của bạn và thiết bị hiện tại.

00:35:27.000 --> 00:35:33.000
Đầu tiên, bạn nên đảm bảo rằng ID gói có trong tải trọng thông tin đã ký khớp với ID gói của ứng dụng của bạn.

00:35:33.000 --> 00:35:44.000
Chúng tôi khuyên bạn nên tăng cường bảo mật, bạn nhúng ID gói ứng dụng của mình ở đâu đó trong ứng dụng, thay vì dựa vào lệnh gọi API và sử dụng giá trị đó để so sánh nó với ID gói trong tải trọng.

00:35:44.000 --> 00:35:48.000
Và điều cuối cùng bạn nên làm là thực hiện kiểm tra xác thực thiết bị.

00:35:48.000 --> 00:35:53.000
Điều này đảm bảo rằng thông tin đã ký thực sự được tạo cho thiết bị hiện tại.

00:35:53.000 --> 00:36:00.000
Sử dụng StoreKit 2 API AppStore.deviceVerificationID để truy xuất mã định danh xác minh thiết bị hiện tại.

00:36:00.000 --> 00:36:08.000
Sau đó, lấy nonce xác minh thiết bị từ thông tin đã ký và thêm số nhận dạng xác minh thiết bị bạn vừa nhận được từ StoreKit.

00:36:08.000 --> 00:36:15.000
Thực hiện hàm băm SHA384 trên giá trị này và so sánh kết quả với trường xác minh thiết bị từ thông tin đã ký.

00:36:15.000 --> 00:36:21.000
Nếu chúng khớp, thì thông tin đã ký đã được tạo cho thiết bị này và quá trình xác thực thông tin đã ký của bạn đã hoàn tất.

00:36:21.000 --> 00:36:26.000
Một điều cuối cùng cần lưu ý là những đối tượng JWS mới này chỉ dành cho mua trong ứng dụng.

00:36:26.000 --> 00:36:32.000
Vì vậy, nếu bạn cần xác thực biên lai ứng dụng, bạn nên sử dụng API và quy trình hiện có cho việc đó.

00:36:32.000 --> 00:36:41.000
Và tất nhiên, chúng tôi đang cung cấp các API máy chủ App Store mới cho các đối tượng JWS mới này, vì vậy bạn có thể truy xuất và xác thực chúng trực tiếp trên máy chủ của mình.

00:36:41.000 --> 00:36:46.000
Chà, tôi hy vọng bạn cũng hào hứng được gặp StoreKit 2 như chúng tôi đã giới thiệu nó với bạn hôm nay.

00:36:46.000 --> 00:36:53.000
StoreKit 2 đang làm cho việc mua hàng trong ứng dụng trở nên tốt hơn với các API mới cung cấp cho bạn nhiều thông tin hơn và dễ sử dụng hơn bao giờ hết.

00:36:53.000 --> 00:37:03.000
Điều này bao gồm các đối tượng thông tin dựa trên JSON mới cho mỗi giao dịch, cũng như các API để cung cấp cho bạn chi tiết giao dịch và dữ liệu giao dịch lịch sử trong mã gốc của bạn.

00:37:03.000 --> 00:37:11.000
Kết hợp điều đó với các API trạng thái đăng ký mới và StoreKit 2 mở ra vô số khả năng cho các giao dịch mua trong ứng dụng của bạn.

00:37:11.000 --> 00:37:18.000
Để tìm hiểu thêm về mua hàng trong ứng dụng, tôi khuyến khích bạn xem các phiên khác này để mã hóa phía máy chủ và hỗ trợ khách hàng.

00:37:18.000 --> 00:37:21.000
Jakob và tôi rất vui vì chúng tôi có thể giới thiệu cho bạn StoreKit 2.

00:37:21.000 --> 00:37:24.000
Cảm ơn vì đã tham gia cùng chúng tôi tại WWDC21!

00:37:24.000 --> 23:59:59.000
♪

