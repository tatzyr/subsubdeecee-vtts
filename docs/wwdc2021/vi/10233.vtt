WEBVTT

00:00:00.000 --> 00:00:05.000
♪ Nhạc bass đang phát ♪

00:00:05.000 --> 00:00:10.000
♪

00:00:10.000 --> 00:00:14.000
Jonathan Hogg: Xin chào, và chào mừng đến với phiên này về Tăng tốc và các khuôn khổ liên quan.

00:00:14.000 --> 00:00:24.000
Tôi là Jonathan từ nhóm Vector &amp; Numerics của Apple, và hôm nay tôi sẽ nói chuyện ngắn gọn với bạn về khung Accelerate trước khi cho bạn biết có gì mới trong thư viện máy học của chúng tôi, BNNS.

00:00:24.000 --> 00:00:32.000
Sau đó, tôi sẽ đề cập đến các cải tiến đối với simd.h và giới thiệu Apple Archive và các vùng chứa Apple Encrypted Archive mới của chúng tôi.

00:00:32.000 --> 00:00:37.000
Vì vậy, hãy bắt đầu với một cái nhìn tổng quan ngắn gọn về khuôn khổ Tăng tốc.

00:00:37.000 --> 00:00:48.000
Accelerate cung cấp tính toán số hiệu suất cao trên tất cả các nền tảng của Apple: MacOS, iOS, iPadOS, watchOS và tvOS.

00:00:48.000 --> 00:00:55.000
Accelerate cũng cung cấp quyền truy cập vào các bộ tăng tốc học máy trong Apple Silicon Macs và các thiết bị iPhone và iPad gần đây.

00:00:55.000 --> 00:01:03.000
Cách duy nhất để tận dụng phần cứng này là gọi Accelerate trực tiếp hoặc thông qua các khuôn khổ cấp cao hơn như Core ML.

00:01:03.000 --> 00:01:06.000
Tăng tốc bao gồm một số phần.

00:01:06.000 --> 00:01:11.000
vDSP cung cấp các nguyên thủy để xử lý tín hiệu như các quy trình DFT và FFT.

00:01:11.000 --> 00:01:17.000
vImage cung cấp các quy trình xử lý hình ảnh như chuyển đổi định dạng và tích chập.

00:01:17.000 --> 00:01:23.000
vForce cung cấp các phiên bản vectơ hóa của các hàm siêu việt như sin và cosin.

00:01:23.000 --> 00:01:33.000
BLAS và LAPACK cung cấp khả năng cấy ghép hiệu suất cao của các quy trình đại số ma trận dày đặc tiêu chuẩn, trong khi Sparse BLAS và Sparse Solvers của chúng tôi cung cấp chức năng tương tự cho ma trận thưa thớt.

00:01:33.000 --> 00:01:39.000
Cuối cùng, BNNS cung cấp hỗ trợ cho việc học máy.

00:01:39.000 --> 00:01:43.000
Hôm nay tôi cũng sẽ nói chuyện với bạn về một số khuôn khổ liên quan.

00:01:43.000 --> 00:01:54.000
Simd.h cung cấp các vectơ và ma trận nhỏ tính toán, chẳng hạn như những vectơ và ma trận được đề cập trong lập trình đồ họa, trong khi Nén và Apple Archive cung cấp hỗ trợ nén dữ liệu không mất dữ liệu.

00:01:54.000 --> 00:02:03.000
Để sử dụng các khuôn khổ này, chỉ cần thêm câu lệnh bao gồm hoặc nhập có liên quan vào mã của bạn và thêm khuôn khổ vào dự án Xcode của bạn.

00:02:03.000 --> 00:02:07.000
Bây giờ, hãy để tôi kể cho bạn nghe về BNNS chi tiết hơn.

00:02:07.000 --> 00:02:14.000
BNNS là viết tắt của Basic Neural Network Subroutines và cung cấp các nguyên thủy hiệu suất cho việc học máy trên CPU.

00:02:14.000 --> 00:02:19.000
Đối với những người bạn không quen thuộc với hệ sinh thái học máy của Apple, sơ đồ này cho thấy vị trí của vùng đất.

00:02:19.000 --> 00:02:29.000
Có ba khối phần cứng chính: CPU, bao gồm các bộ tăng tốc học máy mà tôi đã đề cập trước đó; GPU; và công cụ thần kinh riêng biệt.

00:02:29.000 --> 00:02:37.000
BNNS cung cấp các nguyên thủy hiệu suất trên CPU giống như cách MPS cung cấp các nguyên thủy hiệu suất trên GPU.

00:02:37.000 --> 00:02:42.000
Phía trên lớp này, có một số khung chạy trên một hoặc nhiều phụ trợ này.

00:02:42.000 --> 00:02:51.000
Chúng bao gồm các khung học máy cấp cao của Apple - Core ML và Create ML - cũng như các khung chuyên môn như Vision và Natural Language.

00:02:51.000 --> 00:02:59.000
BNNS cung cấp hỗ trợ cho cả đào tạo và suy luận trên nhiều loại lớp, cũng như hỗ trợ cho các trình tối ưu hóa được hiển thị ở phía dưới.

00:02:59.000 --> 00:03:09.000
Trong bản phát hành này, chúng tôi đã thêm hỗ trợ cho một số loại lớp mới: nhúng, điền ngẫu nhiên và lượng tử hóa; cũng như hỗ trợ cho trình tối ưu hóa AdamW.

00:03:09.000 --> 00:03:24.000
Chúng tôi cũng đã cải thiện các lớp hiện có, thêm hai chức năng kích hoạt mới: SiLU và HardSwish, cũng như hỗ trợ các hàm số học mới: chọn bậc ba, cộng nhân, cũng như tối thiểu và tối đa theo phần tử.

00:03:24.000 --> 00:03:34.000
Phản ứng tổng hợp lớp cung cấp khả năng tiêu thụ đầu ra của một lớp ngay lập tức làm đầu vào cho lớp tiếp theo, tránh sự cần thiết phải ghi nó vào bộ nhớ và đọc lại.

00:03:34.000 --> 00:03:42.000
Chúng tôi đã thêm sự hợp nhất lớp của tích chập và các lớp được kết nối hoàn toàn với lớp lượng tử hóa mới, cũng như sự hợp nhất giữa các lớp số học và chuẩn hóa.

00:03:42.000 --> 00:03:53.000
Các cải tiến khác bao gồm hỗ trợ được cải thiện cho việc cắt gradient trong trình tối ưu hóa, cũng có thể được sử dụng như các chức năng độc lập, cũng như hỗ trợ AMSGrad cho các trình tối ưu hóa dựa trên Adam của chúng tôi.

00:03:53.000 --> 00:03:59.000
Cùng với nhau, những cải tiến này đã mở rộng phạm vi và kiến trúc mạng mà chúng ta có thể tăng tốc hơn nữa.

00:03:59.000 --> 00:04:03.000
Bây giờ, hãy để tôi kể cho bạn nghe về một số cải tiến cho simd.h.

00:04:03.000 --> 00:04:16.000
Simd.h cung cấp các nguyên thủy tính toán trên các vectơ và ma trận nhỏ phù hợp với các thanh ghi của CPU, bao gồm hỗ trợ cho các hàm như sin và cosin cũng như các hoạt động hình học hữu ích, bao gồm hỗ trợ cho các quaternion.

00:04:16.000 --> 00:04:24.000
Điều tôi thực sự thích ở simd.h là nó cho phép chúng ta nhảy vào và nhận được 90 phần trăm lợi ích của vector hóa với 10 phần trăm nỗ lực.

00:04:24.000 --> 00:04:26.000
Đây, để tôi chỉ cho bạn.

00:04:26.000 --> 00:04:29.000
Đây là một chức năng kích hoạt mạng thần kinh mà tôi vừa phát minh ra.

00:04:29.000 --> 00:04:32.000
Như bạn có thể thấy, nó có ba nhánh khác nhau.

00:04:32.000 --> 00:04:36.000
Nếu đầu vào nhỏ hơn trừ pi, tôi chỉ trả về số không.

00:04:36.000 --> 00:04:42.000
Nếu nó nằm giữa trừ pi và pi, tôi trả về gấp hai lần số mũ của x, nhân với x cộng với pi trên hai.

00:04:42.000 --> 00:04:47.000
Nếu không, nếu nó lớn hơn pi, tôi trả về gấp hai lần số mũ.

00:04:47.000 --> 00:04:53.000
Điều đó thật tuyệt, nhưng nếu tôi có một lượng lớn dữ liệu, tôi có thể muốn chạy nó nhanh hơn vòng lặp vô hướng cho phép.

00:04:53.000 --> 00:04:56.000
Vậy hãy để tôi chỉ cho bạn cách thực hiện điều đó trong simd.

00:04:56.000 --> 00:05:10.000
Tôi đã có một số mẫu sẵn, một phần mở rộng cho phép tôi dễ dàng ghi vectơ vào bộ đệm và một vòng lặp đơn giản lặp lại trên mảng đầu ra của chúng tôi theo gia số của một chiều dài tám vectơ tại một thời điểm.

00:05:10.000 --> 00:05:14.000
Phần thú vị là làm thế nào để dịch hàm vô hướng của chúng ta thành một tương đương simd.

00:05:14.000 --> 00:05:16.000
Hãy bắt đầu bằng cách xem lại mã vô hướng của chúng tôi.

00:05:16.000 --> 00:05:18.000
Tôi thấy nó có một vài nhánh.

00:05:18.000 --> 00:05:20.000
Những thứ này không hoạt động tốt cho việc vector hóa.

00:05:20.000 --> 00:05:26.000
Thay vào đó, hãy xây dựng cái này từ những phần mà chúng ta có thể hợp nhất dựa trên mặt nạ.

00:05:26.000 --> 00:05:31.000
Nhìn kỹ hơn, nếu x nhỏ hơn trừ pi, tôi chỉ trả về số không.

00:05:31.000 --> 00:05:38.000
Nếu nó lớn hơn, tôi trả về một biểu thức liên quan đến số mũ gấp hai lần của x.

00:05:38.000 --> 00:05:41.000
Hãy kéo nó ra.

00:05:41.000 --> 00:06:00.000
Bây giờ, chúng tôi muốn xây dựng một vectơ từ y đó, thay thế bằng 0 ở mọi nơi mà x là phần tử nhỏ hơn trừ pi.

00:06:00.000 --> 00:06:02.000
Tiếp theo, chúng ta có thể xem xét một trường hợp lớn hơn.

00:06:02.000 --> 00:06:09.000
Ở đây, chúng ta đang nhân với một ở vùng cao, hoặc với x cộng với pi trên hai ở vùng giữa.

00:06:09.000 --> 00:06:12.000
Vì vậy, hãy viết điều đó theo cùng một cách.

00:06:12.000 --> 00:06:30.000
Chúng tôi lấy x cộng pi của chúng tôi trên hai biểu thức và lần này chúng tôi đang thay thế bằng một biểu thức ở mọi nơi mà x lớn hơn hoặc bằng pi theo phần tử.

00:06:30.000 --> 00:06:35.000
Bây giờ tất cả những gì còn lại là nhân hai đại lượng này lại với nhau.

00:06:35.000 --> 00:06:44.000
Rõ ràng, nếu một phần tử bằng không, nhân với một trong hai giá trị của b vẫn trả về số không.

00:06:44.000 --> 00:06:53.000
Vì vậy, hãy chạy nó và xem nó trông như thế nào.

00:06:53.000 --> 00:07:02.000
Bây giờ, tôi có thể thấy - nhìn xuống bảng điều khiển - rằng phiên bản simd mới của tôi nhanh hơn gần ba lần so với mã vô hướng trước đó.

00:07:02.000 --> 00:07:05.000
Vậy simd được cải thiện như thế nào trong bản phát hành này?

00:07:05.000 --> 00:07:09.000
Chúng tôi đã cải thiện khả năng sử dụng cho các lập trình viên C++ bằng cách sử dụng các mẫu.

00:07:09.000 --> 00:07:20.000
Chúng tôi đã thêm các cấu trúc loại và đặc điểm để cho phép bạn di chuyển giữa loại vô hướng cơ bản và chiều dài vectơ và loại simd cụ thể mà không cần cấu trúc mã phức tạp hoặc cần tự mình triển khai các loại tương tự.

00:07:20.000 --> 00:07:27.000
Để đơn giản hóa việc sử dụng chúng, chúng tôi cũng đã thêm các bí danh thuận tiện để giảm nhu cầu về mẫu C++.

00:07:27.000 --> 00:07:29.000
Đây là một ví dụ về những gì chúng trông giống như khi sử dụng.

00:07:29.000 --> 00:07:43.000
Các loại vectơ và ma trận cho phép chúng ta đi từ một loại cơ bản - chẳng hạn như float hoặc int - và chiều dài vectơ sang một loại cụ thể và cũng có các thành viên cung cấp quyền truy cập vào các loại liên quan, chẳng hạn như phiên bản không liên kết và loại mặt nạ do so sánh.

00:07:43.000 --> 00:07:49.000
Bí danh Vector_t và Matrix_t cung cấp cú pháp đơn giản hóa để truy cập các định nghĩa giống như chúng ta đã có trước đây.

00:07:49.000 --> 00:07:55.000
Cấu trúc get_traits cho phép chúng ta đi theo hướng khác, chuyển từ loại simd cụ thể sang loại chung.

00:07:55.000 --> 00:08:01.000
Và một lần nữa, có những bí danh để đơn giản hóa cú pháp cho các trường hợp sử dụng phổ biến.

00:08:01.000 --> 00:08:06.000
Chúng tôi cũng đã thêm các phiên bản mẫu của các chức năng tạo và chuyển đổi để cho phép sử dụng chúng trong mã mẫu.

00:08:06.000 --> 00:08:14.000
Chúng hoạt động giống như các hàm hiện có, nhưng loại đích của chúng bây giờ là một tham số mẫu chứ không phải là một phần của tên hàm.

00:08:14.000 --> 00:08:21.000
Ngoài những cải tiến C++ của chúng tôi, chúng tôi đã thêm một số chức năng mới được hỗ trợ trên tất cả các ngôn ngữ của chúng tôi.

00:08:21.000 --> 00:08:32.000
Đây là các hàm phân loại - như isfinite và isinf - cung cấp các phiên bản vectơ của các hàm vô hướng trong libm, cũng như các hàm mới để tính toán hàm gamma, cũng như dấu vết của ma trận simd.

00:08:32.000 --> 00:08:37.000
Bây giờ, giới thiệu Kho lưu trữ Apple và các định dạng Kho lưu trữ được mã hóa Apple mới của chúng tôi.

00:08:37.000 --> 00:08:42.000
Kho lưu trữ Apple đã cung cấp năng lượng cho các bản cập nhật hệ thống của chúng tôi trong phần tốt hơn của một thập kỷ.

00:08:42.000 --> 00:08:48.000
Trong bản phát hành macOS 11, chúng tôi đã cấp cho bạn quyền truy cập vào vùng chứa nén và định dạng lưu trữ.

00:08:48.000 --> 00:08:54.000
Mới trong macOS 12, chúng tôi đã thêm API để mã hóa vào hỗ trợ này.

00:08:54.000 --> 00:09:01.000
Bản thân định dạng lưu trữ cung cấp một cách tiếp cận mô-đun, hiện đại, cho phép bạn chọn chính xác thuộc tính tệp và siêu dữ liệu nào bạn muốn lưu trữ.

00:09:01.000 --> 00:09:05.000
Nó có thể phát trực tuyến, có nghĩa là bạn không phải lo lắng về việc lắp toàn bộ dữ liệu vào bộ nhớ cùng một lúc.

00:09:05.000 --> 00:09:12.000
Nó cũng hỗ trợ các tệp kê khai riêng biệt để lập chỉ mục vào các kho lưu trữ lớn như hình ảnh hệ thống tệp.

00:09:12.000 --> 00:09:22.000
Kho lưu trữ được mã hóa mới của Apple được xây dựng dựa trên điều này, kết hợp nén, mã hóa được xác thực và chữ ký số vào một gói bảo mật duy nhất.

00:09:22.000 --> 00:09:29.000
Nó cung cấp cho bạn mật mã hiện đại được thiết kế và kiểm tra bởi nhóm Bảo mật của chúng tôi, cũng như các chuyên gia bên ngoài.

00:09:29.000 --> 00:09:33.000
Bảo mật dữ liệu có nghĩa là dữ liệu của bạn được giữ bí mật.

00:09:33.000 --> 00:09:37.000
Tính xác thực của dữ liệu có nghĩa là bạn có thể chắc chắn rằng nó không bị hỏng trong quá trình truyền tải.

00:09:37.000 --> 00:09:41.000
Xác thực người gửi có nghĩa là bạn có thể chắc chắn ai đã gửi nó.

00:09:41.000 --> 00:09:46.000
Quyền riêng tư của chữ ký có nghĩa là trong bối cảnh khóa công khai, chỉ có bạn và người gửi biết ai đã ký nó.

00:09:46.000 --> 00:09:52.000
Chúng tôi cũng làm xáo trộn siêu dữ liệu - chẳng hạn như độ dài tệp - và bao gồm bảo vệ tấn công từ chức.

00:09:52.000 --> 00:09:58.000
Cùng với nhau, điều này có nghĩa là bạn có thể tự tin rằng dữ liệu của mình vẫn ở chế độ riêng tư và an toàn.

00:09:58.000 --> 00:10:04.000
Để tạo điều kiện thuận lợi cho việc triển khai chính xác, chúng tôi cung cấp một số hồ sơ khác nhau cho các trường hợp sử dụng khác nhau.

00:10:04.000 --> 00:10:07.000
Hồ sơ cơ bản là có chữ ký số mà không cần mã hóa.

00:10:07.000 --> 00:10:15.000
Điều này có thể được sử dụng cho những thứ như cập nhật phần mềm nơi nội dung không bí mật, nhưng bạn muốn chắc chắn rằng dữ liệu không bị giả mạo.

00:10:15.000 --> 00:10:21.000
Tiếp theo, chúng tôi có mã hóa đối xứng, có hoặc không có chữ ký, sử dụng khóa nhị phân được chia sẻ an toàn.

00:10:21.000 --> 00:10:25.000
Điều này tương tự như tùy chọn tiếp theo sử dụng mật khẩu thay vì khóa nhị phân.

00:10:25.000 --> 00:10:30.000
Cuối cùng, chúng tôi có mã hóa khóa công khai toàn diện, một lần nữa có hoặc không có chữ ký.

00:10:30.000 --> 00:10:36.000
Trong tất cả các cấu hình, nén là tùy chọn và dữ liệu luôn được xác thực.

00:10:36.000 --> 00:10:39.000
Để làm việc với các định dạng này, chúng tôi cung cấp một số công cụ dòng lệnh.

00:10:39.000 --> 00:10:47.000
Để làm việc với phần lưu trữ nén của định dạng, có compression_tool, và đối với kho lưu trữ được mã hóa, có aea.

00:10:47.000 --> 00:10:51.000
Công cụ aa xử lý toàn bộ thùng chứa.

00:10:51.000 --> 00:10:57.000
Tất nhiên cũng có một API được cung cấp bởi khung Apple Archive trong cả Swift và C.

00:10:57.000 --> 00:11:01.000
Nó dựa trên luồng, cho phép truy cập cả tuần tự và ngẫu nhiên.

00:11:01.000 --> 00:11:06.000
Việc triển khai nó được đa luồng cho hiệu suất cực nhanh.

00:11:06.000 --> 00:11:08.000
Vì vậy, hãy xem API này đang hoạt động.

00:11:08.000 --> 00:11:11.000
Ở đây, chúng tôi có một ứng dụng demo đơn giản mà chúng tôi đã kết hợp với nhau.

00:11:11.000 --> 00:11:18.000
Phần trên cùng của cửa sổ hoạt động như một mục tiêu kéo và thả cho những thứ chúng ta muốn mã hóa, trong khi phần dưới cùng là một ngăn trạng thái đơn giản.

00:11:18.000 --> 00:11:21.000
Giả sử tôi muốn mã hóa thư mục TopSecret này.

00:11:21.000 --> 00:11:25.000
Tôi chỉ cần kéo và thả cái này vào ứng dụng.

00:11:25.000 --> 00:11:26.000
Và, ồ không! Chúng tôi gặp lỗi.

00:11:26.000 --> 00:11:29.000
Chúng tôi vẫn chưa triển khai chức năng này!

00:11:29.000 --> 00:11:31.000
Hãy làm điều đó ngay bây giờ.

00:11:31.000 --> 00:11:34.000
Vậy, chúng ta cần làm gì để mã hóa điều này với Apple Archive?

00:11:34.000 --> 00:11:42.000
Đầu tiên, chúng ta cần một ngữ cảnh mã hóa mô tả thuật toán và hồ sơ để sử dụng, cùng với bí mật mã hóa của chúng ta.

00:11:42.000 --> 00:11:46.000
Chúng tôi cũng cần một luồng tệp mà chúng tôi sẽ ghi vào kho lưu trữ.

00:11:46.000 --> 00:11:49.000
Chúng tôi kết hợp những thứ này để tạo ra một luồng mã hóa.

00:11:49.000 --> 00:11:56.000
Luồng mã hóa sẽ mã hóa một luồng byte, vì vậy chúng tôi cần một bộ điều hợp sẽ dịch thư mục mà chúng tôi muốn mã hóa thành như vậy.

00:11:56.000 --> 00:11:59.000
Đây là luồng bộ mã hóa.

00:11:59.000 --> 00:12:03.000
Tất nhiên, dữ liệu chảy theo hướng ngược lại với việc tạo đối tượng.

00:12:03.000 --> 00:12:12.000
Chúng tôi cung cấp các mục lưu trữ vào luồng bộ mã hóa, chuyển đổi chúng thành byte cho luồng mã hóa, sau đó xuất dữ liệu được mã hóa vào luồng tệp.

00:12:12.000 --> 00:12:14.000
Hãy xem nó trông như thế nào trong mã.

00:12:14.000 --> 00:12:17.000
Ở đây, chúng tôi xác định rằng chúng tôi đang sử dụng một hồ sơ đối xứng.

00:12:17.000 --> 00:12:21.000
Và "không" cho chúng ta biết rằng chúng ta sẽ không sử dụng chữ ký số.

00:12:21.000 --> 00:12:26.000
Phần ban đầu của liệt kê chỉ xác định thuật toán cụ thể mà chúng tôi muốn sử dụng.

00:12:26.000 --> 00:12:30.000
Ở đây, chúng ta sẽ sử dụng "lzfse" để nén dữ liệu của chúng ta.

00:12:30.000 --> 00:12:36.000
Với ngữ cảnh được tạo, chúng ta chỉ cần chỉ định khóa mã hóa đối xứng của mình.

00:12:36.000 --> 00:12:40.000
Tiếp theo, chúng tôi tạo ra ba luồng đó.

00:12:40.000 --> 00:12:51.000
Đầu tiên, chúng tôi tạo luồng tệp, sau đó chúng tôi kết hợp nó với một ngữ cảnh để tạo luồng mã hóa.

00:12:51.000 --> 00:12:54.000
Cuối cùng, chúng tôi rút ra encoderStream.

00:12:54.000 --> 00:12:59.000
Bây giờ, điều quan trọng là chúng ta phải nhớ đóng các luồng này theo đúng thứ tự.

00:12:59.000 --> 00:13:06.000
Đặc biệt, việc đóng encryptionStream thực hiện rất nhiều công việc đằng sau hậu trường, vì nó ký và niêm phong kho lưu trữ.

00:13:06.000 --> 00:13:13.000
Cuối cùng, tất cả những gì còn lại là để chúng tôi đưa các tệp của mình vào encoderStream.

00:13:13.000 --> 00:13:21.000
Tôi chỉ định các thuộc tính tệp mà tôi muốn mã hóa và sau đó gọi phương thức writeDirectoryContents.

00:13:21.000 --> 00:13:26.000
Tất cả những gì còn lại là in một thông báo trạng thái vào bảng điều khiển bằng khóa mã hóa.

00:13:26.000 --> 00:13:29.000
Hãy xem điều đó có hiệu quả không.

00:13:29.000 --> 00:13:36.000
Nếu tôi thả thư mục TopSecret của chúng tôi vào ứng dụng, nó sẽ thành công, mã hóa nó và in khóa mã hóa của chúng tôi.

00:13:36.000 --> 00:13:42.000
Bây giờ, nếu tôi kéo và thả kho lưu trữ được mã hóa của chúng tôi vào ứng dụng, nó sẽ cố gắng giải mã nó và yêu cầu khóa mã hóa.

00:13:42.000 --> 00:13:48.000
Vì vậy, hãy sao chép và dán khóa mã hóa đó và xem có gì bên trong.

00:13:48.000 --> 00:13:51.000
Mmm, ngon quá!

00:13:51.000 --> 00:13:55.000
Đó là tất cả những gì tôi có cho bạn trên Apple Encrypted Archive, vì vậy hãy kết thúc.

00:13:55.000 --> 00:14:07.000
Hôm nay, tôi đã nói chuyện với bạn về những cải tiến đối với khung Accelerate, bao gồm hỗ trợ cho các loại lớp mới trong BNNS, cũng như hỗ trợ C++ mở rộng và các chức năng khác trong simd.h.

00:14:07.000 --> 00:14:14.000
Sau đó tôi đã giới thiệu cho bạn về Kho lưu trữ Apple và các định dạng Kho lưu trữ được mã hóa Apple mới và sự hỗ trợ của chúng trong các khuôn khổ.

00:14:14.000 --> 00:14:17.000
Cảm ơn bạn và tận hưởng phần còn lại của WWDC.

00:14:17.000 --> 23:59:59.000
♪

