WEBVTT

00:00:02.000 --> 00:00:10.000
Donna: Xin chào.

00:00:10.000 --> 00:00:13.000
Tôi là Donna Tom, và tôi là một kỹ sư TextKit.

00:00:13.000 --> 00:00:17.000
Đồng nghiệp Chris Willmore của tôi sẽ tham gia cùng tôi sau trong video này.

00:00:17.000 --> 00:00:24.000
Chúng tôi đang giới thiệu TextKit 2, công cụ văn bản thế hệ tiếp theo của Apple.

00:00:24.000 --> 00:00:33.000
Để hiểu TextKit 2 là gì, hãy xem lại ngắn gọn TextKit gốc, mà chúng ta sẽ gọi là TextKit 1.

00:00:33.000 --> 00:00:39.000
TextKit 1 là một công cụ văn bản điều khiển bố cục văn bản và hiển thị trên tất cả các nền tảng của Apple.

00:00:39.000 --> 00:00:49.000
Điều khiển văn bản trong UIKit và AppKit sử dụng TextKit 1 để quản lý việc lưu trữ và kiểm soát bố cục của nội dung văn bản.

00:00:49.000 --> 00:00:55.000
TextKit 1 lần đầu tiên xuất hiện trên hệ thống trong OpenStep hơn 20 năm trước.

00:00:55.000 --> 00:01:05.000
Nó đã phát triển và phát triển cùng chúng tôi qua nhiều năm từ macOS 10.0 đến iOS 7 đến macOS 11 và iOS 14.

00:01:05.000 --> 00:01:12.000
Thật tuyệt vời khi TextKit 1 vẫn cung cấp rất nhiều chức năng thiết yếu trên tất cả các thiết bị của Apple.

00:01:12.000 --> 00:01:17.000
Các nguyên tắc thiết kế công nghệ và kỹ thuật đã thay đổi rất nhiều trong nhiều thập kỷ.

00:01:17.000 --> 00:01:31.000
Vì TextKit 1 gắn liền với các nguyên tắc ban đầu của nó, nên việc cung cấp các API tích hợp tốt với các công nghệ mới hơn của chúng tôi trong khi vẫn mang lại tiêu chuẩn hiệu suất cao trở nên khó khăn hơn trong những năm qua.

00:01:31.000 --> 00:01:34.000
Đó là lý do tại sao chúng tôi đã xây dựng TextKit 2.

00:01:34.000 --> 00:01:40.000
TextKit 2 là công cụ văn bản thế hệ tiếp theo của Apple, được xây dựng trên một tập hợp các nguyên tắc thiết kế hướng tới tương lai.

00:01:40.000 --> 00:01:42.000
Và đoán xem?

00:01:42.000 --> 00:01:45.000
Bạn đã sử dụng TextKit 2 trên máy Mac của mình.

00:01:45.000 --> 00:01:52.000
Trong Big Sur, chúng tôi đã cập nhật nhiều thành phần văn bản trên hệ điều hành để sử dụng TextKit 2 đằng sau hậu trường.

00:01:52.000 --> 00:01:57.000
Bất ngờ lớn: bạn đã sử dụng TextKit 2 từ macOS 11.

00:01:57.000 --> 00:02:01.000
Bây giờ, hãy xem lại ngắn gọn kiến trúc cho phép chúng tôi làm điều này.

00:02:01.000 --> 00:02:05.000
TextKit 2 cùng tồn tại với TextKit 1.

00:02:05.000 --> 00:02:13.000
Cũng giống như người tiền nhiệm của nó, TextKit 2 được xây dựng dựa trên Foundation, Quartz và Core Text.

00:02:13.000 --> 00:02:18.000
Các điều khiển văn bản trong UIKit và AppKit được xây dựng trên TextKit 2.

00:02:18.000 --> 00:02:23.000
TextKit 2 cũng giữ lại một cách lỏng lẻo thiết kế MVC của người tiền nhiệm của nó.

00:02:23.000 --> 00:02:35.000
Phần xem vẫn nằm trong các đối tượng xem của khung UIKit và AppKit, trong khi có các phiên bản mới của những người bạn cũ của chúng tôi, NSTextStorage và NSLayoutManager.

00:02:35.000 --> 00:02:42.000
Ngoài các phiên bản mới này, còn có nhiều lớp và giao thức mới tham gia vào các lớp mô hình và bộ điều khiển.

00:02:42.000 --> 00:02:45.000
Có khá nhiều người trong số họ, nhưng đừng lo lắng.

00:02:45.000 --> 00:02:52.000
Những thành phần mới này kết hợp đơn giản, tập trung và mạnh mẽ.

00:02:52.000 --> 00:03:02.000
Chúng giúp bạn dễ dàng thể hiện những gì bạn muốn làm với văn bản của mình và ít lo lắng hơn về cách hệ thống hoàn thành những gì bạn muốn.

00:03:02.000 --> 00:03:07.000
Bây giờ chúng ta đã có cái nhìn kiến trúc về hệ thống, hãy đi sâu vào chi tiết.

00:03:07.000 --> 00:03:21.000
Đầu tiên, chúng ta sẽ thảo luận về các nguyên tắc thiết kế cốt lõi của TextKit 2 và cách các nguyên tắc này sẽ thay đổi cách bạn nghĩ về việc tùy chỉnh lưu trữ, bố cục và hiển thị văn bản trong ứng dụng của mình.

00:03:21.000 --> 00:03:28.000
Sau đó, Chris sẽ hướng dẫn bạn qua ứng dụng mẫu TextKit 2 mà chúng tôi đã tạo ra để cộng tác trên một cuốn sách công thức nấu ăn.

00:03:28.000 --> 00:03:34.000
Ứng dụng này sử dụng các lớp TextKit 2 mới để bố trí và hiển thị văn bản trong CALayers.

00:03:34.000 --> 00:03:39.000
Tại đây, bạn sẽ được học cách các nguyên tắc thiết kế hoạt động trong thực tế.

00:03:39.000 --> 00:03:45.000
Cuối cùng, chúng tôi sẽ đề cập đến một số chi tiết kỹ thuật quan trọng để hiện đại hóa các ứng dụng của bạn cho TextKit 2.

00:03:45.000 --> 00:03:49.000
Vậy hãy bắt đầu với các nguyên tắc thiết kế.

00:03:49.000 --> 00:03:57.000
Các nguyên tắc thiết kế cấp cao cốt lõi của TextKit 2 là tính chính xác, an toàn và hiệu suất.

00:03:57.000 --> 00:04:00.000
Chúng tôi đã thực hiện một cách tiếp cận cân bằng.

00:04:00.000 --> 00:04:07.000
Cả ba nguyên tắc đều quan trọng, vì vậy không có ưu tiên cho thứ tự mà chúng ta thảo luận về chúng.

00:04:07.000 --> 00:04:14.000
Mỗi nguyên tắc thiết kế cấp cao này thông báo một sự thay đổi thiết kế cụ thể trong hệ thống.

00:04:14.000 --> 00:04:19.000
Để chính xác, TextKit 2 tóm tắt việc xử lý glyph.

00:04:19.000 --> 00:04:26.000
Để đảm bảo an toàn, TextKit 2 tập trung nhiều hơn vào ngữ nghĩa giá trị.

00:04:26.000 --> 00:04:33.000
Và để đạt hiệu suất, TextKit 2 sử dụng bố cục và kết xuất dựa trên khung nhìn.

00:04:33.000 --> 00:04:35.000
Chúng ta sẽ bắt đầu với sự đúng đắn.

00:04:35.000 --> 00:04:43.000
Trong lĩnh vực này, chúng tôi đã trừu tượng hóa việc xử lý glyph để cung cấp trải nghiệm nhất quán cho văn bản quốc tế.

00:04:43.000 --> 00:04:57.000
Các thiết bị của Apple được sử dụng ở mọi nơi trên thế giới, vì vậy điều thực sự quan trọng là cung cấp bố cục, kết xuất và tương tác chính xác cho văn bản bằng tất cả các ngôn ngữ và tập lệnh.

00:04:57.000 --> 00:05:01.000
Chúng tôi muốn mọi người có thể đọc và tương tác với văn bản trên thiết bị của họ.

00:05:01.000 --> 00:05:10.000
Và thiết kế của một số API TextKit 1 gây khó khăn cho việc làm việc với văn bản quốc tế theo cách chính xác trên toàn cầu.

00:05:10.000 --> 00:05:15.000
Để hiểu tại sao, trước tiên chúng ta cần hiểu glyph là gì.

00:05:15.000 --> 00:05:21.000
Một glyph là một biểu diễn trực quan của một số ký tự thay đổi.

00:05:21.000 --> 00:05:30.000
Trong nhiều ngôn ngữ phương Tây, một glyph thường đại diện cho một ký tự, nhưng điều này không phải lúc nào cũng đúng.

00:05:30.000 --> 00:05:35.000
Bạn có thể có nhiều glyphs đại diện cho một ký tự duy nhất, hoặc có thể ngược lại.

00:05:35.000 --> 00:05:40.000
Một glyph duy nhất có thể đại diện cho nhiều ký tự.

00:05:40.000 --> 00:05:46.000
Chữ tượng đơn lẻ này được sử dụng để đại diện cho nhiều ký tự được gọi là chữ ghép.

00:05:46.000 --> 00:05:52.000
Không có quá nhiều chữ ghép trong các ngôn ngữ phương Tây và chúng thường không ảnh hưởng đến tính dễ đọc của văn bản.

00:05:52.000 --> 00:05:56.000
Bạn vẫn có thể đọc nó tốt mà không cần chữ ghép.

00:05:56.000 --> 00:05:59.000
Nhưng điều đó không đúng với tất cả các ngôn ngữ.

00:05:59.000 --> 00:06:06.000
Các chữ viết như tiếng Ả Rập và Devanagari sử dụng rất nhiều chữ ghép, và chúng ảnh hưởng đến tính dễ đọc.

00:06:06.000 --> 00:06:09.000
Kiểm tra từ này bằng chữ Ả Rập.

00:06:09.000 --> 00:06:12.000
Đó là một từ tiếng Urdu có nghĩa là "khoảnh khắc".

00:06:12.000 --> 00:06:17.000
Bây giờ hãy dành một chút thời gian để so sánh hai kết xuất này.

00:06:17.000 --> 00:06:23.000
Từ đầy đủ, được vẽ bằng chữ ghép ở bên phải, xuất hiện rất khác so với các ký tự riêng lẻ ở bên trái.

00:06:23.000 --> 00:06:32.000
Độc giả bản địa của ngôn ngữ sẽ coi phiên bản bên trái là không đọc được.

00:06:32.000 --> 00:06:38.000
Nhiều API trong TextKit 1 yêu cầu làm việc với chỉ mục hoặc phạm vi glyph.

00:06:38.000 --> 00:06:47.000
Ví dụ, để có được hình chữ nhật giới hạn của một số văn bản, bạn cần biết phạm vi glyph của văn bản bạn muốn.

00:06:47.000 --> 00:06:53.000
Nếu văn bản bằng ngôn ngữ phương Tây, việc tìm ra phạm vi glyph phù hợp không quá tệ.

00:06:53.000 --> 00:07:01.000
Trong ví dụ tiếng Anh này, khá dễ dàng để tìm phạm vi glyph cho bốn ký tự đầu tiên của văn bản.

00:07:01.000 --> 00:07:07.000
Bây giờ hãy xem xét Kannada, một chữ viết và ngôn ngữ được nói bởi hàng triệu người ở Ấn Độ.

00:07:07.000 --> 00:07:15.000
Nó không chỉ sử dụng nhiều chữ ghép, các glyphs có thể được sắp xếp lại và kết hợp theo đủ loại cách thú vị.

00:07:15.000 --> 00:07:25.000
Từ Kannada này có nghĩa là "Tháng Mười" có một nguyên âm phân tách ở chỉ mục ký tự bốn, do đó được chia thành hai glyphs.

00:07:25.000 --> 00:07:34.000
Sau đó, cái bên trái được sắp xếp lại giữa các glyph đại diện cho các ký tự một và hai trước khi chữ ghép cho hai được áp dụng.

00:07:34.000 --> 00:07:42.000
Glyph đại diện cho ký tự ở chỉ mục ba cũng được thay thế bằng một dạng dính liền.

00:07:42.000 --> 00:07:46.000
Trong từ cuối cùng, nó được vẽ bên dưới một trong những glyphs trong nguyên âm phân chia.

00:07:46.000 --> 00:07:52.000
Bây giờ, nếu bạn không hiểu bất kỳ điều gì tôi vừa nói, điều đó hoàn toàn ổn.

00:07:52.000 --> 00:07:59.000
Đây là những chi tiết mà khuôn khổ nên xử lý cho bạn để bạn có thể tập trung vào việc xây dựng ứng dụng của mình.

00:07:59.000 --> 00:08:06.000
Vấn đề là, không thể tìm thấy phạm vi glyph cho bốn ký tự đầu tiên của văn bản như thế này.

00:08:06.000 --> 00:08:12.000
Không có phạm vi glyph nào đại diện cho bốn ký tự đó.

00:08:12.000 --> 00:08:23.000
Và vì nhiều API TextKit 1 yêu cầu phạm vi glyph, việc sử dụng các API đó có khả năng phá vỡ bố cục và kết xuất cho các tập lệnh phức tạp như thế này.

00:08:23.000 --> 00:08:27.000
Và đó là lý do tại sao TextKit 2 tóm tắt việc xử lý glyph.

00:08:27.000 --> 00:08:35.000
TextKit 2 hiển thị tất cả văn bản với Core Text-- vì vậy bạn sẽ tự động nhận được kết xuất chính xác cho các tập lệnh phức tạp.

00:08:35.000 --> 00:08:39.000
Bạn sẽ không phải quản lý glyphs chút nào với TextKit 2.

00:08:39.000 --> 00:08:45.000
Thay vào đó, bạn sử dụng các đối tượng cấp cao hơn để kiểm soát bố cục văn bản và tương tác.

00:08:45.000 --> 00:08:50.000
Gặp gỡ NSTextSelection, một trong những đối tượng cấp cao hơn này.

00:08:50.000 --> 00:09:03.000
Nó chứa tất cả các ngữ cảnh cần thiết để thể hiện một lựa chọn văn bản, chẳng hạn như độ chi tiết của nó, ái lực của nó và các phạm vi văn bản có thể rời rạc tạo nên lựa chọn.

00:09:03.000 --> 00:09:11.000
Các thuộc tính này trên NSTextSelection chỉ được đọc, vì vậy bạn sẽ không sửa đổi các trường hợp của đối tượng lựa chọn để thay đổi chúng.

00:09:11.000 --> 00:09:27.000
Thay vào đó, bạn sử dụng một phiên bản của NSTextSelectionNavigation để thực hiện các hành động trên các lựa chọn văn bản, nhận các phiên bản mới của NSTextSelection đại diện cho lựa chọn kết quả.

00:09:27.000 --> 00:09:39.000
Bạn có thể yêu cầu đối tượng điều hướng cung cấp cho bạn các lựa chọn do các sự kiện nhấn hoặc chuột xuống tại một điểm trên màn hình hoặc nhận một lựa chọn mới do điều hướng về phía trước hoặc phía sau.

00:09:39.000 --> 00:09:49.000
Điều này giúp việc làm mọi thứ dễ dàng hơn, như mở rộng lựa chọn về phía trước bằng một từ và nhận được kết quả chính xác, tính đến văn bản hai chiều bằng ngôn ngữ từ phải sang trái.

00:09:49.000 --> 00:09:54.000
Bây giờ tôi muốn kêu gọi sự chú ý của bạn đến điều gì đó thú vị về các API lựa chọn mới này.

00:09:54.000 --> 00:09:57.000
Phương pháp này lấy một NSTextLocation.

00:09:57.000 --> 00:10:02.000
Đây là một đối tượng mới khác trong TextKit 2.

00:10:02.000 --> 00:10:06.000
Gặp gỡ NSTextLocation và NSTextRange.

00:10:06.000 --> 00:10:15.000
Chúng rất giống với các lớp UITextPosition và UITextRange từ UIKit, ngoại trừ việc bạn không bắt buộc phải phân lớp chúng.

00:10:15.000 --> 00:10:22.000
Hầu hết thời gian, bạn sẽ sử dụng các đối tượng vị trí và phạm vi mặc định với TextKit 2.

00:10:22.000 --> 00:10:31.000
Sử dụng các đối tượng thay vì số nguyên cho phép các mô hình tài liệu biểu cảm hơn vì các phạm vi được xác định theo các vị trí tương đối với nhau.

00:10:31.000 --> 00:10:36.000
Mô hình đối tượng tài liệu HTML là một ví dụ điển hình về điều này.

00:10:36.000 --> 00:10:45.000
Vì nó có các phần tử lồng nhau, một vị trí cần đại diện cho cả vị trí tuyệt đối trong tài liệu và cả vị trí trong văn bản hiển thị.

00:10:45.000 --> 00:10:49.000
Điều này không thể được thể hiện bằng một chỉ số số duy nhất.

00:10:49.000 --> 00:10:52.000
Và đó là nó cho sự chính xác.

00:10:52.000 --> 00:10:54.000
Tiếp theo là sự an toàn.

00:10:54.000 --> 00:11:07.000
Trong lĩnh vực này, chúng tôi đã thiết kế TextKit 2 với sự nhấn mạnh hơn vào ngữ nghĩa giá trị để phù hợp hơn với các mục tiêu của các công nghệ như Swift và SwiftUI.

00:11:07.000 --> 00:11:12.000
Và khi tôi nói "ngật nghĩa giá trị", tôi không nói về các loại giá trị.

00:11:12.000 --> 00:11:18.000
Chúng tôi đã không biến NSLayoutManager thành một cấu trúc.

00:11:18.000 --> 00:11:23.000
Các loại giá trị giữ một bản sao duy nhất của dữ liệu của chúng, điều này ngăn chặn sự đột biến của dữ liệu đó.

00:11:23.000 --> 00:11:30.000
Điều này làm cho mã của bạn an toàn và ổn định hơn bằng cách loại bỏ việc chia sẻ ngoài ý muốn và các tác dụng phụ liên quan.

00:11:30.000 --> 00:11:35.000
Nhưng các loại giá trị không phải là cách duy nhất để có được lợi ích này.

00:11:35.000 --> 00:11:43.000
Các lớp bất biến có các thuộc tính không thể thay đổi sau khi khởi tạo, điều này cũng ngăn chặn sự đột biến dữ liệu của chúng.

00:11:43.000 --> 00:11:50.000
Các lớp này hoạt động giống như các kiểu giá trị, vì vậy chúng tôi gọi chúng là có ngữ nghĩa giá trị.

00:11:50.000 --> 00:11:57.000
Nếu bạn muốn thay đổi dữ liệu trong một trong những đối tượng này, bạn phải tạo một phiên bản hoàn toàn mới để thay thế phiên bản gốc.

00:11:57.000 --> 00:12:03.000
Và nhiều lớp học trong TextKit 2 được thiết kế theo cách này.

00:12:03.000 --> 00:12:09.000
Để minh họa những lợi ích của sự thay đổi thiết kế này, hãy làm mới trí nhớ của chúng ta về thiết kế của TextKit 1.

00:12:09.000 --> 00:12:15.000
Luồng văn bản từ bộ lưu trữ đến màn hình đã từng hoạt động như thế này.

00:12:15.000 --> 00:12:27.000
Các bản cập nhật cho bộ lưu trữ văn bản đã thông báo cho trình quản lý bố cục, sau đó sẽ tạo các glyphs, định vị chúng và vẽ chúng trực tiếp vào chế độ xem.

00:12:27.000 --> 00:12:37.000
Với cách tiếp cận vẽ glyphs trực tiếp vào chế độ xem, thật khó để tìm ra nơi tách văn bản để tạo khoảng trống cho bản vẽ tùy chỉnh.

00:12:37.000 --> 00:12:45.000
Để hiểu ý tôi về điều đó, hãy xem ảnh chụp màn hình lén lút này từ ứng dụng mẫu, nơi tôi đã để lại một số nhận xét về công thức.

00:12:45.000 --> 00:12:56.000
Chú ý cách nhận xét xuất hiện ngay bên dưới công thức mà nó đề cập đến và nó được vẽ bằng nền màu chàm, hình bong bóng và văn bản màu trắng khác biệt này.

00:12:56.000 --> 00:13:04.000
Chúng ta nên thực hiện cách tiếp cận nào để chèn nhận xét vào đúng vị trí và làm cho chúng trông khác với phần còn lại của văn bản?

00:13:04.000 --> 00:13:21.000
Bạn có thể mong đợi làm điều này bằng cách chia văn bản công thức thành các đơn vị hoặc yếu tố có ý nghĩa, đặt mỗi nhận xét vào phần tử riêng của nó và định vị từng nhận xét sau công thức mà nó liên quan, đồng thời cung cấp hướng dẫn về cách vẽ nhận xét.

00:13:21.000 --> 00:13:25.000
Với TextKit 1, thực tế hoàn toàn khác.

00:13:25.000 --> 00:13:37.000
Bạn phải lo lắng về rất nhiều chi tiết, như tìm chỉ mục glyph, đảm bảo rằng glyph không nằm ở giữa cụm đồ thị, điều chỉnh chỉ mục glyph đó nếu có, thay đổi khoảng cách dòng và có thể tùy chỉnh hình học phân mảnh đường.

00:13:37.000 --> 00:13:40.000
Và những chi tiết này không liên quan đến những gì bạn đang cố gắng làm.

00:13:40.000 --> 00:13:46.000
Vì vậy, với TextKit 2, chúng tôi đang hướng tới việc biến kỳ vọng thành hiện thực.

00:13:46.000 --> 00:13:52.000
Chúng tôi đã thay đổi luồng văn bản thông qua hệ thống để có thể thực hiện các cách tiếp cận như thế này.

00:13:52.000 --> 00:13:56.000
Đây là cách luồng đó hoạt động trong TextKit 2.

00:13:56.000 --> 00:14:03.000
Các bản cập nhật cho bộ lưu trữ văn bản đi qua một đối tượng mới được gọi là trình quản lý nội dung.

00:14:03.000 --> 00:14:09.000
Trình quản lý nội dung chia văn bản thành các yếu tố và theo dõi chúng.

00:14:09.000 --> 00:14:16.000
Khi đến lúc bố cục, trình quản lý bố cục văn bản sẽ hỏi người quản lý nội dung về các yếu tố.

00:14:16.000 --> 00:14:27.000
Sau đó, trình quản lý bố cục văn bản đưa ra các phần tử vào vùng chứa văn bản và tạo ra các đoạn bố cục có chứa thông tin bố cục và định vị.

00:14:27.000 --> 00:14:40.000
Khi đến lúc hiển thị, các đoạn bố cục được chuyển cho ViewportLayoutController, bộ điều phối vị trí và bố cục của các đoạn đó trong bề mặt kết xuất mà bạn chọn, cho dù đó là chế độ xem hay lớp.

00:14:40.000 --> 00:14:44.000
Như bạn có thể nói, có rất nhiều đối tượng mới tham gia vào quá trình này.

00:14:44.000 --> 00:14:50.000
Và đây là nơi mà sự nhấn mạnh vào ngữ nghĩa giá trị xuất hiện.

00:14:50.000 --> 00:15:02.000
Bạn kiểm soát bố cục và hiển thị văn bản của mình bằng cách kết nối vào hệ thống ở đúng điểm và lấy thông tin bạn cần từ các đối tượng sử dụng ngữ nghĩa giá trị.

00:15:02.000 --> 00:15:10.000
Để thực hiện các thay đổi, bạn tạo các phiên bản mới của các đối tượng giá trị với các thay đổi bạn muốn và đưa chúng trở lại hệ thống.

00:15:10.000 --> 00:15:15.000
Hệ thống sử dụng các giá trị từ các đối tượng thay thế của bạn để bố trí và hiển thị.

00:15:15.000 --> 00:15:21.000
Vì vậy, bây giờ, hãy gặp những đối tượng mới này và xác định các điểm khác nhau của hệ thống nơi bạn có thể nhận hoặc thay thế chúng.

00:15:21.000 --> 00:15:25.000
Chúng ta sẽ bắt đầu với các đối tượng lưu trữ.

00:15:25.000 --> 00:15:28.000
Gặp gỡ NSTextElement.

00:15:28.000 --> 00:15:31.000
Các yếu tố là các khối xây dựng tài liệu của bạn.

00:15:31.000 --> 00:15:38.000
Mỗi phần tử đại diện cho một phần của nội dung và chứa một phạm vi mô tả vị trí của nó trong tài liệu.

00:15:38.000 --> 00:15:41.000
Và các yếu tố có ngữ nghĩa giá trị.

00:15:41.000 --> 00:15:48.000
Các thuộc tính của chúng, bao gồm phạm vi, là bất biến và không thể thay đổi sau khi tạo phần tử.

00:15:48.000 --> 00:15:55.000
Mô hình hóa tài liệu như một chuỗi các yếu tố thay vì một loạt các ký tự mang lại cho chúng ta nhiều sức mạnh hơn.

00:15:55.000 --> 00:16:07.000
Chúng tôi có được khả năng dễ dàng phân biệt loại nội dung mà một phần tử nhất định đại diện, cho dù đó là đoạn văn bản, tệp đính kèm hay một số loại tùy chỉnh khác.

00:16:07.000 --> 00:16:13.000
Và chúng ta có thể đưa ra quyết định về cách bố trí các yếu tố dựa trên loại của chúng.

00:16:13.000 --> 00:16:16.000
Bây giờ hãy gặp NSTextContentManager.

00:16:16.000 --> 00:16:25.000
Người quản lý nội dung biết cách tạo các yếu tố từ nội dung văn bản và theo dõi phạm vi của các yếu tố đó trong tài liệu tổng thể.

00:16:25.000 --> 00:16:34.000
Nó cũng biết cách làm việc với cửa hàng sao lưu và cách tạo các yếu tố mới với phạm vi cập nhật khi nội dung trong cửa hàng sao lưu thay đổi.

00:16:34.000 --> 00:16:38.000
Hãy nghĩ về trình quản lý nội dung như một trình bao bọc cho cửa hàng hỗ trợ.

00:16:38.000 --> 00:16:46.000
Trình quản lý nội dung cung cấp một giao diện để dịch dữ liệu thô thành các phần tử.

00:16:46.000 --> 00:16:56.000
NSTextContentManager và NSTextElement đều là các loại trừu tượng, vì vậy bạn có thể phân lớp chúng nếu bạn cần sử dụng mô hình tài liệu tùy chỉnh hoặc cửa hàng sao lưu tùy chỉnh.

00:16:56.000 --> 00:17:00.000
Các tiêu đề và tài liệu cung cấp hướng dẫn về cách thực hiện việc này.

00:17:00.000 --> 00:17:05.000
Nhưng hầu hết thời gian, bạn có thể sử dụng những cái mặc định mà TextKit 2 cung cấp.

00:17:05.000 --> 00:17:09.000
Gặp gỡ NSTextContentStorage và NSTextParagraph.

00:17:09.000 --> 00:17:14.000
Đây là trình quản lý nội dung mặc định và các loại phần tử.

00:17:14.000 --> 00:17:21.000
NSTextContentStorage là một trình quản lý nội dung sử dụng NSTextStorage làm cửa hàng dự phòng.

00:17:21.000 --> 00:17:29.000
Nó biết cách chia nội dung lưu trữ văn bản thành các phần tử đoạn văn, là các trường hợp của NSTextParagraph.

00:17:29.000 --> 00:17:37.000
NSTextContentStorage cũng biết cách tạo các phần tử đoạn văn được cập nhật khi văn bản trong bộ lưu trữ văn bản thay đổi.

00:17:37.000 --> 00:17:40.000
Điều này đưa tôi đến một điểm quan trọng.

00:17:40.000 --> 00:17:48.000
Khi thực hiện các thay đổi đối với bộ lưu trữ văn bản cơ bản, bạn nên gói các bản cập nhật của mình trong phương pháp performEditingTransaction này.

00:17:48.000 --> 00:17:55.000
Điều này đảm bảo rằng các phần khác của hệ thống TextKit 2 được thông báo về những thay đổi của bạn.

00:17:55.000 --> 00:18:02.000
Bạn có thể làm một số thứ thú vị với các đại diện lưu trữ nội dung mà không cần phải triển khai một lớp con NSTextContentManager đầy đủ.

00:18:02.000 --> 00:18:12.000
Sau đó trong video này, Chris sẽ đề cập đến cách sử dụng các đại diện nội dung để thay đổi phông chữ và màu sắc nhận xét mà không cần sửa đổi bộ nhớ văn bản và cách ẩn hoàn toàn nhận xét.

00:18:12.000 --> 00:18:16.000
Vì vậy, hãy theo dõi để biết thêm chi tiết.

00:18:16.000 --> 00:18:17.000
Được rồi.

00:18:17.000 --> 00:18:22.000
Bây giờ chúng tôi đã hiểu cách TextKit 2 tạo ra các yếu tố từ nội dung văn bản của bạn.

00:18:22.000 --> 00:18:26.000
Điều đó quan tâm đến hai bước đầu tiên từ cách tiếp cận mới của chúng tôi.

00:18:26.000 --> 00:18:35.000
Bộ lưu trữ nội dung tự động chia văn bản thành các phần tử đoạn văn và nó biết cách tạo đoạn văn mới cho các nhận xét mới.

00:18:35.000 --> 00:18:41.000
Tiếp theo, hãy tìm ra cách chúng ta có thể hoàn thành hai bước cuối cùng: định vị và hiển thị nhận xét.

00:18:41.000 --> 00:18:47.000
Quay trở lại sơ đồ dòng chảy của chúng tôi, chúng tôi cần lấy thông tin bố cục cho các yếu tố nhận xét của mình.

00:18:47.000 --> 00:18:50.000
Có những đối tượng bố cục mới để giúp chúng tôi thực hiện những nhiệm vụ này.

00:18:50.000 --> 00:18:53.000
Hãy gặp họ ngay bây giờ.

00:18:53.000 --> 00:18:56.000
Gặp gỡ NSTextLayoutManager.

00:18:56.000 --> 00:19:00.000
Trình quản lý bố cục văn bản kiểm soát quá trình bố cục văn bản.

00:19:00.000 --> 00:19:12.000
NSTextLayoutManager tương tự như NSLayoutManager cũ từ TextKit 1 với một điểm khác biệt chính: NSTextLayoutManager không xử lý glyphs.

00:19:12.000 --> 00:19:23.000
Thay vào đó, NSTextLayoutManager lấy các phần tử văn bản, đặt chúng vào vùng chứa văn bản và tạo các đoạn bố cục cho các phần tử đó.

00:19:23.000 --> 00:19:27.000
Bạn làm việc với các đoạn bố cục để lấy thông tin bố cục cho các phần tử văn bản.

00:19:27.000 --> 00:19:31.000
Vì vậy, bây giờ hãy tìm hiểu về các đoạn bố cục.

00:19:31.000 --> 00:19:34.000
Gặp gỡ NSTextLayoutFragment.

00:19:34.000 --> 00:19:39.000
Một đoạn bố cục chứa thông tin bố cục cho một hoặc nhiều phần tử văn bản.

00:19:39.000 --> 00:19:45.000
Cũng giống như các phần tử, chúng sử dụng ngữ nghĩa giá trị và các thuộc tính của chúng là bất biến.

00:19:45.000 --> 00:19:56.000
Vì vậy, trình quản lý bố cục văn bản sẽ tạo các đoạn bố cục cho từng yếu tố nhận xét của chúng tôi và sau đó chúng tôi có thể sử dụng thông tin từ các đoạn bố cục để định vị và hiển thị chúng.

00:19:56.000 --> 00:20:10.000
Các đoạn bố cục truyền đạt thông tin bố cục thông qua ba thuộc tính: một mảng textLineFragments, layoutFragmentFrame và renderingSurfaceBounds.

00:20:10.000 --> 00:20:17.000
Nếu bạn muốn tùy chỉnh hoặc thay đổi bố cục, điều cần thiết là phải hiểu thông tin bạn nhận được với từng thuộc tính này.

00:20:17.000 --> 00:20:20.000
Vì vậy, chúng ta sẽ xem xét điều đó tiếp theo.

00:20:20.000 --> 00:20:24.000
Đối với tài sản đầu tiên, chúng tôi sẽ gặp NSTextLineFragment.

00:20:24.000 --> 00:20:30.000
Các đoạn dòng chứa thông tin đo lường cho từng dòng văn bản trong đoạn bố cục.

00:20:30.000 --> 00:20:39.000
Chúng rất hữu ích để thu thập thông tin hình học cho các dòng cụ thể hoặc để đếm số dòng trong một đoạn bố cục.

00:20:39.000 --> 00:20:48.000
Thuộc tính thứ hai, khung đoạn bố cục, mô tả cách văn bản trong đoạn bố cục được bố trí bên trong khu vực vùng chứa văn bản.

00:20:48.000 --> 00:20:55.000
Trong TextKit 2, bố cục văn bản về cơ bản là xếp chồng các khung đoạn bố cục trong vùng chứa.

00:20:55.000 --> 00:20:57.000
Hãy nghĩ về những khung hình này như gạch.

00:20:57.000 --> 00:21:05.000
Hệ thống đang chia khu vực vùng chứa văn bản thành các ô, trong đó mỗi đoạn bố cục là một ô duy nhất.

00:21:05.000 --> 00:21:10.000
Các đường rỗng có khung phân đoạn bố cục riêng, như được hiển thị trong sơ đồ.

00:21:10.000 --> 00:21:22.000
Nói chung, các khung phân đoạn bố cục rất hữu ích để định vị các chế độ xem khác trong giao diện người dùng của bạn gần nội dung phân đoạn hoặc để tính tổng chiều cao của nội dung văn bản.

00:21:22.000 --> 00:21:27.000
Bây giờ, khung này không thể hiện chính xác không gian cần thiết để vẽ chính văn bản.

00:21:27.000 --> 00:21:31.000
Thông tin đó đến từ tài sản thứ ba.

00:21:31.000 --> 00:21:37.000
Giới hạn bề mặt kết xuất mô tả diện tích cần thiết để vẽ văn bản.

00:21:37.000 --> 00:21:43.000
Đây là hình chữ nhật bạn muốn sử dụng để lấy kích thước của văn bản trong không gian tọa độ xem.

00:21:43.000 --> 00:21:49.000
Và điều này khác với khung phân đoạn bố cục vì văn bản có thể vượt quá các cạnh của khung phân đoạn.

00:21:49.000 --> 00:21:56.000
Điều này xảy ra với dấu phụ hoặc, như được hiển thị ở đây, với các dấu xuống dài trong phông chữ in nghiêng.

00:21:56.000 --> 00:22:04.000
Chú ý cách cạnh dưới bên trái của chữ J nhô ra chỉ một chút từ khung mảnh bố cục.

00:22:04.000 --> 00:22:09.000
Nó không nổi bật nhiều như vậy, vì vậy đây là một ví dụ cực đoan hơn.

00:22:09.000 --> 00:22:15.000
Một số phông chữ, như Zapfino, có các glyphs mở rộng rất xa bên ngoài giới hạn đánh máy.

00:22:15.000 --> 00:22:21.000
Giới hạn bề mặt kết xuất sẽ lớn hơn nhiều so với khung phân đoạn bố cục trong trường hợp này.

00:22:21.000 --> 00:22:32.000
Bây giờ chúng ta đã hiểu thông tin bố cục mà các đoạn bố cục cung cấp, hãy sao lưu một chút và nói về cách sử dụng thông tin này để tùy chỉnh bố cục của các phần tử văn bản.

00:22:32.000 --> 00:22:40.000
Vì các đoạn bố cục là bất biến, bạn không thể trực tiếp thay đổi thông tin bố cục trên một đoạn.

00:22:40.000 --> 00:22:53.000
Quay trở lại sơ đồ dòng chảy của chúng tôi, chúng tôi cần kết nối với quy trình bố cục và tạo các phiên bản mới của NSTextLayoutFragment với thông tin chúng tôi muốn thay đổi.

00:22:53.000 --> 00:23:00.000
Và bạn kết nối với quy trình bố cục bằng cách sử dụng phương thức đại diện này trên NSTextLayoutManager.

00:23:00.000 --> 00:23:07.000
Phương pháp này được gọi trong quá trình bố cục khi trình quản lý bố cục văn bản đang tạo ra các đoạn bố cục từ các phần tử.

00:23:07.000 --> 00:23:15.000
Tại đây bạn có cơ hội tạo đoạn bố cục của riêng mình cho một phần tử.

00:23:15.000 --> 00:23:19.000
Điều đó giải quyết hai bước cuối cùng trong cách tiếp cận của chúng tôi đối với vấn đề bình luận.

00:23:19.000 --> 00:23:31.000
Chúng tôi sẽ xử lý việc định vị và vẽ tùy chỉnh đoạn bố cục nhận xét của mình bằng cách sử dụng lớp con của NSTextLayoutFragment và cung cấp các trường hợp của đoạn tùy chỉnh của chúng tôi trong đại diện trình quản lý bố cục văn bản.

00:23:31.000 --> 00:23:37.000
Sau đó trong video này, Chris sẽ trình bày cách thực hiện điều này trong ứng dụng mẫu của chúng tôi.

00:23:37.000 --> 00:23:38.000
Và đó là sự an toàn.

00:23:38.000 --> 00:23:42.000
Bây giờ hãy chuyển sang biểu diễn.

00:23:42.000 --> 00:23:46.000
Hiệu suất là một trong những thách thức lớn nhất đối với bất kỳ công cụ văn bản nào.

00:23:46.000 --> 00:23:59.000
TextKit 2 cực kỳ nhanh cho một loạt các tình huống cực kỳ rộng, từ việc hiển thị nhanh chóng các nhãn chỉ có một vài dòng mỗi dòng đến bố trí các tài liệu có hàng trăm megabyte được cuộn qua với tốc độ tương tác.

00:23:59.000 --> 00:24:14.000
Và đối với những tình huống này, khi bạn cuộn qua các tài liệu thực sự lớn này với tốc độ thay đổi, bố cục văn bản không liền kề là hoàn toàn cần thiết cho hiệu suất tuyệt vời.

00:24:14.000 --> 00:24:19.000
Hãy xem lại sự khác biệt giữa bố cục liền kề và không liền kề.

00:24:19.000 --> 00:24:27.000
Sơ đồ này cho thấy một tài liệu trong đó hình chữ nhật màu vàng đại diện cho vùng nội dung hiển thị trên màn hình.

00:24:27.000 --> 00:24:35.000
Bố cục liền kề bắt đầu từ đầu tài liệu và theo thứ tự từ đầu đến cuối văn bản.

00:24:35.000 --> 00:24:44.000
Vì vậy, nếu bạn cuộn đến một số điểm ở giữa tài liệu, bố cục tiếp giáp sẽ thực hiện bố cục cho tất cả văn bản xuất hiện trước thời điểm đó.

00:24:44.000 --> 00:24:50.000
Điều này bao gồm tất cả văn bản đã được cuộn ra khỏi màn hình, quay trở lại đầu.

00:24:50.000 --> 00:24:57.000
Và nếu có nhiều văn bản, hiệu suất có thể chậm và bạn có thể gặp trục trặc hoạt hình khi cuộn.

00:24:57.000 --> 00:25:01.000
Trong trường hợp xấu nhất, nó có thể bị treo.

00:25:01.000 --> 00:25:11.000
Ngược lại, bố cục không liền kề có nghĩa là chúng ta có thể bố trí một đoạn văn bản ở bất kỳ đâu trong tài liệu mà không cần bố trí các phần xuất hiện trước nó.

00:25:11.000 --> 00:25:18.000
Bây giờ khi bạn cuộn đến giữa tài liệu, bố cục sẽ xảy ra cho khu vực hiển thị đó ngay lập tức.

00:25:18.000 --> 00:25:30.000
Điều này cải thiện hiệu suất bằng cách chỉ thực hiện bố cục cho các phần văn bản hiển thị trên màn hình, cộng với vùng cuộn quá mức bổ sung, dẫn đến trải nghiệm cuộn mượt mà hơn.

00:25:30.000 --> 00:25:35.000
Và bố cục trong TextKit 2 luôn không liền kề nhau.

00:25:35.000 --> 00:25:41.000
Ngược lại, bố cục không liền kề là tùy chọn trong TextKit 1.

00:25:41.000 --> 00:25:46.000
Nó được kích hoạt bằng cách sử dụng thuộc tính boolean trên NSLayoutManager.

00:25:46.000 --> 00:25:57.000
API này đơn giản, nhưng vì nó đơn giản, nó không thể thể hiện thông tin về trạng thái của bố cục tại thời điểm bạn yêu cầu thông tin bố cục.

00:25:57.000 --> 00:26:04.000
Bố cục không liền kề dựa trên các ước tính có thể thay đổi sau này khi các phần khác của tài liệu đã được trình bày.

00:26:04.000 --> 00:26:10.000
Với TextKit 1, bạn chỉ có thể bật hoặc tắt bố cục không liền kề.

00:26:10.000 --> 00:26:20.000
Không có khả năng kiểm soát phần nào của tài liệu được bố trí và không có cách nào để biết khi nào bố cục kết thúc và ước tính bố cục được cập nhật thành các giá trị thực.

00:26:20.000 --> 00:26:26.000
TextKit 2 API phong phú và biểu cảm hơn.

00:26:26.000 --> 00:26:36.000
TextKit 2 cung cấp cho bạn thông tin bố cục nhất quán cho các yếu tố trong khu vực nội dung hiển thị và thông báo cho bạn khi bố cục cập nhật cho khu vực hiển thị đó.

00:26:36.000 --> 00:26:39.000
Khu vực này được gọi là khung nhìn.

00:26:39.000 --> 00:26:48.000
Bạn quản lý khung nhìn bằng cách điều chỉnh hoặc di chuyển nó và bạn nhận được các cuộc gọi lại trước, trong và sau khi bố cục khung nhìn.

00:26:48.000 --> 00:26:55.000
Để có hiệu suất tối ưu, mã của bạn nên tập trung vào việc làm việc với thông tin bố cục bên trong khu vực khung nhìn.

00:26:55.000 --> 00:27:02.000
Tránh yêu cầu thông tin bố cục cho các yếu tố bên ngoài khung nhìn khi có thể.

00:27:02.000 --> 00:27:13.000
Thông tin bố cục cho các phần tử bên ngoài khung nhìn có thể không chính xác trừ khi bạn yêu cầu rõ ràng đảm bảo bố cục cho các phạm vi văn bản tương ứng với các phần tử đó.

00:27:13.000 --> 00:27:19.000
Cuộc gọi này có thể tốn kém, đặc biệt là đối với các tài liệu lớn.

00:27:19.000 --> 00:27:28.000
Xem lại sơ đồ dòng chảy của chúng tôi từ trước đó, có một lớp bộ điều khiển mới khác để giúp chúng tôi quản lý khung nhìn.

00:27:28.000 --> 00:27:31.000
Gặp gỡ NSTextViewportLayoutController.

00:27:31.000 --> 00:27:35.000
Đây là nguồn gốc của sự thật cho thông tin bố cục khung nhìn.

00:27:35.000 --> 00:27:42.000
Nó nói chuyện với trình quản lý bố cục văn bản để lấy các đoạn bố cục cho các phần tử trong khu vực khung nhìn.

00:27:42.000 --> 00:27:48.000
Bạn có thể truy cập bộ điều khiển bố cục khung nhìn thông qua thuộc tính trên trình quản lý bố cục văn bản.

00:27:48.000 --> 00:27:56.000
Bây giờ chúng ta đã gặp bộ điều khiển bố cục khung nhìn, hãy nói về cách tham gia vào quá trình bố trí khung nhìn.

00:27:56.000 --> 00:28:16.000
Bộ điều khiển bố cục khung nhìn gọi ba phương thức quan trọng trên đại diện của nó trong quá trình bố cục khung nhìn: TextViewportLayoutController WillLayout, textViewportController configureRenderingSurface FortextLayoutFragment và textViewportLayoutController DidLayout.

00:28:16.000 --> 00:28:23.000
Đầu tiên, bộ điều khiển bố cục khung nhìn gọi phương thức willLayout trước khi bố trí các phần tử trong khung nhìn.

00:28:23.000 --> 00:28:31.000
Đây là nơi bạn thực hiện bất kỳ công việc thiết lập nào để chuẩn bị cho bố cục, chẳng hạn như xóa nội dung của chế độ xem hoặc lớp.

00:28:31.000 --> 00:28:39.000
Tiếp theo, bộ điều khiển bố cục khung nhìn gọi configureRenderingSurface cho mọi đoạn bố cục hiển thị trong khung nhìn.

00:28:39.000 --> 00:28:44.000
Đây là nơi bạn cập nhật hình học của mỗi chế độ xem hoặc lớp phân đoạn.

00:28:44.000 --> 00:28:54.000
Cuối cùng, bộ điều khiển bố cục khung nhìn gọi phương thức didLayout sau khi hoàn tất việc bố trí tất cả các đoạn bố cục hiển thị trong khung nhìn.

00:28:54.000 --> 00:29:03.000
Và đây là nơi bạn thực hiện bất kỳ cập nhật cần thiết nào sau khi bố cục khung nhìn hoàn tất, chẳng hạn như nếu bạn muốn điều chỉnh khung nhìn để làm cho phần tử cuối cùng hiển thị đầy đủ trên màn hình.

00:29:03.000 --> 00:29:05.000
Và điều đó tóm tắt nó cho hiệu suất.

00:29:05.000 --> 00:29:10.000
Bây giờ tôi sẽ giao nó cho Chris để chỉ cho bạn cách sử dụng TextKit 2 trong thực tế.

00:29:10.000 --> 00:29:11.000
Cảm ơn bạn, Donna.

00:29:11.000 --> 00:29:18.000
Chúng tôi đã viết một ứng dụng mẫu thể hiện một số cách khác nhau mà bạn có thể sử dụng TextKit 2 để bố trí và tương tác với văn bản trong ứng dụng của mình.

00:29:18.000 --> 00:29:21.000
Bạn có thể tải xuống mã mẫu được sử dụng trong video này.

00:29:21.000 --> 00:29:24.000
Hãy mở nó ra và dùng thử.

00:29:24.000 --> 00:29:31.000
Chúng tôi đang sử dụng ứng dụng cộng tác này để xem lại một cuốn sách công thức nấu ăn để chúng tôi có thể tìm ra những gì chúng tôi muốn làm cho bữa trưa.

00:29:31.000 --> 00:29:42.000
Cuộn qua các công thức nấu ăn hoạt động như mong đợi, nhưng có điều gì đó đặc biệt đang xảy ra đằng sau hậu trường: Chỉ những đoạn văn có thể nhìn thấy trong khung nhìn mới được vẽ.

00:29:42.000 --> 00:29:49.000
Và thay vì mỗi đoạn văn được hiển thị trên cùng một bề mặt lớn, mỗi đoạn văn được hiển thị thành lớp riêng của nó.

00:29:49.000 --> 00:29:55.000
Nếu tôi nhấp vào nút Hiển thị Giới hạn trên thanh công cụ ở đây, những hình chữ nhật màu này sẽ xuất hiện.

00:29:55.000 --> 00:30:00.000
Hình chữ nhật màu cam hiển thị giới hạn của mỗi lớp.

00:30:00.000 --> 00:30:06.000
Vẽ văn bản thành các lớp riêng biệt cho phép chúng tôi thực hiện một tính năng thú vị: Tôi có thể để lại nhận xét về các công thức nấu ăn.

00:30:06.000 --> 00:30:19.000
Bây giờ, tôi nghĩ rằng một chiếc bánh sandwich trứng nghe có vẻ khá ngon, vì vậy tôi sẽ nhấp đúp vào đoạn này và gõ, "này cái này nghe có vẻ khá hay" và nhấn Enter để chèn bình luận.

00:30:19.000 --> 00:30:23.000
Tôi vừa chèn một đoạn văn mới vào tài liệu.

00:30:23.000 --> 00:30:29.000
Nền bong bóng đang được vẽ bởi một lớp con tùy chỉnh của NSTextLayoutFragment được gọi là BubbleLayoutFragment.

00:30:29.000 --> 00:30:31.000
Thêm về điều đó sau.

00:30:31.000 --> 00:30:39.000
Điều đặc biệt là, khi tôi chèn nhận xét vào tài liệu, tất cả các đoạn bên dưới nhận xét đều di chuyển để nhường chỗ cho nó.

00:30:39.000 --> 00:30:46.000
Nếu bạn không bắt được nó lần đầu tiên, tôi sẽ nhấp vào nút rùa này trên thanh công cụ để bật Chế độ chậm.

00:30:46.000 --> 00:30:48.000
Hãy thêm một bình luận khác.

00:30:48.000 --> 00:30:52.000
"Ừ chúng ta hãy làm nó cho bữa trưa hôm nay.

00:30:52.000 --> 00:30:59.000
Sau khi tôi nhấn Enter, bình luận được thêm vào tài liệu bên dưới nó, và tất cả các đoạn bên dưới nó hoạt hình từ từ.

00:30:59.000 --> 00:31:04.000
Nếu bạn muốn ẩn tất cả các bình luận, bạn có thể nhấp vào nút Chuyển đổi Bình luận trên thanh công cụ.

00:31:04.000 --> 00:31:08.000
Đây không thực sự là chỉnh sửa tài liệu cơ bản.

00:31:08.000 --> 00:31:15.000
Thay vào đó, nó yêu cầu người quản lý nội dung văn bản bỏ qua nhận xét khi liệt kê các yếu tố văn bản để bố cục.

00:31:15.000 --> 00:31:20.000
TextKit 2 hoạt động tốt trên iOS cũng như trên macOS.

00:31:20.000 --> 00:31:24.000
Điều này có nghĩa là các phần TextKit 2 của ứng dụng macOS có thể được sử dụng lại trên iOS.

00:31:24.000 --> 00:31:28.000
Hãy chạy nó trên iPad.

00:31:28.000 --> 00:31:35.000
Chúng tôi đã sử dụng những phần đó để viết phiên bản iOS của ứng dụng cộng tác của chúng tôi với tất cả các chức năng giống nhau.

00:31:35.000 --> 00:31:43.000
Tôi đang nhấn lâu vào một đoạn văn để lại bình luận, sau đó gõ, "này nghe hay đấy"...

00:31:43.000 --> 00:31:46.000
Và nhấn Enter.

00:31:46.000 --> 00:31:53.000
Cũng giống như ứng dụng trên macOS, tôi có thể nhấn vào nút Hiển thị/Ẩn nhận xét để ẩn tất cả nhận xét.

00:31:53.000 --> 00:31:59.000
Tôi vừa xem qua một ứng dụng sử dụng TextKit 2 để bố trí, vẽ và tương tác với văn bản.

00:31:59.000 --> 00:32:05.000
Bây giờ chúng ta hãy xem qua một số mã trong ứng dụng mẫu và cách TextKit 2 làm cho nó có thể.

00:32:05.000 --> 00:32:23.000
Ứng dụng thể hiện rất nhiều chức năng mà TextKit 2 cung cấp, nhưng bây giờ tôi muốn tập trung vào hai lĩnh vực: cách nó bố trí văn bản trong khung nhìn bằng NSViewportLayoutController và cách nó thực hiện hành vi ẩn tùy chỉnh và hiển thị nhận xét.

00:32:23.000 --> 00:32:41.000
Khi trình quản lý bố cục văn bản sắp bố trí tài liệu vì nó đã thay đổi, kích thước vùng chứa đã bị thay đổi hoặc một phần chưa từng thấy trước đây của tài liệu đã được chuyển vào khung nhìn, nó sẽ gọi textViewportLayout ControllerWillLayout trên đại diện bố cục khung nhìn của nó.

00:32:41.000 --> 00:32:48.000
Chúng tôi đang sử dụng nó ở đây để xóa tất cả các lớp con văn bản và mở một giao dịch hoạt hình.

00:32:48.000 --> 00:32:57.000
Đối với mỗi phần tử văn bản mà trình quản lý bố cục văn bản đưa ra, nó gọi textViewportLayoutController, configureRenderingSurfaceFor textLayoutFragment.

00:32:57.000 --> 00:33:11.000
Ở đây chúng tôi đang nhận được một lớp để hiển thị đoạn bố cục văn bản, cập nhật hình học của nó, tạo hoạt ảnh cho nó đến vị trí mới, nếu có thể và thêm nó làm lớp con của chế độ xem.

00:33:11.000 --> 00:33:17.000
Khi trình quản lý bố cục hoàn tất việc bố trí, nó sẽ gọi textViewportLayout ControllerDidLayout.

00:33:17.000 --> 00:33:28.000
Chúng tôi cam kết giao dịch hoạt hình, cập nhật các điểm nổi bật của lựa chọn và cập nhật kích thước nội dung để ngón tay cái cuộn được đặt chính xác.

00:33:28.000 --> 00:33:30.000
Bây giờ hãy nói về những bình luận.

00:33:30.000 --> 00:33:37.000
TextKit 2 cung cấp một số móc mà bạn có thể sử dụng để tùy chỉnh phần tử bố cục và tạo đoạn bố cục.

00:33:37.000 --> 00:33:48.000
Tôi sẽ chỉ cho bạn cách chúng tôi nhận xét trong tài liệu, đặt các thuộc tính tùy chỉnh như phông chữ và màu sắc để hiển thị và vẽ bong bóng phía sau chúng.

00:33:48.000 --> 00:33:57.000
Đối với mỗi đoạn trong tài liệu, việc lưu trữ nội dung văn bản cho người đại diện của nó cơ hội tùy chỉnh các thuộc tính trên đoạn văn đó.

00:33:57.000 --> 00:34:07.000
Trong quá trình triển khai của chúng tôi, chúng tôi đang thiết lập phông chữ và màu tùy chỉnh trên nhận xét mà không cần phải thay đổi phông chữ hoặc màu sắc của bộ lưu trữ văn bản cơ bản.

00:34:07.000 --> 00:34:16.000
Trình quản lý nội dung văn bản cũng cho đại diện của mình cơ hội quyết định yếu tố văn bản nào sẽ được hiển thị cho trình quản lý bố cục văn bản trong quá trình bố cục.

00:34:16.000 --> 00:34:20.000
Trả về false cho một phần tử văn bản ngăn không cho nó được hiển thị.

00:34:20.000 --> 00:34:29.000
Ở đây chúng tôi đang ẩn các nhận xét bằng cách chọn không liệt kê chúng mà không cần phải thực sự xóa chúng khỏi bộ lưu trữ văn bản cơ bản.

00:34:29.000 --> 00:34:32.000
Trình quản lý bố cục văn bản cũng có một đại biểu.

00:34:32.000 --> 00:34:47.000
Bằng cách triển khai textLayoutManager, textLayoutFragmentFor vị trí trong textElement, đại diện có thể tạo một đoạn bố cục văn bản tùy chỉnh thay vì phiên bản NSTextLayoutFragment mặc định cho một NSTextElement nhất định.

00:34:47.000 --> 00:34:59.000
Trong trường hợp này, khi nó gặp một NSTextElement đại diện cho một nhận xét, nó sẽ tạo ra một BubbleLayoutFragment, là một lớp con tùy chỉnh của NSTextLayoutFragment.

00:34:59.000 --> 00:35:10.000
BubbleLayoutFragment ghi đè lên phương thức vẽ của NSTextLayoutFragment để vẽ bong bóng nền trước khi gọi triển khai lớp cơ sở để vẽ văn bản ở trên cùng.

00:35:10.000 --> 00:35:17.000
Lưu ý rằng văn bản đang được hiển thị với phông chữ tùy chỉnh và màu văn bản mà chúng tôi đã đặt trước đó.

00:35:17.000 --> 00:35:31.000
Tôi đã xem xét cách ứng dụng mẫu sử dụng TextKit 2 để thực hiện bố cục văn bản hoạt hình dựa trên khung nhìn và cách nó hiển thị nhận xét trong các bong bóng đầy màu sắc đó, đi từ các thuộc tính tùy chỉnh trong lưu trữ văn bản đến bản vẽ tùy chỉnh.

00:35:31.000 --> 00:35:50.000
Nhưng có rất nhiều thứ trong mã mẫu tận dụng API mới do TextKit 2 cung cấp, bao gồm diễn giải các sự kiện chuột để xác định lựa chọn văn bản, làm nổi bật lựa chọn văn bản, đặt cửa sổ bật lên nhận xét tại một đoạn cụ thể trong tài liệu và ước tính chiều cao tài liệu.

00:35:50.000 --> 00:35:54.000
Bạn có thể tìm thêm thảo luận về tất cả các chủ đề này trong mã mẫu.

00:35:54.000 --> 00:35:58.000
Hãy quay lại với Donna để nói về việc chuẩn bị ứng dụng của bạn cho TextKit 2.

00:35:58.000 --> 00:36:00.000
Cảm ơn, Chris.

00:36:00.000 --> 00:36:05.000
Đó là một ví dụ tuyệt vời về cách TextKit 2 hoạt động trong thực tế.

00:36:05.000 --> 00:36:13.000
Bây giờ chúng ta đã xem xét những gì TextKit 2 có thể làm, hãy thảo luận về một số cách tiếp cận để hiện đại hóa ứng dụng.

00:36:13.000 --> 00:36:21.000
Mọi thứ chúng ta đã nói cho đến nay đều áp dụng cho việc tạo ngăn xếp TextKit 2 của riêng bạn để sử dụng với chế độ xem hoặc lớp chung.

00:36:21.000 --> 00:36:27.000
Tất cả các lớp mới đều có sẵn trong UIKit với iOS 15 và trong AppKit với macOS 12.

00:36:27.000 --> 00:36:34.000
Vì vậy, nếu bạn muốn đi theo con đường này, bạn có thể bắt đầu viết mã mới với TextKit 2 ngay hôm nay.

00:36:34.000 --> 00:36:46.000
Mặt khác, nhiều ứng dụng sử dụng các điều khiển văn bản tích hợp, như chế độ xem văn bản, để tận dụng tất cả các chức năng tuyệt vời, miễn phí, như hỗ trợ khả năng truy cập và các dịch vụ lựa chọn và chỉnh sửa.

00:36:46.000 --> 00:36:51.000
Một số điều khiển này đã được cập nhật để sử dụng TextKit 2.

00:36:51.000 --> 00:36:57.000
Nếu ứng dụng của bạn sử dụng các điều khiển tích hợp sẵn, có một vài chi tiết bổ sung cần lưu ý.

00:36:57.000 --> 00:37:02.000
Duy trì khả năng tương thích cũng quan trọng đối với chúng tôi như đối với bạn.

00:37:02.000 --> 00:37:11.000
Vì TextKit 1 là một phần không thể thiếu của các điều khiển văn bản tích hợp, chúng tôi sẽ cố gắng hết sức để duy trì khả năng tương thích cho các ứng dụng đang sử dụng chúng.

00:37:11.000 --> 00:37:19.000
Đây là lý do tại sao chỉ một số điều khiển sử dụng TextKit 2 tự động trong iOS 15 và macOS 12.

00:37:19.000 --> 00:37:26.000
Ngoài ra, một số điều khiển yêu cầu thực hiện các bước bổ sung để sử dụng TextKit 2 trong các phiên bản hệ điều hành này.

00:37:26.000 --> 00:37:32.000
Đối với các nhà phát triển AppKit, NSTextView không tự động sử dụng TextKit 2.

00:37:32.000 --> 00:37:40.000
Nếu bạn muốn sử dụng TextKit 2 với NSTextView, bạn cần chọn tham gia theo chương trình tại thời điểm tạo.

00:37:40.000 --> 00:37:42.000
Đây là cách để làm điều đó.

00:37:42.000 --> 00:37:46.000
Đầu tiên, tạo một trình quản lý bố cục văn bản.

00:37:46.000 --> 00:37:49.000
Tiếp theo, tạo một vùng chứa văn bản.

00:37:49.000 --> 00:37:57.000
Sau đó liên kết vùng chứa văn bản với trình quản lý bố cục văn bản bằng cách sử dụng thuộc tính textContainer trên NSTextLayoutManager.

00:37:57.000 --> 00:38:05.000
Cuối cùng, tạo NSTextView của bạn bằng cách sử dụng trình khởi tạo được chỉ định với vùng chứa văn bản.

00:38:05.000 --> 00:38:08.000
Bây giờ bạn sẽ có một chế độ xem văn bản sử dụng TextKit 2.

00:38:08.000 --> 00:38:15.000
Bạn có thể truy cập trình quản lý bố cục văn bản và lưu trữ nội dung văn bản với các thuộc tính mới trên NSTextView.

00:38:15.000 --> 00:38:18.000
Chỉ có một điều cần cẩn thận.

00:38:18.000 --> 00:38:25.000
Nhớ lại rằng NSTextView có thuộc tính layoutManager cho phép lấy và đặt NSLayoutManager của nó.

00:38:25.000 --> 00:38:32.000
NSLayoutManager là một đối tượng TextKit 1 và nó không tương thích với ngăn xếp TextKit 2.

00:38:32.000 --> 00:38:39.000
Chế độ xem văn bản không thể có cả trình quản lý bố cục và trình quản lý bố cục văn bản cùng một lúc.

00:38:39.000 --> 00:38:41.000
Vậy đây là thỏa thuận.

00:38:41.000 --> 00:38:47.000
Chúng tôi đã thêm một chế độ tương thích đặc biệt cho NSTextView để chuyển nó sang TextKit 1 khi cần.

00:38:47.000 --> 00:38:56.000
Chế độ xem văn bản có thể tự động phát hiện xem nó có cần sử dụng chế độ này hay không và thay thế NSTextLayoutManager bằng NSLayoutManager.

00:38:56.000 --> 00:39:03.000
Để có hiệu suất tối ưu, chế độ xem văn bản sẽ vẫn ở chế độ tương thích từ thời điểm đó trở đi.

00:39:03.000 --> 00:39:15.000
Ngay cả khi bạn chọn tham gia TextKit 2, chế độ xem văn bản của bạn sẽ tự động chuyển sang TextKit 1 nếu bạn gọi rõ ràng thuộc tính layoutManager trên chế độ xem văn bản hoặc vùng chứa văn bản của mình.

00:39:15.000 --> 00:39:24.000
Chế độ xem văn bản cũng sẽ chuyển đổi nếu nó gặp nội dung văn bản chưa được hỗ trợ hoặc phát hiện các điều kiện khác yêu cầu TextKit 1.

00:39:24.000 --> 00:39:28.000
Và điều này cũng có thể xảy ra với các biên tập viên hiện trường.

00:39:28.000 --> 00:39:32.000
Trình chỉnh sửa trường cho NSTextField sử dụng TextKit 2 theo mặc định.

00:39:32.000 --> 00:39:45.000
Nhưng nếu lớp con trường văn bản của bạn đang yêu cầu thông tin bố cục từ trình quản lý bố cục của trình chỉnh sửa trường, trình chỉnh sửa trường sẽ chuyển sang TextKit 1 cho tất cả các trường văn bản trong cửa sổ đó.

00:39:45.000 --> 00:39:50.000
Hệ thống sẽ phát hành thông báo trước và sau khi chế độ xem văn bản chuyển sang TextKit 1.

00:39:50.000 --> 00:39:54.000
Bạn có thể quan sát những thông báo này để nhận thông tin này.

00:39:54.000 --> 00:40:00.000
Các đối tượng thông báo chứa một tham chiếu đến chế độ xem văn bản chính xác đã thay đổi chế độ.

00:40:00.000 --> 00:40:09.000
Để biết chi tiết đầy đủ về chế độ tương thích TextKit 1 cho AppKit, vui lòng tham khảo tài liệu trên cổng thông tin Nhà phát triển Apple.

00:40:09.000 --> 00:40:16.000
Đối với các nhà phát triển UIKit, UITextField sử dụng TextKit 2 tự động trong iOS 15.

00:40:16.000 --> 00:40:23.000
UITextView với TextKit 2 không khả dụng trong iOS 15.

00:40:23.000 --> 00:40:30.000
Chúng tôi đang làm việc để đảm bảo khả năng tương thích tối đa cho tất cả các ứng dụng sử dụng UITextView và có khá nhiều trong số chúng.

00:40:30.000 --> 00:40:41.000
Trong thời gian chờ đợi, bạn có thể xem lại mã hiện có của mình để sử dụng thuộc tính layoutManager của UITextView và suy nghĩ về cách thể hiện ý định của bạn với TextKit 2.

00:40:41.000 --> 00:40:45.000
Bằng cách đó, bạn sẽ sẵn sàng chuyển đổi khi nó có sẵn.

00:40:45.000 --> 00:40:47.000
Và đó là một cái bọc.

00:40:47.000 --> 00:40:52.000
Bây giờ bạn đã gặp TextKit 2, công cụ văn bản mới của Apple để đưa chúng ta vào tương lai.

00:40:52.000 --> 00:40:55.000
Chúng tôi mong muốn được thấy những gì bạn sẽ xây dựng với TextKit 2.

00:40:55.000 --> 00:40:56.000
Cảm ơn vì đã xem.

00:40:56.000 --> 23:59:59.000
[Nhạc lạc quan].

