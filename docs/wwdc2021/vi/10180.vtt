WEBVTT

00:00:00.000 --> 00:00:14.000
Xin chào, tên tôi là Tanuja, và tôi là một kỹ sư trong nhóm Hiệu suất Hệ điều hành.

00:00:14.000 --> 00:00:21.000
Hôm nay Stefan và tôi sẽ nói về cách phát hiện và chẩn đoán các vấn đề về bộ nhớ trong các ứng dụng của bạn.

00:00:21.000 --> 00:00:27.000
Chúng ta sẽ bắt đầu với việc xem xét tác động của dấu chân bộ nhớ của ứng dụng.

00:00:27.000 --> 00:00:34.000
Sau đó chúng ta sẽ nói về các công cụ để lập hồ sơ mức sử dụng bộ nhớ của bạn và các loại vấn đề về bộ nhớ mà bạn có thể gặp phải.

00:00:34.000 --> 00:00:38.000
Hãy nhảy ngay vào.

00:00:38.000 --> 00:00:44.000
Một câu hỏi bạn có thể hỏi ngay lập tức là, tại sao tôi nên quan tâm đến dấu chân bộ nhớ của ứng dụng của mình?

00:00:44.000 --> 00:00:49.000
Lý do chính là nó cải thiện trải nghiệm người dùng ứng dụng của bạn rất nhiều.

00:00:49.000 --> 00:01:00.000
Có một lượng bộ nhớ hữu hạn trên hệ thống và việc giám sát việc sử dụng bộ nhớ của ứng dụng của bạn có thể ngăn hệ thống chấm dứt ứng dụng của bạn để lấy lại bộ nhớ đó.

00:01:00.000 --> 00:01:16.000
Điều này có nghĩa là ứng dụng của bạn có thể duy trì trạng thái của nó khi ở chế độ nền, điều này thật tuyệt, bởi vì việc tải vào bộ nhớ cần có thời gian và giữ cho dấu chân bộ nhớ của bạn nhỏ gọn làm tăng cơ hội ứng dụng của bạn còn lại trong bộ nhớ, dẫn đến kích hoạt ứng dụng nhanh hơn.

00:01:16.000 --> 00:01:26.000
Giảm sử dụng bộ nhớ của bạn cũng dẫn đến trải nghiệm năng động, đáp ứng, đó chính xác là những gì người dùng của bạn muốn khi họ khám phá các tính năng mới của bạn.

00:01:26.000 --> 00:01:36.000
Bằng cách có chiến lược về những gì ứng dụng của bạn đã tải vào bộ nhớ, ứng dụng của bạn có thể tránh được chi phí chờ đợi để lấy lại bộ nhớ khi người dùng tương tác với ứng dụng của bạn.

00:01:36.000 --> 00:01:48.000
Chiến lược về việc sử dụng bộ nhớ của bạn cũng mở ra cánh cửa cho một loạt các tính năng hơn mà bạn có thể thêm vào ứng dụng của mình, chẳng hạn như tải video, bao gồm cả hoạt ảnh và hơn thế nữa.

00:01:48.000 --> 00:01:56.000
Cuối cùng, các thiết bị của chúng tôi không ngừng phát triển theo thời gian và các thiết bị mới hơn của chúng tôi có nhiều bộ nhớ vật lý hơn trước.

00:01:56.000 --> 00:02:05.000
Bằng cách giảm dung lượng bộ nhớ của bạn, ứng dụng của bạn sẽ hoạt động tốt trên các thiết bị cũ hơn, tăng lượng khán giả có thể thưởng thức ứng dụng của bạn.

00:02:05.000 --> 00:02:15.000
Bằng cách theo dõi dấu chân bộ nhớ của ứng dụng, ứng dụng của bạn sẽ kích hoạt nhanh hơn, phản hồi nhanh hơn, xử lý các tính năng phức tạp và hoạt động trên nhiều loại thiết bị hơn.

00:02:15.000 --> 00:02:20.000
Bây giờ chúng ta hãy xem điều gì tạo nên dấu chân trí nhớ của bạn.

00:02:20.000 --> 00:02:27.000
Có ba loại chúng tôi sử dụng để chia nhỏ hồ sơ bộ nhớ ứng dụng của bạn: bộ nhớ bẩn, nén và sạch.

00:02:27.000 --> 00:02:31.000
Chúng ta hãy xem nhanh mỗi thứ này bao gồm những gì.

00:02:31.000 --> 00:02:35.000
Bộ nhớ bẩn bao gồm bộ nhớ được viết bởi ứng dụng của bạn.

00:02:35.000 --> 00:02:44.000
Nó cũng bao gồm tất cả các phân bổ đống như khi bạn sử dụng malloc, bộ đệm hình ảnh được giải mã và các khuôn khổ.

00:02:44.000 --> 00:02:52.000
Bộ nhớ nén đề cập đến bất kỳ trang bẩn nào chưa được truy cập gần đây mà máy nén bộ nhớ đã nén.

00:02:52.000 --> 00:02:56.000
Những trang này sẽ được giải nén khi truy cập.

00:02:56.000 --> 00:03:03.000
Lưu ý rằng chúng tôi không có khái niệm hoán đổi trên iOS, điều này dành riêng cho macOS.

00:03:03.000 --> 00:03:05.000
Và cuối cùng, chúng ta có trí nhớ trong sạch.

00:03:05.000 --> 00:03:10.000
Bộ nhớ sạch là bộ nhớ chưa được ghi vào hoặc dữ liệu có thể được phân trang.

00:03:10.000 --> 00:03:16.000
Ví dụ, đây có thể là các tệp được ánh xạ bộ nhớ như hình ảnh trên đĩa nhưng được tải vào bộ nhớ.

00:03:16.000 --> 00:03:20.000
Hoặc chúng có thể là khuôn khổ.

00:03:20.000 --> 00:03:27.000
Khi chúng tôi tham khảo dấu chân bộ nhớ của ứng dụng của bạn, chúng tôi thực sự đang nói về bộ nhớ bẩn và bộ nhớ nén của ứng dụng của bạn với nhau.

00:03:27.000 --> 00:03:31.000
Bộ nhớ sạch không được tính ở đây.

00:03:31.000 --> 00:03:34.000
Đây là một sự hiểu biết cấp cao về dấu chân bộ nhớ của bạn.

00:03:34.000 --> 00:03:43.000
Để có lời giải thích chi tiết, chuyên sâu hơn, chúng tôi khuyên bạn nên xem bài nói chuyện sâu về bộ nhớ iOS từ WWDC 2018.

00:03:43.000 --> 00:03:49.000
Bây giờ chúng ta hãy xem các công cụ bạn có thể sử dụng để lập hồ sơ dấu chân bộ nhớ của mình.

00:03:49.000 --> 00:03:58.000
Xcode cung cấp một bộ công cụ để giúp giám sát hiệu suất bộ nhớ của ứng dụng của bạn trong suốt cả quy trình phát triển và sản xuất.

00:03:58.000 --> 00:04:12.000
Khung XCTest giúp bạn giám sát dấu chân bộ nhớ của mình trực tiếp trong các bài kiểm tra đơn vị và giao diện người dùng của dự án, trong khi MetricKit và Xcode Organizer cho phép bạn theo dõi các chỉ số bộ nhớ trong quá trình sản xuất từ khách hàng của mình.

00:04:12.000 --> 00:04:16.000
Sự tiếp nối của cuộc nói chuyện này sẽ nằm trong bối cảnh sử dụng XCTests hiệu suất.

00:04:16.000 --> 00:04:23.000
Nhưng lưu ý rằng những kỹ thuật này vẫn áp dụng cho việc phân loại và điều tra trí nhớ chung.

00:04:23.000 --> 00:04:32.000
Sử dụng XCTests hiệu suất, bạn có thể đo lường các tài nguyên hệ thống như sử dụng bộ nhớ, sử dụng CPU, ghi đĩa và hơn thế nữa.

00:04:32.000 --> 00:04:37.000
Chúng ta hãy cùng nhau xem xét một bài kiểm tra ví dụ.

00:04:37.000 --> 00:04:52.000
Giả sử tôi là nhà phát triển ứng dụng tại Meal Planner, một ứng dụng giúp bạn sắp xếp những gì bạn sẽ ăn trong một tuần và tôi muốn đo lường mức sử dụng bộ nhớ của tính năng lưu bữa ăn mới này mà tôi đã thêm vào cho phép người dùng tải công thức xuống thiết bị của họ.

00:04:52.000 --> 00:05:03.000
Trong bài kiểm tra hiệu suất của mình, tôi đang sử dụng API đo lường (số liệu: tùy chọn: khối:) và tôi chỉ định rằng tôi muốn đo lường việc sử dụng bộ nhớ của ứng dụng được nhắm mục tiêu của mình.

00:05:03.000 --> 00:05:14.000
Trong phần thân của khối đo lường, tôi đang khởi chạy ứng dụng, yêu cầu API đo lường theo cách thủ công để bắt đầu đo lường, sau đó nhấn vào nút lưu bữa ăn.

00:05:14.000 --> 00:05:22.000
Tôi đợi tối đa 30 giây để tải xuống công thức hoàn tất bằng cách kiểm tra bản cập nhật trong giao diện người dùng.

00:05:22.000 --> 00:05:28.000
Bây giờ tôi có thể chạy bài kiểm tra này trực tiếp trong giao diện người dùng của Xcode để xem các phép đo của tôi.

00:05:28.000 --> 00:05:32.000
Tôi có thể truy cập số đo của mình bằng cách nhấp vào viên kim cương màu xám bên cạnh bài kiểm tra của mình.

00:05:32.000 --> 00:05:39.000
Giao diện người dùng bật lên kết quả có một trình đơn thả xuống cho tôi biết số liệu nào đã được đo.

00:05:39.000 --> 00:05:45.000
Biểu đồ thanh ở phía dưới cho tôi thấy các phép đo cho từng lần lặp riêng lẻ.

00:05:45.000 --> 00:05:50.000
Trung bình của tất cả năm lần lặp được tính toán và hiển thị.

00:05:50.000 --> 00:05:59.000
Bây giờ tôi có thể quyết định xem tôi có muốn đặt mức trung bình của lần chạy này làm cơ sở cho các bài kiểm tra trong tương lai được so sánh hay không.

00:05:59.000 --> 00:06:04.000
Một lần chạy thử nghiệm trong tương lai bây giờ sẽ thất bại nếu mức trung bình của nó lớn hơn đường cơ sở đã đặt.

00:06:04.000 --> 00:06:09.000
Chúng tôi gọi độ lệch này so với đường cơ sở đã đặt là hồi quy.

00:06:09.000 --> 00:06:18.000
Hồi quy chỉ ra rằng chúng ta nên dừng lại, điều tra và sửa mã của mình để đảm bảo rằng bài kiểm tra vượt qua.

00:06:18.000 --> 00:06:26.000
Chúng tôi rất vui mừng được chia sẻ rằng trong Xcode 13, chúng tôi đã thêm vào một tính năng mới để thu thập các chẩn đoán nhằm giúp phân loại các hồi quy kiểm tra này.

00:06:26.000 --> 00:06:34.000
Có hai chẩn đoán mà chúng tôi thấy có giá trị: tệp ktrace và biểu đồ bộ nhớ.

00:06:34.000 --> 00:06:37.000
Các tệp Ktrace rất mạnh mẽ và linh hoạt.

00:06:37.000 --> 00:06:52.000
Chúng có thể được sử dụng để điều tra hệ thống chung hoặc chúng có thể tập trung vào các vấn đề cụ thể, chẳng hạn như đi sâu vào đường ống kết xuất khi điều tra các trở ngại hoặc xem xét lý do tại sao luồng chính của bạn có thể bị chặn, dẫn đến treo.

00:06:52.000 --> 00:06:59.000
Các tệp ktrace này có thể được mở và phân tích trong Công cụ bằng quy trình làm việc thông thường của bạn.

00:06:59.000 --> 00:07:04.000
Chẩn đoán thứ hai là một biểu đồ bộ nhớ rất tốt cho các cuộc điều tra cụ thể về bộ nhớ.

00:07:04.000 --> 00:07:15.000
Biểu đồ bộ nhớ có thể được sử dụng với trình gỡ lỗi trực quan của Xcode cũng như nhiều công cụ dòng lệnh, một số trong đó chúng ta sẽ đề cập sau trong buổi nói chuyện này.

00:07:15.000 --> 00:07:21.000
Biểu đồ bộ nhớ về cơ bản là ảnh chụp nhanh không gian địa chỉ quy trình của bạn tại một phiên bản kịp thời.

00:07:21.000 --> 00:07:32.000
Memgraphs ghi lại địa chỉ và kích thước của từng vùng bộ nhớ ảo và từng khối malloc được phân bổ, cũng như các con trỏ giữa các vùng và khối đó.

00:07:32.000 --> 00:07:40.000
Điều này cho phép bạn kiểm tra các đối tượng riêng lẻ trên đống, xem các vùng dữ liệu được liên kết với các khung được liên kết và hơn thế nữa.

00:07:40.000 --> 00:07:49.000
XCTest tự động cho phép ghi nhật ký ngăn xếp malloc, ghi lại dấu vết ngược cho các đối tượng mới được phân bổ.

00:07:49.000 --> 00:07:58.000
Để cho phép thu thập chẩn đoán, hãy sử dụng công cụ dòng lệnh xcodebuild kết hợp với cờ enablePerformanceTestsDiagnostics.

00:07:58.000 --> 00:08:06.000
Cờ này sẽ cho phép thu thập ktrace cho các số liệu không phải bộ nhớ và đồ thị cho các số liệu bộ nhớ.

00:08:06.000 --> 00:08:12.000
Khi bài kiểm tra hiệu suất bằng văn bản trước đây của chúng tôi đã chạy xong, chúng tôi sẽ thấy phần sau được in vào bảng điều khiển của chúng tôi.

00:08:12.000 --> 00:08:17.000
Điều này khá nhiều, nhưng có một vài điều quan trọng cần tìm kiếm.

00:08:17.000 --> 00:08:21.000
Điều đầu tiên cần tìm là nếu bài kiểm tra thất bại hoặc vượt qua.

00:08:21.000 --> 00:08:25.000
Trong trường hợp này, bài kiểm tra đã thất bại.

00:08:25.000 --> 00:08:30.000
Đầu ra cũng cho biết rằng bài kiểm tra đã thất bại cụ thể do hồi quy.

00:08:30.000 --> 00:08:35.000
Mức trung bình mới của chúng tôi kém hơn 12% so với đường cơ sở của chúng tôi.

00:08:35.000 --> 00:08:40.000
Cuối cùng, chúng ta có thể tìm thấy đường dẫn đến gói xcresult của mình.

00:08:40.000 --> 00:08:49.000
Khi chúng tôi mở gói xcresult trong Xcode, chúng tôi sẽ thấy các phép đo bộ nhớ ở trên cùng bên cạnh tên bài kiểm tra.

00:08:49.000 --> 00:08:57.000
Sau đó, chúng tôi có thể mở rộng nhật ký kiểm tra và về phía dưới cùng, chúng tôi có thể tìm thấy các biểu đồ đính kèm của mình.

00:08:57.000 --> 00:09:00.000
Sau khi tải xuống và giải nén, chúng tôi tìm thấy 2 memgraphs.

00:09:00.000 --> 00:09:07.000
Điều này là do chúng tôi thêm một lần lặp lại bổ sung vào bài kiểm tra của bạn để cho phép ghi nhật ký ngăn xếp malloc.

00:09:07.000 --> 00:09:17.000
Chúng tôi thu thập một memgraph ban đầu, có tiền tố pre, ở đầu lần lặp đo được, và chúng tôi thu thập một memgraph thứ hai, có tiền tố post, ở cuối lần lặp.

00:09:17.000 --> 00:09:25.000
Điều này cho phép bạn phân tích sự phát triển bộ nhớ trong khoảng thời gian của một lần lặp lại nếu cần.

00:09:25.000 --> 00:09:35.000
Bây giờ với các tệp ktrace và biểu đồ bộ nhớ với tính năng ghi nhật ký ngăn xếp malloc được bật, bạn sẵn sàng không chỉ trả lời nếu hồi quy xảy ra mà còn tại sao hồi quy lại xảy ra?

00:09:35.000 --> 00:09:45.000
Bây giờ tôi sẽ giao nó cho đồng nghiệp của tôi, Stefan, để nói về các loại vấn đề về trí nhớ mà bạn có thể gặp phải khi xem xét các chẩn đoán memgraph đã thu thập được của mình.

00:09:45.000 --> 00:09:48.000
Cảm ơn, Tanuja. Xin chào mọi người.

00:09:48.000 --> 00:09:50.000
Tôi là Stefan, một kỹ sư trong Nhóm Hiệu suất Hệ điều hành.

00:09:50.000 --> 00:10:00.000
Tôi sẽ xem xét một số vấn đề bộ nhớ phổ biến mà bạn có thể tìm thấy trong ứng dụng của mình cũng như cách bạn có thể chẩn đoán, khắc phục và ngăn chặn chúng.

00:10:00.000 --> 00:10:09.000
Tôi sẽ xem xét hai loại vấn đề bộ nhớ: rò rỉ và vấn đề đống, có thể được chia thành hồi quy phân bổ đống và vấn đề phân mảnh.

00:10:09.000 --> 00:10:14.000
Đây không phải là một danh sách đầy đủ, nhưng nó bao gồm một số vấn đề phổ biến nhất.

00:10:14.000 --> 00:10:19.000
Tôi cũng sẽ đề cập đến một số quy trình làm việc dòng lệnh có thể được sử dụng để chẩn đoán những vấn đề này.

00:10:19.000 --> 00:10:27.000
Để có bản tóm tắt chuyên sâu hơn về các công cụ dòng lệnh, hãy xem cuộc nói chuyện sâu về bộ nhớ iOS từ WWDC 2018.

00:10:27.000 --> 00:10:31.000
Hãy bắt đầu bằng cách thảo luận về rò rỉ bộ nhớ.

00:10:31.000 --> 00:10:38.000
Rò rỉ xảy ra khi quá trình phân bổ một đối tượng và mất tất cả các tham chiếu đến nó mà không bao giờ phân bổ nó.

00:10:38.000 --> 00:10:43.000
Ở đây tôi có một biểu đồ đối tượng ví dụ, trong đó các mũi tên màu xám biểu thị các tham chiếu giữa các đối tượng.

00:10:43.000 --> 00:10:47.000
Lưu ý rằng mọi đối tượng đều có ít nhất một tham chiếu đến nó.

00:10:47.000 --> 00:10:51.000
Chú ý tham chiếu đường chấm từ đối tượng A đến đối tượng B.

00:10:51.000 --> 00:10:55.000
Giả sử tôi đặt tham chiếu này thành nil, loại bỏ nó.

00:10:55.000 --> 00:10:58.000
Với tham chiếu đó biến mất, đối tượng B đã bị rò rỉ.

00:10:58.000 --> 00:11:00.000
Không có tài liệu tham khảo nào về nó cả.

00:11:00.000 --> 00:11:06.000
Nó vẫn bẩn, nhưng quá trình này không có cách nào để tham khảo nó và không có cách nào để giải phóng nó cho đến khi nó thoát ra.

00:11:06.000 --> 00:11:11.000
Vì lý do này, bạn nên luôn luôn sửa chữa rò rỉ.

00:11:11.000 --> 00:11:14.000
Một cách phổ biến mà các đối tượng bị rò rỉ trong Swift là thông qua các chu kỳ giữ lại.

00:11:14.000 --> 00:11:18.000
Trong sơ đồ này, các đối tượng A và B đang trong một chu kỳ giữ lại.

00:11:18.000 --> 00:11:23.000
Họ tham chiếu lẫn nhau, nhưng không có tham chiếu bên ngoài nào cho một trong hai người họ.

00:11:23.000 --> 00:11:29.000
Điều này có nghĩa là quá trình không thể truy cập hoặc giải phóng một trong hai chúng, vì vậy chúng được coi là bị rò rỉ.

00:11:29.000 --> 00:11:37.000
May mắn thay, hầu hết các đối tượng trong Swift được quản lý bởi hệ thống đếm tham chiếu tự động của Swift, hoặc ARC, ngăn chặn rất nhiều rò rỉ.

00:11:37.000 --> 00:11:46.000
Nếu bạn đang làm việc với các đối tượng không được ARC quản lý, chẳng hạn như con trỏ không an toàn, hãy đảm bảo rằng bạn phân bổ chúng trước khi mất tài liệu tham khảo về chúng.

00:11:46.000 --> 00:11:51.000
Ngay cả các đối tượng được quản lý ARC cũng dễ bị trở thành một phần của chu kỳ lưu giữ.

00:11:51.000 --> 00:11:54.000
Vì vậy, tránh tạo các tham chiếu vòng tròn mạnh mẽ trong mã của bạn.

00:11:54.000 --> 00:12:04.000
Nếu một tham chiếu tròn là hoàn toàn cần thiết, thay vào đó hãy xem xét một tham chiếu yếu, bởi vì các tham chiếu yếu sẽ không ngăn các đối tượng được phân bổ.

00:12:04.000 --> 00:12:07.000
Hãy xem một ví dụ từ ứng dụng Meal Planner.

00:12:07.000 --> 00:12:12.000
Tanuja đã gửi cho tôi một số bản ghi nhớ trước và sau từ XCTest thất bại.

00:12:12.000 --> 00:12:17.000
Ngay lập tức, tôi muốn kiểm tra rò rỉ trong biểu đồ bài đăng.

00:12:17.000 --> 00:12:20.000
Để làm điều này, tôi chạy rò rỉ trên memgraph.

00:12:20.000 --> 00:12:26.000
Điều này cho tôi thấy một số thông tin hữu ích về bất kỳ rò rỉ nào tôi có.

00:12:26.000 --> 00:12:32.000
Đầu ra cho thấy tôi có 4 rò rỉ với tổng số 240 byte bị rò rỉ.

00:12:32.000 --> 00:12:41.000
Xa hơn nữa, đầu ra bao gồm một cái nhìn chi tiết về biểu đồ đối tượng cho mỗi rò rỉ, điều này cung cấp cho tôi một số manh mối về những gì có thể bị rò rỉ.

00:12:41.000 --> 00:12:47.000
Phần trên cùng của biểu đồ đối tượng cho biết ROOT CYCLE, có nghĩa là tôi đang xử lý một chu kỳ giữ lại.

00:12:47.000 --> 00:12:49.000
Có một số biểu tượng hữu ích ở đây.

00:12:49.000 --> 00:12:56.000
Có vẻ như chu kỳ lưu giữ này có thể bao gồm kế hoạch bữa ăn và các đối tượng món trong thực đơn.

00:12:56.000 --> 00:13:02.000
Bởi vì ghi nhật ký ngăn xếp malloc được bật cho XCTests, đầu ra cũng bao gồm ngăn xếp cuộc gọi phân bổ cho mỗi lần rò rỉ.

00:13:02.000 --> 00:13:07.000
Điều này cực kỳ hữu ích cho việc tìm kiếm những đồ vật nào bị rò rỉ.

00:13:07.000 --> 00:13:12.000
Thông thường, bạn sẽ muốn tìm phần của ngăn xếp cuộc gọi với các ký hiệu từ mã của bạn.

00:13:12.000 --> 00:13:16.000
Đây là phần ngăn xếp cuộc gọi từ mã của tôi.

00:13:16.000 --> 00:13:21.000
Đối tượng kế hoạch bữa ăn bị rò rỉ được phân bổ trong hàm populateMealData.

00:13:21.000 --> 00:13:25.000
Tôi sẽ mở Xcode và xem liệu tôi có thể khắc phục sự cố hay không.

00:13:25.000 --> 00:13:28.000
Đây là hàm populateMealData mà tôi đã thấy trong rò rỉ.

00:13:28.000 --> 00:13:35.000
Ở đây tôi đang phân bổ một đối tượng kế hoạch bữa ăn và một đối tượng mục thực đơn, đó là hai đối tượng tôi đã thấy trong chu kỳ lưu giữ của mình.

00:13:35.000 --> 00:13:39.000
Hmm, chức năng addMealToMealPlan này có vẻ hơi đáng ngờ.

00:13:39.000 --> 00:13:41.000
Tôi sẽ xem qua.

00:13:41.000 --> 00:13:48.000
Hmm, có vẻ như tôi đang gọi addItem trong kế hoạch bữa ăn, nhưng tôi cũng đang gọi addPlan trên mục thực đơn.

00:13:48.000 --> 00:13:56.000
Đây là một tính năng cho phép chúng tôi xem tất cả các mục cho một kế hoạch nhưng cũng là kế hoạch nào mà một mục được liên kết.

00:13:56.000 --> 00:14:01.000
Ở đây trong kế hoạch bữa ăn, addItem thêm mục menu vào một mảng, lưu một tham chiếu đến nó.

00:14:01.000 --> 00:14:06.000
Và ở đây trong mục thực đơn, addPlan lưu một tham chiếu đến kế hoạch bữa ăn.

00:14:06.000 --> 00:14:11.000
Vì vậy, đây chắc chắn là một chu kỳ lưu giữ bởi vì cả hai đều có liên quan chặt chẽ đến nhau.

00:14:11.000 --> 00:14:20.000
Sau khi populateMealData thoát ra, cả kế hoạch bữa ăn và các đối tượng mục thực đơn sẽ nằm ngoài phạm vi, vì vậy sẽ không có tham chiếu bên ngoài nào đến chúng.

00:14:20.000 --> 00:14:24.000
Nhưng họ vẫn tham khảo lẫn nhau, gây ra rò rỉ.

00:14:24.000 --> 00:14:28.000
Có lẽ tôi nên cố gắng tìm ra giải pháp mà không có tham chiếu theo chu kỳ.

00:14:28.000 --> 00:14:34.000
Nhưng để khắc phục nhanh chóng bây giờ, tôi sẽ thay đổi mục thực đơn để sử dụng tham chiếu yếu cho đối tượng kế hoạch bữa ăn của nó.

00:14:34.000 --> 00:14:43.000
Điều này phá vỡ chu kỳ lưu giữ bởi vì chúng ta không còn hai tham chiếu mạnh theo chu kỳ nữa.

00:14:43.000 --> 00:14:47.000
Hãy chuyển số ngay bây giờ để tích hợp hồi quy phân bổ.

00:14:47.000 --> 00:14:53.000
Đống chỉ đơn giản là một phần trong không gian địa chỉ quy trình của bạn, nơi các đối tượng được phân bổ động được lưu trữ.

00:14:53.000 --> 00:15:00.000
Hồi quy phân bổ đống là sự gia tăng dấu chân bộ nhớ do quá trình phân bổ nhiều đối tượng trên đống hơn trước.

00:15:00.000 --> 00:15:07.000
Để giảm hồi quy đống, hãy tìm cách loại bỏ các phân bổ không sử dụng và thu nhỏ các phân bổ lớn không cần thiết.

00:15:07.000 --> 00:15:11.000
Bạn cũng nên chú ý đến lượng bộ nhớ bạn lưu giữ cùng một lúc.

00:15:11.000 --> 00:15:15.000
Phân bổ bộ nhớ bạn không còn sử dụng nữa và đợi để phân bổ bộ nhớ cho đến khi bạn cần nó.

00:15:15.000 --> 00:15:21.000
Điều này sẽ làm giảm dấu chân đỉnh của ứng dụng của bạn, khiến nó ít có khả năng bị chấm dứt hơn.

00:15:21.000 --> 00:15:27.000
Vì vậy, bây giờ chúng ta hãy quay lại XCTest thất bại từ ứng dụng MealPlanner và kiểm tra hồi quy đống.

00:15:27.000 --> 00:15:37.000
Để hiểu nơi tôi nên tìm, tôi sẽ chạy vmmap -summary trên cả memgraph trước và sau để có cái nhìn tổng quan tốt về nơi bộ nhớ đang được sử dụng.

00:15:37.000 --> 00:15:42.000
Dấu chân của tôi trong sơ đồ là khoảng 112 megabyte.

00:15:42.000 --> 00:15:50.000
Và trong biểu đồ bài đăng, dấu chân của tôi là 125 megabyte, vì vậy đó là khoảng sự khác biệt 13 megabyte.

00:15:50.000 --> 00:15:56.000
Xa hơn nữa, đầu ra cho thấy việc sử dụng bộ nhớ của quy trình của tôi được chia nhỏ theo khu vực.

00:15:56.000 --> 00:16:05.000
Bởi vì tôi nghi ngờ đây là vấn đề phân bổ đống, tôi muốn xem xét các khu vực bắt đầu bằng MALLOC_ bởi vì những khu vực đó chứa tất cả các đối tượng đống của tôi.

00:16:05.000 --> 00:16:11.000
Hãy nhớ phương trình của Tanuja: Dấu chân bộ nhớ = Bộ nhớ bẩn + Bộ nhớ nén.

00:16:11.000 --> 00:16:14.000
Trong công cụ này, thuật ngữ "swapped" có nghĩa là "nén".

00:16:14.000 --> 00:16:19.000
Vì vậy, trong số các cột này, tôi chỉ quan tâm đến "kích thước bẩn" và "kích thước hoán đổi".

00:16:19.000 --> 00:16:25.000
Và chắc chắn, đầu ra cho thấy vùng MALLOC_LARGE đang chứa khoảng 13 megabyte bộ nhớ bẩn.

00:16:25.000 --> 00:16:29.000
Điều đó gần tương đương với kích thước hồi quy của tôi, vì vậy tôi chắc chắn muốn xem xét điều đó.

00:16:29.000 --> 00:16:35.000
Bước tiếp theo là tìm ra loại đối tượng nào đang góp phần vào hồi quy 13 megabyte này.

00:16:35.000 --> 00:16:41.000
Để có được thông tin đó, tôi sẽ chạy heap -diffFrom trên memgraph bài đăng của mình.

00:16:41.000 --> 00:16:44.000
Tôi vượt qua trước của mình và đăng các memgraph dưới dạng lập luận.

00:16:44.000 --> 00:16:50.000
Điều này cho tôi thấy các đối tượng tồn tại trong đống memgraph bài đăng nhưng không phải trong đống memgraph trước.

00:16:50.000 --> 00:16:57.000
Gần đỉnh, đầu ra cho thấy tôi có khoảng 13 megabyte đối tượng mới trong biểu đồ bài đăng.

00:16:57.000 --> 00:17:01.000
Bên dưới, bộ nhớ đống được chia nhỏ theo lớp đối tượng.

00:17:01.000 --> 00:17:08.000
Đối với mỗi lớp đối tượng, đầu ra hiển thị số lượng đối tượng và tổng tính bằng byte của các đối tượng đó.

00:17:08.000 --> 00:17:13.000
Ngay lập tức, tôi nhận thấy rằng tôi có khoảng 13 megabyte giá trị của loại "không phải đối tượng" này.

00:17:13.000 --> 00:17:16.000
Trong Swift, điều này thường chỉ ra các byte malloced thô.

00:17:16.000 --> 00:17:23.000
Loại đối tượng này có thể hơi khó theo dõi, nhưng có một số công cụ tôi có thể sử dụng để lấy một số thông tin.

00:17:23.000 --> 00:17:27.000
Để bắt đầu, tôi muốn địa chỉ của những đối tượng không phải này.

00:17:27.000 --> 00:17:32.000
Tôi sẽ chạy đống địa chỉ để lấy chúng.

00:17:32.000 --> 00:17:37.000
Tôi sẽ chỉ rõ rằng tôi chỉ muốn những vật không phải vật có kích thước ít nhất là 500 kilobyte.

00:17:37.000 --> 00:17:39.000
Aha.

00:17:39.000 --> 00:17:44.000
Vật thể không phải này có kích hoạt khoảng 13 megabyte, vì vậy nó là nghi phạm chính trong cuộc điều tra này.

00:17:44.000 --> 00:17:48.000
Tôi sẽ lấy địa chỉ của nó và xem liệu tôi có thể tìm thấy một số manh mối về nó là gì không.

00:17:48.000 --> 00:17:50.000
Tôi có một vài lựa chọn vào thời điểm này.

00:17:50.000 --> 00:17:56.000
Mỗi cái đều có lợi ích của nó tùy thuộc vào tình huống, vì vậy tôi sẽ xem qua từng cái một cách ngắn gọn.

00:17:56.000 --> 00:18:01.000
Một lựa chọn tôi có là chạy rò rỉ --traceTree trên địa chỉ này.

00:18:01.000 --> 00:18:04.000
Điều này cho tôi một cây các đối tượng tham chiếu đến địa chỉ này.

00:18:04.000 --> 00:18:14.000
Điều này rất hữu ích nếu tôi có một đối tượng cụ thể mà tôi muốn biết thêm thông tin và memgraph của tôi không bật ghi nhật ký ngăn xếp malloc hoặc MSL.

00:18:14.000 --> 00:18:23.000
Hãy nhớ rằng các memgraph XCTest của chúng tôi tự động bật MSL, nhưng nếu bạn đang làm việc với một memgraph không có, hãy ghi nhớ công cụ này.

00:18:23.000 --> 00:18:26.000
Tôi đã đánh dấu đối tượng trong cây có vẻ có liên quan.

00:18:26.000 --> 00:18:33.000
Đối tượng không lớn của tôi có thể liên quan đến đối tượng dữ liệu bữa ăn này trong MKTCustomMeal PlannerCollectionViewCell.

00:18:33.000 --> 00:18:42.000
Tôi cũng có thể chạy rò rỉ --referenceTree.

00:18:42.000 --> 00:18:49.000
Điều này cung cấp cho tôi một cây tham chiếu từ trên xuống của tất cả bộ nhớ trong quá trình của tôi với dự đoán tốt nhất về đối tượng nào là gốc rễ.

00:18:49.000 --> 00:18:53.000
Với đầu ra này, tôi có thể hiểu được nơi bộ nhớ được tổng hợp trong ứng dụng của mình.

00:18:53.000 --> 00:19:01.000
Công cụ này cực kỳ hữu ích nếu tôi biết tôi có hồi quy lớn nhưng tôi không biết đối tượng cụ thể nào chịu trách nhiệm.

00:19:01.000 --> 00:19:10.000
Tôi có thể chuyển đối số --groupByType để nhóm các loại giống nhau lại với nhau, thu nhỏ đầu ra và giúp phân tích cú pháp dễ dàng hơn một chút.

00:19:10.000 --> 00:19:19.000
Thông thường, một phần lớn hồi quy sẽ được nhóm lại dưới một nút duy nhất trong cây này, giúp dễ dàng tìm thấy manh mối về bộ nhớ đó là gì.

00:19:19.000 --> 00:19:23.000
Một lần nữa, tôi đã đánh dấu phần hiển thị các đối tượng có liên quan.

00:19:23.000 --> 00:19:28.000
Đây là cùng một đối tượng dữ liệu bữa ăn mà tôi đã thấy trong đầu ra rò rỉ -traceTree.

00:19:28.000 --> 00:19:33.000
Đầu ra cho thấy có khoảng 13 megabyte bộ nhớ được phân bổ cho đối tượng dữ liệu bữa ăn này.

00:19:33.000 --> 00:19:36.000
Tôi rất muốn biết đối tượng này đang được phân bổ như thế nào.

00:19:36.000 --> 00:19:44.000
Bởi vì memgraph của tôi đã bật MSL, tôi có thể sử dụng malloc_history -fullStacks để tìm ra điều đó.

00:19:44.000 --> 00:19:50.000
Tôi đi qua địa chỉ của vật thể không lớn mà tôi đã lấy từ đống địa chỉ trước đó.

00:19:50.000 --> 00:19:53.000
Và tôi nhận được một ngăn xếp cuộc gọi phân bổ cho đối tượng tại địa chỉ đó.

00:19:53.000 --> 00:20:01.000
Điều này cực kỳ hữu ích khi tôi bật MSL và tôi có địa chỉ của đối tượng mà tôi quan tâm.

00:20:01.000 --> 00:20:07.000
Vì vậy, có vẻ như đối tượng dữ liệu bữa ăn của tôi đã được phân bổ trong hàm saveMeal, được hiển thị ở đây trên dòng 3.

00:20:07.000 --> 00:20:10.000
Tôi sẽ đến Xcode để xem chuyện gì đang xảy ra.

00:20:10.000 --> 00:20:14.000
Đây là chức năng saveMeal bên trong bộ điều khiển chế độ xem ô tùy chỉnh của tôi.

00:20:14.000 --> 00:20:16.000
Và đây là thủ phạm.

00:20:16.000 --> 00:20:20.000
Tôi đang phân bổ bộ đệm thô này ở đây và sau đó gói nó với đối tượng dữ liệu bữa ăn.

00:20:20.000 --> 00:20:25.000
Tôi chỉ phân bổ bộ đệm này để tôi có thể điền nó và lưu kết quả vào đĩa.

00:20:25.000 --> 00:20:29.000
Khi tôi lưu xong vào đĩa, tôi không thực sự cần bộ đệm này nữa.

00:20:29.000 --> 00:20:32.000
Vậy tại sao nó lại dính xung quanh?

00:20:32.000 --> 00:20:39.000
Chà, dữ liệu bữa ăn là một thành viên lớp, vì vậy miễn là trường hợp lớp này tồn tại, tài liệu tham khảo sẽ tồn tại.

00:20:39.000 --> 00:20:46.000
Điều này có nghĩa là khi tôi nhấn saveMeal trên bất kỳ ô nào, ô đó sẽ phân bổ và giữ một bộ đệm lớn sẽ tồn tại cho đến khi ô đó bị phá hủy.

00:20:46.000 --> 00:20:51.000
Ký ức đó thực sự có thể tăng lên nếu tôi tiết kiệm nhiều bữa ăn.

00:20:51.000 --> 00:20:53.000
Vậy làm thế nào tôi có thể khắc phục điều này?

00:20:53.000 --> 00:21:01.000
Một lựa chọn sẽ là chỉ xác định mealData trong hàm saveMeal, nhưng tôi biết nó được sử dụng ở những nơi khác trong lớp, vì vậy tôi không muốn làm điều đó.

00:21:01.000 --> 00:21:06.000
Một cách khác là đặt mealData thành nil sau khi tôi ghi xong vào đĩa.

00:21:06.000 --> 00:21:18.000
Đối tượng dữ liệu trong Swift đủ thông minh để tự động phân bổ bộ đệm khi tôi mất tham chiếu cuối cùng của mình với nó, vì vậy bộ đệm sẽ không tồn tại qua phần cuối của chức năng này.

00:21:18.000 --> 00:21:24.000
Cuối cùng, hãy nói về sự phân mảnh.

00:21:24.000 --> 00:21:27.000
Hãy nhanh chóng xem qua cách các trang hoạt động trong iOS.

00:21:27.000 --> 00:21:33.000
Một trang là một kích thước cố định, khối bộ nhớ không thể phân chia mà hệ thống cấp cho quy trình của bạn.

00:21:33.000 --> 00:21:44.000
Bởi vì các trang không thể phân chia, khi quy trình của bạn ghi vào bất kỳ phần nào của trang, toàn bộ trang được coi là bẩn và quy trình của bạn sẽ bị tính phí cho nó, ngay cả khi hầu hết nó không được sử dụng.

00:21:44.000 --> 00:21:50.000
Sự phân mảnh xảy ra khi một quy trình có các trang bẩn không được sử dụng 100%.

00:21:50.000 --> 00:21:53.000
Để hiểu điều này xảy ra như thế nào, hãy xem xét một ví dụ.

00:21:53.000 --> 00:21:58.000
Để bắt đầu, tôi có 3 trang sạch liền kề nhau.

00:21:58.000 --> 00:22:05.000
Khi quá trình diễn ra, việc phân bổ bắt đầu lấp đầy các trang này, làm bẩn chúng.

00:22:05.000 --> 00:22:12.000
Khi các đối tượng được phân bổ, chúng tạo ra các khe trống nơi chúng từng được đánh dấu "bộ nhớ trống" trong sơ đồ.

00:22:12.000 --> 00:22:18.000
Tuy nhiên, những trang này vẫn còn bẩn vì vẫn còn một số đối tượng được phân bổ trên đó.

00:22:18.000 --> 00:22:22.000
Hệ thống sẽ cố gắng lấp đầy những vị trí trống này với các phân bổ trong tương lai.

00:22:22.000 --> 00:22:27.000
Ở đây tôi có một phân bổ lớn đến được ghi chú bởi hộp bên phải.

00:22:27.000 --> 00:22:33.000
Thật không may, phân bổ đến này quá lớn để phù hợp với các khe cắm bộ nhớ miễn phí của tôi.

00:22:33.000 --> 00:22:41.000
Mặc dù kích thước kết hợp của các khe trống đủ lớn, nhưng chúng không liền kề nhau và chúng không thể được sử dụng cho một lần phân bổ duy nhất.

00:22:41.000 --> 00:22:49.000
Vì vậy, vì nó không thể phù hợp với bất kỳ vị trí miễn phí hiện có nào, hệ thống đã đặt phân bổ của tôi trên một trang bẩn mới ở phía bên phải của sơ đồ.

00:22:49.000 --> 00:22:55.000
Các khe cắm bộ nhớ trống vẫn chưa được lấp đầy và được coi là bộ nhớ bị phân mảnh.

00:22:55.000 --> 00:23:02.000
Cách tốt nhất để giảm sự phân mảnh là phân bổ các đối tượng có thời gian tồn tại tương tự gần nhau trong bộ nhớ.

00:23:02.000 --> 00:23:11.000
Điều này giúp đảm bảo rằng tất cả các đối tượng đó được giải phóng cùng nhau, tạo cho quá trình những khối lớn bộ nhớ liền kề để làm việc để phân bổ trong tương lai.

00:23:11.000 --> 00:23:18.000
Trong ví dụ này, tôi đã phân bổ thủ công tất cả các đối tượng được đánh dấu "đối tượng của tôi" và tôi dự định giải phóng chúng cùng một lúc.

00:23:18.000 --> 00:23:24.000
Nhưng tôi đã không cẩn thận trong mã của mình và cuối cùng hệ thống đã xen kẽ các đối tượng của tôi với các đối tượng khác.

00:23:24.000 --> 00:23:33.000
Bây giờ, khi tôi giải phóng tất cả các đối tượng của mình, tôi có bốn khe cắm bộ nhớ trống, không có khe nào liền kề nhau vì chúng bị phá vỡ bởi các đối tượng được phân bổ này.

00:23:33.000 --> 00:23:36.000
Điều này dẫn đến 50% sự phân mảnh và bốn trang bẩn.

00:23:36.000 --> 00:23:39.000
Không tuyệt vời.

00:23:39.000 --> 00:23:43.000
Điều gì sẽ xảy ra nếu thay vào đó tôi viết mã để phân bổ tất cả các đối tượng của mình lại với nhau?

00:23:43.000 --> 00:23:46.000
Bây giờ tất cả họ kết thúc cùng nhau trên hai trang.

00:23:46.000 --> 00:23:56.000
Và khi tôi giải phóng các đối tượng của mình, quá trình giải phóng hai trang sạch cho hệ thống, dẫn đến chỉ có 2 trang bẩn và 0% phân mảnh.

00:23:56.000 --> 00:23:59.000
Chú ý cách phân mảnh là hệ số nhân dấu chân.

00:23:59.000 --> 00:24:05.000
50% sự phân mảnh đã tăng gấp đôi dấu chân của tôi từ 2 lên 4 trang bẩn.

00:24:05.000 --> 00:24:10.000
Trong hầu hết các tình huống thực tế, một số phân mảnh là không thể tránh khỏi.

00:24:10.000 --> 00:24:15.000
Vì vậy, theo nguyên tắc chung, hãy nhắm đến khoảng 25% phân mảnh hoặc ít hơn.

00:24:15.000 --> 00:24:19.000
Một cách để giảm sự phân mảnh là sử dụng các nhóm tự động phát hành.

00:24:19.000 --> 00:24:25.000
Một nhóm tự động phát hành yêu cầu hệ thống giải phóng tất cả các đối tượng được phân bổ bên trong nó ngay khi nó đi ra khỏi phạm vi.

00:24:25.000 --> 00:24:31.000
Điều này giúp đảm bảo rằng tất cả các đối tượng được tạo trong nhóm tự động phát hành có thời gian tồn tại tương tự nhau.

00:24:31.000 --> 00:24:42.000
Mặc dù sự phân mảnh có thể là một vấn đề đối với tất cả các quy trình, các quy trình chạy lâu dài có thể đặc biệt dễ bị tổn hại, bởi vì có rất nhiều phân bổ và phân bổ thỏa thuận để có khả năng phân mảnh không gian địa chỉ.

00:24:42.000 --> 00:24:51.000
Ví dụ, nếu ứng dụng của bạn sử dụng các tiện ích mở rộng chạy lâu dài, hãy đảm bảo xem xét sự phân mảnh trong các quy trình đó.

00:24:51.000 --> 00:25:00.000
Để xem nhanh quá trình phân mảnh của tôi, tôi có thể chạy vmmap -summary và cuộn xuống cuối đầu ra.

00:25:00.000 --> 00:25:02.000
Phần này được chia thành các khu vực malloc.

00:25:02.000 --> 00:25:05.000
Mỗi khu vực chứa các loại phân bổ khác nhau.

00:25:05.000 --> 00:25:13.000
Thông thường tôi sẽ chỉ quan tâm đến DefaultMallocZone, bởi vì đó là nơi phân bổ đống của tôi kết thúc theo mặc định.

00:25:13.000 --> 00:25:20.000
Tuy nhiên, vì memgraph này đã bật MSL, tôi thực sự quan tâm đến MallocStackLoggingLiteZone.

00:25:20.000 --> 00:25:26.000
Miễn là MSL được bật, khu vực này là nơi tất cả các phân bổ đống kết thúc.

00:25:26.000 --> 00:25:32.000
Cột % FRAG cho tôi thấy bao nhiêu phần trăm bộ nhớ của tôi bị lãng phí do sự phân mảnh trong mỗi vùng malloc.

00:25:32.000 --> 00:25:39.000
Một số con số này khá lớn, nhưng tôi chỉ cần tập trung vào MallocStackLoggingLiteZone.

00:25:39.000 --> 00:25:48.000
Đó là bởi vì MallocStackLoggingLiteZone cho đến nay có phần bộ nhớ bẩn lớn nhất, với tổng số 4,3 megabyte trong tổng số 5 megabyte.

00:25:48.000 --> 00:25:52.000
Vì vậy, lần này tôi có thể bỏ qua các khu vực khác.

00:25:52.000 --> 00:26:00.000
Cột "bẩn+kích thước mảnh vụn hoán đổi" cho tôi biết chính xác dung lượng bộ nhớ bị lãng phí do sự phân mảnh trong mỗi vùng malloc.

00:26:00.000 --> 00:26:04.000
Trong trường hợp của tôi, tôi đang lãng phí khoảng 800K do sự phân mảnh.

00:26:04.000 --> 00:26:09.000
Điều này có vẻ như rất nhiều, nhưng như tôi đã đề cập trước đây, một số phân mảnh là không thể tránh khỏi.

00:26:09.000 --> 00:26:16.000
Vì vậy, miễn là tôi ngồi dưới 25% sự phân mảnh, tôi sẽ coi sự lãng phí này là chấp nhận được.

00:26:16.000 --> 00:26:21.000
Có vẻ như tôi đang ngồi ở khoảng 19% phân mảnh trong MallocStackLoggingLiteZone.

00:26:21.000 --> 00:26:26.000
Điều này thoải mái dưới quy tắc ngón tay cái 25%, vì vậy tôi không quan tâm.

00:26:26.000 --> 00:26:33.000
Nếu tôi gặp vấn đề về phân mảnh, tôi có thể sử dụng theo dõi Phân bổ trong công cụ Công cụ.

00:26:33.000 --> 00:26:42.000
Cụ thể, tôi muốn xem chế độ xem danh sách phân bổ và xem những đối tượng nào vẫn tồn tại và bị phá hủy trong khu vực tôi quan tâm.

00:26:42.000 --> 00:26:52.000
Trong bối cảnh phân mảnh, các đối tượng bị phá hủy tạo ra các khe cắm bộ nhớ trống, trong khi các đối tượng tồn tại là các đối tượng còn lại, chịu trách nhiệm giữ cho các trang bẩn.

00:26:52.000 --> 00:26:57.000
Cả hai đều đáng để điều tra khi bạn đang xem xét sự phân mảnh.

00:26:57.000 --> 00:27:06.000
Để biết thêm thông tin về cách sử dụng công cụ Dụng cụ, hãy xem bài nói chuyện Bắt đầu với Dụng cụ từ WWDC 2019.

00:27:06.000 --> 00:27:18.000
Bây giờ tôi đã giải quyết các rò rỉ và hồi quy đống và xác minh rằng sự phân mảnh không phải là vấn đề, tôi sẽ chạy lại XCTest đó.

00:27:18.000 --> 00:27:19.000
Tuyệt vời.

00:27:19.000 --> 00:27:22.000
XCTest bây giờ trôi qua và hồi quy đã được giải quyết.

00:27:22.000 --> 00:27:29.000
Bây giờ bạn đã học về cách phát hiện và chẩn đoán các vấn đề về bộ nhớ, hãy xem lại quy trình làm việc mà bạn có thể sử dụng cho ứng dụng của riêng mình.

00:27:29.000 --> 00:27:38.000
Bất cứ khi nào bạn thêm một tính năng mới, hãy viết XCTest hiệu suất để theo dõi bộ nhớ và/hoặc bất kỳ số liệu hệ thống nào khác được cung cấp.

00:27:38.000 --> 00:27:40.000
Đối với mỗi bài kiểm tra, hãy đặt một đường cơ sở.

00:27:40.000 --> 00:27:48.000
Sau đó sử dụng bài kiểm tra để bắt hồi quy và điều tra bằng cách sử dụng các tệp ktrace và memgraph được thu thập.

00:27:48.000 --> 00:27:53.000
Sử dụng memgraphs từ bất kỳ XCTests thất bại nào để giúp chẩn đoán sự cố bộ nhớ của bạn.

00:27:53.000 --> 00:27:55.000
Điều đầu tiên bạn nên làm là kiểm tra rò rỉ.

00:27:55.000 --> 00:28:01.000
Chạy công cụ rò rỉ và sử dụng dấu vết MSL để giúp tìm và sửa chữa bất kỳ rò rỉ nào.

00:28:01.000 --> 00:28:05.000
Nếu hồi quy không bao gồm rò rỉ, thì hãy kiểm tra đống.

00:28:05.000 --> 00:28:10.000
Bắt đầu với vmmap -summary để xác nhận rằng bộ nhớ đang ở trong đống.

00:28:10.000 --> 00:28:15.000
Nếu vậy, hãy chạy heap -diffFrom để xem loại đối tượng nào chịu trách nhiệm cho sự phát triển.

00:28:15.000 --> 00:28:20.000
Nếu thủ phạm có vẻ hiển nhiên, hãy sử dụng đống địa chỉ để lấy địa chỉ của họ.

00:28:20.000 --> 00:28:24.000
Nếu không, hãy xem rò rỉ -referenceTree để biết một số manh mối.

00:28:24.000 --> 00:28:31.000
Cuối cùng, điều tra các địa chỉ đối tượng thủ phạm có rò rỉ -traceTree và/hoặc malloc_history.

00:28:31.000 --> 00:28:36.000
Cuối cùng, hãy chắc chắn rằng bạn đang phát triển với những phương pháp hay nhất về trí nhớ này.

00:28:36.000 --> 00:28:38.000
Cố gắng không có rò rỉ trong ứng dụng của bạn.

00:28:38.000 --> 00:28:43.000
Nếu bạn đang làm việc với các loại không an toàn, hãy đảm bảo rằng bạn nhớ giải phóng mọi thứ bạn phân bổ.

00:28:43.000 --> 00:28:47.000
Và cũng đang tìm kiếm các chu kỳ lưu giữ trong mã của bạn.

00:28:47.000 --> 00:28:58.000
Tìm cách để giảm phân bổ đống của bạn, cho dù đó là thu nhỏ chúng, giữ chúng trong một khoảng thời gian ngắn hơn hay chỉ loại bỏ hoàn toàn các phân bổ không cần thiết.

00:28:58.000 --> 00:29:00.000
Đảm bảo ghi nhớ sự phân mảnh.

00:29:00.000 --> 00:29:07.000
Phân bổ các đối tượng có thời gian tồn tại tương tự cạnh nhau để tạo ra những khối bộ nhớ trống lớn, đẹp mắt sau này.

00:29:07.000 --> 00:29:15.000
Với những phương pháp hay nhất này và quy trình làm việc XCTest, bạn sẽ được trang bị để phát hiện, chẩn đoán và khắc phục sự cố bộ nhớ trong ứng dụng của mình.

00:29:15.000 --> 00:29:19.000
Thay mặt cho Tanuja và bản thân tôi, cảm ơn rất nhiều vì đã theo dõi.

00:29:19.000 --> 23:59:59.000
[Nhạc gõ].

