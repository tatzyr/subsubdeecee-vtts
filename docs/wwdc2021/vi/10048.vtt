WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:14.000
Xin chào, tên tôi là Brett Cato, và tôi là một kỹ sư trong nhóm Trải nghiệm Hệ thống.

00:00:14.000 --> 00:00:23.000
Hôm nay chúng ta sẽ nói về các nguyên tắc của các tiện ích tuyệt vời, đi sâu vào một số chủ đề nóng để giúp bạn xây dựng các tiện ích tốt nhất có thể.

00:00:23.000 --> 00:00:26.000
Trong iOS 14, chúng tôi đã giới thiệu WidgetKit.

00:00:26.000 --> 00:00:37.000
WidgetKit cho phép bạn tạo các tiện ích đẹp, năng động, đa nền tảng ngay trên Màn hình chính của người dùng trên iOS, iPadOS và macOS.

00:00:37.000 --> 00:00:50.000
Bây giờ, trước khi chúng ta bắt đầu, nếu bạn bỏ lỡ bất kỳ cuộc nói chuyện nào từ WWDC 2020, có một số cuộc nói chuyện thực sự tuyệt vời, như "Gặp gỡ WidgetKit", cung cấp phần giới thiệu về khung WidgetKit và các khái niệm cốt lõi của nó.

00:00:50.000 --> 00:00:57.000
"Widgets code-along" là một loạt ba phần xây dựng một tiện ích với độ phức tạp ngày càng tăng từ cơ bản đến nâng cao.

00:00:57.000 --> 00:01:04.000
"Xây dựng chế độ xem SwiftUI cho các tiện ích" nêu chi tiết cách tận dụng tối đa SwiftUI để xây dựng chế độ xem thích ứng cho tiện ích của bạn.

00:01:04.000 --> 00:01:13.000
Cuối cùng, "Thiết kế các vật dụng tuyệt vời" khám phá các cân nhắc thiết kế từ nhóm giao diện con người của chúng tôi với rất nhiều ví dụ.

00:01:13.000 --> 00:01:22.000
Hôm nay chúng ta sẽ đề cập đến hai chủ đề cho các tiện ích tuyệt vời: giữ cho chúng có liên quan và cho phép tùy chỉnh tiện ích.

00:01:22.000 --> 00:01:25.000
Vì vậy, hãy bắt đầu với sự liên quan.

00:01:25.000 --> 00:01:33.000
Có ba loại liên quan mà chúng ta sẽ thảo luận chuyên sâu để đảm bảo tiện ích của bạn được cập nhật và có thể thích ứng với môi trường của nó.

00:01:33.000 --> 00:01:39.000
Chúng ta sẽ nói về thời gian, cách trình bày và sự liên quan đến địa điểm.

00:01:39.000 --> 00:01:41.000
Trọng tâm của WidgetKit là dòng thời gian.

00:01:41.000 --> 00:01:45.000
Đây là cơ chế cốt lõi của Widgets để duy trì sự liên quan suốt cả ngày.

00:01:45.000 --> 00:01:49.000
Dòng thời gian bao gồm một hoặc nhiều mục dòng thời gian.

00:01:49.000 --> 00:01:56.000
Trong ví dụ này, bạn có thể thấy ba mục như vậy, một lúc 9:00 sáng, 9:30 sáng và 10:00 sáng.

00:01:56.000 --> 00:02:06.000
Bây giờ, khi hệ thống yêu cầu tiện ích của bạn cho dòng thời gian, dòng thời gian kết quả sẽ được lưu trữ và các mục nhập của nó được hiển thị vào những thời điểm cụ thể mà bạn chỉ định trong tương lai.

00:02:06.000 --> 00:02:12.000
Điều này cho phép hệ thống có giao diện người dùng của bạn sẵn sàng ngay lập tức để hiển thị ngay khi người dùng cần.

00:02:12.000 --> 00:02:20.000
Hãy xem xét một số ví dụ về dòng thời gian, bắt đầu từ đơn giản nhất và xem loại nội dung có thể có trong đó.

00:02:20.000 --> 00:02:26.000
Đây là một ví dụ về dòng thời gian đơn giản nhất chỉ với một mục duy nhất: Thời gian sử dụng thiết bị.

00:02:26.000 --> 00:02:40.000
Bây giờ, bởi vì Screen Time không thể dự đoán hoặc dự báo dữ liệu trong tương lai và nó hoàn toàn dựa trên lịch sử thống kê về cách thiết bị của người dùng đã được sử dụng, nó thực sự không thể tận dụng tốt nhiều mục nhập trong dòng thời gian của nó, vì vậy nó chỉ sử dụng một mục nhập duy nhất.

00:02:40.000 --> 00:02:43.000
Đây là dòng thời gian đơn giản nhất mà bạn có thể có.

00:02:43.000 --> 00:02:53.000
Tuy nhiên, điều đó nói rằng không phải tất cả các tiện ích đều cần phải là một mục nhập duy nhất và trên thực tế, trong hầu hết các trường hợp, tôi khuyến khích bạn xem xét và đặt câu hỏi tại sao bạn không cung cấp nhiều mục nhập trong dòng thời gian của mình.

00:02:53.000 --> 00:03:05.000
Nếu bạn có nội dung hướng tới tương lai, có ngày hoặc thời hạn quan trọng hoặc có thể dự báo nội dung của bạn trong tương lai, tiện ích của bạn thực sự nên tận dụng nhiều mục nhập trong dòng thời gian của bạn.

00:03:05.000 --> 00:03:07.000
Đây là một ví dụ khác từ Thời tiết.

00:03:07.000 --> 00:03:13.000
Như bạn có thể thấy, dòng thời gian của Weather cung cấp nhiều mục nhập cho những giờ cuối cùng trong suốt cả ngày.

00:03:13.000 --> 00:03:23.000
Bây giờ, mục đầu tiên ở đây là chính xác nhất vì nó đại diện cho thời tiết hiện tại và tất cả các mục tiếp theo khác đại diện cho dữ liệu dự báo vào những thời điểm sau đó trong ngày.

00:03:23.000 --> 00:03:30.000
Dữ liệu dự báo bổ sung này cực kỳ hữu ích vì tải lại tiện ích không được đảm bảo tải lại vào thời điểm chính xác mà bạn chỉ định.

00:03:30.000 --> 00:03:42.000
Và nếu tải lại không đạt đến ngày mục tiêu đó chính xác như mong muốn, thì bây giờ hệ thống đã có thêm nội dung dự báo để vượt qua trải nghiệm người dùng.

00:03:42.000 --> 00:03:44.000
Đây là một ví dụ từ Photos.

00:03:44.000 --> 00:03:51.000
Bạn có thể thấy rằng dòng thời gian Ảnh cung cấp một số ảnh cá nhân và có liên quan để xuất hiện vào những thời điểm cụ thể trong ngày.

00:03:51.000 --> 00:03:55.000
Đối với tôi, đây là một số kỷ niệm thực sự, thực sự tuyệt vời.

00:03:55.000 --> 00:04:05.000
Và bây giờ, trong khi tiện ích chỉ tải lại một vài lần một ngày, nó thực sự mang lại cảm giác sống động xuyên suốt bằng cách trình bày nội dung mới và mới từ nhiều mục dòng thời gian này.

00:04:05.000 --> 00:04:22.000
Như bạn có thể thấy ở đây, ngay cả khi bạn không có dữ liệu có thể dự báo như thời tiết, như trong ví dụ này với Ảnh, bạn vẫn có thể kết hợp nội dung có liên quan đến người dùng theo cách có thể gây bất ngờ và thích thú bằng cách tận dụng nhiều mục nhập này trong dòng thời gian của bạn.

00:04:22.000 --> 00:04:27.000
Bây giờ, vì một số tiện ích được xem nhiều hơn những tiện ích khác, chúng tôi đã quyết định cung cấp cho các tiện ích một yếu tố công bằng để cập nhật.

00:04:27.000 --> 00:04:30.000
Chúng tôi gọi đây là ngân sách cập nhật.

00:04:30.000 --> 00:04:37.000
Ngân sách được phân bổ và tích lũy trong ngày, và chúng bị ảnh hưởng nặng nề bởi thói quen xem của người dùng.

00:04:37.000 --> 00:04:52.000
Một tiện ích được xem thường xuyên có thể được dự kiến sẽ nhận được ở đâu đó trong sân bóng khoảng 40 đến 70 bản cập nhật nền mỗi ngày, điều này có nghĩa là cập nhật khoảng 15 đến 30 phút một lần nếu cách đều nhau trong những giờ bình thường mà người dùng thức.

00:04:52.000 --> 00:05:01.000
Tuy nhiên, tất nhiên không phải tất cả các lần tải lại đều phải cách đều nhau như thế này và mục tiêu của chúng tôi là kích hoạt và hỗ trợ nhịp cập nhật đa dạng cho các yêu cầu khác nhau.

00:05:01.000 --> 00:05:14.000
Ví dụ: có thể bạn có một tiện ích thể thao phần lớn không hoạt động cho đến một trận đấu sắp tới cho một đội yêu thích, và sau đó nó có thể nhận được một loạt các cập nhật điểm số trước, trong và thậm chí sau trận đấu.

00:05:14.000 --> 00:05:21.000
WidgetKit thông minh và nó có thể giữ lại các bản cập nhật khi người dùng không sử dụng thiết bị trong thời gian dài như khi người dùng đang ngủ.

00:05:21.000 --> 00:05:27.000
Nếu không, các bản cập nhật tiện ích có thể được giữ lại cho đến khi ngân sách có sẵn cho một tiện ích cụ thể.

00:05:27.000 --> 00:05:31.000
Tuy nhiên, tất cả những gì đã nói, tải lại không phải là thao tác mỗi giây.

00:05:31.000 --> 00:05:36.000
Widgets không phải là về việc tạo ra trải nghiệm chạy trực tiếp trên Màn hình chính.

00:05:36.000 --> 00:05:41.000
Bây giờ, có rất nhiều cách mà các vật dụng của bạn sẽ làm mới trong suốt cả ngày.

00:05:41.000 --> 00:05:50.000
Và chúng ta sẽ xem xét ngắn gọn từng thứ này để hiểu chúng là gì, chúng hoạt động như thế nào và chúng hoạt động như thế nào so với ngân sách mà chúng tôi vừa giới thiệu.

00:05:50.000 --> 00:05:54.000
Đầu tiên là TimelineReloadPolicy, là API trong WidgetKit.

00:05:54.000 --> 00:05:59.000
Đây là cơ chế cốt lõi để việc tải lại của bạn xảy ra tự động.

00:05:59.000 --> 00:06:04.000
Khi bạn cung cấp một mốc thời gian, bạn cũng cung cấp một chính sách tải lại cùng với nó.

00:06:04.000 --> 00:06:10.000
Chính sách tải lại này thông báo cho hệ thống khi bạn muốn tự động làm mới tiện ích của mình trong nền.

00:06:10.000 --> 00:06:17.000
Các bản cập nhật tự động này được lập ngân sách và ghi nợ từ ngân sách khả dụng hiện tại của tiện ích của bạn.

00:06:17.000 --> 00:06:20.000
Tiếp theo là API tải lại WidgetCenter.

00:06:20.000 --> 00:06:26.000
Đây là một API để làm mới tiện ích của bạn khi các sự kiện xảy ra sẽ làm mất hiệu lực dữ liệu hiện có của tiện ích của bạn.

00:06:26.000 --> 00:06:34.000
Bây giờ, thông thường, các yêu cầu sử dụng API này sẽ tiêu tốn ngân sách khả dụng, có nghĩa là các bản cập nhật sẽ không xảy ra cho đến khi ngân sách có sẵn.

00:06:34.000 --> 00:06:42.000
Tuy nhiên, có một vài trường hợp ngoại lệ tình huống sẽ khiến những lần tải lại này xảy ra cả ngay lập tức và không có ngân sách.

00:06:42.000 --> 00:06:52.000
Đây là khi ứng dụng vùng chứa của bạn ở phía trước cho người dùng hoặc khi ứng dụng của bạn đang tham gia vào phiên người dùng, như Điều hướng hoặc Đang phát âm thanh.

00:06:52.000 --> 00:06:59.000
API này thực sự bổ sung cho các cập nhật nền tự động từ API TimelineReloadPolicy.

00:06:59.000 --> 00:07:03.000
Các tiện ích của bạn cũng có thể cập nhật khi xảy ra thay đổi vị trí đáng kể.

00:07:03.000 --> 00:07:10.000
Khi hệ thống phát hiện ra sự thay đổi vị trí đáng kể và tiện ích của bạn sử dụng vị trí, hệ thống sẽ cấp cho bạn bản cập nhật miễn phí ngân sách.

00:07:10.000 --> 00:07:17.000
Việc làm mới này xảy ra khi người dùng tiếp theo xem tiện ích của bạn để vị trí đó có thể được giải quyết một cách thích hợp.

00:07:17.000 --> 00:07:24.000
Bây giờ, lưu ý rằng điều này không được đảm bảo xảy ra ngay khi thay đổi vị trí xảy ra mà là lần sau khi người dùng xem tiện ích.

00:07:24.000 --> 00:07:27.000
Chúng ta sẽ nói thêm một chút về địa điểm sau.

00:07:27.000 --> 00:07:31.000
Hệ thống cũng có thể làm mới tiện ích của bạn, nếu môi trường trình bày của nó thay đổi.

00:07:31.000 --> 00:07:44.000
Ví dụ: có thể người dùng thay đổi tùy chọn Trợ năng như văn bản động hoặc văn bản in đậm, có thay đổi ngôn ngữ hoặc khu vực, thay đổi tài khoản iCloud hoặc App Store, thay đổi thời gian đáng kể và hơn thế nữa.

00:07:44.000 --> 00:07:53.000
Cuối cùng, do lập ngân sách, nếu người dùng có một tiện ích hiếm khi được nhìn thấy, nó có thể không nhận được nhiều bản cập nhật như bạn, nhà phát triển, có thể thích.

00:07:53.000 --> 00:08:00.000
Hệ thống biết ngày nào trong dòng thời gian của bạn, thời gian làm mới ưa thích của bạn là bao nhiêu và lịch sử xem chung từ người dùng.

00:08:00.000 --> 00:08:05.000
Hệ thống có thể cấp tải lại miễn phí nếu nó nghĩ rằng dữ liệu có thể cũ khi người dùng xem.

00:08:05.000 --> 00:08:10.000
Tất nhiên, tất cả các bản cập nhật do hệ thống khởi tạo này luôn miễn phí ngân sách.

00:08:10.000 --> 00:08:18.000
Như chúng ta đã biết chỉ một lúc trước, mỗi dòng thời gian đi kèm với chính sách tải lại mô tả thời điểm nó sẽ tự động cập nhật trong nền.

00:08:18.000 --> 00:08:24.000
WidgetKit cung cấp ba lựa chọn ở đây: atEnd, afterDate, và never.

00:08:24.000 --> 00:08:28.000
Chính sách tải lại nào trong ba chính sách tải lại này phù hợp với tiện ích của bạn?

00:08:28.000 --> 00:08:37.000
Hãy đi sâu vào để nói về từng cái, với một số ví dụ cho ngữ cảnh, và chúng ta sẽ nói về gotchas về những gì cần lưu ý với mỗi cái.

00:08:37.000 --> 00:08:41.000
Chính sách đầu tiên chúng ta sẽ thảo luận là chính sách tải lại atEnd.

00:08:41.000 --> 00:08:49.000
Chính sách này sẽ đánh dấu tiện ích của bạn đủ điều kiện để được làm mới khi dòng thời gian kết thúc, đó là, tất nhiên, khi mục nhập cuối cùng trở nên có liên quan.

00:08:49.000 --> 00:08:53.000
Trong trường hợp này, đó là lúc 10:30 sáng.

00:08:53.000 --> 00:09:03.000
Cũng lưu ý rằng lần này chỉ đơn giản là thời điểm tiện ích đủ điều kiện để làm mới và nó không đảm bảo rằng nó sẽ làm mới chính xác vào thời điểm này.

00:09:03.000 --> 00:09:14.000
Hơn nữa, nếu sử dụng atEnd với các tiện ích có dòng thời gian nhập một lần, như ví dụ Thời gian sử dụng mà chúng ta đã nói trước đây, hệ thống sẽ chọn thời gian thích hợp cho tiện ích của bạn.

00:09:14.000 --> 00:09:21.000
atEnd được khuyến nghị nếu tiện ích của bạn đã có nội dung vượt quá tuổi thọ của dòng thời gian hiện tại.

00:09:21.000 --> 00:09:24.000
Tôi thích nghĩ về nó giống như xem cửa sổ vào nội dung của bạn.

00:09:24.000 --> 00:09:27.000
Hãy xem xét một ví dụ.

00:09:27.000 --> 00:09:31.000
Được phác thảo ở đây là dòng thời gian hiện tại cho tiện ích Lịch vào ngày 7 tháng Sáu.

00:09:31.000 --> 00:09:33.000
Nó có bốn mục.

00:09:33.000 --> 00:09:38.000
Tôi đã bao gồm nội dung quá khứ và tương lai của nó để giúp giới thiệu các cửa sổ.

00:09:38.000 --> 00:09:46.000
Và khi chúng tôi thay đổi dòng thời gian cho ngày 8 tháng 6, bạn có thể thấy ý tôi khi xem một cửa sổ vào nội dung của nó.

00:09:46.000 --> 00:09:48.000
Và một lần nữa cho dòng thời gian cho ngày 9 tháng Sáu.

00:09:48.000 --> 00:09:53.000
Chúng tôi chỉ đang thay đổi quan điểm về dữ liệu đã có sẵn và được cung cấp bởi người dùng.

00:09:53.000 --> 00:10:00.000
Loại nội dung này thực sự là nơi sử dụng chính sách atEnd tỏa sáng.

00:10:00.000 --> 00:10:07.000
Bây giờ, một số ví dụ về các tiện ích sử dụng chính sách atEnd bao gồm Lời nhắc, Lịch, Ảnh, Mẹo và hơn thế nữa.

00:10:07.000 --> 00:10:14.000
Một lần nữa, đây là tất cả các tiện ích với nội dung vô tận nổi tiếng trong tương lai, nơi bạn có thể chỉ cần xem một cửa sổ vào đó.

00:10:14.000 --> 00:10:23.000
Nó không thực sự phù hợp với các mốc thời gian nhập một lần vì hệ thống sẽ chọn thời gian tải lại cho bạn và có lẽ đó không phải là điều bạn muốn.

00:10:23.000 --> 00:10:30.000
AtEnd cũng không được khuyến khích nếu dòng thời gian của bạn có nội dung dự kiến mất đi sự liên quan hoặc chính xác theo thời gian.

00:10:30.000 --> 00:10:43.000
Chúng tôi chỉ đơn giản muốn nội dung của bạn phù hợp nhất có thể và nếu chúng tôi đợi đến khi kết thúc dòng thời gian khi mọi thứ ít liên quan nhất để đủ điều kiện cập nhật, thì điều đó không dẫn đến trải nghiệm người dùng tốt nhất.

00:10:43.000 --> 00:10:47.000
Vậy đó là ở End. Bây giờ, hãy nói về afterDate.

00:10:47.000 --> 00:10:53.000
Chính sách tải lại afterDate làm cho tiện ích của bạn đủ điều kiện để tải lại sau ngày được chỉ định.

00:10:53.000 --> 00:10:58.000
Với afterDate, bạn thực sự có toàn quyền kiểm soát thời gian đủ điều kiện.

00:10:58.000 --> 00:11:04.000
Trong ví dụ này, hãy giả vờ dòng thời gian có hiệu lực từ 9:00 sáng đến khoảng 11:00 sáng.

00:11:04.000 --> 00:11:12.000
Ngày chính sách tải lại tiện ích là 9:30 sáng đã được chọn vì dữ liệu dự báo của tiện ích bắt đầu mất độ chính xác vào khoảng 9:45 hoặc lâu hơn.

00:11:12.000 --> 00:11:21.000
Điều này cung cấp cho tiện ích nhiều đường băng sau 9:30 để vẫn hiển thị dữ liệu dự báo của nó, ngay cả khi nó không được tải lại ngay lập tức lúc 9:30.

00:11:21.000 --> 00:11:33.000
afterDate thích hợp nhất cho nội dung có thể thay đổi không thể đoán trước hoặc bất ngờ trong suốt cả ngày cũng như cho dữ liệu có độ chính xác hoặc mức độ liên quan thay đổi định kỳ.

00:11:33.000 --> 00:11:40.000
Một số ví dụ về các tiện ích sử dụng afterDate bao gồm Cổ phiếu, Thời tiết, Tin tức, Thư và hơn thế nữa.

00:11:40.000 --> 00:11:47.000
Đây là tất cả các tiện ích có nội dung có thể thay đổi không thể đoán trước hoặc bất ngờ trong ngày.

00:11:47.000 --> 00:11:52.000
Bây giờ, với afterDate, bạn phải thực sự cẩn thận với một vài vấn đề tiềm ẩn.

00:11:52.000 --> 00:11:55.000
Hãy thận trọng với việc tải lại gần như ngay lập tức.

00:11:55.000 --> 00:12:01.000
Có thể hợp lệ để chỉ định một ngày cách đó một phút hoặc lâu hơn nhưng thường chỉ trong những khoảng thời gian rất hẹp.

00:12:01.000 --> 00:12:08.000
Yêu cầu quá nhiều lần làm mới ở mức độ phân giải này có thể khiến bản thân thiếu tải lại sau này.

00:12:08.000 --> 00:12:12.000
Ngoài ra, hãy cẩn thận nếu bạn sắp xếp ngày làm mới tiện ích trên các thiết bị.

00:12:12.000 --> 00:12:25.000
Ví dụ, Hoa Kỳ. Thị trường chứng khoán mở cửa lúc 9:30 sáng ở Bờ Đông và bạn lên lịch làm mới vào đúng 9:30 sáng để lấy dữ liệu ban đầu trong ngày từ các máy chủ.

00:12:25.000 --> 00:12:33.000
Hãy nhớ rằng, tiện ích của bạn có thể ở trên hàng nghìn hoặc thậm chí hàng triệu thiết bị, thậm chí có thể nhiều lần trên mỗi thiết bị đó.

00:12:33.000 --> 00:12:44.000
Và nếu bạn phải kéo dữ liệu được căn chỉnh theo thời gian như thế này, bạn thực sự nên cân nhắc thêm một số mức độ jitter ngẫu nhiên vào những ngày này ngoài việc nhấn các máy chủ bộ nhớ đệm.

00:12:44.000 --> 00:12:51.000
Những điều này đặc biệt quan trọng cần xem xét để tránh bất kỳ chi phí ngoài kế hoạch hoặc không cần thiết nào.

00:12:51.000 --> 00:12:56.000
Cuối cùng, hãy nói về chính sách tải lại yêu thích của tôi, điều không bao giờ xảy ra.

00:12:56.000 --> 00:13:01.000
Chính sách không bao giờ tải lại là chính sách đơn giản nhất vì nó không bao giờ tự động tải lại.

00:13:01.000 --> 00:13:13.000
Nếu nội dung tiện ích của bạn chỉ có thể thay đổi thông qua ứng dụng vùng chứa ở phía trước hoặc thông qua các sự kiện rời rạc như thông báo đẩy, thì không bao giờ là lựa chọn tuyệt vời cho tiện ích của bạn.

00:13:13.000 --> 00:13:23.000
Khi sử dụng chính sách không bao giờ, bạn có thể cập nhật tiện ích của mình chỉ với API tải lại WidgetCenter từ vùng chứa của bạn hoặc các tiện ích mở rộng phụ kiện khác.

00:13:23.000 --> 00:13:32.000
Điều này thực sự giảm thiểu việc tải lại chỉ xảy ra khi cần thiết và nó giữ tác động tối thiểu đến ngân sách của bạn và thời lượng pin của người dùng.

00:13:32.000 --> 00:13:38.000
Không bao giờ phù hợp nếu tiện ích của bạn yêu cầu điều kiện người dùng rõ ràng trong ứng dụng của bạn mà chưa được thỏa mãn.

00:13:38.000 --> 00:13:43.000
Ví dụ, có thể đăng nhập vào một dịch vụ hoặc mua một số nội dung cụ thể.

00:13:43.000 --> 00:13:49.000
Đừng bao giờ cân nhắc nếu tiện ích của bạn không thể tạo ra nội dung có ý nghĩa trước khi các loại điều kiện này được đáp ứng trong ứng dụng của bạn.

00:13:49.000 --> 00:13:57.000
Các ví dụ điển hình về các tiện ích sử dụng chính sách không bao giờ bao gồm TV, Ghi chú, Âm nhạc, Podcast, Danh bạ và hơn thế nữa.

00:13:57.000 --> 00:14:06.000
Đây là tất cả các tiện ích và ứng dụng yêu cầu tương tác của người dùng trong ứng dụng để thúc đẩy thay đổi nội dung hoặc họ nhận được sự thúc đẩy cho các bản cập nhật nội dung đó.

00:14:06.000 --> 00:14:10.000
Tóm lại, tận dụng các mục nhập dòng thời gian để tạo lợi thế cho bạn.

00:14:10.000 --> 00:14:20.000
Chọn chính sách tải lại chính xác cho tiện ích của bạn và sử dụng API tải lại của WidgetCenter để tải lại các sự kiện dòng thời gian trên các sự kiện rời rạc.

00:14:20.000 --> 00:14:24.000
Được rồi, hãy chuyển sang mức độ liên quan của bài thuyết trình.

00:14:24.000 --> 00:14:31.000
Tiện ích của bạn có thể được trình bày trong các ngữ cảnh cụ thể trên iOS hoặc macOS có thể dẫn đến việc tiện ích của bạn thay đổi diện mạo.

00:14:31.000 --> 00:14:36.000
Tiện ích đôi khi có thể được hiển thị lại mà không cần bất kỳ cập nhật dòng thời gian nào.

00:14:36.000 --> 00:14:40.000
Và các tiện ích tuyệt vời sẽ luôn thích ứng với các môi trường trình bày này một cách thích hợp.

00:14:40.000 --> 00:14:50.000
Vì vậy, chúng ta sẽ nói về cách phối màu, Chế độ tối và sáng, biên tập một phần quyền riêng tư, mới trong iOS 15 và biên tập quyền riêng tư đầy đủ.

00:14:50.000 --> 00:14:56.000
WidgetKit sẽ tự động xử lý việc chuyển nội dung của bạn giữa Chế độ Sáng và Tối khi cài đặt hệ thống thay đổi.

00:14:56.000 --> 00:15:00.000
Điều này là do chúng tôi sử dụng sức mạnh của SwiftUI.

00:15:00.000 --> 00:15:04.000
Bây giờ hãy nghĩ về cách bạn muốn tiện ích của mình trông như thế nào trong các ngữ cảnh tương ứng này.

00:15:04.000 --> 00:15:11.000
Tại đây bạn có thể xem các ví dụ về Ghi chú và Lịch trong cả sơ đồ sáng và tối.

00:15:11.000 --> 00:15:17.000
Tuy nhiên, hãy nhớ rằng không phải tất cả các vật dụng nhất thiết phải phù hợp với Chế độ Sáng và Tối bằng cách thay đổi màu nền và văn bản của chúng.

00:15:17.000 --> 00:15:22.000
Ví dụ, có một vài tiện ích, như Âm nhạc và Cổ phiếu, không thay đổi màu sắc của chúng.

00:15:22.000 --> 00:15:33.000
Nếu thiết kế ứng dụng của bạn bất khả tri về nội dung tương phản cao này của các kiểu tối và sáng, thì hãy thoải mái tiếp tục bất kỳ bảng màu nào có ý nghĩa đối với tiện ích của bạn.

00:15:33.000 --> 00:15:38.000
Bạn cũng có thể xem trước các thay đổi bảng màu cho tiện ích của mình trong Xcode thông qua Xem trước Xcode.

00:15:38.000 --> 00:15:44.000
Đây là một ví dụ nhanh về việc xem trước một tiện ích systemSmall ở Chế độ Ánh sáng.

00:15:44.000 --> 00:15:46.000
Và bây giờ ở Chế độ Tối.

00:15:46.000 --> 00:15:52.000
Tất cả những gì chúng tôi phải làm là thêm ghi đè môi trường colorScheme để xem trước tiện ích của chúng tôi sẽ trông như thế nào trong môi trường này.

00:15:52.000 --> 00:16:02.000
Và nếu bạn muốn màu nền tiêu chuẩn hệ thống cho Chế độ Sáng và Tối như được hiển thị ở đây, thì hãy sử dụng BackgroundStyle để tô màu.

00:16:02.000 --> 00:16:08.000
Các tiện ích cũng phải tuân theo các môi trường trình bày có thể nhạy cảm với quyền riêng tư, như Màn hình khóa trên iOS.

00:16:08.000 --> 00:16:14.000
Mới trong iOS 15, các tiện ích hiện có thể biên tập lại một phần nội dung trong những tình huống này.

00:16:14.000 --> 00:16:20.000
Bây giờ, điều đó nghe có vẻ thực sự khó hiểu, vì vậy hãy đưa ra một ví dụ để xem tôi đang nói về cái quái gì ở đây.

00:16:20.000 --> 00:16:25.000
Hãy giả vờ như chúng ta có một tiện ích ngân hàng nơi tôi đang hiển thị số dư có sẵn trong một tài khoản cụ thể.

00:16:25.000 --> 00:16:31.000
Trong trường hợp này, tôi có sẵn 128,45 đô la trong tài khoản của mình.

00:16:31.000 --> 00:16:44.000
Bây giờ, khi chúng ta vào Màn hình khóa và khóa thiết bị, số dư tài khoản này vẫn xuất hiện trong iOS 14 vì WidgetKit thực sự không có cách nào để tự động chỉnh sửa thông tin số dư khi thiết bị bị khóa.

00:16:44.000 --> 00:16:52.000
Tuy nhiên, điều đó hiện đã thay đổi trong iOS 15 và bây giờ bạn có thể đánh dấu theo ngữ cảnh các chế độ xem cụ thể để được biên tập lại trong những tình huống này.

00:16:52.000 --> 00:17:00.000
Bây giờ, để chỉ cho bạn cách làm điều đó, tất cả những gì chúng tôi làm là, chúng tôi chỉ cần chèn công cụ sửa đổi chế độ xem .privacySensitive vào văn bản đại diện cho số dư.

00:17:00.000 --> 00:17:08.000
Vì vậy, khi mật mã không bị khóa, như bạn có thể thấy ở đây, chế độ xem vẫn hiển thị số dư như bạn mong đợi.

00:17:08.000 --> 00:17:15.000
Nhưng khi chúng tôi khóa thiết bị, số dư sẽ bị che hoặc chỉnh sửa.

00:17:15.000 --> 00:17:21.000
Cũng lưu ý rằng công cụ sửa đổi này có thể được áp dụng cho bất kỳ chế độ xem nào, bao gồm các chế độ xem vùng chứa như hstacks và vstacks.

00:17:21.000 --> 00:17:26.000
Và nếu áp dụng cho một vùng chứa, toàn bộ vùng chứa sẽ được biên tập lại.

00:17:26.000 --> 00:17:44.000
Ví dụ, nếu ứng dụng của bạn tận dụng khả năng bảo vệ dữ liệu hoàn toàn không thể chạm vào trong khi thiết bị iOS bị khóa mật mã, có thể ứng dụng của bạn đang sử dụng dữ liệu Sức khỏe và bạn đã bỏ qua việc xây dựng tiện ích hoặc sợ đưa nó vào vì bạn nghĩ rằng nó phải được hiển thị trên Màn hình khóa, thì tính năng này thực sự

00:17:44.000 --> 00:17:54.000
WidgetKit có thể tự động thay thế nội dung dòng thời gian đang hoạt động của bạn bằng nội dung giữ chỗ khi thiết bị bị khóa mật mã để biên tập đầy đủ nội dung.

00:17:54.000 --> 00:17:59.000
Và nó thậm chí có thể giữ lại các bản cập nhật trong suốt thời gian trong khi thiết bị bị khóa mật mã.

00:17:59.000 --> 00:18:04.000
Tất cả điều này đều có thể xảy ra khi bạn áp dụng quyền bảo vệ dữ liệu mặc định được liệt kê ở đây.

00:18:04.000 --> 00:18:09.000
Dữ liệu dòng thời gian của bạn sẽ được lưu trữ theo mong muốn của bạn trong lớp dữ liệu đó trên thiết bị.

00:18:09.000 --> 00:18:12.000
Chúng tôi thực sự coi trọng quyền riêng tư dữ liệu của bạn ở đây.

00:18:12.000 --> 00:18:15.000
Cuối cùng, tôi muốn nói về sự liên quan đến vị trí.

00:18:15.000 --> 00:18:26.000
Các tiện ích, giống như ứng dụng của bạn, cũng có thể cung cấp thông tin theo ngữ cảnh cho vị trí thực tế hiện tại của chúng tôi hoặc chỉ đơn giản là các vị trí có liên quan đến người dùng theo cách này hay cách khác.

00:18:26.000 --> 00:18:31.000
Nếu ứng dụng của bạn sử dụng vị trí bình thường, thì có khả năng tiện ích của bạn cũng vậy.

00:18:31.000 --> 00:18:46.000
Bởi vì các tiện ích có thể có nhiều trường hợp trên Màn hình chính và trong Trung tâm thông báo trên Mac, hãy cân nhắc cung cấp các vị trí được chọn trước và thậm chí có thể tìm kiếm cho các tiện ích của bạn ngoài việc sử dụng vị trí hiện tại giống như chúng tôi làm với tiện ích Thời tiết thông qua sức mạnh của Ý định.

00:18:46.000 --> 00:18:51.000
Bây giờ, để tìm nạp vị trí hiện tại trong tiện ích của bạn, chỉ cần một vài bước.

00:18:51.000 --> 00:18:56.000
Đầu tiên, bạn cần chỉ định khóa NSWidgetUsesLocation trong Info.plist của bạn.

00:18:56.000 --> 00:19:01.000
Điều này cho hệ thống biết rằng bạn sẽ sử dụng vị trí từ tiện ích mở rộng tiện ích của mình.

00:19:01.000 --> 00:19:10.000
Thứ hai, sử dụng CLLocationManager như bình thường, ngoại trừ lần này từ TimelineProvider trong tiện ích mở rộng tiện ích của bạn.

00:19:10.000 --> 00:19:19.000
Hãy xem xét độ phân giải mà tiện ích của bạn yêu cầu, vì nó nhanh hơn để giải quyết vị trí thô và nó có thể mang lại trải nghiệm người dùng tốt hơn nếu bạn không cần vị trí siêu chính xác.

00:19:19.000 --> 00:19:25.000
Nói chung, vị trí được yêu cầu càng chính xác thì càng mất nhiều thời gian để giải quyết.

00:19:25.000 --> 00:19:33.000
Cuối cùng, bạn có thể kiểm tra xem tiện ích có được ủy quyền để cập nhật vị trí hay không bằng cách sử dụng API isAuthorizedForWidgetUpdates trên CLLocationManager.

00:19:33.000 --> 00:19:38.000
Điều này sẽ cho bạn biết liệu người dùng có cấp quyền tiện ích của bạn để sử dụng vị trí hay không.

00:19:38.000 --> 00:19:44.000
Nói về quyền, hãy xem xét quyền vị trí cho các tiện ích chi tiết hơn để xem chúng hoạt động như thế nào.

00:19:44.000 --> 00:19:48.000
Quyền cho tiện ích thường được chia sẻ với vùng chứa ứng dụng của nó.

00:19:48.000 --> 00:19:54.000
Tại đây, bạn có thể xem danh sách các quyền vị trí có sẵn có sẵn từ ứng dụng Cài đặt.

00:19:54.000 --> 00:20:08.000
Nếu người dùng chọn "Trong khi sử dụng ứng dụng", vị trí của người dùng chỉ có sẵn cho tiện ích khi ứng dụng vùng chứa của tiện ích ở phía trước cho người dùng hoặc các tình huống khác coi ứng dụng đang được sử dụng, chẳng hạn như đang ở trong phiên điều hướng.

00:20:08.000 --> 00:20:19.000
Nếu người dùng chọn "Trong khi sử dụng ứng dụng hoặc tiện ích", thì vị trí có sẵn giống như trước đây với "Trong khi sử dụng ứng dụng", nhưng với một phụ cấp bổ sung dành riêng cho tiện ích.

00:20:19.000 --> 00:20:26.000
Điều này cho phép quyền tiện ích nhận vị trí tối đa 15 phút sau khi tiện ích được xem lần cuối.

00:20:26.000 --> 00:20:41.000
Và khi vị trí không thể được giải quyết với một trong hai quyền này được đặt, hãy xem xét nội dung thay thế, thậm chí có khả năng là nội dung trước đó nếu nó có sẵn hoặc chỉ đơn giản là chỉ ra rằng vị trí không thể được giải quyết.

00:20:41.000 --> 00:20:48.000
Nếu người dùng chọn "Luôn luôn" cho phép, tiện ích sẽ luôn có quyền truy cập vị trí có sẵn.

00:20:48.000 --> 00:20:51.000
Cuối cùng, hãy nói về việc xây dựng các tiện ích có thể tùy chỉnh.

00:20:51.000 --> 00:20:58.000
Chúng ta sẽ nói về kích thước, loại và cấu hình như một phương tiện để người dùng cá nhân hóa trải nghiệm tiện ích của họ.

00:20:58.000 --> 00:21:00.000
Bây giờ, các vật dụng có đủ kích cỡ khác nhau.

00:21:00.000 --> 00:21:06.000
Và bạn nên hỗ trợ càng nhiều kích cỡ càng tốt để người dùng có thể lựa chọn khi đặt tiện ích của họ.

00:21:06.000 --> 00:21:17.000
Hãy nhớ rằng các phương sai nhỏ tồn tại trong kích thước giữa các thiết bị và tốt nhất là sử dụng phần đệm tiêu chuẩn hệ thống, lề, kiểu văn bản và kích thước văn bản khi có thể.

00:21:17.000 --> 00:21:22.000
Bây giờ, nếu bạn nhìn vào chiếc iPad này, nó thực sự được chuyển đổi thành một buổi giới thiệu nội dung.

00:21:22.000 --> 00:21:31.000
Nếu nó không rõ ràng, một kích thước mới đã được thêm vào trong iOS 15 dành riêng cho iPad và chúng tôi gọi nó là Extra Large.

00:21:31.000 --> 00:21:32.000
Đây rồi để bạn có thể nhìn rõ hơn.

00:21:32.000 --> 00:21:39.000
Nó có cùng chiều cao với tiện ích lớn nhưng rộng hơn để hiển thị nhiều nội dung hơn có sẵn trên iPad.

00:21:39.000 --> 00:21:42.000
Và đây là cách bạn thêm nó vào tiện ích của mình.

00:21:42.000 --> 00:21:47.000
Ở đây tôi đã thêm nó vào một cấu hình tiện ích hiện có đã hỗ trợ gia đình systemLarge.

00:21:47.000 --> 00:22:00.000
Theo mặc định, nếu bạn không chỉ định các gia đình được hỗ trợ trên cấu hình tiện ích của mình, thì kích thước mới sẽ được hỗ trợ tự động nếu bạn xây dựng bằng iOS 15 SDK trở lên.

00:22:00.000 --> 00:22:03.000
Trục tiếp theo để cá nhân hóa là loại tiện ích.

00:22:03.000 --> 00:22:08.000
Các loại tiện ích cung cấp các quan điểm khác nhau về dữ liệu hoặc nội dung của bạn.

00:22:08.000 --> 00:22:12.000
Vì vậy, hãy suy nghĩ về loại tiện ích nào có thể có ý nghĩa nhất trong ứng dụng của bạn.

00:22:12.000 --> 00:22:16.000
Cách tốt nhất để mô tả những điều này thực sự là bằng ví dụ.

00:22:16.000 --> 00:22:18.000
Đây là một ví dụ từ Clock.

00:22:18.000 --> 00:22:30.000
Ở bên trái, chúng tôi có một tiện ích Thành phố theo dõi thời gian của một thành phố duy nhất và ở bên phải, một tiện ích Đồng hồ Thế giới có thể chứa nhiều thành phố khác nhau trong cùng một chế độ xem.

00:22:30.000 --> 00:22:31.000
Đây là một ví dụ khác từ Cổ phiếu.

00:22:31.000 --> 00:22:40.000
Ở bên trái, có một tiện ích Biểu tượng cổ phiếu hiển thị giá cổ phiếu cho một cổ phiếu nhất định-- trong trường hợp này là Apple-- và ở bên phải, một tiện ích Tổng quan.

00:22:40.000 --> 00:22:45.000
Tiện ích Tổng quan sẽ hiển thị một loạt các cổ phiếu được phản ánh trong ứng dụng Cổ phiếu của người dùng.

00:22:45.000 --> 00:22:49.000
Vậy làm thế nào để bạn xuất bản những loại vật dụng khác nhau này?

00:22:49.000 --> 00:22:53.000
Chà, xuất bản nhiều loại vật dụng là siêu tầm thường.

00:22:53.000 --> 00:23:00.000
Sử dụng ví dụ Cổ phiếu đó từ trước, ở đây tôi có tiện ích Biểu tượng và tiện ích Tổng quan ở trên cùng bên trái.

00:23:00.000 --> 00:23:08.000
Để xuất bản những thứ này, bạn chỉ cần trả lại các cấu hình tiện ích khác nhau trong đối tượng WidgetBundle và bao gồm thuộc tính @main cho WidgetBundle.

00:23:08.000 --> 00:23:11.000
Thật dễ dàng.

00:23:11.000 --> 00:23:15.000
Lưu ý rằng thứ tự các tiện ích được xác định trong gói cũng rất quan trọng.

00:23:15.000 --> 00:23:19.000
Thứ tự này phản ánh cách các tiện ích của bạn sẽ xuất hiện trong thư viện tiện ích.

00:23:19.000 --> 00:23:24.000
Vì vậy, hãy đảm bảo rằng tiện ích đầu tiên được liệt kê là trường hợp sử dụng anh hùng của bạn.

00:23:24.000 --> 00:23:32.000
Cuối cùng, không thể tự động xuất bản hoặc tự động rút lại tính khả dụng của tiện ích sau khi ứng dụng của bạn được cài đặt.

00:23:32.000 --> 00:23:39.000
Vì vậy, một số sự quan tâm và suy nghĩ nên được áp dụng xung quanh việc hỗ trợ các vật dụng của bạn theo thời gian.

00:23:39.000 --> 00:23:42.000
Trục cuối cùng cho khả năng tùy chỉnh là thông qua cấu hình.

00:23:42.000 --> 00:23:47.000
Và các tiện ích hỗ trợ hai loại: cấu hình tĩnh và dựa trên ý định.

00:23:47.000 --> 00:23:53.000
Cấu hình tiện ích tĩnh cung cấp cùng một nội dung cho mỗi ví dụ tiện ích.

00:23:53.000 --> 00:23:55.000
Hãy nhớ ví dụ Tổng quan về Cổ phiếu từ trước đây?

00:23:55.000 --> 00:24:02.000
Chà, mỗi người sẽ hiển thị chính xác cùng một nội dung ngay cả khi chúng ở các vị trí khác nhau trên thiết bị của người dùng.

00:24:02.000 --> 00:24:11.000
Các tiện ích tĩnh cực kỳ đơn giản và chúng là các định nghĩa tiện ích thanh lịch vì chúng không cần cấu hình hoặc thiết lập từ người dùng.

00:24:11.000 --> 00:24:18.000
Mặt khác, cấu hình tiện ích Intent cung cấp nội dung do người dùng định cấu hình cho từng trường hợp.

00:24:18.000 --> 00:24:22.000
Kiểm tra các tiện ích Biểu tượng Chứng khoán này ở bên phải.

00:24:22.000 --> 00:24:27.000
Người dùng này đã định cấu hình nhiều phiên bản khác nhau, mỗi phiên bản hiển thị một cổ phiếu khác nhau.

00:24:27.000 --> 00:24:28.000
Bây giờ, đây là một số thứ khá ngọt ngào.

00:24:28.000 --> 00:24:35.000
Và người dùng thậm chí có thể kết hợp tất cả những thứ này thành một chồng tiện ích trên Màn hình chính của họ để lật qua để tiết kiệm dung lượng.

00:24:35.000 --> 00:24:39.000
Vậy những thứ này được cấu hình như thế nào bởi người dùng, bạn có thể hỏi.

00:24:39.000 --> 00:24:44.000
Chà, từ quan điểm của người dùng, hệ thống sẽ cung cấp tất cả các phần giao diện người dùng xung quanh.

00:24:44.000 --> 00:24:50.000
Và sau khi nhấn vào một tiện ích ở chế độ Chỉnh sửa hỗ trợ Ý định, đĩa cấu hình được hiển thị.

00:24:50.000 --> 00:24:54.000
Nó trình bày một danh sách các tham số từ Ý định mà người dùng có thể định cấu hình.

00:24:54.000 --> 00:25:02.000
Và trong ví dụ này, có một tham số duy nhất để Biểu tượng theo dõi và giá trị của nó hiện là chuỗi AAPL cho cổ phiếu Apple.

00:25:02.000 --> 00:25:07.000
Bây giờ, khi người dùng nhấn vào một tham số, một bộ điều khiển đầu vào sẽ xuất hiện để thu thập đầu vào từ người dùng.

00:25:07.000 --> 00:25:10.000
Và sau khi hoàn thành, tiện ích sẽ tự động cập nhật.

00:25:10.000 --> 00:25:20.000
Bây giờ, có rất nhiều tùy chỉnh mà bạn có thể thực hiện với một Ý định và có một cuộc nói chuyện tuyệt vời từ WWDC 2020 mà tôi sẽ chia sẻ trong giây lát để giúp bạn bắt đầu nếu bạn muốn cấu hình Ý định.

00:25:20.000 --> 00:25:29.000
Trong thời gian chờ đợi, hãy nhanh chóng làm nổi bật sự khác biệt giữa mã hóa một tiện ích dựa trên Ý định so với cấu hình tĩnh.

00:25:29.000 --> 00:25:31.000
Cấu hình tĩnh thực sự đơn giản.

00:25:31.000 --> 00:25:36.000
Bạn chỉ cần khởi tạo một đối tượng StaticConfiguration với TimelineProvider tiêu chuẩn.

00:25:36.000 --> 00:25:40.000
Hãy đối chiếu điều đó với cấu hình Ý định.

00:25:40.000 --> 00:25:49.000
Tất cả những gì khác biệt ở đây là StaticConfiguration được thay thế bằng IntentConfiguration và TimelineProvider được thay thế bằng IntentTimelineProvider.

00:25:49.000 --> 00:25:57.000
Mỗi cái trong số này có một giao diện được sửa đổi một chút để hỗ trợ Ý định và điều này là để bạn có thể nhận được Ý định do người dùng định cấu hình khi điền dòng thời gian của mình.

00:25:57.000 --> 00:26:12.000
Để có cái nhìn chi tiết hơn về việc tạo và định cấu hình Ý định cho các tiện ích, bao gồm tổng quan về các loại dữ liệu khác nhau được hỗ trợ và chúng trông như thế nào từ giao diện người dùng cấu hình, hãy xem bài nói chuyện "Thêm cấu hình và trí thông minh vào tiện ích của bạn" từ WWDC 2020.

00:26:12.000 --> 00:26:23.000
Để kết thúc, chúng tôi đã xem xét cách các tiện ích tuyệt vời sử dụng các mục nhập dòng thời gian của chúng, làm chủ chính sách tải lại và thích ứng với bản trình bày và môi trường vật lý tiềm năng của chúng.

00:26:23.000 --> 00:26:30.000
Lên kế hoạch cung cấp các kích thước, loại và cấu hình khác nhau để mang lại trải nghiệm năng động và có thể cá nhân hóa cho người dùng của bạn.

00:26:30.000 --> 23:59:59.000
Cảm ơn bạn.

