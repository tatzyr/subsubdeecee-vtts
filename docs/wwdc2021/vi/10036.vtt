WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:11.000
Xin chào.

00:00:11.000 --> 00:00:13.000
Chào mừng đến với buổi Phân tích Âm thanh tại WWDC.

00:00:13.000 --> 00:00:15.000
Tên tôi là Jon Huang.

00:00:15.000 --> 00:00:17.000
Tôi là một nhà nghiên cứu trong nhóm âm thanh.

00:00:17.000 --> 00:00:25.000
Hôm nay, đồng nghiệp của tôi, Kevin, và tôi sẽ giới thiệu những cải tiến để phân loại âm thanh được cung cấp thông qua khung SoundAnalysis và CreateML.

00:00:25.000 --> 00:00:31.000
Vào năm 2019, chúng tôi đã có thể đào tạo các mô hình phân loại âm thanh bằng cách sử dụng CreateML.

00:00:31.000 --> 00:00:37.000
Chúng tôi đã chỉ ra rằng thật dễ dàng để tạo ra các mô hình phân loại âm thanh và triển khai chúng trong các thiết bị Apple.

00:00:37.000 --> 00:00:45.000
Khi bạn sử dụng khung này, tất cả các tính toán được tối ưu hóa để tăng tốc phần cứng và được thực hiện cục bộ trên thiết bị.

00:00:45.000 --> 00:00:50.000
Điều này giúp bảo vệ quyền riêng tư của người dùng vì âm thanh không bao giờ được gửi lên Đám mây.

00:00:50.000 --> 00:00:56.000
Chúng tôi đã tận dụng khung Phân tích Âm thanh để giới thiệu Tính năng Trợ năng được gọi là Nhận dạng Âm thanh.

00:00:56.000 --> 00:01:06.000
Tính năng này có thể cung cấp thông báo cho người dùng khi nghe thấy một số âm thanh nhất định trong môi trường như báo thức, vật nuôi và các âm thanh gia đình khác.

00:01:06.000 --> 00:01:09.000
Đây chỉ là một ứng dụng phân loại âm thanh.

00:01:09.000 --> 00:01:12.000
Hãy xem chúng ta có thể làm gì khác với nó.

00:01:12.000 --> 00:01:17.000
Ứng dụng demo đang sử dụng micrô tích hợp trên máy Mac của tôi để nghe âm thanh trong môi trường.

00:01:17.000 --> 00:01:24.000
Nó truyền âm thanh qua bộ phân loại âm thanh và hiển thị kết quả phân loại trong giao diện người dùng.

00:01:24.000 --> 00:01:27.000
Vì vậy, khi tôi đang trò chuyện với bạn, lời nói được phát hiện.

00:01:27.000 --> 00:01:30.000
Vui lòng ngồi lại với tôi một chút và xem điều gì sẽ xảy ra.

00:01:30.000 --> 00:01:32.000
Làm cho bản thân thoải mái.

00:01:32.000 --> 00:01:34.000
Hãy bắt đầu với một chút âm nhạc.

00:01:34.000 --> 00:01:38.000
Này Siri, chơi "Catch a Vibe" của Karun và Mombru.

00:01:38.000 --> 00:01:41.000
Hiện đang chơi "Catch a Vibe" của Karun và Mombru.

00:01:41.000 --> 00:01:46.000
♪ ♪

00:01:46.000 --> 00:01:49.000
♪ Ồ, ồ, ồ ♪

00:01:49.000 --> 00:01:53.000
Lưu ý rằng bộ phân loại đang chọn cả âm nhạc và âm thanh hát.

00:01:53.000 --> 00:01:56.000
♪ Tôi không biết ai cả ♪

00:01:56.000 --> 00:01:59.000
♪ Ai cảm thấy đúng như vậy ♪

00:01:59.000 --> 00:02:01.000
♪ Không biết ai tạo ra tôi ♪

00:02:01.000 --> 00:02:03.000
♪ Nắm bắt một sự rung cảm, cảm nhận tần suất... ♪

00:02:03.000 --> 00:02:05.000
Bây giờ hãy cùng tôi uống trà.

00:02:05.000 --> 00:02:07.000
♪ Cảm thấy ổn, em yêu ♪

00:02:07.000 --> 00:02:08.000
♪ Chúng ta có thể thấy ♪

00:02:08.000 --> 00:02:14.000
♪ Nếu chúng ta có thể đúng ♪

00:02:14.000 --> 00:02:18.000
♪ Xem nếu đó là điều gì đó về cách bạn cười ♪

00:02:18.000 --> 00:02:20.000
♪ Nín thở và, em yêu, chúng ta có thể ♪

00:02:20.000 --> 00:02:23.000
♪ Nắm bắt một sự rung cảm, cảm nhận tần số ♪

00:02:23.000 --> 00:02:25.000
♪ Nắm bắt một sự rung cảm, chỉ có bạn và tôi ♪

00:02:25.000 --> 00:02:27.000
♪ Cảm thấy ổn, em yêu, chúng ta có thể thấy ♪

00:02:27.000 --> 00:02:29.000
♪ Nếu chúng ta có thể ♪

00:02:29.000 --> 00:02:33.000
♪ Tôi đã nói, tôi đã nói ♪

00:02:33.000 --> 00:02:35.000
♪ Nó là một phần của tôi ♪

00:02:35.000 --> 00:02:37.000
♪ Tất cả những phần bạn thấy ♪

00:02:37.000 --> 00:02:38.000
♪ Bạn nên tự hào về... ♪

00:02:38.000 --> 00:02:42.000
Đây là trà ngon.

00:02:42.000 --> 00:02:45.000
♪ Em là con của anh, trời ơi ♪

00:02:45.000 --> 00:02:47.000
♪ Bạn là một chiếc xe đẩy, tôi hiểu rồi... ♪

00:02:47.000 --> 00:02:50.000
♪ Làm sao điều này có thể xảy ra? ♪

00:02:50.000 --> 00:02:51.000
♪ Làm sao điều này có thể xảy ra?... ♪

00:02:51.000 --> 00:02:54.000
Này, Siri. Dừng lại.

00:02:54.000 --> 00:03:03.000
Bây giờ thật hợp lý khi cho rằng tôi đã thu thập một số dữ liệu cho từng danh mục âm thanh này và đào tạo một mô hình tùy chỉnh bằng CreateML.

00:03:03.000 --> 00:03:09.000
Vâng, tôi có thể đã làm điều đó, nhưng thực ra, bộ phân loại được sử dụng đã được tích hợp sẵn.

00:03:09.000 --> 00:03:15.000
Mới trong năm nay, chúng tôi có một bộ phân loại âm thanh được tích hợp ngay trong khuôn khổ Phân tích Âm thanh.

00:03:15.000 --> 00:03:19.000
Việc bật phân loại âm thanh trong ứng dụng của bạn chưa bao giờ dễ dàng hơn thế.

00:03:19.000 --> 00:03:24.000
Nó được hỗ trợ trên tất cả các nền tảng.

00:03:24.000 --> 00:03:28.000
Trình phân loại tích hợp là tất cả về việc đơn giản hóa trải nghiệm của nhà phát triển.

00:03:28.000 --> 00:03:40.000
Nó loại bỏ nhu cầu thu thập và dán nhãn một lượng lớn dữ liệu, chuyên môn học máy và âm thanh chuyên biệt, và rất nhiều sức mạnh tính toán để phát triển một mô hình có độ chính xác cao.

00:03:40.000 --> 00:03:48.000
Bạn càng ít phải lo lắng về những chi tiết này, bạn càng có nhiều thời gian để làm phong phú thêm trải nghiệm người dùng trong ứng dụng của mình.

00:03:48.000 --> 00:03:52.000
Chỉ cần một vài dòng mã để cho phép phân loại âm thanh.

00:03:52.000 --> 00:03:54.000
Tôi sẽ chỉ cho bạn những gì bộ phân loại này có thể làm.

00:03:54.000 --> 00:03:58.000
Có hơn 300 danh mục để bạn sử dụng.

00:03:58.000 --> 00:04:00.000
Chúng ta hãy xem xét kỹ hơn.

00:04:00.000 --> 00:04:09.000
Chúng ta có thể phân loại âm thanh của động vật nuôi, động vật nuôi và động vật hoang dã.

00:04:09.000 --> 00:04:18.000
Đối với âm nhạc, nhiều nhạc cụ có thể được nhận ra: nhạc cụ bàn phím, bộ gõ, nhạc cụ dây, nhạc cụ gió.

00:04:18.000 --> 00:04:27.000
Chúng ta có thể phát hiện các âm thanh khác nhau của con người: hoạt động nhóm, âm thanh hô hấp, phát âm.

00:04:27.000 --> 00:04:33.000
Sau đó, có âm thanh của những thứ như phương tiện, báo động, dụng cụ, chất lỏng và nhiều hơn thế nữa.

00:04:33.000 --> 00:04:37.000
Các danh mục sẵn sàng sử dụng này có sẵn để bạn dùng thử.

00:04:37.000 --> 00:04:42.000
Tôi sẽ chuyển nó cho Kevin để hướng dẫn bạn cách sử dụng bộ phân loại âm thanh này.

00:04:42.000 --> 00:04:44.000
Cảm ơn, Jon.

00:04:44.000 --> 00:04:49.000
Xin chào, tôi là Kevin, một kỹ sư phần mềm trong nhóm Âm thanh.

00:04:49.000 --> 00:04:56.000
Tôi muốn chỉ cho bạn cách sử dụng trình phân loại âm thanh tích hợp mới bằng cách xem qua một ứng dụng nhỏ mà tôi đã xây dựng.

00:04:56.000 --> 00:05:04.000
Tôi đã hy vọng Jon sẽ cho thấy trình phân loại hoạt động tốt như thế nào với chuông bò, nhưng vì nó không phù hợp với bản demo của anh ấy, tôi đã nảy ra một ý tưởng khác.

00:05:04.000 --> 00:05:13.000
Tôi có một số phương tiện truyền thông trên máy Mac của mình mà tôi đã thu thập trong khi chuẩn bị cho phiên này và tôi khá chắc chắn rằng tôi có một số cảnh quay cũ có chứa chuông bò.

00:05:13.000 --> 00:05:18.000
Tôi rất muốn cho bạn xem, nhưng trước tiên tôi phải tìm nó.

00:05:18.000 --> 00:05:26.000
Điều này có nghĩa là tôi sẽ phải tìm đúng tệp và tôi sẽ phải nhìn vào bên trong để tìm đúng phần.

00:05:26.000 --> 00:05:29.000
Vậy tôi sẽ làm điều này như thế nào?

00:05:29.000 --> 00:05:38.000
Tôi sẽ viết một chương trình đơn giản sử dụng trình phân loại âm thanh tích hợp để đọc một tệp và cho tôi biết liệu một âm thanh nhất định có ở bên trong hay không.

00:05:38.000 --> 00:05:47.000
Nếu âm thanh được tìm thấy, chương trình có thể sử dụng trình phân loại để cho tôi biết thời gian nó xảy ra.

00:05:47.000 --> 00:05:57.000
Sau đó, tôi có thể sử dụng Phím tắt, hiện đã có trên macOS, để tạo quy trình làm việc chạy chương trình của tôi trên nhiều tệp.

00:05:57.000 --> 00:06:07.000
Khi chương trình của tôi tìm thấy âm thanh, quy trình làm việc có thể tự động sử dụng thời gian phát hiện được báo cáo để trích xuất video clip có chứa âm thanh.

00:06:07.000 --> 00:06:11.000
Điều này sẽ hoạt động tốt cho việc tìm kiếm một clip chuông bò.

00:06:11.000 --> 00:06:15.000
Vì vậy, hãy xem nó hoạt động.

00:06:15.000 --> 00:06:19.000
Ở đây, tôi có một thư mục đầy video.

00:06:19.000 --> 00:06:27.000
Tôi sẽ chọn tất cả các tệp và khởi động phím tắt của mình bằng cách sử dụng menu Hành động nhanh.

00:06:27.000 --> 00:06:35.000
Tôi được yêu cầu chọn âm thanh mà tôi muốn tìm, vì vậy từ danh sách các tùy chọn, tôi sẽ chọn Cowbell.

00:06:35.000 --> 00:06:45.000
Bây giờ, phím tắt của tôi đang chạy, và chỉ sau một vài phút, nó tìm thấy âm thanh tôi đang tìm kiếm và hiển thị nó cho tôi trong cửa sổ Finder.

00:06:45.000 --> 00:06:47.000
Hãy cùng xem nào.

00:06:47.000 --> 00:06:54.000
Trông ổn đấy, Jon.

00:06:54.000 --> 00:06:59.000
Chúng ta hãy xem xét kỹ hơn phím tắt mà tôi đã sử dụng.

00:06:59.000 --> 00:07:06.000
Khi phím tắt của tôi bắt đầu, nó sẽ thu thập một danh sách tất cả các âm thanh mà nó có thể nhận ra và nó yêu cầu tôi chọn một âm thanh.

00:07:06.000 --> 00:07:15.000
Sử dụng lựa chọn của tôi, nó truy cập từng tệp mà tôi đã chọn trong Finder và tìm kiếm âm thanh bên trong.

00:07:15.000 --> 00:07:25.000
Khi âm thanh của tôi được phát hiện, nó sẽ trích xuất một vài giây từ video vào khoảng thời gian âm thanh xảy ra và cho tôi xem clip kết quả.

00:07:25.000 --> 00:07:31.000
Trong số các bước này, hai trong số chúng sử dụng bộ phân loại tích hợp sẵn.

00:07:31.000 --> 00:07:41.000
Đây là các bước mà tôi đã triển khai trong ứng dụng tùy chỉnh của riêng mình để Phím tắt sử dụng theo yêu cầu.

00:07:41.000 --> 00:07:53.000
Mặc dù tôi sẽ không nói về Phím tắt chi tiết hơn, nhưng nếu bạn tò mò muốn tìm hiểu thêm, vui lòng tham khảo phiên WWDC có tựa đề "Gặp gỡ Phím tắt cho macOS".

00:07:53.000 --> 00:07:59.000
Bây giờ hãy xem xét việc triển khai cho hai hành động tùy chỉnh của ứng dụng của tôi.

00:07:59.000 --> 00:08:04.000
Hành động đầu tiên báo cáo tất cả các âm thanh mà ứng dụng có thể nhận ra.

00:08:04.000 --> 00:08:11.000
Vì ứng dụng đang sử dụng bộ phân loại âm thanh tích hợp, nó có thể nhận ra vài trăm âm thanh.

00:08:11.000 --> 00:08:15.000
Đây là một chức năng tôi đã viết để có được những âm thanh này.

00:08:15.000 --> 00:08:24.000
Tôi tạo SNClassifySoundRequest bằng cách sử dụng trình khởi tạo mới cho phép tôi chọn trình phân loại tích hợp sẵn.

00:08:24.000 --> 00:08:31.000
Khi tôi có yêu cầu này, tôi có thể sử dụng nó để truy vấn danh sách các âm thanh mà trình phân loại hỗ trợ.

00:08:31.000 --> 00:08:37.000
Hành động thứ hai của ứng dụng cho Shortcuts biết khi nghe thấy âm thanh trong một tệp.

00:08:37.000 --> 00:08:46.000
Để thực hiện điều này, tôi sẽ thực hiện phân loại âm thanh và báo cáo lại lần đầu tiên âm thanh được phát hiện, nếu nó được phát hiện.

00:08:46.000 --> 00:08:51.000
Để thực hiện phân loại âm thanh, tôi sẽ cần chuẩn bị ba đối tượng.

00:08:51.000 --> 00:08:59.000
Đầu tiên, tôi sẽ cần SNClassifySoundRequest, mà tôi có thể sử dụng để định cấu hình phân loại âm thanh.

00:08:59.000 --> 00:09:08.000
Thứ hai, tôi sẽ cần một SNAudioFileAnalyzer, cho phép tôi nhắm mục tiêu phân loại đối với một tệp cụ thể.

00:09:08.000 --> 00:09:12.000
Đối tượng thứ ba sẽ cần thêm một chút chú ý.

00:09:12.000 --> 00:09:18.000
Tôi sẽ cần xác định loại Người quan sát của riêng mình, loại này sẽ xử lý kết quả phân loại.

00:09:18.000 --> 00:09:25.000
Bỏ qua Người quan sát ngay bây giờ, đây là một số mã để chuẩn bị hai đối tượng đầu tiên trong số này.

00:09:25.000 --> 00:09:38.000
Tôi có thể tạo SNClassifySoundRequest bằng cách sử dụng trình phân loại tích hợp và tôi có thể tạo SNAudioFileAnalyzer bằng URL đến tệp tôi muốn phân loại.

00:09:38.000 --> 00:09:50.000
Nếu, tại thời điểm này, tôi đã có một Người quan sát sẵn sàng hoạt động, sẽ dễ dàng để bắt đầu phân loại âm thanh, nhưng xác định rằng Người quan sát là phần còn thiếu.

00:09:50.000 --> 00:09:52.000
Vậy hãy làm điều đó.

00:09:52.000 --> 00:10:01.000
Tôi đang bắt đầu ở đây với một Người quan sát trần kế thừa từ NSObject và phù hợp với giao thức SNResultsObserving.

00:10:01.000 --> 00:10:11.000
Tôi sẽ khởi tạo các trường hợp với nhãn âm thanh mà tôi muốn tìm kiếm và tôi sẽ thêm một biến thành viên CMTime để lưu trữ thời gian mà tôi phát hiện ra âm thanh.

00:10:11.000 --> 00:10:18.000
Tôi chỉ cần thực hiện yêu cầu: phương pháp kết quả didProduce.

00:10:18.000 --> 00:10:29.000
Phương pháp này sẽ được gọi khi kết quả được tạo ra bằng cách phân loại âm thanh, vì vậy tôi hy vọng sẽ nhận được các trường hợp của SNClassificationResult.

00:10:29.000 --> 00:10:39.000
Tôi có thể sử dụng phương pháp classificationForIdentifier của kết quả để trích xuất thông tin về nhãn mà tôi đang tìm kiếm.

00:10:39.000 --> 00:10:49.000
Tôi sẽ truy vấn điểm tin cậy liên quan đến nhãn và nếu điểm đó vượt quá một ngưỡng nhất định, tôi sẽ xem xét âm thanh sẽ được phát hiện.

00:10:49.000 --> 00:10:59.000
Khi tôi nhận thấy phát hiện lần đầu tiên, tôi sẽ tiết kiệm thời gian âm thanh xảy ra để tôi có thể cung cấp nó cho Shortcuts sau này.

00:10:59.000 --> 00:11:07.000
Cùng với đó, Người quan sát của tôi đã hoàn thành và tôi có tất cả các phần cần thiết để xác định khi nào âm thanh xuất hiện trong một tệp.

00:11:07.000 --> 00:11:12.000
Ví dụ này đề cập đến hai chủ đề quan trọng mà tôi muốn thảo luận thêm.

00:11:12.000 --> 00:11:20.000
Đầu tiên, tôi sẽ nói về thời gian phát hiện, và sau đó tôi sẽ nói về các ngưỡng phát hiện.

00:11:20.000 --> 00:11:24.000
Hãy bắt đầu với thời gian phát hiện.

00:11:24.000 --> 00:11:30.000
Khi bạn phân loại âm thanh, tín hiệu sẽ bị chia thành các cửa sổ chồng chéo.

00:11:30.000 --> 00:11:38.000
Đối với mỗi cửa sổ này, bạn sẽ nhận được kết quả cho bạn biết âm thanh nào đã được phát hiện và mức độ tự tin.

00:11:38.000 --> 00:11:45.000
Bạn cũng sẽ nhận được một khoảng thời gian, cho bạn biết phần nào của âm thanh đã được phân loại.

00:11:45.000 --> 00:11:52.000
Trong ứng dụng của tôi, khi tôi phát hiện ra âm thanh, tôi sử dụng phạm vi thời gian của kết quả để xác định thời điểm âm thanh xảy ra.

00:11:52.000 --> 00:11:57.000
Nhưng phạm vi thời gian có thể bị ảnh hưởng khi thời lượng của một cửa sổ thay đổi.

00:11:57.000 --> 00:12:06.000
Bạn có thể tùy chỉnh thời lượng cửa sổ để làm cho nó lớn hay nhỏ dựa trên trường hợp sử dụng của bạn.

00:12:06.000 --> 00:12:12.000
Cửa sổ ngắn hoạt động tốt khi làm việc với âm thanh ngắn, như tiếng trống.

00:12:12.000 --> 00:12:19.000
Điều này là do bạn có thể nắm bắt tất cả các tính năng quan trọng của âm thanh đó trong một khoảng thời gian nhỏ.

00:12:19.000 --> 00:12:23.000
Cửa sổ nhỏ không cắt ra bất kỳ thông tin quan trọng nào.

00:12:23.000 --> 00:12:33.000
Ưu điểm của việc sử dụng thời lượng cửa sổ nhỏ là nó cho phép bạn xác định chính xác hơn thời điểm âm thanh xảy ra.

00:12:33.000 --> 00:12:38.000
Nhưng thời lượng cửa sổ nhỏ có thể không phù hợp khi làm việc với âm thanh dài hơn.

00:12:38.000 --> 00:12:46.000
Ví dụ, còi báo động có thể chứa cả cao độ tăng và giảm trong một khoảng thời gian dài hơn.

00:12:46.000 --> 00:12:54.000
Chụp tất cả các cao độ này lại với nhau trong một cửa sổ duy nhất có thể giúp phân loại âm thanh phát hiện chính xác âm thanh.

00:12:54.000 --> 00:13:02.000
Nói chung, thật tốt khi sử dụng thời lượng cửa sổ đủ lâu để ghi lại tất cả các phần quan trọng của âm thanh mà bạn quan tâm.

00:13:02.000 --> 00:13:10.000
Nếu bạn muốn chỉnh sửa thời lượng cửa sổ, bạn có thể đặt thuộc tính windowDuration của SNClassifySoundRequest.

00:13:10.000 --> 00:13:16.000
Tuy nhiên, lưu ý rằng không phải tất cả các khoảng thời gian cửa sổ đều được hỗ trợ.

00:13:16.000 --> 00:13:20.000
Các bộ phân loại khác nhau có thể hỗ trợ các khoảng thời gian cửa sổ khác nhau.

00:13:20.000 --> 00:13:28.000
Bạn có thể kiểm tra thời lượng cửa sổ nào được hỗ trợ bằng cách đọc thuộc tính windowDurationConstraint của SNClassifySoundRequest.

00:13:28.000 --> 00:13:34.000
Bộ phân loại tích hợp hỗ trợ thời lượng cửa sổ dài từ 1/2 giây đến 15 giây.

00:13:34.000 --> 00:13:43.000
Thời lượng từ một giây trở lên là điểm khởi đầu tuyệt vời khi áp dụng trình phân loại trong ứng dụng của bạn.

00:13:43.000 --> 00:13:47.000
Hãy nói tiếp theo về ngưỡng tin cậy.

00:13:47.000 --> 00:13:56.000
Trong ứng dụng của mình, tôi đã xem xét một âm thanh được phát hiện bất cứ khi nào độ tin cậy cho âm thanh đó tăng lên trên một ngưỡng cố định.

00:13:56.000 --> 00:14:05.000
Tôi đã chọn giá trị 0,5 cho ngưỡng của mình, nhưng có một số điều cần xem xét khi chọn ngưỡng cho ứng dụng của riêng bạn.

00:14:05.000 --> 00:14:10.000
Trình phân loại có thể phát hiện nhiều âm thanh cùng một lúc.

00:14:10.000 --> 00:14:17.000
Khi điều này xảy ra, bạn có thể nhận thấy rằng một số nhãn ghi điểm với độ tin cậy cao.

00:14:17.000 --> 00:14:26.000
Không giống như khi sử dụng một mô hình tùy chỉnh được đào tạo bằng CreateML, điểm nhãn không cộng lại với giá trị của một mô hình.

00:14:26.000 --> 00:14:32.000
Các bí mật là độc lập và không nên so sánh với nhau.

00:14:32.000 --> 00:14:42.000
Bởi vì điểm tin cậy là độc lập, bạn có thể thấy hữu ích khi chọn các ngưỡng tin cậy khác nhau cho các âm thanh khác nhau.

00:14:42.000 --> 00:14:44.000
Chọn một ngưỡng liên quan đến sự đánh đổi.

00:14:44.000 --> 00:14:58.000
Ngưỡng tin cậy cao hơn làm giảm xác suất âm thanh sẽ được phát hiện sai, nhưng nó cũng làm tăng khả năng phát hiện thực sự sẽ bị bỏ lỡ vì nó không đủ mạnh.

00:14:58.000 --> 00:15:06.000
Khi bạn chọn một ngưỡng cho đơn đăng ký của mình, bạn sẽ cần tìm một giá trị đạt được sự cân bằng phù hợp của các yếu tố này cho trường hợp sử dụng của bạn.

00:15:06.000 --> 00:15:15.000
Lưu ý rằng điểm tin cậy có thể thay đổi khi bạn đặt thời lượng cửa sổ tùy chỉnh, vì vậy điều này cũng có thể ảnh hưởng đến ngưỡng của bạn.

00:15:15.000 --> 00:15:21.000
Một điều cuối cùng cần ghi nhớ khi sử dụng bộ phân loại tích hợp là một số âm thanh tương tự nhau.

00:15:21.000 --> 00:15:32.000
Trong số lượng lớn âm thanh mà trình phân loại có thể xác định là một số nhóm âm thanh có thể khó phân biệt chỉ bằng âm thanh, ngay cả đối với con người.

00:15:32.000 --> 00:15:38.000
Nếu có thể, tốt nhất bạn nên chọn lọc về những âm thanh mà bạn chú ý đến.

00:15:38.000 --> 00:15:46.000
Bạn nên cố gắng chỉ xem những âm thanh có khả năng xảy ra trong bối cảnh mà ứng dụng của bạn sẽ được sử dụng.

00:15:46.000 --> 00:15:53.000
Với điều đó, hãy quay lại với Jon để tìm hiểu về những gì mới trong CreateML liên quan đến phân loại âm thanh.

00:15:53.000 --> 00:15:55.000
Cảm ơn, Kevin, vì ví dụ tuyệt vời đó.

00:15:55.000 --> 00:15:58.000
Tôi rất vui vì bạn đã vui vẻ với video chuông bò đó.

00:15:58.000 --> 00:16:08.000
Bây giờ hãy để tôi chỉ cho bạn những gì mới trong CreateML hoặc cụ thể là cách bạn có thể cải thiện các mô hình tùy chỉnh của mình bằng cách tận dụng sức mạnh của trình phân loại tích hợp.

00:16:08.000 --> 00:16:13.000
Trình phân loại tích hợp được đào tạo với rất nhiều dữ liệu trên một số lượng lớn các danh mục.

00:16:13.000 --> 00:16:18.000
Vì vậy, mô hình thực sự chứa rất nhiều kiến thức về phân loại âm thanh.

00:16:18.000 --> 00:16:24.000
Tất cả kiến thức này có thể được sử dụng để đào tạo mô hình tùy chỉnh của bạn bằng cách sử dụng CreateML.

00:16:24.000 --> 00:16:26.000
Tôi sẽ chỉ cho bạn cách thức hoạt động của nó.

00:16:26.000 --> 00:16:30.000
Bộ phân loại âm thanh có thể được tách thành hai mạng khác nhau.

00:16:30.000 --> 00:16:36.000
Phần đầu tiên là trình trích xuất tính năng và phần thứ hai là mô hình phân loại.

00:16:36.000 --> 00:16:41.000
Trình trích xuất tính năng, đôi khi được gọi là mô hình nhúng, là xương sống của mạng.

00:16:41.000 --> 00:16:47.000
Nó lấy một dạng sóng âm thanh và biến nó thành một không gian chiều thấp.

00:16:47.000 --> 00:16:55.000
Một bộ trích xuất tính năng được đào tạo tốt tổ chức các âm thanh tương tự vào các vị trí gần đó trong không gian.

00:16:55.000 --> 00:17:04.000
Ví dụ, âm thanh của guitar sẽ tụ lại với nhau nhưng được đặt cách xa tiếng trống và âm thanh xe hơi.

00:17:04.000 --> 00:17:07.000
Bây giờ, phần thứ hai của đường ống này là mô hình phân loại.

00:17:07.000 --> 00:17:13.000
Nó lấy đầu ra của trình trích xuất tính năng và tính toán xác suất lớp.

00:17:13.000 --> 00:17:22.000
Trình phân loại được hưởng lợi từ việc được ghép nối với trình trích xuất tính năng tốt, giống như trình trích xuất mà chúng tôi đã nhúng vào trình phân loại tích hợp sẵn.

00:17:22.000 --> 00:17:26.000
Chúng tôi đang cung cấp trình trích xuất tính năng của trình phân loại tích hợp cho bạn.

00:17:26.000 --> 00:17:28.000
Nó được gọi là Audio Feature Print.

00:17:28.000 --> 00:17:35.000
Khi bạn đào tạo mô hình tùy chỉnh của riêng mình trong CreateML, mô hình của bạn sẽ được ghép nối với Audio Feature Print.

00:17:35.000 --> 00:17:40.000
Với điều này, mô hình của bạn được hưởng lợi từ tất cả kiến thức có trong trình phân loại tích hợp sẵn.

00:17:40.000 --> 00:17:47.000
So với trình trích xuất tính năng thế hệ trước, Audio Feature Print có những cải tiến trên diện rộng.

00:17:47.000 --> 00:17:56.000
Mặc dù mạng này nhỏ hơn và nhanh hơn, nhưng nó đạt được độ chính xác cao hơn trên tất cả các bộ dữ liệu chuẩn mà chúng tôi so sánh.

00:17:56.000 --> 00:18:02.000
Và giống như trình phân loại tích hợp sẵn, các mô hình sử dụng Audio Feature Print hỗ trợ thời lượng cửa sổ linh hoạt.

00:18:02.000 --> 00:18:11.000
Bạn có thể chọn thời lượng cửa sổ dài để tối ưu hóa cho âm thanh như còi báo động hoặc thời lượng cửa sổ ngắn cho âm thanh như vòi trống.

00:18:11.000 --> 00:18:18.000
Audio Feature Print là trình trích xuất tính năng mặc định mới khi bạn đào tạo một mô hình tùy chỉnh bằng CreateML.

00:18:18.000 --> 00:18:24.000
Thời lượng Window là độ dài của âm thanh được sử dụng để tạo ra một tính năng duy nhất trong quá trình đào tạo.

00:18:24.000 --> 00:18:29.000
Nó mặc định là ba giây, nhưng bạn có thể điều chỉnh nó cho phù hợp với nhu cầu của mình.

00:18:29.000 --> 00:18:35.000
CreateML cung cấp cho bạn tùy chọn để chọn thời lượng cửa sổ từ 1/2 giây đến 15 giây.

00:18:35.000 --> 00:18:44.000
Để có ví dụ chi tiết hơn về việc đào tạo một mô hình tùy chỉnh, bạn có thể xem phiên 2019 về "Đào tạo Mô hình Phân loại Âm thanh trong CreateML."

00:18:44.000 --> 00:18:49.000
Nó cũng chỉ cho bạn cách sử dụng Khung phân tích âm thanh để chạy mô hình tùy chỉnh.

00:18:49.000 --> 00:18:52.000
Cảm ơn vì đã tham gia cùng chúng tôi trong phiên về Phân tích Âm thanh.

00:18:52.000 --> 00:18:56.000
Hôm nay, chúng tôi đã giới thiệu một trình phân loại âm thanh mới mạnh mẽ được tích hợp trong hệ điều hành.

00:18:56.000 --> 00:19:01.000
Cùng với nó, chúng tôi đã nâng cấp trình trích xuất tính năng trong CreateML.

00:19:01.000 --> 00:19:07.000
Những thứ này sẽ mở ra những khả năng mới và chúng tôi nóng lòng muốn xem bạn sẽ làm gì với chúng trong ứng dụng của mình.

00:19:07.000 --> 00:19:10.000
Tận hưởng phần còn lại của WWDC.

00:19:10.000 --> 23:59:59.000
[Nhạc lạc quan].

