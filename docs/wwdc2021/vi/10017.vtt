WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:11.000
Xin chào mọi người.

00:00:11.000 --> 00:00:12.000
Tôi là Michael LeHew từ nhóm Core Data.

00:00:12.000 --> 00:00:22.000
Và hôm nay, tôi thực sự vui mừng được nói chuyện với bạn về một số cải tiến mà nhóm đã thực hiện để làm việc với Core Data và Swift trở thành một trải nghiệm thực sự tuyệt vời.

00:00:22.000 --> 00:00:30.000
Tôi sẽ bắt đầu với một bài đánh giá về cách Core Data là một giải pháp tuyệt vời cho nhu cầu bền bỉ dữ liệu của khách hàng trên tất cả các nền tảng của Apple.

00:00:30.000 --> 00:00:38.000
Sau đó, tôi sẽ tiếp tục thảo luận về một số cách mà Core Data đã áp dụng các cơ hội đồng thời mới trong thời gian chạy Swift.

00:00:38.000 --> 00:00:45.000
Tiếp theo, tôi sẽ đề cập đến một số cải tiến mà chúng tôi đã thực hiện đối với API dữ liệu cốt lõi để làm cho mã của bạn biểu cảm hơn trong Swift.

00:00:45.000 --> 00:00:55.000
Và sau đó kết thúc cuộc thảo luận bằng việc khám phá các khả năng động mà Core Data đang bổ sung vào hỗ trợ SwiftUI hiện có của chúng tôi mà chúng tôi đã giới thiệu vào năm 2020.

00:00:55.000 --> 00:01:03.000
Tuy nhiên, hãy bắt đầu từ đầu, bất kể bạn đang phát triển nền tảng Apple nào, bạn chỉ cần có một ứng dụng.

00:01:03.000 --> 00:01:10.000
Tại một thời điểm nào đó, ứng dụng của bạn cuối cùng sẽ gặp phải dữ liệu người dùng và bạn có thể sẽ cần lưu trữ nó ở đâu đó.

00:01:10.000 --> 00:01:14.000
Một lựa chọn tuyệt vời cho nhu cầu đó là sử dụng Dữ liệu cốt lõi.

00:01:14.000 --> 00:01:23.000
Core Data là khung đặc trưng của Apple dành cho các nhà phát triển ứng dụng, những người mong muốn duy trì dữ liệu người dùng của họ một cách mạnh mẽ và giàu tính năng.

00:01:23.000 --> 00:01:34.000
Khung này giải quyết nhiều phức tạp của việc quản lý dữ liệu người dùng một cách thích hợp, từ cách nó được biểu diễn dưới dạng biểu đồ đối tượng trong bộ nhớ đến cách nó được mô hình hóa trong lưu trữ.

00:01:34.000 --> 00:01:41.000
Khuôn khổ cũng trải qua những nỗ lực tuyệt vời để quản lý các cân nhắc quan trọng về thời gian chạy, như sử dụng bộ nhớ và độ trễ.

00:01:41.000 --> 00:01:44.000
Các khả năng được cung cấp bởi khuôn khổ cũng có thể mở rộng.

00:01:44.000 --> 00:01:56.000
Bạn có thể bắt đầu với một cửa hàng đơn giản, liên tục cục bộ và mở rộng để sử dụng nhiều ngữ cảnh thực thi để cải thiện hiệu suất và thậm chí tạo ra trải nghiệm dữ liệu được chia sẻ mạnh mẽ thông qua CloudKit.

00:01:56.000 --> 00:02:00.000
Dữ liệu cốt lõi cũng hoạt động trên tất cả các nền tảng do Apple hỗ trợ.

00:02:00.000 --> 00:02:03.000
Và tôi thực sự muốn nhấn mạnh điểm cuối cùng này.

00:02:03.000 --> 00:02:13.000
Khi bạn bắt đầu sử dụng Core Data, mọi thứ bạn học sẽ hoạt động trên từng nền tảng của chúng tôi, từ máy Mac, đến iPhone hoặc thậm chí là Apple Watch của bạn.

00:02:13.000 --> 00:02:17.000
Và, tất nhiên, Core Data cũng hoạt động tốt trong Swift.

00:02:17.000 --> 00:02:25.000
Trong vài năm qua, chúng tôi đã tiếp tục nâng cao Core Data API để thể hiện rõ nhất có thể trong Swift.

00:02:25.000 --> 00:02:33.000
Và đây là một năm khá thú vị đối với Swift với sự ra đời của các tính năng đồng thời hoàn toàn mới trong ngôn ngữ và thời gian chạy.

00:02:33.000 --> 00:02:41.000
Kể từ khi thành lập, Core Data luôn quan tâm đến việc chạy mã đồng thời và có một lý do thực sự chính đáng cho việc này.

00:02:41.000 --> 00:02:50.000
Dữ liệu tồn tại đòi hỏi phải đọc và ghi vào một số phương tiện lưu trữ bên ngoài và điều này làm cho việc hỗ trợ mô hình đồng thời mới trở nên phù hợp tự nhiên.

00:02:50.000 --> 00:02:56.000
Hãy cùng khám phá cách thức hoạt động của nó trong bối cảnh ứng dụng mẫu Động đất của chúng tôi.

00:02:56.000 --> 00:03:09.000
Ứng dụng này đọc nguồn cấp dữ liệu từ Cơ quan Khảo sát Địa chất Hoa Kỳ và sử dụng Dữ liệu Cốt lõi để lưu trữ thông tin về các trận động đất gần đây, chẳng hạn như cường độ, vị trí và ngày xảy ra sự kiện.

00:03:09.000 --> 00:03:19.000
Về mặt kiến trúc, Earthquakes là một ứng dụng Swift có ngữ cảnh xem để điều khiển giao diện người dùng và bối cảnh nền để nhập dữ liệu do USGS cung cấp.

00:03:19.000 --> 00:03:28.000
Mẫu của chúng tôi có một vùng chứa cục bộ cho ứng dụng của chúng tôi và thu thập dữ liệu động đất từ nguồn cấp dữ liệu JSON của USGS.

00:03:28.000 --> 00:03:38.000
Khi chúng tôi tải xuống dữ liệu, chúng tôi chuyển nó cho trình phân tích cú pháp JSON của mình và sau đó nhập nó vào ngữ cảnh nền của chúng tôi để biến thành các đối tượng được quản lý và lưu vào cửa hàng cục bộ của chúng tôi.

00:03:38.000 --> 00:03:43.000
Bối cảnh chế độ xem sau đó hợp nhất các thay đổi để cập nhật giao diện người dùng của chúng tôi một cách kỳ diệu.

00:03:43.000 --> 00:03:50.000
Vào năm 2020, chúng tôi tập trung vào cách xử lý hiệu quả dữ liệu này thông qua việc sử dụng các hoạt động hàng loạt.

00:03:50.000 --> 00:03:54.000
Tuy nhiên, bây giờ, tôi muốn tập trung vào cách chúng tôi thực hiện đồng thời các thao tác này.

00:03:54.000 --> 00:04:01.000
Đặc biệt, tôi muốn tập trung vào ba bước mà chúng tôi thực hiện để nhập dữ liệu vào ứng dụng.

00:04:01.000 --> 00:04:09.000
Bước một là tải xuống dữ liệu thô và sau khi tải xuống thành công, ứng dụng cần chuyển đổi nó thành đại diện cục bộ cụ thể của chúng tôi.

00:04:09.000 --> 00:04:13.000
Và cuối cùng, lưu các đối tượng mới vào cửa hàng liên tục.

00:04:13.000 --> 00:04:17.000
Hãy tiếp tục và chuyển đổi cái này thành mã cấp cao.

00:04:17.000 --> 00:04:21.000
Tôi đã trừu tượng hóa mỗi thao tác thành chức năng hoặc đóng riêng của nó.

00:04:21.000 --> 00:04:35.000
Đầu tiên, ứng dụng truy xuất dữ liệu thô từ máy chủ, xử lý nó thành một biểu diễn cục bộ thuận tiện và sau đó nhập các đối tượng vào Dữ liệu cốt lõi bằng cách thực hiện yêu cầu chèn hàng loạt trên ngữ cảnh đối tượng được quản lý nền.

00:04:35.000 --> 00:04:40.000
Được viết như thế này, việc hình dung các nút thắt cổ chai tiềm ẩn sẽ dễ dàng hơn một chút.

00:04:40.000 --> 00:04:46.000
Tải dữ liệu qua mạng sẽ là một cơ hội tuyệt vời để xem xét thực hiện công việc của chúng tôi một cách không đồng bộ.

00:04:46.000 --> 00:04:49.000
Chuyển đổi cũng có thể là một nơi để xem xét.

00:04:49.000 --> 00:04:55.000
Ngoài ra, việc nhập dữ liệu vào cửa hàng liên tục của chúng tôi có vẻ khá cơ hội.

00:04:55.000 --> 00:05:05.000
Tuy nhiên, trong lịch sử, trong tất cả các trường hợp này, bạn sẽ cần phải tự mình thực hiện bất kỳ cơ chế không đồng bộ nào như vậy hoặc dựa nhiều vào việc triển khai theo khuôn khổ cụ thể.

00:05:05.000 --> 00:05:10.000
Hãy nói về sự trừu tượng cụ thể của Core Data.

00:05:10.000 --> 00:05:19.000
Trong trường hợp Dữ liệu cốt lõi, khi bạn gọi performAndWait, ngữ cảnh đối tượng được quản lý sẽ thực hiện đóng được cung cấp trong môi trường thực thi được bảo vệ của riêng nó.

00:05:19.000 --> 00:05:24.000
Điều này có khả năng kết nối chuỗi cuộc gọi cho đến khi công việc hoàn tất.

00:05:24.000 --> 00:05:32.000
Nếu chúng ta hình dung điều này, chúng ta có thể tưởng tượng ba khối mã mà tôi đã gắn nhãn TRƯỚC, TRONG VÀ SAU.

00:05:32.000 --> 00:05:39.000
Khi mã của chúng tôi chạy, trước tiên mã được gắn nhãn TRƯỚC sẽ có cơ hội thực thi trên luồng gốc.

00:05:39.000 --> 00:05:47.000
Sau đó, chúng tôi gọi performAndWait và chuỗi gọi sẽ chặn cho đến khi công việc xảy ra TRONG QUÁ TRÌNH đóng hoàn tất.

00:05:47.000 --> 00:05:52.000
Khi công việc đó được hoàn thành, mã được mô tả SAU sẽ thực thi.

00:05:52.000 --> 00:05:58.000
Tất nhiên, nếu bạn không cần đợi việc đóng cửa kết thúc, chúng tôi luôn cung cấp một biến thể hoàn toàn không đồng bộ.

00:05:58.000 --> 00:06:09.000
Nhưng mới trong năm nay, Swift đã đạt được mô hình đồng thời mạnh mẽ với tích hợp ngôn ngữ sâu cho phép Dữ liệu cốt lõi mô tả chính xác hơn ý định của API của chúng tôi.

00:06:09.000 --> 00:06:11.000
Cú pháp hơi khác một chút.

00:06:11.000 --> 00:06:22.000
Bạn yêu cầu chờ kết quả thực hiện, nhưng mô hình tinh thần để sử dụng API mới này hoàn toàn giống với đối tượng được quản lý luôn hỗ trợ.

00:06:22.000 --> 00:06:30.000
Tuy nhiên, lợi ích là tính đồng thời không còn là chi tiết triển khai ẩn nữa, mà thay vào đó được tích hợp sâu vào ngôn ngữ Swift.

00:06:30.000 --> 00:06:43.000
Bởi vì điều này, trình biên dịch có thể tự động ngăn chặn nhiều lỗi đồng thời phổ biến, chẳng hạn như các cuộc đua dữ liệu và bế tắc, và thậm chí sử dụng hiệu quả các tài nguyên khi các tác vụ được biết là đang chờ kết quả.

00:06:43.000 --> 00:06:49.000
Hãy quay lại mã và xem việc sử dụng cái này trong thực tế như thế nào.

00:06:49.000 --> 00:06:53.000
Như chúng ta đã thấy, bạn yêu cầu chờ đợi một chức năng khai báo không đồng bộ.

00:06:53.000 --> 00:07:01.000
Điều này có khả năng tạm dừng ngữ cảnh thực thi cuộc gọi cho đến khi hàm không đồng bộ mang lại quyền kiểm soát bằng cách trả về.

00:07:01.000 --> 00:07:11.000
Nó cũng hoạt động liền mạch với việc xử lý lỗi có cấu trúc hiện có của Swift bằng cách định tuyến bất kỳ lỗi ném nào đến khung cuộc gọi, giống như bạn mong đợi.

00:07:11.000 --> 00:07:25.000
Bây giờ chúng ta đã thấy một ví dụ về việc gọi một hàm không đồng bộ, chúng ta hãy xem cách chúng được khai báo bằng cách xem xét cách hoàn toàn mới của Core Data để thực hiện công việc không đồng bộ trong bối cảnh đối tượng được quản lý.

00:07:25.000 --> 00:07:36.000
Có khá nhiều chức năng được đóng gói trong khổ thơ nhỏ này của mã Swift, nhưng tôi sẽ chỉ nói về một vài chi tiết quan trọng, và sau đó chúng ta sẽ nhảy vào chỉ ra cách bạn có thể sử dụng nó trong thực tế.

00:07:36.000 --> 00:07:39.000
Bắt đầu với việc tuyên bố quá tải thực hiện mới.

00:07:39.000 --> 00:07:50.000
Bạn có thể thấy nó chung chung dựa trên loại kết quả mà nó có thể trả về và được trang trí bằng từ khóa không đồng bộ mới, chọn chức năng này vào các khả năng đồng thời mới trong Swift.

00:07:50.000 --> 00:08:02.000
Có lẽ khía cạnh quan trọng nhất của API mới này là việc đóng được cung cấp hiện cho phép bạn ném lỗi hoặc trả về giá trị, giúp bạn tiết kiệm nỗ lực định tuyến chúng trở lại khung gọi bằng tay.

00:08:02.000 --> 00:08:07.000
Hãy xem điều này thú vị như thế nào bằng cách khám phá một vài kịch bản khác nhau.

00:08:07.000 --> 00:08:20.000
Trong lịch sử, vì sự đồng thời đang ẩn bên trong việc triển khai của chúng tôi, một trong những cách duy nhất để định tuyến lỗi bên ngoài performAndWait là đóng một tùy chọn và sau đó kiểm tra nó sau đó.

00:08:20.000 --> 00:08:33.000
Điều này có thể phức tạp hơn nếu bạn đang sử dụng các phiên bản thực hiện hoàn toàn không đồng bộ vì bạn cần phải làm nhiều hệ thống ống nước bằng cách chuyển các trình xử lý hoàn thành xung quanh và đảm bảo rằng bạn đã sử dụng chúng một cách nhất quán.

00:08:33.000 --> 00:08:37.000
Với mô hình đồng thời mới trong Swift, tất cả hệ thống ống nước đó đều được xử lý cho bạn!

00:08:37.000 --> 00:08:47.000
Chỉ cần thử và chờ đợi công việc không đồng bộ của bạn, và nếu xảy ra lỗi, chỉ cần ném nó đi, và mọi thứ sẽ thư giãn vào khung cuộc gọi một cách tự nhiên.

00:08:47.000 --> 00:08:51.000
Vì vậy, bây giờ, chúng tôi tập trung vào các lỗi, nhưng còn kết quả thì sao?

00:08:51.000 --> 00:08:54.000
Chà, mọi thứ tôi đã mô tả đều hoạt động giống hệt nhau.

00:08:54.000 --> 00:08:57.000
Hãy xem xét một ví dụ cụ thể.

00:08:57.000 --> 00:09:01.000
Hãy phác thảo những gì chúng ta muốn làm trước khi nhảy vào mã.

00:09:01.000 --> 00:09:09.000
Đối với ví dụ này, tôi muốn định cấu hình yêu cầu tìm nạp để xác định số lượng trận động đất đã xảy ra trong năm giờ qua.

00:09:09.000 --> 00:09:13.000
Như một câu, đây là một nhiệm vụ đơn giản để mô tả.

00:09:13.000 --> 00:09:17.000
Nhưng trong mã, chúng ta sẽ cần sắp xếp lại mọi thứ một chút.

00:09:17.000 --> 00:09:26.000
Trước tiên chúng ta sẽ cần tìm ra khi nào năm giờ trước, chúng ta có thể sử dụng API Lịch để tính toán điều này một cách mạnh mẽ.

00:09:26.000 --> 00:09:33.000
Sau đó, chúng tôi sẽ định cấu hình một yêu cầu tìm nạp với một vị ngữ theo ngày đó và yêu cầu loại kết quả đếm.

00:09:33.000 --> 00:09:37.000
Trong mã, nó trông khá giống kế hoạch của chúng tôi.

00:09:37.000 --> 00:09:49.000
Chúng tôi sử dụng API bù của Lịch để tính toán năm giờ trước bây giờ, và sau đó định cấu hình Quake FetchRequest để trả về kết quả đếm với vị ngữ khớp với ngày mà chúng tôi quan tâm.

00:09:49.000 --> 00:09:54.000
Trong lịch sử, kết quả trả về theo một mô hình tương tự như cách chúng tôi bắt lỗi.

00:09:54.000 --> 00:10:05.000
Bạn sẽ đóng bất kỳ trạng thái nào mà bạn cần đột biến, thực hiện các phép tính của mình trong ngữ cảnh đối tượng được quản lý và sau đó, sử dụng kết quả sau khi lấy lại quyền kiểm soát.

00:10:05.000 --> 00:10:14.000
Bây giờ, chúng ta có thể chỉ cần thử và chờ kết quả của cuộc gọi thực hiện của chúng ta và trả lại kết quả để thực hiện trực tiếp cho khung cuộc gọi của chúng ta.

00:10:14.000 --> 00:10:17.000
Phần còn lại của mã hoàn toàn giống nhau.

00:10:17.000 --> 00:10:26.000
Đó chỉ là định tuyến giá trị thủ công mà chúng tôi tránh cùng với bất kỳ lỗi hoặc sắc thái tiềm ẩn nào mà mã đó có thể có.

00:10:26.000 --> 00:10:30.000
Mã mới này khá ngắn gọn và biểu cảm.

00:10:30.000 --> 00:10:35.000
Tuy nhiên, điều đáng nói là có những lúc bạn nên thận trọng.

00:10:35.000 --> 00:10:39.000
Hãy xem xét một ví dụ khác để xem tại sao.

00:10:39.000 --> 00:10:44.000
Ví dụ này cố gắng trả lại trận động đất gần đây nhất như một vật thể được quản lý.

00:10:44.000 --> 00:10:53.000
Mặc dù API mới giúp việc trả về các giá trị thực sự dễ dàng, nhưng không an toàn khi trả về các đối tượng được quản lý đã được đăng ký vào ngữ cảnh đối tượng được quản lý.

00:10:53.000 --> 00:11:00.000
Chỉ hợp lệ khi tham khảo các đối tượng đã đăng ký như vậy trong phần đóng của cuộc gọi để thực hiện.

00:11:00.000 --> 00:11:15.000
Thay vào đó, nếu bạn cần tham khảo một đối tượng được quản lý giữa các ngữ cảnh thực thi khác nhau, hãy sử dụng ID đối tượng và tìm nạp lại khi cần hoặc sử dụng tùy chọn biểu diễn từ điển của yêu cầu tìm nạp.

00:11:15.000 --> 00:11:21.000
Bây giờ trước khi chúng ta xem xét thêm một ví dụ nữa, tôi muốn đề cập đến một chi tiết mà tôi chưa nói đến.

00:11:21.000 --> 00:11:23.000
Và chi tiết đó là ScheduledTaskType.

00:11:23.000 --> 00:11:32.000
Cho đến nay, mọi hiệu suất không đồng bộ mà chúng ta đã thấy đều về giá trị mặc định cho tùy chọn này: .immediate.

00:11:32.000 --> 00:11:43.000
Có một tùy chọn thứ hai được gọi là .enqueued và để hiểu sự khác biệt giữa hai cách tiếp cận lập lịch này, bạn nên suy nghĩ về những gì cụ thể xảy ra bên trong bối cảnh đối tượng được quản lý khi bạn yêu cầu lên lịch làm việc.

00:11:43.000 --> 00:11:50.000
Như chúng ta đã thấy, .immediate hoạt động rất giống phiên bản Swift-async-aware của performAndWait.

00:11:50.000 --> 00:12:05.000
Nếu bạn đang chạy trên một ngữ cảnh thực thi khác và yêu cầu chờ công việc được thực hiện trên ngữ cảnh nền, bạn sẽ đợi cho đến khi nó được lên lịch và hoàn thành.

00:12:05.000 --> 00:12:13.000
Tuy nhiên, nếu bạn đã ở trong cùng một bối cảnh thực hiện, công việc sẽ được lên lịch một cách lạc quan ngay lập tức.

00:12:13.000 --> 00:12:16.000
.Enqueued, mặt khác, đơn giản hơn một chút.

00:12:16.000 --> 00:12:24.000
Nó chỉ đơn giản là luôn chỉ thêm công việc được yêu cầu vào cuối bộ công việc của ngữ cảnh, bất kể mối quan hệ của trang web cuộc gọi ban đầu.

00:12:24.000 --> 00:12:27.000
Hãy tiếp tục và xem thêm một ví dụ nữa.

00:12:27.000 --> 00:12:31.000
Tất cả các tính năng không đồng bộ này cũng có thể được bạn áp dụng.

00:12:31.000 --> 00:12:40.000
Ở đây, tôi đã tính đến logic nhập mà chúng ta đã nói đến thành một hàm importQuakes mới, được trang trí bằng từ khóa không đồng bộ mới.

00:12:40.000 --> 00:12:46.000
Đến lượt nó, chức năng này được triển khai theo chức năng không đồng bộ khác.

00:12:46.000 --> 00:12:52.000
Giờ đây, bất kỳ ai cũng có thể chờ đợi chức năng mới này để tận dụng các tính năng đồng thời mới trong Swift.

00:12:52.000 --> 00:12:55.000
Hãy tóm tắt những gì chúng ta đã thấy cho đến nay.

00:12:55.000 --> 00:13:02.000
Nhìn chung, API mới này mang lại sự hỗ trợ cho tính đồng thời có cấu trúc của Swift ngay vào Dữ liệu cốt lõi.

00:13:02.000 --> 00:13:11.000
Các biến thể mới của API thực hiện chỉ là các phiên bản nhận biết đồng thời Swift của API Dữ liệu Cốt lõi hiện có mà bạn đã biết và yêu thích.

00:13:11.000 --> 00:13:17.000
Chúng tôi đặc biệt khuyến khích bạn tận dụng API mới này trong các ứng dụng của mình.

00:13:17.000 --> 00:13:25.000
Hơn nữa, NSManagedObjectContext không phải là loại duy nhất trong Dữ liệu cốt lõi hỗ trợ thực hiện các tác vụ trong miền đồng thời được bảo vệ của nó.

00:13:25.000 --> 00:13:31.000
Chúng tôi cũng đang thêm API tương tự cho cả NSPersistentContainer và NSPersistentStoreCoordinator.

00:13:31.000 --> 00:13:36.000
Hình dạng và hành vi chung của các API này khá giống với những gì tôi đã mô tả.

00:13:36.000 --> 00:13:45.000
Nhưng với tất cả sức mạnh đồng thời đó, tôi sẽ thiếu sót nếu không đưa ra lời khuyên về việc sử dụng các công cụ gỡ lỗi hiện có theo ý của bạn.

00:13:45.000 --> 00:13:52.000
Tất nhiên, địa chỉ và chất khử trùng luồng do Xcode cung cấp cực kỳ hữu ích để phát hiện các lỗi mà bạn thậm chí có thể không biết đã tồn tại.

00:13:52.000 --> 00:13:59.000
Cả hai đều có thể được tìm thấy trong ngăn Chẩn đoán của cài đặt Chạy của trình chỉnh sửa sơ đồ.

00:13:59.000 --> 00:14:08.000
Mỗi chất khử trùng phát hiện các loại vấn đề khác nhau, bao gồm xác thực các giả định sử dụng bộ nhớ an toàn và sử dụng dữ liệu thích hợp từ nhiều luồng.

00:14:08.000 --> 00:14:17.000
Luôn luôn là một ý tưởng tốt để đủ điều kiện cho các ứng dụng của bạn và các thử nghiệm liên quan của chúng với cả hai chất khử trùng trước khi bạn phát hành phần mềm của mình cho cộng đồng người dùng của mình.

00:14:17.000 --> 00:14:27.000
Và trong khi các chất khử trùng hữu ích trong mọi ngữ cảnh, tôi cũng muốn nhấn mạnh rằng Dữ liệu cốt lõi cung cấp một cờ thời gian chạy đặc biệt mà bạn có thể kích hoạt để nhận được nhiều trợ giúp cụ thể hơn cho miền.

00:14:27.000 --> 00:14:40.000
Bằng cách bật tùy chọn này, Dữ liệu cốt lõi sẽ bật một số xác nhận hữu ích để xác thực các khóa bên trong và xác nhận việc sử dụng phù hợp các loại Dữ liệu cốt lõi khác nhau.

00:14:40.000 --> 00:14:44.000
Áp dụng hỗ trợ đồng thời Swift không phải là thay đổi duy nhất được thực hiện đối với Dữ liệu cốt lõi trong năm nay.

00:14:44.000 --> 00:14:55.000
Mọi API mới mà chúng tôi đang giới thiệu, từ chia sẻ CloudKit đến tích hợp Spotlight mới, đã được tạo ra với cách trình bày của nó trong Swift.

00:14:55.000 --> 00:15:01.000
Năm nay, chúng tôi có một phiên riêng cho từng chủ đề này và tôi khuyến khích bạn kiểm tra chúng.

00:15:01.000 --> 00:15:14.000
Chúng tôi cũng đã vượt qua toàn bộ khuôn khổ để xác định những nơi khác mà chúng tôi có thể cải thiện Swift và tôi muốn cho bạn thấy một vài trong số này ngay bây giờ, bắt đầu với các loại cửa hàng liên tục khác nhau mà chúng tôi hỗ trợ.

00:15:14.000 --> 00:15:20.000
Nhớ lại, các cửa hàng liên tục mô tả cách bạn thực sự muốn lưu trữ dữ liệu của khách hàng.

00:15:20.000 --> 00:15:27.000
Core Data hiện cung cấp bốn cửa hàng như vậy: XML, nhị phân, trong bộ nhớ và SQLite.

00:15:27.000 --> 00:15:31.000
Và bạn sử dụng những số nhận dạng này mọi lúc.

00:15:31.000 --> 00:15:36.000
Mới trong năm nay, chúng tôi đã tiếp tục và đặt những cái tên tự nhiên hơn này trong Swift.

00:15:36.000 --> 00:15:47.000
Các tên hiện có sẽ tiếp tục hoạt động, nhưng API mới tiêu thụ chúng sẽ tiện dụng hơn rất nhiều do tên ngắn hơn và khả năng tự động hoàn thành các ký hiệu này.

00:15:47.000 --> 00:15:53.000
Tất nhiên, các cửa hàng liên tục không phải là thứ duy nhất trong Dữ liệu cốt lõi liên quan đến các loại.

00:15:53.000 --> 00:16:00.000
Xét cho cùng, khuôn khổ là tất cả về việc lưu trữ dữ liệu đã nhập và các loại như vậy được mô tả bằng các mô tả thuộc tính.

00:16:00.000 --> 00:16:09.000
Và năm nay, chúng tôi sẽ thêm một bảng liệt kê mở rộng mới vào mô tả thuộc tính cung cấp cú pháp tự nhiên hơn nhiều để làm việc với các loại của chúng.

00:16:09.000 --> 00:16:17.000
Chúng ta hãy xem xét những điều này đang hoạt động bằng cách viết một bài kiểm tra đơn vị có thể xác nhận rằng mô hình thời gian chạy của chúng tôi phù hợp với những gì chúng tôi đã thiết kế trong trình tạo mô hình Xcode.

00:16:17.000 --> 00:16:26.000
Để đơn giản, chúng tôi sẽ chỉ cố gắng xác thực một loại thời gian chạy duy nhất được xác định bởi mô hình vật thể động đất của chúng tôi, nhưng bạn có thể tưởng tượng điều này sẽ mở rộng như thế nào.

00:16:26.000 --> 00:16:34.000
Đây có vẻ như là một bài kiểm tra nhỏ để viết, nhưng đó là một điều tốt để xác nhận vì nó có thể tăng tốc các chẩn đoán thú vị hơn trong tương lai.

00:16:34.000 --> 00:16:39.000
Để viết bài kiểm tra này, chúng tôi sẽ viết một hàm trợ giúp nhanh về loại thuộc tính mới.

00:16:39.000 --> 00:16:42.000
Hãy tiếp tục và mô tả chức năng này ngay bây giờ.

00:16:42.000 --> 00:16:53.000
Chúng ta sẽ bắt đầu với chữ ký, mong đợi một tên thuộc tính, mô tả thực thể mà chúng ta quan tâm và loại, được mô tả dưới dạng liệt kê AttributeType mới.

00:16:53.000 --> 00:16:56.000
Định nghĩa của tiện ích này khá đơn giản.

00:16:56.000 --> 00:17:03.000
Trước tiên, chúng tôi xác nhận rằng chúng tôi có một thuộc tính với tên được cung cấp, không đạt bài kiểm tra nếu chúng tôi không thể tìm thấy nó.

00:17:03.000 --> 00:17:06.000
Và sau đó chúng tôi xác nhận rằng loại thuộc tính là như mong đợi.

00:17:06.000 --> 00:17:08.000
Và đó thực sự là tất cả những gì cần làm.

00:17:08.000 --> 00:17:17.000
Chúng tôi có thể lặp lại điều này cho từng thực thể và tài sản và yên tâm rằng hành vi thời gian chạy của chúng tôi phù hợp với mô hình mà chúng tôi đã xác định.

00:17:17.000 --> 00:17:26.000
Và đây chỉ là một ví dụ về một số cải tiến công thái học mà chúng tôi đã thực hiện đối với việc liệt kê Dữ liệu Cốt lõi trong Swift trong năm nay.

00:17:26.000 --> 00:17:35.000
Cho đến bây giờ, tôi đã tập trung vào rất nhiều tương tác khung cấp thấp hơn và cách chúng thể hiện trong Swift, nhưng còn việc trình bày dữ liệu cho người dùng của bạn thì sao?

00:17:35.000 --> 00:17:41.000
Vào năm 2020, chúng tôi đã giới thiệu một số tiện ích khi làm việc với Core Data trong SwiftUI.

00:17:41.000 --> 00:17:47.000
Và bây giờ, đồng nghiệp của tôi, Scott, có khá nhiều điều để chia sẻ với bạn về những cải tiến mới mà chúng tôi đang giới thiệu trong năm nay.

00:17:47.000 --> 00:17:48.000
Scott?

00:17:48.000 --> 00:17:49.000
Cảm ơn, Michael!

00:17:49.000 --> 00:18:03.000
Có một loạt các cải tiến đối với trải nghiệm sử dụng Dữ liệu cốt lõi với SwiftUI trong năm nay, bắt đầu với việc giải quyết thực thể lười biếng trong các yêu cầu tìm nạp, giúp giảm yêu cầu các ứng dụng phải thiết lập ngăn xếp Dữ liệu cốt lõi trước khi chúng xây dựng chế độ xem của mình.

00:18:03.000 --> 00:18:10.000
Cũng trong năm nay, các yêu cầu tìm nạp nhận cấu hình động cho các mô tả và vị ngữ sắp xếp của chúng.

00:18:10.000 --> 00:18:15.000
Và có một loại yêu cầu tìm nạp mới trong thị trấn hỗ trợ tìm nạp theo phân đoạn.

00:18:15.000 --> 00:18:24.000
Tôi sẽ xem qua từng thứ này bằng ứng dụng mẫu Động đất của chúng tôi mà Michael đã đề cập trước đó trong buổi nói chuyện, bắt đầu với giải pháp thực thể lười biếng.

00:18:24.000 --> 00:18:28.000
Có lẽ trong ứng dụng của bạn, bạn có một số mã như thế này.

00:18:28.000 --> 00:18:35.000
Thuộc tính vùng chứa này ở đây không thực sự cần thiết để hỗ trợ mã trong loại này, hoặc thậm chí là ứng dụng rộng hơn.

00:18:35.000 --> 00:18:39.000
Tất cả những thứ đó nhận được những gì nó cần trực tiếp từ loại QuakesProvider.

00:18:39.000 --> 00:18:49.000
Không, thuộc tính này tồn tại để đảm bảo ngăn xếp Dữ liệu Cốt lõi đã được thiết lập trước khi bất kỳ chế độ xem nào trong môi trường cố gắng tham chiếu đến bất kỳ thực thể nào trước khi mô hình được tải.

00:18:49.000 --> 00:18:57.000
Xem ở đây rằng công cụ sửa đổi chế độ xem môi trường được gọi sau khi ContentView đã được khởi tạo.

00:18:57.000 --> 00:19:02.000
Thủ thuật này không còn cần thiết nữa khi triển khai chống lại SDK của năm nay.

00:19:02.000 --> 00:19:16.000
Trình bao bọc thuộc tính FetchRequest hiện tìm kiếm các thực thể theo tên một cách lười biếng tại thời điểm tìm nạp, tại thời điểm đó môi trường đã đảm bảo rằng ngăn xếp Dữ liệu Cốt lõi đã được thiết lập, vì vậy bây giờ an toàn để xóa thuộc tính này...

00:19:16.000 --> 00:19:20.000
Và chỉ cần tham khảo...

00:19:20.000 --> 00:19:25.000
QuakesProvider chia sẻ vùng chứa trực tiếp trong cuộc gọi môi trường.

00:19:25.000 --> 00:19:31.000
Chuyển sang một số API mới, FetchRequest hiện hỗ trợ cấu hình động.

00:19:31.000 --> 00:19:53.000
Có hai thuộc tính mới trên giá trị được bọc để thay đổi trực tiếp vị ngữ của yêu cầu cũng như các bộ mô tả sắp xếp của nó, được thể hiện cả với NSSortDescriptors mà bạn đã quen cũng như loại giá trị SortDescriptor mới cung cấp sự tiện lợi và an toàn hơn khi tìm nạp các thực thể với các lớp con đối tượng được quản lý

00:19:53.000 --> 00:20:00.000
Và cuối cùng, có một ràng buộc cấu hình với cùng một tập hợp các thuộc tính như giá trị được bọc để tích hợp dễ dàng hơn với các chế độ xem.

00:20:00.000 --> 00:20:14.000
Trước API mới này, tôi sẽ phải thiết kế các chế độ xem của mình để các tham số sắp xếp và vị ngữ được truyền qua trình khởi tạo của chế độ xem, nhưng điều đó khiến việc hỗ trợ những thứ như định cấu hình yêu cầu tìm nạp của tôi bằng cách sử dụng các điều khiển trên thanh công cụ thực sự khó khăn.

00:20:14.000 --> 00:20:23.000
Ma sát này được loại bỏ bởi các thuộc tính cấu hình động mới này và tôi muốn chỉ cho bạn cách sử dụng chúng bằng cách thêm sắp xếp và lọc vào ứng dụng mẫu Động đất.

00:20:23.000 --> 00:20:26.000
Trước tiên hãy xem xét các mô tả sắp xếp.

00:20:26.000 --> 00:20:36.000
Theo mặc định, ứng dụng Earthquakes sắp xếp theo thời gian gần đây, nhưng tôi cũng muốn sắp xếp chúng theo cường độ, vì vậy tôi sẽ thêm một menu cho phép tôi kiểm soát thứ tự kết quả.

00:20:36.000 --> 00:20:41.000
Tôi sẽ bắt đầu bằng cách thêm một mảng tĩnh của các bộ...

00:20:41.000 --> 00:20:46.000
Chứa các mô tả sắp xếp mà tôi muốn hỗ trợ cũng như tên cho chúng.

00:20:46.000 --> 00:20:52.000
Xem ở đây rằng họ cũng đang sử dụng loại SortDescriptor mới.

00:20:52.000 --> 00:20:58.000
Tôi cũng sẽ muốn một chút tiểu bang để theo dõi thứ tự sắp xếp mà tôi hiện đang sử dụng.

00:20:58.000 --> 00:21:05.000
Tôi đã tạo một loại cho cái này, vì vậy tôi sẽ thêm nó làm thuộc tính của chế độ xem nội dung.

00:21:05.000 --> 00:21:11.000
Bây giờ tôi sẽ thêm một menu thanh công cụ vào chế độ xem danh sách...

00:21:11.000 --> 00:21:20.000
Điều đó sửa đổi sắp xếp đã chọn cũng như công cụ sửa đổi onChange cập nhật các bộ mô tả sắp xếp của yêu cầu tìm nạp.

00:21:20.000 --> 00:21:27.000
Bây giờ trong bản xem trước, chúng ta có thể thấy menu mới và tôi có thể sử dụng nó để sắp xếp các trận động đất theo cường độ.

00:21:27.000 --> 00:21:29.000
Tuyệt vời!

00:21:29.000 --> 00:21:32.000
Bây giờ để thêm bộ lọc.

00:21:32.000 --> 00:21:36.000
Tôi muốn lọc dựa trên vị trí của trận động đất.

00:21:36.000 --> 00:21:42.000
Điều đầu tiên tôi cần là một số trạng thái cho văn bản của trường tìm kiếm.

00:21:42.000 --> 00:21:48.000
Và tôi sẽ tạo ra một tài sản ràng buộc...

00:21:48.000 --> 00:21:56.000
Cho trường tìm kiếm cập nhật yêu cầu tìm nạp.

00:21:56.000 --> 00:21:59.000
Với những thứ đó tại chỗ, tất cả những gì tôi cần là giao diện người dùng.

00:21:59.000 --> 00:22:04.000
Thuận tiện...

00:22:04.000 --> 00:22:11.000
Có thể tìm kiếm có một liên kết với một chuỗi, vì vậy chúng ta có thể đặt nó ngay tại đây.

00:22:11.000 --> 00:22:22.000
Bây giờ trong bản xem trước của chúng tôi, chúng tôi có thể thu hẹp tất cả các trận động đất gần một nơi phù hợp với bánh sandwich bằng cách chỉ cần gõ "bánh sandwich" vào lĩnh vực mới này ở đây.

00:22:22.000 --> 00:22:25.000
Và đó là cấu hình động cho FetchRequest.

00:22:25.000 --> 00:22:35.000
Một phần chức năng thường được yêu cầu khác là hỗ trợ tìm nạp theo từng phần, xuất hiện trong năm nay dưới dạng một loại trình bao bọc thuộc tính mới được gọi là SectionedFetchRequest.

00:22:35.000 --> 00:22:50.000
Loại này hỗ trợ các thuộc tính cấu hình động mới giống như FetchRequest, nhưng nó được khởi tạo với một tham số bổ sung, một đường dẫn chính đến một thuộc tính xác định phần, rất giống NSFetchedResultsController.

00:22:50.000 --> 00:22:57.000
Nhưng không giống như bộ điều khiển kết quả được tìm nạp, thuộc tính xác định phần có thể có bất kỳ loại nào bạn thích, miễn là nó có thể băm được.

00:22:57.000 --> 00:23:05.000
Điều này được mã hóa trong hệ thống kiểu sử dụng một tham số chung bổ sung trên SectionedFetchRequest.

00:23:05.000 --> 00:23:09.000
Cuối cùng, loại mới này bao bọc một loại kết quả hai chiều.

00:23:09.000 --> 00:23:15.000
SectionedFetchResults là một tập hợp các phần, mỗi phần tự nó là một tập hợp các kết quả.

00:23:15.000 --> 00:23:21.000
Mỗi phần cũng có một thuộc tính với mã định danh phần.

00:23:21.000 --> 00:23:26.000
Điều này thực sự dễ áp dụng, vì vậy tôi sẽ thêm tìm nạp phân đoạn vào ứng dụng Earthquakes.

00:23:26.000 --> 00:23:34.000
Đầu tiên, tôi cập nhật khai báo FetchRequest của mình.

00:23:34.000 --> 00:23:41.000
Quake đã có một tài sản trong ngày, vì vậy tôi sẽ sử dụng nó cho đường dẫn chính phân đoạn.

00:23:41.000 --> 00:23:49.000
Tiếp theo, tôi cần cập nhật thuộc tính cơ thể...

00:23:49.000 --> 00:23:53.000
Để phù hợp với loại kết quả được phân đoạn mới.

00:23:53.000 --> 00:24:12.000
Vòng lặp bên ngoài ở đây lặp lại các phần, vì vậy tôi đang phát ra chế độ xem Phần ở đây và bản thân mỗi phần là một tập hợp các Trận động đất, vì vậy ForEach bên trong này lặp lại phần đó, giống như tôi đã lặp lại kết quả trước đây.

00:24:12.000 --> 00:24:18.000
Nếu chúng ta xem qua bản xem trước, bây giờ tôi đã có các trận động đất được sắp xếp theo thời gian và được phân đoạn theo ngày.

00:24:18.000 --> 00:24:27.000
Và SwiftUI thậm chí còn cung cấp cho tôi hỗ trợ tự động cho các phần thu gọn.

00:24:27.000 --> 00:24:39.000
Loại SectionedFetchRequest mới này hỗ trợ các thuộc tính cấu hình động giống như FetchRequest cũng như một thuộc tính cấu hình bổ sung cho đường dẫn khóa nhận dạng phần.

00:24:39.000 --> 00:24:44.000
Điều này cực kỳ quan trọng vì chúng tôi không thực sự an toàn để thay đổi việc phân loại nữa.

00:24:44.000 --> 00:24:53.000
Nó có thể khiến các phần không liền kề nhau vì thời gian và cường độ động đất không tương quan hoàn hảo, điều này có lẽ là tốt nhất.

00:24:53.000 --> 00:24:59.000
Để khắc phục điều này, tôi cần cập nhật các loại hàng đầu...

00:24:59.000 --> 00:25:05.000
Vì vậy mỗi cái có một đường dẫn khóa nhận dạng phần tương ứng.

00:25:05.000 --> 00:25:09.000
Tiếp theo, xuống thanh công cụ...

00:25:09.000 --> 00:25:16.000
Tôi cần cập nhật đường dẫn khóa nhận dạng phần mỗi khi tôi cập nhật các mô tả sắp xếp.

00:25:16.000 --> 00:25:19.000
Nhưng đây là phần quan trọng.

00:25:19.000 --> 00:25:29.000
Các thay đổi đối với yêu cầu được cam kết bất cứ khi nào trình nhận kết quả được gọi, vì vậy để cập nhật cả sắp xếp và phân đoạn một cách an toàn...

00:25:29.000 --> 00:25:36.000
Tôi cần cập nhật cấu hình trên một tham chiếu đến các kết quả mà tôi đã kéo vào một địa phương.

00:25:36.000 --> 00:25:42.000
Bây giờ trong bản xem trước, chúng ta có thể thấy rằng việc thay đổi thứ tự cũng thay đổi phần.

00:25:42.000 --> 00:25:54.000
Chúng ta có thể lật giữa các trận động đất được sắp xếp theo thời gian, được phân chia theo ngày và các trận động đất được sắp xếp và phân chia theo cường độ.

00:25:54.000 --> 00:26:07.000
Và chúng ta đã có nó: khởi tạo ngăn xếp lười biếng, cấu hình động và tìm nạp phân đoạn, tất cả đều dễ dàng áp dụng cho một ứng dụng hiện có sử dụng iOS 15 và macOS Monterey.

00:26:07.000 --> 00:26:15.000
Vì vậy, tóm lại, Core Data là cửa hàng một cửa của bạn để quản lý nhu cầu bền bỉ dữ liệu của ứng dụng trên tất cả các nền tảng của Apple.

00:26:15.000 --> 00:26:24.000
Nó khai thác các tính năng đồng thời mới có sẵn trong Swift thông qua API thực hiện mới và vẫn có tính năng gỡ lỗi an toàn luồng mạnh mẽ được tích hợp ngay trong đó.

00:26:24.000 --> 00:26:34.000
Nó có các giao diện liệt kê mới giúp các loại lưu trữ và thuộc tính trở nên tự nhiên hơn khi sử dụng trong Swift, cộng với chia sẻ CloudKit và tích hợp Spotlight.

00:26:34.000 --> 00:26:43.000
Và việc kết nối dữ liệu của bạn với chế độ xem của bạn dễ dàng hơn bao giờ hết bằng SwiftUI với cấu hình động và tìm nạp phân đoạn.

00:26:43.000 --> 00:26:46.000
Có rất nhiều thứ mới để tìm hiểu liên quan đến những chủ đề này.

00:26:46.000 --> 00:26:52.000
Chúng tôi khuyên bạn nên kiểm tra các bộ sưu tập "Đơn giản hóa với SwiftUI và Gặp gỡ Swift Concurrency."

00:26:52.000 --> 00:26:53.000
Và thế là xong!

00:26:53.000 --> 00:26:57.000
Tôi thực sự mong chờ được xem tất cả các bạn xây dựng những gì với các API mới này.

00:26:57.000 --> 23:59:59.000
[Nhạc lạc quan].

