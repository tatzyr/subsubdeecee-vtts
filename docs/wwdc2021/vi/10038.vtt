WEBVTT

00:00:02.000 --> 00:00:11.000
Xin chào, và chào mừng đến với WWDC.

00:00:11.000 --> 00:00:16.000
Tên tôi là John, và tôi làm việc trên Core ML, khuôn khổ học máy của Apple.

00:00:16.000 --> 00:00:22.000
Cùng với đồng nghiệp Brian của tôi, chúng tôi rất vui mừng được chỉ cho bạn cách điều chỉnh các mô hình của mình khi bạn mang đến sự kỳ diệu của việc học máy cho các ứng dụng của mình.

00:00:22.000 --> 00:00:27.000
Để bắt đầu mọi thứ, tôi sẽ chỉ cho bạn một số cải tiến cho API học máy của chúng tôi.

00:00:27.000 --> 00:00:32.000
Sau đó, chúng ta sẽ đi sâu vào các cải tiến định dạng tệp mở ra một loạt các khả năng mới.

00:00:32.000 --> 00:00:42.000
Sau đó, Brian sẽ chỉ cho chúng tôi các Chương trình ML và đưa chúng tôi dưới mui xe và hướng dẫn chúng tôi thực hiện đánh máy và cách bạn có thể sử dụng nó để tinh chỉnh độ chính xác và hiệu suất của các mô hình của bạn.

00:00:42.000 --> 00:00:48.000
Bạn có thể sử dụng những cải tiến này để hợp lý hóa quy trình làm việc của mình và đẩy trải nghiệm được hỗ trợ ML của bạn hơn nữa.

00:00:48.000 --> 00:00:52.000
Hãy bắt đầu với những cải tiến API.

00:00:52.000 --> 00:00:56.000
Core ML cung cấp cho bạn một API đơn giản để làm việc với các mô hình trên thiết bị của người dùng.

00:00:56.000 --> 00:01:05.000
Các mô hình này có thể được thiết kế để hoạt động với nhiều đầu vào và đầu ra khác nhau, chẳng hạn như chuỗi hoặc giá trị nguyên thủy hoặc đầu vào phức tạp hơn như hình ảnh và Đa mảng.

00:01:05.000 --> 00:01:09.000
Hãy nói nhiều hơn về loại cuối cùng này, MultiArray.

00:01:09.000 --> 00:01:14.000
Core ML giúp dễ dàng làm việc với dữ liệu đa chiều bằng cách sử dụng MLMultiArray.

00:01:14.000 --> 00:01:20.000
Mặc dù nó là một API đơn giản, mã bạn phải viết để thao tác dữ liệu với nó không phải lúc nào cũng cảm thấy tự nhiên trong Swift.

00:01:20.000 --> 00:01:26.000
Ví dụ, để khởi tạo một MultiArray với một loạt các số nguyên, bạn phải chuyển loại trong thời gian chạy.

00:01:26.000 --> 00:01:34.000
Thêm vào đó, bạn phải sử dụng NSNumber thay vì các số nguyên thông thường, và điều đó không an toàn với loại và không thực sự trông giống Swift thanh lịch.

00:01:34.000 --> 00:01:39.000
Core ML đang giới thiệu MLShapedArray để giúp bạn làm việc với dữ liệu đa chiều dễ dàng hơn.

00:01:39.000 --> 00:01:45.000
MLShapedArray là một loại Swift thuần túy tương tự như một mảng thông thường nhưng hỗ trợ nhiều chiều.

00:01:45.000 --> 00:01:55.000
Giống như mảng, nó là một loại giá trị, với ngữ nghĩa sao chép khi ghi và cú pháp cắt phong phú hoạt động dễ dàng với mã MLMultiArray hiện có của bạn.

00:01:55.000 --> 00:02:02.000
Để khởi tạo MLMultiArray hai chiều, bạn thường sử dụng hai vòng lặp "for" lồng nhau.

00:02:02.000 --> 00:02:08.000
Với MLShapedArray, bạn có thể khởi tạo cùng một mảng 2D với một dòng duy nhất.

00:02:08.000 --> 00:02:14.000
MLShapedArray phù hợp với Swift một cách tự nhiên và giúp việc viết và xem lại mã của bạn dễ dàng hơn nhiều.

00:02:14.000 --> 00:02:15.000
Đây là một ví dụ khác.

00:02:15.000 --> 00:02:20.000
Để truy cập hàng thứ hai dưới dạng một lát cắt, bạn chỉ cần lập chỉ mục vào nó như thế này.

00:02:20.000 --> 00:02:27.000
Để truy cập nhiều hàng và cột dưới dạng lát cắt, bạn có thể sử dụng một phạm vi cho mỗi chiều.

00:02:27.000 --> 00:02:31.000
MLShapedArray và MLMultiArray hoàn toàn tương thích với nhau.

00:02:31.000 --> 00:02:37.000
Bạn có thể dễ dàng chuyển đổi loại này sang loại khác bằng cách sử dụng trình khởi tạo lấy một ví dụ của loại khác.

00:02:37.000 --> 00:02:41.000
Bạn cũng có thể chuyển đổi các kiểu dữ liệu bằng cách sử dụng trình khởi tạo chuyển đổi.

00:02:41.000 --> 00:02:47.000
Ví dụ, mã này chuyển đổi MultiArray of doubles thành ShapedArray of Floats.

00:02:47.000 --> 00:02:51.000
Các mảng có hình dạng có ích bất cứ lúc nào bạn cần làm việc với dữ liệu đa chiều.

00:02:51.000 --> 00:02:58.000
Ví dụ, mô hình phát hiện đối tượng YOLO tìm các đối tượng trong một hình ảnh, và sau đó nó xuất ra một mảng 2 chiều.

00:02:58.000 --> 00:03:00.000
Bảng hiển thị dữ liệu từ một dự đoán.

00:03:00.000 --> 00:03:05.000
Mỗi hàng đại diện cho một hộp giới hạn và các giá trị trong mỗi cột nằm trong khoảng từ 0 đến 1.

00:03:05.000 --> 00:03:12.000
Mỗi giá trị thể hiện mức độ tự tin của mô hình rằng hộp giới hạn chứa một người, xe đạp hoặc ô tô, v.v.

00:03:12.000 --> 00:03:17.000
Tôi muốn viết một số mã để chọn nhãn có khả năng nhất cho mỗi hộp giới hạn.

00:03:17.000 --> 00:03:19.000
Đây là một ví dụ về cách làm điều đó.

00:03:19.000 --> 00:03:24.000
Mã bắt đầu với thuộc tính tin cậy của đầu ra, đó là MultiArray 2 chiều.

00:03:24.000 --> 00:03:29.000
Hàm này lặp qua mỗi hàng để tìm điểm tin cậy cao nhất trong hàng đó.

00:03:29.000 --> 00:03:33.000
Lưu ý rằng nó phải thường xuyên truyền các số nguyên vào NSNumber.

00:03:33.000 --> 00:03:39.000
Mã này sử dụng MLShapedArray thay thế và thực hiện công việc tương tự trong ít dòng dễ đọc hơn.

00:03:39.000 --> 00:03:44.000
Lưu ý kết quả dự đoán của mô hình cung cấp cho chúng ta một thuộc tính ShapedArray có chứa các giá trị tin cậy.

00:03:44.000 --> 00:03:50.000
Mã này đơn giản hơn vì MLShapedArray và vô hướng của nó phù hợp với các giao thức thu thập Swift tiêu chuẩn.

00:03:50.000 --> 00:03:56.000
Điều này cung cấp một trải nghiệm đánh máy mạnh mẽ, dễ đọc hơn và là niềm vui khi làm việc trong Swift.

00:03:56.000 --> 00:04:01.000
Tiếp theo, hãy nói về các mô hình Core ML và cách chúng được thể hiện trong hệ thống tệp.

00:04:01.000 --> 00:04:06.000
Core ML giúp bạn dễ dàng xây dựng trải nghiệm hỗ trợ học máy phong phú cho người dùng của mình.

00:04:06.000 --> 00:04:09.000
Mô hình ML là động cơ mang những trải nghiệm này vào cuộc sống.

00:04:09.000 --> 00:04:15.000
Định dạng tệp .mlmodel mã hóa và tóm tắt chức năng của mô hình nên bạn không cần phải lo lắng về nó.

00:04:15.000 --> 00:04:19.000
Định dạng lưu trữ tất cả các chi tiết triển khai và sự phức tạp của một mô hình.

00:04:19.000 --> 00:04:24.000
Là một nhà phát triển, bạn không cần phải quan tâm đến việc đó là một tập hợp cây hay một mạng lưới thần kinh với hàng triệu tham số.

00:04:24.000 --> 00:04:32.000
Mô hình ML chỉ là một tệp duy nhất mà bạn chỉ cần thêm vào dự án Xcode và viết mã hoạt động với nó, giống như bất kỳ API nào khác.

00:04:32.000 --> 00:04:36.000
Mỗi tệp mô hình Core ML bao gồm một số thành phần.

00:04:36.000 --> 00:04:42.000
Siêu dữ liệu lưu trữ thông tin như tác giả, giấy phép, phiên bản và mô tả ngắn.

00:04:42.000 --> 00:04:46.000
Giao diện xác định đầu vào và đầu ra của mô hình.

00:04:46.000 --> 00:04:49.000
Kiến trúc xác định cấu trúc bên trong của mô hình.

00:04:49.000 --> 00:04:56.000
Ví dụ, với một mạng nơ-ron, phần kiến trúc mô tả các lớp của mô hình và tất cả các kết nối giữa chúng.

00:04:56.000 --> 00:05:03.000
Cuối cùng, phần cuối cùng lưu trữ một loạt các giá trị mà mô hình đã học được trong giai đoạn đào tạo.

00:05:03.000 --> 00:05:12.000
Tệp Mô hình ML mã hóa tất cả các phần này thành định dạng nhị phân protobuf, mà hệ thống tệp và phần mềm điều khiển nguồn xem như một tệp nhị phân duy nhất.

00:05:12.000 --> 00:05:18.000
Phần mềm kiểm soát nguồn không thể nói rằng tệp mô hình nhị phân thực sự là sự kết hợp của một số thành phần riêng biệt.

00:05:18.000 --> 00:05:27.000
Để giải quyết điều đó, Core ML đang thêm một định dạng mô hình mới chia các thành phần này thành các tệp riêng biệt, sử dụng chức năng gói tích hợp của macOS.

00:05:27.000 --> 00:05:30.000
Điều này đưa chúng ta đến với Gói Mô hình ML Cốt lõi mới.

00:05:30.000 --> 00:05:37.000
Đó là một vùng chứa lưu trữ từng thành phần của mô hình trong tệp riêng của nó, tách biệt kiến trúc, trọng số và siêu dữ liệu của nó.

00:05:37.000 --> 00:05:44.000
Bằng cách tách các thành phần này, các gói mô hình cho phép bạn dễ dàng chỉnh sửa siêu dữ liệu và theo dõi các thay đổi với điều khiển nguồn.

00:05:44.000 --> 00:05:50.000
Họ cũng biên dịch hiệu quả hơn và cung cấp sự linh hoạt hơn cho các công cụ đọc và viết mô hình.

00:05:50.000 --> 00:05:55.000
Core ML và Xcode vẫn hỗ trợ đầy đủ định dạng mô hình ML ban đầu.

00:05:55.000 --> 00:06:00.000
Nhưng bạn có thể chuyển sang định dạng có thể mở rộng hơn và biên dịch hiệu quả hơn bằng cách cập nhật lên gói mô hình.

00:06:00.000 --> 00:06:02.000
Hãy thử cái này trong Xcode.

00:06:02.000 --> 00:06:07.000
Đây là một ứng dụng đơn giản sử dụng mô hình phát hiện đối tượng để xác định động vật trong một hình ảnh.

00:06:07.000 --> 00:06:10.000
Lưu ý rằng một số trường siêu dữ liệu trống.

00:06:10.000 --> 00:06:14.000
Nó khá phổ biến khi bắt gặp các mô hình mà siêu dữ liệu không được điền vào.

00:06:14.000 --> 00:06:17.000
Trước đây, bạn không thể chỉnh sửa các trường này trong Xcode.

00:06:17.000 --> 00:06:21.000
Nhưng bây giờ Xcode hỗ trợ các gói mô hình, bạn có thể.

00:06:21.000 --> 00:06:30.000
Hiện tại loại tệp của mô hình là Mô hình ML, nhưng khi tôi nhấp vào nút Chỉnh sửa, Xcode sẽ nhắc tôi cập nhật tệp Mô hình ML lên Gói ML.

00:06:30.000 --> 00:06:37.000
Xcode cho tôi biết rằng nó sắp cập nhật bất kỳ tham chiếu nào trong không gian làm việc của tôi đến tệp mô hình gốc để trỏ đến gói new.ml.

00:06:37.000 --> 00:06:42.000
Tôi sẽ tiếp tục và nhấp vào Cập nhật và Chỉnh sửa.

00:06:42.000 --> 00:06:48.000
Giao diện người dùng của Xcode hiện cho biết mô hình ở định dạng Gói ML.

00:06:48.000 --> 00:06:51.000
Bây giờ tôi có thể điền trực tiếp vào các giá trị còn thiếu trong Xcode.

00:06:51.000 --> 00:07:01.000
Tôi sẽ tiếp tục và cập nhật mô tả với từ "động vật". Vì mô hình này đến từ đồng nghiệp của tôi, Joseph, tôi sẽ đưa tên anh ấy vào trường Tác giả.

00:07:01.000 --> 00:07:07.000
Tôi sẽ nói Giấy phép MIT và phiên bản 2.0.

00:07:07.000 --> 00:07:11.000
Tôi cũng có thể thêm, sửa đổi và xóa các trường siêu dữ liệu bổ sung.

00:07:11.000 --> 00:07:17.000
Tôi sẽ thêm một mục siêu dữ liệu mới cho biết năm nào chúng tôi đã sử dụng mô hình này tại WWDC.

00:07:17.000 --> 00:07:19.000
Vậy chúng ta sẽ nói năm 2021.

00:07:19.000 --> 00:07:27.000
Bây giờ, ngoài hỗ trợ giao diện người dùng, tất cả thông tin này cũng có thể truy cập được bằng API MLModelDescription của Core ML trong thời gian chạy.

00:07:27.000 --> 00:07:32.000
Tôi cũng có thể sửa đổi mô tả về Đầu vào và Đầu ra của mô hình trong tab Dự đoán.

00:07:32.000 --> 00:07:35.000
Ở đây tôi sẽ thay đổi mô tả của Đầu vào này.

00:07:35.000 --> 00:07:38.000
Chúng tôi sẽ thêm "của một con vật."

00:07:38.000 --> 00:07:43.000
Và ở dưới đây, tôi sẽ sửa lỗi đánh máy bằng cách thêm dấu gạch nối bị thiếu.

00:07:43.000 --> 00:07:46.000
Bây giờ, một mô hình với siêu dữ liệu tốt rất giống mã với nhận xét tốt.

00:07:46.000 --> 00:07:54.000
Nó giúp bạn và nhóm của bạn hiểu được ý định của mô hình, và vì vậy điều đặc biệt quan trọng là đảm bảo bạn viết mô tả tốt cho đầu vào và đầu ra của mô hình.

00:07:54.000 --> 00:07:57.000
Tôi sẽ nhấp vào Xong để lưu các thay đổi.

00:07:57.000 --> 00:08:07.000
Bây giờ nếu tôi nhấp vào Kiểm soát nguồn và sau đó Cam kết, Xcode sẽ hiển thị các thay đổi trong chế độ xem khác nhau.

00:08:07.000 --> 00:08:12.000
Siêu dữ liệu hiện có trong tệp .json của riêng nó, giúp dễ dàng xác minh các thay đổi của tôi.

00:08:12.000 --> 00:08:17.000
Tương tự, Mô tả Tính năng có tệp .json riêng biệt của chúng.

00:08:17.000 --> 00:08:24.000
Nếu chúng tôi đã thay đổi một vài byte của tệp Mô hình ML nhị phân 62 megabyte, chúng tôi sẽ có sự khác biệt nhị phân 62 megabyte.

00:08:24.000 --> 00:08:30.000
Tuy nhiên, các gói mô hình hiệu quả và dễ làm việc hơn nhiều, đặc biệt là đối với các thay đổi văn bản nhỏ.

00:08:30.000 --> 00:08:34.000
Xcode hỗ trợ cả gói mô hình và tệp mô hình như nhau.

00:08:34.000 --> 00:08:39.000
Ví dụ, tôi có thể sử dụng tab Xem trước để kiểm tra gói mô hình của mình.

00:08:39.000 --> 00:08:46.000
Nếu tôi mang theo hình ảnh của hai con gấu, chúng ta sẽ thấy rằng chúng ta nhận được hai hộp giới hạn, một cho mỗi con gấu.

00:08:46.000 --> 00:08:57.000
Tương tự, tôi có thể vào tab Tiện ích, nơi tôi có thể tạo khóa mã hóa hoặc kho lưu trữ ML cho gói mô hình giống như tôi làm cho tệp mô hình ML.

00:08:57.000 --> 00:08:59.000
Vậy đó là các gói mô hình trong Xcode.

00:08:59.000 --> 00:09:04.000
Các gói có thể làm mọi thứ mà tệp mô hình có thể và hơn thế nữa, chẳng hạn như chỉnh sửa siêu dữ liệu mô hình.

00:09:04.000 --> 00:09:10.000
Điều cuối cùng tôi muốn hiển thị là mã mà Xcode tự động tạo cho mỗi mô hình bạn thêm vào dự án.

00:09:10.000 --> 00:09:14.000
Tôi sẽ nhấp vào biểu tượng này để xem mã được tạo.

00:09:14.000 --> 00:09:19.000
Trước đó, chúng tôi đã xem xét MLMultiArray và đối tác Swift mới của nó, MLShapedArray.

00:09:19.000 --> 00:09:25.000
Xcode hiện thêm một thuộc tính mảng có hình dạng mới cho mỗi đầu ra MultiArray trong lớp trình bao bọc.

00:09:25.000 --> 00:09:31.000
Ví dụ, lớp được tạo hiện có thuộc tính confidenceShapedArray cho đầu ra của mô hình.

00:09:31.000 --> 00:09:37.000
Bạn vẫn có thể sử dụng thuộc tính MLMultiArray tự tin ban đầu nếu bạn thích.

00:09:37.000 --> 00:09:46.000
Lưu ý rằng mục tiêu triển khai dự án của bạn phải là một trong những phiên bản hệ điều hành này, ví dụ: macOS 12 hoặc iOS 15, để tận dụng thuộc tính mảng có hình dạng mới.

00:09:46.000 --> 00:09:51.000
Bây giờ chúng ta đã thấy tất cả những điều này đang hoạt động, chúng ta hãy xem Mô hình ML và Gói ML cạnh nhau.

00:09:51.000 --> 00:09:59.000
Gói ML hỗ trợ tất cả các loại tương tự mà các tệp Mô hình ML hỗ trợ, bao gồm cây, SVM, mạng thần kinh, v.v.

00:09:59.000 --> 00:10:05.000
Ngoài các loại này, Gói ML cũng hỗ trợ một loại mô hình mới mạnh mẽ được gọi là Chương trình ML.

00:10:05.000 --> 00:10:10.000
Chương trình ML là một loại mô hình đại diện cho các mạng thần kinh ở định dạng định hướng mã hơn.

00:10:10.000 --> 00:10:15.000
Để cho bạn biết thêm về các Chương trình ML và các tính năng mới mà chúng kích hoạt, tôi sẽ giao nó cho Brian.

00:10:15.000 --> 00:10:16.000
Cảm ơn, John.

00:10:16.000 --> 00:10:24.000
Tên tôi là Brian Keene, và tôi rất hào hứng khi nói về các Chương trình ML và cách thực thi đánh máy giúp bạn kiểm soát nhiều hơn độ chính xác và hiệu suất mô hình tốt hơn.

00:10:24.000 --> 00:10:28.000
Có nhiều cách khác nhau mà một mô hình học máy có thể đã được trình bày cho bạn.

00:10:28.000 --> 00:10:36.000
Nếu bạn đang tham gia một khóa học máy hoặc đọc một bài báo, bạn có thể gặp phải một mô hình được mô tả liên quan đến công thức toán học hoặc thống kê của nó.

00:10:36.000 --> 00:10:45.000
Tuy nhiên, các biểu thức toán học này thường được trừu tượng hóa và trình bày thay thế cho bạn dưới dạng biểu đồ hoặc mạng tính toán.

00:10:45.000 --> 00:10:54.000
Biểu diễn đồ họa này như được mô tả trong hai hình giữa, mô tả cách dữ liệu chảy qua một loạt các lớp, mỗi lớp áp dụng biến đổi cụ thể của riêng chúng.

00:10:54.000 --> 00:10:59.000
Trong thư viện phần mềm học máy, mô hình thay vào đó được thể hiện dưới dạng các thao tác trong mã.

00:10:59.000 --> 00:11:07.000
Các kỹ sư học máy đang ngày càng tận dụng cấu trúc chương trình chung chung hơn này bao gồm các khối, chức năng và luồng điều khiển.

00:11:07.000 --> 00:11:13.000
Loại mô hình Chương trình ML mới trong Core ML tự sắp xếp với đại diện cuối cùng này.

00:11:13.000 --> 00:11:16.000
Đây là một Chương trình ML đại diện.

00:11:16.000 --> 00:11:21.000
Nó ở định dạng văn bản có thể đọc được của con người, mặc dù mục đích là bạn không cần phải tự viết nó.

00:11:21.000 --> 00:11:25.000
Chương trình ML sẽ được tạo tự động bởi bộ chuyển đổi của Core ML.

00:11:25.000 --> 00:11:28.000
Một chương trình ML bao gồm một chức năng chính.

00:11:28.000 --> 00:11:32.000
Chức năng chính này bao gồm một chuỗi các hoạt động, hoặc hoạt động.

00:11:32.000 --> 00:11:37.000
Mỗi op tạo ra một biến, và biến này được gõ mạnh.

00:11:37.000 --> 00:11:46.000
Đối với các hoạt động có trọng số, chẳng hạn như hoạt động tuyến tính hoặc tích chập, trọng số thường được tuần tự hóa thành một tệp nhị phân riêng biệt.

00:11:46.000 --> 00:11:52.000
Đây là một bản tóm tắt ngắn gọn về cách các Chương trình ML so sánh với Mạng thần kinh.

00:11:52.000 --> 00:11:57.000
Mạng thần kinh có các lớp, trong khi các chương trình ML có các hoạt động.

00:11:57.000 --> 00:12:04.000
Trọng số trong các mô hình mạng nơ-ron được nhúng trong mô tả lớp của chúng, trong khi các Chương trình ML tuần tự hóa các trọng số riêng biệt.

00:12:04.000 --> 00:12:07.000
Và các mạng nơ-ron không chỉ định các loại tenxơ trung gian.

00:12:07.000 --> 00:12:11.000
Thay vào đó, đơn vị tính toán xác định các loại này trong thời gian chạy.

00:12:11.000 --> 00:12:15.000
Mặt khác, các chương trình ML có các tenxơ đánh máy mạnh.

00:12:15.000 --> 00:12:24.000
Hôm nay tôi sẽ tập trung vào cú pháp được nhập mạnh của Chương trình ML và ý nghĩa của các tenxơ trung gian được nhập có đối với việc học máy trên thiết bị với Chương trình ML.

00:12:24.000 --> 00:12:28.000
Nhưng trước tiên, làm thế nào để bạn có được một Chương trình ML?

00:12:28.000 --> 00:12:32.000
Core ML trước đây đã giới thiệu một API chuyển đổi thống nhất.

00:12:32.000 --> 00:12:42.000
API chuyển đổi thống nhất này cung cấp một phương tiện thuận tiện để đưa mô hình của bạn từ Tensorflow hoặc PyTorch sang mô hình mạng thần kinh Core ML với một lệnh gọi chức năng duy nhất.

00:12:42.000 --> 00:12:51.000
Bây giờ bạn có thể sử dụng cùng một API để chuyển đổi sang Chương trình ML bằng cách chọn iOS 15 làm mục tiêu triển khai tối thiểu.

00:12:51.000 --> 00:12:57.000
Dưới mui xe, bộ chuyển đổi Core ML chọn một biểu diễn trên đĩa cho mô hình tại thời điểm chuyển đổi.

00:12:57.000 --> 00:13:05.000
Đối với các Chương trình ML, biểu diễn trung gian trên đĩa được cung cấp bởi Ngôn ngữ Trung cấp Mô hình, một tính năng được giới thiệu tại WWDC 2020.

00:13:05.000 --> 00:13:12.000
API chuyển đổi thống nhất là nơi bạn có thể chọn tham gia để triển khai mô hình của mình dưới dạng Chương trình ML.

00:13:12.000 --> 00:13:16.000
Trong tương lai, Chương trình ML sẽ là định dạng được ưa chuộng hơn mạng nơ-ron.

00:13:16.000 --> 00:13:21.000
Và Chương trình ML có sẵn bắt đầu với iOS15 và macOS Monterey.

00:13:21.000 --> 00:13:31.000
Core ML hỗ trợ cả định dạng Mô hình ML và Gói ML cho các mô hình mạng thần kinh, nhưng Chương trình ML phải là Gói ML để lưu trữ trọng lượng của nó tách biệt với kiến trúc.

00:13:31.000 --> 00:13:35.000
Core ML đang đầu tư vào Chương trình ML như một nền tảng cho tương lai.

00:13:35.000 --> 00:13:40.000
Sẽ có sự hỗ trợ liên tục cho các mạng thần kinh, nhưng Chương trình ML sẽ là trung tâm của các tính năng mới.

00:13:40.000 --> 00:13:45.000
Vậy nếu Chương trình ML là tương lai, lợi ích của việc áp dụng Chương trình ML ngày hôm nay là gì?

00:13:45.000 --> 00:13:47.000
Điều này đưa chúng ta đến việc thực hiện đánh máy.

00:13:47.000 --> 00:13:54.000
Để làm nổi bật lợi ích của việc thực thi đánh máy với các Chương trình ML, trước tiên chúng ta hãy thảo luận về những gì xảy ra với mạng nơ-ron.

00:13:54.000 --> 00:14:04.000
Được hiển thị ở đây là đầu vào và đầu ra ví dụ cho mô hình Mạng thần kinh Core ML chỉ định Float32 cho các tenxơ đầu vào và đầu ra.

00:14:04.000 --> 00:14:09.000
Đầu vào và đầu ra cũng có thể là loại số nguyên kép hoặc 32 bit.

00:14:09.000 --> 00:14:13.000
Vì vậy, mô hình mạng nơ-ron mạnh mẽ nhập các tenxơ đầu vào và đầu ra này.

00:14:13.000 --> 00:14:17.000
Còn các loại tenxơ trung gian thì sao?

00:14:17.000 --> 00:14:21.000
Một mạng nơ-ron không đánh máy mạnh các tenxơ trung gian của nó.

00:14:21.000 --> 00:14:25.000
Không có thông tin về các loại tenxơ này trong mô hình trên đĩa.

00:14:25.000 --> 00:14:33.000
Thay vào đó, đơn vị tính toán chạy mô hình suy ra các loại tensor sau khi Core ML tải mô hình.

00:14:33.000 --> 00:14:43.000
Khi thời gian chạy Core ML tải một mạng thần kinh, nó sẽ tự động và tự động phân chia biểu đồ mạng thành các phần: Thân thiện với Apple Neural Engine, thân thiện với GPU và CPU.

00:14:43.000 --> 00:14:51.000
Mỗi đơn vị tính toán thực hiện phần của mạng bằng cách sử dụng loại gốc của nó để tối đa hóa hiệu suất và hiệu suất tổng thể của mô hình.

00:14:51.000 --> 00:14:57.000
GPU và Neural Engine đều sử dụng Float16, và CPU sử dụng Float32.

00:14:57.000 --> 00:15:07.000
Là nhà phát triển, bạn có một số quyền kiểm soát đối với sơ đồ thực thi này bằng cách chọn .all, .cpuAndGPU hoặc .cpuOnly với thuộc tính computeUnits của mô hình.

00:15:07.000 --> 00:15:18.000
Thuộc tính này mặc định là .all, hướng dẫn Core ML phân vùng mô hình trên công cụ thần kinh, GPU và CPU trong thời gian chạy để cung cấp cho ứng dụng của bạn hiệu suất tốt nhất có thể.

00:15:18.000 --> 00:15:28.000
Và nếu bạn đặt nó thành cpuOnly, Core ML sẽ không sử dụng Neural Engine hoặc GPU, điều này đảm bảo mô hình của bạn chỉ thực hiện độ chính xác Float32 trên CPU.

00:15:28.000 --> 00:15:36.000
Tóm lại, các mạng nơ-ron có các tenxơ trung gian, được tự động nhập trong thời gian chạy bởi đơn vị tính toán chịu trách nhiệm tạo ra chúng.

00:15:36.000 --> 00:15:46.000
Bạn có một số quyền kiểm soát độ chính xác của chúng bằng cách định cấu hình tập hợp các đơn vị tính toán được phép, nhưng làm như vậy là cài đặt toàn cầu cho mô hình và có thể để lại một số hiệu suất trên bảng.

00:15:46.000 --> 00:15:49.000
Còn Chương trình ML thì sao?

00:15:49.000 --> 00:15:58.000
Trong Chương trình ML được mô tả ở đây, các tenxơ đầu vào và đầu ra được nhập mạnh, và mọi tenxơ trung gian của chương trình cũng vậy.

00:15:58.000 --> 00:16:07.000
Bạn thậm chí có thể kết hợp và kết hợp hỗ trợ chính xác trong một đơn vị tính toán duy nhất, chẳng hạn như CPU hoặc GPU và các loại này được xác định rõ ràng tại thời điểm chuyển đổi mô hình.

00:16:07.000 --> 00:16:13.000
Đó là rất lâu trước khi bạn sử dụng Core ML để tải và chạy mô hình trong kịch bản triển khai.

00:16:13.000 --> 00:16:20.000
Các chương trình ML sử dụng cùng một sơ đồ phân chia tự động phân phối công việc cho Neural Engine, GPU và CPU.

00:16:20.000 --> 00:16:22.000
Tuy nhiên, nó thêm một ràng buộc kiểu.

00:16:22.000 --> 00:16:32.000
Core ML vẫn giữ được khả năng thúc đẩy tenxơ đến độ chính xác cao hơn, nhưng thời gian chạy Core ML không bao giờ sử dụng các tenxơ trung gian với độ chính xác thấp hơn độ chính xác được chỉ định trong Chương trình ML.

00:16:32.000 --> 00:16:45.000
Hỗ trợ mới này cho việc thực thi kiểu đã được thực hiện thông qua hỗ trợ op mở rộng trên cả GPU và CPU, đặc biệt là cho các hoạt động Float32 trên GPU và các hoạt động được chọn trong Float16 trên CPU.

00:16:45.000 --> 00:16:54.000
Với sự hỗ trợ mở rộng này, bạn vẫn có thể thấy lợi ích hiệu suất của GPU khi Chương trình ML của bạn chỉ định độ chính xác Float32.

00:16:54.000 --> 00:17:00.000
Hãy thử API chuyển đổi thống nhất để tạo ra các Chương trình ML với các độ chính xác khác nhau.

00:17:00.000 --> 00:17:07.000
Được rồi, bây giờ tôi đang ở trong một sổ ghi chép Jupyter, đây là một công cụ tiện lợi để thực thi mã Python theo cách tương tác.

00:17:07.000 --> 00:17:11.000
Tôi sẽ xem xét quá trình chuyển đổi một mô hình sang định dạng Chương trình ML mới.

00:17:11.000 --> 00:17:14.000
Mô hình tôi sẽ sử dụng hôm nay là mô hình chuyển đổi phong cách.

00:17:14.000 --> 00:17:18.000
Tôi đã tải xuống một mô hình Tensorflow được đào tạo trước từ Nguồn Mở.

00:17:18.000 --> 00:17:22.000
Mô hình này lấy một hình ảnh và tạo ra một hình ảnh cách điệu.

00:17:22.000 --> 00:17:24.000
Điều đầu tiên cần thiết là một vài báo cáo nhập khẩu.

00:17:24.000 --> 00:17:38.000
Tôi sẽ nhập coremltools, thư viện hình ảnh Python, cũng như một vài thư viện trợ giúp và các hàm trợ giúp đơn giản mà tôi đã viết để giữ cho mã tôi sử dụng ở đây ngắn gọn.

00:17:38.000 --> 00:17:43.000
Bây giờ tôi sẽ chỉ định đường dẫn của mô hình chuyển phong cách và đường dẫn đến hình ảnh mà tôi sẽ cách điệu.

00:17:43.000 --> 00:17:46.000
Tôi cũng sẽ thiết lập các loại đầu vào để chuyển đổi.

00:17:46.000 --> 00:17:52.000
Trong trường hợp này, nó sẽ là một loại đầu vào hình ảnh chỉ định kích thước của hình ảnh mà mô hình được đào tạo.

00:17:52.000 --> 00:18:00.000
Cuối cùng, có một số thiết lập bổ sung để chuẩn bị từ điển đầu vào mà tôi có thể sử dụng để chạy chuyển đổi sau mô hình Core ML.

00:18:00.000 --> 00:18:03.000
Vì vậy, đầu vào đã được tải và mô hình nguồn có sẵn.

00:18:03.000 --> 00:18:11.000
Tại thời điểm này, tất cả các tài nguyên bên ngoài đã sẵn sàng để chuyển đổi sang Chương trình ML.

00:18:11.000 --> 00:18:14.000
Để chuyển đổi, tôi sẽ sử dụng API chuyển đổi hợp nhất.

00:18:14.000 --> 00:18:17.000
Đối số đầu tiên là đường dẫn mô hình nguồn.

00:18:17.000 --> 00:18:19.000
Tiếp theo, chuyển mảng các loại đầu vào.

00:18:19.000 --> 00:18:21.000
Ở đây, chỉ có một cái.

00:18:21.000 --> 00:18:28.000
Cuối cùng, đối số mục tiêu triển khai tối thiểu sẽ xác định xem Công cụ Core ML tạo ra mạng nơ-ron hay Chương trình ML.

00:18:28.000 --> 00:18:32.000
Nó mặc định là iOS 13 và tạo ra một mạng lưới thần kinh.

00:18:32.000 --> 00:18:37.000
Ngay bây giờ tôi muốn có một Chương trình ML, vì vậy tôi sẽ đặt mục tiêu triển khai thành iOS 15.

00:18:37.000 --> 00:18:40.000
Cuối cùng tôi muốn triển khai mô hình này trên một ứng dụng iOS.

00:18:40.000 --> 00:18:47.000
Tôi có thể đã chỉ định một mục tiêu triển khai của macOS 12, nếu thiết bị mục tiêu của tôi là Mac.

00:18:47.000 --> 00:18:50.000
Tôi sẽ nhấn Shift-Enter để chuyển đổi mô hình.

00:18:50.000 --> 00:18:53.000
Và quá trình chuyển đổi đã hoàn tất.

00:18:53.000 --> 00:18:57.000
Có một sự biến đổi biểu đồ xảy ra tự động cho các Chương trình ML trong quá trình chuyển đổi.

00:18:57.000 --> 00:19:02.000
Nó được gọi là thẻ FP16ComputePrecision.

00:19:02.000 --> 00:19:09.000
Biểu đồ này truyền mọi tenxơ Float32 trong biểu đồ Tensorflow ban đầu sang tenxơ Float16 trong chương trình ML.

00:19:09.000 --> 00:19:15.000
Được rồi, bây giờ kể từ khi quá trình chuyển đổi hoàn tất, bước tiếp theo là kiểm tra tính chính xác của chương trình ML.

00:19:15.000 --> 00:19:23.000
Tôi có thể so sánh các số đầu ra với mô hình Tensorflow ban đầu bằng cách gọi dự đoán với cùng một hình ảnh với cả hai mô hình.

00:19:23.000 --> 00:19:32.000
Điều đáng chú ý là đối với các Chương trình ML, tôi đang sử dụng chính xác các API Công cụ ML Cốt lõi giống như những năm trước để dự đoán, lưu mô hình và các tiện ích khác.

00:19:32.000 --> 00:19:37.000
Để so sánh, tôi đã viết một phương thức tiện ích gọi là _get_coreml_tensorflow_output.

00:19:37.000 --> 00:19:45.000
Nó sẽ in ra nhiều chỉ số lỗi để đánh giá đầu ra từ Tensorflow và đầu ra từ Core ML.

00:19:45.000 --> 00:19:51.000
Vì vậy, vì đây là một hình ảnh, số liệu sai số thích hợp nhất có thể là tỷ lệ tín hiệu trên nhiễu, hoặc SNR.

00:19:51.000 --> 00:19:55.000
Trong thực tế, SNR trên 20 hoặc 30 thường là dấu hiệu của kết quả tốt.

00:19:55.000 --> 00:19:59.000
Ở đây tôi có SNR là 71, và điều đó khá tuyệt.

00:19:59.000 --> 00:20:04.000
Có một vài chỉ số khác: sai số tuyệt đối tối đa, sai số tuyệt đối trung bình.

00:20:04.000 --> 00:20:08.000
Tuy nhiên, tôi tò mò, chi phí chính xác của việc sử dụng Float16 là bao nhiêu?

00:20:08.000 --> 00:20:10.000
Tôi đã mất gì?

00:20:10.000 --> 00:20:16.000
Để tìm hiểu, tôi có thể vô hiệu hóa biến đổi Float16 và chuyển đổi lại.

00:20:16.000 --> 00:20:22.000
Tôi sẽ sử dụng cùng một lệnh chuyển đổi, nhưng lần này tôi sẽ chỉ định một đối số compute_precision và đặt nó thành Float32.

00:20:22.000 --> 00:20:32.000
Điều này sẽ yêu cầu bộ chuyển đổi không tiêm các phôi Float16 đó, và vì vậy bộ chuyển đổi Core ML Tools sẽ tạo ra Chương trình Float32 ML.

00:20:32.000 --> 00:20:41.000
Được rồi, bây giờ tôi sẽ so sánh Chương trình Float32 ML này với chương trình Tensorflow gốc.

00:20:41.000 --> 00:20:50.000
Và SNR đã tăng lên hơn 100, và sai số tuyệt đối tối đa đã giảm từ khoảng 1 xuống 0.02.

00:20:50.000 --> 00:20:55.000
Tôi vẫn chưa trả lời liệu lỗi mà tôi gặp phải trước đó với mô hình Float16 có bất kỳ tác động rõ ràng nào hay không.

00:20:55.000 --> 00:21:03.000
Đây là một mô hình chuyển đổi phong cách, vì vậy phán quyết có thể được đưa ra dựa trên một cốt truyện đơn giản của hình ảnh đầu ra.

00:21:03.000 --> 00:21:14.000
Tôi sẽ vẽ biểu đồ hình ảnh nguồn và các phiên bản cách điệu từ cả ba mô hình mà tôi có: Chương trình Float16 ML, chương trình Float32 ML và mô hình Tensorflow.

00:21:14.000 --> 00:21:17.000
Và tôi thực sự không thấy bất kỳ sự khác biệt nào giữa ba đầu ra của mô hình.

00:21:17.000 --> 00:21:24.000
Tất nhiên, việc đánh giá một hình ảnh duy nhất, một lần với một vài số liệu và kiểm tra trực quan thực sự chỉ là một bài kiểm tra khói.

00:21:24.000 --> 00:21:26.000
Mọi thứ có vẻ ổn.

00:21:26.000 --> 00:21:35.000
Trong thực tế, tôi sẽ đánh giá với nhiều chỉ số lỗi hơn trên một tập dữ liệu lớn, đánh giá các trường hợp lỗi trong đường ống được sử dụng bởi mô hình học máy và phân loại chúng.

00:21:35.000 --> 00:21:44.000
Tôi có sẵn một tập dữ liệu nhỏ và để tiến thêm một bước nữa với ví dụ này, tôi có thể so sánh hai Chương trình ML với mô hình Tensorflow cho mỗi hình ảnh trong tập dữ liệu.

00:21:44.000 --> 00:21:53.000
SNR của chương trình Float32 ML so với Tensorflow được mô tả là một đường màu đỏ với Xs, và Chương trình Float16 ML là một đường màu xanh lam với các vòng tròn.

00:21:53.000 --> 00:22:00.000
Chương trình Float32 ML dường như trung bình SNR khoảng 100 và Chương trình Float16 ML vẫn ở mức 70.

00:22:00.000 --> 00:22:05.000
Độ chính xác của Float16 ảnh hưởng đến các số một chút, nhưng nó có vẻ không đáng kể đối với trường hợp sử dụng này.

00:22:05.000 --> 00:22:09.000
Mặc dù, ngay cả trong tập dữ liệu nhỏ gồm 131 hình ảnh này, vẫn có một vài ngoại lệ.

00:22:09.000 --> 00:22:13.000
Nhìn chung, mô hình đang làm khá tốt những gì nó dự kiến sẽ làm.

00:22:13.000 --> 00:22:16.000
Và đây là trường hợp của phần lớn các mô hình học sâu.

00:22:16.000 --> 00:22:19.000
Chúng thường có xu hướng hoạt động tốt, ngay cả với độ chính xác của Float16.

00:22:19.000 --> 00:22:24.000
Đó là lý do tại sao chúng tôi đã bật biến đổi Float16 theo mặc định trong bộ chuyển đổi Core ML.

00:22:24.000 --> 00:22:33.000
Một chương trình ML kiểu Float16 sẽ có sẵn để thực thi trên động cơ thần kinh, có thể giúp tăng hiệu suất đáng kể và giảm mức tiêu thụ điện năng.

00:22:33.000 --> 00:22:43.000
Vì thời gian chạy coi các loại tenxơ là độ chính xác tối thiểu trong quá trình thực thi, Chương trình Float32 ML sẽ thực thi chỉ trên sự kết hợp của GPU và CPU.

00:22:43.000 --> 00:22:51.000
Bản demo này đã chứng minh việc kiểm soát độ chính xác tối thiểu mà Chương trình ML sẽ thực hiện ngay tại thời điểm chuyển đổi dễ dàng như thế nào.

00:22:51.000 --> 00:23:01.000
Và không giống như các mô hình Core ML mạng thần kinh, nếu mô hình của bạn cần độ chính xác cao hơn, bạn không cần phải thay đổi cài đặt của đơn vị tính toán thành cpuOnly trong mã ứng dụng để đạt được điều đó.

00:23:01.000 --> 00:23:07.000
Và như một lưu ý cuối cùng, sổ ghi chép demo này sẽ có sẵn như một ví dụ trên trang web tài liệu Công cụ Core ML.

00:23:07.000 --> 00:23:18.000
Tóm lại, để có được một chương trình ML, hãy sử dụng chức năng chuyển đổi và chuyển một đối số bổ sung để chỉ định mục tiêu triển khai và đặt nó thành ít nhất iOS 15 hoặc macOS 12.

00:23:18.000 --> 00:23:25.000
Theo mặc định, bộ chuyển đổi Core ML sẽ tạo ra một mô hình Float16 được tối ưu hóa đủ điều kiện để thực thi trên công cụ thần kinh.

00:23:25.000 --> 00:23:34.000
Nếu, như nó có thể xảy ra trong một số trường hợp, mô hình nhạy cảm với độ chính xác của Float16, thay vào đó, thật đơn giản để đặt độ chính xác thành Float32.

00:23:34.000 --> 00:23:45.000
Trên thực tế, có các tùy chọn nâng cao hơn có sẵn trong Core ML Tools API, sử dụng mà bạn có thể chọn các hoạt động cụ thể để thực thi trong Float32 trong khi vẫn giữ phần còn lại trong Float16 để tạo ra một Chương trình ML loại hỗn hợp.

00:23:45.000 --> 00:23:48.000
Vui lòng xem tài liệu của chúng tôi để biết những ví dụ này.

00:23:48.000 --> 00:23:54.000
Tóm lại, Core ML có một số cải tiến mới giúp điều chỉnh và làm việc với các mô hình của bạn dễ dàng hơn.

00:23:54.000 --> 00:23:59.000
Loại MLShapedArray mới giúp dễ dàng làm việc với dữ liệu đa chiều.

00:23:59.000 --> 00:24:03.000
Định dạng Gói ML cho phép bạn chỉnh sửa siêu dữ liệu trực tiếp trong Xcode.

00:24:03.000 --> 00:24:14.000
Gói ML với loại mô hình Chương trình ML mới hỗ trợ thực thi đánh máy với hỗ trợ Float32 trên GPU, cung cấp cho bạn nhiều tùy chọn hơn để chơi khi bạn điều chỉnh hiệu suất và độ chính xác của mô hình.

00:24:14.000 --> 00:24:18.000
Chúng tôi khuyến khích bạn nâng cấp mô hình của mình lên Gói ML và sử dụng Chương trình ML.

00:24:18.000 --> 00:24:22.000
Cảm ơn vì đã xem phiên của chúng tôi, và tận hưởng phần còn lại của WWDC.

00:24:22.000 --> 23:59:59.000
[Âm nhạc].

