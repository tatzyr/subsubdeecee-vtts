WEBVTT

00:00:00.000 --> 00:00:05.000
♪ Nhạc bass đang phát ♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:14.000
Dario Rexin: Xin chào, tên tôi là Dario Rexin, và tôi là một kỹ sư trong nhóm Swift tại Apple.

00:00:14.000 --> 00:00:22.000
Hôm nay, đồng nghiệp Doug của tôi và tôi sẽ nói về các diễn viên trong Swift và cách chúng được sử dụng để bảo vệ trạng thái có thể thay đổi trong các ứng dụng Swift đồng thời.

00:00:22.000 --> 00:00:29.000
Một trong những vấn đề khó khăn về cơ bản khi viết các chương trình đồng thời là tránh các cuộc đua dữ liệu.

00:00:29.000 --> 00:00:37.000
Các cuộc đua dữ liệu xảy ra khi hai luồng riêng biệt truy cập đồng thời vào cùng một dữ liệu và ít nhất một trong số các truy cập đó là ghi.

00:00:37.000 --> 00:00:42.000
Các cuộc đua dữ liệu rất tầm thường để xây dựng nhưng nổi tiếng là khó gỡ lỗi.

00:00:42.000 --> 00:00:48.000
Đây là một lớp bộ đếm đơn giản với một thao tác làm tăng bộ đếm và trả về giá trị mới của nó.

00:00:48.000 --> 00:00:52.000
Giả sử chúng ta tiếp tục và cố gắng tăng từ hai nhiệm vụ đồng thời.

00:00:52.000 --> 00:00:54.000
Đây là một ý tưởng tồi.

00:00:54.000 --> 00:01:00.000
Tùy thuộc vào thời gian thực hiện, chúng ta có thể nhận được 1 và sau đó là 2, hoặc 2 và sau đó là 1.

00:01:00.000 --> 00:01:05.000
Điều này được mong đợi, và trong cả hai trường hợp, bộ đếm sẽ được để ở trạng thái nhất quán.

00:01:05.000 --> 00:01:12.000
Nhưng bởi vì chúng tôi đã giới thiệu một cuộc đua dữ liệu, chúng tôi cũng có thể nhận được 1 và 1 nếu cả hai nhiệm vụ đều đọc 0 và viết 1.

00:01:12.000 --> 00:01:18.000
Hoặc thậm chí 2 và 2 nếu các câu lệnh trả về xảy ra sau cả hai thao tác gia tăng.

00:01:18.000 --> 00:01:22.000
Các cuộc đua dữ liệu nổi tiếng là khó tránh và gỡ lỗi.

00:01:22.000 --> 00:01:29.000
Họ yêu cầu lý luận không cục bộ vì việc truy cập dữ liệu gây ra cuộc đua có thể nằm trong các phần khác nhau của chương trình.

00:01:29.000 --> 00:01:38.000
Và chúng không xác định vì bộ lập lịch của hệ điều hành có thể xen kẽ các tác vụ đồng thời theo những cách khác nhau mỗi khi bạn chạy chương trình của mình.

00:01:38.000 --> 00:01:42.000
Các cuộc đua dữ liệu được gây ra bởi trạng thái có thể thay đổi được chia sẻ.

00:01:42.000 --> 00:01:49.000
Nếu dữ liệu của bạn không thay đổi hoặc nó không được chia sẻ trên nhiều tác vụ đồng thời, bạn không thể có một cuộc đua dữ liệu trên đó.

00:01:49.000 --> 00:01:56.000
Một cách để tránh các cuộc đua dữ liệu là loại bỏ trạng thái có thể thay đổi được chia sẻ bằng cách sử dụng ngữ nghĩa giá trị.

00:01:56.000 --> 00:02:00.000
Với một biến của một loại giá trị, tất cả các đột biến là cục bộ.

00:02:00.000 --> 00:02:09.000
Hơn nữa, các thuộc tính "cho phép" của các loại ngữ nghĩa giá trị thực sự bất biến, vì vậy việc truy cập chúng từ các tác vụ đồng thời khác nhau là an toàn.

00:02:09.000 --> 00:02:20.000
Swift đã thúc đẩy ngữ nghĩa giá trị kể từ khi thành lập vì chúng giúp lý luận về chương trình của chúng tôi dễ dàng hơn và những điều tương tự cũng giúp chúng an toàn khi sử dụng trong các chương trình đồng thời.

00:02:20.000 --> 00:02:24.000
Trong ví dụ này, chúng tôi tạo ra một mảng với một số giá trị.

00:02:24.000 --> 00:02:28.000
Tiếp theo, chúng tôi gán mảng đó cho biến thứ hai.

00:02:28.000 --> 00:02:32.000
Bây giờ chúng ta thêm một giá trị khác nhau vào mỗi bản sao của mảng.

00:02:32.000 --> 00:02:44.000
Khi chúng tôi in cả hai mảng ở cuối, chúng tôi thấy rằng cả hai bản sao đều chứa các giá trị mà mảng đã được khởi tạo, nhưng mỗi giá trị được thêm vào chỉ có trong bản sao tương ứng mà chúng tôi đã thêm chúng vào.

00:02:44.000 --> 00:02:55.000
Phần lớn các loại trong thư viện tiêu chuẩn của Swift có ngữ nghĩa giá trị, bao gồm các loại bộ sưu tập như từ điển, hoặc như trong ví dụ này, mảng.

00:02:55.000 --> 00:03:05.000
Bây giờ chúng ta đã thiết lập ngữ nghĩa giá trị đó giải quyết tất cả các cuộc đua dữ liệu của chúng ta, hãy tiếp tục và biến bộ đếm của chúng ta thành một loại giá trị bằng cách biến nó thành một cấu trúc.

00:03:05.000 --> 00:03:12.000
Chúng ta cũng phải đánh dấu hàm gia tăng là đột biến, vì vậy nó có thể sửa đổi thuộc tính giá trị.

00:03:12.000 --> 00:03:21.000
Khi chúng tôi đang cố gắng sửa đổi bộ đếm, chúng tôi sẽ gặp lỗi trình biên dịch vì bộ đếm là cho phép, điều này ngăn chúng tôi biến đổi nó.

00:03:21.000 --> 00:03:27.000
Bây giờ, có vẻ rất hấp dẫn khi chỉ thay đổi biến bộ đếm thành var để làm cho nó có thể thay đổi được.

00:03:27.000 --> 00:03:34.000
Nhưng điều đó sẽ khiến chúng ta, một lần nữa, với một điều kiện chủng tộc bởi vì bộ đếm sẽ được tham chiếu bởi cả hai nhiệm vụ đồng thời.

00:03:34.000 --> 00:03:41.000
May mắn thay, trình biên dịch đã bảo vệ chúng tôi và không cho phép chúng tôi biên dịch mã không an toàn này.

00:03:41.000 --> 00:03:47.000
Thay vào đó, chúng ta có thể gán bộ đếm cho một biến có thể thay đổi cục bộ bên trong mỗi tác vụ đồng thời.

00:03:47.000 --> 00:03:54.000
Khi chúng tôi thực hiện ví dụ của mình ngay bây giờ, nó sẽ luôn in 1 cho cả hai tác vụ đồng thời.

00:03:54.000 --> 00:03:59.000
Nhưng mặc dù mã của chúng tôi bây giờ không có chủng tộc, hành vi đó không còn là điều chúng tôi muốn nữa.

00:03:59.000 --> 00:04:06.000
Điều này cho thấy rằng vẫn có những trường hợp yêu cầu trạng thái có thể thay đổi được chia sẻ.

00:04:06.000 --> 00:04:17.000
Khi chúng tôi đã chia sẻ trạng thái có thể thay đổi trong một chương trình đồng thời, chúng tôi cần một số hình thức đồng bộ hóa để đảm bảo rằng việc sử dụng đồng thời trạng thái có thể thay đổi được chia sẻ của chúng tôi sẽ không gây ra các cuộc đua dữ liệu.

00:04:17.000 --> 00:04:27.000
Có một số nguyên thủy để đồng bộ hóa, từ các công cụ cấp thấp như nguyên tử và khóa đến các cấu trúc cấp cao hơn như hàng đợi điều phối nối tiếp.

00:04:27.000 --> 00:04:40.000
Mỗi nguyên thủy này có những điểm mạnh khác nhau, nhưng tất cả chúng đều có chung điểm yếu quan trọng: chúng đòi hỏi kỷ luật cẩn thận để sử dụng chính xác một cách chính xác, mọi lúc, hoặc chúng ta sẽ kết thúc với một cuộc đua dữ liệu.

00:04:40.000 --> 00:04:43.000
Đây là nơi các diễn viên bước vào.

00:04:43.000 --> 00:04:47.000
Các diễn viên là một cơ chế đồng bộ hóa cho trạng thái có thể thay đổi được chia sẻ.

00:04:47.000 --> 00:04:53.000
Một diễn viên có trạng thái riêng và trạng thái đó bị cô lập với phần còn lại của chương trình.

00:04:53.000 --> 00:04:57.000
Cách duy nhất để truy cập trạng thái đó là thông qua diễn viên.

00:04:57.000 --> 00:05:05.000
Và bất cứ khi nào bạn xem qua diễn viên, cơ chế đồng bộ hóa của diễn viên đảm bảo rằng không có mã nào khác truy cập đồng thời vào trạng thái của diễn viên.

00:05:05.000 --> 00:05:16.000
Điều này mang lại cho chúng tôi cùng một thuộc tính loại trừ lẫn nhau mà chúng tôi nhận được từ việc sử dụng khóa thủ công hoặc hàng đợi điều phối nối tiếp, nhưng với các tác nhân, đó là một đảm bảo cơ bản do Swift cung cấp.

00:05:16.000 --> 00:05:22.000
Bạn không thể quên thực hiện đồng bộ hóa, bởi vì Swift sẽ tạo ra lỗi trình biên dịch nếu bạn thử.

00:05:22.000 --> 00:05:24.000
Diễn viên là một loại hình mới trong Swift.

00:05:24.000 --> 00:05:29.000
Chúng cung cấp các khả năng giống như tất cả các loại được đặt tên trong Swift.

00:05:29.000 --> 00:05:34.000
Chúng có thể có các thuộc tính, phương thức, trình khởi tạo, chỉ số con, v.v.

00:05:34.000 --> 00:05:39.000
Chúng có thể phù hợp với các giao thức và được tăng cường với các phần mở rộng.

00:05:39.000 --> 00:05:45.000
Giống như các lớp học, chúng là các loại tham chiếu; bởi vì mục đích của các diễn viên là thể hiện trạng thái có thể thay đổi được chia sẻ.

00:05:45.000 --> 00:05:56.000
Trên thực tế, đặc điểm phân biệt chính của các loại diễn viên là chúng cô lập dữ liệu phiên bản của chúng với phần còn lại của chương trình và đảm bảo quyền truy cập đồng bộ vào dữ liệu đó.

00:05:56.000 --> 00:06:00.000
Tất cả hành vi đặc biệt của họ đều xuất phát từ những ý tưởng cốt lõi đó.

00:06:00.000 --> 00:06:03.000
Ở đây, chúng tôi đã xác định bộ đếm của mình là một loại diễn viên.

00:06:03.000 --> 00:06:11.000
Chúng tôi vẫn có giá trị thuộc tính thể hiện cho bộ đếm và phương thức tăng để tăng giá trị đó và trả về giá trị mới.

00:06:11.000 --> 00:06:16.000
Sự khác biệt là diễn viên sẽ đảm bảo giá trị không được truy cập đồng thời.

00:06:16.000 --> 00:06:23.000
Trong trường hợp này, điều đó có nghĩa là phương thức tăng, khi được gọi, sẽ chạy đến hoàn thành mà không cần bất kỳ mã nào khác thực thi trên diễn viên.

00:06:23.000 --> 00:06:29.000
Sự đảm bảo đó loại bỏ khả năng xảy ra các cuộc đua dữ liệu ở trạng thái của diễn viên.

00:06:29.000 --> 00:06:33.000
Hãy mang lại ví dụ cuộc đua dữ liệu của chúng ta.

00:06:33.000 --> 00:06:37.000
Chúng tôi lại có hai nhiệm vụ đồng thời cố gắng tăng cùng một bộ đếm.

00:06:37.000 --> 00:06:46.000
Cơ chế đồng bộ hóa nội bộ của diễn viên đảm bảo rằng một cuộc gọi gia tăng được thực hiện để hoàn thành trước khi cuộc gọi kia có thể bắt đầu.

00:06:46.000 --> 00:07:04.000
Vì vậy, chúng tôi có thể nhận được 1 và 2 hoặc 2 và 1 vì cả hai đều là các thực thi đồng thời hợp lệ, nhưng chúng tôi không thể nhận được cùng một số lượng hai lần hoặc bỏ qua bất kỳ giá trị nào vì sự đồng bộ hóa bên trong của diễn viên đã loại bỏ tiềm năng cho các cuộc đua dữ liệu ở trạng thái diễn viên.

00:07:04.000 --> 00:07:11.000
Hãy xem xét điều gì thực sự xảy ra khi cả hai nhiệm vụ đồng thời cố gắng tăng bộ đếm cùng một lúc.

00:07:11.000 --> 00:07:14.000
Một người sẽ đến đó trước, và người kia sẽ phải đợi đến lượt mình.

00:07:14.000 --> 00:07:20.000
Nhưng làm thế nào chúng ta có thể đảm bảo rằng nhiệm vụ thứ hai có thể kiên nhẫn chờ đợi đến lượt diễn viên?

00:07:20.000 --> 00:07:22.000
Swift có một cơ chế cho điều đó.

00:07:22.000 --> 00:07:27.000
Bất cứ khi nào bạn tương tác với một diễn viên từ bên ngoài, bạn làm như vậy một cách không đồng bộ.

00:07:27.000 --> 00:07:34.000
Nếu diễn viên đang bận, thì mã của bạn sẽ tạm dừng để CPU bạn đang chạy có thể thực hiện các công việc hữu ích khác.

00:07:34.000 --> 00:07:41.000
Khi diễn viên được tự do trở lại, nó sẽ đánh thức mã của bạn - tiếp tục thực thi - để cuộc gọi có thể chạy trên diễn viên.

00:07:41.000 --> 00:07:50.000
Từ khóa await trong ví dụ này chỉ ra rằng cuộc gọi không đồng bộ đến diễn viên có thể liên quan đến việc tạm ngưng như vậy.

00:07:50.000 --> 00:07:56.000
Hãy kéo dài ví dụ ngược lại của chúng ta xa hơn một chút bằng cách thêm thao tác đặt lại chậm một cách không cần thiết.

00:07:56.000 --> 00:08:05.000
Thao tác này đặt giá trị trở lại 0, sau đó gọi tăng số lần thích hợp để đưa bộ đếm đến giá trị mới.

00:08:05.000 --> 00:08:12.000
Phương pháp resetSlowly này được xác định trong một phần mở rộng của loại diễn viên truy cập để nó nằm bên trong diễn viên.

00:08:12.000 --> 00:08:19.000
Điều đó có nghĩa là nó có thể truy cập trực tiếp vào trạng thái của diễn viên, điều này sẽ đặt lại giá trị bộ đếm về 0.

00:08:19.000 --> 00:08:26.000
Nó cũng có thể gọi đồng bộ các phương thức khác trên diễn viên, chẳng hạn như trong cuộc gọi tăng.

00:08:26.000 --> 00:08:31.000
Không cần chờ đợi vì chúng tôi đã biết rằng chúng tôi đang chạy trên diễn viên.

00:08:31.000 --> 00:08:34.000
Đây là một tài sản quan trọng của các diễn viên.

00:08:34.000 --> 00:08:39.000
Mã đồng bộ trên diễn viên luôn chạy đến hoàn thành mà không bị gián đoạn.

00:08:39.000 --> 00:08:47.000
Vì vậy, chúng ta có thể lý luận về mã đồng bộ một cách tuần tự, mà không cần phải xem xét ảnh hưởng của sự đồng thời đối với trạng thái diễn viên của chúng ta.

00:08:47.000 --> 00:08:56.000
Chúng tôi đã nhấn mạnh rằng mã đồng bộ của chúng tôi chạy không bị gián đoạn, nhưng các tác nhân thường tương tác với nhau hoặc với các mã không đồng bộ khác trong hệ thống.

00:08:56.000 --> 00:09:00.000
Hãy dành vài phút để nói về mã và diễn viên không đồng bộ.

00:09:00.000 --> 00:09:02.000
Nhưng trước tiên, chúng ta cần một ví dụ tốt hơn.

00:09:02.000 --> 00:09:05.000
Ở đây chúng tôi đang xây dựng một diễn viên tải xuống hình ảnh.

00:09:05.000 --> 00:09:09.000
Nó chịu trách nhiệm tải xuống một hình ảnh từ một dịch vụ khác.

00:09:09.000 --> 00:09:16.000
Nó cũng lưu trữ các hình ảnh đã tải xuống trong bộ nhớ cache để tránh tải xuống cùng một hình ảnh nhiều lần.

00:09:16.000 --> 00:09:26.000
Luồng logic rất đơn giản: kiểm tra bộ nhớ cache, tải xuống hình ảnh, sau đó ghi lại hình ảnh vào bộ nhớ cache trước khi quay lại.

00:09:26.000 --> 00:09:33.000
Bởi vì chúng tôi đang ở trong một diễn viên, mã này không có các cuộc đua dữ liệu cấp thấp; bất kỳ số lượng hình ảnh nào cũng có thể được tải xuống đồng thời.

00:09:33.000 --> 00:09:45.000
Cơ chế đồng bộ hóa của diễn viên đảm bảo rằng chỉ có một tác vụ có thể thực thi mã truy cập vào thuộc tính phiên bản bộ nhớ cache tại một thời điểm, vì vậy không có cách nào bộ nhớ cache có thể bị hỏng.

00:09:45.000 --> 00:09:51.000
Điều đó nói rằng, từ khóa chờ đợi ở đây đang truyền đạt điều gì đó rất quan trọng.

00:09:51.000 --> 00:09:57.000
Bất cứ khi nào một sự chờ đợi xảy ra, điều đó có nghĩa là chức năng có thể bị đình chỉ tại thời điểm này.

00:09:57.000 --> 00:10:04.000
Nó từ bỏ CPU của nó để mã khác trong chương trình có thể thực thi, điều này ảnh hưởng đến trạng thái chương trình tổng thể.

00:10:04.000 --> 00:10:09.000
Tại thời điểm chức năng của bạn tiếp tục, trạng thái chương trình tổng thể sẽ thay đổi.

00:10:09.000 --> 00:10:18.000
Điều quan trọng là phải đảm bảo rằng bạn chưa đưa ra giả định về trạng thái đó trước khi chờ đợi mà có thể không được giữ lại sau khi chờ đợi.

00:10:18.000 --> 00:10:23.000
Hãy tưởng tượng chúng ta có hai tác vụ đồng thời khác nhau đang cố gắng tìm nạp cùng một hình ảnh cùng một lúc.

00:10:23.000 --> 00:10:33.000
Người đầu tiên thấy rằng không có mục nhập bộ nhớ cache, tiến hành bắt đầu tải xuống hình ảnh từ máy chủ và sau đó bị đình chỉ vì quá trình tải xuống sẽ mất một lúc.

00:10:33.000 --> 00:10:40.000
Trong khi nhiệm vụ đầu tiên là tải xuống hình ảnh, một hình ảnh mới có thể được triển khai đến máy chủ dưới cùng một URL.

00:10:40.000 --> 00:10:44.000
Bây giờ, một tác vụ đồng thời thứ hai cố gắng tìm nạp hình ảnh dưới URL đó.

00:10:44.000 --> 00:10:52.000
Nó cũng không thấy mục nhập bộ nhớ cache vì lần tải xuống đầu tiên chưa kết thúc, sau đó bắt đầu tải xuống hình ảnh lần thứ hai.

00:10:52.000 --> 00:10:56.000
Nó cũng bị đình chỉ trong khi quá trình tải xuống hoàn tất.

00:10:56.000 --> 00:11:04.000
Sau một thời gian, một trong những lần tải xuống - giả sử đó là lần đầu tiên - sẽ hoàn thành và nhiệm vụ của nó sẽ tiếp tục thực hiện trên diễn viên.

00:11:04.000 --> 00:11:09.000
Nó điền vào bộ nhớ cache và trả về hình ảnh kết quả của một con mèo.

00:11:09.000 --> 00:11:13.000
Bây giờ nhiệm vụ thứ hai đã hoàn tất quá trình tải xuống, vì vậy nó thức dậy.

00:11:13.000 --> 00:11:18.000
Nó ghi đè lên cùng một mục nhập trong bộ nhớ cache với hình ảnh của con mèo buồn mà nó có.

00:11:18.000 --> 00:11:25.000
Vì vậy, mặc dù bộ nhớ cache đã được điền với một hình ảnh, bây giờ chúng tôi nhận được một hình ảnh khác cho cùng một URL.

00:11:25.000 --> 00:11:27.000
Đó là một chút bất ngờ.

00:11:27.000 --> 00:11:38.000
Chúng tôi mong đợi rằng một khi chúng tôi lưu trữ một hình ảnh, chúng tôi luôn lấy lại cùng một hình ảnh đó cho cùng một URL để giao diện người dùng của chúng tôi vẫn nhất quán, ít nhất là cho đến khi chúng tôi đi và xóa bộ nhớ cache theo cách thủ công.

00:11:38.000 --> 00:11:42.000
Nhưng ở đây, hình ảnh được lưu trong bộ nhớ cache đã thay đổi bất ngờ.

00:11:42.000 --> 00:11:49.000
Chúng tôi không có bất kỳ cuộc đua dữ liệu cấp thấp nào, nhưng vì chúng tôi đã đưa ra các giả định về trạng thái trong một thời gian chờ đợi, chúng tôi đã kết thúc với một lỗi tiềm ẩn.

00:11:49.000 --> 00:11:53.000
Việc sửa chữa ở đây là kiểm tra các giả định của chúng tôi sau khi chờ đợi.

00:11:53.000 --> 00:12:00.000
Nếu đã có một mục nhập trong bộ nhớ cache khi chúng tôi tiếp tục, chúng tôi sẽ giữ lại phiên bản gốc đó và vứt bỏ phiên bản mới.

00:12:00.000 --> 00:12:04.000
Một giải pháp tốt hơn là tránh tải xuống dư thừa hoàn toàn.

00:12:04.000 --> 00:12:08.000
Chúng tôi đã đưa giải pháp đó vào mã được liên kết với video này.

00:12:08.000 --> 00:12:16.000
Sự tái nhập diễn viên ngăn chặn bế tắc và đảm bảo tiến độ chuyển tiếp, nhưng nó yêu cầu bạn kiểm tra các giả định của mình trong mỗi lần chờ đợi.

00:12:16.000 --> 00:12:22.000
Để thiết kế tốt cho việc tái nhập, hãy thực hiện đột biến trạng thái tác nhân trong mã đồng bộ.

00:12:22.000 --> 00:12:29.000
Lý tưởng nhất, hãy làm điều đó trong một hàm đồng bộ để tất cả các thay đổi trạng thái được gói gọn tốt.

00:12:29.000 --> 00:12:34.000
Những thay đổi trạng thái có thể liên quan đến việc tạm thời đưa diễn viên của chúng ta vào trạng thái không nhất quán.

00:12:34.000 --> 00:12:38.000
Đảm bảo khôi phục tính nhất quán trước khi chờ đợi.

00:12:38.000 --> 00:12:41.000
Và hãy nhớ rằng chờ đợi là một điểm đình chỉ tiềm năng.

00:12:41.000 --> 00:12:47.000
Nếu mã của bạn bị đình chỉ, chương trình và thế giới sẽ tiếp tục trước khi mã của bạn được nối lại.

00:12:47.000 --> 00:12:55.000
Bất kỳ giả định nào bạn đã đưa ra về trạng thái toàn cầu, đồng hồ, bộ hẹn giờ hoặc diễn viên của bạn sẽ cần được kiểm tra sau khi chờ đợi.

00:12:55.000 --> 00:13:01.000
Và bây giờ đồng nghiệp Doug của tôi sẽ cho bạn biết thêm về sự cô lập diễn viên. Doug?

00:13:01.000 --> 00:13:03.000
Doug Gregor: Cảm ơn, Dario.

00:13:03.000 --> 00:13:08.000
Sự cô lập diễn viên là nền tảng cho hành vi của các loại diễn viên.

00:13:08.000 --> 00:13:17.000
Dario đã thảo luận về cách cô lập diễn viên được đảm bảo bởi mô hình ngôn ngữ Swift, thông qua các tương tác không đồng bộ từ bên ngoài diễn viên.

00:13:17.000 --> 00:13:29.000
Trong phần này, chúng ta sẽ nói về cách cô lập diễn viên tương tác với các tính năng ngôn ngữ khác, bao gồm tuân thủ giao thức, đóng và lớp học.

00:13:29.000 --> 00:13:36.000
Giống như các loại khác, các tác nhân có thể tuân thủ các giao thức miễn là chúng có thể đáp ứng các yêu cầu của giao thức.

00:13:36.000 --> 00:13:42.000
Ví dụ, hãy làm cho diễn viên LibraryAccount này phù hợp với giao thức Equatable.

00:13:42.000 --> 00:13:48.000
Phương pháp bình đẳng tĩnh so sánh hai tài khoản thư viện dựa trên số ID của chúng.

00:13:48.000 --> 00:13:55.000
Bởi vì phương thức là tĩnh, không có tự thể hiện và vì vậy nó không bị cô lập với diễn viên.

00:13:55.000 --> 00:14:02.000
Thay vào đó, chúng ta có hai tham số của loại diễn viên và phương thức tĩnh này nằm ngoài cả hai.

00:14:02.000 --> 00:14:09.000
Điều đó ổn vì việc triển khai chỉ truy cập trạng thái bất biến trên tác nhân.

00:14:09.000 --> 00:14:15.000
Hãy mở rộng ví dụ của chúng tôi hơn nữa để làm cho tài khoản thư viện của chúng tôi phù hợp với giao thức Hashable.

00:14:15.000 --> 00:14:20.000
Làm như vậy đòi hỏi phải thực hiện thao tác băm (vào), điều mà chúng ta có thể làm như thế này.

00:14:20.000 --> 00:14:26.000
Tuy nhiên, trình biên dịch Swift sẽ phàn nàn rằng sự phù hợp này không được phép.

00:14:26.000 --> 00:14:28.000
Chuyện gì đã xảy ra vậy?

00:14:28.000 --> 00:14:41.000
Chà, tuân thủ Hashable theo cách này có nghĩa là hàm này có thể được gọi từ bên ngoài diễn viên, nhưng hash (vào) không đồng bộ, vì vậy không có cách nào để duy trì sự cô lập của diễn viên.

00:14:41.000 --> 00:14:46.000
Để khắc phục điều này, chúng ta có thể làm cho phương pháp này không bị cô lập.

00:14:46.000 --> 00:14:55.000
Không cô lập có nghĩa là phương pháp này được coi là nằm ngoài diễn viên, mặc dù về mặt cú pháp, nó được mô tả trên diễn viên.

00:14:55.000 --> 00:15:02.000
Điều này có nghĩa là nó có thể đáp ứng yêu cầu đồng bộ từ giao thức Hashable.

00:15:02.000 --> 00:15:09.000
Bởi vì các phương pháp không cô lập được coi là nằm ngoài diễn viên, chúng không thể tham chiếu trạng thái có thể thay đổi trên diễn viên.

00:15:09.000 --> 00:15:14.000
Phương pháp này ổn vì nó đề cập đến số ID bất biến.

00:15:14.000 --> 00:15:28.000
Nếu chúng tôi cố gắng băm dựa trên thứ khác, chẳng hạn như mảng sách cho mượn, chúng tôi sẽ gặp lỗi vì quyền truy cập vào trạng thái có thể thay đổi từ bên ngoài sẽ cho phép chạy đua dữ liệu.

00:15:28.000 --> 00:15:30.000
Thế là đủ sự phù hợp của giao thức.

00:15:30.000 --> 00:15:33.000
Hãy nói về việc đóng cửa.

00:15:33.000 --> 00:15:42.000
Đóng cửa là các hàm nhỏ được xác định trong một hàm, sau đó có thể được chuyển sang một hàm khác để được gọi một thời gian sau đó.

00:15:42.000 --> 00:15:48.000
Giống như các hàm, một đóng có thể bị cô lập bởi diễn viên hoặc nó có thể không bị cô lập.

00:15:48.000 --> 00:15:55.000
Trong ví dụ này, chúng tôi sẽ đọc một số từ mỗi cuốn sách chúng tôi có cho mượn và trả lại tổng số trang chúng tôi đã đọc.

00:15:55.000 --> 00:16:00.000
Lời kêu gọi giảm liên quan đến việc đóng cửa thực hiện việc đọc.

00:16:00.000 --> 00:16:03.000
Lưu ý rằng không có sự chờ đợi trong cuộc gọi này để đọc Một số.

00:16:03.000 --> 00:16:11.000
Đó là bởi vì sự đóng cửa này, được hình thành trong hàm "đọc" bị cô lập bởi diễn viên, bản thân nó được cô lập bởi diễn viên.

00:16:11.000 --> 00:16:22.000
Chúng tôi biết điều này là an toàn vì hoạt động giảm sẽ thực hiện đồng bộ và không thể thoát khỏi việc đóng cửa ra một số luồng khác, nơi nó có thể gây ra truy cập đồng thời.

00:16:22.000 --> 00:16:25.000
Bây giờ, hãy làm điều gì đó khác biệt một chút.

00:16:25.000 --> 00:16:30.000
Tôi không có thời gian để đọc ngay bây giờ, vì vậy hãy đọc sau.

00:16:30.000 --> 00:16:32.000
Ở đây, chúng tôi tạo ra một nhiệm vụ tách rời.

00:16:32.000 --> 00:16:38.000
Một nhiệm vụ tách rời thực hiện việc đóng cửa đồng thời với các công việc khác mà diễn viên đang làm.

00:16:38.000 --> 00:16:44.000
Do đó, việc đóng cửa không thể thuộc về diễn viên hoặc chúng tôi sẽ giới thiệu các cuộc đua dữ liệu.

00:16:44.000 --> 00:16:47.000
Vì vậy, việc đóng cửa này không bị cô lập với diễn viên.

00:16:47.000 --> 00:16:55.000
Khi nó muốn gọi phương thức đọc, nó phải làm như vậy không đồng bộ, như được chỉ ra bởi await.

00:16:55.000 --> 00:17:02.000
Chúng tôi đã nói một chút về sự cô lập của diễn viên đối với mã, đó là liệu mã đó chạy bên trong diễn viên hay bên ngoài nó.

00:17:02.000 --> 00:17:07.000
Bây giờ, hãy nói về sự cô lập và dữ liệu diễn viên.

00:17:07.000 --> 00:17:14.000
Trong ví dụ tài khoản thư viện của chúng tôi, chúng tôi đã cẩn trọng tránh nói loại sách thực sự là gì.

00:17:14.000 --> 00:17:17.000
Tôi đã giả định đó là một loại giá trị, giống như một cấu trúc.

00:17:17.000 --> 00:17:25.000
Đó là một lựa chọn tốt bởi vì nó có nghĩa là tất cả trạng thái cho một ví dụ của diễn viên tài khoản thư viện là khép kín.

00:17:25.000 --> 00:17:32.000
Nếu chúng ta tiếp tục và gọi phương pháp này để chọn một cuốn sách ngẫu nhiên để đọc, chúng ta sẽ nhận được một bản sao của cuốn sách mà chúng ta có thể đọc.

00:17:32.000 --> 00:17:39.000
Những thay đổi chúng tôi thực hiện đối với bản sao cuốn sách của mình sẽ không ảnh hưởng đến diễn viên và ngược lại.

00:17:39.000 --> 00:17:45.000
Tuy nhiên, nếu biến cuốn sách thành một lớp học, mọi thứ sẽ hơi khác một chút.

00:17:45.000 --> 00:17:49.000
Diễn viên tài khoản thư viện của chúng tôi hiện tham khảo các trường hợp của lớp sách.

00:17:49.000 --> 00:17:52.000
Bản thân nó không phải là vấn đề.

00:17:52.000 --> 00:17:58.000
Tuy nhiên, điều gì sẽ xảy ra khi chúng ta gọi phương thức để chọn một cuốn sách ngẫu nhiên?

00:17:58.000 --> 00:18:05.000
Bây giờ chúng ta có một tham chiếu đến trạng thái có thể thay đổi của diễn viên, đã được chia sẻ bên ngoài diễn viên.

00:18:05.000 --> 00:18:09.000
Chúng tôi đã tạo ra tiềm năng cho các cuộc đua dữ liệu.

00:18:09.000 --> 00:18:18.000
Bây giờ, nếu chúng ta đi và cập nhật tiêu đề của cuốn sách, việc sửa đổi sẽ xảy ra ở trạng thái có thể truy cập được trong diễn viên.

00:18:18.000 --> 00:18:25.000
Bởi vì phương pháp truy cập không có trên diễn viên, sửa đổi này cuối cùng có thể là một cuộc đua dữ liệu.

00:18:25.000 --> 00:18:32.000
Các loại giá trị và tác nhân đều an toàn để sử dụng đồng thời, nhưng các lớp vẫn có thể gây ra vấn đề.

00:18:32.000 --> 00:18:38.000
Chúng tôi có tên cho các loại an toàn để sử dụng đồng thời: Có thể gửi được.

00:18:38.000 --> 00:18:44.000
Loại Sendable là loại có giá trị có thể được chia sẻ giữa các diễn viên khác nhau.

00:18:44.000 --> 00:18:56.000
Nếu bạn sao chép một giá trị từ nơi này sang nơi khác và cả hai nơi có thể sửa đổi một cách an toàn các bản sao của chính họ về giá trị đó mà không can thiệp lẫn nhau, loại đó có thể là Sendable.

00:18:56.000 --> 00:19:02.000
Các loại giá trị có thể gửi được vì mỗi bản sao là độc lập, như Dario đã nói trước đó.

00:19:02.000 --> 00:19:08.000
Các loại diễn viên có thể gửi được vì chúng đồng bộ hóa quyền truy cập vào trạng thái có thể thay đổi của chúng.

00:19:08.000 --> 00:19:12.000
Các lớp học có thể được gửi đi, nhưng chỉ khi chúng được triển khai cẩn thận.

00:19:12.000 --> 00:19:20.000
Ví dụ, nếu một lớp và tất cả các lớp con của nó chỉ chứa dữ liệu bất biến, thì nó có thể được gọi là Sendable.

00:19:20.000 --> 00:19:29.000
Hoặc nếu lớp thực hiện đồng bộ hóa nội bộ, ví dụ như với khóa, để đảm bảo truy cập đồng thời an toàn, nó có thể là Sendable.

00:19:29.000 --> 00:19:34.000
Nhưng hầu hết các lớp học đều không phải trong số này, và không thể gửi được.

00:19:34.000 --> 00:19:42.000
Các hàm không nhất thiết phải có thể gửi được, vì vậy có một loại chức năng mới cho các chức năng an toàn để truyền qua các tác nhân.

00:19:42.000 --> 00:19:44.000
Chúng tôi sẽ sớm quay lại với những thứ đó.

00:19:44.000 --> 00:19:52.000
Các tác nhân của bạn - trên thực tế, tất cả mã đồng thời của bạn - chủ yếu nên giao tiếp theo các loại Có thể gửi được.

00:19:52.000 --> 00:19:55.000
Các loại có thể gửi được bảo vệ mã khỏi các cuộc đua dữ liệu.

00:19:55.000 --> 00:19:59.000
Đây là một thuộc tính mà Swift cuối cùng sẽ bắt đầu kiểm tra tĩnh.

00:19:59.000 --> 00:20:06.000
Tại thời điểm đó, sẽ trở thành một lỗi khi chuyển một loại không thể gửi qua ranh giới diễn viên.

00:20:06.000 --> 00:20:09.000
Làm thế nào để người ta biết rằng một loại có thể gửi được?

00:20:09.000 --> 00:20:16.000
Chà, Sendable là một giao thức và bạn nói rằng loại của bạn phù hợp với Sendable giống như cách bạn làm với các giao thức khác.

00:20:16.000 --> 00:20:22.000
Swift sau đó sẽ kiểm tra để đảm bảo loại của bạn có ý nghĩa như một loại Có thể gửi được.

00:20:22.000 --> 00:20:27.000
Cấu trúc Sách có thể là Có thể gửi được nếu tất cả các thuộc tính được lưu trữ của nó thuộc loại Có thể gửi được.

00:20:27.000 --> 00:20:36.000
Giả sử Tác giả thực sự là một lớp, có nghĩa là nó - và do đó mảng tác giả - không thể gửi được.

00:20:36.000 --> 00:20:43.000
Swift sẽ tạo ra lỗi trình biên dịch chỉ ra rằng Book không thể gửi được.

00:20:43.000 --> 00:20:48.000
Đối với các loại chung, việc chúng có thể gửi được hay không có thể phụ thuộc vào các đối số chung của chúng.

00:20:48.000 --> 00:20:53.000
Chúng ta có thể sử dụng sự phù hợp có điều kiện để truyền bá Sendable khi thích hợp.

00:20:53.000 --> 00:21:00.000
Ví dụ, một loại cặp sẽ chỉ là Sendable khi cả hai đối số chung của nó đều là Sendable.

00:21:00.000 --> 00:21:07.000
Cách tiếp cận tương tự được sử dụng để kết luận rằng một mảng các loại Sendable tự nó là Sendable.

00:21:07.000 --> 00:21:14.000
Chúng tôi khuyến khích bạn giới thiệu sự phù hợp Sendable cho các loại có giá trị an toàn để chia sẻ đồng thời.

00:21:14.000 --> 00:21:16.000
Sử dụng những loại đó trong diễn viên của bạn.

00:21:16.000 --> 00:21:23.000
Sau đó, khi Swift bắt đầu thực thi Sendable giữa các diễn viên, mã của bạn sẽ sẵn sàng.

00:21:23.000 --> 00:21:29.000
Bản thân các hàm có thể được Gửi được, có nghĩa là việc truyền giá trị hàm qua các tác nhân là an toàn.

00:21:29.000 --> 00:21:37.000
Điều này đặc biệt quan trọng đối với việc đóng cửa, nơi nó hạn chế những gì việc đóng cửa có thể làm để giúp ngăn chặn các cuộc đua dữ liệu.

00:21:37.000 --> 00:21:46.000
Ví dụ, đóng Sendable không thể nắm bắt được biến cục bộ có thể thay đổi, bởi vì điều đó sẽ cho phép các cuộc đua dữ liệu trên biến cục bộ.

00:21:46.000 --> 00:21:55.000
Bất cứ thứ gì mà việc đóng cửa nắm bắt cần phải có thể gửi được, để đảm bảo rằng việc đóng cửa không thể được sử dụng để di chuyển các loại không thể gửi qua ranh giới diễn viên.

00:21:55.000 --> 00:22:05.000
Và cuối cùng, một đóng Sendable đồng bộ không thể bị cô lập bởi diễn viên, bởi vì điều đó sẽ cho phép mã được chạy trên diễn viên từ bên ngoài.

00:22:05.000 --> 00:22:10.000
Chúng tôi thực sự đang dựa vào ý tưởng đóng cửa Sendable trong buổi nói chuyện này.

00:22:10.000 --> 00:22:20.000
Thao tác tạo ra các tác vụ tách rời nhận một hàm Sendable, được viết ở đây với @Sendable trong loại hàm.

00:22:20.000 --> 00:22:23.000
Bạn có nhớ ví dụ phản biện của chúng ta từ đầu cuộc nói chuyện không?

00:22:23.000 --> 00:22:26.000
Chúng tôi đã cố gắng xây dựng một bộ đếm kiểu giá trị.

00:22:26.000 --> 00:22:33.000
Sau đó, chúng tôi đã cố gắng đi và sửa đổi nó từ hai lần đóng khác nhau cùng một lúc.

00:22:33.000 --> 00:22:36.000
Đây sẽ là một cuộc đua dữ liệu trên biến cục bộ có thể thay đổi.

00:22:36.000 --> 00:22:44.000
Tuy nhiên, vì việc đóng cho một nhiệm vụ tách rời là Sendable, Swift sẽ tạo ra lỗi ở đây.

00:22:44.000 --> 00:22:51.000
Các loại hàm có thể gửi được sử dụng để chỉ ra nơi thực thi đồng thời có thể xảy ra và do đó ngăn chặn các cuộc đua dữ liệu.

00:22:51.000 --> 00:22:55.000
Đây là một ví dụ khác mà chúng ta đã thấy trước đó.

00:22:55.000 --> 00:23:02.000
Bởi vì việc đóng cửa cho nhiệm vụ tách rời là Sendable, chúng tôi biết rằng nó không nên bị cô lập với diễn viên.

00:23:02.000 --> 00:23:08.000
Do đó, các tương tác với nó sẽ phải không đồng bộ.

00:23:08.000 --> 00:23:20.000
Các loại có thể gửi và đóng giúp duy trì sự cô lập của diễn viên bằng cách kiểm tra rằng trạng thái có thể thay đổi không được chia sẻ giữa các tác nhân và không thể sửa đổi đồng thời.

00:23:20.000 --> 00:23:28.000
Chúng tôi đã nói chủ yếu về các loại diễn viên và cách chúng tương tác với các giao thức, đóng và các loại Có thể gửi được.

00:23:28.000 --> 00:23:34.000
Có một diễn viên nữa để thảo luận - một diễn viên đặc biệt mà chúng tôi gọi là diễn viên chính.

00:23:34.000 --> 00:23:38.000
Khi bạn đang xây dựng một ứng dụng, bạn cần suy nghĩ về chủ đề chính.

00:23:38.000 --> 00:23:46.000
Đó là nơi kết xuất giao diện người dùng cốt lõi xảy ra, cũng như nơi các sự kiện tương tác người dùng được xử lý.

00:23:46.000 --> 00:23:51.000
Các hoạt động hoạt động với giao diện người dùng thường cần được thực hiện từ luồng chính.

00:23:51.000 --> 00:23:55.000
Tuy nhiên, bạn không muốn làm tất cả công việc của mình trên chủ đề chính.

00:23:55.000 --> 00:24:06.000
Nếu bạn làm quá nhiều việc trên luồng chính, giả sử, vì bạn có một số thao tác đầu vào/đầu ra chậm hoặc chặn tương tác với máy chủ, giao diện người dùng của bạn sẽ bị đóng băng.

00:24:06.000 --> 00:24:18.000
Vì vậy, bạn cần phải cẩn thận để thực hiện công việc trên luồng chính khi nó tương tác với giao diện người dùng nhưng nhanh chóng thoát khỏi luồng chính cho các hoạt động tốn kém về mặt tính toán hoặc chờ đợi lâu.

00:24:18.000 --> 00:24:29.000
Vì vậy, chúng tôi làm việc trên luồng chính khi chúng tôi có thể và sau đó gọi DispatchQueue.main.async trong mã của bạn bất cứ khi nào bạn có một thao tác cụ thể phải được thực hiện trên luồng chính.

00:24:29.000 --> 00:24:35.000
Quay trở lại từ các chi tiết của cơ chế, cấu trúc của mã này trông mơ hồ quen thuộc.

00:24:35.000 --> 00:24:41.000
Trên thực tế, tương tác với chủ đề chính rất giống với tương tác với một diễn viên.

00:24:41.000 --> 00:24:47.000
Nếu bạn biết bạn đang chạy trên luồng chính, bạn có thể truy cập và cập nhật trạng thái giao diện người dùng của mình một cách an toàn.

00:24:47.000 --> 00:24:52.000
Nếu bạn không chạy trên luồng chính, bạn cần tương tác với nó một cách không đồng bộ.

00:24:52.000 --> 00:24:55.000
Đây chính xác là cách các diễn viên làm việc.

00:24:55.000 --> 00:25:02.000
Có một diễn viên đặc biệt để mô tả chủ đề chính, mà chúng tôi gọi là diễn viên chính.

00:25:02.000 --> 00:25:06.000
Diễn viên chính là một diễn viên đại diện cho chủ đề chính.

00:25:06.000 --> 00:25:10.000
Nó khác với một diễn viên bình thường theo hai cách quan trọng.

00:25:10.000 --> 00:25:16.000
Đầu tiên, diễn viên chính thực hiện tất cả sự đồng bộ hóa của nó thông qua hàng đợi điều phối chính.

00:25:16.000 --> 00:25:24.000
Điều này có nghĩa là, từ góc độ thời gian chạy, diễn viên chính có thể hoán đổi cho nhau bằng cách sử dụng DispatchQueue.main.

00:25:24.000 --> 00:25:30.000
Thứ hai, mã và dữ liệu cần có trên luồng chính nằm rải rác khắp nơi.

00:25:30.000 --> 00:25:35.000
Nó có trong SwiftUI, AppKit, UIKit và các khung hệ thống khác.

00:25:35.000 --> 00:25:41.000
Nó trải rộng trên các chế độ xem của riêng bạn, bộ điều khiển chế độ xem và các phần giao diện người dùng trong mô hình dữ liệu của bạn.

00:25:41.000 --> 00:25:49.000
Với Swift concurrency, bạn có thể đánh dấu một khai báo bằng thuộc tính diễn viên chính để nói rằng nó phải được thực thi trên diễn viên chính.

00:25:49.000 --> 00:25:54.000
Chúng tôi đã làm điều đó với thao tác kiểm tra ở đây, vì vậy nó luôn chạy trên diễn viên chính.

00:25:54.000 --> 00:26:04.000
Nếu bạn gọi nó từ bên ngoài diễn viên chính, bạn cần đợi, để cuộc gọi sẽ được thực hiện không đồng bộ trên chuỗi chính.

00:26:04.000 --> 00:26:12.000
Bằng cách đánh dấu mã phải chạy trên luồng chính là trên diễn viên chính, không còn phỏng đoán nào về thời điểm sử dụng DispatchQueue.main.

00:26:12.000 --> 00:26:20.000
Swift đảm bảo rằng mã này luôn được thực thi trên luồng chính.

00:26:20.000 --> 00:26:26.000
Các loại cũng có thể được đặt trên diễn viên chính, điều này làm cho tất cả các thành viên và lớp con của họ nằm trên diễn viên chính.

00:26:26.000 --> 00:26:34.000
Điều này hữu ích cho các phần của cơ sở mã của bạn phải tương tác với giao diện người dùng, nơi hầu hết mọi thứ cần chạy trên luồng chính.

00:26:34.000 --> 00:26:43.000
Các phương pháp riêng lẻ có thể chọn không tham gia thông qua từ khóa không cô lập, với các quy tắc tương tự mà bạn đã quen thuộc từ các diễn viên bình thường.

00:26:43.000 --> 00:26:57.000
Bằng cách sử dụng tác nhân chính cho các loại và hoạt động đối mặt với giao diện người dùng của bạn và giới thiệu các tác nhân của riêng bạn để quản lý trạng thái chương trình khác, bạn có thể kiến trúc ứng dụng của mình để đảm bảo sử dụng đồng thời an toàn, chính xác.

00:26:57.000 --> 00:27:11.000
Trong phiên này, chúng tôi đã nói về cách các diễn viên bảo vệ trạng thái có thể thay đổi của họ khỏi sự truy cập đồng thời, sử dụng cách ly diễn viên và bằng cách yêu cầu quyền truy cập không đồng bộ từ bên ngoài diễn viên để tuần tự hóa việc thực thi.

00:27:11.000 --> 00:27:16.000
Sử dụng các tác nhân để xây dựng các trừu tượng an toàn, đồng thời trong mã Swift của bạn.

00:27:16.000 --> 00:27:29.000
Trong việc triển khai các tác nhân của bạn và trong bất kỳ mã không đồng bộ nào, hãy luôn thiết kế để tái nhập; chờ đợi trong mã của bạn có nghĩa là thế giới có thể tiếp tục và làm mất hiệu lực các giả định của bạn.

00:27:29.000 --> 00:27:33.000
Các loại giá trị và tác nhân làm việc cùng nhau để loại bỏ các chủng tộc dữ liệu.

00:27:33.000 --> 00:27:42.000
Hãy lưu ý các lớp không xử lý đồng bộ hóa của riêng chúng và các loại không thể gửi khác giới thiệu lại trạng thái có thể thay đổi được chia sẻ.

00:27:42.000 --> 00:27:53.000
Cuối cùng, sử dụng diễn viên chính trên mã của bạn tương tác với giao diện người dùng để đảm bảo rằng mã phải có trên luồng chính luôn chạy trên luồng chính.

00:27:53.000 --> 00:28:01.000
Để tìm hiểu thêm về cách sử dụng các diễn viên trong ứng dụng của riêng bạn, hãy xem phiên của chúng tôi về việc cập nhật ứng dụng cho Swift đồng thời.

00:28:01.000 --> 00:28:11.000
Và để tìm hiểu thêm về việc triển khai mô hình đồng thời của Swift, bao gồm cả các diễn viên, hãy xem phiên "Hậu trường" của chúng tôi.

00:28:11.000 --> 00:28:14.000
Diễn viên là một phần cốt lõi của mô hình đồng thời Swift.

00:28:14.000 --> 00:28:23.000
Họ làm việc cùng nhau với sự đồng thời không đồng bộ/chờ đợi và có cấu trúc để giúp việc xây dựng các chương trình đồng thời chính xác và hiệu quả dễ dàng hơn.

00:28:23.000 --> 00:28:25.000
Chúng tôi nóng lòng muốn xem bạn xây dựng những gì với họ.

00:28:25.000 --> 23:59:59.000
♪

