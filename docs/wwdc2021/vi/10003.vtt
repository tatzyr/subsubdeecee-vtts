WEBVTT

00:00:02.000 --> 00:00:12.000
- Xin chào! Chào mừng đến với WWDC.

00:00:12.000 --> 00:00:17.000
Tên tôi là Anne Hitchcock, và tôi là một kỹ sư trong nhóm Watch Frameworks.

00:00:17.000 --> 00:00:24.000
Tôi rất vui khi có mặt ở đây hôm nay để nói về các chiến lược truyền dữ liệu trên Apple Watch.

00:00:24.000 --> 00:00:29.000
Kể từ khi được giới thiệu, Apple Watch ngày càng trở nên độc lập.

00:00:29.000 --> 00:00:35.000
Series 3 là Apple Watch đầu tiên có sẵn với khả năng di động.

00:00:35.000 --> 00:00:47.000
Ứng dụng Đồng hồ Độc lập trong watchOS 6 đã cung cấp cho bạn khả năng viết các ứng dụng không yêu cầu bạn đồng hành iOS và có thể được mua từ App Store trên Đồng hồ của khách hàng của bạn.

00:00:47.000 --> 00:00:56.000
Với sự ra đời của Thiết lập Gia đình trong watchOS 7, khách hàng của bạn có sự độc lập hơn bao giờ hết, mà không cần có iPhone đồng hành.

00:00:56.000 --> 00:01:05.000
Nhưng những khả năng mới này mang đến cho chúng tôi, với tư cách là nhà phát triển, những thách thức mới trong cách chúng tôi nghĩ về việc giao tiếp với các ứng dụng Đồng hồ của mình.

00:01:05.000 --> 00:01:09.000
May mắn thay, chúng tôi có rất nhiều lựa chọn tuyệt vời.

00:01:09.000 --> 00:01:16.000
Hôm nay chúng ta sẽ nói về những lựa chọn đó và cách chúng ta chọn đúng lựa chọn cho công việc.

00:01:16.000 --> 00:01:27.000
Tôi sẽ cung cấp cho bạn cái nhìn tổng quan về các công cụ chúng tôi có để giao tiếp dữ liệu trong các ứng dụng Watch và thảo luận về cách đánh giá cái nào sẽ là lựa chọn phù hợp cho nhiệm vụ của bạn.

00:01:27.000 --> 00:01:31.000
Chúng ta có thể nhóm rộng rãi các công cụ thành một vài danh mục.

00:01:31.000 --> 00:01:37.000
iCloud cho phép chúng tôi chia sẻ với tất cả các thiết bị của mình và cung cấp cho chúng tôi dung lượng lưu trữ máy chủ.

00:01:37.000 --> 00:01:46.000
Chúng ta có thể sử dụng cái này trong các ứng dụng của mình bằng cách sử dụng Keychain với Đồng bộ hóa iCloud và CoreData với CloudKit.

00:01:46.000 --> 00:01:54.000
Nếu chúng ta cần truyền dữ liệu giữa các thiết bị được ghép nối, chúng ta có thể sử dụng Watch Connectivity.

00:01:54.000 --> 00:02:01.000
Để giao tiếp trực tiếp với máy chủ, chúng ta có thể sử dụng các phiên hoặc ổ cắm URL.

00:02:01.000 --> 00:02:08.000
Nhưng trước tiên, chúng ta sẽ nói về những câu hỏi bạn có thể hỏi để chọn đúng câu hỏi.

00:02:08.000 --> 00:02:14.000
Khi tôi nghĩ về cách tôi sẽ giao tiếp từ ứng dụng Watch của mình, tôi nghĩ về một vài điều.

00:02:14.000 --> 00:02:17.000
Đó là loại dữ liệu gì?

00:02:17.000 --> 00:02:21.000
Và dữ liệu bây giờ ở đâu, và tôi cần nó ở đâu?

00:02:21.000 --> 00:02:26.000
Sự tương tác có phụ thuộc vào một ứng dụng iOS đồng hành không?

00:02:26.000 --> 00:02:30.000
Tôi có muốn hỗ trợ Thiết lập Gia đình không?

00:02:30.000 --> 00:02:33.000
Và khi nào dữ liệu cần phải đến đích?

00:02:33.000 --> 00:02:39.000
Nó có thể đợi để hệ thống tối ưu hóa hiệu suất và mức sử dụng pin cho khách hàng của tôi không?

00:02:39.000 --> 00:02:43.000
Dữ liệu sẽ thay đổi thường xuyên như thế nào?

00:02:43.000 --> 00:02:53.000
Dựa trên câu trả lời của tôi cho những câu hỏi này, tôi có thể bắt đầu xem qua hộp công cụ của mình để đánh giá cách tạo ra giải pháp phù hợp cho nhiệm vụ truyền dữ liệu của mình.

00:02:53.000 --> 00:03:00.000
Hãy xem chúng ta nhận được những khả năng gì từ Chuỗi khóa với Đồng bộ hóa iCloud.

00:03:00.000 --> 00:03:07.000
Keychain cung cấp lưu trữ an toàn cho mật khẩu, khóa và các thông tin đăng nhập nhạy cảm khác.

00:03:07.000 --> 00:03:18.000
Và với Đồng bộ hóa Chuỗi khóa iCloud, được giới thiệu trong watchOS 6.2, các mục móc khóa này có thể được đồng bộ hóa với tất cả các thiết bị của một người.

00:03:18.000 --> 00:03:30.000
Có hai cách bạn có thể hưởng lợi từ Đồng bộ hóa iCloud trong ứng dụng của mình: bằng cách sử dụng Tự động điền Mật khẩu với các mục Tên miền được liên kết và Chuỗi khóa được chia sẻ.

00:03:30.000 --> 00:03:37.000
Tự động điền mật khẩu cho phép bạn sử dụng đồng bộ hóa Keychain với rất ít mã.

00:03:37.000 --> 00:03:42.000
Đầu tiên, thêm khả năng Tên miền liên kết vào mục tiêu của bạn.

00:03:42.000 --> 00:03:47.000
Đối với ứng dụng Đồng hồ của bạn, hãy thêm khả năng vào Mục tiêu Mở rộng WatchKit.

00:03:47.000 --> 00:03:52.000
Thêm một mục nhập thông tin xác thực web với tên miền của bạn.

00:03:52.000 --> 00:03:58.000
Thêm tệp apple-app-site-association vào máy chủ web của bạn.

00:03:58.000 --> 00:04:02.000
Tệp phải có thể truy cập thông qua HTTPS mà không cần chuyển hướng.

00:04:02.000 --> 00:04:12.000
Tệp có định dạng JSON không có phần mở rộng tệp và nó nên được đặt trong thư mục ./nổi tiếng trên máy chủ của bạn.

00:04:12.000 --> 00:04:20.000
Kiểm tra tài liệu trực tuyến cho "Hỗ trợ tên miền liên kết" để biết chi tiết đầy đủ.

00:04:20.000 --> 00:04:24.000
Thêm các loại nội dung văn bản vào các trường văn bản của bạn và các trường bảo mật.

00:04:24.000 --> 00:04:32.000
Các tùy chọn của bạn để tự động điền là tên người dùng, địa chỉ email, mật khẩu và mật khẩu mới.

00:04:32.000 --> 00:04:41.000
Đối với mật khẩu mới, hệ thống sẽ nhắc người đó lưu và một bản ghi sẽ được thêm hoặc cập nhật trong Chuỗi khóa cho trang web của bạn.

00:04:41.000 --> 00:04:52.000
Các đề xuất Tự động điền đã có sẵn kể từ watchOS 6.2 và thậm chí còn tốt hơn với trải nghiệm chỉnh sửa văn bản mới trong watchOS 8.

00:04:52.000 --> 00:05:03.000
Để biết thêm thông tin về việc sử dụng tự động điền mật khẩu, hãy xem phiên "Tự động điền ở mọi nơi" trong ứng dụng Nhà phát triển hoặc trực tuyến.

00:05:03.000 --> 00:05:12.000
Một cách khác để bạn có thể chia sẻ dữ liệu bằng cách sử dụng đồng bộ hóa Chuỗi khóa là chia sẻ các mục Chuỗi khóa giữa các ứng dụng của bạn.

00:05:12.000 --> 00:05:20.000
Như chúng ta đã thảo luận, Keychain là nơi lưu trữ an toàn cho dữ liệu nhạy cảm, như mật khẩu, khóa và thông tin đăng nhập.

00:05:20.000 --> 00:05:32.000
Bạn cũng có thể lưu trữ các bit dữ liệu được chia sẻ nhỏ khác trong Chuỗi khóa, chẳng hạn như sở thích của một người đối với màn hình khởi động, miễn là thông tin không thay đổi thường xuyên.

00:05:32.000 --> 00:05:38.000
Dữ liệu được lưu trữ trong Chuỗi khóa sẽ được đồng bộ hóa với tất cả các thiết bị của người đó.

00:05:38.000 --> 00:05:46.000
Hãy xem cách chúng ta có thể lưu trữ và truy xuất mã thông báo OAuth 2 trong Chuỗi khóa và chia sẻ mã thông báo đó với một nhóm ứng dụng của chúng tôi.

00:05:46.000 --> 00:05:55.000
Đầu tiên, chúng ta cần thêm khả năng Chia sẻ Chuỗi khóa hoặc Nhóm Ứng dụng, tất cả các ứng dụng chúng ta muốn chia sẻ các mục chuỗi khóa này.

00:05:55.000 --> 00:06:05.000
Điều này được yêu cầu để chia sẻ các mục và giúp đảm bảo tính bảo mật và quyền riêng tư của thông tin khách hàng của bạn bằng cách ngăn chặn quyền truy cập của các ứng dụng khác.

00:06:05.000 --> 00:06:10.000
Đối với ứng dụng Đồng hồ của bạn, hãy thêm khả năng vào mục tiêu Tiện ích mở rộng Đồng hồ của bạn.

00:06:10.000 --> 00:06:17.000
Trong ví dụ này, tôi sẽ thêm khả năng Chia sẻ Chuỗi khóa và thêm ứng dụng của mình vào Nhóm Chuỗi khóa.

00:06:17.000 --> 00:06:24.000
Tất cả các ứng dụng của tôi sẽ chia sẻ các mục Keychain cũng cần chia sẻ nhóm này.

00:06:24.000 --> 00:06:29.000
Bây giờ, hãy xem mã để lưu trữ mã thông báo OAuth 2 trong Chuỗi khóa.

00:06:29.000 --> 00:06:35.000
Để lưu trữ mã thông báo, chúng tôi sẽ cập nhật mặt hàng nếu nó tồn tại và thêm nó nếu nó không tồn tại.

00:06:35.000 --> 00:06:44.000
Tôi đã tạo một cấu trúc mã thông báo OAuth 2 để chứa dữ liệu mã thông báo, như chuỗi mã thông báo, hết hạn và làm mới mã thông báo.

00:06:44.000 --> 00:06:50.000
Tôi đã làm cho cấu trúc mã thông báo phù hợp với mã hóa để dễ dàng lưu trữ và truy xuất.

00:06:50.000 --> 00:06:52.000
Chúng tôi tạo ra một từ điển truy vấn.

00:06:52.000 --> 00:07:00.000
Đây là tập hợp các thuộc tính khớp với một mục hiện có nếu chúng tôi đã lưu một thuộc tính cho máy chủ và tài khoản này.

00:07:00.000 --> 00:07:05.000
Lưu ý thuộc tính có thể đồng bộ hóa ở đây được đặt thành "đúng".

00:07:05.000 --> 00:07:14.000
Điều quan trọng là chúng tôi bao gồm thuộc tính này trong truy vấn của mình để chỉ ra rằng chúng tôi muốn mặt hàng của mình đồng bộ hóa với tất cả các thiết bị của khách hàng.

00:07:14.000 --> 00:07:21.000
Chúng tôi sẽ mã hóa mã thông báo dưới dạng dữ liệu và đặt Dữ liệu đó làm giá trị cho mục Keychain của chúng tôi trong từ điển thuộc tính.

00:07:21.000 --> 00:07:27.000
Sau đó, cập nhật mục trong Chuỗi khóa với truy vấn và thuộc tính.

00:07:27.000 --> 00:07:32.000
Chúng tôi luôn cần kiểm tra mã kết quả được trả về từ Keychain API.

00:07:32.000 --> 00:07:37.000
Trước tiên chúng ta sẽ kiểm tra xem Keychain có nói rằng mặt hàng đó không được tìm thấy hay không.

00:07:37.000 --> 00:07:42.000
Nếu vậy, chúng tôi sẽ gọi một hàm khác mà chúng tôi đã viết để thêm nó vào Chuỗi khóa.

00:07:42.000 --> 00:07:45.000
Chúng ta sẽ xem xét điều đó trong giây lát.

00:07:45.000 --> 00:07:48.000
Nếu không, chúng tôi sẽ đảm bảo rằng không có lỗi.

00:07:48.000 --> 00:07:52.000
Để làm điều đó, chúng tôi kiểm tra kết quả thành công.

00:07:52.000 --> 00:07:59.000
Nếu chức năng cập nhật trả về thành công, thì mã thông báo của chúng tôi đã được cập nhật trong Chuỗi khóa.

00:07:59.000 --> 00:08:02.000
Bây giờ, hãy nhìn vào chức năng thêm.

00:08:02.000 --> 00:08:07.000
Để thêm mã thông báo vào Chuỗi khóa, chúng tôi sẽ thiết lập một từ điển với tất cả các thuộc tính.

00:08:07.000 --> 00:08:14.000
Điều này bao gồm các thuộc tính mà chúng tôi đã sử dụng để tìm một mặt hàng hiện có, cộng với dữ liệu mã thông báo.

00:08:14.000 --> 00:08:19.000
Sau đó, chúng ta sẽ gọi hàm thêm của Keychain API với các thuộc tính.

00:08:19.000 --> 00:08:25.000
Và kiểm tra mã trả lại để đảm bảo nó thành công.

00:08:25.000 --> 00:08:32.000
Để truy xuất thông tin mã thông báo từ Chuỗi khóa, chúng tôi sẽ thiết lập một từ điển truy vấn để tìm mục chúng tôi muốn.

00:08:32.000 --> 00:08:39.000
Chúng tôi sẽ bao gồm cùng một bộ khóa và giá trị mà chúng tôi đã bao gồm để tìm mục trước đó trong chức năng cập nhật.

00:08:39.000 --> 00:08:52.000
Thêm vào đó, chúng tôi bao gồm một số thuộc tính để cho API Keychain biết liệu chúng tôi có muốn các thuộc tính mục được trả về hay không (chúng tôi không) và liệu chúng tôi có muốn dữ liệu mục được trả về hay không (chúng tôi muốn).

00:08:52.000 --> 00:09:02.000
Chức năng Keychain "sao chép phù hợp" tìm kiếm bằng cách sử dụng truy vấn của chúng tôi và điền tham chiếu mà chúng tôi đã cung cấp dưới dạng "mục".

00:09:02.000 --> 00:09:09.000
Trước khi chúng tôi cố gắng truy cập vào mặt hàng đã truy xuất, chúng tôi sẽ kiểm tra mã trả lại để đảm bảo rằng nó đã được tìm thấy.

00:09:09.000 --> 00:09:14.000
Sau đó, như mọi khi, chúng tôi kiểm tra mã trả lại để thành công.

00:09:14.000 --> 00:09:25.000
Lấy từ điển đã được sao chép cho mục, lấy dữ liệu mã thông báo mà chúng tôi yêu cầu từ từ điển và giải mã dữ liệu dưới dạng loại mã thông báo OAuth 2 của chúng tôi.

00:09:25.000 --> 00:09:38.000
Và bây giờ, chúng tôi đã lưu, cập nhật và truy xuất thành công mã thông báo OAuth 2 vào Chuỗi khóa và nó được chia sẻ với tất cả các ứng dụng trong Nhóm Chia sẻ Chuỗi khóa của chúng tôi.

00:09:38.000 --> 00:09:43.000
Có một chức năng lưu trữ Keychain nữa mà tôi muốn chia sẻ với bạn.

00:09:43.000 --> 00:09:50.000
Cũng giống như bất cứ nơi nào bạn lưu trữ thứ gì đó trên thiết bị của khách hàng, bạn nên loại bỏ nó khi bạn hoàn thành nó.

00:09:50.000 --> 00:09:56.000
Chúng tôi sẽ thiết lập truy vấn của mình với các thuộc tính quen thuộc hiện nay để tìm kiếm.

00:09:56.000 --> 00:10:01.000
Gọi hàm xóa của Keychain API với truy vấn của chúng tôi.

00:10:01.000 --> 00:10:04.000
Và, như mọi khi, hãy kiểm tra thành công.

00:10:04.000 --> 00:10:08.000
Trong trường hợp xóa, không tìm thấy là thành công.

00:10:08.000 --> 00:10:13.000
Bây giờ, chúng tôi hoàn thành việc dọn dẹp sau khi hoàn thành dữ liệu.

00:10:13.000 --> 00:10:27.000
Dịch vụ móc khóa với đồng bộ hóa chuỗi khóa iCloud là một cách tuyệt vời để ứng dụng của bạn chia sẻ các phần dữ liệu nhỏ không thay đổi thường xuyên và dữ liệu đó sẽ được đồng bộ hóa với tất cả các thiết bị của một người.

00:10:27.000 --> 00:10:34.000
Sử dụng Associated Domains để dễ dàng thêm chức năng tự động điền mật khẩu vào ứng dụng của bạn.

00:10:34.000 --> 00:10:43.000
Bạn cũng có thể lưu trữ và truy xuất các giá trị trực tiếp vào Chuỗi khóa và chia sẻ chúng với các ứng dụng khác của mình bằng cách sử dụng Chia sẻ Chuỗi khóa hoặc Nhóm ứng dụng.

00:10:43.000 --> 00:10:53.000
Đồng bộ hóa Chuỗi khóa iCloud không dựa vào việc có ứng dụng đồng hành iOS và nó hỗ trợ Thiết lập Gia đình.

00:10:53.000 --> 00:11:01.000
Các mục được đồng bộ hóa khi có thể dựa trên tính khả dụng của mạng, pin và các điều kiện hệ thống khác.

00:11:01.000 --> 00:11:10.000
Lưu ý rằng khách hàng có thể vô hiệu hóa đồng bộ hóa Chuỗi khóa iCloud và nó không khả dụng ở tất cả các khu vực.

00:11:10.000 --> 00:11:20.000
CoreData với CloudKit đồng bộ hóa cơ sở dữ liệu cục bộ của bạn với tất cả các thiết bị khác của khách hàng chia sẻ vùng chứa CloudKit của ứng dụng của bạn.

00:11:20.000 --> 00:11:29.000
Tích hợp CoreData với SwiftUI đơn giản hóa việc truy cập và hiển thị dữ liệu từ cơ sở dữ liệu của bạn trong ứng dụng Watch của bạn.

00:11:29.000 --> 00:11:36.000
Bạn có thể nhanh chóng nhận được quá nhiều dữ liệu trên Đồng hồ theo cách này nếu bạn đang phát triển một ứng dụng đa nền tảng.

00:11:36.000 --> 00:11:44.000
Hãy suy nghĩ cẩn thận về những thông tin mà khách hàng của bạn thực sự cần trên Đồng hồ của họ.

00:11:44.000 --> 00:12:00.000
Cân nhắc sử dụng nhiều cấu hình trong mô hình Dữ liệu cốt lõi của bạn để phân đoạn dữ liệu có ý nghĩa trong ứng dụng Đồng hồ của bạn từ dữ liệu phù hợp với ứng dụng của bạn chạy trên thiết bị có dung lượng lưu trữ và dung lượng pin cao hơn.

00:12:00.000 --> 00:12:03.000
CloudKit và Core Data là những công cụ mạnh mẽ.

00:12:03.000 --> 00:12:11.000
Việc tích hợp Core Data với SwiftUI giúp việc sử dụng các tính năng Core Data trong các ứng dụng của bạn dễ dàng hơn.

00:12:11.000 --> 00:12:22.000
Bạn có thể cung cấp ngữ cảnh đối tượng được quản lý" cho Lượt xem của mình với giá trị môi trường và sử dụng trình bao bọc thuộc tính yêu cầu tìm nạp để nhận kết quả từ cơ sở dữ liệu của bạn.

00:12:22.000 --> 00:12:28.000
Những kết quả đó có thể được sử dụng trong Danh sách SwiftUI và các chế độ xem khác.

00:12:28.000 --> 00:12:38.000
Dữ liệu cốt lõi với CloudKit cung cấp cho chúng tôi cách chia sẻ dữ liệu có cấu trúc có thể được đồng bộ hóa với tất cả các thiết bị của một người và được sao lưu trên iCloud.

00:12:38.000 --> 00:12:45.000
Nó không dựa vào việc có một ứng dụng iPhone đồng hành và hỗ trợ Thiết lập Gia đình.

00:12:45.000 --> 00:12:51.000
Đồng bộ hóa các thay đổi Dữ liệu Cốt lõi xảy ra dựa trên tính khả dụng của mạng và điều kiện hệ thống.

00:12:51.000 --> 00:13:00.000
Đừng mong đợi nó diễn ra tức thời, nhưng CloudKit sẽ xử lý việc tối ưu hóa hiệu suất của đồng bộ hóa này cho ứng dụng của bạn.

00:13:00.000 --> 00:13:19.000
Để tìm hiểu thêm về cách sử dụng Dữ liệu cốt lõi với CloudKit trong ứng dụng của bạn, hãy xem "Xây dựng các ứng dụng chia sẻ dữ liệu thông qua CloudKit và Dữ liệu cốt lõi" và "Mang dữ liệu cốt lõi đồng thời đến Swift và SwiftUI" trong ứng dụng dành cho nhà phát triển hoặc trực tuyến.

00:13:19.000 --> 00:13:25.000
Bạn có thể đã quen thuộc với Watch Connectivity, và bạn có thể đã sử dụng nó trước đây.

00:13:25.000 --> 00:13:32.000
Nhưng tôi muốn cung cấp cho bạn thêm chi tiết và một số phương pháp hay nhất để giúp bạn thành công.

00:13:32.000 --> 00:13:44.000
Watch Connectivity cho phép bạn gửi dữ liệu giữa ứng dụng Watch của mình và ứng dụng iPhone đồng hành của nó khi cả hai thiết bị đều nằm trong phạm vi Bluetooth hoặc trên cùng một mạng Wi-Fi.

00:13:44.000 --> 00:13:57.000
Nó được sử dụng tốt nhất để tối ưu hóa trải nghiệm của khách hàng khi họ đã cài đặt cả ứng dụng Điện thoại và Đồng hồ của bạn và để chia sẻ dữ liệu chỉ khả dụng trên một thiết bị.

00:13:57.000 --> 00:14:12.000
Ví dụ: nếu ai đó đã khởi chạy ứng dụng iPhone của bạn và đã tải xuống dữ liệu mới nhất, bạn có thể chia sẻ dữ liệu đó với ứng dụng Đồng hồ của mình để cập nhật các biến chứng của mình và cho phép ứng dụng Đồng hồ của bạn bắt đầu với cùng dữ liệu đó vào lần khởi chạy tiếp theo.

00:14:12.000 --> 00:14:20.000
Điều này sẽ cảm thấy phản hồi nhanh hơn cho khách hàng của bạn và giảm thiểu các bản tải xuống dữ liệu trùng lặp mà ứng dụng của bạn cần thực hiện.

00:14:20.000 --> 00:14:28.000
Watch Connectivity có một bộ tính năng đa dạng, vì vậy thật hữu ích khi biết những gì có sẵn và khi nào nên sử dụng từng tính năng.

00:14:28.000 --> 00:14:38.000
Nhưng trước tiên, tôi muốn chia sẻ một vài mẹo để giúp bạn thành công nếu bạn quyết định rằng Watch Connectivity là công cụ phù hợp cho nhiệm vụ của bạn.

00:14:38.000 --> 00:14:47.000
Vì Watch Connectivity là một công cụ để giao tiếp giữa hai thiết bị, nó sẽ yêu cầu chúng ta biết về một vài điều kiện tiên quyết và xử lý một số lỗi.

00:14:47.000 --> 00:14:53.000
Đây là một số điều bạn có thể làm để đảm bảo giao tiếp Kết nối Đồng hồ của bạn hoạt động trơn tru.

00:14:53.000 --> 00:15:04.000
Kích hoạt phiên kết nối đồng hồ của bạn càng sớm càng tốt trong vòng đời ứng dụng của bạn, tốt nhất là khi ứng dụng của bạn kết thúc khởi chạy trong ứng dụng hoặc đại diện tiện ích mở rộng của bạn.

00:15:04.000 --> 00:15:10.000
Điều này làm cho ứng dụng của bạn có sẵn để nhận thông tin từ ứng dụng đối tác của nó càng sớm càng tốt.

00:15:10.000 --> 00:15:13.000
Hiểu khả năng tiếp cận.

00:15:13.000 --> 00:15:19.000
Không có giao tiếp nền nào yêu cầu ứng dụng đối tác của bạn có thể truy cập được khi bạn gửi dữ liệu.

00:15:19.000 --> 00:15:25.000
Nhưng tin nhắn tương tác có các yêu cầu về khả năng tiếp cận và chúng ta sẽ thảo luận về chúng sau đó.

00:15:25.000 --> 00:15:29.000
Nó sẽ giúp bạn tiết kiệm thời gian để hiểu chúng.

00:15:29.000 --> 00:15:34.000
Tất cả các chức năng đại diện phiên kết nối đồng hồ được gọi trên một hàng đợi nối tiếp không chính.

00:15:34.000 --> 00:15:43.000
Nếu bạn cần thực hiện bất kỳ công việc nào từ các chức năng này để cập nhật giao diện người dùng của mình, hãy đảm bảo rằng bạn thực hiện điều đó trên hàng đợi chính.

00:15:43.000 --> 00:15:49.000
Bây giờ, hãy nói về các tính năng Kết nối Đồng hồ khác nhau và khi nào nên sử dụng từng tính năng.

00:15:49.000 --> 00:16:00.000
Ngữ cảnh ứng dụng là một từ điển danh sách thuộc tính duy nhất được gửi đến ứng dụng đối tác trong nền, với mục tiêu có sẵn khi ứng dụng thức dậy.

00:16:00.000 --> 00:16:08.000
Nếu bạn cập nhật ngữ cảnh ứng dụng trước khi từ điển trước đó được gửi đi, nó sẽ được thay thế bằng giá trị mới.

00:16:08.000 --> 00:16:18.000
Bối cảnh ứng dụng rất hữu ích để cập nhật nội dung trên ứng dụng đối tác khi bạn có dữ liệu mới và dữ liệu có thể cập nhật thường xuyên.

00:16:18.000 --> 00:16:28.000
Chuyển thông tin người dùng cũng gửi từ điển danh sách tài sản đến ứng dụng đối tác trong nền, nhưng nó hơi khác so với ngữ cảnh ứng dụng.

00:16:28.000 --> 00:16:40.000
Thay vì là một từ điển duy nhất được thay thế mỗi khi bạn cập nhật nó, mỗi lần chuyển từ điển thông tin người dùng được xếp hàng đợi và phân phối theo thứ tự mà bạn đã xếp hàng.

00:16:40.000 --> 00:16:44.000
Bạn cũng có thể truy cập hàng đợi để hủy chuyển khoản.

00:16:44.000 --> 00:16:52.000
Truyền tệp tương tự như truyền thông tin người dùng và một khi bạn đã hoàn thành một cái, cái còn lại sẽ cảm thấy quen thuộc.

00:16:52.000 --> 00:16:58.000
Các tệp được xếp hàng đợi để được gửi đến ứng dụng đối tác và được gửi khi nguồn điện và các điều kiện khác cho phép.

00:16:58.000 --> 00:17:03.000
Bạn có thể truy cập hàng đợi để hủy chuyển khoản.

00:17:03.000 --> 00:17:09.000
Các tệp được đặt trong hộp thư đến tài liệu cho ứng dụng nhận khi chúng được chuyển.

00:17:09.000 --> 00:17:17.000
Mỗi tệp sẽ bị xóa khỏi hộp thư đến khi bạn quay lại từ cuộc gọi lại tệp đã nhận được trong đại diện phiên của bạn.

00:17:17.000 --> 00:17:24.000
Đảm bảo rằng bạn di chuyển tệp hoặc nhanh chóng xử lý nó trước khi bạn quay lại từ phương pháp này.

00:17:24.000 --> 00:17:41.000
Một điều hữu ích cần nhớ về điều này: vì cuộc gọi lại này được gọi trên hàng đợi nối tiếp không chính, nếu bạn gọi một phương thức không đồng bộ để xử lý tệp từ hộp thư đến, rất có thể bạn sẽ gặp sự cố vì tệp sẽ biến mất.

00:17:41.000 --> 00:17:50.000
Thời gian truyền tệp dựa trên điều kiện hệ thống và tất nhiên, các tệp lớn hơn có thể mất nhiều thời gian hơn để truyền.

00:17:50.000 --> 00:18:00.000
transferCurrentComplicationUserInfo(_:) là một trường hợp đặc biệt của chức năng truyền thông tin người dùng để gửi dữ liệu liên quan đến biến chứng đến Đồng hồ.

00:18:00.000 --> 00:18:11.000
Nó được chuyển càng sớm càng tốt, trước khi chuyển thông tin người dùng khác, miễn là bạn có chuyển khoản phức tạp còn lại trong ngân sách của mình.

00:18:11.000 --> 00:18:20.000
Việc chuyển khoản ngay lập tức này cho phép bạn cập nhật các biến chứng đang hoạt động cho khách hàng khi bạn cập nhật dữ liệu từ điện thoại của mình.

00:18:20.000 --> 00:18:28.000
Bạn có thể kiểm tra ngân sách còn lại của mình và nếu bạn chuyển thông tin phức tạp hiện tại mà không có ngân sách còn lại, nó vẫn sẽ được gửi đi.

00:18:28.000 --> 00:18:34.000
Nó sẽ chỉ sử dụng hàng đợi chuyển thông tin người dùng thông thường.

00:18:34.000 --> 00:18:39.000
Bạn có thể sử dụng sendMessage để gửi dữ liệu đến ứng dụng đối tác của mình và nhận được phản hồi.

00:18:39.000 --> 00:18:44.000
Cái này dành cho nhắn tin tương tác khi có thể truy cập ứng dụng đối tác của bạn.

00:18:44.000 --> 00:18:49.000
Cho dù bạn đang gửi từ điển hay dữ liệu, hãy giữ cho tin nhắn của bạn nhỏ.

00:18:49.000 --> 00:18:55.000
Chúng tôi cũng khuyên bạn nên chọn bao gồm trình xử lý trả lời cho các cuộc gọi sendMessage của mình.

00:18:55.000 --> 00:19:02.000
Một câu trả lời ngắn cho phép bạn xác minh rằng ứng dụng đối tác đã nhận được tin nhắn và dữ liệu đó là chính xác.

00:19:02.000 --> 00:19:17.000
Khi bạn bao gồm trình xử lý trả lời đó trên sendMessage của mình, hãy đảm bảo rằng bạn triển khai phiên bản của chức năng gọi lại đại diện đã nhận tin nhắn hoặc đã nhận dữ liệu trong ứng dụng đối tác bao gồm trình xử lý trả lời.

00:19:17.000 --> 00:19:22.000
Nếu không, bạn sẽ gặp lỗi khi gửi tin nhắn.

00:19:22.000 --> 00:19:28.000
Bây giờ chúng ta đã nghe nói về sendMessage, hãy xem lại khái niệm về khả năng tiếp cận.

00:19:28.000 --> 00:19:32.000
Cả hai ứng dụng của bạn cần phải có thể truy cập được để gửi tin nhắn.

00:19:32.000 --> 00:19:42.000
Bạn có thể kiểm tra thuộc tính isReachable trên phiên Kết nối Đồng hồ để xác định xem ứng dụng đối tác của bạn có thể truy cập được cho tin nhắn trực tiếp, không phải nền hay không.

00:19:42.000 --> 00:19:46.000
Nhưng có nghĩa là có thể tiếp cận được là gì?

00:19:46.000 --> 00:19:54.000
Cả hai thiết bị cần nằm trong phạm vi của nhau thông qua Bluetooth hoặc trên cùng một mạng Wi-Fi.

00:19:54.000 --> 00:20:07.000
Để Tiện ích mở rộng WatchKit có thể truy cập được, nó phải chạy ở phía trước hoặc chạy ở chế độ nền với mức độ ưu tiên cao, như khi thực hiện các phiên nền dài.

00:20:07.000 --> 00:20:12.000
Ứng dụng iOS không có yêu cầu tiền cảnh này.

00:20:12.000 --> 00:20:23.000
Nếu bạn gửi tin nhắn từ ứng dụng Watch của mình đến ứng dụng iOS và ứng dụng iOS của bạn không ở phía trước, ứng dụng iOS của bạn sẽ được kích hoạt ở chế độ nền để nhận tin nhắn.

00:20:23.000 --> 00:20:31.000
Điều này có nghĩa là ứng dụng iOS của bạn có thể truy cập được từ Tiện ích mở rộng đồng hồ của bạn nhiều hơn so với ngược lại.

00:20:31.000 --> 00:20:43.000
Kết nối đồng hồ là một cách hay để cung cấp cho khách hàng của bạn trải nghiệm cảm thấy kịp thời, nhạy bén và trực quan khi họ đã cài đặt cả ứng dụng iPhone và Watch của bạn.

00:20:43.000 --> 00:20:53.000
Vì Watch Connectivity đặc biệt giao tiếp giữa điện thoại và Đồng hồ được ghép nối, đừng sử dụng nó để hỗ trợ các ứng dụng cho Thiết lập Gia đình.

00:20:53.000 --> 00:21:00.000
Truyền dữ liệu phụ thuộc vào tính khả dụng của thiết bị đồng hành qua Bluetooth hoặc Wi-Fi.

00:21:00.000 --> 00:21:05.000
Giao tiếp theo thời gian thực bằng cách sử dụng sendMessage yêu cầu đối tác phải có thể truy cập được.

00:21:05.000 --> 00:21:13.000
Hãy nhớ rằng ứng dụng đối tác của bạn sẽ không thể truy cập được nhiều lần, đặc biệt là khi bạn đang cố gắng giao tiếp với ứng dụng Đồng hồ của mình.

00:21:13.000 --> 00:21:16.000
Chuyển nền không được giao ngay lập tức.

00:21:16.000 --> 00:21:25.000
Hãy nghĩ về họ giống như đăng một lá thư: bạn bỏ nó vào hộp, nhưng bạn không chắc chắn chính xác khi nào nó sẽ ở đó.

00:21:25.000 --> 00:21:34.000
Để biết thêm thông tin về Kết nối Đồng hồ, hãy xem "Giới thiệu Kết nối Đồng hồ" trong ứng dụng Nhà phát triển hoặc trực tuyến.

00:21:34.000 --> 00:21:41.000
Bây giờ, chúng ta sẽ nói về một vài cách để giao tiếp trực tiếp với máy chủ.

00:21:41.000 --> 00:21:46.000
Đối với hầu hết các trường hợp sử dụng, lựa chọn tốt nhất là các phiên URL.

00:21:46.000 --> 00:21:54.000
Tùy thuộc vào sự tương tác và loại dữ liệu, bạn có thể trì hoãn giao tiếp hoặc có thể cần thực hiện ngay lập tức.

00:21:54.000 --> 00:22:02.000
Vì vậy, chúng tôi có các cấu hình khác nhau cho các phiên URL để cho phép chúng được chạy ở chế độ nền hoặc tiền cảnh.

00:22:02.000 --> 00:22:06.000
Hãy xem khi nào bạn nên sử dụng từng tùy chọn này.

00:22:06.000 --> 00:22:10.000
Bạn nên sử dụng các phiên nền bất cứ khi nào có thể.

00:22:10.000 --> 00:22:18.000
Đây có thể không phải là bản năng đầu tiên của chúng tôi với tư cách là nhà phát triển, nơi chúng tôi có thể muốn tiếp tục và lấy hoặc gửi dữ liệu ngay lập tức.

00:22:18.000 --> 00:22:21.000
Nhưng hãy thực sự nghĩ về nó.

00:22:21.000 --> 00:22:30.000
Các phiên tiền cảnh cần phải hoàn thành trong khi ứng dụng của bạn ở phía trước hoặc phía trước, và đối với tất cả trừ các tác vụ ngắn nhất, điều này không đủ thời gian.

00:22:30.000 --> 00:22:36.000
Hãy suy nghĩ về trải nghiệm của khách hàng nếu nhiệm vụ giao tiếp của họ thất bại.

00:22:36.000 --> 00:22:45.000
Vì vậy, hãy quan tâm đến khách hàng của bạn và đánh giá cẩn thận từng nhiệm vụ giao tiếp và hỏi, "Tôi có thể làm điều này trong nền không?"

00:22:45.000 --> 00:22:54.000
Các phiên URL nền là lựa chọn đúng đắn cho bất kỳ thời điểm giao tiếp nào có thể bị trì hoãn và để truyền dữ liệu lớn.

00:22:54.000 --> 00:23:02.000
Bạn cũng có thể gửi thông báo đẩy đến ứng dụng của mình để cho biết rằng dữ liệu mới có sẵn và bắt đầu cập nhật nền.

00:23:02.000 --> 00:23:08.000
Thời gian chính xác của việc chuyển nền của bạn sẽ phụ thuộc vào điều kiện hệ thống.

00:23:08.000 --> 00:23:12.000
Hãy xem qua một ví dụ về việc gửi một số dữ liệu đến máy chủ trong nền.

00:23:12.000 --> 00:23:28.000
Ví dụ: nếu tôi có một số cài đặt cho ứng dụng của mình mà tôi muốn lưu trữ thông qua máy chủ web của mình, khi khách hàng của tôi lưu chúng, tôi có thể lưu chúng trên Đồng hồ và sau đó gửi chúng đến máy chủ ở chế độ nền.

00:23:28.000 --> 00:23:36.000
Để làm điều đó, tôi đã tạo một lớp phiên URL nền để xử lý công việc của giao tiếp máy chủ.

00:23:36.000 --> 00:23:44.000
Phiên URL của chúng tôi sẽ có cấu hình nền với một mã định danh duy nhất mà chúng tôi có thể sử dụng để tìm nó sau.

00:23:44.000 --> 00:23:57.000
Đặt thuộc tính sự kiện khởi chạy gửi thành đúng để chỉ ra rằng phiên sẽ khởi chạy ứng dụng của bạn trong nền khi các tác vụ trong phiên của bạn cần được xử lý.

00:23:57.000 --> 00:24:14.000
Lưu ý rằng nếu bạn đang chuyển một lượng lớn dữ liệu, bạn nên đặt thuộc tính isDiscretionary của cấu hình phiên URL thành true để cho phép hệ thống lên lịch chuyển vào thời điểm tối ưu cho thiết bị để có hiệu suất tốt nhất.

00:24:14.000 --> 00:24:25.000
Trong trường hợp này, bạn cũng nên cho khách hàng của mình biết rằng việc tải xuống của họ có thể không xảy ra cho đến khi họ được kết nối với Wi-Fi và nguồn điện.

00:24:25.000 --> 00:24:32.000
Khi chúng tôi sẵn sàng gửi dữ liệu, chúng tôi cần xếp hàng chuyển để lên lịch cho phiên nền.

00:24:32.000 --> 00:24:41.000
Chúng tôi sẽ tạo và định cấu hình một yêu cầu URL với nội dung để cập nhật Cài đặt cho máy chủ của chúng tôi.

00:24:41.000 --> 00:24:45.000
Sau đó, chúng tôi sẽ tạo một nhiệm vụ cho yêu cầu của chúng tôi trong phiên.

00:24:45.000 --> 00:24:55.000
Trong ví dụ đơn giản này, tôi chỉ thêm một nhiệm vụ vào phiên của mình, nhưng bạn có thể thêm nhiều yêu cầu vào phiên của mình để đạt hiệu quả.

00:24:55.000 --> 00:24:59.000
Đặt Ngày bắt đầu sớm nhất để bắt đầu tải xuống sau.

00:24:59.000 --> 00:25:07.000
Lưu ý rằng hệ thống sẽ xác định thời gian thực tế mà nhiệm vụ của chúng tôi bắt đầu dựa trên ngân sách nền, mạng và điều kiện hệ thống.

00:25:07.000 --> 00:25:23.000
Ứng dụng của bạn có thể nhận được tối đa bốn tác vụ làm mới nền mỗi giờ, nếu bạn có biến chứng trên mặt đồng hồ đang hoạt động, vì vậy hãy lên lịch các tác vụ của bạn cách nhau ít nhất 15 phút để tránh chúng bị hệ thống trì hoãn.

00:25:23.000 --> 00:25:27.000
Tôi đang giữ phiên này trong danh sách các phiên đang tiến hành.

00:25:27.000 --> 00:25:34.000
Điều này sẽ trở nên quan trọng sau này, khi hệ thống cho tôi biết rằng yêu cầu URL của tôi đã hoàn tất.

00:25:34.000 --> 00:25:41.000
Gọi "tiếp tục" về nhiệm vụ thực sự bắt đầu nó, vì vậy điều quan trọng là bạn phải gọi nó là.

00:25:41.000 --> 00:25:48.000
Cuối cùng, tôi đặt trạng thái của mình thành xếp hàng trong trường hợp có người quan sát cho phiên.

00:25:48.000 --> 00:25:56.000
Hệ thống sẽ thông báo cho ứng dụng của chúng tôi khi yêu cầu nền của chúng tôi đã được xử lý bằng cách sử dụng tác vụ nền được gửi đến Đại diện Mở rộng của chúng tôi.

00:25:56.000 --> 00:26:09.000
Để chúng tôi xử lý nhiệm vụ đó, chúng tôi cần tạo một lớp phù hợp với đại diện mở rộng WK và triển khai hàm xử lý (_ backgroundTasks:).

00:26:09.000 --> 00:26:18.000
Đối với các tác vụ Làm mới Phiên URL Nền, chúng tôi sẽ cố gắng tìm phiên của mình trong danh sách các yêu cầu đang tiến hành của chúng tôi.

00:26:18.000 --> 00:26:31.000
Nếu chúng tôi có nó, chúng tôi sẽ gọi một hàm trên phiên để thêm nhiệm vụ làm mới nền vào danh sách cho phiên, vì vậy chúng tôi có thể cho hệ thống biết rằng chúng tôi đã hoàn thành nó ngay sau khi chúng tôi xử lý xong dữ liệu.

00:26:31.000 --> 00:26:34.000
Tôi sẽ cho bạn xem cái này trong giây lát.

00:26:34.000 --> 00:26:39.000
Nếu chúng tôi không tìm thấy phiên trong danh sách của mình, chúng tôi cần đánh dấu nhiệm vụ là đã hoàn thành.

00:26:39.000 --> 00:26:46.000
Điều rất quan trọng là bạn luôn đặt hoàn thành nhiệm vụ làm mới nền của mình ngay sau khi bạn hoàn thành.

00:26:46.000 --> 00:26:53.000
Có một điều nữa chúng ta cần làm để nhận được các cuộc gọi nhiệm vụ nền của mình: chúng ta cần kết nối đại diện tiện ích mở rộng với Ứng dụng của mình.

00:26:53.000 --> 00:27:03.000
Để làm điều này, chúng tôi sẽ sử dụng trình bao bọc thuộc tính bộ điều hợp đại diện mở rộng WK với lớp Đại diện mở rộng của chúng tôi và thêm một thuộc tính vào ứng dụng của chúng tôi.

00:27:03.000 --> 00:27:08.000
Bây giờ, hệ thống sẽ gọi đại diện mở rộng của chúng tôi để xử lý các nhiệm vụ nền tảng của chúng tôi.

00:27:08.000 --> 00:27:16.000
Trong đại diện mở rộng của chúng tôi, chúng tôi đã gọi hàm này để thêm nhiệm vụ nền của chúng tôi vào phiên hiện tại của chúng tôi.

00:27:16.000 --> 00:27:25.000
Thêm nhiệm vụ này vào danh sách các nhiệm vụ nền của chúng tôi để chúng tôi có thể đánh dấu nó đã hoàn thành ngay sau khi chúng tôi xử lý xong dữ liệu URL.

00:27:25.000 --> 00:27:34.000
Bây giờ, chúng tôi đã kết nối toàn bộ chuyến đi khứ hồi và tất cả những gì chúng tôi còn phải làm là lấy dữ liệu của mình và cho hệ thống biết rằng chúng tôi đã hoàn tất.

00:27:34.000 --> 00:27:40.000
Đại diện tải xuống phiên URL của chúng tôi sẽ được gọi khi yêu cầu của chúng tôi hoàn tất.

00:27:40.000 --> 00:27:43.000
Xử lý dữ liệu nhận được trong tệp từ tác vụ tải xuống.

00:27:43.000 --> 00:27:51.000
Điều quan trọng là bạn phải di chuyển mục này vào một thư mục có thể truy cập vào ứng dụng của mình hoặc nhanh chóng xử lý dữ liệu từ tệp.

00:27:51.000 --> 00:27:55.000
Khi nhiệm vụ này hoàn thành, tệp đã tải xuống sẽ bị xóa.

00:27:55.000 --> 00:28:09.000
Chúng tôi đang xóa phiên này khỏi danh sách các phiên đang trong quá trình, vì chúng tôi sẽ không nhận được thêm bất kỳ tác vụ nền nào cho nó từ đại diện tiện ích mở rộng và chúng tôi đang đặt trạng thái để hoàn thành trong trường hợp có bất kỳ người quan sát nào.

00:28:09.000 --> 00:28:13.000
Cuối cùng, chúng tôi đang hoàn thành nhiệm vụ nền tảng của mình.

00:28:13.000 --> 00:28:17.000
Điều này cho hệ thống biết rằng chúng tôi đã hoàn thành quá trình xử lý nền của mình.

00:28:17.000 --> 00:28:22.000
Đảm bảo rằng bạn làm điều này không chỉ là một công dân ứng dụng Watch tốt.

00:28:22.000 --> 00:28:27.000
Nó ngăn hệ thống chấm dứt ứng dụng của bạn vì vượt quá giới hạn nền của nó.

00:28:27.000 --> 00:28:29.000
Và thế là xong!

00:28:29.000 --> 00:28:33.000
Tất cả chúng ta đã hoàn thành việc gửi cài đặt của mình trong nền và nhận được bất kỳ cập nhật nào.

00:28:33.000 --> 00:28:40.000
Lưu ý rằng trong quá trình triển khai đầy đủ, bạn sẽ muốn xử lý các lỗi và thách thức xác thực, nhưng điều này cung cấp cho bạn các bước cơ bản.

00:28:40.000 --> 00:28:47.000
Sử dụng các phiên URL tiền cảnh để liên lạc nhanh với máy chủ trong khi một người đang tương tác với ứng dụng của bạn.

00:28:47.000 --> 00:28:54.000
Một ví dụ điển hình về điều này là nhận được danh sách tập luyện mới nhất hoặc thiền định trong ngày.

00:28:54.000 --> 00:29:02.000
Các phiên URL tiền cảnh là một cách ít tiết kiệm năng lượng hơn để lấy và gửi dữ liệu và thời gian chờ hai phút rưỡi được thực thi.

00:29:02.000 --> 00:29:10.000
Nhưng trong thực tế, bạn nên cố gắng nhắm mục tiêu các phiên tiền cảnh đến các tương tác nhanh hơn nhiều so với giới hạn đó.

00:29:10.000 --> 00:29:16.000
Các phiên URL là phương pháp tốt nhất để giao tiếp với mục đích chung trực tiếp với máy chủ.

00:29:16.000 --> 00:29:23.000
Họ không dựa vào ứng dụng iPhone đồng hành và bạn có thể sử dụng chúng với các ứng dụng hỗ trợ Thiết lập gia đình.

00:29:23.000 --> 00:29:33.000
Sử dụng các phiên nền cho bất cứ nơi nào bạn có thể trì hoãn việc truyền dữ liệu và luôn để chuyển lượng dữ liệu lớn hơn.

00:29:33.000 --> 00:29:45.000
Để tìm hiểu thêm về các phiên URL, hãy xem "Cập nhật các biến chứng của bạn" và "Thực thi nền được làm sáng tỏ" trong ứng dụng Nhà phát triển hoặc trực tuyến.

00:29:45.000 --> 00:29:55.000
Ngoài các phiên URL, nếu bạn đang xây dựng một ứng dụng âm thanh phát trực tuyến, ổ cắm là một lựa chọn khác để giao tiếp trực tiếp với máy chủ.

00:29:55.000 --> 00:30:03.000
Bạn có thể sử dụng HTTP Live Streaming hoặc Web Sockets trong các ứng dụng Watch trong bối cảnh phiên âm thanh phát trực tuyến đang hoạt động của bạn.

00:30:03.000 --> 00:30:14.000
Để biết thêm thông tin về việc sử dụng Sockets, hãy xem phiên "Phát trực tuyến âm thanh trên watchOS 6" trong ứng dụng dành cho nhà phát triển hoặc trực tuyến.

00:30:14.000 --> 00:30:21.000
Chúng tôi đã đề cập rất nhiều, vì vậy hãy tóm tắt cách chúng tôi có thể chọn trong số tất cả các tùy chọn mà chúng tôi đã thấy.

00:30:21.000 --> 00:30:31.000
Đối với các phần nhỏ dữ liệu nhạy cảm có thể được đồng bộ hóa với tất cả các thiết bị của một người, hãy chọn Chuỗi khóa có Đồng bộ hóa iCloud.

00:30:31.000 --> 00:30:39.000
Để lưu trữ cơ sở dữ liệu trong iCloud và chia sẻ với tất cả các thiết bị của một người, hãy chọn Dữ liệu cốt lõi với CloudKit.

00:30:39.000 --> 00:30:50.000
Để tối ưu hóa trải nghiệm cho các ứng dụng iPhone và Watch đồng hành hoặc để chia sẻ dữ liệu chỉ khả dụng trên một thiết bị trong các ứng dụng đồng hành, hãy chọn Kết nối đồng hồ.

00:30:50.000 --> 00:30:55.000
Để giao tiếp trực tiếp với máy chủ, hãy chọn phiên URL.

00:30:55.000 --> 00:30:59.000
Để phát trực tuyến các ứng dụng âm thanh, bạn cũng có thể sử dụng ổ cắm.

00:30:59.000 --> 00:31:15.000
Để hỗ trợ những khách hàng đang sử dụng Thiết lập Gia đình hoặc sử dụng truyền dữ liệu di động, hãy đảm bảo bạn chọn Chuỗi khóa có Đồng bộ hóa iCloud, Dữ liệu cốt lõi với CloudKit, phiên URL hoặc ổ cắm.

00:31:15.000 --> 00:31:25.000
Hãy suy nghĩ về loại dữ liệu, nguồn và điểm đến của nó, và đối tượng khách hàng của bạn trước khi chọn giải pháp để giúp bạn chọn công cụ phù hợp cho công việc.

00:31:25.000 --> 00:31:35.000
Và luôn kiểm tra ứng dụng của bạn trên các thiết bị, không được kết nối với trình gỡ lỗi, trước khi bạn triển khai nó để xác minh hành vi của nó trong điều kiện thực tế.

00:31:35.000 --> 00:31:42.000
Cảm ơn bạn đã đến để tìm hiểu về tất cả các công cụ tuyệt vời mà chúng tôi có để truyền dữ liệu trong ứng dụng Đồng hồ của bạn.

00:31:42.000 --> 00:31:45.000
Chúng tôi nóng lòng muốn xem bạn xây dựng gì tiếp theo.

00:31:45.000 --> 23:59:59.000
[Âm nhạc].

