WEBVTT

00:00:00.000 --> 00:00:05.000
♪ Nhạc bass đang phát ♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:12.000
Stuart Cheshire: Chào mừng đến với "Giảm sự chậm trễ mạng cho ứng dụng của bạn".

00:00:12.000 --> 00:00:15.000
Tên tôi là Stuart Cheshire.

00:00:15.000 --> 00:00:28.000
Tôi sẽ nói về các yếu tố góp phần làm cho các ứng dụng mạng cảm thấy chậm ngày hôm nay và sau đó tôi sẽ bàn giao cho đồng nghiệp Vidhi Goel của tôi để cho bạn biết về các kỹ thuật và API bạn có thể sử dụng để làm cho ứng dụng mạng của bạn phản hồi nhanh hơn.

00:00:28.000 --> 00:00:36.000
Hãy bắt đầu bằng cách nói về điều gì đó mà bạn có thể đã thấy trong bản beta WWDC của iOS.

00:00:36.000 --> 00:00:42.000
Nếu bạn nhìn vào cài đặt Nhà phát triển, bạn sẽ thấy một mục mới trong phần Mạng được gọi là Khả năng phản hồi.

00:00:42.000 --> 00:00:56.000
Mặc dù thông lượng tải lên, thông lượng tải xuống và thời gian ping nhàn rỗi đều thú vị, nhưng yếu tố chính ảnh hưởng đến khả năng phản hồi của ứng dụng mạng của bạn là khả năng phản hồi của mạng trong điều kiện làm việc, không phải điều kiện nhàn rỗi.

00:00:56.000 --> 00:01:03.000
Phép đo thời gian ping nhàn rỗi kiểm tra tốc độ internet điển hình cho bạn biết kết nối internet của bạn hoạt động tốt như thế nào khi bạn không sử dụng nó.

00:01:03.000 --> 00:01:08.000
Điều quan trọng là kết nối internet của bạn hoạt động tốt như thế nào khi bạn đang sử dụng nó.

00:01:08.000 --> 00:01:10.000
Nhấn vào Kiểm tra.

00:01:10.000 --> 00:01:22.000
Nó sẽ cảnh báo bạn rằng nó sẽ tạo ra lưu lượng mạng, nó sẽ đo lường mạng của bạn trong vài giây, và sau đó nó sẽ cho bạn biết mạng của bạn đang hoạt động tốt như thế nào trong điều kiện làm việc.

00:01:22.000 --> 00:01:29.000
Công cụ báo cáo khả năng phản hồi của mạng trong các chuyến đi khứ hồi mỗi phút, hoặc RPM, thay vì mili giây.

00:01:29.000 --> 00:01:36.000
Chúng tôi đã tạo ra số liệu RPM mới này vì mili giây là một khái niệm khá trừu tượng đối với nhiều người.

00:01:36.000 --> 00:01:40.000
Mọi người cũng quen thuộc hơn với các số liệu trong đó cao hơn là tốt hơn.

00:01:40.000 --> 00:01:49.000
Chỉ số RPM tạo ra các con số trong phạm vi từ vài trăm RPM đến vài nghìn RPM, giống như RPM của động cơ ô tô của bạn.

00:01:49.000 --> 00:01:55.000
Ngoài ra còn có một phiên bản dòng lệnh của công cụ kiểm tra này trên macOS được gọi là NetworkQuality.

00:01:55.000 --> 00:02:00.000
Bạn có thể nghĩ rằng mạng gia đình hoặc nơi làm việc của bạn có thời gian ping tuyệt vời, nhưng đó là khi nó không hoạt động.

00:02:00.000 --> 00:02:10.000
Chạy bài kiểm tra chất lượng mạng này cho chính bạn - trên iPhone hoặc Mac của bạn - và bạn có thể thấy rằng khi mạng của bạn đang được sử dụng, khả năng phản hồi của nó trở nên tồi tệ hơn rất nhiều.

00:02:10.000 --> 00:02:13.000
Và ý tôi là tệ hơn rất nhiều.

00:02:13.000 --> 00:02:24.000
Mạng của bạn có thể có thời gian khứ hồi nhàn rỗi là 20 mili giây, nghe có vẻ khá tốt, nhưng bạn có thể thấy rằng trong điều kiện làm việc, thời gian khứ hồi lên tới 600 mili giây trở lên.

00:02:24.000 --> 00:02:26.000
Điều đó tệ hơn gấp 30 lần.

00:02:26.000 --> 00:02:33.000
Khả năng phản hồi của mạng trong điều kiện làm việc là điều quan trọng đối với trải nghiệm người dùng ứng dụng của bạn.

00:02:33.000 --> 00:02:41.000
Tất cả chúng ta đều thấy vấn đề này mọi lúc, nhưng đặc biệt là với việc đóng băng âm thanh và video, và bỏ học trong hội nghị truyền hình.

00:02:41.000 --> 00:02:49.000
Độ trễ mạng cao làm tổn thương tất cả các ứng dụng, nhưng chúng tôi đã quen với điều đó, vì vậy chúng tôi nhận thấy nó nhiều hơn khi nó ảnh hưởng đến hội nghị truyền hình.

00:02:49.000 --> 00:02:56.000
Khi chúng tôi gặp vấn đề với hội nghị truyền hình, chúng tôi nghĩ rằng chúng tôi sẽ khắc phục nó bằng cách nâng cấp kết nối internet của mình.

00:02:56.000 --> 00:03:02.000
Mọi người đã chuyển từ một vài megabit mỗi giây sang gigabit trở lên, nhưng các vấn đề vẫn xảy ra.

00:03:02.000 --> 00:03:09.000
Một vài megabit mỗi giây sẽ rất nhiều cho hội nghị truyền hình, vậy tại sao chúng ta vẫn gặp phải những vấn đề này?

00:03:09.000 --> 00:03:18.000
Khi bộ đệm trong mạng quá lớn, khi chúng lấp đầy, chúng không cải thiện thông lượng, nhưng chúng làm tăng thêm độ trễ.

00:03:18.000 --> 00:03:25.000
Chúng ta thường nghĩ về internet hoạt động như thế này, với các gói tin chảy nhanh qua mạng.

00:03:25.000 --> 00:03:31.000
Nhưng nếu chúng ta nhìn vào bên trong đám mây, chúng ta sẽ thấy rằng nó thực sự hoạt động giống như thế này.

00:03:31.000 --> 00:03:36.000
Gói bạn thấy ra khỏi mạng không phải là gói mà bạn thấy đi vào.

00:03:36.000 --> 00:03:40.000
Các gói dành nhiều thời gian ngồi trong các bộ đệm quá lớn trong mạng.

00:03:40.000 --> 00:03:51.000
Hiện tượng bộ đệm quá lớn này được gọi là bộ đệm phình to, và cho đến nay nó vẫn chưa được đo lường rộng rãi, bất chấp ảnh hưởng của nó đối với việc sử dụng mạng hàng ngày.

00:03:51.000 --> 00:04:01.000
Tin tốt là có các thuật toán quản lý hàng đợi hiện đại, như CoDel - thuật toán xếp hàng trễ có kiểm soát - loại bỏ sự phình to bộ đệm.

00:04:01.000 --> 00:04:07.000
Khi mạng giữ hàng đợi ngắn, thời gian một gói dành cho việc chờ đợi trong mạng sẽ giảm đáng kể.

00:04:07.000 --> 00:04:12.000
Có thể có được thông lượng cao và độ trễ thấp cùng một lúc.

00:04:12.000 --> 00:04:16.000
Nó không phải là một trong hai/hoặc sự lựa chọn. Nó không phải là một trò chơi có tổng bằng không.

00:04:16.000 --> 00:04:23.000
Chúng tôi đang làm việc với ngành để triển khai các thuật toán quản lý hàng đợi thông minh hơn và cải thiện khả năng phản hồi mạng trong điều kiện làm việc.

00:04:23.000 --> 00:04:31.000
Nhưng hiện tại, nếu bạn muốn mang lại trải nghiệm người dùng tuyệt vời, bạn sẽ muốn làm cho các ứng dụng của mình đối phó với internet như ngày nay.

00:04:31.000 --> 00:04:39.000
Bufferbloat là một thành phần lớn của sự chậm trễ mạng mà ứng dụng của bạn sẽ gặp phải, nhưng nó không phải là nguồn trì hoãn duy nhất.

00:04:39.000 --> 00:04:42.000
Có thời gian xử lý phần mềm và phần cứng.

00:04:42.000 --> 00:04:47.000
Khi CPU nhanh hơn bao giờ hết, thời gian xử lý này tiếp tục thu hẹp.

00:04:47.000 --> 00:04:49.000
Có thời gian truyền dữ liệu thực tế.

00:04:49.000 --> 00:04:57.000
Khi tốc độ dữ liệu tăng từ kilobit lên megabit lên gigabit mỗi giây, thời gian truyền tiếp tục giảm.

00:04:57.000 --> 00:05:00.000
Sau đó là sự chậm trễ thời gian do bộ đệm trong mạng.

00:05:00.000 --> 00:05:04.000
Như tôi đã nói, chúng tôi đang làm việc với ngành công nghiệp để giảm bớt sự chậm trễ này.

00:05:04.000 --> 00:05:08.000
Nhưng sẽ luôn có độ trễ lan truyền tín hiệu tốc độ ánh sáng.

00:05:08.000 --> 00:05:18.000
Trở lại những năm 1990, thời gian ping Stanford-to-MIT, khứ hồi, từ bờ biển đến bờ biển, trên khắp Hoa Kỳ, đã dưới 100 mili giây.

00:05:18.000 --> 00:05:24.000
Điều đó đã khá gần với giới hạn tốc độ ánh sáng rồi, vì vậy nó sẽ không khá hơn nhiều.

00:05:24.000 --> 00:05:36.000
Chúng tôi đang làm việc để giảm ba độ trễ còn lại, nhưng độ trễ tốc độ ánh sáng sẽ không bao giờ biến mất, vì vậy đây là lý do tại sao điều quan trọng là phải thiết kế các ứng dụng của bạn có tính đến thời gian khứ hồi của mạng.

00:05:36.000 --> 00:05:42.000
Khi chúng ta nói về việc tính đến thời gian khứ hồi trên mạng, chúng ta đang nói về loại ứng dụng nào?

00:05:42.000 --> 00:05:48.000
Mọi người đều biết rằng hội nghị truyền hình bị ảnh hưởng nghiêm trọng bởi sự chậm trễ mạng cao.

00:05:48.000 --> 00:05:53.000
Mọi người đều biết rằng các trò chơi trực tuyến bị ảnh hưởng nghiêm trọng bởi độ trễ mạng cao.

00:05:53.000 --> 00:05:56.000
Nhưng điều này ảnh hưởng đến tất cả các ứng dụng sử dụng mạng.

00:05:56.000 --> 00:06:00.000
Tôi đang nói về việc nhận dự báo thời tiết, báo giá cổ phiếu, chỉ đường lái xe.

00:06:00.000 --> 00:06:02.000
Điều này ảnh hưởng đến việc duyệt web.

00:06:02.000 --> 00:06:05.000
Nó ảnh hưởng đến việc bỏ qua phía trước trong khi xem video phát trực tuyến.

00:06:05.000 --> 00:06:11.000
Hãy suy nghĩ về việc có bao nhiêu ứng dụng bao gồm một số chỉ báo độ trễ quay hoạt hình trong khi ứng dụng đang chờ mạng.

00:06:11.000 --> 00:06:13.000
Có thể là ứng dụng của bạn.

00:06:13.000 --> 00:06:18.000
Chúng tôi chỉ ra rằng chỉ báo "vui lòng đợi" để người dùng không nghĩ rằng ứng dụng đã bị treo.

00:06:18.000 --> 00:06:28.000
Thật tuyệt khi chúng tôi đã nỗ lực rất nhiều để cung cấp cho người dùng thứ gì đó để xem xét trong khi họ chờ đợi mạng chậm, nhưng chúng tôi cũng nên nỗ lực như nhau để giảm thời gian họ chờ đợi.

00:06:28.000 --> 00:06:37.000
Nếu bạn có một ứng dụng mà bạn đã từng hiển thị chỉ báo độ trễ trong khi chờ dữ liệu từ mạng, có những kỹ thuật bạn có thể sử dụng để giảm thời gian chờ đợi đó.

00:06:37.000 --> 00:06:48.000
Thời gian một ứng dụng chờ dữ liệu mạng là một hàm của việc mất bao lâu cho một chuyến đi khứ hồi mạng và số chuyến đi khứ hồi mạng mà ứng dụng của bạn yêu cầu.

00:06:48.000 --> 00:06:58.000
Là một nhà phát triển ứng dụng, bạn không thể làm gì nhiều để cải thiện thời gian khứ hồi mạng cơ bản, nhưng bạn có thể kiểm soát số lần khứ hồi mà ứng dụng của bạn yêu cầu.

00:06:58.000 --> 00:07:04.000
Hãy để tôi giới thiệu đồng nghiệp của tôi, Vidhi Goel, để cho bạn biết cách bạn có thể làm điều đó.

00:07:04.000 --> 00:07:06.000
Vidhi Goel: Cảm ơn, Stuart.

00:07:06.000 --> 00:07:16.000
Xin chào, tôi là Vidhi, và hôm nay tôi muốn nói chuyện với bạn về những gì bạn có thể làm với tư cách là một nhà phát triển để giảm sự chậm trễ của mạng trong ứng dụng của bạn.

00:07:16.000 --> 00:07:22.000
Khả năng phản hồi của ứng dụng tỷ lệ nghịch với số lượng chuyến đi khứ hồi trên mạng.

00:07:22.000 --> 00:07:32.000
Hãy để tôi chỉ cho bạn cách bạn có thể giảm các chuyến đi khứ hồi mạng này bằng cách áp dụng các giao thức mạng hiện đại và làm cho các ứng dụng của bạn trở nên siêu linh hoạt.

00:07:32.000 --> 00:07:47.000
Để tăng tốc các ứng dụng của bạn, hãy áp dụng các giao thức mạng hiện đại như HTTP/3 &amp; QUIC, TCP Fast Open, TLS 1.3 và Multipath TCP.

00:07:47.000 --> 00:07:56.000
Với những kỹ thuật này, ứng dụng của bạn có khả năng đạt được nhiều mức giảm khứ hồi trong việc cung cấp dữ liệu cho người dùng của bạn.

00:07:56.000 --> 00:08:05.000
Hỗ trợ phía máy chủ là cần thiết cho tất cả các giao thức hiện đại này, vì vậy hãy kiểm tra với nhà cung cấp của bạn về sự sẵn sàng của chúng.

00:08:05.000 --> 00:08:12.000
Chúng tôi rất vui khi nói với bạn rằng tất cả các công nghệ này đều có sẵn trên iOS và macOS.

00:08:12.000 --> 00:08:15.000
Hãy xem xét từng công nghệ này.

00:08:15.000 --> 00:08:25.000
Đầu tiên, chúng tôi có HTTP/3 và QUIC được bật theo mặc định trong iOS 15 và macOS Monterey.

00:08:25.000 --> 00:08:32.000
QUIC là một giao thức vận chuyển có thể thiết lập kết nối nhanh hơn nhiều so với TCP và TLS.

00:08:32.000 --> 00:08:41.000
Bằng cách giảm chặn đầu dòng, QUIC có thể giảm đáng kể sự chậm trễ trong việc cung cấp dữ liệu cho người dùng của bạn.

00:08:41.000 --> 00:08:47.000
Và đây là phần hay nhất: nếu bạn đã sử dụng URLSession, bạn đã sẵn sàng.

00:08:47.000 --> 00:09:04.000
Nếu bạn cung cấp lớp ứng dụng của riêng mình bằng cách sử dụng API khung mạng và muốn tận dụng QUIC, chỉ cần tạo một NWConnection với các tham số QUIC và đặt giao thức Lớp ứng dụng TLS hoặc ALPN.

00:09:04.000 --> 00:09:14.000
Vui lòng xem phiên "Tăng tốc mạng với HTTP/3 và QUIC" để tìm hiểu thêm về cách sử dụng các công nghệ này trong ứng dụng của bạn.

00:09:14.000 --> 00:09:17.000
QUIC hữu ích trong nhiều tình huống.

00:09:17.000 --> 00:09:24.000
Tuy nhiên, TCP vẫn có thể là lựa chọn đúng đắn cho một số ứng dụng.

00:09:24.000 --> 00:09:35.000
Khi sử dụng TCP, bạn có thể loại bỏ toàn bộ chuyến đi khứ hồi bằng cách gửi dữ liệu ứng dụng cùng với cái bắt tay TCP.

00:09:35.000 --> 00:09:41.000
TCP Fast Open được hỗ trợ trong khung mạng và ổ cắm.

00:09:41.000 --> 00:09:58.000
Để sử dụng nó với NWConnections, có hai tùy chọn: tùy chọn đầu tiên là cho phép Mở nhanh trên kết nối của bạn và trong trường hợp này, ứng dụng sẽ cung cấp dữ liệu ban đầu được gửi đi cùng với cái bắt tay.

00:09:58.000 --> 00:10:06.000
Để kích hoạt điều này, hãy đặt tham số allowFastOpen thành true và tạo kết nối của bạn.

00:10:06.000 --> 00:10:14.000
Và sau đó, trước khi bắt đầu cuộc gọi, bạn sẽ gọi gửi cùng với dữ liệu ban đầu của mình.

00:10:14.000 --> 00:10:24.000
Khi sử dụng TCP Fast Open, bạn phải cẩn thận rằng bạn chỉ gửi các yêu cầu idempotent bằng cái bắt tay.

00:10:24.000 --> 00:10:30.000
Idempotent về cơ bản có nghĩa là dữ liệu an toàn để được phát lại qua mạng.

00:10:30.000 --> 00:10:40.000
Có một cách khác để sử dụng TCP Fast Open mà không yêu cầu ứng dụng của bạn gửi dữ liệu ban đầu của riêng nó.

00:10:40.000 --> 00:10:49.000
Nếu ứng dụng của bạn đang sử dụng TLS qua TCP, bạn có thể chọn gửi tin nhắn bắt tay TLS làm dữ liệu ban đầu.

00:10:49.000 --> 00:10:58.000
Để kích hoạt điều này, hãy chuyển đến các tùy chọn TCP cụ thể của bạn và đặt enableFastOpen thành true.

00:10:58.000 --> 00:11:17.000
Cách được đề xuất để sử dụng TCP Fast Open là thông qua API khung mạng, nhưng nếu ứng dụng của bạn được xây dựng trên Sockets, thì bạn sẽ gọi connectx API với các cờ tương ứng để chỉ định rằng bạn muốn gửi dữ liệu idempotent bằng cái bắt tay.

00:11:17.000 --> 00:11:21.000
Tôi đã đề cập đến idempotent một vài lần.

00:11:21.000 --> 00:11:29.000
Hãy để tôi giải thích ý nghĩa của nó và tại sao điều quan trọng là chỉ gửi yêu cầu idempotent với cái bắt tay.

00:11:29.000 --> 00:11:39.000
Hoạt động idempotent và phát lại an toàn là hoạt động không có tác dụng bổ sung nếu nó được thực hiện nhiều lần.

00:11:39.000 --> 00:11:52.000
Ví dụ, khi người dùng truy cập trang web developer.apple.com, yêu cầu HTTP GET cho trang web này được gửi đi cùng với cái bắt tay TCP.

00:11:52.000 --> 00:12:06.000
Nếu xác nhận cho yêu cầu này bị trì hoãn hoặc bị rớt trong mạng, thiết bị sẽ gửi lại yêu cầu HTTP GET có thể được định tuyến đến một máy chủ khác.

00:12:06.000 --> 00:12:12.000
Và lần này sự thừa nhận đến cùng với phản hồi HTTP.

00:12:12.000 --> 00:12:23.000
Vì yêu cầu HTTP GET không có bất kỳ tác dụng bổ sung nào khi nó được gửi lại qua mạng, nó được coi là một yêu cầu idempotent.

00:12:23.000 --> 00:12:29.000
Bây giờ, giả sử người dùng đang cố gắng mua một chiếc iPhone 12 mới.

00:12:29.000 --> 00:12:36.000
Yêu cầu HTTP được gửi cho hoạt động này không phải là yêu cầu idempotent.

00:12:36.000 --> 00:12:46.000
Nó có thể dẫn đến nhiều giao dịch nếu yêu cầu đi đến một máy chủ khác nhau mỗi khi dữ liệu được phát lại qua mạng.

00:12:46.000 --> 00:12:51.000
Hãy ghi nhớ điều đó, hãy nói về TLS 1.3.

00:12:51.000 --> 00:12:59.000
TLS 1.3 loại bỏ toàn bộ chuyến đi khứ hồi khỏi cái bắt tay so với TLS 1.2.

00:12:59.000 --> 00:13:03.000
Nó cũng cung cấp bảo mật mạnh mẽ hơn.

00:13:03.000 --> 00:13:11.000
Nó được bật theo mặc định kể từ iOS 13.4 cho URLSession và NWConnection.

00:13:11.000 --> 00:13:23.000
Giao thức TLS 1.3 xác định hỗ trợ dữ liệu sớm, có thể tiết kiệm thêm một chuyến đi khứ hồi khác bằng cách gửi các yêu cầu idempotent cùng với tin nhắn bắt tay TLS.

00:13:23.000 --> 00:13:31.000
Hãy chuyển đổi bánh răng và xem xét Multipath TCP hoạt động hơi khác một chút trong việc giảm sự chậm trễ của mạng.

00:13:31.000 --> 00:13:40.000
TCP đa đường cho phép một kết nối TCP duy nhất tiếp tục khi thiết bị chuyển từ mạng này sang mạng khác.

00:13:40.000 --> 00:13:48.000
Để có được tính năng độ trễ thấp của Multipath TCP, hãy sử dụng API chế độ tương tác.

00:13:48.000 --> 00:13:59.000
Nó sẽ lưu tất cả các chuyến đi khứ hồi cần thiết để thiết lập một kết nối mới và hệ thống sẽ tự động chọn đường dẫn mạng nhanh hơn cho các gói dữ liệu của bạn.

00:13:59.000 --> 00:14:11.000
Để chọn tham gia từ máy khách, hãy đặt thuộc tính multipathServiceType thành tương tác trên cấu hình URLSession hoặc trên NWParameters của bạn.

00:14:11.000 --> 00:14:20.000
Để cung cấp cho bạn ý tưởng về số lượng chuyến đi khứ hồi bạn có thể tiết kiệm với những công nghệ hiện đại này, hãy bắt đầu với một điểm tham chiếu.

00:14:20.000 --> 00:14:25.000
Giả sử ứng dụng của bạn hiện đang chạy TLS 1.2 qua TCP.

00:14:25.000 --> 00:14:32.000
Trong trường hợp này, sẽ mất bốn chuyến đi khứ hồi để có được byte đầu tiên cho người dùng của bạn.

00:14:32.000 --> 00:14:41.000
Nếu máy chủ của bạn chuyển từ TLS 1.2 sang TLS 1.3, các kết nối của bạn sẽ loại bỏ toàn bộ chuyến đi khứ hồi.

00:14:41.000 --> 00:14:49.000
Nếu bạn bật TCP Fast Open trên kết nối của mình, bạn sẽ lưu thêm một chuyến khứ hồi khác.

00:14:49.000 --> 00:14:57.000
Trong iOS 15, HTTP/3 qua QUIC cung cấp giảm xuống còn hai chuyến đi khứ hồi.

00:14:57.000 --> 00:15:07.000
Giao thức QUIC cũng xác định hỗ trợ dữ liệu sớm, điều này có thể cho phép giảm thêm một chuyến khứ hồi.

00:15:07.000 --> 00:15:18.000
Dựa trên các phép đo của chúng tôi tại Apple, người dùng thường thấy thời gian khứ hồi đôi khi tăng vọt lên tới 600 mili giây.

00:15:18.000 --> 00:15:21.000
Hãy xem điều đó có ý nghĩa gì đối với ứng dụng của bạn.

00:15:21.000 --> 00:15:30.000
Bốn chuyến đi khứ hồi ở 600 mili giây có nghĩa là người dùng của bạn đang đợi gần hai giây rưỡi để dữ liệu đến nơi.

00:15:30.000 --> 00:15:36.000
Đó là một khoảng thời gian rất lớn để chờ đợi và nhìn chằm chằm vào con quay mạng.

00:15:36.000 --> 00:15:47.000
Bằng cách áp dụng các giao thức mạng hiện đại, bạn có thể giảm thời gian đó xuống byte đầu tiên từ 2,4 giây xuống còn khoảng nửa giây.

00:15:47.000 --> 00:15:55.000
Người dùng chắc chắn sẽ nhận thấy sự khác biệt khi dữ liệu đến sớm hơn cả giây rưỡi.

00:15:55.000 --> 00:16:02.000
Mọi nhà phát triển muốn có hiệu suất mạng tuyệt vời nên chú ý đến số lượng chuyến đi khứ hồi.

00:16:02.000 --> 00:16:06.000
Đây là nơi có những chiến thắng lớn.

00:16:06.000 --> 00:16:14.000
Tất cả các công nghệ mà tôi đã nói đến giúp giảm sự chậm trễ mạng trong ứng dụng của bạn trong điều kiện mạng trong thế giới thực.

00:16:14.000 --> 00:16:23.000
Nếu bạn kiểm tra ứng dụng của mình trên mạng 5G, LTE hoặc Wi-Fi nhanh, khả năng phản hồi ứng dụng của bạn có vẻ phù hợp với bạn.

00:16:23.000 --> 00:16:29.000
Nhưng người dùng của bạn không phải lúc nào cũng sử dụng ứng dụng của bạn trong điều kiện mạng tốt nhất.

00:16:29.000 --> 00:16:38.000
Để mô phỏng các mạng thực tế, công cụ Điều hòa Liên kết Mạng có sẵn cho iOS từ menu cài đặt Nhà phát triển.

00:16:38.000 --> 00:16:43.000
Đối với macOS, bạn có thể tải xuống từ trang web Nhà phát triển Apple.

00:16:43.000 --> 00:16:53.000
Công cụ này là một cách đáng tin cậy và có thể lặp lại để kiểm tra ứng dụng của bạn trong các điều kiện mạng khác nhau mà người dùng của bạn có thể gặp phải trong cuộc sống hàng ngày của họ.

00:16:53.000 --> 00:17:02.000
Nếu bạn nhớ lại, Stuart đã đề cập trước đó rằng bạn không thể làm gì nhiều về việc giảm thời gian khứ hồi trên mạng của mình.

00:17:02.000 --> 00:17:05.000
Chà, điều đó không hoàn toàn đúng.

00:17:05.000 --> 00:17:15.000
Hãy để tôi giải thích cách bạn có thể giảm thời gian khứ hồi của mạng khi bạn thông báo chính xác cho hệ thống về lưu lượng truy cập ứng dụng của mình.

00:17:15.000 --> 00:17:20.000
Hầu hết các ứng dụng đều có sự kết hợp của lưu lượng truy cập mà chúng gửi hoặc nhận.

00:17:20.000 --> 00:17:27.000
Có rất nhiều dữ liệu được trao đổi từ thiết bị của người dùng khi chạy một loạt các ứng dụng.

00:17:27.000 --> 00:17:35.000
Trong các mạng trong thế giới thực, như Wi-Fi gia đình hoặc văn phòng, một số thiết bị chia sẻ cùng một mạng.

00:17:35.000 --> 00:17:43.000
Các thiết bị này đồng thời gửi và nhận một lượng dữ liệu đáng kể trong khi sử dụng một bộ ứng dụng.

00:17:43.000 --> 00:17:59.000
Để tránh xây dựng hàng đợi dài trong mạng chia sẻ này, điều quan trọng là bạn phải phân loại dữ liệu ứng dụng của mình một cách thích hợp để hệ thống có thể quản lý lưu lượng truy cập của bạn một cách hiệu quả nhằm duy trì độ trễ mạng thấp.

00:17:59.000 --> 00:18:12.000
Và khi bạn cho phép hệ thống duy trì độ trễ mạng thấp, nó sẽ làm cho lưu lượng truy cập tiền cảnh của ứng dụng của bạn nhanh hơn và do đó dữ liệu quan trọng nhất đối với người dùng được phân phối nhanh chóng.

00:18:12.000 --> 00:18:16.000
Hãy để tôi minh họa điều này bằng một ví dụ.

00:18:16.000 --> 00:18:24.000
Nhiều ứng dụng tìm nạp trước nội dung như đồ họa, tệp âm thanh, v.v., để có sẵn để sử dụng sau này.

00:18:24.000 --> 00:18:32.000
Khi ứng dụng đang tìm nạp trước một lượng dữ liệu đáng kể, đây là mạng có thể trông như thế nào.

00:18:32.000 --> 00:18:36.000
Hàng đợi nút cổ chai có thể trở nên đầy.

00:18:36.000 --> 00:18:52.000
Nếu tại thời điểm này, người dùng bắt đầu một hoạt động mạng - như xem trang hồ sơ của họ - phản hồi cho yêu cầu này sẽ được xếp hàng ở cuối hàng đợi mạng và có thể mất vài giây trước khi hồ sơ được hiển thị.

00:18:52.000 --> 00:18:56.000
Đây sẽ không phải là một trải nghiệm người dùng tốt.

00:18:56.000 --> 00:19:06.000
Bây giờ, hãy xem điều gì xảy ra với mạng khi chúng tôi đánh dấu các tác vụ tìm nạp trước không phải người dùng này làm nền.

00:19:06.000 --> 00:19:19.000
Đánh dấu những chuyển giao không phải do người dùng bắt đầu này làm nền sẽ làm giảm đáng kể kích thước của hàng đợi mạng, sau đó sẽ có sẵn cho các dữ liệu tiền cảnh khác.

00:19:19.000 --> 00:19:29.000
Do đó, bất kỳ dữ liệu tiền cảnh nào - tức là các gói màu xanh lá cây - sẽ được gửi ngay lập tức để có trải nghiệm nhanh chóng, thú vị.

00:19:29.000 --> 00:19:37.000
Trong iOS 15 và macOS Monterey, loại dịch vụ nền đã được cải thiện đáng kể.

00:19:37.000 --> 00:19:44.000
Chúng tôi đã thêm các thuật toán kiểm soát tắc nghẽn mới để tải lên và tải xuống nền.

00:19:44.000 --> 00:19:59.000
Các thuật toán mới này không chỉ làm giảm đáng kể độ trễ mạng, để có trải nghiệm người dùng tốt hơn mà còn đảm bảo rằng việc chuyển nền kết thúc gần như cùng lúc với các lưu lượng truy cập khác.

00:19:59.000 --> 00:20:07.000
Hãy xem xét các API mạng mà bạn có thể áp dụng để tận dụng loại dịch vụ nền.

00:20:07.000 --> 00:20:22.000
Khi ứng dụng của bạn ở phía trước và thực hiện chuyển khoản không do người dùng khởi tạo, bạn sẽ sử dụng URLSession mặc định và đặt loại dịch vụ mạng thành nền trên các yêu cầu URL của mình.

00:20:22.000 --> 00:20:28.000
Một lần nữa, điều này cho phép hệ thống duy trì độ trễ mạng thấp.

00:20:28.000 --> 00:20:37.000
Và đối với NWConnection, bạn sẽ đặt lớp dịch vụ thành nền trên NWParameters của mình.

00:20:37.000 --> 00:20:51.000
Nếu ứng dụng của bạn bắt đầu chuyển giao lâu dài, cho dù đó có phải là người dùng khởi tạo hay không, bạn sẽ tạo một URLSession nền để tiếp tục chạy ngay cả khi ứng dụng của bạn bị tạm ngưng.

00:20:51.000 --> 00:20:57.000
Đối với các tác vụ không nhạy cảm về thời gian, bạn có thể đặt thuộc tính isDiscretionary thành true.

00:20:57.000 --> 00:21:05.000
Điều này sẽ cho phép hệ thống chờ các điều kiện tối ưu để thực hiện chuyển khoản.

00:21:05.000 --> 00:21:11.000
Chúng tôi đã nói về cách ứng dụng của bạn có thể giúp giữ cho hàng đợi mạng ngắn.

00:21:11.000 --> 00:21:17.000
Một nguồn chậm trễ khác có thể là trên chính thiết bị gửi.

00:21:17.000 --> 00:21:23.000
Trong lịch sử, các ngăn xếp mạng đã sử dụng bộ đệm gửi rất lớn.

00:21:23.000 --> 00:21:32.000
Điều này làm tăng thêm rất nhiều độ trễ không cần thiết, đôi khi theo thứ tự giây, trước khi gói tin thậm chí đi vào mạng.

00:21:32.000 --> 00:21:40.000
Chúng tôi đã khắc phục điều này cho URLSession và NWConnection vào năm 2015.

00:21:40.000 --> 00:21:47.000
Nhưng hầu hết các máy chủ trên internet đều chạy trên Linux và sử dụng BSD Sockets.

00:21:47.000 --> 00:22:01.000
Liên hệ với các nhà khai thác máy chủ của bạn để đảm bảo rằng họ đang sử dụng tùy chọn ổ cắm hình mờ thấp TCP không gửi để giảm sự chậm trễ tại nguồn.

00:22:01.000 --> 00:22:10.000
Đối với các bước tiếp theo của bạn, Áp dụng các giao thức mạng hiện đại để loại bỏ nhiều chuyến khứ hồi.

00:22:10.000 --> 00:22:18.000
Sử dụng chế độ nền để tìm nạp trước tài sản, chuyển hàng loạt và các tác vụ không khẩn cấp.

00:22:18.000 --> 00:22:24.000
Kiểm tra hiệu suất ứng dụng của bạn trong các điều kiện mạng khác nhau.

00:22:24.000 --> 00:22:29.000
Network Link Conditioner là một công cụ tuyệt vời để làm điều đó.

00:22:29.000 --> 00:22:38.000
Giữ độ trễ mạng ở mức thấp sẽ cải thiện khả năng phản hồi của ứng dụng của bạn và nâng cao trải nghiệm người dùng tổng thể.

00:22:38.000 --> 00:22:42.000
Cảm ơn vì đã xem và có một WWDC tuyệt vời!

00:22:42.000 --> 23:59:59.000
♪

