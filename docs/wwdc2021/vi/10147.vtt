WEBVTT

00:00:02.000 --> 00:00:13.000
Xin chào, tên tôi là Kyle Sanner, từ nhóm Kỹ thuật Phần mềm GPU.

00:00:13.000 --> 00:00:21.000
Cùng với đồng nghiệp Alex Li của tôi, chúng ta sẽ nói về cách để có được nhịp độ khung hình tối ưu trong các ứng dụng của bạn trên màn hình tốc độ làm mới thay đổi.

00:00:21.000 --> 00:00:31.000
Chúng tôi sẽ tập trung vào một số công nghệ hiển thị mới đến với macOS, Adaptive-Sync và cách thúc đẩy bản vẽ tùy chỉnh mượt mà trên iPad Pro trong mọi điều kiện.

00:00:31.000 --> 00:00:37.000
Chúng ta sẽ bắt đầu với tổng quan nhanh về các loại màn hình hiện được hỗ trợ trên Nền tảng Apple.

00:00:37.000 --> 00:00:49.000
Chúng tôi sẽ giới thiệu cho bạn màn hình Adaptive-Sync trên Mac và các công cụ mới trong macOS Monterey mà bạn có thể sử dụng để cung cấp tốc độ khung hình mượt mà trong các ứng dụng và trò chơi toàn màn hình trên các màn hình này.

00:00:49.000 --> 00:01:01.000
Sau đó, chúng ta sẽ đi sâu vào ProMotion trên iPad Pro và xem xét một số phương pháp hay nhất của CADisplayLink giúp ứng dụng của bạn duy trì nhịp độ khung hình chính xác ở các tốc độ khung hình khác nhau.

00:01:01.000 --> 00:01:06.000
Trước tiên chúng ta hãy xem lại các loại màn hình mà các thiết bị của Apple có thể hỗ trợ.

00:01:06.000 --> 00:01:10.000
Hầu hết các màn hình trên hệ thống Apple hoạt động ở tốc độ làm mới cố định.

00:01:10.000 --> 00:01:16.000
Đó là, họ làm mới bản thân với tốc độ ổn định bất cứ khi nào họ được bật nguồn.

00:01:16.000 --> 00:01:22.000
Ngoại lệ là màn hình ProMotion của chúng tôi trên iPad, và bây giờ với màn hình Adaptive-Sync trên macOS.

00:01:22.000 --> 00:01:27.000
Hãy bắt đầu tìm hiểu những gì mới với màn hình Adaptive-Sync trên Mac.

00:01:27.000 --> 00:01:32.000
Chúng ta sẽ bắt đầu với màn hình Adaptive-Sync là gì và cách chúng hoạt động trên Mac.

00:01:32.000 --> 00:01:36.000
Nhưng trước tiên, trước tiên chúng ta hãy xem nhanh cách hoạt động của màn hình tốc độ cố định.

00:01:36.000 --> 00:01:41.000
Đây là một sơ đồ cho thấy các khung hình được chuyển đến màn hình 60Hz.

00:01:41.000 --> 00:01:47.000
Mỗi khung hình được trình bày cho màn hình, nơi nó ở trong 16ms trước khi màn hình được làm mới.

00:01:47.000 --> 00:01:53.000
Nếu có một khung mới được vẽ bởi máy Mac của bạn đã sẵn sàng trong Framebuffer, thì khung mới đó sẽ được trình bày.

00:01:53.000 --> 00:01:57.000
Nếu không, khung trước đó sẽ được hiển thị lại.

00:01:57.000 --> 00:02:09.000
Nhìn vào màn hình 120Hz, bạn thấy rằng mặc dù chúng tôi đã tăng gấp đôi tốc độ làm mới và do đó giảm một nửa khoảng thời gian mỗi khung hình có thể xuất hiện trên màn hình, nhưng nó hoạt động theo cùng một cách, chỉ nhanh hơn.

00:02:09.000 --> 00:02:12.000
Mặt khác, hãy xem màn hình Adaptive-Sync này.

00:02:12.000 --> 00:02:18.000
Thay vì một khoảng thời gian tĩnh, mỗi khung hình có một khoảng thời gian mà nó có thể ở trên màn hình.

00:02:18.000 --> 00:02:21.000
Cửa sổ này thay đổi tùy thuộc vào màn hình đính kèm.

00:02:21.000 --> 00:02:31.000
Màn hình này có thể hoạt động trong khoảng từ 40 đến 120Hz, có nghĩa là một khung hình có thể ở bất cứ đâu trong khoảng từ 8 đến 25ms.

00:02:31.000 --> 00:02:41.000
Lưu ý rằng khi thời gian tối đa đã trôi qua, hệ thống phải làm mới bảng điều khiển và màn hình sẽ không có sẵn trong thời gian ngắn để cập nhật mới trong một thời gian ngắn.

00:02:41.000 --> 00:02:46.000
Được rồi, vậy các trò chơi và ứng dụng của bạn có thể nhận được những lợi ích gì trên Màn hình đồng bộ hóa thích ứng?

00:02:46.000 --> 00:02:55.000
Đối với các ứng dụng chủ yếu chạy ở tốc độ làm mới tối đa của màn hình, màn hình Adaptive-Sync cung cấp một lợi ích tuyệt vời miễn phí.

00:02:55.000 --> 00:03:05.000
Trước tiên chúng ta hãy xem xét kịch bản này, nơi ứng dụng của bạn chủ yếu có thể tạo ra các khung hình mới dưới 8ms, vì vậy bạn đang chạy khá đáng tin cậy ở 120Hz.

00:03:05.000 --> 00:03:14.000
Nhưng do sự gia tăng nhất thời về độ phức tạp của cảnh, khung hình đã hoàn thành nằm trong Bộ đệm Khung 9ms sau khi khung hình trước đó được hiển thị lần đầu tiên.

00:03:14.000 --> 00:03:21.000
Trên màn hình hiển thị tốc độ khung hình cố định, khung hình trước đó được hiển thị 16ms, thay vì 8ms mà bạn dự định.

00:03:21.000 --> 00:03:25.000
Điều này dẫn đến một trở ngại có thể cảm nhận được trong ứng dụng của bạn.

00:03:25.000 --> 00:03:34.000
Trên màn hình Adaptive-Sync, khung của bạn được hiển thị lên màn hình ngay sau khi hoàn tất, vì vậy ứng dụng của bạn chỉ bị phạt 1ms.

00:03:34.000 --> 00:03:38.000
Những cú quá giang nhỏ này thường không thể cảm nhận được đối với người dùng.

00:03:38.000 --> 00:03:48.000
Đối với khối lượng công việc không thể đạt đến tốc độ khung hình tối đa của màn hình, bạn có thể cung cấp các khung hình mượt mà, đồng đều bằng cách thực hiện một số thay đổi nhỏ đối với cách ứng dụng của bạn trình bày các bản vẽ của nó.

00:03:48.000 --> 00:03:55.000
Hãy xem xét kịch bản này: một trò chơi chạy một cảnh phức tạp có thể tạo ra các bản cập nhật ở khoảng 90Hz.

00:03:55.000 --> 00:04:04.000
Tuy nhiên, một hiệu ứng không liên tục gây ra một bước nhảy lớn về độ phức tạp, nhưng làm như vậy không nhất quán, gây ra sự tăng đột biến đột ngột xuống 66Hz.

00:04:04.000 --> 00:04:14.000
Bằng cách theo dõi hoạt động GPU của ứng dụng của bạn, bạn có thể phản ứng với sự phức tạp tăng đột biến này bằng cách cố tình trình bày các khung hình của bạn sau này cho đến khi độ phức tạp của cảnh của bạn luôn thấp hơn.

00:04:14.000 --> 00:04:18.000
Bây giờ, hãy nói về một số phương pháp hay nhất của Adaptive-Sync.

00:04:18.000 --> 00:04:32.000
Trên màn hình tốc độ cố định, khi GPU của ứng dụng của bạn hoạt động liên tục vượt quá khoảng thời gian trên kính của màn hình, trước đây chúng tôi đã khuyên bạn nên làm chậm quá trình hiển thị của mình để đạt được yếu tố tiếp theo của tốc độ làm mới nhanh nhất của màn hình.

00:04:32.000 --> 00:04:40.000
Thông thường, điều đó có nghĩa là hạ thấp khung hình mục tiêu mỗi giây xuống 30 từ 60, như trong ví dụ này ở đây.

00:04:40.000 --> 00:04:44.000
Tuy nhiên, khi trình bày cho màn hình Adaptive-Sync, chúng tôi đang thay đổi hướng dẫn đó.

00:04:44.000 --> 00:04:50.000
Thay vào đó, bạn nên cố gắng trình bày các khung hình với tốc độ cao nhất mà ứng dụng của bạn có thể làm như vậy một cách đồng đều.

00:04:50.000 --> 00:05:03.000
Ngoài việc trình bày khung hình đồng đều, hãy nhớ rằng nếu khung hình của bạn được trình bày ở mức thấp hơn tốc độ tối thiểu mà màn hình hỗ trợ, màn hình có thể không khả dụng cho các khung hình mới, điều này có thể gây ra sự thay thế trong ứng dụng của bạn.

00:05:03.000 --> 00:05:08.000
Nhưng miễn là bạn ở trong phạm vi được hỗ trợ, bạn có thể tự do chọn bất kỳ tỷ lệ nào phù hợp nhất với ứng dụng của mình.

00:05:08.000 --> 00:05:17.000
Bây giờ bạn đã hiểu rõ về hỗ trợ hiển thị mới đến với Mac trong năm nay, hãy nói về cách bật Đồng bộ hóa thích ứng trong các trò chơi của bạn.

00:05:17.000 --> 00:05:19.000
Đầu tiên, bạn sẽ cần một máy Mac được hỗ trợ.

00:05:19.000 --> 00:05:27.000
Bất kỳ máy Mac nào có GPU Apple Silicon sẽ hoạt động tốt và chúng tôi cũng hỗ trợ nhiều máy Mac dựa trên Intel gần đây nhất của chúng tôi.

00:05:27.000 --> 00:05:33.000
Thứ hai, bạn sẽ cần một màn hình Adaptive-Sync được hỗ trợ và để bật chế độ Adaptive-Sync.

00:05:33.000 --> 00:05:40.000
Điều này có thể được thực hiện bằng cách chọn tốc độ làm mới biến mới có sẵn trong Tùy chọn hệ thống hiển thị.

00:05:40.000 --> 00:05:45.000
Và cuối cùng, ứng dụng của bạn cần phải chạy ở chế độ toàn màn hình.

00:05:45.000 --> 00:05:52.000
Hãy xem bạn có thể gọi API nào trong ứng dụng của mình để phát hiện xem nó có nên cố gắng lập lịch Adaptive-Sync hay không.

00:05:52.000 --> 00:05:57.000
Trước tiên, bạn sẽ cần xác định xem màn hình bạn đang chạy có khả năng lên lịch Adaptive-Sync hay không.

00:05:57.000 --> 00:06:04.000
Đối với điều đó, có một số thuộc tính mới trong năm nay trên NSScreen, minimumRefreshInterval và maximumRefreshInterval.

00:06:04.000 --> 00:06:10.000
Những giá trị này cho bạn biết phạm vi thời gian hợp lệ trên màn hình cho một khung hình được trình bày cho màn hình này.

00:06:10.000 --> 00:06:19.000
Trên màn hình khung cố định, các giá trị này sẽ giống nhau, vì vậy một so sánh đơn giản không bằng nhau sẽ cho bạn biết liệu màn hình này có ở chế độ Đồng bộ hóa thích ứng hay không.

00:06:19.000 --> 00:06:23.000
Tiếp theo, bạn sẽ cần biết liệu cửa sổ của bạn hiện có toàn màn hình hay không.

00:06:23.000 --> 00:06:27.000
Bạn có thể xác định điều đó bằng cách kiểm tra styleMask của cửa sổ.

00:06:27.000 --> 00:06:35.000
Và hãy nhớ rằng, bạn sẽ cần kết hợp cả hai kiểm tra này để đảm bảo ứng dụng của bạn có thể tận dụng lợi thế của lịch trình Adaptive-Sync.

00:06:35.000 --> 00:06:51.000
Được rồi, tuyệt vời. Vì vậy, bây giờ bạn đã xử lý màn hình Adaptive-Sync và các API mới mà macOS cung cấp để phát hiện chúng, hãy xem cách chúng ta có thể điều chỉnh một số kỹ thuật trình bày kim loại hiện có để trình bày đồng đều trên màn hình Adaptive-Sync.

00:06:51.000 --> 00:07:01.000
Bạn có thể sử dụng các API MetalDrawable của chúng tôi có nhiệt độ khung tích hợp, chẳng hạn như presentAfterMinimumDuration hoặc presentAtTime, để có hiệu quả tuyệt vời với màn hình Adaptive-Sync.

00:07:01.000 --> 00:07:07.000
Hoặc, bạn có thể tung ra giải pháp của riêng mình với một cuộc gọi quà ngay bây giờ và bộ hẹn giờ tùy chỉnh của riêng bạn.

00:07:07.000 --> 00:07:12.000
Hãy cùng xem một vài triển khai khác nhau sẽ hoạt động như thế nào.

00:07:12.000 --> 00:07:15.000
Chúng ta sẽ bắt đầu với một ví dụ đơn giản.

00:07:15.000 --> 00:07:21.000
Ở đây, chúng tôi sẽ có được một Drawable, thiết lập công việc GPU của chúng tôi và trình bày nó trên màn hình.

00:07:21.000 --> 00:07:27.000
Chúng tôi đang dựa vào áp lực ngược của Drawable có sẵn để đặt tốc độ khung hình cho chúng tôi.

00:07:27.000 --> 00:07:37.000
Trên màn hình tốc độ cố định, chúng tôi biết rằng đây không phải là ý tưởng tốt nhất, vì không có gì đảm bảo rằng công việc GPU của bạn sẽ phù hợp với tốc độ làm mới của màn hình.

00:07:37.000 --> 00:07:46.000
Nhưng như bạn có thể thấy từ việc chụp các nhạc cụ này được chụp trên màn hình Đồng bộ hóa Thích ứng, khi cảnh của chúng tôi nhất quán, điều này có vẻ ổn.

00:07:46.000 --> 00:07:50.000
Vấn đề ở đây là cảnh này đang gặp phải những trở ngại định kỳ.

00:07:50.000 --> 00:07:55.000
Những trở ngại này sẽ chuyển thành nói lắp có thể nhìn thấy cho người dùng.

00:07:55.000 --> 00:07:59.000
Hãy cố gắng khắc phục điều đó bằng cách trình bày với tỷ lệ cố định, chẵn.

00:07:59.000 --> 00:08:07.000
Kỹ thuật này cũng có thể được sử dụng nếu bạn muốn triển khai thanh trượt FPS có thể điều chỉnh cho người dùng trong trò chơi của mình.

00:08:07.000 --> 00:08:11.000
Ở đây, chúng tôi đã đặt tần số chúng tôi muốn thành 78Hz.

00:08:11.000 --> 00:08:20.000
Và thay vì một cuộc gọi hiện tại đơn giản, chúng tôi sẽ sử dụng hiện tại sau Thời lượng tối thiểu cho Drawable này và chỉ định khoảng thời gian mà chúng tôi đã xác định ở trên.

00:08:20.000 --> 00:08:24.000
Và ở đây, bạn có thể thấy các khung được trình bày trơn tru với tốc độ mà chúng tôi yêu cầu.

00:08:24.000 --> 00:08:34.000
Chúng tôi không trình bày nhanh như ví dụ trước, nhưng người dùng của bạn ít có khả năng gặp phải tình thế nói lắp hơn và ứng dụng của bạn sẽ sử dụng ít thời gian CPU và GPU hơn.

00:08:34.000 --> 00:08:38.000
Được rồi, vậy đây là nơi mọi thứ trở nên thú vị hơn một chút.

00:08:38.000 --> 00:08:44.000
Hãy thử một cách tiếp cận sẽ tạo ra các khung hình có nhịp độ đồng đều mà không cần phải đặt một tỷ lệ cố định nào.

00:08:44.000 --> 00:08:54.000
Một cách để làm điều này là tính trung bình luân phiên của công việc GPU cần thiết để tạo ra từng khung hình và đưa thời gian đó vào cuộc gọi Drawable hiện tại của chúng tôi.

00:08:54.000 --> 00:08:59.000
Đối với khung hình đầu tiên, chúng ta cần tải thời gian GPU trung bình của mình với giá trị bắt đầu.

00:08:59.000 --> 00:09:04.000
Tôi sẽ chọn lạc quan và nhắm mục tiêu tốc độ nhanh nhất mà màn hình có thể hỗ trợ ở đây.

00:09:04.000 --> 00:09:10.000
Đây sẽ chỉ là điểm khởi đầu cho mức trung bình của chúng tôi, vì vậy bất kỳ dự đoán hợp lý nào chúng tôi đưa ra đều ổn.

00:09:10.000 --> 00:09:20.000
Bây giờ, hãy đính kèm trình xử lý hoàn thành CommandBuffer để đo lượng thời gian GPU dành để hiển thị khung hình này và kết hợp thời gian đó vào mức trung bình của chúng tôi.

00:09:20.000 --> 00:09:24.000
Đầu tiên, chúng ta có thể có được thời gian GPU cần thiết để hoàn thành công việc của mình.

00:09:24.000 --> 00:09:31.000
Sau đó, chúng tôi sẽ kết hợp thời gian mới đó vào trung bình lăn của chúng tôi sẽ được sử dụng khi chúng tôi trình bày khung hình tiếp theo.

00:09:31.000 --> 00:09:33.000
Và đây là kết quả.

00:09:33.000 --> 00:09:46.000
Như bạn có thể thấy, chúng tôi đang trình bày với tốc độ tương tự như ví dụ trước, nhưng giới hạn này được xác định bởi các khung hình trước đó mà chúng tôi đã tạo và sẽ tạo ra tốc độ khung hình chẵn trên một loạt các GPU Mac.

00:09:46.000 --> 00:09:54.000
Ở đây, chúng ta có thể thấy cùng một chương trình chạy trơn tru ở 48Hz trên một máy Mac kém mạnh hơn, mà không cần bất kỳ thay đổi mã bổ sung nào.

00:09:54.000 --> 00:10:01.000
Được rồi, Bây giờ bạn đã có một số công cụ và kỹ thuật mới mà bạn có thể sử dụng để tối ưu hóa ứng dụng của mình cho màn hình Adaptive-Sync.

00:10:01.000 --> 00:10:08.000
Nếu bạn muốn tìm hiểu thêm về màn hình Adaptive-Sync trên macOS, hãy xem dự án mẫu Metal mới trên trang web Nhà phát triển Apple.

00:10:08.000 --> 00:10:15.000
Để tìm hiểu thêm về việc cung cấp trải nghiệm hiệu suất trong Metal, hãy xem các cuộc nói chuyện WWDC này từ những năm trước.

00:10:15.000 --> 00:10:21.000
Và bây giờ, tôi sẽ giao bạn cho Alex, nơi bạn sẽ tìm hiểu thêm về nhịp độ khung hình trên iPad Pro.

00:10:21.000 --> 00:10:22.000
Cảm ơn bạn, Kyle.

00:10:22.000 --> 00:10:25.000
Tiếp theo, hãy nói về ProMotion.

00:10:25.000 --> 00:10:33.000
Kể từ năm 2017, mọi iPad Pro đều được trang bị màn hình ProMotion mang lại tốc độ làm mới lên đến 120Hz.

00:10:33.000 --> 00:10:44.000
Tuy nhiên, 120Hz có thể không khả dụng trong một số tình huống, bao gồm cả khi người dùng đã bật Chế độ năng lượng thấp, chế độ này đã được đưa lên iPad trong năm nay với iPadOS 15.

00:10:44.000 --> 00:10:53.000
Nhịp độ khung hình thích hợp sẽ cho phép ứng dụng của bạn trình bày nội dung chuyển động một cách chính xác và trơn tru, bất kể đặc điểm hiển thị, sở thích của người dùng và trạng thái hệ thống.

00:10:53.000 --> 00:11:02.000
Chúng ta sẽ xem xét sự khác biệt giữa ProMotion và màn hình tỷ lệ cố định, cũng như các tình huống trong đó một số tốc độ khung hình có thể không khả dụng.

00:11:02.000 --> 00:11:08.000
Tiếp theo, chúng ta sẽ thảo luận về liên kết hiển thị là gì và cách ứng dụng của bạn có thể sử dụng nó để thúc đẩy bản vẽ tùy chỉnh.

00:11:08.000 --> 00:11:13.000
Và cuối cùng, chúng tôi sẽ cung cấp một số phương pháp hay nhất về liên kết hiển thị.

00:11:13.000 --> 00:11:15.000
Hãy đi sâu vào.

00:11:15.000 --> 00:11:23.000
Như Kyle đã trình bày ngắn gọn trước đó, một màn hình 60Hz cố định làm mới sau mỗi 16ms, một nhịp cố định.

00:11:23.000 --> 00:11:29.000
Nó hỗ trợ trình bày mượt mà các nội dung có tốc độ khung hình là hệ số 60.

00:11:29.000 --> 00:11:34.000
Ví dụ, 60Hz, 30Hz, 20Hz, vân vân.

00:11:34.000 --> 00:11:49.000
Tuy nhiên, khi nội dung chậm hơn tốc độ làm mới màn hình, chẳng hạn như 30Hz, bản thân màn hình vẫn phải được làm mới ở cùng một nhịp, do đó, mọi khung hình khác đều lặp lại so với khung hình trước đó và điều này tiêu thụ một số năng lượng.

00:11:49.000 --> 00:11:56.000
Mặt khác, ProMotion cung cấp khả năng phản hồi tuyệt vời với tốc độ làm mới lên đến 120Hz.

00:11:56.000 --> 00:12:01.000
Nó cũng thích ứng với nội dung trên màn hình và do đó giảm mức tiêu thụ điện năng của nó.

00:12:01.000 --> 00:12:03.000
Hãy xem nó hoạt động như thế nào.

00:12:03.000 --> 00:12:10.000
Tất nhiên, ở tốc độ làm mới tối đa 120Hz, màn hình làm mới sau mỗi 8ms.

00:12:10.000 --> 00:12:16.000
Vì 120 là bội số của 60, ProMotion hỗ trợ tất cả các tốc độ khung hình hiện có.

00:12:16.000 --> 00:12:22.000
Nó không chỉ cung cấp 120Hz, mà còn cung cấp một số tốc độ khung hình trung gian cho các ứng dụng của bạn.

00:12:22.000 --> 00:12:37.000
Hơn nữa, ProMotion có thể tự động điều chỉnh tốc độ làm mới của nó, vì vậy với nội dung 60Hz mượt mà, nó chỉ có thể làm mới sau mỗi 16ms mà không cần lặp lại, nếu không sẽ được yêu cầu trên màn hình 120Hz cố định.

00:12:37.000 --> 00:12:41.000
Điều này đúng với 24Hz.

00:12:41.000 --> 00:12:44.000
Bây giờ, những tốc độ khung hình này có thể không phải lúc nào cũng có sẵn.

00:12:44.000 --> 00:12:51.000
Người dùng có thể bật chuyển đổi Tốc độ khung hình giới hạn trong cài đặt Trợ năng giới hạn tốc độ khung hình tối đa thành 60Hz.

00:12:51.000 --> 00:12:58.000
Ngoài ra, khi thiết bị nóng lên, hệ thống có thể áp dụng các hạn chế về tính khả dụng của 120Hz.

00:12:58.000 --> 00:13:04.000
Với iPadOS 15, chúng tôi cũng sẽ thực thi nắp 60Hz ở Chế độ Năng lượng Thấp.

00:13:04.000 --> 00:13:07.000
Vậy, những tình huống này ảnh hưởng đến ứng dụng của bạn như thế nào?

00:13:07.000 --> 00:13:11.000
Tin tốt là hầu hết các ứng dụng sẽ hoạt động mà không có bất kỳ thay đổi nào.

00:13:11.000 --> 00:13:20.000
Nhưng nếu ứng dụng của bạn thực hiện vẽ tùy chỉnh từng khung hình, thì bạn sẽ cần chú ý đến những thay đổi tốc độ khung hình này và chúng tôi sẽ chỉ cho bạn cách thực hiện điều đó.

00:13:20.000 --> 00:13:28.000
Công cụ được đề xuất để thúc đẩy bản vẽ tùy chỉnh là liên kết hiển thị, về cơ bản là bộ hẹn giờ được đồng bộ hóa với tốc độ làm mới màn hình.

00:13:28.000 --> 00:13:33.000
Nó giúp ứng dụng của bạn điều khiển bất kỳ hoạt ảnh tùy chỉnh hoặc vòng lặp kết xuất tùy chỉnh nào.

00:13:33.000 --> 00:13:34.000
Có hai liên kết hiển thị.

00:13:34.000 --> 00:13:48.000
Một là CVDisplayLink, được cung cấp bởi CoreVideo trên macOS, và cái còn lại là CADisplayLink, được cung cấp bởi CoreAnimation trên các nền tảng khác của chúng tôi, cũng như Catalyst trên macOS, mỗi nền tảng có các đặc điểm và hành vi hơi khác nhau.

00:13:48.000 --> 00:13:55.000
Hôm nay, chúng ta sẽ chỉ thảo luận về CADisplayLink, nhưng ở cấp độ cao, những khái niệm này sẽ áp dụng cho cả hai.

00:13:55.000 --> 00:14:00.000
CADisplayLink thức dậy ở mỗi vsync và gọi cuộc gọi lại.

00:14:00.000 --> 00:14:06.000
Điều này cung cấp cho ứng dụng toàn bộ 8ms để hoàn thành công việc của nó.

00:14:06.000 --> 00:14:13.000
Bộ hẹn giờ thông thường, chẳng hạn như NSTimer, rất khó có thể đồng bộ hoàn hảo với màn hình.

00:14:13.000 --> 00:14:23.000
Nó có thể bị lệch pha hoặc trôi dạt, vì vậy đôi khi ứng dụng có thể không có đủ thời gian để hoàn thành công việc của mình và nó dẫn đến việc giảm khung hình.

00:14:23.000 --> 00:14:30.000
Bây giờ bạn đã thấy cách CADisplayLink cung cấp thời gian nhất quán, đây là một số lợi ích bổ sung của nó.

00:14:30.000 --> 00:14:42.000
Nó có thể chạy với tốc độ chậm hơn tốc độ làm mới màn hình và để làm như vậy, ứng dụng của bạn cung cấp gợi ý thông qua khung hình ưu tiên PerSecond và chúng tôi sẽ chọn tốc độ khung hình có sẵn gần nhất cho bạn.

00:14:42.000 --> 00:14:50.000
Khi tính khả dụng của tốc độ khung hình thay đổi, như chúng ta đã thảo luận trước đó, CADisplayLink sẽ tự động điều chỉnh tốc độ của nó dưới mui xe.

00:14:50.000 --> 00:14:57.000
Tất nhiên, nó cũng cung cấp cho ứng dụng của bạn thông tin thời gian cần thiết để bản vẽ tùy chỉnh của bạn có thể nhận thức được những thay đổi này.

00:14:57.000 --> 00:15:11.000
Chúng tôi sẽ không đi sâu vào cách viết hoạt ảnh tùy chỉnh hoặc vòng lặp kết xuất tùy chỉnh, nhưng chúng tôi sẽ cung cấp cho bạn bốn phương pháp hay nhất để giúp bản vẽ tùy chỉnh của bạn đồng bộ với thời gian hiển thị và tránh một số cạm bẫy phổ biến.

00:15:11.000 --> 00:15:17.000
Đầu tiên, điều quan trọng là phải truy vấn tốc độ làm mới màn hình trong thời gian chạy thay vì mã hóa cứng nó.

00:15:17.000 --> 00:15:23.000
Thứ hai, thường thì bạn nên sử dụng tốc độ khung hình của chính CADisplayLink.

00:15:23.000 --> 00:15:28.000
Tiếp theo, sử dụng targetTimestamp để chuẩn bị bản vẽ sẽ giúp giảm trở ngại.

00:15:28.000 --> 00:15:35.000
Cuối cùng, luôn luôn là một ý tưởng tốt để chuẩn bị cho những điều bất ngờ bằng cách tính toán động đồng bằng thời gian.

00:15:35.000 --> 00:15:37.000
Hãy xem qua từng cái một.

00:15:37.000 --> 00:15:50.000
Tốc độ làm mới màn hình tối đa có thể được truy vấn thông qua UIScreen, sẽ luôn trả về 120Hz trên màn hình ProMotion, ngay cả trong các tình huống như khi bật Chế độ nguồn điện thấp.

00:15:50.000 --> 00:16:01.000
Mặt khác, CADisplayLink sẽ thực sự cung cấp khoảng thời gian ngắn nhất giữa các khung hình thông qua thuộc tính thời lượng và nó sẽ tự động cập nhật dựa trên trạng thái thiết bị hiện tại.

00:16:01.000 --> 00:16:11.000
Nhưng hầu như luôn luôn, bạn nên sử dụng thông tin khung hình thực tế trực tiếp từ CADisplayLink vì liên kết hiển thị có thể chạy chậm hơn tốc độ làm mới màn hình tối đa.

00:16:11.000 --> 00:16:23.000
Ngoài ra, tính khả dụng của tốc độ khung hình phụ thuộc vào phần cứng và tốc độ khung hình thực tế có thể được thay đổi động bởi chính liên kết hiển thị để đáp ứng với những thay đổi trạng thái hệ thống.

00:16:23.000 --> 00:16:25.000
Hãy xem xét một ví dụ.

00:16:25.000 --> 00:16:27.000
Giả sử chúng tôi yêu cầu một liên kết hiển thị 40Hz.

00:16:27.000 --> 00:16:32.000
Như bạn thấy, trên màn hình ProMotion, 40Hz được hỗ trợ.

00:16:32.000 --> 00:16:41.000
Tuy nhiên, trên màn hình 60Hz hoặc khi ProMotion được giới hạn ở 60Hz, liên kết màn hình sẽ tự động điều chỉnh thành 30Hz.

00:16:41.000 --> 00:16:49.000
Điều này đảm bảo một nhịp tốt trong đó mỗi lần đánh thức nằm trên một vsync có thể cố gắng cung cấp lượng thời gian bằng nhau cho mỗi khung hình.

00:16:49.000 --> 00:17:05.000
Nếu chúng tôi sử dụng NSTimer 40Hz đơn giản, không nhận thức được tốc độ khung hình, quá trình đánh thức của nó có thể ở ngay giữa khoảng thời gian vsync và tất nhiên, chúng tôi không thể trình bày khung ở đó, vì vậy bạn có thể sẽ quan sát thấy các trở ngại trong bản vẽ tùy chỉnh của mình.

00:17:05.000 --> 00:17:07.000
Vậy, nó trông như thế nào trong mã?

00:17:07.000 --> 00:17:11.000
Chà, đây là cách bạn thường thiết lập một liên kết hiển thị.

00:17:11.000 --> 00:17:16.000
Đầu tiên, bạn phải cung cấp một mục tiêu và một bộ chọn, đó là cuộc gọi lại được gọi.

00:17:16.000 --> 00:17:22.000
Tiếp theo, gợi ý tốc độ khung hình ưa thích là 40Hz thông qua khung hình ưu tiênPerSecond.

00:17:22.000 --> 00:17:28.000
Sau đó, bạn thêm liên kết hiển thị vào vòng lặp chạy hiện tại, từ đó cuộc gọi lại sẽ được gọi.

00:17:28.000 --> 00:17:35.000
Vì vậy, trong cuộc gọi lại, bạn có thể nhận được khoảng thời gian dự kiến giữa các lần đánh thức liên kết hiển thị bằng cách trừ dấu thời gian khỏi targetTimestamp.

00:17:35.000 --> 00:17:43.000
Khoảng thời gian này không nhất thiết phải luôn là 1 trên 40 vì bản thân liên kết hiển thị có thể đang chạy ở một tần số khác.

00:17:43.000 --> 00:17:46.000
Tiếp theo, hãy nói về những dấu thời gian này.

00:17:46.000 --> 00:17:58.000
Chủ yếu có hai dấu thời gian trên CADisplayLink, Dấu thời gian, biểu thị khi cuộc gọi lại được lên lịch gọi và dấu thời gian mục tiêu, đó là khi khung tiếp theo sẽ được CoreAnimation tổng hợp.

00:17:58.000 --> 00:18:05.000
Chúng tôi sẽ xem qua một ví dụ minh họa lý do tại sao bạn nên sử dụng targetTimestamp để chuẩn bị bản vẽ của mình.

00:18:05.000 --> 00:18:10.000
Đây là một hình ảnh động trong miền thời gian chuẩn hóa của nó từ 0 đến 1.

00:18:10.000 --> 00:18:16.000
Giả sử chúng ta đang nhắm mục tiêu tốc độ khung hình cao nhất có thể và hiện tại là 120Hz.

00:18:16.000 --> 00:18:29.000
CADisplayLink thức dậy và nếu chúng tôi chuẩn bị bản trình bày khung của mình bằng dấu thời gian, chúng tôi sẽ lấy mẫu trực tiếp tại đây, được trình bày trong vsync tiếp theo và đây là.

00:18:29.000 --> 00:18:39.000
Quá trình tương tự vẫn tiếp tục và chúng tôi thấy rằng nó có nhịp tốt trong đó với mỗi khung hình 120Hz, tiến trình hoạt hình của chúng tôi tăng 0,05.

00:18:39.000 --> 00:18:45.000
Bây giờ, giả sử trạng thái nhiệt thay đổi và 120Hz không còn khả dụng nữa.

00:18:45.000 --> 00:18:57.000
Bây giờ liên kết hiển thị thức dậy một lần nữa và ứng dụng chuẩn bị hoạt ảnh ở tiến trình 0.4, được trình bày trong vsync tiếp theo ngay tại đây.

00:18:57.000 --> 00:18:59.000
Và mô hình tương tự vẫn tiếp tục.

00:18:59.000 --> 00:19:02.000
Có điều gì đó không hoàn toàn đúng trong quá trình chuyển đổi ở đây.

00:19:02.000 --> 00:19:11.000
Chúng tôi thấy rằng tiến độ tăng 0,05, nhưng một cái trên 8ms và cái còn lại trên 16ms.

00:19:11.000 --> 00:19:23.000
Rất rõ ràng nếu chúng ta vẽ biểu đồ tiến độ so với thời gian, chúng ta sẽ thấy một trục trặc ngay khi chuyển đổi và điều này sẽ phản ánh như một trở ngại có thể cảm nhận được của người dùng và điều đó không mong muốn.

00:19:23.000 --> 00:19:26.000
Bây giờ, hãy thử targetTimestamp.

00:19:26.000 --> 00:19:28.000
CADisplayLink thức dậy ở đây.

00:19:28.000 --> 00:19:33.000
Tiến trình được lấy mẫu tại targetTimestamp, cho 0,15.

00:19:33.000 --> 00:19:38.000
Mô hình tương tự vẫn tiếp tục, và một lần nữa, chúng ta thấy một nhịp tốt.

00:19:38.000 --> 00:19:46.000
Tại điểm chuyển đổi tốc độ khung hình này, liên kết hiển thị thức dậy, các mẫu tại targetTimestamp và chúng tôi nhận được 0,50.

00:19:46.000 --> 00:19:49.000
Và nó tiếp tục theo cùng một cách.

00:19:49.000 --> 00:19:58.000
Nếu chúng ta vẽ cùng một biểu đồ tiến độ so với thời gian, bạn sẽ thấy rằng đó là một đường thẳng và do đó nó cung cấp nội dung mượt mà ngay cả khi tốc độ khung hình thay đổi.

00:19:58.000 --> 00:20:04.000
Vì vậy, targetTimestamp nên được sử dụng thay vì dấu thời gian để chuẩn bị bản vẽ của bạn.

00:20:04.000 --> 00:20:12.000
Trong mã của bạn, nó thường đơn giản như thay thế bất kỳ việc sử dụng dấu thời gian nào bằng targetTimestamp.

00:20:12.000 --> 00:20:16.000
Cuối cùng, hãy nói về tính toán động đồng bằng thời gian.

00:20:16.000 --> 00:20:26.000
Sự khác biệt giữa targetTimestamp và dấu thời gian cung cấp cho bạn khoảng thời gian dự kiến giữa các cuộc gọi lại liên kết hiển thị, nhưng khoảng thời gian thực tế không được đảm bảo.

00:20:26.000 --> 00:20:32.000
Một luồng ưu tiên cao hơn có thể được lên lịch trên CPU hoặc runloop đang bận với một thứ khác.

00:20:32.000 --> 00:20:44.000
Trong trường hợp cực đoan, các cuộc gọi lại có thể bị bỏ qua hoàn toàn, vì vậy trong những tình huống này, điều đặc biệt quan trọng là vẫn duy trì thời gian chính xác trong bản vẽ tùy chỉnh của bạn để có trải nghiệm người dùng tốt nhất.

00:20:44.000 --> 00:20:52.000
Khi cuộc gọi lại CADisplayLink được gọi, ứng dụng sẽ thực hiện công việc của mình để chuẩn bị các bản cập nhật hoặc kết xuất cần thiết cho khung tiếp theo.

00:20:52.000 --> 00:20:58.000
Thông thường, cuộc gọi lại sẽ được gọi ngay tại thời gian thức dậy theo lịch trình, nhưng nó không tránh được trường hợp này.

00:20:58.000 --> 00:21:00.000
Chúng tôi hy vọng cuộc gọi lại tiếp theo sẽ được gọi ở đây.

00:21:00.000 --> 00:21:07.000
Tuy nhiên, liên kết hiển thị không có cơ hội chạy cho đến vài mili giây trong khoảng thời gian vsync.

00:21:07.000 --> 00:21:10.000
Và do đó, bạn có thể không nhận được đầy đủ 8ms.

00:21:10.000 --> 00:21:18.000
Trong trường hợp này, bạn có thể truy vấn CACurrentMediaTime và so sánh với targetTimestamp để biết có bao nhiêu thời gian có sẵn.

00:21:18.000 --> 00:21:22.000
Bây giờ, giả sử công việc mất quá nhiều thời gian trong khung này.

00:21:22.000 --> 00:21:26.000
Cuộc gọi lại tiếp theo sẽ không được gọi cho đến khi runloop trống trở lại.

00:21:26.000 --> 00:21:48.000
Bởi vì cái này bị trì hoãn, cuộc gọi lại sau đây sẽ bị bỏ qua, vì vậy khi bạn đang chuẩn bị tiến hành bản vẽ tùy chỉnh của mình trong cuộc gọi lại này, hãy lưu ý rằng thời gian delta mà bạn nên sử dụng không phải là 8ms, mà là 16ms, nếu bạn theo dõi dấu thời gian trước đó mà trạng thái bản vẽ tùy chỉnh của

00:21:48.000 --> 00:21:58.000
Do đó, nếu ứng dụng của bạn sử dụng đồng bằng thời gian để nâng cao trạng thái bản vẽ tùy chỉnh của bạn, điều này sẽ làm chậm bản vẽ tùy chỉnh của bạn xuống một khung mỗi khi bỏ qua một bản calback.

00:21:58.000 --> 00:22:04.000
Thay vào đó, bạn có thể theo dõi Dấu thời gian mục tiêu trước đó để bạn có thể nâng cấp trạng thái một cách chính xác.

00:22:04.000 --> 00:22:13.000
Và nếu bản vẽ tùy chỉnh của bạn có khối lượng công việc cao, bạn có thể xem targetTimestamp để có khả năng giảm khối lượng công việc để đáp ứng thời hạn khi cần thiết.

00:22:13.000 --> 00:22:17.000
Để tóm tắt lại các phương pháp hay nhất, đừng đoán tốc độ làm mới màn hình.

00:22:17.000 --> 00:22:19.000
Luôn truy vấn nó trong thời gian chạy.

00:22:19.000 --> 00:22:26.000
Bản vẽ tùy chỉnh của bạn phải linh hoạt ở tốc độ khung hình được hỗ trợ và phải sẵn sàng thích ứng với tốc độ khác.

00:22:26.000 --> 00:22:36.000
Sử dụng targetTimestamp để đảm bảo chuyển đổi tốc độ khung hình không gặp trở ngại và đề phòng mọi tình huống bất ngờ, chẳng hạn như gọi lại liên kết hiển thị bị bỏ lỡ.

00:22:36.000 --> 00:22:38.000
Vì vậy, hãy kết thúc.

00:22:38.000 --> 00:22:46.000
Trong nửa đầu của phiên này, chúng tôi đã thảo luận về cách tối ưu hóa tốc độ khung hình của ứng dụng của bạn khi chạy trên màn hình Adaptive-Sync trên macOS.

00:22:46.000 --> 00:22:58.000
Trong nửa sau, chúng tôi đã mô tả các phương pháp hay nhất để ứng dụng của bạn thúc đẩy bản vẽ tùy chỉnh và duy trì nhịp độ khung hình mượt mà trong mọi điều kiện trên màn hình ProMotion trên iPad Pro.

00:22:58.000 --> 00:23:10.000
Khi các công nghệ hiển thị tiếp tục phát triển, chúng tôi hy vọng phiên này đã cung cấp cho bạn không chỉ thông tin chi tiết mà còn cả các công cụ và phương pháp hay nhất để hỗ trợ thời gian ngày càng năng động của màn hình.

00:23:10.000 --> 00:23:15.000
Cảm ơn bạn rất nhiều vì đã tham gia cùng chúng tôi, và tận hưởng phần còn lại của WWDC 2021.

00:23:15.000 --> 23:59:59.000
[Âm nhạc].

