WEBVTT

00:00:00.000 --> 00:00:05.000
♪ Nhạc bass đang phát ♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:15.000
Matt Ricketson: Chào mừng đến với "Có gì mới trong SwiftUI." Tôi là Matt, và sau này, tôi sẽ được Taylor tham gia.

00:00:15.000 --> 00:00:20.000
Phiên này là tất cả về SwiftUI, khung giao diện người dùng khai báo của Apple.

00:00:20.000 --> 00:00:25.000
SwiftUI vẫn còn trẻ, nhưng chúng ta đã đi rất xa rồi.

00:00:25.000 --> 00:00:36.000
SwiftUI được phát hành lần đầu tiên vào năm 2019, giới thiệu một cách mới mạnh mẽ để xây dựng giao diện người dùng theo phong cách khai báo, dựa trên trạng thái.

00:00:36.000 --> 00:00:46.000
Chúng tôi đã thực hiện bước tiến lớn tiếp theo với bản phát hành thứ hai của SwiftUI, cho phép 100% ứng dụng SwiftUI với API Ứng dụng và Cảnh mới.

00:00:46.000 --> 00:00:55.000
Năm nay chúng tôi tập trung vào việc hỗ trợ việc áp dụng SwiftUI sâu hơn nữa trong các ứng dụng của bạn với một bộ tính năng mới phong phú tuyệt vời.

00:00:55.000 --> 00:01:00.000
Bây giờ nếu bạn chưa có cơ hội tự mình dùng thử SwiftUI, không sao cả!

00:01:00.000 --> 00:01:04.000
Chỉ có bạn mới biết điều gì là tốt nhất cho ứng dụng của bạn.

00:01:04.000 --> 00:01:10.000
Nhưng đây là một vài mẹo cần ghi nhớ khi bạn tìm hiểu về tất cả các tính năng mới có sẵn trong năm nay.

00:01:10.000 --> 00:01:23.000
Một cách hay để nhúng ngón chân của bạn vào SwiftUI là sử dụng nó để tạo các tính năng hoàn toàn mới trong một ứng dụng hiện có, như cách nó cung cấp năng lượng cho luồng hoạt động mới trong Ghi chú cho iOS, iPadOS và macOS.

00:01:23.000 --> 00:01:28.000
Hoặc bộ chọn hình đại diện mới trong macOS, cũng được xây dựng bằng SwiftUI.

00:01:28.000 --> 00:01:36.000
Hãy nhớ rằng, bạn có thể kết hợp SwiftUI cùng với mã UIKit hoặc AppKit hiện có của mình.

00:01:36.000 --> 00:01:44.000
SwiftUI cũng là một công cụ hữu ích để mở rộng ứng dụng của bạn sang các nền tảng mới, như cách SwiftUI được sử dụng để xây dựng ứng dụng Phím tắt mới trên macOS.

00:01:44.000 --> 00:01:54.000
Với SwiftUI, bạn có thể dễ dàng chia sẻ mã chung giữa các nền tảng trong khi vẫn tạo ra trải nghiệm độc đáo cho từng thiết bị.

00:01:54.000 --> 00:01:59.000
Và khi bạn đã sẵn sàng thiết kế lại ứng dụng của mình, đó là thời điểm hoàn hảo để SwiftUI trợ giúp.

00:01:59.000 --> 00:02:12.000
Quy trình mua Apple Pay hoàn toàn mới được thiết kế lại bằng SwiftUI, cũng được sử dụng để mang lại một lớp sơn mới cho Trình xem trợ giúp mới trên macOS và ứng dụng Mẹo trên watchOS.

00:02:12.000 --> 00:02:21.000
Và cuối cùng, chúng ta không thể quên ứng dụng Thời tiết mới tuyệt đẹp dành cho iOS, cũng được xây dựng lại từ đầu trong SwiftUI.

00:02:21.000 --> 00:02:28.000
Đây chỉ là một vài ví dụ về cách SwiftUI đang giúp xây dựng thế hệ ứng dụng tiếp theo.

00:02:28.000 --> 00:02:34.000
Đối với phiên này, chúng tôi muốn chia sẻ một số API mới tuyệt vời giúp tất cả trở nên khả thi.

00:02:34.000 --> 00:02:40.000
Chúng tôi sẽ bắt đầu bằng cách xem xét các cải tiến về cách chúng tôi xây dựng các bộ sưu tập nội dung với danh sách và lưới.

00:02:40.000 --> 00:02:48.000
Tiếp theo, chúng tôi sẽ vượt ra ngoài danh sách, giới thiệu các tính năng mới để đưa các ứng dụng dựa trên dữ liệu của bạn lên một tầm cao mới.

00:02:48.000 --> 00:02:54.000
Thứ ba, chúng tôi sẽ giới thiệu một số công cụ mới tuyệt đẹp để điều khiển đồ họa và hiệu ứng hình ảnh.

00:02:54.000 --> 00:02:59.000
Chúng ta sẽ nói về những cải tiến đối với văn bản, bàn phím và điều hướng dựa trên tiêu điểm.

00:02:59.000 --> 00:03:03.000
Và cuối cùng, chúng tôi sẽ dành một số tình yêu cho các nút.

00:03:03.000 --> 00:03:13.000
Vì vậy, hãy đi sâu vào, bắt đầu với danh sách và lưới, đây là những tính năng quan trọng để tổ chức và hiển thị dữ liệu trong các ứng dụng SwiftUI.

00:03:13.000 --> 00:03:20.000
Năm nay, chúng tôi đang làm cho việc viết các danh sách và lưới phong phú, tương tác trở nên dễ dàng hơn.

00:03:20.000 --> 00:03:22.000
Hãy bắt đầu với một cái vui vẻ.

00:03:22.000 --> 00:03:28.000
SwiftUI hiện có hỗ trợ tích hợp để tải hình ảnh không đồng bộ.

00:03:28.000 --> 00:03:34.000
SwiftUI giúp việc tải những hình ảnh này trở nên dễ dàng với chế độ xem AsyncImage mới.

00:03:34.000 --> 00:03:43.000
Chỉ cần cung cấp cho nó một URL và SwiftUI sẽ tự động tìm nạp và hiển thị hình ảnh từ xa cho bạn, và thậm chí cung cấp một trình giữ chỗ mặc định.

00:03:43.000 --> 00:03:45.000
AsyncImage cũng có thể được tùy chỉnh.

00:03:45.000 --> 00:03:55.000
Ví dụ, chúng ta có thể thêm công cụ sửa đổi vào hình ảnh đã tải và cũng xác định trình giữ chỗ tùy chỉnh, giống như tôi đang làm ở đây để thêm một số màu sắc thú vị.

00:03:55.000 --> 00:03:58.000
Chúng tôi thậm chí có thể thêm hoạt ảnh tùy chỉnh và xử lý lỗi!

00:03:58.000 --> 00:04:02.000
Và AsyncImage có sẵn trên tất cả các nền tảng.

00:04:02.000 --> 00:04:05.000
Chúng tôi hy vọng bạn kiểm tra nó.

00:04:05.000 --> 00:04:14.000
AsyncImage tải nội dung của nó ngay lập tức, nhưng đôi khi ứng dụng của bạn cần tải nội dung theo yêu cầu, như khi hiển thị nguồn cấp dữ liệu.

00:04:14.000 --> 00:04:23.000
Đây là một trường hợp sử dụng tuyệt vời để hỗ trợ kéo để làm mới trên iOS và iPadOS, sử dụng công cụ sửa đổi có thể làm mới mới.

00:04:23.000 --> 00:04:29.000
Công cụ sửa đổi này định cấu hình một hành động làm mới và truyền xuống môi trường.

00:04:29.000 --> 00:04:40.000
Danh sách trên iOS và iPadOS sử dụng hành động này để tự động thêm kéo để làm mới, nhưng bạn cũng có thể sử dụng nó để xây dựng các hành vi làm mới tùy chỉnh của riêng mình.

00:04:40.000 --> 00:04:47.000
Bạn có thể nhận thấy từ khóa chờ đợi mới này, đây là một trong những tính năng ngôn ngữ đồng thời mới trong Swift 5.5.

00:04:47.000 --> 00:04:56.000
Điều này chỉ ra rằng phương thức updateItems là một hành động không đồng bộ, cho phép chúng tôi làm mới danh sách của mình mà không chặn giao diện người dùng.

00:04:56.000 --> 00:05:02.000
Một tính năng SwiftUI liên quan đến đồng thời mới khác là công cụ sửa đổi tác vụ.

00:05:02.000 --> 00:05:07.000
API này cho phép bạn đính kèm một tác vụ không đồng bộ vào vòng đời của chế độ xem.

00:05:07.000 --> 00:05:14.000
Điều đó có nghĩa là nhiệm vụ sẽ bắt đầu khi chế độ xem tải lần đầu tiên và tự động hủy khi chế độ xem bị xóa.

00:05:14.000 --> 00:05:19.000
Đây là một cách tuyệt vời để chúng tôi tự động tải lô ảnh đầu tiên.

00:05:19.000 --> 00:05:28.000
Những công cụ sửa đổi đồng thời mới này trông đơn giản trên bề mặt, nhưng có thể được sử dụng để xây dựng các hành vi không đồng bộ tinh vi vào ứng dụng của bạn.

00:05:28.000 --> 00:05:35.000
Ví dụ, ở đây tôi đã thiết lập một nhiệm vụ để tải những bức ảnh mới nhất khi chúng có sẵn.

00:05:35.000 --> 00:05:41.000
Tôi chỉ viết một vòng lặp thông thường, nhưng bạn cũng sẽ nhận thấy từ khóa await được sử dụng ở đây.

00:05:41.000 --> 00:05:49.000
Đó là bởi vì các ứng cử viên mới nhất thực sự là một chuỗi không đồng bộ, đây là một tính năng đồng thời mới khác trong Swift 5.5.

00:05:49.000 --> 00:05:57.000
Điều này có nghĩa là chúng tôi sẽ chờ ứng cử viên mới nhất không đồng bộ, chỉ lặp lại vòng lặp khi ứng cử viên tiếp theo có sẵn.

00:05:57.000 --> 00:06:02.000
Điều đó có nghĩa là chúng tôi thực sự đang đóng gói rất nhiều chức năng chỉ trong công cụ sửa đổi duy nhất này.

00:06:02.000 --> 00:06:18.000
Chế độ xem bắt đầu một tác vụ lắng nghe ứng viên không đồng bộ ngay khi nó xuất hiện, cập nhật danh sách mỗi khi một ứng cử viên mới có sẵn và sau đó tự động hủy tác vụ khi chế độ xem biến mất, tất cả mà không chặn giao diện người dùng của ứng dụng của chúng tôi.

00:06:18.000 --> 00:06:26.000
Có rất nhiều điều để tìm hiểu về tính đồng thời của Swift và cách tận dụng nó trong SwiftUI, vì vậy chúng tôi đã chuẩn bị một vài cuộc nói chuyện khác để tìm hiểu chi tiết.

00:06:26.000 --> 00:06:35.000
"Khám phá tính đồng thời trong SwiftUI" sẽ giải thích cách đồng thời liên quan đến mô hình cập nhật của SwiftUI và giới thiệu một số tính năng mới mà chúng tôi vừa thảo luận.

00:06:35.000 --> 00:06:45.000
Và trong "Swift concurrency: Update a sample app", chúng tôi hướng dẫn bạn từng bước nâng cấp một dự án hiện có với mã mô hình không đồng bộ.

00:06:45.000 --> 00:06:51.000
Tiếp theo, chúng tôi sẽ cung cấp cho bạn những cách mới và tốt hơn để xây dựng tính tương tác vào nội dung danh sách của bạn.

00:06:51.000 --> 00:06:58.000
Trong ví dụ này, tôi đã viết một danh sách đơn giản để chia sẻ hướng dẫn đến nơi ẩn náu siêu bí mật của mình.

00:06:58.000 --> 00:07:00.000
Cái này trông đẹp, nhưng văn bản không thể chỉnh sửa được.

00:07:00.000 --> 00:07:02.000
Hãy sửa nó đi.

00:07:02.000 --> 00:07:07.000
Thay vào đó, chúng ta có thể chỉnh sửa văn bản bằng cách hoán đổi nó cho một trường văn bản.

00:07:07.000 --> 00:07:10.000
Tuy nhiên, một trường văn bản yêu cầu liên kết với văn bản.

00:07:10.000 --> 00:07:18.000
Trong phần đóng nội dung danh sách của chúng tôi, chúng tôi chỉ được cung cấp một giá trị đơn giản cho mỗi phần tử trong bộ sưu tập của mình, không phải ràng buộc.

00:07:18.000 --> 00:07:26.000
Trong những tình huống như thế này, có thể khó tìm ra cách liên kết với phần tử bộ sưu tập cho mỗi hàng.

00:07:26.000 --> 00:07:35.000
Thay vào đó, một cách tiếp cận phổ biến là lặp lại các chỉ số của bộ sưu tập, sử dụng chỉ số con để có được liên kết với phần tử tại chỉ mục đó.

00:07:35.000 --> 00:07:45.000
Tuy nhiên, kỹ thuật này không được khuyến khích, bởi vì SwiftUI sẽ buộc phải tải lại toàn bộ danh sách khi có bất kỳ thay đổi nào.

00:07:45.000 --> 00:07:50.000
Trên thực tế, chúng tôi đã chuẩn bị toàn bộ buổi nói chuyện thảo luận về chủ đề này chi tiết hơn nhiều.

00:07:50.000 --> 00:07:59.000
Để tìm hiểu thêm, tôi khuyên bạn nên xem "Demystify SwiftUI." Hiện tại, hãy hoàn tác những thay đổi này và xem xét một giải pháp tốt hơn.

00:07:59.000 --> 00:08:08.000
Năm nay, SwiftUI đang cung cấp một cách dễ dàng hơn nhiều để có quyền truy cập vào các ràng buộc cho các yếu tố riêng lẻ trong một bộ sưu tập.

00:08:08.000 --> 00:08:19.000
Chỉ cần chuyển một ràng buộc cho bộ sưu tập của bạn vào danh sách, sử dụng toán tử ký hiệu đô la thông thường và SwiftUI sẽ chuyển lại một ràng buộc cho từng phần tử riêng lẻ trong phần đóng.

00:08:19.000 --> 00:08:26.000
Mã chỉ cần đọc giá trị có thể giữ nguyên chính xác như trước đây, giống như bạn đã quen.

00:08:26.000 --> 00:08:40.000
Nhưng bây giờ chúng ta có thể dễ dàng thêm các điều khiển tương tác như trường văn bản bằng cách sử dụng cú pháp ràng buộc thông thường mà chúng ta đã quen, điều đó có nghĩa là cuối cùng tôi có thể điền vào mã cửa siêu bí mật mà tôi đã quên bao gồm trước đó.

00:08:40.000 --> 00:08:46.000
Cú pháp mới này là một phần của ngôn ngữ Swift, vì vậy nó hoạt động ở mọi nơi bạn mong đợi, không chỉ là danh sách.

00:08:46.000 --> 00:08:51.000
Ví dụ, thay vào đó, chúng ta có thể sử dụng cùng một kỹ thuật trong chế độ xem ForEach trong danh sách của mình.

00:08:51.000 --> 00:08:58.000
Và tốt hơn nữa, bạn thậm chí có thể triển khai lại mã này cho bất kỳ bản phát hành nào trước đó được SwiftUI hỗ trợ.

00:08:58.000 --> 00:09:01.000
Nhưng chúng tôi không chỉ làm cho mã hiện tại của bạn dễ viết hơn.

00:09:01.000 --> 00:09:04.000
Danh sách cũng đang đạt được một số tính năng mới tuyệt vời!

00:09:04.000 --> 00:09:08.000
Hãy bắt đầu với một số cách mới để tùy chỉnh trực quan danh sách của bạn.

00:09:08.000 --> 00:09:19.000
Với công cụ sửa đổi listRowSeparatorTint mới, bạn có thể thay đổi màu sắc của các dấu phân cách hàng riêng lẻ, như tôi đã làm ở đây để căn chỉnh dấu phân cách và màu biểu tượng cho mỗi hàng.

00:09:19.000 --> 00:09:23.000
SwiftUI cũng có một công cụ sửa đổi tương đương cho các dấu phân cách phần.

00:09:23.000 --> 00:09:27.000
Tuy nhiên, đối với ứng dụng này, tất cả các dấu phân cách đó có vẻ hơi mất tập trung.

00:09:27.000 --> 00:09:31.000
Tôi muốn hướng dẫn của mình cảm thấy như một dòng chảy thống nhất, duy nhất.

00:09:31.000 --> 00:09:39.000
Có lẽ chúng ta nên thử xóa chúng, điều mà bây giờ chúng ta có thể làm với công cụ sửa đổi listRowSeparator mới, định cấu hình các dấu phân cách của chúng ta bị ẩn.

00:09:39.000 --> 00:09:42.000
Bây giờ hướng dẫn của chúng tôi cảm thấy ít lộn xộn hơn nhiều.

00:09:42.000 --> 00:09:47.000
Hãy xem một ứng dụng khác mà tôi đang tạo...

00:09:47.000 --> 00:09:52.000
...Điều này giúp các tác giả truyện tranh theo dõi tất cả các siêu anh hùng và nhân vật phản diện của họ.

00:09:52.000 --> 00:10:02.000
Ứng dụng này sử dụng các thao tác vuốt để ghim và xóa các ký tự một cách nhanh chóng và thuận tiện, nhưng không làm lộn xộn giao diện người dùng của chúng tôi với các điều khiển bổ sung.

00:10:02.000 --> 00:10:09.000
Mới trong năm nay, SwiftUI cho phép bạn xác định các hành động vuốt hoàn toàn tùy chỉnh bằng cách sử dụng công cụ sửa đổi swipeActions mới.

00:10:09.000 --> 00:10:15.000
Bạn định cấu hình các hành động vuốt giống như bất kỳ loại menu nào khác trong SwiftUI, xác định các hành động bằng cách sử dụng các nút.

00:10:15.000 --> 00:10:22.000
Bạn cũng có thể tùy chỉnh màu sắc của chúng bằng cách thêm công cụ sửa đổi tông màu mới, mà tôi đang sử dụng để làm cho hành động ghim của mình có màu vàng.

00:10:22.000 --> 00:10:27.000
Theo mặc định, SwiftUI hiển thị các hành động vuốt ở cạnh sau của hàng.

00:10:27.000 --> 00:10:32.000
Nhưng bạn có thể chuyển chúng sang phía trước bằng cách sử dụng tham số cạnh của công cụ sửa đổi.

00:10:32.000 --> 00:10:40.000
Bạn thậm chí có thể hỗ trợ cả hành động vuốt đầu và cuối bằng cách thêm nhiều công cụ sửa đổi với các cấu hình cạnh khác nhau.

00:10:40.000 --> 00:10:49.000
Và cuối cùng, công cụ sửa đổi swipeActions có sẵn trên mọi nền tảng hỗ trợ chúng, giúp bạn dễ dàng chia sẻ mã trong ứng dụng đa nền tảng của mình.

00:10:49.000 --> 00:10:53.000
Nói về các nền tảng khác, hãy kiểm tra phiên bản macOS của ứng dụng của tôi.

00:10:53.000 --> 00:10:59.000
Nó hiển thị một giao diện nhiều cột, sử dụng thêm dung lượng có sẵn trên Mac.

00:10:59.000 --> 00:11:05.000
Thay vì nhồi nhét tất cả dữ liệu của tôi vào thanh bên, tôi có một tab tổng quan liệt kê tất cả các ký tự của tôi.

00:11:05.000 --> 00:11:09.000
Điều đó cho phép tôi chỉ cần giữ các ký tự được ghim của mình trong thanh bên.

00:11:09.000 --> 00:11:11.000
Tuy nhiên, danh sách này có cảm giác hơi đơn giản.

00:11:11.000 --> 00:11:13.000
Hãy thử làm mới nó một chút.

00:11:13.000 --> 00:11:15.000
Đây là mã hiện có của tôi.

00:11:15.000 --> 00:11:20.000
Tôi hiện đang sử dụng kiểu danh sách chèn để phù hợp với danh sách trong cửa sổ của mình một cách trơn tru.

00:11:20.000 --> 00:11:29.000
Và chúng tôi có thể thể hiện phong cách này một cách đẹp mắt trong mã bằng cách sử dụng cú pháp giống như enum mới có sẵn trên tất cả các kiểu xem trong năm nay.

00:11:29.000 --> 00:11:33.000
Cũng mới trong năm nay, phong cách danh sách bên trong đang đạt được một thủ thuật mới.

00:11:33.000 --> 00:11:41.000
Bây giờ nó có thể thay thế nền của các hàng bằng cách chỉ cần sửa đổi kiểu với cờ alternatesRowBackgrounds.

00:11:41.000 --> 00:11:46.000
Danh sách của chúng tôi hiện đang trông đẹp hơn rất nhiều, với mỗi hàng được phân biệt rõ ràng với hàng kia.

00:11:46.000 --> 00:11:53.000
Nhưng đối với một ứng dụng macOS, vẫn có cảm giác như chúng tôi không tận dụng tối đa không gian đó trong cửa sổ của mình.

00:11:53.000 --> 00:11:58.000
Vì vậy, đối với phần tiếp theo, hãy vượt ra ngoài danh sách để tận dụng tối đa ứng dụng của bạn.

00:11:58.000 --> 00:12:05.000
Để giúp chúng tôi tận dụng tốt hơn tất cả không gian này, hãy nâng cấp danh sách của chúng tôi lên một bảng nhiều cột phong phú!

00:12:05.000 --> 00:12:09.000
Với bốn cột, bây giờ tôi nhận được bốn danh sách với giá của một!

00:12:09.000 --> 00:12:18.000
Nhưng phần tốt nhất là một bảng phức tạp vừa phải như thế này có thể được khai báo với rất ít mã, nó phù hợp với một trang chiếu duy nhất.

00:12:18.000 --> 00:12:23.000
Đó là bởi vì các bảng sử dụng cùng một loại cấu trúc khai báo mà bạn đã quen trong SwiftUI.

00:12:23.000 --> 00:12:28.000
Cũng giống như với danh sách, bạn có thể tạo một bảng từ một bộ sưu tập nội dung duy nhất.

00:12:28.000 --> 00:12:36.000
Nhưng không giống như một danh sách, một bảng được tạo thành từ TableColumns xác định nội dung trong mỗi cột trực quan.

00:12:36.000 --> 00:12:46.000
Mỗi cột này được gắn nhãn trực quan và sử dụng dữ liệu từ bộ sưu tập để xác định nội dung trực quan của chúng với một số tiện ích tốc ký cho các trường hợp phổ biến như chỉ hiển thị văn bản.

00:12:46.000 --> 00:12:56.000
Nhưng các bảng cũng có tính tương tác, hỗ trợ lựa chọn hàng cho cả hàng đơn và nhiều hàng, giống như trong danh sách thông thường.

00:12:56.000 --> 00:13:02.000
Các bảng cũng hỗ trợ sắp xếp với sự trợ giúp của các đường dẫn chính đến các giá trị có thể sắp xếp trên các cột.

00:13:02.000 --> 00:13:10.000
Giờ đây, các bảng hỗ trợ một số tính năng khác, bao gồm nhiều phong cách hình ảnh khác nhau cũng như tinh chỉnh giao diện của mỗi cột.

00:13:10.000 --> 00:13:14.000
Nhưng hãy nói nhiều hơn về dữ liệu bạn cung cấp cho một bảng hoặc danh sách.

00:13:14.000 --> 00:13:19.000
Năm nay, chúng tôi có một số cải tiến mới đối với sự hỗ trợ của SwiftUI cho các yêu cầu tìm nạp CoreData.

00:13:19.000 --> 00:13:33.000
FetchRequests hiện cung cấp một ràng buộc cho các bộ mô tả sắp xếp của chúng, mà chúng ta có thể chuyển đến Bảng, cho phép chúng ta viết một bảng hoàn toàn dựa trên Dữ liệu Cốt lõi, hoàn chỉnh với các cột lựa chọn và có thể sắp xếp, chỉ trong một vài dòng mã.

00:13:33.000 --> 00:13:44.000
SwiftUI hiện cũng cung cấp một yêu cầu tìm nạp theo từng phần, cho phép các danh sách phức tạp, đa phần như danh sách bên phải được điều khiển từ một yêu cầu duy nhất.

00:13:44.000 --> 00:13:49.000
Trong ví dụ này, chúng tôi phân chia dữ liệu của mình thành các phần dựa trên việc chúng có được ghim hay không.

00:13:49.000 --> 00:14:00.000
Chúng tôi sử dụng nhiều SortDescriptors để sắp xếp dữ liệu, đầu tiên để chia nó thành các phần được ghim và không ghim, và thứ hai để sắp xếp các ký tự được sửa đổi gần đây cuối cùng.

00:14:00.000 --> 00:14:03.000
Tiếp theo chúng tôi chỉ định rằng bất kỳ thay đổi nào cũng nên được hoạt hình.

00:14:03.000 --> 00:14:12.000
Và cuối cùng chúng tôi xây dựng các phần và hàng trong danh sách của mình một cách linh hoạt, dựa trên kết quả của yêu cầu.

00:14:12.000 --> 00:14:18.000
Tất cả cùng nhau, yêu cầu duy nhất này có thể điều khiển danh sách hoạt hình ở bên phải.

00:14:18.000 --> 00:14:28.000
Để biết thêm thông tin về việc xây dựng ứng dụng cho macOS, làm việc với các bảng và tích hợp Dữ liệu cốt lõi với SwiftUI, hãy nhớ xem các cuộc nói chuyện khác này.

00:14:28.000 --> 00:14:35.000
Loạt bài gồm hai phần "SwiftUI trên Mac" sẽ hướng dẫn bạn từng bước xây dựng một ứng dụng được tối ưu hóa cho Mac.

00:14:35.000 --> 00:14:44.000
Và "Mang dữ liệu cốt lõi đồng thời đến Swift và SwiftUI" sẽ bao gồm các API yêu cầu tìm nạp Dữ liệu cốt lõi mới chi tiết hơn nhiều.

00:14:44.000 --> 00:14:50.000
Bây giờ là lúc lùi lại và suy nghĩ về cách chúng tôi có thể giúp người dùng tìm thấy những gì họ cần giữa tất cả dữ liệu này.

00:14:50.000 --> 00:14:54.000
Tất nhiên, tôi đang nói về tìm kiếm.

00:14:54.000 --> 00:14:57.000
Tìm kiếm là một phần quan trọng trong tất cả các nền tảng của chúng tôi.

00:14:57.000 --> 00:15:01.000
Nó giúp người dùng tìm thấy chính xác những gì họ cần khi họ cần.

00:15:01.000 --> 00:15:08.000
Bạn sẽ tìm thấy nó trên các thiết bị lớn như Apple TV, thậm chí cho đến các thiết bị nhỏ nhất, như Apple Watch.

00:15:08.000 --> 00:15:16.000
Vì vậy, vì tìm kiếm là một vấn đề đa nền tảng, nó cần một giải pháp đa nền tảng có thể mở rộng trên tất cả các thiết bị này.

00:15:16.000 --> 00:15:24.000
May mắn thay, việc thêm tìm kiếm vào ứng dụng của bạn không thể dễ dàng hơn; chỉ cần thêm công cụ sửa đổi có thể tìm kiếm, như chúng tôi đã làm ở đây trên NavigationView của mình.

00:15:24.000 --> 00:15:35.000
Với một công cụ sửa đổi này, SwiftUI sẽ tự động thêm trường tìm kiếm vào vị trí thích hợp trong ứng dụng của bạn và tùy chọn hiển thị các đề xuất theo cách phù hợp với nền tảng và ngữ cảnh.

00:15:35.000 --> 00:15:41.000
Công cụ sửa đổi có liên kết với văn bản tìm kiếm, cho phép bạn lọc dữ liệu của mình dựa trên giá trị hiện tại.

00:15:41.000 --> 00:15:51.000
Bây giờ, có rất nhiều điều để nói về tìm kiếm trong SwiftUI, nhưng may mắn thay, chúng tôi có cả một phiên để hướng dẫn bạn cách suy nghĩ về khả năng tìm kiếm trên nhiều nền tảng.

00:15:51.000 --> 00:15:55.000
Kiểm tra "Trải nghiệm tìm kiếm thủ công trong SwiftUI" để tìm hiểu thêm.

00:15:55.000 --> 00:16:04.000
Cho đến nay, chúng tôi đã khám phá cách tải, hiển thị, sắp xếp và tìm kiếm thông qua dữ liệu ứng dụng của bạn bằng cách sử dụng danh sách và lưới.

00:16:04.000 --> 00:16:08.000
Bây giờ hãy nói về cách chia sẻ dữ liệu đó ngoài ứng dụng của bạn.

00:16:08.000 --> 00:16:13.000
Một trong những phương pháp chia sẻ dữ liệu đơn giản nhất là chỉ cần kéo nó ra khỏi ứng dụng của bạn.

00:16:13.000 --> 00:16:21.000
Trong ứng dụng Heroes &amp; Villains của tôi, tôi đã định cấu hình biểu tượng nhân vật trên màn hình chi tiết để có thể kéo được bằng cách sử dụng công cụ sửa đổi onDrag hiện có.

00:16:21.000 --> 00:16:26.000
Mới trong năm nay, bây giờ bạn có thể thêm các bản xem trước tùy chỉnh vào chế độ xem có thể kéo của mình.

00:16:26.000 --> 00:16:32.000
Bản xem trước này được hiển thị thay vì chế độ xem trong khi nó đang được kéo.

00:16:32.000 --> 00:16:39.000
Kéo và thả được cung cấp bởi các nhà cung cấp vật phẩm, cho phép sao chép và chia sẻ dữ liệu giữa các quy trình khác nhau.

00:16:39.000 --> 00:16:57.000
Năm nay, SwiftUI đang cung cấp thêm một số cách để sử dụng các nhà cung cấp mặt hàng để tích hợp với các ứng dụng và dịch vụ khác như định cấu hình ứng dụng của bạn để hỗ trợ nhập các nhà cung cấp mặt hàng từ các dịch vụ bên ngoài, sử dụng công cụ sửa đổi importsItemProviders mới.

00:16:57.000 --> 00:17:05.000
Trong ví dụ này, chúng tôi đã định cấu hình chế độ xem của mình để có thể nhập hình ảnh và thêm chúng dưới dạng tệp đính kèm cho các nhân vật câu chuyện của chúng tôi.

00:17:05.000 --> 00:17:11.000
Chúng ta có thể ghép nối khả năng này với tính năng macOS mới: Continuity Camera.

00:17:11.000 --> 00:17:21.000
Bằng cách thêm các lệnh "Nhập từ Thiết bị" vào menu chính của ứng dụng, giờ đây chúng tôi có thể sử dụng iPhone hoặc iPad để chỉ chụp ảnh để nhập vào ứng dụng Mac của mình.

00:17:21.000 --> 00:17:23.000
Hãy thử nó đi!

00:17:23.000 --> 00:17:26.000
Biểu tượng của siêu anh hùng View Builder là chiếc búa đáng tin cậy của cô ấy.

00:17:26.000 --> 00:17:30.000
Sẽ thật tuyệt nếu đính kèm một bức ảnh của nó vào hồ sơ của cô ấy.

00:17:30.000 --> 00:17:34.000
May mắn thay, tôi tình cờ có nó ngay tại đây!

00:17:34.000 --> 00:17:42.000
Từ bên trong ứng dụng của mình, tôi có thể truy cập các lệnh "Nhập từ thiết bị" trong menu Tệp.

00:17:42.000 --> 00:17:49.000
Sau đó, tôi có thể chọn chụp ảnh bằng iPhone của mình...

00:17:49.000 --> 00:17:56.000
....Tự động mở ứng dụng Camera để chúng ta có thể nhanh chóng chụp ảnh.

00:17:56.000 --> 00:18:03.000
Và ảnh mới được nhập và thêm vào ứng dụng của tôi, sử dụng công cụ sửa đổi importsItemProviders mà chúng tôi đã trình bày trước đó.

00:18:03.000 --> 00:18:07.000
SwiftUI cũng hỗ trợ xuất dữ liệu ra khỏi ứng dụng của chúng tôi.

00:18:07.000 --> 00:18:15.000
Xuất dữ liệu cho phép bạn tận dụng các dịch vụ khác, chẳng hạn như có thể kích hoạt các phím tắt trực tiếp trong ứng dụng của bạn.

00:18:15.000 --> 00:18:20.000
Trong SwiftUI, bạn có thể xuất dữ liệu bằng cách sử dụng công cụ sửa đổi exportsItemProviders mới.

00:18:20.000 --> 00:18:28.000
Điều này hiển thị dữ liệu ứng dụng của bạn cho phần còn lại của hệ thống, ví dụ, cho phép nó được sử dụng bởi các dịch vụ và phím tắt trên macOS.

00:18:28.000 --> 00:18:33.000
Hãy cùng xem điều này xuất hiện như thế nào đối với những người sử dụng ứng dụng.

00:18:33.000 --> 00:18:39.000
Bây giờ tôi có thể thấy các hành động nhanh hiển thị trong menu Dịch vụ của ứng dụng khi tôi đã chọn một trong các ký tự được ghim của mình.

00:18:39.000 --> 00:18:48.000
Đây là một phím tắt tiện dụng để thêm biểu ngữ tiêu đề vào bức ảnh gần đây nhất, mà tôi có thể sử dụng để chia sẻ những ý tưởng siêu anh hùng mới nhất của mình với bạn bè.

00:18:48.000 --> 00:18:54.000
Tôi đã tìm thấy bức ảnh tuyệt vời này để sử dụng cho siêu anh hùng Stylizer của mình, người cũng là một chú chó đáng yêu.

00:18:54.000 --> 00:19:00.000
Phím tắt tùy chỉnh của tôi đã thêm biểu ngữ vui nhộn này lên trên cùng và phủ tên của anh hùng.

00:19:00.000 --> 00:19:02.000
Phím tắt của tôi cũng cho phép tôi chia sẻ bức ảnh.

00:19:02.000 --> 00:19:07.000
Tôi rất muốn nhận được phản hồi của Taylor, vì anh ấy biết một hoặc hai điều về đồ họa tuyệt vời.

00:19:07.000 --> 00:19:15.000
Tôi chỉ có thể thêm Taylor làm người nhận và nhập một tin nhắn nhanh và gửi nó đi!

00:19:15.000 --> 00:19:17.000
Bạn nghĩ sao, Taylor?

00:19:17.000 --> 00:19:19.000
Taylor Kelly: Cảm ơn bạn, Matt. Nó trông thật hoàn hảo.

00:19:19.000 --> 00:19:22.000
Và nó chắc chắn sẽ là ảnh liên lạc mới của bạn.

00:19:22.000 --> 00:19:26.000
Hình ảnh đáng yêu này là một sự chuyển tiếp tuyệt vời cho phần tiếp theo, Đồ họa nâng cao.

00:19:26.000 --> 00:19:33.000
Có một loạt các cải tiến thú vị trong năm nay: từ cập nhật biểu tượng, vật liệu và sự sống động, đến chế độ xem canvas mới mạnh mẽ.

00:19:33.000 --> 00:19:34.000
Đầu tiên là các biểu tượng.

00:19:34.000 --> 00:19:39.000
Biểu tượng SF là một cách tuyệt vời và dễ dàng để thêm biểu tượng đẹp trong ứng dụng của bạn.

00:19:39.000 --> 00:19:46.000
Không chỉ có nhiều cái mới trong năm nay, mà chúng còn đi kèm với một số tính năng mới để giúp việc sử dụng chúng trong ứng dụng của bạn trở nên dễ dàng và biểu cảm hơn.

00:19:46.000 --> 00:19:51.000
Có hai chế độ kết xuất mới cho phép bạn kiểm soát nhiều hơn cách tạo kiểu biểu tượng.

00:19:51.000 --> 00:20:02.000
Phân cấp sử dụng kiểu tiền cảnh hiện tại để tô màu biểu tượng, giống như đơn sắc, nhưng tự động thêm nhiều cấp độ mờ để thực sự nhấn mạnh các yếu tố chính của biểu tượng.

00:20:02.000 --> 00:20:08.000
Và bảng màu cung cấp cho bạn quyền kiểm soát chi tiết hơn nữa đối với các lớp riêng lẻ của biểu tượng với các lần tô tùy chỉnh.

00:20:08.000 --> 00:20:13.000
Kiểm tra "Có gì mới trong Biểu tượng SF" để biết thêm thông tin và hướng dẫn thiết kế về các chế độ mới này.

00:20:13.000 --> 00:20:17.000
Kết hợp hoàn hảo với những thứ này là bản cập nhật cho bộ màu có sẵn trong SwiftUI.

00:20:17.000 --> 00:20:26.000
Những màu này được tối ưu hóa cho tất cả các cấu hình khác nhau mà chúng xuất hiện: Chế độ sáng và tối, giao diện cụ thể trên các vết mờ và thậm chí cả nền tảng cụ thể mà chúng được hiển thị.

00:20:26.000 --> 00:20:30.000
Ngoài các màu sắc khác nhau, các biểu tượng có nhiều hình dạng khác nhau.

00:20:30.000 --> 00:20:34.000
Nhiều biểu tượng có công cụ sửa đổi để hiển thị dưới dạng điền, khoanh tròn và hơn thế nữa.

00:20:34.000 --> 00:20:36.000
Trước đây bạn phải mã hóa cứng các biến thể này.

00:20:36.000 --> 00:20:41.000
Nhưng hơn thế nữa, bạn phải biết biến thể nào đúng để sử dụng trong bối cảnh nào.

00:20:41.000 --> 00:20:50.000
Nguyên tắc giao diện con người iOS mô tả cách trong các thanh tab, các biến thể đã điền nên được ưu tiên, vì vậy bạn phải bao gồm cụ thể công cụ sửa đổi .fill đó trong tên.

00:20:50.000 --> 00:20:52.000
Năm nay, bạn không phải lo lắng về điều đó.

00:20:52.000 --> 00:20:56.000
SwiftUI sẽ tự động chọn biến thể phù hợp với bạn dựa trên ngữ cảnh bạn sử dụng nó.

00:20:56.000 --> 00:21:00.000
Tất cả những gì bạn phải làm là cung cấp biểu tượng cơ sở mà bạn muốn sử dụng.

00:21:00.000 --> 00:21:06.000
Và bằng cách không xác định quá mức cấu hình chính xác mà bạn muốn, bạn cũng nhận được mã có thể tái sử dụng nhiều hơn.

00:21:06.000 --> 00:21:13.000
Ví dụ, nếu chúng ta chạy cùng một mã này trên macOS, chúng ta sẽ nhận được biến thể chính xác cho nền tảng đó: phác thảo.

00:21:13.000 --> 00:21:21.000
Để tìm hiểu cách tận dụng sự hỗ trợ tự động này trong chế độ xem tùy chỉnh của riêng bạn, cũng như nhiều cải tiến biểu tượng hơn, hãy xem "Biểu tượng SF trong SwiftUI".

00:21:21.000 --> 00:21:26.000
Hiện tại có rất nhiều Biểu tượng SF, vì vậy tôi muốn xây dựng một trình hiển thị thú vị để duyệt qua tất cả chúng.

00:21:26.000 --> 00:21:30.000
Đây là một cách sử dụng tuyệt vời cho chế độ xem Canvas mới của SwiftUI.

00:21:30.000 --> 00:21:34.000
Canvas hỗ trợ vẽ chế độ ngay lập tức tương tự như drawRect từ UIKit hoặc AppKit.

00:21:34.000 --> 00:21:41.000
Khi soạn nhiều yếu tố đồ họa không cần theo dõi hoặc vô hiệu hóa riêng lẻ, đây là một công cụ tuyệt vời.

00:21:41.000 --> 00:21:45.000
Ở đây tôi có một khung vẽ hiển thị mọi Biểu tượng SF đi kèm với hệ điều hành.

00:21:45.000 --> 00:21:50.000
Và đối với tất cả 3166 người trong số họ, nó thu hút mỗi người trong số họ vào khung của riêng họ.

00:21:50.000 --> 00:21:52.000
Canvas hoạt động trên mọi nền tảng.

00:21:52.000 --> 00:22:03.000
Và vì Canvas là một chế độ xem giống như bất kỳ chế độ xem nào khác, chúng tôi cũng có thể đính kèm cử chỉ, thông tin khả năng truy cập và cập nhật nó dựa trên trạng thái hoặc môi trường như thích ứng với Chế độ tối.

00:22:03.000 --> 00:22:07.000
Ở đây, tôi đã thêm một cử chỉ cho phép tôi đặt tiêu điểm để phóng to.

00:22:07.000 --> 00:22:11.000
Và tôi sẽ cập nhật khung và độ mờ đục của mỗi biểu tượng dựa trên điều đó.

00:22:11.000 --> 00:22:18.000
Bây giờ tôi có thể nhấp và kéo xung quanh và mọi biểu tượng cập nhật trơn tru khi con trỏ di chuyển xung quanh màn hình.

00:22:18.000 --> 00:22:23.000
Chúng tôi cũng có thể đảm bảo rằng điều này hoàn toàn có thể truy cập được bằng cách tận dụng công cụ sửa đổi accessibilityChildren mới.

00:22:23.000 --> 00:22:31.000
Điều thú vị là bạn sử dụng lại các chế độ xem giống nhau mà bạn đã sử dụng trong SwiftUI để tinh chỉnh cách nó xuất hiện thông qua các tính năng trợ năng.

00:22:31.000 --> 00:22:39.000
Trong trường hợp này, các biểu tượng bây giờ có thể được liệt kê giống như ai đó sẽ duyệt qua các phần tử trong danh sách, nói từng phần tử khi chúng điều hướng qua.

00:22:39.000 --> 00:22:46.000
Công cụ sửa đổi này không chỉ giới hạn ở Canvas, nhưng có thể được sử dụng với bất kỳ chế độ xem nào để thực sự đánh bóng trải nghiệm khả năng tiếp cận của nó.

00:22:46.000 --> 00:22:52.000
Một điều cuối cùng chúng tôi có thể thêm vào khung vẽ của mình là cập nhật theo thời gian, sử dụng TimelineView mới.

00:22:52.000 --> 00:22:58.000
Một sự tinh chỉnh để thực hiện cho tvOS là để tiêu điểm đó di chuyển một cách hoạt hình xung quanh màn hình, hoạt động giống như một trình bảo vệ màn hình.

00:22:58.000 --> 00:23:05.000
TimelineView được tạo ra với một lịch trình - trong trường hợp này là lịch trình hoạt hình - và nó cung cấp thời gian hiển thị hiện tại.

00:23:05.000 --> 00:23:11.000
Và vì vậy chúng ta có thể sử dụng thời gian đó để cập nhật tiêu điểm trong quá trình chuyển đổi, tạo ra trình bảo vệ màn hình biểu tượng tuyệt đẹp của chúng ta.

00:23:11.000 --> 00:23:14.000
Chế độ xem dòng thời gian này có thể làm được nhiều hơn thế.

00:23:14.000 --> 00:23:17.000
Một tính năng thực sự thú vị của Apple Watch là nó luôn hiển thị.

00:23:17.000 --> 00:23:22.000
Trước đây, ứng dụng của bạn sẽ bị mờ với thời gian được phủ lên khi nó chuyển sang trạng thái Luôn Bật.

00:23:22.000 --> 00:23:32.000
Và với watchOS 8, ứng dụng của bạn hiện mờ dần theo mặc định và bạn có nhiều quyền kiểm soát hơn đối với cách nó xuất hiện với SwiftUI cung cấp cho bạn các công cụ bạn cần, một trong số đó là TimelineView.

00:23:32.000 --> 00:23:39.000
Khi đồng hồ chuyển sang trạng thái Luôn Bật, TimelineView có thể tải trước màn hình hiển thị chế độ xem của bạn vào những ngày trong tương lai.

00:23:39.000 --> 00:23:46.000
Và khi chúng ta tiến tới tương lai, những chế độ xem đó sẽ tự động được hiển thị trên màn hình mà không bao giờ lấy ứng dụng của bạn từ nền.

00:23:46.000 --> 00:23:49.000
Một phần quan trọng của việc này là Lịch trình Dòng thời gian.

00:23:49.000 --> 00:23:59.000
Trong ví dụ này, tôi đang sử dụng lịch trình everyMinute đơn giản để TimelineView sẽ tải trước màn hình của mỗi phút trên phút, hiển thị cho tôi biểu tượng tiếp theo trong trình duyệt.

00:23:59.000 --> 00:24:09.000
Có một số loại lịch trình khác cũng như để giúp phù hợp với nhu cầu của ứng dụng của bạn, chẳng hạn như một bộ sưu tập các ngày rõ ràng, hoạt động tốt khi sẽ có các sự kiện vào những thời điểm cụ thể.

00:24:09.000 --> 00:24:15.000
Bây giờ, một khía cạnh quan trọng khác của chế độ này là ẩn thông tin nhạy cảm với người dùng vì nó có thể hiển thị với những người khác.

00:24:15.000 --> 00:24:17.000
Tôi thực sự muốn giữ riêng tư biểu tượng yêu thích của mình.

00:24:17.000 --> 00:24:24.000
Và chỉ cần thêm công cụ sửa đổi privacySensitive, nó sẽ tự động được chỉnh sửa lại khi đồng hồ chuyển sang trạng thái Luôn Bật.

00:24:24.000 --> 00:24:29.000
Kiểm tra "Có gì mới trong watchOS 8" để biết thêm thông tin về màn hình Luôn Bật và hơn thế nữa.

00:24:29.000 --> 00:24:33.000
Và công cụ sửa đổi nhạy cảm với quyền riêng tư này cũng hoạt động trong các tiện ích.

00:24:33.000 --> 00:24:42.000
Các tiện ích được thêm vào màn hình Khóa sẽ sử dụng điều này để ẩn thông tin nhạy cảm trong khi thiết bị vẫn bị khóa và hiển thị khi thiết bị được mở khóa.

00:24:42.000 --> 00:24:48.000
"Nguyên tắc của các tiện ích tuyệt vời" sẽ đi vào chi tiết hơn về điều này và các cách khác để xây dựng các tiện ích tuyệt vời cho ứng dụng của bạn.

00:24:48.000 --> 00:24:58.000
Tài liệu được sử dụng trên tất cả các nền tảng và ứng dụng của Apple để tạo ra các hiệu ứng hình ảnh đẹp mắt thực sự nhấn mạnh nội dung của chúng và bây giờ bạn có thể tạo chúng trực tiếp trong SwiftUI!

00:24:58.000 --> 00:25:06.000
Tôi đã thử nghiệm thêm màu sắc và vật liệu vào Trình duyệt Biểu tượng của mình và tôi đang thêm lớp phủ được hỗ trợ bởi vật liệu để hiển thị số lượng biểu tượng.

00:25:06.000 --> 00:25:09.000
Thêm một tài liệu dễ dàng như thêm một nền.

00:25:09.000 --> 00:25:14.000
Tôi đang sử dụng ultraThinMaterial, và có thể cung cấp cho nó bất kỳ hình dạng tùy chỉnh nào để lấp đầy.

00:25:14.000 --> 00:25:23.000
Những tài liệu này tự động đi kèm với sự pha trộn sôi động như mong đợi của nội dung bên trên chúng khi sử dụng các phong cách sơ cấp, trung học, đại học và bây giờ thậm chí là tiền cảnh bậc bốn.

00:25:23.000 --> 00:25:29.000
Và biểu tượng cảm xúc được tự động loại trừ khỏi điều đó, vì vậy chúng trông chính xác như bình thường.

00:25:29.000 --> 00:25:39.000
Trên Mac, bối cảnh hệ thống như thanh bên và cửa sổ bật lên tự động có nền vật liệu mờ và giờ đây cũng sẽ có giao diện sống động như mong đợi cho nội dung bên trong chúng.

00:25:39.000 --> 00:25:50.000
Những tài liệu mới này hoạt động tốt khi kết hợp với công cụ sửa đổi safeAreaInset mới, cho phép bạn đặt nội dung lên trên chế độ xem có thể cuộn và vị trí nội dung vẫn bắt đầu và kết thúc như mong đợi.

00:25:50.000 --> 00:25:55.000
Phiên "đồ họa phong phú" đi sâu vào chi tiết hơn rất nhiều trên vải, vật liệu và hơn thế nữa.

00:25:55.000 --> 00:26:03.000
Và để kết thúc nó, bổ sung các cách mới để xác định các chế độ xem tùy chỉnh tuyệt đẹp này là một vài cải tiến đối với các bản xem trước SwiftUI trong Xcode.

00:26:03.000 --> 00:26:14.000
Đầu tiên là một công cụ sửa đổi định hướng xem trước mới cho phép bạn chỉ định hướng của thiết bị iOS trong các bản xem trước và thậm chí trộn và kết hợp các bản xem trước trên các hướng khác nhau.

00:26:14.000 --> 00:26:19.000
Và thứ hai là một cải tiến lớn đối với cách bạn chỉnh sửa và xem khả năng truy cập ứng dụng của mình trong các bản xem trước.

00:26:19.000 --> 00:26:27.000
Trình chỉnh sửa tài sản hiện có một danh sách được sắp xếp các công cụ sửa đổi khả năng truy cập, giúp việc đánh bóng hành vi khả năng truy cập của chế độ xem trở nên dễ dàng hơn.

00:26:27.000 --> 00:26:32.000
Và có một cách hoàn toàn mới để xem bản xem trước của bạn với tab Xem trước Trợ năng mới.

00:26:32.000 --> 00:26:38.000
Bạn sẽ được hiển thị một đại diện trực tiếp, văn bản của các yếu tố khả năng tiếp cận và các thuộc tính của chúng.

00:26:38.000 --> 00:26:45.000
Đây là thông tin tương tự cung cấp các tính năng trợ năng, nhưng hiện được trình bày cho bạn ở định dạng có thể quen thuộc hơn với bạn.

00:26:45.000 --> 00:26:53.000
Kiểm tra phiên "Truy cập SwiftUI" để biết thêm thông tin về điều này và nhiều hơn nữa về cách tạo trải nghiệm khả năng truy cập tuyệt vời cho ứng dụng của bạn!

00:26:53.000 --> 00:27:00.000
Bây giờ, tiếp theo là một loạt các cải tiến đối với văn bản, các điều khiển liên quan đến văn bản và điều hướng bàn phím.

00:27:00.000 --> 00:27:02.000
Văn bản rất cơ bản cho mọi ứng dụng.

00:27:02.000 --> 00:27:07.000
Đó là một trong những cách chính mà ứng dụng của bạn giao tiếp với mọi người; nó thường là chế độ xem đầu tiên bạn viết.

00:27:07.000 --> 00:27:15.000
Và năm nay, nó đã đạt được rất nhiều tính năng thú vị mới từ kiểu dáng đến bản địa hóa, đến tương tác và định dạng.

00:27:15.000 --> 00:27:18.000
Đầu tiên là hỗ trợ Markdown.

00:27:18.000 --> 00:27:21.000
Văn bản bây giờ có thể chứa định dạng Markdown trực tiếp nội tuyến.

00:27:21.000 --> 00:27:31.000
Điều này có thể được sử dụng để thêm sự nhấn mạnh mẽ, các liên kết - có thể được tương tác với - và thậm chí cả bản trình bày kiểu mã.

00:27:31.000 --> 00:27:36.000
Và tất cả điều này được xây dựng dựa trên AttributedString mới, mạnh mẽ dựa trên Swift trong Foundation.

00:27:36.000 --> 00:27:47.000
Ngoài hỗ trợ Markdown, nó còn mang đến toàn bộ bộ các thuộc tính phong phú, an toàn kiểu và khả năng xác định các thuộc tính của riêng bạn và thậm chí sử dụng chúng trong cú pháp Markdown.

00:27:47.000 --> 00:27:53.000
Để biết thêm thông tin về điều này và thỏa thuận Ngữ pháp Tự động mới tuyệt vời, hãy xem "Có gì mới trong Nền tảng."

00:27:53.000 --> 00:27:58.000
Quan trọng hơn, văn bản cũng bản địa hóa nội dung của nó để mọi người trên khắp thế giới có thể sử dụng ứng dụng của bạn.

00:27:58.000 --> 00:28:05.000
Và điều này cũng đúng với hỗ trợ Markdown mới, cho phép các thuộc tính nhạy cảm với ngôn ngữ được bản địa hóa đúng cách.

00:28:05.000 --> 00:28:09.000
Một cải tiến tuyệt vời khác cho bản địa hóa đến từ Xcode 13.

00:28:09.000 --> 00:28:20.000
Bây giờ nó sử dụng trình biên dịch Swift để tạo các chuỗi và danh mục bản địa hóa từ mọi lần sử dụng LocalizedStringKey và các trình khởi tạo localizedString và attributedString mới.

00:28:20.000 --> 00:28:26.000
Để tìm hiểu thêm về điều này và các mẹo và thủ thuật bản địa hóa khác, hãy xem "Nội địa hóa ứng dụng SwiftUI của bạn".

00:28:26.000 --> 00:28:32.000
Bây giờ, ngoài những cách hiển thị văn bản mới này, còn có những cách mới để làm cho văn bản trở nên năng động hơn.

00:28:32.000 --> 00:28:35.000
Đầu tiên là một tính năng tiếp cận quan trọng: Loại động.

00:28:35.000 --> 00:28:47.000
SwiftUI đã hỗ trợ Dynamic Type kể từ khi thành lập và năm nay có một API mới cho phép hạn chế phạm vi kích thước loại mà giao diện người dùng hỗ trợ để giữ cho nó không quá lớn hoặc quá nhỏ.

00:28:47.000 --> 00:28:50.000
Điều này cho thấy tiêu đề của chúng tôi trông như thế nào ở kích thước lớn mặc định.

00:28:50.000 --> 00:29:02.000
Cá nhân tôi sử dụng Dynamic Type để có thêm mật độ thông tin vào nội dung của mình và điều này cho thấy tiêu đề vẫn giữ nguyên kích thước ở kích thước loại nhỏ như thế nào, vì nó bị giới hạn ở mức tối thiểu là kích thước lớn.

00:29:02.000 --> 00:29:11.000
Ở đầu kia của quang phổ, việc sử dụng kích thước khả năng tiếp cận dẫn đến tiêu đề của chúng tôi phát triển lớn hơn, nhưng chỉ lên đến kích thước cực lớn.

00:29:11.000 --> 00:29:18.000
Mặc dù macOS không hỗ trợ Dynamic Type, nhưng nó hỗ trợ một tương tác văn bản quan trọng khác: văn bản có thể lựa chọn.

00:29:18.000 --> 00:29:25.000
Điều này cho phép mọi người thực hiện hành động trên văn bản không thể chỉnh sửa từ ứng dụng của bạn và hiện có thể được bật bằng cách sử dụng công cụ sửa đổi textSelection.

00:29:25.000 --> 00:29:33.000
Công cụ sửa đổi đó có thể được áp dụng cho bất kỳ chế độ xem nào và nó áp dụng cho tất cả văn bản bên trong nó - trong ví dụ này, bây giờ áp dụng cho văn bản trong tiêu đề.

00:29:33.000 --> 00:29:40.000
Và chúng tôi cũng đã giới thiệu công cụ sửa đổi này trên iOS và iPadOS, nơi nó cho phép văn bản được sao chép hoặc chia sẻ trên báo chí dài.

00:29:40.000 --> 00:29:48.000
Cuối cùng, các API kiểu định dạng mới của Foundation giúp việc định dạng văn bản đơn giản hơn rất nhiều, nhưng vẫn cho phép trình bày chính xác.

00:29:48.000 --> 00:29:51.000
Ở đây chúng ta có một ngày áp dụng định dạng mặc định.

00:29:51.000 --> 00:29:56.000
Và đây là một biến thể chỉ hiển thị thời gian, như được sử dụng trong danh sách hoạt động.

00:29:56.000 --> 00:30:01.000
Và cuối cùng, một định dạng mở rộng cho phép chỉ định các thành phần chính xác để hiển thị.

00:30:01.000 --> 00:30:07.000
Danh sách hoạt động của chúng tôi cũng giới thiệu định dạng một mảng người thành một bài thuyết trình được bản địa hóa đúng cách.

00:30:07.000 --> 00:30:09.000
Hãy nhanh chóng xem qua điều này.

00:30:09.000 --> 00:30:17.000
Chúng tôi đang ánh xạ các giá trị người của mình vào một mảng PersonNameComponents và định dạng nó bằng cách sử dụng kiểu định dạng danh sách.

00:30:17.000 --> 00:30:24.000
Và đối với mỗi thành viên trong danh sách, sử dụng định dạng PersonNameComponent với kiểu ngắn, chỉ hiển thị tên đầu tiên.

00:30:24.000 --> 00:30:27.000
Và cuối cùng, tham gia nó với một sự kết hợp "và".

00:30:27.000 --> 00:30:34.000
Tất cả cùng nhau, tạo ra một biểu hiện định dạng hiệu quả và an toàn kiểu xử lý đúng cách bất kỳ số lượng người nào.

00:30:34.000 --> 00:30:42.000
TextField cũng đã nhận được sự hỗ trợ cho các kiểu định dạng mới này, cho phép bạn thêm văn bản được định dạng có thể chỉnh sửa với liên kết an toàn kiểu với một số giá trị cơ bản.

00:30:42.000 --> 00:30:50.000
Trường người tham dự mới được liên kết với giá trị PersonNameComponents và nó được định dạng bằng định dạng tên tiêu chuẩn.

00:30:50.000 --> 00:30:55.000
Điều này quan tâm đến việc phân tích cú pháp đầu vào và tạo ra tên người kết quả.

00:30:55.000 --> 00:31:00.000
"Có gì mới trong Foundation" cũng đi vào chi tiết về sức mạnh của những phong cách định dạng mới này.

00:31:00.000 --> 00:31:09.000
TextField hiện cũng hỗ trợ thêm lời nhắc rõ ràng, tách biệt với nhãn của nó, để cho người dùng biết loại nội dung mà một trường đang mong đợi.

00:31:09.000 --> 00:31:17.000
Và khi thêm TextField vào biểu mẫu trên macOS, họ sẽ căn chỉnh nhãn của mình tương tự như các điều khiển khác và sử dụng lời nhắc làm nội dung giữ chỗ của nó.

00:31:17.000 --> 00:31:23.000
Bây giờ, toàn bộ điểm của trường văn bản là thêm văn bản và bàn phím là công cụ của chúng tôi để làm điều đó.

00:31:23.000 --> 00:31:34.000
Từ bàn phím phần mềm trên iPhone đến iPad, hỗ trợ cả bàn phím phần mềm và phần cứng, và tất nhiên, macOS, luôn có bàn phím phần cứng.

00:31:34.000 --> 00:31:38.000
Năm nay, có một số cải tiến để làm cho trải nghiệm sử dụng bàn phím trở nên tốt hơn.

00:31:38.000 --> 00:31:47.000
Với công cụ sửa đổi onSubmit mới, bạn có thể dễ dàng thêm các hành động bổ sung khi người dùng gửi văn bản của trường, chẳng hạn như bằng cách nhấn phím Return.

00:31:47.000 --> 00:31:53.000
Công cụ sửa đổi này cung cấp thêm một số tính linh hoạt ở chỗ nó thậm chí có thể được áp dụng cho toàn bộ hình thức điều khiển.

00:31:53.000 --> 00:32:00.000
Và để giúp cung cấp cho người dùng gợi ý về loại hành động nào sẽ xảy ra khi gửi một trường, có công cụ sửa đổi submitLabel mới.

00:32:00.000 --> 00:32:04.000
Trên bàn phím phần mềm, điều này sẽ được sử dụng làm nhãn cho phím Return.

00:32:04.000 --> 00:32:10.000
Và cuối cùng, chúng tôi đã có thể thêm chế độ xem phụ kiện vào bàn phím bằng cách sử dụng vị trí thanh công cụ bàn phím mới.

00:32:10.000 --> 00:32:18.000
Những chế độ xem này sẽ được hiển thị trên thanh công cụ phía trên bàn phím phần mềm trên iOS và iPadOS hoặc trong Touch Bar trên macOS.

00:32:18.000 --> 00:32:25.000
Đây là một cách tuyệt vời để cung cấp cho người dùng quyền truy cập nhanh vào các hành động phía trên bàn phím mà không bỏ qua nó để tránh làm gián đoạn trải nghiệm chỉnh sửa ứng dụng của bạn.

00:32:25.000 --> 00:32:40.000
Bàn phím cũng phục vụ một vai trò quan trọng khác của điều hướng và lấy nét, và chức năng này tồn tại trên mọi nền tảng; từ việc sử dụng tập trung trên watchOS đến đầu vào Digital Crown trực tiếp, đến sử dụng Siri Remote để điều hướng xung quanh nội dung trên tvOS.

00:32:40.000 --> 00:32:46.000
Đối với hầu hết mọi thứ, SwiftUI chỉ quan tâm đến những quan điểm nào có thể tập trung và cách nó di chuyển giữa chúng.

00:32:46.000 --> 00:32:51.000
Nhưng đôi khi có những cải tiến bổ sung mà bạn có thể thực hiện để tạo ra trải nghiệm mượt mà hơn trong ứng dụng của mình.

00:32:51.000 --> 00:32:57.000
Để giúp điều đó, SwiftUI có một công cụ mới, mạnh mẽ được gọi là FocusState.

00:32:57.000 --> 00:33:02.000
Đây là một trình bao bọc thuộc tính vừa phản ánh trạng thái tập trung vừa cung cấp quyền kiểm soát chính xác đối với nó.

00:33:02.000 --> 00:33:06.000
Đơn giản nhất, nó có thể phản ánh một giá trị Boolean.

00:33:06.000 --> 00:33:09.000
Điều này có thể được gắn với chế độ xem có thể lấy nét bằng cách sử dụng công cụ sửa đổi lấy nét.

00:33:09.000 --> 00:33:13.000
Khi quan điểm đó được tập trung, giá trị sẽ đúng và sai khi không.

00:33:13.000 --> 00:33:16.000
Giá trị này cũng có thể được ghi vào, để kiểm soát tiêu điểm.

00:33:16.000 --> 00:33:19.000
Ví dụ, để đáp lại việc ai đó nhấn một nút.

00:33:19.000 --> 00:33:26.000
Ví dụ này có thể hoạt động như một máy gia tốc, cho phép người dùng bắt đầu nhập ngay lập tức sau khi thực hiện một hành động liên quan.

00:33:26.000 --> 00:33:31.000
Phiên bản Boolean này là một sự tiện lợi cho hình thức đầy đủ của nó, đại diện cho bất kỳ loại nào có thể băm được.

00:33:31.000 --> 00:33:36.000
Mã này có chức năng tương đương với slide trước đó nhưng với một số tính linh hoạt được tăng lên.

00:33:36.000 --> 00:33:37.000
Hãy đi qua nó.

00:33:37.000 --> 00:33:42.000
Đầu tiên, tôi đã xác định một bảng liệt kê đơn giản các trường mà tôi có thể muốn biết được tập trung.

00:33:42.000 --> 00:33:46.000
Thuộc tính FocusState sử dụng loại đó để phản ánh trạng thái hiện tại.

00:33:46.000 --> 00:33:49.000
Nó là tùy chọn để chỉ ra khả năng không ai trong số những người đã tập trung.

00:33:49.000 --> 00:33:55.000
Công cụ sửa đổi tập trung của chúng tôi vẫn bị ràng buộc với cùng trạng thái lấy nét đó, nhưng chỉ khi nó bằng addAttendee.

00:33:55.000 --> 00:34:01.000
Và cuối cùng, khi chúng tôi muốn tập trung vào lĩnh vực đó, chúng tôi đặt giá trị trạng thái tập trung của mình thành addAttendee.

00:34:01.000 --> 00:34:11.000
Tính linh hoạt mới này cho phép thêm chức năng bổ sung, chẳng hạn như xây dựng các nút thanh công cụ từ trước, di chuyển tiêu điểm giữa mỗi trường và phản ánh xem tiêu điểm đạt đến đầu hay cuối.

00:34:11.000 --> 00:34:18.000
Trạng thái lấy nét cũng cung cấp một cách tuyệt vời để các ứng dụng iOS loại bỏ bàn phím phần mềm bằng cách xóa giá trị của nó.

00:34:18.000 --> 00:34:26.000
Nếu bạn quan tâm đến việc tìm hiểu thêm về các cách khác để tinh chỉnh trải nghiệm tập trung trong ứng dụng của mình, hãy xem phiên năm nay, "Trực tiếp và phản ánh sự tập trung trong SwiftUI."

00:34:26.000 --> 00:34:31.000
Cuối cùng, chúng ta sẽ tập trung vào các nút vì các nút rất quan trọng.

00:34:31.000 --> 00:34:39.000
Tất cả chúng ta đều biết một nút điển hình trông như thế nào; nó thay đổi từ nền tảng này sang nền tảng khác và nó là một trong những cách đơn giản nhất để cho phép mọi người tương tác với ứng dụng của bạn.

00:34:39.000 --> 00:34:43.000
Và đặc biệt là trong SwiftUI, các nút được sử dụng cho rất nhiều thứ.

00:34:43.000 --> 00:34:46.000
Matt đã thảo luận trước đó về cách các hành động vuốt được tạo thành từ các nút.

00:34:46.000 --> 00:34:51.000
Và năm nay, có rất nhiều thứ mới với các nút.

00:34:51.000 --> 00:34:55.000
Đầu tiên, SwiftUI hiện có các nút viền tiêu chuẩn trên iOS.

00:34:55.000 --> 00:35:01.000
Bạn có thể tạo một nút có viền chỉ bằng cách thêm công cụ sửa đổi buttonStyle, giống như tôi đang làm với nút Thêm này.

00:35:01.000 --> 00:35:06.000
Giống như các công cụ sửa đổi kiểu khác, điều này có thể được thêm vào một nhóm các điều khiển và áp dụng cho tất cả chúng.

00:35:06.000 --> 00:35:10.000
Nó hỗ trợ nhuộm màu cho các trường hợp bạn muốn có một diện mạo cụ thể cho một nút nhất định.

00:35:10.000 --> 00:35:15.000
Nhưng đối với giao diện người dùng này, tôi thích giao diện mặc định sử dụng màu nhấn.

00:35:15.000 --> 00:35:18.000
Cũng có nhiều tùy chỉnh hơn được tích hợp sẵn.

00:35:18.000 --> 00:35:21.000
Đầu tiên là kiểm soát kích thước và sự nổi bật.

00:35:21.000 --> 00:35:25.000
Tôi đang sử dụng những thứ này để tùy chỉnh các nút đại diện cho các thẻ.

00:35:25.000 --> 00:35:32.000
Họ đang sử dụng kích thước điều khiển nhỏ tiêu chuẩn mới và có tông màu với sự nổi bật ngày càng tăng để thực sự làm cho chúng nổi bật.

00:35:32.000 --> 00:35:39.000
Chúng ta có thể sử dụng các công cụ sửa đổi tương tự này để tạo ra một loại nút phổ biến khác: những nút có kích thước lớn này hiện được tích hợp vào SwiftUI.

00:35:39.000 --> 00:35:45.000
Bằng cách chỉ định kích thước điều khiển lớn, bạn sẽ tự động nhận được các nút hình chữ nhật tròn, đẹp mắt này.

00:35:45.000 --> 00:35:53.000
Và để mang lại cho họ cảm giác về hệ thống phân cấp, tôi đã sửa đổi cái quan trọng nhất để tăng sự nổi bật, lấp đầy nó bằng một màu nhấn có độ tương phản cao.

00:35:53.000 --> 00:35:57.000
Và nút phụ vẫn có thể được nhuộm màu nhưng có độ tương phản thấp hơn.

00:35:57.000 --> 00:36:02.000
Các nút này cũng có ít công cụ sửa đổi để làm cho chúng trở nên tuyệt vời trên iPad.

00:36:02.000 --> 00:36:08.000
Các nhãn văn bản có chiều rộng tối đa để nút tổng thể linh hoạt nhưng không lớn một cách hài hước.

00:36:08.000 --> 00:36:18.000
Và nút chính có phím tắt hành động mặc định, vì vậy khi sử dụng ứng dụng có bàn phím, tôi có thể nhanh chóng nhấn phím Return để thêm nút này vào lọ của mình.

00:36:18.000 --> 00:36:24.000
Giờ đây, nhiều API này đã tồn tại trên macOS, giúp việc xây dựng ứng dụng cho nhiều nền tảng trở nên dễ dàng hơn.

00:36:24.000 --> 00:36:31.000
Một bổ sung mới là tăng cường hỗ trợ tông màu nổi bật để cho phép bạn thêm các nút sáng này vào ứng dụng của mình một cách trang nhã.

00:36:31.000 --> 00:36:40.000
Lưu ý rằng các nút không nổi bật, như các nút Thêm này, không hiển thị bất kỳ tông màu nào vì chrome của chúng là thứ cho thấy tính tương tác của chúng trên macOS.

00:36:40.000 --> 00:36:49.000
Sau khi tìm hiểu về sự nổi bật, tôi có thể bị cám dỗ để áp dụng điều đó cho tất cả các nút Thêm của mình, nhưng có thể trở nên quá sức và khó hiểu khi có rất nhiều nút nổi bật trên màn hình.

00:36:49.000 --> 00:36:52.000
Tốt nhất là dành nó cho các hành động chính đơn lẻ.

00:36:52.000 --> 00:36:57.000
Màu sắc nổi bật thấp hơn là một sự thay thế tuyệt vời để thêm một chút màu sắc trên iOS.

00:36:57.000 --> 00:37:08.000
Bây giờ, điều yêu thích của tôi về các kiểu nút mới này là chúng tự động có trạng thái nhấn và tắt dự kiến, hỗ trợ Chế độ tối và tất nhiên hoàn toàn có thể truy cập và tương thích với Loại động.

00:37:08.000 --> 00:37:11.000
Và chúng giúp mang lại sự nhất quán giữa các ứng dụng.

00:37:11.000 --> 00:37:13.000
Và API mới của các nút không dừng lại ở đây.

00:37:13.000 --> 00:37:23.000
SwiftUI cũng đã thêm hỗ trợ hạng nhất cho các nút có ngữ nghĩa bổ sung, chẳng hạn như đánh dấu một nút là phá hoại, điều này sẽ tự động cung cấp cho chúng tông màu đỏ dự kiến.

00:37:23.000 --> 00:37:30.000
Một ngữ cảnh mới mà điều này cũng có thể được sử dụng trong các hộp thoại xác nhận, cho phép người dùng xác nhận các hành động có tác động nghiêm trọng đến dữ liệu của họ.

00:37:30.000 --> 00:37:37.000
Trên iOS, điều này hiển thị dưới dạng bảng hành động, trên iPad dưới dạng cửa sổ bật lên và trên macOS dưới dạng cảnh báo.

00:37:37.000 --> 00:37:42.000
SwiftUI tự động xử lý theo độ nhạy thiết kế của từng nền tảng.

00:37:42.000 --> 00:37:47.000
Tiếp theo, hãy nói về các nút không phải là nút "vốn B".

00:37:47.000 --> 00:37:50.000
Hiện tại, các nút Thêm của ứng dụng chỉ cần thêm vào lọ mặc định của người dùng.

00:37:50.000 --> 00:37:54.000
Nhưng đối với những nhà sưu tập cuồng nhiệt, tôi muốn hỗ trợ thêm vào các lọ cụ thể.

00:37:54.000 --> 00:37:57.000
Đây là một trường hợp sử dụng hoàn hảo cho một nút menu.

00:37:57.000 --> 00:38:03.000
Chúng tôi sẽ sử dụng cùng một nhãn "Thêm", nhưng trình bày một menu gồm tất cả các lọ có thể có sau khi nhấp vào nút.

00:38:03.000 --> 00:38:07.000
Tuy nhiên, các nút menu này trực quan mang rất nhiều điểm nổi bật.

00:38:07.000 --> 00:38:12.000
Chúng tôi có thể ẩn các chỉ báo bằng cách sử dụng công cụ sửa đổi menuIndicator mới được thêm vào trong năm nay.

00:38:12.000 --> 00:38:16.000
Và ngay cả khi không có chỉ báo, nút này vẫn hiển thị menu khi nhấp chuột.

00:38:16.000 --> 00:38:25.000
Nhưng đối với các nút này, lý tưởng nhất là chúng ta sẽ tận dụng tốt nhất cả hai thế giới: chỉ với một cú nhấp chuột đơn giản để thêm vào lọ mặc định và tính linh hoạt trong việc hiển thị menu của những người khác.

00:38:25.000 --> 00:38:30.000
Điểm mới trong năm nay là khả năng tùy chỉnh hành động chính của menu để giúp giải quyết loại trường hợp này.

00:38:30.000 --> 00:38:35.000
Theo mặc định, một menu với hành động chính có giao diện hai phân đoạn trên macOS.

00:38:35.000 --> 00:38:40.000
Phần chính của nút kích hoạt hành động chính trong chỉ báo trình bày menu.

00:38:40.000 --> 00:38:47.000
Và khi chỉ báo bị ẩn, nó lại trông giống như nút mà tôi đã bắt đầu nhưng có sự khác biệt về hành vi.

00:38:47.000 --> 00:38:51.000
Một cú nhấp chuột kích hoạt hành động chính và nhấn và giữ sẽ hiển thị menu.

00:38:51.000 --> 00:38:54.000
Và điều tuyệt vời là điều tương tự này cũng hoạt động trên iOS!

00:38:54.000 --> 00:38:59.000
Bây giờ các menu này cung cấp rất nhiều sự linh hoạt, thực sự phục vụ cho cách ứng dụng của bạn cần sử dụng chúng.

00:38:59.000 --> 00:39:03.000
Một ví dụ mới khác về việc điều khiển đạt được kiểu nút là Chuyển đổi.

00:39:03.000 --> 00:39:09.000
Điều này tạo ra một nút mà khi chạm vào, bật và tắt trực quan và có thể được sử dụng giống như bất kỳ nút chuyển đổi nào khác.

00:39:09.000 --> 00:39:16.000
Và tham gia các kiểu điều khiển mới này là một vùng chứa nhóm các điều khiển liên quan; được gọi một cách khéo léo là ControlGroup.

00:39:16.000 --> 00:39:20.000
Trên iOS, các điều khiển trong một nhóm được sắp xếp chặt chẽ hơn một chút trên thanh công cụ.

00:39:20.000 --> 00:39:26.000
Và trên macOS, có các khả năng trực quan chỉ ra hai nút được nhóm lại.

00:39:26.000 --> 00:39:30.000
Và để kết thúc tất cả những điều này, tự nhiên tất cả những thứ này có thể được kết hợp với nhau.

00:39:30.000 --> 00:39:35.000
Ví dụ, các nút quay lại/chuyển tiếp tiêu chuẩn này là một ControlGroup gồm hai menu.

00:39:35.000 --> 00:39:39.000
Mỗi menu này đều có một Hành động chính được thực hiện khi được nhấp vào.

00:39:39.000 --> 00:39:44.000
Và một khi thực đơn được nhấn từ lâu, họ sẽ trình bày nội dung của họ.

00:39:44.000 --> 00:39:53.000
Giờ đây, chỉ với một vài tùy chỉnh bổ sung trên các nút và các kiểu mới này, rất nhiều sự linh hoạt đã mở ra về cách bạn có thể sử dụng các điều khiển này trong ứng dụng của mình.

00:39:53.000 --> 00:39:57.000
Chúng tôi đã trải qua rất nhiều trong phiên này, và thậm chí còn có nhiều thứ hơn mà chúng tôi không có thời gian để trang trải.

00:39:57.000 --> 00:40:04.000
Chúng tôi rất vui khi bạn tận dụng các tính năng mới này trong các ứng dụng SwiftUI của riêng bạn và áp dụng SwiftUI ở nhiều nơi hơn nữa.

00:40:04.000 --> 00:40:07.000
Cảm ơn bạn và chúc bạn có một phần còn lại tuyệt vời trong năm 2021 của bạn!

00:40:07.000 --> 23:59:59.000
♪

