WEBVTT

00:00:00.000 --> 00:00:05.000
♪ Nhạc bass đang phát ♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:12.000
Chris Donegan: Xin chào, tôi là Chris, một kỹ sư trên UIKit.

00:00:12.000 --> 00:00:15.000
Tôi sẽ được tham gia sau bởi các đồng nghiệp Anant và Mohammed.

00:00:15.000 --> 00:00:20.000
iPad là thiết bị chính của nhiều người do sức mạnh và khả năng của nó.

00:00:20.000 --> 00:00:28.000
Trong video này, bạn sẽ tìm hiểu về một số tính năng mới thú vị mà bạn nên sử dụng để đưa ứng dụng iPad của mình lên một tầm cao mới.

00:00:28.000 --> 00:00:33.000
Đầu tiên, tôi sẽ cho bạn thấy những tiến bộ mới nhất trong đa nhiệm và cảnh quay.

00:00:33.000 --> 00:00:38.000
Sau đó, Anant sẽ hướng dẫn bạn những thay đổi mạnh mẽ đối với các phím tắt.

00:00:38.000 --> 00:00:44.000
Cuối cùng, Mohammed sẽ chỉ cho bạn những cải tiến mới nhất cho con trỏ hệ thống.

00:00:44.000 --> 00:00:47.000
Hãy bắt tay ngay vào đa nhiệm.

00:00:47.000 --> 00:00:52.000
iPadOS 13 đã giới thiệu khả năng chạy nhiều phiên bản giao diện người dùng ứng dụng của bạn.

00:00:52.000 --> 00:01:01.000
Trong iPadOS 15, chúng tôi đang cải thiện trải nghiệm này với các API mới để trình bày cảnh cũng như khôi phục trạng thái nâng cao.

00:01:01.000 --> 00:01:05.000
Những cải tiến này được xây dựng dựa trên cơ sở hạ tầng UIScene hiện có.

00:01:05.000 --> 00:01:11.000
Nếu bạn chưa áp dụng UIScene, hãy xem "Giới thiệu nhiều Windows trên iPad."

00:01:11.000 --> 00:01:15.000
Hãy xem xét ngắn gọn các khái niệm chính.

00:01:15.000 --> 00:01:20.000
Một cảnh đại diện cho một phiên bản duy nhất của giao diện người dùng ứng dụng của bạn.

00:01:20.000 --> 00:01:25.000
Cấu trúc của các thành phần của cảnh được xác định bởi cấu hình cảnh.

00:01:25.000 --> 00:01:30.000
Ở mức tối thiểu, nó xác định vai trò của cảnh và lớp đại diện.

00:01:30.000 --> 00:01:34.000
Bạn cũng có thể cung cấp tên, bảng phân cảnh và lớp con cảnh.

00:01:34.000 --> 00:01:43.000
Cấu hình cảnh có thể được khai báo trong Info.plist của bạn hoặc được tạo trong thời gian chạy bằng cách sử dụng đối tượng UISceneConfiguration.

00:01:43.000 --> 00:01:48.000
Nội dung của một cảnh được đại diện bởi NSUserActivity.

00:01:48.000 --> 00:01:52.000
Những hoạt động này được sử dụng để yêu cầu các cảnh cũng như để khôi phục trạng thái.

00:01:52.000 --> 00:01:56.000
Một cảnh được quản lý bởi một đại biểu cảnh.

00:01:56.000 --> 00:02:05.000
Người đại diện chịu trách nhiệm thiết lập giao diện người dùng, phản hồi các sự kiện vòng đời, cũng như lưu và khôi phục trạng thái.

00:02:05.000 --> 00:02:09.000
Cuối cùng, một cảnh được theo dõi bởi một phiên cảnh.

00:02:09.000 --> 00:02:15.000
Bản thân cảnh có thể bị ngắt kết nối và kết nối lại bởi hệ thống khi nó ở chế độ nền.

00:02:15.000 --> 00:02:22.000
Phiên cảnh theo dõi cảnh bất kể trạng thái kết nối của nó và vẫn tồn tại giữa các lần phóng.

00:02:22.000 --> 00:02:27.000
Phiên có thể được coi là đại diện trong trình chuyển đổi ứng dụng hệ thống.

00:02:27.000 --> 00:02:31.000
Mỗi mục trong trình chuyển đổi tương ứng với một phiên cảnh.

00:02:31.000 --> 00:02:38.000
Khi yêu cầu một cảnh từ hệ thống, bạn có thể cung cấp một đối tượng tùy chọn để tùy chỉnh yêu cầu.

00:02:38.000 --> 00:02:42.000
iPadOS 15 có một lớp con tùy chọn mới dành riêng cho các cảnh cửa sổ.

00:02:42.000 --> 00:02:47.000
Sử dụng lớp con này cho phép bạn chỉ định một phong cách trình bày.

00:02:47.000 --> 00:02:54.000
Phong cách trình bày cảnh cửa sổ ảnh hưởng đến cách cảnh được trình bày so với các cảnh khác trong không gian làm việc.

00:02:54.000 --> 00:03:00.000
Có ba giá trị khả thi: nổi bật, tiêu chuẩn và tự động.

00:03:00.000 --> 00:03:04.000
Đây là một cảnh sử dụng phong cách trình bày nổi bật.

00:03:04.000 --> 00:03:09.000
Nó được trình bày theo phương thức trong không gian làm việc hiện tại với những cảnh đằng sau nó mờ đi.

00:03:09.000 --> 00:03:13.000
Bởi vì nó là phương thức, nó nên cung cấp các nút Hủy, Đóng hoặc Xong.

00:03:13.000 --> 00:03:18.000
Phong cách mới này có thể được coi là nơi dàn dựng cho những cảnh mới.

00:03:18.000 --> 00:03:27.000
Nó có thể được định vị lại giống như bất kỳ cảnh nào khác bằng cách sử dụng các điều khiển đa nhiệm mới và nó cũng có thể được chuyển vào kệ ứng dụng để sử dụng.

00:03:27.000 --> 00:03:33.000
Khi xem xét liệu phong cách này có phù hợp với một cảnh hay không, có một số hướng dẫn cần ghi nhớ.

00:03:33.000 --> 00:03:36.000
Đầu tiên, những cảnh nổi bật nên tự nó hữu ích.

00:03:36.000 --> 00:03:41.000
Chúng không nên được sử dụng để cung cấp các tùy chọn hoặc công cụ cho một cảnh khác.

00:03:41.000 --> 00:03:50.000
Họ nên cung cấp nút Xong hoặc Đóng và họ nên dành riêng cho nội dung cụ thể trong ứng dụng của bạn như tài liệu hoặc tệp.

00:03:50.000 --> 00:03:56.000
Phạm vi nội dung chuyên dụng này phải được xác định trong điều kiện kích hoạt của cảnh.

00:03:56.000 --> 00:04:03.000
Để biết thêm thông tin về các điều kiện kích hoạt, hãy xem "Nhắm mục tiêu nội dung với nhiều cửa sổ".

00:04:03.000 --> 00:04:08.000
Ví dụ này cho thấy cách Safari đang mở một cảnh mới bằng cách sử dụng phong cách tiêu chuẩn.

00:04:08.000 --> 00:04:16.000
Chúng được trình bày cạnh nhau, cho phép tương tác với từng cái và cả hai đều cung cấp đầy đủ chức năng của cảnh chính.

00:04:16.000 --> 00:04:20.000
Bạn cũng có thể chỉ định tự động làm kiểu.

00:04:20.000 --> 00:04:26.000
Giá trị này cho hệ thống biết rằng nó nên chọn kiểu tốt nhất dựa trên cách nó được yêu cầu.

00:04:26.000 --> 00:04:37.000
iPadOS 15 không chỉ cung cấp một cách để tùy chỉnh bản trình bày bằng cách sử dụng các phong cách, nó còn giúp mọi người mở nội dung của họ dễ dàng hơn trong các cảnh mới.

00:04:37.000 --> 00:04:42.000
Trên Mac, người ta thường tìm thấy một mục Mở trong Cửa sổ Mới trong các menu ngữ cảnh.

00:04:42.000 --> 00:04:49.000
Bạn nên mang trải nghiệm quen thuộc này đến ứng dụng iPad của mình bằng cách sử dụng UIWindowScene.ActivationAction.

00:04:49.000 --> 00:04:56.000
Đó là một lớp con UIAction mới để yêu cầu các cảnh có thể được sử dụng trong các menu, nút và các mục nút thanh.

00:04:56.000 --> 00:05:03.000
Để thêm chức năng này vào ứng dụng của bạn, hãy bắt đầu bằng cách khởi tạo UIWindowScene.ActivationAction.

00:05:03.000 --> 00:05:08.000
Nó được khởi tạo với một đóng được thực thi khi mục được chọn.

00:05:08.000 --> 00:05:15.000
Việc đóng sẽ trả lại cấu hình kích hoạt với hoạt động của người dùng cho nội dung của cảnh mới.

00:05:15.000 --> 00:05:20.000
Cuối cùng, đặt hành động vào thực đơn và bạn đã sẵn sàng.

00:05:20.000 --> 00:05:27.000
Trên iPad và Mac Catalyst, menu hiển thị mục Mở trong Cửa sổ Mới, khi được chọn, sẽ hiển thị một cảnh mới.

00:05:27.000 --> 00:05:34.000
Trên iPhone, mục này được tự động ẩn vì nhiều cảnh không được hỗ trợ.

00:05:34.000 --> 00:05:39.000
Nếu bạn muốn hiển thị một mục khác ở vị trí của nó, bạn có thể cung cấp một hành động thay thế.

00:05:39.000 --> 00:05:42.000
Hãy cập nhật ví dụ trước để đưa ra một ví dụ.

00:05:42.000 --> 00:05:46.000
Để làm điều này, hãy bắt đầu bằng cách tạo hành động thay thế.

00:05:46.000 --> 00:05:52.000
Tiêu đề và hình ảnh của hành động mới được hiển thị khi không có nhiều cửa sổ.

00:05:52.000 --> 00:06:01.000
Sau đó, cập nhật trình khởi tạo hành động kích hoạt cảnh bằng cách chuyển hành động mới làm hành động thay thế.

00:06:01.000 --> 00:06:16.000
Với một hành động thay thế được cung cấp, các menu trên iPad và Mac Catalyst vẫn hiển thị mục Mở trong Cửa sổ Mới nhưng trên iPhone, mục Hiển thị Chi tiết hiển thị; tất cả được thực hiện mà không có một điều kiện duy nhất trong mã của bạn.

00:06:16.000 --> 00:06:22.000
Thêm các mục menu này là một cách rõ ràng và quen thuộc để mọi người mở nội dung của họ trong các cảnh mới.

00:06:22.000 --> 00:06:24.000
Nhưng đó không phải là cách duy nhất.

00:06:24.000 --> 00:06:30.000
iPad là một thiết bị cảm ứng đầu tiên và thật dễ dàng để mở cảnh chỉ bằng một cử chỉ.

00:06:30.000 --> 00:06:34.000
Trong ứng dụng Ghi chú, việc chèn ép trên một ô sẽ mở ghi chú trong một cảnh mới.

00:06:34.000 --> 00:06:40.000
Cảnh tương tác làm sinh động từ phòng giam đến vị trí cuối cùng của nó.

00:06:40.000 --> 00:06:44.000
Có hai cách để cung cấp chức năng này trong ứng dụng của bạn.

00:06:44.000 --> 00:06:48.000
Nếu bạn đang sử dụng chế độ xem bộ sưu tập, có một phương thức đại diện mới.

00:06:48.000 --> 00:06:52.000
Đối với các chế độ xem khác, hãy sử dụng UIWindowScene ActivationInteraction.

00:06:52.000 --> 00:06:57.000
Cả hai điều này chỉ để trình bày những cảnh với phong cách nổi bật.

00:06:57.000 --> 00:07:06.000
Để hỗ trợ cử chỉ này trong chế độ xem bộ sưu tập của bạn, hãy triển khai phương thức đại diện mới có tên là sceneActivationConfiguration ForItemAt indexPath.

00:07:06.000 --> 00:07:10.000
Nó rất giống với ví dụ trình đơn ngữ cảnh từ trước đó.

00:07:10.000 --> 00:07:18.000
Tạo hoạt động người dùng cho nội dung của cảnh mới, sau đó trả lại cấu hình kích hoạt với hoạt động đó.

00:07:18.000 --> 00:07:22.000
Bạn có thể không muốn mọi tế bào hỗ trợ mở một cảnh mới.

00:07:22.000 --> 00:07:26.000
Để ngăn cử chỉ bắt đầu, chỉ cần quay lại số không.

00:07:26.000 --> 00:07:32.000
Để hỗ trợ cử chỉ này ở các chế độ xem khác, hãy tạo một UIWindowScene. Tương tác kích hoạt.

00:07:32.000 --> 00:07:42.000
Nó được tạo ra với một đóng chấp nhận hai đối số: bản thân tương tác và điểm tương tác trong không gian tọa độ xem.

00:07:42.000 --> 00:07:47.000
Chúng có thể được sử dụng để tạo các hoạt động người dùng cụ thể cho các khu vực khác nhau của chế độ xem.

00:07:47.000 --> 00:07:53.000
Việc đóng cửa sẽ trả về một cấu hình kích hoạt với hoạt động của người dùng.

00:07:53.000 --> 00:07:55.000
Sự tương tác cũng cần một trình xử lý lỗi.

00:07:55.000 --> 00:08:06.000
Mặc dù tương tác bị vô hiệu hóa trên các nền tảng không hỗ trợ nhiều cảnh, nhưng lỗi vẫn có thể xảy ra do sự cố cấu hình hoặc thiếu tài nguyên hệ thống.

00:08:06.000 --> 00:08:14.000
Bạn có thể nhận thấy rằng tất cả các cách trình bày cảnh cửa sổ này đều sử dụng cùng một đối tượng cấu hình kích hoạt.

00:08:14.000 --> 00:08:22.000
Yêu cầu duy nhất của nó là hoạt động của người dùng, nhưng nó cũng chứa các tùy chọn yêu cầu cảnh và bản xem trước được nhắm mục tiêu.

00:08:22.000 --> 00:08:26.000
Nếu những thứ này không được cung cấp, hệ thống sẽ cố gắng hết sức để tạo ra chúng cho bạn.

00:08:26.000 --> 00:08:31.000
Tuy nhiên, bạn có thể cung cấp chúng một cách rõ ràng để tinh chỉnh trải nghiệm.

00:08:31.000 --> 00:08:36.000
Ví dụ, các ô xem bộ sưu tập này có hình thu nhỏ, tiêu đề và chú thích.

00:08:36.000 --> 00:08:43.000
Khi ô bị chèn ép, một cảnh được trình bày chủ yếu hiển thị phiên bản lớn hơn của nội dung hình thu nhỏ.

00:08:43.000 --> 00:08:47.000
Lưu ý rằng cảnh mới đang chuyển đổi từ toàn bộ ô.

00:08:47.000 --> 00:08:51.000
Nó sẽ trông đẹp hơn nếu nó chuyển đổi từ chỉ hình thu nhỏ.

00:08:51.000 --> 00:08:57.000
Để đạt được hiệu ứng này, cấu hình kích hoạt được tạo ra như trước đây.

00:08:57.000 --> 00:09:01.000
Sau đó, kiểm tra xem ô đó có phải là ô thu nhỏ không.

00:09:01.000 --> 00:09:09.000
Nếu vậy, hãy sử dụng chế độ xem hình thu nhỏ của ô để tạo bản xem trước được nhắm mục tiêu và đặt nó trên cấu hình.

00:09:09.000 --> 00:09:15.000
Bằng cách cung cấp bản xem trước tùy chỉnh trên cấu hình kích hoạt, quá trình chuyển đổi được đánh bóng hơn nhiều.

00:09:15.000 --> 00:09:17.000
Chúng ta hãy xem xét kỹ hơn.

00:09:17.000 --> 00:09:27.000
Bây giờ, thay vì chuyển đổi từ chính ô, nó chuyển đổi từ hình thu nhỏ, để phần còn lại của ô tại chỗ.

00:09:27.000 --> 00:09:32.000
Cấu hình kích hoạt cho phép bạn yêu cầu bất kỳ cảnh nào trong ứng dụng của mình.

00:09:32.000 --> 00:09:37.000
Tuy nhiên, bạn có thể chỉ muốn hiển thị một tệp mà không cần phải tự xây dựng cảnh.

00:09:37.000 --> 00:09:41.000
iPadOS 15 làm cho điều này rất dễ dàng.

00:09:41.000 --> 00:09:50.000
Có một lớp con đặc biệt của UIWindowScene. Cấu hình kích hoạt được gọi là "Cấu hình kích hoạt cảnh QLPreviewScene".

00:09:50.000 --> 00:09:55.000
Trả về cấu hình cảnh xem trước yêu cầu cảnh xem trước do hệ thống quản lý.

00:09:55.000 --> 00:10:04.000
Không có đại diện cảnh và không có cuộc gọi lại nào phải lo lắng, nhưng ứng dụng của bạn phải tuyên bố hỗ trợ cho nhiều cửa sổ trong Info.plist.

00:10:04.000 --> 00:10:10.000
Cung cấp những cách bóng bẩy và thuận tiện để mọi người mở nội dung trong những cảnh mới là rất quan trọng.

00:10:10.000 --> 00:10:18.000
Nhưng việc lưu và khôi phục trạng thái của cảnh cũng quan trọng không kém, vì vậy quay lại với họ sau này là một trải nghiệm liền mạch.

00:10:18.000 --> 00:10:26.000
Khi một cảnh di chuyển sang nền, hệ thống sẽ yêu cầu đại diện của cảnh cho NSUserActivity đại diện cho trạng thái của nó.

00:10:26.000 --> 00:10:33.000
Hoạt động này có thể là hoạt động của bộ điều khiển chế độ xem gốc nếu nó hỗ trợ Handoff hoặc một hoạt động được tạo ngay tại chỗ.

00:10:33.000 --> 00:10:42.000
Ở đây, một hoạt động của người dùng được tạo ra để lưu nội dung của trường văn bản trong từ điển thông tin người dùng của hoạt động.

00:10:42.000 --> 00:10:47.000
Để mang lại trải nghiệm tốt nhất, trạng thái cảnh nên vượt ra ngoài nội dung.

00:10:47.000 --> 00:10:55.000
Bạn cũng nên lưu trạng thái trực quan và tương tác như vị trí cuộn, vị trí con trỏ và trạng thái phản hồi đầu tiên.

00:10:55.000 --> 00:11:03.000
Thay vì lưu từng thứ này một cách độc lập, UITextField và UITextView hiện có thuộc tính interactionState.

00:11:03.000 --> 00:11:08.000
Thuộc tính này cung cấp một đối tượng duy nhất chứa tất cả trạng thái tương tác.

00:11:08.000 --> 00:11:17.000
Đối tượng không chứa nội dung, đó là thông tin bổ sung để bạn lưu trong hoạt động của người dùng.

00:11:17.000 --> 00:11:21.000
Tôi đã cập nhật ví dụ trước bằng cách lưu trạng thái tương tác của trường văn bản.

00:11:21.000 --> 00:11:32.000
Giờ đây, bằng cách lưu cả nội dung và trạng thái tương tác, hoạt động của người dùng chứa đủ thông tin để được khôi phục chính xác.

00:11:32.000 --> 00:11:37.000
Trên iPadOS 14, việc khôi phục trạng thái có thể hơi phức tạp.

00:11:37.000 --> 00:11:44.000
Nếu bạn cố gắng khôi phục trạng thái khi cảnh đang kết nối, bạn sẽ nhận thấy rằng bảng phân cảnh và chế độ xem chưa được tải đầy đủ.

00:11:44.000 --> 00:11:51.000
Nếu bạn khôi phục sau đó, khi cảnh đang chuyển sang tiền cảnh, bạn phải theo dõi xem đó có phải là lần đầu tiên hay không.

00:11:51.000 --> 00:11:58.000
iPadOS 15 giải quyết vấn đề này bằng một phương thức đại diện mới một cách rõ ràng để khôi phục trạng thái.

00:11:58.000 --> 00:12:06.000
Nó được gọi sau khi cảnh được kết nối và bảng phân cảnh đã được tải, nhưng trước khi chuyển đổi đầu tiên lên tiền cảnh.

00:12:06.000 --> 00:12:12.000
Bất kể ứng dụng của bạn có sử dụng bảng phân cảnh hay không, bạn nên sử dụng lệnh gọi lại mới này để khôi phục trạng thái.

00:12:12.000 --> 00:12:20.000
Khôi phục trạng thái từ hoạt động được lưu trong ví dụ trước bắt đầu với hệ thống gọi sceneRestoreInteractionState.

00:12:20.000 --> 00:12:24.000
Sau đó, khôi phục nội dung của trường văn bản.

00:12:24.000 --> 00:12:27.000
Cuối cùng, khôi phục trạng thái tương tác của nó.

00:12:27.000 --> 00:12:32.000
Điều quan trọng là nội dung phải được khôi phục trước trạng thái tương tác.

00:12:32.000 --> 00:12:36.000
Cuối cùng, trạng thái khôi phục đồng bộ có thể phức tạp.

00:12:36.000 --> 00:12:42.000
Bạn có thể cần truy cập cơ sở dữ liệu hoặc tải tệp và không muốn giao diện người dùng trống trong thời gian đó.

00:12:42.000 --> 00:12:48.000
Để giải thích cho điều này, iPadOS 15 cho phép ứng dụng của bạn yêu cầu gia hạn ngắn hạn.

00:12:48.000 --> 00:12:55.000
Trong phần mở rộng này, hình ảnh khởi chạy sẽ vẫn hiển thị trong khi vẫn cho phép RunLoop chính thực thi.

00:12:55.000 --> 00:13:01.000
Khi nội dung của bạn được tải, ứng dụng sẽ báo hiệu để hoàn tất việc khôi phục.

00:13:01.000 --> 00:13:08.000
Tiện ích mở rộng này ngắn gọn và không nhằm mục đích sử dụng cho các tác vụ có khả năng chạy lâu dài như truy cập mạng.

00:13:08.000 --> 00:13:14.000
Nếu ứng dụng của bạn không báo hiệu hoàn thành hoặc mất quá nhiều thời gian, nó sẽ bị hệ thống đóng cửa.

00:13:14.000 --> 00:13:19.000
Để sử dụng khôi phục trạng thái mở rộng, hãy bắt đầu bằng cách yêu cầu gia hạn từ hiện trường.

00:13:19.000 --> 00:13:22.000
Sau đó, bắt đầu công việc không đồng bộ của bạn.

00:13:22.000 --> 00:13:28.000
Khi nội dung được tải, hãy khôi phục nó và yêu cầu cảnh khôi phục hoàn tất.

00:13:28.000 --> 00:13:31.000
Cảnh sau đó sẽ hiển thị giao diện người dùng mới được khôi phục của bạn.

00:13:31.000 --> 00:13:39.000
Hỗ trợ đa nhiệm trong ứng dụng của bạn làm cho nó tỏa sáng, nhưng để trở thành một ứng dụng iPad cấp độ tiếp theo thực sự, còn nhiều việc phải làm.

00:13:39.000 --> 00:13:41.000
Và bây giờ, đến Anant.

00:13:41.000 --> 00:13:43.000
Anant Jain: Cảm ơn bạn, Chris!

00:13:43.000 --> 00:13:47.000
Tên tôi là Anant và tôi là một kỹ sư UIKit.

00:13:47.000 --> 00:13:58.000
Mọi người thích rằng iPad đủ nhẹ để cầm trên tay trong khi vẫn có thể gắn vào bàn phím vật lý ngay lập tức.

00:13:58.000 --> 00:14:03.000
Họ mong đợi ứng dụng của bạn theo kịp họ bằng cách hỗ trợ bàn phím tuyệt vời.

00:14:03.000 --> 00:14:11.000
iPadOS 15 giới thiệu một số tính năng mới để đưa các phím tắt của ứng dụng của bạn lên một tầm cao mới.

00:14:11.000 --> 00:14:17.000
iPadOS 15 có giao diện hoàn toàn mới để khám phá các phím tắt.

00:14:17.000 --> 00:14:27.000
Nó cấu trúc mỗi lệnh thành các danh mục quen thuộc, mang lại sự cân bằng tăng lên giữa các phiên bản iPad và Mac Catalyst của ứng dụng của bạn.

00:14:27.000 --> 00:14:33.000
Menu cung cấp một tính năng tìm kiếm thuận tiện có thể được đưa lên từ mọi nơi trên hệ thống.

00:14:33.000 --> 00:14:37.000
Bạn thậm chí có thể nhấn vào một phím tắt để kích hoạt nó.

00:14:37.000 --> 00:14:49.000
Nếu bạn cần bồi dưỡng về cách hỗ trợ các phím tắt với UIKeyCommand, bao gồm cách các lệnh được gửi đến chuỗi phản hồi, hãy xem "Hỗ trợ bàn phím phần cứng trong ứng dụng của bạn".

00:14:49.000 --> 00:14:57.000
Trên Mac Catalyst, mỗi ứng dụng đều có một menu toàn cầu được gọi là menu chính, được hiển thị trong thanh menu ở đầu màn hình.

00:14:57.000 --> 00:15:11.000
Menu chính bao gồm một số menu con danh mục, như Tệp và Chỉnh sửa, và các menu danh mục này lần lượt chứa các menu con khác với tất cả các lệnh của ứng dụng.

00:15:11.000 --> 00:15:16.000
Trên iPadOS 15, chúng tôi đã đưa hệ thống menu chính lên các ứng dụng iPad.

00:15:16.000 --> 00:15:23.000
Giao diện phím tắt mới, xuất hiện bằng cách giữ phím Command, hiển thị menu này.

00:15:23.000 --> 00:15:29.000
Bây giờ, hệ thống menu chính được thể hiện hơi khác một chút trên iPad so với Mac.

00:15:29.000 --> 00:15:37.000
Mac hiển thị hệ thống phân cấp menu con đầy đủ trong mỗi danh mục, trong khi iPad làm phẳng các hệ thống phân cấp đó.

00:15:37.000 --> 00:15:44.000
Các lệnh bị vô hiệu hóa và không thể thực hiện xuất hiện màu xám trên Mac, trong khi chúng bị ẩn trên iPad.

00:15:44.000 --> 00:15:51.000
Hơn nữa, menu phím tắt iPad được thiết kế để giúp khám phá các phím tắt trong một ứng dụng.

00:15:51.000 --> 00:15:56.000
Nó sẽ không hiển thị các lệnh không cần chìa khóa như thanh menu Mac.

00:15:56.000 --> 00:16:03.000
Theo mặc định, menu chính chứa tất cả các menu danh mục hệ thống như Tệp và Chỉnh sửa.

00:16:03.000 --> 00:16:10.000
Chúng bao gồm tất cả các lệnh hệ thống, như Hoàn tác và Làm lại, Dán và Khớp Kiểu, v.v.

00:16:10.000 --> 00:16:24.000
iPadOS 15 thêm lệnh In vào danh sách các lệnh hệ thống này, ứng dụng nào có thể nhận được bằng cách thêm khóa UIApplication SupportsPrintCommand vào Info.plist của họ.

00:16:24.000 --> 00:16:35.000
Giờ đây, các ứng dụng iPad trên iPadOS 15 hỗ trợ hệ thống menu chính, chúng có thể sử dụng UIMenuBuilder API để tùy chỉnh nó, giống như các ứng dụng Mac Catalyst.

00:16:35.000 --> 00:16:43.000
Trên thực tế, nếu bạn đã có phiên bản Mac Catalyst của ứng dụng, bạn đã hoàn thành hầu hết công việc.

00:16:43.000 --> 00:16:48.000
Các ứng dụng nên sử dụng trình tạo để thêm tất cả các lệnh chính được hỗ trợ vào menu chính của chúng.

00:16:48.000 --> 00:17:01.000
Đây là một thay đổi so với cách các ứng dụng trước đây sẽ khai báo các phím tắt: bằng cách ghi đè thuộc tính keyCommands trên UIResponder hoặc bằng cách gọi addKeyCommand(_:) trên bộ điều khiển chế độ xem.

00:17:01.000 --> 00:17:10.000
Các lệnh được xác định theo cách này vẫn hoạt động, nhưng chúng sẽ xuất hiện trong một phần chưa được phân loại riêng biệt của giao diện mới.

00:17:10.000 --> 00:17:16.000
Các ứng dụng nên xóa các khai báo lệnh chính như thế này và thay vào đó thêm chúng vào menu chính.

00:17:16.000 --> 00:17:22.000
Để tùy chỉnh menu chính, hãy ghi đè buildMenu(withbuilder:) trong AppDelegate của bạn.

00:17:22.000 --> 00:17:29.000
UIKit gọi phương thức này khi khởi chạy ứng dụng và chuyển vào đối tượng UIMenuBuilder.

00:17:29.000 --> 00:17:33.000
Các ứng dụng nên kiểm tra xem trình tạo có đang sửa đổi hệ thống menu chính hay không.

00:17:33.000 --> 00:17:38.000
Nếu vậy, họ có thể sử dụng trình tạo để thực hiện các tùy chỉnh.

00:17:38.000 --> 00:17:44.000
Giả sử một ứng dụng muốn một số lệnh chính trong menu Tệp để làm việc với các tab.

00:17:44.000 --> 00:17:53.000
Ứng dụng chỉ đơn giản là tạo một menu con bằng API UIMenu và thêm các lệnh phím mong muốn làm menu con.

00:17:53.000 --> 00:18:02.000
Sau đó, ứng dụng gọi phương thức insertChild trên đối tượng trình tạo để chèn menu con vào menu Tệp.

00:18:02.000 --> 00:18:11.000
Để tham chiếu một phần tử hiện có trong hệ thống menu chính - như menu Tệp, trong trường hợp này - các ứng dụng nên chỉ định số nhận dạng của phần tử.

00:18:11.000 --> 00:18:19.000
Các số nhận dạng menu hệ thống tích hợp được định nghĩa là hằng số trong UIMenu.Identifier.

00:18:19.000 --> 00:18:23.000
Các ứng dụng cũng có thể dễ dàng tạo các danh mục menu của riêng chúng.

00:18:23.000 --> 00:18:29.000
Tại đây, ứng dụng tạo ra một menu Dấu trang - một lần nữa, sử dụng UIMenu API.

00:18:29.000 --> 00:18:37.000
Sau đó, ứng dụng sử dụng trình tạo để chèn menu đó vào menu gốc - trong trường hợp này, sau menu Xem hệ thống.

00:18:37.000 --> 00:18:39.000
Đó là tất cả những gì nó cần!

00:18:39.000 --> 00:18:46.000
Bây giờ, trình tạo có thể được sử dụng để chèn thêm vào menu Dấu trang, giống như với menu Tệp.

00:18:46.000 --> 00:18:52.000
Chỉ cần chuyển mã định danh của menu mới, mà UIKit tự động tạo ra.

00:18:52.000 --> 00:18:55.000
Bây giờ, tôi tiếp tục đề cập đến các số nhận dạng.

00:18:55.000 --> 00:19:04.000
UIMenuBuilder sẽ thực thi rằng mỗi phần tử trong hệ thống menu chính có một mã định danh duy nhất, bao gồm các lệnh riêng lẻ.

00:19:04.000 --> 00:19:11.000
Giả sử một ứng dụng chèn các lệnh chính để hiển thị nội dung dưới dạng danh sách hoặc dưới dạng lưới.

00:19:11.000 --> 00:19:15.000
Cả hai lệnh đều chia sẻ cùng một hành động: changeViewMode(_:).

00:19:15.000 --> 00:19:25.000
Trong hệ thống menu chính, các lệnh được xác định ngầm bởi hành động của chúng, vì vậy cả hai lệnh này đều có chung số nhận dạng.

00:19:25.000 --> 00:19:31.000
UIMenuBuilder sẽ không cho phép chèn cả hai lệnh trừ khi chúng có các số nhận dạng khác nhau.

00:19:31.000 --> 00:19:37.000
Một cách để phân biệt các lệnh này là cung cấp cho chúng các giá trị propertyList khác nhau.

00:19:37.000 --> 00:19:44.000
Nhưng một cách tốt hơn là chỉ cần cung cấp cho mỗi lệnh một hành động duy nhất mô tả những gì nó làm cụ thể.

00:19:44.000 --> 00:19:51.000
Trình tạo cũng thực thi rằng các kết hợp phím tắt trong menu chính là duy nhất.

00:19:51.000 --> 00:19:56.000
Giả sử một ứng dụng chèn lệnh phím Get Info trên Command-I.

00:19:56.000 --> 00:20:05.000
Bởi vì phím tắt in nghiêng hệ thống trong menu kiểu văn bản chia sẻ cùng một phím tắt, việc chèn này cũng sẽ thất bại.

00:20:05.000 --> 00:20:08.000
Một lần nữa, có hai giải pháp.

00:20:08.000 --> 00:20:16.000
Ứng dụng có thể thay đổi phím tắt Get Info thành một cái gì đó không va chạm với một phím tắt hiện có, chẳng hạn như Control-Command-I.

00:20:16.000 --> 00:20:23.000
Ngoài ra, ứng dụng có thể yêu cầu người xây dựng xóa các lệnh kiểu văn bản nếu chúng không cần thiết.

00:20:23.000 --> 00:20:36.000
Nếu một phần chèn bao gồm một bản sao, thì UIMenuBuilder sẽ thất bại trong việc chèn đó và ghi lại một lỗi trong bảng điều khiển hiển thị các lệnh phím trùng lặp hoặc các số nhận dạng được chia sẻ.

00:20:36.000 --> 00:20:46.000
Nếu bạn thấy các phần chèn của mình không xuất hiện, rất có thể có một bản sao ở đâu đó, vì vậy hãy tìm các bản ghi như thế này trong bảng điều khiển.

00:20:46.000 --> 00:20:56.000
Sau khi cuộc gọi buildMenu (với builder:) kết thúc, menu chính của ứng dụng xuất hiện trong thanh menu Mac và lớp phủ phím tắt iPad.

00:20:56.000 --> 00:20:58.000
Tuy nhiên, có một vấn đề.

00:20:58.000 --> 00:21:05.000
Ứng dụng đã thêm một menu con với các lệnh để sắp xếp dấu trang theo tên hoặc theo ngày.

00:21:05.000 --> 00:21:14.000
Nhưng vì lớp phủ phím tắt iPad không hiển thị hệ thống phân cấp menu con, nên không rõ những phím tắt này làm gì trên iPadOS.

00:21:14.000 --> 00:21:20.000
Đối với những tình huống như thế này, hãy đặt tiêu đề khả năng khám phá mô tả nhiều hơn trên các lệnh chính.

00:21:20.000 --> 00:21:27.000
iPadOS thích tiêu đề khả năng khám phá hơn tiêu đề thông thường nếu cả hai đều được cung cấp.

00:21:27.000 --> 00:21:37.000
Bây giờ, tôi đã đề cập trước đó rằng những người phản hồi cá nhân nên tránh khai báo các phím tắt và thay vào đó khai báo chúng trong hệ thống menu chính.

00:21:37.000 --> 00:21:44.000
Tuy nhiên, những người phản hồi vẫn nên thực hiện các phương pháp hành động cho các lệnh menu chính.

00:21:44.000 --> 00:21:51.000
Khi các lệnh chính được kích hoạt, UIKit sẽ tự động gửi hành động đến người phản hồi.

00:21:51.000 --> 00:21:56.000
UIKit thực hiện điều này bằng cách duyệt qua chuỗi phản hồi của ứng dụng.

00:21:56.000 --> 00:22:04.000
Ngay khi nó tìm thấy một người phản hồi có thể thực hiện hành động, nó sẽ gọi phương thức hành động của người phản hồi đó.

00:22:04.000 --> 00:22:10.000
Nếu không có gì trong chuỗi có thể thực hiện hành động, thì lệnh phím không thể thực hiện được.

00:22:10.000 --> 00:22:19.000
Nếu bạn chưa quen với các khái niệm UIResponder, "Hỗ trợ bàn phím phần cứng trong ứng dụng của bạn" có phần giới thiệu tuyệt vời về cách thức hoạt động của nó.

00:22:19.000 --> 00:22:24.000
"Chất lượng của một ứng dụng Mac Catalyst tuyệt vời" cũng đi sâu vào chi tiết hơn một chút.

00:22:24.000 --> 00:22:31.000
Khi UIKit thực hiện tìm kiếm phản hồi dọc theo chuỗi, nó sẽ gọi hai phương thức UIResponder hữu ích.

00:22:31.000 --> 00:22:37.000
Các ứng dụng có thể ghi đè các phương pháp này trong trình phản hồi của chúng để cải thiện các lệnh chính của chúng.

00:22:37.000 --> 00:22:46.000
Đầu tiên là canPerformAction (_:withSender:), mà UIKit sử dụng để kiểm tra xem người phản hồi có thể thực hiện một hành động hay không.

00:22:46.000 --> 00:22:55.000
Theo mặc định, điều này trả về true nếu người phản hồi thực hiện phương thức hành động đó; nếu không, nó trả về false.

00:22:55.000 --> 00:22:59.000
Người trả lời có thể ghi đè điều này để thêm logic tùy chỉnh.

00:22:59.000 --> 00:23:09.000
Ví dụ, một trình duyệt web có thể nói với UIKit rằng lệnh closeTab không thể thực hiện được nếu không có các tab đang mở.

00:23:09.000 --> 00:23:20.000
Vì UIKit không thể tìm thấy trình phản hồi mục tiêu cho hành động đó, lệnh sẽ không thể thực hiện được và nó sẽ không được hiển thị trong giao diện phím tắt.

00:23:20.000 --> 00:23:26.000
Lưu ý rằng ghi đè cho phương thức này phải gọi super cho các trường hợp chưa được xử lý.

00:23:26.000 --> 00:23:30.000
Phương thức hữu ích khác là validate(_ command:).

00:23:30.000 --> 00:23:39.000
Khi UIKit tìm thấy một người phản hồi mục tiêu cho một lệnh chính, nó sẽ gọi phương thức này trên người phản hồi đó và chuyển vào một bản sao của lệnh.

00:23:39.000 --> 00:23:47.000
Người trả lời có thể ghi đè xác thực (_ lệnh:) để cập nhật giao diện của lệnh cho trạng thái hiện tại của ứng dụng.

00:23:47.000 --> 00:23:55.000
Tại đây, ứng dụng cập nhật tiêu đề của lệnh toggleBookmark(_:) dựa trên việc trang hiện tại có được đánh dấu hay không.

00:23:55.000 --> 00:24:00.000
Tiêu đề được đặt trong phương pháp này sẽ phản ánh trong giao diện phím tắt khi nó xuất hiện.

00:24:00.000 --> 00:24:06.000
Trong iPadOS 15, UIKit đang giới thiệu một thay đổi lớn đối với chuỗi phản hồi.

00:24:06.000 --> 00:24:16.000
Khi các ứng dụng áp dụng điều hướng bàn phím với hệ thống lấy nét, thì việc đi qua người phản hồi sẽ bắt đầu ở mục tập trung thay vì người phản hồi đầu tiên.

00:24:16.000 --> 00:24:21.000
Sự thay đổi này hoạt động cực kỳ tốt với các lệnh chính.

00:24:21.000 --> 00:24:27.000
Ví dụ, ảnh cho phép người dùng làm việc với thư viện ảnh của họ chỉ bằng bàn phím.

00:24:27.000 --> 00:24:32.000
Khi người dùng tập trung một ô trong lưới, họ có thể nhấn phím cách để xem bức ảnh đó.

00:24:32.000 --> 00:24:37.000
Họ thậm chí có thể nhấn Command-C để sao chép bức ảnh đó để dán vào một ứng dụng khác.

00:24:37.000 --> 00:24:47.000
Mỗi ô thực hiện các hành động lệnh chính khác nhau và vì quá trình duyệt của người phản hồi bắt đầu tại mục được tập trung, nên các lệnh chính nhắm mục tiêu vào ô.

00:24:47.000 --> 00:24:53.000
Nói tóm lại, hệ thống tập trung tăng cấp các lệnh chính và chuỗi phản hồi.

00:24:53.000 --> 00:24:58.000
Tận dụng nó để hỗ trợ các phím tắt theo ngữ cảnh mạnh mẽ trong ứng dụng của bạn.

00:24:58.000 --> 00:25:03.000
Để tìm hiểu thêm, hãy xem "Tập trung vào điều hướng bàn phím iPad."

00:25:03.000 --> 00:25:10.000
Cuối cùng, iPadOS 15 và macOS 12 giới thiệu bản địa hóa phím tắt.

00:25:10.000 --> 00:25:19.000
Khi bạn xây dựng ứng dụng của mình với các SDK này, hệ thống sẽ tự động bản địa hóa các công cụ sửa đổi và đầu vào phím tắt cho mỗi bố cục bàn phím.

00:25:19.000 --> 00:25:22.000
Lấy phím tắt Command-backslash làm ví dụ.

00:25:22.000 --> 00:25:31.000
Mặc dù phím tắt hoạt động trên bàn phím Hoa Kỳ, nhưng không thể thực hiện trên bàn phím Nhật Bản, vì bố cục đó không có phím dấu gạch chéo ngược.

00:25:31.000 --> 00:25:34.000
Vì vậy, hệ thống sẽ ánh xạ lại phím tắt cho bàn phím tiếng Nhật.

00:25:34.000 --> 00:25:42.000
Điều này có nghĩa là các ứng dụng không nên bản địa hóa các công cụ sửa đổi hoặc đầu vào phím tắt, và thay vào đó hãy để hệ thống thực hiện công việc.

00:25:42.000 --> 00:25:50.000
Các ứng dụng cũng có thể chọn không tham gia bản địa hóa tự động, ở cấp độ toàn ứng dụng hoặc trên cơ sở mỗi phím tắt.

00:25:50.000 --> 00:25:57.000
Khi hệ thống bản địa hóa các phím tắt, nó cũng phản chiếu chúng cho bố cục từ phải sang trái.

00:25:57.000 --> 00:26:05.000
Ví dụ, một phím tắt để điều hướng ngược với dấu ngoặc Command bên trái được lật sang dấu ngoặc Command-phải.

00:26:05.000 --> 00:26:17.000
Nếu một phím tắt không nên được phản chiếu, hãy đặt thuộc tính allowsAutomaticMirroring của lệnh thành false để vô hiệu hóa phản chiếu mà không vô hiệu hóa hoàn toàn bản địa hóa tự động.

00:26:17.000 --> 00:26:21.000
iPadOS 15 là một bản phát hành lớn cho các phím tắt.

00:26:21.000 --> 00:26:25.000
Có rất nhiều cải tiến khác trên tất cả mọi thứ chúng tôi đã đề cập ngày hôm nay.

00:26:25.000 --> 00:26:32.000
Vì vậy, bạn đã áp dụng tất cả các tính năng Đa nhiệm mới và bạn đã xây dựng được sự hỗ trợ bàn phím tuyệt vời.

00:26:32.000 --> 00:26:39.000
Bây giờ, Mohammed sẽ cung cấp cho bạn một vài gợi ý để đưa ứng dụng iPad của bạn lên mức cao nhất.

00:26:39.000 --> 00:26:42.000
Mohammed Jisrawi: Cảm ơn, Anant! Xin chào, tôi là Mohammed.

00:26:42.000 --> 00:26:48.000
Hãy nói về những cải tiến mà iPadOS 15 mang lại cho con trỏ hệ thống.

00:26:48.000 --> 00:27:00.000
iPadOS 13.4 đã giới thiệu một con trỏ hệ thống thích ứng kết nối giữa giao diện người dùng dựa trên cảm ứng của iPad và độ chính xác của chuột hoặc bàn di chuột.

00:27:00.000 --> 00:27:08.000
Nếu bạn chưa quen với các tương tác con trỏ, hãy dành một chút thời gian để làm quen với chúng và xem những video trước đó.

00:27:08.000 --> 00:27:13.000
"Xây dựng cho con trỏ iPadOS" phá vỡ các API tương tác con trỏ.

00:27:13.000 --> 00:27:22.000
"Thiết kế cho Con trỏ iPadOS" đi sâu vào triết lý thiết kế đằng sau chúng và thảo luận về các phương pháp hay nhất khi áp dụng chúng trong ứng dụng của bạn.

00:27:22.000 --> 00:27:30.000
iPadOS 15 mang đến một số tương tác quen thuộc của người dùng Mac theo cách phù hợp với ngôn ngữ thiết kế của iPad.

00:27:30.000 --> 00:27:37.000
Nó cũng giới thiệu một số khái niệm mới giúp nâng cao khả năng sử dụng và sự rõ ràng.

00:27:37.000 --> 00:27:48.000
Bổ sung đầu tiên trong số những bổ sung này là lựa chọn ban nhạc, một trải nghiệm đa lựa chọn dành riêng cho con trỏ mới quen thuộc với bất kỳ ai đã sử dụng máy Mac.

00:27:48.000 --> 00:28:00.000
Trong iPadOS 15, khi bạn nhấp và kéo trong chế độ xem bộ sưu tập, con trỏ sẽ kéo dài thành hình chữ nhật và chế độ xem bộ sưu tập sẽ chọn các mục mà hình chữ nhật bao gồm.

00:28:00.000 --> 00:28:06.000
Tất nhiên điều này chuyển một cách tự nhiên sang giao diện người dùng Mac quen thuộc trên các ứng dụng Mac Catalyst.

00:28:06.000 --> 00:28:10.000
Sự tương tác này được tích hợp vào UICollectionViews không nằm trong danh sách.

00:28:10.000 --> 00:28:25.000
Bất kỳ UICollectionView nào hỗ trợ các cử chỉ đa lựa chọn một và hai ngón tay hiện có thông qua shouldBeginMultiple SelectionInteraction API sẽ tự động nhận được hành vi này trong iPadOS 15.

00:28:25.000 --> 00:28:35.000
Đối với bất kỳ thứ gì khác ngoài UICollectionView, UIBandSelectionInteraction API mới cho phép bạn dễ dàng áp dụng trải nghiệm này trong ứng dụng của mình.

00:28:35.000 --> 00:28:46.000
Vì logic lựa chọn hoàn toàn phụ thuộc vào bạn, bạn có thể hỗ trợ các hành vi lựa chọn tùy chỉnh và giao diện người dùng của bạn phản ứng với lựa chọn thay đổi theo bất kỳ cách nào bạn chọn.

00:28:46.000 --> 00:28:56.000
Để bắt đầu, hãy khởi tạo tương tác với trình xử lý lựa chọn được gọi khi con trỏ di chuyển và trạng thái của tương tác thay đổi.

00:28:56.000 --> 00:29:02.000
Sau khi nó được tạo, hãy thêm tương tác vào chế độ xem của bạn như bạn làm với bất kỳ UIInteraction nào khác.

00:29:02.000 --> 00:29:11.000
Trong trình xử lý, bạn có thể triển khai logic lựa chọn tùy chỉnh của mình bằng cách phản hồi các thay đổi trong trạng thái tương tác và selectionRect.

00:29:11.000 --> 00:29:21.000
Ở đây chúng tôi có một triển khai đơn giản đặt lựa chọn cho các mục trong selectionRect của tương tác trong khi con trỏ đang di chuyển.

00:29:21.000 --> 00:29:28.000
Sau đó, nó hoàn tất phiên lựa chọn khi nút chuột chính được nhả ra và tương tác kết thúc.

00:29:28.000 --> 00:29:37.000
Ngoài lựa chọn cơ bản, lựa chọn băng tần tích hợp của UICollectionView hỗ trợ một số phím tắt phổ biến ngay lập tức.

00:29:37.000 --> 00:29:46.000
Ví dụ, giữ phím Shift khi bắt đầu kéo khiến các mục được thêm vào lựa chọn hiện có thay vì thay thế các mục hiện được chọn.

00:29:46.000 --> 00:29:51.000
Giữ lệnh chuyển đổi trạng thái lựa chọn của các mục trong trực tràng lựa chọn.

00:29:51.000 --> 00:30:01.000
Điều này có thể được triển khai trong giao diện người dùng tùy chỉnh bằng cách sử dụng thuộc tính InitialModifierFlags của tương tác, cung cấp các khóa được giữ khi bắt đầu kéo.

00:30:01.000 --> 00:30:11.000
Vì nó là một tập hợp của tất cả các công cụ sửa đổi được nhấn, bạn có thể phản hồi các tổ hợp phím tùy ý để hỗ trợ hành vi tùy chỉnh hoặc nâng cao hơn dành riêng cho ứng dụng của bạn.

00:30:11.000 --> 00:30:16.000
Bổ sung thứ hai cho con trỏ hệ thống là khả năng gắn các phụ kiện.

00:30:16.000 --> 00:30:26.000
Các phụ kiện truyền đạt thông tin bổ sung và cung cấp các gợi ý theo ngữ cảnh bằng cách kết hợp các hình dạng phụ với con trỏ chính.

00:30:26.000 --> 00:30:32.000
Ví dụ, trong ví dụ bên trái, hai mũi tên chỉ ra rằng chế độ xem này có thể được kéo theo chiều ngang.

00:30:32.000 --> 00:30:39.000
Trong ví dụ bên phải, dấu cộng cung cấp một số ngữ cảnh bổ sung cho nút Thêm vào giỏ hàng này.

00:30:39.000 --> 00:30:44.000
Có một vài điểm khác biệt chính giữa các phụ kiện và sử dụng hình dạng con trỏ tùy chỉnh.

00:30:44.000 --> 00:30:49.000
Các phụ kiện tách biệt về mặt thị giác và thứ cấp so với con trỏ chính.

00:30:49.000 --> 00:30:58.000
Điều này được nhấn mạnh bởi thực tế là chúng có thể được hiển thị với một diện mạo khác và hoạt hình riêng biệt với con trỏ chính.

00:30:58.000 --> 00:31:06.000
Chúng là những đơn vị độc lập có thể được kết hợp và định vị xung quanh con trỏ để truyền đạt các ý tưởng khác nhau.

00:31:06.000 --> 00:31:11.000
Vì chúng độc lập, chúng có thể được kết hợp với bất kỳ kiểu con trỏ nào.

00:31:11.000 --> 00:31:20.000
Đây là một minh chứng về cách cùng một bộ phụ kiện - hai mũi tên biểu thị khả năng kéo - có thể được kết hợp với các kiểu con trỏ khác nhau.

00:31:20.000 --> 00:31:28.000
Ở bên trái, chúng được kết hợp với hiệu ứng nâng trong đó con trỏ hợp nhất với chế độ xem và nâng nó lên.

00:31:28.000 --> 00:31:37.000
Ở giữa, chúng cùng với hiệu ứng tô sáng, trong đó con trỏ biến thành hình chữ nhật tròn và đi dưới tầm nhìn.

00:31:37.000 --> 00:31:46.000
Ở bên phải, chúng xuất hiện với con trỏ hệ thống mặc định sử dụng API UIPointerStyle.system() mới.

00:31:46.000 --> 00:32:00.000
Vì vậy, chúng tôi có thể cung cấp bối cảnh bổ sung này trong khi vẫn sử dụng hiệu ứng lý tưởng cho tình huống, mà không phải hy sinh tính sống động của con trỏ và trong khi vẫn duy trì mối quan hệ sâu sắc của nó với giao diện người dùng của ứng dụng.

00:32:00.000 --> 00:32:09.000
Giống như nó làm sinh động giữa các kiểu con trỏ, hệ thống sẽ tự động làm sinh động sự xuất hiện và biến mất của các phụ kiện.

00:32:09.000 --> 00:32:14.000
Nó cũng sẽ hoạt hình liền mạch giữa hình dạng và vị trí của phụ kiện.

00:32:14.000 --> 00:32:19.000
Hành động chuyển đổi phụ kiện trong khi một hiệu ứng nhất định đang hoạt động có thể có ý nghĩa.

00:32:19.000 --> 00:32:26.000
Sự chuyển đổi như vậy có thể được sử dụng để truyền đạt sự thay đổi về trạng thái hoặc hành vi trong giao diện người dùng cơ bản.

00:32:26.000 --> 00:32:38.000
Trong ví dụ bên trái, việc chuyển đổi từ dấu cộng sang dấu không có thể chỉ ra rằng một thao tác trước đây có thể thực hiện được không còn được phép nữa.

00:32:38.000 --> 00:32:54.000
Các phụ kiện con trỏ bao gồm UIPointerShape và UIPointerAccessory. Vị trí, mô tả vị trí mong muốn như một độ lệch từ điểm giữa của con trỏ và một góc từ trên xuống.

00:32:54.000 --> 00:33:00.000
Để thuận tiện, UIKit cung cấp một số giá trị được xác định trước cho các vị trí xung quanh con trỏ.

00:33:00.000 --> 00:33:08.000
Nếu các vị trí được xác định trước không hoàn toàn phù hợp với nhu cầu của bạn, bạn có thể sử dụng chúng làm điểm khởi đầu và tùy chỉnh các thuộc tính riêng lẻ.

00:33:08.000 --> 00:33:14.000
Ví dụ này bắt đầu với vị trí topRight và tùy chỉnh độ lệch.

00:33:14.000 --> 00:33:23.000
Bạn cũng có thể xác định các vị trí hoàn toàn tùy chỉnh, như trong ví dụ này, tạo ra một vị trí với độ lệch và góc tùy chỉnh.

00:33:23.000 --> 00:33:36.000
Để thiết lập ví dụ mà chúng tôi đã thấy ở đầu phân đoạn này, chúng tôi sẽ tạo một UITargetedPreview với chế độ xem của mình và sử dụng nó để tạo UIPointerStyle với hiệu ứng nâng.

00:33:36.000 --> 00:33:44.000
Sau đó, chúng tôi sẽ đặt thuộc tính phụ kiện mới của phong cách thành một mảng chứa hai phụ kiện mũi tên của chúng tôi.

00:33:44.000 --> 00:33:52.000
UIKit cung cấp một phụ kiện mũi tên được tạo sẵn, vì vậy chúng ta chỉ có thể tạo hai trong số những thứ được đặt ở bên trái và bên phải của hiệu ứng.

00:33:52.000 --> 00:34:01.000
Vì vậy, bây giờ khi con trỏ di chuột qua chế độ xem này, hai mũi tên hoạt hình khi chế độ xem nâng lên, gợi ý rằng nó có thể được kéo.

00:34:01.000 --> 00:34:10.000
Nếu bạn đã từng cố gắng thực hiện loại tương tác này trong đó chế độ xem có hiệu ứng con trỏ có thể kéo được, bạn có thể nhận thấy điều gì đó như thế này.

00:34:10.000 --> 00:34:17.000
Khi con trỏ chạm đến cạnh của vùng con trỏ, nó sẽ rời khỏi chế độ xem được nâng lên và hiệu ứng kết thúc.

00:34:17.000 --> 00:34:25.000
Điều này thường được mong muốn, vì nó ngăn con trỏ bám vào chế độ xem khi nó di chuyển xung quanh.

00:34:25.000 --> 00:34:35.000
Tuy nhiên, trong những tình huống như thế này, trải nghiệm lý tưởng sẽ là hiệu ứng con trỏ vẫn ổn định và bám vào chế độ xem và theo dõi nó khi nó được kéo.

00:34:35.000 --> 00:34:43.000
Để kích hoạt tốt hơn các loại tương tác này, iPadOS 15 giới thiệu khái niệm chốt rìu trên UIPointerRegion.

00:34:43.000 --> 00:34:51.000
Khi một vùng bám dọc theo một trục nhất định, hiệu ứng con trỏ của nó đi theo con trỏ dọc theo trục khi nhấn nút chuột chính.

00:34:51.000 --> 00:34:59.000
Vùng chốt theo chiều ngang cho phép bạn kéo tự do dọc theo trục x trong khi vẫn dải cao su dọc theo trục y.

00:34:59.000 --> 00:35:04.000
Một cái chốt theo chiều dọc cho phép bạn kéo tự do dọc theo trục y.

00:35:04.000 --> 00:35:09.000
Và một cái chốt dọc theo cả hai cho phép bạn kéo tự do dọc theo cả hai trục.

00:35:09.000 --> 00:35:14.000
Những công cụ mới này có thể được sử dụng để xây dựng một số trải nghiệm mới thực sự mạnh mẽ.

00:35:14.000 --> 00:35:19.000
Ở đây chúng được kết hợp trong một ứng dụng chỉnh sửa tài liệu như Pages hoặc Keynote.

00:35:19.000 --> 00:35:23.000
Hình ảnh này có thể được chọn bằng cách sử dụng lựa chọn ban nhạc.

00:35:23.000 --> 00:35:35.000
Chọn hình ảnh khiến các chỉ báo kéo xuất hiện và khi con trỏ di chuột qua một chỉ báo, các phụ kiện xuất hiện để gợi ý về cách hình ảnh sẽ được thay đổi kích thước nếu nó được kéo.

00:35:35.000 --> 00:35:43.000
Và cuối cùng, chốt cho phép hiệu ứng con trỏ và các phụ kiện tuân theo cử chỉ thay đổi kích thước bị khóa trục.

00:35:43.000 --> 00:35:48.000
Đây chỉ là một số cải tiến mà iPadOS 15 mang lại cho iPad.

00:35:48.000 --> 00:35:52.000
Tận dụng chúng khi áp dụng để thực sự tối đa hóa tiện ích của ứng dụng của bạn.

00:35:52.000 --> 00:35:58.000
Áp dụng các cảnh nổi bật để cung cấp cho mọi người một cái nhìn tập trung, không bị gián đoạn về nội dung ứng dụng của bạn.

00:35:58.000 --> 00:36:08.000
Trao quyền cho họ để đạt được các tác vụ phức tạp một cách nhanh chóng với menu phím tắt mới và tăng năng suất của họ với các tính năng con trỏ mới.

00:36:08.000 --> 00:36:10.000
Cảm ơn vì đã xem!

00:36:10.000 --> 23:59:59.000
♪

