WEBVTT

00:00:00.000 --> 00:00:05.000
♪ Nhạc bass đang phát ♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:14.000
Courtland Idstrom: Xin chào, tên tôi là Courtland Idstrom, và tôi là một kỹ sư trong nhóm RealityKit.

00:00:14.000 --> 00:00:19.000
Trong video này, tôi sẽ chỉ cho bạn cách sử dụng các tính năng kết xuất mới trong RealityKit 2.

00:00:19.000 --> 00:00:24.000
RealityKit là một khuôn khổ được thiết kế để giúp việc xây dựng các ứng dụng AR trở nên đơn giản và trực quan.

00:00:24.000 --> 00:00:30.000
Kết xuất là một phần quan trọng của RealityKit, tập trung vào kết xuất dựa trên vật lý, chân thực cao.

00:00:30.000 --> 00:00:36.000
Kể từ lần phát hành đầu tiên vào năm 2019, chúng tôi đã làm việc với phản hồi của bạn và chúng tôi đang gửi một bản cập nhật lớn cho RealityKit.

00:00:36.000 --> 00:00:52.000
Trong phiên "Dive into Reality Kit 2", chúng tôi đã đề cập đến sự phát triển của RealityKit, cung cấp nhiều cải tiến - từ các bản cập nhật cho hệ thống ECS, khả năng vật liệu và hoạt hình phát triển hơn, đồng thời tạo ra các tài nguyên âm thanh và kết cấu trong thời gian chạy.

00:00:52.000 --> 00:00:58.000
Để giới thiệu những cải tiến này, chúng tôi đã xây dựng một ứng dụng biến phòng khách của bạn thành một bể cá dưới nước.

00:00:58.000 --> 00:01:02.000
Trong buổi nói chuyện này, chúng tôi sẽ hiển thị một số tính năng kết xuất mới đã đi vào ứng dụng.

00:01:02.000 --> 00:01:10.000
RealityKit 2 cung cấp khả năng kiểm soát và linh hoạt với cách các đối tượng được kết xuất, cho phép bạn tạo ra trải nghiệm AR tốt hơn nữa.

00:01:10.000 --> 00:01:18.000
Năm nay chúng tôi mang lại những tiến bộ cho hệ thống vật liệu của mình, cho phép bạn thêm tài liệu của riêng mình bằng cách tạo ra các bộ đổ bóng kim loại tùy chỉnh.

00:01:18.000 --> 00:01:24.000
Hiệu ứng bài đăng tùy chỉnh cho phép bạn tăng cường hiệu ứng bài đăng của RealityKit bằng hiệu ứng bài đăng của riêng bạn.

00:01:24.000 --> 00:01:31.000
Các API lưới mới cho phép tạo, kiểm tra và sửa đổi lưới trong thời gian chạy.

00:01:31.000 --> 00:01:37.000
Hãy bắt đầu với tính năng được yêu cầu nhiều nhất trong RealityKit 2, hỗ trợ cho các bộ đổ bóng tùy chỉnh.

00:01:37.000 --> 00:01:41.000
Kết xuất của RealityKit xoay quanh một mô hình kết xuất dựa trên vật lý.

00:01:41.000 --> 00:01:47.000
Bộ đổ bóng tích hợp của nó giúp dễ dàng tạo ra các mô hình trông tự nhiên bên cạnh các vật thể thực trong nhiều điều kiện ánh sáng.

00:01:47.000 --> 00:01:56.000
Năm nay, chúng tôi đang xây dựng trên những bộ đổ bóng dựa trên vật lý này và phơi bày khả năng bạn tùy chỉnh hình học và bề mặt của các mô hình bằng cách sử dụng bộ đổ bóng.

00:01:56.000 --> 00:01:59.000
API đổ bóng đầu tiên của chúng tôi là công cụ sửa đổi hình học.

00:01:59.000 --> 00:02:10.000
Công cụ sửa đổi hình học là một chương trình, được viết bằng Ngôn ngữ tạo bóng kim loại, mang đến cho bạn cơ hội thay đổi các đỉnh của một đối tượng mỗi khung hình khi nó được hiển thị trên GPU.

00:02:10.000 --> 00:02:16.000
Điều này bao gồm di chuyển chúng và tùy chỉnh các thuộc tính của chúng, chẳng hạn như màu sắc, bình thường hoặc tia cực tím.

00:02:16.000 --> 00:02:24.000
Nó được chạy bên trong bộ đổ bóng đỉnh của RealityKit và hoàn hảo cho hoạt hình xung quanh, biến dạng, hệ thống hạt và biển quảng cáo.

00:02:24.000 --> 00:02:27.000
Rong biển của chúng tôi là một ví dụ tuyệt vời về hoạt hình xung quanh.

00:02:27.000 --> 00:02:31.000
Rong biển đang di chuyển chậm do sự chuyển động của nước xung quanh nó.

00:02:31.000 --> 00:02:33.000
Chúng ta hãy xem xét kỹ hơn.

00:02:33.000 --> 00:02:41.000
Ở đây bạn có thể thấy khung dây của rong biển do nghệ sĩ của chúng tôi tạo ra; điều này cho thấy các đỉnh và hình tam giác bao gồm lưới.

00:02:41.000 --> 00:02:46.000
Chúng ta sẽ viết một chương trình đổ bóng thực thi trên mỗi đỉnh để tạo chuyển động của chúng ta.

00:02:46.000 --> 00:02:50.000
Chúng ta sẽ sử dụng sóng sin, một hàm tuần hoàn đơn giản, để tạo ra chuyển động.

00:02:50.000 --> 00:02:59.000
Chúng tôi đang mô phỏng các dòng nước nên chúng tôi muốn các đỉnh gần đó hoạt động tương tự, bất kể quy mô hay hướng của mô hình của chúng.

00:02:59.000 --> 00:03:04.000
Vì lý do này, chúng tôi sử dụng vị trí thế giới của đỉnh làm đầu vào cho hàm sin.

00:03:04.000 --> 00:03:08.000
Chúng tôi cũng bao gồm một giá trị thời gian, để nó di chuyển theo thời gian.

00:03:08.000 --> 00:03:12.000
Sóng sin đầu tiên của chúng tôi nằm ở chiều Y để tạo ra chuyển động lên xuống.

00:03:12.000 --> 00:03:16.000
Để kiểm soát chu kỳ chuyển động, chúng ta sẽ thêm một thang đo không gian.

00:03:16.000 --> 00:03:21.000
Và chúng ta có thể kiểm soát lượng chuyển động của nó với biên độ.

00:03:21.000 --> 00:03:26.000
Chúng tôi sẽ áp dụng cùng một chức năng cho các kích thước X và Z để nó di chuyển theo cả ba trục.

00:03:26.000 --> 00:03:30.000
Bây giờ, hãy nhìn vào mô hình nói chung.

00:03:30.000 --> 00:03:39.000
Một điều chúng tôi chưa tính đến: các đỉnh gần gốc thân cây có rất ít chỗ để di chuyển, trong khi các đỉnh có quyền tự do di chuyển cao nhất.

00:03:39.000 --> 00:03:53.000
Để mô phỏng điều này, chúng ta có thể sử dụng tọa độ y của đỉnh liên quan đến nguồn gốc của đối tượng làm hệ số chia tỷ lệ cho cả ba trục, điều này cho chúng ta công thức cuối cùng.

00:03:53.000 --> 00:03:58.000
Bây giờ chúng ta đã có kế hoạch cho bộ đổ bóng của mình, chúng ta hãy xem nơi để tìm các thông số này.

00:03:58.000 --> 00:04:02.000
Các thông số hình học được tổ chức thành một vài loại.

00:04:02.000 --> 00:04:07.000
Đầu tiên là đồng nhất, các giá trị giống nhau cho mọi đỉnh của đối tượng trong một khung.

00:04:07.000 --> 00:04:10.000
Chúng ta cần thời gian cho rong biển của chúng ta.

00:04:10.000 --> 00:04:18.000
Kết cấu chứa tất cả các kết cấu được tạo ra như một phần của mô hình, cộng với một khe tùy chỉnh bổ sung, mà bạn có thể sử dụng khi bạn thấy phù hợp.

00:04:18.000 --> 00:04:26.000
Các hằng số vật liệu có bất kỳ tham số nào, chẳng hạn như tỷ lệ sắc thái hoặc độ mờ, được tạo ra với đối tượng hoặc được đặt thông qua mã.

00:04:26.000 --> 00:04:32.000
Hình học chứa một số giá trị chỉ đọc, chẳng hạn như vị trí mô hình của đỉnh hiện tại hoặc ID đỉnh.

00:04:32.000 --> 00:04:38.000
Chúng ta cần cả vị trí mô hình và thế giới cho phong trào rong biển của chúng ta.

00:04:38.000 --> 00:04:44.000
Hình học cũng có các giá trị đọc-ghi, bao gồm bình thường, tia cực tím và độ lệch vị trí mô hình.

00:04:44.000 --> 00:04:49.000
Khi chúng tôi đã tính toán độ lệch của mình, chúng tôi sẽ lưu trữ nó ở đây để di chuyển các đỉnh của chúng tôi.

00:04:49.000 --> 00:04:52.000
Hãy đi sâu vào Metal shader.

00:04:52.000 --> 00:04:55.000
Chúng tôi bắt đầu bằng cách bao gồm RealityKit.h.

00:04:55.000 --> 00:04:59.000
Bây giờ chúng tôi khai báo một hàm với thuộc tính hàm hiển thị.

00:04:59.000 --> 00:05:04.000
Điều này hướng dẫn trình biên dịch làm cho nó có sẵn riêng biệt với các chức năng khác.

00:05:04.000 --> 00:05:09.000
Hàm nhận một tham số duy nhất, đó là geometry_parameters của RealityKit.

00:05:09.000 --> 00:05:12.000
Chúng tôi sẽ truy xuất tất cả các giá trị thông qua đối tượng này.

00:05:12.000 --> 00:05:18.000
Sử dụng thành viên hình học của các tham số, chúng tôi sẽ yêu cầu cả vị trí thế giới và vị trí mô hình.

00:05:18.000 --> 00:05:24.000
Tiếp theo chúng tôi tính toán độ lệch pha, dựa trên vị trí thế giới ở đỉnh và thời gian.

00:05:24.000 --> 00:05:29.000
Sau đó, chúng tôi áp dụng công thức của mình để tính toán độ lệch của đỉnh này.

00:05:29.000 --> 00:05:34.000
Chúng tôi lưu trữ độ lệch trên hình học, sẽ được thêm vào vị trí mô hình của đỉnh.

00:05:34.000 --> 00:05:39.000
Chúng tôi có công cụ sửa đổi hình học của mình, nhưng nó vẫn chưa được kết nối với rong biển của chúng tôi.

00:05:39.000 --> 00:05:43.000
Hãy chuyển sang lớp con ARView của chúng ta, được viết bằng Swift.

00:05:43.000 --> 00:05:47.000
Chúng tôi bắt đầu bằng cách tải thư viện Metal mặc định của ứng dụng, có chứa bộ đổ bóng của chúng tôi.

00:05:47.000 --> 00:05:52.000
Tiếp theo, chúng tôi xây dựng một geometryModifier bằng cách sử dụng tên và thư viện đổ bóng của chúng tôi.

00:05:52.000 --> 00:05:56.000
Đối với mỗi vật liệu trên rong biển, chúng tôi tạo ra một vật liệu tùy chỉnh mới.

00:05:56.000 --> 00:06:07.000
Chúng tôi chuyển vật liệu hiện có làm tham số đầu tiên cho CustomMaterial, để nó kế thừa các kết cấu và thuộc tính vật liệu từ vật liệu cơ bản trong khi thêm công cụ sửa đổi hình học của chúng tôi.

00:06:07.000 --> 00:06:12.000
Nó trông khá đẹp! Kể từ khi chúng tôi ở dưới nước, chúng tôi đã giữ hoạt hình khá chậm.

00:06:12.000 --> 00:06:19.000
Bằng cách điều chỉnh biên độ và pha, hiệu ứng tương tự có thể được mở rộng sang cỏ, cây cối hoặc các tán lá khác.

00:06:19.000 --> 00:06:23.000
Bây giờ chúng ta đã chỉ ra cách sửa đổi hình học, hãy nói về bóng râm.

00:06:23.000 --> 00:06:28.000
Đây là con bạch tuộc của chúng tôi từ cảnh dưới nước, trông tuyệt vời với bộ đổ bóng tích hợp của chúng tôi.

00:06:28.000 --> 00:06:32.000
Khi họ làm vậy, bạch tuộc của chúng ta chuyển đổi giữa nhiều ngoại hình.

00:06:32.000 --> 00:06:35.000
Cái nhìn thứ hai có màu đỏ.

00:06:35.000 --> 00:06:40.000
Nghệ sĩ của chúng tôi đã tạo ra hai kết cấu màu cơ bản, một cho mỗi diện mạo.

00:06:40.000 --> 00:06:46.000
Ngoài sự thay đổi màu sắc, bạch tuộc đỏ có giá trị nhám cao hơn, làm cho nó ít phản chiếu hơn.

00:06:46.000 --> 00:06:52.000
Và, để làm cho bạch tuộc của chúng tôi trở nên đặc biệt hơn, chúng tôi muốn tạo ra một sự chuyển đổi tốt đẹp giữa các ngoại hình.

00:06:52.000 --> 00:06:56.000
Ở đây bạn có thể thấy quá trình chuyển đổi đang hoạt động.

00:06:56.000 --> 00:06:58.000
Mê hoặc.

00:06:58.000 --> 00:07:05.000
Mặc dù mỗi cái nhìn có thể được mô tả như một vật liệu dựa trên vật lý, nhưng đối với chính quá trình chuyển đổi, chúng ta cần viết một bộ đổ bóng bề mặt.

00:07:05.000 --> 00:07:07.000
Vậy bộ đổ bóng bề mặt là gì?

00:07:07.000 --> 00:07:11.000
Bộ đổ bóng bề mặt cho phép bạn xác định diện mạo của một vật thể.

00:07:11.000 --> 00:07:15.000
Nó chạy bên trong bộ đổ bóng đoạn cho mọi điểm ảnh có thể nhìn thấy của một đối tượng.

00:07:15.000 --> 00:07:22.000
Ngoài màu sắc, điều này bao gồm các đặc tính bề mặt như bình thường, gương và nhám.

00:07:22.000 --> 00:07:28.000
Bạn có thể viết đổ bóng giúp tăng cường diện mạo của đối tượng hoặc thay thế hoàn toàn, tạo ra các hiệu ứng mới.

00:07:28.000 --> 00:07:31.000
Chúng tôi đã thấy hai kết cấu màu cơ bản cho bạch tuộc của chúng tôi.

00:07:31.000 --> 00:07:36.000
Đối với hiệu ứng chuyển tiếp, nghệ sĩ của chúng tôi đã mã hóa một kết cấu đặc biệt cho chúng tôi.

00:07:36.000 --> 00:07:40.000
Kết cấu này thực sự là sự kết hợp của ba lớp khác nhau.

00:07:40.000 --> 00:07:44.000
Có một lớp nhiễu ở trên cùng tạo ra các mẫu chuyển tiếp cục bộ.

00:07:44.000 --> 00:07:51.000
Chúng ta có một lớp chuyển tiếp, quyết định chuyển động tổng thể, bắt đầu từ đầu và di chuyển về phía các xúc tu.

00:07:51.000 --> 00:07:59.000
Và có một lớp mặt nạ cho các khu vực mà chúng ta không muốn thay đổi màu sắc, chẳng hạn như mắt và mặt dưới của xúc tu.

00:07:59.000 --> 00:08:06.000
Ba lớp này được kết hợp thành các kênh màu đỏ, xanh lá cây và xanh dương của kết cấu của chúng tôi, mà chúng tôi gán cho khe kết cấu tùy chỉnh.

00:08:06.000 --> 00:08:12.000
Với kết cấu của chúng tôi được thiết lập, hãy xem cách truy cập chúng từ bộ đổ bóng bề mặt.

00:08:12.000 --> 00:08:18.000
Tương tự như công cụ sửa đổi hình học, bộ đổ bóng bề mặt có quyền truy cập vào đồng phục, kết cấu và hằng số vật liệu.

00:08:18.000 --> 00:08:21.000
Thời gian là đầu vào cho quá trình chuyển đổi bạch tuộc của chúng ta.

00:08:21.000 --> 00:08:29.000
Chúng tôi sẽ lấy mẫu kết cấu được tạo bằng mô hình của chúng tôi và đọc các hằng số vật liệu, cho phép nghệ sĩ của chúng tôi thực hiện các điều chỉnh trên toàn mô hình.

00:08:29.000 --> 00:08:33.000
Hình học - chẳng hạn như vị trí, bình thường hoặc tia cực tím - xuất hiện trong cấu trúc hình học.

00:08:33.000 --> 00:08:37.000
Đây là những đầu ra nội suy từ bộ đổ bóng đỉnh.

00:08:37.000 --> 00:08:40.000
Chúng tôi sẽ sử dụng UV0 làm tọa độ kết cấu của chúng tôi.

00:08:40.000 --> 00:08:42.000
Một bộ đổ bóng bề mặt viết một cấu trúc bề mặt.

00:08:42.000 --> 00:08:48.000
Các thuộc tính bắt đầu với các giá trị mặc định và chúng tôi có thể tự do tính toán các giá trị này theo bất kỳ cách nào chúng tôi thấy phù hợp.

00:08:48.000 --> 00:08:51.000
Chúng tôi sẽ tính toán màu cơ bản và màu bình thường.

00:08:51.000 --> 00:08:56.000
Sau đó, bốn thông số bề mặt: độ nhám, kim loại, tắc môi trường xung quanh và gương.

00:08:56.000 --> 00:09:00.000
Bây giờ chúng ta đã biết giá trị của mình tồn tại ở đâu, hãy bắt đầu viết đổ bóng của chúng ta.

00:09:00.000 --> 00:09:02.000
Chúng tôi sẽ làm điều này trong ba bước.

00:09:02.000 --> 00:09:09.000
Đầu tiên hãy tính giá trị chuyển tiếp, trong đó 0 là một con bạch tuộc màu tím hoàn toàn và 1 là màu đỏ hoàn toàn.

00:09:09.000 --> 00:09:16.000
Sử dụng giá trị chuyển tiếp, chúng tôi sẽ tính toán màu sắc và chuẩn mực và sau đó tinh chỉnh bằng cách gán các thuộc tính vật liệu.

00:09:16.000 --> 00:09:17.000
Hãy bắt đầu nào.

00:09:17.000 --> 00:09:19.000
Bước đầu tiên: chuyển đổi.

00:09:19.000 --> 00:09:24.000
Chúng tôi đang xây dựng hàm bề mặt bạch tuộc, lấy đối số surface_parameters.

00:09:24.000 --> 00:09:27.000
Vì chúng tôi đang sử dụng kết cấu, chúng tôi khai báo một bộ lấy mẫu.

00:09:27.000 --> 00:09:33.000
Ở bên phải, bạn có thể thấy bạch tuộc của chúng ta trông như thế nào với một bóng đổ bóng bề mặt trống rỗng - nó có màu xám và hơi sáng bóng.

00:09:33.000 --> 00:09:38.000
RealityKit giúp bạn kiểm soát hoàn toàn những gì đóng góp hoặc không đóng góp vào sự xuất hiện của người mẫu của bạn.

00:09:38.000 --> 00:09:41.000
Để tính toán màu sắc, có một vài điều chúng ta cần làm trước.

00:09:41.000 --> 00:09:44.000
Chúng tôi sẽ lưu trữ một số biến số tiện lợi.

00:09:44.000 --> 00:09:48.000
Chúng tôi truy cập UV0 của mình, chúng tôi sẽ sử dụng làm tọa độ kết cấu.

00:09:48.000 --> 00:09:56.000
Metal và USD có các hệ tọa độ kết cấu khác nhau, vì vậy chúng tôi sẽ đảo ngược tọa độ y để khớp với các kết cấu được tải từ USD.

00:09:56.000 --> 00:10:01.000
Bây giờ chúng tôi sẽ lấy mẫu kết cấu chuyển tiếp của mình - kết cấu ba lớp mà nghệ sĩ của chúng tôi đã tạo ra.

00:10:01.000 --> 00:10:09.000
Nghệ sĩ của chúng tôi đã thiết lập một hàm nhỏ lấy giá trị mặt nạ cộng với thời gian và trả về 0 đến 1 giá trị cho pha trộn và pha trộn màu.

00:10:09.000 --> 00:10:13.000
Bước thứ hai: màu sắc và bình thường.

00:10:13.000 --> 00:10:19.000
Với biến pha trộn được tính toán trước đây của chúng tôi, bây giờ chúng tôi có thể tính toán màu của bạch tuộc và xem quá trình chuyển đổi.

00:10:19.000 --> 00:10:27.000
Để làm điều này, chúng tôi lấy mẫu hai kết cấu: màu cơ bản và màu cơ bản phụ, mà chúng tôi đã lưu trữ trong emissive_color.

00:10:27.000 --> 00:10:32.000
Sau đó, chúng tôi pha trộn giữa hai màu bằng cách sử dụng colorBlend được tính toán trước đó.

00:10:32.000 --> 00:10:38.000
Chúng ta sẽ nhân với base_color_tint - một giá trị từ vật liệu - và đặt màu cơ bản của chúng ta trên bề mặt.

00:10:38.000 --> 00:10:46.000
Tiếp theo chúng ta sẽ áp dụng bản đồ bình thường, thêm độ lệch bề mặt, đáng chú ý nhất trên đầu và xúc tu.

00:10:46.000 --> 00:10:52.000
Chúng tôi lấy mẫu kết cấu bản đồ bình thường, giải nén giá trị của nó và sau đó đặt trên đối tượng bề mặt.

00:10:52.000 --> 00:10:55.000
Về các thuộc tính vật liệu.

00:10:55.000 --> 00:10:58.000
Đây là bạch tuộc của chúng tôi cho đến nay, với màu sắc và bình thường.

00:10:58.000 --> 00:11:01.000
Hãy xem các đặc tính bề mặt ảnh hưởng đến vẻ ngoài của nó như thế nào.

00:11:01.000 --> 00:11:13.000
Độ nhám, mà bạn sẽ thấy ở phần dưới cơ thể; tắc nghẽn xung quanh, sẽ làm tối phần dưới; và gương, cho chúng ta một sự phản chiếu tốt đẹp trên mắt và một số định nghĩa bổ sung trên cơ thể.

00:11:13.000 --> 00:11:15.000
Hãy thêm những thứ này vào đổ bóng của chúng ta.

00:11:15.000 --> 00:11:19.000
Chúng tôi lấy mẫu bốn kết cấu trên mô hình, một cho mỗi thuộc tính.

00:11:19.000 --> 00:11:23.000
Tiếp theo chúng tôi chia tỷ lệ các giá trị này với các cài đặt vật liệu.

00:11:23.000 --> 00:11:29.000
Ngoài ra, chúng tôi cũng đang tăng độ nhám khi chúng tôi chuyển từ màu tím sang màu đỏ.

00:11:29.000 --> 00:11:32.000
Sau đó, chúng tôi đặt bốn giá trị của mình trên bề mặt.

00:11:32.000 --> 00:11:36.000
Tương tự như trước đây, chúng ta cần áp dụng bộ đổ bóng cho mô hình của mình.

00:11:36.000 --> 00:11:41.000
Chúng tôi gán tài liệu này cho mô hình của chúng tôi trong lớp con ARView của chúng tôi.

00:11:41.000 --> 00:11:46.000
Đầu tiên chúng tôi tải hai kết cấu bổ sung của mình, sau đó tải bộ đổ bóng bề mặt của chúng tôi.

00:11:46.000 --> 00:11:55.000
Giống như trước đây, chúng tôi đang xây dựng các vật liệu mới từ vật liệu cơ bản của vật thể, lần này với một bộ đổ bóng bề mặt và hai kết cấu bổ sung của chúng tôi.

00:11:55.000 --> 00:11:57.000
Và chúng ta đã hoàn thành.

00:11:57.000 --> 00:12:05.000
Vì vậy, tóm lại, chúng tôi đã hiển thị hoạt ảnh rong biển bằng cách sử dụng các công cụ sửa đổi hình học và cách xây dựng quá trình chuyển đổi bạch tuộc với các bộ đổ bóng bề mặt.

00:12:05.000 --> 00:12:11.000
Mặc dù chúng tôi đã trình diễn chúng một cách riêng biệt, bạn có thể kết hợp cả hai để có hiệu ứng thú vị hơn nữa.

00:12:11.000 --> 00:12:18.000
Chuyển sang một tính năng được yêu cầu cao khác, hỗ trợ thêm hiệu ứng xử lý bài đăng tùy chỉnh.

00:12:18.000 --> 00:12:29.000
RealityKit đi kèm với một bộ phong phú các hiệu ứng bài đăng phù hợp với máy ảnh như làm mờ chuyển động, nhiễu máy ảnh và độ sâu trường ảnh.

00:12:29.000 --> 00:12:35.000
Tất cả các hiệu ứng này đều được thiết kế để làm cho các đối tượng ảo và thực có cảm giác như chúng là một phần của cùng một môi trường.

00:12:35.000 --> 00:12:38.000
Những thứ này có sẵn để bạn tùy chỉnh trên ARView.

00:12:38.000 --> 00:12:43.000
Năm nay, chúng tôi cũng đang phơi bày khả năng để bạn tạo ra các hiệu ứng toàn màn hình của riêng mình.

00:12:43.000 --> 00:12:50.000
Điều này cho phép bạn tận dụng RealityKit cho chủ nghĩa hiện thực của ảnh và thêm các hiệu ứng mới để điều chỉnh kết quả cho ứng dụng của bạn.

00:12:50.000 --> 00:12:52.000
Vậy quy trình đăng bài là gì?

00:12:52.000 --> 00:13:00.000
Quá trình đăng bài là một trình đổ bóng hoặc một loạt các trình đổ bóng thực thi sau khi các đối tượng đã được hiển thị và sáng.

00:13:00.000 --> 00:13:04.000
Nó cũng xảy ra sau bất kỳ hiệu ứng bài đăng RealityKit nào.

00:13:04.000 --> 00:13:09.000
Đầu vào của nó là hai kết cấu: màu sắc và bộ đệm độ sâu.

00:13:09.000 --> 00:13:16.000
Bộ đệm độ sâu được hiển thị dưới dạng thang độ xám ở đây; nó chứa giá trị khoảng cách cho mỗi điểm ảnh so với máy ảnh.

00:13:16.000 --> 00:13:20.000
Một quá trình đăng bài ghi kết quả của nó vào một kết cấu màu đích.

00:13:20.000 --> 00:13:25.000
Hiệu ứng bài viết đơn giản nhất sẽ sao chép màu nguồn thành màu đích.

00:13:25.000 --> 00:13:27.000
Chúng ta có thể xây dựng những thứ này theo một vài cách.

00:13:27.000 --> 00:13:36.000
Các nền tảng của Apple đi kèm với một số công nghệ tích hợp tốt với các hiệu ứng bài đăng, chẳng hạn như Core Image, Metal Performance Shaders và SpriteKit.

00:13:36.000 --> 00:13:39.000
Bạn cũng có thể tự viết bằng Ngôn ngữ tô bóng kim loại.

00:13:39.000 --> 00:13:42.000
Hãy bắt đầu với một số hiệu ứng Core Image.

00:13:42.000 --> 00:13:45.000
Core Image là một khuôn khổ của Apple để xử lý hình ảnh.

00:13:45.000 --> 00:13:53.000
Nó có hàng trăm hiệu ứng xử lý màu sắc, cách điệu và biến dạng mà bạn có thể áp dụng cho hình ảnh và video.

00:13:53.000 --> 00:13:58.000
Nhiệt là một hiệu ứng gọn gàng - thứ mà bạn có thể bật cho một công cụ tìm cá dưới nước.

00:13:58.000 --> 00:14:01.000
Hãy xem việc tích hợp với RealityKit dễ dàng như thế nào.

00:14:01.000 --> 00:14:04.000
Tất cả các hiệu ứng bài đăng của chúng tôi sẽ theo cùng một mô hình.

00:14:04.000 --> 00:14:13.000
Bạn đặt lệnh gọi lại kết xuất, phản hồi để chuẩn bị với thiết bị và sau đó quá trình đăng bài sẽ được gọi mọi khung hình.

00:14:13.000 --> 00:14:16.000
Kết xuất các cuộc gọi lại tồn tại trên ARView của RealityKit.

00:14:16.000 --> 00:14:20.000
Chúng tôi muốn cả cuộc gọi lại prepareWithDevice và postProcess.

00:14:20.000 --> 00:14:24.000
Chuẩn bị với thiết bị sẽ được gọi một lần với MTLDevice.

00:14:24.000 --> 00:14:30.000
Đây là một cơ hội tốt để tạo kết cấu, tải tính toán hoặc kết xuất đường ống và kiểm tra khả năng của thiết bị.

00:14:30.000 --> 00:14:33.000
Đây là nơi chúng tôi tạo ra bối cảnh Core Image của mình.

00:14:33.000 --> 00:14:36.000
Cuộc gọi lại postProcess được gọi mỗi khung.

00:14:36.000 --> 00:14:40.000
Chúng tôi sẽ tạo một CIImage, tham khảo kết cấu màu nguồn của chúng tôi.

00:14:40.000 --> 00:14:43.000
Tiếp theo chúng tôi tạo ra bộ lọc nhiệt của chúng tôi.

00:14:43.000 --> 00:14:48.000
Nếu bạn đang sử dụng một bộ lọc Core Image khác, đây là nơi bạn sẽ định cấu hình các thông số khác của nó.

00:14:48.000 --> 00:14:56.000
Sau đó, chúng tôi tạo một điểm đến kết xuất, nhắm vào kết cấu màu đầu ra của chúng tôi và sử dụng bộ đệm lệnh của ngữ cảnh.

00:14:56.000 --> 00:15:01.000
Chúng tôi yêu cầu Core Image giữ nguyên hướng của hình ảnh và bắt đầu nhiệm vụ.

00:15:01.000 --> 00:15:02.000
Thế là xong!

00:15:02.000 --> 00:15:07.000
Với Core Image, chúng tôi đã mở khóa hàng trăm hiệu ứng dựng sẵn mà chúng tôi có thể sử dụng.

00:15:07.000 --> 00:15:12.000
Bây giờ hãy xem cách chúng ta có thể sử dụng Metal Performance Shaders để xây dựng các hiệu ứng mới.

00:15:12.000 --> 00:15:13.000
Hãy nói về sự nở hoa.

00:15:13.000 --> 00:15:22.000
Bloom là một kỹ thuật không gian màn hình tạo ra ánh sáng xung quanh các vật thể được chiếu sáng rực rỡ, mô phỏng hiệu ứng thấu kính trong thế giới thực.

00:15:22.000 --> 00:15:28.000
Core Image chứa hiệu ứng nở hoa, nhưng chúng tôi sẽ tự xây dựng để có thể kiểm soát từng bước của quy trình.

00:15:28.000 --> 00:15:35.000
Chúng tôi sẽ xây dựng hiệu ứng với Metal Performance Shaders, một bộ sưu tập các bộ đổ bóng đồ họa và tính toán được tối ưu hóa cao.

00:15:35.000 --> 00:15:40.000
Để xây dựng bộ đổ bóng này, chúng ta sẽ xây dựng một biểu đồ các bộ lọc sử dụng màu sắc làm nguồn.

00:15:40.000 --> 00:15:43.000
Đầu tiên chúng tôi muốn cách ly những khu vực sáng sủa.

00:15:43.000 --> 00:15:47.000
Để làm điều này, chúng tôi sử dụng một thao tác gọi là "ngưỡng về 0".

00:15:47.000 --> 00:15:52.000
Nó chuyển đổi màu sắc thành độ sáng và đặt mọi điểm ảnh dưới một mức độ sáng nhất định thành 0.

00:15:52.000 --> 00:15:58.000
Sau đó, chúng tôi làm mờ kết quả bằng cách sử dụng làm mờ Gaussian, truyền ánh sáng lên các khu vực lân cận.

00:15:58.000 --> 00:16:02.000
Việc làm mờ hiệu quả có thể là một thách thức để thực hiện và thường yêu cầu nhiều giai đoạn.

00:16:02.000 --> 00:16:05.000
Metal Performance Shaders xử lý việc này cho chúng tôi.

00:16:05.000 --> 00:16:11.000
Sau đó, chúng tôi thêm kết cấu mờ này vào màu gốc, thêm ánh sáng xung quanh các vùng sáng.

00:16:11.000 --> 00:16:15.000
Hãy thực hiện biểu đồ này như một hiệu ứng bài đăng.

00:16:15.000 --> 00:16:18.000
Chúng tôi bắt đầu bằng cách tạo ra một bloomTexture trung gian.

00:16:18.000 --> 00:16:24.000
Sau đó thực hiện thao tác ThresholdToZero của chúng tôi, đọc từ sourceColor và viết để bloomTexture.

00:16:24.000 --> 00:16:28.000
Sau đó, chúng tôi thực hiện một gaussianBlur tại chỗ.

00:16:28.000 --> 00:16:32.000
Cuối cùng, chúng tôi thêm màu gốc của chúng tôi và màu nở này lại với nhau.

00:16:32.000 --> 00:16:33.000
Thế là xong!

00:16:33.000 --> 00:16:41.000
Bây giờ chúng ta đã thấy một vài cách để tạo hiệu ứng bài đăng, hãy nói về cách đặt hiệu ứng lên trên đầu ra của chúng ta bằng SpriteKit.

00:16:41.000 --> 00:16:46.000
SpriteKit là khuôn khổ của Apple cho các trò chơi 2D hiệu suất cao, tiết kiệm pin.

00:16:46.000 --> 00:16:49.000
Nó hoàn hảo để thêm một số hiệu ứng lên trên chế độ xem 3D của chúng tôi.

00:16:49.000 --> 00:16:57.000
Chúng tôi sẽ sử dụng nó để thêm một số bong bóng trên màn hình như một hiệu ứng bài đăng, sử dụng cùng một cuộc gọi lại prepareWithDevice và postProcess.

00:16:57.000 --> 00:16:59.000
Chúng tôi có hai bước giống như trước đây.

00:16:59.000 --> 00:17:04.000
Trong prepareWithDevice, chúng tôi sẽ tạo trình kết xuất SpriteKit của mình và tải cảnh chứa bong bóng của chúng tôi.

00:17:04.000 --> 00:17:13.000
Sau đó, trong cuộc gọi lại postProcess của chúng tôi, chúng tôi sẽ sao chép màu nguồn của mình sang màu đích, cập nhật cảnh SpriteKit của chúng tôi và hiển thị trên nội dung 3D.

00:17:13.000 --> 00:17:20.000
prepareWithDevice khá đơn giản - chúng tôi tạo trình kết xuất và tải cảnh của chúng tôi từ một tệp.

00:17:20.000 --> 00:17:26.000
Chúng tôi sẽ vẽ cái này trên cảnh AR của chúng tôi, vì vậy chúng tôi cần nền SpriteKit của chúng tôi trong suốt.

00:17:26.000 --> 00:17:34.000
Trong postProcess, trước tiên chúng tôi bật màu nguồn thành targetColorTexture; đây sẽ là nền mà SpriteKit hiển thị ở phía trước.

00:17:34.000 --> 00:17:40.000
Sau đó chuyển cảnh SpriteKit của chúng tôi sang thời điểm mới để bong bóng của chúng tôi di chuyển lên trên.

00:17:40.000 --> 00:17:44.000
Thiết lập một RenderPassDescriptor và kết xuất trên đó.

00:17:44.000 --> 00:17:45.000
Và thế là xong!

00:17:45.000 --> 00:17:53.000
Chúng tôi đã chỉ ra cách sử dụng các khuôn khổ hiện có để tạo hiệu ứng bài đăng, nhưng đôi khi bạn thực sự cần tạo một khuôn khổ từ đầu.

00:17:53.000 --> 00:17:58.000
Bạn cũng có thể tạo hiệu ứng toàn màn hình bằng cách viết trình đổ bóng tính toán.

00:17:58.000 --> 00:18:05.000
Đối với bản demo dưới nước của chúng tôi, chúng tôi cần một hiệu ứng sương mù áp dụng cho các vật thể ảo và máy ảnh truyền qua.

00:18:05.000 --> 00:18:11.000
Sương mù mô phỏng sự tán xạ ánh sáng qua môi trường; cường độ của nó tỷ lệ thuận với khoảng cách.

00:18:11.000 --> 00:18:17.000
Để tạo hiệu ứng này, chúng ta cần biết mỗi điểm ảnh cách thiết bị bao xa.

00:18:17.000 --> 00:18:23.000
May mắn thay, ARKit và RealityKit đều cung cấp quyền truy cập vào thông tin chuyên sâu.

00:18:23.000 --> 00:18:31.000
Đối với các thiết bị hỗ trợ LiDAR, ARKit cung cấp quyền truy cập vào sceneDepth, chứa khoảng cách tính bằng mét từ máy ảnh.

00:18:31.000 --> 00:18:36.000
Những giá trị này cực kỳ chính xác ở độ phân giải thấp hơn toàn màn hình.

00:18:36.000 --> 00:18:42.000
Chúng tôi có thể sử dụng trực tiếp độ sâu này nhưng nó không bao gồm các vật thể ảo, vì vậy chúng sẽ không sương mù chính xác.

00:18:42.000 --> 00:18:53.000
Trong postProcess của chúng tôi, RealityKit cung cấp quyền truy cập vào chiều sâu cho nội dung ảo và - khi tính năng hiểu cảnh được bật - các mắt lưới gần đúng cho các đối tượng trong thế giới thực.

00:18:53.000 --> 00:18:59.000
Lưới được xây dựng dần dần khi bạn di chuyển, vì vậy nó chứa một số lỗ mà chúng tôi hiện chưa quét.

00:18:59.000 --> 00:19:03.000
Những lỗ hổng này sẽ cho thấy sương mù như thể chúng ở rất xa.

00:19:03.000 --> 00:19:08.000
Chúng tôi sẽ kết hợp dữ liệu từ hai kết cấu chiều sâu này để giải quyết sự khác biệt này.

00:19:08.000 --> 00:19:11.000
ARKit cung cấp các giá trị chiều sâu như một kết cấu.

00:19:11.000 --> 00:19:16.000
Mỗi điểm ảnh là khoảng cách, tính bằng mét, của điểm được lấy mẫu.

00:19:16.000 --> 00:19:28.000
Vì cảm biến ở hướng cố định trên iPhone hoặc iPad của bạn, chúng tôi sẽ yêu cầu ARKit xây dựng chuyển đổi từ hướng của cảm biến sang hướng màn hình hiện tại và sau đó đảo ngược kết quả.

00:19:28.000 --> 00:19:34.000
Để đọc chiều sâu nội dung ảo, chúng ta cần một chút thông tin về cách RealityKit đóng gói chiều sâu.

00:19:34.000 --> 00:19:40.000
Bạn sẽ nhận thấy rằng, không giống như sceneDepth của ARKit, các giá trị sáng hơn gần với máy ảnh hơn.

00:19:40.000 --> 00:19:46.000
Các giá trị được lưu trữ trong phạm vi từ 0 đến 1, sử dụng Phép chiếu Reverse-Z Vô hạn.

00:19:46.000 --> 00:19:52.000
Điều này chỉ có nghĩa là 0 có nghĩa là vô cùng xa, và 1 nằm ở mặt phẳng gần của máy ảnh.

00:19:52.000 --> 00:19:58.000
Chúng ta có thể dễ dàng đảo ngược sự biến đổi này bằng cách chia độ sâu mặt phẳng gần cho độ sâu được lấy mẫu.

00:19:58.000 --> 00:20:01.000
Hãy viết một hàm trợ giúp để làm điều này.

00:20:01.000 --> 00:20:05.000
Chúng tôi có một hàm Kim loại lấy độ sâu và ma trận chiếu của mẫu.

00:20:05.000 --> 00:20:08.000
Các điểm ảnh không có nội dung ảo chính xác là 0.

00:20:08.000 --> 00:20:12.000
Chúng ta sẽ kẹp vào một epsilon nhỏ để tránh chia cho 0.

00:20:12.000 --> 00:20:19.000
Để hoàn tác phép chia phối cảnh, chúng tôi lấy giá trị z của cột cuối cùng và chia cho độ sâu được lấy mẫu của chúng tôi.

00:20:19.000 --> 00:20:20.000
Tuyệt vời!

00:20:20.000 --> 00:20:26.000
Bây giờ chúng ta đã có hai giá trị độ sâu của mình, chúng ta có thể sử dụng giá trị tối thiểu của cả hai làm đầu vào cho chức năng sương mù của mình.

00:20:26.000 --> 00:20:35.000
Sương mù của chúng ta có một vài thông số: khoảng cách tối đa, cường độ tối đa ở khoảng cách đó và số mũ đường cong lũy thừa.

00:20:35.000 --> 00:20:38.000
Các giá trị chính xác đã được chọn bằng thực nghiệm.

00:20:38.000 --> 00:20:42.000
Chúng định hình giá trị độ sâu của chúng tôi để đạt được mật độ sương mù mong muốn của chúng tôi.

00:20:42.000 --> 00:20:44.000
Bây giờ chúng ta đã sẵn sàng để ghép các mảnh lại với nhau.

00:20:44.000 --> 00:20:51.000
Chúng tôi có giá trị độ sâu từ ARKit, giá trị độ sâu tuyến tính hóa từ RealityKit và một chức năng cho sương mù của chúng tôi.

00:20:51.000 --> 00:20:53.000
Hãy viết trình đổ bóng tính toán của chúng tôi.

00:20:53.000 --> 00:20:57.000
Đối với mỗi điểm ảnh, chúng tôi bắt đầu bằng cách lấy mẫu cả hai giá trị độ sâu tuyến tính.

00:20:57.000 --> 00:21:04.000
Sau đó, chúng tôi áp dụng chức năng sương mù của mình bằng cách sử dụng các tham số điều chỉnh, biến độ sâu tuyến tính thành giá trị 0 đến 1.

00:21:04.000 --> 00:21:12.000
Sau đó, chúng tôi pha trộn giữa màu nguồn và màu sương mù, tùy thuộc vào giá trị của fogBlend, lưu trữ kết quả trong outColor.

00:21:12.000 --> 00:21:19.000
Tóm lại, API quy trình đăng bài mới của RealityKit cho phép một loạt các hiệu ứng bài đăng.

00:21:19.000 --> 00:21:23.000
Với Core Image, chúng tôi đã mở khóa hàng trăm hiệu ứng được xây dựng sẵn.

00:21:23.000 --> 00:21:33.000
Bạn có thể dễ dàng xây dựng những cái mới với Metal Performance Shaders, thêm lớp phủ màn hình với SpriteKit và viết của riêng bạn từ đầu với Metal.

00:21:33.000 --> 00:21:40.000
Để biết thêm thông tin về Core Image hoặc Metal Performance Shaders, hãy xem các phiên được liệt kê.

00:21:40.000 --> 00:21:46.000
Bây giờ chúng ta đã đề cập đến các hiệu ứng kết xuất, hãy chuyển sang chủ đề tiếp theo của chúng ta, các mắt lưới động.

00:21:46.000 --> 00:21:49.000
Trong RealityKit, tài nguyên lưới lưu trữ dữ liệu lưới.

00:21:49.000 --> 00:21:54.000
Trước đây, loại mờ đục này cho phép bạn gán mắt lưới cho các thực thể.

00:21:54.000 --> 00:22:01.000
Năm nay, chúng tôi đang cung cấp khả năng kiểm tra lưới, tạo và cập nhật lưới trong thời gian chạy.

00:22:01.000 --> 00:22:05.000
Hãy xem cách chúng ta có thể thêm các hiệu ứng đặc biệt vào thợ lặn.

00:22:05.000 --> 00:22:10.000
Trong bản demo này, chúng tôi muốn hiển thị một hiệu ứng xoắn ốc nơi các đường viền xoắn ốc xung quanh thợ lặn.

00:22:10.000 --> 00:22:16.000
Bạn cũng có thể thấy hình xoắn ốc đang thay đổi lưới của nó theo thời gian như thế nào để tạo hiệu ứng chuyển động của nó.

00:22:16.000 --> 00:22:20.000
Hãy cùng xem cách tạo cái này bằng cách sử dụng API lưới mới của chúng tôi.

00:22:20.000 --> 00:22:24.000
Hiệu ứng tập trung thành ba bước.

00:22:24.000 --> 00:22:29.000
Chúng tôi sử dụng kiểm tra lưới để đo mô hình bằng cách kiểm tra các đỉnh của nó.

00:22:29.000 --> 00:22:33.000
Sau đó chúng tôi xây dựng một hình xoắn ốc, sử dụng các phép đo làm hướng dẫn.

00:22:33.000 --> 00:22:38.000
Và cuối cùng, chúng ta có thể cập nhật vòng xoắn ốc theo thời gian.

00:22:38.000 --> 00:22:40.000
Bắt đầu với việc kiểm tra lưới.

00:22:40.000 --> 00:22:44.000
Để giải thích cách các mắt lưới được lưu trữ, hãy xem mô hình thợ lặn của chúng tôi.

00:22:44.000 --> 00:22:48.000
Trong RealityKit, lưới của Thợ lặn được thể hiện dưới dạng tài nguyên lưới.

00:22:48.000 --> 00:22:53.000
Với bản phát hành năm nay, MeshResource hiện có một thành viên có tên là Contents.

00:22:53.000 --> 00:22:57.000
Đó là nơi mà tất cả các hình học lưới được xử lý tồn tại.

00:22:57.000 --> 00:23:02.000
Nội dung chứa một danh sách các trường hợp và mô hình.

00:23:02.000 --> 00:23:08.000
Các mô hình chứa dữ liệu đỉnh thô, trong khi các trường hợp tham chiếu chúng và thêm một phép biến đổi.

00:23:08.000 --> 00:23:13.000
Các trường hợp cho phép hiển thị cùng một hình học nhiều lần mà không cần sao chép dữ liệu.

00:23:13.000 --> 00:23:15.000
Một mô hình có thể có nhiều phần.

00:23:15.000 --> 00:23:19.000
Một phần là một nhóm hình học với một vật liệu.

00:23:19.000 --> 00:23:28.000
Cuối cùng, mỗi phần chứa dữ liệu đỉnh mà chúng tôi quan tâm, chẳng hạn như vị trí, chuẩn, tọa độ kết cấu và chỉ số.

00:23:28.000 --> 00:23:32.000
Trước tiên chúng ta hãy xem cách chúng ta sẽ truy cập dữ liệu này trong mã.

00:23:32.000 --> 00:23:38.000
Chúng tôi sẽ tạo một phần mở rộng trên MeshResource.Contents, gọi đóng với vị trí của mỗi đỉnh.

00:23:38.000 --> 00:23:41.000
Chúng tôi bắt đầu bằng cách xem qua tất cả các trường hợp.

00:23:41.000 --> 00:23:43.000
Mỗi trường hợp này ánh xạ đến một mô hình.

00:23:43.000 --> 00:23:47.000
Đối với mỗi trường hợp, chúng tôi tìm thấy sự biến đổi của nó liên quan đến thực thể.

00:23:47.000 --> 00:23:53.000
Sau đó, chúng ta có thể đi sâu vào từng bộ phận của mô hình và truy cập các thuộc tính của bộ phận.

00:23:53.000 --> 00:23:56.000
Đối với chức năng này, chúng tôi chỉ quan tâm đến vị trí.

00:23:56.000 --> 00:24:02.000
Sau đó, chúng ta có thể chuyển đổi đỉnh thành vị trí không gian thực thể và gọi lại cuộc gọi lại của chúng ta.

00:24:02.000 --> 00:24:07.000
Bây giờ chúng ta có thể truy cập các đỉnh, hãy xem cách chúng ta muốn sử dụng dữ liệu này.

00:24:07.000 --> 00:24:10.000
Chúng tôi sẽ chia thợ lặn của chúng tôi thành các lát cắt ngang.

00:24:10.000 --> 00:24:18.000
Đối với mỗi lát cắt, chúng ta sẽ tìm bán kính giới hạn của mô hình của mình và làm điều này cho mỗi lát cắt.

00:24:18.000 --> 00:24:23.000
Để thực hiện điều này, chúng ta sẽ bắt đầu bằng cách tạo ra một mảng không chứa đầy với các phần tử numSlices.

00:24:23.000 --> 00:24:28.000
Sau đó, chúng tôi tìm ra các giới hạn của lưới dọc theo trục y để tạo ra các lát cắt của chúng tôi.

00:24:28.000 --> 00:24:38.000
Sử dụng hàm chúng tôi vừa tạo, cho mỗi đỉnh trong mô hình, chúng tôi tìm ra lát cắt nào đi vào và chúng tôi cập nhật bán kính với bán kính lớn nhất cho lát cắt đó.

00:24:38.000 --> 00:24:44.000
Cuối cùng, chúng tôi trả về một đối tượng Slices chứa bán kính và giới hạn.

00:24:44.000 --> 00:24:49.000
Bây giờ chúng tôi đã phân tích lưới của mình để biết nó lớn như thế nào, hãy xem cách tạo lưới xoắn ốc.

00:24:49.000 --> 00:24:52.000
Hình xoắn ốc là một lưới được tạo ra động.

00:24:52.000 --> 00:24:57.000
Để tạo lưới này, chúng ta cần mô tả dữ liệu của mình cho RealityKit.

00:24:57.000 --> 00:24:59.000
Chúng tôi làm điều này với một mô tả lưới.

00:24:59.000 --> 00:25:06.000
Mô tả lưới chứa các vị trí, chuẩn mực, tọa độ kết cấu, nguyên thủy và chỉ số vật liệu.

00:25:06.000 --> 00:25:09.000
Khi bạn có một bộ mô tả lưới, bạn có thể tạo một tài nguyên lưới.

00:25:09.000 --> 00:25:14.000
Điều này gọi bộ xử lý lưới của RealityKit, giúp tối ưu hóa lưới của bạn.

00:25:14.000 --> 00:25:23.000
Nó sẽ hợp nhất các đỉnh trùng lặp, tam giác các tứ giác và đa giác của bạn, và đại diện cho lưới ở định dạng hiệu quả nhất để kết xuất.

00:25:23.000 --> 00:25:28.000
Kết quả của quá trình xử lý này cung cấp cho chúng tôi một tài nguyên lưới mà chúng tôi có thể gán cho một thực thể.

00:25:28.000 --> 00:25:32.000
Lưu ý rằng các chuẩn mực, tọa độ kết cấu và vật liệu là tùy chọn.

00:25:32.000 --> 00:25:37.000
Bộ xử lý lưới của chúng tôi sẽ tự động tạo ra các chuẩn mực chính xác và điền chúng vào.

00:25:37.000 --> 00:25:43.000
Là một phần của quá trình tối ưu hóa, RealityKit sẽ tái tạo cấu trúc liên kết của lưới.

00:25:43.000 --> 00:25:48.000
Nếu bạn cần một cấu trúc liên kết cụ thể, bạn có thể sử dụng MeshResource.Contents trực tiếp.

00:25:48.000 --> 00:25:52.000
Bây giờ chúng ta đã biết cách tạo lưới hoạt động, hãy xem cách tạo vòng xoắn ốc.

00:25:52.000 --> 00:25:58.000
Để mô hình hóa hình xoắn ốc, chúng ta hãy xem xét kỹ hơn một phần.

00:25:58.000 --> 00:26:01.000
Xoắn ốc còn được gọi là xoắn ốc.

00:26:01.000 --> 00:26:04.000
Chúng tôi sẽ xây dựng cái này trong các phân đoạn cách đều nhau.

00:26:04.000 --> 00:26:12.000
Chúng ta có thể tính toán từng điểm bằng cách sử dụng định nghĩa toán học của một vòng xoắn và bán kính từ lưới được phân tích của chúng ta.

00:26:12.000 --> 00:26:17.000
Sử dụng hàm này cho mỗi phân đoạn trên vòng xoắn, chúng ta có thể xác định bốn đỉnh.

00:26:17.000 --> 00:26:21.000
P0 và P1 chính xác là các giá trị mà p() trả về.

00:26:21.000 --> 00:26:28.000
Để tính P2 và P3, chúng ta có thể bù P0 và P1 theo chiều dọc với độ dày đã cho của chúng ta.

00:26:28.000 --> 00:26:31.000
Chúng tôi đang tạo ra các hình tam giác, vì vậy chúng tôi cần một đường chéo.

00:26:31.000 --> 00:26:34.000
Chúng ta sẽ tạo ra hai hình tam giác bằng cách sử dụng những điểm này.

00:26:34.000 --> 00:26:37.000
Đã đến lúc kết hợp tất cả lại với nhau.

00:26:37.000 --> 00:26:41.000
Chức năng generateSpiral của chúng tôi cần lưu trữ các vị trí và chỉ số.

00:26:41.000 --> 00:26:44.000
Các chỉ số tham chiếu các giá trị ở các vị trí.

00:26:44.000 --> 00:26:53.000
Đối với mỗi phân đoạn, chúng tôi sẽ tính toán bốn vị trí và lưu trữ các chỉ số của chúng - i0 là chỉ số của p0 khi nó được thêm vào mảng.

00:26:53.000 --> 00:26:59.000
Sau đó, chúng tôi thêm bốn vị trí và sáu chỉ số - cho hai tam giác - vào mảng của chúng.

00:26:59.000 --> 00:27:03.000
Một khi bạn đã có hình học của mình, việc tạo lưới rất đơn giản.

00:27:03.000 --> 00:27:06.000
Đầu tiên, tạo một MeshDescriptor mới.

00:27:06.000 --> 00:27:08.000
Sau đó chỉ định các vị trí và nguyên thủy.

00:27:08.000 --> 00:27:13.000
Chúng tôi đang sử dụng nguyên thủy tam giác, nhưng chúng tôi cũng có thể chọn tứ giác hoặc đa giác.

00:27:13.000 --> 00:27:17.000
Khi hai trường đó được điền vào, chúng tôi có đủ để tạo một MeshResource.

00:27:17.000 --> 00:27:24.000
Bạn cũng có thể cung cấp các thuộc tính đỉnh khác như chuẩn, tọa độ kết cấu hoặc gán vật liệu.

00:27:24.000 --> 00:27:26.000
Chúng tôi đã đề cập đến cách tạo lưới.

00:27:26.000 --> 00:27:30.000
Điều cuối cùng trong ví dụ xoắn ốc của chúng tôi là cập nhật lưới.

00:27:30.000 --> 00:27:34.000
Chúng tôi sử dụng các bản cập nhật lưới để làm cho vòng xoắn ốc di chuyển xung quanh thợ lặn.

00:27:34.000 --> 00:27:37.000
Để cập nhật lưới, có hai cách.

00:27:37.000 --> 00:27:42.000
Chúng tôi có thể tạo một MeshResource mới cho mỗi khung bằng cách sử dụng MeshDescriptors API.

00:27:42.000 --> 00:27:48.000
Nhưng đây không phải là một con đường hiệu quả, vì nó sẽ chạy qua trình tối ưu hóa lưới mỗi khung hình.

00:27:48.000 --> 00:27:52.000
Một lộ trình hiệu quả hơn là cập nhật nội dung trong MeshResource.

00:27:52.000 --> 00:27:56.000
Bạn có thể tạo một MeshContents mới và sử dụng nó để thay thế lưới.

00:27:56.000 --> 00:27:58.000
Tuy nhiên, có một cảnh báo.

00:27:58.000 --> 00:28:05.000
Nếu chúng tôi tạo lưới ban đầu của mình bằng MeshDescriptor, bộ xử lý lưới của RealityKit sẽ tối ưu hóa dữ liệu.

00:28:05.000 --> 00:28:08.000
Cấu trúc liên kết cũng được giảm xuống thành hình tam giác.

00:28:08.000 --> 00:28:14.000
Do đó, hãy đảm bảo rằng bạn biết lưới của mình bị ảnh hưởng như thế nào trước khi áp dụng bất kỳ bản cập nhật nào.

00:28:14.000 --> 00:28:17.000
Hãy xem mã để biết cách bạn có thể cập nhật vòng xoắn ốc.

00:28:17.000 --> 00:28:21.000
Chúng tôi bắt đầu bằng cách lưu trữ nội dung của vòng xoắn ốc hiện có.

00:28:21.000 --> 00:28:24.000
Tạo một mô hình mới từ mô hình hiện có.

00:28:24.000 --> 00:28:29.000
Sau đó, đối với mỗi phần, chúng tôi thay thế triangleIndices bằng một tập hợp con các chỉ số.

00:28:29.000 --> 00:28:34.000
Cuối cùng, với nội dung mới, chúng ta có thể gọi thay thế trên MeshResource hiện có.

00:28:34.000 --> 00:28:36.000
Và đó là nó cho các mắt lưới động.

00:28:36.000 --> 00:28:43.000
Để tóm tắt những điều quan trọng về lưới động, chúng tôi đã giới thiệu một trường Nội dung mới trong MeshResource.

00:28:43.000 --> 00:28:48.000
Vùng chứa này cho phép bạn kiểm tra và sửa đổi dữ liệu thô của lưới.

00:28:48.000 --> 00:28:50.000
Bạn có thể tạo các mắt lưới mới bằng cách sử dụng MeshDescriptor.

00:28:50.000 --> 00:28:59.000
Lộ trình linh hoạt này cho phép bạn sử dụng hình tam giác, tứ giác hoặc thậm chí đa giác và RealityKit sẽ tạo ra một lưới được tối ưu hóa để kết xuất.

00:28:59.000 --> 00:29:07.000
Cuối cùng, để cập nhật lưới, chúng tôi đã cung cấp khả năng cập nhật nội dung của MeshResource, lý tưởng cho việc cập nhật thường xuyên.

00:29:07.000 --> 00:29:13.000
Để kết thúc, hôm nay chúng tôi đã giới thiệu một số tính năng kết xuất mới trong RealityKit 2.

00:29:13.000 --> 00:29:17.000
Công cụ sửa đổi hình học cho phép bạn di chuyển và sửa đổi các đỉnh.

00:29:17.000 --> 00:29:21.000
Bộ đổ bóng bề mặt cho phép bạn xác định diện mạo bề mặt của mô hình.

00:29:21.000 --> 00:29:31.000
Bạn có thể sử dụng hiệu ứng bài đăng để áp dụng hiệu ứng cho khung cuối cùng và các mắt lưới động giúp dễ dàng tạo và sửa đổi các mắt lưới trong thời gian chạy.

00:29:31.000 --> 00:29:36.000
Để xem thêm các tính năng của năm nay, đừng bỏ lỡ "Dive into RealityKit 2."

00:29:36.000 --> 00:29:41.000
Và để biết thêm thông tin về RealityKit, hãy xem "Xây dựng ứng dụng với RealityKit."

00:29:41.000 --> 00:29:46.000
Chúng tôi rất vui mừng về bản phát hành năm nay và nóng lòng muốn xem những trải nghiệm bạn xây dựng với nó.

00:29:46.000 --> 00:29:47.000
Cảm ơn bạn.

00:29:47.000 --> 23:59:59.000
♪

