WEBVTT

00:00:00.000 --> 00:00:06.000
♪ Nhạc bass đang phát ♪

00:00:06.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:11.000
Jeff Nadeau: Xin chào, và chào mừng đến với "Có gì mới trong AppKit."

00:00:11.000 --> 00:00:13.000
Tôi là Jeff Nadeau.

00:00:13.000 --> 00:00:16.000
Tôi làm việc trên AppKit, và tôi có một số cập nhật tuyệt vời để chia sẻ với bạn.

00:00:16.000 --> 00:00:21.000
macOS Monterey bao gồm một số tính năng và cải tiến mới tuyệt vời cho các ứng dụng Mac.

00:00:21.000 --> 00:00:44.000
Thực sự có một cái gì đó cho tất cả mọi người trong bản phát hành này, bao gồm các bản cập nhật cho thiết kế giao diện người dùng của chúng tôi, cải tiến nhiều điều khiển của chúng tôi, bản cập nhật lớn cho SF Symbols, một công cụ văn bản hoàn toàn mới có tên TextKit 2, các tính năng ngôn ngữ Swift mới mạnh mẽ và tự động hóa

00:00:44.000 --> 00:00:50.000
Hãy đi sâu vào, bắt đầu với một số cập nhật về thiết kế của giao diện người dùng macOS.

00:00:50.000 --> 00:00:55.000
Chúng tôi rất vui mừng trước phản hồi đối với thiết kế lại toàn hệ thống đã ra mắt trong macOS Big Sur.

00:00:55.000 --> 00:01:01.000
Rất nhiều ứng dụng yêu thích của chúng tôi đã cập nhật để áp dụng thiết kế mới chỉ trong vài tháng ngắn ngủi.

00:01:01.000 --> 00:01:09.000
Trong macOS Monterey, chúng tôi đã tiếp tục lặp lại và tinh chỉnh thiết kế mới này, vì vậy bạn sẽ nhận thấy một vài điểm nhấn mới trên toàn hệ thống.

00:01:09.000 --> 00:01:21.000
Một số trong số chúng lớn và đáng chú ý, như cửa sổ bật lên hiện xuất hiện và rút đi với hình ảnh động hoàn toàn mới hoặc thanh trượt hiện lướt nhẹ nhàng vào vị trí khi bạn nhấp vào chúng.

00:01:21.000 --> 00:01:32.000
Ngoài ra còn có nhiều thay đổi tinh tế hơn, như các số liệu tinh chỉnh trong các điều khiển thanh công cụ và hỗ trợ tải lò xo trên nút Tìm kiếm, vì vậy thật dễ dàng để kéo văn bản và mã thông báo.

00:01:32.000 --> 00:01:37.000
Và tăng khoảng cách giữa các phần của bảng để cải thiện độ rõ nét.

00:01:37.000 --> 00:01:41.000
Chúng tôi đã tiếp tục lặp lại và nâng cao thiết kế mới đến từng chi tiết nhỏ nhất.

00:01:41.000 --> 00:01:46.000
Và điều đó dẫn tôi đến một số cải tiến kiểm soát mà bạn có thể sử dụng để tinh chỉnh các thiết kế của riêng mình.

00:01:46.000 --> 00:01:49.000
Cái lớn đầu tiên là kiểm soát nhuộm màu.

00:01:49.000 --> 00:01:56.000
Chúng tôi đã bật tính năng tùy chỉnh các nút riêng lẻ, các điều khiển được phân đoạn và thanh trượt.

00:01:56.000 --> 00:02:06.000
Mỗi điều khiển này chấp nhận một màu sắc thái tùy chỉnh bằng cách sử dụng một trong các API sau: bezelColor, selectedSegmentColor và trackFillColor.

00:02:06.000 --> 00:02:12.000
Chúng tôi đã giới thiệu các API này trong macOS Sierra để cho phép nhuộm màu các điều khiển riêng lẻ trong Touch Bar.

00:02:12.000 --> 00:02:17.000
Và bắt đầu từ macOS Monterey, chúng cũng hoạt động cho các điều khiển trong cửa sổ.

00:02:17.000 --> 00:02:24.000
Tóm lại, hầu hết các điều khiển vẽ bằng cách sử dụng màu nhấn, có thể định cấu hình trong Tùy chọn hệ thống.

00:02:24.000 --> 00:02:27.000
Điều này cho phép mọi người tạo chủ đề cho máy Mac của họ để phù hợp với màu sắc yêu thích của họ.

00:02:27.000 --> 00:02:32.000
Tùy chọn Nhiều màu cho phép mỗi ứng dụng xác định màu tùy chỉnh của riêng mình.

00:02:32.000 --> 00:02:38.000
Đối với chủ đề phổ biến, bạn có thể xác định màu nhấn tùy chỉnh trong danh mục nội dung của ứng dụng.

00:02:38.000 --> 00:02:43.000
API pha màu mới cung cấp một cách để ghi đè màu cho một điều khiển cụ thể.

00:02:43.000 --> 00:02:48.000
Điều này rất tốt cho các điều khiển mà bạn muốn áp dụng một màu có ý nghĩa ngữ nghĩa.

00:02:48.000 --> 00:02:58.000
Ví dụ: nếu ứng dụng của bạn sử dụng một màu cam cụ thể để phân biệt đơn đặt hàng trước với giao dịch mua thông thường, bạn có thể củng cố thiết kế đó bằng cách sử dụng nút màu.

00:02:58.000 --> 00:03:06.000
Một ví dụ khác sẽ là ứng dụng hội nghị truyền hình, trong đó các nút Bắt đầu và Kết thúc Cuộc gọi thực hiện hai trong số các hành động có ý nghĩa nhất trong ứng dụng.

00:03:06.000 --> 00:03:12.000
Tô màu xanh lá cây và đỏ làm tăng thêm điểm nhấn và nó làm cho chức năng của chúng có thể nhận ra ngay lập tức.

00:03:12.000 --> 00:03:21.000
Một lưu ý quan trọng là các nút màu luôn hiển thị màu sắc của chúng ở mọi trạng thái hoạt động, không giống như các nút ấn thông thường có màu trắng hoặc xám.

00:03:21.000 --> 00:03:24.000
Điều này đặt màu sắc thái của bạn ở phía trước và trung tâm.

00:03:24.000 --> 00:03:31.000
Tuy nhiên, hãy cẩn thận trong thiết kế của bạn để không tạo ra sự nhầm lẫn với nút mặc định, nút này cũng sử dụng vẻ ngoài đầy màu sắc.

00:03:31.000 --> 00:03:36.000
Cuối cùng, điều quan trọng là truyền đạt mục đích điều khiển của bạn không chỉ bằng màu sắc.

00:03:36.000 --> 00:03:47.000
Bạn muốn đảm bảo rằng những người gặp khó khăn trong việc phân biệt giữa các màu sắc vẫn có thể dễ dàng xác định mục đích của một điều khiển nhất định, vì vậy hãy đảm bảo cung cấp một nhãn hoặc biểu tượng rõ ràng.

00:03:47.000 --> 00:03:54.000
Một thay đổi thiết kế nút quan trọng khác là các nút nhấn không còn làm nổi bật bằng cách sử dụng màu nhấn khi nhấp chuột.

00:03:54.000 --> 00:04:01.000
Điều này đưa chúng phù hợp với các yếu tố có thể nhấp khác, như các phân đoạn điều khiển được phân đoạn, núm trượt và bước.

00:04:01.000 --> 00:04:15.000
Đây là một thay đổi quan trọng, bởi vì nếu bạn đang thực hiện bất kỳ bản vẽ tùy chỉnh nào có vẻ ngoài đầy màu sắc trong khi được tô sáng - giả sử, nếu bạn chọn vẽ nội dung màu trắng lên trên - nó có thể trông không chính xác trên macOS Monterey.

00:04:15.000 --> 00:04:22.000
Thay vì kiểm tra trạng thái nổi bật, bạn có thể đưa ra quyết định vẽ của mình bằng cách sử dụng thuộc tính interiorBackgroundStyle.

00:04:22.000 --> 00:04:39.000
Thuộc tính này phản ánh kiểu cơ bản của viền nút, vì vậy nó sẽ luôn trả về .bình thường cho các trạng thái không màu và nó sẽ trả về .được nhấn mạnh cho các trạng thái nhấn mạnh đầy màu sắc, như các nút màu, nút mặc định và các nút được chuyển sang trạng thái "bật".

00:04:39.000 --> 00:04:47.000
Cuối cùng, chúng tôi đã cập nhật kiểu nút Nhấn linh hoạt - trước đây được gọi là Hình vuông thông thường - để phục vụ như một nút nhấn có chiều cao thay đổi.

00:04:47.000 --> 00:04:55.000
Bây giờ nó hỗ trợ tất cả các cấu hình giống như một nút nhấn thông thường, có nghĩa là nó có thể đóng vai trò là nút mặc định và bạn có thể tô màu nó.

00:04:55.000 --> 00:05:11.000
Bán kính góc và phần đệm nội dung hiện phù hợp với các nút nhấn tiêu chuẩn ở mỗi kích thước điều khiển, vì vậy chúng sẽ phù hợp tuyệt vời với các điều khiển khác của bạn, nhưng thiết kế có thể thay đổi kích thước theo chiều dọc của chúng có nghĩa là chúng có thể chứa các biểu tượng hoặc văn bản lớn hơn với ngắt dòng.

00:05:11.000 --> 00:05:23.000
Mặc dù phần lớn các nút nhấn nên tiếp tục sử dụng kiểu chiều cao cố định tiêu chuẩn, nhưng kiểu mở rộng mới này cung cấp một số tính linh hoạt cho những trường hợp đặc biệt đó khi bạn cần chứa nội dung cao hơn.

00:05:23.000 --> 00:05:30.000
Một bản cập nhật điều khiển rất quan trọng khác xuất hiện dưới dạng bản địa hóa tự động cho các phím tắt menu.

00:05:30.000 --> 00:05:37.000
Có rất nhiều bố cục bàn phím ngoài kia trên thế giới, và điều đó có thể làm cho việc bản địa hóa các phím tắt khá phức tạp.

00:05:37.000 --> 00:05:42.000
Một số tổ hợp phím khó tiếp cận trên một số bàn phím và những tổ hợp khác hoàn toàn không thể đánh máy được.

00:05:42.000 --> 00:05:48.000
Ngoài ra, một số phím tắt định hướng thực sự nên phản chiếu bằng các ngôn ngữ từ phải sang trái.

00:05:48.000 --> 00:05:53.000
Tin tuyệt vời là, trong macOS Monterey, AppKit có thể làm điều đó cho bạn.

00:05:53.000 --> 00:05:58.000
Đây là một ví dụ về một phím tắt có thể được hưởng lợi từ việc bản địa hóa: Dấu gạch chéo ngược lệnh.

00:05:58.000 --> 00:06:07.000
Mặc dù điều này hoạt động tốt trên bàn phím tiếng Anh Hoa Kỳ, nhưng thực sự không thể gõ trên bàn phím tiếng Nhật, bàn phím này hoàn toàn không có phím dấu gạch chéo ngược.

00:06:07.000 --> 00:06:15.000
Bắt đầu từ macOS Monterey, hệ thống tự động ánh xạ lại phím tắt, cung cấp một phím tắt tương đương tự nhiên để nhập.

00:06:15.000 --> 00:06:19.000
Một trường hợp phổ biến khác là một phím tắt có ý nghĩa định hướng.

00:06:19.000 --> 00:06:25.000
Ví dụ, Safari sử dụng dấu ngoặc vuông lệnh để đi lùi và tiến trong lịch sử.

00:06:25.000 --> 00:06:35.000
Trong ngôn ngữ từ phải sang trái, việc sử dụng dấu ngoặc trái để đi ngược không trực quan lắm, vì vậy AppKit hiện tự động hoán đổi nó sang dấu ngoặc phải khi chạy bằng ngôn ngữ từ phải sang trái.

00:06:35.000 --> 00:06:40.000
Hành vi này áp dụng cho dấu ngoặc, dấu ngoặc đơn, dấu ngoặc đơn và phím mũi tên.

00:06:40.000 --> 00:06:44.000
Trong một số trường hợp, bạn có thể muốn vô hiệu hóa hành vi phản chiếu này.

00:06:44.000 --> 00:06:53.000
Ví dụ: nếu mục menu của bạn có định hướng tuyệt đối - ví dụ như căn chỉnh bên trái - bạn sẽ muốn sử dụng dấu ngoặc trái ngay cả trong ngôn ngữ từ phải sang trái.

00:06:53.000 --> 00:06:57.000
Chúng tôi đã cung cấp lựa chọn không tham gia cho các trường hợp như thế này.

00:06:57.000 --> 00:07:01.000
Bạn có thể kiểm soát hành vi này bằng cách sử dụng một số thuộc tính mới trên NSMenuItem.

00:07:01.000 --> 00:07:18.000
allowsAutomaticKey EquivalentMirroring cho phép bạn kiểm soát hành vi phản chiếu cho các phím định hướng như dấu ngoặc và cho phépAutomaticKey EquivalentLocalization điều khiển tất cả các tính năng bản địa hóa, bao gồm ánh xạ và phản chiếu bàn phím.

00:07:18.000 --> 00:07:30.000
Nếu bạn đã bản địa hóa cẩn thận các phím tắt của mình hoặc nếu ứng dụng của bạn có triển khai tùy chỉnh nhiều ràng buộc phím tắt, bạn có thể muốn tắt tính năng này cho toàn bộ ứng dụng của mình.

00:07:30.000 --> 00:07:39.000
Để làm điều đó, bạn có thể triển khai phương thức đại diện ứng dụng này, applicationShouldAutomatically LocalizeKeyEquivalents và trả về false.

00:07:39.000 --> 00:07:41.000
Hầu hết các ứng dụng sẽ không cần sử dụng cái này.

00:07:41.000 --> 00:07:49.000
Các API mục menu riêng lẻ được ưu tiên mạnh mẽ để chọn không tham gia các mục cụ thể và hầu hết các ứng dụng hoàn toàn không cần phải chọn không tham gia.

00:07:49.000 --> 00:07:53.000
Tiếp theo, một số cải tiến lớn đối với hình ảnh biểu tượng.

00:07:53.000 --> 00:08:03.000
Chúng tôi đã đưa SF Symbols lên macOS trong Big Sur, mở ra một loạt các hình ảnh biểu tượng đẹp, cân bằng kiểu chữ cho tất cả các ứng dụng Mac.

00:08:03.000 --> 00:08:11.000
Trong macOS Monterey, chúng tôi đã xây dựng một thế hệ API và công cụ biểu tượng mới mà chúng tôi gọi là Biểu tượng SF 3.

00:08:11.000 --> 00:08:18.000
Đó là một bản cập nhật lớn trải dài mọi khía cạnh của quy trình làm việc hình ảnh biểu tượng và tất cả đều có sẵn cho các ứng dụng AppKit của bạn.

00:08:18.000 --> 00:08:26.000
SF Symbols 3 mở rộng khả năng của ứng dụng SF Symbols để xem trước, xuất và nhập hình ảnh biểu tượng.

00:08:26.000 --> 00:08:42.000
Nó cũng đi kèm với một định dạng cập nhật để chú thích các biểu tượng tùy chỉnh, cho phép bạn xác định các lớp riêng biệt trong hình ảnh biểu tượng và chúng tôi đã mở rộng các API của mình trong AppKit, UIKit và SwiftUI để cho phép bạn tô màu riêng từng lớp của biểu tượng.

00:08:42.000 --> 00:08:46.000
Trong Big Sur, chúng tôi đã cung cấp hai chế độ kết xuất riêng biệt cho các biểu tượng.

00:08:46.000 --> 00:08:54.000
Đầu tiên, có phong cách Mẫu truyền thống, được vẽ bằng cách sử dụng một màu hoặc hiệu ứng tông màu duy nhất trên toàn bộ biểu tượng.

00:08:54.000 --> 00:09:04.000
Thứ hai là Multicolor, vẽ giống như một hình ảnh đầy đủ màu sắc hơn, vẽ từng phần tử đường dẫn bằng cách sử dụng một màu được xác định trong chính hình ảnh biểu tượng.

00:09:04.000 --> 00:09:12.000
Trong SF Symbols 3, chúng tôi đã thêm hai chế độ kết xuất mới tận dụng thông tin lớp được cung cấp bởi định dạng hình ảnh biểu tượng mới.

00:09:12.000 --> 00:09:22.000
Đầu tiên, Phân cấp, vẽ bằng cách sử dụng một màu duy nhất, đồng thời nhấn mạnh vào các phần cụ thể của biểu tượng trong khi nhấn mạnh các phần khác.

00:09:22.000 --> 00:09:28.000
Và thứ hai, Bảng màu, cho phép bạn gán bất kỳ màu nào bạn muốn cho từng lớp của biểu tượng.

00:09:28.000 --> 00:09:34.000
Bạn có thể truy cập các chế độ kết xuất này bằng API mới trên NSImage.SymbolConfiguration.

00:09:34.000 --> 00:09:40.000
Tôi đang đại diện cho các tham số NSColor dưới dạng các dấu chấm để hiển thị cách chúng tương ứng với biểu tượng được hiển thị.

00:09:40.000 --> 00:09:46.000
Chế độ kết xuất phân cấp có một màu duy nhất, được áp dụng cho các lớp biểu tượng với độ mờ giảm dần.

00:09:46.000 --> 00:09:51.000
Chế độ Bảng màu chấp nhận một mảng màu sắc được áp dụng cho các lớp nguyên văn.

00:09:51.000 --> 00:09:58.000
Bạn cũng có thể tạo một cấu hình thích chế độ kết xuất nhiều màu.

00:09:58.000 --> 00:10:04.000
Chúng tôi cũng đã thêm một API mới cho phép bạn ánh xạ từ một biểu tượng cơ sở thành một trong các biến thể của nó.

00:10:04.000 --> 00:10:14.000
Ví dụ, bạn có thể ánh xạ biểu tượng trái tim đến biến thể đầy của nó, hoặc một biến thể được ghi như vòng tròn, hoặc thậm chí đến biến thể có dấu gạch chéo qua nó.

00:10:14.000 --> 00:10:21.000
Điều này thực sự hữu ích cho các tình huống mà bạn thích một kiểu biểu tượng cụ thể cho một bối cảnh cụ thể.

00:10:21.000 --> 00:10:28.000
Ví dụ, bạn có thể có một điều khiển bộ chọn nơi bạn thích phác thảo cho các trạng thái chưa được chọn, nhưng một kiểu đầy đủ cho lựa chọn của bạn.

00:10:28.000 --> 00:10:35.000
Thông thường, điều khiển này sẽ cần hai thuộc tính hình ảnh khác nhau để chỉ định các phiên bản đã chọn và không được chọn của hình ảnh.

00:10:35.000 --> 00:10:44.000
Nhưng với API biến thể, nó chỉ có thể chấp nhận một biểu tượng cơ sở duy nhất và tự động lấy trạng thái đã điền.

00:10:44.000 --> 00:10:54.000
Điều khiển này có thể gọi hình ảnh (với: .fill) để thích một biểu tượng đã điền ở trạng thái lựa chọn của nó và nó sẽ tự động chọn đúng phiên bản của biểu tượng bất cứ khi nào có biến thể đã điền.

00:10:54.000 --> 00:11:03.000
Có các hằng số cho từng loại biến thể biểu tượng và bạn có thể kết hợp chúng để yêu cầu nhiều biến thể với nhau, như hình tròn và điền.

00:11:03.000 --> 00:11:08.000
Đây chỉ là phần giới thiệu ngắn gọn về các tính năng của Biểu tượng SF 3.

00:11:08.000 --> 00:11:14.000
Có một bộ sưu tập video mới, nơi bạn có thể nhận được thông tin chi tiết đầy đủ về mọi thứ mới trên toàn bộ quy trình làm việc của biểu tượng.

00:11:14.000 --> 00:11:17.000
Hãy chắc chắn thêm chúng vào danh sách theo dõi của bạn.

00:11:17.000 --> 00:11:22.000
macOS Monterey cũng có một bản cập nhật lớn cho hệ thống văn bản dưới dạng TextKit 2.

00:11:22.000 --> 00:11:30.000
TextKit là công cụ bố cục và kết xuất văn bản cho tất cả các thiết bị của Apple và nó là một công cụ văn bản tuyệt vời với hồ sơ theo dõi đã được chứng minh.

00:11:30.000 --> 00:11:36.000
TextKit là một công cụ bố cục văn bản tuyến tính, có nghĩa là nó sắp chữ một khối văn bản từ đầu đến cuối.

00:11:36.000 --> 00:11:44.000
Khi chúng tôi phát triển các nền tảng và công nghệ của mình, chúng tôi đã tìm thấy rất nhiều trường hợp bố cục văn bản phi tuyến sẽ phục vụ chúng tôi tốt hơn nhiều.

00:11:44.000 --> 00:11:52.000
Vì vậy, chúng tôi đã quay trở lại những điều cơ bản và tạo ra một phiên bản mới của TextKit và đó là TextKit 2.

00:11:52.000 --> 00:11:55.000
Chúng tôi đã có một vài mục tiêu chính cho TextKit 2.

00:11:55.000 --> 00:12:01.000
Như mọi khi, chúng tôi muốn cung cấp trải nghiệm tốt nhất cho văn bản quốc tế của mọi kịch bản và bố cục.

00:12:01.000 --> 00:12:05.000
Chúng tôi cũng muốn làm cho việc trộn văn bản với các loại nội dung khác dễ dàng hơn.

00:12:05.000 --> 00:12:17.000
Và cuối cùng, TextKit 2 được thiết kế để định hình và hiển thị văn bản siêu nhanh, hiệu quả, cho dù đó là nhãn ngắn hay được cuộn ngang qua một tài liệu lớn.

00:12:17.000 --> 00:12:23.000
TextKit 2 cùng tồn tại với TextKit 1, vì vậy bạn có thể chọn công cụ nào để sử dụng cho chế độ xem văn bản nhất định.

00:12:23.000 --> 00:12:25.000
Bây giờ tôi sẽ cho bạn biết một bí mật.

00:12:25.000 --> 00:12:36.000
Bạn đã chạy TextKit 2 trên máy Mac của mình vì bắt đầu từ Big Sur, TextEdit sử dụng nó cho các tài liệu văn bản thuần túy và các trường văn bản AppKit sử dụng TextKit 2 cho hầu hết các cấu hình.

00:12:36.000 --> 00:12:40.000
Vì vậy, bạn đã thực sự xem lén toàn bộ thời gian này.

00:12:40.000 --> 00:12:45.000
Một trong những điểm khác biệt chính trong TextKit 2 là nó luôn sử dụng hệ thống bố cục phi tuyến.

00:12:45.000 --> 00:12:52.000
Điều đó có nghĩa là nó có thể thực hiện bố cục văn bản ở cấp độ chi tiết hơn, điều này cho phép nó tránh được những công việc không cần thiết.

00:12:52.000 --> 00:13:04.000
Ví dụ, nếu chúng ta có một tài liệu lớn trong đó chỉ một phần của văn bản được cuộn để hiển thị, một hệ thống tuyến tính vẫn phải bố trí tất cả các văn bản trước đó để hiển thị khu vực này.

00:13:04.000 --> 00:13:11.000
Bằng cách so sánh, một hệ thống phi tuyến như TextKit 2 có thể bắt đầu bố cục ở ranh giới đoạn gần nhất.

00:13:11.000 --> 00:13:14.000
Đối với các tài liệu lớn, đây là một sự tăng tốc rất lớn.

00:13:14.000 --> 00:13:22.000
Công cụ bố cục mới cung cấp một tập hợp các điểm tùy chỉnh mạnh mẽ, giúp việc mở rộng hệ thống bố cục và thêm các hành vi của riêng bạn trở nên đơn giản.

00:13:22.000 --> 00:13:29.000
Hệ thống bố cục phi tuyến cũng cho phép trộn các yếu tố phi văn bản vào bố cục văn bản của bạn.

00:13:29.000 --> 00:13:33.000
Và nó thực hiện tất cả những điều này trong khi cải thiện hiệu suất cho ngay cả những tài liệu lớn nhất.

00:13:33.000 --> 00:13:41.000
Để tìm hiểu thêm, hãy xem "Gặp gỡ TextKit 2", đi vào chi tiết đầy đủ về thiết kế của API mới và cách sử dụng nó.

00:13:41.000 --> 00:13:49.000
Tiếp theo, tôi muốn chia sẻ một số cập nhật về AppKit trong Swift bắt đầu bằng đồng thời.

00:13:49.000 --> 00:13:54.000
Swift 5.5 giới thiệu một số tính năng cấp ngôn ngữ quan trọng để quản lý đồng thời.

00:13:54.000 --> 00:14:01.000
Đầu tiên, async/await, cho phép các cuộc gọi phương thức không đồng bộ hoạt động rất giống coroutines.

00:14:01.000 --> 00:14:09.000
Thứ hai, các loại diễn viên, bảo vệ trạng thái có thể thay đổi khỏi các cuộc đua dữ liệu bằng cách cô lập quyền truy cập vào một chuỗi thực thi duy nhất.

00:14:09.000 --> 00:14:12.000
AppKit hoạt động tốt với cả hai tính năng mới này.

00:14:12.000 --> 00:14:25.000
Đối với async/await, nhiều phương thức không đồng bộ trong AppKit - nghĩa là, các phương thức tiếp tục làm khối xử lý hoàn thành - đã được chuyển đổi trong SDK để cung cấp các biến thể không đồng bộ.

00:14:25.000 --> 00:14:31.000
Một ví dụ đơn giản là NSColorSampler, cho phép người dùng chọn màu từ bất kỳ đâu trên màn hình.

00:14:31.000 --> 00:14:39.000
Cuộc gọi này không đồng bộ vì nó đợi người dùng chọn màu họ muốn, và sau đó nó chạy trình xử lý hoàn thành khi họ hoàn thành.

00:14:39.000 --> 00:14:43.000
Với async/await, bạn có thể diễn đạt điều này dưới dạng một cuộc gọi hàm không đồng bộ.

00:14:43.000 --> 00:14:51.000
Nó mang lại chuỗi thực thi của nó trong khi nó đang chờ công việc không đồng bộ hoàn thành, và sau đó nó chọn lại ngay nơi nó đã dừng lại.

00:14:51.000 --> 00:14:53.000
Bạn thậm chí có thể làm điều đó từ bên trong một tuyên bố bảo vệ.

00:14:53.000 --> 00:15:00.000
Bây giờ, phần tiếp theo - công việc sẽ được thực hiện tiếp theo - không còn được lồng vào bên trong khối trình xử lý hoàn thành.

00:15:00.000 --> 00:15:06.000
Thay vào đó, mã đọc tự nhiên theo trình tự.

00:15:06.000 --> 00:15:12.000
Các diễn viên làm việc để bảo vệ trạng thái khỏi sự truy cập đồng thời bằng cách cô lập nó thành một chuỗi thực thi duy nhất.

00:15:12.000 --> 00:15:24.000
Nếu điều đó nghe có vẻ quen thuộc, đó là bởi vì hầu hết trạng thái của AppKit, như hệ thống phân cấp chế độ xem và chuỗi phản hồi, cũng nên được truy cập từ một luồng thực thi duy nhất, cụ thể là luồng chính.

00:15:24.000 --> 00:15:34.000
Hạn chế này phù hợp với mô hình diễn viên một cách độc đáo, vì vậy chúng tôi đã giới thiệu khái niệm MainActor, đây là một loại phải được truy cập từ chuỗi chính.

00:15:34.000 --> 00:15:51.000
Trong AppKit, chúng tôi đã chỉ định NSResponder bao gồm các lớp con của NSView, ViewController, WindowController và Application, cộng với NSCell, Alert, Document và DocumentController làm MainActors.

00:15:51.000 --> 00:15:59.000
Mã chạy trong MainActor có thể tự do gọi các phương thức trên các loại MainActor khác, vì bạn biết rằng bạn đã ở trên luồng chính.

00:15:59.000 --> 00:16:09.000
Tuy nhiên, mã không chạy trong MainActor phải sử dụng các tính năng không đồng bộ/chờ mới để thực hiện giao diện người dùng đó hoạt động trong ngữ cảnh của MainActor.

00:16:09.000 --> 00:16:17.000
Bằng cách thực thi điều này ở cấp độ trình biên dịch, Swift có thể giúp bạn tránh được một nguồn lỗi phổ biến khi trộn đồng thời với mã giao diện người dùng.

00:16:17.000 --> 00:16:21.000
Các video đồng thời Swift đi sâu vào tính năng ngôn ngữ mới mạnh mẽ này.

00:16:21.000 --> 00:16:24.000
Bạn không muốn bỏ lỡ chúng.

00:16:24.000 --> 00:16:30.000
Cũng mới trong Swift 5.5 là phiên bản được nhập giá trị của AttributedString.

00:16:30.000 --> 00:16:39.000
Ngoài việc cung cấp ngữ nghĩa giá trị, nó còn có các thuộc tính an toàn kiểu và công thái học Swift tuyệt vời để liệt kê và thao tác các phạm vi thuộc tính.

00:16:39.000 --> 00:16:51.000
Khi bạn đang sử dụng AttributedString với AppKit, bạn sẽ tự động có quyền truy cập vào các thuộc tính có liên quan đến hệ thống vẽ văn bản của chúng tôi; những thứ như màu nền trước, kiểu đoạn văn, v.v.

00:16:51.000 --> 00:17:00.000
Bạn có thể chuyển đổi giữa cấu trúc AttributedString và NSAttributedString được nhập tham chiếu, vì vậy bạn có thể tương tác với các API sử dụng NSAttributedString.

00:17:00.000 --> 00:17:06.000
Video "Có gì mới trong Foundation" đi vào chi tiết hơn về thiết kế của AttributedString và cách sử dụng nó.

00:17:06.000 --> 00:17:11.000
Cải tiến Swift cuối cùng của chúng tôi liên quan đến việc cập nhật lái xe cho NSViews của bạn.

00:17:11.000 --> 00:17:17.000
Nó sử dụng tính năng trình bao bọc thuộc tính của Swift để giảm đáng kể bản mẫu phổ biến trong các thuộc tính chế độ xem.

00:17:17.000 --> 00:17:19.000
Hãy xem qua một ví dụ.

00:17:19.000 --> 00:17:23.000
Đây là chế độ xem tùy chỉnh có thể định cấu hình thông qua một số thuộc tính.

00:17:23.000 --> 00:17:38.000
Và mặc dù điều này có vẻ ổn, nhưng thực tế là các khai báo thuộc tính trong quan điểm của chúng tôi có nhiều khả năng chứa nhiều didSets và các tác dụng phụ bổ sung, bởi vì nó phổ biến đến mức bạn cần vẽ lại hoặc bố cục hoặc cập nhật các ràng buộc của mình khi có điều gì đó thay đổi.

00:17:38.000 --> 00:17:40.000
Bây giờ, đó là rất nhiều nồi hơi.

00:17:40.000 --> 00:17:46.000
Vì vậy, chúng tôi đã làm cho kịch bản này tốt hơn bằng cách tạo một trình bao bọc thuộc tính Swift mới chỉ cho trường hợp này.

00:17:46.000 --> 00:17:48.000
Nó được gọi là Vô hiệu hóa.

00:17:48.000 --> 00:17:57.000
Nó được lồng trong NSView và nó cho phép bạn chỉ định một hoặc nhiều khía cạnh của chế độ xem để vô hiệu hóa khi thuộc tính được bọc thay đổi.

00:17:57.000 --> 00:18:06.000
Tất cả các didSets và dấu ngoặc đều biến mất, giúp việc tập trung vào định nghĩa của chính tài sản dễ dàng hơn.

00:18:06.000 --> 00:18:16.000
AppKit cung cấp một số trường hợp vô hiệu hóa tích hợp sẵn: hiển thị, bố cục, ràng buộc, kích thước nội dung nội tại và trạng thái có thể khôi phục.

00:18:16.000 --> 00:18:25.000
Vì những sự vô hiệu hóa này chỉ có ý nghĩa đối với các chế độ xem, chúng tôi đã hạn chế trình bao bọc thuộc tính để nó chỉ hoạt động trên các lớp con của NSView.

00:18:25.000 --> 00:18:29.000
Chúng tôi cũng yêu cầu giá trị phù hợp với Equatable.

00:18:29.000 --> 00:18:37.000
Chúng tôi sử dụng sự phù hợp này để kiểm tra những thay đổi có ý nghĩa về giá trị trước khi thực hiện vẽ lại hoặc vượt qua bố cục có khả năng tốn kém.

00:18:37.000 --> 00:18:46.000
Nếu bạn muốn làm điều gì đó tùy chỉnh, bạn thậm chí có thể xác định sự vô hiệu hóa của chính mình bằng cách tuân thủ một loại với giao thức NSViewInvalidating.

00:18:46.000 --> 00:18:49.000
Cuối Cùng, Các Phím Tắt.

00:18:49.000 --> 00:18:56.000
Trong macOS Monterey, chúng tôi rất vui mừng được mang toàn bộ sức mạnh của Phím tắt đến Mac và điều đó bao gồm tích hợp Phím tắt với các ứng dụng AppKit của bạn.

00:18:56.000 --> 00:19:07.000
Tin tuyệt vời là, nếu ứng dụng của bạn hỗ trợ Dịch vụ, thì nó đã hỗ trợ Phím tắt và Phím tắt xuất hiện ở tất cả những nơi giống nhau mà bạn có thể truy cập Dịch vụ ngay hôm nay.

00:19:07.000 --> 00:19:10.000
Nếu bạn chưa quen với chức năng này, nó thực sự dễ áp dụng.

00:19:10.000 --> 00:19:16.000
AppKit quyết định phím tắt nào phù hợp theo ngữ cảnh bằng cách kiểm tra chuỗi phản hồi.

00:19:16.000 --> 00:19:23.000
Nó hỏi mỗi người trả lời liệu nó có thể cung cấp hoặc nhận các loại dữ liệu được mong đợi bởi mỗi phím tắt hay không.

00:19:23.000 --> 00:19:29.000
Chúng tôi thể hiện điều này bằng cách sử dụng loại bảng dán, trong hầu hết các trường hợp, tương ứng với số nhận dạng loại thống nhất.

00:19:29.000 --> 00:19:34.000
Tất cả những gì bạn phải làm là triển khai validRequestor cho phương thức sendType và returnType.

00:19:34.000 --> 00:19:42.000
Và nếu bạn có thể chấp nhận hoặc cung cấp các loại được chỉ định, hãy trả về một đối tượng phù hợp với giao thức NSServicesMenuRequestor.

00:19:42.000 --> 00:19:46.000
Trong hầu hết các trường hợp, bạn sẽ chỉ thực hiện giao thức đó trực tiếp và sau đó trả lại bản thân.

00:19:46.000 --> 00:19:55.000
Khi một Phím tắt được gọi, bạn sẽ nhận được các cuộc gọi để ghi và/hoặc đọc dữ liệu từ một bảng dán đặc biệt mà Phím tắt sử dụng cho đầu vào và đầu ra của nó.

00:19:55.000 --> 00:19:56.000
Và thế là xong!

00:19:56.000 --> 00:19:59.000
Thật dễ dàng để tích hợp ứng dụng của bạn với Phím tắt.

00:19:59.000 --> 00:20:02.000
Chúng tôi cũng đã đưa Siri Intents lên macOS.

00:20:02.000 --> 00:20:06.000
Bây giờ bạn có thể xử lý Ý định bằng cách tạo Phần mở rộng Ý định trong Xcode.

00:20:06.000 --> 00:20:13.000
Hoặc, nếu bạn cần xử lý chúng từ ứng dụng chính của mình, bạn có thể trả lại trình xử lý Ý định từ đại diện ứng dụng của mình.

00:20:13.000 --> 00:20:21.000
Trong đại diện ứng dụng của bạn, hãy triển khai phương thức xử lý ứng dụng For intent:, trả về một đối tượng xử lý cho bất kỳ ý định nào mà bạn có thể xử lý.

00:20:21.000 --> 00:20:33.000
Mỗi loại ý định đều có giao thức xử lý riêng mà đối tượng được trả về phải tuân thủ, vì vậy hãy kiểm tra tài liệu khung Ý định để biết thêm chi tiết về việc triển khai đối tượng xử lý.

00:20:33.000 --> 00:20:37.000
Bây giờ bạn đã được trang bị tất cả thông tin mới này, điều gì tiếp theo?

00:20:37.000 --> 00:20:44.000
Đầu tiên, hãy nghĩ về cách các tính năng như điều khiển nhuộm màu và Biểu tượng SF 3 có thể giúp bạn nâng cao thiết kế ứng dụng của mình.

00:20:44.000 --> 00:20:52.000
Tiếp theo, nếu ứng dụng của bạn sử dụng TextKit để tạo trải nghiệm văn bản tùy chỉnh, hãy xem video "Gặp gỡ TextKit 2" và dùng thử API mới.

00:20:52.000 --> 00:21:00.000
Bạn sẽ thích cách dễ dàng để thể hiện bố cục tùy chỉnh và nội dung phong phú với TextKit 2.

00:21:00.000 --> 00:21:08.000
Cách ứng dụng của bạn quản lý đồng thời là một phần quan trọng trong kiến trúc của nó và các tính năng đồng thời mới của Swift sẽ là một cải tiến lớn trong lĩnh vực này.

00:21:08.000 --> 00:21:16.000
Bây giờ là lúc để bắt đầu lập kế hoạch cho cách các tính năng như async/await sẽ định hình cách ứng dụng của bạn quản lý khối lượng công việc đồng thời của nó.

00:21:16.000 --> 00:21:21.000
Cuối cùng, chuẩn bị sẵn sàng ứng dụng của bạn cho Phím tắt bằng cách áp dụng các tính năng tự động hóa của AppKit.

00:21:21.000 --> 00:21:23.000
Cảm ơn bạn đã dành thời gian và quan tâm.

00:21:23.000 --> 00:21:26.000
Chúng tôi hy vọng bạn thích tất cả những cải tiến tuyệt vời này trong macOS Monterey.

00:21:26.000 --> 23:59:59.000
♪

