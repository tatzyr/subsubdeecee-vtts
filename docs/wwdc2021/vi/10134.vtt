WEBVTT

00:00:01.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:13.000
Xin chào, tôi là Kavon, và tôi sẽ được tham gia bởi đồng nghiệp của tôi, Joe, sau này.

00:00:13.000 --> 00:00:19.000
Swift 5.5 giới thiệu một cách mới để viết các chương trình đồng thời, sử dụng một khái niệm gọi là đồng thời có cấu trúc.

00:00:19.000 --> 00:00:30.000
Các ý tưởng đằng sau tính đồng thời có cấu trúc dựa trên lập trình có cấu trúc, trực quan đến mức bạn hiếm khi nghĩ về nó, nhưng suy nghĩ về nó sẽ giúp bạn hiểu tính đồng thời có cấu trúc.

00:00:30.000 --> 00:00:34.000
Vậy chúng ta hãy đi sâu vào.

00:00:34.000 --> 00:00:43.000
Trong những ngày đầu của máy tính, các chương trình rất khó đọc vì chúng được viết dưới dạng một chuỗi các hướng dẫn, trong đó luồng điều khiển được phép nhảy khắp nơi.

00:00:43.000 --> 00:00:49.000
Bạn không thấy điều đó ngày nay, bởi vì các ngôn ngữ sử dụng lập trình có cấu trúc để làm cho luồng điều khiển thống nhất hơn.

00:00:49.000 --> 00:00:54.000
Ví dụ, câu lệnh if-then sử dụng luồng điều khiển có cấu trúc.

00:00:54.000 --> 00:01:00.000
Nó chỉ định rằng một khối mã lồng nhau chỉ được thực thi có điều kiện trong khi di chuyển từ trên xuống dưới.

00:01:00.000 --> 00:01:08.000
Trong Swift, khối đó cũng tôn trọng phạm vi tĩnh, có nghĩa là các tên chỉ hiển thị nếu chúng được xác định trong một khối kèm theo.

00:01:08.000 --> 00:01:15.000
Điều này cũng có nghĩa là tuổi thọ của bất kỳ biến nào được xác định trong một khối sẽ kết thúc khi rời khỏi khối.

00:01:15.000 --> 00:01:23.000
Vì vậy, lập trình có cấu trúc với phạm vi tĩnh giúp luồng điều khiển và tuổi thọ thay đổi dễ hiểu.

00:01:23.000 --> 00:01:29.000
Tổng quát hơn, luồng điều khiển có cấu trúc có thể được sắp xếp theo trình tự và lồng vào nhau một cách tự nhiên.

00:01:29.000 --> 00:01:33.000
Điều này cho phép bạn đọc toàn bộ chương trình của mình từ trên xuống dưới.

00:01:33.000 --> 00:01:37.000
Vì vậy, đó là những nguyên tắc cơ bản của lập trình có cấu trúc.

00:01:37.000 --> 00:01:42.000
Như bạn có thể tưởng tượng, thật dễ dàng để coi là điều hiển nhiên, bởi vì nó rất trực quan đối với chúng ta ngày nay.

00:01:42.000 --> 00:01:51.000
Nhưng các chương trình ngày nay có mã không đồng bộ và đồng thời, và chúng không thể sử dụng lập trình có cấu trúc để làm cho mã đó dễ viết hơn.

00:01:51.000 --> 00:01:56.000
Đầu tiên, hãy xem xét cách lập trình có cấu trúc làm cho mã không đồng bộ đơn giản hơn.

00:01:56.000 --> 00:02:03.000
Nói rằng bạn cần tìm nạp một loạt hình ảnh từ internet và thay đổi kích thước chúng thành hình thu nhỏ một cách tuần tự.

00:02:03.000 --> 00:02:09.000
Mã này hoạt động không đồng bộ, lấy một bộ sưu tập các chuỗi xác định hình ảnh.

00:02:09.000 --> 00:02:13.000
Bạn sẽ nhận thấy hàm này không trả về một giá trị khi được gọi.

00:02:13.000 --> 00:02:18.000
Đó là bởi vì hàm chuyển kết quả của nó, hoặc một lỗi, cho một trình xử lý hoàn thành mà nó đã được đưa ra.

00:02:18.000 --> 00:02:23.000
Mẫu này cho phép người gọi nhận được câu trả lời sau.

00:02:23.000 --> 00:02:29.000
Do hậu quả của mẫu đó, chức năng này không thể sử dụng luồng điều khiển có cấu trúc để xử lý lỗi.

00:02:29.000 --> 00:02:35.000
Đó là bởi vì nó chỉ có ý nghĩa để xử lý các lỗi được ném ra khỏi một chức năng, không phải vào một chức năng.

00:02:35.000 --> 00:02:39.000
Ngoài ra, mẫu này ngăn bạn sử dụng một vòng lặp để xử lý từng hình thu nhỏ.

00:02:39.000 --> 00:02:46.000
Đệ quy là bắt buộc, bởi vì mã chạy sau khi hàm hoàn thành phải được lồng trong trình xử lý.

00:02:46.000 --> 00:02:55.000
Bây giờ, chúng ta hãy xem mã trước đó nhưng được viết lại để sử dụng cú pháp không đồng bộ/chờ mới, dựa trên lập trình có cấu trúc.

00:02:55.000 --> 00:02:59.000
Tôi đã bỏ đối số trình xử lý hoàn thành khỏi hàm.

00:02:59.000 --> 00:03:04.000
Thay vào đó, nó được chú thích bằng "không đồng bộ" và "ném" trong chữ ký loại của nó.

00:03:04.000 --> 00:03:07.000
Nó cũng trả về một giá trị thay vì không có gì.

00:03:07.000 --> 00:03:17.000
Trong phần thân của hàm, tôi sử dụng "chờ đợi" để nói rằng một hành động không đồng bộ xảy ra và không cần lồng nhau cho mã chạy sau hành động đó.

00:03:17.000 --> 00:03:21.000
Điều này có nghĩa là bây giờ tôi có thể lặp lại các hình thu nhỏ để xử lý chúng tuần tự.

00:03:21.000 --> 00:03:27.000
Tôi cũng có thể ném và bắt lỗi, và trình biên dịch sẽ kiểm tra xem tôi đã không quên.

00:03:27.000 --> 00:03:40.000
Để có cái nhìn sâu sắc về async/await, hãy xem phiên "Gặp gỡ async/await trong Swift." Vì vậy, mã này rất tuyệt, nhưng nếu bạn đang tạo hình thu nhỏ cho hàng nghìn hình ảnh thì sao?

00:03:40.000 --> 00:03:44.000
Xử lý từng hình thu nhỏ một không còn lý tưởng nữa.

00:03:44.000 --> 00:03:50.000
Thêm vào đó, điều gì sẽ xảy ra nếu kích thước của mỗi hình thu nhỏ phải được tải xuống từ một URL khác, thay vì là một kích thước cố định?

00:03:50.000 --> 00:03:56.000
Bây giờ có một cơ hội để thêm một số đồng thời, vì vậy nhiều lần tải xuống có thể diễn ra song song.

00:03:56.000 --> 00:04:00.000
Bạn có thể tạo các tác vụ bổ sung để thêm tính đồng thời vào chương trình.

00:04:00.000 --> 00:04:05.000
Nhiệm vụ là một tính năng mới trong Swift hoạt động song song với các chức năng không đồng bộ.

00:04:05.000 --> 00:04:10.000
Một nhiệm vụ cung cấp một ngữ cảnh thực thi mới để chạy mã không đồng bộ.

00:04:10.000 --> 00:04:14.000
Mỗi nhiệm vụ chạy đồng thời đối với các bối cảnh thực thi khác.

00:04:14.000 --> 00:04:20.000
Chúng sẽ được tự động lên lịch để chạy song song khi an toàn và hiệu quả để làm như vậy.

00:04:20.000 --> 00:04:26.000
Bởi vì các tác vụ được tích hợp sâu vào Swift, trình biên dịch có thể giúp ngăn chặn một số lỗi đồng thời.

00:04:26.000 --> 00:04:31.000
Ngoài ra, hãy nhớ rằng việc gọi một hàm không đồng bộ không tạo ra một nhiệm vụ mới cho cuộc gọi.

00:04:31.000 --> 00:04:34.000
Bạn tạo ra các nhiệm vụ một cách rõ ràng.

00:04:34.000 --> 00:04:43.000
Có một vài hương vị khác nhau của các nhiệm vụ trong Swift, bởi vì tính đồng thời có cấu trúc là về sự cân bằng giữa tính linh hoạt và sự đơn giản.

00:04:43.000 --> 00:04:51.000
Vì vậy, trong phần còn lại của phiên này, Joe và tôi sẽ giới thiệu và thảo luận về từng loại nhiệm vụ để giúp bạn hiểu được sự đánh đổi của họ.

00:04:51.000 --> 00:04:58.000
Hãy bắt đầu với nhiệm vụ đơn giản nhất trong số những nhiệm vụ này, được tạo ra với một dạng cú pháp mới được gọi là ràng buộc async-let.

00:04:58.000 --> 00:05:06.000
Để giúp bạn hiểu dạng cú pháp mới này, trước tiên tôi muốn chia nhỏ đánh giá về một ràng buộc thông thường.

00:05:06.000 --> 00:05:12.000
Có hai phần: biểu thức khởi tạo ở phía bên phải của bằng và tên của biến ở bên trái.

00:05:12.000 --> 00:05:18.000
Có thể có những tuyên bố khác trước hoặc sau khi cho phép, vì vậy tôi cũng sẽ bao gồm những tuyên bố đó ở đây.

00:05:18.000 --> 00:05:24.000
Khi Swift đạt đến ràng buộc let, trình khởi tạo của nó sẽ được đánh giá để tạo ra một giá trị.

00:05:24.000 --> 00:05:30.000
Trong ví dụ này, điều đó có nghĩa là tải xuống dữ liệu từ URL, có thể mất một lúc.

00:05:30.000 --> 00:05:39.000
Sau khi dữ liệu đã được tải xuống, Swift sẽ liên kết giá trị đó với tên biến trước khi tiến hành các câu lệnh tiếp theo.

00:05:39.000 --> 00:05:45.000
Lưu ý rằng chỉ có một luồng thực thi ở đây, như được theo dõi bởi các mũi tên qua mỗi bước.

00:05:45.000 --> 00:05:54.000
Vì quá trình tải xuống có thể mất một lúc, bạn muốn chương trình bắt đầu tải xuống dữ liệu và tiếp tục thực hiện các công việc khác cho đến khi dữ liệu thực sự cần thiết.

00:05:54.000 --> 00:05:59.000
Để đạt được điều này, bạn chỉ cần thêm từ không đồng bộ trước một ràng buộc let hiện có.

00:05:59.000 --> 00:06:04.000
Điều này biến nó thành một ràng buộc đồng thời được gọi là async-let.

00:06:04.000 --> 00:06:10.000
Việc đánh giá một ràng buộc đồng thời khá khác so với một liên kết tuần tự, vì vậy hãy tìm hiểu cách nó hoạt động.

00:06:10.000 --> 00:06:14.000
Tôi sẽ bắt đầu ngay tại thời điểm trước khi gặp phải sự ràng buộc.

00:06:14.000 --> 00:06:21.000
Để đánh giá một ràng buộc đồng thời, Swift trước tiên sẽ tạo một nhiệm vụ con mới, đây là một nhiệm vụ con của tác vụ đã tạo ra nó.

00:06:21.000 --> 00:06:29.000
Bởi vì mọi nhiệm vụ đại diện cho một bối cảnh thực thi cho chương trình của bạn, hai mũi tên sẽ đồng thời xuất hiện từ bước này.

00:06:29.000 --> 00:06:34.000
Mũi tên đầu tiên này dành cho tác vụ con, sẽ ngay lập tức bắt đầu tải xuống dữ liệu.

00:06:34.000 --> 00:06:41.000
Mũi tên thứ hai dành cho tác vụ mẹ, sẽ ngay lập tức liên kết kết quả biến với giá trị giữ chỗ.

00:06:41.000 --> 00:06:46.000
Nhiệm vụ mẹ này cũng giống như nhiệm vụ đã thực hiện các câu lệnh trước đó.

00:06:46.000 --> 00:06:54.000
Trong khi dữ liệu đang được tải xuống đồng thời bởi đứa trẻ, tác vụ mẹ tiếp tục thực hiện các câu lệnh tuân theo ràng buộc đồng thời.

00:06:54.000 --> 00:07:06.000
Nhưng khi đạt được một biểu thức cần giá trị thực tế của kết quả, phụ huynh sẽ chờ hoàn thành nhiệm vụ con, nhiệm vụ này sẽ hoàn thành trình giữ chỗ cho kết quả.

00:07:06.000 --> 00:07:10.000
Trong ví dụ này, cuộc gọi của chúng tôi đến URLSession cũng có thể gây ra lỗi.

00:07:10.000 --> 00:07:13.000
Điều này có nghĩa là việc chờ kết quả có thể khiến chúng ta gặp lỗi.

00:07:13.000 --> 00:07:17.000
Vì vậy, tôi cần viết "cố gắng" để chăm sóc nó.

00:07:17.000 --> 00:07:18.000
Và đừng lo lắng.

00:07:18.000 --> 00:07:22.000
Đọc lại giá trị của kết quả sẽ không tính toán lại giá trị của nó.

00:07:22.000 --> 00:07:28.000
Bây giờ bạn đã thấy cách hoạt động của async-let, bạn có thể sử dụng nó để thêm tính đồng thời vào mã tìm nạp hình thu nhỏ.

00:07:28.000 --> 00:07:33.000
Tôi đã tính đến một đoạn mã trước đó để tìm nạp một hình ảnh duy nhất vào chức năng riêng của nó.

00:07:33.000 --> 00:07:44.000
Chức năng mới này ở đây cũng đang tải xuống dữ liệu từ hai URL khác nhau: một cho chính hình ảnh có kích thước đầy đủ và một cho siêu dữ liệu, chứa kích thước hình thu nhỏ tối ưu.

00:07:44.000 --> 00:07:53.000
Lưu ý rằng với một ràng buộc tuần tự, bạn viết "thử chờ đợi" ở phía bên phải của let, bởi vì đó là nơi sẽ quan sát thấy lỗi hoặc đình chỉ.

00:07:53.000 --> 00:07:59.000
Để làm cho cả hai lần tải xuống diễn ra đồng thời, bạn viết "không đồng bộ" trước cả hai điều này.

00:07:59.000 --> 00:08:06.000
Vì việc tải xuống hiện đang diễn ra trong các tác vụ con, bạn không còn viết "thử chờ đợi" ở phía bên phải của ràng buộc đồng thời.

00:08:06.000 --> 00:08:13.000
Những hiệu ứng đó chỉ được quan sát bởi nhiệm vụ mẹ khi sử dụng các biến bị ràng buộc đồng thời.

00:08:13.000 --> 00:08:19.000
Vì vậy, bạn viết "thử chờ đợi" trước khi biểu thức đọc siêu dữ liệu và dữ liệu hình ảnh.

00:08:19.000 --> 00:08:26.000
Ngoài ra, lưu ý rằng việc sử dụng các biến bị ràng buộc đồng thời này không yêu cầu gọi phương thức hoặc bất kỳ thay đổi nào khác.

00:08:26.000 --> 00:08:31.000
Những biến đó có cùng loại mà chúng đã làm trong một ràng buộc tuần tự.

00:08:31.000 --> 00:08:37.000
Bây giờ, những nhiệm vụ con mà tôi đang nói đến thực sự là một phần của hệ thống phân cấp được gọi là cây nhiệm vụ.

00:08:37.000 --> 00:08:40.000
Cây này không chỉ là một chi tiết triển khai.

00:08:40.000 --> 00:08:43.000
Đó là một phần quan trọng của sự đồng thời có cấu trúc.

00:08:43.000 --> 00:08:50.000
Nó ảnh hưởng đến các thuộc tính của các nhiệm vụ của bạn như hủy bỏ, ưu tiên và các biến cục bộ nhiệm vụ.

00:08:50.000 --> 00:08:56.000
Bất cứ khi nào bạn thực hiện cuộc gọi từ hàm không đồng bộ này sang hàm không đồng bộ khác, nhiệm vụ tương tự sẽ được sử dụng để thực hiện cuộc gọi.

00:08:56.000 --> 00:09:01.000
Vì vậy, hàm fetchOneThumbnail kế thừa tất cả các thuộc tính của tác vụ đó.

00:09:01.000 --> 00:09:09.000
Khi tạo một tác vụ có cấu trúc mới như với async-let, nó sẽ trở thành con của tác vụ mà hàm hiện tại đang chạy.

00:09:09.000 --> 00:09:15.000
Các nhiệm vụ không phải là con của một chức năng cụ thể, nhưng tuổi thọ của chúng có thể được xác định phạm vi của nó.

00:09:15.000 --> 00:09:19.000
Cây được tạo thành từ các liên kết giữa mỗi nhiệm vụ cha mẹ và con của nó.

00:09:19.000 --> 00:09:26.000
Một liên kết thực thi một quy tắc nói rằng một nhiệm vụ mẹ chỉ có thể hoàn thành công việc của nó nếu tất cả các nhiệm vụ con của nó đã hoàn thành.

00:09:26.000 --> 00:09:33.000
Quy tắc này vẫn tồn tại ngay cả khi đối mặt với dòng chảy kiểm soát bất thường sẽ ngăn chặn một nhiệm vụ trẻ em được chờ đợi.

00:09:33.000 --> 00:09:40.000
Ví dụ, trong mã này, trước tiên tôi chờ tác vụ siêu dữ liệu trước tác vụ dữ liệu hình ảnh.

00:09:40.000 --> 00:09:49.000
Nếu tác vụ được chờ đợi đầu tiên kết thúc bằng cách ném lỗi, hàm fetchOneThumbnail phải thoát ngay lập tức bằng cách ném lỗi đó.

00:09:49.000 --> 00:09:53.000
Nhưng điều gì sẽ xảy ra với nhiệm vụ thực hiện lần tải xuống thứ hai?

00:09:53.000 --> 00:10:03.000
Trong quá trình thoát bất thường, Swift sẽ tự động đánh dấu tác vụ không mong đợi là đã bị hủy và sau đó đợi nó kết thúc trước khi thoát khỏi chức năng.

00:10:03.000 --> 00:10:07.000
Đánh dấu một nhiệm vụ là đã hủy không dừng nhiệm vụ.

00:10:07.000 --> 00:10:11.000
Nó chỉ đơn giản thông báo cho nhiệm vụ rằng kết quả của nó không còn cần thiết nữa.

00:10:11.000 --> 00:10:18.000
Trên thực tế, khi một nhiệm vụ bị hủy bỏ, tất cả các nhiệm vụ phụ đã quá hạn của nhiệm vụ đó cũng sẽ tự động bị hủy.

00:10:18.000 --> 00:10:27.000
Vì vậy, nếu việc triển khai URLSession tạo ra các tác vụ có cấu trúc của riêng nó để tải xuống hình ảnh, những tác vụ đó sẽ được đánh dấu để hủy bỏ.

00:10:27.000 --> 00:10:37.000
Hàm fetchOneThumbnail cuối cùng cũng thoát ra bằng cách ném lỗi khi tất cả các tác vụ có cấu trúc mà nó tạo trực tiếp hoặc gián tiếp đã kết thúc.

00:10:37.000 --> 00:10:40.000
Sự đảm bảo này là nền tảng cho sự đồng thời có cấu trúc.

00:10:40.000 --> 00:10:50.000
Nó ngăn bạn vô tình rò rỉ các tác vụ bằng cách giúp bạn quản lý vòng đời của chúng, giống như cách ARC tự động quản lý vòng đời của bộ nhớ.

00:10:50.000 --> 00:10:54.000
Cho đến nay, tôi đã cung cấp cho bạn một cái nhìn tổng quan về cách hủy bỏ lan truyền.

00:10:54.000 --> 00:10:57.000
Nhưng khi nào nhiệm vụ cuối cùng dừng lại?

00:10:57.000 --> 00:11:04.000
Nếu nhiệm vụ đang ở giữa một giao dịch quan trọng hoặc có kết nối mạng mở, sẽ không chính xác nếu chỉ dừng nhiệm vụ.

00:11:04.000 --> 00:11:08.000
Đó là lý do tại sao việc hủy nhiệm vụ trong Swift là hợp tác.

00:11:08.000 --> 00:11:15.000
Mã của bạn phải kiểm tra việc hủy bỏ một cách rõ ràng và giảm bớt việc thực thi theo bất kỳ cách nào phù hợp.

00:11:15.000 --> 00:11:21.000
Bạn có thể kiểm tra trạng thái hủy của nhiệm vụ hiện tại từ bất kỳ chức năng nào, cho dù nó có không đồng bộ hay không.

00:11:21.000 --> 00:11:29.000
Điều này có nghĩa là bạn nên triển khai các API của mình với mục đích hủy bỏ, đặc biệt nếu chúng liên quan đến các tính toán lâu dài.

00:11:29.000 --> 00:11:38.000
Người dùng của bạn có thể gọi mã của bạn từ một tác vụ có thể bị hủy và họ sẽ mong đợi việc tính toán dừng lại càng sớm càng tốt.

00:11:38.000 --> 00:11:45.000
Để xem việc sử dụng hủy hợp tác đơn giản như thế nào, chúng ta hãy quay lại ví dụ tìm nạp hình thu nhỏ.

00:11:45.000 --> 00:11:53.000
Ở đây, tôi đã viết lại hàm ban đầu được cung cấp tất cả các hình thu nhỏ để tìm nạp để nó sử dụng hàm fetchOneThumbnail thay thế.

00:11:53.000 --> 00:12:02.000
Nếu chức năng này được gọi trong một tác vụ đã bị hủy, chúng tôi không muốn giữ ứng dụng của mình bằng cách tạo các hình thu nhỏ vô dụng.

00:12:02.000 --> 00:12:07.000
Vì vậy, tôi chỉ có thể thêm một cuộc gọi để kiểm tra Hủy bỏ ở đầu mỗi lần lặp vòng lặp.

00:12:07.000 --> 00:12:12.000
Cuộc gọi này chỉ gây ra lỗi nếu nhiệm vụ hiện tại đã bị hủy.

00:12:12.000 --> 00:12:19.000
Bạn cũng có thể lấy trạng thái hủy của nhiệm vụ hiện tại dưới dạng giá trị Boolean nếu điều đó phù hợp hơn với mã của bạn.

00:12:19.000 --> 00:12:27.000
Lưu ý rằng trong phiên bản hàm này, tôi đang trả về một phần kết quả, một từ điển chỉ có một số hình thu nhỏ được yêu cầu.

00:12:27.000 --> 00:12:34.000
Khi làm điều này, bạn phải đảm bảo rằng API của bạn nêu rõ rằng một phần kết quả có thể được trả về.

00:12:34.000 --> 00:12:43.000
Nếu không, việc hủy nhiệm vụ có thể gây ra lỗi nghiêm trọng cho người dùng của bạn vì mã của họ yêu cầu kết quả hoàn chỉnh ngay cả trong quá trình hủy.

00:12:43.000 --> 00:12:52.000
Cho đến nay, bạn đã thấy rằng async-let cung cấp một cú pháp nhẹ để thêm tính đồng thời vào chương trình của bạn trong khi nắm bắt được bản chất của lập trình có cấu trúc.

00:12:52.000 --> 00:12:56.000
Loại nhiệm vụ tiếp theo mà tôi muốn nói với bạn được gọi là nhiệm vụ nhóm.

00:12:56.000 --> 00:13:03.000
Chúng cung cấp tính linh hoạt hơn so với async-let mà không từ bỏ tất cả các thuộc tính tốt đẹp của đồng thời có cấu trúc.

00:13:03.000 --> 00:13:08.000
Như chúng ta đã thấy trước đó, async-let hoạt động tốt khi có sẵn một lượng đồng thời cố định.

00:13:08.000 --> 00:13:11.000
Hãy xem xét cả hai chức năng mà tôi đã thảo luận trước đó.

00:13:11.000 --> 00:13:19.000
Đối với mỗi ID hình thu nhỏ trong vòng lặp, chúng tôi gọi fetchOneThumbnail để xử lý nó, tạo ra chính xác hai tác vụ con.

00:13:19.000 --> 00:13:26.000
Ngay cả khi chúng ta nội dung của hàm đó vào vòng lặp này, số lượng đồng thời sẽ không thay đổi.

00:13:26.000 --> 00:13:28.000
Async-let có phạm vi giống như một liên kết biến.

00:13:28.000 --> 00:13:34.000
Điều đó có nghĩa là hai nhiệm vụ con phải hoàn thành trước khi vòng lặp tiếp theo bắt đầu.

00:13:34.000 --> 00:13:41.000
Nhưng điều gì sẽ xảy ra nếu chúng ta muốn vòng lặp này bắt đầu các tác vụ để tìm nạp đồng thời tất cả các hình thu nhỏ?

00:13:41.000 --> 00:13:48.000
Sau đó, số lượng đồng thời không được biết đến tĩnh vì nó phụ thuộc vào số lượng ID trong mảng.

00:13:48.000 --> 00:13:51.000
Công cụ phù hợp cho tình huống này là một nhóm nhiệm vụ.

00:13:51.000 --> 00:13:56.000
Nhóm nhiệm vụ là một hình thức đồng thời có cấu trúc được thiết kế để cung cấp một lượng đồng thời động.

00:13:56.000 --> 00:14:01.000
Bạn có thể giới thiệu một nhóm tác vụ bằng cách gọi hàm withThrowingTaskGroup.

00:14:01.000 --> 00:14:08.000
Chức năng này cung cấp cho bạn một đối tượng nhóm có phạm vi để tạo các tác vụ con được phép ném lỗi.

00:14:08.000 --> 00:14:14.000
Các nhiệm vụ được thêm vào một nhóm không thể tồn tại lâu hơn phạm vi của khối mà nhóm được xác định.

00:14:14.000 --> 00:14:21.000
Vì tôi đã đặt toàn bộ for-loop bên trong khối, bây giờ tôi có thể tạo một số lượng nhiệm vụ động bằng cách sử dụng nhóm.

00:14:21.000 --> 00:14:25.000
Bạn tạo các nhiệm vụ con trong một nhóm bằng cách gọi phương thức không đồng bộ của nó.

00:14:25.000 --> 00:14:31.000
Sau khi được thêm vào một nhóm, các nhiệm vụ con bắt đầu thực hiện ngay lập tức và theo bất kỳ thứ tự nào.

00:14:31.000 --> 00:14:37.000
Khi đối tượng nhóm đi ra khỏi phạm vi, việc hoàn thành tất cả các nhiệm vụ bên trong nó sẽ được ngầm chờ đợi.

00:14:37.000 --> 00:14:44.000
Đây là hệ quả của quy tắc cây nhiệm vụ mà tôi đã mô tả trước đó, bởi vì các nhiệm vụ nhóm cũng được cấu trúc.

00:14:44.000 --> 00:14:55.000
Tại thời điểm này, chúng tôi đã đạt được sự đồng thời mà chúng tôi muốn: một nhiệm vụ cho mỗi cuộc gọi đến fetchOneThumbnail, bản thân nó sẽ tạo thêm hai tác vụ bằng cách sử dụng async-let.

00:14:55.000 --> 00:14:58.000
Đó là một tài sản tuyệt vời khác của sự đồng thời có cấu trúc.

00:14:58.000 --> 00:15:08.000
Bạn có thể sử dụng async-let trong các tác vụ nhóm hoặc tạo các nhóm tác vụ trong các tác vụ async-let và các mức độ đồng thời trong cây sáng tác tự nhiên.

00:15:08.000 --> 00:15:11.000
Bây giờ, mã này chưa hoàn toàn sẵn sàng để chạy.

00:15:11.000 --> 00:15:16.000
Nếu chúng tôi cố gắng chạy nó, trình biên dịch sẽ cảnh báo chúng tôi một cách hữu ích về vấn đề cuộc đua dữ liệu.

00:15:16.000 --> 00:15:21.000
Vấn đề là chúng tôi đang cố gắng chèn một hình thu nhỏ vào một từ điển duy nhất từ mỗi nhiệm vụ con.

00:15:21.000 --> 00:15:25.000
Đây là một sai lầm phổ biến khi tăng số lượng đồng thời trong chương trình của bạn.

00:15:25.000 --> 00:15:28.000
Các cuộc đua dữ liệu vô tình được tạo ra.

00:15:28.000 --> 00:15:39.000
Từ điển này không thể xử lý nhiều hơn một lần truy cập cùng một lúc và nếu hai tác vụ con cố gắng chèn hình thu nhỏ đồng thời, điều đó có thể gây ra sự cố hoặc hỏng dữ liệu.

00:15:39.000 --> 00:15:47.000
Trước đây, bạn phải tự mình điều tra những lỗi đó, nhưng Swift cung cấp kiểm tra tĩnh để ngăn chặn những lỗi đó xảy ra ngay từ đầu.

00:15:47.000 --> 00:15:55.000
Bất cứ khi nào bạn tạo một nhiệm vụ mới, công việc mà nhiệm vụ thực hiện nằm trong một loại đóng mới được gọi là đóng @Sendable.

00:15:55.000 --> 00:16:05.000
Phần thân của đóng @Sendable bị hạn chế nắm bắt các biến có thể thay đổi trong ngữ cảnh từ vựng của nó, bởi vì các biến đó có thể được sửa đổi sau khi tác vụ được khởi chạy.

00:16:05.000 --> 00:16:09.000
Điều này có nghĩa là các giá trị bạn nắm bắt được trong một nhiệm vụ phải an toàn để chia sẻ.

00:16:09.000 --> 00:16:22.000
Ví dụ, bởi vì chúng là các loại giá trị, như Int và String, hoặc bởi vì chúng là các đối tượng được thiết kế để truy cập từ nhiều luồng, như các diễn viên và các lớp thực hiện đồng bộ hóa của riêng chúng.

00:16:22.000 --> 00:16:30.000
Chúng tôi có cả một phiên dành riêng cho chủ đề này, được gọi là "Bảo vệ trạng thái có thể thay đổi với các diễn viên Swift", vì vậy tôi khuyến khích bạn kiểm tra nó.

00:16:30.000 --> 00:16:35.000
Để tránh cuộc đua dữ liệu trong ví dụ của chúng tôi, bạn có thể yêu cầu mỗi nhiệm vụ con trả về một giá trị.

00:16:35.000 --> 00:16:40.000
Thiết kế này giao cho nhiệm vụ cha mẹ trách nhiệm duy nhất trong việc xử lý kết quả.

00:16:40.000 --> 00:16:49.000
Trong trường hợp này, tôi đã chỉ định rằng mỗi tác vụ con phải trả về một bộ chứa ID Chuỗi và UIImage cho hình thu nhỏ.

00:16:49.000 --> 00:16:58.000
Sau đó, bên trong mỗi nhiệm vụ con, thay vì viết trực tiếp vào từ điển, tôi yêu cầu chúng trả về bộ giá trị khóa để cha mẹ xử lý.

00:16:58.000 --> 00:17:04.000
Nhiệm vụ cha mẹ có thể lặp lại thông qua các kết quả từ mỗi nhiệm vụ con bằng cách sử dụng vòng lặp chờ đợi mới.

00:17:04.000 --> 00:17:09.000
Vòng lặp chờ đợi thu được kết quả từ các nhiệm vụ con theo thứ tự hoàn thành.

00:17:09.000 --> 00:17:17.000
Bởi vì vòng lặp này chạy tuần tự, tác vụ mẹ có thể thêm từng cặp giá trị khóa vào từ điển một cách an toàn.

00:17:17.000 --> 00:17:23.000
Đây chỉ là một ví dụ về việc sử dụng vòng lặp for-await để truy cập một chuỗi các giá trị không đồng bộ.

00:17:23.000 --> 00:17:30.000
Nếu loại của riêng bạn phù hợp với giao thức AsyncSequence, thì bạn cũng có thể sử dụng for-await để lặp lại chúng.

00:17:30.000 --> 00:17:34.000
Bạn có thể tìm hiểu thêm trong phiên "Gặp gỡ AsyncSequence".

00:17:34.000 --> 00:17:43.000
Mặc dù các nhóm nhiệm vụ là một dạng đồng thời có cấu trúc, nhưng có một sự khác biệt nhỏ trong cách thực hiện quy tắc cây nhiệm vụ cho các nhiệm vụ nhóm so với các nhiệm vụ cho thuê không đồng bộ.

00:17:43.000 --> 00:17:50.000
Giả sử khi lặp lại kết quả của nhóm này, tôi gặp phải một nhiệm vụ con đã hoàn thành với một lỗi.

00:17:50.000 --> 00:17:57.000
Bởi vì lỗi đó được ném ra khỏi khối của nhóm, tất cả các nhiệm vụ trong nhóm sau đó sẽ bị ngầm hủy bỏ và sau đó được chờ đợi.

00:17:57.000 --> 00:17:59.000
Cái này hoạt động giống như async-let.

00:17:59.000 --> 00:18:05.000
Sự khác biệt đến khi nhóm của bạn đi ra khỏi phạm vi thông qua một lối thoát bình thường từ khối.

00:18:05.000 --> 00:18:08.000
Sau đó, việc hủy bỏ không phải là ngầm định.

00:18:08.000 --> 00:18:17.000
Hành vi này giúp bạn dễ dàng thể hiện mô hình tham gia ngã ba bằng cách sử dụng một nhóm nhiệm vụ, bởi vì các công việc sẽ chỉ được chờ đợi, không bị hủy bỏ.

00:18:17.000 --> 00:18:24.000
Bạn cũng có thể hủy tất cả các tác vụ theo cách thủ công trước khi thoát khỏi khối bằng phương thức cancelAll của nhóm.

00:18:24.000 --> 00:18:31.000
Hãy nhớ rằng bất kể bạn hủy một nhiệm vụ như thế nào, việc hủy bỏ sẽ tự động lan truyền xuống cây.

00:18:31.000 --> 00:18:37.000
Nhiệm vụ Async-let và nhóm là hai loại nhiệm vụ cung cấp các nhiệm vụ có cấu trúc có phạm vi trong Swift.

00:18:37.000 --> 00:18:42.000
Bây giờ, tôi sẽ giao mọi thứ cho Joe, người sẽ cho bạn biết về các nhiệm vụ phi cấu trúc.

00:18:42.000 --> 00:18:43.000
Cảm ơn, Kavon.

00:18:43.000 --> 00:18:45.000
Xin chào. Tôi là Joe.

00:18:45.000 --> 00:18:55.000
Kavon đã chỉ cho bạn cách đồng thời có cấu trúc đơn giản hóa việc truyền lỗi, hủy và các sổ sách kế toán khác khi bạn thêm đồng thời vào một chương trình với hệ thống phân cấp rõ ràng cho các nhiệm vụ.

00:18:55.000 --> 00:19:00.000
Nhưng chúng tôi biết rằng bạn không phải lúc nào cũng có hệ thống phân cấp khi bạn thêm nhiệm vụ vào chương trình của mình.

00:19:00.000 --> 00:19:08.000
Swift cũng cung cấp các API tác vụ phi cấu trúc, giúp bạn linh hoạt hơn rất nhiều với chi phí cần quản lý thủ công nhiều hơn.

00:19:08.000 --> 00:19:13.000
Có rất nhiều tình huống mà một nhiệm vụ có thể không rơi vào một hệ thống phân cấp rõ ràng.

00:19:13.000 --> 00:19:21.000
Rõ ràng nhất, bạn có thể không có tác vụ mẹ nếu bạn đang cố gắng khởi chạy một tác vụ để thực hiện tính toán không đồng bộ từ mã không đồng bộ.

00:19:21.000 --> 00:19:28.000
Ngoài ra, tuổi thọ bạn muốn cho một nhiệm vụ có thể không phù hợp với giới hạn của một phạm vi duy nhất hoặc thậm chí là một chức năng duy nhất.

00:19:28.000 --> 00:19:40.000
Ví dụ, bạn có thể muốn bắt đầu một tác vụ để phản hồi một cuộc gọi phương thức đặt một đối tượng vào trạng thái hoạt động và sau đó hủy việc thực thi nó để phản hồi một cuộc gọi phương thức khác hủy kích hoạt đối tượng.

00:19:40.000 --> 00:19:45.000
Điều này xuất hiện rất nhiều khi triển khai các đối tượng đại diện trong AppKit và UIKit.

00:19:45.000 --> 00:19:57.000
Công việc giao diện người dùng phải diễn ra trên chủ đề chính và như phiên diễn viên Swift thảo luận, Swift đảm bảo điều này bằng cách khai báo các lớp giao diện người dùng thuộc về diễn viên chính.

00:19:57.000 --> 00:20:02.000
Giả sử chúng ta có chế độ xem bộ sưu tập và chúng ta chưa thể sử dụng API nguồn dữ liệu chế độ xem bộ sưu tập.

00:20:02.000 --> 00:20:10.000
Thay vào đó, chúng tôi muốn sử dụng chức năng fetchThumbnails mà chúng tôi vừa viết để lấy hình thu nhỏ từ mạng khi các mục trong chế độ xem bộ sưu tập được hiển thị.

00:20:10.000 --> 00:20:16.000
Tuy nhiên, phương thức đại diện không đồng bộ, vì vậy chúng ta không thể chỉ chờ đợi một cuộc gọi đến một hàm không đồng bộ.

00:20:16.000 --> 00:20:23.000
Chúng ta cần bắt đầu một nhiệm vụ cho điều đó, nhưng nhiệm vụ đó thực sự là một phần mở rộng của công việc mà chúng ta đã bắt đầu để đáp ứng với hành động của đại biểu.

00:20:23.000 --> 00:20:28.000
Chúng tôi muốn nhiệm vụ mới này vẫn chạy trên diễn viên chính với ưu tiên giao diện người dùng.

00:20:28.000 --> 00:20:33.000
Chúng tôi chỉ không muốn giới hạn tuổi thọ của nhiệm vụ với phạm vi của phương pháp đại diện duy nhất này.

00:20:33.000 --> 00:20:38.000
Đối với những tình huống như thế này, Swift cho phép chúng tôi xây dựng một nhiệm vụ phi cấu trúc.

00:20:38.000 --> 00:20:46.000
Hãy di chuyển phần không đồng bộ của mã vào một đóng và chuyển đóng đó để xây dựng một tác vụ không đồng bộ.

00:20:46.000 --> 00:20:48.000
Bây giờ đây là những gì xảy ra trong thời gian chạy.

00:20:48.000 --> 00:20:56.000
Khi chúng tôi đạt đến điểm tạo nhiệm vụ, Swift sẽ lên lịch chạy trên cùng một diễn viên với phạm vi gốc, đây là diễn viên chính trong trường hợp này.

00:20:56.000 --> 00:21:00.000
Trong khi đó, quyền kiểm soát trả lại ngay lập tức cho người gọi.

00:21:00.000 --> 00:21:07.000
Nhiệm vụ hình thu nhỏ sẽ chạy trên luồng chính khi có một lỗ mở để làm như vậy mà không ngay lập tức chặn luồng chính trên phương thức đại diện.

00:21:07.000 --> 00:21:13.000
Xây dựng các nhiệm vụ theo cách này cho chúng ta một điểm giữa mã có cấu trúc và không có cấu trúc.

00:21:13.000 --> 00:21:25.000
Một nhiệm vụ được xây dựng trực tiếp vẫn kế thừa tác nhân, nếu có, của bối cảnh được khởi chạy của nó, và nó cũng kế thừa mức độ ưu tiên và các đặc điểm khác của nhiệm vụ gốc, giống như một nhiệm vụ nhóm hoặc một tác vụ không đồng bộ sẽ làm.

00:21:25.000 --> 00:21:27.000
Tuy nhiên, nhiệm vụ mới không được bao gồm.

00:21:27.000 --> 00:21:31.000
Tuổi thọ của nó không bị ràng buộc bởi phạm vi nơi nó được ra mắt.

00:21:31.000 --> 00:21:34.000
Nguồn gốc thậm chí không cần phải không đồng bộ.

00:21:34.000 --> 00:21:37.000
Chúng ta có thể tạo ra một nhiệm vụ không có phạm vi ở bất cứ đâu.

00:21:37.000 --> 00:21:44.000
Trong giao dịch cho tất cả sự linh hoạt này, chúng ta cũng phải quản lý thủ công những thứ mà đồng thời có cấu trúc sẽ xử lý tự động.

00:21:44.000 --> 00:21:55.000
Việc hủy bỏ và lỗi sẽ không tự động lan truyền và kết quả của nhiệm vụ sẽ không được ngầm chờ đợi trừ khi chúng tôi thực hiện hành động rõ ràng để làm như vậy.

00:21:55.000 --> 00:22:06.000
Vì vậy, chúng tôi đã bắt đầu một nhiệm vụ để tìm nạp hình thu nhỏ khi một mục chế độ xem bộ sưu tập được hiển thị và chúng tôi cũng nên hủy nhiệm vụ đó nếu mục đó được cuộn ra khỏi tầm nhìn trước khi hình thu nhỏ sẵn sàng.

00:22:06.000 --> 00:22:10.000
Vì chúng tôi đang làm việc với một nhiệm vụ không có phạm vi, việc hủy bỏ đó không tự động.

00:22:10.000 --> 00:22:12.000
Hãy thực hiện nó ngay bây giờ.

00:22:12.000 --> 00:22:16.000
Sau khi chúng ta xây dựng nhiệm vụ, hãy lưu lại giá trị mà chúng ta nhận được.

00:22:16.000 --> 00:22:25.000
Chúng ta có thể đặt giá trị này vào một từ điển được khóa bởi chỉ mục hàng khi chúng ta tạo nhiệm vụ để chúng ta có thể sử dụng nó sau này để hủy nhiệm vụ đó.

00:22:25.000 --> 00:22:31.000
Chúng ta cũng nên xóa nó khỏi từ điển sau khi nhiệm vụ kết thúc để chúng ta không cố gắng hủy một nhiệm vụ nếu nó đã hoàn thành.

00:22:31.000 --> 00:22:39.000
Lưu ý ở đây rằng chúng ta có thể truy cập cùng một từ điển bên trong và bên ngoài tác vụ không đồng bộ đó mà không cần trình biên dịch gắn cờ cuộc đua dữ liệu.

00:22:39.000 --> 00:22:46.000
Lớp đại biểu của chúng tôi bị ràng buộc với diễn viên chính và nhiệm vụ mới kế thừa điều đó, vì vậy chúng sẽ không bao giờ chạy song song với nhau.

00:22:46.000 --> 00:22:54.000
Chúng tôi có thể truy cập an toàn các thuộc tính được lưu trữ của các lớp ràng buộc diễn viên chính bên trong nhiệm vụ này mà không phải lo lắng về các cuộc đua dữ liệu.

00:22:54.000 --> 00:23:04.000
Trong khi đó, nếu đại diện của chúng tôi sau đó được thông báo rằng cùng một hàng bảng đã bị xóa khỏi màn hình, thì chúng tôi có thể gọi phương thức hủy trên giá trị để hủy nhiệm vụ.

00:23:04.000 --> 00:23:12.000
Vì vậy, bây giờ chúng tôi đã thấy cách chúng tôi có thể tạo các tác vụ phi cấu trúc chạy độc lập với phạm vi trong khi vẫn kế thừa các đặc điểm từ bối cảnh gốc của nhiệm vụ đó.

00:23:12.000 --> 00:23:17.000
Nhưng đôi khi bạn không muốn kế thừa bất cứ điều gì từ bối cảnh gốc của mình.

00:23:17.000 --> 00:23:22.000
Để linh hoạt tối đa, Swift cung cấp các nhiệm vụ tách biệt.

00:23:22.000 --> 00:23:27.000
Giống như tên cho thấy, các nhiệm vụ tách rời độc lập với bối cảnh của chúng.

00:23:27.000 --> 00:23:28.000
Chúng vẫn là những nhiệm vụ phi cấu trúc.

00:23:28.000 --> 00:23:32.000
Cuộc đời của họ không bị ràng buộc bởi phạm vi nguồn gốc của họ.

00:23:32.000 --> 00:23:36.000
Nhưng các nhiệm vụ tách biệt cũng không chọn bất cứ thứ gì khác từ phạm vi ban đầu của chúng.

00:23:36.000 --> 00:23:43.000
Theo mặc định, chúng không bị ràng buộc trong cùng một diễn viên và không phải chạy ở cùng mức độ ưu tiên như nơi chúng được khởi chạy.

00:23:43.000 --> 00:23:55.000
Các tác vụ tách rời chạy độc lập với các mặc định chung cho những thứ như ưu tiên, nhưng chúng cũng có thể được khởi chạy với các tham số tùy chọn để kiểm soát cách thức và địa điểm tác vụ mới được thực hiện.

00:23:55.000 --> 00:24:04.000
Giả sử rằng sau khi chúng tôi tìm nạp hình thu nhỏ từ máy chủ, chúng tôi muốn ghi chúng vào bộ nhớ cache đĩa cục bộ để chúng tôi không truy cập lại mạng nếu chúng tôi cố gắng tìm nạp chúng sau này.

00:24:04.000 --> 00:24:14.000
Bộ nhớ đệm không cần phải xảy ra trên diễn viên chính và ngay cả khi chúng tôi hủy tìm nạp tất cả các hình thu nhỏ, vẫn hữu ích khi lưu trữ bất kỳ hình thu nhỏ nào mà chúng tôi đã tìm nạp.

00:24:14.000 --> 00:24:17.000
Vì vậy, hãy bắt đầu bộ nhớ đệm bằng cách sử dụng một nhiệm vụ tách rời.

00:24:17.000 --> 00:24:23.000
Khi chúng tôi tách ra một nhiệm vụ, chúng tôi cũng linh hoạt hơn rất nhiều trong việc thiết lập cách thực hiện nhiệm vụ mới đó.

00:24:23.000 --> 00:24:33.000
Bộ nhớ đệm nên xảy ra ở mức ưu tiên thấp hơn mà không can thiệp vào giao diện người dùng chính và chúng tôi có thể chỉ định mức độ ưu tiên nền khi chúng tôi tách nhiệm vụ mới này.

00:24:33.000 --> 00:24:35.000
Hãy lên kế hoạch trước một chút ngay bây giờ.

00:24:35.000 --> 00:24:41.000
Chúng ta nên làm gì trong tương lai nếu chúng ta có nhiều nhiệm vụ nền mà chúng ta muốn thực hiện trên hình thu nhỏ của mình?

00:24:41.000 --> 00:24:48.000
Chúng tôi có thể tách rời nhiều nhiệm vụ nền hơn, nhưng chúng tôi cũng có thể sử dụng tính đồng thời có cấu trúc bên trong nhiệm vụ tách rời của mình.

00:24:48.000 --> 00:24:55.000
Chúng ta có thể kết hợp tất cả các loại nhiệm vụ khác nhau với nhau để khai thác từng thế mạnh của chúng.

00:24:55.000 --> 00:25:05.000
Thay vì tách một nhiệm vụ độc lập cho mọi công việc nền tảng, chúng ta có thể thiết lập một nhóm nhiệm vụ và sinh ra từng công việc nền tảng như một nhiệm vụ con vào nhóm đó.

00:25:05.000 --> 00:25:08.000
Có một số lợi ích của việc làm như vậy.

00:25:08.000 --> 00:25:17.000
Nếu chúng ta cần hủy nhiệm vụ nền trong tương lai, sử dụng nhóm nhiệm vụ có nghĩa là chúng ta có thể hủy tất cả các nhiệm vụ con chỉ bằng cách hủy nhiệm vụ tách biệt cấp cao nhất đó.

00:25:17.000 --> 00:25:23.000
Việc hủy bỏ đó sau đó sẽ tự động lan truyền đến các nhiệm vụ con và chúng tôi không cần phải theo dõi một loạt các tay cầm.

00:25:23.000 --> 00:25:28.000
Hơn nữa, các nhiệm vụ con tự động kế thừa quyền ưu tiên của cha mẹ chúng.

00:25:28.000 --> 00:25:44.000
Để giữ tất cả công việc này trong nền, chúng ta chỉ cần nền tảng cho nhiệm vụ tách rời và điều đó sẽ tự động lan truyền đến tất cả các tác vụ con của nó, vì vậy chúng ta không cần phải lo lắng về việc quên đặt ưu tiên nền chuyển tiếp và vô tình bỏ đói công việc giao diện người dùng.

00:25:44.000 --> 00:25:48.000
Tại thời điểm này, chúng tôi đã thấy tất cả các hình thức nhiệm vụ chính có trong Swift.

00:25:48.000 --> 00:25:59.000
Async-let cho phép một số lượng cố định các tác vụ con được sinh ra dưới dạng các ràng buộc biến đổi, với khả năng tự động quản lý hủy bỏ và truyền lỗi nếu ràng buộc nằm ngoài phạm vi.

00:25:59.000 --> 00:26:07.000
Khi chúng ta cần một số lượng động các nhiệm vụ con vẫn bị giới hạn trong một phạm vi, chúng ta có thể chuyển lên các nhóm nhiệm vụ.

00:26:07.000 --> 00:26:18.000
Nếu chúng ta cần phá vỡ một số công việc không có phạm vi tốt nhưng vẫn liên quan đến nhiệm vụ ban đầu của nó, chúng ta có thể xây dựng các nhiệm vụ phi cấu trúc, nhưng chúng ta cần quản lý chúng theo cách thủ công.

00:26:18.000 --> 00:26:28.000
Và để linh hoạt tối đa, chúng tôi cũng có các nhiệm vụ tách rời, đó là các nhiệm vụ được quản lý thủ công mà không kế thừa bất cứ điều gì từ nguồn gốc của chúng.

00:26:28.000 --> 00:26:33.000
Các nhiệm vụ và tính năng đồng thời có cấu trúc chỉ là một phần của bộ tính năng đồng thời mà Swift hỗ trợ.

00:26:33.000 --> 00:26:37.000
Hãy chắc chắn kiểm tra tất cả các cuộc nói chuyện tuyệt vời khác này để xem nó phù hợp với phần còn lại của ngôn ngữ như thế nào.

00:26:37.000 --> 00:26:46.000
"Gặp gỡ không đồng bộ/chờ đợi trong Swift" cung cấp cho bạn thêm chi tiết về các hàm không đồng bộ, điều này cung cấp cho chúng tôi cơ sở có cấu trúc để viết mã đồng thời.

00:26:46.000 --> 00:26:52.000
Các diễn viên cung cấp cách ly dữ liệu để tạo ra các hệ thống đồng thời an toàn trước các cuộc đua dữ liệu.

00:26:52.000 --> 00:26:57.000
Xem phiên "Bảo vệ trạng thái có thể thay đổi với các diễn viên Swift" để tìm hiểu thêm về cách thực hiện.

00:26:57.000 --> 00:27:07.000
Chúng tôi đã thấy các vòng lặp "for await" trên các nhóm tác vụ và đó chỉ là một ví dụ về AsyncSequence, cung cấp giao diện tiêu chuẩn để làm việc với các luồng dữ liệu không đồng bộ.

00:27:07.000 --> 00:27:13.000
Phiên "Gặp gỡ AsyncSequence" đi sâu hơn vào các API có sẵn để làm việc với các chuỗi.

00:27:13.000 --> 00:27:25.000
Các nhiệm vụ tích hợp với hệ điều hành cốt lõi để đạt được chi phí thấp và khả năng mở rộng cao, và phiên "Swift concurrency: Behind the scenes" cung cấp thêm chi tiết kỹ thuật về cách hoàn thành điều đó.

00:27:25.000 --> 00:27:42.000
Tất cả các tính năng này kết hợp với nhau để giúp việc viết mã đồng thời trong Swift trở nên dễ dàng và an toàn, cho phép bạn viết mã tận dụng tối đa thiết bị của mình trong khi vẫn tập trung vào các phần thú vị của ứng dụng, suy nghĩ ít hơn về cơ chế quản lý các tác vụ đồng thời hoặc lo lắng về các lỗi tiềm ẩn do đa luồng gây

00:27:42.000 --> 00:27:44.000
Cảm ơn bạn đã xem.

00:27:44.000 --> 00:27:46.000
Tôi hy vọng bạn thích phần còn lại của hội nghị.

00:27:46.000 --> 23:59:59.000
[Nhạc lạc quan].

