WEBVTT

00:00:00.000 --> 00:00:05.000
♪ Nhạc bass đang phát ♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:17.000
Sihui Liu: Xin chào. Chào mừng đến với "Phát triển nội dung web nâng cao." Tôi là Sihui, và tôi là một kỹ sư trong nhóm Safari và WebKit.

00:00:17.000 --> 00:00:23.000
Tôi rất vui được chia sẻ với bạn những cập nhật quan trọng mà chúng tôi đã thực hiện trong WebKit và Safari cho các nhà phát triển web trong năm qua.

00:00:23.000 --> 00:00:28.000
Những điều tôi sắp chia sẻ thường được chia thành ba loại.

00:00:28.000 --> 00:00:33.000
Đầu tiên, tôi sẽ hướng dẫn bạn các tính năng và cải tiến mới trong JavaScript.

00:00:33.000 --> 00:00:39.000
Sau đó tôi sẽ cung cấp cho bạn cái nhìn tổng quan về các bản cập nhật trong WebAssembly.

00:00:39.000 --> 00:00:47.000
Và cuối cùng, tôi sẽ giới thiệu cho bạn một số API web mới có thể thêm các khả năng bổ sung vào nội dung web của bạn.

00:00:47.000 --> 00:00:51.000
Có rất nhiều thứ để đề cập, vì vậy hãy bắt đầu với tin tức của chúng tôi bằng JavaScript.

00:00:51.000 --> 00:00:56.000
Mỗi năm, có hàng trăm thay đổi được thực hiện trong công cụ JavaScript của chúng tôi.

00:00:56.000 --> 00:01:02.000
Tôi sẽ đề cập đến một số điều quan trọng nhất mà bạn cần biết nếu bạn làm việc với JavaScript.

00:01:02.000 --> 00:01:25.000
Đó là: cú pháp trường lớp mới, tài liệu tham khảo yếu cho phép quản lý bộ nhớ thông minh hơn, cách sử dụng mới từ khóa await, hỗ trợ cho các mô-đun trong công nhân và giao diện được thêm vào họ API Quốc tế hóa.

00:01:25.000 --> 00:01:31.000
Để đưa bạn vào bức tranh về những tính năng mới này, tôi sẽ sử dụng một chiếc đồng hồ bấm giờ đơn giản làm ví dụ.

00:01:31.000 --> 00:01:34.000
Đồng hồ bấm giờ chỉ có một nút bấm.

00:01:34.000 --> 00:01:36.000
Nhấp vào nó một lần, nó bắt đầu đếm.

00:01:36.000 --> 00:01:40.000
Nhấp vào nó một lần nữa, nó sẽ dừng lại và cung cấp cho bạn thời lượng đã trôi qua.

00:01:40.000 --> 00:01:46.000
Hãy ghi nhớ điều này và chúng tôi sẽ triển khai nó sau trong JavaScript.

00:01:46.000 --> 00:01:49.000
Bây giờ, chúng ta hãy xem cú pháp trường lớp mới.

00:01:49.000 --> 00:01:59.000
Chúng tôi có các trường và phương thức lớp riêng tư mới cho phép bạn xác định các thành viên riêng tư thực sự có quyền truy cập được bảo vệ bởi ngôn ngữ.

00:01:59.000 --> 00:02:02.000
Bạn sẽ thấy lỗi nếu bạn vi phạm các quy tắc truy cập.

00:02:02.000 --> 00:02:12.000
Chúng tôi cũng thêm hỗ trợ cho các trường tĩnh, cho phép bạn khai báo một thành viên lớp có thể được truy cập mà không cần tạo một phiên bản của lớp.

00:02:12.000 --> 00:02:15.000
Bây giờ bạn đã có ý tưởng cơ bản.

00:02:15.000 --> 00:02:19.000
Hãy kiểm tra xem nó có thể được sử dụng như thế nào với ví dụ đồng hồ bấm giờ.

00:02:19.000 --> 00:02:26.000
Nếu bạn được yêu cầu triển khai lớp đồng hồ bấm giờ, việc triển khai của bạn có thể trông như thế này.

00:02:26.000 --> 00:02:30.000
StopwatchWithOneButton chỉ có một phương thức có tên click().

00:02:30.000 --> 00:02:33.000
Nó kiểm tra biến startTime.

00:02:33.000 --> 00:02:39.000
Nếu thời gian bắt đầu không được đặt, nhấp chuột có nghĩa là bắt đầu, vì vậy nó sẽ đặt thời gian bắt đầu.

00:02:39.000 --> 00:02:47.000
Nếu thời gian bắt đầu đã được đặt, nhấp chuột có nghĩa là dừng lại, vì vậy nó sẽ tính toán thời lượng và đặt lại thời gian bắt đầu.

00:02:47.000 --> 00:02:51.000
Bạn có thể thấy startTime đi kèm với một tiền tố gạch dưới.

00:02:51.000 --> 00:02:58.000
Đây là một quy ước đặt tên thường được sử dụng để biểu thị rằng biến chỉ nên được sử dụng bên trong lớp.

00:02:58.000 --> 00:03:03.000
Nhưng điều đó không thực sự ngăn cản thời gian bắt đầu được truy cập công khai.

00:03:03.000 --> 00:03:06.000
Cú pháp riêng tư mới có thể giúp khắc phục điều này.

00:03:06.000 --> 00:03:11.000
Chỉ cần thay thế dấu gạch dưới bằng hàm băm và bạn có thể khai báo một trường phiên bản riêng thực.

00:03:11.000 --> 00:03:15.000
Sự đóng gói được thực thi bởi ngôn ngữ.

00:03:15.000 --> 00:03:18.000
Ngoài ra còn có hỗ trợ cho các phương pháp riêng tư.

00:03:18.000 --> 00:03:30.000
Ví dụ, để làm cho các phương thức click() có cấu trúc hơn, chúng ta có thể tạo hai phương thức riêng tư start() và stop() để thay thế nội dung được đánh dấu, như thế này.

00:03:30.000 --> 00:03:39.000
Bằng cách thêm tiền tố băm vào các phương thức, chúng tôi đảm bảo rằng các hàm thành viên chỉ có thể được truy cập từ bên trong lớp.

00:03:39.000 --> 00:03:45.000
Cú pháp riêng tư mới cũng áp dụng cho các trường tĩnh như startedStopwatchCount.

00:03:45.000 --> 00:03:52.000
Tại đây, startedStopwatchCount chỉ có thể được sửa đổi bởi các đối tượng đồng hồ bấm giờ vào thời điểm bắt đầu hoặc dừng.

00:03:52.000 --> 00:04:02.000
Tất nhiên, nếu bạn muốn startedStopwatchCount được truy cập ở mọi nơi, bạn có thể khai báo nó là trường tĩnh công khai, mà không cần tiền tố băm.

00:04:02.000 --> 00:04:06.000
Trường tĩnh công khai hiện cũng có sẵn trong WebKit.

00:04:06.000 --> 00:04:14.000
Các trường phiên bản riêng tư, các phương thức, các trường tĩnh riêng tư và các trường tĩnh công khai; đó là hỗ trợ trường lớp mới của chúng tôi.

00:04:14.000 --> 00:04:19.000
Và hãy tiếp tục với một tính năng khác, các tài liệu tham khảo yếu.

00:04:19.000 --> 00:04:27.000
Các tham chiếu yếu cho phép bạn giữ tham chiếu đến một đối tượng JavaScript theo cách không ngăn chặn việc thu gom rác.

00:04:27.000 --> 00:04:35.000
Không giống như WeakMap và WeakSet, bạn có thể lấy đối tượng cơ bản mà không cần tham chiếu đến nó.

00:04:35.000 --> 00:04:43.000
Hỗ trợ cũng bao gồm thông báo về việc thu gom rác, vì vậy bạn có thể thực hiện một số nhiệm vụ dọn dẹp nếu cần.

00:04:43.000 --> 00:04:45.000
Và hãy xem nó có thể được sử dụng như thế nào.

00:04:45.000 --> 00:04:48.000
Chúng tôi vừa triển khai lớp đồng hồ bấm giờ.

00:04:48.000 --> 00:04:54.000
Bây giờ hãy tưởng tượng bạn đã tạo ra nhiều đối tượng đồng hồ bấm giờ cho các tác vụ khác nhau.

00:04:54.000 --> 00:04:57.000
Để kiểm tra, bạn cần nhấp vào tất cả chúng cùng một lúc.

00:04:57.000 --> 00:04:59.000
Bạn sẽ làm điều đó như thế nào?

00:04:59.000 --> 00:05:04.000
Một cách trực quan là giữ một tập hợp tất cả các trường hợp đồng hồ bấm giờ.

00:05:04.000 --> 00:05:07.000
Khi đồng hồ bấm giờ được tạo, hãy thêm nó vào bộ.

00:05:07.000 --> 00:05:14.000
Sau đó, trong chức năng clickAllStopwatches, lặp lại bộ và nhấp vào từng đồng hồ bấm giờ.

00:05:14.000 --> 00:05:17.000
Nhưng có một vấn đề với cách tiếp cận này.

00:05:17.000 --> 00:05:28.000
Chúng tôi biết các đối tượng JavaScript giữ tham chiếu mạnh theo mặc định, vì vậy trong trường hợp này, tất cả các đối tượng đồng hồ bấm giờ không thể được thu gom rác vì tập hợp vẫn có tham chiếu đến chúng.

00:05:28.000 --> 00:05:32.000
Tất nhiên, chúng tôi không muốn giữ tất cả các đối tượng đồng hồ bấm giờ xung quanh chỉ để thử nghiệm.

00:05:32.000 --> 00:05:36.000
Điều này không tốt cho việc sử dụng bộ nhớ.

00:05:36.000 --> 00:05:42.000
Bây giờ, bạn có thể đề nghị chỉ thay thế Set bằng WeakSet, nhưng WeakSet không thể lặp lại được.

00:05:42.000 --> 00:05:44.000
Vậy bạn sẽ làm gì?

00:05:44.000 --> 00:05:50.000
Chúng ta có thể giải quyết nó với giao diện mới WeakRef, giao diện này chứa các tham chiếu yếu đến một đối tượng.

00:05:50.000 --> 00:05:56.000
Chúng tôi vẫn có bộ, nhưng lần này chúng tôi thêm WeakRef của các đối tượng đồng hồ bấm giờ vào bộ.

00:05:56.000 --> 00:06:04.000
Trong chức năng clickAllStopwatches, chúng tôi kiểm tra xem đối tượng có còn tồn tại hay không bằng cách hủy tham chiếu nó trước khi nhấp.

00:06:04.000 --> 00:06:17.000
Điều này dường như giải quyết được vấn đề của chúng tôi, nhưng có một vấn đề khác: chúng tôi không loại bỏ đồng hồ bấm giờ thu gom rác khỏi bộ này một cách kịp thời và bộ này có thể phát triển khá lớn trước khi kiểm tra nhấp chuột tiếp theo của chúng tôi.

00:06:17.000 --> 00:06:21.000
Bây giờ chúng ta nên làm gì?

00:06:21.000 --> 00:06:25.000
Một giao diện mới khác - FinalizationRegistry - có thể hữu ích trong trường hợp này.

00:06:25.000 --> 00:06:32.000
Với nó, bạn có thể chỉ định một cuộc gọi lại sẽ được gọi khi một số đối tượng được thu thập rác.

00:06:32.000 --> 00:06:43.000
Ở đây chúng tôi tạo một đối tượng finalizationRegistry với hàm removeStopwatch, vì vậy hàm này được gọi mỗi khi một đối tượng được thu thập.

00:06:43.000 --> 00:06:47.000
Sau đó, chúng tôi đăng ký các đối tượng đồng hồ bấm giờ vào sổ đăng ký.

00:06:47.000 --> 00:06:54.000
Mỗi đồng hồ bấm giờ được liên kết với một mã định danh, vì vậy removeStopwatch biết nên tháo đồng hồ bấm giờ nào.

00:06:54.000 --> 00:07:00.000
Tốt, bây giờ đồng hồ bấm giờ thu gom rác sẽ bị xóa khỏi allStopwatches.

00:07:00.000 --> 00:07:05.000
Việc sử dụng các tài liệu tham khảo yếu nghe có vẻ không khó lắm, phải không?

00:07:05.000 --> 00:07:12.000
Nhưng hãy lưu ý rằng việc thu gom rác trong JavaScript rất phức tạp và có rất nhiều điều không chắc chắn.

00:07:12.000 --> 00:07:26.000
Ví dụ, đối tượng bạn nghĩ nên được thu thập có thể không thực sự được thu thập cho đến một thời gian dài sau đó và bạn có thể không nhận được cuộc gọi lại từ FinalizationRegistry đúng cách vì nó chạy trên vòng lặp sự kiện.

00:07:26.000 --> 00:07:33.000
Do đó, hãy đảm bảo rằng bạn hiểu đầy đủ cú pháp và hành vi mong đợi của nó trước khi sử dụng.

00:07:33.000 --> 00:07:37.000
Hãy chuyển từ các tham chiếu yếu sang tính năng tiếp theo, cấp cao nhất đang chờ đợi.

00:07:37.000 --> 00:07:40.000
Đây là một tính năng mới cho các mô-đun.

00:07:40.000 --> 00:07:46.000
Nó cho phép bạn sử dụng từ khóa await bên ngoài hàm async.

00:07:46.000 --> 00:07:55.000
Trong trường hợp này, bản thân mô-đun giống như một hàm không đồng bộ lớn, vì vậy một mô-đun không đồng bộ có thể chặn việc thực thi mô-đun nhập chúng.

00:07:55.000 --> 00:08:00.000
Hãy để tôi chỉ cho bạn một ví dụ với lớp học đồng hồ bấm giờ của chúng tôi.

00:08:00.000 --> 00:08:03.000
Đây là lớp học mà chúng tôi vừa tạo ra.

00:08:03.000 --> 00:08:09.000
Để minh họa việc sử dụng await cấp cao nhất, hãy biến nó thành một mô-đun và xuất lớp.

00:08:09.000 --> 00:08:13.000
Đây là một tệp HTML chứa một mô-đun nội tuyến.

00:08:13.000 --> 00:08:18.000
Nó nhập mô-đun đồng hồ bấm giờ bằng cách sử dụng nhập động.

00:08:18.000 --> 00:08:27.000
Hàm nhập trả về một lời hứa, vì vậy chúng ta có thể sử dụng các phương thức then hoặc catch để thực hiện các hành động sau khi nhập xong.

00:08:27.000 --> 00:08:34.000
Với await cấp cao nhất, bạn có thể loại bỏ các phương thức xâu chuỗi và viết mã theo cách đồng bộ.

00:08:34.000 --> 00:08:38.000
Điều này có thể làm cho mã của bạn dễ theo dõi hơn.

00:08:38.000 --> 00:08:48.000
Ngoài ra, bởi vì các mô-đun đã nhập được đánh giá tại thời điểm tải, vì vậy một mô-đun không đồng bộ có thể chặn việc thực thi các mô-đun tùy thuộc vào nó.

00:08:48.000 --> 00:08:59.000
Điều đó có nghĩa là nếu mô-đun đồng hồ bấm giờ chạy các hoạt động không đồng bộ và chờ kết quả, biến đồng hồ bấm giờ ở đây sẽ được khởi tạo sau khi mô-đun đồng hồ bấm giờ kết thúc thực thi.

00:08:59.000 --> 00:09:03.000
Chờ đợi cấp cao nhất đã giúp việc quản lý phụ thuộc trở nên dễ dàng hơn.

00:09:03.000 --> 00:09:14.000
Nhưng một lần nữa, tính năng này chỉ có sẵn trong các mô-đun, vì vậy nếu tập lệnh không phải là một mô-đun, như thế này...

00:09:14.000 --> 00:09:17.000
...Bạn sẽ thấy một lỗi cú pháp trong Web Inspector.

00:09:17.000 --> 00:09:22.000
Nói về các mô-đun, có một tính năng liên quan khác: công nhân mô-đun.

00:09:22.000 --> 00:09:25.000
Người lao động có một số lợi ích nổi tiếng.

00:09:25.000 --> 00:09:31.000
Nó có thể chạy các tập lệnh trong một chuỗi nền, vì vậy các tài nguyên có thể được sử dụng hiệu quả hơn.

00:09:31.000 --> 00:09:44.000
Với sự hỗ trợ mới này, người lao động hiện chia sẻ những lợi ích của các mô-đun, bao gồm nhập động, tải và thực hiện được tối ưu hóa và quản lý phụ thuộc.

00:09:44.000 --> 00:09:51.000
Nó có lợi hơn và dễ dàng hơn cho bạn để di chuyển công việc nặng nhọc từ chủ đề chính sang chủ đề nền ngay bây giờ.

00:09:51.000 --> 00:09:58.000
Các mô-đun hiện có sẵn trong các loại công nhân khác nhau, bao gồm nhân viên web, nhân viên dịch vụ và worklet.

00:09:58.000 --> 00:10:07.000
Để tạo một nhân viên mô-đun, đối với nhân viên web và nhân viên dịch vụ, bạn cần chỉ định loại là mô-đun trong các tùy chọn.

00:10:07.000 --> 00:10:12.000
Đối với một worklet như Audio Worklet, bạn có thể sử dụng chức năng addModule.

00:10:12.000 --> 00:10:18.000
Khá dễ dàng để tạo một nhân viên mô-đun giúp tăng tốc ứng dụng của bạn.

00:10:18.000 --> 00:10:23.000
Phần cuối cùng trong JavaScript là các bản cập nhật trên API Quốc tế hóa.

00:10:23.000 --> 00:10:26.000
API này cung cấp định dạng dựa trên ngôn ngữ.

00:10:26.000 --> 00:10:31.000
Sẽ rất hữu ích nếu nội dung web của bạn được xây dựng cho người dùng ở các ngôn ngữ khác nhau.

00:10:31.000 --> 00:10:41.000
Để cho bạn thấy nó có thể được sử dụng như thế nào, tôi đã xây dựng trang hồ bấm giờ này bởi vì, bạn biết đấy, đồng hồ bấm giờ cần phải theo kịp thời gian và các bản phát hành tính năng của chúng tôi.

00:10:41.000 --> 00:10:53.000
Trang này hiển thị cho chúng tôi thông tin chi tiết về việc sử dụng đồng hồ bấm giờ một lần, bao gồm thời lượng, thời gian bắt đầu, sự kiện, người tham gia và các ngôn ngữ có sẵn của trang.

00:10:53.000 --> 00:10:58.000
Bây giờ, chúng ta hãy đi sâu vào từng phần và xem xét kỹ hơn từng giao diện.

00:10:58.000 --> 00:11:00.000
Đầu tiên là NumberFormat.

00:11:00.000 --> 00:11:06.000
NumberFormat cung cấp định dạng số nhạy cảm với ngôn ngữ và nó được sử dụng để định dạng thời lượng.

00:11:06.000 --> 00:11:13.000
Trình tạo của NumberFormat nhận hai tham số tùy chọn: ngôn ngữ và các tùy chọn.

00:11:13.000 --> 00:11:22.000
Ở đây tôi đặt ngôn ngữ thành tiếng Anh và tôi tạo hai đối tượng tùy chọn, chỉ định số chữ số tối thiểu khác nhau.

00:11:22.000 --> 00:11:29.000
Sau khi tạo hai đối tượng NumberFormat với ngôn ngữ và các tùy chọn, chúng ta có thể sử dụng chúng để định dạng các số thời lượng.

00:11:29.000 --> 00:11:39.000
Ở đây, nếu số không phải là mili giây, tôi sử dụng Format1 để giữ hai chữ số; nếu không tôi sử dụng Format2 để giữ ba chữ số.

00:11:39.000 --> 00:11:44.000
Như bạn có thể thấy, phương thức định dạng sẽ tự động thêm các số không đệm cho chúng tôi.

00:11:44.000 --> 00:11:54.000
Có nhiều tùy chọn khác nhau mà bạn có thể sử dụng để tạo các định dạng bạn cần, chẳng hạn như kiểu dáng, nơi bạn có thể chỉ định giá trị là tiền tệ hoặc đơn vị.

00:11:54.000 --> 00:12:01.000
Tiếp theo là DateTimeFormat, cho phép định dạng ngày và giờ nhạy cảm với ngôn ngữ.

00:12:01.000 --> 00:12:03.000
Cách sử dụng tương tự như NumberFormat.

00:12:03.000 --> 00:12:05.000
Đầu tiên, thiết lập ngôn ngữ.

00:12:05.000 --> 00:12:07.000
Sau đó, thiết lập các tùy chọn.

00:12:07.000 --> 00:12:11.000
Trong các tùy chọn, tôi đặt các kiểu khác nhau cho ngày và giờ.

00:12:11.000 --> 00:12:20.000
Đối tượng DateTimeFormat cung cấp một cấu hình chi tiết thậm chí cho phép bạn chỉ định kiểu cho giây hoặc mili giây.

00:12:20.000 --> 00:12:28.000
Sau đó, chúng ta có thể tạo một đối tượng DateTimeFormat với các tham số và sử dụng nó để định dạng thời gian bắt đầu của chúng ta.

00:12:28.000 --> 00:12:31.000
Kết quả được thể hiện bằng tiếng Anh.

00:12:31.000 --> 00:12:37.000
Bạn có thể thấy ngày tháng chi tiết hơn vì nó có phong cách dài.

00:12:37.000 --> 00:12:39.000
Cái tiếp theo là Segmenter.

00:12:39.000 --> 00:12:43.000
Nó cho phép bạn thực hiện tách chuỗi nhạy cảm với ngôn ngữ.

00:12:43.000 --> 00:12:48.000
Tôi đã sử dụng nó để tìm các từ khóa trong câu sự kiện.

00:12:48.000 --> 00:12:52.000
Đây là phiên bản tiếng Trung của trang ghi đồng hồ bấm giờ.

00:12:52.000 --> 00:12:56.000
Đầu tiên, tôi khai báo một danh sách ngắn các từ khóa mà tôi muốn làm nổi bật.

00:12:56.000 --> 00:13:01.000
Chuỗi sự kiện thậm chí còn bao gồm một Unicode cho biểu tượng độ C.

00:13:01.000 --> 00:13:04.000
Ở đây chúng tôi chỉ định tiếng Trung là ngôn ngữ.

00:13:04.000 --> 00:13:08.000
Trong các tùy chọn, độ chi tiết được đặt thành một từ.

00:13:08.000 --> 00:13:12.000
Các giá trị khả thi khác là đồ thị và câu.

00:13:12.000 --> 00:13:18.000
Sau đó, chúng tôi tạo một Segmenter và sử dụng nó để tách chuỗi bằng phương thức phân đoạn.

00:13:18.000 --> 00:13:22.000
Chúng ta có thể lặp lại các đối tượng kết quả để có được tất cả các phân đoạn.

00:13:22.000 --> 00:13:28.000
Kiểm tra xem mỗi phân đoạn có nằm trong danh sách từ khóa để đánh dấu nó không.

00:13:28.000 --> 00:13:38.000
Segmenter khá hữu ích cho việc phiên dịch các ngôn ngữ, như tiếng Trung, nơi ranh giới từ không quá rõ ràng.

00:13:38.000 --> 00:13:43.000
Tiếp theo là ListFormat, cho phép định dạng danh sách nhạy cảm với ngôn ngữ.

00:13:43.000 --> 00:13:47.000
Giống như trước đây, chúng ta có thể chỉ định ngôn ngữ và các tùy chọn.

00:13:47.000 --> 00:13:52.000
ListFormat không có nhiều tùy chọn như các giao diện khác.

00:13:52.000 --> 00:13:56.000
Những cái hữu ích nhất mà tôi tìm thấy là kiểu chữ và kiểu dáng.

00:13:56.000 --> 00:14:03.000
Với ngôn ngữ và các tùy chọn, chúng tôi có thể tạo Định dạng Danh sách và định dạng danh sách người tham gia mà chúng tôi có.

00:14:03.000 --> 00:14:13.000
Như bạn có thể thấy, vì kiểu là liên từ và kiểu dài, phương thức định dạng thêm dấu phẩy và từ "và" trong kết quả.

00:14:13.000 --> 00:14:16.000
Cái cuối cùng là DisplayNames.

00:14:16.000 --> 00:14:21.000
Nó cung cấp bản dịch nhất quán các tên hiển thị cho ngôn ngữ, khu vực và kịch bản.

00:14:21.000 --> 00:14:24.000
Ở đây tôi chỉ định ngôn ngữ là tiếng Nhật.

00:14:24.000 --> 00:14:27.000
DisplayNames có thể lấy mã ngôn ngữ làm đầu vào.

00:14:27.000 --> 00:14:31.000
Trong các tùy chọn, chúng tôi đặt kiểu làm ngôn ngữ.

00:14:31.000 --> 00:14:34.000
Sau đó chúng ta có thể tạo đối tượng DisplayNames.

00:14:34.000 --> 00:14:39.000
Và ở đây, sử dụng phương pháp, chúng ta có thể nhận được kết quả đã dịch.

00:14:39.000 --> 00:14:45.000
Mặc dù trang này được xây dựng bằng tiếng Anh, người dùng Nhật Bản có thể biết những ngôn ngữ nào được hỗ trợ.

00:14:45.000 --> 00:14:52.000
Và đây là cách tôi xây dựng trang hồ bấm giờ với các giao diện quốc tế hóa mới.

00:14:52.000 --> 00:14:58.000
Để làm mới trí nhớ của bạn, đây là danh sách những thứ chúng tôi vừa xem xét trong phần JavaScript.

00:14:58.000 --> 00:15:04.000
Sau đó, điểm dừng tiếp theo của chúng tôi là cập nhật trong WebAssembly.

00:15:04.000 --> 00:15:13.000
Chúng tôi đã vận chuyển công cụ WebAssembly của mình trong một thời gian, nhưng trong trường hợp bạn không quen thuộc với nó, hãy để tôi bắt đầu bằng cách điền vào một số thông tin cơ bản về WebAssembly.

00:15:13.000 --> 00:15:20.000
WebAssembly là một định dạng hướng dẫn nhị phân cho một máy ảo dựa trên ngăn xếp.

00:15:20.000 --> 00:15:26.000
Nó là một loại mã có thể chạy trong các trình duyệt web hiện đại với hiệu suất gần với mã gốc.

00:15:26.000 --> 00:15:42.000
WebAssembly được thiết kế để trở thành mục tiêu biên dịch di động cho các ngôn ngữ lập trình như C, C++ hoặc Rust, vì vậy WebAssembly có thể giúp chúng tôi triển khai các ứng dụng được viết bằng các ngôn ngữ đó trên web.

00:15:42.000 --> 00:15:47.000
Trong hầu hết các trường hợp sử dụng của WebAssembly, nó chạy cùng với JavaScript.

00:15:47.000 --> 00:15:52.000
Họ có thể giao tiếp với nhau thông qua WebAssembly API.

00:15:52.000 --> 00:15:59.000
WebAssembly có thể cung cấp hiệu suất gần như nguyên bản và cung cấp các khuôn khổ mạnh mẽ trên web.

00:15:59.000 --> 00:16:04.000
JavaScript có thể thao tác DOM và cung cấp các API web mạnh mẽ.

00:16:04.000 --> 00:16:09.000
Chúng có thể là những bổ sung tốt cho nhau.

00:16:09.000 --> 00:16:12.000
Một ví dụ điển hình về việc sử dụng WebAssembly là Funky Karts.

00:16:12.000 --> 00:16:17.000
Đây là một trò chơi được chuyển đổi từ C++ sang WebAssembly với Emscripten.

00:16:17.000 --> 00:16:22.000
Như bạn có thể thấy, nó sẽ chạy rất trơn tru trong Safari.

00:16:22.000 --> 00:17:24.000
Năm nay, chúng tôi đã nâng cấp công cụ WebAssembly của mình với các tính năng sau: hướng dẫn bộ nhớ mới cung cấp cho bạn hiệu suất tốt hơn trong các hoạt động bộ nhớ hàng loạt, như sao chép hoặc khởi tạo các khối bộ nhớ; hướng dẫn mới để yêu cầu quy trình người dùng không bị mắc kẹt ngoại lệ, như tràn dương khi chuyển đổi giữa Các đối tượng, chuyển chúng làm đối số và lưu trữ chúng; và cuối cùng, phát trực tuyến tải xuống và biên dịch WebAssembly rút ngắn thời gian thực thi tổng thể.

00:17:24.000 --> 00:17:28.000
Đây là những điểm nổi bật của các tính năng WebAssembly mới của chúng tôi.

00:17:28.000 --> 00:17:31.000
Chúng tôi hy vọng họ sẽ giúp bạn phát triển.

00:17:31.000 --> 00:17:37.000
Bây giờ, hãy chuyển từ mã cấp thấp mạnh mẽ sang một số API cấp cao.

00:17:37.000 --> 00:17:42.000
Trong phần này, chúng ta sẽ khám phá các API web mới.

00:17:42.000 --> 00:17:52.000
Mục tiêu của tôi là không chỉ cho bạn biết về các tính năng mới mà còn khiến bạn cảm thấy sẵn sàng sử dụng chúng, vì vậy bạn sẽ thấy một số ví dụ điển hình.

00:17:52.000 --> 00:17:59.000
Nhưng đây sẽ không phải là một hướng dẫn đầy đủ, vì vậy hãy nhớ kiểm tra tài liệu chính thức trước khi sử dụng.

00:17:59.000 --> 00:18:02.000
Đây là bản xem trước các tính năng mà tôi sẽ nói đến.

00:18:02.000 --> 00:18:12.000
Một số trong số chúng hoàn toàn mới như Nhận dạng giọng nói và một số trong số chúng đã có sẵn, nhưng chúng tôi có một số cập nhật mà chúng tôi muốn chia sẻ, như Truy cập bộ nhớ.

00:18:12.000 --> 00:18:17.000
Bây giờ, hãy tìm hiểu từng người trong số họ.

00:18:17.000 --> 00:18:24.000
Chúng tôi biết để làm cho nội dung web hấp dẫn, điều rất quan trọng là cung cấp trải nghiệm hình ảnh tuyệt vời.

00:18:24.000 --> 00:18:33.000
Với WebGL2 có sẵn trong WebKit và Safari, bạn sẽ dễ dàng tạo nội dung web đẹp, tương tác hơn.

00:18:33.000 --> 00:18:37.000
Đây là một ví dụ điển hình về những gì có thể được thực hiện với WebGL2.

00:18:37.000 --> 00:18:42.000
After the Flood là một bản demo tương tác được phát triển bởi PlayCanvas.

00:18:42.000 --> 00:18:45.000
Bạn có thể thấy gió nhẹ lắc lư cái cây.

00:18:45.000 --> 00:18:48.000
Nó trông sống động trong Safari.

00:18:48.000 --> 00:18:50.000
Vậy WebGL2 là gì?

00:18:50.000 --> 00:18:56.000
WebGL là một API cấp thấp được sử dụng rất rộng rãi để kết xuất đồ họa 2D và 3D.

00:18:56.000 --> 00:19:03.000
WebGL2 là bản nâng cấp của WebGL giúp loại bỏ dự phòng và giới thiệu một số tính năng mới thú vị.

00:19:03.000 --> 00:19:09.000
Nó thêm kết cấu 3D để cho phép hiển thị các hiệu ứng thể tích như đám mây.

00:19:09.000 --> 00:19:16.000
Nó có các đối tượng lấy mẫu giúp bạn linh hoạt hơn về cách sử dụng kết cấu trong đổ bóng.

00:19:16.000 --> 00:19:23.000
Nó cung cấp phản hồi chuyển đổi giúp bạn triển khai các hệ thống hạt hiệu suất trên GPU.

00:19:23.000 --> 00:19:27.000
Có rất nhiều tính năng mới tuyệt vời trong WebGL2.

00:19:27.000 --> 00:19:34.000
Và quan trọng hơn, WebGL2 hiện có sẵn trong Safari trên tất cả các thiết bị Apple.

00:19:34.000 --> 00:19:39.000
Điều đó có nghĩa là bạn có thể xây dựng một trang web đẹp trông tuyệt vời ở mọi nơi.

00:19:39.000 --> 00:19:46.000
Và hãy làm quen hơn với WebGL2 với một ví dụ: tạo một hình vuông màu cam.

00:19:46.000 --> 00:19:50.000
Và đây là mã JavaScript bạn cần viết cho nó.

00:19:50.000 --> 00:19:57.000
Nếu bạn chưa từng sử dụng WebGL trước đây, điều này có thể không dễ dàng như bạn tưởng tượng.

00:19:57.000 --> 00:20:03.000
Như tôi đã đề cập, bởi vì WebGL là một API cấp thấp, nó có thể rất dài dòng.

00:20:03.000 --> 00:20:10.000
Nhưng đừng lo lắng; có rất nhiều thư viện và khuôn khổ tuyệt vời có thể giúp đơn giản hóa sự phát triển của bạn.

00:20:10.000 --> 00:20:17.000
Với họ, không khó để tạo ra một hình vuông đẹp hoặc thứ gì đó phức tạp hơn thế.

00:20:17.000 --> 00:20:23.000
Bây giờ, nếu bạn đã sử dụng WebGL trong nội dung web của mình, cũng có một tin tốt.

00:20:23.000 --> 00:20:29.000
Chúng tôi đã cải thiện hỗ trợ của mình bằng cách di chuyển phụ trợ từ OpenGL sang Metal.

00:20:29.000 --> 00:20:40.000
Điều đó có nghĩa là iOS Simulator hiện có thể sử dụng GPU cho nội dung web, làm cho nó thể hiện chính xác hơn nhiều về những gì người dùng của bạn sẽ thấy.

00:20:40.000 --> 00:20:47.000
Ngoài ra, bạn có thể sử dụng các công cụ Metal, chẳng hạn như Xcode Frame Debugger, để phân tích mã WebGL của bạn ngay bây giờ.

00:20:47.000 --> 00:20:54.000
Bên cạnh việc tạo nội dung với WebGL, một cách phổ biến khác để cung cấp trải nghiệm hình ảnh tuyệt vời là thông qua video.

00:20:54.000 --> 00:21:06.000
Không phải tất cả các trình duyệt đều có cùng loại hỗ trợ cho các định dạng phương tiện, vì vậy đôi khi bạn có thể khó quyết định định dạng nào bạn sẽ sử dụng.

00:21:06.000 --> 00:21:15.000
Để giúp mọi thứ dễ dàng hơn cho bạn, năm nay, chúng tôi đã tăng cường hỗ trợ cho WebM, một định dạng phương tiện phổ biến trên web.

00:21:15.000 --> 00:21:19.000
Để bắt đầu, hỗ trợ chỉ dành cho phát trực tuyến.

00:21:19.000 --> 00:21:28.000
Trong macOS 11.3, chúng tôi đã thêm hỗ trợ phát các tệp WebM có chứa video VP8 hoặc VP9 và âm thanh Vorbis.

00:21:28.000 --> 00:21:34.000
Và trong macOS 12, chúng tôi thêm hỗ trợ cho các tệp có chứa âm thanh Opus.

00:21:34.000 --> 00:21:40.000
Năm ngoái, chúng tôi đã bắt đầu hỗ trợ WebM được phát thông qua Tiện ích mở rộng nguồn phương tiện trên macOS.

00:21:40.000 --> 00:21:44.000
Bây giờ, chúng tôi đang mang sự hỗ trợ đó đến iPadOS 15.

00:21:44.000 --> 00:21:55.000
Để kiểm tra xem WebM có được hỗ trợ trong mã của bạn hay không, bạn có thể sử dụng MediaCapabilities API, cho phép bạn phát hiện cấu hình phương tiện chính xác mà bạn muốn sử dụng.

00:21:55.000 --> 00:22:03.000
Cấu hình trên màn hình được hỗ trợ trong Safari mới nhất và điều đó có nghĩa là VP9 hiện cũng được hỗ trợ.

00:22:03.000 --> 00:22:12.000
Với sự hỗ trợ cho định dạng mã hóa video này, chúng tôi mong đợi nhiều nội dung web hơn sẽ có sẵn trong các ứng dụng Safari và WebKit.

00:22:12.000 --> 00:22:16.000
Bạn có thể sử dụng VP9 trong cả phát trực tuyến và WebRTC.

00:22:16.000 --> 00:22:19.000
Nó hoạt động trên macOS và iPadOS.

00:22:19.000 --> 00:22:26.000
Về hỗ trợ trên các thiết bị khác nhau, nó có sẵn trên tất cả các máy Mac silicon của Apple.

00:22:26.000 --> 00:22:33.000
Đối với những người khác, bạn có thể kiểm tra với MediaCapabilities API, giống như những gì chúng ta vừa thấy cho WebM.

00:22:33.000 --> 00:22:50.000
Bây giờ, nếu trang web của bạn có nội dung WebM hoặc VP9, tôi khuyến khích bạn kiểm tra xem nó hoạt động như thế nào trong Safari và WebKit mới nhất; nhưng nếu bạn vẫn đang quyết định sử dụng định dạng phương tiện nào, chúng tôi khuyên bạn nên sử dụng H.264 hoặc HEVC.

00:22:50.000 --> 00:22:54.000
H.264 đã trưởng thành và được hỗ trợ tốt trên các trình duyệt.

00:22:54.000 --> 00:22:58.000
HEVC có sự hỗ trợ tuyệt vời cho các video chất lượng cao.

00:22:58.000 --> 00:23:06.000
Cả hai đều đi kèm với khả năng tăng tốc phần cứng có thể phát lại mượt mà hơn và thời lượng pin phát lại lâu hơn.

00:23:06.000 --> 00:23:13.000
Nói về việc lưu trữ nội dung video, một trường hợp phổ biến là chúng tôi không sở hữu nội dung; thay vào đó, chúng tôi nhận được nó từ bên thứ ba.

00:23:13.000 --> 00:23:18.000
Ví dụ, tôi thấy video hay này trên video.domain.

00:23:18.000 --> 00:23:29.000
Để làm cho nó xuất hiện trên trang web của tôi, main.domain, tôi có thể tải nguồn video này từ video.domain, hoặc tôi chỉ tạo iframes của video.domain.

00:23:29.000 --> 00:23:36.000
Vì lý do bảo mật, iframe hoặc tài nguyên của bên thứ ba không có quyền truy cập vào bộ nhớ của bên thứ nhất theo mặc định.

00:23:36.000 --> 00:23:46.000
Và điều đó có nghĩa là nếu yêu cầu tài nguyên cho video.domain được khởi tạo từ main.domain, nó sẽ không bao gồm cookie của video.domain.

00:23:46.000 --> 00:23:53.000
Đây có thể là một vấn đề khi các máy chủ web của video.domain chỉ muốn cung cấp nội dung cho những người dùng được xác thực.

00:23:53.000 --> 00:23:57.000
Và không có cookie có nghĩa là không có xác thực.

00:23:57.000 --> 00:24:01.000
API Truy cập Lưu trữ giải quyết vấn đề này.

00:24:01.000 --> 00:24:08.000
Nó cho phép iframe của bên thứ ba yêu cầu quyền truy cập cookie của bên thứ nhất.

00:24:08.000 --> 00:24:17.000
Nếu người dùng cấp quyền, video.domain của bên thứ ba sẽ có thể truy cập cookie của bên thứ nhất.

00:24:17.000 --> 00:24:22.000
API Truy cập Lưu trữ đã có sẵn trong WebKit và Safari trong hơn ba năm.

00:24:22.000 --> 00:24:29.000
Để cải thiện khả năng tương tác, năm nay chúng tôi đã thêm hai tính năng mới.

00:24:29.000 --> 00:24:32.000
Đầu tiên, quyền truy cập được cấp trên phạm vi mỗi trang.

00:24:32.000 --> 00:24:40.000
Nó có nghĩa là một khi sự cho phép được cấp cho bên thứ ba, nó sẽ được mở rộng cho tất cả các tài nguyên con của nó trên cùng một trang.

00:24:40.000 --> 00:24:45.000
Bạn không cần phải đưa ra yêu cầu cho mỗi iframe.

00:24:45.000 --> 00:24:49.000
Thứ hai, chúng tôi cho phép các iframe lồng nhau đưa ra yêu cầu.

00:24:49.000 --> 00:24:58.000
Điều này có nghĩa là iframe bên trong iframe cũng có thể yêu cầu quyền truy cập vào cookie của bên thứ nhất, điều này trước đây không thể thực hiện được.

00:24:58.000 --> 00:25:08.000
Để tìm hiểu thêm về cách sử dụng mới, vui lòng kiểm tra bài đăng trên blog của chúng tôi "Cập nhật API Truy cập Lưu trữ" tại webkit.org.

00:25:08.000 --> 00:25:15.000
Bây giờ chúng tôi đã biết cách tải hoặc nhập nội dung video từ bên thứ ba với sự cho phép của người dùng nếu cần.

00:25:15.000 --> 00:25:18.000
Làm thế nào về việc tự tạo ra thứ gì đó?

00:25:18.000 --> 00:25:23.000
Với Media Recorder API mới, rất dễ dàng để làm điều đó.

00:25:23.000 --> 00:25:34.000
Media Recorder API cho phép bạn thu thập dữ liệu từ các yếu tố phương tiện, bao gồm các yếu tố phương tiện HTML như thẻ video hoặc các đối tượng MediaStream.

00:25:34.000 --> 00:25:39.000
Bạn có thể sử dụng nó để ghi lại từ các thiết bị đầu vào của người dùng.

00:25:39.000 --> 00:25:47.000
Bạn có thể chỉ định các tùy chọn mong muốn, chẳng hạn như loại MIME của vùng chứa hoặc tốc độ bit mong muốn của các bản nhạc.

00:25:47.000 --> 00:25:49.000
API rất đơn giản.

00:25:49.000 --> 00:25:58.000
Nó bao gồm một giao diện chính duy nhất, MediaRecorder, thực hiện tất cả công việc thu thập dữ liệu từ nguồn và cung cấp cho bạn.

00:25:58.000 --> 00:26:02.000
Để tôi chỉ cho bạn một ví dụ.

00:26:02.000 --> 00:26:07.000
Tôi đã sử dụng MediaRecorder API để xây dựng ứng dụng web này có tên là "Voice Memo".

00:26:07.000 --> 00:26:09.000
Đây là bản ghi nhớ giọng nói đầu tiên của tôi.

00:26:09.000 --> 00:26:13.000
Nhấp vào nút, nó bắt đầu ghi âm từ micrô.

00:26:13.000 --> 00:26:16.000
Nhấp một lần nữa, nó dừng ghi âm và cung cấp phát lại.

00:26:16.000 --> 00:26:19.000
Đây là bản ghi nhớ giọng nói đầu tiên của tôi.

00:26:19.000 --> 00:26:21.000
Điều đó thật vui.

00:26:21.000 --> 00:26:25.000
Và bây giờ hãy kiểm tra việc triển khai.

00:26:25.000 --> 00:26:29.000
Chúng tôi có hai chức năng chính: startRecording và stopRecording.

00:26:29.000 --> 00:26:33.000
Trong startRecording, chúng tôi nhận được luồng phương tiện đầu vào cho micrô.

00:26:33.000 --> 00:26:36.000
Sau đó, chúng tôi tạo ra một đối tượng MediaRecorder với điều đó.

00:26:36.000 --> 00:26:40.000
Chúng tôi lắng nghe hai sự kiện của máy ghi âm phương tiện truyền thông.

00:26:40.000 --> 00:26:43.000
Và sau đó chúng ta có thể khởi động máy ghi âm bằng phương pháp bắt đầu.

00:26:43.000 --> 00:26:50.000
Để dừng ghi âm, chúng ta chỉ cần gọi phương thức dừng trên đối tượng mediaRecorder.

00:26:50.000 --> 00:26:52.000
Đây là hai người xử lý sự kiện.

00:26:52.000 --> 00:26:57.000
Khi một số dữ liệu được thu thập có sẵn, chúng tôi lưu trữ nó trong một mảng.

00:26:57.000 --> 00:27:05.000
Khi quá trình ghi bị dừng lại, chúng tôi tạo một đốm màu với dữ liệu được thu thập trong một mảng và gửi nó đến một phần tử âm thanh hiện có để phát lại.

00:27:05.000 --> 00:27:09.000
Cứ như vậy, bạn có thể tạo một máy ghi âm chức năng.

00:27:09.000 --> 00:27:13.000
Sau khi bạn thu thập dữ liệu âm thanh, bạn có thể muốn chỉnh sửa nó.

00:27:13.000 --> 00:27:18.000
Trong trường hợp này, bạn có thể sử dụng tốt Audio Worklet API.

00:27:18.000 --> 00:27:27.000
Giao diện Audio Worklet là một phần của Web Audio API, mà bạn có thể đã quen thuộc nếu bạn đã thực hiện xử lý âm thanh trên web trước đây.

00:27:27.000 --> 00:27:37.000
Nó cho phép chúng tôi chạy các tập lệnh như mã JavaScript hoặc WebAssembly để xử lý âm thanh trên chuỗi kết xuất âm thanh hỗ trợ AudioNodes tùy chỉnh.

00:27:37.000 --> 00:27:49.000
So với ScriptProcessorNode, giải pháp trước đó để chạy tập lệnh tùy chỉnh, nó làm giảm sự nhảy giữa luồng kết xuất và luồng chính và đảm bảo độ trễ thấp.

00:27:49.000 --> 00:27:55.000
Với Audio Worklet, tôi đã thêm một khả năng mới vào Voice Memo của mình.

00:27:55.000 --> 00:27:57.000
Đây là giọng nói méo mó của tôi.

00:27:57.000 --> 00:28:03.000
Nếu hộp Distortion được chọn để ghi âm, một số hiệu ứng biến dạng sẽ được áp dụng cho âm thanh.

00:28:03.000 --> 00:28:12.000
Đây là giọng nói méo mó của tôi Nghe có vẻ tuyệt, và chúng ta hãy xem nó được thực hiện như thế nào.

00:28:12.000 --> 00:28:16.000
Tôi đã sửa đổi chức năng startRecording để thêm xử lý âm thanh.

00:28:16.000 --> 00:28:20.000
Chúng ta vẫn cần lấy MediaStream để nhập âm thanh trước.

00:28:20.000 --> 00:28:23.000
Để sử dụng Audio Worklet API, có bốn bước cơ bản.

00:28:23.000 --> 00:28:26.000
Bước một: tạo một nguồn.

00:28:26.000 --> 00:28:34.000
Bước hai: tạo một AudioWorkletNode và liên kết nó với một bộ xử lý Audio Worklet thực hiện xử lý âm thanh.

00:28:34.000 --> 00:28:39.000
Bộ xử lý được triển khai trong một mô-đun, và chúng ta sẽ xem xét nó sau.

00:28:39.000 --> 00:28:41.000
Bước ba: tạo một điểm đến.

00:28:41.000 --> 00:28:46.000
Bước bốn: kết nối đường dẫn từ nguồn đến đích.

00:28:46.000 --> 00:28:55.000
Lần này, MediaRecorder lấy đầu ra từ AudioWorklet làm nguồn và nó ghi lại âm thanh bị biến dạng.

00:28:55.000 --> 00:28:58.000
Đây là mô-đun xử lý âm thanh.

00:28:58.000 --> 00:29:01.000
Chúng tôi triển khai lớp DistortionProcessor ở đây.

00:29:01.000 --> 00:29:09.000
Nó phải mở rộng lớp AudioWorkletProcessor và phải cung cấp việc triển khai cho chức năng quy trình.

00:29:09.000 --> 00:29:17.000
Các đầu vào là các mẫu âm thanh đi vào Audio Worklet và đầu ra là các mẫu kết quả sau khi xử lý.

00:29:17.000 --> 00:29:21.000
Bạn có thể sử dụng các thuật toán khác nhau để tạo ra đầu ra.

00:29:21.000 --> 00:29:26.000
Ở đây, tôi sử dụng một hàm tùy chỉnh được gọi là distort() để tính toán một giá trị dựa trên đầu vào.

00:29:26.000 --> 00:29:32.000
Hàm xử lý trả về true, có nghĩa là nút xử lý đang hoạt động.

00:29:32.000 --> 00:29:35.000
Đó là cấu trúc cơ bản của chức năng quy trình.

00:29:35.000 --> 00:29:45.000
Sau khi tạo lớp bộ xử lý, chúng ta cần đăng ký nó trên toàn cầu dưới một tên được chỉ định, vì vậy nó có thể được sử dụng để xây dựng AudioWorkletNode.

00:29:45.000 --> 00:29:50.000
Cứ như vậy, bạn có thể áp dụng hiệu ứng âm thanh cho dữ liệu âm thanh của mình.

00:29:50.000 --> 00:29:54.000
Cho đến nay chúng tôi đã thảo luận về việc sản xuất và xử lý dữ liệu âm thanh.

00:29:54.000 --> 00:29:59.000
Làm thế nào về việc lưu trữ nó hoặc chia sẻ nó đến một nơi khác để bạn ghi lại?

00:29:59.000 --> 00:30:04.000
Tôi đoán bạn không muốn mất bản ghi âm sau khi bạn thoát khỏi trình duyệt.

00:30:04.000 --> 00:30:10.000
Với các bản cập nhật cho Web Share API trong năm nay, thật dễ dàng để làm điều đó.

00:30:10.000 --> 00:30:13.000
Web Share không phải là mới trong WebKit và Safari.

00:30:13.000 --> 00:30:24.000
Nếu bạn chọn chia sẻ liên kết trên trang web trong Safari, một bảng chia sẻ sẽ hiển thị với các mục tiêu chia sẻ như Tin nhắn, Thư hoặc AirDrop.

00:30:24.000 --> 00:30:32.000
Bảng chia sẻ phù hợp với phong cách hệ thống được tạo bằng Web Share API.

00:30:32.000 --> 00:30:36.000
Năm nay, chúng tôi đã thêm hỗ trợ cho việc chia sẻ tệp.

00:30:36.000 --> 00:30:43.000
Điều đó có nghĩa là bạn có thể chia sẻ hình ảnh, video, âm thanh hoặc các loại tệp khác với API này ngay bây giờ.

00:30:43.000 --> 00:30:47.000
Hãy thêm khả năng chia sẻ vào Voice Memo.

00:30:47.000 --> 00:30:57.000
Nếu hộp Lưu được chọn, Voice Memo sẽ tạo một tệp âm thanh với dữ liệu đã thu được và hiển thị nút Chia sẻ để cho phép chúng tôi chia sẻ tệp.

00:30:57.000 --> 00:31:00.000
Ở đây, tôi muốn chia sẻ tệp ghi nhớ qua email.

00:31:00.000 --> 00:31:06.000
Chỉ với một cú nhấp chuột, một bản nháp đẹp được tạo ra với tệp ghi nhớ được đính kèm.

00:31:06.000 --> 00:31:09.000
Và hãy kiểm tra mã.

00:31:09.000 --> 00:31:14.000
Đây là trình xử lý sự kiện dừng mà chúng tôi đã thấy trong ví dụ MediaRecorder.

00:31:14.000 --> 00:31:21.000
Đầu tiên, hãy tạo biến blob trong trình xử lý sự kiện dừng toàn cầu, để nó có thể được sử dụng bởi hàm chia sẻ.

00:31:21.000 --> 00:31:25.000
Chức năng chia sẻ là trình xử lý sự kiện nhấp chuột của nút chia sẻ.

00:31:25.000 --> 00:31:29.000
Nó chuyển đổi một đốm màu thành một tệp và đặt cho nó một tên tệp.

00:31:29.000 --> 00:31:34.000
Tệp được đặt trong một mảng vì đó là loại đầu vào dự kiến.

00:31:34.000 --> 00:31:40.000
Sau đó, chúng tôi kiểm tra xem API có khả dụng hay không và liệu tệp có thể được chia sẻ với phương thức canShare hay không.

00:31:40.000 --> 00:31:46.000
Nếu kiểm tra được thông qua, chúng tôi gọi navigator.share với mảng tệp.

00:31:46.000 --> 00:31:51.000
Có những tùy chọn bạn có thể chỉ định, như tiêu đề và văn bản mô tả.

00:31:51.000 --> 00:31:57.000
Thật dễ dàng để làm cho ứng dụng web của bạn chia sẻ tệp giống như một ứng dụng gốc.

00:31:57.000 --> 00:32:08.000
Chà, nếu bạn không thực sự muốn tương tác với dữ liệu âm thanh, nhưng chỉ muốn văn bản của nó chẳng hạn, trong trường hợp lệnh thoại cũng có một API mới cho bạn.

00:32:08.000 --> 00:32:11.000
Đó Là Nhận Dạng Giọng Nói.

00:32:11.000 --> 00:32:18.000
Giống như tên gọi của nó được đề xuất, Speech Recognition API ghi lại âm thanh trực tiếp và phiên âm nó thành văn bản.

00:32:18.000 --> 00:32:23.000
Nó cũng cung cấp cho bạn xác suất và lựa chọn thay thế bảng điểm.

00:32:23.000 --> 00:32:32.000
Nó sử dụng cùng một công cụ giọng nói như Siri, và nó nhận được tất cả các lợi ích: hỗ trợ nhiều ngôn ngữ và độ chính xác cao.

00:32:32.000 --> 00:32:41.000
Điều đó cũng có nghĩa là người dùng của bạn sẽ cần bật Siri hoặc Đọc chính tả trong Tùy chọn hoặc Cài đặt Hệ thống để cung cấp API.

00:32:41.000 --> 00:32:49.000
Nhận dạng có thể dựa trên máy chủ, vì vậy chúng tôi đưa ra lời nhắc về quyền riêng tư khi dịch vụ nhận dạng được sử dụng lần đầu tiên trong ứng dụng.

00:32:49.000 --> 00:32:55.000
Người dùng có thể thay đổi quyền trong Tùy chọn hoặc Cài đặt Hệ thống.

00:32:55.000 --> 00:32:59.000
Bây giờ, hãy cập nhật Voice Memo với khả năng mới này.

00:32:59.000 --> 00:33:04.000
Nếu hộp Nhận dạng được chọn, điều đó có nghĩa là tạo bảng điểm cho bản ghi âm.

00:33:04.000 --> 00:33:07.000
Đây là bản ghi nhớ giọng nói của tôi.

00:33:07.000 --> 00:33:10.000
Giai đoạn.

00:33:10.000 --> 00:33:13.000
Và hãy kiểm tra mã.

00:33:13.000 --> 00:33:16.000
Cách sử dụng hơi giống với máy ghi phương tiện.

00:33:16.000 --> 00:33:21.000
Ở đây chúng ta có hai chức năng chính: startRecognition và stopRecognition.

00:33:21.000 --> 00:33:25.000
Trước tiên bạn cần tạo một đối tượng webkitSpeechRecognition.

00:33:25.000 --> 00:33:32.000
Vâng, chúng tôi vẫn giữ tiền tố WebKit ngay bây giờ để tương thích, vì vậy đừng quên thêm nó.

00:33:32.000 --> 00:33:42.000
Sau đó, bạn có thể đặt một số thuộc tính của nhận dạng, như liên tục, yêu cầu nhận dạng tiếp tục cho đến khi nó dừng lại.

00:33:42.000 --> 00:33:45.000
Chúng tôi lắng nghe kết quả và kết thúc các sự kiện.

00:33:45.000 --> 00:33:55.000
Với đối tượng nhận dạng, chúng ta có thể gọi phương thức bắt đầu để bắt đầu và gọi phương thức dừng để dừng.

00:33:55.000 --> 00:33:59.000
Trong sự kiện kết quả, chúng tôi thu thập finalTranscript vào một chuỗi.

00:33:59.000 --> 00:34:07.000
Ở đây, tôi chỉ chọn mục đầu tiên của kết quả vì các lựa chọn thay thế phiên âm được sắp xếp dựa trên xác suất.

00:34:07.000 --> 00:34:13.000
Khi nhận dạng dừng lại, tôi sử dụng chức năng nhật ký tùy chỉnh để in bảng điểm lên màn hình.

00:34:13.000 --> 00:34:20.000
Như vậy, bạn có thể thêm khả năng nhận dạng vào nội dung web của mình chỉ trong vài dòng.

00:34:20.000 --> 00:34:26.000
Đó là một hành trình dài, và có một API web cuối cùng mà tôi nghĩ đáng được nhắc đến.

00:34:26.000 --> 00:34:33.000
Bạn có thể nhận thấy rằng trên macOS và iOS, tiện ích Đang phát có thể hiển thị cho bạn trạng thái phương tiện trong Safari.

00:34:33.000 --> 00:34:39.000
Nó tiện lợi, nhưng nó thường không chứa nhiều thông tin.

00:34:39.000 --> 00:34:46.000
Ví dụ, điều này chỉ hiển thị tiêu đề của trang web; không có thông tin về âm thanh đang được phát.

00:34:46.000 --> 00:34:55.000
Có một API web mới có thể giúp bạn cải thiện tình huống này: Media Session API.

00:34:55.000 --> 00:35:02.000
Media Session API cho phép bạn truyền đạt trạng thái phương tiện giữa trang web và các thành phần nền tảng khác.

00:35:02.000 --> 00:35:12.000
Nếu bạn muốn người dùng của mình xem hoặc kiểm soát trạng thái phương tiện bên ngoài trang web, như trong tiện ích Đang phát, đây là API bạn cần biết.

00:35:12.000 --> 00:35:24.000
Để biết thêm chi tiết về Media Session API, vui lòng kiểm tra phiên WWDC của chúng tôi "Phối hợp phát lại phương tiện trên web với GroupActivities."

00:35:24.000 --> 00:35:27.000
Và đây là những tính năng mới mà chúng tôi vừa khám phá.

00:35:27.000 --> 00:35:30.000
Tôi hy vọng bạn cảm thấy bạn đã học được điều gì đó về nó.

00:35:30.000 --> 00:35:36.000
Và bài tập về nhà của bạn hôm nay là triển khai Voice Memo của riêng bạn với các API mới này.

00:35:36.000 --> 00:35:45.000
Tôi chỉ đùa thôi, nhưng chúng tôi có một vài điều chúng tôi hy vọng bạn có thể làm để giúp chúng tôi mang đến cho bạn trải nghiệm phát triển tốt nhất trong WebKit và Safari.

00:35:45.000 --> 00:35:53.000
Vui lòng thử các tính năng mới trong WebKit và Safari mới nhất và gửi báo cáo lỗi tại bugs.webkit.org.

00:35:53.000 --> 00:36:01.000
Bạn có thể xem qua các tính năng hoặc tính năng mới đang được phát triển tích cực với Safari Technology Preview.

00:36:01.000 --> 00:36:11.000
Nếu bạn quan tâm đến các công nghệ web được sử dụng trong WebKit hoặc Safari, hoặc quan tâm đến việc tham gia cộng đồng WebKit, webkit.org là một nguồn tốt.

00:36:11.000 --> 00:36:20.000
Nếu bạn muốn nhận thông tin cập nhật mới về WebKit hoặc nếu bạn có bất kỳ câu hỏi nào cho chúng tôi, đừng quên theo dõi chúng tôi hoặc gắn thẻ chúng tôi trên Twitter.

00:36:20.000 --> 00:36:25.000
Cảm ơn vì đã xem phiên này, và tôi hy vọng bạn có một khoảng thời gian tuyệt vời tại WWDC!

00:36:25.000 --> 23:59:59.000
♪

