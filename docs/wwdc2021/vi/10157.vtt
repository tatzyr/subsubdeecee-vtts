WEBVTT

00:00:02.000 --> 00:00:15.000
Xin chào! Tên tôi là Egor, và hôm nay, tôi muốn nói với bạn về tất cả những cải tiến và tính năng mới trong Metal Debugger.

00:00:15.000 --> 00:00:23.000
Năm nay, chúng tôi sẽ hỗ trợ nhiều tính năng Kim loại hơn, chẳng hạn như dò tia và con trỏ chức năng.

00:00:23.000 --> 00:00:35.000
Chúng tôi đã thêm quy trình làm việc lập hồ sơ hoàn toàn mới, như dòng thời gian GPU và trạng thái hiệu suất GPU nhất quán, để giúp bạn tận dụng tối đa GPU trên các nền tảng của Apple.

00:00:35.000 --> 00:00:45.000
Chúng tôi đã thực hiện các cải tiến đối với quy trình gỡ lỗi khác mà bạn biết và yêu thích, bao gồm hỗ trợ rộng hơn để xác thực đổ bóng và điều khiển chụp chính xác.

00:00:45.000 --> 00:00:53.000
Chúng tôi cũng đang giới thiệu những tiến bộ trong nén kết cấu, mà đồng nghiệp Amanda của tôi sẽ nói về sau.

00:00:53.000 --> 00:00:56.000
Đầu tiên, hãy nói về dò tia.

00:00:56.000 --> 00:01:11.000
Năm ngoái, chúng tôi đã giới thiệu một API theo dõi tia kim loại mới và bây giờ, trong Xcode 13, chúng tôi hỗ trợ nó trong Trình gỡ lỗi kim loại, cùng với các con trỏ chức năng và bảng chức năng, mang lại sự linh hoạt cho bộ đổ bóng của bạn.

00:01:11.000 --> 00:01:18.000
Và các thư viện động, cung cấp cho bạn một cách để xây dựng mã thư viện đổ bóng được rút ra và có thể tái sử dụng tốt.

00:01:18.000 --> 00:01:25.000
Ngoài ra, để dò tia, chúng tôi đang giới thiệu một công cụ hoàn toàn mới, Trình xem cấu trúc gia tốc.

00:01:25.000 --> 00:01:28.000
Hãy xem dấu vết tia trong Trình gỡ lỗi kim loại.

00:01:28.000 --> 00:01:33.000
Tôi đã mở một dấu vết GPU của ứng dụng mẫu ModernRenderer.

00:01:33.000 --> 00:01:41.000
Nó đã được sửa đổi để sử dụng dấu vết tia kim loại để đạt được các hiệu ứng như bóng tối và tắc nghẽn môi trường xung quanh.

00:01:41.000 --> 00:01:45.000
Bộ mã hóa này tạo ra một bản đồ bóng theo dấu vết tia tuyệt đẹp.

00:01:45.000 --> 00:01:51.000
Tôi đã chọn một cuộc gọi điều phối để bạn có thể thấy cấu trúc tăng tốc trong các tài nguyên bị ràng buộc.

00:01:51.000 --> 00:01:58.000
Từ đây, tôi sẽ mở cấu trúc gia tốc để đi đến trình xem cấu trúc gia tốc mới của chúng tôi.

00:01:58.000 --> 00:02:07.000
Tại đây, bạn có thể thấy hình học của cảnh quán rượu quen thuộc ở bên phải và đường viền của nó ở bên trái.

00:02:07.000 --> 00:02:14.000
Nhấp vào một ví dụ trong cảnh sẽ chọn nó trong trình xem và cả trong phác thảo cảnh.

00:02:14.000 --> 00:02:20.000
Bạn có thể xem ma trận biến đổi và các thuộc tính phiên bản khác bằng cách mở rộng nó.

00:02:20.000 --> 00:02:26.000
Bạn cũng có thể chọn một hình học riêng lẻ bằng cách giữ phím Tùy chọn trong khi nhấp vào trình xem cảnh.

00:02:26.000 --> 00:02:32.000
Điều này cũng sẽ chọn nó trong phác thảo cảnh và ngược lại.

00:02:32.000 --> 00:02:40.000
Bạn cũng có thể thấy các chức năng giao nhau có liên quan được sử dụng với cấu trúc gia tốc ngay tại đây trong trình xem.

00:02:40.000 --> 00:02:46.000
Nhưng Trình xem Cấu trúc Gia tốc có thể làm nhiều hơn là chỉ đơn giản là hiển thị hình học.

00:02:46.000 --> 00:02:54.000
Ở dưới cùng bên phải, bạn cũng sẽ tìm thấy một số chế độ tô sáng sẽ giúp bạn hình dung một số thuộc tính của cảnh của mình.

00:02:54.000 --> 00:03:01.000
Ví dụ, chế độ di chuyển âm lượng giới hạn có thể giúp bạn hình dung sự phức tạp của hình học.

00:03:01.000 --> 00:03:11.000
Màu xanh lam đậm hơn cho thấy các khu vực mà hệ thống phân cấp khối lượng giới hạn đắt hơn về mặt tính toán để đi qua so với các phần khác của nó.

00:03:11.000 --> 00:03:18.000
Đối với tất cả các chế độ, chúng tôi có chế độ xem nhỏ này hiển thị thông tin liên quan khi bạn di chuột qua các phần khác nhau trong cảnh của mình.

00:03:18.000 --> 00:03:25.000
Ở đây, nó hiển thị số lần đi qua hộp giới hạn và giao lộ nguyên thủy.

00:03:25.000 --> 00:03:30.000
Để cung cấp cho bạn sự linh hoạt hơn, chúng tôi cũng bao gồm các cài đặt duyệt.

00:03:30.000 --> 00:03:40.000
Với chúng, bạn có thể định cấu hình trình xem cấu trúc gia tốc, sử dụng các thuộc tính tương tự mà bạn có thể tìm thấy trên một đối tượng liên ngành bên trong bộ đổ bóng của mình.

00:03:40.000 --> 00:03:43.000
Có rất nhiều điều để nói khi nói đến dò tia.

00:03:43.000 --> 00:04:01.000
Nếu bạn muốn tìm hiểu thêm, hãy xem phiên năm nay "Khám phá kết xuất lai với truy tìm tia kim loại." Và nếu bạn muốn biết thêm về API nói chung, hãy xem bài nói chuyện năm ngoái, "Khám phá dò dò tia bằng Kim loại." Tiếp theo, hãy nói về hồ sơ.

00:04:01.000 --> 00:04:07.000
Lập hồ sơ ứng dụng của bạn là một bước quan trọng và chúng tôi đã có rất nhiều công cụ tuyệt vời theo ý của bạn.

00:04:07.000 --> 00:04:20.000
Ví dụ: sử dụng dấu vết hệ thống Metal trong các công cụ, bạn có thể khám phá chế độ xem dòng thời gian hiển thị thời lượng CPU và GPU cho các giai đoạn kết xuất, bộ đếm GPU và dòng thời gian đổ bóng khác nhau.

00:04:20.000 --> 00:04:31.000
Và trong Trình gỡ lỗi kim loại, bộ đếm GPU hiển thị một bộ đo phong phú trực tiếp từ GPU, cho mỗi bộ mã hóa hoặc mỗi lần vẽ.

00:04:31.000 --> 00:04:36.000
Cả hai đều là những công cụ tuyệt vời, cung cấp các chế độ xem bổ sung về hiệu suất ứng dụng của bạn.

00:04:36.000 --> 00:04:40.000
Nhưng việc sắp xếp những quan điểm đó có thể cần thêm nỗ lực.

00:04:40.000 --> 00:04:50.000
Vì vậy, đó là lý do tại sao tôi rất vui được giới thiệu cho bạn một công cụ lập hồ sơ GPU mới kết hợp dấu vết hệ thống Kim loại và bộ đếm GPU trong một trải nghiệm thống nhất.

00:04:50.000 --> 00:04:57.000
Giới thiệu Dòng thời gian GPU trong Trình gỡ lỗi kim loại, một công cụ mới được thiết kế đặc biệt cho GPU của Apple.

00:04:57.000 --> 00:05:06.000
Nó cung cấp cho bạn một góc nhìn khác về dữ liệu hiệu suất và nó có thể giúp bạn tìm ra các điểm tối ưu hóa tiềm năng trong ứng dụng của mình.

00:05:06.000 --> 00:05:12.000
Hãy cùng xem qua phần bổ sung mới nhất này cho bộ công cụ lập hồ sơ của chúng tôi.

00:05:12.000 --> 00:05:16.000
Dòng thời gian GPU có sẵn dưới bảng Hiệu suất.

00:05:16.000 --> 00:05:21.000
Bạn có thể tìm thấy nó trong trình duyệt gỡ lỗi sau khi bạn đã chụp một khung hình từ ứng dụng của mình.

00:05:21.000 --> 00:05:28.000
Khi bạn mở bảng Hiệu suất, bạn sẽ được chào đón bởi một tập hợp các bản nhạc khác nhau được bố trí song song.

00:05:28.000 --> 00:05:33.000
Trước khi chúng ta tiếp tục, tôi muốn giải thích tại sao các bản nhạc bộ mã hóa lại song song.

00:05:33.000 --> 00:05:42.000
Trên GPU của Apple, các giai đoạn đỉnh và phân đoạn của các đường kết xuất khác nhau, và cả các công văn tính toán, có thể chạy đồng thời.

00:05:42.000 --> 00:05:57.000
Điều này được kích hoạt bởi kiến trúc GPU của Apple và sử dụng kỹ thuật kết xuất được gọi là "kết xuất hoãn dựa trên gạch". Chúng tôi nghĩ rằng điều quan trọng là bạn có thể thấy bản chất song song này của GPU Apple trong ngữ cảnh ứng dụng của bạn.

00:05:57.000 --> 00:06:00.000
Và đó là nơi Dòng thời gian GPU có ích.

00:06:00.000 --> 00:06:10.000
Ở trên cùng, bạn có thể thấy các mốc thời gian của bộ mã hóa Vertex, Fragment và Compute, với mỗi bộ mã hóa hiển thị các tài nguyên mà nó sử dụng trong nháy mắt.

00:06:10.000 --> 00:06:17.000
Bên dưới các bộ mã hóa, bạn sẽ tìm thấy các bộ đếm Công suất, Băng thông và bộ giới hạn.

00:06:17.000 --> 00:06:21.000
Chúng ta hãy xem xét kỹ hơn dòng thời gian của bộ mã hóa.

00:06:21.000 --> 00:06:27.000
Bạn có thể mở rộng từng bản nhạc bộ mã hóa để xem dòng thời gian đổ bóng tổng hợp.

00:06:27.000 --> 00:06:35.000
Mở rộng dòng thời gian hơn nữa sẽ hiển thị cho bạn từng bộ đổ bóng riêng lẻ theo kiểu giống như thác nước.

00:06:35.000 --> 00:06:38.000
Thật dễ dàng để điều hướng các bộ mã hóa.

00:06:38.000 --> 00:06:43.000
Chọn một bản nhạc bộ mã hóa để xem danh sách tất cả các bộ mã hóa ở bên phải.

00:06:43.000 --> 00:06:48.000
Ở đó, bạn có thể sắp xếp chúng theo thời lượng trung bình của chúng.

00:06:48.000 --> 00:06:54.000
Nhấp vào một bộ mã hóa riêng lẻ trong dòng thời gian sẽ hiển thị cho bạn thêm thông tin về nó trong thanh bên.

00:06:54.000 --> 00:07:01.000
Ví dụ, ở đây bạn có thể thấy các tệp đính kèm cho bộ mã hóa lệnh kết xuất này.

00:07:01.000 --> 00:07:09.000
Bạn có thể nhận thấy rằng khi bạn chọn một bộ mã hóa, phạm vi thời gian nơi nó hoạt động sẽ được tô sáng trên tất cả các bản nhạc.

00:07:09.000 --> 00:07:18.000
Với điều này, bạn có thể dễ dàng kiểm tra xem các giai đoạn khác nhau chồng chéo như thế nào và cũng tương quan các giá trị truy cập cho bộ mã hóa.

00:07:18.000 --> 00:07:31.000
Tránh xa chế độ xem dòng thời gian, bạn có thể truy cập bộ đếm GPU bằng cách chuyển sang tab Bộ đếm hoặc bạn chỉ cần mở menu ngữ cảnh của bộ mã hóa và hiển thị nó trong Bộ đếm từ đó.

00:07:31.000 --> 00:07:36.000
Và đây chỉ là một cái nhìn sơ lược về Dòng thời gian GPU.

00:07:36.000 --> 00:07:56.000
Để tìm hiểu thêm về cách sử dụng Trình gỡ lỗi kim loại để hiểu hiệu suất ứng dụng của bạn, hãy xem phiên năm nay "Tối ưu hóa các trò chơi cao cấp cho GPU của Apple". Bây giờ tôi đã chỉ cho bạn một cách mới để lập hồ sơ ứng dụng của bạn, điều quan trọng là phải hiểu rằng hiệu suất của nó phụ thuộc vào một số yếu tố.

00:07:56.000 --> 00:08:02.000
Khi chúng ta đang nói về Metal, trạng thái hiệu suất GPU là một yếu tố rất quan trọng.

00:08:02.000 --> 00:08:14.000
Nó được quản lý bởi hệ điều hành, điều này sẽ làm giảm hoặc tăng trạng thái tùy thuộc vào nhiệt độ thiết bị, cài đặt hệ thống, sử dụng GPU và các thông số khác.

00:08:14.000 --> 00:08:20.000
Những thay đổi trạng thái này có thể ảnh hưởng đến kết quả hồ sơ mà bạn đang thấy.

00:08:20.000 --> 00:08:26.000
Năm nay, chúng tôi đang giới thiệu những cách mới để bạn lập hồ sơ ứng dụng của mình với kết quả nhất quán hơn.

00:08:26.000 --> 00:08:49.000
Chúng tôi đã thêm các cách để bạn xem và thay đổi trạng thái hiệu suất GPU trên toàn bộ bộ công cụ Metal của chúng tôi, bắt đầu với nhạc cụ và dấu vết hệ thống Metal để ghi lại hiệu suất trực tiếp, tiếp tục với Trình gỡ lỗi kim loại, để lập hồ sơ dấu vết GPU và cuối cùng là các điều kiện thiết bị trong Xcode, cho các trường hợp

00:08:49.000 --> 00:08:53.000
Đầu tiên, hãy nói về Nhạc cụ.

00:08:53.000 --> 00:08:59.000
Năm nay, chúng tôi đã thêm một bản nhạc cho trạng thái hiệu suất GPU vào dấu vết hệ thống Metal.

00:08:59.000 --> 00:09:06.000
Sử dụng nó kết hợp với các bản nhạc khác để tương quan hiệu suất ứng dụng của bạn với trạng thái hiệu suất của thiết bị.

00:09:06.000 --> 00:09:12.000
Tuy nhiên, hãy nhớ rằng việc có thể nhìn thấy trạng thái hiệu suất chỉ là một phần của phương trình.

00:09:12.000 --> 00:09:21.000
Để có được kết quả hồ sơ nhất quán và có thể tái tạo, bạn cũng cần một cách để đặt trạng thái hiệu suất GPU trên thiết bị.

00:09:21.000 --> 00:09:29.000
Điểm mới trong năm nay là khả năng tạo ra trạng thái hiệu suất GPU cụ thể khi bạn đang ghi lại một dấu vết trong Instruments.

00:09:29.000 --> 00:09:35.000
Chỉ cần vào Tùy chọn ghi âm và chọn trạng thái biểu diễn trước khi bắt đầu ghi âm.

00:09:35.000 --> 00:09:40.000
Sau đó, bạn có thể ghi lại dấu vết hiệu suất như bình thường.

00:09:40.000 --> 00:09:45.000
Các nhạc cụ sẽ tạo ra trạng thái bạn đã chọn trong suốt thời gian theo dõi, nếu thiết bị có thể duy trì nó.

00:09:45.000 --> 00:09:54.000
Đôi khi, bạn có thể cần kiểm tra xem bản nhạc Instruments hiện có có trạng thái hiệu suất GPU gây ra trong quá trình ghi hay không.

00:09:54.000 --> 00:10:01.000
Bạn có thể tìm thấy thông tin này trong phần "Cài đặt ghi âm" trong cửa sổ bật lên thông tin.

00:10:01.000 --> 00:10:06.000
Và bây giờ, bạn đã biết cách xem và tạo trạng thái hiệu suất GPU từ Instruments.

00:10:06.000 --> 00:10:12.000
Cách thứ hai để tận dụng trạng thái hiệu suất GPU nhất quán là sử dụng Trình gỡ lỗi kim loại.

00:10:12.000 --> 00:10:20.000
Theo mặc định, khi bạn chụp dấu vết GPU của ứng dụng của mình, Xcode sẽ lập hồ sơ dấu vết cho bạn.

00:10:20.000 --> 00:10:26.000
Và nó sẽ làm như vậy bằng cách sử dụng cùng một trạng thái hiệu suất mà thiết bị đã ở tại thời điểm chụp.

00:10:26.000 --> 00:10:31.000
Trạng thái đó có thể đã dao động, tùy thuộc vào các yếu tố mà chúng tôi đã đề cập trước đó.

00:10:31.000 --> 00:10:39.000
Thay vào đó, nếu bạn muốn tự mình chọn một trạng thái hiệu suất nhất định, hãy sử dụng nút Đồng hồ bấm giờ trong thanh gỡ lỗi.

00:10:39.000 --> 00:10:44.000
Sau khi bạn thực hiện lựa chọn, Metal Debugger sẽ lập hồ sơ lại dấu vết GPU của bạn.

00:10:44.000 --> 00:10:51.000
Sau khi hoàn thành, nút được tô sáng để phản ánh rằng trạng thái hiệu suất nhất quán đã đạt được.

00:10:51.000 --> 00:11:00.000
Ngoài ra, phần "Hiệu suất" trên trang tóm tắt hiện hiển thị dữ liệu hiệu suất mới trong nháy mắt, cũng như trạng thái hiệu suất đã chọn.

00:11:00.000 --> 00:11:04.000
Hai cách tiếp cận này được gắn với bộ công cụ Kim loại.

00:11:04.000 --> 00:11:10.000
Nhưng đôi khi, bạn có thể muốn tạo ra trạng thái hiệu suất nhất quán bên ngoài quy trình làm việc lập hồ sơ.

00:11:10.000 --> 00:11:17.000
Cách thứ ba để thiết lập trạng thái hiệu suất GPU là thông qua các điều kiện Thiết bị.

00:11:17.000 --> 00:11:24.000
Nếu bạn muốn kiểm tra xem ứng dụng của mình hoạt động như thế nào dưới các trạng thái hiệu suất GPU khác nhau, đây là tùy chọn dành cho bạn.

00:11:24.000 --> 00:11:30.000
Trong Xcode 13, chúng tôi đã thêm điều kiện thiết bị trạng thái hiệu suất GPU.

00:11:30.000 --> 00:11:39.000
Nó buộc hệ điều hành sử dụng trạng thái được chỉ định trên một thiết bị, miễn là nó có thể duy trì nó và nó vẫn được kết nối với Xcode.

00:11:39.000 --> 00:11:54.000
Bạn có thể thêm điều kiện này từ Xcode, nếu bạn vào Window, Devices and Simulators, chọn thiết bị của bạn ở đó, sau đó cuộn đến phần "Điều kiện thiết bị" và thêm điều kiện "Trạng thái hiệu suất GPU" với mức mong muốn.

00:11:54.000 --> 00:11:59.000
Nhấn Bắt đầu khi bạn muốn áp dụng thay đổi trạng thái hiệu suất GPU trên thiết bị.

00:11:59.000 --> 00:12:03.000
Sau đó, khi bạn hoàn thành, nhấn Dừng lại.

00:12:03.000 --> 00:12:11.000
Những cách mới này để xem và thay đổi trạng thái hiệu suất GPU ngay từ các công cụ của chúng tôi sẽ giúp bạn lập hồ sơ và kiểm tra các ứng dụng của mình.

00:12:11.000 --> 00:12:20.000
Và tôi nghĩ bạn sẽ thích những bổ sung và cải tiến mới nhất của chúng tôi đối với quy trình làm việc lập hồ sơ và tôi hy vọng chúng sẽ giúp bạn làm cho ứng dụng của mình tốt hơn nữa.

00:12:20.000 --> 00:12:26.000
Bây giờ, hãy nói về một số cải tiến khác mà chúng tôi sẽ mang đến cho Metal Debugger trong năm nay.

00:12:26.000 --> 00:12:31.000
Đầu tiên, tôi sẽ cho bạn biết về những cải tiến đối với xác thực đổ bóng.

00:12:31.000 --> 00:12:34.000
Sau đó, tôi sẽ chỉ cho bạn các điều khiển chụp chính xác.

00:12:34.000 --> 00:12:40.000
Và sau đó, tôi sẽ cho bạn xem xét quy trình làm việc trạng thái đường ống mới.

00:12:40.000 --> 00:12:50.000
Cuối cùng, tôi muốn giới thiệu hai tính năng mới liên quan đến gỡ lỗi và lập hồ sơ đổ bóng, thông tin gỡ lỗi riêng biệt và gỡ lỗi đổ bóng chọn lọc.

00:12:50.000 --> 00:13:02.000
Năm ngoái, trong Xcode 12, chúng tôi đã giới thiệu xác thực đổ bóng, giúp bạn chẩn đoán lỗi thời gian chạy trên GPU, như truy cập ngoài giới hạn và các lỗi khác.

00:13:02.000 --> 00:13:19.000
Hãy nhớ rằng nếu xác thực đổ bóng được bật và bộ mã hóa gây ra lỗi xác thực, bạn sẽ gặp sự cố thời gian chạy trong trình điều hướng sự cố, hiển thị cả dấu vết ngược CPU và GPU cho cuộc gọi bị lỗi.

00:13:19.000 --> 00:13:46.000
Chúng tôi đã có một phiên đề cập đến điều này chi tiết hơn, vì vậy để tìm hiểu thêm về cách sử dụng xác thực đổ bóng, hãy xem bài nói chuyện năm ngoái, được gọi là "Gỡ lỗi phía GPU trong Metal". Năm nay, chúng tôi đang mở rộng xác thực đổ bóng để hỗ trợ nhiều trường hợp sử dụng hơn, làm cho nó có sẵn khi bạn đang sử dụng bộ đệm lệnh gián tiếp, thư viện động, con trỏ và bảng chức năng.

00:13:46.000 --> 00:13:53.000
Điều này sẽ cho phép bạn sử dụng xác thực đổ bóng rộng rãi hơn trong toàn bộ ứng dụng của mình trong quá trình phát triển.

00:13:53.000 --> 00:13:58.000
Tiếp theo, tôi muốn cho bạn thấy các điều khiển chụp chính xác mới của chúng tôi.

00:13:58.000 --> 00:14:04.000
Nhưng trước tiên, hãy nhìn vào nút Chụp, bây giờ trông giống như logo Kim loại.

00:14:04.000 --> 00:14:09.000
Nó nằm trên thanh gỡ lỗi, ở cuối cửa sổ Xcode.

00:14:09.000 --> 00:14:12.000
Khi bạn nhấp vào nó, một menu mới sẽ xuất hiện.

00:14:12.000 --> 00:14:16.000
Trình đơn này cho phép bạn chọn một phạm vi để chụp.

00:14:16.000 --> 00:14:23.000
Mặc định là chụp một khung hình, nhưng bạn có thể chỉ định số lượng bạn muốn chụp, tối đa năm.

00:14:23.000 --> 00:14:42.000
Bạn cũng có thể chọn chụp một số bộ đệm lệnh có cùng thiết bị mẹ hoặc hàng đợi lệnh, cũng như những bộ đệm trình bày một lớp Kim loại nhất định và thậm chí cả phạm vi tùy chỉnh mà bạn có thể xác định trong mã ứng dụng của mình bằng MTLCaptureScope API.

00:14:42.000 --> 00:14:51.000
Những điều khiển mới này cung cấp cho bạn sức mạnh đáng kinh ngạc ngay lập tức trong việc quyết định cách thức và thời điểm các cuộc gọi Metal của bạn được ghi lại.

00:14:51.000 --> 00:14:56.000
Tiếp theo, hãy nói về các thư viện Metal và các trạng thái đường ống.

00:14:56.000 --> 00:15:00.000
Đây là những khối xây dựng thiết yếu của ứng dụng Metal của bạn.

00:15:00.000 --> 00:15:07.000
Và trong Xcode 13, chúng tôi đã giúp việc kiểm tra tất cả các trạng thái đường ống và thư viện mà ứng dụng của bạn đang sử dụng trở nên dễ dàng hơn bao giờ hết.

00:15:07.000 --> 00:15:11.000
Bây giờ, hãy xem nó trông như thế nào trong thực tế.

00:15:11.000 --> 00:15:16.000
Ở đây, tôi đã ghi lại một dấu vết GPU từ một ứng dụng mẫu ModernRenderer.

00:15:16.000 --> 00:15:23.000
Tôi muốn xem trạng thái đường ống GBuffer hoạt động như thế nào, vì vậy tôi đã chọn cuộc gọi rút thăm này.

00:15:23.000 --> 00:15:28.000
Nếu tôi nhìn vào các tài nguyên bị ràng buộc, bây giờ tôi có thể thấy trạng thái đường ống đã được sử dụng.

00:15:28.000 --> 00:15:32.000
Mở nó đưa tôi đến Pipeline State Viewer.

00:15:32.000 --> 00:15:39.000
Từ đây, tôi có thể kiểm tra các chức năng và xem các thuộc tính khác mà trạng thái đường ống được tạo ra.

00:15:39.000 --> 00:15:49.000
Hơn nữa, từ trình xem, tôi có thể kiểm tra dữ liệu hiệu suất được liên kết với trạng thái hoặc tôi có thể truy cập Trình xem bộ nhớ và hiển thị trạng thái ở đó.

00:15:49.000 --> 00:15:57.000
Trong Xcode 13, Trình xem bộ nhớ hiện hiển thị lượng bộ nhớ mà các trạng thái đường ống đang chiếm trong ứng dụng của bạn.

00:15:57.000 --> 00:16:06.000
Đây chỉ là một số bổ sung giúp kiểm tra trạng thái đường ống trên Trình gỡ lỗi kim loại dễ dàng hơn khi bạn đang xem dấu vết GPU của ứng dụng của mình.

00:16:06.000 --> 00:16:11.000
Tiếp theo, hãy nói về gỡ lỗi và lập hồ sơ đổ bóng trong Trình gỡ lỗi kim loại.

00:16:11.000 --> 00:16:16.000
Ngay bây giờ, nếu bạn muốn sử dụng các tính năng này, bạn có hai lựa chọn.

00:16:16.000 --> 00:16:21.000
Tùy chọn đầu tiên là biên dịch thư viện của bạn từ mã nguồn khi ứng dụng đang chạy.

00:16:21.000 --> 00:16:30.000
Một lựa chọn thứ hai, tốt hơn là xây dựng các tệp Metallib với các nguồn được nhúng ngoại tuyến và sau đó tải chúng trong thời gian chạy.

00:16:30.000 --> 00:16:37.000
Nhưng sau đó, các quy tắc của App Store không cho phép bạn xuất bản các ứng dụng của mình với các Metallibs gỡ lỗi này.

00:16:37.000 --> 00:16:54.000
Tất cả điều đó có nghĩa là nếu bạn biên dịch các thư viện của mình ngoại tuyến và bạn muốn có thể gỡ lỗi các trình đổ bóng của mình, bạn phải biên dịch chúng hai lần: một lần với các nguồn được nhúng, để sử dụng trong quá trình phát triển và một lần không có nguồn, để phân phối.

00:16:54.000 --> 00:16:57.000
Năm nay, chúng tôi đang thay đổi điều đó.

00:16:57.000 --> 00:17:03.000
Bây giờ bạn có thể tạo một tệp riêng biệt với các nguồn và thông tin gỡ lỗi khác trong khi biên dịch Metallib.

00:17:03.000 --> 00:17:14.000
Các tệp này có phần mở rộng Metallibsym và chúng cho phép bạn gỡ lỗi và đổ bóng hồ sơ mà không cần nhúng thông tin bổ sung vào chính thư viện.

00:17:14.000 --> 00:17:21.000
Lợi ích quan trọng nhất của việc có chúng riêng biệt, là bây giờ bạn không cần phải có hai phiên bản của cùng một Metallib.

00:17:21.000 --> 00:17:34.000
Một lợi ích khác là với các tệp Metallibsym này, giờ đây bạn sẽ có thể gỡ lỗi các trình đổ bóng ngay cả trong các phiên bản phát hành của ứng dụng mà không cần phải xâm phạm các nguồn đổ bóng của bạn.

00:17:34.000 --> 00:17:42.000
Tôi sẽ chỉ cho bạn một ví dụ về cách biên dịch tệp nguồn đổ bóng thành Metallib với tệp Metallibsym cùng với nó.

00:17:42.000 --> 00:17:48.000
Tôi sẽ bắt đầu với lệnh đầu cuối xcrun biên dịch Metallib như bình thường.

00:17:48.000 --> 00:17:58.000
Để tạo tệp Metallibsym, tôi chỉ cần thêm cờ "nguồn bản ghi" với tùy chọn "phẳng", sau đó chạy trình biên dịch.

00:17:58.000 --> 00:18:07.000
Bây giờ, khi tôi cố gắng gỡ lỗi một bộ đổ bóng đã được biên dịch với một tệp thông tin gỡ lỗi riêng biệt, tôi sẽ được nhắc nhập nó.

00:18:07.000 --> 00:18:15.000
Nhấp vào Nhập Nguồn sẽ mở ra một hộp thoại liệt kê tất cả các thư viện và liệu chúng có được nhập tệp nguồn hay không.

00:18:15.000 --> 00:18:25.000
Từ đây, tôi có thể nhập bất kỳ tệp Metallibsym nào và sau khi nhập, các thư viện và nguồn của chúng sẽ được khớp tự động.

00:18:25.000 --> 00:18:34.000
Khi tôi nhập xong, tôi có thể đóng hộp thoại, và bây giờ tôi có thể xem các nguồn cho đổ bóng và gỡ lỗi nó.

00:18:34.000 --> 00:18:38.000
Có một cải tiến gỡ lỗi cuối cùng mà tôi muốn cho bạn thấy.

00:18:38.000 --> 00:18:48.000
Nó được gọi là "gỡ lỗi đổ bóng chọn lọc." Nếu ứng dụng của bạn sử dụng bộ đổ bóng lớn, bạn có thể nhận thấy rằng việc gỡ lỗi bộ đổ bóng có thể mất một lúc để bắt đầu.

00:18:48.000 --> 00:18:53.000
Để giúp đỡ trong những trường hợp như vậy, năm nay, chúng tôi đang đưa ra gỡ lỗi đổ bóng có chọn lọc.

00:18:53.000 --> 00:18:59.000
Nó giúp bạn thu hẹp phạm vi gỡ lỗi, vì vậy bạn có thể gỡ lỗi bộ đổ bóng của mình nhanh hơn.

00:18:59.000 --> 00:19:03.000
Hãy xem nó hoạt động với một trong những bộ đổ bóng lớn như vậy.

00:19:03.000 --> 00:19:08.000
Tôi muốn gỡ lỗi GPU ASTCDecoder này.

00:19:08.000 --> 00:19:14.000
Tôi biết rằng nếu tôi cố gắng gỡ lỗi toàn bộ hạt nhân này, Shader Debugger sẽ mất nhiều thời gian để bắt đầu.

00:19:14.000 --> 00:19:23.000
Tôi không muốn đợi lâu như vậy, vì vậy thay vào đó, tôi có thể thu hẹp phạm vi gỡ lỗi xuống chỉ hàm này, decodeIntegerSequence.

00:19:23.000 --> 00:19:28.000
Để làm như vậy, tôi có thể nhấp chuột phải vào nó và chọn Chức năng gỡ lỗi.

00:19:28.000 --> 00:19:33.000
Điều này mở ra trình đơn "chức năng để gỡ lỗi", với phạm vi chức năng đã được chọn.

00:19:33.000 --> 00:19:40.000
Bây giờ, trình gỡ lỗi sẽ bắt đầu gần như ngay lập tức.

00:19:40.000 --> 00:19:45.000
Gỡ lỗi bộ đổ bóng có chọn lọc là một cách tuyệt vời để xác định lỗi trong bộ đổ bóng lớn một cách nhanh chóng.

00:19:45.000 --> 00:19:50.000
Đây là tất cả những cải tiến công cụ kim loại mà tôi muốn cho bạn thấy hôm nay.

00:19:50.000 --> 00:19:54.000
Và bây giờ, Amanda sẽ cho bạn biết về những tiến bộ mà chúng tôi đã đạt được trong việc nén kết cấu.

00:19:54.000 --> 00:19:56.000
Amanda?

00:19:56.000 --> 00:19:57.000
Cảm ơn, Egor.

00:19:57.000 --> 00:20:02.000
Tôi sẽ hướng dẫn bạn các bản cập nhật mà chúng tôi đã thực hiện trong năm nay cho các công cụ nén kết cấu.

00:20:02.000 --> 00:20:08.000
Trước khi đi sâu vào các công cụ, tôi sẽ thảo luận ngắn gọn về những điều cơ bản về nén kết cấu trên nền tảng Apple.

00:20:08.000 --> 00:20:13.000
Nén kết cấu, trong trường hợp này, là nén dữ liệu kết cấu có tốc độ cố định, mất dữ liệu.

00:20:13.000 --> 00:20:19.000
Điều này chủ yếu nhằm mục đích nén ngoại tuyến dữ liệu kết cấu tĩnh, chẳng hạn như đề can hoặc bản đồ thông thường.

00:20:19.000 --> 00:20:24.000
Mặc dù bạn có thể nén dữ liệu kết cấu động trong thời gian chạy, nhưng đó không phải là điều tôi đề cập đến hôm nay.

00:20:24.000 --> 00:20:31.000
Hầu hết việc nén kết cấu hoạt động bằng cách tách kết cấu thành các khối và nén từng khối dưới dạng một cặp màu.

00:20:31.000 --> 00:20:38.000
Cặp này xác định một bảng màu được bản địa hóa, bao gồm các màu khác được nội suy từ các điểm cuối này và chỉ mục trên mỗi pixel chọn từ bảng màu này.

00:20:38.000 --> 00:20:43.000
Mỗi định dạng có những điểm mạnh khác nhau phù hợp với các loại dữ liệu kết cấu khác nhau.

00:20:43.000 --> 00:20:50.000
GPU của Apple cũng hỗ trợ nén bộ đệm khung không mất dữ liệu bắt đầu trong các thiết bị A12 của chúng tôi và rất phù hợp để tối ưu hóa băng thông.

00:20:50.000 --> 00:20:58.000
Hãy xem phiên năm ngoái "Tối ưu hóa các ứng dụng và trò chơi Metal với bộ đếm GPU" để tìm hiểu thêm về cách đo băng thông bộ nhớ mà GPU đang sử dụng cho ứng dụng của bạn.

00:20:58.000 --> 00:21:07.000
Một lựa chọn khác là thực hiện nén không mất dữ liệu các tệp kết cấu trên phần nén kết cấu GPU mà tôi đang đề cập trong bài thuyết trình này.

00:21:07.000 --> 00:21:11.000
Điều này có thể giúp bạn giảm thêm kích thước tải xuống ứng dụng của bạn.

00:21:11.000 --> 00:21:17.000
Bây giờ tôi đã xác định nén kết cấu cho bài nói chuyện này, tôi sẽ nói về những lợi ích mà nén kết cấu có thể mang lại cho ứng dụng của bạn.

00:21:17.000 --> 00:21:21.000
Nén kết cấu là một bước quan trọng trong sự phát triển ứng dụng của bạn.

00:21:21.000 --> 00:21:26.000
Nói chung, hầu hết dấu chân bộ nhớ của trò chơi bao gồm các kết cấu.

00:21:26.000 --> 00:21:34.000
Sử dụng nén kết cấu cho phép bạn tải nhiều kết cấu hơn vào bộ nhớ và sử dụng các kết cấu chi tiết hơn để tạo ra các trò chơi trực quan hấp dẫn hơn.

00:21:34.000 --> 00:21:39.000
Nén cũng có thể cho phép bạn giảm kích thước và dung lượng bộ nhớ của ứng dụng.

00:21:39.000 --> 00:21:45.000
Bây giờ tôi đã đề cập đến những điều cơ bản, tôi sẽ thảo luận về tình trạng hiện tại của các công cụ nén kết cấu trên nền tảng Apple.

00:21:45.000 --> 00:21:50.000
TextureTool hiện có trong iOS SDK có một đường ống tương đối đơn giản.

00:21:50.000 --> 00:21:59.000
TextureTool đọc hình ảnh đầu vào, tạo mipmap nếu muốn, nén kết cấu, chặn từng khối, sau đó ghi kết quả vào tệp đầu ra mới.

00:21:59.000 --> 00:22:05.000
Nhưng khi các thuật toán đồ họa tăng độ phức tạp, kết cấu cần xử lý nâng cao hơn.

00:22:05.000 --> 00:22:14.000
Cốt lõi của các quy trình này là thực hiện các thao tác trong không gian màu chính xác, đồng thời giảm thiểu việc làm tròn từ các phép biến đổi giữa các độ chính xác số.

00:22:14.000 --> 00:22:24.000
Hiểu được điều này, chúng tôi đã thiết kế một công cụ nén mới có tên là TextureConverter để xử lý sự gia tăng cần thiết trong độ tinh vi xử lý kết cấu và cung cấp cho bạn quyền truy cập vào một loạt các tùy chọn mới.

00:22:24.000 --> 00:22:31.000
Chúng ta hãy xem xét kỹ hơn cách chúng ta đã cải tiến quy trình xử lý kết cấu trên các nền tảng của Apple.

00:22:31.000 --> 00:22:39.000
Đường ống xử lý kết cấu đã được xây dựng lại từ đầu để cung cấp cho bạn quyền truy cập vào đường ống xử lý kết cấu đầy đủ tính năng với TextureConverter.

00:22:39.000 --> 00:22:50.000
TextureConverter tận dụng một bộ máy nén được công nhận trong ngành để hỗ trợ một loạt các định dạng nén và cung cấp cho bạn tùy chọn để đánh đổi giữa tốc độ nén và chất lượng hình ảnh.

00:22:50.000 --> 00:22:58.000
Bạn có thể chỉ định sử dụng máy nén nào hoặc cho phép TextureConverter chọn dựa trên định dạng nén, mức chất lượng và các tùy chọn khác.

00:22:58.000 --> 00:23:04.000
Mỗi giai đoạn hiện có thể được bạn cấu hình đầy đủ và xử lý kết cấu nhận thức được gamma.

00:23:04.000 --> 00:23:13.000
Để hỗ trợ tích hợp vào tất cả các đường ống nội dung của bạn, TextureConverter có sẵn cho cả macOS và Windows, và được tối ưu hóa để sử dụng với Apple Silicon.

00:23:13.000 --> 00:23:17.000
Hãy bước qua từng giai đoạn của đường ống mở rộng, bắt đầu với gamma.

00:23:17.000 --> 00:23:22.000
Hiệu chỉnh gamma là một hoạt động phi tuyến để mã hóa và giải mã độ sáng trong hình ảnh.

00:23:22.000 --> 00:23:25.000
Kết cấu có thể được mã hóa trong nhiều không gian gamma.

00:23:25.000 --> 00:23:29.000
Sự lựa chọn tốt nhất phụ thuộc vào loại dữ liệu mà kết cấu đại diện.

00:23:29.000 --> 00:23:36.000
Hầu hết dữ liệu trực quan, chẳng hạn như đề can hoặc bản đồ ánh sáng, hoạt động tốt nhất khi được mã hóa trong không gian phi tuyến tính, như sRGB.

00:23:36.000 --> 00:23:41.000
Dữ liệu phi trực quan, giống như bản đồ thông thường, nên được mã hóa trong không gian tuyến tính.

00:23:41.000 --> 00:23:45.000
Sự lựa chọn này mang lại cho bạn độ chính xác cao hơn trong các vùng tối nơi cần thiết.

00:23:45.000 --> 00:23:49.000
Dữ liệu phi trực quan, giống như bản đồ thông thường, nên được mã hóa trong không gian tuyến tính.

00:23:49.000 --> 00:23:55.000
Việc nén nên được thực hiện trong không gian màu mục tiêu của bạn, được chỉ định bằng các tùy chọn "gamma_in" và "gamma_out".

00:23:55.000 --> 00:24:03.000
Bạn có thể nhập giá trị float cho không gian gamma tuyến tính hoặc sử dụng chuỗi "sRGB" để chỉ định không gian màu đó.

00:24:03.000 --> 00:24:08.000
Bạn cũng có thể linh hoạt sử dụng các tùy chọn này để chuyển đổi sang một không gian mục tiêu khác.

00:24:08.000 --> 00:24:13.000
Các hoạt động khác, chẳng hạn như tạo mipmap, nên được thực hiện trong không gian tuyến tính.

00:24:13.000 --> 00:24:17.000
Tôi sẽ đi qua các giai đoạn xử lý không gian tuyến tính ngay bây giờ.

00:24:17.000 --> 00:24:26.000
Bây giờ đầu vào đã được chuyển đổi thành không gian gamma tuyến tính, các hoạt động không gian tuyến tính được thực hiện trước khi kết cấu đầu vào được chuyển đổi thành không gian gamma mục tiêu được chỉ định.

00:24:26.000 --> 00:24:34.000
Ba giai đoạn là biến đổi vật lý, tạo mipmap và xử lý alpha, và một số trong số này có các giai đoạn con.

00:24:34.000 --> 00:24:36.000
Tôi sẽ bắt đầu với các biến đổi vật lý.

00:24:36.000 --> 00:24:43.000
Bằng cách xác định kích thước tối đa trong bất kỳ trục nào, bạn có thể thu nhỏ hình ảnh của mình khi bạn cần cho mipmap cấp cao nhất của mình.

00:24:43.000 --> 00:24:48.000
Trong giai đoạn này, bạn cũng có quyền kiểm soát bộ lọc thay đổi kích thước và thay đổi kích thước chế độ làm tròn.

00:24:48.000 --> 00:24:55.000
Các tùy chọn bộ lọc thay đổi kích thước sử dụng các thuật toán khác nhau để giúp bạn giảm độ mờ của mipmap khi chúng giảm kích thước kích thước.

00:24:55.000 --> 00:25:01.000
Thay đổi kích thước chế độ tròn được sử dụng kết hợp với max_extent khi thay đổi kích thước hình ảnh của bạn.

00:25:01.000 --> 00:25:07.000
Nếu vượt quá max_extent, hình ảnh nguồn sẽ được thay đổi kích thước bằng cách duy trì khía cạnh của hình ảnh gốc.

00:25:07.000 --> 00:25:11.000
Chế độ vòng được chỉ định sẽ được sử dụng khi tìm kích thước mục tiêu.

00:25:11.000 --> 00:25:19.000
Nếu bạn không chắc chắn nên sử dụng bộ lọc thay đổi kích thước hoặc chế độ làm tròn nào, chúng tôi đã chọn mặc định hoạt động tốt trong hầu hết các trường hợp.

00:25:19.000 --> 00:25:27.000
Và các tùy chọn lật trong giai đoạn này cung cấp cho bạn quyền kiểm soát các phép biến đổi tuyến tính trên các trục X, Y và Z.

00:25:27.000 --> 00:25:34.000
Sau khi biến đổi là tạo mipmap, được sử dụng trong phần lớn các tình huống xử lý kết cấu phổ biến.

00:25:34.000 --> 00:25:43.000
Mipmaps là một chuỗi hình ảnh được tính toán trước làm giảm độ phân giải trên chuỗi, được sử dụng để tăng tốc độ kết xuất và giảm răng cưa.

00:25:43.000 --> 00:25:48.000
Chiều cao và chiều rộng của mỗi cấp độ nhỏ hơn hai cấp độ so với cấp độ trước đó.

00:25:48.000 --> 00:25:55.000
Khi tùy chỉnh tạo mipmap, hãy chỉ định số lượng tối đa bạn muốn và bộ lọc mip nào sẽ sử dụng.

00:25:55.000 --> 00:26:03.000
TextureConverter mặc định là lọc Kaiser, với các tùy chọn lọc "hộp" và "tam giác".

00:26:03.000 --> 00:26:08.000
Giai đoạn cuối cùng trong xử lý không gian tuyến tính là xử lý alpha.

00:26:08.000 --> 00:26:15.000
Nếu alpha to coverage được bật, điều này được áp dụng trước, sử dụng giá trị tham chiếu alpha được chỉ định.

00:26:15.000 --> 00:26:18.000
Alpha to coverage thay thế pha trộn alpha bằng mặt nạ che phủ.

00:26:18.000 --> 00:26:29.000
Khi sử dụng kết cấu khử răng cưa hoặc bán trong suốt, điều này mang lại cho bạn độ trong suốt độc lập với thứ tự và là một công cụ đặc biệt hữu ích để hiển thị cây xanh dày đặc trong trò chơi của bạn.

00:26:29.000 --> 00:26:36.000
Sau đó, tùy chọn loại bỏ, bảo quản hoặc nhân trước kênh alpha được trình bày.

00:26:36.000 --> 00:26:44.000
Trong alpha nhân trước, các điểm ảnh trong suốt một phần của hình ảnh của bạn sẽ được nhân trước với màu thảm.

00:26:44.000 --> 00:26:52.000
Vào cuối các giai đoạn xử lý không gian tuyến tính, chúng tôi đã sẵn sàng quay trở lại không gian gamma mục tiêu và nén các mức mip đã xử lý.

00:26:52.000 --> 00:26:55.000
Bước cuối cùng trong xử lý kết cấu là nén.

00:26:55.000 --> 00:27:01.000
Giai đoạn nén có thể được chia thành hai giai đoạn con, ánh xạ kênh và mã hóa.

00:27:01.000 --> 00:27:08.000
Ánh xạ kênh là một kỹ thuật để tối ưu hóa các thuật toán nén kết cấu mục đích chung cho các loại dữ liệu cụ thể.

00:27:08.000 --> 00:27:11.000
Chỉ định ánh xạ kênh trong TextureConverter là tùy chọn.

00:27:11.000 --> 00:27:19.000
Nếu bạn muốn sử dụng nó, TextureConverter hiện hỗ trợ hai chế độ ánh xạ kênh, mã hóa RGBM và mã hóa bản đồ thông thường.

00:27:19.000 --> 00:27:24.000
Tôi sẽ đề cập đến cả hai định dạng này sâu hơn, bắt đầu với mã hóa RGBM.

00:27:24.000 --> 00:27:35.000
Mã hóa RGBM là một kỹ thuật để nén dữ liệu HDR ở định dạng LDR bằng cách lưu trữ hệ số nhân trong kênh alpha và chia tỷ lệ các kênh RGB bằng hệ số nhân này.

00:27:35.000 --> 00:27:38.000
Đây là một ví dụ về hình ảnh HDR của một lớp học.

00:27:38.000 --> 00:27:44.000
Và đây là cùng một hình ảnh lớp học một lần nữa với hệ số nhân được lưu trữ trong kênh alpha có thể nhìn thấy ở thang độ xám.

00:27:44.000 --> 00:27:49.000
Tôi sẽ chỉ cho bạn cách tính hệ số nhân để mã hóa thành RGBM bằng một ví dụ mã.

00:27:49.000 --> 00:27:57.000
EncodeRGBM là một hàm mã giả đơn giản mà tôi sẽ hướng dẫn bạn để giúp bạn hiểu cơ chế mã hóa thành RGBM.

00:27:57.000 --> 00:28:05.000
Đoạn mã này bao gồm việc sử dụng RGBM_Range, tham số hoàn toàn mới để đặt phạm vi của RGBM và mặc định thành 6.0.

00:28:05.000 --> 00:28:15.000
Để tính toán giá trị alpha RGBM, hệ số nhân, trước tiên, tôi sẽ xác định mức tối đa của các kênh màu đỏ, xanh lá cây và xanh dương của kết cấu đầu vào.

00:28:15.000 --> 00:28:18.000
Điều này được thực hiện với chức năng max3 của Metal.

00:28:18.000 --> 00:28:21.000
Sau đó mức tối đa này được chia cho RGBM_Range.

00:28:21.000 --> 00:28:36.000
Để tính toán các giá trị kênh màu đỏ, xanh lá cây và xanh dương của RGBM được mã hóa, trước tiên, hệ số nhân được tính toán trước đó được nhân lại với RGBM_Range, được sử dụng để chia tỷ lệ giá trị lưu trữ trong kênh alpha.

00:28:36.000 --> 00:28:41.000
Sau đó, kết cấu đầu vào được chia cho giá trị hệ số nhân cuối cùng.

00:28:41.000 --> 00:28:49.000
Để giải mã RGBM trong bộ đổ bóng của bạn, bạn nhân RGB của mẫu với alpha và hệ số cố định, như tôi đã chỉ cho bạn trong hàm mã hóa.

00:28:49.000 --> 00:28:53.000
Tôi sẽ xem qua đoạn mã DecodeRGBM để chỉ cho bạn cách thực hiện việc này.

00:28:53.000 --> 00:29:02.000
Hệ số chia tỷ lệ được tính toán lại bằng cách nhân kênh alpha RGBM, nơi hệ số nhân được lưu trữ, với RGBM_Range.

00:29:02.000 --> 00:29:09.000
RGB của kết cấu ban đầu được tính bằng cách nhân mẫu RGBM với hệ số nhân được tính toán.

00:29:09.000 --> 00:29:14.000
Bây giờ tôi đã giới thiệu cho bạn mã hóa RGBM, tôi sẽ chuyển sang mã hóa bản đồ bình thường.

00:29:14.000 --> 00:29:20.000
Trong hầu hết các trường hợp, khi đề cập đến bản đồ bình thường, chúng tôi đặc biệt đề cập đến bản đồ bình thường không gian đối tượng.

00:29:20.000 --> 00:29:31.000
Khi mã hóa các chuẩn của chúng ta trong không gian đối tượng, chúng ta biết rằng mỗi chuẩn là một vectơ đơn vị, có lợi ích là nó có thể được biểu diễn trong hai trục với trục thứ ba có thể dẫn xuất tầm thường trong thời gian chạy.

00:29:31.000 --> 00:29:42.000
Điều này cho phép chúng tôi ánh xạ lại hai kênh này để tận dụng tốt nhất các thuật toán nén kết cấu và đạt được chất lượng nén vượt trội so với nén XYZ dưới dạng RGB.

00:29:42.000 --> 00:29:45.000
Cách bạn ánh xạ lại các kênh khác nhau tùy thuộc vào định dạng nén.

00:29:45.000 --> 00:29:51.000
Tôi sẽ xem qua một ví dụ về mã hóa bình thường bằng ASTC, sử dụng biểu đồ này làm hướng dẫn.

00:29:51.000 --> 00:30:00.000
Khi mã hóa bằng ASTC, các kênh màu đỏ, xanh lá cây và xanh dương được đặt thành thành phần X và kênh alpha được đặt thành thành phần Y.

00:30:00.000 --> 00:30:07.000
Các màu sắc tương ứng với kênh mà các thành phần X và Y sẽ được gán lại khi lấy mẫu bình thường được mã hóa.

00:30:07.000 --> 00:30:16.000
TextureConverter đảm nhận việc ánh xạ lại mã hóa cho bạn bằng cách tự động ánh xạ lại theo định dạng bạn đã chọn nếu bạn vượt qua tham số bản đồ bình thường.

00:30:16.000 --> 00:30:21.000
Khi lấy mẫu bản đồ bình thường trong bộ đổ bóng của bạn, điều quan trọng là phải biết ánh xạ kênh.

00:30:21.000 --> 00:30:29.000
Trong khi thành phần X được đọc từ kênh màu đỏ hoặc alpha, thành phần Y đến từ kênh alpha hoặc màu xanh lá cây tùy thuộc vào định dạng nén.

00:30:29.000 --> 00:30:41.000
Quay trở lại ví dụ ASTC, để lấy mẫu kết cấu, thành phần X được lấy mẫu từ kênh màu đỏ và thành phần Y được lấy mẫu từ kênh alpha, ngược lại với cách mã hóa chuẩn.

00:30:41.000 --> 00:30:49.000
Nếu bạn đang mã hóa thành nhiều định dạng để đạt được chất lượng tốt nhất có thể trên bất kỳ thiết bị nào, thì ánh xạ này là thứ mà bạn sẽ cần xử lý trong thời gian chạy.

00:30:49.000 --> 00:30:55.000
Tôi sẽ xem qua một ví dụ về lấy mẫu bình thường trong thời gian chạy bằng cách sử dụng kết cấu kim loại.

00:30:55.000 --> 00:31:02.000
Mã hóa thành nhiều định dạng có thể dẫn đến việc cần nhiều biến thể đổ bóng nếu các định dạng khác nhau sử dụng ánh xạ kênh khác nhau.

00:31:02.000 --> 00:31:07.000
Để tránh điều này, Metal cho phép bạn áp dụng các họa tiết tùy chỉnh cho kết cấu của mình.

00:31:07.000 --> 00:31:14.000
Swizzles cho phép bạn ánh xạ lại các thành phần X và Y sang các kênh màu đỏ và xanh lá cây để các bộ đổ bóng của bạn có thể là định dạng nén trung tính.

00:31:14.000 --> 00:31:22.000
Đây là một ví dụ về ánh xạ lại các kênh sang màu đỏ và xanh lá cây cho một bản đồ bình thường được nén bằng ASTC, như chúng ta đã thấy trong sơ đồ trước đây.

00:31:22.000 --> 00:31:32.000
Sau khi mô tả kết cấu được khởi tạo, kênh màu đỏ được đặt thành MTLTextureSwizzleRed và kênh màu xanh lá cây được đặt thành MTLTextureSwizzleAlpha.

00:31:32.000 --> 00:31:36.000
Vì đây là một bản đồ bình thường, chỉ cần hai kênh để lấy mẫu.

00:31:36.000 --> 00:31:46.000
Vì các kênh màu đỏ và màu xanh lá cây hiện được gán cho các thành phần X và Y ban đầu được mã hóa cho các kênh màu đỏ và alpha, các kênh màu xanh lam và alpha được đặt về 0.

00:31:46.000 --> 00:31:55.000
Sau khi hoàn tất, dòng cuối cùng là lắp ráp swizzle cuối cùng với các kênh được ánh xạ lại bằng cách sử dụng MTLTextureSwizzleChannelsMake.

00:31:55.000 --> 00:32:00.000
Khi các kênh X và Y được lấy mẫu trong bộ đổ bóng của bạn, bạn có thể tái tạo lại thành phần Z.

00:32:00.000 --> 00:32:06.000
Tôi sẽ hướng dẫn bạn qua chức năng ReconstructNormal để chỉ cho bạn cách thực hiện.

00:32:06.000 --> 00:32:14.000
Đầu tiên, mã định vị lại các thành phần X và Y vào phạm vi chính xác, đó là âm một đối một đối với bình thường.

00:32:14.000 --> 00:32:23.000
Bước tiếp theo là trừ tích dấu chấm của các thành phần X và Y khỏi một, để đảm bảo kết quả của sản phẩm dấu chấm có dấu đúng.

00:32:23.000 --> 00:32:29.000
Hàm bão hòa sau đó được sử dụng để kẹp kết quả này trong phạm vi từ 0 đến 1.

00:32:29.000 --> 00:32:36.000
Bước cuối cùng để tính thành phần Z là lấy căn bậc hai của đầu ra của hàm bão hòa.

00:32:36.000 --> 00:32:48.000
Bây giờ tôi đã giải thích RGBM và các tùy chọn mã hóa bản đồ thông thường có sẵn để ánh xạ kênh, tôi sẽ kết thúc cuộc thảo luận về đường ống nén kết cấu với trạng thái con nén cuối cùng, mã hóa.

00:32:48.000 --> 00:32:55.000
Tất cả các dòng lệnh TextureConverter đều yêu cầu đặc điểm kỹ thuật của định dạng nén đích với đối số compression_format.

00:32:55.000 --> 00:33:04.000
Bạn cũng có thể chỉ định sử dụng máy nén nào hoặc để TextureConverter thực hiện lựa chọn dựa trên định dạng nén và các tùy chọn khác mà bạn đã chọn.

00:33:04.000 --> 00:33:08.000
Bạn cũng có thể chọn chất lượng nén từ bốn tùy chọn này.

00:33:08.000 --> 00:33:20.000
Lưu ý rằng có sự cân bằng giữa tốc độ nén và chất lượng hình ảnh và bạn có thể muốn chọn chất lượng nén thấp hơn trong khi lặp lại trò chơi của mình, nhưng hãy sử dụng chất lượng cao nhất cho các bản dựng đã phát hành.

00:33:20.000 --> 00:33:25.000
Bây giờ, tôi sẽ đề cập đến các định dạng nén kết cấu có sẵn để bạn lựa chọn.

00:33:25.000 --> 00:33:30.000
Đây là tổng quan về các họ định dạng nén kết cấu được hỗ trợ trên nền tảng Apple.

00:33:30.000 --> 00:33:40.000
Các nền tảng iOS và Apple Silicon hỗ trợ các gia đình ASTC và PVRTC, và tất cả các nền tảng macOS đều hỗ trợ các gia đình BCn.

00:33:40.000 --> 00:33:46.000
Tôi sẽ xem xét từng gia đình định dạng này chi tiết hơn và cung cấp cho bạn một số hướng dẫn để giúp bạn chọn những định dạng tốt nhất cho nhu cầu của mình.

00:33:46.000 --> 00:33:49.000
Tôi sẽ bắt đầu với các định dạng BCn.

00:33:49.000 --> 00:33:58.000
BCn là một tập hợp gồm bảy định dạng mà tất cả đều hoạt động bằng cách sử dụng bốn khối pixel và sử dụng bốn hoặc tám bit trên mỗi pixel.

00:33:58.000 --> 00:34:02.000
Mỗi định dạng nén lý tưởng cho một định dạng dữ liệu khác nhau.

00:34:02.000 --> 00:34:16.000
BC1 và BC3 thường được sử dụng để nén RGB và RGBA, BC6 lý tưởng cho hình ảnh HDR và BC5, với các kênh độc lập kép, lý tưởng cho mã hóa bản đồ thông thường.

00:34:16.000 --> 00:34:25.000
Tiếp theo là ASTC, một họ các định dạng RGBA trong không gian màu LDR, sRGB và HDR.

00:34:25.000 --> 00:34:33.000
Họ định dạng ASTC cho phép chất lượng cao nhất ở mọi kích cỡ, và do đó thường được khuyến nghị hơn so với PVRTC.

00:34:33.000 --> 00:34:37.000
Có một loạt các bit trên mỗi pixel so với chất lượng cho mỗi định dạng.

00:34:37.000 --> 00:34:45.000
Với ASTC, kích thước byte của mỗi khối là như nhau bất kể định dạng, trong khi số lượng texels mà nó đại diện khác nhau.

00:34:45.000 --> 00:34:58.000
Điều này cung cấp cho bạn sự liên tục giữa tốc độ nén chất lượng cao nhất nhưng tốc độ nén thấp nhất ở kích thước khối bốn x bốn so với chất lượng nén thấp nhất nhưng tốc độ nén cao nhất ở kích thước khối 12 x 12.

00:34:58.000 --> 00:35:05.000
Các biến thể LDR, sRGB và HDR mô tả dải màu cho kết cấu ASTC nén.

00:35:05.000 --> 00:35:17.000
LDR và sRGB đều nằm trong phạm vi không-một, trong không gian tuyến tính hoặc sRGB, trong khi biến thể HDR dành cho dữ liệu bên ngoài phạm vi không-một.

00:35:17.000 --> 00:35:24.000
Cuối cùng, các định dạng PVRTC có sẵn ở chế độ RGB và RGBA ở chế độ 2 bit hoặc 4 bit.

00:35:24.000 --> 00:35:36.000
Một khối dữ liệu ở định dạng này luôn chiếm tám byte, vì vậy ở chế độ 2 bit sẽ có một khối cho mỗi tám x bốn pixel và ở chế độ 4 bit, có một khối cho mỗi điểm ảnh bốn x bốn.

00:35:36.000 --> 00:35:43.000
Bây giờ tôi đã giới thiệu các họ định dạng được hỗ trợ, tôi sẽ đưa ra một số đề xuất để chọn định dạng cho ứng dụng của bạn.

00:35:43.000 --> 00:35:55.000
Trên các thiết bị iOS, bạn nên luôn sử dụng nén ASTC theo mặc định, với việc bổ sung nén PVRTC và làm mỏng trên mỗi thiết bị chỉ khi bạn đang hỗ trợ GPU A7 trở về trước.

00:35:55.000 --> 00:36:04.000
Nếu bạn có bất kỳ kết cấu HDR nào, bạn có thể tận dụng ASTC HDR trên A13 và các GPU mới hơn.

00:36:04.000 --> 00:36:08.000
Đối với macOS, BCn có sẵn trên bảng.

00:36:08.000 --> 00:36:16.000
Trên Apple Silicon Macs, bạn cũng có tùy chọn sử dụng ASTC và bạn nên xem xét tùy chọn này nếu bạn cũng đang nhắm mục tiêu các thiết bị iOS.

00:36:16.000 --> 00:36:24.000
Mặc dù PVRTC có sẵn trên Apple Silicon, chúng tôi không đề xuất tùy chọn này và nó chỉ dành cho hỗ trợ kế thừa iOS.

00:36:24.000 --> 00:36:36.000
Vì có rất nhiều định dạng khác nhau trong mỗi họ định dạng nén để lựa chọn, hướng dẫn để chọn các định dạng nén kết cấu hiệu quả nhất cho ứng dụng của bạn là chọn mỗi kết cấu và mỗi mục tiêu khi có thể.

00:36:36.000 --> 00:36:49.000
Trừ khi tất cả các kết cấu của bạn là dữ liệu RGB hoặc RGBA, bạn nên chọn định dạng nén dựa trên loại dữ liệu bạn đang nén, chẳng hạn như chọn định dạng cho phép nén dưới dạng hai kênh độc lập cho dữ liệu thông thường.

00:36:49.000 --> 00:36:54.000
Khi nén sang định dạng ASTC, bạn có thể muốn chọn một tập hợp con của các định dạng.

00:36:54.000 --> 00:37:02.000
Xem xét kết cấu xô bởi những kết cấu yêu cầu chất lượng cao nhất so với những kết cấu được chấp nhận ở tốc độ nén cao hơn.

00:37:02.000 --> 00:37:04.000
Bây giờ, hãy xem lại những gì chúng tôi đã đề cập.

00:37:04.000 --> 00:37:13.000
Chúng tôi đã làm lại hoàn toàn quy trình xử lý kết cấu từ TextureTool để cung cấp cho bạn toàn quyền kiểm soát mọi giai đoạn của đường ống với công cụ TextureConverter mới của chúng tôi.

00:37:13.000 --> 00:37:25.000
Tôi đã đi qua từng giai đoạn của đường ống mới này và khám phá tất cả các tùy chọn có sẵn để bạn sử dụng ở từng giai đoạn và giới thiệu cho bạn các họ định dạng nén kết cấu và ánh xạ kênh được hỗ trợ trên nền tảng Apple.

00:37:25.000 --> 00:37:35.000
Chúng tôi muốn cập nhật quy trình làm việc của bạn từ việc sử dụng TextureTool sang TextureConverter trở nên dễ dàng nhất có thể, vì vậy chúng tôi đã thêm chế độ tương thích để giúp bạn chuyển đổi các dòng lệnh của mình.

00:37:35.000 --> 00:37:44.000
Cho dù sử dụng chế độ tương thích TextureTool hay gọi TextureConverter với các tùy chọn gốc, hãy gọi bằng xcrun TextureConverter.

00:37:44.000 --> 00:37:49.000
Đây là một dòng lệnh ví dụ của TextureConverter được gọi với các tùy chọn TextureTool.

00:37:49.000 --> 00:38:01.000
TextureConverter sẽ dịch các tùy chọn sang các tùy chọn TextureConverter gốc, thực hiện nén và sau đó cho bạn biết các tùy chọn gốc mới là gì, để bạn có thể cập nhật các tập lệnh xây dựng của mình một cách dễ dàng.

00:38:01.000 --> 00:38:03.000
Đó là phần giới thiệu về TextureConverter.

00:38:03.000 --> 00:38:04.000
Đây là cách để có được nó.

00:38:04.000 --> 00:38:10.000
TextureConverter xuất xưởng như một phần của Xcode 13 và có sẵn để sử dụng trong hạt giống 1.

00:38:10.000 --> 00:38:19.000
Trên Windows, TextureConverter vận chuyển như một phần của gói Công cụ phát triển kim loại cho Windows 2.0, có sẵn từ developer.apple.com.

00:38:19.000 --> 00:38:21.000
Seed 1 hiện đã có sẵn.

00:38:21.000 --> 00:38:32.000
Lưu ý rằng trong Windows, không có hỗ trợ nén các định dạng PVRTC, vì PVRTC có sẵn trong macOS để hỗ trợ các nền tảng iOS kế thừa.

00:38:32.000 --> 00:38:37.000
Một phần quan trọng khác của Công cụ Nhà phát triển Kim loại cho Windows là Trình biên dịch Kim loại cho Windows.

00:38:37.000 --> 00:38:44.000
Trình biên dịch kim loại cho Windows đã được giới thiệu vào năm ngoái, với sự hỗ trợ cho Ngôn ngữ đổ bóng kim loại phiên bản 2.3.

00:38:44.000 --> 00:38:48.000
Các bản cập nhật trong suốt cả năm phản ánh các bản cập nhật cho trình biên dịch Metal được vận chuyển trong Xcode.

00:38:48.000 --> 00:38:55.000
Phiên bản phát hành mới nhất là 1.2, bao gồm hỗ trợ cho Metal Shading Language trên Apple Silicon Macs.

00:38:55.000 --> 00:39:05.000
Seed 1 của phiên bản 2.0 hiện có sẵn với sự hỗ trợ cho tất cả các tính năng mới tuyệt vời trong Metal Shading Language 2.4.

00:39:05.000 --> 00:39:12.000
Đây là bản tóm tắt về mọi thứ chúng tôi đã đề cập hôm nay: Egor đã thảo luận về việc hỗ trợ nhiều tính năng Metal hơn, như dò tia và con trỏ chức năng.

00:39:12.000 --> 00:39:23.000
Anh ấy đã giới thiệu quy trình làm việc lập hồ sơ hoàn toàn mới, như Dòng thời gian GPU và trạng thái hiệu suất GPU nhất quán, để giúp bạn tận dụng tối đa GPU trên tất cả các nền tảng của Apple.

00:39:23.000 --> 00:39:31.000
Và anh ấy đã chứng minh những cải tiến đối với quy trình gỡ lỗi mà bạn đã quen thuộc để cung cấp cho bạn nhiều hỗ trợ hơn cho việc xác thực đổ bóng và điều khiển chụp chính xác.

00:39:31.000 --> 00:39:43.000
Và tôi đã giới thiệu cho bạn TextureConverter, một công cụ mới giúp bạn tận dụng tối đa quy trình xử lý kết cấu và tất cả các định dạng nén kết cấu được hỗ trợ có sẵn trên nền tảng Apple.

00:39:43.000 --> 00:39:46.000
Cảm ơn, và chúc bạn có một phần còn lại tuyệt vời của WWDC 2021.

00:39:46.000 --> 23:59:59.000
[Âm nhạc].

