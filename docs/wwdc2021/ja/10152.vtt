WEBVTT

00:00:00.000 --> 00:00:11.000
こんにちは。私はサハルシュ・オザです。

00:00:11.000 --> 00:00:14.000
私はアップルのGPUソフトウェアエンジニアリングチームに所属しています。

00:00:14.000 --> 00:00:20.000
今日は同僚のYuliya Pylypivと、Metal Performance Shaders Graphの新機能について話します。

00:00:20.000 --> 00:00:22.000
始めましょう。

00:00:22.000 --> 00:00:35.000
MPSは、画像処理、線形代数、レイトレーシング、機械学習など、さまざまな分野向けの金属ベースの高性能GPUアクセラレーションプリミティブのライブラリです。

00:00:35.000 --> 00:00:44.000
MPSチームは、Appleのさまざまなプラットフォームで各ハードウェアで最高のパフォーマンスを提供するために、Metalカーネルを最適化しています。

00:00:44.000 --> 00:00:51.000
昨年、GPU用の汎用計算グラフであるMPSGraphフレームワークを導入しました。

00:00:51.000 --> 00:01:00.000
MPSフレームワークと同様に、macOS、iOS、iPadOS、tvOSでサポートされています。

00:01:00.000 --> 00:01:05.000
MPSGraphの紹介の詳細については、昨年のセッションをご覧ください。詳細はこちらをご覧ください。

00:01:05.000 --> 00:01:07.000
議題を見てみましょう。 では、議題を見てみましょう

00:01:07.000 --> 00:01:09.000
私たちはカバーすることがたくさんあります。

00:01:09.000 --> 00:01:14.000
MPSGraphを通じて、ML推論とトレーニングアクセラレーションについて議論します。

00:01:14.000 --> 00:01:18.000
いくつかのエキサイティングな新しいMPSGraph操作を紹介します。

00:01:18.000 --> 00:01:23.000
MPSGraphでコンパイルを制御するための新しい方法を紹介します。

00:01:23.000 --> 00:01:29.000
そして最後に、MPSGraphのすべての新しい制御フロー機能を見ていきます。

00:01:29.000 --> 00:01:36.000
推論とトレーニングの加速に関するエキサイティングなアップデートを共有する同僚のユリヤを紹介したいと思います。

00:01:36.000 --> 00:01:37.000
ありがとう、サハーシュ。

00:01:37.000 --> 00:01:39.000
こんにちは。私はユリヤ・ピリピフです。

00:01:39.000 --> 00:01:42.000
私はアップルのGPUソフトウェアチームの一員です。

00:01:42.000 --> 00:01:47.000
今日は、GPUのトレーニングと推論のパフォーマンスを向上させるために行った改善点を共有したいと思います。

00:01:47.000 --> 00:01:50.000
すぐにそれに入りましょう。

00:01:50.000 --> 00:01:59.000
MPSGraphフレームワークは、GPUアクセラレーションのためにCore MLやTensorFlowなどの高レベルの機械学習フレームワークに採用されています。

00:01:59.000 --> 00:02:07.000
今年は、カーネルの改善とステッチの採用を組み合わせて、MPSGraphをさらに最適化しました。

00:02:07.000 --> 00:02:14.000
これは、MPSを使用する機械学習フレームワークに大きなパフォーマンスの向上に変換されました。

00:02:14.000 --> 00:02:19.000
TensorFlow用の新しいメタルプラグインを詳しく見てみましょう。

00:02:19.000 --> 00:02:25.000
TensorFlowは人気のある機械学習トレーニングプラットフォームであり、GPUは主要なアクセラレータデバイスです。

00:02:25.000 --> 00:02:34.000
今年は、TensorFlow 2.5でリリースされたTensorFlow PluggableDevice Interfaceを使用して、新しいメタルプラグインを開発しました。

00:02:34.000 --> 00:02:39.000
これは、MPSとMPSGraphを使用してTensorFlowにMetalの力をもたらします。

00:02:39.000 --> 00:02:46.000
これにより、変更することなく、MacプラットフォームのGPUであらゆる機械学習モデルをトレーニングできます。

00:02:46.000 --> 00:02:48.000
さて、これらのうちの1つが実際に動作しているのを見てみましょう。

00:02:48.000 --> 00:02:52.000
このデモでは、Jupyter環境を使用します。

00:02:52.000 --> 00:02:58.000
私のM1システムには、利用可能な最新のTensorFlowがインストールされています。

00:02:58.000 --> 00:03:06.000
物理デバイスをリストすると、CPUデバイスのみが登録されていることがわかります。

00:03:06.000 --> 00:03:16.000
ここでは、画像の分類、転送学習などに広く使用されている人気のある機械学習モデル、ResNet50を定義しています。

00:03:16.000 --> 00:03:25.000
現在のモデルは、224×224の画像サイズの標準ImageNetデータセットを使用しています。

00:03:25.000 --> 00:03:32.000
ご覧のとおり、CPUで実行されている最初のエポックの現在のETAは約20分です。

00:03:32.000 --> 00:03:39.000
先ほど導入したTensorFlowメタルプラグインをインストールして、現在のネットワークにスピードアップを追加できるかどうかを確認します。

00:03:39.000 --> 00:03:49.000
これを行うには、pip install tensorflow-metalを使用します。

00:03:49.000 --> 00:03:54.000
以前使用したのと同じResNet50モデルに戻ります。

00:03:54.000 --> 00:03:58.000
今回だけ、新しいGPUデバイスが登録されていることがわかります。

00:03:58.000 --> 00:04:06.000
これは、Metal Pluginを使用してTensorFlowプラットフォームの一部として導入したGPUデバイスです。

00:04:06.000 --> 00:04:11.000
すべてのコールバックとネットワーク定義は変更されません。

00:04:11.000 --> 00:04:15.000
ETAを比較できるように、再びネットワークを開始します。

00:04:15.000 --> 00:04:24.000
同じネットワークのGPUバージョンは、TensorFlow Metal Pluginを使用して約4倍速くトレーニングされていることがわかります。

00:04:24.000 --> 00:04:27.000
では、他のネットワークを詳しく見てみましょう。

00:04:27.000 --> 00:04:33.000
ここでは、CPUに対する主要な機械学習トレーニングベンチマークのパフォーマンスを示します。

00:04:33.000 --> 00:04:42.000
ご覧のとおり、すべてのベンチマークで優れたスピードアップがあり、M1 MacBook Proでは最大8倍高速です。

00:04:42.000 --> 00:04:46.000
TensorFlow用の新しいメタルプラグインのインストールは簡単です。

00:04:46.000 --> 00:04:55.000
Pip install tensorflow-macosを使用してベースTensorFlowをインストールした後、pip install tensorflow-metalを使用してMetal Pluginをインストールできます。

00:04:55.000 --> 00:05:00.000
メタルプラグインは、公式のPythonパッケージリポジトリ、pypi.orgで利用可能になります。

00:05:00.000 --> 00:05:06.000
環境のセットアップとインストールの詳細については、Metal Developer Resourceを参照してください。

00:05:06.000 --> 00:05:08.000
TensorFlowはそれだけです。

00:05:08.000 --> 00:05:13.000
次に、Core MLの推論アクセラレーションについて話しましょう。

00:05:13.000 --> 00:05:16.000
Core MLは、Appleの機械学習推論フレームワークです。

00:05:16.000 --> 00:05:23.000
また、MPSGraphを使用したCore MLのパフォーマンスが大幅に向上しました。

00:05:23.000 --> 00:05:28.000
ここでは、M1上の機械学習ネットワークの主要なクラスの推論のスピードアップを示します。

00:05:28.000 --> 00:05:35.000
NLPアプリケーションに使用される正規のトランスネットワークであるBERTで2倍のスピードアップを取得します。

00:05:35.000 --> 00:05:43.000
コンピュータビジョンアプリケーションの中心であるResNet50は、以前のリリースでテクスチャパスに合わせて調整されています。

00:05:43.000 --> 00:05:51.000
これは、MPSGraphを介した新しいバッファバックエンドによる16%の追加パフォーマンス改善です。

00:05:51.000 --> 00:05:59.000
Core MLとTensorFlowのこれらのパフォーマンスの向上は、Convolution2DのようなMPSプリミティブのパフォーマンスの向上によるものです。

00:05:59.000 --> 00:06:10.000
ここでは、それぞれトレーニングと推論に使用されるNHWCとNCHWのデータレイアウトでConvolution2Dのスピードアップを示します。

00:06:10.000 --> 00:06:13.000
推論とトレーニングの改善はそれだけです。

00:06:13.000 --> 00:06:18.000
次に、Saharshに戻って、MPSGraphの新しい操作について詳しく学びましょう。

00:06:18.000 --> 00:06:20.000
ありがとう、ユリヤ。

00:06:20.000 --> 00:06:25.000
次に、MPSGraphでサポートされている新しい一連の操作を見ていきます。

00:06:25.000 --> 00:06:36.000
畳み込みと削減の複数のバリアントから、計算グラフに必要なすべての基本的な数学操作まで、MPSGraphの多数の操作をサポートしています。

00:06:36.000 --> 00:06:42.000
今年は、MPSGraphでさらに多くのことができるよう、特別な操作を追加しました。

00:06:42.000 --> 00:06:50.000
制御依存関係、ステンシル演算子、収集演算子の3つの新しいプリミティブを紹介します。

00:06:50.000 --> 00:06:53.000
まず、制御依存性を見ていきます。

00:06:53.000 --> 00:06:58.000
グラフ内の操作を明示的に順序設定するには、制御依存関係が必要です。

00:06:58.000 --> 00:07:02.000
これを理解するために、グラフ操作を正式に定義しましょう。

00:07:02.000 --> 00:07:20.000
グラフ内の操作は、3種類のエッジを介して互いに接続します。入力テンソルは、どのテンソルがopへのデータ入力として機能するかを表す、出力テンソルは、op自体によって作成され、最後に、制御依存関係と呼ばれる特別な種類のエッジです。

00:07:20.000 --> 00:07:26.000
現在の操作自体がそれに依存していなくても、現在の操作の前に実行する必要があります。

00:07:26.000 --> 00:07:33.000
このAPIは、MPSGraphによって操作が最適化されるのを防ぐ便利な方法も提供します。

00:07:33.000 --> 00:07:38.000
これは、バッチ正規化のような機械学習レイヤーを実装するために必要です。

00:07:38.000 --> 00:07:41.000
これを実際に見てみましょう。

00:07:41.000 --> 00:07:48.000
バッチ正規化は、ネットワークをより安定させ、より速く収束させるためにMLトレーニングで使用される標準層です。

00:07:48.000 --> 00:07:52.000
ここでは、トレーニングに使用されるバッチ正規化の計算グラフを参照してください。

00:07:52.000 --> 00:07:56.000
最初のステップは、平均と分散を計算することです。

00:07:56.000 --> 00:08:02.000
これらは、推論に必要な実行平均と実行分散を更新するために使用されます。 推論に必要です。

00:08:02.000 --> 00:08:10.000
ただし、トレーニンググラフの結果はこれらの変数を必要としないため、MPSGraphはそれらを最適化する可能性があります。

00:08:10.000 --> 00:08:18.000
制御依存関係を使用して、最終的な正規化演算子の前にそれらを明示的に順序付けすることで、これを解決できます。

00:08:18.000 --> 00:08:23.000
このAPIの使用方法を示すコードを含む簡単な例を見てみましょう。

00:08:23.000 --> 00:08:26.000
このグラフは指数を示し、演算子を割り当てます。

00:08:26.000 --> 00:08:30.000
割り当て演算子は、グラフ内の他の誰によっても使用されません。

00:08:30.000 --> 00:08:32.000
だから、それは離れて最適化されるかもしれません。

00:08:32.000 --> 00:08:37.000
これを解決する1つの方法は、割り当てをtargetOperationとして明示的に設定することです。

00:08:37.000 --> 00:08:43.000
ただし、これにより、開発者はグラフ全体で依存関係をグローバルに追跡する必要があります。

00:08:43.000 --> 00:08:51.000
代わりに、新しい制御依存関係APIを使用すると、指数操作を割り当てに依存させることができます。

00:08:51.000 --> 00:08:58.000
これにより、targetOperationを持つ必要がなくなり、グラフが最適化されないことが保証されます。

00:08:58.000 --> 00:09:01.000
次に、これをコードで見ます。

00:09:01.000 --> 00:09:06.000
まず、指数が依存している演算子を定義します。

00:09:06.000 --> 00:09:11.000
次に、指数演算子を定義する依存ブロックを作成します。

00:09:11.000 --> 00:09:15.000
最後に、このグラフで実行APIを呼び出します。

00:09:15.000 --> 00:09:19.000
targetOperationsをグローバルに追跡する必要はないことに注意してください。

00:09:19.000 --> 00:09:21.000
制御依存性については、それだけです。

00:09:21.000 --> 00:09:25.000
では、ステンシル演算子について話しましょう。

00:09:25.000 --> 00:09:31.000
ステンシル操作は、画像畳み込みのようなスライドウィンドウ演算子の一般化です。

00:09:31.000 --> 00:09:38.000
これらの演算子は、有限要素法、機械学習、および画像処理アプリケーションに不可欠です。

00:09:38.000 --> 00:09:44.000
ここでは、ラプラシアン操作を実装するために一般的に使用される5点の2Dステンシルが見られます。

00:09:44.000 --> 00:09:52.000
ここに示されているステンシル演算子は、この7点式3Dステンシル図に示すように、より高い次元にも適用できます。

00:09:52.000 --> 00:09:55.000
オペレーターを詳しく見てみましょう。

00:09:55.000 --> 00:10:02.000
出力値ごとに、図に示すように、入力テンソルのステンシルウィンドウに対して加重削減を計算します。

00:10:02.000 --> 00:10:11.000
オペレータは、argmin/argmaxを含むさまざまなリダクションモードと、反射やclampToZeroを含むさまざまなパディングモードをサポートしています。

00:10:11.000 --> 00:10:17.000
MPSGraphは、最適なパフォーマンスのためにMPSカーネル間のステッチを可能にします。

00:10:17.000 --> 00:10:25.000
ステッチサポートにより、ステンシル演算子を使用すると、単一のカーネル起動で複雑な数学的操作を表現できます。

00:10:25.000 --> 00:10:28.000
そのような例を1つ見てみましょう。

00:10:28.000 --> 00:10:34.000
ローカル応答の正規化は、チャネル次元で正規化するために使用されるpytorch opです。

00:10:34.000 --> 00:10:38.000
新しいステンシル操作でこれを実装するのは非常に簡単です。

00:10:38.000 --> 00:10:42.000
ここでは、この正規化手法のグラフを参照してください。

00:10:42.000 --> 00:10:46.000
ステンシル操作の周りの単なる要素賢明な操作であることがわかります。

00:10:46.000 --> 00:10:50.000
新しい操作がなければ、複数のディスパッチが必要になります。

00:10:50.000 --> 00:10:57.000
現在、ステンシル操作はステッチをサポートしているため、このグラフ全体を1回のディスパッチで起動できます。

00:10:57.000 --> 00:11:00.000
ステンシルオペレーターはそれでおそれです。

00:11:00.000 --> 00:11:05.000
次に、収集操作の改善を見てみましょう。 収集操作の改善を見てみましょう。

00:11:05.000 --> 00:11:09.000
今年は、新しい収集操作がMPSGraphに追加されました。

00:11:09.000 --> 00:11:16.000
これらは、非連続したメモリの場所に任意のサイズのスライスを効率的にコピーすることを可能にします。

00:11:16.000 --> 00:11:22.000
概念的には、メモリの塊から青でマークされた場所から値を集めています。

00:11:22.000 --> 00:11:29.000
これらの収集レイヤーは、埋め込みルックアップと動的マトリックスコピーの効率的な実装を可能にします。

00:11:29.000 --> 00:11:32.000
GatherNDは、収集操作の強力な拡張です。

00:11:32.000 --> 00:11:40.000
通常の収集は線形インデックスをサポートしていますが、gatherND操作はN次元インデックスを可能にします。

00:11:40.000 --> 00:11:45.000
これにより、N次元入力のどこからでもデータをシームレスにコピーできます。

00:11:45.000 --> 00:11:53.000
この操作への入力は座標のベクトルであり、各座標は入力テンソルのランクまですることができます。

00:11:53.000 --> 00:11:59.000
座標で指定されていない寸法は、スライスコピーになります。

00:11:59.000 --> 00:12:04.000
3Dテンソルからの行スライスの収集の例をステップスルーすることができます。

00:12:04.000 --> 00:12:12.000
この例では、インデックスは行列座標と行座標に対応する2つの座標を指定します。

00:12:12.000 --> 00:12:18.000
列インデックスへの3番目の座標がないため、このgatherNDは行全体をコピーします。

00:12:18.000 --> 00:12:24.000
結果テンソルは、入力行列から収集された行の2次元行列です。

00:12:24.000 --> 00:12:29.000
GatherNDは、ほぼすべての形態の収集操作を代表し、優れたパフォーマンスを発揮することができます。

00:12:29.000 --> 00:12:36.000
たとえば、収集操作を使用して埋め込みルックアップを実装する方法を見てみましょう。

00:12:36.000 --> 00:12:43.000
埋め込みルックアップは、提供された入力オブジェクトのセットの埋め込みベクトルを見つけるために使用される一般的な操作です。

00:12:43.000 --> 00:12:54.000
一般的に、このレイヤーは言語処理ネットワークで使用され、語彙の各単語を埋め込みベクトルに関連付ける埋め込み行列が生成されます。

00:12:54.000 --> 00:13:03.000
語彙内の単語のIDは、収集操作のインデックスとして使用でき、埋め込み行列は入力テンソルです。

00:13:03.000 --> 00:13:10.000
各単語IDに対応する行を取得したいのですが、これはギャザーレイヤーを使用して簡単に行うことができます。

00:13:10.000 --> 00:13:16.000
座標を1つだけ指定するので、入力単語ごとに行全体がコピーされます。

00:13:16.000 --> 00:13:23.000
結果のテンソルは、行に沿った各入力ワードの埋め込みベクトルの2D行列です。

00:13:23.000 --> 00:13:27.000
今年導入した新しいMPSGraph操作については、これでおそれです。

00:13:27.000 --> 00:13:30.000
では、コンパイルAPIについて話しましょう。

00:13:30.000 --> 00:13:35.000
今年は、新しいMPSGraphExecutable APIを導入します。

00:13:35.000 --> 00:13:39.000
このコンパイルAPIは、2つの方法でパフォーマンスを向上させます。

00:13:39.000 --> 00:13:44.000
まず、開発者がいつグラフをコンパイルするかを制御できます。

00:13:44.000 --> 00:13:50.000
第二に、遅延型推論によってコンパイル呼び出しの数を減らすことができます。

00:13:50.000 --> 00:13:53.000
では、それぞれを詳しく見てみましょう。

00:13:53.000 --> 00:14:00.000
昨年、MPSGraphを定義して実行するための本当に便利なAPIを提供しました。

00:14:00.000 --> 00:14:09.000
内部では、評価が初めて要求されたとき、MPSGraphは入力タイプのコンパイルを呼び出し、内部で実行可能ファイルを作成しました。

00:14:09.000 --> 00:14:18.000
その後の実行では、MPSGraphはこの実行可能ファイルをシームレスにキャッシュして、コンパイルコストが再び支払われないようにしました。

00:14:18.000 --> 00:14:25.000
ユーザーは事前にコンパイルを呼び出すことができるようになったので、コンパイルのタイムラインを選択できます。

00:14:25.000 --> 00:14:31.000
コンパイルされた実行可能ファイルを使用すると、MPSGraphExecutableで直接runを呼び出すことができます。

00:14:31.000 --> 00:14:39.000
これにより、グラフがコンパイルされたときにユーザーが制御でき、コンパイルされた実行可能ファイルをキャッシュできるため、さらに多くのパフォーマンスを得ることができます。

00:14:39.000 --> 00:14:42.000
これをコードで見てみましょう。

00:14:42.000 --> 00:14:45.000
ここには、2つのテンソルを追加するための簡単なグラフがあります。

00:14:45.000 --> 00:14:51.000
コンパイルするには、操作とともにフィードとターゲットテンソルの型を提供します。

00:14:51.000 --> 00:14:55.000
私たちが得るのは、コンパイルされたグラフと実行可能ファイルです。

00:14:55.000 --> 00:14:58.000
そして、評価方法も同じように簡単です。

00:14:58.000 --> 00:15:02.000
メタルコマンドキューと入力テンソルデータを提供します。

00:15:02.000 --> 00:15:05.000
したがって、これらはMPSグラフのコンパイルの基本です。

00:15:05.000 --> 00:15:11.000
次に、遅延型推論によるコンパイル呼び出しの数を減らす方法について話しましょう。

00:15:11.000 --> 00:15:19.000
型推論は、MPSGraphがユーザーによって指定されていないテンソル形状を決定する必要があるコンパイルパスです。

00:15:19.000 --> 00:15:25.000
このグラフでは、2つの2次元テンソルの行列乗算を実行しています。

00:15:25.000 --> 00:15:27.000
入力テンソルの形状が表示されます。

00:15:27.000 --> 00:15:32.000
しかし、出力テンソルは未知の形状です。

00:15:32.000 --> 00:15:39.000
型推論パスが完了すると、入力と操作タイプに基づいて出力テンソル形状が決定されます。

00:15:39.000 --> 00:15:45.000
標準ニューラルネットワークでは、ネットワークへの入力が常に同じサイズであるとは限りません。

00:15:45.000 --> 00:15:51.000
自然言語処理の場合、文章やシーケンスは長さが異なる場合があります。

00:15:51.000 --> 00:15:56.000
CNNでは、異なるサイズの画像が評価されるのが見られます。

00:15:56.000 --> 00:16:05.000
今年のコンパイルアップグレードの前に、新しいサイズの画像ごとに、グラフ全体の型推論を行うためにコンパイルが呼び出されます。

00:16:05.000 --> 00:16:13.000
コンパイルを制御できるようになったので、開発者は、型推論パスをオフにしてコンパイルを呼び出すことができます。

00:16:13.000 --> 00:16:21.000
これにより、各反復で数十秒または数百秒のコンパイル時間を節約し、最高のパフォーマンスを得ることができます。

00:16:21.000 --> 00:16:28.000
MPSGraphランタイムは、エンコード中にちょうど間に合うようにタイプを推測し、シームレスに物事を機能させます。

00:16:28.000 --> 00:16:34.000
これは、コンパイル時間の節約と最適なグラフの取得のトレードオフです。

00:16:34.000 --> 00:16:39.000
以前に共有したコード例でこれをどのように使用できるか見てみましょう。

00:16:39.000 --> 00:16:45.000
タイプ推論パスを無効にすることは、図のようにコンパイル記述子を設定することで実現できます。

00:16:45.000 --> 00:16:48.000
コンパイルAPIはそれだけです。

00:16:48.000 --> 00:16:53.000
最後に、MPSGraphの新しいコントロールフローAPIについて話しましょう。

00:16:53.000 --> 00:17:00.000
これらのAPIを使用すると、以前にグラフで評価されたテンソルに基づいて操作を動的にディスパッチできます。

00:17:00.000 --> 00:17:07.000
これは、バッチ正規化やリカレントニューラルネットワークなどのアプリケーションで一般的です。

00:17:07.000 --> 00:17:14.000
新しいAPIなしで、今日MPSGraphで「whileループ」を実装する方法を見てみましょう。

00:17:14.000 --> 00:17:19.000
まず、述語を計算するグラフを作成します。

00:17:19.000 --> 00:17:25.000
次に、プレディケートは明示的なメモリ同期を通じてCPU上で評価されます。

00:17:25.000 --> 00:17:32.000
述語がtrueの場合、以前に作成されたグラフは新しい入力で再実行されます。

00:17:32.000 --> 00:17:41.000
それ以外の場合、述語がfalseの場合、ループは終了し、2番目のMPSGraphが作成され、結果を消費するために実行されます。

00:17:41.000 --> 00:17:48.000
新しい制御フローAPIを使用すると、これらすべてのステップを単一のMPSGraph実行の一部として起動できます。

00:17:48.000 --> 00:17:55.000
これは、明示的なメモリ同期プリミティブを導入する必要がないため、実装する方が便利です。

00:17:55.000 --> 00:17:59.000
それでは、これがどのように潜在的により効率的になるかを見てみましょう。

00:17:59.000 --> 00:18:04.000
ここでは、新しいAPIなしで制御フローのタイムラインを見ることができます。

00:18:04.000 --> 00:18:07.000
CPU上の最初のカーネルをエンコードします。

00:18:07.000 --> 00:18:13.000
カーネルが完了したら、結果を読み取るためにメモリを同期する必要があります。

00:18:13.000 --> 00:18:19.000
CPUはGPUの実行が完了するのを待たなければならないため、これは潜在的に非効率的です。

00:18:19.000 --> 00:18:26.000
同様に、GPUはCPUの同期とその後のエンコーディングが完了するのを待つ必要があります。

00:18:26.000 --> 00:18:29.000
これは各反復で起こります。

00:18:29.000 --> 00:18:33.000
それでは、新しいMPSGraph APIを使用する利点を見てみましょう。

00:18:33.000 --> 00:18:37.000
CPUエンコードコールを1つだけ実行する必要があります。

00:18:37.000 --> 00:18:46.000
述語はGPUタイムラインで評価されるため、同期オーバーヘッドは発生せず、カーネルはバブルなしで起動できます。

00:18:46.000 --> 00:18:52.000
では、新しいAPIが何であるかを見てみましょう。

00:18:52.000 --> 00:18:59.000
If/else、for loops、while loopsの3つの新しい制御フローAPIを追加しました。

00:18:59.000 --> 00:19:02.000
If/elseプリミティブから始めましょう。

00:19:02.000 --> 00:19:04.000
私たちは皆、これに精通しています。

00:19:04.000 --> 00:19:08.000
述語に基づいて、異なるコードパスが実行されます。

00:19:08.000 --> 00:19:14.000
「If」と「else」条件のコードブロックとともに、ブール述語が提供されます。

00:19:14.000 --> 00:19:18.000
この述語がtrueの場合、コードのthenブロックを実行します。

00:19:18.000 --> 00:19:23.000
そうでなければ、falseの場合、elseブランチが実行されます。

00:19:23.000 --> 00:19:28.000
If/else操作は、ニューラルネットワークで非常に便利です。

00:19:28.000 --> 00:19:35.000
1つの正規の用途はバッチ正規化操作であり、トレーニングと推論の動作が異なります。

00:19:35.000 --> 00:19:42.000
isTraining Booleanを使用すると、ノーマライザーの両方のバリアントを表す単一のグラフを持つことができます。

00:19:42.000 --> 00:19:45.000
コードでif/elseブランチを設定する方法を見てみましょう。

00:19:45.000 --> 00:19:50.000
2つの入力スカラーテンソルの非常に簡単な例を見てみましょう。

00:19:50.000 --> 00:19:55.000
最初のテンソルが2番目のテンソルよりも小さい場合は、操作の合計を返します。

00:19:55.000 --> 00:19:58.000
そうでなければ、私たちは差額を返します。

00:19:58.000 --> 00:20:03.000
まず、述語を計算し、それをAPIに渡します。

00:20:03.000 --> 00:20:09.000
次に、述語が真の場合、thenブロックを計算し、テンソルを追加します。

00:20:09.000 --> 00:20:15.000
最後に、述語がfalseの場合、elseブロックを計算し、テンソルを減算します。

00:20:15.000 --> 00:20:19.000
次に、forループを実装する方法を見てみましょう。

00:20:19.000 --> 00:20:24.000
Forループは、一連の操作を一定回数にわたってループします。

00:20:24.000 --> 00:20:31.000
これは、トレーニング中に異なる長さのシーケンスをループしなければならないリカレントニューラルネットワークで一般的です。

00:20:31.000 --> 00:20:34.000
forループのnumberOfIterationsを提供する必要があります。

00:20:34.000 --> 00:20:42.000
インデックスは0に初期化され、各ループ反復のnumberOfIterationsと比較されます。

00:20:42.000 --> 00:20:50.000
numberOfIterationsより小さい場合は、forループの本体を実行し、インデックスを1増やします。

00:20:50.000 --> 00:20:55.000
インデックスがnumberOfIterations以上の場合、ループを終了します。

00:20:55.000 --> 00:20:58.000
これをコードで実装する方法を見てみましょう。

00:20:58.000 --> 00:21:02.000
本当に簡単な例を実装したかったとしましょう。

00:21:02.000 --> 00:21:06.000
結果変数を何らかの入力値に初期化します。

00:21:06.000 --> 00:21:13.000
次に、4回ループし、毎回結果に別の入力値を掛けます。

00:21:13.000 --> 00:21:15.000
まず、2つのグラフテンソルを作成します。

00:21:15.000 --> 00:21:19.000
出力テンソルはinput0に初期化されます。

00:21:19.000 --> 00:21:24.000
各反復では、このテンソルに入力1が乗算されます。

00:21:24.000 --> 00:21:33.000
次に、index 0からindex 3までループを4回実行できるように、numberOfIterationsを4に設定します。

00:21:33.000 --> 00:21:35.000
次に、forループの本体を作成します。

00:21:35.000 --> 00:21:40.000
これは、単一の反復を表すクロージャを作成することによって行われます。

00:21:40.000 --> 00:21:47.000
各反復には、現在の反復のインデックスと、以前の反復の出力が渡されます。

00:21:47.000 --> 00:21:52.000
次に、結果を更新して返して、次のイテレーションに渡します。

00:21:52.000 --> 00:21:57.000
最後に、これらの引数をすべてグラフ内のforループAPIに渡します。

00:21:57.000 --> 00:22:04.000
Body の iterationArguments は input0 テンソルに初期化されることに注意してください。

00:22:04.000 --> 00:22:06.000
ループはそれだけです。

00:22:06.000 --> 00:22:09.000
では、whileループAPIを見てみましょう。

00:22:09.000 --> 00:22:14.000
このプリミティブは、条件が満たされている間に一連の操作を実行します。

00:22:14.000 --> 00:22:18.000
このAPIを使用するには、2つのコードブロックを提供する必要があります。

00:22:18.000 --> 00:22:22.000
最初のブロックでは、条件は述語でチェックされます。

00:22:22.000 --> 00:22:27.000
述語がtrueの場合、afterブロックのwhileループの本体が実行されます。

00:22:27.000 --> 00:22:30.000
これは述語を再計算します。

00:22:30.000 --> 00:22:36.000
MPSGraphは、beforeブロックの次の反復でこの述語を使用します。

00:22:36.000 --> 00:22:40.000
評価された条件がfalseの場合、ループを終了します。

00:22:40.000 --> 00:22:48.000
APIでは、本文と条件の評価コードブロックを交換することで、do-whileループを実装することもできます。

00:22:48.000 --> 00:22:51.000
本当に簡単な例を実装したかったとしましょう。

00:22:51.000 --> 00:22:55.000
結果変数を何らかの入力値に初期化します。

00:22:55.000 --> 00:23:01.000
次に、しきい値を超えるまで、ループで毎回結果に乗数を掛けます。

00:23:01.000 --> 00:23:08.000
まず、前回の反復の結果を使用して述語を評価するコードブロックを定義します。

00:23:08.000 --> 00:23:13.000
また、前回の反復の結果をreturnTensors NSArrayに保存します。

00:23:13.000 --> 00:23:22.000
この配列は、述語がtrueの場合に次の反復への入力として使用され、述語がfalseの場合は最終結果として使用されます。

00:23:22.000 --> 00:23:27.000
次に、テンソルが乗算されるwhileループの本体を定義します。

00:23:27.000 --> 00:23:31.000
製品は、条件ブロックを読み取るために返されます。

00:23:31.000 --> 00:23:36.000
最後に、図に示すように、これらすべての引数をwhileループAPIに渡します。

00:23:36.000 --> 00:23:43.000
initialInputs引数は、beforeブロックの最初の反復で使用されることに注意してください。

00:23:43.000 --> 00:23:45.000
ループの間はそれだけです。

00:23:45.000 --> 00:23:48.000
次に、これを実際のアプリケーションでどのように使用できるかを見ていきます。

00:23:48.000 --> 00:23:52.000
画像合成は、一般的な画像編集ユーティリティです。

00:23:52.000 --> 00:23:56.000
ここでは、オブジェクトがターゲット画像に埋め込まれます。

00:23:56.000 --> 00:24:00.000
図に示すように、ソース画像と背景画像から始めます。

00:24:00.000 --> 00:24:03.000
次に、ソース画像にマスクを作成します。

00:24:03.000 --> 00:24:08.000
ソース画像のこのマスクを背景に直接配置しましょう。

00:24:08.000 --> 00:24:13.000
ソース画像の端がはっきりと見えるので、それは見栄えがよくありません。

00:24:13.000 --> 00:24:17.000
画像構成を通じて、これらのエッジを滑らかにしたい。

00:24:17.000 --> 00:24:23.000
ラプラシアンエッジフィルターと反復線形ソルバーをペアリングすることは、これを達成するための一般的な方法です。

00:24:23.000 --> 00:24:25.000
では、詳細を見てみましょう。

00:24:25.000 --> 00:24:30.000
ここでは、MPSGraphで画像合成を実行するために必要なパイプラインを確認します。

00:24:30.000 --> 00:24:38.000
入力テンソル、背景画像、ソース画像、およびオブジェクトのマスクから始めます。

00:24:38.000 --> 00:24:44.000
次に、ラプラシアンエッジ検出器と組み合わせた反復線形ソルバーを使用します。

00:24:44.000 --> 00:24:49.000
この一連の操作の出力は、滑らかなエッジを持つ複合画像です。

00:24:49.000 --> 00:24:53.000
ラプラシアンエッジフィルターを見てみましょう。 

00:24:53.000 --> 00:25:00.000
ラプラシアンエッジフィルターの実装には、一連の重みを持つソース画像のウィンドウ化された縮小が含まれます。

00:25:00.000 --> 00:25:04.000
ステンシル演算子は、図のようにこれを実装するために使用されます。

00:25:04.000 --> 00:25:08.000
この演算子を使用すると、ソースオブジェクトのエッジを見ることができます。

00:25:08.000 --> 00:25:13.000
ここで計算されたエッジは、線形ソルバーへの入力として使用されます。

00:25:13.000 --> 00:25:17.000
次に、線形ソルバーを見てみましょう。 

00:25:17.000 --> 00:25:22.000
背景画像から始めて、それを線形ソルバーにフィードします。

00:25:22.000 --> 00:25:27.000
ソルバーはこの画像を更新し、結果はその後読み戻されます。

00:25:27.000 --> 00:25:31.000
ご覧のとおり、これは反復的なプロセスです。

00:25:31.000 --> 00:25:38.000
反復が進むにつれて、エッジで完璧なブレンドに到達するまで、ソリューションイメージが改善されます。

00:25:38.000 --> 00:25:42.000
ループは、エラーがユーザー定義の許容範囲を下回ると終了します。

00:25:42.000 --> 00:25:44.000
これにはwhileループが必要です。

00:25:44.000 --> 00:25:48.000
MPSGraph Control Flow APIを使用してこれを実装できるようになりました。

00:25:48.000 --> 00:25:51.000
では、デモを見てみましょう。

00:25:51.000 --> 00:25:58.000
MPSGraphをiPad Proアプリケーションとして使用した画像合成ユーティリティを実装しました。

00:25:58.000 --> 00:26:02.000
上部のソース画像と下のターゲット画像から始めます。

00:26:02.000 --> 00:26:06.000
ソースからターゲットにオブジェクトを複製します。

00:26:06.000 --> 00:26:11.000
私たちが最初にする必要があるのは、移動したい牛の周りにマスクを描くことです。

00:26:11.000 --> 00:26:15.000
これがナイーブなクローンでどのように見えるか見てみましょう。

00:26:15.000 --> 00:26:18.000
粗いエッジが見えるので、それはあまり良く見えません。

00:26:18.000 --> 00:26:22.000
では、先ほど説明した画像合成テクニックを試してみましょう。

00:26:22.000 --> 00:26:26.000
まず、背景画像に初期ソリューションを設定することから始めます。

00:26:26.000 --> 00:26:31.000
これを約50回の反復で実行しましょう。

00:26:31.000 --> 00:26:34.000
明らかに、ソリューションイメージはまだ収束していません。

00:26:34.000 --> 00:26:39.000
さらに約50回の反復で実行しましょう。

00:26:39.000 --> 00:26:42.000
エッジが滑らかになるにつれて、これはより自然に見えます。

00:26:42.000 --> 00:26:48.000
MPSGraphでのプログラミングの容易さにより、さまざまなテクニックの実験が簡単になります。

00:26:48.000 --> 00:26:53.000
背景画像の代わりにクローン画像でソルバーを初期化すると、収束が速くなります。

00:26:53.000 --> 00:26:58.000
このスイッチを切り替えることで、この初期化モードを有効にすることができます。

00:26:58.000 --> 00:27:04.000
反復カウントを50に再度設定し、ナイーブクローンにリセットすることで、これを実際に見てみましょう。

00:27:04.000 --> 00:27:07.000
では、ソルバーを再実行しましょう。

00:27:07.000 --> 00:27:11.000
50回の反復後にソリューション画像がかなり良く見えるのを見ることができます。

00:27:11.000 --> 00:27:16.000
すでにソースオブジェクトから始めているので、エッジでの出血も少なくなっています。

00:27:16.000 --> 00:27:17.000
これは素晴らしいです。

00:27:17.000 --> 00:27:21.000
しかし、私たちが本当に望んでいることは、エラー許容度に基づいて収束を自動化することです。

00:27:21.000 --> 00:27:26.000
これには、このスイッチを使用して有効にするwhileループが必要です。

00:27:26.000 --> 00:27:30.000
私たちは新しいMPSGraph APIでこれを実装しました。

00:27:30.000 --> 00:27:33.000
誤差許容差はこのスライダーで制御できます。

00:27:33.000 --> 00:27:35.000
図に示すように、0.1に設定しました。

00:27:35.000 --> 00:27:37.000
これをナイーブなクローンにリセットしましょう。

00:27:37.000 --> 00:27:40.000
今、ソルバーを開始します。

00:27:40.000 --> 00:27:48.000
このwhileループでは、反復回数を指定することなく、約80回の反復でソリューションイメージに収束します。

00:27:48.000 --> 00:27:52.000
では、この背景に他の動物をクローニングして楽しみましょう。

00:27:52.000 --> 00:27:56.000
このかわいい子犬を試してみましょう。

00:27:56.000 --> 00:27:58.000
よし、追跡は終わった。

00:27:58.000 --> 00:28:03.000
この画像の右下が似合うと思います。

00:28:03.000 --> 00:28:07.000
たぶん、私たちは次に鳥を試すことができます。

00:28:07.000 --> 00:28:11.000
これは背景の右上に似合うでしょう。

00:28:11.000 --> 00:28:14.000
これらすべての画像を含む新しい背景はかなりきれいに見えます。

00:28:14.000 --> 00:28:17.000
デモはそれだけです。

00:28:17.000 --> 00:28:25.000
要約すると、MPSGraphの採用がどのようにCoreMLとTensorFlowの驚くべきパフォーマンス向上につながったかを示しました。

00:28:25.000 --> 00:28:29.000
推論は現在、最大2倍の速さです。

00:28:29.000 --> 00:28:37.000
幅広いアプリケーションを可能にするステンシル演算子を含む、便利な新しい計算プリミティブを導入しました。

00:28:37.000 --> 00:28:41.000
MPSGraphが提供する新しいコンパイルの柔軟性を示しました。

00:28:41.000 --> 00:28:45.000
これにより、推論ネットワークからのレイテンシが削減されます。

00:28:45.000 --> 00:28:50.000
そして最後に、MPSGraphのすべての新しい制御フロー機能を示しました。

00:28:50.000 --> 00:28:58.000
このAPIは、機械学習ネットワークに加えて、いくつかの線形代数アプリケーションを表現するための鍵です。

00:28:58.000 --> 00:29:02.000
私たちは、あなたがこれらの機能をどのように活用するかを見て興奮しています。

00:29:02.000 --> 00:29:06.000
ありがとう、そして素晴らしいWWDC 2021をお過ごしください。

00:29:06.000 --> 23:59:59.000
[明るい音楽]。

