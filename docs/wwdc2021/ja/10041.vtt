WEBVTT

00:00:02.000 --> 00:00:12.000
こんにちは、WWDCへようこそ。

00:00:12.000 --> 00:00:16.000
私の名前はフランク・ドゥープケで、ビジョンチームのエンジニアです。

00:00:16.000 --> 00:00:20.000
ビジョンフレームワークは、画像分析に重点を置いて、長年にわたって成長してきました。

00:00:20.000 --> 00:00:26.000
よりよく把握するために、使用の焦点の観点からビジョンの能力を見ることができます。

00:00:26.000 --> 00:00:27.000
スポーツ。

00:00:27.000 --> 00:00:36.000
オブジェクトの追跡と人間のポーズの分析は、スポーツアプリケーションを作成するのに役立つリクエストのほんの一部です。

00:00:36.000 --> 00:00:38.000
アクセシビリティ。

00:00:38.000 --> 00:00:46.000
OCRや画像分類や物体検出などのビジョン要求は、視覚障害のあるユーザーを支援しています。

00:00:46.000 --> 00:00:47.000
人々。

00:00:47.000 --> 00:00:52.000
ビジョンは、アプリが使用できる多くの顔と体関連のリクエストを提供します。

00:00:52.000 --> 00:01:00.000
これについては、「ビジョンを使用して人、顔、ポーズを検出する」セッションで詳しく知ることができます。

00:01:00.000 --> 00:01:01.000
健康。

00:01:01.000 --> 00:01:11.000
バーコードスキャンやOCRから人間のポーズの分析まで、ビジョンはスマートな健康アプリケーションを作成するためのビルディングブロックを提供します。

00:01:11.000 --> 00:01:13.000
計算写真。

00:01:13.000 --> 00:01:19.000
ポートレートモードのような機能は、顔検出とセグメンテーションに依存しています。

00:01:19.000 --> 00:01:21.000
セキュリティ。

00:01:21.000 --> 00:01:29.000
顔や人間の検出などのリクエストは、防犯カメラの動き検出などのアプリケーションに役立ちます。

00:01:29.000 --> 00:01:31.000
そして書類。

00:01:31.000 --> 00:01:36.000
これがこのセッションで焦点を当てたいことです。

00:01:36.000 --> 00:01:55.000
ビジョンは、バーコード検出、テキスト認識、または一般的に知られているOCR、輪郭検出、長方形検出、および今年の新しいドキュメントセグメンテーション検出など、ドキュメントの分析に役立つ多くのリクエストを提供しています。

00:01:55.000 --> 00:01:56.000
これが私たちの議題です。

00:01:56.000 --> 00:01:59.000
まず、バーコード検出について話します。

00:01:59.000 --> 00:02:01.000
次に、テキスト認識について話します。

00:02:01.000 --> 00:02:04.000
そして最後に、文書の検出について話します。

00:02:04.000 --> 00:02:07.000
バーコード検出を見てみましょう。

00:02:07.000 --> 00:02:12.000
今年は、バーコード検出要求の新しい改訂版を導入します。

00:02:12.000 --> 00:02:18.000
VNDetectBarcodesRequestRevision2は、新しいシンボルをサポートしています。

00:02:18.000 --> 00:02:40.000
Codabar、GS1Databarには、Expanded and Limited、MicroPDF、MicroQRが含まれています。後者は、URLのQRコードを作成し、スペースが少なくて済むため、小さなラベルやパッケージに配置する必要がある場合に特に役立ちます。

00:02:40.000 --> 00:02:55.000
この新しいリビジョンの動作を、クライアントが指定した関心のある領域に関連して、結果のバウンディングボックスがどのように報告されるかに関して、ビジョンの残りの部分に沿った動作を変更しました。

00:02:55.000 --> 00:02:58.000
その変化を詳しく見てみましょう。

00:02:58.000 --> 00:03:01.000
ここには、QRコード付きの文書があります。

00:03:01.000 --> 00:03:10.000
ROIとも呼ばれる関心のある領域を指定しない場合、境界ボックスは完全な画像に関連して報告されます。

00:03:10.000 --> 00:03:17.000
さて、カメラが見ているものの中央部分だけに焦点を当てたいように、ROIを指定しましょう。

00:03:17.000 --> 00:03:25.000
リビジョン2は、他のビジョンリクエストと同様に、ROIに関連してバウンディングボックスを報告するようになりました。

00:03:25.000 --> 00:03:29.000
残念ながら、リビジョン1は常に完全な画像に関連して報告します。

00:03:29.000 --> 00:03:34.000
しかし、既存のクライアントを壊す可能性があるため、その行動を変えたくありません。

00:03:34.000 --> 00:03:45.000
念のため、最新のSDKに対してアプリケーションをコンパイルし、特定のリビジョンを指定しない場合、常に最新のリビジョンを取得します。

00:03:45.000 --> 00:03:57.000
しかし、リビジョン1を指定するアプリケーション、または新しいSDKに対して再コンパイルしないアプリケーションの場合、古いリビジョン1の動作は引き続き取得されます。

00:03:57.000 --> 00:04:03.000
ビジョンでのバーコード検出要求のいくつかの興味深い側面を強調させてください。

00:04:03.000 --> 00:04:07.000
ビジョンは1Dおよび2Dバーコードをサポートしています。

00:04:07.000 --> 00:04:16.000
しかし、本当に興味深いのは、1つの画像内で、複数のコードと複数のシンボルを一度に検出できることです。

00:04:16.000 --> 00:04:21.000
つまり、複数のコードを取得するために何度も何度もスキャンする必要がないということです。

00:04:21.000 --> 00:04:24.000
これは、ほとんどのハンドヘルドスキャナーよりも大きな利点です。

00:04:24.000 --> 00:04:32.000
複数のシンボルをスキャンすると、指定したシンボルが多いほど時間がかかることを覚えておいてください。

00:04:32.000 --> 00:04:40.000
したがって、ユースケースに関連するシンボルのみを使用してリクエストを設定したいと考えています。

00:04:40.000 --> 00:04:47.000
バーコードスキャンの新しいシンボルの拡張により、ビジョンは健康分野で特に役立つ役割を果たすことができます。

00:04:47.000 --> 00:04:57.000
iPhoneを使用すると、一度に複数のコードを分析でき、インターネットへの接続のおかげで、別のスキャナを必要とせずに情報を引き出すことができます。

00:04:57.000 --> 00:05:10.000
また、iPhoneの強力な低照度機能のおかげで、暗いシナリオでも、レーザーを撃ったり、休憩中に患者を邪魔したりすることなく、コードをスキャンすることができます。

00:05:10.000 --> 00:05:15.000
では、Visionがバーコード検出をどのように実行するかを見てみましょう。

00:05:15.000 --> 00:05:18.000
1Dコードは行としてスキャンされます。

00:05:18.000 --> 00:05:23.000
つまり、同じコードに対して複数の検出が得られる可能性が高いということです。

00:05:23.000 --> 00:05:33.000
バーコードに含まれている実際のデータであるペイロードを見ることで、それらを重複排除するのは簡単です。

00:05:33.000 --> 00:05:35.000
2Dコードは1つのユニットとしてスキャンされます。

00:05:35.000 --> 00:05:39.000
つまり、コード全体のバウンディングボックスを1つ取り戻すということです。

00:05:39.000 --> 00:05:45.000
2Dコードの例はQRコードです。

00:05:45.000 --> 00:05:49.000
各バーコードは、独自の観察で報告されます。

00:05:49.000 --> 00:05:58.000
しかし、前に述べたように、1Dコードは、同じ内容で、異なる物理的な場所で複数の観測を返すことができます。

00:05:58.000 --> 00:06:05.000
ペイロードは、バーコードの内容、つまり、この機械可読コードに含まれるデータです。

00:06:05.000 --> 00:06:14.000
特にQRコードのペイロードについては、データ検出器を使用してエンコードされたURLを分析することをお勧めします。

00:06:14.000 --> 00:06:17.000
さて、これをちょっとしたデモで見てみましょう。

00:06:17.000 --> 00:06:24.000
さて、ここにはXcodeの遊び場があり、すべてのバーコードが入った画像があることがわかります。

00:06:24.000 --> 00:06:29.000
VNDetectBarcodesRequestを使用し、リビジョンを2に設定しました。

00:06:29.000 --> 00:06:38.000
さて、シンボルとして、私はコーダバーを持っているだけで、これを見ると、コーダバーが赤で強調表示されていることがわかります。

00:06:38.000 --> 00:06:46.000
さて、これをQRに変更しましょう。 

00:06:46.000 --> 00:06:52.000
今起こることは、リクエストを再度実行し、QRコードが強調表示されることがわかります。

00:06:52.000 --> 00:06:58.000
しかし、それは配列なので、ean8としましょう、それで他のリクエストを指定することもできます。

00:06:58.000 --> 00:07:06.000
そして、私がそれを行うと、私たちは今、ean8とQRコードの両方を持っていることがわかります。

00:07:06.000 --> 00:07:08.000
しかし、私がそれらすべてを手に入れたい場合はどうなりますか?

00:07:08.000 --> 00:07:13.000
私は単に空の配列を通過し、その瞬間に、すべてのシンボルが読まれます。

00:07:13.000 --> 00:07:18.000
そして、ご覧のとおり、今はすべてが下部のコードで強調表示されています。

00:07:18.000 --> 00:07:21.000
スライドに戻りましょう。 

00:07:21.000 --> 00:07:25.000
バーコードから、私たちは今、テキスト認識に目を向けています。

00:07:25.000 --> 00:07:29.000
ビジョンは2019年にテキスト認識を導入しました。

00:07:29.000 --> 00:07:33.000
高速と正確な2つのモードで動作します。

00:07:33.000 --> 00:07:37.000
それ以来、ビジョンは言語サポートを拡大してきました。

00:07:37.000 --> 00:07:42.000
テキスト認識がどのように機能し、言語がどこで役割を果たすかを見てみましょう。

00:07:42.000 --> 00:07:46.000
ファストパスには、ラテン文字認識器があります。

00:07:46.000 --> 00:07:54.000
一方、正確なパスは、単語や行で動作する機械学習ベースのリコグナイザを使用します。

00:07:54.000 --> 00:07:59.000
認識が完了すると、各パスは言語修正段階を経ます。

00:07:59.000 --> 00:08:02.000
そして、最終的には、認識されたテキストを取り戻します。

00:08:02.000 --> 00:08:05.000
言語の選択は認識段階に影響します。

00:08:05.000 --> 00:08:13.000
ファストパスでは、ドイツ語のウムラウトのように、異なるラテン文字セットがサポートされていることを意味します。

00:08:13.000 --> 00:08:23.000
正確なパスでは、中国語の構造がラテン語ベースの言語とは大きく異なるため、中国語を認識する必要があるときにまったく異なるモデルが使用されます。

00:08:23.000 --> 00:08:31.000
つまり、中国語のテキストを読む必要がある場合は、中国語が要求の主要言語であることが重要です。

00:08:31.000 --> 00:08:40.000
言語選択は、その仕事のために正しい辞書を選ぶので、言語修正にも影響します。

00:08:40.000 --> 00:08:44.000
では、テキスト認識で言語を使用する際のベストプラクティスは何ですか?

00:08:44.000 --> 00:08:56.000
固定された言語セットがサポートされているように見えるかもしれませんが、supportedRecognitionLanguages()を使用して、特定の要求設定でサポートされている言語を照会することをお勧めします。

00:08:56.000 --> 00:09:01.000
複数の言語を指定でき、その場合、順序が重要です。

00:09:01.000 --> 00:09:06.000
曖昧さがある場合、それは言語の順序で解決されます。

00:09:06.000 --> 00:09:13.000
特に正確なパスについては、第一言語がどの認識モデルが使用されるかを決定します。

00:09:13.000 --> 00:09:22.000
つまり、ユースケースによって、リクエストで使用する言語が決まります。

00:09:22.000 --> 00:09:25.000
ちょっとしたデモでこれを見てみましょう。

00:09:25.000 --> 00:09:35.000
だから、私は今ここに私たちのサンプルコードの改訂版を持っています、そしてあなたは私がその中にテキストの異なる言語を持つ画像を持っていることがわかります。

00:09:35.000 --> 00:09:39.000
さて、リビジョン2を指定して、どの言語がサポートされているかを確認できます。

00:09:39.000 --> 00:09:45.000
私たちは英語、フランス語などを持っています。

00:09:45.000 --> 00:09:52.000
たとえば、リビジョン1に戻すと、英語しかないことがわかります。

00:09:52.000 --> 00:09:57.000
そして、それは高速の場合と正確なパスの場合と同じです。

00:09:57.000 --> 00:10:00.000
では、リビジョン2に戻りましょう。

00:10:00.000 --> 00:10:10.000
例えば、私が今ドイツ語に切り替えるとき、私は実際にGrüsse aus Cupertinoでウムラウトを正しく取得することに注意してください。

00:10:10.000 --> 00:10:15.000
しかし、私は中国人のためのファストパスでサポートを持っていません。

00:10:15.000 --> 00:10:22.000
正確なパスで、私は今中国語を選ぶことができます。

00:10:22.000 --> 00:10:27.000
そして今、私たちはついに「Hello World」の正しい中国語の文字を手に入れました。

00:10:27.000 --> 00:10:30.000
スライドに戻りましょう。 スライドに戻りましょう

00:10:30.000 --> 00:10:34.000
最後になりましたが、ドキュメントの検出を見てみましょう。

00:10:34.000 --> 00:10:39.000
ビジョンは、VNDocumentSegmentationRequestと呼ばれる新しいリクエストを導入します。

00:10:39.000 --> 00:10:49.000
これは、紙、サイン、メモ、領収書、ラベルなど、さまざまな種類の文書で訓練した機械学習ベースの検出器です。

00:10:49.000 --> 00:11:00.000
リクエストの結果は、低解像度のセグメンテーションマスクであり、各ピクセルは、そのピクセルが検出されたドキュメントの一部であるかどうかの信頼を表します。

00:11:00.000 --> 00:11:07.000
さらに、四角形の4つの角点を提供します。

00:11:07.000 --> 00:11:14.000
ニューラルエンジンを搭載したデバイスでは、リクエストはカメラやビデオフィードでリアルタイムで実行できます。

00:11:14.000 --> 00:11:25.000
VisionKitのVNDocumentCameraは、ニューラルエンジンを搭載した最新のデバイスで、VNDetectRectanglesRequestの代わりにリクエストを使用しています。

00:11:25.000 --> 00:11:33.000
VNDetectRectanglesRequestと言えば、どちらもドキュメントの検出に使用できるため、これら2つの要求はどのように異なりますか?

00:11:33.000 --> 00:11:40.000
DetectDocumentsRequestは、私が述べたように、機械学習ベースであり、ニューラルエンジンで最速で実行します。

00:11:40.000 --> 00:11:48.000
しかし、GPUやCPUでも使用できますが、リアルタイムのパフォーマンスには十分な速さではありません。

00:11:48.000 --> 00:12:01.000
長方形検出器は、CPUでのみ実行され、CPUが他のタスクで飽和していない限り、リアルタイムのパフォーマンスに追いつくことができる従来のコンピュータビジョンアルゴリズムです。

00:12:01.000 --> 00:12:09.000
文書要求はさまざまな文書で訓練されており、その主な強みの1つであるすべての長方形である必要はありません。

00:12:09.000 --> 00:12:22.000
一方、長方形検出器は、四角形を形成するエッジと交差点を見つけることによって機能します。これは、文書内のあいまいな角や折り畳みで課題になる可能性があります。

00:12:22.000 --> 00:12:31.000
ドキュメント要求はセグメンテーションマスクとコーナーポイントを提供しますが、長方形検出器はコーナーポイントのみを提供します。

00:12:31.000 --> 00:12:35.000
そして、文書検出器は1つの文書だけを探すように訓練されています。

00:12:35.000 --> 00:12:39.000
長方形検出器を使用すると、複数の長方形を返します。

00:12:39.000 --> 00:12:42.000
これらの長方形はネストすることさえできます。

00:12:42.000 --> 00:12:46.000
これをもう少し見てみましょう。 

00:12:46.000 --> 00:12:55.000
私が述べたように、文書検出器は、検出されたオブジェクトの四角形でここで見られる1つの文書を見つけます。

00:12:55.000 --> 00:13:04.000
しかし、長方形検出器は、画像で見つけたすべての長方形の複数の観察を返し、私はここでいくつかを強調しました。

00:13:04.000 --> 00:13:08.000
どの長方形が文書であるかを決めるのはアプリ次第です。

00:13:08.000 --> 00:13:12.000
デモでこれをすべて試してみるのはどうですか？

00:13:12.000 --> 00:13:17.000
さて、私たちはWWDCでどれだけうまくやっているか、ちょっとした調査を作りたかったのです。

00:13:17.000 --> 00:13:22.000
さて、残念ながら、あなたは私と一緒にいないので、私はここのカメラチームにあなたのためにアンケートに記入するように頼まなければなりませんでした。

00:13:22.000 --> 00:13:27.000
そこで、アンケートカードをスキャンできる小さなアプリを作成しました。

00:13:27.000 --> 00:13:28.000
そして、私たちは何を手に入れますか?

00:13:28.000 --> 00:13:31.000
初心者向けのQuickDrawは時代遅れだと感じました。

00:13:31.000 --> 00:13:36.000
まあ、今では少し古いです。

00:13:36.000 --> 00:13:38.000
次に行きましょう。"

00:13:38.000 --> 00:13:45.000
ああ、ビジョンは面白くて有益でした。

00:13:45.000 --> 00:13:49.000
最後になりましたが、コボル、まさに私が必要としていたものです。

00:13:49.000 --> 00:13:52.000
誰かがここで間違ったセッションに参加しています。

00:13:52.000 --> 00:13:56.000
さて、コードでこれをどのように行ったかを見てみましょう。

00:13:56.000 --> 00:14:01.000
だから、私たちのためにこのようなものを構築する方が簡単なので、私はここで再び小さな遊び場を作りました。

00:14:01.000 --> 00:14:10.000
すでにご覧のとおり、画像をロードし、画像操作を行う必要があるため、CIImageを使用しました。

00:14:10.000 --> 00:14:15.000
requestHandlerを作成し、新しいVNDetectDocument SegmentationRequest()を使用しました。

00:14:15.000 --> 00:14:33.000
リクエストを実行すると、結果が返され、コア画像を使用して透視補正画像として使用した小さなヘルパー機能を作成し、透視補正形式で切り取られたカードだけを取り戻します。

00:14:33.000 --> 00:14:35.000
だから、それは簡単です。

00:14:35.000 --> 00:14:37.000
それで、私たちは次に何をしなければなりませんか?

00:14:37.000 --> 00:14:44.000
バーコードを検出し、長方形を検出し、テキストを認識する必要があります。

00:14:44.000 --> 00:14:50.000
このリクエストを実行したら、チェックボックスをスキャンして、どれがチェックされているかを確認する必要があります。

00:14:50.000 --> 00:14:58.000
さて、私はこれを少し準備したので、バーコードの検出から始めましょう。

00:14:58.000 --> 00:15:02.000
そして、私はシンボルとして、QRコードだけを使っています。

00:15:02.000 --> 00:15:09.000
私はそれが知っていることを知っているので、私は文書のタイトルにロードしました--私のQRコードの内容は、私たちがそれから得るもののタイトルになります。

00:15:09.000 --> 00:15:12.000
次に、長方形を検出する必要があります。

00:15:12.000 --> 00:15:18.000
繰り返しますが、そのための小さなコード矩形があります。

00:15:18.000 --> 00:15:20.000
だから、私は2つの配列を作成します。

00:15:20.000 --> 00:15:25.000
分析に必要なデータであるすべてのcheckBoxImagesを取得したいです。

00:15:25.000 --> 00:15:27.000
そして、私はすべての長方形を取り出します。

00:15:27.000 --> 00:15:30.000
そこで、私はVNDetectRectanglesRequestを使用しました。

00:15:30.000 --> 00:15:39.000
さて、私がここで行うことは、正しい順序で結果を得るように、それらを垂直順に並べ替えることです。

00:15:39.000 --> 00:15:44.000
さて、今、私たちはテキストを認識する必要があります。

00:15:44.000 --> 00:15:45.000
それは簡単です。

00:15:45.000 --> 00:15:51.000
結果のすべてのテキストブロックを保存し、VNRecognizeTextRequestを使用します。

00:15:51.000 --> 00:15:56.000
だから今、私たちがしなければならないのは、単に要求を実行することです。

00:15:56.000 --> 00:16:05.000
そして、ご覧のとおり、私はトリミングされた画像を使用したdocumentRequestHandlerを使用し、その要求を実行しました。

00:16:05.000 --> 00:16:14.000
そして、私がここに戻ると、私はすでに正しいQRコードを取得していることがわかりますが、私の長方形では何かが正しくありません。

00:16:14.000 --> 00:16:16.000
長方形は手がありません。

00:16:16.000 --> 00:16:18.000
それで、私は何をしなければなりませんか?

00:16:18.000 --> 00:16:25.000
まあ、デフォルトでは、長方形検出器は画像の少なくとも20%である長方形のみを探します。

00:16:25.000 --> 00:16:26.000
だから、私たちはそれを修正する必要があります。

00:16:26.000 --> 00:16:41.000
だから、私は中に入って、最小サイズを10%のようなものに設定します。

00:16:41.000 --> 00:16:45.000
そして、それを行うと、長方形になります。

00:16:45.000 --> 00:16:48.000
さて、まあ、それは1つだけです。

00:16:48.000 --> 00:16:53.000
さて、長方形検出器のもう1つのことは、それがいくつ戻るべきかを伝える必要があるということです。

00:16:53.000 --> 00:16:59.000
デフォルトでは、長方形の検出は、最も目立つ長方形の1つだけを返します。

00:16:59.000 --> 00:17:00.000
しかし、私はそれらすべてを手に入れたい。

00:17:00.000 --> 00:17:05.000
これを行うには、maximumObservationsを0に設定します。

00:17:05.000 --> 00:17:16.000
そして、それを行うと、それは長方形のように見えるので、すべてのチェックボックスとバーコードを取得します。

00:17:16.000 --> 00:17:18.000
さて、私たちは大丈夫です。

00:17:18.000 --> 00:17:23.000
今、最後の部分が来て、私は実際にチェックボックスをスキャンする必要があります。

00:17:23.000 --> 00:17:28.000
だから、そのために、私は実際に少し機械学習のデモを準備しました。

00:17:28.000 --> 00:17:31.000
ここには、先ほどCreate MLでトレーニングしたモデルがあります。

00:17:31.000 --> 00:17:40.000
それは画像分類器であり、私がやったのは、マークされたこれらのチェックボックス画像のいくつかを使用し、そのうちのいくつかは私の「はい」と「いいえ」のラベルにマークされていません。

00:17:40.000 --> 00:17:43.000
そして、私はまた、それらのどちらでもないいくつかの画像を集めました。

00:17:43.000 --> 00:17:47.000
それは私のNotItです。

00:17:47.000 --> 00:17:56.000
繰り返しますが、これをコードで使用できます。

00:17:56.000 --> 00:17:58.000
それで、私たちは何を持っていますか?

00:17:58.000 --> 00:18:03.000
モデルをロードしてリクエストを作成し、Create MLリクエストを作成します。

00:18:03.000 --> 00:18:12.000
そして、すべてのチェックボックス画像を反復し、そこからImageRequestHandlerを作成し、分類を実行します。

00:18:12.000 --> 00:18:14.000
今、私は私のトップ分類を見ることができます。

00:18:14.000 --> 00:18:22.000
それが「はい」の場合、私が持っているチェックボックスとどのテキスト行が並んでいるかを見つけ、最終的に何を得るのですか?

00:18:22.000 --> 00:18:26.000
ビジョンは面白くて有益でした。

00:18:26.000 --> 00:18:29.000
スライドに戻りましょう。 スライドに戻りましょう

00:18:29.000 --> 00:18:31.000
私たちが見たものについてまとめてみましょう。

00:18:31.000 --> 00:18:35.000
ドキュメント分析は、Vision APIの焦点です。

00:18:35.000 --> 00:18:42.000
ビジョンのバーコード検出はスキャナーよりも汎用性が高く、新しいドキュメントセグメンテーション検出を導入しています。

00:18:42.000 --> 00:18:49.000
OCRの使い方についてもっと知りたい場合は、WWDC 2019のセッションをご覧ください。

00:18:49.000 --> 00:19:02.000
WWDC 2020の「ビジョンとコアイメージ」セッションは、画像を前処理し、輪郭を検出することにより、独自のカスタムドキュメント分析を行うための追加の洞察を提供します。

00:19:02.000 --> 00:19:05.000
ありがとう、そしてWWDCの残りの部分を楽しんでください。

00:19:05.000 --> 23:59:59.000
[音楽]。

