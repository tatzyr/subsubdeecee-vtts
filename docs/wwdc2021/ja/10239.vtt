WEBVTT

00:00:00.000 --> 00:00:05.000
♪ベース音楽の演奏♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:12.000
スチュアート・チェシャー：「アプリのネットワーク遅延を減らす」へようこそ。

00:00:12.000 --> 00:00:15.000
私の名前はスチュアート・チェシャーです。

00:00:15.000 --> 00:00:28.000
今日、ネットワークアプリを遅く感じさせる要因について話してから、同僚のVidhi Goelに渡して、ネットワークアプリをよりレスポンシブにするために使用できるテクニックとAPIについて説明します。

00:00:28.000 --> 00:00:36.000
iOSのWWDCベータ版ですでに見たことがあるかもしれないことについて話すことから始めましょう。

00:00:36.000 --> 00:00:42.000
開発者設定を見ると、ネットワーキングセクションに「応答性」という新しい項目が表示されます。

00:00:42.000 --> 00:00:56.000
アップロードスループット、ダウンロードスループット、アイドルping時間はすべて興味深いですが、ネットワークアプリの応答性に影響を与える主な要因は、アイドル状態ではなく、作業条件下でのネットワークの応答性です。

00:00:56.000 --> 00:01:03.000
典型的なインターネット速度テストのアイドルping時間測定は、使用していないときにインターネット接続がどれだけうまく機能するかを示します。

00:01:03.000 --> 00:01:08.000
重要なのは、使用しているときにインターネット接続がどれだけうまく機能するかです。

00:01:08.000 --> 00:01:10.000
テストをタップします。

00:01:10.000 --> 00:01:22.000
ネットワークトラフィックを生成することを警告し、ネットワークを数秒間測定し、作業条件下でネットワークがどれだけうまく機能しているかを伝えます。

00:01:22.000 --> 00:01:29.000
このツールは、ミリ秒ではなく、1分あたりの往復、またはRPMでネットワークの応答性を報告します。

00:01:29.000 --> 00:01:36.000
ミリ秒は多くの人にとってかなり抽象的な概念であるため、この新しいRPMメトリックを作成しました。

00:01:36.000 --> 00:01:40.000
人々はまた、高い方が良い指標に精通しています。

00:01:40.000 --> 00:01:49.000
RPMメトリックは、車のエンジンのRPMと同様に、数百RPMから数千RPMの範囲の数値を生成します。

00:01:49.000 --> 00:01:55.000
macOSには、NetworkQualityと呼ばれるこのテストツールのコマンドラインバージョンもあります。

00:01:55.000 --> 00:02:00.000
あなたの家や職場のネットワークは素晴らしいping時間を持っていると思うかもしれませんが、それはアイドル状態です。

00:02:00.000 --> 00:02:10.000
このネットワーク品質テストをiPhoneまたはMacで自分で実行すると、ネットワークが使用されているときに、その応答性がはるかに悪くなる可能性があります。

00:02:10.000 --> 00:02:13.000
そして、私はもっと悪い意味です。

00:02:13.000 --> 00:02:24.000
ネットワークには20ミリ秒のアイドルラウンドトリップ時間があるかもしれませんが、これはかなり良さそうですが、作業条件下では、ラウンドトリップ時間は600ミリ秒以上になるかもしれません。

00:02:24.000 --> 00:02:26.000
それは30倍悪いです。

00:02:26.000 --> 00:02:33.000
労働条件の下でのネットワークの応答性は、アプリのユーザーエクスペリエンスにとって重要です。

00:02:33.000 --> 00:02:41.000
私たちは皆、この問題を常に見ていますが、特にオーディオとビデオのフリーズ、ビデオ会議中のドロップアウトで。

00:02:41.000 --> 00:02:49.000
高いネットワーク遅延はすべてのアプリを傷つけますが、私たちはそれに慣れているので、それがビデオ会議に影響を与えるとき、私たちはそれにもっと気づきます。

00:02:49.000 --> 00:02:56.000
ビデオ会議に問題がある場合は、インターネット接続をアップグレードすることで解決すると思います。

00:02:56.000 --> 00:03:02.000
人々は毎秒数メガビットからギガビット以上になりましたが、問題はまだ発生しています。

00:03:02.000 --> 00:03:09.000
毎秒数メガビットはビデオ会議には十分なはずですが、なぜ私たちはまだこれらの問題を抱えているのですか?

00:03:09.000 --> 00:03:18.000
ネットワーク内のバッファが大きすぎると、いっぱいになると、スループットは改善しませんが、遅延が追加されます。

00:03:18.000 --> 00:03:25.000
私たちは通常、インターネットがこのように動作し、パケットがネットワークを高速に流れることを考えます。

00:03:25.000 --> 00:03:31.000
しかし、クラウドの内部を見ると、実際にはこのように機能することがわかります。

00:03:31.000 --> 00:03:36.000
ネットワークから出てくるパケットは、あなたが見たパケットではありません。

00:03:36.000 --> 00:03:40.000
パケットは、ネットワーク内の過度に大きなバッファに座って多くの時間を費やします。

00:03:40.000 --> 00:03:51.000
過度に大きなバッファーのこの現象はbufferbloatと呼ばれ、日常のネットワーク使用への影響にもかかわらず、今まで広く測定されていません。

00:03:51.000 --> 00:04:01.000
良いニュースは、バッファブロートを排除する制御遅延キューイングアルゴリズムであるCoDelのような最新のキュー管理アルゴリズムがあることです。

00:04:01.000 --> 00:04:07.000
ネットワークがキューを短くすると、パケットがネットワーク内で待機する時間が劇的に短縮されます。

00:04:07.000 --> 00:04:12.000
高スループットと低遅延を同時に取得することが可能です。

00:04:12.000 --> 00:04:16.000
それはどちらか/または選択ではありません。それはゼロサムゲームではありません。

00:04:16.000 --> 00:04:23.000
私たちは業界と協力して、よりスマートなキュー管理アルゴリズムを展開し、労働条件下でのネットワークの応答性を向上させています。

00:04:23.000 --> 00:04:31.000
しかし、今のところ、優れたユーザーエクスペリエンスを提供したい場合は、アプリが今日のようにインターネットに対応できるようにしたいと思うでしょう。

00:04:31.000 --> 00:04:39.000
Bufferbloatは、アプリケーションが経験するネットワーク遅延の大きなコンポーネントですが、遅延の原因だけではありません。

00:04:39.000 --> 00:04:42.000
ソフトウェアとハードウェアの処理時間があります。

00:04:42.000 --> 00:04:47.000
CPUがますます速くなるにつれて、この処理時間は縮小し続けます。

00:04:47.000 --> 00:04:49.000
実際のデータ送信時間があります。

00:04:49.000 --> 00:04:57.000
データレートがキロビットからメガビットからギガビット/秒に増加するにつれて、伝送時間は縮小し続けています。

00:04:57.000 --> 00:05:00.000
次に、ネットワーク内のバッファリングによる時間遅延があります。

00:05:00.000 --> 00:05:04.000
私が言ったように、私たちはこれらの遅延を減らすために業界と協力しています。

00:05:04.000 --> 00:05:08.000
しかし、常に光速信号の伝播遅延があります。

00:05:08.000 --> 00:05:18.000
1990年代、米国全土のスタンフォードからMITへのping時間、往復、海岸から海岸まではすでに100ミリ秒未満でした。

00:05:18.000 --> 00:05:24.000
それはすでに光速の制限にかなり近いので、それほど良くならないようにします。

00:05:24.000 --> 00:05:36.000
私たちは他の3つの遅延の削減に取り組んでいますが、光の速度の遅延は決して消えないので、これがネットワークの往復時間を考慮してアプリを設計することが重要です。

00:05:36.000 --> 00:05:42.000
ネットワークの往復時間を考慮に入れることについて話しているとき、どのようなアプリについて話しているのですか?

00:05:42.000 --> 00:05:48.000
ビデオ会議が高いネットワーク遅延によって深刻な影響を受けることは誰もが知っています。

00:05:48.000 --> 00:05:53.000
オンラインゲームは高いネットワーク遅延によって深刻な影響を受けていることは誰もが知っています。

00:05:53.000 --> 00:05:56.000
しかし、これはネットワークを使用するすべてのアプリに影響します。

00:05:56.000 --> 00:06:00.000
私は天気予報、株価、道順を得ることについて話しています。

00:06:00.000 --> 00:06:02.000
これはウェブブラウジングに影響します。

00:06:02.000 --> 00:06:05.000
ストリーミングビデオを見ながらスキップに影響します。

00:06:05.000 --> 00:06:11.000
アプリがネットワークを待っている間に、アニメーション化された回転遅延インジケーターを含むアプリの数を考えてください。

00:06:11.000 --> 00:06:13.000
たぶんあなたのアプリ。

00:06:13.000 --> 00:06:18.000
ユーザーがアプリがハングしたと思わないように、「お待ちください」インジケーターを表示します。

00:06:18.000 --> 00:06:28.000
遅いネットワークを待っている間、ユーザーが見るものを与えることに多くの努力をすることは素晴らしいことですが、彼らが待つのに費やす時間を減らすためにも同等の努力をする必要があります。

00:06:28.000 --> 00:06:37.000
ネットワークからのデータを待っている間に遅延インジケーターを表示するアプリがある場合は、それらの待ち時間を短縮するために使用できるテクニックがあります。

00:06:37.000 --> 00:06:48.000
アプリがネットワークデータを待つ時間は、1回のネットワーク往復にかかる時間と、アプリに必要なネットワーク往復の数の関数です。

00:06:48.000 --> 00:06:58.000
アプリ開発者として、基盤となるネットワークの往復時間を改善するためにできることはあまりありませんが、アプリに必要な往復回数を制御できます。

00:06:58.000 --> 00:07:04.000
同僚のヴィディ・ゴエルを紹介して、その方法を教えてください。

00:07:04.000 --> 00:07:06.000
ヴィディ・ゴエル:ありがとう、スチュアート。

00:07:06.000 --> 00:07:16.000
こんにちは、私はVidhiです。今日は、アプリのネットワーク遅延を減らすために開発者として何ができるかについてお話ししたいと思います。

00:07:16.000 --> 00:07:22.000
アプリの応答性は、ネットワーク往復の数に反比例します。

00:07:22.000 --> 00:07:32.000
最新のネットワークプロトコルを採用し、アプリを超スピーにすることで、これらのネットワーク往復を減らす方法をお見せしましょう。

00:07:32.000 --> 00:07:47.000
アプリを高速化するには、HTTP/3&amp;QUIC、TCP Fast Open、TLS 1.3、Multipath TCPなどの最新のネットワークプロトコルを採用してください。

00:07:47.000 --> 00:07:56.000
これらの手法により、アプリはユーザーにデータを配信する際の複数の往復削減を潜在的に達成できます。

00:07:56.000 --> 00:08:05.000
これらの最新のプロトコルすべてにサーバー側のサポートが必要なので、その準備状況についてはプロバイダに確認してください。

00:08:05.000 --> 00:08:12.000
これらの技術はすべてiOSとmacOSで利用可能であることをお伝えできることを嬉しく思います。

00:08:12.000 --> 00:08:15.000
これらの技術のそれぞれを見てみましょう。 

00:08:15.000 --> 00:08:25.000
まず、iOS 15とmacOS Montereyでデフォルトで有効になっているHTTP/3とQUICがあります。

00:08:25.000 --> 00:08:32.000
QUICは、TCPやTLSよりもはるかに高速に接続を設定できるトランスポートプロトコルです。

00:08:32.000 --> 00:08:41.000
回線のブロックを減らすことで、QUICはユーザーへのデータ配信の遅延を大幅に削減できます。

00:08:41.000 --> 00:08:47.000
そして、ここに最高の部分があります:あなたがすでにURLSessionを使用している場合、あなたはすべて設定されています。

00:08:47.000 --> 00:09:04.000
ネットワークフレームワークAPIを使用して独自のアプリケーションレイヤーを提供し、QUICを利用したい場合は、QUICパラメータでNWConnectionを作成し、TLSアプリケーションレイヤープロトコルまたはALPNを設定するだけです。

00:09:04.000 --> 00:09:14.000
アプリでこれらの技術を使用する方法の詳細については、「HTTP/3とQUICでネットワークを加速する」セッションをチェックしてください。

00:09:14.000 --> 00:09:17.000
QUICは多くのシナリオで役に立ちます。

00:09:17.000 --> 00:09:24.000
しかし、一部のアプリケーションでは、TCPは依然として正しい選択かもしれません。

00:09:24.000 --> 00:09:35.000
TCPを使用する場合、TCPハンドシェイクと一緒にアプリデータを送信することで、往復全体を排除できます。

00:09:35.000 --> 00:09:41.000
TCPファストオープンは、ネットワークフレームワークとソケットでサポートされています。

00:09:41.000 --> 00:09:58.000
NWConnectionsで使用するには、2つのオプションがあります。最初のオプションは、接続でファストオープンを許可することです。この場合、アプリはハンドシェイクで送信される初期データを提供します。

00:09:58.000 --> 00:10:06.000
これを有効にするには、allowFastOpenパラメータをtrueに設定し、接続を作成します。

00:10:06.000 --> 00:10:14.000
そして、スタートを呼び出す前に、最初のデータで送信を呼び出します。

00:10:14.000 --> 00:10:24.000
TCP Fast Openを使用する場合は、ハンドシェイクで冪等要求のみを送信するように注意する必要があります。

00:10:24.000 --> 00:10:30.000
Idempotentは基本的に、データがネットワーク上で安全に再生できることを意味します。

00:10:30.000 --> 00:10:40.000
アプリが独自の初期データを送信する必要がないTCP Fast Openを使用する別の方法があります。

00:10:40.000 --> 00:10:49.000
アプリがTCPでTLSを使用している場合は、最初のデータとしてTLSハンドシェイクメッセージを送信することを選択できます。

00:10:49.000 --> 00:10:58.000
これを有効にするには、TCP固有のオプションに移動し、enableFastOpenをtrueに設定します。

00:10:58.000 --> 00:11:17.000
TCP Fast Openを使用する推奨される方法は、ネットワークフレームワークAPI経由ですが、アプリがソケット上に構築されている場合は、それぞれのフラグでconnectx APIを呼び出すと、ハンドシェイクで冪等データを送信することを指定します。

00:11:17.000 --> 00:11:21.000
私は冪等について何度か言及しました。

00:11:21.000 --> 00:11:29.000
それが何を意味するのか、そしてなぜ握手で冪等要求だけを送ることが重要なのかを説明しましょう。

00:11:29.000 --> 00:11:39.000
冪等でリプレイセーフな操作は、複数回実行しても追加効果のない操作です。

00:11:39.000 --> 00:11:52.000
たとえば、ユーザーがdeveloper.apple.comのWebページにアクセスすると、このWebページのHTTP GETリクエストがTCPハンドシェイクで送信されます。

00:11:52.000 --> 00:12:06.000
このリクエストの確認がネットワークで遅延またはドロップされた場合、デバイスはHTTP GETリクエストを再送信し、別のサーバーにルーティングされる可能性があります。

00:12:06.000 --> 00:12:12.000
そして今回は、HTTPレスポンスと一緒に確認応答が届きます。

00:12:12.000 --> 00:12:23.000
HTTP GETリクエストは、ネットワーク経由で再送信されたときに追加の効果がないため、冪等要求と見なされます。

00:12:23.000 --> 00:12:29.000
さて、ユーザーが新しいiPhone 12を購入しようとしているとしましょう。

00:12:29.000 --> 00:12:36.000
この操作に対して送信されたHTTPリクエストは、冪等要求ではありません。

00:12:36.000 --> 00:12:46.000
データがネットワーク経由で再生されるたびに要求が異なるサーバーに送信されると、複数のトランザクションが発生する可能性があります。

00:12:46.000 --> 00:12:51.000
それを念頭に置いて、TLS 1.3について話しましょう。

00:12:51.000 --> 00:12:59.000
TLS 1.3は、TLS 1.2と比較して、ハンドシェイクから往復全体を削除します。

00:12:59.000 --> 00:13:03.000
また、より強力なセキュリティを提供します。

00:13:03.000 --> 00:13:11.000
URLSessionとNWConnectionのiOS 13.4以降、デフォルトで有効になっています。

00:13:11.000 --> 00:13:23.000
TLS 1.3プロトコルは、早期データサポートを定義し、TLSハンドシェイクメッセージと一緒に冪等要求を送信することで、さらに別の往復を節約できます。

00:13:23.000 --> 00:13:31.000
ギアを切り替えて、ネットワークの遅延を減らすために少し異なる方法で機能するマルチパスTCPを見てみましょう。

00:13:31.000 --> 00:13:40.000
マルチパスTCPを使用すると、デバイスが1つのネットワークから別のネットワークに切り替わるときに、単一のTCP接続を継続できます。

00:13:40.000 --> 00:13:48.000
マルチパスTCPの低レイテンシ機能を取得するには、インタラクティブモードAPIを使用します。

00:13:48.000 --> 00:13:59.000
新しい接続を確立するために必要なすべての往復が保存され、システムは自動的にデータパケットのより高速なネットワークパスを選択します。

00:13:59.000 --> 00:14:11.000
クライアントからオプトインするには、multipathServiceTypeプロパティをURLSession設定またはNWParametersでインタラクティブに設定します。

00:14:11.000 --> 00:14:20.000
これらの近代的な技術で節約できる往復の数のアイデアを与えるために、基準点から始めましょう。

00:14:20.000 --> 00:14:25.000
あなたのアプリが現在TCPでTLS 1.2を実行しているとしましょう。

00:14:25.000 --> 00:14:32.000
この場合、最初のバイトをユーザーに取得するには4往復かかります。

00:14:32.000 --> 00:14:41.000
サーバーがTLS 1.2からTLS 1.3に切り替わると、接続は往復全体を排除します。

00:14:41.000 --> 00:14:49.000
接続でTCP Fast Openを有効にすると、さらに別の往復が保存されます。

00:14:49.000 --> 00:14:57.000
iOS 15では、HTTP/3 over QUICは2往復に削減されます。

00:14:57.000 --> 00:15:07.000
QUICプロトコルはまた、早期データサポートを定義し、1往復にさらに削減することができます。

00:15:07.000 --> 00:15:18.000
Appleでの測定値に基づいて、ユーザーは600ミリ秒にも急上昇する往復時間を見るのが一般的です。

00:15:18.000 --> 00:15:21.000
それがあなたのアプリにとって何を意味するのか見てみましょう。

00:15:21.000 --> 00:15:30.000
600ミリ秒での4往復は、ユーザーがデータが届くのをほぼ2秒半待っていることを意味します。

00:15:30.000 --> 00:15:36.000
それは、ネットワークスピナーを待って見つめる膨大な時間です。

00:15:36.000 --> 00:15:47.000
最新のネットワークプロトコルを採用することで、その時間を最初のバイトに2.4秒から約0.5秒に短縮できます。

00:15:47.000 --> 00:15:55.000
データは1秒半早く到着すると、ユーザーは確実に違いに気づくでしょう。

00:15:55.000 --> 00:16:02.000
優れたネットワークパフォーマンスを望むすべての開発者は、往復の数に注意を払う必要があります。

00:16:02.000 --> 00:16:06.000
ここが大きな勝利があるところです。

00:16:06.000 --> 00:16:14.000
私が話したすべての技術は、現実世界のネットワーク条件でアプリのネットワーク遅延を減らすのに役立ちます。

00:16:14.000 --> 00:16:23.000
5G、LTE、または高速Wi-Fiネットワークでアプリをテストすると、アプリの応答性は問題ないと思われるかもしれません。

00:16:23.000 --> 00:16:29.000
しかし、ユーザーが常に最高のネットワーク条件でアプリを使用しているとは限りません。

00:16:29.000 --> 00:16:38.000
現実的なネットワークをシミュレートするために、ネットワークリンクコンディショナーツールは開発者設定メニューからiOSで利用可能です。

00:16:38.000 --> 00:16:43.000
macOSの場合は、Apple DeveloperのWebサイトからダウンロードできます。

00:16:43.000 --> 00:16:53.000
このツールは、ユーザーが日常生活で経験する可能性のあるさまざまなネットワーク条件でアプリをテストするための信頼性が高く反復可能な方法です。

00:16:53.000 --> 00:17:02.000
思い出せば、スチュアートは先ほど、ネットワークの往復時間を短縮することはあまりできないと述べました。

00:17:02.000 --> 00:17:05.000
まあ、それは完全に真実ではありません。

00:17:05.000 --> 00:17:15.000
アプリのトラフィックについてシステムに正しく通知すると、ネットワークの往復時間を短縮する方法を説明します。

00:17:15.000 --> 00:17:20.000
ほとんどのアプリには、送受信するトラフィックが混在しています。

00:17:20.000 --> 00:17:27.000
たくさんのアプリを実行すると、ユーザーのデバイスから多くのデータが交換されます。

00:17:27.000 --> 00:17:35.000
家庭やオフィスのWi-Fiなどの現実世界のネットワークでは、多くのデバイスが同じネットワークを共有しています。

00:17:35.000 --> 00:17:43.000
これらのデバイスは、一連のアプリを使用している間、同時に大量のデータを送受信します。

00:17:43.000 --> 00:17:59.000
この共有ネットワークで長いキューを構築することを避けるために、ネットワーク遅延を低く維持するために、システムがトラフィックを効率的に管理できるように、アプリデータを適切に分類することが重要です。

00:17:59.000 --> 00:18:12.000
また、システムが低ネットワーク遅延を維持できるようにすると、アプリのフォアグラウンドトラフィックが速くなり、ユーザーにとって最も重要なデータが迅速に配信されます。

00:18:12.000 --> 00:18:16.000
これを例で説明しましょう。

00:18:16.000 --> 00:18:24.000
多くのアプリは、グラフィックス、オーディオファイルなどのコンテンツをプリフェッチして、後で使用できるようにします。

00:18:24.000 --> 00:18:32.000
アプリがかなりの量のデータをプリフェッチしているとき、これはネットワークがどのように見えるかです。

00:18:32.000 --> 00:18:36.000
ボトルネックキューがいっぱいになる可能性があります。

00:18:36.000 --> 00:18:52.000
この時点で、ユーザーがプロファイルページの表示など、ネットワークアクティビティを開始すると、この要求に対する応答はネットワークキューの最後にキューに入れられ、プロファイルが表示されるまでに数秒かかる場合があります。

00:18:52.000 --> 00:18:56.000
これは良いユーザーエクスペリエンスではないでしょう。

00:18:56.000 --> 00:19:06.000
では、これらの非ユーザーが開始したプリフェッチタスクをバックグラウンドとしてマークすると、ネットワークに何が起こるかを見てみましょう。

00:19:06.000 --> 00:19:19.000
これらの非ユーザー主導の転送をバックグラウンドとしてマークすると、ネットワークキューのサイズが劇的に縮小され、他のフォアグラウンドデータで利用できるようになります。

00:19:19.000 --> 00:19:29.000
したがって、フォアグラウンドデータ、つまりグリーンパケットは、迅速で楽しい体験のために即座に配信されます。

00:19:29.000 --> 00:19:37.000
iOS 15とmacOS Montereyでは、バックグラウンドサービスタイプが劇的に改善されました。

00:19:37.000 --> 00:19:44.000
バックグラウンドのアップロードとダウンロードのための新しい混雑制御アルゴリズムを追加しました。

00:19:44.000 --> 00:19:59.000
これらの新しいアルゴリズムは、より良いユーザーエクスペリエンスのためにネットワークの遅延を大幅に削減するだけでなく、バックグラウンド転送が他のトラフィックとほぼ同じ時間に終了することを保証します。

00:19:59.000 --> 00:20:07.000
バックグラウンドサービスタイプを利用するために採用できるネットワークAPIを見てみましょう。

00:20:07.000 --> 00:20:22.000
アプリがフォアグラウンドにあり、ユーザーが開始していない転送を実行する場合は、デフォルトのURLSessionを使用し、URLリクエストでネットワークサービスタイプをバックグラウンドに設定します。

00:20:22.000 --> 00:20:28.000
繰り返しになりますが、これにより、システムは低いネットワーク遅延を維持できます。

00:20:28.000 --> 00:20:37.000
また、NWConnectionの場合、サービスクラスをNWParametersのバックグラウンドに設定します。

00:20:37.000 --> 00:20:51.000
ユーザーが開始したかどうかにかかわらず、アプリが長時間の転送を開始した場合、アプリが一時停止されている場合でも実行を続けるためのバックグラウンドURLSessionを作成します。

00:20:51.000 --> 00:20:57.000
時間に敏感なタスクでは、isDiscretionary プロパティを true に設定できます。

00:20:57.000 --> 00:21:05.000
これにより、システムは転送を実行するための最適な条件を待つことができます。

00:21:05.000 --> 00:21:11.000
私たちはあなたのアプリがネットワークキューを短く保つのにどのように役立つかについて話しました。

00:21:11.000 --> 00:21:17.000
もう1つの遅延の原因は、送信デバイス自体にある可能性があります。

00:21:17.000 --> 00:21:23.000
歴史的に、ネットワークスタックは非常に大きな送信バッファを使用してきました。

00:21:23.000 --> 00:21:32.000
これにより、パケットがネットワークに入る前に、時には秒単位で多くの不必要な遅延が追加されます。

00:21:32.000 --> 00:21:40.000
私たちは2015年にURLSessionとNWConnectionのためにこれを修正しました。

00:21:40.000 --> 00:21:47.000
しかし、インターネット上のほとんどのサーバーはLinuxで動作し、BSDソケットを使用しています。

00:21:47.000 --> 00:22:01.000
サーバーオペレーターに連絡して、ソースでの遅延を減らすために、TCPが送信されていない低透かしソケットオプションを使用していることを確認してください。

00:22:01.000 --> 00:22:10.000
次のステップでは、最新のネットワークプロトコルを採用して、複数の往復旅行を排除します。

00:22:10.000 --> 00:22:18.000
バックグラウンドモードを使用して、アセット、一括転送、および緊急ではないタスクをプリフェッチします。

00:22:18.000 --> 00:22:24.000
さまざまなネットワーク条件でアプリのパフォーマンスをテストします。

00:22:24.000 --> 00:22:29.000
ネットワークリンクコンディショナーは、それを行うための優れたツールです。

00:22:29.000 --> 00:22:38.000
ネットワークの遅延を低く保つことで、アプリの応答性が向上し、全体的なユーザーエクスペリエンスが向上します。

00:22:38.000 --> 00:22:42.000
見てくれてありがとう、素晴らしいWWDCを!

00:22:42.000 --> 23:59:59.000
♪

