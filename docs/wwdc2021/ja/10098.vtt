WEBVTT

00:00:00.000 --> 00:00:05.000
♪ベース音楽の演奏♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:13.000
David Stites: こんにちは、「Showcase app data in Spotlight」へようこそ。

00:00:13.000 --> 00:00:17.000
私の名前はDavid Stitesで、Core Dataチームのエンジニアです。

00:00:17.000 --> 00:00:26.000
このセッションでは、NSCoreDataCoreSpotlightDelegateを使用してアプリにSpotlightインデックスを追加する方法を紹介します。

00:00:26.000 --> 00:00:43.000
このセッションの議題は、NSCoreDataCoreSpotlightDelegateオブジェクトとそれを使用する理由について学び、簡単な実装を設定し、その実装をカスタマイズする方法を学び、最後にフルテキスト検索を追加してコードを検証することです。

00:00:43.000 --> 00:00:48.000
まず、コアデータとスポットライトを見てみましょう。

00:00:48.000 --> 00:00:53.000
人々はあなたのアプリに多くの素晴らしい重要なコンテンツを作成して保存します。

00:00:53.000 --> 00:01:08.000
アプリの使用とデータセットのサイズが大きくなるにつれて、標準の検索方法を使用してアプリ内と、Spotlight検索などのアプリの外部の両方で、そのデータをすばやく見つけたいと思うでしょう。

00:01:08.000 --> 00:01:13.000
アプリ内のデータがSpotlightに表示されるのは素晴らしいことではないでしょうか？

00:01:13.000 --> 00:01:17.000
さて、これはコアデータがあなたを助けることができる場所です。

00:01:17.000 --> 00:01:27.000
NSCoreDataCore SpotlightDelegateオブジェクトは、すべての重い作業を行い、アプリによって提供されるコンテンツを迅速かつ効率的にインデックス化する一連のAPIを提供します。

00:01:27.000 --> 00:01:30.000
電源を入れるだけでいい！

00:01:30.000 --> 00:01:38.000
インデックスが作成されると、検索結果はアプリ外のSpotlight検索ユーザーインターフェイスにも表示されます。

00:01:38.000 --> 00:01:46.000
Spotlightデリゲートは、グラフの管理対象オブジェクトへの変更を自動的に処理し、それに応じてSpotlightインデックスを更新します。

00:01:46.000 --> 00:01:58.000
さらに、プライベートでデバイスのみのインデックスと対話するための堅牢なインデックス管理機能を提供し、好みに合わせてインデックス結果を調整できます。

00:01:58.000 --> 00:02:05.000
実際、永続的なストアにあるコンテンツは、インデックスを作成する資格があります。

00:02:05.000 --> 00:02:29.000
Spotlightデリゲートを使用する理由は3つあります。(1)Spotlightデリゲートは、Core Spotlight APIとの機能パリティを維持し、(2)多くの必要な実装コードを削除し、(3)このセッションの後半で議論する素晴らしい追加機能セットを提供します。

00:02:29.000 --> 00:02:41.000
私の前のポイントを説明するために、これは検索インデックスにアイテムのみを追加し、それを...これに減らすコアスポットライトAPIを使用した非常に簡単な実装です!

00:02:41.000 --> 00:02:43.000
2行！

00:02:43.000 --> 00:02:45.000
シンプルで読みやすく、メンテナンスが簡単です。

00:02:45.000 --> 00:02:49.000
つまり、さあ、誰がより少ないコードを好まないのですか？

00:02:49.000 --> 00:02:53.000
すぐにセットアップして実行する方法を見てみましょう。 すぐに実行する

00:02:53.000 --> 00:02:58.000
この簡単な例では、何を索引付けするかを決定し、デリゲートを作成します。

00:02:58.000 --> 00:03:07.000
このセッションを通して、私は自分で書いたタグというアプリを参照します。これは簡単な写真タグ付けアプリケーションです。

00:03:07.000 --> 00:03:12.000
このサンプルアプリには、私が今日議論している多くのAPIが組み込まれます。

00:03:12.000 --> 00:03:24.000
スポットライトのサポートを追加する前に、「ナチュラルブリッジ州立公園」のスポットライト検索クエリ結果がないため、すべてのタグと写真データがタグ内に閉じ込められていることがわかります。

00:03:24.000 --> 00:03:25.000
それを変えよう！

00:03:25.000 --> 00:03:34.000
NSCoreDataCoreSpotlightDelegateを使用した実装の最初のステップは、Spotlightで何をインデックス化するかを決定することです。

00:03:34.000 --> 00:03:37.000
スポットライトで何がインデックス化されるのは、完全にあなた次第です。

00:03:37.000 --> 00:03:48.000
タグでは、エンティティ写真のuserSpecifiedName属性とエンティティタグの名前属性をインデックス化することにしました。

00:03:48.000 --> 00:04:01.000
インデックス作成用のモデルを準備するために、Xcodeでプロジェクトのコアデータモデルを開き、インデックスを作成する各属性を選択し、属性インスペクタの「スポットライトのインデックス」チェックボックスにチェックを入れました。

00:04:01.000 --> 00:04:09.000
Core Data Spotlightの表示名を設定する必要があるため、Core Dataモデルエディタで作業が継続されます。

00:04:09.000 --> 00:04:13.000
コアデータスポットライトの表示名はNSExpressionです。

00:04:13.000 --> 00:04:23.000
インデックス作成時に、この式はSpotlightによってインデックス化されたプロパティを持つ各管理オブジェクトで評価され、結果が保存されます。

00:04:23.000 --> 00:04:33.000
その後、Spotlight検索ユーザーインターフェイスが表示されると、これらの保存された結果は検索結果の「表示名」として使用されます。

00:04:33.000 --> 00:04:35.000
NSExpressionとは何ですか?

00:04:35.000 --> 00:04:42.000
まあ、式はキーパス、この場合はTag.nameを評価するのと同じくらい簡単です。

00:04:42.000 --> 00:04:48.000
しかし、このオブジェクトには、キーパスを評価する以外にもかなりの数のトリックがあります。

00:04:48.000 --> 00:04:51.000
この例では、それはあなたのためにいくつかの数学をしています。

00:04:51.000 --> 00:04:59.000
この式は、一連の数値の標準偏差を計算するなど、さらに複雑になる可能性があります。

00:04:59.000 --> 00:05:09.000
タグでは、Spotlightの表示名は、エンティティPhotoのuserSpecifiedNameとエンティティタグの名前に設定されます。

00:05:09.000 --> 00:05:15.000
モデルのインデックス作成の準備ができたので、Spotlightデリゲートを作成しましょう。

00:05:15.000 --> 00:05:24.000
iOS 15とmacOS Monterey以降、StoreWith: model:の初期化子は非推奨になりました。

00:05:24.000 --> 00:05:28.000
Spotlightデリゲートを初期化する新しい方法は、forStoreWith: coordinator:を使用しています。

00:05:28.000 --> 00:05:39.000
新しい指定されたイニシャライザを採用することで、ストアをコーディネーターに追加する前に、スポットライトデリゲートのインスタンスをストアオプションに追加する必要がなくなりました。

00:05:39.000 --> 00:05:47.000
ただし、Spotlightデリゲートが作業を開始するには、startSpotlightIndexingを呼び出す必要があります。

00:05:47.000 --> 00:05:52.000
NSCoreDataCoreSpotlightDelegateを使用するためのいくつかの要件を呼び出したいと思います。

00:05:52.000 --> 00:05:59.000
インデックスを作成するストアのストアタイプはSQLiteでなければならず、永続的な履歴追跡が有効になっている必要があります。

00:05:59.000 --> 00:06:01.000
そして、それで、あなたは終わりです!

00:06:01.000 --> 00:06:02.000
それでおそれ！

00:06:02.000 --> 00:06:08.000
他に何もする必要はなく、データはSpotlightでインデックス化されます。

00:06:08.000 --> 00:06:13.000
タグアプリにSpotlightインデックスを追加するのがいかに簡単かを実証しました。

00:06:13.000 --> 00:06:18.000
基本を説明したので、その実装を少しカスタマイズしてみましょう。

00:06:18.000 --> 00:06:24.000
実装をカスタマイズする最初の方法は、ドメイン名とインデックス名を定義することです。

00:06:24.000 --> 00:06:34.000
まず、NSCoreDataCoreSpotlightDelegateのサブクラスであるタグSpotlightDelegateを定義します。

00:06:34.000 --> 00:06:39.000
次に、実装でdomainNameとindexNameをオーバーライドします。

00:06:39.000 --> 00:06:49.000
これらのセレクタをオーバーライドすると、インデックスされたデータを保存する場所をSpotlightに伝え、特に複数のインデックスがある場合は、後でよりよく識別できます。

00:06:49.000 --> 00:06:56.000
domainIdentifierを上書きしない場合、デフォルトのドメイン識別子はストア識別子です。

00:06:56.000 --> 00:07:02.000
indexNameをオーバーライドしない場合、デフォルトのインデックス名はnilです。

00:07:02.000 --> 00:07:08.000
Spotlightデリゲートをカスタマイズする次のステップは、属性セットを定義することです。

00:07:08.000 --> 00:07:21.000
このセッションのセットアップ部分では、NSCoreDataCore SpotlightDelegateオブジェクトは、Spotlightのチェックボックスインデックスにチェックを入れるだけで、Spotlightに返される属性セットを定義しました。

00:07:21.000 --> 00:07:28.000
次に、インデックス作成に使用する属性を指定する方法を正確に実演します。

00:07:28.000 --> 00:07:36.000
インデックスを作成する属性を指定すると、インデックスが作成されるものと検索方法をより明示的に制御できます。

00:07:36.000 --> 00:07:40.000
これを行うには、CSSearchableItemAttributeSetを使用します。

00:07:40.000 --> 00:07:52.000
属性セットには、いくつかの事前定義されたプロパティが含まれており、検索結果として表示されるときに、指定された管理対象オブジェクトについて表示するメタデータを指定できます。

00:07:52.000 --> 00:07:56.000
選択する属性は、ドメインに完全に依存します。

00:07:56.000 --> 00:08:05.000
CSSearchableItemAttributeSetで利用可能な定義済みのプロパティを使用するか、独自のプロパティを定義することができます。

00:08:05.000 --> 00:08:13.000
タグアプリは、事前定義されたプロパティキーワード、displayName、およびthumbnailDataを使用します。

00:08:13.000 --> 00:08:24.000
属性セット内のプロパティへの同時アクセスには未定義の動作があるため、一度に1つのスレッドで設定された属性のみを変更する必要があることに注意することが重要です。

00:08:24.000 --> 00:08:31.000
TagsSpotlightDelegateクラスに戻って、attributeSet(オブジェクト:)をオーバーライドして、これがどのように機能するかを見てみましょう。

00:08:31.000 --> 00:08:36.000
オーバーライドの実装では、オブジェクトがフォトタイプのオブジェクトであるかどうかを判断することから始めます。

00:08:36.000 --> 00:08:42.000
次に、コンテンツタイプ.imageでattributeSetを初期化します。

00:08:42.000 --> 00:08:55.000
次に、Photoオブジェクトの適切な属性を使用して、設定された属性にプロパティ識別子、displayName、およびthumbnailDataを設定します。

00:08:55.000 --> 00:09:01.000
次に、Photoオブジェクトタグセットから属性セットのキーワード配列にタグを追加します。

00:09:01.000 --> 00:09:15.000
この時点で、モデルが関係をインデックス化する場合、attributeSet（オブジェクトの場合：）をオーバーライドして、特にその関係の何がインデックス化されるかを定義する必要があることに言及する価値があります。

00:09:15.000 --> 00:09:19.000
最後に、属性セットを返します。

00:09:19.000 --> 00:09:25.000
モデルはタグオブジェクトもインデックス化しているため、コードはタグのケースを処理する必要があります。

00:09:25.000 --> 00:09:37.000
そのために、contentType .text で設定された属性を作成し、表示名をタグの名前に設定してから、属性セットを返します。

00:09:37.000 --> 00:09:45.000
最後のステップとして、前の手順でモデルエディタで設定したCore Data Spotlight表示名を削除します。

00:09:45.000 --> 00:09:52.000
さらに進んで、インデックス作成を開始および停止するためのイベントループを定義しましょう。

00:09:52.000 --> 00:10:00.000
以前、Spotlightデリゲートを設定すると、Spotlightデリゲートを作成した直後にstartSpotlightIndexingが呼び出されました。

00:10:00.000 --> 00:10:11.000
NSCoreDataCoreSpotlightDelegateがいつインデックス作成作業を行っているかを正確に制御するために、stopSpotlightIndexingもフレームワークに追加されました。

00:10:11.000 --> 00:10:25.000
これら2つのセレクタを協調して使用すると、アプリが強力なCPUまたはディスクアクティビティ操作を実行している場合に、必要に応じてインデックス作成作業を開始および停止することができます。

00:10:25.000 --> 00:10:31.000
それでは、インデックスの更新が完了したときに通知を受けるためのサポートを追加しましょう。

00:10:31.000 --> 00:10:41.000
Spotlightでインデックスされているエンティティまたはエンティティに変更が発生すると、そのインデックスは非同期に更新されます。

00:10:41.000 --> 00:10:48.000
iOS 15とmacOS Montereyでは、Core Dataフレームワークにインデックス更新通知が追加されました。

00:10:48.000 --> 00:11:01.000
インデックスの更新が完了したときに通知を受けるには、Spotlightデリゲートが投稿するNSCoreDataCoreSpotlightDelegate .indexDidUpdateNotificationを購読してください。

00:11:01.000 --> 00:11:11.000
これらの通知は、NSManagedObjectContextで保存する呼び出しを処理した後、またはバッチ操作の完了後に掲載されます。

00:11:11.000 --> 00:11:14.000
これを実際に見てみましょう。

00:11:14.000 --> 00:11:18.000
まず、インデックス作成が有効になっているかどうかを確認します。

00:11:18.000 --> 00:11:23.000
もしそうなら、indexDidUpdateNotificationに登録してください。

00:11:23.000 --> 00:11:50.000
次に、ハンドラで通知を調べます。通知には、リモート変更通知に似た2つのキーと値のペアを含むuserInfo辞書があります。Spotlightデリゲートがインデックスを更新したストアのNSString UUIDと、Spotlightデリゲートがインデックスを更新したストアの永続的な履歴トークンです。

00:11:50.000 --> 00:11:59.000
これらのキーの両方を使用して、興味のあるストアが最新の永続的な履歴トークンまでインデックス化されているかどうかを判断できます。

00:11:59.000 --> 00:12:07.000
インデックス作成が有効になっていない場合は、通知からオブザーバーとして自分自身を削除できます。

00:12:07.000 --> 00:12:21.000
今年以前は、アプリによってインデックスされたデータを削除する唯一の方法は、Core Spotlight APIを実装してインデックスエントリを削除するか、Core Dataのクライアントグラフ全体を削除することでした。

00:12:21.000 --> 00:12:36.000
重要なことに、iOS 15とmacOS Montereyで新しく追加されたCore Dataは、開発者にクライアントグラフを削除せずにSpotlightインデックスを管理する新しい方法を提供し、ユーザーのプライバシーにとって大きな勝利です!

00:12:36.000 --> 00:12:39.000
まず、コードはインデックス作成を停止します。

00:12:39.000 --> 00:12:43.000
次に、deleteSpotlightIndexを呼び出します。

00:12:43.000 --> 00:12:47.000
最後に、完了ハンドラで結果として生じるエラーを処理します。

00:12:47.000 --> 00:12:58.000
このメソッドを呼び出すと、Core DataやCore Spotlightなどの下位層の依存関係からエラーが返される可能性があることに注意してください。

00:12:58.000 --> 00:13:09.000
Spotlightデリゲートの実装をカスタマイズする方法をお見せしたので、Core Spotlight APIを使用してタグアプリに全文検索を追加して、設定を検証しましょう。

00:13:09.000 --> 00:13:13.000
結果は、以前にインデックス化されたものになります。

00:13:13.000 --> 00:13:25.000
まず、UISearchResultsUpdatingプロトコルと関数updateSearchResults（コントローラ用）を採用したPhotosViewControllerの拡張機能を定義することから始めます。

00:13:25.000 --> 00:13:29.000
タグのユーザーインターフェイスにはUISearchControllerがあります。

00:13:29.000 --> 00:13:33.000
その検索コントローラーの検索バーからユーザー入力を取得します。

00:13:33.000 --> 00:13:42.000
ユーザー入力が空の場合は、データプロバイダーからすべての画像を取得し、検索クエリがないためコレクションビューをリロードします。

00:13:42.000 --> 00:13:46.000
では、検索クエリがある場合に対処しましょう。

00:13:46.000 --> 00:13:51.000
開始するには、ユーザー入力文字列をエスケープしてサニタイズします。

00:13:51.000 --> 00:13:56.000
次に、ユーザーのサニタイズされた入力文字列を使用してクエリ文字列を定義します。

00:13:56.000 --> 00:14:04.000
クエリ文字列は、CSSearchableItemAttributeSetオブジェクトのプロパティに関連付けられた値を操作します。

00:14:04.000 --> 00:14:11.000
この場合、コードは前の手順で設定したキーワード属性で動作します。

00:14:11.000 --> 00:14:17.000
検索クエリでは、修飾子c、d、およびwが使用されています。

00:14:17.000 --> 00:14:20.000
Cは大文字と小文字を区別しません。

00:14:20.000 --> 00:14:22.000
Dは発音記号の無神経です。

00:14:22.000 --> 00:14:27.000
そして、wは単語ベースの検索用です。

00:14:27.000 --> 00:14:42.000
次に、作成されたばかりのフォーマットされたクエリ文字列と、CSSearchableItemAttributeSetで定義されたプロパティに対応する属性名の配列を指定して、CSSearchQueryオブジェクトを作成します。

00:14:42.000 --> 00:14:53.000
この検索クエリオブジェクトは、SpotlightデリゲートAPIを使用して以前にインデックスしたアプリコンテンツを検索するときに適用する基準を管理します。

00:14:53.000 --> 00:14:56.000
その後、foundItemsHandlerを設定します。

00:14:56.000 --> 00:15:02.000
このハンドラは、以前に定義された検索クエリに一致する項目で繰り返し呼び出されます。

00:15:02.000 --> 00:15:11.000
一度呼び出されるクエリの完了ハンドラで、エラーをチェックし、エラー処理を実行する可能性があります。

00:15:11.000 --> 00:15:23.000
エラーがない場合、メインキューにブロックをディスパッチして、データプロバイダーを使用してSpotlightが見つけたアイテムのフェッチを実行し、ユーザーインターフェイスにロードします。

00:15:23.000 --> 00:15:28.000
最後に、そして最も重要なことは、クエリを開始することを忘れないでください。

00:15:28.000 --> 00:15:36.000
タグアプリにはSpotlightデリゲートがコンテンツをインデックス化しているため、データはアプリ内から解放されました!

00:15:36.000 --> 00:15:51.000
スポットライトに行き、以前追加したタグを検索すると、タグ名自体と「Natural Bridges State Park」というキーワードでタグ付けした特定の写真の2つの結果が返されます。

00:15:51.000 --> 00:16:15.000
最後に、NSCoreDataCoreSpotlightDelegateと、ユーザーがSpotlight検索でアプリ内とアプリの外でコンテンツを見つけるのにどのように役立つかを学び、Spotlightデリゲートをすばやく簡単にセットアップして、巨大なコード負担なしでインデックス作成を開始し、このリリースで利用可能な新しいAPIを使用してSpotlightデリゲートをカスタマイズしました。

00:16:15.000 --> 00:16:24.000
この情報が役に立ち、ユーザーがコンテンツを見つけるのを助けるために、プロジェクトにNSCoreDataCoreSpotlightDelegateを採用することを検討することを願っています。

00:16:24.000 --> 00:16:27.000
素晴らしいWWDCを！

00:16:27.000 --> 23:59:59.000
♪

