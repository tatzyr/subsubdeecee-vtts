WEBVTT

00:00:00.000 --> 00:00:05.000
♪ベース音楽の演奏♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:12.000
トーマス・ナウデ:こんにちは、WWDCへようこそ。

00:00:12.000 --> 00:00:20.000
私はアップルのローカリゼーションチームのトーマスです。今日は、ローカライズされた文字列を合理化する方法を紹介します。

00:00:20.000 --> 00:00:25.000
アプリを多くの言語で動作させる最も簡単な方法が表示されます。

00:00:25.000 --> 00:00:28.000
UIコードを書くことから始めます。

00:00:28.000 --> 00:00:32.000
次に、ターゲットの文字列を整理する方法を見ていきます。

00:00:32.000 --> 00:00:38.000
その後、Xcodeに私たちのために重い作業をさせます。

00:00:38.000 --> 00:00:42.000
最後に、高度な弦の新しいテクニックを学びます。

00:00:42.000 --> 00:00:47.000
これらすべてで、私たちはあなたのアプリが素晴らしい翻訳のために準備ができていることを保証します。

00:00:47.000 --> 00:00:52.000
テキストは私たちの生活のどこにでもあるので、これは非常に重要です。

00:00:52.000 --> 00:00:56.000
私たちは、現実世界でコミュニケーションを取り、情報を得るためにテキストを使用します。

00:00:56.000 --> 00:01:05.000
それは明らかに、私たちが毎日読むすべてのアプリ、通知、記事で私たちの接続されたデバイスでより真実です。

00:01:05.000 --> 00:01:12.000
これまで以上に、テキストが読みやすく、正確で、アクセスしやすいことが重要です。

00:01:12.000 --> 00:01:18.000
これらすべての看板の中で小さな店を見つけようとして、この通りで完全に迷子になっていることを想像してみてください。

00:01:18.000 --> 00:01:21.000
アプリのユーザーでも同じかもしれません。

00:01:21.000 --> 00:01:27.000
テキストはそのようなコア機能であり、ユーザーを導き、親しみやすさをもたらします。

00:01:27.000 --> 00:01:37.000
このようにして、アプリのローカライズは、特にApp Storeが提供するすべての市場で、世界中のすべてのユーザーにリーチする機会です。

00:01:37.000 --> 00:01:44.000
開発者として、私たち開発者は物事に名前を付けることを楽しんでいるので、あなたはすでにテキストに精通しています。

00:01:44.000 --> 00:01:47.000
私たちはテキストを「文字列」と呼びました。

00:01:47.000 --> 00:01:58.000
タイトル、ボタン、ユーザーコンテンツ、オンラインコンテンツ、検索クエリ、グラフィック、アクセシビリティラベルなど、文字列はどこにでもあります。

00:01:58.000 --> 00:02:02.000
アプリ内のすべての文字列を映画の字幕として考えてください。

00:02:02.000 --> 00:02:13.000
あなたが見る映画では、すべての字幕を適切な言語で、適切なタイミングで、適切な文脈で、映画全体を通して一貫していることを望んでいます。

00:02:13.000 --> 00:02:15.000
これはここでもまったく同じです。

00:02:15.000 --> 00:02:25.000
あなたの文字列は、あなたのビジュアルコンテンツに意味を伝え、ユーザーがあなたのアプリの通りをナビゲートするのを助けます。

00:02:25.000 --> 00:02:31.000
それでは、開発者の観点から、ローカリゼーションプロセスが何であるかを見てみましょう。

00:02:31.000 --> 00:02:35.000
ユーザーインターフェイスは、ビューに文字列を表示します。

00:02:35.000 --> 00:02:39.000
これらの文字列は独自のファイルにあります。

00:02:39.000 --> 00:02:48.000
これは、すべての言語に一般的なビジュアルコンテンツと特定の翻訳との間の懸念を分離するのに役立ちます。

00:02:48.000 --> 00:02:54.000
その間に、Foundationフレームワークはユーザーインターフェイスとすべての文字列をリンクします。

00:02:54.000 --> 00:02:58.000
この講演では、これらの各コンポーネントについて詳しく説明します。

00:02:58.000 --> 00:03:04.000
それは多くのように見えますが、私たちはすべてを段階的に明らかにします。

00:03:04.000 --> 00:03:09.000
では、ユーザーインターフェイスで文字列を定義することから始めましょう。

00:03:09.000 --> 00:03:14.000
最新のAppleテクノロジーを組み合わせることで、ローカライズされた文字列を簡単に表示できます。

00:03:14.000 --> 00:03:22.000
二度とローカリゼーションについて二度考える必要がないように、アプリでこれらのテクニックを使用することをお勧めします!

00:03:22.000 --> 00:03:26.000
さて、UIで定義した文字列はローカライズする必要があります。

00:03:26.000 --> 00:03:30.000
目に見える文字列には2つのタイプがあります。

00:03:30.000 --> 00:03:34.000
1つは、ビューを作成するときに直接定義されます。

00:03:34.000 --> 00:03:38.000
ここでは、SwiftUIとStoryboardでラベルを定義しました。

00:03:38.000 --> 00:03:41.000
そして、はい！どちらもローカライズ可能です。

00:03:41.000 --> 00:03:43.000
簡単だって言ったでしょ！

00:03:43.000 --> 00:03:54.000
2番目のタイプの文字列はより一般的で、SwiftUIのモデルコードだけでなく、AppKitやUIKitでも見つけることができます。

00:03:54.000 --> 00:03:59.000
文字列を変数に格納するか、関数から返す必要があるかもしれません。

00:03:59.000 --> 00:04:04.000
これらすべての場合、NSLocalizedStringを使用できます。

00:04:04.000 --> 00:04:12.000
iOS 15とmacOS Montereyの新機能では、Swift、String(localized:)の洗練された方法を使用できます。

00:04:12.000 --> 00:04:17.000
少しの間、SwiftUIの最初の方法に焦点を当てましょう。

00:04:17.000 --> 00:04:31.000
インターフェイスに提示するものはすべて確かにビューであり、これがテキストラベルであろうとボタンであろうと、デフォルトではすべてローカライズ可能で、将来の翻訳された文字列をホストする準備ができています。

00:04:31.000 --> 00:04:40.000
これはデフォルトで有効になっているため、プレビューなどのモックコンテンツがある場合は、逐語を使用してオプトアウトしてください。

00:04:40.000 --> 00:04:44.000
これにより、翻訳者にとって不要な作業を回避できます。

00:04:44.000 --> 00:04:49.000
この関連セッションでは、より多くのテクニックを学ぶことができます。

00:04:49.000 --> 00:04:54.000
基本をカバーしたので、この文字列をよりダイナミックにする方法を学びましょう。

00:04:54.000 --> 00:04:59.000
現在、注文するためのローカライズされたボタンを表示しています。

00:04:59.000 --> 00:05:06.000
あなたは私がコンサートを愛していることを知らないかもしれません、そして私はアーティストが友達と一緒に暮らすのを見るのがもっと好きです!

00:05:06.000 --> 00:05:12.000
このアプリでは、友達全員にチケットを何枚注文しているかは明らかではありません。

00:05:12.000 --> 00:05:18.000
だから、私が選択したチケットの数を含めるようにそのボタンを改善しましょう。

00:05:18.000 --> 00:05:19.000
それは簡単でした。

00:05:19.000 --> 00:05:24.000
Swiftで慣れているように、文字列に変数を挿入しました。

00:05:24.000 --> 00:05:31.000
ここでは、カウントは実行時に実際の数3に置き換えられます。

00:05:31.000 --> 00:05:38.000
すべてのオプションを見たので、共通の落とし穴を呼び出したいと思います：文字列（フォーマット：）。

00:05:38.000 --> 00:05:45.000
(Format:) の文字列は素晴らしいですが、ローカライズされた文字列に使用することを意図していません。

00:05:45.000 --> 00:05:52.000
テキストの方向と数字が異なる可能性があるアラビア語の例で理由を見てみましょう。

00:05:52.000 --> 00:05:58.000
良いニュースは、String(localized:)を使用すると、両方とも自動的に管理されることです。

00:05:58.000 --> 00:06:07.000
これで、「3」という数字は、設定のユーザーの好みの数字に従って、ボタンにアラビア語で正しく書かれています。

00:06:07.000 --> 00:06:19.000
String(localized:)は、複数形と文字列の各部分の分離もサポートしています。つまり、単語は双方向テキストでシャッフルされません。

00:06:19.000 --> 00:06:22.000
最後に、変数を過剰に使用しないように注意してください。

00:06:22.000 --> 00:06:28.000
文字列を接着するのは便利ですが、翻訳の問題につながる可能性があります。

00:06:28.000 --> 00:06:39.000
ここでは、「注文」という言葉は、今すぐ注文するか、後で注文するかにかかわらず、いくつかの言語で異なって書くことができます。

00:06:39.000 --> 00:06:43.000
2つの別々の文字列を使用する方が安全です。

00:06:43.000 --> 00:06:52.000
わかった。私が今まで密かにあなたから隠していたことを私たちが見る必要がある1つの主要な、最後の側面があります。

00:06:52.000 --> 00:06:57.000
あなたが定義した文字列は、あなた以外の誰かによって翻訳される必要があります。

00:06:57.000 --> 00:07:08.000
翻訳者は、文字列を文字列ごとに翻訳している間、目の前に完全なアプリUIを持っておらず、すべての文字列で一貫性を保つ必要があります。

00:07:08.000 --> 00:07:16.000
だから、コードコメントを追加して同僚があなたのコードを理解するのを助けるのと同じように、あなたは彼らを助ける必要があります。

00:07:16.000 --> 00:07:20.000
文字列に関係なく、常にコメントを定義する必要があると主張します。

00:07:20.000 --> 00:07:27.000
そして、ストーリーボードのファイルを忘れないでください。IDインスペクタにコメントフィールドがあります。

00:07:27.000 --> 00:07:31.000
翻訳者を助けるためのヒントをいくつか共有しましょう。

00:07:31.000 --> 00:07:35.000
まず、コメントは文字列が表示されている場所を説明する必要があります。

00:07:35.000 --> 00:07:41.000
例えば、これはボタンですか?ラベル？ボイスオーバーのテキスト？

00:07:41.000 --> 00:07:51.000
これがアクション - 命令 - またはステートメント - 注文 - を知ることは重要です。

00:07:51.000 --> 00:07:54.000
第二に、彼らは文脈を説明するべきです。

00:07:54.000 --> 00:08:01.000
注文を押すと、取引を完了しますか、それともリストを並べ替えますか？

00:08:01.000 --> 00:08:04.000
最後に、コメントは変数を説明する必要があります。

00:08:04.000 --> 00:08:16.000
ローカライザーがあなたの文字列を見ると、あなたのコードが表示されないので、手がかりを得るために変数の名前が表示されず、代わりに一般的なプレースホルダだけです。

00:08:16.000 --> 00:08:22.000
では、ここでの最後の例では、「注文」の前の数字は何を表していますか?

00:08:22.000 --> 00:08:25.000
これは過去の注文数ですか?

00:08:25.000 --> 00:08:28.000
注文したばかりのチケットの数は？

00:08:28.000 --> 00:08:34.000
はい！コメントのおかげで、私はそれがチケットの総数であることを知っています。

00:08:34.000 --> 00:08:44.000
多くの言語の翻訳者は、「チケット」という言葉の性別に応じて正しく翻訳することができます。

00:08:44.000 --> 00:08:51.000
時には、最も簡単なのは、コメントに変数の例の値を書くことです。

00:08:51.000 --> 00:08:53.000
それを念頭に置いて、そこにあります。

00:08:53.000 --> 00:08:59.000
UIコードはローカライズの準備ができています。

00:08:59.000 --> 00:09:05.000
次に、UIコードを文字列とは別に維持する方法を学びます。

00:09:05.000 --> 00:09:10.000
基本的には、弦が住む場所を整理することができます。

00:09:10.000 --> 00:09:18.000
これを行うには、Foundationがコードが正しいローカライズされた文字列ファイルをロードすることを確認する方法を見てみましょう。

00:09:18.000 --> 00:09:22.000
もちろん、ローカリゼーションは言語から始まります。

00:09:22.000 --> 00:09:27.000
プロジェクト設定に移動して、新しいものを追加できます。

00:09:27.000 --> 00:09:29.000
Xcodeを見てみましょう。 では、Xcodeを見てみましょう

00:09:29.000 --> 00:09:34.000
プロジェクトを選択し、プラス(+)ボタンをクリックしてローカリゼーションを追加します。

00:09:34.000 --> 00:09:39.000
メニューは最新バージョンで多くの新しい言語を獲得したことがわかります。

00:09:39.000 --> 00:09:46.000
見てみましょう...ローカリゼーションのアプリリストでは、一番上のBaseで始まります。

00:09:46.000 --> 00:09:51.000
実際、UI要素は言語間で共有されているため、ここに住んでいます。

00:09:51.000 --> 00:10:00.000
たとえば、Storyboardファイルは共有され、Siri Intentsファイルも共有されます。

00:10:00.000 --> 00:10:02.000
その後、ベースに追加する必要があります。

00:10:02.000 --> 00:10:08.000
したがって、すべての共有アセットの「ローカライズ」ボタンをクリックしてください。

00:10:08.000 --> 00:10:12.000
わかりましたが、一方、あなたの文字列は共有されていません。

00:10:12.000 --> 00:10:14.000
文字列は1つの言語に属します。

00:10:14.000 --> 00:10:21.000
だから、あなたの弦は英語で、すべての弦はアラビア語になります。

00:10:21.000 --> 00:10:30.000
特定の言語の文字列でアプリをテストするには、SwiftUIでプレビュー環境を変更するか、アプリスキームの設定を変更することができます。

00:10:30.000 --> 00:10:37.000
デバイスがアプリがサポートしていない言語の場合、Foundationは最良の選択肢を見つけようとします。

00:10:37.000 --> 00:10:50.000
私の電話がメキシコスペイン語の場合、財団はラテンアメリカのスペイン語、次にスペイン語、そしてあなたのアプリ開発言語、例えば英語にフォールバックしようとします。

00:10:50.000 --> 00:10:57.000
最後に、文字列がサーバーから来る場合は、ユーザーの優先言語を尊重するようにしてください。

00:10:57.000 --> 00:10:58.000
すごい。

00:10:58.000 --> 00:11:02.000
私たちは、各言語が文字列のコレクションを持っているのを見てきました。

00:11:02.000 --> 00:11:08.000
これらの文字列は、「テーブル」と呼ばれるファイルにさらに整理できます。

00:11:08.000 --> 00:11:12.000
この機能を使用して、すべての文字列を好きなように整理できます。

00:11:12.000 --> 00:11:18.000
たとえば、各機能、または各画面のテーブルを持つことができます。

00:11:18.000 --> 00:11:25.000
これはデフォルトではオプションであるため、すべての文字列はLocalizableという名前のテーブルに置かれます。

00:11:25.000 --> 00:11:31.000
具体的には、これはすべての文字列がLocalizable.stringsという名前のファイルに格納されていることを意味します。

00:11:31.000 --> 00:11:36.000
これまでに学んだことを要約する例を見てみましょう。 これまでに学んだことを要約しましょう。

00:11:36.000 --> 00:11:45.000
変数、カスタマイズされたテーブル名、コメントを含む文字列を宣言する次のコードがあります。

00:11:45.000 --> 00:11:48.000
私のアプリがフランス語をサポートしているとしましょう。

00:11:48.000 --> 00:11:56.000
Xcodeでは、英語からのフランス語翻訳を含むUserProfile.stringsファイルが必要になります。

00:11:56.000 --> 00:12:03.000
慣習によって名付けられたフランスのリソースフォルダ、fr.lprojに保存されます。

00:12:03.000 --> 00:12:06.000
そのコメントはフランス語の翻訳者にとってとても役に立ちました。

00:12:06.000 --> 00:12:15.000
彼らはフェミニンを「場所」としてマークするために「e」を使用しました。チケットのフランス語はフェミニンです。

00:12:15.000 --> 00:12:19.000
物事を少し盛り上げて、バンドルについて話しましょう。

00:12:19.000 --> 00:12:24.000
このパラメータを使用すると、ターゲット間で文字列をロードできます。

00:12:24.000 --> 00:12:27.000
バンドルパラメータはデフォルトでメインです。

00:12:27.000 --> 00:12:30.000
あなた自身のアプリでは、それは必要ありません。

00:12:30.000 --> 00:12:32.000
メインはそのアプリです。

00:12:32.000 --> 00:12:39.000
アプリ拡張機能では、メインは独自の拡張機能を指すので、それも必要ありません。

00:12:39.000 --> 00:12:44.000
しかし、アプリとその拡張機能の間で文字列を共有したいとしましょう。

00:12:44.000 --> 00:12:49.000
拡張機能では、メインアプリのバンドルを提供する必要があります。

00:12:49.000 --> 00:12:54.000
そうすることで、2つの間の文字列の重複を回避できます。

00:12:54.000 --> 00:12:58.000
フレームワークから文字列を取得することもできます。

00:12:58.000 --> 00:13:12.000
その場合、アプリコードでバンドルを指定してフレームワークの文字列を直接タップするか、フレームワークが直接使用できる変数を提供します。

00:13:12.000 --> 00:13:21.000
これらのローカライズされた文字列変数は、フレームワーク独自のバンドルを指定することで、フレームワークで定義されています。

00:13:21.000 --> 00:13:31.000
モデルを振り返ってみると、今だけそれを更新して、アプリがフレームワークによって提供された文字列を読み込むようにします。

00:13:31.000 --> 00:13:41.000
フレームワークは文字列を定義し、翻訳が文字列ファイル内の独自のバンドル内に格納されていることを財団に通知します。

00:13:41.000 --> 00:13:49.000
このパラメータがなければ、文字列は代わりにホスティングアプリから取得され、見つかりません。

00:13:49.000 --> 00:13:51.000
実際には、このように見えます。

00:13:51.000 --> 00:13:55.000
テキストが保存されているバンドルを提供します。

00:13:55.000 --> 00:14:00.000
フレームワークは、独自のバンドルに文字列を探します。

00:14:00.000 --> 00:14:02.000
そうすれば、あなたのアプリは簡単です。

00:14:02.000 --> 00:14:06.000
この文字列は、単純なコード行で使用できます。

00:14:06.000 --> 00:14:19.000
さらに、この方法でフレームワークにローカリゼーションを実装する場合、「完了」を含むここに表示される文字列ファイルを作成する必要さえありません。では、その理由を見てみましょう。

00:14:19.000 --> 00:14:24.000
文字列を宣言して整理するために、コードでできることはすべて見てきました。

00:14:24.000 --> 00:14:30.000
しかし、私たちはあなたの翻訳を保持するファイルを実際に作成する方法を見ていません。

00:14:30.000 --> 00:14:34.000
実際には、これらの文字列ファイルを作成する必要がないことがわかりました。

00:14:34.000 --> 00:14:40.000
Xcodeは、すべての.stringsファイルを作成できます。

00:14:40.000 --> 00:14:46.000
エクスポートローカリゼーションを使用すると、コードを読み取り、すべての文字列を抽出します。

00:14:46.000 --> 00:14:49.000
文字列ファイルを維持する必要がないので、これは素晴らしいことです。

00:14:49.000 --> 00:14:55.000
UIでコーディングしたばかりの文字列をローカライズするのを忘れていた場合、これはあなたのためです。

00:14:55.000 --> 00:15:00.000
あなたが「ゲンストリング」に苦労しているなら、これもあなたのためです。

00:15:00.000 --> 00:15:07.000
今年、Xcode 13では、Swift文字列抽出のコンパイラサポートを追加しました。

00:15:07.000 --> 00:15:11.000
また、ワークスペースは完全にサポートされるようになりました。

00:15:11.000 --> 00:15:17.000
これにより、ロジックと翻訳の間の懸念がさらに分離されます。

00:15:17.000 --> 00:15:23.000
Xcodeは、以前に見たSwiftとFoundationのメソッドからテキストを検出して抽出します。

00:15:23.000 --> 00:15:30.000
これらのAPIをラップするカスタムコードがある場合、これはデフォルトでは機能しませんのでご注意ください。

00:15:30.000 --> 00:15:41.000
通常、メソッドやマクロを使用する必要はありませんが、本当に必要な場合は、ローカライズされた文字列マクロ名の下のビルド設定に追加できます。

00:15:41.000 --> 00:15:56.000
残りについては、Xcodeは、Info.plistで定義されたアプリ名とプライバシーの説明、および一般的にXcodeのインスペクタでローカライズされたすべての資産をローカライズするために抽出します。

00:15:56.000 --> 00:16:03.000
既存のローカリゼーションがある場合は、すでに新しいUIのXcodeのエクスポートに移行できます。

00:16:03.000 --> 00:16:08.000
新しい文字列は既存のファイルに自動的に追加されます。

00:16:08.000 --> 00:16:14.000
これは、自分のペースでプロジェクトを変換したい場合に最適です。

00:16:14.000 --> 00:16:19.000
ボーナスとして、UIテストのスクリーンショットが含まれるようになりました。

00:16:19.000 --> 00:16:31.000
ローカライザーは、文字列があるコンテキストを取得するのに最適で、App Storeでアプリのローカライズされたスクリーンショットを紹介するのは素晴らしいことです。

00:16:31.000 --> 00:16:41.000
さて、Xcodeはすべてのローカリゼーションカタログを抽出したので、今度は翻訳者が働く番だと思うでしょう。

00:16:41.000 --> 00:16:43.000
実は、君もできるよ！

00:16:43.000 --> 00:16:51.000
Xcode 13の新機能で、エクスポートされたローカリゼーションカタログは、Xcodeで直接表示および編集できます。

00:16:51.000 --> 00:16:56.000
生成された各ファイル（各テーブル）を左側のバンドルで見ることができます。

00:16:56.000 --> 00:17:03.000
そして、あなたの選択のために、あなたは含まれているすべての文字列、画像、およびファイルを見ることができます。

00:17:03.000 --> 00:17:10.000
文字列をフィルタリングしたり、並べ替えたり、コメントやスクリーンショットを見たり、翻訳したりすることもできます!

00:17:10.000 --> 00:17:14.000
これは、独自のアプリを開発して翻訳する場合に非常に便利です。

00:17:14.000 --> 00:17:19.000
文字列を自分で確認してバグ修正することもできます。

00:17:19.000 --> 00:17:30.000
翻訳者が翻訳された文字列カタログを返送するときは、Xcodeの製品メニューを使用してプロジェクトにインポートできます。

00:17:30.000 --> 00:17:37.000
そしてブーム！文字列ファイル、stringsdicts、およびその他のアセットが作成され、更新されます。

00:17:37.000 --> 00:17:45.000
コマンドラインに相当するものを使用して、継続的インテグレーションシステムで自動エクスポートとインポートを実行できます。

00:17:45.000 --> 00:17:55.000
定期的に呼び出すことで、プロジェクトは最新の文字列を取得し、新しいUIを翻訳する迅速なターンアラウンドを取得します。

00:17:55.000 --> 00:18:05.000
今年のセッション「SwiftUIアプリをローカライズする」で、強化されたワークフローの動作を確認し、入門セッションで詳細を学ぶことができます。

00:18:05.000 --> 00:18:06.000
それでおそれ！

00:18:06.000 --> 00:18:10.000
あなたは、あなたのアプリで弦がどのように生まれ、生きているかを目撃しました。

00:18:10.000 --> 00:18:14.000
最後に、より複雑な文字列を扱う方法を紹介します。 より複雑な文字列を扱う方法を紹介します。

00:18:14.000 --> 00:18:18.000
そして、あなたは私たちが店に持っている新機能を気に入ると確信しています。

00:18:18.000 --> 00:18:20.000
素晴らしいものから始めましょう!

00:18:20.000 --> 00:18:25.000
ローカライズが組み込まれるように、アトリビュート文字列を改善しました。

00:18:25.000 --> 00:18:30.000
Markdown構文のサポートで可能になりました!

00:18:30.000 --> 00:18:34.000
フォーマットを失うことなく、文字列をローカライズできるようになりました。

00:18:34.000 --> 00:18:40.000
1つの単語を太字にするだけで、危険なキャラクター操作はもうありません。

00:18:40.000 --> 00:18:57.000
そういえば、ここではアスタリスクを使って「完全」に重点を置いています。「ファンデーションの新機能」をチェックして、リンク、強調、モノスペーステキストなどを追加する方法を学ぶことをお勧めします。

00:18:57.000 --> 00:19:03.000
コードで定義した1つの文字列には、文字列ファイルに1つの翻訳があることがわかります。

00:19:03.000 --> 00:19:09.000
しかし、時には文字列が複数の表現を持つ必要があります。

00:19:09.000 --> 00:19:17.000
これは、定義したルールに適応する文字列のコレクションであるstringsdictファイルで可能です。

00:19:17.000 --> 00:19:22.000
例えば、いくつかのチケットを注文したい例を覚えていますか？

00:19:22.000 --> 00:19:31.000
英語では、複数のチケットがあり、1枚のチケットに「s」がない場合は、接尾辞として「s」を追加します。

00:19:31.000 --> 00:19:37.000
コードをシンプルで正しい状態に保つには、stringsdictを使用してこの複数のルールを定義する必要があります。

00:19:37.000 --> 00:19:43.000
アプリをローカライズすると、これらのルールは言語ごとに異なるからです。

00:19:43.000 --> 00:19:46.000
ロシア語のケースのいくつかを見てください。

00:19:46.000 --> 00:19:53.000
あなたはコードでそれに対処したくありません、それはむしろローカリゼーションが対処すべきものです。

00:19:53.000 --> 00:19:55.000
それをどのように実装するか見てみましょう。

00:19:55.000 --> 00:20:01.000
コードの変更は必要ありません。上記の既存のコードを引き続き使用します。

00:20:01.000 --> 00:20:08.000
まず、あなたのために作られている文字列ファイルと比較して、stringsdictは手動オプトインです。

00:20:08.000 --> 00:20:15.000
したがって、Xcodeテンプレートを使用して作成し、インスペクタで「ローカライズ」をクリックしたことを確認してください。

00:20:15.000 --> 00:20:20.000
さて、それはすべてあなたがコードで定義した文字列から始まります。

00:20:20.000 --> 00:20:27.000
コードに複数の複数の文字列がある場合は、それぞれにこのルートエントリを追加できます。

00:20:27.000 --> 00:20:30.000
内部では、提示された実際の値を定義します。

00:20:30.000 --> 00:20:34.000
この値は、検索置換メカニズムに従います。

00:20:34.000 --> 00:20:40.000
この例では、「チケット」という名前のトークンを1つ定義しました。

00:20:40.000 --> 00:20:44.000
それは完全な最後の文字列を保持します。

00:20:44.000 --> 00:20:59.000
トークン内にほとんどのテキストを含めるのが最善ですが、翻訳者がプレフィックス、サフィックスを追加したり、複数の変数がある場合にトークンを移動したりする必要がある場合、そのフィールドはローカライズ可能になります。

00:20:59.000 --> 00:21:04.000
OK、そのトークンはコードの1つの変数によって異なります。

00:21:04.000 --> 00:21:08.000
では、そのチケットトークンを定義しましょう。

00:21:08.000 --> 00:21:13.000
まず、いくつかの複数形化を行っていることを確認するだけです。

00:21:13.000 --> 00:21:20.000
次に、変数がCスタイルのフォーマッタdを持つ数値であることを示します。

00:21:20.000 --> 00:21:24.000
そして最後に、複数のルールを書くことができます。

00:21:24.000 --> 00:21:31.000
英語では、必要に応じて、ルール「1」と「その他」と「ゼロ」を宣言することができます。

00:21:31.000 --> 00:21:37.000
エントリごとに、チケットトークンの実際の価値を書きます。

00:21:37.000 --> 00:21:45.000
その後、チケットが3枚ある場合、英語では「other」を使用し、「Order 3 Tickets」が生成されます。

00:21:45.000 --> 00:21:49.000
%Dを数字の3に置き換えます。

00:21:49.000 --> 00:21:52.000
言語により多くのケースが必要な場合は、心配しないでください。

00:21:52.000 --> 00:21:55.000
Xcodeはエクスポート時にそれらを追加します。

00:21:55.000 --> 00:22:02.000
ロシア語では、既存のものの上に「少数」と「多く」が追加されます。

00:22:02.000 --> 00:22:03.000
それでおそれ！

00:22:03.000 --> 00:22:07.000
私たちの文字列は実行時に複数形になります。

00:22:07.000 --> 00:22:10.000
先に進む前に、1つのケースを呼び出したいと思います。

00:22:10.000 --> 00:22:18.000
Stringsdictは複数形に使用する必要がありますが、数字を含む文字列を対象としています。

00:22:18.000 --> 00:22:21.000
私たちは以前、英語の単数形の「one」のケースを見ました。

00:22:21.000 --> 00:22:31.000
確かにロシア語でもナンバーワンですが、21、31などにも使われています。

00:22:31.000 --> 00:22:42.000
その場合、1つだけに等しいだけなので、stringsdictを使用することは正しくありません。

00:22:42.000 --> 00:22:47.000
この例では、複数形はこれ、両方、またはすべてによって異なります。

00:22:47.000 --> 00:22:51.000
番号はありません。stringsdictは使用しないでください。

00:22:51.000 --> 00:23:01.000
すべての友人のために21枚のチケットを予約すると、ロシア語で「すべてのチケットを注文する」ではなく「このチケットを注文する」と想像してみてください。

00:23:01.000 --> 00:23:05.000
私はあなたに「私のお金はどこにありますか？」と尋ねます。

00:23:05.000 --> 00:23:15.000
代わりに、すべての言語で3つの文字列のそれぞれを正しく複数形にするために、このシンプルだが効果的なif/elseを使用してください。

00:23:15.000 --> 00:23:21.000
そして、それは複数サポートでしたが、stringsdictは文字列のより多くのバリアントタイプを処理できます。

00:23:21.000 --> 00:23:26.000
詳細については、関連するセッションをご覧ください。

00:23:26.000 --> 00:23:32.000
これは素晴らしいことですが、私たちはあなたにもっと簡単な方法を提供したかったのです。

00:23:32.000 --> 00:23:36.000
はい、財団は今年あなたのために文法のやり方を学びました!

00:23:36.000 --> 00:23:49.000
属性文字列にMarkdownサポートを追加すると、infect属性でこの新しい形式を使用すると、このボタンのように実行時に適切な値が計算されます。

00:23:49.000 --> 00:23:57.000
これはiOS 15とmacOS Montereyの素晴らしい新機能で、現在一部の言語で利用可能です。

00:23:57.000 --> 00:24:02.000
より多くの制御が必要な場合は、stringsdictを使用できます。

00:24:02.000 --> 00:24:05.000
私たちは複数のサポートを追加するのをやめませんでした。

00:24:05.000 --> 00:24:10.000
私たちは、ソフトウェア文字列をより包括的にしたかった。

00:24:10.000 --> 00:24:15.000
例えば、アプリがユーザーを歓迎するとき、それは英語ではかなり簡単です。

00:24:15.000 --> 00:24:23.000
しかし、ユーザーの住所条件に依存するため、スペイン語ではありません。

00:24:23.000 --> 00:24:31.000
これまでは、パーソナライズされていない文字列を提示しなければなりませんでした。これは正しいですが、ほとんどのスペインのユーザーには高尚です。

00:24:31.000 --> 00:24:35.000
文字通り、「私たちはあなたを歓迎します。」

00:24:35.000 --> 00:24:39.000
では、ユーザーのために文字列をパーソナライズできるとしたらどうでしょうか?

00:24:39.000 --> 00:24:43.000
私たちの新しいマークダウン表記法で、あなたは今それを行うことができます!

00:24:43.000 --> 00:24:49.000
文字列は、デバイスの言語設定で選択したアドレスの用語に従います。

00:24:49.000 --> 00:25:04.000
したがって、女性で言及されたいユーザーのための「Bienvenida」、男性的な「Bienvenido」、そして私たちが知らない場合は、既存の抑揚の代替手段を使用します。

00:25:04.000 --> 00:25:11.000
複数形とアドレスの用語のインライン抑揚は、コードまたは翻訳のいずれかで定義できます。

00:25:11.000 --> 00:25:19.000
私たちは、選択した言語へのこの新しい追加に非常に興奮しており、あなたのアプリがそれを使用するのを見るのが待ちきれません。

00:25:19.000 --> 00:25:25.000
最後に、私たちは今日、ローカライズ可能な文字列を書くことができるすべての方法を見ました。

00:25:25.000 --> 00:25:32.000
しかし、データを提示したい場合は、実際にフレームワークにそれらを書かせるべきです。

00:25:32.000 --> 00:25:39.000
当社のフォーマッタは、言語と地域の何百もの組み合わせ、およびさまざまなタイプとユニットを処理します。

00:25:39.000 --> 00:25:44.000
だから、ハードコードしないでください。ハードワークをしましょう。

00:25:44.000 --> 00:25:49.000
そして、今年からSwiftでフォーマッタを採用することがこれまで以上に簡単になりました。

00:25:49.000 --> 00:25:55.000
文字列補間でインラインで使いやすくしました。

00:25:55.000 --> 00:26:03.000
今年の「ファンデーションの新機能」をチェックして、新しいお気に入りのAPIを見つけて、今日見たすべてのものの詳細を入手してください。

00:26:03.000 --> 00:26:10.000
以前のリリースに展開する必要がある場合や、フォーマッタの詳細が必要な場合は、昨年のセッションを確認してください。

00:26:10.000 --> 00:26:21.000
さて、今日取り除いてほしいのは、最新のAPIを使用してコードを書くと、Xcodeがすべての文字列を生成するということです。

00:26:21.000 --> 00:26:30.000
バンドル間で文字列を整理する方法を見て、文法と書式設定を簡単にするための新しいAPIを発見しました。

00:26:30.000 --> 00:26:37.000
これらすべてのテクニックに従えば、新しい言語を追加すると、コードの変更は必要ありません!

00:26:37.000 --> 00:26:40.000
最後に、常にテストします。

00:26:40.000 --> 00:26:49.000
文字列のローカライズにどれだけの労力を費やしても、アプリをテストして、すべての言語でうまく動作することを確認する必要があります。

00:26:49.000 --> 00:26:54.000
それで、あなたの完全にローカライズされたアプリでコンサートを予約するのが待ちきれません。

00:26:54.000 --> 00:26:58.000
WWDCの残りの部分を楽しんでください、ご覧いただきありがとうございます。

00:26:58.000 --> 23:59:59.000
♪

