WEBVTT

00:00:02.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:10.000
こんにちは、ようこそ。

00:00:10.000 --> 00:00:12.000
App Clipsチームのエンジニア、ブライアン・ゴールドバーグです。

00:00:12.000 --> 00:00:17.000
軽くて高速なアプリクリップを構築するための素晴らしいヒントやテクニックをお見せするのが待ちきれません。

00:00:17.000 --> 00:00:19.000
始めましょう。

00:00:19.000 --> 00:00:25.000
アプリクリップは、顧客がアプリが提供するものにすばやくアクセスして体験するための素晴らしい方法です。

00:00:25.000 --> 00:00:32.000
アプリクリップは、必要な瞬間に発見され、ダウンロードできるアプリの小さな部分です。

00:00:32.000 --> 00:00:34.000
アプリクリップはOSに深く統合されています。

00:00:34.000 --> 00:00:43.000
アプリクリップコード、QRコードをスキャンするか、NFCタグをタップすることで、Safariやメッセージだけでなく、現実の世界でも呼び出すことができます。

00:00:43.000 --> 00:00:46.000
アプリクリップは、マップやSiriの提案にも表示されています。

00:00:46.000 --> 00:00:54.000
このセッションには、顧客に素晴らしい体験を構築し、提供するのに役立つベストプラクティスとトラブルシューティングのヒントが満載されています。

00:00:54.000 --> 00:00:58.000
サイズ制限の下であなたのクリップを手に入れるための計画をお見せします。

00:00:58.000 --> 00:01:05.000
アプリクリップがウェブページに表示されていないか、コードをスキャンしたときにアプリクリップカードが表示されない可能性があります。

00:01:05.000 --> 00:01:14.000
おそらく、新機能の採用に伴う追加の複雑さを引き受けながら、コードベースの品質を維持するためのヒントを探しています。

00:01:14.000 --> 00:01:20.000
そして、App Clipsに特異的でユニークな、どのような機能を活用できるかを知りたいかもしれません。

00:01:20.000 --> 00:01:33.000
ゼロから構築する場合でも、既存のアプリにクリップターゲットを追加する場合でも、開発者が日常的に直面する現実世界の問題を説明し、より良いクリップやアプリを構築するための実用的な次のステップを提供します。

00:01:33.000 --> 00:01:40.000
ユーザーがモバイルネットワークのカバレッジが良好な地域にいる場合でも、ダウンロード速度は異なる場合があります。

00:01:40.000 --> 00:01:49.000
アプリクリップをすぐにオンデマンドで提供できるようにするために、アプリクリップの最大サイズは限られています。

00:01:49.000 --> 00:01:54.000
したがって、開発者として、サイズに合わせてコンテンツを最適化することが重要です。

00:01:54.000 --> 00:02:02.000
あなたのクリップがオンデマンドで配信できるほどコンパクトであるかどうか、開発の早い段階で、そして開発中に頻繁に知っておくのは良いことです。

00:02:02.000 --> 00:02:09.000
あなた方の多くは、ソフトウェア開発におけるプロファイリングと最適化の反復プロセスに精通しています。

00:02:09.000 --> 00:02:17.000
Xcodeを使用してサイズレポートを生成し、デバイスバリアントごとにIPAをエクスポートできるプロセスを紹介したいと思います。

00:02:17.000 --> 00:02:24.000
次に、アプリクリップのサイズを小さくするために実行できる一連の基本および高度な最適化を説明します。

00:02:24.000 --> 00:02:30.000
目標は、クリップが制限を超えた場合、アプリの提出時間に驚かされることを避けることです。

00:02:30.000 --> 00:02:33.000
私たちが見るべき楽しい例をまとめました。

00:02:33.000 --> 00:02:38.000
これは、サイズ制限を超える多くのgotchasを持つFrutaサンプルのバージョンです。

00:02:38.000 --> 00:02:41.000
Gotchasは、いくつかの重要なポイントを説明するのが簡単です。

00:02:41.000 --> 00:02:49.000
あなたのアプリは間違いなくより複雑で、さらに多くの機能を持っているので、さらなる探求の出発点として私の例を使ってください。

00:02:49.000 --> 00:03:00.000
Xcodeを起動して、サイズレポートを生成し、IPAファイルをエクスポートする手順を実行し、これらのgotchasを発見し、それらを一緒に修正する方法を学びましょう。

00:03:00.000 --> 00:03:04.000
まず、完全なアプリスキームを選択します。

00:03:04.000 --> 00:03:09.000
次に、[製品]メニューに移動し、[アーカイブ]を選択します。

00:03:09.000 --> 00:03:16.000
これは、スキームエディタで指定された設定を使用してプロジェクトを構築します。

00:03:16.000 --> 00:03:19.000
主催者が開いたら、[アプリの配布]をクリックします。

00:03:19.000 --> 00:03:22.000
開発を選択してください。

00:03:22.000 --> 00:03:28.000
次に、アプリクリップを選択します。

00:03:28.000 --> 00:03:33.000
[アプリ シンニング] ドロップダウンで、互換性のあるすべてのデバイスのバリアントを選択します。

00:03:33.000 --> 00:03:37.000
ビットコードからの再構築がチェックされていることを確認してください。

00:03:37.000 --> 00:03:42.000
アーカイブの準備が完了したら、[エクスポート]をクリックします。

00:03:42.000 --> 00:03:46.000
次に、エクスポートするファイルシステム上の場所を選択します。

00:03:46.000 --> 00:03:52.000
次に、Finderでエクスポートフォルダを開きます...

00:03:52.000 --> 00:03:57.000
そして、App Thinning Size Report.txtを開きます。

00:03:57.000 --> 00:04:01.000
各デバイスバリアントのセクションがあります。

00:04:01.000 --> 00:04:06.000
各セクションの最後から2行目は、そのバリアントの非圧縮サイズを教えてくれます。

00:04:06.000 --> 00:04:08.000
それが私たちが興味を持っていることです。

00:04:08.000 --> 00:04:11.000
サイズを見ると、これは私に2つのことを教えてくれます。

00:04:11.000 --> 00:04:13.000
1つ、私はサイズ制限を超えています。

00:04:13.000 --> 00:04:21.000
第二に、すべてのデバイスのバリエーションがほぼ同じサイズであるため、アプリのシンニングの影響は見当たりません。

00:04:21.000 --> 00:04:27.000
サイズレポートを閉じて、その理由をもう少し深く掘り下げてみましょう。

00:04:27.000 --> 00:04:29.000
アプリのサブフォルダを開きます。

00:04:29.000 --> 00:04:35.000
バリアントIPAの拡張子の1つを.zipに変更し、確認します。

00:04:35.000 --> 00:04:37.000
ダブルクリックして解凍します。

00:04:37.000 --> 00:04:45.000
ペイロードフォルダを開き、Controlキーを押しながらクリックしてパッケージの内容を表示します。

00:04:45.000 --> 00:04:46.000
よく見てみましょう。

00:04:46.000 --> 00:04:51.000
私の画像は個々のバンドルリソースのようです。

00:04:51.000 --> 00:04:56.000
これらを資産カタログに入れれば、スペースを節約できるかもしれません。

00:04:56.000 --> 00:05:04.000
インストール可能な製品に属さないドキュメントのzipとREADMEファイルが表示されます。

00:05:04.000 --> 00:05:06.000
私のクリップで使用されているフレームワークがあります。

00:05:06.000 --> 00:05:11.000
それもある程度のスペースを占有しているに違いない。

00:05:11.000 --> 00:05:18.000
いくつかのローカリゼーションフォルダが存在し、チェックを外したままにしておくと、これらのファイルが増加することがあることを知っています。

00:05:18.000 --> 00:05:22.000
コンパイルされた実行可能ファイルは比較的小さいです...

00:05:22.000 --> 00:05:25.000
しかし、それをさらに小さくする方法があるかもしれません。

00:05:25.000 --> 00:05:27.000
少しでも役に立ちます。

00:05:27.000 --> 00:05:31.000
続けて、これらの問題のいくつかを解決するために何ができるか見てみましょう。

00:05:31.000 --> 00:05:40.000
サイズレポートを生成し、IPAを調べるプロセスは、アプリクリップのサイズを小さくするために実行できるいくつかの手順を特定したため、非常に役に立ちました。

00:05:40.000 --> 00:05:45.000
まずいくつかの基本的なステップから始めて、より高度なテクニックに移りましょう。

00:05:45.000 --> 00:06:00.000
ビルド設定を再確認し、アセットカタログを使用する利点を確認し、属していない最終製品への道からファイルを除外し、コードと設定を確認し、サイズを縮小するためのリファクタリングを行います。

00:06:00.000 --> 00:06:09.000
私たちがカバーする最適化は、アプリとアプリクリップの両方に適用されるので、これらのヒントを両方のタイプの製品に自由に適用してください。

00:06:09.000 --> 00:06:11.000
では、各トピックをより詳細に探りましょう。

00:06:11.000 --> 00:06:17.000
App Clipパッケージのコンパイルされたコード部分は、確かにクリップのサイズへの最大の貢献者ではありませんでした。

00:06:17.000 --> 00:06:20.000
それは間違いなく資産であり、私たちはすぐに手に入れるでしょう。

00:06:20.000 --> 00:06:22.000
しかし、少しでも役に立ちます。

00:06:22.000 --> 00:06:30.000
デフォルトでは、Xcodeは最小で最速の最適化設定を使用してビルドされますが、それが私のプロジェクトで設定されていることを確認するために再確認しましょう。

00:06:30.000 --> 00:06:36.000
完全なアプリがアクティブなスキームとして設定されていることを確認し、Optionキーを押しながらクリックしてスキーム設定を表示します。

00:06:36.000 --> 00:06:42.000
アーカイブビルドはリリースするように設定する必要がありますが、ある時点で変更し、元に戻すのを忘れたようです。

00:06:42.000 --> 00:06:48.000
私はまた、ビルド設定で少し実験していて、リリース最適化レベルをデフォルトから外しました。

00:06:48.000 --> 00:06:55.000
小さなバイナリサイズと高速ランタイム実行の最適な組み合わせを使用するように、元に戻しましょう。

00:06:55.000 --> 00:07:03.000
ほとんどの場合、私の場合と同様に、画像、オーディオ、ビデオなどのアセットが最も多くのスペースを占有します。

00:07:03.000 --> 00:07:12.000
これらのアセットがApp Clipのサイズに与える影響を減らすために取ることができる最も重要なステップは、アセットカタログを使用することです。これには2つの理由があります。

00:07:12.000 --> 00:07:19.000
1つは、アセットカタログに追加するメディアは、Xcodeビルドプロセスの一部として自動的に最適化されます。

00:07:19.000 --> 00:07:28.000
そして第二に、顧客があなたのアプリやクリップをダウンロードすると、彼らがダウンロードした製品は、自分のデバイスに適した資産のみを含むように十分に小さくなります。

00:07:28.000 --> 00:07:33.000
これはアプリシンニングとしても知られており、私たちは確かにそれを利用すべきです。

00:07:33.000 --> 00:07:37.000
私のプロジェクトでは、私は本当にそれらの画像をアセットカタログに入れるべきでした。

00:07:37.000 --> 00:07:39.000
私たちは実際にさらにうまくやることができます。

00:07:39.000 --> 00:07:49.000
2番目のアセットカタログを作成し、アプリとアプリクリップの間で共有されているすべての画像をこのカタログに移動します。

00:07:49.000 --> 00:07:57.000
両方のカタログを並べて持ちましょう。

00:07:57.000 --> 00:08:06.000
アイコンと色を共有カタログに移動します。

00:08:06.000 --> 00:08:11.000
次に、成分とスムージーの画像を共有カタログに入れます。

00:08:11.000 --> 00:08:19.000
レシピ画像は完全なアプリでのみ必要なので、アプリクリップのサイズにカウントされないように、共有されていないカタログに入れます。

00:08:19.000 --> 00:08:24.000
アセットライブラリにコピーした画像を必ず削除します。

00:08:24.000 --> 00:08:29.000
そして最後に、ターゲットのメンバーシップエディタを使用して、App Clipから共有されていない資産カタログを除外します。

00:08:29.000 --> 00:08:38.000
アセットカタログを深く掘り下げるには、アプリのストレージの最適化とアプリアセットの最適化に関するセッションをご覧ください。

00:08:38.000 --> 00:08:48.000
以前、ファイルシステムでIPAを検査したところ、READMEファイルやzipを含むドキュメントなど、属していないものがいくつかあります。

00:08:48.000 --> 00:08:55.000
Xcodeのターゲットメンバーシップエディタを使用して、これらのファイルをすべてのビルド製品から除外しましょう。

00:08:55.000 --> 00:09:02.000
実行されるタスクに必要なコードのみをApp Clipターゲットに含めていることを確認してください。

00:09:02.000 --> 00:09:09.000
ビルドフェーズを見て、App Clipに貢献しているすべてのソースファイルの概要を把握すると便利です。

00:09:09.000 --> 00:09:15.000
不必要に見えるものがあれば、ソースのリストから削除して再構築します。

00:09:15.000 --> 00:09:23.000
Frutaのレシピと報酬機能は、完全なアプリには必要ですが、App Clipには必要ではないので、それらのファイルを削除しましょう。

00:09:23.000 --> 00:09:25.000
コンパイラに手伝っててもらうこともできます。

00:09:25.000 --> 00:09:35.000
ビルドエラーがある場合は、ファイルが必要だったか、削除すべきものがあるか、App Clipターゲットから条件付きでコンパイルする必要があるコードがあるかもしれません。

00:09:35.000 --> 00:09:41.000
時間が経つにつれて、ローカライズされた文字列ファイルは、重複や未使用の文字列で膨らむ可能性があります。

00:09:41.000 --> 00:09:46.000
文字列ファイルを検査し、不要なものはすべて削除します。

00:09:46.000 --> 00:09:56.000
アセットカタログで行ったのと同様に、アプリクリップに完全なアプリのローカライズされた文字列を含めないように、専用の文字列ファイルを作成できます。

00:09:56.000 --> 00:10:03.000
アプリクリップの提出準備をするために、今日実装できる基本的な最適化をいくつか説明しました。

00:10:03.000 --> 00:10:11.000
さて、この反復プロセスの一環として、もう一度測定し、サイズレポートを見て、まだ必要な場所にいないとします。

00:10:11.000 --> 00:10:12.000
大丈夫です。

00:10:12.000 --> 00:10:18.000
私はあなたが考慮すべきいくつかの高度な最適化戦略を持っています。

00:10:18.000 --> 00:10:23.000
まず、外部の依存関係を評価し、そのサイズを考慮に入れます。

00:10:23.000 --> 00:10:30.000
アプリクリップはアプリの一口サイズのバージョンなので、クリップの機能に必要なものだけをリンクしていることを確認してください。

00:10:30.000 --> 00:10:35.000
アプリクリップのサイズに追加されていたSmoothyAccountLoginフレームワークを覚えていますか？

00:10:35.000 --> 00:10:45.000
ほとんどの場合、目標を達成するのに役立つAppleのフレームワークがすでにOSに統合されています。

00:10:45.000 --> 00:10:57.000
これらの組み込みフレームワークの1つを使用することは無料で、アプリとアプリクリップがより軽く、より速くなります。つまり、より速くダウンロードし、より速く起動し、顧客が手元のタスクをより迅速に完了できるようにします。

00:10:57.000 --> 00:11:02.000
Appleでサインインを使用すると、ユーザーはApple IDだけでサービスに簡単にサインインできます。

00:11:02.000 --> 00:11:08.000
支払いの場合、Apple Payは、あなた、開発者、そして顧客の両方にとって迅速かつ簡単です。

00:11:08.000 --> 00:11:11.000
ネットワークを経由で通信するには、NSURLSessionを使用してください。

00:11:11.000 --> 00:11:15.000
3Dグラフィックスには、RealityKitとMetalを活用してください。

00:11:15.000 --> 00:11:20.000
より詳細な認証フローについては、ASWebAuthenticationSessionをご覧ください。

00:11:20.000 --> 00:11:25.000
アプリクリップのサイズが制限を超えるのは、ほとんどの場合、アセットであり、コードではありません。

00:11:25.000 --> 00:11:29.000
多くの場合、これらの資産は画像です。

00:11:29.000 --> 00:11:36.000
基本的な手順では、組み込みの最適化とアプリのシンニングを利用するために、すべての画像をアセットカタログに移動しました。

00:11:36.000 --> 00:11:42.000
時にはそれだけでは不十分で、画像のサイズを小さくするためにさらに行動を起こす必要があります。

00:11:42.000 --> 00:11:49.000
ソース画像を保存するときに使用するフォーマットとオプションは、サイズと品質の両方に大きな影響を与えることがよくあります。

00:11:49.000 --> 00:11:51.000
では、どのように最良の選択をしますか?

00:11:51.000 --> 00:12:02.000
一般的に言えば、PNG画像はJPEG画像よりも多くのスペースを消費するので、フォーマットが透明性を提供する特定の機能が必要な場合は、PNGを使用してください。

00:12:02.000 --> 00:12:07.000
または、JPEGの非可逆圧縮が許容できない品質の低下をもたらす場合。

00:12:07.000 --> 00:12:11.000
これらの例には、高周波機能、鮮明なエッジ、および定義されたハイライトが含まれています。

00:12:11.000 --> 00:12:18.000
PNGのロスレス圧縮は、これらの機能をJPEGよりもはるかに良く保持します。

00:12:18.000 --> 00:12:24.000
そして、PNGをテーマにしている間は、写真以外の素材にはPNG8を検討してください。

00:12:24.000 --> 00:12:29.000
右側の画像は、ファイルサイズを大幅に縮小するためにPNG8として保存されました。

00:12:29.000 --> 00:12:35.000
画像をエクスポートするときは、並べて比較して、最適化が持ちこたえていることを確認してください。

00:12:35.000 --> 00:12:45.000
色深度の減少は多くのスペースを節約できますが、量子化アーティファクトに悩まされない特定の画像にのみ適しています。

00:12:45.000 --> 00:12:51.000
写真素材の場合、スペースを節約する必要がある場合は、JPEGを使用し、非可逆圧縮に少し傾けてください。

00:12:51.000 --> 00:12:56.000
画像を保存する際に、コンテンツ作成ツールのデフォルトを受け入れる必要はありません。

00:12:56.000 --> 00:13:03.000
私の場合、品質が著しく低下することなく、ファイルサイズを大幅に縮小しました。

00:13:03.000 --> 00:13:11.000
さまざまな最適化の下で画質が維持されるように、プロジェクトで使用できるかもしれない小さなトリックをお見せしましょう。

00:13:11.000 --> 00:13:17.000
私は一時的にパイナップルをより高い圧縮率として保存されたマンゴーに置き換えました。

00:13:17.000 --> 00:13:25.000
これにより、実際のアプリで簡単なA / B比較を行い、変更が品質の低下をもたらさなかったことを確認できます。

00:13:25.000 --> 00:13:30.000
ビデオの場合は、HEVCのような最新の規格を使用してエンコードします。

00:13:30.000 --> 00:13:37.000
原則として、AACまたはMP3コーデックを使用してオーディオを圧縮し、ビットレートの低下を試します。

00:13:37.000 --> 00:13:45.000
多くの場合、超高ビットレートは必要ではなく、ビットレートの低いクリップは品質の顕著な低下をもたらすことはありません。

00:13:45.000 --> 00:13:59.000
インターフェイスコントロール、ロゴ、アイコンなどの特定の種類の画像の場合、SVG形式で表すと、大幅なスペースの節約につながる可能性があり、ベクター形式であるため、どのサイズでも素晴らしくレンダリングされます。

00:13:59.000 --> 00:14:05.000
SVG形式といえば、私たちはそれをとても愛しているので、SFシンボルをバックアップするためにそれを選びました。強くお勧めします。

00:14:05.000 --> 00:14:09.000
2,000以上の設定可能なシンボルから選択できます。

00:14:09.000 --> 00:14:18.000
テキストラベルと自動的に整列する幅広いウェイトとスケールがあり、ダイナミックタイプは箱から出してすぐにサポートされています。

00:14:18.000 --> 00:14:22.000
プロジェクトでSFシンボルを使い始めるためのコードをいくつか紹介します。

00:14:22.000 --> 00:14:28.000
このコードスニペットは、同様のテキストスタイルをラベルとシンボル画像の両方に適用する方法を示しています。

00:14:28.000 --> 00:14:33.000
ベースライン制約は、ラベルとシンボル画像を完璧に整列させます。

00:14:33.000 --> 00:14:41.000
アセットカタログに画像のいくつかのバリエーションを含める代わりに、1つのベースイメージを含め、実行時に必要なバリエーションを構築します。

00:14:41.000 --> 00:14:46.000
これがどのように実践されているかの素晴らしい例については、Frutaのサンプルをチェックしてください。

00:14:46.000 --> 00:15:00.000
オレンジ色の成分のプレゼンテーションごとに別々の画像を使用する代わりに、このコレクションビューに1つ、垂直テキストとコントロールを備えたフル画像ビューにもう1つ、成分カードバックに3つ...

00:15:00.000 --> 00:15:05.000
この1つの画像は、3つの異なる用途のバッキングアセットとして機能します。

00:15:05.000 --> 00:15:10.000
その結果、実行時にバリエーションを構築することで、大幅なスペースの節約が達成されます。

00:15:10.000 --> 00:15:21.000
最後に、他のすべての手順を完了し、クリップのサイズ制限を超えるアセットがまだある場合は、コンテンツ配信ネットワークからそれらのアセットを怠惰にロードすることを検討してください。

00:15:21.000 --> 00:15:34.000
たとえば、良質だが解像度の低いプレースホルダアセットをApp Clipで出荷し、新しいAsyncイメージAPIを使用して、起動後にこれらのアセットを徐々に置き換えます。

00:15:34.000 --> 00:15:37.000
詳細については、SwiftUIセッションの新機能を確認してください。

00:15:37.000 --> 00:15:48.000
そしてヒント：ネットワークリンクコンディショナーを使用して、さまざまな帯域幅シナリオでApp Clipをテストし、顧客が手元のタスクを完了するのに遅延が発生していないことを確認します。

00:15:48.000 --> 00:15:52.000
これらの高度な最適化により、最初のトピックの終わりに達しました。

00:15:52.000 --> 00:16:00.000
アプリのサイズを小さくするために、開発者ドキュメントでさらに探求し、より多くのテクニックを発見することができます。

00:16:00.000 --> 00:16:07.000
App Clipを本番環境にリリースし、SafariでWebサイトを表示するときに期待どおりに提供されていないとします。

00:16:07.000 --> 00:16:14.000
あるいは、QRコードをスキャンして、App Clipカードを見る代わりにSafariに誘導されたのかもしれません。

00:16:14.000 --> 00:16:22.000
一般的に、これらの問題は、エクスペリエンスの登録と関連するドメイン構成といういくつかの異なるバケットに分類されます。

00:16:22.000 --> 00:16:28.000
簡単な用語の復習をしましょう。その後、問題を解決するために実行できるいくつかの手順を説明します。

00:16:28.000 --> 00:16:32.000
App Store Connectでは、2種類のエクスペリエンスを追加できます。

00:16:32.000 --> 00:16:35.000
すべてのアプリクリップにはデフォルトのエクスペリエンスが必要です。

00:16:35.000 --> 00:16:44.000
デフォルトのエクスペリエンスでは、SafariのWebページから呼び出されたとき、または誰かがメッセージでWebページへのリンクを送信したときに、App Clipカードに入力するメタデータを指定します。

00:16:44.000 --> 00:16:55.000
QRスキャン、NFC、アプリクリップコードなどの物理的な呼び出しを利用するには、高度なエクスペリエンスを追加する必要があります。

00:16:55.000 --> 00:17:03.000
登録はデバイスに伝播するのに時間がかかるため、App Store Connectで行われた変更はすぐには利用できないことに注意してください。

00:17:03.000 --> 00:17:11.000
体験の登録について詳しくは、App Store Connectの新機能のセッションと、App Clipの構成とリンクを参照してください。

00:17:11.000 --> 00:17:20.000
App Clipを表示するUIを表示する前に、OSは呼び出しドメインがApp Clipに検証可能に関連付けられていることを確認します。

00:17:20.000 --> 00:17:33.000
言い換えれば、Safariで表示されたURL、またはQRコードでエンコードされたURLは、資格とAASAファイルとアプリとアプリクリップとの安全な関連付けを持っている必要があります。

00:17:33.000 --> 00:17:37.000
これが正しく設定されていない場合、クリップは表面化されません。

00:17:37.000 --> 00:17:47.000
この安全な関連付けの確立の詳細については、「ユニバーサルリンクセッションの新機能」と「App Clipsセッションの設定とリンク」を参照してください。

00:17:47.000 --> 00:17:55.000
すべてを設定し、Safariをチェックして、App Clipカードがこのようにインラインで表示されることを期待しているとします。

00:17:55.000 --> 00:18:00.000
しかし、残念ながら、あなたはあなたのウェブページを見るだけで、他には何も表示されません。

00:18:00.000 --> 00:18:05.000
では、何が問題なのか、どのようなトラブルシューティング手順を踏むことができますか?

00:18:05.000 --> 00:18:11.000
まず、メタタグの構文を確認し、このテンプレートに似ていることを確認してください。

00:18:11.000 --> 00:18:18.000
黄色のプレースホルダを、それぞれ完全なアプリのApp Store IDとApp ClipのbundleIDに置き換えます。

00:18:18.000 --> 00:18:22.000
メタタグが正しく構築されていることを確認するために使用するテクニックを紹介します。

00:18:22.000 --> 00:18:27.000
Safariでウェブページに移動し、ウェブインスペクタを開きます。

00:18:27.000 --> 00:18:30.000
ヘッドエレメントを展開し、ソースをよく見てください。

00:18:30.000 --> 00:18:40.000
次に、ノード属性をチェックして、メタタグが正しく解析され、App Clip bundleIDがXcodeとApp Store Connectに表示されているものとまったく同じであることを確認します。

00:18:40.000 --> 00:18:44.000
転送またはリダイレクトはドメインの検証に干渉していますか?

00:18:44.000 --> 00:18:53.000
ドメイン検証機構に関する限り、Example.comはwww.example.comと同等とは見なされません。

00:18:53.000 --> 00:19:07.000
ここで覚えておくべき重要なことは、コンテンツを提供するドメイン、リダイレクトチェーンの最後にあるドメインは、AASAファイルを提供し、関連するドメインのエンタイトルメントに含まれるドメインでなければならないということです。

00:19:07.000 --> 00:19:14.000
また、プライベートブラウジングが有効になっている場合、Safariは完全なアプリクリップカードやスマートアプリバナーを表示しないことを忘れないでください。

00:19:14.000 --> 00:19:22.000
それでも立ち往生している場合は、ASCポータルでAASAが検証に合格していることを確認してください。

00:19:22.000 --> 00:19:29.000
SWCutilコマンドラインツールを使用して、予想される場所でWebサイトからAASAファイルを取得できます。

00:19:29.000 --> 00:19:33.000
これは、App Store Connectによって実行される操作と非常によく似ています。

00:19:33.000 --> 00:19:39.000
これを使用して、App Store Connectがファイルを取得するのを妨げるエラーがないことを確認できます。

00:19:39.000 --> 00:19:45.000
applicationIDの代わりに指定されたbundleIDなどの一般的な間違いがないか、JSON出力を確認してください。

00:19:45.000 --> 00:19:52.000
詳細については、App Store Connectセッションの新機能とユニバーサルリンクセッションの新機能をチェックしてください。

00:19:52.000 --> 00:20:01.000
今、アプリクリップコード、QRコード、NFCタグなどの物理的な呼び出しのために、ここに期待される経験があります。

00:20:01.000 --> 00:20:09.000
完全に設定されていない場合、顧客がカメラでアプリクリップカードを見る代わりに、ウェブページがSafariで提供されます。

00:20:09.000 --> 00:20:17.000
多くの場合、これが発生する理由は、物理コードにエンコードされたURLに対して高度なエクスペリエンスが作成されていないためです。

00:20:17.000 --> 00:20:30.000
QRコードのURLがウェブサイトのURLと同じで、エクスペリエンスがSafariで完璧に表示される場合でも、App Store Connectで高度なエクスペリエンスを作成して、物理コードを強化する必要があります。

00:20:30.000 --> 00:20:34.000
Safariの呼び出しをトラブルシューティングしていたときのこのスライドを覚えていますか？

00:20:34.000 --> 00:20:39.000
ウェブトラフィックの場合、ドメインの検証の前にすべてのリダイレクトが続きます。

00:20:39.000 --> 00:20:46.000
物理的なコードのドメイン検証の処理方法における微妙でありながら重要な違いをお知らせしたいと思います。

00:20:46.000 --> 00:20:55.000
QRコードのURLで一意のドメインを使用していて、プラットフォーム間で一貫性を提供するためにそれをウェブサイトに転送しているとします。

00:20:55.000 --> 00:21:01.000
あなたはすでに、ウェブから直接入力する顧客のために、そのドメインからAASAファイルを提供しています。

00:21:01.000 --> 00:21:03.000
さて、微妙な違いが生まれます。

00:21:03.000 --> 00:21:13.000
コードスキャンでは、App Clipのエンタイトルメントに正確なドメインを追加し、このドメインからもAASAファイルを提供する必要があります。

00:21:13.000 --> 00:21:18.000
この背後にある理由は、物理的なコードをスキャンしているユーザーに迅速なフィードバックを与えるためです。

00:21:18.000 --> 00:21:24.000
また、通常、リダイレクトチェーンに従うことになるネットワーク要求の実行を避けます。

00:21:24.000 --> 00:21:31.000
高度なエクスペリエンスやサイトの関連付けの変更は、デバイスに伝播するのに時間がかかります。

00:21:31.000 --> 00:21:41.000
スキャンしたURLが高度なエクスペリエンスとして追加されたことを確認しても、App Clipカードが表示されない場合は、開発者設定でエクスペリエンスキャッシュをクリアしてみてください。

00:21:41.000 --> 00:21:43.000
次のトピックに進みます。

00:21:43.000 --> 00:21:50.000
あなたはプロジェクトでいくつかの追加の複雑さを引き受けました、そして利点は、あなたが今より近代的でプラットフォームに従う経験を持っていることです。

00:21:50.000 --> 00:22:01.000
ここまで達成するために一生懸命働いてきた品質のレベルを維持しながら、余分な機能を受け入れるために取ることができるいくつかのステップをお見せしたいと思います。

00:22:01.000 --> 00:22:05.000
基本的なレストランアプリの機能を示す図を見てみましょう。 基本的なレストランアプリの機能機能を示す図を見てみましょう。

00:22:05.000 --> 00:22:10.000
この例では、お客様はレストランのメニューを閲覧することから始めます。

00:22:10.000 --> 00:22:14.000
次に、ハンバーガーやカクテルをカスタマイズしてからチェックアウトできます。

00:22:14.000 --> 00:22:20.000
その後、注文状況と注文ピックアップのオプションが表示されます。

00:22:20.000 --> 00:22:33.000
さて、レストランが2つの機能を追加して体験を向上させたいとしましょう。QRコードでテーブルで支払い、カスタマイズしたハンバーガーをリンクとして友人に送って、彼らも注文できるようにすることです。

00:22:33.000 --> 00:22:40.000
これらの機能の両方がチェックアウトステップに直接起動することに依存しているため、これには大幅な再設計が必要になります。

00:22:40.000 --> 00:22:49.000
要求された機能は、アプリクリップにとって本当に素晴らしい機会ですが、それを現在のデザインにシューホーンにすると、多くの追加の複雑さが生じます。

00:22:49.000 --> 00:22:53.000
アプリをより柔軟にするために、どのような措置を講じることができますか?

00:22:53.000 --> 00:23:01.000
まず、アプリの各コンポーネントが独立しており、直接起動できる、平坦化されたモジュラー機能を作成することをお勧めします。

00:23:01.000 --> 00:23:08.000
このアプローチは、アプリクリップがどのように呼び出され、状態が提供されるかの基本であるディープリンクにはるかに適しています。

00:23:08.000 --> 00:23:16.000
URLでエンコードできるメニュー項目のリストを提供することで、直接呼び出されるチェックアウトモジュールを設計します。

00:23:16.000 --> 00:23:24.000
注文をビジュアルコードに埋め込まれたURLとして表現することで、顧客にテーブルで小切手を支払うことができます。

00:23:24.000 --> 00:23:35.000
食品がURLでエンコーダ可能になったら、このパラダイムを使用して、顧客が注文したものを友人と共有して、同じものを購入できるように促すことができます。

00:23:35.000 --> 00:23:45.000
オーバーヘッドがほとんど残っていないため、アプリをまだダウンロードしていない顧客にオンデマンドでこの機能を提供することで、アプリクリップを採用し、リーチを増やすことができます。

00:23:45.000 --> 00:23:54.000
オーバーヘッドを最小限に抑えながら、追加の機能のロックを解除するために、アプリケーションの設計について少し違った考え方をするいくつかの方法を示しました。

00:23:54.000 --> 00:23:59.000
それでは、アプリクリップの提供に関わる定型コードの一部を最小限に抑える方法を見てみましょう。

00:23:59.000 --> 00:24:09.000
アプリのコードでは、通常、アプリがバックグラウンドで起動または再開されたときに呼び出されるこれらのメソッドを使用して、ライフサイクルイベントに応答している可能性があります。

00:24:09.000 --> 00:24:13.000
アプリクリップを採用すると、これらのまったく同じライフサイクル方法の別のセットが追加されます。

00:24:13.000 --> 00:24:25.000
UserActivityからURLを抽出し、その抽出されたURLを使用して状態を導き出し、UIを表示するApp Clipのライフサイクルメソッドにコードを配置したくなるかもしれません。

00:24:25.000 --> 00:24:34.000
コンセプトは健全ですが、その前に、アプリとApp Clipの起動の両方を処理するコードが共有されるようにリファクタリングすることをお勧めします。

00:24:34.000 --> 00:24:45.000
これにより、App Clipとフルアプリ間の別々の起動パスで同様の機能を維持しようとするバグや頭痛の種が排除されます。

00:24:45.000 --> 00:24:50.000
ユーザーアクティビティをパラメータとして取るresponseToのようなメソッドを作成することを検討してください。

00:24:50.000 --> 00:25:00.000
このメソッドをアプリの主なエントリポイントとして使用し、関連するすべてのライフサイクルメソッドから直接呼び出してクリップします。

00:25:00.000 --> 00:25:06.000
今、あなたはアプリとクリップの両方に共通するコードを実行しており、オーバーヘッドを大幅に削減します。

00:25:06.000 --> 00:25:14.000
おそらく、顧客がテーブルで小切手を支払うのを容易にするために、URLからレストランのメニュー項目を抽出することで、そのユーザーアクティビティに応答します。

00:25:14.000 --> 00:25:20.000
これはすべて共有されているコードなので、一度変更を加えると、アプリとアプリクリップの両方でメリットを得ることができます。

00:25:20.000 --> 00:25:28.000
品質を維持しながらプロジェクトに最新の機能を採用することに関する議論は、テストに言及せずには完了しません。

00:25:28.000 --> 00:25:33.000
あなたに思い出させたいアプリクリップに特有の2つのテクニックがあります。

00:25:33.000 --> 00:25:42.000
反復開発の場合、Xcodeでビルドして実行するときは、_XCAppClipURL環境変数を選択した呼び出しURLに設定します。

00:25:42.000 --> 00:25:51.000
クリップを実行すると、ここで設定したURLは、顧客のデバイスと同じようにクリップに渡されます。

00:25:51.000 --> 00:26:00.000
開発中のクリップが本番デバイスと同様にOSによって表面化されるのを見るには、開発者設定に移動し、ローカルエクスペリエンスを作成します。

00:26:00.000 --> 00:26:08.000
顧客が自分のデバイスでApp Clipをどのように使用するかをよりよく理解するために、クリップを提出する前にこれを試してみる必要があります。

00:26:08.000 --> 00:26:15.000
そうでなければ、カメラでコードをスキャンするなど、クリップを呼び出す方法の多くをテストする素晴らしい機会を逃しています。

00:26:15.000 --> 00:26:24.000
また、Safariの新しいApp Clipカードエクスペリエンスのように、本番環境で利用可能になる前に、シードビルドの新機能を試すのに最適な方法です。

00:26:24.000 --> 00:26:29.000
私はちょうどアプリクリップをテストするための地元の経験がどれほど素晴らしいかについて表面をスキミングしました。

00:26:29.000 --> 00:26:41.000
詳細については、今年のApp Clipsセッションの新機能を参照してください。また、App Clipsのテストに関する詳細な説明については、「App Clipの起動体験のテスト」というタイトルの開発者ドキュメントを参照してください。

00:26:41.000 --> 00:26:49.000
最後に、すべての開発者が利用すべきApp Clipsに固有の機能がいくつかあります。

00:26:49.000 --> 00:26:54.000
App Clipsが導入されたとき、App Clipsのためだけに2つの合理化された権限項目が利用可能になりました。

00:26:54.000 --> 00:26:59.000
これらの項目は、一時的な通知と位置確認と呼ばれます。

00:26:59.000 --> 00:27:06.000
顧客がApp Clipカードで右を利用するための事前承認を提供することができます。

00:27:06.000 --> 00:27:20.000
一時的な通知を使用すると、App Clipが最後に起動されてから24時間通知を送信でき、位置確認は、顧客が正確な位置を尋ねたり、知ったりすることなく、お客様が期待するエリア内にあることを確認するのに役立ちます。

00:27:20.000 --> 00:27:30.000
これは、間違ったガソリンスタンドでの偶発的な支払いや、間違った町のFrutaショップからスムージーを注文するのを防ぐのに役立ちます。

00:27:30.000 --> 00:27:34.000
開発者として、Info.plistでこの機能にオプトインします。

00:27:34.000 --> 00:27:43.000
今、あなたのアプリクリップは、あなたが実際に必要とする以上のものを要求するアラートであなたの経験の起動を中断することなく、これらのユニークな許可にアクセスできます。

00:27:43.000 --> 00:27:50.000
位置確認は、NFCタグ、アプリクリップコード、QRコードなどの物理的な呼び出しでのみ利用できます。

00:27:50.000 --> 00:27:58.000
お客様は、現在のセッションまたはすべてのリクエストのロケーション確認をオプトアウトできます。

00:27:58.000 --> 00:28:11.000
confirmAcquiredのエラーをチェックして、これらの状態を適切に処理し、何が起こったのか、そしておそらくより有利な条件で取引を再開するためのオプションについて、顧客に役立つガイダンスを提供してください。

00:28:11.000 --> 00:28:14.000
プロファイルとXcodeでの署名に関する簡単なメモ。

00:28:14.000 --> 00:28:23.000
ほとんどの人は、プロジェクト設定の「署名と機能」セクションで署名を自動的に管理することを可能にしていますが、これは素晴らしいことです。

00:28:23.000 --> 00:28:27.000
署名を手動で管理している場合は、最近のプロフィールを取得してください。

00:28:27.000 --> 00:28:34.000
直接的な利点の1つは、顧客がアプリクリップからフルアプリにアップグレードすると、データがより速く移行されることです。

00:28:34.000 --> 00:28:38.000
これは、私たちが常に取り組んでいる多くの利点の1つです。

00:28:38.000 --> 00:28:46.000
最近のプロファイルを持つことで、アプリとクリップがこれらの改善を利用するために必要な機能を持っていることを保証します。

00:28:46.000 --> 00:28:51.000
あなたは今、軽くて高速なアプリクリップを構築するためのいくつかの素晴らしいテクニックを学びました。

00:28:51.000 --> 00:28:53.000
すべてをまとめる時が来ました。

00:28:53.000 --> 00:28:59.000
私はあなたのクリップをオンデマンドで稲妻のように簡単に配信するのに十分小さくするための基本的かつ高度なテクニックをカバーしました。

00:28:59.000 --> 00:29:04.000
App Clipがどこでどのように呼び出されていることを確認する方法をお見せしました。

00:29:04.000 --> 00:29:10.000
アプリクリップとユニバーサルリンクを採用するために、プロジェクトをディープリンクに備えるためのベストプラクティスをいくつか示しました。

00:29:10.000 --> 00:29:14.000
そして、App Clipsのユニークで合理化された機能を取り上げました。

00:29:14.000 --> 00:29:21.000
今日Xcodeを起動し、これらのヒントのいくつかを使用して、App Clipをより軽く、より速くできることを願っています。

00:29:21.000 --> 00:29:26.000
今年のApp Clipsの新機能に関する同僚のYongjunのセッションを必ずチェックしてください。

00:29:26.000 --> 00:29:30.000
ありがとう、そして素晴らしいWWDCをお過ごしください。

00:29:30.000 --> 23:59:59.000
[明るい音楽]。

