WEBVTT

00:00:00.000 --> 00:00:11.000
こんにちは、WWDCへようこそ。

00:00:11.000 --> 00:00:22.000
私はToriです。サーバーの新機能についてお話しし、すべてのアプリ内購入のステータスを追跡するために効果的なサーバーを実行するためのガイドラインを設定するのに役立つことにとても興奮しています。

00:00:22.000 --> 00:00:24.000
では、すぐに飛び込みましょう。

00:00:24.000 --> 00:00:30.000
このセッションは、アプリ内購入に焦点を当てた3つのセッションシリーズのパート2です。

00:00:30.000 --> 00:00:39.000
「Meet StoreKit 2」または「顧客をサポートし、払い戻しを処理する」をまだ見ていない場合は、このセッションの後を見て、完全なストーリーを入手することをお勧めします。

00:00:39.000 --> 00:00:46.000
このセッションでは、サーバーと、アプリ内購入を管理するためのサーバーを構築する方法に焦点を当てます。

00:00:46.000 --> 00:00:52.000
このセッションを始めるために、まずサーバーを持つことが有用な理由のいくつかについて話しましょう。

00:00:52.000 --> 00:00:59.000
サーバーを持つことはいくつかの理由で有用であり、アプリ内購入の場合、それらのほとんどは追跡ステータスを中心に展開します。

00:00:59.000 --> 00:01:14.000
サーバーがある場合、App Storeサーバー通知を通じてアプリ内購入のステータスが変更されたときにリアルタイムで通知することができ、サーバーツーサーバーAPIを使用していつでもオンデマンドでステータスを確認できます。

00:01:14.000 --> 00:01:29.000
サーバーを持つことで、デバイスがオフラインであっても、またはアプリの外でステータスが変更された場合でも、顧客のコンテンツへのアクセスを検証できるため、更新後も顧客がまだ購読しているかどうか、またはゲームで購入したコインが返金されているかどうかを知ることができます。

00:01:29.000 --> 00:01:34.000
すでにサーバーをお持ちの場合は、これらの理由のいくつかでサーバーを設定している可能性があります。

00:01:34.000 --> 00:01:41.000
サーバーを持っておらず、サーバーを構築することを考えている場合、これらはコンテンツをより詳細に制御できるため、考慮すべき強力な理由です。

00:01:41.000 --> 00:01:48.000
あなたがサーバーを持っていても、私たちの物語はアプリ内購入でiPhone、iPad、またはその他のデバイスから始まります。

00:01:48.000 --> 00:02:02.000
transactionId、originalTransactionId、領収書など、その購入に関する情報をサーバーに送信すると、当社のサーバーと直接通信することで、サーバーからその購入を追跡できるようになりました。

00:02:02.000 --> 00:02:08.000
今日、これにはverifyReceiptのようなAPIやApp Storeサーバー通知のようなフレームワークの使用が含まれます。

00:02:08.000 --> 00:02:13.000
私たちは、今日のコンテンツに私たちをもたらす、私たちのサーバーとの統合をさらに良くしたいだけです。

00:02:13.000 --> 00:02:22.000
サーバー側で提供されるすべての変更と、これらと統合して、より良い、より強力なサーバーを構築する方法を確認します。

00:02:22.000 --> 00:02:36.000
まず、App Storeの領収書でアクセスを検証し、App Store Server APIでステータスを追跡し、App Storeサーバーの通知でステータスを受動的に追跡する方法について説明します。

00:02:36.000 --> 00:02:45.000
また、これが家族共有を管理するための意味と、サンドボックスでサーバーをテストする方法についても確認します。

00:02:45.000 --> 00:02:49.000
領収書を使ってステータスの検証を始めましょう。

00:02:49.000 --> 00:02:52.000
今日、私たちの領収書は統一されたアプリの領収書形式です。

00:02:52.000 --> 00:03:04.000
領収書のJSONバージョンを取得するには、アプリでデバイス上の領収書検証を行うか、サーバーについて話しているので、サーバー間verifyReceiptエンドポイントを呼び出す必要があります。

00:03:04.000 --> 00:03:16.000
サーバーツーサーバーを呼び出すと、このデコードされた領収書に加えて、最新の_receipt_infoセクションの新しいトランザクション、pending_renewal_infoセクションの今後の更新情報、および最新の領収書が取得されます。

00:03:16.000 --> 00:03:27.000
この領収書は巨大になる可能性があり、非消耗品、消耗品、サブスクリプション、または非更新サブスクリプションなど、アプリ全体からのトランザクションが含まれています。

00:03:27.000 --> 00:03:32.000
これはあなたにたくさんの情報を提供しますが、それが多すぎるのではないかと思います。

00:03:32.000 --> 00:03:45.000
さらに、StoreKit 2では、JWS、またはJSON Web署名、クライアント側のフォーマットに新しい署名付きトランザクションを導入しており、サーバー上で同じものを提供したいと考えています。

00:03:45.000 --> 00:03:47.000
なぜ私たちは署名された取引を導入することに決めたのですか?

00:03:47.000 --> 00:03:49.000
アップルでは、セキュリティを重視しています。

00:03:49.000 --> 00:03:57.000
JWSを使用してこれらのトランザクションに署名すると、署名と署名の検証を通じてセキュリティが強化されます。

00:03:57.000 --> 00:04:06.000
さらに、トランザクションは簡単にデコードして検証できるため、電話することなくサーバーで実行できます。

00:04:06.000 --> 00:04:09.000
今、これらの署名された取引を見てみましょう。

00:04:09.000 --> 00:04:13.000
署名された取引は、ピリオドで区切られた3つの文字列で構成されています。

00:04:13.000 --> 00:04:21.000
最初の文字列は、base64でエンコードされたJSONヘッダー、次にbase64でエンコードされたJSONペイロード、続いて署名です。

00:04:21.000 --> 00:04:28.000
base64でヘッダーをデコードすると、使用した署名アルゴリズムとx5Cクレームが含まれています。

00:04:28.000 --> 00:04:32.000
これには、署名を確認するために必要な証明書チェーンが含まれています。

00:04:32.000 --> 00:04:34.000
すぐに署名の確認に戻ります。 もう少ししたら。

00:04:34.000 --> 00:04:40.000
次に、base64でペイロードをデコードすると、レシートJSONが表示されます。

00:04:40.000 --> 00:04:50.000
つまり、トランザクションをデコードするために必要なのは、base64がペイロードをデコードすることだけです。これは、サーバー上で自分で実行できる簡単な操作です。

00:04:50.000 --> 00:04:52.000
デコードされたトランザクションを簡単に見てみましょう。

00:04:52.000 --> 00:05:01.000
ちらっと見るだけで、一部のデータ型が以前のレシートの文字列から、数値やブール値などのより適切なデータ型に変更されていることに気付くかもしれません。

00:05:01.000 --> 00:05:06.000
また、エポック以来、日付形式を1ミリ秒に減らしたことに注意してください。

00:05:06.000 --> 00:05:09.000
また、いくつかの新しいフィールドを追加しました。

00:05:09.000 --> 00:05:13.000
トランザクションが適用されるコンテンツタイプを示す「タイプ」というフィールドを追加しました。

00:05:13.000 --> 00:05:17.000
「appAccountToken」というフィールドも追加しました。

00:05:17.000 --> 00:05:26.000
StoreKit 2アプリで購入時にこの値をStoreKitに提供すると、サーバーに保持して各トランザクションで返します。

00:05:26.000 --> 00:05:35.000
また、新しい署名された取引だけでなく、各取引の既存の統一されたアプリの領収書でもこれを返します。

00:05:35.000 --> 00:05:40.000
ここで呼び出したい次の2つのフィールドは、実際には新しいものではなく、むしろ名前が変更されました。

00:05:40.000 --> 00:05:52.000
これらのフィールドの存在が、失効日の時点でサービスを取り消す必要があることを示すことをより明確にするために、 cancellation_date と cancellation_reason と cancellation_reason を revocation_date と revocation_reason に変更しました。

00:05:52.000 --> 00:05:59.000
これらの最後の2つのフィールドは新しく見えるかもしれませんが、実際には以前の領収書からのいくつかの情報の単純化です。

00:05:59.000 --> 00:06:10.000
isTrialPeriod、isIntroOfferPeriod、promotionalOfferIdentifier、offerCodeRefNameを offerTypeとofferIdentifierに統合しました。

00:06:10.000 --> 00:06:21.000
offerTypeは、顧客がこの期間に適用したオファーの種類を示します。1はイントロオファー、2はサブスクリプションオファー、3はオファーコードです。

00:06:21.000 --> 00:06:30.000
オファータイプが2または3の場合、オファー識別子フィールドに、プロモーションオファーIDまたはofferCodeRefNameのいずれかの値も表示されます。

00:06:30.000 --> 00:06:35.000
さて、署名されたトランザクション情報の署名部分の検証について話したいと思います。

00:06:35.000 --> 00:06:41.000
署名を確認することは、取引がAppleから来ており、信頼できることを検証するためのオプションです。

00:06:41.000 --> 00:06:46.000
トランザクションの内容のみを見たい場合は、この手順は必要ありません。

00:06:46.000 --> 00:06:54.000
ただし、署名を確認するには、署名されたトランザクション情報のヘッダー部分で利用可能なクレームを使用する必要があります。

00:06:54.000 --> 00:07:03.000
Algクレームを使用して、使用した署名アルゴリズムを知り、x5cクレームの配列の証明書チェーンを使用します。

00:07:03.000 --> 00:07:10.000
これら2つを取得したら、お気に入りの暗号化ライブラリを使用して、署名されたトランザクション情報の署名を確認できます。

00:07:10.000 --> 00:07:18.000
そのため、App Storeの領収書の変更、または私たちが今呼んでいるように、署名された取引をカバーしています。

00:07:18.000 --> 00:07:21.000
では、APIでステータスを確認する方法に移りましょう。

00:07:21.000 --> 00:07:33.000
したがって、署名されたトランザクションの有効性を確認したり、トランザクションをデコードしたりするために、今日のverifyReceiptのようなAPIは必要ありませんが、サーバー上で役立つAPIを構築したいと考えていました。

00:07:33.000 --> 00:07:47.000
そのため、今年WWDCでApp Store Server APIの新しいライブラリを導入し、サーバーで以前は利用できなかった新機能を提供し、新しい署名されたトランザクションも利用します。

00:07:47.000 --> 00:07:55.000
そこで、私たちは今、2つの真新しいAPIについて話します。サブスクリプションステータスAPIとアプリ内購入履歴APIです。

00:07:55.000 --> 00:07:58.000
まず、サブスクリプションステータスAPIについて話したいと思います。

00:07:58.000 --> 00:08:07.000
サブスクリプションステータスAPIは、アプリの元のTransactionIdで示される自動更新サブスクリプションの最新ステータスを提供します。

00:08:07.000 --> 00:08:12.000
このAPIを使用すると、購読者のステータスに関する迅速な回答を得ることができます。

00:08:12.000 --> 00:08:19.000
1回の簡単なチェックで、サブスクリプションがアクティブか、期限切れか、猶予期間か、その他の州かをすぐに知ることができます。

00:08:19.000 --> 00:08:21.000
今、それを見てみましょう。"

00:08:21.000 --> 00:08:27.000
このAPIへのリクエストは簡単で、URLにオリジナルのTransactionIdのみが必要です。

00:08:27.000 --> 00:08:37.000
このAPIからの応答には、顧客がアプリで購読しているすべてのサブスクリプションのステータスが含まれており、subscriptionGroupIdentifierでグループ化されています。

00:08:37.000 --> 00:08:46.000
subscriptionGroupIdentifierごとに、サブスクリプショングループ内の元のTransactionIdごとにエントリを含む最新のトランザクションのリストを提供します。

00:08:46.000 --> 00:08:59.000
この配列の各エントリには、ステータス、originalTransactionId、signedTransactionInfo、およびsignedRenewalInfoが含まれており、これもJWS形式で署名されています。

00:08:59.000 --> 00:09:03.000
今、そのステータスフィールドを詳しく見てみましょう。

00:09:03.000 --> 00:09:11.000
ステータスフィールドは、サブスクリプションのステータスに関する迅速な回答を提供するので、購読者のサービスのロックを解除するかどうかを知ることができます。

00:09:11.000 --> 00:09:35.000
ステータスの5つの可能な値から始めます。1は、サブスクリプションがアクティブであることを意味します。2は、サブスクリプションの有効期限が切れていることを意味します。3は、サブスクリプションが請求再試行期間にあることを意味します。4は、サブスクリプションが猶予期間にあることを意味します。5は、キャンセルまたはその他のイベントによりサブスクリプションアクセスが取り消されたことを意味します。

00:09:35.000 --> 00:09:39.000
ステータスフィールドを見ると、サブスクリプションに関する簡単な回答が得られます。

00:09:39.000 --> 00:09:48.000
そのステータスの詳細については、署名されたトランザクション情報のペイロードと署名された更新情報のペイロードを確認できます。

00:09:48.000 --> 00:09:58.000
signedRenewalInfoをデコードするには、base64がペイロード部分をデコードすることで、署名されたトランザクション情報と同じ手順に従います。

00:09:58.000 --> 00:10:04.000
ヘッダーを使用して、同じ方法でsignedRenewalInfoの署名をさらに検証できます。

00:10:04.000 --> 00:10:08.000
デコードされると、このようなものが表示されます。

00:10:08.000 --> 00:10:22.000
更新情報には、今日のverifyReceiptの保留中の更新情報セクションで提供しているのと同じフィールドが含まれており、日付形式を1つだけ含めたり、該当する場合はいくつかのフィールドをブール値または数値にしたりするなど、いくつかの更新が含まれています。

00:10:22.000 --> 00:10:28.000
また、新しいフィールドofferTypeとofferIdentifierをsignedRenewalInfoに追加します。

00:10:28.000 --> 00:10:33.000
これにより、お客様が次回の更新時にオファーを引き換える予定があるかどうかがわかります。

00:10:33.000 --> 00:10:45.000
サブスクリプションステータスAPIに加えて、今日のverifyReceiptの最新の_receipt_infoセクションで提供しているように、アプリに関連するすべてのトランザクションを取得する方法を提供したいと考えています。

00:10:45.000 --> 00:10:50.000
このため、アプリ内購入履歴APIも追加しています。

00:10:50.000 --> 00:11:00.000
アプリ内購入履歴APIは、今日のverifyReceiptの最新の_receipt_infoセクションで受け取るのと同じように、アプリのすべてのトランザクションの履歴を提供します。

00:11:00.000 --> 00:11:12.000
ここでの主な違いは、各トランザクションが新しい署名されたトランザクション情報形式になり、APIがページネーションされてApp Storeから受け取る応答のサイズを制御することです。

00:11:12.000 --> 00:11:17.000
これに対する最初の要求は、サブスクリプションステータスAPIと同様に、非常に簡単です。

00:11:17.000 --> 00:11:23.000
リクエストを処理するには、お客様からのオリジナルのTransactionIdのみが必要です。

00:11:23.000 --> 00:11:34.000
応答では、アプリのApple IDやバンドルIDなどのアプリのメタデータと、新しい署名されたトランザクション情報形式でアプリの最新の20トランザクションの配列を受け取ります。

00:11:34.000 --> 00:11:38.000
リクエストごとに20の署名済み取引情報を返します。

00:11:38.000 --> 00:11:44.000
より多くのトランザクションがある場合は、応答のhasMoreとリビジョン値を見てください。

00:11:44.000 --> 00:11:49.000
アプリにさらに多くのトランザクションが残っている場合、hasMoreは真実になります。

00:11:49.000 --> 00:11:56.000
この場合、別のリクエストを行い、リビジョントークンをクエリパラメータとして渡し、次の20のトランザクションを取得します。

00:11:56.000 --> 00:11:59.000
hasMoreがfalseになるまでこれを繰り返します。

00:11:59.000 --> 00:12:06.000
では、ピボットして、すべてのApp Store Server APIが互いにどのように一致するかについて話しましょう。

00:12:06.000 --> 00:12:16.000
それらはすべて、JWT（またはJSON Webトークン）の認証の背後にあり、新しい署名されたトランザクションをサポートし、JSON要求と応答形式を備えています。

00:12:16.000 --> 00:12:26.000
そして何よりも、それらはすべて、リクエストで領収書と共有秘密を要求するのではなく、リクエストで提供した元のTransactionIdからキーオフします。

00:12:26.000 --> 00:12:29.000
さて、私はJWT認証をカバーしたいと思います。

00:12:29.000 --> 00:12:35.000
すべての新しいApp Store Server APIは、JSON Webトークン（JWT）認証を利用します。

00:12:35.000 --> 00:12:41.000
私たちは、私たちのサーバーとあなたのサーバーの間の通信のセキュリティを高めるためにこれを選びました。

00:12:41.000 --> 00:12:46.000
このJWTを生成するには、App Store Connectから秘密鍵をダウンロードする必要があります。

00:12:46.000 --> 00:12:51.000
このプロセスでは、公開鍵がサーバーに自動的に登録されます。

00:12:51.000 --> 00:12:56.000
その後、サーバーを呼び出す前に、ES256アルゴリズムを使用してトークンに署名する必要があります。

00:12:56.000 --> 00:13:03.000
App Store Connectで秘密鍵を生成するには、[ユーザーとアクセス]ページに移動し、[キー]タブにアクセスしてください。

00:13:03.000 --> 00:13:08.000
アプリ内購入キーオプションを選択すると、このようなページが表示されます。

00:13:08.000 --> 00:13:10.000
キーを追加して名前を付けます。

00:13:10.000 --> 00:13:16.000
一度しかダウンロードできないので、キーを安全な場所に保存し、キーIDをメモしてください。

00:13:16.000 --> 00:13:20.000
さて、このJWTが実際にどのように見えるかを見てみましょう。

00:13:20.000 --> 00:13:26.000
JWTは、ヘッダー、ペイロード、署名の3つの部分で構成されています。

00:13:26.000 --> 00:13:32.000
ヘッダーには、秘密鍵のキーIDと署名に使用されるアルゴリズムを含める必要があります。

00:13:32.000 --> 00:13:38.000
SHA 256ハッシュ、またはES256の楕円曲線シグネチャが必要です。

00:13:38.000 --> 00:13:44.000
また、トークンの種類も含めます。この場合、常にJWTです。

00:13:44.000 --> 00:13:46.000
ペイロードには発行者IDを含める必要があります。

00:13:46.000 --> 00:13:49.000
この値はApp Store Connectで見つけることができます。

00:13:49.000 --> 00:13:55.000
トークンが発行された時間と期限切れになる時刻を、エポックから秒単位で含めます。

00:13:55.000 --> 00:13:59.000
この2つの時間の差は1時間以内でなければなりません。

00:13:59.000 --> 00:14:03.000
常にappstoreconnect-v1であるオーディエンスを含めます。

00:14:03.000 --> 00:14:07.000
ノンス、または1回限りの一意の文字列を生成する必要があります。

00:14:07.000 --> 00:14:12.000
最後に、アプリのバンドル識別子を含める必要があります。

00:14:12.000 --> 00:14:23.000
この情報をすべて入手したら、ES256アルゴリズムを使用してこのトークンの署名、またはSHA 256ハッシュを持つ楕円曲線シグネチャを実装する必要があります。

00:14:23.000 --> 00:14:28.000
先に進む前に、App Store Server APIの重要なポイントを確認しましょう。

00:14:28.000 --> 00:14:36.000
まず、これらは別々の機能であるため、ステータスの決定と取引の履歴の表示を分離しました。

00:14:36.000 --> 00:14:55.000
次に、これらのAPIはリクエストの元のTransactionIdのみを必要とします。つまり、アプリまたはサーバーからの応答から受け取った署名されたトランザクションを取得し、元のTransactionIdを含む興味のあるフィールドを保存し、署名されたトランザクション情報を取り除くことができます。

00:14:55.000 --> 00:15:01.000
過去に領収書で行うように案内してきたので、もう署名された取引を保存する必要はありません。

00:15:01.000 --> 00:15:07.000
そのため、新しいApp Store Server APIで顧客のステータスを確認する方法について説明します。

00:15:07.000 --> 00:15:15.000
さて、App Storeサーバーの通知を一貫性のあるものにする方法と、通知を使用してステータスを追跡する方法について説明します。

00:15:15.000 --> 00:15:19.000
まず、App Storeサーバー通知の簡単なレビューから始めましょう。

00:15:19.000 --> 00:15:25.000
私たちは数年前からApp Storeサーバーの通知について議論してきたので、なぜそれが役に立つのかを見直しましょう。

00:15:25.000 --> 00:15:35.000
App Storeサーバー通知を使用すると、トランザクションのステータスがApp Storeから直接変更されたときに通知を受け取ることができます。

00:15:35.000 --> 00:15:43.000
通知を受け取ったら、顧客が携帯電話でアプリを開くことなく、すぐにステータスを更新できます。

00:15:43.000 --> 00:15:47.000
App Storeのサーバー通知では、ステータスについてお電話いただく必要もありません。

00:15:47.000 --> 00:15:50.000
何かが変わったらお知らせします。

00:15:50.000 --> 00:15:55.000
これらは、サーバーが利用できる最も強力なツールの1つです。

00:15:55.000 --> 00:16:05.000
今年の目標は、新しい使いやすい署名付きトランザクションを利用して、App Storeサーバー通知をさらに強力にすることです。

00:16:05.000 --> 00:16:19.000
これに加えて、1つのユーザーアクションに対して1つの通知のみが送信されるように通知を更新し、ペイロードを更新し、セキュリティを強化するためにJWSを使用してペイロード全体が署名されます。

00:16:19.000 --> 00:16:27.000
また、準備ができたらv2通知にオプトインすることも許可し、しばらくの間、既存の通知を送信し続けます。

00:16:27.000 --> 00:16:31.000
これは、v1通知の現在の通知です。

00:16:31.000 --> 00:16:36.000
INITIAL_BUYからREVOKEまで、合計11のタイプがあります。

00:16:36.000 --> 00:16:45.000
v2通知では、INITIAL_BUY、INTERACTIVE_RENEWAL、CANCEL、PRICE_INCREASE_CONSENTの4つの通知タイプを廃止します。

00:16:45.000 --> 00:16:54.000
しかし、SUBSCRIBED、OFFER_REDEEMED、EXPIRED、GRACE_PERIOD_EXPIRED、PRICE_INCREASEの5つの新しいタイプを追加します。

00:16:54.000 --> 00:17:00.000
新しい通知タイプに加えて、通知に「サブステート」という新しいフィールドを追加します。

00:17:00.000 --> 00:17:05.000
これは、より一般的な通知タイプを特定のユーザーアクションに絞り込むのに役立ちます。

00:17:05.000 --> 00:17:20.000
現在、サブステートは、SUBSCRIBED、DID_CHANGE_RENEWAL_STATUS、DID_CHANGE_RENEWAL_PREFERENCES、OFFER_REDEEMED、EXPIRED、PRICE_INCREASEの6つのv2通知タイプに適用されます。

00:17:20.000 --> 00:17:25.000
サブステートがこれらの通知タイプにどのように適用されるかの例を見てみましょう。

00:17:25.000 --> 00:17:30.000
まず、SUBSCRIBED通知とそのサブステートについて話したいと思います。

00:17:30.000 --> 00:17:37.000
顧客が初めて購入すると、INITIAL_BUYのサブステートでSUBSCRIBEDを受け取ります。

00:17:37.000 --> 00:17:49.000
顧客が同じSKUまたは別のSKUを再購読すると、サブスクリプションが同じサブスクリプショングループ内にある限り、RESUBSCRIBEのサブステートでSUBSCRIBEDを受け取ります。

00:17:49.000 --> 00:17:57.000
V1 App Storeサーバー通知で同等のタイプを持たない新しい通知タイプの1つは、OFFER_REDEEMED通知です。

00:17:57.000 --> 00:17:59.000
だから、この例を見てみたい。

00:17:59.000 --> 00:18:04.000
OFFER_REDEEMEDは、顧客がプロモーションオファーを利用するたびに受信されます。

00:18:04.000 --> 00:18:12.000
お客様が初回購入のオファーを引き換えると、INITIAL_BUYのサブステートでOFFER_REDEEMEDを受け取ります。

00:18:12.000 --> 00:18:21.000
顧客が同じ非アクティブなサブスクリプションに再購読するオファーを引き換えると、RESUBSCRIBEのサブステートでOFFEET_REDEEMEDを受け取ります。

00:18:21.000 --> 00:18:29.000
お客様がアクティブなサブスクリプションをアップグレードするオファーを利用すると、UPGRADEのサブステートでOFFEE OFFER_REDEEMEDが届きます。

00:18:29.000 --> 00:18:37.000
お客様がアクティブなサブスクリプションをダウングレードするオファーを引き換えると、DOWNGRADEのサブステートでOFFER_REDEEMEDを受け取ります。

00:18:37.000 --> 00:18:50.000
さらに、お客様が同じ期間内にキャンセルした後にアクティブなサブスクリプションに再購読するオファーを引き換えた場合、AUTO_RENEW_ENABLEDのサブステートでOFFEE OFFER_REDEEMEDを受け取ります。

00:18:50.000 --> 00:18:52.000
では、EXPIREDを見てみましょう。

00:18:52.000 --> 00:19:02.000
新しいEXPIRED通知タイプでは、顧客がVOLUNTARYのサブステートで自動更新を無効にした後、サブスクリプションの有効期限が切れると、EXPIREDを受け取ります。

00:19:02.000 --> 00:19:11.000
請求の再試行期間が正常に回復せずに終了したため、サブスクリプションの有効期限が切れた場合、BILLING_RETRYのサブステートでEXPIREDを受け取ります。

00:19:11.000 --> 00:19:21.000
さらに、顧客が値上げに同意していないためにサブスクリプションが期限切れになった場合、PRICE_INCREASEのサブステートでEXPIREDを受け取ります。

00:19:21.000 --> 00:19:30.000
したがって、v2通知タイプと該当するサブステートを組み合わせることで、現在20以上の異なる顧客ライフサイクルイベントをカバーしています。

00:19:30.000 --> 00:19:42.000
通知タイプを見るだけで、購入で何が変更されたかの一般的な把握を得るには十分ですが、より詳細に入りたい場合は、サブステートを見ると、より具体的な状態を取得するのに役立ちます。

00:19:42.000 --> 00:19:46.000
では、新しいペイロードを簡単に見てみましょう。

00:19:46.000 --> 00:19:52.000
V2通知の場合、通知の種類に関係なく、常に同じフィールドセットが含まれます。

00:19:52.000 --> 00:20:18.000
通知タイプ、サブタイプ、v2通知を購読すると2になる通知バージョン、通知が適用される環境、バンドルID、アプリのApple ID、バンドルバージョンなどのアプリメタデータ、新しいsignedTransactionInfo形式の影響を受けるアプリ内の最新のトランザクション、新しいsignedRenewalInfo形式のアプリ内の最新の更新情報。

00:20:18.000 --> 00:20:30.000
これらの変更により、通知の解析が容易になり、新しい署名されたトランザクションを利用し、影響を受けるアプリ内購入に関する情報のみが含まれているため、採用が容易になります。

00:20:30.000 --> 00:20:37.000
先に述べたように、通知のセキュリティと信頼性を高めるために、ペイロード全体が署名されます。

00:20:37.000 --> 00:20:46.000
先ほど見たペイロードは読みやすさのために署名されていませんが、署名はJWS形式でトランザクションと更新情報に署名する方法に似ています。

00:20:46.000 --> 00:20:50.000
準備ができたら、v2通知にオプトインできるようにしてほしい。

00:20:50.000 --> 00:20:59.000
このため、App Store Connectの通知URLにオプションを追加して、App Storeサーバーの通知バージョンを選択できるようにしています。

00:20:59.000 --> 00:21:06.000
これを行うには、アプリのページに移動し、新しいApp Storeサーバー通知セクションまでスクロールします。

00:21:06.000 --> 00:21:15.000
本番サーバーのURLを選択すると、バージョン1またはバージョン2のApp Storeサーバー通知を選択するオプションが表示されます。

00:21:15.000 --> 00:21:21.000
これらの変更が今年後半に開始されると、バージョン2のApp Storeサーバー通知にオプトインできるようになります。

00:21:21.000 --> 00:21:30.000
それでは、サブスクリプションの初回購入から始めて、新しいApp Storeサーバー通知を使用して、いくつかのシナリオの例をいくつか見たいと思います。

00:21:30.000 --> 00:21:36.000
アプリでの初回サブスクリプション購入の場合、購入の結果として署名された取引情報を受け取ります。

00:21:36.000 --> 00:21:50.000
アプリでこれを検証し、元のTransactionIdやその他の関連フィールドをサーバーに送信するか、署名されたトランザクション情報をサーバーに送信して検証し、その時点でデータベースに保存するフィールドを選択できます。

00:21:50.000 --> 00:21:56.000
同じ頃、INITIAL_BUYのサブステートを含むSUBSCRIBED通知が届きます。

00:21:56.000 --> 00:22:09.000
通知の署名されたトランザクション情報にアプリアカウントトークンが含まれているので、購入後にサーバーとアプリ間の通信が失われた場合でも、この通知をアプリ内ユーザーにすぐにリンクできます。

00:22:09.000 --> 00:22:13.000
署名されたトランザクション情報を確認するためにサーバーに電話する必要はありません。

00:22:13.000 --> 00:22:22.000
元のTransactionIdを送信して、ステータスまたはアプリ内購入履歴APIを確認したい場合は、いつでも当社のサーバーに電話することができます。

00:22:22.000 --> 00:22:25.000
今、私はサブスクリプションの購入をカバーしました。

00:22:25.000 --> 00:22:27.000
サブスクリプションの更新に移りましょう。

00:22:27.000 --> 00:22:30.000
これで、このサブスクリプションの更新に達しました。

00:22:30.000 --> 00:22:35.000
このサブスクリプションが正常に更新されると、DID_RENEWタイプの通知が届きます。

00:22:35.000 --> 00:22:47.000
ペイロードで署名された取引情報と署名された更新情報を見て、サブスクリプションの次の更新日と、次の更新のための顧客の更新設定を確認できます。

00:22:47.000 --> 00:22:55.000
また、サブスクリプションステータスAPIを呼び出すジョブをスケジュールして、フェイルオーバーメカニズムとして更新時にサブスクリプションのステータスを確認することもできます。

00:22:55.000 --> 00:23:01.000
繰り返しになりますが、通知で受け取った取引を確認するために私たちに電話する必要はありません。

00:23:01.000 --> 00:23:07.000
もちろん、自動更新は、特に請求の問題がある場合、常に計画通りに進むとは限りません。

00:23:07.000 --> 00:23:11.000
だから今、私は猶予期間と請求の再試行をカバーしたいと思います。

00:23:11.000 --> 00:23:15.000
それでは、サブスクリプションが期待どおりに更新されなかったとしましょう。

00:23:15.000 --> 00:23:19.000
このような場合は、DID_FAIL_TO_RENEW通知で通知します。

00:23:19.000 --> 00:23:32.000
猶予期間が有効になっていて、サブスクリプションが正常に更新せずに猶予期間を終了した場合、GRACE_PERIOD_EXPIRED通知が送信され、顧客が請求再試行期間に入ったことを知ることができます。

00:23:32.000 --> 00:23:41.000
請求再試行期間中にサブスクリプションがまだ回復しない場合は、BILLING_RETRYのサブステージで期限切れの通知が送信されます。

00:23:41.000 --> 00:23:49.000
猶予期間または請求再試行期間中にサブスクリプションの請求を回復した場合、DID_RECOVER通知をお送りします。

00:23:49.000 --> 00:23:59.000
更新の結果に関係なく、署名された取引情報と署名された更新情報を含むv2通知で結果を通知します。

00:23:59.000 --> 00:24:06.000
このプロセスの任意の時点でサブスクリプションステータスまたは履歴APIを呼び出すと、サブスクリプションステータスを再確認できます。

00:24:06.000 --> 00:24:11.000
今、私たちは、顧客があなたのアプリで購入するものはサブスクリプションだけではないことを認識しています。

00:24:11.000 --> 00:24:16.000
それでは、消耗品の初回購入時に何を期待するかをピボットしてカバーしましょう。

00:24:16.000 --> 00:24:23.000
アプリの消耗品を初めて購入すると、購入の結果として署名された取引情報が届きます。

00:24:23.000 --> 00:24:37.000
アプリでこれを検証し、元のTransactionIdやその他の関連フィールドをサーバーに送信するか、署名されたトランザクション情報をサーバーに送信して検証し、その時点でデータベースに保存するフィールドを選択できます。

00:24:37.000 --> 00:24:42.000
後で必要になるかもしれないので、元のTransactionIdを常にメモしておいてください。

00:24:42.000 --> 00:24:53.000
消耗品や非消耗品や非更新サブスクリプションなどの他のコンテンツタイプについては、顧客が払い戻しを要求しない限り、その購入のライフサイクルにわたってあまり変更はありません。

00:24:53.000 --> 00:24:56.000
だから私は今、そのケースをカバーしたい。

00:24:56.000 --> 00:25:00.000
さて、顧客が消耗品購入の払い戻しを要求したとします。

00:25:00.000 --> 00:25:08.000
署名された取引情報に失効日と失効理由を記載した払い戻し通知をお送りします。

00:25:08.000 --> 00:25:13.000
失効日以降に消耗品購入へのアクセスの提供を停止することを知ることができます。

00:25:13.000 --> 00:25:21.000
いつでも消耗品購入のステータスを心配している場合は、アプリ内履歴APIを呼び出すことができ、応答でそれを探すことができます。

00:25:21.000 --> 00:25:27.000
キャンセルされた消耗品は常に含まれるので、取引状況が変わったかどうかがわかります。

00:25:27.000 --> 00:25:30.000
今、私は停電について話したいです。

00:25:30.000 --> 00:25:34.000
最善の努力にもかかわらず、サーバーで停止が発生することがあります。

00:25:34.000 --> 00:25:38.000
次に、サーバーが停止から回復するのを助ける方法について説明します。

00:25:38.000 --> 00:25:46.000
サーバーで停止が発生し、App Storeサーバーの通知を見逃した場合は、その間に何が変更されたかを知りたいでしょう。

00:25:46.000 --> 00:25:49.000
アプリ内履歴APIは、ここでのソリューションです。

00:25:49.000 --> 00:26:00.000
各顧客のAPIを呼び出して、アプリからオリジナルのTransactionIdを提供するだけで、アプリの最新のトランザクション履歴を取得して、サーバーを更新できます。

00:26:00.000 --> 00:26:06.000
その後、サブスクリプションステータスAPIを呼び出すと、各サブスクリプションの最新のサブスクリプションステータスを取得できます。

00:26:06.000 --> 00:26:11.000
さて、最後のケースを取り上げたいと思います。サーバー上で署名されたトランザクションに移行します。

00:26:11.000 --> 00:26:19.000
これは、アプリの前にサーバーを更新する準備ができている場合や、古いバージョンのアプリから統一されたアプリの領収書を受け取っている場合に特に重要です。

00:26:19.000 --> 00:26:26.000
オリジナルのTransactionIdのみが必要なため、サーバー上の署名付きトランザクションへの移行は簡単です。

00:26:26.000 --> 00:26:38.000
サーバーがアプリから受信した統一されたアプリレシートをJWSレシートに簡単に変換できるため、サーバーはApp StoreサーバーAPIやApp Storeサーバー通知と互換性があります。

00:26:38.000 --> 00:26:46.000
これを行うには、まず統一されたアプリレシートでverifyReceiptを呼び出して、応答から一意のoriginalTransactionIdをすべて引き出します。

00:26:46.000 --> 00:26:54.000
これらの元のTransactionIdの1つのアプリ内購入履歴APIを呼び出して、署名されたトランザクションのアプリの履歴を取得します。

00:26:54.000 --> 00:27:04.000
次に、サブスクリプションoriginalTransactionIdのサブスクリプションステータスAPIを呼び出すと、すべての顧客サブスクリプションの署名付きトランザクションとsignedRenewalInformationを取得します。

00:27:04.000 --> 00:27:14.000
署名されたトランザクションのペイロードから関連するデータを書き留めると、これらのAPIを引き続き使用し、v2 App Storeサーバー通知を受け取る準備が整います。

00:27:14.000 --> 00:27:24.000
だから今、私はApp Storeサーバー通知に関するすべての変更と、通知を使用して顧客のステータスを確認する方法を取り上げました。

00:27:24.000 --> 00:27:31.000
さて、サーバーからのアプリ内購入のファミリー共有の管理をさらに簡単にする方法について話したいと思います。

00:27:31.000 --> 00:27:43.000
アプリ内購入のファミリー共有は、App Store Connectでそのアプリ内購入のファミリー共有を有効にしている場合、現在、自動更新サブスクリプションと非消費型購入でサポートされています。

00:27:43.000 --> 00:27:58.000
現在、トランザクションが家族共有または購入であるかどうかを示すためにinAppOwnershipTypeというフィールドを提供し、家族向けの通知のサブセットをサポートしています：REVOKE、DID_RECOVER、およびDID_FAIL_TO_RENEW。

00:27:58.000 --> 00:28:08.000
アプリ内の所有権タイプフィールドと既存のサポートされている通知タイプは、新しい署名済みトランザクションとApp Storeサーバー通知v2に残ります。

00:28:08.000 --> 00:28:14.000
しかし、今年後半には、家族向けのApp Storeサーバー通知のサポートが追加されます。

00:28:14.000 --> 00:28:24.000
v1通知には、DID_CHANGE_RENEWAL_STATUS、DID_CHANGE_RENEWAL_PREF、DID_RENEW、およびINTERACTIVE_RENEWALを追加します。

00:28:24.000 --> 00:28:28.000
V2通知では、家族へのサポートをさらに追加しています。

00:28:28.000 --> 00:28:44.000
DID_CHANGE_RENEWAL_STATUS、DID_CHANGE_RENEWAL_PREF、DID_RENEWに加えて、購入者と家族向けのSUBSCRIBED、EXPIRED、GRACE_PERIOD_EXPIRED、OFFER_REDEEMEDのサポートを追加しています。

00:28:44.000 --> 00:28:53.000
これにより、App Storeサーバーの通知を通じて、購入者と家族の両方のすべての顧客のステータスを追跡することがさらに簡単になります。

00:28:53.000 --> 00:29:06.000
そのため、今年の家族への通知の変更により、既存の家族共有機能と組み合わせることで、アプリ内購入の家族共有の管理がさらに簡単になるはずです。

00:29:06.000 --> 00:29:11.000
さて、もう1つ締めくくりたいと思います。サンドボックスでサーバーをテストすることです。

00:29:11.000 --> 00:29:14.000
私たちはあなたのアプリとサーバーに自信を持ってほしいです。

00:29:14.000 --> 00:29:23.000
そのため、本番前にサンドボックスで新しいApp Store Server APIとApp Storeサーバー通知と統合できるようにしてほしい。

00:29:23.000 --> 00:29:31.000
今日議論したApp Store Server APIについては、サンドボックスで完全にテスト可能であり、今からライブであることを意味します!

00:29:31.000 --> 00:29:35.000
これには、サブスクリプションステータスAPIとアプリ内購入履歴APIが含まれます。

00:29:35.000 --> 00:29:40.000
これに加えて、サンドボックスに他のいくつかの新機能を追加しています。

00:29:40.000 --> 00:29:46.000
今年後半には、App Store Connectでサンドボックス固有の通知URLを追加できるようになります。

00:29:46.000 --> 00:29:52.000
この追加により、プロダクションとサンドボックスの通知を完全に分離しておくことができます。

00:29:52.000 --> 00:30:02.000
さらに、サンドボックス通知バージョンを選択することもできるので、生産前にサンドボックスでv2通知をテストすることができます。

00:30:02.000 --> 00:30:11.000
昨年、トライアル資格のリセットやサンドボックスでのサブスクリプション管理ページの提供など、いくつかのエキサイティングなサンドボックスの改善をもたらしました。

00:30:11.000 --> 00:30:17.000
サンドボックスでのテストを引き続き簡単にしたいので、今年はいくつかの新しい機能強化を追加する予定です。

00:30:17.000 --> 00:30:27.000
これらは、サンドボックスApple IDの購入履歴の消去、サンドボックスアカウントの地域の変更、サンドボックスでのサブスクリプション更新率の調整です。

00:30:27.000 --> 00:30:38.000
さらに、セキュリティ強化として、お客様がTestFlightユーザーではなくなったことが検出された場合、TestFlight領収書のverifyReceiptからエラーを返します。

00:30:38.000 --> 00:30:43.000
これらの新しいサンドボックスの機能強化は、App Store Connectのサンドボックステスターページからアクセスできます。

00:30:43.000 --> 00:30:51.000
購入履歴を消去するには、[編集]を選択し、テスターを切り替えて、[購入履歴を消去]ボタンを選択します。

00:30:51.000 --> 00:30:56.000
テスターの購入履歴のクリアを確認すると、アクションを元に戻すことはできません。

00:30:56.000 --> 00:31:00.000
だから、このオプションを選択したテスターを覚えておいてください。

00:31:00.000 --> 00:31:08.000
購入履歴のクリアは、新しいアカウントを作成せずに何かを再度購入できる強力な新しいテストツールです。

00:31:08.000 --> 00:31:12.000
また、テスト用の新鮮で空の領収書を持つこともできます。

00:31:12.000 --> 00:31:21.000
アカウントの地域を変更したり、サブスクリプション更新率を調整したりするには、テスターページに戻り、テスターの行を選択します。

00:31:21.000 --> 00:31:29.000
テスターの設定では、App Storeの地域を変更し、サブスクリプションの更新率を調整するための新しいオプションが表示されます。

00:31:29.000 --> 00:31:34.000
目的の地域を選択することで、テスターのアカウント地域を変更できます。

00:31:34.000 --> 00:31:42.000
これにより、サンドボックスの175のストアフロントでテストすることができ、すべて1つのテスターアカウントでテストできます。

00:31:42.000 --> 00:31:47.000
最後の新しいサンドボックス機能は、サンドボックスでのサブスクリプション更新率を調整することです。

00:31:47.000 --> 00:31:51.000
これを編集するには、ドロップダウンから希望の更新率を選択します。

00:31:51.000 --> 00:31:55.000
現在、1か月はサンドボックスの5分と相関しています。

00:31:55.000 --> 00:32:00.000
テスターの更新率を調整するためのオプションをいくつか提供します。

00:32:00.000 --> 00:32:12.000
サブスクリプションの更新率を調整すると、サブスクリプションのキャンセル、アップグレード、ダウングレードなどの時間が増え、更新を迅速にスピードアップして長期的な顧客をシミュレートできます。

00:32:12.000 --> 00:32:15.000
それが私たちが今年サンドボックスに来るすべてです。

00:32:15.000 --> 00:32:18.000
これらの新機能でテストを気に入っていただければ幸いです。

00:32:18.000 --> 00:32:23.000
だから、私たちは今日多くの新しい情報をカバーしました、そして今、私はあなたにそのすべてを探求できるようにしてほしいです。

00:32:23.000 --> 00:32:29.000
新しいJWSの領収書を採用するために、アプリとサーバーを更新するのに時間がかかることを願っています。

00:32:29.000 --> 00:32:34.000
新しいApp Store Server API、特に現在稼働しているサンドボックスで活用してください。

00:32:34.000 --> 00:32:42.000
そして、まだ登録していない場合は、App Storeサーバー通知に登録し、今年後半に予定されているv2アップデートの準備をしてください。

00:32:42.000 --> 00:32:45.000
私たちの新しいサンドボックスの強化も今年後半に来ます。

00:32:45.000 --> 00:32:49.000
これらを活用して、サンドボックスのテスト体験を向上させてください。

00:32:49.000 --> 00:32:57.000
最後に、このシリーズの今年の他の2つのセッション「Meet StoreKit 2」と「顧客をサポートし、払い戻しを処理する」をチェックしてください。

00:32:57.000 --> 00:33:12.000
App Storeサーバー通知の背景とその設定方法については、WWDC 2020の「アプリ内購入の新機能」とWWDC 2019の「アプリ内購入とサーバー間通知の使用」をご覧ください。

00:33:12.000 --> 00:33:20.000
当社の領収書、API、通知は、サーバーからアプリ内購入を管理するために必要な3つの強力なツールです。

00:33:20.000 --> 00:33:25.000
これらを活用することで、サーバーとアプリをこれまで以上に強力にすることができます。

00:33:25.000 --> 00:33:31.000
今日紹介したすべての新機能を活用してください。ご意見をお待ちしております。

00:33:31.000 --> 00:33:37.000
今日は聞いてくれてありがとう、そしてWWDCの残りの部分を楽しんでください。

00:33:37.000 --> 23:59:59.000
[明るい音楽]。

