WEBVTT

00:00:02.000 --> 00:00:12.000
こんにちは、WWDCへようこそ。

00:00:12.000 --> 00:00:23.000
私の名前はApp StoreのテクニカルプログラムマネージャーであるManjeet Chawlaです。顧客をサポートし、払い戻しを処理するのに役立つ新機能について話すことに本当に興奮しています。

00:00:23.000 --> 00:00:28.000
これは、アプリ内購入に焦点を当てた3部構成のシリーズの3番目のセッションです。

00:00:28.000 --> 00:00:39.000
また、「Meet StoreKit 2」や「サーバーでのアプリ内購入の管理」をまだ見ていない場合は、このセッションの後を見て、完全なストーリーを入手することをお勧めします。

00:00:39.000 --> 00:00:47.000
このセッションでは、まずカスタマーサポートと、顧客にコンテクストサポートを提供する方法について説明します。

00:00:47.000 --> 00:00:56.000
そして、払い戻しはサポートの重要な部分であるため、私の同僚であるジョーは、払い戻しプロセスに情報を提供し、改善するための払い戻しの処理と新しいサーバーAPIについて話します。

00:00:56.000 --> 00:01:06.000
App Storeでビジネスが成長するにつれて、顧客をサポートし、スケーラブルなサポートを提供することの利点と課題から始めましょう。

00:01:06.000 --> 00:01:23.000
アプリが自動更新サブスクリプションを提供する場合でも、消耗品や非消耗品などの1回限りのアプリ内購入を提供する場合でも、カスタマーサポートの問題をタイムリーかつ効率的に解決するために、新しいStoreKitおよびApp StoreサーバーAPIを導入しています。

00:01:23.000 --> 00:01:44.000
また、サポートの提供に加えて、これらのAPIは、最初に獲得した後、既存の顧客との関係を管理し、全体的なリテンションを高め、顧客満足度を向上させ、エンゲージメントの向上につながり、長期的な収益を増やす解約を減らすのに役立ちます。

00:01:44.000 --> 00:01:52.000
今日、顧客がアプリ内購入のヘルプが必要な場合は、Appleまたは開発者であるあなたに連絡することができます。

00:01:52.000 --> 00:02:05.000
また、シナリオに基づいて、お客様はAppleのセルフサービスWebサイト「Report-A-Problem」を使用するか、電話、電子メール、またはチャットでAppleサポートに連絡して問題に対処することができます。

00:02:05.000 --> 00:02:14.000
あるいは、ソーシャルメディア、フォーラム、またはアプリ内のライブチャットを通じてあなたに連絡することもあります。

00:02:14.000 --> 00:02:20.000
そして、彼らがアプリ内購入についてあなたに連絡したとき、問題はこれらのシナリオの1つに分類される可能性があります。

00:02:20.000 --> 00:02:39.000
顧客のアプリ内購入や払い戻しの特定から、サービスの問題や停止に対する補償の提供、サブスクリプションの管理や払い戻しのリクエストの支援まで、これらの質問はサポートシナリオのほとんどをカバーし、各シナリオをより詳細に説明します。

00:02:39.000 --> 00:02:46.000
最初のシナリオから始めましょう。顧客が最初にサポートのためにあなたに連絡したとき、顧客が行った購入をどのように識別しますか?

00:02:46.000 --> 00:02:51.000
さて、App Storeでコンテンツを購入したことがあるなら、すでにこのメールを見ているかもしれません。

00:02:51.000 --> 00:02:58.000
今日、顧客がアプリ内購入を行うと、その購入の請求書がメールで届きます。

00:02:58.000 --> 00:03:03.000
この請求書には、請求書ごとに一意の注文IDが含まれています。

00:03:03.000 --> 00:03:10.000
また、お客様は電子メールで、またはアカウント設定での購入履歴を見ることで、これにアクセスできます。

00:03:10.000 --> 00:03:25.000
そして今、顧客がサポートのためにあなたに連絡するとき、あなたは顧客に請求書の注文IDを尋ね、新しいサーバー間APIを使用して、顧客が提示した請求書のアプリ内購入を検索することができます。

00:03:25.000 --> 00:03:32.000
このAPIは、請求書の検証に加えて、アプリ内購入に関する問題を特定するのにも役立ちます。

00:03:32.000 --> 00:03:40.000
たとえば、請求書にApp Storeからすでに返金された購入が含まれている場合。

00:03:40.000 --> 00:03:44.000
では、このAPIがどのように機能するかを見てみましょう。

00:03:44.000 --> 00:04:01.000
これで、顧客がサポートチームに連絡すると、顧客に請求書注文IDを尋ねることができ、サーバーは請求書検索APIを呼び出すことができ、それに応じて、App StoreはJWS形式で署名されたその請求書のステータスとトランザクションを返します。

00:04:01.000 --> 00:04:08.000
そして最後に、この情報を使用して、正しいアプリ内購入のサポートを提供できます。

00:04:08.000 --> 00:04:20.000
このAPIをサーバーに実装するには、URLの請求書注文IDとリクエストのアプリのApple IDを使用してルックアップエンドポイントを呼び出すことができます。

00:04:20.000 --> 00:04:29.000
応答には、JWS形式で署名されたその請求書のトランザクションを含むsignedTransactionsオブジェクトが含まれています。

00:04:29.000 --> 00:04:35.000
各トランザクションのペイロードをデコードして、購入の詳細を取得できます。

00:04:35.000 --> 00:04:39.000
では、新しいステータスフィールドを詳しく見てみましょう。

00:04:39.000 --> 00:04:43.000
このフィールドは、請求書の全体的なステータスを識別します。

00:04:43.000 --> 00:04:59.000
可能な値は0で、請求書が有効であり、この注文IDのトランザクションが含まれていることを意味し、1は注文IDが無効であることを意味し、2は請求書が有効であることを意味しますが、この注文IDに一致するトランザクションは見つかりませんでした。

00:04:59.000 --> 00:05:05.000
では、このAPIからの応答を使用する方法の例を見てみましょう。

00:05:05.000 --> 00:05:15.000
これは、各顧客のアプリ内購入の元のTransactionIdと、製品IDと購入日を格納する可能性のあるサンプル顧客アカウントデータベースです。

00:05:15.000 --> 00:05:25.000
このAPIを使用すると、顧客が問題について連絡したときに、請求書注文IDを顧客のアプリ内購入にリンクすることができます。

00:05:25.000 --> 00:05:36.000
たとえば、この顧客がアプリでコインを購入し、サポートを求めて連絡した場合、購入したコインの請求書注文IDを保存できます。

00:05:36.000 --> 00:05:43.000
さて、顧客の元のTransactionIdがあり、過去の払い戻しを検索したいシナリオを考えてみましょう。

00:05:43.000 --> 00:05:52.000
今日では、払い戻しに関する通知を受け取るために、verifyReceipt APIまたはApp Storeサーバーの通知に頼っているかもしれません。

00:05:52.000 --> 00:06:02.000
ただし、停止があり、サーバーがApp Storeから通知を受信しなかった場合、この顧客の過去の払い戻しをどのように検索しますか?

00:06:02.000 --> 00:06:14.000
アプリ内のアプリ内購入の元のトランザクションIDを使用して、顧客の返金されたトランザクションを検索するための新しいサーバー間APIを導入しています。

00:06:14.000 --> 00:06:23.000
このAPIを使用すると、いつでも迅速かつ簡単に払い戻しを調べることで、停止や定期メンテナンスを処理できます。

00:06:23.000 --> 00:06:30.000
さらに、このAPIは、アプリの顧客の払い戻し履歴全体を特定するのにも役立ちます。

00:06:30.000 --> 00:06:41.000
たとえば、アプリがサブスクリプションと消耗品の両方を提供している場合、このAPIはすべてのコンテンツタイプで払い戻されたすべてのトランザクションを返します。

00:06:41.000 --> 00:06:53.000
このAPIをサーバーに実装するには、URLに元のトランザクションIDと、リクエストパラメータにアプリのApple IDを使用してリクエストを作成します。

00:06:53.000 --> 00:06:59.000
応答には、JWS形式で署名された返金されたトランザクションのリストが含まれています。

00:06:59.000 --> 00:07:07.000
各トランザクションのペイロードをデコードすることで、購入に必要なすべての情報を取得できます。

00:07:07.000 --> 00:07:22.000
したがって、サンプル顧客アカウントデータベースに戻ると、このAPIによって返された情報を使用して、元のトランザクションIDを使用してこの顧客の返金されたトランザクションを更新できるようになりました。

00:07:22.000 --> 00:07:27.000
さて、サービスの問題があったことを確認した後、どのように顧客に補償しますか?

00:07:27.000 --> 00:07:30.000
今日、考慮すべきいくつかの異なる選択肢があります。

00:07:30.000 --> 00:07:38.000
ゲームの場合、仮想通貨やコンテンツの形で何らかの形のアプリ内報酬を提供している可能性があります。

00:07:38.000 --> 00:07:43.000
または、サブスクリプションの場合は、次回の更新時に割引を提供することをお勧めします。

00:07:43.000 --> 00:07:47.000
では、サービスの問題について加入者にどのように補償しますか?

00:07:47.000 --> 00:08:01.000
iOS 14では、サブスクリプションオファーコードと呼ばれる新機能を導入し、期間限定で割引または無料でサブスクリプションを提供することで、加入者の獲得、維持、獲得を支援します。

00:08:01.000 --> 00:08:07.000
これらのユニークなワンタイムコードは、オンラインまたはオフラインのチャネルを使用して配布できます。

00:08:07.000 --> 00:08:16.000
また、カスタマーサービスの問題については、問題の補償としてオファーコードを提供でき、リテンションの向上に役立ちます。

00:08:16.000 --> 00:08:21.000
また、これを代替サブスクリプションを提案する機会として使用することもできます。

00:08:21.000 --> 00:08:27.000
たとえば、低価格でより多くの価値を提供するより長い期間のプラン。

00:08:27.000 --> 00:08:42.000
また、iOS 14およびiPadOS 14以降のお客様は、StoreKitにpresentCodeRedemptionSheet APIを実装している場合は、1回限りのコード引き換えURLまたはアプリ内でApp Storeでオファーコードを引き換えることができます。

00:08:42.000 --> 00:08:47.000
では、アプリ内のサンプルコード償還フローを見てみましょう。

00:08:47.000 --> 00:08:53.000
作成する必要がある唯一のカスタムUIは、償還フローを開始するものです。

00:08:53.000 --> 00:08:57.000
このUIを提供する自然な場所がいくつかあります。

00:08:57.000 --> 00:09:06.000
たとえば、顧客がサポートエージェントとチャットしているとき、アプリの設定画面やライブチャット機能内で。

00:09:06.000 --> 00:09:20.000
顧客が引き換えボタンをタップすると、システムは自動的にここに示されているような一連のコード償還画面を提供し、顧客がコードを入力してオファーを引き換えます。

00:09:20.000 --> 00:09:32.000
さて、停電やイベントがキャンセルされたシナリオを見てみましょう。これは、スポーツ、ライブテレビ、ビデオなどのストリーミングベースのアプリでより一般的かもしれません。

00:09:32.000 --> 00:09:37.000
これらの停止やキャンセルされたイベントのために、どのように顧客をなだめることができますか?

00:09:37.000 --> 00:09:46.000
有料アクティブサブスクリプションの更新日を延長するために、自動更新サブスクリプション用の新しいサーバーツーサーバーAPIを導入しています。

00:09:46.000 --> 00:09:57.000
このAPIを使用すると、一時的な停止やサービスの問題に対する柔軟な対応として使用できる、追加の時間のために顧客に無料サービスを提供できます。

00:09:57.000 --> 00:10:09.000
顧客のサブスクリプションの更新日は暦年に2回、それぞれ最大90日後に移動できるため、サービスの問題や停止を柔軟に解決できます。

00:10:09.000 --> 00:10:18.000
延長期間は、85%の収益率を受け取るために必要な1年間の有料サービスにはカウントされないことに注意してください。

00:10:18.000 --> 00:10:23.000
では、このAPIをサーバーに実装する方法を見てみましょう。

00:10:23.000 --> 00:10:34.000
このAPIのリクエストには、顧客のサブスクリプションの元のトランザクションID、延長期間（日数）、および延長の理由コードが必要です。

00:10:34.000 --> 00:10:51.000
応答には、リクエストで渡されたトランザクションID、拡張更新のWeb注文ラインアイテムID、リクエストが成功したかどうかを示す成功フラグ、リクエストが成功した場合の延長の発効日が含まれています。

00:10:51.000 --> 00:10:56.000
では、このAPIを使用できる2つの異なるシナリオを見てみましょう。

00:10:56.000 --> 00:11:12.000
最初のシナリオでは、顧客がサービスの問題や停止についてサポートチームに連絡すると、このAPIを呼び出すことで顧客をなだめることができ、それに応じてApp Storeはサブスクリプションを延長し、電子メールで顧客に通知します。

00:11:12.000 --> 00:11:33.000
または2番目のシナリオでは、不測の事態によるスポーツの試合のキャンセル、またはライブストリーミングイベントの中断が発生した場合、サポートチームはこのAPIを積極的に使用でき、それに応じて、App Storeはサブスクリプションを延長し、電子メールで顧客に通知します。

00:11:33.000 --> 00:11:42.000
さて、顧客がサブスクリプションを管理したいシナリオでは、顧客がアプリ内でサブスクリプションを管理できるようにするにはどうすればよいですか?

00:11:42.000 --> 00:11:56.000
サブスクリプション管理ページを表示する新しいStoreKit 2 APIを導入しています。これにより、顧客をApp Storeにリダイレクトすることなく、アプリ内でサブスクリプション管理機能を提供できます。

00:11:56.000 --> 00:12:08.000
オプションで、サブスクリプションの管理ページが表示される前にセーブオファーを提示するか、キャンセル後に終了アンケートを表示してキャンセル理由を取得することもできます。

00:12:08.000 --> 00:12:16.000
また、このAPIを使用すると、サンドボックス環境でサブスクリプション購入の管理をテストすることもできます。

00:12:16.000 --> 00:12:20.000
このAPIは実装が本当に簡単で、1行のコードが必要です。

00:12:20.000 --> 00:12:28.000
StoreKit 2 で showManageSubscriptions() メソッドを呼び出すだけで、サブスクリプションの管理ページが表示されます。

00:12:28.000 --> 00:12:33.000
では、アプリのサブスクリプション管理UIのサンプルを見てみましょう。

00:12:33.000 --> 00:12:38.000
アカウント設定では、ユーザーがサブスクリプションを管理するためのオプションを追加できます。

00:12:38.000 --> 00:12:49.000
顧客がこのボタンをタップすると、App Storeには既存のサブスクリプション管理ページが表示され、現在アクティブなサブスクリプションと更新オプションが表示されます。

00:12:49.000 --> 00:13:01.000
これは、App Storeのアカウント設定でサブスクリプションの管理にアクセスしたときに顧客がよく知っているのと同じビューで、サブスクリプションを表示、アップグレード、ダウングレード、またはキャンセルすることができます。

00:13:01.000 --> 00:13:10.000
これで、お客様がサブスクリプションをキャンセルすることを選択した場合、キャンセルの詳細とサービスの有効期限が記載された確認画面が表示されます。

00:13:10.000 --> 00:13:22.000
そして、ユーザーがこのページで実行する可能性のあるアクションに対して、サーバーはApp Storeサーバーの通知を受け取り、新しいStoreKit 2 APIを実装した場合、アプリに通知されます。

00:13:22.000 --> 00:13:31.000
最後に、顧客が購入に不満があり、払い戻しをリクエストしたい場合は、助けを得るためにアプリを離れる必要はありません。

00:13:31.000 --> 00:13:36.000
では、顧客がアプリ内で払い戻しをリクエストできるようにするにはどうすればよいですか?

00:13:36.000 --> 00:13:47.000
現在、startRefundRequestと呼ばれる新しいStoreKit 2 APIを導入しています。これにより、顧客はアプリ内から直接アプリ内購入の払い戻しをリクエストできます。

00:13:47.000 --> 00:13:55.000
また、払い戻しが承認されると、アプリに通知され、サーバーはApp Storeから払い戻し通知を受け取ります。

00:13:55.000 --> 00:14:02.000
または、払い戻しが拒否された場合、サーバーは新しいREFUND-DECLINED通知を受け取ります。

00:14:02.000 --> 00:14:11.000
そして、初めて、このAPIを使用して、アプリ内でサンドボックスで払い戻しを開始し、テストできるようになりました。

00:14:11.000 --> 00:14:20.000
このAPIを実装するには、その購入のトランザクションIDでbeginRefundRequestメソッドを呼び出すだけです。

00:14:20.000 --> 00:14:26.000
また、リクエストが送信された後、do-catchステートメントを使用してエラーを処理できます。

00:14:26.000 --> 00:14:39.000
たとえば、これがすでに返金されたトランザクションの重複リクエストである場合、またはその他の理由でリクエストが失敗した場合、エラーコードは返金リクエストのステータスを反映します。

00:14:39.000 --> 00:14:43.000
これは、アプリの払い戻しリクエストUIのサンプルです。

00:14:43.000 --> 00:14:48.000
ヘルプページには、「払い戻しをリクエストする」という新しいオプションがあります。

00:14:48.000 --> 00:14:54.000
選択すると、アプリはその顧客が払い戻しを要求するための購入を表示します。

00:14:54.000 --> 00:15:09.000
また、電力サージ購入が期待どおりに機能しなかった場合、お客様はその購入をタップして、購入の詳細とお客様が選択する理由コードのリストを含む払い戻しリクエストシートを呼び出すことができます。

00:15:09.000 --> 00:15:23.000
リクエストが送信されると、アプリ内確認画面に加えて、App Storeは顧客にAppleの「問題を報告する」へのリンクを記載したメールを送信し、払い戻しのステータスを確認できます。

00:15:23.000 --> 00:15:34.000
そのため、新しいAPIを使用すると、アプリ内や他のサポートチャネル全体で、アプリ内購入のコンテキストとシームレスなサポートを提供できるようになりました。

00:15:34.000 --> 00:15:47.000
優れたサポートを提供することは、全体的なリテンションを高め、顧客満足度を向上させ、より高いエンゲージメントにつながり、最終的にはより肯定的な評価とレビューにつながります。

00:15:47.000 --> 00:15:50.000
言い換えれば、それは誰にとってもより良い経験です。

00:15:50.000 --> 00:16:02.000
さて、新しい払い戻しリクエストAPIを使用して払い戻しをリクエストする方法を顧客に提供する方法について話しましたが、リクエストを開始した後に行われる払い戻しにはもっと多くのものがあります。

00:16:02.000 --> 00:16:10.000
だから、私は同僚のジョーを招待して、払い戻しの処理と払い戻しの決定に関する新しい機会についてもっと話すつもりです。

00:16:10.000 --> 00:16:12.000
ありがとう、マンジート。

00:16:12.000 --> 00:16:16.000
こんにちは、私の名前はジョー・マニで、App Storeのプログラムマネージャーです。

00:16:16.000 --> 00:16:20.000
払い戻しはデリケートな話題であり、ここApp Storeでは真剣に受け止めています。

00:16:20.000 --> 00:16:26.000
それは取引のごく一部に影響しますが、それがあなたのアプリに与える影響を理解しています。

00:16:26.000 --> 00:16:32.000
WWDC20で開始された払い戻し通知の簡単な要約から始めたいと思います。

00:16:32.000 --> 00:16:35.000
次に、払い戻しの処理方法についていくつかの洞察を提供します。

00:16:35.000 --> 00:16:42.000
最後に、払い戻しプロセスを通知し、改善するのに役立つ新機能について説明します。

00:16:42.000 --> 00:16:47.000
WWDC20では、REFUNDという新しい通知タイプを発表しました。

00:16:47.000 --> 00:16:54.000
顧客に払い戻しが発行された後、App Storeは払い戻し通知をサーバーに送信します。

00:16:54.000 --> 00:17:01.000
App Store ConnectでサーバーURLを設定している場合は、すでに払い戻し通知を受け取っている可能性があります。

00:17:01.000 --> 00:17:08.000
サーバーがこの通知を受信したら、成功したHTTPステータスコード200で応答します。

00:17:08.000 --> 00:17:14.000
その後、それに応じて払い戻しのために適切な措置を講じることができます。

00:17:14.000 --> 00:17:22.000
REFUND通知の開始以来、私たちはあなたのフィードバックを聞く機会がありました、そして私はあなたといくつかのベストプラクティスを共有したいと思います。

00:17:22.000 --> 00:17:26.000
ビジネスモデルに最適な対応戦略を見つけてください。

00:17:26.000 --> 00:17:38.000
たとえば、ユーザーがゲーム内通貨を購入し、払い戻しを要求した場合、サーバーが払い戻し通知を受け取った後、アカウントから残高を差し引くことができます。

00:17:38.000 --> 00:17:46.000
一方、サブスクリプションの場合、サブスクリプションが返金およびキャンセルされた後、サービスへのアクセスを取り消すことができます。

00:17:46.000 --> 00:17:52.000
対応戦略を特定する際には、ゲームデザインへの影響を考慮してください。

00:17:52.000 --> 00:18:05.000
マーケティングおよびプロモーションツールを使用して顧客を再エンゲージし、実行したアクションについて、コミュニケーションチャネル全体で常に顧客に明確なメッセージングを提供します。

00:18:05.000 --> 00:18:11.000
ゲーム内通貨としてコインを提供するアプリのサンプル払い戻しタイムラインを見てみましょう。

00:18:11.000 --> 00:18:17.000
顧客が100枚のコインを購入した後、彼らはすぐにあなたのゲーム内でそれらのコインを使うかもしれません。

00:18:17.000 --> 00:18:25.000
お客様が新しいリクエスト払い戻しAPIを使用するか、Appleサポートに連絡して払い戻しをリクエストした場合。

00:18:25.000 --> 00:18:33.000
また、払い戻しが承認された場合、App Storeは払い戻しを発行し、サーバーに払い戻し通知を送信し、顧客にも通知します。

00:18:33.000 --> 00:18:37.000
そして、これは通常48時間以内に起こります。

00:18:37.000 --> 00:18:44.000
それでは、払い戻しが要求された後、App Storeが決定を下す前に何が起こるかを見てみましょう。

00:18:44.000 --> 00:18:51.000
高いレベルでは、各払い戻し要求は、払い戻し決定システムを通過して決定を下します。

00:18:51.000 --> 00:19:00.000
払い戻し決定システムには、問題となっている取引に関する情報や、お客様の購入履歴や払い戻し履歴などのその他の要因が含まれます。

00:19:00.000 --> 00:19:12.000
さて、払い戻しの決定においてより積極的な役割を果たしたいと聞いたので、払い戻しプロセスを改善し、通知する新機能を発表できることを嬉しく思います。

00:19:12.000 --> 00:19:20.000
新しい消費APIを使用すると、顧客のアプリ内購入に関する情報をApp Storeと共有できます。

00:19:20.000 --> 00:19:33.000
顧客が消耗品のアプリ内購入の払い戻しを要求すると、App Storeは、消費データで返信するために、CONSUMPTION-REQUESTと呼ばれる新しい通知をサーバーに送信します。

00:19:33.000 --> 00:19:41.000
ほとんどの場合、顧客は購入した後すぐにコンテンツを消費し始め、この情報を知ることは払い戻しの決定プロセスに役立ちます。

00:19:41.000 --> 00:19:50.000
払い戻しの決定を通知するために使用できるように、消費要求を受け取ってから12時間以内に消費情報をApp Storeに送信してください。

00:19:50.000 --> 00:19:55.000
では、消費データに含まれるフィールドを見てみましょう。 

00:19:55.000 --> 00:20:03.000
消費ペイロードには次のデータポイントが含まれており、それぞれが払い戻しの決定を通知するのに役立ちます。

00:20:03.000 --> 00:20:09.000
まず、リクエストURLにアプリ内購入の元のトランザクションIDを含めます。

00:20:09.000 --> 00:20:22.000
Appleが意思決定にそのデータを使用するために、ユーザーが要求された消費APIデータをAppleに送信することに同意した場合は、customerConsentedフィールドを「true」に設定します。

00:20:22.000 --> 00:20:24.000
消費ステータスフィールドは重要です。

00:20:24.000 --> 00:20:30.000
ユーザーがアプリ内購入を部分的に消費したか、完全に消費したか、まったく消費しなかったかを示すために使用します。

00:20:30.000 --> 00:20:41.000
たとえば、アプリに物々交換がある交換プラットフォームがある場合、またはあるアカウントから別のアカウントに転送されたアプリ内購入がある場合、それは消費されたと見なされます。

00:20:41.000 --> 00:20:47.000
消費プラットフォームフィールドは、アプリがクロスプラットフォームであるかどうか、どこで消費されたかを識別します。

00:20:47.000 --> 00:20:58.000
sampleContentフィールドを使用して、ユーザーに無料サンプルまたはトライアルを提供したかどうか、またはユーザーがアプリ内で同様のアプリ内購入を与えられたかどうかを示します。

00:20:58.000 --> 00:21:09.000
または、このフィールドを使用して、ユーザーが購入前にアプリ内購入と予想されるゲームプレイまたはメカニックに関する情報を提供されたかどうかを示します。

00:21:09.000 --> 00:21:17.000
deliveryStatusフィールドを使用して、アプリ内購入が顧客に正常に配信され、正常に機能したことを示します。

00:21:17.000 --> 00:21:20.000
appAccountTokenは、StoreKit 2で導入された新しいフィールドです。

00:21:20.000 --> 00:21:31.000
これは、あなたが作成したアプリのユーザーアカウントに関連付けられたUUIDで、購入を開始し、購入のためにコンテンツを消費します。

00:21:31.000 --> 00:21:43.000
残りのフィールドには、ユーザーがアカウントを持っている期間、アプリでプレイした時間、総支出、アカウントの現在のステータスに関する情報が含まれます。

00:21:43.000 --> 00:21:57.000
払い戻しリクエストには、3つの関連するApp Storeサーバー通知があります。消耗品のアプリ内購入の払い戻しリクエストが開始されたときに通知する新しいCONSUMPTION-REQUEST通知。

00:21:57.000 --> 00:22:05.000
すべてのコンテンツタイプについて、払い戻し通知は、払い戻しが顧客に発行されたときに通知します。

00:22:05.000 --> 00:22:15.000
また、すべてのコンテンツタイプについて、Store Kit APIを使用して開始されたリクエストの払い戻しが拒否されたときに、REFUND-DECLINED通知通知が通知します。

00:22:15.000 --> 00:22:17.000
では、払い戻しのタイムラインに戻りましょう。

00:22:17.000 --> 00:22:28.000
お客様が消耗品のアプリ内購入の払い戻しを要求すると、App Storeサーバーがサーバーに消費リクエスト通知を送信します。

00:22:28.000 --> 00:22:36.000
サーバーは12時間以内に応答し、消費データをApp Storeサーバーに戻し、意思決定に使用されます。

00:22:36.000 --> 00:22:50.000
承認された場合、App Storeは払い戻し通知を送信し、サーバーがHTTP OK応答で応答した後、その払い戻しに対して適切な措置を講じることができます。

00:22:50.000 --> 00:22:56.000
そして、消費APIは、今日の時点で生産とサンドボックスでのテストの両方で利用可能です。

00:22:56.000 --> 00:23:02.000
それでは、新しい消費APIでAppleに情報を送信する利点のいくつかを取り上げましょう。

00:23:02.000 --> 00:23:08.000
これらのデータポイントを取得すると、透明性が向上し、全体的な払い戻しプロセスが改善されます。

00:23:08.000 --> 00:23:13.000
これは、順番に、あなたの顧客により良い全体的な結果を提供します。

00:23:13.000 --> 00:23:22.000
また、新しいREFUND通知により、顧客に連絡する機会が増え、全体的なコミュニケーションが向上します。

00:23:22.000 --> 00:23:28.000
さて、私はそれを同僚のManjeetに渡して、私たちがカバーしたすべてからいくつかの重要なポイントを共有したいと思います。

00:23:28.000 --> 00:23:31.000
だから、今日は多くのトピックを取り上げました。

00:23:31.000 --> 00:23:34.000
このセッションの重要なポイントを見てみましょう。教えてください。

00:23:34.000 --> 00:23:46.000
新しいStoreKit APIを使用すると、顧客が払い戻しやサブスクリプションをリクエストするためのカスタムヘルプUIをアプリに実装できるようになりました。これは、アプリ内でサブスクリプションを管理する方法です。

00:23:46.000 --> 00:23:53.000
新しいサーバー間APIを実装して、カスタマーサポートジャーニーを見直し、最適化します。

00:23:53.000 --> 00:24:00.000
たとえば、請求書検索APIを使用して、顧客のアプリ内購入を特定して検証します。

00:24:00.000 --> 00:24:10.000
また、まだ設定していない場合は、App Storeから払い戻し、消費リクエスト、その他のステータス更新通知を受け取るようにサーバーを設定してください。

00:24:10.000 --> 00:24:17.000
払い戻し時に行動を起こすために、アプリのビジネスモデルに最適な対応戦略を特定します。

00:24:17.000 --> 00:24:29.000
そして最後に、最新の消費データを送信して、App Storeからの消費要求通知に応答することで、Appleの払い戻し決定システムに通知できるようになりました。

00:24:29.000 --> 00:24:32.000
だから、これは「顧客をサポートし、払い戻しを処理する」でした。

00:24:32.000 --> 00:24:45.000
新しいStoreKit 2 APIの詳細については、「Meet StoreKit 2」をご覧ください。また、アプリ内購入のサーバーサイドロジックの構築の詳細については、「サーバーでアプリ内購入を管理する」をご覧ください。

00:24:45.000 --> 00:24:49.000
今日は聞いてくれてありがとう、そしてWWDCの残りの部分を楽しんでください。

00:24:49.000 --> 23:59:59.000
[パーカッシブミュージック]。

