WEBVTT

00:00:02.000 --> 00:00:14.000
こんにちは、私はジェイコブです。「SwiftUIアプリにリッチグラフィックスを追加する」へようこそ。

00:00:14.000 --> 00:00:18.000
私は何人かの同僚と一緒にグラデーションを構築するためのアプリに取り組んでいます。

00:00:18.000 --> 00:00:21.000
今年、色は私たちのチームでホットなものです。

00:00:21.000 --> 00:00:24.000
ほとんどの実装はすでに完了しています。

00:00:24.000 --> 00:00:27.000
今、私はいくつかの豊かなグラフィックを追加してそれを終える必要があります。

00:00:27.000 --> 00:00:42.000
アプリをカスタマイズすると、いくつかの異なる領域が表示されます。安全な領域のカスタマイズを含む安全な領域での作業、新しいフォアグラウンドスタイルのサポート、豊富な新しい素材セット、キャンバスを使った描画、強力な新しいビュー。

00:00:42.000 --> 00:00:44.000
では、始めましょう。

00:00:44.000 --> 00:00:47.000
これまでにアプリに何が入っているかをお見せします。

00:00:47.000 --> 00:00:51.000
グラデーションのライブラリがあり、それらのグラデーションを見ることができます。

00:00:51.000 --> 00:00:53.000
これには私が本当に好きな何かがあります。

00:00:53.000 --> 00:00:55.000
私はそれの上に指を置くことができません。

00:00:55.000 --> 00:00:58.000
グラデーションを編集することもできます...

00:00:58.000 --> 00:01:06.000
これにより、カラーストップを変更できます。

00:01:06.000 --> 00:01:10.000
そして、新しいグラデーションを追加できます。

00:01:10.000 --> 00:01:14.000
これらのグラデーションは、いくつかのビジュアライザーでも使用できます...

00:01:14.000 --> 00:01:18.000
しかし、一歩ずつ。それらを少し後で見てみましょう。

00:01:18.000 --> 00:01:22.000
とりあえず、このグラデーションの詳細ビューに焦点を当てましょう。

00:01:22.000 --> 00:01:28.000
それは機能的ですが、実際のコンテンツはクロムと空きスペースに比べてかなり小さいです。

00:01:28.000 --> 00:01:31.000
この画面のグラデーションを本当に引き継いでほしい。

00:01:31.000 --> 00:01:35.000
では、Xcodeで編集を始めましょう。

00:01:35.000 --> 00:01:40.000
これは私たちの主な詳細ビューであり、編集モードにも使用されます。

00:01:40.000 --> 00:01:44.000
isEditing falseから始めて、後で編集モードを見てみましょう。

00:01:44.000 --> 00:01:51.000
このフレームを削除して、グラデーションでできるだけ多くのスペースを使用させましょう。

00:01:51.000 --> 00:01:57.000
勾配がすべての高さを占めている今、私たちはもはやこのスペーサーを必要としません。

00:01:57.000 --> 00:02:04.000
これをZStackに変更することで、このグラデーションの上にコントロールを置くことで、さらに進むことができます。

00:02:04.000 --> 00:02:11.000
以前にZStackを見たことがない場合は、互いに隣り合うのではなく、互いの上に要素をレイアウトします。

00:02:11.000 --> 00:02:18.000
編集コントロールを一番下に移動しましょう。

00:02:18.000 --> 00:02:22.000
そして、グラデーションではなく、コントロールにパディングだけが必要です。

00:02:22.000 --> 00:02:26.000
では、これを動かしましょう。

00:02:26.000 --> 00:02:33.000
パディングを取り除いた後でも、なぜグラデーションの上部と下部にまだ空きスペースがあるのか疑問に思うかもしれません。

00:02:33.000 --> 00:02:43.000
デフォルトでは、SwiftUIはコンテンツをセーフエリア内に配置し、ホームインジケーターや表示されているバーなど、ビューを不明瞭にしたりクリップしたりするものを避けます。

00:02:43.000 --> 00:02:50.000
安全な領域は、ビューが表示されている最も外側の完全な領域から挿入された領域として表されます。

00:02:50.000 --> 00:02:57.000
安全領域のコンテンツは、隠される領域を避けるために、適切なインセット内に自動的にレイアウトされます。

00:02:57.000 --> 00:03:02.000
安全なエリアは、SwiftUIがキーボードの下にコンテンツを描くのを避ける方法でもあります。

00:03:02.000 --> 00:03:07.000
したがって、私たちのアプリでは、私たちのコントロールは自動的にキーボードの邪魔にならないように持ち上げられます。

00:03:07.000 --> 00:03:13.000
これは同じように機能し、どのようにより詳しく見ると、複数の異なる安全領域があるためです。

00:03:13.000 --> 00:03:21.000
最も一般的なものはコンテナセーフエリアで、コンテナによって駆動され、ビューが内部に表示され、バーやデバイスクロームのようなものが含まれています。

00:03:21.000 --> 00:03:25.000
さらに、キーボードを避けるためのキーボードの安全なエリアがあります。

00:03:25.000 --> 00:03:30.000
また、キーボードセーフエリアは常にコンテナセーフエリア内の領域であることに注意してください。

00:03:30.000 --> 00:03:36.000
キーボードに加えて、コンテナの安全な領域と同じ領域からコンテンツを安全に保ちます。

00:03:36.000 --> 00:03:39.000
安全なエリアをオプトアウトすることは可能です。

00:03:39.000 --> 00:03:44.000
ほとんどのコンテンツはクリップされないように安全なエリア内にある必要があるため、通常はこれを行う必要はありません。

00:03:44.000 --> 00:03:46.000
結局のところ、それは安全です。

00:03:46.000 --> 00:03:52.000
しかし、安全なエリアを無視することは、完全にエッジからエッジまで行きたい背景やその他のコンテンツにとって理にかなっています。

00:03:52.000 --> 00:04:01.000
このコードを使用して、すべてのセーフエリアをオプトアウトするか、キーボードのエリアをオプトアウトするようにキーボード領域を指定できます。

00:04:01.000 --> 00:04:09.000
そのフルブリード効果を得るために、線形グラデーションにignosesSafeAreaを追加しましょう。

00:04:09.000 --> 00:04:19.000
この編集ボタンはグラデーションの上にはあまり見えないので、下端の安全な領域だけを無視しましょう。

00:04:19.000 --> 00:04:31.000
さて、この下のテキストがグラデーションから判読不能であるという同じ問題に遭遇しないようにするために、その背後に背景を追加しましょう。

00:04:31.000 --> 00:04:50.000
1分で背景をカスタマイズしますが、ダークモードで自動的に変更される白い背景を提供する最も単純なデフォルトから始めましょう。

00:04:50.000 --> 00:04:54.000
そして、この背景は自動的に安全なエリアを超えて広がっています。

00:04:54.000 --> 00:05:00.000
このバージョンの背景とその動作は、iOS 15と調整されたOSリリースで新しいものです。

00:05:00.000 --> 00:05:01.000
それがどのように機能するかを見てみましょう。

00:05:01.000 --> 00:05:05.000
コンテナビューとその安全なエリアから始めましょう。

00:05:05.000 --> 00:05:11.000
次に、コンテンツビューがあり、読みやすく保つために安全なエリア内にあります。

00:05:11.000 --> 00:05:16.000
適用されたビューに同じ境界を持つ背景を素朴に追加すると、これが表示されます。

00:05:16.000 --> 00:05:26.000
しかし、background viewだけにignosesSafeArea修飾子を適用すると、メインコンテンツを素敵で安全に保ちながら、セーフエリアを超えて拡大します。

00:05:26.000 --> 00:05:31.000
新しい背景修飾子は、この動作を自動的に提供します。

00:05:31.000 --> 00:05:34.000
背景に戻って、カスタマイズを始めましょう。

00:05:34.000 --> 00:05:42.000
グラデーションのような色や他のスタイルである可能性のある特定のスタイルで渡すことができます。

00:05:42.000 --> 00:05:47.000
このアプリではあまり意味がありませんが、パステルカラーのものを見てみましょう。

00:05:47.000 --> 00:05:51.000
私はまた、この背景をクリップする形を渡すことができます...

00:05:51.000 --> 00:05:58.000
例えば、丸みを帯びた長方形。

00:05:58.000 --> 00:06:05.000
カスタム図形を使用すると、図形がコンテンツの境界と一致するように、背景が安全領域の外に伸びなくなったことに注意してください。

00:06:05.000 --> 00:06:09.000
私たちのアプリにもっと合うと思うのは、私たちの背景のぼかしです。

00:06:09.000 --> 00:06:13.000
これを行うには、別の新しいAPIを使用できます。マテリアルです。

00:06:13.000 --> 00:06:17.000
素材は、適用できる標準的なぼかしスタイルのセットです。

00:06:17.000 --> 00:06:22.000
そして、この背景をエリア全体を取り上げることに戻しましょう。

00:06:22.000 --> 00:06:27.000
素材は、このようなカラフルなコンテンツを通して見せたい場所に最適です。

00:06:27.000 --> 00:06:32.000
超薄型から超薄型まで、さまざまな素材から選択できます。

00:06:32.000 --> 00:06:38.000
そして、これらはすべて、すべてのプラットフォームで適切なデザインを自動的に表示します。

00:06:38.000 --> 00:06:41.000
私はここで薄い材料を使うつもりです。

00:06:41.000 --> 00:06:43.000
次に、テキストをカスタマイズしたいです。

00:06:43.000 --> 00:06:51.000
名前がここでの主な情報であることを示すために、色の数を少し目立たないようにしましょう。

00:06:51.000 --> 00:06:58.000
セカンダリのフォアグラウンドスタイルを設定することで、それを行うことができます。

00:06:58.000 --> 00:07:05.000
セカンダリコンテンツは、その背後にある色をブレンドするバイブランシーと呼ばれる効果で自動的に表示されることに気づいたかもしれません。

00:07:05.000 --> 00:07:08.000
SwiftUIでは、この効果のための追加のAPIはありません。

00:07:08.000 --> 00:07:14.000
物質的な文脈で新しいセカンダリから第四紀のスタイルを使用すると、自動的に発生します。

00:07:14.000 --> 00:07:24.000
これは、先ほどのように、マテリアルで背景を明示的に追加した場合、またはコンテンツがサイドバーなどのシステムコンポーネントにあり、マテリアルを追加する場合に発生する可能性があります。

00:07:24.000 --> 00:07:27.000
そして、これらのスタイルには多くの自動スマートがあります。

00:07:27.000 --> 00:07:34.000
ぼやけていないコンテキストでも使用すると、自動的に正しいことを行い、鮮やかな効果を使用しません。

00:07:34.000 --> 00:07:40.000
また、色を設定すると自動的に動作が変更され、各レベルの色のバージョンが設定されます。

00:07:40.000 --> 00:07:45.000
そして、同じサポートは、グラデーションのようなものであっても、任意のベースフォアグラウンドスタイルを設定するために機能します。

00:07:45.000 --> 00:07:47.000
上品に使ってください。

00:07:47.000 --> 00:07:54.000
注意すべき点：任意のテキストには、単一のフォアグラウンドスタイルを適用できますが、その範囲内で複数の色が適用されます。

00:07:54.000 --> 00:08:03.000
たとえば、文字列補間を使用して内部テキストを埋め込むことができます...

00:08:03.000 --> 00:08:08.000
そして、赤の前景色を適用します...

00:08:08.000 --> 00:08:09.000
「色」という言葉に。

00:08:09.000 --> 00:08:18.000
そして、それはその色を示し、その範囲の活気を自動的にオプトアウトします。

00:08:18.000 --> 00:08:28.000
さらに重要なことに、これらのフォアグラウンドスタイルでは、初めて、埋め込まれた絵文字で正しい動作を得ることができます。

00:08:28.000 --> 00:08:30.000
これは良さそうです。

00:08:30.000 --> 00:08:41.000
もう一度実行して、これらの変更で編集モードも試してみましょう。

00:08:41.000 --> 00:08:43.000
それはほとんどすでに機能しています。

00:08:43.000 --> 00:08:47.000
そして、これらの色はぼかしの下に入ります、それは素晴らしいです。

00:08:47.000 --> 00:08:51.000
しかし、よく見ると、それは正しいことをしていません。

00:08:51.000 --> 00:08:56.000
ずっと下にスクロールすると、ぼかしの後ろに隠されているリストが少しあります。

00:08:56.000 --> 00:08:58.000
何が起こっているのかもっと詳しく見てみましょう。 

00:08:58.000 --> 00:09:03.000
クロムを取り除き、ここで関連するビューだけを見てみましょう。

00:09:03.000 --> 00:09:11.000
これらのビューを少し水平にスライドさせると、バーがコンテンツの上にZStackedされているため、これがわかります。

00:09:11.000 --> 00:09:17.000
後ろのすべてのビューを見たいので、それは正しい行動ではありません。

00:09:17.000 --> 00:09:25.000
ここではVStackに変更できますが、ぼかしの下のリストがなければ、下にスクロールするときに色が表示されません。

00:09:25.000 --> 00:09:31.000
リストの背景とそのスクロール可能な領域をバーの下に拡張したいが、メインコンテンツは拡張したくない。

00:09:31.000 --> 00:09:34.000
そして、これはまさに安全なエリアのためのものです。

00:09:34.000 --> 00:09:40.000
このバーに安全なエリアを挿入させると、重要なコンテンツは隠されないままになります。

00:09:40.000 --> 00:09:46.000
独自のビューの安全な領域をカスタマイズするには、新しい修飾子「safeAreaInset」を使用できます。

00:09:46.000 --> 00:09:51.000
これにより、メインコンテンツの上にバーなどの補助コンテンツを追加できます。

00:09:51.000 --> 00:09:56.000
ZStackを交換します...

00:09:56.000 --> 00:10:03.000
safeAreaInsetで...

00:10:03.000 --> 00:10:07.000
ボトムのエッジを使用して...

00:10:07.000 --> 00:10:10.000
そして、それに私たちのコントロールを入れてください。

00:10:10.000 --> 00:10:17.000
もう一度実行して確認しましょう。

00:10:17.000 --> 00:10:20.000
この景色はまだ同じように見えますが、それは良いことです。

00:10:20.000 --> 00:10:24.000
それはセーフエリアを無視しているからです。

00:10:24.000 --> 00:10:27.000
そして、編集モードでは...

00:10:27.000 --> 00:10:30.000
私たちはまだそのぼかしを得るためにバーの下をスクロールすることができます。

00:10:30.000 --> 00:10:34.000
しかし、一番下までスクロールすると、何も隠されません。

00:10:34.000 --> 00:10:35.000
すごい。

00:10:35.000 --> 00:10:39.000
次に、ビジュアライザーを見てみましょう。

00:10:39.000 --> 00:10:44.000
すでに書かれているシェイプビジュアライザーから始めましょう。

00:10:44.000 --> 00:10:49.000
多数のランダムな形状記号が表示され、それぞれがアプリからのグラデーションの1つで描かれています。

00:10:49.000 --> 00:10:55.000
シンボルをタップしてズームアップできます...

00:10:55.000 --> 00:11:00.000
または、バックグラウンドをタップして、すべてのシンボルの位置を変更します。

00:11:00.000 --> 00:11:05.000
そして、以前にSwiftUIアニメーションのデモを見たことがあるなら、常にインタラクティブで中断可能であることを知っています。

00:11:05.000 --> 00:11:09.000
だから私は再配置し続けることができます...

00:11:09.000 --> 00:11:15.000
そして、それが起こっている間、タップして図形を選択および選択解除することもできます。

00:11:15.000 --> 00:11:19.000
もし私がコードを見に行ったら...

00:11:19.000 --> 00:11:23.000
SwiftUIでグラフィックを描画するための一般的な手法を使用しています。

00:11:23.000 --> 00:11:33.000
GeometryReaderがあるので、ビューのサイズを読んで、これらのグラフィックをすべてレイアウトし、それらを配置するのに役立つZStackがあります。

00:11:33.000 --> 00:11:38.000
そして、本文の最後には、以前に見たことのある修飾子があります：drawingGroup。

00:11:38.000 --> 00:11:44.000
drawingGroupは、SwiftUIに、含まれているすべてのビューを1つのレイヤーにまとめて描画するように指示します。

00:11:44.000 --> 00:11:51.000
これは、このようなグラフィカルな要素ではうまく機能しますが、テキストフィールドやリストなどのUIコントロールでは使用しないでください。

00:11:51.000 --> 00:11:57.000
これは、ここで行っているような多数のグラフィック要素を表示したいときに使用する素晴らしいテクニックです。

00:11:57.000 --> 00:12:07.000
そして、drawingGroupの利点の1つは、これらのビューの描画が異なっていても、アプリの他の場所で使用しているのと同じ機能をSwiftUIから使用できることです。

00:12:07.000 --> 00:12:18.000
たとえば、ここでは、各シンボルをタップするためのジェスチャーと、選択を変更したり位置を変更したりしたときに適用されるアニメーションがあります。

00:12:18.000 --> 00:12:26.000
これらのビューに含まれるアクセシビリティ情報も、通常通り渡されます。たとえば、各シンボルのこれらのアクセシビリティアクションなどです。

00:12:26.000 --> 00:12:31.000
ただし、これらの機能をすべてサポートするために、各ビューにはいくつかの簿記とストレージが必要です。

00:12:31.000 --> 00:12:36.000
あなたが十分な数の要素を持っているなら、その余分なオーバーヘッドでさえ多すぎるかもしれません。

00:12:36.000 --> 00:12:39.000
そして、そのようなケースのために、私たちは新しいキャンバスビューを導入しました。

00:12:39.000 --> 00:12:44.000
次のビジュアライザーは複雑な粒子システムを表示しますが、まだ書かれていません。

00:12:44.000 --> 00:12:46.000
それを作りに行きましょう。

00:12:46.000 --> 00:12:52.000
それを描くためにキャンバスビューから始めましょう。

00:12:52.000 --> 00:12:58.000
これにより、キャンバスが描画されるたびに実行され、描画コマンドを含むクロージャを作成できます。

00:12:58.000 --> 00:13:03.000
UIKitまたはAppKitのdrawRectに精通している場合、これはかなり同じように機能します。

00:13:03.000 --> 00:13:12.000
このクロージャは、描画コマンドを送信するコンテキストと、キャンバス全体のサイズを取得するために使用できるサイズを提供します。

00:13:12.000 --> 00:13:15.000
イメージを描くことから始めましょう。

00:13:15.000 --> 00:13:22.000
SwiftUIコードの残りの部分で使用しているのと同じ画像タイプを使用して作成できます。

00:13:22.000 --> 00:13:32.000
そして、私たちのイメージを描くように文脈を伝えましょう。

00:13:32.000 --> 00:13:37.000
0,0で描くと、ここにあり、原点を中心に、あまり目立たない。

00:13:37.000 --> 00:13:51.000
キャンバス全体のサイズが利用できるので、それを使って真ん中に描きましょう。

00:13:51.000 --> 00:13:58.000
そして、プレビューをダークモードに変更すればわかることが1つあります。

00:13:58.000 --> 00:14:05.000
先ほど見たのと同じ前景スタイルを使用しているので、私たちの画像は自動的に反転して白で描画するということです。

00:14:05.000 --> 00:14:10.000
パーティクルシステムを構築したいので、この画像をもう数回描きましょう。

00:14:10.000 --> 00:14:13.000
このクロージャは命令コード用であることに注意してください。

00:14:13.000 --> 00:14:14.000
それはViewBuilderではありません。

00:14:14.000 --> 00:14:21.000
だから、私はループにノーマルを使うことができます。

00:14:21.000 --> 00:14:32.000
そして、実際に見ることができるように、各画像を少しシフトしてみましょう。

00:14:32.000 --> 00:14:43.000
今、私たちはこの画像を数回描いていますが、毎回、コンテキストは毎回同じ画像であるにもかかわらず、現在の環境のようなものに基づいてそれを評価するためにそれを解決する必要があります。

00:14:43.000 --> 00:14:52.000
画像を描く前に自分で画像を解決することで、これを改善できます。

00:14:52.000 --> 00:15:00.000
同じ解決済み画像を共有しているため、パフォーマンスが向上しましたが、解決済み画像では他のこともできます。

00:15:00.000 --> 00:15:03.000
私たちは今、そのサイズとベースラインを求めることができます。

00:15:03.000 --> 00:15:17.000
私たちの場合、そのサイズを使用して、それぞれを適切な量にシフトします。

00:15:17.000 --> 00:15:20.000
次に、輝きの後ろに楕円を加えましょう。

00:15:20.000 --> 00:15:22.000
私はそれらを同じ地域に描くつもりです。

00:15:22.000 --> 00:15:29.000
では、フレームを引き抜いて両方を描きましょう。

00:15:29.000 --> 00:15:45.000
同じXとYの値でCGRectを作成し、幅と高さにimageSizeを使用します...

00:15:45.000 --> 00:15:50.000
次に、そのフレームに画像を描きます。

00:15:50.000 --> 00:15:56.000
各描画操作は順番に行われるため、楕円を画像の後ろに置くには、最初に描画する必要があります。

00:15:56.000 --> 00:16:00.000
そして、私たちは文脈でそれを描くことができます。フィル...

00:16:00.000 --> 00:16:02.000
それは道と陰影を取ります。

00:16:02.000 --> 00:16:16.000
標準的なベジェ曲線でパスを構築できますが、ここにヒントがあります。楕円のような図形を使用して、特定の長方形のパスを尋ねることもできます。

00:16:16.000 --> 00:16:19.000
もう1つの議論はシェーディングであり、それは私たちの道を埋めるものです。

00:16:19.000 --> 00:16:23.000
そして、これはSwiftUIアプリの残りの部分と同じスタイルを使用できます。

00:16:23.000 --> 00:16:28.000
シアン色を使いましょう。

00:16:28.000 --> 00:16:30.000
そして、楕円があります。

00:16:30.000 --> 00:16:32.000
しかし、画像とのコントラストはあまりありません。

00:16:32.000 --> 00:16:33.000
それを直しましょう。

00:16:33.000 --> 00:16:40.000
グラフィックコンテキストには、不透明度、ブレンドモード、変換など、多くの標準的な描画プロパティがあります。

00:16:40.000 --> 00:16:42.000
ここに不透明度を設定しましょう。

00:16:42.000 --> 00:16:48.000
そして、このコンテキストがあなたが慣れているかもしれないものとは少し異なる動作をする領域を見ることができます。

00:16:48.000 --> 00:16:52.000
コンテキストに不透明度を設定すると、期待どおりに動作します。

00:16:52.000 --> 00:16:57.000
それはその後に起こるすべての操作に影響します。

00:16:57.000 --> 00:17:07.000
過去には、描画操作の一部にのみ適用されるグラフィックスコンテキストに変更を加えたい場合、保存と復元の呼び出しでそれらの操作を括弧で囲う必要があります。

00:17:07.000 --> 00:17:19.000
しかし、SwiftUIのコンテキストでは、私がしなければならないのはコピーに変更を加えることだけです。

00:17:19.000 --> 00:17:23.000
そして、これらの変更は、変更されたコンテキストで行われた描画にのみ影響します。

00:17:23.000 --> 00:17:28.000
元のコンテキストで行われた描画は影響を受けません。

00:17:28.000 --> 00:17:31.000
私たちのイメージにも色を加えましょう。

00:17:31.000 --> 00:17:41.000
解決された画像でできるもう1つのことは、シンボルの描画方法を制御するためのシェーディングを設定することです。

00:17:41.000 --> 00:17:47.000
ここに青い色を設定しましょう。

00:17:47.000 --> 00:17:50.000
それは私が望んでいたよりも少し明るく見えません。

00:17:50.000 --> 00:17:54.000
時々、あなたが絵を描いているとき、適切なブレンドモードは大きな違いを生むことができます。

00:17:54.000 --> 00:18:02.000
ブレンドモードは、ここにあるように、特に部分的な不透明度で、色がどのように組み合わされるかを制御します。

00:18:02.000 --> 00:18:04.000
スクリーンブレンドモードを設定しましょう。

00:18:04.000 --> 00:18:08.000
それは色を組み合わせて、常に明るくなります。

00:18:08.000 --> 00:18:10.000
その方が良さそうです。

00:18:10.000 --> 00:18:13.000
あなたができる描画操作はもっとたくさんあります。

00:18:13.000 --> 00:18:17.000
GraphicsContextタイプをチェックして、可能なすべてを確認してください。

00:18:17.000 --> 00:18:20.000
さて、これをシミュレーションのようにするには、実際に移動する必要があります。

00:18:20.000 --> 00:18:24.000
SwiftUIには、時間の経過とともに何かを変えるためのツールがいくつかあります。

00:18:24.000 --> 00:18:30.000
アニメーションは最も一般的であり、通常、変更を加えると自動的に発生します。

00:18:30.000 --> 00:18:38.000
今年は、時間の経過とともに何かがどのように変化するかを正確に制御したいときに、TimelineViewと呼ばれる新しい低レベルのツールを導入します。

00:18:38.000 --> 00:18:49.000
変更したいビューを囲むだけで、タイムラインビューを使用できます。

00:18:49.000 --> 00:18:56.000
そして、更新する頻度を示すスケジュールで設定できます。

00:18:56.000 --> 00:19:04.000
タイマーなどのスケジュールがありますが、アニメーションスケジュールを使用して、表示できるだけ迅速に更新を取得します。

00:19:04.000 --> 00:19:07.000
表示リンクに精通している場合、これは非常によく似ています。

00:19:07.000 --> 00:19:09.000
そして、あなたがそうでないなら、それは全く大丈夫です。

00:19:09.000 --> 00:19:16.000
私たちは、私たちが何を示すべきかについての情報を提供するタイムラインコンテキストを渡されます。

00:19:16.000 --> 00:19:26.000
画像をアニメーション化するために使用する時間を数秒で引き出すことができます。

00:19:26.000 --> 00:19:29.000
回転する振動で画像を移動させましょう。

00:19:29.000 --> 00:19:36.000
だから、私は現在の時間から角度を作ります。

00:19:36.000 --> 00:19:42.000
余りを使って3秒ごとにループさせましょう...

00:19:42.000 --> 00:19:47.000
そして、それに120を掛けて360度になります。

00:19:47.000 --> 00:19:50.000
そして、コサインでX値を取得します。

00:19:50.000 --> 00:19:51.000
それとも正弦だったの？

00:19:51.000 --> 00:19:56.000
あなたの三角法を覚えていることを願っています。

00:19:56.000 --> 00:20:01.000
では、その値を使ってオフセットを変更しましょう...

00:20:01.000 --> 00:20:06.000
そして、私たちのプレビューをライブで見て、それがどのように見えるかを見てください。

00:20:06.000 --> 00:20:09.000
いいね。それらが重なると、さらに明るくなるのを見てください。

00:20:09.000 --> 00:20:11.000
それが職場でのスクリーンブレンドモードです。

00:20:11.000 --> 00:20:14.000
次に、いくつかのインタラクティブ性を追加しましょう。

00:20:14.000 --> 00:20:19.000
先ほど、個々のビューにジェスチャーを追加することで実行できるインタラクションのいくつかを調べました。

00:20:19.000 --> 00:20:26.000
キャンバスを使用することのトレードオフの1つは、キャンバス内の個々の要素が1つの図面にまとめられていることを覚えておいてください。

00:20:26.000 --> 00:20:31.000
そのため、たとえば、これらの個々の画像にジェスチャーを添付することはできませんでした。

00:20:31.000 --> 00:20:34.000
ただし、ビュー全体にジェスチャーを追加できます。

00:20:34.000 --> 00:20:38.000
表示される輝きの数を増やす機能を追加しましょう。

00:20:38.000 --> 00:20:45.000
表示する数について、いくつかの状態を追加します。

00:20:45.000 --> 00:20:48.000
そして、2つから始めましょう。

00:20:48.000 --> 00:20:55.000
カウントを使ってループをコントロールしましょう。

00:20:55.000 --> 00:21:02.000
次に、TapGestureを追加してカウントを増やします。

00:21:02.000 --> 00:21:07.000
プレビューを更新しましょう。

00:21:07.000 --> 00:21:13.000
そして今、私たちはタップして輝きを加えることができます。

00:21:13.000 --> 00:21:22.000
キャンバスを使用するもう1つの重要な側面は、単一のグラフィックであるため、アクセシビリティで利用可能なコンテンツに関する情報がないことです。

00:21:22.000 --> 00:21:37.000
これをアクセスしやすくするために、標準のアクセシビリティ修飾子を使用して、ビューに関する情報を追加します。

00:21:37.000 --> 00:21:49.000
また、より高度なケースでは、ビューに関するアクセシビリティ情報を生成するために使用する任意のSwiftUIビュー階層を指定できる強力な新しい.accessibilityChildren修飾子があります。

00:21:49.000 --> 00:21:55.000
使用方法の詳細については、「SwiftUI Accessibility: Beyond the Basics」を参照してください。

00:21:55.000 --> 00:22:02.000
私たちはCanvasの比較的単純な使用を構築しましたが、それははるかに複雑な使用をサポートするように設計されているので、物事を少し盛り上げましょう。

00:22:02.000 --> 00:22:09.000
私の同僚の一人は、私たちがここに持っているものと同じように動作するいくつかのシミュレーションコードを書いてくれましたが、より多くの要素がより興味深いことをしています。

00:22:09.000 --> 00:22:22.000
彼がここに送ってくれたファイルがあるので、私たちのビューに貼り付けます。

00:22:22.000 --> 00:22:26.000
このコードは、私たちが今やっていたのと同じ構造です。

00:22:26.000 --> 00:22:33.000
私たちは今、すべての粒子を追跡するために時間をかけて更新している長寿命のモデルオブジェクトを持っています。

00:22:33.000 --> 00:22:38.000
私たちは、コンテンツをアニメーション化して描画するために同じTimelineViewとCanvasを持っています。

00:22:38.000 --> 00:22:50.000
モデルを新しい日付で更新し、そのスクリーンブレンドモードを設定し、各活性粒子に、先ほどの楕円と同じ方法で描画するように指示しています。

00:22:50.000 --> 00:22:55.000
そして最後に、もう少し複雑なジェスチャーで、同じ修飾子が適用されます。

00:22:55.000 --> 00:23:04.000
だから、それがどのように見えるか見てみましょう。

00:23:04.000 --> 00:23:10.000
定期的に新しい花火バーストを作成し、タップしてバーストを追加することもできます。

00:23:10.000 --> 00:23:16.000
そして、それらはアプリのグラデーションの色と楕円を使用して作られています。

00:23:16.000 --> 00:23:24.000
Canvasで描画するもう1つの素晴らしい点は、watchOS、tvOS、macOSでも機能することです。

00:23:24.000 --> 00:23:27.000
すべてのSwiftUIプラットフォームで利用できます。

00:23:27.000 --> 00:23:29.000
わかった。私たちはアプリを終えました。

00:23:29.000 --> 00:23:46.000
その過程で、安全な領域の操作と変更、フォアグラウンドスタイルを使用してコンテンツの描画方法を制御する方法、素材を使用してぼかしと活気を得る方法、CanvasとTimelineViewを使用して複雑なアニメーショングラフィックを構築しました。

00:23:46.000 --> 00:23:50.000
あなたがアプリでどんな素晴らしいグラフィックを作るかを見るのが待ちきれません。

00:23:50.000 --> 23:59:59.000
[音楽]。

