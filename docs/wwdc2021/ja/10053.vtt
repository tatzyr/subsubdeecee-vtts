WEBVTT

00:00:00.000 --> 00:00:05.000
♪ベース音楽の演奏♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:13.000
オーウェン・モンスマ:こんにちは、「素晴らしいMac Catalystアプリの資質」へようこそ。

00:00:13.000 --> 00:00:16.000
私の名前はオーウェン・モンスマで、ココアのエンジニアです。

00:00:16.000 --> 00:00:20.000
そして、後でUIKitの同僚Dave Rahardjaが参加します。

00:00:20.000 --> 00:00:27.000
今日は、素晴らしいCatalystアプリを作るための3つの重要な考慮事項について説明します。

00:00:27.000 --> 00:00:33.000
まず、Mac Catalystアプリに移行するときに発生するいくつかの高レベルの変更について説明します。

00:00:33.000 --> 00:00:40.000
次に、Macでのアプリ体験を向上させるためにできる特定のコード変更について説明します。

00:00:40.000 --> 00:00:44.000
そして、アプリの配布に関する情報で締めくくります。

00:00:44.000 --> 00:00:49.000
それでは、アプリをMac Catalystに移行することから始めましょう。

00:00:49.000 --> 00:00:58.000
優れたCatalystアプリへの第一歩は、優れたiPadアプリを持つことであり、あなたのアプリはすでにM1を搭載したMacで追加の変更なしで実行されています。

00:00:58.000 --> 00:01:05.000
M1 Macをお持ちの場合は、XcodeのDesigned for iPad実行先ですぐにこれを試すことができます。

00:01:05.000 --> 00:01:11.000
iPadでこれらの機能を採用することで、あなたのMacアプリは有利なスタートを切るでしょう。

00:01:11.000 --> 00:01:19.000
アプリがiPadでマルチタスクをサポートしている場合は、Macで自動的に複数のウィンドウサポートを受けることができます。

00:01:19.000 --> 00:01:29.000
また、UIMenuBuilderを使用している場合、メニューはアプリのメニューバーで自動的にピックアップされ、ビューをセカンダリクリックしたコンテキストメニューによって選択されます。

00:01:29.000 --> 00:01:34.000
また、コピー/ペーストやドラッグアンドドロップなどのシステム動作を自動的にブリッジします。

00:01:34.000 --> 00:01:46.000
iPadアプリがM1 Macでそのまま動作する方法の詳細については、ビデオ「M1を搭載したMacでの素晴らしいiPadとiPhoneアプリの品質」をご覧ください。

00:01:46.000 --> 00:01:49.000
しかし、あなたは物事をさらに進めたいので、ここにいます。

00:01:49.000 --> 00:01:58.000
Macのチェックボックスをオンにすると、すべてのMacに配布し、アプリをさらに絞り込むための追加のAPIにアクセスできます。

00:01:58.000 --> 00:02:02.000
だから、私たちのアプリ、トリッププランナーでやりましょう!

00:02:02.000 --> 00:02:08.000
Xcodeのプロジェクト設定では、Deployment Infoの下にあるMacオプションをチェックします。

00:02:08.000 --> 00:02:16.000
右側には、追加のポップアップが表示され、スケーリングされたiPadインターフェイスとMacに最適化されたインターフェイスのどちらかを選択できます。

00:02:16.000 --> 00:02:19.000
この選択をもう少し検討します。

00:02:19.000 --> 00:02:24.000
とりあえず、ビルドをクリックして、Xcodeツールバーで実行しましょう。

00:02:24.000 --> 00:02:27.000
そして、私たちのアプリはビルドされ、実行されます!

00:02:27.000 --> 00:02:33.000
さて、アプリがビルドに失敗した場合、調査すべきことがいくつかあります。

00:02:33.000 --> 00:02:40.000
特定の非推奨のフレームワークとクラスはMac Catalystでは利用できないので、今が近代化する時です。

00:02:40.000 --> 00:02:46.000
これにより、Macでアプリが実行されるだけでなく、iOSアプリも改善されます。

00:02:46.000 --> 00:02:53.000
OpenGLESからApple独自のMetalフレームワークへの移行は、GPUのフルパワーのロックを解除します。

00:02:53.000 --> 00:03:01.000
連絡先フレームワークは、非推奨のアドレスブックを置き換え、連絡先を処理するための前向きでスレッドセーフな方法です。

00:03:01.000 --> 00:03:06.000
そして、UIWebViewは廃止され、WKWebViewに取って代わられました。

00:03:06.000 --> 00:03:10.000
また、サードパーティの依存関係を必ず確認してください。

00:03:10.000 --> 00:03:19.000
これらのフレームワークがXCFrameworkバンドルとして配布されている場合は、リンクするMacバイナリを提供していることを確認してください。

00:03:19.000 --> 00:03:26.000
Macアプリの作業を開始するときは、プロジェクトを構築するときにコンパイラの警告に注意し、ランタイムメッセージのコンソールログを監視します。

00:03:26.000 --> 00:03:33.000
これらの警告は、Mac Catalystプロセスとしてうまく実行されるようにコードを修正する方法を教えてくれます。

00:03:33.000 --> 00:03:40.000
また、将来のmacOSリリースでアプリが引き続き実行されるように、サポートされているAPIのみを使用することを忘れないでください。

00:03:40.000 --> 00:03:46.000
また、Macで実行しているときにアプリが受け取るライフサイクルイベントを認識することも重要です。

00:03:46.000 --> 00:04:01.000
アプリが現在、アプリデリゲートで呼び出されたライフサイクルイベントに依存している場合は、代わりにシーンのライフサイクルを監視し、アプリがデスクトップ上の各ウィンドウのコンテンツに固有のイベントに応答できるようにする必要があります。

00:04:01.000 --> 00:04:09.000
Mac Catalystアプリは、iPadアプリほど頻繁にシーンDidEnterBackgroundイベントを受信しないことを忘れないでください。

00:04:09.000 --> 00:04:14.000
デスクトップウィンドウが最小化または閉じられると、シーンはバックグラウンド状態になります。

00:04:14.000 --> 00:04:25.000
アプリが sceneDidEnterBackgroundを使用してドキュメントの自動保存などの日常的な作業を実行する場合、代わりにタイマーを使用すると、このアクションが定期的に実行されます。

00:04:25.000 --> 00:04:32.000
最後に、Catalystアプリのシーンはゼロかもしれませんが、フォアグラウンドで実行し続けることを覚えておいてください。

00:04:32.000 --> 00:04:40.000
この状態は、すべてのアプリのウィンドウが閉じられたときに発生しますが、アプリの名前はメニューバーに表示されたままです。

00:04:40.000 --> 00:04:44.000
では、Mac用のインターフェースを最適化するかどうかを決めましょう。

00:04:44.000 --> 00:04:50.000
これは、最初にアプリを導入し始めたときに行う最も重要な決定の1つです。

00:04:50.000 --> 00:04:58.000
Macのイディオムを使用することは、Macでアプリを最もくつろげるようにすることをお勧めしますが、追加の作業が必要です。

00:04:58.000 --> 00:05:08.000
Macのイディオムでは、アプリは100%のスケールで実行され、ピクセルパーフェクトなテキストと画像、およびネイティブのAppKitコントロールを提供します。

00:05:08.000 --> 00:05:16.000
必要に応じて、アセットカタログに新しいMac固有のアセットを追加して、この追加の詳細を活用できます。

00:05:16.000 --> 00:05:23.000
すべてのモニター解像度をサポートするために、1xと2xの両方のアセットを提供するのは良い習慣です。

00:05:23.000 --> 00:05:32.000
多くのコントロールのサイズメトリックが変更されるので、アプリのレイアウトを調整することが重要です。 対応してください。

00:05:32.000 --> 00:05:36.000
アプリのカスタムコントロールには、追加の選択肢があります。

00:05:36.000 --> 00:05:39.000
自動的に、Macスタイルのコントロールが手に入る。

00:05:39.000 --> 00:05:48.000
しかし、この変換からボタンとスライダーをオプトアウトして、Macコントロールでは利用できないカスタマイズAPIを使用できます。

00:05:48.000 --> 00:06:00.000
UISliderに親指を設定するなど、カスタムアセットを使用すると、デフォルトでは予想よりも大きく表示されるため、スケーリングしたり、新しいアセットを提供したりする必要があるかもしれません。

00:06:00.000 --> 00:06:08.000
また、MacユーザーはAppKitスタイルのコントロールを期待しているため、カスタムコントロールは控えめに使用する必要があることを覚えておいてください。

00:06:08.000 --> 00:06:16.000
Macのイディオムの詳細については、ビデオ「Mac Catalystアプリのインターフェースを最適化する」をご覧ください。

00:06:16.000 --> 00:06:25.000
MacイディオムのCatalystアプリはAppKitのコントロールスタイルを取るため、一部のコントロールの外観と動作の両方が変わります。

00:06:25.000 --> 00:06:34.000
私たちのビデオ「Mac Catalystの新機能」では、Macボタンタイプのスイートを締めくくる新しいポップアップボタンスタイルを紹介しました。

00:06:34.000 --> 00:06:40.000
これらのコントロールの違いと、システムがどのコントロールを使用するかをどのように選択するかを掘り下げてみましょう。

00:06:40.000 --> 00:06:48.000
これらのコントロールとそれらが一般的に見つかる場所を理解することは、アプリでの使用について情報に基づいた選択をするのに役立ちます。

00:06:48.000 --> 00:06:53.000
デフォルトのUIButtonタイプはUIButtonタイプ.systemです。

00:06:53.000 --> 00:06:59.000
このボタンタイプでは、ボタンは自動的にそのコンテキストの期待される外観を取ります。

00:06:59.000 --> 00:07:04.000
Macの慣用句では、これは縁取りされたプッシュボタンになることを意味します。

00:07:04.000 --> 00:07:13.000
プルダウンボタンは、可能なアクションのリストを提供するために使用されるMacネイティブコントロールであり、単一の矢印インジケーターで描画されます。

00:07:13.000 --> 00:07:22.000
良い例は、印刷ダイアログのPDFプルダウンで、PDFとして保存やメールで送信などのアクションが表示されます。

00:07:22.000 --> 00:07:34.000
プルダウンボタンを取得するには、メニュープロパティを使用してUIメニューをボタンに割り当てていることを確認し、さらにshowsMenuAsPrimaryActionをtrueに設定します。

00:07:34.000 --> 00:07:39.000
ボタンはプルダウンの外観になり、クリックでメニューが表示されます。

00:07:39.000 --> 00:07:45.000
そして、macOS Montereyを搭載したCatalystの新機能には、ポップアップボタンがあります。

00:07:45.000 --> 00:07:52.000
ポップアップボタンはプルダウンボタンに似ていますが、ダブルアローインジケーターがあり、少し違うことをします。

00:07:52.000 --> 00:08:00.000
プルダウンがアクションをトリガーする場合、ポップアップボタンを使用して、相互に排他的なオプションのセットの1つを選択します。

00:08:00.000 --> 00:08:03.000
たとえば、曜日を選択します。

00:08:03.000 --> 00:08:07.000
ボタンのタイトルは、選択を反映するように更新されます。

00:08:07.000 --> 00:08:13.000
これは、アプリのUIPickerViewを置き換えるのに良い、Macに優しい選択です。

00:08:13.000 --> 00:08:21.000
このコントロールの取得はプルダウンボタンに似ていますが、プロパティの変更SelectionAsPrimaryActionもtrueでなければなりません。

00:08:21.000 --> 00:08:30.000
最後に、チェックボックスは非排他的なバイナリトグルを表すために使用され、スイッチのよりマウスに優しい代替手段です。

00:08:30.000 --> 00:08:35.000
そして、結局のところ、あなたは追加の作業なしでチェックボックスを取得します!

00:08:35.000 --> 00:08:43.000
スイッチにタイトルが設定されていることを確認し、タイトルプロパティはMacのイディオムでのみサポートされていることを覚えておいてください。

00:08:43.000 --> 00:08:56.000
デフォルトでは、スイッチには自動の優先スタイルがあり、読み取り専用スタイルプロパティを使用して、スイッチかチェックボックスかを実行時に確認できます。

00:08:56.000 --> 00:09:02.000
さて、いくつかの特定のコード変更に飛び込むために、私の同僚のデイブに物事を手渡しましょう。

00:09:02.000 --> 00:09:07.000
Dave Rahardja: みなさん、こんにちは。私の名前はDaveで、UIKitチームのエンジニアです。

00:09:07.000 --> 00:09:13.000
Mac Catalystアプリをよりくつろげるためにできる具体的なことについて話しましょう。

00:09:13.000 --> 00:09:18.000
Mac Catalystアプリは、より多くの画面の不動産にアクセスできる可能性があります。

00:09:18.000 --> 00:09:26.000
アプリのウィンドウは、iPadよりもMacではるかに大きくサイズ変更でき、フルスクリーンで表示できます。

00:09:26.000 --> 00:09:31.000
少し時間を取って、アプリのウィンドウのサイズを変更し、そのレイアウトに注意を払ってください。

00:09:31.000 --> 00:09:39.000
アプリをより使いやすくするために、より多くのコンテンツとコントロールを表示するために追加のスペースを使用していることを確認してください。

00:09:39.000 --> 00:09:43.000
ライブサイズ変更は、アプリのレイアウトパフォーマンスをテストします。

00:09:43.000 --> 00:09:51.000
アプリは、サイズ変更中にアプリのウィンドウをレスポンシブに保つために、レイアウト中に可能な限り最小限の作業を行う必要があります。

00:09:51.000 --> 00:09:58.000
モーダルプレゼンテーションやポップオーバーに依存するアプリのインタラクションに特に注意してください。

00:09:58.000 --> 00:10:06.000
表示領域が大きくなると、子ビューとして表示することで、これらのインタラクションを常に利用できるようにすることができます。

00:10:06.000 --> 00:10:09.000
では、ポインタ入力デバイスについて話しましょう。

00:10:09.000 --> 00:10:18.000
すべてのMacがトラックパッドを持っているわけではないし、一部のMacはスクロールをサポートしていない入力デバイスに接続されていることを覚えておいてください。

00:10:18.000 --> 00:10:29.000
ビューがピンチまたは回転ジェスチャーに依存している場合は、スクロール入力なしでマウスを使用してすべての機能にアクセスできることを確認してください。

00:10:29.000 --> 00:10:38.000
Mac Catalystアプリのビューに追加のボタンやその他のコントロールを追加して、すべての機能にアクセスできるようにします。

00:10:38.000 --> 00:10:48.000
さらに、タップまたはパンジェスチャーリコグナイザでキーボード修飾子を検出すると、ビューの機能にすばやくアクセスできる場合があります。

00:10:48.000 --> 00:10:54.000
たとえば、Shift-panをズームできるようにします。

00:10:54.000 --> 00:10:57.000
キーボードショートカットとメインメニューについて話しましょう。

00:10:57.000 --> 00:11:06.000
Macアプリのメインメニューは、アプリで利用可能なすべてのアクションと、関連するキーボードショートカットを見つけるのに最適な場所です。

00:11:06.000 --> 00:11:17.000
アプリがレスポンダーからキーコマンドを返すことでキーボードショートカットをすでにサポートしている場合は、代わりにメニュービルダーAPIを使用してこれらのコマンドをメインメニューに追加してください。

00:11:17.000 --> 00:11:24.000
すべてのキーボードショートカットをメインメニューに移動すると、現在有効になっていなくても検出可能になります。

00:11:24.000 --> 00:11:35.000
さらに、MenuBuilder APIを使用してMac Catalystでショートカットを整理し、iPadのショートカットオーバーレイでも整理します。

00:11:35.000 --> 00:11:42.000
メインメニューを作成する際に、アプリとの対話に必要なすべてのアクションを必ず追加してください。

00:11:42.000 --> 00:11:49.000
iPadのジェスチャーで実行されるアクションは、メインメニューから項目を選択することでアクセスできるはずです。

00:11:49.000 --> 00:11:56.000
メニュー項目にキーボードショートカットを追加すると、これらのアクションにさらにすばやくアクセスできます。

00:11:56.000 --> 00:12:09.000
メニューバーとキーコマンドアクションはファーストレスポンダーからルーティングされるため、これらのアクションのターゲットとなるビューがファーストレスポンダーになり、フォーカスを受け入れることができることを確認してください。

00:12:09.000 --> 00:12:18.000
canBecomeFirstResponder プロパティと canBecomeFocused プロパティに対してビューを true に戻すことで、これを行うことができます。

00:12:18.000 --> 00:12:37.000
Macアプリは、ビューの直接操作に頼らず、ユーザーがビューを選択し、メインメニューからアクションを選択することに依存する必要があるため、より多くのアプリのビューがファーストレスポンダーになり、集中する能力は、Mac Catalystでより重要になります。

00:12:37.000 --> 00:12:45.000
フォーカスとファーストレスポンダーの詳細については、ビデオ「iPadキーボードナビゲーションに焦点を当てる」をご覧ください。

00:12:45.000 --> 00:12:52.000
レスポンダーをテーマにしている間は、アプリでレスポンダーチェーンを変更せずに残してください。

00:12:52.000 --> 00:12:56.000
言い換えれば、nextResponderをオーバーライドしないでください。

00:12:56.000 --> 00:13:04.000
レスポンダチェーンを変更しないままにしておくと、Mac Catalystがアクションを適切なターゲットにルーティングできるようになります。

00:13:04.000 --> 00:13:17.000
アプリがレスポンダーチェーンにないオブジェクトを使用して特定のアクションを処理する場合は、target(for Action:, withSender:)関数を使用して、代わりにこれらのアクションを適切なオブジェクトに委任します。

00:13:17.000 --> 00:13:19.000
コードを調べてみましょう。

00:13:19.000 --> 00:13:31.000
この例では、ビューはsetAsFavoriteアクションをモデルオブジェクトに委任し、他のアクションがレスポンダチェーンを伝播し続けることを可能にします。

00:13:31.000 --> 00:13:36.000
それでは、シーンとそれらがMac Catalystアプリでどのように機能するかについて話しましょう。

00:13:36.000 --> 00:13:41.000
Macアプリでは、多くのデスクトップウィンドウが同時に開いている可能性があります。

00:13:41.000 --> 00:13:48.000
Mac Catalystアプリでは、これらの各ウィンドウがUIWindowSceneとペアになっています。

00:13:48.000 --> 00:13:51.000
あなたのアプリは、異なる機能を持つウィンドウを提供するかもしれません。

00:13:51.000 --> 00:13:59.000
たとえば、ドキュメントウィンドウ、詳細ビューアウィンドウ、メッセージコンポーザーウィンドウなどがある場合があります。

00:13:59.000 --> 00:14:07.000
これらの異なるシーン機能を整理する最善の方法は、ウィンドウの種類ごとにシーン設定を定義することです。

00:14:07.000 --> 00:14:14.000
シーン設定を定義するには、アプリケーションシーンマニフェストエントリの下のInfo.plistに追加します。

00:14:14.000 --> 00:14:22.000
アプリケーションセッションロール配列の下で、アプリがサポートするシーンの種類ごとに1つの設定を作成します。

00:14:22.000 --> 00:14:33.000
これらの設定のそれぞれに名前を付け、シーンの作成時にインスタンス化されるシーンクラス、デリゲートクラス、ストーリーボードを選択します。

00:14:33.000 --> 00:14:42.000
シーン構成を定義したので、それらを使用して特定の構成の新しいシーンを作成する方法について説明します。

00:14:42.000 --> 00:14:49.000
この例では、ビューをダブルクリックしたときに新しい詳細ビューアシーンを作成したいと考えています。

00:14:49.000 --> 00:14:56.000
最初に行うことは、詳細ビューアシーンを要求するための新しいユーザーアクティビティタイプを定義することです。

00:14:56.000 --> 00:14:59.000
私たちはそれをviewDetailActivityTypeと呼びます。

00:14:59.000 --> 00:15:08.000
その新しいユーザーアクティビティを作成するときは、詳細に表示したいアイテムの識別子を渡します。

00:15:08.000 --> 00:15:15.000
これを行うには、その情報をユーザー情報辞書に保持するitemIDKeyを定義します。

00:15:15.000 --> 00:15:30.000
次に、ダブルクリックイベントハンドラで、適切なタイプの新しいNSUserActivityオブジェクトを作成し、そのuserInfoプロパティを表示したいitemIDを保持する辞書に設定します。

00:15:30.000 --> 00:15:40.000
最後に、UIApplication requestSceneSessionActivation関数を呼び、作成したばかりのユーザーアクティビティを渡します。

00:15:40.000 --> 00:15:44.000
これにより、システムは新しいシーンを作成します。

00:15:44.000 --> 00:15:49.000
これで、特定のユーザーアクティビティタイプの新しいシーンをリクエストする方法がわかります。

00:15:49.000 --> 00:15:56.000
では、その情報を使用して適切なシーン設定をロードする方法について話しましょう。

00:15:56.000 --> 00:16:05.000
アプリケーションデリゲートにアプリケーションconfigurationForConnecting機能を実装することで、シーン作成要求に対応します。

00:16:05.000 --> 00:16:12.000
実装では、着信シーンリクエストにユーザーアクティビティが含まれているかどうかを調べます。

00:16:12.000 --> 00:16:20.000
リクエストには複数のユーザーアクティビティを含めることができますが、このコード例では、最初のものを調べます。

00:16:20.000 --> 00:16:26.000
処理する必要があるアクティビティがある場合は、そのactivityTypeをチェックします。

00:16:26.000 --> 00:16:31.000
ここでは、viewDetailActivityTypeに等しいかどうかをテストします。

00:16:31.000 --> 00:16:36.000
もしそうなら、DetailViewerという名前のシーン設定を返します。

00:16:36.000 --> 00:16:51.000
これにより、システムはInfo.plistでその名前の設定を確認し、適切なシーンとシーンのデリゲートクラスをロードし、指定されたストーリーボードを新しいデスクトップウィンドウに表示します。

00:16:51.000 --> 00:16:59.000
特定のシーン設定をロードする必要がある場合は、デフォルトの設定を返すことにフォールバックします。

00:16:59.000 --> 00:17:01.000
やるべきことがもう1つあります。

00:17:01.000 --> 00:17:05.000
表示するアイテムのアイテムIDを保存したことを覚えていますか？

00:17:05.000 --> 00:17:11.000
作成したばかりのシーンのビューコントローラーにその値を設定する必要があります。

00:17:11.000 --> 00:17:15.000
私たちはSceneDelegateクラスでそれを行います。

00:17:15.000 --> 00:17:23.000
シーンwillConnectToセッション機能は、シーンがデスクトップに表示されようとしている直前に呼び出されます。

00:17:23.000 --> 00:17:30.000
アプリケーションデリゲートに渡されたユーザーアクティビティは、シーンデリゲートのこの機能にも渡されます。

00:17:30.000 --> 00:17:38.000
userInfo辞書からitemIDを抽出し、新しいビューコントローラーに設定できるようになりました。

00:17:38.000 --> 00:17:46.000
NSUserActivityを使用して新しいシーンを設定すると、アプリが状態の復元を簡単にサポートできます。

00:17:46.000 --> 00:17:57.000
シーンデリゲートがstateRestorationActivity（Scene：）コールバックに応答すると、返されたユーザーアクティビティは、アプリが終了したときにシステムによって保存されます。

00:17:57.000 --> 00:18:14.000
システム環境設定で状態復元が有効になっている場合、次回アプリが起動されると、システムはシーンを再作成し、各シーンのユーザーアクティビティオブジェクトをアプリデリゲートのアプリケーションconfigurationForConnecting SceneSession機能に渡します。

00:18:14.000 --> 00:18:20.000
これは、先に説明したように、アプリが新しいシーンを作成するときに呼び出されるのと同じ関数です。

00:18:20.000 --> 00:18:35.000
一貫した一連のアクティビティタイプを使用することで、同じコードを使用して、アプリが新しいデスクトップウィンドウを作成し、状態の復元中に適切なシーン設定を選択できます。

00:18:35.000 --> 00:18:56.000
アプリが同じコードで新しいシーンリクエストと状態復元の両方を処理できるように、シーンデリゲートに追加する必要があることが1つあります。それは、シーン接続オプションのアクティビティがnilの場合、シーンデリゲートのシーンwillConnectセッション機能を変更して、stateRestorationActivityにフォールバックするようにすることです。

00:18:56.000 --> 00:19:02.000
これで、アプリは新しいシーンリクエストと状態復元を処理する準備が整いました。

00:19:02.000 --> 00:19:09.000
状態の復元の詳細については、「iPadで複数のWindowsを紹介する」ビデオをご覧ください。

00:19:09.000 --> 00:19:13.000
次に、アプリのツールバーについて話しましょう。

00:19:13.000 --> 00:19:21.000
優れたMacアプリは、Windowsのツールバーを使用して、頻繁に使用されるアクションやその他のナビゲーションオプションを表示して、すばやくアクセスできます。

00:19:21.000 --> 00:19:34.000
iOSのツールバーとは異なり、Mac Catalystアプリのデスクトップウィンドウのツールバーは、ビューコントローラーがSplit Viewコントローラーまたはナビゲーションコントローラーに表示されたり消えたりしても変更されません。

00:19:34.000 --> 00:19:43.000
ツールバーはシーンと強く関連しているため、ツールバーを設定するのに最適な場所はシーンデリゲートサブクラスです。

00:19:43.000 --> 00:19:49.000
通常、ツールバーにある重要な項目の1つは、共有ボタンです。

00:19:49.000 --> 00:20:01.000
ツールバーにNSSharingServicePicker ToolbarItemを追加すると、アプリはMacの標準共有メニューを使用してシーンに表示されるメインコンテンツを共有できます。

00:20:01.000 --> 00:20:11.000
macOS Montereyでは、シーンで共有されているアクティビティアイテムの設定を自動的に使用するボタンの機能を追加しました。

00:20:11.000 --> 00:20:19.000
これは、Siriの新しいShare This機能がiOSで使用しているのと同じ設定であることに注意してください。

00:20:19.000 --> 00:20:29.000
シーンの共有設定を提供する良い方法は、RootViewControllerのactivityItemsConfigurationプロパティからオブジェクトを返すことです。

00:20:29.000 --> 00:20:37.000
Mac Catalystでは、アプリのツールバーにあるNSSharingServicePicker ToolbarItemが自動的にこのプロパティを使用します。

00:20:37.000 --> 00:20:43.000
iOSでは、Siriは同じプロパティを使用して「Share This」を使用してデータを共有します。

00:20:43.000 --> 00:20:48.000
もちろん、ツールバーは、アプリが共有するアイテムを提供できる唯一の場所ではありません。

00:20:48.000 --> 00:20:55.000
多くの場合、コンテキストメニューから画像やその他のアイテムの共有を許可したいと思うでしょう。

00:20:55.000 --> 00:21:04.000
これを行うには、ビューからactivitiesItemsConfigurationオブジェクトを返し、contextMenuInteractionを追加します。

00:21:04.000 --> 00:21:09.000
これがMac CatalystとiPadの両方での結果です。

00:21:09.000 --> 00:21:16.000
Mac Catalystでは、コピーアクションと共有メニューが自動的に追加されることに注意してください。

00:21:16.000 --> 00:21:21.000
また、アプリがiPadで実行されると、コピーと共有アクションが追加されます。

00:21:21.000 --> 00:21:25.000
共有アクションをタップすると、自動的に共有シートが表示されます。

00:21:25.000 --> 00:21:36.000
アクティビティアイテム構成APIを使用すると、アプリはビューを共有できるものを宣言できるため、システムは各プラットフォームで適切なUIを表示できます。

00:21:36.000 --> 00:21:47.000
アプリがデータを共有する方法について話しましたので、アプリがContinuity Cameraを使用してiPhoneやiPadから画像をインポートする方法について話しましょう。

00:21:47.000 --> 00:21:56.000
アプリがUITextViewを使用してリッチテキストを表示する場合、macOS MontereyでContinuity Cameraのサポートが自動的に有効になります。

00:21:56.000 --> 00:22:07.000
テキストビューを右クリックすると、iPhoneまたはiPadで写真を撮り、添付ファイルとして自動的に追加するオプションを備えたコンテキストメニューが表示されます。

00:22:07.000 --> 00:22:24.000
任意のビューにContinuity Cameraのサポートを追加するには、ビューのpasteConfigurationプロパティから画像を受け入れるUIPasteConfigurationオブジェクトを返し、UI contextMenuInteractionを追加するだけです。

00:22:24.000 --> 00:22:33.000
次に、貼り付け(itemProviders:) 関数を実装して、着信オブジェクトをロードして貼り付けます。この場合は画像です。

00:22:33.000 --> 00:22:53.000
ボーナスとして、ビューから貼り付け設定を返すと、設定が画像を受け入れるときにContinuity Cameraが有効になるだけでなく、コンテキストメニューの貼り付けアクションを自動的に有効にし、Mac CatalystとiPadの両方でビューが着信ドラッグを受け入れることができます。

00:22:53.000 --> 00:23:00.000
だから、これらはあなたのアプリを素晴らしいMac Catalystアプリにするためにあなたができるいくつかの具体的なことです。

00:23:00.000 --> 00:23:04.000
さて、オーウェンに戻って配布について話しましょう。

00:23:04.000 --> 00:23:06.000
オーウェン:ありがとう、デイブ。

00:23:06.000 --> 00:23:17.000
アプリのリリースに関しては、覚えておくべき重要なことは、Mac CatalystアプリはMacアプリであり、他のMacアプリと同じ手段で配布できるということです。

00:23:17.000 --> 00:23:28.000
既存のiOSの顧客が自動的にMacアプリを入手できるように、ユニバーサル購入のオプションを使用して、Mac App Storeにアプリを公開することができます。

00:23:28.000 --> 00:23:34.000
アプリのベータリリースのためにTestFlightにアクセスし、新しいビルドに関する早期のフィードバックを得ることができます。

00:23:34.000 --> 00:23:39.000
アプリ公証を使用して、自分で配布することもできます。

00:23:39.000 --> 00:23:47.000
また、フレームワークを開発する場合は、XCFrameworksを使用してクロスプラットフォームを配布し、すべてのプラットフォームのバイナリをバンドルします。

00:23:47.000 --> 00:23:57.000
今日は、Mac Catalystを使用してMac用のiOSアプリを構築するプロセスを取り上げ、その過程で行うべきいくつかの重要な決定と変更を強調しました。

00:23:57.000 --> 00:24:00.000
今、あなた自身のプロジェクトを検討する時が来ました。

00:24:00.000 --> 00:24:12.000
Macでアプリを実行するのは簡単で、ほんの少しの作業で、アプリを自宅にいるように感じさせ、まったく新しい興奮した顧客が利用できるようにすることができます。

00:24:12.000 --> 00:24:13.000
ありがとう！

00:24:13.000 --> 23:59:59.000
♪

