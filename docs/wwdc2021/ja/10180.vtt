WEBVTT

00:00:00.000 --> 00:00:14.000
こんにちは、私の名前はタヌジャで、OSパフォーマンスチームのエンジニアです。

00:00:14.000 --> 00:00:21.000
今日、ステファンと私は、アプリケーションのメモリの問題を検出して診断する方法について話します。

00:00:21.000 --> 00:00:27.000
まず、アプリケーションのメモリフットプリントの影響を調べます。

00:00:27.000 --> 00:00:34.000
次に、メモリ使用量をプロファイリングするためのツールと、遭遇する可能性のあるメモリの問題の種類について説明します。

00:00:34.000 --> 00:00:38.000
すぐに飛び込みましょう。

00:00:38.000 --> 00:00:44.000
あなたがすぐに尋ねるかもしれない1つの質問は、なぜ私のアプリケーションのメモリフットプリントを気にする必要があるのですか?

00:00:44.000 --> 00:00:49.000
主な理由は、アプリのユーザーエクスペリエンスを大幅に向上させるためです。

00:00:49.000 --> 00:01:00.000
システムには限られた量のメモリがあり、アプリのメモリ使用量を監視することで、システムがアプリを終了してそのメモリを取り戻すのを防ぐことができます。

00:01:00.000 --> 00:01:16.000
これは、アプリがバックグラウンドでその状態を維持できることを意味します。これは素晴らしいことです。メモリへの読み込みには時間がかかり、メモリフットプリントをコンパクトに保つと、アプリケーションがメモリに残る可能性が高まり、アプリのアクティベーションが速くなるからです。

00:01:16.000 --> 00:01:26.000
メモリ使用量を減らすと、ダイナミックでレスポンシブなエクスペリエンスも得られます。これは、ユーザーが新機能を探索する際にまさに望むものです。

00:01:26.000 --> 00:01:36.000
アプリがメモリにロードされたものについて戦略的にすることで、アプリはユーザーがアプリと対話するときにメモリを取り戻すのを待つコストを回避できます。

00:01:36.000 --> 00:01:48.000
メモリ使用量について戦略的であることは、アニメーションを含むビデオの読み込みなど、アプリに追加できる幅広い機能への扉を開きます。

00:01:48.000 --> 00:01:56.000
最後に、私たちのデバイスは時間の経過とともに絶えず進化しており、新しいデバイスは以前よりも多くの物理メモリを持っています。

00:01:56.000 --> 00:02:05.000
メモリフットプリントを削減することで、アプリは古いデバイスでも同じようにパフォーマンスを発揮し、アプリを楽しめるオーディエンスを増やします。

00:02:05.000 --> 00:02:15.000
アプリのメモリフットプリントを監視することで、アプリはより速くアクティブ化し、より応答性が高く、複雑な機能を処理し、より幅広いデバイスでパフォーマンスを発揮します。

00:02:15.000 --> 00:02:20.000
それでは、あなたの記憶の足跡を構成するものを見てみましょう。

00:02:20.000 --> 00:02:27.000
アプリケーションのメモリプロファイルを分解するために使用する3つのカテゴリがあります。ダーティ、圧縮、クリーンメモリです。

00:02:27.000 --> 00:02:31.000
これらのそれぞれに何が含まれているかを簡単に見てみましょう。

00:02:31.000 --> 00:02:35.000
ダーティメモリは、アプリケーションによって書かれたメモリで構成されています。

00:02:35.000 --> 00:02:44.000
また、malloc、デコードされたイメージバッファ、フレームワークを使用する場合など、すべてのヒープ割り当ても含まれます。

00:02:44.000 --> 00:02:52.000
圧縮メモリとは、メモリコンプレッサーが圧縮した、最近アクセスされていないダーティページを指します。

00:02:52.000 --> 00:02:56.000
これらのページはアクセス時に解凍されます。

00:02:56.000 --> 00:03:03.000
macOSに固有のiOSでのスワップの概念がないことに注意してください。

00:03:03.000 --> 00:03:05.000
そして最後に、私たちはきれいな記憶を持っています。

00:03:05.000 --> 00:03:10.000
クリーンメモリとは、書き込まれていないメモリ、またはページアウトできるデータです。

00:03:10.000 --> 00:03:16.000
たとえば、これらは、ディスク上にあるがメモリにロードされたイメージなどのメモリマップされたファイルです。

00:03:16.000 --> 00:03:20.000
または、それらはフレームワークになることができます。

00:03:20.000 --> 00:03:27.000
アプリケーションのメモリフットプリントを参照するとき、私たちは本当にあなたのアプリの汚れたメモリと圧縮されたメモリを一緒に話しています。

00:03:27.000 --> 00:03:31.000
クリーンメモリはここではカウントされません。

00:03:31.000 --> 00:03:34.000
これはあなたのメモリフットプリントの高度な理解です。

00:03:34.000 --> 00:03:43.000
より詳細で詳細な説明については、WWDC 2018のiOSメモリディープダイブトークをチェックすることをお勧めします。

00:03:43.000 --> 00:03:49.000
それでは、メモリフットプリントをプロファイリングするために使用できるツールを見てみましょう。

00:03:49.000 --> 00:03:58.000
Xcodeは、開発と本番の両方のワークフローを通じて、アプリのメモリパフォーマンスを監視するのに役立つ一連のツールを提供しています。

00:03:58.000 --> 00:04:12.000
XCTestフレームワークは、プロジェクトのユニットテストとUIテストでメモリフットプリントを直接監視するのに役立ちますが、MetricKitとXcodeオーガナイザーを使用すると、顧客から本番環境のメモリメトリクスを監視できます。

00:04:12.000 --> 00:04:16.000
この講演の続きは、パフォーマンスXCTestsを使用する文脈で行われます。

00:04:16.000 --> 00:04:23.000
しかし、これらの技術は依然として一般的なメモリトリアージと調査に適用されることに注意してください。

00:04:23.000 --> 00:04:32.000
パフォーマンスXCTestsを使用すると、メモリ使用率、CPU使用率、ディスク書き込みなどのシステムリソースを測定できます。

00:04:32.000 --> 00:04:37.000
一緒にテストの例を見てみましょう。 一緒に見てみましょう。

00:04:37.000 --> 00:04:52.000
私が1週間で食べるものを整理するのに役立つアプリであるMeal Plannerのアプリ開発者であるとしましょう。ユーザーが自分のデバイスにレシピをダウンロードできるように追加したこの新しい食事保存機能のメモリ使用量を測定したいと思います。

00:04:52.000 --> 00:05:03.000
パフォーマンステストでは、measures(metrics:options:block:) APIを使用しており、ターゲットアプリケーションのメモリ使用量を測定することを指定しています。

00:05:03.000 --> 00:05:14.000
測定ブロックの本文で、アプリケーションを起動し、手動で測定APIに測定を開始するように指示し、[食事の保存]ボタンをタップします。

00:05:14.000 --> 00:05:22.000
UIでアップデートをチェックして、レシピのダウンロードが完了するまで最大30秒待ちます。

00:05:22.000 --> 00:05:28.000
これで、XcodeのUIで直接このテストを実行して、測定値を表示できます。

00:05:28.000 --> 00:05:32.000
テストの横にある灰色のダイヤモンドをクリックすると、測定値にアクセスできます。

00:05:32.000 --> 00:05:39.000
結果のポップオーバーUIには、どのメトリクスが測定されたかを示すドロップダウンがあります。

00:05:39.000 --> 00:05:45.000
下部の棒グラフは、個々の反復の測定値を示しています。

00:05:45.000 --> 00:05:50.000
5つの反復すべての平均が計算され、表示されます。

00:05:50.000 --> 00:05:59.000
将来のテストと比較するためのベースラインとして、この実行の平均を設定するかどうかを決定できます。

00:05:59.000 --> 00:06:04.000
平均が設定されたベースラインよりも大きい場合、テストの将来の実行は失敗します。

00:06:04.000 --> 00:06:09.000
私たちは、設定されたベースラインからのこの偏差を回帰と呼びます。

00:06:09.000 --> 00:06:18.000
回帰は、テストが合格することを確認するために、コードを停止、調査、修正する必要があることを示します。

00:06:18.000 --> 00:06:26.000
Xcode 13では、これらのテスト回帰のトリアージに役立つ診断を収集する新機能を追加しました。

00:06:26.000 --> 00:06:34.000
価値があると思う診断は2つあります。ktraceファイルとメモリグラフです。

00:06:34.000 --> 00:06:37.000
Ktraceファイルは強力で汎用性があります。

00:06:37.000 --> 00:06:52.000
一般的なシステム調査に使用したり、ヒッチを調査する際にレンダリングパイプラインに飛び込んだり、メインスレッドがブロックされ、ハングする理由を調べるなど、特定の問題に焦点を当てることができます。

00:06:52.000 --> 00:06:59.000
これらのktraceファイルは、通常のワークフローを使用してInstrumentsで開いて分析できます。

00:06:59.000 --> 00:07:04.000
2番目の診断は、メモリ固有の調査に最適なメモリグラフです。

00:07:04.000 --> 00:07:15.000
メモリグラフは、Xcodeのビジュアルデバッガやさまざまなコマンドラインツールで使用できます。そのうちのいくつかは、この講演の後半で説明します。

00:07:15.000 --> 00:07:21.000
メモリグラフは、基本的にインスタンス内のプロセスのアドレス空間のスナップショットです。

00:07:21.000 --> 00:07:32.000
Memgraphは、各仮想メモリ領域と割り当てられた各mallocブロックのアドレスとサイズ、およびそれらの領域とブロック間のポインタを記録します。

00:07:32.000 --> 00:07:40.000
これにより、ヒープ上の個々のオブジェクトを検査したり、リンクされたフレームワークに関連付けられたデータ領域を表示したりできます。

00:07:40.000 --> 00:07:49.000
XCTestは、新しく割り当てられたオブジェクトのバックトレースをキャプチャするmallocスタックロギングを自動的に有効にします。

00:07:49.000 --> 00:07:58.000
診断コレクションを有効にするには、enablePerformanceTestsDiagnosticsフラグと組み合わせてxcodebuildコマンドラインツールを使用します。

00:07:58.000 --> 00:08:06.000
このフラグは、非メモリメトリクスのktraceコレクションとメモリメトリクスのmemgraphを有効にします。

00:08:06.000 --> 00:08:12.000
以前に書かれたパフォーマンステストの実行が完了すると、以下がコンソールに印刷されます。

00:08:12.000 --> 00:08:17.000
これはかなり多いですが、探すべき重要なことがいくつかあります。

00:08:17.000 --> 00:08:21.000
最初に探すべきことは、テストに失敗したか合格したかどうかです。

00:08:21.000 --> 00:08:25.000
この場合、テストは失敗しました。

00:08:25.000 --> 00:08:30.000
出力はまた、回帰のためにテストが特に失敗したことを呼び出します。

00:08:30.000 --> 00:08:35.000
私たちの新しい平均はベースラインよりも12%悪いです。

00:08:35.000 --> 00:08:40.000
最後に、xcresultバンドルへのパスを見つけることができます。

00:08:40.000 --> 00:08:49.000
Xcodeでxcresultバンドルを開くと、テスト名の横に上部にメモリ測定値が表示されます。

00:08:49.000 --> 00:08:57.000
その後、テストログを展開し、下部に向かって、添付のメムグラフを見つけることができます。

00:08:57.000 --> 00:09:00.000
ダウンロードして解凍すると、2つのmemgraphが見つかります。

00:09:00.000 --> 00:09:07.000
これは、mallocスタックロギングを有効にするために、テストに追加の反復を追加するためです。

00:09:07.000 --> 00:09:17.000
測定された反復の開始時にプレの接頭辞が付いた最初のメムグラフを収集し、反復の最後にポストの接頭辞が付いた2番目のメムグラフを収集します。

00:09:17.000 --> 00:09:25.000
これにより、必要に応じて、1回の反復期間中のメモリの成長を分析できます。

00:09:25.000 --> 00:09:35.000
Mallocスタックロギングが有効になっているktraceファイルとメモリグラフを使用すると、回帰が発生したかどうかだけでなく、なぜ回帰が発生したのかを答える準備が整いました。

00:09:35.000 --> 00:09:45.000
同僚のステファンに渡して、収集したメモリグラフ診断を調べるときに遭遇する可能性のあるメモリの問題の種類について話します。

00:09:45.000 --> 00:09:48.000
ありがとう、タヌジャ。みなさん、こんにちは。

00:09:48.000 --> 00:09:50.000
私はOSパフォーマンスチームのエンジニア、ステファンです。

00:09:50.000 --> 00:10:00.000
アプリで見つかる可能性のある一般的なメモリの問題と、それらを診断、修正、防止する方法について説明します。

00:10:00.000 --> 00:10:09.000
リークとヒープの問題の2種類のメモリの問題について説明します。これは、ヒープ割り当て回帰とフラグメンテーションの問題に分類できます。

00:10:09.000 --> 00:10:14.000
これは網羅的なリストではありませんが、最も一般的な問題のいくつかをカバーしています。

00:10:14.000 --> 00:10:19.000
また、これらの問題を診断するために使用できるコマンドラインワークフローについても説明します。

00:10:19.000 --> 00:10:27.000
コマンドラインツールのより詳細な要約については、WWDC 2018のiOSメモリディープダイブトークをご覧ください。

00:10:27.000 --> 00:10:31.000
メモリリークについて議論することから始めましょう。

00:10:31.000 --> 00:10:38.000
リークは、プロセスがオブジェクトを割り当て、割り当てを解除せずにオブジェクトへのすべての参照を失うときに発生します。

00:10:38.000 --> 00:10:43.000
ここにオブジェクトグラフの例があり、灰色の矢印はオブジェクト間の参照を示します。

00:10:43.000 --> 00:10:47.000
すべてのオブジェクトには、少なくとも1つの参照があることに注意してください。

00:10:47.000 --> 00:10:51.000
オブジェクトAからオブジェクトBへの点線参照に注目してください。

00:10:51.000 --> 00:10:55.000
この参照をnilに設定して削除したとしましょう。

00:10:55.000 --> 00:10:58.000
その参照がなくなったので、オブジェクトBは漏洩しました。

00:10:58.000 --> 00:11:00.000
それへの言及は全くありません。

00:11:00.000 --> 00:11:06.000
それはまだ汚れていますが、プロセスにはそれを参照する方法がなく、それが終わるまでそれを解放する方法はありません。

00:11:06.000 --> 00:11:11.000
このため、常にリークを修正する必要があります。

00:11:11.000 --> 00:11:14.000
Swiftでオブジェクトが漏れる一般的な方法は、リテンションサイクルです。

00:11:14.000 --> 00:11:18.000
この図では、オブジェクトAとBは保持サイクルにあります。

00:11:18.000 --> 00:11:23.000
彼らは互いに参照しますが、どちらにも外部参照はありません。

00:11:23.000 --> 00:11:29.000
これは、プロセスがそれらのいずれかにアクセスまたは解放できないことを意味するため、漏洩したと見なされます。

00:11:29.000 --> 00:11:37.000
幸いなことに、Swiftのほとんどのオブジェクトは、多くのリークを防ぐSwiftの自動参照カウントシステム（ARC）によって管理されています。

00:11:37.000 --> 00:11:46.000
安全でないポインタなど、ARCによって管理されていないオブジェクトで作業している場合は、それらへの参照を失う前に、それらの割り当てを解除してください。

00:11:46.000 --> 00:11:51.000
ARCが管理するオブジェクトでさえ、保持サイクルの一部になりやすい。

00:11:51.000 --> 00:11:54.000
したがって、コードに強力な循環参照を作成することは避けてください。

00:11:54.000 --> 00:12:04.000
循環参照が絶対に必要な場合は、弱い参照はオブジェクトの割り当て解除を妨げないため、代わりに弱い参照を検討してください。

00:12:04.000 --> 00:12:07.000
ミールプランナーアプリの例を見てみましょう。

00:12:07.000 --> 00:12:12.000
Tanujaは、失敗したXCTestからいくつかのプレとポストのメモリグラフを送ってくれました。

00:12:12.000 --> 00:12:17.000
すぐに、ポストメムグラフのリークを確認したいです。

00:12:17.000 --> 00:12:20.000
これを行うには、memgraphでリークを実行します。

00:12:20.000 --> 00:12:26.000
これは、私が持っているリークに関するいくつかの有用な情報を示しています。

00:12:26.000 --> 00:12:32.000
出力は、合計240のリークバイトで4つのリークがあることを示しています。

00:12:32.000 --> 00:12:41.000
さらに下には、出力には各リークのオブジェクトグラフの詳細なビューが含まれており、何がリークしている可能性があるかについていくつかの手がかりが得られます。

00:12:41.000 --> 00:12:47.000
オブジェクトグラフの上部にはROOT CYCLEと書かれていますが、これは保持サイクルを扱っていることを意味します。

00:12:47.000 --> 00:12:49.000
ここには便利なシンボルがいくつかあります。

00:12:49.000 --> 00:12:56.000
この保持サイクルには、おそらく食事プランとメニュー項目のオブジェクトが含まれているようです。

00:12:56.000 --> 00:13:02.000
XCTestsではmallocスタックロギングが有効になっているため、出力にはリークごとに割り当てコールスタックも含まれています。

00:13:02.000 --> 00:13:07.000
これは、どのオブジェクトが漏洩したかを見つけるのに非常に便利です。

00:13:07.000 --> 00:13:12.000
多くの場合、コードのシンボルを含むコールスタックのセクションを見つけたいと思うでしょう。

00:13:12.000 --> 00:13:16.000
これが私のコードからのコールスタックの部分です。

00:13:16.000 --> 00:13:21.000
漏洩した食事プランオブジェクトは、populateMealData関数に割り当てられます。

00:13:21.000 --> 00:13:25.000
Xcodeを開いて、問題を解決できるかどうかを確認します。

00:13:25.000 --> 00:13:28.000
これは私がリークで見たpopulateMealData関数です。

00:13:28.000 --> 00:13:35.000
ここでは、私の保持サイクルで見た2つのオブジェクトである食事プランオブジェクトとメニュー項目オブジェクトを割り当てています。

00:13:35.000 --> 00:13:39.000
うーん、このaddMealToMealPlan関数は少し怪しげに見えます。

00:13:39.000 --> 00:13:41.000
見てみます。

00:13:41.000 --> 00:13:48.000
うーん、食事プランでaddItemを呼んでいるように見えますが、メニュー項目でaddPlanも呼んでいます。

00:13:48.000 --> 00:13:56.000
これは、プランのすべてのアイテムだけでなく、アイテムがどのプランに関連付けられているかを見ることができる機能用です。

00:13:56.000 --> 00:14:01.000
ここ食事プランでは、addItemはメニュー項目を配列に追加し、それへの参照を保存します。

00:14:01.000 --> 00:14:06.000
そして、このメニュー項目で、addPlanは食事プランへの参照を保存します。

00:14:06.000 --> 00:14:11.000
だから、彼らは両方ともお互いに強い参照を持っているので、これは間違いなく保持サイクルです。

00:14:11.000 --> 00:14:20.000
populateMealDataが終了すると、食事プランとメニュー項目オブジェクトの両方が範囲外になるため、外部参照はありません。

00:14:20.000 --> 00:14:24.000
しかし、彼らはまだお互いを参照し、リークを引き起こします。

00:14:24.000 --> 00:14:28.000
私はおそらく、周期的な参照なしで解決策を見つけようとするべきです。

00:14:28.000 --> 00:14:34.000
しかし、今のところ簡単な修正として、メニュー項目を変更して、食事プランオブジェクトに弱い参照を使用します。

00:14:34.000 --> 00:14:43.000
これは、もはや2つの周期的な強い参照を持たないため、保持サイクルを中断します。

00:14:43.000 --> 00:14:47.000
では、ヒープ割り当て回帰にギアをシフトしましょう。

00:14:47.000 --> 00:14:53.000
ヒープは、動的に割り当てられたオブジェクトが格納されるプロセスのアドレス空間のセクションにすぎません。

00:14:53.000 --> 00:15:00.000
ヒープ割り当て回帰は、以前よりも多くのオブジェクトをヒープに割り当てるプロセスによるメモリフットプリントの増加です。

00:15:00.000 --> 00:15:07.000
ヒープ回帰を減らすために、未使用の割り当てを削除し、不必要に大きな割り当てを縮小してください。

00:15:07.000 --> 00:15:11.000
また、一度にどれだけの記憶を持っているかに注意を払う必要があります。

00:15:11.000 --> 00:15:15.000
使用しなくなったメモリを割り当て解除し、必要になるまでメモリを割り当てるのを待ちます。

00:15:15.000 --> 00:15:21.000
これにより、アプリのピークフットプリントが削減され、終了する可能性が低くなります。

00:15:21.000 --> 00:15:27.000
それでは、MealPlannerアプリから失敗したXCTestに戻り、ヒープ回帰を確認しましょう。

00:15:27.000 --> 00:15:37.000
どこを見るべきかを理解するために、プレメモリグラフとポストメモリグラフの両方でvmmap-summaryを実行して、メモリが使用されている場所の概要を把握します。

00:15:37.000 --> 00:15:42.000
プレメモリグラフの私のフットプリントは約112メガバイトです。

00:15:42.000 --> 00:15:50.000
そして、ポストメモリグラフでは、私のフットプリントは125メガバイトなので、それは約13メガバイトの差です。

00:15:50.000 --> 00:15:56.000
さらに下では、出力は地域ごとに分類された私のプロセスのメモリ使用量を示しています。

00:15:56.000 --> 00:16:05.000
これはヒープ割り当ての問題ではないかと思うので、これらの領域にはすべてのヒープオブジェクトが含まれているため、MALLOC_で始まる領域を見てみたいと思います。

00:16:05.000 --> 00:16:11.000
タヌジャの方程式を覚えておいてください:メモリフットプリント=ダーティメモリ+圧縮メモリ。

00:16:11.000 --> 00:16:14.000
このツールでは、「スワップ」という用語は「圧縮」を意味します。

00:16:14.000 --> 00:16:19.000
だから、これらのコラムの中で、私は「汚いサイズ」と「スワップサイズ」だけを気にしています。

00:16:19.000 --> 00:16:25.000
そして確かに、出力はMALLOC_LARGE領域が約13メガバイトのダーティメモリを保持していることを示しています。

00:16:25.000 --> 00:16:29.000
それは私の回帰サイズとほぼ同等なので、間違いなくそれを調べたいです。

00:16:29.000 --> 00:16:35.000
次のステップは、この13メガバイトの回帰にどのような種類のオブジェクトが寄与しているかを把握することです。

00:16:35.000 --> 00:16:41.000
その情報を取得するには、投稿のmemgraphでheap -diffFromを実行します。

00:16:41.000 --> 00:16:44.000
私はプレとポストのメムグラフを引数として渡します。

00:16:44.000 --> 00:16:50.000
これは、ポストメムグラフヒープに存在するが、プレメムグラフヒープには存在しないオブジェクトを示しています。

00:16:50.000 --> 00:16:57.000
上部付近では、出力は、ポストmemgraphに約13メガバイトの新しいオブジェクトがあることを示しています。

00:16:57.000 --> 00:17:01.000
以下では、ヒープメモリはオブジェクトクラス別に分解されています。

00:17:01.000 --> 00:17:08.000
各オブジェクトクラスについて、出力はオブジェクトの数とそれらのオブジェクトのバイト単位の合計を示します。

00:17:08.000 --> 00:17:13.000
すぐに、私はこの「非オブジェクト」タイプの約13メガバイト分を持っていることに気づきました。

00:17:13.000 --> 00:17:16.000
Swiftでは、これは通常、生のmallocedバイトを示します。

00:17:16.000 --> 00:17:23.000
このタイプのオブジェクトは追跡するのが少し難しいかもしれませんが、情報を取得するために使用できるツールがいくつかあります。

00:17:23.000 --> 00:17:27.000
まず、これらの非オブジェクトのアドレスが欲しいです。

00:17:27.000 --> 00:17:32.000
私はそれらをつかむためにヒープアドレスを実行します。

00:17:32.000 --> 00:17:37.000
サイズが少なくとも500キロバイトの非オブジェクトのみが欲しいと指定します。

00:17:37.000 --> 00:17:39.000
はは。

00:17:39.000 --> 00:17:44.000
この非物体は約13メガバイトなので、この調査の主な容疑者です。

00:17:44.000 --> 00:17:48.000
私はその住所を手に入れて、それが何であるかについてのいくつかの手がかりを見つけることができるかどうかを確認します。

00:17:48.000 --> 00:17:50.000
現時点ではいくつかの選択肢があります。

00:17:50.000 --> 00:17:56.000
それぞれに状況に応じてメリットがありますので、それぞれを簡単に説明します。

00:17:56.000 --> 00:18:01.000
私が持っている1つの選択肢は、このアドレスでリーク--traceTreeを実行することです。

00:18:01.000 --> 00:18:04.000
これにより、このアドレスを参照するオブジェクトのツリーが表示されます。

00:18:04.000 --> 00:18:14.000
これは、より多くの情報を入手したい特定のオブジェクトがあり、memgraphにmallocスタックロギングやMSLが有効になっていない場合に便利です。

00:18:14.000 --> 00:18:23.000
XCTestのmemgraphは自動的にMSLが有効になっていることを覚えておいてください。ただし、そうでないmemgraphで作業している場合は、このツールを念頭に置いてください。

00:18:23.000 --> 00:18:26.000
関連性があると思われるツリー内のオブジェクトを強調しました。

00:18:26.000 --> 00:18:33.000
私の大きな非オブジェクトは、おそらくMKTCustomMeal PlannerCollectionViewCellのこの食事データオブジェクトと関係があります。

00:18:33.000 --> 00:18:42.000
リーク--referenceTreeを実行することもできます。

00:18:42.000 --> 00:18:49.000
これにより、どのオブジェクトがルートであるかを最もよく推測して、私のプロセス内のすべてのメモリのトップダウン参照ツリーが得られます。

00:18:49.000 --> 00:18:53.000
この出力で、私のアプリでメモリが集約されている場所の感覚を得ることができます。

00:18:53.000 --> 00:19:01.000
このツールは、私が大きな回帰を持っていることを知っているが、どの特定のオブジェクトが責任を負うのか分からない場合に非常に役立ちます。

00:19:01.000 --> 00:19:10.000
--groupByType引数を渡して、タイプをグループ化して、出力を縮小して解析を少し簡単にすることができます。

00:19:10.000 --> 00:19:19.000
多くの場合、回帰の大部分がこのツリー内の単一のノードの下にグループ化され、そのメモリが何であるかについての手がかりを見つけやすくなります。

00:19:19.000 --> 00:19:23.000
繰り返しになりますが、関連するオブジェクトを示すセクションを強調表示しました。

00:19:23.000 --> 00:19:28.000
これは私がリーク-traceTree出力で見たのと同じ食事データオブジェクトです。

00:19:28.000 --> 00:19:33.000
出力は、この食事データオブジェクトに約13メガバイト分のメモリが割り当てられていることを示しています。

00:19:33.000 --> 00:19:36.000
このオブジェクトがどのように割り当てられているのか知りたいです。

00:19:36.000 --> 00:19:44.000
私のmemgraphはMSLが有効になっているので、malloc_history -fullStacksを使ってそれを理解することができます。

00:19:44.000 --> 00:19:50.000
先ほどヒープアドレスから取得した大きな非オブジェクトのアドレスを渡します。

00:19:50.000 --> 00:19:53.000
そして、そのアドレスでオブジェクトの割り当てコールスタックを取得します。

00:19:53.000 --> 00:20:01.000
これは、MSLが有効になっていて、気になるオブジェクトのアドレスを持っている場合に非常に便利です。

00:20:01.000 --> 00:20:07.000
したがって、私の食事データオブジェクトは、ここ3行目に示されているsaveMeal関数に割り当てられていたようです。

00:20:07.000 --> 00:20:10.000
Xcodeに行って、何が起こっているのか見てみます。 様子を見ます。

00:20:10.000 --> 00:20:14.000
これが私のカスタムセルビューコントローラー内のsaveMeal機能です。

00:20:14.000 --> 00:20:16.000
そして、これが犯人です。

00:20:16.000 --> 00:20:20.000
この生のバッファをここに割り当てて、食事データオブジェクトでラップしています。

00:20:20.000 --> 00:20:25.000
このバッファを割り当てているのは、それを入力して結果をディスクに保存できるようにすることです。

00:20:25.000 --> 00:20:29.000
ディスクへの保存が終わったら、このバッファはもう必要ありません。

00:20:29.000 --> 00:20:32.000
では、なぜそれがくっついているのですか?

00:20:32.000 --> 00:20:39.000
さて、食事データはクラスメンバーなので、このクラスインスタンスが存在する限り、参照は残ります。

00:20:39.000 --> 00:20:46.000
これは、任意のセルでsaveMealを押すと、そのセルが割り当てられ、そのセルが破壊されるまで固執する大きなバッファを保持することを意味します。

00:20:46.000 --> 00:20:51.000
私が複数の食事を保存している場合、その記憶は本当に加算される可能性があります。

00:20:51.000 --> 00:20:53.000
では、どうすればこれを修正できますか?

00:20:53.000 --> 00:21:01.000
1つのオプションは、saveMeal関数でmealDataを定義することですが、私はそれがクラスの他の場所で使用されていることを知っているので、私はそれをしたくありません。

00:21:01.000 --> 00:21:06.000
もう1つの方法は、ディスクへの書き込みが終わったら、mealDataをnilに設定することです。

00:21:06.000 --> 00:21:18.000
Swiftのデータオブジェクトは、最終的な参照を失った後にバッファを自動的に割り当て解除するのに十分賢いので、バッファはこの関数の終わりを過ぎても固執しません。

00:21:18.000 --> 00:21:24.000
最後に、断片化について話しましょう。

00:21:24.000 --> 00:21:27.000
iOSでページがどのように機能するかを簡単に見てみましょう。

00:21:27.000 --> 00:21:33.000
ページは、システムがプロセスに付与する固定サイズの分割不可能なメモリの塊です。

00:21:33.000 --> 00:21:44.000
ページは不可分であるため、プロセスがページの任意の部分に書き込むと、ページ全体が汚れていると見なされ、そのほとんどが未使用であっても、プロセスに対して課金されます。

00:21:44.000 --> 00:21:50.000
断片化は、プロセスに100%利用されていない汚れたページがある場合に発生します。

00:21:50.000 --> 00:21:53.000
これがどのように起こるかを理解するために、例を見てみましょう。

00:21:53.000 --> 00:21:58.000
まず、私は3つの連続したクリーンページを持っています。

00:21:58.000 --> 00:22:05.000
プロセスが実行されると、割り当てはこれらのページをいっぱいにし始め、それらを汚します。

00:22:05.000 --> 00:22:12.000
オブジェクトが割り当て解除されると、図で「空きメモリ」とマークされていた空のスロットが作成されます。

00:22:12.000 --> 00:22:18.000
しかし、これらのページはまだいくつかの割り当てられたオブジェクトがあるため、まだ汚れています。

00:22:18.000 --> 00:22:22.000
システムは、これらの空のスロットを将来の割り当てで埋めようとします。

00:22:22.000 --> 00:22:27.000
ここでは、右側のボックスで示された大きな着信割り当てがあります。

00:22:27.000 --> 00:22:33.000
残念ながら、この着信割り当ては大きすぎて、私の空きメモリスロットに収まります。

00:22:33.000 --> 00:22:41.000
空のスロットの合計サイズは十分に大きいですが、それらは連続しておらず、単一の割り当てには使用できません。

00:22:41.000 --> 00:22:49.000
そのため、既存の空きスロットに収まらなかったため、システムは図の右側にある新しいダーティページに私の割り当てを配置しました。

00:22:49.000 --> 00:22:55.000
空きメモリスロットは未充填のままで、断片化されたメモリと見なされます。

00:22:55.000 --> 00:23:02.000
断片化を減らす最善の方法は、メモリ内で互いに近い同様のライフタイムを持つオブジェクトを割り当てることです。

00:23:02.000 --> 00:23:11.000
これは、これらのオブジェクトがすべて一緒に解放されることを確実にするのに役立ち、プロセスに将来の割り当てのために作業するための連続したメモリの大きな塊を与えます。

00:23:11.000 --> 00:23:18.000
この例では、「マイオブジェクト」とマークされたすべてのオブジェクトを手動で割り当て、同時に解放する予定です。

00:23:18.000 --> 00:23:24.000
しかし、私はコードに注意を払わず、システムは私のオブジェクトを他のオブジェクトとインターリーブすることになりました。

00:23:24.000 --> 00:23:33.000
さて、すべてのオブジェクトを解放すると、空きメモリのスロットが4つありますが、これらの割り当てられたオブジェクトによって分割されているため、どれも連続していません。

00:23:33.000 --> 00:23:36.000
これにより、50%の断片化と4つの汚いページになります。

00:23:36.000 --> 00:23:39.000
良くない。

00:23:39.000 --> 00:23:43.000
代わりに、すべてのオブジェクトを一緒に割り当てるコードを書いたらどうなりますか?

00:23:43.000 --> 00:23:46.000
今、それらはすべて2ページで一緒に終わります。

00:23:46.000 --> 00:23:56.000
そして、オブジェクトを解放すると、プロセスはシステム用の2つのクリーンページを解放し、その結果、わずか2つのダーティページと0%の断片化になります。

00:23:56.000 --> 00:23:59.000
断片化がいかにフットプリント乗数であるかに注目してください。

00:23:59.000 --> 00:24:05.000
50%の断片化により、フットプリントが2ページから4ページに倍増しました。

00:24:05.000 --> 00:24:10.000
ほとんどの実際のシナリオでは、いくつかの断片化は避けられません。

00:24:10.000 --> 00:24:15.000
したがって、経験則として、約25%以下の断片化を目指します。

00:24:15.000 --> 00:24:19.000
断片化を減らす1つの方法は、自動リリースプールを使用することです。

00:24:19.000 --> 00:24:25.000
自動解放プールは、スコープ外になるとすぐに、その中に割り当てられたすべてのオブジェクトを解放するようにシステムに指示します。

00:24:25.000 --> 00:24:31.000
これは、自動リリースプールで作成されたすべてのオブジェクトが同様の寿命を持つことを保証するのに役立ちます。

00:24:31.000 --> 00:24:42.000
フラグメンテーションはすべてのプロセスで問題になる可能性がありますが、アドレス空間を断片化する可能性のある割り当てや割り当て解除がたくさんあるため、長時間実行中のプロセスは特に起こりやすい場合があります。

00:24:42.000 --> 00:24:51.000
たとえば、アプリが長時間実行中の拡張機能を使用している場合は、これらのプロセスの断片化を必ず確認してください。

00:24:51.000 --> 00:25:00.000
プロセスの断片化を簡単に確認するには、vmmap -summaryを実行し、出力の一番下までスクロールできます。

00:25:00.000 --> 00:25:02.000
このセクションはmallocゾーンに分かれています。

00:25:02.000 --> 00:25:05.000
各ゾーンには異なるタイプの割り当てが含まれています。

00:25:05.000 --> 00:25:13.000
通常、私はDefaultMallocZoneだけを気にします。なぜなら、それは私のヒープ割り当てがデフォルトで終わる場所だからです。

00:25:13.000 --> 00:25:20.000
しかし、このmemgraphはMSLが有効になっているので、私は実際にMallocStackLoggingLiteZoneを気にしています。

00:25:20.000 --> 00:25:26.000
MSLが有効になっている限り、このゾーンはすべてのヒープ割り当てが終わる場所です。

00:25:26.000 --> 00:25:32.000
% FRAG列は、各mallocゾーンの断片化のためにメモリの何パーセントが無駄になっているかを示しています。

00:25:32.000 --> 00:25:39.000
これらの数字のいくつかはかなり大きいですが、私はMallocStackLoggingLiteZoneに集中するだけです。

00:25:39.000 --> 00:25:48.000
これは、MallocStackLoggingLiteZoneがダーティメモリのシェアが最も大きく、合計5メガバイトのうち4.3メガバイトであるためです。

00:25:48.000 --> 00:25:52.000
だから、今回は他のゾーンを無視することができます。

00:25:52.000 --> 00:26:00.000
「Dirty+swap frag size」列は、各mallocゾーンの断片化によってどれだけのメモリが無駄になっているかを正確に示しています。

00:26:00.000 --> 00:26:04.000
私の場合、断片化のために約800Kを無駄にしています。

00:26:04.000 --> 00:26:09.000
これは多くのように思えますが、前に述べたように、いくつかの断片化は避けられません。

00:26:09.000 --> 00:26:16.000
だから、私が25%の断片化の下に座っている限り、私はこれだけの無駄を許容できると思います。

00:26:16.000 --> 00:26:21.000
MallocStackLoggingLiteZoneで約19%の断片化に座っているようです。

00:26:21.000 --> 00:26:26.000
これは25%の経験則を快適に下回っているので、私は心配していません。

00:26:26.000 --> 00:26:33.000
断片化の問題がある場合は、Instrumentsツールの割り当てトラックを使用できます。

00:26:33.000 --> 00:26:42.000
具体的には、割り当てリストビューを見て、興味のある分野でどのオブジェクトが永続化され、破壊されたかを確認したいと思います。

00:26:42.000 --> 00:26:52.000
フラグメンテーションの文脈では、破壊されたオブジェクトは空きメモリスロットを作成し、永続オブジェクトは残りのオブジェクトであり、ページを汚しておく責任があります。

00:26:52.000 --> 00:26:57.000
断片化を調べているとき、両方とも調査する価値があります。

00:26:57.000 --> 00:27:06.000
インスツルメンツツールの使用方法の詳細については、WWDC 2019の「インスツルメンツを使い始める」トークをご覧ください。

00:27:06.000 --> 00:27:18.000
リークとヒープ回帰に対処し、フラグメンテーションが問題ではないことを確認したので、XCTestを再度実行します。

00:27:18.000 --> 00:27:19.000
素晴らしい。

00:27:19.000 --> 00:27:22.000
XCTestは合格し、回帰は解決されました。

00:27:22.000 --> 00:27:29.000
メモリの問題の検出と診断について学んだので、自分のアプリに使用できるワークフローを確認しましょう。

00:27:29.000 --> 00:27:38.000
新しい機能を追加するときはいつでも、メモリ、および/または他の提供されたシステムメトリックを監視するためのパフォーマンスXCTestを書いてください。

00:27:38.000 --> 00:27:40.000
テストごとに、ベースラインを設定します。

00:27:40.000 --> 00:27:48.000
次に、テストを使用して回帰をキャッチし、収集されたktraceファイルとmemgraphファイルを使用して調査します。

00:27:48.000 --> 00:27:53.000
失敗したXCTestsのmemgraphを使用して、メモリの問題を診断してください。

00:27:53.000 --> 00:27:55.000
最初にすべきことは、漏れがないか確認することです。

00:27:55.000 --> 00:28:01.000
リークツールを実行し、MSLバックトレースを使用して、リークを見つけて修正します。

00:28:01.000 --> 00:28:05.000
回帰にリークが含まれていない場合は、ヒープをチェックしてください。

00:28:05.000 --> 00:28:10.000
Vmmap -summaryから始めて、メモリがヒープ内にあることを確認します。

00:28:10.000 --> 00:28:15.000
もしそうなら、heap -diffFromを実行して、どのオブジェクトタイプが成長の原因かを確認します。

00:28:15.000 --> 00:28:20.000
犯人が明らかな場合は、ヒープアドレスを使用して住所を取得します。

00:28:20.000 --> 00:28:24.000
そうでない場合は、いくつかの手がかりについては、リーク-referenceTreeを見てください。

00:28:24.000 --> 00:28:31.000
最後に、リーク-traceTreeおよび/またはmalloc_historyで犯人オブジェクトアドレスを調査します。

00:28:31.000 --> 00:28:36.000
最後に、これらの記憶のベストプラクティスを念頭に置いて開発していることを確認してください。

00:28:36.000 --> 00:28:38.000
アプリのリークをゼロにするように努めてください。

00:28:38.000 --> 00:28:43.000
安全でないタイプで作業している場合は、割り当てたすべてのものを解放することを忘れないでください。

00:28:43.000 --> 00:28:47.000
また、コードの保持サイクルにも目を光らせてください。

00:28:47.000 --> 00:28:58.000
ヒープの割り当てを縮小したり、より短い期間保持したり、不要な割り当てを完全に取り除いたりするなど、ヒープの割り当てを減らす方法を見つけてください。

00:28:58.000 --> 00:29:00.000
断片化を念頭に置いてください。

00:29:00.000 --> 00:29:07.000
似たようなライフタイムを持つオブジェクトを隣同士に割り当てて、後で素敵で大きな空きメモリの塊を作成します。

00:29:07.000 --> 00:29:15.000
これらのベストプラクティスとXCTestワークフローを使用すると、アプリのメモリの問題を検出、診断、修正することができます。

00:29:15.000 --> 00:29:19.000
タヌジャと私を代表して、チューニングしてくれてありがとう。

00:29:19.000 --> 23:59:59.000
[パーカッシブミュージック]。

