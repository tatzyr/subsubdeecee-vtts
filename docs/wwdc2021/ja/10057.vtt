WEBVTT

00:00:00.000 --> 00:00:05.000
♪ベース音楽の演奏♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:12.000
クリス・ドネガン:こんにちは、私はUIKitのエンジニアであるクリスです。

00:00:12.000 --> 00:00:15.000
後で同僚のアナントとモハメッドが参加します。

00:00:15.000 --> 00:00:20.000
iPadは、そのパワーと機能により、多くの人々にとって主要なデバイスです。

00:00:20.000 --> 00:00:28.000
このビデオでは、iPadアプリを次のレベルに引き上げるために使用すべきいくつかのエキサイティングな新機能について学びます。

00:00:28.000 --> 00:00:33.000
まず、マルチタスクとシーンの最新の進歩を紹介します。

00:00:33.000 --> 00:00:38.000
その後、Anantはキーボードショートカットの強力な変更を案内します。

00:00:38.000 --> 00:00:44.000
最後に、Mohammedはシステムポインタの最新の機能強化を紹介します。

00:00:44.000 --> 00:00:47.000
すぐにマルチタスクに入りましょう。

00:00:47.000 --> 00:00:52.000
iPadOS 13では、アプリのUIの複数のインスタンスを実行する機能が導入されました。

00:00:52.000 --> 00:01:01.000
iPadOS 15では、シーンプレゼンテーション用の新しいAPIと強化された状態復元で、このエクスペリエンスを改善しています。

00:01:01.000 --> 00:01:05.000
これらの機能強化は、既存のUISceneインフラストラクチャに基づいています。

00:01:05.000 --> 00:01:11.000
UISceneを採用していない場合は、「iPadで複数のWindowsを導入する」をチェックしてください。

00:01:11.000 --> 00:01:15.000
重要な概念を簡単に説明しましょう。

00:01:15.000 --> 00:01:20.000
シーンは、アプリのUIの単一のインスタンスを表します。

00:01:20.000 --> 00:01:25.000
シーンの構成要素の構造は、シーン構成によって定義されます。

00:01:25.000 --> 00:01:30.000
少なくとも、シーンの役割とデリゲートクラスを定義します。

00:01:30.000 --> 00:01:34.000
名前、ストーリーボード、シーンサブクラスを指定することもできます。

00:01:34.000 --> 00:01:43.000
シーン設定は、Info.plistで宣言することも、UISceneConfigurationオブジェクトを使用して実行時に作成することもできます。

00:01:43.000 --> 00:01:48.000
シーンの内容はNSUserActivityで表されます。

00:01:48.000 --> 00:01:52.000
これらの活動は、シーンの要求や状態の復元に使用されます。

00:01:52.000 --> 00:01:56.000
シーンはシーンデリゲートによって管理されます。

00:01:56.000 --> 00:02:05.000
デリゲートは、UIの設定、ライフサイクルイベントへの応答、状態の保存と復元を担当します。

00:02:05.000 --> 00:02:09.000
最後に、シーンはシーンセッションによって追跡されます。

00:02:09.000 --> 00:02:15.000
シーン自体は、バックグラウンドにあるときにシステムによって切断され、再接続することができます。

00:02:15.000 --> 00:02:22.000
シーンセッションは、接続状態に関係なくシーンを追跡し、起動の合間に持続します。

00:02:22.000 --> 00:02:27.000
セッションは、システムアプリスイッチャーの表現と考えることができます。

00:02:27.000 --> 00:02:31.000
スイッチャーの各項目は、シーンセッションに対応します。

00:02:31.000 --> 00:02:38.000
システムからシーンをリクエストするときは、リクエストをカスタマイズするためのオプションオブジェクトを提供できます。

00:02:38.000 --> 00:02:42.000
iPadOS 15には、ウィンドウシーン専用の新しいオプションサブクラスがあります。

00:02:42.000 --> 00:02:47.000
このサブクラスを使用すると、プレゼンテーションスタイルを指定できます。

00:02:47.000 --> 00:02:54.000
ウィンドウシーンのプレゼンテーションスタイルは、ワークスペースの他のシーンと比較してシーンがどのように表示されるかに影響します。

00:02:54.000 --> 00:03:00.000
目立つ、標準、自動の3つの可能な値があります。

00:03:00.000 --> 00:03:04.000
これは目立つプレゼンテーションスタイルを使ったシーンです。

00:03:04.000 --> 00:03:09.000
それは現在のワークスペースでモーダルに提示され、その背後にあるシーンは暗められています。

00:03:09.000 --> 00:03:13.000
モーダルなので、キャンセル、閉じる、または完了ボタンを指定する必要があります。

00:03:13.000 --> 00:03:18.000
この新しいスタイルは、新しいシーンの舞台と考えることができます。

00:03:18.000 --> 00:03:27.000
新しいマルチタスクコントロールを使用して、他のシーンと同様に再配置でき、後でアプリシェルフに移動することもできます。

00:03:27.000 --> 00:03:33.000
このスタイルがシーンに適しているかどうかを検討する際には、心に留めておくべきガイドラインがいくつかあります。

00:03:33.000 --> 00:03:36.000
まず、目立つシーンはそれ自体が役に立つはずです。

00:03:36.000 --> 00:03:41.000
別のシーンにオプションやツールを提供するために使用すべきではありません。

00:03:41.000 --> 00:03:50.000
「完了」または「閉じる」ボタンを提供し、ドキュメントやファイルなど、アプリ内の特定のコンテンツに専念する必要があります。

00:03:50.000 --> 00:03:56.000
この専用のコンテンツスコープは、シーンのアクティベーション条件で定義する必要があります。

00:03:56.000 --> 00:04:03.000
アクティベーション条件の詳細については、「複数のWindowsでコンテンツをターゲットにすること」をチェックしてください。

00:04:03.000 --> 00:04:08.000
この例は、Safariが標準スタイルを使用して新しいシーンを開く方法を示しています。

00:04:08.000 --> 00:04:16.000
それらは並んで提示され、それぞれとの相互作用を可能にし、両方ともメインシーンの完全な機能を提供します。

00:04:16.000 --> 00:04:20.000
スタイルとして自動を指定することもできます。

00:04:20.000 --> 00:04:26.000
この値は、要求された方法に基づいて最適なスタイルを選択する必要があることをシステムに伝えます。

00:04:26.000 --> 00:04:37.000
iPadOS 15は、スタイルを使用してプレゼンテーションをカスタマイズする方法を提供するだけでなく、新しいシーンでコンテンツを簡単に開くことができます。

00:04:37.000 --> 00:04:42.000
Macでは、コンテキストメニューで新しいウィンドウで開くアイテムを見つけるのが一般的です。

00:04:42.000 --> 00:04:49.000
UIWindowScene.ActivationActionを使用して、この使い慣れた体験をiPadアプリに持ち込む必要があります。

00:04:49.000 --> 00:04:56.000
これは、メニュー、ボタン、バーボタンの項目で使用できるシーンを要求するための新しいUIActionサブクラスです。

00:04:56.000 --> 00:05:03.000
この機能をアプリに追加するには、まずUIWindowScene.ActivationActionを初期化します。

00:05:03.000 --> 00:05:08.000
アイテムが選択されたときに実行されるクロージャで初期化されます。

00:05:08.000 --> 00:05:15.000
クロージャは、新しいシーンのコンテンツのユーザーアクティビティを含むアクティベーション設定を返す必要があります。

00:05:15.000 --> 00:05:20.000
最後に、アクションをメニューに入れて、あなたは行っても大丈夫です。

00:05:20.000 --> 00:05:27.000
iPadとMac Catalystでは、メニューに「新しいウィンドウで開く」項目が表示され、選択すると新しいシーンが表示されます。

00:05:27.000 --> 00:05:34.000
iPhoneでは、複数のシーンがサポートされていないため、アイテムは自動的に非表示になります。

00:05:34.000 --> 00:05:39.000
代わりに別のアイテムを表示したい場合は、代替アクションを提供できます。

00:05:39.000 --> 00:05:42.000
前の例を更新して1つを提供しましょう。

00:05:42.000 --> 00:05:46.000
これを行うには、代替アクションを作成することから始めます。

00:05:46.000 --> 00:05:52.000
新しいアクションのタイトルと画像は、複数のウィンドウが利用できない場合に表示されます。

00:05:52.000 --> 00:06:01.000
次に、新しいアクションを代替として渡すことで、シーンアクティベーションアクションの初期化子を更新します。

00:06:01.000 --> 00:06:16.000
代替アクションが提供されると、iPadとMac Catalystのメニューにはまだ「新しいウィンドウで開く」項目が表示されますが、iPhoneでは「詳細を表示」項目が表示されます。すべてコードに単一の条件なしで行われます。

00:06:16.000 --> 00:06:22.000
これらのメニュー項目を追加することは、人々が新しいシーンでコンテンツを開くための明確で身近な方法です。

00:06:22.000 --> 00:06:24.000
しかし、それが唯一の方法ではありません。

00:06:24.000 --> 00:06:30.000
iPadはタッチファーストのデバイスで、1回のジェスチャーで簡単にシーンを開くことができます。

00:06:30.000 --> 00:06:34.000
メモアプリでは、セルをつまむと、新しいシーンでメモが開きます。

00:06:34.000 --> 00:06:40.000
シーンは、セルから最終的な位置までインタラクティブにアニメーション化されます。

00:06:40.000 --> 00:06:44.000
アプリでこの機能を提供するには2つの方法があります。

00:06:44.000 --> 00:06:48.000
コレクションビューを使用している場合は、新しいデリゲートメソッドがあります。

00:06:48.000 --> 00:06:52.000
その他のビューについては、UIWindowScene ActivationInteractionを使用してください。

00:06:52.000 --> 00:06:57.000
これらは両方とも、目立つスタイルのシーンを提示するためのものです。

00:06:57.000 --> 00:07:06.000
コレクションビューでこのジェスチャーをサポートするには、sceneActivationConfiguration ForItemAt indexPathという名前の新しいデリゲートメソッドを実装します。

00:07:06.000 --> 00:07:10.000
これは、以前のコンテキストメニューの例と非常によく似ています。

00:07:10.000 --> 00:07:18.000
新しいシーンのコンテンツのユーザーアクティビティを作成し、そのアクティビティでアクティベーション設定を返します。

00:07:18.000 --> 00:07:22.000
すべてのセルが新しいシーンを開くのをサポートしたくないかもしれません。

00:07:22.000 --> 00:07:26.000
ジェスチャーが始まるのを防ぐために、ゼロを返してください。

00:07:26.000 --> 00:07:32.000
他のビューでこのジェスチャーをサポートするには、UIWindowSceneを作成します。アクティベーションインタラクション。

00:07:32.000 --> 00:07:42.000
これは、相互作用自体とビューの座標空間における相互作用のポイントという2つの引数を受け入れるクロージャで作成されます。

00:07:42.000 --> 00:07:47.000
これらは、ビューのさまざまな領域の特定のユーザーアクティビティを作成するために使用できます。

00:07:47.000 --> 00:07:53.000
クロージャは、ユーザーアクティビティのアクティベーション設定を返す必要があります。

00:07:53.000 --> 00:07:55.000
インタラクションにはエラーハンドラもかかります。

00:07:55.000 --> 00:08:06.000
複数のシーンをサポートしていないプラットフォームではインタラクションが無効になっていますが、構成の問題やシステムリソースの不足によりエラーが発生する可能性があります。

00:08:06.000 --> 00:08:14.000
ウィンドウシーンを表示するこれらの方法はすべて、同じアクティベーション設定オブジェクトを使用していることにお気づきでしょう。

00:08:14.000 --> 00:08:22.000
その唯一の要件はユーザーアクティビティですが、シーンリクエストオプションとターゲットプレビューも含まれています。

00:08:22.000 --> 00:08:26.000
これらが提供されていない場合、システムはあなたのためにそれらを作成するために最善を尽くします。

00:08:26.000 --> 00:08:31.000
しかし、あなたは経験を洗練させるためにそれらを明示的に提供することができます。

00:08:31.000 --> 00:08:36.000
例として、これらのコレクションビューセルには、サムネイル、タイトル、キャプションがあります。

00:08:36.000 --> 00:08:43.000
セルがピンチアウトされると、主にサムネイルのコンテンツのより大きなバージョンを表示するシーンが表示されます。

00:08:43.000 --> 00:08:47.000
新しいシーンがセル全体から移行していることに注意してください。

00:08:47.000 --> 00:08:51.000
サムネイルだけから移行した方が良さそうです。

00:08:51.000 --> 00:08:57.000
この効果を達成するために、アクティベーション設定は以前と同じように作成されます。

00:08:57.000 --> 00:09:01.000
次に、セルがサムネイルセルであるかどうかを確認します。

00:09:01.000 --> 00:09:09.000
その場合は、セルのサムネイルビューを使用してターゲットを絞ったプレビューを作成し、設定に設定します。

00:09:09.000 --> 00:09:15.000
アクティベーション設定のカスタムプレビューを提供することで、トランジションははるかに洗練されます。

00:09:15.000 --> 00:09:17.000
詳しく見てみましょう。 

00:09:17.000 --> 00:09:27.000
今では、セル自体から移行するのではなく、サムネイルから移行し、セルの残りの部分を所定の位置に残します。

00:09:27.000 --> 00:09:32.000
アクティベーション設定では、アプリのシーンをリクエストできます。

00:09:32.000 --> 00:09:37.000
ただし、自分でシーンを構築することなく、単にファイルを表示したいと思うかもしれません。

00:09:37.000 --> 00:09:41.000
iPadOS 15はこれをとても簡単にします。

00:09:41.000 --> 00:09:50.000
UIWindowSceneには特別なサブクラスがあります。ActivationConfigurationは「QLPreviewScene ActivationConfiguration」と呼ばれます。

00:09:50.000 --> 00:09:55.000
プレビューシーン設定を返すと、システムが管理するプレビューシーンが要求されます。

00:09:55.000 --> 00:10:04.000
シーンデリゲートや心配するコールバックはありませんが、アプリはInfo.plistで複数のウィンドウのサポートを宣言する必要があります。

00:10:04.000 --> 00:10:10.000
人々が新しいシーンでコンテンツを開くための洗練された便利な方法を提供することは重要です。

00:10:10.000 --> 00:10:18.000
しかし、シーンの状態を保存して復元することも同様に重要なので、後でそれらに戻ることはシームレスな経験です。

00:10:18.000 --> 00:10:26.000
シーンがバックグラウンドに移動すると、システムはシーンのデリゲートにNSUserActivityがその状態を表すように要求します。

00:10:26.000 --> 00:10:33.000
このアクティビティは、Handoffをサポートしている場合は、ルートビューコントローラーのアクティビティ、またはその場で作成されたアクティビティである可能性があります。

00:10:33.000 --> 00:10:42.000
ここでは、アクティビティのユーザー情報辞書にテキストフィールドの内容を保存してユーザーアクティビティが作成されます。

00:10:42.000 --> 00:10:47.000
最高の体験を提供するために、シーンの状態はコンテンツだけを超える必要があります。

00:10:47.000 --> 00:10:55.000
また、スクロール位置、カーソル位置、ファーストレスポンダーステータスなどの視覚的およびインタラクション状態も保存する必要があります。

00:10:55.000 --> 00:11:03.000
これらのそれぞれを個別に保存するのではなく、UITextFieldとUITextViewはinteractionStateプロパティを持つようになりました。

00:11:03.000 --> 00:11:08.000
このプロパティは、すべてのインタラクション状態を含む単一のオブジェクトを提供します。

00:11:08.000 --> 00:11:17.000
オブジェクトにはコンテンツ自体が含まれていないため、ユーザーアクティビティに保存するための追加情報です。

00:11:17.000 --> 00:11:21.000
テキストフィールドのインタラクション状態を保存して、前の例を更新しました。

00:11:21.000 --> 00:11:32.000
これで、コンテンツとインタラクション状態の両方を保存することで、ユーザーアクティビティには正確に復元するのに十分な情報が含まれています。

00:11:32.000 --> 00:11:37.000
iPadOS 14では、状態の復元は少し難しい場合があります。

00:11:37.000 --> 00:11:44.000
シーンが接続されているときに状態を復元しようとすると、ストーリーボードとビューが完全にロードされていないことに気付くでしょう。

00:11:44.000 --> 00:11:51.000
後で復元した場合、シーンがフォアグラウンドに移行していたときに、それが初めてだったかどうかを追跡する必要がありました。

00:11:51.000 --> 00:11:58.000
iPadOS 15は、状態を復元するための新しいデリゲートメソッドでこの問題を解決します。

00:11:58.000 --> 00:12:06.000
シーンが接続され、ストーリーボードがロードされた後、フォアグラウンドへの最初の移行の前に呼び出されます。

00:12:06.000 --> 00:12:12.000
アプリがストーリーボードを使用しているかどうかに関係なく、状態を復元するためにこの新しいコールバックを使用する必要があります。

00:12:12.000 --> 00:12:20.000
前の例で保存されたアクティビティから状態を復元することは、システムが sceneRestoreInteractionStateを呼び出すことから始まります。

00:12:20.000 --> 00:12:24.000
次に、テキストフィールドの内容を復元します。

00:12:24.000 --> 00:12:27.000
最後に、その相互作用状態を復元します。

00:12:27.000 --> 00:12:32.000
インタラクション状態の前にコンテンツを復元することが重要です。

00:12:32.000 --> 00:12:36.000
最後に、同期復元状態は複雑になる可能性があります。

00:12:36.000 --> 00:12:42.000
データベースにアクセスしたり、ファイルをロードしたりする必要がある場合があり、その間に空のUIは不要です。

00:12:42.000 --> 00:12:48.000
これを考慮して、iPadOS 15では、アプリが短期的な延長をリクエストできます。

00:12:48.000 --> 00:12:55.000
この拡張機能の間、メインのRunLoopの実行を許可しながら、起動イメージは表示されたままになります。

00:12:55.000 --> 00:13:01.000
コンテンツが読み込まれると、アプリは復元を完了するように合図するはずです。

00:13:01.000 --> 00:13:08.000
この拡張機能は短く、ネットワークアクセスなどの潜在的に長時間実行されるタスクに使用することを意図していません。

00:13:08.000 --> 00:13:14.000
アプリの完了の合図に失敗したり、時間がかかりすぎたりすると、システムによって閉じられます。

00:13:14.000 --> 00:13:19.000
拡張状態復元を使用するには、まずシーンから拡張をリクエストします。

00:13:19.000 --> 00:13:22.000
その後、非同期作業を開始します。

00:13:22.000 --> 00:13:28.000
コンテンツが読み込まれたら、それを復元し、シーンに復元を完了するように指示します。

00:13:28.000 --> 00:13:31.000
その後、シーンには復元されたばかりのUIが表示されます。

00:13:31.000 --> 00:13:39.000
アプリでマルチタスクをサポートすることはそれを輝かせますが、真の次のレベルのiPadアプリになるためには、やるべきことがもっとあります。

00:13:39.000 --> 00:13:41.000
そして今、アナントへ。

00:13:41.000 --> 00:13:43.000
アナント・ジェイン:ありがとう、クリス!

00:13:43.000 --> 00:13:47.000
私の名前はアナントで、UIKitエンジニアです。

00:13:47.000 --> 00:13:58.000
人々は、iPadが一瞬の通知で物理的なキーボードに取り付けることができながら、手に持つのに十分軽いのが大好きです。

00:13:58.000 --> 00:14:03.000
彼らは、優れたキーボードサポートを持つことで、あなたのアプリが彼らに追いつくことを期待しています。

00:14:03.000 --> 00:14:11.000
iPadOS 15では、アプリのキーボードショートカットを次のレベルに引き上げるためのいくつかの新機能が導入されています。

00:14:11.000 --> 00:14:17.000
iPadOS 15は、キーボードショートカットを発見するためのまったく新しいインターフェースを備えています。

00:14:17.000 --> 00:14:27.000
各コマンドを使い慣れたカテゴリに構造化し、iPadとMac Catalystバージョンのアプリ間のパリティが向上します。

00:14:27.000 --> 00:14:33.000
メニューは、システム全体のどこからでも起動できる便利な検索機能を提供します。

00:14:33.000 --> 00:14:37.000
ショートカットをタップしてトリガーすることもできます。

00:14:37.000 --> 00:14:49.000
コマンドがレスポンダーチェーンにディスパッチされる方法など、UIKeyCommandでキーボードショートカットをサポートする方法について復習が必要な場合は、「アプリでハードウェアキーボードをサポートする」をチェックしてください。

00:14:49.000 --> 00:14:57.000
Mac Catalystでは、各アプリにはメインメニューと呼ばれるグローバルメニューがあり、画面上部のメニューバーに表示されます。

00:14:57.000 --> 00:15:11.000
メインメニューは、ファイルや編集などのいくつかのカテゴリサブメニューで構成されており、これらのカテゴリメニューには、すべてのアプリのコマンドを含むさらなるサブメニューが含まれています。

00:15:11.000 --> 00:15:16.000
iPadOS 15では、メインメニューシステムをiPadアプリに導入しました。

00:15:16.000 --> 00:15:23.000
Commandキーを押したままに表示される新しいショートカットインターフェイスには、このメニューが表示されます。

00:15:23.000 --> 00:15:29.000
現在、メインメニューシステムは、Macと比較してiPadで少し異なって表現されています。

00:15:29.000 --> 00:15:37.000
Macは各カテゴリ内の完全なサブメニュー階層を表示しますが、iPadはそれらの階層を平坦化します。

00:15:37.000 --> 00:15:44.000
無効で実行不可能なコマンドは、Macではグレー表示表示されますが、iPadでは非表示になっています。

00:15:44.000 --> 00:15:51.000
さらに、iPadのショートカットメニューは、アプリでキーボードショートカットを見つけるのに役立つように設計されています。

00:15:51.000 --> 00:15:56.000
Macのメニューバーのようにキーレスコマンドは表示されません。

00:15:56.000 --> 00:16:03.000
デフォルトでは、メインメニューには、ファイルや編集などのすべてのシステムカテゴリメニューが含まれています。

00:16:03.000 --> 00:16:10.000
これらには、UndoとRedo、PasteとMatch Styleなど、すべてのシステムコマンドが含まれます。

00:16:10.000 --> 00:16:24.000
iPadOS 15は、このシステムコマンドのリストにPrintコマンドを追加します。このコマンドは、アプリがInfo.plistにUIApplication SupportsPrintCommandキーを追加することで取得できます。

00:16:24.000 --> 00:16:35.000
iPadOS 15のiPadアプリがメインメニューシステムをサポートしているようになったので、Mac Catalystアプリと同様に、UIMenuBuilder APIを使用してカスタマイズできます。

00:16:35.000 --> 00:16:43.000
実際、すでにアプリのMac Catalystバージョンをお持ちの場合は、すでにほとんどの作業を完了しています。

00:16:43.000 --> 00:16:48.000
アプリはビルダーを使用して、サポートされているすべてのキーコマンドをメインメニューに追加する必要があります。

00:16:48.000 --> 00:17:01.000
これは、アプリが以前にキーボードショートカットを宣言する方法からの変更です。UIResponderのkeyCommandsプロパティをオーバーライドするか、ビューコントローラーでaddKeyCommand(_:)を呼び出すことによって。

00:17:01.000 --> 00:17:10.000
この方法で定義されたコマンドは引き続き機能しますが、新しいインターフェイスの別の未分類セクションに表示されます。

00:17:10.000 --> 00:17:16.000
アプリは、このようなキーコマンド宣言を削除し、代わりにメインメニューに追加する必要があります。

00:17:16.000 --> 00:17:22.000
メインメニューをカスタマイズするには、AppDelegateでbuildMenu(withbuilder:)をオーバーライドします。

00:17:22.000 --> 00:17:29.000
UIKitは、アプリの起動時にこのメソッドを呼び出し、UIMenuBuilderオブジェクトを渡します。

00:17:29.000 --> 00:17:33.000
アプリは、ビルダーがメインメニューシステムを変更しているかどうかを確認する必要があります。

00:17:33.000 --> 00:17:38.000
もしそうなら、彼らはビルダーを使ってカスタマイズを行うことができます。

00:17:38.000 --> 00:17:44.000
アプリがタブを操作するためのファイルメニューにいくつかのキーコマンドを求めているとします。

00:17:44.000 --> 00:17:53.000
アプリは、UIMenu APIを使用してサブメニューを作成し、そのメニューの子として目的のキーコマンドを追加するだけです。

00:17:53.000 --> 00:18:02.000
次に、アプリはビルダーオブジェクトのinsertChildメソッドを呼び出して、ファイルメニューにサブメニューを挿入します。

00:18:02.000 --> 00:18:11.000
ファイルメニューのように、メインメニューシステムの既存の要素を参照するには、この場合、アプリは要素の識別子を指定する必要があります。

00:18:11.000 --> 00:18:19.000
組み込みのシステムメニュー識別子は、UIMenu.Identifierの下で定数として定義されています。

00:18:19.000 --> 00:18:23.000
アプリは独自のメニューカテゴリも簡単に作成できます。

00:18:23.000 --> 00:18:29.000
ここで、アプリはブックマークメニューを作成します - もう一度、UIMenu APIを使用します。

00:18:29.000 --> 00:18:37.000
次に、アプリはビルダーを使用してそのメニューをルートメニューに挿入します。この場合、システムビューメニューの後です。

00:18:37.000 --> 00:18:39.000
必要なのはそれだけです!

00:18:39.000 --> 00:18:46.000
これで、ビルダーは、ファイルメニューと同じように、ブックマークメニューにさらに挿入するために使用できます。

00:18:46.000 --> 00:18:52.000
UIKitが自動的に生成する新しいメニューの識別子を渡すだけです。

00:18:52.000 --> 00:18:55.000
今、私は識別子に言及し続けています。

00:18:55.000 --> 00:19:04.000
UIMenuBuilderは、メインメニューシステムの各要素に、個々のコマンドを含む一意の識別子を持つように強制します。

00:19:04.000 --> 00:19:11.000
アプリがキーコマンドを挿入して、コンテンツをリストまたはグリッドとして表示するとします。

00:19:11.000 --> 00:19:15.000
どちらのコマンドも同じアクションを共有します: changeViewMode(_:)。

00:19:15.000 --> 00:19:25.000
メインメニューシステムでは、コマンドはアクションによって暗黙的に識別されるため、これらのコマンドは両方とも同じ識別子を共有します。

00:19:25.000 --> 00:19:31.000
UIMenuBuilderは、異なる識別子がない限り、両方のコマンドを挿入することはできません。

00:19:31.000 --> 00:19:37.000
これらのコマンドを区別する1つの方法は、異なるpropertyList値を与えることです。

00:19:37.000 --> 00:19:44.000
しかし、より良い方法は、単に各コマンドに、それが具体的に何をするかを説明するユニークなアクションを与えることです。

00:19:44.000 --> 00:19:51.000
ビルダーはまた、メインメニューのキーボードショートカットの組み合わせがユニークであることを強制します。

00:19:51.000 --> 00:19:56.000
アプリがCommand-IにGet Infoキーコマンドを挿入したとします。

00:19:56.000 --> 00:20:05.000
テキストスタイルメニューのシステムイタリックショートカットは同じショートカットを共有しているため、この挿入も失敗します。

00:20:05.000 --> 00:20:08.000
繰り返しになりますが、2つの解決策があります。

00:20:08.000 --> 00:20:16.000
このアプリは、Get Infoショートカットを、Control-Command-Iなどの既存のショートカットと衝突しないものに変更できます。

00:20:16.000 --> 00:20:23.000
あるいは、アプリは、必要でない場合は、テキストスタイルのコマンドを削除するようにビルダーに指示することができます。

00:20:23.000 --> 00:20:36.000
挿入に重複が含まれている場合、UIMenuBuilderはその挿入に失敗し、重複したキーコマンドまたは共有識別子を示すエラーをコンソールに記録します。

00:20:36.000 --> 00:20:46.000
挿入が表示されない場合は、どこかに重複がある可能性があるので、コンソールでこのようなログを探してください。

00:20:46.000 --> 00:20:56.000
buildMenu(with builder:)への呼び出しが終了すると、アプリのメインメニューがMacのメニューバーとiPadのショートカットオーバーレイに表示されます。

00:20:56.000 --> 00:20:58.000
しかし、1つ問題があります。

00:20:58.000 --> 00:21:05.000
アプリは、ブックマークを名前または日付で並べ替えるコマンドを含むサブメニューを追加しました。

00:21:05.000 --> 00:21:14.000
しかし、iPadのショートカットオーバーレイにはサブメニュー階層が表示されないため、これらのショートカットがiPadOSで何をするかは明らかではありません。

00:21:14.000 --> 00:21:20.000
このような状況では、キーコマンドでよりわかりやすい発見可能性のタイトルを設定します。

00:21:20.000 --> 00:21:27.000
iPadOSは、両方が提供されている場合、通常のタイトルよりも発見可能性のタイトルを好みます。

00:21:27.000 --> 00:21:37.000
さて、先ほど、個々のレスポンダーはキーボードショートカットの宣言を避け、代わりにメインメニューシステムで宣言する必要があると述べました。

00:21:37.000 --> 00:21:44.000
ただし、レスポンダーはメインメニューコマンドのアクションメソッドを実装する必要があります。

00:21:44.000 --> 00:21:51.000
キーコマンドがトリガーされると、UIKitは自動的にアクションをレスポンダーにディスパッチします。

00:21:51.000 --> 00:21:56.000
UIKitは、アプリのレスポンダーチェーンを横断することでこれを行います。

00:21:56.000 --> 00:22:04.000
アクションを実行できるレスポンダを見つけるとすぐに、そのレスポンダのアクションメソッドを呼び出します。

00:22:04.000 --> 00:22:10.000
チェーン内の何もアクションを実行できない場合、キーコマンドは実行できません。

00:22:10.000 --> 00:22:19.000
UIResponderの概念を初めて使うなら、「アプリでハードウェアキーボードをサポート」には、それがどのように機能するかについて素晴らしい紹介があります。

00:22:19.000 --> 00:22:24.000
「素晴らしいMac Catalystアプリの資質」ももう少し詳しく説明しています。

00:22:24.000 --> 00:22:31.000
UIKitがチェーンに沿ってレスポンダー検索を実行すると、2つの便利なUIResponderメソッドを呼び出します。

00:22:31.000 --> 00:22:37.000
アプリは、キーコマンドを改善するために、レスポンダーでこれらのメソッドをオーバーライドできます。

00:22:37.000 --> 00:22:46.000
1つ目は、UIKitがレスポンダーがアクションを実行できるかどうかを確認するために使用するcanPerformAction(_:withSender:)です。

00:22:46.000 --> 00:22:55.000
デフォルトでは、レスポンダがそのアクションメソッドを実装する場合、これはtrueを返します。それ以外の場合は、falseを返します。

00:22:55.000 --> 00:22:59.000
レスポンダーはこれをオーバーライドしてカスタムロジックを追加できます。

00:22:59.000 --> 00:23:09.000
たとえば、Webブラウザは、開いているタブがない場合、closeTabコマンドが実行できないことをUIKitに伝えることができます。

00:23:09.000 --> 00:23:20.000
UIKitはそのアクションのターゲットレスポンダーを見つけることができないため、コマンドは実行不能になり、ショートカットインターフェイスには表示されません。

00:23:20.000 --> 00:23:26.000
このメソッドのオーバーライドは、未処理のケースに対してsuperを呼び出す必要があることに注意してください。

00:23:26.000 --> 00:23:30.000
もう1つの便利な方法はvalidate(_ command:)です。

00:23:30.000 --> 00:23:39.000
UIKitがキーコマンドのターゲットレスポンダを見つけると、そのレスポンダでこのメソッドを呼び出し、コマンドのコピーを渡します。

00:23:39.000 --> 00:23:47.000
レスポンダーは、validate(_ command:)をオーバーライドして、アプリの現在の状態のコマンドの外観を更新できます。

00:23:47.000 --> 00:23:55.000
ここでは、アプリは現在のページがブックマークされているかどうかに基づいて、toggleBookmark(_:)コマンドのタイトルを更新します。

00:23:55.000 --> 00:24:00.000
このメソッドで設定されたタイトルは、表示されたときにショートカットインターフェイスに反映されます。

00:24:00.000 --> 00:24:06.000
iPadOS 15では、UIKitはレスポンダーチェーンに大きな変更を導入しています。

00:24:06.000 --> 00:24:16.000
アプリがフォーカスシステムでキーボードナビゲーションを採用すると、レスポンダートラバーサルはファーストレスポンダーではなくフォーカスされたアイテムから開始されます。

00:24:16.000 --> 00:24:21.000
この変更は、キーコマンドで非常にうまく機能します。

00:24:21.000 --> 00:24:27.000
たとえば、写真を使用すると、ユーザーはキーボードのみを使用してフォトライブラリを操作できます。

00:24:27.000 --> 00:24:32.000
ユーザーがグリッド内のセルに焦点を合わせると、スペースバーを押してその写真を見ることができます。

00:24:32.000 --> 00:24:37.000
Command-Cを押してその写真をコピーして別のアプリに貼り付けることもできます。

00:24:37.000 --> 00:24:47.000
各セルはさまざまなキーコマンドアクションを実装し、レスポンダートラバーサルはフォーカスされたアイテムから始まるため、キーコマンドはセルをターゲットにします。

00:24:47.000 --> 00:24:53.000
要するに、フォーカスシステムはキーコマンドとレスポンダーチェーンをレベルアップします。

00:24:53.000 --> 00:24:58.000
それを利用して、アプリで強力なコンテキストショートカットをサポートしてください。

00:24:58.000 --> 00:25:03.000
詳細については、「iPadのキーボードナビゲーションに焦点を当てる」をチェックしてください。

00:25:03.000 --> 00:25:10.000
最後に、iPadOS 15とmacOS 12はキーボードショートカットのローカリゼーションを導入します。

00:25:10.000 --> 00:25:19.000
これらのSDKを使用してアプリを構築すると、システムは自動的に各キーボードレイアウトのショートカット修飾子と入力をローカライズします。

00:25:19.000 --> 00:25:22.000
たとえば、コマンドバックスラッシュショートカットを取ります。

00:25:22.000 --> 00:25:31.000
ショートカットは米国のキーボードで動作しますが、そのレイアウトにはバックスラッシュキーがないため、日本語のキーボードで実行することは不可能です。

00:25:31.000 --> 00:25:34.000
そのため、システムは日本語キーボードのショートカットを再マッピングします。

00:25:34.000 --> 00:25:42.000
これは、アプリがショートカット修飾子や入力をローカライズせず、代わりにシステムに作業をさせるべきであることを意味します。

00:25:42.000 --> 00:25:50.000
アプリは、アプリ全体のレベルまたはショートカットごとに自動ローカリゼーションをオプトアウトすることもできます。

00:25:50.000 --> 00:25:57.000
システムがショートカットをローカライズすると、右から左へのレイアウトにもミラーリングされます。

00:25:57.000 --> 00:26:05.000
たとえば、Command左括弧で後方に移動するショートカットは、Command右括弧に反転します。

00:26:05.000 --> 00:26:17.000
ショートカットをミラーリングすべきでない場合は、コマンドの allowsAutomaticMirroring プロパティを false に設定して、自動ローカリゼーションを完全に無効にせずにミラーリングを無効にします。

00:26:17.000 --> 00:26:21.000
iPadOS 15は、キーボードショートカットのための巨大なリリースです。

00:26:21.000 --> 00:26:25.000
今日取り上げたすべてのものに加えて、他にもたくさんの機能強化があります。

00:26:25.000 --> 00:26:32.000
そのため、すべての新しいマルチタスク機能を採用し、優れたキーボードサポートを構築しました。

00:26:32.000 --> 00:26:39.000
今、モハメッドは、あなたのiPadアプリを最高レベルに引き上げるためのいくつかの指針を提供します。

00:26:39.000 --> 00:26:42.000
モハメド・ジスラウィ:ありがとう、アナント!こんにちは、私はモハメッドです。

00:26:42.000 --> 00:26:48.000
iPadOS 15がシステムポインタにもたらす改善点について話しましょう。

00:26:48.000 --> 00:27:00.000
iPadOS 13.4は、iPadのタッチベースのUIとマウスやトラックパッドの精度を橋渡しするアダプティブシステムポインターを導入しました。

00:27:00.000 --> 00:27:08.000
ポインターインタラクションに慣れていない場合は、それらに慣れて、これらの以前のビデオをチェックしてください。

00:27:08.000 --> 00:27:13.000
「iPadOSポインタ用ビルド」は、ポインタインタラクションAPIを分解します。

00:27:13.000 --> 00:27:22.000
「Design for the iPadOS Pointer」は、その背後にあるデザイン哲学を掘り下げ、アプリに採用する際のベストプラクティスについて議論します。

00:27:22.000 --> 00:27:30.000
iPadOS 15は、iPadのデザイン言語と一致する方法で、おなじみのMacユーザーインタラクションをもたらします。

00:27:30.000 --> 00:27:37.000
また、使いやすさと明瞭さを高めるいくつかの新しい概念も紹介しています。

00:27:37.000 --> 00:27:48.000
これらの追加の最初のものは、バンド選択であり、Macを使用している人なら誰にでも馴染みのある新しいポインタ固有の複数選択体験です。

00:27:48.000 --> 00:28:00.000
iPadOS 15では、コレクションビューをクリックしてドラッグすると、ポインタが長方形に伸び、コレクションビューは長方形が包含するアイテムを選択します。

00:28:00.000 --> 00:28:06.000
もちろん、これはMac CatalystアプリのおなじみのMac UIに自然に翻訳されます。

00:28:06.000 --> 00:28:10.000
このインタラクションは、非リストのUICollectionViewsに組み込まれています。

00:28:10.000 --> 00:28:25.000
shouldBeginMultiple SelectionInteraction APIを介して既存の1本指と2本の指の複数選択ジェスチャーをサポートするUICollectionViewは、iPadOS 15でこの動作を自動的に取得します。

00:28:25.000 --> 00:28:35.000
UICollectionView以外では、新しいUIBandSelectionInteraction APIを使用すると、このエクスペリエンスをアプリで簡単に採用できます。

00:28:35.000 --> 00:28:46.000
選択ロジックは完全にあなた次第なので、カスタム選択動作をサポートし、選択した方法で変更された選択にUIを反応させることができます。

00:28:46.000 --> 00:28:56.000
開始するには、ポインタが移動し、インタラクションの状態が変更されるときに呼び出される選択ハンドラとのインタラクションをインスタンス化します。

00:28:56.000 --> 00:29:02.000
作成したら、他のUIInteractionと同様に、インタラクションをビューに追加します。

00:29:02.000 --> 00:29:11.000
ハンドラでは、インタラクションの状態と selectionRect の変更に応答することで、カスタム選択ロジックを実装できます。

00:29:11.000 --> 00:29:21.000
ここでは、ポインタが移動している間、インタラクションの選択Rect内の項目に選択を設定する簡単な実装があります。

00:29:21.000 --> 00:29:28.000
次に、プライマリマウスボタンが解放され、インタラクションが終了すると、選択セッションが終了します。

00:29:28.000 --> 00:29:37.000
基本的な選択に加えて、UICollectionViewの内蔵バンド選択は、箱から出してすぐにいくつかの一般的なキーボードショートカットをサポートしています。

00:29:37.000 --> 00:29:46.000
たとえば、ドラッグの開始時にShiftキーを押したままにすると、現在選択されているアイテムを置き換えるのではなく、既存の選択にアイテムが追加されます。

00:29:46.000 --> 00:29:51.000
コマンドを長押しすると、選択rect内の項目の選択状態が切り替えます。

00:29:51.000 --> 00:30:01.000
これは、ドラッグの開始時に保持されたキーを提供するインタラクションのinitialModifierFlagsプロパティを使用して、カスタムUIで実装できます。

00:30:01.000 --> 00:30:11.000
押されたすべての修飾子のセットであるため、任意のキーの組み合わせに応答して、アプリに固有のカスタムまたはより高度な動作をサポートできます。

00:30:11.000 --> 00:30:16.000
システムポインタへの2番目の追加は、アクセサリを取り付ける機能です。

00:30:16.000 --> 00:30:26.000
アクセサリは、二次形状とプライマリポインタを組み合わせることで、追加情報を伝達し、コンテキストのヒントを提供します。

00:30:26.000 --> 00:30:32.000
たとえば、左側の例では、2つの矢印は、このビューを水平にドラッグできることを示しています。

00:30:32.000 --> 00:30:39.000
右側の例では、プラスは、このカートに追加ボタンに追加のコンテキストを提供します。

00:30:39.000 --> 00:30:44.000
アクセサリーとカスタムポインタ形状の使用には、いくつかの重要な違いがあります。

00:30:44.000 --> 00:30:49.000
アクセサリーは視覚的に分離されており、メインポインタに二次的です。

00:30:49.000 --> 00:30:58.000
これは、それらが異なる外観でレンダリングされ、メインポインタとは別にアニメーション化される可能性があるという事実によって強調されています。

00:30:58.000 --> 00:31:06.000
それらは、異なるアイデアを伝えるためにポインターの周りに組み合わせて配置できる独立したユニットです。

00:31:06.000 --> 00:31:11.000
それらは独立しているので、どんなポインタースタイルとも組み合わせることができます。

00:31:11.000 --> 00:31:20.000
これは、同じアクセサリーセット（ドラッグ可能性を示す2つの矢印）を異なるポインタスタイルと組み合わせる方法のデモンストレーションです。

00:31:20.000 --> 00:31:28.000
左側では、ポインタがビューとマージして持ち上げるリフト効果と組み合わされています。

00:31:28.000 --> 00:31:37.000
真ん中には、ポインタが丸みを帯びた長方形に変わり、ビューの下に入るハイライト効果の横にあります。

00:31:37.000 --> 00:31:46.000
右側には、新しいUIPointerStyle.system() APIを使用してデフォルトのシステムポインタが表示されます。

00:31:46.000 --> 00:32:00.000
そのため、ポインタの活気を犠牲にすることなく、アプリのUIとの深い関係を維持しながら、状況に理想的な効果を使用しながら、この追加のコンテキストを提供することができます。

00:32:00.000 --> 00:32:09.000
ポインタースタイル間でアニメーション化するように、システムは自動的にアクセサリーの外観と消失をアニメーション化します。

00:32:09.000 --> 00:32:14.000
また、アクセサリーの形状と位置の間でシームレスにアニメーション化されます。

00:32:14.000 --> 00:32:19.000
与えられた効果がアクティブな間にアクセサリーを移行する行為は意味があります。

00:32:19.000 --> 00:32:26.000
このような移行は、基礎となるUIの状態や動作の変化を伝えるために使用できます。

00:32:26.000 --> 00:32:38.000
左側の例では、プラス記号から無記号への移行は、以前に可能だった操作がもはや許可されていないことを示している可能性があります。

00:32:38.000 --> 00:32:54.000
ポインターアクセサリーは、UIPointerShapeとUIPointerAccessory.Positionで構成され、所望の位置をポインターの中間点からのオフセットと上からの角度として記述します。

00:32:54.000 --> 00:33:00.000
便宜上、UIKitはポインタの周りの位置にいくつかの事前定義された値を提供します。

00:33:00.000 --> 00:33:08.000
事前定義されたポジションがニーズに合わない場合は、それらを出発点として使用し、個々のプロパティをカスタマイズできます。

00:33:08.000 --> 00:33:14.000
この例は、右上の位置から始まり、オフセットをカスタマイズします。

00:33:14.000 --> 00:33:23.000
この例のように、完全にカスタム位置を定義して、カスタムオフセットと角度で位置を作成することもできます。

00:33:23.000 --> 00:33:36.000
このセグメントの冒頭で見た例を設定するには、ビューでUITargetedPreviewを作成し、それを使用してリフト効果のあるUIPointerStyleを作成します。

00:33:36.000 --> 00:33:44.000
次に、スタイルの新しいアクセサリープロパティを、2つの矢印アクセサリーを含む配列に設定します。

00:33:44.000 --> 00:33:52.000
UIKitは既製の矢印アクセサリーを提供しているので、エフェクトの左側と右側に配置されたものを2つ作成できます。

00:33:52.000 --> 00:34:01.000
したがって、ポインタがこのビューの上にホバリングすると、ビューが上がると2つの矢印がアニメーション化し、ドラッグできることを示唆します。

00:34:01.000 --> 00:34:10.000
ポインタ効果を持つビューがドラッグ可能なこの種のインタラクションを実装しようとしたことがあるなら、おそらくこのようなことに気づいたことがあるでしょう。

00:34:10.000 --> 00:34:17.000
ポインタがポインタ領域の端に到達すると、持ち上げられたビューから切り離され、効果が終了します。

00:34:17.000 --> 00:34:25.000
これは、ポインタが移動中にビューに固執するのを防ぐため、通常は望ましいです。

00:34:25.000 --> 00:34:35.000
しかし、このようなシナリオでは、理想的な経験は、ポインタ効果が安定したままであり、ビューにラッチし、それが引きずられるにつれてそれに従うことです。

00:34:35.000 --> 00:34:43.000
この種のインタラクションをより有効にするために、iPadOS 15はUIPointerRegionでラッチAxesの概念を導入しています。

00:34:43.000 --> 00:34:51.000
領域が特定の軸に沿ってラッチすると、プライマリマウスボタンが押されたときに、そのポインタ効果は軸に沿ってポインタに従います。

00:34:51.000 --> 00:34:59.000
水平ラッチ領域を使用すると、y軸に沿ってゴムバンドをしながら、x軸に沿って自由にドラッグできます。

00:34:59.000 --> 00:35:04.000
垂直ラッチすると、y軸に沿って自由にドラッグできます。

00:35:04.000 --> 00:35:09.000
そして、両方に沿ってラッチする1つは、両方の軸に沿って自由にドラッグすることができます。

00:35:09.000 --> 00:35:14.000
これらの新しいツールは、いくつかの本当に強力な新しい経験を構築するために使用することができます。

00:35:14.000 --> 00:35:19.000
ここでは、PagesやKeynoteなどのドキュメント編集アプリに組み合わされています。

00:35:19.000 --> 00:35:23.000
この画像はバンド選択を使用して選択できます。

00:35:23.000 --> 00:35:35.000
画像を選択すると、ドラッグインジケーターが表示され、ポインジケーターにカーソルを合わせると、アクセサリは、ドラッグされた場合に画像がどのようにサイズ変更されるかを示唆して表示されます。

00:35:35.000 --> 00:35:43.000
そして最後に、ラッチにより、ポインタ効果とアクセサリは軸ロックされたサイズ変更ジェスチャーに従うことができます。

00:35:43.000 --> 00:35:48.000
これらは、iPadOS 15がiPadにもたらす機能強化のほんの一部です。

00:35:48.000 --> 00:35:52.000
アプリの有用性を最大限に高めるために、該当する場所でそれらを活用してください。

00:35:52.000 --> 00:35:58.000
目立つシーンを採用して、人々にアプリのコンテンツの集中的で途切れないビューを提供します。

00:35:58.000 --> 00:36:08.000
新しいキーボードショートカットメニューで複雑なタスクをすばやく達成できるようにし、新しいポインタ機能で生産性を向上させます。

00:36:08.000 --> 00:36:10.000
見てくれてありがとう!

00:36:10.000 --> 23:59:59.000
♪

