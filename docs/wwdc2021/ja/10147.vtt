WEBVTT

00:00:02.000 --> 00:00:13.000
こんにちは、GPUソフトウェアエンジニアリングチームのカイル・サナーと申します。

00:00:13.000 --> 00:00:21.000
同僚のアレックス・リーと一緒に、可変リフレッシュレートディスプレイでアプリで最適なフレームペーシングを取得する方法について話します。

00:00:21.000 --> 00:00:31.000
macOSに搭載される新しいディスプレイ技術、Adaptive-Sync、およびあらゆる条件下でiPad Proでカスタム描画をスムーズに駆動する方法に焦点を当てます。

00:00:31.000 --> 00:00:37.000
Appleプラットフォームで現在サポートされているディスプレイの種類の概要から始めます。

00:00:37.000 --> 00:00:49.000
MacのAdaptive-Syncディスプレイと、これらのディスプレイ上のフルスクリーンアプリやゲームでスムーズなフレームレートを提供するために使用できるmacOS Montereyの新しいツールを紹介します。

00:00:49.000 --> 00:01:01.000
次に、iPad ProのProMotionを深く掘り下げ、アプリが異なるフレームレートで正しいフレームペーシングを維持するのに役立つCADisplayLinkのベストプラクティスを見ていきます。

00:01:01.000 --> 00:01:06.000
まず、Appleのデバイスがサポートできるディスプレイの種類を確認しましょう。

00:01:06.000 --> 00:01:10.000
Appleシステムのほとんどのディスプレイは、固定のリフレッシュレートで動作します。

00:01:10.000 --> 00:01:16.000
つまり、電源を入れるたびに一貫した速度でリフレッシュします。

00:01:16.000 --> 00:01:22.000
例外は、iPadのProMotionディスプレイと、macOSのAdaptive-Syncディスプレイです。

00:01:22.000 --> 00:01:27.000
MacのAdaptive-Syncディスプレイの新機能について掘り下げてみましょう。

00:01:27.000 --> 00:01:32.000
Adaptive-Syncディスプレイとは何か、そしてそれらがMacでどのように機能するかから始めます。

00:01:32.000 --> 00:01:36.000
しかし、まず、固定レートディスプレイがどのように機能するかを簡単に見てみましょう。

00:01:36.000 --> 00:01:41.000
これは、フレームが60Hzのディスプレイに配信されていることを示す図です。

00:01:41.000 --> 00:01:47.000
各フレームはディスプレイに表示され、ディスプレイが更新されるまで16ミリ秒間滞在します。

00:01:47.000 --> 00:01:53.000
フレームバッファにMacによって描かれた新しいフレームがある場合は、その新しいフレームが表示されます。

00:01:53.000 --> 00:01:57.000
それ以外の場合は、前のフレームが再び表示されます。

00:01:57.000 --> 00:02:09.000
120Hzのディスプレイを見ると、リフレッシュレートを2倍にし、それによって各フレームが画面に表示される間隔を半分にしましたが、同じように、より速く動作することがわかります。

00:02:09.000 --> 00:02:12.000
一方、このAdaptive-Syncディスプレイを見てみましょう。

00:02:12.000 --> 00:02:18.000
静的な持続時間の代わりに、各フレームには画面に表示される時間のウィンドウがあります。

00:02:18.000 --> 00:02:21.000
このウィンドウは、付属のディスプレイによって異なります。

00:02:21.000 --> 00:02:31.000
このディスプレイは40〜120Hzの間で動作できます。つまり、フレームは8〜25msの任意の場所で画面に表示できます。

00:02:31.000 --> 00:02:41.000
最大時間が経過すると、システムはパネルを更新する必要があり、ディスプレイは短時間、新しい更新のために一時的に使用できなくなることに注意してください。

00:02:41.000 --> 00:02:46.000
さて、あなたのゲームやアプリはアダプティブ同期ディスプレイでどのような利点を得ることができますか?

00:02:46.000 --> 00:02:55.000
主にディスプレイの最大リフレッシュレートで実行されるアプリケーションの場合、Adaptive-Syncディスプレイは無料で大きな利点を提供します。

00:02:55.000 --> 00:03:05.000
まず、このシナリオを見てみましょう。アプリはほとんどの場合、8ms未満で新しいフレームを生成することができるため、120Hzでかなり確実に実行しています。

00:03:05.000 --> 00:03:14.000
しかし、シーンの複雑さが瞬間的に増加したため、完成したフレームは、前のフレームが最初に表示された後、フレームバッファ9msに着地します。

00:03:14.000 --> 00:03:21.000
固定フレームレートディスプレイでは、前のフレームは意図した8msではなく16msで表示されます。

00:03:21.000 --> 00:03:25.000
これにより、アプリに目に見えるヒッチが発生します。

00:03:25.000 --> 00:03:34.000
Adaptive-Syncディスプレイでは、フレームが完了した直後にディスプレイに表示されるため、アプリは1msのペナルティしか発生しません。

00:03:34.000 --> 00:03:38.000
この小さなヒッチは、一般的にユーザーには認識できません。

00:03:38.000 --> 00:03:48.000
ディスプレイの最大フレームレートに到達できないワークロードの場合、アプリが描画可能な表示方法にいくつかの小さな変更を加えることで、スムーズで均一なフレームを提供できます。

00:03:48.000 --> 00:03:55.000
このシナリオを考えてみましょう。複雑なシーンを実行するゲームは、約90Hzで更新を生成することができます。

00:03:55.000 --> 00:04:04.000
しかし、断続的な効果は複雑さの大きなジャンプを引き起こしますが、一貫性がなく、66Hzまでの突然のスパイクを引き起こします。

00:04:04.000 --> 00:04:14.000
アプリのGPU作業を監視することで、シーンの複雑さが一貫して低くなるまで、後で意図的にフレームを提示することで、この複雑さの急増に対応できます。

00:04:14.000 --> 00:04:18.000
さて、Adaptive-Syncのベストプラクティスについて話しましょう。

00:04:18.000 --> 00:04:32.000
固定レートディスプレイでは、アプリのGPU動作が一貫してディスプレイのオンガラス間隔を超える場合、以前はレンダリングを遅くして、ディスプレイの最速のリフレッシュレートの次の要因に達することを推奨していました。

00:04:32.000 --> 00:04:40.000
通常、この例のように、ターゲットフレーム/秒を60から30に下げることを意味します。

00:04:40.000 --> 00:04:44.000
ただし、Adaptive-Syncディスプレイに表示する場合は、そのガイダンスを変更します。

00:04:44.000 --> 00:04:50.000
代わりに、アプリが均等にできる最高のレートでフレームを表示しようとする必要があります。

00:04:50.000 --> 00:05:03.000
フレームを均等に表示することに加えて、フレームがディスプレイがサポートする最小レート未満で表示されている場合、新しいフレームでディスプレイが使用できなくなる可能性があり、アプリでジャダーを誘発する可能性があることを覚えておいてください。

00:05:03.000 --> 00:05:08.000
しかし、サポートされている範囲内にある限り、アプリに最適なレートを自由に選択できます。

00:05:08.000 --> 00:05:17.000
今年Macに搭載される新しいディスプレイサポートを高レベルで理解したので、ゲームでアダプティブシンクを有効にする方法について話しましょう。

00:05:17.000 --> 00:05:19.000
まず、サポートされているMacが必要です。

00:05:19.000 --> 00:05:27.000
Apple Silicon GPUを搭載したどのMacでもうまく機能し、最新のIntelベースのMacの多くもサポートしています。

00:05:27.000 --> 00:05:33.000
次に、サポートされているAdaptive-Syncディスプレイと、Adaptive-Syncモードを有効にする必要があります。

00:05:33.000 --> 00:05:40.000
これは、ディスプレイシステム環境設定で利用可能な新しい可変リフレッシュレートを選択することで実行できます。

00:05:40.000 --> 00:05:45.000
そして最後に、アプリはフルスクリーンモードで実行されている必要があります。

00:05:45.000 --> 00:05:52.000
Adaptive-Syncスケジューリングを行う必要があるかどうかを検出するために、アプリで呼び出すことができるAPIを見てみましょう。

00:05:52.000 --> 00:05:57.000
まず、実行しているディスプレイがAdaptive-Syncスケジューリングが可能かどうかを判断する必要があります。

00:05:57.000 --> 00:06:04.000
そのために、今年はNSScreen、minimumRefreshInterval、maximumRefreshIntervalにいくつかの新しいプロパティがあります。

00:06:04.000 --> 00:06:10.000
これらの値は、このディスプレイに表示されたフレームの有効な画面上の時間の範囲を示します。

00:06:10.000 --> 00:06:19.000
固定フレームディスプレイでは、これらの値は同じになるので、単純な不均等な比較で、この画面がAdaptive-Syncモードになっているかどうかがわかります。

00:06:19.000 --> 00:06:23.000
次に、ウィンドウが現在フルスクリーンであるかどうかを知る必要があります。

00:06:23.000 --> 00:06:27.000
ウィンドウのstyleMaskをチェックすることで、それを判断できます。

00:06:27.000 --> 00:06:35.000
また、アプリがAdaptive-Syncスケジューリングを活用できるように、これらのチェックの両方を組み合わせる必要があることを覚えておいてください。

00:06:35.000 --> 00:06:51.000
オーケー、いいね。だから、Adaptive-SyncディスプレイとmacOSがそれらを検出するために提供する新しいAPIのハンドルを手に入れたので、Adaptive-Syncディスプレイで均等に提示するために、既存の金属プレゼンテーション技術を適応させる方法を見てみましょう。

00:06:51.000 --> 00:07:01.000
presentAfterMinimumDurationやpresentAtTimeなど、フレームペーシングを内蔵したMetalDrawable APIを使用して、Adaptive-Syncディスプレイで大きな効果を発揮できます。

00:07:01.000 --> 00:07:07.000
または、プレゼントナウコールと独自のカスタムタイマーを使用して、独自のソリューションをロールすることができます。

00:07:07.000 --> 00:07:12.000
いくつかの異なる実装がどのように機能するかを見てみましょう。 

00:07:12.000 --> 00:07:15.000
簡単な例から始めます。

00:07:15.000 --> 00:07:21.000
ここでは、Drawableを取得し、GPU作業をセットアップし、画面に表示します。

00:07:21.000 --> 00:07:27.000
私たちは、フレームレートを設定するために利用可能なDrawableの背圧に依存しています。

00:07:27.000 --> 00:07:37.000
固定レートディスプレイでは、GPUの作業がディスプレイのリフレッシュレートに一致する保証がないため、これは最良のアイデアではないことを知っています。

00:07:37.000 --> 00:07:46.000
しかし、Adaptive-Syncディスプレイで撮影されたこの楽器キャプチャからわかるように、私たちのシーンが一貫しているとき、これはうまくいくようです。

00:07:46.000 --> 00:07:50.000
ここでの問題は、このシーンが定期的なヒッチに遭遇していることです。

00:07:50.000 --> 00:07:55.000
これらのヒッチは、ユーザーに見える吃音に変換されます。

00:07:55.000 --> 00:07:59.000
固定された均一なレートで提示することで、それを修正してみましょう。

00:07:59.000 --> 00:08:07.000
このテクニックは、ゲームのプレイヤーにユーザー調整可能なFPSスライダーを実装する場合にも使用できます。

00:08:07.000 --> 00:08:11.000
ここでは、必要な周波数を78Hzに設定しました。

00:08:11.000 --> 00:08:20.000
そして、プレーンな現在の呼び出しの代わりに、このDrawableにpresent afterMinimumDurationを使用し、上記で定義した間隔を指定します。

00:08:20.000 --> 00:08:24.000
そして、ここでは、私たちが要求した速度でスムーズに提示されたフレームを見ることができます。

00:08:24.000 --> 00:08:34.000
前の例ほど迅速に提示していませんが、ユーザーは吃音に遭遇する可能性がはるかに低く、アプリはCPUとGPUの時間を短縮します。

00:08:34.000 --> 00:08:38.000
さて、ここでは物事がもう少し面白くなります。

00:08:38.000 --> 00:08:44.000
単一の固定レートを設定することなく、均等なペースのフレームを生成するアプローチを試してみましょう。

00:08:44.000 --> 00:08:54.000
これを行う1つの方法は、各フレームを生成するために必要なGPU作業のローリング平均を計算し、その時間を現在のDrawableコールにフィードすることです。

00:08:54.000 --> 00:08:59.000
最初のフレームでは、平均GPU時間を開始値でロードする必要があります。

00:08:59.000 --> 00:09:04.000
私は楽観的であることを選択し、ディスプレイがここでサポートできる最速のレートをターゲットにするつもりです。

00:09:04.000 --> 00:09:10.000
これは私たちの平均の出発点にすぎないので、合理的な推測は問題ありません。

00:09:10.000 --> 00:09:20.000
次に、CommandBuffer完了ハンドラを添付して、GPUがこのフレームのレンダリングに費やした時間を測定し、その時間をローリング平均に組み込みましょう。

00:09:20.000 --> 00:09:24.000
まず、GPUが作業を完了するのにかかった時間を獲得できます。

00:09:24.000 --> 00:09:31.000
次に、その新しい時間を次のフレームを提示するときに使用されるローリング平均に組み込みます。

00:09:31.000 --> 00:09:33.000
そして、これが結果です。

00:09:33.000 --> 00:09:46.000
ご覧のとおり、前の例と同様のレートで提示していますが、この制限は生成した以前のフレームによって決定され、さまざまなMac GPUで均一なフレームレートを生成します。

00:09:46.000 --> 00:09:54.000
ここでは、追加のコードを変更することなく、あまり強力ではないMacで同じプログラムが48Hzでスムーズに実行されているのを見ることができます。

00:09:54.000 --> 00:10:01.000
さて、Adaptive-Syncディスプレイ用にアプリを最適化するために使用できる新しいツールとテクニックがいくつかあるようになりました。

00:10:01.000 --> 00:10:08.000
macOSのAdaptive-Syncディスプレイについてもっと知りたい場合は、Apple Developerサイトで新しいMetalサンプルプロジェクトをチェックしてください。

00:10:08.000 --> 00:10:15.000
メタルでパフォーマンス体験を提供することの詳細については、前年のWWDCトークをご覧ください。

00:10:15.000 --> 00:10:21.000
そして今、私はあなたをアレックスに引き渡します、そこであなたはiPad Proのフレームペーシングについてもっと学びます。

00:10:21.000 --> 00:10:22.000
ありがとう、カイル。

00:10:22.000 --> 00:10:25.000
次に、ProMotionについて話しましょう。

00:10:25.000 --> 00:10:33.000
2017年以来、すべてのiPad Proには、最大120Hzのリフレッシュレートを提供するProMotionディスプレイが搭載されています。

00:10:33.000 --> 00:10:44.000
ただし、ユーザーがiPadOS 15で今年iPadに持ち込まれた低電力モードをオンにした場合など、状況によっては120Hzが利用できない場合があります。

00:10:44.000 --> 00:10:53.000
適切なフレームペーシングにより、表示特性、ユーザーの好み、システムの状態に関係なく、アプリはモーションコンテンツを正確かつスムーズに表示できます。

00:10:53.000 --> 00:11:02.000
ProMotionと固定レートディスプレイの違いと、一部のフレームレートが利用できない状況を見ていきます。

00:11:02.000 --> 00:11:08.000
次に、表示リンクとは何か、アプリがそれを使用してカスタム描画を駆動する方法について説明します。

00:11:08.000 --> 00:11:13.000
そして最後に、いくつかのディスプレイリンクのベストプラクティスを提供します。

00:11:13.000 --> 00:11:15.000
すぐに飛び込みましょう。

00:11:15.000 --> 00:11:23.000
カイルが先に簡単に提示したように、固定60Hzディスプレイは16ミリ秒ごとに更新され、固定ケイデンスです。

00:11:23.000 --> 00:11:29.000
フレームレートが60の係数であるコンテンツのスムーズな表示をサポートします。

00:11:29.000 --> 00:11:34.000
例えば、60Hz、30Hz、20Hzなど。

00:11:34.000 --> 00:11:49.000
ただし、コンテンツがディスプレイのリフレッシュレート、例えば30Hzよりも遅い場合、ディスプレイ自体は同じケイデンスで更新する必要があります。したがって、他のすべてのフレームは以前のフレームの繰り返しであり、これはある程度の電力を消費します。

00:11:49.000 --> 00:11:56.000
一方、ProMotionは最大120Hzのリフレッシュレートで優れた応答性を提供します。

00:11:56.000 --> 00:12:01.000
また、画面上のコンテンツに適応するため、消費電力を削減します。

00:12:01.000 --> 00:12:03.000
それがどのように機能するか見てみましょう。

00:12:03.000 --> 00:12:10.000
もちろん、最大リフレッシュレートは120Hzで、ディスプレイは8ミリ秒ごとにリフレッシュされます。

00:12:10.000 --> 00:12:16.000
120は60の倍数であるため、ProMotionは既存のすべてのフレームレートをサポートしています。

00:12:16.000 --> 00:12:22.000
120Hzだけでなく、アプリの中間フレームレートも提供します。

00:12:22.000 --> 00:12:37.000
さらに、ProMotionはリフレッシュレートを動的に調整できるため、スムーズな60Hzのコンテンツを使用すると、繰り返しなしで16msごとにのみ更新できます。それ以外の場合は、固定120Hzディスプレイで必要になります。

00:12:37.000 --> 00:12:41.000
これは24Hzまでずっと当てはまります。

00:12:41.000 --> 00:12:44.000
さて、これらのフレームレートは必ずしも利用可能ではないかもしれません。

00:12:44.000 --> 00:12:51.000
ユーザーは、最大フレームレートを60Hzに制限するアクセシビリティ設定で、フレームレート制限トグルをオンにすることができます。

00:12:51.000 --> 00:12:58.000
また、デバイスが熱くなると、システムは120Hzの可用性に制限を適用する場合があります。

00:12:58.000 --> 00:13:04.000
iPadOS 15では、低電力モードで60Hzのキャップも適用します。

00:13:04.000 --> 00:13:07.000
では、これらのシナリオはアプリにどのように影響しますか?

00:13:07.000 --> 00:13:11.000
良いニュースは、ほとんどのアプリが変更なしで動作するということです。

00:13:11.000 --> 00:13:20.000
しかし、アプリがフレームごとのカスタム描画を実行する場合は、これらのフレームレートの変更に注意を払う必要があり、その方法を紹介します。

00:13:20.000 --> 00:13:28.000
カスタム描画を駆動するための推奨ツールは、基本的にディスプレイリフレッシュレートと同期するタイマーであるディスプレイリンクです。

00:13:28.000 --> 00:13:33.000
アプリがカスタムアニメーションやカスタムレンダリングループを駆動するのに役立ちます。

00:13:33.000 --> 00:13:34.000
表示リンクは2つあります。

00:13:34.000 --> 00:13:48.000
1つは、macOSのCoreVideoが提供するCVDisplayLinkで、もう1つは、他のプラットフォームでCoreAnimationが提供するCADisplayLinkと、macOSのCatalystで、それぞれがわずかに異なる特性と動作を持っています。

00:13:48.000 --> 00:13:55.000
今日は、CADisplayLinkについてのみ議論しますが、高いレベルでは、これらの概念は両方に適用されます。

00:13:55.000 --> 00:14:00.000
CADisplayLinkは、すべてのvsyncでウェイクアップし、コールバックを呼び出します。

00:14:00.000 --> 00:14:06.000
これにより、アプリケーションは作業を完了するために8ms全体を提供します。

00:14:06.000 --> 00:14:13.000
NSTimerなどの通常のタイマーは、ディスプレイと完全に同期する可能性は非常に低いです。

00:14:13.000 --> 00:14:23.000
位相から外れたり、ドリフトしたりする可能性があるため、アプリが作業を完了するのに十分な時間がなく、フレームドロップにつながることがあります。

00:14:23.000 --> 00:14:30.000
CADisplayLinkが一貫したタイミングを提供する方法を見ましたが、追加の利点をいくつか紹介します。

00:14:30.000 --> 00:14:42.000
ディスプレイのリフレッシュレートよりも遅い速度で実行できるため、アプリはpreferredFramesPerSecondを介してヒントを提供し、最も近いフレームレートを選択します。

00:14:42.000 --> 00:14:50.000
先に説明したように、フレームレートの可用性が変更されると、CADisplayLinkは自動的にボンネットの下でレートを調整します。

00:14:50.000 --> 00:14:57.000
もちろん、カスタム図面がこれらの変更を認識できるように、必要なタイミング情報をアプリにも提供します。

00:14:57.000 --> 00:15:11.000
カスタムアニメーションやカスタムレンダリングループの書き方については取りませんが、カスタム描画がディスプレイのタイミングと同期し、一般的な落とし穴を回避するための4つのベストプラクティスを提供します。

00:15:11.000 --> 00:15:17.000
まず、ハードコーディングするのではなく、実行時にディスプレイのリフレッシュレートを照会することが重要です。

00:15:17.000 --> 00:15:23.000
第二に、通常、CADisplayLink自体のフレームレートを使用する必要があります。

00:15:23.000 --> 00:15:28.000
次に、targetTimestampを使用して図面を準備すると、ヒッチを減らすのに役立ちます。

00:15:28.000 --> 00:15:35.000
最後に、時間デルタを動的に計算することで、予期せぬ事態に備えることは常に良い考えです。

00:15:35.000 --> 00:15:37.000
それらを一つずつ見てみましょう。

00:15:37.000 --> 00:15:50.000
最大ディスプレイリフレッシュレートは、低電力モードがオンになっているなどの状況でも、ProMotionディスプレイで常に120Hzを返すUIScreenを介して照会できます。

00:15:50.000 --> 00:16:01.000
一方、CADisplayLinkは実際には期間プロパティを介してフレーム間の最短間隔を提供し、現在のデバイスの状態に基づいて動的に更新されます。

00:16:01.000 --> 00:16:11.000
しかし、ほとんどの場合、表示リンクは最大表示リフレッシュレートよりも遅くなる可能性があるため、CADisplayLinkから直接実際のフレーム情報を使用する必要があります。

00:16:11.000 --> 00:16:23.000
また、フレームレートの可用性はハードウェアに依存し、実際のフレームレートは、システム状態の変化に応じて表示リンク自体によって動的に変更される可能性があります。

00:16:23.000 --> 00:16:25.000
例を見てみましょう。 例を見てみましょう。

00:16:25.000 --> 00:16:27.000
40Hzのディスプレイリンクを要求したとします。

00:16:27.000 --> 00:16:32.000
ご覧のとおり、ProMotionディスプレイでは40Hzがサポートされています。

00:16:32.000 --> 00:16:41.000
ただし、60Hzのディスプレイ、またはProMotionが60Hzに制限されている場合、ディスプレイリンクは自動的に30Hzに調整されます。

00:16:41.000 --> 00:16:49.000
これにより、各ウェイクアップが可能なvsyncにあり、各フレームに同じ時間を与えようとする良好なケイデンスが保証されます。

00:16:49.000 --> 00:17:05.000
フレームレートを認識していないプレーンな40Hz NSTimerを使用する場合、そのウェイクアップはvsync間隔のちょうど真ん中にある可能性があり、もちろん、そこにフレームを提示することはできないので、カスタム図面でヒッチを観察する可能性があります。

00:17:05.000 --> 00:17:07.000
では、コードではどのように見えますか?

00:17:07.000 --> 00:17:11.000
さて、これは通常、表示リンクを設定する方法です。

00:17:11.000 --> 00:17:16.000
まず、呼び出されるコールバックであるターゲットとセレクタを指定する必要があります。

00:17:16.000 --> 00:17:22.000
次に、preferredFramesPerSecondを介して40Hzの優先フレームレートをヒントします。

00:17:22.000 --> 00:17:28.000
次に、現在のランループに表示リンクを追加し、そこからコールバックが呼び出されます。

00:17:28.000 --> 00:17:35.000
したがって、コールバックでは、targetTimestampからタイムスタンプを差し引くことで、表示リンクのウェイクアップ間の予想される間隔を取得できます。

00:17:35.000 --> 00:17:43.000
この間隔は、表示リンク自体が異なる周波数で実行されている可能性があるため、必ずしも40以上の1とは限りません。

00:17:43.000 --> 00:17:46.000
次に、これらのタイムスタンプについて話しましょう。

00:17:46.000 --> 00:17:58.000
CADisplayLinkには主に2つのタイムスタンプがあり、コールバックが呼び出される予定の時刻を示すTimestampと、次のフレームがCoreAnimationによって合成されるtargetTimestampがあります。

00:17:58.000 --> 00:18:05.000
図面を準備するためにtargetTimestampを使用する理由を説明する例を見ていきます。

00:18:05.000 --> 00:18:10.000
これは、0から1までの正規化された時間領域のアニメーションです。

00:18:10.000 --> 00:18:16.000
可能な限り最高のフレームレートをターゲットにしており、現在は120Hzであるとします。

00:18:16.000 --> 00:18:29.000
CADisplayLinkが目を覚まし、タイムスタンプを使用してフレームプレゼンテーションを準備する場合は、ここで直接サンプリングし、次のvsyncで提示され、ここにあります。

00:18:29.000 --> 00:18:39.000
同じプロセスが続いており、120Hzフレームごとにアニメーションの進行が0.05増加する良いケイデンスがあることがわかります。

00:18:39.000 --> 00:18:45.000
さて、熱状態が変化し、120Hzが使用できなくなったとします。

00:18:45.000 --> 00:18:57.000
これで、表示リンクが再び起動し、アプリは進行状況0.4でアニメーションを準備し、次のvsyncでここで表示されます。

00:18:57.000 --> 00:18:59.000
そして、同じパターンが続きます。

00:18:59.000 --> 00:19:02.000
ここの移行では何かが正しくありません。

00:19:02.000 --> 00:19:11.000
進歩は0.05増加しますが、1つは8ミリ秒を超え、もう1つは16ミリ秒を超えています。

00:19:11.000 --> 00:19:23.000
時間に対して進捗状況をプロットすると、トランジションでしゃっくりが表示されることは非常に明確であり、これはユーザーが知覚できるヒッチとして反映され、それは望ましくありません。

00:19:23.000 --> 00:19:26.000
では、targetTimestampを試してみましょう。

00:19:26.000 --> 00:19:28.000
CADisplayLinkはここで目を覚ます。

00:19:28.000 --> 00:19:33.000
進捗状況はtargetTimestampでサンプリングされ、0.15になります。

00:19:33.000 --> 00:19:38.000
同じパターンが続き、再び、私たちは良いケイデンスを見ます。

00:19:38.000 --> 00:19:46.000
このフレームレート遷移ポイントでは、表示リンクが起動し、targetTimestampでサンプリングされ、0.50になります。

00:19:46.000 --> 00:19:49.000
そして、それは同じように続きます。

00:19:49.000 --> 00:19:58.000
同じ進行状況と時間グラフをプロットすると、それが直線であることがわかります。したがって、フレームレートが変化してもスムーズなコンテンツを提供します。

00:19:58.000 --> 00:20:04.000
したがって、図面を準備するには、タイムスタンプではなくtargetTimestampを使用する必要があります。

00:20:04.000 --> 00:20:12.000
コードでは、通常、タイムスタンプの使用をtargetTimestampに置き換えるのと同じくらい簡単です。

00:20:12.000 --> 00:20:16.000
最後に、時間デルタの動的計算について話しましょう。

00:20:16.000 --> 00:20:26.000
targetTimestampとtimestampの違いは、表示リンクコールバック間の予想される時間を示しますが、実際の時間は保証されていません。

00:20:26.000 --> 00:20:32.000
より優先度の高いスレッドがCPUでスケジュールされているか、ランループが何か他のものでビジーである可能性があります。

00:20:32.000 --> 00:20:44.000
極端な場合、コールバックは完全にスキップされる可能性があるため、このような状況では、最高のユーザーエクスペリエンスのためにカスタム図面で正しいタイミングを維持することが特に重要です。

00:20:44.000 --> 00:20:52.000
CADisplayLinkコールバックが呼び出されると、アプリは次のフレームに必要な更新またはレンダリングを準備する作業を実行します。

00:20:52.000 --> 00:20:58.000
通常、コールバックは予定された起床時間に呼び出されますが、そうではありません。

00:20:58.000 --> 00:21:00.000
次のコールバックがここで呼び出されることを期待しています。

00:21:00.000 --> 00:21:07.000
ただし、表示リンクは、vsync間隔に数ミリ秒まで実行される機会がありません。

00:21:07.000 --> 00:21:10.000
したがって、あなたは完全な8msを得ることはできません。

00:21:10.000 --> 00:21:18.000
この場合、CACurrentMediaTimeを照会し、targetTimestampと比較して、利用可能な時間を取得できます。

00:21:18.000 --> 00:21:22.000
さて、このフレームで作業に時間がかかりすぎるとします。

00:21:22.000 --> 00:21:26.000
ランループが再び自由になるまで、次のコールバックは呼び出されません。

00:21:26.000 --> 00:21:48.000
これは遅れているため、次のコールバックはスキップされるため、このコールバックでカスタム描画の進捗状況を進める準備をしているときは、カスタム描画状態が更新された以前のタイムスタンプを追跡する場合は、使用すべき時間デルタが8msではなく、16msであることに注意してください。

00:21:48.000 --> 00:21:58.000
したがって、アプリがタイムデルタを使用してカスタム描画の状態を進めると、カルバックがスキップされるたびにカスタム描画が1フレーム遅くなります。

00:21:58.000 --> 00:22:04.000
代わりに、以前のtargetTimestampを追跡して、状態を正しく進めることができます。

00:22:04.000 --> 00:22:13.000
また、カスタム図面の作業負荷が高い場合は、targetTimestampを見て、必要に応じて締め切りに間に合うように作業負荷を軽減することができます。

00:22:13.000 --> 00:22:17.000
ベストプラクティスを要約するために、ディスプレイのリフレッシュレートを推測しないでください。

00:22:17.000 --> 00:22:19.000
常に実行時にそれを照会します。

00:22:19.000 --> 00:22:26.000
カスタム図面は、サポートされているフレームレートで柔軟で、異なるレートに適応する準備ができている必要があります。

00:22:26.000 --> 00:22:36.000
targetTimestampを使用して、ヒッチのないフレームレートの移行を確保し、表示リンクコールバックを逃したなど、予期しない状況に目を離さないようにします。

00:22:36.000 --> 00:22:38.000
では、締めくくりましょう。

00:22:38.000 --> 00:22:46.000
このセッションの前半では、macOSのAdaptive-Syncディスプレイで実行しているときに、アプリのフレームペーシングを最適化する方法について議論しました。

00:22:46.000 --> 00:22:58.000
後半では、iPad ProのProMotionディスプレイで、アプリがカスタム描画を推進し、あらゆる条件下でスムーズなフレームペースを維持するためのベストプラクティスについて説明しました。

00:22:58.000 --> 00:23:10.000
ディスプレイ技術が進化し続けるにつれて、このセッションが洞察だけでなく、ディスプレイのますますダイナミックなタイミングをサポートするためのツールやベストプラクティスも提供してくれることを願っています。

00:23:10.000 --> 00:23:15.000
ご参加いただきありがとうございます。WWDC 2021の残りの部分をお楽しみください。

00:23:15.000 --> 23:59:59.000
[音楽]。

