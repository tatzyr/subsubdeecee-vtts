WEBVTT

00:00:02.000 --> 00:00:11.000
こんにちは、私はゲームセンターチームのハリソンです。

00:00:11.000 --> 00:00:15.000
あなたのゲームで定期的なリーダーボードを使用することについて学ぶために参加してくれてありがとう。

00:00:15.000 --> 00:00:20.000
Game Centerは、プレイヤーが多くのゲームでデータにアクセスするために使用できる便利なアイデンティティを提供します。

00:00:20.000 --> 00:00:28.000
開発者として、Game Centerでは、アチーブメント、マルチプレイヤー、リーダーボードなどの機能を簡単に追加できます。

00:00:28.000 --> 00:00:32.000
これはコードアロングなので、参加するには初期設定を行う必要があります。

00:00:32.000 --> 00:00:39.000
次に、Game Centerのリーダーボードタイプを簡単に要約し、提供されたサンプルゲームについて説明します。

00:00:39.000 --> 00:00:46.000
最後に、App Store Connectに定期的なリーダーボードを追加し、サンプルゲームで使用するいくつかの異なる方法を紹介します。

00:00:46.000 --> 00:00:49.000
いくつかのセットアップから始めましょう。

00:00:49.000 --> 00:00:54.000
始めるために、開発者ポータルでXcode 13と互換性のあるプロジェクトを提供しました。

00:00:54.000 --> 00:00:58.000
ビデオを一時停止して今すぐダウンロードすることをお勧めします。

00:00:58.000 --> 00:01:04.000
ダウンロードしたら、再開して、初期設定をご案内します。

00:01:04.000 --> 00:01:07.000
ダウンロードしたフォルダには、The CoastというXcodeプロジェクトがあります。

00:01:07.000 --> 00:01:10.000
さあ、今すぐ開けてください。

00:01:10.000 --> 00:01:15.000
Game Centerの機能を使用するようにこのアプリを変更するので、チームに登録する必要があります。

00:01:15.000 --> 00:01:19.000
必要に応じて一時停止して、フォローしてください。

00:01:19.000 --> 00:01:24.000
まず、プロジェクトナビゲーターからTheCoastプロジェクトファイルを選択します。

00:01:24.000 --> 00:01:29.000
次に、ターゲットのリストからTheCoastを選択します。

00:01:29.000 --> 00:01:33.000
[署名と機能] ペインで、チームメニューからチームを選択します。

00:01:33.000 --> 00:01:40.000
Apple IDまたはチームがメニューにない場合は、まず「アカウントを追加」を選択し、Apple ID情報を入力します。

00:01:40.000 --> 00:01:43.000
次に、バンドルIDを一意の識別子に設定します。

00:01:43.000 --> 00:01:46.000
続行するには、バンドルIDを変更する必要があります。

00:01:46.000 --> 00:01:50.000
プロンプトが表示されたら、[デバイスの登録]をクリックしてプロビジョニングプロファイルを作成します。

00:01:50.000 --> 00:01:56.000
登録に成功すると、ステータスの下に警告は表示されません。

00:01:56.000 --> 00:02:01.000
選択したバンドルIDが登録されたので、App Store Connectにアプリレコードを追加できます。

00:02:01.000 --> 00:02:07.000
App Store Connectの右上隅で、バンドルIDの登録時に使用したチームを選択します。

00:02:07.000 --> 00:02:11.000
次に、「マイアプリ」セクションに移動します。

00:02:11.000 --> 00:02:17.000
左上隅のプラスボタンをクリックし、新しいアプリを選択します。

00:02:17.000 --> 00:02:22.000
iOSのみのアプリで作業するので、プラットフォームとしてiOSを選択してください。

00:02:22.000 --> 00:02:26.000
適切な名前、主要言語、SKUを選択してください。

00:02:26.000 --> 00:02:30.000
バンドルIDについては、Xcodeに登録したバンドルIDを選択してください。

00:02:30.000 --> 00:02:36.000
すべての必須フィールドに入力したら、[作成] を選択してアプリレコードを追加します。

00:02:36.000 --> 00:02:38.000
あなたは少し後でApp Store Connectに戻ってきます。

00:02:38.000 --> 00:02:43.000
しかし、今、私はリーダーボードの簡単な要約を与えるつもりです。

00:02:43.000 --> 00:02:48.000
すべてのリーダーボードでは、プレイヤーは世界中の友人やプレイヤーに対してどれだけうまくランク付けされているかを見ることができます。

00:02:48.000 --> 00:02:54.000
私たちのリーダーボードの種類は、主にリーダーボードがアクティブである期間によって異なります。

00:02:54.000 --> 00:02:57.000
古典的なリーダーボードは常にアクティブで、終わりはありません。

00:02:57.000 --> 00:03:02.000
彼らは、毎週および毎日のランキングだけでなく、オールタイムのランキングを維持しています。

00:03:02.000 --> 00:03:10.000
獲得した合計経験ポイントや現在のコイン数など、累積スコアに特に役立ちます。

00:03:10.000 --> 00:03:18.000
一方、定期的なリーダーボードは、5分ごとや30日ごとなど、開発者が定義したスケジュールで繰り返される短命のリーダーボードです。

00:03:18.000 --> 00:03:28.000
現在アクティブなリーダーボードのオカレンスを取得できます。また、終了時間から最大30日間、プレイヤーが提出した最新のオカレンスを取得することもできます。

00:03:28.000 --> 00:03:36.000
定期的なリーダーボードは、毎週日曜日の正午に1時間のチャレンジや毎週新しいリーダーボードなど、定期的なタイミングのイベントに役立ちます。

00:03:36.000 --> 00:03:41.000
セッション中に定期的なリーダーボードの特定のユースケースを強調します。

00:03:41.000 --> 00:03:44.000
しかし、まず、Xcodeで開いたプロジェクトに戻りましょう。

00:03:44.000 --> 00:03:50.000
iOSデバイスまたはシミュレーターで構築して実行します。

00:03:50.000 --> 00:03:53.000
これはザ・コーストのタイトル画面です。

00:03:53.000 --> 00:03:56.000
今のところ、この画面にはゲームを開始するボタンがあるだけです。

00:03:56.000 --> 00:03:58.000
先に進んで「PLAY」をタップします。

00:03:58.000 --> 00:04:04.000
ゲームプレイはかなり簡単です:船を見たら、それをタップしてポイントを取得します。

00:04:04.000 --> 00:04:06.000
各セッションは60秒続きます。

00:04:06.000 --> 00:04:11.000
最後に、再試行するか、タイトル画面に戻るかを選択できます。

00:04:11.000 --> 00:04:16.000
右上隅のメニューボタンを選択すると、早めに終了できます。

00:04:16.000 --> 00:04:21.000
では、これはどのように実装されていますか?

00:04:21.000 --> 00:04:24.000
始めるべき主なクラスをいくつか強調します。

00:04:24.000 --> 00:04:28.000
TitleScreenViewControllerはタイトル画面を担当します。

00:04:28.000 --> 00:04:31.000
しばらくすると、Game Centerで認証するために使用されます。

00:04:31.000 --> 00:04:38.000
今のところ、主にPLAYボタンがタップされたときにGameViewControllerを表示する責任があります。

00:04:38.000 --> 00:04:41.000
GameViewControllerはとてもシンプルです。

00:04:41.000 --> 00:04:49.000
ビューがロードされると、GameSceneと呼ばれるSpriteKitシーンが表示され、タイトル画面に戻るためのendGameというデリゲートメソッドがあります。

00:04:49.000 --> 00:04:54.000
すべてのゲームプレイロジックを管理するGameSceneを見てみましょう。

00:04:54.000 --> 00:04:58.000
提示されると、いくつかのSpriteKitノードが設定されます。

00:04:58.000 --> 00:05:02.000
1つは、背景画像で作成されたノードです。

00:05:02.000 --> 00:05:07.000
これはデバイスの画面サイズに基づいてスケーリングされ、他のすべてのノードが子として追加されます。

00:05:07.000 --> 00:05:15.000
もう1つは、現在のスコアを表示する画面の左上に配置されたSKLabelNodeであるscoreLabelです。

00:05:15.000 --> 00:05:23.000
最後はCountdownNodeで、プレイヤーに残り時間を示し、時間が終わったらGameSceneに通知します。

00:05:23.000 --> 00:05:31.000
これらのノードを追加すると、setupBoatNodeWithActions()メソッドが呼び出されます。

00:05:31.000 --> 00:05:39.000
これにより、セッション中にボートスプライトをフェードインおよびフェードアウトする一連のSpriteKitアクションが開始されます。

00:05:39.000 --> 00:05:46.000
touchesEndedメソッドは、タップしたときにこれらのボートスプライトを削除し、スコアをインクリメントするためにオーバーライドされます。

00:05:46.000 --> 00:05:57.000
カウントダウンの最後に、timeIsUpメソッドでは、すべてのノードがバックグラウンドから削除され、最終スコアのメニューが表示されます。

00:05:57.000 --> 00:06:05.000
定期的なリーダーボードを活用して、プレイヤーのコーストの経験を向上させる方法はたくさんありますが、今日は3つに焦点を当てます。

00:06:05.000 --> 00:06:14.000
まず、24時間の定期的なリーダーボードを作成して毎日の競争を確立する方法と、Game CenterのデフォルトのリーダーボードUIにリンクする方法を紹介します。

00:06:14.000 --> 00:06:21.000
これはおそらく定期的なリーダーボードを追加する最も簡単な方法であり、プレイヤーが他の人に対してどのように積み重なるかを知るための素晴らしい方法です。

00:06:21.000 --> 00:06:27.000
毎日のケイデンスは、誰もがトップの座を獲得する新鮮な機会を持つことを保証します。

00:06:27.000 --> 00:06:31.000
次に、ゲームプレイ中にライブランキングを表示します。

00:06:31.000 --> 00:06:38.000
これは、プレイヤーが彼らがどれだけうまくやっているか、そして彼らがトップの座にどれだけ近づいているかをリアルタイムで見ることができるので、ゲームに多くの興奮を追加します。

00:06:38.000 --> 00:06:45.000
最後に、現在および以前の出来事のランクを使用して、プレイヤーが時間の経過とともにどのように変化しているかを示します。

00:06:45.000 --> 00:06:49.000
これは、プレイヤーにゲームの進歩感を与える本当に簡単な方法です。

00:06:49.000 --> 00:06:51.000
始めましょう。

00:06:51.000 --> 00:06:55.000
先ほど、毎日の定期的なリーダーボードを使用すると述べました。

00:06:55.000 --> 00:06:59.000
ゲームでリーダーボードを使用する前に、App Store Connectで設定する必要があります。

00:06:59.000 --> 00:07:04.000
今すぐSafariでそれを引き上げて、アプリを開いてください。

00:07:04.000 --> 00:07:07.000
[機能] タブに移動し、Game Center が選択されていることを確認します。

00:07:07.000 --> 00:07:14.000
次に、リーダーボードの横にあるプラスボタンをクリックし、定期的なリーダーボードオプションを選択します。

00:07:14.000 --> 00:07:18.000
クラシックリーダーボードとリクリーダーボードの両方に、設定するこれらの6つのフィールドがあります。

00:07:18.000 --> 00:07:21.000
リーダーボードの参照名は、App Store Connectで内部的に使用されています。

00:07:21.000 --> 00:07:24.000
「DailyHighScore」のような説明的なものを選んでください。

00:07:24.000 --> 00:07:28.000
リーダーボードIDは、アプリ内のリーダーボードを参照するために使用されます。

00:07:28.000 --> 00:07:34.000
簡単にするために、参照名に使用したのと同じ説明値を使用します。

00:07:34.000 --> 00:07:38.000
スコアフォーマットタイプは、Game Center UIでスコアがどのようにフォーマットされるかを決定します。

00:07:38.000 --> 00:07:44.000
コーストのスコアは単なる整数ですが、他のゲームは時間やお金を使うかもしれません。

00:07:44.000 --> 00:07:53.000
プレイヤーが同じリーダーボードに複数のスコアを提出した場合、スコア提出タイプは、どちらがランク付けされるかを決定します。最高のスコアまたは最新のスコアです。

00:07:53.000 --> 00:07:59.000
その日のプレーヤーの最高スコアを記録したいので、コーストに最適です。

00:07:59.000 --> 00:08:03.000
ソート順は、プレイヤーのスコアが互いにどのようにランク付けされるかを決定します。

00:08:03.000 --> 00:08:07.000
コーストでは、ハイスコアの方が良いので、高から低を選択してください。

00:08:07.000 --> 00:08:10.000
オプションで有効なスコアの範囲を定義できます。

00:08:10.000 --> 00:08:14.000
その範囲外のスコアは拒否されます。

00:08:14.000 --> 00:08:17.000
これは不正行為に対する緩和策として役立ちます。

00:08:17.000 --> 00:08:24.000
プレイヤーがその範囲外で得点することを合理的に期待していないので、最小0と最大200を設定するつもりです。

00:08:24.000 --> 00:08:28.000
定期的なリーダーボードには、これらの追加の必須フィールドがあります。

00:08:28.000 --> 00:08:33.000
開始日時は、リーダーボードが最初に発生した日時をUTCで設定します。

00:08:33.000 --> 00:08:42.000
過去のスタートは選択できないので、すぐにリーダーボードを使い始めることができるように、1分のように、近い将来の日付と時刻を選択してください。

00:08:42.000 --> 00:08:46.000
期間は、スコアをリーダーボードに投稿できる時間の長さです。

00:08:46.000 --> 00:08:51.000
もちろん、これは毎日のリーダーボードの1日です。

00:08:51.000 --> 00:08:56.000
Restarts Everyは、リーダーボードの新しい出現が作成される頻度を指定します。

00:08:56.000 --> 00:09:02.000
発生が重複しないように、頻度は持続時間以上である必要があります。

00:09:02.000 --> 00:09:09.000
海岸は発生間のギャップを必要としないので、これを期間に等しく設定してください。

00:09:09.000 --> 00:09:13.000
以下は、これらのフィールドがどのように相互作用して発生を生み出すかを示す図です。

00:09:13.000 --> 00:09:19.000
選択した開始日、例えば6月11日午前9時に、オカレンスが作成されます。

00:09:19.000 --> 00:09:24.000
設定された期間のため、この発生に1日提出できます。

00:09:24.000 --> 00:09:32.000
その発生が期限切れになった直後の6月12日午前9時に、再起動が期間と一致するように設定されているため、新しい発生が作成されます。

00:09:32.000 --> 00:09:36.000
このプロセスは無期限に続きます。

00:09:36.000 --> 00:09:40.000
最後に設定するのはローカリゼーション情報です。

00:09:40.000 --> 00:09:44.000
リーダーボードは、Game Center UIに正しく表示するためにこれが必要です。

00:09:44.000 --> 00:09:46.000
少なくとも1つの言語を設定する必要があります。

00:09:46.000 --> 00:09:50.000
私は英語のために設定するつもりです。

00:09:50.000 --> 00:09:54.000
毎日のリーダーボードの「デイリーハイスコア」など、適切な表示名を選択してください。

00:09:54.000 --> 00:09:57.000
また、スコア形式を選択する必要があります。

00:09:57.000 --> 00:10:01.000
整数型の場合、ピリオドまたはカンマを数千の区切り文字として使用できます。

00:10:01.000 --> 00:10:04.000
あなたの言語に意味のあるものを選んでください。

00:10:04.000 --> 00:10:09.000
スコア形式の接尾辞は、ポイントやヒットなど、スコアの単位を指定する方法です。

00:10:09.000 --> 00:10:12.000
私は海岸のためにこれを空白のままにするつもりです。

00:10:12.000 --> 00:10:19.000
リーダーボードの画像はオプションですが、Game Center UIでゲームの外観をカスタマイズできるため、お勧めです。

00:10:19.000 --> 00:10:24.000
プロジェクトのアセットディレクトリには、leaderboardImageという名前の画像があります。

00:10:24.000 --> 00:10:26.000
それをアップロードしてください。

00:10:26.000 --> 00:10:31.000
リーダーボードを保存したら、Game Centerで認証してゲームで使用できます。

00:10:31.000 --> 00:10:35.000
では、Game Center認証を有効にすることから始めましょう。

00:10:35.000 --> 00:10:42.000
TitleScreenViewController には、authenticateLocalPlayer() というメソッドがあり、本文はコメントアウトされています。

00:10:42.000 --> 00:10:44.000
どうぞ、コメントを外してください。

00:10:44.000 --> 00:10:52.000
このコードは、ローカルプレーヤーの認証ハンドラを設定し、開始時にGame Centerのログインフローをトリガーします。

00:10:52.000 --> 00:10:56.000
詳細情報が必要な場合は、提供されたドキュメントへのリンクをたどってください。

00:10:56.000 --> 00:10:58.000
これで、スコアを提出できます。

00:10:58.000 --> 00:11:04.000
先ほど、タッチ終了時にスコアを更新するGameSceneで、touchsEndedと呼ばれる方法を紹介しました。

00:11:04.000 --> 00:11:11.000
それに移動します。

00:11:11.000 --> 00:11:13.000
submitScoreには2つのメソッドがあります。

00:11:13.000 --> 00:11:16.000
1つはクラスメソッドで、もう1つはインスタンスメソッドです。

00:11:16.000 --> 00:11:22.000
クラスメソッドに提出すると、現在アクティブなイベントが何であれ、提出が送信されます。

00:11:22.000 --> 00:11:25.000
アクティブな発生がない場合にのみ失敗します。

00:11:25.000 --> 00:11:34.000
インスタンスメソッドを使用するには、まず現在の発生を表すGKLeaderboardをロードします。

00:11:34.000 --> 00:11:49.000
次に、完了ハンドラでスコアを送信すると、その発生がまだアクティブである場合にのみ成功します。

00:11:49.000 --> 00:11:54.000
1時間ごとの定期的なリーダーボードを使用して、1時間ごとにユニークなチャレンジを提供するゲームを考えてみましょう。

00:11:54.000 --> 00:12:03.000
プレイヤーのデバイスとサーバー間のネットワーク遅延など、1つのチャレンジのスコアが次のチャレンジの発生に漏れることを望まないでしょう。

00:12:03.000 --> 00:12:06.000
インスタンスの送信スコアメソッドは、それが起こらないことを保証します。

00:12:06.000 --> 00:12:13.000
コーストの毎日のリーダーボードは特定のゲームセッションに結びついていないので、どのような出来事がスコアを受け取るかは関係ありません。

00:12:13.000 --> 00:12:34.000
クラスメソッドを使いましょう。

00:12:34.000 --> 00:12:38.000
これで、スコアは現在アクティブなリーダーボードの出現に提出されます。

00:12:38.000 --> 00:12:41.000
コンテキストを0に設定していることに注意してください。

00:12:41.000 --> 00:12:46.000
コンテキストを使用して、ゲーム固有の情報をエンコードし、スコアとともに保存できます。

00:12:46.000 --> 00:12:50.000
コーストの場合、スコアは追加のコンテキストを必要としません。

00:12:50.000 --> 00:12:57.000
毎日のリーダーボードに提出したので、タイトル画面からGame Center UIのリーダーボードを表示するボタンを追加しましょう。

00:12:57.000 --> 00:13:04.000
まず、TitleScreenViewControllerに向かいます。

00:13:04.000 --> 00:13:12.000
新しいIBActionメソッドを作成する必要があります。

00:13:12.000 --> 00:13:19.000
それをshowLeaderboardVCと呼んでください。

00:13:19.000 --> 00:13:29.000
GKGameCenterViewControllerをインスタンス化します。

00:13:29.000 --> 00:13:45.000
LeaderboardID、playerScope--私はglobalを使っています--とtimeScopeを渡します。

00:13:45.000 --> 00:13:53.000
定期的なリーダーボードの場合、timeScopeはallTimeでなければなりません。

00:13:53.000 --> 00:14:01.000
gameCenterDelegateを「self」に設定します。

00:14:01.000 --> 00:14:11.000
それから、それを提示してください。

00:14:11.000 --> 00:14:23.000
また、UIButtonを作成する必要があります。

00:14:23.000 --> 00:14:30.000
私はちょうど私のリーダーボードボタンを呼んでいます。

00:14:30.000 --> 00:14:36.000
次に、メインストーリーボードですべてを配線します。

00:14:36.000 --> 00:14:41.000
アセットディレクトリで使用するリーダーボードグリフを提供しました。

00:14:41.000 --> 00:14:43.000
その画像を含むボタンを追加し、テキストを削除します。

00:14:43.000 --> 00:14:52.000
グリフが引き伸ばされないように、アスペクト比の制約を設定します。

00:14:52.000 --> 00:14:57.000
次に、PLAYボタンの横に配置します。

00:14:57.000 --> 00:15:06.000
Touch Up Insideイベントを新しいメソッドに設定します。

00:15:06.000 --> 00:15:13.000
そして、新しいボタンに新しい参照アウトレットを設定します。

00:15:13.000 --> 00:15:28.000
次に、アプリを構築して実行して、新しいリーダーボードを試してみてください。

00:15:28.000 --> 00:15:30.000
Game Centerにログインするように求められる場合があります。

00:15:30.000 --> 00:15:36.000
リーダーボードが機能するには認証されたアカウントが必要なので、今すぐそうしてください。

00:15:36.000 --> 00:15:42.000
リーダーボードのグリフをタップすると、Game Center UIのリーダーボードに直接移動します。

00:15:42.000 --> 00:15:45.000
まだプレイしていない場合、リーダーボードは空になります。

00:15:45.000 --> 00:16:08.000
簡単にプレイして、リーダーボードに戻って新しいスコアを確認してください。

00:16:08.000 --> 00:16:19.000
リーダーボードがあり、スコアを提出している今、ゲームプレイ中にライブスコアを追加しましょう。

00:16:19.000 --> 00:16:27.000
LeaderboardNodeクラスを見てみましょう。

00:16:27.000 --> 00:16:34.000
これはSpriteKitノードで、名前とスコアで構成されるリーダーボードエントリのリストを取り、ランクに応じて表示します。

00:16:34.000 --> 00:16:39.000
エントリで初期化し、エントリを変更する必要があるときに更新できます。

00:16:39.000 --> 00:16:58.000
GameSceneのメンバーとしてオプションのリーダーボードノードを追加します。

00:16:58.000 --> 00:17:02.000
setupInitialGameplayでリーダーボードの位置を初期化します。

00:17:02.000 --> 00:17:18.000
そのすぐ下にあるノードを初期化します。

00:17:18.000 --> 00:17:34.000
5行で設定し、最初のエントリを空白のままにしています。

00:17:34.000 --> 00:17:46.000
バックグラウンドノードに追加して、シーンに表示します。

00:17:46.000 --> 00:17:50.000
次に、エントリをロードし、リーダーボードを更新する必要があります。

00:17:50.000 --> 00:18:02.000
このためにupdateLeaderboardNode関数を作成します。

00:18:02.000 --> 00:18:13.000
まず、DailyHighScoreリーダーボードをロードします。

00:18:13.000 --> 00:18:21.000
完了ハンドラで、リーダーボードを使用して、グローバルリーダーボードから上位5つのエントリをロードします。

00:18:21.000 --> 00:18:38.000
これは定期的なリーダーボードであるため、タイムスコープは常にオールタイムになります。

00:18:38.000 --> 00:19:01.000
これらがロードされたら、エントリがnilでない場合、GameKitエントリをLeaderboardNodeが使用するLeaderboardEntry構造体に変換する必要があります。

00:19:01.000 --> 00:19:38.000
次に、LeaderboardNodeのupdateEntriesメソッドを呼び出します。

00:19:38.000 --> 00:19:42.000
最後のステップは、ゲームプレイ中にLeaderboardNodeを更新することです。

00:19:42.000 --> 00:19:47.000
このゲームでは、プレイヤーのスコアは頻繁に変化しており、LeaderboardNodeを同期させる必要があります。

00:19:47.000 --> 00:20:03.000
これを行うには、submitScoreの完了ハンドラでupdateLeaderboardNode()を呼び出します。

00:20:03.000 --> 00:20:19.000
プレイヤーが得点する前にリーダーボードを正しく表示するには、ノードが作成された直後に呼び出すこともできます。

00:20:19.000 --> 00:20:33.000
今、私は再び構築して実行するつもりです。

00:20:33.000 --> 00:20:35.000
私と一緒にゲームをしている友達が何人かいます。

00:20:35.000 --> 00:20:57.000
スコアが上がるにつれて、リーダーボードが継続的に更新されるのを見ることができます。

00:20:57.000 --> 00:21:05.000
私が行っている最後の変更は、プレイヤーの現在のデイリーランクが以前のデイリーランクとどのように異なるかを示すことです。

00:21:05.000 --> 00:21:13.000
時間が終わったら、これをGameMenuNodeに入れます。

00:21:13.000 --> 00:21:21.000
これを実装するために一連のネストされた完了ハンドラを使用できますが、GameKitの新しい非同期メソッドを使用すると、このコードがより読みやすくなります。

00:21:21.000 --> 00:21:22.000
新しい非同期メソッドを作成します。

00:21:22.000 --> 00:21:36.000
addRankToGameMenu()と呼びましょう。

00:21:36.000 --> 00:21:39.000
GameKitの非同期メソッドはスローできるので、エラーをキャッチしたいと思うでしょう。

00:21:39.000 --> 00:21:45.000
私はちょうどそれらを記録するつもりです。

00:21:45.000 --> 00:21:53.000
デイリーリーダーボードをロードし、正常に返されたことを確認します。

00:21:53.000 --> 00:21:56.000
そのリーダーボードインスタンスでは、2つのことを行います。

00:21:56.000 --> 00:22:01.000
まず、async letでエントリを非同期にロードします。

00:22:01.000 --> 00:22:08.000
ローカルプレーヤーのスコアしか気にしていないので、forパラメータを空のままにします。

00:22:08.000 --> 00:22:20.000
次に、リーダーボードの以前の出現を非同期にロードし、それを使用してエントリをロードします。

00:22:20.000 --> 00:22:24.000
この情報を表示するには、gameMenuNodeにメソッドを書く必要があります。

00:22:24.000 --> 00:22:36.000
それをaddRankNodeと呼びましょう。

00:22:36.000 --> 00:22:55.000
現在と以前のランクで合格する。

00:22:55.000 --> 00:23:04.000
あなたは彼らが準備ができているのを待つためにtry awaitを使用する必要があります。

00:23:04.000 --> 00:23:23.000
先に進んで、timeIsUpから切り離しブロックで新しい非同期メソッドを呼び出してください。

00:23:23.000 --> 00:23:41.000
次に、GameMenuNodeに向かい、addRankNodeを実装します。

00:23:41.000 --> 00:24:01.000
addRankNodeは、以前のランクと現在のランクの違いを使用して、いくつかの簡単なテキストを生成します。

00:24:01.000 --> 00:24:05.000
両方のランクがゼロであれば、あなたはただ戻ることができます。

00:24:05.000 --> 00:24:08.000
ラベルノードにテキストを表示します。

00:24:08.000 --> 00:24:28.000
私はそれを作成するためにヘルパー関数を使用しています。

00:24:28.000 --> 00:24:36.000
適切に配置してください。

00:24:36.000 --> 00:24:52.000
水平方向に中央に、垂直に中央の少し下に追加します。

00:24:52.000 --> 00:25:02.000
次に、それを背景に追加します。

00:25:02.000 --> 00:25:12.000
では、結果を見てみましょう。

00:25:12.000 --> 00:25:15.000
私は昨日プレイしたので、以前のランクが利用可能です。

00:25:15.000 --> 00:25:21.000
ご覧のとおり、私のランクは今日少し下がっており、プレーし続ける正当な理由です。

00:25:21.000 --> 00:25:37.000
このセッションでは、App Store Connectで定期的なリーダーボードを設定する方法と、スコアを送信し、Game Center独自のリーダーボードUIにリンクし、リーダーボードAPIを使用してライブグローバルランクと以前のランクを表示することで、ゲームでそれを使用する方法を紹介しました。

00:25:37.000 --> 00:25:44.000
定期的なリーダーボードの詳細については、昨年のWWDCの「ゲームセンターをタップ：リーダーボード、実績、マルチプレイヤー」を参照してください。

00:25:44.000 --> 00:25:48.000
そして、今年のWWDCで「ゲームセンターの新機能」を必ずチェックしてください。

00:25:48.000 --> 23:59:59.000
[パーカッシブミュージック]。

