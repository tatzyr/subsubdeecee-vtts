WEBVTT

00:00:00.000 --> 00:00:05.000
♪ベース音楽の演奏♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:11.000
マーティ・パイ：「AVKitの新機能」へようこそ。

00:00:11.000 --> 00:00:14.000
私の名前はマーティ・パイで、AVKitチームのエンジニアです。

00:00:14.000 --> 00:00:23.000
今日は、ピクチャー・イン・ピクチャー、または短いPiP、およびmacOSのフルスクリーン体験に対して行った機能強化のいくつかについて話したいと思います。

00:00:23.000 --> 00:00:27.000
ピクチャー・イン・ピクチャーから始めましょう。

00:00:27.000 --> 00:00:33.000
ピクチャー・イン・ピクチャーを使用すると、ユーザーはデバイスでマルチタスクしながらビデオコンテンツを引き続き楽しむことができます。

00:00:33.000 --> 00:00:41.000
たとえば、ビデオをフルスクリーンで見ていて、メッセージを受信した場合は、コンテンツを見続けながら、そのメッセージに簡単に返信できます。

00:00:41.000 --> 00:00:48.000
ビデオは自動的にPiPに入り、返信が完了したら、すぐにフルスクリーン再生を再開できます。

00:00:48.000 --> 00:00:55.000
これにより、本当にシームレスな視聴体験ができ、ユーザーはビデオを見ているときにこの動作を期待すると思います。

00:00:55.000 --> 00:01:05.000
PiPを自分のアプリに統合する方法の詳細については、AVKitで直感的なメディア再生を提供するこの2019年のセッションを見ることをお勧めします。

00:01:05.000 --> 00:01:14.000
今年の新機能、ビデオがインラインで再生されている場合は、ユーザーがホーム画面にスワイプしたときにPiPを自動的に入力することをオプションで許可できます。

00:01:14.000 --> 00:01:21.000
この動作を有効にすると、canStartPictureInPicture AutomaticallyFromInlineプロパティを介して実現されます。

00:01:21.000 --> 00:01:31.000
このプロパティは、ネイティブコントロールを使用するアプリのAVPlayerViewControllerと、独自のカスタムUIを実装するアプリのAVPictureInPictureControllerの両方で利用できます。

00:01:31.000 --> 00:01:39.000
再生コンテンツがユーザーの主な焦点であることを意図している場合にのみ、このフラグをtrueに設定してください。

00:01:39.000 --> 00:01:44.000
AVPlayerViewControllerを使用してビデオコンテンツを提示している場合は、PiPが処理されます。

00:01:44.000 --> 00:01:46.000
あなたがする必要があることは何もありません。

00:01:46.000 --> 00:01:54.000
AVPlayerViewControllerを使用していない場合でも、AVPictureInPictureControllerを使用して、ネイティブのPiPエクスペリエンスをアプリに持ち込むことができます。

00:01:54.000 --> 00:02:01.000
まず、再生用にアプリのオーディオセッションカテゴリを設定し、PiPバックグラウンドモードを有効にする必要があります。

00:02:01.000 --> 00:02:08.000
次に、pictureInPictureControllerを作成し、playerLayerへの参照を渡すだけです。

00:02:08.000 --> 00:02:17.000
次に、ユーザーが指定したボタンを使用してピクチャ・イン・ピクチャを切り替えようとすると、コントローラオブジェクトのPiPの開始または停止を呼び出すだけです。

00:02:17.000 --> 00:02:22.000
これまで、私たちのピクチャー・イン・ピクチャー体験はAVPlayerベースのコンテンツを中心に構築されていました。

00:02:22.000 --> 00:02:28.000
本日、AVSampleBufferDisplayLayerの同じレベルのサポートを発表できることを嬉しく思います。

00:02:28.000 --> 00:02:40.000
プレーヤーレイヤーでピクチャーインピクチャーコントローラーを作成する代わりに、まずContentSourceを作成し、AVPlayerLayerまたはここに示すようにAVSampleBufferDisplayLayerで設定します。

00:02:40.000 --> 00:02:43.000
ユーザーの場合、ピクチャー・イン・ピクチャーのエクスペリエンスは同じになります。

00:02:43.000 --> 00:02:51.000
開発者として、AVSampleBufferDisplayLayerのPiPのサポートに関連するいくつかの新しい責任があります。

00:02:51.000 --> 00:02:53.000
この再生デリゲートを見てみましょう。

00:02:53.000 --> 00:03:06.000
メディア再生はAVPlayerによって管理されていないため、PiP UIをレンダリングするために、新しいAVPictureInPictureSample BufferPlaybackDelegateを介して提供される再生状態情報に依存する必要があります。

00:03:06.000 --> 00:03:12.000
ユーザーがPiP UIからメディアを制御しようとすると、それらのコマンドをデリゲートに転送して処理します。

00:03:12.000 --> 00:03:16.000
5つの個別のコールバックを1つずつ確認しましょう。

00:03:16.000 --> 00:03:21.000
setPlaying機能は、ユーザーがPiPウィンドウの再生/一時停止ボタンを押すと呼び出されます。

00:03:21.000 --> 00:03:25.000
skipByInterval関数は、ユーザーがスキップボタンの1つを押すと呼び出されます。

00:03:25.000 --> 00:03:29.000
これらのコールバックを使用して、それに応じてメディアを制御します。

00:03:29.000 --> 00:03:34.000
timeRangeForPlayback関数を使用すると、現在再生可能な時間範囲を指定できます。

00:03:34.000 --> 00:03:39.000
これにより、タイムラインをレンダリングし、再生ヘッドが現在どこにあるかを示すことができます。

00:03:39.000 --> 00:03:45.000
有限の期間を持つ時間範囲には、常にサンプルバッファ表示レイヤーのタイムベースの現在の時刻を含める必要があります。

00:03:45.000 --> 00:03:50.000
ライブコンテンツを示すために、無限の期間を持つ時間範囲を使用してください。

00:03:50.000 --> 00:03:57.000
didTransitionToRenderSize関数は、ピンチツーズーム中など、ピクチャインピクチャウィンドウのサイズが変更されたときに呼び出されます。

00:03:57.000 --> 00:04:04.000
不要なデコードオーバーヘッドを避けるために、メディアバリアントを選択する際には、このレンダリングサイズを考慮してください。

00:04:04.000 --> 00:04:12.000
isPlaybackPaused関数は定期的に呼び出され、一時停止または再生状態を反映するかどうかをPicture in Picture UIに通知します。

00:04:12.000 --> 00:04:17.000
これは概念的には、AVPlayerのtimeControlStatusと同等です。

00:04:17.000 --> 00:04:23.000
次に、macOSのフルスクリーン体験に対して行った改善点をいくつか見てみましょう。

00:04:23.000 --> 00:04:31.000
Big Surでは、Mac Catalystアプリでビデオをフルスクリーンで撮影すると、ビデオはウィンドウ全体を埋めますが、画面全体は埋めません。

00:04:31.000 --> 00:04:36.000
macOS Montereyでは、ビデオが画面全体を取り上げます。

00:04:36.000 --> 00:04:42.000
ネイティブのmacOSアプリとMac Catalystアプリの両方で、真のフルスクリーン体験になります。

00:04:42.000 --> 00:04:44.000
再生コントロールは両方とも同じように見えます。

00:04:44.000 --> 00:04:48.000
すべてのMac Catalystアプリは、この新しい動作を自動的に取得します。

00:04:48.000 --> 00:04:54.000
ネイティブのmacOSフルスクリーンエクスペリエンスと同様に、ユーザーはアプリウィンドウにスワイプして戻ることができます。

00:04:54.000 --> 00:05:00.000
オリジナルのビデオの代わりにプレースホルダが表示され、コンテンツがフルスクリーンで再生されていることを示します。

00:05:00.000 --> 00:05:06.000
これは、ビデオがピクチャ・イン・ピクチャで再生されているときに表示されるプレースホルダと非常によく似ています。

00:05:06.000 --> 00:05:15.000
ユーザーがコンテンツを選択した後にプレイヤービューコントローラーをフルスクリーンで表示するシナリオでは、ビューコントローラーは引き続きフルウィンドウに表示されます。

00:05:15.000 --> 00:05:25.000
しかし、macOS Montereyの新機能では、ユーザーはウィンドウの左上にある緑色のフルスクリーンボタンを押すことで、真のフルスクリーン再生体験に切り離すことができます。

00:05:25.000 --> 00:05:32.000
フルスクリーンのライフサイクルは、アプリケーションのニーズに基づいてより良いユーザーエクスペリエンスを提供するために明示的に管理できます。

00:05:32.000 --> 00:05:35.000
例を見てみましょう。 例を見てみましょう。

00:05:35.000 --> 00:05:43.000
すでに示したように、ユーザーはビデオをフルスクリーンで撮影し、再生が継続している間にアプリにスワイプバックできるはずです。

00:05:43.000 --> 00:05:50.000
プレイヤービューコントローラーがビュー階層から削除されたとしても、アプリを自由にナビゲートできるはずです。

00:05:50.000 --> 00:05:57.000
いつでも、スワイプするか、Mission Controlを使用してフルスクリーンビデオに戻ることができるはずです。

00:05:57.000 --> 00:05:59.000
それでは、それを機能させる方法を見てみましょう。

00:05:59.000 --> 00:06:03.000
あなたはplayerViewControllerのライフサイクルに責任があります。

00:06:03.000 --> 00:06:12.000
最適なエクスペリエンスを実現するには、アプリのビュー階層になくても、playerViewControllerを存続させる必要があります。

00:06:12.000 --> 00:06:20.000
それ以外の場合、ユーザーがビデオでページから離れると、playerViewControllerがリリースされるとフルスクリーン再生が終了します。

00:06:20.000 --> 00:06:27.000
あなたがする必要があるのは、willBeginFullScreenPresentationコールバックを受け取ったときに、playerViewControllerへの強力な参照を維持することだけです。

00:06:27.000 --> 00:06:34.000
その後、ユーザーがフルスクリーンを終了すると、willEndFullScreenPresentationコールバックを受け取ります。

00:06:34.000 --> 00:06:43.000
これは、ユーザーが提示された元のビューから離れてナビゲートしたと仮定して、あなたが生き続けていたplayerViewControllerを手放す機会です。

00:06:43.000 --> 00:06:46.000
ネイティブmacOSにも同じことが当てはまります。

00:06:46.000 --> 00:06:54.000
新しいplayerViewDelegateを使用すると、playerViewWillExitFullScreenコールバックを受け取るまで、playerViewを存続させることができます。

00:06:54.000 --> 00:07:00.000
ユーザーがフルスクリーンを終了すると、このrestoreUserInterfaceコールバックも受信します。

00:07:00.000 --> 00:07:08.000
これは、あなたのユースケースに適していると仮定して、アプリがビデオを含む元のページに戻る機会です。

00:07:08.000 --> 00:07:14.000
これは、ユーザーがPicture in Pictureを停止したときに受け取る既存のコールバックと非常によく似ています。

00:07:14.000 --> 00:07:21.000
フルスクリーンからインラインへの移行をブロックしないように、できるだけ早くこの完了ハンドラーから戻るようにしてください。

00:07:21.000 --> 00:07:29.000
Falseを返すと、復元が失敗した、または不可能であることを示します。その場合、コンテンツはアニメーションなしでフルスクリーンを終了します。

00:07:29.000 --> 00:07:32.000
それで、今日のセッションを締めくくりたいと思います。

00:07:32.000 --> 00:07:41.000
AVPlayerLayerの代わりにAVSampleBufferDisplayLayerを使用する場合、新しいコンテンツソースAPIを使用してアプリにピクチャーインピクチャーサポートを追加する方法を見ました。

00:07:41.000 --> 00:07:50.000
macOSとMac Catalystでは、強化されたフルスクリーンエクスペリエンスを確認し、コードをシームレスに統合するために必要な手順を概説しました。

00:07:50.000 --> 00:07:56.000
今日のセッションを楽しんでいただければ幸いです。これらの機能のいくつかがアプリに統合されるのを楽しみにしています。

00:07:56.000 --> 00:07:58.000
会議の残りを楽しんでください。

00:07:58.000 --> 23:59:59.000
♪

