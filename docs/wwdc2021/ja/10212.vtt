WEBVTT

00:00:00.000 --> 00:00:11.000
ようこそ！私の名前はカッパーです。

00:00:11.000 --> 00:00:22.000
私はAppleのパフォーマンスツールエンジニアで、今日はSergioと一緒に、Instruments 13で利用可能な新しいHTTPトラフィックインストゥルメントについて話します。

00:00:22.000 --> 00:00:32.000
ネットワークテンプレートに含まれるこのインストゥルメントでは、Apple Networkingスタックを介してアプリケーションからのHTTPトラフィックを検査できます。

00:00:32.000 --> 00:00:35.000
このアプローチには複数の利点があります。

00:00:35.000 --> 00:00:38.000
それはすべてのAppleデバイスで動作します。

00:00:38.000 --> 00:00:48.000
新しいHTTP/3プロトコルまたはVPN経由で送信されたトラフィックでも、URLローディングシステムを通過するトラフィック全体が公開されます。

00:00:48.000 --> 00:01:00.000
システム統合のため、トラフィックをその上で実行されているプロセスに帰属させ、Apple Networkingフレームワークをインストルメントしているため、ディスク上のキャッシュやネットワークエラーにヒットする要求を明らかにすることさえできます。

00:01:00.000 --> 00:01:10.000
これらはすべて、URLSessionsやURLSessionTasksなど、あなたがよく知っている高レベルのAPI概念のコンテキストで公開されています。

00:01:10.000 --> 00:01:17.000
このツールは、APIの使用がネットワーク要求の寿命にどのように変換されるかを理解するのに役立ちます。

00:01:17.000 --> 00:01:25.000
このハンズオンセッションでは、まず、Instruments UIが使用しているAPIの概念をどのように反映しているかを把握します。

00:01:25.000 --> 00:01:35.000
この簡単な紹介の後、このツールを使用してパフォーマンスと正確性の両方の問題を検出する方法を説明する4つのデモに移行します。

00:01:35.000 --> 00:01:45.000
そして、あなたのアプリが完璧に動作しているように見えても、そこから来るトラフィックを監査することによって、あなたが考えていることをすることを確認する方法を学びます。

00:01:45.000 --> 00:01:50.000
ネットワーキングAPIがインスツルメンツの視覚化にどのようにマッピングするかから始めましょう。

00:01:50.000 --> 00:01:58.000
これは、ネットワークテンプレートを使用してシステムトラフィックを記録したときに、HTTPトラフィックトレースがInstrumentsに表示される方法です。

00:01:58.000 --> 00:02:04.000
ナビゲーションはトラック階層を中心に構成されており、最初に詳しく説明します。

00:02:04.000 --> 00:02:19.000
トップレベルにあるHTTPトラフィックインストゥルメントは、任意の時点でトレースで実行されていたURLSessionタスクの数の概要を示し、アプリの存続期間中にHTTPトラフィックアクティビティが増加したスポットを検出するのに理想的です。

00:02:19.000 --> 00:02:24.000
次の階層レベルは、プロセスごとの活動の内訳を示しています。

00:02:24.000 --> 00:02:31.000
デバッグ可能なすべてのプロセスからのトラフィックに加えて、それらによって開始されたバックグラウンドトラフィックを検査することができます。

00:02:31.000 --> 00:02:35.000
各プロセスの下には、それで使用されるすべてのURLSessionsが含まれています。

00:02:35.000 --> 00:02:40.000
これらは、コードで作成したURLSessionオブジェクトに対応しています。

00:02:40.000 --> 00:02:46.000
このレベルのグラフでは、すべての個々のタスク間隔を検査できます。

00:02:46.000 --> 00:02:57.000
セッションオブジェクトとビジュアライゼーションの間のより良いマッピングを得るには、セッションインスタンスにsessionDescriptionプロパティを設定することで、コードでそれらに名前を付けることができます。

00:02:57.000 --> 00:03:02.000
最後のレベルでは、トラフィックは要求されたドメインによって分類されます。

00:03:02.000 --> 00:03:12.000
このレベルのグラフは、タスクとその状態を構成する個々のトランザクションを含む、タスクに関する詳細を示しています。

00:03:12.000 --> 00:03:21.000
タスクとトランザクションが何であるかをよりよく理解するために、例を分析しましょう。

00:03:21.000 --> 00:03:25.000
選択したドメインからデータをロードするタスクをいくつか紹介します。

00:03:25.000 --> 00:03:32.000
タスクの構造を分析するために、そのうちの1つに焦点を当てましょう。

00:03:32.000 --> 00:03:35.000
この単一のタスク間隔には多くの情報があります。

00:03:35.000 --> 00:03:45.000
インストゥルメントの視覚化が使用されているAPIにどのようにマッピングされるかを理解するために、これをより抽象的な方法で表現することができます。

00:03:45.000 --> 00:03:49.000
トップレベルでは、タスクオブジェクトがあります。

00:03:49.000 --> 00:03:54.000
タスクは1つ以上のトランザクションで構成されています。

00:03:54.000 --> 00:04:02.000
トランザクションは、HTTPリクエストと対応するレスポンスのペアです。

00:04:02.000 --> 00:04:08.000
タスクレベルは、コードがURLローディングシステムのAPIとどのように相互作用するかの表現です。

00:04:08.000 --> 00:04:14.000
タスクを作成して再開を呼び出すと、タスク間隔が開始されます。

00:04:14.000 --> 00:04:20.000
そして、完了ブロックが呼び出される直前に終了します。

00:04:20.000 --> 00:04:30.000
各タスクには、instrumentsの間隔にラベルを付けるために使用されるtaskDescriptionプロパティを使用してセマンティック名を付けることができます。

00:04:30.000 --> 00:04:35.000
また、タスク識別子をタスクラベルの一部として表示します。

00:04:35.000 --> 00:04:39.000
タスクを他のデータと相互参照するために使用できます。

00:04:39.000 --> 00:04:47.000
タスクがエラーで終了した場合、その説明はデバッグを容易にするためにインターバルラベルに表示されます。

00:04:47.000 --> 00:04:52.000
前に述べたように、タスクは複数のトランザクションで作成できます。

00:04:52.000 --> 00:04:54.000
今からこれらについて話しましょう。

00:04:54.000 --> 00:04:59.000
ここでは、apple.comのスタートページを読み込むタスクがあります。

00:04:59.000 --> 00:05:03.000
ただし、このURLは正規のURLではありません。

00:05:03.000 --> 00:05:10.000
タスクはapple.comを要求しますが、優先ドメインはwww.apple.comです。

00:05:10.000 --> 00:05:17.000
このタスクを作成すると、URLローディングシステムは最初にapple.comへのリクエストを作成します。

00:05:17.000 --> 00:05:27.000
その後まもなく、サーバーからリダイレクト応答を受け取り、優先URLは実際にはwww.apple.comであると述べています。

00:05:27.000 --> 00:05:38.000
デフォルトでは、リダイレクトに従うため、301応答を返す代わりに、URLロードシステムは新しいトランザクションを作成し、優先URLをロードします。

00:05:38.000 --> 00:05:46.000
この2番目の成功したトランザクションからの応答は、タスクに返されるものです。

00:05:46.000 --> 00:05:53.000
前述のように、トランザクションはHTTPリクエストとレスポンスの組み合わせを表します。

00:05:53.000 --> 00:06:08.000
URLSessionがタスクを処理するために内部で行うことと一致し、要求されたURL、転送されたデータに関する情報など、HTTPレイヤーのすべての情報が含まれています。

00:06:08.000 --> 00:06:14.000
タスクと同様に、トランザクションラベルはトランザクションの概要を示します。

00:06:14.000 --> 00:06:20.000
主に、要求と応答に関する情報を取得します。

00:06:20.000 --> 00:06:28.000
トラック階層は要求されたドメインを指示しますが、ラベル自体でパスとクエリを見つけることができます。

00:06:28.000 --> 00:06:41.000
それに加えて、インターバルラベルには、HTTPバージョン、HTTPメソッド、およびリクエストがAuthorizationまたはCookieヘッダーを送信したかどうかが表示されます。

00:06:41.000 --> 00:06:47.000
これらは、認証フローを一目で理解するのにしばしば役立ちます。

00:06:47.000 --> 00:06:57.000
応答については、ステータスコード、応答にクッキーが含まれているかどうか、および応答のコンテンツタイプを取得します。

00:06:57.000 --> 00:07:08.000
要求と応答にかかった時間、およびトランザクションの一部である他の作業に関するより詳細なタイミング情報は、トランザクション状態によってキャプチャされます。

00:07:08.000 --> 00:07:12.000
包含タスクの文脈でそれらを分析しましょう。

00:07:12.000 --> 00:07:21.000
トランザクションの開始は、URLローディングシステムがこの要求を行うためのトランザクションを作成する時点です。

00:07:21.000 --> 00:07:25.000
まず、すでに有効なキャッシュされた応答があるかどうかを確認します。

00:07:25.000 --> 00:07:32.000
そうでない場合は、接続でリクエストをスケジュールしようとします。

00:07:32.000 --> 00:07:40.000
次に、トランザクションはブロックされた状態で少し待って、利用可能な接続を待たなければならないかもしれません。

00:07:40.000 --> 00:07:46.000
送信要求の状態は、トランザクションが最終的に接続によって処理されたときに開始されます。

00:07:46.000 --> 00:07:51.000
リクエストの最後のバイトをネットワークに送信すると終了します。

00:07:51.000 --> 00:08:04.000
次に、トランザクションはアイドル状態になり、応答待ち状態になり、続いて応答を受信し、サーバーから受信した最初のバイトから最後のバイトまでのスパンを追跡します。

00:08:04.000 --> 00:08:14.000
URLローディングシステムがこれが応答に成功したかどうかを判断すると、最後のバイトを受信した直後にトランザクション全体が完了します。

00:08:14.000 --> 00:08:25.000
実際には、GETリクエストのキャッシュルックアップと送信状態は通常はるかに短いため、このように見える可能性が高くなります。

00:08:25.000 --> 00:08:30.000
実用的な例をお見せするために、同僚のセルジオに手渡したいと思います。

00:08:30.000 --> 00:08:40.000
彼は、HTTPインストゥルメントがパフォーマンスと正確性の問題を修正するのにどのように役立つかを説明するために、最近開発し始めたアプリを案内します。

00:08:40.000 --> 00:08:42.000
ありがとう、カスパー。みなさん、こんにちは。

00:08:42.000 --> 00:08:46.000
私の名前はセルジオ・ロペスで、犬愛好家のためのこのアプリに取り組んできました。

00:08:46.000 --> 00:08:50.000
ソーシャルメディアプラットフォームのように考えてください、しかし犬の写真のために...

00:08:50.000 --> 00:08:51.000
だけ！

00:08:51.000 --> 00:08:55.000
人々は犬の画像を投稿することができ、あなたは最新のアップロードのストリームを取得します!

00:08:55.000 --> 00:09:05.000
そのため、アプリを開くと、いくつかの新しい犬の画像が読み込まれますが、読み込みを完了するのにかなりの時間がかかることに気づきました。

00:09:05.000 --> 00:09:12.000
この状況を改善するために、新しいHTTPトラフィック機器でアプリをプロファイリングしましょう。

00:09:12.000 --> 00:09:19.000
「製品」メニューで、「プロファイル」オプションを選択して、Instrumentsでアプリをプロファイルします。

00:09:19.000 --> 00:09:29.000
これは、すべての最適化をオンにして、ユーザーのために実行されるようにアプリをプロファイリングしていることを確認するために、リリース構成で私のアプリを構築します。

00:09:29.000 --> 00:09:32.000
ビルドが完了すると、Instrumentsは自動的に起動します。

00:09:32.000 --> 00:09:39.000
起動時に、Instrumentsの標準テンプレートセレクタが表示されます。

00:09:39.000 --> 00:09:58.000
私たちの場合、左下のネットワークテンプレートを選択したいと思います。これは、私のアプリが行う一般的なネットワーク接続に関する詳細情報を提供しますが、新しいHTTPトレース機能も含まれています。

00:09:58.000 --> 00:10:03.000
トラックエリアには、各楽器に1つずつ2つのトラックが含まれています。

00:10:03.000 --> 00:10:10.000
下のトラックは既存のネットワーク接続インストゥルメントで、上のトラックは新しいHTTPトラフィックインストゥルメントです。

00:10:10.000 --> 00:10:13.000
今日はこの新しい楽器に焦点を当てます。

00:10:13.000 --> 00:10:15.000
私が今する必要があるのは「レコード」を押すことだけです。

00:10:15.000 --> 00:10:21.000
その後、楽器は私のアプリを起動し、録音を開始します。

00:10:21.000 --> 00:10:27.000
このツールを使用する前に、ネットワークトラフィックをキャプチャすることの意味を理解していることを確認する必要があります。

00:10:27.000 --> 00:10:31.000
特にすべてのプロセスを記録する場合、それは非常に強力です。

00:10:31.000 --> 00:10:38.000
キャプチャされたデータには、送信されるすべてのものが含まれます。これは、ユーザーの資格情報まで、個人情報や機密情報である可能性があります。

00:10:38.000 --> 00:10:42.000
したがって、結果のトレースファイルには細心の注意を払う必要があります。

00:10:42.000 --> 00:10:47.000
では、これを確認させてください。

00:10:47.000 --> 00:10:53.000
アプリが起動し、画像の読み込みが遅かった。

00:10:53.000 --> 00:10:58.000
今から録音を停止します。

00:10:58.000 --> 00:11:08.000
Optionキーを押しながらクリックして、HTTPトラフィックをカバーする領域をドラッグして、記録したデータにズームインしましょう。

00:11:08.000 --> 00:11:20.000
左上の「HTTPトラフィック」トラックの開示インジケータをクリックすると、Kacperが以前に説明した完全なトラック階層が表示されます。

00:11:20.000 --> 00:11:32.000
また、すべての間隔を表示するためにトラックの高さを増やします。

00:11:32.000 --> 00:11:41.000
上部には、アプリの「最新」セクションに表示される画像のリストをサーバーに照会する最初のタスクがあります。

00:11:41.000 --> 00:11:49.000
このタスクが完了したら、受け取ったリスト上のすべての画像のサムネイルをロードする新しいタスクを作成します。

00:11:49.000 --> 00:12:04.000
画像のリストを取得するのにかかった時間枠をカバーする領域をドラッグし、その後、個々の画像を取得するための多くのリクエストが続きます。

00:12:04.000 --> 00:12:10.000
この領域をドラッグすると、選択した時間範囲の期間を示すツールチップが表示されます。

00:12:10.000 --> 00:12:16.000
全体として、初期画面の読み込みを完了するのに7秒以上かかりました。

00:12:16.000 --> 00:12:18.000
最初のいくつかの画像はかなり速く読み込まれます。

00:12:18.000 --> 00:12:26.000
しかし、下にスクロールすると、紫色のブロック状態の増加が指摘されているように、後で開始されたタスクは完了までに時間がかかりました。

00:12:26.000 --> 00:12:30.000
混雑の問題のように思えますが、並行してリクエストが多すぎます。

00:12:30.000 --> 00:12:37.000
後のタスクの1つを調査しましょう。

00:12:37.000 --> 00:12:44.000
タスクにカーソルを合わせると、ツールチップはタスクの期間と、ホバーしている子間隔を示します。

00:12:44.000 --> 00:12:49.000
このタスクは、ほとんどの場合ブロックされました。

00:12:49.000 --> 00:12:58.000
ブロックされた理由を理解するために、トラック表示を「接続によるHTTPトランザクション」ビューに切り替えましょう。

00:12:58.000 --> 00:13:07.000
左側のトラックサイドバーのドメイン名の下に、クリックしてトラック表示を切り替えることができる下向き矢印があります。

00:13:07.000 --> 00:13:10.000
現在、私たちは「タスク」を描いています。

00:13:10.000 --> 00:13:18.000
「接続によるHTTPトランザクション」の表示に切り替えましょう。

00:13:18.000 --> 00:13:28.000
このビューはトランザクションのみを表示し、タスクごとにグループ化するのではなく、スケジュールされた接続を確認できるようになりました。

00:13:28.000 --> 00:13:32.000
トランザクションは、使用した接続によってグループ化されます。

00:13:32.000 --> 00:13:37.000
全体として、これらのトランザクションを処理するために利用可能な6つの接続がありました。

00:13:37.000 --> 00:13:45.000
接続1で発行されたトランザクションを分析し、サムネイルの読み込みトランザクションのいくつかをさらに調査しましょう。

00:13:45.000 --> 00:13:49.000
トップダウンから、各トランザクションが完了するまでに時間がかかることが顕著です。

00:13:49.000 --> 00:13:54.000
連続するトランザクションごとに紫色のブロック状態が増加しています。

00:13:54.000 --> 00:13:59.000
実際、ここにはかなり明確な階段のパターンがあります。

00:13:59.000 --> 00:14:05.000
同じ接続上の以前のトランザクションが終了するまで、各トランザクションはブロックされます。

00:14:05.000 --> 00:14:07.000
そうして初めて、リクエストを送信できます。

00:14:07.000 --> 00:14:11.000
このパターンは、後続のトランザクションごとに繰り返されます。

00:14:11.000 --> 00:14:18.000
これは「ヘッドオブラインブロッキング」と呼ばれ、HTTP/1を使用する際の問題の1つです。

00:14:18.000 --> 00:14:23.000
イライラする部分は、これらの取引がほとんどの時間何もしていないことです。

00:14:23.000 --> 00:14:28.000
代わりに、彼らはほとんどの時間をブロックしたり、サーバーからの応答を待って過ごします。

00:14:28.000 --> 00:14:39.000
同じ接続で以前のトランザクションの応答を待っている間に、次のトランザクションの別のリクエストを送信できますが、HTTP/1ではサポートされていません。

00:14:39.000 --> 00:14:54.000
ヘッドオブラインブロッキングはHTTP/1の主な制限の1つであり、HTTP/2の主な改善点の1つは、同じサーバーへの複数の要求を単一の接続に多重化することで、その影響を回避することです。

00:14:54.000 --> 00:15:00.000
HTTP/2では、最初のリクエストが応答を待っている間に、実際に2番目のリクエストの送信を開始できます。

00:15:00.000 --> 00:15:03.000
あなたのアプリはそれをサポートするために何もする必要はありません。

00:15:03.000 --> 00:15:13.000
すべてのAppleプラットフォームはHTTP/2をサポートしており、iOS 15とmacOS Monterey以降、HTTP/3もサポートされています。

00:15:13.000 --> 00:15:17.000
クライアントは、サーバーがサポートする最新のHTTPバージョンを選択します。

00:15:17.000 --> 00:15:33.000
HTTP/1とHTTP/2の違い、およびHTTP/3が提供する追加の利点について詳しく知りたい場合は、「HTTP/3とQUICでネットワーキングを加速する」セッションをご覧ください。

00:15:33.000 --> 00:15:40.000
私はこのトレースを取り、サーバーの人々に見せ、HTTP / 2を本当にサポートする必要があることを彼らに納得させることができました。

00:15:40.000 --> 00:15:45.000
では、新しいサーバーの機能強化で私のアプリを実行しましょう。

00:15:45.000 --> 00:15:48.000
うわー、これはすでに速く感じます!

00:15:48.000 --> 00:15:50.000
これをインスツルメンツで確認しましょう。

00:15:50.000 --> 00:15:55.000
これは、HTTP/2のサーバーサポートをオンにした後に記録したトレースです。

00:15:55.000 --> 00:16:01.000
ドメイン固有のトラックでは、サムネイルの読み込みタスクが長時間ブロックされていないようです。

00:16:01.000 --> 00:16:02.000
それはいいね！

00:16:02.000 --> 00:16:15.000
もう一度「接続によるHTTPトランザクション」ビューに切り替えましょう。

00:16:15.000 --> 00:16:18.000
私たちが最初に気づくのは、接続が1つしかないということです。

00:16:18.000 --> 00:16:29.000
これは、同時リクエストを送信するために複数の接続が不要になったためです。つまり、接続設定コストを一度支払うだけで済みます。

00:16:29.000 --> 00:16:35.000
個々のサムネイルローディングトランザクションに焦点を当てると、基本的に「ブロックされた」状態で時間を費やさないことがわかります。

00:16:35.000 --> 00:16:40.000
実際、時間は非常に小さいので、このズームレベルでは見えません。

00:16:40.000 --> 00:16:47.000
最終的に、すべてのトランザクションはリクエストの送信を完了し、応答を待ちます。

00:16:47.000 --> 00:16:54.000
下にスクロールすると、応答が同時に進んでいることがわかります。

00:16:54.000 --> 00:17:00.000
全体として、すべてのリクエストは3秒以内に完了します。

00:17:00.000 --> 00:17:02.000
これは以前の2倍の速さです。

00:17:02.000 --> 00:17:10.000
サーバーの人々と話し、HTTP / 1.1からHTTP / 2に切り替えたので、私たちのイメージははるかに速く読み込まれています。

00:17:10.000 --> 00:17:14.000
アプリを再起動して、他に何ができるかをお見せしましょう。

00:17:14.000 --> 00:17:21.000
画像をタップすると、アプリはフル解像度の画像をロードし、この写真が私からどのくらい離れているかを示します。

00:17:21.000 --> 00:17:26.000
右上にはハートのアイコンもあり、その特定の写真をお気に入りにすることができます。

00:17:26.000 --> 00:17:28.000
これを行うには、アカウントが必要です。

00:17:28.000 --> 00:17:38.000
私は人々がアプリを使用してアカウントなしで写真を閲覧することを許可しますが、お気に入りの画像を保存し、デバイス間で同期し、新しい写真をアップロードするには、アカウントが必要です。

00:17:38.000 --> 00:17:44.000
では、ここにログインさせてください。

00:17:44.000 --> 00:17:47.000
すごい。別の写真をお気に入りにさせてください。

00:17:47.000 --> 00:17:50.000
ああ、この犬はかわいく見える！お気に入りに追加させてください。 

00:17:50.000 --> 00:17:53.000
待って、やっただけなのに、なぜもう一度ログインしなければならないの？

00:17:53.000 --> 00:17:54.000
これは正しくありません。

00:17:54.000 --> 00:17:56.000
私のアプリは私のログインを覚えているはずです。

00:17:56.000 --> 00:17:57.000
これは以前はうまくいきました。

00:17:57.000 --> 00:18:03.000
再度ログインしたくないので、ログイン画面を消去します。

00:18:03.000 --> 00:18:07.000
私は以前、問題を再現した後、トレースファイルを記録しました。

00:18:07.000 --> 00:18:09.000
録音を分析するために楽器で開けさせてください。

00:18:09.000 --> 00:18:16.000
左側には、初めてお気に入りのボタンを押したときに対応するタスクがあります。

00:18:16.000 --> 00:18:24.000
その右側には、最新のタブに戻った後に発行されたタスクがあり、画像のストリームが更新されました。

00:18:24.000 --> 00:18:31.000
次に、別の犬の写真をタップした後、フル解像度の画像を読み込むタスクがあります。

00:18:31.000 --> 00:18:37.000
そして右端には、お気に入りボタンを2回目にタップしたときに対応するタスクがあります。

00:18:37.000 --> 00:18:47.000
最初のタスク間隔には、実際には2つのトランザクションが含まれています。

00:18:47.000 --> 00:18:50.000
最初の取引は401ステータスコードを受け取りました。

00:18:50.000 --> 00:18:53.000
ログインしていなかったので、これは予想されていました。

00:18:53.000 --> 00:19:02.000
トランザクションは、これがHTTPレベルで成功していないことを示すためにオレンジ色で描画されます。

00:19:02.000 --> 00:19:15.000
次に、タスクに大きな空の領域があり、ユーザー名とパスワードの入力に費やした時間を表します。

00:19:15.000 --> 00:19:20.000
これらの資格情報の入力が完了したらすぐに、トランザクションを再試行します。

00:19:20.000 --> 00:19:25.000
間隔の緑色と201ステータスコードは、今回成功したことを示しています。

00:19:25.000 --> 00:19:41.000
認証チャレンジ、パスワードの入力、トランザクションの再試行のこの相互作用は、URLローディングシステムが処理する別のケースであるため、これら2つのトランザクションは同じタスクオブジェクトに属します。

00:19:41.000 --> 00:19:46.000
ズームアウトすると、右側の画像をお気に入りにしようとする2回目の試みがあります。

00:19:46.000 --> 00:19:55.000
ログイン画面を閉じるとタスクがキャンセルされ、ラベルにも表示されるため、タスクオブジェクトは灰色で表示されます。

00:19:55.000 --> 00:20:01.000
再びサーバーから401応答を受け取ったので、トランザクション間隔はオレンジ色で表示されます。

00:20:01.000 --> 00:20:08.000
このタスクは、別の犬の写真を好きになろうとした後に発生し、2回目のログインを求められるようになりました。

00:20:08.000 --> 00:20:21.000
私たちは、ユーザーが最初に資格情報を送信する非常に基本的なログインシステムを使用しますが、サーバーがユーザーの資格情報を確認すると、次の要求で資格情報を提供する必要がないように、ユーザーを識別するクッキーを設定します。

00:20:21.000 --> 00:20:26.000
だから、私はこのタスクが適切なクッキーを送信することを期待していたでしょう。

00:20:26.000 --> 00:20:27.000
それが起こったかどうかを判断しましょう。

00:20:27.000 --> 00:20:36.000
Kacperが先に説明したように、このトランザクションがCookieヘッダーを送信した場合、HTTPメソッドの横に小さなCookieアイコンがあるはずです。

00:20:36.000 --> 00:20:40.000
しかし、ここにはそのようなアイコンはありません。つまり、クッキーは送信されませんでした。

00:20:40.000 --> 00:20:41.000
だから、その部分は機能していません。

00:20:41.000 --> 00:20:47.000
問題は、サーバーがクッキーを提供しなかったのか、それともクライアントがクッキーを受け取ったにもかかわらず、クッキーを送信していないのかということです。

00:20:47.000 --> 00:20:53.000
調べるには、以前のトランザクションを調査し、サーバーからクッキーを受け取ったかどうかを確認する必要があります。

00:20:53.000 --> 00:20:58.000
これが前のトランザクションで、最初のログインリクエストから成功したトランザクションです。

00:20:58.000 --> 00:21:05.000
これには、トランザクションラベルの応答部分にクッキーアイコンが表示されているため、サーバーはクッキーを送信しました。

00:21:05.000 --> 00:21:07.000
それは面白いですね。

00:21:07.000 --> 00:21:10.000
では、なぜ次の取引でクッキーを送信しなかったのですか?

00:21:10.000 --> 00:21:25.000
このトランザクションに関する詳細情報を入手し、クッキーを詳細に調査するには、下部の詳細ビューの「トランザクション」リストに切り替えます。

00:21:25.000 --> 00:21:32.000
タイムカーソルがトラックビューの内側に配置されるため、トランザクションはすでにここで選択されています。

00:21:32.000 --> 00:21:40.000
右下の拡張詳細ビューには、現在選択されているトランザクションのすべての要求ヘッダーと応答ヘッダーが表示されます。

00:21:40.000 --> 00:21:43.000
そして、これが私たちが期待するSet-Cookieヘッダーです。

00:21:43.000 --> 00:21:47.000
一見すると、このクッキーは大丈夫そうです。

00:21:47.000 --> 00:21:49.000
しかし、ああ、待って、有効期限が見えますか？

00:21:49.000 --> 00:21:52.000
2020年3月です。それは過去のことだ！

00:21:52.000 --> 00:21:56.000
そのため、サーバーはクッキーを送信しましたが、期限切れのクッキーです。

00:21:56.000 --> 00:21:59.000
期限切れのクッキーが好きな人はいない!

00:21:59.000 --> 00:22:05.000
これにより、まだ有効なクッキーのみを送信するため、URLSessionはクッキーを送信しません。

00:22:05.000 --> 00:22:07.000
これはサーバー側のバグです。

00:22:07.000 --> 00:22:12.000
トレースファイルをサーバーの担当者に送信して、問題を調査して解決してもらうことができます。

00:22:12.000 --> 00:22:18.000
クッキーの問題を修正したので、ログインを求められることなく、さらに数枚の写真をお気に入りにすることができます。

00:22:18.000 --> 00:22:25.000
「最新」タブに加えて、「お気に入り」タブもあり、ユーザーがお気に入りにしたすべての犬の画像のリストを表示します。

00:22:25.000 --> 00:22:28.000
そのタブに切り替えましょう。

00:22:28.000 --> 00:22:34.000
素晴らしい、ここには昨日追加したお気に入りがいくつかありますが、何らかの理由で、私の最近のお気に入りは表示されません。

00:22:34.000 --> 00:22:36.000
もう一度やってみましょう。

00:22:36.000 --> 00:22:40.000
お風呂を楽しんでいるように見えるこの犬を選んで、私に好きにさせましょう。

00:22:40.000 --> 00:22:45.000
私のお気に入りに戻って、それが表示されるかどうか確認しましょう。

00:22:45.000 --> 00:22:46.000
うーん、まだそこにはありません。

00:22:46.000 --> 00:22:50.000
もう一度インスツルメンツを使って、何が起こっているのかを把握しましょう。

00:22:50.000 --> 00:22:52.000
私はすでにこれのためのトレースファイルを準備しました。

00:22:52.000 --> 00:22:59.000
トラックビューでお気に入りのリストを読み込むタスクを見つけることを期待していますが、一見すると表示されません。

00:22:59.000 --> 00:23:06.000
サーバードメインのトラックを選択して、そのドメインに発行されたリクエストのみを表示させてください。

00:23:06.000 --> 00:23:12.000
次に、このドメインのすべてのタスクのリストを含む下部の詳細ビューに移動できます。

00:23:12.000 --> 00:23:14.000
ここにはかなりの数のリクエストがあります。

00:23:14.000 --> 00:23:27.000
左下の詳細フィルターを使用して、「お気に入り」に関連するすべてのリクエストを検索して、リクエストを行ったかどうかを確認できます。

00:23:27.000 --> 00:23:32.000
フィルタリングすると、結果は、ここにお気に入りのリストをロードするためにいくつかのリクエストを送信したことを示しています。

00:23:32.000 --> 00:23:36.000
トラックビューに集中しましょう。

00:23:36.000 --> 00:23:45.000
カーソルは、詳細ビューで選択したタスクの開始時に配置されたので、上記のトラックビューでかなり簡単に見つけることができます。

00:23:45.000 --> 00:23:55.000
ズームインして再確認しましょう。

00:23:55.000 --> 00:23:59.000
だから、最初のアプリの起動時にお気に入りのリストを読み込んだのはこれが初めてでした。

00:23:59.000 --> 00:24:06.000
これで大丈夫です。

00:24:06.000 --> 00:24:15.000
ここで、私は新しい画像をお気に入りにし、その後、私たちは再びお気に入りをロードしました。

00:24:15.000 --> 00:24:25.000
さて、ここにはタスクの間隔がありますが、とても短いです。

00:24:25.000 --> 00:24:27.000
ええ、このGETリクエストは数ミリ秒しかかかりませんでした。

00:24:27.000 --> 00:24:30.000
それはサーバーの応答を得るには速すぎます。

00:24:30.000 --> 00:24:40.000
詳細については、もう一度「接続によるHTTPトランザクション」ビューに切り替えましょう。

00:24:40.000 --> 00:24:45.000
最初に気付いたのは、このトランザクションは接続ではなく、「ローカルキャッシュ」で実行されるということです。

00:24:45.000 --> 00:24:51.000
これは、リクエストがネットワーク上で送信されたのではなく、ローカルキャッシュからロードされたことを示しています。

00:24:51.000 --> 00:24:59.000
これは、トランザクションがサーバーを待たなかったため、「応答待ち」状態がない理由も説明しています。

00:24:59.000 --> 00:25:05.000
それが問題です。リクエストはキャッシュされているため、実際にサーバーに尋ねることはなく、常にキャッシュされた応答を取り戻します。

00:25:05.000 --> 00:25:10.000
これを修正する1つの方法は、この応答を決してキャッシュしないために、キャッシュ制御ヘッダーを設定するようにサーバーに指示することです。

00:25:10.000 --> 00:25:17.000
私たちが望むのは、ユーザーがお気に入りタブに移動し、新しい画像が追加されるたびに画像をリロードすることです。

00:25:17.000 --> 00:25:22.000
私たちが望まないのは、そのような変更がなければ、画像のリスト全体を読み込むことです。

00:25:22.000 --> 00:25:27.000
良いトレードオフは、サーバーに「ねえ、何か変わったことはありますか?」と尋ねることができればです。

00:25:27.000 --> 00:25:30.000
もしそうなら、私に知らせてください。

00:25:30.000 --> 00:25:35.000
これは実際には、リクエストにキャッシュポリシーを設定することでできることです。

00:25:35.000 --> 00:25:48.000
コードを更新するには、タスクビューに戻り、問題のタスクを選択します。

00:25:48.000 --> 00:25:54.000
ここで実行された各URLSessionタスクについて...

00:25:54.000 --> 00:26:01.000
タスクで「再開」が呼び出されたバックトレースを右側に表示します。

00:26:01.000 --> 00:26:04.000
メソッド同期、ImageCollectionタイプで再開されました。

00:26:04.000 --> 00:26:09.000
ここで変更を加えるために、Xcodeでこれを開きましょう。

00:26:09.000 --> 00:26:15.000
ここで、私はURLRequestを持っています、そして今、私はキャッシュポリシーを設定したいです。

00:26:15.000 --> 00:26:25.000
必要なキャッシュポリシーはreloadRevalidatingCacheDataです。つまり、ローカルキャッシュを無視し、キャッシュがまだ有効かどうかを確認するためにサーバーに要求します。

00:26:25.000 --> 00:26:31.000
その場合、サーバーは304応答コードを送信し、ローカルキャッシュの使用を知らせます。

00:26:31.000 --> 00:26:34.000
そうでない場合は、新しいデータが返送されます。

00:26:34.000 --> 00:26:47.000
試してみましょう。 

00:26:47.000 --> 00:26:51.000
だから、これらは私の現在のお気に入りの画像であり、お風呂に入る犬が追加されました。

00:26:51.000 --> 00:26:55.000
もう1つ追加しましょう。

00:26:55.000 --> 00:26:58.000
では、「お気に入り」タブをチェックしてみましょう。

00:26:58.000 --> 00:27:01.000
先ほどお気に入りにした画像が正しく表示されます。

00:27:01.000 --> 00:27:04.000
OK、いいね！それも今修正されています。

00:27:04.000 --> 00:27:09.000
同僚のKacperに戻って、アプリと依存関係が期待どおりに動作するかどうかを確認することをカバーしています。

00:27:09.000 --> 00:27:17.000
Sergioが前に示したように、ログインせずに「お気に入り」タブをクリックすると、ログインビューが表示されます。

00:27:17.000 --> 00:27:22.000
ログイン体験をシームレスにするために、すでにAppleでサインインを追加しました。

00:27:22.000 --> 00:27:33.000
しかし、当社はいくつかのペットをテーマにしたアプリを持っており、別のチームは、ユーザーがアプリケーション間でアカウントを再利用できるように、共有ログインSDKに取り組んでいます。

00:27:33.000 --> 00:27:41.000
このSDKは現在開発中であり、他のチームは、従来のログイン画面を置き換えることができるかどうかを尋ねました。

00:27:41.000 --> 00:27:51.000
ペットと呼ばれるSDKバイナリを手に入れました。これは、すべてのプラットフォームで使用できるように、xcframeworkとして配布されています。

00:27:51.000 --> 00:27:58.000
Xcodeプロジェクトに統合するのは、埋め込みフレームワークセクションにドラッグアンドドロップするのと同じくらい簡単です。

00:27:58.000 --> 00:28:03.000
さて、残っているのは、既存のビューにボタンを追加することだけです。

00:28:03.000 --> 00:28:09.000
Log-inViewのソースコードに移動します。

00:28:09.000 --> 00:28:20.000
まずフレームワークをインポートしてから、Appleでサインインのすぐ下にあるSwiftUI VStackにボタンを追加します。

00:28:20.000 --> 00:28:25.000
Swift UIプレビューをリフレッシュしましょう。

00:28:25.000 --> 00:28:26.000
ここにあります。

00:28:26.000 --> 00:28:31.000
「ペットでサインイン」ボタンがプレビューに表示され、まさに私が望む場所でした。

00:28:31.000 --> 00:28:34.000
それは確かに、本当に簡単な統合でした。

00:28:34.000 --> 00:28:37.000
この新しいログイン方法がどれだけ速くなるか知りたいです。

00:28:37.000 --> 00:28:50.000
そして、これを測定するために、製品プロファイルアクションを使用してインスツルメンツでアプリケーションをプロファイリングします。

00:28:50.000 --> 00:28:53.000
ネットワークテンプレートを選択しています。

00:28:53.000 --> 00:29:03.000
そして、ツールバーの「録画」ボタンをクリックしてアプリを起動します。

00:29:03.000 --> 00:29:05.000
私のアプリが起動しました。

00:29:05.000 --> 00:29:08.000
ログインビューに切り替えることができます。

00:29:08.000 --> 00:29:13.000
機器は、その間に発生するすべてのネットワークトラフィックを表示しています。

00:29:13.000 --> 00:29:19.000
私はそれを拡張して、アプリのURLセッションを検査します。

00:29:19.000 --> 00:29:20.000
ここにあります。

00:29:20.000 --> 00:29:22.000
でも待って。

00:29:22.000 --> 00:29:33.000
メインアプリのURLSessionだけがここにあることを期待していますが、統合したばかりのPetsフレームワークは、ログインボタンをクリックすることなく、独自のセッションからリクエストをしているようです。

00:29:33.000 --> 00:29:35.000
それは予想外です。

00:29:35.000 --> 00:29:42.000
今すぐ録音を停止して、さらに調査しましょう。

00:29:42.000 --> 00:29:50.000
オプションをクリックしてドラッグして、いくつかの最初のリクエストにズームインします。

00:29:50.000 --> 00:30:03.000
いくつかの分析エンドポイントには多くのリクエストがあり、詳細を取得するには、この「ペットサインオンネットワーク」セッションをクリックして、詳細ビューにそれらをすべて一覧表示することができます。

00:30:03.000 --> 00:30:16.000
それらはすべてPOSTリクエストであり、1つをクリックすると、リクエストがコードのどの部分から発信されたかを示す右側のバックトレースが表示されます。

00:30:16.000 --> 00:30:22.000
だから、その要求は予想通り、ペットによって呼び出されたCFNetworkを通過しているようです。

00:30:22.000 --> 00:30:27.000
しかし、より深くナビゲートすると、CoreLocationが関与しているように見えます。

00:30:27.000 --> 00:30:33.000
特に私はそれをトリガーするためのアクションを実行しなかったので、それは本当に疑わしいです。

00:30:33.000 --> 00:30:42.000
私の場所がサーバーに送り返されているのだろうか、それがCoreLocationとCFNetworkが同じバックトレースにある理由です。

00:30:42.000 --> 00:30:48.000
これらのタスクの対応するHTTPトランザクションを検査することで、それを検証します。

00:30:48.000 --> 00:30:54.000
これを行うには、詳細をタスクのリストからトランザクションのリストに切り替えます。

00:30:54.000 --> 00:30:58.000
そして、そのうちの1つを選択してください。

00:30:58.000 --> 00:31:06.000
右下の拡張された詳細では、この要求にかなり標準的なヘッダーが含まれていることが明らかで、心配する必要はありません。

00:31:06.000 --> 00:31:09.000
しかし、待って、リクエストボディを見てください。

00:31:09.000 --> 00:31:13.000
それは私の位置座標を含み、それは本当に悪いです。

00:31:13.000 --> 00:31:17.000
この情報を送信すると、ユーザーのプライバシーが侵害されます。

00:31:17.000 --> 00:31:22.000
私たちは、彼らの同意と正当な理由なしに彼らの場所を集めたくありません。

00:31:22.000 --> 00:31:29.000
これまでのところ、私たちのアプリは、ユーザーエクスペリエンスをより良くする正当な目的のためにのみこの許可を要求しています。

00:31:29.000 --> 00:31:34.000
現時点では、このSDKの統合についてはこれ以上進みません。

00:31:34.000 --> 00:31:41.000
代わりに、他のチームにバグレポートを提出して、私が検出したこの容認できない行動について知らせます。

00:31:41.000 --> 00:31:47.000
また、このInstrumentsトレースを使用して、バグレポートに必要な情報を生成することもできます。

00:31:47.000 --> 00:31:51.000
まず私のデスクトップに保存しましょう。

00:31:51.000 --> 00:31:58.000
私はそれを「PrivacyViolation」と名付け、「保存」を押します。

00:31:58.000 --> 00:32:11.000
Instrumentsにバンドルされているコマンドラインツールであるxctraceは、このトレースをHTTPトラフィックに関する情報交換の業界標準であるHTTPアーカイブ形式にエクスポートするために使用できます。

00:32:11.000 --> 00:32:20.000
これを行うには、トレースの入力とHARエクスポートフラグを使用して、xctraceエクスポートコマンドを実行するだけです。

00:32:20.000 --> 00:32:24.000
今それを実行しましょう。

00:32:24.000 --> 00:32:28.000
このコマンドは、バグレポートに添付できるファイルを生成します。

00:32:28.000 --> 00:32:38.000
それを受け取った人は、機器がマシンにインストールされていなくても、HARをサポートするツールで記録された情報を検査することができます。

00:32:38.000 --> 00:32:46.000
HAR自体はJSONベースの形式であるため、テキストエディタで開いたり、スクリプトを使用して簡単に処理することもできます。

00:32:46.000 --> 00:32:58.000
また、URLSessionsやバックトレースなどの機器固有の詳細は含まれていませんが、他のチームがこの問題を調査するには十分なはずです。

00:32:58.000 --> 00:33:10.000
そして、HTTPトラフィックインストゥルメントを使用して、アプリケーションからのトラフィックのソースとコンテンツを診断し、実行時にアプリが何をするかを制御できることを確認する方法です。

00:33:10.000 --> 00:33:21.000
新しいHTTPトラフィックインストゥルメントの使用に慣れたので、今日お見せしたように、問題を検出するためにアプリをターゲットにしてください。

00:33:21.000 --> 00:33:29.000
デバッグを容易にし、コンテキストを増やすには、URLSessionとタスクオブジェクトに名前を付けてください。

00:33:29.000 --> 00:33:33.000
常に最新のネットワークプロトコルの採用を目指してください。

00:33:33.000 --> 00:33:44.000
また、アプリのパフォーマンスや正確性の問題が見つからない場合でも、不要なトラフィックを取り除くために送信するデータの量を確認してください。

00:33:44.000 --> 00:33:50.000
今日はご覧いただきありがとうございます。アプリのHTTPトラフィックを追跡して楽しい時間を過ごせることを願っています。

00:33:50.000 --> 23:59:59.000
[明るい音楽]。

