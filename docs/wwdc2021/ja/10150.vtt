WEBVTT

00:00:00.000 --> 00:00:05.000
♪ベース音楽の演奏♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:12.000
アリ・デ・ヨング：WWDC 2021へようこそ。

00:00:12.000 --> 00:00:16.000
私の名前はアリ・デ・ヨングで、アップルのGPUソフトウェアエンジニアです。

00:00:16.000 --> 00:00:23.000
そして今日、同僚のデビッド・ヌニェス・ルビオと一緒に、メタルレイトレーシングによるハイブリッドレンダリングを探ります。

00:00:23.000 --> 00:00:43.000
まず、レイトレーシングがビジュアルにもたらすことができるいくつかの改善点をお見せします。次に、「ハイブリッドレンダリング」と呼ばれる技術を使用して、レイトレーシングパスをラスタライズに組み込む方法について説明します。その後、デビッドはレイトレーシングを実装するのに役立つ新しいツールを紹介します。

00:00:43.000 --> 00:00:48.000
まず、レイトレーシングの素晴らしいユースケースを見てみましょう。

00:00:48.000 --> 00:00:57.000
ゲームや映画は、増え続けるリアリズムを絶えず追求しており、長年にわたり、グラフィックスへのアプローチはラスタライズによって行ってきました。

00:00:57.000 --> 00:01:01.000
ラスタライズは、リアルタイムのレートで美しい画像を生成するのに最適です。

00:01:01.000 --> 00:01:04.000
しかし、私たちが達成できることには限界があります。

00:01:04.000 --> 00:01:11.000
レイトレーシングは、シェーダーから世界を照会し、新しいエキサイティングな技術への扉を開くことを可能にするメカニズムです。

00:01:11.000 --> 00:01:16.000
そして、それをラスタライズと組み合わせることで、ビジュアルを大幅に改善することができます。

00:01:16.000 --> 00:01:19.000
いくつかの例を見てみましょう。 いくつか見てみましょう。

00:01:19.000 --> 00:01:23.000
ラスタイズにとって常に問題となっている領域の1つは、反射です。

00:01:23.000 --> 00:01:34.000
これは、ラスタライズされたピクセルをシェーディングするときに、正確な反射のためのシーンの残りの部分のコンテキストがなく、その情報を生成するために余分な作業を行う必要があるためです。

00:01:34.000 --> 00:01:39.000
レイトレーシングを使用すると、シェーディングされているピクセルからアレイをトレースし、世界にあるものを発見することができます。

00:01:39.000 --> 00:01:48.000
さらに良いことに、このプロセスを再帰的に適用して、反射に正しい影、さらには反射を適用することができます。

00:01:48.000 --> 00:01:51.000
レイトレーシングが優れているもう1つの分野は影です。

00:01:51.000 --> 00:02:00.000
ラスタライズ、シャドウの一般的なぼやけ、モペットの湾曲した表面のシャドウマップ解像度によって引き起こされるエイリアシングに注目してください。

00:02:00.000 --> 00:02:07.000
レイトレーシングシャドウはよりシャープで、シャドウバイアスなどの人工的なパラメータを必要とせずにエイリアシングの問題に対処します。

00:02:07.000 --> 00:02:11.000
柔らかい影は、より正確に近似することもできます。

00:02:11.000 --> 00:02:18.000
陰影のある点への閉塞オブジェクトの近さに応じて、より硬いまたは柔らかい影を自然に生成できます。

00:02:18.000 --> 00:02:23.000
ラスタライズでは、サンプリング時にシャドウマップをフィルタリングすることに頼る必要があります。

00:02:23.000 --> 00:02:27.000
しかし、レイトレーシングでは、コーン内の光線をトレースするだけで、この結果を得ることができます。

00:02:27.000 --> 00:02:32.000
最後に、レイトレーシングが私たちのビジュアルを高めることができるもう1つの領域は透明性です。

00:02:32.000 --> 00:02:36.000
これは伝統的に、ラスタライズ技術のために正確に扱うのは非常に困難です。

00:02:36.000 --> 00:02:42.000
この画像では、日光が窓からどのように入ってくるかに注目しますが、ガラスの不透明な文字は影を出しません。

00:02:42.000 --> 00:02:48.000
従来のシャドウマッピング技術は、多くの場合、透明なオブジェクトに問題があります。

00:02:48.000 --> 00:02:52.000
レイトレーシングを使用すると、透明な材料のカスタム交差機能を作成できます。

00:02:52.000 --> 00:03:01.000
これにより、どの光線が材料を通過でき、どの光線が通過できないかを定義でき、バストの頭の文字のように自然に投影された影を生成することができます。

00:03:01.000 --> 00:03:05.000
そしてもちろん、すべての影は全体的にシャープに見えます。

00:03:05.000 --> 00:03:10.000
では、なぜレイトレーシングが私たちのビジュアルを劇的に改善できるのでしょうか?

00:03:10.000 --> 00:03:15.000
これを理解するために、従来のラスタライズプロセスがどのように機能するかを見てみましょう。

00:03:15.000 --> 00:03:20.000
ラスタライズプロセスでは、メッシュはレンダリングされる金属に送られます。

00:03:20.000 --> 00:03:28.000
それらは頂点シェーダーによって世界とカメラの前に配置され、それらのプリミティブはラスタライザによってピクセル（またはフラグメント）に配置されます。

00:03:28.000 --> 00:03:35.000
これらのピクセルはフラグメントシェーダーによってシェーディングされ、結果は出力画像にブレンドされます。

00:03:35.000 --> 00:03:43.000
ご存知のように、各ピクセルは独立してシェーディングすることができ、並行して動作します。これは、GPUがラスタライズプロセスで非常に優れている理由です。

00:03:43.000 --> 00:03:54.000
しかし、トレードオフは、シェーディングを適用している時点で、シーンの残りの部分のコンテキストを完全に失っており、このピクセルに関連するポイントを取り囲む可能性のあるオブジェクトがわかりません。

00:03:54.000 --> 00:04:01.000
高度なゲームエンジンは、中間情報を生成する追加のレンダリングパスを追加することで、この状況を埋め合わせます。

00:04:01.000 --> 00:04:08.000
フラグメントシェーダーは、そのデータを活用して、ポイントがある幾何学的コンテキストの詳細を近似することができます。

00:04:08.000 --> 00:04:11.000
これがどのように機能するかをもう少し詳しく見てみましょう。

00:04:11.000 --> 00:04:19.000
このテクニックでは、シーンに関する幾何学的情報を画面に直接ではなく、中間テクスチャにラスタライズします。

00:04:19.000 --> 00:04:23.000
これは、アルベド、深さ、またはノーマルのようなものです。

00:04:23.000 --> 00:04:29.000
これは一般に、ジオメトリバッファパスまたは略してGバッファパスと呼ばれます。

00:04:29.000 --> 00:04:38.000
中間テクスチャは、光がシーン内のオブジェクトとどのように相互作用するかを近似するためにスマートなトリックを使用する光近似パスの入力として使用されます。

00:04:38.000 --> 00:04:43.000
いくつかの例は、スクリーン空間アンビエントオクルージョンとスクリーン空間反射です。

00:04:43.000 --> 00:04:53.000
最後のステップでは、私たちの中間アタッチメントは、より滑らかな画像を作るためにノイズ除去またはわずかにぼやけ、すべてが一緒に結合されて最終的な画像を生成します。

00:04:53.000 --> 00:04:59.000
これらの時には精巧なテクニックは画像を改善するのに役立ちますが、それでも単なる近似値です。

00:04:59.000 --> 00:05:06.000
一方、レイトレーシングは、より正確なビジュアルと簡略化されたビジュアル技術を可能にするまったく異なるアプローチを採用しています。

00:05:06.000 --> 00:05:14.000
レイトレーシングでは、メッシュを一度に1つずつ処理する代わりに、シーン全体を網羅する加速構造を構築します。

00:05:14.000 --> 00:05:20.000
それを手に入れたら、GPUは特定の方向に向かって点から光線をトレースし、交差点を見つけることができます。

00:05:20.000 --> 00:05:25.000
これにより、すべてのコンテキストシーン情報にアクセスできます。

00:05:25.000 --> 00:05:30.000
レイトレーシングはレイインタラクションをモデル化するため、レンダリングを超えたアプリケーションもあります。

00:05:30.000 --> 00:05:37.000
オーディオおよび物理シミュレーション、衝突検出、またはAIおよびパスファインディングに使用できます。

00:05:37.000 --> 00:05:49.000
レイトレーシングは非常に強力な技術であるため、レイトレーシングとラスタライズを組み合わせて、それぞれのユニークな利点を得たいと考えています。これは、「ハイブリッドレンダリング」と呼ばれる技術を通じて行うことができます。

00:05:49.000 --> 00:05:55.000
では、ハイブリッドレンダリングフレームの作成方法と、このテクニックのユースケースを見てみましょう。

00:05:55.000 --> 00:06:04.000
ラスタライズされたフレーム図から始めると、レイトレーシングを使用して、光近似パスの一部または全部を置き換えることができます。

00:06:04.000 --> 00:06:14.000
私たちはまだGバッファをラスタライズします - それは私たちの主要な光線の役割を果たします - そして、レイトレーシングを使用して、シーンの残りの部分にクエリすることによって、より現実的に光の特性をシミュレートします。

00:06:14.000 --> 00:06:21.000
私たちはまだノイズを消し、光の構成パスを行いますが、私たちの結果はシーンデータに対してはるかに正確です。

00:06:21.000 --> 00:06:27.000
このフレームアーキテクチャは、多くのハイブリッドレンダリング技術を探求するための良い基盤を提供します。

00:06:27.000 --> 00:06:32.000
Metalを使用してこのようなフレームをエンコードする方法を見てみましょう。

00:06:32.000 --> 00:06:36.000
Gバッファの記入から始めます。

00:06:36.000 --> 00:06:44.000
そのために、レンダリングパスを作成し、Gバッファに記入し、そのテクスチャをパスの添付ファイルとして設定します。

00:06:44.000 --> 00:06:50.000
レンダリングされたコンテンツが後続のパスで使用できるように、画像がメモリに保存されていることを確認します。

00:06:50.000 --> 00:06:56.000
パスを開始し、レンダリングをエンコードし、レンダリングパスを終了します。

00:06:56.000 --> 00:07:00.000
次に、これにレイトレーシングコンピューティングディスパッチを追加します。

00:07:00.000 --> 00:07:07.000
中間テクスチャを作成したら、レイトレーシングパスをエンコードしましょう。

00:07:07.000 --> 00:07:13.000
同じコマンドバッファからコンピューティングパスを作成し、Gバッファテクスチャを入力として設定するようにします。

00:07:13.000 --> 00:07:22.000
デフォルトでは、Metalは書き込みと読み取りの依存関係を追跡するので、同期を気にしすぎることなく、自由にアルゴリズムに集中できます。

00:07:22.000 --> 00:07:29.000
これは計算なので、レイトレーシング作業の結果を書き込むために出力テクスチャを設定します。

00:07:29.000 --> 00:07:33.000
レイトレーシング技術のためにPipelineStateオブジェクトを設定しました。

00:07:33.000 --> 00:07:39.000
計算シェーダーの各スレッドは、ピクセルまたは領域のレイトレーシング結果を計算します。

00:07:39.000 --> 00:07:45.000
最後に、2Dグリッドを派遣し、このパスを終了します。

00:07:45.000 --> 00:07:57.000
このパスがエンコードされた後、光蓄積パスなどのより多くの作業をエンコードし続けるか、コマンドバッファを送信して、フレームの残りの部分をエンコードしながらGPUが作業を開始することができます。

00:07:57.000 --> 00:08:06.000
作業を2つのパスでエンコードしたため、パスが相互に通信するために、中間レンダリングアタッチメントをシステムメモリに保存する必要があります。

00:08:06.000 --> 00:08:14.000
これは機能しますが、Apple SiliconとiOSデバイスでは、これをさらに良くする機会があります。

00:08:14.000 --> 00:08:20.000
Apple GPUでは、ハードウェアはタイルメモリを利用して、作業中にピクセルデータを保持します。

00:08:20.000 --> 00:08:27.000
パスの最後に、このタイルメモリはシステムメモリに肉付けされ、次のパスの開始時にリロードする必要があります。

00:08:27.000 --> 00:08:35.000
しかし、理想的には、システムメモリへの往復を避けて、計算パスをタイルメモリで直接動作させるでしょう。

00:08:35.000 --> 00:08:41.000
今年は、レンダリングパイプラインからレイトレーシング作業をディスパッチすることで、その機能を追加しました。

00:08:41.000 --> 00:08:49.000
これにより、シングルパスでタイルシェーダーを介してレンダリングと計算を混合して、レイトレーシングにオンタイルメモリを活用することができます。

00:08:49.000 --> 00:08:56.000
これにより、帯域幅の使用、メモリ消費が削減され、ユーザーのデバイスが涼しく動作するのに役立ちます。

00:08:56.000 --> 00:09:13.000
2019年の「Modern rendering with Metal」セッションを必ず確認して、レンダリングと計算を効率的にミックスする方法を学んでください。これにより、レンダリングからレイトレーシングに適用できます。今年の「メタルレイトレーシングでアプリを強化する」セッションでは、今年のメタルレイトレーシングの他の改善点について学んでください。

00:09:13.000 --> 00:09:20.000
ハイブリッドレンダリングワークロードをエンコードする方法がわかったので、レイトレーシングで改善できるテクニックをいくつか確認しましょう。

00:09:20.000 --> 00:09:25.000
影、周囲の閉塞、反射に焦点を当てます。

00:09:25.000 --> 00:09:28.000
影から始めましょう。

00:09:28.000 --> 00:09:32.000
影は、シーン内のオブジェクトの近接性を伝えるのに役立ちます。

00:09:32.000 --> 00:09:38.000
しかし、シェーディング時にシーンのコンテキストを失うため、これはラスタライズの課題です。

00:09:38.000 --> 00:09:46.000
シャドウマッピングは、この情報不足を補うのに役立ちますが、各光の観点から追加のレンダリングが必要です。

00:09:46.000 --> 00:09:51.000
このラスタライズ技術は、すべての光の視点からシーンをレンダリングすることから始まります。

00:09:51.000 --> 00:09:57.000
これにより、各光の変換行列と一緒に保存する必要がある一連の深度マップが生成されます。

00:09:57.000 --> 00:10:01.000
次に、メインカメラの視点からレンダリングします。

00:10:01.000 --> 00:10:05.000
各ピクセルをシェーディングするには、点を光の座標に変換する必要があります。

00:10:05.000 --> 00:10:14.000
深度マップから来る深さをサンプリングし、最終的にこれらの深さ値を比較して、各光源の光と影のどちらにあるかを判断します。

00:10:14.000 --> 00:10:17.000
このテクニックにはいくつかの欠点があります。

00:10:17.000 --> 00:10:21.000
まず、各光の光の視点からシーンをレンダリングする必要があります。

00:10:21.000 --> 00:10:24.000
これは、シーンを複数回処理することを意味します。

00:10:24.000 --> 00:10:36.000
第二に、シャドウマップには所定の解像度があります。つまり、影はエイリアシングの対象となります。さらに悪いことに、画像に収まらないピクセルの情報はありません。

00:10:36.000 --> 00:10:39.000
これをレイトレースされた影と比較してみましょう。

00:10:39.000 --> 00:10:48.000
レイトレーシングで影を計算するには、光源の方向に向かって点から光線をトレースし、物体がその経路を塞いでいるかどうかを判断することができます。

00:10:48.000 --> 00:10:54.000
何も見つからない場合、それはポイントがシェーディングのためにこの光源を考慮する必要があることを意味します。

00:10:54.000 --> 00:11:01.000
オブジェクトが経路をブロックしている場合は、照明方程式でその光源の寄与を除外するだけです。

00:11:01.000 --> 00:11:07.000
これが、閉塞するオブジェクトのシルエットに対応する自然な影を生成する方法に注目してください。

00:11:07.000 --> 00:11:11.000
さらに良いことに、私たちはもはや深度マップに保存されている情報に限定されません。

00:11:11.000 --> 00:11:17.000
光のフラスタムやカメラの視界の外側のポイントの影を決定できます。

00:11:17.000 --> 00:11:21.000
レイトレーシングでシャドウテクニックがどのように簡素化されるかを見てみましょう。

00:11:21.000 --> 00:11:24.000
メインカメラからレンダリングすることから始めます。

00:11:24.000 --> 00:11:33.000
次に、カメラの位置からレンダリングされた加速度構造と深度マップを取り、それをレイトレーシングカーネルに供給します。

00:11:33.000 --> 00:11:45.000
ピクセル位置を計算し、光の方向に光線をトレースするだけです。ここから、閉塞する物体との交点が見つかったかどうかに応じて、点が照らされているか影にあるかを判断します。

00:11:45.000 --> 00:11:52.000
このプロセスでは、シャドウテクスチャが生成され、レンダリングパスの結果と組み合わせて最終的な画像を取得できます。

00:11:52.000 --> 00:11:56.000
これを行うためにメタルシェーダーをコーディングする方法を見てみましょう。

00:11:56.000 --> 00:12:03.000
シェーダーコードでは、各スレッドが深さとthread_idから処理する位置を計算することから始めます。

00:12:03.000 --> 00:12:09.000
計算された位置からシャドウレイを作成し、光の方向にトレースするように設定します。

00:12:09.000 --> 00:12:18.000
ポイントライト、スポットライト、エリアライトなどのほとんどのライトタイプでは、ポイントから光源まで追跡するために最小値と最大値を設定します。

00:12:18.000 --> 00:12:22.000
指向性シャドウの場合、最大値を無限大に設定したい場合があります。

00:12:22.000 --> 00:12:30.000
さらに、より柔らかいシャドウのためにコーンレイトレーシングを実装することにした場合、これはShadowRayにジッターを追加するのに最適な場所です。

00:12:30.000 --> 00:12:33.000
次に、インターセクターオブジェクトを作成します。

00:12:33.000 --> 00:12:40.000
1つの交差点が見つかった場合、それは私たちが影にいることを意味するので、任意の交差点を受け入れるようにインターセクターを設定します。

00:12:40.000 --> 00:12:45.000
最後に、加速構造と交差します。

00:12:45.000 --> 00:12:54.000
その交差結果に基づいて、ポイントが点灯しているかどうかを書き込み、シーンに対してより正確な影のテクスチャを作成します。

00:12:54.000 --> 00:13:02.000
そのシャドウテクスチャが適用されると、はるかにリアルなシャドウを取得し、エイリアスを取り除くことがわかります。

00:13:02.000 --> 00:13:07.000
レイトレーシングでは、影を決定することは非常に自然な技術になります。

00:13:07.000 --> 00:13:11.000
光線をトレースして、何かがその点の光源を遮っているかどうかを調べるだけです。

00:13:11.000 --> 00:13:18.000
中間深度マップを持つ必要がなくなり、ライトごとに複数の余分なレンダリングパスを持つことを避けることができます。

00:13:18.000 --> 00:13:24.000
このテクニックは、深さにのみ依存するため、遅延レンダラーまたはフォワードレンダラーに簡単に実装できます。

00:13:24.000 --> 00:13:29.000
そして最後に、半透明材料のカスタム交差機能を可能にします。

00:13:29.000 --> 00:13:33.000
次に、アンビエントオクルージョンを見てみましょう。

00:13:33.000 --> 00:13:39.000
概念的には、ジオメトリに囲まれた点は、大量の周囲光を受け取る可能性が低い。

00:13:39.000 --> 00:13:51.000
アンビエントオクルージョンは、その近所がどれほど忙しいかに基づいて、ある時点で受信した周囲の光をミュートすることで構成されており、自然に裂け目を暗くし、最終的な画像に深みを与えます。

00:13:51.000 --> 00:14:01.000
これを達成するためのラスタライゼーション技術は、ポイントの近くの深さと法線をサンプリングし、それを囲み、潜在的に閉塞するオブジェクトがあるかどうかを判断します。

00:14:01.000 --> 00:14:10.000
近くの物体の数に基づいて、減衰係数を計算して周囲の光をミュートし、画像に適用するテクスチャを作成します。

00:14:10.000 --> 00:14:20.000
ただし、深度バッファやサーフェス法線などの画面空間情報に頼ると、目に見えないオクルーダーや画像の境界外のオブジェクトの情報が欠落しています。

00:14:20.000 --> 00:14:27.000
レイトレーシングでは、画面空間情報に頼るのではなく、シーンの実際の幾何学的データに頼ることができます。

00:14:27.000 --> 00:14:35.000
アイデアは、すべてのピクセルをシェーディングし、半球でランダムな光線を生成し、オブジェクトに対する交差点を検索することです。

00:14:35.000 --> 00:14:42.000
交差点が見つかった場合は、周囲の閉塞要因を考慮します。

00:14:42.000 --> 00:14:44.000
加速構造からやり直します。

00:14:44.000 --> 00:14:51.000
この手法では、通常のデータと深さが必要なため、Gバッファパスでデータを収集します。

00:14:51.000 --> 00:14:55.000
深さと法線は、半球でランダムな光線を生成するために使用されます。

00:14:55.000 --> 00:14:59.000
次に、光線を追跡し、減衰係数を計算します。

00:14:59.000 --> 00:15:04.000
これにより、裂け目が自然に暗くなる画像が生成され、効果が生まれます。

00:15:04.000 --> 00:15:08.000
アンビエントオクルージョン用のメタルシェーダーを見てみましょう。

00:15:08.000 --> 00:15:11.000
まず、ランダムな光線を生成します。

00:15:11.000 --> 00:15:16.000
この場合、各スレッドの法線に沿ってcosineWeightedRayを取ります。

00:15:16.000 --> 00:15:22.000
小さな近所にしか興味がないため、max_distanceを小さな数に設定しました。

00:15:22.000 --> 00:15:27.000
次に、インターセクターを作成し、加速構造を交差させます。

00:15:27.000 --> 00:15:33.000
結果に応じて、減衰係数に蓄積します。

00:15:33.000 --> 00:15:35.000
これは横並びの比較です。

00:15:35.000 --> 00:15:39.000
そして、レイトレーシングされたアプローチがどれほど良く見えるかをすぐに見ることができます。

00:15:39.000 --> 00:15:44.000
スクリーンスペース効果の限界を本当に示すいくつかの場所を強調したいと思います。

00:15:44.000 --> 00:15:50.000
これは、画面空間の情報が限られているため、近所が誤って表示される例です。

00:15:50.000 --> 00:15:57.000
これは、実際のジオメトリがカメラにほぼ垂直であるため、この角度の深度バッファではないためです。

00:15:57.000 --> 00:16:02.000
同じ問題が画像全体、特にモペットの下で発生します。

00:16:02.000 --> 00:16:06.000
この角度から見ると、モペットの底が深度バッファーから欠けています。

00:16:06.000 --> 00:16:09.000
したがって、スクリーンスペースのテクニックは減衰を完全に見逃します。

00:16:09.000 --> 00:16:16.000
一方、レイトレーシングバージョンは、フロアピクセルのモペットの底に対する交差点を正しく検出します。

00:16:16.000 --> 00:16:21.000
そして、これは画面の境界線に関する制限の素晴らしい例です。

00:16:21.000 --> 00:16:30.000
閉塞ジオメトリはオフスクリーンであるため、その貢献はスクリーンスペース技術で失われますが、レイトレーシングで説明されます。

00:16:30.000 --> 00:16:40.000
ご覧のとおり、ハイブリッドレンダリングは、シーンの実際のジオメトリを使用して大幅な品質改善を提供し、画面空間情報の制限から技術を解放します。

00:16:40.000 --> 00:16:44.000
そして最後に、反省を見てみましょう。 

00:16:44.000 --> 00:16:48.000
反射は伝統的にラスタライズにとって非常に困難でした。

00:16:48.000 --> 00:16:57.000
反射プローブは、うまく機能するが、解像度が限られており、フィルタリングを必要とし、動的ジオメトリに苦労する技術です。

00:16:57.000 --> 00:17:01.000
スクリーン空間反射技術は、スクリーン空間情報によって制限されます。

00:17:01.000 --> 00:17:09.000
反射プローブは、周囲の色情報をキャプチャするために、シーン全体に沿ってカメラを戦略的に配置する必要があるソリューションです。

00:17:09.000 --> 00:17:15.000
反射プローブを使用するには、キューブマップがシーン内のさまざまな場所からキャプチャされます。

00:17:15.000 --> 00:17:20.000
これは本質的に、同じ点から6方向のシーンのレンダリングです。

00:17:20.000 --> 00:17:28.000
ピクセルがシェーディングされると、プローブとの関係を計算し、キューブマップをサンプリングして反射されたシェーディングを生成します。

00:17:28.000 --> 00:17:33.000
現実的な結果を得るには、通常、多くのプローブがシーン全体に散在する必要があります。

00:17:33.000 --> 00:17:41.000
また、動的なオブジェクトがシーンを移動すると、シェーダーは複数のキューブマップからサンプリングし、反射色を手動で補間する必要があります。

00:17:41.000 --> 00:17:49.000
キューブマップはまた、放射照度を正確に表すために事前にフィルタリングする必要があり、解像度が制限されています。

00:17:49.000 --> 00:17:59.000
別のラスタライズ技術である画面空間反射は、すでにフレームバッファにあるピクセルの反射に基づいて、これらの問題のいくつかを回避します。

00:17:59.000 --> 00:18:06.000
フラグメントシェーダーは、法線を使用して徐々に外側に行進し、潜在的な近くのオブジェクトの深度マップをチェックします。

00:18:06.000 --> 00:18:12.000
何かを見つけたら、フレームバッファから直接色をサンプリングし、出力画像にシェーディングします。

00:18:12.000 --> 00:18:18.000
しかし、先ほど説明した画面空間の制限に苦しんでいます。

00:18:18.000 --> 00:18:26.000
このモペットの例では、フレームバッファに存在する床タイルに対応して、表面の一部のみが正確な反射を得ることができることに注意してください。

00:18:26.000 --> 00:18:28.000
シーンの残りの部分が欠けています。

00:18:28.000 --> 00:18:39.000
さらに悪いことに、黄色でマークされたフェンダーの後ろの下部には情報が欠けています。カメラから離れた表面がどのように見えるかを知る方法はありません。

00:18:39.000 --> 00:18:43.000
レイマーチングも計算的に高価になる可能性があります。

00:18:43.000 --> 00:18:52.000
しかし、レイトレーシング反射は、加速構造の真のシーン情報に頼ることができるため、両方の問題を克服するのに役立ちます。

00:18:52.000 --> 00:18:56.000
完璧な鏡がどのように機能するかを見てみましょう。

00:18:56.000 --> 00:19:00.000
まず、カメラの位置からポイントまでインシデント光線を取ります。

00:19:00.000 --> 00:19:04.000
次に、この点をその点に関連する通常の点に反映します。

00:19:04.000 --> 00:19:09.000
これにより、光線をたどり、反射した物体を見つけることができる方向が得られます。

00:19:09.000 --> 00:19:16.000
このため、反射レイトレーシングカーネルにGバッファの法線と深さを提供します。

00:19:16.000 --> 00:19:25.000
このレイトレーシングカーネルは、カメラから各ポイントまでのビューベクトルを計算し、このベクトルを反射し、ポイントからその方向に光線をトレースします。

00:19:25.000 --> 00:19:32.000
最後に、正確な反射のために、レイトレーシングカーネルで直接見つかった交点をシェーディングすることができます。

00:19:32.000 --> 00:19:35.000
このシェーダーのコーディングを見てみましょう。

00:19:35.000 --> 00:19:39.000
もう一度、ポイントの深さから始めて、その位置を再構築します。

00:19:39.000 --> 00:19:43.000
今回は、その地位が世界空間にあることを望んでいます。

00:19:43.000 --> 00:19:49.000
したがって、computePosition関数では、ビュー行列の逆数を乗算する必要があります。

00:19:49.000 --> 00:19:56.000
次に、法線上で反射された入射ベクトルを計算し、その方向に光線を作成します。

00:19:56.000 --> 00:20:02.000
次に、インターセクターを作成し、反射光線を追跡します。

00:20:02.000 --> 00:20:07.000
物体に当たった場合、その点をシェーディングして反射を生成します。

00:20:07.000 --> 00:20:15.000
交差点がすべてのオブジェクトを見逃した場合は、スカイボックスをサンプリングし、その色を返して、空を示す反射をシミュレートすることができます。

00:20:15.000 --> 00:20:21.000
シェーディングは、この手法の計算カーネルで直接実行されることに注意してください。

00:20:21.000 --> 00:20:25.000
反射プローブと光線追跡反射を比較してみましょう。

00:20:25.000 --> 00:20:31.000
右側の画像はハイブリッドレンダリングを使用しており、床タイルの詳細をより明確に見ることができます。

00:20:31.000 --> 00:20:37.000
建物は存在し、モペットのフロントパネルに影が映っているのを見ることさえできます。

00:20:37.000 --> 00:20:40.000
反射はレイトレーシングに自然に適合します。

00:20:40.000 --> 00:20:44.000
鏡のような反射や大まかな反射をうまく処理します。

00:20:44.000 --> 00:20:49.000
これらは、コーンに沿って複数の光線をトレースし、結果をフィルタリングすることによって達成できます。

00:20:49.000 --> 00:21:01.000
彼らは加速構造から来る完璧な情報に依存しているため、レイトレーシング反射はスクリーン空間アーティファクトから解放され、シーンの静的幾何学と動的幾何学の両方を処理できます。

00:21:01.000 --> 00:21:08.000
さて、1つの重要な詳細：反射のために、計算カーネルで直接ポイントをシェーディングする必要があると述べました。

00:21:08.000 --> 00:21:17.000
この1つやグローバルイルミネーションのようないくつかのテクニックでは、コンピューティングカーネルから直接頂点データと金属リソースにアクセスする必要があります。

00:21:17.000 --> 00:21:24.000
このような場合、GPUがシェーディング方程式を適用するために必要なデータにアクセスできることを確認する必要があります。

00:21:24.000 --> 00:21:30.000
これは、Metalで引数バッファとして表されるバインドレスバインディングモデルで達成されます。

00:21:30.000 --> 00:21:36.000
詳細については、今年の「メタルのブロンドレスレンダリング」トークを必ずチェックしてください。

00:21:36.000 --> 00:21:41.000
私たちは、いくつかの異なる技術でハイブリッドレンダリングを実践する方法を見ました。

00:21:41.000 --> 00:21:48.000
これは、より正確な結果を生み出すという利点を持つ、より自然なアルゴリズムにつながります。

00:21:48.000 --> 00:21:58.000
場合によっては、従来のラスタライズ技術と比較すると、レンダリングパスを削除し、場合によってはメモリと帯域幅を節約できることがわかります。

00:21:58.000 --> 00:22:04.000
レンダリングからレイトレーシングを追加することで、作業全体をチップに維持することもできます。

00:22:04.000 --> 00:22:12.000
レイトレーシングの採用は大きな課題であり、これらの技術をエンジンに持ち込むプロセスを支援する優れた新しいツールがあります。

00:22:12.000 --> 00:22:21.000
今年は、レイトレーシング作業をキャプチャし、加速構造を検査し、可視機能と交差機能を検査できるツールを紹介します。

00:22:21.000 --> 00:22:25.000
今、デビッドは私たちにこれらの新しいツールのツアーを提供します。

00:22:25.000 --> 00:22:30.000
デビッド・ヌニェス・ルビオ:ありがとう、アリ。私の名前はデビッド・ヌニェス・ルビオで、GPUソフトウェアエンジニアです。

00:22:30.000 --> 00:22:34.000
昨年、メタルにレイトレーシングサポートを導入しました。

00:22:34.000 --> 00:22:38.000
しかし、複雑なアプリケーションの開発は難しい場合があります。

00:22:38.000 --> 00:22:42.000
幸いなことに、メタルデバッガーはあなたを助けるためにここにいます。

00:22:42.000 --> 00:22:47.000
今年は、メタルデバッガーでレイトレーシングサポートを導入しました。

00:22:47.000 --> 00:22:52.000
ハイブリッドレンダリングの採用のおかげで、私たちのデモはこれまで以上に良くなっています。

00:22:52.000 --> 00:22:58.000
光線でトレースされた柔らかい影、反射、周囲の閉塞。結果は素晴らしいです。

00:22:58.000 --> 00:23:02.000
デモの開発中に、私たちはいくつかの問題にぶつかった。

00:23:02.000 --> 00:23:07.000
これは、ツールがこれらの問題を解決するのに役立つ方法です。

00:23:07.000 --> 00:23:12.000
この初期のバージョンのデモでは、レイトレーシングシャドウがすでに実装されています。

00:23:12.000 --> 00:23:18.000
しかし、よく見ると、地面の木の葉から欠けている影に気づくでしょう。

00:23:18.000 --> 00:23:21.000
参照バージョンと比較すると、より明白です。

00:23:21.000 --> 00:23:26.000
参照とレイトレースを参照してください。

00:23:26.000 --> 00:23:34.000
Xcodeに飛び込んでキャプチャして、ツールがこの問題のデバッグにどのように役立つかを見てみましょう。

00:23:34.000 --> 00:23:39.000
メタルボタンを押して、キャプチャーをクリックする必要があります。

00:23:39.000 --> 00:23:45.000
これは静的な問題なので、必要なフレームは1つだけです。

00:23:45.000 --> 00:23:51.000
デバッガでは、API呼び出しはデバッグナビゲーターの左側に編成されます。

00:23:51.000 --> 00:23:57.000
オフスクリーンコマンドバッファを展開して、シャドウエンコーディングを探しましょう。

00:23:57.000 --> 00:24:02.000
コンピューティングコマンドエンコーダを「Raytrace Shadows」とラベル付けしました。

00:24:02.000 --> 00:24:08.000
メタルデバッガーで簡単に見つけられるように、メタルオブジェクトにラベルを付けるのは良い習慣です。

00:24:08.000 --> 00:24:13.000
サムネイルはまた、確かに、これが私たちが探しているエンコーダであるというヒントを与えてくれます。

00:24:13.000 --> 00:24:19.000
ディスパッチThreadgroups API呼び出しをクリックして、バンドリソースを表示できるようになりました。

00:24:19.000 --> 00:24:25.000
これは、現在のカーネルディスパッチに関連付けられているすべてのオブジェクトのリストです。

00:24:25.000 --> 00:24:31.000
そして、ここでは、私たちが便利にラベル付けした構造の加速を見ることができます。

00:24:31.000 --> 00:24:35.000
私たちのカーネルは、光線をキャストするために加速構造を使用しています。

00:24:35.000 --> 00:24:47.000
これは通常、光線が交差する3D世界を表すツリーのようなデータ構造である境界ボリューム階層またはBVHとして実装されています。

00:24:47.000 --> 00:24:56.000
次に、ダブルクリックして加速度構造ビューアを開きます。

00:24:56.000 --> 00:25:00.000
これは、メタルデバッガーに組み込まれた素晴らしい新しいツールです。

00:25:00.000 --> 00:25:04.000
それがどのように整理されているかの概要を説明しましょう。

00:25:04.000 --> 00:25:14.000
右側には、カスタムジオメトリや交差関数を含む3Dシーンのレイトレースビジュアライゼーションがある3Dビューがあります。

00:25:14.000 --> 00:25:20.000
これは、髪などのカスタムジオメトリやアルファテストを使用する場合に最適です。

00:25:20.000 --> 00:25:25.000
使い慣れたコントロールを使って、カメラを動かしたり、周りを見回したりできます。

00:25:25.000 --> 00:25:31.000
そして、ここにヒントがあります：スクロールしながらOptionキーを押してズームインおよびズームアウトします。

00:25:31.000 --> 00:25:36.000
私たちは、私たちのシーンをよりよく理解するために、いくつかの素晴らしい視覚化ツールを構築しました。

00:25:36.000 --> 00:25:42.000
強調表示されたメニューをクリックして、利用可能なさまざまなモードを見てみましょう。

00:25:42.000 --> 00:25:46.000
たとえば、バウンディングボリュームトラバーサルを視覚化できます。

00:25:46.000 --> 00:25:54.000
これは、サーフェスに当たる前に1つの光線が通過する必要があるノードの数を示すヒートマップです。

00:25:54.000 --> 00:26:02.000
暗い色は、より多くのノードを横断し、交差テストを遅くする必要があることを意味します。

00:26:02.000 --> 00:26:11.000
また、加速度構造に基づいてシーンを色分けすることもできます...

00:26:11.000 --> 00:26:15.000
ジオメトリ...

00:26:15.000 --> 00:26:19.000
インスタンス...

00:26:19.000 --> 00:26:26.000
または交差関数。

00:26:26.000 --> 00:26:31.000
ツールにもう少し慣れたので、元の問題に戻ることができます。

00:26:31.000 --> 00:26:36.000
3Dビューのおかげで、ジオメトリがそこにあることを確認しました。

00:26:36.000 --> 00:26:39.000
だから、何か他のものがあるに違いない。

00:26:39.000 --> 00:26:42.000
左側にはナビゲーターエリアがあります。

00:26:42.000 --> 00:26:47.000
ここでは、トップレベルとボトムレベルの加速構造を見ることができます。

00:26:47.000 --> 00:26:53.000
任意の加速度構造を展開して、それが構築されたジオメトリのリストを見ることができます。

00:26:53.000 --> 00:27:03.000
不透明度やプリミティブカウントなどの特性を見るために再び展開することができます。

00:27:03.000 --> 00:27:07.000
また、この加速構造のインスタンスのリストも見ることができます。

00:27:07.000 --> 00:27:15.000
木の葉をクリックして、ナビゲーターでインスタンスを表示し、そのプロパティを調べましょう。

00:27:15.000 --> 00:27:24.000
マトリックスは正しく見え、フラグは設定されていませんが、マスクに何かが欠けているようです。

00:27:24.000 --> 00:27:27.000
このデモでは、交差点マスクを使用しています。

00:27:27.000 --> 00:27:32.000
マスクの最も低いビットを使用して、影を落とすオブジェクトにフラグを立てます。

00:27:32.000 --> 00:27:40.000
その後、インターセクターは、ビット単位と操作を使用してこのマスクをテストし、失敗した場合は交差を拒否します。

00:27:40.000 --> 00:27:44.000
この動作を3Dビューで直接視覚化できます。

00:27:44.000 --> 00:27:49.000
インターセクターヒントメニューを開く必要があります。

00:27:49.000 --> 00:27:54.000
ここでは、視覚化のためのレイトラバーサルオプションを設定できます。

00:27:54.000 --> 00:28:02.000
カリング操作を変更したり、カスタム交差点を無効にしたり、インターセクターのマスクを変更したりできます。

00:28:02.000 --> 00:28:05.000
デフォルトでは、すべてが交差します。

00:28:05.000 --> 00:28:11.000
シャドウに使っている値に変更しましょう。

00:28:11.000 --> 00:28:19.000
これにより、シャドウマスクを使用する際のシーンの正確な視覚化が表示されます。

00:28:19.000 --> 00:28:24.000
そして実際、私たちは木の葉が欠けていることを確認しました。

00:28:24.000 --> 00:28:33.000
問題を特定したら、ソースに戻り、適切なマスク値を設定していることを確認する必要があります。

00:28:33.000 --> 00:28:37.000
これは影が以前どのように見えたかです。

00:28:37.000 --> 00:28:41.000
そして、これは彼らがマスクの価値を修正した後にどのように見えるかです。

00:28:41.000 --> 00:28:47.000
これは、レイトレーシングアプリケーションのデバッグに役立つワークフローの例です。

00:28:47.000 --> 00:28:58.000
ツールについてもっと知りたい場合は、今年の「金属デバッグ、プロファイリング、資産作成ツールの発見」WWDCセッションをチェックしてください。

00:28:58.000 --> 00:29:03.000
このセッションでは、レイトレーシングがあなたのビジュアルをどのように高めることができるかを見直しました。

00:29:03.000 --> 00:29:08.000
ハイブリッドレンダリングは、ラスタライズとレイトレーシングの組み合わせです。

00:29:08.000 --> 00:29:16.000
これにより、光近似技術を、たまたまより単純なより正確なものに置き換えることができます。

00:29:16.000 --> 00:29:22.000
また、エンジンにレイトレーシングを採用するプロセスを支援する新しいツールも見ました。

00:29:22.000 --> 00:29:31.000
ラスタライズとレイトレーシングを組み合わせることで、どのような新しい可能性が利用できるかについて表面を引っ掻いただけです。

00:29:31.000 --> 00:29:39.000
将来の新しい革新的なグラフィック技術を開発するために、これらの技術をどのように実践するかを見るのが待ちきれません。

00:29:39.000 --> 00:29:43.000
ありがとう、WWDCの残りの部分を楽しんでください。

00:29:43.000 --> 23:59:59.000
♪

