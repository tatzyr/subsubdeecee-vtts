WEBVTT

00:00:00.000 --> 00:00:10.000
みなさん、こんにちは。

00:00:10.000 --> 00:00:15.000
私の名前はシェファリ・サブーで、アップルのパフォーマンスツールエンジニアです。

00:00:15.000 --> 00:00:19.000
一緒にアプリケーションのパフォーマンスをナビゲートする際に、私はあなたのガイドになります。

00:00:19.000 --> 00:00:23.000
今日の旅は、パフォーマンスの世界を巡るスリリングなツアーになります。

00:00:23.000 --> 00:00:29.000
あなたのアプリは、私たちのデバイスでの全体的なソフトウェア体験において重要な役割を果たします。

00:00:29.000 --> 00:00:40.000
アプリを最適化し、パフォーマンスを向上させ続けることは、ユーザーがアプリをより頻繁に使用し、よりエンゲージメントを維持し、アプリを長期間使用することを意味します。

00:00:40.000 --> 00:00:46.000
パフォーマンスの最適化は、追跡する多くの指標と使用するツールを持つ困難な作業のように思えるかもしれません。

00:00:46.000 --> 00:00:47.000
しかし、恐れることはありません。

00:00:47.000 --> 00:00:59.000
このサバイバルガイドでは、開発を次のレベルに引き上げ、可能な限り最高の顧客体験を確保するのに役立つツール、メトリクス、パラダイムをスピードアップします。

00:00:59.000 --> 00:01:07.000
私たちのパフォーマンスツールとあなたがそれらを使ってできる素晴らしいことを歩きながら、あなたのガイドになることにとても興奮しています。

00:01:07.000 --> 00:01:18.000
今日取り上げる5つの主要なツールがあります。Xcode Organizer、MetricKit、Instruments、XCTest、App Store Connect APIです。

00:01:18.000 --> 00:01:23.000
主要な指標を簡単に紹介することから始めます。

00:01:23.000 --> 00:01:31.000
次に、各ドメイン領域の一般的な問題と、それらを解決して防止する方法について説明します。

00:01:31.000 --> 00:01:34.000
そして最後に、次のステップで終わります。

00:01:34.000 --> 00:01:38.000
パフォーマンスの最適化は、多くの停留所がある長い川のようなものです。

00:01:38.000 --> 00:01:44.000
ナビゲーションに必要ないくつかの異なるツールがあり、各停留所で学ぶべき新しい何かがあります。

00:01:44.000 --> 00:01:47.000
川を下って旅行しましょう。

00:01:47.000 --> 00:01:49.000
まず、簡単な紹介です。

00:01:49.000 --> 00:01:54.000
今日取り上げるさまざまなパフォーマンス指標を見てみましょう。 

00:01:54.000 --> 00:02:07.000
現在、アプリケーションのパフォーマンスを追跡するには、バッテリー使用量、起動時間、ハングレート、メモリ、ディスク書き込み、スクロール、終端、MXSignpostsの8つの重要なポイントがあります。

00:02:07.000 --> 00:02:10.000
これらはすべて、当社のツールセットを通じて追跡できます。

00:02:10.000 --> 00:02:19.000
私は、ユーザーがその週の食事を追跡し、クールなレシピを保存できるMealPlannerというアプリの開発者です。

00:02:19.000 --> 00:02:26.000
これは、特にスクロールヒッチの形で、私のアプリ内の貧弱なユーザーエクスペリエンスの例です。

00:02:26.000 --> 00:02:31.000
遅い、スキップする、そして不安なスクロールに気づきましたか?

00:02:31.000 --> 00:02:38.000
反対に、これはシームレスなユーザーエクスペリエンスとヒッチのない同じアプリケーションです。

00:02:38.000 --> 00:02:49.000
私たちはすでに2つの経験の間にかなりの違いがあることがわかります、そしてこのスムーズなスクロールは、あなたがパフォーマンスの最適化を通じて達成するのを助けたいものです。

00:02:49.000 --> 00:02:54.000
各パフォーマンスメトリックには、独自のパラダイムセットと共通のツールがあります。

00:02:54.000 --> 00:03:00.000
各ドメイン領域の一般的な問題と、それらを解決して防止する方法に飛び込みましょう。

00:03:00.000 --> 00:03:05.000
川沿いの最初の停留所はバッテリー使用量です。

00:03:05.000 --> 00:03:09.000
アプリが多くのバッテリーを消耗している場合、ユーザーが自分の側で見るものは次のとおりです。

00:03:09.000 --> 00:03:12.000
これはバッテリーUIです。

00:03:12.000 --> 00:03:22.000
これは、デバイス上のアプリの全体的なバッテリー消耗がどの程度貢献したか、およびフォアグラウンドとバックグラウンドアクティビティをユーザーに示します。

00:03:22.000 --> 00:03:24.000
なぜバッテリー寿命の向上を気にする必要があるのですか?

00:03:24.000 --> 00:03:26.000
簡単。

00:03:26.000 --> 00:03:32.000
ユーザーは、充電を必要とせずに一日中デバイスを使用できるアプリの使用を優先します。

00:03:32.000 --> 00:03:38.000
バッテリー寿命を最適化することで、ユーザーは自分のデバイスとアプリを長期間使用できます。

00:03:38.000 --> 00:03:41.000
それ自体が勝利です。

00:03:41.000 --> 00:03:47.000
バッテリー寿命の最適化に関しては、注意すべき多くの異なるサブシステムがあります。

00:03:47.000 --> 00:03:53.000
メモする上位3つは、CPU、ネットワーク、およびロケーションです。

00:03:53.000 --> 00:04:01.000
開発中またはバージョンがすでにリリースされた後、いくつかの異なるツールを使用して、アプリのバッテリー寿命を追跡してトリアージすることができます。

00:04:01.000 --> 00:04:15.000
デスクで新機能を開発およびテストしている間、Xcodeを使用してコードをビルドして実行し、小さなスプレーボトルのように見えるデバッグナビゲーターをクリックして、Xcodeが提供するさまざまなゲージを確認します。

00:04:15.000 --> 00:04:18.000
私が細心の注意を払うのはエネルギーゲージです。

00:04:18.000 --> 00:04:30.000
エネルギーゲージを使用すると、アプリをテストしているときにCPU使用率を追跡でき、CPU使用率の高い領域とCPUウェイクオーバーヘッドが表示されます。

00:04:30.000 --> 00:04:42.000
高いCPU使用率とは、CPU使用量が20%を超える場合であり、CPUウェイクオーバーヘッドは、CPUがアイドル状態からウェイクし、発生するエネルギーコストが発生する領域です。

00:04:42.000 --> 00:05:00.000
アプリがユーザーインターフェイスを描画したり、ネットワークからデータを処理したり、計算を実行したりすると、CPUが急増するのが一般的ですが、これらのタスクが完了し、アプリがユーザーが次のアクションを実行するのを待っていると、CPU使用率がゼロまたはゼロに近いことがわかります。

00:05:00.000 --> 00:05:11.000
ここから、タイムプロファイルをクリックして、Instrumentsでアプリをプロファイリングし、プロファイリングされた期間のサーマル状態、CPU使用率、およびアクティブなコールスタックを確認することもできます。

00:05:11.000 --> 00:05:20.000
また、ロケーションエネルギーモデルを使用して、コアロケーションの影響を測定し、アプリが使用すべきでないときに場所を使用していないことを確認することもできます。

00:05:20.000 --> 00:05:31.000
時折、私のアプリのベータ版またはリリース版にバグがあり、私の机で再現するのが難しいか、デバッグするためにより多くのロギングとコンテキストが必要な場合があります。

00:05:31.000 --> 00:05:45.000
オールインワンのパフォーマンステレメトリフレームワークとしてデバイス上で動作するMetricKitは、根本原因を絞り込み、顧客が直面している問題について貴重な洞察を提供するのに役立ちます。

00:05:45.000 --> 00:05:57.000
MetricKitを使用するには、アプリにAppMetricsというカスタムクラスを追加して実装し、この新しいクラスをMXMetricManagerSubscriberプロトコルに適合させるだけです。

00:05:57.000 --> 00:06:02.000
その後、カスタムクラスへの参照をマネージャーに追加できます。

00:06:02.000 --> 00:06:08.000
そして、推奨されるベストプラクティスであるdeinitに関する私のカスタムクラスへの参照を削除します。

00:06:08.000 --> 00:06:13.000
このデータは、対応するdidReceiveメソッドで処理できます。

00:06:13.000 --> 00:06:25.000
戦略的に行われれば、エネルギーログやCPUメトリックなど、オーガナイザーで見つけるのと同じデータの多くを、問題が発生したときに何が間違っていた可能性があるかについてのMemetricKitのコンテキストデータで拡張できます。

00:06:25.000 --> 00:06:33.000
オンデバイス分析パイプラインのおかげで、このデータのシンプルなバージョンは、余分な労力なしで利用できます。

00:06:33.000 --> 00:06:38.000
ユーザーがアプリを使用する際に、同意したデバイスからパフォーマンスデータを収集します。

00:06:38.000 --> 00:06:45.000
このデータは、当社のサーバーに集約され、Xcodeオーガナイザーなどの多くのツールの1つを介してお客様に返送されます。

00:06:45.000 --> 00:07:00.000
Xcodeオーガナイザーにアクセスして、すでにアプリストアにあるアプリのバージョンのパフォーマンスデータを見るのは、Xcodeが開いている間にメニューバーに移動し、ウィンドウに移動し、オーガナイザーをクリックして起動するのと同じくらい簡単です。

00:07:00.000 --> 00:07:13.000
ここに来たら、バッテリー使用量メトリックをクリックして、過去16のアプリバージョンのアプリの集計データと、チャートの右側にある主要なサブコンポーネント別の詳細な内訳を表示できます。

00:07:13.000 --> 00:07:25.000
私のアプリの最新バージョンに大きな回帰がある場合、Xcode 13で新しい回帰ペインに移動すると、バージョンがオーガナイザーに表示された直後にわかります。

00:07:25.000 --> 00:07:36.000
この新しい回帰ペインは、私のアプリの最新バージョンで大幅に増加したすべてのメトリクスを分離するので、集中する必要があるすべてのものを1か所で見ることができます。

00:07:36.000 --> 00:07:49.000
アプリのどの領域が問題を引き起こしたかを判断するために、レポートの下のEnergy Organizerを使用して、CPU使用率の高い地域と、同意したユーザーデバイスから収集されたログを表示することもできます。

00:07:49.000 --> 00:07:53.000
これにより、私のアプリで何が起こっていたのかをより詳細に見ることができます。

00:07:53.000 --> 00:08:04.000
App Store Connect APIも照会し、要求されたデータとともに返されるJSONペイロードで独自の分析を実行することで、このすべてのデータを取得できます。

00:08:04.000 --> 00:08:11.000
これらのツールはすべて、私のアプリで多くのバッテリー使用量の回帰を簡単にキャッチして解決することができます。

00:08:11.000 --> 00:08:25.000
バッテリー寿命の最適化の詳細については、2019年の「バッテリー寿命とパフォーマンスの向上」トークをチェックし、Instrumentsの使用の詳細については、今年の「InstrumentsのHTTPトラフィックを分析する」トークをチェックしてください。

00:08:25.000 --> 00:08:32.000
次の目的地はハングレートとスクロールで、私のアプリが反応しなかったことを伝える2つの指標です。

00:08:32.000 --> 00:08:40.000
ハングとは、アプリが少なくとも250ミリ秒間ユーザーの入力またはアクションに応答しない場合です。

00:08:40.000 --> 00:08:54.000
アプリにハングすると、顧客がアプリスイッチャーからアプリケーションを強制的に終了させる可能性があり、アプリでのユーザーエクスペリエンスにとって大きな障害となり、優先順位を付ける必要があります。

00:08:54.000 --> 00:09:00.000
吃音スクロールは、新しいコンテンツが次の画面更新の準備ができていないときに発生します。

00:09:00.000 --> 00:09:08.000
これらは、不快なユーザーエクスペリエンスと全体的なフラストレーションにつながり、その結果、ユーザーはアプリに費やす時間が少なくなります。

00:09:08.000 --> 00:09:18.000
アプリ開発者として、目標はユーザーエンゲージメントの量を最大化することなので、これは最適化を始めるのに最適な場所です。

00:09:18.000 --> 00:09:20.000
先ほどお見せした滑らかなスクロールを覚えていますか？

00:09:20.000 --> 00:09:24.000
これを目指すことは、ユーザーにとって最善の利益です。

00:09:24.000 --> 00:09:32.000
それぞれのビューに移動することで、Xcodeオーガナイザーでハングとスクロールメトリクスを追跡できます。

00:09:32.000 --> 00:09:48.000
私のアプリが何をしているかに細心の注意を払う必要がある兆候は、チャートのいずれかが上昇傾向にあることに気付いた場合、またはスクロールの場合、このグラフのように、グラフが緑のバーではなく黄色と赤のバーを表示していることに気付いた場合です。

00:09:48.000 --> 00:09:58.000
チャートの右側のキーによると、赤いバーは、以前にビデオで見たスクロール体験が悪いことであり、すぐに修正する必要があります。

00:09:58.000 --> 00:10:03.000
このデータは、App Store Connect APIからも利用可能になりました。

00:10:03.000 --> 00:10:09.000
スレッド状態またはシステムコールトレースを使用して、インストゥルメントを使用してハングの原因を検出できます。

00:10:09.000 --> 00:10:17.000
スレッド状態トレースインストゥルメントは、スレッドの状態と、OSがスレッドの実行をスケジュールしたタイミングのタイムラインを表示します。

00:10:17.000 --> 00:10:22.000
詳細セクションでは、スレッドがどのくらいの期間ブロックされたかがわかります。

00:10:22.000 --> 00:10:29.000
システムコールトレースは、入力されたシステムコールと時間がかかった時間を詳述した物語を示しています。

00:10:29.000 --> 00:10:41.000
ユーザーのスクロール体験に影響を与えるバグのあるアプリバージョンをリリースしていないことを確認するために、XCTestでパフォーマンステストを書いて、アプリを起動してスクロールすることができます。

00:10:41.000 --> 00:10:52.000
このテストでは、スクロールデセルレーションサブメトリックを測定したいと指定し、メジャーブロックの本文では、アプリで期待するスクロール速度で上にスワイプしています。

00:10:52.000 --> 00:11:01.000
このメジャーブロックはデフォルトで5回実行されるため、XCTMeasureOptionsを使用して実行間のアプリケーション状態をリセットします。

00:11:01.000 --> 00:11:09.000
これを測定ブロックに渡し、測定を停止してから、アプリケーションの状態をリセットすることができます。

00:11:09.000 --> 00:11:14.000
時には、強制テストケースでの応答性の問題を再現するのは簡単ではないかもしれません。

00:11:14.000 --> 00:11:25.000
幸いなことに、MetricKitは、私の本番アプリケーションに展開されると、発生した時点でこれらの問題のテレメトリと診断を収集することができます。

00:11:25.000 --> 00:11:32.000
ハングの場合、iOS 14では、MetricKitは24時間のケイデンスでこれらの診断を私に提供します。

00:11:32.000 --> 00:11:42.000
iOS 15とmacOS 12の新機能で、問題が発生した直後に、ハングを含むすべての診断をアプリで受け取ります。

00:11:42.000 --> 00:11:51.000
これらのインスタント診断を私自身のテレメトリと組み合わせて使用することで、最も差し迫った応答性の問題をすばやく根本原因と解決できます。

00:11:51.000 --> 00:12:00.000
スクロールヒッチの場合、iOS 15はMetricKit内に新しいAPIを導入し、MXSignpostを使用してカスタムアニメーションにタグを付けます。

00:12:00.000 --> 00:12:09.000
MXSignpostは、テレメトリの重要なコードセクションをマークできるMetricKitに同梱されているラッパーAPIです。

00:12:09.000 --> 00:12:17.000
MXSignpostAnimation-IntervalBegin APIを使用すると、カスタムアニメーションの始まりを戦略的にマークすることができます。

00:12:17.000 --> 00:12:26.000
MXSignpostエンドAPIを使用すると、アニメーションの終了をマークし、その間隔でヒッチレートテレメトリを収集できます。

00:12:26.000 --> 00:12:34.000
これら2つの機能は、この間隔の詳細なパフォーマンスデータをキャプチャするだけでなく、発生したヒッチもキャプチャします。

00:12:34.000 --> 00:12:43.000
ハングを理解して排除する方法の詳細については、今年の「アプリからハングを理解して排除する」トークをチェックすることをお勧めします。

00:12:43.000 --> 00:12:56.000
スクロールヒッチの問題を特定する方法の詳細については、2020年の「XCTestを使用してヒッチを解消する」トークと「UIアニメーションヒッチとレンダリングループを探索する」技術トークをチェックすることをお勧めします。

00:12:56.000 --> 00:13:01.000
ディスク書き込みの議論に進むにつれて、私たちは今、中途半端なマークに近づいています。

00:13:01.000 --> 00:13:06.000
ディスクへの書き込みは、ユーザーのNANDを消耗させる可能性があり、デバイスの健全性が低下します。

00:13:06.000 --> 00:13:18.000
書き込みにも多くの時間がかかり、頻繁に行うとユーザーエクスペリエンスが低下し、パフォーマンスが低下する可能性があるため、これらの書き込みをバッチ処理することが重要です。

00:13:18.000 --> 00:13:24.000
アプリのバージョンをリリースする前に、Instrumentsのファイルアクティビティテンプレートを使用してアプリをプロファイリングできます。

00:13:24.000 --> 00:13:33.000
これは、システムコールの形でファイルシステムの使用を記録するので、アプリのコードでファイルシステムにアクセスしている場所を簡単に識別できます。

00:13:33.000 --> 00:13:37.000
システムの善良な市民になり、ディスクへの書き込みを制限する方法はたくさんあります。

00:13:37.000 --> 00:13:46.000
一般的なもののいくつかは、書き込み操作をバッチ処理し、頻繁に変化するデータにコアデータを使用し、迅速なファイルの作成と削除を回避することです。

00:13:46.000 --> 00:13:59.000
アプリのプロファイリングに加えて、XCTestでパフォーマンステストを書いて、アプリのディスク使用量を測定し、過剰なディスク書き込みのコードがユーザーのデバイスで実行されるのを防ぐこともできます。

00:13:59.000 --> 00:14:09.000
これは、XCTStorageMetricのインスタンスをmeasureWithMetric APIに渡し、ディスクに書き込むコードを呼び出すのと同じくらい簡単です。

00:14:09.000 --> 00:14:16.000
このテストは、ブロック内のコードによってディスクに書き込まれたデータ量を測定し、Xcode自体内で結果を表示します。

00:14:16.000 --> 00:14:25.000
ブロック内のコードがそれを超えた場合にテストが失敗するように、ディスクに書き込まれる予定のデータ量のベースラインを設定できます。

00:14:25.000 --> 00:14:30.000
これは、私がバグのあるコードを出していないことを確認するのに役立ちます。

00:14:30.000 --> 00:14:39.000
ディスク書き込みの高いアプリのバージョンをすでにリリースしている場合は、オーガナイザーを使用してユーザーデバイスでのパフォーマンスを追跡できます。

00:14:39.000 --> 00:14:47.000
ディスク書き込みメトリックは、以前にリリースされたバージョンと比較して、私のアプリの現在のバージョンが実行している書き込みの数の傾向を示しています。

00:14:47.000 --> 00:14:52.000
グラフのスパイクは、私のアプリに大量の書き込みを引き起こしているバグがあることを示している可能性があります。

00:14:52.000 --> 00:15:00.000
私はこれらの書き込みのトップソースを特定し、それらを理解し、それらを減らす方法を探す必要があります。

00:15:00.000 --> 00:15:05.000
ディスク書き込みレポートを見ることで、これらの書き込みのソースを探すことができます。

00:15:05.000 --> 00:15:12.000
これらは、私のアプリが24時間以内に1GB以上を書き込むときに生成される例外レポートのコレクションです。

00:15:12.000 --> 00:15:31.000
スタックトレースは、コードのどこで過度の書き込みをしていたかを示し、Xcode 13で新しく、Insightsと呼ばれる追加の詳細を取得することもできます。これにより、システムの善良な市民になり、アプリの書き込みの一部を減らすことができる簡単な最適化が示されます。

00:15:31.000 --> 00:15:37.000
このすべてのデータは、App Store Connect APIを通じて私にも利用可能になりました。

00:15:37.000 --> 00:15:42.000
また、アプリケーションで発生した時点で、これらのレポートをMetricKitで取得することもできます。

00:15:42.000 --> 00:15:56.000
MetricKitを使用してアプリのディスク使用状況を監視している場合は、MXSignpost間隔で重要なディスク書き込みパスを予約して、より詳細なテレメトリを収集することができ、最適化の機会を発見するのに役立ちます。

00:15:56.000 --> 00:16:06.000
ディスク書き込みの問題をシームレスに特定して解決する方法の詳細については、今年の「アプリの電力とパフォーマンスの回帰の診断」トークに必ず同調してください。

00:16:06.000 --> 00:16:11.000
次の停留所に近づくと、打ち上げ時間と終了について話し合います。

00:16:11.000 --> 00:16:20.000
起動時間は、ユーザーがアプリのアイコンをタップして、最初のフレームがアプリでレンダリングされるまでの時間です。

00:16:20.000 --> 00:16:33.000
ユーザーがアプリの起動を待つのに長い時間を費やすと、ユーザーにとって意図しない不満につながる可能性があり、起動時間が長くなり、システムがアプリを終了する可能性があります。

00:16:33.000 --> 00:16:44.000
システムがアプリを終了すると、ユーザーは最初から起動フロー全体を経験し、バックグラウンド実行状態から再開するよりもはるかに時間がかかります。

00:16:44.000 --> 00:16:53.000
プロセスの終了は、システムメモリ制限のヒットと超過、起動時にタイムアウトするなど、さまざまな理由で発生する可能性があります。

00:16:53.000 --> 00:17:11.000
これらの理由のいずれかでアプリが終了するたびに、ユーザーが次回アプリアイコンをタップすると、完全な起動フローが通過し、時間がかかるだけでなく、特に頻繁に発生する場合はイライラする経験でもあります。

00:17:11.000 --> 00:17:20.000
状態を復元しない場合、これはユーザーが自分の場所を再び見つけたり、失われた仕事を再作成したりしなければならないという不満を増す可能性があります。

00:17:20.000 --> 00:17:29.000
私はちょうど私のユーザーが彼らの食事のための写真や詳細なレシピを追加できる機能を備えた私のアプリの新しいバージョンをリリースしました。

00:17:29.000 --> 00:17:36.000
この新機能で私のアプリの起動時間がどのように見えるか、そしてそれが以前にどのように見えたかを見てみましょう。

00:17:36.000 --> 00:17:42.000
これは、新しい機能が追加されたので、私のアプリを起動しようとすると、ユーザーが見るものです。

00:17:42.000 --> 00:17:47.000
最初のフレームをレンダリングしようとしてどれだけの時間が費やされたかに注目してください。

00:17:47.000 --> 00:17:51.000
私のアプリは、私たちがそれを使用する機会を得る前に停止されました。

00:17:51.000 --> 00:17:56.000
比較すると、その機能が追加される前の起動の様子は次のとおりです。

00:17:56.000 --> 00:18:01.000
私のアプリが起動を予想し、最初のフレームを表示する準備ができていたようなものです。

00:18:01.000 --> 00:18:10.000
これら2つの例から、最初の信じられないほど遅い起動は、ユーザーが私のアプリについて考えるときに覚えておいてほしいものではないことをすでに知っています。

00:18:10.000 --> 00:18:14.000
だから、できるだけ早くこれを修正する必要があります。

00:18:14.000 --> 00:18:25.000
起動の問題はすでにユーザーが使用している私のアプリのバージョンにあるので、オーガナイザーに行き、起動時間と新しい終了ペインを見ることから始めることができます。

00:18:25.000 --> 00:18:37.000
起動時間を見ると、アプリの平均的な「最初のフレームまでの時間」が過去16バージョンで何であるかがわかるので、新しい機能が追加される前の速さがわかります。

00:18:37.000 --> 00:18:47.000
また、終了ペインにアクセスして、起動に時間がかかるため、アプリがシステムによって終了される頻度を確認することもできます。

00:18:47.000 --> 00:18:56.000
オーガナイザーを見た後、実際にはこれは私の新機能で導入されたかなり悪いバグであり、多くのユーザーを襲っているように見えます。

00:18:56.000 --> 00:19:00.000
これを修正する方法を見てみましょう。これはどのように修正できるかを見てみましょう。

00:19:00.000 --> 00:19:07.000
InstrumentsのApp Launchテンプレートを使用して、アプリの起動時間をプロファイリングすることで、デスクでこの問題をテストできます。

00:19:07.000 --> 00:19:21.000
このテンプレートはアプリを5秒間実行し、その間にアプリの起動中に何が起こっていたかの時間プロファイルとスレッド状態のトレースを収集するので、スレッドがブロックされた理由を把握し、それを修正することができます。

00:19:21.000 --> 00:19:31.000
また、先ほど見たものと同様の測定ブロックでXCTApplicationsLaunchMetricを使用して、パフォーマンスXCTestの起動時間を測定することもできます。

00:19:31.000 --> 00:19:41.000
アプリにMetricKitを実装して独自の分析を行いたい場合は、デフォルトで毎日のメトリックペイロードの一部として終了テレメトリを受け取ります。

00:19:41.000 --> 00:19:51.000
アプリが終了したときにデータ損失を回避するための状態の復元の詳細については、「なぜ私のアプリが殺されるのですか?」をチェックしてください。2020年から話します。

00:19:51.000 --> 00:19:53.000
イェーイ、やったよ。

00:19:53.000 --> 00:19:56.000
私たちは旅を終える前に最後の停留所にいます。

00:19:56.000 --> 00:19:59.000
私たちの最後の停留所は記憶です。

00:19:59.000 --> 00:20:04.000
メモリは、アプリ、OS、カーネル間の共有リソースです。

00:20:04.000 --> 00:20:17.000
アプリがメモリ制限を超えると、システムによって終了し、次回ユーザーが起動すると、最初から起動し、バックグラウンド実行状態から再開するよりもはるかに時間がかかります。

00:20:17.000 --> 00:20:26.000
私のアプリの新機能により、開発者は食事に写真や説明を追加できます。つまり、メモリ使用量が少し高くなる可能性があります。

00:20:26.000 --> 00:20:39.000
このような場合、メモリ制限を超えるとアプリが終了する可能性があるため、オーガナイザーのメモリと終了のメトリックに目を光らせて、そうではないことを確認する必要があります。

00:20:39.000 --> 00:20:51.000
終了していないように見えますが、オーガナイザーのサスペンションチャートのピークメモリとメモリによると、この新しいバージョンの私のアプリのメモリ使用量が大幅に急増しています。

00:20:51.000 --> 00:20:59.000
Instrumentsのリーク、割り当て、およびVMトラッカーテンプレートを使用して、アプリのメモリ使用量をプロファイリングできます。

00:20:59.000 --> 00:21:04.000
リークは、私のプロセスのヒープを調べ、リークされたメモリをチェックします。

00:21:04.000 --> 00:21:08.000
割り当ては、私のアプリのメモリライフサイクルを分析します。

00:21:08.000 --> 00:21:13.000
そして、VMトラッカーは、時間の経過とともに私のアプリの仮想メモリ空間を表示します。

00:21:13.000 --> 00:21:18.000
MetricKitを使用して同じ情報を取得し、独自の分析を実行することもできます。

00:21:18.000 --> 00:21:33.000
終端とメモリテレメトリを含む毎日のメトリックペイロードを使用することに加えて、重要なコードセクションの周りにMXSignpostsを計測して、メモリ使用量に関するより詳細なテレメトリをキャプチャすることもできます。

00:21:33.000 --> 00:21:44.000
アプリケーションに入る前にメモリ回帰を解決する方法の検出と理解の詳細については、今年の「メモリ問題の検出と診断」の講演をご覧ください。

00:21:44.000 --> 00:21:51.000
途中であなたを送る前に、今日ここで見たことをまとめて、次のステップをいくつか見ましょう。

00:21:51.000 --> 00:21:56.000
私たちは、パフォーマンスの最適化を特定することがどれほど難しいかを理解しています。

00:21:56.000 --> 00:22:05.000
過去数年間、開発者は、重要なパフォーマンスの最適化を行うために、私たちがあなたに提供するこれらの同じツールを使用してきました。

00:22:05.000 --> 00:22:11.000
素晴らしい例は、何百万人もの人々が毎日使用しているアプリであるSnapchatです。

00:22:11.000 --> 00:22:19.000
Snapchatは、アプリの起動体験を向上させ、終了に追いやすことに長年の献身を持っています。

00:22:19.000 --> 00:22:25.000
昨年、Snapchatの望ましくない終了が99%減少しました。

00:22:25.000 --> 00:22:34.000
私たちはそれが信じられないと思いますし、今日ここで説明したパフォーマンスツールとデータを使用して、あなたもこれを達成することができます。

00:22:34.000 --> 00:22:55.000
パフォーマンスツールを初めて使用する場合は、2020年の「Xcodeオーガナイザーでパフォーマンスの問題を診断する」と「MetricKitの新機能」トーク、2020年の「パワーとパフォーマンスAPIでトレンドを特定する」トーク、2019年の「Instrumentsを使い始める」トークをチェックすることをお勧めします。

00:22:55.000 --> 00:23:04.000
これらの指標とツールをすべて掘り下げた後、App Storeで最もパフォーマンスの高いアプリを出荷するために必要なリソースを十分に備えていることを願っています。

00:23:04.000 --> 00:23:09.000
ユーザーは、シームレスなユーザーエクスペリエンスを楽しんでいるため、これに感謝します。

00:23:09.000 --> 00:23:22.000
ここでは多くの資料が取り上げられていたので、楽しいエクササイズとして、Xcodeオーガナイザーを使用してアプリのパフォーマンスに関するトレンドデータを確認することをお勧めします。

00:23:22.000 --> 00:23:26.000
インストゥルメントで提供されているさまざまなテンプレートを探索してプレイしてください。

00:23:26.000 --> 00:23:32.000
リリースされる前に問題をキャッチするためにXCTestsを書くことに挑戦してください。

00:23:32.000 --> 00:23:37.000
そして、MetricKitで分析の範囲を広げます。

00:23:37.000 --> 00:23:47.000
パフォーマンスの最適化に関しては、私たちのツールが提供しなければならないものがたくさんあるので、あなたの手を汚し、それらに付属するすべてを探索することを躊躇しないでください。

00:23:47.000 --> 00:23:54.000
今日の旅にご参加いただきありがとうございます。今年の会議で素晴らしい時間を過ごせることを願っています。

00:23:54.000 --> 23:59:59.000
[明るい音楽]。

