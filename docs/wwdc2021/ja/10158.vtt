WEBVTT

00:00:02.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:10.000
こんにちは。

00:00:10.000 --> 00:00:14.000
私の名前はPeikangで、ビデオコーディングと処理チームの出身です。

00:00:14.000 --> 00:00:27.000
「ビデオツールボックスによる低遅延ビデオエンコーディングの探索」へようこそ。低遅延エンコーディングは、多くのビデオアプリケーション、特にリアルタイムビデオ通信アプリにとって非常に重要です。

00:00:27.000 --> 00:00:35.000
この講演では、低遅延エンコーディングを実現するために、Video Toolboxで新しいエンコーディングモードを紹介します。

00:00:35.000 --> 00:00:42.000
この新しいモードの目標は、リアルタイムアプリケーション用に既存のエンコーダパイプラインを最適化することです。

00:00:42.000 --> 00:00:47.000
では、リアルタイムのビデオアプリケーションには何が必要ですか?

00:00:47.000 --> 00:00:54.000
人々がお互いに話さないように、通信のエンドツーエンドのレイテンシを最小限に抑える必要があります。

00:00:54.000 --> 00:01:01.000
ビデオアプリがより多くのデバイスと通信できるようにすることで、相互運用性を強化する必要があります。

00:01:01.000 --> 00:01:08.000
エンコーダパイプラインは、通話に複数の受信者がいる場合に効率的であるはずです。

00:01:08.000 --> 00:01:13.000
アプリは最高のビジュアル品質でビデオを提示する必要があります。

00:01:13.000 --> 00:01:20.000
ネットワーク損失によってもたらされたエラーから通信を回復するための信頼できるメカニズムが必要です。

00:01:20.000 --> 00:01:27.000
今日お話しする低遅延ビデオエンコーディングは、これらすべての面で最適化されます。

00:01:27.000 --> 00:01:33.000
このモードでは、リアルタイムアプリケーションは新しいレベルのパフォーマンスを達成できます。

00:01:33.000 --> 00:01:39.000
この講演では、まず低遅延ビデオエンコーディングの概要を説明します。

00:01:39.000 --> 00:01:45.000
私たちは、パイプラインで低レイテンシを達成する方法についての基本的なアイデアを持つことができます。

00:01:45.000 --> 00:01:54.000
次に、VTCompressionSession APIを使用してパイプラインを構築し、低遅延モードでエンコードする方法を紹介します。

00:01:54.000 --> 00:02:00.000
最後に、低遅延モードで導入している複数の機能について説明します。

00:02:00.000 --> 00:02:05.000
まず、低レイテンシのビデオエンコーディングの概要を説明します。

00:02:05.000 --> 00:02:10.000
これは、Appleのプラットフォーム上のビデオエンコーダパイプラインの簡単な図です。

00:02:10.000 --> 00:02:15.000
ビデオツールボックスは、CVImagebufferを入力画像として取ります。

00:02:15.000 --> 00:02:24.000
ビデオエンコーダに、生データのサイズを小さくするためにH.264などの圧縮アルゴリズムを実行するように要求します。

00:02:24.000 --> 00:02:33.000
出力圧縮データはCMSampleBufferでラップされ、ビデオ通信のためにネットワークを介して送信できます。

00:02:33.000 --> 00:02:44.000
前の図からお気づきかもしれませんが、エンドツーエンドのレイテンシは、処理時間とネットワーク送信時間の2つの要因によって影響を受ける可能性があります。

00:02:44.000 --> 00:02:50.000
処理時間を最小限に抑えるために、低遅延モードはフレームの並べ替えを排除します。

00:02:50.000 --> 00:02:54.000
1イン、1アウトのエンコーディングパターンに従います。

00:02:54.000 --> 00:03:06.000
また、このモードのレートコントローラーは、ネットワークの変更に応じてより高速に適応するため、ネットワークの混雑による遅延も最小限に抑えられます。

00:03:06.000 --> 00:03:14.000
これら2つの最適化により、デフォルトモードと比較して、すでに明らかなパフォーマンスの向上が見られます。

00:03:14.000 --> 00:03:21.000
低レイテンシのエンコーディングは、720p 30fpsのビデオで最大100ミリ秒の遅延を減らすことができます。

00:03:21.000 --> 00:03:26.000
このような節約は、ビデオ会議にとって非常に重要です。

00:03:26.000 --> 00:03:37.000
レイテンシを減らすことで、ビデオ会議やライブ放送などのリアルタイム通信のためのより効率的なエンコーディングパイプラインを実現できます。

00:03:37.000 --> 00:03:45.000
また、低遅延モードは、電力を節約するために、常にハードウェアアクセラレーションビデオエンコーダを使用します。

00:03:45.000 --> 00:03:56.000
注：このモードでサポートされているビデオコーデックタイプはH.264で、この機能はiOSとmacOSの両方に搭載されています。

00:03:56.000 --> 00:04:02.000
次に、ビデオツールボックスで低遅延モードを使用する方法について話したいと思います。

00:04:02.000 --> 00:04:11.000
まず、VTCompressionSessionの使用を要約してから、低遅延エンコーディングを有効にするために必要な手順を紹介します。

00:04:11.000 --> 00:04:21.000
VTCompressionSessionを使用する場合、まずVTCompressionSessionCreate APIを使用してセッションを作成することです。

00:04:21.000 --> 00:04:28.000
VTSessionSetProperty APIを使用して、ターゲットビットレートなどのセッションをオプションで設定できます。

00:04:28.000 --> 00:04:35.000
設定が提供されていない場合、エンコーダはデフォルトの動作で動作します。

00:04:35.000 --> 00:04:46.000
セッションが作成され、適切に設定された後、VTCompressionSessionEncodeFrame呼び出しでCVImageBufferをセッションに渡すことができます。

00:04:46.000 --> 00:04:53.000
エンコードされた結果は、セッション作成時に提供された出力ハンドラから取得できます。

00:04:53.000 --> 00:04:58.000
圧縮セッションで低遅延エンコーディングを有効にするのは簡単です。

00:04:58.000 --> 00:05:02.000
必要な変更は、セッションの作成だけです。

00:05:02.000 --> 00:05:06.000
これは、その方法を示すコードスニペットです。

00:05:06.000 --> 00:05:11.000
まず、encoderSpecification用のCFMutableDictionaryが必要です。

00:05:11.000 --> 00:05:18.000
encoderSpecificationは、セッションが使用する必要がある特定のビデオエンコーダを指定するために使用されます。

00:05:18.000 --> 00:05:25.000
次に、encoderSpecificationでEnableLowLatencyRateControlフラグを設定する必要があります。

00:05:25.000 --> 00:05:36.000
最後に、このエンコーダ仕様をVTCompressionSessionCreateに渡す必要があり、圧縮セッションは低遅延モードで動作します。

00:05:36.000 --> 00:05:39.000
設定手順は通常と同じです。

00:05:39.000 --> 00:05:45.000
たとえば、AverageBitRateプロパティで目標ビットレートを設定できます。

00:05:45.000 --> 00:05:51.000
さて、私たちはビデオツールボックスで低遅延モードの基本をカバーしました。

00:05:51.000 --> 00:05:59.000
リアルタイムビデオアプリケーションの開発をさらに支援できるこのモードの新機能に移りたいと思います。

00:05:59.000 --> 00:06:04.000
これまでのところ、低遅延モードを使用することによるレイテンシの利点について話しました。

00:06:04.000 --> 00:06:10.000
残りの利点は、私が紹介する機能によって達成できます。

00:06:10.000 --> 00:06:13.000
最初の特徴は、新しいプロファイルです。

00:06:13.000 --> 00:06:20.000
パイプラインに2つの新しいプロファイルを追加することで、相互運用性を強化しました。

00:06:20.000 --> 00:06:24.000
また、時間的なスケーラビリティについて話すことに興奮しています。

00:06:24.000 --> 00:06:28.000
この機能はビデオ会議で非常に役立ちます。

00:06:28.000 --> 00:06:35.000
最大フレーム量子化パラメータを使用して、画質をきめ細かく制御できるようになりました。

00:06:35.000 --> 00:06:42.000
最後に、長期参照のサポートを追加することで、エラーの回復力を向上させたいと考えています。

00:06:42.000 --> 00:06:45.000
新しいプロフィールのサポートについて話しましょう。

00:06:45.000 --> 00:06:51.000
プロファイルは、デコーダがサポートできるコーディングアルゴリズムのグループを定義します。

00:06:51.000 --> 00:07:00.000
受信機側と通信するために、エンコードされたビットストリームは、デコーダがサポートする特定のプロファイルに準拠する必要があります。

00:07:00.000 --> 00:07:09.000
ここビデオツールボックスでは、ベースラインプロファイル、メインプロファイル、ハイプロファイルなど、多くのプロファイルをサポートしています。

00:07:09.000 --> 00:07:19.000
本日、制約されたベースラインプロファイル、CBP、制約されたハイプロファイル、CHPの2つの新しいプロファイルをファミリーに追加しました。

00:07:19.000 --> 00:07:29.000
CBPは主に低コストのアプリケーションに使用され、一方、CHPは圧縮比を向上させるためのより高度なアルゴリズムを備えています。

00:07:29.000 --> 00:07:35.000
どのプロファイルを使用するべきかを知るには、デコーダ機能を確認する必要があります。

00:07:35.000 --> 00:07:43.000
CBPを要求するには、ProfileLevelセッションプロパティをContrainedBaseLine_AutoLevelに設定するだけです。

00:07:43.000 --> 00:07:50.000
同様に、プロファイルレベルをContrainedHigh_AutoLevelに設定してCHPを使用できます。

00:07:50.000 --> 00:07:54.000
では、時間的スケーラビリティについて話しましょう。

00:07:54.000 --> 00:08:01.000
一時的なスケーラビリティを使用して、マルチパーティビデオ通話の効率を高めることができます。

00:08:01.000 --> 00:08:05.000
シンプルな3者間のビデオ会議シナリオを考えてみましょう。

00:08:05.000 --> 00:08:16.000
このモデルでは、レシーバー「A」の帯域幅は600kbpsが低く、レシーバーBの帯域幅は1,000kbpsです。

00:08:16.000 --> 00:08:28.000
通常、送信者は、各受信側のダウンリンク帯域幅を満たすために、2組のビットストリームをエンコードする必要があります。これは最適ではないかもしれません。

00:08:28.000 --> 00:08:40.000
このモデルは、送信者が1つのビットストリームをエンコードするだけで、後で2つのレイヤーに分割できる時間的スケーラビリティでより効率的になります。

00:08:40.000 --> 00:08:44.000
このプロセスがどのように機能するかをお見せしましょう。

00:08:44.000 --> 00:08:54.000
これは、各フレームが予測参照として前のフレームを使用するエンコードされたビデオフレームのシーケンスです。

00:08:54.000 --> 00:09:05.000
フレームの半分を別のレイヤーに引き込むことができ、元のレイヤーのフレームのみが予測に使用されるように参照を変更できます。

00:09:05.000 --> 00:09:13.000
元のレイヤーはベースレイヤーと呼ばれ、新しく構築されたレイヤーはエンハンスメントレイヤーと呼ばれます。

00:09:13.000 --> 00:09:20.000
エンハンスメントレイヤーは、フレームレートを向上させるために、ベースレイヤーの補足として使用できます。

00:09:20.000 --> 00:09:27.000
受信者「A」の場合、ベースレイヤー自体はすでにデコーダ可能であるため、ベースレイヤーフレームを送信できます。

00:09:27.000 --> 00:09:37.000
さらに重要なことに、ベースレイヤーにはフレームの半分しか含まれていないため、送信データレートは低くなります。

00:09:37.000 --> 00:09:48.000
一方、レシーバーBは、ベースレイヤーフレームとエンハンスメントレイヤーフレームを受信するのに十分な帯域幅を持っているので、よりスムーズなビデオを楽しむことができます。

00:09:48.000 --> 00:09:53.000
時間的スケーラビリティを使用してエンコードされたビデオをお見せしましょう。

00:09:53.000 --> 00:10:02.000
2つのビデオを再生します。1つはベースレイヤーから、もう1つはエンハンスメントレイヤーと一緒にベースレイヤーから再生します。

00:10:02.000 --> 00:10:11.000
ベースレイヤー自体は正常に再生できますが、同時に、ビデオがかなりスムーズではないことに気付くかもしれません。

00:10:11.000 --> 00:10:16.000
2番目のビデオを再生すると、すぐに違いがわかります。

00:10:16.000 --> 00:10:24.000
右のビデオには、ベースレイヤーとエンハンスメントレイヤーの両方が含まれているため、左のビデオと比較してフレームレートが高くなります。

00:10:24.000 --> 00:10:31.000
左のビデオは入力フレームレートの50%を持ち、ターゲットビットレートの60%を使用します。

00:10:31.000 --> 00:10:37.000
これら2つのビデオでは、エンコーダが一度に1つのビットストリームをエンコードするだけで済みます。

00:10:37.000 --> 00:10:44.000
マルチパーティビデオ会議を行う場合、これははるかに電力効率が高くなります。

00:10:44.000 --> 00:10:48.000
時間的スケーラビリティのもう1つの利点は、エラーの回復力です。

00:10:48.000 --> 00:10:58.000
ご覧のとおり、エンハンスメントレイヤーのフレームは予測に使用されていないため、これらのフレームに依存しません。

00:10:58.000 --> 00:11:07.000
これは、ネットワーク送信中に1つ以上のエンハンスメントレイヤーフレームがドロップされた場合、他のフレームは影響を受けないことを意味します。

00:11:07.000 --> 00:11:11.000
これにより、セッション全体がより堅牢になります。

00:11:11.000 --> 00:11:15.000
時間的スケーラビリティを有効にする方法はかなり簡単です。

00:11:15.000 --> 00:11:22.000
BaseLayerFrameRateFractionと呼ばれる低遅延モードで新しいセッションプロパティを作成しました。

00:11:22.000 --> 00:11:34.000
このプロパティを0.5に設定するだけで、入力フレームの半分がベースレイヤーに割り当てられ、残りはエンハンスメントレイヤーに割り当てられます。

00:11:34.000 --> 00:11:38.000
サンプルバッファアタッチメントからレイヤー情報を確認できます。

00:11:38.000 --> 00:11:49.000
ベースレイヤーフレームの場合、CMSampleAttachmentKey_ IsDependedOnByOthersはtrueになり、それ以外の場合はfalseになります。

00:11:49.000 --> 00:11:54.000
また、各レイヤーのターゲットビットレートを設定するオプションもあります。

00:11:54.000 --> 00:12:01.000
セッションプロパティAverageBitRateを使用して、ターゲットビットレートを設定することを忘れないでください。

00:12:01.000 --> 00:12:12.000
ターゲットビットレートを設定した後、新しいBaseLayerBitRateFractionプロパティを設定して、ベースレイヤーに必要なターゲットビットレートの割合を制御できます。

00:12:12.000 --> 00:12:18.000
このプロパティが設定されていない場合は、デフォルト値0.6が使用されます。

00:12:18.000 --> 00:12:26.000
また、ベースレイヤーのビットレート分数は0.6から0.8の範囲であることをお勧めします。

00:12:26.000 --> 00:12:33.000
では、最大フレーム量子化パラメータ、または最大フレームQPに移動しましょう。

00:12:33.000 --> 00:12:39.000
フレームQPは、画質とデータレートを調整するために使用されます。

00:12:39.000 --> 00:12:43.000
低フレームQPを使用して、高品質の画像を生成できます。

00:12:43.000 --> 00:12:47.000
この場合、画像サイズは大きくなります。

00:12:47.000 --> 00:12:56.000
一方、ハイフレームQPを使用して、低品質でサイズが小さい画像を生成できます。

00:12:56.000 --> 00:13:10.000
低遅延モードでは、エンコーダは、現在のターゲットビットレートの制約の下で最高の視覚品質を生成するために、画像の複雑さ、入力フレームレート、ビデオモーションなどの要因を使用してフレームQPを調整します。

00:13:10.000 --> 00:13:17.000
したがって、フレームQPを調整するには、エンコーダのデフォルトの動作に頼ることをお勧めします。

00:13:17.000 --> 00:13:29.000
しかし、クライアントがビデオ品質に対する特定の要件を持っている場合、エンコーダの使用が許可されている最大フレームQPを制御できるようになりました。

00:13:29.000 --> 00:13:42.000
最大フレームQPでは、エンコーダは常にこの制限よりも小さいフレームQPを選択するため、クライアントは画質をきめ細かく制御できます。

00:13:42.000 --> 00:13:49.000
通常のレート制御は、指定された最大フレームQPでも引き続き機能することを言及する価値があります。

00:13:49.000 --> 00:14:01.000
エンコーダが最大フレームQPキャップに達したが、ビットレートの予算を使い果たしている場合、目標ビットレートを維持するためにフレームをドロップし始めます。

00:14:01.000 --> 00:14:08.000
この機能を使用する1つの例は、貧弱なネットワークを介して画面コンテンツビデオを送信することです。

00:14:08.000 --> 00:14:15.000
鮮明な画面コンテンツ画像を送信するためにフレームレートを犠牲にすることで、トレードオフを行うことができます。

00:14:15.000 --> 00:14:20.000
最大フレームQPを設定すると、この要件を満たすことができます。

00:14:20.000 --> 00:14:22.000
インターフェースを見てみましょう。 

00:14:22.000 --> 00:14:29.000
新しいセッションプロパティMaxAllowedFrameQPで最大フレームQPを渡すことができます。

00:14:29.000 --> 00:14:38.000
最大フレームQPの値は、標準に従って1から51の範囲でなければならないことを覚えておいてください。

00:14:38.000 --> 00:14:45.000
低遅延モード、長期参照で開発した最後の機能について話しましょう。

00:14:45.000 --> 00:14:50.000
長期参照またはLTRは、エラーの回復力に使用できます。

00:14:50.000 --> 00:14:58.000
パイプライン内のエンコーダ、送信者クライアント、および受信者クライアントを示すこの図を見てみましょう。

00:14:58.000 --> 00:15:03.000
ビデオ通信が接続の悪いネットワークを通過するとします。

00:15:03.000 --> 00:15:07.000
送信エラーが原因でフレーム損失が発生する可能性があります。

00:15:07.000 --> 00:15:16.000
受信クライアントがフレームの損失を検出すると、セッションをリセットするためにリフレッシュフレームを要求できます。

00:15:16.000 --> 00:15:23.000
エンコーダが要求を受け取った場合、通常は更新目的でキーフレームをエンコードします。

00:15:23.000 --> 00:15:26.000
しかし、キーフレームは通常かなり大きいです。

00:15:26.000 --> 00:15:30.000
大きなキーフレームは、レシーバーにたどり着くのに時間がかかります。

00:15:30.000 --> 00:15:38.000
ネットワークの状態はすでに悪いため、大きなフレームがネットワークの輻輳の問題を悪化させる可能性があります。

00:15:38.000 --> 00:15:43.000
では、リフレッシュのためにキーフレームの代わりに予測フレームを使用できますか?

00:15:43.000 --> 00:15:48.000
フレーム確認があれば、答えはイエスです。

00:15:48.000 --> 00:15:51.000
それがどのように機能するかをお見せしましょう。

00:15:51.000 --> 00:15:55.000
まず、承認が必要なフレームを決定する必要があります。

00:15:55.000 --> 00:16:00.000
これらのフレームを長期参照、またはLTRと呼びます。

00:16:00.000 --> 00:16:03.000
これはエンコーダからの決定です。

00:16:03.000 --> 00:16:12.000
送信者クライアントがLTRフレームを送信する場合、受信者クライアントに確認要求も必要です。

00:16:12.000 --> 00:16:19.000
LTRフレームが正常に受信された場合は、確認書を返送する必要があります。

00:16:19.000 --> 00:16:30.000
送信者クライアントが確認応答を取得し、その情報をエンコーダに渡すと、エンコーダはどのLTRフレームが反対側から受信されたかを知る。

00:16:30.000 --> 00:16:34.000
悪いネットワーク状況をもう一度見てみましょう。

00:16:34.000 --> 00:16:47.000
エンコーダが更新要求を取得すると、この時間以来、エンコーダは認識されたLTRの束を持っているので、これらの認識されたLTRの1つから予測されるフレームをエンコードすることができます。

00:16:47.000 --> 00:16:53.000
このようにエンコードされたフレームはLTR-Pと呼ばれます。

00:16:53.000 --> 00:17:02.000
通常、LTR-Pはキーフレームに比べてエンコードされたフレームサイズがはるかに小さいため、送信が簡単です。

00:17:02.000 --> 00:17:07.000
では、LTRのAPIについて話しましょう。

00:17:07.000 --> 00:17:12.000
フレーム確認応答は、アプリケーションレイヤーで処理する必要があることに注意してください。

00:17:12.000 --> 00:17:20.000
RTP制御プロトコルのRPSIメッセージなどのメカニズムで行うことができます。

00:17:20.000 --> 00:17:28.000
ここでは、このプロセスでエンコーダと送信者クライアントがどのように通信するかに焦点を当てます。

00:17:28.000 --> 00:17:37.000
低遅延エンコーディングを有効にしたら、EnableLTRセッションプロパティを設定することで、この機能を有効にすることができます。

00:17:37.000 --> 00:17:48.000
LTRフレームがエンコードされると、エンコーダはサンプル添付ファイルRequireLTRAcknowledgementTokenで一意のフレームトークンを通知します。

00:17:48.000 --> 00:17:57.000
送信者クライアントは、AcknowledgedLTRTokensフレームプロパティを通じて、承認されたLTRフレームをエンコーダに報告する責任があります。

00:17:57.000 --> 00:18:06.000
一度に複数の確認応答が届く可能性があるため、これらのフレームトークンを格納するために配列を使用する必要があります。

00:18:06.000 --> 00:18:12.000
ForceLTRRefreshフレームプロパティを使用して、いつでもリフレッシュフレームをリクエストできます。

00:18:12.000 --> 00:18:18.000
エンコーダがこの要求を受信すると、LTR-Pがエンコードされます。

00:18:18.000 --> 00:18:26.000
利用可能な承認されたLTRがない場合、この場合、エンコーダはキーフレームを生成します。

00:18:26.000 --> 00:18:27.000
わかった。

00:18:27.000 --> 00:18:30.000
これで、低レイテンシモードの新機能を取り上げました。

00:18:30.000 --> 00:18:34.000
これらの機能を一緒に使用することについて話し合うことができます。

00:18:34.000 --> 00:18:42.000
たとえば、グループ画面共有アプリケーションには、時間的スケーラビリティと最大フレーム量子化パラメータを使用できます。

00:18:42.000 --> 00:18:55.000
時間的スケーラビリティは、各受信者の出力ビデオを効率的に生成することができ、画面コンテンツのよりシャープなUIとテキストのために最大フレームQPを下げることができます。

00:18:55.000 --> 00:19:05.000
通信が貧弱なネットワークを通過し、エラーから回復するためにリフレッシュフレームが必要な場合は、長期参照を使用できます。

00:19:05.000 --> 00:19:15.000
また、受信者が制約されたプロファイルのみをデコードできる場合は、制約されたベースラインプロファイルまたは制約されたハイプロファイルでエンコードできます。

00:19:15.000 --> 00:19:16.000
わかりました。

00:19:16.000 --> 00:19:19.000
ここではいくつかのトピックを取り上げました。

00:19:19.000 --> 00:19:24.000
ビデオツールボックスに低遅延エンコーディングモードを導入しました。

00:19:24.000 --> 00:19:31.000
VTCompressionSession APIを使用して低レイテンシモードでビデオをエンコードする方法について話しました。

00:19:31.000 --> 00:19:40.000
レイテンシの利点に加えて、リアルタイムビデオアプリケーションの要件に対処するための多くの新機能も開発しました。

00:19:40.000 --> 00:19:46.000
これらすべての改善により、低遅延モードがあなたのビデオアプリをより素晴らしいものにしてくれることを願っています。

00:19:46.000 --> 00:19:50.000
見てくれてありがとう、素晴らしいWWDC 2021をお過ごしください。

00:19:50.000 --> 23:59:59.000
[明るい音楽]。

