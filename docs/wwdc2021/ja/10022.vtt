WEBVTT

00:00:00.000 --> 00:00:05.000
♪ベース音楽の演奏♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:14.000
マット・リケットソン：こんにちは、私はマットです。後でルカとラジが加わります。

00:00:14.000 --> 00:00:17.000
今日は、SwiftUIを解明します。

00:00:17.000 --> 00:00:24.000
さて、SwiftUIは宣言的なUIフレームワークであることを何度も聞いたことがあります。

00:00:24.000 --> 00:00:32.000
つまり、アプリに欲しいものを高いレベルで説明し、SwiftUIはそれを実現する方法を正確に決定します。

00:00:32.000 --> 00:00:34.000
さて、ほとんどの場合、これはうまくいきます!

00:00:34.000 --> 00:00:37.000
そして、それはSwiftUIが魔法のように感じるときです。

00:00:37.000 --> 00:00:42.000
しかし、SwiftUIがあなたが期待しないかもしれないことをする瞬間は常にあります。

00:00:42.000 --> 00:00:54.000
そして、それらの瞬間に、あなたが探している結果を得る方法についてより良い直感を構築するために、SwiftUIが舞台裏で何をしているのかをもう少し理解するのに役立ちます。

00:00:54.000 --> 00:00:59.000
だから今日の質問は、SwiftUIがあなたのコードを見るとき、何が見えますか?

00:00:59.000 --> 00:01:06.000
答えは、アイデンティティ、生涯、依存関係の3つです。

00:01:06.000 --> 00:01:15.000
アイデンティティとは、SwiftUIがアプリの複数のアップデートで要素を同じまたは異なるものとして認識する方法です。

00:01:15.000 --> 00:01:21.000
ライフタイムは、SwiftUIが時間の経過とともにビューとデータの存在を追跡する方法です。

00:01:21.000 --> 00:01:28.000
そして、依存関係は、SwiftUIがインターフェイスを更新する必要があるときとその理由を理解する方法です。

00:01:28.000 --> 00:01:40.000
これら3つの概念は、SwiftUIが何を、どのように、いつ変更する必要があるかをどのように決定するかを知らせ、その結果、画面に表示される動的なユーザーインターフェイスが得られます。

00:01:40.000 --> 00:01:46.000
今日は、これら3つの概念のそれぞれについてより深く話します。

00:01:46.000 --> 00:01:51.000
アイデンティティから始めましょう、そしてここには私を助けてくれる友達が何人かいます。

00:01:51.000 --> 00:01:59.000
これらのルビースパニエルは愛らしいですが、深い哲学的な質問の対象でもあります。

00:01:59.000 --> 00:02:01.000
この2匹の犬は違うの？

00:02:01.000 --> 00:02:06.000
それとも、これらは実際には、同じ犬の2枚の写真ですか?

00:02:06.000 --> 00:02:09.000
真実は、それは言うことは不可能です!

00:02:09.000 --> 00:02:11.000
私たちは十分な情報を持っていないだけです。

00:02:11.000 --> 00:02:19.000
しかし、物事が同じか異なるかというこの質問は、私たちが「アイデンティティ」と呼ぶものの中心です。

00:02:19.000 --> 00:02:21.000
しかし、アイデンティティは犬にとって重要なだけではありません。

00:02:21.000 --> 00:02:27.000
また、SwiftUIがアプリをどのように理解しているかの重要な側面でもあります。

00:02:27.000 --> 00:02:30.000
例を見てみましょう。 例を見てみましょう。

00:02:30.000 --> 00:02:37.000
これは私が作った「グッドドッグ、バッドドッグ」というアプリで、私の毛皮のような友人が彼女の最高の行動をとっているかどうかを追跡するのに役立ちます。

00:02:37.000 --> 00:02:38.000
それはかなり簡単です。

00:02:38.000 --> 00:02:43.000
画面上の任意の場所をタップするだけで、良い状態と悪い状態を切り替えることができます。

00:02:43.000 --> 00:02:47.000
では、アイデンティティは私のアプリと何の関係があるのでしょうか?

00:02:47.000 --> 00:02:53.000
まあ、それは実際に私たちが犬について尋ねた哲学的な質問と非常によく似ています。

00:02:53.000 --> 00:02:59.000
これらのアイコンを見ると、それらは互いに完全に異なる2つの異なるビューのように見えますか?

00:02:59.000 --> 00:03:04.000
それとも、同じビューで、ちょうど別の場所で、異なる色で?

00:03:04.000 --> 00:03:13.000
その区別は、インターフェイスが1つの状態から別の状態に移行する方法を変えるため、実際には非常に重要です。

00:03:13.000 --> 00:03:17.000
これらのアイコンは、実際には異なる見解だとしましょう。

00:03:17.000 --> 00:03:24.000
つまり、フェードインやフェードアウトなど、アイコンは独立して移行する必要があります。

00:03:24.000 --> 00:03:27.000
しかし、もし彼らが実際に同じ見解だったらどうでしょうか?

00:03:27.000 --> 00:03:37.000
それは代わりに、ある場所から別の場所に移動する同じビューであるため、トランジション中にビューが画面を横切ってスライドする必要があることを意味します。

00:03:37.000 --> 00:03:45.000
したがって、SwiftUIがそれらの間の移行方法を理解する方法であるため、異なる状態間のビューを接続することは重要です。

00:03:45.000 --> 00:03:50.000
これは、ビューアイデンティティの背後にある重要な概念です。

00:03:50.000 --> 00:03:57.000
同じアイデンティティを共有するビューは、同じ概念的なUI要素の異なる状態を表します。

00:03:57.000 --> 00:04:03.000
対照的に、異なるUI要素を表すビューは、常に異なるアイデンティティを持ちます。

00:04:03.000 --> 00:04:11.000
講演の後半で、LucaとRajは、ビューアイデンティティがアプリのデータと更新サイクルに及ぼす実用的な影響について話します。

00:04:11.000 --> 00:04:21.000
とりあえず、SwiftUIで使用される2つの異なるタイプのアイデンティティに焦点を当てて、コードでアイデンティティがどのように表現されているかを見てみましょう。

00:04:21.000 --> 00:04:27.000
まず、明示的なアイデンティティ：カスタムまたはデータ駆動型の識別子を使用します。

00:04:27.000 --> 00:04:35.000
そして第二に、構造的アイデンティティ：ビュー階層のタイプと位置によってビューを区別する。

00:04:35.000 --> 00:04:40.000
さて、これらの概念を理解するために、私の友人をさらに紹介しましょう。

00:04:40.000 --> 00:04:47.000
さて、特に犬が同じように見える場合は、犬を区別するのは難しいことを覚えておいてください。

00:04:47.000 --> 00:04:52.000
では、どのような追加情報が私たちの犬を識別するのに役立ちますか?

00:04:52.000 --> 00:04:56.000
1つの方法は、単に彼らの名前を尋ねることです。

00:04:56.000 --> 00:05:04.000
2匹の犬が同じように見え、同じ名前を共有している場合、実際には同じ犬である可能性が高いと思います。

00:05:04.000 --> 00:05:10.000
しかし、彼らが異なる名前を持っている場合、私たちは彼らが実際には異なる犬であることを保証することができます。

00:05:10.000 --> 00:05:16.000
このような名前や識別子を割り当てることは、明示的なアイデンティティの一形態です。

00:05:16.000 --> 00:05:24.000
明示的なアイデンティティは強力で柔軟ですが、誰かがどこかでそれらのすべての名前を追跡する必要があります。

00:05:24.000 --> 00:05:32.000
すでに使用されている可能性のある明示的なアイデンティティの1つの形式は、UIKitとAppKit全体で使用されるポインタアイデンティティです。

00:05:32.000 --> 00:05:40.000
現在、SwiftUIはポインタアイデンティティを使用していませんが、それについて学ぶことは、SwiftUIの仕組みと理由をよりよく理解するのに役立ちます。

00:05:40.000 --> 00:05:42.000
ざっと見てみましょう。

00:05:42.000 --> 00:05:45.000
このようなUIKitまたはAppKitのビュー階層を考えてみましょう。

00:05:45.000 --> 00:05:53.000
UIViewsとNSViewsはクラスであるため、それぞれがメモリ割り当てへの一意のポインタを持っています。

00:05:53.000 --> 00:05:56.000
ポインタは明示的なアイデンティティの自然な源です。

00:05:56.000 --> 00:06:07.000
ポインタを使用するだけで個々のビューを参照することができ、2つのビューが同じポインタを共有している場合、それらが本当に同じビューであることを保証できます。

00:06:07.000 --> 00:06:16.000
しかし、SwiftUIビューは値型であり、一般的にクラスではなく構造体として表されるため、SwiftUIはポインタを使用しません。

00:06:16.000 --> 00:06:27.000
2019年の「SwiftUI essentials」トークでは、SwiftUIがビューにクラスの代わりに値タイプを使用する理由について話し合ったので、そのトークを見て詳細を学ぶことをお勧めします。

00:06:27.000 --> 00:06:37.000
今のところ、知っておくべき重要なことは、値型には、SwiftUIがビューの永続的なアイデンティティとして使用できる正規参照がないということです。

00:06:37.000 --> 00:06:42.000
代わりに、SwiftUIは他の形式の明示的なアイデンティティに依存しています。

00:06:42.000 --> 00:06:46.000
例えば、この救助犬のリストを考えてみましょう。

00:06:46.000 --> 00:06:51.000
ここで使用されるidパラメータは、明示的なアイデンティティの形式です。

00:06:51.000 --> 00:06:58.000
各救助犬のドッグタグIDは、リスト内の対応するビューを明示的に識別するために使用されます。

00:06:58.000 --> 00:07:08.000
救助犬のコレクションが変更された場合、SwiftUIはこれらのIDを使用して、何が正確に変更されたかを理解し、リスト内で正しいアニメーションを生成できます。

00:07:08.000 --> 00:07:15.000
この場合、SwiftUIは異なるセクション間を移動するビューを正しくアニメーション化することさえできました。

00:07:15.000 --> 00:07:18.000
より高度な例を見てみましょう。

00:07:18.000 --> 00:07:25.000
ここでは、ScrollViewReaderを使用して、下部のボタンを使用してビューの上部にジャンプします。

00:07:25.000 --> 00:07:35.000
Id(_:)修飾子は、カスタム識別子を使用してビューを明示的に識別する方法を提供します。この場合、ページの上部にあるヘッダービューです。

00:07:35.000 --> 00:07:45.000
次に、その識別子をスクロールビュープロキシのscrollTo(_:)メソッドに渡して、SwiftUIにその特定のビューに行くように指示することができます。

00:07:45.000 --> 00:07:55.000
これの素晴らしいところは、すべてのビューを明示的に識別する必要はなく、ヘッダーテキストのように、コードの他の場所で参照する必要があるビューだけであるということです。

00:07:55.000 --> 00:08:03.000
比較すると、ScrollViewReader、ScrollView、バックストーリーテキスト、およびBbuttonは明示的な識別子を必要としません。

00:08:03.000 --> 00:08:15.000
しかし、彼らのアイデンティティが明示的ではないからといって、たとえ明示的でなくても、すべてのビューにアイデンティティがあるため、これらのビューにアイデンティティがまったくないわけではありません。

00:08:15.000 --> 00:08:18.000
ここで構造的アイデンティティの出番です。

00:08:18.000 --> 00:08:27.000
SwiftUIは、ビュー階層の構造を使用してビューの暗黙のアイデンティティを生成するので、その必要はありません。

00:08:27.000 --> 00:08:32.000
さて、私が何を意味するのかを説明するのを手伝うために、もう少し友達を連れてきましょう。

00:08:32.000 --> 00:08:38.000
似たような犬を2匹飼っていますが、名前はわかりませんが、それぞれを識別する必要があります。

00:08:38.000 --> 00:08:44.000
さて、これらは非常に良い犬であり、彼らは非常にじっと座っていることができると仮定します。

00:08:44.000 --> 00:08:54.000
彼らが動かないことを保証することができれば、「左側の犬」や「右側の犬」のように、彼らが座っている場所に基づいてそれらを識別することができます。

00:08:54.000 --> 00:09:02.000
私たちは、被験者の相対的な配置を使用して、それらを互いに区別しています。それは構造的アイデンティティです。

00:09:02.000 --> 00:09:11.000
SwiftUIはAPI全体で構造的アイデンティティを活用し、典型的な例は、Viewコード内でifステートメントやその他の条件付きロジックを使用する場合です。

00:09:11.000 --> 00:09:18.000
条件文の構造は、各ビューを識別するための明確な方法を提供します。

00:09:18.000 --> 00:09:25.000
最初のビューは条件がtrueの場合にのみ表示され、2番目のビューは条件がfalseの場合にのみ表示されます。

00:09:25.000 --> 00:09:31.000
つまり、たとえ同じように見えたとしても、どのビューがどのビューであるかを常に伝えることができます。

00:09:31.000 --> 00:09:39.000
ただし、これは、SwiftUIがこれらのビューが元の場所にとどまり、場所を交換しないことを静的に保証できる場合にのみ機能します。

00:09:39.000 --> 00:09:45.000
SwiftUIは、ビュー階層の型構造を見ることでこれを達成します。

00:09:45.000 --> 00:09:58.000
SwiftUIがあなたのビューを見ると、その一般的なタイプが表示されます。この場合、私たちのifステートメントは、真と偽のコンテンツに対して一般的な_ConditionalContentビューに変換されます。

00:09:58.000 --> 00:10:05.000
この翻訳は、Swiftの結果ビルダーの一種であるViewBuilderによって供給されています。

00:10:05.000 --> 00:10:15.000
Viewプロトコルは、ViewBuilderでbodyプロパティを暗黙的にラップし、プロパティのロジックステートメントから単一の汎用ビューを構築します。

00:10:15.000 --> 00:10:25.000
私たちのボディプロパティのいくつかのビューリターンタイプは、この静的な複合タイプを表すプレースホルダであり、コードを乱雑にしないように隠します。

00:10:25.000 --> 00:10:42.000
このジェネリックタイプを使用すると、SwiftUIは、真のビューが常にAdoptionDirectoryであり、Falseビューが常にDogListであり、舞台裏で暗黙の安定したアイデンティティを割り当てることができることを保証できます。

00:10:42.000 --> 00:10:48.000
実際、これは以前のGood Dog、Bad Dogアプリを理解するための鍵です。

00:10:48.000 --> 00:10:55.000
上部のコードでは、条件付きブランチごとに異なるビューを定義するifステートメントがあります。

00:10:55.000 --> 00:11:06.000
SwiftUIは、ifステートメントの各ブランチが異なるアイデンティティを持つ異なるビューを表すことを理解しているため、ビューのインとアウトが遷移します。

00:11:06.000 --> 00:11:13.000
あるいは、レイアウトと色を変更する単一のPawViewを持つこともできます。

00:11:13.000 --> 00:11:19.000
別の状態に移行すると、ビューは次の位置にスムーズにスライドします。

00:11:19.000 --> 00:11:24.000
これは、一貫したアイデンティティを持つ単一のビューを変更しているからです。

00:11:24.000 --> 00:11:30.000
これらの戦略は両方とも機能しますが、SwiftUIは一般的に2番目のアプローチを推奨しています。

00:11:30.000 --> 00:11:34.000
デフォルトでは、アイデンティティを維持し、より流動的な遷移を提供するようにしてください。

00:11:34.000 --> 00:11:41.000
これはまた、ルカが後でより詳細に話すあなたのビューの寿命と状態を維持するのに役立ちます。

00:11:41.000 --> 00:11:48.000
構造的アイデンティティを理解したので、その邪悪な宿敵であるAnyViewについて話す必要があります。

00:11:48.000 --> 00:11:55.000
AnyViewの使用の影響を理解するために、それがビューの構造に及ぼす影響を見てみましょう。 ビューの構造への影響を見てみましょう。

00:11:55.000 --> 00:12:00.000
以前、AdoptionDirectoryとDogListを切り替えるために、このifステートメントを書きました。

00:12:00.000 --> 00:12:06.000
SwiftUIがこのコードを見ると、右側に一般的な型構造が表示されます。

00:12:06.000 --> 00:12:11.000
では、AnyViewを広範囲に使用する別の例を見てみましょう。

00:12:11.000 --> 00:12:17.000
これは、犬の品種を表すビューを得るために私が書いたヘルパー機能です。

00:12:17.000 --> 00:12:28.000
関数の各条件付きブランチは異なる種類のビューを返すので、Swiftは関数全体に単一の戻り値タイプを必要とするため、それらをすべてAnyViewsでラップしました。

00:12:28.000 --> 00:12:34.000
残念ながら、これはSwiftUIが私のコードの条件付き構造を見ることができないことも意味します。

00:12:34.000 --> 00:12:39.000
代わりに、AnyViewを関数の戻り値タイプとして見るだけです。

00:12:39.000 --> 00:12:49.000
これは、AnyViewが「タイプ消去ラッパータイプ」と呼ばれるもので、一般的な署名からラッピングしているビューのタイプを隠すためです。

00:12:49.000 --> 00:12:56.000
しかし、おそらくもっと重要なのは、このコードは私たち単なる人間にとっても本当に読みにくいことです。

00:12:56.000 --> 00:13:03.000
このコードを簡素化し、その構造をより多くSwiftUIに表示できるかどうか見てみましょう。

00:13:03.000 --> 00:13:12.000
まず、近くに羊がいる場合、このブランチはBorderCollieViewと一緒にSheepViewを条件付きで追加しているように見えます。

00:13:12.000 --> 00:13:22.000
ビューの周りにHStackを条件付きで追加するのではなく、HStack内にビューを条件付きで追加することで、これを簡素化できます。

00:13:22.000 --> 00:13:31.000
その変更により、各ブランチから単一のビューを返すことが簡単にわかるようになったので、ローカルのdogView変数は必要ありません。

00:13:31.000 --> 00:13:36.000
代わりに、各ブランチ内のリターンステートメントに置き換えることができます。

00:13:36.000 --> 00:13:44.000
先に見たように、通常のSwiftUIビューコードは、異なるタイプのビューを返すifステートメントを使用できます。

00:13:44.000 --> 00:13:52.000
しかし、コードからreturn文とAnyViewsを削除しようとすると、いくつかのエラーと警告が表示されます。

00:13:52.000 --> 00:13:57.000
これは、SwiftUIがヘルパー関数から単一のリターンタイプを必要とするためです。

00:13:57.000 --> 00:14:00.000
では、どうすればこれらのエラーを避けることができますか?

00:14:00.000 --> 00:14:08.000
ViewプロトコルがViewBuilderで暗黙的にラップするため、ビューのbodyプロパティは特別であることを思い出してください。

00:14:08.000 --> 00:14:14.000
これは、プロパティ内のロジックを単一の一般的なビュー構造に変換します。

00:14:14.000 --> 00:14:24.000
現在、Swiftはヘルパー関数がデフォルトでビュービルダーであると推測しませんが、ViewBuilder属性を手動で適用することでオプトインできます。

00:14:24.000 --> 00:14:32.000
これにより、警告やエラーなしに、リターンステートメントとAnyViewラッパーを削除できます。

00:14:32.000 --> 00:14:35.000
さて、私たちのコードは今かなり良さそうです!

00:14:35.000 --> 00:14:40.000
AnyViewsをすべて削除して、以前よりも読みやすくしました。

00:14:40.000 --> 00:14:57.000
そして、結果の型シグネチャを見ると、条件付きコンテンツのツリーで関数の条件付きロジックを正確に複製し、SwiftUIにビューとそのコンポーネントのアイデンティティのより豊かな視点を提供します。

00:14:57.000 --> 00:15:00.000
しかし、私たちができる小さな改善がもう1つあります。

00:15:00.000 --> 00:15:05.000
私たちの機能のトップレベルは、犬の品種のさまざまなケースと一致しているだけです。

00:15:05.000 --> 00:15:12.000
これは、ビュービルダーでもサポートされているスイッチステートメントの優れたユースケースのようです。

00:15:12.000 --> 00:15:17.000
今では、私たちの見解のすべての異なるケースをすばやく理解することがさらに簡単になりました。

00:15:17.000 --> 00:15:27.000
また、スイッチステートメントは実際には条件付きステートメントの構文的な砂糖にすぎないため、右側の結果のビューのタイプ署名はまったく同じままです。

00:15:27.000 --> 00:15:38.000
一歩下がって、AnyViewsがコードからタイプ情報を消去する方法を示し、ビュービルダーを活用して不要なAnyViewsを取り除く方法を紹介しました。

00:15:38.000 --> 00:15:43.000
一般的に、可能な限りAnyViewsを避けることをお勧めします。

00:15:43.000 --> 00:15:48.000
AnyViewsが多すぎると、コードの読み取りと理解が難しくなることがよくあります。

00:15:48.000 --> 00:15:56.000
If/elseやswitchなどの従来の制御フローステートメントにより、ビューのさまざまな可能な状態をはるかに見やすくなります。

00:15:56.000 --> 00:16:06.000
また、AnyViewはコンパイラから静的型情報を隠すため、有用な診断エラーや警告がコードに表示されるのを防ぐことができます。

00:16:06.000 --> 00:16:13.000
最後に、必要がないときにAnyViewを使用すると、パフォーマンスが低下する可能性があることに注意してください。

00:16:13.000 --> 00:16:20.000
可能であれば、ジェネリックを使用して、コードの周りにAnyViewsを渡すのではなく、静的型情報を保持します。

00:16:20.000 --> 00:16:26.000
そして、SwiftUIで基本的なタイプのビューアイデンティティを導入し終えました。

00:16:26.000 --> 00:16:35.000
明示的なアイデンティティを使用すると、ビューのアイデンティティをデータに結び付けたり、特定のビューを参照するためのカスタム識別子を提供したりできます。

00:16:35.000 --> 00:16:44.000
また、構造的アイデンティティを使用して、SwiftUIがビュー階層内のタイプと位置に基づいてビューを識別する方法を学びました。

00:16:44.000 --> 00:16:51.000
そして今、私はルカに物事を引き渡して、あなたの見解のアイデンティティが彼らの生涯と状態とどのように関連しているかについて話し合います。

00:16:51.000 --> 00:16:53.000
ルカ・ベルナルディ:ありがとう、マット。

00:16:53.000 --> 00:17:03.000
SwiftUIがあなたのビューを識別する方法を理解したので、アイデンティティがビューとデータの寿命にどのように関連しているかを探りましょう。

00:17:03.000 --> 00:17:07.000
これは、SwiftUIがどのように機能するかをよりよく理解するのに役立ちます。

00:17:07.000 --> 00:17:12.000
これを説明するために、私も友人を連れてくるつもりです。

00:17:12.000 --> 00:17:13.000
これはテセウスです。

00:17:13.000 --> 00:17:15.000
彼も可愛くないですか？

00:17:15.000 --> 00:17:18.000
誰かがもっと愛らしいと言うだろうが、私は脱線する。

00:17:18.000 --> 00:17:31.000
お気に入りのペットに名前を付けると、異なる州にいて一日中動いても、いつも同じ愛らしい猫になると考えるのは非常に直感的です。

00:17:31.000 --> 00:17:44.000
私たちが一瞬彼を見ると、彼は眠いかもしれませんし、しばらくして、適切な猫として、彼は私の存在に悩まされています - しかし、彼はいつもテセウスです。

00:17:44.000 --> 00:17:48.000
これがアイデンティティと生涯を結びつける本質です。

00:17:48.000 --> 00:17:55.000
アイデンティティを使用すると、時間の経過とともに異なる値に対して安定した要素を定義できます。

00:17:55.000 --> 00:18:00.000
言い換えれば、時間の経過とともに継続性を導入することができます。

00:18:00.000 --> 00:18:04.000
これはSwiftUIにどのように適用されるのか疑問に思うかもしれません。

00:18:04.000 --> 00:18:10.000
だから、マットが取り組んでいたアプリの猫に優しいバージョンを持ち帰りましょう。

00:18:10.000 --> 00:18:21.000
テセウスが時間の異なる瞬間に異なる状態にあるように、私たちの見解も生涯を通じて異なる状態にあります。

00:18:21.000 --> 00:18:26.000
すべての状態は、私たちの見解にとって異なる値です。

00:18:26.000 --> 00:18:33.000
アイデンティティは、これらの異なる値を時間の経過とともに単一のエンティティ（ビュー）として接続します。

00:18:33.000 --> 00:18:36.000
これを明確にするために、いくつかのコードを見てみましょう。

00:18:36.000 --> 00:18:41.000
ここでは、喉の強さを示す簡単なビューがあります。

00:18:41.000 --> 00:18:44.000
ネタバレ：テセウスはかなりうるさいです。

00:18:44.000 --> 00:18:54.000
ボディの評価を通じて、SwiftUIはこのビューの新しい値を作成します。この場合、強度値は25です。

00:18:54.000 --> 00:18:58.000
テセウスはお腹が空いていて、もっと注目を集めている。

00:18:58.000 --> 00:19:05.000
ボディはより高い強度で再び呼び出され、ビューの新しい値が作成されます。

00:19:05.000 --> 00:19:11.000
これらは、同じビュー定義から作成された2つの異なる値です。

00:19:11.000 --> 00:19:19.000
SwiftUIは、比較を実行し、ビューが変更されたかどうかを知るために値のコピーを保管します。

00:19:19.000 --> 00:19:23.000
しかし、その後、価値は破壊されます。

00:19:23.000 --> 00:19:30.000
ここで理解することが重要なのは、ビューの値がビューのアイデンティティとは異なるということです。

00:19:30.000 --> 00:19:34.000
ビューの値は一時的であり、その寿命に頼るべきではありません。

00:19:34.000 --> 00:19:39.000
しかし、あなたがコントロールできるのは彼らのアイデンティティです。

00:19:39.000 --> 00:19:49.000
ビューが最初に作成され、それが表示されると、SwiftUIは以前に説明したテクニックの組み合わせを使用してアイデンティティを割り当てます。

00:19:49.000 --> 00:19:55.000
時間が経つにつれて、更新によって駆動され、ビューの新しい値が作成されます。

00:19:55.000 --> 00:20:01.000
しかし、SwiftUIの観点から見ると、これらは同じ見解を表しています。

00:20:01.000 --> 00:20:08.000
ビューのアイデンティティが変更されるか、ビューが削除されると、その寿命は終了します。

00:20:08.000 --> 00:20:17.000
ビューの寿命について話すときはいつでも、そのビューに関連するアイデンティティの期間を参照しています。

00:20:17.000 --> 00:20:27.000
ビューのアイデンティティとその寿命を結びつけることができることは、SwiftUIがあなたの状態をどのように持続させるかを理解するための基本です。

00:20:27.000 --> 00:20:31.000
では、StateとStateObjectを画像に入れましょう。

00:20:31.000 --> 00:20:43.000
SwiftUIがあなたのビューを見て、StateまたはStateObjectを見ると、ビューの存続期間中、そのデータを保持する必要があることを知っています。

00:20:43.000 --> 00:20:52.000
言い換えれば、StateとStateObjectは、ビューのアイデンティティに関連付けられた永続的なストレージです。

00:20:52.000 --> 00:21:05.000
ビューのアイデンティティの開始時に、初めて作成されたとき、SwiftUIは初期値を使用してStateとStateObjectのメモリ内のストレージを割り当てます。

00:21:05.000 --> 00:21:09.000
ここでは、タイトル状態に焦点を当てています。

00:21:09.000 --> 00:21:19.000
ビューの存続期間中、SwiftUIはこのストレージが変異し、ビューの本体が再評価されると、このストレージを永続化します。

00:21:19.000 --> 00:21:25.000
アイデンティティの変化が国家の永続性にどのように影響するかの具体的な例を見てみましょう。

00:21:25.000 --> 00:21:31.000
私たちは同じ見解を持っていますが、2つの別々の枝にあるので、これは興味深い例です。

00:21:31.000 --> 00:21:40.000
以前から覚えていれば、構造的なアイデンティティのために、2つのビューは異なるアイデンティティを持っていると見なされます。

00:21:40.000 --> 00:21:49.000
マットはこれがアニメーションにどのように影響するかについて議論しましたが、これはあなたの状態の永続性にも大きな影響を与えます。

00:21:49.000 --> 00:21:51.000
これを実際に見てみましょう。

00:21:51.000 --> 00:22:03.000
最初にボディを評価し、真のブランチに入ると、SwiftUIは初期値で状態の永続ストレージを割り当てます。

00:22:03.000 --> 00:22:11.000
このビューの存続期間中、SwiftUIはさまざまなアクションによって変異するにつれて状態を持続します。

00:22:11.000 --> 00:22:17.000
しかし、dayTimeの値が変更され、偽のブランチを入力するとどうなりますか?

00:22:17.000 --> 00:22:23.000
SwiftUIは、これが明確なアイデンティティを持つ異なる見解であることを知っています。

00:22:23.000 --> 00:22:35.000
状態の初期値から始めて、偽のビューの新しいストレージを作成し、真のビューのストレージは直後に割り当て解除されます。

00:22:35.000 --> 00:22:38.000
しかし、私たちが本当の支店に戻ったらどうなりますか?

00:22:38.000 --> 00:22:47.000
さて、それは再び新しいビューなので、SwiftUIは州の初期値から再び開始して、新しいストレージを作成します。

00:22:47.000 --> 00:22:54.000
ここでのポイントは、アイデンティティが変更されるたびに、状態が置き換えられるということです。

00:22:54.000 --> 00:23:07.000
ここで少し立ち止まって、この重要な点を理解していることを確認してください。あなたの状態の永続性は、あなたの見解の寿命に結びついています。

00:23:07.000 --> 00:23:17.000
ビューの本質であるもの、つまりその状態を明確に分離し、それをそのアイデンティティに結びつけることができるため、これは非常に強力な概念です。

00:23:17.000 --> 00:23:21.000
他のすべてはそれから導き出すことができます。

00:23:21.000 --> 00:23:35.000
そして、あなたのデータは非常に重要なので、SwiftUIには、あなたのビューの明示的なアイデンティティの形式としてあなたのデータのアイデンティティを使用する一連のデータ駆動型構造を持っています。

00:23:35.000 --> 00:23:39.000
これの標準的な例はForEachです。

00:23:39.000 --> 00:23:44.000
それでは、ForEachを初期化するさまざまな方法を見てみましょう。

00:23:44.000 --> 00:23:49.000
これは、このタイプの周りにより良い直感を構築するのに役立ちます。

00:23:49.000 --> 00:23:54.000
ForEachの最も単純な形式は、一定の範囲を取るものです。

00:23:54.000 --> 00:24:00.000
これは、特に新しいUIのプロトタイピングを始めるときに、非常に便利な初期化子です。

00:24:00.000 --> 00:24:07.000
SwiftUIは、この範囲のオフセットを使用して、ビュービルダーによって生成されたビューを識別します。

00:24:07.000 --> 00:24:16.000
一定の範囲を要求することで、ビューの存続期間中、アイデンティティが安定していることを保証します。

00:24:16.000 --> 00:24:23.000
実際、この初期化子をダイナミックレンジで使用するのはエラーです。

00:24:23.000 --> 00:24:29.000
そして、今年は新しく、非一定の範囲を提供するときに警告が表示されます。

00:24:29.000 --> 00:24:35.000
物事をより面白くし、ダイナミックなデータ収集をもたらしましょう。

00:24:35.000 --> 00:24:41.000
この初期化子は、識別子として機能するプロパティへのコレクションとキーパスを取ります。

00:24:41.000 --> 00:24:55.000
SwiftUIはその値を使用して、コレクションの要素から生成されたすべてのビューにアイデンティティを割り当てるため、このプロパティはハッシュ可能でなければなりません。

00:24:55.000 --> 00:25:05.000
後で、Rajは、安定したアイデンティティを選択することがアプリのパフォーマンスと正確性にどのように影響するかの例をいくつか紹介します。

00:25:05.000 --> 00:25:18.000
データに安定したIDを提供するというこのアイデアは非常に重要であるため、標準ライブラリはこの機能を記述するために識別可能なプロトコルを定義します。

00:25:18.000 --> 00:25:34.000
また、SwiftUIはこのプロトコルを最大限に活用し、キーパスを省略し、プロトコル要件によって提供される識別子を使用して、データとビューに関連付けられたIDを定義できます。

00:25:34.000 --> 00:25:45.000
私がスウィフトについて本当に気に入っているのは、そのタイプシステムを利用して、解決している問題の制約を正確に説明できることです。

00:25:45.000 --> 00:25:51.000
だから、私たちがここで使用している初期化子の定義を見てみましょう。

00:25:51.000 --> 00:25:58.000
この短い定義には興味深いものがたくさんあるので、それらを解凍してみましょう。

00:25:58.000 --> 00:26:10.000
ForEachには、一般的な引数データで示されているコレクションと、コレクションの各要素からビューを生成する方法の2つの主要な部分が必要です。

00:26:10.000 --> 00:26:21.000
この初期化子の形状は、ForEachがデータのコレクションとビューのコレクションの関係を定義するという直感を与えるはずです。

00:26:21.000 --> 00:26:29.000
しかし、実際には、ここで最も興味深いのは、コレクションの要素を識別可能に制約することです。

00:26:29.000 --> 00:26:43.000
繰り返しますが、識別可能なプロトコルの目的は、SwiftUIがその生涯を通じてデータを追跡できるように、タイプがアイデンティティの安定した概念を提供できるようにすることです。

00:26:43.000 --> 00:26:50.000
実際、これは先ほど議論したアイデンティティと生涯の概念と非常によく似ています。

00:26:50.000 --> 00:26:57.000
識別可能なタイプとビュービルダーを取るSwiftUIビューは、データ駆動型のコンポーネントです。

00:26:57.000 --> 00:27:06.000
これらのビューは、指定したデータのアイデンティティを使用して、それに関連付けられたビューの寿命をスコープします。

00:27:06.000 --> 00:27:14.000
良い識別子を選択することは、ビューとデータの寿命を制御する機会です。

00:27:14.000 --> 00:27:19.000
では、このセクションで議論したことを要約しましょう。

00:27:19.000 --> 00:27:24.000
ビューの値は一時的なものであり、その寿命に頼るべきではありません。

00:27:24.000 --> 00:27:31.000
しかし、彼らのアイデンティティはそうではなく、時間の経過とともに継続性を与えるものです。

00:27:31.000 --> 00:27:39.000
あなたは自分の見解のアイデンティティをコントロールしており、アイデンティティを使用して状態の寿命を明確にスコープすることができます。

00:27:39.000 --> 00:27:51.000
そして最後に、SwiftUIはデータ駆動型コンポーネントの識別可能なプロトコルを最大限に活用しているため、データの安定した識別子を選択することが重要です。

00:27:51.000 --> 00:27:56.000
そして今、伝統を続けて、私はそれをRajに引き渡すつもりです。ラージ？

00:27:56.000 --> 00:27:58.000
ラージ・ラママーシー:ありがとう、ルカ!

00:27:58.000 --> 00:28:03.000
これまでのところ、私たちはアイデンティティとは何か、そしてそれがビューの生涯とどのように結びついているかを説明しました。

00:28:03.000 --> 00:28:07.000
次に、SwiftUIがUIを更新する方法について説明します。

00:28:07.000 --> 00:28:12.000
目標は、SwiftUIコードを構造化する方法について、より良いメンタルモデルを提供することです。

00:28:12.000 --> 00:28:17.000
また、最後にすべてを概説するいくつかの例を紹介します。

00:28:17.000 --> 00:28:21.000
依存関係に関するこの議論をキックオフするために、ビューを見てみましょう。

00:28:21.000 --> 00:28:22.000
これは簡単な見方です。

00:28:22.000 --> 00:28:26.000
犬におやつをプレゼントするボタンが表示されます。

00:28:26.000 --> 00:28:29.000
申し訳ありませんが、ルカ、私は犬派です。

00:28:29.000 --> 00:28:32.000
ビューの構造に焦点を当てましょう。

00:28:32.000 --> 00:28:34.000
まず、一番上を見てみましょう。

00:28:34.000 --> 00:28:40.000
2つのプロパティがあります。1つは犬用、もう1つはおやつ用です。

00:28:40.000 --> 00:28:43.000
これらのプロパティはビューの依存関係です。

00:28:43.000 --> 00:28:47.000
依存関係はビューへの入力にすぎません。

00:28:47.000 --> 00:28:53.000
依存関係が変更されると、ビューは新しいボディを生成する必要があります。

00:28:53.000 --> 00:28:56.000
本文は、ビューの階層を構築する場所です。

00:28:56.000 --> 00:29:03.000
このビューの階層に飛び込むと、アクション付きのボタンがあります。

00:29:03.000 --> 00:29:07.000
アクションは、ビューの依存関係の変更をトリガーするものです。

00:29:07.000 --> 00:29:11.000
コードを同等の図に交換しましょう。

00:29:11.000 --> 00:29:13.000
これが私たちのDogViewの図です。

00:29:13.000 --> 00:29:18.000
ボタンをタップすると、犬に報酬を与えるアクションが送信されます。

00:29:18.000 --> 00:29:21.000
私たちの犬はあっという間におやつを飲み込みます。

00:29:21.000 --> 00:29:25.000
そして、それは犬への変更をもたらします - 多分彼は別の犬を望んでいます。

00:29:25.000 --> 00:29:31.000
依存関係が変わったため、DogViewは新しいボディを生成します。

00:29:31.000 --> 00:29:40.000
SwiftUIのデータフローの一般的な概念の詳細については、WWDC 2020の「SwiftUIのデータエッセンシャル」をチェックしてください。

00:29:40.000 --> 00:29:43.000
次に、この図を少し単純化しましょう。

00:29:43.000 --> 00:29:48.000
ビュー階層に焦点を当てて、私たちのビューがどのように木のような構造を形成するかに注目してください。

00:29:48.000 --> 00:29:55.000
そして、犬を追加して依存関係を一番上に戻すと、それはまだ木のように見えます。

00:29:55.000 --> 00:29:59.000
ただし、DogViewは依存関係を持つ唯一のビューではありません。

00:29:59.000 --> 00:30:04.000
SwiftUIでは、各ビューは独自の依存関係を持つことができます。

00:30:04.000 --> 00:30:06.000
これまでのところ、これはまだ木のように見えます。

00:30:06.000 --> 00:30:12.000
ただし、同じ状態やその他のデータに依存する複数のビューが存在する可能性があることに注意してください。

00:30:12.000 --> 00:30:17.000
例えば、子孫の1人も犬に依存しているかもしれません。

00:30:17.000 --> 00:30:20.000
そして、これは私たちの他の依存関係の1つに起こる可能性があります。

00:30:20.000 --> 00:30:25.000
だから私たちは木から始めましたが、この構造は今では木に大まかにしか似ていません。

00:30:25.000 --> 00:30:36.000
実際、重複する線を避けるために再配置すると、この構造になり、これは実際にはグラフであり、木ではないことがわかります。

00:30:36.000 --> 00:30:42.000
実際、私たちはこの構造を「依存グラフ」と呼んでいます。

00:30:42.000 --> 00:30:49.000
この構造は、SwiftUIが新しいボディを必要とするビューのみを効率的に更新できるため、重要です。

00:30:49.000 --> 00:30:53.000
例えば、一番下の依存関係を考えてみましょう。

00:30:53.000 --> 00:30:57.000
この依存関係を調べると、2つの依存ビューがあります。

00:30:57.000 --> 00:31:04.000
グラフの秘密は、依存関係が変更された場合、それらのビューのみが無効になることです。

00:31:04.000 --> 00:31:10.000
SwiftUIは各ビューのボディを呼び出し、各ビューに新しいボディ値を生成します。

00:31:10.000 --> 00:31:14.000
SwiftUIは、無効になった各ビューの本文の値をインスタンス化します。

00:31:14.000 --> 00:31:19.000
その結果、より多くの依存関係が変わるかもしれませんが、必ずしもそうとは限りません!

00:31:19.000 --> 00:31:26.000
ビューは値タイプであるため、SwiftUIはそれらを効率的に比較して、ビューの適切なサブセットのみを更新できます。

00:31:26.000 --> 00:31:30.000
これは、ルカが以前に議論したことを見る別の方法です。

00:31:30.000 --> 00:31:32.000
ビューの値は短命です。

00:31:32.000 --> 00:31:38.000
構造体値は比較に使用されますが、ビュー自体の寿命は長くなります。

00:31:38.000 --> 00:31:43.000
そして、それが私たちが中央のビューのための新しいボディを生成するのを避けることができる方法です。

00:31:43.000 --> 00:31:47.000
アイデンティティは依存関係グラフのバックボーンです。

00:31:47.000 --> 00:31:54.000
マットが言ったように、明示的に指定されているか構造的に指定されているかにかかわらず、すべてのビューにはアイデンティティがあります。

00:31:54.000 --> 00:32:01.000
そのアイデンティティは、SwiftUIが適切なビューに変化し、UIを効率的に更新する方法です。

00:32:01.000 --> 00:32:03.000
依存関係には多くの種類があります。

00:32:03.000 --> 00:32:15.000
先ほど、トリートプロパティとドッグバインディングでいくつかの例を見ましたが、環境、状態、または観測可能なオブジェクトプロパティラッパーのいずれかを使用して依存関係を形成することもできます。

00:32:15.000 --> 00:32:20.000
次に、あなたの見解におけるアイデンティティの使用を改善する方法についてお話ししたいと思います。

00:32:20.000 --> 00:32:25.000
これは、SwiftUIがあなたのコードをよりよく理解するのに役立ちます。

00:32:25.000 --> 00:32:33.000
ルカが言ったように、ビューの寿命はそのアイデンティティの期間であり、それは識別子の安定性が重要であることを意味します。

00:32:33.000 --> 00:32:37.000
安定していない識別子は、ビューの寿命が短くなる可能性があります。

00:32:37.000 --> 00:32:46.000
また、安定した識別子を持つことは、SwiftUIがビューのストレージを継続的に作成し、グラフを更新してチャーンする必要がないため、パフォーマンスにも役立ちます。

00:32:46.000 --> 00:32:56.000
先ほど見たように、SwiftUIは永続ストレージを管理するためにライフタイムを使用するため、状態の損失を回避するために安定した識別子も重要です。

00:32:56.000 --> 00:33:03.000
識別子の安定性の重要性を説明するために、コード例を見てみましょう。

00:33:03.000 --> 00:33:06.000
この例では、私のお気に入りのペットのリストがあります。

00:33:06.000 --> 00:33:09.000
ペット構造体には識別子があります。

00:33:09.000 --> 00:33:18.000
しかし、実際にはバグがあります。新しいペットを飼うたびに、画面上のすべてが点滅します!

00:33:18.000 --> 00:33:21.000
ちょっと立ち止まって、このコードを見てみましょう。

00:33:21.000 --> 00:33:24.000
虫がどこにあるか見つけられますか?

00:33:24.000 --> 00:33:27.000
バグは、私たちの識別可能な適合性でここにあります。

00:33:27.000 --> 00:33:32.000
テストに合格しなかった場合は、心配しないでください。このセクションにはおやつはありません。

00:33:32.000 --> 00:33:40.000
問題は、この識別子が安定していないため、データが変更されるたびに新しい識別子を取得することです。

00:33:40.000 --> 00:33:44.000
代わりに、ペット配列のインデックスを使用した場合はどうなりますか?

00:33:44.000 --> 00:33:47.000
残念ながら、これにも同様の問題があります。

00:33:47.000 --> 00:33:54.000
インデックスを使用することで、ビューはコレクション内のそれぞれのペットの位置によって識別されるようになりました。

00:33:54.000 --> 00:34:02.000
私が新しい最初のお気に入りのペットを飼うと決めた場合、他のすべてのペットはアイデンティティを変更し、悪いバグを引き起こす可能性があります。

00:34:02.000 --> 00:34:16.000
この例では、ボタンはインデックスゼロに新しい要素を挿入しますが、最後のインデックスは新しいインデックスであるため、開始ではなく最後に挿入されます。

00:34:16.000 --> 00:34:23.000
これは、計算されたランダム識別子と同様に、インデックスはアイデンティティの安定した形式ではないためです。

00:34:23.000 --> 00:34:31.000
この例では、データベースからのものやペットの安定したプロパティから派生したような安定した識別子を使用する必要があります。

00:34:31.000 --> 00:34:34.000
永続的な識別子は素晴らしい選択です。

00:34:34.000 --> 00:34:39.000
今、私たちのアニメーションは素晴らしく見えます!

00:34:39.000 --> 00:34:45.000
しかし、優れた識別子に必要な特性は安定性だけではありません。

00:34:45.000 --> 00:34:49.000
良い識別子のもう一つの特性は一意性です。

00:34:49.000 --> 00:34:52.000
各識別子は、単一のビューにマッピングする必要があります。

00:34:52.000 --> 00:35:00.000
これにより、アニメーションが素晴らしく見え、パフォーマンスがスムーズになり、階層の依存関係が最も効率的な形式に反映されます。

00:35:00.000 --> 00:35:04.000
別の例を見てみましょう。

00:35:04.000 --> 00:35:09.000
この例では、私はペットのお気に入りのおやつのすべてでビューに取り組んでいます。

00:35:09.000 --> 00:35:13.000
それぞれのおやつには、名前、絵文字、有効期限があります。

00:35:13.000 --> 00:35:18.000
私はそれぞれのおやつをその名前で識別することを選択しました。

00:35:18.000 --> 00:35:22.000
この時点で - 私はあなたが推測できると確信しています - ここにもバグがあります。

00:35:22.000 --> 00:35:26.000
同じ種類のおやつが複数あるとどうなりますか?

00:35:26.000 --> 00:35:30.000
あなたのことは知りませんが、私は犬のビスケットを大量に買うのが好きです。

00:35:30.000 --> 00:35:33.000
瓶に追加すると、表示されない場合があります。

00:35:33.000 --> 00:35:39.000
問題は、おやつの名前が一意の識別子ではないことです。

00:35:39.000 --> 00:35:44.000
代わりに、治療ごとにシリアル番号またはその他の一意のIDを使用できます。

00:35:44.000 --> 00:35:48.000
そして、これはすべての正しいデータが私たちの瓶に表示されることを保証します。

00:35:48.000 --> 00:35:52.000
また、より良いアニメーションとより良いパフォーマンスを保証します。

00:35:52.000 --> 00:35:56.000
SwiftUIが識別子を必要とするとき、それはあなたの助けが必要です!

00:35:56.000 --> 00:36:01.000
ランダムな識別子を使用する場合、特に計算されたプロパティでは注意してください。

00:36:01.000 --> 00:36:06.000
一般的に、すべての識別子を安定させたいと考えています。

00:36:06.000 --> 00:36:13.000
識別子は時間の経過とともに変更されるべきではありません。新しい識別子は、新しいライフタイムを持つ新しいアイテムを表します。

00:36:13.000 --> 00:36:16.000
そして最後に、識別子は一意である必要があります。

00:36:16.000 --> 00:36:20.000
複数のビューは識別子を共有できません。

00:36:20.000 --> 00:36:25.000
SwiftUIは、アプリをスムーズかつバグのない状態に実行するために、これらのプロパティに依存しています。

00:36:25.000 --> 00:36:31.000
明示的なアイデンティティについて話したので、構造的なアイデンティティに移りたいと思います。

00:36:31.000 --> 00:36:35.000
この例では、私は以前からトリートジャーに取り組んでいます。

00:36:35.000 --> 00:36:41.000
責任あるペット愛好家として、私はペットに最高級の未期限の食品しか与えます。

00:36:41.000 --> 00:36:49.000
おやつがいつ悪くなったかを知るために、おやつの有効期限が切れたときにオプションでおやつセルを暗くする新しい修飾子を追加しました。

00:36:49.000 --> 00:36:52.000
暗くなっているセルを強調しました。

00:36:52.000 --> 00:36:55.000
修飾子に飛び込みましょう。

00:36:55.000 --> 00:37:03.000
修飾子で、私は日付を持っていて、それを現在の日付と比較して、いつビューを暗くするかを知ることができます。

00:37:03.000 --> 00:37:07.000
これは最初は問題ないようですが、ここには微妙な問題があります。

00:37:07.000 --> 00:37:15.000
条件が変化し、私たちの治療が期限切れになった場合、ここにブランチがあるため、新しいアイデンティティになります。

00:37:15.000 --> 00:37:20.000
マットが議論したように、枝は構造的アイデンティティの一形態です。

00:37:20.000 --> 00:37:26.000
これは、オプションで修正された単一のコピーではなく、コンテンツの2つのコピーがあることを意味します。

00:37:26.000 --> 00:37:29.000
ここのブランチは修飾子にあることに注意してください。

00:37:29.000 --> 00:37:39.000
明確にするために、私は修飾子とその使用サイトを同じスライドに置きましたが、あなたのプロジェクトでは、気づかずにファイル間でこのようなブランチがあるかもしれません!

00:37:39.000 --> 00:37:46.000
もちろん、ここで説明したことはすべて、ビューとビュー修飾子に適用されます。

00:37:46.000 --> 00:37:48.000
では、どうすればこれを避けることができますか?

00:37:48.000 --> 00:37:56.000
さて、1つの方法は、枝を折りたたんで、不透明度修飾子の中で条件を移動することです。

00:37:56.000 --> 00:38:01.000
このブランチを削除することで、このビューは単一のアイデンティティを持つと正しく説明しました。

00:38:01.000 --> 00:38:09.000
さらに、不透明度修飾子内の条件を移動すると、依存コードを厳密にスコープしたため、パフォーマンスに役立ちます。

00:38:09.000 --> 00:38:16.000
条件が変更されると、不透明度のみを変更する必要があります。

00:38:16.000 --> 00:38:23.000
これのコツは、条件が真の場合、不透明度が1で、このように見えることです。

00:38:23.000 --> 00:38:26.000
不透明度1は効果がありません。

00:38:26.000 --> 00:38:31.000
このような修飾子は、レンダリングされた結果に影響を与えないため、「不活性修飾子」と呼びます。

00:38:31.000 --> 00:38:36.000
SwiftUI修飾子は安いので、このパターンには固有のコストはほとんどありません。

00:38:36.000 --> 00:38:44.000
結果として生じる視覚効果がないため、フレームワークは修飾子を効率的に剪定し、コストをさらに削減できます。

00:38:44.000 --> 00:38:48.000
ブランチは素晴らしく、SwiftUIに存在するのには理由があります。

00:38:48.000 --> 00:38:56.000
しかし、不必要に使用すると、パフォーマンスの低下、驚くべきアニメーション、そしてルカが示したように、状態の喪失さえも引き起こす可能性があります。

00:38:56.000 --> 00:39:05.000
ブランチを導入するときは、1秒間一時停止し、複数のビューを表しているのか、同じビューの2つの状態を表しているのかを検討してください。

00:39:05.000 --> 00:39:12.000
見たように、単一のビューを識別するためにブランチの代わりに不活性修飾子を使用する方がうまくいくことがよくあります。

00:39:12.000 --> 00:39:16.000
以下は、不活性修飾子のほんの一例です。

00:39:16.000 --> 00:39:21.000
私は特に、環境に条件付きで書くためのtransformEnvironmentが大好きです。

00:39:21.000 --> 00:39:27.000
すべてをまとめると、私たちは今日、アイデンティティが素晴らしいパフォーマンスの秘訣の1つであることをあなたに示しました。

00:39:27.000 --> 00:39:34.000
明示的で構造的なアイデンティティと、それぞれを活用してアプリを改善する方法について議論しました。

00:39:34.000 --> 00:39:42.000
アイデンティティから、関連するストレージ、トランジションなどを制御するビューの寿命を導き出すことができます。

00:39:42.000 --> 00:39:53.000
また、SwiftUIはアイデンティティとライフタイムを使用して依存関係を形成し、UIを効率的に更新できるグラフで表されることも説明しました。

00:39:53.000 --> 00:40:01.000
SwiftUIの謎を解くとともに、バグを回避し、アプリのパフォーマンスを向上させるためのヒントとコツをいくつか紹介しました。

00:40:01.000 --> 00:40:06.000
そして、これらのトリックを学んだので、コードのツアーに参加して、彼らがあなたを助けることができるかどうかを確認してください。

00:40:06.000 --> 00:40:10.000
ありがとう、そして素晴らしいアプリを作り続けてください!

00:40:10.000 --> 23:59:59.000
♪

