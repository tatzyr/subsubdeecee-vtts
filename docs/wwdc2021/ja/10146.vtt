WEBVTT

00:00:00.000 --> 00:00:05.000
♪ベース音楽の演奏♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:15.000
アダム・ソナンスタイン:こんにちは!私の名前はアダムです。今日、AVFoundationの新機能をお見せします。

00:00:15.000 --> 00:00:17.000
今日話し合うべき3つの新機能があります。

00:00:17.000 --> 00:00:30.000
AVAsset検査の世界の新機能について話し合うのにほとんどの時間を費やし、メタデータを使用したビデオ合成とキャプションファイルのオーサリングの2つの機能を簡単に紹介します。

00:00:30.000 --> 00:00:37.000
だから、これ以上手間をかけずに、AVAsset非同期検査という最初のトピックに飛び込みましょう。

00:00:37.000 --> 00:00:42.000
しかし、まず、AVAssetの復習から始めて、少し背景があります。

00:00:42.000 --> 00:00:58.000
AVAssetは、ユーザーのデバイスに保存されているムービーファイル、リモートサーバーなどの他の場所に保存されているムービーファイル、HTTPライブストリームやコンポジションなどの他の形式の視聴覚コンテンツを表現するためのAVFoundationのコアモデルオブジェクトです。

00:00:58.000 --> 00:01:05.000
そして、あなたが資産を持っているとき、あなたは最も頻繁にそれをプレイしたいと思うが、同じように頻繁に、あなたはそれを検査したいと思うでしょう。

00:01:05.000 --> 00:01:11.000
あなたは、その期間、またはそれに含まれるオーディオとビデオのフォーマットは何ですか？のような質問をしたいですか？

00:01:11.000 --> 00:01:16.000
そして、それは私たちがこのトピックで本当に話すことです：資産検査。

00:01:16.000 --> 00:01:22.000
そして、資産を検査するときはいつでも、心に留めておくべき重要なことが2つあります。

00:01:22.000 --> 00:01:26.000
1つ目は、資産検査がオンデマンドで行われることです。

00:01:26.000 --> 00:01:29.000
これは主に、映画ファイルが非常に大きくなる可能性があるためです。

00:01:29.000 --> 00:01:32.000
長編映画は数ギガバイトのサイズになる可能性があります。

00:01:32.000 --> 00:01:38.000
後でその期間を尋ねる場合に備えて、アセットがファイル全体を熱心にダウンロードしたくないでしょう。

00:01:38.000 --> 00:01:47.000
代わりに、アセットはプロパティ値をロードするように要求するまで待ってから、その値を与えるために必要な情報だけをダウンロードします。

00:01:47.000 --> 00:01:52.000
2番目に覚えておくべきことは、資産検査は非同期プロセスであるということです。

00:01:52.000 --> 00:01:55.000
ネットワークI/Oには時間がかかる可能性があるため、これは本当に重要です。

00:01:55.000 --> 00:02:03.000
アセットがネットワーク全体に保存されている場合、AVAssetが同期ネットワーク要求を発行している間、アプリのメインスレッドをブロックしたくありません。

00:02:03.000 --> 00:02:08.000
代わりに、AVAssetは準備ができたら非同期に結果を提供します。

00:02:08.000 --> 00:02:16.000
これら2つのことを念頭に置いて、資産プロパティを検査するための新しいAPIがあり、少しこのように見えます。

00:02:16.000 --> 00:02:25.000
注意すべき主なことは、ロードするプロパティ値を伝えるために、プロパティ識別子（この場合は.duration）を取り込むこの新しいロードメソッドです。

00:02:25.000 --> 00:02:33.000
各プロパティ識別子は、コンパイル時に結果タイプに関連付けられており、ロードメソッドの戻り値タイプを決定します。

00:02:33.000 --> 00:02:38.000
この場合、期間はCMTimeなので、結果はCMTimeになります。

00:02:38.000 --> 00:02:42.000
これまでに見たことのないものの1つは、このawaitキーワードです。

00:02:42.000 --> 00:02:48.000
これはSwiftの新機能であり、コールサイトでロードメソッドが非同期であることをマークするために使用されます。

00:02:48.000 --> 00:02:58.000
async/awaitとSwiftでのより広範な並行性の取り組みの詳細については、「Meet async/await in Swift」というセッションをチェックすることをお勧めします。

00:02:58.000 --> 00:03:07.000
今のところ、新しいプロパティロード方法の使用方法を簡単に理解する方法として、awaitキーワードは呼び出し関数を2つの部分に分割すると考えたいと思います。

00:03:07.000 --> 00:03:11.000
まず、非同期操作が始まる前に起こる部分があります。

00:03:11.000 --> 00:03:15.000
この場合、アセットを作成し、その期間をロードするように依頼します。

00:03:15.000 --> 00:03:22.000
この時点で、資産はオフになり、その期間を決定するために必要なI/Oと解析を行い、その結果を待ちます。

00:03:22.000 --> 00:03:30.000
待っている間、呼び出し関数は中断されます。つまり、待機後に書かれたコードはすぐには実行されません。

00:03:30.000 --> 00:03:33.000
しかし、私たちが実行していたスレッドはブロックされていません。

00:03:33.000 --> 00:03:36.000
代わりに、私たちが待っている間、より多くの仕事をすることは自由です。

00:03:36.000 --> 00:03:42.000
非同期期間のロードが終了すると、関数の後半が実行される予定です。

00:03:42.000 --> 00:03:50.000
この場合、期間の読み込みが成功した場合、期間をローカル定数に保存し、別の関数に送信します。

00:03:50.000 --> 00:03:56.000
または、操作が失敗した場合、呼び出し元関数が再開されるとエラーがスローされます。

00:03:56.000 --> 00:04:00.000
だから、それがプロパティ値を非同期にロードする基本です。

00:04:00.000 --> 00:04:08.000
複数のプロパティの値を一度にロードすることもできます。これは、複数のプロパティ識別子をロードメソッドに渡すだけです。

00:04:08.000 --> 00:04:13.000
この場合、デュレーションとトラックの両方を同時にロードしています。

00:04:13.000 --> 00:04:16.000
これは便利であるだけでなく、より効率的になることもあります。

00:04:16.000 --> 00:04:23.000
資産があなたが興味を持っているすべてのプロパティを知っている場合、その値をロードするために必要な作業をバッチ処理できます。

00:04:23.000 --> 00:04:30.000
複数のプロパティ値をロードした結果は、プロパティ識別子に使用したのと同じ順序でロードされた値を持つタプルです。

00:04:30.000 --> 00:04:34.000
単一のプロパティ値を読み込むのと同じように、これはタイプセーフです。

00:04:34.000 --> 00:04:42.000
この場合、結果タプルの最初の要素はCMTimeで、2番目の要素はAVAssetTracksの配列です。

00:04:42.000 --> 00:04:47.000
そしてもちろん、単一の値を読み込むのと同じように、これは非同期操作です。

00:04:47.000 --> 00:04:58.000
プロパティ値を非同期にロードすることに加えて、新しい status(of: ) メソッドを使用して、値がいつでもロードされるのを待たずにプロパティのステータスを確認することもできます。

00:04:58.000 --> 00:05:04.000
Loadメソッドに使用するのと同じプロパティ識別子を渡すと、4つの可能なケースを持つ列挙型が返されます。

00:05:04.000 --> 00:05:07.000
各プロパティは.notYetLoadedとして始まります。

00:05:07.000 --> 00:05:16.000
資産検査はオンデマンドで行われるため、資産価値のロードを依頼するまで、資産はそれをロードするための作業を行っていないことを覚えておいてください。

00:05:16.000 --> 00:05:21.000
読み込み中にステータスを確認すると、.loadingケースが表示されます。

00:05:21.000 --> 00:05:29.000
または、プロパティがすでにロードされている場合は、関連する値としてロードされた値にバンドルされている.loadedケースを取得します。

00:05:29.000 --> 00:05:38.000
最後に、おそらくネットワークがダウンしたため、障害が発生した場合は、何がうまくいかなかったのかを説明するエラーがバンドルされた.failedケースが表示されます。

00:05:38.000 --> 00:05:46.000
これは、失敗したロード要求を開始したロードメソッドの呼び出しによってスローされたのと同じエラーであることに注意してください。

00:05:46.000 --> 00:05:51.000
つまり、非同期プロパティをロードし、そのステータスを確認するための新しいAPIです。

00:05:51.000 --> 00:05:56.000
AVAssetには、値を非同期にロードできるかなりの数のプロパティがあります。

00:05:56.000 --> 00:06:06.000
これらのほとんどは自己完結型の値を販売しますが、.tracksと.metadataプロパティは、資産の階層構造に下降するために使用できるより複雑なオブジェクトを販売します。

00:06:06.000 --> 00:06:10.000
.tracksプロパティの場合、AVAssetTracksの配列を取得します。

00:06:10.000 --> 00:06:18.000
AVAssetTrackには、同じロードメソッドを使用して値を非同期にロードできる独自のプロパティのコレクションがあります。

00:06:18.000 --> 00:06:29.000
同様に、.metadataプロパティはAVMetadataItemsの配列を提供し、いくつかのAVMetadataItemプロパティは、ロードメソッドを使用して非同期にロードすることもできます。

00:06:29.000 --> 00:06:37.000
この領域の新しいAPIの最後のビットは、特定のプロパティ値の特定のサブセットで取得するために使用できる非同期メソッドのコレクションです。

00:06:37.000 --> 00:06:46.000
たとえば、すべてのトラックをロードする代わりに、これらの最初の3つの方法のいずれかを使用して、トラックの一部だけをロードできます。たとえば、オーディオトラックのみです。

00:06:46.000 --> 00:06:51.000
AVAssetとAVAssetTrackの両方に、このような新しい方法がいくつかあります。

00:06:51.000 --> 00:06:56.000
だから、それが私たちがアセットを非同期に検査するためのすべての新しいAPIです。

00:06:56.000 --> 00:07:00.000
しかし、この時点で、私は小さな告白をしなければなりません。

00:07:00.000 --> 00:07:02.000
この機能のどれも実際には新しいものではありません。

00:07:02.000 --> 00:07:09.000
APIは新しいですが、これらのクラスは常にプロパティ値を非同期にロードする機能を備えています。

00:07:09.000 --> 00:07:14.000
ただ、古いAPIでは、もっとこのようなコードを書かなければならなかったでしょう。

00:07:14.000 --> 00:07:16.000
それは3段階のプロセスでした。

00:07:16.000 --> 00:07:23.000
まず、loadValuesAsynchronouslyメソッドを呼び出し、どのプロパティをロードするかを伝える文字列を与える必要があります。

00:07:23.000 --> 00:07:29.000
次に、各プロパティが実際に正常にロードされ、失敗しなかったことを確認する必要があります。

00:07:29.000 --> 00:07:38.000
その後、そこまで到達したら、対応する同期プロパティを照会するか、同期フィルタリングメソッドの1つを呼び出すことによって、ロードされた値を取得できます。

00:07:38.000 --> 00:07:43.000
これは冗長で反復的であるだけでなく、誤用も簡単です。

00:07:43.000 --> 00:07:49.000
たとえば、これらの重要なロードとステータスチェックの手順を実行するのを忘れるのは非常に簡単です。

00:07:49.000 --> 00:08:00.000
残っているのは、いつでも呼び出すことができるこれらの同期プロパティとメソッドですが、最初にプロパティ値をロードせずに呼び出すと、I/Oをブロックすることになります。

00:08:00.000 --> 00:08:06.000
メインスレッドでこれを行うと、アプリが予測不可能な時間にハングしてしまう可能性があることを意味します。

00:08:06.000 --> 00:08:21.000
したがって、新しいAPIが単に使いやすいという事実に加えて、これらの一般的な誤用も排除するという事実は、将来のリリースでSwiftクライアントの古い同期APIを廃止する予定であることを意味します。

00:08:21.000 --> 00:08:29.000
これは、これらのインターフェイスの新しい非同期バージョンに移行するのに最適な時期であり、それを支援するために、短い移行ガイドを用意しました。

00:08:29.000 --> 00:08:43.000
したがって、値をロードし、そのステータスを確認し、同期プロパティを取得する3連単を行っている場合は、ロードメソッドを呼び出して、それをすべて1つの非同期ステップで行うことができます。

00:08:43.000 --> 00:08:55.000
同様に、その3段階のプロセスを行っているが、プロパティの代わりに同期フィルタリング方法を使用している場合は、そのフィルタリング方法と同等の非同期を呼び出して、1つのステップでそれを行うことができます。

00:08:55.000 --> 00:09:13.000
古い statusOfValue(forKey: ) メソッドを使用してプロパティのステータスを切り替え、.loaded ケースにいることが確認したときに同期プロパティ値を取得する場合、新しいステータス列挙型の .loaded ケースにその .loaded 値がバンドルされているという事実を活用できます。

00:09:13.000 --> 00:09:25.000
アプリがコードの一部にプロパティの値をロードし、コードの別の部分でロードされた値を取得するなど、もう少し興味深いことをしている場合は、新しいインターフェイスでこれを行う方法がいくつかあります。

00:09:25.000 --> 00:09:28.000
ロードメソッドをもう一度呼び出すことをお勧めします。

00:09:28.000 --> 00:09:35.000
これは最も簡単で安全な方法であり、プロパティがすでにロードされている場合、これはすでに行われた作業を複製しません。

00:09:35.000 --> 00:09:38.000
代わりに、キャッシュされた値を返すだけです。

00:09:38.000 --> 00:09:46.000
ただし、これには1つの注意点があります。それは、loadメソッドは非同期メソッドであるため、非同期コンテキストからのみ呼び出すことができるということです。

00:09:46.000 --> 00:09:58.000
したがって、本当に純粋な同期コンテキストからプロパティの値を取得する必要がある場合は、プロパティのステータスを取得し、プロパティの値を同期的に取得するためにロードされていることをアサートすることができます。

00:09:58.000 --> 00:10:06.000
それでも、プロパティがすでにロードされた後でも失敗する可能性があるため、これを行うには注意する必要があります。

00:10:06.000 --> 00:10:19.000
最後に、ロードとステータスチェックの手順をスキップして、結果が利用可能になるまでブロックするプロパティとメソッドの現在の動作に依存している場合は、実際にはこれに代わるものを提供していません。

00:10:19.000 --> 00:10:24.000
これはAPIを使用するための推奨される方法ではないので、私たちは常にそれを思いとどまらせてきました。

00:10:24.000 --> 00:10:35.000
新しいプロパティローディングAPIは、単純なプロパティを取得するのと同じくらい使いやすいように設計したので、新しいAPIへの移行は簡単であるべきです。

00:10:35.000 --> 00:10:38.000
そして、それで、それが私たちの最初のトピックのすべてです。

00:10:38.000 --> 00:10:46.000
Swiftの新しい非同期機能を使用して、アセットを検査する新しい方法に本当に興奮しています。私と同じくらい楽しんでいただければ幸いです。

00:10:46.000 --> 00:10:52.000
それでは、2つの短いトピックの最初のトピックに移りましょう。メタデータを使用したビデオ合成です。

00:10:52.000 --> 00:11:01.000
ここでは、複数のビデオトラックを取り、それらを単一のビデオフレームのストリームに構成するプロセスであるビデオ合成について話しています。

00:11:01.000 --> 00:11:10.000
特に、カスタムビデオコンポジターの機能強化があり、合成を行うコードを提供します。

00:11:10.000 --> 00:11:17.000
今年の新機能では、カスタムコンポジターのフレームコンポジションコールバックで、フレームごとのメタデータを配信できます。

00:11:17.000 --> 00:11:29.000
例として、一連のGPSデータがあり、そのデータがタイムスタンプされ、ビデオと同期されており、フレームの構成方法に影響を与えるためにそのGPSデータを使用したいとします。

00:11:29.000 --> 00:11:36.000
あなたは今それを行うことができ、最初のステップは、ソースムービーの時付けされたメタデータトラックにGPSデータを書き込むことです。

00:11:36.000 --> 00:11:43.000
AVAssetWriterでこれを行うには、既存のクラス、AVAssetWriter InputMetadataAdaptorをチェックしてください。

00:11:43.000 --> 00:11:46.000
では、新しいAPIを見てみましょう。

00:11:46.000 --> 00:11:51.000
特定のトラックのコレクションを持つソースムービーから始めているとしましょう。

00:11:51.000 --> 00:11:56.000
おそらく、オーディオトラック、2つのビデオトラック、3つの時付けメタデータトラックがあります。

00:11:56.000 --> 00:12:04.000
しかし、トラック4と5には、ビデオ合成に役立つメタデータが含まれていますが、トラック6は無関係です。

00:12:04.000 --> 00:12:18.000
実行する2つのセットアップ手順があり、1つ目は、新しいソースSampleDataTrackIDsプロパティを使用して、ビデオコンポジションオブジェクトに、ビデオコンポジション全体に関連するすべての時付けメタデータトラックのIDを指示することです。

00:12:18.000 --> 00:12:34.000
それが終わったら、2番目のステップは、各ビデオ構成の指示を取り、同様のことをすることですが、今回は、その特定の命令に関連するトラックID（またはID）を伝えるためにrequiredSourceSampleData TrackIDsプロパティを設定します。

00:12:34.000 --> 00:12:41.000
これらのセットアップ手順の両方を実行することが重要です。そうしないと、コンポジションのコールバックにメタデータを取得しません。

00:12:41.000 --> 00:12:44.000
では、コールバック自体に移りましょう。

00:12:44.000 --> 00:12:54.000
コールバックで非同期ビデオコンポジション要求オブジェクトを取得すると、ビデオコンポジションのメタデータを取得するために使用する2つの新しいAPIがあります。

00:12:54.000 --> 00:13:02.000
1つ目は、その要求に関連するメタデータトラックのトラックIDをリプレイするソースSampleDataTrackIDsプロパティです。

00:13:02.000 --> 00:13:12.000
次に、各トラックIDについて、sourceTimedMetadata(byTrackID :))メソッドを使用して、そのトラックの現在のタイミングメタデータグループを取得できます。

00:13:12.000 --> 00:13:22.000
現在、AVTimedMetadataGroupはメタデータの高レベルの表現であり、値は文字列、日付、またはその他の高レベルオブジェクトに解析されます。

00:13:22.000 --> 00:13:32.000
メタデータの生のバイトを操作したい場合は、sourceSampleBuffer(byTrackID: ) メソッドを使用して、AVTimedMetadataGroup の代わりに CMSampleBuffer を取得できます。

00:13:32.000 --> 00:13:42.000
メタデータが手に入ったら、メタデータをソースビデオフレームと一緒に使用して出力ビデオフレームを生成し、リクエストを終了することができます。

00:13:42.000 --> 00:13:52.000
だから、ビデオコンポジションでもっと面白いことをできるように、カスタムビデオコンポジターのコールバックにメタデータを取り込むのに必要なのはそれだけです。

00:13:52.000 --> 00:13:57.000
さて、最後のトピックはキャプションファイルのオーサリングです。

00:13:57.000 --> 00:14:02.000
今年のmacOSの新機能であるAVFoundationは、2つのファイル形式のサポートを追加しています。

00:14:02.000 --> 00:14:07.000
まず、iTunes Timed Text、または字幕を含む.ittファイルがあります。

00:14:07.000 --> 00:14:14.000
もう1つのファイル形式は、クローズドキャプションを含むScenaristクローズドキャプション（または.sccファイル）です。

00:14:14.000 --> 00:14:26.000
AVFoundationは、これら2つのファイル形式の作成、これらのタイプのファイルからのキャプションの取り込み、および再生中の外観を確認するために実行時にキャプションをプレビューするためのサポートを追加しています。

00:14:26.000 --> 00:14:33.000
オーサリング側では、単一のキャプションを表すモデルオブジェクトであるAVCaptionから始まるいくつかの新しいAPIがあります。

00:14:33.000 --> 00:14:40.000
単一のキャプションのテキスト、位置、スタイル、その他の属性などのプロパティがあります。

00:14:40.000 --> 00:14:49.000
AVCaptionsを自分で作成し、AVAssetWriterInputCaptionAdaptorを使用して、これら2つのファイル形式のいずれかに書き込むことができます。

00:14:49.000 --> 00:15:00.000
さらに、AVCaptionConversion Validatorクラスに新しい検証サービスがあります。これは、あなたが書いているキャプションが実際に選択したファイル形式と互換性があることを確認するのに役立ちます。

00:15:00.000 --> 00:15:04.000
これが重要な理由の例として、.sccファイルを検討してください。

00:15:04.000 --> 00:15:19.000
CEA-608キャプションが含まれています。これは、特定の時間内に持つことができるキャプションの数について非常に具体的な制限があり、個々の文字とそのスタイリングを表すデータの固定ビット予算を持つまでです。

00:15:19.000 --> 00:15:33.000
したがって、バリデータは、キャプションのストリームがファイル形式と互換性があることを確認するだけでなく、タイムスタンプを調整するなど、キャプションに調整できる調整を提案します。

00:15:33.000 --> 00:15:43.000
キャプションを取り込むための新しいAPIはAVAssetReader OutputCaptionAdaptorで、これらのファイルの1つを取り、そこからAVCaptionオブジェクトで読み取ることができます。

00:15:43.000 --> 00:15:56.000
最後に、AVCaptionRendererクラスがあり、単一のキャプションまたはキャプションのグループを取り、再生中の外観のプレビューを取得するためにCGContextにレンダリングすることができます。

00:15:56.000 --> 00:16:00.000
だから、それは私たちの新しいキャプションファイルオーサリングAPIの氷山の一角にすぎません。

00:16:00.000 --> 00:16:10.000
それらを採用することに興味がある場合は、フォーラムまたは会議ラボのいずれかで私たちと連絡を取ることをお勧めします。ご質問にお答えします。

00:16:10.000 --> 00:16:14.000
そして、それが私たちの最後のトピックだったので、締めくくりましょう。

00:16:14.000 --> 00:16:26.000
その日の大きなトピックは、AVAssetプロパティの検査、オンデマンドおよび非同期に行うことの重要性、この分野の新しいAPI、および古いAPIから移行するためのいくつかのヒントでした。

00:16:26.000 --> 00:16:32.000
次に、時付きメタデータを使用して、カスタムビデオコンポジションをさらにカスタマイズすることについて話しました。

00:16:32.000 --> 00:16:38.000
最後に、キャプションファイルのオーサリングとその分野の新しいAPIについて簡単に紹介しました。

00:16:38.000 --> 00:16:40.000
今日はそれだけです。

00:16:40.000 --> 00:16:44.000
WWDC21をご覧いただき、ありがとうございます。

00:16:44.000 --> 23:59:59.000
♪

