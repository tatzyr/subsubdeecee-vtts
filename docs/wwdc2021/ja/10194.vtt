WEBVTT

00:00:00.000 --> 00:00:05.000
♪ベース音楽の演奏♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:19.000
ベン・コーエン：こんにちは、私はSwiftチームのBenです。このビデオでは、Swiftの新しい並行性機能を使用するために、既存のアプリケーションの移植について説明します。

00:00:19.000 --> 00:00:34.000
これらの新機能が、より明確な非同期コードを作成し、可能な競合状態から保護するのにどのように役立つかを確認し、コードをこの新しい操作方法に徐々に移動するためのいくつかのテクニックを見ていきます。

00:00:34.000 --> 00:00:43.000
私はコーヒートラッカーというアプリを使うつもりですが、それはウォッチコンプリケーションの作成と更新に関するWWDC 2020の講演に基づいています。

00:00:43.000 --> 00:00:52.000
これは、今日飲んだすべてのコーヒーと、時計の文字盤に現在のカフェインレベルを表示するための合併症を追跡できるシンプルなアプリです。

00:00:52.000 --> 00:01:10.000
小さなアプリですが、SwiftUIとの並行性の仕組み、watch SDKからのコールバックのデリゲート、一部のI/O、AppleのSDKの非同期APIとのインターフェースなど、私たちが考えたいさまざまなことを示しているので、私たちの目的のために使用する素晴らしい例です。

00:01:10.000 --> 00:01:12.000
では、アプリの簡単なツアーに参加しましょう。

00:01:12.000 --> 00:01:15.000
それは大まかに3つの層に分かれています。

00:01:15.000 --> 00:01:18.000
まず、UIレイヤーがあります。

00:01:18.000 --> 00:01:27.000
これは主にSwiftUIビューですが、この場合、UIレイヤーの一部としてコンプリケーションデータソースのようなものを考慮することもできます。

00:01:27.000 --> 00:01:36.000
次に、カフェイン飲料を表すいくつかの単純な値タイプと、「コーヒーモデル」と呼ばれるモデルタイプで構成されるモデルレイヤーがあります。

00:01:36.000 --> 00:01:39.000
さて、これはあなたがUIモデルと呼ぶかもしれないものです。

00:01:39.000 --> 00:01:44.000
つまり、UIレイヤーで表示するためにデータを保持する場所です。

00:01:44.000 --> 00:01:52.000
これは、SwiftUIビューを供給する観測可能なオブジェクトであり、そのすべての更新はメインスレッドで行う必要があります。

00:01:52.000 --> 00:01:59.000
アプリケーションのすべてのデータの完全なモデルではない可能性があるため、UIモデルと呼んでいます。

00:01:59.000 --> 00:02:08.000
それはあなたのデータモデルの投影またはそのサブセットかもしれません。現時点でUIに表示する必要があるものです。

00:02:08.000 --> 00:02:20.000
最後に、バックエンドレイヤーとして考えることができるものがあります。おそらくバックグラウンドで発生する処理は、モデルに入力したり、アプリの外の世界と話したりします。

00:02:20.000 --> 00:02:31.000
私たちの場合、それはユーザーのカフェイン摂取量を保存してロードするためにHealthKitへの通信を管理するこのHealthKitControllerタイプによって表されます。

00:02:31.000 --> 00:02:37.000
さて、コードを見始める前に、アプリで並行性がどのように管理されているかについて話しましょう。

00:02:37.000 --> 00:02:46.000
このアーキテクチャはかなりきれいに見えますが、並行性がどのように処理されるかを重ねると、はるかに乱雑な画像がわかります。

00:02:46.000 --> 00:02:53.000
このアプリは基本的に、コードを実行できる3つの同時キューに分かれています。

00:02:53.000 --> 00:02:57.000
UIとモデルでの作業は、メインキューで行われます。

00:02:57.000 --> 00:03:02.000
このアプリには、バックグラウンドで作業を行うためのディスパッチキューもあります。

00:03:02.000 --> 00:03:10.000
そして最後に、HealthKitから結果を返すものなど、完了ハンドラへの特定のコールバックは、任意のキューで行われます。

00:03:10.000 --> 00:03:13.000
これはかなり一般的な状況です。

00:03:13.000 --> 00:03:21.000
単純なアプリケーションアーキテクチャのように見えるものは、並行性を処理する方法の隠れた複雑さの多くを無視しています。

00:03:21.000 --> 00:03:23.000
さて、簡単なネタバレのために。

00:03:23.000 --> 00:03:32.000
Swiftの並行性を採用するにあたり、このアドホックな並行性アーキテクチャから、このようなものに移行します。

00:03:32.000 --> 00:03:37.000
私たちは、メインアクターと呼ばれるものにUIビューとモデルを置くつもりです。

00:03:37.000 --> 00:03:47.000
バックグラウンドで動作する新しいアクターを作成し、これらのタイプはasync/await機能を使用して互いにスレッドセーフ値を渡します。

00:03:47.000 --> 00:03:55.000
完了したら、並行性アーキテクチャは、型アーキテクチャと同じくらい明確で説明しやすいものでなければなりません。

00:03:55.000 --> 00:04:04.000
ここでは、「async/await」や「actors」など、馴染みのない用語をいくつか使用しましたが、コードで使用するときに簡単に説明します。

00:04:04.000 --> 00:04:12.000
しかし、これらの機能のより詳細な説明のために、はるかに詳細に入る他のいくつかの講演があります。

00:04:12.000 --> 00:04:19.000
それでは、全体的なアーキテクチャを見たので、コードに飛び込みましょう。

00:04:19.000 --> 00:04:21.000
ここにはさまざまなファイルがあります。

00:04:21.000 --> 00:04:24.000
まず、いくつかのSwift UIビュー。

00:04:24.000 --> 00:04:30.000
そして、ウォッチコンプリケーションコントローラーの拡張デリゲートがあります。

00:04:30.000 --> 00:04:39.000
カフェインドリンクを表すシンプルなモデルタイプと、これらのドリンクの配列を保持するCoffeeData UIモデルがあります。

00:04:39.000 --> 00:04:42.000
そして最後に、HealthKitControllerがあります。

00:04:42.000 --> 00:04:51.000
そして、このレイヤーでは、Swiftの新しい並行性機能のいくつかをアプリに導入し始めます。

00:04:51.000 --> 00:04:58.000
HealthKitControllerには、完了ハンドラを取るHealthKit SDKへのいくつかの異なる呼び出しが含まれています。

00:04:58.000 --> 00:05:01.000
まず、このコントローラーの保存操作を見てみましょう。

00:05:01.000 --> 00:05:09.000
それで、Control-6を押すと、このファイル内の関数のリストが表示され、保存操作に進みます。

00:05:09.000 --> 00:05:17.000
さて、新しい並行性機能に入る前に、今日はSwiftのスレッドの安全性について少し話しましょう。

00:05:17.000 --> 00:05:22.000
このコードは、いくつかの変数にアクセスし、利用可能で保存します。

00:05:22.000 --> 00:05:26.000
さて、この関数ではこれらの変数だけを読んでいるように見えます。

00:05:26.000 --> 00:05:28.000
それは安全ですか?

00:05:28.000 --> 00:05:32.000
まあ、いいえ、他のコードが同時に彼らに書き込むことができれば、そうではありません。

00:05:32.000 --> 00:05:38.000
このコードがスレッドセーフかどうかを知るには、この機能を見るだけでなく、より多くの情報が必要です。

00:05:38.000 --> 00:05:46.000
ディスパッチキューやロックは使用されていないので、このコードをスレッドセーフにするものは何でも、それがそうであると仮定すると、他の場所にある必要があります。

00:05:46.000 --> 00:05:50.000
呼び出し者は、キューを介して保存するためにすべての呼び出しをシリアル化するかもしれません。

00:05:50.000 --> 00:05:53.000
あるいは、アプリは何らかの形で構築されているので、大丈夫かもしれません。

00:05:53.000 --> 00:05:58.000
しかし、この機能を見るだけではわかりません。

00:05:58.000 --> 00:06:12.000
それを行うことができること - この機能を見て、私のプログラムの他の部分を見に行かなくても特定のことを知ることは、私たちがローカル推論と呼ぶものであり、それはSwiftにとって本当に重要な目標です。

00:06:12.000 --> 00:06:16.000
例えば、スウィフトは価値タイプに重点を置いていますが、局所的な推論に関するものです。

00:06:16.000 --> 00:06:24.000
参照型とは異なり、渡された値型がプログラムの他の場所で変異していることを心配する必要はありません。

00:06:24.000 --> 00:06:35.000
Swift 5.5で並行性のために導入されている多くの言語機能は、コードについてローカルに推論するより多くの機会を与えることです。

00:06:35.000 --> 00:06:43.000
さて、たまたま、この関数は完全にスレッドセーフですが、私はそれを自分で理解しました。コンパイラはこれらの問題を見つけるのに役立ちません。

00:06:43.000 --> 00:06:51.000
そこで、ここでは、affeineSampleをユーザーの健康データに保存するためのHealthKit SDKへの呼び出しがあります。

00:06:51.000 --> 00:06:57.000
そして、これは完了ハンドラを取り、その完了ハンドラは成功またはエラーの2つの値を取ります。

00:06:57.000 --> 00:07:01.000
操作が成功した場合、エラーはありません。エラーはnilになります。

00:07:01.000 --> 00:07:10.000
これは、ステータスを確認し、必要に応じて、ここでオプションのエラーをアンラップすることを覚えておく必要があることを意味します。

00:07:10.000 --> 00:07:13.000
さて、これは通常、Swiftでエラーを処理する方法ではありません。

00:07:13.000 --> 00:07:18.000
これは、失敗を投げることができる方法としてはるかに良いでしょう。

00:07:18.000 --> 00:07:22.000
しかし、そのアプローチは完了ハンドラーでは機能しません。

00:07:22.000 --> 00:07:29.000
しかし今、非同期メソッドを使用すると、スローできる非同期関数を持つことができます。

00:07:29.000 --> 00:07:38.000
このHealthKit保存方法は、まさにそれを行う非同期の同等のものを持っているので、それを使用することに切り替えましょう。

00:07:38.000 --> 00:07:51.000
これを行うには、まず完了ハンドラを削除し、メソッド呼び出しの前に「await」と書きます。

00:07:51.000 --> 00:07:59.000
これは、それが非同期関数呼び出しであり、この時点でコードが一時停止し、他のコードの実行を許可することを思い出させます。

00:07:59.000 --> 00:08:03.000
これが重要な理由については、少し後で戻ってきます。

00:08:03.000 --> 00:08:12.000
したがって、コンパイルすると、これをやった今、コンパイラが「試行」が必要だと言っていることがわかります。

00:08:12.000 --> 00:08:16.000
そして、これは非同期関数の大きな利点です。彼らは投げることができます。

00:08:16.000 --> 00:08:22.000
オプションのエラーをチェックすることを覚えておく必要はもうありません。

00:08:22.000 --> 00:08:30.000
そのため、このメソッド呼び出しの前に「試行」を追加でき、すぐにエラーを処理したいと考えています。

00:08:30.000 --> 00:08:33.000
だから、私たちはこの呼び出しをdoブロックでラップします...

00:08:33.000 --> 00:08:39.000
そして、エラーをキャッチします。

00:08:39.000 --> 00:08:47.000
このガードを取り外すことができます。

00:08:47.000 --> 00:08:54.000
そして今、私たちはエラーをキャッチしているので、それはもはやオプションではないので、アンラップを削除することができます。

00:08:54.000 --> 00:09:16.000
これはまた、ハッピーパスを一番上に保つためにコードを並べ替えて、成功ロギングラインをセーブのすぐ下に移動し、キャッシュ内のエラーロギングを処理できることを意味します。

00:09:16.000 --> 00:09:19.000
保存は値を返さないことに注意してください。

00:09:19.000 --> 00:09:32.000
成功/失敗を返すことは、エラーと本当に重複していたので、私たちの新しい関数はスローするか、成功するかのどちらかです。

00:09:32.000 --> 00:09:37.000
Try-catchを追加したので、コンパイラからもう1つのエラーが発生しています。

00:09:37.000 --> 00:09:44.000
非同期関数を呼び出していますが、同期関数内から呼び出しています。

00:09:44.000 --> 00:09:46.000
これはうまくいきません。

00:09:46.000 --> 00:09:57.000
非同期関数には、同期関数にはない機能があります。待機中に実行中のスレッドの制御を放棄する機能です。

00:09:57.000 --> 00:10:04.000
これを行うには、スタックフレームを処理する別の方法があり、これは同期機能と互換性がありません。

00:10:04.000 --> 00:10:12.000
したがって、1つのオプションは、代わりにこの関数を非同期にすることです。

00:10:12.000 --> 00:10:17.000
そのため、関数定義の後に非同期キーワードを追加するだけです。

00:10:17.000 --> 00:10:21.000
そして今、このファイルはコンパイルされます。

00:10:21.000 --> 00:10:24.000
しかし、プロジェクト全体はまだコンパイルされていません。

00:10:24.000 --> 00:10:34.000
この関数を非同期にすることで、問題が呼び出されるレベルに押し上げられた。

00:10:34.000 --> 00:10:40.000
私のデータモデルでは、この関数が非同期ではないため、同じコンパイラエラーが発生しています。

00:10:40.000 --> 00:10:48.000
今、私はチェーンを上り続けることができますが、今のところ、変更をローカライズし続けるための別のテクニックを見てみましょう。

00:10:48.000 --> 00:10:56.000
非同期関数を呼び出すには、非同期関数を呼び出すことが許可される新しい非同期タスクをスピンオフします。

00:10:56.000 --> 00:11:09.000
この非同期タスクは、グローバルディスパッチキューで非同期を呼び出すのと非常によく似ています。

00:11:09.000 --> 00:11:16.000
ブロックが同時に実行されるため、そこから外部関数に値を返すことはできません。

00:11:16.000 --> 00:11:21.000
したがって、切り離された閉鎖で何をするにしても、自己完結型である必要があります。

00:11:21.000 --> 00:11:28.000
この場合、saveを呼び出すだけで、値は返されないので、問題ありません。

00:11:28.000 --> 00:11:36.000
また、他のスレッドから同時に変異する可能性のあるグローバル状態に触れないように注意する必要があります。

00:11:36.000 --> 00:11:50.000
そして、これは、保存が完全にスレッドセーフであることに関連する場所です。そうしないと、この新しいタスクを追加することで、誤って新しいレース条件を導入する可能性があります。

00:11:50.000 --> 00:12:04.000
それを非同期タスクに入れたので、待ち望んでいた関数がコンパイルされ、このアプリでのasync/awaitの最初の使用を終えたので、今すぐ実行できます。

00:12:04.000 --> 00:12:13.000
これらのリファクタリングのもう1つを行い、今回は、非同期に移行するときに他のテクニックを見てみましょう。

00:12:13.000 --> 00:12:25.000
それでは、ユーザーの健康データへのアクセス許可を要求する呼び出しを見てみましょう。

00:12:25.000 --> 00:12:29.000
これは同様に、完了ハンドラでHealthKitを呼び出します。

00:12:29.000 --> 00:12:35.000
しかし、以前とは異なり、この関数はそれ自体が完了ハンドラを取ります。

00:12:35.000 --> 00:12:42.000
私がやろうとしているのは、完了ハンドラのバージョンを維持しながら、非同期になる関数の2番目のバージョンを作成することです。

00:12:42.000 --> 00:12:51.000
そうすれば、完了ハンドラで呼び出すコードの他の部分は、リファクタリング中に作業を続けることができます。

00:12:51.000 --> 00:12:56.000
「Create Async Alternative」リファクタリングアクションを使用することで、これは簡単にできます。

00:12:56.000 --> 00:13:05.000
これは、コマンド-Shift-Aで表示できるコードアクションメニューで利用でき、非同期の代替オプションを追加します。

00:13:05.000 --> 00:13:20.000
したがって、これは元の呼び出しの2番目の非同期バージョンを追加しました。

00:13:20.000 --> 00:13:30.000
そして、元の完了ハンドラコードを、新しい非同期タスクを作成するコードに置き換えました...

00:13:30.000 --> 00:13:37.000
...そして、関数の非同期バージョンを待つだけです。

00:13:37.000 --> 00:13:45.000
非同期リファクタリングにより、元のリファクタリングに非推奨の警告が追加されたことに注意してください。

00:13:45.000 --> 00:13:53.000
これらは、この新しい非同期バージョンを呼び出すためにリファクタリングから次に恩恵を受けることができる私のコードの一部に私を導くのに役立ちます。

00:13:53.000 --> 00:13:59.000
取り消して、元の完了ハンドラーバージョンに戻りましょう。

00:13:59.000 --> 00:14:08.000
このrequestAuthorizationコールバック内では、このコールバックは任意のスレッドで発生する可能性があります。

00:14:08.000 --> 00:14:14.000
そのため、その中のコードはスレッドセーフであることを知っておく必要があります。

00:14:14.000 --> 00:14:19.000
しかし、私はそうは思いません。

00:14:19.000 --> 00:14:27.000
ここでのこの割り当ては、他のスレッドでこの値を読み取る他のコードと同時に発生する可能性があります。

00:14:27.000 --> 00:14:31.000
そして、このコードには局所的な推論の欠如の別の例があります。

00:14:31.000 --> 00:14:41.000
その割り当ての後、この完了ハンドラが呼び出され、その完了ハンドラ内のコードがスレッドセーフかどうかはわかりません。

00:14:41.000 --> 00:14:52.000
この機能へのすべてのコールサイトを見て、完了ハンドラがどのように書かれているかを見て、これがOKであることを知る必要があります。

00:14:52.000 --> 00:14:58.000
では、もう一度やり直して、リファクタリングされたバージョンを見てみましょう。

00:14:58.000 --> 00:15:07.000
さて、非同期タスクは、ディスパッチコールバックに似た任意のスレッドでも実行されることを忘れないでください。

00:15:07.000 --> 00:15:14.000
したがって、この転送バージョンは、以前に持っていた完了ハンドラバージョンと同様の問題を抱えています。

00:15:14.000 --> 00:15:18.000
私たちはまだコードをより安全にしていません。

00:15:18.000 --> 00:15:21.000
コードにアクターを導入することで、すぐにこれを修正します。

00:15:21.000 --> 00:15:28.000
しかし、今のところ、この関数を非同期に変換したからといって、競合状態から解放されるわけではないことに注意する必要があります。

00:15:28.000 --> 00:15:36.000
実際、非同期機能を導入するためにリファクタリングを実行する場合のみ、コードに新しい競合条件を導入するリスクを認識する必要があります。

00:15:36.000 --> 00:15:40.000
では、この新しい非同期関数を見てみましょう。

00:15:40.000 --> 00:15:52.000
リファクタリングアクションは、このSDK APIの新しい非同期バージョンを呼び出すために、すでに完了ハンドラで呼び出しを変換しています。

00:15:52.000 --> 00:15:58.000
しかし、この関数を非同期に変換すると、興味深いことが強調されています。

00:15:58.000 --> 00:16:05.000
ここでは、完了ハンドラ技術を使用していたとき、完了ハンドラを呼び出すことなくリターンがありました。

00:16:05.000 --> 00:16:08.000
そして、これはおそらくバグでした。

00:16:08.000 --> 00:16:11.000
発信者はぶら下がったままになっていただろう。

00:16:11.000 --> 00:16:26.000
しかし、非同期関数では、値を返す必要があるため、コンパイルエラーが発生しており、失敗に対してfalseを返すだけで解決できます。

00:16:26.000 --> 00:16:43.000
そして、以前と同じように、この新しい非同期バージョンのrequestAuthorizationは実際には値を返すことはなく、成功するか、スローするかのどちらかです。

00:16:43.000 --> 00:16:47.000
したがって、この戻り値を削除するだけです。

00:16:47.000 --> 00:16:57.000
そして、代わりにこの道で、私たちはそれが成功したと仮定する必要があります...

00:16:57.000 --> 00:17:05.000
...そして、失敗のパスでは、falseを返す必要があります。

00:17:05.000 --> 00:17:31.000
今コンパイルしようとすると、他の場所の古いコードがまだ完了ハンドラーバージョンを呼び続けることができるため、プロジェクトがコンパイルされ、それを行うときにこれらの非推奨の警告が表示され、リファクタリングしたいかもしれない次の場所につながる可能性があります。

00:17:31.000 --> 00:17:35.000
さて、もう1つの非同期変換をしましょう。

00:17:35.000 --> 00:17:38.000
HealthKitからデータをロードする機能を見つけましょう。

00:17:38.000 --> 00:17:47.000
以前と同じように、古いコードを呼び出すためのスタブを作成することから始めます。

00:17:47.000 --> 00:18:38.000
次に、非同期バージョンに移動すると、ちなみに、これはオプションの完了ハンドラを取ります。これと同等の非同期は、この関数に破棄可能な結果をもたらすことです。

00:18:38.000 --> 00:19:02.000
次に、下に移動し、完了ハンドラの使用をリターンに置き換えます。

00:19:02.000 --> 00:19:06.000
たとえば、この完了ハンドラを削除して、falseを返すことができます。

00:19:06.000 --> 00:19:19.000
しかし、もう少し進むと、私たちは障害にぶつかり始め、それはHealthKitクエリAPIの配置方法に関係しています。

00:19:19.000 --> 00:19:36.000
ここでは、完了ハンドラがありますが、このクエリオブジェクトにあります。実際、私が待ちたいのは、関数の下部にあるクエリの実行です。

00:19:36.000 --> 00:19:44.000
ちなみに、この関数の上下のホッピングは、async/awaitが解決に役立つもう一つのことです。

00:19:44.000 --> 00:19:53.000
だから私がしたいのは、クエリを作成してから実行する単一の非同期関数を作成することです。

00:19:53.000 --> 00:19:58.000
私たちは今、継続と呼ばれる技術を使ってそれを行うつもりです。

00:19:58.000 --> 00:20:08.000
そこで、この関数の一番上に戻り、「queryHealthKit」というヘルパー関数を作成します。

00:20:08.000 --> 00:20:17.000
既存の機能内でこの作業をすべて行うことができますが、少し乱雑になるかもしれないので、ヘルパー機能で別々にしておくのが好きです。

00:20:17.000 --> 00:20:26.000
この関数は非同期になるので、それを待つことができ、クエリ操作が失敗する可能性があるため、スローされます。

00:20:26.000 --> 00:20:38.000
そして、この関数は、現在クエリの完了ハンドラに渡されている有用な値を返します。

00:20:38.000 --> 00:20:47.000
だから、私はクエリを実行するためのロジックを取り、それをカットし、ヘルパー関数に移動するつもりです。

00:20:47.000 --> 00:20:52.000
そして、私はまた、クエリの実行を取り、それを移動するつもりです。

00:20:52.000 --> 00:21:13.000
さて、このコードを何とか反転して、完了ハンドラーを待って、新しい非同期関数から完了ハンドラーに渡されたこれらの値を返す必要があります。

00:21:13.000 --> 00:21:15.000
そして、これは私が継続を使用する場所です。

00:21:15.000 --> 00:21:29.000
したがって、この関数では、withCheckedThrowingContinuation関数の呼び出しを待とうとした結果を返します。

00:21:29.000 --> 00:21:33.000
そして、これは継続を取るブロックを取ります。

00:21:33.000 --> 00:22:01.000
そして、このコードをそのブロック内に移動し、次にブロック内で、継続を使用してこの関数からデータを渡すか、継続を使用してここでエラーのスローを再開します。

00:22:01.000 --> 00:22:08.000
...または...

00:22:08.000 --> 00:22:18.000
...受信した値を完了ハンドラに返すのを再開します。

00:22:18.000 --> 00:22:41.000
この待機可能な関数がわかったので、元のコードで使用できます。

00:22:41.000 --> 00:22:47.000
そこで、関数を呼び出す結果を割り当てます。

00:22:47.000 --> 00:23:03.000
そして、スローされる可能性のあるエラーを処理する必要があります。

00:23:03.000 --> 00:23:23.000
実際、実際には、私はここに行って、この少しのロギングを取り、ハンドラーでそれを行うつもりです。

00:23:23.000 --> 00:23:30.000
そして、このすべての成功コードを幸せな道に移す必要があります。

00:23:30.000 --> 00:23:46.000
最後に、この閉鎖に対処する必要があります。

00:23:46.000 --> 00:23:52.000
ここでは、メインスレッドに戻って非同期のディスパッチを使用しています。

00:23:52.000 --> 00:23:59.000
しかし、私たちは完了ハンドラを捨てたので、この情報を使用してメインスレッドに中継する方法はありません。

00:23:59.000 --> 00:24:02.000
私たちは別の方法が必要です。

00:24:02.000 --> 00:24:06.000
これを解決するために、私たちは俳優を最初に利用するつもりです。

00:24:06.000 --> 00:24:17.000
Swiftの並行性モデルには、メインスレッド上のすべての操作を調整するメインアクターと呼ばれるグローバルアクターがあります。

00:24:17.000 --> 00:24:27.000
ディスパッチmain.async呼び出しを、メインアクターの実行関数の呼び出しに置き換えることができます。

00:24:27.000 --> 00:24:40.000
そして、これはメインアクターで実行するためにコードのブロックを必要とします。

00:24:40.000 --> 00:24:43.000
実行は非同期関数なので、それを待つ必要があります。

00:24:43.000 --> 00:24:57.000
メインスレッドがこの操作を処理する準備が整うまで、この機能を一時停止する必要がある可能性があるため、それを待つ必要があります。

00:24:57.000 --> 00:25:14.000
しかし、それを待っているので、完了ハンドラを削除し、代わりに値を返すことができます。

00:25:14.000 --> 00:25:35.000
さて、最後に、コンパイラは今、キャプチャされた変数について私にエラーを与えています。

00:25:35.000 --> 00:25:42.000
これは、非同期関数内でのみ発生する新しいエラーです。

00:25:42.000 --> 00:26:01.000
Swiftのクロージャは参照によって変数をキャプチャするため、可変変数（この場合はnewDrinks配列）をキャプチャすると、共有可変状態の可能性が作成され、それが競合条件の源になる可能性があります。

00:26:01.000 --> 00:26:07.000
したがって、これを行うときは、この値のコピーを作成していることを確認する必要があります。

00:26:07.000 --> 00:26:12.000
これを行う1つの方法は、このようにクロージャのキャプチャリストにnewDrinksを追加することです。

00:26:12.000 --> 00:26:29.000
しかし、多くの場合、そもそも可変変数を持たないことで、この問題を回避する方が良いです。

00:26:29.000 --> 00:26:34.000
ここでは、代わりに上記のコードを変更することでこれを行うことができます。

00:26:34.000 --> 00:26:40.000
サンプルはオプションなので、このように書かれています。

00:26:40.000 --> 00:27:00.000
しかし、代わりにできることは、newDrinksを不変の値に変更し、ifブランチで値を設定するか、「else」を追加して空の配列に設定することです。

00:27:00.000 --> 00:27:04.000
必要に応じて、ゼロ合体演算子でこれを行うこともできます。

00:27:04.000 --> 00:27:18.000
この値はvarではなくletで宣言されるようになったため、不変であり、追加のキャプチャを行うことなく問題を解決します。

00:27:18.000 --> 00:27:32.000
それでは、メインスレッドで呼び出す必要があるこの関数を見て、メインアクターについて話し続けましょう。

00:27:32.000 --> 00:27:45.000
この関数の上部には、本当に素晴らしいアイデアがあります。関数がメインスレッドで正しく実行されているというアサーションがあります。

00:27:45.000 --> 00:27:58.000
間違いを犯し、メインスレッドへのディスパッチ非同期でラップせずにこの関数を呼び出した場合、デバッグビルドでエラーが発生し、既存のコードの一部でこのプラクティスを採用する必要があります。

00:27:58.000 --> 00:28:01.000
しかし、このアプローチにはいくつかの制限があります。

00:28:01.000 --> 00:28:11.000
必要な場所にアサートを置くのを忘れる可能性があり、保存されたプロパティへのアクセスをアサートすることはできません、または少なくとも多くのボイラープレートなしではアサートすることはできません。

00:28:11.000 --> 00:28:19.000
コンパイラがこれらのルールのいくつかを適用できる方がはるかに良いので、このような間違いを犯すことはできません。

00:28:19.000 --> 00:28:23.000
そして、それが私たちが主役を使う方法です。

00:28:23.000 --> 00:28:31.000
「@MainActor」で関数に注釈を付けることができます。

00:28:31.000 --> 00:28:42.000
そして、この関数が実行される前に、発信者がメインアクターに切り替える必要があります。

00:28:42.000 --> 00:28:50.000
これをやったので、コンパイラはこの関数をメインスレッド以外の場所で呼び出すことができないため、アサーションを削除できます。

00:28:50.000 --> 00:29:13.000
発信者に戻り、このコールをこのMainActor.runブロックの外に移動することで、これが機能していることを証明できます。

00:29:13.000 --> 00:29:20.000
そして、コンパイラが教えてくれます、いいえ、私たちは主役ではないので、ここからそれを呼ぶことはできません。

00:29:20.000 --> 00:29:24.000
この機能について考える方法は次のとおりです。オプションの値によく似ています。

00:29:24.000 --> 00:29:37.000
以前はポインタのような値を持っていて、nilのチェックを覚えなければなりませんでしたが、忘れやすく、コンパイラにこのチェックが常にいくつかの言語構文砂糖と一緒に行われるようにして簡単にする方がはるかに良いです。

00:29:37.000 --> 00:29:47.000
ここでは、同様のことをやっていますが、ゼロチェックを強制する代わりに、あなたが実行している俳優を強制しています。

00:29:47.000 --> 00:29:54.000
この機能を主役に置いたので、厳密に言えば、このMainActor.runはもう必要ありません。

00:29:54.000 --> 00:30:01.000
俳優の外にいる場合は、いつでもその俳優を待つことで機能を実行できます。

00:30:01.000 --> 00:30:03.000
そして実際、それはコンパイラがここで私たちに言っていることです。

00:30:03.000 --> 00:30:10.000
この機能を実行するためにメインアクターに切り替えるには、awaitキーワードが必要だと言っています。

00:30:10.000 --> 00:30:22.000
したがって、それを追加すると、この呼び出しが実行ブロック内に入っていなくてもコードがコンパイルされます。

00:30:22.000 --> 00:30:35.000
ここでは、同期関数でawaitを使用しています - updateModelは同期です - しかし、awaitは、私たちがいる関数がメインアクターに自分自身を取得するために一時停止する必要があるかもしれないことを示しています。

00:30:35.000 --> 00:30:51.000
これはDispatchQueue.sync呼び出しを行うのと似ていると考えてください。waitを除いて、関数はブロックする代わりに一時停止し、メインスレッドへの呼び出しが完了した後に再開します。

00:30:51.000 --> 00:30:59.000
だから、私たちはもうここでそれを必要としませんが、このMainActor.runテクニックは別の理由でまだ重要です。

00:30:59.000 --> 00:31:05.000
待機するたびに、関数が一時停止し、他のコードが実行される可能性があります。

00:31:05.000 --> 00:31:10.000
それが待つポイントです:ブロックするのではなく、他のコードを実行させることです。

00:31:10.000 --> 00:31:21.000
この場合、待つ関数は1つしかなかったので、実際には問題ではありませんが、メインスレッドで複数の呼び出しを実行したい場合があります。

00:31:21.000 --> 00:31:36.000
たとえば、テーブルビューのエントリを更新するなど、UIの更新に取り組んでいる場合、実行する操作の間にメインの実行ループを回したくない場合があります。

00:31:36.000 --> 00:31:58.000
その場合、MainActor.runを使用して、メインアクターへの複数の呼び出しをグループ化して、それぞれがその間に中断することなく実行されるようにします。

00:31:58.000 --> 00:32:05.000
そのため、メインアクターを使用して、メインスレッドで実行する必要があるコードを保護しています。

00:32:05.000 --> 00:32:10.000
しかし、このクラスの他のコードはどうですか?

00:32:10.000 --> 00:32:20.000
特に、ここで割り当てられたクエリアンカーなど、ローカル変数を変異させるコード。

00:32:20.000 --> 00:32:25.000
それらがレース条件から自由であることをどのように保証できますか?

00:32:25.000 --> 00:32:32.000
または、1つの方法は、メインアクターにHealthKitControllerのすべてを置くことです。

00:32:32.000 --> 00:32:57.000
HealthKitコントローラ定義に移動し、個々のメソッドではなくクラスに「@MainActor」と書くと、このタイプのすべてのメソッドが保護され、その上に保存されたすべてのプロパティがメインスレッドで調整されます。

00:32:57.000 --> 00:33:02.000
そして、このような簡単なアプリケーションの場合、それはおそらくOKの選択でしょう。

00:33:02.000 --> 00:33:04.000
しかし、それも少し間違っているようです。

00:33:04.000 --> 00:33:13.000
このHealthKitControllerは本当に私たちのアプリのバックエンドです。メインスレッドですべての作業を行う必要はないようです。

00:33:13.000 --> 00:33:19.000
私たちは、UIに焦点を当てた活動を行うために、そのスレッドを自由に残したい。

00:33:19.000 --> 00:33:25.000
代わりに、このクラス自体を俳優に変更することができます。

00:33:25.000 --> 00:33:38.000
グローバルアクターであるメインアクターとは異なり、このアクタータイプは複数回インスタンス化できます。

00:33:38.000 --> 00:33:47.000
私のプロジェクトでは、私はまだそれらの1つだけを作成するつもりですが、同じ俳優の複数のコピーをインスタンス化することができる俳優の他の多くの用途があります。

00:33:47.000 --> 00:33:52.000
たとえば、チャットサーバーの各部屋を独自のアクターにすることができます。

00:33:52.000 --> 00:33:59.000
それで、このクラスをアクターにしたので、コンパイラが何を言うか見てみましょう。

00:33:59.000 --> 00:34:04.000
わかりました。コンパイルエラーが発生しています。

00:34:04.000 --> 00:34:08.000
では、ここで一時停止して、コンパイラのエラーについて話しましょう。

00:34:08.000 --> 00:34:18.000
これらのエラーは、コードを新しい並行性モデルに移行するときに更新する必要があるコードの場所へとあなたを導いています。

00:34:18.000 --> 00:34:22.000
これらのエラーが発生したら、彼らがあなたに言っていることを理解していることを確認してください。

00:34:22.000 --> 00:34:30.000
問題を解決する方法や理由がわからないときに、修正ボタンをマッシュする誘惑に抵抗してください。

00:34:30.000 --> 00:34:34.000
警戒すべきことの1つは、エラーのカスケードに入ることです。

00:34:34.000 --> 00:34:43.000
時々、先ほどのようにクラスをアクターに変換したり、メソッドを非同期にしたりするなど、変更を加えると、コンパイラエラーが発生します。

00:34:43.000 --> 00:34:52.000
したがって、これらのエラーのサイトに移動し、そのメソッドを非同期にしたり、メインアクターに置いたりするなど、それらのエラーを修正するためにより多くの変更を加えるのが魅力的です。

00:34:52.000 --> 00:34:58.000
問題は、これがさらに多くのエラーにつながる可能性があり、すぐに圧倒される可能性があることです。

00:34:58.000 --> 00:35:11.000
代わりに、このウォークスルーで使用しているようなテクニックを使用し、変更を分離して、プロジェクトをコンパイルして実行して、一度に1ステップずつ実行してみてください。

00:35:11.000 --> 00:35:17.000
後で削除してしまう場合でも、古いコードが機能し続けることができるようにシムを追加します。

00:35:17.000 --> 00:35:23.000
そうすれば、ポイントから徐々に移動し、進むにつれてコードを整理することができます。

00:35:23.000 --> 00:35:31.000
ちなみに、私がここでやったことは、まずHealthKitControllerのメソッドを非同期に変換してからアクターにすることです。

00:35:31.000 --> 00:35:40.000
そして、俳優の変換から始めるのではなく、そのように行うと最もうまくいくと思います。

00:35:40.000 --> 00:35:45.000
さて、これらのエラーにジャンプして見てみましょう。

00:35:45.000 --> 00:35:49.000
彼らは私たちが主役に置いた機能についてここにいます。

00:35:49.000 --> 00:35:58.000
そして、この関数では、新しいHealthKitControllerアクターの保存されたプロパティ、モデルプロパティに触れているので、これは理にかなっています。

00:35:58.000 --> 00:36:09.000
アクターはその状態を保護し、メインアクターに明示的に配置したこの関数など、アクターではなく、その格納されたプロパティに触れさせません。

00:36:09.000 --> 00:36:18.000
この関数を見ると、それが触れるアクターの唯一の状態はモデルオブジェクトのように見えます。

00:36:18.000 --> 00:36:21.000
他のすべては関数引数として渡されます。

00:36:21.000 --> 00:36:30.000
そして私にとって、これはこの機能がモデルに属していることを示唆しています。ここのモデルは実際には自己であるべきです。

00:36:30.000 --> 00:36:33.000
では、モデルに移動しましょう。

00:36:33.000 --> 00:36:47.000
そのため、この機能を取り、カットし、CoffeeData UIモデルに移動し、貼り付けることができます。

00:36:47.000 --> 00:36:54.000
プライベートではなく内部になるので、HealthKitControllerから呼び出すことができます。

00:36:54.000 --> 00:36:59.000
そして、モデルへのすべての参照を通過して削除する必要があります。なぜなら、それは今自己だからです。

00:36:59.000 --> 00:37:11.000
最後に、私たちはそれが呼ばれていた場所に行く必要があります...

00:37:11.000 --> 00:37:20.000
...そして、ここでselfをモデルへの呼び出しに置き換えます。

00:37:20.000 --> 00:37:28.000
これで、このHealthKitControllerファイルがコンパイルされ、他のファイルから新しいエラーが発生します。

00:37:28.000 --> 00:37:30.000
それらのエラーを見てみましょう。

00:37:30.000 --> 00:37:42.000
ここでは、この関数を非同期に書き換えたにもかかわらず、完了ハンドラを渡し続けることができるように、以前に呼び出した完了ハンドラシムを呼び出しています。

00:37:42.000 --> 00:37:48.000
これらの機能は現在、俳優によって保護されているので、直接呼び出すことはできません。

00:37:48.000 --> 00:37:55.000
しかし、私たちが彼らを見ると、彼らは俳優の状態の他の部分に触れません。

00:37:55.000 --> 00:38:02.000
彼らがやっているのは、タスクをスピンオフしてから、関数の非同期バージョンへの呼び出しを待つことだけです。

00:38:02.000 --> 00:38:10.000
彼らは俳優の内部状態のどの部分にも触れないので、私はそれらを「nonisolated」と呼ばれるものとしてマークすることができます。

00:38:10.000 --> 00:38:16.000
ここでも同じことをしてください。

00:38:16.000 --> 00:38:31.000
何かを非分離としてマークすると、分離された状態のいずれにも触れないことをコンパイラに伝えるため、この関数はどこからでも呼び出すことができます。

00:38:31.000 --> 00:38:41.000
演者への切り替えは、関数の非同期バージョンへの呼び出しを待つと、実際には自動的に行われます。

00:38:41.000 --> 00:38:47.000
コンパイラは、この非分離された主張が真であることを確認することに注意してください。

00:38:47.000 --> 00:39:10.000
承認ステータスを印刷するなど、アクターの状態にアクセスしようとすると、コンパイラは私を停止します。

00:39:10.000 --> 00:39:19.000
だから今、私はHealthKitControllerを人種条件から内部状態を保護するアクターに変換する作業を完了しました。

00:39:19.000 --> 00:39:30.000
次に、これらの非推奨のブレッドクラムに従って、次のファイル（CoffeeDataモデルタイプ）に取り組みましょう。

00:39:30.000 --> 00:39:39.000
現在、このクラスはObservableObjectを実装し、公開されたプロパティを持っています。

00:39:39.000 --> 00:39:56.000
SwiftUIビューに公開されたプロパティの更新は、メインスレッドで行う必要があるため、このクラスはおそらくメインアクターに置くのに適した候補です。

00:39:56.000 --> 00:40:04.000
しかし、バックグラウンドでいくつかの作業を行うためのこのバックグラウンドDispatchQueueもあります。

00:40:04.000 --> 00:40:11.000
それがどのように使われているかを見てみましょう。 

00:40:11.000 --> 00:40:15.000
そして、それはロードとセーブの2つの機能です。

00:40:15.000 --> 00:40:23.000
それは理にかなっています。あなたはおそらくメインスレッドでロードとセーブをしたくないでしょう。

00:40:23.000 --> 00:40:41.000
このようなパターンを見ると、キューが特定のアクティビティを調整するために使用されていますが、クラスの残りの部分はメインスレッドにある必要があります。これは、その背景コードを別のアクターに因数分解したいというサインです。

00:40:41.000 --> 00:40:43.000
だから、そうしましょう。

00:40:43.000 --> 00:40:49.000
では、ファイルの一番上に行って、新しいプライベートアクターを作りましょう。

00:40:49.000 --> 00:40:54.000
...私たちは「CoffeeDataStore」と呼びます。

00:40:54.000 --> 00:41:04.000
そして、別のウィンドウでCoffeeDataを開きましょう。

00:41:04.000 --> 00:41:07.000
そして、私たちの新しい俳優にコードを移動し始めます。

00:41:07.000 --> 00:41:13.000
だから、私たちはそれに独自のロガーを与えることができます。

00:41:13.000 --> 00:41:17.000
そして、俳優がいつ使用されているかがわかるように、カテゴリを微調整しましょう。

00:41:17.000 --> 00:41:25.000
そして次に、このDispatchQueueの代わりに、新しい俳優のコピーをインスタンス化します。

00:41:25.000 --> 00:41:38.000
次に、保存操作に行き、それを移動しましょう。

00:41:38.000 --> 00:41:42.000
だから、私たちはこの機能を取ることができます...

00:41:42.000 --> 00:41:47.000
...ここからそれをカットして、俳優に移します。

00:41:47.000 --> 00:41:52.000
コンパイルして、どのような問題が発生するかを見ることから始めましょう。

00:41:52.000 --> 00:41:56.000
まず、この現在のDrinksプロパティがあります。

00:41:56.000 --> 00:42:02.000
これは、このメソッドをモデルからアクターに移動する前のモデルタイプのプロパティでした。

00:42:02.000 --> 00:42:05.000
では、今どのようにアクセスできますか?

00:42:05.000 --> 00:42:12.000
さて、俳優が情報を中継する方法は、お互いに値を渡すことです。

00:42:12.000 --> 00:42:17.000
したがって、この関数はcurrentDrinksを引数として取る必要があります。

00:42:17.000 --> 00:42:32.000
保存するこの引数は、モデルタイプによって渡された保存するcurrentDrinksのリストを受け取ります。

00:42:32.000 --> 00:42:35.000
それで解決します。

00:42:35.000 --> 00:42:38.000
次に、保存された飲み物。

00:42:38.000 --> 00:42:46.000
これは、何も変わっていないときに不必要に保存しないように、最後に保存された値のコピーです。

00:42:46.000 --> 00:42:56.000
この値は保存関数と負荷関数の両方によって変異するので、間違いなくアクターによって保護される必要があります。

00:42:56.000 --> 00:42:58.000
だから、私たちのモデルでそれを見つけましょう...

00:42:58.000 --> 00:43:09.000
...そしてそれを動かしてください。

00:43:09.000 --> 00:43:13.000
わかった、次は何?

00:43:13.000 --> 00:43:33.000
さて、このプロパティdataURLは、実際にはロードと保存操作だけで使用されているので、アクターのプライベートヘルパーになるように移動できます。

00:43:33.000 --> 00:43:36.000
さて、解決すべき最後の問題です。

00:43:36.000 --> 00:43:48.000
さて、ここでエラーが発生しており、見てみると、俳優からいくつかの状態をキャプチャしているクロージャがあるように見えるので、それを修正する必要があります。

00:43:48.000 --> 00:43:50.000
では、なぜここに閉鎖があるのですか?

00:43:50.000 --> 00:44:01.000
まあ、見下ろすと、同じコードが2か所で呼び出されているからです。

00:44:01.000 --> 00:44:06.000
そして、コンパイラが私たちにとって本当に興味深いものにフラグを立てたことが判明しました。

00:44:06.000 --> 00:44:13.000
このコードが行っていることは、時計の拡張機能がバックグラウンドで実行されているかどうかを確認することです。

00:44:13.000 --> 00:44:27.000
そして、アイデアは、すでにバックグラウンドで実行されている場合は、バックグラウンドキューに入らないでください。メインスレッドにとどまり、同期して保存するタスクを実行するだけです。

00:44:27.000 --> 00:44:29.000
しかし、これは正しくないようです。

00:44:29.000 --> 00:44:39.000
アプリがバックグラウンドで実行されている場合でも、保存などのI/O操作を実行するためにメインスレッドをブロックしてはいけません。

00:44:39.000 --> 00:44:40.000
なぜアプリはこれを行うのですか?

00:44:40.000 --> 00:44:52.000
さて、保存操作が呼び出されている場所まで追跡することができます。

00:44:52.000 --> 00:44:58.000
currentDrinksのdidSetから呼び出されています。

00:44:58.000 --> 00:45:06.000
そして、プロパティが割り当てられるたびに、新しい値を保存するように発火します。

00:45:06.000 --> 00:45:12.000
さて、didSetsはとても便利ですが、少し魅力的すぎるかもしれません。

00:45:12.000 --> 00:45:16.000
現在のDrinksプロパティのすべての発信者を見てみましょう。

00:45:16.000 --> 00:45:25.000
ここまでドリルダウンしたら...

00:45:25.000 --> 00:45:41.000
...保存操作は、WatchKit拡張機能からバックグラウンドタスクを処理するための呼び出しであるこの関数から呼び出される方法のために、最終的に同期していることがわかります。

00:45:41.000 --> 00:45:45.000
現在、このハンドルAPIには契約があります。

00:45:45.000 --> 00:45:57.000
すべての作業を行うことになっていて、すべての作業が完了したら、このsetTaskCompletedWithSnapshotメソッドを呼び出します。

00:45:57.000 --> 00:46:04.000
そして、時計アプリが一時停止されるため、これを呼び出すときにすべての作業が完了することを保証する必要があります。

00:46:04.000 --> 00:46:11.000
完了したと言ったときに、私たちの保存操作のようなI/O操作がまだ実行されていることはできません。

00:46:11.000 --> 00:46:18.000
これは、非同期がコード全体でグローバルな推論を強制する方法の完璧な例です。

00:46:18.000 --> 00:46:21.000
ここで何が起こっているのかを視覚化しましょう。

00:46:21.000 --> 00:46:28.000
HealthKit関数からロードを呼び出すhandle(backgroundTasks:)から始めます。

00:46:28.000 --> 00:46:31.000
これには完了ハンドラが必要です。

00:46:31.000 --> 00:46:42.000
しかし、その後、同期的に実行されるupdateModel（）に切り替えて、同期的に保存するdidSetを同期的に呼び出します。

00:46:42.000 --> 00:46:50.000
これが完了すると、完了ハンドラが呼び出され、すべて完了したことをWatchKitに通知します。

00:46:50.000 --> 00:46:56.000
メインスレッドで同期I/Oを実行することを強制するのは、同期部分です。

00:46:56.000 --> 00:46:59.000
どうすればこれを修正できますか?

00:46:59.000 --> 00:47:08.000
完了ハンドラで修正するには、現在同期している各メソッドを更新して、完了ハンドラを取る必要があります。

00:47:08.000 --> 00:47:16.000
しかし、didSetではそれを行うことはできません。それは引数を取らず、プロパティを更新すると自動的に起動するだけです。

00:47:16.000 --> 00:47:27.000
しかし、良いニュースは、関数を同期から非同期に更新する方がはるかに簡単であるため、すべての非同期リファクタリングが報われるということです。

00:47:27.000 --> 00:47:42.000
まず、公開されたプロパティ、currentDrinksに移動し、すべての突然変異がこのファイルからのみ起こっていることを知るために、それをプライベート(セット)に変更しましょう。

00:47:42.000 --> 00:48:00.000
そして、このdidSet操作を取り、代わりにそのロジックを新しい関数に移動しましょう...

00:48:00.000 --> 00:48:03.000
...「drinksUpdated（）」と呼ばれています。

00:48:03.000 --> 00:48:11.000
俳優のセーブ操作を呼び出すので、非同期にします。

00:48:11.000 --> 00:48:19.000
そして、それは待つ必要があります...

00:48:19.000 --> 00:48:27.000
...CoffeeDataストアで、新しいcurrentDrinks値を渡す予定です。

00:48:27.000 --> 00:48:41.000
次に、currentDrinksが更新される場所に移動し、その後drinksUpdatedを呼び出す必要があります。

00:48:41.000 --> 00:49:16.000
さて、この機能では、注意すべき点が1つあります。

00:49:16.000 --> 00:49:29.000
currentDrinksのコピーを取り、それを変異させ、それを書き戻すこの操作は、すべて原子的に行われることが重要です。

00:49:29.000 --> 00:49:43.000
そして、これがawaitキーワードが不可欠である理由です。この時点で、この操作が一時停止する可能性があり、他の関数（currentDrinksを更新する可能性のある関数）が実行される可能性があることを示しています。

00:49:43.000 --> 00:50:01.000
したがって、待機する前に突然変異とライトバック全体が発生することを確認する必要があります。そうしないと、他の関数が来て、currentDrinksを変異させると、一貫性のない状態につながる可能性があります。

00:50:01.000 --> 00:50:04.000
したがって、この関数は非同期である必要があります。

00:50:04.000 --> 00:50:26.000
保存操作に移動し、この不要なバックグラウンドとフォアグラウンドブランチを排除し、毎回アクターで操作を行うことができます。

00:50:26.000 --> 00:50:39.000
わかりました。最後に、ロード操作を見てみましょう。

00:50:39.000 --> 00:50:54.000
ここで、ロジックは、バックグラウンドで実行する必要があるコードと、メインスレッドで実行する必要があるコードに分割されています。

00:50:54.000 --> 00:51:06.000
では、まず前半（背景部分）を取り、それを俳優に移しましょう。

00:51:06.000 --> 00:51:14.000
今、これを行うと、別の可能性のあるレース条件に気づきます。

00:51:14.000 --> 00:51:25.000
ここのsaveValuesはメインキューで変異していましたが、保存操作を覚えている場合は、バックグラウンドキューから読み書きされました。

00:51:25.000 --> 00:51:31.000
さて、たまたま、アプリの構築方法、ロードは起動時にしか起こらなかったので、これは大丈夫でした。

00:51:31.000 --> 00:51:40.000
しかし、繰り返しますが、それはグローバルな推論に依存しており、将来の変更を行うときに微妙な方法で壊れる可能性のある仮定のようなものです。

00:51:40.000 --> 00:51:46.000
俳優にプログラムが常に正しいことを確認させる方がはるかに良いです。

00:51:46.000 --> 00:51:47.000
だから、私たちは今それを修正するつもりです。

00:51:47.000 --> 00:51:54.000
まず、このキュー管理を削除しましょう...

00:51:54.000 --> 00:51:58.000
...機能を再インデントし、この他のキュー管理を削除します。

00:51:58.000 --> 00:52:12.000
そして、セーブと同様に、アクターのこのロード関数から値を返すだけで、ロードされた値を渡す方法が必要です。

00:52:12.000 --> 00:52:27.000
では、元の負荷に戻りましょう。

00:52:27.000 --> 00:52:36.000
そして、私たちはこのロジックを動かしたので、それを削除することができます...

00:52:36.000 --> 00:52:40.000
そして、それを待つための呼び出しに置き換えてください...

00:52:40.000 --> 00:52:59.000
...俳優からの飲み物を積み込む。

00:52:59.000 --> 00:53:06.000
さて、私たちはアクターを待っているので、この機能は非同期である必要があります。

00:53:06.000 --> 00:53:19.000
そして、私たちがここにいる間、これらの非推奨の警告をクリーンアップすることができます。

00:53:19.000 --> 00:53:50.000
そして最後に、この負荷は非同期になったので、ここで待つ必要があります。

00:53:50.000 --> 00:53:59.000
そして、私たちはここでそれを待っているので、タスクを作成する必要があります。

00:53:59.000 --> 00:54:13.000
しかし、この時点で、非同期タスクを使用した場合、新しいレース条件を導入する可能性があります。

00:54:13.000 --> 00:54:21.000
俳優の外では、この新しいタスクは任意のスレッドで実行されることを忘れないでください。

00:54:21.000 --> 00:54:28.000
currentDrinksのように、任意のスレッドから共有状態を変異させるべきではありません。

00:54:28.000 --> 00:54:40.000
さて、これを解決する1つの方法は、メインアクターに負荷関数を置くことですが、モデルタイプ全体をメインアクターに移動する方がはるかに良いです。

00:54:40.000 --> 00:55:01.000
そこで、CoffeeModelの定義に移動し、モデルタイプに「MainActor」を追加します。

00:55:01.000 --> 00:55:12.000
モデルをメインアクターに置くことで、CoffeeDataのプロパティへのすべてのアクセスがメインスレッドから行われることを保証します。

00:55:12.000 --> 00:55:23.000
そして、先に述べたように、それは観測可能なオブジェクトであり、公開されたプロパティを持っているので、これは良いことです。

00:55:23.000 --> 00:55:29.000
また、SwiftUIに公開されたプロパティは、メインスレッドでのみ更新する必要があります。

00:55:29.000 --> 00:55:36.000
また、アクターからの非同期への呼び出しもアクターで実行されることを意味します。

00:55:36.000 --> 00:55:42.000
そのため、先ほど追加したような他の「MainActor」アノテーションを削除できます。

00:55:42.000 --> 00:56:06.000
だから今、私たちがコンパイルするとき、以前に他のものを俳優に移したときとは異なり、コンパイルエラーが発生しないことに気付くかもしれません。

00:56:06.000 --> 00:56:15.000
それは、私たちがモデルに呼び込んでいる場所は、SwiftUIビューのようなものだからです。

00:56:15.000 --> 00:56:17.000
例えば、DrinkListViewに行きましょう。

00:56:17.000 --> 00:56:26.000
これで、このタイプは画面にボタンのリストを表示します。

00:56:26.000 --> 00:56:30.000
そして、それは私たちのモデルタイプにあるaddDrinkを呼び出します。

00:56:30.000 --> 00:56:35.000
しかし、このDrinkListView自体はメインアクターでもあります。

00:56:35.000 --> 00:56:40.000
そして、その方法は...

00:56:40.000 --> 00:56:47.000
...待たずにCoffeeDataモデルを呼び出すことができます。

00:56:47.000 --> 00:56:52.000
このSwiftUIビューがメインアクターにあると判断するものは何ですか?

00:56:52.000 --> 00:56:58.000
さて、それはここでのEnvironmentObjectの使用から推測されます。

00:56:58.000 --> 00:57:11.000
環境オブジェクトや観察されたオブジェクトなど、共有状態にアクセスするSwiftUIビューは、常にメインアクターにあります。

00:57:11.000 --> 00:57:15.000
他の場所では...

00:57:15.000 --> 00:57:25.000
...また、この拡張デリゲートコールからモデルにアクセスしています。

00:57:25.000 --> 00:57:43.000
この拡張デリゲートはメインスレッドで呼び出されることが保証されているため、ウォッチキットによってメインアクターで実行されていると注釈が付けられているため、モデルタイプを直接呼び出すこともできます。

00:57:43.000 --> 00:57:53.000
最後に、私たちがここにいるので、このメソッドをリファクタリングして、この非推奨の完了ハンドラーの使用を取り除きましょう。

00:57:53.000 --> 00:58:01.000
代わりに、このセクションを新しい非同期タスクでラップすることができます。

00:58:01.000 --> 00:58:17.000
このハンドラはメインスレッドで実行されているため、タスクを作成すると、そのタスクもメインスレッドで実行されます。

00:58:17.000 --> 00:58:22.000
そして、この新しいタスクの中で、私たちは今待つことができます...

00:58:22.000 --> 00:58:31.000
...HealthKitから新しいデータをロードするための呼び出し。

00:58:31.000 --> 00:58:49.000
そして、完了ハンドラを取り除くことについて本当に素晴らしいことは、関数を一緒に構成できるようになったことです。

00:58:49.000 --> 00:58:58.000
したがって、必要に応じて、この待機をifステートメントに直接移動できます。

00:58:58.000 --> 00:59:08.000
この関数呼び出しが戻ると、その中で保存操作を待つため、すべての作業が完了していることを知っています。

00:59:08.000 --> 00:59:19.000
そして、すべてのI/O操作を完了したことを知って、自信を持ってbackground.Task.setTaskCompletedを呼び出すことができます。

00:59:19.000 --> 00:59:28.000
私たちは今、これ以上の作業を完了する前に非同期操作を待つために、この素敵で構造化されたトップダウンのアプローチを持っています。

00:59:28.000 --> 00:59:35.000
ちなみに、並行性に対するこの構造化されたアプローチは、Swiftの並行性機能のもう1つの本当に重要な部分です。

00:59:35.000 --> 00:59:50.000
詳細については、関連するトークをご覧ください。この機能を利用して、複数の非同期操作が完了するのを待つなど、より複雑な例を構成する方法について説明します。

00:59:50.000 --> 01:00:01.000
このトークを見ている間、これらの新機能のいくつかがどのように機能するかを正確に疑問に思った場合は、技術のいくつかを詳細に探求する私たちのアンダーザフードトークをチェックしてください。

01:00:01.000 --> 01:00:03.000
では、要約しましょう。

01:00:03.000 --> 01:00:14.000
私たちは、サウンドタイプのアーキテクチャを持つが、見つけるのが本当に難しいいくつかの隠された競合条件を持つ複雑な並行性アーキテクチャを持ついくつかのコードを取りました。

01:00:14.000 --> 01:00:23.000
そして、新しい並行性機能の助けを借りて、並行性とタイプアーキテクチャがうまく整列するように再設計しました。

01:00:23.000 --> 01:00:27.000
そして、コンパイラは、途中でいくつかの隠された潜在的な競合条件を見つけるのに役立ちました。

01:00:27.000 --> 01:00:39.000
Swift 5.5には、タスクグループとの構造化された並行性、非同期シーケンス、SDK内のいくつかの素晴らしい新しい非同期APIなど、私たちがカバーしていないことがたくさんあります。

01:00:39.000 --> 01:00:46.000
また、このプロジェクトで行わなかったリファクタリングもいくつかありますが、自分で試してみたいかもしれません。

01:00:46.000 --> 01:00:53.000
これらのテクニックを学ぶ最善の方法は、自分のアプリで試してみることなので、楽しんで、これらのよりクリーンで安全なコーディング方法を楽しんでください。

01:00:53.000 --> 23:59:59.000
♪

