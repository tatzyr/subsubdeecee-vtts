WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:13.000
こんにちは、私はアップルのSwiftチームのエンジニア、ネイトです。

00:00:13.000 --> 00:00:18.000
今日、同僚のロバートと私は、スウィフトでの非同期/待機についてお話しします。

00:00:18.000 --> 00:00:21.000
非同期プログラミングは、多くの人にとって定期的な活動です。

00:00:21.000 --> 00:00:28.000
だから、冗長で、複雑で、さらには正しくない非同期コードを書くのは簡単すぎることを知っています。

00:00:28.000 --> 00:00:31.000
SwiftのAsync/awaitが役に立ちます。

00:00:31.000 --> 00:00:36.000
それを使用すると、通常のコードを書くのと同じくらい簡単に非同期コードを書くことができます。

00:00:36.000 --> 00:00:40.000
そして、あなたがそうするとき、あなたのコードはあなたのアイデアをよりよく反映するでしょう。

00:00:40.000 --> 00:00:42.000
それもより安全でしょう。

00:00:42.000 --> 00:00:48.000
その上、SDKには何百もの待機可能なメソッドがあります。

00:00:48.000 --> 00:00:53.000
たとえば、UIKitはUIImageからサムネイルを形成する機能を提供します。

00:00:53.000 --> 00:00:59.000
実際、そのタスクを完了するために、同期機能と非同期機能の両方を提供します。

00:00:59.000 --> 00:01:09.000
簡単なリマインダーとして、同期している関数、つまり通常の古い関数を呼び出すと、スレッドがブロックされ、その関数が終了するのを待ちます。

00:01:09.000 --> 00:01:19.000
したがって、fetchThumbnail関数が準備サムネイルを呼び出す場合--同期関数UIKitが提供する--それが終わるまで、あなたのスレッドは他に何もできません。

00:01:19.000 --> 00:01:30.000
対照的に、その関数の非同期バージョンであるprepareThumbnail (of:completionHandler:)を呼び出すと、スレッドは他の作業を自由に行うことができます。

00:01:30.000 --> 00:01:35.000
完了したら、完了ハンドラを呼び出すことで通知します。

00:01:35.000 --> 00:01:38.000
SDKは多くの非同期機能を提供します。

00:01:38.000 --> 00:01:42.000
彼らはいくつかの異なる方法で完了したことをあなたに知らせます。

00:01:42.000 --> 00:01:44.000
このような完了ハンドラを使用する人もいます。

00:01:44.000 --> 00:01:47.000
他の人はデリゲートコールバックに依存しています。

00:01:47.000 --> 00:01:50.000
そして、多くは非同期とマークされ、値を返すだけです。

00:01:50.000 --> 00:01:59.000
これらの非同期関数に共通しているのは、これを呼び出すと、スレッドのブロックをすばやく解除し、作業を開始することです。

00:01:59.000 --> 00:02:04.000
これにより、長時間の作業が完了している間、スレッドが他のことをすることができます。

00:02:04.000 --> 00:02:10.000
その違いを見るために、多くのおなじみの例を見てみましょう。

00:02:10.000 --> 00:02:18.000
ロバートと私が一緒に構築しているアプリでは、アイテムのリストがあり、各行にはサーバーに保存されている画像のサムネイルが表示されます。

00:02:18.000 --> 00:02:25.000
サムネイルをそのリストに表示する準備をするとき、ビューモデルでは、fetchThumbnailメソッドが呼び出されます。

00:02:25.000 --> 00:02:30.000
一連のステップで文字列をUIImageに変換します。

00:02:30.000 --> 00:02:36.000
まず、ビューモデルの thumbnailURLRequest メソッドは、文字列から URLRequest を作成します。

00:02:36.000 --> 00:02:42.000
次に、URLSessionのdataTaskメソッドは、そのリクエストのデータを取得します。

00:02:42.000 --> 00:02:51.000
次に、UIImage initWithDataはそのデータから画像を作成し、最後にUIImageのprepareThumbnailメソッドは元の画像からサムネイルをレンダリングします。

00:02:51.000 --> 00:02:55.000
これらの各操作は、前の結果に依存します。

00:02:55.000 --> 00:02:59.000
つまり、それらは順番に実行されなければならないということです。

00:02:59.000 --> 00:03:15.000
これらの操作のいくつかは、値をすばやく返します。文字列からURLRequestを構築し、データからUIImageを構築することはどちらもこんな感じです。そのため、関数がたまたまオンになっているスレッドで実行し、これらを同期呼び出しにすることは問題ありません。

00:03:15.000 --> 00:03:17.000
しかし、そのうちのいくつかは時間がかかります。

00:03:17.000 --> 00:03:21.000
画像を構成するすべてのデータをダウンロードするにはしばらく時間がかかります。

00:03:21.000 --> 00:03:27.000
そして、そこから見栄えの良いサムネイルをレンダリングするには、高価な作業を行うためのデバイスが必要です。

00:03:27.000 --> 00:03:32.000
そのため、SDKはこれらのタスクを完了するための非同期機能を提供します。

00:03:32.000 --> 00:03:35.000
したがって、これらの呼び出しは非同期であるべきです。

00:03:35.000 --> 00:03:43.000
Robertと私がasync/awaitでスピンを取る前に、完了ハンドラを使用して関数を書いていました。

00:03:43.000 --> 00:03:52.000
この関数は、文字列、最初の操作への入力、および出力を呼び出すために使用される完了ハンドラを引数として受け取ります。

00:03:52.000 --> 00:03:57.000
fetchThumbnailが呼び出されると、まずthumbnailURLRequestを呼び出します。

00:03:57.000 --> 00:04:02.000
このメソッドは同期的であるため、完了ハンドラは必要ありません。

00:04:02.000 --> 00:04:10.000
次に、共有URLSessionインスタンスでdataTaskを呼び出し、そのURLRequestと完了ハンドラを渡します。

00:04:10.000 --> 00:04:17.000
同期的にURLSessionDataTaskを生成し、非同期作業を開始するために再開する必要があります。

00:04:17.000 --> 00:04:22.000
その後、FetchThumbnailが戻り、スレッドは他の作業を自由に行うことができます。

00:04:22.000 --> 00:04:32.000
画像のダウンロードには時間がかかり、データがストリーミングされるのを待っているスレッドをブロックしたくないので、それは本当に重要です。

00:04:32.000 --> 00:04:37.000
最終的に画像のダウンロードが完了するか、何かがうまくいかないかのどちらかです。

00:04:37.000 --> 00:04:50.000
いずれにせよ、要求は完了し、dataTaskに渡された完了ハンドラは、データ、応答、およびエラーのいくつかのオプション値で呼び出されます。

00:04:50.000 --> 00:04:57.000
何か問題が発生した場合は、完了ハンドラを呼び出してエラーを渡す必要があります。

00:04:57.000 --> 00:05:03.000
すべてがうまくいった場合は、UIImageのinitWithDataを使用してデータから画像を作成します。

00:05:03.000 --> 00:05:08.000
同期しているため、結果を処理するために通常の直線コードを書くことができます。

00:05:08.000 --> 00:05:11.000
画像が生成されなければ、完了です。

00:05:11.000 --> 00:05:19.000
そして、画像が生成された場合、最後にUIKitのメソッドprepareThumbnailを呼び出して、完了ハンドラを渡します。

00:05:19.000 --> 00:05:25.000
その作業が完了している間、スレッドはブロック解除され、他の作業を行うために解放されます。

00:05:25.000 --> 00:05:34.000
サムネイルが準備された後、サムネイルの準備が成功した場合、またはnilの場合、その完了ハンドラは画像で呼び出されます。

00:05:34.000 --> 00:05:41.000
成功した場合は、完了ハンドラを呼び出すと、画像を渡します。

00:05:41.000 --> 00:05:44.000
しかし、ロバートが私に指摘したように、問題があります。

00:05:44.000 --> 00:05:51.000
FetchThumbnailの発信者は、失敗した場合でも、fetchThumbnailが作業を終了したときに通知されることを期待しています。

00:05:51.000 --> 00:05:55.000
そして現在、私たちは発信者を置き去りにしています。

00:05:55.000 --> 00:06:01.000
私は「guard else return」を書くのに慣れているので、完了ハンドラを2回呼び出すのを忘れました。

00:06:01.000 --> 00:06:11.000
したがって、データからのUIImageの作成やサムネイルの準備に失敗した場合、fetchThumbnailの呼び出し者に通知されることはなく、行も更新されません。

00:06:11.000 --> 00:06:15.000
それは永遠にスピナーを見せるだけです。

00:06:15.000 --> 00:06:22.000
だからこそ、fetchThumbnailの著者である私たちにとって、何が起こっても発信者に通知することが非常に重要です。

00:06:22.000 --> 00:06:26.000
したがって、機能を通るすべてのパスは、それらを通知する必要があります。

00:06:26.000 --> 00:06:32.000
これを行うには、エラーが発生した場合に完了ハンドラを呼び出し、エラーを渡す必要があります。

00:06:32.000 --> 00:06:36.000
通常の関数は、それをスローすることで呼び出し元にエラーを返します。

00:06:36.000 --> 00:06:44.000
そして、Swiftは、関数を通じて実行がどのように進行しても、値が返されない場合、エラーがスローされることを保証します。

00:06:44.000 --> 00:06:48.000
しかし、ここではSwiftの通常のエラー処理メカニズムを使用することはできません。

00:06:48.000 --> 00:06:52.000
問題が発生した場合、これらの完了ハンドラ内からエラーをスローすることはできません。

00:06:52.000 --> 00:06:57.000
スウィフトが私たちの仕事をチェックできないことを意味するので、それは残念です。

00:06:57.000 --> 00:07:02.000
Swiftにとって、fetchThumbnailsのような補完ハンドラは単なるクロージャです。

00:07:02.000 --> 00:07:08.000
常に呼び出されていることを確認したいのですが、Swiftではそれを強制する方法はありません。

00:07:08.000 --> 00:07:13.000
だからこそ、その2人の警備員から戻ったときにコンパイルエラーが発生しませんでした。

00:07:13.000 --> 00:07:18.000
ロバートは、私がそれを修正するのに問題があることを指摘しました。

00:07:18.000 --> 00:07:23.000
したがって、完了ハンドラが最終的に呼び出されることを確認するのはあなた次第です。

00:07:23.000 --> 00:07:30.000
私たち二人がこの関数を書くために座ったとき、私たちは次から次へいくつかの操作をしたかっただけです。

00:07:30.000 --> 00:07:35.000
2つは同期で、2つは非同期で、完了ハンドラを取りました。

00:07:35.000 --> 00:07:43.000
私たちは成功しましたが、微妙なバグが忍び寄る5つの機会を含む約20行のコードで終わりました。

00:07:43.000 --> 00:07:53.000
私たちが望んでいたのは、これらの4つの操作を順番に実行することでしたが、私たちが得たものは従うのが難しく、正しく理解するのが難しく、私たちの意図を覆い隠しています。

00:07:53.000 --> 00:07:56.000
さて、これをもう少し安全にする方法があります。

00:07:56.000 --> 00:08:01.000
たとえば、標準ライブラリの結果タイプを使用できました。

00:08:01.000 --> 00:08:08.000
そして、これは少し安全ですが、それはまた式典を追加し、私たちのコードを醜く、わずかに長くします。

00:08:08.000 --> 00:08:14.000
人々はまた、他の方法で非同期コードを改善するために先物のような技術を使用しています。

00:08:14.000 --> 00:08:19.000
しかし、これらのアプローチのいずれも、シンプルで簡単で安全なコードを提供してくれません。

00:08:19.000 --> 00:08:22.000
Async/awaitで、私たちはもっとうまくやることができます。

00:08:22.000 --> 00:08:26.000
ロバートと私は、これらの4つのステップを実行する機能を書き直しました。

00:08:26.000 --> 00:08:30.000
そして今回は、async/awaitを使用しました。

00:08:30.000 --> 00:08:33.000
この関数は依然として文字列を引数として取ります。

00:08:33.000 --> 00:08:40.000
しかし、前回は完了ハンドラも渡されましたが、今回は代わりに関数は非同期です。

00:08:40.000 --> 00:08:50.000
関数を非同期にマークするとき、キーワードはこのように関数署名の「スロー」の直前、または関数がスローしない場合は矢印の前に行く必要があります。

00:08:50.000 --> 00:08:56.000
関数を非同期にマークすると、それとその署名がより簡単になります。

00:08:56.000 --> 00:09:01.000
画像のサムネイルが正常に実行されると、そのサムネイルは単に返されます。

00:09:01.000 --> 00:09:05.000
そして、エラーが発生した場合、それはただスローされます。

00:09:05.000 --> 00:09:12.000
fetchThumbnailが呼び出されると、以前と同じように、thumbnailURLRequestを呼び出すことで始まります。

00:09:12.000 --> 00:09:17.000
この関数は同期的であるため、スレッドはブロックされ、その作業を行います。

00:09:17.000 --> 00:09:23.000
次に、共有URLSessionでdata(for: request)を呼び出すことで、データのダウンロードを開始します。

00:09:23.000 --> 00:09:29.000
dataTaskと同様に、このメソッドはFoundationによっても提供され、非同期でもあります。

00:09:29.000 --> 00:09:33.000
しかし、dataTaskとは異なり、データメソッドは待機可能です。

00:09:33.000 --> 00:09:38.000
だから、それが呼び出された後、それはすぐに自分自身を一時停止し、スレッドのブロックを解除します。

00:09:38.000 --> 00:09:42.000
その後、スレッドは他の作業を自由に行うことができます。

00:09:42.000 --> 00:09:52.000
データメソッドが「スロー」とマークされているため、「トライ」がここにあります。以前のバージョンでは、エラーをチェックし、完了ハンドラを明示的に呼び出す方法を覚えていますか?

00:09:52.000 --> 00:09:59.000
ここ待機可能なバージョンでは、そのコードはすべてtryキーワードだけに煮詰められています。

00:09:59.000 --> 00:10:18.000
「Throws」とマークされた関数を呼び出すために「try」が必要なように、「await」は「async」とマークされた関数を呼び出すために必要です。式に複数の非同期関数呼び出しがある場合、複数のスロー関数呼び出しを持つ式に対して1つの「試行」だけを必要とするのと同じように、「await」を一度だけ書く必要があります。

00:10:18.000 --> 00:10:30.000
全体として、関数呼び出しは「try await」とマークされています。スローする非同期式を扱うときは、このように待つ前にtryを置く必要があります。

00:10:30.000 --> 00:10:38.000
最終的に、データのダウンロードが完了すると、データメソッドが再開され、fetchThumbnailに戻ります。

00:10:38.000 --> 00:10:44.000
その時点で、データメソッドが返す値またはスローするエラーが流れ込みます。

00:10:44.000 --> 00:10:49.000
エラーをスローした場合、fetchThumbnailはそのエラー自体を順番にスローします。

00:10:49.000 --> 00:10:54.000
それ以外の場合は、データ変数と応答変数が定義されます。

00:10:54.000 --> 00:11:02.000
これは、URLSessionのdataTaskメソッドに渡された完了ハンドラが呼び出されたときの以前のバージョンのfetchThumbnailで起こったことと似ています。

00:11:02.000 --> 00:11:08.000
どちらのバージョンでも、URLSessionの非同期メソッドによって生成された値とエラーが流れ込みました。

00:11:08.000 --> 00:11:12.000
しかし、待ち時間のあるバージョンはとてもシンプルです。

00:11:12.000 --> 00:11:14.000
それは私たちが何を意味するのかを正確に述べています。

00:11:14.000 --> 00:11:20.000
このリクエストを行い、変数に戻す値を割り当てて、それらを使用できるようにします。

00:11:20.000 --> 00:11:24.000
そして、問題に遭遇した場合は、エラーをスローします。

00:11:24.000 --> 00:11:30.000
次に、fetchThumbnailはダウンロードしたデータからUIImageを作成しようとします。

00:11:30.000 --> 00:11:37.000
それが成功すると、サムネイルプロパティにアクセスすることで、その画像のサムネイルがレンダリングされます。

00:11:37.000 --> 00:11:48.000
サムネイルが形成されている間、サムネイルプロパティが最終的に再開され、fetchThumbnailに戻るまで、スレッドは他のことを自由に行うことができます。

00:11:48.000 --> 00:11:52.000
サムネイルがレンダリングされると、fetchThumbnailがそれを返します。

00:11:52.000 --> 00:11:54.000
そうでなければ、エラーがスローされます。

00:11:54.000 --> 00:12:03.000
完了ハンドラーバージョンとは対照的に、サムネイルがレンダリングされない場合、Swiftはここでエラーをスローするか、値を返すことを保証します。

00:12:03.000 --> 00:12:06.000
しかし、私たちは黙って失敗することはできません。

00:12:06.000 --> 00:12:10.000
そして、それだけです。それが私たちが必要とするすべてのコードです。

00:12:10.000 --> 00:12:14.000
この関数は、完了ハンドラのバージョンが以前とまったく同じことをします。

00:12:14.000 --> 00:12:17.000
しかし、20行のコードの代わりに、6行しかない。

00:12:17.000 --> 00:12:20.000
そして、それはすべて直線コードです。

00:12:20.000 --> 00:12:25.000
順番に実行する必要がある4つの操作は、次々にリストされています。

00:12:25.000 --> 00:12:33.000
そして、Swiftは、関数が完了したときに、問題が発生した場合に返すか、投げることによって、常に呼び出し元の呼び出し者に通知することを確認します。

00:12:33.000 --> 00:12:46.000
これは、async/awaitを使用して非同期Swiftコードを変換し、より安全で短くし、意図をよりよく反映させる方法の一例にすぎません。

00:12:46.000 --> 00:12:50.000
fetchThumbnailの実装方法の詳細を掘り下げてみましょう。

00:12:50.000 --> 00:13:01.000
最後から2行目では、関数呼び出しがないにもかかわらず、サムネイルのレンダリングを開始する式は「await」とマークされています。それは、サムネイルプロパティが非同期だからです。

00:13:01.000 --> 00:13:03.000
関数だけでなく、非同期にすることができます。

00:13:03.000 --> 00:13:08.000
プロパティもできますし、初期化子もできます。

00:13:08.000 --> 00:13:11.000
現在、サムネイルプロパティはSDKの一部ではありません。

00:13:11.000 --> 00:13:13.000
それは実際にロバートが付け加えたものです。

00:13:13.000 --> 00:13:16.000
それを見てみましょう。 てみましょう。

00:13:16.000 --> 00:13:22.000
彼はUIImageの拡張機能でこのプロパティを定義し、その実装は短いです。

00:13:22.000 --> 00:13:29.000
それはCGSizeを形成し、PreparingThumbnail(ofSize)によってそれを渡す結果を待っています。

00:13:29.000 --> 00:13:35.000
ところで、selfのこのメソッドは、以前に使用したメソッドの待機可能なバージョンです。

00:13:35.000 --> 00:13:38.000
注目すべきことがいくつかあります。

00:13:38.000 --> 00:13:40.000
まず、それは明示的なゲッターを持っています。

00:13:40.000 --> 00:13:44.000
これは、プロパティを非同期にマークするために必要です。

00:13:44.000 --> 00:13:48.000
スウィフト5.5では、プロパティゲッターも投げることができます。

00:13:48.000 --> 00:13:58.000
また、非同期関数シグネチャと同様に、プロパティが非同期とスローの両方である場合、非同期キーワードはスローの直前になります。

00:13:58.000 --> 00:14:01.000
第二に、プロパティにはセッターがありません。

00:14:01.000 --> 00:14:05.000
読み取り専用プロパティのみを非同期にすることができます。

00:14:05.000 --> 00:14:13.000
関数、プロパティ、および初期化子では、関数がスレッドのブロックを解除する可能性のある場所を示すために式でawaitを使用できます。

00:14:13.000 --> 00:14:20.000
待っている場所も使用できる別の場所があります。forループで非同期シーケンスを反復します。

00:14:20.000 --> 00:14:26.000
非同期シーケンスは、要素を非同期に販売することを除いて、通常のシーケンスと同じです。

00:14:26.000 --> 00:14:33.000
したがって、次のアイテムを取得するには、非同期であることを示すawaitキーワードでマークする必要があります。

00:14:33.000 --> 00:14:50.000
関数が非同期シーケンスを何度も反復すると、次の要素を待っている間にスレッドのブロックを解除し、次の要素でループの本体に戻るか、要素が残っていない場合はループの後に再開することがあります。

00:14:50.000 --> 00:14:55.000
AsyncSequenceの詳細については、「Meet AsyncSequence」セッションをご覧ください。

00:14:55.000 --> 00:15:03.000
また、多くの非同期タスクを並行して実行することに興味がある場合は、「Swiftでの構造化された並行性」セッションをチェックしてください。

00:15:03.000 --> 00:15:06.000
だから、アウェイを使用できる場所がたくさんあります。

00:15:06.000 --> 00:15:11.000
キーワードは、非同期関数がそこで一時停止する可能性があることを示します。

00:15:11.000 --> 00:15:15.000
非同期関数が一時停止するとはどういう意味ですか?

00:15:15.000 --> 00:15:19.000
それに答えるために、関数を呼び出すと何が起こるかを考えてみましょう。

00:15:19.000 --> 00:15:27.000
任意の関数を呼び出すときは、関数が実行されているスレッドをその関数に制御します。

00:15:27.000 --> 00:15:39.000
ここのthumbnailURLRequestのように、呼び出している通常の関数の場合、スレッドは終了するまでその1つの関数に代わって作業して完全に占有されます。

00:15:39.000 --> 00:15:45.000
その作業は、関数自体の本体、またはそれが呼び出す他の関数にある可能性があります。

00:15:45.000 --> 00:15:51.000
最終的には、その関数は値を返すか、エラーをスローすることによって終了します。

00:15:51.000 --> 00:15:55.000
そうすると、それはあなたの機能にコントロールを戻します。

00:15:55.000 --> 00:16:00.000
これは、通常の関数がスレッドの制御を放棄できる唯一の方法です。

00:16:00.000 --> 00:16:04.000
そして、あなたの機能は、それが制御を与えることができる唯一のものです。

00:16:04.000 --> 00:16:09.000
あなたが呼び出している非同期関数であれば、状況は異なります。

00:16:09.000 --> 00:16:14.000
通常の関数のように、完了すると、終了し、コントロールを関数に戻します。

00:16:14.000 --> 00:16:22.000
しかし、通常の機能とは異なり、サスペンドすることで、まったく異なる方法でスレッドの制御を放棄することができます。

00:16:22.000 --> 00:16:28.000
通常の関数と同様に、非同期関数を呼び出すと、スレッドを制御できます。

00:16:28.000 --> 00:16:32.000
実行されると、非同期関数は一時停止できます。

00:16:32.000 --> 00:16:35.000
そうすると、スレッドの制御をあきらめます。

00:16:35.000 --> 00:16:41.000
しかし、あなたの機能に制御を返すのではなく、代わりにシステムにスレッドの制御を与えます。

00:16:41.000 --> 00:16:46.000
それが起こると、あなたの機能も中断されます。

00:16:46.000 --> 00:16:51.000
一時停止は、「あなたがやるべきことがたくさんあることを知っています」とシステムに伝える機能の方法です。

00:16:51.000 --> 00:16:55.000
何が最も重要なかを決めるのはあなたです。それはどれくらい協力的ですか?

00:16:55.000 --> 00:17:02.000
したがって、関数がそれ自体を一時停止すると、システムはスレッドを使用して他の作業を自由に行うことができます。

00:17:02.000 --> 00:17:11.000
ある時点で、システムは、最も重要な作業は、以前に中断していた非同期関数の実行を継続することであると判断します。

00:17:11.000 --> 00:17:14.000
その時点で、システムはそれを再開します。

00:17:14.000 --> 00:17:21.000
その非同期関数は、スレッドの制御に戻り、その作業を続けることができます。

00:17:21.000 --> 00:17:25.000
そして、それが望むなら、それは再び自分自身を中断することができます。

00:17:25.000 --> 00:17:29.000
実際、それは必要なだけ何度でも自分自身を中断することができます。

00:17:29.000 --> 00:17:33.000
一方、それはまったく自分自身を中断する必要はないかもしれません。

00:17:33.000 --> 00:17:41.000
非同期関数は一時停止するかもしれませんが、非同期とマークされているからといって、必ずしも一時停止するとは限りません。

00:17:41.000 --> 00:17:49.000
そして、同様に、「待機」が表示されたからといって、機能が間違いなくそこで中断されるわけではありません。

00:17:49.000 --> 00:18:02.000
しかし、最終的には、一時停止しなくても、または最後に再開した後でも、関数は終了し、値やエラーとともにスレッドの制御を関数に戻します。

00:18:02.000 --> 00:18:07.000
fetchThumbnailをもう一度見て、一時停止時に何が起こるかを見てみましょう。

00:18:07.000 --> 00:18:19.000
fetchThumbnailがURLSessionの非同期データメソッドを呼び出すと、データメソッドは、非同期関数のみが一時停止できる特別な方法でスレッドでの実行を停止します。

00:18:19.000 --> 00:18:26.000
スレッドをシステムに制御し、URLSessionのデータメソッドの作業をスケジュールするようにシステムに要求します。

00:18:26.000 --> 00:18:32.000
しかし、現時点では、システムは制御されており、その作業はすぐには開始されない可能性があります。

00:18:32.000 --> 00:18:35.000
スレッドは代わりに他のものに使用できます。

00:18:35.000 --> 00:18:38.000
それがどのように起こるか見てみましょう。

00:18:38.000 --> 00:18:44.000
fetchThumbnailが呼び出された後、ユーザーがいくつかのデータをアップロードするボタンをタップするとします。

00:18:44.000 --> 00:18:47.000
例えば、彼らが投稿に反応するとします。

00:18:47.000 --> 00:18:55.000
その後、システムは、以前にキューに入れられた作業の前に、ユーザーの反応を投稿する作業を自由に実行できます。

00:18:55.000 --> 00:19:01.000
その遅い作業が完了すると、URLSessionのデータメソッドが再開される可能性があります。

00:19:01.000 --> 00:19:04.000
または、システムは代わりに他の作業を実行するかもしれません。

00:19:04.000 --> 00:19:11.000
最後に、データメソッドが終了すると、fetchThumbnailに戻ります。

00:19:11.000 --> 00:19:19.000
関数が中断されている間に他の作業を実行できるという事実は、Swiftがawaitキーワードで非同期呼び出しをマークすることを主張する理由です。

00:19:19.000 --> 00:19:25.000
機能が一時停止すると、アプリの状態が劇的に変化する可能性があることを認識する必要があります。

00:19:25.000 --> 00:19:29.000
さて、これは完了ハンドラを使用する場合にも当てはまります。

00:19:29.000 --> 00:19:42.000
しかし、async/awaitコードに伴うすべての儀式とインデントがないため、awaitキーワードは、コードのブロックが1つのトランザクションとして実行されないことに気付く方法です。

00:19:42.000 --> 00:19:49.000
関数は一時停止する可能性があり、関数の行間で中断されている間に他のことが起こる可能性があります。

00:19:49.000 --> 00:19:54.000
それ以上に、この関数はまったく異なるスレッドに再開される可能性があります。

00:19:54.000 --> 00:20:00.000
これらの問題について学ぶには、「Swiftアクターで可変状態を保護する」セッションを参照してください。

00:20:00.000 --> 00:20:03.000
Async/awaitについて覚えておくべき重要なことがいくつかあります。

00:20:03.000 --> 00:20:08.000
まず、関数を非同期にマークすると、一時停止を許可します。

00:20:08.000 --> 00:20:12.000
そして、関数が自分自身を一時停止すると、その呼び出し者も一時停止します。

00:20:12.000 --> 00:20:15.000
したがって、その呼び出し者も非同期でなければなりません。

00:20:15.000 --> 00:20:24.000
第二に、非同期関数で1回または何度も一時停止する可能性がある場所を指摘するために、awaitキーワードが使用されます。

00:20:24.000 --> 00:20:28.000
第三に、非同期関数が中断されている間、スレッドはブロックされません。

00:20:28.000 --> 00:20:31.000
そのため、システムは自由に他の作業をスケジュールできます。

00:20:31.000 --> 00:20:35.000
後でキックオフされる作業でも、最初に実行できます。

00:20:35.000 --> 00:20:40.000
つまり、機能が中断されている間、アプリの状態は大いに変わる可能性があります。

00:20:40.000 --> 00:20:52.000
最後に、非同期関数が再開されると、それが呼んだ非同期関数から返された結果は元の関数に戻り、実行は中断したところから続きます。

00:20:52.000 --> 00:20:56.000
Swiftでasync/awaitがどのように機能するかを見てきました。

00:20:56.000 --> 00:21:00.000
今、ロバートはあなた自身のプロジェクトでそれを使い始める方法を紹介します。

00:21:00.000 --> 00:21:02.000
ありがとう、ネイト。

00:21:02.000 --> 00:21:05.000
以前、ネイトは私たちが一緒に構築しているアプリを見せてくれました。

00:21:05.000 --> 00:21:15.000
彼がasync/awaitを採用するように変換したサムネイル関数は、いくつかの場所で呼び出されたため、並行性を採用するためにそれらを移行する必要があります。

00:21:15.000 --> 00:21:20.000
現代のソフトウェア開発にとって重要なもの、つまりテストから始めましょう。

00:21:20.000 --> 00:21:29.000
非同期コードのテストが同期コードのテストと同じくらい簡単であることを望んでいたので、XCTestは箱から出して非同期をサポートしています。

00:21:29.000 --> 00:22:01.000
以前は、期待を設定し、テスト中のAPIを呼び出し、期待を満たし、任意の時間を待つという面倒なプロセスであったことは、テスト関数に非同期キーワードを追加し、XCTestの期待、そのフルフィルメント、および明示的な待機を削除し、代わりにネイトが以前に示した新しい非同期fetchThumbnail関数を呼び出す結果を待つのと同じくらい簡単になります。

00:22:01.000 --> 00:22:06.000
テストが解決したので、アプリケーションコード自体を拡大しましょう。

00:22:06.000 --> 00:22:13.000
特に、このリストの各行のサムネイルビューの背後にあるSwiftUIコード。

00:22:13.000 --> 00:22:22.000
画像セルは投稿で作成され、各投稿にはビューモデルに渡すIDがあり、サムネイルを非同期に取得できます。

00:22:22.000 --> 00:22:29.000
あなたはすでにテストコードからこの呼び出しを変換する方法を見たので、試してみましょう。

00:22:29.000 --> 00:22:40.000
まず、完了ハンドラを削除し、次にエラーを処理するために「try」が追加され、非同期関数の呼び出しを完了するために「await」が追加されます。

00:22:40.000 --> 00:22:44.000
しかし、このコードを構築しようとすると、何かがうまくいかない。

00:22:44.000 --> 00:22:52.000
Swiftコンパイラは、それ自体が非同期ではないコンテキストで非同期関数を呼び出すことはできないと言っています。

00:22:52.000 --> 00:23:05.000
ここでは、onAppear修飾子はプレーンで非非同期クロージャを取るため、同期世界と非同期世界の間のギャップを埋める方法が必要です。

00:23:05.000 --> 00:23:09.000
解決策は、非同期タスク関数を使用することです。

00:23:09.000 --> 00:23:20.000
非同期タスクは、クロージャ内の作業をパッケージ化し、グローバルディスパッチキューの非同期関数のように、次の利用可能なスレッドですぐに実行するためにシステムに送信します。

00:23:20.000 --> 00:23:27.000
ここでの主な利点は、同期コードを同期コンテキスト内から呼び出すことができることです。

00:23:27.000 --> 00:23:31.000
別の再構築の後、コンパイラは満足しています。

00:23:31.000 --> 00:23:41.000
非同期タスクは、使い慣れた自然に構造化されたスタイルで豊富な同時Swiftコードを構築できるAPIファミリーの一部です。

00:23:41.000 --> 00:23:59.000
詳細については、「Swiftで構造化された並行性を調べる」を参照してください。また、SwiftUIアプリで非同期コードを最大限に活用する方法については、「SwiftUIで並行性を発見する」を参照してください。fetchThumbnail関数と呼んでいたすべての場所の移行が完了しました。

00:23:59.000 --> 00:24:03.000
しかし、私たちのアプリには、async/awaitを採用する機会がたくさんあります。

00:24:03.000 --> 00:24:11.000
迅速に起動して実行するには、既存のAPIに代わる非同期の代替手段で小さく始めることをお勧めします。

00:24:11.000 --> 00:24:20.000
SDKは、非同期の方法であなたに代わって動作するため、完了ハンドラを取る何百ものAPIを提供します。

00:24:20.000 --> 00:24:27.000
これらのAPIが並んで並ぶと、パターンが現れ始めます。

00:24:27.000 --> 00:24:35.000
名前や目的が異なる場合がありますが、これらの機能はすべて同じ必須API契約を持っています。

00:24:35.000 --> 00:24:42.000
あなたは彼らに電話し、彼らは提供された完了ハンドラーであなたに電話をかけ直し、彼らが得た結果を渡します。

00:24:42.000 --> 00:24:49.000
以前、ネイトは、より自然に見えるコードを書くために非同期関数の結果を待つことができることを示しました。

00:24:49.000 --> 00:24:57.000
これらのコールバックブロックをこれらの非同期関数に変えることができれば、それは素晴らしいことではないでしょうか?

00:24:57.000 --> 00:25:02.000
Swift 5.5の時点で、これはまさに起こることです。

00:25:02.000 --> 00:25:10.000
Swiftコンパイラは、Objective-Cからインポートされた完了ハンドラコードを自動的に調べ、非同期の代替手段を提供します。

00:25:10.000 --> 00:25:12.000
しかし、私たちはそこで止まりませんでした。

00:25:12.000 --> 00:25:18.000
多くのデリゲートAPIには、完了ハンドラを渡すメソッドも含まれています。

00:25:18.000 --> 00:25:24.000
ハンドラーを呼び出すと、非同期タスクが完了したときにフレームワークに協力して通知します。

00:25:24.000 --> 00:25:32.000
fetchThumbnailを呼び出して、特定の投稿のタイムラインエントリを表示するこのClockKitコンプリケーションデータソースを取ります。

00:25:32.000 --> 00:25:41.000
以前と同様に、すべてのパスで完了ハンドラーを呼び出す必要があります。また、閉鎖のため、ここには余分なノイズがたくさんあります。

00:25:41.000 --> 00:25:45.000
Async awaitでは、これはもはやそうである必要はありません。

00:25:45.000 --> 00:25:50.000
このデリゲートメソッドには、代わりに使用できる非同期の代替手段があります。

00:25:50.000 --> 00:26:05.000
まず、先頭の「get」をドロップする非同期代替の名前が使用されます。非同期関数は、呼び出しの結果が直接返されないときに通信する「get」のような先頭の単語を省略することをお勧めします。

00:26:05.000 --> 00:26:13.000
結局のところ、これは非同期の代替関数であるため、タイムラインエントリを直接返します。

00:26:13.000 --> 00:26:19.000
非同期コンテキストが設定されたので、fetchThumbnailの非同期バージョンを呼び出します。

00:26:19.000 --> 00:26:27.000
最後に、現在削除された完了ブロックを呼び出すのではなく、このメソッドからタイムラインエントリを返します。

00:26:27.000 --> 00:26:32.000
ここで強調した非同期APIは、表面をかろうじて傷つけます。

00:26:32.000 --> 00:26:43.000
詳細については、API自体と、async/awaitを採用する際の使用方法について詳しく説明するこれらのセッションを参照してください。

00:26:43.000 --> 00:26:49.000
これらはすべて、Swiftがあなたに代わって非同期の代替案を作成する状況の例です。

00:26:49.000 --> 00:26:56.000
しかし、必然的にコードには、自分で非同期の代替案を作成する必要がある場所があります。

00:26:56.000 --> 00:26:59.000
これが実際にどのように見えるか見てみましょう。

00:26:59.000 --> 00:27:07.000
私たちのアプリでは、このgetPersistentPosts機能を使用して、コアデータストアに保持した投稿を取得します。

00:27:07.000 --> 00:27:18.000
この関数は、非同期サムネイル関数よりも多くの場所でアプリ内で呼び出されるため、どこでも非同期を使用するのは本当に大きな変化になります。

00:27:18.000 --> 00:27:26.000
そして、NSAsynchronousFetchRequestを使用しているので、この関数は非同期の代替案の完璧な候補のようです。

00:27:26.000 --> 00:27:31.000
まず、非同期関数を作成し、戻り値を変換します。

00:27:31.000 --> 00:27:37.000
この関数はエラーが発生する可能性があるため、この関数も「スロー」とマークします。

00:27:37.000 --> 00:27:46.000
次に、getPersistentPostsの完了ハンドラーバージョンを呼び出し、今、私たちは立ち往生しています。

00:27:46.000 --> 00:27:53.000
コールバックの結果を、async persistentPosts関数の呼び出しを待っている場所に返す必要があります。

00:27:53.000 --> 00:27:57.000
それだけでなく、これらの発信者は中断状態にあります。

00:27:57.000 --> 00:28:05.000
彼らが残りの仕事に取り掛かることができるように、適切なタイミングで適切なデータでそれらを再開する必要があります。

00:28:05.000 --> 00:28:12.000
以前、ネイトは、スウィフトとシステムが私たちのために非同期コードを再開するためにどのように協力するかを示しました。

00:28:12.000 --> 00:28:22.000
この一時停止/再開プロセスがどのように機能するかをもう少し深く掘り下げて、問題に対して同様の解決策を考え出すことができるかどうかを確認します。

00:28:22.000 --> 00:28:27.000
persistentPostsの非同期バージョンが呼び出されると、Core Dataが呼び出されます。

00:28:27.000 --> 00:28:34.000
後で、Core Dataは完了ハンドラを呼び出し、フェッチ要求の結果を渡します。

00:28:34.000 --> 00:28:46.000
この状況は、fetchThumbnail関数がCore Dataではなくシステムに一時停止された非同期関数呼び出しを再開するように要求したときに、Nateが以前に示したものとほぼ同じように見えます。

00:28:46.000 --> 00:28:53.000
欠けているのは、完了ハンドラを待ち、フェッチ要求の結果を再開するためのブリッジだけです。

00:28:53.000 --> 00:28:59.000
このパターンは常に登場し、名前があります：続き。

00:28:59.000 --> 00:29:07.000
このセッションを通して、ネイトと私はすでに継続の例をたくさん見せました：完了ブロックを取る方法。

00:29:07.000 --> 00:29:15.000
メソッドの呼び出し者は、関数呼び出しの結果を待ち、次に何をすべきかを指定するクロージャを提供します。

00:29:15.000 --> 00:29:23.000
関数呼び出しが完了すると、完了ハンドラを呼び出して、呼び出し元が結果でやりたいことを再開します。

00:29:23.000 --> 00:29:29.000
この種の協調的な実行は、まさにSwiftの非同期関数の仕組みです。

00:29:29.000 --> 00:29:40.000
これを明示するために、Swiftは、高レベルで安全な方法で継続を作成、管理、再開できる機能を提供します。

00:29:40.000 --> 00:29:47.000
例に戻って、継続が非同期の代替案の作成を完了するのにどのように役立つかを見てみましょう。

00:29:47.000 --> 00:29:56.000
withCheckedThrowingContinuation関数は、非同期Swift関数をスローするエラーで完了ブロックを持ち上げます。

00:29:56.000 --> 00:30:04.000
関数が決してエラーをスローしないことを知っている状況に対して、withCheckedContinuationsと呼ばれるカウンターパートがあります。

00:30:04.000 --> 00:30:12.000
これらの関数は、中断された非同期関数を再開するために使用できる継続値にアクセスする方法です。

00:30:12.000 --> 00:30:19.000
これはまた、私たちがPersistentPostsを取得するための呼び出しを待つことを可能にすることによって、ブリッジの最初の部分を構築します。

00:30:19.000 --> 00:30:22.000
橋の建設を終わらせましょう。

00:30:22.000 --> 00:30:29.000
継続値は、完了ハンドラの結果を配置する再開機能を提供します。

00:30:29.000 --> 00:30:38.000
それだけでなく、resumeは、persistentPosts関数の結果を待っている呼び出しの一時停止を解除するために必要な不足しているリンクを提供します。

00:30:38.000 --> 00:30:46.000
そして、1つのきちんとしたパッケージには、完了ハンドラから非同期関数への完成したブリッジがあります。

00:30:46.000 --> 00:30:56.000
継続は、非同期関数の実行を手動で制御する強力な方法を提供しますが、心に留めておくべきことがいくつかあります。

00:30:56.000 --> 00:31:00.000
継続にはシンプルだが重要な契約がある。

00:31:00.000 --> 00:31:04.000
履歴書は、すべてのパスで正確に1回呼び出す必要があります。

00:31:04.000 --> 00:31:08.000
でも、心配しないでください。スウィフトはここであなたの背中を持っています。

00:31:08.000 --> 00:31:18.000
再開が呼び出されずに継続が破棄された場合、非同期呼び出しが一時停止されることはないため、Swiftランタイムは警告を記録します。

00:31:18.000 --> 00:31:27.000
ただし、継続が同じ機能で複数回再開された場合、プログラムデータが破損する可能性があるため、これはより深刻なエラーです。

00:31:27.000 --> 00:31:37.000
これに対処するために、Swiftランタイムは再開を複数回呼び出す試みを検出し、2番目の再開ポイントで致命的なエラーが発生するようにします。

00:31:37.000 --> 00:31:44.000
これを念頭に置いて、チェックされた継続を使用する可能性のあるもう1つの重要な場所を強調しましょう。

00:31:44.000 --> 00:31:47.000
多くのAPIはイベント駆動型です。

00:31:47.000 --> 00:31:55.000
彼らは、特定の重要なポイントでアプリケーションに通知し、適切に応答できるようにするために、デリゲートコールバックを提供します。

00:31:55.000 --> 00:32:02.000
Async/awaitを適切に採用するには、継続を保存し、後で再開する必要があります。

00:32:02.000 --> 00:32:07.000
以前と同様に、チェックされた継続を作成します。

00:32:07.000 --> 00:32:12.000
その後、それを保存し、作業を開始します。

00:32:12.000 --> 00:32:25.000
チェックされた継続のAPI契約を尊重するために、アクティブな継続を再開し、最終的にそれをゼロにして、複数回呼び出すことから保護されるようにします。

00:32:25.000 --> 00:32:37.000
常に覚えておいてください：ここでチェックされた継続値は、このAPIへの非同期呼び出しを手動で再開する機能を表すため、すべてのパスで呼び出す必要があります。

00:32:37.000 --> 00:32:49.000
デリゲートAPIが何度も呼び出された場合、または特定の状況でまったく呼び出されない場合は、アクティブな継続を1回だけ再開することが重要です。

00:32:49.000 --> 00:32:58.000
継続を含むSwift並行性の下位レベルの詳細の詳細については、「Swift並行性：舞台裏」セッションを参照してください。

00:32:58.000 --> 00:33:03.000
これは、Swiftのasync/awaitの旋風ツアーでした。

00:33:03.000 --> 00:33:11.000
実行時に非同期と待機キーワードがどのように機能し、アプリケーションやフレームワークに採用する方法を示しました。

00:33:11.000 --> 00:33:23.000
始めるために、SDKで利用可能な非同期APIのサンプルを提供し、既存のコードを同期世界から非同期世界に橋渡しする方法を紹介しました。

00:33:23.000 --> 00:33:28.000
Async/awaitは、Swiftの並行性機能の全宇宙の基盤です。

00:33:28.000 --> 00:33:31.000
私たちは、あなたが彼らと一緒に構築するものを見ることに興奮しています。

00:33:31.000 --> 23:59:59.000
ご覧いただきありがとうございます。

