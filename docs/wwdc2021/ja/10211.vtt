WEBVTT

00:00:00.000 --> 00:00:05.000
♪ベース音楽の演奏♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:10.000
アレハンドロ・ルセナ:皆さん、こんにちは。

00:00:10.000 --> 00:00:13.000
象徴化に関するこのセッションにご参加いただきありがとうございます。

00:00:13.000 --> 00:00:22.000
シンボリック化は曖昧な用語のように思えるかもしれませんが、バグ、クラッシュ、パフォーマンスのボトルネックの根本原因を迅速に特定するのに役立つ重要な役割がわかります。

00:00:22.000 --> 00:00:30.000
私たちは、シンボリックがどのように機能するかについてより深い直感を得て、あなたが直接従うためにあなたが自由に使えるいくつかのツールをカバーします。

00:00:30.000 --> 00:00:43.000
その過程で、豊富なシンボリック化体験に必要なデバッグ情報のさまざまなソースと、この情報を最大限に活用するようにアプリを設定する方法について説明します。

00:00:43.000 --> 00:00:49.000
象徴的な具体的な定義と例に慣れることから始めましょう。

00:00:49.000 --> 00:01:03.000
基本的に、シンボリック化は、デバイスが実行時にアプリをどのように見ているかを変換または翻訳するメカニズムです。これは、メモリアドレスと命令の観点から、開発者としての私たちがアプリをどのように見ているかに戻ります。これは、機能、名前、ファイルの観点からです。

00:01:03.000 --> 00:01:11.000
このブリッジングレイヤーがなければ、数行のコードでもバグの診断が非常に複雑になります。

00:01:11.000 --> 00:01:13.000
例として、このSwiftコードを考えてみましょう。

00:01:13.000 --> 00:01:20.000
ここには、候補番号のリストから特定の番号を選択する関数 `generateMagicNumber()` があります。

00:01:20.000 --> 00:01:27.000
これを行うには、まずランダムに生成された10個の数値の配列を返す`numberChoices()`を呼び出します。

00:01:27.000 --> 00:01:33.000
次に、その配列を「selectMagicNumber(choices:)」に渡し、特定のインデックスで数値を返します。

00:01:33.000 --> 00:01:37.000
これは合理的なプログラムのように思えますが、最初に実行したときにクラッシュに遭遇します。

00:01:37.000 --> 00:01:42.000
私の最初の手段は、クラッシュログをチェックすることですが、これはかなり実りのないものです。

00:01:42.000 --> 00:01:47.000
スレッドのバックトレースからわかるのは、私のMagicNumbersアプリがどこかでクラッシュしたということだけです。

00:01:47.000 --> 00:01:49.000
ありがとう、でも私はすでにそれを知っていました。

00:01:49.000 --> 00:01:54.000
レジスタが何を指しているのか、私にはわかりません。

00:01:54.000 --> 00:02:02.000
デバッガでアプリをステップスルーしてクラッシュを特定しようとすることができますが、これが再現できない特定の状況でのみ発生する場合はどうなりますか?

00:02:02.000 --> 00:02:07.000
その場合、デバッガを使用すると、必ずしも問題を特定するとは限りません。

00:02:07.000 --> 00:02:13.000
または、分解を見てみることもできますが、物事を追跡することははるかに困難です。

00:02:13.000 --> 00:02:22.000
これは明らかに問題を診断するための実行可能な方法ではなく、さらに重要なことに、シンボリック化の助けを借りて、この出発点からデバッグする必要はありません。

00:02:22.000 --> 00:02:28.000
Xcodeオーガナイザーは、クラッシュログを再処理するこのアプリのdSYMをダウンロードできると教えてくれます。

00:02:28.000 --> 00:02:44.000
そうすることで、Xcodeはシンボリック化の概念を適用して、はるかに素晴らしいクラッシュログで問題を診断できます。そこでは、すべての関数が実際に呼び出されているのを見ることができるだけでなく、コードで参照するファイルと行番号を決定することもできます。

00:02:44.000 --> 00:02:49.000
この更新されたクラッシュログは、範囲外のインデックスにアクセスしようとしたことも教えてくれます。

00:02:49.000 --> 00:02:56.000
あるいは、すでにdSYMを持っている場合は、「atos」コマンドを使用して同じ情報を取得できます。

00:02:56.000 --> 00:03:03.000
私のコードを振り返ってみると、「MAGIC_CHOICE」は10要素配列の境界をはるかに超えていることに気づきました。

00:03:03.000 --> 00:03:04.000
おっと。

00:03:04.000 --> 00:03:10.000
別の例では、最速のユーザーエクスペリエンスを提供するためにアプリをプロファイリングすることに興味があります。

00:03:10.000 --> 00:03:16.000
ここでは、インスツルメンツは、アプリが高利用率と低利用率の期間を循環することを示しています。

00:03:16.000 --> 00:03:22.000
使用率の低い期間に焦点を当てると、Instrumentsはアプリがファイルにいくつかのコンテンツを書き込んでいたことを教えてくれます。

00:03:22.000 --> 00:03:28.000
しかし、高い利用率の期間を検査すると、同じ正確なバックトレースが得られる。

00:03:28.000 --> 00:03:29.000
これはどのように可能ですか?

00:03:29.000 --> 00:03:32.000
これはまったく同じコードを実行していませんか?

00:03:32.000 --> 00:03:36.000
ご覧のとおり、このインストゥルメントのトレースは部分的にしか象徴化されていません。

00:03:36.000 --> 00:03:42.000
たとえば、更新されたクラッシュログで行ったように、バックトレースにファイル名や行番号が表示されません。

00:03:42.000 --> 00:03:45.000
その結果、いくつかの情報が欠落しています。

00:03:45.000 --> 00:03:49.000
それを念頭に置いて、私は同様に楽器で私のdSYMを見つけることができます。

00:03:49.000 --> 00:04:00.000
これを行う後、私の新しいInstrumentsトレースは、高利用率領域が実際にファイルに書き込んでいたことを示していますが、それらは特に私がプログラムに残したデバッグコードパス内でした。

00:04:00.000 --> 00:04:05.000
利用率の低い領域はこれを避け、私のアプリが本番でどのように振る舞うかを表しています。

00:04:05.000 --> 00:04:19.000
XcodeがdSYMを利用してかなり情報のないクラッシュログを象徴化したように、InstrumentsもdSYMを使用して部分的に象徴化されたトレースを充実させ、パフォーマンスの問題の正確な原因を教えてくれました。

00:04:19.000 --> 00:04:26.000
さて、これらのツールがシンボリックを利用して私のコードの問題領域を特定するのは素晴らしいことですが、自然にいくつかの疑問を投げかけます。

00:04:26.000 --> 00:04:28.000
これはすべてどのように機能しますか?

00:04:28.000 --> 00:04:29.000
他にどこでこれを適用できますか?

00:04:29.000 --> 00:04:32.000
そして、これはすべてdSYMについてですか?

00:04:32.000 --> 00:04:38.000
これらの質問に答え、シンボリックの機能のロックを解除するには、詳細を深く掘り下げる必要があります。

00:04:38.000 --> 00:04:43.000
これは少し圧倒的に思えるかもしれませんが、これらは理解すべき重要な概念です。

00:04:43.000 --> 00:04:48.000
シンボリックに基づいて構築されたデバッグとプロファイリングを支援する多くのツールがあります。

00:04:48.000 --> 00:04:54.000
「atos」だけで、すでにクラッシュの正確な根本原因が示されており、Xcodeにはさらに多くのツールが組み込まれています。

00:04:54.000 --> 00:05:00.000
さらに、`o`、`l`、`i`のようなフラグを`atos`に指定しましたが、それらはどういう意味ですか?

00:05:00.000 --> 00:05:02.000
私たちはいつも同じ旗のセットを使いますか?

00:05:02.000 --> 00:05:05.000
利用可能な値の1つがない場合はどうなりますか?

00:05:05.000 --> 00:05:15.000
また、インスツルメンツのケースで見たように、バックトレースが完全に象徴化されていない可能性がある時期と理由、およびそれを修正する方法を理解する上で、良い基盤を得ることができます。

00:05:15.000 --> 00:05:21.000
最後に、シンボリックの豊かさに影響を与える、あなたがコントロールできる多くのビルド設定があります。

00:05:21.000 --> 00:05:26.000
これらのビルド設定を調べて、それらがどのように利用されているかについて確かな直感を持つようにします。

00:05:26.000 --> 00:05:30.000
そのために、象徴化のための2段階のプロセスを紹介したいと思います。

00:05:30.000 --> 00:05:36.000
ステップ1はファイルに戻り、ステップ2はデバッグ情報を参照することです。

00:05:36.000 --> 00:05:44.000
ご覧のとおり、ファイルに戻ることは、ランタイムメモリアドレスをより安定した使用可能な形式に変換または変換することです。

00:05:44.000 --> 00:05:52.000
これにより、デバッグ情報と通信して、生のメモリアドレスとソースコードの間に有意義な接続を行うことができます。

00:05:52.000 --> 00:05:57.000
まず、ステップ1について話し合い、ファイルに戻りましょう。

00:05:57.000 --> 00:06:07.000
このステップの究極の目標は、元のクラッシュログで見たようなランタイムメモリアドレスを、ディスク上のバイナリの対応するアドレスに変換することです。

00:06:07.000 --> 00:06:13.000
ランタイムアドレスがあるように、アプリやフレームワークにもディスクにアドレス空間があります!

00:06:13.000 --> 00:06:23.000
ディスク上のアドレス空間は、アプリが実行時に占有するアドレス空間とは異なり、それらの違いを把握するためのメカニズムが必要です。

00:06:23.000 --> 00:06:27.000
まず、ディスク上のアドレスが何であるかを正確に理解する必要があります。

00:06:27.000 --> 00:06:31.000
これらのアドレスは、アプリをビルドするときにリンカーによって割り当てられます。

00:06:31.000 --> 00:06:34.000
具体的には、リンカーはバイナリをセグメントにグループ化します。

00:06:34.000 --> 00:06:41.000
各セグメントには関連データが含まれており、名前、サイズ、割り当てられたアドレスなどのプロパティがあります。

00:06:41.000 --> 00:06:52.000
たとえば、バイナリの `__TEXT` セグメントには、作成したすべての関数とメソッドが含まれており、`__DATA` セグメントには、グローバル変数などのプログラム全体の状態が含まれています。

00:06:52.000 --> 00:06:57.000
これらのセグメントのそれぞれには、重複しないように異なるアドレスが割り当てられます。

00:06:57.000 --> 00:07:03.000
リンカは、Mach-Oヘッダーの一部として、実行可能ファイルの冒頭にこの情報を記録します。

00:07:03.000 --> 00:07:10.000
Mach-Oは、すべての実行可能なバイナリとライブラリに使用される形式であり、システムはアプリを実行するためにこのヘッダーを読み取る必要があることを知っています。

00:07:10.000 --> 00:07:17.000
もう少しよく見ると、Mach-Oヘッダーには、セグメントプロパティを保持する多くのロードコマンドが含まれています。

00:07:17.000 --> 00:07:21.000
システムは、これらのロードコマンドを使用してセグメントをメモリにロードします。

00:07:21.000 --> 00:07:28.000
アプリがユニバーサル2の場合、アプリには各アーキテクチャに1つのヘッダーとセグメントのセットがあることに注意してください。

00:07:28.000 --> 00:07:35.000
指定されたファイルのロードコマンドを出力する`otool -l`コマンドを使用することで、自分で見ることができます。

00:07:35.000 --> 00:07:41.000
ここでは、「LC_SEGMENT_64」で識別されるセグメントロードコマンドを探しています。

00:07:41.000 --> 00:07:48.000
このロードコマンドは、`__TEXT`セグメントが`vmaddr`のアドレスから始まり、`vmsize`バイトの長さであると言います。

00:07:48.000 --> 00:07:57.000
したがって、カーネルがこれらのロードコマンドに従ってセグメントをメモリにロードする場合、ランタイムとリンカーアドレスの違いは何ですか?

00:07:57.000 --> 00:08:04.000
さて、カーネルが実際にセグメントをロードする前に、ASLRスライドと呼ばれるランダムな値を初期化します。

00:08:04.000 --> 00:08:09.000
その後、カーネルはロードコマンドのアドレスにASLRスライドを追加します。

00:08:09.000 --> 00:08:21.000
したがって、アドレスAで`__TEXT`セグメントをロードし、アドレスBで`__DATA`セグメントをロードするのではなく、カーネルは代わりにそれらをA+SとB+Sにロードします。SはASLRスライドです。

00:08:21.000 --> 00:08:28.000
A+SとB+Sはシステムが使用する真のアドレスであるため、ロードアドレスとも呼ばれます。

00:08:28.000 --> 00:08:36.000
それを念頭に置いて、ランタイムアドレスとリンカーアドレスの違いはASLRスライドであることを知っています。

00:08:36.000 --> 00:08:48.000
次の式でASLRスライドを計算できます。S = L-A、SはASLRスライド、Lはロードアドレス、Aはリンカアドレスです。

00:08:48.000 --> 00:08:57.000
この方程式の例をまもなく見ますが、重要なポイントは、ASLRスライドを知ったら、いつでもファイルアドレス空間に戻ることができるということです。

00:08:57.000 --> 00:09:04.000
ASLRスライド方程式には、ロードアドレスとリンカーアドレスの2つのアドレスが必要だったので、どこから入手できますか?

00:09:04.000 --> 00:09:11.000
「Otool」を使用してリンカーアドレスを知るためにロードコマンドを照会する方法をすでに見ました。

00:09:11.000 --> 00:09:21.000
ランタイムアドレスを知るために、システムはクラッシュの時点で、またはインスツルメンツによってプロファイリングされているランタイムアドレス空間についてアプリを照会します。

00:09:21.000 --> 00:09:27.000
この情報は、クラッシュログのバイナリ画像リストに反映されます。

00:09:27.000 --> 00:09:35.000
また、プログラム内のアクティブなメモリ領域を列挙する「vmmap」ツールを使用して、ロードアドレスをインタラクティブに表示することもできます。

00:09:35.000 --> 00:09:40.000
元のクラッシュログからASLRスライド値を計算しましょう。

00:09:40.000 --> 00:09:44.000
バイナリ画像リストには、`__TEXT`セグメントのロードアドレスがあります。

00:09:44.000 --> 00:09:49.000
ロードコマンドを見たとき、ディスク上のバイナリのリンカーアドレスも持っています。

00:09:49.000 --> 00:09:54.000
これら2つを差し引くと、ASLRスライド値は0x45c000になります。

00:09:54.000 --> 00:10:04.000
これは、私のプログラムのランタイム`__TEXT`セグメント内のすべてのアドレスが、リンカ`__TEXT`セグメントアドレスから0x45c000バイト離れていることを意味します。

00:10:04.000 --> 00:10:15.000
したがって、クラッシュログのバックトレースアドレスがファイルで何に対応するかを確認するには、そこから0x45c000を引いてディスク上のアドレスを取得できます。

00:10:15.000 --> 00:10:21.000
このアドレスは現在、ディスク上のアドレス空間の一部であるため、アプリを調べて、そこに何があるかを確認できます。

00:10:21.000 --> 00:10:31.000
クラッシュログは、このアドレスにあるものを実行中にスレッドがクラッシュしたことを教えてくれるので、再び「otool」を使用して問題のある命令を見ることができます。

00:10:31.000 --> 00:10:37.000
今回は、分解を印刷する「otool」に「-tV」フラグを指定しました。

00:10:37.000 --> 00:10:41.000
アーキテクチャもarm64として指定していることに注意してください。

00:10:41.000 --> 00:10:48.000
これは、アプリがユニバーサル2として構築されているため、otoolがどのMach-Oヘッダーとセグメントを考慮するかを知るためです。

00:10:48.000 --> 00:10:52.000
`otool`の出力は、アドレスで`brk`命令を明らかにする。

00:10:52.000 --> 00:10:56.000
「Brk」は、アプリの例外または問題を示します。

00:10:56.000 --> 00:11:03.000
「atos」などのツールも、一緒に経験したのと同じテクニックを使用してASLRスライドを計算します。

00:11:03.000 --> 00:11:11.000
`atos`は、`-o`フラグで示されたファイルのロードコマンドを読み取り、`-l`フラグでロードアドレスについて伝えます。

00:11:11.000 --> 00:11:16.000
前述したように、「vmmap」は、実行中のアプリのロードアドレスについても教えてくれます。

00:11:16.000 --> 00:11:24.000
この計算をもう一度試してみましょうが、今回はバイナリ画像リストの代わりに「vmmap」を使用してASLRスライドを決定します。

00:11:24.000 --> 00:11:31.000
MagicNumbersプログラムを再度実行し、プログラムがクラッシュする前に`__TEXT`セグメントロードアドレスを得ました。

00:11:31.000 --> 00:11:38.000
以前の式を使用して、今回はASLRのスライド値が0x104d14000だったと判断できます。

00:11:38.000 --> 00:11:43.000
繰り返しますが、ファイルに戻るには、ASLRスライドの値を差し引く必要があります。

00:11:43.000 --> 00:11:52.000
新しいクラッシュログの一番上のエントリから0x104d14000を引くと、以前と同じ正確なファイルアドレスが表示されます。

00:11:52.000 --> 00:12:00.000
そして、これは偶然ではありません。カーネルはちょうど別のASLR値を選んだので、クラッシュログ間でロードアドレスが変更されました。

00:12:00.000 --> 00:12:06.000
ただし、クラッシュの原因となったファイルアドレスは引き続き特定できます。

00:12:06.000 --> 00:12:16.000
ここでの重要なポイントは、ランタイムアドレスに関係なく、アプリが命令レベルまで何をしていたかを正確に理解するメカニズムがあるということです。

00:12:16.000 --> 00:12:24.000
そして、そのマッピングにより、これらの命令にコンパイルされたソースコードのデバッグ情報を参照することができます。

00:12:24.000 --> 00:12:30.000
先に進む前に、私たちがカバーした内容と使用したツールの概要を紹介したいと思います。

00:12:30.000 --> 00:12:33.000
アプリバイナリとフレームワークはMach-Oファイルです。

00:12:33.000 --> 00:12:37.000
これは、異なるセグメントに関連コンテンツがあることを意味します。

00:12:37.000 --> 00:12:40.000
これらのセグメントはリンカーによって作成されます。

00:12:40.000 --> 00:12:45.000
Mach-Oヘッダーロードコマンドは、アドレスを含むこれらのセグメントのプロパティを記述します。

00:12:45.000 --> 00:12:50.000
`otool`と`-l`フラグを使用して、ロードコマンドを印刷しました。

00:12:50.000 --> 00:12:57.000
次に、カーネルがリンカーアドレスにASLRスライドと呼ばれるランダムな値を追加することを学びました。

00:12:57.000 --> 00:13:02.000
ASLRスライドとリンカーアドレスの追加は、ロードアドレスとして知られています。

00:13:02.000 --> 00:13:12.000
クラッシュログのバイナリイメージリストをチェックして、クラッシュが発生した場合のロードアドレスを確認することも、「vmmap」を使用して実行中のアプリのロードアドレスを確認することもできます。

00:13:12.000 --> 00:13:19.000
最後に、ファイルアドレス空間に戻るためにASLRスライドを計算するいくつかの例を見てきました。

00:13:19.000 --> 00:13:26.000
これで、ファイルアドレスとソースコードの間の重要なリンクを含むデバッグ情報について話し合うことができます。

00:13:26.000 --> 00:13:35.000
Xcodeは、アプリを構築するときにデバッグ情報を作成し、アプリバイナリに直接埋め込むか、dSYMなどの別のファイルとして保存します。

00:13:35.000 --> 00:13:39.000
デバッグ情報にはいくつかのカテゴリまたは種類があります。

00:13:39.000 --> 00:13:43.000
それぞれが、特定のファイルアドレスに対して異なるレベルの詳細を提供します。

00:13:43.000 --> 00:13:47.000
今日は3種類のデバッグ情報を見ていきます。

00:13:47.000 --> 00:13:54.000
まず、関数の開始について説明します。それ自体はあまり価値を付加しませんが、一般的な出発点です。

00:13:54.000 --> 00:13:58.000
次に、関数名とメソッド名を追加するnlistシンボルテーブルが表示されます。

00:13:58.000 --> 00:14:03.000
最後に、dSYMと静的ライブラリに由来するDWARFを見ていきます。

00:14:03.000 --> 00:14:09.000
DWARFは、ファイル名、行番号、最適化レコードなど、最も詳細を追加します。

00:14:09.000 --> 00:14:16.000
DWARFは最も詳細を提供するので、可能な限りこの種のデバッグ情報を持つように努力したいと考えています。

00:14:16.000 --> 00:14:21.000
これらのそれぞれと、それらを使用して完全にシンボリック化されたクラッシュログを構築する方法について学びます。

00:14:21.000 --> 00:14:24.000
関数の開始から始めましょう。

00:14:24.000 --> 00:14:29.000
表で見たように、function startsは最小限のソースコードの詳細を提供します。

00:14:29.000 --> 00:14:38.000
また、その名前に忠実に、このタイプのデバッグ情報は、関数の最初のアドレス（または文字通りの開始）についてのみ教えてくれます。

00:14:38.000 --> 00:14:44.000
たとえば、これは、関数が特定のアドレスで始まり、存在することを教えてくれます。

00:14:44.000 --> 00:14:51.000
ただし、どの関数がそれらのアドレスで始まるかは教えてくれず、それらが存在することだけです。

00:14:51.000 --> 00:14:57.000
デバッグ情報を開始する関数は、アプリの`__LINKEDIT`セグメントのアドレスのリストをエンコードすることによってこれを行います。

00:14:57.000 --> 00:15:07.000
これはアプリに直接埋め込まれているため、Mach-Oヘッダーには「LC_FUNCTION_STARTS」という場所を知らせるloadコマンドもあります。

00:15:07.000 --> 00:15:13.000
`symbols`コマンドと`-onlyFuncStartsData`フラグで、これらを自分で見ることができます。

00:15:13.000 --> 00:15:17.000
ここでは、アドレスとヌルプレースホルダのリストを取得します。

00:15:17.000 --> 00:15:24.000
これらのプレースホルダは、ヌルではなく関数名とメソッド名を持つことが理想的ですが、関数の開始データは名前を提供しません。

00:15:24.000 --> 00:15:28.000
繰り返しますが、これは最も説明的なデータではありません。

00:15:28.000 --> 00:15:32.000
ただし、クラッシュログのわずかな更新が可能です。

00:15:32.000 --> 00:15:35.000
ファイルアドレスを関数からのオフセットとして表示できるようになりました。

00:15:35.000 --> 00:15:43.000
たとえば、まずASLRスライドの値を引いてファイルに戻ります。

00:15:43.000 --> 00:15:48.000
次に、ファイルアドレスを含む可能性のある関数開始値を見つけます。

00:15:48.000 --> 00:15:56.000
この場合、他のすべての値がアドレスよりも大きいため、最初の値のみがアドレスを含めることができます。

00:15:56.000 --> 00:16:04.000
最後に、この関数では、ファイルアドレスが実際には264バイトであると主張することができます。

00:16:04.000 --> 00:16:11.000
これは、この関数がどのように設定され、どのレジスタが変更されたかの詳細を理解できるため、デバッガにとって主に便利です。

00:16:11.000 --> 00:16:21.000
しかし、これがあなたにとって意味することは、関数名のないクラッシュログに遭遇した場合、おそらくこの最低レベルのデバッグ情報を扱っているということです。

00:16:21.000 --> 00:16:29.000
これは、より良いデバッグ情報でクラッシュログを充実させる機会がたくさんあることを意味するので、良いニュースです。

00:16:29.000 --> 00:16:34.000
当然のことながら、私たちが見たい次のレベルの詳細は関数名です。

00:16:34.000 --> 00:16:43.000
これにより、クラッシュログまたはインストゥルメントトレースを取得し、それを使用してソースコードの問題を追跡する最初の本当の機会が得られます。

00:16:43.000 --> 00:16:46.000
これは、nlistシンボルテーブルにつながります。

00:16:46.000 --> 00:16:55.000
シンボルテーブルは、関数開始のアイデアに基づいて構築され、「__LINKEDIT」セグメントの情報のリストをエンコードし、独自のロードコマンドもあります。

00:16:55.000 --> 00:17:00.000
ただし、単にアドレスをエンコードするのではなく、C構造をエンコードします。

00:17:00.000 --> 00:17:06.000
これにより、関数の開始と比較して、特定のエントリの詳細を追加できます。

00:17:06.000 --> 00:17:10.000
具体的には、`nlist_64`構造体をエンコードします。

00:17:10.000 --> 00:17:13.000
ここにその構造体の定義があります。

00:17:13.000 --> 00:17:18.000
ざっと見ると、名前といくつかのプロパティにアクセスできることがわかります。

00:17:18.000 --> 00:17:24.000
これらの構造体フィールドの値は、nlistの`n_type`によって決定されます。

00:17:24.000 --> 00:17:30.000
私たちが興味を持っている主要なn_typeは3つありますが、今のところ2つだけに焦点を当てます。

00:17:30.000 --> 00:17:33.000
1つ目は直接シンボルとして知られています。

00:17:33.000 --> 00:17:38.000
これらは、アプリとフレームワーク内で完全に定義した機能とメソッドです。

00:17:38.000 --> 00:17:43.000
直接記号には、`nlist_64`構造体に名前とアドレスがあります。

00:17:43.000 --> 00:17:49.000
さらに、それらは「n_type」フィールドの特定のビットパターンで表されます。

00:17:49.000 --> 00:17:55.000
具体的には、`n_type`には、2番目、3番目、4番目の最下位ビットが設定されます。

00:17:55.000 --> 00:17:59.000
これらのビットは「N_SECT」とも呼ばれます。

00:17:59.000 --> 00:18:05.000
これらは「nm」で表示され、「-defined-only」フラグと「--numeric-sort」フラグを指定できます。

00:18:05.000 --> 00:18:13.000
ここでは、「nm」はMagicNumbersプログラムの定義されたシンボルを歩き、それらをアドレス順にリストしました。

00:18:13.000 --> 00:18:16.000
私たちが戻ってきた名前は不可解に見えます。

00:18:16.000 --> 00:18:20.000
なぜなら、シンボルテーブルに実際に保存されている名前は、めちゃくちゃな名前だからです。

00:18:20.000 --> 00:18:29.000
これらのめちゃくちゃな名前は、コンパイラとリンカーが関数を一意に識別するのに役立ちますが、angledがない限り理解するのは簡単ではありません。

00:18:29.000 --> 00:18:34.000
これらの名前のより親しみやすいバージョンを取得するために、出力を「swift-demangle」に渡しました。

00:18:34.000 --> 00:18:41.000
これで、私のアプリで直接定義されているため、「main」や「numberChoices」など、おなじみの名前がいくつか得られます。

00:18:41.000 --> 00:18:49.000
同様に、「シンボル」ツールには、nlistデータを表示するオプションがあり、名前を自動的にデangleします。

00:18:49.000 --> 00:18:55.000
関数名をアドレスに関連付けることができるようになったので、クラッシュログをもう一度更新することができます。

00:18:55.000 --> 00:19:05.000
ここでは、関数開始データから取得したオフセット式も直接記号からのエントリと一致し、そのエントリに名前があることがわかります。

00:19:05.000 --> 00:19:11.000
これら2つをまとめると、クラッシュが264バイトで発生したと言えます。

00:19:11.000 --> 00:19:18.000
メインが唯一の機能ではないという事実を知っているので、これはまだいくつかの詳細を望んでいます。

00:19:18.000 --> 00:19:21.000
また、正確な行番号を持つことも役立ちます。

00:19:21.000 --> 00:19:29.000
インスツルメントのトレースの例でこれに似たものに遭遇しました。いくつかの機能名がありましたが、他のものは見逃していました。

00:19:29.000 --> 00:19:36.000
この理由の1つは、シンボルテーブルには、リンクに関与する関数の直接シンボルエントリしかないことです。

00:19:36.000 --> 00:19:42.000
これらは、フレームワークからエクスポートするモジュールまたは関数間で使用する機能です。

00:19:42.000 --> 00:19:46.000
これにより、APIの境界を特定するのに役立ちます。

00:19:46.000 --> 00:19:54.000
また、`dlsym()`や`dladdr()`などの関数で動的ロードに電力を供給するために必要なデータがあることを意味します。

00:19:54.000 --> 00:20:03.000
しかし、1つの欠点は、ローカルまたは静的関数がモジュールの外部で参照されないため、シンボルテーブルで表現されないことです。

00:20:03.000 --> 00:20:09.000
これは、アプリのロジックのかなりの部分を持つ可能性のある実装機能を省略することになります。

00:20:09.000 --> 00:20:14.000
さらに、リリースモードで構築されたバイナリは、シンボルテーブルが削除されるのが一般的です。

00:20:14.000 --> 00:20:21.000
これは、不要なエントリがシンボルテーブルから削除されることを意味し、アプリのサイズを小さくするのに役立ちます。

00:20:21.000 --> 00:20:32.000
考えてみると、アプリのプライマリドライバーがどこにでも機能をエクスポートすることはかなり珍しいので、これらのシンボルテーブルのエントリを維持するスペースを無駄にしています。

00:20:32.000 --> 00:20:44.000
フレームワークとライブラリについては、クライアントが使用すべき機能を間違いなくエクスポートしていますが、他の場所では使用できないため、ローカルで共有された機能を保持する必要はありません。

00:20:44.000 --> 00:20:50.000
プライマリアプリの実行可能ファイルを削除すると、ほとんどの場合、シンボルテーブルは実質的に空のままになります。

00:20:50.000 --> 00:20:54.000
フレームワークとライブラリを削除すると、エクスポートされた機能だけが残ります。

00:20:54.000 --> 00:21:02.000
Strip Linked Product、Strip Style、Strip Swift Symbolsなど、Xcodeのビルド設定に出くわしたかもしれません。

00:21:02.000 --> 00:21:06.000
これらのビルド設定は、ビルド中にアプリがどのように削除されるかを制御します。

00:21:06.000 --> 00:21:12.000
ストリップリンク製品が有効になっている場合、バイナリはストリップスタイルに従って削除されます。

00:21:12.000 --> 00:21:19.000
たとえば、すべてのシンボルは最も侵襲的な除去を実行し、むき出しの必需品だけを残します。

00:21:19.000 --> 00:21:28.000
Non Globalsは、アプリのさまざまなモジュール内で使用されているが、他のアプリで使用するためにエクスポートされない直接シンボルを削除します。

00:21:28.000 --> 00:21:35.000
デバッグシンボルは、DWARFにたどり着いたときに後で説明する3番目のタイプのnlistタイプを削除します。

00:21:35.000 --> 00:21:39.000
しかし、このストリップスタイルは直接記号を保持します。

00:21:39.000 --> 00:21:46.000
たとえば、ここには2つのパブリックインターフェイスと1つの内部共有実装機能を定義するフレームワークがあります。

00:21:46.000 --> 00:21:52.000
これらの機能はすべてリンクに役割を果たすため、すべて直接シンボルエントリがあります。

00:21:52.000 --> 00:21:56.000
非グローバルを削除すると、インターフェイスだけが残ります。

00:21:56.000 --> 00:22:02.000
共有実装機能は、私のフレームワーク内でのみ使用されたため、グローバルとは見なされません。

00:22:02.000 --> 00:22:10.000
同様に、すべてのシンボルを剥がすことは、他のアプリがフレームワークを使用するために必要であるため、依然としてインターフェイスを離れます。

00:22:10.000 --> 00:22:19.000
また、`symbols --onlyNListData`出力では、直接シンボルの間に点在する関数開始アドレスがあることに気付くことができます。

00:22:19.000 --> 00:22:25.000
これらのアドレスは、直接記号になかった、または削除された機能を表します。

00:22:25.000 --> 00:22:30.000
これらのストリップ設定は、シンボルテーブルの可視性の希望のレベルに合わせて調整できます。

00:22:30.000 --> 00:22:34.000
この情報を使用して、いつダイレクトシンボルで作業しているかを判断できます。

00:22:34.000 --> 00:22:46.000
これのいくつかの兆候は、関数名を持つが、行番号やファイル名がないことです。または、フレームワークの例でここに示すように、関数名と関数の開始アドレスが混在しています。

00:22:46.000 --> 00:22:54.000
分析する2番目のタイプのnlist構造体は、直接記号とは対照的に、間接記号として知られています。

00:22:54.000 --> 00:22:59.000
これは、`n_type`が`N_EXT`ビットパターンにのみ一致する場合です。

00:22:59.000 --> 00:23:05.000
これらは、`print()`などの他のフレームワークやライブラリから使用している関数とメソッドです。

00:23:05.000 --> 00:23:12.000
これらは「nm」で見ることができますが、今回は「--defined-only」ではなく「--undefined-only」を指定します。

00:23:12.000 --> 00:23:19.000
また、関数がどのフレームワークまたはライブラリにあるべきかを示す「-m」フラグも追加します。

00:23:19.000 --> 00:23:27.000
たとえば、MagicNumbersアプリは、libswiftCoreで定義されているさまざまなSwift関数に依存しています。

00:23:27.000 --> 00:23:34.000
3つのデバッグ情報カテゴリのうち2つをカバーしたので、その特性を理解していることを確認しましょう。

00:23:34.000 --> 00:23:41.000
関数の開始はアドレスのリストなので、名前がありませんが、オフセットを決定することができます。

00:23:41.000 --> 00:23:48.000
Nlistシンボルテーブルは、情報の構造体全体をエンコードし、名前をアドレスに関連付けることができます。

00:23:48.000 --> 00:23:55.000
それらは、アプリで定義されている直接シンボルと、依存関係によって提供される間接シンボルを記述します。

00:23:55.000 --> 00:24:03.000
直接シンボルは通常、リンクに関連する機能のために予約されており、ストリップビルド設定は、利用可能な直接シンボルに影響します。

00:24:03.000 --> 00:24:10.000
最後に、関数の開始とnlistシンボルテーブルの両方がアプリに直接埋め込まれます。

00:24:10.000 --> 00:24:16.000
私たちがまだ見ていないのは、ファイル名や行番号など、より豊かなレベルの詳細です。

00:24:16.000 --> 00:24:18.000
これはDWARFによって私たちに提供されています。

00:24:18.000 --> 00:24:23.000
DWARFは、nlistシンボルテーブルの概念をまったく異なるレベルに引き上げます。

00:24:23.000 --> 00:24:29.000
DWARFは、関数のサブセットのみを保持するのではなく、すべてを記述するよう努めています。

00:24:29.000 --> 00:24:35.000
Nlistシンボルテーブルは、関数の開始と比較して、はるかに多くの情報を追加することがわかりました。

00:24:35.000 --> 00:24:37.000
それは次元を追加することによってそれを達成しました。

00:24:37.000 --> 00:24:44.000
関数の開始を見たとき、アドレスである単一の次元から始めたことを覚えておいてください。

00:24:44.000 --> 00:24:51.000
次に、nlistシンボルテーブルに情報でいっぱいの構造体をエンコードして、2次元にアップグレードしました。

00:24:51.000 --> 00:24:54.000
DWARFは、関係に関する3次元を追加します。

00:24:54.000 --> 00:24:58.000
DWARFは、機能が分離されていないことを認識しています。

00:24:58.000 --> 00:25:05.000
彼らは他の関数を呼び出し、パラメータを持ち、意味のあるデータを返し、特定のファイルで定義されます。

00:25:05.000 --> 00:25:10.000
これらの関係をエンコードすると、シンボリックの最も強力な側面が解き放たされます。

00:25:10.000 --> 00:25:15.000
DWARFを分析するときは、主にdSYMバンドルを参照しています。

00:25:15.000 --> 00:25:22.000
plistsなどの他のメタデータに加えて、dSYMバンドルにはDWARFのバイナリが含まれています。

00:25:22.000 --> 00:25:24.000
このバイナリが特別な理由は何ですか?

00:25:24.000 --> 00:25:29.000
バイナリには、特別な「__DWARF」セグメントにデータが含まれています。

00:25:29.000 --> 00:25:35.000
DWARF仕様は、私たちが焦点を当てるセグメント内の3つのデータストリームに言及しています。

00:25:35.000 --> 00:25:45.000
`debug_info`には生データが含まれ、`debug_abbrev`はデータに構造を割り当て、`debug_line`にはファイル名と行番号が含まれています。

00:25:45.000 --> 00:25:51.000
DWARFはまた、最初に勉強する2つの語彙タイプを定義します。コンパイルユニットとサブプログラムです。

00:25:51.000 --> 00:25:54.000
3つ目は後で紹介します。

00:25:54.000 --> 00:26:00.000
コンパイルユニットは、製品の構築に入った単一のソースファイルを表します。

00:26:00.000 --> 00:26:06.000
たとえば、プロジェクト内のSwiftファイルごとに1つのコンパイルユニットを持つことが期待できます。

00:26:06.000 --> 00:26:16.000
DWARFは、ファイルの名前、SDK、その機能が占める`__TEXT`セグメントの部分など、コンパイルユニットにプロパティを割り当てます。

00:26:16.000 --> 00:26:29.000
Main.swiftコンパイルユニットには、左側の`debug_info`ストリームにこれらのプロパティが含まれており、右側の`debug _abbrev`ストリームに対応するエントリがあり、値が何を表しているかを示します。

00:26:29.000 --> 00:26:37.000
ここでは、ファイル名、書かれている言語、および`__TEXT`セグメント範囲を表す低/高のペアが表示されます。

00:26:37.000 --> 00:26:40.000
サブプログラムは、定義された関数を表します。

00:26:40.000 --> 00:26:48.000
Nlistシンボルテーブルで定義された関数をすでに見ましたが、サブプログラムは静的およびローカル関数も記述できます。

00:26:48.000 --> 00:26:53.000
サブプログラムには、名前とその「__TEXT」セグメントアドレス範囲もあります。

00:26:53.000 --> 00:27:02.000
コンパイルユニットとサブプログラムの基本的な関係の1つは、サブプログラムがコンパイルユニットで定義されることです。

00:27:02.000 --> 00:27:05.000
DWARFはこれを木で表しています。

00:27:05.000 --> 00:27:11.000
コンパイルユニットはツリーのルートにあり、子としてサブプログラムエントリがあります。

00:27:11.000 --> 00:27:15.000
子供たちは住所範囲に従うことで検索できます。

00:27:15.000 --> 00:27:19.000
「Dwarfdump」コマンドを使用して、これらをより詳細に調べることができます。

00:27:19.000 --> 00:27:21.000
まず、コンパイルユニットを見ていきます。

00:27:21.000 --> 00:27:25.000
これは、先に述べたコンパイルユニットのプロパティの一部と一致します。

00:27:25.000 --> 00:27:35.000
`dwarfdump`は、`debug_ info`と`debug _abbrev`の内容を組み合わせて、dSYMのデータの構造と内容を表示します。

00:27:35.000 --> 00:27:40.000
そして、出力を下にスクロールすると、1つのサブプログラムの子に遭遇します。

00:27:40.000 --> 00:27:47.000
それが占めるアドレス範囲はコンパイルユニットの範囲内であり、関数の名前も見ることができます。

00:27:47.000 --> 00:27:50.000
私は、DWARFがそのデータを非常に詳細に説明していると述べました。

00:27:50.000 --> 00:27:56.000
これらすべての詳細に多くの時間を費やすことはありませんが、関数パラメータなどの詳細を見るのは楽しいと思います。

00:27:56.000 --> 00:28:02.000
彼らは、パラメータの名前とタイプを記述する独自の語彙タイプを持っています。

00:28:02.000 --> 00:28:07.000
ツリーモデルに続いて、パラメータはサブプログラムの子です。

00:28:07.000 --> 00:28:12.000
ここでは、関数に供給する選択肢パラメータのエントリに出くわします。

00:28:12.000 --> 00:28:17.000
次に、ファイル名と行番号は「debug_line」ストリームから来ます。

00:28:17.000 --> 00:28:19.000
このストリームにはツリー構造がありません。

00:28:19.000 --> 00:28:27.000
代わりに、個々のファイルアドレスを正確なコード行にマッピングできるラインテーブルプログラムを定義します。

00:28:27.000 --> 00:28:33.000
これにより、ファイルと行を見つけるために検索できるソースコードの詳細のリストが生成されます。

00:28:33.000 --> 00:28:41.000
`debug_info`ツリーを解析して`debug_line`リストを生成すると、次のような構造になります。

00:28:41.000 --> 00:28:45.000
したがって、ファイルアドレスを一致させたい場合は、ツリーを横断できます。

00:28:45.000 --> 00:28:49.000
まず、コンパイルユニットから始めて、ブランチに従います。

00:28:49.000 --> 00:28:53.000
次に、一致した「debug_line」エントリのいずれかをピックアップします。

00:28:53.000 --> 00:29:01.000
「Atos」でこれを再び自動化できますが、今回は特に「-i」フラグを除外しています。

00:29:01.000 --> 00:29:03.000
ここで少し奇妙なことに気づきましたか?

00:29:03.000 --> 00:29:08.000
はい、私たちは関数名と行番号を持っているので、間違いなくDWARFを使用しています。

00:29:08.000 --> 00:29:13.000
しかし、それ以外は、これはnlistシンボルテーブルの更新とあまり違いはありません。

00:29:13.000 --> 00:29:22.000
実際、初めて「atos」を使用したときと比較すると、まだ多くの貴重な機能と詳細が欠けているように見えます!

00:29:22.000 --> 00:29:24.000
ここで何があったの?

00:29:24.000 --> 00:29:30.000
唯一変わったのは、今回は「-i」を「atos」に指定しなかったことです。

00:29:30.000 --> 00:29:34.000
その旗は「インライン関数」の略です。

00:29:34.000 --> 00:29:38.000
インライン化は、コンパイラが実行するルーチンの最適化です。

00:29:38.000 --> 00:29:43.000
これには、関数呼び出しを関数の本体に直接置き換えることが含まれます。

00:29:43.000 --> 00:29:47.000
それが持っている1つのクールな効果は、コードが一見消えるようにすることです。

00:29:47.000 --> 00:29:55.000
`numberChoices()`を呼び出すのではなく、`numberChoices()`のコード全体が削除されたと考えることができます。

00:29:55.000 --> 00:30:00.000
突然、`numberChoices()`への関数呼び出しがなくなりました!

00:30:00.000 --> 00:30:03.000
DWARFはこれをインラインサブルーチンで表します。

00:30:03.000 --> 00:30:07.000
これは、今日議論するDWARFの3番目で最後の語彙タイプです。

00:30:07.000 --> 00:30:15.000
インライン化されたサブルーチンは、別のサブプログラムにインライン化されたサブプログラムであるため、関数です。

00:30:15.000 --> 00:30:24.000
インライン関数は関係ツリー内の別のノードに完全に飲み込まれるため、インラインサブルーチンはそのノードの子です。

00:30:24.000 --> 00:30:32.000
この定義は再帰的にも適用されます。つまり、インライン化されたサブルーチンは他のインライン化された子を持つことができます。

00:30:32.000 --> 00:30:36.000
繰り返しますが、「dwarfdump」を使用すると、インライン化されたサブルーチンを探すことができます。

00:30:36.000 --> 00:30:42.000
それらは他のノードの子としてリストされており、名前や住所などのサブプログラムと同様のプロパティを持っています。

00:30:42.000 --> 00:30:50.000
ただし、DWARFでは、これらのプロパティは、抽象オリジンと呼ばれる共通のノードを介して頻繁にアクセスされます。

00:30:50.000 --> 00:31:00.000
特定の関数のインラインコピーが多い場合、それらの共通の共有プロパティは、どこでも重複しないように、抽象的なオリジンに保持されます。

00:31:00.000 --> 00:31:05.000
インラインサブルーチンが持つユニークなプロパティの1つは、コールサイトです。

00:31:05.000 --> 00:31:12.000
これは、実際の関数呼び出しを書いたソースコードの場所ですが、オプティマイザがそれを置き換えました。

00:31:12.000 --> 00:31:18.000
たとえば、main.swiftファイルの36行目で「generateANumber」を呼び出しました。

00:31:18.000 --> 00:31:22.000
これにより、新しい子ノードでツリーを更新できます。

00:31:22.000 --> 00:31:27.000
そして今、これは私たちのプログラムのはるかに包括的な見解のように見えます。

00:31:27.000 --> 00:31:35.000
インライン関数の最適化の詳細は、完全にシンボリック化されたクラッシュログにたどり着くための重要な詳細でした。

00:31:35.000 --> 00:31:41.000
「Atos」の「-i」フラグは、シンボリック化中にそれらを考慮するようにツールに指示します。

00:31:41.000 --> 00:31:44.000
彼らはまた、私たちのインスツルメントトレースから欠けている詳細でした。

00:31:44.000 --> 00:31:54.000
インスツルメンツとクラッシュログの両方でdSYMが必要な理由は、まさにこのすべてのコンテンツを抽出できるようにした。

00:31:54.000 --> 00:32:00.000
DWARFを見つける別のソースがあり、それは静的ライブラリとオブジェクトファイルからのものです。

00:32:00.000 --> 00:32:07.000
dSYMがない場合でも、静的ライブラリまたはオブジェクトファイルからリンクした関数のDWARFを収集できます。

00:32:07.000 --> 00:32:12.000
そのような場合、デバッグシンボルnlistタイプがあります。

00:32:12.000 --> 00:32:15.000
これらは、剥がすことができるシンボルタイプの1つでした。

00:32:15.000 --> 00:32:18.000
しかし、彼らはDWARF自身を保持していません。

00:32:18.000 --> 00:32:22.000
むしろ、彼らは関数を元のファイルに関連付けます。

00:32:22.000 --> 00:32:28.000
ライブラリがデバッグ情報を使用して構築された場合、nlistエントリはそのDWARFを指し示すことができます。

00:32:28.000 --> 00:32:35.000
これらのタイプのnlistエントリは、`dsymutil -dump-debug-map`で冗長に見ることができます。

00:32:35.000 --> 00:32:39.000
ここには、さまざまな機能のリストと、それらがどこから引き出されたかがあります。

00:32:39.000 --> 00:32:42.000
これらの場所は、DWARFのためにスキャンして処理することができます。

00:32:42.000 --> 00:32:47.000
要約すると、DWARFは詳細なシンボリック化データの重要な情報源です。

00:32:47.000 --> 00:32:52.000
DWARFは、関数とファイルの間の重要な関係を公開します。

00:32:52.000 --> 00:33:00.000
関数インライン化などの最適化は、シンボリック化の品質に大きな影響を与え、DWARFはそれを非常によく表現できます。

00:33:00.000 --> 00:33:04.000
また、dSYMと静的ライブラリにはDWARFが含まれていることもわかりました。

00:33:04.000 --> 00:33:12.000
ただし、dSYMを他の人に簡単に転送でき、いくつかのツールからサポートが組み込まれているため、dSYMを優先してください。

00:33:12.000 --> 00:33:18.000
最後に、象徴化を促進するために使用できるさまざまなツールやヒントを共有したいと思います。

00:33:18.000 --> 00:33:25.000
ローカル開発ビルドの場合、デバッグモードでビルドすると、一般的に多くのデバッグ情報があります。

00:33:25.000 --> 00:33:32.000
リリースモードでは、デバッグ情報フォーマットのビルド設定をチェックすることで、XcodeがdSYMを生成することを確認できます。

00:33:32.000 --> 00:33:36.000
リリースがdSYMファイルでDWARFに設定されていることを確認してください。

00:33:36.000 --> 00:33:41.000
App Storeに提出されたアプリについては、App Store ConnectからdSYMをダウンロードできます。

00:33:41.000 --> 00:33:45.000
これには、ビットコードが有効になっているアプリも含まれます。

00:33:45.000 --> 00:33:51.000
特定のdSYMがすでにデバイス上にあることを確認したい場合は、「mdfind」コマンドを使用できます。

00:33:51.000 --> 00:33:58.000
ここでの英数字の文字列は、バイナリのUUIDであり、ロードコマンドで定義された一意の識別子です。

00:33:58.000 --> 00:34:03.000
dSYMのUUIDは「シンボル-uuid」で確認できます。

00:34:03.000 --> 00:34:07.000
ツールチェーンが無効なDWARFを生成することがあります。

00:34:07.000 --> 00:34:09.000
これは「dwarfdump -verify」で確認できます。

00:34:09.000 --> 00:34:13.000
報告されたエラーが表示された場合は、バグを提出してください!

00:34:13.000 --> 00:34:17.000
DWARFデータには、バイナリごとに4ギガバイトの上限もあります。

00:34:17.000 --> 00:34:28.000
dSYMで問題が発生し、4ギガバイトを超えていることが確認された場合は、それぞれが独自の小さなdSYMを持つように、プロジェクトを別々のコンポーネントに分割することを検討してください。

00:34:28.000 --> 00:34:36.000
使用しているdSYMが、UUIDを比較することで、興味のあるアプリの特定のビルドと一致することを確認できます。

00:34:36.000 --> 00:34:43.000
アプリのUUIDは、クラッシュレポートのバイナリ画像リストセクションにあり、「シンボル」コマンドでも見ることができます。

00:34:43.000 --> 00:34:49.000
アプリとdSYMの両方が同じUUIDを持っていることを確認する必要があります。

00:34:49.000 --> 00:34:55.000
「シンボル」ツールでは、アプリが利用可能なデバッグ情報の種類を確認することもできます。

00:34:55.000 --> 00:35:02.000
私たちはすでにこの例を見てきましたが、角括弧内のこれらのタグが情報源を教えてくれることを思い出させるのに役立ちます。

00:35:02.000 --> 00:35:07.000
どのデバッグ情報を扱っているのかわからない場合に便利です。 便利です。

00:35:07.000 --> 00:35:16.000
dSYMが利用可能であることは確かですが、Instrumentsトレースで関数の名前を取得していない場合は、資格とコード署名を確認してください。

00:35:16.000 --> 00:35:23.000
具体的には、「codesign」コマンドを使用すると、適切なコード署名があることを確認できます。

00:35:23.000 --> 00:35:28.000
また、開発用にローカルに構築されたアプリに「get-task-allow」資格があることを確認する必要があります。

00:35:28.000 --> 00:35:34.000
この資格は、インストゥルメントなどのツールにアプリをシンボリックする権限を付与します。

00:35:34.000 --> 00:35:41.000
Xcodeは、プロファイルアクションでこのエンタイトルメントを自動的に設定する必要がありますが、確認すると便利です。

00:35:41.000 --> 00:35:52.000
「get-task-allow」エンタイトルメントが有効になっていない場合は、Code Signing Inject Base Entitlementsのビルド設定を確認し、開発中に有効になっていることを確認する必要があります。

00:35:52.000 --> 00:36:00.000
最後に、ユニバーサル2アプリの場合、興味のあるアーキテクチャをツールに指定する必要があります。

00:36:00.000 --> 00:36:07.000
`symbols`、`otool`、および`dwarfdump`はすべて、特定のアーキテクチャスライスでのみ動作する`-arch`フラグを持っています。

00:36:07.000 --> 00:36:11.000
これで「象徴化：基本を超えて」は終わります。

00:36:11.000 --> 00:36:15.000
他に何もなければ、私は本当にいくつかの重要なポイントを強調したいと思います。

00:36:15.000 --> 00:36:25.000
UUIDとファイルアドレスは、ASLRスライドから独立しているため、アプリが何をしていたかを識別するための一貫した信頼性の高い方法です。

00:36:25.000 --> 00:36:28.000
また、デバッグ情報を照会するための鍵でもあります。

00:36:28.000 --> 00:36:31.000
また、可能な限りdSYMを使用する必要があります。

00:36:31.000 --> 00:36:38.000
dSYMには、DWARFの形で最も豊富なデバッグ情報が含まれており、XcodeとInstrumentsでサポートされています。

00:36:38.000 --> 00:36:42.000
最後に、いくつかのツールを取り上げました。

00:36:42.000 --> 00:36:47.000
これらのツールはXcodeですぐに利用でき、強力な診断と洞察を提供します。

00:36:47.000 --> 00:36:54.000
デバッグと最適化のために、それらをワークフローに組み込むよう努めるべきです。

00:36:54.000 --> 00:37:08.000
もっと知りたい場合は、WWDC18の次の2つのセッションをお勧めします。「アプリの起動時間の最適化」と「アプリの起動時間：過去、現在、未来」です。

00:37:08.000 --> 00:37:11.000
象徴化について学ぶために私に参加してくれてありがとう!

00:37:11.000 --> 00:37:13.000
素敵な一週間をお過ごしください。

00:37:13.000 --> 23:59:59.000
♪

