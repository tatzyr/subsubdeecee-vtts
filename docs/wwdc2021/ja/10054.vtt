WEBVTT

00:00:00.000 --> 00:00:06.000
♪ベース音楽の演奏♪

00:00:06.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:11.000
ジェフ・ナドー:こんにちは、「AppKitの新機能」へようこそ。

00:00:11.000 --> 00:00:13.000
私はジェフ・ナドーです。

00:00:13.000 --> 00:00:16.000
私はAppKitに取り組んでおり、あなたと共有する素晴らしいアップデートがいくつかあります。

00:00:16.000 --> 00:00:21.000
macOS Montereyには、Macアプリのためのいくつかの素晴らしい新機能と機能強化が含まれています。

00:00:21.000 --> 00:00:44.000
このリリースには、ユーザーインターフェイスデザインのアップデート、多くのコントロールの強化、SFシンボルの大きなアップデート、TextKit 2と呼ばれるまったく新しいテキストエンジン、強力な新しいSwift言語機能、Macで利用可能なショートカットによる自動化など、誰にとっても本当に何かがあります。

00:00:44.000 --> 00:00:50.000
macOSのユーザーインターフェイスのデザインに関するいくつかのアップデートから始めましょう。

00:00:50.000 --> 00:00:55.000
私たちは、macOS Big Surでデビューしたシステム全体の再設計への反応に興奮しています。

00:00:55.000 --> 00:01:01.000
私たちのお気に入りのアプリの多くは、わずか数ヶ月で新しいデザインを採用するように更新されました。

00:01:01.000 --> 00:01:09.000
macOS Montereyでは、この新しいデザインを反復して改良し続けているので、システム全体でいくつかの新しいタッチに気づくでしょう。

00:01:09.000 --> 00:01:21.000
それらのいくつかは、新しいアニメーションで表示されて後退するポップオーバーや、クリックしたときにスムーズに所定の位置に滑り込むスライダーなど、大きくて目立つものもあります。

00:01:21.000 --> 00:01:32.000
ツールバーコントロールの洗練されたメトリクスや、検索ボタンのバネローディングサポートなど、はるかに微妙な変更もあるので、テキストやトークンを簡単にドラッグできます。

00:01:32.000 --> 00:01:37.000
そして、明快さを向上させるためにテーブルセクション間の間隔を増やしました。

00:01:37.000 --> 00:01:41.000
私たちは、細部まで新しいデザインを反復し、強化し続けています。

00:01:41.000 --> 00:01:46.000
そして、それはあなたがあなた自身のデザインを洗練するために使用できるいくつかのコントロールの強化につながります。

00:01:46.000 --> 00:01:49.000
最初の大きなものはコントロールティンティングです。

00:01:49.000 --> 00:01:56.000
個々のボタン、セグメント化されたコントロール、スライダーのカスタム着色を有効にしました。

00:01:56.000 --> 00:02:06.000
これらの各コントロールは、これらのAPIの1つを使用してカスタムティントカラーを受け入れます：bezelColor、selectedSegmentColor、およびtrackFillColor。

00:02:06.000 --> 00:02:12.000
タッチバーで個々のコントロールの着色を可能にするために、macOS SierraにこれらのAPIを導入しました。

00:02:12.000 --> 00:02:17.000
そして、macOS Monterey以降、ウィンドウ内コントロールでも機能します。

00:02:17.000 --> 00:02:24.000
要約すると、ほとんどのコントロールは、システム環境設定で設定可能なアクセントカラーを使用して描画します。

00:02:24.000 --> 00:02:27.000
これにより、人々は自分の好きな色に合わせてMacをテーマにすることができます。

00:02:27.000 --> 00:02:32.000
マルチカラーオプションを使用すると、各アプリは独自のカスタムカラーを定義できます。

00:02:32.000 --> 00:02:38.000
広範なテーマについては、アプリのアセットカタログでカスタムアクセントカラーを定義できます。

00:02:38.000 --> 00:02:43.000
新しい着色APIは、1つの特定のコントロールの色を上書きする方法を提供します。

00:02:43.000 --> 00:02:48.000
これは、意味的に意味のある色を適用したいコントロールに最適です。

00:02:48.000 --> 00:02:58.000
たとえば、アプリが特定のオレンジ色の色合いを使用して予約注文と通常の購入を区別する場合、着色されたボタンを使用してそのデザインを強化できます。

00:02:58.000 --> 00:03:06.000
もう1つの例は、通話の開始ボタンと終了ボタンがアプリで最も意味のあるアクションの2つを実行するビデオ会議アプリです。

00:03:06.000 --> 00:03:12.000
それらを緑と赤に着色すると強調され、その機能が即座に認識可能になります。

00:03:12.000 --> 00:03:21.000
重要な注意点の1つは、着色されたボタンは、白や灰色の通常のプッシュボタンとは異なり、すべてのアクティブな状態で常に色合いの色を表示することです。

00:03:21.000 --> 00:03:24.000
これはあなたの色合いの色を前面と中央に置きます。

00:03:24.000 --> 00:03:31.000
ただし、カラフルな外観を使用するデフォルトのボタンと混同しないようにデザインに注意してください。

00:03:31.000 --> 00:03:36.000
最後に、単なる色以上のものを使ってコントロールの目的を伝えることが重要です。

00:03:36.000 --> 00:03:47.000
色を区別するのが難しい人は、特定のコントロールの目的を簡単に識別できるようにしたいので、必ず明確なラベルやアイコンを提供してください。

00:03:47.000 --> 00:03:54.000
もう1つの重要なボタンのデザイン変更は、プッシュボタンがクリック時にアクセントカラーを使用して強調表示されなくなったことです。

00:03:54.000 --> 00:04:01.000
これにより、セグメント化されたコントロールセグメント、スライダーノブ、ステッパーなど、他のクリック可能な要素と一致します。

00:04:01.000 --> 00:04:15.000
これは重要な変更です。なぜなら、ハイライトされている間にカラフルな外観を想定したカスタム描画を行う場合、つまり、上に白いコンテンツを描画することを選択した場合、macOS Montereyでは正しく見えない可能性があるためです。

00:04:15.000 --> 00:04:22.000
ハイライト状態をチェックする代わりに、interiorBackgroundStyleプロパティを使用して描画の決定を推進できます。

00:04:22.000 --> 00:04:39.000
このプロパティは、ボタンベゼルの基礎となるスタイルを反映しているため、無色の状態には常に.normalを返し、着色されたボタン、デフォルトボタン、および「オン」状態に切り替えられたボタンなど、カラフルな強調状態に対して.emphasizedを返します。

00:04:39.000 --> 00:04:47.000
最後に、以前はレギュラースクエアとして知られていたボタンのフレキシブルプッシュスタイルを更新し、可変高さのプッシュボタンとして機能しました。

00:04:47.000 --> 00:04:55.000
通常のプッシュボタンと同じ構成をすべてサポートするようになりました。つまり、デフォルトのボタンとして機能し、色を塗ることができます。

00:04:55.000 --> 00:05:11.000
コーナー半径とコンテンツパディングは、各コントロールサイズの標準プッシュボタンと一致するため、他のコントロールとうまく収まりますが、垂直方向のサイズ変更可能なデザインは、改行でより大きなアイコンやテキストに対応できることを意味します。

00:05:11.000 --> 00:05:23.000
プッシュボタンの大部分は、標準の固定高さスタイルを使用し続ける必要がありますが、この新しく拡張されたスタイルは、背の高いコンテンツに対応する必要がある場合の特別なケースに柔軟性を提供します。

00:05:23.000 --> 00:05:30.000
もう1つの非常に重要なコントロールアップデートは、メニューキーボードショートカットの自動ローカリゼーションの形で提供されます。

00:05:30.000 --> 00:05:37.000
世界には多くのキーボードレイアウトがあり、キーボードショートカットのローカライズをかなり複雑にする可能性があります。

00:05:37.000 --> 00:05:42.000
一部のキーボードでは手が届きにくいものもあれば、まったく入力できないものもあります。

00:05:42.000 --> 00:05:48.000
さらに、いくつかの指向性キーボードショートカットは、本当に右から左の言語でミラーリングする必要があります。

00:05:48.000 --> 00:05:53.000
素晴らしいニュースは、macOS Montereyでは、AppKitがあなたのためにそれを行うことができるということです。

00:05:53.000 --> 00:05:58.000
ローカリゼーションの恩恵を受けることができるショートカットの例を次に示します。Command-backslashです。

00:05:58.000 --> 00:06:07.000
これは米国の英語のキーボードではうまく機能しますが、実際にはバックスラッシュキーがまったくない日本語のキーボードで入力することは不可能です。

00:06:07.000 --> 00:06:15.000
macOS Monterey以降、システムはショートカットを自動的に再マップし、自然に入力できる同等のショートカットを提供します。

00:06:15.000 --> 00:06:19.000
もう1つの一般的なケースは、方向性の意味を持つキーボードショートカットです。

00:06:19.000 --> 00:06:25.000
たとえば、Safariはコマンド二乗括弧を使用して、歴史を前後に進めます。

00:06:25.000 --> 00:06:35.000
右から左の言語では、左の括弧を使用して戻るのはあまり直感的ではないため、AppKitは右から左の言語で実行するときに自動的に右の括弧に交換するようになりました。

00:06:35.000 --> 00:06:40.000
この動作は、括弧、中括弧、括弧、矢印キーに適用されます。

00:06:40.000 --> 00:06:44.000
場合によっては、このミラーリング動作を無効にしたい場合があります。

00:06:44.000 --> 00:06:53.000
たとえば、メニュー項目に絶対的な方向性がある場合（たとえば、左揃えなど）は、右から左の言語でも左括弧を使用します。

00:06:53.000 --> 00:06:57.000
このようなケースのオプトアウトを提供しました。

00:06:57.000 --> 00:07:01.000
NSMenuItemのいくつかの新しいプロパティを使用して、この動作を制御できます。

00:07:01.000 --> 00:07:18.000
allowsAutomaticKey EquivalentMirroringを使用すると、ブラケットなどの方向キーのミラーリング動作を制御でき、allowsAutomaticKey EquivalentLocalizationは、キーボードマッピングやミラーリングを含むすべてのローカリゼーション機能を制御します。

00:07:18.000 --> 00:07:30.000
すでにキーボードショートカットを慎重にローカライズしている場合、またはアプリケーションにキーボードショートカットバインディングのカスタム実装がある場合は、アプリ全体でこの機能を無効にすることをお勧めします。

00:07:30.000 --> 00:07:39.000
これを行うには、このアプリケーションデリゲートメソッドを実装し、applicationShouldAutomatically LocalizeKeyEquivalentsを実装し、falseを返すことができます。

00:07:39.000 --> 00:07:41.000
ほとんどのアプリはこれを使用する必要はありません。

00:07:41.000 --> 00:07:49.000
個々のメニュー項目APIは、特定の項目をオプトアウトするために強く好まれており、ほとんどのアプリはまったくオプトアウトする必要はありません。

00:07:49.000 --> 00:07:53.000
次に、シンボル画像のいくつかの大きな機能強化。

00:07:53.000 --> 00:08:03.000
私たちはBig SurのmacOSにSFシンボルをもたらし、すべてのMacアプリに美しく、タイポグラフィ的にバランスのとれたシンボル画像の大規模なレパートリーを開きました。

00:08:03.000 --> 00:08:11.000
macOS Montereyでは、SFシンボル3と呼ばれる新世代のシンボルAPIとツールを構築しました。

00:08:11.000 --> 00:08:18.000
これは、シンボル画像ワークフローのあらゆる側面にまたがる大きなアップデートであり、AppKitアプリケーションですべて利用できます。

00:08:18.000 --> 00:08:26.000
SFシンボル3は、シンボル画像のプレビュー、エクスポート、インポートのためのSFシンボルアプリの機能を拡張します。

00:08:26.000 --> 00:08:42.000
また、カスタムシンボルに注釈を付けるための更新されたフォーマットが付属しており、シンボル画像内に異なるレイヤーを定義することができ、AppKit、UIKit、SwiftUIのAPIを拡張して、シンボルの各レイヤーを個別に色付けできるようにしました。

00:08:42.000 --> 00:08:46.000
ビッグサーでは、シンボルの2つの異なるレンダリングモードを提供しました。

00:08:46.000 --> 00:08:54.000
まず、シンボル全体に単一の色合いの色または効果を使用して描画する伝統的なテンプレートスタイルがありました。

00:08:54.000 --> 00:09:04.000
2つ目はマルチカラーで、フルカラー画像のように描画し、シンボル画像自体で定義されている色を使用して各パス要素を描画します。

00:09:04.000 --> 00:09:12.000
SFシンボル3では、新しいシンボル画像フォーマットによって提供されるレイヤー情報を利用する2つの新しいレンダリングモードを追加しました。

00:09:12.000 --> 00:09:22.000
最初のヒエラルキーは、シンボルの特定の部分を強調しながら、他のものを強調しながら、単一の色を使用して描画します。

00:09:22.000 --> 00:09:28.000
そして2番目のパレットでは、シンボルの各レイヤーに好きな色を割り当てることができます。

00:09:28.000 --> 00:09:34.000
NSImage.SymbolConfigurationの新しいAPIを使用して、これらのレンダリングモードにアクセスできます。

00:09:34.000 --> 00:09:40.000
NSColorパラメータをドットとして表現して、レンダリングされたシンボルとどのように対応するかを示しています。

00:09:40.000 --> 00:09:46.000
階層レンダリングモードは単一の色を取り、不透明度が減少してシンボルレイヤーに適用されます。

00:09:46.000 --> 00:09:51.000
パレットモードは、レイヤーに逐語的に適用される色の配列を受け入れます。

00:09:51.000 --> 00:09:58.000
マルチカラーレンダリングモードを好む設定を作成することもできます。

00:09:58.000 --> 00:10:04.000
また、1つのベースシンボルからそのバリアントの1つにマッピングできる新しいAPIを追加しました。

00:10:04.000 --> 00:10:14.000
たとえば、ハートのシンボルを塗りつぶされたバリアント、円のような刻まれたバリアント、さらにはスラッシュを含むバリアントにマッピングできます。

00:10:14.000 --> 00:10:21.000
これは、特定のコンテキストで特定のスタイルのシンボルを好む状況で本当に便利です。

00:10:21.000 --> 00:10:28.000
たとえば、選択されていない状態のアウトラインを好むピッカーコントロールがありますが、選択には塗りつぶされたスタイルがあります。

00:10:28.000 --> 00:10:35.000
通常、このコントロールでは、画像の選択されたバージョンと未選択のバージョンを指定するために、2つの異なる画像プロパティが必要になります。

00:10:35.000 --> 00:10:44.000
しかし、バリアントAPIを使用すると、単一のベースシンボルを受け入れ、満たされた状態を自動的に導き出すことができます。

00:10:44.000 --> 00:10:54.000
このコントロールは、image(with: .fill)を呼び出すことができ、選択状態で塗りつぶされたシンボルを好むことができ、塗りつぶされたバリアントが利用可能なときはいつでも、シンボルの適切なバージョンを自動的に選択します。

00:10:54.000 --> 00:11:03.000
シンボルバリアントの種類ごとに定数があり、それらを組み合わせて、円や塗りつぶしなどの複数のバリアントを一緒に要求することができます。

00:11:03.000 --> 00:11:08.000
これは、SFシンボル3の機能の簡単な紹介でした。

00:11:08.000 --> 00:11:14.000
シンボルワークフロー全体で新しいすべての詳細を入手できる新しいビデオコレクションがあります。

00:11:14.000 --> 00:11:17.000
必ずウォッチリストに追加してください。

00:11:17.000 --> 00:11:22.000
macOS Montereyは、TextKit 2の形でテキストシステムの大幅なアップデートも備えています。

00:11:22.000 --> 00:11:30.000
TextKitは、すべてのAppleデバイス用のテキストレイアウトとレンダリングエンジンであり、実績のある優れたテキストエンジンです。

00:11:30.000 --> 00:11:36.000
TextKitは線形テキストレイアウトエンジンです。つまり、テキストのブロックを最初から最後までタイプします。

00:11:36.000 --> 00:11:44.000
プラットフォームと技術を進化させるにつれて、非線形テキストレイアウトがはるかに役立つケースが多く見つかりました。

00:11:44.000 --> 00:11:52.000
そこで、基本に戻り、TextKitの新しいバージョンを作成しました。それはTextKit 2です。

00:11:52.000 --> 00:11:55.000
TextKit 2にはいくつかの重要な目標がありました。

00:11:55.000 --> 00:12:01.000
いつものように、私たちはすべてのスクリプトとレイアウトの国際的なテキストに最高の体験を提供したいと考えています。

00:12:01.000 --> 00:12:05.000
また、テキストを他の種類のコンテンツと簡単に混在させたいと考えています。

00:12:05.000 --> 00:12:17.000
そして最後に、TextKit 2は、短いラベルであろうと、大規模なドキュメントの途中でスクロールされるであろうと、テキストを超高速で効率的に整形し、レンダリングするように設計されています。

00:12:17.000 --> 00:12:23.000
TextKit 2はTextKit 1と共存しているため、特定のテキストビューに使用するエンジンを選択できます。

00:12:23.000 --> 00:12:25.000
今、私はあなたに秘密を教えます。

00:12:25.000 --> 00:12:36.000
Big Sur以降、TextEditはプレーンテキストドキュメントに使用し、AppKitテキストフィールドはほとんどの設定にTextKit 2を使用するため、すでにMacでTextKit 2を実行しています。

00:12:36.000 --> 00:12:40.000
だから、あなたは実際にこの間ずっとスニークピークを得ています。

00:12:40.000 --> 00:12:45.000
TextKit 2の主な違いの1つは、常に非線形レイアウトシステムを使用していることです。

00:12:45.000 --> 00:12:52.000
つまり、テキストレイアウトをより詳細なレベルで実行できるため、不要な作業を回避できます。

00:12:52.000 --> 00:13:04.000
たとえば、テキストの一部のみがスクロールして表示される大きなドキュメントがある場合、線形システムは、この領域を表示するために、以前のテキストをすべてレイアウトする必要があります。

00:13:04.000 --> 00:13:11.000
比較すると、TextKit 2のような非線形システムは、最も近い段落境界でレイアウトを開始できます。

00:13:11.000 --> 00:13:14.000
大規模な文書の場合、これは大きなスピードアップです。

00:13:14.000 --> 00:13:22.000
新しいレイアウトエンジンは、堅牢なカスタマイズポイントセットを提供し、レイアウトシステムを拡張して独自の動作を簡単に追加できるようにします。

00:13:22.000 --> 00:13:29.000
非線形レイアウトシステムは、非テキスト要素をテキストレイアウトに混在させるのにも適しています。

00:13:29.000 --> 00:13:33.000
そして、最大のドキュメントでもパフォーマンスを向上させながら、これらすべてを行います。

00:13:33.000 --> 00:13:41.000
詳細については、新しいAPIの設計とその使用方法について詳しく説明する「Meet TextKit 2」をチェックしてください。

00:13:41.000 --> 00:13:49.000
次に、並行性から始まるSwiftのAppKitに関するいくつかのアップデートを共有したいと思います。

00:13:49.000 --> 00:13:54.000
Swift 5.5では、並行性を管理するための重要な言語レベルの機能をいくつか導入しています。

00:13:54.000 --> 00:14:01.000
最初のasync/awaitは、コルーチンのように振る舞う非同期メソッド呼び出しを可能にします。

00:14:01.000 --> 00:14:09.000
2番目のアクタータイプは、単一の実行スレッドへのアクセスを分離することで、データレースから変更可能な状態を保護します。

00:14:09.000 --> 00:14:12.000
AppKitは、これらの新機能の両方でうまく機能します。

00:14:12.000 --> 00:14:25.000
非同期/待機の場合、AppKitの多くの非同期メソッド、つまり、補完ハンドラブロックとして継続を取るメソッドは、非同期バリアントも提供するためにSDKで変換されています。

00:14:25.000 --> 00:14:31.000
1つの簡単な例は、ユーザーが画面上のどこからでも色を選択できるNSColorSamplerです。

00:14:31.000 --> 00:14:39.000
この呼び出しは、ユーザーが好きな色を選択するのを待ってから、完了したら完了ハンドラを実行するため、非同期です。

00:14:39.000 --> 00:14:43.000
Async/awaitを使用すると、これを非同期関数呼び出しとして表現できます。

00:14:43.000 --> 00:14:51.000
非同期作業が完了するのを待っている間に実行スレッドを生成し、中断したところから右に戻ります。

00:14:51.000 --> 00:14:53.000
ガードステートメント内から行うこともできます。

00:14:53.000 --> 00:15:00.000
これで、継続（次に実行する作業）は、完了ハンドラブロック内にネストされなくなりました。

00:15:00.000 --> 00:15:06.000
代わりに、コードは自然に順番に読み込まれます。

00:15:06.000 --> 00:15:12.000
アクターは、実行の単一のスレッドに分離することで、状態を同時アクセスから保護するために働きます。

00:15:12.000 --> 00:15:24.000
それが聞き覚えがあるなら、ビュー階層やレスポンダーチェーンなど、AppKitの状態のほとんどは、単一の実行スレッド、特にメインスレッドからもアクセスする必要があるためです。

00:15:24.000 --> 00:15:34.000
この制限はアクターモデルにうまく適合するので、メインスレッドからアクセスしなければならないタイプであるメインアクターの概念を導入しました。

00:15:34.000 --> 00:15:51.000
AppKitでは、NSView、ViewController、WindowController、Applicationのサブクラスを含むNSResponderと、NSCell、Alert、Document、DocumentControllerをMainActorsとして指定しました。

00:15:51.000 --> 00:15:59.000
MainActorで実行されているコードは、すでにメインスレッドにいることを知っているので、他のMainActorタイプのメソッドを自由に呼び出すことができます。

00:15:59.000 --> 00:16:09.000
ただし、MainActorで実行されていないコードは、MainActorのコンテキストでそのUI作業を実行するために、新しい非同期/待機機能を使用する必要があります。

00:16:09.000 --> 00:16:17.000
これをコンパイラレベルで強制することで、Swiftは並行性とUIコードを混在させる際のバグの一般的な原因を回避するのに役立ちます。

00:16:17.000 --> 00:16:21.000
Swiftの並行性ビデオは、この強力な新言語機能について深く掘り下げています。

00:16:21.000 --> 00:16:24.000
あなたはそれらを見逃したくありません。

00:16:24.000 --> 00:16:30.000
また、Swift 5.5の新機能には、AttributedStringの値型バージョンがあります。

00:16:30.000 --> 00:16:39.000
価値セマンティクスを提供することに加えて、タイプセーフな属性と、属性の範囲を列挙および操作するための優れたSwift人間工学も備えています。

00:16:39.000 --> 00:16:51.000
AppKitでAttributedStringを使用すると、テキスト描画システムに関連する属性に自動的にアクセスできます。前景色、段落スタイルなどです。

00:16:51.000 --> 00:17:00.000
Struct AttributedStringと参照型のNSAttributedStringの間で変換できるため、NSAttributedStringを使用するAPIと相互運用できます。

00:17:00.000 --> 00:17:06.000
「What's new in Foundation」ビデオでは、AttributedStringのデザインとその使用方法について詳しく説明します。

00:17:06.000 --> 00:17:11.000
最後のSwiftの機能強化は、NSViewsの更新の推進に関係しています。

00:17:11.000 --> 00:17:17.000
Swiftのプロパティラッパー機能を使用して、ビュープロパティに共通するボイラープレートを劇的に減らします。

00:17:17.000 --> 00:17:19.000
例を見てみましょう。例を見てみましょう。

00:17:19.000 --> 00:17:23.000
これは、一握りのプロパティを介して設定可能なカスタムビューです。

00:17:23.000 --> 00:17:38.000
そして、これは問題ないように見えますが、現実には、私たちのビューのプロパティ宣言には、多くのdidSetと余分な副作用が含まれている可能性がはるかに高いです。なぜなら、何かが変更されたときに再描画、またはレイアウト、または制約を更新する必要があるからです。

00:17:38.000 --> 00:17:40.000
さて、それは多くのボイラープレートです。

00:17:40.000 --> 00:17:46.000
そのため、このケースのためだけに新しいSwiftプロパティラッパーを作成することで、このシナリオをより良くしました。

00:17:46.000 --> 00:17:48.000
それは無効化と呼ばれています。

00:17:48.000 --> 00:17:57.000
NSViewの下にネストされており、ラップされたプロパティが変更されたときに無効にするビューの1つ以上の側面を指定できます。

00:17:57.000 --> 00:18:06.000
didSetとブラケットはすべて消えてしまうため、プロパティ自体の定義に集中しやすくなります。

00:18:06.000 --> 00:18:16.000
AppKitは、表示、レイアウト、制約、固有のコンテンツサイズ、および回復可能な状態など、いくつかの組み込みの無効化ケースを提供します。

00:18:16.000 --> 00:18:25.000
これらの無効化はビューでのみ意味をなすため、NSViewのサブクラスでのみ機能するようにプロパティラッパーを制約しました。

00:18:25.000 --> 00:18:29.000
また、値がEquatableに準拠していることも要求します。

00:18:29.000 --> 00:18:37.000
この適合性を使用して、潜在的に高価な再描画またはレイアウトパスを実行する前に、値の有意義な変更を確認します。

00:18:37.000 --> 00:18:46.000
カスタムをしたい場合は、NSViewInvalidatingプロトコルにタイプを適合させることで、独自の無効化を定義することもできます。

00:18:46.000 --> 00:18:49.000
最後に、ショートカット。

00:18:49.000 --> 00:18:56.000
macOS Montereyでは、ショートカットのフルパワーをMacにもたらすことに興奮しています。これには、ショートカットをAppKitアプリと統合することが含まれます。

00:18:56.000 --> 00:19:07.000
素晴らしいニュースは、アプリがサービスをサポートしている場合、すでにショートカットをサポートしており、ショートカットは今日のサービスにアクセスできるすべての同じ場所に表示されることです。

00:19:07.000 --> 00:19:10.000
この機能に慣れていない場合は、採用するのは本当に簡単です。

00:19:10.000 --> 00:19:16.000
AppKitは、レスポンダーチェーンをチェックすることで、どのショートカットが文脈的に適切かを決定します。

00:19:16.000 --> 00:19:23.000
各応答者は、各ショートカットで期待されるデータの種類を提供または受信できるかどうかを尋ねます。

00:19:23.000 --> 00:19:29.000
ほとんどの場合、統一型識別子に対応するペーストボード型を使用してこれを表現します。

00:19:29.000 --> 00:19:34.000
あなたがしなければならないのは、sendTypeとreturnTypeメソッドのvalidRequestorを実装することだけです。

00:19:34.000 --> 00:19:42.000
また、指定されたタイプを受け入れたり提供したりできる場合は、NSServicesMenuRequestorプロトコルに準拠したオブジェクトを返します。

00:19:42.000 --> 00:19:46.000
ほとんどの場合、そのプロトコルを直接実装してから自己を返すだけです。

00:19:46.000 --> 00:19:55.000
ショートカットが呼び出されると、ショートカットが入力と出力に使用する特別なペーストボードからデータを書き込むおよび/または読み込むための呼び出しが取得されます。

00:19:55.000 --> 00:19:56.000
そして、それだけです!

00:19:56.000 --> 00:19:59.000
アプリをショートカットと統合するのはとても簡単です。

00:19:59.000 --> 00:20:02.000
また、Siri IntentsをmacOSにもたらしました。

00:20:02.000 --> 00:20:06.000
XcodeでIntents Extensionを作成することで、Intentsを処理できるようになりました。

00:20:06.000 --> 00:20:13.000
または、メインアプリケーションからそれらを処理する必要がある場合は、アプリケーションデリゲートからインテントハンドラを返すことができます。

00:20:13.000 --> 00:20:21.000
アプリデリゲートで、application handlerFor intent:メソッドを実装し、処理できるインテントのハンドラーオブジェクトを返します。

00:20:21.000 --> 00:20:33.000
すべてのタイプのインテントには、返されたオブジェクトが準拠しなければならない独自のハンドラープロトコルがありますので、ハンドラーオブジェクトの実装の詳細については、インテントフレームワークのドキュメントを確認してください。

00:20:33.000 --> 00:20:37.000
この新しい情報がすべて揃ったので、次は何ですか?

00:20:37.000 --> 00:20:44.000
まず、コントロールティンティングやSFシンボル3などの機能が、アプリのデザイン強化にどのように役立つかを考えてください。

00:20:44.000 --> 00:20:52.000
次に、アプリがTextKitを使用してカスタムテキストエクスペリエンスを作成する場合は、「Meet TextKit 2」ビデオを見て、新しいAPIを試してみてください。

00:20:52.000 --> 00:21:00.000
TextKit 2でカスタムレイアウトや豊富なコンテンツを表現するのがいかに簡単かを気に入るはずです。

00:21:00.000 --> 00:21:08.000
アプリが並行性を管理する方法は、そのアーキテクチャの重要な部分であり、Swiftの新しい並行性機能は、この分野で大きな改善になります。

00:21:08.000 --> 00:21:16.000
今、async/awaitなどの機能が、アプリが同時ワークロードを管理する方法をどのように形成するかの計画を開始する時です。

00:21:16.000 --> 00:21:21.000
最後に、AppKitの自動化機能を採用して、アプリをショートカットに備えましょう。

00:21:21.000 --> 00:21:23.000
あなたの時間と注意に感謝します。

00:21:23.000 --> 00:21:26.000
macOS Montereyでこれらの素晴らしい機能強化をすべて楽しんでいただければ幸いです。

00:21:26.000 --> 23:59:59.000
♪

