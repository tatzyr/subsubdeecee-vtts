WEBVTT

00:00:00.000 --> 00:00:05.000
♪ベース音楽の演奏♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:12.000
フアン・ロドリゲス・クエラー:こんにちは、WWDCへようこそ。

00:00:12.000 --> 00:00:17.000
私の名前はJuan Rodriguez Cuellarで、AppleのGPUコンパイラエンジニアです。

00:00:17.000 --> 00:00:24.000
このセッションでは、メタルレイトレーシングAPIを強化するために今年追加した新機能について説明します。

00:00:24.000 --> 00:00:28.000
しかし、まず、レイトレーシングについて簡単にまとめましょう。

00:00:28.000 --> 00:00:35.000
レイトレーシングアプリケーションは、光線がシーンと相互作用するときに取る経路をトレースすることに基づいています。

00:00:35.000 --> 00:00:44.000
レイトレーシングは、オーディオ、物理シミュレーション、AIなどの多くの分野で適用されますが、主なアプリケーションの1つはフォトリアリスティックレンダリングです。

00:00:44.000 --> 00:00:55.000
レンダリングアプリケーションでは、レイトレーシングを使用して個々の光線をモデル化し、反射、柔らかい影、間接照明などの効果をシミュレートすることができます。

00:00:55.000 --> 00:00:58.000
それはレイトレーシングの一般的な定義にすぎません。

00:00:58.000 --> 00:01:01.000
それに対するメタルのアプローチについて話しましょう。

00:01:01.000 --> 00:01:03.000
コンピューティングカーネルから始めます。

00:01:03.000 --> 00:01:08.000
私たちのカーネルでは、シーンに放出される光線を生成します。

00:01:08.000 --> 00:01:17.000
次に、インターセクターと加速度構造を持つシーン内のジオメトリに対する交差について、これらの光線をテストします。

00:01:17.000 --> 00:01:26.000
各交点は、表面から跳ね返る光を表します。どのくらいの光が跳ね返り、どの方向に、物体がどのように見えるかを決定します。

00:01:26.000 --> 00:01:30.000
次に、各交差点の色を計算し、画像を更新します。

00:01:30.000 --> 00:01:38.000
このプロセスはシェーディングと呼ばれ、追加の光線を生成することができ、それらの光線も交差のためにテストされます。

00:01:38.000 --> 00:01:44.000
シーンの周りで跳ね返る光をシミュレートしたいのと同じくらい何度もこのプロセスを繰り返します。

00:01:44.000 --> 00:01:49.000
今年は、新機能を3つの主要な分野に焦点を当てました。

00:01:49.000 --> 00:01:57.000
まず、レンダリングパイプラインにレイトレーシングサポートを追加した方法について説明します。これにより、レイトレーシングとレンダリングを混在させることができます。

00:01:57.000 --> 00:02:04.000
次に、使いやすさと移植性に焦点を当てた新機能を紹介します。

00:02:04.000 --> 00:02:09.000
これらの機能により、メタルレイトレーシングAPIの使用が容易になります。

00:02:09.000 --> 00:02:17.000
最後に、よりリアルなコンテンツを作成するのに役立つ、今年追加したプロダクションレンダリング機能について説明します。

00:02:17.000 --> 00:02:21.000
レンダリングパイプラインからのレイトレーシングから始めましょう。

00:02:21.000 --> 00:02:27.000
単一のレンダリングパスを持つレンダリングの基本的なケースを考えてみましょう。

00:02:27.000 --> 00:02:35.000
レンダリングパイプラインからのレイトレーシングの新しいサポートにより、レンダリングにレイトレーシングを追加することが非常に簡単になります。

00:02:35.000 --> 00:02:45.000
ただし、このサポートがなければ、昨年のメタルレイトレーシングAPIでこのレンダリングにレイトレーシングを追加するには、コンピューティングパスを追加する必要があります。

00:02:45.000 --> 00:02:51.000
レンダリングされた画像を拡張するために、レンダリング後にそれを追加することから始めましょう。

00:02:51.000 --> 00:02:59.000
この余分なコンピューティングパスを追加することは、レイトレーシングに使用するコンピューティングパスのためにメモリにより多くの出力を書き込むことを意味します。

00:02:59.000 --> 00:03:09.000
さて、レンダリングパスの途中でレイトレーシングを使用して、ピクセルあたりのシャドーイングなどの値を計算したい場合はどうなりますか?

00:03:09.000 --> 00:03:15.000
これは、レンダリングを分割し、コンピューティングパスを導入する必要があることを意味します。

00:03:15.000 --> 00:03:29.000
これが何を意味するのかをもっと考えて、レイトレーシングへの入力としてピクセル位置と法線をメモリに書き出し、交差結果をおそらく数回読み返す必要があります。

00:03:29.000 --> 00:03:38.000
しかし、レンダリングステージからのレイトレーシングの新しいサポートにより、レンダリングパスを離れる必要はなく、出力をメモリに書き込むだけです。

00:03:38.000 --> 00:03:40.000
新しいAPIをどのように使用するか見てみましょう。

00:03:40.000 --> 00:03:45.000
レイトレーシング用のレンダリングパイプラインの準備は、コンピューティングパイプラインに似ています。

00:03:45.000 --> 00:03:51.000
加速度構造を構築し、カスタム交差関数を定義することから始めます。

00:03:51.000 --> 00:03:59.000
カスタム交差をサポートするには、交差関数テーブルが必要で、それを交差関数で埋める必要があります。

00:03:59.000 --> 00:04:02.000
この部分は、昨年のAPIと比較していくつかの違いがあります。

00:04:02.000 --> 00:04:05.000
それを行う方法を見ていきましょう。

00:04:05.000 --> 00:04:09.000
簡単な交差関数をいくつか考えてみましょう。

00:04:09.000 --> 00:04:19.000
ここには、球、円錐、または円錐などのオブジェクトを分析的に交差することを可能にするいくつかの機能があります。

00:04:19.000 --> 00:04:24.000
パイプラインを作成するときに、これらの関数を呼び出す可能性のあるリンク関数として追加します。

00:04:24.000 --> 00:04:30.000
この場合、パイプラインのフラグメント段階に追加します。

00:04:30.000 --> 00:04:38.000
関数を使用するには、パイプラインの状態とステージから交差関数テーブルを作成する必要があります。

00:04:38.000 --> 00:04:47.000
テーブルを取得したら、パイプラインの状態とステージから関数ハンドルを作成し、テーブルに入力できます。

00:04:47.000 --> 00:04:55.000
フラグメントステージの関数を指定すると、昨年導入したlinkedFunctionsオブジェクトが再利用されます。

00:04:55.000 --> 00:05:02.000
各ステージには、レンダリングパイプライン記述子に独自のlinkedFunctionsのセットがあります。

00:05:02.000 --> 00:05:09.000
交差関数テーブルの作成は、計算パイプラインで実行した場合とほぼ同じです。

00:05:09.000 --> 00:05:14.000
唯一の変更は、ステージ引数の追加です。

00:05:14.000 --> 00:05:19.000
テーブルに入力するには、関数ハンドルを作成します。

00:05:19.000 --> 00:05:27.000
繰り返しますが、ハンドルはステージに固有であるため、ハンドルを要求するときにステージを指定する必要があります。

00:05:27.000 --> 00:05:33.000
関数ハンドルを取得したら、関数テーブルに挿入するだけです。

00:05:33.000 --> 00:05:38.000
そして、レンダリングパイプラインで関数テーブルを準備するために必要なのはそれだけです。

00:05:38.000 --> 00:05:45.000
今、私たちは交差するためにこれまでに構築したすべてのものを使用する必要があります。

00:05:45.000 --> 00:05:47.000
実際の使用は簡単です。

00:05:47.000 --> 00:05:57.000
accelerationStructureと交差関数テーブルは、どちらもレンダリングエンコーダのバッファインデックスにバインドされています。

00:05:57.000 --> 00:06:06.000
シェーダーは、これらのリソースを使用して、コンピューティングカーネルと同じように光線とインターセクターを交差させることができます。

00:06:06.000 --> 00:06:13.000
レイトレーシング用のパイプラインの準備方法の詳細については、昨年のプレゼンテーションを参照してください。

00:06:13.000 --> 00:06:22.000
その講演では、加速度構造の構築、ファンクションテーブルの作成、シェーディング言語でのインターセクターの使用について学びます。

00:06:22.000 --> 00:06:39.000
レンダリングパイプラインからのレイトレーシングサポートにより、単一のレンダリングパス内にレイトレーシングを追加し、ハイブリッドレンダリングでレイトレーシングとラスタライズを混合し、Apple Siliconのタイル機能などの最適化を活用するなど、さらに多くの機会への扉を開いています。

00:06:39.000 --> 00:06:49.000
実際、WWDC 2019での「Modern Rendering in Metal」セッションでデモしたサンプルアプリにレイトレーシングをまもなく追加する予定です。

00:06:49.000 --> 00:06:56.000
レンダリングパイプラインからのレイトレーシングを使用すると、コードを更新してタイル関数を使用してタイルメモリにすべてを保持できます。

00:06:56.000 --> 00:07:03.000
これの詳細については、今年の「メタルレイトレーシングでハイブリッドレンダリングを探索する」プレゼンテーションを参照してください。

00:07:03.000 --> 00:07:11.000
次に、メタルレイトレーシングAPIの使いやすさと移植性を向上させるために、今年追加した新機能を紹介したいと思います。

00:07:11.000 --> 00:07:20.000
これらの機能は、メタルレイトレーシングをより簡単に使用できるだけでなく、他のレイトレーシングAPIからの移植性も提供します。

00:07:20.000 --> 00:07:23.000
これらの新機能の1つは、交差クエリです。

00:07:23.000 --> 00:07:29.000
交差クエリを使用すると、交差プロセスをより詳細に制御できます。

00:07:29.000 --> 00:07:36.000
交差クエリは、インターセクターがオーバーヘッドを作成できる単純なユースケースを対象としています。

00:07:36.000 --> 00:07:44.000
これは、インラインカスタム交差テストを実行するオプションを提供する加速構造を横断する新しい方法です。

00:07:44.000 --> 00:07:50.000
昨年のインターセクターを使用して、現在カスタム交差点をどのように処理しているかを見てみましょう。

00:07:50.000 --> 00:08:06.000
昨年のメタルプレゼンテーションによるレイトレーシングのアルファテストの例に戻ると、チェーンと葉で見られるように、アルファテストを使用してシーンに多くの幾何学的ディテールを追加する方法を実証しました。

00:08:06.000 --> 00:08:16.000
また、三角形の交差関数を使用してインターセクターをカスタマイズすることで、アルファテストを実装するのがいかに簡単かを学びました。

00:08:16.000 --> 00:08:27.000
この三角形の交差関数内のロジックは、光線が加速度構造を横断する際に交差を承認または拒否する責任があります。

00:08:27.000 --> 00:08:38.000
この場合、テストロジックは最初の交差を拒否しますが、不透明な表面が交差しているため、2番目の交差を受け入れます。

00:08:38.000 --> 00:08:43.000
交差関数がどのように使用されるか見てみましょう。

00:08:43.000 --> 00:08:54.000
Intersector を使用する場合、intersect() を呼び出すと、加速度構造を横断して交差点を見つけ、intersection_result を埋めます。

00:08:54.000 --> 00:09:02.000
インターセクター内では、潜在的な交点が見つかるたびに交差関数が呼び出されます。

00:09:02.000 --> 00:09:08.000
そして、交差は、交差関数ロジックに基づいて受け入れられるか拒否されます。

00:09:08.000 --> 00:09:21.000
これは、パフォーマンスと利便性の両方があるため、インターセクターを使用した優れたプログラミングモデルですが、新しい交差関数を作成してパイプラインにリンクする必要があります。

00:09:21.000 --> 00:09:32.000
アルファテストロジックの場合と同様に、交差関数内のロジックが数行のコードしかない場合があります。

00:09:32.000 --> 00:09:38.000
これは、アルファテストを行うためのロジックを含む交差関数です。

00:09:38.000 --> 00:09:44.000
交差クエリを使用すると、この交差関数を必要とせずに、このロジックをインラインに配置できます。

00:09:44.000 --> 00:09:47.000
方法は次のとおりです。

00:09:47.000 --> 00:10:01.000
交差クエリでは、交差プロセスを開始すると、レイは加速構造を横断し、クエリオブジェクトにはトラバーサルの状態と結果が含まれます。

00:10:01.000 --> 00:10:12.000
レイがカスタムプリミティブまたは非不透明な三角形と交差するたびに、コントロールがシェーダーに返され、交差候補を評価します。

00:10:12.000 --> 00:10:24.000
現在の候補者がカスタム交差ロジックに合格した場合は、現在のコミットされた交差を更新し、交差プロセスを続行することをコミットします。

00:10:24.000 --> 00:10:31.000
一方、候補者がカスタム交差ロジックに失敗した場合は、無視して続行できます。

00:10:31.000 --> 00:10:36.000
交差クエリを使用してアルファテストを行うためのコードをお見せしましょう。

00:10:36.000 --> 00:10:39.000
まず、トラバーサルを開始します。

00:10:39.000 --> 00:10:45.000
すべての候補の交差点を評価するために、次にループすることに注意してください。

00:10:45.000 --> 00:10:51.000
次に、候補者のタイプを確認することから始めて、各候補者を評価します。

00:10:51.000 --> 00:10:57.000
アルファテストの例では、三角形タイプの交点に興味があります。

00:10:57.000 --> 00:11:03.000
タイプを確認した後、候補者に関するいくつかの交差情報を照会したいと思うでしょう。

00:11:03.000 --> 00:11:11.000
現在インライン化されているアルファテストロジックで必要な情報について3つのクエリを実行します。

00:11:11.000 --> 00:11:20.000
最後に、候補交差がアルファテストに合格した場合、現在のコミットされた交差になるようにコミットします。

00:11:20.000 --> 00:11:31.000
これまでは、候補交差点を評価する加速構造全体を横断し、アルファテストロジックに合格した交差点をコミットしています。

00:11:31.000 --> 00:11:38.000
次に、シェーディングを行うには、コミットされた交差点情報を照会する必要があります。

00:11:38.000 --> 00:11:41.000
まず、コミットされたタイプを照会します。

00:11:41.000 --> 00:11:53.000
候補交差点のいずれもコミットされた交差点になるための条件を満たしていない場合、コミットされたタイプはnoneになります。これは、現在のレイが見逃したことを意味します。

00:11:53.000 --> 00:12:05.000
一方、コミットされた交差点がある場合は、交差点タイプに適用される交差点に関する情報を照会し、シェーディングに使用することをお勧めします。

00:12:05.000 --> 00:12:10.000
交差クエリを使用してアルファテストを実行するために必要なコードはすべてです。

00:12:10.000 --> 00:12:21.000
交差クエリの導入とパイプラインをレンダリングするためのインターセクターの導入により、メタルレイトレーシングをアプリに導入し始める機会が増えています。

00:12:21.000 --> 00:12:29.000
インターセクターオブジェクトと交差クエリのどちらかを選択する際に考慮すべきことがいくつかあります。

00:12:29.000 --> 00:12:38.000
まず、コンピューティングでインターセクターを使用するなど、既存のコードがあるかどうか、そのコードを移植する計画を検討してください。

00:12:38.000 --> 00:12:46.000
他のAPIからの既存のクエリコードがある場合、交差クエリはそのコードを移植するのに役立ちます。

00:12:46.000 --> 00:12:51.000
次に、カスタム交差点の処理の複雑さがあります。

00:12:51.000 --> 00:13:02.000
インターセクターには交差関数とテーブルが必要であり、交差クエリを使用してカスタム交差を自分で処理する方が簡単かもしれません。

00:13:02.000 --> 00:13:04.000
最後の質問はパフォーマンスです。

00:13:04.000 --> 00:13:21.000
より単純なケースでは、交差クエリはレイトレーシング用のパイプラインを構築する際のオーバーヘッドを回避できますが、カスタム交差処理では、トラバーサル中にコードに戻る必要があり、ユースケースに応じてパフォーマンスに影響を与える可能性があります。

00:13:21.000 --> 00:13:26.000
また、複数のクエリオブジェクトを使用すると、より多くのメモリが必要になります。

00:13:26.000 --> 00:13:34.000
一方、インターセクターは、すべての交差作業をカプセル化することで、より複雑なケースをサポートできます。

00:13:34.000 --> 00:13:41.000
機会があれば、両方のソリューションのパフォーマンスを比較することをお勧めします。

00:13:41.000 --> 00:13:43.000
それはすべて交差クエリについてです。

00:13:43.000 --> 00:13:46.000
では、他の新機能に移りましょう。

00:13:46.000 --> 00:13:52.000
次に説明する2つの機能は、ユーザーインスタンスIDとインスタンス変換です。

00:13:52.000 --> 00:14:01.000
これらの機能は、アクセラレーション構造により多くの情報を追加し、すでにそこにあるより多くのデータにアクセスするのに役立ちます。

00:14:01.000 --> 00:14:03.000
これが、これらが本当に便利な機能だと思う理由です。

00:14:03.000 --> 00:14:11.000
昨年のプレゼンテーションのサンプルコードを振り返ってみると、カーネルボックスの複数のインスタンスがあります。

00:14:11.000 --> 00:14:20.000
この下には、インスタンスに到達するまで分岐するノードのセットを持つインスタンスアクセラレーション構造があります。

00:14:20.000 --> 00:14:27.000
これらのインスタンスのうち2つを見ると、それらはインスタンスアクセラレーション構造の最低レベルにあります。

00:14:27.000 --> 00:14:35.000
現在、これらのインスタンスの1つを交差させると、交差結果からシステムのインスタンスIDのみを取得します。

00:14:35.000 --> 00:14:44.000
これにより、独自のデータテーブルを維持できますが、加速構造に公開できるデータがあります。

00:14:44.000 --> 00:14:48.000
まず、ユーザー定義のインスタンスIDについて話しましょう。

00:14:48.000 --> 00:14:58.000
この機能を使用すると、インスタンスごとにカスタム32ビット値を指定し、交差結果の一部としてこの値を取得できます。

00:14:58.000 --> 00:15:06.000
これは、独自のデータ構造にインデックスを作成するのに本当に便利ですが、カスタムデータをエンコードするためにも使用できます。

00:15:06.000 --> 00:15:13.000
たとえば、ここではユーザーIDを使用して、各インスタンスのカスタムカラーをエンコードしています。

00:15:13.000 --> 00:15:19.000
追加の資料情報を調べる必要がなく、より簡単な反射にこれを使用できます。

00:15:19.000 --> 00:15:23.000
これはほんの一例ですが、機会は無限です。

00:15:23.000 --> 00:15:31.000
インスタンスごとのマテリアルIDやインスタンスごとのフラグなど、どのようにエンコードしたいかがわかります。

00:15:31.000 --> 00:15:39.000
これらのIDを指定するために使用されるインスタンス記述子タイプの拡張バージョンを作成しました。

00:15:39.000 --> 00:15:48.000
インスタンスアクセラレーション構造記述子で使用している記述子のタイプを必ず指定してください。

00:15:48.000 --> 00:15:59.000
シェーディング言語では、現在のユーザーインスタンスIDの値は、インスタンスタグとの交差関数への入力として使用できます。

00:15:59.000 --> 00:16:09.000
交差後の値を取得するには、インターセクターオブジェクトを使用する場合、ユーザー定義のインスタンスIDが交差結果から利用できます。

00:16:09.000 --> 00:16:21.000
また、交差クエリオブジェクトを使用する場合、候補とコミットされた交差の両方のユーザー定義のインスタンスIDにアクセスするための対応するクエリがあります。

00:16:21.000 --> 00:16:28.000
ユーザーインスタンスIDと同様に、インスタンス変換マトリックスにアクセスするためのサポートを追加しました。

00:16:28.000 --> 00:16:37.000
このデータはすでにインスタンス記述子で指定されており、アクセラレーション構造に格納されています。

00:16:37.000 --> 00:16:42.000
今年は、シェーディング言語からこれらの行列を公開しました。

00:16:42.000 --> 00:16:51.000
Instancingタグとworld_space_dataタグを適用すると、交差関数のインスタンス変換にアクセスできます。

00:16:51.000 --> 00:17:03.000
同様に、インスタンス変換は、instancingタグとworld_space_dataタグを持つインターセクタを使用する場合、交差結果で提供されます。

00:17:03.000 --> 00:17:14.000
インスタンシングタグで交差クエリを使用する場合、候補とコミットされた交差の両方のインスタンス変換にアクセスするための対応するクエリがあります。

00:17:14.000 --> 00:17:23.000
要約すると、今年は3つの新機能を導入することで、メタルレイトレーシングAPIの使いやすさと移植性を向上させています。

00:17:23.000 --> 00:17:32.000
交差クエリは、交差プロセスをより詳細に制御できるインターセクターの代替手段として提供されます。

00:17:32.000 --> 00:17:46.000
また、ユーザーインスタンスIDとインスタンス変換機能の導入により、コード内の外部マッピングを処理するのではなく、アクセラレーション構造からデータにアクセスする機能を提供します。

00:17:46.000 --> 00:17:55.000
さらに、これら3つの機能は、他のレイトレーシングAPIからの移植性を提供し、クロスプラットフォームの開発を容易にします。

00:17:55.000 --> 00:18:05.000
これまでのセッションでは、レンダリングパイプラインでのレイトレーシングの新しいサポートと、今年追加したさまざまなユーザビリティとポータビリティ機能について話しました。

00:18:05.000 --> 00:18:11.000
さて、プロダクションレンダリングを強化するために導入している機能をお見せしましょう。

00:18:11.000 --> 00:18:20.000
メタルレイトレーシングAPIが昨年導入されて以来、人々はいくつかの素晴らしい高品質のコンテンツをレンダリングするためにそれを使用しています。

00:18:20.000 --> 00:18:26.000
今年は、より良いコンテンツをレンダリングできるように、2つの新機能を追加しました。

00:18:26.000 --> 00:18:29.000
拡張された制限から始めましょう。

00:18:29.000 --> 00:18:41.000
メタルレイトレーシングAPIをリリースして以来、一部のユーザーは、特に生産規模のユースケースで、加速構造の内部限界に達し始めています。

00:18:41.000 --> 00:18:48.000
そのため、さらに大きなシーンをサポートするために、拡張リミットモードのサポートを追加しています。

00:18:48.000 --> 00:18:57.000
昨年、典型的なシーンサイズでパフォーマンスを優先するために、加速構造サイズのバランスをとるためにこれらの制限を選択しました。

00:18:57.000 --> 00:19:06.000
この機能をオンにするには潜在的なパフォーマンスのトレードオフがあるため、どのモードがアプリケーションに最適かを判断する必要があります。

00:19:06.000 --> 00:19:18.000
拡張リミットモードでは、プリミティブ、ジオメトリ、インスタンスの数、およびインスタンスのフィルタリングに使用されるマスクのサイズの制限が増加します。

00:19:18.000 --> 00:19:25.000
オンにするには、加速度構造を構築するときに、まず拡張制限モードを指定します。

00:19:25.000 --> 00:19:32.000
次に、シェーディング言語でインターセクターオブジェクトのextended_limitsタグを指定します。

00:19:32.000 --> 00:19:36.000
拡張制限をオンにするために必要なのはそれだけです!

00:19:36.000 --> 00:19:39.000
次に、動きについて話しましょう。

00:19:39.000 --> 00:19:45.000
コンピュータグラフィックスでは、カメラの露出が瞬間的であると仮定することがよくあります。

00:19:45.000 --> 00:19:52.000
しかし、実生活では、カメラの露出はゼロ以外の期間続きます。

00:19:52.000 --> 00:19:58.000
その間に物体がカメラに対して相対的に動くと、画像がぼやけて見えます。

00:19:58.000 --> 00:20:09.000
この極端な例では、中央の人は、他の誰もが動いている間、露出の間ずっとじっと立っていて、ぼやけています。

00:20:09.000 --> 00:20:16.000
この効果は、コンピュータで生成された画像をより現実的に見せるのに大いに役立ちます。

00:20:16.000 --> 00:20:28.000
この例では、球はいくつかのフレームにわたってアニメーション化されますが、各フレームは依然として瞬間的な露出であり、不安定なアニメーションになります。

00:20:28.000 --> 00:20:36.000
モーションAPIを使用すると、ゼロ以外の時間持続するカメラの露出をシミュレートできます。

00:20:36.000 --> 00:20:41.000
これにより、より滑らかでリアルなアニメーションになります。

00:20:41.000 --> 00:20:50.000
ビデオを凍結すると、実際のカメラのように球の境界が動きの方向にぼやけていることがわかります。

00:20:50.000 --> 00:20:56.000
ゲームのようなリアルタイムアプリケーションは、多くの場合、画面空間でこの効果を近似します。

00:20:56.000 --> 00:21:06.000
しかし、レイトレーシングは、物理的に正確なモーションブラーをシミュレートすることを可能にし、影や反射などの間接的な効果にも拡張します。

00:21:06.000 --> 00:21:11.000
モーションブラーバージョンがどのようにレンダリングされたかを見てみましょう。

00:21:11.000 --> 00:21:15.000
モーションブラーは、レイトレーシングの簡単な拡張です。

00:21:15.000 --> 00:21:24.000
ほとんどのレイトレーシングアプリケーションは、間接照明の入射光方向などの物理的な寸法をすでにランダムにサンプリングしています。

00:21:24.000 --> 00:21:31.000
モーションブラーを追加するには、各光線にランダムな時間を選択することもできます。

00:21:31.000 --> 00:21:37.000
金属は、各光線に関連付けられた時点と一致するようにシーンと交差します。

00:21:37.000 --> 00:21:42.000
例えば、この光線はこのようなシーンを見るでしょう。

00:21:42.000 --> 00:21:46.000
別の光線はこのようなシーンを見るでしょう。

00:21:46.000 --> 00:21:52.000
ますます多くのサンプルを蓄積するにつれて、モーションブラード画像に収束し始めます。

00:21:52.000 --> 00:21:58.000
実際には、カスタム交差関数を使用して、今日すでにこれを実装することができます。

00:21:58.000 --> 00:22:08.000
露出全体にわたって各プリミティブのバウンディングボックスを計算し、これらのバウンディングボックスを使用して加速構造を構築できます。

00:22:08.000 --> 00:22:21.000
しかし、これは非効率的です。バウンディングボックスは非常に大きく、一部の光線はプリミティブとの交差をチェックする必要があるため、実際には交差することはありません。

00:22:21.000 --> 00:22:30.000
代わりに、このようなケースを効率的に処理するように設計されたモーションブラーに対するMetalの組み込みサポートを使用できます。

00:22:30.000 --> 00:22:38.000
最初にする必要があるのは、メタルシェーディング言語コードの各光線にランダムな時間を関連付けることです。

00:22:38.000 --> 00:22:47.000
まず、暴露間隔内でランダムな時間を生成し、それをインターセクターに渡します。

00:22:47.000 --> 00:22:54.000
次に行う必要があるのは、アニメーションジオメトリをMetalに提供することです。

00:22:54.000 --> 00:22:59.000
これは、キーフレームアニメーションと呼ばれる一般的なアニメーション方法を使用して行います。

00:22:59.000 --> 00:23:06.000
アニメーションは、キーフレームと呼ばれる重要な時点でボールをモデル化することによって作成されます。

00:23:06.000 --> 00:23:14.000
これらのキーフレームは、アニメーションの開始と終了の間に均一に分散されています。

00:23:14.000 --> 00:23:23.000
光線が加速度構造を横断すると、時間値に基づいて任意のキーフレームからデータを取得できます。

00:23:23.000 --> 00:23:33.000
たとえば、レイAは、その時間がたまたまキーフレーム11と一致するため、キーフレーム11でモデル化されたシーンを見るでしょう。

00:23:33.000 --> 00:23:38.000
対照的に、レイBの時間はキーフレーム3と4の間です。

00:23:38.000 --> 00:23:46.000
したがって、2つのキーフレームのジオメトリはレイBに補間されます。

00:23:46.000 --> 00:23:50.000
モーションはインスタンスレベルとプリミティブレベルの両方でサポートされています。

00:23:50.000 --> 00:23:55.000
インスタンスアニメーションは、オブジェクト全体を厳密に変換するために使用できます。

00:23:55.000 --> 00:24:00.000
これはプリミティブアニメーションよりも安いですが、オブジェクトを変形させません。

00:24:00.000 --> 00:24:09.000
一方、原始的なアニメーションはより高価ですが、スキンキャラクターアニメーションのようなものに使用できます。

00:24:09.000 --> 00:24:16.000
インスタンスアニメーションとプリミティブアニメーションの両方がキーフレームアニメーションに基づいていることに注意してください。

00:24:16.000 --> 00:24:20.000
まず、インスタンスモーションについて話しましょう。

00:24:20.000 --> 00:24:27.000
インスタンスの加速構造では、各インスタンスは変換行列に関連付けられています。

00:24:27.000 --> 00:24:31.000
このマトリックスは、ジオメトリをシーンのどこに配置するかを説明しています。

00:24:31.000 --> 00:24:40.000
この例では、2つの原始的な加速度構造があります。1つは球体用、もう1つは静的幾何学用です。

00:24:40.000 --> 00:24:45.000
各プリミティブアクセラレーション構造には単一のインスタンスがあります。

00:24:45.000 --> 00:24:55.000
球体をアニメーション化するために、アニメーションの開始点と終了点を表す2つの変換行列を提供します。

00:24:55.000 --> 00:25:01.000
次に、金属は各光線の時間パラメータに基づいてこれら2つの行列を補間します。

00:25:01.000 --> 00:25:12.000
これは2つのキーフレームを使用する特定の例ですが、Metalは任意の数のキーフレームをサポートしていることに注意してください。

00:25:12.000 --> 00:25:18.000
加速度構造記述子を使用してこれらの行列を提供します。

00:25:18.000 --> 00:25:23.000
標準のMetalインスタンス記述子には、単一の変換行列の余地しかありません。

00:25:23.000 --> 00:25:28.000
代わりに、新しいモーションインスタンス記述子を使用します。

00:25:28.000 --> 00:25:35.000
この記述子を使用すると、変換行列は別のバッファに格納されます。

00:25:35.000 --> 00:25:45.000
インスタンス記述子には、変換バッファ内の変換行列の範囲を表す開始インデックスとカウントが含まれます。

00:25:45.000 --> 00:25:49.000
各行列は単一のキーフレームを表します。

00:25:49.000 --> 00:25:56.000
新しいモーションインスタンス記述子タイプでインスタンス記述子を設定する方法を見てみましょう。

00:25:56.000 --> 00:26:01.000
通常のインスタンスアクセラレーション構造記述子を作成することから始めます。

00:26:01.000 --> 00:26:07.000
次に、新しいモーションインスタンス記述子タイプを使用することを指定します。

00:26:07.000 --> 00:26:15.000
次に、モーションインスタンス記述子を含むinstanceDescriptorBufferを指定します。

00:26:15.000 --> 00:26:23.000
最後に、各キーフレームの頂点バッファを含むtransformsBufferをバインドする必要があります。

00:26:23.000 --> 00:26:33.000
残りのプロパティは、他のインスタンスアクセラレーション構造と同じであり、他のアクセラレーション構造と同様に構築できます。

00:26:33.000 --> 00:26:41.000
Instance_motionタグを指定するという、シェーディング言語の変更を1つだけ行う必要があります。

00:26:41.000 --> 00:26:48.000
これは、インターセクターにインスタンス運動を伴う加速構造を期待するように指示します。

00:26:48.000 --> 00:26:52.000
そして、インスタンスモーションを設定するために必要なのはそれだけです。

00:26:52.000 --> 00:26:56.000
次に、原始的な動きについて話しましょう。

00:26:56.000 --> 00:27:05.000
プリミティブモーションでは、各プリミティブは別々に移動できます。つまり、スキンキャラクターアニメーションのようなものに使用できます。

00:27:05.000 --> 00:27:13.000
キーフレームごとに個別の3Dモデルを提供する必要があり、Metalはそれらの間で補間することを忘れないでください。

00:27:13.000 --> 00:27:17.000
各キーフレームの頂点データを提供する必要があります。

00:27:17.000 --> 00:27:20.000
これを設定する方法を見てみましょう。 

00:27:20.000 --> 00:27:26.000
まず、各キーフレームの頂点バッファを配列に収集することから始めます。

00:27:26.000 --> 00:27:32.000
MTLMotionKeyframeDataオブジェクトを使用すると、バッファとオフセットを指定できます。

00:27:32.000 --> 00:27:37.000
それを使用して、各キーフレームの頂点バッファを指定します。

00:27:37.000 --> 00:27:42.000
次に、モーショントライアングルジオメトリ記述子を作成します。

00:27:42.000 --> 00:27:48.000
これは、わずかに異なるタイプを使用することを除いて、他のジオメトリ記述子を作成するのと同じです。

00:27:48.000 --> 00:27:56.000
そして、単一の頂点バッファを提供する代わりに、頂点バッファの配列を提供します。

00:27:56.000 --> 00:28:02.000
最後に、通常のプリミティブ加速度構造記述子を作成します。

00:28:02.000 --> 00:28:06.000
次に、geometryDescriptorを提供します。

00:28:06.000 --> 00:28:10.000
次に、キーフレームの数を指定します。

00:28:10.000 --> 00:28:19.000
インスタンスモーションと同様に、primitive_motionタグを指定するには、シェーディング言語を少し変更する必要があります。

00:28:19.000 --> 00:28:22.000
そして、それは私たちが原始的な動きを設定するために必要なすべてです!

00:28:22.000 --> 00:28:30.000
さらにダイナミックなシーンでは、実際に両方のタイプのアニメーションを同時に使用できることを覚えておいてください。

00:28:30.000 --> 00:28:34.000
次に、このすべてのアクションを見てみましょう! !

00:28:34.000 --> 00:28:39.000
これは、高度なコンテンツチームによって作成されたパストレースレンダリングです。

00:28:39.000 --> 00:28:45.000
このビデオは、AMD Radeon Pro Vega II GPUを搭載したMac Proでレンダリングされました。

00:28:45.000 --> 00:28:54.000
忍者のキャラクターは、各プリミティブが別々に動くことを可能にするスキン骨格アニメーション技術を使用してアニメーション化されました。

00:28:54.000 --> 00:29:02.000
各フレームは、プリミティブモーションAPIを使用して取得した256のランダムなタイミングのサンプルを組み合わせてレンダリングされました。

00:29:02.000 --> 00:29:06.000
違いをより明確に見るために、それを遅くすることができます。

00:29:06.000 --> 00:29:13.000
左側のバージョンにはモーションブラーはありませんが、右側のバージョンにはモーションブラーがありません。

00:29:13.000 --> 00:29:18.000
また、長時間露光をシミュレートするために、露光時間をさらに増やすことができます。

00:29:18.000 --> 00:29:25.000
モーションブラーはリアリズムに大きな違いを生むことができ、新しいモーションAPIで簡単に追加できるようになりました。

00:29:25.000 --> 00:29:27.000
だから、それは動きのためです。

00:29:27.000 --> 00:29:29.000
この講演を見てくれてありがとう。

00:29:29.000 --> 00:29:36.000
私たちは、アプリを強化するために必要なツールを提供するために、メタルレイトレーシングAPIに多くの労力を費やしてきました。

00:29:36.000 --> 00:29:40.000
私たちはあなたがそれで作成する素晴らしいコンテンツを見るのが待ちきれません。

00:29:40.000 --> 00:29:44.000
ありがとう、そして素晴らしいWWDCを!

00:29:44.000 --> 23:59:59.000
♪

