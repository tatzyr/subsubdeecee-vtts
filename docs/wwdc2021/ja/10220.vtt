WEBVTT

00:00:01.000 --> 00:00:21.000
こんにちは、私の名前はPaul Borokhovで、SwiftUI Macチームのエンジニアです。

00:00:21.000 --> 00:00:29.000
後で同僚のケイト・コノネンコがローカリゼーションチームに加わり、SwiftUIアプリをローカライズする方法について話します。

00:00:29.000 --> 00:00:34.000
このプロセスを説明するために、以前に見たことのあるFrutaサンプルアプリを使用します。

00:00:34.000 --> 00:00:42.000
このアプリケーションでは、スムージーのメニューを閲覧したり、注文したり、レシピを見て自宅で作ることができます。

00:00:42.000 --> 00:00:55.000
この講演では、私とケイトの両方の母国語であり、独自のアプリで使用する必要があるさまざまなローカリゼーションのベストプラクティスの良いショーケースであるため、ロシア語のローカリゼーションをアプリに追加します。

00:00:55.000 --> 00:01:02.000
SwiftUIで文字列がどのようにローカライズされているか、そして一般的な設計上の落とし穴を避けるのがいかに簡単かについて、いくつかの基礎について説明します。

00:01:02.000 --> 00:01:10.000
文字列とデータのスタイルとフォーマットのテクニックについて議論し、キーボードショートカットのローカリゼーションのいくつかの改善について説明します。

00:01:10.000 --> 00:01:19.000
最後に、ケイトは、アプリのローカライズをこれまで以上に簡単にするために、Xcodeのローカリゼーションワークフローに対する改善のデモを行います。

00:01:19.000 --> 00:01:29.000
アプリケーションをローカライズする上で最も重要な部分の1つは、UIのさまざまな部分の文字列が翻訳者に公開され、実行時に正しくレンダリングされるようにすることです。

00:01:29.000 --> 00:01:37.000
SwiftUIは、文字列リテラルでテキストを使用すると、メインバンドルでローカライズされた文字列ルックアップを自動的に実行するため、これを簡単にします。

00:01:37.000 --> 00:01:45.000
この例では、ロシア語の文字列ファイルの翻訳に基づいて、実行時に自動的にローカライズされる完了ボタンがあります。

00:01:45.000 --> 00:01:56.000
これは文字列補間でも機能するため、変数を文字列に埋め込むことができ、エクスポートされたローカライズ可能な文字列ファイルとカタログの書式指定子に自動的に変換されます。

00:01:56.000 --> 00:02:05.000
Xcode 13の新機能では、文字列に渡される変数の型に基づいて、書式指定子タイプを自動的に推測するようになりました。

00:02:05.000 --> 00:02:10.000
テキストは、より多くの制御が必要な場合に備えて、テーブル名とバンドルの追加のオプション引数を受け入れます。

00:02:10.000 --> 00:02:17.000
この例では、成分に関連するすべての文字列を「成分」と呼ばれる別の表に配置しました。

00:02:17.000 --> 00:02:28.000
スムージーの実際の成分とは別に、スムージービューとレシピビューの2つの異なるコンテキストに「成分」という言葉の2つのバリエーションをこの文字列表に配置しました。

00:02:28.000 --> 00:02:34.000
ご覧のとおり、ロシア語はこれら2つの単語を文脈に基づいて異なる方法で翻訳する必要があるため、これをしました。

00:02:34.000 --> 00:02:39.000
文字列の整理方法の詳細については、「ローカライズされた文字列を合理化する」トークで学ぶことができます。

00:02:39.000 --> 00:02:45.000
テキストの最初の引数はLocalizedStringKey型であるため、これはすべて機能します。

00:02:45.000 --> 00:02:54.000
文字列リテラルを受け入れるカスタムビューとメソッドがある場合は、Stringの代わりにこのタイプを使用してローカライズ可能にすることができます。

00:02:54.000 --> 00:03:05.000
このようにして、これらのビューと関数に引数として渡されるリテラルは、Xcodeローカリゼーションエクスポートプロセス中に自動的に抽出され、実行時にバンドルからロードされます。

00:03:05.000 --> 00:03:11.000
ボタンの例で先に見た別のアプローチは、ビューが代わりにテキスト引数を受け入れるようにすることです。

00:03:11.000 --> 00:03:19.000
LocalizedStringKeyを使用すると、プレビュープロバイダーで環境のロケールを指定することで、一度に複数のロケールをプレビューすることもできます。

00:03:19.000 --> 00:03:29.000
NSLocalizedStringでロードされたものを含め、すべてのローカライズされた文字列をプレビューしたい場合は、ケイトが後で示すように、スキームエディタで言語を変更できます。

00:03:29.000 --> 00:03:36.000
Xcode 13の新機能で、ローカリゼーションのためにプロジェクトをエクスポートすると、実際にすべてのターゲットを構築して、ローカライズ可能な文字列を見つけることができます。

00:03:36.000 --> 00:03:43.000
これが実際に意味することは、Xcodeがローカライズ可能なコンテンツを見つけ、ローカリゼーションのためにそれを抽出するというはるかに良い仕事をすることができるということです。

00:03:43.000 --> 00:03:47.000
だから、複数行の文字列を持つコードがあると想像してみてください。

00:03:47.000 --> 00:03:54.000
コンパイラがローカライズされたコンテンツの抽出に使用されるようになったため、この複数行の文字列リテラルは正しく解析されます。

00:03:54.000 --> 00:04:01.000
それでは、SwiftUIがローカリゼーションに優しいレイアウトでアプリを簡単に構築する方法を見てみましょう。

00:04:01.000 --> 00:04:12.000
文字列ルックアップと同様に、SwiftUIが提供するデフォルトのレイアウト動作はローカリゼーションを念頭に置いて設計されており、ほとんどの場合、追加の労力は必要ありません。

00:04:12.000 --> 00:04:20.000
たとえば、必要に応じて、テキスト付きのコントロールは、長いラベルを持つ言語でクリップしたり切り捨てたりしないようにラップします。

00:04:20.000 --> 00:04:26.000
この場合、スムージーの名前は長いため、ロシア語で2行目にラップされます。

00:04:26.000 --> 00:04:30.000
レイアウトは、右から左の言語でも自動的に反転されます。

00:04:30.000 --> 00:04:37.000
スクリーンショットでは、テーブルセルのレイアウトが反転され、タブバーのシンボルも必要に応じてミラーリングされていることがわかります。

00:04:37.000 --> 00:04:49.000
また、デフォルトから逸脱するように何かをカスタマイズする必要がある場合でも、私たちが提供するオプションは、VStacksで左ではなく先頭のアライメントを提供するなど、ローカリゼーションに優しいソリューションを案内します。

00:04:49.000 --> 00:04:56.000
次に、アプリを構築する際に、UIに表示されるローカライズされたテキストのスタイルを設定する必要があるかもしれません。

00:04:56.000 --> 00:05:02.000
これを簡単にするために、マークダウンを使用してローカライズ可能な文字列をスタイル設定する機能を導入しました。

00:05:02.000 --> 00:05:11.000
これにより、ローカライズされた文字列へのスタイリングの適用が大幅に簡素化され、翻訳者は自分の言語に賢明なスタイリングを適用することができます。

00:05:11.000 --> 00:05:23.000
たとえば、アラビア語にはイタリック体の概念がないため、英語の文字列に強調を使用しても、翻訳者は翻訳に強い強調などの異なる処理を使用できます。

00:05:23.000 --> 00:05:31.000
この場合、私たちのロシア語翻訳者は、元の英語の説明の意図と一致するように、文字列内の最も関連性の高い単語の周りにマークアップを適用することができました。

00:05:31.000 --> 00:05:41.000
そして、このサポートは基礎に存在しますが、SwiftUIは、スタイル化された文字列を表示用のテキストに直接渡すだけで、特に簡単に活用できます。

00:05:41.000 --> 00:05:48.000
「What's New in Foundation」とSwiftUIトークをチェックすることで、テキストのスタイリングについて詳しく知ることができます。

00:05:48.000 --> 00:05:55.000
アプリで遭遇するもう1つの一般的なシナリオは、言語と地域に適した方法でデータをフォーマットする必要性です。

00:05:55.000 --> 00:06:03.000
使いやすく、TextおよびTextFieldと緊密に統合する新しい書式設定APIを使用すると、このタスクを達成できます。

00:06:03.000 --> 00:06:07.000
Frutaでは、UI内のいくつかの場所でカロリー数を表示します。

00:06:07.000 --> 00:06:14.000
以前は、ここのスライドにあるものと同様に、フォーマットされた値を表示するために測定フォーマッタを作成する必要がありました。

00:06:14.000 --> 00:06:20.000
これで、値が表示されている場所と直接インラインで宣言的な方法でフォーマットを指定できます。

00:06:20.000 --> 00:06:26.000
これは読みやすいだけでなく、前のスライドのコードよりもパフォーマンスが高くなります。

00:06:26.000 --> 00:06:32.000
これらの新しい書式設定APIの詳細については、「What's New in Foundation」の講演をご覧ください。

00:06:32.000 --> 00:06:41.000
最後に、初心者もパワーユーザーも、MacとiPadの両方でタスクをより迅速に実行できるキーボードショートカットを考えてみましょう。

00:06:41.000 --> 00:06:52.000
macOSとiPadOSの新機能では、SwiftUIアプリで定義したキーボードショートカットが自動的に調整され、ユーザーの現在アクティブなキーボードレイアウトで入力できるようになりました。

00:06:52.000 --> 00:06:58.000
たとえば、お気に入りリストにスムージーを追加する場合は、「Command plus」と入力して追加できます。

00:06:58.000 --> 00:07:07.000
これは、組み合わせが正確に2つのキー押下、Commandキーとプラスキーを必要とする米国のレイアウトでうまく機能します。

00:07:07.000 --> 00:07:12.000
ただし、リトアニア語のキーボードレイアウトを使用している場合、プラスキーに到達するのはそれほど簡単ではありません。

00:07:12.000 --> 00:07:17.000
最初にバックティックキーを押してから、「Shift equals」を押す必要があります。

00:07:17.000 --> 00:07:23.000
さらに悪いことに、この組み合わせは実際にはCommandキーを押しながら入力できません。

00:07:23.000 --> 00:07:40.000
しかし、macOS MontereyとiPadOS 15の再マッピング機能のおかげで、リトアニアのキーボードレイアウトがアクティブな場合、ショートカットは「Command ž」に変更され、ユーザーは現在使用しているキーボードレイアウトに関係なく、キーボードショートカットを使用してお気に入りにスムージーを追加できます。

00:07:40.000 --> 00:07:45.000
そして、ここに最高の部分があります、あなたは開発者として何もする必要はありません、それはただ機能します。

00:07:45.000 --> 00:07:57.000
そして、それをケイトに渡しましょう。ケイトは、Xcode 13のローカリゼーションワークフローの改善点を示し、私が今取り上げたベストプラクティスと新しいAPIのいくつかをデモします。

00:07:57.000 --> 00:07:58.000
ありがとう、ポール。

00:07:58.000 --> 00:08:01.000
こんにちは、ローカリゼーションチームのエンジニアのケイトです。

00:08:01.000 --> 00:08:06.000
SwiftUIアプリのローカライズがどれほど簡単かを見てみましょう。 試してみましょう。

00:08:06.000 --> 00:08:08.000
ここにはFrutaのサンプルアプリがあります。

00:08:08.000 --> 00:08:15.000
私たちは、世界中の人々が母国語でスムージーを注文できるようにしたいと考えています。

00:08:15.000 --> 00:08:18.000
今日は、ロシア語のローカリゼーションを追加します。

00:08:18.000 --> 00:08:29.000
したがって、まず、プロジェクトナビゲーターでプロジェクトに移動し、プロジェクトエディタで「Fruta」を選択し、「情報」タブでローカリゼーションを追加できます。

00:08:29.000 --> 00:08:35.000
macOSに付属するすべてのローカリゼーションは、ここにアルファベット順にリストされています。

00:08:35.000 --> 00:08:44.000
Xcode 12.5では、リストの下部にある「More Languages」サブメニューに、さらに何百もの言語と地域のバリエーションを追加しました。

00:08:44.000 --> 00:08:47.000
「ロシア語」を選択します。

00:08:47.000 --> 00:08:57.000
ポールが述べたように、Xcode 13は、Swiftコンパイラで新しい技術を使用して、Swiftコードからの文字列抽出を大幅に簡素化します。

00:08:57.000 --> 00:09:07.000
FrutaはSwiftUIで書かれているので、ビルド設定「Compilerを使用してSwift Stringsを抽出する」が「はい」に設定されていることを確認したい。

00:09:07.000 --> 00:09:15.000
これは新しいSwiftプロジェクトではデフォルトで有効になっていますが、既存のプロジェクトがSwiftUIを使用している場合は、この設定をオプトインできます。

00:09:15.000 --> 00:09:27.000
ローカリゼーションのためにエクスポートすると、Xcodeはプロジェクト内のすべてのターゲットを構築し、コンパイラタイプ情報を使用してSwiftUIコードからLocalizedStringKeysを抽出します。

00:09:27.000 --> 00:09:36.000
エクスポートする前に、SwiftUIプレビューで疑似言語を使用して、どの文字列がローカライズ可能で、どの文字列が見逃したかを確認できます。

00:09:36.000 --> 00:09:43.000
そこで、スキームエディタに移動し、[オプション]タブで[App Language]をクリックします。

00:09:43.000 --> 00:09:56.000
私のアプリでサポートされているすべての言語は上部にリストされていますが、一番下まで行って、アクセント付き疑似言語を選択します。

00:09:56.000 --> 00:10:03.000
アクセント付きの疑似言語は、UIのソース文字列に異なるアクセントマークを追加します。

00:10:03.000 --> 00:10:07.000
これで、すべての成分が疑似局在化されていることがわかります。

00:10:07.000 --> 00:10:16.000
測定値はフォーマットされているため疑似ローカライズされていませんが、StepperViewは疑似ローカライズされているはずです。

00:10:16.000 --> 00:10:19.000
この文字列をローカライズ可能にしましょう。

00:10:19.000 --> 00:10:27.000
StepperViewは、「ラベル」文字列を取り込み、それをテキストビューに渡すカスタムSwiftUIビューです。

00:10:27.000 --> 00:10:33.000
ローカリゼーションが必要なカスタムSwiftUIビューでは、LocalizedStringKeyを使用する必要があります。

00:10:33.000 --> 00:10:41.000
今、それが疑似ローカライズされていることを確認しましょう。

00:10:41.000 --> 00:10:42.000
すごい！

00:10:42.000 --> 00:10:48.000
この文字列がローカライズ可能になったので、複数形を適切に処理することを確認する必要があります。

00:10:48.000 --> 00:10:57.000
このコードは英語で「smoothie」を複数形にするために機能しますが、すべての単語で機能するわけではありませんし、すべての言語で機能するわけではありません。

00:10:57.000 --> 00:11:00.000
代わりにstringsdictを使いましょう。

00:11:00.000 --> 00:11:06.000
Stringsdictファイルは、言語の複数形のバリアントに対して異なる翻訳を提供できます。

00:11:06.000 --> 00:11:14.000
Stringsdictの使用方法の詳細については、「ローカライズされた文字列を合理化する」ビデオをご覧ください。

00:11:14.000 --> 00:11:26.000
ここにファイルが用意されているので、プロジェクトにドラッグします。

00:11:26.000 --> 00:11:30.000
そして、ローカリゼーションのためにそれをマークします。

00:11:30.000 --> 00:11:33.000
では、ローカリゼーションのためにエクスポートしましょう。

00:11:33.000 --> 00:11:43.000
Xcode 12.5以降、製品メニューでプロジェクトやワークスペースのローカリゼーションをエクスポートおよびインポートできます。

00:11:43.000 --> 00:11:50.000
では、ローカリゼーションのエクスポートをクリックして、デスクトップに保存しましょう。

00:11:50.000 --> 00:12:00.000
今、Xcodeは私のプロジェクトを構築しており、それをロシア語に翻訳することを志願したポールに送る準備ができているXcodeローカリゼーションカタログを作成します。

00:12:00.000 --> 00:12:10.000
Xcodeローカリゼーションカタログの詳細については、WWDC 2018の「Xcode 10の新しいローカリゼーションワークフロー」トークをご覧ください。

00:12:10.000 --> 00:12:15.000
翻訳のために送信する前に、エクスポートされたものを再確認しましょう。

00:12:15.000 --> 00:12:22.000
Xcode 13以降、Xcodeローカリゼーションカタログは作業がさらに便利になります。

00:12:22.000 --> 00:12:27.000
Finderでカタログをダブルクリックして、Xcodeで開くだけです。

00:12:27.000 --> 00:12:42.000
これは、独自のアプリをローカライズする場合、ローカリゼーションのためにコンテンツを送信する前に文字列やスクリーンショットを確認する場合、または特定の言語の翻訳を修正する場合に非常に便利です。

00:12:42.000 --> 00:12:48.000
ここエディタでは、ローカリゼーションが必要なすべてのファイルを見ることができます。

00:12:48.000 --> 00:12:53.000
ファイルを選択すると、翻訳者と同じようにすべての文字列を見ることができます。

00:12:53.000 --> 00:12:59.000
キー、ソース文字列、翻訳、およびコメント。

00:12:59.000 --> 00:13:03.000
私はここをざっと見て、すべてが良さそうに見えるかどうかを確認します。

00:13:03.000 --> 00:13:07.000
すぐに、私はいくつかの問題を見ることができます。

00:13:07.000 --> 00:13:11.000
まず、「%lfカロリー」文字列をエクスポートしました。

00:13:11.000 --> 00:13:17.000
異なる地域がカロリーを測定するために異なる単位を使用するため、その文字列はフォーマットする必要があります。

00:13:17.000 --> 00:13:21.000
それを修正するには、コードを変更する必要があります。

00:13:21.000 --> 00:13:34.000
ここNutritionFactViewでは、文字列の代わりに、NutritionFacts構造体の測定タイプで「フォーマットされた」メソッドを使用できます。

00:13:34.000 --> 00:13:41.000
食品のカロリーを測定しているので、ワイドフォーマットを使用し、使用量を「食品」に設定します。

00:13:41.000 --> 00:13:45.000
これにより、すべての地域のユニットのフォーマットが処理されます。

00:13:45.000 --> 00:13:47.000
それは簡単な修正でした。

00:13:47.000 --> 00:13:53.000
私のひもを見直すことに戻りましょう。

00:13:53.000 --> 00:14:01.000
ああ、翻訳者は変数名が表示されないので、「%@のレシピを購入する」のような文字列は混乱する可能性があります。

00:14:01.000 --> 00:14:06.000
私は特定の価格でレシピを買っていますか、それとも友人にプレゼントしていますか?

00:14:06.000 --> 00:14:12.000
他に曖昧な文字列があるかどうか見てみましょう。

00:14:12.000 --> 00:14:20.000
「お気に入り」には動詞だというコメントがありますが、「お気に入り」にコメントを追加する必要があるので、名詞であることは明らかです。

00:14:20.000 --> 00:14:25.000
両方のコメントをコードに追加します。

00:14:25.000 --> 00:14:31.000
最初に「レシピを購入する」文字列を処理しましょう。

00:14:31.000 --> 00:14:33.000
行くよ。

00:14:33.000 --> 00:14:41.000
「お気に入り」文字列は私のタブバーの項目にあるので、コメントも追加しましょう。

00:14:41.000 --> 00:14:43.000
タブバー項目はラベルビューです。

00:14:43.000 --> 00:14:51.000
SwiftUIでは、コメントを追加するには、テキストビューでラベルを初期化する必要があります。

00:14:51.000 --> 00:14:57.000
このようなコメントを追加することは、高品質のローカリゼーションを確保するために本当に重要です。

00:14:57.000 --> 00:15:01.000
翻訳者に混乱してほしくないし、私の言いたいことを推測しないといけない。

00:15:01.000 --> 00:15:05.000
さて、私はすべてを直したと思います。

00:15:05.000 --> 00:15:12.000
新しいカタログをエクスポートしてポールに送る時間です。

00:15:12.000 --> 00:15:18.000
うわー、それは速かった。

00:15:18.000 --> 00:15:22.000
ポールは翻訳者のアップルシリコンです!

00:15:22.000 --> 00:15:27.000
彼が送り返したものを簡単に見てみましょう。

00:15:27.000 --> 00:15:31.000
ここでは、すべての翻訳を見ることができます。

00:15:31.000 --> 00:15:36.000
私が追加したスムージーステッパーのstringsdictがあります。

00:15:36.000 --> 00:15:41.000
よさそうですね。これをインポートして、アプリがロシア語でどのように見えるか見てみましょう。

00:15:41.000 --> 00:15:51.000
インポートするには、[製品]メニューに移動し、[ローカリゼーションのインポート]をクリックし、Paulからカタログを選択します。

00:15:51.000 --> 00:15:53.000
今、私のすべての文字列はローカライズされるべきです。

00:15:53.000 --> 00:15:57.000
macOS用のロシア語でアプリを構築して実行しましょう。

00:15:57.000 --> 00:16:09.000
まず、スキームをmacOSに変更してから、言語をロシア語に変更できます。

00:16:09.000 --> 00:16:15.000
よし、それを実行しよう。

00:16:15.000 --> 00:16:21.000
うわー、アプリはロシア語で素晴らしく見えます、そしてすべてのスムージーは美味しそうに見えます。

00:16:21.000 --> 00:16:27.000
私はそれらのすべての成分とすべての栄養価を見ることができます。

00:16:27.000 --> 00:16:33.000
私は実際にこれを注文すると思います。

00:16:33.000 --> 00:16:38.000
うわー、なんて素晴らしいサービスでしょう。

00:16:38.000 --> 00:16:44.000
SwiftUIのローカリゼーションは簡単に設計されているので、コードを書くことに集中できます。

00:16:44.000 --> 00:16:49.000
アプリを開発する際に心に留めておくべき重要なポイントをいくつか紹介します。

00:16:49.000 --> 00:16:56.000
LocalizedStringKeyは、バンドル内のローカライズされた文字列を検索するようにSwiftUIに通知する特別なタイプです。

00:16:56.000 --> 00:17:01.000
カスタムSwiftUIビューで使用して、ローカリゼーションの準備をします。

00:17:01.000 --> 00:17:11.000
Xcodeでローカリゼーションのためにエクスポートするときに、コードからLocalizedStringKeysを抽出する「Compilerを使用してSwift Stringsを抽出する」ビルド設定を有効にします。

00:17:11.000 --> 00:17:17.000
文字列をフォーマットしてコードを国際化し、Markdownでスタイル設定します。

00:17:17.000 --> 00:17:22.000
テキストを使用して、追加の翻訳コンテキストのコメントを追加します。

00:17:22.000 --> 00:17:27.000
見てくれてありがとう、そしてWWDCの残りの部分を楽しんでください!

00:17:27.000 --> 23:59:59.000
[音楽]。

