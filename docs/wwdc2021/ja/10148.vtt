WEBVTT

00:00:02.000 --> 00:00:11.000
WWDCへようこそ。

00:00:11.000 --> 00:00:13.000
こんにちは、私はジョナサン・メッツガーです。

00:00:13.000 --> 00:00:16.000
私はアップルのメタルエコシステムチームのメンバーです。

00:00:16.000 --> 00:00:21.000
私たちはゲーム開発者と協力して、Apple GPUで最高のグラフィックスパフォーマンスを得られるよう支援します。

00:00:21.000 --> 00:00:26.000
ダスティンと私は、Apple GPUのハイエンドゲームを最適化する方法を紹介します。

00:00:26.000 --> 00:00:30.000
このビデオでは、ゲームを最適化するために使用するプロセスについて説明します。

00:00:30.000 --> 00:00:37.000
次に、ゲームBaldur's Gate 3とMetro Exodusで使用されている最適化の種類を紹介します。

00:00:37.000 --> 00:00:49.000
そして最後に、ダスティンはゲームDivinity: Original Sin 2をフィーチャーしたツールのデモンストレーションを行い、Xcode 13で新しいGPUタイムラインを紹介します。

00:00:49.000 --> 00:00:52.000
飛び込んで最適化について話しましょう。

00:00:52.000 --> 00:01:00.000
そのため、過去1年間、私たちはLarian Studiosと4A Gamesと協力して、Apple GPU用のゲームのグラフィックパフォーマンスを調整する方法を見つけました。

00:01:00.000 --> 00:01:11.000
私はあなたが詳細を見ることに興奮すると確信しています、そして私は少し時間を取って、このプレゼンテーションで開発資料を表示する許可を与えてくれたLarian Studiosと4A Gamesの両方に感謝したいと思います。

00:01:11.000 --> 00:01:19.000
今年を振り返ってみると、私たちは多くのゲームを分析し、グラフィックパフォーマンスに影響を与えるいくつかの一般的なシナリオを特定しました。

00:01:19.000 --> 00:01:31.000
あなたはおそらくあなた自身のゲームを最適化する機会を見つけることに興味があるので、私たちはGPUツールがこれらの問題領域を特定するのに特に有用であることを強調し、それらを解決する方法を提案するためにこのセッションを調整しました。

00:01:31.000 --> 00:01:37.000
そして、特に、私たちのチームが開発者がゲームを最適化するのを助けるために使用する原則のいくつかを共有したいと思います。

00:01:37.000 --> 00:01:45.000
グラフィックアプリケーションを最適化するときは、方法論、特定の問題を解決する方法を定義する一連の原則を持つことが重要です。

00:01:45.000 --> 00:01:49.000
では、4段階のプロセスをお見せしましょう。

00:01:49.000 --> 00:01:56.000
まず、収集または測定するデータを選択する必要があるため、ゲームで何が起こっているのかを理解するのに役立ちます。

00:01:56.000 --> 00:02:02.000
データの測定を開始するとすぐに、いくつかのパフォーマンス目標、または終了時にどこにいたいかを選択したいと思うでしょう。

00:02:02.000 --> 00:02:13.000
GPUフレームキャプチャとメタルシステムトレース、シーンの複雑さ、グラフィックス設定、およびフレームタイムなど、あなたにとって重要なその他の指標を取るために、ゲーム内の場所を決めることができます。

00:02:13.000 --> 00:02:17.000
次に、データを分析して、エンジンの動作について学びます。

00:02:17.000 --> 00:02:21.000
詳細な分析は、ボトルネックが発生している場所と理由を見つけるのに役立ちます。

00:02:21.000 --> 00:02:31.000
ボトルネックの原因がわかったら、ゲームを改善できますが、通常は一度に1つまたは2つを選択するので、各変更の影響を理解できます。

00:02:31.000 --> 00:02:37.000
最後に、いくつかの新しい測定値を元の測定値と比較することで、改善を確認します。

00:02:37.000 --> 00:02:43.000
最適化はプロセスであるため、パフォーマンス目標が達成されるまで戻って繰り返します。

00:02:43.000 --> 00:02:56.000
これらのゲームでは、XcodeのMetal Debuggerを使用して、パフォーマンスとフレームグラフの構造に関する洞察を提供し、InstrumentsのMetal System Traceを使用して、時間の経過とともにゲームのパフォーマンスについて学びます。

00:02:56.000 --> 00:03:04.000
GPUトレースファイルとInstrumentsトレースファイルを保存して、最適化の前と後の両方のデータを持つことができるのは素晴らしいアイデアです。

00:03:04.000 --> 00:03:10.000
だから、私はあなたがあなたのゲームで考慮したり、探したりできるものの小さなリストを持っています。

00:03:10.000 --> 00:03:16.000
前述したように、XcodeとInstrumentsは、Metalアプリケーションを理解するのに役立つ素晴らしいツールです。

00:03:16.000 --> 00:03:22.000
最適化とは、シェーダーのパフォーマンスからメモリ帯域幅まで、いくつかの分野を最大限に活用することです。

00:03:22.000 --> 00:03:28.000
もう1つの領域は、頂点、フラグメント、およびコンピューティングワークロード全体でうまく重複しています。

00:03:28.000 --> 00:03:34.000
そして、飛行中にいくつかのフレームをレンダリングしている間、一部のApple GPUはそれらの間でワークロードを重ねる可能性があります。

00:03:34.000 --> 00:03:40.000
重複を防ぐ可能性のあるリソースの依存関係に役立ついくつかのポインタを紹介します。

00:03:40.000 --> 00:03:47.000
また、一部の開発者はシェーダーにカスタムワークフローを使用しているため、コンパイラの設定がパフォーマンスにどのように影響するかを紹介します。

00:03:47.000 --> 00:03:53.000
最後に、冗長バインディングの影響を軽減する方法について話します。

00:03:53.000 --> 00:03:58.000
Larian StudiosのBaldur's Gate 3から始めましょう。

00:03:58.000 --> 00:04:05.000
Baldur's Gate 3は、20年間のゲームの遺産に基づいて構築されたRPGであり、その映画のような視覚効果で際立っています。

00:04:05.000 --> 00:04:12.000
Larian Studiosとの関わりは、Apple GPU用の素晴らしいレンダリングエンジンを最適化する方法を特定するのに役立ちました。

00:04:12.000 --> 00:04:17.000
まず、ここで見られるRavaged Beachのシーンのように、GPUフレームキャプチャから始めました。

00:04:17.000 --> 00:04:21.000
次に、シーンをフレームグラフに分解します。

00:04:21.000 --> 00:04:26.000
フレームグラフは、各レンダリングパスの順序と目的の内訳です。

00:04:26.000 --> 00:04:36.000
ハイエンドゲームには、アンビエントオクルージョン、シャドウマッピング、ポストプロセッシングなど、特定の視覚効果を達成することに特化した多くのレンダリングパスがあります。

00:04:36.000 --> 00:04:42.000
Baldur's Gate 3には複雑なフレームグラフがあるので、これは簡略化されたバージョンです。

00:04:42.000 --> 00:04:49.000
Xcodeのメタルデバッガを使用して、GPUトレースをキャプチャし、それを使用してゲーム内のすべてのレンダリングパスを確認します。

00:04:49.000 --> 00:04:55.000
「依存関係を表示」をクリックすると、パンしてズームできるビジュアライゼーションが表示されます。

00:04:55.000 --> 00:05:01.000
これは、レンダリングパスが以前の結果にどのように依存しているかを示し、何が起こっているのかを理解するのに役立ちます。

00:05:01.000 --> 00:05:06.000
たとえば、詳細を取得するために、この延期されたデカールレンダリングステージを拡大しています。

00:05:06.000 --> 00:05:11.000
次に、楽器ツールをお見せします。

00:05:11.000 --> 00:05:18.000
インスツルメントトレース、メタルシステムトレース、またはゲームパフォーマンステンプレートを使用してゲームの分析に時間を費やします。

00:05:18.000 --> 00:05:30.000
メタルシステムトレースは、GPUの実行とスケジューリング分析に焦点を当てたい場合に理想的であり、ゲームパフォーマンスはそれを拡張し、スレッドストールや熱通知などの他の問題を支援します。

00:05:30.000 --> 00:05:36.000
メタルシステムトレースを選択して、フレームからフレームへのエンジンの動作を見てみましょう。

00:05:36.000 --> 00:05:40.000
機器を使用すると、タイムラインに沿って複数のチャネルのデータを表示できます。

00:05:40.000 --> 00:05:45.000
ここでは、最初の問題を見つけます。レンダリングパスの高価なワークロードです。

00:05:45.000 --> 00:05:48.000
高価な作業負荷は、シェーダーを最適化する必要があることを意味するかもしれません。

00:05:48.000 --> 00:05:52.000
たとえば、長い計算シェーダーがフレームの残りの部分を保持しているのが見えます。

00:05:52.000 --> 00:05:55.000
私たちはこれらのギャップを「バブル」と呼んでいます。

00:05:55.000 --> 00:06:00.000
GPUトレースに戻り、これをさらに調査しましょう。

00:06:00.000 --> 00:06:02.000
これは「前」のGPUトレースです。

00:06:02.000 --> 00:06:06.000
グループ化をAPI CALLからPIPELINE STATEに変更しましょう。

00:06:06.000 --> 00:06:11.000
パイプラインの状態が実行時間によってソートされていることに気付くかもしれません。

00:06:11.000 --> 00:06:13.000
最初のコンピューティングパイプラインを確認しましょう。

00:06:13.000 --> 00:06:18.000
計算関数の詳細を展開して、その統計を詳しく調べることができます。

00:06:18.000 --> 00:06:22.000
ここでは、4.5千以上の指示があることに注意してください。 

00:06:22.000 --> 00:06:25.000
それはかなり多いです。それで、他には？

00:06:25.000 --> 00:06:30.000
この計算関数でどのようなリソースが使用されているか見てみましょう。

00:06:30.000 --> 00:06:36.000
入力データに応じて、この関数は最大120のテクスチャを使用して出力を生成します。

00:06:36.000 --> 00:06:42.000
しかし、実際には90%しか使用されていないことがわかりました。

00:06:42.000 --> 00:06:46.000
では、このシェーダーをどのように改善できるかについて話しましょう。

00:06:46.000 --> 00:06:54.000
多くの異なる条件を処理する必要があるシェーダーは、必要以上に多くのレジスタを予約することができ、これにより並列に実行されるスレッドの数を減らすことができます。

00:06:54.000 --> 00:07:02.000
ワークロードをより小さく、より焦点を絞ったシェーダーに分割し、レジスタが少なくなると、シェーダーコアの使用率を向上させることができます。

00:07:02.000 --> 00:07:10.000
したがって、シェーダーで適切なアルゴリズムを選択する代わりに、GPUワークロードを発行するときに適切なシェーダー順列を選択します。

00:07:10.000 --> 00:07:21.000
さらに、あまりにも多くのレジスタを使用するシェーダー機能は、実行ユニットが高速レジスタメモリを使い果たし、代わりにデバイスメモリを使用しなければならない場合、レジスタ圧力を引き起こす可能性があります。

00:07:21.000 --> 00:07:32.000
これは、フロートのような32ビット型よりも半分のレジスタスペースを使用するため、必要に応じて半分のような16ビット型を使用する理由の1つです。

00:07:32.000 --> 00:07:41.000
この場合、Larian Studiosはすでに半精度の浮動小数点を使用するようにシェーダーを最適化し、代わりに専用のシェーダーバリアントを作成することにしました。

00:07:41.000 --> 00:07:44.000
では、何が起こったのか見てみましょう。

00:07:44.000 --> 00:08:00.000
前の数字を比較すると、左側のボックスの数字と右側のボックスの数字を比較すると、指示の数は84%減少し、ブランチは90%減少し、レジスタは25%減少し、テクスチャ読み取りは92%減少しました。

00:08:00.000 --> 00:08:03.000
このシェーダーバリアントは90%の時間で使用されます。

00:08:03.000 --> 00:08:06.000
メタルシステムトレースでも見ることができます。

00:08:06.000 --> 00:08:12.000
ここで、前のトレースで、私たちが以前に見た泡に注目してください。

00:08:12.000 --> 00:08:15.000
そしてここで、後追跡では、それらは最小限に抑えられています。

00:08:15.000 --> 00:08:20.000
ラリアンスタジオは、このシェーダーを平均8ミリ秒減らすことができました。

00:08:20.000 --> 00:08:22.000
それは大きな勝利です!

00:08:22.000 --> 00:08:29.000
最も高価なパイプライン状態オブジェクトとシェーダーを見ると、簡略化できる複雑なシェーダーが見つかるかもしれません。

00:08:29.000 --> 00:08:34.000
これは、そのシェーダーの結果が後のパスで使用される場合に特に当てはまります。

00:08:34.000 --> 00:08:39.000
これはゲームにとって大きな改善でしたが、開発者のパフォーマンス目標には及ばなかった。

00:08:39.000 --> 00:08:47.000
メモリを問題として言及しましたが、GPUの機能の1つは、特定の条件で有効になっているロスレス圧縮です。

00:08:47.000 --> 00:08:51.000
だから、誤って設定したか、設定するのを忘れたフラグがあったのかもしれません。

00:08:51.000 --> 00:09:00.000
ロスレス圧縮は、タイルからデバイスメモリに保存されたテクスチャを圧縮することで、帯域幅を削減するのに役立ちます。

00:09:00.000 --> 00:09:07.000
概要ページの帯域幅インサイトを見ると、一部のテクスチャのロスレス圧縮警告に気付くかもしれません。

00:09:07.000 --> 00:09:13.000
彼らは、これらのテクスチャはロスレス圧縮できないことを教えてくれ、帯域幅のペナルティを支払う可能性があります。

00:09:13.000 --> 00:09:17.000
メタルデバッガは、これらのテクスチャを可逆圧縮できない理由も教えてくれます。

00:09:17.000 --> 00:09:21.000
ここでは、ShaderWriteの使用フラグが原因であることがわかります。

00:09:21.000 --> 00:09:25.000
メモリセクションに行くと、すべての使用フラグを確認できます。

00:09:25.000 --> 00:09:29.000
メモリセクションに入ったら、レンダリングターゲットでフィルタリングできます。

00:09:29.000 --> 00:09:35.000
次に、テーブルヘッダーを右クリックし、テクスチャを選択し、次に使用を選択します。

00:09:35.000 --> 00:09:41.000
これで、使用法で並べ替え、ShaderWriteを使用してテクスチャを見つけることができます。

00:09:41.000 --> 00:09:47.000
テクスチャの作成時にShaderWriteまたはPixelFormatViewフラグを設定すると、ロスレス圧縮が無効になります。

00:09:47.000 --> 00:09:51.000
これらの旗をもっと詳しく見てみましょう。 ではもっと詳しく見てみましょう。

00:09:51.000 --> 00:09:57.000
Unknown、ShaderWrite、およびPixelFormatViewフラグは、テクスチャがロスレス圧縮されるのを防ぎます。

00:09:57.000 --> 00:10:01.000
一般的な経験則は、必要な場合にのみこれらのフラグを使用することです。

00:10:01.000 --> 00:10:09.000
たとえば、write() メソッドを使用してフラグメントまたは計算関数のテクスチャに値を格納する場合は、ShaderWrite フラグを使用します。

00:10:09.000 --> 00:10:14.000
カラーアタッチメントとしてバインドされたテクスチャにレンダリングするには、ShaderWriteフラグは必要ありません。

00:10:14.000 --> 00:10:19.000
また、コンポーネントの値を別の順序で読み取る必要がある場合は、PixelFormatViewオプションを設定しないでください。

00:10:19.000 --> 00:10:24.000
代わりに、スウィズルパターンを使用してテクスチャビューを作成し、新しい順序を指定します。

00:10:24.000 --> 00:10:33.000
同様に、テクスチャビューが線形空間とsRGBの間でのみ変換する場合は、PixelFormatViewオプションを設定しないでください。

00:10:33.000 --> 00:10:35.000
詳細については、ドキュメントを確認してください。

00:10:35.000 --> 00:10:46.000
シェーダーの最適化と可逆圧縮は、私たちを助けた2つのテクニックですが、別の問題領域は、頂点、フラグメント、および計算チャネル全体で良好な重複を得ています。

00:10:46.000 --> 00:10:50.000
チャネル間でワークロードを最適化する2つの方法を見てみましょう。

00:10:50.000 --> 00:10:53.000
まず、メタルシステムトレースをもう一度見ることから始めます。

00:10:53.000 --> 00:10:58.000
ここでは、頂点、フラグメント、および計算チャネルの重複が少ないことがわかります。

00:10:58.000 --> 00:11:02.000
GPUを忙しく保つために、これを改善するのはいいことです。

00:11:02.000 --> 00:11:07.000
この問題を解決する1つの方法は、フレームグラフのエンコーディング順序を再構築できるかどうかを確認することです。

00:11:07.000 --> 00:11:12.000
言い換えれば、この作業を頂点ステージの占有率が非常に低い場所に移動したいと考えています。

00:11:12.000 --> 00:11:20.000
以前のレンダリングパスのフラグメントステージとともに、これらの頂点を早期に処理したいと思います。

00:11:20.000 --> 00:11:26.000
フレームグラフは、この疑似コードの例のように、レンダリングタスクのリストと考えることができます。

00:11:26.000 --> 00:11:31.000
良いオーバーラップを得るのは、フレームグラフのレンダリングタスクの順序を変更するのと同じくらい簡単です。

00:11:31.000 --> 00:11:36.000
一部のタスクは以前のタスクの結果に依存する場合がありますが、必ずしもそうとは限りません。

00:11:36.000 --> 00:11:45.000
頂点シェーダーが重いCascadedShadowBufferステージは、依存関係が少ないため、いくつかのタスクを早く移動できることがわかりました。

00:11:45.000 --> 00:11:53.000
そして今、重複の少ない地域は、頂点とフラグメントチャネルの利用率が向上し、さらに1ミリ秒の勝利が得られます。

00:11:53.000 --> 00:11:57.000
しかし、私たちが試すことができる別の最適化があります。

00:11:57.000 --> 00:12:00.000
ゲームはしばしば飛行中に2〜3フレームを持っています。

00:12:00.000 --> 00:12:11.000
したがって、タイルベースの遅延レンダリング、またはTBDRアーキテクチャGPUのクールな機能は、それらの間にリソースの依存関係がない場合に、2つのフレームからワークロードを重ねることです。

00:12:11.000 --> 00:12:15.000
では、この可能性を最適化する方法を紹介します。

00:12:15.000 --> 00:12:19.000
インストゥルメントのGPUトラックをもう一度見てみましょう。

00:12:19.000 --> 00:12:24.000
ここでは、これらのフレームがほぼ連続して処理されていることがわかります。

00:12:24.000 --> 00:12:32.000
これは、blitエンコーダを使用して、フレームごとのアニメーションデータなどの一定のバッファを更新することによって引き起こされます。

00:12:32.000 --> 00:12:43.000
ディスクリートGPUで一定のバッファデータを効率的に更新するために、CPU上の共有バッファからフレームのレンダリングに使用されるGPU上のプライベートバッファにブリットします。

00:12:43.000 --> 00:12:51.000
この戦略は、ディスクリートメモリを持つGPUにとって効率的であるため、その目的のためにこの動作を維持したいと考えています。

00:12:51.000 --> 00:12:59.000
デバイスにユニファイドメモリアーキテクチャがある場合は、ブリットエンコーダを使用してデータをプライベートバッファにコピーする必要はありません。

00:12:59.000 --> 00:13:12.000
ただし、リングバッファパターンで共有バッファを使用する場合は、CPUが現在GPUによって読み込まれているデータに書き込むと、視覚的な破損が発生する可能性があるため、同期の問題に注意する必要があります。

00:13:12.000 --> 00:13:16.000
これを実際に見てみましょう。

00:13:16.000 --> 00:13:21.000
ここでは、この図でフレームのエンコーディングとレンダリングを見ることができます。

00:13:21.000 --> 00:13:31.000
共有バッファを表すために色を使用しており、フレームの先頭で更新されます。バッファ1は青、バッファ2は緑、バッファ3は黄色です。

00:13:31.000 --> 00:13:38.000
リングバッファは通常、コンパクトな量のメモリを使用する必要があるキューを実装するために使用されます。

00:13:38.000 --> 00:13:46.000
ここでは、共有バッファの書き込みと読み取りは相互に排他的であるため、この取り決めによるデータ競合状態の懸念はありません。

00:13:46.000 --> 00:13:51.000
フレームのエンコードとフレームのレンダリングの間にレイテンシがあるのは非常に一般的です。

00:13:51.000 --> 00:13:55.000
これにより、レンダリングが実際に開始される時期が変化します。

00:13:55.000 --> 00:13:59.000
レイテンシが長すぎない限り、データ競合状態はありません。

00:13:59.000 --> 00:14:04.000
しかし、レイテンシが増加し続けるとどうなりますか?

00:14:04.000 --> 00:14:12.000
さて、これは、GPUがフレームをレンダリングしている間にメインスレッドが共有バッファを更新しているデータ競合条件を導入します。

00:14:12.000 --> 00:14:18.000
そして、それが起こると、フレームの要素がこのデータに依存している場合、視覚的な破損が発生する可能性があります。

00:14:18.000 --> 00:14:30.000
Baldur's Gate 3の場合、プライベートバッファとBlitエンコーダを削除すると、同期ポイントが排除されましたが、競合状態が導入され、一時的なアンチエイリアスレンダリングパスに影響しました。

00:14:30.000 --> 00:14:34.000
では、この状況を回避する方法を見てみましょう。

00:14:34.000 --> 00:14:40.000
この競合状態を回避するには、GPUが読み込んでいるのと同じリソースに書き込んでいないことを確認する必要があります。

00:14:40.000 --> 00:14:48.000
たとえば、完了ハンドラを利用して、エンコーディングスレッドの共有バッファを更新するのが安全になるまで待つことができます。

00:14:48.000 --> 00:14:53.000
しかし、待ち時間を避けた方法をお見せしましょう。

00:14:53.000 --> 00:14:59.000
完了ハンドラを維持しましたが、待ち時間を避けるためにリングバッファに余分なバッファを追加しました。

00:14:59.000 --> 00:15:02.000
余分なバッファーは、下の図で紫色に着色されています。

00:15:02.000 --> 00:15:06.000
メモリ消費量はディスクリートGPUと同じままです。

00:15:06.000 --> 00:15:13.000
しかし、メモリを節約する必要があり、CPUの待ち時間がゲームのフレームレートに影響しない場合は、3つのバッファを使用できます。

00:15:13.000 --> 00:15:22.000
それでは、疑似コードの例で作成する共有バッファとプライベートバッファの数を決定する簡単な方法を見てみましょう。

00:15:22.000 --> 00:15:29.000
このコードスニペットでは、初期化時に共有バッファとプライベートバッファの数を選択する方法を確認できます。

00:15:29.000 --> 00:15:39.000
デバイスを作成したら、デバイスにユニファイドメモリがあるかどうかを確認し、追加の共有バッファを作成するか、プライベートバッファを使用することを確認します。

00:15:39.000 --> 00:15:47.000
この余分なバッファは、データ競合状態を回避するために使用している完了ハンドラを待つことの影響を軽減するのに役立ちます。

00:15:47.000 --> 00:15:54.000
そして今、前のフレームのフラグメントワークロードが次のフレームの頂点ワークロードとどのように重なるかを見ることができます。

00:15:54.000 --> 00:15:58.000
全体として、これはシーンに応じて1〜2ミリ秒を与えることができます。

00:15:58.000 --> 00:16:09.000
そして、もちろん、このアプローチは、この例で示した一定のバッファデータだけでなく、CPUからGPUに転送するすべてのバッファデータにも適用できます。

00:16:09.000 --> 00:16:11.000
では、復習しましょう。

00:16:11.000 --> 00:16:33.000
Larian Studiosは、次の最適化を適用することで、パフォーマンス目標を達成することができました。バブルを減らすために最も高価なシェーダーを最適化し、帯域幅を改善するためにロスレス圧縮を選択し、頂点とフラグメントワークロードを重ねてGPUの使用率を向上させ、フレームの重複を防ぐリソースの依存関係をチェックします。

00:16:33.000 --> 00:16:41.000
彼らが終わったとき、ラリアンスタジオはパフォーマンス目標を達成しただけでなく、ゲームのフレームタイムが33%向上しました。

00:16:41.000 --> 00:16:47.000
そして今、私たちはゲームメトロエクソダスで異なる一連の最適化を見ていきます。

00:16:47.000 --> 00:16:54.000
メトロエクソダスは、この一連のゲームプレイクリップでわかるように、壮大なストーリーと要求の厳しい視覚効果で知られています。

00:16:54.000 --> 00:17:00.000
提案された最適化を統合した後、4A Gamesはパフォーマンス目標を達成することができました。

00:17:00.000 --> 00:17:05.000
それでは、メトロエクイダスのゲーム内シーンを見てみましょう。

00:17:05.000 --> 00:17:13.000
Metro Exodusは、カスタムワークフローを使用してレンダリングコマンドをMetal APIコマンドに変換します。これは、クロスプラットフォームゲームでは非常に一般的です。

00:17:13.000 --> 00:17:22.000
彼らが使用している翻訳層はMetalに最適化されていますが、2つの複雑なシステムが実際に一緒になると、いくつかの問題が発生する可能性があります。

00:17:22.000 --> 00:17:28.000
そのため、プロジェクトの目標を達成するためには、追加のパフォーマンスチューニングが必要でした。

00:17:28.000 --> 00:17:33.000
前のゲームと同様に、フレームがどのようにレンダリングされているかを調査することから始めます。

00:17:33.000 --> 00:17:40.000
現代のレンダラーにはさまざまな技術が含まれているため、まず高レベルのフレームグラフを理解しようとします。

00:17:40.000 --> 00:17:44.000
繰り返しになりますが、GPUのトレースを見て分析を開始します。

00:17:44.000 --> 00:17:48.000
それは常にゲームのパフォーマンスに関する有用な洞察を与えてくれます。

00:17:48.000 --> 00:17:53.000
まず、開発者のパフォーマンス目標を満たしていないGPUの時間から始めましょう。

00:17:53.000 --> 00:17:57.000
では、最も時間がかかるシェーダーやパイプラインを見つけましょう。

00:17:57.000 --> 00:18:03.000
これを行うには、もう一度パイプラインの状態ごとにグループ化し、最も高価なものを見ていきます。

00:18:03.000 --> 00:18:06.000
その統計をすばやく見てみましょう。

00:18:06.000 --> 00:18:12.000
合計と比較してALU命令の数が多いことがわかります。つまり、これは数学の多いシェーダーです。

00:18:12.000 --> 00:18:17.000
また、シェーダーで使用されているレジスタの数が非常に多いことがわかります。

00:18:17.000 --> 00:18:23.000
特定のシェーダーで使用されるレジスタの数は、実行中にワークロードがどのように拡張されるかに直接影響します。

00:18:23.000 --> 00:18:28.000
この数字が高ければ高いほど、GPUが並行して行う作業が少なくなります。

00:18:28.000 --> 00:18:41.000
この例のSSAOのような複雑なシェーダーで、多くの計算とレジスタが必要になることもありますが、コンパイラの設定が生成された命令とレジスタの割り当てにも影響することもあります。

00:18:41.000 --> 00:18:44.000
シェーダーコンパイラのオプションも見てみましょう。

00:18:44.000 --> 00:18:48.000
そして、このシェーダーは高速数学フラグを無効にしてコンパイルされたことが判明しました。

00:18:48.000 --> 00:18:56.000
高速数学により、シェーダーコンパイラはさまざまな命令を最適化でき、デフォルトではメタルシェーダーコンパイラで有効になっています。

00:18:56.000 --> 00:19:03.000
ただし、カスタムシェーダーワークフローを使用して、このコンパイルフラグを無効にできる場合があります。

00:19:03.000 --> 00:19:13.000
この場合、4A Gamesがコンパイラを呼び出すために使用していた翻訳レイヤーには、高速数学を使用しないようにデフォルトの動作が設定されていることがわかりました。

00:19:13.000 --> 00:19:15.000
では、高速数学とは何ですか?

00:19:15.000 --> 00:19:22.000
高速数学は、速度と正確性の間で取引する浮動小数点演算のための一連の最適化です。

00:19:22.000 --> 00:19:30.000
たとえば、結果または引数としてNAN、無限大、または符号付きゼロがないと仮定することができます。

00:19:30.000 --> 00:19:39.000
高速数学の最適化は、代数的に等価な変換を適用することもでき、浮動小数点結果の精度に影響を与える可能性があります。

00:19:39.000 --> 00:19:43.000
しかし、ほとんどのシナリオでは、速い数学はゲームに最適です。

00:19:43.000 --> 00:19:48.000
これにより、特にALUに縛られたケースでは、パフォーマンスが大幅に向上する可能性があります。

00:19:48.000 --> 00:20:00.000
私たちの推奨事項は、シェーダーが先ほど述べたものに依存していない場合は、高速数学を有効にしていることを確認するためにコンパイラオプションを確認することです。

00:20:00.000 --> 00:20:04.000
高速数学フラグは、フロントエンドとバックエンドのコンパイラレベルで機能します。

00:20:04.000 --> 00:20:12.000
シェーダーソースを構築するとき、フロントエンドのシェーダーコンパイラは、中間コードで使用される高速数学関数を選択します。

00:20:12.000 --> 00:20:18.000
これは、より最適なGPUマシンコードを生成できることをバックエンドシェーダーコンパイラに示唆します。

00:20:18.000 --> 00:20:26.000
ここでは、このシェーダーを再コンパイルした後、右側のボックスで左側の指示と登録カウンターがどのように改善されたかを見ることができます。

00:20:26.000 --> 00:20:38.000
したがって、すべてのシェーダーの高速数学を可能にするために翻訳レイヤーの動作を変更した後、組み込みのゲームベンチマークを使用してテストワークロードのフレーム時間が21%減少しました。

00:20:38.000 --> 00:20:43.000
だから、私が話したい次の分野は冗長バインディングです。

00:20:43.000 --> 00:20:51.000
要約ページに戻り、APIの洞察を見ると、フレームをレンダリングするときに多くの冗長なバインディングがあることがわかります。

00:20:51.000 --> 00:21:01.000
冗長バインディングは、テクスチャ、バッファ、サンプラーなどのリソース、または深度ステンシル状態、ビューポート設定などのレンダリング状態のいずれかです。

00:21:01.000 --> 00:21:11.000
繰り返しバインドされたリソースはエンコーディング時間に悪影響を及ぼす可能性がありますが、冗長なレンダリング状態の変更はGPU時間にも影響を与える可能性があります。

00:21:11.000 --> 00:21:16.000
メタルシステムトレースのエンコーディングとGPU時間を見てみましょう。

00:21:16.000 --> 00:21:24.000
特定のフレームでは、すべてのコマンドをエンコードするのに8ミリ秒半かかり、GPUがこのフレームをレンダリングするのに約22ミリ秒かかります。

00:21:24.000 --> 00:21:32.000
冗長バインディングの原因を調査したところ、翻訳層を変更してそれらを減らすことができることがわかりました。

00:21:32.000 --> 00:21:38.000
では、冗長なバインディングをチェックして減らす方法を示す疑似コードの例をお見せしましょう。

00:21:38.000 --> 00:21:45.000
テクスチャを直接エンコーダにバインドする代わりに、それらを事前にキャッシュし、変更された場合にのみバインドすることができます。

00:21:45.000 --> 00:21:56.000
また、APIとの相互作用を最小限に抑えるために、1つずつループで設定するのではなく、setFragmentTexturesメソッドを1回呼び出してすべてのテクスチャを設定できます。

00:21:56.000 --> 00:22:04.000
さらに、他のシェーダーステージや、バッファやサンプラーなどの他のバインディングタイプ、レンダリング状態にも同様のアプローチを適用できます。

00:22:04.000 --> 00:22:09.000
では、メタルシステムトレースで何が起こったのか見てみましょう。

00:22:09.000 --> 00:22:21.000
4A Gamesは、翻訳層が同じリソースとレンダリング状態を繰り返しバインドしていなかったため、シーンに応じてエンコーディング時間を30%から50%短縮することができました。

00:22:21.000 --> 00:22:29.000
しかし、GPU時間も最大3ミリ秒減少し、全体として、ゲーム内のベンチマークで15%のスピードアップをもたらしました。

00:22:29.000 --> 00:22:39.000
いくつかの冗長なバインディング警告がある場合、それは問題ではありませんが、私たちは間違いなく数百または数千の冗長バインディングの影響を見ています。

00:22:39.000 --> 00:22:45.000
したがって、冗長なバインディングを避けることで、平均フレーム時間をさらに15%短縮しました。

00:22:45.000 --> 00:22:50.000
これら2つの改善の後、4A Gamesはパフォーマンス目標を達成することができました。

00:22:50.000 --> 00:22:57.000
それでは、Apple GPU用のMetro Exodusの最適化から学んだことをまとめましょう。

00:22:57.000 --> 00:23:06.000
まず、シェーダーのカスタムワークフローを使用している場合は、コンパイラの設定を確認して、Metalアプリケーションに最適なオプションを使用していることを確認する必要があります。

00:23:06.000 --> 00:23:17.000
また、メタルデバッガに多くの冗長なバインディング警告が表示された場合は、エンコーディングとGPUの時間のオーバーヘッドを削減するテクニックを示しました。これは、エンジンまたは使用している翻訳層のいずれかに適用できます。

00:23:17.000 --> 00:23:27.000
そして今、私はそれをDustinに引き渡したいと思います。DustinはDivinity: Original Sin 2についてあなたに話し、新しいXcode GPUタイムライン機能をデモします。

00:23:27.000 --> 00:23:29.000
ありがとう、ジョナサン。

00:23:29.000 --> 00:23:33.000
こんにちは、私の名前はダスティンで、ここアップルのGPUソフトウェアチームで働いています。

00:23:33.000 --> 00:23:41.000
そして今日、Larian Studiosのヒットタイトル「Divinity: Original Sin 2」の初期ビルドを最適化する実践的なデモをお見せできることを嬉しく思います。

00:23:41.000 --> 00:23:48.000
昨年、ラリアンは絶賛されたロールプレイングゲーム「Divinity: Original Sin 2」をiPadに持ち込むと発表した。

00:23:48.000 --> 00:23:55.000
そして、昨年、ラリアンはApple GPUでうまく動作するようにゲームを最適化するために懸命に取り組んでおり、ゲームはプレイするのがとても楽しいです。

00:23:55.000 --> 00:24:09.000
ラリアンは、新しいGPUタイムラインを追加することで、今年Xcode 13でさらに良くなっているMetal DebuggerとMetal System Traceの素晴らしいツールセットの助けを借りて、これらの結果を達成することができました。

00:24:09.000 --> 00:24:15.000
先ほど撮影したDivinity: Original Sin 2のフレームを見てみましょう。

00:24:15.000 --> 00:24:22.000
概要ページには、ゲームをデバッグして最適化するのに役立つフレームの概要が含まれています。 をデバッグして最適化するのに役立つ。

00:24:22.000 --> 00:24:30.000
概要ページから、新しいGPUタイムラインを含む、メタルデバッガーが提供するすべての優れたツールにすばやく移動できます。

00:24:30.000 --> 00:24:34.000
そして、アクセスは、ここで新しいパフォーマンスページをクリックするのと同じくらい簡単です。

00:24:34.000 --> 00:24:37.000
だから、先に進んでそれをやらせてください。

00:24:37.000 --> 00:24:40.000
新しいGPUタイムラインをご紹介します。

00:24:40.000 --> 00:24:47.000
タイムラインは、各GPUパイプラインステージを並行して実行できるようにするApple GPUのユニークなアーキテクチャを中心に設計されています。

00:24:47.000 --> 00:24:57.000
パフォーマンスを最大化するためには、タイムラインで簡単に見ることができるオーバーラップを最大化することで、すべてのパイプラインステージをできるだけ忙しく保つ必要があります。

00:24:57.000 --> 00:25:00.000
タイムラインは2つのセクションで構成されています。

00:25:00.000 --> 00:25:11.000
上部にはGPUセクションがあり、各パイプラインステージごとに別々のトラックで構成されているため、どのステージがアクティブで並行して実行されているかを本当に簡単に確認できます。

00:25:11.000 --> 00:25:29.000
その下には、シェーダーの占有率、帯域幅、パフォーマンスリミッターなどの重要なカウンターのキュレーションされたセットを含むカウンターセクションがあり、ワークロードの過程でGPUのシステムパフォーマンスがどのように変化するかについてのより深い洞察を提供します。

00:25:29.000 --> 00:25:35.000
GPUトラックのエンコーダは、クリックするだけで、さらに多くの有用な情報を提供します。

00:25:35.000 --> 00:25:41.000
レンダリングエンコーダを選択すると、現在選択されているアイテムの追加情報を含むタイムラインのサイドバーが表示されます。

00:25:41.000 --> 00:25:49.000
この場合、サイドバーには、テクスチャの詳細、ロード/ストアアクション、ドロー呼び出しの数などのレンダリングパス情報が含まれています。

00:25:49.000 --> 00:25:57.000
レンダリングエンコーダは2つのシェーダーステージで構成されているため、頂点ステージとフラグメントステージの両方が強調表示されることに注意してください。

00:25:57.000 --> 00:26:06.000
代わりにフラグメントトラックを選択すると、サイドバーにはタイムライン内のすべてのエンコーダが含まれており、時間に基づいて並べ替えることができます。

00:26:06.000 --> 00:26:15.000
しかし、フラグメントトラックを展開して、実行中にエンコーダが使用するすべてのシェーダーを表示するシェーダータイムラインを表示できるため、それだけではありません。

00:26:15.000 --> 00:26:22.000
長時間実行されるシェーダーや、他のシェーダーと並行して実行されているシェーダーを簡単に識別できます。

00:26:22.000 --> 00:26:26.000
フラグメントトラックには、ロード/ストアアクション用の2つの追加トラックもあります。

00:26:26.000 --> 00:26:38.000
これは、GPUがローカルメモリとメインメモリの間でアタッチメントテクスチャをロードして保存しているときに確認するのに有用であり、帯域幅の使用を削減するための重要な考慮事項です。

00:26:38.000 --> 00:26:49.000
シェーダーを選択すると、アクティブになっているタイムライン上のすべての領域が強調表示され、サイドバーに表示されるコンパイラ統計とランタイムパフォーマンスメトリックから詳細を知ることができます。

00:26:49.000 --> 00:27:01.000
シェーダーのタイムラインを展開すると、各シェーダーが独自のトラックに表示され、GPUワークロードの流れとシェーダーの実行順序を理解するのに役立ちます。

00:27:01.000 --> 00:27:13.000
新しいGPUタイムラインにもう少し精通し、自分で使用できるすべての方法を考えているので、GPUタイムラインを使用してパフォーマンスのボトルネックを見つけるのがいかに簡単かをお見せしましょう。

00:27:13.000 --> 00:27:26.000
シェーダーのパフォーマンスは、多くの要因の結果として損なわれる可能性があり、そのうちの1つはレジスタ圧力であり、これが起こると、GPUは高速レジスタメモリを使い果たし、代わりにメインメモリを使用する必要があります。

00:27:26.000 --> 00:27:30.000
高いALUリミッターだけでは、パフォーマンスのボトルネックを示すものではありません。

00:27:30.000 --> 00:27:33.000
あなたのシェーダーは数学が重いだけかもしれません。

00:27:33.000 --> 00:27:43.000
ただし、シェーダーの占有率が低いと組み合わせると、シェーダーがレジスタ圧力を経験していることを示す指標となり、シェーダーの動作が遅くなる可能性があります。

00:27:43.000 --> 00:27:57.000
今日のデモでこれをよりよく強調するために、左側の「プラス」ボタンをクリックして、ALUトラックとシェーダー占有トラックの両方をタイムラインの上部に固定します。

00:27:57.000 --> 00:28:08.000
これら2つのトラックをスキャンすると、最初に気付いたのは、ALUが急増し、同時にシェーダーの占有率が低下するこの地域のことです。

00:28:08.000 --> 00:28:12.000
タイムラインで領域を強調表示して、実行にかかる時間を確認できます。

00:28:12.000 --> 00:28:17.000
これを行うと、サイドバーのカウンタは、選択した領域に基づいて動的に更新されます。

00:28:17.000 --> 00:28:21.000
ここの領域は、実行に約3.7ミリ秒かかっています。

00:28:21.000 --> 00:28:25.000
ズームインして詳しく見てみましょう。

00:28:25.000 --> 00:28:30.000
私たちの問題は、アンビエントオクルージョンパスの最初の4つのエンコーダに関連しているようです。

00:28:30.000 --> 00:28:36.000
シェーダーのタイムラインを見て、どのシェーダーが使用されているか見てみましょう。

00:28:36.000 --> 00:28:41.000
私たちの問題は、使用されている唯一のものなので、ここでこのシェーダーに関連しているようです。

00:28:41.000 --> 00:28:52.000
サイドバーのランタイムパフォーマンス指標から、このシェーダーALUは集中的であるだけでなく、フロートも重いので、浮動小数点利用トラックを見てみましょう。

00:28:52.000 --> 00:28:56.000
このトラックにカーソルを合わせると、このシェーダーはF32のみを使用していることに注意してください。

00:28:56.000 --> 00:28:59.000
F16は0%です。

00:28:59.000 --> 00:29:06.000
タイムラインから、シェーダーを右クリックして開くことで、シェーダーソースに直接移動できます。

00:29:06.000 --> 00:29:12.000
ここソースエディタでは、デモ用のシェーダーソースの簡略化されたバージョンを見ることができます。

00:29:12.000 --> 00:29:18.000
ソースに加えて、シェーダープロファイラの助けを借りて、行ごとのコスト情報を見ることもできます。

00:29:18.000 --> 00:29:28.000
シェーダープロファイラ円グラフにカーソルを合わせると、ALUとフロートヘビーの両方であるため、この機能がレジスタ圧力を引き起こしている可能性が高いことを確認できます。

00:29:28.000 --> 00:29:41.000
このような状況は、F16を使用するための候補であり、F32の完全な精度が要求されない場所では、レジスタの量の2倍になり、レジスタの圧力を軽減するのに役立ちます。

00:29:41.000 --> 00:29:46.000
メタルデバッガは、ソースエディタ内で直接ソースコードを更新するのが本当に便利です。

00:29:46.000 --> 00:29:54.000
F32とF16の混合物を使用するシェーダーの更新バージョンを使用して、ここでこの変更を加えてみましょう。

00:29:54.000 --> 00:30:08.000
この変更を行った後、下部にある「シェーダーをリロード」ボタンをクリックすると、シェーダーの更新がトリガーされ、シェーダーの再コンパイルと再プロファイルの両方がトリガーされ、ラインごとのシェーダーのコストが更新されます。

00:30:08.000 --> 00:30:12.000
タイムラインに戻ることで、この変更がどのような影響を与えたか見てみましょう。

00:30:12.000 --> 00:30:20.000
私が最初にしたいことは、アンビエントオクルージョンパスの最初の4つのエンコーダにどれくらいの時間がかかるかを見ることです。

00:30:20.000 --> 00:30:25.000
ここのこの地域は、実行に約2.6ミリ秒かかるようです。

00:30:25.000 --> 00:30:34.000
先ほどの変更により、シェーダーの実行時間が1ミリ秒以上（30%）改善されました。これは大きな改善です。

00:30:34.000 --> 00:30:41.000
以前のカウンターのいくつかを見てみると、ALUはまだ高いですが、それは数学の重いシェーダーに期待されます。

00:30:41.000 --> 00:30:48.000
しかし、シェーダーの占有率がほぼ2倍に改善されたため、シェーダーのレジスタ圧力が少なくなっています。

00:30:48.000 --> 00:30:56.000
これは、浮動小数点利用トラックを使用して見ることができるF32とF16の混合物を使用して達成されました。

00:30:56.000 --> 00:31:04.000
GPUタイムラインにより、問題を特定し、問題が存在する場所に移動し、修正することが本当に簡単になりました。

00:31:04.000 --> 00:31:13.000
GPUタイムラインは、シェーダーのパフォーマンスの問題だけでなく、メモリ帯域幅や他の多くの種類の問題を特定するための優れたツールです。

00:31:13.000 --> 00:31:24.000
私はあなたが真新しいGPUタイムラインのこのデモを楽しんで、すでにApple GPUでさらに良く実行するためにゲームを最適化するために使用するすべての方法を考えていることを願っています。

00:31:24.000 --> 00:31:27.000
ありがとう、そしてWWDCの残りの部分を楽しんでください。

00:31:27.000 --> 00:31:28.000
ジョナサンに戻る。

00:31:28.000 --> 00:31:31.000
ダスティン、その素晴らしいデモをありがとう。

00:31:31.000 --> 00:31:33.000
そして、見てくれてありがとう。

00:31:33.000 --> 00:31:40.000
Apple GPUの機能を活用するために、Larian Studiosと4A Gamesとどのように協力したかを皆さんと共有できてよかったです。

00:31:40.000 --> 00:31:46.000
それらは、ロスレス圧縮から重複するシェーダーワークロードまで、パフォーマンスを向上させる多くの方法を提供します。

00:31:46.000 --> 00:31:53.000
また、Metal System TraceやXcodeの新しいGPUタイムラインなどのツールは、ゲームを改善する際に本当に役立ちます。

00:31:53.000 --> 00:32:03.000
私があなたに残すことができることが1つある場合、高度に最適化されたゲームを提供するためには、あなたのレンダリングの徹底的な検査が不可欠であり、私たちのツールはこれを助けるためにそこにあります。

00:32:03.000 --> 00:32:17.000
詳細を知りたい場合は、今年のWWDCの関連セッション「メタルデバッグ、プロファイリング、アセット作成ツールの発見」、またはWWDC20の「GPUカウンターでメタルアプリとゲームを最適化する」を参照してください。

00:32:17.000 --> 00:32:20.000
ありがとう、そしてさようなら!

00:32:20.000 --> 23:59:59.000
[音楽]。

