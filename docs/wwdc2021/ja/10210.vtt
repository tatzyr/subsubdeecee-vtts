WEBVTT

00:00:00.000 --> 00:00:05.000
♪ベース音楽の演奏♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:14.000
Jake Petroules: こんにちは、「Xcodeで高度なプロジェクト構成を探索する」へようこそ。

00:00:14.000 --> 00:00:22.000
私はジェイクです。同僚のプラチと一緒に、Xcodeプロジェクトのビルド構成を最大限に活用するための戦略とテクニックについて話し合います。

00:00:22.000 --> 00:00:26.000
3つの主要なトピック分野をカバーします。

00:00:26.000 --> 00:00:34.000
まず、PrachiはマルチプラットフォームプロジェクトとXcode 13のマルチプラットフォームフレームワークターゲットの新しいサポートについて議論します。

00:00:34.000 --> 00:00:44.000
次に、スキーム、ターゲット設定、依存関係管理、およびフェーズとルールの構築を通じて、プロジェクトのモデリングと設定のベストプラクティスについて説明します。

00:00:44.000 --> 00:00:57.000
そして最後に、Prachiはビルド設定を深く掘り下げ、その構造と動作、プロジェクトエディタUI、構成設定ファイルとその構文などについて説明します。

00:00:57.000 --> 00:01:04.000
この講演では、Frutaと呼ばれるマルチプラットフォームアプリプロジェクトを使用して、これらのテクニックが実際のプロジェクトにどのように適用されるかを示します。

00:01:04.000 --> 00:01:09.000
そして今、私はそれをプラチに引き渡します。プラチはマルチプラットフォームフレームワークについて話します。

00:01:09.000 --> 00:01:10.000
Prachi Pai Asnodkar: ありがとう、ジェイク。

00:01:10.000 --> 00:01:16.000
Xcode 13の新機能の1つは、マルチプラットフォームフレームワークのサポートです。

00:01:16.000 --> 00:01:30.000
マルチプラットフォームフレームワークを使用すると、複数のフレームワークを1つに統合し、ターゲット管理を簡素化し、管理する1組のビルドフェーズ、管理する1組のビルド設定を提供します。

00:01:30.000 --> 00:01:35.000
Frutaアプリを見て、この機能を利用するためにプロジェクトを更新しましょう。

00:01:35.000 --> 00:01:37.000
これはFrutaアプリです。

00:01:37.000 --> 00:01:43.000
これは、macOS、iOS、watchOS用に構築されたマルチプラットフォームアプリです。

00:01:43.000 --> 00:01:51.000
また、3つのフレームワークターゲットがあります。各プラットフォームに1つずつ、アプリで使用される一連の共有コードが含まれています。

00:01:51.000 --> 00:02:04.000
3つの別々のフレームワークを維持するには、ビルド設定を同期させ、すべてのソースファイルがコンパイルソースのビルドフェーズに適切に追加されるようにするなど、課題が生じる可能性があります。

00:02:04.000 --> 00:02:12.000
これらの課題に取り組むために、フレームワークの1つをマルチプラットフォームフレームワークに変換することから始めます。

00:02:12.000 --> 00:02:17.000
ここには3つのフレームワークがあります。各プラットフォームに1つずつです。

00:02:17.000 --> 00:02:24.000
これらのターゲットはすべて同一ですが、macOSでのみビルドされるファイルがあります。

00:02:24.000 --> 00:02:34.000
まず、macOSフレームワークターゲットのプロジェクトナビゲーターの「ビルド設定」タブに移動しましょう。

00:02:34.000 --> 00:02:43.000
次に、サポートされているプラットフォームのビルド設定に移動し、任意のプラットフォームを選択して、すべてのプラットフォーム用に構築するフレームワークを構成します。

00:02:43.000 --> 00:02:49.000
また、マルチプラットフォームビルドの許可が自動的に「はい」に設定されていることがわかります。

00:02:49.000 --> 00:02:56.000
これは、必要に応じて、サポートされているプラットフォームごとにこのターゲットを1回構築するようにビルドシステムに通知します。

00:02:56.000 --> 00:03:06.000
これはマルチプラットフォームのターゲットなので、元のmacOSフレームワークには、macOS用に構築するときにのみ構築すべき1つの追加ファイルがあったことを思い出してください。

00:03:06.000 --> 00:03:14.000
これを行うためのフレームワークを設定するために、プラットフォームフィルターを追加して、このファイルがmacOS用にのみビルドされることを指定できます。

00:03:14.000 --> 00:03:19.000
これを行うには、まず[ビルドフェーズ]タブに移動します。

00:03:19.000 --> 00:03:23.000
次に、コンパイルソースのビルドフェーズを展開します。

00:03:23.000 --> 00:03:36.000
最後に、フィルター項目をクリックし、macOS以外のすべてのチェックを外して、macOS専用にビルドするようにIngredient+macOS.swiftを設定します。

00:03:36.000 --> 00:03:47.000
新しいマルチプラットフォームターゲットが設定されたので、フレームワークの他の2つのバリアントは不要になったため、削除できます。

00:03:47.000 --> 00:03:56.000
さらに、フレームワークターゲットは1つしかないため、その新しいターゲットをリンクして埋め込むようにすべてのアプリを設定する必要があります。

00:03:56.000 --> 00:04:03.000
macOSアプリはすでに設定されています。なぜなら、macOSからマルチプラットフォームのターゲットを設定しているからです。

00:04:03.000 --> 00:04:20.000
各アプリターゲットの[一般]タブに移動し、フレームワークとライブラリの構築フェーズにフレームワークを追加することで、iOSおよびwatchOSアプリに新しいフレームワークを追加できます。

00:04:20.000 --> 00:04:27.000
要約すると、macOSフレームワークのターゲットを取り、iOSとwatchOS用に構築できるようにしました。

00:04:27.000 --> 00:04:32.000
macOSのみのソースファイルのプラットフォームフィルタを使用して、そのフレームワークをカスタマイズしました。

00:04:32.000 --> 00:04:39.000
そして最後に、新しいシングルマルチプラットフォームフレームワークターゲットをリンクして埋め込むようにアプリターゲットを設定しました。

00:04:39.000 --> 00:04:42.000
そして、それはXcodeのマルチプラットフォームターゲットです。

00:04:42.000 --> 00:04:47.000
さて、プロジェクト構成を深く掘り下げるジェイクに戻ります。

00:04:47.000 --> 00:04:48.000
ジェイク:ありがとう、プラチ。

00:04:48.000 --> 00:04:59.000
Xcodeプロジェクトのモデリングと設定のベストプラクティスについて話し合い、ビルドのパフォーマンスと正確性を向上させるためにできることをいくつか紹介します。

00:04:59.000 --> 00:05:02.000
まず、スキームのビルドオプションを見てみましょう。

00:05:02.000 --> 00:05:08.000
スキームピッカーをクリックし、スキームを編集し、ビルドセクションに移動します。

00:05:08.000 --> 00:05:10.000
ここで設定できる簡単なことがいくつかあります。

00:05:10.000 --> 00:05:19.000
ビルドオーダーでは、依存関係グラフに従ってプロジェクト内のターゲットが並行して構築される依存関係オーダーを選択することをお勧めします。

00:05:19.000 --> 00:05:25.000
これにより、マルチコアのビルドパフォーマンスが大幅に向上し、継続的インテグレーションからより迅速な結果が得られます。

00:05:25.000 --> 00:05:30.000
対照的に、手動注文の選択は非推奨であり、推奨されません。

00:05:30.000 --> 00:05:39.000
このオプションを使用すると、ビルドが遅くなり、スキームにリストされているターゲット順序がプロジェクトの依存関係と矛盾すると、サイクルエラーが発生する可能性があります。

00:05:39.000 --> 00:05:44.000
スキームビルドオプションのもう1つの重要な設定は、暗黙の依存関係の検索です。

00:05:44.000 --> 00:05:56.000
このオプションをチェックすると、Xcodeは、ビルド設定のリンカーフラグやビルドフェーズのリンクされたライブラリの名前など、プロジェクト内の情報に基づいてターゲット間の依存関係を自動的に追加できます。

00:05:56.000 --> 00:06:04.000
これは、関連するターゲットが、通常は明示的なターゲット依存関係を追加できない異なるプロジェクトにある場合に特に便利です。

00:06:04.000 --> 00:06:19.000
異なるプロジェクト間で明示的なターゲット依存関係を追加できないため、手動の依存関係順序を使用して特定の順序でターゲットを構築している場合、依存関係順序の選択と組み合わせて暗黙の依存関係の検索を有効にすることが、多くの場合、より良い解決策です。

00:06:19.000 --> 00:06:22.000
次に、スクリプトフェーズとビルドルールについて話します。

00:06:22.000 --> 00:06:29.000
プロジェクトのターゲットリストからSmoothyKitターゲットを選択し、[ビルドフェーズ]タブを選択します。

00:06:29.000 --> 00:06:34.000
ここでは、カスタムビルドロジックを含むプロセスレシピスクリプトフェーズがあります。

00:06:34.000 --> 00:06:42.000
その責任の1つは、入力ごとに1つの出力を持つ多数のレシピファイルからコードを生成し、順番に処理することです。

00:06:42.000 --> 00:06:47.000
さて、これらの計算は互いに完全に独立していることに気づくかもしれません。

00:06:47.000 --> 00:06:54.000
これは、それらを並行して実行することで活用できるパフォーマンス最適化の機会を提供します。

00:06:54.000 --> 00:06:57.000
ルールを構築することで、私たちはまさにそれを行うことができます。

00:06:57.000 --> 00:07:01.000
この作業をビルドルールに抽出する方法を見てみましょう。 ルール

00:07:01.000 --> 00:07:08.000
フレームワークのプロジェクトエディタの[ビルドルール]タブに移動し、プラスボタンをクリックして新しいビルドルールを追加します。

00:07:08.000 --> 00:07:16.000
次に、このルールで処理するファイルタイプのファイル拡張子に対応するファイルパターン「*.recipe」を入力します。

00:07:16.000 --> 00:07:19.000
次に、このルールに依存関係を追加します。

00:07:19.000 --> 00:07:26.000
入力として処理する各入力ファイルが自動的に取得されるため、ビルドルールに追加の入力を追加する必要はありません。

00:07:26.000 --> 00:07:33.000
ただし、ルールが処理するファイルごとに生成する出力ファイルのパスをビルドシステムに伝える必要があります。

00:07:33.000 --> 00:07:41.000
プラスボタンをクリックして新しい出力ファイルを追加し、$(DERIVED_ FILE_ DIR)/$ (INPUT_ FILE _BASE) .compiledrecipeを入力します。

00:07:41.000 --> 00:07:49.000
ビルドシステムによって管理される適切な場所を指すため、生成されたファイルをDERIVED_FILE_DIRに書き込むのがベストプラクティスです。

00:07:49.000 --> 00:07:52.000
ソースルートで出力ファイルを生成することは避けるべきです。

00:07:52.000 --> 00:07:58.000
これは、複数のビルドを同時に実行すると、ソース制御に干渉し、競合につながる可能性があります。

00:07:58.000 --> 00:08:03.000
もちろん、スクリプトのフェーズコードをルールにコピーする必要があります。

00:08:03.000 --> 00:08:10.000
スクリプトフェーズに戻り、各ファイルを処理したコードをコピーします。

00:08:10.000 --> 00:08:15.000
その後、ルールに戻り、それを貼り付けます。

00:08:15.000 --> 00:08:18.000
ルールは、処理する入力ごとに1回実行されることを忘れないでください。

00:08:18.000 --> 00:08:37.000
したがって、forループを削除し、$RECIPEを$SCRIPT_INPUT_FILEに置き換えます。これは、処理中の現在の入力ファイルの絶対ファイルパスに対応し、$DERIVED_FILE_DIR/ $RECIPE.compiledrecipeを$SCRIPT_OUTPUT_FILE_0に置き換えます。これは、以下の出力ファイルセクションで

00:08:37.000 --> 00:08:44.000
ファイルパスのスペースやその他の特殊文字が正しく処理されていることを確認するために、変数を引用することを忘れないでください。

00:08:44.000 --> 00:08:45.000
すごい。

00:08:45.000 --> 00:08:47.000
今、ルールで設定すべきことがもう1つあります。

00:08:47.000 --> 00:08:52.000
ルールは、処理する入力ごとに1回実行されると述べました。

00:08:52.000 --> 00:08:57.000
デフォルトでは、ターゲットがコンパイルしているアーキテクチャごとに1回実行されます。

00:08:57.000 --> 00:09:06.000
たとえば、Macアプリのターゲットのルールは、arm64に対して1回、x86_64に対して各入力を1回実行することがあります。

00:09:06.000 --> 00:09:11.000
したがって、4つの入力と2つのアーキテクチャがある場合、ルールは8回呼び出されます。

00:09:11.000 --> 00:09:16.000
これは、ルールの出力がオブジェクトコードなどのアーキテクチャに依存している場合に便利です。

00:09:16.000 --> 00:09:28.000
しかし、この場合、私のルールは基礎となるCPUアーキテクチャから独立した出力を生成するので、「アーキテクチャごとに1回実行」のチェックを外します。

00:09:28.000 --> 00:09:39.000
最後に、ビルドシステムが入力ファイルをビルドルールに伝播するには、フレームワークターゲットのコンパイルソースビルドフェーズにすべての.recipeファイルを追加する必要があります。

00:09:39.000 --> 00:09:51.000
ビルドフェーズに戻り、コンパイルソースを展開し、プラスボタンを使用してレシピファイルを追加します。

00:09:51.000 --> 00:09:53.000
では、スクリプトフェーズに戻りましょう。

00:09:53.000 --> 00:10:02.000
これが行う残りの作業は、複数のテキストファイルの内容を1つのファイルにマージすることで、アプリで実行時により効率的に読み込むことができます。

00:10:02.000 --> 00:10:11.000
そして、より良いソース制御の経験を持つために、私はスクリプトをプロジェクトファイルの外部に保管し、ここでインラインスクリプトエディタからそれらを呼び出しています。

00:10:11.000 --> 00:10:16.000
それでは、package.shへの参照に従ってコードを見てみましょう。

00:10:16.000 --> 00:10:24.000
この場合、すべての入力を一度に処理して1つにまとめる必要があるため、ビルドルールは適切ではありません。

00:10:24.000 --> 00:10:32.000
したがって、並行して実行できる分離されたユニットに分割する方法がないため、この作業をスクリプトフェーズに維持することは理にかなっています。

00:10:32.000 --> 00:10:39.000
しかし、これは最も重要なポイントの1つに私たちをもたらします:スクリプトには入力と出力の依存関係が指定されていません。

00:10:39.000 --> 00:10:52.000
これは、スクリプトフェーズが使用している可能性のあるファイルがわからないため、Xcodeが他のタスクを並行して実行することに関してより保守的でなければならないため、ビルドタスクが間違った順序で実行され、ビルドが遅くなる可能性があります。

00:10:52.000 --> 00:11:03.000
したがって、スクリプトフェーズによって実行される作業がビルド内の他のタスクと比較して正しい順序で行われるように、入力と出力の依存関係を追加することが重要です。

00:11:03.000 --> 00:11:06.000
この特定のスクリプトには、多数の入力があります。

00:11:06.000 --> 00:11:16.000
これらをプロジェクトファイルに1つずつ入力する代わりに、xcfilelistを使用して、外部ファイルを介してこの入力リストを管理できます。

00:11:16.000 --> 00:11:19.000
今からプロジェクトに1つ追加します。

00:11:19.000 --> 00:11:28.000
「ファイル」&gt;「新規ファイル」に移動し、「その他の」セクションの下にある「フェーズファイルリストのビルド」を選択します。

00:11:28.000 --> 00:11:34.000
このスクリプトフェーズで処理される入力ファイルのリストを1行に1つずつ貼り付けます。

00:11:34.000 --> 00:11:41.000
必要に応じて、ポンド記号で行を開始してコメントを書くこともできます。これは、追加のコンテキストを追加するのに最適です。

00:11:41.000 --> 00:11:46.000
次に、スクリプトフェーズからこのxcfilelistを参照します。

00:11:46.000 --> 00:11:52.000
スクリプトフェーズに戻り、入力ファイルリストのxcfilelistへのパスを指定します。

00:11:52.000 --> 00:12:06.000
最後に、ビルドルールで行ったのと同じように、出力内容が書き込まれるファイルパスを提供することで、出力依存関係を指定します。

00:12:06.000 --> 00:12:13.000
もう1つ言及すべきことがあります。

00:12:13.000 --> 00:12:18.000
ビルドルールと同様に、スクリプトフェーズによって提供される重要な環境変数がいくつかあります。

00:12:18.000 --> 00:12:23.000
Package.shに戻って詳しく見てみましょう。 

00:12:23.000 --> 00:12:49.000
ソースでは、SCRIPT_INPUT_FILE_LIST_COUNTを参照します。これは、スクリプトフェーズに渡された入力ファイルリストの総数、SCRIPT_INPUT_FILE_LIST_nを参照します。これは、n番目のインデックスの入力ファイルリストの解決された絶対ファイルパスを参照し、SCRIPT_OUTPUT_FILE_0を参照します。これは、

00:12:49.000 --> 00:12:54.000
以下は、スクリプトフェーズに提供される主要な環境変数の概要です。

00:12:54.000 --> 00:12:59.000
ターゲットのビルド設定は、スクリプトフェーズ環境でも利用できます。

00:12:59.000 --> 00:13:06.000
以下は、ルールを構築するための特定の環境変数と、あまり一般的ではない環境変数の概要です。

00:13:06.000 --> 00:13:12.000
スクリプトフェーズと同様に、ターゲットのビルド設定もビルドルール環境で利用できます。

00:13:12.000 --> 00:13:23.000
わかりました。さて、プロジェクトを構築しようとすると、問題に遭遇します。

00:13:23.000 --> 00:13:27.000
ビルドログに行って、詳しく見てみましょう。

00:13:27.000 --> 00:13:40.000
SmoothieKitはマルチプラットフォームのターゲットであるため、2回構築されています。1回はiOS用、もう1回はwatchOS用です。これは、これらのビルドのそれぞれが同じパスでスクリプトフェーズの出力を生成しようとしていることを意味します。

00:13:40.000 --> 00:13:48.000
ビルドシステムでは、ビルド全体で1つのタスクのみが特定のパスで出力を生成する必要があるため、これは許可されていません。

00:13:48.000 --> 00:13:51.000
これを解決できる方法はいくつかあります。

00:13:51.000 --> 00:13:58.000
簡単な解決策の1つは、スクリプトフェーズの出力パスを変更して、ターゲットが構築されるたびに一意になるようにすることです。

00:13:58.000 --> 00:14:07.000
この場合、プラットフォーム固有のDERIVED_FILE_DIRのような別のビルド設定を使用することを検討し、パスを十分に一意にし、競合を解決します。

00:14:07.000 --> 00:14:17.000
ただし、スクリプトフェーズが行っている実際の作業が各ターゲットのコンテキスト内で同一である場合、同じ作業が2回行われるだけです。

00:14:17.000 --> 00:14:26.000
その場合、スクリプトフェーズを、共有フレームワークターゲットが依存する新しい集約ターゲットに移動する方がより良い選択肢です。

00:14:26.000 --> 00:14:28.000
それが私のプロジェクトのためにやろうとしていることです。

00:14:28.000 --> 00:14:38.000
開始するには、ターゲットリストの下部にあるプラスボタンをクリックし、[その他]タブを選択し、[ターゲットの集計]を選択します。

00:14:38.000 --> 00:14:42.000
私はそれをリソースと呼びます。

00:14:42.000 --> 00:15:06.000
次に、新しいスクリプトフェーズを追加し、フレームワークターゲットから名前、スクリプトソース、入力、出力をコピーします。

00:15:06.000 --> 00:15:19.000
最後に、フレームワークターゲットから元のスクリプトフェーズを削除し、新しい集約ターゲットにターゲット依存関係を追加します。

00:15:19.000 --> 00:15:34.000
このようにして、作業は一度だけ行われ、出力ファイルの競合はなく、フレームワークのiOSとwatchOSの両方のバリアントは、そのスクリプトフェーズに対して正しい順序で構築されます。

00:15:34.000 --> 00:15:37.000
成功する。

00:15:37.000 --> 00:15:41.000
そして今、Prachiに戻って、誰がビルド設定についてあなたにすべて話すつもりです。

00:15:41.000 --> 00:15:43.000
プラチ：ありがとう、ジェイク！

00:15:43.000 --> 00:15:45.000
では、ビルド設定とは何ですか?

00:15:45.000 --> 00:15:52.000
これは、ビルド方法の側面を設定するために、Xcodeターゲットに適用できるプロパティです。

00:15:52.000 --> 00:15:57.000
Xcodeは、ビルド設定を構成するための2つの主要なメカニズムを提供します。

00:15:57.000 --> 00:16:00.000
1つ目は、ビルド設定エディタを介してです。

00:16:00.000 --> 00:16:06.000
2つ目は、構成設定ファイルまたは.xcconfigファイルです。

00:16:06.000 --> 00:16:14.000
まず、ビルド設定エディタを使用してプロジェクト内の設定を管理する方法を見てみましょう。

00:16:14.000 --> 00:16:21.000
ビルド設定エディタを表示するには、まずプロジェクトナビゲーターでプロジェクトを選択する必要があります。

00:16:21.000 --> 00:16:26.000
次に、設定するターゲットを選択してください。

00:16:26.000 --> 00:16:32.000
そして最後に、タブバーの[ビルド設定]タブをクリックします。

00:16:32.000 --> 00:16:37.000
ここから、新しいビルド設定を追加したり、既存の設定を変更したりできます。

00:16:37.000 --> 00:16:46.000
クイックヘルプインスペクタを開いて、選択したビルド設定の追加情報を見つけることもできます。

00:16:46.000 --> 00:16:49.000
ビルド設定は複数のレベルで定義されています。

00:16:49.000 --> 00:16:52.000
これは定義の積み重ねと考えることができます。

00:16:52.000 --> 00:16:59.000
実際、これらのレベルは、レベルフィルターをクリックすることで視覚化できます。

00:16:59.000 --> 00:17:08.000
各列は、ビルド設定を定義できる異なるレベルを表し、右から左に評価されます。

00:17:08.000 --> 00:17:35.000
最低レベルから始めて、現在選択されているSDKによって定義されたデフォルト値、プロジェクトレベルの構成設定ファイル、Xcodeプロジェクトファイルからのプロジェクトレベル設定、構成設定ファイルで定義されたターゲット設定、Xcodeプロジェクトファイルで定義されたターゲットレベルの設定、そして最後に、ビルド設定の解決値があります。

00:17:35.000 --> 00:17:43.000
レベルがビルド設定の明示的な値を持つことを示す太字の設定が表示された場合は、注意してください。

00:17:43.000 --> 00:17:52.000
ビルド設定を管理するためにXcodeが提供するもう1つのメカニズムは、構成設定ファイルまたは.xcconfigファイルです。

00:17:52.000 --> 00:18:12.000
Xcconfigファイルの利点には、より良いソース管理管理、ターゲットまたは構成間で設定の共有、ビルド設定の高度な構成、および開発またはテスト環境に基づいて追加のxcconfigファイルを含める機能が含まれます。

00:18:12.000 --> 00:18:17.000
Xcconfigファイルでビルド設定を作成する方法を見てみましょう。

00:18:17.000 --> 00:18:27.000
最も基本的なレベルでは、ビルド設定は名前、代入演算子、および値で構成されています。

00:18:27.000 --> 00:18:32.000
条件付き構文を使用して、ビルド設定の値を絞り込むことができます。

00:18:32.000 --> 00:18:36.000
条件設定は角括弧を使用して定義されます。

00:18:36.000 --> 00:18:44.000
サポートされている条件には、構成、アーキテクチャ、SDKなどがあります。

00:18:44.000 --> 00:18:51.000
SDK条件に示すように、ワイルドカードはマッチング目的で使用できます。

00:18:51.000 --> 00:18:57.000
おなじみのダブルスラッシュ構文を使用してコメントを追加することもできます。

00:18:57.000 --> 00:19:03.000
ビルド設定は、dollar-parens構文を使用して、別のビルド設定の値に設定できます。

00:19:03.000 --> 00:19:09.000
この例では、MY_OTHER_BUILD_SETTINGがYESに設定されています。

00:19:09.000 --> 00:19:16.000
MY_BUILD_SETTING_NAMEの値は、dollar-parens構文を使用してMY_OTHER_BUILD_SETTINGを評価します。

00:19:16.000 --> 00:19:22.000
MORE_SETTINGSで見られるように、ここでも複数の値を評価できます。

00:19:22.000 --> 00:19:28.000
そして最後に、ビルド設定の既存の値は、$(継承)値で使用できます。

00:19:28.000 --> 00:19:34.000
これにより、既存の値をすべて保持しながら、ビルド設定に追加値を追加できます。

00:19:34.000 --> 00:19:41.000
これは、ビルド設定名であるAPPEND_TO_EXISTING_SETTINGSを使用することもできるため、便利なフォームです。

00:19:41.000 --> 00:19:50.000
ビルド設定評価構文のもう1つの用途は、他のビルド設定のセットからビルド設定を一緒に作成することです。

00:19:50.000 --> 00:19:55.000
まず、コントロール設定から始めます: IS_BUILD_SETTING_ENABLED。

00:19:55.000 --> 00:20:04.000
この設定の値を、MY_BUILD_SETTING_NOとMY_BUILD_SETTING_YESの2つの追加ビルド設定のサフィックスとして使用します。

00:20:04.000 --> 00:20:14.000
最後に、MY_BUILD_SETTINGとIS_BUILD_SETTING_ENABLEDの両方で構成される値を持つようにMY_BUILD_SETTINGを定義します。

00:20:14.000 --> 00:20:24.000
ビルド設定の評価はインサイドアウトで行われるため、最も内側の設定が評価され、IS_BUILD_SETTING_ENABLEDの値であるNOを返します。

00:20:24.000 --> 00:20:33.000
最後に、構成されたBUILD_SETTING_NOは-use_this_oneの値に評価されます。

00:20:33.000 --> 00:20:41.000
ビルド設定を評価する際には、値の基本的な変換を提供するために使用できる一連の演算子があります。

00:20:41.000 --> 00:20:52.000
演算子の3つの分類は、文字列演算子、パス演算子、および置換演算子です。

00:20:52.000 --> 00:21:09.000
サポートされている文字列演算子は、文字列内の文字をエスケープする引用符、文字のケースを変換する下と上、および文字列をさまざまな形式で有効な識別子に変換する識別子です。

00:21:09.000 --> 00:21:20.000
ディレクトリ、ファイル名、基本名、接尾辞、および標準化されたパスを取得するための一連のパス演算子を提供します。

00:21:20.000 --> 00:21:26.000
各パス演算子には、値の一部を置き換えることができる代替演算子があります。

00:21:26.000 --> 00:21:36.000
ビルド設定が空の場合、置換値を提供するデフォルト演算子もあります。それ以外の場合は、ビルド設定の既存の値を使用します。

00:21:36.000 --> 00:21:43.000
最後に見るべき項目は、他のxcconfigファイル内にxcconfigファイルを含める機能です。

00:21:43.000 --> 00:21:45.000
利用可能なメカニズムは2つあります。

00:21:45.000 --> 00:21:51.000
1つ目は、xcconfigファイルがディスクに存在する必要があるインクルードが必要です。

00:21:51.000 --> 00:21:55.000
ファイルが見つからない場合、コンパイラエラーが発生します。

00:21:55.000 --> 00:22:02.000
2つ目はオプションのインクルードで、ディスクに存在する場合はxconfigファイルを含めることができます。

00:22:02.000 --> 00:22:06.000
ファイルが存在しない場合、これは失敗しません。

00:22:06.000 --> 00:22:12.000
パスはXcodeプロジェクトファイルの場所から相対的であることに注意してください。

00:22:12.000 --> 00:22:20.000
では、これらすべての情報を現実世界のシナリオにまとめる方法を見てみましょう。

00:22:20.000 --> 00:22:25.000
この例では、次の問題を解決する方法を見ていきます。

00:22:25.000 --> 00:22:32.000
私たちの開発マシンでは、コンパイラは入力チェックに時間がかかりすぎる式を積極的に警告する必要があります。

00:22:32.000 --> 00:22:39.000
ただし、CIマシンは遅いため、式チェックの時間を増やす必要があります。

00:22:39.000 --> 00:22:48.000
当社のソリューションには、debug、common、ci.xcconfigの3つの構成設定ファイルがあります。

00:22:48.000 --> 00:22:59.000
デバッグxcconfigファイルは、デバッグビルドに使用され、 OTHER_SWIFT_FLAGSビルド設定を介してSwiftコンパイラにいくつかの追加のフラグを渡します。

00:22:59.000 --> 00:23:04.000
一般的なxcconfigファイルには、オプションでci.xcconfigファイルが含まれています。

00:23:04.000 --> 00:23:09.000
また、型式警告を制御するための OTHER_SWIFT_FLAGS 設定も定義しています。

00:23:09.000 --> 00:23:27.000
$(継承)を使用して、debug.xcconfigファイルやデフォルト値200のMAX _EXPRESSION_TIMEのビルド設定評価など、他のフラグ設定が含まれていることを確認します。

00:23:27.000 --> 00:23:34.000
Ci xcconfigファイルは、MAX_EXPRESSION _TIMEのオーバーライド値を定義します。

00:23:34.000 --> 00:23:42.000
最後に、Xcodeは、これらのxcconfigファイルをサポートされている構成レベルの1つに適用する方法を伝える必要があります。

00:23:42.000 --> 00:23:47.000
これは、ここで見られるプロジェクトエディタを通じて行われます。

00:23:47.000 --> 00:23:59.000
設定セクションから、定義されたビルド設定に対して、プロジェクトまたはターゲットレベルでプロジェクトの任意の設定ファイルを適用できます。

00:23:59.000 --> 00:24:08.000
ここでは、debug.xcconfigファイルがFrutaのデバッグ設定のプロジェクトレベルで適用されていることがわかります。

00:24:08.000 --> 00:24:16.000
また、プロジェクト内のターゲットごとにcommon.xcconfigファイルが設定されています。

00:24:16.000 --> 00:24:24.000
解決策を要約すると、デフォルトの演算子を使用してMAX_EXPRESSION_TIMEのデフォルト値を定義しました。

00:24:24.000 --> 00:24:30.000
ci.xcconfigファイルは、CIシステムにのみ存在するため、オプションで含まれていました。

00:24:30.000 --> 00:24:37.000
そして、CI xcconfigファイルでは、MAX_EXPRESSION_TIMEのデフォルト値のオーバーライドが使用されました。

00:24:37.000 --> 00:24:40.000
これは私たちの実用的な例を締めくくります。

00:24:40.000 --> 00:24:44.000
さて、ジェイクに戻って、私たちがカバーしたすべてを見直しましょう。

00:24:44.000 --> 00:24:46.000
ジェイク:ありがとう、プラチ。

00:24:46.000 --> 00:24:47.000
要約しましょう。

00:24:47.000 --> 00:24:55.000
マルチプラットフォームフレームワークと、マルチプラットフォームプロジェクトのビルド設定とビルドフェーズを管理する簡単な方法を提供する方法について学びました。

00:24:55.000 --> 00:25:10.000
依存関係の順序に従って並行してターゲットを構築することで、プロジェクトの構成を改善し、パフォーマンスを構築する方法、ビルドルールとビルドフェーズを適切に使用する方法、および依存関係を指定することの重要性を見ました。

00:25:10.000 --> 00:25:21.000
最後に、ビルド設定、構成設定ファイルを使用してそれらをより簡単に管理する方法を深く掘り下げ、その構文とそれが提供するすべての構造を掘り下げました。

00:25:21.000 --> 00:25:28.000
これらのレッスンが、開発経験を最大限に活用するのに役立つ一連の便利なツールを提供することを願っています。

00:25:28.000 --> 00:25:29.000
見てくれてありがとう!

00:25:29.000 --> 23:59:59.000
♪

