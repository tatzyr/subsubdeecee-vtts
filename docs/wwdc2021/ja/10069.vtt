WEBVTT

00:00:00.000 --> 00:00:05.000
♪ベース音楽の演奏♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:12.000
エリック・ホーンバーガー:研究とケアアプリのコードアロングへようこそ!

00:00:12.000 --> 00:00:19.000
これは、あなたと私が友人のジェイミーのために理学療法アプリを構築する3部構成のシリーズのパート2です。

00:00:19.000 --> 00:00:24.000
フォローしたい場合は、セッションリソースで私たちのプロジェクトを見つけることができます。

00:00:24.000 --> 00:00:27.000
先に進んで、ここにログインします。

00:00:27.000 --> 00:00:33.000
セッション1に参加した場合は、オンボーディングと同意を終えたばかりであることを思い出すでしょう。

00:00:33.000 --> 00:00:36.000
このセッションでは、ああ、ちょっと待って。

00:00:36.000 --> 00:00:38.000
ジェイミーからメッセージを受け取ったようです。

00:00:38.000 --> 00:00:41.000
「アプリの新しいアイデアがいくつかある。」

00:00:41.000 --> 00:00:43.000
「私の最後のメールを見ましたか？」

00:00:43.000 --> 00:00:45.000
追加のアプリ要件。

00:00:45.000 --> 00:00:49.000
ジェイミーは、ノート文書の共同作業にあなたを招待しました。

00:00:49.000 --> 00:00:55.000
さて、今回は何をするか見てみよう！！ よし！

00:00:55.000 --> 00:00:59.000
フォームの表示、一部のデータの保持、動的スケジュール、可動域。わかりました。

00:00:59.000 --> 00:01:09.000
だから、ジェイミーは、彼らがどれだけの睡眠をとったか、彼らがどれだけの痛みを経験しているかについて参加者に尋ねる毎日のチェックイン調査を設定することを望んでいるようです。

00:01:09.000 --> 00:01:15.000
ResearchKitのフォームアイテムを使用して、1つのページに複数の質問を置く方法を紹介します。

00:01:15.000 --> 00:01:21.000
次に、ResearchKit調査の結果を解析し、CareKitに保持する必要があります。

00:01:21.000 --> 00:01:26.000
これにより、完了リングがいっぱいになり、タスクカードのUIが更新されます。

00:01:26.000 --> 00:01:39.000
また、CareKitでより高度なスケジュールを作成する方法について詳しく説明し、ResearchKitと一緒にこれらのスケジュールの1つを使用して、参加者に膝の可動域を測定するよう促します。

00:01:39.000 --> 00:01:43.000
ここではカバーすることがたくさんあるので、飛び込みましょう！

00:01:43.000 --> 00:01:46.000
毎日のチェックイン調査から始めます。

00:01:46.000 --> 00:01:53.000
オンボーディングタスクで行ったように、スケジュールとCareKitタスクを定義することから始めます。

00:01:53.000 --> 00:02:00.000
毎日のチェックインのはずなので、毎朝午前8時にスケジュールしましょう。例えば、午前8時にしましょう。

00:02:00.000 --> 00:02:05.000
一意の識別子と先ほど定義したスケジュールを使用して、チェックインタスクを作成します。

00:02:05.000 --> 00:02:10.000
そしてもちろん、私たちはここ私たちの店でそれを維持する必要があります。

00:02:10.000 --> 00:02:13.000
これはすべて、オンボーディングタスクで行ったのとまったく同じです。

00:02:13.000 --> 00:02:17.000
うまくいけば、それはあなたに馴染みを感じ始めています!

00:02:17.000 --> 00:02:26.000
そして、オンボーディングタスクと同様に、次のステップはCareFeedViewControllerにジャンプして、このタスクを表示する方法をCareKitに伝えることです。

00:02:26.000 --> 00:02:31.000
今回は、私たちの解決策をもう少し一般的なものにしましょう。

00:02:31.000 --> 00:02:34.000
現在の日付のすべてのタスクを取得します。 

00:02:34.000 --> 00:02:39.000
次に、タスクごとにビューコントローラーを作成し、そのビューコントローラーをリストに追加します。

00:02:39.000 --> 00:02:42.000
これは、タスクを追加するにつれて、もう少しうまく拡張されるはずです。

00:02:42.000 --> 00:02:49.000
現在、このfetchTasksメソッドまたはこのviewControllerメソッドを実際に定義していません。

00:02:49.000 --> 00:02:54.000
ファイルをもう少し下にドロップダウンして、それらを書き出す必要があります。

00:02:54.000 --> 00:02:56.000
これが私たちのfetchTasksメソッドです。

00:02:56.000 --> 00:03:05.000
まず、特定の日付のタスククエリを作成し、スケジュールされたイベントがないタスクを除外することを指定します。

00:03:05.000 --> 00:03:09.000
これは、毎日起こらないタスクがあるときに機能します。

00:03:09.000 --> 00:03:13.000
例えば、毎週月曜日に薬を服用するための処方箋を与えられたとしましょう。

00:03:13.000 --> 00:03:19.000
火曜日と水曜日には、その処方箋はまだあなたに割り当てられていますが、服用する薬はありません。

00:03:19.000 --> 00:03:24.000
このプロパティは、そのようなタスクがクエリから返されないことを保証します。

00:03:24.000 --> 00:03:31.000
クエリが戻ってきたら、フェッチしたタスクを完了ハンドラに渡します。

00:03:31.000 --> 00:03:36.000
また、タスクを受け取り、ビューコントローラーを返すメソッドに記入する必要があります。

00:03:36.000 --> 00:03:45.000
タスクのIDを検査し、チェックインタスクの場合は、パート1で導入した新しいSurveyTaskViewControllerを使用します。

00:03:45.000 --> 00:03:52.000
以前と同様に、タスク、eventQuery、およびstoreManagerへの参照を提供します。

00:03:52.000 --> 00:04:00.000
また、ResearchKitの調査と、ResearchKitの結果をCareKitの結果値の配列に変換する機能に合格する必要があります。

00:04:00.000 --> 00:04:12.000
これら2つの方法をすぐに書きますが、まず、アプリ、ResearchKit、CareKitがどのように連携するかを見てみましょう。

00:04:12.000 --> 00:04:16.000
私たちのアプリはResearchKit調査を作成します。

00:04:16.000 --> 00:04:22.000
ResearchKitが引き継ぎ、調査フローを通じて参加者を案内します。

00:04:22.000 --> 00:04:28.000
ORKTaskResultが生成され、アプリに返されます。

00:04:28.000 --> 00:04:36.000
その後、私たちのアプリはResearchKitの結果をCareKitの結果値に変換し、CareKitのストアで維持します。

00:04:36.000 --> 00:04:42.000
新しい結果を保存すると、完了リングがいっぱいになり、タスクカードのUIが更新されます。

00:04:42.000 --> 00:04:45.000
では、この2つの方法に取り組みましょう。

00:04:45.000 --> 00:04:49.000
Surveys.swiftでそれらを定義します。

00:04:49.000 --> 00:04:53.000
以下で使用する識別子をいくつか用意しました。"

00:04:53.000 --> 00:05:01.000
ResearchKit調査を作成する方法と、結果をCareKitの結果値に変換する方法が必要です。

00:05:01.000 --> 00:05:11.000
参加者が得る睡眠の量と彼らが経験する痛みの量との間に関連性があるかどうかを発見したいので、2つの質問を含むフォームを作成します。

00:05:11.000 --> 00:05:17.000
formStepには、一意の識別子、タイトル、およびいくつかのテキストが必要です。

00:05:17.000 --> 00:05:23.000
また、フォームをスキップ可能にしたくないので、非オプションとしてマークします。

00:05:23.000 --> 00:05:27.000
次に、2つのアイテムを作成しましょう。

00:05:27.000 --> 00:05:32.000
最初は痛みについて尋ね、私たちはそれを非オプションの質問にします。

00:05:32.000 --> 00:05:42.000
つまり、フォーム自体をスキップすることはできず、この特定の質問に対する回答なしにフォームを提出することもできないということです。

00:05:42.000 --> 00:05:46.000
回答形式も提供する必要があることがわかります。

00:05:46.000 --> 00:05:53.000
回答形式は、どのような回答を期待し、どのようにユーザーに入力を促すかをResearchKitに伝えます。

00:05:53.000 --> 00:05:58.000
彼らは重みを入力していますか、画像を選択していますか、それとも声を録音していますか?

00:05:58.000 --> 00:06:06.000
この場合、UISliderを作成するORKScaleAnswerFormatを使用することを選択します。

00:06:06.000 --> 00:06:15.000
スライダーは、iOSユーザーにとって使い慣れたインターフェースです。直感的で、紙の調査で円を埋めるよりもはるかに優れた体験を提供します。

00:06:15.000 --> 00:06:31.000
最大ペインスコア10、最小値1を指定し、ラウンドナンバーのみが許可されるようにステップサイズを1に設定し、最小値と最大値の説明を提供します。

00:06:31.000 --> 00:06:36.000
さて、もう少し下にドロップして、もう1つのアイテムを作成しましょう：sleepItem。

00:06:36.000 --> 00:06:43.000
これはpainItemとほぼ同じで、ほぼ同じ回答形式も使用します。

00:06:43.000 --> 00:06:50.000
唯一の違いは識別子であり、最低睡眠時間を0時間、最大睡眠時間を12時間に変更したことです。

00:06:50.000 --> 00:07:01.000
次に、これら2つのアイテムをフォームアイテムに渡し、単一のフォームステップでORKOrderedTaskを作成するだけです。

00:07:01.000 --> 00:07:08.000
2番目の関数は、ResearchKitタスクの結果を取り、持続するCareKit値の配列を作成することになっています。

00:07:08.000 --> 00:07:17.000
しかし、このコードを書く前に、ResearchKitのタスク結果の構造を見て、それを解析する方法をよりよく理解しましょう。

00:07:17.000 --> 00:07:22.000
ORKTaskResultsはネストされたタイプであることを理解することが重要です。

00:07:22.000 --> 00:07:30.000
チェックイン調査のルート結果から始めて、checkin.formまでドリルダウンしたいと思います。

00:07:30.000 --> 00:07:37.000
Checkin.formには2人の子供がいて、それぞれを掘り下げる必要があります。

00:07:37.000 --> 00:07:46.000
まず、ペインアイテム識別子に与えられた答えを見つけ、次にスリープアイテム識別子の答えを見つけたいです。

00:07:46.000 --> 00:07:51.000
私たちはそれらが両方ともスケールの質問の結果であることを知っており、それらからスケールの答えを得ることができます。

00:07:51.000 --> 00:07:56.000
この例では、4と11です。

00:07:56.000 --> 00:08:03.000
だから、それは視覚的に見えるものであり、これはコードで同じプロセスがどのように見えるかです。

00:08:03.000 --> 00:08:09.000
ルート結果から始めて、フォーム識別子でマークされた最初の子を見つけます。

00:08:09.000 --> 00:08:18.000
その結果、独自の子を持ち、ORKScaleQuestionResultタイプですべての子を抽出することができ、そのうちの2つがあることがわかっています。

00:08:18.000 --> 00:08:26.000
痛みの答えは痛みの識別子でマークされた最初のもので、睡眠の答えは睡眠識別子でマークされた最初のものです。

00:08:26.000 --> 00:08:31.000
両方ともscaleAnswerプロパティを持ちます。

00:08:31.000 --> 00:08:39.000
答えが手に入ったら、それらをCareKitの結果値に変換する必要があります。1つは睡眠用、もう1つは痛み用です。

00:08:39.000 --> 00:08:42.000
ここでの種類のプロパティはオプションです。

00:08:42.000 --> 00:08:47.000
設定する必要はありませんが、後で値を調べたい場合に役立ちます。 後で値を調べることができます。

00:08:47.000 --> 00:08:50.000
パート3でこれが役に立つ理由がわかります!

00:08:50.000 --> 00:08:55.000
最後にすべきことは、この関数から2つの値を返すことです。

00:08:55.000 --> 00:08:59.000
そのすべてが整っているので、私たちの毎日のチェックインは行くのに良いはずです!

00:08:59.000 --> 00:09:04.000
アプリを実行して、私たちがどのようにやっているか見てみましょう。

00:09:04.000 --> 00:09:10.000
パート1ではすでにオンボーディングを完了しているので、同意フローを再度通過する必要はありません。

00:09:10.000 --> 00:09:17.000
これは私たちのアプリの真のコンテンツであり、私たちが作成したばかりのCareKitチェックインタスクは、私たちが期待する場所です。

00:09:17.000 --> 00:09:22.000
カードをタップすると、ResearchKitの調査に行くことができます。

00:09:22.000 --> 00:09:24.000
私たちは先に進んで、ここでいくつかの答えを与えます。

00:09:24.000 --> 00:09:31.000
痛みのために4のように、8時間の睡眠で行きましょう。

00:09:31.000 --> 00:09:41.000
ケアフィードに戻ると、上部の完了リングがいっぱいになり、ResearchKitからの回答がCareKitに正常に解析されたことがわかります。

00:09:41.000 --> 00:09:43.000
これは本当に良さそうです。

00:09:43.000 --> 00:09:52.000
そこで、マルチ質問フォームでチェックイン調査を完了し、データが私たちが望むようにCareKitに保持されていることを確認しました。

00:09:52.000 --> 00:09:54.000
それは私たちがそこの半分くらいにいることを意味します!

00:09:54.000 --> 00:10:01.000
CareKitの高度なスケジュールに移り、後でモーションタスクの範囲に適用します。

00:10:01.000 --> 00:10:07.000
チェックインタスクやその前のオンボーディングタスクと同様に、最初のステップはスケジュールを定義することです。

00:10:07.000 --> 00:10:12.000
しかし、私たちはこれのためにもう少し関与する何かをするつもりです。

00:10:12.000 --> 00:10:19.000
ジェイミーは、時間が経つにつれて参加者に可動域を測定するように依頼する頻度を減らすよう求めました。

00:10:19.000 --> 00:10:33.000
具体的には、参加者に最初の週は毎日可動域を測定するように促すスケジュールを設定したいと考えていますが、その後、月末まで週に1回だけ、その後は二度と測定しません。

00:10:33.000 --> 00:10:39.000
だから、最初の週は1日1回、残りの月は週に1回。

00:10:39.000 --> 00:10:47.000
いくつかの重要な日付を定義することから始めましょう：thisMorning、nextWeek、nextMonth。

00:10:47.000 --> 00:10:55.000
さて、CareKitでより微妙なスケジュールを作成したい場合は、OCKScheduleElementが仕事のためのツールです。

00:10:55.000 --> 00:11:02.000
スケジュール要素には、開始日、終了日があり、その期間中に一定間隔で繰り返されます。

00:11:02.000 --> 00:11:10.000
ここのdailyElementは今朝始まり、来週に終わり、毎日繰り返されます。

00:11:10.000 --> 00:11:13.000
2番目の要素はweeklyElementです。

00:11:13.000 --> 00:11:19.000
それは来週始まり、来月に終わり、毎週繰り返されます。

00:11:19.000 --> 00:11:31.000
2つの要素がわかったので、それらを一緒に構成して複合スケジュールを作成し、そのスケジュールを使用して新しい範囲のモーションタスクを作成できます。

00:11:31.000 --> 00:11:34.000
もちろん、私たちの店にも追加する必要があります。 それも必要です。

00:11:34.000 --> 00:11:43.000
他のタスクと同様に、次のステップはCareFeedに戻り、CareKitにこのタスクを表示する方法を指定することです。

00:11:43.000 --> 00:11:52.000
もう一度、SurveyTaskViewControllerを使用し、回答を抽出するための調査と機能を提供する必要があります。

00:11:52.000 --> 00:12:00.000
Surveys.swiftに戻り、始める前に少し構造を提供するためにそれらをスタブしましょう。

00:12:00.000 --> 00:12:04.000
さて、モーションタスクの範囲は実際にはかなり簡単です。

00:12:04.000 --> 00:12:09.000
実際のところ、それは事前定義されたタスクとしてResearchKitに組み込まれています。

00:12:09.000 --> 00:12:15.000
識別子を与えて、どの膝を測定するかを指定するだけです。

00:12:15.000 --> 00:12:28.000
現在、事前定義されたタスクには完了ステップが組み込まれており、表示されるメッセージは合理的なデフォルトですが、ユースケースに合わせたカスタムメッセージを表示したいと思います。

00:12:28.000 --> 00:12:32.000
そこで、標準の完了ステップを省略するようにResearchKitに伝えます。

00:12:32.000 --> 00:12:40.000
次に、私たちは自分自身を定義し、特に理学療法に関連する励ましのメッセージを与えます。

00:12:40.000 --> 00:12:41.000
それが最初の機能です。

00:12:41.000 --> 00:12:48.000
2つ目は、ResearchKitの結果からCareKitの結果値に変換する場所です。

00:12:48.000 --> 00:12:52.000
うまくいけば、これは今身近に感じ始めています。

00:12:52.000 --> 00:12:58.000
これを行う方法はたくさんありますが、今日は最初の運動範囲の結果にたどり着くまで掘り下げます。

00:12:58.000 --> 00:13:01.000
そして、私たちは1つしかないことを知っています。

00:13:01.000 --> 00:13:14.000
運動結果の範囲は、実際には多くの有用な特性を持っていますが、ユースケースに最も興味を持っているのは範囲であり、参加者が膝をどこまで曲げることができたかを測定します。

00:13:14.000 --> 00:13:20.000
キーパスと一緒に種類フィールドを使用して、後でこの値を簡単に検索できます。

00:13:20.000 --> 00:13:24.000
ところで、それはパート3の予兆です。

00:13:24.000 --> 00:13:29.000
さて、それは結果値を抽出するための私たちの機能をまとめます。

00:13:29.000 --> 00:13:32.000
いいね！私たちはすべて準備が整っていると思います。

00:13:32.000 --> 00:13:35.000
私たちのアプリを実行して、それがどのように機能するかをお見せします。

00:13:35.000 --> 00:13:40.000
最初に確認したいのは、私たちのスケジュールが意図した通りに機能していることです。

00:13:40.000 --> 00:13:45.000
モーション範囲タスクは、最初の週に毎日表示されるはずです。

00:13:45.000 --> 00:13:53.000
8日、9日、10日をページスルーすると、モーションタスクの範囲が毎日表示されます。

00:13:53.000 --> 00:14:03.000
しかし、私が来週に出るとき、それはここで月曜日を除いて表示されなくなります。これは、私たちがまだ表示したい週の1日です。

00:14:03.000 --> 00:14:06.000
ここでは、まだ週に1回しか表示されません。

00:14:06.000 --> 00:14:14.000
しかし、私たちがさらに未来に出て行くと、来月までずっと、それはもうまったく現れません。

00:14:14.000 --> 00:14:19.000
CareKitのスケジュールは、このようなレジメンを事前にプログラムするのに最適な方法です。

00:14:19.000 --> 00:14:27.000
今日に戻って、これを試してみましょう。

00:14:27.000 --> 00:14:33.000
開始をタップすると、指示のステップは何をすべきかを理解するのに役立ちます。

00:14:33.000 --> 00:14:40.000
私が始めると、Siriは私に音声ガイダンスをくれるので、私は彼女の指示に従うつもりです。

00:14:40.000 --> 00:14:42.000
Siri: デバイスを左膝の上に置きます。

00:14:42.000 --> 00:14:45.000
画面をタップして、左膝をできるだけ伸ばします。

00:14:45.000 --> 00:14:50.000
続けるにはどこでもタッチしてください。

00:14:50.000 --> 00:14:55.000
終わったら、左膝をスタート位置に戻し、どこでもタップします。

00:14:55.000 --> 00:15:01.000
エリック：いいね。

00:15:01.000 --> 00:15:04.000
それはかなりきちんとしていますよね?

00:15:04.000 --> 00:15:15.000
通常、あなたは医者のオフィスを訪問する必要がありますし、セラピストはあなたがこのような測定を行うのを手伝いますが、ResearchKitは参加者が自分の家で測定を行うのを助けることができます。

00:15:15.000 --> 00:15:19.000
ジェイミーは私たちの進歩に本当に感銘を受けると思います。

00:15:19.000 --> 00:15:24.000
この直後に彼にFaceTimeして、TestFlightで私たちのアプリの最新バージョンを彼に送ります。

00:15:24.000 --> 00:15:34.000
ジェイミーに進捗状況をスピードアップさせていますが、researchandcare.orgでフレームワークに関する詳細情報を見つけるか、GitHubのソースコードを読むことができます。

00:15:34.000 --> 00:15:37.000
セッション1では、オンボーディングを設定しました。

00:15:37.000 --> 00:15:40.000
このセッションでは、2つのタスクをスケジュールしました。

00:15:40.000 --> 00:15:47.000
3回目と最後のセッションに再び参加して、ResearchKitとCareKitがアプリを完成させるのにどのように役立つかを確認してください。

00:15:47.000 --> 00:15:49.000
また近いうちに会いましょう!

00:15:49.000 --> 23:59:59.000
♪

