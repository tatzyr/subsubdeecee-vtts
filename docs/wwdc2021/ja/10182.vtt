WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:11.000
こんにちは。

00:00:11.000 --> 00:00:18.000
私はクラウドファイルプロバイダーチームのヨハネス・フォートマンで、macOSのファイルプロバイダーをお見せするためにここにいます。

00:00:18.000 --> 00:00:23.000
ユーザーのファイルをmacOSに同期するクラウドストレージベンダーなら、あなたは正しい話です。

00:00:23.000 --> 00:00:31.000
紹介の後、ファイルの同期に関連するユーザーフローのいくつかについて説明します。

00:00:31.000 --> 00:00:40.000
次に、Xcodeのフローの1つを実行し、それぞれのサポートを実装する順序について説明します。

00:00:40.000 --> 00:00:48.000
追加のオプションの統合ポイントと次のステップの概要を簡単に説明します。

00:00:48.000 --> 00:00:54.000
まず、ファイルプロバイダーがあなたのために何ができるかについて話しましょう。

00:00:54.000 --> 00:01:01.000
ファイルプロバイダーフレームワークを使用すると、クラウドストレージをmacOSのファイルシステムに統合できます。

00:01:01.000 --> 00:01:08.000
新しいAPFS機能を使用して、ユーザーファイルやフォルダのオンデマンドダウンロードを可能にします。

00:01:08.000 --> 00:01:11.000
APIは完全にユーザースペースにあります。

00:01:11.000 --> 00:01:24.000
macOSではカーネル拡張機能を廃止しているので、FUSEやKAUTHに頼ってシステムコールを傍受したり、オンデマンドでファイルをダウンロードしたりする場合、これはあなたにとって良い選択肢です。

00:01:24.000 --> 00:01:31.000
あなたがしなければならないのは、アップロード、ダウンロードを処理し、リモートで何が変わったかを伝えることだけです。

00:01:31.000 --> 00:01:36.000
システムは、ローカルで何が変更されたかを教えてくれ、残りのすべてを処理します。

00:01:36.000 --> 00:01:43.000
この機能はすべて、システム、特にFinderとうまく統合されています。

00:01:43.000 --> 00:01:45.000
プロバイダーがサイドバーに表示されます。

00:01:45.000 --> 00:01:53.000
ファイルのステータスはFinderに表示され、追跡され、UIとのカスタマイズ可能な統合ポイントがいくつかあります。

00:01:53.000 --> 00:01:59.000
システムと統合するアプリ拡張機能を実装します。

00:01:59.000 --> 00:02:03.000
そのライフサイクルは、ユーザーの行動によって駆動されます。

00:02:03.000 --> 00:02:12.000
最初は、ユーザーがクラウドストレージでアクセスできるファイルツリーを表すドメインを作成します。

00:02:12.000 --> 00:02:21.000
システムは、Finderのサイドバーでそのドメインを公開し、ファイルシステム内のドメインのルートディレクトリを作成します。

00:02:21.000 --> 00:02:29.000
この時点で、実際のデータはデバイス上にはありませんが、ユーザーはすでにルートとのやり取りを開始できます。

00:02:29.000 --> 00:02:31.000
これはどのように機能しますか?

00:02:31.000 --> 00:02:34.000
ルートは、私たちがデータレスディレクトリと呼ぶものです。

00:02:34.000 --> 00:02:42.000
これはAPFSの新しい種類のオブジェクトであり、それらを認識して対話するためのAPIがあります。

00:02:42.000 --> 00:02:49.000
しかし、さらに重要なことに、データレスオブジェクトは、準備ができていないプロセスに対して完全に透明です。

00:02:49.000 --> 00:02:57.000
読み取りはダウンロードをトリガーし、ファイルは読み取りの再開が許可される前にデータレスプロパティを失います。

00:02:57.000 --> 00:03:08.000
このプレゼンテーションでは、ファイルプロバイダーフレームワークを使用して、データレスファイルを読み取る処理時に呼び出されるコールバックを実装する方法を見ていきます。

00:03:08.000 --> 00:03:12.000
同期して実行するために、いくつかのユーザーフローを見てみましょう。

00:03:12.000 --> 00:03:19.000
同期ダウンと同期アップの両方をカバーする4つの重要なフローを見ていきます。

00:03:19.000 --> 00:03:27.000
各フローでは、新しいデータが必要なときはいつでも、システムが拡張機能を呼び出していることがわかります。

00:03:27.000 --> 00:03:36.000
クラウドサーバーと話をしてそのデータを取得し、最後に完了ハンドラーに電話して返信できることをお見せします。

00:03:36.000 --> 00:03:44.000
まず、データレスファイルが読み込まれたときに何が起こるかを見ていきます。

00:03:44.000 --> 00:03:55.000
カーネルがデータレスファイルへの読み取りアクセスを検出すると、拡張機能がファイルの内容を取得するために呼び出されている間、そのシステムコールは一時停止されます。

00:03:55.000 --> 00:03:59.000
拡張機能のfetchContentsメソッドが呼び出されます。

00:03:59.000 --> 00:04:02.000
通常、ダウンロードを実行するために実装します。

00:04:02.000 --> 00:04:06.000
ダウンロードが完了すると、完了ハンドラが呼びます。

00:04:06.000 --> 00:04:15.000
ファイルの内容は、開いているファイル記述子を無効にすることなく、以前のデータレスファイルを埋めるシステムに渡されます。

00:04:15.000 --> 00:04:19.000
その後、システムは読み取りアクセスの一時停止を解除します。

00:04:19.000 --> 00:04:26.000
ファイルがデータレスではなくなったので、その後の読み取りに拡張機能を含める必要はありません。

00:04:26.000 --> 00:04:29.000
ディレクトリの列挙は非常によく似ています。

00:04:29.000 --> 00:04:33.000
カーネルはreaddir呼び出しを検出して一時停止します。

00:04:33.000 --> 00:04:38.000
拡張機能を呼び出して、そのディレクトリ内の項目を列挙します。

00:04:38.000 --> 00:04:42.000
これらのアイテムのメタデータをサーバーから取得します。

00:04:42.000 --> 00:04:45.000
そして、あなたはいくつかの項目で返信します。

00:04:45.000 --> 00:04:48.000
列挙はページ分割されています。

00:04:48.000 --> 00:04:56.000
アイテムの完全なセットよりも少ないものを返すことができ、システムは中断したところから列挙を再開します。

00:04:56.000 --> 00:05:03.000
すべてのページが列挙されると、システムは元の呼び出しを通過できるようにします。

00:05:03.000 --> 00:05:16.000
ファイルの場合と同様に、ディレクトリが列挙されると、後続のreaddir呼び出しはディスクの内容を使用し、拡張子を巻き込む必要はありません。

00:05:16.000 --> 00:05:20.000
しかし、それらのコンテンツがリモートで変更された場合はどうなりますか?

00:05:20.000 --> 00:05:24.000
さて、リモート変更をシステムに通知する必要があります。

00:05:24.000 --> 00:05:27.000
それがどのように機能するかを見てみましょう。

00:05:27.000 --> 00:05:34.000
リモート変更がある場合、サーバーはMacにプッシュ通知を送信できます。

00:05:34.000 --> 00:05:45.000
そのプッシュ通知に応答して、特別な列挙子である.workingSetから列挙する必要がある変更があることをシステムに通知します。

00:05:45.000 --> 00:05:51.000
システムは回転し、.workingSetで変更された項目を列挙します。

00:05:51.000 --> 00:05:58.000
syncAnchorと呼ばれる継続トークンは、新しい変更のみを列挙するために使用されます。

00:05:58.000 --> 00:06:01.000
このトークンは、あなたの拡張機能によって定義されます。

00:06:01.000 --> 00:06:05.000
システムは、最後に列挙されたsyncAnchorを追跡します。

00:06:05.000 --> 00:06:09.000
enumerateChanges(from syncAnchor:)メソッドで列挙子を呼び出します。

00:06:09.000 --> 00:06:19.000
それに応じて、変更されたアイテムを返品し、完了したら、次回使用できる新しいsyncAnchorをお知らせください。

00:06:19.000 --> 00:06:23.000
システムは非同期に移動し、ユーザーに表示されるファイルを更新します。

00:06:23.000 --> 00:06:31.000
APFSの比較とスワップ機能を使用して、その過程でローカルの変更が失われないようにしています。

00:06:31.000 --> 00:06:41.000
さらに、このシステムは、ファイル調整やその他のアドバイザリーロックメカニズムと統合して、アプリケーションと調整します。

00:06:41.000 --> 00:06:50.000
これら3つのメカニズムを使用すると、クラウドからファイルを同期し、リモートでの変更が発生した場合に同期させることができます。

00:06:50.000 --> 00:06:54.000
最後のフローは、ローカルの変更をクラウドに同期させることを扱います。

00:06:54.000 --> 00:07:06.000
システムは、ローカルアイテムが変更されたときに検出し、拡張機能のmodifyItemメソッドを呼び出し、変更されたフィールドの正確なセットを渡します。

00:07:06.000 --> 00:07:11.000
低レベルのイベントを、同期に意味のあるイベントに集約します。

00:07:11.000 --> 00:07:20.000
たとえば、カーネルは安全な保存を検出し、アイテム識別子を新しいファイルIDに透過的に再マップします。

00:07:20.000 --> 00:07:29.000
一貫したパッケージレベルの変更を要求して提示すると、システムもパッケージファイルを圧縮します。

00:07:29.000 --> 00:07:35.000
modifyItem呼び出しに応答して、アイテムサーバー側の状態を更新します。

00:07:35.000 --> 00:07:47.000
ファイルの内容が変更された場合、システムは変更されたファイルのクローンを手渡すので、さらに変更された場合でも一貫したバージョンをアップロードできます。

00:07:47.000 --> 00:07:51.000
完了したら、完了ハンドラを呼び出します。

00:07:51.000 --> 00:07:59.000
完了ハンドラは、アイテムのバージョン識別子を更新し、拡張機能への変更の配信を確認するために使用されます。

00:07:59.000 --> 00:08:04.000
完了ハンドラは、アイテムの最終状態もパラメータとして取ります。

00:08:04.000 --> 00:08:11.000
クラウド内のアイテムを更新すると、リモート変更と競合する場合など、状態が変更される可能性があります。

00:08:11.000 --> 00:08:21.000
最終状態を元に戻すと、システムはクラウド内の真実と一致するようにアイテムのローカル状態を更新することができます。

00:08:21.000 --> 00:08:24.000
5番目の流れがあります:立ち退き。

00:08:24.000 --> 00:08:34.000
システムは、ディスク容量が緊急に必要になった場合、ファイルプロバイダの拡張子を関与させることなく、自動的にローカルファイルを追い出します。

00:08:34.000 --> 00:08:41.000
これは、たとえば、ユーザーがビデオを録画したり、ソフトウェアアップデートをダウンロードしたりしているときに発生する可能性があります。

00:08:41.000 --> 00:08:51.000
システムは、これらの新しいファイルを書き込むために必要なディスク容量を解放するために必要な、最近使用されていないファイルの最小セットを追い出します。

00:08:51.000 --> 00:08:54.000
トランジションを見直しましょう。

00:08:54.000 --> 00:09:02.000
立ち退きはローカルファイルをデータレスファイルに変え、ダウンロードはデータレスファイルをローカルファイルに変えます。

00:09:02.000 --> 00:09:09.000
ファイルは、リモートで作成されている場合や、ローカルで作成されている場合は、データレスで開始できます。

00:09:09.000 --> 00:09:12.000
しかし、すべてのファイルが追い出すことができるわけではありません。

00:09:12.000 --> 00:09:19.000
システムは、アップロードされたものとして報告したファイルのみを追い出し、再度ダウンロードできるようにします。

00:09:19.000 --> 00:09:25.000
したがって、ローカルファイルには、アップロードされたファイルとアップロードされていないファイルの2種類があります。

00:09:25.000 --> 00:09:33.000
ローカル編集後、新しいバージョンのファイルをアップロードする必要があるため、追い出不能な状態に戻ります。

00:09:33.000 --> 00:09:44.000
これまでのこのプレゼンテーションでは、アクセス時にファイルをダウンロードし、ローカル編集後にファイルをアップロードするために、ファイルプロバイダーの拡張子がシステムによってどのように呼び出されるかを見てきました。

00:09:44.000 --> 00:09:54.000
ディスク圧力トリガーの立ち退きには関与していませんが、エクステンションからの立ち退きをトリガーまたは防止する方法があります。

00:09:54.000 --> 00:09:56.000
これは多くの理論でした。

00:09:56.000 --> 00:10:00.000
実際のフローの1つを見てみましょう。

00:10:00.000 --> 00:10:08.000
私たちは、小さなローカルファイルサーバーを実行し、そのサーバーに対して動作するファイルプロバイダの拡張子を埋め込むアプリを書きました。

00:10:08.000 --> 00:10:10.000
それはFruitBasketと呼ばれています。

00:10:10.000 --> 00:10:16.000
私はすでにそのサーバーにログインしているので、サイドバーにルートフォルダのエントリがあります。

00:10:16.000 --> 00:10:23.000
また、システムがそのフォルダ内のアイテムにデータレスエントリを作成する原因となったルートフォルダも選択しました。

00:10:23.000 --> 00:10:31.000
ファイル名の横にあるクラウドダウンロードアイコンから、アイテムがデータレスであることがわかります。

00:10:31.000 --> 00:10:35.000
コマンドラインで「cat」を使用してファイルを読み込みます。

00:10:35.000 --> 00:10:40.000
ファイルがデータレスであるため、拡張機能でコンテンツがフェッチされます。

00:10:40.000 --> 00:10:52.000
私はすでにXcodeの拡張機能に添付し、このコンテンツのフェッチを傍受するためのブレークポイントを設定しました。

00:10:52.000 --> 00:10:56.000
「猫」が走っていて、私たちのブレークポイントがヒットしました。

00:10:56.000 --> 00:11:02.000
コンテンツフェッチの完了をブロックしているため、ターミナルウィンドウの読み取りもブロックされます。

00:11:02.000 --> 00:11:09.000
Finderウィンドウで、クラウドアイコンが進行状況インジケータに置き換えられたことに注意してください。

00:11:09.000 --> 00:11:13.000
システムは、ダウンロードステータスの一貫したビューを持っています。

00:11:13.000 --> 00:11:21.000
もちろん、実際にはダウンロード中ではなくデバッガでブロックされているため、進行状況は更新されません。

00:11:21.000 --> 00:11:23.000
続けましょう。

00:11:23.000 --> 00:11:30.000
完了ハンドラを呼び出す直前に2番目のブレークポイントを設定しました。

00:11:30.000 --> 00:11:36.000
現時点では、プロバイダーはファイルの内容をディスク上のローカルURLにダウンロードしました。

00:11:36.000 --> 00:11:44.000
完了ハンドラを呼び出すと、システムはユーザーに表示されるファイルの内容をダウンロードしたものと交換します。

00:11:44.000 --> 00:11:47.000
Xcodeで続行して、システムのブロックを解除しましょう。

00:11:47.000 --> 00:11:58.000
Finderのステータスは、ファイルをローカルとして表示するように更新され、catプロセスがブロックされたという読み取りが成功します。

00:11:58.000 --> 00:12:05.000
ブレークポイントはまだ設定されていますが、ファイルがローカルになったので、ブレークポイントに当たらずに「cat」を再度実行できます。

00:12:05.000 --> 00:12:15.000
これらの読み取りは、通常のローカルファイルに反しており、拡張子は含まれません。

00:12:15.000 --> 00:12:21.000
もちろん、これはサンプルファイルプロバイダの機能セットのほんの一部にすぎません。

00:12:21.000 --> 00:12:26.000
APIの全機能セットを取り上げ、このセッションの一環としてソースコードを公開しています。

00:12:26.000 --> 00:12:31.000
私たちが話したフローの実装にどのようにアプローチできるかについて話しましょう。

00:12:31.000 --> 00:12:35.000
まず、同期する準備ができていることをシステムに伝えたいと思います。 同期する

00:12:35.000 --> 00:12:39.000
これにより、Finderのサイドバーにエントリが表示されます。

00:12:39.000 --> 00:12:46.000
これらのエントリをドメインと呼び、通常はクラウドサーバーのログインセッションに対応します。

00:12:46.000 --> 00:12:54.000
各ドメインには一意の識別子があり、それを表示するために、新しいインスタンスを作成し、マネージャーオブジェクトを介して追加します。

00:12:54.000 --> 00:12:56.000
ドメインを削除することもできます。

00:12:56.000 --> 00:13:05.000
通常、ユーザーがログアウトするときにこれを行いますが、最初の開発とテスト中にも役立ちます。

00:13:05.000 --> 00:13:14.000
ドメインがFinderに表示されると、エントリに移動するとすぐに、システムはアイテムの列挙を要求します。

00:13:14.000 --> 00:13:16.000
では、次にそれを実装しましょう。

00:13:16.000 --> 00:13:20.000
ここでの最初のステップは、アイテムクラスを実装することです。

00:13:20.000 --> 00:13:26.000
そのインスタンスは、列挙する個々のエントリを表します。

00:13:26.000 --> 00:13:33.000
次に、システムが要求したときにアイテムでシステムを呼び出す列挙子を実装します。

00:13:33.000 --> 00:13:39.000
この時点で、サイドバーのエントリに移動することでディレクトリを見ることができます。

00:13:39.000 --> 00:13:43.000
もちろん、これらのディレクトリ内のすべてのファイルはデータレスになります。

00:13:43.000 --> 00:13:47.000
コンテンツフェッチを実装して、それを変更しましょう。

00:13:47.000 --> 00:13:52.000
fetchContentsメソッドは、データレスファイルの1つを開くと、システムによって呼び出されます。

00:13:52.000 --> 00:14:00.000
私たちの仕事は、ファイルの内容をディスク上の場所にダウンロードし、その場所のURLで完了ハンドラを呼び出すことです。

00:14:00.000 --> 00:14:07.000
システムは、コンテンツを使用してデータレスファイルを埋め、私たちのためにそれらをクリーンアップします。

00:14:07.000 --> 00:14:13.000
ディレクトリ構造を同期させるために、別のタイプの列挙子を実装します。

00:14:13.000 --> 00:14:15.000
これはリモートでの変更を同期します。

00:14:15.000 --> 00:14:20.000
システムは、最初にcurrentSyncAnchorメソッドを呼び出して同期アンカーを取得します。

00:14:20.000 --> 00:14:25.000
データベースの変更カーソルを記述するデータオブジェクトを返します。

00:14:25.000 --> 00:14:32.000
何かが変更されたことを知らせるたびに、システムはあなたが提供した最後のアンカーから変更を要求します。

00:14:32.000 --> 00:14:37.000
その後、変更を返し、最後に新しいアンカーを返すことができます。

00:14:37.000 --> 00:14:41.000
最後のステップは、変更の同期を許可することです。

00:14:41.000 --> 00:14:51.000
システムがローカルファイルへの変更を検出した場合、既存のアイテムを作成、変更、または削除するための3つの方法のいずれかを呼び出します。

00:14:51.000 --> 00:14:54.000
作成方法を簡単に見てみます。

00:14:54.000 --> 00:15:00.000
システムは、作成を依頼する新しいアイテムを手渡します。

00:15:00.000 --> 00:15:06.000
これはシステムアイテムですが、自分のアイテムと同じプロトコルに従います。

00:15:06.000 --> 00:15:11.000
システムはまた、アイテムに関心のある一連のフィールドを手渡します。

00:15:11.000 --> 00:15:20.000
たとえば、アイテムには拡張属性が添付されているかどうかがあり、それを記述するフィールドがあります。

00:15:20.000 --> 00:15:26.000
コンテンツフィールドが設定されている場合、システムはコンテンツを含むファイルURLを渡します。

00:15:26.000 --> 00:15:31.000
フォルダやシンボリックリンクを記述するアイテムにはコンテンツがありません。

00:15:31.000 --> 00:15:44.000
あなたの仕事は、新しいローカルアイテムのデータをサーバーにアップロードし、結果のリモートアイテムで完了ハンドラを呼び出すことです。

00:15:44.000 --> 00:15:46.000
そして、それだけです。

00:15:46.000 --> 00:15:59.000
この時点で、macOS上の機能的なファイルプロバイダーがオンデマンドでファイルを提供し、クラウドへのローカル変更とMacへのリモート変更を伝播します。

00:15:59.000 --> 00:16:07.000
ファイルプロバイダーフレームワークには多くの追加のオプションAPIがあり、システムとのより細かい統合が可能です。

00:16:07.000 --> 00:16:10.000
見てみましょう。 見てみましょう。

00:16:10.000 --> 00:16:16.000
アイコンの装飾は、Finderでアイテムを視覚的に飾るために使用できます。

00:16:16.000 --> 00:16:22.000
ファイルアイコンにバッジをつけたり、フォルダをエンボス加工したり、共有ステータスを表示したりできます。

00:16:22.000 --> 00:16:29.000
アプリで宣言されたUTTypeを介して、装飾用のカスタムアートワークを提供します。

00:16:29.000 --> 00:16:38.000
コンテキストメニューアクションを使用すると、ユーザーはコンテキストメニューを介してファイルに対してカスタムアクションを実行できます。

00:16:38.000 --> 00:16:42.000
UIと非UIのバリエーションがあります。

00:16:42.000 --> 00:16:52.000
拡張機能のInfo.plistで宣言されたNSPredicatesを使用して、これらのアクションが適用されるファイルを定義できます。

00:16:52.000 --> 00:17:00.000
フライト前のアラートを使用すると、意図しない結果をもたらす可能性のあるアクションを実行する前にユーザーに警告することができます。

00:17:00.000 --> 00:17:08.000
アラートUIとアラートをアクティブにする基準は、Info.plistでも設定されています。

00:17:08.000 --> 00:17:10.000
それで、あなたの次のステップは何ですか?

00:17:10.000 --> 00:17:14.000
さて、まず第一に、セッションのサンプルコードをダウンロードできます。

00:17:14.000 --> 00:17:19.000
それは非常に包括的で、あなたに多くの指針を与えるでしょう。

00:17:19.000 --> 00:17:23.000
新しい拡張機能の既存のアプリにターゲットを追加します。

00:17:23.000 --> 00:17:27.000
起動するのに役立つXcodeテンプレートがあります。

00:17:27.000 --> 00:17:37.000
そこから、あなたがしなければならないのは、私たちが議論した順序でメソッドスタブを実装することだけで、すぐに起動して実行できます。

00:17:37.000 --> 00:17:39.000
このセッションをご覧いただきありがとうございます。

00:17:39.000 --> 23:59:59.000
macOSでファイルプロバイダの拡張子を楽しみにしています。

