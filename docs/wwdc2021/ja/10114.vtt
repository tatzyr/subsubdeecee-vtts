WEBVTT

00:00:00.000 --> 00:00:05.000
♪ベース音楽の演奏♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:12.000
ロス・ルボー:こんにちは、WWDC21へようこそ。

00:00:12.000 --> 00:00:16.000
私の名前はロス・ルボーで、StoreKitチームのエンジニアです。

00:00:16.000 --> 00:00:27.000
今日はStoreKitについて話します。これは実際には、クライアント側のコードを実装し、アプリ内購入用のサーバーを構築し、顧客をサポートし、払い戻しを処理するのに役立つように設計された3つのセッションの1つです。

00:00:27.000 --> 00:00:33.000
このセッションはMeet StoreKit 2で、他の2つのセッションはWWDC21で見つけることができます。

00:00:33.000 --> 00:00:36.000
このセッションでは、クライアント側の機能と実装に焦点を当てます。

00:00:36.000 --> 00:00:39.000
では、始めましょう!

00:00:39.000 --> 00:00:44.000
StoreKitはiOS 3で導入されて以来、あなたとあなたのビジネスにとって素晴らしい機会を生み出しました。

00:00:44.000 --> 00:00:52.000
今日、それは4つのAppleプラットフォームに存在し、ゲームからニュースアプリ、インディーズタイトルから国際的なヒットまで、すべてをサポートしています。

00:00:52.000 --> 00:00:58.000
長年にわたり、Xcodeでのオファーコード、ファミリー共有、StoreKitテストなどの優れた機能を導入してきました。

00:00:58.000 --> 00:01:02.000
しかし、今年、私たちは最初に戻ることにしました。

00:01:02.000 --> 00:01:06.000
今日は、StoreKit 2をご紹介できることを嬉しく思います!

00:01:06.000 --> 00:01:17.000
StoreKit 2は、iOS、macOS、tvOS、watchOSでアプリ内購入を操作するための、モダンで柔軟なSwift APIの新しいセットです。

00:01:17.000 --> 00:01:21.000
私たちは、Swiftファーストの考え方でStoreKitを新たに見てきました。

00:01:21.000 --> 00:01:29.000
私たちは、シンプルでありながら強力なAPIを作成するために、非同期/待機パターンを使用したSwift並行性など、最新の言語機能のいくつかを採用しました。

00:01:29.000 --> 00:01:39.000
また、アプリ内購入取引を大幅に更新し、作業がはるかに簡単になり、より多くの情報と高いセキュリティも提供しました。

00:01:39.000 --> 00:01:47.000
また、ビジネスの成長に使用できるより深い洞察を提供するために、サブスクリプション専用のより強力なAPIを追加しました。

00:01:47.000 --> 00:01:57.000
StoreKit 2 APIは、現在存在するのと同じStoreKitフレームワーク内にあり、すべてのAPIを置き換えるのではなく、コアなアプリ内購入体験に焦点を当てています。

00:01:57.000 --> 00:02:09.000
新しいStoreKit 2 APIは、製品、購入、トランザクション情報、トランザクション履歴、サブスクリプションステータスの5つの主要な分野で構成されています。

00:02:09.000 --> 00:02:18.000
今日は、これらの各分野の概要を説明し、同僚のJakobが、対応するStoreKit 2 APIを実際のコードで使用する方法を紹介します。

00:02:18.000 --> 00:02:24.000
まず、StoreKitの構成要素である製品と購入から始めましょう。

00:02:24.000 --> 00:02:29.000
StoreKit 2製品構造体は、慣れ親しんだStoreKit製品オブジェクトのスーパーチャージバージョンです。

00:02:29.000 --> 00:02:36.000
まず、製品タイプや拡張サブスクリプション情報など、追加データを追加しました。

00:02:36.000 --> 00:02:43.000
StoreKit 2では、顧客があなたの紹介オファーの対象となるかどうかを調べるなど、簡単に行うことができます。

00:02:43.000 --> 00:02:47.000
また、StoreKit 2製品を新機能と前方互換性のあるものにしています。

00:02:47.000 --> 00:02:56.000
これは、BackingValueと呼ばれるラッピングタイプを追加することで達成しました。これにより、製品を直接サブスクリプト化することで、製品に含まれるデータを取得できます。

00:02:56.000 --> 00:03:06.000
これは、将来的に製品にデータを追加すると、古いバージョンのStoreKit 2を搭載したオペレーティングシステムを実行しているSDKやデバイスでも、StoreKit 2で常にアクセスできることを意味します。

00:03:06.000 --> 00:03:13.000
これは、最新の機能を使用して、顧客ベースのより大きなセクションに新しい機能を提供できることを意味します。

00:03:13.000 --> 00:03:18.000
StoreKit 2では、製品タイプ自体の静的関数を呼び出すことで製品をリクエストします。

00:03:18.000 --> 00:03:24.000
これは、既存のSKProductsRequestと同様に、App Storeから製品メタデータを要求します。

00:03:24.000 --> 00:03:31.000
しかし、新しいSwift並行性非同期/待機パターンのおかげで、StoreKit 2製品リクエストには1行のコードしか必要ありません。

00:03:31.000 --> 00:03:37.000
同様に、StoreKit 2で製品を購入することは、もう1つの簡単な1行のタスクです。

00:03:37.000 --> 00:03:44.000
購入は現在、製品タイプのインスタンスメソッドです。つまり、取得したばかりの製品を取り、直接購入を呼び出すことができます。

00:03:44.000 --> 00:03:51.000
購入方法もasync/awaitを使用するため、コード内でインラインで購入結果が得られます。

00:03:51.000 --> 00:03:54.000
今、私たちはすべての購入が同じではないことを知っています。

00:03:54.000 --> 00:04:01.000
デフォルト設定を超えて購入行動を変更したい場合、StoreKit 2には購入オプションがあります。

00:04:01.000 --> 00:04:06.000
購入オプションは、購入の単一のプロパティを記述するアイテムです。

00:04:06.000 --> 00:04:11.000
購入オプションは、購入方法に渡すセットに構成できます。

00:04:11.000 --> 00:04:16.000
StoreKit 2には、数量やプロモーションオファーなどの購入オプションが含まれています。

00:04:16.000 --> 00:04:20.000
そして、StoreKit 2では、アプリアカウントトークンと呼ばれる新しいオプションを追加しています。

00:04:20.000 --> 00:04:27.000
アプリアカウントトークンは、どのアプリのユーザーアカウントがトランザクションを開始し、完了したかを追跡する方法です。

00:04:27.000 --> 00:04:33.000
これは、アプリが所有するアカウントにリンクできる、生成する不透明なトークンです。

00:04:33.000 --> 00:04:39.000
唯一の要件はUUID形式に準拠することであるため、アプリアカウントトークンを生成するのは簡単です。

00:04:39.000 --> 00:04:47.000
購入時にアプリアカウントトークンを購入オプションとして送信すると、このトークンはその購入の取引情報に返されます。

00:04:47.000 --> 00:04:51.000
アプリアカウントトークンは、デバイス間でもトランザクション情報に永遠に残ります。

00:04:51.000 --> 00:05:02.000
アプリが独自のアカウントシステムをサポートしている場合、購入に使用されたApple IDやデバイスに関係なく、各アプリ内アカウントが行った購入を追跡するのに役立ちます。

00:05:02.000 --> 00:05:09.000
それで、私たちはApp Storeから製品を入手し、購入を開始することについて話しました。その購入が完了するとどうなりますか?

00:05:09.000 --> 00:05:15.000
ご想像のとおり、StoreKitは暗号署名された情報とともに成功したトランザクションを返します。

00:05:15.000 --> 00:05:17.000
聞き覚えがありますよね?

00:05:17.000 --> 00:05:22.000
さて、StoreKit 2は、アプリ内購入取引にこれまでで最大のアップデートをもたらしています。

00:05:22.000 --> 00:05:28.000
まず、StoreKit 2はすべてのトランザクションに個別に署名されたオブジェクトを提供します。

00:05:28.000 --> 00:05:37.000
それだけでなく、StoreKit 2から、アプリ内購入トランザクション情報は、JSONという非常に一般的で使いやすい形式で提供されるようになりました。

00:05:37.000 --> 00:05:47.000
また、安全な暗号署名がStoreKit購入の重要な部分であることを知っているので、現在、JSON Web Signatureと呼ばれるウェブ全体で使用されている共通の標準を使用しています。

00:05:47.000 --> 00:05:56.000
さらに、署名されたオブジェクトに含まれるすべての情報は、ネイティブのStoreKit APIを通じて利用可能になり、アプリのコードでこのデータを簡単に操作できるようになります。

00:05:56.000 --> 00:05:59.000
実際、それがどれほど簡単かをお見せします。

00:05:59.000 --> 00:06:03.000
これは、実際のコードでこれらのAPIをデモンストレーションしたJakobです。

00:06:03.000 --> 00:06:04.000
ヤコブ・スワンク:こんにちは、私はヤコブです。

00:06:04.000 --> 00:06:07.000
私はStoreKitチームのエンジニアです。

00:06:07.000 --> 00:06:13.000
今日は、アプリでStoreKit 2を起動して実行するのがいかに簡単かをお見せできることに本当に興奮しています。

00:06:13.000 --> 00:06:17.000
右側には、私が構築しているポケットカーというアプリがあります。

00:06:17.000 --> 00:06:24.000
このセッションのリソースセクションでこのアプリのサンプルコードをダウンロードし、それに従うことができます。

00:06:24.000 --> 00:06:26.000
このアプリには2つの主要なビューがあります。

00:06:26.000 --> 00:06:30.000
私の集めた車の眺めと私の店の眺めがあります。

00:06:30.000 --> 00:06:33.000
お店に行きましょう。

00:06:33.000 --> 00:06:38.000
現在、販売可能な商品がないので、私の店は空っぽです。

00:06:38.000 --> 00:06:41.000
私は先に進んで、今それらを実装するつもりです。

00:06:41.000 --> 00:06:46.000
すぐに起動して実行するために、私はXcodeでStoreKitテストを使用しています。

00:06:46.000 --> 00:06:53.000
これにより、App Store Connectで製品を定義する前に、ストアを構築してテストすることができます。

00:06:53.000 --> 00:07:02.000
Xcodeプロジェクトでは、販売したい製品を定義するStoreKit設定ファイルをすでに作成しました。

00:07:02.000 --> 00:07:10.000
これは、私がStoreKitに使用していたのと同じ設定ファイルです。何も変更したり移行したりする必要はありません。

00:07:10.000 --> 00:07:16.000
ここには、すべての製品識別子を含むplistもあります。

00:07:16.000 --> 00:07:23.000
アプリに組み込まれたリソースファイルとして含まれているので、実行時に使用できます。

00:07:23.000 --> 00:07:32.000
これらの製品を店舗に表示するには、まず表示したい製品識別子のセットを使用して製品リクエストを行う必要があります。

00:07:32.000 --> 00:07:39.000
StoreKit 2では、Product構造体で静的メソッドを呼び出すだけでこれを行うことができます。

00:07:39.000 --> 00:07:50.000
App Storeから製品を受け取ったら、タイプ別に分けたいです。

00:07:50.000 --> 00:08:04.000
製品タイプは、App Storeサーバーで定義されているタイプのプロパティを提供するようになったため、StoreKit 2で簡単にこれを行うことができます。

00:08:04.000 --> 00:08:10.000
私のアプリでは、燃料、車、ナビゲーションパッケージの3種類の製品を販売しています。

00:08:10.000 --> 00:08:19.000
燃料は消耗品です。一度使用すると、なくなってしまうので、すべての消耗品を燃料アレイに入れます。

00:08:19.000 --> 00:08:29.000
車は非消耗車です。

00:08:29.000 --> 00:08:31.000
車を購入すると、私はそれを永遠に所有します。

00:08:31.000 --> 00:08:36.000
だから、私はすべての非消耗品を車のアレイに入れます。

00:08:36.000 --> 00:08:49.000
ナビゲーションパッケージは、3つのレベルのサービスを備えたサブスクリプション製品です。

00:08:49.000 --> 00:08:55.000
私の顧客は一度に1つのレベルのサービスを購読することができ、定期的に請求されます。

00:08:55.000 --> 00:09:00.000
また、サービスレベルを変更したい場合は、いつでもアップグレードまたはダウングレードできます。

00:09:00.000 --> 00:09:10.000
App Storeはサービスレベルごとに製品を返すので、すべての自動更新サブスクリプションをサブスクリプション配列に入れます。

00:09:10.000 --> 00:09:21.000
また、各タイプ内の製品を、最低から最高までの価格で並べ替えたいです。

00:09:21.000 --> 00:09:34.000
私のアプリを実行して、私がこれまでに何をしたかを確認しましょう。

00:09:34.000 --> 00:09:36.000
今、私は店に移動します。

00:09:36.000 --> 00:09:37.000
うわー！

00:09:37.000 --> 00:09:43.000
以前、私の店は空いていましたが、今では私のすべての製品が展示されてかなり素晴らしく見えます。

00:09:43.000 --> 00:09:57.000
たった1行のコードで、App Storeからアプリの製品をリクエストすることができ、その後、受け取ったメタデータのみに基づいてそれらの製品をグループ化してソートすることができ、ストアUIを簡単に構築することができました。

00:09:57.000 --> 00:10:02.000
今、私の製品は素晴らしく見えますが、購入ボタンをタップしても何も起こりません。

00:10:02.000 --> 00:10:07.000
それは、私の店での購入方法が何もしないからです。

00:10:07.000 --> 00:10:10.000
StoreKitで購入を開始する必要があります。

00:10:10.000 --> 00:10:15.000
製品の購入方法を呼び出すだけで、これを行うことができます。

00:10:15.000 --> 00:10:32.000
ロスが述べたように、StoreKit 2はSwiftの新しい並行性機能を使用するためにゼロから構築されました。

00:10:32.000 --> 00:10:43.000
これにより、私のアプリは、私のコードを読みやすくするために、その購入の結果を購入して処理するためのコードを同じコンテキスト内で保持することができます。

00:10:43.000 --> 00:10:47.000
購入が完了すると、PurchaseResultが返されます。

00:10:47.000 --> 00:11:03.000
このPurchaseResultは、購入が成功したかどうか、またはユーザーが購入をキャンセルした、または購入が親からの追加の銀行の検証または承認を必要とするなど、他のエラーのない状態で完了したかどうかを知らせます。

00:11:03.000 --> 00:11:06.000
各ケースを処理するために、私はそれらを切り替えるだけです。

00:11:06.000 --> 00:11:19.000
PurchaseResultが成功状態にある場合、検証結果も得られます。

00:11:19.000 --> 00:11:25.000
検証結果には、検証済みと未検証の2つのケースが含まれています。

00:11:25.000 --> 00:11:34.000
StoreKit 2では、トランザクションタイプには、署名されたトランザクションを表すJWSペイロードが含まれています。

00:11:34.000 --> 00:11:48.000
私のアプリがStoreKit 2からトランザクションを受信するたびに、トランザクションは、ペイロードがこのデバイス用の私のアプリのApp Storeによって署名されているかどうかを確認するための検証プロセスを通過しています。

00:11:48.000 --> 00:11:49.000
あなたはそれを正しく聞きました。

00:11:49.000 --> 00:11:53.000
StoreKit 2はあなたのために取引の検証を行います。

00:11:53.000 --> 00:12:01.000
もちろん、検証結果をどのように処理するかは、完全に私と私のビジネスのニーズ次第です。

00:12:01.000 --> 00:12:07.000
私のアプリでは、StoreKitから受け取ったこの取引が確認されていることを確認します。

00:12:07.000 --> 00:12:14.000
私の店では、VerificationResultに使用できるcheckVerifiedメソッドを作成します。

00:12:14.000 --> 00:12:26.000
結果が未確認の場合、私は自分のfailedVerificationエラーをスローして、アプリの他の部分に警告します。

00:12:26.000 --> 00:12:32.000
結果が確認されたら、トランザクションのラップを解除して発信者に返します。

00:12:32.000 --> 00:12:37.000
これで、購入結果にこのcheckVerifiedメソッドを使用できます。

00:12:37.000 --> 00:12:55.000
最後に、取引が確認されると、ユーザーにコンテンツを配信します。

00:12:55.000 --> 00:13:09.000
ユーザーがコンテンツを取得したら、StoreKitにトランザクションを完了するように指示する必要があります。

00:13:09.000 --> 00:13:19.000
その後、UIが更新されるように、それを返却する必要があります。

00:13:19.000 --> 00:13:26.000
私のアプリには、私が維持しているアカウントデータベースがあります。

00:13:26.000 --> 00:13:37.000
App Storeで署名されたトランザクションを取得したときに、この情報をアプリが常に利用できるように、アプリの現在のログインユーザーをStoreKitの購入に含めたい。

00:13:37.000 --> 00:13:49.000
ログインアカウントのトークン化されたバージョンを使用してappAccountToken購入オプションを作成し、そのオプションを購入方法に渡すことで、これを行うことができます。

00:13:49.000 --> 00:14:00.000
わかりました。

00:14:00.000 --> 00:14:03.000
購入方法の実装の準備が整いました。

00:14:03.000 --> 00:14:13.000
私のアプリをもう一度実行しましょう。

00:14:13.000 --> 00:14:16.000
今、私たちは私の店に戻って、私はかなり冒険的な気分です。

00:14:16.000 --> 00:14:22.000
だから、私はいつもバイクが欲しかったので、バイクを購入するつもりです。

00:14:22.000 --> 00:14:27.000
購入が適切に開始されたことを示すStoreKitからの支払いシートがあります。

00:14:27.000 --> 00:14:32.000
タップして購入を確認します。

00:14:32.000 --> 00:14:36.000
その後、StoreKitは購入が成功したことを示すアラートを表示します。

00:14:36.000 --> 00:14:47.000
そのアラートを却下した後、購入ボタンが緑色のチェックマークに変わり、アプリが取引を信頼し、バイクが配達されたことを示しています。

00:14:47.000 --> 00:14:50.000
ここで注意したい重要なことがもう1つあります。

00:14:50.000 --> 00:15:00.000
前に言ったように、顧客はアカウントで追加の検証を行う必要があるか、購入が完了する前に親の承認が必要になることがあります。

00:15:00.000 --> 00:15:08.000
このような場合、product.purchase()から受け取った購入結果は保留状態になります。

00:15:08.000 --> 00:15:19.000
つまり、顧客がアカウントの確認を完了した後、または親が承認した後、私のアプリは完了した購入を反映するようにUIを更新する必要があります。

00:15:19.000 --> 00:15:31.000
これらのトランザクションの更新を聞くには、トランザクションタイプの静的プロパティを反復する必要があります。

00:15:31.000 --> 00:15:38.000
このプロパティは無限の非同期シーケンスです。

00:15:38.000 --> 00:15:48.000
つまり、キャンセルするか、forループから抜け出すかを選択するまで、StoreKitから入ってくるトランザクションの更新を反復し続けることを意味します。

00:15:48.000 --> 00:15:59.000
ここでは、ストアが割り当て解除されたときに更新リスナーを明示的にキャンセルするために使用できるタスクハンドルを返すデタッチタスクを作成しています。

00:15:59.000 --> 00:16:09.000
StoreKit 2から受け取るすべてのトランザクションと同様に、ユーザーにコンテンツを配信する前に、検証結果が検証されているかどうかを確認したい。

00:16:09.000 --> 00:16:14.000
以前に定義したcheckVerifiedメソッドを使用できます。

00:16:14.000 --> 00:16:35.000
そして、購入応答と同様に、確認済みのトランザクションを取得したら、ユーザーにコンテンツを配信する必要があります。

00:16:35.000 --> 00:16:47.000
そしてもちろん、私はいつも取引を終える必要があります。

00:16:47.000 --> 00:16:54.000
アプリが起動したらすぐにトランザクション更新リスナーを開始し、1つも見逃さないようにすることが非常に重要です。

00:16:54.000 --> 00:17:00.000
アプリの起動の直後に起こる、私の店が作成されたらすぐにこれを行うつもりです。

00:17:00.000 --> 00:17:19.000
アップデートリスナーをテストするために、Xcodeテスト環境でAsk To Buyを有効にして、保留中の購入応答をシミュレートします。

00:17:19.000 --> 00:17:29.000
これを行うには、StoreKit設定ファイルを選択し、[エディタ]メニューで[購入依頼を有効にする]を選択します。

00:17:29.000 --> 00:17:43.000
私のアプリをもう一度実行して購入しましょう。

00:17:43.000 --> 00:17:52.000
今回は、支払いシートで確認した後、購入を完了するために許可を求める必要があるというStoreKitからの新しいアラートが表示されます。

00:17:52.000 --> 00:17:56.000
先に進んでAskをタップします。

00:17:56.000 --> 00:18:00.000
購入応答は、保留中の状態で私のアプリに返されます。

00:18:00.000 --> 00:18:13.000
購入を承認するには、XcodeトランザクションマネージャーでStoreKitテストを開き、右上隅の[承認]ボタンをクリックします。

00:18:13.000 --> 00:18:14.000
すごい！

00:18:14.000 --> 00:18:25.000
トランザクションを承認した直後に、アップデートリスナーは検証結果を受け取り、UIはすぐに承認された購入を表示するように変更されました。

00:18:25.000 --> 00:18:30.000
今、私はクルーズする真新しい標準的な5人乗りを持っています。

00:18:30.000 --> 00:18:46.000
製品をリクエストし、購入を開始し、さまざまな購入結果に対応し、トランザクションの整合性を確認し、保留中の取引の更新をApp Storeから受け取るのがいかに簡単かを示しました。すべてStoreKit 2を使用します。

00:18:46.000 --> 00:18:53.000
それでは、ロスに戻って、ユーザーの取引履歴とサブスクリプションステータスの操作について紹介しましょう。

00:18:53.000 --> 00:18:57.000
ロス：うわー！これらの新しいAPIが動作しているのを見るのはかなり驚くべきことです。

00:18:57.000 --> 00:19:01.000
そして、自動検証、これ以上何が欲しいですか?

00:19:01.000 --> 00:19:02.000
それは何ですか?

00:19:02.000 --> 00:19:05.000
あなたは暗号が大好きで、それでも自分でデータを検証したいですか?

00:19:05.000 --> 00:19:07.000
心配しないでください。

00:19:07.000 --> 00:19:14.000
StoreKit 2の自動検証はセキュリティの水準を上げますが、独自の検証を完全に置き換えるものではありません。

00:19:14.000 --> 00:19:19.000
いつものように、セキュリティは強さ、時間、複雑さのスペクトルにあります。

00:19:19.000 --> 00:19:22.000
検証に関するスクープを少し後でお伝えします。

00:19:22.000 --> 00:19:30.000
まず、私と同じくらいStoreKit 2の取引に興奮しているなら、私たちがあなたに彼らと一緒に働くための多くの新しい方法を提供していると聞いて気に入るでしょう。

00:19:30.000 --> 00:19:36.000
ユーザーのトランザクション履歴に完了したトランザクションを照会するための新しいAPIセットを追加します。

00:19:36.000 --> 00:19:42.000
StoreKit 2では、1回のAPI呼び出しでユーザーの過去のすべてのトランザクションにアクセスできます。

00:19:42.000 --> 00:19:45.000
また、製品の最新のトランザクションにアクセスすることもできます。

00:19:45.000 --> 00:19:49.000
したがって、サブスクリプションの最新の更新だけを見たい場合は、できます。

00:19:49.000 --> 00:19:57.000
そして、あなたが知る必要がある一番のことは、ユーザーが今アクセスするために支払った製品であることを知っています。

00:19:57.000 --> 00:20:02.000
そこで、私たちはその情報をCurrentEntitlementsと呼ばれる単一の関数にまとめました。

00:20:02.000 --> 00:20:10.000
現在の資格には、ユーザーのトランザクション履歴にあるすべての非消耗品と、現在アクティブなすべてのサブスクリプショントランザクションが含まれています。

00:20:10.000 --> 00:20:16.000
これにより、ユーザーがアプリで支払ったすべてのロックを解除するために必要なすべての情報が揃っています。

00:20:16.000 --> 00:20:24.000
そして、これはユーザーが今すぐアクセスする必要があるもののみを表すため、取り消されたトランザクションは応答に含まれません。

00:20:24.000 --> 00:20:30.000
トランザクション履歴の永続的な部分ではないため、消耗品も含まれていません。

00:20:30.000 --> 00:20:32.000
今、あなたは「待ちきれない!」と考えているに違いない。

00:20:32.000 --> 00:20:35.000
いつ私のアプリでこれらの呼び出しを開始できますか?

00:20:35.000 --> 00:20:41.000
さて、StoreKit 2では、ユーザーがこれまでに完了したすべてのトランザクションは、あなたがそれを要求するとすぐにあなたのアプリで利用可能になります。

00:20:41.000 --> 00:20:50.000
これは、ユーザーが新しいデバイスにアプリをインストールすると、アプリを初めて開いたときにどの製品にアクセスする権利があるかを知ることができることを意味します。

00:20:50.000 --> 00:20:56.000
さらに、取引履歴はユーザーのデバイス間で自動的に更新されます。

00:20:56.000 --> 00:21:04.000
顧客が1つのデバイスで購入すると、アプリはインストールされている他のすべてのデバイスで購入を見ることができます。

00:21:04.000 --> 00:21:10.000
実際、別のデバイスでの購入時にアプリが実行されている場合は、新しいトランザクションについて通知されます。

00:21:10.000 --> 00:21:17.000
ヤコブは、アプリが起動したらすぐに取引に耳を傾けることが重要であり、これが真実であるもう一つの理由であると述べました。

00:21:17.000 --> 00:21:24.000
したがって、これはすべて、アプリが新しいデバイスに再インストールまたはダウンロードされたときに、ユーザーが完了したトランザクションを復元する必要がないことを意味します。

00:21:24.000 --> 00:21:28.000
すべてがStoreKitによって自動的に取得され、最新の状態に保つ必要があります。

00:21:28.000 --> 00:21:33.000
しかし、人々は何百万もの場所で何百万もの方法でAppleデバイスを使用しています。

00:21:33.000 --> 00:21:39.000
まれに、ユーザーがトランザクションを持つべきだと思っているが、それが表示されない場合は、App Storeの同期APIを使用できます。

00:21:39.000 --> 00:21:44.000
これにより、すべてのStoreKit 2トランザクションがすぐに再同期されます。

00:21:44.000 --> 00:21:51.000
これはrestoreCompletedTransactions APIの代替品であり、ユーザーが同期を開始できるUIをアプリに提供する必要があります。

00:21:51.000 --> 00:21:58.000
しかし、StoreKit 2の自動同期のおかげで、ユーザーが手動で同期を開始する必要があることは非常にまれです。

00:21:58.000 --> 00:22:02.000
自動同期は、ほとんどのケースをカバーする必要があります。

00:22:02.000 --> 00:22:07.000
ユーザーが手動同期を開始する必要がある場合は、アカウントを認証する必要があります。

00:22:07.000 --> 00:22:13.000
このため、このAPIはユーザーの入力に応じてのみ使用してください。

00:22:13.000 --> 00:22:20.000
最後に、StoreKit 2 APIを使用して行われたすべてのトランザクションは、元のStoreKit APIで利用可能であり、その逆も同様です。

00:22:20.000 --> 00:22:27.000
したがって、アプリに既存のトランザクションがある場合は、使用を開始するとすぐにStoreKit 2 APIでそれらを見ることができます。

00:22:27.000 --> 00:22:38.000
元のStoreKit APIで行われた新規購入は、StoreKit 2 APIを介してすぐに利用可能になり、StoreKit 2で行われた購入は、更新されると統一されたレシート内でも利用可能になります。

00:22:38.000 --> 00:22:47.000
取引履歴に加えて、StoreKit 2は、ユーザーのサブスクリプションステータスに関する詳細情報を取得する方法も追加しています。

00:22:47.000 --> 00:22:50.000
サブスクリプションステータスには3つの部分があります。

00:22:50.000 --> 00:22:52.000
1つ目は最新の取引です。

00:22:52.000 --> 00:23:01.000
これにより、このサブスクリプションで発生した最後のトランザクションにアクセスでき、先ほど話した最新のトランザクションに電話した場合と同じです。

00:23:01.000 --> 00:23:03.000
2つ目は更新状態です。

00:23:03.000 --> 00:23:07.000
これは、サブスクリプションの現在の状態を伝える列挙です。

00:23:07.000 --> 00:23:12.000
今、サブスクリプションで何が起こっているのかを知りたい場合は、この値を見てください。

00:23:12.000 --> 00:23:18.000
現在購読されているか、期限切れか、猶予期間内かなどを教えてくれます。

00:23:18.000 --> 00:23:24.000
私たちは、この値からアプリのロジックを簡単にするために、あなたに見るための単一の場所を提供するように設計しました。

00:23:24.000 --> 00:23:28.000
そして、サブスクリプションステータスの最後の部分は更新情報です。

00:23:28.000 --> 00:23:32.000
ここでは、ユーザーのサブスクリプションに関するすべての詳細を確認できます。

00:23:32.000 --> 00:23:39.000
このデータは実際にトランザクションなしで変更される可能性があるため、トランザクション情報にないあらゆる種類の情報が含まれています。

00:23:39.000 --> 00:23:48.000
たとえば、更新情報では、自動更新ステータスを確認できます。これは、ユーザーがこのサブスクリプションの自動更新をオンまたはオフにしているかどうかを示します。

00:23:48.000 --> 00:23:52.000
自動更新が設定されている製品IDを確認することもできます。

00:23:52.000 --> 00:24:01.000
したがって、ユーザーが最近サブスクリプションをダウングレードした場合は、ここでそれを見ることができ、より高い層にとどまるためのウィンバックオファーを提示する機会として利用できるかもしれません。

00:24:01.000 --> 00:24:06.000
サブスクリプションがすでに有効期限が切れている場合は、更新情報を使用して有効期限の理由を確認できます。

00:24:06.000 --> 00:24:11.000
そして、完全な更新情報には、これらすべてのデータと、さらに別の重要な機能があります。

00:24:11.000 --> 00:24:16.000
そうです、すべての暗号愛好家、更新情報はJWSを使用して署名されています!

00:24:16.000 --> 00:24:22.000
取引情報と同様に、更新情報はサービスのロックを解除し、マーケティングの決定を下す上で重要な部分です。

00:24:22.000 --> 00:24:26.000
だから、私たちはあなたにそれが有効であり、Appleから直接であることを知る自信を与えています。

00:24:26.000 --> 00:24:35.000
そして、私が今あなたの頭の中を駆け巡っていると確信している質問に答えるために、はい、StoreKit 2は自動的に更新情報を検証します。

00:24:35.000 --> 00:24:41.000
サブスクリプションステータスAPIについて知っておくべき最後の1つは、ステータスの配列を返すことです。

00:24:41.000 --> 00:24:46.000
これは、場合によっては、ユーザーが同じ製品に複数のサブスクリプションを持つことができるためです。

00:24:46.000 --> 00:24:53.000
たとえば、ユーザーが製品を購読し、ファミリー共有を通じてサブスクリプションを受け取る可能性があります。

00:24:53.000 --> 00:24:57.000
配列をチェックして、彼らが受ける資格のある最高レベルのサービスが何であるかを確認する必要があります。

00:24:57.000 --> 00:25:05.000
今、私はそれをヤコブに返して、あなたのアプリコードでこれらのトランザクション履歴とサブスクリプションステータスAPIで動作するようにどのように見えるかをお見せします。

00:25:05.000 --> 00:25:07.000
ヤコブ:ありがとう、ロス。

00:25:07.000 --> 00:25:15.000
私が取り組んできたアプリに戻り、ロスが先ほど話した新しいトランザクション履歴とサブスクリプションステータスAPIを使用するように更新しましょう。

00:25:15.000 --> 00:25:27.000
以前に購入したオートバイにはグリーンチェックがなく、店舗ビューから移動した後、標準の5人乗りにもグリーンチェックはありません。

00:25:27.000 --> 00:25:31.000
ユーザーとして、私はすでに購入したものがわかりません。

00:25:31.000 --> 00:25:34.000
これはStoreKit 2で簡単に解決できる問題です。

00:25:34.000 --> 00:25:43.000
いつでも、私のアプリはどの製品が購入されたかをStoreKitに照会できるので、アプリのUIを常に最新の状態に保つことができます。

00:25:43.000 --> 00:25:49.000
私のStore.swiftファイルでは、isPurchasedメソッドは現在falseのみを返します。

00:25:49.000 --> 00:25:54.000
Transaction.latest(for:)への簡単な呼び出しでそれを修正しましょう。

00:25:54.000 --> 00:26:03.000
次に、製品識別子を渡して、最新のトランザクションを取得します。

00:26:03.000 --> 00:26:12.000
このStoreKitメソッドは、トランザクションがStoreKit 2の検証チェックを通過したことを知らせる別の検証結果を返します。

00:26:12.000 --> 00:26:19.000
トランザクションが検証されていることを確認し、以前に書いたcheckVerifiedメソッドを使用してラップを解除します。

00:26:19.000 --> 00:26:38.000
次に、失効日がnilに等しいことを確認することで、アプリが返金されたトランザクションのコンテンツを配信しないことを確認します。

00:26:38.000 --> 00:26:58.000
また、期間の途中で顧客がより高いレベルのサービスにアップグレードしたサブスクリプションでは、isUpgradedフラグがtrueに設定されます。

00:26:58.000 --> 00:27:08.000
私のアプリが顧客が購読している最高レベルのサービスを提供していることを確認したいので、isPurchasedメソッドはアップグレードされたトランザクションを無視する必要があります。

00:27:08.000 --> 00:27:20.000
サブスクリプション製品の場合、トランザクションタイプはストーリーの一部のみを伝えます。

00:27:20.000 --> 00:27:38.000
取引日とサブスクリプションの有効期限に加えて、次の更新日がいつなのか、顧客がサブスクリプションの自動更新をオフにしたかどうか、または次の更新期間が購読しているサービスのレベルを変更するかどうかも知りたいです。

00:27:38.000 --> 00:27:44.000
これらすべての情報を取得するために、StoreKit 2はサブスクリプションステータスAPIを提供しています。

00:27:44.000 --> 00:27:56.000
私のSubscriptionsView.swiftファイルでは、updateSubscriptionStatusメソッドは、StoreKitからサブスクリプションステータスを取得し、ユーザーに表示する責任があります。

00:27:56.000 --> 00:28:04.000
私のサブスクリプション製品はすべて同じグループに属しているため、それらのいずれかを使用してグループの現在のステータスを取得できます。

00:28:04.000 --> 00:28:08.000
お店から最初のサブスクリプション商品を選ぶだけです。

00:28:08.000 --> 00:28:17.000
製品を入手したら、サブスクリプションからステータスプロパティを取得できます。

00:28:17.000 --> 00:28:22.000
それはとても簡単です。

00:28:22.000 --> 00:28:31.000
ロスが述べたように、ユーザーが家族によって共有されているサブスクリプションを持っている間、ユーザーは自分の個人的なサブスクリプションを支払う可能性があります。

00:28:31.000 --> 00:28:38.000
したがって、statusプロパティは、各サブスクリプションのすべてのステータスを含む配列を返します。

00:28:38.000 --> 00:28:46.000
今、彼らは個人的にプロティアを購読している間、標準ティアを彼らと共有することができます。

00:28:46.000 --> 00:28:54.000
ユーザーがアクセスできる最高レベルのサービスを受けられるようにしたいので、各ステータスを反復します。

00:28:54.000 --> 00:29:08.000
次に、ステータスの有効期限が切れているか取り消されているかを確認します。

00:29:08.000 --> 00:29:13.000
これらのケースを無視して、ユーザーに何も表示したくない。

00:29:13.000 --> 00:29:22.000
他のすべてのケースについては、newalInfoを取得し、店舗のcheckVerifiedメソッドを使用して検証されていることを確認します。

00:29:22.000 --> 00:29:45.000
更新情報を確認したら、サービスレベルを以前の製品と比較します。

00:29:45.000 --> 00:30:01.000
このチェックでは、サブスクリプションステータスに対応する製品を取得し、以前の製品と比較され、より高い階層の場合は、新しいサブスクリプションにhighestStatusとhighProductを設定します。

00:30:01.000 --> 00:30:10.000
すべてのステータスを確認し、最高レベルのサービスを決定したら、ビューのステータスと現在のサブスクリプションを設定します。

00:30:10.000 --> 00:30:32.000
今すぐ構築して実行しましょう。

00:30:32.000 --> 00:30:41.000
私の店舗ビューでは、以前に購入した製品には、すでに所有していることを示す緑色のチェックマークが表示されており、再度購入する必要はありません。

00:30:41.000 --> 00:30:49.000
サブスクリプション製品の1つを購入するとどうなるか見てみましょう。

00:30:49.000 --> 00:30:54.000
購入を確認すると、ステータスがストアに表示されます。

00:30:54.000 --> 00:31:03.000
StoreKit 2に組み込まれたAPIを使用して、購読しているものと、サブスクリプションがいつ更新されるかをユーザーに知らせることができます。

00:31:03.000 --> 00:31:06.000
さて、このマイカーズビューはどうですか?

00:31:06.000 --> 00:31:11.000
購入したすべての製品が表示されるはずですが、現在は空です。

00:31:11.000 --> 00:31:23.000
これを埋めるために、私はすべての製品を反復し、それぞれの最新のトランザクションを取得し、トランザクションの有効期限と返金されたかどうかを確認することができますが、それは多くのように聞こえます。

00:31:23.000 --> 00:31:34.000
ありがたいことに、StoreKit 2のパワーと新しいシンプルで便利なAPIを使用して、currentEntitlementsと呼ばれるすべてのユーザーの有効なトランザクションを取得できます。

00:31:34.000 --> 00:31:41.000
マイカーズビューでは、ビューがロードされたときに購入した製品をリフレッシュするこの方法があります。

00:31:41.000 --> 00:31:46.000
トランザクションの更新と同様に、現在の資格を反復します。

00:31:46.000 --> 00:32:02.000
しかし、トランザクションの更新とは異なり、現在のエンタイトルメントの非同期シーケンスは有限であるため、forループで永遠に待つことはできず、ユーザーがより多くの購入を行うにつれて新しいエンタイトルメントを提供します。

00:32:02.000 --> 00:32:09.000
資格ごとに、他のすべての取引と同様に検証結果を確認したいです。

00:32:09.000 --> 00:32:22.000
それらが検証されたら、元の製品リクエストで行ったのと同じように、productTypeプロパティを切り替えて、資格を異なる配列にフィルタリングします。

00:32:22.000 --> 00:32:32.000
現在の資格は、非消耗型および自動再生可能な製品のトランザクションのみを返します。

00:32:32.000 --> 00:32:39.000
他の製品タイプを無視してswitchステートメントを完成させ、Swiftコンパイラを幸せに保つことができます。

00:32:39.000 --> 00:32:46.000
トランザクションを取得したら、関連する製品をUIに表示する必要があります。

00:32:46.000 --> 00:32:57.000
非消耗取引の場合、この取引に一致する製品識別子を車の製品配列で検索します。

00:32:57.000 --> 00:33:07.000
同様に、自動更新可能なトランザクションと一致するようにサブスクリプション製品配列を検索します。

00:33:07.000 --> 00:33:16.000
もう一度実行して、私のUIをチェックしてみましょう。

00:33:16.000 --> 00:33:21.000
今、マイカーズビューに入ると、購入したすべてのものが見えます。

00:33:21.000 --> 00:33:26.000
私の車はすべて上部にグループ化されており、私のサブスクリプションは以下です。

00:33:26.000 --> 00:33:30.000
今、私のアプリは完全に機能するストアを持っており、それは素晴らしく見えます!

00:33:30.000 --> 00:33:40.000
そして、トランザクション履歴とサブスクリプションステータスAPIを使用して、ユーザーが見るUIについてアプリで情報に基づいた決定を下す方法です。

00:33:40.000 --> 00:33:46.000
では、JSON Web Signatureオブジェクトについてより深く話すRossに戻りましょう。

00:33:46.000 --> 00:33:49.000
ロス：素晴らしいデモをありがとう、ヤコブ。

00:33:49.000 --> 00:33:54.000
新しいトランザクションとサブスクリプションAPIがどのように役立つかを本当に見ることができます。

00:33:54.000 --> 00:34:03.000
StoreKit 2がセキュリティのためにJWSを使用する2つの方法を見たので、私はそれを詳しく見て、あなた自身の検証を行う方法を約束しました。

00:34:03.000 --> 00:34:06.000
JSON Web Signatureは3つの部分で構成されています。

00:34:06.000 --> 00:34:10.000
1つ目は、オブジェクトに関するメタデータを含むヘッダーです。

00:34:10.000 --> 00:34:18.000
これには、署名に使用されるアルゴリズムや、署名の検証に使用される証明書を見つける場所などの重要な情報が含まれています。

00:34:18.000 --> 00:34:25.000
StoreKit 2は現在、CryptoKitでSwiftでネイティブにサポートされているECDSAアルゴリズムを使用しています。

00:34:25.000 --> 00:34:33.000
証明書の場合、StoreKit 2はx5cヘッダーを使用します。これは、証明書チェーン全体がJWSデータに含まれていることを示します。

00:34:33.000 --> 00:34:40.000
これは、これらのJWS署名を検証するためにインターネット接続が不要であることを意味します。

00:34:40.000 --> 00:34:43.000
JWSデータの次の部分はペイロードです。

00:34:43.000 --> 00:34:50.000
これは、トランザクションID、製品ID、購入日などの主な情報です。

00:34:50.000 --> 00:34:57.000
署名を検証したら、トランザクションまたはサブスクリプションについて知りたいすべてのデータを読み取るのがここです。

00:34:57.000 --> 00:35:01.000
そして、JWSデータの最後の部分は署名そのものです。

00:35:01.000 --> 00:35:05.000
これは、ヘッダーとペイロードの両方を使用して生成されます。

00:35:05.000 --> 00:35:14.000
JWS署名の検証は、標準の十分に文書化された部分であるため、独自の実装を書くことに興味がある場合は、元のソースに直接行くことをお勧めします。

00:35:14.000 --> 00:35:18.000
このセッションに関連するリソースに、このドキュメントへのリンクを含めました。

00:35:18.000 --> 00:35:27.000
JWSデータから署名を検証したら、署名された情報がアプリと現在のデバイスに有効であることを確認するために、さらにいくつかのことを行う必要があります。

00:35:27.000 --> 00:35:33.000
まず、署名された情報ペイロードに存在するバンドルIDが、アプリのバンドルIDと一致していることを確認する必要があります。

00:35:33.000 --> 00:35:44.000
セキュリティを強化するために、API呼び出しに頼るのではなく、アプリのバンドルIDをアプリのどこかに埋め込み、その値を使用してペイロードのバンドルIDと比較することをお勧めします。

00:35:44.000 --> 00:35:48.000
そして、あなたがすべき最後のことは、デバイスの検証チェックを実行することです。

00:35:48.000 --> 00:35:53.000
これにより、署名された情報が、現在使用しているデバイスに対して実際に生成されたことが保証されます。

00:35:53.000 --> 00:36:00.000
StoreKit 2 API AppStore.deviceVerificationIDを使用して、現在のデバイス検証識別子を取得します。

00:36:00.000 --> 00:36:08.000
次に、署名された情報からデバイス検証ノンスを取り、StoreKitから受け取ったばかりのデバイス検証識別子を追加します。

00:36:08.000 --> 00:36:15.000
この値に対してSHA384ハッシュを実行し、結果を署名された情報からデバイス検証フィールドと比較します。

00:36:15.000 --> 00:36:21.000
それらが一致する場合、このデバイスに対して署名された情報が生成され、署名された情報の検証が完了します。

00:36:21.000 --> 00:36:26.000
最後に注意すべきことは、これらの新しいJWSオブジェクトはアプリ内購入専用であるということです。

00:36:26.000 --> 00:36:32.000
したがって、アプリの領収書を検証する必要がある場合は、既存のAPIとプロセスを使用する必要があります。

00:36:32.000 --> 00:36:41.000
そしてもちろん、これらの新しいJWSオブジェクト用の新しいApp StoreサーバーAPIを提供しているので、サーバー上で直接取得して検証することができます。

00:36:41.000 --> 00:36:46.000
さて、私たちが今日あなたに紹介するのと同じくらいStoreKit 2に会うことに興奮していたことを願っています。

00:36:46.000 --> 00:36:53.000
StoreKit 2は、より多くの情報を提供し、これまで以上に使いやすい新しいAPIで、アプリ内購入をさらに良くしています。

00:36:53.000 --> 00:37:03.000
これには、各トランザクションの新しいJSONベースの情報オブジェクトと、ネイティブコードでトランザクションの詳細と過去のトランザクションデータを提供するAPIが含まれます。

00:37:03.000 --> 00:37:11.000
それを新しいサブスクリプションステータスAPIと組み合わせると、StoreKit 2はアプリ内購入の豊富な可能性を解き放ちます。

00:37:11.000 --> 00:37:18.000
アプリ内購入の詳細については、サーバーサイドのコーディングと顧客サポートのために、これらの他のセッションを見ることをお勧めします。

00:37:18.000 --> 00:37:21.000
ヤコブと私は、StoreKit 2を紹介できることに興奮しています。

00:37:21.000 --> 00:37:24.000
WWDC21にご参加いただきありがとうございます!

00:37:24.000 --> 23:59:59.000
♪

