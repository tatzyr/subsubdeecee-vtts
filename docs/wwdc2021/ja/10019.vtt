WEBVTT

00:00:02.000 --> 00:00:12.000
こんにちは、「SwiftUIで並行性を発見する」へようこそ。

00:00:12.000 --> 00:00:15.000
SwiftUIチームのエンジニア、カート・クリフトンです。

00:00:15.000 --> 00:00:18.000
後で、同僚のジェシカが加わります。

00:00:18.000 --> 00:00:24.000
Swift 5.5では、Swiftコードの並行性を管理するためのさまざまな新しいツールが導入されています。

00:00:24.000 --> 00:00:32.000
この講演では、ジェシカと私は、これらの改善がSwiftUIアプリとどのように相互作用するかを理解するお手伝いをします。

00:00:32.000 --> 00:00:40.000
新しいツールがデータモデルをさらに良くするのにどのように役立つか、SwiftUIが新しいメインアクターとどのように連携するかを紹介します。

00:00:40.000 --> 00:00:52.000
その後、ジェシカは、並行データモデルをSwiftUIビューに接続する方法を示し、Swiftの新しい並行性ツールを活用する素晴らしい新しいAPIを紹介します。

00:00:52.000 --> 00:00:59.000
ジェシカと私が共有する情報を最大限に活用するには、Swiftの新しい並行性サポートの背景を持つことが重要です。

00:00:59.000 --> 00:01:09.000
このビデオの残りの部分に飛び込む前に、「Swiftで非同期/待機する」と「スウィフトで構造化された並行性を探る」を見ることをお勧めします。

00:01:09.000 --> 00:01:12.000
子供の頃、私はいつも宇宙飛行士になることを夢見ていました。

00:01:12.000 --> 00:01:17.000
私は時々宇宙船で働いていますが、そうでなければ、その特定の子供の頃の夢は実現しませんでした。

00:01:17.000 --> 00:01:21.000
それでも、私は宇宙への熱意を失っていません。

00:01:21.000 --> 00:01:27.000
そこで、SwiftUIエンジニアとしての実際のスキルを適用して、宇宙関連の写真をダウンロードするアプリを構築することにしました。

00:01:27.000 --> 00:01:31.000
私が計画したアプリを見てみましょう。 

00:01:31.000 --> 00:01:33.000
このアプリは、ランダムな宇宙写真のリストを表示します。

00:01:33.000 --> 00:01:35.000
これらの色はただ美しいです。

00:01:35.000 --> 00:01:40.000
私が本当に好きな写真を見たら、後で見るためにそれを保存することができます。

00:01:40.000 --> 00:01:47.000
これらの美しい画像を取得するために、私のアプリはREST APIを使用してウェブサービスと対話します。

00:01:47.000 --> 00:01:52.000
これは、Swiftで導入された新しい並行性機能の完璧な使い方のように聞こえます。

00:01:52.000 --> 00:01:55.000
データモデルから始めましょう。

00:01:55.000 --> 00:02:00.000
SpacePhoto構造体を使用して、単一の画像の情報を保持しています。

00:02:00.000 --> 00:02:12.000
構造体には、タイトル、写真の説明、画像が投稿された日付、実際の画像を指すURLなどのフィールドがあります。

00:02:12.000 --> 00:02:24.000
サーバーの応答からインスタンスを簡単にインスタンス化したり、ディスクに保存したり、ForEachやその他のデータ駆動型ビューで使用できるように識別できるように、タイプをCodableにしました。

00:02:24.000 --> 00:02:27.000
次に、これらのエントリのリストを表示します。

00:02:27.000 --> 00:02:32.000
そのために、それらのコレクションを取得して保持するモデルが必要です。

00:02:32.000 --> 00:02:36.000
私はこのために写真のクラスを使っています。

00:02:36.000 --> 00:02:45.000
写真クラスをObservableObjectに準拠させることで、SwiftUIビューはデータが更新されるたびに自動的に更新されます。

00:02:45.000 --> 00:02:51.000
公開されたプロパティを使用して、SpacePhotosの配列を保存しています。

00:02:51.000 --> 00:02:56.000
RESTエンドポイントから更新されたアイテムを取得するには、Update Itemsメソッドを使用しています。

00:02:56.000 --> 00:02:59.000
それについては、すぐに詳しく話します。

00:02:59.000 --> 00:03:03.000
しかし、まず基本的なユーザーインターフェイスを大まかにしたいと思います。

00:03:03.000 --> 00:03:06.000
これは私が構築したいユーザーインターフェースです。

00:03:06.000 --> 00:03:13.000
これまでのところ、タブビューと基本的なPhotoViewがあるだけです。

00:03:13.000 --> 00:03:17.000
My PhotoViewはスペース写真を撮り、そのタイトルを表示します。

00:03:17.000 --> 00:03:21.000
それは私が動作中の私のデータモデルを見ることができるのに十分な配管です。

00:03:21.000 --> 00:03:24.000
次はカタログビューを見てみましょう。

00:03:24.000 --> 00:03:27.000
私のカタログビューには、写真のリストが表示されます。

00:03:27.000 --> 00:03:34.000
これを行うには、状態オブジェクトを追加し、Photosの観測可能なオブジェクトでインスタンス化します。

00:03:34.000 --> 00:03:38.000
私のビューの本文に、NavigationViewを追加します。

00:03:38.000 --> 00:03:43.000
ここでナビゲーションビューを使用すると、まもなく大きなナビゲーションタイトルを追加できます。

00:03:43.000 --> 00:03:47.000
次に、NavigationViewの中にリストを追加します。

00:03:47.000 --> 00:03:56.000
そして、私のリストの中で、私はForEachを使用して私の写真の上にマッピングし、それらのそれぞれにPhotoViewを表示します。

00:03:56.000 --> 00:04:00.000
そで、私は自分のサンプルデータを見ることができます。

00:04:00.000 --> 00:04:05.000
それは私が今のところ行く必要がある限りですが、ここにもう少し磨きを加えましょう。

00:04:05.000 --> 00:04:08.000
まず、これが約束されたナビゲーションタイトルです。

00:04:08.000 --> 00:04:21.000
さて、ここでのデフォルトの挿入リストスタイルは素晴らしく見えますが、本当に私の宇宙写真を披露するために、写真が黒い背景に対して本当にポップになるようにプレーンスタイルに切り替えたいです。

00:04:21.000 --> 00:04:27.000
ここで新しい列挙型のような静的メンバー構文を使用して、リストスタイルをプレーンにすることができます。

00:04:27.000 --> 00:04:36.000
この構文を使用すると、SwiftUIのスタイル修飾子は、Xcode 13のオートコンプリートをよりよくサポートし、より簡潔なスペルを取得します。

00:04:36.000 --> 00:04:43.000
最後に、今年のSwiftUIで新しい別の機能を使用させてください。リスト区切りの制御です。

00:04:43.000 --> 00:04:50.000
ForEach内では、listRowSeparator修飾子を使用してセパレータを非表示にすることができます。

00:04:50.000 --> 00:04:55.000
時々、SwiftUIでユーザーインターフェイスを磨いているとき、私は止めるのは難しいと感じます。

00:04:55.000 --> 00:04:57.000
しかし、私は今のところUIを離れます。

00:04:57.000 --> 00:05:01.000
ジェシカは、私がデータモデルを終えた後、それを終える予定です。

00:05:01.000 --> 00:05:09.000
しかし、データモデルを掘り下げる前に、SwiftUIが観測可能なオブジェクトとどのように相互作用するかについて少しお話ししたいと思います。

00:05:09.000 --> 00:05:16.000
そして、Swift 5.5の新しい並行性機能により、このインタラクションがこれまで以上に簡単になります。

00:05:16.000 --> 00:05:25.000
Dub Dub 2020の「Data Essentials in SwiftUI」で、同僚のRajがSwiftUIの更新ライフサイクルについて話しました。

00:05:25.000 --> 00:05:33.000
このライフサイクルを駆動するコードを「実行ループ」と呼びます。Swift 5.5では、実行ループはメインアクターで実行されます。

00:05:33.000 --> 00:05:44.000
一般的な俳優の詳細については、「スウィフト俳優で可変状態を保護する」というトークをチェックしてください。ジェシカと私はこの講演の主役に焦点を当てます。

00:05:44.000 --> 00:05:51.000
SwiftUI実行ループは、ユーザーからイベントを受信し、モデルを更新し、SwiftUIビューを画面にレンダリングします。

00:05:51.000 --> 00:06:01.000
私はこれらのアップデートを「実行ループのティック」と呼ぶのが好きです。このループを展開して、複数のティックを連続して見てみましょう。

00:06:01.000 --> 00:06:07.000
SwiftUIでは、ObservableObjectsはいくつかの興味深い方法でSwiftUI実行ループと対話することができます。

00:06:07.000 --> 00:06:12.000
Photos ObservableObjectに戻り、updateItemsメソッドを見てみましょう。

00:06:12.000 --> 00:06:17.000
SwiftUIビューからupdateItemsを呼び出すと、メインアクターで実行されます。

00:06:17.000 --> 00:06:23.000
この青い長方形を使って、updateItemsが実行されている時刻を表示しましょう。

00:06:23.000 --> 00:06:29.000
フェッチした写真を「アイテム」プロパティに割り当てるこのコード行に集中したい。

00:06:29.000 --> 00:06:46.000
「アイテム」は公開されたプロパティであるため、この割り当てはobjectWillChangeイベントをトリガーし、すぐにフェッチされた写真を「アイテム」のストレージに書き込みます。SwiftUIがこのobjectWillChangeを見ると、私のアイテムのスナップショットを撮ります。

00:06:46.000 --> 00:06:53.000
スナップショットの後の実行ループの次のティックで、SwiftUIはスナップショットを現在の値と比較します。

00:06:53.000 --> 00:06:59.000
これらの値は異なるため、SwiftUIは写真に依存するビューを更新することを知っています。

00:06:59.000 --> 00:07:09.000
objectWillChange、ストレージの更新、および実行ループティックはすべてメインアクターで発生するため、順番に発生することが保証されていることに注意してください。

00:07:09.000 --> 00:07:17.000
2020年の「Data Essentials」トークでは、Rajは、あなたのビューが体内で作業しすぎるときの遅い更新について説明しています。

00:07:17.000 --> 00:07:24.000
モデルコードがメインアクターで作業しすぎると、更新が遅くなることもあります。

00:07:24.000 --> 00:07:33.000
たとえば、ダウンロードが完了するのを待っている間にfetchPhotos機能がブロックされ、接続が遅いとします。

00:07:33.000 --> 00:07:38.000
主演俳優をブロックしているので、このランループのダニが恋しいです。

00:07:38.000 --> 00:07:42.000
これは私のユーザーにヒッチとして表示されます。

00:07:42.000 --> 00:07:51.000
過去には、高価なfetchPhotosがメインスレッドから発生するように、作業を実行するために別のキューにディスパッチした可能性があります。

00:07:51.000 --> 00:07:56.000
これはうまくいくように思えるかもしれませんが、私はここでトリッキーな問題を抱えています。

00:07:56.000 --> 00:08:00.000
ObservableObjectを主役から変更しています。

00:08:00.000 --> 00:08:04.000
私の変更と実行ループのティックがインターリーブされる可能性があります。

00:08:04.000 --> 00:08:15.000
たとえば、「アイテム」に割り当て、SwiftUIがobjectWillChangeスナップショットを取ると、これは実行ループのティックの直前に発生する可能性があります。

00:08:15.000 --> 00:08:23.000
状態の変更はまだ起こっていないので、SwiftUIはスナップショットを変更されていない値と比較します。

00:08:23.000 --> 00:08:31.000
実際の状態の変化は実行ループのチェックの後に起こりますが、SwiftUIはその変化を見ないので、私のビューは更新されません。

00:08:31.000 --> 00:08:44.000
正しく更新するには、SwiftUIはこれらのイベントを順番に実行する必要があります。objectWillChange、ObservableObjectの状態が更新され、実行ループが次のティックに到達します。

00:08:44.000 --> 00:08:49.000
これらすべてが主役で起こることを確実にすることができれば、この注文を保証できます。

00:08:49.000 --> 00:08:57.000
Swift 5.5より前は、状態を更新するためにメインキューに派遣していたかもしれませんが、今でははるかに簡単です。

00:08:57.000 --> 00:08:59.000
ただ待ってください!

00:08:59.000 --> 00:09:08.000
Awaitを使用してメインアクターから非同期呼び出しを行うことで、非同期作業が発生する間、メインアクターで他の作業を続行させます。

00:09:08.000 --> 00:09:13.000
これは主役の「ielding」と呼ばれています。

00:09:13.000 --> 00:09:24.000
updateItemsでは、awaitを使用して、ロングランI/O中にメインアクターをSwiftUIに戻すことができるため、実行ループのカチカチを維持し、UIのヒッチを回避できます。

00:09:24.000 --> 00:09:33.000
非同期作業が完了すると、Swiftはmain actorにupdateItemsメソッドを再入力するので、状態を更新できます。

00:09:33.000 --> 00:09:35.000
これがどのように機能するか見てみましょう。

00:09:35.000 --> 00:09:41.000
別のキューにディスパッチする代わりに、長時間の操作の結果を待つだけです。

00:09:41.000 --> 00:09:49.000
awaitを書くと、updateItems関数はメインアクターの制御を生成し、実行ループを続行できます。

00:09:49.000 --> 00:10:04.000
待ちに待ったフェッチが完了すると、メインアクターが関数を再入力し、公開されたプロパティを安全に更新し、objectWillChangeをトリガーし、新しい値をSwiftUIで使用できるようにします。

00:10:04.000 --> 00:10:09.000
Xcodeに飛び込んで、フェッチを実現できるかどうか見てみましょう。

00:10:09.000 --> 00:10:12.000
これは私がスライドで示したupdateItemsメソッドです。

00:10:12.000 --> 00:10:17.000
fetchPhotosを実装するには、まず1枚の写真を取得するコードを追加しましょう。

00:10:17.000 --> 00:10:27.000
fetchPhotoメソッドに残りのエンドポイントから写真のURLを取得させ、SpacePhotoを返します。

00:10:27.000 --> 00:10:35.000
次に、URLSessionのデータ利便性の新しい非同期バージョンを使用して、URLからデータを取得します。

00:10:35.000 --> 00:10:54.000
これをスタブするために、私は強制的なトライを使用しています。

00:10:54.000 --> 00:11:01.000
すぐに片付けます。

00:11:01.000 --> 00:11:07.000
ああ、データメソッドは非同期なので、awaitを使う必要があります。

00:11:07.000 --> 00:11:13.000
つまり、fetchPhotoメソッドを非同期にする必要があるということです。

00:11:13.000 --> 00:11:14.000
オーケー、いいね。

00:11:14.000 --> 00:11:19.000
データがわかったので、Decodable初期化子を使用して写真をインスタンス化して返します。

00:11:19.000 --> 00:11:30.000
次はfetchPhotosを見てみましょう。

00:11:30.000 --> 00:11:34.000
私は日付をランダムに選択し、それらをループするためにいくつかのコードをスタブしました。

00:11:34.000 --> 00:11:43.000
配列を構築したいので、「ダウンロード済み」をvarにし、ループに日付変数を追加します。

00:11:43.000 --> 00:11:59.000
ループ内で、特定の日付を取得するための残りのエンドポイントURLをすでに構築する必要があるヘルパーメソッドを呼び出します。

00:11:59.000 --> 00:12:03.000
次に、fetchPhotoメソッドを呼び出して、結果を配列に追加します。

00:12:03.000 --> 00:12:16.000
そして、構築しましょう。

00:12:16.000 --> 00:12:23.000
ああ、fetchPhotoは非同期なので、結果を待つ必要があります。

00:12:23.000 --> 00:12:27.000
つまり、fetchPhotosも非同期である必要があります。

00:12:27.000 --> 00:12:31.000
シンプルにするために、写真を順番にフェッチするためにこれらの呼び出しをしています。

00:12:31.000 --> 00:12:37.000
さらに強力なオプションについては、Swift 5.5のタスクグループをチェックしてください。

00:12:37.000 --> 00:12:43.000
今、私はスライドで示したようにフェッチ写真を待つ必要があります。

00:12:43.000 --> 00:12:47.000
そして、それで、私の更新ロジックが整っています。

00:12:47.000 --> 00:12:52.000
さて、フェッチを実現しようとするこれらの強制的な試みによって、私と同じくらい緊張しているかもしれません。

00:12:52.000 --> 00:12:53.000
それを片付けましょう。

00:12:53.000 --> 00:12:56.000
今のところ、ダウンロードが失敗したらゼロを返します。

00:12:56.000 --> 00:13:20.000
次に、fetchPhotosでは、nil以外の値のみを配列に追加します。

00:13:20.000 --> 00:13:30.000
Photosがasync-awaitを使用しているので、メインアクターで実行されている限り、私が議論したトリッキーなobjectWillChangeのバグに遭遇しないと確信できます。

00:13:30.000 --> 00:13:32.000
しかし、どうすればそれを保証できますか?

00:13:32.000 --> 00:13:35.000
幸いなことに、Swiftコンパイラはここで私を助けることができます。

00:13:35.000 --> 00:13:46.000
写真に新しい@MainActorアノテーションを追加することで、コンパイラは写真のプロパティとメソッドがメインアクターからのみアクセスされることを保証します。

00:13:46.000 --> 00:13:49.000
それが終わったら、モデルは所定の位置にあります。

00:13:49.000 --> 00:13:58.000
次に、ジェシカは私たちの見解をモデルに結びつけ、アプリの並行性を活用するための素晴らしい新しいSwiftUI APIを紹介します。

00:13:58.000 --> 00:14:00.000
ジェシカ？

00:14:00.000 --> 00:14:01.000
ありがとう、カート。

00:14:01.000 --> 00:14:09.000
CatalogViewに切り替えて、Curtが示したupdateItemsメソッドを使用しましょう。

00:14:09.000 --> 00:14:13.000
カタログが表示されるたびにupdateItemsを呼びたいです。

00:14:13.000 --> 00:14:20.000
過去には、これにonAppearを使用したことがあるかもしれませんが、今年からSwiftUIでは、タスク修飾子を使用します。

00:14:20.000 --> 00:14:24.000
タスクを使用すると、非同期タスクをビューに関連付けることができます。

00:14:24.000 --> 00:14:27.000
タスクは、ビューの寿命の開始から始まります。

00:14:27.000 --> 00:14:42.000
タスクはデフォルトで非同期なので、そのクロージャの中で、myPhotosオブジェクトのupdateItemsを呼び出すことができ、結果を待つことができます。

00:14:42.000 --> 00:14:46.000
これはタスクの素晴らしい使い方ですが、この新しい修飾子にはさらに多くのものがあります。

00:14:46.000 --> 00:14:54.000
タスクのライフタイムはビューのライフタイムに関連付けられているため、非同期シーケンスを待ち、その値に応答するなどを行うことができます。

00:14:54.000 --> 00:14:58.000
そして、ビューの寿命が終了すると、タスクは自動的にキャンセルされます。

00:14:58.000 --> 00:15:08.000
ビューライフタイムの詳細については、トーク「Demystify SwiftUI」を必ずチェックしてください。ライブプレビューを使用すると、エントリが更新されていることがわかります。

00:15:08.000 --> 00:15:10.000
しかし、私たちはまだ美しい画像が欠けています。

00:15:10.000 --> 00:15:15.000
私はすでにCurtが以前に示したPhotoViewを更新しています。

00:15:15.000 --> 00:15:18.000
タイトルの後ろにいくつかの背景資料を追加します。

00:15:18.000 --> 00:15:20.000
では、画像を追加しましょう。

00:15:20.000 --> 00:15:27.000
幸いなことに、新しいAsyncImage APIを使用すると、リモートサーバーからの画像の読み込みがこれまで以上に簡単になります。

00:15:27.000 --> 00:15:34.000
私がしなければならないのは、エントリから取得したい画像URLを取得し、それをAsyncImageに渡すことだけです。

00:15:34.000 --> 00:16:00.000
さて、これはフルサイズでは少し大きすぎるので、AsyncImageのオーバーロードを使用して、画像を調整し、ユーザーが自分の画像がロードされていることを知らせるようにプレースホルダを表示しましょう。

00:16:00.000 --> 00:16:29.000
次に、画像のサイズを変更可能にし、スペースを埋めるためにアスペクト比を設定します。

00:16:29.000 --> 00:16:53.000
最後に、画像を柔軟にするために、最小幅と高さを追加します。

00:16:53.000 --> 00:16:59.000
ゼロ以外の最小高さを使用すると、プログレスビューがタイトル領域を覗くことも確認できます。

00:16:59.000 --> 00:17:20.000
SwiftUIの残りの部分と同様に、AsyncImageにはインテリジェントなデフォルトが組み込まれているため、画像の読み込みにエラーが発生した場合でも、結果はプレースホルダを表示し続けることになります。

00:17:20.000 --> 00:17:24.000
エラー処理の動作をカスタマイズすることもできます。

00:17:24.000 --> 00:17:33.000
これを行うには、「フェーズを使用するAsyncImageのオーバーロード」をチェックしてください。また、ユーザーが後で表示するためにお気に入りの画像を保存できれば素晴らしいことです。

00:17:33.000 --> 00:17:36.000
これを行うには、このタイトルエリアにボタンを追加しましょう。

00:17:36.000 --> 00:17:41.000
このボタンは、イメージエントリをディスクに保存するための非同期アクションをトリガーします。

00:17:41.000 --> 00:17:45.000
保存されたエントリは、アプリの[保存済み]タブに表示されます。

00:17:45.000 --> 00:17:47.000
私はすでにこれを行うためにスタブしました。

00:17:47.000 --> 00:17:51.000
ここに追加して、そのコードを見てみましょう。そのコードを見てみましょう。

00:17:51.000 --> 00:18:05.000
これが私の保存ボタンのスタブインバージョンです。

00:18:05.000 --> 00:18:09.000
写真を保存するアクションを追加しましょう。

00:18:09.000 --> 00:18:14.000
SwiftUIのボタンアクションは同期ですが、私の「保存」メソッドは非同期です。

00:18:14.000 --> 00:18:21.000
メソッドを呼び出すには、非同期タスクを開始します。

00:18:21.000 --> 00:18:37.000
次に、クロージャの中で、「写真」の「保存」メソッドを呼び出します。非同期なので、awaitを使います。

00:18:37.000 --> 00:18:41.000
セーブ中にプログレスビューを表示しておくといいと思います。

00:18:41.000 --> 00:18:44.000
これを行うには、州のプロパティを追加します。

00:18:44.000 --> 00:19:02.000
その後、通話の周りの状態を更新して保存します。

00:19:02.000 --> 00:19:25.000
次に、ボタンのラベルを更新して、保存時に進行状況ビューを表示します。

00:19:25.000 --> 00:19:31.000
「不透明度」を使用して保存ラベルを非表示にし、オーバーレイを使用して進行状況ビューを表示しています。

00:19:31.000 --> 00:20:18.000
この組み合わせは、「保存」という単語のローカリゼーションに基づいて、ボタンが同じサイズのままであることを保証します。最後に、保存中にボタンを無効にします。

00:20:18.000 --> 00:20:24.000
これがライブプレビューでどのように機能するか見てみましょう。

00:20:24.000 --> 00:20:26.000
それはかなり素晴らしいです!

00:20:26.000 --> 00:20:36.000
カタログビューに戻って、すべてをまとめましょう。 

00:20:36.000 --> 00:20:42.000
SwiftUIには今年、人々が手動でデータを更新する機能を与えるために使用できる素晴らしい新しい修飾子があります。

00:20:42.000 --> 00:20:49.000
更新可能な修飾子をリストに追加することで、このコンテンツが更新可能であることをSwiftUIに伝えます。

00:20:49.000 --> 00:20:56.000
更新可能な非同期クロージャを提供し、updateItemsメソッドを呼び出してリストを更新することができます。

00:20:56.000 --> 00:21:10.000
先ほど「タスク」で示したように、この非同期メソッドでawaitを使用します。

00:21:10.000 --> 00:21:16.000
リフレッシュインジケーターは、非同期作業が完了すると自動的に閉じます。

00:21:16.000 --> 00:21:29.000
これで、プルダウンして画像を更新し、[保存]をタップして好きな画像を保存し、[保存済み]タブに切り替えて保存した画像を見ることができます。

00:21:29.000 --> 00:21:34.000
Swiftの新機能により、並行データの操作が容易になります。

00:21:34.000 --> 00:21:40.000
SwiftUIは、Swiftの並行性機能とうまく統合され、デフォルトで最高の動作を提供します。

00:21:40.000 --> 00:21:46.000
多くの場合、並行性の力を活用するためにawaitを使用する必要があります。

00:21:46.000 --> 00:21:55.000
ObservableObjectを「@MainActor」としてマークして、ビューとうまく機能する方法でオブジェクトの更新をより堅牢にチェックします。

00:21:55.000 --> 00:22:03.000
SwiftUIのAPI追加を利用して、最小限の労力で安全でパフォーマンスの高い同時アプリを作成してください。

00:22:03.000 --> 00:22:07.000
AsyncImageを使用して、画像を同時にロードします。

00:22:07.000 --> 00:22:15.000
ビュー階層に「更新可能な」修飾子を追加して、ユーザーが手動でデータを更新できるようにします。

00:22:15.000 --> 00:22:22.000
保存ボタンで見たように、独自のカスタムビューでSwiftの新しい並行性機能を使用できます。

00:22:22.000 --> 00:22:25.000
ご存知のように、並行性は難しいです。

00:22:25.000 --> 00:22:35.000
難しい問題ですが、これらの新しい言語機能とSwiftUI APIを使用すると、アプリでその複雑さを管理するためのツールができました。

00:22:35.000 --> 00:22:47.000
Swift 5.5とSwiftUIの素晴らしい新しい並行性ツールについて学ぶことを楽しんだことを願っています。アプリのトリッキーな問題に取り組むためにそれらを使用するすべての方法を楽しみにしています。

00:22:47.000 --> 23:59:59.000
[音楽]。

