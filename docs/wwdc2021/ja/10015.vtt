WEBVTT

00:00:02.000 --> 00:00:10.000
こんにちは。

00:00:10.000 --> 00:00:14.000
私はアップルのコアデータチームのエンジニア、ニック・ギレットです。

00:00:14.000 --> 00:00:23.000
このセッションでは、NSPersistentCloudKitContainerを使用して複数のiCloudユーザーとデータを共有するアプリケーションを簡単に構築する方法を紹介します。

00:00:23.000 --> 00:00:32.000
まず、NSPersistentCloudKitContainerとの共有の意味と、それが構築できるエクスペリエンスの種類にどのように影響するかについて説明します。

00:00:32.000 --> 00:00:37.000
次に、共有の仕組みを深く掘り下げます。

00:00:37.000 --> 00:00:46.000
そして最後に、NSPersistentCloudKitContainerがiCloudに保存されている機密データの追加の保護を可能にするのにどのように役立つかを簡単に説明します。

00:00:46.000 --> 00:00:50.000
共有から始めましょう。

00:00:50.000 --> 00:00:56.000
議論のために、この写真を友達と共有したいと想像してみましょう。

00:00:56.000 --> 00:00:57.000
どうすればいいの？

00:00:57.000 --> 00:01:03.000
Appleのプラットフォームでは、アプリケーションが作成したデータを共有する方法はいくつかあります。

00:01:03.000 --> 00:01:10.000
写真は左下にシステムコントロールを実装し、アクションシートを呼び出すことができます。

00:01:10.000 --> 00:01:16.000
共有するいくつかの方法を含め、私が取ることができる多種多様な行動があります。

00:01:16.000 --> 00:01:22.000
例えば、iMessageやメールで友達に送ることができます。

00:01:22.000 --> 00:01:31.000
しかし、理想的には、友人と私がお互いに写真を共有できる写真アプリに直接1つの場所があります。

00:01:31.000 --> 00:01:38.000
iCloudにサインインすると、写真は共有のための別のオプションをサポートしています。共有アルバムです。

00:01:38.000 --> 00:01:46.000
写真共有アルバムは、他のユーザーが表示し、必要に応じて貢献できる画像の共有コレクションを作成します。

00:01:46.000 --> 00:01:53.000
新しいアルバムにタイトルを付け、[次へ]をタップして参加者のセットを選択するだけです。

00:01:53.000 --> 00:01:56.000
ここで私は写真を共有するために4人の友達を選びました。

00:01:56.000 --> 00:02:05.000
ヘザー、ジャーメイン、パーシー、メアリーはすべて、共有機能を構築するときに定期的に作業するテストアカウントです。

00:02:05.000 --> 00:02:10.000
「次へ」をタップすると、共有した写真を含む新しいアルバムが表示されます。

00:02:10.000 --> 00:02:17.000
写真では、右上のこの人物アイコンをタップして、アルバムの参加者を表示することもできます。

00:02:17.000 --> 00:02:21.000
タップすると、参加者のセットが表示されます。

00:02:21.000 --> 00:02:27.000
ここでは、彼らの招待状況と共有アルバムの許可の一部を見ることができます。

00:02:27.000 --> 00:02:30.000
このような経験をどうやって構築できるでしょうか?

00:02:30.000 --> 00:02:35.000
そしてもっと重要なのは、そのような経験は、私たちが構築するアプリケーションをどのように変えるでしょうか?

00:02:35.000 --> 00:02:37.000
さて、お見せしましょう。

00:02:37.000 --> 00:02:47.000
NSPersistentCloudKitContainerとの共有の仕組みを実証するために、コアデータストアをクラウドと同期するサンプルアプリケーションを使用します。

00:02:47.000 --> 00:02:51.000
私はすでに、異なるiCloudユーザーとの投稿共有をサポートするためにそれを変更しました。

00:02:51.000 --> 00:03:00.000
そして、このテーブルの上には、小さなデバイスのプールがあり、それぞれがヘザー、ジャーメイン、またはメアリーに属するiCloudアカウントにログインしています。

00:03:00.000 --> 00:03:09.000
まず、ジャーメインのデバイスでアプリケーションを起動し、右上隅のこのプラス(+)記号をタップして新しい投稿を作成します。

00:03:09.000 --> 00:03:17.000
「デモの共有は素晴らしいです」という簡単なタイトルを付けて、「完了」をタップします。

00:03:17.000 --> 00:03:22.000
そして、追加したこの新しいアクションボタンをタップして、共有コントローラーを表示します。

00:03:22.000 --> 00:03:26.000
メールで私と一緒にこの投稿に取り組むための招待状を一人一人に送りたいです。

00:03:26.000 --> 00:03:31.000
だから、メールをタップして、友達の情報を入力します。

00:03:31.000 --> 00:03:36.000
私はすでにヘザーとメアリーをアドレス帳に保存したので、簡単に見つけることができます。

00:03:36.000 --> 00:03:40.000
最後に、[送信]をタップしてメールを送信します。

00:03:40.000 --> 00:03:48.000
さて、ヘザーのデバイスでメールを開き、送信したメール内のリンクをタップすると、アプリケーションが開きます。

00:03:48.000 --> 00:03:59.000
しばらく待った後、ジャーメインのデバイスで作成した投稿がこのデバイスに表示されるようになりました。

00:03:59.000 --> 00:04:07.000
メアリーのデバイスで、メールを開き、送信したメール内のリンクをタップすると、アプリケーションが開きます。

00:04:07.000 --> 00:04:14.000
少し待った後、ジャーメインのデバイスで作成した投稿が、このデバイスにも表示されるようになりました。

00:04:14.000 --> 00:04:16.000
しかし、このすべてはどのように機能しますか?

00:04:16.000 --> 00:04:20.000
そして、サンプルアプリケーションで正確にどのくらい変更する必要がありますか?

00:04:20.000 --> 00:04:23.000
答えは「あまりない」です。

00:04:23.000 --> 00:04:29.000
共有は、NSPersistentCloudKitContainerに組み込まれた最も複雑な機能です。

00:04:29.000 --> 00:04:37.000
CloudKitの仕組みと、レコードやオブジェクトの操作方法に関する膨大な量のドメイン知識を結集します。

00:04:37.000 --> 00:04:45.000
当然のことながら、このドメインの知識は、NSPersistentCloudKitContainer用に構築したAPIに反映されています。

00:04:45.000 --> 00:04:51.000
では、NSPersistentCloudKitContainerがどのようにオブジェクトを共有するかを正確に見てみましょう。

00:04:51.000 --> 00:05:00.000
私の簡単なデモでは、.privateと.sharedデータベースの2つのCloudKitデータベースを使用するアプリケーションを示しました。

00:05:00.000 --> 00:05:09.000
これらのそれぞれは、私のアプリケーションの永続ストアにミラーリングされ、1つは.privateデータベーススコープを使用し、もう1つは.sharedデータベーススコープを使用します。

00:05:09.000 --> 00:05:16.000
単一の管理オブジェクトコンテキストを使用して、私のアプリケーションは両方のストアのデータにアクセスできます。

00:05:16.000 --> 00:05:21.000
その変更をもう少し詳しく見てみましょう。

00:05:21.000 --> 00:05:30.000
私がしなければならなかった最初の変更は、.shared CloudKitデータベースを新しい永続ストアにミラーリングするようにNSPersistentCloudKitContainerに伝えることでした。

00:05:30.000 --> 00:05:41.000
CoreDataStackを変更し、新しい永続的なストアの説明を追加してこれを行いました。ここでは、別のURLを持つ.privateストア用のコピーです。

00:05:41.000 --> 00:05:46.000
次に、CloudKitコンテナオプションのdatabaseScopeプロパティを.sharedに設定しました。

00:05:46.000 --> 00:05:56.000
これは新しいiOS 15で、永続ストアを.shared CloudKitデータベースにミラーリングするようにNSPersistentCloudKitContainerを構成できます。

00:05:56.000 --> 00:06:01.000
デモを完了するには、他の2つの変更を加える必要がありました。

00:06:01.000 --> 00:06:06.000
共有を作成するために、NSPersistentCloudKitContainerの新しい方法を採用しました。

00:06:06.000 --> 00:06:15.000
Share(_ managedObjects: to share: completion:)は、UICloudSharingControllerと直接ペアリングするように設計された新しいメソッドです。

00:06:15.000 --> 00:06:21.000
UICloudSharingControllerのインスタンスをインスタンス化するためのボタンアクションを追加しただけです。

00:06:21.000 --> 00:06:30.000
Share(_ managedObjects: to share: completion:)は、UICloudSharingControllerのワークフローのcreate-shareフェーズで呼び出されることを意図しています。

00:06:30.000 --> 00:06:40.000
共有する必要があるすべてのオブジェクトを特定し、必要に応じて共有を作成するために、カバーの下で多くの作業を行います。

00:06:40.000 --> 00:06:52.000
最後に、NSPersistentCloudKitContainerによって提供された結果でUICloudSharingControllerの完了ブロックを呼び出します。これにより、共有フローを続行する準備ができていることがわかります。

00:06:52.000 --> 00:06:59.000
これは、わずか数行のコードでNSPersistentCloudKitContainerを使用してオブジェクトを共有できることを意味します。

00:06:59.000 --> 00:07:27.000
私がしなければならなかった最後の変更は、NSPersistentCloudKitContainerでこの新しい方法を使用して、共有招待を受け入れることでした: acceptShareInvitations(メタデータから: persistentStoreへ: AppDelegeateのアプリケーションuserDidAcceptCloudKitShare(メタデータ付き:)メソッドでこのメソッドを使用して、着信共有メタデータをNSPersistentCloudKitContainerに直接

00:07:27.000 --> 00:07:38.000
このメソッドは、私が提供する永続ストアに関連付けられたコンテナ内のCloudKitサーバーとの共有を受け入れます。ここでは、私のアプリケーションの共有ストアです。

00:07:38.000 --> 00:07:46.000
共有が承認された後、NSPersistentCloudKitContainerはすべての共有オブジェクトをローカルストアに自動的に同期します。

00:07:46.000 --> 00:07:57.000
そのため、NSPersistentCloudKitContainerを使用して、.privateデータベースと.sharedデータベースを結合し、オブジェクトの共有を作成し、共有招待を受け入れる方法です。

00:07:57.000 --> 00:08:02.000
しかし、私たちのアプリケーションは通常、大量のデータコレクションを管理するように設計されています。

00:08:02.000 --> 00:08:16.000
この共有データを使用するアプリケーションを簡単に構築するために、NSPersistentCloudKitContainerは、ユーザーのための有益なユーザーインターフェイスを構築できるように、これらすべてのオブジェクトを理解するのにも役立ちます。

00:08:16.000 --> 00:08:24.000
これらの課題をもう少し明確に理解するには、共有のための2つの重要な概念を特定する必要があります。

00:08:24.000 --> 00:08:28.000
1つ目は、一連の俳優の概念です。

00:08:28.000 --> 00:08:31.000
私たちは彼らをオーナーと参加者と呼んでいます。

00:08:31.000 --> 00:08:35.000
所有者は、実際にオブジェクトを所有しているiCloudアカウントです。

00:08:35.000 --> 00:08:40.000
所有者は、一連の参加者とオブジェクトを作成して共有します。

00:08:40.000 --> 00:08:47.000
参加者は、何らかの方法でそれらのオブジェクトを操作することが許可されている他のiCloudアカウントです。

00:08:47.000 --> 00:09:05.000
参加者は、特定のオブジェクトセットに対してどのように行動できるかを制限するさまざまな役割と権限を持つことができ、NSPersistentCloudKitContainerとCloudKitがこれらの共有オブジェクトをどのように構成するかという2番目の重要な概念に私たちをもたらします。

00:09:05.000 --> 00:09:10.000
コアデータでは、オブジェクトをNSManagedObjectの観点から考えます。

00:09:10.000 --> 00:09:19.000
NSPersistentCloudKitContainerは、これらの管理オブジェクトをCloudKitに保存されているCKRecordのインスタンスに変換します。

00:09:19.000 --> 00:09:29.000
以前に共有に取り組んだことがあるなら、おそらく階層的な共有に精通しているでしょう。これらのレコードは、共有と呼ばれるルートレコードに関連付けられています。

00:09:29.000 --> 00:09:33.000
しかし、これはNSPersistentCloudKitContainerの仕組みではありません。

00:09:33.000 --> 00:09:44.000
NSPersistentCloudKitContainerは、セッション「CloudKitの新機能」でより詳細に説明されている、レコードゾーン共有と呼ばれるCloudKitの新機能を使用しています。

00:09:44.000 --> 00:09:53.000
しかし、NSPersistentCloudKitContainerがレコードゾーン共有を使用して管理対象オブジェクトを共有する方法を見てみましょう。

00:09:53.000 --> 00:10:04.000
CloudKitデータベースでは、たとえば、.privateデータベース--NSPersistentCloudKitContainerは通常、アプリケーションが作成したオブジェクトを格納するためにプライベートゾーンを管理します。

00:10:04.000 --> 00:10:11.000
レコードゾーン共有では、共有されたCKRecordsは共有されたCKRecordZone内に含まれています。

00:10:11.000 --> 00:10:17.000
共有レコードゾーンは、単一のCKShareレコードの存在によって識別されます。

00:10:17.000 --> 00:10:29.000
階層的な共有と同様に、このレコードには、所有者、参加者、権限や役割など、ゾーンと連携するために必要なすべての情報が含まれています。

00:10:29.000 --> 00:10:35.000
NSPersistentCloudKitContainerはこれらのゾーンを管理し、自動的にレコードを割り当てます。

00:10:35.000 --> 00:10:47.000
ルートレコードがないため、NSPersistentCloudKitContainerは、所有者と参加者の概念がレコードゾーン全体にどのように適用されるかを理解する必要があります。

00:10:47.000 --> 00:10:52.000
私が共有したい人々のコレクションを持っていると想像してみましょう。

00:10:52.000 --> 00:11:02.000
他の人との共有は興味深いですが、NSPersistentCloudKitContainerは、はるかに多くの人口のための共有を促進するように設計されています。

00:11:02.000 --> 00:11:08.000
これらの参加者はそれぞれ、私が共有するオブジェクトにアクセスして操作することができます。

00:11:08.000 --> 00:11:14.000
そして、彼らが私と共有するオブジェクトにアクセスして操作できるようになります。

00:11:14.000 --> 00:11:19.000
各参加者はまた、独自のデバイスのコレクションを持っています。

00:11:19.000 --> 00:11:26.000
NSPersistentCloudKitContainerを使用すると、アプリケーションは任意のAppleデバイスから共有オブジェクトを操作できます。

00:11:26.000 --> 00:11:37.000
参加者ごとに、NSPersistentCloudKitContainerは、.privateデータベースと.sharedデータベースの2つのCloudKitデータベース内のオブジェクトを管理します。

00:11:37.000 --> 00:11:45.000
私の.privateデータベースでは、それらのゾーンが共有されているかどうかにかかわらず、私が所有するレコードとゾーンが表示されます。

00:11:45.000 --> 00:11:50.000
例えば、NSPersistentCloudKitContainerが管理するゾーン。

00:11:50.000 --> 00:12:03.000
共有では、NSPersistentCloudKitContainerは、私が所有するこれらのゾーンにアクセスできるユーザーを制御するCKShareレコードを使用して、共有ゾーンも作成します。

00:12:03.000 --> 00:12:11.000
私と、許可されている場合、他の参加者はこれらの共有ゾーンにレコードを追加および変更することができます。

00:12:11.000 --> 00:12:17.000
私の.sharedデータベースには、他のユーザーが私と共有したレコードゾーンが表示されます。

00:12:17.000 --> 00:12:27.000
許可されている場合は、私が所有しているゾーンと同じように、私が所有しているレコードをそれらのゾーンのいずれかに追加できます。

00:12:27.000 --> 00:12:37.000
別のユーザーは、それらのゾーンの所有者であるかどうかに応じて、.privateデータベースと.sharedデータベースに異なるゾーンセットが表示されます。

00:12:37.000 --> 00:12:45.000
たとえば、このユーザーは、.privateデータベースに所有するプライベートゾーンと共有ゾーンを持つことができます。

00:12:45.000 --> 00:12:56.000
さらに、彼らは私が彼らと共有する私の2つのゾーンと、彼らが.sharedデータベースに参加している他のゾーンを見るでしょう。

00:12:56.000 --> 00:13:02.000
では、NSPersistentCloudKitContainerはどのようにして記録を保管する場所を知っていますか?

00:13:02.000 --> 00:13:09.000
多くの場合、他のオブジェクトとの関係に基づいて、レコードがどこに属しているかを推測できます。

00:13:09.000 --> 00:13:20.000
しかし、share(_ managedObjects: to share: completion:)に、非nil CKShareを渡すことで、特定の共有ゾーンにオブジェクトを格納するように指示することもできます。

00:13:20.000 --> 00:13:32.000
たとえば、このコード行を既存の共有を使用するように変更すると、NSPersistentCloudKitContainerは提供された投稿オブジェクトをその共有に割り当てようとします。

00:13:32.000 --> 00:13:45.000
これらは私が最初のデモのために行わなければならなかったすべての変更ですが、私のアプリケーションはまた、どのオブジェクトが共有されているか、誰と共有されているか、そしてそれらの参加者が何ができるかを効果的に伝える必要があります。

00:13:45.000 --> 00:13:53.000
私たちのユーザーは、共有することを選択したオブジェクトについて適切な決定を下すことができるように、そのすべての情報を必要としています。

00:13:53.000 --> 00:13:58.000
それでは、これらの状態と特権を伝えるためにアプリケーションをどのように変更したかを見てみましょう。

00:13:58.000 --> 00:14:08.000
サンプルアプリケーションに戻ると、最初のデモのデータが、投稿が共有されていることを示す新しいユーザーインターフェイスの装飾で表示されるようになりました。

00:14:08.000 --> 00:14:18.000
それをタップすると、詳細ビューコントローラーの下部に表示される参加者の役割、権限、受け入れ状態も表示されます。

00:14:18.000 --> 00:14:25.000
ここでは、ジャーメインが投稿を含むシェアの所有者であり、ヘザーがプライベート参加者であることがわかります。

00:14:25.000 --> 00:14:37.000
次に、新しい投稿を追加し、タイトルを付けて、[完了]をタップします。

00:14:37.000 --> 00:14:48.000
アクションボタンをタップして共有コントローラーを表示しますが、今回は、参加者が共有の内容を編集または変更できないように、共有を読み取り専用にしたいです。

00:14:48.000 --> 00:14:52.000
したがって、共有オプションを変更して、共有を表示のみとしてマークします。

00:14:52.000 --> 00:14:59.000
次に、メールをタップして、ジャーメインとメアリーを招待します。

00:14:59.000 --> 00:15:03.000
最後に、メールを送ります。

00:15:03.000 --> 00:15:08.000
メアリーのデバイスで、私は新しい共有を受け入れます、そして今、私は新しい投稿を見ることができます。

00:15:08.000 --> 00:15:18.000
それをタップすると、編集ボタンが無効になっていることが確認でき、メアリーの参加者エントリは、彼女が共有の読み取り専用参加者であることを示しています。

00:15:18.000 --> 00:15:30.000
同様に、スワイプしてこの投稿を削除することはできません。また、編集ボタンをタップしてテーブルビューを編集モードにすると、この投稿を削除できません。

00:15:30.000 --> 00:15:37.000
今、ジャーメインのデバイスで、私は新しいシェアを受け入れます。

00:15:37.000 --> 00:15:42.000
そして今、私は新しい投稿を見ることができます。

00:15:42.000 --> 00:15:56.000
それをタップすると、編集ボタンが無効になっていることが確認でき、ジャーメインの参加者エントリは、彼が共有の読み取り専用参加者であることを示しています。

00:15:56.000 --> 00:16:05.000
この謙虚なサンプルアプリケーションでも、共有オブジェクトに関する情報を提示するために、ユーザーインターフェイスに多くの変更を加える必要がありました。

00:16:05.000 --> 00:16:10.000
どれが共有されているかを示すために、ポストテーブルのセルを飾らなければなりませんでした。

00:16:10.000 --> 00:16:19.000
また、現在のユーザー参加者に割り当てられた権限に応じて、編集コントロールを有効または無効にするためのロジックを追加する必要がありました。

00:16:19.000 --> 00:16:28.000
そして最後に、個々の共有で参加者に関する情報を表示するために、新しいユーザーインターフェイス要素を構築する必要がありました。

00:16:28.000 --> 00:16:35.000
この作業はすべて、特定の投稿が存在するCKShareに関するメタデータにアクセスする必要がありました。

00:16:35.000 --> 00:16:42.000
NSPersistentCloudKitContainerには、これらの懸念事項のそれぞれに合わせるための多くのAPIメソッドが含まれています。

00:16:42.000 --> 00:16:50.000
fetchShares(matching objectIDs:)はiOS 15で新しく、特定の投稿のCKShareを取得できます。

00:16:50.000 --> 00:17:00.000
しかし、条件付き編集のためのこれらの3つの方法は、2020年にWWDCで.publicデータベースのサポートと一緒に導入されました。

00:17:00.000 --> 00:17:05.000
これらのメソッドは、ユーザーインターフェイスをカスタマイズする必要がある場所であればどこでも、アプリケーションで使用できます。

00:17:05.000 --> 00:17:10.000
しかし、私のアプリケーションでは、私は少し異なるアプローチを取りました。

00:17:10.000 --> 00:17:21.000
NSPersistentCloudKitContainerでメソッドを直接呼び出す代わりに、必要なカスタマイズごとに特定のメソッドを公開するプロトコルを構築しました。

00:17:21.000 --> 00:17:23.000
それはSharingProviderと呼ばれています。

00:17:23.000 --> 00:17:29.000
SharingProviderには、アプリケーション内の特定のコールサイトに直接バインドする方法があります。

00:17:29.000 --> 00:17:34.000
たとえば、オブジェクトが共有されているかどうかを知る必要があるかもしれません。

00:17:34.000 --> 00:17:44.000
共有されている場合は、ユーザーインターフェイスに詳細情報を表示するために、そのオブジェクトのCKShareまたは参加者を取得する必要があるかもしれません。

00:17:44.000 --> 00:17:52.000
最後に、オブジェクトは常に変更可能ではなく、個々の参加者は同じオブジェクトに対して異なる権限を持つことができます。

00:17:52.000 --> 00:17:58.000
このプロトコルを使用すると、アプリケーションコードに特定のロジックを簡単に追加できます。

00:17:58.000 --> 00:18:05.000
そして、オブジェクトが共有されているかどうかを知る必要があるMainViewControllerの1つの特定のコールサイトを表示したいと思います。

00:18:05.000 --> 00:18:18.000
ここでisSharedを使用して、投稿のタイトルを帰属文字列に変換するかどうかを決定し、その投稿が共有の一部であることを示すためにperson.circleシンボルを先頭に付けました。

00:18:18.000 --> 00:18:26.000
このようなカスタマイズは、共有をサポートしないことを選択した場合よりも、必然的に複雑なコードを必要とします。

00:18:26.000 --> 00:18:38.000
これらのカスタマイズのいくつかを追加した後、それらがすべて正しく動作することを確認する方法が必要であることが明らかになりました。これにより、SharingProviderが存在する主な理由であるテストです。

00:18:38.000 --> 00:18:44.000
SharingProviderプロトコルを使用すると、インジェクションによってこれらの決定ポイントを簡単にテストできます。

00:18:44.000 --> 00:18:54.000
このコードのスニペットは、テーブルセルが投稿が共有されているかどうかを正しく示すことを確認するために、MainViewController用に書いたテストケースの一部です。

00:18:54.000 --> 00:19:08.000
サンプルデータを作成するための足場はやめましたが、テストでは、このセット内のオブジェクトIDの存在によって共有または共有されていないものとして識別する管理オブジェクトの混合セットを作成します。

00:19:08.000 --> 00:19:23.000
次に、テスト用に特別に書かれたクラスであるBlockBasedShareProviderのインスタンスを設定します。これにより、MainViewControllerが使用するsharingProviderにカスタムロジックを簡単に注入できます。

00:19:23.000 --> 00:19:30.000
ここでは、私が作成したセットの包含メソッドを呼び出すようにisSharedBlockを設定しています。

00:19:30.000 --> 00:19:38.000
これは、提供されたobjectIDがsharedObjectIDにあるかどうかを確認することができるSwiftのかわいいトリックです。

00:19:38.000 --> 00:19:45.000
次に、BlockBasedProviderをビューコントローラーのプロバイダーとして設定し、インジェクションを完了します。

00:19:45.000 --> 00:20:02.000
最後に、このテストはMainViewControllerにテーブルセルを尋ね、sharedObjectIDセットに含めたものには期待されるプレフィックスがあり、共有されていないオブジェクトに対応するセルにはないことを確認します。

00:20:02.000 --> 00:20:10.000
isSharedの実際の実装は、私のアプリケーションの永続的なCloudKitコンテナを管理するCoreDataStackにあります。

00:20:10.000 --> 00:20:16.000
そして、私がテストで使用した単純な注射よりも少し複雑であることがわかります。

00:20:16.000 --> 00:20:22.000
さて、私はこの実装を1行ごとに通過することができますが、それはここで重要なことではありません。

00:20:22.000 --> 00:20:36.000
重要なのは、テーブルビューの変更を確認するたびに簡単に運動できるよりもはるかに複雑であり、そうしようとすると、開発プロセスに多くの摩擦が加わるということです。

00:20:36.000 --> 00:20:47.000
一方、このインジェクション技術により、CloudKitサーバーと話すことなく、共有オブジェクトのさまざまな構成を簡単かつ迅速にテストできます。

00:20:47.000 --> 00:21:01.000
これらのテストをすべて記述し、このタイプの注入を容易にする方法でアプリケーションを構造化するのは、事前にもう少しコードですが、結果として得られる信頼性と信頼性はそれだけの価値があります。

00:21:01.000 --> 00:21:15.000
私が述べたように、SharingProviderにはサンプルアプリケーションのための他の多くの重要な方法が含まれており、それらの実装とそれらがユーザーインターフェイスにどのように影響するかについて私が書いたテストをチェックすることをお勧めします。

00:21:15.000 --> 00:21:25.000
全体として、私は1200行強のテストコードを追加しましたが、これらの例があなた自身のアプリケーションでテストを本当に簡単に構築できることを願っています。

00:21:25.000 --> 00:21:35.000
今日取り上げたい最後のトピックは、CloudKitの別の新機能のサポートです。暗号化されたCKRecord値です。

00:21:35.000 --> 00:21:44.000
これらの値は、「CloudKitの新機能」セッションで導入されたencryptedValuesと呼ばれるCKRecordの新しいペイロードに保存されます。

00:21:44.000 --> 00:21:51.000
CKRecordのこの新しいペイロードでは、ユーザーのキーチェーンのキーマテリアルを使用して値を暗号化できます。

00:21:51.000 --> 00:22:03.000
これらの値は、CloudKitサーバーからダウンロードした後、デバイス上でローカルに復号化され、CloudKitサーバーにアップロードされる前にデバイス上でローカルに暗号化されます。

00:22:03.000 --> 00:22:09.000
Xcodeでワンクリックで暗号化された値の採用を可能にしました。

00:22:09.000 --> 00:22:13.000
それを実際に見てみましょう。

00:22:13.000 --> 00:22:19.000
ここXcodeで、コアデータストアをクラウドと同期するサンプルアプリケーションを開きました。

00:22:19.000 --> 00:22:29.000
CoreDataCloudKitDemo管理オブジェクトモデルを開くと、場所と呼ばれることを示すポストエンティティに特定のプロパティがあります。

00:22:29.000 --> 00:22:36.000
ロケーション属性を選択すると、右側のデータモデルインスペクタでその設定を確認できます。

00:22:36.000 --> 00:22:44.000
オプションのTransformable属性に設定し、この新しい許可クラウド暗号化チェックボックスをチェックしました。

00:22:44.000 --> 00:22:55.000
この新しいチェックボックスは、この属性の値を結果のCKRecordのencryptedValuesペイロードに格納する必要があることをNSPersistentCloudKitContainerに伝えます。

00:22:55.000 --> 00:23:07.000
行列をコードとして読みたい場合は、NSAttributeDescriptionに新しいブール値-- allowsCloudEncryption--があり、モデルコードでこのプロパティを設定するために使用できます。

00:23:07.000 --> 00:23:13.000
さて、CloudKitによる暗号化は導入時の決定です。

00:23:13.000 --> 00:23:20.000
つまり、後で考えを変えて、現在本番でまだ暗号化されていないフィールドを暗号化することを選択することはできません。

00:23:20.000 --> 00:23:26.000
同様に、すでに暗号化されているフィールドの暗号化を解除することはできません。

00:23:26.000 --> 00:23:32.000
CloudKitスキーマが本番環境にプッシュされると、どのフィールドタイプも変更できません。

00:23:32.000 --> 00:23:44.000
したがって、スキーマを本番環境にデプロイする前に、すべてのフィールドが存在し、正しく入力されていることを確認するために、NSPersistentCloudKitContainerのinitializeSchemaメソッドを使用してください。

00:23:44.000 --> 00:23:52.000
共有をサポートするためにNSPersistentCloudKitContainerに加えた変更の一部を紹介できることを嬉しく思います。

00:23:52.000 --> 00:23:54.000
学ぶべき新しいAPIがたくさんあります。

00:23:54.000 --> 00:24:11.000
そのため、サンプルアプリケーションとドキュメントを更新して、CloudKitで作業するときにさまざまな状態のオブジェクトにどのように応答するかを確認するためのテストを書く方法など、独自のアプリケーションでそれを使用する方法を実証しました。

00:24:11.000 --> 00:24:17.000
また、フィードバックアシスタントにバグを提出して問題が発生した場合は、必ずお知らせください。

00:24:17.000 --> 00:24:22.000
いつものように、NSPersistentCloudKitContainerで何を構築するかを見るのが待ちきれません。

00:24:22.000 --> 00:24:28.000
アクティブに過ごし、リングを閉じて、素晴らしいWWDC 2021をお過ごしください。

00:24:28.000 --> 23:59:59.000
[音楽]。

