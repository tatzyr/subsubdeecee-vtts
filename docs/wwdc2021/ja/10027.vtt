WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:11.000
こんにちは。私の名前はエリー・エプスカンプ・ハントです。

00:00:11.000 --> 00:00:13.000
私はサファリのエンジニアとして働いています。

00:00:13.000 --> 00:00:18.000
今日は、Safariで利用できる新しいWeb拡張APIの概要を説明します。

00:00:18.000 --> 00:00:22.000
昨年、SafariはmacOSでWeb Extensions APIのサポートを追加しました。

00:00:22.000 --> 00:00:29.000
この新しいAPIサポートを使用する過去1年間に出荷されたすべての新しいSafari拡張機能を見るのは驚くべきことです。

00:00:29.000 --> 00:00:35.000
そして、このリリースでは、iOSとiPadOSにウェブ拡張機能をもたらすことに本当に興奮しています。

00:00:35.000 --> 00:00:42.000
これらの新しいプラットフォームの拡張機能の詳細については、独自の専用セッション「iOSでSafari Web拡張機能に会う」で学ぶことができます。

00:00:42.000 --> 00:00:47.000
また、Safari Web Extensions全般についてもっと知りたい場合は、昨年のセッションをチェックしてください。

00:00:47.000 --> 00:00:49.000
今日は、3つの新しい拡張APIを取り上げます。

00:00:49.000 --> 00:00:56.000
まず、パフォーマンスを向上させるために拡張機能を構成する方法である非永続的な背景ページについて説明します。

00:00:56.000 --> 00:01:00.000
次に、宣言型ネットリクエストと呼ばれるWeb拡張機能用のコンテンツブロックAPIを紹介します。

00:01:00.000 --> 00:01:04.000
そして最後に、拡張機能がSafariで新しいタブをカスタマイズする方法を見ていきます。

00:01:04.000 --> 00:01:09.000
この新しいAPIについてもっと学ぶ前に、永続的なバックグラウンドページについて話しましょう。

00:01:09.000 --> 00:01:13.000
Web拡張機能は、JavaScript、HTML、およびCSSを使用して作成されます。

00:01:13.000 --> 00:01:18.000
一部の拡張機能には、バックグラウンドページと呼ばれるブラウザのバックグラウンドで実行されるスクリプトがあります。

00:01:18.000 --> 00:01:24.000
目に見えるUIはありませんが、タブの開口部や拡張機能の別の部分からのメッセージなどのイベントに反応することができます。

00:01:24.000 --> 00:01:27.000
永続的な背景ページは決して閉じません。

00:01:27.000 --> 00:01:33.000
したがって、ブラウザで2つの拡張機能をオンにすると、2つのバックグラウンドページが常に実行されます。

00:01:33.000 --> 00:01:39.000
そして、8つの拡張機能を使用する場合、それは常にバックグラウンドで実行されている8つの拡張プロセスです。

00:01:39.000 --> 00:01:41.000
ここに問題があることがわかります。これは問題です。

00:01:41.000 --> 00:01:48.000
永続的な背景ページは、ユーザーが決して閉じることができないこれらの目に見えないタブのようなもので、メモリを消費し、CPU使用率を増加させます。

00:01:48.000 --> 00:01:53.000
ユーザーは、拡張機能の使用とブラウザから優れたパフォーマンスを引き出すことの間で妥協する必要はありません。

00:01:53.000 --> 00:01:57.000
したがって、代わりに、拡張機能は非永続的な背景ページを採用することができます。

00:01:57.000 --> 00:02:05.000
これらのタイプのページは、必要に応じて行ったり来たりすることができ、拡張機能のパフォーマンスが向上し、ユーザーに全体的により良いブラウジング体験を提供します。

00:02:05.000 --> 00:02:13.000
iOS用に開発している場合は、iOSデバイスのリソース制約があるため、拡張機能には非永続的なバックグラウンドページが必要です。

00:02:13.000 --> 00:02:19.000
永続的な背景ページを使用する理由を理解したので、それらがどのように機能するかを見てみましょう。 それらがどのように機能するかを見てみましょう。

00:02:19.000 --> 00:02:22.000
非永続的な背景ページの寿命は、イベントを中心に構成されています。

00:02:22.000 --> 00:02:30.000
バックグラウンドページは、タブの閉鎖や拡張機能の別の部分からのメッセージなど、ブラウザで起こることに反応するためにイベントリスナーを登録します。

00:02:30.000 --> 00:02:35.000
また、これらのイベントは、ブラウザがバックグラウンドページを読み込むかアンロードするかを判断するのに役立ちます。

00:02:35.000 --> 00:02:37.000
例を見てみましょう。 例を見てみましょう。

00:02:37.000 --> 00:02:43.000
拡張機能がオンまたは更新されると、バックグラウンドページが読み込まれ、イベントリスナーが登録されます。

00:02:43.000 --> 00:02:49.000
この例のために、この背景ページには、コンテンツスクリプトからのメッセージのリスナーが正確に1つあるとします。

00:02:49.000 --> 00:02:57.000
時間が経過し、コンテンツスクリプトがメッセージを送信しない場合、その非アクティブのため、バックグラウンドページはブラウザによってアンロードされます。

00:02:57.000 --> 00:03:06.000
しかし、コンテンツスクリプトがメッセージを送信すると、バックグラウンドページがスリープされ、そのメッセージを受信して反応することができます。

00:03:06.000 --> 00:03:11.000
そして、イベントが発生した後、背景ページはロードされたままになります。

00:03:11.000 --> 00:03:16.000
しかし、再び時間が経過し、イベントが発生しない場合、背景ページはアンロードされます。

00:03:16.000 --> 00:03:22.000
したがって、そのメンタルモデルを念頭に置いて、非永続的な背景ページを実際に実装する方法について話すことができます。

00:03:22.000 --> 00:03:27.000
まず、マニフェストの背景セクションに「永続的」キーを追加します。

00:03:27.000 --> 00:03:31.000
そして、バックグラウンドスクリプトにさらにいくつかの変更を加える必要があるかもしれません。

00:03:31.000 --> 00:03:37.000
バックグラウンドページはアンロードできるため、必要に応じてストレージAPIを使用してディスクに情報を書き込む必要があります。

00:03:37.000 --> 00:03:41.000
Browser.storageを使用して、バックグラウンドページの存続期間にわたって情報を維持します。

00:03:41.000 --> 00:03:45.000
次に、スクリプトの最上位レベルでイベントリスナーを登録する必要があります。

00:03:45.000 --> 00:03:50.000
別のイベントリスナーの完了ハンドラにリスナーを登録しないでください。

00:03:50.000 --> 00:03:53.000
そして、タイマーの代わりにbrowser.alarms APIを使用したいと思うでしょう。

00:03:53.000 --> 00:03:57.000
バックグラウンドページがアンロードされている場合、タイマーは呼び出されません。

00:03:57.000 --> 00:04:00.000
では、避けたいコードについて話しましょう。

00:04:00.000 --> 00:04:03.000
browser.extensionへの呼び出しを削除します。getBackgroundPage。

00:04:03.000 --> 00:04:07.000
すでにアンロードされている場合、バックグラウンドページは起動しません。

00:04:07.000 --> 00:04:10.000
そして最後に、webRequestリスナーを削除する必要があります。

00:04:10.000 --> 00:04:19.000
webRequestは、Webトラフィックを分析できるAPIであり、webRequestイベントが発生する頻度により、このAPIは非永続的なバックグラウンドページと互換性がありません。

00:04:19.000 --> 00:04:22.000
だから、これらすべてが一緒にどのように機能するかを見るために、Safariで試してみましょう。

00:04:22.000 --> 00:04:27.000
私はSafariの拡張機能に関する昨年のセッションのサンプルコードの修正版を使用しています。

00:04:27.000 --> 00:04:34.000
この拡張機能は、ウェブページの単語を絵文字に置き換えることができ、合計置換が発生した数を報告します。

00:04:34.000 --> 00:04:37.000
まず、この拡張機能が変更を加えずに何をするかを見てみましょう。

00:04:37.000 --> 00:04:42.000
マニフェストに「永続的な」キーを省略したため、バックグラウンドページはデフォルトで永続的です。

00:04:42.000 --> 00:04:45.000
拡張機能を含むアプリを構築して実行します。

00:04:45.000 --> 00:04:48.000
そして、Safariの環境設定でオンにします。

00:04:48.000 --> 00:04:50.000
今、私はウェブページで拡張機能を使用します。

00:04:50.000 --> 00:04:58.000
魚に関するこのウィキペディアの記事に行きましょう、そして私は拡張機能と対話するためにポップオーバーを使用します。

00:04:58.000 --> 00:05:03.000
「単語を置き換える」ボタンをクリックすると、「魚」という単語のすべてのインスタンスが魚の絵文字に置き換えられました。

00:05:03.000 --> 00:05:09.000
ポップオーバーをもう一度クリックすると、置き換えられた単語の総数が表示されます。

00:05:09.000 --> 00:05:13.000
この拡張機能のバックグラウンドページは、その置換数の追跡を担当しています。

00:05:13.000 --> 00:05:17.000
アクティビティモニターに行って、拡張プロセスを見てみましょう。

00:05:17.000 --> 00:05:21.000
ここでは、すべての拡張コードが実行されているウェブプロセスを見ることができます。

00:05:21.000 --> 00:05:30.000
拡張機能は永続的なバックグラウンドページを使用しているため、数時間後にこの拡張機能の使用を停止しても、Safariが実行されているときにこのプロセスは常に実行されます。

00:05:30.000 --> 00:05:35.000
では、この拡張機能をもう少し良くして、背景ページを非永続的にしましょう。

00:05:35.000 --> 00:05:39.000
最初に行うことは、マニフェストの背景セクションに「永続的」キーを追加することです。

00:05:39.000 --> 00:05:42.000
そして、ここで立ち止まって、私たちの拡張機能がまだ機能するかどうかを見てみましょう。

00:05:42.000 --> 00:05:45.000
拡張機能を含むアプリを構築します。

00:05:45.000 --> 00:05:48.000
Safariに戻ってページをリロードします。

00:05:48.000 --> 00:05:50.000
では、いくつかの単語を置き換えます。

00:05:50.000 --> 00:05:54.000
その後、私は少し待って、バックグラウンドページにアイドル状態になる時間を与えます。

00:05:54.000 --> 00:05:59.000
このデモの目的で、Safariを修正して、通常よりもはるかに速く背景ページをアンロードしました。

00:05:59.000 --> 00:06:06.000
Web Extension Background Pagesの下にある開発メニューで、バックグラウンドページが実際にアンロードされていることを確認できます。

00:06:06.000 --> 00:06:09.000
これは、背景ページを検査できる場所でもあります。

00:06:09.000 --> 00:06:13.000
アンロード時にページを検査することを選択した場合、すぐに読み込まれることに注意してください。

00:06:13.000 --> 00:06:16.000
背景ページがアンロードされたので、ポップオーバーをもう一度開きましょう。

00:06:16.000 --> 00:06:21.000
予想される数564の代わりに、ゼロの単語が置き換えられます。

00:06:21.000 --> 00:06:23.000
そのため、拡張機能にバグがあります。

00:06:23.000 --> 00:06:29.000
拡張機能が非永続的な背景ページで正しく機能するように、戻ってさらにいくつかの変更を加える必要があります。

00:06:29.000 --> 00:06:32.000
これは、拡張機能の背景ページのコードです。

00:06:32.000 --> 00:06:34.000
この背景ページは2つのことを行います。

00:06:34.000 --> 00:06:38.000
単語の置換カウントに1つを追加するか、現在のカウントを報告します。

00:06:38.000 --> 00:06:41.000
グローバル変数は、私たちのバグの原因です。

00:06:41.000 --> 00:06:44.000
バックグラウンドページがリロードされると、カウントは0にリセットされます。

00:06:44.000 --> 00:06:49.000
だから、564語が置き換えられたという状態を維持する代わりに、私たちはそれを失います。

00:06:49.000 --> 00:06:55.000
これを回避するには、browser.storage APIを使用して、必要に応じて単語数を保存してロードしましょう。

00:06:55.000 --> 00:07:00.000
まず、ストレージからそのカウントをロードするためのコードを追加します。

00:07:00.000 --> 00:07:06.000
ストレージAPIの結果を解析して、必要な値を取得します。

00:07:06.000 --> 00:07:11.000
そして、更新されるたびに、その価値をストレージに保存します。

00:07:11.000 --> 00:07:19.000
そして、そのonMessageリスナーをストレージコールバックの本体に持ち込みます。

00:07:19.000 --> 00:07:22.000
でも待って。私たちは問題を抱えています。

00:07:22.000 --> 00:07:28.000
イベントリスナーはスクリプトの最上位レベルで登録する必要があることを知っているので、これはうまくいきません。

00:07:28.000 --> 00:07:37.000
では、ここで物事を再構築し、ストレージコールをリスナーの体に持ち込みましょう。

00:07:37.000 --> 00:07:45.000
また、ストレージAPIを使用しているため、マニフェストにストレージ権限を追加する必要があります。

00:07:45.000 --> 00:07:50.000
次に、アプリを再構築し、拡張機能を再度テストします。

00:07:50.000 --> 00:07:53.000
私は以前とまったく同じことをします。

00:07:53.000 --> 00:07:57.000
魚に関するウィキペディアのページを見て、ページをリロードします。

00:07:57.000 --> 00:08:05.000
その後、私はいくつかの単語を置き換えてしばらく待って、私たちの背景にアンロードする時間を与えます。

00:08:05.000 --> 00:08:06.000
すごい。

00:08:06.000 --> 00:08:10.000
ポップオーバーでは、置き換えられた正しい数の単語が報告されています。

00:08:10.000 --> 00:08:16.000
永続的な背景ページを持つ拡張機能を取り、非永続的な背景ページを使用するように正常に変換しました。

00:08:16.000 --> 00:08:26.000
また、アクティビティモニターに戻ると、非永続的な背景ページを採用するためにこの作業を行ったため、背景ページがアンロードされた後、拡張プロセスは存在しなくなります。

00:08:26.000 --> 00:08:30.000
これは、Safariの非永続的なバックグラウンドページサポートの概要でした。

00:08:30.000 --> 00:08:37.000
iOS用の拡張機能を開発する場合は、非永続的な背景ページを採用する必要があることを覚えておいてください。

00:08:37.000 --> 00:08:41.000
次に、新しいコンテンツブロックAPIである宣言的なネットリクエストを見てみましょう。

00:08:41.000 --> 00:08:47.000
Safariは、2015年以来、WebKitコンテンツルールリストを使用して構築されたコンテンツブロッカー拡張機能をサポートしています。

00:08:47.000 --> 00:08:53.000
今年はいくつかの改善点があり、Appleの更新されたドキュメントで確認できます。

00:08:53.000 --> 00:09:00.000
しかし、ウェブ拡張機能は、これまでそのような高速でプライバシー保護、コンテンツブロック機能を持っていませんでした。

00:09:00.000 --> 00:09:06.000
Chromeによって最近導入された宣言的なネットリクエストAPIは、これらすべてのボックスをチェックします。

00:09:06.000 --> 00:09:10.000
基本をやり直しましょう。

00:09:10.000 --> 00:09:14.000
コンテンツブロックルールはJSON形式で書かれています。

00:09:14.000 --> 00:09:22.000
これらのJSONルールは、ルールセットと呼ばれるファイルに論理的にグループ化されており、これらのルールセットを個別にオンまたはオフに切り替えることができるJavaScript APIがあります。

00:09:22.000 --> 00:09:29.000
また、ChromeはこのAPIもサポートしているため、複数のプラットフォームで複数のブラウザで実行できる1つのコンテンツブロッカーを書くことができます。

00:09:29.000 --> 00:09:34.000
宣言型ネットリクエストを使用してコンテンツブロックルールを作成する方法を見てみましょう。

00:09:34.000 --> 00:09:38.000
最初のステップは、拡張機能のマニフェストにルールセットを指定することです。

00:09:38.000 --> 00:09:41.000
ここで、私は1つのルールセットを宣言しました。

00:09:41.000 --> 00:09:44.000
また、宣言的なネットリクエスト権限を追加する必要があります。

00:09:44.000 --> 00:09:49.000
以下は、ルールセットで指定したファイルの中に入る宣言的なネットリクエストルールの例です。

00:09:49.000 --> 00:09:52.000
それは4つの部分があります。

00:09:52.000 --> 00:09:59.000
一意のIDと優先順位があり、ルールが適用される順序を決定します。

00:09:59.000 --> 00:10:04.000
ルールのアクションピースでは、リソースのスキームをブロック、許可、またはアップグレードすることができます。

00:10:04.000 --> 00:10:09.000
そして、条件は、このルールを実行する場所と条件をSafariに伝える場所です。

00:10:09.000 --> 00:10:12.000
このルールの条件辞書には、2つのキーがあります。

00:10:12.000 --> 00:10:20.000
「regexFilter」はリソースURLと照合され、「resourceTypes」配列はブロックされるリソースのタイプを指定します。

00:10:20.000 --> 00:10:25.000
この条件辞書でサポートされているものについてもっと詳しく説明しましょう。

00:10:25.000 --> 00:10:32.000
宣言型ネットリクエストルールを使用してターゲットにできるすべてのリソースタイプを次に示します。

00:10:32.000 --> 00:10:38.000
「excludedResourceTypes」キーを使用すると、一致させたくないタイプを指定できます。

00:10:38.000 --> 00:10:46.000
「domainTypeキー」を使用すると、ロードされるリソースのドメインとドキュメントのドメインの関係に基づいてリソースをブロックできます。

00:10:46.000 --> 00:10:51.000
「ファーストパーティ」ロードは、URLがドキュメントと同じセキュリティオリジンを持つロードです。

00:10:51.000 --> 00:10:54.000
他のすべてのケースは「第三者」です。

00:10:54.000 --> 00:11:00.000
そして最後に、「大文字と小文字を区別する」キーを使用すると、正規表現フィルターが大文字と小文字を区別するかどうかを制御できます。

00:11:00.000 --> 00:11:03.000
デフォルトでは、それは本当です。

00:11:03.000 --> 00:11:08.000
それでは、宣言型ネットリクエストAPIを使用してコンテンツをブロックするウェブ拡張機能を構築しましょう。

00:11:08.000 --> 00:11:13.000
最初に行うことは、マニフェストに宣言的なネットリクエストセクションを追加することです。

00:11:13.000 --> 00:11:22.000
その宣言的なネットリクエストセクションの中に、ID、それがオンになっていることを示すブール、および私のルールを含むJSONファイルへのパスを書いてルールセットを追加します。

00:11:22.000 --> 00:11:26.000
そして、私たちがマニフェストにいる間、宣言的なネットリクエスト許可も追加します。

00:11:26.000 --> 00:11:31.000
ここから、ルールセットJSONファイルに入りましょう。

00:11:31.000 --> 00:11:37.000
すべてのウェブページで画像をブロックするルールを書きます。

00:11:37.000 --> 00:11:43.000
拡張機能を含むアプリを構築し、Safariを開きます。

00:11:43.000 --> 00:11:51.000
この拡張機能は、すべてのWebページのコンテンツをブロックできるにもかかわらず、閲覧履歴やWebページのコンテンツを表示する機能がないことに注意してください。

00:11:51.000 --> 00:11:56.000
拡張機能を有効にする前に、いくつかの画像を含むWebKitブログ投稿を開きます。

00:11:56.000 --> 00:12:00.000
このウェブページには2つの画像があることがわかります。

00:12:00.000 --> 00:12:10.000
環境設定に戻り、拡張機能をオンにしてからページをリロードすると、画像はブロックされます。

00:12:10.000 --> 00:12:14.000
では、魚に関するこのウィキペディアのページのような別のウェブページに行きましょう。

00:12:14.000 --> 00:12:19.000
画像もここでブロックされていますが、実際にはこの特定のページで画像を見ることができた方がいいです。

00:12:19.000 --> 00:12:24.000
だから、ここ以外のどこでも画像がブロックされるように拡張機能を変更しましょう。

00:12:24.000 --> 00:12:29.000
Xcodeに戻って、このページで画像を許可するルールを書きます。

00:12:29.000 --> 00:12:34.000
このルールのアクションタイプは「許可」になり、最初のブロッキングルールよりも優先度の高いルールになります。

00:12:34.000 --> 00:12:38.000
アプリを再構築してから、Safariに戻ります。

00:12:38.000 --> 00:12:42.000
ページをリロードします。

00:12:42.000 --> 00:12:49.000
しかし、私はまだ画像を見ていないので、この新しいルールは機能しませんでした。

00:12:49.000 --> 00:12:53.000
拡張機能の環境設定でエラーメッセージを探します。

00:12:53.000 --> 00:13:02.000
さて、文字列「image」の配列ではなく、リソースタイプキーに空の配列を使用したようです。

00:13:02.000 --> 00:13:05.000
間違いを直すためにXcodeに戻ります。

00:13:05.000 --> 00:13:17.000
再構築してSafariの環境設定に戻り、エラーメッセージが消えたことを確認します。

00:13:17.000 --> 00:13:20.000
その後、ページをリロードします。

00:13:20.000 --> 00:13:24.000
そして素晴らしい、画像はもはやこのウィキペディアのページでブロックされていません。

00:13:24.000 --> 00:13:29.000
つまり、ウェブ上のコンテンツをブロックできるウェブ拡張機能を構築する方法の概要でした。

00:13:29.000 --> 00:13:34.000
宣言型ネットリクエストの使用方法の詳細については、Appleのドキュメントを参照してください。

00:13:34.000 --> 00:13:38.000
最後に、拡張機能がSafariで新しいタブをカスタマイズする方法を見てみましょう。

00:13:38.000 --> 00:13:42.000
私たちは、ユーザーがブラウザをパーソナライズするのが大好きで、拡張機能がそれを行うための素晴らしい方法であることを知っています。

00:13:42.000 --> 00:13:49.000
新しいタブオーバーライドAPIを使用すると、拡張機能はSafariの新しいタブページを引き継ぎ、完全にカスタマイズできます。

00:13:49.000 --> 00:13:53.000
このAPIはすでにSafari 14.1で公開されています。

00:13:53.000 --> 00:13:57.000
新しいタブのオーバーライドはマニフェストで宣言されます。

00:13:57.000 --> 00:14:06.000
そして、ユーザーが新しいタブオーバーライドで拡張機能をオンにすると、その拡張機能がSafariで新しいタブを引き継ぐかどうかを選択します。

00:14:06.000 --> 00:14:10.000
マニフェストの新しいタブオーバーライドページを指摘する方法は次のとおりです。

00:14:10.000 --> 00:14:14.000
この新しいAPIを一緒に使用する拡張機能を構築しましょう。

00:14:14.000 --> 00:14:17.000
Sea Creator拡張機能に新しいタブオーバーライドを追加します。

00:14:17.000 --> 00:14:22.000
私たちの目標は、Safariで新しいタブを開くたびに楽しいウェブページが表示されるようにすることです。

00:14:22.000 --> 00:14:29.000
HTMLページがマニフェストの新しいタブオーバーライドであることを宣言することから始めます。

00:14:29.000 --> 00:14:33.000
使い既存のHTMLファイルとCSSファイルがいくつかあります。

00:14:33.000 --> 00:14:36.000
それらは私の拡張機能のリソースフォルダにあります。

00:14:36.000 --> 00:14:39.000
それらをXcodeプロジェクトに追加するだけです。

00:14:39.000 --> 00:14:42.000
Xcodeプロジェクトにファイルを追加したことがない場合は、心配しないでください。

00:14:42.000 --> 00:14:44.000
それはかなり簡単です。

00:14:44.000 --> 00:14:58.000
[ファイル]をクリックし、[Sea Creatorにファイルを追加]をクリックし、追加したいファイルを選択し、それらが拡張ターゲットの一部であり、アプリのターゲットではないことを確認します。

00:14:58.000 --> 00:15:02.000
このHTMLは、楽しい事実を持つカラフルなページを作成します。

00:15:02.000 --> 00:15:09.000
では、アプリを実行して、Safariで拡張機能をオンにします。

00:15:09.000 --> 00:15:14.000
このプロンプトが表示され、この拡張機能が新しいタブとウィンドウを引き継ぐことができるかどうかを尋ねられます。

00:15:14.000 --> 00:15:19.000
私はそれを許可します。

00:15:19.000 --> 00:15:25.000
後でこれを変更したい場合は、一般設定に入ることができます。

00:15:25.000 --> 00:15:29.000
しかし今、Safariで新しいタブを作成すると、新しいタブページが表示されます。

00:15:29.000 --> 00:15:31.000
かなり良さそうですね！

00:15:31.000 --> 00:15:34.000
しかし、私はいくつかの微調整をしたい。

00:15:34.000 --> 00:15:40.000
私の新しいタブオーバーライドページには、あまり素敵なタイトルがありません。

00:15:40.000 --> 00:15:48.000
Xcodeに戻って、Safariのタブバーでページが良く見えるようにタイトルを追加します。

00:15:48.000 --> 00:15:54.000
Safariがページから推測したものとは異なるものが必要な場合は、別のテーマカラーを選択することもできます。

00:15:54.000 --> 00:15:57.000
私が使用しているこのメタタグは、新しいタブのオーバーライドに固有のものではありません。

00:15:57.000 --> 00:15:59.000
それはどのウェブページでも機能します。

00:15:59.000 --> 00:16:09.000
SafariのUIの変更についてもっと知りたい場合は、「Design for Safari 15」というセッションを必ずチェックしてください。

00:16:09.000 --> 00:16:11.000
それが今どのように見えるか見てみましょう。

00:16:11.000 --> 00:16:14.000
もう一度建てます。

00:16:14.000 --> 00:16:17.000
そして、Safariに戻って、新しいタブを作成します。

00:16:17.000 --> 00:16:19.000
すごい。

00:16:19.000 --> 00:16:24.000
Sea Creator拡張機能に新しいタブオーバーライドを正常に追加しました。

00:16:24.000 --> 00:16:29.000
そして、それは拡張機能がSafariで新しいタブをカスタマイズする方法を見ていました。

00:16:29.000 --> 00:16:34.000
今日は、macOSとiOSのSafariで利用可能な3つの新しいWeb拡張APIについて議論しました。

00:16:34.000 --> 00:16:39.000
このセッションに関連するサンプルプロジェクトをダウンロードして、新しいAPIで遊ぶことをお勧めします。

00:16:39.000 --> 00:16:45.000
これらの拡張機能がmacOSでどのように機能するかをお見せしましたが、iOSでも機能します。

00:16:45.000 --> 00:16:47.000
私たちはまた、あなたの考えを知りたいです。

00:16:47.000 --> 00:16:53.000
フィードバックアシスタントを使用してバグを提出することも、Safari開発者フォーラムで私たちとチャットすることもできます。

00:16:53.000 --> 00:16:57.000
そして最後に、あなたがまだしていない場合は、私が今日言及した他のセッションをチェックしてください。

00:16:57.000 --> 00:16:59.000
ありがとう、そして素晴らしいWWDCをお過ごしください。

00:16:59.000 --> 23:59:59.000
[エーテルパーカッション音楽]。

