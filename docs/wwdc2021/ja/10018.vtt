WEBVTT

00:00:00.000 --> 00:00:05.000
♪ベース音楽の演奏♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:15.000
マット・リケットソン：「SwiftUIの新機能」へようこそ。私はマットで、後でテイラーが加わります。

00:00:15.000 --> 00:00:20.000
このセッションは、Appleの宣言型UIフレームワークであるSwiftUIに関するものです。

00:00:20.000 --> 00:00:25.000
SwiftUIはまだ若いですが、私たちはすでにここまで来ています。

00:00:25.000 --> 00:00:36.000
SwiftUIは2019年に初めてリリースされ、宣言的で状態主導のスタイルでユーザーインターフェイスを構築する強力な新しい方法を導入しました。

00:00:36.000 --> 00:00:46.000
SwiftUIの2番目のリリースで次の大きな一歩を踏み出し、新しいアプリとシーンAPIで100%のSwiftUIアプリを有効にしました。

00:00:46.000 --> 00:00:55.000
今年は、豊富な新機能を備えたアプリでのSwiftUIのより深い採用をサポートすることに重点を置いています。

00:00:55.000 --> 00:01:00.000
今、あなたがまだ自分でSwiftUIを試す機会がなかったなら、それは大丈夫です!

00:01:00.000 --> 00:01:04.000
あなたのアプリに最適なものを知っているのはあなただけです。

00:01:04.000 --> 00:01:10.000
しかし、今年利用可能なすべての新機能について学ぶ際に心に留めておくべきヒントがいくつかあります。

00:01:10.000 --> 00:01:23.000
SwiftUIにつま先を浸す良い方法は、iOS、iPadOS、macOSのNotesの新しいアクティビティストリームを強化する方法など、既存のアプリでまったく新しい機能を作成することです。

00:01:23.000 --> 00:01:28.000
または、SwiftUIで構築されたmacOSの新しいアバターピッカー。

00:01:28.000 --> 00:01:36.000
既存のUIKitまたはAppKitコードと一緒にSwiftUIを混ぜることができることを忘れないでください。

00:01:36.000 --> 00:01:44.000
SwiftUIは、SwiftUIを使用してmacOSで新しいショートカットアプリを構築する方法など、アプリを新しいプラットフォームに拡張するための便利なツールでもあります。

00:01:44.000 --> 00:01:54.000
SwiftUIを使用すると、各デバイスに独自のエクスペリエンスを作成しながら、プラットフォーム間で共通のコードを簡単に共有できます。

00:01:54.000 --> 00:01:59.000
そして、アプリを再設計する準備ができたら、SwiftUIを持ち込むのに最適な時期です。

00:01:59.000 --> 00:02:12.000
まったく新しいApple Payの購入フローは、SwiftUIを使用して再設計されました。SwiftUIは、macOSの新しいHelp ViewerとwatchOSのTipsアプリに新鮮な塗料をもたらすためにも使用されました。

00:02:12.000 --> 00:02:21.000
そして最後に、SwiftUIでゼロから再構築されたiOS用の豪華な新しい天気アプリを忘れることはできません。

00:02:21.000 --> 00:02:28.000
これらは、SwiftUIが次世代のアプリの構築にどのように役立っているかのほんの一例です。

00:02:28.000 --> 00:02:34.000
このセッションでは、それをすべて可能にした素晴らしい新しいAPIのいくつかを共有したいと思います。

00:02:34.000 --> 00:02:40.000
まず、リストとグリッドを使用してコンテンツのコレクションを構築する方法の改善を歩きます。

00:02:40.000 --> 00:02:48.000
次に、リストを超えて、データ駆動型アプリを次のレベルに引き上げるための新機能を紹介します。

00:02:48.000 --> 00:02:54.000
第三に、グラフィックや視覚効果を駆動するためのいくつかの素晴らしい新しいツールを披露します。

00:02:54.000 --> 00:02:59.000
テキスト、キーボード、フォーカスベースのナビゲーションの強化について説明します。

00:02:59.000 --> 00:03:03.000
そして最後に、私たちはボタンにいくつかの愛を与えます。

00:03:03.000 --> 00:03:13.000
それでは、SwiftUIアプリ内でデータを整理して表示するための重要な機能であるリストとグリッドから始めましょう。

00:03:13.000 --> 00:03:20.000
今年は、リッチでインタラクティブなリストとグリッドの作成をさらに簡単にします。

00:03:20.000 --> 00:03:22.000
楽しいものから始めましょう。

00:03:22.000 --> 00:03:28.000
SwiftUIには、画像を非同期にロードするためのサポートが組み込まれています。

00:03:28.000 --> 00:03:34.000
SwiftUIは、新しいAsyncImageビューでこれらの画像の読み込みを簡単にします。

00:03:34.000 --> 00:03:43.000
URLを与えるだけで、SwiftUIは自動的にリモート画像をフェッチして表示し、デフォルトのプレースホルダも提供します。

00:03:43.000 --> 00:03:45.000
AsyncImageはカスタマイズすることもできます。

00:03:45.000 --> 00:03:55.000
たとえば、ロードされた画像に修飾子を追加したり、ここで楽しい色を追加したりするように、カスタムプレースホルダを定義したりできます。

00:03:55.000 --> 00:03:58.000
カスタムアニメーションやエラー処理を追加することもできます!

00:03:58.000 --> 00:04:02.000
また、AsyncImageはすべてのプラットフォームで利用できます。

00:04:02.000 --> 00:04:05.000
ぜひチェックしていただければ幸いです。

00:04:05.000 --> 00:04:14.000
AsyncImageはすぐにコンテンツをロードしますが、フィードを表示するときなど、アプリがリクエストに応じてコンテンツをロードする必要がある場合があります。

00:04:14.000 --> 00:04:23.000
これは、新しいリフレッシュ可能な修飾子を使用して、iOSとiPadOSでプルツーリフレッシュをサポートするための優れたユースケースです。

00:04:23.000 --> 00:04:29.000
この修飾子は、リフレッシュアクションを設定し、環境を通過します。

00:04:29.000 --> 00:04:40.000
iOSとiPadOSのリストでは、このアクションを使用してプルツーリフレッシュを自動的に追加しますが、独自のカスタムリフレッシュ動作を構築するためにも使用できます。

00:04:40.000 --> 00:04:47.000
Swift 5.5の新しい並行性言語機能の1つであるこの新しいawaitキーワードに気付いたかもしれません。

00:04:47.000 --> 00:04:56.000
これは、updateItemsメソッドが非同期アクションであり、UIをブロックせずにリストを更新できることを示しています。

00:04:56.000 --> 00:05:02.000
もう1つの新しい並行性関連のSwiftUI機能は、タスク修飾子です。

00:05:02.000 --> 00:05:07.000
このAPIを使用すると、ビューの存続期間に非同期タスクを添付できます。

00:05:07.000 --> 00:05:14.000
つまり、ビューが最初に読み込まれたときにタスクが開始され、ビューが削除されると自動的にキャンセルされます。

00:05:14.000 --> 00:05:19.000
これは、写真の最初のバッチを自動的に読み込むのに最適な方法です。

00:05:19.000 --> 00:05:28.000
これらの新しい並行性修飾子は、表面上はシンプルに見えますが、アプリに洗練された非同期動作を構築するために使用できます。

00:05:28.000 --> 00:05:35.000
たとえば、ここでは、最新の写真が利用可能になったときに読み込むタスクを設定しました。

00:05:35.000 --> 00:05:41.000
私は通常のループを書きましたが、ここでもawaitキーワードが使用されていることに気付くでしょう。

00:05:41.000 --> 00:05:49.000
これは、new newestCandidatesが実際には非同期シーケンスであり、Swift 5.5のもう1つの新しい並行性機能であるためです。

00:05:49.000 --> 00:05:57.000
これは、最新の候補者を非同期に待機し、次の候補者が利用可能な場合にのみループを反復することを意味します。

00:05:57.000 --> 00:06:02.000
つまり、実際にはこの単一の修飾子に大量の機能を詰め込んでいるということです。

00:06:02.000 --> 00:06:18.000
ビューは、表示されるとすぐに候補者を非同期にリッスンするタスクを開始し、新しい候補者が利用可能になるたびにリストを更新し、ビューが消えたときに自動的にタスクをキャンセルします。

00:06:18.000 --> 00:06:26.000
Swiftの並行性とSwiftUIでそれを活用する方法について学ぶべきことがたくさんあるので、詳細を掘り下げるために他のいくつかの講演を準備しました。

00:06:26.000 --> 00:06:35.000
「SwiftUIで並行性を発見する」は、並行性がSwiftUIのアップデートモデルとどのように関連しているかを説明し、先ほど説明した新機能をデモします。

00:06:35.000 --> 00:06:45.000
そして、「Swift並行性：サンプルアプリを更新する」では、非同期モデルコードを使用して既存のプロジェクトをアップグレードすることを段階的に説明します。

00:06:45.000 --> 00:06:51.000
次に、リストコンテンツにインタラクティブ性を組み込むための新しい、より良い方法を提供します。

00:06:51.000 --> 00:06:58.000
この例では、私の超秘密の隠れ家への道順を共有するための簡単なリストを書きました。

00:06:58.000 --> 00:07:00.000
これは素敵に見えますが、テキストは編集できません。

00:07:00.000 --> 00:07:02.000
それを直しましょう。

00:07:02.000 --> 00:07:07.000
代わりにテキストフィールドに交換することで、テキストを編集可能にすることができます。

00:07:07.000 --> 00:07:10.000
ただし、テキストフィールドにはテキストへのバインディングが必要です。

00:07:10.000 --> 00:07:18.000
リストのコンテンツクロージャでは、バインディングではなく、コレクション内の各要素のプレーンな値のみが与えられます。

00:07:18.000 --> 00:07:26.000
このような状況では、各行のコレクション要素へのバインディングを取得する方法を理解するのは難しい場合があります。

00:07:26.000 --> 00:07:35.000
一般的なアプローチの1つは、代わりにコレクションのインデックスを反復し、添字を使用してそのインデックスの要素へのバインディングを取得することです。

00:07:35.000 --> 00:07:45.000
ただし、SwiftUIは何か変更されたときにリスト全体をリロードすることを余儀なくされるため、このテクニックは推奨されません。

00:07:45.000 --> 00:07:50.000
実際、私たちはこのトピックをより詳細に議論する全体の講演を準備しました。

00:07:50.000 --> 00:07:59.000
詳細については、「Demystify SwiftUI」を見ることをお勧めします。とりあえず、これらの変更を元に戻して、より良い解決策を見てみましょう。

00:07:59.000 --> 00:08:08.000
今年、SwiftUIは、コレクション内の個々の要素のバインディングにアクセスするためのはるかに簡単な方法を提供しています。

00:08:08.000 --> 00:08:19.000
通常のドル記号演算子を使用して、コレクションへのバインディングをリストに渡すだけで、SwiftUIはクロージャ内の個々の要素にバインディングを返します。

00:08:19.000 --> 00:08:26.000
値を読み取るだけでいいコードは、あなたが慣れているように、以前とまったく同じままです。

00:08:26.000 --> 00:08:40.000
しかし、慣れている通常のバインディング構文を使用して、テキストフィールドのようなインタラクティブなコントロールを簡単に追加できます。つまり、以前に含めるのを忘れたスーパーシークレットドアコードを最終的に入力できます。

00:08:40.000 --> 00:08:46.000
この新しい構文はSwift言語の一部であるため、リストだけでなく、どこでも機能します。

00:08:46.000 --> 00:08:51.000
たとえば、代わりにリスト内のForEachビューで同じテクニックを使用できます。

00:08:51.000 --> 00:08:58.000
さらに良いことに、このコードをSwiftUIでサポートされている以前のリリースにバックデプロイすることもできます。

00:08:58.000 --> 00:09:01.000
しかし、私たちはあなたの既存のコードを書きやすくしているだけではありません。

00:09:01.000 --> 00:09:04.000
リストもいくつかの素晴らしい新機能を獲得しています!

00:09:04.000 --> 00:09:08.000
リストを視覚的にカスタマイズする新しい方法から始めましょう。

00:09:08.000 --> 00:09:19.000
新しいlistRowSeparatorTint修飾子を使用すると、各行の区切り文字とアイコンの色を揃えるためにここで行ったように、個々の行区切り文字の色を変更できます。

00:09:19.000 --> 00:09:23.000
SwiftUIには、セクションセパレータの同等の修飾子もあります。

00:09:23.000 --> 00:09:27.000
しかし、このアプリでは、これらすべてのセパレータが少し気を散らすようです。

00:09:27.000 --> 00:09:31.000
私の指示を単一の統一された流れのように感じてほしい。

00:09:31.000 --> 00:09:39.000
新しいlistRowSeparator修飾子で、セパレータを非表示にするように設定できるようになったので、それらを削除してみてください。

00:09:39.000 --> 00:09:42.000
今、私たちの方向ははるかに散らかっていないように感じます。

00:09:42.000 --> 00:09:47.000
私が作っている別のアプリを見てみましょう...

00:09:47.000 --> 00:09:52.000
...これは、漫画作家がすべてのスーパーヒーローと悪役を追跡するのに役立ちます。

00:09:52.000 --> 00:10:02.000
このアプリは、スワイプアクションを使用して、迅速かつ便利に文字を固定および削除しますが、追加のコントロールでUIを乱雑にしません。

00:10:02.000 --> 00:10:09.000
今年の新機能であるSwiftUIでは、新しいswipsActions修飾子を使用して、完全にカスタムのスワイプアクションを定義できます。

00:10:09.000 --> 00:10:15.000
SwiftUIの他の種類のメニューと同様にスワイプアクションを設定し、ボタンを使用してアクションを定義します。

00:10:15.000 --> 00:10:22.000
また、ピンアクションを黄色にするために使用している新しい色合い修飾子を追加して、色をカスタマイズすることもできます。

00:10:22.000 --> 00:10:27.000
デフォルトでは、SwiftUIは行の後端にスワイプアクションを表示します。

00:10:27.000 --> 00:10:32.000
しかし、修飾子のエッジパラメータを使用して、それらを先頭側に切り替えることができます。

00:10:32.000 --> 00:10:40.000
異なるエッジ構成で複数の修飾子を追加することで、先頭と末尾の両方のスワイプアクションをサポートすることもできます。

00:10:40.000 --> 00:10:49.000
そして最後に、sワイプアクション修飾子は、それらをサポートするすべてのプラットフォームで利用でき、マルチプラットフォームアプリ内でコードを簡単に共有できます。

00:10:49.000 --> 00:10:53.000
他のプラットフォームといえば、私のアプリのmacOSバージョンをチェックしてみましょう。

00:10:53.000 --> 00:10:59.000
これは、Macで利用可能な余分なスペースを利用するマルチカラムインターフェースを示しています。

00:10:59.000 --> 00:11:05.000
すべてのデータをサイドバーに詰め込む代わりに、すべてのキャラクターを一覧表示する概要タブがあります。

00:11:05.000 --> 00:11:09.000
これにより、ピン留めされた文字をサイドバーに保存できます。

00:11:09.000 --> 00:11:11.000
しかし、このリストは少し明白に感じます。

00:11:11.000 --> 00:11:13.000
それを少し盛り上げてみよう。 

00:11:13.000 --> 00:11:15.000
これが私の既存のコードです。

00:11:15.000 --> 00:11:20.000
現在、ウィンドウ内にリストをスムーズに合わせるために、挿入リストスタイルを使用しています。

00:11:20.000 --> 00:11:29.000
そして、今年すべてのビュースタイルで利用可能な新しい列挙型のような構文を使用して、このスタイルをコードで美しく表現することができます。

00:11:29.000 --> 00:11:33.000
今年も新しく、インセットリストスタイルは新しいトリックを獲得しています。

00:11:33.000 --> 00:11:41.000
alternatesRowBackgroundsフラグでスタイルを変更するだけで、行の背景を交互にできるようになりました。

00:11:41.000 --> 00:11:46.000
私たちのリストは今、各行が他の行と明確に区別され、はるかに良く見えます。

00:11:46.000 --> 00:11:53.000
しかし、macOSアプリの場合、ウィンドウ内のすべてのスペースを最大限に活用していないように感じます。

00:11:53.000 --> 00:11:58.000
次のセクションでは、リストを超えて、アプリをさらに理解しましょう。

00:11:58.000 --> 00:12:05.000
このすべてのスペースをよりよく活用するために、リストを豊富な複数列のテーブルにアップグレードしましょう!

00:12:05.000 --> 00:12:09.000
4つの列で、私は今1つの価格で4つのリストを取得します!

00:12:09.000 --> 00:12:18.000
しかし、最良の部分は、このような適度に複雑なテーブルは、単一のスライドに収まるほど少ないコードで宣言できることです。

00:12:18.000 --> 00:12:23.000
なぜなら、テーブルはSwiftUI全体で慣れているのと同じ種類の宣言型構造を使用しているからです。

00:12:23.000 --> 00:12:28.000
リストと同様に、単一のコンテンツコレクションからテーブルを作成できます。

00:12:28.000 --> 00:12:36.000
しかし、リストとは異なり、テーブルは各ビジュアル列内のコンテンツを定義するTableColumnsで構成されています。

00:12:36.000 --> 00:12:46.000
これらの各列は視覚的にラベル付けされ、コレクションのデータを使用して、テキストを表示するなどの一般的なケースのためのいくつかの速記的な利便性で視覚的なコンテンツを定義します。

00:12:46.000 --> 00:12:56.000
しかし、テーブルもインタラクティブで、通常のリストと同様に、単一の行と複数の行の両方の行選択をサポートします。

00:12:56.000 --> 00:13:02.000
テーブルは、列のソート可能な値へのキーパスの助けを借りてソートもサポートしています。

00:13:02.000 --> 00:13:10.000
現在、テーブルは、複数の異なるビジュアルスタイルや、各列の外観の微調整など、他のいくつかの機能をサポートしています。

00:13:10.000 --> 00:13:14.000
しかし、テーブルやリストに提供するデータについてもっと話しましょう。

00:13:14.000 --> 00:13:19.000
今年は、SwiftUIのCoreDataフェッチリクエストのサポートにいくつかの新しい機能強化があります。

00:13:19.000 --> 00:13:33.000
FetchRequestsは、ソート記述子へのバインディングを提供し、テーブルに渡すことができ、選択列とソート可能な列を備えた完全なコアデータ駆動型テーブルをわずか数行のコードで記述できます。

00:13:33.000 --> 00:13:44.000
SwiftUIは現在、セクション化されたフェッチ要求も提供しており、単一の要求から駆動される右側のような複雑なマルチセクションリストを可能にします。

00:13:44.000 --> 00:13:49.000
この例では、ピン留めされているかどうかに基づいて、データをセクションに分割します。

00:13:49.000 --> 00:14:00.000
複数のSortDescriptorsを使用してデータを配置し、最初にピン留めされたセクションとピン留めされていないセクションに分割し、次に最近変更された文字を最後に並べ替えます。

00:14:00.000 --> 00:14:03.000
次に、変更をアニメーション化することを指定します。

00:14:03.000 --> 00:14:12.000
そして最後に、リクエストの結果に基づいて、リストのセクションと行を動的に構築します。

00:14:12.000 --> 00:14:18.000
すべて一緒に、この単一のリクエストは、右側のアニメーションリストを駆動することができます。

00:14:18.000 --> 00:14:28.000
macOS用のアプリの構築、テーブルの操作、SwiftUIとのコアデータの統合の詳細については、これらの他の講演を必ずチェックしてください。

00:14:28.000 --> 00:14:35.000
「SwiftUI on the Mac」の2部構成のシリーズでは、Mac用に最適化されたアプリの構築を段階的に説明します。

00:14:35.000 --> 00:14:44.000
そして、「SwiftとSwiftUIにコアデータの並行性をブリングする」は、新しいコアデータフェッチ要求APIをより詳細にカバーします。

00:14:44.000 --> 00:14:50.000
今、一歩下がって、ユーザーがこのすべてのデータの中で必要なものを見つけるのをどのように支援できるかを考える時が来ました。

00:14:50.000 --> 00:14:54.000
もちろん、私は検索について話しています。

00:14:54.000 --> 00:14:57.000
検索は、すべてのプラットフォームの重要な部分です。

00:14:57.000 --> 00:15:01.000
これは、ユーザーが必要なときに必要なものを正確に見つけるのに役立ちます。

00:15:01.000 --> 00:15:08.000
Apple TVのような大型デバイスでも、Apple Watchのような最小のデバイスでも見つかります。

00:15:08.000 --> 00:15:16.000
したがって、検索はマルチプラットフォームの問題であるため、これらすべてのデバイスに拡張できるマルチプラットフォームソリューションが必要です。

00:15:16.000 --> 00:15:24.000
幸いなことに、アプリに検索を追加するのは簡単ではありません。NavigationViewで行ったように、検索可能な修飾子を追加するだけです。

00:15:24.000 --> 00:15:35.000
この1つの修飾子を使用すると、SwiftUIはアプリの適切な場所に検索フィールドを自動的に追加し、オプションでプラットフォームとコンテキストに適した方法で提案を表示します。

00:15:35.000 --> 00:15:41.000
修飾子は検索テキストにバインドされ、現在の値に基づいてデータをフィルタリングできます。

00:15:41.000 --> 00:15:51.000
さて、SwiftUIでの検索について言いたいことはたくさんありますが、幸いなことに、複数のプラットフォームでの検索機能について考える方法を説明するセッションがあります。

00:15:51.000 --> 00:15:55.000
詳細については、「SwiftUIでのクラフト検索体験」をご覧ください。

00:15:55.000 --> 00:16:04.000
これまでのところ、リストとグリッドを使用してアプリのデータをロード、表示、整理、検索する方法を探りました。

00:16:04.000 --> 00:16:08.000
それでは、アプリを超えてそのデータを共有する方法について話しましょう。

00:16:08.000 --> 00:16:13.000
データを共有する最も簡単な方法の1つは、アプリから引きずり出すことです。

00:16:13.000 --> 00:16:21.000
私のヒーローズ&amp;ヴィランアプリでは、既存のonDrag修飾子を使用してドラッグできるように詳細画面のキャラクターアイコンを設定しました。

00:16:21.000 --> 00:16:26.000
今年新しく、ドラッグ可能なビューにカスタムプレビューを追加できるようになりました。

00:16:26.000 --> 00:16:32.000
このプレビューは、ドラッグ中にビューの代わりに表示されます。

00:16:32.000 --> 00:16:39.000
ドラッグアンドドロップはアイテムプロバイダーによって駆動され、異なるプロセス間でデータをコピーして共有することができます。

00:16:39.000 --> 00:16:57.000
今年、SwiftUIは、新しいimportsItemProviders修飾子を使用して、外部サービスからのアイテムプロバイダーのインポートをサポートするようにアプリを設定するなど、アイテムプロバイダーを使用して他のアプリやサービスと統合するいくつかの方法を提供しています。

00:16:57.000 --> 00:17:05.000
この例では、画像をインポートし、ストーリーキャラクターに添付ファイルとして追加できるようにビューを設定しました。

00:17:05.000 --> 00:17:11.000
この機能を新しいmacOS機能であるContinuity Cameraとペアリングできます。

00:17:11.000 --> 00:17:21.000
アプリのメインメニューに「デバイスからインポート」コマンドを追加することで、iPhoneまたはiPadを使用して写真を撮るだけでMacアプリにインポートできるようになりました。

00:17:21.000 --> 00:17:23.000
やってみよう！

00:17:23.000 --> 00:17:26.000
ビュービルダーのスーパーヒーローのシンボルは、彼女の信頼できるハンマーです。

00:17:26.000 --> 00:17:30.000
彼女のプロフィールにその写真を添付するのは素晴らしいことです。

00:17:30.000 --> 00:17:34.000
幸いなことに、私はたまたまここにそれを持っています!

00:17:34.000 --> 00:17:42.000
アプリ内から、ファイルメニューの「デバイスからインポート」コマンドにアクセスできます。

00:17:42.000 --> 00:17:49.000
その後、iPhoneを使って写真を撮ることを選択できます...

00:17:49.000 --> 00:17:56.000
....カメラアプリが自動的に開くので、すぐに写真を撮ることができます。

00:17:56.000 --> 00:18:03.000
そして、新しい写真は、以前に示したimportsItemProviders修飾子を使用して、私のアプリにインポートされ、追加されます。

00:18:03.000 --> 00:18:07.000
SwiftUIは、アプリからデータをエクスポートすることもサポートしています。

00:18:07.000 --> 00:18:15.000
データをエクスポートすると、アプリ内から直接ショートカットをトリガーできるなど、他のサービスを利用できます。

00:18:15.000 --> 00:18:20.000
SwiftUIでは、新しいexportsItemProviders修飾子を使用してデータをエクスポートできます。

00:18:20.000 --> 00:18:28.000
これにより、アプリのデータをシステムの残りの部分に公開します。たとえば、macOSのサービスやショートカットで使用できるようになります。

00:18:28.000 --> 00:18:33.000
アプリを使用している人にとって、これがどのように表示されるかを見てみましょう。

00:18:33.000 --> 00:18:39.000
ピン留めされた文字の1つを選択すると、アプリのサービスメニューにクイックアクションが表示されるようになりました。

00:18:39.000 --> 00:18:48.000
これは、最新の写真にタイトルバナーを追加するための便利なショートカットで、最新のスーパーヒーローのアイデアを友達と共有するために使用できます。

00:18:48.000 --> 00:18:54.000
私はたまたま愛らしい犬でもある私のスタイライザーのスーパーヒーローに使用するこの素晴らしい写真を見つけました。

00:18:54.000 --> 00:19:00.000
私のカスタムショートカットは、この楽しいバナーを一番上に追加し、ヒーローの名前をオーバーレイしました。

00:19:00.000 --> 00:19:02.000
私のショートカットでは、写真を共有することもできます。

00:19:02.000 --> 00:19:07.000
彼はクールなグラフィックについて1つか2つ知っているので、テイラーのフィードバックをもらいたいです。

00:19:07.000 --> 00:19:15.000
テイラーを受信者として追加して、簡単なメッセージを入力して送信できます。

00:19:15.000 --> 00:19:17.000
テイラー、どう思う？

00:19:17.000 --> 00:19:19.000
テイラー・ケリー:ありがとう、マット。完璧に見えます。

00:19:19.000 --> 00:19:22.000
そして、それは間違いなくあなたの新しい連絡先の写真になるでしょう。

00:19:22.000 --> 00:19:26.000
この愛らしい画像は、次のセクション、Advanced Graphicsへの素晴らしいセグエです。

00:19:26.000 --> 00:19:33.000
シンボルの更新、素材、活気から、強力な新しいキャンバスビューまで、今年はエキサイティングな機能強化がたくさんあります。

00:19:33.000 --> 00:19:34.000
まずはシンボルです。

00:19:34.000 --> 00:19:39.000
SFシンボルは、アプリ全体に美しい図像を追加する素晴らしい簡単な方法です。

00:19:39.000 --> 00:19:46.000
今年は新しいものがたくさんあるだけでなく、アプリでの使用をさらに簡単で表現力豊かにするために、いくつかの新機能が付属しています。

00:19:46.000 --> 00:19:51.000
シンボルのスタイルをさらに制御できる2つの新しいレンダリングモードがあります。

00:19:51.000 --> 00:20:02.000
Hierarchicalは、モノクロのように、現在のフォアグラウンドスタイルを使用してシンボルに色を付けますが、シンボルの重要な要素を本当に強調するために、自動的に複数のレベルの不透明度を追加します。

00:20:02.000 --> 00:20:08.000
また、パレットを使用すると、カスタム塗りつぶしでシンボルの個々のレイヤーをさらに細かく制御できます。

00:20:08.000 --> 00:20:13.000
これらの新しいモードの詳細とデザインガイダンスについては、「SFシンボルの新機能」をご覧ください。

00:20:13.000 --> 00:20:17.000
これらと完璧に組み合わせることは、SwiftUIで利用可能な一連の色のアップデートです。

00:20:17.000 --> 00:20:26.000
これらの色は、ライトモードとダークモード、ぼかし上の特定の外観、さらには表示される特定のプラットフォームなど、表示されるすべての異なる構成に最適化されています。

00:20:26.000 --> 00:20:30.000
異なる色に加えて、シンボルにはさまざまな形があります。

00:20:30.000 --> 00:20:34.000
多くのシンボルには、塗りつぶし、丸で囲まれたなどとして表示する修飾子があります。

00:20:34.000 --> 00:20:36.000
以前は、これらのバリアントをハードコードする必要がありました。

00:20:36.000 --> 00:20:41.000
しかし、それ以上に、どのバリアントがどのコンテキストで使用するのが正しいかを知らなければなりませんでした。

00:20:41.000 --> 00:20:50.000
iOSヒューマンインターフェイスガイドラインでは、タブバーで塗りつぶされたバリアントが優先される方法を説明しているため、その.fill修飾子を名前に具体的に含める必要がありました。

00:20:50.000 --> 00:20:52.000
今年は、それを心配する必要はありません。

00:20:52.000 --> 00:20:56.000
SwiftUIは、使用するコンテキストに基づいて、適切なバリアントを自動的に選択します。

00:20:56.000 --> 00:21:00.000
あなたがしなければならないのは、使用したいベースシンボルを提供することだけです。

00:21:00.000 --> 00:21:06.000
また、必要な正確な設定を過度に指定しないことで、より再利用可能なコードも取得できます。

00:21:06.000 --> 00:21:13.000
たとえば、macOSでこの同じコードを実行すると、そのプラットフォームの正しいバリアントを取得します:アウトライン。

00:21:13.000 --> 00:21:21.000
独自のカスタムビューでこの自動サポートを利用する方法と、より多くのシンボルの強化を学ぶには、「SwiftUIのSFシンボル」をチェックしてください。

00:21:21.000 --> 00:21:26.000
今ではSFシンボルがたくさんあるので、それらすべてをブラウズするためのクールなビジュアライザーを作りたいと思いました。

00:21:26.000 --> 00:21:30.000
これは、SwiftUIの新しいキャンバスビューに最適です。

00:21:30.000 --> 00:21:34.000
Canvasは、UIKitやAppKitのdrawRectに似た即時モードの描画をサポートしています。

00:21:34.000 --> 00:21:41.000
個々の追跡や無効化を必要としない多くのグラフィカルな要素を作成する場合、これは素晴らしいツールです。

00:21:41.000 --> 00:21:45.000
ここには、OSに付属するすべてのSFシンボルを表示するキャンバスがあります。

00:21:45.000 --> 00:21:50.000
そして、それらのすべての3166のために、それはそれらのそれぞれを自分のフレームに引き寄せます。

00:21:50.000 --> 00:21:52.000
キャンバスはすべてのプラットフォームで動作します。

00:21:52.000 --> 00:22:03.000
また、キャンバスは他のビューと同様に、ジェスチャー、アクセシビリティ情報を添付し、ダークモードへの適応など、状態や環境に基づいて更新することもできます。

00:22:03.000 --> 00:22:07.000
ここでは、ズームインするフォーカルポイントを設定できるジェスチャーを追加しました。

00:22:07.000 --> 00:22:11.000
そして、それに基づいて各シンボルのフレームと不透明度を更新します。

00:22:11.000 --> 00:22:18.000
これで、クリックしてドラッグすることができ、カーソルが画面を移動するにつれて、すべてのシンボルがスムーズに更新されます。

00:22:18.000 --> 00:22:23.000
また、新しいアクセシビリティ子供修飾子を利用することで、これが完全にアクセス可能であることを確認することもできます。

00:22:23.000 --> 00:22:31.000
とてもクールなのは、SwiftUIで使用していたのと同じビューを再利用して、アクセシビリティ機能を通じてどのように伝わるかを洗練することです。

00:22:31.000 --> 00:22:39.000
この場合、誰かがリスト内の要素を参照し、ナビゲート中に各要素を話すように、シンボルを列挙できるようになりました。

00:22:39.000 --> 00:22:46.000
この修飾子はキャンバスだけに限定されるものではなく、アクセシビリティ体験を本当に磨くためにあらゆる目的で使用できます。

00:22:46.000 --> 00:22:52.000
キャンバスに追加できる最後の1つは、新しいTimelineViewを使用して、時間の経過とともに更新することです。

00:22:52.000 --> 00:22:58.000
tvOSのための改良は、フォーカルポイントが画面上をアニメーションで動き回り、スクリーンセーバーのように振る舞うことです。

00:22:58.000 --> 00:23:05.000
TimelineViewはスケジュール（この場合はアニメーションスケジュール）で作成され、レンダリングされている現在の時間を提供します。

00:23:05.000 --> 00:23:11.000
そして、その時間を使って変換のフォーカルポイントを更新し、美しいシンボルスクリーンセーバーを作成できます。

00:23:11.000 --> 00:23:14.000
このタイムラインビューはもっと多くのことができます。

00:23:14.000 --> 00:23:17.000
Apple Watchの本当にクールな機能は、常時表示です。

00:23:17.000 --> 00:23:22.000
以前は、アプリがAlways On状態に入ると、時間がオーバーレイされてぼやけていました。

00:23:22.000 --> 00:23:32.000
また、watchOS 8では、アプリはデフォルトで暗くなり、必要なツールを提供するSwiftUIでどのように表示されるかをより詳細に制御できます。そのうちの1つはTimelineViewです。

00:23:32.000 --> 00:23:39.000
時計がAlways On状態になると、TimelineViewは将来の日付でビューの表示をプリロードできます。

00:23:39.000 --> 00:23:46.000
そして、私たちが将来に進むにつれて、これらのビューは、バックグラウンドからアプリを取ることなく、自動的に画面に表示されます。

00:23:46.000 --> 00:23:49.000
これの重要な部分はTimelineScheduleです。

00:23:49.000 --> 00:23:59.000
この例では、簡単なeveryMinuteスケジュールを使用しているので、TimelineViewは分ごとに表示をプリロードし、ブラウザに次のシンボルを表示します。

00:23:59.000 --> 00:24:09.000
明示的な日付のコレクションなど、アプリのニーズに合わせて、他のいくつかの種類のスケジュールもあります。これは、特定の時間にイベントがあるときに最適です。

00:24:09.000 --> 00:24:15.000
さて、このモードのもう1つの重要な側面は、他の人に見られる可能性があるため、ユーザーに敏感な情報を隠すことです。

00:24:15.000 --> 00:24:17.000
私は本当にお気に入りのシンボルを非公開にしたいです。

00:24:17.000 --> 00:24:24.000
また、privacySensitive修飾子を追加するだけで、時計がAlways On状態になると自動的に編集されます。

00:24:24.000 --> 00:24:29.000
常時表示ディスプレイなどの詳細については、「watchOS 8の新機能」をご覧ください。

00:24:29.000 --> 00:24:33.000
そして、このプライバシーに敏感な修飾子は、ウィジェットでも機能します。

00:24:33.000 --> 00:24:42.000
ロック画面に追加されたウィジェットは、これを使用して、デバイスがまだロックされている間に機密情報を非表示にし、デバイスのロックが解除されると明らかにします。

00:24:42.000 --> 00:24:48.000
「素晴らしいウィジェットの原理」では、この方法と、アプリ用の素晴らしいウィジェットを構築する他の方法について詳しく説明します。

00:24:48.000 --> 00:24:58.000
素材は、コンテンツを強調する美しい視覚効果を作成するために、Appleのすべてのプラットフォームとアプリで使用され、SwiftUIで直接作成できるようになりました!

00:24:58.000 --> 00:25:06.000
シンボルブラウザに色と素材を追加する実験をしていて、シンボルの数を表示するために素材に裏打ちされたオーバーレイを追加しています。

00:25:06.000 --> 00:25:09.000
素材の追加は、背景を追加するのと同じくらい簡単です。

00:25:09.000 --> 00:25:14.000
私はultraThinMaterialを使用しており、それを埋めるために任意のカスタム形状を与えることができます。

00:25:14.000 --> 00:25:23.000
これらの素材には、プライマリ、セカンダリ、三次、さらには第四級フォアグラウンドスタイルを使用すると、その上にコンテンツの期待される鮮やかなブレンドが自動的に付属しています。

00:25:23.000 --> 00:25:29.000
そして、絵文字は自動的にそこから除外されるので、本来あるべき姿に見えます。

00:25:29.000 --> 00:25:39.000
Macでは、サイドバーやポップオーバーなどのシステムコンテキストは自動的に素材の背景をぼかし、その中のコンテンツに期待される鮮やかな外観を持つようになりました。

00:25:39.000 --> 00:25:50.000
これらの新しい素材は、スクロール可能なビューの上にコンテンツを配置し、コンテンツ位置を期待どおりに開始および終了させることができる新しいsafeAreaInset修飾子と組み合わせてうまく機能します。

00:25:50.000 --> 00:25:55.000
「リッチグラフィック」セッションでは、キャンバス、素材などについてさらに詳しく説明します。

00:25:55.000 --> 00:26:03.000
そして、それを締めくくるために、これらの美しいカスタムビューを定義する新しい方法を補完することは、XcodeのSwiftUIプレビューのいくつかの機能強化です。

00:26:03.000 --> 00:26:14.000
まず、プレビューでiOSデバイスの向きを指定したり、異なる向きでプレビューを混ぜ合わせたりできる新しいプレビュー方向修飾子です。

00:26:14.000 --> 00:26:19.000
そして2つ目は、プレビューでアプリのアクセシビリティを編集して表示する方法の大幅な改善です。

00:26:19.000 --> 00:26:27.000
プロパティエディタには、アクセシビリティ修飾子のキュレーションされたリストがあり、ビューのアクセシビリティ動作を磨くことがさらに簡単になりました。

00:26:27.000 --> 00:26:32.000
また、新しいアクセシビリティプレビュータブでプレビューを表示するまったく新しい方法があります。

00:26:32.000 --> 00:26:38.000
アクセシビリティ要素とそのプロパティのライブテキスト表現が表示されます。

00:26:38.000 --> 00:26:45.000
これは、アクセシビリティ機能を強化するのと同じ情報ですが、より身近な形式で提示されています。

00:26:45.000 --> 00:26:53.000
これの詳細と、アプリに素晴らしいアクセシビリティ体験を作成する方法については、「SwiftUIアクセシビリティ」セッションをチェックしてください!

00:26:53.000 --> 00:27:00.000
次に、テキスト、テキスト関連のコントロール、キーボードナビゲーションのさまざまな機能強化があります。

00:27:00.000 --> 00:27:02.000
テキストはすべてのアプリにとって非常に基本的なものです。

00:27:02.000 --> 00:27:07.000
これは、アプリが人々とコミュニケーションをとる主な方法の1つです。多くの場合、最初に書くビューです。

00:27:07.000 --> 00:27:15.000
そして今年は、スタイリングからローカリゼーション、インタラクション、フォーマットまで、多くの新しいエキサイティングな機能を獲得しています。

00:27:15.000 --> 00:27:18.000
まず、Markdownのサポートです。

00:27:18.000 --> 00:27:21.000
テキストには、直接インラインでMarkdownフォーマットを含めることができるようになりました。

00:27:21.000 --> 00:27:31.000
これは、強い強調、対話できるリンク、さらにはコードスタイルのプレゼンテーションを追加するために使用できます。

00:27:31.000 --> 00:27:36.000
そして、これはすべてFoundationの新しい強力なSwiftベースのAttributedStringの上に構築されています。

00:27:36.000 --> 00:27:47.000
Markdownのサポートに加えて、リッチでタイプセーフな属性のスイート全体と、独自の属性を定義し、Markdown構文内でそれらを使用する機能をもたらします。

00:27:47.000 --> 00:27:53.000
これと驚くべき新しい自動文法契約の詳細については、「Foundationの新機能」をご覧ください。

00:27:53.000 --> 00:27:58.000
重要なのは、テキストはまた、世界中の人々があなたのアプリを使用できるように、そのコンテンツをローカライズすることです。

00:27:58.000 --> 00:28:05.000
そして、これは新しいMarkdownサポートにも当てはまり、言語に敏感な属性を適切にローカライズすることができます。

00:28:05.000 --> 00:28:09.000
ローカリゼーションのもう1つの大きな改善は、Xcode 13から来ています。

00:28:09.000 --> 00:28:20.000
現在、Swiftコンパイラを使用して、LocalizedStringKeyと新しいlocalizedStringと attributedString初期化子のすべての使用から文字列とローカリゼーションカタログを生成します。

00:28:20.000 --> 00:28:26.000
これやその他のローカリゼーションのヒントやコツの詳細については、「SwiftUIアプリをローカライズする」をチェックしてください。

00:28:26.000 --> 00:28:32.000
さて、テキストを表示するこれらの新しい方法に加えて、テキストをさらにダイナミックにする新しい方法があります。

00:28:32.000 --> 00:28:35.000
1つ目は、重要なアクセシビリティ機能であるダイナミックタイプです。

00:28:35.000 --> 00:28:47.000
SwiftUIは創業以来ダイナミックタイプをサポートしており、今年はUIがサポートするタイプサイズの範囲を制限して、大きすぎたり小さすぎたりするのを防ぐための新しいAPIがあります。

00:28:47.000 --> 00:28:50.000
これは、ヘッダーがデフォルトの大きなサイズでどのように見えるかを示しています。

00:28:50.000 --> 00:29:02.000
私は個人的にダイナミックタイプを使用して、コンテンツに余分な情報密度を取得します。これは、少なくとも大きなサイズに制限されているため、ヘッダーが小さなタイプサイズで同じサイズにとどまった方法を示しています。

00:29:02.000 --> 00:29:11.000
スペクトルの反対側では、アクセシビリティサイズを使用すると、ヘッダーが大きくなりますが、余分な特大サイズまでしか成長しません。

00:29:11.000 --> 00:29:18.000
macOSはダイナミックタイプをサポートしていませんが、別の重要なテキストインタラクションをサポートしています。選択可能なテキストです。

00:29:18.000 --> 00:29:25.000
これにより、人々はあなたのアプリから編集不可能なテキストに対してアクションを実行することができ、textSelection修飾子を使用して有効にできるようになりました。

00:29:25.000 --> 00:29:33.000
その修飾子はどのビューにも適用でき、その中のすべてのテキストに適用されます。この例では、ヘッダー内のテキストに適用されます。

00:29:33.000 --> 00:29:40.000
また、この修飾子をiOSとiPadOSに導入し、長押しでテキストをコピーまたは共有することができます。

00:29:40.000 --> 00:29:48.000
最後に、Foundationの新しいフォーマットスタイルのAPIは、テキストの書式設定をはるかに簡単にしますが、正確なプレゼンテーションを可能にします。

00:29:48.000 --> 00:29:51.000
ここには、デフォルトの書式を適用する日付があります。

00:29:51.000 --> 00:29:56.000
そして、これはアクティビティリストで使用されている時間のみを表示するバリアントです。

00:29:56.000 --> 00:30:01.000
そして最後に、表示する正確なコンポーネントを指定できる拡張形式。

00:30:01.000 --> 00:30:07.000
私たちの活動リストはまた、適切にローカライズされたプレゼンテーションに人々の配列をフォーマットすることを特徴としました。

00:30:07.000 --> 00:30:09.000
これをさっと見てみましょう。

00:30:09.000 --> 00:30:17.000
人の値をPersonNameComponentsの配列にマッピングし、リスト形式のスタイルを使用してフォーマットしています。

00:30:17.000 --> 00:30:24.000
そして、リストの各メンバーについて、短いスタイルでPersonNameComponent形式を使用し、ファーストネームのみを表示します。

00:30:24.000 --> 00:30:27.000
そして最後に、「と」接続詞で結合します。

00:30:27.000 --> 00:30:34.000
すべて一緒に、任意の人数を適切に処理するフォーマットのパフォーマンスとタイプセーフな表現を作成します。

00:30:34.000 --> 00:30:42.000
TextFieldはまた、これらの新しいフォーマットスタイルのサポートを得ており、基礎となる値にタイプセーフバインディングで編集可能なフォーマットされたテキストを追加することができます。

00:30:42.000 --> 00:30:50.000
新しい出席者フィールドはPersonNameComponents値にバインドされており、標準の名前形式を使用してフォーマットされています。

00:30:50.000 --> 00:30:55.000
これは、入力を解析し、結果の人名を生成します。

00:30:55.000 --> 00:31:00.000
「ファンデーションの新機能」では、これらの新しいフォーマットスタイルのパワーについても詳しく説明しています。

00:31:00.000 --> 00:31:09.000
TextFieldは、フィールドが期待しているコンテンツの種類をユーザーに知らせるために、ラベルとは別に明示的なプロンプトの追加もサポートするようになりました。

00:31:09.000 --> 00:31:17.000
また、macOSのフォームにTextFieldを追加すると、他のコントロールと同様にラベルを揃え、プロンプトをプレースホルダコンテンツとして使用します。

00:31:17.000 --> 00:31:23.000
さて、テキストフィールドの全体的なポイントはテキストを追加することであり、キーボードはそれを行うためのツールです。

00:31:23.000 --> 00:31:34.000
iPhoneのソフトウェアキーボードから、ソフトウェアキーボードとハードウェアキーボードの両方をサポートするiPad、そしてもちろん、常にハードウェアキーボードを備えたmacOSまで。

00:31:34.000 --> 00:31:38.000
今年は、キーボードの使用体験をさらに良くするためのいくつかの機能強化があります。

00:31:38.000 --> 00:31:47.000
新しいonSubmit修飾子を使用すると、Returnキーを押すなど、フィールドのテキストがユーザーによって送信されたときの補足アクションを簡単に追加できます。

00:31:47.000 --> 00:31:53.000
この修飾子は、コントロールのフォーム全体にも適用できるという点で、いくつかの余分な柔軟性を提供します。

00:31:53.000 --> 00:32:00.000
また、フィールドの送信時にどのようなアクションが発生するかをユーザーにヒントを与えるために、新しいsubmitLabel修飾子があります。

00:32:00.000 --> 00:32:04.000
ソフトウェアキーボードでは、これはReturnキーのラベルとして使用されます。

00:32:04.000 --> 00:32:10.000
そして最後に、新しいキーボードツールバーの配置を使用して、キーボードにアクセサリビューを追加できるようにしました。

00:32:10.000 --> 00:32:18.000
これらのビューは、iOSとiPadOSのソフトウェアキーボードの上のツールバー、またはmacOSのTouch Barに表示されます。

00:32:18.000 --> 00:32:25.000
これは、アプリの編集体験を中断しないように、ユーザーがキーボードの上のアクションにすばやくアクセスできるようにする素晴らしい方法です。

00:32:25.000 --> 00:32:40.000
キーボードはまた、ナビゲーションとフォーカスの別の重要な役割を果たしており、この機能はすべてのプラットフォームに存在します。watchOSに焦点を当ててデジタルクラウン入力を指示することから、Siri Remoteを使用してtvOS上のコンテンツをナビゲートすることまで。

00:32:40.000 --> 00:32:46.000
ほとんどの場合、SwiftUIは、どのビューがフォーカス可能で、それらの間でどのように移動するかを処理します。

00:32:46.000 --> 00:32:51.000
しかし、時にはあなたのアプリでさらにスムーズな経験を作成するためにあなたが作ることができる余分な改良があります。

00:32:51.000 --> 00:32:57.000
それを助けるために、SwiftUIにはFocusStateと呼ばれる新しい強力なツールがあります。

00:32:57.000 --> 00:33:02.000
これは、フォーカスの状態を反映し、それに対する正確な制御を提供するプロパティラッパーです。

00:33:02.000 --> 00:33:06.000
簡単に言えば、ブール値を反映できます。

00:33:06.000 --> 00:33:09.000
これは、フォーカスされた修飾子を使用してフォーカス可能なビューに結びつけることができます。

00:33:09.000 --> 00:33:13.000
そのビューがフォーカスされている場合、値はtrueになり、そうでない場合はfalseになります。

00:33:13.000 --> 00:33:16.000
この値は、フォーカスを制御するために書くこともできます。

00:33:16.000 --> 00:33:19.000
例えば、誰かがボタンを押したと反応して。

00:33:19.000 --> 00:33:26.000
この例はアクセラレータとして機能し、ユーザーは関連するアクションを実行した後すぐに入力を開始できます。

00:33:26.000 --> 00:33:31.000
このブールバージョンは、任意のハッシュ可能なタイプを表す完全な形式の利便性です。

00:33:31.000 --> 00:33:36.000
このコードは機能的に前のスライドと同等ですが、ある程度の柔軟性が向上しています。

00:33:36.000 --> 00:33:37.000
それを歩きましょう。

00:33:37.000 --> 00:33:42.000
まず、私が知りたいかもしれないフィールドの簡単な列挙を定義しました。

00:33:42.000 --> 00:33:46.000
FocusStateプロパティは、そのタイプを使用して現在の状態を反映します。

00:33:46.000 --> 00:33:49.000
潜在的に誰も集中していないことを示すのはオプションです。

00:33:49.000 --> 00:33:55.000
私たちのフォーカス修飾子はまだ同じフォーカス状態にバインドされていますが、addAttendeeに等しい場合に限ります。

00:33:55.000 --> 00:34:01.000
そして最後に、その分野に焦点を当てたいときは、フォーカス状態の値をaddAttendeeに設定します。

00:34:01.000 --> 00:34:11.000
この新しい柔軟性により、以前からツールバーボタンを構築したり、各フィールド間でフォーカスを移動したり、フォーカスが最初または最後に達したかどうかを反映したりするなど、追加機能を追加できます。

00:34:11.000 --> 00:34:18.000
フォーカス状態はまた、iOSアプリがその値をクリアすることによってソフトウェアキーボードを却下するための素晴らしい方法を提供します。

00:34:18.000 --> 00:34:26.000
アプリのフォーカスエクスペリエンスを洗練させる他の方法についてもっと知りたい場合は、今年のセッション「SwiftUIのダイレクトとフォーカスの反映」をチェックしてください。

00:34:26.000 --> 00:34:31.000
最後に、ボタンが重要なので、ボタンに焦点を当てます。

00:34:31.000 --> 00:34:39.000
私たちは皆、典型的なボタンがどのように見えるかを知っています。それはプラットフォームごとに異なり、人々があなたのアプリと対話できるようにする最も簡単な方法の1つです。

00:34:39.000 --> 00:34:43.000
そして、特にSwiftUIでは、ボタンは多くのことに使われています。

00:34:43.000 --> 00:34:46.000
マットは先ほど、スワイプアクションがボタンからどのように構成されているかについて話し合った。

00:34:46.000 --> 00:34:51.000
そして今年は、ボタン付きの新しいものがたくさんあります。

00:34:51.000 --> 00:34:55.000
まず、SwiftUIにはiOSに標準のボーダーボタンがあります。

00:34:55.000 --> 00:35:01.000
この追加ボタンで行っているように、ボタンスタイルの修飾子を追加するだけで、ボタンの境界線を作ることができます。

00:35:01.000 --> 00:35:06.000
他のスタイル修飾子と同様に、これはコントロールのグループに追加でき、それらすべてに適用されます。

00:35:06.000 --> 00:35:10.000
特定のボタンの特定の外観が必要な場合は、着色をサポートします。

00:35:10.000 --> 00:35:15.000
しかし、このUIでは、アクセントカラーを使用するデフォルトの外観が好きです。

00:35:15.000 --> 00:35:18.000
より多くのカスタマイズも組み込まれています。

00:35:18.000 --> 00:35:21.000
まず、コントロールサイズとプロミネンスです。

00:35:21.000 --> 00:35:25.000
これらを使用して、タグを表すボタンをカスタマイズしています。

00:35:25.000 --> 00:35:32.000
彼らは新しい標準的な小さなコントロールサイズを使用しており、本当に目立つように目立つ色合いを持っています。

00:35:32.000 --> 00:35:39.000
これらの同じ修飾子を使用して、別の一般的な種類のボタンを作成できます。これらの大きなサイズのものは、SwiftUIに組み込まれています。

00:35:39.000 --> 00:35:45.000
大きなコントロールサイズを指定すると、これらの美しく丸みを帯びた長方形のボタンが自動的に手に入る。

00:35:45.000 --> 00:35:53.000
そして、彼らにヒエラルキーの感覚を与えるために、私は最も重要なものを目立たせるように変更し、コントラストの高いアクセントカラーで満たしました。

00:35:53.000 --> 00:35:57.000
そして、セカンダリボタンはまだ着色できますが、コントラストは低くなります。

00:35:57.000 --> 00:36:02.000
これらのボタンには、iPadでも素晴らしいものにするための修飾子がほとんどない。

00:36:02.000 --> 00:36:08.000
テキストラベルは最大幅なので、全体的なボタンは柔軟ですが、コミカルに大きくなりません。

00:36:08.000 --> 00:36:18.000
また、プライマリボタンにはデフォルトのアクションキーボードショートカットがあるので、キーボードでアプリを使用する場合は、Returnキーをすばやく押して、このボタンをジャーに追加できます。

00:36:18.000 --> 00:36:24.000
現在、このAPIの多くはmacOSにすでに存在しており、複数のプラットフォーム用のアプリの構築がさらに簡単になりました。

00:36:24.000 --> 00:36:31.000
1つの新しい追加は、目立つ色合いのサポートを増やして、これらの明るいボタンをアプリに上品に追加できるようにすることです。

00:36:31.000 --> 00:36:40.000
これらの追加ボタンのような非目立つボタンは、クロムがmacOSでのインタラクティブ性を示すものであるため、色合いを表示しないことに注意してください。

00:36:40.000 --> 00:36:49.000
卓越性について学んだので、私はそれをすべての追加ボタンに適用したくなるかもしれませんが、画面上に非常に多くの目立つボタンがあると圧倒的で混乱する可能性があります。

00:36:49.000 --> 00:36:52.000
単一の主要な行動のためにそれを予約するのが最善です。

00:36:52.000 --> 00:36:57.000
低いプロミネンスの色合いは、iOSに色のスプラッシュを追加するための素晴らしい選択肢です。

00:36:57.000 --> 00:37:08.000
さて、これらの新しいボタンスタイルについての私のお気に入りは、自動的に予想されるプレス状態と無効状態、ダークモードのサポート、そしてもちろん完全にアクセス可能で、ダイナミックタイプと互換性があることです。

00:37:08.000 --> 00:37:11.000
そして、それらはアプリ間の一貫性を与えるのに役立ちます。

00:37:11.000 --> 00:37:13.000
そして、ボタンの新しいAPIはここで止まりません。

00:37:13.000 --> 00:37:23.000
SwiftUIはまた、ボタンを破壊的としてマークするなど、追加のセマンティクスを持つボタンのファーストクラスのサポートを追加し、自動的に期待される赤い色合いを与えます。

00:37:23.000 --> 00:37:30.000
これが使用できる新しいコンテキストの1つは、ユーザーがデータに深刻な影響を与えるアクションを確認できる確認ダイアログです。

00:37:30.000 --> 00:37:37.000
iOSでは、これはアクションシートとして、iPadではポップオーバーとして、macOSではアラートとして表示されます。

00:37:37.000 --> 00:37:42.000
SwiftUIは、各プラットフォームのデザイン感度に従って自動的に処理します。

00:37:42.000 --> 00:37:47.000
次に、「大文字のB」ボタンではないボタンについて話しましょう。

00:37:47.000 --> 00:37:50.000
現在、アプリの追加ボタンは、ユーザーのデフォルトのjarに追加するだけです。

00:37:50.000 --> 00:37:54.000
しかし、熱心なコレクターのために、私は特定の瓶への追加をサポートしたいです。

00:37:54.000 --> 00:37:57.000
これはメニューボタンの完璧なユースケースです。

00:37:57.000 --> 00:38:03.000
同じ「追加」ラベルを使用しますが、ボタンをクリックすると、すべての可能な瓶のメニューが表示されます。

00:38:03.000 --> 00:38:07.000
しかし、これらのメニューボタンは視覚的に多くの卓越性を持っています。

00:38:07.000 --> 00:38:12.000
今年追加された新しいメニュー指標修飾子を使用して、指標を非表示にすることができます。

00:38:12.000 --> 00:38:16.000
そして、インジケーターがなくても、このボタンはクリック時にメニューを表示します。

00:38:16.000 --> 00:38:25.000
しかし、これらのボタンについては、理想的には両方の長所を得ることができます。簡単なワンクリックでデフォルトのjarに追加し、他の人のメニューを表示する柔軟性です。

00:38:25.000 --> 00:38:30.000
今年の新機能は、この種のケースを支援するためにメニューの主要なアクションをカスタマイズする機能です。

00:38:30.000 --> 00:38:35.000
デフォルトでは、プライマリアクションを持つメニューは、macOSで2つのセグメントの外観を持っています。

00:38:35.000 --> 00:38:40.000
ボタンのメイン部分は、メニューを表示するインジケーターのプライマリアクションをトリガーします。

00:38:40.000 --> 00:38:47.000
そして、インジケーターが隠されているとき、それは再び視覚的に私が始めたボタンのように見えますが、行動の区別があります。

00:38:47.000 --> 00:38:51.000
クリックするとプライマリアクションがトリガーされ、長押しするとメニューが表示されます。

00:38:51.000 --> 00:38:54.000
そして素晴らしいのは、この同じことがiOSでも機能することです!

00:38:54.000 --> 00:38:59.000
今、これらのメニューは多くの柔軟性を与え、あなたのアプリがそれらをどのように使用する必要があるかを本当にケータリングします。

00:38:59.000 --> 00:39:03.000
ボタンスタイルを獲得するコントロールのもう1つの新しい例は、トグルです。

00:39:03.000 --> 00:39:09.000
これにより、タップすると視覚的にオン/オフし、他のトグルと同じように使用できるボタンが作成されます。

00:39:09.000 --> 00:39:16.000
そして、これらの新しいコントロールスタイルに参加することは、関連するコントロールをグループ化するコンテナです。適切にControlGroupと呼ばれます。

00:39:16.000 --> 00:39:20.000
iOSでは、グループ内のコントロールはツールバーで少しきつく整理されています。

00:39:20.000 --> 00:39:26.000
また、macOSでは、2つのグループ化されたボタンを示す視覚的なアフォーダンスがあります。

00:39:26.000 --> 00:39:30.000
そして、このすべてをまとめるために、当然のことながら、これらすべてを一緒に構成することができます。

00:39:30.000 --> 00:39:35.000
たとえば、これらの標準のバック/フォワードボタンは、2つのメニューのコントロールグループです。

00:39:35.000 --> 00:39:39.000
これらの各メニューには、クリックしたときに実行されるプライマリアクションがあります。

00:39:39.000 --> 00:39:44.000
そして、メニューが長押しされると、彼らは内容を提示します。

00:39:44.000 --> 00:39:53.000
今、ボタンとこれらの新しいスタイルにいくつかの追加のカスタマイズだけで、アプリでこれらのコントロールを使用する方法について多くの柔軟性が開かれました。

00:39:53.000 --> 00:39:57.000
私たちはこのセッションで多くのことを経験しましたが、カバーする時間がなかったことがさらにあります。

00:39:57.000 --> 00:40:04.000
あなた自身のSwiftUIアプリでこれらの新機能を活用し、さらに多くの場所でSwiftUIを採用できることを嬉しく思います。

00:40:04.000 --> 00:40:07.000
ありがとう、そして2021年の素晴らしい残りをお過ごしください!

00:40:07.000 --> 23:59:59.000
♪

