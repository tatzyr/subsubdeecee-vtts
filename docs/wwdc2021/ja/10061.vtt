WEBVTT

00:00:02.000 --> 00:00:10.000
ドナ：こんにちは。

00:00:10.000 --> 00:00:13.000
私はDonna Tomで、TextKitのエンジニアです。

00:00:13.000 --> 00:00:17.000
同僚のクリス・ウィルモアが後でこのビデオに参加します。

00:00:17.000 --> 00:00:24.000
Appleの次世代テキストエンジンであるTextKit 2を導入します。

00:00:24.000 --> 00:00:33.000
TextKit 2が何であるかを理解するために、TextKit 1と呼ぶオリジナルのTextKitを簡単に復習しましょう。

00:00:33.000 --> 00:00:39.000
TextKit 1は、Appleのすべてのプラットフォームでテキストレイアウトと表示を駆動するテキストエンジンです。

00:00:39.000 --> 00:00:49.000
UIKitとAppKitのテキストコントロールは、TextKit 1を使用してストレージを管理し、テキストコンテンツのレイアウトを制御します。

00:00:49.000 --> 00:00:55.000
TextKit 1は、20年以上前にOpenStepのシステムに初めて登場しました。

00:00:55.000 --> 00:01:05.000
macOS 10.0からiOS 7、macOS 11、iOS 14まで、長年にわたって成長し、進化してきました。

00:01:05.000 --> 00:01:12.000
TextKit 1が依然としてすべてのAppleデバイスで非常に多くの必須機能に電力を供給していることは非常に驚くべきことです。

00:01:12.000 --> 00:01:17.000
技術設計とエンジニアリングの原則は、何十年にもわたって大きく変化してきました。

00:01:17.000 --> 00:01:31.000
TextKit 1は元の原則に結びついているため、高水準のパフォーマンスを提供しながら、新しい技術とうまく統合するAPIを提供することは、長年にわたってより困難になっています。

00:01:31.000 --> 00:01:34.000
それが私たちがTextKit 2を構築した理由です。

00:01:34.000 --> 00:01:40.000
TextKit 2は、一連の前向きなデザイン原則に基づいて構築されたAppleの次世代テキストエンジンです。

00:01:40.000 --> 00:01:42.000
そして、何だと思う?

00:01:42.000 --> 00:01:45.000
あなたはすでにMacでTextKit 2を使っています。

00:01:45.000 --> 00:01:52.000
Big Surでは、舞台裏でTextKit 2を使用するように、OS全体のテキストコンポーネントの多くを更新しました。

00:01:52.000 --> 00:01:57.000
大きな驚き：あなたはmacOS 11からTextKit 2を使っています。

00:01:57.000 --> 00:02:01.000
では、これを行うことができるアーキテクチャを簡単に確認しましょう。

00:02:01.000 --> 00:02:05.000
TextKit 2はTextKit 1と共存しています。

00:02:05.000 --> 00:02:13.000
前身と同様に、TextKit 2はFoundation、Quartz、Core Textの上に構築されています。

00:02:13.000 --> 00:02:18.000
UIKitとAppKitのテキストコントロールは、TextKit 2の上に構築されています。

00:02:18.000 --> 00:02:23.000
TextKit 2はまた、前任者のMVCデザインをゆるやかに保持しています。

00:02:23.000 --> 00:02:35.000
ビュー部分はUIKitとAppKitフレームワークのビューオブジェクトに残りますが、古い友人であるNSTextStorageとNSLayoutManagerの新しいバージョンがあります。

00:02:35.000 --> 00:02:42.000
これらの新しいバージョンに加えて、モデルレイヤーとコントローラーレイヤーに参加する新しいクラスとプロトコルがたくさんあります。

00:02:42.000 --> 00:02:45.000
かなりの数がありますが、心配しないでください。 心配しないでください。

00:02:45.000 --> 00:02:52.000
これらの新しいコンポーネントは、シンプルで集中的で、パワフルな組み合わせです。

00:02:52.000 --> 00:03:02.000
彼らは、あなたがテキストでやりたいことを表現しやすくなり、システムがあなたが望むことをどのように達成するかを心配しなくなります。

00:03:02.000 --> 00:03:07.000
システムのアーキテクチャビューがわかったので、詳細を掘り下げてみましょう。

00:03:07.000 --> 00:03:21.000
まず、TextKit 2のコア設計原則と、これらの原則がアプリ内のテキストのストレージ、レイアウト、表示のカスタマイズに関する考え方をどのように変えるかについて説明します。

00:03:21.000 --> 00:03:28.000
その後、クリスは私たちがレシピの本で共同作業するために作成したTextKit 2サンプルアプリを案内します。

00:03:28.000 --> 00:03:34.000
このアプリは、新しいTextKit 2クラスを使用して、CALayersでテキストをレイアウトして表示します。

00:03:34.000 --> 00:03:39.000
ここでは、設計原則が実際にどのように機能するかを学びます。

00:03:39.000 --> 00:03:45.000
最後に、TextKit 2用のアプリをモダナイズするための重要な技術的詳細を取り上げます。

00:03:45.000 --> 00:03:49.000
では、デザインの原則から始めましょう。

00:03:49.000 --> 00:03:57.000
TextKit 2のコアハイレベル設計原則は、正確性、安全性、およびパフォーマンスです。

00:03:57.000 --> 00:04:00.000
私たちはバランスの取れたアプローチを取りました。

00:04:00.000 --> 00:04:07.000
3つの原則はすべて重要なので、それらを議論する順序に優先順位はありません。

00:04:07.000 --> 00:04:14.000
これらの高レベルの設計原則のそれぞれは、システムの特定の設計変更を通知します。

00:04:14.000 --> 00:04:19.000
正確性のために、TextKit 2はグリフ処理を抽象化します。

00:04:19.000 --> 00:04:26.000
安全のために、TextKit 2は価値セマンティクスに重点を置いています。

00:04:26.000 --> 00:04:33.000
また、パフォーマンスのために、TextKit 2はビューポートベースのレイアウトとレンダリングを使用します。

00:04:33.000 --> 00:04:35.000
正確性から始めます。

00:04:35.000 --> 00:04:43.000
この分野では、国際的なテキストに一貫した体験を提供するために、グリフ処理を抽象化しました。

00:04:43.000 --> 00:04:57.000
Appleデバイスは世界中のどこでも使用されているため、すべての言語とスクリプトでテキストに正しいレイアウト、レンダリング、インタラクションを提供することが非常に重要です。

00:04:57.000 --> 00:05:01.000
私たちは、誰もが自分のデバイスでテキストを読んだり操作したりできるようにしたいと考えています。

00:05:01.000 --> 00:05:10.000
また、TextKit 1 APIの一部の設計により、普遍的に正しい方法で国際テキストを操作することが困難になります。

00:05:10.000 --> 00:05:15.000
理由を理解するには、まずグリフが何であるかを理解する必要があります。

00:05:15.000 --> 00:05:21.000
グリフは、可変数の文字の視覚的表現です。

00:05:21.000 --> 00:05:30.000
多くの西洋言語では、1つのグリフは通常1つの文字を表しますが、これは必ずしも真実ではありません。

00:05:30.000 --> 00:05:35.000
1つの文字を表す複数のグリフを持つこともできますし、その逆になることもあります。

00:05:35.000 --> 00:05:40.000
1つのグリフは複数の文字を表すことができます。

00:05:40.000 --> 00:05:46.000
複数の文字を表すために使用されるこの単一のグリフは、合字と呼ばれます。

00:05:46.000 --> 00:05:52.000
西洋言語には合字がそれほど多くなく、通常はテキストの読みやすさには影響しません。

00:05:52.000 --> 00:05:56.000
あなたはまだ合字なしでそれをうまく読むことができます。

00:05:56.000 --> 00:05:59.000
しかし、それはすべての言語に当てはまるわけではありません。

00:05:59.000 --> 00:06:06.000
アラビア語やデーヴァナーガリーのようなスクリプトは、多くの合字を使用しており、読みやすさに影響します。

00:06:06.000 --> 00:06:09.000
この単語をアラビア文字でチェックしてください。

00:06:09.000 --> 00:06:12.000
それは「瞬間」を意味するウルドゥー語の単語です。

00:06:12.000 --> 00:06:17.000
少し時間を取って、これら2つのレンダリングを比較してください。

00:06:17.000 --> 00:06:23.000
右側の合字で描かれた完全な単語は、左側の個々の文字とは大きく異なるように見えます。

00:06:23.000 --> 00:06:32.000
言語のネイティブ読者は、左側のバージョンが判読不能であると考えるだろう。

00:06:32.000 --> 00:06:38.000
TextKit 1のAPIの多くは、グリフインデックスまたは範囲で作業する必要があります。

00:06:38.000 --> 00:06:47.000
たとえば、テキストの境界矩形を取得するには、必要なテキストのグリフ範囲を知る必要があります。

00:06:47.000 --> 00:06:53.000
テキストが西洋言語の場合、正しいグリフ範囲を理解することはそれほど悪くありません。

00:06:53.000 --> 00:07:01.000
この英語の例では、テキストの最初の4文字のグリフ範囲を見つけるのはかなり簡単です。

00:07:01.000 --> 00:07:07.000
今、インドの何百万人もの人々が話すスクリプトと言語であるカンナダ語を考えてみましょう。

00:07:07.000 --> 00:07:15.000
多くの合字を使用するだけでなく、グリフは並べ替えて、あらゆる種類の興味深い方法で組み合わせることができます。

00:07:15.000 --> 00:07:25.000
「10月」を意味するこのカンナダ語は、文字インデックス4で分割された母音を特徴としているため、2つのグリフに分割されます。

00:07:25.000 --> 00:07:34.000
次に、左側のものは、2の合字が適用される前に、文字1と2を表すグリフの間で並べ替えられます。

00:07:34.000 --> 00:07:42.000
インデックス3の文字を表すグリフも結合形式に置き換えられます。

00:07:42.000 --> 00:07:46.000
最後の言葉では、それは分割母音のグリフの1つの下に描かれます。

00:07:46.000 --> 00:07:52.000
さて、私が今言ったことを理解していなかったら、それは完全に大丈夫です。

00:07:52.000 --> 00:07:59.000
これらは、アプリの構築に集中できるように、フレームワークが処理すべき詳細です。

00:07:59.000 --> 00:08:06.000
ポイントは、このようなテキストの最初の4文字のグリフ範囲を見つけることができないということです。

00:08:06.000 --> 00:08:12.000
これらの4文字を表す単一のグリフ範囲はありません。

00:08:12.000 --> 00:08:23.000
また、多くのTextKit 1 APIはグリフ範囲を必要とするため、これらのAPIを使用すると、このような複雑なスクリプトのレイアウトとレンダリングを壊す可能性があります。

00:08:23.000 --> 00:08:27.000
そして、それがTextKit 2がグリフ処理を抽象化する理由です。

00:08:27.000 --> 00:08:35.000
TextKit 2は、すべてのテキストをコアテキストでレンダリングするので、複雑なスクリプトに対して自動的に正しいレンダリングを取得します。

00:08:35.000 --> 00:08:39.000
TextKit 2でグリフをまったく管理する必要はありません。

00:08:39.000 --> 00:08:45.000
代わりに、より高いレベルのオブジェクトを使用して、テキストレイアウトとインタラクションを制御します。

00:08:45.000 --> 00:08:50.000
これらの上位レベルのオブジェクトの1つであるNSTextSelectionをご紹介します。

00:08:50.000 --> 00:09:03.000
粒度、親和性、選択を構成するテキストのおそらくバラバラな範囲など、テキスト選択を表すために必要なすべてのコンテキストが含まれています。

00:09:03.000 --> 00:09:11.000
NSTextSelectionのこれらのプロパティは読み取り専用なので、選択オブジェクトのインスタンスを変更して変更することはありません。

00:09:11.000 --> 00:09:27.000
代わりに、NSTextSelectionNavigationのインスタンスを使用して、テキスト選択に対してアクションを実行し、結果の選択を表すNSTextSelectionの新しいインスタンスを受け取ります。

00:09:27.000 --> 00:09:39.000
ナビゲーションオブジェクトに、画面上のポイントでタップまたはマウスダウンイベントから選択したり、前方または後方に移動して新しい選択を取得するように依頼できます。

00:09:39.000 --> 00:09:49.000
これにより、選択範囲を1つの単語で前方に拡張し、正しい結果を得るなど、右から左の言語の双方向テキストを考慮しやすくなります。

00:09:49.000 --> 00:09:54.000
今、私はこれらの新しい選択APIについて何か興味深いことにあなたの注意を喚起したいと思います。

00:09:54.000 --> 00:09:57.000
このメソッドはNSTextLocationを取ります。

00:09:57.000 --> 00:10:02.000
これはTextKit 2のもう1つの新しいオブジェクトです。

00:10:02.000 --> 00:10:06.000
NSTextLocationとNSTextRangeをご紹介します。

00:10:06.000 --> 00:10:15.000
これらは、UIKitのUITextPositionおよびUITextRangeクラスと非常によく似ていますが、サブクラスにする必要はありません。

00:10:15.000 --> 00:10:22.000
ほとんどの場合、TextKit 2でデフォルトの場所と範囲のオブジェクトを使用します。

00:10:22.000 --> 00:10:31.000
整数の代わりにオブジェクトを使用すると、範囲は互いに相対的な位置の観点から定義されているため、より表現力豊かなドキュメントモデルが可能になります。

00:10:31.000 --> 00:10:36.000
HTMLドキュメントオブジェクトモデルは、その良い例です。

00:10:36.000 --> 00:10:45.000
ネストされた要素があるため、場所はドキュメント内の絶対位置と可視テキスト内の位置の両方を表す必要があります。

00:10:45.000 --> 00:10:49.000
これは単一の数値インデックスでは表現できません。

00:10:49.000 --> 00:10:52.000
そして、それは正しさのためです。

00:10:52.000 --> 00:10:54.000
次は安全です。

00:10:54.000 --> 00:11:07.000
この分野では、SwiftやSwiftUIなどのテクノロジーの目標によりよく一致するように、バリューセマンティクスに重点を置いたTextKit 2を設計しました。

00:11:07.000 --> 00:11:12.000
そして、私が「価値セマンティクス」と言うとき、私は価値タイプについて話しているのではありません。

00:11:12.000 --> 00:11:18.000
NSLayoutManagerを構造体にはしませんでした。

00:11:18.000 --> 00:11:23.000
値タイプはデータの一意のコピーを保持し、そのデータの突然変異を防ぎます。

00:11:23.000 --> 00:11:30.000
これにより、意図しない共有や関連する副作用を取り除くことで、コードがより安全で安定したものになります。

00:11:30.000 --> 00:11:35.000
しかし、価値タイプは、この利益を得る唯一の方法ではありません。

00:11:35.000 --> 00:11:43.000
不変クラスには、初期化後に変更できないプロパティがあり、データの突然変異も防ぎます。

00:11:43.000 --> 00:11:50.000
これらのクラスは値型のように振る舞うので、値セマンティクスを持つと呼びます。

00:11:50.000 --> 00:11:57.000
これらのオブジェクトの1つのデータを変更したい場合は、元のインスタンスを置き換えるために真新しいインスタンスを作成する必要があります。

00:11:57.000 --> 00:12:03.000
そして、TextKit 2の多くのクラスはこのように設計されています。

00:12:03.000 --> 00:12:09.000
このデザイン変更の利点を説明するために、TextKit 1のデザインに関する記憶をリフレッシュしましょう。

00:12:09.000 --> 00:12:15.000
ストレージから画面へのテキストの流れは、このように機能していました。

00:12:15.000 --> 00:12:27.000
テキストストレージの更新は、レイアウトマネージャーに通知し、グリフを生成し、配置し、ビューに直接描画します。

00:12:27.000 --> 00:12:37.000
ビューに直接グリフを描画するこのアプローチでは、カスタム描画用のスペースを作成するためにテキストを分離する場所を理解することは困難です。

00:12:37.000 --> 00:12:45.000
私が何を意味するのかを理解するために、レシピにいくつかのコメントを残したサンプルアプリからこのスニークピークスクリーンショットをチェックしてください。

00:12:45.000 --> 00:12:56.000
コメントが参照しているレシピのすぐ下にどのように表示され、この明確な泡の形をしたインディゴの背景と白いテキストで描かれていることに注目してください。

00:12:56.000 --> 00:13:04.000
正しい場所にコメントを挿入し、テキストの残りの部分と異なって見えるようにするには、どのようなアプローチを取るべきですか?

00:13:04.000 --> 00:13:21.000
レシピテキストを意味のある単位または要素に分割し、各コメントを独自の要素に入れ、関連するレシピの後に各コメントを配置しながら、コメントの描画方法の指示を提供することで、これを行うことを期待するかもしれません。

00:13:21.000 --> 00:13:25.000
TextKit 1では、現実はかなり異なります。

00:13:25.000 --> 00:13:37.000
グリフインデックスの検索、グリフが書記素クラスタの真ん中にないことを確認する、そのグリフインデックスの調整、行間隔の変更、ラインフラグメントジオメトリのカスタマイズなど、多くの詳細を心配する必要があります。

00:13:37.000 --> 00:13:40.000
そして、これらの詳細は、あなたがやろうとしていることとは関係ありません。

00:13:40.000 --> 00:13:46.000
したがって、TextKit 2では、期待を現実にすることを目指しています。

00:13:46.000 --> 00:13:52.000
このようなアプローチを可能にするために、システムを通るテキストの流れを変更しました。

00:13:52.000 --> 00:13:56.000
TextKit 2でそのフローの仕組みは次のとおりです。

00:13:56.000 --> 00:14:03.000
テキストストレージの更新は、コンテンツマネージャーと呼ばれる新しいオブジェクトを通過します。

00:14:03.000 --> 00:14:09.000
コンテンツマネージャーは、テキストを要素に分割し、それらを追跡します。

00:14:09.000 --> 00:14:16.000
レイアウトの時間になると、テキストレイアウトマネージャーはコンテンツマネージャーに要素を尋ねます。

00:14:16.000 --> 00:14:27.000
次に、テキストレイアウトマネージャは要素をテキストコンテナにレイアウトし、レイアウトと位置情報を含むレイアウトフラグメントを生成します。

00:14:27.000 --> 00:14:40.000
表示の時間になると、レイアウトフラグメントはViewportLayoutControllerに引き渡され、ビューであろうとレイヤーであろうと、選択したレンダリングサーフェス内のそれらのフラグメントの位置とレイアウトを調整します。

00:14:40.000 --> 00:14:44.000
わかるように、このプロセスには多くの新しいオブジェクトが関与しています。

00:14:44.000 --> 00:14:50.000
そして、ここで価値セマンティクスに重点が置かれます。

00:14:50.000 --> 00:15:02.000
適切なポイントでシステムにフックし、値セマンティクスを使用するオブジェクトから必要な情報を取得することで、テキストのレイアウトと表示を制御します。

00:15:02.000 --> 00:15:10.000
変更を加えるには、必要な変更で値オブジェクトの新しいインスタンスを作成し、システムに返します。

00:15:10.000 --> 00:15:15.000
システムは、レイアウトと表示に置換オブジェクトの値を使用します。

00:15:15.000 --> 00:15:21.000
それでは、これらの新しいオブジェクトに会い、それらを受信または交換できるシステムのさまざまなポイントを特定しましょう。

00:15:21.000 --> 00:15:25.000
ストレージオブジェクトから始めます。

00:15:25.000 --> 00:15:28.000
NSTextElementをご紹介します。

00:15:28.000 --> 00:15:31.000
要素はドキュメントの構成要素です。

00:15:31.000 --> 00:15:38.000
各要素はコンテンツの一部を表し、ドキュメントのどこにあるかを記述する範囲が含まれています。

00:15:38.000 --> 00:15:41.000
そして、要素には価値のセマンティクスがあります。

00:15:41.000 --> 00:15:48.000
範囲を含むそれらのプロパティは不変であり、要素の作成後に変更することはできません。

00:15:48.000 --> 00:15:55.000
文書を一連の文字ではなく一連の要素としてモデル化することは、私たちにもっと多くの力を与えます。

00:15:55.000 --> 00:16:07.000
テキストの段落、添付ファイル、またはその他のカスタムタイプなど、特定の要素が表すコンテンツの種類を簡単に区別できます。

00:16:07.000 --> 00:16:13.000
そして、そのタイプに基づいて要素をレイアウトする方法を決定することができます。

00:16:13.000 --> 00:16:16.000
それでは、NSTextContentManagerに会いましょう。

00:16:16.000 --> 00:16:25.000
コンテンツマネージャーは、テキストコンテンツから要素を生成する方法を知っており、ドキュメント全体内のそれらの要素の範囲を追跡します。

00:16:25.000 --> 00:16:34.000
また、バッキングストアで作業する方法や、バッキングストアのコンテンツが変更されたときに更新された範囲で新しい要素を生成する方法も知っています。

00:16:34.000 --> 00:16:38.000
コンテンツマネージャーをバッキングストアのラッパーと考えてください。

00:16:38.000 --> 00:16:46.000
コンテンツマネージャーは、生データを要素に変換するためのインターフェースを提供します。

00:16:46.000 --> 00:16:56.000
NSTextContentManagerとNSTextElementはどちらも抽象型であるため、カスタムドキュメントモデルまたはカスタムバッキングストアを使用する必要がある場合は、それらをサブクラス化できます。

00:16:56.000 --> 00:17:00.000
ヘッダーとドキュメントは、これを行う方法に関するガイダンスを提供します。

00:17:00.000 --> 00:17:05.000
しかし、ほとんどの場合、TextKit 2が提供するデフォルトのものを使用できます。

00:17:05.000 --> 00:17:09.000
NSTextContentStorageとNSTextParagraphをご紹介します。

00:17:09.000 --> 00:17:14.000
これらはデフォルトのコンテンツマネージャーと要素タイプです。

00:17:14.000 --> 00:17:21.000
NSTextContentStorageは、NSTextStorageをバッキングストアとして使用するコンテンツマネージャーです。

00:17:21.000 --> 00:17:29.000
テキストストレージの内容を、NSTextParagraphのインスタンスである段落要素に分割する方法を知っています。

00:17:29.000 --> 00:17:37.000
NSTextContentStorageは、テキストストレージ内のテキストが変更されたときに更新された段落要素を生成する方法も知っています。

00:17:37.000 --> 00:17:40.000
これは私を重要なポイントに導きます。

00:17:40.000 --> 00:17:48.000
基礎となるテキストストレージに変更を加えるときは、このperformEditingTransactionメソッドで更新をラップする必要があります。

00:17:48.000 --> 00:17:55.000
これにより、TextKit 2システムの他の部分にあなたの変更が確実に通知されます。

00:17:55.000 --> 00:18:02.000
完全なNSTextContentManagerサブクラスを実装することなく、コンテンツストレージデリゲートでいくつかのクールなことを行うことができます。

00:18:02.000 --> 00:18:12.000
このビデオの後半では、クリスは、コンテンツデリゲートを使用してテキストストレージを変更せずにコメントのフォントと色を変更する方法と、コメントを完全に非表示にする方法について説明します。

00:18:12.000 --> 00:18:16.000
詳細については、ご期待ください。

00:18:16.000 --> 00:18:17.000
わかりました。

00:18:17.000 --> 00:18:22.000
これで、TextKit 2がテキストコンテンツから要素を作成する方法を理解しました。

00:18:22.000 --> 00:18:26.000
それは私たちの新しいアプローチからの最初の2つのステップの世話をします。

00:18:26.000 --> 00:18:35.000
コンテンツストレージは自動的にテキストを段落要素に分割し、新しいコメントの新しい段落を作成する方法を知っています。

00:18:35.000 --> 00:18:41.000
次に、コメントのポジショニングと表示という最後の2つのステップを達成する方法を考えてみましょう。

00:18:41.000 --> 00:18:47.000
フロー図に戻ると、コメント要素のレイアウト情報を取得する必要があります。

00:18:47.000 --> 00:18:50.000
これらのタスクに役立つ新しいレイアウトオブジェクトがあります。

00:18:50.000 --> 00:18:53.000
今、彼らに会いましょう。

00:18:53.000 --> 00:18:56.000
NSTextLayoutManagerをご紹介します。

00:18:56.000 --> 00:19:00.000
テキストレイアウトマネージャは、テキストレイアウトプロセスを制御します。

00:19:00.000 --> 00:19:12.000
NSTextLayoutManagerは、TextKit 1の古いNSLayoutManagerに似ていますが、1つの大きな違いがあります。NSTextLayoutManagerはグリフを扱っていません。

00:19:12.000 --> 00:19:23.000
代わりに、NSTextLayoutManagerはテキスト要素をテキストコンテナにレイアウトし、それらの要素のレイアウトフラグメントを生成します。

00:19:23.000 --> 00:19:27.000
レイアウトフラグメントを使用して、テキスト要素のレイアウト情報を取得します。

00:19:27.000 --> 00:19:31.000
それでは、レイアウトフラグメントについて学びましょう。

00:19:31.000 --> 00:19:34.000
NSTextLayoutFragmentをご紹介します。

00:19:34.000 --> 00:19:39.000
レイアウトフラグメントには、1つ以上のテキスト要素のレイアウト情報が含まれています。

00:19:39.000 --> 00:19:45.000
要素と同様に、それらは値セマンティクスを使用し、そのプロパティは不変です。

00:19:45.000 --> 00:19:56.000
したがって、テキストレイアウトマネージャーは、各コメント要素のレイアウトフラグメントを作成し、レイアウトフラグメントの情報を使用して配置して表示することができます。

00:19:56.000 --> 00:20:10.000
レイアウトフラグメントは、textLineFragmentsの配列、layoutFragmentFrame、およびrendersSurfaceBoundsの3つのプロパティを通じてレイアウト情報を伝えます。

00:20:10.000 --> 00:20:17.000
レイアウトをカスタマイズまたは変更する場合は、これらの各プロパティで得られる情報を理解することが不可欠です。

00:20:17.000 --> 00:20:20.000
だから、次はそれを調べます。

00:20:20.000 --> 00:20:24.000
最初のプロパティでは、NSTextLineFragmentに会います。

00:20:24.000 --> 00:20:30.000
ラインフラグメントには、レイアウトフラグメント内のテキストの各行の測定情報が含まれています。

00:20:30.000 --> 00:20:39.000
これらは、特定の行の幾何学的情報を取得したり、レイアウトフラグメントの行数を数えたりするのに便利です。

00:20:39.000 --> 00:20:48.000
2番目のプロパティであるレイアウトフラグメントフレームは、レイアウトフラグメント内のテキストがテキストコンテナ領域内にどのようにレイアウトされるかを説明しています。

00:20:48.000 --> 00:20:55.000
TextKit 2では、テキストレイアウトは基本的にコンテナ内のレイアウトフラグメントフレームを積み重ねています。

00:20:55.000 --> 00:20:57.000
これらのフレームをタイルのように考えてください。

00:20:57.000 --> 00:21:05.000
システムは、テキストコンテナ領域をタイルに分割しており、各レイアウトフラグメントは単一のタイルです。

00:21:05.000 --> 00:21:10.000
図に示すように、空の線には独自のレイアウトフラグメントフレームがあります。

00:21:10.000 --> 00:21:22.000
一般に、レイアウトフラグメントフレームは、フラグメントコンテンツの近くにUI内の他のビューを配置したり、テキストコンテンツの合計高さを計算したりするのに便利です。

00:21:22.000 --> 00:21:27.000
さて、このフレームはテキスト自体を描画するために必要なスペースを正確に表していません。

00:21:27.000 --> 00:21:31.000
その情報は第3の財産から来ています。

00:21:31.000 --> 00:21:37.000
レンダリングサーフェスの境界は、テキストを描画するために必要な領域を記述します。

00:21:37.000 --> 00:21:43.000
これは、ビューの座標空間内のテキストのサイズを取得するために使用する長方形です。

00:21:43.000 --> 00:21:49.000
そして、テキストはフラグメントフレームの端をオーバーシュートする可能性があるため、これはレイアウトフラグメントフレームとは異なります。

00:21:49.000 --> 00:21:56.000
これは、発音記号、またはここに示すように、イタリックフォントの長いディセンダで発生します。

00:21:56.000 --> 00:22:04.000
Jの左下端がレイアウトフラグメントフレームからほんの少し突き出ていることに注目してください。

00:22:04.000 --> 00:22:09.000
それはそれほど目立たないので、ここにもっと極端な例があります。

00:22:09.000 --> 00:22:15.000
Zapfinoのようないくつかのフォントには、タイポグラフィの境界をはるかに超えているグリフがあります。

00:22:15.000 --> 00:22:21.000
この場合、レンダリングサーフェスの境界はレイアウトフラグメントフレームよりもはるかに大きくなります。

00:22:21.000 --> 00:22:32.000
レイアウトフラグメントが提供するレイアウト情報を理解したので、少しバックアップして、この情報を使用してテキスト要素のレイアウトをカスタマイズする方法について話しましょう。

00:22:32.000 --> 00:22:40.000
レイアウトフラグメントは不変であるため、フラグメントのレイアウト情報を直接変更することはできません。

00:22:40.000 --> 00:22:53.000
フロー図に戻ると、レイアウトプロセスにフックし、変更したい情報を使用してNSTextLayoutFragmentの新しいインスタンスを作成する必要があります。

00:22:53.000 --> 00:23:00.000
そして、NSTextLayoutManagerでこのデリゲートメソッドを使用してレイアウトプロセスにフックします。

00:23:00.000 --> 00:23:07.000
このメソッドは、テキストレイアウトマネージャーが要素からレイアウトフラグメントを生成しているときに、レイアウトプロセス中に呼び出されます。

00:23:07.000 --> 00:23:15.000
ここでは、要素の独自のレイアウトフラグメントを作成する機会があります。

00:23:15.000 --> 00:23:19.000
これは、コメント問題へのアプローチの最後の2つのステップを処理します。

00:23:19.000 --> 00:23:31.000
NSTextLayoutFragmentのサブクラスを使用し、テキストレイアウトマネージャーデリゲートにカスタムフラグメントのインスタンスを提供することで、コメントレイアウトフラグメントの配置とカスタム描画を処理します。

00:23:31.000 --> 00:23:37.000
このビデオの後半で、クリスはこれが私たちのサンプルアプリでどのように行われるかを実演します。

00:23:37.000 --> 00:23:38.000
そして、それは安全です。

00:23:38.000 --> 00:23:42.000
では、パフォーマンスに移りましょう。

00:23:42.000 --> 00:23:46.000
パフォーマンスは、あらゆるテキストエンジンにとって最大の課題の1つです。

00:23:46.000 --> 00:23:59.000
TextKit 2は、それぞれわずか数行のラベルをすばやくレンダリングすることから、インタラクティブな速度でスクロールされる数百メガバイトのドキュメントをレイアウトすることまで、信じられないほど幅広いシナリオで非常に高速です。

00:23:59.000 --> 00:24:14.000
そして、これらのシナリオでは、これらの本当に大きな文書を可変速度でスクロールしているとき、連続しないテキストレイアウトは優れたパフォーマンスのために絶対に不可欠です。

00:24:14.000 --> 00:24:19.000
連続したレイアウトと非連続したレイアウトの違いを確認しましょう。

00:24:19.000 --> 00:24:27.000
この図は、黄色の長方形が画面上の目に見えるコンテンツ領域を表す文書を示しています。

00:24:27.000 --> 00:24:35.000
連続したレイアウトは、ドキュメントの先頭から始まり、テキストの先頭から末尾まで順番に進みます。

00:24:35.000 --> 00:24:44.000
したがって、ドキュメントの中央のどこかのポイントまでスクロールすると、連続したレイアウトは、そのポイントの前に来たすべてのテキストのレイアウトを実行します。

00:24:44.000 --> 00:24:50.000
これには、最初から最後まで、画面からスクロールされたすべてのテキストが含まれます。

00:24:50.000 --> 00:24:57.000
また、テキストが多い場合は、パフォーマンスが遅くなり、スクロール時にアニメーションのしゃっくりが得られる可能性があります。

00:24:57.000 --> 00:25:01.000
最悪の場合、それはハングアップすることができます。

00:25:01.000 --> 00:25:11.000
対照的に、非連続したレイアウトは、その前に来る部分をレイアウトすることなく、文書内のどこにでもテキストの一部をレイアウトできることを意味します。

00:25:11.000 --> 00:25:18.000
ドキュメントの中央までスクロールすると、その表示領域のレイアウトがすぐに発生します。

00:25:18.000 --> 00:25:30.000
これにより、画面に表示されるテキストの一部と追加のオーバースクロール領域に対してのみレイアウトを実行することでパフォーマンスが向上し、よりスムーズなスクロール体験が得られます。

00:25:30.000 --> 00:25:35.000
そして、TextKit 2のレイアウトは常に連続しません。

00:25:35.000 --> 00:25:41.000
対照的に、TextKit 1では非連続レイアウトはオプションです。

00:25:41.000 --> 00:25:46.000
NSLayoutManagerのブールプロパティを使用して有効になります。

00:25:46.000 --> 00:25:57.000
このAPIはシンプルですが、シンプルであるため、レイアウト情報を要求したときのレイアウトの状態に関する情報を表現することはできません。

00:25:57.000 --> 00:26:04.000
非連続レイアウトは、ドキュメントの他の部分がレイアウトされると後で変更される可能性のある見積もりに依存しています。

00:26:04.000 --> 00:26:10.000
TextKit 1では、非連続レイアウトのオン/オフのみを切り替えることができます。

00:26:10.000 --> 00:26:20.000
ドキュメントのどの部分がレイアウトされるかを制御する機能はなく、レイアウトがいつ終了し、レイアウトの見積もりが実際の値に更新されるかを知る方法はありません。

00:26:20.000 --> 00:26:26.000
TextKit 2 APIは、より豊かで表現力豊かです。

00:26:26.000 --> 00:26:36.000
TextKit 2は、可視コンテンツ領域の要素の一貫したレイアウト情報を提供し、その可視領域のレイアウトが更新されたときに通知します。

00:26:36.000 --> 00:26:39.000
このエリアはビューポートと呼ばれています。

00:26:39.000 --> 00:26:48.000
ビューポートを調整または再配置して管理し、ビューポートレイアウトの前、最中、後にコールバックを受け取ります。

00:26:48.000 --> 00:26:55.000
最適なパフォーマンスを得るには、コードはビューポート領域内のレイアウト情報の操作に集中する必要があります。

00:26:55.000 --> 00:27:02.000
可能であれば、ビューポート外の要素のレイアウト情報を要求しないでください。

00:27:02.000 --> 00:27:13.000
ビューポート外の要素のレイアウト情報は、これらの要素に対応するテキスト範囲のレイアウトの確保を明示的に要求しない限り、正確ではない可能性があります。

00:27:13.000 --> 00:27:19.000
この通話は、特に大きな文書の場合、高価になる可能性があります。

00:27:19.000 --> 00:27:28.000
先ほどのフロー図を再検討すると、ビューポートの管理に役立つ別の新しいコントローラークラスがあります。

00:27:28.000 --> 00:27:31.000
NSTextViewportLayoutControllerをご紹介します。

00:27:31.000 --> 00:27:35.000
これは、ビューポートレイアウト情報の真実の源です。

00:27:35.000 --> 00:27:42.000
テキストレイアウトマネージャーと話して、ビューポート領域内の要素のレイアウトフラグメントを取得します。

00:27:42.000 --> 00:27:48.000
テキストレイアウトマネージャーのプロパティからビューポートレイアウトコントローラーにアクセスできます。

00:27:48.000 --> 00:27:56.000
ビューポートレイアウトコントローラーに出会ったので、ビューポートレイアウトプロセスに参加する方法について話しましょう。

00:27:56.000 --> 00:28:16.000
ビューポートレイアウトコントローラーは、ビューポートレイアウトプロセス中にデリゲートの3つの重要なメソッドを呼び出します。TextViewportLayoutController WillLayout、textViewportController configureRenderingSurface FortextLayoutFragment、およびtextViewportLayoutController DidLayout。

00:28:16.000 --> 00:28:23.000
まず、ビューポートレイアウトコントローラーは、ビューポートに要素をレイアウトする前に、willLayoutメソッドを呼び出します。

00:28:23.000 --> 00:28:31.000
ここでは、ビューやレイヤーの内容をクリアするなど、レイアウトの準備のためのセットアップ作業を行う場所です。

00:28:31.000 --> 00:28:39.000
次に、ビューポートレイアウトコントローラーは、ビューポートに表示されるすべてのレイアウトフラグメントに対してconfigureRenderingSurfaceを呼び出します。

00:28:39.000 --> 00:28:44.000
ここでは、各フラグメントビューまたはレイヤーのジオメトリを更新します。

00:28:44.000 --> 00:28:54.000
最後に、ビューポートレイアウトコントローラーは、ビューポートに表示されるすべてのレイアウトフラグメントのレイアウトが完了した後、didLayoutメソッドを呼び出します。

00:28:54.000 --> 00:29:03.000
そして、ビューポートのレイアウトが完了した後、ビューポートを調整して最後の要素を画面に完全に表示したい場合など、必要な更新を実行する場所です。

00:29:03.000 --> 00:29:05.000
そして、それはパフォーマンスのためにそれを要約します。

00:29:05.000 --> 00:29:10.000
今、私はそれをクリスに渡して、実際にTextKit 2の使い方をお見せします。

00:29:10.000 --> 00:29:11.000
ありがとう、ドナ。

00:29:11.000 --> 00:29:18.000
TextKit 2を使用してアプリ内のテキストをレイアウトしたり操作したりするさまざまな方法のいくつかを示すサンプルアプリを書きました。

00:29:18.000 --> 00:29:21.000
このビデオで使用されているサンプルコードをダウンロードできます。

00:29:21.000 --> 00:29:24.000
開けて試してみましょう。

00:29:24.000 --> 00:29:31.000
このコラボレーションアプリを使用してレシピの本をレビューし、昼食に何を作りたいかを把握できます。

00:29:31.000 --> 00:29:42.000
レシピのスクロールは期待どおりに機能しますが、舞台裏で何か特別なことが起こっています。ビューポートに表示される段落のみが描画されています。

00:29:42.000 --> 00:29:49.000
そして、すべての段落が同じ大きな表面にレンダリングされる代わりに、各段落は独自のレイヤーにレンダリングされます。

00:29:49.000 --> 00:29:55.000
ここのツールバーの[境界を表示]ボタンをクリックすると、これらの色付きの長方形が表示されます。

00:29:55.000 --> 00:30:00.000
オレンジ色の長方形は、各レイヤーの境界を示しています。

00:30:00.000 --> 00:30:06.000
テキストを別々のレイヤーに描画すると、楽しい機能を実装できます。レシピにコメントを残すことができます。

00:30:06.000 --> 00:30:19.000
さて、エッグサンドイッチはかなり良さそうだと思うので、この段落をダブルクリックして「ねえ、これはかなり良さそうですね」と入力し、Enterキーを押してコメントを挿入します。

00:30:19.000 --> 00:30:23.000
文書に新しい段落を挿入しました。

00:30:23.000 --> 00:30:29.000
バブルの背景は、BubbleLayoutFragmentと呼ばれるNSTextLayoutFragmentのカスタムサブクラスによって描画されています。

00:30:29.000 --> 00:30:31.000
それについては後で詳しく説明します。

00:30:31.000 --> 00:30:39.000
特別なのは、文書にコメントを挿入すると、コメントの下のすべての段落がそれのためのスペースを作るために移動することです。

00:30:39.000 --> 00:30:46.000
初めて捕まえなかった場合は、ツールバーのこのタートルボタンをクリックしてスローモードを有効にします。

00:30:46.000 --> 00:30:48.000
別のコメントを追加しましょう。

00:30:48.000 --> 00:30:52.000
ええ、今日の昼食に作りましょう。

00:30:52.000 --> 00:30:59.000
Enterキーを押すと、その下のドキュメントにコメントが追加され、その下のすべての段落がゆっくりとアニメーション化されます。

00:30:59.000 --> 00:31:04.000
すべてのコメントを非表示にしたい場合は、ツールバーの[コメントの切り替え]ボタンをクリックします。

00:31:04.000 --> 00:31:08.000
これは実際に基礎となる文書を編集しているわけではありません。

00:31:08.000 --> 00:31:15.000
代わりに、レイアウトのテキスト要素を列挙するときにコメントをスキップするようにテキストコンテンツマネージャーに求めています。

00:31:15.000 --> 00:31:20.000
TextKit 2は、macOSと同様にiOSでも同様に機能します。

00:31:20.000 --> 00:31:24.000
これは、macOSアプリのTextKit 2の部分がiOSで再利用できることを意味します。

00:31:24.000 --> 00:31:28.000
iPadで実行しましょう。

00:31:28.000 --> 00:31:35.000
これらの部分を使用して、同じ機能を備えたコラボレーションアプリのiOSバージョンを書きました。

00:31:35.000 --> 00:31:43.000
段落を長押ししてコメントを残し、「やあ、それは良さそうだね」と入力しています...

00:31:43.000 --> 00:31:46.000
そしてEnterキーを押す。

00:31:46.000 --> 00:31:53.000
macOSのアプリと同じように、コメントの表示/非表示ボタンをタップして、すべてのコメントを非表示にすることができます。

00:31:53.000 --> 00:31:59.000
TextKit 2を使用してレイアウトし、描画し、テキストを操作するアプリを操作したところです。

00:31:59.000 --> 00:32:05.000
それでは、サンプルアプリのコードの一部と、TextKit 2がそれを可能にする方法について説明します。

00:32:05.000 --> 00:32:23.000
このアプリはTextKit 2が提供する多くの機能を示していますが、今のところ2つの分野に焦点を当てたいと思います。NSViewportLayoutControllerを使用してビューポート内のテキストをどのようにレイアウトするか、カスタム非表示動作とコメントのレンダリングをどのように実装するかです。

00:32:23.000 --> 00:32:41.000
テキストレイアウトマネージャが変更されたため、コンテナサイズが変更されたため、またはドキュメントのこれまで見られなかった部分がビューポートに移動したためにドキュメントをレイアウトしようとしているとき、ビューポートレイアウトデリゲートでtextViewportLayout ControllerWillLayoutを呼び出します。

00:32:41.000 --> 00:32:48.000
ここでは、すべてのテキストサブレイヤーをクリアし、アニメーショントランザクションを開くために使用しています。

00:32:48.000 --> 00:32:57.000
テキストレイアウトマネージャがレイアウトするテキスト要素ごとに、textViewportLayoutController、configureRenderingSurfaceFor textLayoutFragmentを呼び出します。

00:32:57.000 --> 00:33:11.000
ここでは、テキストレイアウトの断片を表示し、ジオメトリを更新し、可能であれば新しい位置にアニメーション化し、ビューのサブレイヤーとして追加するレイヤーを取得しています。

00:33:11.000 --> 00:33:17.000
レイアウトマネージャのレイアウトが完了すると、textViewportLayout ControllerDidLayoutが呼び出されます。

00:33:17.000 --> 00:33:28.000
アニメーショントランザクションをコミットし、選択のハイライトを更新し、スクロールの親指が正しく配置されるようにコンテンツサイズを更新します。

00:33:28.000 --> 00:33:30.000
では、コメントについて話しましょう。

00:33:30.000 --> 00:33:37.000
TextKit 2は、レイアウト要素とレイアウトフラグメントの生成をカスタマイズするために使用できるいくつかのフックを提供します。

00:33:37.000 --> 00:33:48.000
ドキュメントのコメントを取り、表示用のフォントや色などのカスタム属性を設定し、その背後にあるバブルを描く方法を紹介します。

00:33:48.000 --> 00:33:57.000
ドキュメントの各段落について、テキストコンテンツストレージは、そのデリゲートにその段落の属性をカスタマイズする機会を与えます。

00:33:57.000 --> 00:34:07.000
実装では、基礎となるテキストストレージのフォントや色を変更することなく、コメントにカスタムフォントと色を設定しています。

00:34:07.000 --> 00:34:16.000
テキストコンテンツマネージャーはまた、そのデリゲートにレイアウト中にテキストレイアウトマネージャーにどのテキスト要素を表示するかを決定する機会を与えます。

00:34:16.000 --> 00:34:20.000
テキスト要素にfalseを返すと、表示されなくなります。

00:34:20.000 --> 00:34:29.000
ここでは、基礎となるテキストストレージから実際に削除することなく、コメントを列挙しないことを選択することで、コメントを隠しています。

00:34:29.000 --> 00:34:32.000
テキストレイアウトマネージャーにもデリゲートがあります。

00:34:32.000 --> 00:34:47.000
textLayoutManager、textLayoutFragmentFor location in textElementを実装することにより、デリゲートは、特定のNSTextElementのデフォルトのNSTextLayoutFragmentインスタンスの代わりに、カスタムテキストレイアウトフラグメントを生成できます。

00:34:47.000 --> 00:34:59.000
この場合、コメントを表すNSTextElementに遭遇すると、NSTextLayoutFragmentのカスタムサブクラスであるBubbleLayoutFragmentが作成されます。

00:34:59.000 --> 00:35:10.000
BubbleLayoutFragmentは、NSTextLayoutFragmentの描画メソッドを上書きして、基本クラスの実装を呼び出してテキストを上に描画する前に、背景バブルを描画します。

00:35:10.000 --> 00:35:17.000
テキストは、先ほど設定したカスタムフォントとテキストの色でレンダリングされていることに注意してください。

00:35:17.000 --> 00:35:31.000
サンプルアプリがTextKit 2を使用してテキストのビューポートベースのアニメーションレイアウトを実行する方法と、テキストストレージのカスタム属性からカスタム描画まで、それらのカラフルなバブルにコメントを表示する方法を調べました。

00:35:31.000 --> 00:35:50.000
しかし、テキスト選択を決定するためのマウスイベントの解釈、テキスト選択のハイライトのレンダリング、ドキュメント内の特定の段落へのコメントポップオーバーの配置、ドキュメントの高さの推定など、TextKit 2が提供する新しいAPIを利用するサンプルコードにはもっと多くのものがあります。

00:35:50.000 --> 00:35:54.000
これらすべてのトピックのさらなる議論は、サンプルコードで見つけることができます。

00:35:54.000 --> 00:35:58.000
ドナに戻って、TextKit 2用のアプリの準備について話しましょう。

00:35:58.000 --> 00:36:00.000
ありがとう、クリス。

00:36:00.000 --> 00:36:05.000
これは、TextKit 2が実際にどのように機能するかの素晴らしい例です。

00:36:05.000 --> 00:36:13.000
TextKit 2で何ができるかを説明したので、アプリの近代化のためのいくつかのアプローチについて話し合いましょう。

00:36:13.000 --> 00:36:21.000
これまでに話したことはすべて、一般的なビューまたはレイヤーで使用する独自のTextKit 2スタックの作成に適用されます。

00:36:21.000 --> 00:36:27.000
すべての新しいクラスは、iOS 15のUIKitとmacOS 12のAppKitで利用できます。

00:36:27.000 --> 00:36:34.000
だから、このルートに行きたいなら、今日からTextKit 2で新しいコードを書き始めることができます。

00:36:34.000 --> 00:36:46.000
一方、多くのアプリは、テキストビューなどの組み込みのテキストコントロールを使用して、アクセシビリティサポートや選択および編集サービスなど、すべての優れた無料機能を利用できます。

00:36:46.000 --> 00:36:51.000
これらのコントロールのいくつかは、TextKit 2を使用するようにすでに更新されています。

00:36:51.000 --> 00:36:57.000
アプリが組み込みのコントロールを使用している場合は、注意すべき追加の詳細がいくつかあります。

00:36:57.000 --> 00:37:02.000
互換性を維持することは、あなたと同じくらい私たちにとっても重要です。

00:37:02.000 --> 00:37:11.000
TextKit 1は組み込みのテキストコントロールの不可欠な部分であるため、それらを使用しているアプリの互換性を維持するために多大な努力を払います。

00:37:11.000 --> 00:37:19.000
これが、一部のコントロールだけがiOS 15とmacOS 12でTextKit 2を自動的に使用する理由です。

00:37:19.000 --> 00:37:26.000
さらに、一部のコントロールでは、これらのOSバージョンでTextKit 2を使用するための追加の手順が必要です。

00:37:26.000 --> 00:37:32.000
AppKit開発者にとって、NSTextViewはTextKit 2を自動的に使用しません。

00:37:32.000 --> 00:37:40.000
NSTextViewでTextKit 2を使用する場合は、作成時にプログラムでオプトインする必要があります。

00:37:40.000 --> 00:37:42.000
これがやり方です。

00:37:42.000 --> 00:37:46.000
まず、テキストレイアウトマネージャーを作成します。

00:37:46.000 --> 00:37:49.000
次に、テキストコンテナを作成します。

00:37:49.000 --> 00:37:57.000
次に、NSTextLayoutManagerのtextContainerプロパティを使用して、テキストコンテナをテキストレイアウトマネージャーに関連付けます。

00:37:57.000 --> 00:38:05.000
最後に、テキストコンテナで指定された初期化子を使用してNSTextViewを作成します。

00:38:05.000 --> 00:38:08.000
これで、TextKit 2を使用するテキストビューが表示されます。

00:38:08.000 --> 00:38:15.000
NSTextViewの新しいプロパティを使用して、テキストレイアウトマネージャーとテキストコンテンツストレージにアクセスできます。

00:38:15.000 --> 00:38:18.000
注意すべきことが1つだけあります。

00:38:18.000 --> 00:38:25.000
NSTextViewには、NSLayoutManagerを取得して設定できるlayoutManagerプロパティがあることを思い出してください。

00:38:25.000 --> 00:38:32.000
NSLayoutManagerはTextKit 1オブジェクトであり、TextKit 2スタックと互換性がありません。

00:38:32.000 --> 00:38:39.000
テキストビューは、レイアウトマネージャーとテキストレイアウトマネージャーの両方を同時に持つことはできません。

00:38:39.000 --> 00:38:41.000
だから、これが取引です。

00:38:41.000 --> 00:38:47.000
NSTextViewの特別な互換性モードを追加し、必要に応じてTextKit 1に切り替えました。

00:38:47.000 --> 00:38:56.000
テキストビューは、このモードを使用する必要があるかどうかを自動的に検出し、NSTextLayoutManagerをNSLayoutManagerに置き換えることができます。

00:38:56.000 --> 00:39:03.000
最適なパフォーマンスのために、テキストビューはその時点から互換性モードのままになります。

00:39:03.000 --> 00:39:15.000
TextKit 2をオプトインした場合でも、テキストビューまたはテキストコンテナのlayoutManagerプロパティを明示的に呼び出すと、テキストビューは自動的にTextKit 1に切り替わります。

00:39:15.000 --> 00:39:24.000
テキストビューは、まだサポートされていないテキストコンテンツに遭遇した場合、またはTextKit 1を必要とする他の条件を検出した場合にも切り替わります。

00:39:24.000 --> 00:39:28.000
そして、これはフィールド編集者にも起こる可能性があります。

00:39:28.000 --> 00:39:32.000
NSTextFieldのフィールドエディタは、デフォルトでTextKit 2を使用します。

00:39:32.000 --> 00:39:45.000
しかし、テキストフィールドサブクラスがフィールドエディタのレイアウトマネージャーからレイアウト情報を要求している場合、フィールドエディタはそのウィンドウ内のすべてのテキストフィールドに対してTextKit 1に切り替わります。

00:39:45.000 --> 00:39:50.000
システムは、テキストビューがTextKit 1に切り替わる前後に通知を発行します。

00:39:50.000 --> 00:39:54.000
これらの通知を観察して、この情報を受け取ることができます。

00:39:54.000 --> 00:40:00.000
通知オブジェクトには、モードを変更した正確なテキストビューへの参照が含まれています。

00:40:00.000 --> 00:40:09.000
AppKitのTextKit 1互換モードの詳細については、Apple Developerポータルのドキュメントを参照してください。

00:40:09.000 --> 00:40:16.000
UIKit開発者にとって、UITextFieldはiOS 15でTextKit 2を自動的に使用します。

00:40:16.000 --> 00:40:23.000
TextKit 2を使用したUITextViewは、iOS 15では利用できません。

00:40:23.000 --> 00:40:30.000
私たちは、UITextViewを使用するすべてのアプリケーションに最大限の互換性を確保するため取り組んでおり、それらはかなりたくさんあります。

00:40:30.000 --> 00:40:41.000
それまでの間、UITextViewのlayoutManagerプロパティの使用について既存のコードを確認し、TextKit 2で意図を表現する方法を考えることができます。

00:40:41.000 --> 00:40:45.000
そうすれば、利用可能になったら移行する準備が整います。

00:40:45.000 --> 00:40:47.000
そして、それはラップです。

00:40:47.000 --> 00:40:52.000
今、あなたは私たちを未来に連れて行くためのAppleの新しいテキストエンジンであるTextKit 2に会いました。

00:40:52.000 --> 00:40:55.000
TextKit 2で何を構築するかを楽しみにしています。

00:40:55.000 --> 00:40:56.000
見てくれてありがとう。

00:40:56.000 --> 23:59:59.000
[明るい音楽]。

