WEBVTT

00:00:02.000 --> 00:00:15.000
こんにちは！私の名前はエゴールです。今日は、メタルデバッガーのすべての改善点と新機能についてお話ししたいと思います。

00:00:15.000 --> 00:00:23.000
今年は、レイトレーシングやファンクションポインタなど、より多くのメタル機能のサポートをもたらします。

00:00:23.000 --> 00:00:35.000
Appleプラットフォーム全体でGPUを最大限に活用できるように、GPUタイムラインや一貫したGPUパフォーマンス状態など、まったく新しいプロファイリングワークフローを追加しました。

00:00:35.000 --> 00:00:45.000
シェーダー検証のより広範なサポートや正確なキャプチャコントロールなど、あなたが知っていて愛している他のデバッグワークフローを改善しました。

00:00:45.000 --> 00:00:53.000
また、同僚のアマンダが後で話すテクスチャ圧縮の進歩も紹介しています。

00:00:53.000 --> 00:00:56.000
まず、レイトレーシングについて話しましょう。

00:00:56.000 --> 00:01:11.000
昨年、新しいメタルレイトレーシングAPIを導入し、現在、Xcode 13では、シェーダーに柔軟性をもたらす機能ポインタと関数テーブルとともに、メタルデバッガでサポートしています。

00:01:11.000 --> 00:01:18.000
そして、ダイナミックライブラリは、よく抽象的で再利用可能なシェーダーライブラリコードを構築する方法を提供します。

00:01:18.000 --> 00:01:25.000
また、レイトレーシングには、まったく新しいツールであるAcceleration Structure Viewerを導入しています。

00:01:25.000 --> 00:01:28.000
メタルデバッガのレイトレーシングを見てみましょう。

00:01:28.000 --> 00:01:33.000
ModernRendererサンプルアプリのGPUトレースを開きました。

00:01:33.000 --> 00:01:41.000
影や周囲の閉塞などの効果を達成するために、メタルレイトレーシングを使用するように変更されました。

00:01:41.000 --> 00:01:45.000
このエンコーダは、美しいレイトレースシャドウマップを作成します。

00:01:45.000 --> 00:01:51.000
バインドされたリソースの加速構造を確認できるように、ディスパッチコールを選択しました。

00:01:51.000 --> 00:01:58.000
ここから、加速構造を開いて、新しい加速構造ビューアに移動します。

00:01:58.000 --> 00:02:07.000
ここでは、右側に馴染みのあるビストロシーンのジオメトリ、左側にそのアウトラインを見ることができます。

00:02:07.000 --> 00:02:14.000
シーン内のインスタンスをクリックすると、ビューアとシーンアウトラインで選択されます。

00:02:14.000 --> 00:02:20.000
展開することで、変換行列やその他のインスタンスプロパティを確認できます。

00:02:20.000 --> 00:02:26.000
シーンビューアでOptionキーを押しながらクリックすることで、個々のジオメトリを選択することもできます。

00:02:26.000 --> 00:02:32.000
これにより、シーンのアウトラインでも選択され、その逆も同様です。

00:02:32.000 --> 00:02:40.000
また、加速構造で使用される関連する交差関数をビューアで確認することもできます。

00:02:40.000 --> 00:02:46.000
しかし、加速構造ビューアは、単にジオメトリを表示するよりもはるかに多くのことができます。

00:02:46.000 --> 00:02:54.000
右下には、シーンのプロパティの一部を視覚化するのに役立ついくつかのハイライトモードもあります。

00:02:54.000 --> 00:03:01.000
たとえば、バウンディングボリュームトラバーサルモードは、ジオメトリの複雑さを視覚化するのに役立ちます。

00:03:01.000 --> 00:03:11.000
より深い青色は、境界ボリューム階層が他の部分と比較して横断するのに計算コストがかかる領域を示しています。

00:03:11.000 --> 00:03:18.000
すべてのモードについて、シーンのさまざまな部分にカーソルを合わせると、関連情報を表示するこの小さなビューがあります。

00:03:18.000 --> 00:03:25.000
ここでは、バウンディングボックストラバーサルとプリミティブ交差点の数が表示されます。

00:03:25.000 --> 00:03:30.000
柔軟性を高めるために、トラバーサル設定も含めました。

00:03:30.000 --> 00:03:40.000
それらを使用すると、シェーダー内のインターセクターオブジェクトで見つけることができるのと同じプロパティを使用して、加速構造ビューアを設定できます。

00:03:40.000 --> 00:03:43.000
レイトレーシングに関しては、話すことがたくさんあります。

00:03:43.000 --> 00:04:01.000
詳細を知りたい場合は、今年のセッション「メタルレイトレーシングでハイブリッドレンダリングを探る」をチェックしてください。そして、一般的なAPIについてもっと知りたい場合は、昨年の講演「金属でレイトレーシングを発見する」をチェックしてください。次に、プロファイリングについて話しましょう。

00:04:01.000 --> 00:04:07.000
アプリをプロファイリングすることは重要なステップであり、私たちはすでにあなたの処分で多くの素晴らしいツールを持っています。

00:04:07.000 --> 00:04:20.000
たとえば、機器のメタルシステムトレースを使用すると、さまざまなレンダリングステージ、GPUカウンタ、シェーダータイムラインのCPUとGPUの期間を示すタイムラインビューを探索できます。

00:04:20.000 --> 00:04:31.000
また、メタルデバッガでは、GPUカウンターは、エンコーダごとまたはドローごとに、GPUから直接豊富な測定セットを表示します。

00:04:31.000 --> 00:04:36.000
どちらも優れたツールであり、アプリのパフォーマンスの補完的なビューを提供します。

00:04:36.000 --> 00:04:40.000
しかし、これらの見解を一致させるには、さらなる努力が必要かもしれません。

00:04:40.000 --> 00:04:50.000
だからこそ、メタルシステムトレースとGPUカウンターを統一された体験で組み合わせた新しいGPUプロファイリングツールをお見せできることを嬉しく思います。

00:04:50.000 --> 00:04:57.000
Apple GPU用に特別に設計された新しいツール、Metal DebuggerのGPUタイムラインをご紹介します。

00:04:57.000 --> 00:05:06.000
パフォーマンスデータについて異なる視点を提供し、アプリで潜在的な最適化ポイントを見つけるのに役立ちます。

00:05:06.000 --> 00:05:12.000
プロファイリングツールのスイートへのこの最新の追加を見ていきましょう。

00:05:12.000 --> 00:05:16.000
GPUタイムラインは、パフォーマンスパネルの下にあります。

00:05:16.000 --> 00:05:21.000
アプリからフレームをキャプチャした後、デバッグナビゲーターで見つけることができます。

00:05:21.000 --> 00:05:28.000
パフォーマンスパネルを開くと、並行して配置されたさまざまなトラックのセットが迎えられます。

00:05:28.000 --> 00:05:33.000
続ける前に、エンコーダトラックが並列になっている理由を説明したいと思います。

00:05:33.000 --> 00:05:42.000
Apple GPUでは、異なるレンダリングパスの頂点とフラグメントステージ、およびコンピューティングディスパッチを同時に実行できます。

00:05:42.000 --> 00:05:57.000
これは、Apple GPUアーキテクチャと「タイルベースの遅延レンダリング」と呼ばれるレンダリング技術の使用によって可能になります。私たちは、アプリのコンテキストでApple GPUのこの並列的な性質を見ることができることが重要だと思いました。

00:05:57.000 --> 00:06:00.000
そして、そこでGPUタイムラインが役に立ちます。

00:06:00.000 --> 00:06:10.000
上部には、頂点、フラグメント、およびコンピュートエンコーダのタイムラインが表示され、各エンコーダは使用するリソースを一目で確認できます。

00:06:10.000 --> 00:06:17.000
エンコーダの下には、占有、帯域幅、リミッターカウンタがあります。

00:06:17.000 --> 00:06:21.000
エンコーダのタイムラインを詳しく見てみましょう。

00:06:21.000 --> 00:06:27.000
各エンコーダトラックを展開して、集約されたシェーダータイムラインを見ることができます。

00:06:27.000 --> 00:06:35.000
タイムラインをさらに拡大すると、それぞれのシェーダーが滝のような方法で表示されます。

00:06:35.000 --> 00:06:38.000
エンコーダをナビゲートするのは簡単です。

00:06:38.000 --> 00:06:43.000
エンコーダトラックを選択すると、右側のすべてのエンコーダのリストが表示されます。

00:06:43.000 --> 00:06:48.000
そこでは、平均期間で並べ替えることができます。

00:06:48.000 --> 00:06:54.000
タイムラインで個々のエンコーダをクリックすると、サイドバーに詳細情報が表示されます。

00:06:54.000 --> 00:07:01.000
たとえば、ここでは、このレンダリングコマンドエンコーダの添付ファイルを見ることができます。

00:07:01.000 --> 00:07:09.000
エンコーダを選択すると、アクティブな時間範囲がすべてのトラックで強調表示されることに気づいたかもしれません。

00:07:09.000 --> 00:07:18.000
これにより、異なるステージがどのように重なるかを簡単に調べることができ、エンコーダのカウンタ値を関連付けることができます。

00:07:18.000 --> 00:07:31.000
タイムラインビューから離れると、[カウンタ]タブに切り替えてGPUカウンタにアクセスするか、エンコーダのコンテキストメニューを開いてそこからカウンタで表示することができます。

00:07:31.000 --> 00:07:36.000
そして、これはGPUタイムラインのスニークピークです。

00:07:36.000 --> 00:07:56.000
Metal Debuggerを使用してアプリのパフォーマンスを理解する方法の詳細については、今年のセッション「Apple GPU用にハイエンドゲームを最適化する」をご覧ください。アプリをプロファイリングする新しい方法を紹介したので、そのパフォーマンスはいくつかの要因に依存することを理解することが重要です。

00:07:56.000 --> 00:08:02.000
メタルについて話すとき、GPUのパフォーマンス状態は非常に重要な要素です。

00:08:02.000 --> 00:08:14.000
オペレーティングシステムによって管理され、デバイスのサーマル、システム設定、GPU使用率、その他のパラメータに応じて状態を下げたり引き上げたりします。

00:08:14.000 --> 00:08:20.000
これらの状態の変更は、表示されているプロファイリング結果に影響を与える可能性があります。

00:08:20.000 --> 00:08:26.000
今年は、より一貫した結果でアプリをプロファイリングするための新しい方法を導入します。

00:08:26.000 --> 00:08:49.000
ライブパフォーマンス録画用のInstrumentsとMetalシステムトレースから始まり、Metal Debugger、GPUトレースのプロファイリング、最後に一般的なユースケース用のXcodeのデバイス条件など、Metalツールのスイート全体でGPUパフォーマンス状態を確認および変更する方法を追加しました。

00:08:49.000 --> 00:08:53.000
まず、楽器について話しましょう。

00:08:53.000 --> 00:08:59.000
今年は、メタルシステムトレースにGPUのパフォーマンス状態のトラックを追加しました。

00:08:59.000 --> 00:09:06.000
他のトラックと組み合わせて使用して、アプリのパフォーマンスとデバイスのパフォーマンス状態を関連付けます。

00:09:06.000 --> 00:09:12.000
ただし、パフォーマンス状態を見ることができることは、方程式の一部にすぎないことを覚えておいてください。

00:09:12.000 --> 00:09:21.000
一貫性のある再現性のあるプロファイリング結果を得るには、デバイスにGPUのパフォーマンス状態を設定する方法も必要です。

00:09:21.000 --> 00:09:29.000
今年の新しいのは、Instrumentsにトレースを記録するときに、特定のGPUパフォーマンス状態を誘導する機能です。

00:09:29.000 --> 00:09:35.000
録画オプションに移動し、録画が始まる前にパフォーマンス状態を選択するだけです。

00:09:35.000 --> 00:09:40.000
その後、通常どおりパフォーマンストレースを記録できます。

00:09:40.000 --> 00:09:45.000
機器は、デバイスがそれを維持できる場合、トレースの期間中に選択した状態を誘導します。

00:09:45.000 --> 00:09:54.000
場合によっては、既存のInstrumentsトレースが記録中にGPUパフォーマンス状態を誘発したかどうかを確認する必要があるかもしれません。

00:09:54.000 --> 00:10:01.000
この情報は、情報ポップオーバーの「録画設定」セクションにあります。

00:10:01.000 --> 00:10:06.000
そして今、あなたはInstrumentsからGPUのパフォーマンス状態を表示し、誘導する方法を知っています。

00:10:06.000 --> 00:10:12.000
一貫したGPUパフォーマンス状態を活用する2番目の方法は、Metal Debuggerを使用することです。

00:10:12.000 --> 00:10:20.000
デフォルトでは、アプリのGPUトレースをキャプチャすると、Xcodeがトレースをプロファイリングします。

00:10:20.000 --> 00:10:26.000
そして、キャプチャ時にデバイスがいたのと同じパフォーマンス状態を使用してそうします。

00:10:26.000 --> 00:10:31.000
前述の要因によっては、その状態が変動した可能性があります。

00:10:31.000 --> 00:10:39.000
代わりに、特定のパフォーマンス状態を自分で選択したい場合は、デバッグバーのストップウォッチボタンを使用します。

00:10:39.000 --> 00:10:44.000
選択後、Metal DebuggerはGPUトレースを再度プロファイリングします。

00:10:44.000 --> 00:10:51.000
完了後、一貫したパフォーマンス状態が達成されたことを反映してボタンが強調表示されます。

00:10:51.000 --> 00:11:00.000
また、サマリーページの「パフォーマンス」セクションには、新しいパフォーマンスデータと選択したパフォーマンス状態が一目で表示されるようになりました。

00:11:00.000 --> 00:11:04.000
これら2つのアプローチは、一連の金属工具に結びついています。

00:11:04.000 --> 00:11:10.000
しかし、時には、プロファイリングワークフローの外で一貫したパフォーマンス状態を誘導したいと思うかもしれません。

00:11:10.000 --> 00:11:17.000
GPUのパフォーマンス状態を設定する3番目の方法は、デバイス条件です。

00:11:17.000 --> 00:11:24.000
異なるGPUパフォーマンス状態でアプリがどのように機能するかをテストしたい場合は、これがあなたのためのオプションです。

00:11:24.000 --> 00:11:30.000
Xcode 13では、GPUのパフォーマンス状態のデバイス条件を追加しました。

00:11:30.000 --> 00:11:39.000
オペレーティングシステムは、デバイスを維持し、Xcodeに接続したままである限り、デバイス上で指定された状態を使用することを強制します。

00:11:39.000 --> 00:11:54.000
Xcodeからこの条件を追加できます。ウィンドウ、デバイス、シミュレータに移動し、そこでデバイスを選択し、「デバイス条件」セクションまでスクロールして、目的のレベルで「GPUパフォーマンス状態」条件を追加します。

00:11:54.000 --> 00:11:59.000
GPUのパフォーマンス状態の変更をデバイスに適用する場合は、[スタート]を押します。

00:11:59.000 --> 00:12:03.000
その後、完了したら、停止を押します。

00:12:03.000 --> 00:12:11.000
当社のツールから直接GPUのパフォーマンス状態を確認および変更するこれらの新しい方法は、アプリのプロファイリングとテストに役立つはずです。

00:12:11.000 --> 00:12:20.000
そして、プロファイリングワークフローへの最新の追加と改善を気に入っていただけると思います。アプリをさらに良くするのに役立つことを願っています。

00:12:20.000 --> 00:12:26.000
さて、今年Metal Debuggerにもたらす他のいくつかの改善について話しましょう。

00:12:26.000 --> 00:12:31.000
まず、シェーダー検証の改善についてお話しします。

00:12:31.000 --> 00:12:34.000
次に、正確なキャプチャコントロールをお見せします。

00:12:34.000 --> 00:12:40.000
その後、新しいパイプライン状態のワークフローを見ていきます。

00:12:40.000 --> 00:12:50.000
最後に、シェーダーのデバッグとプロファイリング、別々のデバッグ情報と選択的なシェーダーのデバッグに関連する2つの新機能を紹介したいと思います。

00:12:50.000 --> 00:13:02.000
昨年、Xcode 12では、範囲外のアクセスなど、GPUのランタイムエラーを診断するのに役立つシェーダー検証を導入しました。

00:13:02.000 --> 00:13:19.000
シェーダーの検証が有効になっていて、エンコーダが検証エラーを発生させると、問題ナビゲーターでランタイムの問題が発生し、障害が発生したコールのCPUとGPUの両方のバックトレースが表示されることを覚えておいてください。

00:13:19.000 --> 00:13:46.000
私たちはすでにこれをより詳細にカバーするセッションを持っているので、シェーダー検証の使用の詳細については、「MetalのGPU側エラーのデバッグ」と呼ばれる昨年の講演をチェックしてください。今年は、より多くのユースケースをサポートするためにシェーダーの検証を拡張し、間接コマンドバッファ、動的ライブラリ、関数ポインタとテーブルを使用しているときに利用できるようにします。

00:13:46.000 --> 00:13:53.000
これにより、開発中にアプリ全体でシェーダー検証をより広範囲に使用できるはずです。

00:13:53.000 --> 00:13:58.000
次に、新しい正確なキャプチャコントロールをお見せしたいと思います。

00:13:58.000 --> 00:14:04.000
しかし、まず、メタルのロゴのように見えるキャプチャボタンを見てください。

00:14:04.000 --> 00:14:09.000
これは、Xcodeウィンドウの下部にあるデバッグバーにあります。

00:14:09.000 --> 00:14:12.000
クリックすると、新しいメニューが表示されます。

00:14:12.000 --> 00:14:16.000
このメニューでは、キャプチャのスコープを選択できます。

00:14:16.000 --> 00:14:23.000
デフォルトは1つのフレームをキャプチャすることですが、キャプチャするフレーム数を最大5つまで指定できます。

00:14:23.000 --> 00:14:42.000
また、同じ親デバイスまたはコマンドキューを持つ多数のコマンドバッファ、特定のメタルレイヤーを提示するコマンドバッファ、さらにはMTLCaptureScope APIを使用してアプリのコードで定義できるカスタムスコープをキャプチャすることもできます。

00:14:42.000 --> 00:14:51.000
これらの新しいコントロールは、メタルコールがいつどのようにキャプチャされるかを決定する際に、すぐに使える信じられないほどのパワーを提供します。

00:14:51.000 --> 00:14:56.000
次に、金属ライブラリとパイプラインの状態について話しましょう。

00:14:56.000 --> 00:15:00.000
これらはあなたのMetalアプリの不可欠な構成要素です。

00:15:00.000 --> 00:15:07.000
また、Xcode 13では、アプリが使用しているすべてのパイプラインの状態とライブラリを調べることがこれまで以上に簡単になりました。

00:15:07.000 --> 00:15:11.000
さて、それが実際にどのように見えるか見てみましょう。

00:15:11.000 --> 00:15:16.000
ここでは、ModernRendererのサンプルアプリからGPUトレースをキャプチャしました。

00:15:16.000 --> 00:15:23.000
GBufferパイプラインの状態がどのように機能するかを見たかったので、このドローコールを選択しました。

00:15:23.000 --> 00:15:28.000
バインドされたリソースを見ると、使用されたパイプラインの状態がわかります。

00:15:28.000 --> 00:15:32.000
それを開くと、パイプラインステートビューアに移動します。

00:15:32.000 --> 00:15:39.000
ここから、関数を調べて、パイプライン状態が作成された他のプロパティを見ることができます。

00:15:39.000 --> 00:15:49.000
さらに、ビューアから、状態に関連するパフォーマンスデータをチェックするか、メモリビューアに移動して状態を明らかにすることができます。

00:15:49.000 --> 00:15:57.000
Xcode 13では、メモリビューアが、パイプライン状態がアプリでどれだけのメモリを消費しているかを表示するようになりました。

00:15:57.000 --> 00:16:06.000
これらは、アプリのGPUトレースを見ているときに、メタルデバッガ全体のパイプライン状態を簡単に検査できる追加のほんの一部です。

00:16:06.000 --> 00:16:11.000
次に、Metal Debuggerでのシェーダーのデバッグとプロファイリングについて話しましょう。

00:16:11.000 --> 00:16:16.000
現在、これらの機能を使用したい場合は、2つの選択肢があります。

00:16:16.000 --> 00:16:21.000
最初のオプションは、アプリの実行中にソースコードからライブラリをコンパイルすることです。

00:16:21.000 --> 00:16:30.000
2番目のより良い選択肢は、ソースがオフラインで埋め込まれたMetallibファイルを構築し、実行時にそれらをロードすることです。

00:16:30.000 --> 00:16:37.000
しかし、その後、App Storeのルールでは、これらのデバッグMetallibsでアプリを公開することはできません。

00:16:37.000 --> 00:16:54.000
つまり、ライブラリをオフラインでコンパイルし、シェーダーをデバッグできるようにしたい場合は、2回コンパイルする必要があります。1回はソースが埋め込まれており、開発中に使用するため、もう1回はソースなしで配布用です。

00:16:54.000 --> 00:16:57.000
今年、私たちはそれを変えています。

00:16:57.000 --> 00:17:03.000
Metallibをコンパイル中に、ソースやその他のデバッグ情報を含む別のファイルを生成できるようになりました。

00:17:03.000 --> 00:17:14.000
これらのファイルにはMetallibsym拡張子があり、ライブラリ自体に追加情報を埋め込むことなく、シェーダーをデバッグしてプロファイルすることができます。

00:17:14.000 --> 00:17:21.000
それらを別々に持つことの最も重要な利点は、同じMetallibの2つのバージョンを持つ必要がないことです。

00:17:21.000 --> 00:17:34.000
もう1つの利点は、これらのMetallibsymファイルを使用すると、シェーダーソースを危険にさらすことなく、アプリのリリースバージョンでもシェーダーをデバッグできることです。

00:17:34.000 --> 00:17:42.000
シェーダーソースファイルをMetallibsymファイルと一緒にMetallibにコンパイルする方法の例を紹介します。

00:17:42.000 --> 00:17:48.000
通常どおりMetallibをコンパイルするxcrunターミナルコマンドから始めます。

00:17:48.000 --> 00:17:58.000
Metallibsymファイルを生成するには、「フラット」オプションでフラグ「レコードソース」を追加し、コンパイラを実行するだけです。

00:17:58.000 --> 00:18:07.000
さて、別のデバッグ情報ファイルでコンパイルされたシェーダーをデバッグしようとすると、インポートするように求められます。

00:18:07.000 --> 00:18:15.000
ソースのインポートをクリックすると、すべてのライブラリとソースファイルをインポートしたかどうかを一覧表示するダイアログが開きます。

00:18:15.000 --> 00:18:25.000
ここから、任意のMetallibsymファイルをインポートでき、インポートすると、ライブラリとそのソースが自動的に一致します。

00:18:25.000 --> 00:18:34.000
インポートが完了したら、ダイアログを閉じることができ、シェーダーのソースを確認してデバッグできます。

00:18:34.000 --> 00:18:38.000
あなたに見せたい最後のデバッグの改善があります。

00:18:38.000 --> 00:18:48.000
それは「選択的シェーダーデバッグ」と呼ばれています。アプリが大きなシェーダーを使用している場合、シェーダーのデバッグの開始に時間がかかる可能性があることに気付いたかもしれません。

00:18:48.000 --> 00:18:53.000
そのような場合を支援するために、今年は選択的なシェーダーデバッグをもたらします。

00:18:53.000 --> 00:18:59.000
デバッグスコープを絞り込むのに役立つので、シェーダーをより迅速にデバッグできます。

00:18:59.000 --> 00:19:03.000
このような大きなシェーダーの1つで実際に見てみましょう。

00:19:03.000 --> 00:19:08.000
このGPU ASTCDecoderをデバッグしたいと思います。

00:19:08.000 --> 00:19:14.000
このカーネル全体をデバッグしようとすると、シェーダーデバッガの起動に長い時間がかかることを知っています。

00:19:14.000 --> 00:19:23.000
そんなに長く待ちたくないので、代わりに、デバッグスコープをこの関数、decodeIntegerSequenceだけに絞り込むことができます。

00:19:23.000 --> 00:19:28.000
これを行うには、右クリックして「デバッグ関数」を選択できます。

00:19:28.000 --> 00:19:33.000
これにより、「デバッグする関数」メニューが開き、関数スコープがすでに選択されています。

00:19:33.000 --> 00:19:40.000
これで、デバッガはほぼ瞬時に起動します。

00:19:40.000 --> 00:19:45.000
選択的なシェーダーデバッグは、巨大なシェーダーのバグをすばやく特定する素晴らしい方法です。

00:19:45.000 --> 00:19:50.000
これらはすべて、私が今日お見せしたかった金属工具の改善です。

00:19:50.000 --> 00:19:54.000
そして今、アマンダは私たちがテクスチャ圧縮で成し遂げた進歩についてあなたに話します。

00:19:54.000 --> 00:19:56.000
アマンダ？

00:19:56.000 --> 00:19:57.000
ありがとう、エゴール。

00:19:57.000 --> 00:20:02.000
テクスチャ圧縮ツールに今年行ったアップデートを順を追って説明します。

00:20:02.000 --> 00:20:08.000
ツールに飛び込む前に、Appleプラットフォームでのテクスチャ圧縮の基本について簡単に説明します。

00:20:08.000 --> 00:20:13.000
テクスチャ圧縮は、この場合、テクスチャデータの固定レート、損失圧縮です。

00:20:13.000 --> 00:20:19.000
これは主に、デカールやノーマルマップなどの静的テクスチャデータのオフライン圧縮を目的としています。

00:20:19.000 --> 00:20:24.000
実行時に動的テクスチャデータを圧縮できますが、それは私が今日カバーしているものではありません。

00:20:24.000 --> 00:20:31.000
ほとんどのテクスチャ圧縮は、テクスチャをブロックに分割し、各ブロックを色のペアとして圧縮することで機能します。

00:20:31.000 --> 00:20:38.000
このペアは、これらのエンドポイントから補間された他の色を含むローカライズされたパレットと、このパレットから選択するピクセルごとのインデックスを定義します。

00:20:38.000 --> 00:20:43.000
各フォーマットには、異なる種類のテクスチャデータに適した異なる強みがあります。

00:20:43.000 --> 00:20:50.000
Apple GPUは、A12デバイスからロスレスフレームバッファ圧縮もサポートしており、帯域幅の最適化に最適です。

00:20:50.000 --> 00:20:58.000
GPUがアプリに使用しているメモリ帯域幅の測定の詳細については、昨年のセッション「GPUカウンタでMetalアプリとゲームを最適化する」をご覧ください。

00:20:58.000 --> 00:21:07.000
もう1つのオプションは、このプレゼンテーションで取り上げているGPUテクスチャ圧縮の上にテクスチャファイルのロスレス圧縮を実行することです。

00:21:07.000 --> 00:21:11.000
これにより、アプリのダウンロードのサイズをさらに削減できます。

00:21:11.000 --> 00:21:17.000
この講演のためにテクスチャ圧縮を定義したので、テクスチャ圧縮がアプリにもたらす利点について話します。

00:21:17.000 --> 00:21:21.000
テクスチャ圧縮は、アプリの開発における重要なステップです。

00:21:21.000 --> 00:21:26.000
一般的に、ゲームのメモリフットプリントのほとんどはテクスチャで構成されています。

00:21:26.000 --> 00:21:34.000
テクスチャ圧縮を使用すると、より多くのテクスチャをメモリにロードし、より詳細なテクスチャを使用して、より視覚的に魅力的なゲームを作成できます。

00:21:34.000 --> 00:21:39.000
圧縮により、アプリのサイズとメモリフットプリントを削減することもできます。

00:21:39.000 --> 00:21:45.000
基本を説明したので、Appleプラットフォームのテクスチャ圧縮ツールの現状について説明します。

00:21:45.000 --> 00:21:50.000
iOS SDKの既存のTextureToolには、比較的シンプルなパイプラインがあります。

00:21:50.000 --> 00:21:59.000
TextureToolは、入力画像を読み取り、必要に応じてミップマップを生成し、テクスチャを圧縮し、ブロックごとにブロックし、結果を新しい出力ファイルに書き込みます。

00:21:59.000 --> 00:22:05.000
しかし、グラフィックアルゴリズムの複雑さが増すにつれて、テクスチャはより高度な処理が必要です。

00:22:05.000 --> 00:22:14.000
これらのプロセスの中核は、数値精度間の変換からの丸めを最小限に抑えながら、正しい色空間で操作を実行することです。

00:22:14.000 --> 00:22:24.000
これを理解して、テクスチャ処理の洗練さの必要な増加を処理し、多くの新しいオプションにアクセスできるように、TextureConverterと呼ばれる新しい圧縮ツールを設計しました。

00:22:24.000 --> 00:22:31.000
Appleプラットフォームのテクスチャ処理パイプラインをどのように刷新したかを詳しく見てみましょう。 見てみましょう。

00:22:31.000 --> 00:22:39.000
テクスチャ処理パイプラインは、TextureConverterでフル機能のテクスチャ処理パイプラインにアクセスできるように、ゼロから再構築されました。

00:22:39.000 --> 00:22:50.000
TextureConverterは、業界で認められた一連のコンプレッサーを活用して、幅広い圧縮フォーマットをサポートし、圧縮速度と画質をトレードオフするオプションを提供します。

00:22:50.000 --> 00:22:58.000
使用するコンプレッサーを指定するか、圧縮形式、品質レベル、その他のオプションに基づいてTextureConverterを選択できるようにしたりできます。

00:22:58.000 --> 00:23:04.000
各ステージはあなたによって完全に設定可能になり、テクスチャ処理はガンマ認識です。

00:23:04.000 --> 00:23:13.000
すべてのコンテンツパイプラインへの統合をサポートするために、TextureConverterはmacOSとWindowsの両方で利用でき、Apple Siliconでの使用に最適化されています。

00:23:13.000 --> 00:23:17.000
ガンマから始めて、拡張されたパイプラインの各段階をステップスルーしましょう。

00:23:17.000 --> 00:23:22.000
ガンマ補正は、画像の輝度をエンコードおよびデコードする非線形操作です。

00:23:22.000 --> 00:23:25.000
テクスチャは多くのガンマ空間でエンコードできます。

00:23:25.000 --> 00:23:29.000
最良の選択は、テクスチャが表すデータの種類に依存します。

00:23:29.000 --> 00:23:36.000
デカールやライトマップなどのほとんどの視覚データは、sRGBのような非線形空間でエンコードされている場合に最適です。

00:23:36.000 --> 00:23:41.000
非視覚データは、通常のマップと同様に、線形空間でエンコードする必要があります。

00:23:41.000 --> 00:23:45.000
この選択により、必要な暗い領域での精度が向上します。

00:23:45.000 --> 00:23:49.000
非視覚データは、通常のマップと同様に、線形空間でエンコードする必要があります。

00:23:49.000 --> 00:23:55.000
圧縮は、「gamma_in」と「gamma_out」オプションで指定されたターゲット色空間で実行する必要があります。

00:23:55.000 --> 00:24:03.000
線形ガンマ空間の浮動小数点数を入力するか、文字列「sRGB」を使用してその色空間を指定できます。

00:24:03.000 --> 00:24:08.000
また、これらのオプションを使用して別のターゲットスペースに変換する柔軟性もあります。

00:24:08.000 --> 00:24:13.000
ミップマップ生成などの他の操作は、線形空間で実行する必要があります。

00:24:13.000 --> 00:24:17.000
今から線形空間処理の段階を歩きます。

00:24:17.000 --> 00:24:26.000
入力が線形ガンマ空間に変換されたので、入力テクスチャが指定されたターゲットガンマ空間に変換される前に、線形空間操作が実行されます。

00:24:26.000 --> 00:24:34.000
3つのステージは、物理変換、ミップマップ生成、アルファ処理であり、これらのいくつかにはサブステージがあります。

00:24:34.000 --> 00:24:36.000
物理的な変換から始めます。

00:24:36.000 --> 00:24:43.000
任意の軸の最大サイズを定義することで、トップレベルのミップマップの必要に応じて画像を縮小できます。

00:24:43.000 --> 00:24:48.000
この段階では、サイズ変更フィルターとサイズ変更の丸めモードも制御できます。

00:24:48.000 --> 00:24:55.000
サイズ変更フィルターオプションは、さまざまなアルゴリズムを使用して、ディメンションサイズが下がるミップマップのぼやけを減らすのに役立ちます。

00:24:55.000 --> 00:25:01.000
サイズ変更ラウンドモードは、画像のサイズを変更するときにmax_extentと組み合わせて使用されます。

00:25:01.000 --> 00:25:07.000
Max_extentを超えると、元の画像のアスペクトを維持することで、ソース画像のサイズが変更されます。

00:25:07.000 --> 00:25:11.000
ターゲットの寸法を見つけるときに、指定されたラウンドモードが使用されます。

00:25:11.000 --> 00:25:19.000
どのサイズ変更フィルターまたは丸めモードを使用するかわからない場合は、ほとんどの場合、うまく機能するデフォルトを選択しました。

00:25:19.000 --> 00:25:27.000
また、この段階の反転オプションを使用すると、X軸、Y軸、およびZ軸の線形変換を制御できます。

00:25:27.000 --> 00:25:34.000
変換後はミップマップ生成であり、一般的なテクスチャ処理状況の大部分で使用されます。

00:25:34.000 --> 00:25:43.000
Mipmapsは、レンダリング速度を高め、エイリアシングを減らすために使用される、シーケンスよりも解像度を低下させる、事前に計算された画像のシーケンスです。

00:25:43.000 --> 00:25:48.000
各レベルの高さと幅は、前のレベルよりも2つ小さいパワーです。

00:25:48.000 --> 00:25:55.000
Mipmap生成をカスタマイズするときは、必要な最大数と使用するmipフィルタを指定します。

00:25:55.000 --> 00:26:03.000
TextureConverterのデフォルトはKaiserフィルタリングで、「ボックス」と「トライアングル」フィルタリングのオプションがあります。

00:26:03.000 --> 00:26:08.000
線形空間処理の最終段階はアルファ処理です。

00:26:08.000 --> 00:26:15.000
アルファからカバレッジが有効になっている場合、指定されたアルファ参照値を使用して、これが最初に適用されます。

00:26:15.000 --> 00:26:18.000
アルファ・トゥ・カバレッジは、アルファブレンドをカバレッジマスクに置き換えます。

00:26:18.000 --> 00:26:29.000
アンチエイリアスまたは半透明のテクスチャを使用すると、注文に依存しない透明度が得られ、ゲームで密集した緑をレンダリングするのに特に便利なツールです。

00:26:29.000 --> 00:26:36.000
その後、アルファチャンネルを破棄、保存、または事前乗算するオプションが表示されます。

00:26:36.000 --> 00:26:44.000
事前に乗算されたアルファでは、画像の部分的に透明なピクセルがマットカラーで事前に乗算されます。

00:26:44.000 --> 00:26:52.000
線形空間処理段階の終わりに、ターゲットのガンマ空間に戻り、処理されたミップレベルを圧縮する準備が整いました。

00:26:52.000 --> 00:26:55.000
テクスチャ処理の最後のステップは圧縮です。

00:26:55.000 --> 00:27:01.000
圧縮段階は、チャネルマッピングとエンコーディングの2つのサブステージに分けることができます。

00:27:01.000 --> 00:27:08.000
チャネルマッピングは、特定のデータ型に対して汎用テクスチャ圧縮アルゴリズムを最適化する手法です。

00:27:08.000 --> 00:27:11.000
TextureConverterでチャンネルマッピングを指定することはオプションです。

00:27:11.000 --> 00:27:19.000
使用したい場合、TextureConverterは現在、チャネルマッピングの2つのモード、RGBMエンコーディングとノーマルマップエンコーディングをサポートしています。

00:27:19.000 --> 00:27:24.000
RGBMエンコーディングから始めて、これらのフォーマットの両方をより深くカバーします。

00:27:24.000 --> 00:27:35.000
RGBMエンコーディングは、アルファチャンネルに乗数を格納し、この乗数でRGBチャンネルをスケーリングすることにより、LDR形式でHDRデータを圧縮する手法です。

00:27:35.000 --> 00:27:38.000
これは教室のHDR画像の例です。

00:27:38.000 --> 00:27:44.000
そして、これは再び同じ教室の画像で、アルファチャンネルに保存された乗数がグレースケールで表示されます。

00:27:44.000 --> 00:27:49.000
コード例を使って、RGBMにエンコードする乗数を計算する方法を紹介します。

00:27:49.000 --> 00:27:57.000
EncodeRGBMは、RGBMへのエンコーディングの仕組みを理解するのに役立つ簡略化された疑似コード関数です。

00:27:57.000 --> 00:28:05.000
このスニペットには、RGBMの範囲を設定するためのまったく新しいパラメータであるRGBM_Rangeの使用が含まれており、デフォルトは6.0です。

00:28:05.000 --> 00:28:15.000
RGBMアルファ値、乗数を計算するために、まず、入力テクスチャの赤、緑、青のチャンネルの最大値を決定します。

00:28:15.000 --> 00:28:18.000
これはMetalのmax3機能で行われます。

00:28:18.000 --> 00:28:21.000
次に、この最大値はRGBM_Rangeで割ります。

00:28:21.000 --> 00:28:36.000
エンコードされたRGBMの赤、緑、青のチャンネル値を計算するために、まず、以前に計算された乗数にRGBM_Rangeを掛け、アルファチャンネルのストレージの値をスケーリングするために使用します。

00:28:36.000 --> 00:28:41.000
次に、入力テクスチャを最終的な乗数値で割ります。

00:28:41.000 --> 00:28:49.000
シェーダーでRGBMをデコードするには、エンコーディング機能で示したように、サンプルのRGBにアルファと固定係数を掛けます。

00:28:49.000 --> 00:28:53.000
DecodeRGBMコードスニペットを見て、これを行う方法を紹介します。

00:28:53.000 --> 00:29:02.000
スケーリング係数は、乗数が格納されているRGBMアルファチャネルにRGBM_Rangeを乗じて再計算されます。

00:29:02.000 --> 00:29:09.000
元のテクスチャのRGBは、RGBMサンプルに計算された乗数を掛けて計算されます。

00:29:09.000 --> 00:29:14.000
RGBMエンコーディングを紹介したので、通常のマップエンコーディングに移ります。

00:29:14.000 --> 00:29:20.000
ほとんどの場合、正規マップを参照するときは、特にオブジェクト空間正規マップを参照しています。

00:29:20.000 --> 00:29:31.000
オブジェクト空間で法線をエンコードする場合、各法線は単位ベクトルであり、実行時に3番目の軸で2つの軸で表現できるという利点があります。

00:29:31.000 --> 00:29:42.000
これにより、これら2つのチャネルを再マッピングして、テクスチャ圧縮アルゴリズムを最大限に活用し、XYZをRGBとして圧縮するよりも優れた圧縮品質を実現できます。

00:29:42.000 --> 00:29:45.000
チャンネルの再マップ方法は、圧縮形式によって異なります。

00:29:45.000 --> 00:29:51.000
このチャートをガイドとして、ASTCでノーマルをエンコードする例を見ていきます。

00:29:51.000 --> 00:30:00.000
ASTCでエンコードする場合、赤、緑、青のチャンネルはXコンポーネントに設定され、アルファチャンネルはYコンポーネントに設定されます。

00:30:00.000 --> 00:30:07.000
色は、エンコードされた法線をサンプリングするときに、X成分とY成分が再割り当てされるチャネルに対応します。

00:30:07.000 --> 00:30:16.000
TextureConverterは、通常のマップパラメータを渡すと、選択した形式に自動的に再マッピングすることで、エンコーディングの再マッピングを処理します。

00:30:16.000 --> 00:30:21.000
シェーダーでノーマルマップをサンプリングするときは、チャンネルマッピングを知ることが重要です。

00:30:21.000 --> 00:30:29.000
Xコンポーネントは赤またはアルファチャンネルから読み取られますが、Yコンポーネントは圧縮形式に応じてアルファまたは緑のチャンネルから来ます。

00:30:29.000 --> 00:30:41.000
ASTCの例に戻ると、テクスチャをサンプリングするために、Xコンポーネントは赤いチャンネルからサンプリングされ、Yコンポーネントはアルファチャンネルからサンプリングされ、通常のエンコード方法の逆です。

00:30:41.000 --> 00:30:49.000
任意のデバイスで可能な限り最高の品質を達成するために複数のフォーマットにエンコードしている場合、このマッピングは実行時に処理する必要があります。

00:30:49.000 --> 00:30:55.000
メタルテクスチャスウィズルを使用したランタイムノーマルサンプリングの例を見ていきます。

00:30:55.000 --> 00:31:02.000
複数のフォーマットへのエンコードは、異なるフォーマットが異なるチャネルマッピングを使用している場合、複数のシェーダーバリアントが必要になる可能性があります。

00:31:02.000 --> 00:31:07.000
これを避けるために、Metalを使用すると、テクスチャにカスタムスウィズルを適用できます。

00:31:07.000 --> 00:31:14.000
Swizzlesを使用すると、XとYのコンポーネントを赤と緑のチャンネルに再マップできるため、シェーダーは圧縮フォーマットをニュートラルにすることができます。

00:31:14.000 --> 00:31:22.000
以前の図で見たように、ASTCで圧縮された通常のマップのチャンネルを赤と緑に再マッピングする例を次に示します。

00:31:22.000 --> 00:31:32.000
テクスチャ記述子が初期化された後、赤いチャンネルはMTLTextureSwizzleRedに設定され、緑のチャンネルはMTLTextureSwizzleAlphaに設定されます。

00:31:32.000 --> 00:31:36.000
これは通常のマップであるため、サンプリングに必要なチャンネルは2つだけです。

00:31:36.000 --> 00:31:46.000
赤と緑のチャンネルは、もともと赤とアルファチャンネルにエンコードされたXとYコンポーネントに割り当てられるようになったため、青とアルファチャンネルはゼロに設定されています。

00:31:46.000 --> 00:31:55.000
それが完了したら、最後の行は、MTLTextureSwizzleChannelsMakeを使用して、再マップされたチャンネルで最終的なスウィズルを組み立てることです。

00:31:55.000 --> 00:32:00.000
XチャンネルとYチャンネルがシェーダーでサンプリングされたら、Zコンポーネントを再構築できます。

00:32:00.000 --> 00:32:06.000
ReconstructNormal関数を順を追って説明します。

00:32:06.000 --> 00:32:14.000
まず、コードはXとYのコンポーネントを正しい範囲に再バイアスします。これは、通常の1対1の負です。

00:32:14.000 --> 00:32:23.000
次のステップは、ドット積の結果が正しい符号を持っていることを確認するために、X成分とY成分のドット積を1つから減算することです。

00:32:23.000 --> 00:32:29.000
その後、飽和関数は、この結果を0から1の範囲内にクランプするために使用されます。

00:32:29.000 --> 00:32:36.000
Z成分を計算する最後のステップは、飽和関数の出力の平方根を取ることです。

00:32:36.000 --> 00:32:48.000
チャネルマッピングで利用可能なRGBMとノーマルマップエンコーディングオプションを説明したので、最終的な圧縮サブステートであるエンコーディングでテクスチャ圧縮パイプラインの議論を終了します。

00:32:48.000 --> 00:32:55.000
すべてのTextureConverterコマンドラインでは、compression_format引数を持つターゲット圧縮フォーマットの指定が必要です。

00:32:55.000 --> 00:33:04.000
また、使用するコンプレッサーを指定したり、選択した圧縮形式やその他のオプションに基づいてTextureConverterに選択させたりすることもできます。

00:33:04.000 --> 00:33:08.000
これらの4つのオプションから圧縮品質を選択することもできます。

00:33:08.000 --> 00:33:20.000
圧縮速度と画質の間にはトレードオフがあり、ゲームを反復しながらより低い圧縮品質を選択したいと思うかもしれませんが、リリースされたビルドには最高の品質を使用してください。

00:33:20.000 --> 00:33:25.000
さて、あなたが選択できるテクスチャ圧縮フォーマットについて説明します。

00:33:25.000 --> 00:33:30.000
以下は、Appleプラットフォームでサポートされているテクスチャ圧縮フォーマットファミリーの概要です。

00:33:30.000 --> 00:33:40.000
iOSとApple SiliconプラットフォームはASTCとPVRTCファミリーをサポートし、すべてのmacOSプラットフォームはBCnファミリーをサポートしています。

00:33:40.000 --> 00:33:46.000
これらのフォーマットファミリーのそれぞれをより詳細に説明し、ニーズに最適なものを選択するのに役立つガイドラインを提供します。

00:33:46.000 --> 00:33:49.000
BCn形式から始めます。

00:33:49.000 --> 00:33:58.000
BCnは、すべて4×4ブロックのピクセルを使用して動作し、ピクセルあたり4ビットまたは8ビットを使用する7つのフォーマットのセットです。

00:33:58.000 --> 00:34:02.000
各圧縮形式は、異なるデータ形式に最適です。

00:34:02.000 --> 00:34:16.000
BC1とBC3はRGBとRGBAの圧縮に一般的に使用され、BC6はHDR画像に理想的であり、デュアル独立チャンネルを備えたBC5は、通常のマップエンコーディングに最適です。

00:34:16.000 --> 00:34:25.000
次は、LDR、sRGB、HDR色空間のRGBAフォーマットのファミリーであるASTCです。

00:34:25.000 --> 00:34:33.000
ASTCファミリのフォーマットは、すべてのサイズで最高の品質を可能にするため、PVRTCよりも一般的に推奨されます。

00:34:33.000 --> 00:34:37.000
各フォーマットには、ピクセルごとのビット数と品質の範囲があります。

00:34:37.000 --> 00:34:45.000
ASTCでは、各ブロックのバイトサイズはフォーマットに関係なく同じですが、表すテクセルの数は異なります。

00:34:45.000 --> 00:34:58.000
これにより、最高品質の圧縮が、4×4のブロックサイズで最低の圧縮率と、12×12のブロックサイズで最低の圧縮品質が最高の圧縮率の間の連続性が得られます。

00:34:58.000 --> 00:35:05.000
LDR、sRGB、およびHDRバリアントは、圧縮されたASTCテクスチャの色範囲を記述します。

00:35:05.000 --> 00:35:17.000
LDRとsRGBはどちらもリニアまたはsRGB空間のいずれかで0対1の範囲にあり、HDRバリアントは0対1の範囲外のデータ用です。

00:35:17.000 --> 00:35:24.000
最後に、PVRTCフォーマットは、2ビットまたは4ビットモードでRGBとRGBAで利用できます。

00:35:24.000 --> 00:35:36.000
この形式のデータブロックは常に8バイトを占めるため、2ビットモードでは8×4ピクセルごとに1つのブロックがあり、4ビットモードでは4×4ピクセルごとに1つのブロックがあります。

00:35:36.000 --> 00:35:43.000
サポートされているフォーマットファミリーを紹介したので、アプリのフォーマットを選択するための推奨事項をいくつか紹介します。

00:35:43.000 --> 00:35:55.000
iOSデバイスでは、A7 GPU以前をサポートしている場合にのみ、常にASTC圧縮を使用し、PVRTC圧縮とデバイスごとのシンニングを追加する必要があります。

00:35:55.000 --> 00:36:04.000
HDRテクスチャがある場合は、A13以降のGPUでASTC HDRを利用できます。

00:36:04.000 --> 00:36:08.000
macOSの場合、BCnは全面的に利用可能です。

00:36:08.000 --> 00:36:16.000
Apple Silicon Macでは、ASTCを使用するオプションもあり、iOSデバイスもターゲットにしている場合は、このオプションを検討する必要があります。

00:36:16.000 --> 00:36:24.000
PVRTCはApple Siliconで利用できますが、このオプションはお勧めしません。また、iOSのレガシーサポートのみを対象としています。

00:36:24.000 --> 00:36:36.000
各圧縮フォーマットファミリにはさまざまなフォーマットがあるため、アプリに最も効果的なテクスチャ圧縮フォーマットを選択するためのガイドラインは、可能な限りテクスチャごととターゲットごとを選択することです。

00:36:36.000 --> 00:36:49.000
すべてのテクスチャがRGBまたはRGBAデータでない限り、通常のデータの2つの独立したチャネルとして圧縮を可能にするフォーマットを選択するなど、圧縮するデータの種類に基づいて圧縮フォーマットを選択する必要があります。

00:36:49.000 --> 00:36:54.000
ASTC形式に圧縮するときは、形式のサブセットを選択することをお勧めします。

00:36:54.000 --> 00:37:02.000
より高い圧縮率で受け入れられるものと比較して、最高の品質を必要とするテクスチャをバケット化することを検討してください。

00:37:02.000 --> 00:37:04.000
さて、私たちがカバーした内容を見直しましょう。

00:37:04.000 --> 00:37:13.000
新しいTextureConverterツールを使用して、パイプラインのすべての段階を完全に制御するために、TextureToolからテクスチャ処理パイプラインを完全にリメイクしました。

00:37:13.000 --> 00:37:25.000
この新しいパイプラインの各段階を歩き、各段階で使用できるすべてのオプションを検討し、Appleプラットフォームでサポートされているチャネルマッピングとテクスチャ圧縮フォーマットファミリを紹介しました。

00:37:25.000 --> 00:37:35.000
TextureToolからTextureConverterへのワークフローをできるだけ簡単に更新できるようにしたいので、コマンドラインを切り替えるのに役立つ互換性モードを追加しました。

00:37:35.000 --> 00:37:44.000
TextureTool互換モードを使用するか、ネイティブオプションでTextureConverterを呼び出すかにかかわらず、xcrun TextureConverterで呼び出します。

00:37:44.000 --> 00:37:49.000
これは、TextureToolオプションで呼び出されるTextureConverterのコマンドラインの例です。

00:37:49.000 --> 00:38:01.000
TextureConverterは、オプションをネイティブのTextureConverterオプションに変換し、圧縮を行い、新しいネイティブオプションが何であるかを伝えるので、ビルドスクリプトを簡単に更新できます。

00:38:01.000 --> 00:38:03.000
それはTextureConverterの紹介でした。

00:38:03.000 --> 00:38:04.000
それを手に入れる方法は次のとおりです。

00:38:04.000 --> 00:38:10.000
TextureConverterはXcode 13の一部として出荷され、シード1で使用できます。

00:38:10.000 --> 00:38:19.000
Windowsでは、TextureConverterは、developer.apple.comから入手できるMetal Developer Tools for Windows 2.0パッケージの一部として出荷されます。

00:38:19.000 --> 00:38:21.000
シード1は現在入手可能です。

00:38:21.000 --> 00:38:32.000
Windowsでは、PVRTCはレガシーiOSプラットフォームをサポートするためにmacOSで利用できるため、PVRTC形式への圧縮はサポートされていないことに注意してください。

00:38:32.000 --> 00:38:37.000
Windows用のMetal Developer Toolsのもう1つの重要な部分は、Windows用のMetalコンパイラです。

00:38:37.000 --> 00:38:44.000
Windows用のMetalコンパイラは昨年導入され、Metal Shading Languageバージョン2.3をサポートしました。

00:38:44.000 --> 00:38:48.000
年間を通してのアップデートは、Xcodeで出荷されたMetalコンパイラへのアップデートを反映しました。

00:38:48.000 --> 00:38:55.000
最新のリリースバージョンは1.2で、Apple Silicon MacでのMetal Shading Languageのサポートが含まれています。

00:38:55.000 --> 00:39:05.000
バージョン2.0のシード1は、Metal Shading Language 2.4のすべての素晴らしい新機能をサポートするようになりました。

00:39:05.000 --> 00:39:12.000
以下は、今日取り上げたすべての要約です。エゴールは、レイトレーシングやファンクションポインタなど、より多くの金属機能のサポートについて議論しました。

00:39:12.000 --> 00:39:23.000
彼は、すべてのAppleプラットフォームでGPUを最大限に活用できるように、GPUタイムラインや一貫したGPUパフォーマンス状態などのまったく新しいプロファイリングワークフローを導入しました。

00:39:23.000 --> 00:39:31.000
そして、シェーダーの検証と正確なキャプチャコントロールをよりサポートするために、すでに慣れ親しんでいるデバッグワークフローの改善を実証しました。

00:39:31.000 --> 00:39:43.000
そして、テクスチャ処理パイプラインとAppleプラットフォームで利用可能なサポートされているすべてのテクスチャ圧縮フォーマットを最大限に活用するのに役立つ新しいツールであるTextureConverterを紹介しました。

00:39:43.000 --> 00:39:46.000
ありがとう、そしてWWDC 2021の素晴らしい残りをお過ごしください。

00:39:46.000 --> 23:59:59.000
[音楽]。

