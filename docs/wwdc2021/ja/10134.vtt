WEBVTT

00:00:01.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:13.000
こんにちは、私はカボンです。後で同僚のジョーが参加します。

00:00:13.000 --> 00:00:19.000
Swift 5.5は、構造化並行性と呼ばれる概念を使用して、並行プログラムを書く新しい方法を導入しています。

00:00:19.000 --> 00:00:30.000
構造化並行性の背後にあるアイデアは、構造化プログラミングに基づいており、直感的であるため、めったに考えませんが、それについて考えることは、構造化並行性を理解するのに役立ちます。

00:00:30.000 --> 00:00:34.000
では、飛び込みましょう。

00:00:34.000 --> 00:00:43.000
コンピューティングの初期には、制御フローがあちこちにジャンプすることを許された一連の命令として書かれていたため、プログラムは読みにくかった。

00:00:43.000 --> 00:00:49.000
言語は構造化プログラミングを使用して制御フローをより均一にするため、今日ではそれが見えません。

00:00:49.000 --> 00:00:54.000
たとえば、if-then ステートメントは構造化されたコントロールフローを使用します。

00:00:54.000 --> 00:01:00.000
ネストされたコードブロックは、上から下に移動している間のみ条件付きで実行されることを指定します。

00:01:00.000 --> 00:01:08.000
Swiftでは、そのブロックは静的スコープも尊重します。つまり、名前は囲むブロックで定義されている場合にのみ表示されます。

00:01:08.000 --> 00:01:15.000
これはまた、ブロックを離れるときに、ブロックで定義された変数の寿命が終了することを意味します。

00:01:15.000 --> 00:01:23.000
したがって、静的スコープを使用した構造化プログラミングにより、制御フローと変数の寿命が理解しやすくなります。

00:01:23.000 --> 00:01:29.000
より一般的には、構造化されたコントロールフローを自然にシーケンスしてネストすることができます。

00:01:29.000 --> 00:01:33.000
これにより、プログラム全体を上から下に読むことができます。

00:01:33.000 --> 00:01:37.000
したがって、これらは構造化プログラミングの基礎です。

00:01:37.000 --> 00:01:42.000
ご想像のとおり、今日の私たちにとってとても直感的なので、当然のことと考えるのは簡単です。

00:01:42.000 --> 00:01:51.000
しかし、今日のプログラムは非同期および同時コードを特徴としており、そのコードを書きやすくするために構造化プログラミングを使用することができませんでした。

00:01:51.000 --> 00:01:56.000
まず、構造化プログラミングが非同期コードをより簡単にする方法を考えてみましょう。

00:01:56.000 --> 00:02:03.000
インターネットからたくさんの画像を取得し、順番にサムネイルになるようにサイズ変更する必要があるとします。

00:02:03.000 --> 00:02:09.000
このコードは非同期に機能し、画像を識別する文字列のコレクションを取り込みます。

00:02:09.000 --> 00:02:13.000
この関数は、呼び出されたときに値を返さないことに気付くでしょう。

00:02:13.000 --> 00:02:18.000
これは、関数が結果またはエラーを与えられた完了ハンドラに渡すためです。

00:02:18.000 --> 00:02:23.000
このパターンにより、発信者は後で回答を受け取ることができます。

00:02:23.000 --> 00:02:29.000
そのパターンの結果として、この関数はエラー処理に構造化制御フローを使用できません。

00:02:29.000 --> 00:02:35.000
それは、関数ではなく、関数から投げ出されたエラーを処理することが理にかなっているからです。

00:02:35.000 --> 00:02:39.000
また、このパターンは、ループを使用して各サムネイルを処理するのを防ぎます。

00:02:39.000 --> 00:02:46.000
関数が完了した後に実行されるコードはハンドラ内にネストする必要があるため、再帰が必要です。

00:02:46.000 --> 00:02:55.000
それでは、以前のコードを見てみましょうが、構造化プログラミングに基づく新しいasync/await構文を使用するように書き換えてみましょう。

00:02:55.000 --> 00:02:59.000
関数から完了ハンドラ引数を削除しました。

00:02:59.000 --> 00:03:04.000
代わりに、その型シグネチャに「async」と「throws」で注釈が付けられます。

00:03:04.000 --> 00:03:07.000
また、何もない代わりに値を返します。

00:03:07.000 --> 00:03:17.000
関数の本体では、「await」を使用して、非同期アクションが発生し、そのアクションの後に実行されるコードにネストは必要ありません。

00:03:17.000 --> 00:03:21.000
これは、サムネイルをループして順番に処理できるようになったことを意味します。

00:03:21.000 --> 00:03:27.000
私はまた、エラーを投げてキャッチすることができ、コンパイラは私が忘れていないことを確認します。

00:03:27.000 --> 00:03:40.000
async/awaitを詳しく見るには、「Swiftでasync/awaitに会う」というセッションをチェックしてください。だから、このコードは素晴らしいですが、何千もの画像のサムネイルを作成している場合はどうなりますか?

00:03:40.000 --> 00:03:44.000
各サムネイルを一度に1つずつ処理することは、もはや理想的ではありません。

00:03:44.000 --> 00:03:50.000
さらに、各サムネイルの寸法は、固定サイズではなく、別のURLからダウンロードする必要がある場合はどうなりますか?

00:03:50.000 --> 00:03:56.000
今、いくつかの並行性を追加する機会があるので、複数のダウンロードが並行して発生する可能性があります。

00:03:56.000 --> 00:04:00.000
プログラムに並行性を追加するための追加のタスクを作成できます。

00:04:00.000 --> 00:04:05.000
タスクは、非同期関数と連携するSwiftの新機能です。

00:04:05.000 --> 00:04:10.000
タスクは、非同期コードを実行するための新しい実行コンテキストを提供します。

00:04:10.000 --> 00:04:14.000
各タスクは、他の実行コンテキストに関して同時に実行されます。

00:04:14.000 --> 00:04:20.000
安全かつ効率的な場合は、自動的に並行して実行するようにスケジュールされます。

00:04:20.000 --> 00:04:26.000
タスクはSwiftに深く統合されているため、コンパイラはいくつかの並行性のバグを防ぐのに役立ちます。

00:04:26.000 --> 00:04:31.000
また、非同期関数を呼び出すと、呼び出しの新しいタスクは作成されないことに注意してください。

00:04:31.000 --> 00:04:34.000
タスクを明示的に作成します。

00:04:34.000 --> 00:04:43.000
構造化された並行性は柔軟性とシンプルさのバランスに関するものであるため、Swiftにはいくつかの異なる種類のタスクがあります。

00:04:43.000 --> 00:04:51.000
したがって、このセッションの残りの部分では、ジョーと私は、トレードオフを理解するのに役立つ各種類のタスクを紹介し、議論します。

00:04:51.000 --> 00:04:58.000
これらのタスクの中で最も簡単なものから始めましょう。これは、async-letバインディングと呼ばれる新しい構文形式で作成されます。

00:04:58.000 --> 00:05:06.000
この新しい構文形式を理解するために、まず通常のレットバインディングの評価を分解したいと思います。

00:05:06.000 --> 00:05:12.000
イコールの右側にイニシャライザ式と左側に変数の名前の2つの部分があります。

00:05:12.000 --> 00:05:18.000
許可の前後に他の声明があるかもしれないので、ここにも含めます。

00:05:18.000 --> 00:05:24.000
Swiftがletバインディングに達すると、その初期化子は値を生成するように評価されます。

00:05:24.000 --> 00:05:30.000
この例では、URLからデータをダウンロードすることを意味し、しばらく時間がかかる可能性があります。

00:05:30.000 --> 00:05:39.000
データがダウンロードされた後、Swiftは後続のステートメントに進む前に、その値を変数名にバインドします。

00:05:39.000 --> 00:05:45.000
各ステップの矢印でたどられているように、ここには実行の流れが1つしかないことに注意してください。

00:05:45.000 --> 00:05:54.000
ダウンロードにはしばらく時間がかかる可能性があるため、プログラムがデータのダウンロードを開始し、データが実際に必要になるまで他の作業を続ける必要があります。

00:05:54.000 --> 00:05:59.000
これを実現するには、既存のletバインディングの前にasyncという単語を追加するだけです。

00:05:59.000 --> 00:06:04.000
これにより、async-letと呼ばれる同時バインディングに変わります。

00:06:04.000 --> 00:06:10.000
同時バインディングの評価は、シーケンシャルバインディングとは大きく異なるので、それがどのように機能するかを学びましょう。

00:06:10.000 --> 00:06:14.000
バインディングに遭遇する直前から始めます。

00:06:14.000 --> 00:06:21.000
同時バインディングを評価するために、Swiftは最初にそれを作成したサブタスクである新しい子タスクを作成します。

00:06:21.000 --> 00:06:29.000
すべてのタスクはプログラムの実行コンテキストを表すため、このステップから2つの矢印が同時に出てきます。

00:06:29.000 --> 00:06:34.000
この最初の矢印は子タスク用で、すぐにデータのダウンロードを開始します。

00:06:34.000 --> 00:06:41.000
2番目の矢印は親タスク用で、変数の結果をすぐにプレースホルダ値にバインドします。

00:06:41.000 --> 00:06:46.000
この親タスクは、前述のステートメントを実行していたタスクと同じです。

00:06:46.000 --> 00:06:54.000
データが子によって同時にダウンロードされている間、親タスクは同時バインディングに続くステートメントを実行し続けます。

00:06:54.000 --> 00:07:06.000
しかし、結果の実際の値を必要とする式に到達すると、親は結果のプレースホルダを満たす子タスクの完了を待ちます。

00:07:06.000 --> 00:07:10.000
この例では、URLSessionの呼び出しもエラーをスローする可能性があります。

00:07:10.000 --> 00:07:13.000
これは、結果を待つとエラーが発生する可能性があることを意味します。

00:07:13.000 --> 00:07:17.000
だから、私はそれの世話をするために「try」と書く必要があります。

00:07:17.000 --> 00:07:18.000
そして、心配しないでください。

00:07:18.000 --> 00:07:22.000
結果の値をもう一度読んでも、その値は再計算されません。

00:07:22.000 --> 00:07:28.000
Async-letがどのように機能するかを見たので、それを使用してサムネイルのフェッチコードに並行性を追加できます。

00:07:28.000 --> 00:07:33.000
単一の画像を独自の関数にフェッチする前のコードの一部を因数分解しました。

00:07:33.000 --> 00:07:44.000
この新しい機能は、2つの異なるURLからデータをダウンロードしています。1つはフルサイズの画像自体用、もう1つは最適なサムネイルサイズを含むメタデータ用です。

00:07:44.000 --> 00:07:53.000
シーケンシャルバインディングでは、エラーやサスペンションが観察される場所であるため、letの右側に「try await」と書くことに注意してください。

00:07:53.000 --> 00:07:59.000
両方のダウンロードを同時に実行するには、これらの両方の許可の前に「非同期」と書きます。

00:07:59.000 --> 00:08:06.000
ダウンロードは現在子タスクで行われているため、同時バインディングの右側に「try await」と書かなくなりました。

00:08:06.000 --> 00:08:13.000
これらの効果は、同時にバインドされている変数を使用する場合、親タスクによってのみ観察されます。

00:08:13.000 --> 00:08:19.000
したがって、式がメタデータと画像データを読み込む前に「try await」と書きます。

00:08:19.000 --> 00:08:26.000
また、これらの同時バインドされた変数を使用すると、メソッド呼び出しやその他の変更は必要ないことに注意してください。

00:08:26.000 --> 00:08:31.000
これらの変数は、シーケンシャルバインディングで行ったのと同じタイプです。

00:08:31.000 --> 00:08:37.000
さて、私が話してきたこれらの子タスクは、実際にはタスクツリーと呼ばれる階層の一部です。

00:08:37.000 --> 00:08:40.000
このツリーは単なる実装の詳細ではありません。

00:08:40.000 --> 00:08:43.000
それは構造化された並行性の重要な部分です。

00:08:43.000 --> 00:08:50.000
キャンセル、優先度、タスクローカル変数などのタスクの属性に影響します。

00:08:50.000 --> 00:08:56.000
ある非同期関数から別の非同期関数に呼び出しを行うたびに、同じタスクが呼び出しを実行するために使用されます。

00:08:56.000 --> 00:09:01.000
したがって、関数fetchOneThumbnailは、そのタスクのすべての属性を継承します。

00:09:01.000 --> 00:09:09.000
Async-letのような新しい構造化タスクを作成すると、現在の関数が実行されているタスクの子になります。

00:09:09.000 --> 00:09:15.000
タスクは特定の機能の子ではありませんが、その寿命はそれにスコープされる可能性があります。

00:09:15.000 --> 00:09:19.000
ツリーは、各親とその子タスク間のリンクで構成されています。

00:09:19.000 --> 00:09:26.000
リンクは、親タスクは、すべての子タスクが終了した場合にのみ作業を完了できるというルールを強制します。

00:09:26.000 --> 00:09:33.000
このルールは、子タスクが待たされるのを防ぐ異常な制御フローに直面しても当てはまります。

00:09:33.000 --> 00:09:40.000
たとえば、このコードでは、画像データタスクの前に、まずメタデータタスクを待ちます。

00:09:40.000 --> 00:09:49.000
最初に待ちに待ったタスクがエラーをスローして終了した場合、fetchOneThumbnail関数はそのエラーをスローしてすぐに終了する必要があります。

00:09:49.000 --> 00:09:53.000
しかし、2回目のダウンロードを実行するタスクはどうなりますか?

00:09:53.000 --> 00:10:03.000
異常な終了中、Swiftは自動的に未完了のタスクをキャンセルされたものとしてマークし、関数を終了する前に終了を待ちます。

00:10:03.000 --> 00:10:07.000
タスクをキャンセルとしてマークしても、タスクは停止しません。

00:10:07.000 --> 00:10:11.000
それは単に、その結果がもはや必要ないことをタスクに通知します。

00:10:11.000 --> 00:10:18.000
実際、タスクがキャンセルされると、そのタスクの故人であるすべてのサブタスクも自動的にキャンセルされます。

00:10:18.000 --> 00:10:27.000
したがって、URLSessionの実装が画像をダウンロードするための独自の構造化タスクを作成した場合、それらのタスクはキャンセルのためにマークされます。

00:10:27.000 --> 00:10:37.000
関数fetchOneThumbnailは、直接的または間接的に作成したすべての構造化タスクが完了すると、エラーをスローすることで最終的に終了します。

00:10:37.000 --> 00:10:40.000
この保証は、構造化された並行性の基本です。

00:10:40.000 --> 00:10:50.000
ARCがメモリの寿命を自動的に管理するのと同じように、ライフタイムの管理を支援することで、誤ってタスクを漏洩するのを防ぎます。

00:10:50.000 --> 00:10:54.000
これまでのところ、キャンセルがどのように伝播するかの概要を説明しました。

00:10:54.000 --> 00:10:57.000
しかし、タスクが最終的に停止するのはいつですか?

00:10:57.000 --> 00:11:04.000
タスクが重要なトランザクションの最中にある場合、またはネットワーク接続が開いている場合、タスクを停止するのは正しくありません。

00:11:04.000 --> 00:11:08.000
そのため、Swiftでのタスクのキャンセルは協力的です。

00:11:08.000 --> 00:11:15.000
コードはキャンセルを明示的にチェックし、適切な方法で実行を縮小する必要があります。

00:11:15.000 --> 00:11:21.000
現在のタスクのキャンセルステータスは、非同期であるかどうかにかかわらず、任意の機能から確認できます。

00:11:21.000 --> 00:11:29.000
これは、特に長時間の計算を伴う場合は、キャンセルを念頭に置いてAPIを実装する必要があることを意味します。

00:11:29.000 --> 00:11:38.000
ユーザーは、キャンセルできるタスクからコードを呼び出す可能性があり、計算ができるだけ早く停止することを期待します。

00:11:38.000 --> 00:11:45.000
協力的なキャンセルを使用するのがどれほど簡単かを確認するには、サムネイルのフェッチ例に戻りましょう。

00:11:45.000 --> 00:11:53.000
ここでは、代わりにfetchOneThumbnail関数を使用するように、フェッチするすべてのサムネイルを与えられた元の関数を書き換えました。

00:11:53.000 --> 00:12:02.000
この関数がキャンセルされたタスク内で呼び出された場合、無駄なサムネイルを作成してアプリケーションを保持したくありません。

00:12:02.000 --> 00:12:07.000
したがって、各ループ反復の開始時にcheckCancellationへの呼び出しを追加できます。

00:12:07.000 --> 00:12:12.000
この呼び出しは、現在のタスクがキャンセルされた場合にのみエラーをスローします。

00:12:12.000 --> 00:12:19.000
コードにより適切な場合は、現在のタスクのキャンセルステータスをブール値として取得することもできます。

00:12:19.000 --> 00:12:27.000
このバージョンの関数では、部分的な結果、一部のサムネイルのみが要求された辞書を返すことに注意してください。

00:12:27.000 --> 00:12:34.000
これを行うときは、APIに部分的な結果が返される可能性があることを明確に示す必要があります。

00:12:34.000 --> 00:12:43.000
そうしないと、タスクのキャンセルは、キャンセル中でも完全な結果を必要とするため、ユーザーにとって致命的なエラーを引き起こす可能性があります。

00:12:43.000 --> 00:12:52.000
これまでのところ、async-letは、構造化プログラミングの本質をキャプチャしながら、プログラムに並行性を追加するための軽量構文を提供することがわかります。

00:12:52.000 --> 00:12:56.000
私があなたに伝えたい次の種類のタスクは、グループタスクと呼ばれます。

00:12:56.000 --> 00:13:03.000
それらは、構造化された並行性のすべての素晴らしい特性を放棄することなく、async-letよりも柔軟性を提供します。

00:13:03.000 --> 00:13:08.000
先に見たように、async-letは、利用可能な一定量の並行性がある場合にうまく機能します。

00:13:08.000 --> 00:13:11.000
先ほど説明した両方の機能を考えてみましょう。

00:13:11.000 --> 00:13:19.000
ループ内のサムネイルIDごとに、fetchOneThumbnailを呼び出して処理し、正確に2つの子タスクを作成します。

00:13:19.000 --> 00:13:26.000
その関数の本体をこのループにインライン化しても、並行性の量は変わりません。

00:13:26.000 --> 00:13:28.000
Async-letは、変数バインディングのようにスコープされます。

00:13:28.000 --> 00:13:34.000
つまり、次のループ反復が始まる前に、2つの子タスクを完了する必要があります。

00:13:34.000 --> 00:13:41.000
しかし、このループがタスクをキックオフして、すべてのサムネイルを同時に取得したい場合はどうなりますか?

00:13:41.000 --> 00:13:48.000
次に、配列内のIDの数に依存するため、並行性の量は静的に知られていません。

00:13:48.000 --> 00:13:51.000
この状況に適したツールはタスクグループです。

00:13:51.000 --> 00:13:56.000
タスクグループは、動的な量の並行性を提供するように設計された構造化された並行性の一形態です。

00:13:56.000 --> 00:14:01.000
withThrowingTaskGroup関数を呼び出すことで、タスクグループを導入できます。

00:14:01.000 --> 00:14:08.000
この関数は、エラーをスローできる子タスクを作成するためのスコープ付きグループオブジェクトを提供します。

00:14:08.000 --> 00:14:14.000
グループに追加されたタスクは、グループが定義されているブロックの範囲よりも長生きすることはできません。

00:14:14.000 --> 00:14:21.000
For-loop全体をブロック内に配置したので、グループを使用して動的な数のタスクを作成できるようになりました。

00:14:21.000 --> 00:14:25.000
同期メソッドを呼び出すことで、グループに子タスクを作成します。

00:14:25.000 --> 00:14:31.000
グループに追加されると、子タスクはすぐに任意の順序で実行されます。

00:14:31.000 --> 00:14:37.000
グループオブジェクトがスコープ外になると、その中のすべてのタスクの完了が暗黙的に待たされます。

00:14:37.000 --> 00:14:44.000
これは、グループタスクも構造化されているため、先ほど説明したタスクツリールールの結果です。

00:14:44.000 --> 00:14:55.000
この時点で、私たちはすでに望んでいた並行性を達成しました。fetchOneThumbnailへの呼び出しごとに1つのタスクで、それ自体がasync-letを使用してさらに2つのタスクを作成します。

00:14:55.000 --> 00:14:58.000
それは構造化された並行性のもう一つの素晴らしい特性です。

00:14:58.000 --> 00:15:08.000
グループタスク内でasync-letを使用したり、async-letタスク内でタスクグループを作成したりすることができ、ツリー内の並行性のレベルは自然に構成されます。

00:15:08.000 --> 00:15:11.000
今、このコードはまだ実行する準備ができていません。

00:15:11.000 --> 00:15:16.000
実行しようとすると、コンパイラはデータレースの問題を警告してくれます。

00:15:16.000 --> 00:15:21.000
問題は、各子タスクから1つの辞書にサムネイルを挿入しようとしていることです。

00:15:21.000 --> 00:15:25.000
これは、プログラムの並行性の量を増やすときのよくある間違いです。

00:15:25.000 --> 00:15:28.000
データレースは誤って作成されます。

00:15:28.000 --> 00:15:39.000
この辞書は一度に複数のアクセスを処理できず、2つの子タスクが同時にサムネイルを挿入しようとすると、クラッシュやデータの破損を引き起こす可能性があります。

00:15:39.000 --> 00:15:47.000
過去には、これらのバグを自分で調査する必要がありましたが、Swiftはそもそもそれらのバグが発生するのを防ぐために静的チェックを提供しています。

00:15:47.000 --> 00:15:55.000
新しいタスクを作成するたびに、タスクが実行する作業は、@Sendableクロージャと呼ばれる新しいクロージャタイプ内にあります。

00:15:55.000 --> 00:16:05.000
@Sendableクロージャの本体は、タスクの起動後にこれらの変数が変更される可能性があるため、レキシカルコンテキストで変更可能な変数をキャプチャすることが制限されています。

00:16:05.000 --> 00:16:09.000
これは、タスクでキャプチャする値が安全に共有できる必要があることを意味します。

00:16:09.000 --> 00:16:22.000
たとえば、IntやStringなどの値型であるため、またはアクターなどの複数のスレッドからアクセスするように設計されたオブジェクトであり、独自の同期を実装するクラスであるためです。

00:16:22.000 --> 00:16:30.000
「スウィフトアクターで可変状態を保護する」と呼ばれるこのトピックに特化したセッション全体がありますので、ぜひチェックすることをお勧めします。

00:16:30.000 --> 00:16:35.000
この例のデータレースを避けるために、各子タスクに値を返すことができます。

00:16:35.000 --> 00:16:40.000
この設計は、親タスクに結果を処理する唯一の責任を与えます。

00:16:40.000 --> 00:16:49.000
この場合、各子タスクは、サムネイルの文字列IDとUIImageを含むタプルを返さなければならないと指定しました。

00:16:49.000 --> 00:16:58.000
次に、各子タスク内で、辞書に直接書き込む代わりに、親が処理するキー値タプルを返してもらいます。

00:16:58.000 --> 00:17:04.000
親タスクは、新しいfor-awaitループを使用して、各子タスクの結果を反復処理できます。

00:17:04.000 --> 00:17:09.000
For-awaitループは、子タスクから完了順に結果を取得します。

00:17:09.000 --> 00:17:17.000
このループは順番に実行されるため、親タスクは各キー値のペアを辞書に安全に追加できます。

00:17:17.000 --> 00:17:23.000
これは、for-awaitループを使用して非同期の値のシーケンスにアクセスする一例にすぎません。

00:17:23.000 --> 00:17:30.000
独自のタイプがAsyncSequenceプロトコルに準拠している場合は、for-awaitを使用してそれらを反復することもできます。

00:17:30.000 --> 00:17:34.000
「Meet AsyncSequence」セッションで詳細を確認できます。

00:17:34.000 --> 00:17:43.000
タスクグループは構造化された並行性の一形態ですが、グループタスクと非同期レットタスクのタスクツリールールの実装方法には小さな違いがあります。

00:17:43.000 --> 00:17:50.000
このグループの結果を反復処理するときに、エラーで完了した子タスクに遭遇したとします。

00:17:50.000 --> 00:17:57.000
そのエラーはグループのブロックからスローされるため、グループ内のすべてのタスクは暗黙的にキャンセルされ、その後待たされます。

00:17:57.000 --> 00:17:59.000
これはasync-letと同じように機能します。

00:17:59.000 --> 00:18:05.000
違いは、あなたのグループがブロックからの通常の出口を通って範囲外になったときに起こります。

00:18:05.000 --> 00:18:08.000
その後、キャンセルは暗黙ではありません。

00:18:08.000 --> 00:18:17.000
この動作により、ジョブはキャンセルされず、待たされるため、タスクグループを使用してフォーク結合パターンを表現しやすくなります。

00:18:17.000 --> 00:18:24.000
グループのcancelAllメソッドを使用して、ブロックを終了する前に、すべてのタスクを手動でキャンセルすることもできます。

00:18:24.000 --> 00:18:31.000
タスクをどのようにキャンセルしても、キャンセルは自動的にツリー下に伝播することを覚えておいてください。

00:18:31.000 --> 00:18:37.000
Async-letタスクとグループタスクは、Swiftでスコープ付きの構造化タスクを提供する2種類のタスクです。

00:18:37.000 --> 00:18:42.000
さて、私はジョーに物事を手渡します。ジョーは構造化されていないタスクについて教えてくれます。

00:18:42.000 --> 00:18:43.000
ありがとう、カヴォン。

00:18:43.000 --> 00:18:45.000
こんにちは。私はジョーです。

00:18:45.000 --> 00:18:55.000
Kavonは、タスクに明確な階層を持つプログラムに並行性を追加すると、構造化された並行性がどのようにエラー伝播、キャンセル、およびその他の簿記を簡素化するかを示しました。

00:18:55.000 --> 00:19:00.000
しかし、プログラムにタスクを追加するときは、常に階層があるわけではないことを知っています。

00:19:00.000 --> 00:19:08.000
Swiftは、より多くの手動管理を必要とすることを犠牲にして、より多くの柔軟性を与える非構造化タスクAPIも提供します。

00:19:08.000 --> 00:19:13.000
タスクが明確な階層に該当しない可能性がある状況はたくさんあります。

00:19:13.000 --> 00:19:21.000
最も明らかに、非非非同期コードから非同期計算を行うタスクを起動しようとしている場合は、親タスクがまったくない可能性があります。

00:19:21.000 --> 00:19:28.000
あるいは、タスクの寿命は、単一のスコープや単一の関数の境界に合わないかもしれません。

00:19:28.000 --> 00:19:40.000
たとえば、オブジェクトをアクティブな状態にするメソッド呼び出しに応答してタスクを開始し、オブジェクトを無効にする別のメソッド呼び出しに応答して実行をキャンセルすることができます。

00:19:40.000 --> 00:19:45.000
これは、AppKitとUIKitにデリゲートオブジェクトを実装するときによく起こります。

00:19:45.000 --> 00:19:57.000
UI作業はメインスレッドで行われなければならず、Swiftアクターセッションが議論しているように、Swiftはメインアクターに属するUIクラスを宣言することによってこれを保証します。

00:19:57.000 --> 00:20:02.000
コレクションビューがあり、コレクションビューのデータソースAPIをまだ使用できないとします。

00:20:02.000 --> 00:20:10.000
代わりに、コレクションビューのアイテムが表示されるように、ネットワークからサムネイルを取得するために書いたfetchThumbnails関数を使用したいと考えています。

00:20:10.000 --> 00:20:16.000
ただし、デリゲートメソッドは非同期ではないため、非同期関数の呼び出しを待つことはできません。

00:20:16.000 --> 00:20:23.000
そのためにタスクを開始する必要がありますが、そのタスクは実際にはデリゲートアクションに応じて開始した作業の延長です。

00:20:23.000 --> 00:20:28.000
この新しいタスクは、UI優先度を持つメインアクターで引き続き実行されることを望んでいます。

00:20:28.000 --> 00:20:33.000
タスクの寿命をこの単一のデリゲートメソッドの範囲にバインドしたくないだけです。

00:20:33.000 --> 00:20:38.000
このような状況では、Swiftでは非構造化タスクを構築できます。

00:20:38.000 --> 00:20:46.000
コードの非同期部分をクロージャに移動し、そのクロージャを渡して非同期タスクを構築しましょう。

00:20:46.000 --> 00:20:48.000
さて、実行時に何が起こるかは次のとおりです。

00:20:48.000 --> 00:20:56.000
タスクを作成するポイントに達すると、Swiftは、この場合のメインアクターである元のスコープと同じアクターで実行するようにスケジュールします。

00:20:56.000 --> 00:21:00.000
一方、コントロールはすぐに発信者に戻ります。

00:21:00.000 --> 00:21:07.000
サムネイルタスクは、デリゲートメソッドのメインスレッドをすぐにブロックすることなく、開く開口部がある場合にメインスレッドで実行されます。

00:21:07.000 --> 00:21:13.000
この方法でタスクを構築すると、構造化コードと非構造化コードの中間点が得られます。

00:21:13.000 --> 00:21:25.000
直接構築されたタスクは、起動されたコンテキストのアクターを継承し、グループタスクやasync-letと同様に、オリジンタスクの優先順位やその他の特性も継承します。

00:21:25.000 --> 00:21:27.000
しかし、新しいタスクはスコープ外です。

00:21:27.000 --> 00:21:31.000
その寿命は、それが打ち上げられた場所の範囲に縛られていません。

00:21:31.000 --> 00:21:34.000
オリジンは非同期である必要さえありません。

00:21:34.000 --> 00:21:37.000
スコープなしのタスクはどこでも作成できます。

00:21:37.000 --> 00:21:44.000
この柔軟性のすべてのための取引では、構造化された並行性が自動的に処理するものを手動で管理する必要があります。

00:21:44.000 --> 00:21:55.000
キャンセルとエラーは自動的に伝播せず、明示的な行動を取らない限り、タスクの結果は暗黙的に待ちられません。

00:21:55.000 --> 00:22:06.000
そのため、コレクションビューアイテムが表示されたときにサムネイルを取得するタスクを開始し、サムネイルの準備が整う前にアイテムがビューからスクロールされた場合は、そのタスクをキャンセルする必要があります。

00:22:06.000 --> 00:22:10.000
スコープのないタスクで作業しているので、そのキャンセルは自動的にではありません。

00:22:10.000 --> 00:22:12.000
今すぐそれを実行しましょう。

00:22:12.000 --> 00:22:16.000
タスクを構築した後、得られる値を保存しましょう。

00:22:16.000 --> 00:22:25.000
タスクを作成するときに、この値を行インデックスでキー入力された辞書に入れて、後でそのタスクをキャンセルできるようにすることができます。

00:22:25.000 --> 00:22:31.000
また、タスクが終了したら辞書から削除して、タスクがすでに完了している場合にタスクをキャンセルしようとしないようにする必要があります。

00:22:31.000 --> 00:22:39.000
ここでは、コンパイラによってフラグ付けされたデータレースを取得することなく、その非同期タスクの内外で同じ辞書にアクセスできることに注意してください。

00:22:39.000 --> 00:22:46.000
私たちのデリゲートクラスはメインアクターにバインドされており、新しいタスクはそれを継承するので、並行して一緒に実行されることはありません。

00:22:46.000 --> 00:22:54.000
データレースを心配することなく、このタスク内のメインアクターバインドクラスの保存されたプロパティに安全にアクセスできます。

00:22:54.000 --> 00:23:04.000
一方、デリゲートが後で同じテーブル行がディスプレイから削除されたと言われた場合、値のcancelメソッドを呼び出してタスクをキャンセルできます。

00:23:04.000 --> 00:23:12.000
そこで、そのタスクの元のコンテキストから特性を継承しながら、スコープから独立して実行される非構造化タスクを作成する方法を見てきました。

00:23:12.000 --> 00:23:17.000
しかし、時には、元のコンテキストから何も継承したくないこともあります。

00:23:17.000 --> 00:23:22.000
最大限の柔軟性のために、Swiftは切り離されたタスクを提供します。

00:23:22.000 --> 00:23:27.000
名前が示すように、切り離されたタスクはコンテキストから独立しています。

00:23:27.000 --> 00:23:28.000
それらはまだ構造化されていないタスクです。

00:23:28.000 --> 00:23:32.000
彼らの生涯は、その起源の範囲に縛られていない。

00:23:32.000 --> 00:23:36.000
しかし、切り離されたタスクは、元のスコープから他に何も拾うことはありません。

00:23:36.000 --> 00:23:43.000
デフォルトでは、同じアクターに制約されず、起動した場所と同じ優先順位で実行する必要はありません。

00:23:43.000 --> 00:23:55.000
切り離されたタスクは、優先度などの一般的なデフォルトで独立して実行されますが、新しいタスクの実行方法と場所を制御するためのオプションのパラメータで起動することもできます。

00:23:55.000 --> 00:24:04.000
サーバーからサムネイルを取得した後、後で取得しようとするとネットワークに再びヒットしないように、ローカルディスクキャッシュに書き込むとします。

00:24:04.000 --> 00:24:14.000
キャッシュはメインアクターで行う必要はなく、すべてのサムネイルの取得をキャンセルしても、取得したサムネイルをキャッシュすることは役に立ちます。

00:24:14.000 --> 00:24:17.000
では、切り離されたタスクを使用してキャッシュを開始しましょう。

00:24:17.000 --> 00:24:23.000
タスクを切り離すと、新しいタスクの実行方法の設定にも柔軟性が高まります。

00:24:23.000 --> 00:24:33.000
キャッシュは、メインUIに干渉しないより低い優先度で行われるべきであり、この新しいタスクを切り離すときにバックグラウンドの優先度を指定できます。

00:24:33.000 --> 00:24:35.000
少し前もって計画を立てましょう。

00:24:35.000 --> 00:24:41.000
サムネイルで実行したいバックグラウンドタスクが複数ある場合、将来何をすべきですか?

00:24:41.000 --> 00:24:48.000
より多くのバックグラウンドタスクを切り離すことができますが、切り離されたタスク内で構造化された並行性を利用することもできます。

00:24:48.000 --> 00:24:55.000
さまざまな種類のタスクを組み合わせて、それぞれの強みを活用することができます。

00:24:55.000 --> 00:25:05.000
すべてのバックグラウンドジョブの独立したタスクを切り離す代わりに、タスクグループを設定し、各バックグラウンドジョブを子タスクとしてそのグループに生成することができます。

00:25:05.000 --> 00:25:08.000
そうすることには多くの利点があります。

00:25:08.000 --> 00:25:17.000
将来的にバックグラウンドタスクをキャンセルする必要がある場合、タスクグループを使用すると、その最上位の切り離されたタスクをキャンセルするだけで、すべての子タスクをキャンセルできます。

00:25:17.000 --> 00:25:23.000
そのキャンセルは自動的に子タスクに伝播し、ハンドルの配列を追跡する必要はありません。

00:25:23.000 --> 00:25:28.000
さらに、子タスクは自動的に親の優先順位を継承します。

00:25:28.000 --> 00:25:44.000
この作業をすべてバックグラウンドで維持するには、切り離されたタスクをバックグラウンド化するだけで、すべての子タスクに自動的に伝播されるため、バックグラウンドの優先順位を推移的に設定するのを忘れたり、誤ってUI作業を飢えさせたりすることを心配する必要はありません。

00:25:44.000 --> 00:25:48.000
この時点で、私たちはSwiftにあるタスクの主要な形式をすべて見てきました。

00:25:48.000 --> 00:25:59.000
Async-letを使用すると、固定数の子タスクを可変バインディングとして生成し、バインディングがスコープ外になった場合のキャンセルとエラーの伝播を自動的に管理できます。

00:25:59.000 --> 00:26:07.000
まだスコープに制限されている動的な数の子タスクが必要な場合は、タスクグループに移動できます。

00:26:07.000 --> 00:26:18.000
十分にスコープされていないが、元のタスクに関連する作業を中断する必要がある場合は、非構造化タスクを構築できますが、それらを手動で管理する必要があります。

00:26:18.000 --> 00:26:28.000
また、最大限の柔軟性のために、オリジンから何も継承しない手動で管理されたタスクであるタスクも切り離されています。

00:26:28.000 --> 00:26:33.000
タスクと構造化された並行性は、Swiftがサポートする一連の並行性機能の一部にすぎません。

00:26:33.000 --> 00:26:37.000
他のすべての素晴らしいトークをチェックして、それが他の言語にどのように適合するかを確認してください。

00:26:37.000 --> 00:26:46.000
「Meet async/await in Swift」は、非同期関数に関する詳細を提供し、同時コードを書くための構造化された基礎を提供します。

00:26:46.000 --> 00:26:52.000
アクターは、データレースから安全な並行システムを作成するためのデータ分離を提供します。

00:26:52.000 --> 00:26:57.000
方法の詳細については、「Swiftアクターで変更可能な状態を保護する」セッションを参照してください。

00:26:57.000 --> 00:27:07.000
タスクグループで「for await」ループを見ましたが、これらは非同期データストリームを操作するための標準インターフェイスを提供するAsyncSequenceの一例にすぎません。

00:27:07.000 --> 00:27:13.000
「Meet AsyncSequence」セッションは、シーケンスを操作するための利用可能なAPIをより深く掘り下げます。

00:27:13.000 --> 00:27:25.000
タスクはコアOSと統合して低オーバーヘッドと高いスケーラビリティを実現し、「Swift並行性：舞台裏」セッションでは、それがどのように達成されたかについてより技術的な詳細を提供します。

00:27:25.000 --> 00:27:42.000
これらすべての機能が組み合わさって、Swiftで並行コードを書くことを簡単かつ安全にし、アプリの興味深い部分に焦点を当てながら、デバイスを最大限に活用するコードを書くことができます。並行タスクを管理する仕組みや、マルチスレッドによって引き起こされる潜在的なバグの心配についてはあまり考えません。

00:27:42.000 --> 00:27:44.000
ご覧いただきありがとうございます。

00:27:44.000 --> 00:27:46.000
残りの会議を楽しんでください。

00:27:46.000 --> 23:59:59.000
[明るい音楽]。

