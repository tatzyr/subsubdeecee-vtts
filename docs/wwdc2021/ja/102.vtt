WEBVTT

00:00:17.000 --> 00:00:21.000
組合のWWDC2021プラットフォームの状態へようこそ。

00:00:21.000 --> 00:00:28.000
WWDCは、私たちが開発者コミュニティとして集まり、近い将来が私たちのプラットフォームに何をもたらすかを見る時です。

00:00:28.000 --> 00:00:36.000
また、あなたがした仕事が私たち全員がこの1年を乗り切るのにどのように役立ったかについて少し考えたいと思います。

00:00:36.000 --> 00:00:45.000
あなたのアプリとあなたの創造性は、人々が異常な状況下で物事を動かし続ける新しい方法を見つけることを可能にしました。

00:00:45.000 --> 00:00:55.000
開発者が違いを生み出す素晴らしい例はたくさんあり、あなたが世界をより良くするためにできることはもっとたくさんあることを知っています。

00:00:55.000 --> 00:01:03.000
そのため、今年は、より多くのことを達成できるように設計されたツール、テクノロジー、APIを提供しています。

00:01:03.000 --> 00:01:07.000
そして今日は、それを実現する3つの大きな分野について話します。

00:01:07.000 --> 00:01:15.000
まず、XcodeとXcode Cloud、Swift、UIフレームワークなど、優れたアプリを構築するのに役立つものについて説明します。

00:01:15.000 --> 00:01:25.000
次に、Appleのテクノロジーが、ユーザーが新しい方法で世界を見るための拡張現実とグラフィックス技術を可能にするアプリの構築にどのように役立つかを見ていきます。

00:01:25.000 --> 00:01:39.000
最後に、フォーカス、スクリーンタイムAPI、ウィジェット、シェアプレイなどの新機能により、あなたが構築したアプリが、ユーザーが互いによりよくつながり、最も重要なことに優先順位を付けるのに役立つ方法を見ていきます。

00:01:39.000 --> 00:01:41.000
アプリの開発から始めましょう。

00:01:41.000 --> 00:01:48.000
さらに詳しくお伝えします。アリソン、ロンダ、アンドリューです。

00:01:48.000 --> 00:01:57.000
今日のアプリの開発はかなり洗練されたプロセスであり、集中力と効果を維持するためにツールに依存しています。

00:01:57.000 --> 00:02:04.000
プロセスの最も重要な部分はコーディングですが、今日質の高いアプリを構築するには、多くの専門的なステップとツールが必要です。

00:02:04.000 --> 00:02:08.000
さまざまな構成でコードをテストする必要があります。

00:02:08.000 --> 00:02:13.000
チームはコードをレビューし、変更を共有リポジトリに統合します。

00:02:13.000 --> 00:02:15.000
あなたはベータテスターに配信します。

00:02:15.000 --> 00:02:19.000
そして、彼らのフィードバックに基づいて、あなたは常にあなたのアプリを洗練させます。

00:02:19.000 --> 00:02:23.000
これらのステップはすべて重要であり、それらをすべて正しく行うことが重要です。

00:02:23.000 --> 00:02:30.000
すべてを成し遂げるには、さまざまなアプリ、ウェブサイト、サービス間を移動しなければならないことがよくあります。

00:02:30.000 --> 00:02:36.000
このすべてのコンテキスト切り替えは、あなたの焦点を乱し、あなたのコードからあなたを引き離します。

00:02:36.000 --> 00:02:47.000
それについて何かをする時が来ました。摩擦を取り除き、すべてをまとめるので、あなたとあなたのチームは素晴らしい経験を生み出すことに集中することができます。

00:02:47.000 --> 00:02:56.000
そのため、Xcode Cloudを作成しました。Xcodeに組み込まれ、クラウドでホストされている新しい継続的インテグレーションと配信サービスです。

00:02:56.000 --> 00:03:04.000
開発プロセスのあらゆる段階を管理するのに役立ち、重要なことを簡単に正しく理解できます。

00:03:04.000 --> 00:03:10.000
Xcode Cloudは、すべてのAppleプラットフォームの開発をサポートするためにゼロから設計および構築されました。

00:03:10.000 --> 00:03:16.000
Xcodeに深く統合されており、1か所に集中することで時間を節約できます。

00:03:16.000 --> 00:03:23.000
Appleのクラウドインフラストラクチャを活用して、ビルド、テスト、さらには配布用のコード署名をオフロードします。

00:03:23.000 --> 00:03:30.000
Test FlightやApp Store ConnectなどのAppleサービス、およびすべての主要なgitベースのソース管理プロバイダーと統合されています。

00:03:30.000 --> 00:03:35.000
開発プロセスの他の側面に接続するのに役立つREST APIもあります。

00:03:35.000 --> 00:03:40.000
そして、それはあなたとあなたのプロジェクトを保護するために高度なセキュリティで構築されています。

00:03:40.000 --> 00:03:50.000
これは、Xcodeの元のリリース以来、私たちが開発者ツールに行った最大の投資であり、そのすべてはあなたがすでに知っている経験の中にあります。

00:03:50.000 --> 00:04:00.000
Xcode 13でXcode Cloudワークフローを作成および管理し、テストスイート、コード署名、およびTestFlight配布が処理されている間、コードにとどまることができます。

00:04:00.000 --> 00:04:05.000
そして、Xcode Cloudがビルドを完了すると、結果はXcode内にあります。

00:04:05.000 --> 00:04:08.000
これはあなたの働き方を変えるでしょう。

00:04:08.000 --> 00:04:10.000
それはすでに私たちの働き方を変えています。

00:04:10.000 --> 00:04:23.000
Appleの多くのチームは、Xcode自体の背後にあるチームを含め、Xcode Cloudを開発プロセスに組み込んでいます。

00:04:23.000 --> 00:04:26.000
Xcode Cloudを使い始めるのは信じられないほど簡単です。

00:04:26.000 --> 00:04:36.000
製品の選択、ワークフローの確認、ソースコードへのアクセスの許可、App Store Connectへのリンクの4つのステップしかかかりません。

00:04:36.000 --> 00:04:41.000
SwiftUIのサンプルアプリであるFrutaでプロセスを進めましょう。

00:04:41.000 --> 00:04:47.000
Xcode Cloudはプロジェクトの製品とプラットフォームを自動的に検出するので、「次へ」をクリックします。

00:04:47.000 --> 00:04:55.000
次に、Xcode Cloudに何をすべきか、いつ行うべきかを伝える、提案されたワークフローを確認します。

00:04:55.000 --> 00:05:00.000
デフォルトのアクションは、私が行うすべての変更をビルドし、それはまさに私が望むものです。

00:05:00.000 --> 00:05:05.000
これで、Xcode Cloudは私のソースコードのホストアカウントに安全に接続します。

00:05:05.000 --> 00:05:10.000
私はすでに資格情報を使用してアクセスを許可したので、先に進むことができます。

00:05:10.000 --> 00:05:17.000
最後に、Xcode CloudはFrutaがApp Storeにすでに存在していることを認識し、情報を確認するように依頼します。

00:05:17.000 --> 00:05:22.000
アプリがまだ登録されていない場合は、Xcode Cloudがあなたのためにそれを行います。

00:05:22.000 --> 00:05:27.000
[完了] をクリックして、クラウドで最初のビルドを開始します。

00:05:27.000 --> 00:05:31.000
ビルドが完了したら、レポートナビゲーターで結果を表示できるようになります。

00:05:31.000 --> 00:05:40.000
そして、ちょうどそのように、私はXcode内から1分でアプリの継続的インテグレーションと配信を設定しました。

00:05:40.000 --> 00:05:44.000
結果がどのように提示されるかを詳しく見てみましょう。

00:05:44.000 --> 00:05:52.000
レポートナビゲーターの[クラウド]タブでは、各ワークフローで実行されたビルドがブランチまたはプルリクエストごとにグループ化されます。

00:05:52.000 --> 00:06:03.000
個々のビルドを選択すると、いつどのように開始されたか、どのXcodeとmacOSのバージョンが使用されたか、すべてのアクションのステータスなどの情報を含む概要が表示されます。

00:06:03.000 --> 00:06:07.000
ソースをチェックしたり、再構築を開始したりすることもできます。

00:06:07.000 --> 00:06:18.000
デフォルトのワークフローは始めるのに最適ですが、Xcode Cloudは、アプリの分析やTest FlightやApp Storeへの新しいリリースのデプロイなどの目標を達成するためのさらに多くのパワーを提供します。

00:06:18.000 --> 00:06:27.000
私のチームは、すべての新しいプルリクエストでiOSテストを実行したいので、今すぐそのワークフローを設定しましょう。

00:06:27.000 --> 00:06:34.000
Xcode Cloudの製品メニューに戻り、今回は[ワークフローの管理]を選択し、[プラス]をクリックして新しいものを追加します。

00:06:34.000 --> 00:06:44.000
ワークフローのプルリクエストに名前を付け、その開始条件を編集して、メインブランチをターゲットとするすべてのプルリクエストで実行します。

00:06:44.000 --> 00:06:51.000
テストをXcodeとmacOSのパブリックベータ版で実行したいので、ここで設定します。

00:06:51.000 --> 00:07:02.000
次に、ワークフローのアクションを見て、テストアクションを追加し、プロジェクトから既存のiOSテストプランを選択します。

00:07:02.000 --> 00:07:08.000
私のアプリの幅広いテストカバレッジを得るために、Xcode Cloudは私が使用するシミュレータを推奨しています。

00:07:08.000 --> 00:07:14.000
わずか2回のクリックで、ワークフロー用にキュレーションされたiPhoneとiPadのセットが手に入る。

00:07:14.000 --> 00:07:16.000
今、それはかなりきちんとしています。

00:07:16.000 --> 00:07:19.000
また、私たちのチームは、ビルドが成功または失敗したときに通知を受ける必要があります。

00:07:19.000 --> 00:07:25.000
そこで、通知投稿アクションを追加し、チームのSlackチャンネルを追加します。

00:07:25.000 --> 00:07:29.000
[保存]をクリックすると、Xcode Cloudの製品にワークフローが追加されました。

00:07:29.000 --> 00:07:34.000
今、私のチームは、私たちが行っている変更に自信を持てるようになるでしょう。

00:07:34.000 --> 00:07:46.000
カスタムビルドスクリプトの実行や、Xcode CloudのWebフックとAPIを使用して、あなたとあなたのチームが依存している他のシステムと統合するなど、ワークフローでできることはたくさんあります。

00:07:46.000 --> 00:07:53.000
また、Xcodeで見たワークフロー管理とビルドレポートは、ウェブ上のApp Store Connectでも入手できます。

00:07:53.000 --> 00:07:59.000
これにより、あなたやチームの他のメンバーがどこからでもXcode Cloudを簡単に使用できます。

00:07:59.000 --> 00:08:07.000
Xcode Cloudでの作業の基本を見たので、開発サイクルの各特定の分野でどのように役立つかを見てみましょう。

00:08:07.000 --> 00:08:13.000
優れたテストを書いて繰り返し実行することは、質の高いアプリケーションを作成するために不可欠です。

00:08:13.000 --> 00:08:21.000
Xcode Cloudを使用すると、コードをより徹底的に、より一貫して、より効率的にテストできます。

00:08:21.000 --> 00:08:31.000
Xcode Cloudワークフローを設定して、複数のプラットフォーム、デバイスシミュレータ、OSバージョンで複数のテストプランを並行して実行できます。

00:08:31.000 --> 00:08:39.000
ベータ版を自分のマシンにダウンロードする前に、ベータOSリリースでXcode Cloudでテストを実行することもできます。

00:08:39.000 --> 00:08:50.000
したがって、Xcode Cloudはより多くのテストに役立ち、Xcode 13はより良いテストに役立ちます。

00:08:50.000 --> 00:08:59.000
私たちのアプリFrutaは、ライトとダークの外観、ポートレートとランドスケープの向きをサポートし、2つの言語にローカライズします。

00:08:59.000 --> 00:09:07.000
私はFrutaの最も人気のある機能を実行する一連のユーザーエクスペリエンステストに取り組んできました。

00:09:07.000 --> 00:09:18.000
私のテストコードでは、このシンプルなXCテストAPIを採用して、各バリエーションで各テストを自動的に実行することで、これらのテストをさらに進めます。

00:09:18.000 --> 00:09:26.000
最新のビルドと設定したワークフローテストアクションを選択して、Xcode Cloudでのテストカバレッジを見てみましょう。

00:09:26.000 --> 00:09:30.000
結果は、おなじみのXcodeテストレポートに表示されます。

00:09:30.000 --> 00:09:41.000
これらのテストは、設定ごとに1回、iOS 15を実行している推奨されるiPadシミュレータのセットで実行され、途中でスクリーンショットをキャプチャしました。

00:09:41.000 --> 00:09:45.000
Xcode 13には、これらの結果を確認する素晴らしい新しい方法があります。

00:09:45.000 --> 00:09:50.000
エディタオプションメニューから、新しいギャラリービューを有効にします。

00:09:50.000 --> 00:09:58.000
私のテストのスクリーンショットは、すべてのバリエーションに表示され、各テストの画像が一緒に表示されます。

00:09:58.000 --> 00:10:08.000
さらにズームアウトしてすべての画像を見ることができ、本当に興味のある画像を見つけたら、クイックルックを使ってフル解像度で見ることができます。

00:10:08.000 --> 00:10:16.000
ギャラリービューでは、アプリがすべての条件、言語、レイアウトで幻想的に見えることを簡単に確認できます。

00:10:16.000 --> 00:10:22.000
私の単体テストでは、あなたが関係すると確信しているテストの失敗があります。

00:10:22.000 --> 00:10:26.000
テストが合格する時もあれば、失敗する時もある。

00:10:26.000 --> 00:10:27.000
私たちは皆、以前にここに来たことがあります。

00:10:27.000 --> 00:10:31.000
そして、Xcode 13がお手伝いします。

00:10:31.000 --> 00:10:38.000
テストソースに移動し、テストジェムをクリックし、「テストを繰り返し実行」を選択します。

00:10:38.000 --> 00:10:43.000
100回実行することで、信頼性の感覚を良くしましょう。

00:10:43.000 --> 00:10:48.000
以前にこれをやりたいと思ったら、自分で何度も何度もテストを実行しなければならないだろう。

00:10:48.000 --> 00:10:53.000
今、ツールがすべての作業を行うので、私は後ろに座ることができます。

00:10:53.000 --> 00:10:59.000
私が疑ったように、Xcodeはこのテストが非常に信頼性が低いことを示しています。

00:10:59.000 --> 00:11:01.000
私のコードに問題があるに違いない。

00:11:01.000 --> 00:11:10.000
しかし、私がそれを修正できるまで、私は新しいExpected Fail APIを採用し、私のチームの残りの部分が見るために信頼性についてのメッセージを含めます。

00:11:10.000 --> 00:11:18.000
物事が期待通りであることを確認するために、製品メニューから入手可能なTest Again機能を利用します。

00:11:18.000 --> 00:11:22.000
Xcodeは前回何をしたかを覚えているので、本当に簡単です。

00:11:22.000 --> 00:11:27.000
私のテストはまだ主張を上げていますが、もう失敗していません。

00:11:27.000 --> 00:11:30.000
そして、私は道に沿ってそれを修正するための穏やかなリマインダーを持っています。

00:11:30.000 --> 00:11:33.000
それはまさに私が必要としているものです。

00:11:33.000 --> 00:11:43.000
ご覧のとおり、Xcode 13とXcode Cloudは、アプリやテストの問題をより迅速に見つけて対処するのに役立ちます。

00:11:43.000 --> 00:11:45.000
テストは、コードに関する洞察の一形態です。

00:11:45.000 --> 00:11:49.000
もう1つは、コードレビューとプルリクエストを通じて、同僚からの入力です。

00:11:49.000 --> 00:11:58.000
コードに集中するために、Xcode 13はチームとのこれらの議論をエディタに直接もたらします。

00:11:58.000 --> 00:12:01.000
私が取り組んでいる機能ブランチからプルリクエストを作成しました。

00:12:01.000 --> 00:12:06.000
私の機能により、ユーザーは最もおいしいスムージーをお気に入りにすることができます。

00:12:06.000 --> 00:12:11.000
左側のナビゲーターでは、新しいソースコントロールの変更タブを見ることができます。

00:12:11.000 --> 00:12:16.000
ローカルで変更したすべてのファイル、プルリクエスト、および含まれている変更が表示されます。

00:12:16.000 --> 00:12:22.000
プルリクエストを選択すると、すべてのアクティビティと会話の完全な概要がわかります。

00:12:22.000 --> 00:12:30.000
そして、スクロールすると、私の説明と興味深いイベントと時間、そして私のチームからのコードフィードバックと私が作った新しいコミットが表示されます。

00:12:30.000 --> 00:12:37.000
しかし、私たちはXcode Cloudを使用しており、プルリクエストワークフローは、私が行うすべてのコミットを構築し、テストしています。

00:12:37.000 --> 00:12:43.000
上部では、すべてのワークフローからライブステータスを取得します。

00:12:43.000 --> 00:12:47.000
ロンダは、私のコードをさらに良くするためにいくつかの提案をしています。

00:12:47.000 --> 00:12:53.000
ソースコードに移動すると、エディタにロンダからのコメントが表示されます。

00:12:53.000 --> 00:12:55.000
このコードでは、ユーザーがログインする必要があります。

00:12:55.000 --> 00:13:00.000
そのため、レシピをお気に入りにする前にサインインできるように作り直す必要があります。

00:13:00.000 --> 00:13:10.000
私が変更に取り組んでいることをロンダに知らせるために返信し、また彼女に警告します。彼女が最初にサインインしない場合、これはビルドでクラッシュする可能性があります。

00:13:10.000 --> 00:13:17.000
プルリクエストを超えて、Xcode 13はローカルの変更のレビューも本当に簡単にします。

00:13:17.000 --> 00:13:28.000
作業中のファイルに移動すると、Xcodeはこの美しい新しいインラインプレゼンテーションで、最新のリビジョンに対する変更の差分を自動的に表示します。

00:13:28.000 --> 00:13:35.000
更新されたリビジョンセレクタを使用して、ローカルの変更を履歴のブランチやタグと比較することができます。

00:13:35.000 --> 00:13:44.000
何よりも、ウィンドウ内の異なるファイルに分割された複数のエディタを使用している場合でも、どのエディタでもコードレビューを使用できます。

00:13:44.000 --> 00:13:53.000
そして今、インライン比較とサイドバイサイドの2つのオプションで、私は私が取り組んでいることに最適なプレゼンテーションを選ぶことができます。

00:13:53.000 --> 00:14:02.000
最後のコード変更とコメントで、私のチームからの洞察を確認して応答するのは簡単ではありません。

00:14:02.000 --> 00:14:08.000
素晴らしい体験を提供することの一部は、アプリをチームとベータテスターの手に渡すことです。

00:14:08.000 --> 00:14:12.000
Xcode Cloudは、そのプロセスを楽にします。

00:14:12.000 --> 00:14:19.000
Xcode 13は現在、クラウドを使用して、アプリのコード署名に必要なものすべてを安全に取得し、管理しています。

00:14:19.000 --> 00:14:27.000
これは、Macで証明書やプロファイルを最新の状態に保つことを心配する必要がなくなったことを意味します。

00:14:27.000 --> 00:14:34.000
Xcode Cloudワークフローのアーカイブアクションは、同じシステムを使用して、配布のためにアプリに署名します。

00:14:34.000 --> 00:14:46.000
また、Xcode Cloudワークフローにポストアクションを追加することで、新しいTest Flight for Macを搭載したmacOSを含むすべてのAppleプラットフォームにTest Flightを通じてベータ版が自動的に配信されます。

00:14:46.000 --> 00:14:52.000
最新のビルドを配信すると、ベータテスターからさらに多くの洞察を得ることができます。

00:14:52.000 --> 00:15:00.000
Xcode 13には、App Store Connectで見つかったのと同じ診断とフィードバックによりよく接続するための大幅な改善が含まれています。

00:15:00.000 --> 00:15:06.000
テストフライトアプリからのクラッシュログは、数分以内にオーガナイザーに直接配信されるようになりました。

00:15:06.000 --> 00:15:11.000
そして、オーガナイザーは、ユーザーがクラッシュレポートに添付した書面によるフィードバックを表示するようになりました。

00:15:11.000 --> 00:15:17.000
これにより、クラッシュを分析する際の貴重なコンテキストと、アプリの使用状況に関するより広い視野が得られます。

00:15:17.000 --> 00:15:24.000
アンドリューのテストに合格した後、Xcode CloudはビルドをTest Flightに直接提出した。

00:15:24.000 --> 00:15:32.000
Frutaの新しいiOSビルドの通知を携帯電話で受け取ったばかりで、Test Flight for MacのMacバージョンがあります。

00:15:32.000 --> 00:15:39.000
Frutaはマルチプラットフォームプロジェクトなので、私は両方の場所で同時にこの新しいビルドを取得しています。

00:15:39.000 --> 00:15:43.000
このビルドをインストールして、新機能がどのように感じるかを見ることに本当に興奮しています。

00:15:43.000 --> 00:15:45.000
だから、今からやります。

00:15:45.000 --> 00:15:48.000
まだいくつかの粗いエッジがあると思います。

00:15:48.000 --> 00:15:52.000
このスムージーをお気に入りにしようとすると、アプリがクラッシュするかもしれません。

00:15:52.000 --> 00:15:54.000
そして、確かに、それはそうです。

00:15:54.000 --> 00:16:00.000
テストフライトのクラッシュフィードバックUIを使用して、アンドリューに知らせることができます。

00:16:00.000 --> 00:16:10.000
アプリがクラッシュしたときに私が何をしていたかを説明します、そして彼は問題を修正し、これが次回早くキャッチされることを確認するためにテストを追加することができます。

00:16:10.000 --> 00:16:24.000
私はオーガナイザーで最新のアプリリリースを見てきました。最終日までフィルタリングすると、ロンダがほんの少し前に経験したクラッシュがあり、完全に象徴化され、調査の準備ができています。

00:16:24.000 --> 00:16:31.000
新しいテストフライトフィードバックインスペクタには、彼女のコメント、アプリのビルド、バージョン、および彼女のデバイスに関する情報が含まれています。

00:16:31.000 --> 00:16:34.000
そして、私は彼女の経験についてもっと学ぶために彼女に連絡することさえできます。

00:16:34.000 --> 00:16:40.000
さらに良いことに、Xcodeは私のコードの中でこのクラッシュがどこから来たのかを知っています。

00:16:40.000 --> 00:16:44.000
だから、ワンクリックで、私のプロジェクトでそれを開くことができます。

00:16:44.000 --> 00:16:48.000
デバッグナビゲーターには完全なバックトレースがあります。

00:16:48.000 --> 00:16:54.000
私のソースエディタはアサーションを強調表示し、プルリクエストの会話も表示されます。

00:16:54.000 --> 00:17:01.000
Xcodeでこの問題を解決するために必要なものを持っているのは信じられないほどエキサイティングです。

00:17:01.000 --> 00:17:15.000
テスト結果、同僚からのコメント、ユーザーのフィードバックなど、毎日使用するツールに必要なものをすべて持ち込み、より大きな洞察を提供し、アプリの次の素晴らしいバージョンを提供するのに役立ちます。

00:17:15.000 --> 00:17:20.000
Xcode Cloudは、お客様のプライバシーとセキュリティを念頭に置いて構築されました。

00:17:20.000 --> 00:17:26.000
ソース、アクセストークン、サインインキー、ビルドアーティファクトなどのデータは安全に処理されます。

00:17:26.000 --> 00:17:30.000
そして、サービスを実行するために可能な限り最小限のデータを使用します。

00:17:30.000 --> 00:17:34.000
これは私たちの開発者ツールにとって大きな年です。

00:17:34.000 --> 00:17:46.000
Xcode 13とXcode Cloudを使用すると、これまで以上に少ない時間と労力で、Appleのすべてのプラットフォームで高品質のアプリを構築し、配信できます。

00:17:46.000 --> 00:17:50.000
Xcode Cloudは当初、無料の限定ベータ版として利用可能になります。

00:17:50.000 --> 00:17:56.000
開発者プログラムのアカウント所有者は、developer.apple.comで今すぐサインアップできます。

00:17:56.000 --> 00:18:03.000
来年、すべての開発者がこれを利用できるようにするために、徐々にチームを追加します。

00:18:03.000 --> 00:18:07.000
この秋、価格と在庫状況の詳細を提供します。

00:18:07.000 --> 00:18:14.000
登録状況は、App Store ConnectのXcode 13またはXcode Cloudタブから確認できます。

00:18:14.000 --> 00:18:28.000
ここで見たすべてのものに加えて、XcodeでのSwiftサポートの素晴らしい機能強化など、今年のセッションで学ぶことができる開発者ツールの改善点と機能の膨大なリストがあります。

00:18:28.000 --> 00:18:32.000
それは今年のスウィフトのエキサイティングな物語の始まりにすぎません。

00:18:32.000 --> 00:18:39.000
もっと詳しく言うと、ここにジョシュ、ホリー、マットがいます。

00:18:39.000 --> 00:18:45.000
Swiftは、Appleのプラットフォームおよびそれ以降の開発者にとって重要な言語となっています。

00:18:45.000 --> 00:18:56.000
SwiftUI、CreateML、新しいStoreKit 2などの新世代のフレームワークの基盤として、最新のテクノロジーが有効になっています。

00:18:56.000 --> 00:19:07.000
Xcode PreviewsやSwift Package Managerなどの強力なツールを使用して、最も複雑なアプリを作成し、開発を加速するためのモダンでタイプセーフな言語を提供します。

00:19:07.000 --> 00:19:15.000
また、新規参入者にとってフレンドリーで親しみやすく、コーディング方法を学ぶためにSwift Playgroundsで利用可能な魅力的なコンテンツとレッスンがあります。

00:19:15.000 --> 00:19:20.000
さて、技術があなたにとって素晴らしいものであることを保証するための重要な部分は、それを自分たちで採用することです。

00:19:20.000 --> 00:19:31.000
音楽のような知名度の高いアプリは何年も前からSwiftで書かれており、ウィジェットのようなシステム全体の機能はSwiftUIでゼロから設計されています。

00:19:31.000 --> 00:19:42.000
SwiftとSwiftUIを学ぶと、すべてのプラットフォーム用の完全ネイティブアプリを構築するための共通で強力なツールとAPIのセットが提供されます。

00:19:42.000 --> 00:19:52.000
また、Swift自体はオープンソースであるため、過去数年間で多くの新しい機能を提供するために、多くのお客様と協力することができました。

00:19:52.000 --> 00:19:59.000
さて、アプリを構築する上で重要な機能の1つは、並行性のサポートです。

00:19:59.000 --> 00:20:04.000
そして、ここにホリーがそれについてすべて話します。

00:20:04.000 --> 00:20:09.000
あなたがそれについて考えるかどうかにかかわらず、あなたは今日並行コードを書いています。

00:20:09.000 --> 00:20:23.000
並行性により、アプリは同時に複数のタスクを実行できます。これにより、ユーザーが都市を選択している間に天気予報データを取得する気象アプリのように、バックグラウンドで作業しながら、アプリがユーザーの入力に応答し続けることができます。

00:20:23.000 --> 00:20:35.000
また、マルチコアプロセッサを活用して、ビデオアプリで複雑な視覚効果をレンダリングするなど、重い計算で高いパフォーマンスを実現することが不可欠です。

00:20:35.000 --> 00:20:42.000
しかし、言語サポートがなければ、並行コードを書くのは本当に難しいです。

00:20:42.000 --> 00:20:47.000
そのため、Swiftに並行性に対するファーストクラスのサポートを提供しています。

00:20:47.000 --> 00:21:01.000
言語に並行性を構築するための私たちのアプローチは、Swift自体と同じコア原則に従っており、プログラミングミスのクラス全体を排除する、モダンで安全で高速なコードを書くことが容易になります。

00:21:01.000 --> 00:21:07.000
まず、Swiftに並行性を構築するための現代的なアプローチをどのように採用したかについて話しましょう。

00:21:07.000 --> 00:21:14.000
今日、私たちは現代のコードは構造化され、あなたがやりたいことを簡単に表現できると考えています。

00:21:14.000 --> 00:21:22.000
残念ながら、今日の非同期コードのほとんどは、構造化されておらず表現しにくい補完ハンドラを使用しています。

00:21:22.000 --> 00:21:29.000
非同期関数の表現を容易にするために、最新の非同期/待機パターンをSwiftに組み込みました。

00:21:29.000 --> 00:21:34.000
これで、非同期キーワードで非同期関数をマークできます。

00:21:34.000 --> 00:21:43.000
関数が呼び出されると、awaitキーワードを使用して、呼び出し元の非同期関数の結果を待っている間に他の作業が実行できることを示します。

00:21:43.000 --> 00:21:50.000
Async/awaitが補完ハンドラにもたらす改善を理解するために、例を見てみましょう。

00:21:50.000 --> 00:21:54.000
スウィフトコンパイラに取り組んでいないときは、踊るのが好きです。

00:21:54.000 --> 00:22:02.000
ショーの準備をするために、ダンスカンパニーは最初にウォームアップしなければならず、乗組員は倉庫から風景と小道具を取り、その後、ステージが設定されます。

00:22:02.000 --> 00:22:07.000
それがすべて完了すると、ダンサーはオープニングポジションに移動できます。

00:22:07.000 --> 00:22:13.000
これは、完了ハンドラを使用する「prepareForShow」の非同期実装です。

00:22:13.000 --> 00:22:18.000
このコードが達成しようとしていることは本当に簡単ですが、コードは複雑です。

00:22:18.000 --> 00:22:26.000
実行の流れを不自然にするネストされた完了ハンドラを使用するため、コードは本当に読みにくいです。

00:22:26.000 --> 00:22:32.000
この例でasync/awaitを採用すると、直線になったコードが残ります。

00:22:32.000 --> 00:22:36.000
このコードはとても理解しやすいです。

00:22:36.000 --> 00:22:40.000
コントロールフローは、他の機能と同様に、上から下へ行きます。

00:22:40.000 --> 00:22:45.000
Swiftで慣れているのと同じ方法でエラーを処理し、値を返します。

00:22:45.000 --> 00:22:49.000
通常の制御フロー構造もすべて使用できます。

00:22:49.000 --> 00:22:55.000
したがって、条件付きロジックを簡単に追加できるため、リハーサル中に関数の動作が異なります。

00:22:55.000 --> 00:23:02.000
Async/awaitは、すでに知っているツールを活用することで、非同期コードの作成を容易にします。

00:23:02.000 --> 00:23:08.000
また、構造化並行性を使用して、必要な場所に並行性を導入する方が簡単です。

00:23:08.000 --> 00:23:15.000
構造化並行性は、並行タスクを整理して推論しやすくする方法です。

00:23:15.000 --> 00:23:18.000
prepareForShowに並行性を導入しましょう。

00:23:18.000 --> 00:23:28.000
現在、この機能は、ダンサーがウォームアップを終えるまで待ってから景色をフェッチし始めますが、これらのタスクは並行して行うことができます。

00:23:28.000 --> 00:23:38.000
構造化並行性を使用すると、このようなローカル変数を使用してasync/awaitを使用して、同時子タスクを簡単に作成できます。

00:23:38.000 --> 00:23:46.000
現在、コードは「async let」変数を使用して、親と同時に実行される子タスクを作成します。

00:23:46.000 --> 00:23:53.000
したがって、会社のウォームアップと景色の取得は、prepareForShowの残りの部分と同時に実行されます。

00:23:53.000 --> 00:23:58.000
これらの子タスクの結果が必要なときは、結果を待ちます。

00:23:58.000 --> 00:24:12.000
fetchStageSceneryは同時に実行されるため、prepareForShowを使用する必要があるときに結果がまだ準備ができていない可能性があるため、結果へのアクセスは非同期に行う必要があります。

00:24:12.000 --> 00:24:16.000
スウィフトの並行性モデルも安全であるように設計されています。

00:24:16.000 --> 00:24:31.000
Swiftがオプションでヌルポインタの間違いを排除するように、コンパイラは、共有状態へのアクセスが並行タスク間で安全に調整されるようにすることで、一般的な並行性の問題を排除するのに役立ちます。

00:24:31.000 --> 00:24:36.000
この安全な並行性モデルの中核部分は、アクターを中心に構築されています。

00:24:36.000 --> 00:24:43.000
アクターは、安全な同時プログラミングのための業界で実績のあるモデルであり、強力な同期プリミティブです。

00:24:43.000 --> 00:24:52.000
概念的には、アクターは、相互に排他的なアクセスのみを提供することによって、独自の状態を保護するオブジェクトです。

00:24:52.000 --> 00:24:58.000
これにより、同時アクセスとそれに付いている低レベルのデータレースが完全に排除されます。

00:24:58.000 --> 00:25:08.000
この概念は、俳優に触発されたディスパッチキューを持つクラスにすでに使用している可能性のあるパターンに似ているため、聞き覚えがあるかもしれません。

00:25:08.000 --> 00:25:17.000
このパターンでは、クラス内のインスタンスプロパティは、相互排除を維持するためにシリアルディスパッチキューを使用して慎重にアクセスされます。

00:25:17.000 --> 00:25:21.000
しかし、このパターンは間違いを犯しがちです。

00:25:21.000 --> 00:25:30.000
定型文が多く、キューを一度だけ手動で使用して、コードに競合状態を導入するのを忘れるのは簡単すぎます。

00:25:30.000 --> 00:25:39.000
これらの問題を解決するために、私たちは俳優のコアアイデアに戻り、それを一流の構造としてSwiftに組み込みました。

00:25:39.000 --> 00:25:44.000
これで、簡単なキーワードでSwiftでアクタータイプを宣言できます。

00:25:44.000 --> 00:25:52.000
それはあなたがすでに知っている構造と同じ構造を持ち、手動同期の必要はありません。

00:25:52.000 --> 00:25:59.000
アクターがSwift言語に組み込まれているため、アクター状態への同期アクセスを自動的に管理できます。

00:25:59.000 --> 00:26:10.000
アクターは独自のプロパティに直接アクセスすることができ、外部的にアクターと対話すると、相互排除を保証するためにasync/awaitを使用します。

00:26:10.000 --> 00:26:21.000
アクターの概念は非常に強力であるため、UI操作などのためのメインスレッドの適切な使用である並行性問題の別の一般的な原因も解決します。

00:26:21.000 --> 00:26:30.000
今日では、メインスレッドで実行する必要があるAPIを呼び出すたびに、メインキューに手動でディスパッチする必要があります。

00:26:30.000 --> 00:26:39.000
次に、APIが常にメインアクターを使用してメインスレッドで実行されていることを述べる方法を紹介します。

00:26:39.000 --> 00:26:48.000
APIが常にメインアクターで実行されていることを確認することは、MainActor属性で宣言に注釈を付けるのと同じくらい簡単です。

00:26:48.000 --> 00:26:55.000
他の俳優と同じように、主役で実行される関数を呼び出すのはただ待つだけです。

00:26:55.000 --> 00:27:03.000
全体として、これは、自分で管理する必要がない安全な同時コードを書く方が簡単であることを意味します。

00:27:03.000 --> 00:27:12.000
並行性のサポートを言語に直接構築することで、並行コードのパフォーマンスをより良く最適化する機会が得られます。

00:27:12.000 --> 00:27:20.000
Async/awaitを使用すると、コンパイラはコードの並行性を理解し、より効果的な最適化を可能にします。

00:27:20.000 --> 00:27:29.000
これには、参照数の削減とインライン化、過剰なコンテキストスイッチなどの並行性固有のパフォーマンス問題への対処が含まれます。

00:27:29.000 --> 00:27:36.000
そしてもちろん、コンパイラが今後数年間で賢くなるにつれて、同時コードはさらに速くなります。

00:27:36.000 --> 00:27:42.000
SDKには、すでにアプリで使用している非同期APIがたくさんあります。

00:27:42.000 --> 00:27:53.000
これらの非同期APIでasync/awaitを有効にするようにSDKを改良したので、既存のコードでasync/awaitをすぐに採用できます。

00:27:53.000 --> 00:27:55.000
そして、私たちはそこで止まりませんでした。

00:27:55.000 --> 00:28:10.000
URLで作業するとき、非同期I/Oを行うときにasync/awaitを利用する新しい意図的に作成されたAPIを追加し、ファイルを非同期に行ごとに反復するサポートも追加しました。

00:28:10.000 --> 00:28:23.000
Async/awaitは非同期コードを自然に表現し、構造化された並行性は並行コードを推論しやすくし、アクターは並行プログラムで共有状態を安全にモデル化するのに役立ちます。

00:28:23.000 --> 00:28:34.000
Swiftの並行性モデルは、これらの基本的な部分をまとめて、より効率的にし、より多くのパワーを与え、並行アプリの構築をより楽しくできるようにします。

00:28:34.000 --> 00:28:39.000
もちろん、言語はパズルの1つのピースにすぎません。

00:28:39.000 --> 00:28:43.000
Swiftで構築されたフレームワークも同様に重要です。

00:28:43.000 --> 00:28:45.000
さて、ジョシュに戻ります。

00:28:45.000 --> 00:28:49.000
Swiftは次世代のAPIの基盤です。

00:28:49.000 --> 00:29:03.000
並行性などの新機能により、言語とフレームワークを一緒に進化させているので、SwiftUIのような主要な技術を含め、SDK全体にすぐにメリットがあります。

00:29:03.000 --> 00:29:08.000
2年前、私たちはプラットフォームでUI開発を再発明し始めました。

00:29:08.000 --> 00:29:17.000
私たちは、既存のアプリケーションでSwiftUIを段階的に採用できるコアAPIで、小規模から始めました。

00:29:17.000 --> 00:29:26.000
昨年、アプリのライフサイクルを説明するAPIを追加し、コードの最初の行からSwiftUIで完全にアプリを開発できるようにしました。

00:29:26.000 --> 00:29:37.000
そして今年、SwiftUIはさらに大きな一歩を踏み出し、すべてのAppleプラットフォームですべてのユーザーに素晴らしい体験を提供するのに役立ちます。

00:29:37.000 --> 00:29:44.000
私たちは、私たちのアプリを構築するためにも必要だったので、あなたのアプリにとって重要であるとわかっているAPIに焦点を当てました。

00:29:44.000 --> 00:29:51.000
そして、あなたのフィードバックは、開発経験を向上させながら、最も重要なAPIを強化するのに役立ちました。

00:29:51.000 --> 00:29:57.000
今年は、マップ、写真、ショートカットなどのアプリでSwiftUIを使い始めました。

00:29:57.000 --> 00:30:08.000
そして、WeatherのようなiOSアプリ、Apple Pay支払いシートのようなシステムインターフェース、Find Myのような新しいwatchOSアプリを完全にSwiftUIで再構築しました。

00:30:08.000 --> 00:30:14.000
これを可能にする機能強化をいくつか見るために、Frutaを改善できるいくつかの方法を見てみましょう。

00:30:14.000 --> 00:30:20.000
私たちは、すべてのプラットフォームで最もユビキタスなコンポーネントであるリストから始めます。

00:30:20.000 --> 00:30:25.000
スムージーをお気に入りとしてマークするスワイプアクションを簡単に追加できるようになりました。

00:30:25.000 --> 00:30:28.000
Pull-to-refreshを追加すると、もう1行です。

00:30:28.000 --> 00:30:37.000
そして、Swiftは、修飾子を単一のプラットフォーム、この場合はiOSに簡単に制限するようになりました。

00:30:37.000 --> 00:30:40.000
検索フィールドの追加は、もう1行だけです。

00:30:40.000 --> 00:30:47.000
さて、私たちはそこで止まることができますが、入力中に表示される検索候補も追加しましょう。

00:30:47.000 --> 00:30:51.000
そして、ここでXcodeでそれをテストしましょう。

00:30:51.000 --> 00:31:02.000
わずか数行のコードで、スワイプアクション、プルツーリフレッシュ、提案を含む完全な検索サポートがあります。

00:31:02.000 --> 00:31:06.000
次に、Frutaのアクセシビリティサポートを洗練させましょう。

00:31:06.000 --> 00:31:15.000
まず、アクセシビリティローターを追加する新しい修飾子により、VoiceOverでアプリをより速くナビゲートできます。

00:31:15.000 --> 00:31:20.000
そして第二に、このカスタムステッピングコントロールのアクセシビリティを向上させます。

00:31:20.000 --> 00:31:30.000
カスタムコントロールはしばしば貧弱なアクセシビリティの原因ですが、標準のステッパーから完全なアクセシビリティ実装を継承できるようになりました。

00:31:30.000 --> 00:31:40.000
ほとんどのSwiftUI APIはすべてのプラットフォームで利用できますが、必要に応じてプラットフォームを個別に前進させています。

00:31:40.000 --> 00:31:44.000
macOSアプリに複数列のテーブルを追加しましょう。

00:31:44.000 --> 00:31:50.000
私はすでにこのために新しいファイルを追加したので、ここに新しいテーブルコンポーネントを追加します。

00:31:50.000 --> 00:31:54.000
そして、その中に3つの列のデータを追加するだけです。

00:31:54.000 --> 00:31:58.000
では、私たちのアプリのmacOSバージョンを実行しましょう。

00:31:58.000 --> 00:32:05.000
検索フィールドはツールバーの表示場所に配置され、入力中にそのすぐ下に提案が表示されます。

00:32:05.000 --> 00:32:12.000
追加した新しい複数列のテーブルに切り替えると、検索結果も表示されることがわかります。

00:32:12.000 --> 00:32:17.000
そしてもちろん、私たちはそれらすべてを取り戻すために検索をクリアすることができます。

00:32:17.000 --> 00:32:22.000
では、レシピに切り替えてVoiceOverをオンにしましょう。

00:32:22.000 --> 00:32:29.000
VoiceOverを使用すると、追加したローターに簡単にアクセスして、リストからスムージーをすばやく選択できます。

00:32:29.000 --> 00:32:38.000
また、カスタムステッパーとのVoiceOverインタラクションは、標準ステッパーとまったく同じように動作し、すべてのユーザーが簡単に使用できるようになりました。

00:32:38.000 --> 00:32:46.000
私たちはこれらの新機能を使用してアプリを構築しているので、あなたの機能にも役立つことを知っています。

00:32:46.000 --> 00:32:50.000
そして、私たちは新しいものの表面を傷つけました。

00:32:50.000 --> 00:32:55.000
例えば、あなたはSwiftUIの新しいマテリアルサポートを気に入るはずです。

00:32:55.000 --> 00:33:07.000
Frutaアプリでは、このようなビューは背景画像を追加することでより面白くなり、コンテンツの背後にある新しい素材スタイルの1つを適用することで読みやすく保たれます。

00:33:07.000 --> 00:33:24.000
コンテンツはこの背景に動的に反応するため、不透明なコンテキストでセカンダリコンテンツに通常使用されるグレーの代わりに、SwiftUIはテキスト、シンボル、さらにはセパレータのような標準UIに自動的に鮮やかなレンダリングを適用します。

00:33:24.000 --> 00:33:30.000
したがって、1行のコードで、このような見栄えの良い結果を自動的に得ることができます。

00:33:30.000 --> 00:33:33.000
そして、もっとたくさんあります。

00:33:33.000 --> 00:33:41.000
これらすべての改善により、SwiftUIは、すべてのプラットフォームですべてのユーザーにとって素晴らしい体験を構築するための最良の方法です。

00:33:41.000 --> 00:33:48.000
そして今年は、SwiftUIを使ったアプリ開発をSwift PlaygroundsのiPadにもたらします。

00:33:48.000 --> 00:33:56.000
それはとても楽しいです、そしてマットはそれがどのように機能するかについてあなたにすべてを見せます。

00:33:56.000 --> 00:34:03.000
Swift Playgroundsは、コーディング方法を学ぶための素晴らしい方法を提供し、Swiftの知識を広げるために何百万人もの人々によって使用されています。

00:34:03.000 --> 00:34:14.000
そして、学ぶための素晴らしい方法であるだけでなく、多くの人がすでにSwift Playgroundsを使って実験し、新しいアイデアをスケッチし、iPadOS SDKの最新機能で遊んでいることを知っています。

00:34:14.000 --> 00:34:24.000
今年、Swift Playgrounds 4は、アプリを構築し、iPadから直接App Storeに提出できるようにすることで、大きな一歩を踏み出しています。

00:34:24.000 --> 00:34:34.000
iPadでアプリを作成する機能により、Swift Playgroundsではこれまで以上に生産性が高くなり、どこにいても、どのデバイスでもアイデアに取り組むことができます。

00:34:34.000 --> 00:34:41.000
また、新しいパッケージベースのプロジェクト形式により、Swift PlaygroundsとXcodeの間でシームレスに作業を持ち込むことができます。

00:34:41.000 --> 00:34:43.000
飛び込んで見てみましょう。 

00:34:43.000 --> 00:34:46.000
これはスウィフトプレイグラウンド4です。

00:34:46.000 --> 00:34:56.000
世界中の新しい開発者を鼓舞するのに役立つ素晴らしいLearn to Codeコンテンツがすべてあり、今ではSwiftUIアプリを構築できるプロジェクトを作成できます。

00:34:56.000 --> 00:35:00.000
今すぐ新しいものを作って、何を構築できるか見てみましょう。

00:35:00.000 --> 00:35:03.000
作成した新しいプロジェクトを開きます。

00:35:03.000 --> 00:35:10.000
Swift Playgroundsのアプリプロジェクトでは、私のコードは左側にあり、私の作業の結果は私が慣れているように右側にあります。

00:35:10.000 --> 00:35:19.000
新機能は、Xcodeで使用されているのと同じ技術を搭載したライブインタラクティブプレビューを備えた、SwiftUIの深く統合されたサポートです。

00:35:19.000 --> 00:35:26.000
私の新しいプロジェクトテンプレートにはHello Worldプレースホルダが付属しており、自分のテキストビューに簡単に置き換えることができます。

00:35:26.000 --> 00:35:36.000
テキストの入力を開始し、すぐにコード補完から役立つ提案が得られます。このリリースでは、挿入ポイントのすぐ下に表示されます。

00:35:36.000 --> 00:35:40.000
完了を受け入れて、自分の挨拶メッセージを書きます。

00:35:40.000 --> 00:35:45.000
入力中、アプリがライブで更新され、キーストロークごとに変更が表示されます。

00:35:45.000 --> 00:35:47.000
さあ、少し楽しみましょう。

00:35:47.000 --> 00:35:51.000
この静的なテキストをボタンに置き換えます。

00:35:51.000 --> 00:35:56.000
テキストビューを選択し、ライブラリからボタンを追加します。

00:35:56.000 --> 00:36:07.000
ここライブラリでは、プロジェクトのアセットや、iPadOSが提供するSwiftUIビュー、修飾子、色、SFシンボルを閲覧して検索できます。

00:36:07.000 --> 00:36:11.000
とりあえず、ボタンを追加するだけです。

00:36:11.000 --> 00:36:17.000
簡単な印刷ステートメントでアクションを埋めます。

00:36:17.000 --> 00:36:22.000
ボディには、システムイメージのラベルを使用します。

00:36:22.000 --> 00:36:26.000
テキストは「こんにちは」になります。

00:36:26.000 --> 00:36:30.000
そして、画像はスウィフトのSFシンボルになります。

00:36:30.000 --> 00:36:34.000
今、私のアプリにインタラクティブなボタンがあります。

00:36:34.000 --> 00:36:39.000
それをタップすると、私が書いた印刷メッセージが画面の下部にメッセージバブルとして表示されます。

00:36:39.000 --> 00:36:50.000
コンソールを開くと、このプロジェクトを開いてから実行された印刷ステートメントの履歴が表示され、アプリとやり取りするとリアルタイムで更新されます。

00:36:50.000 --> 00:36:57.000
さて、このボタンは紫色です。なぜなら、それは私がプロジェクトを作成したときにSwift Playgroundsが私のために選んだ私のアプリのアクセントカラーだからです。

00:36:57.000 --> 00:37:05.000
ドキュメントサイドバーを開くと、名前、アクセントカラー、アイコンなど、アプリのすべてのトップレベルの設定にアクセスできます。

00:37:05.000 --> 00:37:18.000
私は紫が大好きですが、このスマイリーフェイスはオレンジ色で大きくて明るく見えると思うので、ここでアクセントの色を変更し、アプリのアイコンと今作ったボタンの色合いの色の両方が変更を反映して更新されます。

00:37:18.000 --> 00:37:24.000
これは本当に楽しかったですが、Swift Playgroundsは実験のためだけではありません。

00:37:24.000 --> 00:37:27.000
私はしばらく取り組んできた別のアプリを持っています。 

00:37:27.000 --> 00:37:34.000
私はこのアプリを使って、お気に入りの趣味に費やした時間を追跡し、他の人も役に立つかもしれないと思います。

00:37:34.000 --> 00:37:39.000
フルスクリーンで撮影することで、インストールされたアプリがどのように見えるかを感じることができます。

00:37:39.000 --> 00:37:45.000
これで、全幅の2列または3列のレイアウトでアプリを探索できます。

00:37:45.000 --> 00:37:51.000
フルスクリーンから飛び出して、いつでも好きなときにコードに戻ることができます。

00:37:51.000 --> 00:37:57.000
これは素晴らしい気分で、私のハードワークはTestFlightで友人や家族と共有する準備ができていると思います。

00:37:57.000 --> 00:38:04.000
開発者アカウントを持っている人は誰でも、App Store Connectの準備ができたら、アプリ設定エリアからアプリをアップロードできます。

00:38:04.000 --> 00:38:09.000
アップロードボタンをタップすると、Swift Playgroundsがアプリをビルド、パッケージ化、アップロードします。

00:38:09.000 --> 00:38:19.000
その後、App Store Connectのウェブサイトにアクセスし、TestFlight経由でアプリを利用できるようにし、準備ができたらApp Storeに提出し、世界と共有することができます。

00:38:19.000 --> 00:38:26.000
そして、それはあなたのiPadでSwiftUIを使用してアプリを作成する機能を備えたSwift Playgrounds 4を簡単に見ることができます。

00:38:26.000 --> 00:38:29.000
Swift Playgrounds 4は今年後半に利用可能になります。

00:38:29.000 --> 00:38:36.000
私たちは、あなたがどこに行っても、どのデバイスでも、あなたのアプリのアイデアを開発する自由を持つことを愛することを知っています。

00:38:36.000 --> 00:38:43.000
そして今、私はそれをスーザンに返します。

00:38:43.000 --> 00:38:51.000
私たちが世界を体験する方法の多くはビジュアルコミュニケーションであり、それはAppleデバイスを使用する上で大きな部分を占めています。

00:38:51.000 --> 00:39:08.000
Apple WatchのAlways on Displayをちらっと見たり、iPad Proでビデオツールを操作しながらProMotionを楽しんだり、iPhoneでゲームをプレイしたり、Macで没入型の3Dコンテンツを作成したりするなど、グラフィックス、ディスプレイ、拡張現実のための当社の技術は前面と中心です。

00:39:08.000 --> 00:39:15.000
そして今、マイラとエリックは、拡張現実から始めて、今年の新機能を説明します。

00:39:15.000 --> 00:39:23.000
ARは強力な技術であり、何千人もの人々がすでにアプリでそれを使用して、私たち全員が働き、遊び、自分自身を表現する方法を変革しています。

00:39:23.000 --> 00:39:33.000
今日、世界中で10億台以上のAR対応のiPhoneとiPadで、アプリにAR体験を追加したり、まったく新しいアプリを構築したりするのに、これほど良い時期はありません。

00:39:33.000 --> 00:39:41.000
歴史的に、優れたARアプリを構築するには、3Dモデリングに関する深い知識と洗練されたレンダリングエンジンの習得が必要でした。

00:39:41.000 --> 00:39:47.000
しかし、私たちは皆さんが素晴らしいAR体験を創造できることを望んでいます。

00:39:47.000 --> 00:39:52.000
そのため、ARを簡単に使い始めるための一連のテクノロジーをリリースしました。

00:39:52.000 --> 00:40:01.000
そのうちの1つは、AR用にゼロから構築された3Dレンダリング、オーディオ、アニメーション、物理エンジンであるRealityKitです。

00:40:01.000 --> 00:40:10.000
RealityKitは、フォトリアリスティックなレンダリングと、ノイズやモーションブラーなどのカメラエフェクトを特徴とする、没入型AR体験のレンダリングをシンプルにします。

00:40:10.000 --> 00:40:21.000
RealityKitはまた、LiDARスキャナーのような最新のハードウェアを利用して、仮想オブジェクトが人やオブジェクトのオクルージョンと一緒に実際にそこにいたように振る舞うことを可能にします。

00:40:21.000 --> 00:40:23.000
そして、それはすべてSwiftで書かれています。

00:40:23.000 --> 00:40:37.000
本日、RealityKit 2を発表します。これは、より多くのビジュアル、オーディオ、アニメーションのコントロールを提供し、3Dモデルを作成するという優れたARアプリの作成の最も難しい部分に取り組む大きなアップデートです。

00:40:37.000 --> 00:40:44.000
以前に作成したことがあるなら、単一のモデルを作るのに数時間と数千ドルかかることを知っています。

00:40:44.000 --> 00:40:58.000
これで、Object Captureを使用すると、iPhoneを使用してオブジェクトの2D画像をキャプチャし、MacのObject Capture APIを使用して、これらの画像をAR用に最適化されたリアルな3Dモデルに変換して、数分で3Dモデルを作成できます。

00:40:58.000 --> 00:41:00.000
このプロセスはとても簡単です。

00:41:00.000 --> 00:41:11.000
オブジェクトの反転と自動フォアグラウンドセグメンテーションをサポートしているため、iPhoneまたはiPadで一連の写真を撮って、下部を含むオブジェクトのすべての角度をキャプチャすることから始めます。

00:41:11.000 --> 00:41:17.000
ワークフローを合理化するための優れたガイドを提供するQloneのようなアプリを使用できます。

00:41:17.000 --> 00:41:23.000
次に、Object Capture APIを使用して、3Dモデルを生成するのに数行のコードしかかかりません。

00:41:23.000 --> 00:41:30.000
RealityKitで、キャプチャした画像のフォルダを指す新しいフォトグラメトリセッションを開始します。

00:41:30.000 --> 00:41:36.000
次に、プロセス関数を呼び出すと、目的の詳細レベルでモデルが生成されます。

00:41:36.000 --> 00:41:37.000
そんなに簡単だよ！

00:41:37.000 --> 00:41:49.000
オブジェクトキャプチャを使用すると、ARクイックルック用に最適化されたUSDZファイルを生成できるため、ユーザーはメッセージ、メール、Safari、その他のアプリで表示できます。

00:41:49.000 --> 00:41:59.000
また、レイトレーシングやその他のポストプロダクションワークフローに使用できるObject Capture APIからUSDまたはOBJアセットバンドルを生成することもできます。

00:41:59.000 --> 00:42:03.000
現実世界のオブジェクトを3Dモデルに変えることは、かつてないほど簡単になりました。

00:42:03.000 --> 00:42:21.000
サンプルコードで今日からオブジェクトキャプチャの使用を開始できます。また、主要な3Dコンテンツ作成ツールのいくつかと協力して、今年後半に利用可能なUnity Mars、Cinema 4D、Qloneなど、すでに使用している多くのプロアプリにこのワークフローを組み込んでいます。

00:42:21.000 --> 00:42:29.000
オブジェクトキャプチャモデルをXcodeに持ち込み、新しいRealityKit APIを使用してエフェクトを追加するのは簡単です。

00:42:29.000 --> 00:42:39.000
私のチームと私は、お気に入りの食べ物をスキャンしてオブジェクトキャプチャをテストし、料理のARプレビューを含むレシピを共有するためにARアプリクリップを構築しました。

00:42:39.000 --> 00:42:52.000
Qloneを使って捕獲したチョコレートクロワッサンは、実際には私のチームの誰かが焼いたクロワッサンの仮想レプリカであり、アプリクリップに別のレシピとして追加したいと思います。

00:42:52.000 --> 00:42:58.000
クロワッサンの3DモデルをARAppプロジェクトにドラッグすることから始めます。

00:42:58.000 --> 00:43:06.000
次に、ARKitを使用してApp Clip Codeに固定し、アセットのModelEntityを初期化します。

00:43:06.000 --> 00:43:15.000
アプリクリップを展開する前に、プロジェクトの構築中はいつでもXcode Quicklookで3Dモデルを直接完全に調べることができます。

00:43:15.000 --> 00:43:24.000
App Clipの新しいRealityKit APIを使用して、各ARディッシュにエフェクトを追加して、より現実的なものにしました。

00:43:24.000 --> 00:43:32.000
RealityKitはネイティブレンダリングエンジンであるため、複数のARシーンやレシピをApp Clipに収めることができます。

00:43:32.000 --> 00:43:39.000
調べてみましょう。

00:43:39.000 --> 00:43:46.000
アプリクリップコードをスキャンすると、アプリクリップが起動し、チョコレートクロワッサンを右上に固定します。

00:43:46.000 --> 00:43:55.000
クロワッサンをより現実的にするために、新しいRealityKitカスタムサーフェスシェーダーを使用して、発光光を追加し、アンビエントオクルージョンを引き戻しました。

00:43:55.000 --> 00:43:59.000
焼いたステーキなど、チームからさらにいくつかの料理を見てみましょう。

00:43:59.000 --> 00:44:08.000
ここでは、新しいProcedural Geometry APIでスチームエフェクトを作成して、フリップブックシェーダーにレイヤー化することで、カスタムサーフェスシェーダーに追加しました。

00:44:08.000 --> 00:44:13.000
蒸気は手続き的であるため、このピザのような多くのレシピで同じ効果を使用することができます。

00:44:13.000 --> 00:44:19.000
蒸気効果がピザのサイズとともに手続き的にどのように拡大したかに注目してください。

00:44:19.000 --> 00:44:26.000
このバーベキューチキン料理には、この料理がスパイシーであることを示すために、フルスクリーンのポスト処理火災効果を追加しました。

00:44:26.000 --> 00:44:36.000
そして最後に、私たちは炎を落とし、代わりに新しい計算シェーダーとジオメトリ修飾子を使用して、バースデーケーキの周りにお祝いの紙吹雪を追加しました。

00:44:36.000 --> 00:44:47.000
ご覧のとおり、私たちはより多くのカスタマイズにRealityKitレンダリングを開放し、これらの新しいAPIの使用方法に関するあなたの創造性を見るのが待ちきれません。

00:44:47.000 --> 00:44:59.000
これらは、すべての開発者が3Dモデルを作成して、より没入感のあるリアルなAR体験を構築することを可能にする、ARのエキサイティングな新しい改善のほんの一部です。

00:44:59.000 --> 00:45:05.000
ARKitとRealityKitで行うことの基本的な側面の1つは、グラフィックス技術です。

00:45:05.000 --> 00:45:09.000
そして、エリックは最新情報を教えてくれます。

00:45:09.000 --> 00:45:18.000
Appleで製品を構築する方法のコアアイデアは、最も素晴らしいハードウェアとソフトウェアをまとめることであり、グラフィックスへのアプローチはその理想を反映しています。

00:45:18.000 --> 00:45:30.000
長年にわたり、Appleが設計したiPhoneとiPad用の強力なGPUを提供し、MetalグラフィックスとコンピューティングAPIと組み合わせて、製品を最大限に活用できるようにしてきました。

00:45:30.000 --> 00:45:52.000
そして今、M1チップでは、最新のMacとiPad Proで前例のないレベルのグラフィックス性能と電力効率を提供しているだけでなく、iPhoneからiPad、Macまで、Metal、Apple GPU、ユニファイドメモリに基づく共通のアーキテクチャを備えた統一されたAppleグラフィックスプラットフォームを作成しました。

00:45:52.000 --> 00:45:55.000
そして、このプラットフォームは根本的な変化を可能にします。

00:45:55.000 --> 00:46:05.000
以前はハイエンドワークステーションやディスクリートGPUゲーミングコンピュータを必要としていたグラフィックスワークロードが、最も人気のある製品で可能になりました。

00:46:05.000 --> 00:46:17.000
たとえば、この統一されたプラットフォームのコンソールレベルのパフォーマンスにより、ラリアンのような開発者はAAAゲームであるDivinity Original Sin 2をMacに、そしてiPadに持ち込むことができました。

00:46:17.000 --> 00:46:27.000
そして、Deep SilverはM1とMetalの最新のシェーダーパイプラインを使用して、Mac用のサバイバルゲームMetro Exodusで高性能で没入型グラフィックスを実現しています。

00:46:27.000 --> 00:46:31.000
しかし、このグラフィックプラットフォームはゲームのためだけではありません。

00:46:31.000 --> 00:46:46.000
MetalコンピューティングAPIは現在、OTOYのまったく新しいOctane XやCinema 4DのMaxonのRedshiftレンダラーなど、次世代のプロフェッショナルGPUレンダラーを加速しており、Macで初めてMetal-acceleratedを実行しています。

00:46:46.000 --> 00:47:00.000
そのため、Appleのすべての強力なデバイスにグラフィックアプリとゲームをもたらすために、今年は高度なグラフィックスとゲーム機能、強力なグラフィック開発者ツールの2つの大きな分野に焦点を当てました。

00:47:00.000 --> 00:47:27.000
まず、現代のハイエンドゲームとGPUレンダリングアルゴリズムに不可欠な3つの主要機能に焦点を当てました。複雑な数学的操作を加速し、光の動作をモデル化し、現実的な表面を表現するために、現代のGPUレンダラーは同じパイプラインでMetalグラフィックスとコンピューティングコマンドをインターリーブする必要があるため、Metalはグラフィックシェーダーから直接動的ライブラリとRay Queryプリミティブを呼び出すことができます。

00:47:27.000 --> 00:47:34.000
また、Metal Ray Tracing APIの新しいStochastic Motion Blur機能を使用して、さらにフォトリアルなレンダリングを作成できます。

00:47:34.000 --> 00:47:42.000
ゲームがより低いレイテンシとより少ないジャダーでより高いフレームレートを達成するためには、開発者はディスプレイをより詳細に制御する必要があります。

00:47:42.000 --> 00:47:57.000
これを達成し、最新のiPad Proの素晴らしいグラフィックスパフォーマンスを活用するために、ゲームはMetalプレゼンテーションタイムAPIとProMotionディスプレイを使用して、レンダリングと入力の間の希望するレイテンシーに基づいてアプリのフレームレートを動的に調整できます。

00:47:57.000 --> 00:48:02.000
また、macOS MontereyはAdaptive Sync Displaysのサポートを追加します。

00:48:02.000 --> 00:48:10.000
これは、Macゲームでもこれらの超低遅延と可変リフレッシュレートディスプレイを利用できるようになったことを意味します。

00:48:10.000 --> 00:48:16.000
現在、高度なグラフィックスを備えたハイエンドゲームは、多くの場合、ゲームコントローラーを入力として使用して設計されています。

00:48:16.000 --> 00:48:23.000
また、ゲームコントローラーのサポートを追加することは、共通の入力モデルを使用して、ゲームを統一されたグラフィックプラットフォームに持ち込む強力で簡単な方法です。

00:48:23.000 --> 00:48:35.000
当社のゲームコントローラーフレームワークは、最新のXbox Series XワイヤレスコントローラーとPlayStation 5 DualSenseコントローラーのサポートを含む、最も人気のあるコントローラーをサポートしています。

00:48:35.000 --> 00:48:46.000
コントローラーベースのゲームをiPhoneやiPadにさらに簡単に持ち込むために、わずか数行のコードで画面上の仮想ゲームコントローラーを有効にできるように、新しいAPIを追加しました。

00:48:46.000 --> 00:49:04.000
macOS MontereyとiPadOS 15では、プレイヤーは友達がプレイしているゲームを見つけ、アプリライブラリに直接移動してゲームを起動し、「共有」ボタンを押してお気に入りのゲームのハイライトを記録することができるため、ゲームコントローラーのサポートはこれまで以上に価値があります。

00:49:04.000 --> 00:49:18.000
現在、これらの新しい高度なAPIと機能とともに、Xcode 13は、GPUコードを最適化およびデバッグするための強力な新しいグラフィックス開発者ツールを追加し、それぞれが最新のハイエンドゲームやグラフィックスアプリケーションを次のレベルに引き上げるように設計されています。

00:49:18.000 --> 00:49:23.000
まず、高度なGPUレンダラーやゲームを構築するとき、GPUシェーダーは本当に大きくなる可能性があります。

00:49:23.000 --> 00:49:30.000
並行して実行されている何千ものワークグループで10,000行のシェーダーコードをデバッグするには、本当に長い時間がかかることがあります。

00:49:30.000 --> 00:49:34.000
このプロセスを合理化するために、Xcode 13は選択的シェーダーデバッグを追加します。

00:49:34.000 --> 00:49:41.000
ここでは、選択的シェーダーデバッグを使用して、はるかに大きなGPUシェーダー内で、デバッグする機能を正確に選択しています。

00:49:41.000 --> 00:49:51.000
これにより、最大のシェーダーの反復とデバッグにかかる時間を大幅に短縮できるため、より迅速に開発でき、GPUコードに機能とパフォーマンスを追加することに集中できます。

00:49:51.000 --> 00:50:18.000
次に、ハイエンドのAAAゲームには、最新のテクスチャ圧縮サポートも必要です。そのため、強力なメタルテクスチャコンバータツールを更新して、テクスチャコンバータ圧縮パイプラインを直接制御し、まったく新しいガンマ認識ピクセル変換を追加し、Mac、PC、iOSゲームで使用される最新のASTCおよびBCテクスチャ圧縮フォーマットのサポートを大幅に拡張しました。

00:50:18.000 --> 00:50:23.000
これにより、Appleの各デバイスに対してゲームのテクスチャアセットを最適化することがさらに簡単になります。

00:50:23.000 --> 00:50:33.000
最後に、最先端のレンダリングでピークパフォーマンスを達成するために、Xcode 13はMetal Debuggerにまったく新しいGPUタイムラインビューを追加します。

00:50:33.000 --> 00:50:47.000
この強力な新しいビューでは、強力なパフォーマンスカウンターとボトルネック分析情報に加えて、イベントのタイムラインで、Metalコマンド、リソース、バッファを視覚的にデバッグする最高のものを組み合わせることができます。

00:50:47.000 --> 00:51:05.000
Apple CPU、GPU、Metalを使用して、10億台以上のデバイスを備えた統合グラフィックスプラットフォームを作成し、最新の機能と開発者ツールを使用して、グラフィックス、プロアプリ、ゲームのまったく新しいレベルの機能とパフォーマンスを解き放つことができます。

00:51:05.000 --> 00:51:13.000
そして今、あなたに戻ります、スーザン。

00:51:13.000 --> 00:51:21.000
あなたのアプリは、人々をアイデア、サービス、ツール、そして最も重要なのは、他の人と結びつけるのに役立ちます。

00:51:21.000 --> 00:51:43.000
バランスを見つけることは接続と同じくらい重要なので、今年はユーザーが適切なタイミングでアプリに集中し、プライバシーを尊重しながら愛する人のデバイスを管理し、アプリのコンテンツをAppleプラットフォーム全体で構築された新しい、共有された、親密な体験の中心にすることができます。

00:51:43.000 --> 00:51:49.000
私たちはあなたのアプリがそのような関係を作成するのに役立つ強力な新しいAPIセットを作成しました。

00:51:49.000 --> 00:51:53.000
ヒーナとマットから始めて、フォーカスについて教えてください。

00:51:53.000 --> 00:52:00.000
iOS 15は、人々が集中するのに役立つ強力な新しいツールセットを導入しています。

00:52:00.000 --> 00:52:04.000
これらのツールは、人々がその瞬間にいることができるように、気晴らしを減らすのに役立ちます。

00:52:04.000 --> 00:52:08.000
そして、それは通知に対する全く新しいアプローチから始まります。

00:52:08.000 --> 00:52:11.000
ロック画面に積み上げられた通知をいくつか紹介します。

00:52:11.000 --> 00:52:14.000
彼らの緊急性のレベルは明らかに異なります。

00:52:14.000 --> 00:52:17.000
しかし、彼らは皆同じように振る舞った。

00:52:17.000 --> 00:52:21.000
彼らは同じ外観、同じ触覚、同じ明らかな重要性を持っていました。

00:52:21.000 --> 00:52:29.000
今、新しい中断レベルAPIでは、アプリがさまざまなレベルの緊急性を伝えるためのより微妙な方法があります。

00:52:29.000 --> 00:52:32.000
通知には、4つの中断レベルのいずれかを割り当てることができます。

00:52:32.000 --> 00:52:36.000
受動的な中断は静かで、デバイスを目覚めさせません。

00:52:36.000 --> 00:52:39.000
人々は次に電話を取るときに彼らに会うでしょう。

00:52:39.000 --> 00:52:43.000
これらを、時間に敏感ではない通知に使用することをお勧めします。

00:52:43.000 --> 00:52:48.000
アクティブな中断は、今日の通知と同じように音や触覚を再生します。

00:52:48.000 --> 00:52:55.000
時間に敏感な中断は、ユーザーがタップしていない場合、視覚的に目立ち、ロック画面に少し長くハングアップするように設計されています。

00:52:55.000 --> 00:52:59.000
また、誰かがAirPodsを着用している場合は、Siriによっても発表されます。

00:52:59.000 --> 00:53:04.000
そして、あなたはすぐに注意を必要とする通知にこれを使用したいと思うでしょう。

00:53:04.000 --> 00:53:06.000
クリティカルアラートは最も緊急なカテゴリです。

00:53:06.000 --> 00:53:09.000
デバイスがミュートされていても、彼らは音を再生します。

00:53:09.000 --> 00:53:17.000
これらは非常に深刻な健康と安全上の懸念のためだけに予約されており、承認された資格が必要です。

00:53:17.000 --> 00:53:22.000
特別な注意に値する通知の別のカテゴリがあります:人々からのコミュニケーション。

00:53:22.000 --> 00:53:28.000
コミュニケーションアプリをお持ちの場合は、メッセージと通話通知についてシステムに伝えることが重要です。

00:53:28.000 --> 00:53:34.000
その後、システムはこの情報を使用して通知の外観と行動を調整し、人々がそれらをよりよく解釈するのに役立ちます。

00:53:34.000 --> 00:53:47.000
実装されると、通知は標準的な外観からこのようになります。アプリのアイコンが重ねられた目立つアバターが特徴で、同じアバターがシェアシートのようにシステム内の他の場所で使用されます。

00:53:47.000 --> 00:53:50.000
私はそれらのアバターを見てとても興奮しています!

00:53:50.000 --> 00:53:55.000
さて、通知は人々の注意を引くための本当に効果的な方法です。

00:53:55.000 --> 00:53:57.000
しかし、彼らはまた、一種の一時的なものになる可能性があります。

00:53:57.000 --> 00:54:00.000
彼らがタイミングが良くなければ、人々は簡単にそれらを見逃すことができます。

00:54:00.000 --> 00:54:12.000
ユーザーが自分の時間に通知に参加できるように、通知サマリーを導入しています。これは、ユーザーが選択した時に便利なバンドルとして通知を配信し、最適なときにすぐに追いつくことができます。

00:54:12.000 --> 00:54:20.000
サマリーは、ユーザーが選択したアプリからのパッシブ通知とアクティブ通知をバンドルし、美しいレイアウトで表示します。

00:54:20.000 --> 00:54:23.000
その後、見られるまでしばらくロック画面に固執します。

00:54:23.000 --> 00:54:27.000
要約はまた、ユーザーごとにパーソナライズされています。

00:54:27.000 --> 00:54:30.000
ご覧のとおり、上部に2つのマーキースロットがあります。

00:54:30.000 --> 00:54:38.000
そこで特集されているのは、いくつかの要因に基づいています。まず、多様性を提供するために、これらの2つのアプリは要約の中からサンプリングされます。

00:54:38.000 --> 00:54:41.000
そこから、私たちはいくつかの追加の重み付けを行います。

00:54:41.000 --> 00:54:45.000
大きなサムネイル付きの通知は、常にサムネイルのない通知よりも選択されます。

00:54:45.000 --> 00:54:52.000
そして、あなたが決定した最も高い関連性スコアを持つ通知は、同じアプリから他の通知よりも選択されます。

00:54:52.000 --> 00:55:00.000
さて、あなたは「私のアプリはどのようにして要約に終わるのか」と疑問に思うかもしれません。まず、通知の概要を使用するかどうかは、完全にユーザー次第です。

00:55:00.000 --> 00:55:05.000
そして、もしそうなら、最も多くの通知を送信するアプリが提案されます。

00:55:05.000 --> 00:55:10.000
ユーザーは、どのアプリが要約に入るか、それを受け取る時間もカスタマイズできます。

00:55:10.000 --> 00:55:16.000
アプリがスケジュールされたサマリーに配置されている場合、リアルタイムでユーザーに連絡する方法はまだあります。

00:55:16.000 --> 00:55:20.000
そこで、時間に敏感な通知が届きます。

00:55:20.000 --> 00:55:24.000
この中断レベルを使用する通知は、すぐに配信されます。

00:55:24.000 --> 00:55:31.000
通知が即時の注意を必要とし、その瞬間に関連している場合にのみ、通知をタイムセンシティブとしてマークする必要があることを忘れないでください。

00:55:31.000 --> 00:55:35.000
邪魔をしない以上に気を散らす機能はありません。

00:55:35.000 --> 00:55:40.000
しかし、Do Not Disturbはすべての通知を沈黙させ、ユーザーにより多くの柔軟性を与えたいと考えました。

00:55:40.000 --> 00:55:47.000
Focusを使用すると、ユーザーは現在行っていることに基づいて、通知を受け取る必要があるアプリや人を選択できます。

00:55:47.000 --> 00:55:53.000
彼らは仕事のために一日を切り開くか、ゲーム、読書、フィットネスなどの活動のための焦点を作成することができます。

00:55:53.000 --> 00:55:59.000
フォーカスにいる間、ユーザーは自分のステータスを他の人と共有できるので、中断しないように知っています。

00:55:59.000 --> 00:56:04.000
しかし、それが本当に緊急であれば、メッセージはとにかく突破して通知することができます。

00:56:04.000 --> 00:56:09.000
コミュニケーションアプリは、ユーザーのフォーカスステータスへのアクセスをリクエストすることもできます。

00:56:09.000 --> 00:56:16.000
許可された場合、システムは変更時にアプリに通知されるため、アプリはステータスをシステムの残りの部分と同期させることができます。

00:56:16.000 --> 00:56:21.000
あなたのアプリは、緊急のコミュニケーションのために突破する機能をユーザーに提供することもできます。

00:56:21.000 --> 00:56:26.000
私たちは、通知を管理するためのこれまで以上に多くのコントロールと柔軟性をユーザーに提供しています。

00:56:26.000 --> 00:56:34.000
また、これらのツールが機能していることを確認するために、システムは定期的にチェックインして、設定の特定の調整が役立つかどうかを確認します。

00:56:34.000 --> 00:56:38.000
これは、ユーザーがアプリや通知とどのようにやり取りするかに基づいています。

00:56:38.000 --> 00:56:46.000
したがって、ユーザーが通常フォーカス中にアプリを使用している場合、システムはそのフォーカス中にそのアプリの通知を許可することを提案するかもしれません。

00:56:46.000 --> 00:56:53.000
または、ユーザーがアプリのタイムセンシティブ通知を操作している場合、システムはそれらをアクティブな通知に戻すことを提案するかもしれません。

00:56:53.000 --> 00:56:59.000
アプリが次々と通知を送信し、ユーザーが関与していない場合も同様です。

00:56:59.000 --> 00:57:07.000
システムは、そのアプリからのすべての通知をミュートするか、限られた時間だけの会話でミュートすることを提案するかもしれません。

00:57:07.000 --> 00:57:11.000
したがって、これらの新機能を最大限に活用するには、必要な重要なことがいくつかあります。

00:57:11.000 --> 00:57:21.000
通知に関連性スコアを設定し、適切なサムネイルを添付することで、要約の上部にあるマーキースロットに適切なコンテンツが紹介されていることを確認するのに役立ちます。

00:57:21.000 --> 00:57:26.000
どの中断レベルが通知に理にかなっているかを慎重に考える必要があります。

00:57:26.000 --> 00:57:33.000
コミュニケーションアプリをお持ちの場合は、新しいユーザー通知APIを採用して、メッセージと通話通知をシステムに伝える必要があります。

00:57:33.000 --> 00:57:39.000
また、新しいフォーカスステータスAPIを使用して、ユーザーのフォーカスをアプリに反映する必要があります。

00:57:39.000 --> 00:57:45.000
これらのツールは、あなたの助けを借りて、ユーザーが気晴らしを減らすのに大いに役立つと思います。

00:57:45.000 --> 00:57:49.000
次に、マーティンは新しいスクリーンタイムAPIについて教えてくれます。

00:57:49.000 --> 00:57:50.000
ありがとう、マット。

00:57:50.000 --> 00:57:55.000
さて、スクリーンタイムとペアレンタルコントロールについて話すためにギアを切り替えましょう。

00:57:55.000 --> 00:58:04.000
私たちは、親が子供たちが健康的なデジタル生活を築くのを助けるために近代的で革新的なソリューションを必要としていることを認識しており、家族のプライバシーも深く大切にしています。

00:58:04.000 --> 00:58:09.000
そして、私たちはこれらのユーザーのニーズに応えるために、あなたの多くからの食欲を見てきました。

00:58:09.000 --> 00:58:18.000
そこで今日、私たちはプライバシーへの深いコミットメントに基づいて構築されたオーダーメイドのペアレンタルコントロールフレームワークのセットであるScreen Time APIをリリースします。

00:58:18.000 --> 00:58:22.000
スクリーンタイムAPIでは、3つの重要な目標を念頭に置いていました。

00:58:22.000 --> 00:58:26.000
ペアレンタルコントロールアプリを開発するための最新のソリューションを提供します。

00:58:26.000 --> 00:58:32.000
ダイナミックな体験を構築し、今日のスクリーンタイムが提供するものを超えて革新できるようにします。

00:58:32.000 --> 00:58:35.000
そして、ユーザーのプライバシーを保護するために。

00:58:35.000 --> 00:58:47.000
そのために、ペアレンタルコントロールの世界で革新することを可能にする3つの新しいSwiftフレームワークをiOS SDKに追加しました：マネージド設定、ファミリーコントロール、デバイスアクティビティ。

00:58:47.000 --> 00:58:50.000
まず、管理された設定について話しましょう。

00:58:50.000 --> 00:59:01.000
基本的に、ペアレンタルコントロールアプリには、子供がデバイス間でできることを制限し、親がそうでないと言うまでそれらの制限が維持されるようにする方法が必要です。

00:59:01.000 --> 00:59:14.000
管理された設定を使用すると、アプリは、スクリーンタイムのように、アカウントのロック、パスワード変更の防止、Webトラフィックのフィルタリング、アプリケーションへのアクセスの制限など、多くの制限を設定できます。

00:59:14.000 --> 00:59:18.000
アプリのブランディングと機能でカスタマイズされています。

00:59:18.000 --> 00:59:24.000
このフレームワークを活用することで、アプリはこれらの制限をすべて管理できるようになります。

00:59:24.000 --> 00:59:33.000
制限を超えて、必要に応じてアプリやウェブサイトへのアクセスを制限し、ユースケースに固有の一連のアクションを提供することができます。

00:59:33.000 --> 00:59:43.000
そして最後に、親の明示的な承認がある場合にのみ削除できるように、アプリを所定の位置にロックします。

00:59:43.000 --> 00:59:50.000
現在、ファミリーコントロールフレームワークは、当社のプライバシーモデルの中心であり、2つの主要なユーザー向けエクスペリエンスを提供します。

00:59:50.000 --> 00:59:58.000
まず、親がiCloudの資格情報を使用してアプリの管理を承認し、デバイスがその家族の子供用であることを保証します。

00:59:58.000 --> 01:00:10.000
また、システムアプリとウェブサイトピッカーを介してパーソナライズされた体験を提供します。これにより、保護者はユーザーのプライバシーを保護しながら、制限するアプリやサイトを選択できます。

01:00:10.000 --> 01:00:21.000
私たちは、親が子供が使用するアプリやウェブサイトを管理および制限できるようにしたかったが、プライベートアプリケーションやウェブブラウジングの詳細を漏らさない方法でそうしたい。

01:00:21.000 --> 01:00:28.000
したがって、生のバンドルIDとURLの選択を返すのではなく、ピッカーは代わりに不透明なトークンを返します。

01:00:28.000 --> 01:00:40.000
これらのトークンを使用すると、親が管理したいアプリやウェブサイトをアプリが追跡でき、親がこの機密性の高い情報にアクセスできるのは親だけです。

01:00:40.000 --> 01:00:44.000
そして、これらのトークンは、これらすべてのフレームワークで機能を有効にします。

01:00:44.000 --> 01:00:58.000
トークンを使用して、管理された設定で特定のアプリやウェブサイトへのアクセスを制限したり、デバイスアクティビティフレームワークを使用して、今日までiOSでは不可能だったアプリやウェブサイトのアクティビティに関する洞察を得ることができます。

01:00:58.000 --> 01:01:06.000
ファミリーコントロールのアクティビティピッカーが提供するトークンを使用すると、デバイスアクティビティの力を活用する準備が整いました。

01:01:06.000 --> 01:01:15.000
さまざまなアプリやアクティビティに一意のタイムウィンドウを登録することができ、それぞれに「あと5分」などの警告と完了イベントが発令されます。

01:01:15.000 --> 01:01:25.000
アプリがこれらのイベントを受信すると、制限を変更したり、関連するアプリやウェブサイトへのアクセスを制限したりすることで、それに応じて反応することができます。

01:01:25.000 --> 01:01:28.000
子供たちに宿題をするように励ます。

01:01:28.000 --> 01:01:33.000
ユーザーに提供しようとしている経験が何であれ。

01:01:33.000 --> 01:01:46.000
ブラウザのアクティビティだけでなく、デバイス上のすべてのアプリでデバイスのアクティビティを見るというこの概念はまったく新しく、ペアレンタルコントロールの世界で革新するユニークな機会です。

01:01:46.000 --> 01:01:57.000
スクリーンタイムAPIを使用すると、家族全体のダウンタイムを有効にしたり、宿題をした後にゲームのロックを解除するなど、教育的なことの後に何か楽しいことをするインセンティブを作成することもできます。

01:01:57.000 --> 01:02:05.000
私たちは、親や家族が私たちのデバイスを使用する方法を管理するのを助けるために、あなたがこれらのAPIをどのように構築するかを見て非常に興奮しています。

01:02:05.000 --> 01:02:09.000
そして今、Widgetsの新機能を教えてください。

01:02:09.000 --> 01:02:13.000
昨年、私たちはホーム画面にウィジェットを導入しました。

01:02:13.000 --> 01:02:15.000
そして人々は彼らを愛していました。

01:02:15.000 --> 01:02:24.000
ウィジェットは、アプリから最も関連性の高いコンテンツの楽しくタイムリーなビューで深いパーソナライゼーションを提供します。

01:02:24.000 --> 01:02:27.000
それらはすべて一目見やすさに関するものです。

01:02:27.000 --> 01:02:36.000
人々は、ウィジェットがアプリから最も有用な情報を一目で、正確に適切なタイミングで提示する方法が大好きです。

01:02:36.000 --> 01:02:39.000
タップすると、アプリの右側にディープリンクできます。

01:02:39.000 --> 01:02:46.000
過去1年間で、あなたは本当に私たちにインスピレーションを与えたいくつかの素晴らしいウィジェット体験を作成しました。

01:02:46.000 --> 01:02:52.000
最高のウィジェットは、集中的でダイナミックで、一日を通してアプリのユニークなビューを提供します。

01:02:52.000 --> 01:02:54.000
このように、初日から。

01:02:54.000 --> 01:02:57.000
それはサンタクルーズへの旅行中の私と私の子供たちです。

01:02:57.000 --> 01:03:06.000
適切なコンテキストで適切なコンテンツを浮上させることは、ユーザーがアプリの魔法を発見するのに役立ちます。

01:03:06.000 --> 01:03:12.000
そして、ウィジェットは人々があなたのアプリをさらに使用することを奨励しているのを見てきました。

01:03:12.000 --> 01:03:20.000
今年は、ウィジェットでアプリをより便利で見つけやすくするための次のステップを踏み出します。

01:03:20.000 --> 01:03:28.000
そして、それは人々がiPadのホーム画面であなたのアプリの中にウィジェットを配置させることから始まります。

01:03:28.000 --> 01:03:36.000
大画面を利用するために、ウィジェット用の新しい特大サイズを導入しています。

01:03:36.000 --> 01:03:45.000
これは、iPadで最もよく機能するまったく新しいタイプのウィジェットのための全く新しい機会を意味します。

01:03:45.000 --> 01:03:56.000
ウィジェットへの追加をさらに簡単にするために、iPhoneとiPadのウィジェットで新しいデフォルトのホーム画面レイアウトを追加します。

01:03:56.000 --> 01:04:02.000
これらには、スマートスタックに配置された、人々が最もよく使用するアプリのウィジェットが含まれます。

01:04:02.000 --> 01:04:07.000
スタックを使用すると、複数のウィジェットを互いの上に配置することで、スペースを節約できます。

01:04:07.000 --> 01:04:14.000
スマートスタックは、デバイス上のインテリジェンスを使用して、現在最も関連性の高いウィジェットを表示します。

01:04:14.000 --> 01:04:24.000
昨年のTimelineRelevance APIの基盤に基づいて、私たちは単にデバイス上のインテリジェンスでスタックを回転させるだけではありません。

01:04:24.000 --> 01:04:32.000
今、私たちは、それがまだスタックになかった場合でも、それを提案することによって、あなたのウィジェットにより多くの露出を与えることができます。

01:04:32.000 --> 01:04:33.000
そして、私たちはこれをどのように行うのですか?

01:04:33.000 --> 01:04:36.000
ウィジェットの提案を入力します。

01:04:36.000 --> 01:04:43.000
人々があなたのアプリとどのようにやり取りするか、そしてあなたが私たちに何を伝えることができるかは、スタック内のウィジェットを提案するのに役立ちます。

01:04:43.000 --> 01:04:48.000
これがFrutaの例アプリでどのように機能するか見てみましょう。

01:04:48.000 --> 01:04:55.000
ユーザーが毎朝グリーンジュースを注文した場合、デバイス上のインテリジェンスはそれを提案することを学びます。

01:04:55.000 --> 01:05:00.000
オプトインするには、インテントフレームワークを採用し、インタラクションを寄付する必要があります。

01:05:00.000 --> 01:05:01.000
それでおそれ！

01:05:01.000 --> 01:05:07.000
これで、あなたのウィジェットは、人々があなたのアプリをどのように使用するかに基づいて自動的に提案することができます。

01:05:07.000 --> 01:05:13.000
ユーザーに新しい情報を提供したい場合は、Intents APIを使用して寄付することもできます。

01:05:13.000 --> 01:05:20.000
たとえば、Frutaアプリはこれを採用して、無料のバースデースムージーを提供できます。

01:05:20.000 --> 01:05:30.000
過去の使用行動と新しい関連する意図の寄付の両方は、適切なタイミングでスタック内のウィジェットを提案するのに役立ちます。

01:05:30.000 --> 01:05:36.000
また、ユーザーがウィジェットが役に立つと感じた場合は、長押しで永久に簡単に追加できます。

01:05:36.000 --> 01:05:40.000
これが今年のウィジェットの大きなアップデートです。

01:05:40.000 --> 01:05:44.000
これまで以上に便利で、発見しやすい。

01:05:44.000 --> 01:05:48.000
次はSharePlayに関するいくつかのニュースです。

01:05:48.000 --> 01:05:50.000
ライアンとフアンへ。

01:05:50.000 --> 01:05:55.000
今年、私たちは皆、新しい接続方法を見つけるために即興でやらなければなりませんでした。

01:05:55.000 --> 01:06:02.000
そして、あなたの多くが革新し、人々が遠くにいる間に一体感を感じるための素晴らしい新しい方法を構築するのを見るのは印象的でした。

01:06:02.000 --> 01:06:13.000
そして、人々が接続を維持するためにこれまで以上にFaceTimeとiMessageに依存しているため、人々が離れているときに人々がより一緒に感じるのを助けるために、それらの経験に基づいて構築するのは当然のことでした。

01:06:13.000 --> 01:06:21.000
人々が一緒に過ごす最も有意義な瞬間のいくつかは、単に会話を共有するだけでなく、経験を共有することです。

01:06:21.000 --> 01:06:26.000
だから、その親密さの感覚を育むために、私たちは全く新しいものを構築する必要がありました。

01:06:26.000 --> 01:06:28.000
そして、私たちは野心的な目標を持っていました。

01:06:28.000 --> 01:06:36.000
私たちは、FaceTimeが人々を親しい友人や家族と同じ空間に運んだポータルのように感じてほしかった。

01:06:36.000 --> 01:06:38.000
そこで、私たちはSharePlayを構築しました。

01:06:38.000 --> 01:06:44.000
また、新しいGroupActivitiesフレームワークを使用して、魔法のSharePlayエクスペリエンスを作成するために必要なツールを提供します。

01:06:44.000 --> 01:06:47.000
私たちはグループを連れてきて、あなたは活動を持ってきます。

01:06:47.000 --> 01:06:51.000
そして、それはすべてこの活動の概念に帰着します。

01:06:51.000 --> 01:07:03.000
FaceTime通話の誰かがアクティビティを開始すると、SharePlayはグループを直接アプリに持ち込み、ユーザーが慣れているようにコミュニケーションできる豊かなインタラクティブな体験を可能にします。

01:07:03.000 --> 01:07:07.000
グループ活動の枠組みで探求する可能性はたくさんあります。

01:07:07.000 --> 01:07:16.000
そして、あなたの親しい友人の何人かとあなたのお気に入りの番組を見るよりも、あなたの仮想リビングルームで行うより良い活動は何ですか。

01:07:16.000 --> 01:07:21.000
ねえ、フアン、あなたのチームはSharePlayをテレビアプリに統合し終えたばかりなので、私たちに案内してみませんか？

01:07:21.000 --> 01:07:23.000
もちろんです！何を見たいですか？

01:07:23.000 --> 01:07:25.000
ちょっとした「テッド・ラッソ」はいかがですか?

01:07:25.000 --> 01:07:27.000
よさそうですね。

01:07:27.000 --> 01:07:32.000
再生を押すと、共有再生を開始するか、代わりにローカルで再生するかをシステムから求められます。

01:07:32.000 --> 01:07:34.000
ここがあなたの出番です。

01:07:34.000 --> 01:07:40.000
アプリの既存のビデオ体験にぴったり合うように設計された再生を開始するための新しいAPIを提供しています。

01:07:40.000 --> 01:07:49.000
今、私は共有再生を選んだので、システムは私のデバイスとライアンのビデオを、コアメディアとグループアクティビティとまったく同時に調整しています。

01:07:49.000 --> 01:07:55.000
つまり、私が一時停止を押すと、フアンのビデオはまったく同じ瞬間に一時停止します。

01:07:55.000 --> 01:08:01.000
私はお気に入りのシーンにジャンプすることさえでき、まるで私たち全員が同じ部屋にいるかのように、誰もが私と一緒に来ます。

01:08:01.000 --> 01:08:03.000
大丈夫？つまり、ねえ、ヒギンズと私は今日昼食を食べます。

01:08:03.000 --> 01:08:06.000
私はこのシーンが大好きです！

01:08:06.000 --> 01:08:11.000
この再生調整の背後にある魔法は、あなたのメディアがいかなる方法でも再送信されないことを意味します。

01:08:11.000 --> 01:08:17.000
アプリ内で再生され、いつものようにサーバーからストリーミングされるため、誰もがあなたの完全な忠実度のビデオを取得します。

01:08:17.000 --> 01:08:25.000
さて、シンプルなメディアアプリでグループアクティビティを採用し、フレームワークを最大限に活用することがどれほど簡単かを見てみましょう。

01:08:25.000 --> 01:08:28.000
アプリを共有再生に備えるには、いくつかの手順があります。

01:08:28.000 --> 01:08:32.000
まず、グループ活動を定義する必要があります。

01:08:32.000 --> 01:08:38.000
グループアクティビティプロトコルに準拠した新しいタイプを作成し、グループ内の全員がロードするためのURLを提供します。

01:08:38.000 --> 01:08:43.000
アプリがすでにコンテンツへのディープリンクをサポートしている場合は、ここで使用できます。

01:08:43.000 --> 01:08:51.000
また、確認ダイアログや通知などのシステムUIをカスタマイズするための基本的なメタデータをシステムに提供します。

01:08:51.000 --> 01:08:54.000
次に、再生ボタンを接続する必要があります。

01:08:54.000 --> 01:08:59.000
Play() 関数では、新しいアクティビティを作成し、その上で .prepareForActivation() を呼び出します。

01:08:59.000 --> 01:09:03.000
これは、システムが先ほど見た確認ダイアログを表示するときです。

01:09:03.000 --> 01:09:05.000
余分な条件なしでこれを呼び出すことができます。

01:09:05.000 --> 01:09:08.000
ユーザーがFaceTime通話をしていない場合は、すぐに戻ってきます。

01:09:08.000 --> 01:09:12.000
では、入ってくる活動の処理に注意を向けましょう。

01:09:12.000 --> 01:09:18.000
イニシエータは他の参加者と同じようにセッションに参加するので、コードは誰にとっても同じように見えます。

01:09:18.000 --> 01:09:24.000
ここでは、Swift並行性を使用して、配信されるセッションごとに新しいモデルを作成しています。

01:09:24.000 --> 01:09:28.000
その後、プレイヤーが表示されたら、新しいセッションに参加します。

01:09:28.000 --> 01:09:33.000
それに応じてUIを更新するために、他の状態の変更についてセッションを観察することができます。

01:09:33.000 --> 01:09:36.000
最後に、プレイヤーを同期させましょう。

01:09:36.000 --> 01:09:43.000
ステップ1：AVPlayerをつかみ、セッションで.playbackCoordinator.coordinate WithSessionパスを呼び出します。

01:09:43.000 --> 01:09:46.000
ステップ2：ステップ2はありません。

01:09:46.000 --> 01:09:47.000
それでおそれ！

01:09:47.000 --> 01:09:53.000
グループアクティビティやAVPlayerとフレーム正確なAV同期を取得するために必要なのはそれだけです。

01:09:53.000 --> 01:09:55.000
残りはシステムが処理します。

01:09:55.000 --> 01:09:59.000
今、私たちは共有されたメディア体験についてたくさん話しました。

01:09:59.000 --> 01:10:06.000
しかし、私たちはグループ活動が、あなたが夢見ることができる最も野心的な経験にも力を与えることができる基盤を提供することを望んでいました。

01:10:06.000 --> 01:10:14.000
そこで、私たちは今日、グループFaceTimeを強化するファブリックの上に構築し始め、アプリに高速で信頼性の高いデータチャネルを提供しました。

01:10:14.000 --> 01:10:20.000
グループリーダーとして仕事を引き受けることで、私たちのサーバーはグループ全体の集中状態を調整します。

01:10:20.000 --> 01:10:26.000
これらのサーバーは、すべてエンドツーエンドで暗号化されているため、プライベートのままであるため、ユーザーのデータを表示しません。

01:10:26.000 --> 01:10:38.000
そして、この高速で安全なデータチャネルを使用すると、共有本のページをめくることから、誰かが共有ホワイトボードに描いたストロークをライブで見ることまで、没入型体験を作成できます。

01:10:38.000 --> 01:10:45.000
私たちは、あなたが私たちのAPIを最大限に活用し、かつてないほどユーザーを結びつけるように本当に刺激したいと思っています。

01:10:45.000 --> 01:10:53.000
しかし、デモをお見せする前に、これについて少し余分な助けを呼び出す必要があります。

01:10:53.000 --> 01:10:55.000
やあ、みんな。参加してくれてありがとう。

01:10:55.000 --> 01:11:00.000
グループ活動の力を本当に実証するために、この最後のデモであなたの助けが必要です。

01:11:00.000 --> 01:11:06.000
さて、グループアクティビティで何ができるかを示すホワイトボードのデモアプリがあります。

01:11:06.000 --> 01:11:12.000
今、共有キャンバスを開くことで、私は一緒に描くためにグループと新しい活動を始めています。

01:11:12.000 --> 01:11:17.000
今、私たちは皆同じキャンバスを見ていて、まったく新しい方法でお互いに交流することができます。

01:11:17.000 --> 01:11:22.000
キャンバスのどこかに絵を描くと、誰もが私が描いているものをライブで見ることができます。

01:11:22.000 --> 01:11:32.000
現在、このアプリは以前に見たのと同じAPIを使用していますが、メディアを同期する代わりに、GroupSessionMessengerを使用して私のストロークを全員のデバイスに送信しています。

01:11:32.000 --> 01:11:34.000
そして、これは画面共有ではありません。

01:11:34.000 --> 01:11:39.000
このアプリはみんなのiPadでネイティブに実行されているので、キャンバスにも絵を描くことができます。

01:11:39.000 --> 01:11:49.000
みんなでやってみましょう。

01:11:49.000 --> 01:11:53.000
だから、私たちはどんなに遠く離れていても、共有のキャンバスの周りに集まることができます。

01:11:53.000 --> 01:11:59.000
そして、それはかつてないほど私たちを結びつけています。

01:11:59.000 --> 01:12:02.000
助けてくれてありがとう、みんな。

01:12:02.000 --> 01:12:14.000
最良の部分は、あなたが今見たすべてのもの - SharePlayアクティビティ、再生同期、高速で安全なデータチャネル - アプリをGroupActivitiesフレームワークと統合するだけで、これらすべての利点を得ることができます。

01:12:14.000 --> 01:12:20.000
SharePlayは、アプリのコンテンツを高め、ユーザーにとってより没入感のある体験を生み出すのに役立つ素晴らしい新しい方法です。

01:12:20.000 --> 01:12:26.000
私たちは、あなたがグループアクティビティを使用して思いつく新しい共有体験を見ることを熱望しています。

01:12:26.000 --> 01:12:33.000
さて、スーザンに物事をまとめます。

01:12:33.000 --> 01:12:39.000
私たちは、あなたが今日見た進歩は、あなたが違いを生むアプリを構築し続けるのに役立つと信じています。

01:12:39.000 --> 01:12:45.000
ワークフローを合理化し、優れたアプリをより迅速に構築するためのツールを構築しています。

01:12:45.000 --> 01:12:50.000
プロのクリエイターのための没入型コンテンツ、ゲーム、ツールの構築を容易にしました。

01:12:50.000 --> 01:12:57.000
最も重要なことに集中しながら、アプリがユーザーの接続にどのように役立つかをお見せしました。

01:12:57.000 --> 01:13:00.000
あなたが今日見たものはほんの始まりに過ぎません。

01:13:00.000 --> 01:13:06.000
今週はチェックすべきことがたくさんあるので、触れる機会さえありませんでした。

01:13:06.000 --> 23:59:59.000
私たちはあなたが何か素晴らしいものを作ることを知っています、そして私たちはそれを見るのが待ちきれません。

