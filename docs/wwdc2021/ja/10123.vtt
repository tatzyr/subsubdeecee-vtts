WEBVTT

00:00:02.000 --> 00:00:11.000
WWDCへようこそ。

00:00:11.000 --> 00:00:18.000
私はスクリーンタイムチームのエンジニアであるクリストファー・スコゲンです。新しいスクリーンタイムAPIについてお話しします。

00:00:18.000 --> 00:00:23.000
AppleがiOS用のスクリーンタイムを導入してから3年が経ちました。

00:00:23.000 --> 00:00:31.000
そして、それはお客様と家族のデバイスとの関係を改善するための大きな前進でした。

00:00:31.000 --> 00:00:38.000
過去3年間で、スクリーンタイムはiPhone、iPad、Macにいくつかの素晴らしい新しい能力をもたらしました。

00:00:38.000 --> 00:00:58.000
スクリーンタイムは、あなたとあなたの家族がアプリやウェブサイトを使用する頻度を追跡し、制限を設定して時間を管理し、家族と共有してデバイスがどのように使用されているかのビューを提供し、最後に、子供が誰と通信しているかなどを管理するのに役立ちます。

00:00:58.000 --> 00:01:05.000
また、多くのお客様から、これらの機能の一部を独自のペアレンタルコントロールアプリで活用したいと聞いています。

00:01:05.000 --> 00:01:08.000
そこで、スクリーンタイムAPIを作成しました。

00:01:08.000 --> 00:01:16.000
アプリにコアスクリーンタイム機能をもたらすので、顧客にダイナミックな新しい体験を生み出すことができます。

00:01:16.000 --> 00:01:22.000
まず、APIはiOSとiPadOS 15で利用可能になります。

00:01:22.000 --> 00:01:31.000
最新のSwiftアプリケーションに簡単に統合するための100%SwiftとSwiftUIコードです。

00:01:31.000 --> 00:01:36.000
スクリーンタイムAPIは、3つの指針に基づいて設計および構築されました。

00:01:36.000 --> 00:01:45.000
まず、既存の制限への直接APIアクセスのための最新のオンデバイスフレームワークを提供します。

00:01:45.000 --> 00:01:50.000
私たちの2番目の指針は、ユーザーのプライバシーを保護することでした。

00:01:50.000 --> 00:02:02.000
スクリーンタイムは、使用したアプリや訪問したウェブサイトなど、非常に機密性の高い個人情報を処理するため、スクリーンタイムは常に非常にプライバシー中心のアプローチを取っています。

00:02:02.000 --> 00:02:12.000
たとえば、家族やApple以外の人が、どのサイトにアクセスしたか、どのアプリを使用しているかを知る方法はありません。

00:02:12.000 --> 00:02:21.000
新しいAPIでは、プライバシーに対するこのアプローチを継続し、顧客の使用データはデバイスの外部では見えなくなります。

00:02:21.000 --> 00:02:33.000
そして最後に、私たちの3番目の指導原則は、開発者が素晴らしい新しいダイナミックなペアレンタルコントロール体験を作成できるようにすることでした。

00:02:33.000 --> 00:02:39.000
私たちの3つの指導原則が3つの新しいフレームワークを作成するために私たちを導いたのは偶然ではありません。

00:02:39.000 --> 00:02:44.000
3つのフレームワークをまとめると、スクリーンタイムAPIを構成します。

00:02:44.000 --> 00:02:47.000
まず、管理された設定。

00:02:47.000 --> 00:02:54.000
マネージド設定により、アプリはスクリーンタイムで利用可能なのと同じ制限に直接アクセスできます。

00:02:54.000 --> 00:02:56.000
第二に、家族のコントロール。

00:02:56.000 --> 00:03:01.000
ファミリーコントロールは、当社のプライバシーポリシーを推進しています。

00:03:01.000 --> 00:03:04.000
そして最後に、デバイスのアクティビティ。

00:03:04.000 --> 00:03:12.000
デバイスアクティビティを使用すると、アプリを起動せずにコードを実行するための優れた新しい能力をアプリに与えることで、スクリーンタイムを超えることができます。

00:03:12.000 --> 00:03:16.000
3つのフレームワークすべてを詳しく見てみましょう。

00:03:16.000 --> 00:03:19.000
管理された設定から始めましょう。

00:03:19.000 --> 00:03:30.000
あなたのアプリは、子供が自分のデバイスで何ができるかを制限し、親または保護者がそうでないと言うまでそれらの制限が維持されるようにするためのより良い方法が必要です。

00:03:30.000 --> 00:03:49.000
管理された設定を使用すると、アプリは、スクリーンタイムと同様に、アカウントのロック、パスワード変更の防止、Webトラフィックのフィルタリング、アプリケーションのシールドなど、多くの制限を設定できますが、アプリのブランディングと機能でカスタマイズできます。

00:03:49.000 --> 00:03:52.000
次はファミリーコントロールです。

00:03:52.000 --> 00:04:01.000
ファミリー共有を活用することで、ファミリーコントロールは保護者の承認なしにスクリーンタイムAPIへのアクセスを防ぎます。

00:04:01.000 --> 00:04:08.000
アプリが保護者によって承認されると、保護者の承認なしにデバイスから削除することはできません。

00:04:08.000 --> 00:04:14.000
さらに、ファミリーコントロールは、アプリやウェブサイトを表す不透明なトークンを提供します。

00:04:14.000 --> 00:04:27.000
これらのトークンは、スクリーンタイムAPI全体で使用状況を監視または制限し、単一のファミリー共有グループ以外の誰もどのアプリやウェブサイトが使用されているかを知らないようにします。

00:04:27.000 --> 00:04:30.000
そして最後に、デバイスのアクティビティ。

00:04:30.000 --> 00:04:39.000
このフレームワークでは、ウェブやアプリの使用状況を監視し、必要に応じてコードを実行する新しい方法をアプリに与えることで、スクリーンタイムを超えることができます。

00:04:39.000 --> 00:04:46.000
あなたのアプリはペアレンタルコントロールアプリなので、子供が自分のデバイスでアプリを実行する理由がある可能性は非常に低いです。

00:04:46.000 --> 00:04:50.000
では、制限を設定するためにコードをどのように実行しますか?

00:04:50.000 --> 00:04:55.000
答えは、デバイスアクティビティのスケジュールとイベントです。

00:04:55.000 --> 00:05:05.000
デバイスアクティビティスケジュールは、タイムウィンドウの開始時と終了時にアプリケーションの拡張機能を呼び出すタイムウィンドウです。

00:05:05.000 --> 00:05:15.000
イベントは、デバイス上のユーザーがデバイスアクティビティスケジュールの使用しきい値に達したときに、拡張機能を呼び出す使用状況モニターです。

00:05:15.000 --> 00:05:21.000
アプリは、どのような使用状況を気にし、いつ気にするかを宣言するだけです。

00:05:21.000 --> 00:05:26.000
3つのフレームワークをすべて組み合わせると、次のようになります。

00:05:26.000 --> 00:05:34.000
アプリが保護者と子供のデバイスの両方にインストールされた後、保護者は子供のデバイスでアプリを開きます。

00:05:34.000 --> 00:05:37.000
あなたのアプリはファミリーコントロールで承認されます。

00:05:37.000 --> 00:05:44.000
その後、保護者のデバイス上のアプリは、設定、制限、およびルールを選択します。

00:05:44.000 --> 00:05:48.000
アプリはその情報を子供のデバイスに送信します。

00:05:48.000 --> 00:05:54.000
そして、子供のデバイスで、アプリはデバイスアクティビティでスケジュールとイベントを作成します。

00:05:54.000 --> 00:06:01.000
アプリのデバイスアクティビティ拡張機能は、スケジュールが発生したとき、またはイベントが発生したときに呼び出されます。

00:06:01.000 --> 00:06:05.000
拡張機能から、管理された設定で制限を設定します。

00:06:05.000 --> 00:06:09.000
ノーランを紹介する良い機会です。

00:06:09.000 --> 00:06:17.000
ノーランは素晴らしい新しいデモアプリ「宿題」に取り組んでおり、宿題がスクリーンタイムAPIをどのように使用しているかを説明します。

00:06:17.000 --> 00:06:20.000
こんにちは、私はスクリーンタイムチームのエンジニア、ノーランです。

00:06:20.000 --> 00:06:23.000
私のデモアプリ、宿題を紹介したいと思います。

00:06:23.000 --> 00:06:32.000
宿題は、保護者が使用を希望する他のアプリでの使用を蓄積するまで、特定のアプリへの子供のアクセスを制限することで、良い習慣を奨励します。

00:06:32.000 --> 00:06:37.000
宿題を機能させるために、スクリーンタイムAPIの3つのフレームワークをすべて使用します。

00:06:37.000 --> 00:06:41.000
まず、ファミリーコントロールの承認をリクエストする順を追って説明します。

00:06:41.000 --> 00:06:46.000
次に、保護者が選択した落胆したアプリを定期的なスケジュールで保護します。

00:06:46.000 --> 00:06:52.000
次に、十分に奨励されたアプリの使用を蓄積した後、それらのシールドを削除する方法を紹介します。

00:06:52.000 --> 00:06:58.000
最後に、アプリのブランディングと機能に合わせて、宿題で使用されるシールドをカスタマイズします。

00:06:58.000 --> 00:07:03.000
プロジェクトのセットアップとファミリーコントロールの承認から始めます。

00:07:03.000 --> 00:07:14.000
ファミリーコントロール機能を含むようにXcodeプロジェクトを設定するには、プロジェクトエディタに移動し、アプリのターゲットを選択し、署名と機能の下でプラスボタンをクリックします。

00:07:14.000 --> 00:07:19.000
ファミリーコントロールを検索して機能を見つけてプロジェクトに追加します。

00:07:19.000 --> 00:07:22.000
機能が追加されたので、コーディングの準備が整いました。

00:07:22.000 --> 00:07:28.000
宿題が最初にする必要があるのは、ファミリーコントロールの承認を要求することです。

00:07:28.000 --> 00:07:34.000
ファミリーコントロールフレームワークの共有承認センターを使用して、アプリの起動時にこのリクエストを行います。

00:07:34.000 --> 00:07:37.000
リクエストは成功または失敗につながる可能性があります。

00:07:37.000 --> 00:07:43.000
この機能を呼び出すには、家族の保護者が宿題のためのファミリーコントロールを承認する必要があります。

00:07:43.000 --> 00:07:50.000
私のアプリはこれまでこのiPhoneで実行されたことがないので、requestAuthorizationはアラートで保護者の承認を求めます。

00:07:50.000 --> 00:07:57.000
許可をタップすると、保護者にApple IDとパスワードで認証して続行するように求められます。

00:07:57.000 --> 00:08:06.000
保護者が正常に認証されると、requestAuthorizationを呼び出すと、再びアラートが表示されず、代わりに静かに成功を返します。

00:08:06.000 --> 00:08:14.000
誤用を防ぐために、サインインしたiCloudがファミリー共有を使用している子供でない場合、requestAuthorizationは失敗を返します。

00:08:14.000 --> 00:08:18.000
アプリがスクリーンタイムAPIを使用する準備をするのはとても簡単です。

00:08:18.000 --> 00:08:20.000
ありがとう、ノーラン。

00:08:20.000 --> 00:08:25.000
私たちはちょうど私たちのデモアプリ、宿題、ファミリーコントロールで承認するのを見ました。

00:08:25.000 --> 00:08:30.000
ファミリーコントロールで承認すると、アプリに他の魔法の力も付与されます。

00:08:30.000 --> 00:08:37.000
たとえば、デバイスが認証されると、ユーザーはiCloudからサインアウトできなくなります。

00:08:37.000 --> 00:08:49.000
また、ネットワーク拡張フレームワークで構築されたデバイス上のWebコンテンツフィルタは、アプリに含めることができ、自動的にインストールされ、削除することはできません。

00:08:49.000 --> 00:08:54.000
これにより、アプリはデバイス上のウェブトラフィックをフィルタリングすることができます。

00:08:54.000 --> 00:09:04.000
ペアレンタルコントロールアプリを書く際の課題の1つは、子供がアプリを実行しない可能性が高いときに、子供のデバイスでコードを実行することです。

00:09:04.000 --> 00:09:11.000
スクリーンタイムAPIでは、デバイスアクティビティでバックグラウンドコードの実行を実行する新しい方法を作成しました。

00:09:11.000 --> 00:09:18.000
デバイスアクティビティ拡張機能は、スクリーンタイムAPIの残りの部分と対話する主な方法です。

00:09:18.000 --> 00:09:29.000
ノーランに戻って、宿題が繰り返しスケジュールでコードを実行し、一部のアプリにスクリーンタイムシールドを配置して子供のデバイスを制限する方法を見てみましょう。

00:09:29.000 --> 00:09:31.000
ノーラン。

00:09:31.000 --> 00:09:32.000
ありがとう、クリス。

00:09:32.000 --> 00:09:38.000
次の宿題は、保護者が繰り返しのスケジュールを思いとどまらせるために選択したアプリを保護することです。

00:09:38.000 --> 00:09:50.000
アプリの実行が子供のデバイスで実行されているとは期待できないため、保護者が設定してから宿題が実行されていない場合でも、デバイスアクティビティスケジュールを使用して毎日アプリケーションシールドの制限を設定します。

00:09:50.000 --> 00:09:55.000
デバイスアクティビティスケジュールが起動すると、デバイスアクティビティが新しい拡張ポイントに呼び込まれます。

00:09:55.000 --> 00:10:01.000
宿題には、アプリを保護するための制限を設定するこの拡張ポイントの拡張機能が含まれます。

00:10:01.000 --> 00:10:08.000
この拡張ポイントの拡張を実装するには、基本クラスとしてDeviceActivityMonitorをサブクラス化する必要があります。

00:10:08.000 --> 00:10:14.000
ここでは、拡張機能の原理クラスの2つのメソッドをオーバーライドしました。intervalDidStartとintervalDidEndです。

00:10:14.000 --> 00:10:19.000
これらの機能は、私のスケジュールの開始と終了後にデバイスが初めて使用されるときに呼び出されます。

00:10:19.000 --> 00:10:26.000
宿題のメインアプリからデバイスアクティビティのスケジュールを設定するまで、これらの機能の実装を空のままにします。

00:10:26.000 --> 00:10:35.000
デバイスアクティビティモニター拡張機能がメインアプリから設定されたので、デバイスアクティビティ名とデバイスアクティビティスケジュールを作成する必要があります。

00:10:35.000 --> 00:10:39.000
デバイスアクティビティ名は、拡張機能内からアクティビティを参照する方法です。

00:10:39.000 --> 00:10:45.000
そして、デバイスアクティビティスケジュールは、私の拡張機能がアクティビティを監視する時間枠を表します。

00:10:45.000 --> 00:10:51.000
ここでは、アクティビティの名前を「毎日」に設定し、スケジュールを真夜中に開始および終了するように設定しました。

00:10:51.000 --> 00:10:53.000
また、このスケジュールを繰り返すように設定します。

00:10:53.000 --> 00:11:00.000
最後に、デバイスアクティビティセンターを作成し、先ほど定義したアクティビティ名とスケジュールでstartMonitoringを呼び出すことができます。

00:11:00.000 --> 00:11:09.000
これらの数行のコードを使用すると、スケジュールが開始および終了するたびに、デバイスアクティビティモニター拡張機能がアクティビティ名で呼び出されます。

00:11:09.000 --> 00:11:13.000
アプリを保護するためのもう1つの要素は、保護者が阻止したいものを理解することです。

00:11:13.000 --> 00:11:19.000
ファミリーコントロールフレームワークには、ジョブのためだけにSwiftUI要素があります:ファミリーアクティビティピッカー。

00:11:19.000 --> 00:11:28.000
メインアプリのUIから、家族のアクティビティピッカーを表示し、保護者が家族が使用するアプリ、ウェブサイト、カテゴリのリストから選択できるようにします。

00:11:28.000 --> 00:11:37.000
保護者が選択したら、宿題はピッカーから返された不透明なトークンを使用して、各トークンが表すアプリ、ウェブサイト、およびカテゴリに制限を設定できます。

00:11:37.000 --> 00:11:45.000
ここでは、アプリのボタンにfamilyActivityPickerビュー修飾子を追加し、ピッカーの選択パラメータをアプリのモデルのプロパティにバインドしました。

00:11:45.000 --> 00:11:51.000
これにより、保護者の選択がUIで更新されるたびに、私のモデルが更新されます。

00:11:51.000 --> 00:11:59.000
保護者の落胆したアプリの選択がアプリのモデルに保存されているので、デバイスアクティビティモニター拡張機能に戻ります。

00:11:59.000 --> 00:12:06.000
まず、管理設定モジュールのインポートをドロップして、アプリケーションシールド制限にアクセスします。

00:12:06.000 --> 00:12:14.000
その後、intervalDidStartで、アプリのモデルから選択範囲を引き出し、それに応じてアプリケーションシールド制限を設定できます。

00:12:14.000 --> 00:12:20.000
そして、intervalDidEndでは、nilに設定することで制限を解除できます。

00:12:20.000 --> 00:12:26.000
これらの簡単な変更により、宿題は保護者が選択した落胆したアプリを毎日真夜中から真夜中まで保護します。

00:12:26.000 --> 00:12:28.000
折り返し連絡してね、クリス。

00:12:28.000 --> 00:12:30.000
ありがとう、ノーラン。

00:12:30.000 --> 00:12:34.000
シールドは、管理された設定で利用可能な唯一の制限ではありません。

00:12:34.000 --> 00:12:41.000
また、デバイスアクティビティスケジュールの開始時または終了時に任意の数の制限を設定することもできます。

00:12:41.000 --> 00:12:53.000
たとえば、アプリはアカウントの作成や削除を防ぐか、アプリやウェブサイトを完全にブロックするか、年齢別にメディアコンテンツを拒否するかを選択できます。

00:12:53.000 --> 00:13:03.000
メディアの制限といえば、マネージド設定は、任意のアプリが映画やテレビコンテンツの制限を読むことを可能にするAPIも提供します。

00:13:03.000 --> 00:13:07.000
ファミリーコントロールの承認は必要ありません。

00:13:07.000 --> 00:13:15.000
これらの機能は、デバイスがユーザーに提示されるコンテンツを制限する必要があるかどうかを確認するためのメディアアプリに最適です。

00:13:15.000 --> 00:13:25.000
宿題のデモアプリでは、制限は毎日真夜中に設定されていましたが、アプリやウェブの使用状況に基づいて制限を変更したい場合はどうなりますか?

00:13:25.000 --> 00:13:32.000
デバイスアクティビティには、アプリがそれを可能にする別の機能があります。デバイスアクティビティイベントです。

00:13:32.000 --> 00:13:41.000
これらのイベントは、ファミリーアクティビティピッカーで見たのと同じトークンで設定されており、使用制限に達したときにコードを実行できます。

00:13:41.000 --> 00:13:47.000
これらのイベントは、ノーランが最後のセグメントで私たちに見せたスケジュールと一緒に登録されています。

00:13:47.000 --> 00:13:51.000
では、ノーランにチェックインして、これらのイベントがどのように機能するかを見てみましょう。

00:13:51.000 --> 00:14:02.000
宿題のスケジュールが終了したときだけでなく、子供が保護者が選択した一連の奨励されたアプリに十分な使用量を蓄積したときにも、アプリケーションシールドの制限を削除したい。

00:14:02.000 --> 00:14:13.000
これを行うには、使用しきい値が満たされたときにデバイスアクティビティモニター拡張機能をさらに呼び出すようにデバイスアクティビティを設定することで、これらの奨励されたアプリの使用状況を監視する必要があります。

00:14:13.000 --> 00:14:17.000
ここでは、デバイスアクティビティのイベント名を「encouraged」と定義します。

00:14:17.000 --> 00:14:21.000
この名前は、拡張機能内からイベントを参照する方法です。

00:14:21.000 --> 00:14:28.000
そして、保護者が選択した奨励されたアプリのセットと希望する使用のしきい値を含めるように、私の奨励されたイベントを定義します。

00:14:28.000 --> 00:14:35.000
最後に、設定したばかりのイベントを含むように、startMonitoringへの呼び出しを更新します。

00:14:35.000 --> 00:14:46.000
メインアプリからデバイスアクティビティイベントを監視しているので、これらのイベントのいずれかが使用しきい値を満たすたびに、デバイスアクティビティモニター拡張機能が呼び出されます。

00:14:46.000 --> 00:14:57.000
関数eventDidReachThresholdは、デバイスアクティビティイベント名とDeviceActivityNameで呼び出され、どのイベントがどのスケジュールされたアクティビティに対して発生したかを識別します。

00:14:57.000 --> 00:15:03.000
宿題では、このイベントの拡張機能が通知されたときに、アプリケーションシールドの制限をnilに設定したいです。

00:15:03.000 --> 00:15:08.000
この制限をnilに設定すると、以前にシールドされたアプリのいずれかからシールドが削除されます。

00:15:08.000 --> 00:15:09.000
クリスに戻る。

00:15:09.000 --> 00:15:15.000
前のセクションでは、落胆したアプリはデフォルトのスクリーンタイムシールドでシールドされていました。

00:15:15.000 --> 00:15:20.000
しかし、あなたはおそらくこれらのシールドであなた自身のブランディングとスタイルを手に入れたいと思うでしょう。

00:15:20.000 --> 00:15:24.000
また、おそらくシールドのボタンのための独自のアクションハンドラーを持ちたいと思うでしょう。

00:15:24.000 --> 00:15:27.000
私たちは両方のためのツールを持っています。

00:15:27.000 --> 00:15:33.000
カスタムシールドを使用すると、ユニークなブランド体験を作成できます。

00:15:33.000 --> 00:15:40.000
シールドをカスタマイズするには、管理設定で定義された2つの新しい拡張ポイントを実装する必要があります。

00:15:40.000 --> 00:15:51.000
1つの拡張ポイントでは、背景素材、タイトル、アイコン、ボタンの外観を変更することで、シールドの外観をカスタマイズできます。

00:15:51.000 --> 00:15:56.000
また、別の拡張ポイントでは、カスタムボタンハンドラを作成できます。

00:15:56.000 --> 00:16:02.000
ノーランに戻って、シールドをどのようにカスタマイズするか見てみましょう。

00:16:02.000 --> 00:16:10.000
宿題用のカスタムシールドのルックアンドフィールを設定するには、拡張機能のメインクラスとしてShieldConfigurationProviderをサブクラス化することから始める必要があります。

00:16:10.000 --> 00:16:14.000
設定は、ここでオーバーライドする必要がある唯一の機能です。

00:16:14.000 --> 00:16:21.000
この関数は、現在シールドされているアプリケーションへの参照が渡され、ShieldConfiguration構造体を返すことが期待されます。

00:16:21.000 --> 00:16:34.000
ShieldConfiguration構造体を使用すると、背景効果、背景色、アイコン、タイトル、サブタイトル、プライマリボタンラベル、プライマリボタンの背景色、およびセカンダリボタンラベルを定義できます。

00:16:34.000 --> 00:16:37.000
うわー、それはたくさんのカスタマイズです。

00:16:37.000 --> 00:16:47.000
この構造体が設定され、私のシールド構成プロバイダー拡張機能によって返されると、オペレーティングシステムは宿題によってシールドされたすべてのアプリにこれらのカスタマイズを自動的に表示します。

00:16:47.000 --> 00:16:57.000
シールドをスタイル設定したので、管理設定の2番目の拡張ポイントを使用して、プライマリボタンとセカンダリボタンのアクションハンドラを設定できます。

00:16:57.000 --> 00:17:05.000
この新しい拡張機能では、ShieldActionHandlerをプリンシパルクラスとしてサブクラス化し、関数ハンドルをオーバーライドします。

00:17:05.000 --> 00:17:14.000
ハンドル機能は、プライマリボタンアクションまたはセカンダリボタンアクションが押されたかどうか、どのアプリケーションが現在シールドされているかを知らされます。

00:17:14.000 --> 00:17:19.000
スシールドアクション応答で関数の完了ハンドラを呼び出す必要があります。

00:17:19.000 --> 00:17:25.000
応答は、シールドされたアプリケーションを閉じるか、アクションを延期してシールド構成を再描画するかのどちらかです。

00:17:25.000 --> 00:17:34.000
シールドでアクションを延期する機能は、続行方法の信号を待っている間、シールドに外観を更新する機会を与えるため、非常に強力です。

00:17:34.000 --> 00:17:41.000
たとえば、子供がここでアクセスを求めるをタップしたときに、シールドが保護者の行動を待っていることを示すために使用できます。

00:17:41.000 --> 00:17:46.000
これらのカスタムシールドを追加することで、私のデモアプリ「宿題」が完成しました。

00:17:46.000 --> 00:17:56.000
保護者は、ゲームやエンターテイメントなどのシールドするアプリを選択し、子供が読書、学習、創造性など、十分なポジティブなスクリーンタイムを終えたらシールドを取り外すことができます。

00:17:56.000 --> 00:17:59.000
この素晴らしい新しいデモアプリの構築に参加してくれてありがとう。

00:17:59.000 --> 00:18:00.000
さて、クリスに戻ります。

00:18:00.000 --> 00:18:14.000
今日は、制限を提供し、プライバシーを保護し、新しい動的体験を可能にするという3つの目標が、スクリーンタイムAPIを構成する3つのフレームワークでどのように提供されたかを学びました。

00:18:14.000 --> 00:18:20.000
管理された設定により、アプリは設定と制限を強制できます。

00:18:20.000 --> 00:18:29.000
デバイスアクティビティを使用すると、アプリが使用されていない場合でも、アプリはスケジュールまたは使用イベントでコードを実行できます。

00:18:29.000 --> 00:18:44.000
そして最後に、ファミリーコントロールは、管理された設定とデバイスアクティビティへのアクセスを許可し、ユーザーのプライバシーを保護し、保護者だけが子供が何をしているのかを知ることを保証します。

00:18:44.000 --> 00:18:51.000
すべてのフレームワークと同様に、スクリーンタイムAPIはあなたからのフィードバックに基づいて進化し続けます。

00:18:51.000 --> 00:18:58.000
だから、これらを試してみて、彼らがあなたのユニークなユースケースをどのようにサポートするか、またはサポートしないかを私たちに知らせてください。

00:18:58.000 --> 00:19:00.000
今日はご参加いただきありがとうございます。

00:19:00.000 --> 00:19:03.000
WWDC 2021をお楽しみください。

00:19:03.000 --> 23:59:59.000
[音楽]。

