WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:13.000
こんにちは、私はSwiftUIチームのエンジニア、ハリーです。

00:00:13.000 --> 00:00:16.000
「SwiftUIでのクラフト検索体験」へようこそ。

00:00:16.000 --> 00:00:21.000
検索は今年SwiftUIでまったく新しく、これらの機能の使用を開始する方法を紹介することに興奮しています。

00:00:21.000 --> 00:00:32.000
時には、アプリ内で特定の何かを見つけたいこともありますが、多くのアプリには大量のデータコレクションが含まれているため、探しているものを正確に見つけるのが難しくなる可能性があります。

00:00:32.000 --> 00:00:41.000
最新のアプリのトレンド、次のお気に入りの曲、または朝の通勤に適したポッドキャストを見つけるかどうかにかかわらず、検索を実装することはまさにそれを行うのに役立ちます。

00:00:41.000 --> 00:00:46.000
最適な検索体験は、アプリの構造と内容によって異なります。

00:00:46.000 --> 00:00:52.000
しかし、一般的に、すべての経験には、検索クエリを定義する検索フィールドが含まれます。

00:00:52.000 --> 00:00:55.000
これで、SwiftUIで直接検索を実装できます。

00:00:55.000 --> 00:00:57.000
見てみましょう。 

00:00:57.000 --> 00:01:05.000
この講演では、SwiftUIのすべての検索機能の基礎を形成する新しい検索可能な修飾子を紹介します。

00:01:05.000 --> 00:01:10.000
ナビゲーションビューが検索可能な修飾子とどのように統合されるかを紹介します。

00:01:10.000 --> 00:01:16.000
最後に、検索候補を追加することで、検索可能な修飾子の機能を拡張します。

00:01:16.000 --> 00:01:22.000
Searchableは、すべてのプラットフォームで利用可能なSwiftUIの新しいビュー修飾子です。

00:01:22.000 --> 00:01:26.000
これにより、表示コンテンツを検索可能としてマークすることができます。

00:01:26.000 --> 00:01:29.000
コンテンツは、それが何を意味するのかを正確に定義します。

00:01:29.000 --> 00:01:34.000
この講演を通して、各プラットフォームでこの修飾子の例を探ります。

00:01:34.000 --> 00:01:38.000
さて、この修飾子をよりよく理解するために、天気について話しましょう!

00:01:38.000 --> 00:01:43.000
iOSでの検索の素晴らしい例は、新しい天気アプリで見つけることができます。

00:01:43.000 --> 00:01:50.000
都市のリストを表示するときに、検索バーに入力し始めると、リストに追加する新しい都市が検索されます。

00:01:50.000 --> 00:01:57.000
Weatherが検索可能な修飾子を使用してこの機能を強化する方法を説明するために、UIの構造を分解しましょう。

00:01:57.000 --> 00:02:02.000
天気は、ナビゲーションバーを提供するナビゲーションビューから始まります。

00:02:02.000 --> 00:02:06.000
天気は、ナビゲーションビューのコンテンツとしてカスタムリストを追加します。

00:02:06.000 --> 00:02:11.000
そして、そのリストの中で、そのセルの上にForEachを追加します。

00:02:11.000 --> 00:02:15.000
最後に、Weatherは検索可能な修飾子をナビゲーションビューに追加します。

00:02:15.000 --> 00:02:21.000
すべての検索可能な修飾子の中核は、検索フィールドの設定です。

00:02:21.000 --> 00:02:30.000
検索可能な修飾子は、設定された検索フィールドを受け取り、環境を介してそれを渡し、他のビューを各プラットフォームに最適な方法で使用します。

00:02:30.000 --> 00:02:36.000
ここでは、ナビゲーションビューはその検索フィールドを理解し、検索バーとしてレンダリングします。

00:02:36.000 --> 00:02:44.000
ビューが設定された検索フィールドを使用しない場合、検索可能な修飾子は、ツールバーに検索フィールドをレンダリングするデフォルトの実装を提供します。

00:02:44.000 --> 00:02:49.000
現在、検索フィールドは多くの場合、検索関連のUIの唯一の部分ではありません。

00:02:49.000 --> 00:02:53.000
何らかの形式の検索結果を表示することは、一般的なデザインパターンです。

00:02:53.000 --> 00:03:04.000
天気はこのパターンに従い、空でない検索クエリが表示されるたびに、カスタムリストを切り替えて、現在のクエリの結果を含む別のリストを表示します。

00:03:04.000 --> 00:03:10.000
天気が検索可能な修飾子によって販売された情報を使用して、このUIを実現する方法を見てみましょう。

00:03:10.000 --> 00:03:12.000
これが天気のカスタムリストです。

00:03:12.000 --> 00:03:23.000
検索可能な修飾子は、ユーザーが積極的に検索しているかどうかに基づいて、表示されるビューを動的に変更するために使用するisSearchingと呼ばれる新しい環境プロパティを設定します。

00:03:23.000 --> 00:03:30.000
天気は、isSearching環境プロパティと検索のテキストを条件付きで結果ビューを表示します。

00:03:30.000 --> 00:03:39.000
独自の結果をレンダリングするときは、ユーザーが検索インタラクションから戻った後にメインUIの状態が変更されないように、オーバーレイを使用することを検討してください。

00:03:39.000 --> 00:03:45.000
ナビゲーションビューが新しい検索可能な修飾子とどのように統合されるかについて、もう少し話しましょう。

00:03:45.000 --> 00:03:50.000
これを行うには、私が精力的に取り組んできたアプリを紹介したいと思います。

00:03:50.000 --> 00:03:51.000
私はそれを色と呼んでいます。

00:03:51.000 --> 00:03:58.000
このアプリでは、ユーザーはパレットと呼ばれるお気に入りの色セットのライブラリを管理できます。

00:03:58.000 --> 00:04:05.000
部屋のさまざまなペイント、アプリのテーマで遊んだり、新しいM1 iMacの色を選ぶのを手伝ってもらいたいかもしれません。

00:04:05.000 --> 00:04:08.000
あなたの欲望に関係なく、Colorsはあなたのためのアプリです。

00:04:08.000 --> 00:04:20.000
色の基本的な構造は2列のナビゲーションビューで、最初の列であるルートビューは、iPadOSとmacOSのサイドバー、または他のプラットフォームのナビゲーションスタックのルートです。

00:04:20.000 --> 00:04:23.000
サイドバーには、私のカラーパレットのライブラリが見えます。

00:04:23.000 --> 00:04:32.000
詳細ビューでは、現在選択されているカラーパレットと、それらの色が視覚的な違いを持つユーザーにどのように表示されるかを見ることができます。

00:04:32.000 --> 00:04:35.000
人々がアプリを使い始めると、私は何かに気づき始めました。

00:04:35.000 --> 00:04:37.000
人々は色が大好きです。

00:04:37.000 --> 00:04:49.000
彼らは常にライブラリに色を追加していますが、ライブラリが大きくなるにつれて、人々がそれを見つけるためにライブラリ全体をスクロールする必要があるため、特定のカラーパレットを見つけるのが難しくなります。

00:04:49.000 --> 00:04:53.000
この時点で、検索機能を追加する時が来たと判断しました。

00:04:53.000 --> 00:04:59.000
この機能は、私のアプリを使用している人々がすぐに理解できるように、プラットフォームの慣習に従ってほしいです。

00:04:59.000 --> 00:05:05.000
検索可能な修飾子を使用してこの機能を実装する方法を見てみましょう。

00:05:05.000 --> 00:05:10.000
ここに、Colorsアプリの一部として構築したナビゲーションビューがあります。

00:05:10.000 --> 00:05:14.000
検索を実装するために、検索可能な修飾子をナビゲーションビューに追加します。

00:05:14.000 --> 00:05:20.000
以前と同じように、検索クエリを裏付ける状態へのバインディングを提供します。

00:05:20.000 --> 00:05:25.000
繰り返しになりますが、これはiOSとiPadOSの検索バーとしてレンダリングされます。

00:05:25.000 --> 00:05:32.000
ナビゲーションビューが検索可能な修飾子のコンテンツである場合、検索フィールドをその列の1つに関連付けます。

00:05:32.000 --> 00:05:38.000
どの列を使用するかは、ナビゲーションビューに提供される列の数によって異なります。

00:05:38.000 --> 00:05:45.000
私は2列のナビゲーションビューを持っているので、検索バーはiOSとiPadOSの両方のサイドバー列に関連付けられています。

00:05:45.000 --> 00:05:56.000
デフォルト以外の列に関連付けられた検索フィールドが必要な場合は、既存のツールバー修飾子と同様に、目的の列に検索可能な修飾子を配置できます。

00:05:56.000 --> 00:06:00.000
このアプリでは、ナビゲーションビューで検索可能にしておきます。

00:06:00.000 --> 00:06:07.000
Weatherと同様に、isSearching環境プロパティを使用して、サイドバーに検索結果を動的に表示します。

00:06:07.000 --> 00:06:19.000
macOSでの検索可能な修飾子の同じ配置は、ツールバーの最も末尾の位置に配置された検索フィールドをレンダリングし、ウィンドウが縮小すると自動的に崩壊するなど、そのプラットフォームで期待される動作になります。

00:06:19.000 --> 00:06:26.000
ここでは、macOSでのより典型的な体験のために、アプリの詳細ペインに検索結果をレンダリングします。

00:06:26.000 --> 00:06:33.000
watchOSは、ツールバーのビューの上部に検索フィールドを配置するという点で、iOSと同様に動作します。

00:06:33.000 --> 00:06:38.000
ここで、SwiftUIは検索フィールドを関連付ける最初の列を選択します。

00:06:38.000 --> 00:06:44.000
プラットフォーム全体でこれらの異なる動作を生成するために、検索可能な修飾子を配置した場所を変更しなかったことに注目してください。

00:06:44.000 --> 00:06:51.000
私のアプリの構造はこれらのプラットフォーム間で変更され、二重列のナビゲーションビューのままでした。

00:06:51.000 --> 00:06:57.000
SwiftUIはこの構造とさまざまなプラットフォーム規約を理解しているので、私に代わってそれらの実装を処理しました。

00:06:57.000 --> 00:07:04.000
tvOSを見ると、他のプラットフォームでの私のアプリの構造がより適切になる可能性があることに気づきました。

00:07:04.000 --> 00:07:10.000
tvOSは通常、検索をタブビューのタブとしてレンダリングしますが、私のアプリにはタブビューがありません。

00:07:10.000 --> 00:07:13.000
私のアプリを少し微調整するだけで、それを修正できます。

00:07:13.000 --> 00:07:26.000
2列のナビゲーションビューをレンダリングする代わりに、タブビューをナビゲーションビューのコンテンツとして1列のナビゲーションビューをレンダリングすることで、より典型的なtvOS体験を作ることができます。

00:07:26.000 --> 00:07:31.000
タブビューでは、既存のサイドバービューを配置し、新しい検索タブを追加します。

00:07:31.000 --> 00:07:37.000
検索タブは、誰かが最初にそのタブに移動したときに表示されるプレースホルダビューを表します。

00:07:37.000 --> 00:07:45.000
最後に、ナビゲーションビューをラップする代わりに、検索可能な修飾子を移動して検索タブをラップします。

00:07:45.000 --> 00:07:52.000
空でない検索クエリが入力されたら、ビューを移行して検索結果を表示します。

00:07:52.000 --> 00:07:55.000
これで、各プラットフォームに検索機能を追加しました。

00:07:55.000 --> 00:08:10.000
私のアプリのナビゲーション構造が一貫しているSwiftUIの宣言的な性質のおかげで、私はSwiftUIに頼ることができ、検索可能な修飾子の実装がその特定のナビゲーション構造に適したインターフェイスを選択できるようにしました。

00:08:10.000 --> 00:08:18.000
アプリの構造が変わったtvOSでは、検索可能な修飾子について学んだことを別の構造に適用しました。

00:08:18.000 --> 00:08:23.000
私が「検索可能」と定義したものだけが、その構造で変わりました。

00:08:23.000 --> 00:08:30.000
検索可能な修飾子を理解したので、最後のトピック「検索候補」に進みましょう。

00:08:30.000 --> 00:08:40.000
私のアプリで検索を使用した後、一部のユーザーは、検索が提供する新機能を本当に気に入っているが、検索できるものに対して途方に暮れることがあると報告しています。

00:08:40.000 --> 00:08:46.000
多くのアプリは、検索候補を使用して、提供できる検索クエリの種類に人々を導くのに役立ちます。

00:08:46.000 --> 00:08:58.000
これらの提案は、macOSのようなメニュー、iOSのようなリスト、またはwatchOSのようなリストを表示するボタンとして表示される可能性のある、完了した検索クエリを表します。

00:08:58.000 --> 00:09:03.000
提案は、人々が検索できるものの種類のアイデアを与えます。

00:09:03.000 --> 00:09:06.000
SwiftUIは、アプリに検索候補を追加する簡単な方法を提供します。

00:09:06.000 --> 00:09:08.000
見てみましょう。 

00:09:08.000 --> 00:09:13.000
私のアプリを見ると、テキストで検索可能な修飾子を設定したことがわかります。

00:09:13.000 --> 00:09:19.000
検索可能な修飾子は、私が含め始めることができる提案と呼ばれるオプションのパラメータを提供します。

00:09:19.000 --> 00:09:22.000
提案パラメータについては、ビューを提供します。

00:09:22.000 --> 00:09:31.000
これはいくつかの静的ボタンかもしれないし、おそらく、私のアプリデータベースやサーバーから来る提案の動的なセットの上にForEachになるかもしれません。

00:09:31.000 --> 00:09:37.000
SwiftUIはこのビューを見て、表示する提案があるかどうかに基づいて表示します。

00:09:37.000 --> 00:09:43.000
たとえば、watchOSは、空でない提案を提供すると、検索フィールドにアイコンをレンダリングします。

00:09:43.000 --> 00:09:55.000
ここでの一般的なパターンは、対話するときに、検索可能な修飾子に提供されたテキストバインディングを検索提案のテキスト値で更新するボタンのForEachを提供することです。

00:09:55.000 --> 00:10:02.000
実際、このパターンが非常に一般的であることを期待しているので、これを行うsearchCompletion修飾子を追加しました。

00:10:02.000 --> 00:10:06.000
searchCompletion修飾子は、非対話型ビューで使用できます。

00:10:06.000 --> 00:10:13.000
そのビューを、検索テキストを更新し、現在提示されている提案を却下するボタンに変換します。

00:10:13.000 --> 00:10:25.000
ユーザーが最初に提案と対話し、その提案に基づいて検索結果の完全なセットを取得するアプリを作成する場合は、新しいonSubmit修飾子を使用して、検索結果を取得するタイミングを知ることを検討してください。

00:10:25.000 --> 00:10:34.000
検索の値をonSubmit修飾子に渡すと、ユーザーが検索クエリを送信するたびに、指定したクロージャが呼び出されます。

00:10:34.000 --> 00:10:39.000
これは通常、検索候補を選択するか、ハードウェアキーボードでEnterキーを押すと発生します。

00:10:39.000 --> 00:10:46.000
また、新しいonSubmit修飾子をテキストフィールドまたは検索関連以外の提出物の安全なフィールドと組み合わせて使用することもできます。

00:10:46.000 --> 00:10:55.000
検索完了修飾子と一緒に提案パラメータを使用すると、アプリに強力な検索提案機能を追加する簡単な方法が提供されます。

00:10:55.000 --> 00:11:01.000
SwiftUIが現在提供している検索機能の簡単なツアーを楽しんだことを願っています。

00:11:01.000 --> 00:11:07.000
要約すると、検索可能な修飾子を使用すると、ビューコンテンツを検索可能として記述できます。

00:11:07.000 --> 00:11:16.000
ナビゲーションビューは、検索可能な修飾子と統合して、ナビゲーションビューの内容に基づいてプラットフォームに適したエクスペリエンスを提供します。

00:11:16.000 --> 00:11:23.000
環境のisSearchingプロパティを使用して、ユーザーが検索しているときにアプリのUIを動的に調整します。

00:11:23.000 --> 00:11:30.000
検索完了修飾子と検索可能な修飾子の提案パラメータを使用して、検索候補をアプリに追加します。

00:11:30.000 --> 00:11:35.000
さあ、外に出て、すべてのSwiftUIアプリに検索を追加して、素晴らしいWWをお過ごしください。

00:11:35.000 --> 23:59:59.000
[明るい音楽]。

