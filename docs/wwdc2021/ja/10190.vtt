WEBVTT

00:00:00.000 --> 00:00:12.000
こんにちは。私の名前はベク・サン・チャンで、コアオーディオに取り組んでいます。

00:00:12.000 --> 00:00:16.000
今日は、DriverKitでオーディオドライバを作成する新しい方法について説明します。

00:00:16.000 --> 00:00:19.000
しかし、まず、今日のオーディオドライバの仕組みを確認しましょう。

00:00:19.000 --> 00:00:29.000
macOS Big Sur以前は、オーディオサーバープラグインは、ユーザークライアントを介してカーネル拡張機能にハードウェアデバイスと通信する必要が高かった。

00:00:29.000 --> 00:00:38.000
macOS Big Surでは、CoreAudio HALは、DriverKit拡張機能の上に構築されたオーディオサーバープラグインを作成するためのサポートを提供しました。

00:00:38.000 --> 00:00:47.000
プラグインとdextの間のレイヤーはkextと同じでしたが、カーネルからユーザースペースに移動することでセキュリティが改善されました。

00:00:47.000 --> 00:00:53.000
DriverKitの詳細については、以前のWWDC DriverKitのビデオをご覧ください。

00:00:53.000 --> 00:01:05.000
現在のソリューションでは、オーディオドライバの開発はカーネルから移行できますが、機能的なハードウェアオーディオドライバを実装するには、オーディオサーバープラグインとドライバ拡張機能の2つの別々のコンポーネントが必要です。

00:01:05.000 --> 00:01:12.000
これにより、開発が複雑になり、リソースが増加し、オーバーヘッドとレイテンシが増加する可能性があります。

00:01:12.000 --> 00:01:17.000
macOS Monterey以降では、dextだけが必要で、プラグインはもう必要ありません。

00:01:17.000 --> 00:01:26.000
AudioDriverKitは、USBDriverKitまたはPCIDriverKitと一緒にオーディオドライバ拡張機能を書くために使用される新しいDriverKitフレームワークです。

00:01:26.000 --> 00:01:32.000
この新しいフレームワークは、CoreAudio HALへのすべてのプロセス間通信を処理します。

00:01:32.000 --> 00:01:37.000
あなたはdextしか持っていないので、dextとオーディオサーバープラグインの間で通信する必要はありません。

00:01:37.000 --> 00:01:41.000
DriverKit内で集中し続けることができます。

00:01:41.000 --> 00:01:50.000
AudioDriverKit拡張機能はMacアプリ内にバンドルされているため、別のインストーラーは不要になりました。

00:01:50.000 --> 00:01:55.000
そして今、あなたのドライバーはすぐに読み込まれ、再起動は必要ありません。

00:01:55.000 --> 00:02:00.000
AudioDriverKitの利点がわかったので、新しいオーディオドライバの作成に飛び込みましょう。

00:02:00.000 --> 00:02:10.000
オーディオドライバーに関連するコンポーネントの簡単な概要から始めて、デックスを書く前に必要なものをいくつか紹介します。

00:02:10.000 --> 00:02:22.000
コードの作成を開始する準備ができたら、dextの設定と初期化、デバイス、ストリーム、その他のオーディオオブジェクトの作成、IOパスとタイムスタンプの処理方法を説明します。

00:02:22.000 --> 00:02:30.000
最後に、構成変更の処理方法について話し合い、最後にdextのデモをお見せします。

00:02:30.000 --> 00:02:32.000
では、建築から始めましょう。

00:02:32.000 --> 00:02:39.000
この図は、HALがAudioDriverKitフレームワークを使用してドライバー拡張機能と通信する方法を示しています。

00:02:39.000 --> 00:02:47.000
AudioDriverKitフレームワークは、CoreAudioとオーディオデクスト間のすべての通信に使用されるプライベートユーザークライアントを作成します。

00:02:47.000 --> 00:02:53.000
このユーザークライアントは、直接使用することを意図しておらず、dextにさらされていません。

00:02:53.000 --> 00:03:00.000
アプリとdextの間で通信するために必要なプラグインやカスタムユーザークライアントがないことに注意してください。

00:03:00.000 --> 00:03:07.000
オプションで、必要に応じて、アプリはカスタムユーザークライアントを開き、デクストと直接通信することができます。

00:03:07.000 --> 00:03:10.000
それでは、あなたが必要とする資格について話しましょう。

00:03:10.000 --> 00:03:14.000
すべてのDriverKitドライバ拡張機能には、DriverKitの資格が必要です。

00:03:14.000 --> 00:03:20.000
AudioDriverKit dextsには、ユーザークライアントのアクセスを許可する権限も必要です。

00:03:20.000 --> 00:03:25.000
これは、DriverKitの資格が承認されたすべての開発者が利用できます。

00:03:25.000 --> 00:03:30.000
さらに、輸送家族の資格は、必要に応じて追加する必要があります。

00:03:30.000 --> 00:03:38.000
USBまたはPCIトランスポートの資格をまだリクエストしていない場合は、Appleの開発者サイトにアクセスしてリクエストを送信してください。

00:03:38.000 --> 00:03:51.000
提示されたサンプルコードは純粋にデモンストレーション目的であり、ハードウェアデバイスに関連付けられていない仮想オーディオドライバを作成するため、そのようなユースケースでは資格は付与されないことに注意してください。

00:03:51.000 --> 00:03:59.000
仮想オーディオドライバまたはデバイスがすべて必要な場合は、オーディオサーバープラグインドライバモデルを引き続き使用する必要があります。

00:03:59.000 --> 00:04:01.000
では、あなたのdextのinfo.plistを見てみましょう。

00:04:01.000 --> 00:04:05.000
これらの設定は、dextのIOKitPersonalitiesに追加する必要があります。

00:04:05.000 --> 00:04:11.000
AudioDriverKitは、HALが必要とするIOUserAudioDriverUserClientの作成を処理します。

00:04:11.000 --> 00:04:15.000
HALには、ユーザークライアント接続に接続するために必要な資格があります。

00:04:15.000 --> 00:04:20.000
SimpleAudioDriverUserClientのカスタムユーザークライアントの例を次に示します。

00:04:20.000 --> 00:04:24.000
詳細については、AudioDriverKitTypes.hヘッダーファイルを参照してください。

00:04:24.000 --> 00:04:28.000
次に、設定と初期化について話しましょう。

00:04:28.000 --> 00:04:35.000
オーディオデクストを設定する最初のステップは、IOUserAudioDriverをサブクラス化し、仮想メソッドをオーバーライドすることです。

00:04:35.000 --> 00:04:40.000
IOUserAudioDriverはIOServiceのサブクラスです。

00:04:40.000 --> 00:04:46.000
カスタム動作を実装するために必要なIOUserAudioオブジェクトをサブクラス化します。

00:04:46.000 --> 00:04:50.000
次に、それらを設定してIOUserAudioDriverに追加します。

00:04:50.000 --> 00:04:55.000
この図は、作成するIOUserAudioオブジェクトの概要を示しています。

00:04:55.000 --> 00:05:01.000
SimpleAudioDriverは、IOUserAudioDriverのサブクラスであり、dextへのエントリポイントです。

00:05:01.000 --> 00:05:07.000
SimpleAudioDriverは、IOUserAudioDeviceのサブクラスであるSimpleAudioDeviceを作成します。

00:05:07.000 --> 00:05:12.000
オーディオデバイスは、すべてのスタートストップIO関連メッセージ、タイムスタンプ、および構成変更を処理します。

00:05:12.000 --> 00:05:16.000
SimpleAudioDeviceは、さまざまなIOUserAudioObjectsを作成します。

00:05:16.000 --> 00:05:26.000
デバイスオブジェクトはまた、OSTimerDispatchSources、OSActionsを作成し、ハードウェア割り込みとIOをシミュレートするためのトーンジェネレータを実装します。

00:05:26.000 --> 00:05:29.000
IOUserAudioStreamは、デバイスが所有するストリームです。

00:05:29.000 --> 00:05:35.000
ストリームは、HALにマッピングされるオーディオIOにIOMemoryDescriptorを使用します。

00:05:35.000 --> 00:05:41.000
IOUserAudioVolumeLevelControlは、スカラー値またはdB値を取る制御オブジェクトです。

00:05:41.000 --> 00:05:45.000
制御値は、入力オーディオバッファにゲインを適用するために使用されます。

00:05:45.000 --> 00:05:50.000
すべてのIOUserAudioObjectは、IOUserAudioCustomPropertiesを持つことができます。

00:05:50.000 --> 00:05:57.000
SimpleAudioDeviceは、カスタムプロパティと文字列の例を修飾子とデータ値として作成します。

00:05:57.000 --> 00:05:59.000
コードを見てみましょう。-コードを見てみましょう。

00:05:59.000 --> 00:06:03.000
SimpleAudioDriverはIOUserAudioDriverのサブクラスです。

00:06:03.000 --> 00:06:10.000
Start、Stop、およびNewUserClientは、ドライバーがオーバーライドする必要があるIOServiceクラスの仮想メソッドです。

00:06:10.000 --> 00:06:16.000
StartDeviceとStopDeviceは、IOUserAudioDriverのIO関連の仮想メソッドです。

00:06:16.000 --> 00:06:21.000
これらは、HALがオーディオデバイスのIOを開始または停止したときに呼び出されます。

00:06:21.000 --> 00:06:26.000
デバイス、ストリーム、その他のオーディオオブジェクトを調べた後、IOパスについて説明します。

00:06:26.000 --> 00:06:31.000
この例は、NewUserClientをオーバーライドしてユーザークライアント接続を作成する方法を示しています。

00:06:31.000 --> 00:06:37.000
NewUserClientは、クライアントプロセスがdextに接続したいときに呼び出されます。

00:06:37.000 --> 00:06:45.000
AudioDriverKitフレームワークは、IOUserAudioDriver基本クラスでNewUserClientを呼び出すことで、HALが必要とするユーザークライアントの作成を処理します。

00:06:45.000 --> 00:06:51.000
これにより、CoreAudio HALに必要なIOUserAudioDriverUserClientが作成されます。

00:06:51.000 --> 00:07:02.000
以前に追加されたドライバー拡張機能info.plistエントリからユーザークライアントオブジェクトを作成するIOService Createを呼び出すことで、カスタムユーザークライアントも作成できます。

00:07:02.000 --> 00:07:08.000
Startをオーバーライドし、カスタムIOUserAudioDeviceオブジェクトを作成する方法を見てみましょう。

00:07:08.000 --> 00:07:11.000
まず、スーパークラスでスタートを呼び出します。

00:07:11.000 --> 00:07:16.000
次に、SimpleAudioDeviceを割り当て、いくつかの必要なパラメータで初期化します。

00:07:16.000 --> 00:07:22.000
初期化されたデバイスは、AddObjectを呼び出してオーディオドライバに追加する必要があります。

00:07:22.000 --> 00:07:26.000
最後に、サービスを登録すると、ドライバーは行く準備が整います。

00:07:26.000 --> 00:07:32.000
ドライバーが初期化されたので、デバイス、ストリーム、その他のオーディオオブジェクトを作成しましょう。

00:07:32.000 --> 00:07:37.000
カスタム動作を取得するサブクラスIOUserAudioDevice。

00:07:37.000 --> 00:07:42.000
入力ストリーム、ボリュームコントロール、カスタムプロパティオブジェクトを作成しましょう。

00:07:42.000 --> 00:07:48.000
SimpleAudioDeviceのinitメソッドは、デバイスを設定し、さまざまなオーディオオブジェクトを作成する方法を示しています。

00:07:48.000 --> 00:07:56.000
デバイスのサンプルレート関連情報は、デバイスでSetAvailableSampleRatesとSetSampleRateを呼び出すことによって設定されます。

00:07:56.000 --> 00:08:01.000
IOUserAudioStreamに渡されるIOBufferMemoryDescriptorを作成します。

00:08:01.000 --> 00:08:05.000
メモリはCoreAudio HALにマッピングされ、オーディオIOに使用されます。

00:08:05.000 --> 00:08:10.000
メモリは理想的には、ハードウェアへのDMAに使用されるのと同じIOメモリであるべきです。

00:08:10.000 --> 00:08:19.000
IOUserAudioStreamは、入力ストリームの方向で指定し、上記で作成されたIOメモリ記述子を渡すことによって作成されます。

00:08:19.000 --> 00:08:23.000
機能する前に、ストリームでいくつかの追加設定をする必要があります。

00:08:23.000 --> 00:08:30.000
ストリームフォーマットは、IOUserAudio StreamBasicDescriptionsのフォーマットリストを作成することによって定義されます。

00:08:30.000 --> 00:08:35.000
サンプルレート、フォーマットID、およびその他の必要なフォーマットプロパティを指定します。

00:08:35.000 --> 00:08:39.000
上記で宣言されたストリームフォーマットリストを渡すことで、利用可能なフォーマットを設定します。

00:08:39.000 --> 00:08:42.000
そして、ストリームの現在のフォーマットを設定します。

00:08:42.000 --> 00:08:46.000
最後に、AddStreamを呼び出して、設定されたストリームをデバイスに追加します。

00:08:46.000 --> 00:08:49.000
それでは、ボリュームレベルコントロールの作成についてお進みください。

00:08:49.000 --> 00:08:56.000
ボリュームコントロールオブジェクトを作成するには、IOUserAudioLevelControl::Createメソッドを呼び出します。

00:08:56.000 --> 00:09:04.000
コントロールは、初期レベルが-6dBに設定され、範囲が96dBの設定可能なボリュームコントロールです。

00:09:04.000 --> 00:09:08.000
コントロールの要素、スコープ、およびクラスも指定する必要があります。

00:09:08.000 --> 00:09:11.000
最後に、コントロールオブジェクトをデバイスに追加します。

00:09:11.000 --> 00:09:18.000
ボリュームコントロールゲイン値は、入力ストリームのIOバッファにゲインを適用することにより、IOパスで使用されます。

00:09:18.000 --> 00:09:21.000
それでは、デバイスのカスタムプロパティオブジェクトの作成について確認しましょう。

00:09:21.000 --> 00:09:26.000
すべてのカスタムプロパティオブジェクトにプロパティアドレスを提供する必要があります。

00:09:26.000 --> 00:09:31.000
グローバルスコープとメイン要素を持つカスタムセレクタタイプを定義します。

00:09:31.000 --> 00:09:36.000
次に、上記で定義されたプロパティアドレスを提供して、カスタムプロパティオブジェクトを作成します。

00:09:36.000 --> 00:09:42.000
カスタムプロパティは設定可能で、修飾子とデータ値の型は両方とも文字列です。

00:09:42.000 --> 00:09:45.000
次に、修飾子とデータ値のOSStringを作成します。

00:09:45.000 --> 00:09:47.000
次に、カスタムプロパティに設定します。

00:09:47.000 --> 00:09:51.000
最後に、カスタムプロパティをデバイスに追加します。

00:09:51.000 --> 00:09:55.000
オーディオオブジェクトを作成したので、IOについて話しましょう。

00:09:55.000 --> 00:10:02.000
GetIOMemoryDescriptorメソッドは、IOUserAudioStreamで使用されるIOMemoryDescriptorを返します。

00:10:02.000 --> 00:10:11.000
IOMemoryDescriptorは、ストリームの作成時にinitメソッドに渡され、ストリームも新しいメモリ記述子で更新できます。

00:10:11.000 --> 00:10:16.000
メモリはHALにマッピングされ、オーディオIOに使用されます。

00:10:16.000 --> 00:10:22.000
ストリームで使用されるのと同じメモリ記述子は、理想的にはハードウェアデバイスへのDMAに使用されるものと同じであるべきです。

00:10:22.000 --> 00:10:27.000
IOUserAudioClockDeviceは、IOUserAudioDeviceの基本クラスです。

00:10:27.000 --> 00:10:34.000
UpdateCurrentZeroTimestampとGetCurrentZeroTimestampは、ハードウェアデバイスからのタイムスタンプを処理するために使用する必要があります。

00:10:34.000 --> 00:10:41.000
タイムスタンプはアトミックに処理され、HALはサンプルのタイムホストタイムペアを使用してIOを実行および同期します。

00:10:41.000 --> 00:10:45.000
ハードウェアクロックのタイムスタンプをできるだけ近くで追跡することが重要です。

00:10:45.000 --> 00:10:51.000
SimpleAudioDeviceクラスを見て、IO関連のメソッドに焦点を当てましょう。

00:10:51.000 --> 00:10:58.000
HALがIOを実行しようとすると、StartIOとStopIOがドライバーから呼び出されます。

00:10:58.000 --> 00:11:10.000
プライベートメソッドは、IOTimerDispatchSourceとOSActionを使用してハードウェア割り込みをシミュレートし、入力IOバッファでゼロタイムスタンプとオーディオデータを生成するために使用されます。

00:11:10.000 --> 00:11:18.000
この例はハードウェアデバイスに対して実行されていないため、ハードウェア割り込みとDMAの代わりにタイマーとアクションが使用されます。

00:11:18.000 --> 00:11:23.000
HALがデバイスでIOを起動しようとすると、デバイスオブジェクトでStartIOが呼び出されます。

00:11:23.000 --> 00:11:27.000
ハードウェアでIOを起動するために必要な呼び出しは、ここで行う必要があります。

00:11:27.000 --> 00:11:31.000
その後、StartIOは基本クラスで呼び出されるべきです。

00:11:31.000 --> 00:11:38.000
次に、入力ストリームのIOMemoryDescriptorを取得して、CreateMappingを呼び出してIOMemoryMapを作成できます。

00:11:38.000 --> 00:11:46.000
バッファアドレス、長さ、およびオフセットは、IOバッファにトーンを生成するために発生したハンドラで使用されます。

00:11:46.000 --> 00:11:55.000
StartTimersは、タイムスタンプを生成し、入力オーディオバッファに入力するためのタイムソースとアクションを設定して有効にするために呼び出されます。

00:11:55.000 --> 00:12:03.000
UpdateCurrentZeroTimestampは、IOUserAudioDeviceのサンプル時間-ホスト時間ペアを原子的に更新するために呼び出されます。

00:12:03.000 --> 00:12:11.000
タイマーソースは有効になり、mach_absolute_timeとデバイスから設定されたホストティックに基づいてウェイクアップ時間で設定されます。

00:12:11.000 --> 00:12:18.000
ZtsTimerOccurredアクションは、デバイスで新しいタイムスタンプを更新できるように、ウェイク時間に基づいて呼び出されます。

00:12:18.000 --> 00:12:26.000
ここには示されていませんが、サンプルコードはトーン生成タイマーとアクションも同様の方法で更新します。

00:12:26.000 --> 00:12:35.000
ゼロタイムスタンプアクションが発生すると、GetCurrentZeroTimestampを呼び出すことで、最後のゼロタイムスタンプ値がデバイスから取得されます。

00:12:35.000 --> 00:12:40.000
これが最初のタイムスタンプの場合は、タイマーに渡されたmach_absolute_timeをアンカー時間として使用します。

00:12:40.000 --> 00:12:47.000
それ以外の場合、タイムスタンプはゼロタイムスタンプ期間とバッファごとのホストティックによって更新されます。

00:12:47.000 --> 00:12:55.000
UpdateCurrentZeroTimestampを呼び出すと、HALが新しい値を使用できるようにデバイスのタイムスタンプが更新されます。

00:12:55.000 --> 00:13:02.000
次のゼロタイムスタンプのために将来目を覚ますようにZTSタイマーを設定します。

00:13:02.000 --> 00:13:08.000
DMAをシミュレートするために、タイマーアクションが実行されると、オーディオデータが入力IOバッファに書き込まれます。

00:13:08.000 --> 00:13:15.000
まず、start IOが呼び出されたときに割り当てられた入力メモリマップが有効かどうかを確認します。

00:13:15.000 --> 00:13:21.000
メモリマップバッファの長さとストリーム形式を使用して、IOバッファのサンプルの長さを取得します。

00:13:21.000 --> 00:13:30.000
ストリームは署名された16ビットpcmサンプル形式のみをサポートしているため、バッファアドレスとオフセットを取得し、int16_tバッファポインタとして割り当てます。

00:13:30.000 --> 00:13:34.000
これで、入力IOバッファは、正弦音を生成することによって埋めることができます。

00:13:34.000 --> 00:13:38.000
まず、入力ボリュームコントロールゲインをスカラー値として取得します。

00:13:38.000 --> 00:13:43.000
次に、必要なサンプル数をループし、ボリュームコントロールゲインを適用して正弦音を生成します。

00:13:43.000 --> 00:13:51.000
次に、バッファをループし、チャンネル数に基づいて正弦トーンサンプルをIOバッファに入力し、ラップアラウンドも考慮します。

00:13:51.000 --> 00:14:01.000
オーディオデクストが設定され、IOを実行できるようになったので、次のステップは、デバイスとそのIO関連の状態を更新するための構成変更を処理することです。

00:14:01.000 --> 00:14:06.000
表示されているデバイスメソッドは、構成変更を要求および実行するために使用できます。

00:14:06.000 --> 00:14:22.000
IOまたはその構造に影響を与えるオーディオデバイスの状態の変更については、ドライバーはRequestDeviceConfigurationChangeを呼び出して設定変更を要求する必要があります。HALは実行中のIOを停止し、PerformDeviceConfigurationChangeはドライバーで呼び出されます。

00:14:22.000 --> 00:14:26.000
そうして初めて、オーディオデバイスはIO関連の状態を更新できます。

00:14:26.000 --> 00:14:36.000
これの一般的なシナリオは、オーディオデバイスの現在のサンプルレートを更新するか、ハードウェアデバイスの変更に合わせて現在のストリーム形式を変更することです。

00:14:36.000 --> 00:14:41.000
この図は、デバイス構成変更の一連のイベントを示しています。

00:14:41.000 --> 00:14:44.000
ドライバーはまず設定の変更をリクエストする必要があります。

00:14:44.000 --> 00:14:49.000
HALは、デバイスの設定変更が開始されることをリスナーに通知します。

00:14:49.000 --> 00:14:52.000
IOが現在実行されている場合、IOはデバイスで停止します。

00:14:52.000 --> 00:14:55.000
デバイスの現在の状態がキャプチャされます。

00:14:55.000 --> 00:14:59.000
PerformDeviceConfigurationChangeがドライバで呼び出されます。

00:14:59.000 --> 00:15:03.000
これは、ドライバーがデバイスとハードウェアの状態を変更できるときです。

00:15:03.000 --> 00:15:12.000
設定変更が実行されると、デバイスの新しい状態がキャプチャされ、IOバッファやサンプルレートなどのすべてのIO関連状態が更新されます。

00:15:12.000 --> 00:15:16.000
デバイスの状態の変更は、クライアントリスナーに通知されます。

00:15:16.000 --> 00:15:23.000
設定変更前にIOが以前に実行されていた場合、IOはデバイスで再起動されます。

00:15:23.000 --> 00:15:28.000
最後に、HALは設定の変更が終了したことをリスナーに通知します。

00:15:28.000 --> 00:15:36.000
ハードウェアボトムアップ設定変更要求をシミュレートするために、カスタムユーザークライアントコマンドを使用して、dextのサンプルレート変更をトリガーします。

00:15:36.000 --> 00:15:43.000
RequestDeviceConfigurationChangeは、オーディオデバイスの設定変更要求をHALに通知します。

00:15:43.000 --> 00:15:46.000
変更情報は、あらゆる種類のOSObjectである可能性があることに注意してください。

00:15:46.000 --> 00:15:54.000
この例では、カスタム設定変更アクションと変更情報をOSStringとして提供します。

00:15:54.000 --> 00:16:08.000
構成変更の実行を処理するには、SimpleAudioDeviceクラスは、PerformDeviceConfigurationChangeのメソッドをオーバーライドする必要があります。PerformDeviceConfigurationChangeは、スイッチステートメントの構成変更アクションを処理します。

00:16:08.000 --> 00:16:14.000
設定変更が要求されたときに変更情報として提供されたのと同じOSStringオブジェクトを記録します。

00:16:14.000 --> 00:16:19.000
次に、現在のサンプルレートを取得し、デバイスに新しいレートを設定します。

00:16:19.000 --> 00:16:28.000
ストリームオブジェクトでDeviceSampleRateChangedを呼び出して、サンプルレートの変更を処理するために、オーディオストリームが現在のストリームフォーマットを更新していることを確認してください。

00:16:28.000 --> 00:16:34.000
デバイスが直接処理しないその他の設定変更アクションは、基本クラスに渡すことができます。

00:16:34.000 --> 00:16:36.000
Macでこれを見てみましょう。 では、Macで見てみましょう。

00:16:36.000 --> 00:16:41.000
So SimpleAudioは、ドライバ拡張機能をバンドルするサンプルコードアプリケーションです。

00:16:41.000 --> 00:16:47.000
オーディオドライバ拡張機能をインストールするには、[ドライバのインストール]を押すだけで、セキュリティ設定が表示されるはずです。

00:16:47.000 --> 00:16:53.000
したがって、Allowキーを押すと、オーディオドライバの拡張機能が動的に読み込まれます。

00:16:53.000 --> 00:16:58.000
以前は、再起動が必要になるため、これはkextでは不可能でした。

00:16:58.000 --> 00:17:06.000
そのため、SimpleAudioDeviceには、利用可能なサンプルレート形式とトーン選択データソースがあります。

00:17:06.000 --> 00:17:09.000
そして、サンプルコードに追加したボリュームコントロール。

00:17:09.000 --> 00:17:15.000
これで、QuickTimeを開いて、オーディオデバイスでオーディオ録音を行うことができます。

00:17:15.000 --> 00:17:31.000
また、ボトムアップ設定の変更をテストするには、dextと直接通信してトーン周波数またはサンプルレートを切り替えることができ、変更はAudio MIDI設定にも反映する必要があります。

00:17:31.000 --> 00:17:42.000
ドライバーの拡張機能を削除するには、アプリケーションを削除するだけです。

00:17:42.000 --> 00:17:46.000
そして、オーディオMIDIの設定では利用できなくなったことがわかります。

00:17:46.000 --> 00:17:51.000
まとめとして、オーディオサーバープラグインとDriverKit拡張機能の状態をまとめました。

00:17:51.000 --> 00:17:57.000
これは引き続きサポートされ、AudioServerPlugInドライバインターフェイスは非推奨ではありません。

00:17:57.000 --> 00:18:03.000
私は新しいAudioDriverKitフレームワークを紹介し、新しいドライバーモデルの利点について議論しました。

00:18:03.000 --> 00:18:15.000
AudioDriverKitフレームワークを採用する方法の詳細な例を調べ、ユーザースペースで実行されているIOUserServiceベースのオーディオデクストを作成するためのサンプルコードを示しました。

00:18:15.000 --> 00:18:18.000
最新のXcodeとDriverKit SDKをダウンロードしてください。

00:18:18.000 --> 00:18:25.000
DriverKitがサポートするハードウェアデバイスファミリを持つオーディオデバイスにAudioDriverKitを採用してください。

00:18:25.000 --> 00:18:30.000
また、Appleのフィードバックアシスタントを通じて、AudioDriverKitに関するフィードバックを提供してください。

00:18:30.000 --> 00:18:32.000
ありがとう。

00:18:32.000 --> 23:59:59.000
[明るい音楽]。

