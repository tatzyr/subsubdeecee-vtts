WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:15.000
こんにちは、「App AttestとDeviceCheckで詐欺を軽減」へようこそ。

00:00:15.000 --> 00:00:19.000
私の名前はXuerui Yanで、App Store Trust and Safetyチームで働いています。

00:00:19.000 --> 00:00:26.000
App AttestとDeviceCheckを使用してアプリを保護することについて話すことに興奮しています。

00:00:26.000 --> 00:00:35.000
Appleでは、App Storeが顧客や開発者にとって安全で信頼できる場所であることを常に確認しています。

00:00:35.000 --> 00:00:39.000
このビデオでは、エンジニアリングの詳細について説明します。

00:00:39.000 --> 00:00:50.000
ビジネスと概念の詳細については、WWDC 2021の「アカウント、プロモーション、コンテンツの保護」ビデオを参照してください。

00:00:50.000 --> 00:00:55.000
iOS 11では、DeviceCheckフレームワークを導入しました。

00:00:55.000 --> 00:01:00.000
DeviceCheckは、プロモーション製品の詐欺を軽減するのに役立ちます。

00:01:00.000 --> 00:01:04.000
アプリに新機能を導入していると仮定します。

00:01:04.000 --> 00:01:09.000
この機能を宣伝するために、無料の使い捨てアイテムを提供しています。

00:01:09.000 --> 00:01:18.000
誰かが無料のアイテムを請求するためだけに何度も何度もアプリを再インストールすることで、プロモーションを悪用するかもしれません。

00:01:18.000 --> 00:01:30.000
おそらく、アプリを繰り返しインストールしてプロモーションを再利用するのではなく、プロモーションアイテムをデバイスごとに1回に制限したいと思うでしょう。

00:01:30.000 --> 00:01:43.000
現在、DeviceCheckは、デバイスがプロモーションオファーを受け取ったかどうか、またはデバイスが不正行為に参加したかどうかを検出するのに役立ちます。

00:01:43.000 --> 00:01:53.000
これにより、1つのデバイスに関連付けられた2ビットの情報とタイムスタンプをAppleサーバーに永続的に保存できます。

00:01:53.000 --> 00:01:59.000
これらのビットがアプリケーションにとって何を意味するかを決めるのはあなた次第です。

00:01:59.000 --> 00:02:05.000
状態は、あなたが更新して照会するためにAppleによって維持されます。

00:02:05.000 --> 00:02:09.000
ビットは開発者からのすべてのアプリによって共有されます。

00:02:09.000 --> 00:02:18.000
すべてのアプリに適用できるように、ビットに意味を割り当てるときは、それを覚えておいてください。

00:02:18.000 --> 00:02:27.000
状態は、アプリの再インストール、ユーザー間のデバイス転送、さらには「すべてのコンテンツと設定を消去」しても持続します。

00:02:27.000 --> 00:02:38.000
プロモーションおよびビジネス戦略に基づいて、タイムスタンプを使用して選択した期間のビットをリセットすることを検討してください。

00:02:38.000 --> 00:02:49.000
DeviceCheckの詳細については、WWDC 2017の「プライバシーとアプリ」ビデオとDeviceCheck Frameworkのドキュメントを参照してください。

00:02:49.000 --> 00:02:52.000
それがDeviceCheckです。

00:02:52.000 --> 00:03:00.000
次に、DeviceCheck Frameworkでも利用可能なApp Attestについて話します。

00:03:00.000 --> 00:03:08.000
あなたのサービスがリクエストを受け取ると、それが本当にあなたのアプリからのものかどうかを知るのは難しいかもしれません。

00:03:08.000 --> 00:03:16.000
App Attestを使用すると、アプリはリクエストの一部としてハードウェアに裏打ちされたアサーションを添付できます。

00:03:16.000 --> 00:03:23.000
サーバーはアサーションを使用して、リクエストが本物のAppleデバイス上の本物のアプリから来たことを確認できます。

00:03:23.000 --> 00:03:38.000
想像してみてください、あなたは収集品を発見するために旅行を奨励する美しいアプリを設計し、変更されたアプリが家を出ることなくすべてを集めることができることがわかりました。

00:03:38.000 --> 00:03:50.000
または、競争力のあるマルチプレイヤーレースゲームで無制限のブーストを得るためにチートを使用して、他の人がリーダーボードをレースするのを見るプレイヤーの欲求不満を想像してみてください。

00:03:50.000 --> 00:04:06.000
または、土曜日に目を覚まし、あなたのサーバーで非常に高いリクエスト量を見て、あなたの喜びを想像してみてください、しかし、調査の後、あなたは通話があなたのアプリからまったく来ていないことがわかります。

00:04:06.000 --> 00:04:17.000
App Attestは、アプリの正規版と修正版を特定するのに役立ち、アプリ体験とビジネスを保護することができます。

00:04:17.000 --> 00:04:27.000
App Attestは、あなたとあなたの顧客を保護するために利用できる3つの重要なプロパティを提供します。

00:04:27.000 --> 00:04:46.000
App Attestを使用すると、3つの条件を満たすことで、アプリの正当なインスタンスからのリクエストをサービスで確認できます。リクエストは本物のAppleデバイスから来て、本物のアプリケーションを実行し、ペイロードが改ざんされていないこと。

00:04:46.000 --> 00:04:52.000
App Attestがこれらのプロパティのそれぞれをどのように提供しているかを見てみましょう。

00:04:52.000 --> 00:05:05.000
App Attestの中心には、安全なキーペアとAppleが署名した証明書があり、キーペアが本物のAppleデバイスに由来することを証明しています。

00:05:05.000 --> 00:05:14.000
秘密鍵は、App Attest APIを使用してSecure Enclaveを通じてのみ保存され、アクセス可能です。

00:05:14.000 --> 00:05:26.000
アプリはキーでサービスへのリクエストに署名することができ、サービスは署名をチェックして、リクエストが本物のAppleデバイスで生成されたことを確認できます。

00:05:26.000 --> 00:05:32.000
Appleデバイスでアプリを実行するには、署名が必要です。

00:05:32.000 --> 00:05:39.000
アプリに不正な変更を加える人は、自分が管理するIDで再署名する必要があります。

00:05:39.000 --> 00:05:45.000
これは必然的にアプリのアイデンティティを変更します。

00:05:45.000 --> 00:05:51.000
認証には、アプリのIDのハッシュを含めます。

00:05:51.000 --> 00:06:01.000
アプリのIDと認証に含まれるものを比較することで、発信者が変更されたバージョンを使用しているかどうかを判断できます。

00:06:01.000 --> 00:06:12.000
リクエストが本物のデバイスと本物のアプリから来たことがわかったので、リクエストペイロードについて話しましょう。

00:06:12.000 --> 00:06:21.000
ペイロードをサーバーに送信する前に、証明されたキーを使用してペイロードのダイジェストに署名するようにApp Attestに指示できます。

00:06:21.000 --> 00:06:26.000
これにより、ペイロードのアサーションが作成されます。

00:06:26.000 --> 00:06:30.000
アプリは、ペイロードとアサーションをサービスに送信する必要があります。

00:06:30.000 --> 00:06:39.000
ペイロードに対するアサーションを検証することで、ペイロードが輸送中に改ざんされていないことを信頼できます。

00:06:39.000 --> 00:06:42.000
これらは3つの重要な特性です。

00:06:42.000 --> 00:06:46.000
では、プライバシーについて少し話しましょう。

00:06:46.000 --> 00:06:51.000
ここアップルでは、プライバシーを深く気にかけています。

00:06:51.000 --> 00:06:57.000
私たちは、プライバシーが健全なアプリエコシステムにとって不可欠な基盤であると信じています。

00:06:57.000 --> 00:07:03.000
App Attestの各要素は、プライバシーを念頭に置いて構築されています。

00:07:03.000 --> 00:07:11.000
認証は、追跡から保護しながら、本物のデバイスの保証を提供するように設計されています。

00:07:11.000 --> 00:07:17.000
認証は匿名で、ハードウェア識別子は含まれていません。

00:07:17.000 --> 00:07:22.000
App Attestキーは、アプリのインストールごとに一意です。

00:07:22.000 --> 00:07:33.000
これは、App Attestキーがアプリの再インストールに耐えられず、バックアップされず、デバイス間で同期されないことを意味します。

00:07:33.000 --> 00:07:38.000
アプリを設計するときは、これを覚えておいてください。

00:07:38.000 --> 00:07:48.000
App Attestが提供する価値を理解したので、アプリに組み込む詳細を掘り下げてみましょう。

00:07:48.000 --> 00:07:54.000
App Attestをアプリに組み込むための3つの基本的な部分があります。

00:07:54.000 --> 00:08:02.000
App Attestキーを作成し、キーを証明および検証し、アサーションを生成および検証します。

00:08:02.000 --> 00:08:06.000
App Attestキーの作成から始めましょう。

00:08:06.000 --> 00:08:11.000
すべてのApp Attestコールは、isSupportedプロパティによって保護されるべきです。

00:08:11.000 --> 00:08:24.000
App AttestはSecure Enclaveを持つデバイスでサポートされていますが、App Extensionsなど、isSupportedが依然としてfalseを返す場合があります。

00:08:24.000 --> 00:08:29.000
アプリはこれらのケースを適切に処理する必要があります。

00:08:29.000 --> 00:08:36.000
すぐにアクセスをブロックするのではなく、障害をリスクシグナルとして使用してください。

00:08:36.000 --> 00:08:40.000
まず、発信者を信頼できないものとして分類します。

00:08:40.000 --> 00:08:49.000
次に、リスク評価ロジックに基づいて、クライアントが機密性の高い機能を使用できるようにするかどうかを評価します。

00:08:49.000 --> 00:08:58.000
もう1つのアプローチは、サービスを呼び出すときにApp Attestをサポートしていないと主張するデバイスの急激な増加を監視することです。

00:08:58.000 --> 00:09:09.000
App Attestをサポートするデバイスの比率が突然減少した場合、変更されたアプリがチェックをバイパスしようとしている兆候である可能性があります。

00:09:09.000 --> 00:09:17.000
App Attestキーが正常に生成されたら、先に進んでキーを証明しましょう。

00:09:17.000 --> 00:09:24.000
中間者攻撃やリプレイ攻撃を防ぐには、1回限りのサーバーチャレンジが必要です。

00:09:24.000 --> 00:09:28.000
サーバーにアプリへのチャレンジを発行してもらいましょう。

00:09:28.000 --> 00:09:40.000
認証をユーザーアカウントIDまたはその他の値にリンクするには、それらの値をハッシュしてclientDataHashを作成するチャレンジします。

00:09:40.000 --> 00:09:49.000
clientDataHashを使用して、前のステップのkeyIdとともに、attestKey APIを呼び出すことができます。

00:09:49.000 --> 00:10:00.000
attestKeyは秘密鍵を使用してデバイスのハードウェア認証要求を作成し、確認のためにAppleに要求を送信します。

00:10:00.000 --> 00:10:07.000
確認後、Appleは匿名の認証オブジェクトをアプリに返します。

00:10:07.000 --> 00:10:15.000
認証は、カスタムペイロードとともに、検証のためにサーバーに送り返します。

00:10:15.000 --> 00:10:22.000
さて、アプリが認証をサーバーに送信したので、確認してみましょう。

00:10:22.000 --> 00:10:36.000
認証はWeb認証基準に従っており、Appleが署名した証明書のリスト、Authenticatorデータ構造、およびリスクメトリックの領収書の3つの部分が含まれています。

00:10:36.000 --> 00:10:42.000
確認する必要がある重要な部分を見てみましょう。 確認する必要があります。

00:10:42.000 --> 00:10:48.000
証明書セクションには、リーフ証明書と中間証明書が含まれています。

00:10:48.000 --> 00:10:55.000
App Attestルート証明書は、Apple Private PKIリポジトリで入手できます。

00:10:55.000 --> 00:11:02.000
完全な証明書チェーンを検証すると、デバイスが本物のAppleデバイスであることがわかります。

00:11:02.000 --> 00:11:12.000
attestKeyを呼び出すと、nonceと呼ばれるシングルユースハッシュがclientDataHashやその他のデータから作成されました。

00:11:12.000 --> 00:11:16.000
そのノンスは葉の証明書に含まれています。

00:11:16.000 --> 00:11:24.000
改ざんを防ぐために、サーバー上のノンスを再構築し、それが一致することを確認します。

00:11:24.000 --> 00:11:36.000
オーセンティケータデータブロックには、アプリIDのハッシュを含む複数のプロパティが含まれており、アプリがあなたを呼び出していることを確認するために使用できます。

00:11:36.000 --> 00:11:44.000
キー認証には、Appleにリスク指標を要求するために保管して後で使用できる領収書も含まれています。

00:11:44.000 --> 00:11:49.000
それについての詳細は、ビデオの後半で取り上げます。

00:11:49.000 --> 00:11:54.000
すべてがチェックアウトされた場合、App Attestキーは本物です。

00:11:54.000 --> 00:12:02.000
後続の要求を検証するために使用するために、クライアントデータに関連付けられたキーを保存します。

00:12:02.000 --> 00:12:06.000
すべての失敗が無効な認証によるものというわけではありません。

00:12:06.000 --> 00:12:16.000
isSupportedがfalseを返す、ランプアップ中にスロットルされる、または一般的なネットワーク障害などのシナリオを優雅に処理します。

00:12:16.000 --> 00:12:22.000
その後、全体的なリスク評価に障害をシグナルとして組み込むことができます。

00:12:22.000 --> 00:12:28.000
検証の実施の詳細については、ドキュメントを参照してください。

00:12:28.000 --> 00:12:36.000
attest-Key APIを呼び出すと、アプリからApp Attestサービスへのネットワークコールが生成されます。

00:12:36.000 --> 00:12:39.000
これは、アプリインスタンスごとに1回しか発生しません。

00:12:39.000 --> 00:12:47.000
ただし、インストールベースが大きい場合、アプリはApp Attestに多くのリクエストを送信する可能性があります。

00:12:47.000 --> 00:12:56.000
リソースを管理し、レートの制限を避けるために、インストールベース全体でこの機能を徐々に有効にしてください。

00:12:56.000 --> 00:13:05.000
たとえば、毎日100万人のアクティブユーザーがいる場合、おそらく1日かそこらでランプアップすることができます。

00:13:05.000 --> 00:13:09.000
毎日10億人のアクティブユーザーがいるなら、お疲れ様でした!

00:13:09.000 --> 00:13:14.000
あなたは1ヶ月以上ランプアップする必要があります。

00:13:14.000 --> 00:13:25.000
認証されたキーがわかったので、generateAssertion API呼び出しを使用して、アプリとサーバー間の機密性の高い通信を保護できます。

00:13:25.000 --> 00:13:33.000
Appleのサーバーはもはや関与していないため、アサーションフローは認証よりも簡単です。

00:13:33.000 --> 00:13:41.000
キーを使用するすべてのアサーションは、デバイス上で生成され、サーバー上で検証されます。

00:13:41.000 --> 00:13:51.000
まず、サーバーに一意のチャレンジを要求し、ペイロードのダイジェストを生成し、generateAssertionを呼び出します。

00:13:51.000 --> 00:13:59.000
generateAssertionは、ダイジェストを使用してノンスを計算し、App Attestキーで署名します。

00:13:59.000 --> 00:14:04.000
その後、アプリはペイロードとアサーションをサーバーに送信できます。

00:14:04.000 --> 00:14:09.000
最後に、サーバーはペイロードを確認する必要があります。

00:14:09.000 --> 00:14:13.000
アサーションペイロードには、この高レベルの構造が含まれています。

00:14:13.000 --> 00:14:18.000
署名と認証データ。

00:14:18.000 --> 00:14:24.000
署名を検証するには、プロセスを逆にしてサーバー上のノンスを再構築します。

00:14:24.000 --> 00:14:29.000
次に、公開鍵を使用して署名を確認します。

00:14:29.000 --> 00:14:36.000
署名が有効な場合は、ペイロードが変更されていないことを信頼できます。

00:14:36.000 --> 00:14:41.000
オーセンティケータデータセクションには、アプリのIDハッシュが含まれています。

00:14:41.000 --> 00:14:48.000
ハッシュを検証して、アサーションが本物のアプリからのものであることを確認します。

00:14:48.000 --> 00:14:53.000
オーセンティケータデータには、増え続けるカウンターも含まれています。

00:14:53.000 --> 00:15:04.000
リプレイ攻撃から保護するために、カウンター値をサーバーに保存し、その後のリクエストごとに増加することを期待します。

00:15:04.000 --> 00:15:10.000
キーを使用すると、必要なだけこのプロセスを繰り返すことができます。

00:15:10.000 --> 00:15:17.000
アサーションを生成することはAppleサーバーを呼び出すことはありませんが、それはいくつかのレイテンシを追加する暗号化操作です。

00:15:17.000 --> 00:15:25.000
App Attestをアプリに組み込むときは、これをデザインに組み込む必要があります。

00:15:25.000 --> 00:15:36.000
アサーションは、重要だがまれな呼び出し、および追加のレイテンシと必要な計算に対処できる呼び出しに適しています。

00:15:36.000 --> 00:15:42.000
頻繁なリアルタイムネットワークコマンドの場合、アサーションは適していない可能性があります。

00:15:42.000 --> 00:15:44.000
おめでとうございます！

00:15:44.000 --> 00:15:49.000
これで、App Attestの基本的な実装が完了しました。

00:15:49.000 --> 00:16:02.000
この実装だけで、着信サーバー要求を本物で変更されたものとして分類し始め、この重要な詐欺信号をビジネスロジックに組み込むことができます。

00:16:02.000 --> 00:16:04.000
しかし、もっとあります。

00:16:04.000 --> 00:16:20.000
攻撃者は、単一のデバイスを使用して多くのApp Attestキーを作成し、そのデバイスを使用して多くの変更されたアプリとサーバー間の通信を提供することで、App Attestを回避しようとする可能性があります。

00:16:20.000 --> 00:16:35.000
このような動作を検出するために、アプリのデバイスに作成されたキーのおおよその数を提供するApp Attest Risk Metric Serviceと呼ばれるサービスを提供しています。

00:16:35.000 --> 00:16:41.000
attestKeyは、認証とリスクメトリックの領収書の両方を返すことを思い出してください。

00:16:41.000 --> 00:16:48.000
サーバーは、その領収書をサービスに送信し、新しい領収書と引き換えることができます。

00:16:48.000 --> 00:16:53.000
新しい領収書にはリスク指標が含まれます。

00:16:53.000 --> 00:17:02.000
定期的に、最新の領収書をそのアプリ/デバイスペアの更新されたメトリクスに引き換えることができます。

00:17:02.000 --> 00:17:06.000
これは、レシート構造の高レベルのビューです。

00:17:06.000 --> 00:17:10.000
それはPKCS7コンテナです。

00:17:10.000 --> 00:17:17.000
詳細については、DeviceCheck Frameworkドキュメントの「詐欺リスクの評価」を参照してください。

00:17:17.000 --> 00:17:22.000
App ClipsはiOSのエキサイティングな機能です。

00:17:22.000 --> 00:17:29.000
iOS 15のApp ClipsにApp Attestのサポートを追加しました。

00:17:29.000 --> 00:17:40.000
App Clipからフルアプリへのシームレスなアップグレードをサポートするために、App ClipとフルアプリはApp Attestコンテキストで同じアプリIDを共有します。

00:17:40.000 --> 00:17:47.000
サーバー側でアプリのIDを確認するときは、この点に留意してください。

00:17:47.000 --> 00:17:58.000
App Clipsが手動で削除または期限切れになると、完全なアプリがアンインストールされたときと同じように、そのキーは無効になります。

00:17:58.000 --> 00:18:02.000
はい、App Clipsはそれでおそれです。

00:18:02.000 --> 00:18:07.000
さて、App Attestで成功するためのこれらの重要なポイントを覚えておいてください。

00:18:07.000 --> 00:18:10.000
デバイス上ではなく、サーバーで検証します。

00:18:10.000 --> 00:18:15.000
アプリは、検証コードを無効にするために変更される場合があります。

00:18:15.000 --> 00:18:22.000
ネットワークリプレイ攻撃を防ぐために、ワンタイムサーバーチャレンジをフローに組み込みます。

00:18:22.000 --> 00:18:32.000
isSupportedがfalseを返す、ランプアップ中にスロットルされる、または一般的なネットワーク障害などの障害シナリオを処理します。

00:18:32.000 --> 00:18:37.000
リスク評価のシグナルとして失敗を組み込む。

00:18:37.000 --> 00:18:45.000
App AttestとDeviceCheckは、全体的な不正評価に統合できる情報を提供します。

00:18:45.000 --> 00:18:51.000
DeviceCheckを使用して、プロモーション製品の詐欺を軽減します。

00:18:51.000 --> 00:19:00.000
App Attestを活用して、アプリの変更されたバージョンを検出し、コンテンツとユーザーエクスペリエンスを保護します。

00:19:00.000 --> 00:19:01.000
見てくれてありがとう!

00:19:01.000 --> 00:19:08.000
あなたのアプリがApp AttestとDeviceCheckで保護されるのを楽しみにしています。

00:19:08.000 --> 23:59:59.000
平和！

