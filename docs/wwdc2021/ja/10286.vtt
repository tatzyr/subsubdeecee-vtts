WEBVTT

00:00:00.000 --> 00:00:05.000
♪ベース音楽の演奏♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:11.000
アレハンドロ・セゴビア・アザピアン:WWDCへようこそ!

00:00:11.000 --> 00:00:16.000
私の名前はAle Segovia Azapianで、AppleのGPUソフトウェアエンジニアです。

00:00:16.000 --> 00:00:21.000
このセッションでは、Metalのバインドレスレンダリングを探ります。

00:00:21.000 --> 00:00:29.000
Bindlessは、GPUがリソースのグループを利用できるようにして最新のレンダリング技術を実装できる最新のリソースバインディングモデルです。

00:00:29.000 --> 00:00:33.000
まず、バインドレスの背後にあるコンセプトの必要性を見ていきます。

00:00:33.000 --> 00:00:41.000
次に、バインドレスモデルを紹介し、従来のバインディングモデルの課題を解決するために必要な柔軟性をどのように提供するかを示します。

00:00:41.000 --> 00:00:51.000
エン則バッファを使用してシーンリソースをエンコードしてMetalで利用できるようにするメカニズムと、シェーダーからGPU構造をナビゲートする方法を要約します。

00:00:51.000 --> 00:00:53.000
始めましょう！

00:00:53.000 --> 00:01:02.000
したがって、バインドレスレンダリングは、すべてのシーンリソースをシェーダーで利用できるようにし、グラフィック技術に信じられないほどの柔軟性をもたらします。

00:01:02.000 --> 00:01:06.000
例を見てみましょう。 例を見てみましょう。

00:01:06.000 --> 00:01:11.000
加速構造に対する交点を見つけるレイトレーシングカーネルがあると想像してみましょう。

00:01:11.000 --> 00:01:18.000
レイトレーシングシャドウなどの一部の光効果では、アルゴリズムは非常に自然です。

00:01:18.000 --> 00:01:23.000
交点と光の間の物体を見つけたい。

00:01:23.000 --> 00:01:29.000
影の光線をたどるために必要なのは、光に向かう位置と方向だけです。

00:01:29.000 --> 00:01:39.000
光線と交差点のパラメータから導き出すことができる交差点の世界空間位置を超えて、オブジェクト属性や金属資源は必要ありません。

00:01:39.000 --> 00:01:43.000
しかし、反射などの他の効果については、状況はより複雑になります。

00:01:43.000 --> 00:01:49.000
メタルシェーディング言語のレイトレーシング反射シェーダーを見てみましょう。

00:01:49.000 --> 00:01:57.000
この新しい例では、交差点を見つけたばかりで、ピクセルを正しい反射色でペイントしようとしています。

00:01:57.000 --> 00:02:03.000
交差点を見つけた後に単色を塗るだけで、地面の反射は正確には見えません。

00:02:03.000 --> 00:02:14.000
正しい結果を得るには、見つかった各反射点の属性を決定し、そのピクセルの正しい陰影を計算する必要があります。

00:02:14.000 --> 00:02:22.000
この問題は、場合によっては、拡散グローバル照明や周囲の閉塞など、他の光線追跡効果にも存在します。

00:02:22.000 --> 00:02:27.000
課題は、私たちが光線トレースするとき、私たちの光線が加速構造内の任意の物体に当たる可能性があることです。

00:02:27.000 --> 00:02:39.000
これは、レイトレーシングシェーダーから、交差するメッシュに関連する頂点データとその素材を含む、シーン内の金属リソースにアクセスする必要がある可能性があることを意味します。

00:02:39.000 --> 00:02:43.000
この量のリソースをパイプラインに直接バインドすることはできません。

00:02:43.000 --> 00:02:47.000
ここで、バインドレスバインディングモデルの出番です。

00:02:47.000 --> 00:02:52.000
バインドレスの背後にあるアイデアは、リソースを集約し、それらをリンクすることです。

00:02:52.000 --> 00:03:00.000
これにより、単一のバッファをパイプラインにバインドし、ナビゲーションを介して参照されたすべてのリソースを利用できるようにすることができます。

00:03:00.000 --> 00:03:03.000
メタルでは、これを行うことを可能にする構造は引数バッファです。

00:03:03.000 --> 00:03:08.000
特に、バインドレスの場合、引数バッファTier 2が必要です。

00:03:08.000 --> 00:03:12.000
これらは、Apple6およびMac2 GPUファミリで利用できます。

00:03:12.000 --> 00:03:16.000
引数バッファは、Metalのすべてのシェーダータイプから使用できます。

00:03:16.000 --> 00:03:20.000
これは、レイトレーシングとラスタライズの両方に使用できることを意味します。

00:03:20.000 --> 00:03:27.000
私たちが見たように、特定のレイトレーシング効果のために、良好な視覚結果を得るためにバインドレスを使用することは必須です。

00:03:27.000 --> 00:03:32.000
ラスタライズの場合、使用はオプションですが、直接バインディングモデルよりも利点があります。

00:03:32.000 --> 00:03:46.000
特に、特定のドローコールにバインドできるリソース数のスロット制限を事実上削除し、このセッションの後半で検討するいくつかの素晴らしい最適化の機会も提供します。

00:03:46.000 --> 00:03:56.000
Metal APIへの1回の呼び出しで、一定のデータとリソースを一度にバインドできるメカニズムとして、Metal 2を使用した引数バッファを導入しました。

00:03:56.000 --> 00:04:02.000
引数バッファは非常に柔軟で、他のバッファを参照することもできます。

00:04:02.000 --> 00:04:08.000
バインドレスモデルの背後にあるアイデアは、この機能を活用してすべてのシーンリソースをリンクすることです。

00:04:08.000 --> 00:04:13.000
これにより、それらをGPUで同時に利用できるようになります。

00:04:13.000 --> 00:04:19.000
シーンリソースを引数バッファにリンクする方法の例を見てみましょう。

00:04:19.000 --> 00:04:23.000
この消防車のようなモデルをレンダリングしたいとしましょう。

00:04:23.000 --> 00:04:28.000
このモデルは、テクスチャ、頂点データ、およびインデックスデータで構成されています。

00:04:28.000 --> 00:04:35.000
これらは、従来のバインディングモデルのドローコールごとに1つずつバインドする典型的なリソースです。

00:04:35.000 --> 00:04:45.000
しかし、私たちの場合、シーンのすべてのテクスチャ、頂点データ、およびインデックスを一度に利用できるようにしたいので、これらを集約する必要があります。

00:04:45.000 --> 00:04:47.000
ここにそうする潜在的な方法があります。

00:04:47.000 --> 00:04:55.000
まず、資産の編成方法に応じて、すべてのメッシュまたはサブメッシュを含むメッシュ引数バッファを作成できます。

00:04:55.000 --> 00:05:01.000
この引数バッファを使用すると、シーンの頂点配列とインデックス配列を参照できます。

00:05:01.000 --> 00:05:06.000
同様に、同じことをして、マテリアルを引数バッファにエンコードすることができます。

00:05:06.000 --> 00:05:13.000
各マテリアルは、そのテクスチャを参照するだけでなく、インライン定数データを含めることができます。

00:05:13.000 --> 00:05:19.000
わかりましたが、すべてのメッシュと素材がGPUで利用できるようになったので、どうすればそれらをまとめることができますか?

00:05:19.000 --> 00:05:25.000
たとえば、インスタンスオブジェクトを作成し、引数バッファに配置することもできます。

00:05:25.000 --> 00:05:29.000
インスタンスは、1つのメッシュと関連するマテリアルを参照できます。

00:05:29.000 --> 00:05:34.000
これは、モデル変換行列をインライン定数データとして保存するのに最適な場所です。

00:05:34.000 --> 00:05:36.000
しかし、私たちはそこで止まる必要はありません。

00:05:36.000 --> 00:05:43.000
1つのインスタンスを保存できるようになったので、これをさらに進めて、すべてのインスタンスを配列としてこの引数バッファにエンコードすることができます。

00:05:43.000 --> 00:05:50.000
この図を簡素化し、それぞれが独自の材料を持ついくつかのトラックインスタンスを追加しましょう。

00:05:50.000 --> 00:05:59.000
ご覧のとおり、これで、フルシーンとそのリソースをエンコードし、引数バッファとリンクできるようになりました。

00:05:59.000 --> 00:06:07.000
後で、シェーダーからこれらのリソースのいずれかを参照する場合は、インスタンスバッファへのポインタが必要です。

00:06:07.000 --> 00:06:15.000
直接渡して、このバッファを配列として解釈したり、別のシーン引数バッファにポインタを渡したりできます。

00:06:15.000 --> 00:06:20.000
さて、間接的にアクセスされたリソースの居住で何が起こるかに注意することが重要です。

00:06:20.000 --> 00:06:30.000
シーンへのポインタをパイプラインに渡すだけなので、Metalはこのバッファ参照については知っていますが、間接的にアクセスされるリソースについては知りません。

00:06:30.000 --> 00:06:36.000
アプリケーションは、間接的にアクセスされたすべてのリソースの居住を宣言する責任があります。

00:06:36.000 --> 00:06:43.000
リソースを常駐させるということは、GPUでメモリを利用できるようにするためにドライバーに信号を送ることを意味します。

00:06:43.000 --> 00:06:48.000
これは、シェーダーから参照できるように必要です。

00:06:48.000 --> 00:06:57.000
これを行うには、コンピューティングエンコーダ用のuseResource:usage: APIとレンダリングコマンドエンコーダ用のuseResource:usage:stages: APIを呼び出すことができます。

00:06:57.000 --> 00:07:02.000
非居住者リソースへのアクセスは、GPUの再起動とコマンドバッファの失敗の一般的な原因です。

00:07:02.000 --> 00:07:07.000
これは、このAPIを呼び出すのを忘れた場合、メモリページが存在しない可能性があるためです。

00:07:07.000 --> 00:07:12.000
したがって、間接的にアクセスされたすべてのリソースをMetalに宣言することが非常に重要です。

00:07:12.000 --> 00:07:21.000
さて、もう1つのオプションは、便宜上、MTLHeapsから割り当てられたリソースを、useHeap APIを使用して1回の呼び出しで常駐させることができるようになったことです。

00:07:21.000 --> 00:07:27.000
すでにヒープからリソースをサブ割り当てまたはサブ割り当てすることを計画している場合、これは素晴らしい選択肢です。

00:07:27.000 --> 00:07:35.000
現在、ヒープはMetal APIの素晴らしい部分であり、最高のリソース作成パフォーマンスとメモリ節約の機会のためにそれらを使用することをお勧めします。

00:07:35.000 --> 00:07:39.000
しかし、それらを効果的に使用するためのいくつかの考慮事項があります。

00:07:39.000 --> 00:07:44.000
最初に尋ねるべきことは、私たちのサブ割り当てリソースはすべて読み取られるだけですか?

00:07:44.000 --> 00:07:52.000
リソースに書き込む必要がある場所の例には、計算シェーダーからのメッシュスキニングや動的テクスチャなどがあります。

00:07:52.000 --> 00:08:02.000
このような場合、GPUがリソースに書き込む必要がある場合は、書き込み使用フラグを使用して個別に居住者を宣言する必要があります。

00:08:02.000 --> 00:08:10.000
さらに、変更された可能性のあるリソースは、独自のuseResource呼び出しが必要です。

00:08:10.000 --> 00:08:19.000
これは、Metalフレームワークがリソースの移行を処理し、GPUキャッシュをフラッシュし、内部メモリレイアウトを調整できるようにするためのものです。

00:08:19.000 --> 00:08:24.000
2番目の考慮事項は、ヒープトラックはリソースの依存関係をサブ割り当てしますか？

00:08:24.000 --> 00:08:31.000
繰り返しますが、同じヒープからのリソースを読み書きする場合、これは特に重要です。

00:08:31.000 --> 00:08:42.000
Metalは、依存関係追跡を通じて同期の問題を回避するのに最適であり、Metal 2.3以降、ヒープはリソースへのアクセスにおける危険を追跡するように構成できます。

00:08:42.000 --> 00:08:50.000
ただし、ヒープはMetalへの単一のリソースであるため、同期はサブ割り当てレベルではなくヒープレベルで処理されます。

00:08:50.000 --> 00:08:54.000
これにより、サブ割り当てされたリソースが誤った共有の問題になる可能性があります。

00:08:54.000 --> 00:08:56.000
見てみましょう。 

00:08:56.000 --> 00:09:01.000
AとBの2つのレンダリングパスが同じヒープからリソースにアクセスするとしましょう。

00:09:01.000 --> 00:09:06.000
レンダリングパスAは、追跡されたヒープから割り当てられたレンダリングテクスチャにレンダリングされます。

00:09:06.000 --> 00:09:13.000
レンダリングパスBは、同じヒープからサブ割り当てされる無関係なバッファから読み取っています。

00:09:13.000 --> 00:09:30.000
異なる条件に応じて、レンダリングパスAとBはGPUによって並行して実行される資格があります。ただし、同じリソース（ヒープ）からの書き込みと読み取りの潜在的な危険性があるため、Metalは競合条件がないことを確認するためにアクセスをシリアル化する必要があります。

00:09:30.000 --> 00:09:35.000
これにより、GPUによるワークロードの実行ウォールクロック時間が増加する可能性があります。

00:09:35.000 --> 00:09:41.000
しかし、私たちの場合、個々のリソースが独立していることがわかっていれば、このフェンスは回避できます。

00:09:41.000 --> 00:09:45.000
これを行うには2つの方法があります。

00:09:45.000 --> 00:09:53.000
1つのオプションは、静的リソースに使用されるものと別のヒープから更新可能なリソースをサブ割り当てすることです。

00:09:53.000 --> 00:10:01.000
もう1つのオプションは、すべてをバンドルしたい場合は、ヒープがサブ割り当てされたリソースを追跡しないように設定されていることを確認することです。

00:10:01.000 --> 00:10:09.000
これはMetalのデフォルトの動作であり、プログラマーとして私たち自身が危険を同期させる責任を負うことを意味します。

00:10:09.000 --> 00:10:14.000
さて、この図では、誤った共有の問題を説明するために物事を少し簡略化しました。

00:10:14.000 --> 00:10:19.000
実際には、重複はレンダリングパスレベルではなく、シェーディングステージレベルで発生します。

00:10:19.000 --> 00:10:24.000
その結果、金属はステージの粒度でフェンスを指定することができます。

00:10:24.000 --> 00:10:40.000
これは、頂点ステージやラスタライザなどのパイプラインの一部を同時に実行でき、以前のパスのフラグメントステージ出力に依存した場合は、フラグメントステージの後半でのみブロックできるため、これは素晴らしいことです。

00:10:40.000 --> 00:10:46.000
可能であれば、最大限のパフォーマンスを得るために、常にこれを行うことをお勧めします。

00:10:46.000 --> 00:10:57.000
さて、これは覚えておくべきことがたくさんあるので、このリストから1つだけ取得した場合は、これを覚えておいてください。静的テクスチャやメッシュなどの読み取り専用データは、処理するのが最も簡単です。

00:10:57.000 --> 00:11:06.000
総割り当てサイズとアライメント要件を事前に決定し、アプリの起動時またはゲームのロードセクション中にこれらのリソースをヒープに配置します。

00:11:06.000 --> 00:11:14.000
このようにして、クリティカルパスのオーバーヘッドを最小限に抑えながら、後で1回の通話に常駐させることができます。

00:11:14.000 --> 00:11:25.000
バインドレスバインディングモデルについてわかったので、リソースをエンコードして実践し、引数バッファを使用してGPUで完全なシーンを利用できるようにする方法を見てみましょう。

00:11:25.000 --> 00:11:28.000
インスタンスバッファをエンコードしたいとしましょう。

00:11:28.000 --> 00:11:31.000
このバッファはインスタンスの配列で構成されていることを覚えておいてください。

00:11:31.000 --> 00:11:41.000
見たように、インスタンスはメッシュ、マテリアルを参照し、ローカル空間から世界空間への変換を記述するインライン定数4x4行列が含まれています。

00:11:41.000 --> 00:11:48.000
エンコーディングは引数バッファエンコーダを介して実行され、Metalで1つを作成するには2つの異なる方法があります。

00:11:48.000 --> 00:11:52.000
リフレクションによるエンコーディングに精通しているかもしれません。

00:11:52.000 --> 00:12:00.000
引数バッファがシェーダー関数への直接パラメータとして渡された場合、MTLFunctionオブジェクトにエンコーダの作成を依頼できます。

00:12:00.000 --> 00:12:06.000
このメカニズムはうまく機能しますが、シーン全体を引数バッファにエンコードしているとき、すべてのエンコーダが反映されるわけではありません。

00:12:06.000 --> 00:12:13.000
特に、MTLFunctionシグネチャは、間接的に参照されるバッファについて知りません。

00:12:13.000 --> 00:12:26.000
MTLFunctionからエンコーダを作成するのが便利ではない他の状況もあります。たとえば、エンジンアーキテクチャがパイプライン状態の作成とは別に引数バッファの作成とリソースロードを処理する場合などです。

00:12:26.000 --> 00:12:31.000
さらに、関数が配列を渡されることを期待している場合、エンコーダを反映することはできません。

00:12:31.000 --> 00:12:34.000
では、このような場合、私たちは何ができますか?

00:12:34.000 --> 00:12:40.000
このような場合、MetalはMTLArgumentDescriptorを介してエンコーダを作成するための便利な2番目のメカニズムを提供します。

00:12:40.000 --> 00:12:47.000
MTLArgumentDescriptorsを使用すると、構造体メンバーをMetalに記述し、その後MTLFunctionなしでエンコーダを作成できます。

00:12:47.000 --> 00:12:54.000
まず、データ型とバインディングインデックスを指定して、各メンバーの記述子を作成する必要があります。

00:12:54.000 --> 00:13:01.000
次に、記述子を取り、それらをMTLDeviceに直接渡してエンコーダを作成します。

00:13:01.000 --> 00:13:05.000
その結果、エンコーダオブジェクトを取り戻します。

00:13:05.000 --> 00:13:09.000
それでは、これがコードでどのように見えるかを探ってみましょう。

00:13:09.000 --> 00:13:34.000
各メンバーについて、MTLArgumentDescriptorを作成する必要がありました。構造体内のメンバーのID属性に対応するバインディングインデックスを指定します。MTLDataTypeと潜在的なアクセスを指定します。最後に、すべてのメンバーを宣言した後、デバイスから直接エンコーダを作成し、すべての記述子を含む配列を渡すことができます。

00:13:34.000 --> 00:13:39.000
エンコーダができたら、データをバッファに記録するのは簡単です。

00:13:39.000 --> 00:13:43.000
エンコーダに引数バッファを設定し、バッファの先頭を指します。

00:13:43.000 --> 00:13:47.000
次に、保存するデータを設定するだけです。

00:13:47.000 --> 00:13:50.000
配列のエンコードも簡単です。

00:13:50.000 --> 00:13:58.000
私たちがしなければならないのは、エンコーダから便利に取得できるencodedLengthによってエンコーダの引数バッファ記録ポイントをオフセットすることだけです。

00:13:58.000 --> 00:14:04.000
次の例では、encodedLengthをオフセットに2回目に追加します。

00:14:04.000 --> 00:14:10.000
実際、記録する必要がある各位置のオフセットは、index×encodedLengthになります。

00:14:10.000 --> 00:14:14.000
このメカニズムにより、構造体の配列を非常に簡単にエンコードできます。

00:14:14.000 --> 00:14:22.000
さて、言及する価値のある重要な点の1つは、シェーダー側からこれらの配列へのインデックスに特別な処理は必要ないということです。

00:14:22.000 --> 00:14:27.000
シェーダーはバッファの長さを知る必要がなく、配列内の任意の場所に自由にインデックスできます。

00:14:27.000 --> 00:14:29.000
それはちょうど動作します!

00:14:29.000 --> 00:14:35.000
さて、バインドレスシーンをエンコードしたので、ナビゲーションを見てみましょう。

00:14:35.000 --> 00:14:38.000
レイトレーシングの場合、ナビゲーションは非常に自然です。

00:14:38.000 --> 00:14:43.000
まず、バインドレスシーンのルートを含むバッファをレイトレーシングパイプラインにバインドします。

00:14:43.000 --> 00:14:47.000
これは、他のすべてにアクセスできる引数バッファです。

00:14:47.000 --> 00:14:52.000
次に、カーネルから、いつものようにレイトレースされた交差点に進みます。

00:14:52.000 --> 00:14:58.000
交差点を発見した後、交差点の結果オブジェクトはナビゲーションを記述します。

00:14:58.000 --> 00:15:03.000
このオブジェクトは、instance_id、geometry_id、およびprimitive_idを照会できます。

00:15:03.000 --> 00:15:07.000
これらのメンバーは、加速構造をナビゲートするために特別に設計されています。

00:15:07.000 --> 00:15:14.000
したがって、先に示したように、加速構造を反映した構造でバインドレスシーンを構築することが重要です。

00:15:14.000 --> 00:15:16.000
もう一度見てみましょう。 もう一度見てみましょう。

00:15:16.000 --> 00:15:23.000
覚えておいてください、これはシーンを整理する方法のほんの一例なので、私はそれをどのように整理したかに応じてそれをナビゲートするつもりです。

00:15:23.000 --> 00:15:30.000
シーンの特定の詳細は、独自の引数バッファを整理する方法によって異なる場合があります。

00:15:30.000 --> 00:15:33.000
まず、交差点を見つける必要があります。

00:15:33.000 --> 00:15:45.000
それを手に入れたら、バインドレスシーンを戦略的に整理したため、instance_idが与えられた場合、インスタンスバッファへのポインタをたどり、どちらにヒットしたかを決定できます。

00:15:45.000 --> 00:15:49.000
次に、私たちが見たように、インスタンスはそのメッシュと素材を知っています。

00:15:49.000 --> 00:15:56.000
そのため、geometry_idを使用して、参照バッファ内でヒットしたジオメトリを決定できます。

00:15:56.000 --> 00:16:03.000
最後に、各メッシュがインデックスバッファを知るように準備した場合、primitive_idを使用して、ヒットした正確なプリミティブを決定できます。

00:16:03.000 --> 00:16:10.000
たとえば、三角形の場合、この配列から3つのインデックスを引き出し、それらを使用して頂点データを取得できます。

00:16:10.000 --> 00:16:14.000
このナビゲーションは、Metal Shading Languageでどのように見えるかです。

00:16:14.000 --> 00:16:24.000
交差オブジェクトから、instance_idを取得し、それを使用してインスタンス配列に動的にインデックスを作成し、ヒットしたインスタンスを取得します。

00:16:24.000 --> 00:16:32.000
次に、インスタンスを使用して、geometry_idを使用して、どのジオメトリまたはサブメッシュがヒットしたかを判断します。

00:16:32.000 --> 00:16:38.000
ジオメトリを決定したら、インデックスバッファから直接インデックスを引き出すことができます。

00:16:38.000 --> 00:16:43.000
三角形の場合、次々に3つのインデックスを引きます。

00:16:43.000 --> 00:16:49.000
これらのインデックスを使用して、頂点データ配列にアクセスし、テクニックに必要な属性を取得します。

00:16:49.000 --> 00:16:54.000
たとえば、各頂点に対応する法線を取得できます。

00:16:54.000 --> 00:17:04.000
そして最後に、点の重心座標を使用して、頂点法線を手動で補間して、交点の正しい法線に到達します。

00:17:04.000 --> 00:17:15.000
これらの変更により、ティーポットの例に戻すと、交差点で法線を計算する方法が整ったので、反射を正しくシェーディングすることができます。

00:17:15.000 --> 00:17:23.000
交差点で正しい属性を見つけるためにコードを更新しましたが、結果が視覚的に正しいようになりました。

00:17:23.000 --> 00:17:35.000
これで、このフレームワークに基づいて構築し、テクスチャ座標や接線ベクトルを適用して通常のマッピングを実装するなど、必要な他の属性を計算することができます。

00:17:35.000 --> 00:17:44.000
そこで、ここでは、バインドレスシーンをナビゲートして頂点データを取得し、手動で補間し、最後に、発見されたすべての交点を正しくシェーディングするために適用する方法を見ました。

00:17:44.000 --> 00:17:52.000
これらの概念を独自のエンジンに持ち込むために、これらすべての具体的な実装を示すコンパニオンコードサンプルをリリースします。

00:17:52.000 --> 00:17:58.000
これは、モデルI/Oフレームワークを使用してロードされたシーンのレイトレース反射を計算するハイブリッドレンダリングサンプルです。

00:17:58.000 --> 00:18:13.000
このサンプルは、レイトレーシング加速構造に一致するバインドレスシーンをエンコードする方法を示し、交差を見つけて、レイトレーシングシェーダーから直接関連するピクセルを正しくシェーディングする方法も示しています。

00:18:13.000 --> 00:18:21.000
ここで見ることができるように、サンプルはまた、光線がトラックと交差するポイントで反射レイトレーシングシェーダーの出力を直接視覚化することができます。

00:18:21.000 --> 00:18:28.000
これは、反射アルゴリズムを反復的に実験するのに最適です。

00:18:28.000 --> 00:18:34.000
さて、私たちはここで多くの分野をカバーし、これまでのところ、レイトレーシングの文脈で議論のほとんどを集中させてきました。

00:18:34.000 --> 00:18:40.000
しかし、先に述べたように、ラスタライズの文脈でピクセルを適切にシェーディングするために同じ原則を適用することができます。

00:18:40.000 --> 00:18:44.000
物理ベースのレンダリングは、これのための素晴らしい候補です。

00:18:44.000 --> 00:18:54.000
PBRでは、フラグメントシェーダーには、アルベド、粗さ、メタリック、アンビエントオクルージョンなど、いくつかのテクスチャからの情報が必要です。

00:18:54.000 --> 00:19:01.000
ダイレクトバインディングモデルでは、各ドローコールを発行する前に、各スロットを個別にバインドする必要があります。

00:19:01.000 --> 00:19:05.000
バインドレスモデルは、これを大幅に簡素化します。

00:19:05.000 --> 00:19:13.000
引数バッファをエンコードしたら、シーンを直接バインドし、ドローコールに対応するマテリアルに移動し、すべてのテクスチャに間接的にアクセスできます。

00:19:13.000 --> 00:19:26.000
実際、単一のバッファを一度バインドする必要があるため、このアーキテクチャは、ドロー呼び出しの数を減らし、代わりにインスタンスレンダリングを使用することで、エンジンをさらに最適化する絶好の機会を提供します。

00:19:26.000 --> 00:19:31.000
私たちがアクセスする予定のすべてのテクスチャを居住者にすることを忘れないでください。

00:19:31.000 --> 00:19:34.000
典型的なPBRシェーダーの例を次に示します。

00:19:34.000 --> 00:19:40.000
従来のモデルでは、参照される各テクスチャは、この描画呼び出しの前に個別にバインドする必要があります。

00:19:40.000 --> 00:19:48.000
次のドロー呼び出しで異なるテクスチャセットが必要な場合は、これらのリソースもすべて1つずつバインドする必要があります。

00:19:48.000 --> 00:19:57.000
バインドレスモデルを使用する場合、ルート引数バッファを渡して、以前と同じように参照構造から直接マテリアルを取得できるようになりました。

00:19:57.000 --> 00:20:12.000
まず、インスタンスを取得します。これは頂点シェーディング段階で決定される場合があります。次に、そのマテリアルを取得し、参照されたテクスチャと一定データを使用して適切なシェーディングを計算します。

00:20:12.000 --> 00:20:15.000
最後に、色を返すだけです。

00:20:15.000 --> 00:20:16.000
わかった！

00:20:16.000 --> 00:20:20.000
そして、それはメタルでバインドレスレンダリングを効果的に実装する方法についてのツアーでした!

00:20:20.000 --> 00:20:29.000
要約すると、私たちはメタルバインドレスモデルを調査し、それがどれほど非常に柔軟であるかを見て、あなたが望むようにあなたのシーンを表現することができます。

00:20:29.000 --> 00:20:34.000
私のお勧めは、与えられたレンダラーのナビゲーションを容易にする構造を設計し、構築することです。

00:20:34.000 --> 00:20:42.000
このようにして、ナビゲーションは非常に自然になり、レイトレーシングとラスタライズの両方に同じバッファーを使用することもできます。

00:20:42.000 --> 00:20:48.000
Bindlessはゲームを完全に変え、最新のレンダリング技術を実装するために必要なすべてのデータをGPUに与えます。

00:20:48.000 --> 00:20:57.000
さらに進んで、このアーキテクチャを使用してGPUを運転席に置き、間接的なコマンドバッファとGPUカリングを通じて間接的なパイプラインを採用することもできます。

00:20:57.000 --> 00:21:03.000
次世代のグラフィカルアプリケーションやゲームを提供するために、これをどのように実践するかを見るのが待ちきれません。

00:21:03.000 --> 00:21:06.000
ありがとう、WWDC 2021の残りを楽しんでください!

00:21:06.000 --> 23:59:59.000
♪

