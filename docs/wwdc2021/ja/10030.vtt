WEBVTT

00:00:00.000 --> 00:00:05.000
♪ベース音楽の演奏♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:17.000
Sihui Liu:こんにちは。「高度なウェブコンテンツの開発」へようこそ。私はSihuiで、SafariとWebKitチームのエンジニアです。

00:00:17.000 --> 00:00:23.000
過去1年間にウェブ開発者のためにWebKitとSafariで行った重要なアップデートを皆さんと共有できることを嬉しく思います。

00:00:23.000 --> 00:00:28.000
私が共有しようとしているものは、一般的に3つのカテゴリーに分類されます。

00:00:28.000 --> 00:00:33.000
まず、JavaScriptの新機能と機能強化について説明します。

00:00:33.000 --> 00:00:39.000
次に、WebAssemblyの更新の概要を説明します。

00:00:39.000 --> 00:00:47.000
そして最後に、ウェブコンテンツに機能を追加できる新しいウェブAPIを紹介します。

00:00:47.000 --> 00:00:51.000
取り上げることがたくさんあるので、JavaScriptでのニュースから始めましょう。

00:00:51.000 --> 00:00:56.000
毎年、私たちのJavaScriptエンジンには何百もの変更が加えられています。

00:00:56.000 --> 00:01:02.000
JavaScriptで作業する場合、あなたが知る必要がある最も重要なもののいくつかをカバーします。

00:01:02.000 --> 00:01:25.000
それらは、新しいクラスフィールド構文、よりスマートなメモリ管理を可能にする弱い参照、awaitキーワードの新しい使用法、ワーカーのモジュールのサポート、および国際化APIファミリに追加されたインターフェイスです。

00:01:25.000 --> 00:01:31.000
これらの新機能の絵にあなたを入れるために、私は例として簡単なストップウォッチを使うつもりです。

00:01:31.000 --> 00:01:34.000
ストップウォッチにはボタンが1つしかありません。

00:01:34.000 --> 00:01:36.000
一度クリックすると、カウントが開始されます。

00:01:36.000 --> 00:01:40.000
もう一度クリックすると、停止し、経過した期間が表示されます。

00:01:40.000 --> 00:01:46.000
これを念頭に置いて、後でJavaScriptで実装します。

00:01:46.000 --> 00:01:49.000
では、新しいクラスフィールド構文を見てみましょう。

00:01:49.000 --> 00:01:59.000
アクセスが言語によって保護されている実際のプライベートメンバーを定義できる新しいプライベートクラスフィールドとメソッドがあります。

00:01:59.000 --> 00:02:02.000
アクセスルールを破るとエラーが表示されます。

00:02:02.000 --> 00:02:12.000
また、静的フィールドのサポートを追加します。これにより、クラスのインスタンスを作成せずにアクセスできるクラスメンバーを宣言できます。

00:02:12.000 --> 00:02:15.000
今、あなたは基本的な考えを持っています。

00:02:15.000 --> 00:02:19.000
ストップウォッチの例でどのように使用できるかを確認しましょう。

00:02:19.000 --> 00:02:26.000
ストップウォッチクラスを実装するように求められた場合、実装は次のようになります。

00:02:26.000 --> 00:02:30.000
StopwatchWithOneButtonには、click()という名前のメソッドが1つしかありません。

00:02:30.000 --> 00:02:33.000
startTime変数をチェックします。

00:02:33.000 --> 00:02:39.000
開始時間が設定されていない場合、クリックは開始を意味するので、開始時間が設定されます。

00:02:39.000 --> 00:02:47.000
開始時間がすでに設定されている場合、クリックは停止することを意味するので、期間を計算し、開始時間をリセットします。

00:02:47.000 --> 00:02:51.000
startTimeにはアンダースコアプレフィックスが付属していることがわかります。

00:02:51.000 --> 00:02:58.000
これは、変数がクラス内でのみ使用されるべきであることを示すために一般的に使用される命名規則です。

00:02:58.000 --> 00:03:03.000
しかし、それは実際には開始時間が公にアクセスされるのを妨げるものではありません。

00:03:03.000 --> 00:03:06.000
新しいプライベート構文は、これを修正するのに役立ちます。

00:03:06.000 --> 00:03:11.000
アンダースコアをハッシュに置き換えるだけで、実際のプライベートインスタンスフィールドを宣言できます。

00:03:11.000 --> 00:03:15.000
カプセル化は言語によって強制されます。

00:03:15.000 --> 00:03:18.000
プライベートメソッドのサポートもあります。

00:03:18.000 --> 00:03:30.000
たとえば、click() メソッドをより構造化するには、次のように強調表示されたコンテンツを置き換えるために、2 つのプライベート メソッド start() と stop() を作成できます。

00:03:30.000 --> 00:03:39.000
メソッドにハッシュプレフィックスを追加することで、メンバー関数がクラス内からのみアクセスできるようにします。

00:03:39.000 --> 00:03:45.000
新しいプライベート構文は、startedStopwatchCountのような静的フィールドにも適用されます。

00:03:45.000 --> 00:03:52.000
ここでは、startedStopwatchCountは、開始時刻または停止時刻にストップウォッチオブジェクトによってのみ変更できます。

00:03:52.000 --> 00:04:02.000
もちろん、startedStopwatchCountをどこでもアクセスしたい場合は、ハッシュプレフィックスなしでパブリック静的フィールドとして宣言できます。

00:04:02.000 --> 00:04:06.000
パブリックスタティックフィールドは現在、WebKitでも利用可能です。

00:04:06.000 --> 00:04:14.000
プライベートインスタンスフィールド、メソッド、プライベート静的フィールド、パブリック静的フィールド。それが私たちの新しいクラスフィールドサポートです。

00:04:14.000 --> 00:04:19.000
そして、別の機能、弱い参照を続けましょう。

00:04:19.000 --> 00:04:27.000
弱い参照を使用すると、ガベージコレクションを妨げない方法でJavaScriptオブジェクトへの参照を保持することができます。

00:04:27.000 --> 00:04:35.000
WeakMapやWeakSetとは異なり、すでに参照しなくても、基礎となるオブジェクトを取得できます。

00:04:35.000 --> 00:04:43.000
サポートにはガベージコレクションの通知も含まれているので、必要に応じてクリーンアップタスクを実行できます。

00:04:43.000 --> 00:04:45.000
そして、それがどのように使用できるか見てみましょう。

00:04:45.000 --> 00:04:48.000
ストップウォッチクラスを実装したばかりです。

00:04:48.000 --> 00:04:54.000
さまざまなタスク用に複数のストップウォッチオブジェクトを作成したと想像してみてください。

00:04:54.000 --> 00:04:57.000
テストを行うには、一度にすべてをクリックする必要があります。

00:04:57.000 --> 00:04:59.000
どうやってそれをするの？

00:04:59.000 --> 00:05:04.000
直感的な方法は、すべてのストップウォッチインスタンスのセットを維持することです。

00:05:04.000 --> 00:05:07.000
ストップウォッチが作成されたら、セットに追加します。

00:05:07.000 --> 00:05:14.000
次に、clickAllStopwatches機能で、セットを反復して各ストップウォッチをクリックします。

00:05:14.000 --> 00:05:17.000
しかし、このアプローチには問題があります。

00:05:17.000 --> 00:05:28.000
JavaScriptオブジェクトはデフォルトで強力な参照を保持していることを知っているので、この場合、セットにはまだ参照があるため、すべてのストップウォッチオブジェクトをガベージコレクションすることはできません。

00:05:28.000 --> 00:05:32.000
もちろん、テストのためだけにすべてのストップウォッチオブジェクトを周りに置いておきたくありません。

00:05:32.000 --> 00:05:36.000
これはメモリの使用には最適ではありません。

00:05:36.000 --> 00:05:42.000
さて、SetをWeakSetに置き換えることを提案するかもしれませんが、WeakSetは反復可能ではありません。

00:05:42.000 --> 00:05:44.000
それで、あなたはどうしますか?

00:05:44.000 --> 00:05:50.000
オブジェクトへの弱い参照を保持する新しいインターフェイスWeakRefで解決できます。

00:05:50.000 --> 00:05:56.000
私たちはまだセットを持っていますが、今回はストップウォッチオブジェクトのWeakRefをセットに追加します。

00:05:56.000 --> 00:06:04.000
clickAllStopwatches関数では、クリックする前にオブジェクトを逆参照して、オブジェクトがまだ存在するかどうかを確認します。

00:06:04.000 --> 00:06:17.000
これは私たちの問題を解決しているようですが、別の問題があります。ガベージコレクションのストップウォッチをタイムリーにセットから削除せず、次のクリックテストの前にセットがかなり大きくなる可能性があります。

00:06:17.000 --> 00:06:21.000
さて、私たちは何をすべきですか?

00:06:21.000 --> 00:06:25.000
この場合、別の新しいインターフェイスであるFinalizationRegistryが役立つかもしれません。

00:06:25.000 --> 00:06:32.000
それを使用すると、あるオブジェクトがガベージコレクションされたときに呼び出されるコールバックを指定できます。

00:06:32.000 --> 00:06:43.000
ここでは、removeStopwatch関数を使用してfinalizationRegistryオブジェクトを作成するため、オブジェクトが収集されるたびにこの関数が呼び出されます。

00:06:43.000 --> 00:06:47.000
次に、ストップウォッチオブジェクトをレジストリに登録します。

00:06:47.000 --> 00:06:54.000
各ストップウォッチは識別子でバインドされているので、removeStopwatchはどのストップウォッチを削除するかを知っています。

00:06:54.000 --> 00:07:00.000
よし、ゴミ収集ストップウォッチはすべてのストップウォッチから削除されます。

00:07:00.000 --> 00:07:05.000
弱い参照の使用はそれほど難しく聞こえませんよね?

00:07:05.000 --> 00:07:12.000
しかし、JavaScriptのガベージコレクションは非常に複雑であり、多くの不確実性があることに注意してください。

00:07:12.000 --> 00:07:26.000
たとえば、収集する必要があると思われるオブジェクトは、実際には長い時間後まで収集されない可能性があり、イベントループで実行されるため、FinalizationRegistryから正しい方法でコールバックを取得できない場合があります。

00:07:26.000 --> 00:07:33.000
したがって、使用前に構文とその予想される動作を完全に理解していることを確認してください。

00:07:33.000 --> 00:07:37.000
弱い参照から次の機能、トップレベルの待機に移りましょう。

00:07:37.000 --> 00:07:40.000
これはモジュールの新機能です。

00:07:40.000 --> 00:07:46.000
これにより、非同期関数の外でawaitキーワードを使用できます。

00:07:46.000 --> 00:07:55.000
この場合、モジュール自体は大きな非同期関数のようなものなので、非同期モジュールはそれらをインポートするモジュールの実行をブロックすることができます。

00:07:55.000 --> 00:08:00.000
ストップウォッチクラスの例をお見せしましょう。

00:08:00.000 --> 00:08:03.000
これは私たちが作成したばかりのクラスです。

00:08:03.000 --> 00:08:09.000
トップレベルの待機の使用を説明するために、それをモジュールにしてクラスをエクスポートしましょう。

00:08:09.000 --> 00:08:13.000
これは、インラインモジュールを含むHTMLファイルです。

00:08:13.000 --> 00:08:18.000
動的インポートを使用してストップウォッチモジュールをインポートします。

00:08:18.000 --> 00:08:27.000
インポート関数は約束を返すので、インポートが完了した後、thenまたはcatchメソッドを使用してアクションを実行できます。

00:08:27.000 --> 00:08:34.000
トップレベルの待機では、チェーンメソッドを削除し、同期的な方法でコードを書くことができます。

00:08:34.000 --> 00:08:38.000
これにより、コードがわかりやすくなります。

00:08:38.000 --> 00:08:48.000
また、インポートされたモジュールはロード時に評価されるため、非同期モジュールはそれに応じてモジュールの実行をブロックすることができます。

00:08:48.000 --> 00:08:59.000
つまり、ストップウォッチモジュールが非同期操作を実行して結果を待つ場合、ストップウォッチモジュールの実行が完了した後、ここでのストップウォッチ変数が初期化されます。

00:08:59.000 --> 00:09:03.000
トップレベルの待機により、依存関係管理が容易になりました。

00:09:03.000 --> 00:09:14.000
しかし、繰り返しますが、この機能はモジュールでのみ利用できるので、スクリプトがモジュールでない場合、このように...

00:09:14.000 --> 00:09:17.000
...Webインスペクタに構文エラーが表示されます。

00:09:17.000 --> 00:09:22.000
モジュールといえば、別の関連機能があります。モジュールワーカーです。

00:09:22.000 --> 00:09:25.000
労働者にはいくつかのよく知られた利点があります。

00:09:25.000 --> 00:09:31.000
バックグラウンドスレッドでスクリプトを実行できるため、リソースをより効率的に活用できます。

00:09:31.000 --> 00:09:44.000
この新しいサポートにより、ワーカーは動的インポート、最適化されたロードと実行、依存関係管理など、モジュールの利点を共有します。

00:09:44.000 --> 00:09:51.000
重い作業をメインスレッドからバックグラウンドスレッドに移動することは、より有益で簡単です。

00:09:51.000 --> 00:09:58.000
モジュールは、ウェブワーカー、サービスワーカー、ワークレットなど、さまざまなタイプのワーカーで利用可能になりました。

00:09:58.000 --> 00:10:07.000
ウェブワーカーとサービスワーカーのモジュールワーカーを作成するには、オプションでモジュールの型を指定する必要があります。

00:10:07.000 --> 00:10:12.000
オーディオワークレットのようなワークレットには、addModule関数を使用できます。

00:10:12.000 --> 00:10:18.000
アプリケーションを高速化するのに役立つモジュールワーカーを作成するのはとても簡単です。

00:10:18.000 --> 00:10:23.000
JavaScriptの最後のセクションは、国際化APIの更新です。

00:10:23.000 --> 00:10:26.000
このAPIは、言語ベースの書式設定を提供します。

00:10:26.000 --> 00:10:31.000
ウェブコンテンツが異なるロケールのユーザー向けに構築されている場合に便利です。

00:10:31.000 --> 00:10:41.000
使用方法を示すために、このストップウォッチレコードページを作成しました。なぜなら、ストップウォッチは時間と機能のリリースに追いつく必要があるからです。

00:10:41.000 --> 00:10:53.000
このページでは、期間、開始時間、イベント、参加者、ページの利用可能な言語など、ストップウォッチの1回の使用に関する詳細を示しています。

00:10:53.000 --> 00:10:58.000
では、各セクションに飛び込んで、各インターフェイスを詳しく見てみましょう。

00:10:58.000 --> 00:11:00.000
最初はNumberFormatです。

00:11:00.000 --> 00:11:06.000
NumberFormatは、言語に敏感な数値の書式設定を提供し、期間を書式設定するために使用されます。

00:11:06.000 --> 00:11:13.000
NumberFormatのコンストラクタは、言語とオプションの2つのオプションパラメータを取ります。

00:11:13.000 --> 00:11:22.000
ここでは、言語を英語に設定し、異なる最小桁数を指定する2つのオプションオブジェクトを作ります。

00:11:22.000 --> 00:11:29.000
言語とオプションで2つのNumberFormatオブジェクトを作成した後、それらを使用して期間番号をフォーマットできます。

00:11:29.000 --> 00:11:39.000
ここでは、数値がミリ秒でない場合は、Format1を使用して2桁を保持します。それ以外の場合は、Format2を使用して3桁を保持します。

00:11:39.000 --> 00:11:44.000
ご覧のとおり、フォーマットメソッドは自動的に私たちのためにパディングゼロを追加します。

00:11:44.000 --> 00:11:54.000
スタイルなど、必要なフォーマットを作成するために利用できるさまざまなオプションがあり、値を通貨または単位として指定できます。

00:11:54.000 --> 00:12:01.000
次は、言語に敏感な日付と時刻の書式設定を可能にするDateTimeFormatです。

00:12:01.000 --> 00:12:03.000
使い方はNumberFormatに似ています。

00:12:03.000 --> 00:12:05.000
まず、言語を設定します。

00:12:05.000 --> 00:12:07.000
次に、オプションを設定します。

00:12:07.000 --> 00:12:11.000
オプションでは、日付と時刻に異なるスタイルを設定します。

00:12:11.000 --> 00:12:20.000
DateTimeFormatオブジェクトは、2秒またはミリ秒のスタイルを指定できるきめ細かな構成を提供します。

00:12:20.000 --> 00:12:28.000
その後、パラメータを持つDateTimeFormatオブジェクトを作成し、それを使用して開始時間をフォーマットすることができます。

00:12:28.000 --> 00:12:31.000
結果は英語で表されます。

00:12:31.000 --> 00:12:37.000
スタイルが長いので、日付がより詳細であることがわかります。

00:12:37.000 --> 00:12:39.000
次はセグメンタです。

00:12:39.000 --> 00:12:43.000
これにより、言語に敏感な文字列分割を行うことができます。

00:12:43.000 --> 00:12:48.000
イベント文のキーワードを見つけるために使用しました。

00:12:48.000 --> 00:12:52.000
これはストップウォッチレコードページの中国語版です。

00:12:52.000 --> 00:12:56.000
まず、強調したいキーワードの短いリストを宣言します。

00:12:56.000 --> 00:13:01.000
イベント文字列には、摂氏度記号のUnicodeも含まれています。

00:13:01.000 --> 00:13:04.000
ここでは、中国語を言語として指定します。

00:13:04.000 --> 00:13:08.000
オプションでは、粒度は単語に設定されています。

00:13:08.000 --> 00:13:12.000
他の可能な値は、書記素と文です。

00:13:12.000 --> 00:13:18.000
次に、セグメンタを作成し、それを使用してセグメントメソッドで文字列を分割します。

00:13:18.000 --> 00:13:22.000
結果オブジェクトを反復して、すべてのセグメントを取得できます。

00:13:22.000 --> 00:13:28.000
各セグメントがキーワードリストに含まれているかどうかを確認してマークします。

00:13:28.000 --> 00:13:38.000
セグメンタは、単語の境界がそれほど明白ではない中国語のような言語を解釈するのに非常に便利です。

00:13:38.000 --> 00:13:43.000
次は、言語に敏感なリストの書式設定を可能にするListFormatです。

00:13:43.000 --> 00:13:47.000
以前と同じように、言語とオプションを指定できます。

00:13:47.000 --> 00:13:52.000
ListFormatには、他のインターフェイスほど多くのオプションはありません。

00:13:52.000 --> 00:13:56.000
私が見つけた最も有用なものは、タイプとスタイルです。

00:13:56.000 --> 00:14:03.000
言語とオプションを使用すると、ListFormatを作成し、参加者リストをフォーマットできます。

00:14:03.000 --> 00:14:13.000
ご覧のとおり、タイプは接続詞でスタイルが長いため、フォーマットメソッドは結果にカンマと単語「and」を追加します。

00:14:13.000 --> 00:14:16.000
最後はDisplayNamesです。

00:14:16.000 --> 00:14:21.000
言語、地域、スクリプトの表示名の一貫した翻訳を提供します。

00:14:21.000 --> 00:14:24.000
ここでは、日本語の言語を指定します。

00:14:24.000 --> 00:14:27.000
DisplayNamesは、言語コードを入力として取ることができます。

00:14:27.000 --> 00:14:31.000
オプションでは、タイプを言語として設定します。

00:14:31.000 --> 00:14:34.000
次に、DisplayNamesオブジェクトを作成できます。

00:14:34.000 --> 00:14:39.000
そしてここで、メソッドを使用して、翻訳された結果を得ることができます。

00:14:39.000 --> 00:14:45.000
このページは英語で構築されていますが、日本のユーザーはどの言語がサポートされているかを知ることができます。

00:14:45.000 --> 00:14:52.000
そして、これが私が新しい国際化インターフェースでストップウォッチレコードページを構築した方法です。

00:14:52.000 --> 00:14:58.000
記憶をリフレッシュするために、JavaScriptセクションで見たもののリストを次に示します。

00:14:58.000 --> 00:15:04.000
その後、次の目的地はWebAssemblyの更新です。

00:15:04.000 --> 00:15:13.000
私たちはしばらくの間、WebAssemblyエンジンを出荷してきましたが、それに慣れていない場合は、WebAssemblyの背景を記入することから始めましょう。

00:15:13.000 --> 00:15:20.000
WebAssemblyは、スタックベースの仮想マシンのバイナリ命令形式です。

00:15:20.000 --> 00:15:26.000
これは、ネイティブコードに近いパフォーマンスを持つ最新のWebブラウザで実行できるコードの一種です。

00:15:26.000 --> 00:15:42.000
WebAssemblyは、C、C ++、Rustなどのプログラミング言語のポータブルコンパイルターゲットとして設計されているため、WebAssemblyは、これらの言語で書かれたアプリケーションをWeb上に展開するのに役立ちます。

00:15:42.000 --> 00:15:47.000
WebAssemblyのほとんどのユースケースでは、JavaScriptと一緒に実行されます。

00:15:47.000 --> 00:15:52.000
彼らはWebAssembly APIを通じて互いに通信することができます。

00:15:52.000 --> 00:15:59.000
WebAssemblyは、ほぼネイティブなパフォーマンスを提供し、強力なフレームワークをウェブ上で利用できるようにします。

00:15:59.000 --> 00:16:04.000
JavaScriptはDOMを操作でき、強力なウェブAPIを提供します。

00:16:04.000 --> 00:16:09.000
彼らはお互いに良い追加になることができます。

00:16:09.000 --> 00:16:12.000
WebAssemblyの使用の良い例は、ファンキーカートです。

00:16:12.000 --> 00:16:17.000
これは、EmscriptenでC++からWebAssemblyに変換されたゲームです。

00:16:17.000 --> 00:16:22.000
ご覧のとおり、Safariでは非常にスムーズに実行できます。

00:16:22.000 --> 00:17:24.000
今年は、次の機能を備えたWebAssemblyエンジンをアップグレードしました。メモリブロックのコピーや初期化など、バルクメモリ操作でより良いパフォーマンスを提供する新しいメモリ命令。floatとintの間で変換するときの正のオーバーフローなど、例外をトラップしないようにユーザープロセスに指示する新しい命令。符号付き整数を拡張できる新しい符号拡張演算子。以前のソリューションよりも簡単で、コードをオブジェクト、それらを引数として渡し、それらを保存します。そして最後に、全体的な実行時間を短縮するWebAssemblyのダウンロードとコンパイルをストリーミングします。

00:17:24.000 --> 00:17:28.000
これらは、新しいWebAssembly機能のハイライトです。

00:17:28.000 --> 00:17:31.000
彼らがあなたの開発に役立つことを願っています。

00:17:31.000 --> 00:17:37.000
では、強力な低レベルコードからいくつかの高レベルAPIに移行しましょう。

00:17:37.000 --> 00:17:42.000
このセクションでは、新しいWeb APIについて説明します。

00:17:42.000 --> 00:17:52.000
私の目標は、新機能についてあなたに知らせるだけでなく、あなたがそれらを使用する準備ができていると感じさせることですので、あなたはいくつかの良い例を見るでしょう。

00:17:52.000 --> 00:17:59.000
しかし、これは完全なチュートリアルではないので、使用前に公式のドキュメントを確認することを忘れないでください。

00:17:59.000 --> 00:18:02.000
これは私が話す機能のプレビューです。

00:18:02.000 --> 00:18:12.000
それらのいくつかは音声認識のように完全に新しく、それらのいくつかはすでにそこにありますが、ストレージアクセスのように共有したいいくつかのアップデートがあります。

00:18:12.000 --> 00:18:17.000
では、それぞれを掘り下げてみましょう。

00:18:17.000 --> 00:18:24.000
私たちはウェブコンテンツを魅力的にすることを知っています、素晴らしい視覚体験を提供することは非常に重要です。

00:18:24.000 --> 00:18:33.000
WebGL2がWebKitとSafariで利用可能であるため、美しくインタラクティブなWebコンテンツを簡単に作成できます。

00:18:33.000 --> 00:18:37.000
これは、WebGL2で何ができるかの良い例です。

00:18:37.000 --> 00:18:42.000
After the Floodは、PlayCanvasが開発したインタラクティブなデモです。

00:18:42.000 --> 00:18:45.000
穏やかな風が木を揺らしているのが見えます。

00:18:45.000 --> 00:18:48.000
サファリでは鮮やかに見えます。

00:18:48.000 --> 00:18:50.000
では、WebGL2とは何ですか?

00:18:50.000 --> 00:18:56.000
WebGLは、2Dおよび3Dグラフィックスをレンダリングするために非常に広く使用されている低レベルAPIです。

00:18:56.000 --> 00:19:03.000
WebGL2は、フォールバックを排除し、いくつかのクールな新機能を導入するWebGLのアップグレードです。

00:19:03.000 --> 00:19:09.000
雲のような体積効果をレンダリングできるように、3Dテクスチャを追加します。

00:19:09.000 --> 00:19:16.000
シェーダーでテクスチャを使用する方法について、より柔軟性を与えるサンプラーオブジェクトがあります。

00:19:16.000 --> 00:19:23.000
GPUにパフォーマンスパーティクルシステムを実装するのに役立つ変換フィードバックを提供します。

00:19:23.000 --> 00:19:27.000
WebGL2には非常に多くの素晴らしい新機能があります。

00:19:27.000 --> 00:19:34.000
さらに重要なことに、WebGL2はすべてのAppleデバイスのSafariで利用可能になりました。

00:19:34.000 --> 00:19:39.000
つまり、どこでも見栄えのいい美しいサイトを構築できるということです。

00:19:39.000 --> 00:19:46.000
そして、オレンジ色の四角を作成するという例で、WebGL2に慣れましょう。

00:19:46.000 --> 00:19:50.000
そして、これはあなたがそれのために書く必要があるJavaScriptコードです。

00:19:50.000 --> 00:19:57.000
以前にWebGLを使用したことがないなら、これはあなたが想像していたほど簡単ではないかもしれません。

00:19:57.000 --> 00:20:03.000
前述したように、WebGLは低レベルのAPIであるため、非常に冗長になる可能性があります。

00:20:03.000 --> 00:20:10.000
しかし、心配しないでください。開発を簡素化するのに役立つ素晴らしいライブラリやフレームワークがたくさんあります。

00:20:10.000 --> 00:20:17.000
彼らと一緒に、素敵な正方形やそれよりも複雑なものを作るのはそれほど難しくありません。

00:20:17.000 --> 00:20:23.000
さて、すでにウェブコンテンツでWebGLを使用している場合は、良いニュースもあります。

00:20:23.000 --> 00:20:29.000
バックエンドをOpenGLからMetalに移行することで、サポートを改善しました。

00:20:29.000 --> 00:20:40.000
つまり、iOS SimulatorはWebコンテンツにGPUを使用でき、ユーザーが見るものをはるかに正確に表現できるようになったということです。

00:20:40.000 --> 00:20:47.000
また、Xcodeフレームデバッガなどの金属ツールを使用して、WebGLコードを分析することもできます。

00:20:47.000 --> 00:20:54.000
WebGLでコンテンツを作成するだけでなく、優れたビジュアル体験を提供するもう1つの一般的な方法は、ビデオです。

00:20:54.000 --> 00:21:06.000
すべてのブラウザが同じ種類のメディアフォーマットをサポートしているわけではないので、使用するフォーマットを決めるのが難しい場合があります。

00:21:06.000 --> 00:21:15.000
物事をより簡単にするために、今年は、ウェブ上の一般的なメディアフォーマットであるWebMのサポートを強化しました。

00:21:15.000 --> 00:21:19.000
まず、サポートはストリーミング再生のみです。

00:21:19.000 --> 00:21:28.000
macOS 11.3では、VP8またはVP9ビデオとVorbisオーディオを含むWebMファイルを再生するためのサポートを追加しました。

00:21:28.000 --> 00:21:34.000
また、macOS 12では、Opusオーディオを含むファイルのサポートが追加されています。

00:21:34.000 --> 00:21:40.000
昨年、macOSのMedia Source Extensionsで再生されるWebMのサポートを開始しました。

00:21:40.000 --> 00:21:44.000
今、私たちはそのサポートをiPadOS 15にもたらしています。

00:21:44.000 --> 00:21:55.000
WebMがコードでサポートされているかどうかを確認するには、MediaCapabilities APIを使用して、使用する正確なメディア構成を検出できます。

00:21:55.000 --> 00:22:03.000
画面上の設定は最新のSafariでサポートされています。つまり、VP9もサポートされています。

00:22:03.000 --> 00:22:12.000
このビデオコーディングフォーマットのサポートにより、SafariやWebKitアプリでより多くのウェブコンテンツが利用可能になることを期待しています。

00:22:12.000 --> 00:22:16.000
VP9はストリーミングとWebRTCの両方で使用できます。

00:22:16.000 --> 00:22:19.000
macOSとiPadOSで動作します。

00:22:19.000 --> 00:22:26.000
さまざまなデバイスでのサポートについては、すべてのAppleシリコンMacで利用できます。

00:22:26.000 --> 00:22:33.000
他の人については、WebMで見たものと同じように、MediaCapabilities APIで確認できます。

00:22:33.000 --> 00:22:50.000
さて、あなたのサイトにWebMまたはVP9のコンテンツがある場合は、最新のSafariとWebKitでどのように機能するかを確認することをお勧めします。しかし、まだ使用するメディア形式を決定している場合は、H.264またはHEVCをお勧めします。

00:22:50.000 --> 00:22:54.000
H.264は成熟しており、ブラウザ間で十分にサポートされています。

00:22:54.000 --> 00:22:58.000
HEVCは高品質のビデオを非常にサポートしています。

00:22:58.000 --> 00:23:06.000
どちらも、よりスムーズな再生とより長い再生バッテリー寿命を提供できるハードウェアアクセラレーションが付属しています。

00:23:06.000 --> 00:23:13.000
ビデオコンテンツのホスティングについて言えば、一般的なケースは、コンテンツを所有するのではなく、第三者から入手することです。

00:23:13.000 --> 00:23:18.000
例えば、私はvideo.domainでこの素敵なビデオを見ます。

00:23:18.000 --> 00:23:29.000
私のサイトmain.domainに表示するには、video.domainからこのビデオソースを読み込むか、video.domainのiframeを作成するだけです。

00:23:29.000 --> 00:23:36.000
セキュリティ上の理由から、サードパーティのiframeまたはリソースはデフォルトでファーストパーティストレージにアクセスできません。

00:23:36.000 --> 00:23:46.000
つまり、video.domainのリソース要求がmain.domainから開始された場合、video.domainのクッキーは含まれません。

00:23:46.000 --> 00:23:53.000
これは、video.domainのWebサーバーが認証されたユーザーにのみコンテンツを提供したい場合に問題になる可能性があります。

00:23:53.000 --> 00:23:57.000
そして、クッキーがないということは、認証がないことを意味します。

00:23:57.000 --> 00:24:01.000
ストレージアクセスAPIはこの問題を解決します。

00:24:01.000 --> 00:24:08.000
これにより、サードパーティのiframeは、ファーストパーティのCookieにアクセスする許可を要求できます。

00:24:08.000 --> 00:24:17.000
ユーザーが許可を付与すると、サードパーティのvideo.domainはファーストパーティのCookieにアクセスできるようになります。

00:24:17.000 --> 00:24:22.000
ストレージアクセスAPIは、WebKitとSafariで3年以上にわたって利用可能です。

00:24:22.000 --> 00:24:29.000
相互運用性を向上させるために、今年は2つの新機能を追加しました。

00:24:29.000 --> 00:24:32.000
まず、アクセスはページごとの範囲で許可されます。

00:24:32.000 --> 00:24:40.000
これは、第三者に許可が付与されると、同じページ上のすべてのサブリソースに拡張されることを意味します。

00:24:40.000 --> 00:24:45.000
各iframeのリクエストを行う必要はありません。

00:24:45.000 --> 00:24:49.000
第二に、ネストされたiframeが要求をすることを許可します。

00:24:49.000 --> 00:24:58.000
これは、iframe内のiframeが、以前は不可能だったファーストパーティクッキーへのアクセスも要求できることを意味します。

00:24:58.000 --> 00:25:08.000
新しい使用法の詳細については、webkit.orgのブログ記事「Storage Access APIの更新」を確認してください。

00:25:08.000 --> 00:25:15.000
これで、必要に応じてユーザーの許可を得て第三者からビデオコンテンツをロードまたはインポートする方法を知っています。

00:25:15.000 --> 00:25:18.000
自分で何かを作るのはどうですか?

00:25:18.000 --> 00:25:23.000
新しいメディアレコーダーAPIを使用すると、非常に簡単に実行できます。

00:25:23.000 --> 00:25:34.000
Media Recorder APIを使用すると、ビデオタグやMediaStreamオブジェクトなどのHTMLメディア要素を含むメディア要素からデータをキャプチャできます。

00:25:34.000 --> 00:25:39.000
ユーザーの入力デバイスから記録するために使用できます。

00:25:39.000 --> 00:25:47.000
コンテナのMIMEタイプやトラックの所望のビットレートなど、目的のオプションを指定できます。

00:25:47.000 --> 00:25:49.000
APIはシンプルです。

00:25:49.000 --> 00:25:58.000
これは、単一の主要なインターフェイスであるMediaRecorderで構成されており、ソースからデータを収集して配信するすべての作業を行います。

00:25:58.000 --> 00:26:02.000
例をお見せしましょう。

00:26:02.000 --> 00:26:07.000
MediaRecorder APIを使用して、「ボイスメモ」と呼ばれるこのウェブアプリを構築しました。

00:26:07.000 --> 00:26:09.000
これは私の最初のボイスメモです。

00:26:09.000 --> 00:26:13.000
ボタンをクリックすると、マイクから録音が始まります。

00:26:13.000 --> 00:26:16.000
もう一度クリックすると、録画を停止し、再生を提供します。

00:26:16.000 --> 00:26:19.000
これは私の最初のボイスメモです。

00:26:19.000 --> 00:26:21.000
それは楽しいです。

00:26:21.000 --> 00:26:25.000
では、実装を確認しましょう。

00:26:25.000 --> 00:26:29.000
startRecordingとstopRecordingの2つの主要な機能があります。

00:26:29.000 --> 00:26:33.000
startRecordingでは、マイクの入力メディアストリームを取得します。

00:26:33.000 --> 00:26:36.000
次に、それを使用してMediaRecorderオブジェクトを作成します。

00:26:36.000 --> 00:26:40.000
私たちはメディアレコーダーの2つのイベントを聞きます。

00:26:40.000 --> 00:26:43.000
そして、開始方法でレコーダーを起動できます。

00:26:43.000 --> 00:26:50.000
録音を停止するには、mediaRecorderオブジェクトのstopメソッドを呼び出すだけです。

00:26:50.000 --> 00:26:52.000
ここに2つのイベントハンドラがあります。

00:26:52.000 --> 00:26:57.000
キャプチャされたデータが利用可能な場合は、それを配列に保存します。

00:26:57.000 --> 00:27:05.000
録音が停止すると、収集したデータを配列でブロブを作成し、再生のために既存のオーディオ要素に送信します。

00:27:05.000 --> 00:27:09.000
そのように、機能的なボイスレコーダーを作成できます。

00:27:09.000 --> 00:27:13.000
オーディオデータを収集した後、それを編集したいと思うかもしれません。

00:27:13.000 --> 00:27:18.000
この場合、新しいAudio Worklet APIをうまく活用できます。

00:27:18.000 --> 00:27:27.000
Audio WorkletインターフェイスはWeb Audio APIの一部であり、以前にWebでオーディオ処理を行ったことがある場合は、すでによく知っているかもしれません。

00:27:27.000 --> 00:27:37.000
JavaScriptやWebAssemblyコードなどのスクリプトを実行して、カスタムAudioNodesをサポートするオーディオレンダリングスレッドでオーディオを処理できます。

00:27:37.000 --> 00:27:49.000
ScriptProcessorNodeと比較して、カスタムスクリプトを実行するための以前のソリューションは、レンダリングスレッドとメインスレッドの間のホッピングを減らし、低レイテンシーを保証します。

00:27:49.000 --> 00:27:55.000
オーディオワークレットで、ボイスメモに新しい機能を追加しました。

00:27:55.000 --> 00:27:57.000
これは私の歪んだ声です。

00:27:57.000 --> 00:28:03.000
録音のために歪みボックスがチェックされている場合、オーディオに何らかの歪み効果が適用されます。

00:28:03.000 --> 00:28:12.000
これは私の歪んだ声です、それはクールに聞こえます、そしてそれがどのように実装されているかを見てみましょう。

00:28:12.000 --> 00:28:16.000
startRecording機能を変更して、オーディオ処理を追加しました。

00:28:16.000 --> 00:28:20.000
最初にオーディオ入力用のMediaStreamを取得する必要があります。

00:28:20.000 --> 00:28:23.000
Audio Worklet APIを使用するには、4つの基本的なステップがあります。

00:28:23.000 --> 00:28:26.000
ステップ1：ソースを作成します。

00:28:26.000 --> 00:28:34.000
ステップ2：AudioWorkletNodeを作成し、オーディオ処理を実行するAudio Workletプロセッサにバインドします。

00:28:34.000 --> 00:28:39.000
プロセッサはモジュールに実装されており、後で見ていきます。

00:28:39.000 --> 00:28:41.000
ステップ3：目的地を作成します。

00:28:41.000 --> 00:28:46.000
ステップ4：ソースから宛先へのパスを接続します。

00:28:46.000 --> 00:28:55.000
今回、MediaRecorderはAudioWorkletからの出力をソースとして取り、歪んだオーディオを記録します。

00:28:55.000 --> 00:28:58.000
これはオーディオ処理モジュールです。

00:28:58.000 --> 00:29:01.000
ここでDistortionProcessorクラスを実装します。

00:29:01.000 --> 00:29:09.000
AudioWorkletProcessorクラスを拡張し、プロセス機能の実装を提供する必要があります。

00:29:09.000 --> 00:29:17.000
入力はAudio Workletに入ってくるオーディオサンプルで、出力は処理後の結果のサンプルです。

00:29:17.000 --> 00:29:21.000
異なるアルゴリズムを使用して出力を作成できます。

00:29:21.000 --> 00:29:26.000
ここでは、distorted()と呼ばれるカスタム関数を使用して、入力に基づいて値を計算します。

00:29:26.000 --> 00:29:32.000
プロセス関数はtrueを返します。つまり、プロセッサノードがアクティブです。

00:29:32.000 --> 00:29:35.000
それがプロセス機能の基本的な構造です。

00:29:35.000 --> 00:29:45.000
プロセッサクラスを作成した後、AudioWorkletNodeの構築に使用できるように、指定された名前でグローバルに登録する必要があります。

00:29:45.000 --> 00:29:50.000
このようにして、オーディオデータに効果音を適用できます。

00:29:50.000 --> 00:29:54.000
これまでのところ、オーディオデータの作成と処理について議論しました。

00:29:54.000 --> 00:29:59.000
記録のために保存したり、他の場所に共有したりするのはどうですか？

00:29:59.000 --> 00:30:04.000
ブラウザを終了した後、録画を失いたくないと思います。

00:30:04.000 --> 00:30:10.000
今年のWeb Share APIのアップデートにより、それを行うのは非常に簡単です。

00:30:10.000 --> 00:30:13.000
Web Shareは、WebKitとSafariでは新しいものではありません。

00:30:13.000 --> 00:30:24.000
SafariでWebページでリンクを共有することを選択した場合、メッセージ、メール、AirDropなどの共有ターゲットを含む共有シートが表示されます。

00:30:24.000 --> 00:30:32.000
システムスタイルによく一致する共有シートは、Web Share APIで作成されます。

00:30:32.000 --> 00:30:36.000
今年は、ファイル共有のサポートを追加しました。

00:30:36.000 --> 00:30:43.000
これは、このAPIで画像、ビデオ、オーディオ、またはその他の種類のファイルを共有できることを意味します。

00:30:43.000 --> 00:30:47.000
ボイスメモに共有機能を追加しましょう。

00:30:47.000 --> 00:30:57.000
[保存]ボックスがチェックされている場合、ボイスメモはキャプチャされたデータを含むオーディオファイルを作成し、ファイルを共有できるように共有ボタンを表示します。

00:30:57.000 --> 00:31:00.000
ここでは、メモファイルをメールで共有したいです。

00:31:00.000 --> 00:31:06.000
ワンクリックで、メモファイルが添付された素敵なドラフトが作成されます。

00:31:06.000 --> 00:31:09.000
そして、コードを確認しましょう。

00:31:09.000 --> 00:31:14.000
これは、MediaRecorderの例で見た停止イベントハンドラです。

00:31:14.000 --> 00:31:21.000
まず、共有関数で使用できるように、停止イベントハンドラでブロブ変数をグローバルにしましょう。

00:31:21.000 --> 00:31:25.000
共有機能は、共有ボタンのクリックイベントハンドラです。

00:31:25.000 --> 00:31:29.000
Blobをファイルに変換し、ファイル名を与えます。

00:31:29.000 --> 00:31:34.000
予想される入力タイプであるため、ファイルは配列に入れられます。

00:31:34.000 --> 00:31:40.000
次に、APIが利用可能かどうか、およびファイルをcanShareメソッドで共有できるかどうかを確認します。

00:31:40.000 --> 00:31:46.000
チェックが合格した場合、ファイル配列でnavigator.shareを呼び出します。

00:31:46.000 --> 00:31:51.000
タイトルや説明テキストなど、指定できるオプションがあります。

00:31:51.000 --> 00:31:57.000
ネイティブアプリのように、ウェブアプリがファイルを共有できるのと同じくらい簡単です。

00:31:57.000 --> 00:32:08.000
まあ、実際にオーディオデータと対話したくないが、そのテキストが欲しいだけなら、例えば音声コマンドの場合、新しいAPIもあります。

00:32:08.000 --> 00:32:11.000
それは音声認識です。

00:32:11.000 --> 00:32:18.000
その名前が示唆されているように、音声認識APIはライブオーディオをキャプチャし、それをテキストに転写します。

00:32:18.000 --> 00:32:23.000
また、トランスクリプトの確率と代替案も提供します。

00:32:23.000 --> 00:32:32.000
Siriと同じ音声エンジンを使用し、複数の言語のサポートと優れた精度など、すべての利点が得られます。

00:32:32.000 --> 00:32:41.000
つまり、APIを利用可能にするには、ユーザーがシステム環境設定または設定でSiriまたはディクテーションをオンにする必要があることを意味します。

00:32:41.000 --> 00:32:49.000
認識はサーバーベースでできるため、認識サービスがアプリで初めて使用されるときにプライバシープロンプトを表示します。

00:32:49.000 --> 00:32:55.000
ユーザーは、システム環境設定または設定で権限を変更できます。

00:32:55.000 --> 00:32:59.000
さて、この新機能でボイスメモを更新しましょう。

00:32:59.000 --> 00:33:04.000
認識ボックスがチェックされている場合は、録音のトランスクリプトを生成することを意味します。

00:33:04.000 --> 00:33:07.000
これは私のボイスメモのトランスクリプトです。

00:33:07.000 --> 00:33:10.000
期間。

00:33:10.000 --> 00:33:13.000
そして、コードを確認しましょう。

00:33:13.000 --> 00:33:16.000
使い方はメディアレコーダーに少し似ています。

00:33:16.000 --> 00:33:21.000
ここには、startRecognitionとstopRecognitionの2つの主要な機能があります。

00:33:21.000 --> 00:33:25.000
最初にwebkitSpeechRecognitionオブジェクトを作成する必要があります。

00:33:25.000 --> 00:33:32.000
はい、互換性のために今のところWebKitプレフィックスを保持しているので、追加することを忘れないでください。

00:33:32.000 --> 00:33:42.000
次に、停止するまで継続するように認識を要求する連続など、認識のいくつかのプロパティを設定できます。

00:33:42.000 --> 00:33:45.000
私たちは結果と終了イベントに耳を傾けます。

00:33:45.000 --> 00:33:55.000
認識オブジェクトを使用すると、startメソッドを呼び出して開始し、stopメソッドを呼び出して停止できます。

00:33:55.000 --> 00:33:59.000
結果イベントでは、finalTranscriptを文字列に収集します。

00:33:59.000 --> 00:34:07.000
ここでは、転写の選択肢は確率に基づいてソートされるため、結果の最初の項目のみを選択します。

00:34:07.000 --> 00:34:13.000
認識が停止すると、カスタムログ機能を使用してトランスクリプトを画面に印刷します。

00:34:13.000 --> 00:34:20.000
このように、わずか数行でウェブコンテンツに認識機能を追加できます。

00:34:20.000 --> 00:34:26.000
それは長い旅であり、言及する価値があると思う最後のWeb APIが1つあります。

00:34:26.000 --> 00:34:33.000
macOSとiOSでは、再生中ウィジェットがSafariでメディアの状態を表示できることに気付いたかもしれません。

00:34:33.000 --> 00:34:39.000
便利ですが、通常はあまり情報が含まれていません。

00:34:39.000 --> 00:34:46.000
たとえば、これはウェブページのタイトルのみを表示し、再生されているオーディオに関する情報はありません。

00:34:46.000 --> 00:34:55.000
この状況を改善するのに役立つ新しいウェブAPIがあります。メディアセッションAPIです。

00:34:55.000 --> 00:35:02.000
メディアセッションAPIを使用すると、Webページと他のプラットフォームコンポーネント間でメディアの状態を通信できます。

00:35:02.000 --> 00:35:12.000
ユーザーが「再生中」ウィジェットのように、ウェブページの外でメディアの状態を表示または制御したい場合、これはあなたが知る必要があるAPIです。

00:35:12.000 --> 00:35:24.000
メディアセッションAPIの詳細については、WWDCセッション「GroupActivitiesでウェブ上のメディア再生を調整する」をご覧ください。

00:35:24.000 --> 00:35:27.000
そして、これらは私たちが探求したばかりの新機能です。

00:35:27.000 --> 00:35:30.000
あなたがそれについて何かを学んだと感じることを願っています。

00:35:30.000 --> 00:35:36.000
そして、今日の宿題は、これらの新しいAPIで独自のボイスメモを実装することです。

00:35:36.000 --> 00:35:45.000
冗談ですが、WebKitとSafariで最高の開発体験をお届けするために、あなたができることがいくつかあります。

00:35:45.000 --> 00:35:53.000
最新のWebKitとSafariの新機能を試して、bugs.webkit.orgでバグレポートを提出してください。

00:35:53.000 --> 00:36:01.000
Safari Technology Previewを使用すると、アクティブな開発中の新機能や機能を垣間見ることができます。

00:36:01.000 --> 00:36:11.000
WebKitやSafariで使用されるウェブ技術に興味がある場合、またはWebKitコミュニティへの参加に興味がある場合は、webkit.orgが良い情報源です。

00:36:11.000 --> 00:36:20.000
WebKitに関する最新情報を入手したい場合、または私たちに質問がある場合は、私たちをフォローするか、Twitterでタグを付けることを忘れないでください。

00:36:20.000 --> 00:36:25.000
このセッションをご覧いただきありがとうございます。WWDCで楽しい時間を過ごせますように！

00:36:25.000 --> 23:59:59.000
♪

