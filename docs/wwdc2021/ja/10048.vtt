WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:14.000
こんにちは、私の名前はブレット・カトーで、システムエクスペリエンスチームのエンジニアです。

00:00:14.000 --> 00:00:23.000
今日は、素晴らしいウィジェットの原則について話し、可能な限り最高のウィジェットを構築するのに役立ついくつかのホットなトピックに飛び込みます。

00:00:23.000 --> 00:00:26.000
iOS 14では、WidgetKitを導入しました。

00:00:26.000 --> 00:00:37.000
WidgetKitを使用すると、iOS、iPadOS、macOSのユーザーのホーム画面で、美しくダイナミックなマルチプラットフォームウィジェットを作成できます。

00:00:37.000 --> 00:00:50.000
さて、始める前に、WWDC 2020の講演を見逃した場合、WidgetKitフレームワークとそのコアコンセプトを紹介する「Meet WidgetKit」など、本当に素晴らしいものがいくつかあります。

00:00:50.000 --> 00:00:57.000
「ウィジェットコードアロング」は、基本から上級まで複雑さを増すウィジェットを構築する3部構成のシリーズです。

00:00:57.000 --> 00:01:04.000
「ウィジェット用のSwiftUIビューの構築」では、ウィジェットの適応可能なビューを構築するためにSwiftUIを最大限に活用する方法について詳しく説明します。

00:01:04.000 --> 00:01:13.000
最後に、「素晴らしいウィジェットをデザインする」は、多くの例を挙げて、ヒューマンインターフェースグループからデザインの考慮事項を探ります。

00:01:13.000 --> 00:01:22.000
今日は、優れたウィジェットの2つのトピックに触れます。関連性を維持し、ウィジェットのカスタマイズを有効にします。

00:01:22.000 --> 00:01:25.000
では、関連性から始めましょう。

00:01:25.000 --> 00:01:33.000
ウィジェットが最新であり、その環境に適応できることを確認するために、3種類の関連性について深く議論します。

00:01:33.000 --> 00:01:39.000
時間、プレゼンテーション、場所の関連性について話します。

00:01:39.000 --> 00:01:41.000
WidgetKitの中心にはタイムラインがあります。

00:01:41.000 --> 00:01:45.000
これは、一日を通して関連性を維持するためのウィジェットのコアメカニズムです。

00:01:45.000 --> 00:01:49.000
タイムラインは、1つ以上のタイムラインエントリで構成されています。

00:01:49.000 --> 00:01:56.000
この例では、午前9時、午前9時30分、午前10時の3つのエントリを見ることができます。

00:01:56.000 --> 00:02:06.000
これで、システムがウィジェットにタイムラインを要求すると、結果のタイムラインがアーカイブされ、そのエントリは将来指定した特定の時間にレンダリングされます。

00:02:06.000 --> 00:02:12.000
これにより、システムは一瞬の通知でユーザーインターフェイスを準備し、ユーザーが必要とするときに表示することができます。

00:02:12.000 --> 00:02:20.000
最も単純なものから始めて、タイムラインのいくつかの例を見て、その中にある可能性のあるコンテンツの種類を見てみましょう。

00:02:20.000 --> 00:02:26.000
これは、1つのエントリを持つ最も単純なタイムラインの例です:スクリーンタイム。

00:02:26.000 --> 00:02:40.000
現在、スクリーンタイムは将来のデータを予測または予測できず、ユーザーのデバイスがどのように使用されたかの統計履歴に厳密に基づいているため、タイムラインで複数のエントリをうまく活用できないため、1つのエントリを使用するだけです。

00:02:40.000 --> 00:02:43.000
これはあなたが持つことができる最も単純なタイムラインです。

00:02:43.000 --> 00:02:53.000
とはいえ、すべてのウィジェットが単一のエントリである必要はなく、実際には、ほとんどの場合、タイムラインで複数のエントリを提供しない理由を検討し、質問することをお勧めします。

00:02:53.000 --> 00:03:05.000
将来を見据えたコンテンツがある場合、重要な日付や締め切りがある場合、または将来のコンテンツを予測できる場合、ウィジェットはタイムラインの複数のエントリを実際に利用しているはずです。

00:03:05.000 --> 00:03:07.000
これは天気の別の例です。

00:03:07.000 --> 00:03:13.000
ご覧のとおり、天気のタイムラインは、1日を通して最後の時間に複数のエントリを提供します。

00:03:13.000 --> 00:03:23.000
さて、ここでの最初のエントリは、現在の天気を表し、他のすべての後続のエントリは、その日の後半の予測データを表すため、最も正確です。

00:03:23.000 --> 00:03:30.000
この追加の予測データは、ウィジェットのリロードは、指定した正確な時間にリロードすることが保証されていないため、非常に便利です。

00:03:30.000 --> 00:03:42.000
そして、リロードが希望どおりにその目標日に正確にヒットしない場合、システムはユーザーエクスペリエンスを乗り越えるために追加の予測コンテンツを持っています。

00:03:42.000 --> 00:03:44.000
これは写真の例です。

00:03:44.000 --> 00:03:51.000
写真のタイムラインは、1日の特定の時間に表示される多くの個人的および関連性の高い写真を提供していることがわかります。

00:03:51.000 --> 00:03:55.000
私にとって、これらは本当に、本当に素晴らしい思い出です。

00:03:55.000 --> 00:04:05.000
そして今、ウィジェットは1日に数回しかリロードしませんが、これらの複数のタイムラインエントリから新しくて新鮮なコンテンツを提示することで、本当に活気に満ちている感覚を与えます。

00:04:05.000 --> 00:04:22.000
ご覧のとおり、写真のこの例のように、天気のような予測可能なデータがなくても、タイムラインでこれらの複数のエントリを活用することで、驚かせ、喜ばせる方法でユーザーに関連するコンテンツを組み込むことができます。

00:04:22.000 --> 00:04:27.000
さて、一部のウィジェットは他のウィジェットよりも多く表示されるため、ウィジェットに更新の公平性要因を与えることにしました。

00:04:27.000 --> 00:04:30.000
私たちはこれを更新予算と呼んでいます。

00:04:30.000 --> 00:04:37.000
予算は一日を通して割り当てられ、蓄積され、ユーザーの視聴習慣に大きく影響されます。

00:04:37.000 --> 00:04:52.000
頻繁に表示されるウィジェットは、1日あたり約40〜70のバックグラウンド更新の球場のどこかで受け取ることが期待できます。これは、ユーザーが起きている通常の時間内に均等に配置されている場合、約15〜30分ごとに更新されます。

00:04:52.000 --> 00:05:01.000
しかし、もちろん、すべてのリロードがこのように均等に間隔をあける必要はなく、私たちの目標は、さまざまな要件に対してさまざまな更新ケイデンスを有効にしてサポートすることでした。

00:05:01.000 --> 00:05:14.000
たとえば、お気に入りのチームの今後の試合までほとんどアイドル状態のスポーツウィジェットがあり、試合前、試合中、試合後にスコア更新のバーストを受け取ることができます。

00:05:14.000 --> 00:05:21.000
WidgetKitのスマートで、ユーザーが眠っているときのように、ユーザーがデバイスを長時間使用していないときに更新を保留する可能性があります。

00:05:21.000 --> 00:05:27.000
それ以外の場合、特定のウィジェットの予算が利用可能になるまで、ウィジェットの更新が保留される可能性があります。

00:05:27.000 --> 00:05:31.000
しかし、そうは言っても、リロードは毎秒の操作ではありません。

00:05:31.000 --> 00:05:36.000
ウィジェットは、ホーム画面でライブランニング体験を作成することではありません。

00:05:36.000 --> 00:05:41.000
今、あなたのウィジェットが一日を通して更新される多くの方法があります。

00:05:41.000 --> 00:05:50.000
そして、これらのそれぞれを簡単に説明して、それらが何であるか、どのように機能し、先ほど導入した予算に関連してどのように機能するかを理解します。

00:05:50.000 --> 00:05:54.000
1つ目は、WidgetKitのAPIであるTimelineReloadPolicyです。

00:05:54.000 --> 00:05:59.000
これは、リロードが自動的に行われるためのコアメカニズムです。

00:05:59.000 --> 00:06:04.000
タイムラインを提供する場合は、それと一緒にリロードポリシーも提供します。

00:06:04.000 --> 00:06:10.000
このリロードポリシーは、バックグラウンドでウィジェットを自動的に更新したいときにシステムに通知します。

00:06:10.000 --> 00:06:17.000
これらの自動更新は予算化され、ウィジェットの現在の利用可能な予算から引き落とされます。

00:06:17.000 --> 00:06:20.000
次はWidgetCenterリロードAPIです。

00:06:20.000 --> 00:06:26.000
これは、ウィジェットの既存のデータを無効にするイベントが発生したときにウィジェットを更新するAPIです。

00:06:26.000 --> 00:06:34.000
さて、通常、このAPIを使用するリクエストは利用可能な予算を消費します。つまり、予算が利用可能になるまで更新は行われません。

00:06:34.000 --> 00:06:42.000
しかし、これらのリロードを即時かつ予算なしで行うようにするいくつかの状況例外があります。

00:06:42.000 --> 00:06:52.000
これらは、コンテナアプリがユーザーのフォアグラウンドである場合、またはアプリがナビゲーションや再生中オーディオなどのユーザーセッションに参加している場合です。

00:06:52.000 --> 00:06:59.000
このAPIは、TimelineReloadPolicy APIからの自動バックグラウンド更新を本当に補完するものです。

00:06:59.000 --> 00:07:03.000
ウィジェットは、重要な場所の変更が発生したときにも更新できます。

00:07:03.000 --> 00:07:10.000
システムが重要な場所の変更を検出し、ウィジェットが場所を使用すると、システムは予算なしの更新を許可します。

00:07:10.000 --> 00:07:17.000
この更新は、場所を適切に解決できるように、ユーザーが次にウィジェットを表示したときに発生します。

00:07:17.000 --> 00:07:24.000
さて、これは場所の変更が発生したときにすぐに起こることは保証されるのではなく、ユーザーが次回ウィジェットを見たときに起こることを保証することに注意してください。

00:07:24.000 --> 00:07:27.000
後で場所についてもう少し話します。

00:07:27.000 --> 00:07:31.000
プレゼンテーション環境が変更された場合、システムもウィジェットを更新できます。

00:07:31.000 --> 00:07:44.000
たとえば、ユーザーが動的テキストや太字テキストなどのアクセシビリティ設定を変更したり、言語や地域の変更、iCloudまたはApp Storeアカウントの変更、大幅な時間変更などがあるかもしれません。

00:07:44.000 --> 00:07:53.000
最後に、予算編成のため、ユーザーがめったに見られないウィジェットを持っている場合、開発者が好むほど多くの更新を受信しない可能性があります。

00:07:53.000 --> 00:08:00.000
システムは、タイムラインの日付、好みの更新時間、およびユーザーからの一般的なビュー履歴を知っています。

00:08:00.000 --> 00:08:05.000
システムは、ユーザーが閲覧したときにデータが古くなっている可能性があると思われる場合、予算なしのリロードを許可する場合があります。

00:08:05.000 --> 00:08:10.000
もちろん、これらのシステム開始の更新はすべて常に予算フリーです。

00:08:10.000 --> 00:08:18.000
先ほど学んだように、各タイムラインには、バックグラウンドで自動的に更新するタイミングを説明するリロードポリシーが組み合わされています。

00:08:18.000 --> 00:08:24.000
WidgetKitはここで3つの選択肢を提供します:atEnd、afterDate、never。

00:08:24.000 --> 00:08:28.000
これら3つのリロードポリシーのうち、ウィジェットに適したものはどれですか?

00:08:28.000 --> 00:08:37.000
文脈のためのいくつかの例を挙げて、それぞれについて話し合いましょう。そして、それぞれについて何に留意すべきかについてのgotchasについて話しましょう。

00:08:37.000 --> 00:08:41.000
議論する最初のポリシーは、atEndリロードポリシーです。

00:08:41.000 --> 00:08:49.000
このポリシーは、タイムラインが終了したとき、つまりもちろん最後のエントリが関連したときに、ウィジェットを更新する資格をマークします。

00:08:49.000 --> 00:08:53.000
この場合、午前10時30分です。

00:08:53.000 --> 00:09:03.000
また、今回は単にウィジェットが更新の対象となる時間であり、この時点で正確に更新されることを保証するものではありません。

00:09:03.000 --> 00:09:14.000
さらに、前に説明したスクリーンタイムの例のように、シングルエントリのタイムラインを持つウィジェットでatEndを使用する場合、システムはウィジェットに適切な時間を選択します。

00:09:14.000 --> 00:09:21.000
ウィジェットに現在のタイムラインの寿命を超えたコンテンツがすでにある場合は、atEndをお勧めします。

00:09:21.000 --> 00:09:24.000
私はあなたのコンテンツにウィンドウを見るようにそれについて考えるのが好きです。

00:09:24.000 --> 00:09:27.000
例を見てみましょう。 例を見てみましょう。

00:09:27.000 --> 00:09:31.000
ここで概説されているのは、6月7日のカレンダーウィジェットの現在のタイムラインです。

00:09:31.000 --> 00:09:33.000
4つのエントリがあります。

00:09:33.000 --> 00:09:38.000
ウィンドウを紹介するのに役立つ過去と将来のコンテンツを含めました。

00:09:38.000 --> 00:09:46.000
そして、6月8日のタイムラインを変更すると、そのコンテンツのウィンドウを見ることで私が何を意味するかがわかります。

00:09:46.000 --> 00:09:48.000
そしてまた、6月9日のタイムラインについて。

00:09:48.000 --> 00:09:53.000
私たちは、すでに利用可能で、ユーザーによって提供されているデータに対する視点を変えているだけです。

00:09:53.000 --> 00:10:00.000
このタイプのコンテンツは、実際にatEndポリシーを使用することが輝く場所です。

00:10:00.000 --> 00:10:07.000
さて、atEndポリシーを使用するウィジェットの例には、リマインダー、カレンダー、写真、ヒントなどがあります。

00:10:07.000 --> 00:10:14.000
繰り返しになりますが、これらはすべて、将来的によく知られている無限のコンテンツを持つウィジェットであり、単にウィンドウを表示することができます。

00:10:14.000 --> 00:10:23.000
システムはあなたのためにリロード時間を選択し、おそらくあなたが望むものではないので、シングルエントリーのタイムラインにはあまり適していません。

00:10:23.000 --> 00:10:30.000
また、タイムラインに時間の経過とともに関連性や精度が失われる予測コンテンツがある場合、AtEndは推奨されません。

00:10:30.000 --> 00:10:43.000
私たちは単にあなたのコンテンツが可能な限り最も関連性のあるものにしたいし、物事が更新の資格を得るために最も関連性の低いタイムラインの終わりまで待つと、それは最高のユーザーエクスペリエンスにつながりません。

00:10:43.000 --> 00:10:47.000
だから、それはアットエンドです。さて、afterDateについて話しましょう。

00:10:47.000 --> 00:10:53.000
afterDateリロードポリシーにより、ウィジェットは指定された日付以降にリロードの対象となります。

00:10:53.000 --> 00:10:58.000
AfterDateでは、資格時間を完全に管理できます。

00:10:58.000 --> 00:11:04.000
この例では、タイムラインが午前9時から午前11時頃まで有効であるふりをしましょう。

00:11:04.000 --> 00:11:12.000
ウィジェットの予測データが9時45分頃に精度を失い始めるため、午前9時30分のウィジェットリロードポリシーの日付が選択されました。

00:11:12.000 --> 00:11:21.000
これにより、9時30分にすぐにリロードされていなくても、ウィジェットには9時30分以降に十分な滑走路があり、予測データを表示できます。

00:11:21.000 --> 00:11:33.000
afterDateは、1日を通して予測不能または予期せず変化する可能性のあるコンテンツや、正確性や関連性が定期的に変化するデータに最も適しています。

00:11:33.000 --> 00:11:40.000
afterDateを使用するウィジェットの例には、株式、天気、ニュース、メールなどがあります。

00:11:40.000 --> 00:11:47.000
これらはすべて、一日を通して予測不能または予期せず変化する可能性のあるコンテンツを含むウィジェットです。

00:11:47.000 --> 00:11:52.000
さて、afterDateでは、いくつかの潜在的な問題に本当に注意する必要があります。

00:11:52.000 --> 00:11:55.000
ほぼ即時のリロードに注意してください。

00:11:55.000 --> 00:12:01.000
1分かそこら離れた日付を指定することは有効ですが、通常は非常に狭い時間枠でのみ有効です。

00:12:01.000 --> 00:12:08.000
このレベルの解像度であまりにも多くのリフレッシュを求めると、後でリロードを飢えさせる可能性があります。

00:12:08.000 --> 00:12:12.000
また、デバイス間でウィジェットの更新日を揃える場合は注意してください。

00:12:12.000 --> 00:12:25.000
例えば、米国は。株式市場は東海岸で午前9時30分にオープンし、午前9時30分にリフレッシュをスケジュールして、その日の初期データをサーバーから取得します。

00:12:25.000 --> 00:12:33.000
あなたのウィジェットは数千または数百万のデバイスにあり、潜在的にはそれらの各デバイスでも複数回ある可能性があることを覚えておいてください。

00:12:33.000 --> 00:12:44.000
そして、このように時間に合わせたデータプルを行う必要がある場合は、キャッシングサーバーを打つことに加えて、これらの日付にある程度のランダムなジッターを追加することを検討する必要があります。

00:12:44.000 --> 00:12:51.000
これらは、潜在的に計画されていないコストや不必要なコストを避けるために考慮することが特に重要です。

00:12:51.000 --> 00:12:56.000
最後に、私のお気に入りのリロードポリシーについて話しましょう。これは決してありません。

00:12:56.000 --> 00:13:01.000
決してリロードしないポリシーは、自動的にリロードされないため、最も単純なポリシーです。

00:13:01.000 --> 00:13:13.000
ウィジェットのコンテンツが、フォアグラウンドであるコンテナアプリケーションを介してのみ変更できる場合、またはプッシュ通知などの個別のイベントを介してのみ変更できる場合は、ウィジェットにとって決して素晴らしい選択ではありません。

00:13:13.000 --> 00:13:23.000
ネローポリシーを使用する場合は、コンテナやその他のアクセサリ拡張機能からのWidgetCenterリロードAPIでのみ、ウィジェットを最新の状態に保つことができます。

00:13:23.000 --> 00:13:32.000
これにより、必要な場合にのみリロードが最小限に抑えられ、予算とユーザーのバッテリー寿命への影響を最小限に抑えます。

00:13:32.000 --> 00:13:38.000
ウィジェットがアプリでまだ満たされていない明示的なユーザー条件を必要とする場合も、決して適切ではありません。

00:13:38.000 --> 00:13:43.000
たとえば、サービスにログインしたり、特定のコンテンツを購入したりするかもしれません。

00:13:43.000 --> 00:13:49.000
これらの種類の条件がアプリで満たされる前に、ウィジェットが意味のあるコンテンツを生成できない場合は、決して考慮しないでください。

00:13:49.000 --> 00:13:57.000
決してポリシーを使用するウィジェットの良い例には、テレビ、メモ、音楽、ポッドキャスト、連絡先などがあります。

00:13:57.000 --> 00:14:06.000
これらはすべて、コンテンツの変更を促進するためにアプリ内のユーザーインタラクションを必要とするウィジェットとアプリ、またはそれらのコンテンツ更新のプッシュを受け取ります。

00:14:06.000 --> 00:14:10.000
要約すると、タイムラインエントリを有利に活用してください。

00:14:10.000 --> 00:14:20.000
ウィジェットの正しいリロードポリシーを選択し、WidgetCenterのリロードAPIを使用して、個別のイベントのタイムラインイベントをリロードします。

00:14:20.000 --> 00:14:24.000
さて、プレゼンテーションの関連性に移りましょう。

00:14:24.000 --> 00:14:31.000
ウィジェットはiOSまたはmacOSの特定のコンテキストで表示され、ウィジェットの外観が変わる可能性があります。

00:14:31.000 --> 00:14:36.000
ウィジェットは、タイムラインを更新せずに再レンダリングされることがあります。

00:14:36.000 --> 00:14:40.000
そして、優れたウィジェットは常にこれらのプレゼンテーション環境に適切に適応します。

00:14:40.000 --> 00:14:50.000
そこで、カラースキーム、ダークモードとライトモード、iOS 15で新しい部分的なプライバシーの編集、および完全なプライバシーの編集について話します。

00:14:50.000 --> 00:14:56.000
WidgetKitは、システム設定が変更されると、ライトモードとダークモードの間のコンテンツの移動を自動的に処理します。

00:14:56.000 --> 00:15:00.000
これは、SwiftUIのパワーを使用しているためです。

00:15:00.000 --> 00:15:04.000
次に、これらのそれぞれのコンテキストでウィジェットをどのように見たいかを考えてください。

00:15:04.000 --> 00:15:11.000
ここでは、明るいスキームと暗いスキームの両方でノートとカレンダーの例を見ることができます。

00:15:11.000 --> 00:15:17.000
ただし、すべてのウィジェットが背景とテキストの色を変更することで、必ずしもライトモードとダークモードに準拠する必要はないことを覚えておいてください。

00:15:17.000 --> 00:15:22.000
たとえば、音楽や株式など、色を変えないウィジェットがいくつかあります。

00:15:22.000 --> 00:15:33.000
アプリケーションデザインがダークスタイルとライトスタイルのこの高コントラストコンテンツに依存しない場合は、ウィジェットにとって理にかなっている配色を自由に続けてください。

00:15:33.000 --> 00:15:38.000
Xcodeプレビューを通じて、Xcodeでウィジェットの配色変更をプレビューすることもできます。

00:15:38.000 --> 00:15:44.000
これは、ライトモードでsystemSmallウィジェットをプレビューする簡単な例です。

00:15:44.000 --> 00:15:46.000
そして今、ダークモードです。

00:15:46.000 --> 00:15:52.000
私たちがしなければならなかったのは、この環境でウィジェットがどのように見えるかをプレビューするために、colorScheme環境オーバーライドを追加することだけでした。

00:15:52.000 --> 00:16:02.000
また、ここに示すように、ライトモードとダークモードのシステム標準の背景色が必要な場合は、塗りつぶしにBackgroundStyleを使用してください。

00:16:02.000 --> 00:16:08.000
ウィジェットは、iOSのロック画面など、プライバシーに敏感なプレゼンテーション環境にもさらされています。

00:16:08.000 --> 00:16:14.000
iOS 15の新機能で、ウィジェットはこのような状況で部分的なコンテンツを編集できるようになりました。

00:16:14.000 --> 00:16:20.000
さて、それは本当に混乱しているように聞こえるかもしれないので、私がここで何を言っているのかを見るために例を挙げましょう。

00:16:20.000 --> 00:16:25.000
特定の口座で利用可能な残高を表示している銀行ウィジェットを持っているふりをしましょう。

00:16:25.000 --> 00:16:31.000
この場合、私の口座には128.45ドルがあります。

00:16:31.000 --> 00:16:44.000
さて、ロック画面に移動してデバイスをロックすると、デバイスがロックされたときにWidgetKitが残高情報を動的に編集する方法がなかったため、このアカウントの残高はまだiOS 14に表示されます。

00:16:44.000 --> 00:16:52.000
しかし、それはiOS 15で変更され、これらの状況で編集される特定のビューを文脈的にマークできるようになりました。

00:16:52.000 --> 00:17:00.000
さて、その方法を示すために、残高を表すテキストに.privacySensitiveビュー修飾子を挿入するだけです。

00:17:00.000 --> 00:17:08.000
したがって、パスコードがロックされていない場合でも、ここでわかるように、ビューは期待どおりに残高をレンダリングします。

00:17:08.000 --> 00:17:15.000
しかし、デバイスをロックすると、残高がマスクされるか、または編集されます。

00:17:15.000 --> 00:17:21.000
この修飾子は、hstacksやvstacksなどのコンテナビューを含む任意のビューに適用できることにも注意してください。

00:17:21.000 --> 00:17:26.000
また、コンテナに適用すると、コンテナ全体が編集されます。

00:17:26.000 --> 00:17:44.000
iOSデバイスがパスコードロックされている間、アプリが触れることができない完全なデータ保護を活用している場合、たとえば、アプリが健康データを使用していて、ウィジェットの構築をスキップしたり、ロック画面に表示しなければならないと思ったためにそれを含めることを恐れていた場合、この機能は本当にあなたのためです。

00:17:44.000 --> 00:17:54.000
WidgetKitは、デバイスがコンテンツの完全な編集のためにパスコードロックされている場合、アクティブなタイムラインコンテンツを自動的にプレースホルダコンテンツに置き換えることができます。

00:17:54.000 --> 00:17:59.000
また、デバイスがパスコードロックされている間は、更新を保留することもできます。

00:17:59.000 --> 00:18:04.000
これは、ここにリストされているデフォルトのデータ保護資格を採用する場合、すべて可能です。

00:18:04.000 --> 00:18:09.000
あなたのタイムラインデータは、あなたの希望に応じて、デバイス上のそのデータクラスに保存されます。

00:18:09.000 --> 00:18:12.000
私たちはここであなたのデータのプライバシーを真剣に受け止めています。

00:18:12.000 --> 00:18:15.000
最後に、場所の関連性について話したいと思います。

00:18:15.000 --> 00:18:26.000
アプリのようなウィジェットは、現在の物理的な場所のコンテキスト情報、または単に何らかの形でユーザーに関連する場所を提供することもできます。

00:18:26.000 --> 00:18:31.000
アプリケーションが位置情報を正常に使用する場合は、ウィジェットも使用する必要がある可能性があります。

00:18:31.000 --> 00:18:46.000
ウィジェットはホーム画面とMacの通知センターで複数のインスタンスを持つことができるので、Intentsの力で天気ウィジェットで行うのと同じように、現在の場所を使用することに加えて、ウィジェットに事前に選択され、検索可能な場所を提供することを検討してください。

00:18:46.000 --> 00:18:51.000
さて、ウィジェットで現在の場所を取得するには、必要な手順はほんのわずかです。

00:18:51.000 --> 00:18:56.000
まず、Info.plistでNSWidgetUsesLocationキーを指定する必要があります。

00:18:56.000 --> 00:19:01.000
これにより、ウィジェット拡張機能から位置情報を使用することをシステムに知らせます。

00:19:01.000 --> 00:19:10.000
次に、ウィジェット拡張機能のTimelineProviderからのこの時間を除いて、通常どおりCLLocationManagerを使用してください。

00:19:10.000 --> 00:19:19.000
粗い場所を解決するのが速く、超正確な場所を必要としない場合、より良いユーザーエクスペリエンスをもたらす可能性があるため、ウィジェットが必要とする解像度を検討してください。

00:19:19.000 --> 00:19:25.000
一般的に、要求された場所が正確であればあるほど、解決に時間がかかります。

00:19:25.000 --> 00:19:33.000
最後に、CLLocationManagerのisAuthorizedForWidgetUpdates APIを使用して、ウィジェットが位置情報の更新を許可されているかどうかを確認できます。

00:19:33.000 --> 00:19:38.000
これにより、ユーザーがウィジェットに位置情報を使用する許可を与えたかどうかがわかります。

00:19:38.000 --> 00:19:44.000
許可といえば、ウィジェットの場所の許可をより詳細に見て、どのように機能するかを見てみましょう。

00:19:44.000 --> 00:19:48.000
ウィジェットの権限は、通常、そのアプリコンテナと共有されます。

00:19:48.000 --> 00:19:54.000
ここでは、設定アプリから利用可能な場所のアクセス許可のリストを見ることができます。

00:19:54.000 --> 00:20:08.000
ユーザーが「アプリの使用中」を選択した場合、ウィジェットのコンテナアプリがユーザーにとってフォアグラウンドである場合、またはナビゲーションセッション中など、アプリが使用中であると考えるその他の状況でのみ、ユーザーの位置がウィジェットで利用できます。

00:20:08.000 --> 00:20:19.000
ユーザーが「アプリまたはウィジェットの使用中」を選択した場合、場所は「アプリの使用中」で以前と同じように利用できますが、ウィジェットに固有の追加手当があります。

00:20:19.000 --> 00:20:26.000
これにより、ウィジェットのアクセス許可は、ウィジェットが最後に表示されてから最大15分後に場所を受信できます。

00:20:26.000 --> 00:20:41.000
そして、これら2つのアクセス許可のいずれかを設定して場所を解決できない場合は、代替コンテンツ、利用可能な場合は潜在的に以前のコンテンツ、または単に場所を解決できなかったことを示すことを検討してください。

00:20:41.000 --> 00:20:48.000
ユーザーが許可に「常に」を選択した場合、ウィジェットは常に場所にアクセスするための利用可能な許可を持っています。

00:20:48.000 --> 00:20:51.000
最後に、カスタマイズ可能なウィジェットの構築について話しましょう。

00:20:51.000 --> 00:20:58.000
ユーザーがウィジェット体験をパーソナライズするための手段として、サイズ、種類、構成について話します。

00:20:58.000 --> 00:21:00.000
現在、ウィジェットにはさまざまなサイズがあります。

00:21:00.000 --> 00:21:06.000
また、ユーザーがウィジェットを配置する際に選択できるように、できるだけ多くのサイズをサポートすることをお勧めします。

00:21:06.000 --> 00:21:17.000
デバイス間のサイジングには小さな差異があり、可能であればシステム標準のパディング、余白、テキストスタイル、テキストサイズを使用するのが最善であることを忘れないでください。

00:21:17.000 --> 00:21:22.000
さて、このiPadを見ると、それは本当にコンテンツショーケースに変身します。

00:21:22.000 --> 00:21:31.000
明らかでない場合は、iPad専用の新しいサイズがiOS 15に追加され、私たちはそれをエクストララージと呼んでいます。

00:21:31.000 --> 00:21:32.000
あなたがそれをよりよく見ることができるようにここにあります。

00:21:32.000 --> 00:21:39.000
それは大きなウィジェットと同じ高さですが、iPadで利用可能なさらに多くのコンテンツを紹介するためにより広いです。

00:21:39.000 --> 00:21:42.000
そして、ウィジェットに追加する方法は次のとおりです。

00:21:42.000 --> 00:21:47.000
ここでは、すでにsystemLargeファミリーをサポートしている既存のウィジェット設定に追加しました。

00:21:47.000 --> 00:22:00.000
デフォルトでは、ウィジェットの設定でサポートされているファミリーを指定しない場合、iOS 15 SDK以降でビルドすると、新しいサイズが自動的にサポートされます。

00:22:00.000 --> 00:22:03.000
パーソナライゼーションの次の軸はウィジェットの種類です。

00:22:03.000 --> 00:22:08.000
ウィジェットの種類は、データやコンテンツに異なる視点を提供します。

00:22:08.000 --> 00:22:12.000
だから、あなたのアプリでどのようなウィジェットが最も理にかなっているかを考えてください。

00:22:12.000 --> 00:22:16.000
これらを説明する最善の方法は、実際には例です。

00:22:16.000 --> 00:22:18.000
これは時計の例です。

00:22:18.000 --> 00:22:30.000
左側には、単一の都市の時刻を追跡する都市ウィジェットがあり、右側には、同じビューで多くの異なる都市を収容できる世界時計ウィジェットがあります。

00:22:30.000 --> 00:22:31.000
これは株式からの別の例です。

00:22:31.000 --> 00:22:40.000
左側には、特定の株式（この場合はApple）の株価を示す株式シンボルウィジェットがあり、右側には概要ウィジェットがあります。

00:22:40.000 --> 00:22:45.000
概要ウィジェットには、ユーザーの株式アプリに反映された一連の株式が表示されます。

00:22:45.000 --> 00:22:49.000
では、これらのさまざまな種類のウィジェットをどのように公開しますか?

00:22:49.000 --> 00:22:53.000
まあ、複数の種類のウィジェットを公開するのは超些細なことです。

00:22:53.000 --> 00:23:00.000
以前の株式の例を使用して、左上にシンボルウィジェットと概要ウィジェットがあります。

00:23:00.000 --> 00:23:08.000
これらを公開するには、WidgetBundleオブジェクトに異なるウィジェット設定を返し、WidgetBundleに@main属性を含めるだけです。

00:23:08.000 --> 00:23:11.000
それはとても簡単です。

00:23:11.000 --> 00:23:15.000
ウィジェットがバンドルで定義されている順序も非常に重要であることに注意してください。

00:23:15.000 --> 00:23:19.000
この順序は、ウィジェットがウィジェットギャラリーにどのように表示されるかを反映しています。

00:23:19.000 --> 00:23:24.000
したがって、リストされている最初のウィジェットがヒーローのユースケースであることを確認してください。

00:23:24.000 --> 00:23:32.000
最後に、アプリがインストールされると、ウィジェットの可用性を動的に公開したり、動的に撤回したりすることはできません。

00:23:32.000 --> 00:23:39.000
したがって、時間の経過とともにウィジェットのサポートの周りにいくつかの注意と思考を適用する必要があります。

00:23:39.000 --> 00:23:42.000
カスタマイズ性の最後の軸は、設定です。

00:23:42.000 --> 00:23:47.000
また、ウィジェットは、静的構成とインテントベースの構成の2つのタイプをサポートしています。

00:23:47.000 --> 00:23:53.000
静的ウィジェット構成は、ウィジェットインスタンスごとに同じコンテンツを配信します。

00:23:53.000 --> 00:23:55.000
以前の株式概要の例を覚えていますか？

00:23:55.000 --> 00:24:02.000
まあ、ユーザーのデバイス上の異なる場所にいても、それぞれがまったく同じコンテンツを表示します。

00:24:02.000 --> 00:24:11.000
静的ウィジェットは非常にシンプルで、ユーザーから設定や設定を取らないため、エレガントなウィジェット定義です。

00:24:11.000 --> 00:24:18.000
一方、Intentウィジェットの設定は、各インスタンスにユーザー設定のコンテンツを配信します。

00:24:18.000 --> 00:24:22.000
右側のこれらのストックシンボルウィジェットをチェックしてください。

00:24:22.000 --> 00:24:27.000
このユーザーは多くの異なるインスタンスを設定し、それぞれが異なる株式を紹介しています。

00:24:27.000 --> 00:24:28.000
さて、これはかなり甘いものです。

00:24:28.000 --> 00:24:35.000
また、ユーザーはこれらすべてをホーム画面のウィジェットのスタックにまとめて、スペースを節約することもできます。

00:24:35.000 --> 00:24:39.000
では、これらはユーザーによってどのように設定されているのか、あなたは尋ねるかもしれません。

00:24:39.000 --> 00:24:44.000
さて、ユーザーの観点から、システムは周囲のすべてのUIピースを提供します。

00:24:44.000 --> 00:24:50.000
そして、インテントをサポートする編集モードでウィジェットをタップすると、設定プラッターが表示されます。

00:24:50.000 --> 00:24:54.000
ユーザーが設定できるIntentのパラメータのリストを表示します。

00:24:54.000 --> 00:25:02.000
そして、この例では、シンボルが追跡するための単一のパラメータがあり、その値は現在、アップル株の文字列AAPLです。

00:25:02.000 --> 00:25:07.000
これで、ユーザーがパラメータをタップすると、入力コントローラがユーザーから入力を収集するように見えます。

00:25:07.000 --> 00:25:10.000
そして、完了すると、ウィジェットは自動的に更新されます。

00:25:10.000 --> 00:25:20.000
今、インテントでできるカスタマイズがたくさんあります。そして、WWDC 2020からの素晴らしい話があります。インテント設定が必要な場合は、すぐに始めるのを手伝います。

00:25:20.000 --> 00:25:29.000
それまでの間、インテントに基づくウィジェットのコーディングと静的設定の違いを簡単に強調しましょう。

00:25:29.000 --> 00:25:31.000
静的構成は本当にシンプルです。

00:25:31.000 --> 00:25:36.000
標準のTimelineProviderでStaticConfigurationオブジェクトをインスタンス化するだけです。

00:25:36.000 --> 00:25:40.000
それをインテント構成と対比しましょう。

00:25:40.000 --> 00:25:49.000
ここで異なるのは、StaticConfigurationがIntentConfigurationに置き換えられ、TimelineProviderがIntentTimelineProviderに置き換えられることです。

00:25:49.000 --> 00:25:57.000
これらのそれぞれには、インテントをサポートするためにわずかに変更されたインターフェイスがあり、タイムラインに入力するときにユーザー設定のインテントを受け取ることができます。

00:25:57.000 --> 00:26:12.000
サポートされているさまざまなデータタイプの概要や設定UIからどのように見えるかなど、ウィジェットのインテントの作成と設定に関するより詳細な概要については、WWDC 2020の「ウィジェットに構成とインテリジェンスを追加する」トークをご覧ください。

00:26:12.000 --> 00:26:23.000
最後に、優れたウィジェットがタイムラインエントリをどのように使用し、リロードポリシーをマスターし、プレゼンテーションや潜在的に物理的な環境に適応するかを見直しました。

00:26:23.000 --> 00:26:30.000
ユーザーにダイナミックでカスタマイズ可能な体験を提供するために、さまざまなサイズ、種類、構成を提供する計画を立ててください。

00:26:30.000 --> 23:59:59.000
ありがとうございます。

