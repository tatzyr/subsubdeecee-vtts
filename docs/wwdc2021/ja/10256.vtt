WEBVTT

00:00:00.000 --> 00:00:05.000
♪ベース音楽の演奏♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:11.000
カイル・マコンバー:こんにちは、私はカイルです。

00:00:11.000 --> 00:00:20.000
Swift Standard Libraryチームは、Swift ArgumentParser、Swift Numerics、Swift Systemなど、増え続けるオープンソースパッケージの名簿を維持しています。

00:00:20.000 --> 00:00:28.000
今日、私たちは家族に2つの大きな新しい追加を紹介することに興奮しています:スウィフトアルゴリズムとスウィフトコレクション!

00:00:28.000 --> 00:00:35.000
Swiftアルゴリズムは、Swift標準ライブラリを拡張するシーケンスおよびコレクションアルゴリズムのオープンソースパッケージです。

00:00:35.000 --> 00:00:41.000
Swiftの最も強力な機能の1つは、組み込まれたアルゴリズムの豊富な分類です。

00:00:41.000 --> 00:00:53.000
語彙を学ぶには少しの投資が必要ですが、一度そうすると、どれだけのアルゴリズムが目の前に隠れているか、それらを採用することでコードの品質をどれだけ向上させることができるかを発見するのは印象的です。

00:00:53.000 --> 00:00:59.000
私が何を意味するかを見るために、私が取り組んできたメッセージングアプリケーションのコードを見てみましょう。

00:00:59.000 --> 00:01:10.000
テーブルビューで選択した行のインデックスパスを反復し、転送または削除のために対応するすべてのメッセージを収集するこのループを検討してください。

00:01:10.000 --> 00:01:14.000
これはただの地図です。

00:01:14.000 --> 00:01:24.000
マップを使用すると、長さや複雑さに関係なく、クロージャの本体が入力を変換しているという余分なコンテキストを提供するため、このコードは読者にとってより明確になります。

00:01:24.000 --> 00:01:36.000
マップを使用すると、容量を予約することで配列のサイズ変更による中間割り当てが回避されるため、このコードが速くなります。

00:01:36.000 --> 00:01:48.000
または、ユーザーが画像をタップすると、トランスクリプト内のメッセージを反復し、クイックルックを使用して表示するためのすべての添付ファイルを収集するこのループを検討してください。

00:01:48.000 --> 00:01:51.000
これは単なる地図とフィルターです!

00:01:51.000 --> 00:02:06.000
実際、ニルをフィルタリングし、オプションをアンラップにマッピングするこのパターンは非常に一般的であるため、特別な名前とアルゴリズムがあります。コンパクトマップです。

00:02:06.000 --> 00:02:08.000
次に、このコードを検討してください。

00:02:08.000 --> 00:02:14.000
私はメッセージの配列を持っており、それをトランスクリプト項目の配列に変換したいです。

00:02:14.000 --> 00:02:22.000
厄介なのは、特定のメッセージがチャット記録の複数の項目に対応する可能性があることです。

00:02:22.000 --> 00:02:25.000
ここでマップを使用すると、配列の配列が生成されます。

00:02:25.000 --> 00:02:29.000
しかし、それは私が欲しいものではありません。私はただ平らな配列が欲しいだけです。

00:02:29.000 --> 00:02:33.000
これは、raw for loopの使用に戻らなければならないということですか？

00:02:33.000 --> 00:02:37.000
もちろんそうではありません。そのための別のアルゴリズムがあります。

00:02:37.000 --> 00:02:39.000
それは「結合」と呼ばれています。

00:02:39.000 --> 00:02:45.000
それが行うことは、すべての内部配列を要素の単一のフラットなコレクションに結合することです。

00:02:45.000 --> 00:02:55.000
このマッピングと結合のパターンは非常に一般的であるため、別の特別な種類のマップを定義します。flatMapです。

00:02:55.000 --> 00:02:59.000
もちろん、地図とフィルターは氷山の一角にすぎません。

00:02:59.000 --> 00:03:03.000
私のアプリのチャット詳細画面から、この生のループを考えてみましょう。

00:03:03.000 --> 00:03:08.000
最新のものから古いものまで、最後の6枚の写真をチャットで表示したいです。

00:03:08.000 --> 00:03:16.000
そのため、トランスクリプトを最新のものから古いものまで逆に反復し、アイテムが写真の場合は、配列に追加します。

00:03:16.000 --> 00:03:19.000
そして、私が6つになったら、私は停止します。

00:03:19.000 --> 00:03:35.000
標準ライブラリ（逆、コンパクトマップ、プレフィックス）のアルゴリズムを連鎖することで、これをより簡潔に表現できます。

00:03:35.000 --> 00:03:42.000
アルゴリズムを連鎖させることで、このコードをより明確に表現するための柔軟性も高まります。

00:03:42.000 --> 00:03:52.000
たとえば、この操作について、逆のトランスクリプトの接頭辞ではなく、トランスクリプトの接尾辞の観点から考える方が自然だと思います。

00:03:52.000 --> 00:03:58.000
したがって、アルゴリズムの連鎖は生のループよりも明確で簡潔ですが、パフォーマンスはどのように比較されますか?

00:03:58.000 --> 00:04:06.000
チェーンの各ステップが中間配列を割り当てる場合、生のループよりも遅くなるのではないでしょうか?

00:04:06.000 --> 00:04:13.000
標準ライブラリがここで巧妙なトリックをしていなかったら、答えはイエスでしょう。

00:04:13.000 --> 00:04:19.000
先ほど見た結合アルゴリズムに戻り、何が起こっているのかを詳しく見てみましょう。

00:04:19.000 --> 00:04:23.000
Joinedは実際にはここで新しい配列を割り当てて返さないことが判明しました。

00:04:23.000 --> 00:04:26.000
代わりに、FlattenSequenceを返します。

00:04:26.000 --> 00:04:30.000
FlattenSequenceは、私たちが「怠惰なアダプター」と呼ぶものです。

00:04:30.000 --> 00:04:37.000
ほとんどの目的のために、それは配列のように機能しますが、それはただの薄いラッパーなので、効果的に自由に作成できます。

00:04:37.000 --> 00:04:43.000
そして、それは怠惰なので、すべての作業を前もって行うのではなく、オンデマンドで要素を処理します。

00:04:43.000 --> 00:04:51.000
FlattenSequenceのような怠惰なアダプターは、アルゴリズムチェーンがループの生で競争力のあるパフォーマンスを持つことを可能にするものです。

00:04:51.000 --> 00:04:59.000
詳細画面に戻り、チャットで最後の6枚の写真を計算するためのアルゴリズムを詳しく見てみましょう。

00:04:59.000 --> 00:05:14.000
接尾辞は実際には配列スライスを返すだけであることがわかります - それは賢いです - そして、その逆は遅延アダプターとしても実装されています。

00:05:14.000 --> 00:05:17.000
コンパクトマップはどうですか?

00:05:17.000 --> 00:05:20.000
それはまだ配列を返しています。それは怠け者ですか?

00:05:20.000 --> 00:05:22.000
できます。

00:05:22.000 --> 00:05:31.000
チェーンの先頭に.lazyを追加するだけで、マップやフィルターなどのクロージャを取るアルゴリズムのいずれかが怠惰になります!

00:05:31.000 --> 00:05:41.000
怠惰なアルゴリズムチェーンは、潜在的に非常に大きなコレクションから少数の要素しか処理していないこのようなユースケースに最適です。

00:05:41.000 --> 00:05:45.000
もちろん、時には配列が必要な場合や必要な場合があります。

00:05:45.000 --> 00:05:50.000
その場合、アルゴリズムチェーンを配列初期化子でいつでもラップできます。

00:05:50.000 --> 00:05:55.000
これは、標準ライブラリチームで、私たちが怠惰なアルゴリズムの大ファンであるもう一つの理由です。

00:05:55.000 --> 00:06:02.000
怠惰なアルゴリズムを熱心な結果に変えるのは本当に簡単ですが、他の道を行くことは不可能です。

00:06:02.000 --> 00:06:08.000
だから私はメッセージングアプリで大きな進歩を遂げており、デザイナーが機能リクエストで私に近づいてきます。

00:06:08.000 --> 00:06:15.000
2つの連続したメッセージの間に1時間以上経過した場合、トランスクリプトにタイムスタンプを含めたいと考えています。

00:06:15.000 --> 00:06:16.000
合理的に思える。

00:06:16.000 --> 00:06:20.000
これには別のアルゴリズムが使えるものがありますよね？

00:06:20.000 --> 00:06:26.000
あります。しかし、それにアクセスするには、Swift Algorithmsパッケージをインポートする必要があります。

00:06:26.000 --> 00:06:33.000
時々、Swift標準ライブラリがまだカバーしていないこのようなユースケースに遭遇するでしょう。

00:06:33.000 --> 00:06:45.000
アルゴリズムパッケージの目的は、あなたの助けを借りて、標準ライブラリに最終的に含めるために、不足しているアルゴリズムの新しいファミリーをインキュベートするために、摩擦の少ない会場を提供することです。

00:06:45.000 --> 00:06:49.000
私たちはすでにSwiftアルゴリズムに40以上のアルゴリズムを追加しました。

00:06:49.000 --> 00:07:07.000
要素のコレクションのすべての組み合わせまたは順列を生成すること、またはシーケンスの要素を2つまたは3つ、または述語によって決定されるグループで反復すること、またはコレクション内の5つの最小要素、5つの最大の要素、または任意の5つをランダムに選択することなど。

00:07:07.000 --> 00:07:13.000
Swiftアルゴリズムに付属する強力な反復ツールのいくつかを詳しく見てみましょう。

00:07:13.000 --> 00:07:20.000
windows(ofCount:)は、コレクションの要素にサイズ3のスライディングウィンドウを提供します。

00:07:20.000 --> 00:07:30.000
ループの各ターンに対して、ウィンドウはベースコレクションのサブシーケンスにすぎません。ここではArraySliceです。これは中間割り当てを回避します。

00:07:30.000 --> 00:07:35.000
ウィンドウ(ofCount:2)は特に一般的であるため、利便性があります。

00:07:35.000 --> 00:07:37.000
それは「adjacentPairs」と呼ばれています。

00:07:37.000 --> 00:07:44.000
adjacentPairsは、サブシーケンスではなくタプルをベンドし、より便利な要素アクセスを可能にします。

00:07:44.000 --> 00:07:49.000
もう1つの強力な反復ツールはチャンク(ofCount:)です。

00:07:49.000 --> 00:07:54.000
ウィンドウとは異なり、チャンクは重ならない。

00:07:54.000 --> 00:08:01.000
コレクションがチャンク数で均等に割り切れない場合、シーケンスの最後のチャンクには残りが含まれます。

00:08:01.000 --> 00:08:07.000
そして、ウィンドウと同様に、チャンクはベースコレクションのサブシーケンスであるため、作成が安価です。

00:08:07.000 --> 00:08:12.000
時には、コレクションをlike-elementsのランにチャンクしたい場合があります。

00:08:12.000 --> 00:08:15.000
ここでは、isPrimeをチャンクしています。

00:08:15.000 --> 00:08:22.000
これは、isPrimeに同じ値を返す連続した要素のチャンクを反復することを意味します。

00:08:22.000 --> 00:08:29.000
便宜上、chunked(on:)は、チャンクとチャンクされる値の両方のタプルをベンドします。

00:08:29.000 --> 00:08:37.000
以前と現在の要素が異なる場合にのみ機能する、このような生のループを書いていることに気づいたことがありますか?

00:08:37.000 --> 00:08:39.000
これはただのチャンクです!

00:08:39.000 --> 00:08:48.000
メッセージの間に1時間以上経過するたびにトランスクリプトにタイムスタンプを含めるように、私のデザイナーからのその機能要求に戻りましょう。

00:08:48.000 --> 00:08:55.000
思い出せば、トランスクリプト項目を作成するために、メッセージの上にフラットマッピングしてトランスクリプトを作成します。

00:08:55.000 --> 00:09:00.000
さて、すべてのトランスクリプト項目は、その日付にアクセスできます。

00:09:00.000 --> 00:09:07.000
日付をチャンクして、トランスクリプト項目をグループ化することができます。

00:09:07.000 --> 00:09:11.000
私たちはすでに、コレクションをような要素のランにチャンクする方法を見てきました。

00:09:11.000 --> 00:09:17.000
スウィフトアルゴリズムには、カスタム述語を提供できるチャンクの別のバリアントが付属しています。

00:09:17.000 --> 00:09:24.000
隣接する要素のペアを渡し、同じグループに属している場合はtrueを返します。

00:09:24.000 --> 00:09:32.000
ここでは、トランスクリプト項目間の時間間隔が1時間未満の場合、trueを返します。

00:09:32.000 --> 00:09:39.000
次に、タイムスタンプを作成し、すべてを1つのフラットコレクションにまとめる必要があります。

00:09:39.000 --> 00:09:44.000
以前、私たちはネストされたコレクションを平らにするために参加していました。

00:09:44.000 --> 00:09:50.000
標準ライブラリには、セパレータを挿入できる結合された別のバリアントが付属しています。

00:09:50.000 --> 00:09:57.000
このアルゴリズムを使用して、新しい行やカンマ区切り文字などと文字列を結合することは本当に一般的です。

00:09:57.000 --> 00:10:02.000
しかし、この場合、一定の区切り文字では不十分です。

00:10:02.000 --> 00:10:09.000
タイムスタンプを構築するには、次のチャンクの最初の日付にアクセスする必要があります。

00:10:09.000 --> 00:10:18.000
さて、アルゴリズムパッケージには、前のチャンクと次のチャンクからセパレータを計算できる結合の別のバリアントが含まれています。

00:10:18.000 --> 00:10:25.000
ここでそれを使用して、タイムスタンプで区切られたトランスクリプトアイテムのチャンクを結合することができます。

00:10:25.000 --> 00:10:28.000
かなり満足しているね？

00:10:28.000 --> 00:10:33.000
もちろん、これらの中間割り当てのいずれにも支払う必要はありません。

00:10:33.000 --> 00:10:38.000
このすべては、.lazyを追加するだけでオンデマンドで計算できます。

00:10:38.000 --> 00:10:40.000
ヴォイラ！

00:10:40.000 --> 00:10:44.000
しかし、怠惰は銀の弾丸ではないことに注意したい。

00:10:44.000 --> 00:10:51.000
シーケンスを1回だけ反復している場合、オンデマンドで計算すると、作業を節約し、割り当てを回避できます。

00:10:51.000 --> 00:11:08.000
しかし、私がメッセージングアプリのトランスクリプトを使用しているように、シーケンスを何度も繰り返しているとき、オンデマンドのコンピューティングは同じ作業を何度も繰り返します。ユーザーが編集モードに入ったり、画像をタップしたり、詳細画面にアクセスしたりするたびに、マッピング、チャンキング、参加します。

00:11:08.000 --> 00:11:11.000
このような場合でも、怠惰なアルゴリズムチェーンを使用する必要があります。

00:11:11.000 --> 00:11:19.000
最後のステップとして、すべてを配列にまとめて作業を保存すると、より効率的になります。

00:11:19.000 --> 00:11:24.000
Swift標準ライブラリとアルゴリズムパッケージから12以上の異なるアルゴリズムを見てきました。

00:11:24.000 --> 00:11:37.000
それらのすべては、配列だけでなく、文字列、およびシーケンスとコレクションプロトコルに準拠した他のすべてのSwiftタイプでも動作します - 新しいSwiftコレクションパッケージのすべてのデータ構造を含みます。

00:11:37.000 --> 00:11:42.000
アルゴリズムを連鎖させることで、コードがより明確で、より速く、より正確になります。

00:11:42.000 --> 00:11:48.000
そして、それに熟達することは複雑ではありません。それはあなたの語彙を構築することです。

00:11:48.000 --> 00:11:58.000
だから、次に生のループを読んだり書いたりしていることに気づいたら、それがマップ、フィルター、またはあなたが今見た他のアルゴリズムの1つであるかどうかを立ち止まって考えてください。

00:11:58.000 --> 00:12:12.000
何も思い浮かばない場合は、シーケンスとコレクションプロトコルに関するドキュメントを検索するか、Swift Algorithms GitHubリポジトリのガイドを読むか、Swiftフォーラムで一緒に解決してください。

00:12:12.000 --> 00:12:17.000
誰が知っている、それはアルゴリズムパッケージへの新しい追加のためのインスピレーションとして役立つかもしれません!

00:12:17.000 --> 00:12:24.000
次に、Karoyは、新しいSwift Collectionsパッケージに付属する汎用性の高いデータ構造について教えます。

00:12:24.000 --> 00:12:25.000
カロイ？

00:12:25.000 --> 00:12:26.000
カロイ・ロレンティ:ありがとう、カイル!

00:12:26.000 --> 00:12:29.000
データ構造について話しましょう。

00:12:29.000 --> 00:12:42.000
今日の現状では、Swift標準ライブラリは、配列、順序なしセット、および順序なし辞書を提供する3つの主要な汎用データ構造のみを実装しています。

00:12:42.000 --> 00:12:51.000
これらは、ユニバーサルコレクションタイプとして素晴らしい選択肢であることが証明されており、モジュールの境界を越えてデータを転送するのに特に最適です。

00:12:51.000 --> 00:13:08.000
それらはすべて、コピーオンライト値のセマンティクスを実装し、効率的なインプレース突然変異操作を提供すると同時に、これらの突然変異なしに収集値が安全に渡され、作成されたコピーの予期しない変更につながることを保証します。

00:13:08.000 --> 00:13:11.000
しかし、そこにはもっと多くのデータ構造があります。

00:13:11.000 --> 00:13:16.000
より多くの選択肢から選択できると便利です。

00:13:16.000 --> 00:13:22.000
今年初め、新しいデータ構造の実装で、Swift Collectionsパッケージをリリースしました。

00:13:22.000 --> 00:13:35.000
このパッケージを使用すると、Swift開発者は、最終的にSwift標準ライブラリに含めることを提案する前に、新しいコレクションタイプで実際の制作経験を積むことができます。

00:13:35.000 --> 00:13:40.000
Swift Collectionsパッケージをインポートすることで、追加のタイプにアクセスできます。

00:13:40.000 --> 00:13:46.000
パッケージの初期バージョンは、最も頻繁に要求される3つのデータ構造を実装しています。

00:13:46.000 --> 00:13:51.000
これらはたまたま3つの標準コレクションタイプの新しいバリエーションです。

00:13:51.000 --> 00:13:59.000
ダブルエンドキュー、OrderedSet、OrderedDictionaryがあります。

00:13:59.000 --> 00:14:08.000
これらは配列、セット、辞書に似ています。それらは同じテーマの変種であり、既存の構造物に新しい機能を追加します。

00:14:08.000 --> 00:14:15.000
とはいえ、これらの新しいタイプは既存のタイプに代わるものではなく、それらを補完するものです。

00:14:15.000 --> 00:14:18.000
一部のユースケースでは、新しいタイプがより適しています。

00:14:18.000 --> 00:14:23.000
しかし、他の多くの人にとって、既存のタイプは引き続き正しい選択です。

00:14:23.000 --> 00:14:30.000
どのデータ構造に到達するかを知るには、これらが既存のタイプとどのように異なるかを学ぶ必要があります。

00:14:30.000 --> 00:14:38.000
では、ダブルエンドのキュー、またはむしろ一般的なキューから始めて、これらのそれぞれを簡単に見てみましょう。

00:14:38.000 --> 00:14:51.000
スーパーマーケットで並んで待っている顧客からアプリケーション内の非同期タスクまで、任意の数のアイテムを1つずつ処理する必要がある場所にキューがポップアップ表示されます。

00:14:51.000 --> 00:15:06.000
最も抽象的な形式では、キューは2つの主要な操作を提供します。アイテムをキューの背面にプッシュし、要素を前面からポップすることができます。

00:15:06.000 --> 00:15:10.000
ダブルエンドキューは、これらのキュー操作を対称にします。

00:15:10.000 --> 00:15:16.000
新しいアイテムをキューの先頭に効率的にプッシュすることをサポートします...

00:15:16.000 --> 00:15:23.000
...背中から要素をポップするだけでなく。

00:15:23.000 --> 00:15:30.000
「ダブルエンドキュー」という名前は、このような便利なタイプにはかなり一口なので、「deque」に短縮したいと思います。

00:15:30.000 --> 00:15:37.000
そして、もう1つの音節を剃るために、これは伝統的にカードのデッキのように「デッキ」と発音されます。

00:15:37.000 --> 00:15:45.000
Collectionsパッケージでは、dequeは使い慣れた配列タイプとほぼ同じAPIを持ち、同じプロトコルの多くを実装しています。

00:15:45.000 --> 00:15:51.000
たとえば、配列リテラルを使用してdequeを作成できます。

00:15:51.000 --> 00:15:54.000
DequeはRandomAccessCollectionプロトコルに準拠しています。

00:15:54.000 --> 00:16:00.000
配列と同様に、dequeはコレクションの開始から測定されたオフセットである整数インデックスを使用します。

00:16:00.000 --> 00:16:04.000
これにより、その位置に基づいて任意の要素に簡単にアクセスできます。

00:16:04.000 --> 00:16:11.000
たとえば、このデクのインデックス1の要素はEの文字です。

00:16:11.000 --> 00:16:17.000
さて、このコレクションの最後にある小文字のfに悩まされているのは私だけではないと確信しています。

00:16:17.000 --> 00:16:28.000
幸いなことに、dequeはMutableCollectionプロトコルに準拠しているため、インデックス2を介して割り当てて、小文字のfを大文字のfに置き換えることでこれを修正できます。

00:16:28.000 --> 00:16:30.000
ああ、それはとても良く見えます!

00:16:30.000 --> 00:16:42.000
DequeはRangeReplaceableCollectionプロトコルも実装しているため、要素のサブレンジを挿入、削除、または置き換えるためのすべての使い慣れた操作を提供します。

00:16:42.000 --> 00:16:50.000
たとえば、インデックスがゼロのinsert(contentsOf:)メソッドを呼び出すことで、dequeの前面にシーケンスを挿入できます。

00:16:50.000 --> 00:16:55.000
これをどのように実行するかは、dequeが配列と異なり始めるところです。

00:16:55.000 --> 00:17:06.000
配列を使用してアイテムを格納する場合、前面に新しい要素を挿入するには、既存の要素を移動して新しい要素のためのスペースを作ることから始める必要があります。

00:17:06.000 --> 00:17:15.000
アクセスをできるだけシンプルにするために、配列はストレージの開始から始めて、要素を単一の連続したバッファに保持します。

00:17:15.000 --> 00:17:30.000
配列が大きい場合、新しい要素のプリセットは比較的高価になります。したがって、前面に新しい要素を挿入するには、すでに配列にある要素の数にほぼ比例する時間がかかります。

00:17:30.000 --> 00:17:32.000
デケの働きは異なります。

00:17:32.000 --> 00:17:41.000
既存の要素を移動せずに新しい要素を付加できるように、ストレージバッファを境界の周りにラップします。

00:17:41.000 --> 00:17:51.000
インデックスはまだコレクションの論理的な開始からオフセットであるため、挿入後、インデックス1の要素はBになります。

00:17:51.000 --> 00:18:03.000
これは、dequesが論理インデックスと実際のストレージ位置の間で翻訳するためにいくつかの作業を行う必要があることを意味しますが、要素へのアクセスはまだ非常に効率的です。

00:18:03.000 --> 00:18:12.000
また、dequeにプリペンドすると、既存のメンバーをスライドさせないため、この操作を配列よりも根本的に高速に実行できます。

00:18:12.000 --> 00:18:20.000
前面に新しい要素を挿入するには、すでにコレクションにいくつの要素があっても、一定の時間がかかります。

00:18:20.000 --> 00:18:23.000
これがデータ構造の力です。

00:18:23.000 --> 00:18:28.000
ツールボックスにそれらがあれば、以前は手の届かない問題を解決するためにそれらを使用することができます。

00:18:28.000 --> 00:18:32.000
適切なデータ構造に切り替えることは、すべての違いを生むことができます。

00:18:32.000 --> 00:18:39.000
それは、使用できないほど遅いアプリを、使うのが楽しいレスポンシブな不思議に変えることができます。

00:18:39.000 --> 00:18:46.000
もちろん、dequesは、ストレージの途中で操作を実行する方法についても賢明です。

00:18:46.000 --> 00:19:00.000
たとえば、要素の範囲を削除する場合、dequeには後続の要素ではなく前の要素を移動して結果のギャップを閉じるオプションがあり、これにより移動する必要がある要素の数を減らすことができます。

00:19:00.000 --> 00:19:10.000
これは、要素をプリペンディングするほど劇的な改善ではありませんが、ランダムに要素を削除すると、平均して2倍の速さになります。

00:19:10.000 --> 00:19:12.000
だから、それはデクです。

00:19:12.000 --> 00:19:17.000
では、注文されたセットを見てみましょう。

00:19:17.000 --> 00:19:23.000
標準の既存のセットタイプは、すべての要素が一意であることを保証するコレクションです。

00:19:23.000 --> 00:19:27.000
しかし、それは彼らの元の注文を保持しません。

00:19:27.000 --> 00:19:33.000
実際、セット内の要素の順序は事実上ランダムです。

00:19:33.000 --> 00:19:43.000
これは、同じセットの2つのインスタンスが、多くの場合、2つのまったく異なる順列でそれらをリストすることを意味します。

00:19:43.000 --> 00:19:51.000
それにもかかわらず、同じ要素を含む2つのセットは等しいと見なされます。順序は重要ではありません。

00:19:51.000 --> 00:19:59.000
これは、私たちが望むすべてが独自性を保証することである場合に素晴らしいことですが、時には要素がどのように順序付けられているかをコントロールしたいこともあります。

00:19:59.000 --> 00:20:11.000
たとえば、ToDoリストアプリを書いている場合は、各項目が一度だけリストされていることを確認したい場合がありますが、ユーザーが設定した特定の順序で保持する必要があります。

00:20:11.000 --> 00:20:14.000
だから、それは注文されたセットが行うことです。

00:20:14.000 --> 00:20:26.000
私たちの視点に応じて、その要素を一意に保つ配列のように機能するか、メンバーに確立した順序を保持するセットとして見ることができます。

00:20:26.000 --> 00:20:32.000
配列やセットと同様に、順序付きセットも配列リテラルで表現できます。

00:20:32.000 --> 00:20:38.000
ただし、セットとは異なり、要素の順序は保存されることが保証されています。

00:20:38.000 --> 00:20:49.000
順序も重要です。2つの順序付けられたセットは、同じメンバーだけでなく、同じ順序でなければならない場合、比較は等しくなります。

00:20:49.000 --> 00:20:57.000
2つの順序付きセットに任意の順序で同じ要素が含まれているかどうかを知る必要がある場合は、特別な順序付けられていないビューでそれらを比較することができます。

00:20:57.000 --> 00:21:05.000
この軽量ビューは要素の順序を無視するので、より従来のセットのようなインターフェイスを提供します。

00:21:05.000 --> 00:21:09.000
しかし、デフォルトでは、順序付けられたセットは配列の仕組みに似ています。

00:21:09.000 --> 00:21:16.000
これは、順序付きセットが整数オフセットインデックスを持つランダムアクセスコレクションであるという事実によって強化されています。

00:21:16.000 --> 00:21:23.000
配列やdequeのように、整数添字を使用してアイテムにアクセスできます。

00:21:23.000 --> 00:21:32.000
セットから予想されるように、要素を追加および削除することもできますが、これらの操作は位置を考慮する必要があります。

00:21:32.000 --> 00:21:40.000
たとえば、まだメンバーでない場合は、セットの末尾に新しい要素を追加する追加操作があります。

00:21:40.000 --> 00:21:48.000
その戻り値は、要素を追加する必要があるかどうかを示し、アイテムのインデックスも報告します。

00:21:48.000 --> 00:21:53.000
また、指定された場所に新しい要素を置く挿入操作もあります。

00:21:53.000 --> 00:22:01.000
この場合、文字Bはすでに存在しているため、操作は単に既存のメンバーのインデックスを返します。

00:22:01.000 --> 00:22:11.000
要素を削除すると、順序付けられたセットに穴が残り、配列のように、残りのメンバーを移動して埋める必要があります。

00:22:11.000 --> 00:22:17.000
注文されたセットは、要素を一意に保つ必要があるため、任意のアイテムの交換をサポートすることはできません。

00:22:17.000 --> 00:22:24.000
これは、配列とは異なり、MutableCollectionまたはRangeReplaceableCollectionプロトコルに準拠できないことを意味します。

00:22:24.000 --> 00:22:32.000
ただし、ソートやシャッフルなどの標準的な並べ替え操作をサポートしています。

00:22:32.000 --> 00:22:42.000
順序付きセットはまた、Order-serving方法で、SetAlgebraプロトコルからのすべての高レベルセット操作を実装します。

00:22:42.000 --> 00:22:51.000
たとえば、ユニオンを形成すると、2番目のセットに表示される順序で、不足している要素が追加されます。

00:22:51.000 --> 00:22:56.000
セットを引くと、残りの要素は元の順序で保持されます。

00:22:56.000 --> 00:23:08.000
順序付けられたセットはほとんどのSetAlgebra演算を実装していますが、要素の順序が重要でなければならないため、そのプロトコルに正式に準拠することはできません。

00:23:08.000 --> 00:23:13.000
しかし、彼らの順序のないビューは、順序に鈍感な平等の概念を持っています。

00:23:13.000 --> 00:23:16.000
したがって、それはSetAlgebraに準拠することができます。

00:23:16.000 --> 00:23:23.000
これを使用して、SetAlgebra値を必要とする関数にOrderedSet値を渡すことができます。

00:23:23.000 --> 00:23:34.000
ボンネットの下を見ると、標準の順序付けられていないセットタイプは、ランダムにシードされたユニバーサルハッシュ関数を使用して、その要素をフラットなハッシュテーブルに直接格納します。

00:23:34.000 --> 00:23:40.000
これは、要素に優れたルックアップパフォーマンスを提供しますが、元の順序を破棄します。

00:23:40.000 --> 00:23:50.000
任意のユーザー指定の要素の順序付けをサポートするために、順序付きセットは代わりにその要素を通常の配列インスタンスに格納します。

00:23:50.000 --> 00:24:01.000
順序付きセットは、同じ高速で安全なハッシュテーブルの実装を使用しますが、この場合、テーブルは整数インデックスをストレージ配列に格納するだけで済みます。

00:24:01.000 --> 00:24:11.000
これらの整数の範囲はハッシュテーブルのサイズによってバインドされているため、整数値をできるだけ少ないビットにパックすることでテーブルを圧縮できます。

00:24:11.000 --> 00:24:22.000
これにより、ほとんどの操作で競争力のあるパフォーマンスを維持しながら、通常のセットと比較してかなりの量のメモリを節約できる場合があります。

00:24:22.000 --> 00:24:25.000
ルックアップのパフォーマンスは標準セットに匹敵します。

00:24:25.000 --> 00:24:31.000
ランダムなメンバーを見つけるには、コレクションのサイズに関係なく、ほぼ一定の時間がかかります。

00:24:31.000 --> 00:24:38.000
配列は各要素を苦労して見る必要があり、コレクションが成長するにつれて時間がかかります。

00:24:38.000 --> 00:24:46.000
順序付きセットに新しい要素を追加すると、標準セットに要素を挿入することとほぼ同じくらい実行されます。

00:24:46.000 --> 00:24:57.000
これはまだ新しい項目をハッシュする必要があり、要素がすでに存在するかどうかのチェックも含まれているので、これは単純な配列に要素を直接追加するよりもはるかに複雑な操作です。

00:24:57.000 --> 00:25:03.000
しかし、コレクションがどんなに大きくなろうとも、これらにはまだ一定の時間がかかります。

00:25:03.000 --> 00:25:15.000
ただし、OrderedSetは既存の要素をすばやく検索して新しい要素を追加できますが、セットの前面または中央にアイテムを削除または挿入することを効率的に実装することはできません。

00:25:15.000 --> 00:25:24.000
配列と同様に、これらの操作はストレージ配列内の要素をスライドさせる必要がありますが、ハッシュテーブルで後続のインデックスに番号を付け直す必要があります。

00:25:24.000 --> 00:25:34.000
これは、削除と挿入が直線的な複雑さを持つ操作に変わり、通常のセットよりも遅くなることを意味します。

00:25:34.000 --> 00:25:36.000
常にトレードオフがあります!

00:25:36.000 --> 00:25:50.000
しかし、これらのデータ構造がどのように機能するかに慣れると、満たす必要がある要件と最適化することが重要な操作に基づいて、問題を解決するための適切なものを自信を持って選択できるようになります。

00:25:50.000 --> 00:25:59.000
適切なデータ構造を選択すると、アルゴリズムの改善につながり、数百倍、さらには数千倍の高速なコードが得られます。

00:25:59.000 --> 00:26:01.000
間違ったものを選択すると、その逆の可能性があります。

00:26:01.000 --> 00:26:10.000
だから、最終的には素晴らしいアプリと幸せなユーザーを生み出すので、これらについて学ぶことは有用だと思います。

00:26:10.000 --> 00:26:16.000
この新しいOrderedSetタイプは、Foundationの既存のNSOrderedSetタイプの純粋なSwiftバリアントです。

00:26:16.000 --> 00:26:22.000
ただし、OrderedSetはパッケージに実装されているため、NSOrderedSetとブリッジしません。

00:26:22.000 --> 00:26:29.000
これは、既存のObjective-C APIが新しいタイプを使用するために自動的にインポートされないことを意味します。

00:26:29.000 --> 00:26:33.000
これらは別々のものです。

00:26:33.000 --> 00:26:42.000
コレクションパッケージによって提供される3番目のデータ構造は、標準辞書タイプの順序付けられたアナログです。

00:26:42.000 --> 00:26:52.000
標準辞書と同様に、これはキーと値のペアのシーケンスで、キーを添字として使用して、対応する値をすばやく検索できます。

00:26:52.000 --> 00:26:57.000
通常の辞書とは異なり、キーと値のペアの順序は明確に定義されています。

00:26:57.000 --> 00:27:03.000
デフォルトでは、キーが最初に挿入された順序に従います。

00:27:03.000 --> 00:27:09.000
新しい要素を追加するには、新しいキーに値を割り当てることができます。

00:27:09.000 --> 00:27:14.000
既存のキーにnilを割り当てることで、要素を削除できます。

00:27:14.000 --> 00:27:23.000
これらの操作を通して、順序付けられた辞書は明確に定義された順序で内容を維持します。

00:27:23.000 --> 00:27:30.000
順序付き辞書は配列のような整数インデックスを使用しますが、これは興味深い問題をもたらします。

00:27:30.000 --> 00:27:37.000
辞書の例では、インデックス付き添字操作はキー添字と競合します。

00:27:37.000 --> 00:27:49.000
ゼロで添字するとき、キーゼロの値にアクセスすることを意味しますか、それともオフセットゼロでキーと値のペアを取得することを意味しますか?

00:27:49.000 --> 00:28:00.000
キーベースの添字は辞書型の主な操作であると思うので、このあいまいさを防ぐために、順序付けられた辞書を添字することは、常にキーイング添字を意味します。

00:28:00.000 --> 00:28:06.000
OrderedDictionaryは、インデックス付き添字操作をまったく提供していません。

00:28:06.000 --> 00:28:14.000
これは、コレクションプロトコルにはそのような添字が必要なため、OrderedDictionaryはコレクションにできないことを意味します。

00:28:14.000 --> 00:28:19.000
したがって、OrderedDictionaryはシーケンスプロトコルにのみ準拠します。

00:28:19.000 --> 00:28:27.000
ただし、コレクションの適合性が望ましい場合、OrderedDictionaryは特別な要素ビューを提供します。

00:28:27.000 --> 00:28:35.000
要素は、キーと値のペアを返すインデックス付き添字を提供するランダムアクセスコレクションです。

00:28:35.000 --> 00:28:52.000
基礎となる実装を見ると、通常の辞書タイプはそれぞれキーと値を格納するために2つの別々のハッシュテーブルを使用しますが、順序付けられた辞書は代わりに単一の圧縮ハッシュテーブルと2つの並列配列を使用します。

00:28:52.000 --> 00:28:56.000
これにより、注文されたセットよりもさらに多くのスペースを節約できます。

00:28:56.000 --> 00:29:01.000
したがって、これらはコレクションパッケージで利用可能な3つの新しいデータ構造です。

00:29:01.000 --> 00:29:17.000
これらの構造を使用することで、アプリのパフォーマンスを向上させたり、メモリ使用量を減らしたり、同様に重要なことに、セット内の要素の順序を保持するなど、標準タイプで簡単に満たすことができなかった制約を表現することができます。

00:29:17.000 --> 00:29:30.000
これらの新しいタイプはすべていくつかのシーケンスとコレクションプロトコルに準拠しているため、標準ライブラリが提供するアルゴリズムや、カイルが以前に示した新しいアルゴリズムパッケージとも相互運用します。

00:29:30.000 --> 00:29:38.000
スウィフトコレクションとスウィフトアルゴリズムは、増え続けるオープンソースパッケージのリストの新しいメンバーの2つにすぎません。

00:29:38.000 --> 00:29:45.000
Swiftライブラリエコシステムの未来は、新しいプラットフォームや新しいドメインに参入するにつれて、今形成されています。

00:29:45.000 --> 00:29:51.000
そして、オープンソースパッケージをますます活用するにつれて、これは目に見えるように行われています。

00:29:51.000 --> 00:30:01.000
これらのパッケージはまだ柔軟でありながら、意図的に早期にリリースしており、GitHubでのコミュニティの取り組みとして開発しています。

00:30:01.000 --> 00:30:02.000
だから、それらを試してみてください。

00:30:02.000 --> 00:30:05.000
問題を提出してください。プルリクエストを開きます。

00:30:05.000 --> 00:30:11.000
かつてないほど良い時期であり、関与して影響を与えることがかつてないほど簡単になりました。

00:30:11.000 --> 00:30:16.000
私たちと同じように、これらの新しいSwiftパッケージに興奮していることを願っています。

00:30:16.000 --> 00:30:19.000
あなたがこれらで何を作るかを見るのが待ちきれません!

00:30:19.000 --> 00:30:23.000
見てくれてありがとう、そして会議の残りを楽しんでください!

00:30:23.000 --> 23:59:59.000
♪

