WEBVTT

00:00:02.000 --> 00:00:12.000
こんにちは、私の名前はトニーで、ファウンデーションチームのエンジニアです。

00:00:12.000 --> 00:00:19.000
「ファンデーションの新機能」へようこそ。Foundationフレームワークは、すべてのアプリとフレームワークの基本機能を提供します。

00:00:19.000 --> 00:00:25.000
ファイル処理からネットワーキングや通知まで、さまざまな機能を備えています。

00:00:25.000 --> 00:00:31.000
今日は、すべてのアプリが必要とするもの、つまり国際化とローカリゼーションに焦点を当てたいと思います。

00:00:31.000 --> 00:00:36.000
今年のリリースでは、このAPI史上最大の進歩を遂げています。

00:00:36.000 --> 00:00:43.000
私たちは低いレベルから始めて、Swiftの帰属文字列が何であるかを再考しました。

00:00:43.000 --> 00:00:50.000
Swift用のフォーマッタを再構築し、より速く、使いやすくし、新機能を追加しました。

00:00:50.000 --> 00:00:55.000
そして最後に、自動文法契約と呼ばれるまったく新しい機能があります。

00:00:55.000 --> 00:01:02.000
提供する必要があるローカライズされた文字列の数を劇的に減らし、同時にコードをよりシンプルにします。

00:01:02.000 --> 00:01:05.000
帰属文字列に飛び込みましょう。

00:01:05.000 --> 00:01:12.000
帰属文字列は、文字、範囲のセット、および辞書の組み合わせです。

00:01:12.000 --> 00:01:20.000
属性文字列を使用すると、キーと値のペアである属性を文字列の特定の範囲に関連付けることができます。

00:01:20.000 --> 00:01:25.000
最も一般的な属性はSDKによって定義されていますが、独自の属性を作成することもできます。

00:01:25.000 --> 00:01:30.000
リッチテキストをサポートするAPIには、アトリビュートの文字列がよくあります。

00:01:30.000 --> 00:01:32.000
例を見てみましょう。 例を見てみましょう。

00:01:32.000 --> 00:01:34.000
これは私が取り組んでいるCafféというアプリです。

00:01:34.000 --> 00:01:36.000
シンプルなメニューです。

00:01:36.000 --> 00:01:42.000
私は欲しい食べ物、サイズ、量を選びます。

00:01:42.000 --> 00:01:47.000
そして最後に、私が注文したすべてのもののリストが入った領収書が表示されます。

00:01:47.000 --> 00:01:52.000
ここの一番下に、短いお礼状を追加することにしました。

00:01:52.000 --> 00:01:54.000
これは帰属文字列です。

00:01:54.000 --> 00:01:58.000
文字列の一部は太字で、一部はイタリック体です。

00:01:58.000 --> 00:02:00.000
最後の言葉にもリンクがあります。

00:02:00.000 --> 00:02:04.000
ここでわかるように、属性は重なる可能性があります。

00:02:04.000 --> 00:02:09.000
Foundationの開始以来、NSAttributedStringという参照型がありました。

00:02:09.000 --> 00:02:17.000
今年は、Swiftが提供するすべての機能を最大限に活用する新しい構造体AttributedStringを導入します。

00:02:17.000 --> 00:02:21.000
まず第一に、それは値タイプです。

00:02:21.000 --> 00:02:26.000
また、Swift Stringと同じ文字カウント動作もあります。

00:02:26.000 --> 00:02:34.000
包括的なソフトウェアを簡単に作成するための取り組みの一環として、AttributedStringは完全にローカライズ可能になりました。

00:02:34.000 --> 00:02:37.000
最後に、それは安全とセキュリティを念頭に置いて構築されています。

00:02:37.000 --> 00:02:45.000
これには、強力なタイピングを使用したコンパイル時の安全性と、Codableを使用したアーカイブ解除時の安全性の両方が含まれます。

00:02:45.000 --> 00:02:51.000
新しいAttributedStringで何ができるかを簡単に見てみましょう。 AttributedString

00:02:51.000 --> 00:02:54.000
私たちは感謝のメッセージを作るつもりです。ありがとう。

00:02:54.000 --> 00:02:58.000
まず、単純な初期化子を使用して属性文字列を作成します。

00:02:58.000 --> 00:03:01.000
この文字列全体に属性を設定したい。

00:03:01.000 --> 00:03:03.000
それはフォントプロパティを設定するのと同じくらい簡単です。

00:03:03.000 --> 00:03:10.000
Struct AttributedStringでは、すべての属性が直接利用可能で、正しい型を使用します。

00:03:10.000 --> 00:03:14.000
たとえば、このプロパティはSwiftUIフォントです。

00:03:14.000 --> 00:03:17.000
次に、別の属性文字列を作成します。

00:03:17.000 --> 00:03:23.000
これは当社のウェブサイトへの参照なので、リンクプロパティをURLに設定しました。

00:03:23.000 --> 00:03:26.000
ここでは、文字列全体にフォントとリンクを設定しています。

00:03:26.000 --> 00:03:30.000
後で文字列の一部だけを変更する方法を見ていきます。

00:03:30.000 --> 00:03:33.000
もう1つの便利なツールは、属性コンテナです。

00:03:33.000 --> 00:03:38.000
文字列なしで属性と値を単独で保持できる場所です。

00:03:38.000 --> 00:03:44.000
ここでは、メッセージの重要性に応じて、コンテナを作成し、その上にいくつかの属性を設定します。

00:03:44.000 --> 00:03:49.000
そして最後に、これらの属性を両方の属性文字列にマージします。

00:03:49.000 --> 00:03:55.000
前述したように、帰属文字列は文字、範囲、辞書の組み合わせです。

00:03:55.000 --> 00:03:59.000
帰属文字列自体は、それらの単一のもののコレクションではありません。

00:03:59.000 --> 00:04:05.000
代わりに、これらのプロパティにアクセスするために、ビューと呼ばれるものがあります。

00:04:05.000 --> 00:04:12.000
2つの最も重要なビューは、文字列へのアクセスを提供する文字と、属性へのアクセスを提供する実行です。

00:04:12.000 --> 00:04:20.000
これらのビューはSwiftコレクションです。つまり、Arrayのようなタイプから慣れ親しんだ関数もここで利用できます。

00:04:20.000 --> 00:04:23.000
別の例を見てみましょう。

00:04:23.000 --> 00:04:30.000
私たちのデザイナーが、すべての句読点を楽しいオレンジ色にすることで、感謝のメッセージに少しピザを追加するように言ったとしましょう。

00:04:30.000 --> 00:04:35.000
これを行うには、まず、属性文字列の句読点がどこにあるかを見つける必要があります。

00:04:35.000 --> 00:04:43.000
他のSwiftコレクションと同様に、帰属文字列ビューは、単にコレクション内のいくつかの要素の位置であるインデックスを使用します。

00:04:43.000 --> 00:04:48.000
インデックスで反復するには、標準のライブラリインデックス関数を使用します。

00:04:48.000 --> 00:04:55.000
次に、isPunctuation関数を使用して、この文字が変更する必要があるかどうかを確認します。

00:04:55.000 --> 00:05:02.000
最後に、帰属文字列の別の機能であるスライスを使用して、文字列全体のサブレンジのみに属性を適用します。

00:05:02.000 --> 00:05:09.000
範囲はこのインデックスから始まり、その後の次のインデックスまで続くので、1文字です。

00:05:09.000 --> 00:05:11.000
そして今、句読点はオレンジ色です。

00:05:11.000 --> 00:05:13.000
別のビューを見てみましょう、実行します。

00:05:13.000 --> 00:05:19.000
実行は、特定の属性の開始場所、長さ、および値です。

00:05:19.000 --> 00:05:22.000
メッセージのすべてのランを数えることから始めることができます。

00:05:22.000 --> 00:05:26.000
これにより、文字列内の属性値の連続した範囲が反復されます。

00:05:26.000 --> 00:05:29.000
この文字列には4つのランがあります。

00:05:29.000 --> 00:05:32.000
各実行には、各属性の値またはnilがあります。

00:05:32.000 --> 00:05:40.000
文字と実行の範囲は交換可能なので、属性またはその逆の文字列を見つけることができます。

00:05:40.000 --> 00:05:48.000
ここでは、文字ビューの添字の属性の範囲を使用し、結果をスタンドアロンの文字列に変換します。

00:05:48.000 --> 00:05:53.000
多くの場合、特定の属性に焦点を当てて実行を見ることが最も有用です。

00:05:53.000 --> 00:05:58.000
ここでは、キーパスリンクを使用して、リンク属性のみを合体させます。

00:05:58.000 --> 00:06:07.000
結果のコレクションの各要素は、文字列に設定される可能性のある他の属性を考慮せず、リンク属性の値を提供します。

00:06:07.000 --> 00:06:19.000
リンクだけを見ると、3つのランがあります。1つ目は設定されていない、2つ目は値に設定されています。3つ目は、文の最後のピリオドで、再度設定されていません。

00:06:19.000 --> 00:06:23.000
実行を反復すると、値と範囲のタプルが得られます。

00:06:23.000 --> 00:06:32.000
値はタイプセーフであるため、間違ったタイプをキャストしたり心配したりすることなく、URLに存在するスキームのようなAPIを使用できます。

00:06:32.000 --> 00:06:37.000
ここでは、帰属文字列内のすべてのリンクがhttpsであることを確認しています。

00:06:37.000 --> 00:06:43.000
もう1つの便利なテクニックは、部分文字列を探し、その範囲を使用して文字や属性を編集することです。

00:06:43.000 --> 00:06:48.000
「訪問」という言葉をより後退の雰囲気を持つものに置き換えたいとしましょう。

00:06:48.000 --> 00:06:51.000
まず、部分文字列の範囲を探します。

00:06:51.000 --> 00:06:58.000
次に、その範囲を使用して、そのサブ範囲のみに属性と文字を設定します。

00:06:58.000 --> 00:07:02.000
結果は、このように6回の実行を持つアトリビュートリビュートリス文字列です。

00:07:02.000 --> 00:07:05.000
次に、ローカリゼーションについて話しましょう。

00:07:05.000 --> 00:07:08.000
AttributedStringは完全にローカライズ可能です。

00:07:08.000 --> 00:07:12.000
また、Objective-CのNSAttributedStringにローカリゼーションサポートを追加しました。

00:07:12.000 --> 00:07:18.000
属性文字列は、通常の文字列と同じように、アプリの文字列ファイルにあります。

00:07:18.000 --> 00:07:27.000
Swiftでは、SwiftUIのテキストビューと同様に、文字列補間を使用して、StringとAttributedStringのローカライズされた書式設定をサポートするようになりました。

00:07:27.000 --> 00:07:29.000
これは簡単な例です。

00:07:29.000 --> 00:07:35.000
この関数は、ユーザーのドキュメント名でカスタマイズされたローカライズされた文字列を返します。

00:07:35.000 --> 00:07:44.000
%@ や %d などの書式指定子を使用して書式関数を呼び出す代わりに、値を直接入力できるようになりました。

00:07:44.000 --> 00:07:49.000
同じアプローチがAttributedStringにも有効です。

00:07:49.000 --> 00:07:53.000
Xcodeは、コンパイラを使用して、これらの新しい初期化子から文字列ファイルを生成できます。

00:07:53.000 --> 00:08:02.000
オンにするには、ビルド設定に移動し、ローカリゼーション設定を探し、「コンパイラを使用してSwift文字列を抽出する」をオンにします。

00:08:02.000 --> 00:08:06.000
ローカライズされた帰属文字列がどのようにその属性を取得するのか疑問に思うかもしれません。

00:08:06.000 --> 00:08:10.000
AttributedStringにMarkdownのサポートを追加したことをお伝えできることを嬉しく思います。

00:08:10.000 --> 00:08:15.000
SwiftUIテキストで、ローカライズされた属性文字列を使用する例を次に示します。

00:08:15.000 --> 00:08:18.000
私は普通のひもから始めます。

00:08:18.000 --> 00:08:25.000
テキストの周りに2つのアスタリスクを追加することで、SwiftUIが太字としてレンダリングすることを強調します。

00:08:25.000 --> 00:08:32.000
アンダースコアを使用してテキストを強調することができ、SwiftUIはイタリック体としてレンダリングします。

00:08:32.000 --> 00:08:34.000
リンクもサポートしています。

00:08:34.000 --> 00:08:41.000
これは、ローカライザーがさまざまな言語にカスタマイズされたURLを提供する絶好の機会です。

00:08:41.000 --> 00:08:45.000
また、取り消し線やコードボイスなどの他のインラインスタイルもサポートしています。

00:08:45.000 --> 00:08:49.000
最後に、帰属文字列のアーカイブについて話しましょう。

00:08:49.000 --> 00:08:55.000
まず、NSAttributedString参照タイプとの間で変換する機能が必要です。

00:08:55.000 --> 00:09:01.000
アトリビュート文字列はデータモデルの一部になることができます。つまり、それらをエンコードおよびデコードできる必要があります。

00:09:01.000 --> 00:09:06.000
最後に、Markdownでカスタム属性を指定する方法が必要です。

00:09:06.000 --> 00:09:08.000
これらの操作はすべて相互に関連しています。

00:09:08.000 --> 00:09:12.000
コンバージョンを見ることから始めましょう。

00:09:12.000 --> 00:09:20.000
私たちは皆、NSAttributedStringを使用する多くのコードを書いたので、構造体からクラスタイプへの変換を簡単にしました。

00:09:20.000 --> 00:09:24.000
NSAttributedStringプロパティを持つビューを次に示します。

00:09:24.000 --> 00:09:30.000
変換するには、構造体AttributedStringをNSAttributedString初期化子に渡すだけです。

00:09:30.000 --> 00:09:35.000
SDKの一部である属性については、私がする必要があるのはこれだけです。

00:09:35.000 --> 00:09:38.000
では、エンコードとデコードを見てみましょう。

00:09:38.000 --> 00:09:41.000
これは、Cafféアプリからの領収書を保持する構造体です。

00:09:41.000 --> 00:09:48.000
繰り返しになりますが、SwiftUI、UIKit、AppKit、Foundationが提供する属性を使用しています。

00:09:48.000 --> 00:09:53.000
つまり、AttributedStringのデフォルトのCodable実装は、私が必要とするすべてです。

00:09:53.000 --> 00:09:58.000
領収書にコード可能な適合性を追加するだけで、完了です。

00:09:58.000 --> 00:10:02.000
もう少し進んで、カスタム属性をエンコードするためのサポートを追加しましょう。

00:10:02.000 --> 00:10:05.000
属性自体について話すことから始めます。

00:10:05.000 --> 00:10:09.000
属性は、キーと値の2つの部分です。

00:10:09.000 --> 00:10:13.000
キーは、新しいAttributedStringKeyプロトコルに準拠したタイプです。

00:10:13.000 --> 00:10:19.000
これは、必要な値の種類とアーカイブの名前を定義します。

00:10:19.000 --> 00:10:25.000
このキーは、値のエンコードまたはデコード方法をカスタマイズするために、他のプロトコルに準拠することもできます。

00:10:25.000 --> 00:10:30.000
余分な色を持つために、帰属文字列の範囲を定義したいとしましょう。

00:10:30.000 --> 00:10:35.000
このレインボーエフェクトには、プレーン、ファン、エクストリームの3つのレベルがあります。

00:10:35.000 --> 00:10:41.000
列挙型を使用してその値を表し、名前をレインボーに設定します。

00:10:41.000 --> 00:10:47.000
タイプと名前を定義することは、このプロトコルの唯一の要件です。

00:10:47.000 --> 00:10:53.000
さて、この属性をコード可能にし、エンコードされた属性文字列の一部にしたいとしましょう。

00:10:53.000 --> 00:10:57.000
私がしなければならないのは、このようにCodableコンフォーマンスを追加することだけです。

00:10:57.000 --> 00:11:02.000
最後に、レインボーレベルをローカライズされた文字列の一部にしたいとしましょう。

00:11:02.000 --> 00:11:08.000
つまり、それがどこにいても、どの言語でも、文字列の正しい部分に適用できることを意味します。

00:11:08.000 --> 00:11:14.000
必要なのは、オプトインするためのもう1つのプロトコル適合だけです。

00:11:14.000 --> 00:11:22.000
属性がMarkdown decodableであると言うと、Markdownから直接デコードし、アトリビュート文字列に挿入できます。

00:11:22.000 --> 00:11:25.000
必要なのは、値がコード可能であることだけです。

00:11:25.000 --> 00:11:29.000
次に、Markdownのカスタム属性構文を見てみましょう。

00:11:29.000 --> 00:11:32.000
この最初の例では、リンクへの参照があります。

00:11:32.000 --> 00:11:39.000
リンクテキストには角括弧を使用し、リンク先であるURLには括弧を使用します。

00:11:39.000 --> 00:11:42.000
この2番目の例では、画像への参照があります。

00:11:42.000 --> 00:11:50.000
感嘆符で始まり、画像の説明には角括弧を使用し、画像ソースには括弧を使用します。

00:11:50.000 --> 00:11:53.000
これらの最初の2つの例は、Markdownで一般的です。

00:11:53.000 --> 00:11:57.000
3番目の例は、カスタム属性の構文を示しています。

00:11:57.000 --> 00:12:03.000
キャレットから始まり、テキストには角括弧を使用し、属性には括弧を使用します。

00:12:03.000 --> 00:12:06.000
属性はJSON 5で表されます。

00:12:06.000 --> 00:12:13.000
JSON 5はJSONと互換性があり、引用符で囲まれていないキー、コメント、その他いくつかの機能を可能にします。

00:12:13.000 --> 00:12:17.000
このような人間に優しいひもにぴったりです。

00:12:17.000 --> 00:12:22.000
また、Foundationの他のJSON APIにJSON 5のサポートを追加しました。

00:12:22.000 --> 00:12:31.000
カスタム属性はJSONを使用するため、JSONDecoderでデコードできるものはすべて、新しいカスタムMarkdown構文と自動的に互換性があります。

00:12:31.000 --> 00:12:39.000
ここでは、単一の属性、2つの属性、1つの文字列と1つの数値、および複数のプロパティを持つ単一の属性があります。

00:12:39.000 --> 00:12:45.000
ここには1つの追加部分があります。これは、Markdownでこれらの名前をSwiftタイプに結びつける方法です。

00:12:45.000 --> 00:12:47.000
その作品は属性スコープと呼ばれます。

00:12:47.000 --> 00:12:50.000
スコープは属性キーのグループです。

00:12:50.000 --> 00:13:00.000
スコープは、どの属性、名前、およびそれらをデコードする方法を教えてくれるため、JSONまたはMarkdownからデコードするときに便利です。

00:13:00.000 --> 00:13:06.000
Foundation、UIKit、AppKit、SwiftUIのスコープをそれぞれ1つずつ定義します。

00:13:06.000 --> 00:13:10.000
独自の属性の範囲を定義することもできます。

00:13:10.000 --> 00:13:13.000
Cafféアプリの範囲を定義しましょう。

00:13:13.000 --> 00:13:19.000
AttributeScopes内にスコープをネストし、AttributeScopeプロトコルに準拠します。

00:13:19.000 --> 00:13:28.000
次に、スコープ内の属性を「let」でリストアップするだけです。これまでのところ、私たちは虹の属性だけを持っています。

00:13:28.000 --> 00:13:32.000
次に、SwiftUIスコープを私たちの中に含めます。

00:13:32.000 --> 00:13:36.000
それは私たち自身のものに加えて、それらの属性のすべてを可能にします。

00:13:36.000 --> 00:13:40.000
スコープは再帰的にネストされるため、これにはFoundation属性も含まれます。

00:13:40.000 --> 00:13:43.000
新しいスコープのプロパティを定義すると便利です。

00:13:43.000 --> 00:13:48.000
これにより、スコープを引数として取る関数でキーパス構文を使用できます。

00:13:48.000 --> 00:13:54.000
最後に、カスタムMarkdownからローカライズされたカラフルな属性文字列をロードできるようになりました。

00:13:54.000 --> 00:14:00.000
また、NSAttributedStringとの間のアーカイブと変換のためのスコープ取得関数もあります。

00:14:00.000 --> 00:14:04.000
これにより、すべてのステップで動作をカスタマイズできます。

00:14:04.000 --> 00:14:10.000
これは再びCafféアプリの最初の画面で、タイトルにカスタムレインボー属性を見ることができます。

00:14:10.000 --> 00:14:21.000
ローカライズされた文字列がMarkdownからアトリビュート文字列に変換された後、アプリは属性を見つけ、文字列のちょうどその範囲に楽しい効果を適用します。

00:14:21.000 --> 00:14:29.000
この属性はローカライズされた文字列ファイルから来ているため、スペイン語など、Cafféがサポートするすべての言語で正しく機能します。

00:14:29.000 --> 00:14:31.000
しかし、私たちはまだ始まったばかりです。

00:14:31.000 --> 00:14:35.000
また、まったく新しいフォーマッタAPIもあります。

00:14:35.000 --> 00:14:38.000
フォーマッタは、もう1つの長年のFoundation機能です。

00:14:38.000 --> 00:14:47.000
彼らは、数字、日付、時刻などのデータを取り、ローカライズされたユーザーが提示可能な文字列に変換する責任があります。

00:14:47.000 --> 00:14:54.000
フォーマッタは、かなりの構成データによって裏打ちされているため、それらをキャッシュして再利用するのは一般的なパターンです。

00:14:54.000 --> 00:14:57.000
しかし、アプリは多くの異なるコードで構成されています。

00:14:57.000 --> 00:15:02.000
それらすべての間でフォーマッタを共有することは必ずしも理にかなっているとは限りません。

00:15:02.000 --> 00:15:14.000
また、人々が日付と時刻を読む多種多様な方法に加えて、私たちのデザインに合った方法でこのデータを提示したいというアプリの作者としての私たちの願望のために、エッジケースのための多くの機会があります。

00:15:14.000 --> 00:15:21.000
今年は、Formatter APIを一から再考することで、パフォーマンスと使いやすさの両方を改善しました。

00:15:21.000 --> 00:15:25.000
要するに、私たちの新しいAPIはフォーマットに焦点を当てています。

00:15:25.000 --> 00:15:31.000
地震のサンプルアプリからこのコードを見てみましょう。そこでは、キャッシュパターンの動作を見ることができます。

00:15:31.000 --> 00:15:34.000
それは2段階のプロセスを持っています。

00:15:34.000 --> 00:15:37.000
まず、フォーマッタを作成して設定します。

00:15:37.000 --> 00:15:41.000
次に、フォーマッタに日付を与え、文字列を取得します。

00:15:41.000 --> 00:15:43.000
どうやればもっと簡単になるの？

00:15:43.000 --> 00:15:47.000
さて、独自の日付フォーマッタを作成する要件を削除することから始めましょう。

00:15:47.000 --> 00:15:54.000
これをキャッシュする必要があることを忘れるのは本当に簡単でした。これにより、テーブル内のすべてのセルに対して同じフォーマッタを再作成することになりました。

00:15:54.000 --> 00:15:56.000
次に、書式設定のステップ。

00:15:56.000 --> 00:16:01.000
日付をフォーマッタに渡す代わりに、日付自体を使いましょう。

00:16:01.000 --> 00:16:03.000
今はたった1行のコードです。

00:16:03.000 --> 00:16:07.000
必要なフォーマットを指定すれば、それだけです。

00:16:07.000 --> 00:16:10.000
この数字の形式についてもっと話しましょう。

00:16:10.000 --> 00:16:15.000
それは多くのコードではありませんが、いくつかの複雑さを隠しており、注意すべきいくつかの落とし穴があります。

00:16:15.000 --> 00:16:21.000
引数が浮動小数点数でない場合は、ここで完全に間違った出力を取得します。

00:16:21.000 --> 00:16:30.000
読者は、浮動小数点数をフォーマットするための特殊なケースの構文と、単なる文字列定数である修飾子のセットを認識する必要があります。

00:16:30.000 --> 00:16:35.000
このコードは理解しやすく、維持しやすく、読みやすいと思います。

00:16:35.000 --> 00:16:40.000
通常のSwift関数を使用して、番号のフォーマット方法を正確に指定します。

00:16:40.000 --> 00:16:44.000
また、オートコンプリートとタイプの安全性も得ます。

00:16:44.000 --> 00:16:48.000
この新しいアプローチをFoundationの10人のフォーマッタすべてに適用しました。

00:16:48.000 --> 00:16:57.000
インターフェイスをクリーンアップして簡素化し、一般的な落とし穴を避けるために変更を加え、途中で多くの新機能を追加しました。

00:16:57.000 --> 00:17:04.000
最も一般的なフォーマットされたタイプの2つ、日付と数字を詳しく見てみましょう。

00:17:04.000 --> 00:17:13.000
日付の書式設定は、カレンダーとタイムゾーンを使用して、絶対的な時点を人間が日付として理解するものに変換することです。

00:17:13.000 --> 00:17:20.000
そしてそれ以上に、それは人間が自分の日付がどのように見えるかについて持っているすべての好みを考慮に入れています。

00:17:20.000 --> 00:17:23.000
私たちはそれらの好みをロケールと呼んでいます。

00:17:23.000 --> 00:17:28.000
日付をフォーマットするために必要な少量のコードを見てみましょう。 日付をフォーマットする必要があります。

00:17:28.000 --> 00:17:33.000
まず、Date.nowを使用して現在の時点を取得します。

00:17:33.000 --> 00:17:35.000
次に、フォーマットされた関数を呼び出します。

00:17:35.000 --> 00:17:37.000
それでおそれ。

00:17:37.000 --> 00:17:42.000
もちろん、先ほど例で見たように、日付の書式設定には多くのオプションがあります。

00:17:42.000 --> 00:17:45.000
だから、これを少し広げましょう。

00:17:45.000 --> 00:17:51.000
フォーマットされた関数は、日付または時刻のみを表示するように設定できます。

00:17:51.000 --> 00:17:55.000
これらの議論の両方には、いくつかの選択肢があります。

00:17:55.000 --> 00:18:03.000
この新しい書式設定APIの重要な目標は、正しい書式を作成する際にできるだけ多くのコンパイル時間のヘルプを提供することです。

00:18:03.000 --> 00:18:16.000
魔法の文字列値を使用したフォーマットは、通常の状況下ではフォーマットが正しく見えますが、年末のようなエッジケースで完全に間違った値を生成する落とし穴を作成することで悪名高いです。

00:18:16.000 --> 00:18:19.000
ここでもデフォルトのフォーマットです。

00:18:19.000 --> 00:18:24.000
これは、このような日付と時刻のスタイルを尋ねる短いバージョンです。

00:18:24.000 --> 00:18:29.000
議論のないバージョンとシンプルなスタイルのバージョンの両方で、デフォルトのフォーマットを選択します。

00:18:29.000 --> 00:18:36.000
ただし、日付を本当にカスタマイズしたい場合は、ここから関心のあるフィールドを追加するだけです。

00:18:36.000 --> 00:18:41.000
この例では、スタイルにフィールドを追加してフォーマットを構築します。

00:18:41.000 --> 00:18:45.000
私は年、日、月だけが欲しい。

00:18:45.000 --> 00:18:49.000
その他の可能性には、時間、分、秒などが含まれます。

00:18:49.000 --> 00:18:55.000
出力形式は、ユーザーのロケールに応じて自動的に調整されます。

00:18:55.000 --> 00:18:57.000
これらのフィールドも設定可能です。

00:18:57.000 --> 00:19:04.000
この場合、月をワイドフォーマットに変更します。つまり、完全な月名が印刷されます。

00:19:04.000 --> 00:19:08.000
日付の一部だけをフォーマットすることは、このAPIでも簡単です。

00:19:08.000 --> 00:19:10.000
ここで私は平日だけを手に入れたいです。

00:19:10.000 --> 00:19:13.000
日付はさまざまなスタイルにフォーマットすることもできます。

00:19:13.000 --> 00:19:24.000
ここでは、ISO 8601形式とiso8601を使用することを選択しますが、年、月、日のみを使用し、ダッシュで区切られています。

00:19:24.000 --> 00:19:28.000
これらの例では、書式設定パターンが明確になります。

00:19:28.000 --> 00:19:30.000
フォーマットしたい値から始めます。

00:19:30.000 --> 00:19:35.000
フォーマットされた関数を呼び出し、引数はスタイルです。

00:19:35.000 --> 00:19:38.000
タイプごとに複数の種類のスタイルがあるかもしれません。

00:19:38.000 --> 00:19:42.000
たとえば、DateにはdateTimeとiso8601の両方があります。

00:19:42.000 --> 00:19:47.000
スタイルは、デフォルト設定で使用することも、カスタマイズすることもできます。

00:19:47.000 --> 00:19:54.000
この書式設定APIは、フィールドのリストを指定することで機能し、そのうちのいくつかには追加のオプションがあります。

00:19:54.000 --> 00:19:57.000
提供するフィールドの順序は関係ありません。

00:19:57.000 --> 00:20:04.000
各フィールドは、最終出力のどこかにどの値を含めるべきかをフォーマッタに伝えるだけです。

00:20:04.000 --> 00:20:11.000
引数がない、またはスタイル名のみのAPIの最短バージョンの賢明なデフォルトを選択します。

00:20:11.000 --> 00:20:22.000
フィールドの追加を開始すると、出力はカスタマイズされ、UIのプレースホルダテキストのように、表示することを選択したものだけを反映します。

00:20:22.000 --> 00:20:26.000
また、互いに相対的な2つの日付をフォーマットするための新しいAPIもあります。

00:20:26.000 --> 00:20:29.000
ここにいくつかの例があります。

00:20:29.000 --> 00:20:32.000
まず、範囲内の2つの日付をフォーマットします。

00:20:32.000 --> 00:20:38.000
2つの日付で通常のSwift範囲構文を使用できます。

00:20:38.000 --> 00:20:45.000
書式設定範囲では、単一の日付で行ったのと同じように、日付と時刻の表示を設定できます。

00:20:45.000 --> 00:20:53.000
この範囲は、期間、コンポーネント、または現在に対する単一の日付としてフォーマットできます。

00:20:53.000 --> 00:20:56.000
書式設定のもう1つの新機能は、出力です。

00:20:56.000 --> 00:21:05.000
これにより、ユーザーの好みに合わせて再配置した後、フォーマッタがフォーマットされた値の特定の部分を置いた場所を見つけることができます。

00:21:05.000 --> 00:21:09.000
もちろん、これは新しい構造体AttributedStringを使用します。

00:21:09.000 --> 00:21:13.000
フォーマットされた出力にスタイリングを適用すると、あらゆる種類の場所に表示されます。

00:21:13.000 --> 00:21:17.000
watchOSでは、コンプリケーションの多くはフォーマットされた文字列です。

00:21:17.000 --> 00:21:30.000
Apple Watchはそのような個人的なデバイスであるため、ユーザーの好みを考慮に入れることが重要ですが、日付の一部にユーザーが選択した色を与えるなど、特定の種類のデザイン言語を適用したい場所でもあります。

00:21:30.000 --> 00:21:34.000
これを設定することは、実際にはSwiftUIではかなり楽しいです。

00:21:34.000 --> 00:21:36.000
デモで一緒に見てみましょう。

00:21:36.000 --> 00:21:42.000
ここに私のカフェコンパニオンアプリの出発点があります。これは、あなたの次の無料のコーヒーがいつであるかを示しています。

00:21:42.000 --> 00:21:48.000
フォーマットされた日付を表示するSwiftUIビューがあります。

00:21:48.000 --> 00:21:56.000
フォーマットにロケールを設定したので、ここでSwiftUIプレビューで制御できます。

00:21:56.000 --> 00:22:02.000
かなり良いスタートですが、もう少しカスタマイズしたいと思います。 もう少しカスタマイズしたいと思います。

00:22:02.000 --> 00:22:06.000
これを私のアプリにもう少し具体的にすることから始めましょう。

00:22:06.000 --> 00:22:15.000
私は分、時間、平日だけを気にします。

00:22:15.000 --> 00:22:20.000
OK、かなり良さそうだね。では、色のスプラッシュを加えましょう。

00:22:20.000 --> 00:22:33.000
まず、戻り値の型をAttributedStringに変更し、帰属出力を要求します。

00:22:33.000 --> 00:22:36.000
次に、属性コンテナを使用します。

00:22:36.000 --> 00:22:40.000
これらは、文字列内の特定の文字にアタッチされることなく、属性を保持することができます。

00:22:40.000 --> 00:22:46.000
日付形式が出力に配置する平日属性用に作成します。

00:22:46.000 --> 00:22:52.000
平日を含む文字列の範囲に設定されています。 

00:22:52.000 --> 00:23:00.000
次に、設定したいカラー属性のコンテナを作ります。

00:23:00.000 --> 00:23:13.000
最後に、帰属文字列関数を使用して、最初のコンテナ内の属性に一致する属性を、帰属文字列の2番目の属性の値に置き換えます。

00:23:13.000 --> 00:23:26.000
AttributedStringは値型であり、置換は突然変異関数であるため、「let」を「var」に変更する必要があります。素敵ですね。

00:23:26.000 --> 00:23:28.000
さらに良いことに、それはすべてのロケールで機能します。

00:23:28.000 --> 00:23:37.000
再確認するために、プレビューにもう少し追加しましょう。

00:23:37.000 --> 00:23:43.000
ここでは、これらのロケールのフォーマットされた日付のどこにあっても、平日はオレンジ色であることがわかります。

00:23:43.000 --> 00:23:46.000
さらに新しいフォーマッタAPIについて学び続けましょう。

00:23:46.000 --> 00:23:53.000
日付を文字列に変える方法を見たので、文字列を日付に変える方法について話しましょう。

00:23:53.000 --> 00:23:57.000
日付には、戦略引数を取る初期化子があります。

00:23:57.000 --> 00:24:02.000
この戦略は、入力に期待されるフィールドをパーサーに伝えるために使用されます。

00:24:02.000 --> 00:24:06.000
日付については、フォーマットも一種の戦略です。

00:24:06.000 --> 00:24:14.000
これは、出力を表示し、ユーザーが新しい日付を入力できるテキストフィールドのように、日付をラウンドトリップするのに便利です。

00:24:14.000 --> 00:24:16.000
これは往復の例です。

00:24:16.000 --> 00:24:18.000
解析が投げられることに気付くでしょう。

00:24:18.000 --> 00:24:23.000
これは、入力によっては、解析が失敗する可能性があるためです。

00:24:23.000 --> 00:24:27.000
一部の戦略には、解析のためのより高度なオプションがあります。

00:24:27.000 --> 00:24:34.000
ここでは、固定フォーマットを解析します。これは、日付フォーマットがサーバーから受信したものである場合に便利です。

00:24:34.000 --> 00:24:37.000
それを使用するには、書式文字列で戦略を初期化します。

00:24:37.000 --> 00:24:42.000
しかし、魔法の文字列値を使用する代わりに、文字列補間を使用します。

00:24:42.000 --> 00:24:48.000
この場合、年-月-日の形式の文字列を期待します。

00:24:48.000 --> 00:24:55.000
各補間はフィールドによって明確に識別され、それぞれが期待する形式を正確に指定します。

00:24:55.000 --> 00:24:59.000
これの1つの本当に良い点は、オートコンプリート体験です。

00:24:59.000 --> 00:25:07.000
別の日形式を使用したい場合、オートコンプリートは、それぞれが何を意味するかについてのドキュメントとともに有効なオプションを表示します。

00:25:07.000 --> 00:25:12.000
いいえ、1年に解析するために何Y文字を使うべきかを推測してください。

00:25:12.000 --> 00:25:13.000
数字に移りましょう。

00:25:13.000 --> 00:25:20.000
数値の書式設定は、整数または浮動小数点の値を人間が読み取ることができるものに変換することです。

00:25:20.000 --> 00:25:24.000
すべての書式設定と同様に、数字の表示方法に関する設定を考慮に入れます。

00:25:24.000 --> 00:25:30.000
これには、使用される数字の種類から、数字をグループ化するために使用される文字まで、すべてが含まれます。

00:25:30.000 --> 00:25:37.000
日付の書式設定と同様に、追加のパラメータを必要とせず、優れた出力を得るのは簡単です。

00:25:37.000 --> 00:25:40.000
サポートされている多くの種類のオプションと出力があります。

00:25:40.000 --> 00:25:47.000
ここでは、パーセンテージ、科学的表記法、通貨を示します。

00:25:47.000 --> 00:25:50.000
最後に、いくつかのフォーマットをまとめましょう。

00:25:50.000 --> 00:25:54.000
リストの書式設定は、配列をフォーマットするだけです。

00:25:54.000 --> 00:25:59.000
このメンバースタイル引数は、配列内の各要素のフォーマットスタイルを指定します。

00:25:59.000 --> 00:26:02.000
これらは数字なので、パーセンテージを使いたいです。

00:26:02.000 --> 00:26:05.000
出力はすべてのユーザーのロケールに対して正しいです。

00:26:05.000 --> 00:26:08.000
これまでのところ、私たちは値を直接フォーマットすることに焦点を当ててきました。

00:26:08.000 --> 00:26:13.000
SwiftUIは、TextFieldにフォーマットスタイルを添付することもサポートしています。

00:26:13.000 --> 00:26:22.000
フォーマットスタイルには、フォーマットされる値の種類に関するタイプ情報があるため、ここで私の領収書のチップパーセンテージには、読み取り可能で安全な構文を使用できます。

00:26:22.000 --> 00:26:28.000
Cafféアプリをもう一度見て、フォーマットが表示される場所の数を見てみましょう。

00:26:28.000 --> 00:26:31.000
成分にはリスト形式を使用します。

00:26:31.000 --> 00:26:34.000
価格には通貨形式を使用しています。

00:26:34.000 --> 00:26:39.000
数量には数値形式を使用し、注文ボタンでカウントをローカライズします。

00:26:39.000 --> 00:26:43.000
私たちは、あなたがいつもここの隅に見る日付形式を忘れることはできません。

00:26:43.000 --> 00:26:50.000
フォーマットされた出力は至る所にあり、この新しいAPIはアプリでも簡単に、さらに楽しくなると思います。

00:26:50.000 --> 00:26:54.000
ローカライズされた文字列やフォーマッタに役立つリソースはもっとたくさんあります。

00:26:54.000 --> 00:27:07.000
このトピックについては、「SwiftUIアプリをローカライズする」と「ローカライズされた文字列を合理化する」という2つのセッションがあります。次に、自動文法合意と呼ばれる新機能について話しましょう。

00:27:07.000 --> 00:27:15.000
スペイン語のような言語のローカライザーは、自然な翻訳を表現する能力が制限されており、時には厄介な対話につながります。

00:27:15.000 --> 00:27:27.000
これらの言語は、スピーチの異なる部分間の性別と複数化の合意を達成するために変換を必要とし、時にはユーザーの好ましい住所用語の知識を必要とすることさえあります。

00:27:27.000 --> 00:27:33.000
英語にもこの特徴があり、単数形と複数形が異なる名詞があります。

00:27:33.000 --> 00:27:37.000
私はそこに多くの言語の専門用語を捨てたので、例を見てみましょう。

00:27:37.000 --> 00:27:42.000
私のカフェアプリでは、食品、サイズ、数量を選ぶことができます。

00:27:42.000 --> 00:27:46.000
私は小さなサラダを1つ選びます。

00:27:46.000 --> 00:27:51.000
今、私の友人は彼女が私に加わると言っているので、私はカウントを2に増やします。

00:27:51.000 --> 00:27:56.000
英語では、「サラダ」という単語は数字の2と一致するように変更されなければなりません。

00:27:56.000 --> 00:27:58.000
これは合意と呼ばれています。

00:27:58.000 --> 00:28:03.000
つまり、この文の単語は互いに一致しなければならないということです。

00:28:03.000 --> 00:28:07.000
英語では、複数形のために単語を修正することは、一般的な種類の合意です。

00:28:07.000 --> 00:28:16.000
では、アプリをスペイン語に切り替えて、エンサラダペケーニャを1つ、または小さなサラダを1つ注文しましょう。

00:28:16.000 --> 00:28:23.000
友人のために注文するとき、この注文ボタンは英語と同じ複数形が必要ですが、ひねりがあります。

00:28:23.000 --> 00:28:31.000
スペイン語では、形容詞ペケニャと名詞エンサラダの両方がカウント、ドスと一致する必要があります。

00:28:31.000 --> 00:28:37.000
だから、ensalada pequeñaの代わりに、ボタンにはensaladas pequeñasと書かれています。

00:28:37.000 --> 00:28:40.000
次に、飲み物に進みます。

00:28:40.000 --> 00:28:49.000
この文では、ボタンは正しい複数形化だけでなく、これらの単語の文法的な性別にも同意する必要があります。

00:28:49.000 --> 00:28:52.000
ジュース、ジュゴは男性的です。

00:28:52.000 --> 00:28:56.000
形容詞ペケニョも一致しなければならない。

00:28:56.000 --> 00:29:02.000
このようなテキストを正しくローカライズするために、組み合わせの爆発に終わります。

00:29:02.000 --> 00:29:07.000
食品、サイズ、カウントの組み合わせごとに異なるローカライズされた文字列が必要です。

00:29:07.000 --> 00:29:15.000
コードでは、多くの場合、このように見えることになり、各アイテムを切り替えてから、各サイズを切り替える必要があります。

00:29:15.000 --> 00:29:21.000
カウントのためにこれらの文字列のそれぞれを正しく複数形にできるstringsdictファイルもあります。

00:29:21.000 --> 00:29:31.000
さて、キーボードの提案を強化するのと同じ技術を活用して、これらすべてのケースなどを簡単に処理できる新しいAPIを作成しました。

00:29:31.000 --> 00:29:41.000
システムは、正しい文法を持つようにローカライズされた文字列を自動的に修正するため、この機能を自動文法合意と呼びます。

00:29:41.000 --> 00:29:43.000
これで、コードははるかにシンプルになります。

00:29:43.000 --> 00:29:48.000
数量、サイズ、食品を1つの文字列にまとめることができます。

00:29:48.000 --> 00:29:53.000
自動文法合意は、inflectionと呼ばれるプロセスを使用して文字列を修正します。

00:29:53.000 --> 00:29:54.000
それを分解しましょう。

00:29:54.000 --> 00:29:59.000
屈折するには、文字列のどの部分を修正する必要があるかを知る必要があります。

00:29:59.000 --> 00:30:05.000
幸いなことに、Swiftにはそれができるタイプ、AttributedString、およびMarkdownのカスタム属性があります。

00:30:05.000 --> 00:30:12.000
この文字列では、その構文を使用して、食品、サイズ、および屈折属性でカウントをラップします。

00:30:12.000 --> 00:30:15.000
属性の値はtrueです。

00:30:15.000 --> 00:30:28.000
このプロジェクトのローカリゼーションをエクスポートすると、注釈付き文字列と、食品の名前やサイズなどのソースコード内の他のローカライズされた文字列を含む文字列ファイルを取得します。

00:30:28.000 --> 00:30:30.000
これがラテンアメリカスペイン語の文字列です。

00:30:30.000 --> 00:30:40.000
ローカライザーは、「small」や「large」のような形容詞がスペイン語の名詞の前にあるため、引数並べ替え構文%1、%3、%2を使用しました。

00:30:40.000 --> 00:30:48.000
彼らは、文字列のこの領域を屈折するためのカスタム属性構文を保持し、食品とサイズの翻訳を提供します。

00:30:48.000 --> 00:30:51.000
自動文法エンジンは、残りを修理します。

00:30:51.000 --> 00:30:59.000
一部の言語は、ローカライズされたテキスト自体の単語間だけでなく、そのテキストとそれを読んでいる人との間の合意を特徴としています。

00:30:59.000 --> 00:31:02.000
自動文法合意もそれに役立ちます。

00:31:02.000 --> 00:31:05.000
例えば、このメモのウェルカム画面を見てみましょう。

00:31:05.000 --> 00:31:17.000
英語では「Welcome to Notes」と言います。スペイン語では、「Te damos la bienvenida a Notas」または「Notesへようこそ」と言います。私たちはスペイン語で英語と同じ経験をしたいと思っています。

00:31:17.000 --> 00:31:24.000
ただし、スペイン語では、「bienvenido」という単語は、ユーザーの好みの住所用語と一致する必要があります。

00:31:24.000 --> 00:31:29.000
この用語はいくつかの選択肢の1つである可能性があり、その選択はテキストを変更します。

00:31:29.000 --> 00:31:34.000
正しい住所用語を使用すると、より個人的で包括的な経験が得られます。

00:31:34.000 --> 00:31:40.000
今年のリリースでは、スペイン語を使用する人々が住所の用語を指定できるようにしました。

00:31:40.000 --> 00:31:44.000
言語と地域の設定では、新しい住所期間オプションがあります。

00:31:44.000 --> 00:31:51.000
選択すると、好みを選択し、すべてのアプリと共有することもできます。

00:31:51.000 --> 00:31:55.000
ここでは、女性的な住所用語のメモに新しいウェルカム画面が表示されます。

00:31:55.000 --> 00:31:57.000
そして、ここでは男性的な住所の用語です。

00:31:57.000 --> 00:32:03.000
わからない場合、またはユーザーが指定したくない場合は、元の文字列を代替として保持します。

00:32:03.000 --> 00:32:09.000
先ほど見たのと同じ抑揚属性は、ユーザーを参照するローカライズされた文字列でも使用されます。

00:32:09.000 --> 00:32:14.000
「ようこそ」の場合、bienvenidoという単語に抑揚属性を適用します。

00:32:14.000 --> 00:32:17.000
英語の文字列は変更する必要はありません。

00:32:17.000 --> 00:32:25.000
また、ユーザーの好みに関する情報がない場合にエンジンが使用する置換文字列である抑揚の代替を追加することもできます。

00:32:25.000 --> 00:32:29.000
今年は、スペイン語と英語の自動契約をサポートします。

00:32:29.000 --> 00:32:34.000
ノートのウェルカム画面など、OS全体のいくつかの場所で採用しました。

00:32:34.000 --> 00:32:36.000
アプリにも採用できます。

00:32:36.000 --> 00:32:41.000
必要なコードの変更は、ほとんどの場合、異なる文字列を選択するために多くのロジックを削除するだけです。

00:32:41.000 --> 00:32:50.000
何を反転させるかについての指示は、ローカライズされた文字列自体の一部であり、ローカライザーは文字列が自分の言語でどのように表示されるかをより詳細に制御できます。

00:32:50.000 --> 00:32:54.000
Cafféアプリの自動文法契約を見てみましょう。 

00:32:54.000 --> 00:32:57.000
英語で実行されているカフェアプリを見てみましょう。

00:32:57.000 --> 00:33:02.000
注文にピザを追加することから始めます。

00:33:02.000 --> 00:33:05.000
私は大きなものを持っていると思います。そしてちょうど1。

00:33:05.000 --> 00:33:10.000
ボタンのテキストが大きなピザ0枚から大きなピザ1枚に変わったことに注目してください。

00:33:10.000 --> 00:33:12.000
それは自動的に行われました。

00:33:12.000 --> 00:33:16.000
2を選べば、また直ります。

00:33:16.000 --> 00:33:19.000
1つだけもらいます。

00:33:19.000 --> 00:33:23.000
この画面の下部で、注文ボタンが「1項目」に変更されました。

00:33:23.000 --> 00:33:27.000
何か飲み物はいかがですか?

00:33:27.000 --> 00:33:31.000
小さいのは大丈夫です、そしてこれらのうちの1つだけです。

00:33:31.000 --> 00:33:35.000
ボタンが「アイテム」ではなく「アイテム」と言うように変更されたことに気づきましたか?

00:33:35.000 --> 00:33:37.000
その文字列は自動的に変更されました。

00:33:37.000 --> 00:33:41.000
チェックしましょう。

00:33:41.000 --> 00:33:43.000
これが私たちの領収書です。

00:33:43.000 --> 00:33:46.000
ピザとジュース、およびフォーマットされた価格が記載されています。

00:33:46.000 --> 00:33:51.000
下部には、カスタムフォントとウェブサイトへのリンクを含む、私たちの帰属文字列があります。

00:33:51.000 --> 00:33:54.000
Xcodeに戻って、ソースを見てみましょう。 ソースを見てみましょう。

00:33:54.000 --> 00:34:01.000
食べ物の詳細ビューから始めます。

00:34:01.000 --> 00:34:04.000
これは、サイズ選択画面を表示するビューです。

00:34:04.000 --> 00:34:15.000
新しいサイズを追加して、食べ物の種類、サイズ、カウントごとに1つではなく、スペイン語のローカライズされた文字列を1つ追加する必要があるかを確認できるようにしましょう。

00:34:15.000 --> 00:34:17.000
この行はリストを示しています。

00:34:17.000 --> 00:34:19.000
リストは私たちのモデルオブジェクトから来ています。

00:34:19.000 --> 00:34:24.000
そこに行きましょう。

00:34:24.000 --> 00:34:27.000
サイズ列挙型はすでに小さいものと大きいものがあります。

00:34:27.000 --> 00:34:38.000
私は「巨大な」と呼ばれる私たちの飢えた顧客のために新しいサイズを追加するつもりです。これを行うには、ローカライズされた文字列とともに新しいケースを追加します。

00:34:38.000 --> 00:34:41.000
今、私は巨大なサイズの価格を追加する必要があります。

00:34:41.000 --> 00:34:44.000
このデモでは、イニシャライザに入れただけです。

00:34:44.000 --> 00:34:47.000
今、私は巨大なサイズの価格を追加する必要があります。

00:34:47.000 --> 00:34:57.000
このデモでは、イニシャライザに入れました。

00:34:57.000 --> 00:35:03.000
私たちの見解をもう一度見てみましょう。

00:35:03.000 --> 00:35:06.000
プレビューでは、私たちの新しいサイズです。

00:35:06.000 --> 00:35:08.000
私たちのソースにはすでに英語の文字列が含まれています。

00:35:08.000 --> 00:35:10.000
私は今、スペイン語のものが必要です。

00:35:10.000 --> 00:35:24.000
新しい文字列を生成するには、コンパイラを使用して「巨大な」の新しいローカライズされた文字列を見つけます。これを行うには、[製品] &gt; [ローカリゼーションのエクスポート] を選択し、スペイン語の文字列を保存します。

00:35:24.000 --> 00:35:34.000
では、スペイン語の翻訳を追加しましょう。

00:35:34.000 --> 00:35:45.000
新しい文字列をフィルタリングして、スペイン語の単語を入力できます。

00:35:45.000 --> 00:35:57.000
次に、これらのローカリゼーションをインポートしてアプリに入れます。

00:35:57.000 --> 00:36:01.000
今、私は再び私たちのアプリを実行しますが、スペイン語で。

00:36:01.000 --> 00:36:08.000
これを行うには、[製品] &gt; [スキーム] &gt; [スキームの編集] を選択します。

00:36:08.000 --> 00:36:17.000
オプションでは、テストしたい言語を選択できます。

00:36:17.000 --> 00:36:20.000
そして走る。

00:36:20.000 --> 00:36:23.000
私たちのヘッダーから、私たちが今スペイン語で走っていることがわかります。

00:36:23.000 --> 00:36:27.000
サラダから始めて、別の注文をしましょう。

00:36:27.000 --> 00:36:32.000
数量を変更すると、注文ボタンが固定されます。

00:36:32.000 --> 00:36:37.000
私たちの新しい巨大なサイズは、2つのサラダのために正しく複数形化されています。

00:36:37.000 --> 00:36:43.000
さらに、それは「ensalada」の文法的な性別と一致し、すべて1つの文字列で一致します。

00:36:43.000 --> 00:36:51.000
今年はFoundationに多くの素晴らしい新機能があり、今日あなたのアプリで試す準備ができています。

00:36:51.000 --> 00:36:59.000
AttributedStringは、文字列の範囲にキーと値のペアを追加するための、高速で使いやすいSwiftファーストのインターフェイスを提供します。

00:36:59.000 --> 00:37:05.000
テキストでSwiftUIと一緒に使用し、ローカライズされた文字列でMarkdownを使い始めることができます。

00:37:05.000 --> 00:37:12.000
新しいFormatter APIは、フォーマットに焦点を当て、コードを簡素化し、パフォーマンスを向上させます。

00:37:12.000 --> 00:37:17.000
アプリでデータを表示するすべての場所でフォーマットを使用してください。

00:37:17.000 --> 00:37:28.000
最後に、自動文法契約は、文法的な性別、カウント、およびユーザー自身のアドレス用語と一致するように、ローカライズされた文字列をインテリジェントに修正します。

00:37:28.000 --> 00:37:30.000
これらの新機能を気に入っていただければ幸いです。

00:37:30.000 --> 00:37:32.000
私たちはあなたのアプリでそれらを見つけるのを楽しみにしています。

00:37:32.000 --> 00:37:34.000
ありがとうございます。

00:37:34.000 --> 23:59:59.000
[音楽]。

