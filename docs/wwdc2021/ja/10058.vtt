WEBVTT

00:00:00.000 --> 00:00:05.000
♪ベース音楽の演奏♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:17.000
フィリップ・ハウスラー:こんにちは、私の名前はフィリップです。Swiftのクールな新機能、AsyncSequenceをご紹介できることを本当に楽しみにしています。

00:00:17.000 --> 00:00:22.000
今日は、非同期シーケンスとは何か、その背後にある基礎について説明します。

00:00:22.000 --> 00:00:29.000
次に、コードでそれらを使用する方法について話し、新しいAsyncSequence APIのいくつかについて説明します。

00:00:29.000 --> 00:00:34.000
そして最後に、独自の非同期シーケンスを構築する方法を探ります。

00:00:34.000 --> 00:00:36.000
だから、すぐに飛び込みましょう。

00:00:36.000 --> 00:00:42.000
これは、AsyncSequenceでできるクールな新しいもののいくつかを説明するために私が書いた本当にシンプルなツールです。

00:00:42.000 --> 00:00:46.000
このツールでは、エンドポイントへのURLから始めます。

00:00:46.000 --> 00:00:48.000
最近の地震をリストアップしています。

00:00:48.000 --> 00:00:54.000
さて、通常、ダウンロードは実際には非同期タスクであり、時間がかかることがあります。

00:00:54.000 --> 00:01:00.000
しかし、この場合、すべてのものがダウンロードされるのを待ちたくありません。代わりに、受け取ったものを表示したいと考えています。

00:01:00.000 --> 00:01:08.000
だから私は物事を少し揺るがし、新しい非同期/待機機能を使用して、このエンドポイントから応答する行を取得することにしました。

00:01:08.000 --> 00:01:14.000
取得しているデータはカンマで区切られたテキストとしてフォーマットされているため、各行はデータの完全な行です。

00:01:14.000 --> 00:01:22.000
非同期の行シーケンスは、受信されたときに各行を放出しているので、それは潜在的に私たちの前に本当に大きなダウンロードを持つことができることを意味します。

00:01:22.000 --> 00:01:35.000
しかし、私たちがそれらを得るにつれてそれらを放出することによって、スニペットは本当に応答性を感じ、それについての最も素晴らしい部分は、この新しい非同期コンテキストで通常のシーケンスから使用することに慣れているのと同じものを使用できるということです。

00:01:35.000 --> 00:01:48.000
つまり、新しいfor-await-in構文を使用して反復し、map、filter、reduceなどの関数、またはこのサンプルのようにdropFirst関数を使用してそれらの値を操作できることを意味します。

00:01:48.000 --> 00:01:50.000
では、これはどのように機能しますか?

00:01:50.000 --> 00:01:56.000
さて、私が今日話す多くのことは、非同期/待機トークに基づいた基礎を持っています。

00:01:56.000 --> 00:01:59.000
しかし、いくつかの重要なポイントを要約しましょう。

00:01:59.000 --> 00:02:06.000
非同期関数を使用すると、awaitキーワードを使用して、コールバックを必要とせずに並行コードを書くことができます。

00:02:06.000 --> 00:02:12.000
非同期関数を呼び出すと、値やエラーが発生するたびに一時停止され、再開されます。

00:02:12.000 --> 00:02:22.000
一方、AsyncSequenceは各要素で一時停止し、基礎となるイテレータが値を生成するか、スローしたときに再開します。

00:02:22.000 --> 00:02:29.000
基本的に、名前が示すように、それらは通常のシーケンスに似ていますが、いくつかの重要な違いがあります。

00:02:29.000 --> 00:02:33.000
つまり、各要素は非同期に配信されます。

00:02:33.000 --> 00:02:39.000
しかし、それらは非同期配信であるため、それは失敗が間違いなく可能性があることを意味します。

00:02:39.000 --> 00:02:45.000
一部の非同期シーケンスはスローされますが、失敗がオプションでない場合、そうでないものもあります。

00:02:45.000 --> 00:02:52.000
スローする関数と同様に、コンパイラは反復または作成時にエラーが処理されることを確認するのに役立ちます。

00:02:52.000 --> 00:02:57.000
一般的に言えば、非同期シーケンスは、時間の経過とともに値を生成する方法の説明です。

00:02:57.000 --> 00:03:05.000
したがって、非同期シーケンスは0以上の値であり、シーケンスと同様に、イテレータからnilを返すことで完了を意味します。

00:03:05.000 --> 00:03:17.000
エラーが発生した場合、それはまた、非同期シーケンスが端末状態にあるポイントであり、エラーが発生した後、イテレータの次への後続の呼び出しに対してnilを返します。

00:03:17.000 --> 00:03:24.000
それでは、まず定期的な反復から始めて、その定義がどのように機能するかを掘り下げてみましょう。

00:03:24.000 --> 00:03:26.000
ここには、かなり馴染みのあるパターンがあります。

00:03:26.000 --> 00:03:28.000
これはフォーインループです。

00:03:28.000 --> 00:03:35.000
この場合、シーケンスから地震を反復し、マグニチュードが特定の値を超えるときに関数を呼び出します。

00:03:35.000 --> 00:03:41.000
コンパイラは、この反復がどのように機能するかについての知識を持っていますが、それが行うことは魔法ではありません。

00:03:41.000 --> 00:03:46.000
コンパイルステップは、実際にはいくつかの簡単な変換を行うだけです。

00:03:46.000 --> 00:03:52.000
この非同期形式が何であるかを理解できるように、これらの変換を調べてみましょう。

00:03:52.000 --> 00:03:56.000
これは、以前のコードを構築するときにコンパイラが行うことです。

00:03:56.000 --> 00:04:04.000
最初にイテレータ変数を作成することから開始し、次に呼び出されたときにイテレータによって生成されるすべての地震を取得するためにwhileループを使用します。

00:04:04.000 --> 00:04:10.000
新しい非同期/待機機能を使用するには、わずかな変更が1つあります。

00:04:10.000 --> 00:04:15.000
次の関数を非同期に変更するのと同じくらい簡単です。

00:04:15.000 --> 00:04:21.000
次の地震を待つことで、反復をSwiftの並行性に参加させることができます。

00:04:21.000 --> 00:04:28.000
ループが非同期シーケンスにあった場合、これがどのようなものであったかを明らかにするために巻き戻しましょう。

00:04:28.000 --> 00:04:33.000
前述のように、非同期シーケンスから各アイテムを待つ必要があります。

00:04:33.000 --> 00:04:37.000
これは、新しいfor-await-in構文に反映されています。

00:04:37.000 --> 00:04:44.000
これはすべて、Sequenceの使い方を知っていれば、AsyncSequenceの使い方についてすでに良いアイデアを持っていることを意味します。

00:04:44.000 --> 00:04:47.000
非同期シーケンスを利用する方法はいくつかあります。

00:04:47.000 --> 00:04:59.000
先ほど説明したように、新しいfor-await-in構文を使用できます。または、非同期シーケンスがスローされた場合は、新しいfor-try-await-in構文を使用できます。

00:04:59.000 --> 00:05:10.000
これにより、クロージャでつぶすことなく、非同期に生成された値を簡単に反復し、すでに慣れ親しんだ構文を使用して反復することができます。

00:05:10.000 --> 00:05:14.000
休憩や継続のようなものでさえ、ただ働くだけです。

00:05:14.000 --> 00:05:18.000
これで、非同期シーケンスの理論をよく紹介しました。

00:05:18.000 --> 00:05:21.000
その反復をもう少し詳しく見てみましょう。

00:05:21.000 --> 00:05:28.000
非同期シーケンスであるソースが与えられた場合、for-await-in構文を使用して各値を待つことができます。

00:05:28.000 --> 00:05:36.000
これは、イテレータによって生成された各アイテムを待ち、端末にヒットするとループを完了することを意味します。

00:05:36.000 --> 00:05:43.000
非同期シーケンスを反復する場合、ブレークは明らかにループ内から早期に反復を終了する良い方法です。

00:05:43.000 --> 00:05:46.000
これは通常のシーケンスと同じように機能します。

00:05:46.000 --> 00:05:50.000
ここでは、地震の位置データが存在しない場合に壊れています。

00:05:50.000 --> 00:05:55.000
または、スキップしたい値がある場合は、continueを使用できます。

00:05:55.000 --> 00:06:04.000
この場合、深さが何らかの値よりも大きい場合は、それらをスキップして次の地震を待ち続けます。

00:06:04.000 --> 00:06:12.000
ダウンロードからのこの次の反復は以前と同じように機能しますが、この場合、私たちが持っているソースはエラーをスローする可能性があります。

00:06:12.000 --> 00:06:20.000
関数をスローするのと同じように、反復されるAsyncSequenceがスローできるときに、各要素を処理するためにtryが必要です。

00:06:20.000 --> 00:06:28.000
また、関数を投げるのと同じように、コンパイラはトライを逃したときに検出し、間違いを修正するためのFix-itを提供します。

00:06:28.000 --> 00:06:37.000
これは、非同期シーケンスがエラーを生成する可能性がある場合、言語がそのエラーをスローするかキャッチすることを強制するため、常に安全であることを意味します。

00:06:37.000 --> 00:06:42.000
この2番目の反復は、最初のループの反復の後に順番に実行されます。

00:06:42.000 --> 00:06:46.000
コードを順番に実行することは、必ずしも望ましいとは限りません。

00:06:46.000 --> 00:06:55.000
起こっている他のことと同時に反復を実行すると便利な場合は、反復をカプセル化する新しい非同期タスクを作成できます。

00:06:55.000 --> 00:07:01.000
これは、使用している非同期シーケンスが無期限に実行される可能性があることがわかっている場合に便利です。

00:07:01.000 --> 00:07:07.000
さて、そのシーケンスは潜在的に無期限である可能性がありますが、発生することはかなり一般的ではありません。

00:07:07.000 --> 00:07:15.000
しかし、非同期行動の世界では、それははるかに一般的なものであり、それらを使用する際に考慮する必要があるものです。

00:07:15.000 --> 00:07:21.000
ありがたいことに、Swiftの並行性のための施設は、これを本当に簡単で安全にします。

00:07:21.000 --> 00:07:27.000
これは、外部で反復をキャンセルしたい場合にも本当に役立ちます。

00:07:27.000 --> 00:07:32.000
ここでは、2つの反復を同時に実行し、後で反復を終了することができます。

00:07:32.000 --> 00:07:40.000
コンテナの寿命に無期限である可能性のある反復の作業にスコープするタスクではかなり簡単です。

00:07:40.000 --> 00:07:51.000
次に、macOS Monterey、iOS 15、tvOS 15、およびwatchOS 8で入手可能なAsyncSequence APIのいくつかを見てみましょう。

00:07:51.000 --> 00:07:55.000
たくさんありますが、ハイライトをいくつかお見せします。

00:07:55.000 --> 00:08:00.000
ファイルからの読み取りは、多くの場合、非同期動作の主なユースケースです。

00:08:00.000 --> 00:08:07.000
FileHandleには、そのFileHandleから非同期のバイトシーケンスにアクセスできる新しいバイトプロパティが追加されました。

00:08:07.000 --> 00:08:16.000
これは、バイトの非同期シーケンスを行に変換するAsyncSequenceの新しい拡張機能と組み合わせて使用できます。

00:08:16.000 --> 00:08:24.000
しかし、ファイルを扱うことは非常に一般的であるため、URLはバイトと行の両方のアクセサを持つべきだと判断しました。

00:08:24.000 --> 00:08:28.000
これは私が最初の例で使用したのと同じAPIです。

00:08:28.000 --> 00:08:37.000
これは、ファイルまたはネットワークから、コンテンツから行のAsyncSequenceを返すためのURLの便利なプロパティです。

00:08:37.000 --> 00:08:42.000
これにより、これまで多くの本当に複雑なタスクが簡単かつ安全になると確信しています。

00:08:42.000 --> 00:08:48.000
ネットワークから物事を取得するには、応答と認証をもう少し制御する必要がある場合があります。

00:08:48.000 --> 00:08:57.000
したがって、URLSessionには、URLまたはURLRequestが与えられたバイトの非同期シーケンスを取得するバイト関数を持つようになりました。

00:08:57.000 --> 00:09:10.000
もっと知りたい場合は、この詳細とURLSessionを使用したさらに多くの新しい非同期機能については、セッション「URLSessionで非同期/待機」をチェックしてください。

00:09:10.000 --> 00:09:15.000
しかし、AsyncSequenceにとって理にかなっているのはファイルやネットワークだけではありません。

00:09:15.000 --> 00:09:20.000
通知は、新しい通知APIで待つことができます。

00:09:20.000 --> 00:09:25.000
そして、反復はAsyncSequenceと対話する唯一の方法ではありません。

00:09:25.000 --> 00:09:33.000
この例では、一致するストアUUIDを持つリモート変更の最初の通知を待っています。

00:09:33.000 --> 00:09:47.000
firstWhereのようなメソッドを使用すると、通知非同期シーケンスとともに、以前は複雑なロジックを表現していたコードをコンパクトで読みやすくする、本当にきちんとした新しいデザインパターンが可能になります。

00:09:47.000 --> 00:09:55.000
そして、それらすべてが十分にクールでなかった場合、非同期シーケンスから値を非同期に操作するための新しいAPIがたくさんあります。

00:09:55.000 --> 00:10:00.000
これらは、Sequenceで利用可能なのと同じ機能のいくつかであるため、かなり馴染みがあるはずです。

00:10:00.000 --> 00:10:06.000
これまでに、dropFirstやfirstWhereなど、いくつかを取り上げましたが、それ以上のものがあります。

00:10:06.000 --> 00:10:14.000
シーケンスで使用するために考えられるほとんどすべてのものには、AsyncSequenceで作業するための非同期の対応物があります。

00:10:14.000 --> 00:10:25.000
今、それは取り込むべきことがたくさんあり、あなたは「ねえ、それらの新しいAPIは本当にクールで、その構文は超きちんとしていますが、どうすれば自分の非同期シーケンスを作ることができますか?」と思うかもしれません。

00:10:25.000 --> 00:10:27.000
さて、まさにそれをやりましょう!

00:10:27.000 --> 00:10:35.000
非同期シーケンスを実装する方法はいくつかありますが、既存のコードを適応させる方法に焦点を当てます。

00:10:35.000 --> 00:10:46.000
特に、AsyncSequenceで本当にうまく機能するいくつかのデザインパターンがあり、あなたがすでに持っているものをこの新しいコンセプトと相互作用させるためのいくつかの素晴らしい機能があります。

00:10:46.000 --> 00:10:54.000
これらのデザインパターンのいくつかは、複数回呼び出されるクロージャのようなものですが、一部のデリゲートもうまく機能します。

00:10:54.000 --> 00:11:04.000
応答を必要とせず、発生する新しい値を通知するだけで、非同期シーケンスを作成するための主要な候補になる可能性があります。

00:11:04.000 --> 00:11:09.000
これらのデザインパターンは本当に一般的であり、あなたはおそらく今日すでにあなたのアプリにいくつか持っているでしょう。

00:11:09.000 --> 00:11:12.000
これは一般的なハンドラパターンの例です。

00:11:12.000 --> 00:11:17.000
ハンドラープロパティと開始および停止メソッドを持つクラスです。

00:11:17.000 --> 00:11:21.000
AsyncSequenceの完璧な候補のようです。

00:11:21.000 --> 00:11:32.000
既存の使用法は、モニターが作成され、値を取得するハンドラーが割り当てられ、その後、地震がハンドラーに送信されるようにモニターが開始される、このようなものになる可能性があります。

00:11:32.000 --> 00:11:38.000
後で、生成されるイベントをキャンセルするためにモニターが停止される可能性があります。

00:11:38.000 --> 00:11:44.000
同じインターフェイスを使用して、新しいAsyncStreamタイプに使用を適応させることができます。

00:11:44.000 --> 00:11:51.000
それを使用するにはほんの少しのコードが必要で、非同期シーケンスを構築できます。

00:11:51.000 --> 00:11:57.000
非同期ストリームを構築するときは、要素タイプと構築クロージャが指定されます。

00:11:57.000 --> 00:12:04.000
クロージャには、値を複数回、終了、または処理できる継続があります。

00:12:04.000 --> 00:12:10.000
つまり、この場合、モニターは建設閉鎖内に作成できます。

00:12:10.000 --> 00:12:14.000
そして、ハンドラーを割り当てて、継続に地震をもたらすことができます。

00:12:14.000 --> 00:12:18.000
そして、onTerminationはキャンセルとクリーンアップを処理できます。

00:12:18.000 --> 00:12:20.000
そして、私たちは監視を始めることができます。

00:12:20.000 --> 00:12:26.000
以前と同じモニターコードは、非同期ストリームの構築に簡単にカプセル化できます。

00:12:26.000 --> 00:12:30.000
これにより、すべての使用サイトで同じロジックを複製する必要がなくなります。

00:12:30.000 --> 00:12:34.000
そして、これがこの非同期ストリームの使用方法です。

00:12:34.000 --> 00:12:40.000
フィルターなどの強力な変換関数と、新しいfor-await-in構文を使用できます。

00:12:40.000 --> 00:12:49.000
これにより、すべてが1か所にまとめられているため、簿記の複製を心配するのではなく、コードの意図に集中できます。

00:12:49.000 --> 00:12:54.000
独自の非同期シーケンスを作成するには、AsyncStreamに多くの柔軟性があります。

00:12:54.000 --> 00:12:59.000
これは本当にほんの一例であり、あなた自身のコードに適応できる他の多くのものがある可能性があります。

00:12:59.000 --> 00:13:05.000
AsyncStreamは、既存のコードを非同期シーケンスに適合させるのに最適な方法です。

00:13:05.000 --> 00:13:14.000
安全性、反復、キャンセルなど、非同期シーケンスに期待されるすべてのものを処理しますが、バッファリングも処理します。

00:13:14.000 --> 00:13:25.000
AsyncStreamは、生成される要素の唯一のソースは構築からであるため、独自の非同期シーケンスと独自のAPIから適切なリターンタイプを構築する堅実な方法です。

00:13:25.000 --> 00:13:27.000
そして、あなたが投げられているエラーを表す必要がある場合?

00:13:27.000 --> 00:13:30.000
まあ、私たちはそのためのタイプを持っています!

00:13:30.000 --> 00:13:35.000
AsyncThrowingStreamはAsyncStreamに似ていますが、エラーを処理できます。

00:13:35.000 --> 00:13:42.000
AsyncStreamと同じ柔軟性と安全性を提供しますが、反復からスローすることで障害を処理できます。

00:13:42.000 --> 00:13:51.000
AsyncSequenceは、複数の非同期値を扱うのに安全で使い慣れた本当に強力なツールです。

00:13:51.000 --> 00:13:56.000
シーケンスの使い方を知っていれば、すでにAsyncSequenceの使い方を知っています。

00:13:56.000 --> 00:14:02.000
非同期シーケンスとは何か、どのように使用されるかを調べ、AsyncStreamを紹介しました。

00:14:02.000 --> 00:14:11.000
私たちは、理論とそれらを定義するもの、そして新しく導入された非同期シーケンスのいくつか、そして最後に、独自のシーケンスを構築する方法に飛び込みました。

00:14:11.000 --> 00:14:14.000
私はあなたが次に彼らと何をするかを心待ちにしています。

00:14:14.000 --> 23:59:59.000
♪

