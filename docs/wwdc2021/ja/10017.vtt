WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:11.000
みなさん、こんにちは。

00:00:11.000 --> 00:00:12.000
コアデータチームのマイケル・ルヒューです。

00:00:12.000 --> 00:00:22.000
そして今日、Core DataとSwiftでの作業を本当に優れた経験にするためにチームが行った機能強化のいくつかについてお話しできることを本当に楽しみにしています。

00:00:22.000 --> 00:00:30.000
Core Dataが、すべてのAppleプラットフォームで顧客のデータ永続性のニーズに対応する優れたソリューションであるレビューから始めます。

00:00:30.000 --> 00:00:38.000
次に、Core DataがSwiftランタイムで新しい並行性の機会を採用した方法についての議論をフォローアップします。

00:00:38.000 --> 00:00:45.000
次に、Swiftでコードをより表現力豊かにするために、Core Data APIに対して行った機能強化のいくつかについて説明します。

00:00:45.000 --> 00:00:55.000
そして、Core Dataが2020年に導入した既存のSwiftUIサポートに追加している動的な機能の探求で議論を締めくくります。

00:00:55.000 --> 00:01:03.000
しかし、あなたが開発しているAppleプラットフォームに関係なく、あなたは単にアプリケーションを持っているので、最初から始めましょう。

00:01:03.000 --> 00:01:10.000
ある時点で、アプリケーションは最終的にユーザーデータに遭遇し、どこかに保存する必要があるでしょう。

00:01:10.000 --> 00:01:14.000
そのニーズのための素晴らしい選択は、コアデータを使用することです。

00:01:14.000 --> 00:01:23.000
Core Dataは、堅牢で機能豊富な方法でユーザーのデータを永続化したいアプリケーション開発者のためのAppleの特徴的なフレームワークです。

00:01:23.000 --> 00:01:34.000
このフレームワークは、メモリ内のオブジェクトグラフとして表現される方法から、ストレージでのモデル化方法まで、ユーザーデータを適切に管理する複雑さの多くを処理します。

00:01:34.000 --> 00:01:41.000
このフレームワークはまた、メモリの使用やレイテンシなどの重要なランタイムの考慮事項を管理するために多大な努力をしています。

00:01:41.000 --> 00:01:44.000
フレームワークによって提供される機能もスケーラブルです。

00:01:44.000 --> 00:01:56.000
シンプルでローカルに永続的なストアから始めて、複数の実行コンテキストを使用してパフォーマンスを向上させ、CloudKitを通じて強力な共有データエクスペリエンスを作成することもできます。

00:01:56.000 --> 00:02:00.000
Core Dataは、Appleがサポートするすべてのプラットフォームでも機能します。

00:02:00.000 --> 00:02:03.000
そして、私は本当にこの最後の点を強調したいと思います。

00:02:03.000 --> 00:02:13.000
コアデータを使い始めると、学んだことはすべて、MacからiPhone、さらにはApple Watchまで、各プラットフォームで機能します。

00:02:13.000 --> 00:02:17.000
そしてもちろん、Core DataはSwiftでもうまく機能します。

00:02:17.000 --> 00:02:25.000
過去数年間、私たちはSwiftで可能な限り表現力豊かになるようにCore Data APIを強化し続けています。

00:02:25.000 --> 00:02:33.000
そして、これは言語とランタイムにまったく新しい並行性機能が導入され、Swiftにとってかなりエキサイティングな年です。

00:02:33.000 --> 00:02:41.000
創業以来、Core Dataは常にコードを同時に実行することを気にしてきましたが、これには本当に正当な理由があります。

00:02:41.000 --> 00:02:50.000
永続的なデータには、一部の外部ストレージメディアへの読み書きが必要であり、これにより、新しい並行性モデルをサポートすることが自然に適合します。

00:02:50.000 --> 00:02:56.000
地震サンプルアプリケーションのコンテキストで、これがどのように機能するかを探りましょう。

00:02:56.000 --> 00:03:09.000
このアプリケーションは、米国地質調査所からのデータフィードを読み取り、コアデータを使用して、マグニチュード、場所、イベントが発生した日付など、最近の地震に関する情報を保存します。

00:03:09.000 --> 00:03:19.000
アーキテクチャ的には、Earthquaksは、UIを駆動するためのビューコンテキストと、USGSが提供するデータを取り込むためのバックグラウンドコンテキストを持つSwiftアプリケーションです。

00:03:19.000 --> 00:03:28.000
私たちのサンプルには、アプリケーション用のローカルコンテナがあり、USGSのJSONフィードから地震データを収集します。

00:03:28.000 --> 00:03:38.000
データをダウンロードすると、それをJSONパーサーに引き継ぎ、それをバックグラウンドコンテキストにインポートして、管理オブジェクトに変換され、ローカルストアに保存されます。

00:03:38.000 --> 00:03:43.000
その後、ビューコンテキストは変更をマージして、UIを魔法のように更新します。

00:03:43.000 --> 00:03:50.000
2020年には、バッチ操作を使用してこのデータを効率的に処理する方法に焦点を当てました。

00:03:50.000 --> 00:03:54.000
しかし、今、これらの操作を同時に実行する方法に焦点を当てたいと思います。

00:03:54.000 --> 00:04:01.000
特に、アプリケーションにデータをインポートするために取る3つのステップに焦点を当てたいと思います。

00:04:01.000 --> 00:04:09.000
ステップ1は、生データをダウンロードすることであり、ダウンロードが成功すると、アプリケーションはそれを特定のローカル表現に変換する必要があります。

00:04:09.000 --> 00:04:13.000
そして最後に、新しいオブジェクトを永続ストアに保存します。

00:04:13.000 --> 00:04:17.000
これを高レベルのコードに変換しましょう。

00:04:17.000 --> 00:04:21.000
各操作を独自の機能またはクロージャに抽象化しました。

00:04:21.000 --> 00:04:35.000
アプリは最初にサーバーから生データを取得し、それを便利なローカル表現に処理し、バックグラウンド管理オブジェクトコンテキストでバッチ挿入要求を行うことでオブジェクトをコアデータにインポートします。

00:04:35.000 --> 00:04:40.000
このように書かれているので、潜在的なボトルネックを視覚化するのは少し簡単です。

00:04:40.000 --> 00:04:46.000
ネットワーク経由でデータをロードすることは、非同期に作業を行うことを検討する絶好の機会です。

00:04:46.000 --> 00:04:49.000
変換も考慮すべき場所かもしれません。

00:04:49.000 --> 00:04:55.000
さらに、永続的なストアにデータをインポートすることは非常に適切なようです。

00:04:55.000 --> 00:05:05.000
しかし、歴史的に、これらすべてのケースでは、そのような非同期メカニズムを自分で実装するか、フレームワーク固有の実装に大きく依存する必要があります。

00:05:05.000 --> 00:05:10.000
コアデータの特定の抽象化について話しましょう。

00:05:10.000 --> 00:05:19.000
Core Dataの場合、performAndWaitを呼び出すと、管理オブジェクトコンテキストは、独自の保護された実行環境内で提供されたクロージャを実行します。

00:05:19.000 --> 00:05:24.000
これは、作業が完了するまで呼び出しスレッドを結びつける可能性があります。

00:05:24.000 --> 00:05:32.000
これを視覚化すると、前、中、後にラベル付けした3つのコードブロックを想像できます。

00:05:32.000 --> 00:05:39.000
コードが実行されると、最初にBEFOREというラベルの付いたコードが、元のスレッドで実行する機会を得ます。

00:05:39.000 --> 00:05:47.000
次に、performAndWaitを呼び出し、呼び出しスレッドは、クロージャ中に発生する作業が完了するまでブロックされます。

00:05:47.000 --> 00:05:52.000
その作業が完了すると、AFTERで説明されたコードが実行されます。

00:05:52.000 --> 00:05:58.000
もちろん、閉鎖が終了するのを待つ必要がない場合は、常に完全非同期バリアントを提供してきました。

00:05:58.000 --> 00:06:09.000
しかし、今年新しく、Swiftは、コアデータがAPIの意図をより正確に記述することを可能にする深い言語統合を備えた強力な並行性モデルを獲得しました。

00:06:09.000 --> 00:06:11.000
構文は少し異なります。

00:06:11.000 --> 00:06:22.000
実行の結果を待つように頼みますが、この新しいAPIを使用するためのメンタルモデルは、管理オブジェクトが常にサポートしてきたものとまったく同じです。

00:06:22.000 --> 00:06:30.000
しかし、利点は、並行性がもはや隠された実装の詳細ではなく、代わりにSwift言語に深く統合されていることです。

00:06:30.000 --> 00:06:43.000
このため、コンパイラは、データレースやデッドロックなどの多くの一般的な並行性バグを自動的に防止し、タスクが結果を待っていることが知られているときにリソースを効率的に利用することさえできます。

00:06:43.000 --> 00:06:49.000
コードに戻って、実際にこれを使うのがどのようなものか見てみましょう。

00:06:49.000 --> 00:06:53.000
私たちが見たように、あなたは非同期宣言された関数を待つように頼みます。

00:06:53.000 --> 00:07:01.000
これは、非同期関数が返すことによって制御を生成するまで、呼び出し実行コンテキストを一時停止する可能性があります。

00:07:01.000 --> 00:07:11.000
また、予想通り、スローされたエラーを呼び出しフレームにルーティングすることで、Swiftの既存の構造化エラー処理とシームレスに連携します。

00:07:11.000 --> 00:07:25.000
非同期関数を呼び出す例を見たので、管理オブジェクトコンテキスト内で非同期作業を実行するCore Dataのまったく新しい方法を見て、それらがどのように宣言されているかを見てみましょう。

00:07:25.000 --> 00:07:36.000
Swiftコードのこの小さなスタンザにはかなりの機能が詰め込まれていますが、私はいくつかの重要な詳細について話すだけで、実際にそれを使用する方法を示すことに飛びつきます。

00:07:36.000 --> 00:07:39.000
新しい実行オーバーロードの宣言から始めます。

00:07:39.000 --> 00:07:50.000
返すことができる結果の種類に基づいてジェネリックであり、Swiftの新しい並行性機能にこの機能を選択する新しいasyncキーワードで装飾されていることがわかります。

00:07:50.000 --> 00:08:02.000
おそらく、この新しいAPIの最も重要な側面は、提供されたクロージャにより、エラーをスローしたり、値を返したりできるようになり、これらを手動で呼び出しフレームに戻す手間を節約できることです。

00:08:02.000 --> 00:08:07.000
いくつかの異なるシナリオを探求して、これがどれほどクールか見てみましょう。

00:08:07.000 --> 00:08:20.000
歴史的に、並行性が実装内に隠れていたため、performAndWaitの外部にエラーをルーティングする唯一の方法の1つは、オプションを閉じてからチェックすることでした。

00:08:20.000 --> 00:08:33.000
完了ハンドラーを渡し、それらを一貫して使用していることを確認することで、多くの配管を行う必要があるため、完全に非同期バージョンのパフォーマンスを使用している場合、これはより複雑になる可能性があります。

00:08:33.000 --> 00:08:37.000
Swiftの新しい並行性モデルでは、その配管のすべてがあなたのために処理されます!

00:08:37.000 --> 00:08:47.000
試してみて、あなたの非同期作業を待つだけで、エラーが発生した場合は、それをスローするだけで、物事は自然に呼び出しフレームに巻き戻されます。

00:08:47.000 --> 00:08:51.000
だから今、私たちはエラーに焦点を当てましたが、結果はどうですか?

00:08:51.000 --> 00:08:54.000
さて、私が説明したものはすべてまったく同じように機能します。

00:08:54.000 --> 00:08:57.000
具体的な例を見てみましょう。

00:08:57.000 --> 00:09:01.000
コードに飛び込む前に、やりたいことをスケッチしましょう。

00:09:01.000 --> 00:09:09.000
この例では、過去5時間に発生した地震の数を識別するためのフェッチ要求を設定したいと思います。

00:09:09.000 --> 00:09:13.000
文として、これは説明するのが簡単な作業です。

00:09:13.000 --> 00:09:17.000
しかし、コードでは、物事を少し並べ替える必要があります。

00:09:17.000 --> 00:09:26.000
まず、5時間前がいつだったかを把握する必要があります。そのため、カレンダーAPIを使用して、これを堅牢な方法で計算できます。

00:09:26.000 --> 00:09:33.000
次に、その日付に関する述語でフェッチ要求を設定し、カウント結果タイプを要求します。

00:09:33.000 --> 00:09:37.000
コードでは、それは私たちの計画とほぼよく似ています。

00:09:37.000 --> 00:09:49.000
カレンダーのオフセットAPIを使用して、今から5時間前に計算し、気になる日付と一致する述語でカウント結果を返すようにQuake FetchRequestを設定します。

00:09:49.000 --> 00:09:54.000
歴史的に、結果を返すことは、エラーをキャプチャする方法と同様のパターンに従っていた。

00:09:54.000 --> 00:10:05.000
変異する必要がある状態を閉じ、管理対象オブジェクトコンテキストで計算を実行し、後で制御を取り戻した後に結果を使用します。

00:10:05.000 --> 00:10:14.000
これで、実行コールの結果を待って、実行結果を呼び出しフレームに直接返すことができます。

00:10:14.000 --> 00:10:17.000
残りのコードはまったく同じです。

00:10:17.000 --> 00:10:26.000
それは、そのコードが持っていたかもしれない潜在的なバグやニュアンスと一緒に避けるのは、手による値ルーティングだけです。

00:10:26.000 --> 00:10:30.000
この新しいコードは非常に簡潔で表現力豊かです。

00:10:30.000 --> 00:10:35.000
しかし、注意すべき時があることに言及する価値があります。

00:10:35.000 --> 00:10:39.000
別の例を見て、その理由を見てみましょう。

00:10:39.000 --> 00:10:44.000
この例では、最新の地震を管理対象として返そうとします。

00:10:44.000 --> 00:10:53.000
新しいAPIを使用すると、値を返すのが本当に簡単になりますが、すでに管理オブジェクトコンテキストに登録されている管理オブジェクトを返すのは安全ではありません。

00:10:53.000 --> 00:11:00.000
実行する呼び出しの終了中にそのような登録されたオブジェクトを参照することはのみ有効です。

00:11:00.000 --> 00:11:15.000
代わりに、異なる実行コンテキスト間で管理オブジェクトを参照する必要がある場合は、オブジェクトIDを使用して必要に応じて再フェッチするか、フェッチ要求の辞書表現オプションを使用します。

00:11:15.000 --> 00:11:21.000
もう1つの例を見る前に、まだ話していない詳細を取り上げたいと思います。

00:11:21.000 --> 00:11:23.000
そして、その詳細はSchededTaskTypeです。

00:11:23.000 --> 00:11:32.000
これまでのところ、私たちが見てきたすべての非同期パフォーマンスは、このオプションのデフォルト値の観点からです: .immediate。

00:11:32.000 --> 00:11:43.000
.Enqueuedと呼ばれる2番目のオプションがあり、これら2つのスケジューリングアプローチの違いを理解するために、作業をスケジュールするように依頼するときに、管理オブジェクトコンテキスト内で具体的に何が起こるかを考えるのに役立ちます。

00:11:43.000 --> 00:11:50.000
ご覧のとおり、.immediateはSwift-async-awareバージョンのperformAndWaitによく似ています。

00:11:50.000 --> 00:12:05.000
別の実行コンテキストで実行していて、バックグラウンドコンテキストで実行される作業を待つように依頼する場合は、スケジュールされて完了するまで待ちます。

00:12:05.000 --> 00:12:13.000
ただし、すでに同じ実行コンテキストにいる場合、作業はすぐに楽観的にスケジュールされます。

00:12:13.000 --> 00:12:16.000
一方、.enqueuedは少し簡単です。

00:12:16.000 --> 00:12:24.000
元のコールサイトの親和性に関係なく、常にコンテキストの作業セットの最後に要求された作業を追加するだけです。

00:12:24.000 --> 00:12:27.000
先に進んで、もう1つの例を見てみましょう。

00:12:27.000 --> 00:12:31.000
これらの非同期機能はすべて、あなたも採用できます。

00:12:31.000 --> 00:12:40.000
ここでは、私たちが話していたインポートロジックを、新しいasyncキーワードで装飾された新しいimportQuakes関数に因数分解しました。

00:12:40.000 --> 00:12:46.000
この機能は、順番に、他の非同期機能の観点から実装されています。

00:12:46.000 --> 00:12:52.000
今、誰もがSwiftの新しい並行性機能を利用するために、この新しい機能を待つことができます。

00:12:52.000 --> 00:12:55.000
これまでに見たものをまとめましょう。

00:12:55.000 --> 00:13:02.000
全体として、この新しいAPIは、Swiftの構造化された並行性のサポートをコアデータにもたらします。

00:13:02.000 --> 00:13:11.000
実行APIの新しいバリアントは、あなたがすでに知っていて愛している既存のCore Data APIのSwift並行性対応バージョンです。

00:13:11.000 --> 00:13:17.000
アプリケーションでこの新しいAPIを利用することを強くお勧めします。

00:13:17.000 --> 00:13:25.000
さらに、NSManagedObjectContextは、保護された並行性ドメイン内でタスクの実行をサポートするコアデータの唯一のタイプではありません。

00:13:25.000 --> 00:13:31.000
また、NSPersistentContainerとNSPersistentStoreCoordinatorの両方に同様のAPIを追加しています。

00:13:31.000 --> 00:13:36.000
これらのAPIの一般的な形状と動作は、私がすでに説明したものと非常によく似ています。

00:13:36.000 --> 00:13:45.000
しかし、そのすべての同時パワーで、私はあなたが自由に使える既存のデバッグツールを使用するというアドバイスを提供しないのは怠慢です。

00:13:45.000 --> 00:13:52.000
もちろん、Xcodeが提供するアドレスとスレッドサニタイザーは、存在すら知らないかもしれないバグをキャッチするのに非常に役立ちます。

00:13:52.000 --> 00:13:59.000
これらは両方とも、スキームエディタの実行設定の診断ペインにあります。

00:13:59.000 --> 00:14:08.000
各サニタイザーは、安全なメモリ使用の仮定の検証や、複数のスレッドからのデータの適切な使用など、さまざまな種類の問題を検出します。

00:14:08.000 --> 00:14:17.000
ソフトウェアをユーザーのコミュニティにリリースする前に、アプリケーションと関連するテストを両方のサニタイザーで認定することは常に良い考えです。

00:14:17.000 --> 00:14:27.000
また、サニタイザーはすべてのコンテキストで役立ちますが、Core Dataは、より多くのドメイン固有のヘルプを得るために有効にできる特別なランタイムフラグを提供していることを強調したいと思います。

00:14:27.000 --> 00:14:40.000
このオプションを有効にすると、Core Dataは内部ロックを検証し、さまざまなCore Dataタイプの適切な使用を確認するために、多くの有用なアサーションをオンにします。

00:14:40.000 --> 00:14:44.000
今年のコアデータの変更は、Swift並行性サポートの採用だけではありません。

00:14:44.000 --> 00:14:55.000
CloudKitの共有から新しいSpotlight統合まで、私たちが導入するすべての新しいAPIは、Swiftでのプレゼンテーションを念頭に置いて作られています。

00:14:55.000 --> 00:15:01.000
今年は、これらのトピックごとに別々のセッションがあり、それらをチェックすることをお勧めします。

00:15:01.000 --> 00:15:14.000
さらに、Swiftを改善できる他の場所を特定するために、フレームワーク全体を通過しました。私たちがサポートするさまざまな永続的なストアの種類から始めて、これらのいくつかを紹介したいと思います。

00:15:14.000 --> 00:15:20.000
リコール、永続的なストアは、顧客のデータを物理的にどのように保存したいかを説明しています。

00:15:20.000 --> 00:15:27.000
Core Dataは現在、XML、バイナリ、インメモリ、SQLiteの4つのストアを提供しています。

00:15:27.000 --> 00:15:31.000
そして、あなたはこれらの識別子を常に使用します。

00:15:31.000 --> 00:15:36.000
今年の新しい、私たちは先に進み、スウィフトでこれらのより自然な名前を与えました。

00:15:36.000 --> 00:15:47.000
既存の名前は引き続き機能しますが、これらを消費する新しいAPIは、名前が短く、これらのシンボルをオートコンプリートできるため、はるかに人間工学的になります。

00:15:47.000 --> 00:15:53.000
もちろん、コアデータでは、タイプに関係する永続的なストアだけではありません。

00:15:53.000 --> 00:16:00.000
結局のところ、フレームワークは型付きデータの保存がすべてであり、そのような型は属性記述で説明されています。

00:16:00.000 --> 00:16:09.000
そして今年は、それらのタイプを操作するためのはるかに自然な構文を提供する属性記述に新しい拡張可能な列挙を追加します。

00:16:09.000 --> 00:16:17.000
ランタイムモデルがXcodeモデルビルダーで設計したものと一致することを検証できるユニットテストを書いて、これらの動作を見てみましょう。

00:16:17.000 --> 00:16:26.000
簡単にするために、地震オブジェクトモデルで定義された単一のランタイムタイプを検証しようとしますが、これがどのように拡大するかを想像できます。

00:16:26.000 --> 00:16:34.000
これは書くべき小さなテストのように思えるかもしれませんが、将来的にはより興味深い診断をスピードアップすることができるので、検証するのは良いことです。

00:16:34.000 --> 00:16:39.000
このテストを書くために、新しい属性タイプの観点からクイックヘルパー関数を書きます。

00:16:39.000 --> 00:16:42.000
さあ、この機能を説明しましょう。

00:16:42.000 --> 00:16:53.000
属性名、関心のあるエンティティの説明、および新しいAttributeType列挙の観点から記述されたタイプを期待する署名から始めます。

00:16:53.000 --> 00:16:56.000
このユーティリティの定義はかなり簡単です。

00:16:56.000 --> 00:17:03.000
まず、提供された名前の属性があることを検証し、見つからない場合はテストに失敗します。

00:17:03.000 --> 00:17:06.000
そして、属性のタイプが期待どおりであることを検証します。

00:17:06.000 --> 00:17:08.000
そして、それが本当にそれにあるすべてです。

00:17:08.000 --> 00:17:17.000
エンティティとプロパティごとにこれを繰り返し、ランタイムの動作が定義したモデルと一致するという安心感を享受できます。

00:17:17.000 --> 00:17:26.000
そして、これは、今年Swiftでコアデータの列挙に対して行った人間工学に基づいた改善のほんの一例です。

00:17:26.000 --> 00:17:35.000
今まで、私は多くの低レベルのフレームワークインタラクションと、それらがSwiftでどのように現れるかに焦点を当ててきましたが、ユーザーにデータを提示するのはどうですか?

00:17:35.000 --> 00:17:41.000
2020年には、SwiftUIでCore Dataを操作するための多くの便利さを導入しました。

00:17:41.000 --> 00:17:47.000
そして今、私の同僚のスコットは、私たちが今年導入する新しい機能強化についてあなたと共有したいことがたくさんあります。

00:17:47.000 --> 00:17:48.000
スコット？

00:17:48.000 --> 00:17:49.000
ありがとう、マイケル！

00:17:49.000 --> 00:18:03.000
今年は、フェッチ要求の怠惰なエンティティ解決から始めて、SwiftUIでコアデータを使用する経験に多くの改善があります。これにより、アプリがビューを構築する前にコアデータスタックを設定するという要件が緩和されます。

00:18:03.000 --> 00:18:10.000
また、今年、フェッチリクエストは、ソート記述子と述語の動的設定をピックアップします。

00:18:10.000 --> 00:18:15.000
そして、町には、セクション化されたフェッチをサポートする新しい種類のフェッチリクエストがあります。

00:18:15.000 --> 00:18:24.000
マイケルが講演で先に言及した地震サンプルアプリを使用して、怠惰なエンティティ解決から始めて、これらのそれぞれを歩きます。

00:18:24.000 --> 00:18:28.000
おそらくあなたのアプリには、このようなコードがあります。

00:18:28.000 --> 00:18:35.000
このコンテナプロパティは、このタイプのコード、さらにはより広範なアプリをサポートするために本当に必要ではありません。

00:18:35.000 --> 00:18:39.000
そのすべてのものは、QuakesProviderタイプから直接必要なものを手に入れます。

00:18:39.000 --> 00:18:49.000
いいえ、このプロパティは、モデルがロードされる前に、環境内のビューがエンティティを参照しようとする前に、コアデータスタックが設定されていることを確認するために存在します。

00:18:49.000 --> 00:18:57.000
ContentViewが初期化された後に環境ビュー修飾子が呼び出されることをここで参照してください。

00:18:57.000 --> 00:19:02.000
今年のSDKに対して展開する場合、このトリックはもう必要ありません。

00:19:02.000 --> 00:19:16.000
FetchRequestプロパティラッパーは、フェッチ時に名前でエンティティを怠惰にルックアップし、その時点で環境はコアデータスタックが設定されていることを保証しているので、このプロパティを削除しても安全です...

00:19:16.000 --> 00:19:20.000
そして、ただ参照してください...

00:19:20.000 --> 00:19:25.000
QuakesProviderは、環境コールで直接コンテナを共有しました。

00:19:25.000 --> 00:19:31.000
いくつかの新しいAPIに移ると、FetchRequestは動的設定をサポートするようになりました。

00:19:31.000 --> 00:19:53.000
ラップされた値には、リクエストの述語とそのソート記述子を直接変更するための2つの新しいプロパティがあります。これは、慣れているNSSortDescriptorsと、自動的に生成された管理オブジェクトサブクラスでエンティティを取得するときに、より利便性と安全性を提供する新しいSortDescriptor値タイプの両方で表現されます。

00:19:53.000 --> 00:20:00.000
そして最後に、ビューとの統合を容易にするために、ラップされた値と同じプロパティセットを持つ構成バインディングがあります。

00:20:00.000 --> 00:20:14.000
この新しいAPIの前に、ソートと述語のパラメータがビューの初期化子に渡されるようにビューを設計する必要がありましたが、ツールバーのコントロールを使用してフェッチ要求を設定するなどをサポートするのは本当に困難でした。

00:20:14.000 --> 00:20:23.000
この摩擦は、これらの新しい動的構成プロパティによって排除され、地震サンプルアプリにソートとフィルタリングを追加して、それらを使用する方法を紹介ししたいと思います。

00:20:23.000 --> 00:20:26.000
最初にソート記述子を見てみましょう。

00:20:26.000 --> 00:20:36.000
デフォルトでは、地震アプリは最新性で並べ替えますが、大きさで並べ替えたいので、結果の順序を制御できるメニューを追加します。

00:20:36.000 --> 00:20:41.000
タプルの静的配列を追加することから始めます...

00:20:41.000 --> 00:20:46.000
私がサポートしたいソート記述子とそれらの名前が含まれています。

00:20:46.000 --> 00:20:52.000
彼らが新しいSortDescriptorタイプも使用していることをここで確認してください。

00:20:52.000 --> 00:20:58.000
また、現在使用しているソート順を追跡するための状態も少し必要です。

00:20:58.000 --> 00:21:05.000
私はすでにこのタイプを作成したので、コンテンツビューのプロパティとして追加します。

00:21:05.000 --> 00:21:11.000
次に、リストビューにツールバーメニューを追加します...

00:21:11.000 --> 00:21:20.000
これは、選択したソートと、フェッチ要求のソート記述子を更新するonChange修飾子を変更します。

00:21:20.000 --> 00:21:27.000
プレビューでは、新しいメニューを見ることができ、それを使って地震をマグニチュードで並べ替えることができます。

00:21:27.000 --> 00:21:29.000
すごい！

00:21:29.000 --> 00:21:32.000
次に、フィルタリングを追加します。

00:21:32.000 --> 00:21:36.000
地震の場所に基づいてフィルタリングしたいと思います。 

00:21:36.000 --> 00:21:42.000
最初に必要なのは、検索フィールドのテキストの状態です。

00:21:42.000 --> 00:21:48.000
そして、私はバインディングプロパティを作ります...

00:21:48.000 --> 00:21:56.000
フェッチ要求を更新する検索フィールド。

00:21:56.000 --> 00:21:59.000
それらがあれば、必要なのはUIだけです。

00:21:59.000 --> 00:22:04.000
便利に...

00:22:04.000 --> 00:22:11.000
Searchableは文字列へのバインディングを取るので、ここでそれをドロップすることができます。

00:22:11.000 --> 00:22:22.000
さて、プレビューでは、この新しいフィールドに「サンドイッチ」と入力するだけで、サンドイッチに一致する場所の近くのすべての地震を絞り込むことができます。

00:22:22.000 --> 00:22:25.000
そして、それはFetchRequestの動的設定です。

00:22:25.000 --> 00:22:35.000
もう1つの一般的に要求される機能は、セクションフェッチフェッチと呼ばれる新しいプロパティラッパータイプとして今年到着するセクションフェッチのサポートです。

00:22:35.000 --> 00:22:50.000
このタイプは、FetchRequestと同じ新しい動的構成プロパティをサポートしていますが、NSFetchedResultsControllerのように、セクションを識別するプロパティへのキーパスである追加のパラメータで初期化されます。

00:22:50.000 --> 00:22:57.000
しかし、フェッチされた結果コントローラとは異なり、セクションを識別するプロパティは、ハッシュ可能である限り、好きなタイプを持つことができます。

00:22:57.000 --> 00:23:05.000
これは、SectionedFetchRequestの追加の汎用パラメータを使用して、型システムでエンコードされます。

00:23:05.000 --> 00:23:09.000
最後に、この新しいタイプは2次元の結果タイプをラップします。

00:23:09.000 --> 00:23:15.000
SectionedFetchResultsはセクションのコレクションであり、それぞれが結果のコレクションです。

00:23:15.000 --> 00:23:21.000
各セクションには、セクション識別子を持つプロパティもあります。

00:23:21.000 --> 00:23:26.000
これは本当に簡単に採用できるので、Earthquakesアプリにセクションのフェッチを追加します。

00:23:26.000 --> 00:23:34.000
まず、FetchRequest宣言を更新します。

00:23:34.000 --> 00:23:41.000
Quakeはすでに1日のプロパティを持っているので、私はそれをセクションキーパスに使用するつもりです。

00:23:41.000 --> 00:23:49.000
次に、ボディプロパティを更新する必要があります...

00:23:49.000 --> 00:23:53.000
新しいセクションの結果タイプに一致させる。

00:23:53.000 --> 00:24:12.000
ここの外側のループはセクションを反復するので、私はここでセクションビューを発行しており、各セクション自体はクエイクのコレクションであるため、この内側のForEachは、以前に結果を反復していたのと同じように、セクションを反復します。

00:24:12.000 --> 00:24:18.000
プレビューを見ると、地震は時間ごとに注文され、日ごとに分割されています。

00:24:18.000 --> 00:24:27.000
また、SwiftUIは、折りたたむセクションの自動サポートも提供してくれます。

00:24:27.000 --> 00:24:39.000
この新しい SectionedFetchRequest タイプは、FetchRequest と同じ動的構成プロパティと、セクション識別子キー パスの追加構成プロパティをサポートしています。

00:24:39.000 --> 00:24:44.000
ソートを変更することは実際には安全ではないので、これは非常に重要です。

00:24:44.000 --> 00:24:53.000
時間と地震のマグニチュードが完全に相関していないため、セクションが不連続になる可能性があり、これはおそらく最善です。

00:24:53.000 --> 00:24:59.000
これを修正するには、ソートをトップに更新する必要があります...

00:24:59.000 --> 00:25:05.000
それぞれに、対応するセクション識別子キーパスがあります。

00:25:05.000 --> 00:25:09.000
次に、ツールバーの下...

00:25:09.000 --> 00:25:16.000
ソート記述子を更新するたびに、セクション識別子キーパスを更新する必要があります。

00:25:16.000 --> 00:25:19.000
しかし、ここに重要な部分があります。

00:25:19.000 --> 00:25:29.000
リクエストの変更は、結果ゲッターが呼び出されるたびにコミットされるので、ソートとセクションの両方を安全に更新するために...

00:25:29.000 --> 00:25:36.000
ローカルにプルした結果を参照して設定を更新する必要があります。

00:25:36.000 --> 00:25:42.000
プレビューでは、順序を変更するとセクションも変更されることがわかります。

00:25:42.000 --> 00:25:54.000
時間順に並べられた地震と、日ごとに並べられた地震と、大きさ順に並べられた地震を切り替えることができます。

00:25:54.000 --> 00:26:07.000
そして、そこには、遅延スタックの初期化、動的設定、セクション化されたフェッチがあり、すべてiOS 15とmacOS Montereyを使用して既存のアプリに簡単に適用できます。

00:26:07.000 --> 00:26:15.000
要約すると、Core Dataは、Appleのすべてのプラットフォームでアプリのデータ永続性のニーズを管理するためのワンストップショップです。

00:26:15.000 --> 00:26:24.000
新しいパフォーマンスAPIを通じてSwiftで利用可能な新しい並行性機能を活用し、強力なスレッド安全デバッグが組み込まれています。

00:26:24.000 --> 00:26:34.000
ストアと属性タイプをSwiftで使用するのをさらに自然にする新しい列挙インターフェイスに加えて、CloudKitの共有とSpotlightの統合があります。

00:26:34.000 --> 00:26:43.000
また、動的設定とセクション化されたフェッチを備えたSwiftUIを使用して、データをビューに接続するのがこれまで以上に簡単になりました。

00:26:43.000 --> 00:26:46.000
これらのトピックに関連して学ぶべき新しいことがたくさんあります。

00:26:46.000 --> 00:26:52.000
「SwiftUIで簡素化し、Swiftの並行性を満たす」コレクションをチェックすることをお勧めします。

00:26:52.000 --> 00:26:53.000
そして、それだけです!

00:26:53.000 --> 00:26:57.000
皆さんがこれらの新しいAPIで何を構築するかを本当に楽しみにしています。

00:26:57.000 --> 23:59:59.000
[明るい音楽]。

