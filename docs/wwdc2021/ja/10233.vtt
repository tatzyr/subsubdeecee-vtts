WEBVTT

00:00:00.000 --> 00:00:05.000
♪ベース音楽の演奏♪

00:00:05.000 --> 00:00:10.000
♪

00:00:10.000 --> 00:00:14.000
ジョナサン・ホッグ：こんにちは、加速と関連するフレームワークに関するこのセッションへようこそ。

00:00:14.000 --> 00:00:24.000
私はAppleのVector&amp;NumericsチームのJonathanです。今日は、機械学習ライブラリであるBNNSの新機能を伝える前に、Accelerateフレームワークについて簡単にお話しします。

00:00:24.000 --> 00:00:32.000
次に、simd.hの改善点を取り上げ、Apple Archiveと新しいApple Encrypted Archiveコンテナを紹介します。

00:00:32.000 --> 00:00:37.000
それでは、Accelerateフレームワークの簡単な概要から始めましょう。

00:00:37.000 --> 00:00:48.000
Accelerateは、MacOS、iOS、iPadOS、watchOS、tvOSなど、すべてのAppleプラットフォームで高性能な数値計算を提供します。

00:00:48.000 --> 00:00:55.000
Accelerateは、Apple Silicon Macや最近のiPhoneやiPadデバイスの機械学習アクセラレータへのアクセスも提供します。

00:00:55.000 --> 00:01:03.000
このハードウェアを活用する唯一の方法は、直接、またはCore MLなどの高レベルのフレームワークを介してAccelerateを呼び出すことです。

00:01:03.000 --> 00:01:06.000
Accelerateはいくつかの部分で構成されています。

00:01:06.000 --> 00:01:11.000
vDSPは、DFTやFFTルーチンなどの信号処理のためのプリミティブを提供します。

00:01:11.000 --> 00:01:17.000
vImageは、フォーマット変換や畳み込みなどの画像処理のルーチンを提供します。

00:01:17.000 --> 00:01:23.000
vForceは、正弦やコサインなどの超越関数のベクトル化されたバージョンを提供します。

00:01:23.000 --> 00:01:33.000
BLASとLAPACKは、標準の高密度行列代数ルーチンの高性能移植を提供し、スパースBLASとスパースソルバーはスパース行列に同様の機能を提供します。

00:01:33.000 --> 00:01:39.000
最後に、BNNSは機械学習のサポートを提供します。

00:01:39.000 --> 00:01:43.000
今日は、関連するフレームワークについてもお話しします。また、関連するフレームワークについてお話しします。

00:01:43.000 --> 00:01:54.000
simd.hは、グラフィックスプログラミングでカバーされているような計算された小さなベクトルと行列を提供し、圧縮とApple Archiveはロスレスデータ圧縮をサポートします。

00:01:54.000 --> 00:02:03.000
これらのフレームワークを使用するには、関連するインクルードまたはインポートステートメントをコードに追加し、フレームワークをXcodeプロジェクトに追加するだけです。

00:02:03.000 --> 00:02:07.000
さて、BNNSについてもっと詳しくお話ししましょう。

00:02:07.000 --> 00:02:14.000
BNNSはBasic Neural Network Subroutinesの略で、CPUでの機械学習のパフォーマンスプリミティブを提供します。

00:02:14.000 --> 00:02:19.000
Appleの機械学習エコシステムに不慣れな方のために、この図は土地のレイアウトを示しています。

00:02:19.000 --> 00:02:29.000
3つの主要なハードウェアブロックがあります。前に述べた機械学習アクセラレータを含むCPU、GPU、そして別のニューラルエンジンです。

00:02:29.000 --> 00:02:37.000
BNNSは、MPSがGPUでパフォーマンスプリミティブを提供するのと同じように、CPUでパフォーマンスプリミティブを提供します。

00:02:37.000 --> 00:02:42.000
このレイヤーの上には、これらのバックエンドの1つ以上で実行される多くのフレームワークがあります。

00:02:42.000 --> 00:02:51.000
これらには、Appleの高レベルの機械学習フレームワークであるCore MLとCreate ML、およびVisionやNatural Languageなどの専門的なフレームワークが含まれます。

00:02:51.000 --> 00:02:59.000
BNNSは、幅広いレイヤータイプにわたるトレーニングと推論の両方のサポートと、下部に示されているオプティマイザのサポートを提供します。

00:02:59.000 --> 00:03:09.000
このリリースでは、埋め込み、ランダムフィル、クオンタイズ化、AdamWオプティマイザのサポートなど、いくつかの新しいレイヤータイプのサポートを追加しました。

00:03:09.000 --> 00:03:24.000
また、既存のレイヤーを改善し、SiLUとHardSwishの2つの新しいアクティベーション機能を追加し、三項選択、乗算加算、要素ごとの最小値と最大値の新しい算関数のサポートを追加しました。

00:03:24.000 --> 00:03:34.000
レイヤーフュージョンは、後続のレイヤーへの入力として1つのレイヤーの出力をすぐに消費する機能を提供し、メモリに書き出して再度読み込む必要がなくなります。

00:03:34.000 --> 00:03:42.000
畳み込みのレイヤー融合と、新しい量子化レイヤーと完全に接続されたレイヤー、および算術レイヤーと正規化レイヤーの融合を追加しました。

00:03:42.000 --> 00:03:53.000
その他の改善には、スタンドアロン機能としても使用できるオプティマイザのグラデーションクリッピングのサポートの改善や、AdamベースのオプティマイザのAMSGradサポートが含まれます。

00:03:53.000 --> 00:03:59.000
一緒に、これらの改善は、私たちがさらに加速できる範囲とネットワークアーキテクチャを拡大しました。

00:03:59.000 --> 00:04:03.000
さて、simd.hの改善点についてお話ししましょう。

00:04:03.000 --> 00:04:16.000
simd.hは、正弦や余弦などの関数のサポートや、四元数のサポートを含む有用な幾何学的演算など、CPUのレジスタに収まる小さなベクトルと行列の計算プリミティブを提供します。

00:04:16.000 --> 00:04:24.000
私がsimd.hについて本当に好きなのは、私たちが飛び込んで、10%の努力でベクトル化の利点の90%を得ることができるということです。

00:04:24.000 --> 00:04:26.000
ほら、お見せしましょう。

00:04:26.000 --> 00:04:29.000
これは私が発明したばかりのニューラルネットワーク活性化機能です。

00:04:29.000 --> 00:04:32.000
ご覧のとおり、それは3つの異なる枝を持っています。

00:04:32.000 --> 00:04:36.000
入力がマイナス円周率より小さい場合は、ゼロを返すだけです。

00:04:36.000 --> 00:04:42.000
マイナスπとπの間にある場合、xの指数の2倍にx+πを2倍に掛けて返します。

00:04:42.000 --> 00:04:47.000
そうでなければ、円周率より大きい場合は、指数の2倍を返します。

00:04:47.000 --> 00:04:53.000
それは素晴らしいことですが、大量のデータがある場合は、スカラーループが許すよりも速く実行したいと思うかもしれません。

00:04:53.000 --> 00:04:56.000
それでは、それをsimdで実装する方法をお見せしましょう。

00:04:56.000 --> 00:05:10.000
私はすでにいくつかのボイラープレート、バッファにベクトルを簡単に書き込むことができる拡張機能、および一度に1つの長さ8ベクトルの増分で出力配列を反復する単純なループを持っています。

00:05:10.000 --> 00:05:14.000
興味深い部分は、スカラー関数を同等のsimdに変換する方法です。

00:05:14.000 --> 00:05:16.000
スカラーコードをもう一度見ることから始めましょう。

00:05:16.000 --> 00:05:18.000
枝がいくつかあるのがわかります。

00:05:18.000 --> 00:05:20.000
これらはベクトル化にはうまく機能しません。

00:05:20.000 --> 00:05:26.000
代わりに、マスクに基づいてマージできる部分からこれを構成しましょう。

00:05:26.000 --> 00:05:31.000
もっとよく見ると、xがマイナスπより小さい場合、私はゼロを返すだけです。

00:05:31.000 --> 00:05:38.000
大きい場合は、xの2倍の指数を含む式を返します。

00:05:38.000 --> 00:05:41.000
それを引き抜きましょう。

00:05:41.000 --> 00:06:00.000
さて、そのyからベクトルを構築し、xが要素的にマイナスpiよりも小さいすべての場所でゼロに置き換えます。

00:06:00.000 --> 00:06:02.000
次に、より大きなケースを見ることができます。

00:06:02.000 --> 00:06:09.000
ここでは、高い領域で1を掛けるか、中央の領域でxとπを2で乗算します。

00:06:09.000 --> 00:06:12.000
だから、同じように書きましょう。

00:06:12.000 --> 00:06:30.000
2つの式にx+piを取り、今回はxが要素的にpi以上であるすべての場所で1つに置き換えます。

00:06:30.000 --> 00:06:35.000
今残っているのは、これら2つの量を一緒に乗算することだけです。

00:06:35.000 --> 00:06:44.000
明らかに、ゼロ要素の場合、bのいずれかの値を掛けると、依然としてゼロが返されます。

00:06:44.000 --> 00:06:53.000
だから、それを実行して、それがどのように見えるか見てみましょう。

00:06:53.000 --> 00:07:02.000
今、コンソールを見下ろすと、私の新しいsimdバージョンは以前のスカラーコードのほぼ3倍高速であることがわかります。

00:07:02.000 --> 00:07:05.000
では、このリリースでsimdはどのように改善されますか?

00:07:05.000 --> 00:07:09.000
テンプレートを使用してC++プログラマーの使いやすさを向上させました。

00:07:09.000 --> 00:07:20.000
複雑なコード構造や同様の型を自分で実装することなく、基礎となるスカラー型とベクトル長と具体的なsimd型の間を移動できるように、型と特性構造を追加しました。

00:07:20.000 --> 00:07:27.000
使用を簡素化するために、C++ボイラープレートの必要性を減らすために便利なエイリアスも追加しました。

00:07:27.000 --> 00:07:29.000
これは、それらが使用中どのように見えるかの例です。

00:07:29.000 --> 00:07:43.000
ベクトル型と行列型は、floatやintなどの基礎となる型とベクトル長から具体的な型に移動し、非整列バージョンや比較結果のマスク型などの関連型へのアクセスを提供するメンバーも許可します。

00:07:43.000 --> 00:07:49.000
Vector_tとMatrix_tエイリアスは、以前と同じ定義にアクセスするための簡略化された構文を提供します。

00:07:49.000 --> 00:07:55.000
Get_traits構造体を使用すると、具体的なsimdタイプから一般的なタイプに移動して、他の方向に進むことができます。

00:07:55.000 --> 00:08:01.000
繰り返しになりますが、一般的なユースケースの構文を簡素化するためのエイリアスがあります。

00:08:01.000 --> 00:08:06.000
また、テンプレート化されたコードでの使用を可能にするために、makeおよびconvert関数のテンプレートバージョンを追加しました。

00:08:06.000 --> 00:08:14.000
これらは既存の関数と同じように機能しますが、その宛先タイプは関数名の一部ではなくテンプレートパラメータになりました。

00:08:14.000 --> 00:08:21.000
C++の改善に加えて、すべての言語でサポートされているいくつかの新しい機能を追加しました。

00:08:21.000 --> 00:08:32.000
これらは、libmのスカラー関数のベクトルバージョンを提供するisfiniteやisinfなどの分類関数であり、ガンマ関数を計算するための新しい関数、およびsimd行列のトレースを提供します。

00:08:32.000 --> 00:08:37.000
さて、Apple Archiveと新しいApple Encrypted Archiveフォーマットを紹介します。

00:08:37.000 --> 00:08:42.000
アップルアーカイブは、10年の大部分の間、システムのアップデートに電力を供給してきました。

00:08:42.000 --> 00:08:48.000
macOS 11のリリースでは、圧縮されたコンテナとアーカイブ形式へのアクセスを許可しました。

00:08:48.000 --> 00:08:54.000
macOS 12の新機能では、このサポートに暗号化のためのAPIを追加しました。

00:08:54.000 --> 00:09:01.000
アーカイブ形式自体は、最新のモジュラーアプローチを提供し、保存するファイル属性とメタデータを正確に選択できます。

00:09:01.000 --> 00:09:05.000
ストリーミング可能なので、データ全体を一度にメモリに収めることを心配する必要はありません。

00:09:05.000 --> 00:09:12.000
また、ファイルシステムイメージなどの大規模なアーカイブにインデックスを作成するための個別のマニフェストファイルもサポートしています。

00:09:12.000 --> 00:09:22.000
新しいApple Encrypted Archiveは、圧縮、認証された暗号化、デジタル署名を1つの安全なパッケージに組み合わせ、これに基づいて構築されています。

00:09:22.000 --> 00:09:29.000
これは、当社のセキュリティチームと外部の専門家によって設計および監査された最先端の暗号化を提供します。

00:09:29.000 --> 00:09:33.000
データの機密性とは、データが秘密のままであることを意味します。

00:09:33.000 --> 00:09:37.000
データの信頼性とは、転送中に破損していないことを確認できることを意味します。

00:09:37.000 --> 00:09:41.000
送信者認証とは、誰が送信したかを確認できることを意味します。

00:09:41.000 --> 00:09:46.000
署名プライバシーとは、公開鍵のコンテキストでは、あなたと送信者だけが誰が署名したかを知っていることを意味します。

00:09:46.000 --> 00:09:52.000
また、ファイルの長さなどのメタデータを難読化し、辞任攻撃保護を含めます。

00:09:52.000 --> 00:09:58.000
これは、データがプライベートで安全であることを確信できることを意味します。

00:09:58.000 --> 00:10:04.000
正しい展開を容易にするために、さまざまなユースケース向けにさまざまなプロファイルを提供しています。

00:10:04.000 --> 00:10:07.000
基本的なプロファイルは、暗号化なしでデジタル署名を持つことです。

00:10:07.000 --> 00:10:15.000
これは、コンテンツが秘密ではないソフトウェアアップデートなどにも使用できますが、データが改ざんされていないことを確認する必要があります。

00:10:15.000 --> 00:10:21.000
次に、署名の有無にかかわらず、安全に共有されたバイナリキーを使用して、対称暗号化を使用します。

00:10:21.000 --> 00:10:25.000
これは、バイナリキーではなくパスワードを使用する次のオプションに似ています。

00:10:25.000 --> 00:10:30.000
最後に、署名の有無にかかわらず、本格的な公開鍵暗号化が完成しました。

00:10:30.000 --> 00:10:36.000
すべてのプロファイルでは、圧縮はオプションであり、データは常に認証されます。

00:10:36.000 --> 00:10:39.000
これらのフォーマットを操作するために、いくつかのコマンドラインツールを提供しています。

00:10:39.000 --> 00:10:47.000
フォーマットの圧縮アーカイブ部分を操作するには、compression_toolがあり、暗号化されたアーカイブにはaeaがあります。

00:10:47.000 --> 00:10:51.000
Aaツールは容器全体を処理します。

00:10:51.000 --> 00:10:57.000
もちろん、SwiftとCの両方でApple Archiveフレームワークが提供するAPIもあります。

00:10:57.000 --> 00:11:01.000
ストリームベースで、シーケンシャルアクセスとランダムアクセスの両方を可能にします。

00:11:01.000 --> 00:11:06.000
その実装は、非常に高速なパフォーマンスのためにマルチスレッド化されています。

00:11:06.000 --> 00:11:08.000
では、このAPIの動作を見てみましょう。

00:11:08.000 --> 00:11:11.000
ここには、私たちがまとめたシンプルなデモアプリがあります。

00:11:11.000 --> 00:11:18.000
ウィンドウの上部は、暗号化したいもののドラッグアンドドロップターゲットとして機能し、下部は単純なステータスペインです。

00:11:18.000 --> 00:11:21.000
このTopSecretディレクトリを暗号化したいとしましょう。

00:11:21.000 --> 00:11:25.000
これをアプリにドラッグアンドドロップするだけです。

00:11:25.000 --> 00:11:26.000
そして、ああ、いや!エラーが発生しました。

00:11:26.000 --> 00:11:29.000
私たちはまだこの機能を実装していません!

00:11:29.000 --> 00:11:31.000
今それをやりましょう。

00:11:31.000 --> 00:11:34.000
では、これをApple Archiveで暗号化するにはどうすればよいですか?

00:11:34.000 --> 00:11:42.000
まず、暗号化の秘密とともに、使用するアルゴリズムとプロファイルを記述する暗号化コンテキストが必要です。

00:11:42.000 --> 00:11:46.000
また、アーカイブを書き込むファイルストリームも必要です。

00:11:46.000 --> 00:11:49.000
これらを組み合わせて暗号化ストリームを作成します。

00:11:49.000 --> 00:11:56.000
暗号化ストリームはバイトのストリームを暗号化するので、暗号化したいディレクトリをそのようなディレクトリに変換するアダプターが必要です。

00:11:56.000 --> 00:11:59.000
これはエンコーダストリームです。

00:11:59.000 --> 00:12:03.000
もちろん、データはオブジェクトの作成とは反対方向に流れます。

00:12:03.000 --> 00:12:12.000
アーカイブエントリをエンコーダストリームにフィードし、暗号化ストリームのバイトに変換し、暗号化されたデータをファイルストリームに出力します。

00:12:12.000 --> 00:12:14.000
それがコードでどのように見えるか見てみましょう。

00:12:14.000 --> 00:12:17.000
ここでは、対称プロファイルを使用することを指定します。 対称プロファイルを使用します。

00:12:17.000 --> 00:12:21.000
そして、「なし」は、デジタル署名を使用しないことを教えてくれます。

00:12:21.000 --> 00:12:26.000
列挙型の最初の部分は、使用する特定のアルゴリズムを指定するだけです。

00:12:26.000 --> 00:12:30.000
ここでは、「lzfse」を使用してデータを圧縮します。

00:12:30.000 --> 00:12:36.000
コンテキストが作成されると、対称暗号化キーを指定するだけです。

00:12:36.000 --> 00:12:40.000
次に、これらの3つのストリームを作成します。

00:12:40.000 --> 00:12:51.000
まず、ファイルストリームを作成し、それをコンテキストと組み合わせて暗号化ストリームを作成します。

00:12:51.000 --> 00:12:54.000
最後に、エンコーダストリームを導き出します。

00:12:54.000 --> 00:12:59.000
さて、これらのストリームを正しい順序で閉じることを覚えておくことが重要です。

00:12:59.000 --> 00:13:06.000
特に、cryptionStreamを閉じることは、アーカイブに署名して封印するため、舞台裏で多くの作業を行います。

00:13:06.000 --> 00:13:13.000
最後に、残っているのは、ファイルをエンコーダストリームにフィードすることだけです。

00:13:13.000 --> 00:13:21.000
エンコードするファイル属性を指定し、writeDirectoryContentsメソッドを呼び出します。

00:13:21.000 --> 00:13:26.000
残っているのは、暗号化キーを使用してコンソールにステータスメッセージを印刷することだけです。

00:13:26.000 --> 00:13:29.000
それがうまくいったかどうか見てみましょう。

00:13:29.000 --> 00:13:36.000
TopSecretディレクトリをアプリにドロップすると、成功し、暗号化され、暗号化キーが出力されます。

00:13:36.000 --> 00:13:42.000
今、暗号化されたアーカイブをアプリにドラッグアンドドロップすると、それを復号化しようとし、暗号化キーを要求します。

00:13:42.000 --> 00:13:48.000
では、その暗号化キーをコピーして貼り付けて、中身を見てみましょう。

00:13:48.000 --> 00:13:51.000
うーん、おいしい！

00:13:51.000 --> 00:13:55.000
それは私がApple Encrypted Archiveであなたのために持っているすべてなので、締めくくりましょう。

00:13:55.000 --> 00:14:07.000
今日は、BNNSの新しいレイヤータイプのサポートや、simd.hの拡張されたC++サポートやその他の機能など、Accelerateフレームワークの改善について話しました。

00:14:07.000 --> 00:14:14.000
次に、Apple Archiveと新しいApple Encrypted Archiveフォーマットとフレームワークでのサポートを紹介しました。

00:14:14.000 --> 00:14:17.000
ありがとう、WWDCの残りの部分を楽しんでください。

00:14:17.000 --> 23:59:59.000
♪

