WEBVTT

00:00:00.000 --> 00:00:05.000
♪ベース音楽の演奏♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:12.000
メガナ・グプタ:こんにちは、私の名前はメガナです。

00:00:12.000 --> 00:00:16.000
今日は、スウィフトのARCについて話します。

00:00:16.000 --> 00:00:20.000
Swiftは、構造体や列挙型などの強力な値タイプを提供します。

00:00:20.000 --> 00:00:28.000
参照型に付属する意図しない共有の危険性を避けるために、可能であれば値型を使用することを好むべきです。

00:00:28.000 --> 00:00:38.000
クラスはSwiftの参照型であり、それらを使用することにした場合、Swiftは自動参照カウントまたはARCを介してメモリを管理します。

00:00:38.000 --> 00:00:43.000
効果的なSwiftを書くためには、ARCがどのように機能するかを理解することが重要です。

00:00:43.000 --> 00:00:46.000
このセッションでは、まさにそれを行います。

00:00:46.000 --> 00:00:51.000
Swiftでのオブジェクトの寿命とARCのレビューから始めます。

00:00:51.000 --> 00:00:56.000
次に、観測可能なオブジェクトの寿命について説明します。

00:00:56.000 --> 00:01:08.000
オブジェクトの寿命を観察可能にする言語機能、観察されたオブジェクトの寿命に頼ることの結果、およびそれらを修正するためのいくつかの安全なテクニックを詳細に説明します。

00:01:08.000 --> 00:01:10.000
始めましょう。

00:01:10.000 --> 00:01:16.000
Swiftでのオブジェクトの寿命は、初期化時に始まり、最後の使用時に終了します。

00:01:16.000 --> 00:01:22.000
ARCは、ライフタイム終了後にオブジェクトの割り当てを解除することで、メモリを自動的に管理します。

00:01:22.000 --> 00:01:28.000
参照数を追跡することで、オブジェクトの寿命を決定します。

00:01:28.000 --> 00:01:34.000
ARCは、主に保持およびリリース操作を挿入するSwiftコンパイラによって駆動されます。

00:01:34.000 --> 00:01:40.000
実行時に、参照数をインクリメントし、リリースは減少します。

00:01:40.000 --> 00:01:45.000
参照数がゼロになると、オブジェクトは割り当て解除されます。

00:01:45.000 --> 00:01:49.000
例でどのように機能するか見てみましょう。

00:01:49.000 --> 00:01:52.000
旅行アプリを作りたいと想像してみてください。

00:01:52.000 --> 00:02:00.000
旅行者を表すために、名前とオプションの目的地プロパティを持つクラスを書きましょう。

00:02:00.000 --> 00:02:11.000
Test() 関数では、まず Traveler オブジェクトが作成され、次にその参照がコピーされ、最後に宛先が更新されます。

00:02:11.000 --> 00:02:25.000
Travelerオブジェクトのメモリを自動的に管理するために、Swiftコンパイラは参照開始時に保持操作を挿入し、参照の最後の使用後にリリース操作を挿入します。

00:02:25.000 --> 00:02:32.000
traveler1はTravelerオブジェクトへの最初の参照であり、その最後の使用はコピーです。

00:02:32.000 --> 00:02:40.000
ここで、Swiftコンパイラは、traveler1参照の最後の使用直後にリリース操作を挿入します。

00:02:40.000 --> 00:02:49.000
初期化は参照カウントを1に設定するため、参照開始時に保持操作を挿入しません。

00:02:49.000 --> 00:02:57.000
traveler2はTravelerオブジェクトへの別の参照であり、その最後の使用は目的地の更新です。

00:02:57.000 --> 00:03:08.000
ここで、Swiftコンパイラは、参照が開始されたときに保持操作を挿入し、参照の最後の使用直後にリリース操作を挿入します。

00:03:08.000 --> 00:03:14.000
コードをステップスルーして、実行時に何が起こるか見てみましょう。

00:03:14.000 --> 00:03:22.000
まず、トラベラーオブジェクトがヒープ上に作成され、1の参照カウントで初期化されます。

00:03:22.000 --> 00:03:31.000
次に、新しい参照の準備で、保持操作が実行され、参照カウントが2に増加します。

00:03:31.000 --> 00:03:36.000
現在、トラベラー2はトラベラーオブジェクトへの参照でもあります。

00:03:36.000 --> 00:03:46.000
Traveler1参照の最後の使用後、リリース操作が実行され、参照カウントが1に減少します。

00:03:46.000 --> 00:03:52.000
その後、トラベラーオブジェクトの目的地がビッグサーに更新されます。

00:03:52.000 --> 00:04:01.000
それがtraveler2参照の最後の使用だったので、リリース操作が実行され、参照カウントがゼロに減少します。

00:04:01.000 --> 00:04:09.000
参照カウントがゼロになると、オブジェクトの割り当てを解除できます。

00:04:09.000 --> 00:04:13.000
Swiftのオブジェクトの有効期間は使用ベースです。

00:04:13.000 --> 00:04:20.000
オブジェクトの保証された最小寿命は、初期化時に始まり、最後の使用時に終了します。

00:04:20.000 --> 00:04:29.000
これは、オブジェクトの寿命が閉じ中括弧で終わることが保証されているC++のような言語とは異なります。

00:04:29.000 --> 00:04:36.000
この例では、最後の使用直後にオブジェクトが割り当て解除されたことがわかりました。

00:04:36.000 --> 00:04:45.000
しかし、実際には、オブジェクトの寿命は、Swiftコンパイラによって挿入された保持操作とリリース操作によって決定されます。

00:04:45.000 --> 00:04:57.000
そして、キックインするARCの最適化に応じて、観察されたオブジェクトの寿命は、オブジェクトの最後の使用を超えて終了し、保証された最小値と異なる場合があります。

00:04:57.000 --> 00:05:04.000
そのような場合、オブジェクトは最後の使用を超えてプログラムポイントで割り当てられます。

00:05:04.000 --> 00:05:10.000
ほとんどの場合、オブジェクトの正確な寿命は実際には重要ではありません。

00:05:10.000 --> 00:05:21.000
しかし、弱い未所有の参照やデ初期化の副作用などの言語機能では、オブジェクトの寿命を観察することが可能です。

00:05:21.000 --> 00:05:31.000
また、保証されたオブジェクトの寿命ではなく、観察されたオブジェクトの寿命に依存するプログラムがある場合、将来的に問題が発生する可能性があります。

00:05:31.000 --> 00:05:37.000
観測された物体の寿命に頼ることは、今日ではうまくいくかもしれませんが、それは単なる偶然です。

00:05:37.000 --> 00:05:46.000
観察されたオブジェクトの寿命は、Swiftコンパイラの緊急のプロパティであり、実装の詳細が変更されると変更される可能性があります。

00:05:46.000 --> 00:06:04.000
このようなバグは、開発中に発見されず、長期間隠されている可能性がありますが、改善されたARC最適化または以前に制限されたARC最適化を可能にする無関係なソース変更によるコンパイラアップデートによってのみ発見されます。

00:06:04.000 --> 00:06:17.000
オブジェクトの寿命を観測可能にする言語機能について説明し、観察されたオブジェクトの寿命のみに頼った場合に何が起こるか、およびそれらを修正するためのいくつかの安全なテクニックについて説明します。

00:06:17.000 --> 00:06:30.000
強い参照であるデフォルトの参照とは異なり、弱い参照と未所有の参照は参照カウントに参加せず、このため、参照サイクルを破るために一般的に使用されます。

00:06:30.000 --> 00:06:36.000
彼らの詳細に入る前に、参照サイクルが何であるかを見てみましょう。

00:06:36.000 --> 00:06:39.000
これは私たちの旅行アプリの拡張機能です。

00:06:39.000 --> 00:06:42.000
私たちは今、オプションのポイントシステムを導入したいと考えています。

00:06:42.000 --> 00:06:47.000
旅行者はアカウントを持ち、その中にポイントを貯めることができます。

00:06:47.000 --> 00:06:51.000
これを表すために、ポイントプロパティを持つ新しいアカウントクラスがあります。

00:06:51.000 --> 00:06:58.000
アカウントクラスはトラベラークラスを指し、トラベラークラスはアカウントクラスに戻ります。

00:06:58.000 --> 00:07:07.000
test()関数では、TravelerとAccountオブジェクトを作成し、traveler参照を介してprintSummary()関数を呼び出します。

00:07:07.000 --> 00:07:12.000
コードをステップスルーして、ARCがどうなるか見てみましょう。

00:07:12.000 --> 00:07:18.000
まず、トラベラーオブジェクトは、参照カウントが1のヒープに作成されます。

00:07:18.000 --> 00:07:24.000
次に、アカウントオブジェクトがヒープに作成され、参照カウントが1になります。

00:07:24.000 --> 00:07:32.000
アカウントオブジェクトはトラベラーオブジェクトを参照するため、トラベラーオブジェクトの参照数は2にインクリメントされます。

00:07:32.000 --> 00:07:43.000
これで、トラベラーオブジェクトがアカウントオブジェクトを参照し始めるので、アカウントオブジェクトの参照数も2に増加します。

00:07:43.000 --> 00:07:46.000
これはアカウント参照の最後の使用です。

00:07:46.000 --> 00:07:55.000
この後、アカウント参照は消え、アカウントオブジェクトの参照カウントは1に減少します。

00:07:55.000 --> 00:08:00.000
次に、printSummary() 関数が呼び出されて名前とポイントが印刷されます。

00:08:00.000 --> 00:08:04.000
これはトラベラーリファレンスの最後の使用です。

00:08:04.000 --> 00:08:12.000
この後、トラベラー参照は消え、トラベラーオブジェクトの参照数は1に減少します。

00:08:12.000 --> 00:08:20.000
オブジェクトを到達可能にするすべての参照が消えた後でも、オブジェクトの参照数は1つのままです。

00:08:20.000 --> 00:08:22.000
これは参照サイクルのためです。

00:08:22.000 --> 00:08:29.000
その結果、オブジェクトは決して割り当て解除されないため、メモリリークが発生します。

00:08:29.000 --> 00:08:34.000
弱い参照または未所有の参照で参照サイクルを中断することができます。

00:08:34.000 --> 00:08:43.000
参照カウントに参加しないため、弱い参照または所有されていない参照が使用されている間に、参照されたオブジェクトが割り当て解除される可能性があります。

00:08:43.000 --> 00:08:54.000
これが発生すると、Swiftランタイムは安全に弱い参照へのアクセスをnilとして、未所有の参照へのアクセスをトラップとして回します。

00:08:54.000 --> 00:09:01.000
参照サイクルに参加している参照は、参照サイクルを中断するために、弱いまたは無所有としてマークすることができます。

00:09:01.000 --> 00:09:04.000
アプリケーションによって異なります。

00:09:04.000 --> 00:09:10.000
この例では、アカウントクラスの旅行者参照を弱いものとしてマークしましょう。

00:09:10.000 --> 00:09:20.000
弱い参照は参照カウントに参加しないため、トラベラーオブジェクトを最後に使用した後、その参照数はゼロに低下します。

00:09:20.000 --> 00:09:26.000
トラベラーオブジェクトの参照数がゼロになると、割り当てを解除できます。

00:09:26.000 --> 00:09:34.000
Travelerオブジェクトが消えると、Accountオブジェクトへの参照は消え、参照カウントはゼロになります。

00:09:34.000 --> 00:09:37.000
これで、アカウントオブジェクトの割り当てを解除できます。

00:09:37.000 --> 00:09:43.000
この例では、弱い参照を使用して、参照サイクルを中断するだけです。

00:09:43.000 --> 00:10:03.000
保証されたオブジェクトの寿命が終了している間に、弱い参照を使用してオブジェクトにアクセスし、オブジェクトが利用可能になるために観察されたオブジェクトの寿命に依存している場合、観察されたオブジェクトの寿命が無関係な理由で変更されると、将来的にバグが発生する可能性があります。

00:10:03.000 --> 00:10:05.000
例を見てみましょう。

00:10:05.000 --> 00:10:11.000
ここで、printSummary() 関数は Traveler クラスから Account クラスに移動されます。

00:10:11.000 --> 00:10:17.000
そして、test()関数は、アカウント参照を介してprintSummary()関数を呼び出すようになりました。

00:10:17.000 --> 00:10:22.000
printSummary() 関数が呼び出されると、正確にはどうなりますか?

00:10:22.000 --> 00:10:29.000
今日は旅行者の名前とポイントを印刷するかもしれませんが、これは偶然に過ぎません。

00:10:29.000 --> 00:10:36.000
これは、Travelerオブジェクトの最後の使用がprintSummary（）関数の呼び出し前であるためです。

00:10:36.000 --> 00:10:48.000
この後、コンパイラが最後の使用直後にリリースを挿入した場合、Travelerオブジェクトの参照カウントはゼロに低下する可能性があります。

00:10:48.000 --> 00:10:59.000
参照数がゼロになった場合、弱い参照を介したTravelerオブジェクトへのアクセスはnilになり、Travelerオブジェクトは割り当て解除される可能性があります。

00:10:59.000 --> 00:11:07.000
したがって、printSummary（）関数が呼び出されると、弱いトラベラー参照の強制アンラップがトラップされ、クラッシュが発生します。

00:11:07.000 --> 00:11:16.000
フォースアンラップがここでのクラッシュの理由であり、オプションのバインディングがそれを防いだ可能性があるかどうか疑問に思うかもしれません。

00:11:16.000 --> 00:11:19.000
オプションのバインディングは、実際には問題を悪化させます。

00:11:19.000 --> 00:11:29.000
明らかなクラッシュがなければ、無関係な理由で観察されたオブジェクトの寿命が変更されたときに気づかれないかもしれないサイレントバグを作成します。

00:11:29.000 --> 00:11:41.000
弱い参照や未所有の参照を安全に処理するためのさまざまな技術があり、それぞれが先行実装コストと継続的なメンテナンスコストの程度が異なります。

00:11:41.000 --> 00:11:44.000
私たちの例でそれらを一つずつ探りましょう。

00:11:44.000 --> 00:11:52.000
Swiftは、オブジェクトの寿命を明示的に延長できるExtendedLifetime()ユーティリティを提供します。

00:11:52.000 --> 00:12:04.000
withExtendedLifetime() を使用すると、printSummary() 関数が呼び出されている間に、Traveler オブジェクトの寿命を安全に延長することができ、潜在的なバグを防ぐことができます。

00:12:04.000 --> 00:12:14.000
既存のスコープの最後にwithExtendedLifetime()への空の呼び出しを配置することで、同じ効果を達成できます。

00:12:14.000 --> 00:12:24.000
より複雑なケースでは、deferを使用してオブジェクトの寿命を現在のスコープの終わりまで延長するようにコンパイラに依頼することができます。

00:12:24.000 --> 00:12:30.000
withExtendedLifetime()は、オブジェクトの寿命のバグから抜け出す簡単な方法のように見えるかもしれません。

00:12:30.000 --> 00:12:38.000
しかし、このテクニックは壊れやすく、正しさの責任をあなたに委ねます。

00:12:38.000 --> 00:12:47.000
このアプローチでは、弱い参照がバグを引き起こす可能性があるたびにwithExtendedLifetime()が使用されていることを確認する必要があります。

00:12:47.000 --> 00:12:55.000
制御されていない場合、withExtendedLifetime()はコードベース全体に忍び寄る可能性があり、メンテナンスコストが増加します。

00:12:55.000 --> 00:13:01.000
より良いAPIでクラスを再設計することは、はるかに原則的なアプローチです。

00:13:01.000 --> 00:13:10.000
オブジェクトへのアクセスを強力な参照のみに制限できる場合、オブジェクトの寿命の驚きを防ぐことができます。

00:13:10.000 --> 00:13:19.000
ここで、printSummary() 関数は Traveler クラスに戻り、Account クラスの弱い参照は非表示になります。

00:13:19.000 --> 00:13:28.000
テストは、強力な参照を介してprintSummary（）関数を呼び出すことを余儀なくされ、潜在的なバグを排除します。

00:13:28.000 --> 00:13:37.000
パフォーマンスコストを運ぶことに加えて、クラス設計に注意しないと、弱い参照や未所有の参照がバグを暴露する可能性があります。

00:13:37.000 --> 00:13:44.000
一時停止して考えることが重要です、なぜ弱くて所有されていない参照が必要なのですか?

00:13:44.000 --> 00:13:47.000
それらは参照サイクルを破るためだけに使用されますか?

00:13:47.000 --> 00:13:52.000
そもそも参照サイクルの作成を避ける場合はどうなりますか?

00:13:52.000 --> 00:14:02.000
参照サイクルは、アルゴリズムを再考し、循環クラス関係をツリー構造に変換することで、しばしば回避できます。

00:14:02.000 --> 00:14:07.000
この例では、トラベラークラスはアカウントクラスを参照する必要があります。

00:14:07.000 --> 00:14:12.000
アカウントクラスがトラベラークラスを参照する必要はない。

00:14:12.000 --> 00:14:18.000
アカウントクラスは、旅行者の個人情報へのアクセスのみが必要です。

00:14:18.000 --> 00:14:25.000
旅行者の個人情報をPersonalInfoと呼ばれる新しいクラスに移動することができます。

00:14:25.000 --> 00:14:33.000
トラベラークラスとアカウントクラスの両方がPersonalInfoクラスを参照でき、サイクルを回避できます。

00:14:33.000 --> 00:14:46.000
弱い参照や未所有の参照の必要性を回避するには、追加の実装コストがかかるかもしれませんが、これはすべての潜在的なオブジェクトライフタイムバグを排除する明確な方法です。

00:14:46.000 --> 00:14:53.000
オブジェクトの寿命を観察可能にするもう1つの言語機能は、デ初期化の副作用です。

00:14:53.000 --> 00:15:01.000
デイニタライザーは割り当て解除前に実行され、その副作用は外部プログラム効果によって観察できます。

00:15:01.000 --> 00:15:16.000
外部プログラム効果でデイニタライザーの副作用をシーケンスするためにコードを書くと、無関係な理由で観察されたオブジェクトの寿命が変更された場合にのみ発見される隠れたバグにつながる可能性があります。

00:15:16.000 --> 00:15:22.000
そのようなバグがどのように出てくるかに入る前に、デイニタライザーが何であるかを見てみましょう。

00:15:22.000 --> 00:15:28.000
これは最初の例の繰り返しで、今はデイニタライザーが付いています。

00:15:28.000 --> 00:15:34.000
Deinitializerには、コンソールにメッセージを印刷するという世界的な副作用があります。

00:15:34.000 --> 00:15:40.000
今日、「Done traveling」が印刷された後、デイニタライザーが実行される可能性があります。

00:15:40.000 --> 00:15:54.000
しかし、Travelerオブジェクトの最後の使用は宛先の更新であるため、起動するARCの最適化に応じて、「Done traveling」が印刷される前にdeinitializerを実行できます。

00:15:54.000 --> 00:16:00.000
この例では、デイニタライザーの副作用は観察可能でしたが、信頼されていませんでした。

00:16:00.000 --> 00:16:09.000
初期化解除の副作用が外部のプログラム効果によって依存される、より複雑な例を見てみましょう。

00:16:09.000 --> 00:16:13.000
現在、トラベラークラスに旅行指標を紹介します。

00:16:13.000 --> 00:16:19.000
目的地が更新されるたびに、TravelMetricsクラスに記録されます。

00:16:19.000 --> 00:16:26.000
最終的に、トラベラーオブジェクトを初期化解除すると、メトリクスはグローバルレコードに公開されます。

00:16:26.000 --> 00:16:35.000
公開された指標は、旅行者の匿名ID、検索された目的地の数、および計算された旅行利息カテゴリです。

00:16:35.000 --> 00:16:47.000
Test() 関数では、まず Traveler オブジェクトが作成され、次に travelMetrics への参照が Traveler オブジェクトからコピーされます。

00:16:47.000 --> 00:16:55.000
旅行者の目的地は、TravelMetricsにBig Surを記録するBig Surに更新されます。

00:16:55.000 --> 00:17:02.000
旅行者の目的地は、TravelMetricsにカタリナを記録するカタリナに更新されます。

00:17:02.000 --> 00:17:10.000
次に、旅行の関心カテゴリは、記録された目的地を見て計算されます。

00:17:10.000 --> 00:17:19.000
今日、デイニタライザーは旅行の関心を計算した後に実行され、関心のあるカテゴリをネイチャーとして公開する可能性があります。

00:17:19.000 --> 00:17:29.000
しかし、トラベラーオブジェクトの最後の使用は、カタリナへの宛先の更新であり、その直後にデイニタライザーを実行できます。

00:17:29.000 --> 00:17:37.000
旅行の関心を計算する前にデイニタライザーが実行されるため、nilが公開され、バグが発生します。

00:17:37.000 --> 00:17:45.000
弱くて所有されていない参照と同様に、デ初期化剤の副作用を安全に処理するためのさまざまなテクニックがあります。

00:17:45.000 --> 00:17:53.000
それらのそれぞれは、継続的なメンテナンスコストに対して、さまざまな程度の先行実装コストがあります。

00:17:53.000 --> 00:17:55.000
それらを一つずつ見てみましょう。

00:17:55.000 --> 00:18:08.000
withExtendedLifetime()を使用して、旅行利息カテゴリが計算されるまでTravelerオブジェクトの寿命を明示的に延長し、潜在的なバグを防ぐことができます。

00:18:08.000 --> 00:18:14.000
前に説明したように、これはあなたに正しさの責任を移します。

00:18:14.000 --> 00:18:29.000
このアプローチでは、初期化除去の副作用と外部プログラム効果の間に誤った相互作用の可能性があるたびにwithExtendedLifetimeが使用され、メンテナンスコストが増加することを確認する必要があります。

00:18:29.000 --> 00:18:35.000
効果がすべて局所的である場合、デイニタライザーの副作用は観察できません。

00:18:35.000 --> 00:18:44.000
内部クラスの詳細の可視性を制限してクラスAPIを再設計することで、オブジェクトのライフタイムのバグを防ぐことができます。

00:18:44.000 --> 00:18:50.000
ここでは、TravelMetricsはプライベートとマークされ、外部アクセスから隠されています。

00:18:50.000 --> 00:18:58.000
デイニタライザーは、最も関心のある旅行カテゴリを計算し、メトリクスを公開するようになりました。

00:18:58.000 --> 00:19:07.000
これは機能しますが、より原則的なアプローチは、デイタライザーの副作用を完全に取り除くことです。

00:19:07.000 --> 00:19:17.000
ここでは、デイニタライザーの代わりにデイタライザーが使用され、デイニタライザーは検証のみを実行します。

00:19:17.000 --> 00:19:25.000
Deinitializerの副作用を取り除くことで、潜在的なオブジェクトの寿命のバグをすべて排除することができます。

00:19:25.000 --> 00:19:34.000
ARC、弱い参照と未所有の参照、および初期化除去の副作用について学ぶために、教育旅行アプリの例を調べました。

00:19:34.000 --> 00:19:50.000
驚くべき時期にバグを発見しないように、オブジェクトの寿命を観測可能にし、観察されたオブジェクトの寿命に対する潜在的に誤った依存を排除する言語機能を徹底的に理解することが重要です。

00:19:50.000 --> 00:19:59.000
Xcode 13では、「Object Lifetimesの最適化」と呼ばれる新しい実験的なビルド設定がSwiftコンパイラで利用できます。

00:19:59.000 --> 00:20:04.000
これにより、強力な寿命短縮ARC最適化が可能になります。

00:20:04.000 --> 00:20:19.000
このビルド設定をオンにすると、最後の使用の直後にオブジェクトがはるかに一貫して割り当て解除され、観察されたオブジェクトの寿命が保証された最小値に近づきます。

00:20:19.000 --> 00:20:24.000
これは、議論された例と同様に、隠されたオブジェクトの寿命のバグを公開する可能性があります。

00:20:24.000 --> 00:20:31.000
このセッションで説明した安全なテクニックに従って、そのようなバグをすべて排除することができます。

00:20:31.000 --> 00:20:33.000
あなたがこのセッションを楽しんだことを願っています。

00:20:33.000 --> 00:20:35.000
見てくれてありがとう。

00:20:35.000 --> 23:59:59.000
♪

