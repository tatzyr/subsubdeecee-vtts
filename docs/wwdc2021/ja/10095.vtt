WEBVTT

00:00:00.000 --> 00:00:05.000
♪ベース音楽の演奏♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:11.000
Guoye Zhang:こんにちは、私はGuoyeです。

00:00:11.000 --> 00:00:16.000
同僚のZhenchaoと私はHTTPフレームワークに取り組んでいます。

00:00:16.000 --> 00:00:20.000
あなたは今までにSwiftの並行性について多くのことを聞いたことがあると思います。

00:00:20.000 --> 00:00:24.000
まだしていない場合は、「Swiftで非同期/待機する」をチェックしてください。

00:00:24.000 --> 00:00:28.000
URLSessionでasync/awaitがどのように機能するかに飛び込みます。

00:00:28.000 --> 00:00:38.000
Swiftの並行性について私が最も好きなのは、コードを直線的で簡潔にし、ネイティブのSwiftエラー処理をサポートすることです。

00:00:38.000 --> 00:00:52.000
ネットワーキングは本質的に非同期であり、iOS 15とmacOS Montereyでは、Swiftの並行性機能を利用するために、URLSessionに一連の新しいAPIを導入しました。

00:00:52.000 --> 00:00:58.000
新しいAPIを紹介するために、ここにasync/awaitを採用するために取り組んでいるアプリがあります。

00:00:58.000 --> 00:01:05.000
それは犬愛好家のための写真共有アプリで、私たちはこれらの写真をお気に入りにすることができます。

00:01:05.000 --> 00:01:09.000
これは、犬の写真を取得する既存のコードです。

00:01:09.000 --> 00:01:14.000
URLSessionで completionHandlerベースの便利なメソッドを使用しています。

00:01:14.000 --> 00:01:17.000
コードは簡単そうで、私の限られたテストでうまくいきました。

00:01:17.000 --> 00:01:20.000
しかし、少なくとも3つの間違いがあります。

00:01:20.000 --> 00:01:23.000
飛び込みましょう。

00:01:23.000 --> 00:01:26.000
まず、コントロールフローに従いましょう。

00:01:26.000 --> 00:01:28.000
データタスクを作成し、それを再開します。

00:01:28.000 --> 00:01:38.000
次に、タスクが完了したら、完了ハンドラにジャンプし、応答を確認し、画像を作成し、そこで制御フローが終了します。

00:01:38.000 --> 00:01:41.000
うーん、私たちは前後にジャンプしています。

00:01:41.000 --> 00:01:43.000
スレッドはどうですか?

00:01:43.000 --> 00:01:47.000
この小さなコードは驚くほど複雑です。

00:01:47.000 --> 00:01:50.000
合計で3つの異なる実行コンテキストがあります。

00:01:50.000 --> 00:02:02.000
最も遠いレイヤーは、呼び出し先のスレッドまたはキューで実行され、URLSessionTask completionHandlerはセッションのデリゲートキューで実行され、最終的な完了ハンドラーはメインキューで実行されます。

00:02:02.000 --> 00:02:11.000
コンパイラはここで私たちを助けることができないので、データレースなどのスレッドの問題を避けるために細心の注意を払う必要があります。

00:02:11.000 --> 00:02:13.000
今、私は何かが間違っていることに気づきました。

00:02:13.000 --> 00:02:18.000
completionHandlerへの呼び出しは、メインキューに一貫してディスパッチされるわけではありません。

00:02:18.000 --> 00:02:20.000
これはバグかもしれません。

00:02:20.000 --> 00:02:23.000
また、私たちはここで早めのリターンを逃しています。

00:02:23.000 --> 00:02:27.000
エラーが発生した場合、完了ハンドラーを2回呼び出すことができます。

00:02:27.000 --> 00:02:32.000
これは、発信者の仮定に違反する可能性があります。

00:02:32.000 --> 00:02:37.000
最後に、これはあまり明白ではないかもしれませんが、UIImageの作成は失敗する可能性があります。

00:02:37.000 --> 00:02:48.000
データが間違った形式の場合、このUIImage初期化子はnilを返すので、nil画像とnilエラーの両方でcompletionHandlerを呼び出しました。

00:02:48.000 --> 00:02:51.000
これはおそらく予想外です。

00:02:51.000 --> 00:02:54.000
さて、これはasync/awaitを使用する新しいバージョンです。

00:02:54.000 --> 00:02:56.000
うわー、それはとても簡単です!

00:02:56.000 --> 00:03:08.000
制御フローは上から下まで線形であり、この関数のすべてが同じ並行性コンテキストで実行されることを知っているので、スレッドの問題を心配する必要はもうありません。

00:03:08.000 --> 00:03:13.000
ここでは、URLSessionで新しい非同期データメソッドを使用しました。

00:03:13.000 --> 00:03:23.000
ブロックせずに現在の実行コンテキストを一時停止し、正常に完了するとデータと応答を返すか、エラーをスローします。

00:03:23.000 --> 00:03:29.000
また、応答が予期しないときにエラーをスローするためにthrowキーワードを使用しました。

00:03:29.000 --> 00:03:35.000
これにより、発信者はSwiftネイティブエラー処理を使用してエラーをキャッチして処理できます。

00:03:35.000 --> 00:03:46.000
最後に、この関数からオプションのUIImageを返そうとすると、コンパイラは吠えるので、本質的にnilを正しく処理することを強制します。

00:03:46.000 --> 00:03:51.000
これは、ネットワークからデータを取得するために使用したメソッドの署名です。

00:03:51.000 --> 00:03:58.000
URLSession.dataメソッドは、URLまたはURLRequestのいずれかを受け入れます。

00:03:58.000 --> 00:04:03.000
これらは、既存のデータタスクの便利な方法と同等です。

00:04:03.000 --> 00:04:09.000
また、データをアップロードしたり、ファイルをアップロードしたりできるアップロード方法も提供しています。

00:04:09.000 --> 00:04:13.000
これらは、既存のアップロードタスクの便利な方法と同等です。

00:04:13.000 --> 00:04:23.000
デフォルトのメソッドGETはアップロードをサポートしていないため、リクエストを送信する前に必ず正しいHTTPメソッドを設定してください。

00:04:23.000 --> 00:04:28.000
ダウンロードメソッドは、レスポンスボディをメモリではなくファイルとして保存します。

00:04:28.000 --> 00:04:38.000
ダウンロードタスクの便利な方法とは異なり、これらの新しい方法は自動的にファイルを削除しないので、自分で削除することを忘れないでください。

00:04:38.000 --> 00:04:44.000
この例では、さらなる処理のためにファイルを別の場所に移動しています。

00:04:44.000 --> 00:04:49.000
Swift並行性のキャンセルは、URLSession非同期メソッドで動作します。

00:04:49.000 --> 00:04:53.000
キャンセルする1つの方法は、並行性Task.Handleを使用することです。

00:04:53.000 --> 00:04:59.000
ここでは、非同期を呼び起こして、2つのリソースを1つずつロードする並行性タスクを作成します。

00:04:59.000 --> 00:05:04.000
後で、Task.Handleを使用して、現在実行中の操作をキャンセルできます。

00:05:04.000 --> 00:05:11.000
並行性タスクは、「タスク」という名前を共有しているにもかかわらず、URLSessionTaskとは無関係であることに注意してください。

00:05:11.000 --> 00:05:19.000
先ほど話した方法 - データ、アップロード、ダウンロード - 応答ボディ全体が到着するのを待ってから戻ります。

00:05:19.000 --> 00:05:23.000
応答本文を段階的に受け取りたい場合はどうなりますか?

00:05:23.000 --> 00:05:27.000
URLSession.bytesメソッドをご紹介させていただきます。

00:05:27.000 --> 00:05:34.000
応答ヘッダーが受信されたときに返し、応答本文をバイトのAsyncSequenceとして配信します。

00:05:34.000 --> 00:05:40.000
それがどのように機能するかを示すために、私の同僚のZhenchaoは、彼がDogsアプリでそれをどのように採用しているかをデモします。

00:05:40.000 --> 00:05:44.000
Zhenchao Li: ありがとう、Guoye!こんにちは、私はジェンチャオです。

00:05:44.000 --> 00:05:54.000
私は、犬の写真をお気に入りにした人の数を示すDogsアプリの新機能に取り組んできました。

00:05:54.000 --> 00:06:00.000
今、スクロールビューをプルダウンして、お気に入りのカウントを更新できます。

00:06:00.000 --> 00:06:04.000
これらのお気に入りのカウントをリアルタイムで更新したいと思います。

00:06:04.000 --> 00:06:08.000
そうすれば、アプリははるかにインタラクティブに感じられます。

00:06:08.000 --> 00:06:17.000
これを行うために、当社のバックエンドエンジニアは、写真のライブアップデートを提供するリアルタイムのイベントエンドポイントを構築しました。

00:06:17.000 --> 00:06:23.000
エンドポイントをチェックして応答を調べます。

00:06:23.000 --> 00:06:32.000
応答本文の各行は、更新されたお気に入りのカウントなど、写真の更新を記述するJSONデータの一部です。

00:06:32.000 --> 00:06:42.000
新しい非同期シーケンスAPIを使用して、エンドポイントの応答を消費し、リアルタイムイベントが解析されるにつれてお気に入りのカウントを更新しましょう。

00:06:42.000 --> 00:06:50.000
フォトコレクションビューが表示されたときに呼び出されるアクションであるonAppearHandler関数でライブアップデートを開始できます。

00:06:50.000 --> 00:07:06.000
関数内で、新しいURLSession.bytes APIを呼び出して、新しいエンドポイントからデータを取得します。

00:07:06.000 --> 00:07:12.000
ここで返されるバイトには、URLSession.AsyncBytesのタイプがあることに注意してください。

00:07:12.000 --> 00:07:17.000
これにより、応答体を段階的に消費する方法が得られます。

00:07:17.000 --> 00:07:28.000
また、サーバーから応答が成功したことを確認するために、ここにエラーチェックを追加しました。

00:07:28.000 --> 00:07:33.000
応答の各行をJSONデータの一部として解析したい。

00:07:33.000 --> 00:07:42.000
これを行うには、AsyncBytesでlinesメソッドを使用できます。

00:07:42.000 --> 00:07:54.000
これにより、データを受信したときに応答を行ごとに消費することができます。

00:07:54.000 --> 00:08:03.000
ループ内では、JSONデータを解析し、updateFavoriteCountを呼び出すことでUIを更新することができます。

00:08:03.000 --> 00:08:18.000
UIの更新はメインアクターで行う必要があるため、await構文を使用して、非同期関数であるupdateFavoriteCountを呼び出していることに注意してください。

00:08:18.000 --> 00:08:23.000
すごい。これで、これらのお気に入りのカウントがリアルタイムで更新されます。

00:08:23.000 --> 00:08:27.000
あなたに戻って、Guoye。

00:08:27.000 --> 00:08:35.000
Guoye：Zhenchaoは、AsyncSequence組み込みの変換（行）を使用して、応答本体を行ごとに解析する方法を示しました。

00:08:35.000 --> 00:08:46.000
AsyncSequenceは多くの便利な変換をサポートしており、FileHandleなどの他のシステムフレームワークAPIでAsyncSequenceを使用することもできます。

00:08:46.000 --> 00:08:53.000
AsyncSequenceの詳細については、ビデオ「Meet AsyncSequence」を見ることをお勧めします。

00:08:53.000 --> 00:09:02.000
URLSessionは、認証の課題、メトリクスなどのイベントのコールバックを提供するデリゲートモデルを中心に設計されています。

00:09:02.000 --> 00:09:12.000
新しい非同期メソッドは、もはや基礎となるタスクを公開しないので、タスクに固有の認証の課題をどのように処理しますか?

00:09:12.000 --> 00:09:27.000
はい、これらのメソッドはすべて、追加の引数（タスク固有のデリゲート）を取ることができ、このデータアップロード、ダウンロード、またはバイト操作に固有のデリゲートメッセージを処理するオブジェクトを提供できます。

00:09:27.000 --> 00:09:36.000
また、同じ機能を利用するために、Objective-CのNSURLSessionTaskにデリゲートプロパティを導入しています。

00:09:36.000 --> 00:09:42.000
デリゲートは、タスクが完了または失敗するまで、タスクによって強く保持されます。

00:09:42.000 --> 00:09:47.000
タスク固有のデリゲートがバックグラウンドURLSessionでサポートされていないことは注目に値します。

00:09:47.000 --> 00:09:57.000
メソッドがセッションデリゲートとタスクデリゲートの両方に実装されている場合、タスクデリゲートのメソッドが呼び出されます。

00:09:57.000 --> 00:10:03.000
さて、Zhenchaoは、タスク固有のデリゲートを使用して認証の課題を処理する方法を紹介します。

00:10:03.000 --> 00:10:05.000
Zhenchao:ありがとう、Guoye!

00:10:05.000 --> 00:10:11.000
私たちのDogsアプリには、新しい非同期APIで書かれたシンプルなデータフェッチレイヤーがあります。

00:10:11.000 --> 00:10:23.000
写真をお気に入りとしてマークしたり、すべてのお気に入りの写真を取得したりするなど、データ取得タスクの一部では、ユーザーを認証する必要があります。

00:10:23.000 --> 00:10:29.000
現在、写真のお気に入りをタップすると、「無許可」というエラーが表示されます。

00:10:29.000 --> 00:10:36.000
タスク固有のデリゲートを使用してユーザー認証を追加する方法を見てみましょう。

00:10:36.000 --> 00:10:40.000
まず、URLSessionTaskDelegateを書きましょう。

00:10:40.000 --> 00:10:44.000
それをAuthenticationDelegateと呼びましょう。

00:10:44.000 --> 00:11:00.000
AuthenticationDelegateはURLSessionTaskDelegateプロトコルに準拠しており、初期化子でsignInControllerのインスタンスを受け入れます。

00:11:00.000 --> 00:11:12.000
私たちが実装したsignInControllerクラスには、ユーザーに資格情報を求めるために使用できるいくつかの素晴らしいヘルパー機能がすでに含まれています。

00:11:12.000 --> 00:11:20.000
次に、URLSession didReceive challenge delegateメソッドを実装しましょう。

00:11:20.000 --> 00:11:30.000
デリゲートメソッド内では、ユーザーに資格情報の入力を促すことで、HTTP基本認証の課題に応答することを選択できます。

00:11:30.000 --> 00:11:35.000
もちろん、エラー処理を忘れてはいけません。

00:11:35.000 --> 00:11:41.000
では、このAuthenticationDelegateクラスをタスク固有のデリゲートとして使用しましょう。

00:11:41.000 --> 00:11:53.000
これを行うには、そのインスタンスをインスタンス化して、URLSession.dataメソッドのデリゲートパラメータとして解析することができます。

00:11:53.000 --> 00:12:03.000
デリゲートオブジェクトはインスタンス変数ではなく、タスクが完了または失敗するまでタスクによって強く保持されることに注意してください。

00:12:03.000 --> 00:12:21.000
ここでの新機能なのは、デリゲートを使用してURLSessionタスクのインスタンスに固有のイベントを処理できることです。これは、デリゲートメソッド内のロジックが特定のURLSessionタスクにのみ適用され、他のタスクには適用されない場合に便利です。

00:12:21.000 --> 00:12:29.000
すごい。今、写真のお気に入りをタップすると...

00:12:29.000 --> 00:12:40.000
...ログインフォームがポップアップ表示されます。

00:12:40.000 --> 00:12:53.000
ログインすると、写真はお気に入りとして表示され、お気に入りの写真コレクションに追加されました。

00:12:53.000 --> 00:12:57.000
あなたに戻って、Guoye。

00:12:57.000 --> 00:12:59.000
Guoye: Zhenchaoさん、デモをありがとう。

00:12:59.000 --> 00:13:18.000
URLSessionでasync/awaitを試すのが待ちきれません。関数の変更、完了ハンドラーを非同期関数に持っていく、繰り返しイベントハンドラーをAsyncSequencesに変更するなど、同じ非同期の概念を適用してコードを改善することをお勧めします。

00:13:18.000 --> 00:13:31.000
URLSessionの進歩の詳細については、アプリのHTTPトラフィックを検査するクールな新しい機器に関するビデオと、URLSessionでのHTTP/3サポートに関するビデオがあります。

00:13:31.000 --> 00:13:34.000
ありがとう、そして素晴らしいWWDCを!

00:13:34.000 --> 23:59:59.000
♪

