WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:14.000
こんにちは！私はニコールです。「スウィフトの新機能」へようこそ。

00:00:14.000 --> 00:00:17.000
Swift 5.5はこれまでで最高のリリースです!

00:00:17.000 --> 00:00:33.000
Swift言語は、Swiftでの並行プログラミングを便利、効率的、安全にするために設計された非同期および並行プログラミングの新しいモデルであるSwift Concurrencyを含む多くの新機能により、急速なペースで進化し続けています。

00:00:33.000 --> 00:00:46.000
さらに、パッケージエクスペリエンスの進歩、新しい標準ライブラリパッケージ、開発者エクスペリエンスを強化する機能のおかげで、Swiftでの開発がこれまで以上に簡単になりました。

00:00:46.000 --> 00:00:56.000
これらの進歩と同じくらい重要ですが、Swiftプロジェクトの中心はコードではなく、Swiftプロジェクトの目標に向かって取り組んでいる人々のコミュニティです。

00:00:56.000 --> 00:01:01.000
これが、ソフトウェアだけでなく、コミュニティにも投資することが重要である理由です。

00:01:01.000 --> 00:01:06.000
重要なSwiftコミュニティイニシアチブについて話すことから始めたいと思います。

00:01:06.000 --> 00:01:10.000
多様性はスウィフトコミュニティの中核的価値です。

00:01:10.000 --> 00:01:16.000
研究は、多様なオープンソースプロジェクトがより生産的であり、より良い決定を下すことを示しています。

00:01:16.000 --> 00:01:23.000
あらゆる背景と多様な視点を持つ人々を含めることは、コミュニティが繁栄するのに役立ちます。

00:01:23.000 --> 00:01:35.000
私たちとSwiftコミュニティの他のメンバーは、Diversity in Swiftイニシアチブで、より幅広い開発者からSwiftエコシステムとコミュニティへの積極的な関与を奨励する機会を見ました。

00:01:35.000 --> 00:01:50.000
SwiftのDiversityの使命は、さまざまな声を高め、開発者がバックグラウンドに関係なくSwiftの学習や貢献を始めやすくすることで、包括的なSwiftコミュニティを育成することです。

00:01:50.000 --> 00:02:01.000
このイニシアチブの一環として、コミュニティ内の幅広い開発者からの貢献を認識し、強調する投稿を含むようにswift.orgブログを拡大しました。

00:02:01.000 --> 00:02:10.000
また、開発者が同様の経験をしたり、同様の障壁に直面した可能性のある他の人とつながるためのコミュニティグループをSwiftフォーラムに作成しました。

00:02:10.000 --> 00:02:18.000
スウィフトの多様性や詳細については、swift.org/diversityをご覧ください。

00:02:18.000 --> 00:02:24.000
また、すでにコミュニティにいる開発者がSwiftで成長し、目標を達成できるよう支援したいと考えています。

00:02:24.000 --> 00:02:35.000
Swiftオープンソースプロジェクトへの貢献をより親しみやすくするために、私たちは最近、新規参入者が定期的な貢献者から直接サポートと指導を受けるのを支援するSwiftメンターシッププログラムを発表しました。

00:02:35.000 --> 00:02:38.000
このプログラムはAppleのプロジェクトに限定されるものではありません。

00:02:38.000 --> 00:02:44.000
また、Swiftパッケージとオープンソースツールのエコシステム全体を網羅しています。

00:02:44.000 --> 00:02:48.000
次に、パッケージについて話したいと思います。

00:02:48.000 --> 00:02:56.000
パッケージは、ソフトウェアを構築するための基本的な構成要素であり、増え続けるオープンソースコードの配列を便利に活用することができます。

00:02:56.000 --> 00:03:04.000
Swiftコミュニティのメンバーは、Swiftパッケージインデックスなど、開発者がパッケージを見つけるのに役立つ素晴らしいソリューションを考え出しました。

00:03:04.000 --> 00:03:12.000
Swift Package Indexは、Swift Package Managerをサポートするパッケージを見つけるのに役立つコミュニティによって作成されたページです。

00:03:12.000 --> 00:03:32.000
現在、Swift 5.5とXcode 13では、統合Xcodeツールサポートを提供し、開発ワークフローの一部としてプロジェクト内のパッケージをより迅速かつ簡単に使用できるようにすることで、パッケージを見つけてアクセスするための追加の方法を提供しています。

00:03:32.000 --> 00:03:42.000
今年は、コマンドラインとXcode 13の両方から使用できるSwiftパッケージのキュレーションリストであるSwiftパッケージコレクションを紹介します。

00:03:42.000 --> 00:03:50.000
パッケージコレクションを使用すると、インターネット上でパッケージを検索したり、URLをコピー&amp;ペーストして追加したりする必要はありません。

00:03:50.000 --> 00:03:55.000
Xcodeの新しいパッケージ検索画面からコレクションを閲覧し、パッケージを追加できるようになりました。

00:03:55.000 --> 00:04:00.000
パッケージコレクションは、どこにでも公開できるシンプルなJSONファイルです。

00:04:00.000 --> 00:04:06.000
パッケージコレクションは、誰もがさまざまなユースケースのパッケージのキュレーションされたリストを作成できるようにすることを目的としています。

00:04:06.000 --> 00:04:22.000
たとえば、コンピュータサイエンスクラスのインストラクターは、そのクラスの概念を教えるのに役立つパッケージのセットをまとめることができます。または、誰かが特定のドメインやタスクに適したパッケージ、または組織で使用されるパッケージのコレクションをまとめることができます。

00:04:22.000 --> 00:04:27.000
私たちは、人々がコレクションを使用するさまざまな方法を見ることに興奮しています。

00:04:27.000 --> 00:04:33.000
パッケージコレクションに関する素晴らしいプレゼンテーションがありますので、詳細を確認することをお勧めします。

00:04:33.000 --> 00:04:37.000
パッケージコレクションには、Xcodeの強力なツールサポートが含まれています。

00:04:37.000 --> 00:04:41.000
あなたは今、お気に入りのAPIの使用からちょうどインポートです。

00:04:41.000 --> 00:04:54.000
見つからないモジュールをインポートしようとすると、Xcodeは、設定したパッケージコレクション内のパッケージのいずれかがそのモジュールを提供しているかどうかを確認し、そのパッケージを自動的に使用を開始する機会を提供します。

00:04:54.000 --> 00:05:01.000
パッケージの使用を選択すると、パッケージコレクションの情報に基づいてすべての設定が処理されます。

00:05:01.000 --> 00:05:08.000
パッケージコレクションも検索可能で、ユースケースに合ったパッケージを簡単に見つけることができます。

00:05:08.000 --> 00:05:18.000
今日パッケージコレクションを試すことに興味があるなら、AppleがGitHubで公開しているSwiftパッケージのパッケージコレクションなど、すでに利用可能なものがいくつかあります。

00:05:18.000 --> 00:05:23.000
Xcodeは、Appleコレクションを使用するために事前に配線されています。

00:05:23.000 --> 00:05:34.000
コミュニティからすでに入手可能なコレクションを含むパッケージコレクションの詳細については、パッケージコレクションに関する新しいswift.orgのブログ記事をご覧ください。

00:05:34.000 --> 00:05:42.000
お気に入りのAPIといえば、AppleはオープンソースのSwiftパッケージのファミリーを増やしています。

00:05:42.000 --> 00:05:48.000
お気に入りのパッケージの大きな機能強化に加えて、今年はさらに4つの新しいパッケージを発売しました。

00:05:48.000 --> 00:05:55.000
まず、スウィフトコレクションについてお話ししたいと思います。

00:05:55.000 --> 00:06:04.000
Swift Collectionsは、Swift Standard Libraryで利用可能なものを補完するデータ構造の新しいオープンソースパッケージです。

00:06:04.000 --> 00:06:16.000
Swift Collectionsの初期バージョンには、最も頻繁に要求される3つのデータ構造の実装が付属しています：Deque、OrderedSet、およびOrderedDictionary。

00:06:16.000 --> 00:06:24.000
Dequeは、両端で効率的な挿入と削除をサポートすることを除いて、配列のようなものです。

00:06:24.000 --> 00:06:29.000
OrderedSetは、配列とセットの強力なハイブリッドです。

00:06:29.000 --> 00:06:34.000
Arrayと同様に、OrderedSetは要素を順番に維持し、ランダムアクセスをサポートします。

00:06:34.000 --> 00:06:43.000
セットと同様に、OrderedSetは各要素が一度だけ表示されるようにし、効率的なメンバーシップテストを提供します。

00:06:43.000 --> 00:06:52.000
そして最後はOrderedDictionaryです。これは、順序が重要な場合、または要素へのランダムなアクセスが必要な場合、辞書の便利な代替手段です。

00:06:52.000 --> 00:06:56.000
次に、スウィフトアルゴリズムについて話しましょう。

00:06:56.000 --> 00:07:03.000
Swift Algorithmsは、シーケンスとコレクションアルゴリズムの新しいオープンソースパッケージです。

00:07:03.000 --> 00:07:29.000
要素のコレクションのすべての組み合わせまたは順列を生成したり、シーケンスの要素を2つまたは3つまたは述語によって決定されたグループで反復したり、コレクション内の5つの最小要素、最大の5つ、または任意の5つをランダムに選択するなど、すでに40以上のアルゴリズムをSwiftアルゴリズムに追加しました。

00:07:29.000 --> 00:07:38.000
語彙を学ぶには少しの投資が必要ですが、一度そうすると、どれだけのアルゴリズムが目の前に隠れているかを発見するのは印象的です。

00:07:38.000 --> 00:07:49.000
詳細を知りたい場合は、新しいSwiftアルゴリズムとコレクションパッケージがコードをより明確に、より速く、より正確にするのにどのように役立つかを説明するセッションがあります。

00:07:49.000 --> 00:07:51.000
では、スウィフトシステムについて話しましょう。

00:07:51.000 --> 00:08:00.000
昨年の秋、私たちはシステムコールに慣用的で低レベルのインターフェイスを提供するライブラリであるSwift Systemをオープンソース化しました。

00:08:00.000 --> 00:08:05.000
システムは、Appleプラットフォーム、Linux、さらにはWindowsでも利用できます。

00:08:05.000 --> 00:08:12.000
最近、一般的なパス操作操作を実行するために、システムのFilePathタイプに強力な新しいAPIを追加しました。

00:08:12.000 --> 00:08:21.000
これらには、拡張機能を照会または設定し、コンポーネントを追加および削除し、パス正規化を実行する機能が含まれます。

00:08:21.000 --> 00:08:27.000
パスは、そのルートとその相対的な構成要素に分解することができます。

00:08:27.000 --> 00:08:38.000
FilePathのComponentViewは、構造化されたパスコンポーネントのコレクションです。つまり、箱から出してすぐにSwiftの一般的なアルゴリズムの多くをサポートしています。

00:08:38.000 --> 00:08:47.000
また、Windowsをターゲットにする場合、複雑なルートコンポーネントを持つWindowsパスは、すべての新しいFilePath APIで完全にサポートされています。

00:08:47.000 --> 00:08:51.000
次に、Swift Numericsについて話しましょう。

00:08:51.000 --> 00:08:55.000
Swift Numericsは今年、多くの大きな追加を受けました。

00:08:55.000 --> 00:09:00.000
昨年、Float16をiOS、tvOS、watchOSに導入しました。

00:09:00.000 --> 00:09:09.000
今年は、Apple Silicon MacにFloat16のサポートと、Float16ベースの複素数を作成する機能を追加しました。

00:09:09.000 --> 00:09:18.000
今年のもう1つの追加は、対数、正弦、コサインなどのすべての基本関数の複素数サポートです。

00:09:18.000 --> 00:09:28.000
これらの実装はSwiftで書かれているため、従来のCライブラリよりも効率的であり、他の方法では不可能な最適化が可能です。

00:09:28.000 --> 00:09:32.000
最後に、Swift ArgumentParserについて話しましょう。

00:09:32.000 --> 00:09:44.000
今年は、Fishシェルのコード補完スクリプトの生成、短いオプションの参加、エラーメッセージの改善など、Swift ArgumentParserの改良を続けました。

00:09:44.000 --> 00:09:53.000
また、この春、ArgumentParserがXcode 12.5のSwift Package Managerに採用された重要なマイルストーンを通過しました。

00:09:53.000 --> 00:09:54.000
そうです！

00:09:54.000 --> 00:10:01.000
最近Swift Package Managerのコマンドラインツールを使用した場合は、Swift ArgumentParserを使用しました。

00:10:01.000 --> 00:10:07.000
次に、サーバー開発でSwiftをサポートするために行ったいくつかの作業について話したいと思います。

00:10:07.000 --> 00:10:12.000
昨年、Amazon Linuxを含む多くのプラットフォームのサポートを追加しました。

00:10:12.000 --> 00:10:21.000
今年は、Swiftサーバーアプリケーションのパフォーマンスと機能に投資することで、その作業をフォローアップしました。

00:10:21.000 --> 00:10:32.000
Linuxで静的リンクを有効にすることから始めました。これにより、アプリケーションの起動時間が改善され、サーバーアプリケーションの展開が簡素化され、単一のファイルとして展開できるようになりました。

00:10:32.000 --> 00:10:44.000
また、Swift 5.5では、Linuxで使用されるJSONエンコーディングとデコードがゼロから再実装され、最も一般的なユースケースのパフォーマンスが向上しました。

00:10:44.000 --> 00:10:51.000
最後に、AWS Lambdaランタイムライブラリ自体のパフォーマンスを強化および最適化しました。

00:10:51.000 --> 00:11:06.000
これらすべての作業により、AWS Lambdaで実行されているSwiftプログラムの起動速度が33%速くなり、AWS APIゲートウェイを介してルーティングされたラムダの呼び出し時間が40%速くなりました。

00:11:06.000 --> 00:11:16.000
AWSランタイムライブラリのパフォーマンスを最適化することに加えて、クロージャの代わりに新しい非同期/待機モデルを使用するようにリファクタリングしました。

00:11:16.000 --> 00:11:21.000
Swift開発者体験の向上は、Swift 5.5のもう1つの重要な焦点です。

00:11:21.000 --> 00:11:25.000
ドキュメントについて話すことから始めたいと思います。

00:11:25.000 --> 00:11:33.000
優れたドキュメントを提供することは、フレームワークのユーザーにスムーズで楽しい体験を提供するための鍵です。

00:11:33.000 --> 00:11:45.000
今年は、開発者にSwiftフレームワークやパッケージの使い方を教えるために、Xcode 13に深く統合されたドキュメントコンパイラであるDocCを導入します。

00:11:45.000 --> 00:11:51.000
素晴らしいドキュメントを作成して共有することがこれまで以上に簡単になりました。

00:11:51.000 --> 00:12:04.000
DocCは、Swiftソースコードのマークダウンコメントなど、すでに知っていて愛しているツールやテクノロジーを使用してゼロから構築されているため、ドキュメントを簡単に作成したり差分したりできます。

00:12:04.000 --> 00:12:10.000
XcodeでDocCドキュメントのあらゆる側面を紹介する4つの素晴らしいセッションがあります。

00:12:10.000 --> 00:12:13.000
それらをチェックすることを強くお勧めします。

00:12:13.000 --> 00:12:20.000
そして今、Swift DocCが今年後半にオープンソース化されることを発表できることを嬉しく思います。

00:12:20.000 --> 00:12:30.000
オープンソースのSwift DocCにより、開発者はSwiftでサポートされているすべてのプラットフォームで優れたドキュメントをより簡単に生成できます。

00:12:30.000 --> 00:12:36.000
Swift 5.5では、タイプチェッカーの品質とパフォーマンスの向上に投資しました。

00:12:36.000 --> 00:12:43.000
この結果の1つは、コードをコンパイルするときに「表現が複雑すぎる」エラーが少なくなるということです。

00:12:43.000 --> 00:12:48.000
また、配列リテラルの型チェックのパフォーマンスも高速化しました。

00:12:48.000 --> 00:12:56.000
このリリースでは、増分ビルドをスピードアップするための3つの大きな改善により、開発者の生産性も向上しています。

00:12:56.000 --> 00:13:06.000
まず、増分インポートをサポートするようになりました。つまり、そのモジュールが変更されたときにモジュールをインポートするすべてのソースファイルを再構築しなくなりました。

00:13:06.000 --> 00:13:15.000
さらに、モジュールの依存関係グラフを事前に計算して、変更されたもののみの増分ビルドをすばやく開始できるようになりました。

00:13:15.000 --> 00:13:25.000
最後に、拡張機能で動作するように選択的な再コンパイルを拡張しました。つまり、拡張機能の本体を変更すると再コンパイルが少なくなります。

00:13:25.000 --> 00:13:43.000
SwiftDriverオープンソースプロジェクトを例として、平均して、Swift 5.5の増分インポートでは、インポートされたモジュールが変更されたときに10分の1未満のファイルを再コンパイルし、ビルド時間が約3分の1短縮されます。

00:13:43.000 --> 00:13:52.000
増分インポートによるパフォーマンスの向上は、プロジェクトをモジュール化し、ビルドパフォーマンスに大きなペナルティを与えることなく、インポートされたモジュールを変更できることを意味します。

00:13:52.000 --> 00:14:04.000
ところで、これらのパフォーマンスの向上のいくつかは、Swiftで記述されるコンパイラの最初の部分であるSwiftプロジェクトの重要なマイルストーンによって可能になりました。

00:14:04.000 --> 00:14:10.000
これは、Swiftソースコードのコンパイルを調整するプログラムであるSwift Driverです。

00:14:10.000 --> 00:14:17.000
このプロジェクトは2019年後半に開始され、Xcode 13の時点で、現在はSwiftコンパイルのデフォルトです。

00:14:17.000 --> 00:14:27.000
最後に、Swiftプログラムがより迅速にメモリを取り戻すために、Swiftのメモリ管理をより効率的にするために行った改善について話しましょう。

00:14:27.000 --> 00:14:37.000
Swiftクラスインスタンスは、自動参照カウント、ARCを使用して、特定の時点で特定のオブジェクトへの参照の数を追跡します。

00:14:37.000 --> 00:14:46.000
ほとんどの場合、これはメモリ管理がSwiftで動作することを意味し、自分でメモリ管理について考える必要はありません。

00:14:46.000 --> 00:14:52.000
ARCは、これらのインスタンスが不要になったときに、クラスインスタンスで使用されるメモリを自動的に解放します。

00:14:52.000 --> 00:15:04.000
これを行うには、Swiftコンパイラは、新しい参照が作成されるたびに保持操作を挿入し、新しい参照が使用を停止するたびにリリース操作を挿入します。

00:15:04.000 --> 00:15:14.000
今年は、コンパイラが保持およびリリース操作の数を大幅に削減できるように、コンパイラ内の参照を追跡する新しい方法を導入しました。

00:15:14.000 --> 00:15:20.000
この変更により、測定可能なパフォーマンスとコードサイズの改善が見られました。

00:15:20.000 --> 00:15:30.000
Xcodeの設定「Optimize Object Lifetimes」を追加しました。これにより、この新しい、より積極的なARC最適化のコードへの影響を確認できます。

00:15:30.000 --> 00:15:36.000
ARCの詳細については、「ARC in Swift」セッションをご覧ください。

00:15:36.000 --> 00:15:40.000
これらは、Swift 5.5によってもたらされた改善点のほんの一部です。

00:15:40.000 --> 00:15:46.000
次に、ティムはSwiftの並行性やSwift言語のその他の進化について話します。

00:15:46.000 --> 00:15:48.000
ありがとう、ニコール。

00:15:48.000 --> 00:15:59.000
私たちは皆、Swift Concurrencyに非常に興奮していますが、その前に、日常のプログラミングを簡素化および改善するためにSwiftに加えた他の多くの変更について話し合いたいと思います。

00:15:59.000 --> 00:16:02.000
これが私たちが今年行った人間工学的な改善のリストです。

00:16:02.000 --> 00:16:06.000
SE番号は、Swift Evolutionの提案を特定します。

00:16:06.000 --> 00:16:16.000
これらの提案のそれぞれは、コミュニティのメンバーによって書かれ、Swift Evolutionフォーラムで議論され、言語に受け入れられる前にSwiftコアチームによって承認されました。

00:16:16.000 --> 00:16:25.000
すべてのSE提案は、受け入れられるか、拒否されるか、まだ議論中かにかかわらず、GitHubのSwift Evolutionリポジトリで見つけることができます。

00:16:25.000 --> 00:16:27.000
これらの変更のいくつかを見てみましょう。 いくつか見てみましょう。

00:16:27.000 --> 00:16:30.000
まず、結果ビルダー。

00:16:30.000 --> 00:16:39.000
SwiftUIが最初に発表されたとき、複雑なオブジェクト階層をすばやく簡単に記述するために使用できる新しい構文を導入しました。

00:16:39.000 --> 00:16:49.000
昨年、その構文はSwift Evolutionプロセスを通じて標準化され、洗練され、さまざまなコンテキストでより簡単に使用できるようになりました。

00:16:49.000 --> 00:16:57.000
この強力な技術を利用したい場合は、特にResult Buildersの使用に特化したセッションがあります。

00:16:57.000 --> 00:17:04.000
Codableプロトコルは、データをシリアライズする便利な方法ですが、長い間顕著な省略に苦しんできました。

00:17:04.000 --> 00:17:07.000
この2つのケースの列挙型を考えてみましょう。

00:17:07.000 --> 00:17:15.000
Codableに準拠するためには、以前はこのすべてのボイラープレートを手動で実装する必要ができていました。

00:17:15.000 --> 00:17:22.000
今、あなたはCodable適合性を宣言する必要があり、コンパイラはあなたのためにそのすべての作業を行います。

00:17:22.000 --> 00:17:26.000
また、Swiftのタイプチェッカーにいくつかの重要な改善を行いました。

00:17:26.000 --> 00:17:31.000
ご存知のように、Swiftの型推論は、冗長な型情報を省略できることを意味します。

00:17:31.000 --> 00:17:37.000
ここでは、Coffee.regularをjust .regularに短縮できます。

00:17:37.000 --> 00:17:40.000
しかし、列挙型のような構造も他の方法で表現されます。

00:17:40.000 --> 00:17:50.000
たとえば、プロトコルに準拠したタイプのコレクションがあり、APIでそれらのタイプのインスタンスを使用したい場合があります。

00:17:50.000 --> 00:18:00.000
プロトコルでいくつかの静的プロパティを宣言することで、Enumsに使用するのと同じドット表記を使用して、これらのタイプのインスタンスを参照できるようになりました。

00:18:00.000 --> 00:18:12.000
これは、ここで.largeなどのチェーンプロパティ参照を含む、一般的なコンテキストの静的プロパティについてより一般的に推論できるSwiftの型チェッカーの改善によって有効になります。

00:18:12.000 --> 00:18:23.000
これにより、ライブラリ作成者は、自然で使いやすいEnumのようなAPIを使用して、洗練された汎用データモデルを構築できます。

00:18:23.000 --> 00:18:27.000
今年はプロパティラッパーも改善されました。

00:18:27.000 --> 00:18:31.000
プロパティラッパーは、プロパティに共通のセマンティクスを適用するための便利なツールです。

00:18:31.000 --> 00:18:37.000
あなた方の多くは、構造体に@propertyWrapperアノテーションを使用して、独自のプロパティラッパーを実装しています。

00:18:37.000 --> 00:18:42.000
以下は、プロパティが空ではないという要件を追加する例です。

00:18:42.000 --> 00:18:52.000
SE-0293の実装により、これらの同じプロパティラッパーを関数およびクロージャパラメータに使用できるようになりました。

00:18:52.000 --> 00:18:58.000
累積的に、言語へのこれらおよびその他の変更は、多くの一般的なコーディング問題を簡素化することができます。

00:18:58.000 --> 00:19:03.000
簡単なSwiftUIコードサンプルの文脈でそれらを一緒に見てみましょう。

00:19:03.000 --> 00:19:16.000
これは、設定の配列を保持する単一のプロパティと、それらの設定のリストを表示するボディを持つSwiftUIビューで、それぞれの横にトグルがあります。

00:19:16.000 --> 00:19:22.000
このコードを確認して、新しいSwift 5.5の機能がどのようにそれを簡素化できるかを見てみましょう。

00:19:22.000 --> 00:19:26.000
まず、その Toggle() 初期化子は明らかに複製されます。

00:19:26.000 --> 00:19:40.000
この重複は以前は必要でしたが、#ifの使用を緩和して、ここのtoggleStyle修飾子などの接尾辞式をサラウンドできるようにしました。これにより、その冗長性を考慮することができます。

00:19:40.000 --> 00:19:46.000
SwiftUIは、先ほど述べた新しいタイプチェッカーの改善を利用するためにも更新されました。

00:19:46.000 --> 00:19:51.000
そのため、より多くの場所で自然なドット表記を使用できます。

00:19:51.000 --> 00:19:58.000
設定配列にインデックスを指定し、クロージャ内の配列をインデックスするのは少し厄介です。

00:19:58.000 --> 00:20:01.000
私たちはむしろ価値観をステップスルーしたい。

00:20:01.000 --> 00:20:08.000
これで、投影されたバインディングをリストコンストラクタに直接渡すことができ、配列値を反復することができます。

00:20:08.000 --> 00:20:16.000
プロパティラッパー引数の新しいサポートにより、クロージャ引数をドル記号で書くことができ、クロージャでバインドされた設定が得られます。

00:20:16.000 --> 00:20:21.000
これにより、ラップされた値とバインディングの両方にアクセスできます。

00:20:21.000 --> 00:20:33.000
そして最後に、SwiftコンパイラはCGFloatとDoubleの間で透過的に変換されるようになり、AppleプラットフォームAPIを使用する際に多くの冗長な数値変換を排除することができます。

00:20:33.000 --> 00:20:46.000
ご覧のとおり、コア言語を洗練するための継続的な努力は、あなたが毎日書くコードをこれまで以上にシンプルにし、図書館の作者が豊かで使いやすいAPIを構築する機会を増やしています。

00:20:46.000 --> 00:20:54.000
SwiftUIプログラミングが今年改善された多くの方法の詳細については、「SwiftUIの新機能」セッションをご覧ください。

00:20:54.000 --> 00:21:03.000
もちろん、Swift 5.5のハイライトは、非同期および同時プログラミングをサポートする一連の連動機能です。

00:21:03.000 --> 00:21:10.000
これらをすぐに紹介しますが、まず、「非同期」と「並行」の意味を簡単に説明しましょう。

00:21:10.000 --> 00:21:15.000
ソフトウェアプロジェクトは、何らかの順序で実行されるコードブロックで構成されています。

00:21:15.000 --> 00:21:20.000
最も単純なケースでは、これらのブロックは単純な順序で次々に実行されます。

00:21:20.000 --> 00:21:22.000
しかし、他の構造も一般的です。

00:21:22.000 --> 00:21:29.000
たとえば、ネットワークAPIは、多くの場合、非同期スタイルで設計されています。

00:21:29.000 --> 00:21:37.000
これらのAPIでは、リモートサーバーにリクエストを送信した後、応答を受け取り、より多くの作業が必要になるまで長い遅延が生じる可能性があります。

00:21:37.000 --> 00:21:46.000
理想的には、この遅延中にコードが一時停止されるため、応答に基づいて行動できるまでリソースを使用しません。

00:21:46.000 --> 00:21:54.000
対照的に、同時コードは、同時に実行したい2つ以上のコードブロックがある場合です。

00:21:54.000 --> 00:21:57.000
これらは多くの場合、独立していますが、関連する操作です。

00:21:57.000 --> 00:22:07.000
たとえば、ビデオのいくつかのフレームを処理したり、前の結果セットでUIを更新すると同時にML分類器の次の反復を実行したりします。

00:22:07.000 --> 00:22:17.000
これらのアイデアを念頭に置いて、Swiftの新機能を使用せずに、簡単な非同期プログラミングの例を見てみましょう。

00:22:17.000 --> 00:22:24.000
iOSやmacOSのプログラミングをたくさんやったことがあるなら、これに似たコードを何度も書いたことがあるかもしれません。

00:22:24.000 --> 00:22:27.000
これは、FoundationのURLSessionクラスを使用してネットワークコールを行います。

00:22:27.000 --> 00:22:30.000
dataTaskメソッドは非同期操作です。

00:22:30.000 --> 00:22:32.000
あなたはクロージャ引数でそれを呼び出します。

00:22:32.000 --> 00:22:37.000
結果が利用可能になると、処理する結果とともにクロージャが呼び出されます。

00:22:37.000 --> 00:22:47.000
ただし、この方法でクロージャを使用して非同期コードを表現すると、このコードを歩くとわかるように、やや厄介な操作順序になります。

00:22:47.000 --> 00:22:53.000
まず、いくつかの初期設定があり、dataTaskメソッドはタスクハンドルを返してくれます。

00:22:53.000 --> 00:22:57.000
次に、タスクハンドルを再開してバックグラウンド操作を開始します。

00:22:57.000 --> 00:23:01.000
fetchImage関数は、この時点で実際に返されます。

00:23:01.000 --> 00:23:08.000
私たちに電話した人は誰でも、私たちが頼まれた仕事を実際にやっていないにもかかわらず、続ける準備ができていなければなりません。

00:23:08.000 --> 00:23:13.000
その後、ネットワーク運用が完了した後、この閉鎖は結果に対処する機会があります。

00:23:13.000 --> 00:23:20.000
うまくいけば、すべてがうまくいき、最終結果で完了ハンドラーを呼び出すことができます。

00:23:20.000 --> 00:23:28.000
やや厄介な実行順序に加えて、完了ハンドラを使用すると、試行/キャッチエラー処理を使用できなくなります。

00:23:28.000 --> 00:23:38.000
dataTaskが完了ハンドラに余分なエラーパラメータを提供する方法と、可能なすべてのエラーで完了ハンドラを呼び出す必要がある方法に注目してください。

00:23:38.000 --> 00:23:44.000
Swift 5.5がこれをどのように改善するかを見るために、この1行のコードを見てみましょう。

00:23:44.000 --> 00:23:51.000
この呼び出しがタスク、バックグラウンド操作を表す抽象ハンドルを返す方法に注目してください。

00:23:51.000 --> 00:23:53.000
それは本当に私たちが望むものではありません。

00:23:53.000 --> 00:23:55.000
私たちはただデータを入手したいだけです。

00:23:55.000 --> 00:23:59.000
だから、そのアイデアを少し推し進めて、どこで終わるか見てみましょう。

00:23:59.000 --> 00:24:03.000
HTTPを扱っているので、応答メタデータもキャプチャする必要があります。

00:24:03.000 --> 00:24:11.000
したがって、この関数は、実際のデータを最初の項目として、追加情報を2番目の項目として、実際にペアを返します。

00:24:11.000 --> 00:24:21.000
これをデータを返す関数呼び出しとして構造化することで、try/catchエラー処理を使用して、前の例から多くのボイラープレートを削除できるようになりました。

00:24:21.000 --> 00:24:34.000
データメソッドが開始されるとすぐに関数を一時停止することができ、その操作が完了するまで割り当てを完了できないことをコンパイラに伝えるために、少しの構文が必要です。

00:24:34.000 --> 00:24:37.000
これはまさに新しいawaitキーワードが行うことです。

00:24:37.000 --> 00:24:40.000
それを文脈で見てみましょう。

00:24:40.000 --> 00:24:43.000
fetchImage関数の現在の様子は次のとおりです。

00:24:43.000 --> 00:24:46.000
ご覧のとおり、このコードは従うのがはるかに簡単になりました。

00:24:46.000 --> 00:24:53.000
コントロールは上から下に流れ、ネストされたクロージャは不要になり、try/catchエラー処理を使用できます。

00:24:53.000 --> 00:25:05.000
awaitキーワードは、このfetchImage関数を一時停止できるポイントを示し、続行できるイベントが発生するまで実行しないように設定します。

00:25:05.000 --> 00:25:15.000
この場合、URLSessionがリクエストを開始するとすぐに、操作が他の場所で実行されている間、私たちの機能はSwiftランタイムによって中断されます。

00:25:15.000 --> 00:25:23.000
最終結果の準備ができたら、それが成功した応答であろうとスローされたエラーであろうと、私たちの機能は再開されます。

00:25:23.000 --> 00:25:28.000
応答が成功した場合、データと応答変数の初期化を完了します。

00:25:28.000 --> 00:25:32.000
スローされたエラーの場合は、私たちに電話した人に返します。

00:25:32.000 --> 00:25:37.000
非同期関数は、一時停止中はリソースを使用しません。

00:25:37.000 --> 00:25:40.000
特に、スレッドをブロックしていません。

00:25:40.000 --> 00:25:46.000
これにより、Swiftランタイムは、この関数が実行されていたスレッドを他の作業に再利用することができます。

00:25:46.000 --> 00:25:52.000
これにより、多くの非同期プロセス間でごく少数のスレッドを共有できます。

00:25:52.000 --> 00:25:58.000
構文的には、async キーワードと await キーワードは、スローと試行に同様に使用されます。

00:25:58.000 --> 00:26:05.000
Asyncは、この関数がサスペンションをサポートするためにコンパイルされなければならないことを示すために関数宣言を飾ります。

00:26:05.000 --> 00:26:11.000
Awaitキーワードを使用して、非同期関数、メソッド、またはクロージャへの呼び出しをマークします。

00:26:11.000 --> 00:26:15.000
もちろん、完全なメカニズムは、私がここで示したものよりもはるかに興味深いです。

00:26:15.000 --> 00:26:23.000
「Meet async/await in Swift」と「Swift concurrency: Behind the scenes」のセッションを見て、これらすべてがどのように機能するかについて詳しく知ることができます。

00:26:23.000 --> 00:26:30.000
次に、先ほど説明した非同期/待機の概念に基づいて構築されたSwiftの新しい並行性サポートを見てみましょう。

00:26:30.000 --> 00:26:35.000
これは、3つの異なる画像をレンダリングし、それらを結合する機能です。

00:26:35.000 --> 00:26:39.000
ここに書かれているように、これらの操作は順次です。

00:26:39.000 --> 00:26:48.000
背景、前景、タイトル画像は次々にレンダリングされ、それぞれが前の画像が完了した後にのみ開始されます。

00:26:48.000 --> 00:26:51.000
レンダリング操作を並行して実行したいと考えています。

00:26:51.000 --> 00:27:00.000
しかし、異なるスレッドでそれらを実行するだけでは十分ではありません。また、3つの結果がすべて得られるまで、マージ操作を保持する必要があります。

00:27:00.000 --> 00:27:04.000
これは、いくつかの点で、私が今話していた非同期コーディングに似ています。

00:27:04.000 --> 00:27:11.000
そのため、この関数を「非同期」としてマークして、他のスレッドで計算されている結果を待つ必要がある場合に一時停止できるようにします。

00:27:11.000 --> 00:27:17.000
次に、非同期let構文を使用して、最初の2つの操作を並行して実行します。

00:27:17.000 --> 00:27:22.000
Async letは変数の初期化によく似ており、それは基本的にそれです。

00:27:22.000 --> 00:27:28.000
しかし、この初期化は、結果を使用しようとするまで、他のコードと並行して実行されます。

00:27:28.000 --> 00:27:40.000
バックグラウンド変数とフォアグラウンド変数は非同期レットで初期化されているため、Swiftのランタイムは、必要に応じて、それらの値の準備が整うまでマージ操作を一時停止します。

00:27:40.000 --> 00:27:46.000
これを示すために、awaitキーワードでマージ関数をマークします。

00:27:46.000 --> 00:27:52.000
このコードに関する最も重要な点は、バックグラウンドタスクがこの機能よりも長生きできないということです。

00:27:52.000 --> 00:28:00.000
別の言い方をすれば、2つのバックグラウンドタスクのいずれかがまだ実行されている場合、この関数は戻ることができず、戻りません。

00:28:00.000 --> 00:28:07.000
この関数内のどこからでもエラーがスローされた場合、Swiftランタイムはバックグラウンドタスクが完了するのを待ちます。

00:28:07.000 --> 00:28:17.000
ここでは、タイトル画像の計算がスローされる可能性があることを示すトライマーカーを強調表示しましたが、別のスレッドで発生した場合でも、すべてのスローされたエラーにも同じことが当てはまります。

00:28:17.000 --> 00:28:25.000
物事をレスポンシブに保つために、スローされたエラーがある場合、Swiftランタイムは未完成のタスクに通知し、早期に完了する機会を与えます。

00:28:25.000 --> 00:28:36.000
構造化並行性に関するセッションでは、このキャンセルメカニズムの完全な議論や、ここで説明した非同期レット構文のより柔軟な代替案など、詳細を提供します。

00:28:36.000 --> 00:28:45.000
前のセクションでは、Swift 5.5が規律ある構造化された方法で複数のスレッドで操作を簡単に実行する方法を示しました。

00:28:45.000 --> 00:28:48.000
もちろん、それだけでは十分ではありません。

00:28:48.000 --> 00:28:55.000
2つの別々のスレッドがデータを共有するたびに、データが矛盾したり、破損したりする危険性があります。

00:28:55.000 --> 00:28:59.000
スウィフトの新しいアクター構造は、そのような問題からデータを保護するのに役立ちます。

00:28:59.000 --> 00:29:04.000
繰り返しますが、あなたが自分で書いたかもしれないコードの例から始めましょう。

00:29:04.000 --> 00:29:06.000
これは統計を収集するクラスです。

00:29:06.000 --> 00:29:14.000
カウンタが含まれており、他のさまざまなコードがインクリメントメソッドを呼び出して、何か面白いことが起こるたびにそのカウンタを更新します。

00:29:14.000 --> 00:29:18.000
残念ながら、このコードはマルチスレッドシステムではうまく機能しません。

00:29:18.000 --> 00:29:24.000
2つ以上のスレッドが同時にインクリメントメソッドを呼び出すと、カウントがひどく破損する可能性があります。

00:29:24.000 --> 00:29:30.000
このクラスをスウィフトアクターに変更することで、そのような腐敗から保護されます。

00:29:30.000 --> 00:29:37.000
アクターは、その特定の変更を行うのが安全になるまで、データの破損を引き起こす可能性のある操作を一時停止することで作業します。

00:29:37.000 --> 00:29:44.000
これは、通常、俳優の外部から俳優メソッドを呼び出すときにawaitを使用する必要があることを意味します。

00:29:44.000 --> 00:29:47.000
俳優はまた、async/awaitとシームレスに動作します。

00:29:47.000 --> 00:29:53.000
このパブリッシュメソッドを非同期としてマークすると、ネットワーク操作を待っている間に一時停止することができます。

00:29:53.000 --> 00:30:01.000
中断されている間、他のメソッドは、ネットワーク操作が完了するのを待たずに、データ破損のリスクなしに、このアクターで実行できます。

00:30:01.000 --> 00:30:10.000
アクターはクラスのような参照タイプですが、アクターがマルチスレッド環境で安全に使用できるように設計された多くのルールに従います。

00:30:10.000 --> 00:30:22.000
データをアクターにパッケージ化することで、このデータが同時にアクセスされることを期待し、破損がないようにSwiftコンパイラとランタイムがアクセスを調整したいことを明確に述べています。

00:30:22.000 --> 00:30:27.000
そして、もちろん、私たちは特にスウィフトの新しい俳優の構築に専念する完全なセッションを持っています。

00:30:27.000 --> 00:30:32.000
そこでは、これがもたらすあらゆる機能を活用する方法を見つけることができます。

00:30:32.000 --> 00:30:39.000
締めくくる前に、スウィフトの未来について少し話しましょう。

00:30:39.000 --> 00:30:51.000
Swift 5.5で導入した3つの重要な概念（非同期関数、構造化並行性、アクター）は、安全で高性能なコードを作成するための良い基礎であると考えています。

00:30:51.000 --> 00:31:02.000
Swift 6では、コンパイラが開発プロセスの早い段階でより多くの種類の並行性の間違いをキャッチし、それらの問題を解決するためのより詳細なエラーとガイダンスを提供する方法をすでに研究しています。

00:31:02.000 --> 00:31:15.000
私たちの目標は、非常に簡単に言えば、非同期および同時プログラミングを他のどの種類のプログラミングよりも複雑にするために、最も一般的な種類の並行性のバグを完全に排除することです。

00:31:15.000 --> 00:31:27.000
そしてもちろん、これらの概念に対するコンパイラの理解を向上させ続けるにつれて、これらの新しい構造を使用するコードが今日よりもさらに効率的になることを期待しています。

00:31:27.000 --> 00:31:32.000
Swiftは、あなたのインプットを歓迎するオープンで協力的な取り組みです。

00:31:32.000 --> 00:31:37.000
Swift 6をさらに良くするために、Swift 5.5での経験について教えてください。

00:31:37.000 --> 00:31:42.000
これらの新機能は、実際のアプリ開発でどの程度うまく機能していますか?

00:31:42.000 --> 00:31:45.000
Swift.orgで見つけることができるコンパイラのスナップショットの1つを試してみてください。

00:31:45.000 --> 00:31:52.000
これらのスナップショットを提供しているので、Xcodeにインストールし、開発中に新機能を試すことができます。

00:31:52.000 --> 00:31:57.000
これらのスナップショットを使用することで、Swiftの次のバージョンを導くのに役立ちます。

00:31:57.000 --> 00:32:01.000
スウィフトフォーラムはプロジェクトの生命線です。

00:32:01.000 --> 00:32:09.000
私が議論した各機能は、多様な人々のグループがそれを作業提案に洗練するのを手伝ったSwift Evolutionフォーラムで売り込むことによって人生を始めました。

00:32:09.000 --> 00:32:19.000
また、新規ユーザー向けのヘルプエリアや、Swiftコミュニティに関心のあるニュースを交換する場所など、Swiftの他の多くの側面に特化したフォーラムもあります。

00:32:19.000 --> 00:32:29.000
スウィフトをより良くする方法は他にもたくさんあり、ニコールがこのセッションの冒頭で言及した新しいメンターシッププログラムなど、さらに多くの人々を巻き込むことを熱望しています。

00:32:29.000 --> 00:32:35.000
唯一の要件は、私たちのコミュニティのすべての人のためにSwiftを改善する手助けをしたいという誠実な願望です。

00:32:35.000 --> 00:32:38.000
ご連絡をお待ちしております。会議を楽しんでいただければ幸いです。

00:32:38.000 --> 23:59:59.000
[明るい音楽]。

