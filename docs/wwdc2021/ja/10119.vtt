WEBVTT

00:00:00.000 --> 00:00:05.000
♪ベース音楽の演奏♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:12.000
ネイサン・タナー:こんにちは、WWDCへようこそ!

00:00:12.000 --> 00:00:16.000
私の名前はネイサンで、アクセシビリティチームのエンジニアです。

00:00:16.000 --> 00:00:22.000
今日は、基本を超えて、例外的でアクセスしやすいSwiftUIアプリを提供する方法を学びます。

00:00:22.000 --> 00:00:27.000
今年は、SwiftUIのアクセシビリティの大きな飛躍を迎えます。

00:00:27.000 --> 00:00:30.000
アップルでは、アクセシビリティは私たちのコアバリューの1つです。

00:00:30.000 --> 00:00:40.000
すべてのプラットフォームにわたる当社の支援技術は、身体的、視覚的、聴覚的、または運動障害に関係なく、誰でもあなたのアプリを使用できるようにします。

00:00:40.000 --> 00:00:47.000
私のチームと私は、あなたのアプリのほとんどがデフォルトでアクセス可能であることを確認するために働いていますが、経験を豊かにするためにできることは常にあります。

00:00:47.000 --> 00:00:53.000
今日は、この体験を簡単に豊かにするSwiftUI用の新しいツールとAPIを紹介します。

00:00:53.000 --> 00:00:56.000
Xcodeのツールの改善から始めましょう。

00:00:56.000 --> 00:00:59.000
SwiftUIプレビューは、私たちの多くがアプリを開発する方法を変えました。

00:00:59.000 --> 00:01:09.000
アプリを実行することなく、複数の環境でビューを反復する能力を劇的に向上させます。

00:01:09.000 --> 00:01:15.000
最も重要なアクセシビリティ修飾子をワンクリックで作成するために、アクセシビリティエディタの厳選されたリストを追加しました。

00:01:15.000 --> 00:01:19.000
これが、誰もが常に自分の意見にアクセスできるようにすることを奨励することを願っています。

00:01:19.000 --> 00:01:21.000
しかし、もっとあります。

00:01:21.000 --> 00:01:31.000
アクセシビリティ修飾子にはプレビューに視覚的な変更がないため、Xcodeを離れることなくビューのアクセシビリティを検査できる新しいツールが開発されました。

00:01:31.000 --> 00:01:36.000
エディターパネルから新しいアクセシビリティパネルに切り替えましょう。

00:01:36.000 --> 00:01:42.000
Xcode 13での出荷、SwiftUIプレビューは、アクセシビリティプレビューも備えるようになりました。

00:01:42.000 --> 00:01:46.000
それを使えば、アクセシビリティ要素をリアルタイムで検査してプレビューすることができます。

00:01:46.000 --> 00:01:48.000
そして、これはゲームチェンジャーです。

00:01:48.000 --> 00:01:56.000
アクセシビリティプレビューは、各支援技術を深く理解していなくても、アクセス可能なアプリを作るのに役立ちます。

00:01:56.000 --> 00:02:01.000
変更がアクセシビリティプレビューにどのように反映されているかを詳しく見てみましょう。

00:02:01.000 --> 00:02:04.000
これは、先ほど見たビューの簡略化されたバージョンです。

00:02:04.000 --> 00:02:12.000
プレビューを実行した後、VStackを選択すると、アクセシビリティプレビューが更新され、要素がソートされた順序で表示されます。

00:02:12.000 --> 00:02:20.000
各要素には、ラベルや特性などの基本的なプロパティが常に表示されることに注意してください。

00:02:20.000 --> 00:02:25.000
たとえば、テキストビューは、文字列をラベルとしてアクセシビリティ要素を作成します。

00:02:25.000 --> 00:02:28.000
また、.isStaticText特性も得ます。

00:02:28.000 --> 00:02:35.000
プレビューは、.isHeaderトレイトを追加するなど、アクセシビリティの変更について更新されます。

00:02:35.000 --> 00:02:43.000
また、自動SFシンボルラベルなど、舞台裏で行われる自動アクセシビリティの一部を見ることができます。

00:02:43.000 --> 00:02:49.000
たとえば、checkmark.seal.fillシンボルはデフォルトで「Verified」とラベル付けされています。

00:02:49.000 --> 00:02:55.000
シンボルのデフォルトラベルに依存している場合は、インターフェイスを正確に記述していることを確認することが重要です。

00:02:55.000 --> 00:03:03.000
アプリのすべてのユーザーに優れた体験を提供するのに役立つ5つの重要な分野をステップスルーしながら、アクセシビリティプレビューを引き続き使用します。

00:03:03.000 --> 00:03:08.000
まず、カスタムコントロールにアクセスできるようにするための最良の方法を検討します。

00:03:08.000 --> 00:03:12.000
次に、子供と一緒に景色にアクセスできるようにする方法について説明します。

00:03:12.000 --> 00:03:19.000
一般的なナビゲーションの問題についてアプリを監査する方法と、アクセシビリティプレビューがこれをどのように支援できるかを強調します。

00:03:19.000 --> 00:03:25.000
次に、VoiceOverローターでアプリのナビゲーションをスーパーチャージする方法を紹介します。

00:03:25.000 --> 00:03:31.000
そして最後に、フォーカスとそれが支援技術とどのように関連しているかを見ていきます。

00:03:31.000 --> 00:03:35.000
私はWallet Palと呼ばれる新しい金融アプリのプロトタイプに取り組んできました。

00:03:35.000 --> 00:03:39.000
まだ初期段階ですが、これまでのところ、私は最初のデザインにかなり満足しています。

00:03:39.000 --> 00:03:43.000
初期のベータテスターもそれを気に入っていると聞いてうれしかったです。

00:03:43.000 --> 00:03:49.000
UIを磨いた今、私はアクセシビリティインターフェースを磨くためにいくつかの時間を費やす必要があります。

00:03:49.000 --> 00:03:54.000
アクセシビリティインターフェースは、誰もが使用できるように、視覚的な体験を補完します。

00:03:54.000 --> 00:04:02.000
私は何人かのVoiceOverユーザーにWallet Palのテストを手伝ってくれるように頼みましたが、このアプリはナビゲートが難しく、完全にアクセスできないと聞きました。

00:04:02.000 --> 00:04:08.000
部品がVoiceOverにアクセスできない場合は、他の支援技術にもアクセスできません。

00:04:08.000 --> 00:04:14.000
誰でもWallet Palを使用できることが重要なので、どこで体験を向上させることができるかを調査しましょう。

00:04:14.000 --> 00:04:20.000
Wallet Palの重要な機能である、ユーザーが予算を編集できないという報告から始めます。

00:04:20.000 --> 00:04:27.000
これは、ユーザーが食べ物、エンターテイメント、節約の予算を編集できる予算プランナービューです。

00:04:27.000 --> 00:04:32.000
Wallet Palのデザインに合うように、結局カスタムスライダーを作成する必要がありました。

00:04:32.000 --> 00:04:39.000
私は図形から予算スライダーを作成し、インタラクションにドラッグジェスチャーを使用することでこれを達成しました。

00:04:39.000 --> 00:04:50.000
SwiftUIの図形は、見事でユニークなビューを簡単に作成できますが、デフォルトではアクセスできないので、私の予算スライダーもそうではありません。

00:04:50.000 --> 00:04:54.000
これが、一部のユーザーが予算を編集できない理由に違いない。

00:04:54.000 --> 00:05:01.000
SwiftUIプレビューを実行し、SliderShapeを選択すると、アクセスできないことを確認できます。

00:05:01.000 --> 00:05:07.000
アクセシビリティプレビューは、要素がないことを示しているので、このコントロールにはアクセスできません。

00:05:07.000 --> 00:05:14.000
理想的には、変更できる値を持つ単一のラベル付きアクセシビリティ要素を持つべきです。

00:05:14.000 --> 00:05:23.000
対照的に、標準コントロールはデフォルトでアクセス可能であり、優れた体験を提供するために余分な労力がほとんど必要とされないことを意味します。

00:05:23.000 --> 00:05:34.000
SwiftUIは、ビュータイプとその初期化パラメータを使用して、アクセシビリティ要素のラベル、値、特性、およびアクションを自動的に導出します。

00:05:34.000 --> 00:05:38.000
では、カスタム予算スライダーにアクセスできるようにするための最良の方法は何ですか?

00:05:38.000 --> 00:05:48.000
標準スライダーはデフォルトでアクセス可能なので、私のチームと私は、あるビューのアクセシビリティを別のビューで表現できるAPIを持つことは素晴らしいことだと思いました。

00:05:48.000 --> 00:05:51.000
これが、アクセシビリティ表現(表現:)を作成するために私たちを導いたものです。

00:05:51.000 --> 00:05:57.000
これは、あるビューのアクセシビリティを別のビューで定義できるようにするAPIです。

00:05:57.000 --> 00:06:05.000
私はこれを支援技術によってスライダーとして認識させたいので、それは私がアクセシビリティ表現に使用するものです。

00:06:05.000 --> 00:06:11.000
accessibilityRepresentation(representation:)により、私たちは今、この予算スライダーをアクセシブルにするための道を歩んでいます。

00:06:11.000 --> 00:06:18.000
スライダーのエクスペリエンスを向上させるために必要な唯一の変更は、価値をドルで記述することです。

00:06:18.000 --> 00:06:23.000
そして素晴らしい、ちょうどそのように、今、私たちの予算スライダーは完全にアクセス可能です。

00:06:23.000 --> 00:06:27.000
macOSでは、コントロールの種類はVoiceOverユーザーにも話されます。

00:06:27.000 --> 00:06:34.000
したがって、予算スライダーの表現でスライダービューを使用すると、スライダーとしてアナウンスされます。

00:06:34.000 --> 00:06:40.000
カスタムコントロールにアクセスできるようにするために、可能であればaccessibilityRepresentation(representation:)を使用することをお勧めします。

00:06:40.000 --> 00:06:43.000
これは、accessibilityRepresentation(representation:)を使用する1つの方法にすぎません。

00:06:43.000 --> 00:06:47.000
その柔軟性は、より多くの創造的な使用を可能にします。

00:06:47.000 --> 00:06:51.000
アプリ内の他のアクセシビリティのバグを修正するために使用できるかどうか見てみましょう。

00:06:51.000 --> 00:06:59.000
予算を編集する機能機能を修正しましたが、一部のユーザーは、予算プランナービューに移動する方法を発見できなかったと報告しました。

00:06:59.000 --> 00:07:03.000
Wallet Palをデザインする際には、すべてのボタンにSFシンボルを使用することにしました。

00:07:03.000 --> 00:07:10.000
SFシンボルには優れたデフォルトのアクセシビリティラベルがあるかもしれませんが、必ずしも意図したユースケースに適合するとは限りません。

00:07:10.000 --> 00:07:15.000
問題がラベルの悪いボタンであるかどうかを調査しましょう。

00:07:15.000 --> 00:07:19.000
NavigationBarViewには、予算の編集ボタンが含まれています。

00:07:19.000 --> 00:07:27.000
多くのボタンをSFシンボルに頼っているので、SymbolButtonStyleと呼ばれるカスタムボタンスタイルを作成しました。

00:07:27.000 --> 00:07:36.000
しかし、「予算の編集」というラベルでボタンを初期化したにもかかわらず、ボタンのラベルはslider.vertical.3のようです。

00:07:36.000 --> 00:07:41.000
したがって、アクセシビリティラベルはSFシンボルから派生しています。

00:07:41.000 --> 00:07:45.000
SymbolButtonStyleを詳しく見てみましょう。

00:07:45.000 --> 00:07:49.000
SymbolButtonStyleのmakeBody(configuration:)メソッドは、画像ビューを返します。

00:07:49.000 --> 00:07:55.000
ボタンを初期化する予算の編集文字列は、構成のラベルとしてテキストビューを作成します。

00:07:55.000 --> 00:07:59.000
しかし、このスタイルは構成のラベルを完全に無視します。

00:07:59.000 --> 00:08:04.000
これが、ボタンが「予算の編集」とラベル付けされていない理由です。

00:08:04.000 --> 00:08:12.000
SFシンボルを視覚的に表示されるようにしたいが、ボタンのアクセシビリティを構成のラベルで表したい。

00:08:12.000 --> 00:08:17.000
そして、これはaccessibilityRepresentation(representation:)の素晴らしいユースケースのように思えます。

00:08:17.000 --> 00:08:26.000
accessibilityRepresentation(representation:)を使用すると、画像ビューのアクセシビリティを別のビュー、この場合は設定のラベルに置き換えることができます。

00:08:26.000 --> 00:08:30.000
このようにして、ボタンの作成に使用したラベルを保存できます。

00:08:30.000 --> 00:08:40.000
accessibilityRepresentation(representation:)は、カスタムコントロールをアクセス可能にするための理想的で推奨される方法であるだけでなく、ビューをアクセス可能にするための新しい創造的な可能性も開きます。

00:08:40.000 --> 00:08:46.000
次に、子供とアクセシビリティコンテナの関係について話し合いましょう。

00:08:46.000 --> 00:08:53.000
覚えているかもしれませんが、アクセシビリティ要素は、アクセシビリティコンテナの子としてグループにまとめることができます。

00:08:53.000 --> 00:09:00.000
これは、accessibilityElement(children:)修飾子と子を含む行動で行われます。

00:09:00.000 --> 00:09:11.000
なじみのない場合は、包含子の動作を使用して、既存のアクセシビリティ要素を子としてラップするアクセシビリティコンテナを作成できます。

00:09:11.000 --> 00:09:18.000
しかし、代わりにアクセシビリティ要素があり、その子を設定したい場合はどうなりますか?

00:09:18.000 --> 00:09:23.000
予算履歴グラフにアクセスできるようにしようとすると、このケースに遭遇します。

00:09:23.000 --> 00:09:26.000
ユーザーは、グラフに完全にアクセスできないと報告した。

00:09:26.000 --> 00:09:35.000
つまり、支援技術が予算履歴ヘッダーに焦点を当て、次の要素に移動しようとすると、アラートヘッダーになります。

00:09:35.000 --> 00:09:38.000
VoiceOverユーザーは、このグラフが存在することさえ知らないだろう。

00:09:38.000 --> 00:09:41.000
新しいキャンバスビューを使用してグラフを作成しました。

00:09:41.000 --> 00:09:44.000
キャンバスを使用すると、図形のコレクションを簡単に描画できます。

00:09:44.000 --> 00:09:51.000
キャンバスの詳細については、アプリに豊富なグラフィックを追加するために使用する方法に関するジェイコブのプレゼンテーションをご覧ください。

00:09:51.000 --> 00:09:56.000
アクセシビリティのための最も重要なポイントは、キャンバスが図形のコレクションを描くことです。

00:09:56.000 --> 00:10:01.000
そして、BudgetSliderで見たように、図形はデフォルトではアクセスできません。

00:10:01.000 --> 00:10:08.000
すべてのユーザーが予算履歴を表示できる必要があるので、誰もがアクセスできるようにしましょう。

00:10:08.000 --> 00:10:12.000
基本から始めて、キャンバスにラベルを付けましょう。

00:10:12.000 --> 00:10:17.000
これにより、キャンバスの新しいアクセシビリティ要素が自動的に作成され、そのラベルが割り当てられます。

00:10:17.000 --> 00:10:23.000
さて、グラフの各バーは、独自のアクセシビリティ要素で表されるようにしたいと思います。

00:10:23.000 --> 00:10:29.000
これは、アクセシビリティ要素があり、その子を提供したいユースケースです。

00:10:29.000 --> 00:10:34.000
これを行うには、新しいaccessibilityChildren(children:)修飾子を使用します。

00:10:34.000 --> 00:10:42.000
これにより、アクセシビリティ要素がアクセシビリティコンテナに変換され、ラベルなどの他のアクセシビリティプロパティが保持されます。

00:10:42.000 --> 00:10:50.000
修飾子はViewBuilderを取ります。これにより、アクセシビリティコンテナの子として新しいビューを設定できます。

00:10:50.000 --> 00:10:59.000
予算履歴グラフは水平棒グラフを描画しているので、HStackを使用して各予算のビューを返します。

00:10:59.000 --> 00:11:06.000
フレームが利用可能なすべての垂直スペースを埋めるように、各アクセシビリティ要素に長方形を使用します。

00:11:06.000 --> 00:11:11.000
これにより、各アクセシビリティ要素のフレームが視覚的に表示されているものよりも大きくなり、問題ありません。

00:11:11.000 --> 00:11:23.000
大きくて一貫性のあるフレームを持つことで、VoiceOverユーザーが画面上で指をドラッグしてアクセシビリティ要素をスキャンするときに、iOSでナビゲートしやすくなります。

00:11:23.000 --> 00:11:32.000
accessibilityChildren(children:)修飾子内からHStackを選択すると、アクセシビリティプレビューはグラフ内の各バーに要素が作成されたことを確認します。

00:11:32.000 --> 00:11:38.000
これらはすべて、Canvasアクセシビリティコンテナの子としてアクセスできます。

00:11:38.000 --> 00:11:47.000
これらの変更により、予算履歴グラフは完全にアクセス可能になり、支援技術はグラフの各バーをナビゲートできます。

00:11:47.000 --> 00:11:52.000
各要素のフレームが同じであることに注意してください。これは理想的です。

00:11:52.000 --> 00:11:56.000
より複雑なチャートについては、アクセスできるようにする他の方法があります。

00:11:56.000 --> 00:12:01.000
そのために、チャートにアクセシビリティをもたらすことに関するプレストンのプレゼンテーションをチェックしてください。

00:12:01.000 --> 00:12:09.000
しかし、アクセシビリティの子供たちでは、ビューのアクセシビリティ要素は視覚的に提示されたものとは異なる可能性があり、素晴らしい体験を調整することができます。

00:12:09.000 --> 00:12:15.000
しかし、アクセシビリティの子供たちは、結合行動の助けを借りてアクセシビリティを構成するためにも使用できます。

00:12:15.000 --> 00:12:25.000
クイックリフレッシュとして、コンバイン子の動作は、複数のアクセシビリティ要素のプロパティを新規または既存のアクセシビリティ要素にマージします。

00:12:25.000 --> 00:12:34.000
しかし、アクセシビリティの子APIを追加して、一般的な方法でアクセシビリティを構成するためにも使用できるようになりました。

00:12:34.000 --> 00:12:40.000
アクセシビリティ表現により、元のアクセシビリティは完全に置き換えられます。

00:12:40.000 --> 00:12:51.000
これは、構成ができないことを意味します。一方、アクセシビリティの子供たちは添加物です。

00:12:51.000 --> 00:12:57.000
これは、後で子を組み合わせて、そのプロパティを元の要素にマージできることを意味します。

00:12:57.000 --> 00:13:03.000
これはaccessibilityChildren(children:)修飾子のより高度なユースケースですが、私が強調したかった機能です。

00:13:03.000 --> 00:13:08.000
例は、このプレゼンテーションのアクセシビリティカタログサンプルプロジェクトで紹介されています。

00:13:08.000 --> 00:13:13.000
多くの人がこの種の構成で何が可能かを探るのを見たいと思っています。

00:13:13.000 --> 00:13:17.000
accessibilityChildren(children:)を使用すると、コンテナの子を制御できます。

00:13:17.000 --> 00:13:25.000
そして、キャンバスで描かれた複雑なグラフは、すでに慣れ親しんでいる修飾子とビューでアクセスできるようになります。

00:13:25.000 --> 00:13:30.000
そして、組み合わせた子供の行動により、単一のビューのアクセシビリティは多数で構成できます。

00:13:30.000 --> 00:13:38.000
アプリの個々のコンポーネントにアクセスできるようにする方法を学んだので、ナビゲーション体験を洗練するために物事をまとめ始めることができます。

00:13:38.000 --> 00:13:42.000
VoiceOverでWallet Palをナビゲートするのは混乱し、難しいと聞きました。

00:13:42.000 --> 00:13:49.000
だから、素晴らしいアクセシブルなアプリを提供したい場合は、もう少しやるべきことがあります。

00:13:49.000 --> 00:13:53.000
上部にあるフレンズカルーセルを詳しく見てみましょう。

00:13:53.000 --> 00:13:58.000
この機能はまだ構築されていませんが、Wallet Palに何らかのゲーミフィケーションを追加する予定です。

00:13:58.000 --> 00:14:03.000
そこで、各フレンドビューの左上にチャレンジボタンを追加しました。

00:14:03.000 --> 00:14:09.000
すでにSymbolButtonStyleを修正したので、チャレンジボタンは適切にラベル付けされます。

00:14:09.000 --> 00:14:13.000
しかし、ユーザーはナビゲーションが混乱していると報告しているので、他の問題はありますか?

00:14:13.000 --> 00:14:19.000
それに答えるには、まず、支援技術がWallet Palをどのようにナビゲートするかを理解する必要があります。

00:14:19.000 --> 00:14:28.000
デフォルトでは、アクセシビリティ要素は、左上から右下まで、他の要素との関係で幾何学的な位置に基づいてソートされます。

00:14:28.000 --> 00:14:42.000
これは、コンテンツを区別するためのアクセシビリティコンテナがなければ、VoiceOverは各チャレンジボタン、次に画像と友達を追加ボタン、そして最後にユーザー名のテキストをナビゲートすることを意味します。

00:14:42.000 --> 00:14:48.000
アクセシビリティプレビューの大きな特徴は、整理された順序でアクセシビリティ要素を表示することです。

00:14:48.000 --> 00:14:54.000
これにより、支援技術がXcode内から直接どのようにナビゲートするかを簡単に視覚化できます。

00:14:54.000 --> 00:14:58.000
予想通り、ソートされた順序は私たちが以前に見たものと一致します。

00:14:58.000 --> 00:15:02.000
そして、この順序は確かにナビゲートするのに混乱するでしょう。

00:15:02.000 --> 00:15:07.000
これで、アクセシビリティ要素の並べ替え順序を修正する方法は複数あります。

00:15:07.000 --> 00:15:11.000
私たちができることの1つは、アクセシビリティコンテナを導入することです。

00:15:11.000 --> 00:15:16.000
包含ビヘイビアでaccessibilityElement(children:)修飾子を追加します。

00:15:16.000 --> 00:15:22.000
これにより、各FriendCellViewのアクセシビリティ要素がアクセシビリティコンテナにラップされます。

00:15:22.000 --> 00:15:30.000
これは、アクセシビリティコンテナの子が次のアクセシビリティ要素に移動する前にナビゲートされるため、ナビゲーションの順序を修正します。

00:15:30.000 --> 00:15:39.000
この変更により、VoiceOverは次のアクセシビリティ要素に移動する前に、アクセシビリティコンテナの子をナビゲートします。

00:15:39.000 --> 00:15:42.000
そして、私たちははるかに望ましいナビゲーション順序を達成します。

00:15:42.000 --> 00:15:45.000
しかし、この経験を改善するためにもっとうまくやれるでしょうか?

00:15:45.000 --> 00:15:51.000
1つの問題は、ユーザーが誰であるかを知る前にチャレンジボタンがナビゲートされることです。

00:15:51.000 --> 00:15:59.000
VoiceOverユーザーは、チャレンジを送信する前にユーザーの名前を知りたいので、このボタンは本当に最後にソートする必要があります。

00:15:59.000 --> 00:16:04.000
accessibilitySortPriority(_:)修飾子を使用してこれを修正できます。

00:16:04.000 --> 00:16:10.000
accessibilitySortPriority(_:) は、アクセシビリティ コンテナ内の要素の順序を変更するために使用できます。

00:16:10.000 --> 00:16:16.000
優先度の高い要素は最初にソートされ、優先度が低い要素は最後にソートされます。

00:16:16.000 --> 00:16:22.000
優先順位が等しい要素は、その幾何学的ポジショニングに基づいてソートされます。

00:16:22.000 --> 00:16:29.000
チャレンジボタンにaccessibilitySortPriority(_:)修飾子を追加して、ナビゲーションの順序を改善します。

00:16:29.000 --> 00:16:37.000
デフォルトが0なので、優先度-1を使用して、チャレンジボタンの並べ替え順序を最後にします。

00:16:37.000 --> 00:16:39.000
これで、チャレンジボタンが最後にナビゲートされます。

00:16:39.000 --> 00:16:48.000
VoiceOverユーザーが誰にチャレンジを送っているのか混乱する可能性は低いため、これは良い改善ですが、それでも素晴らしいものではありません。

00:16:48.000 --> 00:16:55.000
各FriendCellViewをアクセシビリティコンテナにラップするのではなく、子を1つの要素にまとめることができます。

00:16:55.000 --> 00:17:01.000
結合は、子のプロパティを既存または新しいアクセシビリティ要素にマージすることを思い出してください。

00:17:01.000 --> 00:17:06.000
結合動作は、最適なデフォルト結果を得るためにマージされるプロパティもキュレーションします。

00:17:06.000 --> 00:17:11.000
たとえば、チャレンジボタンは「チャレンジを送信」という名前のアクションになりました。

00:17:11.000 --> 00:17:16.000
これもナビゲーションの順序を修正し、アクセシビリティ要素の数を減らします。

00:17:16.000 --> 00:17:23.000
これで、ユーザーごとに1つの要素があり、各要素にはSend Challengeアクションがあります。

00:17:23.000 --> 00:17:28.000
ForEachで表されるビューのアクセシビリティ要素を組み合わせることがしばしば理想的です。

00:17:28.000 --> 00:17:33.000
あなたが今までに拾ったかもしれないように、コンバインは超有用な子供の行動です。

00:17:33.000 --> 00:17:39.000
子が個別にナビゲートできる代わりに、プロパティを単一のナビゲート可能な要素にマージします。

00:17:39.000 --> 00:17:46.000
単一の要素が必要で、子からプロパティを継承したくない場合は、無視動作を使用します。

00:17:46.000 --> 00:17:54.000
そして最後に、包含された子の行動は、アクセシビリティコンテナに子を包み込み、関連するビューのグループを表現するために使用する必要があります。

00:17:54.000 --> 00:17:59.000
これにより、デフォルトのソート順が改善されるだけでなく、支援技術に他の利点があります。

00:17:59.000 --> 00:18:03.000
新しいアクセシビリティプレビューでは、これらのナビゲーションの問題を簡単に発見できます。

00:18:03.000 --> 00:18:07.000
そして、いくつかの小さな変更で、経験を劇的に改善することができます。

00:18:07.000 --> 00:18:14.000
しかし、VoiceOverユーザーに本当に優れたナビゲーション体験を提供するために、ローターを検討したいと思うでしょう。

00:18:14.000 --> 00:18:19.000
アクセシビリティが初めてなら、「ローターとは何ですか？」と思うかもしれません。

00:18:19.000 --> 00:18:22.000
要するに、ローターは強力なナビゲーションツールです。

00:18:22.000 --> 00:18:27.000
これらは、ユーザーがそれらの間をすばやくナビゲートできるブックマークと考えることができます。

00:18:27.000 --> 00:18:35.000
見出しやコンテナローターなどのシステムローターは、このスーパーチャージされたナビゲーションの基盤を提供します。

00:18:35.000 --> 00:18:40.000
たとえば、ユーザーは見出しローターを使用してセクションをすばやくナビゲートできます。

00:18:40.000 --> 00:18:52.000
これは、セクションビューが自動的にisHeader特性をヘッダービューに追加するためです。セクションビューを使用していない場合は、accessibilityAddTraits(_:)を使用してisHeader特性をビューに追加できます。

00:18:52.000 --> 00:19:01.000
同様に、アクセシビリティコンテナはコンテナのローターに追加され、先に見たように、accessibilityElement(children:)修飾子で作成されます。

00:19:01.000 --> 00:19:12.000
ご覧のとおり、見出しローターのサポートは非常に簡単で、コンテナのローターは、アクセシビリティ要素を子の行動を含むとグループ化する利点をさらに高めます。

00:19:12.000 --> 00:19:19.000
Wallet Palの基本的なナビゲーション体験が洗練されたので、ローターでさらに一歩進めましょう。

00:19:19.000 --> 00:19:29.000
Wallet Palでは、アラートは、予算が制限に近づいたり超えたりしたときにモチベーションメッセージや警告を提供することで、ユーザーの支出習慣を抑えるのに役立ちます。

00:19:29.000 --> 00:19:32.000
さまざまな種類のアラートにSFシンボルを組み込みました。

00:19:32.000 --> 00:19:36.000
これにより、ビジュアルユーザーはリストをすばやくスキャンできます。

00:19:36.000 --> 00:19:42.000
しかし、この図像はVoiceOverユーザーには役に立ちません。

00:19:42.000 --> 00:19:47.000
代わりに、警告があるかどうかを知るために、すべてのアラートをナビゲートする必要があります。

00:19:47.000 --> 00:19:58.000
目の見えるユーザーが持っている同様の体験を再現するには、VoiceOverユーザーは警告を独占的にナビゲートできる必要があります。そうすれば、瞬時に次の警告アラートに移動できます。

00:19:58.000 --> 00:20:01.000
これを行うには、ローターを使用できます。

00:20:01.000 --> 00:20:10.000
カスタムローターのより多くの例と、それらが効率にとって非常に重要である理由については、2020年の「カスタムローターのボイスオーバー効率」プレゼンテーションをご覧ください。

00:20:10.000 --> 00:20:17.000
AlertsViewに警告ローターを追加するには、最初に行うことは、アクセシビリティコンテナにローターを追加していることを確認することです。

00:20:17.000 --> 00:20:32.000
SwiftUIの一部のビューは、ListやLazyVStackなどのアクセシビリティコンテナですが、VStacksとHStacksはそうではないので、adtainingElement(children:)修飾子を含む修飾子を追加します。

00:20:32.000 --> 00:20:39.000
次に、accessibilityRotor(_:entries:)修飾子でローターを作成し、「警告」という名前を付けます。

00:20:39.000 --> 00:20:46.000
そして最後に、どのアラートを警告ローターに含めたいかを宣言します。この場合はすべての警告アラートです。

00:20:46.000 --> 00:20:47.000
そして、それだけです!

00:20:47.000 --> 00:20:52.000
アプリのナビゲーションをスーパーチャージするのは簡単です。

00:20:52.000 --> 00:21:02.000
これらの簡単なユースケースでローターを非常に簡単にする理由の一部は、SwiftUIがIDに基づいてローターエントリをアクセシビリティ要素に自動的に一致させることができることです。

00:21:02.000 --> 00:21:08.000
これは、ローターエントリのIDが、ForEachによってAlertCellViewに与えられたIDと一致するためです。

00:21:08.000 --> 00:21:12.000
ビューのアイデンティティは、アクセシビリティローターのために理解することが重要です。

00:21:12.000 --> 00:21:20.000
したがって、ビューのアイデンティティが不明な場合、または復習をご希望の場合は、「Demystifying SwiftUI」プレゼンテーションをチェックして詳細を確認することを強くお勧めします。

00:21:20.000 --> 00:21:25.000
今、あなたは「ちょっと待って、私の見解はこんなに単純ではありません。

00:21:25.000 --> 00:21:28.000
ForEach内にないビューはどうですか?

00:21:28.000 --> 00:21:33.000
心配しないで、アクセシビリティローターAPIは単純なビューから複雑なビューまで拡張できます。

00:21:33.000 --> 00:21:40.000
このシンプルなケースは、AlertCellViewに単一のアクセシビリティ要素があるため、エレガントに機能します。

00:21:40.000 --> 00:21:45.000
そして、AlertCellViewはアラートのIDによって識別されます。

00:21:45.000 --> 00:21:50.000
すべてのアラートにアクションビューもあった場合はどうなりますか?

00:21:50.000 --> 00:21:58.000
この場合、VStackはForEachのルートビューであり、アラートのアイデンティティが与えられるのはVStackです。

00:21:58.000 --> 00:22:06.000
したがって、警告ローターにAlertCellViewを含めるには、ローターエントリとして明示的にマークする必要があります。

00:22:06.000 --> 00:22:09.000
アクセシビリティRotorEntry修飾子でそれを行うことができます。

00:22:09.000 --> 00:22:20.000
この修飾子には、名前空間とIDが必要です。これは、AccessibilityRotorEntryの作成に使用されたIDと名前空間と一致する限り、何でもかまいません。

00:22:20.000 --> 00:22:25.000
そして最後に、各ローターエントリにこの名前空間を含める必要があります。

00:22:25.000 --> 00:22:39.000
明示的な名前空間を参照する機能は、アクセシビリティローターAPIが単純なユースケースから複雑なユースケースにスケーリングすることを可能にし、複数のビューにまたがるアクセシビリティ要素を同じローターに含めることができます。

00:22:39.000 --> 00:22:43.000
アクセシビリティローターを追加して、テキストナビゲーションを豊かにすることもできます。

00:22:43.000 --> 00:22:51.000
これを行うには、accessibilityRotor修飾子の別のバリアントを使用します。これにより、テキスト範囲の配列を指定できます。

00:22:51.000 --> 00:23:01.000
この修飾子は、VoiceOverユーザーが電子メール、リンク、電話番号などのテキストエディタ内の特定の文字列にすばやく簡単にアクセスできるようにするのに最適です。

00:23:01.000 --> 00:23:05.000
アクセシビリティローターは、VoiceOverユーザーにとって複雑なナビゲーションを容易にします。

00:23:05.000 --> 00:23:12.000
そして、新しいSwiftUIローターAPIにより、この優れたナビゲーション体験を提供することがかつてないほど簡単になりました。

00:23:12.000 --> 00:23:15.000
今日の最後のトピックはフォーカスです。

00:23:15.000 --> 00:23:24.000
焦点の要素の概念は、あなたがすでに慣れ親しんでいるかもしれませんが、あなたが知らないかもしれないのは、私たちの支援技術の多くが独自の焦点状態を持っているということです。

00:23:24.000 --> 00:23:27.000
これは私たちが「アクセシビリティフォーカス」と呼ぶものです。

00:23:27.000 --> 00:23:33.000
それは私がナビゲートする支援技術について言及するとき、あなたが変化を見ていた焦点を絞ったビューです。

00:23:33.000 --> 00:23:37.000
支援技術のカーソルの位置は、ユーザーエクスペリエンスにとって非常に重要です。

00:23:37.000 --> 00:23:46.000
VoiceOverでフォーカスが変更されると、カーソルは要素の説明を話すことに加えて、フォーカスされた要素のパスと一致するように移動します。

00:23:46.000 --> 00:23:48.000
では、焦点はいつ変わりますか?

00:23:48.000 --> 00:23:53.000
3つのイベントのいずれかが発生すると、フォーカスは変更できますが、常に変わるとは限りません。

00:23:53.000 --> 00:24:00.000
最初で最も一般的なユースケースは、ユーザーが別のアクセシビリティ要素にナビゲートするときにフォーカスの変更を駆動する場合です。

00:24:00.000 --> 00:24:08.000
2番目のケースは、UIが変更され、以前にフォーカスされたビューが画面に表示されなくなったり、モーダルビューでカバーされたりした場合です。

00:24:08.000 --> 00:24:13.000
これが発生すると、フォーカスは最初にソートされたアクセシビリティ要素にリセットされることがよくあります。

00:24:13.000 --> 00:24:19.000
これは、新しく提示されたビューの最初のアクセシビリティ要素に移動するなど、多くのユースケースを自動的にカバーします。

00:24:19.000 --> 00:24:26.000
しかし、それはあなたのアプリでの最良の行動ではないかもしれないので、プログラマティックな要求に応じてフォーカスを変更することもできます。

00:24:26.000 --> 00:24:33.000
ただし、VoiceOverユーザーのフォーカスを移動することは非常に破壊的になる可能性があるため、これは慎重に処理する必要があります。

00:24:33.000 --> 00:24:38.000
そのメモでは、最後のケースに集中しましょう。ダジャレは意図していません。

00:24:38.000 --> 00:24:48.000
今年は、支援技術が現在焦点を当てている場所を読むことに加えて、その焦点を移動するために支援技術を要求できる新しいAPIがあります。

00:24:48.000 --> 00:24:56.000
ここでは、通知を追跡するシンプルなビューがあり、存在する場合は、カスタムNotificationBannerをオーバーレイします。

00:24:56.000 --> 00:25:02.000
Wallet Palでこのビューを使用して、アプリがフォアグラウンドにある間に受信したプッシュ通知のアラートを表示したいと考えています。

00:25:02.000 --> 00:25:08.000
NotificationBannerが追加されると、支援技術は自動的にそれに焦点を合わせません。

00:25:08.000 --> 00:25:13.000
しかし、新しいAccessibilityFocusStateでそうするように要求することができます。

00:25:13.000 --> 00:25:23.000
AccessibilityFocusStateは、支援技術が集中する読み取り方法と、プログラム的なフォーカスの変更を要求する方法の両方を提供するプロパティラッパーです。

00:25:23.000 --> 00:25:30.000
ビューに1つ追加し、accessibilityFocused(_:)修飾子でNotificationBannerにバインドします。

00:25:30.000 --> 00:25:35.000
次に、onChange(of:perform:)修飾子を使用して、新しい通知がいつ受信されたかを追跡します。

00:25:35.000 --> 00:25:42.000
優先度の高い通知を受け取った場合にのみ、アクセシビリティフォーカスの変更を要求します。

00:25:42.000 --> 00:25:50.000
ユーザーインタラクションが発生しない場合、プログラムでフォーカスを移動することは非常に破壊的になる可能性があることに注意することは特に重要です。

00:25:50.000 --> 00:25:55.000
ユーザーが現在焦点を当てているコンテキストから外すため、注意して処理する必要があります。

00:25:55.000 --> 00:26:01.000
したがって、優先度の低い通知については、VoiceOverが発表するためのアクセシビリティ通知を投稿します。

00:26:01.000 --> 00:26:08.000
このようにして、VoiceOverユーザーはまだ新しい通知が表示されたことを知っていて、必要に応じてナビゲートすることができます。

00:26:08.000 --> 00:26:11.000
では、NotificationBannerビューに入りましょう。

00:26:11.000 --> 00:26:15.000
通知が表示されると、タイマーが開始されます。

00:26:15.000 --> 00:26:19.000
完了すると、通知はゼロに設定されます。

00:26:19.000 --> 00:26:24.000
通知がnilの場合、NotificationBannerは非表示になります。

00:26:24.000 --> 00:26:37.000
これは、VoiceOverユーザーが通知バナーに集中し、タイマーの有効期限が切れた場合、ビューが削除されるため、フォーカスがリセットされることを意味します。これは素晴らしいユーザーエクスペリエンスではありません。

00:26:37.000 --> 00:26:45.000
これを修正するには、NotificationBannerが支援技術に焦点を当てているかどうか、もしそうなら、通知の却下を遅らせるかどうかを読みましょう。

00:26:45.000 --> 00:26:47.000
これは理想的な解決策です。

00:26:47.000 --> 00:26:53.000
フォーカス中にビューが削除されなくなったため、VoiceOverユーザーのフォーカスはリセットされなくなります。

00:26:53.000 --> 00:27:08.000
さらに、支援技術ユーザーにコンテンツを消化し、必要に応じて対話するための無制限の時間を与えました。支援技術ユーザーがそうするのにはるかに時間がかかるかもしれない2つのこと。

00:27:08.000 --> 00:27:15.000
AccessibilityFocusStateは、今年以降、例外的でアクセスしやすいSwiftUIアプリを提供するために必要な最後の作品です。

00:27:15.000 --> 00:27:21.000
それを使用すると、ビュー間のスムーズな移行を作成するために、支援技術の焦点を読み、指示することができます。

00:27:21.000 --> 00:27:25.000
うわー、今日はSwiftUIのアクセシビリティについて多くのことを取り上げました。

00:27:25.000 --> 00:27:43.000
SwiftUIのアクセシビリティを開発およびデバッグする方法を強化する新しいアクセシビリティプレビューが紹介されました。カスタムコントロールと複雑なグラフにアクセスできるようにする方法を取り上げました。そして、グループ化、ローター、フォーカスでナビゲーション体験をどのように改善できるかを学びました。

00:27:43.000 --> 00:27:48.000
すべてをまとめると、今年は本当にアクセシビリティにとって大きな飛躍でした。

00:27:48.000 --> 00:27:55.000
アクセシビリティAPIのシンプルで複雑な例については、アクセシビリティカタログサンプルプロジェクトをご覧ください。

00:27:55.000 --> 00:28:00.000
今日カバーできなかったより多くの例と、推奨されるベストプラクティスのいくつかを特集しています。

00:28:00.000 --> 00:28:01.000
参加してくれて本当にありがとう。

00:28:01.000 --> 00:28:05.000
誰もがあなたのアプリにアクセスできるようにする方法を楽しみにしています。

00:28:05.000 --> 23:59:59.000
♪

