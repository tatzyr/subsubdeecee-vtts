WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:11.000
こんにちは。私の名前はジャスティンです。

00:00:11.000 --> 00:00:13.000
私は写真エンジニアです。

00:00:13.000 --> 00:00:19.000
同僚のアダムと一緒に、あなたのアプリで写真へのアクセスを改善する方法について話します。

00:00:19.000 --> 00:00:24.000
まず、システムフォトピッカーの改善について話します。

00:00:24.000 --> 00:00:33.000
次に、Adamは新しいクラウド識別子APIと、それらを使用して異なるデバイス間で同じ資産を識別する方法を示します。

00:00:33.000 --> 00:00:40.000
最後に、制限付きライブラリアクセスモードの変更についても説明します。

00:00:40.000 --> 00:00:42.000
フォトピッカーから始めましょう。

00:00:42.000 --> 00:00:50.000
iOS 14では、UIImagePickerControllerの最新の代替品であるPHPickerを導入しました。

00:00:50.000 --> 00:01:00.000
PHPicker APIは、複数の画像の選択や検索など、必要な機能をアプリに提供しながら、プライバシーを保証します。

00:01:00.000 --> 00:01:09.000
PHPickerについて聞いたことがない場合は、WWDC 2020の「Meet the new Photos picker」セッションを見て、詳細を知ることができます。

00:01:09.000 --> 00:01:15.000
iOS 15では、システムフォトピッカーには4つの大きな改善点があります。

00:01:15.000 --> 00:01:18.000
まず、プライバシー。

00:01:18.000 --> 00:01:26.000
私たちは、アプリがアクセスできる情報を人々に知らせることが重要であり、信頼を高めると考えています。

00:01:26.000 --> 00:01:40.000
iOS 14では、アプリがアウトオブプロセスの写真ピッカーのみを表示し、選択した写真にのみアクセスできる場合でも、アプリがフォトライブラリ全体にアクセスできると考える人もいます。

00:01:40.000 --> 00:01:46.000
人々が違いを理解できるように、設定&gt;プライバシー&gt;写真に新しいセクションを追加しました。

00:01:46.000 --> 00:01:55.000
新しいセクションには、システムフォトピッカーのみを使用するアプリが含まれており、これらのアプリは人々が選択した写真にしかアクセスできないことを説明しています。

00:01:55.000 --> 00:02:02.000
まだ行っていない場合は、カスタムピッカーをシステムピッカーに置き換えることをお勧めします。

00:02:02.000 --> 00:02:06.000
次に、順序付けられた選択について話しましょう。

00:02:06.000 --> 00:02:12.000
時々、人々はそれらを選択するときに写真の順序を制御したいと思うかもしれません。

00:02:12.000 --> 00:02:20.000
iOS 15では、ここに示すように、アプリは選択順序を表示するようにピッカーを設定できます。

00:02:20.000 --> 00:02:25.000
デフォルトでは、選択チェックマークが表示されます。

00:02:25.000 --> 00:02:34.000
新しい順序付き選択の動作をオプトインするには、複数の選択を有効にし、「選択」を「順序付き」に設定するだけです。

00:02:34.000 --> 00:02:40.000
PHPicker APIは、誰かが新しい写真を選択する必要があるときにうまく機能します。

00:02:40.000 --> 00:02:45.000
しかし、ピッカーを使用して写真の選択を解除したい場合はどうなりますか?

00:02:45.000 --> 00:02:51.000
iOS 15では、新しい事前選択APIが使用できます。

00:02:51.000 --> 00:02:58.000
しかし、新しいAPIについて話す前に、PHPicker APIが現在どのように使用されているかを再検討しましょう。

00:02:58.000 --> 00:03:07.000
PHPickerConfigurationオブジェクトを作成し、それを使用してピッカーを初期化するだけです。

00:03:07.000 --> 00:03:13.000
ピッカーセッションが完了すると、選択した写真がアプリに返されます。

00:03:13.000 --> 00:03:23.000
設定がPHPhotoLibraryオブジェクトで初期化されると、ピッカーの結果にはアイテムプロバイダーとアセット識別子の両方が含まれます。

00:03:23.000 --> 00:03:30.000
アプリは、アイテムプロバイダーを使用して、選択した写真をロードして表示できます。

00:03:30.000 --> 00:03:35.000
iOS 15では、最初に選択した写真をピッカーに表示することもできます。

00:03:35.000 --> 00:03:43.000
これにより、より多くの写真を選択したり、アプリで事前に選択した写真の選択を解除したりすることができます。

00:03:43.000 --> 00:03:48.000
これを行うには、新しい設定オブジェクトを作成する必要があります。

00:03:48.000 --> 00:03:59.000
この場合、以前に取得した資産識別子（ID：1）とID：2の配列を設定できます。

00:03:59.000 --> 00:04:07.000
新しいPHPickerViewControllerが表示されると、ID：1とID：2の写真がデフォルトで選択されます。

00:04:07.000 --> 00:04:13.000
人々はそれらを選択解除したり、追加の写真を選択したりすることができます。

00:04:13.000 --> 00:04:20.000
後で使用する必要があるため、今のところ古いピッカーの結果を保持したいと考えています。

00:04:20.000 --> 00:04:28.000
ID：2の写真が選択解除されたが、ID：3の新しい写真が選択に追加されるとします。

00:04:28.000 --> 00:04:33.000
ピッカーセッションが完了すると、選択した写真が返されます。

00:04:33.000 --> 00:04:39.000
しかし、最初の結果には、実際の資産データのない資産識別子しかありません。

00:04:39.000 --> 00:04:40.000
どうして？

00:04:40.000 --> 00:04:43.000
それはあなたのアプリによって選択されたからです。

00:04:43.000 --> 00:04:50.000
アプリを使用しているユーザーが選択していないすべての結果には、空のアイテムプロバイダーがあります。

00:04:50.000 --> 00:04:59.000
古いピッカーの結果には実際の資産データがあるので、古いID：1の結果を使用して、空のアイテムプロバイダーに置き換えることができます。

00:04:59.000 --> 00:05:07.000
ID: 2 が選択されなくなったため、古い ID: 2 の結果を破棄できます。

00:05:07.000 --> 00:05:08.000
わかりました。

00:05:08.000 --> 00:05:13.000
これで、以前のように選択した写真の処理を続けることができます。

00:05:13.000 --> 00:05:23.000
要約すると、ピッカーセッションが完了すると、選択解除されていない事前に選択された資産を含む、選択したすべての資産が返されます。

00:05:23.000 --> 00:05:31.000
また、事前に選択された資産の返品されたアイテムプロバイダーは空になることを覚えておいてください。

00:05:31.000 --> 00:05:37.000
ピッカーセッションがキャンセルされた場合、事前に選択されたアセットのみが返されます。

00:05:37.000 --> 00:05:41.000
すべてのアイテムプロバイダーは空になります。

00:05:41.000 --> 00:05:46.000
よし、コードを見てみましょう。 

00:05:46.000 --> 00:05:56.000
事前に選択されたアセットを設定するには、photoLibraryオブジェクトで設定を初期化し、複数の選択を有効にするだけです。

00:05:56.000 --> 00:06:04.000
新しいpreselectedAssetIdentifiers APIを使用して、事前に選択されたアセットを設定できます。

00:06:04.000 --> 00:06:12.000
デリゲートコールバックでは、前のピッカーセッションから既存の選択を取得する必要があります。

00:06:12.000 --> 00:06:17.000
その後、新しく返されたすべてのピッカー結果を反復処理できます。

00:06:17.000 --> 00:06:24.000
既存の選択の一部である場合は、新しい結果を古い結果に置き換える必要があります。

00:06:24.000 --> 00:06:29.000
最後に、更新された選択を保存できます。

00:06:29.000 --> 00:06:33.000
最後になりましたが、進捗報告について話しましょう。

00:06:33.000 --> 00:06:45.000
デバイスでローカルで利用できない場合は、大きなアセットをダウンロードするのに時間がかかる場合があります。これは、iCloud写真とストレージの最適化がオンになっている場合に発生する可能性があります。

00:06:45.000 --> 00:06:53.000
以前は、読み込み中にのみスピナーを表示できていましたが、これは必ずしも理想的なユーザーエクスペリエンスではありません。

00:06:53.000 --> 00:07:02.000
iOS 15では、アプリがピッカーから実際の読み込みの進捗状況を取得できることをお知らせします。

00:07:02.000 --> 00:07:07.000
読み込みの進行状況は、既存のNSItemProvider APIを介して利用できます。

00:07:07.000 --> 00:07:11.000
返された進行状況を使用して、それに応じて読み込みUIを表示できます。

00:07:11.000 --> 00:07:14.000
フォトピッカーのアップデートは、それがすべてです。

00:07:14.000 --> 00:07:21.000
今、私は同僚のアダムに引き渡して、新しいcloudIdentifier APIについてもっと話します。

00:07:21.000 --> 00:07:22.000
ありがとう、ジャスティン。

00:07:22.000 --> 00:07:29.000
私たちが追加した新機能とAPIにより、写真ピッカーは、ほとんどの開発者がアプリで写真を使用するための最良の方法です。

00:07:29.000 --> 00:07:44.000
しかし、写真、カスタムカメラ、または人々がユニークな方法でフォトライブラリを閲覧する方法を提供するアプリを管理または編集するために、より深いレベルのアクセスと統合を必要とするアプリケーションの特別なカテゴリがあることを知っています。

00:07:44.000 --> 00:07:53.000
これらのアプリの場合、PhotoKitは、フォトライブラリに保存されている写真、ビデオ、アルバムにアクセスして更新するための豊富なAPIセットを提供します。

00:07:53.000 --> 00:08:03.000
アセットとアルバムには、PhotoKitによって一意の識別子が与えられ、アプリに保存され、後でフォトライブラリから同じレコードを取得するために使用されます。

00:08:03.000 --> 00:08:12.000
すべてのフォトライブラリとその識別子は、それらのデバイスがiCloud写真とライブラリを同期している場合でも、実行しているデバイスに固有です。

00:08:12.000 --> 00:08:15.000
だから、あなたのアプリに注意を戻しましょう。

00:08:15.000 --> 00:08:24.000
人々は、外出中にiPhoneでアプリを使用し、机に戻ってラップトップやiPadを使用して、より大きなフォーマットを利用する方法が大好きです。

00:08:24.000 --> 00:08:29.000
お客様は、あるデバイスから別のデバイスに切り替える際のシームレスな体験を望んでいます。

00:08:29.000 --> 00:08:36.000
例えば、写真やコメントで経験を文書化するための写真ジャーナリングアプリを構築したとしましょう。

00:08:36.000 --> 00:08:41.000
外出先でコンテンツをキャプチャするためのiPhoneアプリとして最適です。

00:08:41.000 --> 00:08:50.000
彼らは、iPadやMacで私のアプリを開いたときに、携帯電話に追加したすべての写真やコンテンツで、中断したところからそのジャーナルの作業を再開できるはずです。

00:08:50.000 --> 00:08:52.000
それで、それはどのように機能しますか?

00:08:52.000 --> 00:08:58.000
各デバイスに独自のフォトライブラリと個別の識別子がある場合、同じアセットを見つけるにはどうすればよいですか?

00:08:58.000 --> 00:09:02.000
これは、新しいクラウド識別子APIを使用して機能します。

00:09:02.000 --> 00:09:07.000
彼らは、デバイス間で同じアセットとアルバムを見つける方法を提供します。

00:09:07.000 --> 00:09:13.000
クラウド識別子を使用して、各フォトライブラリに固有のローカル識別子を検索します。

00:09:13.000 --> 00:09:24.000
そして、これらの新しいAPIは、iOS、iPadOS、macOS、tvOSなど、PhotoKitをサポートするすべてのプラットフォームで利用できます。

00:09:24.000 --> 00:09:30.000
目標は、クラウドを心配することなく、デバイス間でアセットをマッピングする簡単な方法を提供することです。

00:09:30.000 --> 00:09:42.000
iCloud写真にサインインしているアカウントで実行しているときに最もよく機能するように設計されていますが、アカウントがサインアウトされているか、iCloudにサインインしたことがないシステムで実行されている場合でも、クラウド識別子は機能します。

00:09:42.000 --> 00:09:45.000
それはすべて識別子マッピングに基づいているので、明確にしましょう。

00:09:45.000 --> 00:09:47.000
識別子には2種類あります。

00:09:47.000 --> 00:09:54.000
ローカル識別子は、先ほど話したもので、そのライブラリに固有のデバイスで使用する識別子です。

00:09:54.000 --> 00:10:00.000
以前にPhotoKitを使用したことがある場合は、APIでlocalIdentifierと呼ばれるのを見たことがあります。

00:10:00.000 --> 00:10:06.000
クラウド識別子は、あるデバイスまたは別のデバイスでローカル識別子を検索するために使用される新しいAPIです。

00:10:06.000 --> 00:10:12.000
それらは、PHCloudIdentifierと呼ばれる新しく利用可能なクラスで表されます。

00:10:12.000 --> 00:10:14.000
使い方を掘り下げてみましょう。

00:10:14.000 --> 00:10:20.000
アプリが一部のアセットのローカル識別子のリストを収集したソースデバイスから始めます。

00:10:20.000 --> 00:10:26.000
そのローカル識別子の配列から、対応するクラウド識別子を取得したいと考えています。

00:10:26.000 --> 00:10:29.000
以下は、APIを使用してそれらを取得する方法の例です。

00:10:29.000 --> 00:10:37.000
フォトライブラリへのこの呼び出しは、各localIdentifierのcloudIdentifierMappingオブジェクトを含む辞書を返します。

00:10:37.000 --> 00:10:42.000
その辞書を反復し、cloudMappingオブジェクトからcloudIdentifierを取得します。

00:10:42.000 --> 00:10:44.000
エラー処理については少しお話しします。

00:10:44.000 --> 00:10:49.000
今のところ、私たちはクラウド識別子を持っている必要があり、それらを使用する準備ができています。

00:10:49.000 --> 00:10:58.000
そして、クラウド識別子の最大の利点は、どこでもそれらを使用することなので、他のクラウド接続デバイスと共有する必要があります。

00:10:58.000 --> 00:11:03.000
このiCloudアカウントに接続されているすべてのデバイスで実行されるときに、アプリで利用可能にしたい。

00:11:03.000 --> 00:11:10.000
クラウド識別子を文字列にアーカイブし、CloudKitまたは他のネットワークデータサービスを使用してそのデータを共有できます。

00:11:10.000 --> 00:11:14.000
このデータをどのようにパッケージ化するかは、本当にあなたとあなたのアプリのニーズ次第です。

00:11:14.000 --> 00:11:17.000
2台目のデバイスで情報をどのように使うか考えてみてください。

00:11:17.000 --> 00:11:24.000
これらのクラウド識別子によって参照されるコンテンツを含めるために、アプリケーションの状態をどのように再構築しますか?

00:11:24.000 --> 00:11:35.000
さて、2台目のデバイスで、クラウド識別子をダウンロードしてアーカイブ解除したら、それらを使用してライブラリ固有のローカル識別子を検索したいと考えています。

00:11:35.000 --> 00:11:44.000
反対方向に作業すると、フォトライブラリへのこの呼び出しは、各cloudIdentifierのlocalIdentifierMappingオブジェクトを含む辞書を返します。

00:11:44.000 --> 00:11:51.000
繰り返しますが、辞書を反復し、今回はlocalMappingオブジェクトからlocalIdentifierを取得します。

00:11:51.000 --> 00:11:58.000
すべてのlocalIdentifierを取得したら、それらを使用して、ソースデバイスに持っていたアセットを取得して表示できます。

00:11:58.000 --> 00:12:13.000
APIがどのように両方向で識別子を簡単に検索できるかを見ることができますが、異なるデバイス構成、アカウント設定、ネットワーク状態、および無数の他の変数の現実は、物事が必ずしもそれほど単純ではないことを意味します。

00:12:13.000 --> 00:12:23.000
その複雑さを処理するために、APIはペアのヘルパーオブジェクトを使用して、有効な識別子またはマッピングが失敗した理由を示すエラーを保持します。

00:12:23.000 --> 00:12:28.000
識別子マッピングを調べるときに処理する必要があるエラーには2種類あります。

00:12:28.000 --> 00:12:42.000
基礎となるレコードが存在しないか、アプリがアクセスできないため、フォトライブラリが識別子マッピングを解決できない場合、APIによって返されるマッピングオブジェクトには、識別子が見つかりませんというエラーが含まれます。

00:12:42.000 --> 00:12:49.000
ここでは、識別子が設定されていない場合、localIdentifierMappingオブジェクトからエラーコードを取得する方法を確認できます。

00:12:49.000 --> 00:13:00.000
Identifier Not Foundエラーの場合、未解決のcloudIdentifierを追跡して、UIにプレースホルダを配置して、このデバイスで写真が見つからないことを示すことは理にかなっています。

00:13:00.000 --> 00:13:05.000
他のタイプのエラーは、識別子マッピングを一意に解決できない場合に発生します。

00:13:05.000 --> 00:13:10.000
言い換えれば、提供されたクラウド識別子に一致する複数のアセットがあります。

00:13:10.000 --> 00:13:17.000
これは、このデバイスでクラウドの状態が完全に同期しておらず、ライブラリが一致するものを見つけるために画像コンテンツに頼らなければならない場合に発生する可能性があります。

00:13:17.000 --> 00:13:28.000
この場合、マッピングオブジェクトにはMultiple Identifiers Foundエラーが発生し、エラーユーザー情報には一致する識別子が含まれます。

00:13:28.000 --> 00:13:39.000
Multiple Identifiers Foundのエラーコードを使用すると、LocalIdentifiersErrorKeyを使用して、エラーユーザー情報から一致するローカル識別子を取得できます。

00:13:39.000 --> 00:13:48.000
この例では、後で一致する資産を取得して表示し、顧客に決定させることができるように、辞書にそれらを隠しました。

00:13:48.000 --> 00:13:51.000
これは、クラウド識別子の概要とその使用方法です。

00:13:51.000 --> 00:14:10.000
ローカル識別子とクラウド識別子の間のマッピングを調べるとコストがかかる可能性があるため、フォトライブラリとのアプリのインタラクションでローカル識別子を使用し、ロード時にマッピング作業を実行し、ポイントを保存して保存してから、クラウド識別子を保存して共有して他のデバイスで使用できるようにします。

00:14:10.000 --> 00:14:14.000
次は、限られた図書館です。

00:14:14.000 --> 00:14:20.000
限られたライブラリの更新に飛び込む前に、フォトライブラリへのアクセスがどのように機能するかを簡単に確認しましょう。

00:14:20.000 --> 00:14:31.000
誰かがアプリを起動し、PhotoKitを使用して写真データへのアクセスを要求すると、システムはアプリへのアクセスを許可する前に彼らの許可を必要とします。

00:14:31.000 --> 00:14:34.000
そして、これが初めて起こると、このようなアラートが表示されます。

00:14:34.000 --> 00:14:37.000
これはお客様にとって本当に重要です。

00:14:37.000 --> 00:14:50.000
限られた写真の選択へのアクセス、ライブラリ全体へのフルアクセス、またはアクセスを完全に拒否するなど、このアプリケーションにどれだけのアクセスを許可するかを制御できます。

00:14:50.000 --> 00:14:57.000
写真の選択オプションを選択すると、アプリには制限されたライブラリアクセスが許可されます。

00:14:57.000 --> 00:15:10.000
制限付きライブラリモードのより完全な説明と、それを最大限に活用するようにアプリを設計する方法については、WWDC '20セッション「アプリで限られた写真ライブラリを扱う」を参照してください。

00:15:10.000 --> 00:15:16.000
今のところ、制限されたライブラリアクセスは、アプリ開発者にとって透明になるように設計されていることを知っておくだけで十分です。

00:15:16.000 --> 00:15:24.000
一般的に、PhotoKit APIは通常どおりに動作し、ライブラリには選択された写真のみが含まれているように動作します。

00:15:24.000 --> 00:15:27.000
一般的なワークフローで便利に動作します。

00:15:27.000 --> 00:15:36.000
たとえば、アプリがライブラリに写真を追加すると、その写真は自動的にアプリの限られたライブラリ選択に含まれます。

00:15:36.000 --> 00:15:42.000
追加したアセットを追跡するために、カスタムアルバムを使用するアプリに見られる別のワークフローがあります。

00:15:42.000 --> 00:15:50.000
しかし、iOS 14では、制限付きライブラリモードでは、カスタムアルバムの作成やアクセスが許可されませんでした。

00:15:50.000 --> 00:16:00.000
iOS 15では、制限付きライブラリモードで実行しているときに、独自のアルバムを作成、フェッチ、更新するためのアプリケーションのサポートが追加されました。

00:16:00.000 --> 00:16:08.000
さて、別のワークフローに注意を向けましょう。このために、写真ジャーナリングアプリの例を参照します。

00:16:08.000 --> 00:16:21.000
私のアプリに限られたライブラリアクセスを選択した顧客に素晴らしい体験をしてもらいたいので、新しいジャーナルの作成の一環として、限られたライブラリピッカーを提示するようにインターフェイスをカスタマイズしました。

00:16:21.000 --> 00:16:27.000
これは、ジャーナルの作成中に、より多くの写真を選択するための自然なステップを提供します。

00:16:27.000 --> 00:16:35.000
しかし、選択が更新されると、私の顧客がこのジャーナルで使用したい写真であるため、どの写真が追加されたかを知るのは素晴らしいことです。

00:16:35.000 --> 00:16:45.000
iOS 15の新しいpresentLimitedLibraryPicker APIを使用すると、ピッカーで選択した写真の識別子を提供する完了ハンドラを渡すことができます。

00:16:45.000 --> 00:16:52.000
これにより、選択の更新がいつ完了し、どのアセットを追加したかがわかります。

00:16:52.000 --> 00:17:03.000
これは、限られたライブラリのアップデート、独自のアルバムを作成して操作するためのアプリのサポート、および限られたライブラリの選択に追加されたものを追跡する方法をアプリに提供するための新しいAPIをカバーしています。

00:17:03.000 --> 00:17:09.000
それが私たちが今日話さなければならなかったことのほとんどですが、私たちが行く前に、私はあなたに次のことを残したいと思います。

00:17:09.000 --> 00:17:14.000
しばらくコードを更新していない人のために、アセットライブラリから離れる時が来ました。

00:17:14.000 --> 00:17:19.000
iOS 9以降は廃止されており、将来のSDKで削除する予定です。

00:17:19.000 --> 00:17:27.000
これは、写真とのより深い統合のために、新しい写真ピッカーまたはPhotoKitに移行する時です。

00:17:27.000 --> 00:17:43.000
そして、PhotoKitに移行するもう1つの理由：エラー処理に長年のギャップがあったことを知っており、変更要求処理、リソース要求、およびライブラリアクセスコール中の根本的な問題を特定するために、最終的に新しいエラーコードでそれらに対処したことをお伝えできてとてもうれしいです。

00:17:43.000 --> 00:17:50.000
iOS 15のフォトピッカーとPhotoKitに追加したすべての素晴らしい新機能をチェックするのが待ちきれません。

00:17:50.000 --> 23:59:59.000
ありがとうございます。

