WEBVTT

00:00:00.000 --> 00:00:05.000
♪ベース音楽の演奏♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:14.000
ダリオ・レキシン：こんにちは、私の名前はダリオ・レキシンで、アップルのスウィフトチームのエンジニアです。

00:00:14.000 --> 00:00:22.000
今日、同僚のダグと私は、Swiftの俳優と、同時Swiftアプリケーションの可変状態を保護するためにそれらがどのように利用されているかについて話します。

00:00:22.000 --> 00:00:29.000
並行プログラムを書く際の根本的に難しい問題の1つは、データ競争を避けることです。

00:00:29.000 --> 00:00:37.000
データレースは、2つの別々のスレッドが同時に同じデータにアクセスし、それらのアクセスの少なくとも1つが書き込みである場合に発生します。

00:00:37.000 --> 00:00:42.000
データレースは構築するのは簡単ですが、デバッグが難しいことで有名です。

00:00:42.000 --> 00:00:48.000
これは、カウンタをインクリメントして新しい値を返す1つの操作を持つ単純なカウンタクラスです。

00:00:48.000 --> 00:00:52.000
先に進んで、2つの同時タスクからインクリメントしようとしましょう。

00:00:52.000 --> 00:00:54.000
これは悪い考えです。

00:00:54.000 --> 00:01:00.000
実行のタイミングによっては、1、次に2、または2、次に1が得られる場合があります。

00:01:00.000 --> 00:01:05.000
これは予想され、どちらの場合も、カウンタは一貫した状態のままになります。

00:01:05.000 --> 00:01:12.000
しかし、データレースを導入したため、両方のタスクが0を読み、1を書き込むと、1と1を得ることもできます。

00:01:12.000 --> 00:01:18.000
または、リターンステートメントが両方の増分操作の後に発生する場合は、2と2でさえも。

00:01:18.000 --> 00:01:22.000
データレースは、回避とデバッグが難しいことで有名です。

00:01:22.000 --> 00:01:29.000
レースの原因となるデータアクセスがプログラムの異なる部分にある可能性があるため、非ローカルな推論が必要です。

00:01:29.000 --> 00:01:38.000
また、オペレーティングシステムのスケジューラは、プログラムを実行するたびに異なる方法で同時タスクをインターリーブする可能性があるため、それらは非決定的です。

00:01:38.000 --> 00:01:42.000
データレースは、共有可変状態によって引き起こされます。

00:01:42.000 --> 00:01:49.000
データが変更されない場合、または複数の同時タスク間で共有されていない場合は、データレースをすることはできません。

00:01:49.000 --> 00:01:56.000
データレースを回避する1つの方法は、値セマンティクスを使用して共有可変状態を排除することです。

00:01:56.000 --> 00:02:00.000
値型の変数では、すべての突然変異は局所的です。

00:02:00.000 --> 00:02:09.000
さらに、値セマンティック型の「let」プロパティは本当に不変であるため、異なる同時タスクからアクセスしても安全です。

00:02:09.000 --> 00:02:20.000
Swiftは、当社のプログラムについて推論しやすくなり、同じことが並行プログラムで安全に使用できるため、創業以来、価値セマンティクスを推進してきました。

00:02:20.000 --> 00:02:24.000
この例では、いくつかの値を持つ配列を作成します。

00:02:24.000 --> 00:02:28.000
次に、その配列を2番目の変数に割り当てます。

00:02:28.000 --> 00:02:32.000
次に、配列の各コピーに異なる値を追加します。

00:02:32.000 --> 00:02:44.000
最後に両方の配列を印刷すると、両方のコピーに配列が初期化された値が含まれていることがわかりますが、追加された各値は、追加したそれぞれのコピーにのみ存在します。

00:02:44.000 --> 00:02:55.000
Swiftの標準ライブラリの大部分の型には、辞書やこの例のように配列などのコレクション型を含む値のセマンティクスがあります。

00:02:55.000 --> 00:03:05.000
値のセマンティクスがすべてのデータレースを解決することを確立したので、先に進み、カウンターを構造体に変換して値型にしましょう。

00:03:05.000 --> 00:03:12.000
また、増分関数を突然変異としてマークする必要があるため、valueプロパティを変更できます。

00:03:12.000 --> 00:03:21.000
カウンタを変更しようとすると、カウンタがletであるため、コンパイラエラーが発生し、突然変異を防ぐことができます。

00:03:21.000 --> 00:03:27.000
さて、カウンタ変数をvarに変更して可変にするのは非常に魅力的に思えます。

00:03:27.000 --> 00:03:34.000
しかし、カウンターは両方の同時タスクによって参照されるため、再び競合状態になります。

00:03:34.000 --> 00:03:41.000
幸いなことに、コンパイラは私たちをカバーしており、この安全でないコードをコンパイルすることはできません。

00:03:41.000 --> 00:03:47.000
代わりに、各同時タスク内のローカル可変変数にカウンタを割り当てることができます。

00:03:47.000 --> 00:03:54.000
今、例を実行すると、両方の同時タスクに対して常に1が印刷されます。

00:03:54.000 --> 00:03:59.000
しかし、私たちのコードは現在レースフリーですが、その動作はもはや私たちが望むものではありません。

00:03:59.000 --> 00:04:06.000
これは、共有可変状態が必要なケースがまだあることを示しています。

00:04:06.000 --> 00:04:17.000
並行プログラムで可変状態を共有している場合、共有可変状態の同時使用がデータ競合を引き起こさないように、何らかの形式の同期が必要です。

00:04:17.000 --> 00:04:27.000
アトミックやロックなどの低レベルのツールから、シリアルディスパッチキューなどの高レベルの構造まで、同期のためのプリミティブがいくつかあります。

00:04:27.000 --> 00:04:40.000
これらのプリミティブにはそれぞれさまざまな強みがありますが、それらはすべて同じ重要な弱点を共有しています。毎回正確に正しく使用するために慎重な規律が必要です。そうしないと、データレースになります。

00:04:40.000 --> 00:04:43.000
ここが俳優の出番です。

00:04:43.000 --> 00:04:47.000
アクターは、共有可変状態の同期メカニズムです。

00:04:47.000 --> 00:04:53.000
俳優には独自の状態があり、その状態はプログラムの残りの部分から隔離されています。

00:04:53.000 --> 00:04:57.000
その状態にアクセスする唯一の方法は、俳優を通過することです。

00:04:57.000 --> 00:05:05.000
そして、アクターを通過するたびに、アクターの同期メカニズムは、他のコードがアクターの状態に同時にアクセスしていないことを保証します。

00:05:05.000 --> 00:05:16.000
これは、ロックまたはシリアルディスパッチキューを手動で使用することで得られるのと同じ相互除外プロパティを提供しますが、アクターでは、Swiftが提供する基本的な保証です。

00:05:16.000 --> 00:05:22.000
試してみると、Swiftはコンパイラエラーが発生するため、同期を実行することを忘れないでください。

00:05:22.000 --> 00:05:24.000
俳優はスウィフトの新しいタイプです。

00:05:24.000 --> 00:05:29.000
それらは、Swiftのすべての名前付きタイプと同じ機能を提供します。

00:05:29.000 --> 00:05:34.000
プロパティ、メソッド、初期化子、添字などを持つことができます。

00:05:34.000 --> 00:05:39.000
それらはプロトコルに準拠し、拡張機能で拡張することができます。

00:05:39.000 --> 00:05:45.000
クラスと同様に、それらは参照型です。アクターの目的は、共有可変状態を表現することだからです。

00:05:45.000 --> 00:05:56.000
実際、アクタータイプの主な特徴は、インスタンスデータをプログラムの残りの部分から分離し、そのデータへの同期アクセスを確保することです。

00:05:56.000 --> 00:06:00.000
彼らの特別な行動はすべて、それらの中核的なアイデアに従います。

00:06:00.000 --> 00:06:03.000
ここでは、カウンターをアクタータイプとして定義しました。

00:06:03.000 --> 00:06:11.000
カウンタのインスタンスプロパティ値と、その値をインクリメントして新しい値を返すインクリメントメソッドがまだあります。

00:06:11.000 --> 00:06:16.000
違いは、アクターが値が同時にアクセスされないようにすることです。

00:06:16.000 --> 00:06:23.000
この場合、インクリメントメソッドは、呼び出されると、アクターで他のコードが実行されることなく完了まで実行されることを意味します。

00:06:23.000 --> 00:06:29.000
その保証は、俳優の状態に関するデータレースの可能性を排除します。

00:06:29.000 --> 00:06:33.000
データレースの例を復活させましょう。

00:06:33.000 --> 00:06:37.000
再び、同じカウンタをインクリメントしようとする2つの同時タスクがあります。

00:06:37.000 --> 00:06:46.000
アクターの内部同期メカニズムは、もう一方のインクリメントコールが開始される前に、1つのインクリメントコールが完了するまで実行されることを保証します。

00:06:46.000 --> 00:07:04.000
したがって、どちらも有効な同時実行であるため、1と2または2と1を得ることができますが、アクターの内部同期により、アクター状態のデータレースの可能性が排除されたため、同じカウントを2回取得したり、値をスキップしたりすることはできません。

00:07:04.000 --> 00:07:11.000
両方の同時タスクが同時にカウンタをインクリメントしようとすると、実際に何が起こるかを考えてみましょう。

00:07:11.000 --> 00:07:14.000
一人は最初にそこに着き、もう一人は順番を待たなければなりません。

00:07:14.000 --> 00:07:20.000
しかし、2番目のタスクが俳優の順番を辛抱強く待つことができるようにするにはどうすればよいでしょうか?

00:07:20.000 --> 00:07:22.000
スウィフトにはそのためのメカニズムがあります。

00:07:22.000 --> 00:07:27.000
外部から俳優と対話するときはいつでも、非同期にそうします。

00:07:27.000 --> 00:07:34.000
アクターがビジー状態の場合、実行中のCPUが他の有用な作業ができるように、コードが一時停止されます。

00:07:34.000 --> 00:07:41.000
アクターが再び自由になると、コードが起動し、実行を再開するので、アクターでコールを実行できます。

00:07:41.000 --> 00:07:50.000
この例のawaitキーワードは、アクターへの非同期呼び出しがそのような停止を伴う可能性があることを示しています。

00:07:50.000 --> 00:07:56.000
不必要に遅いリセット操作を追加して、反例をもう少し伸ばしましょう。

00:07:56.000 --> 00:08:05.000
この操作は、値を0に戻し、適切な回数をインクリメントを呼び出して、カウンタを新しい値に取得します。

00:08:05.000 --> 00:08:12.000
このresetSlowlyメソッドは、カウンターアクタータイプの拡張で定義されているため、アクター内にあります。

00:08:12.000 --> 00:08:19.000
つまり、アクターの状態に直接アクセスでき、カウンタ値を0にリセットします。

00:08:19.000 --> 00:08:26.000
また、インクリメントの呼び出しなど、アクター上の他のメソッドを同期的に呼び出すこともできます。

00:08:26.000 --> 00:08:31.000
私たちはすでに俳優で走っていることを知っているので、待つ必要はありません。

00:08:31.000 --> 00:08:34.000
これは俳優の重要な財産です。

00:08:34.000 --> 00:08:39.000
アクターの同期コードは、常に中断されることなく完了します。

00:08:39.000 --> 00:08:47.000
したがって、並行性がアクター状態に与える影響を考慮することなく、同期コードを順番に推論することができます。

00:08:47.000 --> 00:08:56.000
私たちは、同期コードが途切れることなく実行されることを強調してきましたが、アクターはしばしば互いに相互作用したり、システム内の他の非同期コードと対話したりします。

00:08:56.000 --> 00:09:00.000
数分かけて、非同期コードとアクターについて話しましょう。

00:09:00.000 --> 00:09:02.000
しかし、まず、より良い例が必要です。

00:09:02.000 --> 00:09:05.000
ここでは、画像ダウンローダーの俳優を構築しています。

00:09:05.000 --> 00:09:09.000
別のサービスから画像をダウンロードする責任があります。

00:09:09.000 --> 00:09:16.000
また、同じ画像を複数回ダウンロードしないように、ダウンロードした画像をキャッシュに保存します。

00:09:16.000 --> 00:09:26.000
論理フローは簡単です。キャッシュを確認し、画像をダウンロードし、戻る前にキャッシュに画像を記録します。

00:09:26.000 --> 00:09:33.000
私たちはアクターにいるので、このコードは低レベルのデータレースから解放されています。任意の数の画像を同時にダウンロードできます。

00:09:33.000 --> 00:09:45.000
アクターの同期メカニズムは、一度に1つのタスクのみがキャッシュインスタンスプロパティにアクセスするコードを実行できることを保証するため、キャッシュが破損する方法はありません。

00:09:45.000 --> 00:09:51.000
とはいえ、ここでのawaitキーワードは、非常に重要なことを伝えています。

00:09:51.000 --> 00:09:57.000
待機が発生するたびに、この時点で関数を一時停止できることを意味します。

00:09:57.000 --> 00:10:04.000
プログラム内の他のコードが実行できるようにCPUをあきらめ、プログラム全体の状態に影響します。

00:10:04.000 --> 00:10:09.000
機能が再開される時点で、全体的なプログラムの状態が変更されます。

00:10:09.000 --> 00:10:18.000
待機後に保持されない可能性のある待機の前に、その状態について仮定していないことを確認することが重要です。

00:10:18.000 --> 00:10:23.000
同じ画像を同時に取得しようとする2つの異なる同時タスクがあると想像してみてください。

00:10:23.000 --> 00:10:33.000
1つ目は、キャッシュエントリがないのを見て、サーバーから画像のダウンロードを開始し、ダウンロードに時間がかかるため中断されます。

00:10:33.000 --> 00:10:40.000
最初のタスクがイメージをダウンロードしている間、新しいイメージが同じURLでサーバーにデプロイされる可能性があります。

00:10:40.000 --> 00:10:44.000
さて、2番目の同時タスクは、そのURLの下の画像を取得しようとします。

00:10:44.000 --> 00:10:52.000
また、最初のダウンロードがまだ終了していないため、キャッシュエントリが表示されず、画像の2回目のダウンロードが開始されます。

00:10:52.000 --> 00:10:56.000
また、ダウンロードが完了している間は一時停止されます。

00:10:56.000 --> 00:11:04.000
しばらくすると、ダウンロードの1つ（それが最初であると仮定しましょう）が完了し、そのタスクはアクターの実行を再開します。

00:11:04.000 --> 00:11:09.000
キャッシュに入力し、結果の猫の画像を返します。

00:11:09.000 --> 00:11:13.000
これで2番目のタスクのダウンロードが完了したので、目を覚ます。

00:11:13.000 --> 00:11:18.000
キャッシュ内の同じエントリを、それが得た悲しい猫の画像で上書きします。

00:11:18.000 --> 00:11:25.000
そのため、キャッシュにはすでに画像が入力されていたにもかかわらず、同じURLに対して異なる画像を取得できるようになりました。

00:11:25.000 --> 00:11:27.000
それはちょっとした驚きです。

00:11:27.000 --> 00:11:38.000
画像をキャッシュすると、常に同じURLで同じ画像を取り戻すことを期待していたので、少なくとも手動でキャッシュをクリアするまで、ユーザーインターフェイスは一貫しています。

00:11:38.000 --> 00:11:42.000
しかし、ここでは、キャッシュされた画像が予期せず変更されました。

00:11:42.000 --> 00:11:49.000
低レベルのデータレースはありませんが、待機中に状態に関する仮定を運んだため、潜在的なバグが発生しました。

00:11:49.000 --> 00:11:53.000
ここでの修正は、待った後に私たちの仮定を確認することです。

00:11:53.000 --> 00:12:00.000
再開時にキャッシュにすでにエントリがある場合は、その元のバージョンを保持し、新しいバージョンを破棄します。

00:12:00.000 --> 00:12:04.000
より良い解決策は、冗長なダウンロードを完全に回避することです。

00:12:04.000 --> 00:12:08.000
私たちは、このビデオに関連するコードにその解決策を入れました。

00:12:08.000 --> 00:12:16.000
俳優の再参入はデッドロックを防ぎ、前進の進歩を保証しますが、各待機全体で仮定を確認する必要があります。

00:12:16.000 --> 00:12:22.000
再参入のためにうまく設計するには、同期コード内でアクター状態の突然変異を実行します。

00:12:22.000 --> 00:12:29.000
理想的には、すべての状態変更がうまくカプセル化されるように、同期関数内で行います。

00:12:29.000 --> 00:12:34.000
状態の変更には、一時的に俳優を一貫性のない状態に置くことが含まれます。

00:12:34.000 --> 00:12:38.000
待つ前に必ず一貫性を回復してください。

00:12:38.000 --> 00:12:41.000
そして、待つことは潜在的な停止点であることを覚えておいてください。

00:12:41.000 --> 00:12:47.000
コードが一時停止されると、コードが再開される前にプログラムと世界が進みます。

00:12:47.000 --> 00:12:55.000
グローバル状態、時計、タイマー、または俳優について行った仮定は、待機後にチェックする必要があります。

00:12:55.000 --> 00:13:01.000
そして今、私の同僚のダグが俳優の孤立についてもっと教えてくれます。ダグ？

00:13:01.000 --> 00:13:03.000
ダグ・グレゴール:ありがとう、ダリオ。

00:13:03.000 --> 00:13:08.000
俳優の孤立は、俳優タイプの行動の基本です。

00:13:08.000 --> 00:13:17.000
ダリオは、アクターの外部からの非同期インタラクションを通じて、Swift言語モデルによってアクターの分離がどのように保証されるかについて議論しました。

00:13:17.000 --> 00:13:29.000
このセクションでは、アクターの分離がプロトコル適合性、クロージャ、クラスなど、他の言語機能とどのように相互作用するかについて説明します。

00:13:29.000 --> 00:13:36.000
他のタイプと同様に、アクターはプロトコルの要件を満たすことができる限り、プロトコルに準拠することができます。

00:13:36.000 --> 00:13:42.000
たとえば、このLibraryAccountアクターをEquatableプロトコルに準拠させましょう。

00:13:42.000 --> 00:13:48.000
静的平等法は、ID番号に基づいて2つのライブラリアカウントを比較します。

00:13:48.000 --> 00:13:55.000
メソッドは静的であるため、セルフインスタンスがないため、アクターに分離されません。

00:13:55.000 --> 00:14:02.000
代わりに、アクタータイプの2つのパラメータがあり、この静的メソッドは両方の外側にあります。

00:14:02.000 --> 00:14:09.000
実装はアクターの不変状態にのみアクセスしているので、それは大丈夫です。

00:14:09.000 --> 00:14:15.000
ライブラリアカウントをHashableプロトコルに準拠させるために、例をさらに拡張しましょう。

00:14:15.000 --> 00:14:20.000
そのためには、ハッシュ(into)操作を実装する必要があり、このように行うことができます。

00:14:20.000 --> 00:14:26.000
しかし、Swiftコンパイラは、この適合性が許可されていないと文句を言うだろう。

00:14:26.000 --> 00:14:28.000
どうしましたか？

00:14:28.000 --> 00:14:41.000
さて、この方法でHashableに準拠することは、この関数をアクターの外部から呼び出すことができることを意味しますが、ハッシュ(into)は非同期ではないため、アクターの分離を維持する方法はありません。

00:14:41.000 --> 00:14:46.000
これを修正するには、このメソッドを非単離にすることができます。

00:14:46.000 --> 00:14:55.000
Nonisolatedとは、この方法が、構文的に俳優に記述されているにもかかわらず、俳優の外にあるものとして扱われることを意味します。

00:14:55.000 --> 00:15:02.000
これは、Hashableプロトコルからの同期要件を満たすことができることを意味します。

00:15:02.000 --> 00:15:09.000
非単離された方法はアクターの外にあるものとして扱われるため、アクターの可変状態を参照することはできません。

00:15:09.000 --> 00:15:14.000
この方法は、不変のID番号を参照しているため問題ありません。

00:15:14.000 --> 00:15:28.000
貸し出し中の書籍の配列など、他のものに基づいてハッシュしようとすると、外部からの可変状態へのアクセスがデータレースを許可するため、エラーが発生します。

00:15:28.000 --> 00:15:30.000
プロトコルの適合性はそれで十分です。

00:15:30.000 --> 00:15:33.000
閉鎖について話しましょう。

00:15:33.000 --> 00:15:42.000
クロージャは、ある関数内で定義された小さな関数であり、その後、別の関数に渡して、しばらく後に呼び出すことができます。

00:15:42.000 --> 00:15:48.000
関数と同様に、クロージャはアクターで隔離されているか、非単離されている可能性があります。

00:15:48.000 --> 00:15:55.000
この例では、貸し出し中の各本からいくつか読み、読んだページの総数を返します。

00:15:55.000 --> 00:16:00.000
削減の呼び出しには、読み取りを実行するクロージャが含まれます。

00:16:00.000 --> 00:16:03.000
この呼び出しでは、readSomeへの待ち時間がないことに注意してください。

00:16:03.000 --> 00:16:11.000
それは、アクター分離関数「読み取り」内で形成されるこのクロージャは、それ自体がアクター分離であるためです。

00:16:11.000 --> 00:16:22.000
削減操作は同期的に実行され、同時アクセスを引き起こす可能性のある他のスレッドにクロージャをエスケープできないため、これは安全であることを知っています。

00:16:22.000 --> 00:16:25.000
さて、少し違うことをしましょう。

00:16:25.000 --> 00:16:30.000
今は読む時間がないので、後で読みましょう。 

00:16:30.000 --> 00:16:32.000
ここでは、切り離されたタスクを作成します。

00:16:32.000 --> 00:16:38.000
切り離されたタスクは、アクターが行っている他の作業と同時にクロージャを実行します。

00:16:38.000 --> 00:16:44.000
したがって、閉鎖はアクターにあることができないか、データレースを導入します。

00:16:44.000 --> 00:16:47.000
したがって、この閉鎖は俳優に隔離されていません。

00:16:47.000 --> 00:16:55.000
Readメソッドを呼び出す場合は、waitで示されるように、非同期に呼び出す必要があります。

00:16:55.000 --> 00:17:02.000
コードのアクターの分離について少し話しました。これは、そのコードがアクター内で実行されるか、アクターの外で実行されるかです。

00:17:02.000 --> 00:17:07.000
では、アクターの分離とデータについて話しましょう。

00:17:07.000 --> 00:17:14.000
私たちの図書館アカウントの例では、本の種類が実際に何であるかを言うのを熱心に避けてきました。

00:17:14.000 --> 00:17:17.000
私はそれが構造体のような値型であると仮定してきました。

00:17:17.000 --> 00:17:25.000
ライブラリアカウントアクターのインスタンスのすべての状態が自己完結型であることを意味するので、それは良い選択です。

00:17:25.000 --> 00:17:32.000
先に進んでこの方法を呼び出して、読むべきランダムな本を選択すると、読める本のコピーが手になります。

00:17:32.000 --> 00:17:39.000
本のコピーに加えた変更は、俳優には影響しませんし、その逆も同様です。

00:17:39.000 --> 00:17:45.000
しかし、本をクラスに変えると、物事は少し異なります。

00:17:45.000 --> 00:17:49.000
私たちの図書館アカウントアクターは現在、ブッククラスのインスタンスを参照しています。

00:17:49.000 --> 00:17:52.000
それ自体は問題ではありません。

00:17:52.000 --> 00:17:58.000
しかし、ランダムな本を選択するメソッドを呼び出すとどうなりますか?

00:17:58.000 --> 00:18:05.000
今、私たちは俳優の外で共有されている俳優の可変状態への参照を持っています。

00:18:05.000 --> 00:18:09.000
私たちはデータレースの可能性を生み出しました。

00:18:09.000 --> 00:18:18.000
さて、本のタイトルを更新すると、変更は俳優内でアクセス可能な状態で行われます。

00:18:18.000 --> 00:18:25.000
訪問方法はアクターではないため、この変更はデータレースになる可能性があります。

00:18:25.000 --> 00:18:32.000
値タイプとアクターはどちらも同時に使用しても安全ですが、クラスは依然として問題を引き起こす可能性があります。

00:18:32.000 --> 00:18:38.000
同時に安全に使用できるタイプの名前があります：Sendable。

00:18:38.000 --> 00:18:44.000
センバブルタイプは、異なるアクター間で価値を共有できるタイプです。

00:18:44.000 --> 00:18:56.000
ある場所から別の場所に値をコピーし、両方の場所が互いに干渉することなく、その値の独自のコピーを安全に変更できる場合、タイプは送信可能です。

00:18:56.000 --> 00:19:02.000
Darioが先に述べたように、各コピーは独立しているため、値タイプは送信可能です。

00:19:02.000 --> 00:19:08.000
アクタータイプは、可変状態へのアクセスを同期させるため、送信可能です。

00:19:08.000 --> 00:19:12.000
クラスは送信可能ですが、慎重に実装されている場合に限られます。

00:19:12.000 --> 00:19:20.000
たとえば、クラスとそのすべてのサブクラスが不変のデータのみを保持している場合は、Sendableと呼ぶことができます。

00:19:20.000 --> 00:19:29.000
または、安全な同時アクセスを確保するために、クラスがロックなどの同期を内部的に実行する場合、送信可能にすることができます。

00:19:29.000 --> 00:19:34.000
しかし、ほとんどのクラスはこれらのどちらもなく、送信できません。

00:19:34.000 --> 00:19:42.000
関数は必ずしも送信可能ではないので、アクターを渡しても安全な関数には新しい種類の関数タイプがあります。

00:19:42.000 --> 00:19:44.000
私たちはすぐにそれらに戻ります。

00:19:44.000 --> 00:19:52.000
あなたのアクターは、実際には、すべての同時コードは、主にSendableタイプの観点から通信する必要があります。

00:19:52.000 --> 00:19:55.000
送信可能なタイプは、データレースからコードを保護します。

00:19:55.000 --> 00:19:59.000
これは、Swiftが最終的に静的にチェックを開始するプロパティです。

00:19:59.000 --> 00:20:06.000
その時点で、アクターの境界を越えて送信不可能なタイプを渡すことはエラーになります。

00:20:06.000 --> 00:20:09.000
タイプが送信可能であることをどうやって知るのですか?

00:20:09.000 --> 00:20:16.000
さて、Sendableはプロトコルであり、あなたのタイプは他のプロトコルと同じようにSendableに準拠していると述べています。

00:20:16.000 --> 00:20:22.000
その後、Swiftは、あなたのタイプが送信可能なタイプとして理にかなっているかどうかを確認します。

00:20:22.000 --> 00:20:27.000
保存されたすべてのプロパティがSendableタイプの場合、Book構造体はSendableにすることができます。

00:20:27.000 --> 00:20:36.000
Authorが実際にはクラスであるとします。つまり、著者の配列は送信可能ではありません。

00:20:36.000 --> 00:20:43.000
Swiftは、Bookが送信可能ではないことを示すコンパイラエラーを生成します。

00:20:43.000 --> 00:20:48.000
ジェネリックタイプの場合、送信可能かどうかは、一般的な引数に依存します。

00:20:48.000 --> 00:20:53.000
必要に応じて、条件付き適合を使用してSendableを伝播できます。

00:20:53.000 --> 00:21:00.000
たとえば、ペアタイプは、その一般的な引数の両方がSendableである場合にのみSendableになります。

00:21:00.000 --> 00:21:07.000
同じアプローチを使用して、Sendableタイプの配列自体がSendableであると結論付けます。

00:21:07.000 --> 00:21:14.000
値を同時に共有しても安全なタイプにSendableコンフォーマンスを導入することをお勧めします。

00:21:14.000 --> 00:21:16.000
俳優の中でこれらのタイプを使ってください。

00:21:16.000 --> 00:21:23.000
その後、Swiftがアクター間でSendableを強制し始めると、コードの準備が整います。

00:21:23.000 --> 00:21:29.000
関数自体は送信可能であり、アクター間で関数値を渡すのが安全であることを意味します。

00:21:29.000 --> 00:21:37.000
これは、データレースを防ぐためにクロージャができることを制限するクロージャにとって特に重要です。

00:21:37.000 --> 00:21:46.000
たとえば、Sendableクロージャは、ローカル変数のデータレースを可能にするため、可変ローカル変数をキャプチャできません。

00:21:46.000 --> 00:21:55.000
クロージャがキャプチャするものはすべて、クロージャを使用して送信不可能なタイプをアクターの境界を越えて移動できないようにするために、送信可能である必要があります。

00:21:55.000 --> 00:22:05.000
そして最後に、同期送信可能なクロージャは、外部からアクターでコードを実行できるため、アクターを分離することはできません。

00:22:05.000 --> 00:22:10.000
私たちは実際にこの講演で送信可能な閉鎖のアイデアに頼っています。

00:22:10.000 --> 00:22:20.000
切り離されたタスクを作成する操作は、関数タイプの@Sendableでここに書かれたSendable関数を取ります。

00:22:20.000 --> 00:22:23.000
話の冒頭から私たちの反例を覚えていますか？

00:22:23.000 --> 00:22:26.000
値型カウンタを構築しようとしていました。

00:22:26.000 --> 00:22:33.000
その後、私たちは同時に2つの異なるクロージャからそれを修正しようとしました。

00:22:33.000 --> 00:22:36.000
これは、可変ローカル変数のデータレースになります。

00:22:36.000 --> 00:22:44.000
ただし、切り離されたタスクのクロージャはSendableであるため、Swiftはここでエラーを生成します。

00:22:44.000 --> 00:22:51.000
送信可能な関数型は、同時実行が発生する可能性のある場所を示すために使用され、データレースを防ぎます。

00:22:51.000 --> 00:22:55.000
これは先ほど見た別の例です。

00:22:55.000 --> 00:23:02.000
切り離されたタスクのクロージャはSendableであるため、アクターに分離すべきではないことを知っています。

00:23:02.000 --> 00:23:08.000
したがって、それとの相互作用は非同期でなければなりません。

00:23:08.000 --> 00:23:20.000
送信可能なタイプとクロージャは、可変状態がアクター間で共有されておらず、同時に変更できないことを確認することで、アクターの分離を維持するのに役立ちます。

00:23:20.000 --> 00:23:28.000
私たちは主にアクタータイプと、それらがプロトコル、クロージャ、およびSendableタイプとどのように相互作用するかについて話してきました。

00:23:28.000 --> 00:23:34.000
議論する俳優がもう1人います。メイン俳優と呼ぶ特別な俳優です。

00:23:34.000 --> 00:23:38.000
アプリを構築するときは、メインスレッドについて考える必要があります。

00:23:38.000 --> 00:23:46.000
これは、コアユーザーインターフェイスのレンダリングが行われる場所であり、ユーザーインタラクションイベントが処理される場所です。

00:23:46.000 --> 00:23:51.000
UIで動作する操作は、通常、メインスレッドから実行する必要があります。

00:23:51.000 --> 00:23:55.000
ただし、メインスレッドですべての作業を行うわけではありません。

00:23:55.000 --> 00:24:06.000
メインスレッドで作業が多すぎる場合、例えば、入出力操作が遅いか、サーバーとのやり取りをブロックするため、UIがフリーズします。

00:24:06.000 --> 00:24:18.000
したがって、UIと対話するときはメインスレッドで作業を行うように注意する必要がありますが、計算コストのかかる操作や長時間の操作のためにすぐにメインスレッドから外れる必要があります。

00:24:18.000 --> 00:24:29.000
したがって、可能な限りメインスレッドで作業し、メインスレッドで実行する必要がある特定の操作があるときはいつでも、コードでDispatchQueue.main.asyncを呼び出します。

00:24:29.000 --> 00:24:35.000
メカニズムの詳細から一歩下がって、このコードの構造は漠然と見覚えがあるように見えます。

00:24:35.000 --> 00:24:41.000
実際、メインスレッドとのやり取りは、俳優とのやり取りとまったく似ています。

00:24:41.000 --> 00:24:47.000
すでにメインスレッドで実行していることがわかっている場合は、UIの状態に安全にアクセスして更新できます。

00:24:47.000 --> 00:24:52.000
メインスレッドで実行していない場合は、非同期に操作する必要があります。

00:24:52.000 --> 00:24:55.000
これはまさに俳優のやり方です。

00:24:55.000 --> 00:25:02.000
メインスレッドを説明する特別な俳優がいて、私たちはそれをメイン俳優と呼んでいます。

00:25:02.000 --> 00:25:06.000
メイン俳優は、メインスレッドを表す俳優です。

00:25:06.000 --> 00:25:10.000
それは2つの重要な点で普通の俳優とは異なります。

00:25:10.000 --> 00:25:16.000
まず、メインアクターはメインディスパッチキューを介してすべての同期を実行します。

00:25:16.000 --> 00:25:24.000
これは、ランタイムの観点から、メインアクターがDispatchQueue.mainを使用することと交換可能であることを意味します。

00:25:24.000 --> 00:25:30.000
第二に、メインスレッド上にある必要があるコードとデータはどこにでも散らばっています。

00:25:30.000 --> 00:25:35.000
SwiftUI、AppKit、UIKit、その他のシステムフレームワークにあります。

00:25:35.000 --> 00:25:41.000
独自のビュー、ビューコントローラー、およびデータモデルのUIに面した部分に広がっています。

00:25:41.000 --> 00:25:49.000
Swift並行性を使用すると、メインアクター属性で宣言をマークして、メインアクターで実行する必要があると言うことができます。

00:25:49.000 --> 00:25:54.000
私たちはここでチェックアウト操作でそれをやったので、それは常に主役で実行されます。

00:25:54.000 --> 00:26:04.000
メインアクターの外部から呼び出す場合は、メインスレッドで非同期に実行されるように待つ必要があります。

00:26:04.000 --> 00:26:12.000
メインスレッドで実行する必要があるコードをメインアクター上にあるものとしてマークすることで、DispatchQueue.mainを使用するタイミングについての推測はもうありません。

00:26:12.000 --> 00:26:20.000
Swiftは、このコードが常にメインスレッドで実行されることを保証します。

00:26:20.000 --> 00:26:26.000
タイプはメインアクターにも配置できるため、すべてのメンバーとサブクラスがメインアクターになります。

00:26:26.000 --> 00:26:34.000
これは、ほとんどのものがメインスレッドで実行する必要があるUIと対話する必要があるコードベースの部分に役立ちます。

00:26:34.000 --> 00:26:43.000
個々のメソッドは、通常のアクターから慣れ親しんでいるのと同じルールで、非分離キーワードを介してオプトアウトできます。

00:26:43.000 --> 00:26:57.000
UIに面したタイプと操作にメインアクターを使用し、他のプログラム状態を管理するための独自のアクターを導入することで、並行性の安全で正しい使用を確保するためにアプリを設計することができます。

00:26:57.000 --> 00:27:11.000
このセッションでは、アクターの分離を使用し、実行をシリアル化するためにアクターの外部からの非同期アクセスを要求することによって、アクターが同時アクセスから可変状態を保護する方法について話しました。

00:27:11.000 --> 00:27:16.000
アクターを使用して、Swiftコードで安全な同時抽象化を構築します。

00:27:16.000 --> 00:27:29.000
あなたのアクターを実装するとき、そして任意の非同期コードでは、常に再参入のために設計します。あなたのコードで待つことは、世界が前進し、あなたの仮定を無効にすることができることを意味します。

00:27:29.000 --> 00:27:33.000
バリュータイプとアクターは、データレースを排除するために協力します。

00:27:33.000 --> 00:27:42.000
独自の同期を処理しないクラスや、共有可変状態を再導入する他の送信不可能なタイプに注意してください。

00:27:42.000 --> 00:27:53.000
最後に、UIと対話するコードのメインアクターを使用して、メインスレッドにある必要があるコードが常にメインスレッドで実行されるようにします。

00:27:53.000 --> 00:28:01.000
独自のアプリケーション内でアクターを使用する方法の詳細については、Swift並行性アプリの更新に関するセッションをご覧ください。

00:28:01.000 --> 00:28:11.000
また、俳優を含むSwiftの並行性モデルの実装の詳細については、「舞台裏」セッションをご覧ください。

00:28:11.000 --> 00:28:14.000
アクターはSwift並行性モデルの中核部分です。

00:28:14.000 --> 00:28:23.000
それらは、非同期/待機および構造化された並行性と協力して、正確で効率的な並行プログラムの構築を容易にします。

00:28:23.000 --> 00:28:25.000
あなたが彼らと一緒に何を作るかを見るのが待ちきれません。

00:28:25.000 --> 23:59:59.000
♪

