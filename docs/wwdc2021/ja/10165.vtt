WEBVTT

00:00:01.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:15.000
こんにちは、私の名前はYagil Burowskiで、AppleのLocation Technologiesチームのエンジニアです。

00:00:15.000 --> 00:00:23.000
この講演では、最新の進歩と、今年近くのインタラクションフレームワークに登場する新機能について説明します。

00:00:23.000 --> 00:00:39.000
近くのインタラクションフレームワークは、超広帯域技術のためのAppleのチップであるU1のユニークな機能を簡単に活用し、近くのデバイス間で正確で空間的に認識された相互作用を作成することを可能にします。

00:00:39.000 --> 00:00:48.000
これは、AirTagとiPhoneとHomePod miniの間の流動的なハンドオフジェスチャーで「精密な発見」を強化するのと同じ技術です。

00:00:48.000 --> 00:00:51.000
これは、このセッションで取り上げるものです。

00:00:51.000 --> 00:00:55.000
ユーザー権限フローの更新から始めます。

00:00:55.000 --> 00:01:04.000
その後、互換性のあるサードパーティのハードウェアで近くのインタラクションを実行するための新しいAPIを紹介します。

00:01:04.000 --> 00:01:16.000
そして、アプリやサードパーティのアクセサリにこれらの新しいAPIを採用し始めるために、アプリ開発者やアクセサリーメーカー向けのリソースについて話します。

00:01:16.000 --> 00:01:26.000
飛び込む前に、近くのインタラクションを初めて使用する人、または復習が必要な人のために、アプリでフレームワークを使用する方法をすばやく要約しましょう。

00:01:26.000 --> 00:01:30.000
セッションインスタンスの作成から始めます。

00:01:30.000 --> 00:01:38.000
これは、近くのデバイスとの空間インタラクションを設定して実行する主なオブジェクトです。

00:01:38.000 --> 00:01:46.000
次に、NISessionDelegateプロトコルに準拠するようにアプリの一部を指定する必要があります。

00:01:46.000 --> 00:01:52.000
デリゲートはフレームワークから更新を受け取ります。

00:01:52.000 --> 00:02:01.000
次に行う必要があるのは、NIConfigurationのサブクラスとなる構成オブジェクトを作成することです。

00:02:01.000 --> 00:02:11.000
たとえば、アプリを実行している2台のiPhone間でセッションを開始するときに、NearbyPeerConfigurationを作成できます。

00:02:11.000 --> 00:02:34.000
作成した設定でセッションで実行を呼び出すと、Nearby Interactionは、セッションに積極的に参加している近くのデバイスへの距離とオプションで方向を含むNearbyObjectアップデートのストリームをアプリに提供し始めます。

00:02:34.000 --> 00:02:44.000
フレームワークのAPIをより深く掘り下げることに興味がある場合は、昨年のWWDCトーク「Meet Nearby Interaction」をご覧ください。

00:02:44.000 --> 00:02:54.000
近くのデバイスへの距離や方向などのデータにアクセスするには、アプリはユーザーの許可を得る必要があります。

00:02:54.000 --> 00:02:59.000
では、今年行ったユーザー権限フローの改善について話しましょう。

00:02:59.000 --> 00:03:03.000
これは、iOS 14の近くのインタラクション権限フローです。

00:03:03.000 --> 00:03:11.000
プロンプトは、アプリが新しいアプリの有効期間中にセッションを初めて実行したときに表示されます。

00:03:11.000 --> 00:03:27.000
アラートの「許可しない」または「一度許可する」のオプションは、非常に明確な選択肢を提供しますが、この許可は1回限りであるため、特定の状況で追加のプロンプトにつながることもあります。

00:03:27.000 --> 00:03:34.000
だから、今年は、アプリに近くのインタラクションを使用する許可を与える新しい方法があります。

00:03:34.000 --> 00:03:38.000
これは、iOS 15の新しい「Nearby Interaction」許可プロンプトです。

00:03:38.000 --> 00:03:43.000
それはちょっと似ているように見えますが、いくつかの重要な点で異なります。

00:03:43.000 --> 00:03:50.000
システムは、アプリがNISessionを初めて実行すると、自動的に許可プロンプトを表示します。

00:03:50.000 --> 00:04:10.000
したがって、NISessionを実行するタイミングが明確なユーザーの意図と一致していることを確認することが本当に重要であるため、アプリの特定の機能が近くのインタラクションにアクセスする必要がある理由をユーザーが簡単に理解できます。

00:04:10.000 --> 00:04:14.000
プロンプトの新しいオプションを詳しく見てみましょう。

00:04:14.000 --> 00:04:20.000
新しい「OK」オプションは、アプリの使用中にアプリの許可を付与します。

00:04:20.000 --> 00:04:30.000
ユーザーが近くのインタラクションを使用するというアプリの要求を受け入れるか拒否するかにかかわらず、許可プロンプトは再び表示されません。

00:04:30.000 --> 00:04:37.000
iOS 15以降、近くのインタラクションを使用するアプリが設定に表示されます。

00:04:37.000 --> 00:04:44.000
したがって、ユーザーが気が変わった場合は、設定アプリに移動し、アプリの「近くのインタラクション」アクセスを変更できます。

00:04:44.000 --> 00:04:50.000
アプリを開発するときは、必ずこのシナリオをテストしてください。

00:04:50.000 --> 00:04:56.000
新しい近くのインタラクションのユーザー権限モデルをまとめてみましょう。

00:04:56.000 --> 00:05:05.000
新しい許可プロンプトは、承認されると、アプリの使用中に近くのインタラクションを使用する永続的な許可をアプリに与えます。

00:05:05.000 --> 00:05:13.000
アラートには、アプリのInfo.plistで提供された使用状況の説明文字列が表示されます。

00:05:13.000 --> 00:05:24.000
この目的文字列では、明確かつ簡潔に、近くのインタラクションへのアクセスを必要とするアプリの素晴らしい機能を説明してください。

00:05:24.000 --> 00:05:39.000
プロンプトが最初と最後に表示された後、アプリの名前とアイコンが設定アプリに表示されます。つまり、ユーザーはいつでもアプリの許可状態を変更できます。

00:05:39.000 --> 00:05:50.000
アプリに近くのインタラクションを使用するのに十分な権限がない場合は、権限関連のエラーコードでNISessionsが無効になります。

00:05:50.000 --> 00:06:02.000
したがって、アプリの重要な機能が近くのインタラクションへのアクセスに依存している場合は、これをユーザーに明確に説明し、必要に応じて設定アプリに案内してください。

00:06:02.000 --> 00:06:07.000
それがiOS 15の新しい許可プロンプトでした。

00:06:07.000 --> 00:06:15.000
そして今、互換性のあるサードパーティのハードウェアで近くのインタラクションを使用することを可能にするいくつかの新しいAPIを導入することに興奮しています。

00:06:15.000 --> 00:06:22.000
私たちは、このAPIが、あなたが構築を検討するかもしれない幅広いアクセサリーで動作することを望んでいました。

00:06:22.000 --> 00:06:31.000
そのため、Nearby Interactionのサードパーティのハードウェアサポートは、業界グループと協力してきた標準に基づいています。

00:06:31.000 --> 00:06:49.000
また、プロトタイピング、実験、アクセサリーの構築を開始するために、チップセットメーカーと協力して、iPhoneでU1と相互運用できるハードウェアとファームウェアを含む開発キットを作成しています。

00:06:49.000 --> 00:06:59.000
そのため、開発キットと並んで、開発キットのハードウェアですぐに使えるサンプルアプリコードも用意しています。

00:06:59.000 --> 00:07:07.000
だから、一緒に、彼らはあなたのプロジェクトの優れた出発点として役立つことができます。

00:07:07.000 --> 00:07:20.000
また、アクセサリーメーカーの場合は、Apple開発者Webサイトの「開発者プレビュー」で利用できる近くのインタラクション、アクセサリプロトコル仕様のドキュメントをチェックしてください。

00:07:20.000 --> 00:07:37.000
このエキサイティングな新技術をいじりたい場合でも、Ultra Widebandを独自のアクセサリに統合する準備ができている場合でも、サードパーティのアクセサリでNearby Interaction APIを使用する方法を説明する簡単な例を見てみましょう。

00:07:37.000 --> 00:07:47.000
ユーザーのアクセサリーへの正確な距離に基づいて異なる機能を有効にすることは、そのデバイスとのやり取りを合理化する強力な方法です。

00:07:47.000 --> 00:07:58.000
だから、あなたがアクセサリーを構築していて、それを本当に際立たせる一連の機能を可能にするために、それに超広帯域を統合したいとしましょう。

00:07:58.000 --> 00:08:09.000
そして、超広帯域はあなたに正確な距離を与えることができるので、あなたはアクセサリーの周りのいくつかの正確なゾーンや領域を追跡するためにそれを利用することを計画しています。

00:08:09.000 --> 00:08:19.000
では、半径1.5メートルのアクセサリの周りの領域と、半径3メートルのより大きな領域を定義したとします。

00:08:19.000 --> 00:08:31.000
そして、ユーザーがアクセサリーの周りの大きな領域に入ると、いくつかの機能Aを有効にしたいので、これらの特定の距離を気にしているとしましょう。

00:08:31.000 --> 00:08:38.000
また、ユーザーが小さな領域に入ると、機能Bを有効にします。

00:08:38.000 --> 00:08:43.000
では、近くのインタラクションフレームワークを使用して、実際にアプリでこれをどのように達成しますか?

00:08:43.000 --> 00:08:54.000
まず第一に、近くのインタラクションは、アプリとアクセサリがそれらの間でデータを交換する何らかの機能を持っていることを期待しています。

00:08:54.000 --> 00:09:06.000
データ交換に使用する特定の技術に関しては、それは完全にあなた次第であり、あなたのアクセサリーが何をし、何をする必要がないかです。

00:09:06.000 --> 00:09:09.000
アクセサリがすでにBluetoothをサポートしていると仮定します。

00:09:09.000 --> 00:09:18.000
これは、データ交換の要件に既存のBluetooth機能を利用することができるため、素晴らしい場所にあなたを置きます。

00:09:18.000 --> 00:09:26.000
アクセサリがローカルネットワークに接続されている場合、またはインターネットに安全に接続されている場合は、あなたも素晴らしい状態です。

00:09:26.000 --> 00:09:35.000
アプリとアクセサリの間でデータをやり取りする機能は、次に何をする必要があるかに役立ちます。

00:09:35.000 --> 00:09:43.000
アプリを実行している2台のiPhone間でセッションを開始したいときに、NearbyPeerConfigurationを作成したことを思い出してください。

00:09:43.000 --> 00:09:50.000
アクセサリでセッションを開始するには、NearbyAccessoryConfigurationを作成します。

00:09:50.000 --> 00:09:55.000
これはiOS 15の新しいNIConfigurationタイプです。

00:09:55.000 --> 00:10:12.000
アクセサリ構成をインスタンス化するには、フレームワークがアクセサリ構成データと呼ばれる特定の形式で受け取ることを期待するアクセサリを記述して、いくつかの構成データを提供する必要があります。

00:10:12.000 --> 00:10:17.000
しかし、この構成データをどのように取得し、この特定の形式は何ですか?

00:10:17.000 --> 00:10:31.000
U1互換の超広帯域ハードウェアは、認定技術プロバイダーから入手できるタイプのように、リクエストに応じてこの構成データを生成する方法を知っています。

00:10:31.000 --> 00:10:45.000
これは、アクセサリ自体で実行しているコードは、このデータを生成し、データチャネル上のアプリに送信する必要があることを意味します。

00:10:45.000 --> 00:10:54.000
アクセサリから受信したデータでNearbyAccessoryConfigurationをインスタンス化するためのコード例を見てみましょう。

00:10:54.000 --> 00:11:00.000
setupAccessoryは、私がアプリに書いたヘルパーメソッドであると仮定しましょう。

00:11:00.000 --> 00:11:12.000
アクセサリからアクセサリ構成データを取得するたびに、アクセサリの名前とともに、この機能にルーティングするロジックがアプリにあります。

00:11:12.000 --> 00:11:20.000
この時点で、アクセサリから受け取ったデータを使用してNINearbyAccessoryConfigurationを作成できます。

00:11:20.000 --> 00:11:27.000
Do/catchステートメント内で設定を作成していることに気付くでしょう。

00:11:27.000 --> 00:11:39.000
アクセサリから受け取ったデータが何らかの形で無効な場合、NIConfiguration initメソッドが例外をスローするため、これを行います。

00:11:39.000 --> 00:11:50.000
しかし、構成オブジェクトが正常に作成された場合、アクセサリから受け取ったデータが正しい形式であり、使用できるようになりました。

00:11:50.000 --> 00:11:56.000
設定を作成する究極の理由は、それを使用してセッションを実行するためです。

00:11:56.000 --> 00:12:03.000
しかし、その前に、後で使用するためにいくつかの有用なデータをキャッシュする良い機会があります。

00:12:03.000 --> 00:12:13.000
新しい NearbyAccessoryConfiguration タイプには、フレームワークが自動的に入力するアクセサリの DiscoveryToken プロパティがあります。

00:12:13.000 --> 00:12:21.000
さらに、私が定義したセットアップアクセサリー機能には、アクセサリーの名前もあります。

00:12:21.000 --> 00:12:47.000
したがって、この段階では、このアクセサリの名前と一緒にディスカバリートークンを保存すると本当に便利です。なぜなら、後で、このアクセサリに関するNearbyObjectの更新を受け取り始めると、トークンと名前を使用して更新をこのアクセサリに関連付け、より関連性が高く豊富なUIを表示できるからです。

00:12:47.000 --> 00:12:48.000
わかりました。

00:12:48.000 --> 00:12:56.000
そのため、アクセサリから有効な構成データがあり、それを使用してアクセサリ構成オブジェクトを作成しました。

00:12:56.000 --> 00:13:02.000
今、私たちはこのアクセサリーと対話する準備をすることができます。

00:13:02.000 --> 00:13:09.000
インタラクションを管理するには、NISessionインスタンスが必要で、セッションのデリゲートを設定する必要があります。

00:13:09.000 --> 00:13:19.000
セッションを開始するには、作成したアクセサリ設定オブジェクトを使用して、セッションの「実行」関数を呼び出すだけです。

00:13:19.000 --> 00:13:31.000
近くのインタラクションがアクセサリから構成データを必要とするのと同じように、アクセサリは自分自身を設定する方法を知るために、近くのインタラクションからの設定データも必要です。

00:13:31.000 --> 00:13:37.000
このデータは「共有可能な構成データ」という形式である必要があります。

00:13:37.000 --> 00:13:49.000
アクセサリ設定でセッションを実行すると、近くのインタラクションは、デリゲートコールバックを通じて共有可能な設定データをアプリに提供します。

00:13:49.000 --> 00:14:01.000
そして、データチャネルを使用してアクセサリの構成データを受信したように、ここでは、共有可能な構成データをアクセサリに送り返すために再度使用します。

00:14:01.000 --> 00:14:05.000
物事をより具体的にするために、コード例を見てみましょう。

00:14:05.000 --> 00:14:16.000
共有可能な構成データは、iOS 15の新しいデリゲートコールバックであるdidGenerateデリゲートコールバックを通じてアプリに提供されます。

00:14:16.000 --> 00:14:19.000
これは、アプリでのこのコールバックの可能な実装です。

00:14:19.000 --> 00:14:32.000
このフレームワークは、共有可能な構成データを提供し、どのアクセサリに行くべきかも示します。これは、複数のアクセサリと対話する場合に本当に便利です。

00:14:32.000 --> 00:14:39.000
データチャネルを介して、できるだけ早くアクセサリにデータを送信することを計画する必要があります。

00:14:39.000 --> 00:14:48.000
一般的に、さまざまなアクセサリへのデータ接続を管理することは、ユースケースに応じて、さまざまな形式をとることができます。

00:14:48.000 --> 00:14:58.000
簡単にするために、私のアプリのアーキテクチャでは、対話しているアクセサリごとに独立したデータ接続を維持することを選んだとしましょう。

00:14:58.000 --> 00:15:08.000
そして、私のコードをうまく整理しておくために、私が与えるNearbyObjectに基づいて接続を返すヘルパー関数を定義しました。

00:15:08.000 --> 00:15:17.000
接続への参照を取得したら、それを使用してすぐにアクセサリに共有可能な構成データを送信します。

00:15:17.000 --> 00:15:25.000
共有可能な構成データをできるだけ遅延なくアクセサリに送信するために、アプリを最適化することが重要です。

00:15:25.000 --> 00:15:31.000
ShareableConfigurationDataが十分に迅速に送信されない場合、セッションがタイムアウトする可能性があります。

00:15:31.000 --> 00:15:40.000
アクセサリとのセッションでのタイムアウトは、didRemoveデリゲートコールバックを通じてアプリに通知されます。

00:15:40.000 --> 00:15:44.000
このシナリオをどのように処理するかを見てみましょう。

00:15:44.000 --> 00:15:52.000
Nearby Interactionが画面に表示されるdidRemoveコールバックを教えてくれたら、まず「reason」パラメータをチェックします。

00:15:52.000 --> 00:16:04.000
理由が.timeoutで、アクセサリーがまだ近くにあるかもしれないという高い自信がある場合は、それと対話するために再試行することができます。

00:16:04.000 --> 00:16:16.000
このアクセサリで「再試行フロー」に入るべきかどうかを決定するために、この決定を下すのに役立つ特殊なロジックを含むヘルパー関数を定義しました。

00:16:16.000 --> 00:16:22.000
「成功せずに何回再試行したか」のような条件を想像できます。

00:16:22.000 --> 00:16:25.000
または「アクセサリーは停止したことを私に通知しましたか?」

00:16:25.000 --> 00:16:31.000
または他の同様の質問は、このような決定の一部である可能性があります。

00:16:31.000 --> 00:16:39.000
再試行することにした場合、私がしなければならないのは、同じ設定でセッションを再度実行することだけです。

00:16:39.000 --> 00:16:48.000
キャッシュされた設定は、アクセサリのセッションが終了しない限り、有効なままであることに注意してください。

00:16:48.000 --> 00:16:56.000
セッションが終了した場合は、最初にセッションを作成して実行したのと同じフローを経なければなりません。

00:16:56.000 --> 00:17:09.000
アクセサリのセッションは、アクセサリで実行されているコードが管理しなければならないものであり、ユースケースに応じてさまざまな方法で実行できることに注意してください。

00:17:09.000 --> 00:17:10.000
わかりました。

00:17:10.000 --> 00:17:17.000
共有可能な構成データをアクセサリに送信し、必要に応じて再試行を処理するロジックもあります。

00:17:17.000 --> 00:17:19.000
次は何ですか?

00:17:19.000 --> 00:17:34.000
アクセサリ構成データと同様に、アクセサリのU1互換ハードウェアは、アクセサリコードが提供されると、共有可能な構成データをどうするかを自動的に知ることができます。

00:17:34.000 --> 00:17:46.000
したがって、アクセサリで実行されているコードがデータを受信したら、ボード上の超広帯域ハードウェアにそのまま、できるだけ早く提供する必要があります。

00:17:46.000 --> 00:17:54.000
不思議に思うかもしれませんが、アクセサリの超広帯域ハードウェアは、構成データを生成または消費するためにどのように知っていますか？

00:17:54.000 --> 00:18:06.000
アクセサリ構成データと共有可能な構成データの両方は、今春に公開した仕様書で定義されています。

00:18:06.000 --> 00:18:22.000
このドキュメントは、チップセットとモジュールの製造を対象としており、業界標準を使用してiPhoneのU1と相互運用する超広帯域ソリューションを作成するために必要な詳細が含まれています。

00:18:22.000 --> 00:18:32.000
チップセットメーカーの相互運用性仕様に加えて、アクセサリメーカーを対象とした仕様もリリースしています。

00:18:32.000 --> 00:18:45.000
したがって、超広帯域ハードウェアを含むアクセサリを構築したいと思っていて、アプリの近くのインタラクションフレームワークを使用してそれと対話したい場合は、このドキュメントが目向けです。

00:18:45.000 --> 00:18:52.000
始めるための追加のリソースとともに、開発者のウェブサイトで見つけることができます。

00:18:52.000 --> 00:18:54.000
これが私たちが中断したところです。

00:18:54.000 --> 00:19:01.000
共有可能な構成データをデータチャネルを介してアクセサリに送信したばかりでした。

00:19:01.000 --> 00:19:09.000
さて、アクセサリのコードがそれを受信し、超広帯域ハードウェアに提供したらどうなるか見てみましょう。

00:19:09.000 --> 00:19:24.000
共有可能な構成データを受け取った後、アクセサリの超広帯域ハードウェアは、アプリ内のNISessionと対話するための適切な構成ですぐに実行を開始します。

00:19:24.000 --> 00:19:40.000
また、アクセサリとアプリを実行しているiPhoneの両方が互いに近くにある場合、セッションはアプリに距離とオプションでアクセサリへの方向を含むNearbyObjectアップデートのストリームを提供し始めます。

00:19:40.000 --> 00:19:47.000
それぞれのセッションを作成して実行することで、複数のアクセサリを同時に操作することもできます。

00:19:47.000 --> 00:19:56.000
アクセサリのハードウェア機能によっては、アクセサリで実行されているコードで同等の近接アップデートを取得できる場合もあります。

00:19:56.000 --> 00:20:02.000
フレームワークからNearbyObjectのアップデートを取得したら、それらをどうしますか?

00:20:02.000 --> 00:20:18.000
リマインダーとして、ユーザーがより大きな領域に入ったときにアプリとアクセサリが機能Aを有効にし、ユーザーがアクセサリの周りの小さな領域に入ったときに機能Bを有効にするエクスペリエンスを構築したいと考えました。

00:20:18.000 --> 00:20:26.000
iOSアプリでNearbyObjectのアップデートを使用してこれを行う方法を示すコード例を見てみましょう。

00:20:26.000 --> 00:20:38.000
アプリとアクセサリの間のセッションが実行されているとき、アクセサリに関する更新は、didUpdateデリゲートコールバックを通じてセッションのデリゲートに配信されます。

00:20:38.000 --> 00:20:44.000
まず、フレームワークが私に更新を与えている近くのオブジェクトへの参照をつかみます。

00:20:44.000 --> 00:20:52.000
次に、フレームワークがメートル単位で提供しているこのオブジェクトまでの距離を持つローカル変数を作成します。

00:20:52.000 --> 00:21:02.000
次に行うことは、getSmoothedDistanceというアプリにあるヘルパー関数にこのデータを提供することです。

00:21:02.000 --> 00:21:08.000
距離の急激な変化から身を守るために、この機能をアプリで定義しました。

00:21:08.000 --> 00:21:18.000
たとえば、ユーザーが突然の動きをしたり、ゾーン間の境界に立っている場合などです。

00:21:18.000 --> 00:21:26.000
最後に、ユーザーのアクセサリからの距離が事前定義されたしきい値を超えたかどうかを確認できます。

00:21:26.000 --> 00:21:34.000
ここでは、現在の距離に基づいてFunctionalityAまたはFunctionityBを有効にすることを選択できます。

00:21:34.000 --> 00:21:48.000
デバイス間の距離と方向に基づいてエクスペリエンスを設計することについてもっと知りたい場合は、今年の「空間的相互作用のためのデザイン」WWDCトークをチェックしてください。

00:21:48.000 --> 00:21:53.000
では、このセッションで話し合ったことをまとめましょう。

00:21:53.000 --> 00:22:02.000
新しいアクセス許可モデルにより、アプリの使用中にアプリが近くのインタラクションにアクセスする方法について話しました。

00:22:02.000 --> 00:22:14.000
近くのインタラクション対応のサードパーティ製アクセサリーの真新しい世界と、独自のアクセサリとの空間的インタラクションを構築するために使用できるAPIを深く掘り下げました。

00:22:14.000 --> 00:22:26.000
また、サポートされているテクノロジープロバイダーから入手できるサードパーティの開発キットや、プロジェクトをすぐに開始するために使用できるiOSアプリコードについても議論しました。

00:22:26.000 --> 00:22:32.000
だから、先に進んで、試してみて、ユースケースの実験とプロトタイピングを始めましょう。

00:22:32.000 --> 00:22:42.000
そして、アクセサリーに超広帯域を採用する準備ができたら、Apple開発者のウェブサイトで入手可能な関連する仕様文書を読んでください。

00:22:42.000 --> 00:22:45.000
今年の近くのインタラクションのアップデートはこれで終わりです。

00:22:45.000 --> 00:22:46.000
チューニングしてくれてありがとう。

00:22:46.000 --> 00:22:54.000
このセッションが役に立ち、素晴らしいアプリやアクセサリーの構築を始めるために必要なすべての情報が含まれていることを願っています。

00:22:54.000 --> 23:59:59.000
[明るい音楽]。

