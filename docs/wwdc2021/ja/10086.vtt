WEBVTT

00:00:00.000 --> 00:00:12.000
Nihar: こんにちは、「CloudKitの新機能」へようこそ。

00:00:12.000 --> 00:00:18.000
私の名前はNihar Sharmaで、CloudKitチームのエンジニアで、同僚のQianが参加します。

00:00:18.000 --> 00:00:25.000
まず、Swiftの並行性を利用するCloudKit APIへのいくつかの変更点を強調します。

00:00:25.000 --> 00:00:32.000
その後、Qianはレコード上の暗号化されたフィールドの使用を案内します。

00:00:32.000 --> 00:00:38.000
最後に、レコードゾーンを簡単に共有できる新機能を深く掘り下げます。

00:00:38.000 --> 00:00:41.000
まず、CloudKitとSwiftの並行性があります。

00:00:41.000 --> 00:00:48.000
ちょっとした背景として、CloudKitは、アプリケーションがiCloud上のデータベースにアクセスできるようにするフレームワークです。

00:00:48.000 --> 00:00:55.000
これは、複数のCKDatabaseにアクセスできるCKContainerとしてAPIに公開されます。

00:00:55.000 --> 00:01:01.000
各コンテナには、すべてのユーザーが潜在的にレコードを読み書きできる1つのパブリックデータベースがあります。

00:01:01.000 --> 00:01:10.000
デバイスにiCloudアカウントがログインしている場合、アプリはそのユーザーのデータを含むプライベートデータベースにもアクセスできます。

00:01:10.000 --> 00:01:19.000
また、アプリが共有をサポートしている場合、現在のiCloudユーザーに共有されたデータは、共有CKDatabaseでアプリで利用可能になります。

00:01:19.000 --> 00:01:24.000
CloudKitに対してコードを書く場合、APIには2つの一般的な領域があります。

00:01:24.000 --> 00:01:29.000
まず、CKContainerとCKDatabaseで利用可能な機能。

00:01:29.000 --> 00:01:36.000
このAPIは、CloudKitの新規採用者に有用であり、参入障壁が低いことを目的としています。

00:01:36.000 --> 00:01:46.000
利用可能なすべての設定を提供する代わりに、フレームワークは、ユーザーが対話しているUIアプリケーションに最も適したデフォルトの動作を選択します。

00:01:46.000 --> 00:01:53.000
次は、NSOperationサブクラスのセットとして公開されるOperation APIです。

00:01:53.000 --> 00:02:00.000
このAPIは、CKContainerまたはCKDatabase機能として利用できない多くの機能を提供します。

00:02:00.000 --> 00:02:19.000
これには、サーバーへの単一の往復でアイテムのバッチを送受信し、サーバーから段階的にフェッチして大規模な結果セットをページングし、過去のある時点からサーバーからデータベースとレコードゾーンの変更を要求し、最後に異なる操作をグループ化することが含まれます。

00:02:19.000 --> 00:02:26.000
これにより、それらをユニットとして記録することができ、運用にまたがるワークロードのサイズをシステムに通知することができます。

00:02:26.000 --> 00:02:31.000
多くの開発者は、生産品質のコードを書くときに最終的にこのAPIを使用します。

00:02:31.000 --> 00:02:37.000
新しいSwiftの並行性機能を利用して、CloudKitはいくつかの改善を行いました。

00:02:37.000 --> 00:02:44.000
まず、CloudKit APIと一緒に新しいSwift async/await機能を使用する方法について説明します。

00:02:44.000 --> 00:02:58.000
次に、アイテムごとと操作ごとのコールバックの違いを明確にするのに役立つ新しいAPIと、CloudKitがSwift.Resultタイプを利用して、それらのコールバックに対するパラメータの役割を明確にする方法について説明します。

00:02:58.000 --> 00:03:10.000
そして最後に、以前は操作APIを介してのみ利用可能だった機能と構成可能性の一部をもたらすのに役立つ、コンテナとデータベース機能の機能強化について説明します。

00:03:10.000 --> 00:03:16.000
CloudKit APIは、コンテナとデータベース上の機能に非同期バリアントを導入しています。

00:03:16.000 --> 00:03:21.000
非同期関数を使用して、並行性を扱うコードを改善できます。

00:03:21.000 --> 00:03:27.000
エラー処理をより自然にするのに役立ち、コードの視覚的な制御フローを簡素化します。

00:03:27.000 --> 00:03:32.000
非同期関数の詳細については、「Swiftで非同期/待機する」セッションを参照してください。

00:03:32.000 --> 00:03:36.000
例を見てみましょう。例を見てみましょう。

00:03:36.000 --> 00:03:40.000
このスニペットは、PrivateDatabaseのコードサンプルから取得されています。

00:03:40.000 --> 00:03:47.000
これは、Appleが最近GitHubに投稿したいくつかのCloudKit固有のコードサンプルの1つであり、それらが利用可能です。

00:03:47.000 --> 00:03:54.000
この特定の機能は、サーバーからレコードを削除し、完了したら発信者に通知したいと考えています。

00:03:54.000 --> 00:03:58.000
多くのオプションと条件付きアンラッピングが散りばめられていることに注意してください。

00:03:58.000 --> 00:04:05.000
そして、この機能を最初に理解しようとすると、制御フローはすぐには明らかではありません。

00:04:05.000 --> 00:04:09.000
さて、これをCloudKitの非同期機能を使用するように更新されたコードと比較してみましょう。

00:04:09.000 --> 00:04:16.000
ここでは、オプションとアンラッピングが排除され、制御フローは直線的で従うのが簡単です。

00:04:16.000 --> 00:04:27.000
GitHubリポジトリ上の各コードサンプルには、Swift並行性を使用するようにコードを同様にリファクタリングする方法を示すアップデートがあることを嬉しく思います。

00:04:27.000 --> 00:04:30.000
項目ごとのコールバックについて話しましょう。

00:04:30.000 --> 00:04:41.000
例として、理想的には4つのCKRecordペイロードを取り戻すために、4つのCKRecord.IDをサーバーに送信するCKFetchRecordsOperationです。

00:04:41.000 --> 00:04:45.000
この操作は、3つの異なる方法のいずれかを実行できます。

00:04:45.000 --> 00:04:48.000
最初のケースでは、操作は成功します。

00:04:48.000 --> 00:04:54.000
エラーはなく、レコードはサーバーから正常に取得されます。

00:04:54.000 --> 00:04:58.000
2番目の可能性は、操作全体のエラーが発生することです。

00:04:58.000 --> 00:05:02.000
これは、操作全体が失敗するエラーです。

00:05:02.000 --> 00:05:06.000
例として、デバイスにはネットワーク接続がない可能性があります。

00:05:06.000 --> 00:05:13.000
その場合、操作全体がnetworkUnavailableエラーコードで失敗します。

00:05:13.000 --> 00:05:14.000
これが3番目の選択肢です。

00:05:14.000 --> 00:05:19.000
このシナリオでは、操作が正常にサーバーにラウンドトリッピングされました。

00:05:19.000 --> 00:05:28.000
サーバーは、要求された4番目のレコードが存在しないことを示すエラーとともに、要求されたCKRecordsの3つを正常に返しました。

00:05:28.000 --> 00:05:36.000
この例では、アイテムごとのエラーはunknownItemであり、partialFailureと呼ばれる操作ごとのエラーにバンドルされます。

00:05:36.000 --> 00:05:39.000
では、これはコードでどのように処理されますか?

00:05:39.000 --> 00:05:52.000
上部に、CKFetchRecordsOperationは、下部にこれらのそれぞれのサンプル実装とともに、perRecordCompletionBlockとper-operation完了ブロックを宣言します。

00:05:52.000 --> 00:05:55.000
これら2つのコールバックの重複に注意してください。

00:05:55.000 --> 00:06:11.000
以前から不足しているレコードの例から、コードはアイテムごとのエラーを2回期待しています。1回はアイテムごとのコールバックのトップレベルのunknownItemエラーとして、再び操作ごとのコールバックの部分的なFailureエラー内にバンドルされています。

00:06:11.000 --> 00:06:28.000
同様に、正常にフェッチされたレコードの2つの場所でアイテムごとの成功も期待しています。最初は、アイテムごとのコールバックのトップレベルのパラメータとして、もう一度、操作ごとのコールバックで成功した結果のrecordsByRecordID辞書にラップされています。

00:06:28.000 --> 00:06:36.000
Swift.Resultタイプを活用することで、CloudKitはこれらのコールバックの両方を置き換えてAPIをより明確にしました。

00:06:36.000 --> 00:06:42.000
新しい結果ベースのコールバックにおけるブロックパラメータの分離の最上位に注目してください。

00:06:42.000 --> 00:06:48.000
perRecordResultBlockには、CloudKitがコールバックしているアイテムを識別するIDがあります。

00:06:48.000 --> 00:06:51.000
そして、それはアイテムごとの結果を持っています。

00:06:51.000 --> 00:07:00.000
結果が強く入力されるようになったので、正常にフェッチされたCKRecordペイロード、またはアイテムごとのエラーのいずれかを取得していることを知っています。

00:07:00.000 --> 00:07:12.000
同様に、操作スコープの完了ブロックも、項目ごとの結果ブロックによってすでに報告された成功または失敗を複製しなくなった操作範囲の結果ブロックに更新されました。

00:07:12.000 --> 00:07:15.000
そのため、CloudKitは正式に懸念を分離しました。

00:07:15.000 --> 00:07:22.000
1つのブロックはアイテムごとのレポートにのみ使用され、もう1つのブロックは操作ごとのレポートにのみ使用されます。

00:07:22.000 --> 00:07:42.000
不足しているレコードの例に戻ると、期待されるのは、正常に取得されたCKRecordペイロードを持つアイテムごとの結果ブロックの3つの呼び出し、unknownItemエラーを持つアイテムごとの結果ブロックの1つの呼び出し、および操作全体が成功したため、エラーのない操作ごとの結果ブロックの1つの呼び出しです。

00:07:42.000 --> 00:07:49.000
CloudKitの新しい改善点の1つは、アイテムごとと操作ごとの別々のコールバックをどこでも表示することです。

00:07:49.000 --> 00:07:56.000
以前は、強調表示された操作にのみ、アイテムごとのエラーが表面化するアイテムごとのコールバックがありました。

00:07:56.000 --> 00:08:04.000
すべてのCKOperationsが、必要に応じてアイテムごとのエラーをパスバックするアイテムごとのコールバックを公開したことを発表できることを嬉しく思います。

00:08:04.000 --> 00:08:10.000
それでは、コンテナとデータベースのAPIに対して行ったいくつかの機能強化と拡張を見てみましょう。

00:08:10.000 --> 00:08:16.000
この機能強化は、CKContainerとCKDatabaseの新機能の形をとります。

00:08:16.000 --> 00:08:25.000
これらの新しい機能により、CKOperation APIの大部分がCKContainerとCKDatabaseの関数として利用可能になります。

00:08:25.000 --> 00:08:29.000
重要なのは、これは操作APIの1対1のマッピングではないということです。

00:08:29.000 --> 00:08:39.000
代わりに、デフォルトのパラメータとSwift.Resultタイプを活用して、親しみやすく、強力で、async/awaitで動作するAPIを作成しました。

00:08:39.000 --> 00:08:46.000
つまり、各新しい関数は2回公開されます。1回はcompletionHandlerを取り、再び非同期関数として。

00:08:46.000 --> 00:09:00.000
この強化されたAPIにより、コンテナとデータベースの機能は、複数のアイテムのバッチ処理、大規模なデータセットによるページング、変更の取得など、Operation APIの機能の一部をサポートするようになりました。

00:09:00.000 --> 00:09:07.000
また、ロギングのために関数呼び出しをグループ化し、結合されたワークロードサイズについてシステムに通知することもできます。

00:09:07.000 --> 00:09:11.000
タイムアウトを設定するなど、関数呼び出しも設定できるようになりました。

00:09:11.000 --> 00:09:15.000
では、これはどのように機能しますか?

00:09:15.000 --> 00:09:23.000
ここでもう一度、先ほど見たGitHub PrivateDatabaseのコードサンプルで、非同期関数を使用してレコードを削除します。

00:09:23.000 --> 00:09:28.000
アイテムのバッチ処理を利用するために、このコードをどのように更新できるか見てみましょう。

00:09:28.000 --> 00:09:38.000
この関数の動作を変更して、データベース上の拡張関数APIを利用して、2つのレコードをアトミックに削除します。

00:09:38.000 --> 00:09:41.000
懸念の分離に注目してください。

00:09:41.000 --> 00:09:44.000
強調表示された領域は、機能範囲で動作します。

00:09:44.000 --> 00:09:50.000
彼らは関数をキックオフし、スローされた関数スコープのエラーをキャッチします。

00:09:50.000 --> 00:09:58.000
そして、機能が正常に完了すると、この強調表示された領域は、項目ごとの成功または失敗を検査します。

00:09:58.000 --> 00:10:07.000
GitHubのコードサンプルリポジトリには、これらの機能のそれぞれをカバーする同様の例があり、このセッションのメモにはそれらのリポジトリへのリンクが含まれます。

00:10:07.000 --> 00:10:09.000
私たちは、あなたがそれらが役に立つことを願っています。

00:10:09.000 --> 00:10:16.000
そして、それで、私はそれをQianに渡して、暗号化されたフィールドを案内したいと思います。

00:10:16.000 --> 00:10:18.000
ありがとう、ニハール。

00:10:18.000 --> 00:10:25.000
私はQianです。ユーザーのデータプライバシーを非常に簡単に保護できるCloudKitの新機能について話します。

00:10:25.000 --> 00:10:38.000
これを行うには、まずCloudKitがユーザーのデータを保護する方法の概要を説明し、次に新しいデータ暗号化機能を紹介し、最後に、ユーザーのアカウントの暗号化の前提条件を紹介します。

00:10:38.000 --> 00:10:44.000
Appleでは、プライバシーは、すべての製品に組み込むコアバリューの1つです。

00:10:44.000 --> 00:10:56.000
多くのAppleアプリやサービスを強化するフレームワークとして、CloudKitはプライバシー技術を常に革新し、CloudKitと保存および同期されたデータの保護を提供してきました。

00:10:56.000 --> 00:11:00.000
まず、CloudKitがユーザーのデータをどのように保護しているかを確認しましょう。

00:11:00.000 --> 00:11:08.000
CloudKitのアプローチには、アカウントベースの保護と暗号化保護の2つの主要なデータ保護方法が含まれています。

00:11:08.000 --> 00:11:14.000
CloudKitに保存されているデータは、デフォルトでアカウントベースの認証によって保護されています。

00:11:14.000 --> 00:11:19.000
これには、CloudKitが支援するアプリとApple CloudKitが支援するすべてのアプリが含まれます。

00:11:19.000 --> 00:11:30.000
ストレージと検索時に、CloudKitは安全なトークンを使用して、許可されたユーザーのみがデータにアクセスできるように強制し、Appleや第三者はアクセスできません。

00:11:30.000 --> 00:11:36.000
念のため、プライベートデータベースと共有データベースのデータのみがアカウントベースの保護の対象となります。

00:11:36.000 --> 00:11:47.000
これらのデータベースでは、データは特定のiCloudアカウントに属しているか、共有されており、共有データへのアクセスには認証が必要です。

00:11:47.000 --> 00:11:58.000
ただし、公開データベースでは、すべてのユーザーがデータにアクセスできるため、アカウントベースのデータ保護はデフォルトでは適用されません。

00:11:58.000 --> 00:12:03.000
さて、他のデータ保護技術である暗号保護に移ります。

00:12:03.000 --> 00:12:14.000
CloudKitは、Appleが所有するアプリやサービスに保存されている機密データ、およびCKAssetの形で保存されているすべてのユーザーのデータの暗号化保護を提供します。

00:12:14.000 --> 00:12:25.000
これらのデータは、保存のためにCloudKitサーバーに送信される前にローカルで前処理および暗号化され、取得時にローカルで復号化されます。

00:12:25.000 --> 00:12:34.000
この暗号化機能は、デバイスにサインインしたiCloudアカウントに属するiCloudキーチェーンに保存されているキーマテリアルを使用します。

00:12:34.000 --> 00:12:44.000
また、CloudKitの共有機能と互換性があり、CKShareのユーザーのみが関連する暗号化されたフィールドを復号化できるようにします。

00:12:44.000 --> 00:12:49.000
暗号保護は、アカウントベースの保護の上に別のレイヤーを追加します。

00:12:49.000 --> 00:12:58.000
なぜなら、権限のない当事者が何らかの形で承認をバイパスしたとしても、取得したデータを復号化できないからです。

00:12:58.000 --> 00:13:03.000
暗号保護は、ユーザーにとって機密またはプライベートなデータに使用する必要があります。

00:13:03.000 --> 00:13:13.000
Apple内の多くのCloudKitが支援するアプリは、写真とメモを2つの例として、この機能を利用しています。

00:13:13.000 --> 00:13:21.000
これまで、ユーザーの非資産データに対するCloudKitの保護は、デフォルトでアカウントベースの保護を提供します。

00:13:21.000 --> 00:13:40.000
CloudKitは現在、すべてのキーの導出、管理、および暗号化/復号化プロセスからあなたを救うことに加えて、暗号化保護を提供しています。これは、これまで以上に強力なプライバシーの約束でCloudKitに裏打ちされたアプリを構築するのに役立ちます。

00:13:40.000 --> 00:13:43.000
それを行うのに役立つ新しいAPIをチェックしてみましょう。

00:13:43.000 --> 00:13:57.000
暗号化のためにCKRecordsの新しいプロパティencryptedValuesに任意のキー値のペアを追加し、同じ正確なプロパティを追加して、復号化された元の値を取り戻すことができます。

00:13:57.000 --> 00:14:04.000
encryptedValues APIを使用して、CloudKitサーバーを介して暗号化されたデータを同期する方法について説明します。

00:14:04.000 --> 00:14:08.000
ここには、2つのデバイスと1つのCloudKitサーバーがあります。

00:14:08.000 --> 00:14:18.000
encryptedValuesキー値ペアを設定すると、CloudKitはCKModifyRecordsOperationのローカルレコード値をサーバーに自動的に暗号化します。

00:14:18.000 --> 00:14:29.000
別のデバイスでは、サーバーからレコードを取得した後、同じAPIを呼び出すことができ、CloudKitは自動的にキー値のペアをアンラップします。

00:14:29.000 --> 00:14:33.000
このプロセスを達成するには、最低限のコードの変更が必要です。

00:14:33.000 --> 00:14:39.000
最初のデバイスでは、encryptedValues APIを使用して、レコードにキー値のペアを設定できます。

00:14:39.000 --> 00:14:46.000
この場合、キーは「encryptedStringField」で、値は文字列オブジェクトです。

00:14:46.000 --> 00:14:54.000
その後、CKModifyRecordsOperationを呼び出すと、新しいレコードがサーバーに保存されます。

00:14:54.000 --> 00:15:06.000
2番目のデバイスでは、CKFetchRecordsOperationを呼び出して暗号化されたレコードを取得し、同じencryptedValuesプロパティを使用することで、文字列を取り戻すことができます。

00:15:06.000 --> 00:15:07.000
それでおそれ。

00:15:07.000 --> 00:15:12.000
1つのシンプルなプロパティは、すべての暗号化および復号化プロセスを処理します。

00:15:12.000 --> 00:15:22.000
また、CKReference以外のほぼすべてのCKRecord値タイプを暗号化できます。

00:15:22.000 --> 00:15:33.000
前述したように、CKAssetフィールドはすでにデフォルトで暗号化を採用しているため、encryptedValueとして設定できないことに注意してください。

00:15:33.000 --> 00:15:41.000
通常のフィールドと同様に、CloudKitデータベーススキーマに行くことで、暗号化されたフィールドを視覚化できます。

00:15:41.000 --> 00:15:49.000
CloudKitコンソールセッション「Meet CloudKit Console」があり、コンソールに加えられた他の変更が表示され、お気軽にチェックしてください。

00:15:49.000 --> 00:15:57.000
コンソールでは、すべての暗号化されたフィールドがレコード値データ型のドロップダウンに表示されます。

00:15:57.000 --> 00:16:06.000
「暗号化されたダブル」、「暗号化されたタイムスタンプ」などの接頭辞「暗号化」があり、暗号化されていないものと区別するのに役立ちます。

00:16:06.000 --> 00:16:13.000
コードを変更することなく、CloudKitコンソールを通じて暗号化されたフィールドを直接管理することもできます。

00:16:13.000 --> 00:16:21.000
たとえば、開発データベーススキーマの新しいレコードタイプに新しい暗号化フィールドを追加できます。

00:16:21.000 --> 00:16:26.000
暗号化を含む操作のアカウントの前提条件に進みます。

00:16:26.000 --> 00:16:34.000
プライベートデータベースや共有データベースの他の操作と同様に、有効なログインアカウントが必要です。

00:16:34.000 --> 00:16:45.000
CKContainer accountStatus(completionHandler:)を呼び出して、初期化ロジックで現在のアカウントのステータスを確認する必要があります。

00:16:45.000 --> 00:16:53.000
リマインダーとして、ステータスはプライベートデータベースと共有データベースでの操作に「利用可能」である必要があります。

00:16:53.000 --> 00:17:13.000
他の州ではエラーが発生します。「CKErrorNotAuthenticated」は、アカウントがログインしているが準備ができていないことを示すために今年導入された新しい状態を含む「一時的に利用不可」であり、設定アプリで資格情報を確認するようにユーザーに指示することができます。

00:17:13.000 --> 00:17:26.000
ユーザーのアカウントが「利用可能」状態ではない場合は、アカウントが変更されるたびに投稿されるCKAccountChanged通知を聞いて、状態の準備ができたときに通知を受ける必要があります。

00:17:26.000 --> 00:17:30.000
CloudKitによるデータの暗号化について知っておくべきことはそれだけです。

00:17:30.000 --> 00:17:37.000
ユーザーのデータを保護し、独自のカスタムソリューションを実装することからすべての時間とエネルギーを節約します。

00:17:37.000 --> 00:17:41.000
さて、私の素晴らしい同僚Niharに戻って、ゾーン共有について話します。

00:17:41.000 --> 00:17:46.000
ありがとう、チアン！CloudKitの共有について話しましょう。

00:17:46.000 --> 00:17:56.000
CloudKitは、すべてのユーザーのデバイスにユーザーデータを保存および同期するのに役立つ、安全でプライバシーに配慮したiCloudデータベースです。

00:17:56.000 --> 00:18:04.000
iOS 10とmacOS Sierraは、他のiCloudユーザーと安全にデータを共有する方法であるCloudKit共有を導入しました。

00:18:04.000 --> 00:18:12.000
共有の新機能に飛び込む前に、今日のCloudKit共有がどのように機能するかを詳しく見てみましょう。

00:18:12.000 --> 00:18:28.000
リマインダーとして、CloudKitの共有は、共有されるデータを誰と共有しているか、それらの共有参加者がどのような許可を持っているかなど、共有関連の詳細から分離するCKShareオブジェクトの作成によって開始されます。

00:18:28.000 --> 00:18:40.000
舞台裏では、CloudKitは、すべてのリクエストにアカウントベースの認証を要求することに加えて、参加者の共有データへの暗号アクセスを確立します。

00:18:40.000 --> 00:18:44.000
さて、アプリに共有サポートを追加するには、主に2つの方法があります。

00:18:44.000 --> 00:18:56.000
iOSではUICloudSharingController、macOSではNSSharingServiceを使用して、共有管理にシステムが提供するUIを使用して、すぐに始めることができます。

00:18:56.000 --> 00:19:04.000
または、これらのフレームワーク操作を使用して、ユーザーが共有設定と対話できるように、独自のカスタムUIを構築することもできます。

00:19:04.000 --> 00:19:11.000
先に述べたように、CKSharesは共有されているものと誰と共有されているかを分離します。

00:19:11.000 --> 00:19:26.000
今日は、その方程式の前半に焦点を当て、より具体的には、データをモデル化できるいくつかの異なる方法と、それがCloudKit共有APIを活用する方法にどのように影響するかを見ていきます。

00:19:26.000 --> 00:19:32.000
既存のCloudKit共有機能を利用する例から始めましょう。

00:19:32.000 --> 00:19:36.000
iCloud Driveのフォルダ共有は、CloudKitの上に構築されています。

00:19:36.000 --> 00:19:41.000
自分のアプリで似たようなものを構築する方法を見てみましょう。 あなた自身のアプリで似たようなものを構築しましょう。

00:19:41.000 --> 00:19:59.000
したがって、ここでのデータモデルはファイルシステム階層を表しているため、「ファイル」と「フォルダ」タイプのレコードから始めて、その中に含まれるすべてのレコード、ファイル、またはフォルダと一緒に任意のフォルダレコードを簡単に共有できるようにしたいと考えています。

00:19:59.000 --> 00:20:11.000
CloudKitでこの階層関係を表現し、共有に活用する方法は、子から親レコードへのCKRecord.parent参照を使用することです。

00:20:11.000 --> 00:20:20.000
これにより、CloudKitは結果の階層を単一の共有可能なユニットとして扱うため、先に進んでこれらの参照をここに追加したいと思うでしょう。

00:20:20.000 --> 00:20:25.000
これは非常に重要であり、CloudKitで親参照を特別なものにしています。

00:20:25.000 --> 00:20:36.000
共有をサポートする予定がない場合は、親参照を使用する必要はなく、独自のスキーマ内のプレーンなCKReferenceフィールドで十分であることに注意してください。

00:20:36.000 --> 00:20:46.000
その設定により、フォルダレコードをCKShareのルートレコードとして、CKShareを初期化するだけで、フォルダ共有をサポートできるようになりました。

00:20:46.000 --> 00:20:57.000
フォルダをルートレコードとして使用すると、CloudKitは、最終的にそのフォルダレコードを指す親参照ベースの階層の一部であるすべてのレコードを自動的に共有することを意味します。

00:20:57.000 --> 00:21:06.000
これはまた、後の時点でこの階層から追加または削除されたレコードが、それぞれ自動的に共有または共有解除されることを意味します。

00:21:06.000 --> 00:21:11.000
では、このシンプルなフォルダ共有モデルはコードでどのように設定されていますか?

00:21:11.000 --> 00:21:21.000
この例に引き続き、プライベートデータベースのカスタムゾーンで共有するフォルダレコードとともに、2つのファイルレコードを次に示します。

00:21:21.000 --> 00:21:30.000
まず、親参照はフォルダレコードを指す両方のファイルレコードに設定され、ファイルレコードが保存されます。

00:21:30.000 --> 00:21:42.000
フォルダが共有されているときに変更する必要があるレコードの数を最小限に抑えるために、親参照をできるだけ早く保存することをお勧めします。

00:21:42.000 --> 00:21:53.000
次に、3つのレコードはすべて、CKShareをフォルダをルートレコードとして初期化し、CKShareをフォルダレコードと一緒にプライベートデータベースに保存することで共有されます。

00:21:53.000 --> 00:22:04.000
親参照は以前にサーバーに保存されていたため、共有時に共有とともにルートフォルダレコードのみを変更する必要があることに注意してください。

00:22:04.000 --> 00:22:10.000
そして、それだけです、あなたのアプリは今、フォルダレコードとその下のレコードを共有しています。

00:22:10.000 --> 00:22:19.000
CloudKitは、レコード階層が重複しない限り、同じゾーン内の複数のCKShareをサポートできます。

00:22:19.000 --> 00:22:29.000
さて、階層的なフォルダ共有モデルの代わりに、ゾーン内にいくつかの異なるタイプを表すレコードがあり、それらの間に論理的な階層がないとしましょう。

00:22:29.000 --> 00:22:37.000
言い換えれば、ゾーンはレコードのバケットとして扱われており、その中のすべてのレコードの共有をすばやく開始したいと考えています。

00:22:37.000 --> 00:22:46.000
理想的には、レコードゾーン内のレコードを操作することなく、レコードゾーン全体を「共有」としてマークすることができます。

00:22:46.000 --> 00:22:49.000
今、ゾーン共有で、あなたはまさにそれを行うことができます。

00:22:49.000 --> 00:22:52.000
では、これをコードで設定しましょう。

00:22:52.000 --> 00:23:01.000
あなたがする必要があるのは、プライベートデータベース内の既存のゾーンのレコードゾーンIDを取るCKShareの新しい初期化子を使用することだけです。

00:23:01.000 --> 00:23:17.000
この新しいゾーン全体の共有レコードが保存されると、サーバー上のこのゾーンに存在するすべてのレコードは自動的に共有され、ゾーンからそれらのレコードを追加または削除するだけで、新しいレコードの共有または共有解除が機能します。

00:23:17.000 --> 00:23:22.000
ゾーン全体の共有レコードを削除することで、いつでもレコードゾーン全体を非共有にすることができます。

00:23:22.000 --> 00:23:29.000
これらの新しいゾーン全体の共有記録をもう少し深く掘り下げてみましょう。

00:23:29.000 --> 00:23:42.000
便宜上、ゾーン全体の共有レコードには常によく知られたレコード名CKRecordNameZoneWideShareがあり、ゾーンIDと一緒に使用して完全な共有レコードIDを作成できます。

00:23:42.000 --> 00:23:50.000
ゾーン共有を使用するゾーンでは、そのゾーンのレコード間で親参照を設定する必要はありません。

00:23:50.000 --> 00:23:59.000
ゾーン共有はゾーンごとに単一の共有レコードしか許可しないため、この共有のフレーバーは、同じゾーン内の階層的な共有と共存できないことに注意してください。

00:23:59.000 --> 00:24:08.000
したがって、ゾーンに1つ以上の階層的な共有、または単一のゾーン全体の共有レコードを持つことができます。

00:24:08.000 --> 00:24:20.000
デフォルト以外のレコードゾーンにゾーン全体のシェアを保存でき、これらは新しいゾーン機能であるCKRecordZoneCapability ZoneWideSharingでもマークされています。

00:24:20.000 --> 00:24:30.000
CKShareレコードの作成を過ぎた既存のCloudKit共有メカニズムはすべて同じままであり、1つの例外を除いてゾーン全体の共有で完全にサポートされています。

00:24:30.000 --> 00:24:43.000
ゾーン共有を使用する場合、ルートレコードがなくなったため、階層RootRecordIDやrootRecordなどのCKShareMetadataの関連プロパティは、ゾーン共有を受け入れるとゼロになります。

00:24:43.000 --> 00:24:59.000
同様に、CKFetchShareMetadataOperationを使用してカスタム共有受け入れフローをブートストラップする場合、ゾーン全体の共有の共有メタデータを取得するときに、プロパティ「shouldFetchRootRecord」と「rootRecordDesiredKeys」はシステムによって無視されます。

00:24:59.000 --> 00:25:05.000
そのため、データモデルに応じて、CloudKit共有の2つのフレーバーが利用可能になりました。

00:25:05.000 --> 00:25:18.000
アプリのスキーマが階層を論理的に形成し、階層ツリーが共有可能な単位として理にかなっている場合は、引き続きCKRecordの親参照を使用してそれらの階層を表し、ルートレコードを共有します。

00:25:18.000 --> 00:25:26.000
Appleでは、今日調査したのと同様の方法で、メモ、リマインダー、iCloud Driveのフォルダ共有のためにこれを行います。

00:25:26.000 --> 00:25:38.000
また、他のすべてのケースでは、単一のゾーン全体の共有レコードを作成するだけで、レコードゾーン全体を効率的に共有し、CloudKit共有を最大限に活用できるようになりました。

00:25:38.000 --> 00:25:46.000
Appleでは、HomeKitの安全なビデオ共有やHomePodのマルチユーザーなど、いくつかの機能にゾーン共有をすでに活用しています。

00:25:46.000 --> 00:26:00.000
そこで今日は、アイテムごとの進行状況やエラー報告APIの強化など、Swiftでasync/awaitを使用してCloudKitコードを新しい方法で書き始める方法を検討しました。

00:26:00.000 --> 00:26:12.000
独自の暗号化をロールすることなく、ユーザーのプライバシーに対するAppleのコミットメントを利用して、機密性の高いユーザーデータのために記録上の暗号化されたフィールドを活用する方法について話しました。

00:26:12.000 --> 00:26:20.000
そして、データモデルがゾーン共有で階層化されていない場合に、CloudKit共有を開始するより迅速な方法について学びました。

00:26:20.000 --> 00:26:28.000
これらの機能に関するいくつかの素晴らしい新しいドキュメントがあり、developer.apple.comでさらに多くのドキュメントが利用可能ですので、ぜひ見てください。

00:26:28.000 --> 00:26:38.000
「Explore CloudKit」コレクションには、CloudKitの上に構築された共有機能を導入するCore Dataからのセッションを含め、チェックアウトするための多くの関連セッションがあります。

00:26:38.000 --> 00:26:42.000
ありがとう、そして素晴らしいWWDCをお過ごしください。

00:26:42.000 --> 23:59:59.000
[明るい音楽]。

