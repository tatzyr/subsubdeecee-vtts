WEBVTT

00:00:01.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:13.000
こんにちは、UIKitチームのエンジニア、アディティア・クリシュナデヴァンです。

00:00:13.000 --> 00:00:17.000
多くのアプリの中核には、リストまたはコレクションビューがあります。

00:00:17.000 --> 00:00:22.000
超スムーズなスクロールを持つことは、これらのアプリを素晴らしい気分にさせるための大きな部分です。

00:00:22.000 --> 00:00:28.000
このビデオは、超高速のリストとコレクションビューを作成するときに成功のためにあなたを設定します。

00:00:28.000 --> 00:00:35.000
コレクションビューを使用して、いくつかの素晴らしい旅行先の画像投稿のリストを表示するこのアプリをここで構築します。

00:00:35.000 --> 00:00:41.000
一見するとかなりシンプルで、目的地の写真といくつかのテキストラベルがあります。

00:00:41.000 --> 00:00:47.000
このビデオを通して、それがどのように設定され、人々が期待するパフォーマンスをどのように達成するかについて話します。

00:00:47.000 --> 00:00:54.000
まず、差分可能なデータソースやセル登録などのAPIを使用する際の強力な基盤から始める方法を学びます。

00:00:54.000 --> 00:00:59.000
コレクションビューセルのライフサイクルの理解をリフレッシュします。

00:00:59.000 --> 00:01:06.000
次に、完全に滑らかなスクロールが見えない理由と、役立つプリフェッチの進歩について話します。

00:01:06.000 --> 00:01:18.000
最後に、Patrickは、コンテンツが非同期に届いたときにセルを正しく更新する方法と、新しいUIImage APIを使用してすべてのデバイスで最高のスクロールパフォーマンスを得る方法を説明します。

00:01:18.000 --> 00:01:20.000
わかりました。

00:01:20.000 --> 00:01:24.000
アプリがデータをどのように構成するかについて話すことから始めましょう。

00:01:24.000 --> 00:01:31.000
サンプルアプリは、表示する投稿のリストを取得し、各投稿はこのDestinationPost構造体で表されます。

00:01:31.000 --> 00:01:38.000
DestinationPostは識別可能に準拠しています。つまり、識別子を格納するこのIDプロパティがあります。

00:01:38.000 --> 00:01:45.000
これは、他のプロパティが変更されても安定したままである各DestinationPostの一意の識別子です。

00:01:45.000 --> 00:01:52.000
拡散可能なデータソースは、モデルオブジェクト自体ではなく、モデル内のアイテムの識別子を格納するために構築されています。

00:01:52.000 --> 00:02:00.000
したがって、サンプルアプリでは、差分可能なデータソースは、DestinationPost自体ではなく、ここのIDプロパティを使用して入力されます。

00:02:00.000 --> 00:02:03.000
アプリで使用されている差分可能なデータソースは次のとおりです。

00:02:03.000 --> 00:02:09.000
先ほど説明したように、アイテム識別子にDestinationPost.IDタイプを使用します。

00:02:09.000 --> 00:02:15.000
ここのセクションタイプは、アプリには1つのセクションしかないため、1つのケースを持つ列挙型です。

00:02:15.000 --> 00:02:21.000
データソースに入力するには、アプリは最初に空のスナップショットを作成し、メインセクションを追加します。

00:02:21.000 --> 00:02:27.000
次に、バッキングストアからすべての投稿を取得し、その識別子を追加します。

00:02:27.000 --> 00:02:38.000
このようにして、DestinationPostの他のプロパティの1つが変更された場合、識別子が変更されないため、差分可能なデータソースでの表現は安定しています。

00:02:38.000 --> 00:02:42.000
最後のステップは、スナップショットをデータソースに適用することです。

00:02:42.000 --> 00:02:49.000
iOS 15より前では、アニメーションなしでスナップショットを適用すると、内部的にreloadDataに変換されます。

00:02:49.000 --> 00:02:56.000
コレクションビューは画面上のすべてのセルを破棄して再作成しなければならなかったため、パフォーマンスには最適ではありませんでした。

00:02:56.000 --> 00:03:04.000
iOS 15以降、アニメーションなしでスナップショットを適用すると、違いのみが適用され、余分な作業は実行されません。

00:03:04.000 --> 00:03:14.000
iOS 15では、拡散可能なデータソースは、目に見えるセルの内容を非常に簡単に更新できる新しいreconfigureItemsメソッドも得られます。

00:03:14.000 --> 00:03:17.000
それがどのように機能するかについては、このビデオの後半で説明します。

00:03:17.000 --> 00:03:22.000
まず、データソースからセルと画面にデータを取得しましょう。

00:03:22.000 --> 00:03:33.000
セル登録は、各タイプのセルのすべての構成を1か所に保持するのに最適な方法であり、拡散可能なデータソースからの識別子への便利なアクセスを提供します。

00:03:33.000 --> 00:03:43.000
UICollectionViewは、登録のインスタンスごとに再利用キューを維持しているため、セルの種類ごとに一度だけ登録を作成するようにしてください。

00:03:43.000 --> 00:03:46.000
これは、アプリ内のセルの簡略化された登録です。

00:03:46.000 --> 00:03:54.000
渡されたpostIDは、DestinationPostと画像を含むアセットオブジェクトを取得するために使用されます。

00:03:54.000 --> 00:04:00.000
DestinationPostのプロパティは、セルのタイトルと画像を設定するために使用されます。

00:04:00.000 --> 00:04:08.000
登録を使用するには、データソースのセルプロバイダー内でdequeueConfiguredReusableCellを呼び出します。

00:04:08.000 --> 00:04:13.000
登録がセルプロバイダーの外でどのように作成され、内部で使用されるかに注意してください。

00:04:13.000 --> 00:04:22.000
プロバイダー内で登録を作成すると、コレクションビューがセルを再利用しないことを意味するため、これはパフォーマンスにとって重要です。

00:04:22.000 --> 00:04:29.000
セルの設定方法を理解したので、セルがいつ設定され、そのライフサイクルがどのようなものかに移ります。

00:04:29.000 --> 00:04:35.000
細胞の寿命は、準備と表示の2つの段階で構成されています。

00:04:35.000 --> 00:04:39.000
準備の最初のステップは、作業するセルを取得することです。

00:04:39.000 --> 00:04:44.000
UICollectionViewがセルを必要とするときはいつでも、データソースからセルを要求します。

00:04:44.000 --> 00:04:49.000
これが差分可能なデータソースである場合、セルプロバイダーを実行し、結果を返します。

00:04:49.000 --> 00:04:55.000
セルプロバイダーが実行されると、コレクションビューは登録を使用して新しいセルをキューからデキューするように求められます。

00:04:55.000 --> 00:05:02.000
再利用プールにセルが存在する場合、UICollectionViewはprepareForReuseを呼び出し、セルをキューから解除します。

00:05:02.000 --> 00:05:07.000
再利用プールが空の場合、新しいセルが初期化されます。

00:05:07.000 --> 00:05:12.000
その後、そのセルは登録から構成ハンドラに渡されます。

00:05:12.000 --> 00:05:18.000
これは、アプリが特定のアイテム識別子とインデックスパスを表示するためのセルを設定する場所です。

00:05:18.000 --> 00:05:23.000
設定したセルは、次のステップのためにコレクションビューに返されます。

00:05:23.000 --> 00:05:29.000
コレクションビューは、セルに好みのレイアウト属性を照会し、セルのサイズを適切に設定します。

00:05:29.000 --> 00:05:35.000
この時点で、セルは完全に準備され、フェーズ2:表示の準備ができています。

00:05:35.000 --> 00:05:40.000
willDisplayCellはデリゲートで呼び出され、セルはUICollectionView内に表示されます。

00:05:40.000 --> 00:05:42.000
セルが画面に表示されました。

00:05:42.000 --> 00:05:46.000
目に見えるままである間、そのライフサイクルにこれ以上の変化はありません。

00:05:46.000 --> 00:05:53.000
画面からスクロールすると、didEndDisplayingがセルに呼び出され、再利用プールに戻ります。

00:05:53.000 --> 00:05:58.000
再利用プールから、セルを再びキューから解除し、このプロセスを繰り返すことができます。

00:05:58.000 --> 00:06:02.000
それでは、これらの基本でアプリがどんな感じかを確認しましょう。

00:06:02.000 --> 00:06:07.000
このアプリは、ペルーのクスコとカリブ海のセントルシアを特集しています。

00:06:07.000 --> 00:06:23.000
アプリをスクロールして他の目的地を見てみましょうが、スムーズにスクロールしないことに注目してください。

00:06:23.000 --> 00:06:27.000
スクロール中のこれらの中断は「ヒッチ」と呼ばれます。

00:06:27.000 --> 00:06:33.000
ヒッチの原因を理解するために、まずアプリがディスプレイを更新する方法を学びましょう。

00:06:33.000 --> 00:06:37.000
フレームごとに、タッチなどのイベントがアプリに配信されます。

00:06:37.000 --> 00:06:41.000
それに応じて、ビューとレイヤーのプロパティを更新します。

00:06:41.000 --> 00:06:49.000
たとえば、スクロールビューのcontentOffsetは、パンジェスチャー中に変更され、含まれているすべてのビューの画面上の場所が変更されます。

00:06:49.000 --> 00:06:53.000
これらの変更の結果、アプリのビューとレイヤーはレイアウトを実行します。

00:06:53.000 --> 00:06:56.000
このプロセスは「コミット」と呼ばれます。

00:06:56.000 --> 00:07:00.000
次に、レイヤーツリーがレンダリングサーバーに送信されます。

00:07:00.000 --> 00:07:02.000
各フレームにはコミット期限があります。

00:07:02.000 --> 00:07:06.000
これは、そのフレームのすべてのコミットを終了する必要がある時間です。

00:07:06.000 --> 00:07:12.000
アプリが各フレームに対してコミットしなければならない時間は、ディスプレイのリフレッシュレートによって異なります。

00:07:12.000 --> 00:07:22.000
たとえば、より高いリフレッシュレート120Hzで実行されているiPad Proでは、60Hzで実行されているiPhoneと比較して、アプリは各フレームの作業を完了する時間が少なくなります。

00:07:22.000 --> 00:07:28.000
コレクションまたはテーブルビューでセルのリストをスクロールする典型的な例を次に示します。

00:07:28.000 --> 00:07:35.000
新しいセルが表示されると、より長いコミットがあり、その間に新しいセルが設定され、レイアウトが実行されます。

00:07:35.000 --> 00:07:41.000
次に、画面上で移動されている既存のセルだけであるいくつかのフレームがあります。

00:07:41.000 --> 00:07:46.000
新しいセルが不要なため、これらのフレームのコミットは高速です。

00:07:46.000 --> 00:07:53.000
最終的には、スクロール位置が十分に変化し、新しいセルが見えるようになり、このパターンが繰り返されます。

00:07:53.000 --> 00:07:57.000
では、以前のデモのようなヒッチの原因は何ですか?

00:07:57.000 --> 00:08:04.000
フレームのコミットに時間がかかりすぎて締め切りに間に合わない場合、それらの更新は意図したフレームに組み込まれません。

00:08:04.000 --> 00:08:10.000
ディスプレイは、コミットが終了するまで前のフレームを画面に保持し、この遅延フレームをレンダリングできます。

00:08:10.000 --> 00:08:16.000
これはコミットヒッチであり、スクロール時に一時的な中断として認識されます。

00:08:16.000 --> 00:08:22.000
これと他のタイプのヒッチの詳細については、「UIアニメーションヒッチを探索する」ビデオをご覧ください。

00:08:22.000 --> 00:08:32.000
これらのヒッチを避けるために、UICollectionViewとUITableViewは両方ともiOS 15でまったく新しいセルプリフェッチメカニズムを持っています。

00:08:32.000 --> 00:08:36.000
高価なセルがスクロール中にヒッチを引き起こす例に戻ってきました。

00:08:36.000 --> 00:08:41.000
ここからの重要なポイントは、通常、すべてのフレームにセルを必要としないということです。

00:08:41.000 --> 00:08:46.000
私たちは、最小限の作業を行う非常に短いコミットを持ついくつかのフレームを持っています。

00:08:46.000 --> 00:08:55.000
iOS 15でのセルプリフェッチは、短いコミットを終えた直後に次のセルを準備することで、この空き時間を利用します。

00:08:55.000 --> 00:09:00.000
そして、セルが最終的に必要になったとき、それはそれを見えるようにするだけの問題です。

00:09:00.000 --> 00:09:08.000
そのため、すべての作業が以前に行われたため、プリフェッチされたセルが表示されるフレームのコミットは非常に迅速です。

00:09:08.000 --> 00:09:13.000
セルのプリフェッチに費やした時間は、ヒッチを引き起こしたときと同じです。

00:09:13.000 --> 00:09:17.000
しかし、私たちはヘッドスタートを得ることができるので、ヒッチを避けることができます。

00:09:17.000 --> 00:09:22.000
各コミットをステップスルーすることで、これがなぜ機能するのかを理解しましょう。

00:09:22.000 --> 00:09:26.000
プリフェッチが発生する前に、このフレームのコミットを実行しました。

00:09:26.000 --> 00:09:32.000
セルは必要なかったので、それは迅速なコミットであり、締め切り前に多くの時間を残して終了しました。

00:09:32.000 --> 00:09:43.000
iOS 15では、次のフレームまで待つのではなく、システムは状況を認識し、空き時間を使って次のセルのプリフェッチを開始します。

00:09:43.000 --> 00:09:46.000
さて、次のフレームは物事が面白くなるところです。

00:09:46.000 --> 00:09:53.000
プリフェッチされるセルは高価であるため、実際にはそのフレームのコミットが通常よりも遅く開始されます。

00:09:53.000 --> 00:10:00.000
しかし、そのコミットは遅く始まりますが、迅速であるため、締め切りのかなり前に終了します。

00:10:00.000 --> 00:10:05.000
これを、プリフェッチせずに先ほど見たイラストと比較してください。

00:10:05.000 --> 00:10:12.000
締め切りを逃したコミットがなくなり、セルプリフェッチのヒッチがなくなったことに注目してください。

00:10:12.000 --> 00:10:18.000
これは、アプリがヒッチハイドを引き起こすことなく、各セルを準備するのに最大2倍の時間を費やすことを意味します。

00:10:18.000 --> 00:10:26.000
さらに、この素晴らしい新機能を手に入れるために必要なのは、iOS 15 SDKでアプリを構築することだけです。

00:10:26.000 --> 00:10:31.000
私が最後にデモを実行したとき、アプリはiOS 14 SDKで構築されました。

00:10:31.000 --> 00:10:41.000
iOS 15 SDKで構築されたら、アプリでのスクロールをチェックしてみましょう。

00:10:41.000 --> 00:10:42.000
これはすごい！

00:10:42.000 --> 00:10:45.000
プリフェッチはまさに私たちが望むことをしているように見えます。

00:10:45.000 --> 00:10:51.000
スクロールは完全にスムーズになり、1行のコードも変更する必要はありませんでした。

00:10:51.000 --> 00:10:56.000
覚えておいて、あなたがする必要があるのは、iOS 15 SDKを使用してアプリを構築することだけです。

00:10:56.000 --> 00:11:02.000
UICollectionViewの場合、この新しいプリフェッチはiOS 10で導入されたものを拡張します。

00:11:02.000 --> 00:11:07.000
セルプリフェッチは、リストと他のすべての構成レイアウトでサポートされるようになりました。

00:11:07.000 --> 00:11:12.000
この素晴らしい新しいプリフェッチは、UITableViewでも有効になりました。

00:11:12.000 --> 00:11:19.000
プリフェッチは、ヒッチを排除することでスクロール性能を向上させることができますが、電力使用量を削減し、バッテリー寿命を延ばすこともできます。

00:11:19.000 --> 00:11:26.000
セルが迅速に準備できる場合、システムは余分な時間を使用して、よりエネルギー効率の高い状態で実行し、それでもヒッチを避けることができます。

00:11:26.000 --> 00:11:36.000
したがって、ヒッチに気付かなくても、セルの設定とレイアウトの実装をできるだけ効率的にすることが非常に重要です。

00:11:36.000 --> 00:11:40.000
それでは、プリフェッチが細胞のライフサイクルにどのように影響するかについて話しましょう。

00:11:40.000 --> 00:11:46.000
これは、2つの異なるフェーズで、プリフェッチなしで、先ほど話したライフサイクルです。

00:11:46.000 --> 00:11:53.000
セルがプリフェッチされると、画面上で必要とされるセルの前に実行される準備フェーズです。

00:11:53.000 --> 00:11:58.000
プリフェッチを最大限に活用するには、この段階でセルを完全に設定する必要があります。

00:11:58.000 --> 00:12:02.000
重い作業を行うためにセルが見えるまで待たないでください。

00:12:02.000 --> 00:12:09.000
セルがコレクションビューに戻ると、プリフェッチの一部としても、優先するレイアウト属性を取得するようにサイズが設定されます。

00:12:09.000 --> 00:12:16.000
プリフェッチされた後、セルが表示されるのを待っているこの中間状態があります。

00:12:16.000 --> 00:12:21.000
この新しい段階を考えると、アプリには2つの重要な考慮事項があります。

00:12:21.000 --> 00:12:29.000
準備されたセルが表示されない可能性があります。これは、ユーザーが突然スクロール方向を変更した場合に発生する可能性があります。

00:12:29.000 --> 00:12:36.000
その後、セルが表示されると、画面から外れた後、すぐに待機状態に戻ることができます。

00:12:36.000 --> 00:12:40.000
同じセルを同じインデックスパスに複数回表示できます。

00:12:40.000 --> 00:12:46.000
セルの表示が終了すると、すぐに再利用プールに追加されることはもはやありません。

00:12:46.000 --> 00:12:51.000
プリフェッチは、スムーズなスクロールを実現するのに役立ちますが、それは私たちにより多くの時間を与えるからです。

00:12:51.000 --> 00:12:57.000
フレームレートの高い他のデバイスでは、スクロール中にアプリがヒッチする可能性があります。

00:12:57.000 --> 00:13:08.000
パトリックは、アプリがセルを設定する方法の詳細を提供し、画像を表示する際のコミットあたりの時間を短縮する戦略についても説明します。

00:13:08.000 --> 00:13:09.000
ありがとう、アディ。

00:13:09.000 --> 00:13:12.000
こんにちは、ハイレベルパフォーマンスチームのパトリックです。

00:13:12.000 --> 00:13:23.000
次に、サンプルアプリの既存のセルを更新し、iOS 15でいくつかの新しいAPIを利用して、可能な限り最高のパフォーマンスで画像を表示する方法をご案内します。

00:13:23.000 --> 00:13:27.000
サンプルアプリは、ディスク上のローカルイメージファイルで構築されました。

00:13:27.000 --> 00:13:35.000
アプリをスクロールすると、セルは画面から離れて準備され、その中の画像はすぐにファイルシステムから読み込まれます。

00:13:35.000 --> 00:13:40.000
今、私たちはリモートサーバーに保存されている画像を表示したい。

00:13:40.000 --> 00:13:45.000
したがって、セルがスクロールすると、画像ビューに表示する画像がない可能性があります。

00:13:45.000 --> 00:13:52.000
画像ビューが最初に表示されるとき、それは空白になり、サーバー要求が完了した後にのみ入力されます。

00:13:52.000 --> 00:13:57.000
この新しいアプローチをサポートするために、登録の構成ハンドラを拡張することを見てみましょう。

00:13:57.000 --> 00:14:04.000
登録の構成ハンドラでは、すでにアセットストアからアセットを取得しています。

00:14:04.000 --> 00:14:09.000
ストアは常に画像を返しますが、完全な資産ではないかもしれません。

00:14:09.000 --> 00:14:11.000
ダウンロードする必要があるかもしれません。

00:14:11.000 --> 00:14:16.000
アセットオブジェクトは、isPlaceholderプロパティでこれを示します。

00:14:16.000 --> 00:14:21.000
これが当てはまる場合は、アセットストアに完全な画像をダウンロードするよう依頼します。

00:14:21.000 --> 00:14:26.000
ロード操作が完了したら、セルの画像ビューを更新する時間です。

00:14:26.000 --> 00:14:33.000
ここでは、既存のセルオブジェクトを取り、その画像ビューにアセットを設定します。

00:14:33.000 --> 00:14:35.000
これは間違いです。

00:14:35.000 --> 00:14:45.000
セルは異なる宛先に再利用され、アセットストアが最終的なアセットをロードする頃には、キャプチャしたセルオブジェクトを別のポストに設定できます。

00:14:45.000 --> 00:14:53.000
セルを直接更新する代わりに、必要な更新をコレクションビューのデータソースに通知する必要があります。

00:14:53.000 --> 00:14:58.000
iOS 15では、reconfigureItemsスナップショットメソッドが導入されています。

00:14:58.000 --> 00:15:04.000
準備されたセルでreconfigureItemsを呼び出すと、登録の設定ハンドラが再実行されます。

00:15:04.000 --> 00:15:13.000
新しいセルのキューイングを解除して設定するのではなく、アイテムの既存のセルを再利用するため、reloadItemsの代わりにこれを使用してください。

00:15:13.000 --> 00:15:22.000
サンプルアプリでは、渡されたIDでreconfigureItemsを呼び出すsetPostNeedsUpdateメソッドを宣言します。

00:15:22.000 --> 00:15:32.000
さて、登録の設定ハンドラに戻って、画像がプレースホルダである場合、フルサイズのアセットをダウンロードし、新しいメソッドを呼び出します。

00:15:32.000 --> 00:15:42.000
reconfigureItemsはこのハンドラーを再び呼び出しますが、fetchByIDはプレースホルダではなく完全なアセットを返します。

00:15:42.000 --> 00:15:52.000
これにより、すべてのビュー更新コードを1か所に保存し、データを取得したらセルを非同期に更新することができます。

00:15:52.000 --> 00:15:59.000
準備時間を最大化するために、prefetchingDataSource内でdownloadAssetメソッドを使用することもできます。

00:15:59.000 --> 00:16:04.000
データソースのプリフェッチは、コレクションビューアイテムのネットワークダウンロードを開始するのに最適な場所です。

00:16:04.000 --> 00:16:14.000
セルが表示される前にアセットをダウンロードして準備する時間が増え、ユーザーがプレースホルダコンテンツを見る時間を短縮します。

00:16:14.000 --> 00:16:18.000
これが私たちのアプリでどのように見えるかを見てみましょう。

00:16:18.000 --> 00:16:22.000
大丈夫に見えますが、スクロール中に目に見えるヒッチがあります。

00:16:22.000 --> 00:16:27.000
また、新しい画像が表示されるときと一致しているように見えます。

00:16:27.000 --> 00:16:30.000
新しいセルが準備されると、ヒッチングはありません。

00:16:30.000 --> 00:16:36.000
ヒッチハイクするのは、画像がフル解像度の画像で更新されたときだけです。

00:16:36.000 --> 00:16:47.000
これは、すべての画像が表示のためにデコードするのに時間がかかり、より大きな非プレースホルダ資産のような一部の画像は、表示に間に合うようにデコードするには大きすぎるからです。

00:16:47.000 --> 00:17:00.000
セル登録の構成ハンドラが最初に呼び出され、アセットがプレースホルダである場合、コードはフルサイズイメージの非同期要求を開始し、その構成を完了します。

00:17:00.000 --> 00:17:08.000
アセットが後で最終的にダウンロードされると、セル構成ハンドラは最終的なイメージで再実行されます。

00:17:08.000 --> 00:17:16.000
画像ビューが新しい画像をコミットしようとすると、まずメインスレッドに表示するために画像を準備する必要があります。

00:17:16.000 --> 00:17:21.000
これには長い時間がかかることがあり、アプリがコミット期限に間に合わなかったときにヒッチがあります。

00:17:21.000 --> 00:17:30.000
画像の準備は、すべての画像を表示するために受けなければならない必須のプロセスです。

00:17:30.000 --> 00:17:37.000
レンダリングサーバーは、ビットマップである画像のみを表示できます。つまり、生のピクセルデータです。

00:17:37.000 --> 00:17:48.000
画像はPNG、HEIC、JPEGなど、さまざまな形式で表示され、表示するには処理して解凍する必要があります。

00:17:48.000 --> 00:17:55.000
画像ビューは、新しい画像をコミットするときにこの処理を行い、メインスレッドで発生します。

00:17:55.000 --> 00:18:03.000
理想的には、画像を事前に準備し、最終的に完成したときにのみUIを更新することができます。

00:18:03.000 --> 00:18:08.000
そうすれば、メインスレッドをブロックしたり、ヒッチしたりしません。

00:18:08.000 --> 00:18:17.000
iOS 15では、画像準備APIを導入し、画像準備がいつどこで行われるかを制御できます。

00:18:17.000 --> 00:18:24.000
これらのAPIは、レンダラーが必要とするピクセルデータのみを含む新しいUIImageを生成します。

00:18:24.000 --> 00:18:29.000
画像ビューに設定すると、追加の作業は必要ありません。

00:18:29.000 --> 00:18:41.000
任意のスレッドで実行できる同期形式と、内部UIKitシリアルキューで実行できる非同期形式の2つの形式があります。

00:18:41.000 --> 00:18:48.000
それを使用するには、作成したUIImageを取り、画像ビューにプレースホルダ画像を設定します。

00:18:48.000 --> 00:18:55.000
次に、新しいAPIを呼び出すと、大きな画像のバックグラウンドで準備が開始されます。

00:18:55.000 --> 00:18:59.000
完了したら、画像ビューで設定するだけです。

00:18:59.000 --> 00:19:07.000
準備された画像は、画像の多いアプリで大きな問題を解決しますが、いくつかの考慮事項も付属しています。

00:19:07.000 --> 00:19:12.000
準備された画像には、元の画像の生のピクセルデータが含まれています。

00:19:12.000 --> 00:19:18.000
メモリに保持されている限り、画像ビューで自由に表示できます。

00:19:18.000 --> 00:19:23.000
しかし、これはまた、多くのメモリを占有し、控えめにキャッシュする必要があることを意味します。

00:19:23.000 --> 00:19:28.000
最後に、そのフォーマットのため、ディスクストレージには理想的ではありません。

00:19:28.000 --> 00:19:32.000
代わりに、元のアセットをディスクに保存します。

00:19:32.000 --> 00:19:37.000
最後の考慮事項は、画像の準備がプリフェッチをどのように活用できるかです。

00:19:37.000 --> 00:19:42.000
プリフェッチは、画像をダウンロードして準備するための余分な時間を与えます。

00:19:42.000 --> 00:19:51.000
プロセスにより多くの時間を与えることは、ユーザーがプレースホルダを長く見ず、おそらくまったく見ないことを意味します。

00:19:51.000 --> 00:19:56.000
サンプルアプリには、画像検索用の非同期パスがすでにあります。

00:19:56.000 --> 00:20:03.000
ダウンロードが完了したら、完了ハンドラを呼び出す前にアセットを準備できます。

00:20:03.000 --> 00:20:10.000
これらの資産は大きいだけでなく、貴重なので、画像が準備されたら、それをキャッシュしたいです。

00:20:10.000 --> 00:20:16.000
画像キャッシュは、画像のサイズを使用して、準備された画像のメモリ使用量を推定します。

00:20:16.000 --> 00:20:23.000
さて、セルがアセットを要求すると、サーバーから取得する前にそのキャッシュをチェックします。

00:20:23.000 --> 00:20:27.000
もっと小さい画像があれば、もっとキャッシュできるだろう。

00:20:27.000 --> 00:20:36.000
画像は大きくなる可能性があり、iOS 15では、画像のサムネイルを準備するための同様のAPIが導入されています。

00:20:36.000 --> 00:20:40.000
これらは、より小さなサイズに画像を拡大縮小して準備することができます。

00:20:40.000 --> 00:20:51.000
画像が宛先サイズを念頭に置いて読み取られ、処理されることを保証し、多くのCPU時間とメモリを節約します。

00:20:51.000 --> 00:20:55.000
画像準備APIと同じように使用します。

00:20:55.000 --> 00:21:00.000
まず、UIImageを取り、画像ビューにプレースホルダ画像を設定します。

00:21:00.000 --> 00:21:08.000
次に、ビューのサイズをサムネイルのターゲットサイズとして、新しいサイズ変更APIを呼び出します。

00:21:08.000 --> 00:21:13.000
準備ができたら、新しいサムネイルで画像ビューを更新するだけです。

00:21:13.000 --> 00:21:22.000
画像準備APIに加えて、iOS 15のどのアプリでも画像を高速化し、ヒッチを回避する方がはるかに簡単です。

00:21:22.000 --> 00:21:31.000
画像を扱うときは、画像の準備ができたらUIを更新できる非同期APIを持つことに集中してください。

00:21:31.000 --> 00:21:38.000
それまでの間、同期的に表示できるほど小さいか安価なプレースホルダ画像を使用してください。

00:21:38.000 --> 00:21:49.000
プリフェッチとreconfigureItemsで使用すると、コレクションとリストビューに非同期コンテンツを表示することは、かつてないほど簡単でパフォーマンスを発揮します。

00:21:49.000 --> 00:21:58.000
高速コレクションとテーブルビューを開始するには、まずiOS 15 SDKを使用してアプリを構築し、多くの新しい最適化のロックを解除します。

00:21:58.000 --> 00:22:06.000
特に、新しいプリフェッチでコレクションとテーブルビューの動作を検証してください。

00:22:06.000 --> 00:22:11.000
ここで示されているすべての新しいAPIは、この講演のサンプルコードで見つけることができます。

00:22:11.000 --> 00:22:17.000
それをチェックして、アプリ全体で画像の準備とサイズ変更のAPIを採用するようにしてください。

00:22:17.000 --> 00:22:22.000
これにより、コレクションとテーブルビューが高速になります。

00:22:22.000 --> 00:22:23.000
見てくれてありがとう。

00:22:23.000 --> 23:59:59.000
[明るい音楽]。

