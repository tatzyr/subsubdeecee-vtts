WEBVTT

00:00:02.000 --> 00:00:12.000
- こんにちは！WWDCへようこそ。

00:00:12.000 --> 00:00:17.000
私の名前はアン・ヒッチコックで、Watch Frameworksチームのエンジニアです。

00:00:17.000 --> 00:00:24.000
今日ここに来て、Apple Watchのデータ転送戦略について話すことに興奮しています。

00:00:24.000 --> 00:00:29.000
導入以来、Apple Watchはますます独立しています。

00:00:29.000 --> 00:00:35.000
シリーズ3は、携帯電話機能を備えた最初のApple Watchでした。

00:00:35.000 --> 00:00:47.000
watchOS 6の独立した時計アプリは、iOSコンパニオンを必要とせず、顧客の時計のApp Storeから購入できるアプリを書く機能を提供しました。

00:00:47.000 --> 00:00:56.000
watchOS 7でのファミリーセットアップの導入により、お客様はコンパニオンiPhoneを持っていなくても、これまで以上に自立しています。

00:00:56.000 --> 00:01:05.000
しかし、これらの新機能は、開発者として、Watchアプリとのコミュニケーションに関する考え方に新たな課題を提示します。

00:01:05.000 --> 00:01:09.000
幸いなことに、私たちには素晴らしい選択肢がたくさんあります。

00:01:09.000 --> 00:01:16.000
今日は、これらのオプションと、その仕事に適したものを選ぶ方法について話します。

00:01:16.000 --> 00:01:27.000
Watchアプリでのデータ通信のためのツールの概要を説明し、どれがタスクに適した選択になるかを評価する方法について説明します。

00:01:27.000 --> 00:01:31.000
ツールをいくつかのカテゴリに大きく分類できます。

00:01:31.000 --> 00:01:37.000
iCloudを使用すると、すべてのデバイスと共有でき、サーバーストレージを提供します。

00:01:37.000 --> 00:01:46.000
iCloud同期のKeychainとCloudKitのCoreDataを使用して、アプリでこれを使用できます。

00:01:46.000 --> 00:01:54.000
ペアリングされたデバイス間でデータを転送する必要がある場合は、Watch Connectivityを使用できます。

00:01:54.000 --> 00:02:01.000
サーバーと直接通信するには、URLセッションまたはソケットを使用できます。

00:02:01.000 --> 00:02:08.000
しかし、まず、あなたが正しいものを選ぶために尋ねることができる質問について話します。

00:02:08.000 --> 00:02:14.000
Watchアプリからどのようにコミュニケーションをとるかを考えるとき、いくつかのことを考えます。

00:02:14.000 --> 00:02:17.000
それはどんな種類のデータですか?

00:02:17.000 --> 00:02:21.000
そして、データは今どこにあり、どこにそれが必要ですか?

00:02:21.000 --> 00:02:26.000
インタラクションはコンパニオンiOSアプリに依存していますか?

00:02:26.000 --> 00:02:30.000
ファミリー設定をサポートしたいですか?

00:02:30.000 --> 00:02:33.000
そして、データはいつ目的地にある必要がありますか?

00:02:33.000 --> 00:02:39.000
システムが顧客のパフォーマンスとバッテリー使用量を最適化するのを待つことができますか?

00:02:39.000 --> 00:02:43.000
データはどのくらいの頻度で変更されますか?

00:02:43.000 --> 00:02:53.000
これらの質問に対する私の答えに基づいて、私はデータ転送タスクのための適切なソリューションを作成する方法を評価するために私のツールボックスを通過し始めることができます。

00:02:53.000 --> 00:03:00.000
iCloud同期でキーチェーンから得られる機能を見てみましょう。

00:03:00.000 --> 00:03:07.000
キーチェーンは、パスワード、キー、その他の機密性の高い資格情報のための安全なストレージを提供します。

00:03:07.000 --> 00:03:18.000
また、watchOS 6.2で導入されたiCloudキーチェーン同期により、これらのキーチェーンアイテムを人のすべてのデバイスに同期させることができます。

00:03:18.000 --> 00:03:30.000
アプリでiCloud同期の恩恵を受けるには、関連するドメインと共有キーチェーンアイテムでパスワードの自動入力を使用する2つの方法があります。

00:03:30.000 --> 00:03:37.000
パスワードの自動入力により、非常に少ないコードでキーチェーン同期を使用できます。

00:03:37.000 --> 00:03:42.000
まず、関連ドメイン機能をターゲットに追加します。

00:03:42.000 --> 00:03:47.000
Watchアプリでは、WatchKit Extension Targetに機能を追加します。

00:03:47.000 --> 00:03:52.000
ドメイン名でwebcredentialsエントリを追加します。

00:03:52.000 --> 00:03:58.000
Apple-app-site-associationファイルをウェブサーバーに追加します。

00:03:58.000 --> 00:04:02.000
ファイルは、リダイレクトなしでHTTPS経由でアクセス可能でなければなりません。

00:04:02.000 --> 00:04:12.000
ファイルはファイル拡張子のないJSON形式であり、サーバーの./well-knownディレクトリに配置する必要があります。

00:04:12.000 --> 00:04:20.000
詳細については、「関連ドメインのサポート」のオンラインドキュメントをご覧ください。

00:04:20.000 --> 00:04:24.000
テキストフィールドと安全なフィールドにテキストコンテンツタイプを追加します。

00:04:24.000 --> 00:04:32.000
自動入力のオプションは、ユーザー名、メールアドレス、パスワード、および新しいパスワードです。

00:04:32.000 --> 00:04:41.000
新しいパスワードの場合、システムは人に保存するように促し、サイトのキーチェーンにレコードが追加または更新されます。

00:04:41.000 --> 00:04:52.000
自動入力の提案は、watchOS 6.2から利用可能であり、watchOS 8の新しいテキスト編集体験でさらに優れています。

00:04:52.000 --> 00:05:03.000
パスワードの自動入力の使用の詳細については、Developerアプリまたはオンラインで「どこでも自動入力」セッションをチェックしてください。

00:05:03.000 --> 00:05:12.000
キーチェーン同期を使用してデータを共有するもう1つの方法は、アプリ間でキーチェーンアイテムを共有することです。

00:05:12.000 --> 00:05:20.000
議論したように、キーチェーンは、パスワード、キー、資格情報などの機密データのための安全なストレージです。

00:05:20.000 --> 00:05:32.000
情報が頻繁に変更されない限り、起動画面に対する人の好みなど、他の小さな共有データをキーチェーンに保存することもできます。

00:05:32.000 --> 00:05:38.000
キーチェーンに保存されているデータは、その人のすべてのデバイスに同期されます。

00:05:38.000 --> 00:05:46.000
キーチェーンにOAuth 2トークンを保存して取得し、それをアプリのグループと共有する方法を見てみましょう。

00:05:46.000 --> 00:05:55.000
まず、キーチェーン共有またはアプリグループ機能、これらのキーチェーンアイテムを共有したいすべてのアプリを追加する必要があります。

00:05:55.000 --> 00:06:05.000
これはアイテムを共有するために必要であり、他のアプリによるアクセスを防ぐことで、顧客の情報のセキュリティとプライバシーを確保するのに役立ちます。

00:06:05.000 --> 00:06:10.000
Watchアプリでは、Watch Extensionターゲットに機能を追加します。

00:06:10.000 --> 00:06:17.000
この例では、キーチェーン共有機能を追加し、アプリをキーチェーングループに追加します。

00:06:17.000 --> 00:06:24.000
キーチェーンアイテムを共有するすべてのアプリは、このグループも共有する必要があります。

00:06:24.000 --> 00:06:29.000
では、OAuth 2トークンをキーチェーンに保存するコードを見てみましょう。

00:06:29.000 --> 00:06:35.000
トークンを保存するには、アイテムが存在する場合はアイテムを更新し、存在しない場合は追加します。

00:06:35.000 --> 00:06:44.000
トークン文字列、有効期限、リフレッシュトークンなどのトークンデータを含むOAuth 2トークン構造体を作成しました。

00:06:44.000 --> 00:06:50.000
保存と取得を容易にするために、トークン構造体をcodableに適合させました。

00:06:50.000 --> 00:06:52.000
クエリ辞書を作成します。

00:06:52.000 --> 00:07:00.000
これは、このサーバーとアカウント用にすでに保存されている場合、既存のアイテムに一致する属性のセットです。

00:07:00.000 --> 00:07:05.000
ここで「true」に設定されている同期可能な属性に注意してください。

00:07:05.000 --> 00:07:14.000
アイテムをお客様のすべてのデバイスに同期させたいことを示すために、この属性をクエリに含めることが重要です。

00:07:14.000 --> 00:07:21.000
トークンをデータとしてエンコードし、そのデータを属性辞書のキーチェーンアイテムの値として設定します。

00:07:21.000 --> 00:07:27.000
次に、クエリと属性でキーチェーンのアイテムを更新します。

00:07:27.000 --> 00:07:32.000
キーチェーンAPIから返された結果コードを常に確認する必要があります。

00:07:32.000 --> 00:07:37.000
まず、キーチェーンにアイテムが見つからないと表示されているかどうかを確認します。

00:07:37.000 --> 00:07:42.000
もしそうなら、私たちが書いた別の関数を呼び出して、それをキーチェーンに追加します。

00:07:42.000 --> 00:07:45.000
私たちはすぐにそれを見ます。 

00:07:45.000 --> 00:07:48.000
それ以外の場合は、エラーがなかったことを確認します。

00:07:48.000 --> 00:07:52.000
そのためには、成功結果を確認します。

00:07:52.000 --> 00:07:59.000
更新機能が成功を返した場合、トークンはキーチェーンで更新されました。

00:07:59.000 --> 00:08:02.000
では、追加機能を見てみましょう。

00:08:02.000 --> 00:08:07.000
キーチェーンにトークンを追加するには、すべての属性を持つ辞書を設定します。

00:08:07.000 --> 00:08:14.000
これには、既存のアイテムを見つけるために使用した属性とトークンデータが含まれます。

00:08:14.000 --> 00:08:19.000
次に、キーチェーンAPIの追加関数を属性で呼び出します。

00:08:19.000 --> 00:08:25.000
そして、リターンコードをチェックして、それが成功したことを確認してください。

00:08:25.000 --> 00:08:32.000
キーチェーンからトークン情報を取得するには、必要なアイテムを見つけるためにクエリ辞書を設定します。

00:08:32.000 --> 00:08:39.000
更新機能で以前にアイテムを見つけるために含めたのと同じキーと値のセットを含めます。

00:08:39.000 --> 00:08:52.000
さらに、アイテム属性を返すかどうか（返さない）、アイテムデータを返すかどうか（返す）かどうかをキーチェーンAPIに伝えるために、いくつかの属性が含まれています。

00:08:52.000 --> 00:09:02.000
キーチェーンの「コピーマッチング」関数は、クエリを使用して検索し、提供した参照を「アイテム」として入力します。

00:09:02.000 --> 00:09:09.000
取得したアイテムにアクセスする前に、返品コードが見つかったことを確認します。

00:09:09.000 --> 00:09:14.000
その後、いつものように、リターンコードが成功することを確認します。

00:09:14.000 --> 00:09:25.000
アイテムにコピーされた辞書を取得し、辞書から要求したトークンデータを取得し、データをOAuth 2トークンタイプとしてデコードします。

00:09:25.000 --> 00:09:38.000
そして今、OAuth 2トークンをキーチェーンに正常に保存、更新、取得し、キーチェーン共有グループのすべてのアプリと共有されています。

00:09:38.000 --> 00:09:43.000
あなたと共有したいキーチェーンストレージ機能がもう1つあります。

00:09:43.000 --> 00:09:50.000
顧客のデバイスに何かを保存する場所と同じように、それが終わったら削除する必要があります。

00:09:50.000 --> 00:09:56.000
検索するために、現在馴染みのある属性でクエリを設定します。

00:09:56.000 --> 00:10:01.000
クエリでキーチェーンAPIの削除関数を呼び出します。

00:10:01.000 --> 00:10:04.000
そして、いつものように、成功を確認してください。

00:10:04.000 --> 00:10:08.000
削除の場合、見つかりません。

00:10:08.000 --> 00:10:13.000
さて、データが終わったらクリーンアップを終えます。

00:10:13.000 --> 00:10:27.000
iCloudキーチェーン同期を備えたキーチェーンサービスは、アプリが頻繁に変更されない小さなデータを共有するための素晴らしい方法であり、そのデータは人のすべてのデバイスに同期されます。

00:10:27.000 --> 00:10:34.000
関連ドメインを使用すると、アプリにパスワードの自動入力機能を簡単に追加できます。

00:10:34.000 --> 00:10:43.000
また、キーチェーンに直接値を保存して取得し、キーチェーン共有またはアプリグループを使用して他のアプリと共有することもできます。

00:10:43.000 --> 00:10:53.000
iCloudキーチェーンの同期は、iOSコンパニオンアプリに依存せず、ファミリー設定をサポートしています。

00:10:53.000 --> 00:11:01.000
アイテムは、ネットワークの可用性、バッテリー、その他のシステム条件に基づいて、可能な限り同期されます。

00:11:01.000 --> 00:11:10.000
お客様はiCloudキーチェーンの同期を無効にすることができ、すべての地域で利用できるわけではないことに注意してください。

00:11:10.000 --> 00:11:20.000
CloudKitを使用したCoreDataは、ローカルデータベースを、アプリのCloudKitコンテナを共有する顧客の他のすべてのデバイスに同期します。

00:11:20.000 --> 00:11:29.000
CoreDataとSwiftUIの統合により、Watchアプリケーション内のデータベースからのデータへのアクセスと表示が簡素化されます。

00:11:29.000 --> 00:11:36.000
マルチプラットフォームアプリケーションを開発している場合は、この方法でWatchであまりにも多くのデータをすばやく取得できます。

00:11:36.000 --> 00:11:44.000
顧客が時計で本当に必要とする情報を慎重に考えてください。

00:11:44.000 --> 00:12:00.000
コアデータモデルで複数の構成を使用して、より多くのストレージとバッテリー容量を持つデバイスで実行されているアプリに適したデータから、Watchアプリに持つことが理にかなっているデータをセグメント化することを検討してください。

00:12:00.000 --> 00:12:03.000
CloudKitとコアデータは強力なツールです。

00:12:03.000 --> 00:12:11.000
Core DataとSwiftUIの統合により、アプリでCore Data機能の使用が容易になります。

00:12:11.000 --> 00:12:22.000
管理オブジェクトコンテキスト」を環境値でビューに提供し、フェッチリクエストプロパティラッパーを使用してデータベースから結果を取得できます。

00:12:22.000 --> 00:12:28.000
これらの結果は、SwiftUIリストやその他のビューで使用できます。

00:12:28.000 --> 00:12:38.000
CloudKitを使用したコアデータは、すべてのデバイスに同期し、iCloudにバックアップできる構造化データを共有する方法を提供します。

00:12:38.000 --> 00:12:45.000
コンパニオンiPhoneアプリに依存せず、ファミリー設定をサポートしています。

00:12:45.000 --> 00:12:51.000
コアデータの変更の同期は、ネットワークの可用性とシステム条件に基づいて行われます。

00:12:51.000 --> 00:13:00.000
瞬間的であることを期待しないでくださいが、CloudKitはアプリのこの同期のパフォーマンスの最適化を処理します。

00:13:00.000 --> 00:13:19.000
アプリでCloudKitでCore Dataを使用する方法の詳細については、Developerアプリまたはオンラインの「Build apps that share data through CloudKit and Core Data」と「Bring Core Data concurrency to Swift and SwiftUI」をチェックしてください。

00:13:19.000 --> 00:13:25.000
あなたはすでにWatch Connectivityに精通しているかもしれませんし、以前に使用したことがあるかもしれません。

00:13:25.000 --> 00:13:32.000
しかし、私はあなたが成功するのを助けるために、より多くの詳細といくつかのベストプラクティスを提供したいと思います。

00:13:32.000 --> 00:13:44.000
Watch Connectivityを使用すると、両方のデバイスがBluetooth範囲内または同じWi-Fiネットワーク上にある場合、WatchアプリとそのコンパニオンiPhoneアプリ間でデータを送信できます。

00:13:44.000 --> 00:13:57.000
携帯電話とWatchアプリの両方がインストールされている場合に、顧客体験を最適化し、1つのデバイスでしか利用できないデータを共有するのに最適です。

00:13:57.000 --> 00:14:12.000
たとえば、誰かがiPhoneアプリを起動し、最新のデータをダウンロードした場合、そのデータをWatchアプリと共有して、合併症を最新の状態に保ち、Watchアプリが次回起動時に同じデータで開始できるようにすることができます。

00:14:12.000 --> 00:14:20.000
これにより、顧客にとってより反応が良くなり、アプリが行う必要がある重複したデータのダウンロードを最小限に抑えることができます。

00:14:20.000 --> 00:14:28.000
ウォッチコネクティビティには多様な機能があるので、何が利用可能で、いつそれぞれを使うべきかを知ると便利です。

00:14:28.000 --> 00:14:38.000
しかし、まず、Watch Connectivityがタスクに適したツールであると判断した場合、成功に役立ついくつかのヒントを共有したいと思います。

00:14:38.000 --> 00:14:47.000
Watch Connectivityは2つのデバイス間で通信するためのツールであるため、いくつかの前提条件について知り、いくつかのエラーを処理する必要があります。

00:14:47.000 --> 00:14:53.000
これらは、ウォッチコネクティビティ通信がスムーズに機能するようにするためにできることです。

00:14:53.000 --> 00:15:04.000
アプリのライフサイクルの早い段階で、できればアプリまたは拡張機能デリゲートでアプリの起動が終了したら、時計接続セッションをアクティブにします。

00:15:04.000 --> 00:15:10.000
これにより、アプリはできるだけ早く対応するアプリから情報を受信できるようになります。

00:15:10.000 --> 00:15:13.000
到達可能性を理解する。

00:15:13.000 --> 00:15:19.000
バックグラウンド通信のいずれも、データを送信するときに相手のアプリに到達可能である必要はありません。

00:15:19.000 --> 00:15:25.000
しかし、インタラクティブメッセージングには到達可能性の要件があり、その後それらについて説明します。

00:15:25.000 --> 00:15:29.000
それらを理解する時間を節約できます。

00:15:29.000 --> 00:15:34.000
すべてのウォッチ接続セッションデリゲート関数は、非メインのシリアルキューで呼び出されます。

00:15:34.000 --> 00:15:43.000
ユーザーインターフェイスを更新するためにこれらの機能から作業を行う必要がある場合は、メインキューで行うようにしてください。

00:15:43.000 --> 00:15:49.000
さて、さまざまなWatch接続機能と、それぞれを使用するタイミングについて話しましょう。

00:15:49.000 --> 00:16:00.000
アプリケーションコンテキストは、バックグラウンドで対応するアプリに送信される単一のプロパティリスト辞書であり、アプリが起動したときに利用可能になることを目的としています。

00:16:00.000 --> 00:16:08.000
前の辞書が送信される前にアプリケーションコンテキストを更新すると、新しい値に置き換えられます。

00:16:08.000 --> 00:16:18.000
アプリケーションコンテキストは、新しいデータがあるときに、対応するアプリのコンテンツを最新の状態に保つことや、頻繁に更新される可能性のあるデータに役立ちます。

00:16:18.000 --> 00:16:28.000
ユーザー情報転送は、バックグラウンドで対応するアプリにプロパティリスト辞書も送信しますが、アプリケーションコンテキストとは少し異なります。

00:16:28.000 --> 00:16:40.000
更新するたびに置き換えられる単一の辞書ではなく、各ユーザー情報辞書の転送はキューに入れられ、キューに入れた順序で配信されます。

00:16:40.000 --> 00:16:44.000
キューにアクセスして転送をキャンセルすることもできます。

00:16:44.000 --> 00:16:52.000
ファイル転送はユーザー情報転送に似ており、一度行うと、もう一方は身近に感じるでしょう。

00:16:52.000 --> 00:16:58.000
ファイルは、対応するアプリに送信されるキューに入れられ、電源やその他の条件が許せば送信されます。

00:16:58.000 --> 00:17:03.000
キューにアクセスして転送をキャンセルできます。

00:17:03.000 --> 00:17:09.000
ファイルは、転送されると、受信アプリのドキュメント受信トレイに配置されます。

00:17:09.000 --> 00:17:17.000
セッションデリゲートで受信したファイルコールバックから戻ると、各ファイルは受信トレイから削除されます。

00:17:17.000 --> 00:17:24.000
この方法から戻る前に、必ずファイルを移動するか、すぐに処理してください。

00:17:24.000 --> 00:17:41.000
これについて覚えておくべき1つの役に立つこと：このコールバックは非メインのシリアルキューで呼び出されるため、受信トレイからファイルを処理するために非同期メソッドを呼び出すと、ファイルがなくなるため、問題が発生する可能性が最も高いです。

00:17:41.000 --> 00:17:50.000
ファイル転送のタイミングはシステム条件に基づいており、もちろん、より大きなファイルは転送に時間がかかる場合があります。

00:17:50.000 --> 00:18:00.000
transferCurrentComplicationUserInfo(_:)は、コンプリケーション関連のデータをWatchに送信するユーザー情報転送機能の特別なケースです。

00:18:00.000 --> 00:18:11.000
予算に複雑な転送が残っている限り、他のユーザー情報の転送に先立って、できるだけ早く転送されます。

00:18:11.000 --> 00:18:20.000
この即時転送により、携帯電話からデータを更新したときに、アクティブなコンプリケーションを顧客の最新の状態に保つことができます。

00:18:20.000 --> 00:18:28.000
残りの予算を確認できますが、残りの予算なしで現在の合併症情報を転送しても、まだ送信されます。

00:18:28.000 --> 00:18:34.000
通常のユーザー情報転送キューを使用するだけです。

00:18:34.000 --> 00:18:39.000
sendMessageを使用して、相手のアプリにデータを送信し、返信を受け取ることができます。

00:18:39.000 --> 00:18:44.000
これは、相手のアプリが到達可能な場合のインタラクティブなメッセージング用です。

00:18:44.000 --> 00:18:49.000
辞書やデータを送信する場合でも、メッセージを小さくしてください。

00:18:49.000 --> 00:18:55.000
また、sendMessageコールに返信ハンドラを含めることを選択することをお勧めします。

00:18:55.000 --> 00:19:02.000
短い返信で、相手のアプリがメッセージを受信し、データが正しかったことを確認できます。

00:19:02.000 --> 00:19:17.000
sendMessageにその返信ハンドラを含める場合は、返信ハンドラを含む相手アプリで、受信したメッセージまたは受信したデータデリゲートコールバック機能のバージョンを実装していることを確認してください。

00:19:17.000 --> 00:19:22.000
そうしないと、メッセージを送信するときにエラーが発生します。

00:19:22.000 --> 00:19:28.000
sendMessageについて聞いたので、到達可能性の概念を再検討しましょう。

00:19:28.000 --> 00:19:32.000
メッセージを送信するには、両方のアプリに到達可能である必要があります。

00:19:32.000 --> 00:19:42.000
Watch ConnectivityセッションでisReachableプロパティをチェックして、相手のアプリがライブの非バックグラウンドメッセージングに到達できるかどうかを判断できます。

00:19:42.000 --> 00:19:46.000
しかし、到達可能とはどういう意味ですか?

00:19:46.000 --> 00:19:54.000
両方のデバイスは、Bluetoothを介して、または同じWi-Fiネットワーク上にある必要があります。

00:19:54.000 --> 00:20:07.000
WatchKit拡張機能に到達可能になるには、長時間実行されるバックグラウンドセッションを実行する場合と同様に、フォアグラウンドで実行するか、優先度の高いバックグラウンドで実行する必要があります。

00:20:07.000 --> 00:20:12.000
iOSアプリには、このフォアグラウンド要件はありません。

00:20:12.000 --> 00:20:23.000
WatchアプリからiOSアプリにメッセージを送信し、iOSアプリがフォアグラウンドにない場合、iOSアプリはメッセージを受信するためにバックグラウンドでアクティブになります。

00:20:23.000 --> 00:20:31.000
これは、iOSアプリがWatch Extensionからはるかに多くアクセスできることを意味します。

00:20:31.000 --> 00:20:43.000
Watch Connectivityは、iPhoneとWatchアプリの両方をインストールしたときに、タイムリーで応答性があり、直感的に感じられる体験を顧客に提供するための良い方法です。

00:20:43.000 --> 00:20:53.000
ウォッチコネクティビティは、特に電話とペアリングされたウォッチの間で通信しているため、ファミリーセットアップのアプリをサポートするために使用しないでください。

00:20:53.000 --> 00:21:00.000
データ転送は、BluetoothまたはWi-Fiを介したコンパニオンデバイスの可用性に依存します。

00:21:00.000 --> 00:21:05.000
sendMessageを使用したリアルタイム通信では、相手が到達可能である必要があります。

00:21:05.000 --> 00:21:13.000
特にWatchアプリと通信しようとしているときは、相手のアプリにはあまり連絡が取れないことを覚えておいてください。

00:21:13.000 --> 00:21:16.000
バックグラウンド転送はすぐには配信されません。

00:21:16.000 --> 00:21:25.000
手紙を投稿するように考えてください。箱に落としますが、いつそこにあるのか正確にはわかりません。

00:21:25.000 --> 00:21:34.000
ウォッチコネクティビティの詳細については、開発者アプリまたはオンラインで「ウォッチコネクティビティの紹介」をご覧ください。

00:21:34.000 --> 00:21:41.000
次に、サーバーと直接通信するいくつかの方法について話します。

00:21:41.000 --> 00:21:46.000
ほとんどのユースケースでは、最適なオプションはURLセッションです。

00:21:46.000 --> 00:21:54.000
インタラクションとデータの種類によっては、コミュニケーションを延期したり、すぐに行う必要があるかもしれません。

00:21:54.000 --> 00:22:02.000
そのため、URLセッションをバックグラウンドまたはフォアグラウンドで実行できるように、URLセッションには異なる設定があります。

00:22:02.000 --> 00:22:06.000
これらの各オプションをいつ使用すべきかを見てみましょう。

00:22:06.000 --> 00:22:10.000
可能な限りバックグラウンドセッションを使用する必要があります。

00:22:10.000 --> 00:22:18.000
これは開発者としての最初の本能ではないかもしれませんが、すぐにデータを取得または送信したいと思うかもしれません。

00:22:18.000 --> 00:22:21.000
しかし、本当にそれについて考えてください。

00:22:21.000 --> 00:22:30.000
フォアグラウンドセッションは、アプリがフォアグラウンドまたは最前面にある間に完了する必要があり、最短のタスクを除くすべてのタスクでは、これは十分な時間ではありません。

00:22:30.000 --> 00:22:36.000
コミュニケーションタスクが失敗した場合、顧客の体験について考えてください。

00:22:36.000 --> 00:22:45.000
だから、顧客に配慮し、各コミュニケーションタスクを慎重に評価し、「バックグラウンドでこれを行うことはできますか?」と尋ねてください。

00:22:45.000 --> 00:22:54.000
バックグラウンドURLセッションは、通信が遅れる可能性のある時間や大規模なデータ転送のための正しい選択です。

00:22:54.000 --> 00:23:02.000
また、アプリにプッシュ通知を送信して、新しいデータが利用可能であることを示し、バックグラウンド更新を開始することもできます。

00:23:02.000 --> 00:23:08.000
バックグラウンド転送の正確なタイミングは、システム条件によって異なります。

00:23:08.000 --> 00:23:12.000
バックグラウンドでサーバーにデータを送信する例を見てみましょう。

00:23:12.000 --> 00:23:28.000
たとえば、Webサーバーを介して保存したいアプリケーションの設定がある場合は、顧客がそれらを保存したときに、ウォッチに保存し、バックグラウンドでサーバーに送信できます。

00:23:28.000 --> 00:23:36.000
これを行うには、サーバー通信の作業を処理するためのバックグラウンドURLセッションクラスを作成しました。

00:23:36.000 --> 00:23:44.000
私たちのURLセッションには、後でそれを見つけるために使用できる一意の識別子を持つバックグラウンド設定があります。

00:23:44.000 --> 00:23:57.000
セッションのタスクを処理する必要があるときに、セッションがバックグラウンドでアプリを起動する必要があることを示すために、seds launch eventsプロパティをtrueに設定します。

00:23:57.000 --> 00:24:14.000
大量のデータを転送する場合は、URLセッション設定のisDiscretionaryプロパティをtrueに設定して、システムが最良のパフォーマンスを得るためにデバイスに最適なタイミングで転送をスケジュールできるようにする必要があります。

00:24:14.000 --> 00:24:25.000
この場合、Wi-Fiと電源に接続されるまでダウンロードが起こらない可能性があることを顧客に知らせる必要があります。

00:24:25.000 --> 00:24:32.000
データを送信する準備ができたら、バックグラウンドセッションをスケジュールするために転送をキューに入れる必要があります。

00:24:32.000 --> 00:24:41.000
サーバーへの設定更新の内容を含むURLリクエストを作成して設定します。

00:24:41.000 --> 00:24:45.000
次に、セッションでリクエストのタスクを作成します。

00:24:45.000 --> 00:24:55.000
この簡略化された例では、セッションに1つのタスクを追加するだけですが、効率のためにセッションに複数のリクエストを追加できます。

00:24:55.000 --> 00:24:59.000
後でダウンロードを開始するには、最も早いBeginDateを設定します。

00:24:59.000 --> 00:25:07.000
システムは、バックグラウンド予算、ネットワーク、およびシステム条件に基づいて、タスクの実際の開始時間を決定することに注意してください。

00:25:07.000 --> 00:25:23.000
アクティブな文字盤に合併症がある場合、アプリは1時間あたり最大4つのバックグラウンドリフレッシュタスクを受け取ることができるので、システムによって遅れないように、少なくとも15分間隔でタスクをスケジュールしてください。

00:25:23.000 --> 00:25:27.000
進行中のセッションのリストでこのセッションを保持しています。 

00:25:27.000 --> 00:25:34.000
これは、システムが私のURLリクエストが完了したことを私に知らせるとき、後で重要になります。

00:25:34.000 --> 00:25:41.000
タスクで「再開」を呼び出すと、実際に開始されるので、これを呼び出すことが重要です。

00:25:41.000 --> 00:25:48.000
最後に、セッションのオブザーバーがいる場合に備えて、ステータスをキューに入れるように設定しました。

00:25:48.000 --> 00:25:56.000
拡張デリゲートに送信されたバックグラウンドタスクを使用して、バックグラウンドリクエストが処理されると、システムはアプリに通知します。

00:25:56.000 --> 00:26:09.000
そのタスクを処理するには、WK拡張デリゲートに準拠したクラスを作成し、handle(_ backgroundTasks:)関数を実装する必要があります。

00:26:09.000 --> 00:26:18.000
バックグラウンドURLセッションの更新タスクでは、進行中のリクエストのリストでセッションを見つけようとします。

00:26:18.000 --> 00:26:31.000
それがあれば、セッションの関数を呼び出すと、セッションのリストにバックグラウンド更新タスクが追加されます。そうすれば、データの処理が終了したらすぐに完了したことをシステムに知らせることができます。

00:26:31.000 --> 00:26:34.000
すぐにお見せします。

00:26:34.000 --> 00:26:39.000
リストにセッションが見つからない場合は、タスクを完了としてマークする必要があります。

00:26:39.000 --> 00:26:46.000
完了したらすぐに完了するバックグラウンドリフレッシュタスクを常に設定することが非常に重要です。

00:26:46.000 --> 00:26:53.000
バックグラウンドタスクコールを取得するために行う必要があることがもう1つあります。拡張デリゲートをアプリに接続する必要があります。

00:26:53.000 --> 00:27:03.000
これを行うには、Extension DelegateクラスでWK拡張デリゲートアダプタープロパティラッパーを使用し、アプリにプロパティを追加します。

00:27:03.000 --> 00:27:08.000
これで、システムは拡張デリゲートを呼び、バックグラウンドタスクを処理します。

00:27:08.000 --> 00:27:16.000
拡張デリゲートでは、この関数を呼び出して、バックグラウンドタスクを既存のセッションに追加しました。

00:27:16.000 --> 00:27:25.000
このタスクをバックグラウンドタスクのリストに追加すると、URLデータの処理が完了したらすぐに完了としてマークできます。

00:27:25.000 --> 00:27:34.000
今、私たちは往復全体を配線し、私たちに残されたのは、データを取得し、私たちが終わったことをシステムに知らせることだけです。

00:27:34.000 --> 00:27:40.000
リクエストが完了すると、URLセッションのダウンロードデリゲートが呼び出されます。

00:27:40.000 --> 00:27:43.000
ダウンロードタスクからファイルで受信したデータを処理します。

00:27:43.000 --> 00:27:51.000
このアイテムをアプリからアクセス可能なディレクトリに移動するか、ファイルからデータをすばやく処理することが重要です。

00:27:51.000 --> 00:27:55.000
このタスクが完了すると、ダウンロードしたファイルは削除されます。

00:27:55.000 --> 00:28:09.000
このセッションは、拡張デリゲートからバックグラウンドタスクがこれ以上取得されないため、プロセス中のセッションのリストからこのセッションを削除し、オブザーバーがいる場合に備えてステータスを完了に設定しています。

00:28:09.000 --> 00:28:13.000
最後に、バックグラウンドタスクの完了を設定しています。

00:28:13.000 --> 00:28:17.000
これにより、バックグラウンド処理が完了したことをシステムに知らせます。

00:28:17.000 --> 00:28:22.000
これを行うことを確認することは、単に良いウォッチアプリの市民であることではありません。

00:28:22.000 --> 00:28:27.000
バックグラウンド制限を超えて、システムがアプリを終了するのを防ぎます。

00:28:27.000 --> 00:28:29.000
そして、それだけです!

00:28:29.000 --> 00:28:33.000
設定をバックグラウンドで送信し、更新を取得するのは終わりました。

00:28:33.000 --> 00:28:40.000
完全な実装では、エラーや認証の課題を処理したいと思うでしょうが、これは基本的な手順を提供します。

00:28:40.000 --> 00:28:47.000
人があなたのアプリと対話している間、迅速なサーバー通信のためにフォアグラウンドURLセッションを使用してください。

00:28:47.000 --> 00:28:54.000
これの良い例は、最新のワークアウトリストやその日の瞑想を取得することです。

00:28:54.000 --> 00:29:02.000
フォアグラウンドURLセッションは、データを取得して送信するための電力効率の低い方法であり、2分半のタイムアウトが強制されます。

00:29:02.000 --> 00:29:10.000
しかし、実際には、その制限よりもはるかに速いインタラクションにフォアグラウンドセッションをターゲットにしようとする必要があります。

00:29:10.000 --> 00:29:16.000
URLセッションは、サーバーと直接の一般的な目的の通信に最適な方法です。

00:29:16.000 --> 00:29:23.000
彼らはコンパニオンiPhoneアプリに頼らず、ファミリーセットアップをサポートするアプリで使用できます。

00:29:23.000 --> 00:29:33.000
データ転送を遅らせる可能性のある場所や、常に大量のデータを転送するために、バックグラウンドセッションを使用してください。

00:29:33.000 --> 00:29:45.000
URLセッションの詳細については、開発者アプリまたはオンラインで「コンプリケーションを最新の状態に保つ」と「バックグラウンド実行の謎を解く」をチェックしてください。

00:29:45.000 --> 00:29:55.000
URLセッションに加えて、ストリーミングオーディオアプリを構築する場合、ソケットはサーバーと直接通信する別のオプションです。

00:29:55.000 --> 00:30:03.000
アクティブなストリーミングオーディオセッションのコンテキストで、ウォッチアプリでHTTPライブストリーミングまたはWebソケットを使用できます。

00:30:03.000 --> 00:30:14.000
Socketsの使用の詳細については、Developerアプリまたはオンラインで「watchOS 6のストリーミングオーディオ」セッションをチェックしてください。

00:30:14.000 --> 00:30:21.000
私たちは多くのことをカバーしたので、私たちが見たすべてのオプションの中からどのように選択できるかをまとめましょう。

00:30:21.000 --> 00:30:31.000
すべての人のデバイスに同期できる小さな機密データについては、iCloud同期のキーチェーンを選択します。

00:30:31.000 --> 00:30:39.000
データベースをiCloudに保存し、すべての人のデバイスと共有するには、CloudKitでCore Dataを選択します。

00:30:39.000 --> 00:30:50.000
コンパニオンiPhoneとWatchアプリのエクスペリエンスを最適化するか、コンパニオンアプリで1つのデバイスでのみ利用可能なデータを共有するには、Watch Connectivityを選択します。

00:30:50.000 --> 00:30:55.000
サーバーと直接通信するには、URLセッションを選択します。

00:30:55.000 --> 00:30:59.000
ストリーミングオーディオアプリには、ソケットを使用することもできます。

00:30:59.000 --> 00:31:15.000
ファミリーセットアップを使用しているお客様、またはモバイルデータ転送を使用しているお客様をサポートするには、iCloud同期付きキーチェーン、CloudKit付きコアデータ、URLセッション、またはソケットを選択してください。

00:31:15.000 --> 00:31:25.000
仕事に適したツールを選択するのに役立つソリューションを選択する前に、データの種類、そのソースと宛先、および顧客オーディエンスについて考えてください。

00:31:25.000 --> 00:31:35.000
そして、デバッガに接続されていないデバイスでアプリをテストして、デバッガを展開する前に、実際の状況での動作を検証してください。

00:31:35.000 --> 00:31:42.000
あなたのWatchアプリでデータ転送のために私たちが持っているすべての素晴らしいツールについて学ぶために来てくれてありがとう。

00:31:42.000 --> 00:31:45.000
あなたが次に何を作るかを見るのが待ちきれません。

00:31:45.000 --> 23:59:59.000
[音楽]。

