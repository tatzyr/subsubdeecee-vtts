WEBVTT

00:00:02.000 --> 00:00:14.000
こんにちは、ディスプレイ・アンド・カラー・テクノロジーズチームのケン・グリーンバウムです。

00:00:14.000 --> 00:00:19.000
この「ハイダイナミックレンジ、EDRによるレンダリング」トークにご参加いただきありがとうございます。

00:00:19.000 --> 00:00:22.000
それは私があなたと共有することに興奮している技術です。

00:00:22.000 --> 00:00:28.000
私たちがカバーするものと、出席することで誰が最も利益を得るかをすばやく実行しましょう。

00:00:28.000 --> 00:00:47.000
EDRが実際に何であるかから始めて、既存のアプリにEDRを追加するために使用される4つのステップを説明し、レンダリングをより詳細に制御するためのネイティブEDR APIについて話し合い、最後に、EDRに関連する一連のベストプラクティスを探ります。

00:00:47.000 --> 00:00:50.000
さて、EDRとは何ですか?

00:00:50.000 --> 00:00:54.000
EDRは、あなたがよく知らないかもしれない頭字語です。

00:00:54.000 --> 00:00:58.000
それは「拡張ダイナミックレンジ」の略です。

00:00:58.000 --> 00:01:08.000
「EDR」を使用して、当社のプラットフォームで使用されるHDR表現とHDRレンダリング技術の両方を指します。

00:01:08.000 --> 00:01:13.000
それはあなたがすでによく知っているかもしれないカラーマネジメントにやや似ています。

00:01:13.000 --> 00:01:17.000
多くの種類のアプリの開発者は、この話が面白いと思うでしょう。

00:01:17.000 --> 00:01:30.000
まず、コンピュータグラフィックス技術、ハイダイナミックレンジディスプレイ、特にAppleが過去数年間にリリースしてきた新しいXDRディスプレイに興味のある開発者。

00:01:30.000 --> 00:01:41.000
次は、レンダリングエンジンにすでに存在する可能性のある明るい詳細のロックを解除し、最も現実的でエキサイティングな体験を作りたい筋金入りのゲーム開発者です。

00:01:41.000 --> 00:01:53.000
重要なことに、HDRビデオと静止画のスタジオ参照応答を達成することに興味を持っているプロアプリ開発者がいます。

00:01:53.000 --> 00:02:04.000
最後に、グラフィックスに特に重点を置いていますが、現在エコシステムに入っているHDR静止画とビデオコンテンツを受け入れたいアプリの開発者がいます。

00:02:04.000 --> 00:02:09.000
HDRはここにあり、それは私たちのEDR技術によって有効になっています。

00:02:09.000 --> 00:02:17.000
議論するように、私たちはすでにユーザーの手に信じられないほどの機能を備えたディスプレイを持っています。

00:02:17.000 --> 00:02:29.000
ユーザーがキャプチャ、ストリーミング、ダウンロードしているエコシステムの素晴らしいHDRコンテンツと、ゲームとプロフェッショナルの両方のHDRアプリは、App Storeで入手できます。

00:02:29.000 --> 00:02:32.000
EDRは適応技術です。

00:02:32.000 --> 00:02:42.000
議論するように、EDRはHDRコンテンツを大きく異なる機能のディスプレイにマッピングするだけでなく、さらに幅広い視聴条件もサポートしています。

00:02:42.000 --> 00:02:48.000
明るい環境でディスプレイが、暗闇で見たときとは大きく異なって見えることに気づいたことがありますか?

00:02:48.000 --> 00:02:57.000
屋内で体験する明るく鮮やかな色は、屋外で見ると低いダイナミックレンジで薄暗く、ミュートに見える可能性があります。

00:02:57.000 --> 00:02:59.000
ディスプレイは変わらなかった。

00:02:59.000 --> 00:03:03.000
与えられた明るさの設定では、それは常に同じ光を作っています。

00:03:03.000 --> 00:03:09.000
変化した環境と、環境に急速に適応したあなたのビジョンです。

00:03:09.000 --> 00:03:16.000
暗い環境では、あなたのビジョンは、主要な光源である表示されたコンテンツに適応します。

00:03:16.000 --> 00:03:29.000
しかし、明るい環境では、ユーザーのビジョンは、はるかに暗いディスプレイを介して環境に大きく適応し、コンテンツが薄暗く見え、洗い流され、黒と影のディテールを押しつぶします。

00:03:29.000 --> 00:03:47.000
このため、EDRと基礎となる環境適応技術は、ホワイトポイント、ブラックポイント、参照ホワイト輝度、ダイナミックレンジなどのディスプレイパラメータを「EDRヘッドルーム」として記述し、ディスプレイをユーザーの適応ビジョンにマッピングします。

00:03:47.000 --> 00:03:51.000
EDRの適応には多くの利点があります。

00:03:51.000 --> 00:04:02.000
おそらく最も驚くべきことに、これにより、従来の標準ダイナミックレンジディスプレイでも、EDRが真のHDR応答を生み出します。

00:04:02.000 --> 00:04:09.000
つまり、これらのディスプレイが、対応する調光輝度設定で調光環境で表示される場合です。

00:04:09.000 --> 00:04:17.000
同様に、EDRのダイナミクスは、明るいHDRディスプレイで状況最適化されたHDR機能を生み出します。

00:04:17.000 --> 00:04:33.000
これにより、HDRコンテンツはHDR参照の薄暗い環境で見事に見えると同時に、このイラストのパッチなどの影の詳細を維持しながら、より明るい環境で縮小されたが最適なダイナミックレンジを提供します。

00:04:33.000 --> 00:04:37.000
EDRレンダリングは、私たちが何年も出荷してきたほとんどのデバイスでサポートされています。

00:04:37.000 --> 00:04:49.000
私たちは、従来の最大SDRホワイトよりも何倍明るく、最も明るいEDRピクセルをディスプレイにレンダリングできるかであるEDRヘッドルームの観点からHDR機能を説明しました。

00:04:49.000 --> 00:04:57.000
EDRヘッドルームは、表示機能だけでなく、現在の明るさスライダー設定を含む他のパラメータによって異なります。

00:04:57.000 --> 00:05:06.000
最新のMacやiPadで見られるように、従来のバックライト付きディスプレイでは、最大2倍のSDRが利用可能です。

00:05:06.000 --> 00:05:13.000
XDRディスプレイを搭載したiPhoneは、最大8倍のSDR EDRヘッドルームを提供します。

00:05:13.000 --> 00:05:21.000
新しいiPad ProのLiquid Retina XDRディスプレイは、最大16倍のSDRを備えています。

00:05:21.000 --> 00:05:30.000
Mac、iPad、AppleTV経由で一般的な外部HDR 10ディスプレイを運転する場合、約5倍のSDRが提供されます。

00:05:30.000 --> 00:05:40.000
また、Pro Display XDRは、明るさが最小4nit値に設定されている場合、デフォルトのXDRプリセットで驚異的な400倍SDRにレンダリングされます。

00:05:40.000 --> 00:05:48.000
HDR対応のディスプレイはすでに多くのユーザーの手に渡っているだけでなく、HDRコンテンツが主流になりつつあります。

00:05:48.000 --> 00:06:00.000
商用HDRコンテンツに加えて、ユーザーは自分のiPhoneやその他のデバイスでキャプチャされたHDR静止画とビデオコンテンツをエコシステムに追加しています。

00:06:00.000 --> 00:06:04.000
畏敬の念を起こさせるアプリケーションのリストは、すでにEDRを採用しています。

00:06:04.000 --> 00:06:13.000
EDRをサポートする最上位ゲームには、「Baldur's Gate 3」、「Divinity: Original Sin 2」、「Shadow of the Tomb Raider」などがあります。

00:06:13.000 --> 00:06:23.000
ますます多くのAppleTVサービスが、TVアプリ、Netflix、YouTubeなどのHDRコンテンツを提供しています。

00:06:23.000 --> 00:06:33.000
最後に、Proアプリのエキサイティングで増え続けるリストがEDRを採用しており、賭け金を増やし、プラットフォームで開発されたHDRコンテンツの量を増やしています。

00:06:33.000 --> 00:06:44.000
Affinity Photo、DaVinci Resolve、Cinema 4D、Final Cut Pro、Nuke、Pixelmator Proはアプリのほんの一部です。

00:06:44.000 --> 00:06:53.000
私たちは、人によって異なる意味を持つ傾向がある「HDR」と区別するために、私たちの技術を「EDR」と名付けることを選びました。

00:06:53.000 --> 00:07:00.000
多くの人がハイダイナミックレンジについて考えるとき、彼らは深い黒を生み出すことができる明るいディスプレイを想像します。

00:07:00.000 --> 00:07:06.000
制作志向の人は、コンテンツフォーマット、おそらくHDR10またはドルビービジョンを考えるかもしれません。

00:07:06.000 --> 00:07:12.000
技術的には、PQやHLGなどの転送機能が思い浮かびます。

00:07:12.000 --> 00:07:23.000
そして、おそらく芸術的には、HDRは明るいハイライトを表すシュールで絵画的なトーンマップと、SDRとしての薄暗い影の詳細を提案することさえできます。

00:07:23.000 --> 00:07:31.000
RITが生成した超高ダイナミックレンジOpenEXR画像のこのSDRトーンマップを考えてみましょう。

00:07:31.000 --> 00:07:36.000
トーンマップには、光る電球と影のディテールがすべて存在します。

00:07:36.000 --> 00:07:41.000
しかし、元のHDR画像の劇的なダイナミックレンジは失われます。

00:07:41.000 --> 00:07:52.000
EDRは、意図を失いながらすべての詳細を保持する絵画的なHDRからSDRへの変換ではなく、真のハイダイナミックレンジレンダリングです。

00:07:52.000 --> 00:08:04.000
RITチームは、ここで見られる18ブラケットのデジタル一眼レフ露出を組み合わせて、驚くべき50万:1のダイナミックレンジでHDR画像を作成しました。

00:08:04.000 --> 00:08:20.000
EDRはこれを浮動小数点で完全に表し、画像の被写体であるLuxoランプ自体は、参照白の1.0の下のピクセル値として、電球の発光オーブなどの明るいディテールで、500に近い値として表されます。

00:08:20.000 --> 00:08:23.000
それはランプベースよりも500倍明るいです。

00:08:23.000 --> 00:08:28.000
EDRの実装は、システムのすべての要素の参照ホワイト間のマッピングを作成します。

00:08:28.000 --> 00:08:35.000
コンテンツの参照白からディスプレイの参照白、ユーザーの適応ビジョンの参照白まで。

00:08:35.000 --> 00:09:00.000
このマッピングは、HDRとSDRコンテンツが共存し、環境間でHDRディスプレイのダイナミックレンジを最適に公開し、従来のSDRディスプレイが真のHDRをレンダリングできるようにするなど、EDRの多くの利点を提供するための基本です。

00:09:00.000 --> 00:09:10.000
たとえば、Pro Display XDRでは、輝度スライダーが最大500ニトに設定されている場合、最大3.2のEDR値がクリッピングなしでレンダリングされます。

00:09:10.000 --> 00:09:19.000
ランプヘッドなどのより明るい要素は、それに応じてより大きなEDR値を持ち、ディスプレイの1,600ニトのピークにクランプします。

00:09:19.000 --> 00:09:40.000
ディスプレイの明るさ設定を4ニトの最小値に向かって下げると、薄暗い環境で、自動輝度を介して自動的に、または手動で輝度スライダーを使用して発生すると、最大400のEDR値がレンダリング可能になり、この例外的な画像のダイナミックレンジのほとんどを提供します。

00:09:40.000 --> 00:09:49.000
画像の最も明るい要素は、ディスプレイの1,600ニトのピーク輝度にレンダリングされていますが、電球の輪郭を明確に定義しています。

00:09:49.000 --> 00:09:55.000
同様に、明るく照らされたカラーチェッカーの色など、他の詳細が明らかにされます。

00:09:55.000 --> 00:10:07.000
ユーザーのビジョンが画像の4ニットリファレンスホワイトに適応するようになったため、画像の最も明るい要素は、ランプベースよりも400倍明るくレンダリングされるようになりました。

00:10:07.000 --> 00:10:14.000
EDRの浮動小数点HDR表現とレンダリングパイプラインの影響を探りましょう。

00:10:14.000 --> 00:10:23.000
浮動小数点であるEDRは、この完全に満たされた色度図で表されるように、人間が知覚できるすべての色を表すことができます。

00:10:23.000 --> 00:10:29.000
同様に、EDRは、完全にレンダリングされると視力にダメージを与える明るさを表すことができます。

00:10:29.000 --> 00:10:34.000
そのため、EDRの表現は将来性があります。

00:10:34.000 --> 00:10:41.000
前述のように、EDRは表現であるだけでなく、HDRレンダリングパイプラインでもあります。

00:10:41.000 --> 00:10:48.000
EDRは、Appleが開拓したカラーマネジメント技術の拡張であり、非常に長い間出荷されています。

00:10:48.000 --> 00:10:55.000
たとえば、GPUアクセラレーションカラーマネージドビデオは、最初にMacOS 10.4 Tigerで出荷されました。

00:10:55.000 --> 00:11:12.000
概念的には、通常の色域と広色域のメディアを並べて表示できるようにするのと同様に、EDRはHDRとSDRの資産を調和のとれた方法で画面を共有し、さまざまな機能のディスプレイに適切にレンダリングすることができます。

00:11:12.000 --> 00:11:22.000
とりわけ、これは開発者が既存のSDR資産を引き続き使用し、必要に応じてEDRサポートを選択的に追加できることを意味します。

00:11:22.000 --> 00:11:27.000
EDRのHDRピクセル値の表現を視覚的に探りましょう。

00:11:27.000 --> 00:11:31.000
EDRは浮動小数点表現です。

00:11:31.000 --> 00:11:46.000
EDR 0.0は黒を表し、1.0はSDR maxを表し、「参照白」または「UI白」とも呼ばれ、EDR 0.0から1.0はいつものようにSDR範囲を表します。

00:11:46.000 --> 00:11:50.000
これらの値は画像の被写体を表し、レンダリング時にクリップされることはありません。

00:11:50.000 --> 00:11:59.000
1.0を超えるEDR値は、ハイライトや発光面など、SDRの明るさを超える値を表します。

00:11:59.000 --> 00:12:06.000
これらの値は非常に明るくなる可能性があり、表現可能ですが、レンダリング時にクリッピングの対象となります。

00:12:06.000 --> 00:12:15.000
EDRは、ディスプレイが従来の純粋な電力応答または新しいHDR転送機能を持っているかどうかに関係なく、ディスプレイを駆動するために使用されます。

00:12:15.000 --> 00:12:21.000
PQベースのデフォルトのXDRプリセットでPro Display XDRを考えてみましょう。

00:12:21.000 --> 00:12:26.000
EDR 0.0は、ゼロnit PQコードを介して、ディスプレイをゼロnitsに駆動します。

00:12:26.000 --> 00:12:34.000
「リファレンスホワイト」と呼ばれるEDR 1.0は、いつものようにディスプレイの明るさスライダーまたは自動明るさによってスケーリングされます。

00:12:34.000 --> 00:12:40.000
XDRプリセットは、典型的な約4〜500ニトの参照白色輝度範囲を持っています。

00:12:40.000 --> 00:12:44.000
この例では、最大500ニトの設定を考えてみましょう。

00:12:44.000 --> 00:12:50.000
明るさの設定に関係なく、このプリセットではピークホワイトは常に1,600ニトです。

00:12:50.000 --> 00:13:02.000
したがって、1,600ニトピークホワイトを500ニトの基準白で割って計算できるように、最も明るくレンダリング可能なEDR値であるEDRmaxは3.2です。

00:13:02.000 --> 00:13:14.000
それに応じて、ディスプレイにレンダリング可能な最も明るい値は、参照白よりも3.2倍明るいため、3.2倍のSDRヘッドルームがあると言います。

00:13:14.000 --> 00:13:34.000
要約すると、Pro Display XDRでは、デフォルトのXDRプリセットを使用して、ディスプレイの明るさは「リファレンスホワイト」とも呼ばれ、500ニトで、EDR値0.0〜3.2は0.0〜1,600ニトとしてディスプレイにレンダリングされ、EDR 1.0は500ニトとして表示されます。

00:13:34.000 --> 00:13:41.000
最後に、EDRmaxの3.2を超えるEDR値は、ピークホワイト、1,600ニトにクリップされます。

00:13:41.000 --> 00:13:55.000
驚くべきことに、ディスプレイの明るさが最小4ニトに向かって低下すると、最大400のEDR値がレンダリング可能になり、真のダイナミックレンジで信じられないほど明るいディテールが露出します。

00:13:55.000 --> 00:14:01.000
EDRの仕組みの概要がわかったので、アプリケーションにEDRを追加することを検討します。

00:14:01.000 --> 00:14:05.000
ほとんどのアプリケーションにEDRサポートを追加するには、4つのステップがあります。

00:14:05.000 --> 00:14:15.000
これらの手順はすべて簡単ですが、その効果は微妙であり、それらをすべて適用するまでEDRの結果を確実に得られない可能性があります。

00:14:15.000 --> 00:14:22.000
まず、適切なコンテキスト、レイヤー、またはオブジェクトに属性を追加してEDRを要求する必要があります。

00:14:22.000 --> 00:14:28.000
次に、拡張範囲のカラースペースをバッファ、レイヤー、またはアプリに関連付ける必要があります。

00:14:28.000 --> 00:14:35.000
拡張範囲のカラースペースが指定されていない場合、カラーマネジメントはEDR値を1.0を超えてクリップします。

00:14:35.000 --> 00:14:45.000
カラー管理は、ソースとデスティネーションのカラースペースが一致しない場合にのみ関与する可能性があるため、このクリップは断続的またはコンテンツに依存する可能性があります。

00:14:45.000 --> 00:14:52.000
第三に、1.0を超える値を表現できるピクセルバッファ形式を選択する必要があります。

00:14:52.000 --> 00:14:54.000
これは通常、ある種の浮動小数点です。

00:14:54.000 --> 00:15:03.000
最後に、アプリケーションはSDR 0.0から1の範囲を超えるピクセルを生成し、誇示するキラキラした要素を持つ必要があります。

00:15:03.000 --> 00:15:09.000
多くの開発者は、EDRサポートを追加したいかもしれない既存のアプリを持っています。

00:15:09.000 --> 00:15:19.000
おそらく、EDRを使い始める最も簡単な方法は、既存のSDRコンテンツの代わりにHDRビデオまたは静止画コンテンツを置き換えることです。

00:15:19.000 --> 00:15:22.000
次に、先ほど概説した4つのステップに従ってください。

00:15:22.000 --> 00:15:31.000
一部のアプリケーション、例えば、表示されている電子メールアプリは、HDRコンテンツに遭遇した場合にのみ選択的にEDRを有効にする場合があります。

00:15:31.000 --> 00:15:41.000
AVFoundationのAVPlayerインターフェースは、ドルビービジョン、HDR 10、HLGなどのますます多くのHDRビデオフォーマットをサポートしています。

00:15:41.000 --> 00:15:49.000
AVPlayerは、watchOSを除くすべてのプラットフォームで可能な限り、これらのフォーマットを自動的にEDRとしてレンダリングします。

00:15:49.000 --> 00:15:57.000
既存のAVPlayerベースのアプリケーションは、EDRを介してサポートされているHDRビデオフォーマットをレンダリングするために変更を必要としません。

00:15:57.000 --> 00:16:01.000
EDR対応のAVPlayerコードの例を見てみましょう。

00:16:01.000 --> 00:16:08.000
いつものように、AVPlayerのplayerWithURLを使用して、まずAVPlayerインスタンスを作成するだけです。

00:16:08.000 --> 00:16:12.000
ただし、この例では、HDRビデオコンテンツを指定します。

00:16:12.000 --> 00:16:18.000
次に、playerLayerWithPlayerを使用して、プレイヤーをレイヤーに追加します。

00:16:18.000 --> 00:16:23.000
最後に、コントローラーをプレイヤーに向け、プレイヤーにプレイを開始するよう依頼します。

00:16:23.000 --> 00:16:34.000
AVFoundationは、HDRメディアをEDRとしてレンダリングするために必要なものを自動的に実行し、コンテンツタイプに基づいてEDRを有効または無効にします。

00:16:34.000 --> 00:16:37.000
HDRビデオの再生はかなり簡単です。

00:16:37.000 --> 00:16:41.000
次に、HDR静止画のレンダリングを考えてみましょう。

00:16:41.000 --> 00:16:51.000
ImageIOはHDR画像フォーマットを幅広くサポートしており、便利なことに、浮動小数点バッファでデコードされたピクセルをEDRとして返します。

00:16:51.000 --> 00:16:59.000
ImageIOはすべてのプラットフォームで利用できますが、現在、デコードされた結果はmacOSでEDRとしてのみレンダリングできます。

00:16:59.000 --> 00:17:07.000
今後のCAMetalLayerの例で、ImageIOベースのアセットをアプリケーションに組み込む方法を紹介します。

00:17:07.000 --> 00:17:11.000
では、ネイティブEDR APIを探りましょう。

00:17:11.000 --> 00:17:25.000
前述したように、ネイティブEDR APIは、開発者がカスタムコンテンツをレンダリングし、HDRメディアのレンダリング方法をより詳細に制御したいかもしれないゲームやプロアプリなどのアプリケーション用に作成されました。

00:17:25.000 --> 00:17:32.000
現在、このAPIはCAMetalLayerとNSOpenGLViewを介してmacOSで利用可能です。

00:17:32.000 --> 00:17:38.000
好ましいネイティブEDRフレームワークであるCAMetalLayerを使用した例を見てみましょう。

00:17:38.000 --> 00:17:52.000
まず、4段階のプロセスの最初の3つを見て、EDRを選択し、拡張範囲の色空間を設定し、FP16ピクセルバッファ形式を選択します。

00:17:52.000 --> 00:18:01.000
まず、metalLayerの「wantsExtended DynamicRangeContent」属性を「はい」に設定して、EDRにオプトインします。

00:18:01.000 --> 00:18:09.000
次に、metalLayerの色空間をExtendedLinearDisplayP3などの拡張範囲の色空間に設定します。

00:18:09.000 --> 00:18:17.000
第三に、metalLayerのピクセル形式をRGBA16Floatなどの浮動小数点形式に設定します。

00:18:17.000 --> 00:18:23.000
次に、実際にEDRピクセルを生成する4番目のEDRオプトインステップを調べます。

00:18:23.000 --> 00:18:31.000
この場合、ImageIOを使用してHDR静止画コンテンツをインポートし、結果をEDRテクスチャとしてレンダリングします。

00:18:31.000 --> 00:18:35.000
少し複雑なので、一歩一歩歩きます。

00:18:35.000 --> 00:18:53.000
HDRコンテンツからCGImageを作成し、デコードされた画像を浮動小数点ビットマップに描画し、浮動小数点テクスチャを作成し、EDRビットマップをテクスチャにロードし、最後に、EDR対応の金属パイプラインにテクスチャをレンダリングします。

00:18:53.000 --> 00:19:08.000
まず、CGImageは、CGImageSourceCreateWithURLとCGImageSourceCreateImageAtIndexを使用して、HDRimageURLで指定されたソースから作成されます。

00:19:08.000 --> 00:19:25.000
次に、以前にmetalLayerで設定したのと同じ色空間を使用して、CGBitmapContextCreateでCGContextを作成し、CGContextDrawImageを使用してEDR画像を浮動小数点コンテキストに描画します。

00:19:25.000 --> 00:19:33.000
次に、newTextureWithDescriptorを使用して、RGBA16Float型の浮動小数点テクスチャを作成します。

00:19:33.000 --> 00:19:42.000
replaceRegionを使用して、CGBitmapContextGetDataを使用してEDR画像データをEDRテクスチャにロードします。

00:19:42.000 --> 00:19:51.000
最後に、開発者はEDRテクスチャをEDR対応の金属パイプラインにレンダリングし、動的な結果を楽しむ準備ができています。

00:19:51.000 --> 00:20:02.000
まだOpenGLベースのアプリケーションをサポートしている人のために、すでに実証したものと同様の手順を使用して、NSOpenGLViewでEDRを有効にすることを検討します。

00:20:02.000 --> 00:20:07.000
EDRの採用はまた、カラーマネジメントを完全に受け入れる機会を提供するかもしれない。

00:20:07.000 --> 00:20:10.000
しかし、この講演ではそれを取り上げません。

00:20:10.000 --> 00:20:22.000
次の手順を探ります。EDRにオプトインし、浮動小数点ピクセルバッファ形式を選択し、EDRとコンテンツをNSOpenGLViewに描画します。

00:20:22.000 --> 00:20:30.000
NSOpenGLViewは自動的にカラー管理されないため、拡張範囲のカラースペースを設定する必要はありません。

00:20:30.000 --> 00:20:40.000
まず、NSOpenGLViewの「wantsExtendedDynamicRange OpenGLSurface」属性を「はい」に設定して、EDRにオプトインします。

00:20:40.000 --> 00:20:49.000
次に、ピクセルバッファ形式をNSOpenGLPFAColorFloat with ColorSize、64に設定します。

00:20:49.000 --> 00:20:56.000
最後に、EDR値をOpenGLViewに描画し、変更されたアプリケーションを実行し、結果をお楽しみください。

00:20:56.000 --> 00:21:10.000
既存のアプリケーションで基本的なEDRサポートを有効にすることについて議論したので、EDR対応アプリケーションを最大限に活用するためのいくつかのベストプラクティスをもう少し深く掘り下げてみましょう。

00:21:10.000 --> 00:21:15.000
リコールEDRオプトインステップ4は、拡張範囲の色空間を設定することです。

00:21:15.000 --> 00:21:22.000
そして、これまでの例では、適切な拡張範囲の色空間を明示的に設定しました。

00:21:22.000 --> 00:21:30.000
ただし、多くのアプリは色空間を明示的に設定せず、代わりにフレームワークによって提供されるデフォルトの色空間を使用します。

00:21:30.000 --> 00:21:40.000
これは多くの場合、拡張範囲ではないディスプレイまたはコンポジションスペースに対応し、何かが行われない限りEDRを壊します。

00:21:40.000 --> 00:21:45.000
既存の色空間を拡張範囲に促進する方法の例を探ってみましょう。

00:21:45.000 --> 00:21:51.000
まず、この場合、ビューのウィンドウから既存の色空間を取得します。

00:21:51.000 --> 00:21:57.000
次に、CGcolorspaceCreateExtendedを使用して、その色空間を拡張範囲に昇格します。

00:21:57.000 --> 00:22:10.000
最後に、必要に応じて、新しく生成された拡張範囲の色空間をウィンドウ、バッファ、またはレイヤーに割り当て、色空間を明示的に設定していないアプリがEDRを使用できるようにします。

00:22:10.000 --> 00:22:15.000
次に、EDRコンテンツを生成するためのベストプラクティスを探ります。

00:22:15.000 --> 00:22:25.000
これまでのところ、EDRコンテンツには1.0を超える値があると述べましたが、このコンテンツを実際に合成する方法やHDRソースから変換する方法はありません。

00:22:25.000 --> 00:22:38.000
EDRコンテンツの生成には注意してください。恐ろしい「輝くバニー症候群」を経験する可能性があるため、コンテンツは不気味で虹色の輝きがあり、適切に作成されたコンテンツが薄暗く見える可能性があります。

00:22:38.000 --> 00:22:46.000
強調されているように、EDR 1.0を超えるピクセルは、鏡面ハイライトと発光面のみをエンコードする必要があります。

00:22:46.000 --> 00:22:52.000
これは、SDRコンテンツを取り、それをHDRに伸ばすのは不適切であることを意味します。

00:22:52.000 --> 00:22:58.000
SDRコンテンツは、ネイティブ0.0から1.0の範囲のEDR as-isと互換性があります。

00:22:58.000 --> 00:23:03.000
これにより、SDR参照白がHDRコンテンツの白に合わせます。

00:23:03.000 --> 00:23:15.000
HDRコンテンツが明るすぎるように作成されている場合、暗い要素や影がEDR 1.0を超えると、よく作成されたコンテンツに比べて不自然に見えます。

00:23:15.000 --> 00:23:24.000
ユーザーのビジョンは、この過度に明るいコンテンツに適応し始め、他のコンテンツと比較して薄暗く見える可能性があります。

00:23:24.000 --> 00:23:31.000
写真家やアニメーターが露出を設定するために使用する18%の灰色のカードを持っている女の子のこの例を検討してください。

00:23:31.000 --> 00:23:45.000
少女は写真の被写体であり、その結果、写真家やアニメーターは露出を基準白以下に設定し、クリップされません。

00:23:45.000 --> 00:23:49.000
ほとんどのユーザーインターフェイス要素もEDR 1.0を超えてはいけません。

00:23:49.000 --> 00:23:59.000
ただし、注意を引くために明るく照らされたEDRカラーピッカーや一時的にスケーリングされたUIなど、例外があるかもしれません。

00:23:59.000 --> 00:24:15.000
太陽や雲などの発光面や、光沢のある表面に反射する太陽などの鏡面ハイライトは、参考白よりもはるかに明るくなる可能性があり、その結果、EDR 1.0を超えると予想されます。

00:24:15.000 --> 00:24:20.000
シーンの最も明るい要素は、すでにSDRエンコーディングによってクリップされています。

00:24:20.000 --> 00:24:26.000
その結果、SDRコンテンツはEDR 0.0から1.0として正しく表されます。

00:24:26.000 --> 00:24:32.000
ワークフローでは、HDRフォーマットを明示的にEDRに変換する必要がある場合があります。

00:24:32.000 --> 00:24:39.000
前述のように、ImageIOはHDRコンテンツをEDRにデコードし、それ以上の変換を必要としません。

00:24:39.000 --> 00:24:48.000
たとえば、HLGは0.0から12.0のEDR範囲にデコードされ、EDR 1.0は参照白を表します。

00:24:48.000 --> 00:24:59.000
ImageIOは、他のHDR静止画フォーマットを独自の特定の範囲にデコードし、EDR 1.0は常にソースの参照白に対応します。

00:24:59.000 --> 00:25:05.000
AVFoundationは現在、HDR10などのHDRフォーマットをEDRにデコードしていません。

00:25:05.000 --> 00:25:09.000
したがって、これらはEDRレンダリングで使用するために適応する必要があります。

00:25:09.000 --> 00:25:13.000
この変換は簡単で、2つのステップが必要です。

00:25:13.000 --> 00:25:18.000
まず、逆伝達関数を適用して線形光に変換します。

00:25:18.000 --> 00:25:21.000
そして第二に、媒体の基準白で割る。

00:25:21.000 --> 00:25:33.000
たとえば、PQコンテンツの100ニトなので、参照白はEDR 1.0にマッピングされ、最大PQ 10,000ニトの値はEDR 100にマッピングされます。

00:25:33.000 --> 00:25:39.000
デジタルとフィルムの両方の多くの写真と同様に、空が白に切り取られたこの写真を考えてみましょう。

00:25:39.000 --> 00:25:56.000
EDRはEDR 1.0までの値をクリップしませんが、画像の主題を表す参照白、EDRは現在のEDRmaxを超えた参照白の上の値をクリップするので、現在のシステム表示と表示設定でレンダリングすることはできません。

00:25:56.000 --> 00:26:07.000
参照白の上のこれらの値は、この画像では見ることができない雲、空、太陽などのハイライトまたは発光面であり、そのため、通常はクリップしても大丈夫です。

00:26:07.000 --> 00:26:12.000
しかし、明るいディテールのクリッピングは必ずしも受け入れられるとは限りません。

00:26:12.000 --> 00:26:17.000
例えば、雲の上を高く飛んでいる太陽に照らされた飛行機のこのイメージを考えてみましょう。

00:26:17.000 --> 00:26:20.000
青い「HDR11」のカラーリングに注目してください。

00:26:20.000 --> 00:26:34.000
明るく照らされて、番号とそれが塗装された胴体は、両方とも参照白よりも大きくレンダリングされる可能性があり、したがって、ディスプレイ機能と現在のEDRmaxに応じてクリップされる可能性があります。

00:26:34.000 --> 00:26:45.000
この数字が映画やゲームの重要なプロット要素であった場合、ダイナミックトーンマッピングを使用してクリッピングを回避または管理し、数字を見えるようにすることができます。

00:26:45.000 --> 00:26:54.000
洗練されたアプリケーションが現在のEDRmax値に遅れずについていく方法を検討し、それに応じてレンダリングするものを適応させましょう。

00:26:54.000 --> 00:27:09.000
アプリケーションは、おそらくシーン内のオブジェクトの明るさを調整したり、シーンの露出を変更したり、ブルーム効果を適用したり、重要な詳細が失われないようにソフトクリップを適用したりするために、NSScreen通知を購読したい場合があります。

00:27:09.000 --> 00:27:15.000
現在、NSScreenインターフェースからアクセスできる動的EDR値は1つしかありません。

00:27:15.000 --> 00:27:25.000
これはmaximumExtendedDynamic RangeColorComponentValueであり、現在の最大レンダリング可能な線形EDR値を表します。

00:27:25.000 --> 00:27:31.000
述べたように、EDRmaxより大きいEDR値はEDRmaxにクリップされます。

00:27:31.000 --> 00:27:41.000
また、EDRmaxは、ディスプレイの明るさやTrue Toneなどの特性に依存しているため、動的に変化する可能性があります。

00:27:41.000 --> 00:27:48.000
NSScreenからアクセスできる他の2つのEDR値は静的であり、時間の経過とともに変化しないことを意味します。

00:27:48.000 --> 00:28:02.000
前述の値とは対照的に、maximumPotentialExtendedDynamic RangeColorComponentValueは、このディスプレイでクリッピングせずにレンダリング可能な最大EDRリニアピクセル値を返します。

00:28:02.000 --> 00:28:07.000
つまり、ディスプレイの明るさやその他の機能が適切に設定されている場合です。

00:28:07.000 --> 00:28:18.000
最大潜在的なEDRは、SDRまたはHDRバージョンのコンテンツを使用すべきかどうか、あるいはEDRを有効にする価値があるかどうかを決定するなど、意思決定を導くために使用される可能性があります。

00:28:18.000 --> 00:28:21.000
可能性は名前にあることを覚えておいてください。

00:28:21.000 --> 00:28:27.000
現在のレンダリング可能な最大値であるEDRmaxは、この値を下回っている可能性があります。

00:28:27.000 --> 00:28:32.000
EDRをサポートしていないディスプレイまたはディスプレイプリセットには1.0が返されます。

00:28:32.000 --> 00:28:45.000
最終的な静的値であるmaximumReferenceExtendedDynamic RangeColorComponentValueは、主に参照標準に対する最高の忠実度を達成することを懸念しているProアプリケーション開発者にとって興味深いものです。

00:28:45.000 --> 00:28:55.000
これは、特定のディスプレイで、クリッピングやトーンマッピングなどの歪みなしでレンダリングされることが保証されている最大EDR値を提供します。

00:28:55.000 --> 00:28:59.000
参照レンダリングをサポートしていないディスプレイでは、0.0が返されます。

00:28:59.000 --> 00:29:05.000
それでは、NSScreen経由でEDR値を読み取るサンプルコードを見てみましょう。

00:29:05.000 --> 00:29:10.000
ここでは、maxPotentialとmaxReferenceの2つの静的EDR値を読み取ります。

00:29:10.000 --> 00:29:17.000
EDRの値はディスプレイ間で異なる場合がありますので、アプリが実際にオンになっている画面で必ず電話をかけてください。

00:29:17.000 --> 00:29:21.000
この例では、ウィンドウに関連付けられたNSScreenを使用しています。

00:29:21.000 --> 00:29:39.000
アプリケーションは、「NSWindowDidChangeScreen」通知を購読し、画面変更イベントを受信したときに現在のEDRパラメータを照会し、現在のEDRヘッドルームの知識に基づいてレンダリングされるものを変更する可能性があります。

00:29:39.000 --> 00:29:45.000
トーンマッピングの議論を完了するために、CAMetalLayerトーンマッパーを簡単に検討します。

00:29:45.000 --> 00:29:55.000
これは、HLGやHDR10などのHDRビデオを作成してレンダリングするProアプリにとって、プロジェクトベースのHDRマスタリングパラメータに興味があります。

00:29:55.000 --> 00:30:11.000
すでに説明したように、システムアプリやAVPlayerを採用しているアプリは、CAMetalLayerトーンマッパーを使用して、メディア固有の光学から光学への転送機能と、そうでなければレンダリングできないHDR値のソフトクリップを提供します。

00:30:11.000 --> 00:30:20.000
CAMetalLayerトーンマッパーは、「CAEDRMetadata」属性を介して有効になり、macOSで利用できます。

00:30:20.000 --> 00:30:28.000
この例は、アプリのCAMetalLayerに「EDRMetadata」属性を設定して、システムトーンマッパーを有効にする方法を示しています。

00:30:28.000 --> 00:30:32.000
多くのEDRMetadataコンストラクタが利用可能です。

00:30:32.000 --> 00:30:37.000
それらは、提供されたマスタリング情報だけでなく、HDRビデオ標準に固有のものです。

00:30:37.000 --> 00:30:42.000
ここでは、パラメータを取らないHLGMetadataコンストラクタを見ます。

00:30:42.000 --> 00:30:46.000
次に、HDR10コンストラクタの1つを実演します。

00:30:46.000 --> 00:30:59.000
これには3つのパラメータが必要です。nitsの両方の明示的な最小およびmaximumLuminanceと、しばしばHDR10の100nitリファレンスホワイトに設定されるopticalOutputScaleです。

00:30:59.000 --> 00:31:11.000
構築されたら、結果のオブジェクトをアプリケーションのCAMetalLayerに設定し、このレイヤーでレンダリングされたすべてのコンテンツが、提供されたメタデータに基づいてシステムトーンマッパーによって処理されます。

00:31:11.000 --> 00:31:18.000
アダプティブトーンマッピングと密接に関連して、アプリは、現在レンダリング可能な最も明るい白で描画したいと思うかもしれません。

00:31:18.000 --> 00:31:28.000
NSScreenから現在のEDRmaxを取得する方法をすでに理解していますが、EDRヘッドルームは線形値であり、ピクセルはほとんどの場合非線形にエンコードされています。

00:31:28.000 --> 00:31:35.000
この最後の例では、EDRmaxをアプリの潜在的に非線形色空間に変換します。

00:31:35.000 --> 00:31:41.000
まず、CGColorSpaceCreateWithNameを使用して、レンダリングする線形EDRmaxホワイトピクセルを作成します。

00:31:41.000 --> 00:31:50.000
そして、CGColorCreateCopy ByMatchingToColorSpaceを使用して、線形EDRmaxピクセルをアプリケーションの色空間に変換します。

00:31:50.000 --> 00:31:55.000
結果の色は、EDR対応アプリケーションで使用できます。

00:31:55.000 --> 00:32:01.000
これにより、EDRのパワーとパフォーマンスの影響について、議論する最後のトピックが残ります。

00:32:01.000 --> 00:32:15.000
すべてのCGレンダリングと同様に、EDRの電力とパフォーマンスへの影響を評価することは複雑になる可能性があり、多くの場合、特定のデバイスで使用される特定のハードウェアアーキテクチャとディスプレイ技術に依存します。

00:32:15.000 --> 00:32:31.000
この講演では詳しく説明しませんが、より明るいピクセルを生成すると、多くの場合、より多くの電力を消費し、EDRで使用される浮動小数点バッファが大きくなる可能性があるため、それ以外の場合に使用される可能性のある固定ポイントバッファよりも多くの帯域幅を消費するなど、考慮すべき一般的なポイントがいくつかあります。

00:32:31.000 --> 00:32:34.000
これは、順番に、より多くの消費電力と相関しています。

00:32:34.000 --> 00:32:40.000
CAEDRMetadataベースのトーンマッピングを有効にしても、追加の処理パスが必要です。

00:32:40.000 --> 00:32:44.000
これにより、レイテンシと帯域幅が増加します。

00:32:44.000 --> 00:32:51.000
単純に、EDRは、多くの機能と同様に、無料ではないので、慎重に使用する必要があります。

00:32:51.000 --> 00:32:58.000
ベストプラクティスは、HDRコンテンツと潜在的なEDRヘッドルームの両方が利用可能な場合にEDRを有効にすることです。

00:32:58.000 --> 00:33:01.000
そうでない場合は、EDRを無効にします。

00:33:01.000 --> 00:33:15.000
同様に、EDRの潜在的なヘッドルーム、または現在のEDRmaxヘッドルームが1.0よりも大幅に大きいかどうかに基づいて、オープンまたはストリーミングするコンテンツのHDRまたはSDRバージョンを選択します。

00:33:15.000 --> 00:33:20.000
または、より簡単に言えば、ユーザーが違いを見る場合にのみEDRを有効にします。

00:33:20.000 --> 00:33:24.000
短期間でEDRについて多くのことを取り上げました。

00:33:24.000 --> 00:33:31.000
あなたが私と同じようにEDRに興奮し、それをあなたのアプリケーションに統合することを熱望していることを願っています。

00:33:31.000 --> 00:33:38.000
要約すると、EDRはmacOS、iOS、iPadOS、tvOSデバイスで使用されています。

00:33:38.000 --> 00:33:44.000
EDRは、すでに使用しているカラーマネジメントとSDR表現の拡張機能です。

00:33:44.000 --> 00:33:47.000
EDRは、アプリケーションがオプトインするのは簡単です。

00:33:47.000 --> 00:33:56.000
EDRは業界のHDR規格と互換性があり、デバイスや環境全体で非モーダルアダプティブ体験を提供します。

00:33:56.000 --> 00:34:06.000
HDRビデオ再生、Apple Pro Display XDR、EDRのメタルレンダリングの詳細については、以下の講演とリソースをご覧ください。

00:34:06.000 --> 00:34:07.000
ありがとう！

00:34:07.000 --> 00:34:09.000
残りのWWDCを楽しんでください。

00:34:09.000 --> 23:59:59.000
[音楽]。

