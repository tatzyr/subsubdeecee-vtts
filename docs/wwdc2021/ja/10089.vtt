WEBVTT

00:00:02.000 --> 00:00:10.000
こんにちは。

00:00:10.000 --> 00:00:14.000
私の名前はアニーで、健康記録チームのソフトウェアエンジニアです。

00:00:14.000 --> 00:00:23.000
今日、同僚のケーリーが参加し、HealthKitを使用して検証可能な健康記録を共有できるようにする方法を紹介します。

00:00:23.000 --> 00:00:33.000
検証可能な健康記録に飛び込む前に、iOS 11.3用に2018年に発売した健康記録機能を簡単に再導入したいと思います。

00:00:33.000 --> 00:00:43.000
健康記録を使用すると、ユーザーはプロバイダーに接続し、臨床記録を健康アプリに安全にダウンロードして、簡単に保存して視覚化することができます。

00:00:43.000 --> 00:00:51.000
これはすべて、HL7のFast Healthcare Interoperability ResourcesやFHIRなどの業界標準に基づいて構築されています。

00:00:51.000 --> 00:00:58.000
ユーザーの許可があれば、アプリはユーザーがHealthKitでダウンロードしたこれらの健康記録にアクセスできます。

00:00:58.000 --> 00:01:09.000
既存の健康記録APIの詳細については、WWDC 2018のビデオ「HealthKitによる健康記録へのアクセス」をご覧ください。

00:01:09.000 --> 00:01:23.000
iOS 15では、健康記録の作業を活用して、SMART Health Cardsの仕様に基づいて実装された健康アプリで検証可能な記録のダウンロード、保存、共有を可能にします。

00:01:23.000 --> 00:01:33.000
検証可能な健康記録とは何か、そして現在HealthKitで照会できる健康記録データとどのように異なるのかを探りましょう。

00:01:33.000 --> 00:01:43.000
まず、検証可能な健康記録には、患者リソースと1つ以上の臨床リソースを含む複数のFHIRリソースが含まれています。

00:01:43.000 --> 00:01:48.000
これらのリソースは、SMARTヘルスカードと呼ばれるものにバンドルされています。

00:01:48.000 --> 00:02:02.000
発行者、またはラボや医療提供者などの検証可能な健康記録を作成する機関は、このSMART Health CardにJSON Web Signature（JWS）として暗号署名します。

00:02:02.000 --> 00:02:12.000
最後に、発行者は、患者とその臨床データに関する必要な情報のみを含むように、検証可能な健康記録を生成します。

00:02:12.000 --> 00:02:16.000
これらの点をより明確に把握するために、例を見てみましょう。

00:02:16.000 --> 00:02:24.000
この例では、この記録には2つのFHIR予防接種リソースが含まれており、ワクチンの投与ごとに1つずつです。

00:02:24.000 --> 00:02:30.000
また、ワクチンを受けた人を特定するためのFHIR患者リソースも含まれています。

00:02:30.000 --> 00:02:37.000
その後、これらのリソースはSMARTヘルスカードに組み合わされ、生の形では次のようになります。

00:02:37.000 --> 00:02:56.000
SMART Health Cardペイロードには、ヘルスカードに期待するデータの種類を宣言するURLを含むタイプや、FHIRバージョンと予防接種と患者リソースを含むバンドルリソースを含む資格情報サブジェクトなどの情報が含まれています。

00:02:56.000 --> 00:03:04.000
その後、SMARTヘルスカードはJWSとして署名され、ヘッダーとペイロードの2つのコンポーネントがあります。

00:03:04.000 --> 00:03:21.000
JWSヘッダーには、JWSに署名するために使用されるアルゴリズム、発行者の公開鍵の署名に使用されたことを示す公開鍵の指紋、およびペイロードを圧縮するために使用されるアルゴリズムが含まれています。

00:03:21.000 --> 00:03:38.000
圧縮されたJWSペイロードには、資格情報サブジェクトとともに、発行者の公開鍵が配置されている発行者URL、発行日、オプションの有効期限など、他の請求データが含まれています。

00:03:38.000 --> 00:03:42.000
生の形では、これは検証可能な健康記録がどのように見えるかです。

00:03:42.000 --> 00:03:51.000
詳細については、このセッションに関連付けられているリンクからSMARTヘルスカードの仕様にアクセスすることをお勧めします。

00:03:51.000 --> 00:03:59.000
検証可能な健康記録がどのように見えるかを見直したので、これらの記録を健康アプリにインポートする方法をお見せしましょう。

00:03:59.000 --> 00:04:03.000
1つの選択肢は、既存の健康記録機能を使用することです。

00:04:03.000 --> 00:04:10.000
ユーザーは、健康記録対応プロバイダーに接続することで、検証可能な健康記録を健康アプリにダウンロードできます。

00:04:10.000 --> 00:04:20.000
このオプションは、現在米国、英国、カナダにある健康記録機能が利用可能な場合にのみ利用可能であることに注意してください。

00:04:20.000 --> 00:04:30.000
ユーザーは、.smart-health-cards拡張子を持つファイルをダウンロードするか、スマートヘルスカードファイルに埋め込まれたQRコードをスキャンするオプションもあります。

00:04:30.000 --> 00:04:39.000
これにより、健康アプリに次のシートが表示され、ユーザーは詳細を表示し、これらのレコードをダウンロードするかどうかを選択できます。

00:04:39.000 --> 00:04:42.000
これら2つのオプションは国際的に利用可能です。

00:04:42.000 --> 00:04:47.000
最後に、HealthKitでこのデータへのアクセスをリクエストするにはどうすればよいですか?

00:04:47.000 --> 00:05:00.000
新しいHealthKitクエリ、HKVerifiableClinicalRecordQuery、および新しいHKSampleサブクラス、HKVerifiableClinicalRecord for iOS 15を導入しています。

00:05:00.000 --> 00:05:10.000
他のHKQueryサブクラスとは異なり、このクエリを使用するには、検証可能な健康記録のHealthKitアクセス資格をリクエストする必要があります。

00:05:10.000 --> 00:05:19.000
SDKのパブリックヘッダーには引き続きアクセスできますが、結果ハンドラーはエンタイトルメントなしで承認拒否エラーを返します。

00:05:19.000 --> 00:05:25.000
開始方法については、このセッションに関連するリンクを参照してください。

00:05:25.000 --> 00:05:36.000
クエリとサンプルクラスを深く掘り下げる前に、検証可能な健康記録の承認を見てみましょう。これは、健康記録に慣れているものとはわずかに異なります。

00:05:36.000 --> 00:05:47.000
まず、検証可能な健康記録は、ユーザーがタイプではなく個々のサンプルを選択してアプリと共有するサンプルごとの承認パターンを観察します。

00:05:47.000 --> 00:05:56.000
このタイプの承認は、ユーザーにデータのより詳細な制御を提供し、プライバシーを保護する上で重要です。

00:05:56.000 --> 00:06:08.000
現在のHealthKit認証パターンは、2つのステップで構成されています。まず、読み取りと共有するタイプのユーザー認証を要求し、認証が付与されたらサンプルを照会します。

00:06:08.000 --> 00:06:12.000
検証可能な健康記録では、この最初のステップは必要ありません。

00:06:12.000 --> 00:06:26.000
代わりに、HKVerifiableClinicalRecordQueryのインスタンスが作成されて実行されると、承認シートが表示され、ユーザーはアプリと共有する個々のレコードを選択できます。

00:06:26.000 --> 00:06:32.000
共有後、選択したレコードはクエリの結果ハンドラに返されます。

00:06:32.000 --> 00:06:37.000
さらに、検証可能な健康記録の承認は1回限りです。

00:06:37.000 --> 00:06:44.000
これらのレコードをサードパーティのアプリと共有しても、長期アクセス許可は設定されません。

00:06:44.000 --> 00:06:56.000
HKVerifiableClinicalRecordQueryの各実行により、次の承認シートが提示され、ユーザーが選択したレコードが結果ハンドラに返されます。

00:06:56.000 --> 00:07:03.000
承認を確認したので、HKVerifiableClinicalRecordQueryをもっと詳しく見てみましょう。

00:07:03.000 --> 00:07:16.000
HKVerifiableClinicalRecordQueryを初期化するには、まず、検証可能な健康記録に存在するデータの種類として以前に定義したレコードタイプの文字列配列を提供する必要があります。

00:07:16.000 --> 00:07:24.000
提供されたすべてのレコードタイプが存在するレコードのみが承認シートに表示されます。

00:07:24.000 --> 00:07:32.000
他のHealthKitクエリと同様に、承認のためにサンプルのセットをさらにフィルタリングするために述語を追加するオプションもあります。

00:07:32.000 --> 00:07:40.000
日付間隔内で関連する日付を持つレコードの述語を作成するための便利なコンストラクタを提供しています。

00:07:40.000 --> 00:07:50.000
クエリが実行され、ユーザーが「一度共有」をタップすると、承認されたHKVerifiableClinicalRecordsが結果ハンドラに返されます。

00:07:50.000 --> 00:08:02.000
レコードには、サブジェクトと発行者に関する基本情報、そしてもちろん、検証およびデコードする生データを含むJWSプロパティが含まれています。

00:08:02.000 --> 00:08:18.000
検証可能な健康記録機能とそのAPIがどのように見えるかを確認したので、テストデータをインポートし、APIを使用してレコードを要求し、レコードのJWSを確認する方法をCaryに渡します。

00:08:18.000 --> 00:08:19.000
ありがとう、アニー。

00:08:19.000 --> 00:08:20.000
みなさん、こんにちは。

00:08:20.000 --> 00:08:23.000
私の名前はケーリーで、健康記録チームのエンジニアでもあります。

00:08:23.000 --> 00:08:27.000
今日は、検証可能な健康記録の操作方法を説明します。

00:08:27.000 --> 00:08:34.000
したがって、この新機能で作業を開始する最善の方法は、いくつかのテストデータをHealthKitにロードすることです。

00:08:34.000 --> 00:08:39.000
アニーが述べたように、始めるために使用できる3つの異なる方法があります。

00:08:39.000 --> 00:08:49.000
米国、カナダ、または英国にいる場合は、健康アプリの既存の健康記録機能を使用してプロバイダーに接続するだけです。

00:08:49.000 --> 00:09:00.000
私たちが追加したもう1つの新しい方法は、.smart-health-cardファイルをダウンロードすることです。その例は、smarthealth.cards仕様のウェブサイトで見つけることができます。

00:09:00.000 --> 00:09:04.000
3番目の方法は、QRコードをスキャンすることです。

00:09:04.000 --> 00:09:06.000
では、データを取りに行きましょう。

00:09:06.000 --> 00:09:12.000
このデモでは、新しいQRコードのインポートを試すことから始めることができます。

00:09:12.000 --> 00:09:17.000
iOS 15を実行しているデバイスから始めて、このQRコードをスキャンします。

00:09:17.000 --> 00:09:21.000
スキャンするとすぐに、健康アプリに直接開くようにプロンプトが表示されます。

00:09:21.000 --> 00:09:25.000
健康アプリに切り替えると、すぐにこの健康カードのインポートを案内し始めます。

00:09:25.000 --> 00:09:30.000
「健康に追加」オプションを選択すると、インポートプロセスが完了します。

00:09:30.000 --> 00:09:35.000
ブラウズタブまでスクロールして、予防接種セクションでインポートされたレコードを見ることができます。

00:09:35.000 --> 00:09:44.000
先に進んでこのカテゴリをタップすると、ワクチンを接種し、その署名が健康アプリによって確認されていることがわかります。

00:09:44.000 --> 00:09:51.000
署名入りのレコードが健康アプリにインポートされたので、自分のアプリからこれらのレコードをリクエストする準備が整いました。

00:09:51.000 --> 00:09:56.000
では、アプリがこの新しいAPIにアクセスする方法の例を見てみましょう。

00:09:56.000 --> 00:09:58.000
まず、HealthKitをインポートすることから始めます。

00:09:58.000 --> 00:10:06.000
次に、HealthStoreを作成します。標準のHealthKit認証APIを使用している場合は、すでに慣れているかもしれません。

00:10:06.000 --> 00:10:12.000
また、レコードタイプのリストを作成して、ユーザーがあなたと共有するデータの種類を指定します。

00:10:12.000 --> 00:10:18.000
承認時に、これらのレコードタイプにのみ一致する共有するデータのリストが表示されます。

00:10:18.000 --> 00:10:23.000
次に、サンプルを共有するための有効な日付範囲を指定する述語を作成します。

00:10:23.000 --> 00:10:30.000
この例では、過去7日間に実施されたラボが要求されていることがわかります。

00:10:30.000 --> 00:10:39.000
次に、構築されたrecordTypesと述語を使用してクエリを作成し、完了を使用して、提示されたサンプルがアプリと共有されているかどうかを確認します。

00:10:39.000 --> 00:10:47.000
最後に、クエリを実行すると、承認シートが表示され、結果を選択してアプリと共有できます。

00:10:47.000 --> 00:10:51.000
このダイアログは、このメソッドが実行されるたびに表示されます。

00:10:51.000 --> 00:10:57.000
署名された臨床データを取得したので、アプリ内で署名を確認するためのコードを書くことができます。

00:10:57.000 --> 00:11:03.000
レビューのために、デジタル署名は、デジタル情報の真正性を検証する数学的な方法です。

00:11:03.000 --> 00:11:13.000
このプロセスは、サーバーや他のモバイルデバイスなど、どのデバイスでも実行できますが、アプリ内から実行する方法を見てみましょう。

00:11:13.000 --> 00:11:16.000
これは4つの主要なステップで達成できます。

00:11:16.000 --> 00:11:20.000
まず、Codableを使用して臨床データを解析します。

00:11:20.000 --> 00:11:24.000
次に、署名されたJSON Webトークンペイロードを解凍します。

00:11:24.000 --> 00:11:28.000
第三に、発行者のウェブサイトから発行者の公開鍵をダウンロードします。

00:11:28.000 --> 00:11:32.000
そして最後に、CryptoKitを使用して署名を確認します。

00:11:32.000 --> 00:11:41.000
まず、JSON Web署名仕様で正式に定義されている署名付きレコードのデータモデルを定義する方法を見てみましょう。

00:11:41.000 --> 00:11:47.000
この構造体は、ヘッダー、ペイロード、署名の3つの主要な部分で定義されています。

00:11:47.000 --> 00:11:56.000
Swift Codableを使用して解析を行うことができ、署名検証中に使用するためにヘッダーとペイロードの元の表現を保持する必要があります。

00:11:56.000 --> 00:12:03.000
最も重要なことは、コンパクトなシリアル化された形式からJWSを解析するための初期化子を追加することです。

00:12:03.000 --> 00:12:07.000
次に、JWSヘッダーを表すために使用される構造体を作成します。

00:12:07.000 --> 00:12:14.000
コンパクトなシリアル化からの初期化時、および署名検証プロセス中にこれが必要になります。

00:12:14.000 --> 00:12:25.000
ヘッダーには、指定された署名アルゴリズム、公開鍵の親指印を保持するために使用されるキーIDフィールド、および圧縮アルゴリズムが見つかることが期待できます。

00:12:25.000 --> 00:12:31.000
公開鍵の拇印は、発行者のキーのどれがJWSに署名するために使用されたかを識別するために使用されます。

00:12:31.000 --> 00:12:41.000
このプロセスには、ES256署名アルゴリズムとDEF圧縮アルゴリズムが必要で、どちらもファーストパーティのSwiftライブラリでサポートされています。

00:12:41.000 --> 00:12:46.000
それでは、コンパクトなシリアル化からJWSを解析するために必要なコードを見てみましょう。

00:12:46.000 --> 00:12:55.000
シリアル化された文字列を構成部分に分割することから始めます。それぞれがBase64URLでエンコードされています。

00:12:55.000 --> 00:13:05.000
JSONDecoderとBase64URLを作成してヘッダーとペイロードをデコードした後、ヘッダーがペイロードが正しく圧縮されていることを示しているかどうかを確認できます。

00:13:05.000 --> 00:13:15.000
圧縮を確認した後、提供されたサンプルプロジェクトで見つけることができるユーティリティメソッドを使用してペイロードを解凍します。

00:13:15.000 --> 00:13:20.000
次に必要なのは、ヘルスカードのペイロードをモデル化するための構造体です。

00:13:20.000 --> 00:13:32.000
ここで最も重要な2つの部分は、キーを取得するために使用できる発行者のWeb識別子を保持する発行者フィールドであり、もう1つはすべての患者データを保持するVCフィールドです。

00:13:32.000 --> 00:13:41.000
VCフィールドを解析し、その内容を分析する方法の詳細については、WWDC 2020の「燃やされることなくFHIRを扱う」トークをチェックしてください。

00:13:41.000 --> 00:13:47.000
JWSを解析する方法を見たので、その真正性を確認する準備が整いました。

00:13:47.000 --> 00:13:52.000
JWS構造体に検証方法を追加する拡張機能の作成を見てみましょう。

00:13:52.000 --> 00:14:04.000
発行者のウェブサイトに直接連絡して署名キーを取得するため、Combineを使用してこのプロセスの非同期の側面を支援し、CryptoKitを使用して署名検証を支援することができます。

00:14:04.000 --> 00:14:12.000
検証方法の中では、常に発行者のウェブアドレスである発行者の識別子を引き出すことから始めます。

00:14:12.000 --> 00:14:20.000
ここでは、独自のメソッドを追加して、URLが個人的に信頼できるものであるかどうかを確認し、結果を受け入れたくないものである場合は中止することができます。

00:14:20.000 --> 00:14:30.000
次に、標準の.wellknown/jwks.json URLパスを追加して、発行者のキーを取得するURLを作成します。

00:14:30.000 --> 00:14:36.000
このパスサフィックスは仕様で定義されており、すべての発行者で同じである必要があります。

00:14:36.000 --> 00:14:46.000
よく知られているURLを構築したので、発行者に接続し、キーをダウンロードし、署名の確認を完了することができます。

00:14:46.000 --> 00:14:54.000
このメソッドの作成を完了するには、発行者のよく知られたjwkエンドポイントに接続するURLSession dataTaskPublisherを作成します。

00:14:54.000 --> 00:15:05.000
その後、それをデータにマッピングし、jsonDecoderを使用してJWKのセットにデコードし、最後にブール値にマッピングして、署名が有効かどうかを示すことができます。

00:15:05.000 --> 00:15:12.000
最終的なマップブロック内では、JWSヘッダーが示すものに基づいて発行者のキーを選択します。

00:15:12.000 --> 00:15:17.000
最後の作品は、署名を検証するためにCryptoKitを使用することです。

00:15:17.000 --> 00:15:27.000
JWS仕様によると、データの符号付き部分は、Base64URLエンコードされたヘッダーとペイロードをピリオドで結合することによって形成されます。

00:15:27.000 --> 00:15:39.000
次に、この講演に付随するサンプルプロジェクトで見つけることができるユーティリティメソッドを使用して、ダウンロードしたJWKキーをCryptoKit P256署名キーに変換します。

00:15:39.000 --> 00:15:45.000
最後に、CryptoKitのisValidSignatureメソッドを使用して署名の検証を行います。

00:15:45.000 --> 00:15:52.000
データモデルとその真正性を検証するために必要なすべてのロジックが定義されたので、すべてをまとめることができます。

00:15:52.000 --> 00:16:01.000
新しいAPIを呼び出す方法の以前の例を見て、このコメントを新しい検証メソッドの呼び出しに置き換えることができます。

00:16:01.000 --> 00:16:07.000
APIは選択したすべてのサンプルのリストを返すので、リストから最初のサンプルを選択できます。

00:16:07.000 --> 00:16:10.000
次に、データから文字列に解析します。

00:16:10.000 --> 00:16:14.000
次に、コンパクトなシリアライゼーション初期化子を使用して解析します。

00:16:14.000 --> 00:16:19.000
最後に、新しい検証方法を呼び出し、発行されたブール結果をリッスンします。

00:16:19.000 --> 00:16:27.000
そして、そのように、署名された臨床データの一部を取り、発行者の署名キーをダウンロードし、これらのレコードの署名を検証する方法を見てきました。

00:16:27.000 --> 00:16:30.000
さて、私は要約するためにアニーに物事を返します。

00:16:30.000 --> 00:16:31.000
ありがとう、ケーリー。

00:16:31.000 --> 00:16:38.000
締めくくる前に、検証可能な健康記録に関するプライバシーについて話したいと思います。

00:16:38.000 --> 00:16:46.000
うまくいけば、このセッションを通して、検証可能な健康記録機能はユーザーのプライバシーを念頭に置いて構築されていることを明確にしました。

00:16:46.000 --> 00:16:56.000
まず第一に、SMART Health Cardの仕様は、発行者が各レコードに含めるべき情報を最小限に抑えるデータプロファイルを使用します。

00:16:56.000 --> 00:17:08.000
健康アプリは機密性の高い健康データを保護するように設計されているため、電話がロックされると、健康アプリ内のすべての健康とフィットネスデータが暗号化され、検証可能な健康記録が含まれます。

00:17:08.000 --> 00:17:20.000
検証可能な健康記録にアクセスするには、この機密性の高い健康データが悪用されないようにするための追加の義務を伴う資格への申請が必要です。

00:17:20.000 --> 00:17:28.000
そして最後に、ユーザーは検証可能な健康記録をアプリと共有する方法をさらに制御できます。

00:17:28.000 --> 00:17:30.000
今日取り上げたことを復習しましょう。

00:17:30.000 --> 00:17:42.000
iOS 15では、健康記録の上に構築され、検証可能な記録を健康アプリにインポートし、開発者が新しいAPIでこのデータを読み取る機能を導入しています。

00:17:42.000 --> 00:17:47.000
まとめると、次にできることは次のとおりです。

00:17:47.000 --> 00:17:55.000
まず、検証可能な健康データエコシステムの詳細については、SMARTヘルスカードの仕様を確認してください。

00:17:55.000 --> 00:18:00.000
テスト記録を健康アプリにインポートして、自分で試してみてください。

00:18:00.000 --> 00:18:06.000
これらのテスト記録を照会して検証する方法を示すサンプルアプリをダウンロードしてください。

00:18:06.000 --> 00:18:14.000
そして最後に、アプリを出荷する準備ができたら、検証可能な健康記録のHealthKitアクセス権をリクエストしてください。

00:18:14.000 --> 00:18:18.000
ご覧いただきありがとうございます、そして素晴らしいWWDCをお過ごしください。

00:18:18.000 --> 23:59:59.000
[音楽]。

