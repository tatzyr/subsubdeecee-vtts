WEBVTT

00:00:00.000 --> 00:00:05.000
♪ベース音楽の演奏♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:12.000
Becca Royal-Gordon:こんにちは、私はSwift CompilerチームのBeccaです。

00:00:12.000 --> 00:00:17.000
今日は、SwiftでDSLを実装する方法について話します。

00:00:17.000 --> 00:00:25.000
その用語を聞いたことがないなら、DSLはドメイン固有の言語であり、名前が新しい場合でも、おそらく以前に使用したことがあるでしょう。

00:00:25.000 --> 00:00:31.000
DSLが実際に何であり、Swiftでどのように見えるかを説明することから始めます。

00:00:31.000 --> 00:00:34.000
次に、結果ビルダーがどのように機能するかを説明します。

00:00:34.000 --> 00:00:39.000
これらは、Swift DSLを実装するために使用される主な機能の1つです。

00:00:39.000 --> 00:00:46.000
その後、サンプルアプリFrutaの一部にシンプルなDSLを設計する方法を説明します。

00:00:46.000 --> 00:00:52.000
最後に、Frutaのサンプルコードにある実装の書き方を紹介します。

00:00:52.000 --> 00:00:56.000
しかし、その頭字語をもう少しうまく説明することから始めましょう。

00:00:56.000 --> 00:01:05.000
DSLは、「ドメイン」と呼ばれる特定の領域で動作するプログラム用に設計されたミニチュアプログラミング言語の一種です。

00:01:05.000 --> 00:01:12.000
言語は特定の種類の作業を念頭に置いて設計されているため、そのような作業を容易にする特別な機能を持つことができます。

00:01:12.000 --> 00:01:21.000
したがって、汎用言語の代わりにDSLのコードを書くときは、正確な問題に固有のものを書くだけで済みます。

00:01:21.000 --> 00:01:23.000
多くのDSLは宣言的です。

00:01:23.000 --> 00:01:32.000
つまり、あなたは本当に問題を解決するための正確な指示を書いていません。それはあなたが言語で問題を説明しているようなもので、それはあなたのためにそれを解決します。

00:01:32.000 --> 00:01:36.000
これを行う伝統的な方法は「スタンドアロンDSL」と呼ばれています。

00:01:36.000 --> 00:01:43.000
言語全体をゼロから設計し、インタプリタやコンパイラを書きます。

00:01:43.000 --> 00:01:46.000
組み込みDSLは、より現代的な代替手段です。

00:01:46.000 --> 00:02:00.000
埋め込みDSLでは、Swiftのようなホスト言語の組み込み機能を使用して、DSLの暗黙の動作をコードの一部に追加し、ホスト言語をドメインに合わせたものに効果的に変更します。

00:02:00.000 --> 00:02:13.000
これは、すでに構文の基本を決定し、すでにコンパイラを持っている既存の言語から始めているので、言語全体を設計してコンパイラを書くよりも明らかに簡単です。

00:02:13.000 --> 00:02:17.000
また、DSLコードと非DSLコードを混在させるのも簡単になります。

00:02:17.000 --> 00:02:22.000
多くの場合、DSLを使用して、はるかに大きなアプリの一部にすぎない問題を解決したいと考えています。

00:02:22.000 --> 00:02:28.000
スタンドアロンのDSLを書いている場合は、ある言語から別の言語に電話をかける方法を設計する必要があります。

00:02:28.000 --> 00:02:38.000
埋め込みDSLでは、DSLに書き込まれた部分はアプリの残りの部分に対して通常のコードのように見えるので、相互運用がはるかに簡単になります。

00:02:38.000 --> 00:02:42.000
組み込みDSLは、ホスト言語用に設計されたツールを使用することもできます。

00:02:42.000 --> 00:02:53.000
あなたはすでにSwift用のデバッガとエディタを持っており、それらはSwift DSLではうまく機能します。スタンドアロンDSL用にそれらが欲しい場合は、自分で書く必要があります。

00:02:53.000 --> 00:02:59.000
そして、あなたはホスト言語から始めているので、すでにその言語を知っているクライアントは学ぶことがはるかに少ないです。

00:02:59.000 --> 00:03:08.000
彼らはすでに変数を宣言する方法、または「else if」にスペースがあるかどうかを知っています。彼らが学ぶ必要があるのは、言語をどのようにカスタマイズしたかだけです。

00:03:08.000 --> 00:03:11.000
Swiftは組み込みDSLをサポートするように設計されています。

00:03:11.000 --> 00:03:15.000
実際、SwiftUIを使用したことがあるなら、すでに使用しています。

00:03:15.000 --> 00:03:21.000
SwiftUIビューDSLは、デバイスの画面上のビューのレイアウトを記述することを前提としています。

00:03:21.000 --> 00:03:31.000
したがって、SwiftUI DSLで書くとき、カスタムコードは単にビューを作成し、DSLはSwiftUIが処理するためのツリーを構築する責任があります。

00:03:31.000 --> 00:03:39.000
DSLの価値を理解するには、代わりに通常のSwiftでビューを書いた場合、SwiftUIがどのようなものになるかを考えてください。

00:03:39.000 --> 00:03:45.000
ビューを作成し、変更し、他のビューに追加し、最後に1つを返す必要があります。

00:03:45.000 --> 00:03:54.000
個々のビューを保持するためにいたるところに一時的な変数を作成し、結果はDSLと同じようにビューがネストされる方法を本当に伝えません。

00:03:54.000 --> 00:03:58.000
あなたはより多くのコードを書くだろうが、それはより少ない意味を伝えるだろう。

00:03:58.000 --> 00:04:03.000
対照的に、SwiftUI DSLは、これらの退屈な詳細をすべて暗黙的にします。

00:04:03.000 --> 00:04:11.000
ビューを記述するのがあなたの仕事です。あなたが記述しているビューを収集し、それらを表示する方法を理解するのがDSLの仕事です。

00:04:11.000 --> 00:04:15.000
しかし、DSLは実装に余分な労力を費やし、使用には余分な労力を費やします。

00:04:15.000 --> 00:04:18.000
では、いつ作成したいですか?

00:04:18.000 --> 00:04:25.000
さて、難しいルールはありませんが、ここにあなたが1つを使用したいと思うかもしれないいくつかの兆候があります。

00:04:25.000 --> 00:04:31.000
バニラスウィフトを使用する仕組みがコードの意味を不明瞭にする場所を探してください。

00:04:31.000 --> 00:04:41.000
何かを変更するたびにカンマと角括弧と括弧の再配置に半分の時間を費やしたり、制御フローに対応するために一時的な配列に物事を追加する必要があります。

00:04:41.000 --> 00:04:49.000
コードをどうするかについての指示を直接書くのではなく、コードの別の部分に何かを記述するのが最善のアプローチである状況を探してください。

00:04:49.000 --> 00:04:57.000
サーバーサイドのWebフレームワークのように、サポートするURLのハンドラーを登録する領域があるかもしれません。

00:04:57.000 --> 00:05:08.000
追加ハンドラメソッドを何度も呼び出す代わりに、クライアントが各URLとそのハンドラを宣言するためのDSLを設計し、フレームワークは自動的にそれらを登録することができます。

00:05:08.000 --> 00:05:13.000
主な仕事がプログラミングではない人々によって維持されるコードの一部を探してください。

00:05:13.000 --> 00:05:25.000
例えば、テキストアドベンチャーゲームを書いていると想像してみてください。少数の開発者だけがほとんどのコードで作業しますが、部屋のマップはゲームデザイナーによって更新され、NPCダイアログはライターによって追加されます。

00:05:25.000 --> 00:05:29.000
たぶん、DSLは彼らの仕事を楽にするでしょう。

00:05:29.000 --> 00:05:34.000
そして、DSLから多くの走行距離を得る状況を探してください。

00:05:34.000 --> 00:05:38.000
図書館は、多くの異なるクライアントによって使用されるため、良い例です。

00:05:38.000 --> 00:05:49.000
しかし、良いDSLは、あなたがたくさん定義するプロジェクト内の何かを処理したり、頻繁に読んだり更新したりしなければならないものでさえ、それをできるだけ簡単にすることもできます。

00:05:49.000 --> 00:06:00.000
DSLを作成する理由が何であれ、設計と実装にいくらかの努力がかかるだけでなく、クライアントが学ぶのにもいくらかの努力がかかるという事実とのバランスを取る必要があります。

00:06:00.000 --> 00:06:10.000
メソッドと配列リテラルがDSLとほぼ同じであるならば、Swiftプログラマーはすでにそれらの使用方法を正確に知っているので、それらはしばしば正しい答えです。

00:06:10.000 --> 00:06:14.000
しかし、時には、SwiftUIのように、DSLが正しい答えです。

00:06:14.000 --> 00:06:17.000
それで、どうやって作るの?

00:06:17.000 --> 00:06:23.000
さて、SwiftUI DSLを構築するためにSwiftの機能がどのように一緒に使用されるかを分解してみましょう。

00:06:23.000 --> 00:06:30.000
Swiftの一般的にクリーンな構文に加えて、SwiftUI DSLは4つのことを利用します。

00:06:30.000 --> 00:06:31.000
プロパティラッパー。

00:06:31.000 --> 00:06:36.000
これにより、クライアントはDSLの動作に関連付けられた変数を宣言できます。

00:06:36.000 --> 00:06:38.000
末尾の議論。

00:06:38.000 --> 00:06:46.000
これにより、DSLは、言語に追加されたカスタム構文のように読む関数または初期化子を提供できます。

00:06:46.000 --> 00:06:48.000
結果ビルダー。

00:06:48.000 --> 00:06:54.000
これらは、DSLのコードで計算された値を戻り値に収集するので、それらを処理できます。

00:06:54.000 --> 00:06:57.000
そして最後に、修飾子スタイルのメソッド。

00:06:57.000 --> 00:07:07.000
これらは基本的に、呼び出された値のラップまたは変更されたバージョンを返す単なるメソッドです。結果ビルダーはコードによって計算された値を収集するため、このパターンはそれらと本当にうまく機能します。

00:07:07.000 --> 00:07:15.000
さて、プロパティラッパーは2019年からこのセッションの後半ですでにカバーされていたので、今日はそれらについてあまり話すつもりはありません。

00:07:15.000 --> 00:07:21.000
しかし、これらの他の3つ、特に結果ビルダーは、このセッションの主要なトピックになります。

00:07:21.000 --> 00:07:30.000
末尾のクロージャと修飾子スタイルのメソッドは、多くのSwiftプログラマーが慣れ親しんでいるものですが、結果ビルダーはより舞台裏の機能です。

00:07:30.000 --> 00:07:35.000
それでは、彼らと一緒にDSLの構築を開始できるように、彼らがどのように機能するかについて話しましょう。

00:07:35.000 --> 00:07:44.000
結果ビルダーは、DSLで作成された値を収集し、言語が望むデータ構造にそれらを縫い合わせるために使用されます。

00:07:44.000 --> 00:07:51.000
それらは、特別な型を宣言し、その型を属性として使用できるという点で、プロパティラッパーに少し似ています。

00:07:51.000 --> 00:08:02.000
具体的には、関数やメソッド、計算されたプロパティのゲッター、クロージャなど、戻り値を持つほぼすべての関数本体に結果ビルダーを適用できます。

00:08:02.000 --> 00:08:08.000
結果ビルダーを関数本体に適用すると、Swiftは結果ビルダーに静的メソッドへのさまざまな呼び出しを挿入します。

00:08:08.000 --> 00:08:13.000
これらは、そうでなければ破棄されていたであろうステートメントの結果をキャプチャすることになります。

00:08:13.000 --> 00:08:20.000
したがって、Swiftは通常戻り値を無視し、代わりに結果ビルダーに渡されます。

00:08:20.000 --> 00:08:24.000
これらの呼び出しは、最終的に関数本体から返される値を計算します。

00:08:24.000 --> 00:08:35.000
したがって、関数を呼び出すと、その関数内のすべてのステートメントを正常に実行し、それらによって生成された値を収集し、それらを単一の値に結合して、クロージャの結果になります。

00:08:35.000 --> 00:08:41.000
結果ビルダーはコンパイル時機能であるため、アプリが実行されるOSで動作します。

00:08:41.000 --> 00:08:52.000
オープンソースのSwift Evolution提案289からのこの機能の最終バージョンは、Swift 5.4に含まれていたため、4月にXcode 12.5で出荷されました。

00:08:52.000 --> 00:08:59.000
しかし、この機能のプロトタイプはその前に利用可能だったので、プロトタイプを使用する古いチュートリアルやライブラリが見られるかもしれません。

00:08:59.000 --> 00:09:05.000
それらは「結果ビルダー」ではなく「ファンクションビルダー」と言い、最終的な機能と完全に一致しないかもしれません。

00:09:05.000 --> 00:09:11.000
そこで、私は以前にSwiftUI DSLで使用されている機能を指摘しましたが、それらがどのように機能するかについて話しましょう。

00:09:11.000 --> 00:09:25.000
いくつかのSwiftUIタイプの無関係な部分を削除したり、コンパイラによって生成された変数のv0のような偽の変数名を表示したりなど、いくつかの詳細を簡素化しますが、これは基本を理解するのに役立つはずです。

00:09:25.000 --> 00:09:34.000
最初に気づくべきことは、トップレベルでは、新しい構文のように見えるブロックを持つこのVStackのものは、実際には末尾のクロージャ引数であるということです。

00:09:34.000 --> 00:09:39.000
VStackが何であるかを調べると、SwiftUIの構造体であることがわかります。

00:09:39.000 --> 00:09:44.000
したがって、末尾のクロージャ引数は、その構造体上のこの初期化子に渡されます。

00:09:44.000 --> 00:09:51.000
さて、クロージャが渡されるパラメータを見ると、ViewBuilder属性があることがわかります。

00:09:51.000 --> 00:09:56.000
その属性は、ViewBuilderという名前の結果ビルダーをクロージャに適用する必要があることをコンパイラに伝えます。

00:09:56.000 --> 00:09:58.000
しかし、ViewBuilderとは何ですか?

00:09:58.000 --> 00:10:03.000
さて、私たちはその名前の型を探し、再びSwiftUIでこの型を見つけます。

00:10:03.000 --> 00:10:10.000
結果ビルダーであることをコンパイラに伝えるために、@resultBuilder属性があることに注意してください。

00:10:10.000 --> 00:10:16.000
Swiftが結果ビルダータイプを見つけたので、それをクロージャに適用し始めます。

00:10:16.000 --> 00:10:23.000
最初に行うことは、結果を生成するすべてのステートメントの変数を作成することです。

00:10:23.000 --> 00:10:31.000
これらの変数が作成されると、ViewBuilderのbuildBlockメソッドへの呼び出しを書き、それらの変数をすべて渡します。

00:10:31.000 --> 00:10:38.000
buildBlockの仕事は、すべてのパラメータを1つの値に処理または結合し、それを返すことです。

00:10:38.000 --> 00:10:43.000
次に、コンパイラは、クロージャからbuildBlockの結果を返すreturn文を書き込みます。

00:10:43.000 --> 00:10:54.000
したがって、基本的に、コンパイラはコードを取り、黄色のコードを追加して、ViewBuilderが作成したすべての値をVStackがコンテンツとして使用する単一の値に組み立てることができるようにしました。

00:10:54.000 --> 00:10:58.000
さて、修飾子スタイルのメソッドがこれにどのように適合するかを指摘したいと思います。

00:10:58.000 --> 00:11:06.000
修飾子スタイルのメソッドは、自己の変更されたコピーまたは新しい動作を追加する別のタイプでラップされた自己のコピーのいずれかを返します。

00:11:06.000 --> 00:11:10.000
そして、それは最初に自己を創造したのと同じ声明の中でこれを行います。

00:11:10.000 --> 00:11:14.000
そのため、結果ビルダーがそれを見る前に値を変更することになります。

00:11:14.000 --> 00:11:24.000
また、そのメソッドの結果で他の修飾子スタイルのメソッドを呼び出すことができるので、結果ビルダーが値を見る前に、いくつかの変更を適用して一緒に構成することができます。

00:11:24.000 --> 00:11:34.000
これらの2つのこと - 修飾子を作成する能力と、結果ビルダーがそれを見る前に値を変更するという事実 - は、Swift DSLがしばしば修飾子を使用する理由です。

00:11:34.000 --> 00:11:36.000
二人はただうまく機能する。

00:11:36.000 --> 00:11:48.000
さて、結果ビルダーを設計したときに心配していたことの1つは、Swiftの動作をあまりにも根本的に変更させると、クライアントはDSLの何かが通常のSwiftコードのように機能することを信頼できないということでした。

00:11:48.000 --> 00:12:00.000
そのため、結果ビルダーを設計したとき、有用なDSLを作るのに十分な電力を持つことと、Swiftの機能がクライアントが期待どおりに機能することを確認することのバランスを取ろうとしました。

00:12:00.000 --> 00:12:04.000
結果ビルダーは、クライアントが書き込むコードを根本的に再解釈しません。

00:12:04.000 --> 00:12:16.000
ステートメントはまだ改行で終わり、呼び出しはまだ括弧を使用し、波括弧はまだ一致する必要があります。Swift構文の基本はすべて、クライアントが期待するとおりに機能します。

00:12:16.000 --> 00:12:23.000
また、同じ場所に書かれた通常のコードからは見えない新しい名前も導入しません。

00:12:23.000 --> 00:12:37.000
結果ビルダーを使用しているときにはあまり意味をなさない言語機能がいくつかあります - 主にキャッチやブレークのようなもので、ステートメントの結果をキャプチャして使用するという考えにうまく適合しない方法で制御フローを中断します。

00:12:37.000 --> 00:12:41.000
これらの機能は、結果ビルダーを使用しているときに無効になります。

00:12:41.000 --> 00:12:51.000
また、if、switch、for-inステートメントなど、結果ビルダーがそれらを実装するために使用される追加のメソッドを提供しない限り、無効になっているいくつかの機能があります。

00:12:51.000 --> 00:12:56.000
しかし、Swiftがキーワードの使用を許可する場合、それは通常どおりに機能します。

00:12:56.000 --> 00:13:03.000
Trueブロックとfalseブロックの両方を実行するif-elseステートメントや、いくつかの要素をスキップするループなどでは終わりません。

00:13:03.000 --> 00:13:09.000
結果ビルダーは、そうでなければ捨てられたであろうステートメント結果をキャプチャするだけで、それ以上ではありません。

00:13:09.000 --> 00:13:14.000
だから、クライアントはそれらを頼りにすることができます、あなたが知っている、理にかなっています。

00:13:14.000 --> 00:13:24.000
OK。結果ビルダーとは何か、どのように機能するかがわかったので、それらを使用するDSLの設計を開始できます。

00:13:24.000 --> 00:13:34.000
以前に言語に取り組んだことがない場合は、その考えが威圧的になるかもしれませんが、Swift DSLの設計は、実際にはSwift APIの設計とよく似ています。

00:13:34.000 --> 00:13:46.000
Swift APIのように、Swift DSLはゼロから始めるのではなく、Swiftの構文と機能を使用して、解決しようとしている問題に関連するアイデアや行動を表現します。

00:13:46.000 --> 00:13:52.000
DSLは、APIが通常使用しない追加機能を使用しているだけです。

00:13:52.000 --> 00:14:08.000
Swift APIのように、Swift DSLはすべて問題を解決するいくつかの異なる方法で設計することができるので、あなたの仕事は代替案を考え、あなたが最善だと思うものを選択することです。DSLは、潜在的なソリューションのはるかに大きなスペースを持っています。

00:14:08.000 --> 00:14:16.000
そして、Swift APIのように、Swift DSLの最高の経験則は、通常、最も明確な使用サイトをもたらすデザインを選択することです。

00:14:16.000 --> 00:14:27.000
DSLは、クライアントが事前に言語学習に少し時間を投資することを前提としているため、これまでに見たことのない人々に明確にすることをあまり優先しません。

00:14:27.000 --> 00:14:33.000
したがって、以前にAPIを設計したことがある場合は、DSLを設計するための良い出発点があります。

00:14:33.000 --> 00:14:39.000
そして、そのことについては、私がDSLに使用する提案やテクニックのいくつかは、API設計に本当にうまく転送されます。

00:14:39.000 --> 00:14:43.000
この講演では、アプリFruta用のDSLを設計します。

00:14:43.000 --> 00:14:49.000
Frutaのサンプルコードで、これの実用的な実装を見つけることができます。

00:14:49.000 --> 00:15:00.000
Frutaにはソースコードに15のスムージーレシピが含まれており、DSLの前に、メンバーワイズ初期化子を呼び出して静的定数に割り当てるだけで、各スムージーを作成しました。

00:15:00.000 --> 00:15:13.000
そして、すべてのスムージーの配列を別の静的定数に保存し、特定のビューにアプリ内購入が必要なレシピを含めるかどうかに応じて、リスト全体を返すか、有料レシピを除外します。

00:15:13.000 --> 00:15:17.000
さて、これは完全に出荷可能であり、あなたが望むなら、あなたはそれに固執することができます。

00:15:17.000 --> 00:15:31.000
しかし、スムージーのレシピはかなり頻繁に更新され、アプリの残りの部分とは異なり、デザイナーやマーケティング担当者やマネージャーによって更新されるので、DSLを少し複雑にしたいかもしれません。

00:15:31.000 --> 00:15:36.000
そして、私たちが今やっている方法を見ると、私はいくつかの欠点に気づかずにはいられません。

00:15:36.000 --> 00:15:41.000
有料のスムージーをリストから除外する必要性は、このコードを歪めました。

00:15:41.000 --> 00:15:48.000
allSmoothiesとhasFreeRecipeは、この機能でのみ使用されます。そうでなければ、存在する必要はありません。

00:15:48.000 --> 00:15:54.000
しかし、それらなしでこれを実装することを想像しようとすると、私たちがそれをしなかった理由がわかります。

00:15:54.000 --> 00:16:03.000
配列を作成し、それに要素を追加する仕組みは、この関数のポイントのようなものであるスムージーの実際のリストをあいまいにし始めます。

00:16:03.000 --> 00:16:09.000
同様に、スムージーのリストがスムージーの定義とは別のものであるという事実は少しばかげています。

00:16:09.000 --> 00:16:15.000
これらの定数のいくつかはプレビューで使用されますが、そのほとんどはこのリストにのみ表示されます。

00:16:15.000 --> 00:16:22.000
また、ある場所でスムージーを定義し、別の場所でリストに追加すると、間違いの機会が生まれます。

00:16:22.000 --> 00:16:26.000
新しいスムージー定数を宣言しても、リストに追加するのを忘れた場合はどうなりますか？

00:16:26.000 --> 00:16:29.000
または、スムージーを2回追加するとどうなりますか?

00:16:29.000 --> 00:16:36.000
個々のスムージーの定義を振り返ってみると、私を悩ませる他の2つのことも見られます。

00:16:36.000 --> 00:16:40.000
1つは、成分リストが信じられないほど冗長であるということです。

00:16:40.000 --> 00:16:45.000
例えば、各エントリは「測定」という言葉のいくつかのバージョンを3回繰り返します。

00:16:45.000 --> 00:16:51.000
この行では、私たちが気にかけている実際の情報は1.5カップのオレンジです。

00:16:51.000 --> 00:16:55.000
行の残りの部分は有用なことを言っていません。それはただの視覚的な混乱です。

00:16:55.000 --> 00:17:06.000
必然的に重要な情報の周りにいくつかのサポート構文があるでしょうが、これほどあるとき、その周りの定型文は私たちが伝えようとしている情報を圧倒するだけです。

00:17:06.000 --> 00:17:13.000
私が気づいたもう一つのことは、実際に存在する情報の量と比較して、各スムージーに捧げられた行の数です。

00:17:13.000 --> 00:17:18.000
ここでの犯人は、議論の長さの違いだと思います。

00:17:18.000 --> 00:17:23.000
これらの議論のいくつかは非常に短く、単一の行にまとめることができます。

00:17:23.000 --> 00:17:27.000
他の人はより長く、本当に自分のラインが必要です。

00:17:27.000 --> 00:17:35.000
これで、短い引数を1行に結合し、長い引数に別々の行を使用できますが、ほとんどのスタイルガイドはそれに眉をひそめます。

00:17:35.000 --> 00:17:40.000
私たちは、異なるスタイルのスタイルが自然である構文を好みます。

00:17:40.000 --> 00:17:47.000
これらをまとめると、スムージーリストの維持を容易にするために、DSLに達成してもらいたい目標がたくさんあります。

00:17:47.000 --> 00:17:53.000
さて、次にやるべきことは、これらの目標を達成するためにDSLを設計できるさまざまな方法を検討することです。

00:17:53.000 --> 00:17:57.000
これらのポイントのそれぞれに対処するさまざまなデザインがたくさんあります。

00:17:57.000 --> 00:18:05.000
最初の3つの目標のために何をしようと決めたのかを簡単に説明し、最後の目標をより詳細に探求することができます。

00:18:05.000 --> 00:18:08.000
すべての方法でスムージーリストを定義することにしました。

00:18:08.000 --> 00:18:17.000
スムージーは静的変数を使用せずに体内で直接定義されるので、誰かがスムージーを定義し、それをリストするのを忘れることを心配する必要はありません。

00:18:17.000 --> 00:18:29.000
「SmoothieArrayBuilder」と呼ばれる結果ビルダーを使用して、DSLをアクティブにし、スムージーを配列に収集します。そうすれば、配列リテラルを使用したり、一時的な変数に収集したりする必要はありません。

00:18:29.000 --> 00:18:35.000
そして、スムージーをifステートメントに入れることを許可しますので、以前のようにリストをフィルタリングする必要はありません。

00:18:35.000 --> 00:18:47.000
Swiftをすでに知っているクライアントは、ifステートメントがどのように使用されるかを知っているでしょうし、そうでないクライアントはおそらく「有料を含む場合」をほとんど問題なく理解しないので、これは素晴らしいことです。

00:18:47.000 --> 00:18:51.000
修飾子スタイルの方法を使用して、成分の量を指定することにしました。

00:18:51.000 --> 00:18:59.000
成分には、「measured(with: )」と呼ばれる方法があり、単位を取り、その単位の1つで測定された成分を返します。

00:18:59.000 --> 00:19:07.000
その単位の異なる量が必要な場合は、測定された成分のスケーリングされた(by: )修飾子は、量に渡す数を乗じて返します。

00:19:07.000 --> 00:19:14.000
したがって、1カップのオレンジは1.5カップのオレンジになり、1カップのアボカドは0.2カップのアボカドになります。

00:19:14.000 --> 00:19:19.000
さて、なぜスケーリング(by: )は別の修飾子なのですか?

00:19:19.000 --> 00:19:25.000
Frutaのスクリーンの1つには、スムージーレシピの成分量をスケーリングするために使用できるコントロールがあります。

00:19:25.000 --> 00:19:30.000
私たちは以前、乗数を各成分行に渡し、その量を乗算しました。

00:19:30.000 --> 00:19:41.000
しかし、私は実際にスケーリングされた(by: )修飾子を使用して、代わりに成分が行に渡される前にスケーリングできることに気づきました。これにより、行ビューを簡素化できます。

00:19:41.000 --> 00:19:49.000
そのため、スムージーDSLのデザインを少し微調整することで、プロジェクトの別の部分でその一部を再利用することができました。

00:19:49.000 --> 00:19:54.000
したがって、最初の3つの目標を達成するための変更により、新しいDSLが形になり始めています。

00:19:54.000 --> 00:20:06.000
さて、最後の目標に焦点を当てましょう。個々のスムージーのエントリをよりコンパクトに再設計し、うまくいけば、クライアントがトリップできる紛らわしい句読点が少なくなります。

00:20:06.000 --> 00:20:11.000
それを助けるためにこの情報を手配できるいくつかの異なる方法を見てみましょう。

00:20:11.000 --> 00:20:17.000
私たちができることの1つは、修飾スタイルのメソッドを使用して説明と成分を追加することです。

00:20:17.000 --> 00:20:25.000
これはうまくいくでしょうが、それはちょっと冗長で、誰かが説明を忘れたり、2回指定したりするのは簡単です。

00:20:25.000 --> 00:20:30.000
もう1つできることは、各フィールドにマーカータイプを与え、結果ビルダーのクロージャに入れることです。

00:20:30.000 --> 00:20:36.000
しかし、これはIDとタイトルを独自の行に置き、それを避けようとしています。

00:20:36.000 --> 00:20:43.000
したがって、IDとタイトルをパラメータリストに戻し、他の2つのフィールドにマーカータイプを使用できるかもしれません。

00:20:43.000 --> 00:20:48.000
しかし、これはまだ私たちが本当に必要としているよりも少し多くの式典であるように感じます。

00:20:48.000 --> 00:20:52.000
レシピのユーザーインターフェースを見たとき、そのことに気づきました。

00:20:52.000 --> 00:21:02.000
それらは常に特定の順序で表示されます:上部にタイトル、中央に説明、下部に成分のリスト。

00:21:02.000 --> 00:21:05.000
そして、私たちはわざわざタイトルや説明にラベルを付けません。

00:21:05.000 --> 00:21:13.000
私たちは、彼らの視覚的な階層（タイトルが説明よりも目立つように提示されているという事実）に話をさせます。

00:21:13.000 --> 00:21:18.000
だから私はそれからいくつかのインスピレーションを得て、私たちのスムージーDSLも同じことをすべきだと決めました。

00:21:18.000 --> 00:21:25.000
上部にタイトル、中央に説明、下部に成分のリストを置きます。

00:21:25.000 --> 00:21:37.000
そして、説明が下にあり、タイトルよりもインデントされているため、視覚的に顕著ではないという事実は、説明文字列の意味を伝えるので、ラベルを付ける必要はありません。

00:21:37.000 --> 00:21:42.000
結果は不必要な合併症なしにすぐに理解できると思います。

00:21:42.000 --> 00:21:48.000
そして、それをDSL全体の文脈に入れると、私たちはかなり快適なフィット感を持っていると思います。

00:21:48.000 --> 00:21:52.000
しかし、あなたは同意しないかもしれません、そしてそれは大丈夫です。

00:21:52.000 --> 00:22:00.000
DSLはプログラミング言語であり、個人的な好みと主観的なトレードオフは、あらゆるプログラミング言語を設計する大きな部分を占めています。

00:22:00.000 --> 00:22:02.000
それはあなたが厳格であるべきではないという意味ではありません。

00:22:02.000 --> 00:22:07.000
あなたは言語から欲しいものの明確なアイデアから始めるべきです。

00:22:07.000 --> 00:22:17.000
使い慣れた解決策を採用できれば、人々は新しい解決策を学ぶ必要がないので、ifステートメントのような既存の解決策があるかどうかを調べる必要があります。

00:22:17.000 --> 00:22:22.000
言語の各部分が残りの部分とどのように相互作用するかを考えるべきです。

00:22:22.000 --> 00:22:33.000
スウィフトDSLでは、他の場所で使用できるので、スケーリングされた修飾子を選んだときのように、DSLがその周りの通常のスウィフトコードとどのように相互作用するかを考えることも意味します。

00:22:33.000 --> 00:22:39.000
コンパイル時に検出可能か、書くことが完全に不可能な間違いを犯す解決策を探すべきです。

00:22:39.000 --> 00:22:46.000
あなたが思い出すなら、それが私たちが説明を修飾子にしなかった理由です。あなたは偶然にそれを省略したかもしれません。

00:22:46.000 --> 00:22:51.000
そのすべてを念頭に置いて、あなたはいくつかの異なる可能性を考え出す必要があります。

00:22:51.000 --> 00:22:56.000
それぞれがどのように使用されるかを想像し、小さなモックアップを書いてください。あなたが知っているように、お互いに重さを量ってください。

00:22:56.000 --> 00:23:02.000
しかし、最終的には、あなたは通常、他の人が明らかに間違っているところで明らかに正しいものを見つけることができません。

00:23:02.000 --> 00:23:08.000
あなたができることは、あなたの言語のクライアントにとって最善だと思うものを選ぶことだけです。

00:23:08.000 --> 00:23:12.000
どちらが最適かわからない場合は、おそらく最も読みやすい方を好むべきです。

00:23:12.000 --> 00:23:15.000
そして、その後もまだわからない場合は...

00:23:15.000 --> 00:23:18.000
まあ、個人的には、私は大胆な選択肢を取るのが好きです。

00:23:18.000 --> 00:23:24.000
決して試して疑問に思うよりも、うまくいかない場合は、むしろ何かを試してみて歩いて戻りたいです。

00:23:24.000 --> 00:23:30.000
DSLがどのように見えるかを決めたので、先に進んでFrutaに追加しましょう。

00:23:30.000 --> 00:23:37.000
以前のスムージーの定義をDSLを使用する最終的なすべての方法に置き換えましたが、実際にはまだDSLを実装していません。

00:23:37.000 --> 00:23:41.000
当然のことながら、私たちにはたくさんのエラーがあります。

00:23:41.000 --> 00:23:42.000
でも、それは大丈夫です。

00:23:42.000 --> 00:23:50.000
私たちがこれに取り組むにつれて、私はこれらのエラーが私が解決する必要がある問題に私を導き、最後にはエラーなしで構築されるものを持つことになります。

00:23:50.000 --> 00:23:56.000
では、この最初のエラー「Unknown attribute 'SmoothieArrayBuilder'」で関数の一番上から始めましょう。

00:23:56.000 --> 00:23:59.000
結果ビルダーは実際にはまだ存在しないので、もちろんそれは機能しません。

00:23:59.000 --> 00:24:01.000
それを直しに行きましょう。

00:24:01.000 --> 00:24:08.000
結果ビルダー属性でマークされた「SmoothieArrayBuilder」というタイプを作ることから始めます。

00:24:08.000 --> 00:24:13.000
今、Swiftは実際にこのタイプのインスタンスを作ることはありません。それは単なる静的メソッドの束のためのコンテナです。

00:24:13.000 --> 00:24:17.000
だから私はそれを列挙型にしました、そして私はどんなケースも定義しません。

00:24:17.000 --> 00:24:24.000
ケースを持たない列挙型インスタンスを作成することは不可能であるため、人々が誤って使用するのを防ぎます。

00:24:24.000 --> 00:24:30.000
これだけをビルドすると、結果ビルダーにbuildBlock(_:)メソッドが必要だというエラーが発生します。

00:24:30.000 --> 00:24:38.000
それは1つを挿入する修正イットを持っているので、私はその修正を受け入れ、それを実装する方法を考えます。

00:24:38.000 --> 00:24:55.000
さて、以前から思い出すと、buildBlock(_:)の仕組みは、このようなコードが個々のステートメントの束を持つ場合、それらのステートメントのそれぞれが変数に割り当てられ、変数はすべてbuildBlock(_:)に渡され、buildBlock(_:)によって返された値はクロージャによって返されます。

00:24:55.000 --> 00:25:03.000
したがって、buildBlock(_:)メソッドは、多くのスムージーをパラメータとして受け入れ、スムージーの配列を返す必要があるのは理にかなっています。

00:25:03.000 --> 00:25:09.000
任意の数のスムージーをメソッドに渡すことができるように、可変パラメータを使用してそれを実装する場合...

00:25:09.000 --> 00:25:23.000
...そして構築する...

00:25:23.000 --> 00:25:26.000
...まあ、私たちが得るものは少し良いです。

00:25:26.000 --> 00:25:36.000
まだ多くのエラーがありますが、スムージー配列ビルダーが無効な属性だったと言っているものはなくなり、属性は既知のタイプであることを示すために色も変更されました。

00:25:36.000 --> 00:25:42.000
では、次のエラー、スムージーイニシャライザのエラーに移りましょう。

00:25:42.000 --> 00:25:47.000
ある人は、文字列パラメータに末尾のクロージャを渡していると言います。

00:25:47.000 --> 00:25:50.000
もう一人は、測定された成分の議論を見逃していると言います。

00:25:50.000 --> 00:25:56.000
だから明らかに、私たちはパラメータとして説明と成分を期待する古い初期化子を使用しています。

00:25:56.000 --> 00:25:58.000
私たちは新しいものを作る必要があります。 

00:25:58.000 --> 00:26:12.000
では、ID、タイトル、および説明と成分を返す末尾のクロージャで初期化子を実装しましょう。

00:26:12.000 --> 00:26:18.000
今すぐお伝えします。後でこのイニシャライザに戻らなければなりません。

00:26:18.000 --> 00:26:27.000
今すぐ構築すると、スムージーイニシャライザからすべてのエラーがクリアされるので、これは完璧に機能していると思うかもしれません。

00:26:27.000 --> 00:26:31.000
しかし、それは実際には少し誤解を招く。

00:26:31.000 --> 00:26:38.000
ほら、スムージー配列ビルダーが完成していないことに起因するifステートメントに別のエラーがあります。

00:26:38.000 --> 00:26:44.000
そして、そのエラーがあるので、Swiftはまだクロージャの内部をチェックしていません。

00:26:44.000 --> 00:26:55.000
例えば、このクロージャに入って、存在しないことを知っているランダムな変数名を書いてから構築すると、Swiftはエラーにフラグを立てません。

00:26:55.000 --> 00:27:05.000
起こっていることは、スウィフトは結果ビルダーが正しく適用されなかったことを見ているので、これらのクロージャで見つかったエラーが実際に正確であることを本当に信頼していません。

00:27:05.000 --> 00:27:09.000
だから、まだそこでエラーを探していないだけです。

00:27:09.000 --> 00:27:15.000
後で、スムージーアレイビルダーを終えると、突然これらのエラーが表示され始め、その時点で修正することができます。

00:27:15.000 --> 00:27:24.000
しかし、今のところ、スムージーアレイビルダーの作業を続ける方が簡単なので、これらのクロージャを脇に置いて、次のエラーに進みましょう。

00:27:24.000 --> 00:27:32.000
このエラーを見ると、Swiftはスムージー配列ビルダーでifステートメントを使用できないことを教えてくれますが、それをサポートするために追加できるメソッドがあります。

00:27:32.000 --> 00:27:40.000
ステートメントがこのようないくつかのSwift機能の1つである場合、結果ビルダーがそれらをサポートするための追加のメソッドを実装しない限り、それらは無効になります。

00:27:40.000 --> 00:27:48.000
だから、これを実装し始めるために、ここでfix-itを押して、それが何を追加するかを見てみましょう。

00:27:48.000 --> 00:27:55.000
したがって、明らかに、オプションのスムージーの配列を取り、スムージーの配列を返すbuildOptional(_:)というメソッドを実装する必要があります。

00:27:55.000 --> 00:27:59.000
では、この方法はどのように使用されるのですか?

00:27:59.000 --> 00:28:06.000
さて、他の方法のないifステートメントを持つallメソッドのこの簡略化された例を見てみましょう。

00:28:06.000 --> 00:28:17.000
If ステートメントのない前の例と同様に、これは各ステートメントの結果を変数にキャプチャし、それらの変数をbuildBlock(_:)に渡し、クロージャからbuildBlock(_:)の結果を返します。

00:28:17.000 --> 00:28:22.000
唯一の問題は、ifステートメントの結果をどのようにキャプチャするかということです。

00:28:22.000 --> 00:28:34.000
さて、最初に行うことは、ifステートメントの本文内のすべてのステートメントを変数にキャプチャし、トップレベルと同じようにbuildBlock(_:)を使用してそれらの変数を組み合わせることです。

00:28:34.000 --> 00:28:36.000
しかし、これがbuildOptional(_:)の出番です。

00:28:36.000 --> 00:28:46.000
その内部 buildBlock(_:) 呼び出しの結果を返す代わりに、Swift はそれを buildOptional(_:) に渡し、buildOptional(_:) によって返される値は if ステートメント全体の値になります。

00:28:46.000 --> 00:28:51.000
しかし、if条件がfalseの場合、変数は初期化されないままになります。

00:28:51.000 --> 00:28:56.000
そのため、buildOptionalのパラメータはオプションのスムージーの配列です。

00:28:56.000 --> 00:29:03.000
Swiftは、if文の結果の値をbuildOptional(nil)からの戻り値に設定するelseブランチを追加します。

00:29:03.000 --> 00:29:14.000
SmoothieArrayBuilderの場合、これの結果は、buildOptional(_:)がbuildBlock(_:)から渡された配列を返すか、パラメータがnilの場合は空の配列を返すことです。

00:29:14.000 --> 00:29:18.000
今それを作れば、私たちは...

00:29:18.000 --> 00:29:22.000
...本当に奇妙な見た目のエラー。

00:29:22.000 --> 00:29:26.000
スムージー型の配列を可変引数として渡すことはできませんか?

00:29:26.000 --> 00:29:27.000
何？

00:29:27.000 --> 00:29:30.000
さて、生成されたコードに戻りましょう。

00:29:30.000 --> 00:29:33.000
Ifステートメントは、スムージーの配列を生成することになります。

00:29:33.000 --> 00:29:38.000
しかし、実際には、buildBlock(_:)はスムージーの配列を望んでいません。それは単一のスムージーを望んでいます。

00:29:38.000 --> 00:29:40.000
私たちはそれを変える必要があります。

00:29:40.000 --> 00:29:54.000
したがって、buildBlock(_:)にスムージーの配列を引数として取り、flatMap(_:)を使用して、これらの多くのスムージーの配列を単一のスムージーの配列に連結することができます。

00:29:54.000 --> 00:29:57.000
すごい！それを構築し、そして...

00:29:57.000 --> 00:30:00.000
...いいえ。

00:30:00.000 --> 00:30:04.000
今、私たちのifステートメントは機能しますが、すべてのスムージーラインが壊れました。

00:30:04.000 --> 00:30:07.000
私たちはそれらを必要としています。

00:30:07.000 --> 00:30:11.000
スムージータイプの値をスムージーの配列に変換できません。

00:30:11.000 --> 00:30:13.000
どうしましたか？

00:30:13.000 --> 00:30:20.000
さて、buildOptional(_:)によって返されたスムージーの配列と一致するようにbuildBlock(_:)を変更しました。

00:30:20.000 --> 00:30:25.000
しかし、通常のステートメントで返される個々のスムージーと一致する必要があることを忘れていました。

00:30:25.000 --> 00:30:27.000
おっと。

00:30:27.000 --> 00:30:36.000
基本的に、洗練された制御フローを許可する場合、buildBlockの戻り値の型は、buildBlock(_:)にパラメータとして渡すことができるものである必要があります。

00:30:36.000 --> 00:30:39.000
これを達成するには2つの方法があります。

00:30:39.000 --> 00:30:46.000
1つの方法は、buildBlock(_:)と他の結果ビルダーメソッドが、結果ビルダーで許可されているステートメントと互換性のある型を返すことを確認することです。

00:30:46.000 --> 00:30:49.000
例えば、これがSwiftUIのViewBuilderの仕組みです。

00:30:49.000 --> 00:30:56.000
SwiftUI DSLでは、buildBlock(_:)やその他のビュービルダーメソッドによって返されるタイプを含め、すべてがViewプロトコルに準拠しています。

00:30:56.000 --> 00:31:06.000
しかし、SwiftUIビューとは異なり、他のスムージーの中にスムージーをネストしないため、それは私たちのスムージーDSLには適していません。

00:31:06.000 --> 00:31:13.000
もう1つできることは、結果ビルダーに通常のステートメントの値をbuildBlock(_:)によって返されるのと同じタイプに変換させることです。

00:31:13.000 --> 00:31:16.000
それはこのDSLにより適しています。

00:31:16.000 --> 00:31:20.000
buildExpression(_:)というメソッドを追加することで、それを行うことができます。

00:31:20.000 --> 00:31:26.000
buildExpression(_:)メソッドを追加すると、Swiftは変数にキャプチャする前に、各ベア式をそのメソッドに渡します。

00:31:26.000 --> 00:31:30.000
それは私たちにそれらを配列に変換する機会を与えるでしょう。

00:31:30.000 --> 00:31:43.000
しかし、buildOptional(_:)やbuildBlock(_:)によって生成されたものなど、他の結果ビルダーメソッドから来る値は、これらの呼び出しにラップされないため、この変換は適用されません。これは、すでに配列を返しているので良いことです。

00:31:43.000 --> 00:31:48.000
したがって、私たちが行うことは、buildExpression(_:)メソッドを実装することです。

00:31:48.000 --> 00:31:56.000
Xcodeのコード補完は、結果ビルダーメソッドについてすべて知っているので、1つの署名を書くように依頼することができます。

00:31:56.000 --> 00:32:06.000
次に、パラメータタイプをSmoothyに変更し、配列リテラルでラップされた式パラメータを返すだけです。

00:32:06.000 --> 00:32:13.000
だから今、私たちの単一のスムージーは、buildBlock(_:)が必要とするスムージーの配列に変わります。

00:32:13.000 --> 00:32:16.000
それを構築し、そして...

00:32:16.000 --> 00:32:17.000
...ファンタスティック！

00:32:17.000 --> 00:32:21.000
私たちのifステートメントは機能し、スムージー初期化子も機能します。

00:32:21.000 --> 00:32:28.000
しかし、ミニマップを見ると、ここに動作しない2番目のifステートメントがあることがわかります。

00:32:28.000 --> 00:32:32.000
これは他の条項があるからです。

00:32:32.000 --> 00:32:36.000
buildOptional(_:) は、実際にはプレーンif ステートメントでのみ機能します。

00:32:36.000 --> 00:32:45.000
elseステートメント、else-if、またはスイッチがある場合は、buildEither(first:)とbuildEither(second:)と呼ばれるメソッドのペアを実装する必要があります。

00:32:45.000 --> 00:32:51.000
修正機能を使用してこれらを作成し、それらがどのように機能するかについて話しましょう。

00:32:51.000 --> 00:32:55.000
では、if-elseステートメントでこの簡略化された例を見てみましょう。

00:32:55.000 --> 00:32:58.000
変換のほとんどは、buildOptional(_:)のようなものです。

00:32:58.000 --> 00:33:03.000
buildOptional(_:)と同様に、if-elseステートメント全体が単一の変数を埋めます。

00:33:03.000 --> 00:33:14.000
また、buildOptional(_:)と同様に、ifステートメントの各ブロックには、その中のステートメントが変数にキャプチャされ、buildBlockを使用してそれらを1つの値に結合します。

00:33:14.000 --> 00:33:23.000
プレーンifステートメントとの違いは、buildOptional(_:)を使用して最終値を生成する代わりに、buildEitherメソッドの1つを使用することです。

00:33:23.000 --> 00:33:31.000
ifとelseのような2つのブランチがある場合、最初のブランチはbuildEither(first:)を使用し、2番目のブランチはbuildEither(second:)を使用します。

00:33:31.000 --> 00:33:37.000
これにより、どのブランチを気にする結果ビルダーがそれらを区別することができます。

00:33:37.000 --> 00:33:45.000
さて、3つ以上のケースがある場合にどうするか疑問に思っているなら、その答えは実際にはかなりクールです。

00:33:45.000 --> 00:33:58.000
各ブランチを葉の1つとしてバランスの取れたバイナリツリーを構築し、非リーフノードを必要な呼び出しとして扱い、エッジはbuildEither(first:)とbuildEither(second:)のどちらを使用するかを教えてくれます。

00:33:58.000 --> 00:34:05.000
各ブランチがどの一連の呼び出しを使用すべきかに注意し、その一連の呼び出しで変数に割り当てるコードを生成します。

00:34:05.000 --> 00:34:10.000
したがって、2つの方法しかありませんが、結果ビルダーは3つのブランチを区別できます。

00:34:10.000 --> 00:34:12.000
悪くない。

00:34:12.000 --> 00:34:18.000
とにかく、buildEitherメソッドがどのように機能するかがわかったので、先に進んでそれらを書くことができます。

00:34:18.000 --> 00:34:25.000
そして、SmoothieArrayBuilderは実際にどのブランチを取ったかを気にしないので、私たちがする必要があることはあまりありません。配列引数を返すだけです。

00:34:25.000 --> 00:34:34.000
だから今、私たちはこれを構築し、そして...

00:34:34.000 --> 00:34:36.000
それはまだうまくいきません。

00:34:36.000 --> 00:34:38.000
しかし、私たちは近いです!

00:34:38.000 --> 00:34:48.000
Array-of-smoothieの問題が発生したときのこの種のエラーを覚えているかもしれませんが、今はスムージータイプについて文句を言っているのではなく、タイプ「()」です。

00:34:48.000 --> 00:34:52.000
それは空のタプルで、おそらくボイドと考えるタイプです。

00:34:52.000 --> 00:34:57.000
生成されたコードについて考えると、これが問題である理由は理にかなっています。

00:34:57.000 --> 00:35:04.000
buildExpression(_:)を呼び出していますが、渡される式はlogger.logを呼び出して、SmoothyではなくVoidを返します。

00:35:04.000 --> 00:35:17.000
したがって、voidパラメータを受け取り、空の配列を返すbuildExpression(_:)のオーバーロードを書きます。

00:35:17.000 --> 00:35:24.000
その後、再構築し、ログコールが正しく機能します!

00:35:24.000 --> 00:35:31.000
数え切れないほどのエラーがありますが、これは実際には良いニュースです。

00:35:31.000 --> 00:35:39.000
ほら、これらのエラーの最初のものは、スウィフトが末尾のクロージャでエラーを見つけていないことを示すために、私が最初に追加した偽の変数からのものです。

00:35:39.000 --> 00:35:43.000
今、それは私たちがスムージーアレイビルダーを終えたことを意味します!

00:35:43.000 --> 00:35:46.000
だからイェーイ、エラー!

00:35:46.000 --> 00:35:50.000
その偽の変数を削除して、残っているものを見てみましょう。

00:35:50.000 --> 00:35:54.000
よく見ると、見た目よりもここでやることが少ないことがわかります。 

00:35:54.000 --> 00:36:04.000
すべての説明行に同じ警告があり、すべての成分行に同じ2つのエラーがあります。

00:36:04.000 --> 00:36:12.000
したがって、100のエラーと1ダースの警告がありますが、これは実際には何度も起こっている同じ問題です。

00:36:12.000 --> 00:36:16.000
これらの成分ラインの1つのエラーを詳しく見てみましょう。

00:36:16.000 --> 00:36:26.000
コンパイラには2つの不満があります。どのタイプでカップを探すべきかがわからず、Ingredientに「測定済み」と呼ばれるメンバーがいるとは思いません。

00:36:26.000 --> 00:36:34.000
まあ、それは理にかなっています。私たちは測定された(with:)またはスケーリングされた(by:)修飾子を実装していないので、「測定」と呼ばれるものを見つけることができません。

00:36:34.000 --> 00:36:40.000
そして、測定された(with:)が体積単位を取ることになっていることを知らないので、カップが何であるかを知りません。

00:36:40.000 --> 00:36:48.000
それでは、MeasuredIngredient.swiftに立ち寄って、これら2つの修飾子を実装しましょう。

00:36:48.000 --> 00:36:56.000
Measured(with:)は成分に行き、発信者が渡したユニットの1つで測定された成分を返します。

00:36:56.000 --> 00:37:05.000
そして、scaled(by:)は測定された成分に行き、測定値に発信者が渡したスケールを乗じた新しい測定成分を返します。

00:37:05.000 --> 00:37:11.000
Smoothie.swiftに戻ってビルド...

00:37:11.000 --> 00:37:13.000
...そして、OK。

00:37:13.000 --> 00:37:16.000
より多くの警告といくつかのエラーしか見られません。

00:37:16.000 --> 00:37:32.000
そして、よく見ると、クロージャの各式が無視されているという1種類の警告と、クロージャにはリターンステートメントがないという1種類のエラーしか表示されません。

00:37:32.000 --> 00:37:39.000
その理由を理解するために、これらの後続のクロージャと、結果ビルダーがそれらとどのように相互作用するかについて話しましょう。

00:37:39.000 --> 00:37:45.000
この例では、SmoothyArrayBuilderは、以前に見たように外側のステートメントに影響します。

00:37:45.000 --> 00:37:50.000
それらはbuildExpression(_:)に渡され、変数に保存され、変数はbuildBlockに渡されます。

00:37:50.000 --> 00:37:53.000
しかし、これらの閉鎖はどうですか?

00:37:53.000 --> 00:37:56.000
結果ビルダーは彼らに何をしますか?

00:37:56.000 --> 00:37:58.000
まあ、それは...

00:37:58.000 --> 00:38:07.000
...クロージャは、実際には結果ビルダーを適用した関数内にネストされた別々の関数であるため、絶対に何もありません。

00:38:07.000 --> 00:38:14.000
結果ビルダーは1つの関数にのみ適用され、その中にネストされた関数やクロージャには影響しません。

00:38:14.000 --> 00:38:21.000
結果ビルダーの影響を受けたい場合は、他の方法で適用する必要があります。 それらを適用する必要があります。

00:38:21.000 --> 00:38:25.000
結果ビルダーを機能本体に適用するには、3つの方法があります。

00:38:25.000 --> 00:38:32.000
1つ目は、SmoothyArrayBuilderで行ったように、属性を関数またはプロパティに直接書き込むことです。

00:38:32.000 --> 00:38:42.000
結果ビルダーを適用する2番目の方法は、プロトコルの関数またはプロパティ要件に書き込むことです。その後、すべての適合タイプの実装に自動的に適用されます。

00:38:42.000 --> 00:38:55.000
それがSwiftUIビューのボディプロパティの仕組みです。ViewBuilder属性はビューのボディ要件に適用されるため、ビューのボディプロパティにも自動的に適用されます。

00:38:55.000 --> 00:39:00.000
結果ビルダーを適用する3番目の方法は、クロージャパラメータの前に書き込むことです。

00:39:00.000 --> 00:39:08.000
そうすると、Swiftは、そのパラメータに渡されたクロージャには結果ビルダーが適用されるべきだと推測します。

00:39:08.000 --> 00:39:18.000
Swiftがプロトコルまたはパラメータから結果ビルダーを推測し、実際にそれを適用したくない場合は、return文を使用して明示的に値を返すことで無効にすることができます。

00:39:18.000 --> 00:39:28.000
しかし、この場合、クロージャを使用しているので、これらの3つのオプションの最後が必要です。クロージャパラメータから結果ビルダーを推測します。

00:39:28.000 --> 00:39:31.000
引数ラベルの前に属性を書くことで、それを行います。

00:39:31.000 --> 00:39:39.000
さて、私たちはここでSmoothyArrayBuilderを書くことができますが、それはおそらくこれを行うための最良の方法ではありません。

00:39:39.000 --> 00:39:50.000
SmoothieArrayBuilderはスムージーの配列を生成しますが、私たちはこの閉鎖がスムージーを生成することを望んでいません。私たちはそれが文字列と成分の配列を生成することを望みます。

00:39:50.000 --> 00:39:55.000
また、このクロージャでは、ステートメントやボイドリターンコールも必要ありません。

00:39:55.000 --> 00:40:09.000
だから本当に、私たちはこのクロージャに言語ルールの別のセットを適用しており、その2番目のルールセットをSmoothieArrayBuilderに混ぜるのではなく、これらの新しいルールを実装する新しい結果ビルダーを作成する方が理にかなっています。

00:40:09.000 --> 00:40:23.000
それをSmoothyBuilderと呼び、新しい型を作成し、buildBlock(_:)メソッドを書き始めましょう。

00:40:23.000 --> 00:40:25.000
さて、これは少し特別です。

00:40:25.000 --> 00:40:32.000
任意の数の測定された成分を受け入れたいが、前面にひもを付けたい。

00:40:32.000 --> 00:40:36.000
それで、どうやってやるの?

00:40:36.000 --> 00:40:49.000
さて、buildBlockメソッドのみを持つ単純な結果ビルダーであるSmoothyBuilderがどのように展開されるかを考えると、それらの行はそれぞれ異なるパラメータとして渡されます。

00:40:49.000 --> 00:40:59.000
したがって、buildBlockの先頭に文字列パラメータを書くだけで、最初のステートメントはMeasuredIngredientの代わりに文字列を生成する必要があるようです。

00:40:59.000 --> 00:41:02.000
だから、それをやってみましょう。

00:41:02.000 --> 00:41:09.000
文字列パラメータを前面に追加し、文字列のタプルと成分の配列を返します。

00:41:09.000 --> 00:41:18.000
そして、もし私たちが建てるなら...

00:41:18.000 --> 00:41:22.000
ねえ、それを見て！エラーゼロ！

00:41:22.000 --> 00:41:24.000
私たちのDSLは機能します!

00:41:24.000 --> 00:41:30.000
現在、結果ビルダーは、フォーインループや最終リターン結果の処理など、さらにいくつかの機能をサポートしています。

00:41:30.000 --> 00:41:37.000
それらを使用したい場合は、Swift Programming Languageの本に記載されています。

00:41:37.000 --> 00:41:46.000
しかし、終わる前に、言語デザインの最も重要な部分の1つである良いエラーメッセージに注意を喚起したいと思います。

00:41:46.000 --> 00:41:58.000
言語を設計するときに学ぶことの1つは、無効なコードよりも無効なコードを書く方法がたくさんあるので、無効なコードに対して発生するエラーについて考える時間を費やすべきです。

00:41:58.000 --> 00:42:03.000
コードが間違っているときのあなたの行動は、コードが正しいときと同じくらい重要です。

00:42:03.000 --> 00:42:09.000
これで、Swift DSLの場合、Swiftのエラー処理を無料で入手できます。

00:42:09.000 --> 00:42:13.000
しかし、クライアントが表示するエラーメッセージは、一般的なSwiftコード用に設計されています。

00:42:13.000 --> 00:42:20.000
彼らはあなたの言語のルールの観点から表現されていないので、彼らはあなたのクライアントに問題を明確に伝えないかもしれません。

00:42:20.000 --> 00:42:29.000
例えば、誰かがこれらのスムージーの1つに説明を入れるのを忘れたと想像してみてください。

00:42:29.000 --> 00:42:33.000
スウィフトはエラーメッセージを発行しますが、少し不明です。

00:42:33.000 --> 00:42:39.000
最初の成分を文字列に変換できないと不平を言います。

00:42:39.000 --> 00:42:43.000
では、このコードはどのようにしてこのエラーを生成するのでしょうか?

00:42:43.000 --> 00:42:53.000
さて、SwiftコンパイラはスムージーDSLのセマンティクスを本当に理解していませんが、結果ビルダーを使用するために生成されたSwiftコードのセマンティクスのみを理解しています。

00:42:53.000 --> 00:43:00.000
したがって、このエラーを診断しようとすると、この値をスムージーや最初の成分の説明とは考えません。

00:43:00.000 --> 00:43:04.000
それはbuildBlockの最初の引数だと考えています。

00:43:04.000 --> 00:43:14.000
v0、buildBlock(_:)の最初の引数はMeasuredIngredientですが、文字列パラメータに渡されています。

00:43:14.000 --> 00:43:23.000
したがって、Swiftはこのエラーを「MeasuredIngredientを文字列パラメータに渡そうとしていますが、MeasuredIngredientを文字列に変換できません」と考えています。

00:43:23.000 --> 00:43:28.000
エラーメッセージは技術的には間違っていませんが、あまり役に立ちません。

00:43:28.000 --> 00:43:37.000
コンパイラエンジニアにはコツがあります。コンパイラに無効なものをサポートさせますが、それを行うとエラーが発生します。

00:43:37.000 --> 00:43:44.000
たとえば、Swiftの関数文法には、スロー、リスロー、または何も書くことができるスロットがあります。

00:43:44.000 --> 00:43:55.000
他のサポートされていない単語を書くと、コンパイラはそれが別のステートメントの一部であるはずだったと推測し、セミコロンを追加するか、新しい行を使用するかというエラーが表示されます。

00:43:55.000 --> 00:43:59.000
しかし、具体的に「try」と書くと、別のエラーが発生します。

00:43:59.000 --> 00:44:07.000
コンパイラは、それをスローに置き換えることを提案し、代わりにそこにスローを書いたかのようにファイルの残りの部分を解析します。

00:44:07.000 --> 00:44:11.000
これは、Swiftパーサーに追加した特別なケースです。

00:44:11.000 --> 00:44:21.000
開発者がスローを書くことを意味するときに、ここで他のエラー処理キーワードを入力することがあることに気づいたので、言語の正式な文法に小さな文書化されていない拡張を作成しました。

00:44:21.000 --> 00:44:29.000
ここでこれらの誤ったキーワードを解析し、その特定の間違いに合わせて、通常とは異なるエラーを診断します。

00:44:29.000 --> 00:44:35.000
エラー動作を改善するために、結果ビルダーで同様のことを行うことができるので、これを指摘します。

00:44:35.000 --> 00:44:47.000
具体的には、不正なコードに一致する結果ビルダーメソッドのオーバーロードを行い、そのオーバーロードを使用不可としてマークした場合、それを診断するときに使用するエラーメッセージを指定できます。

00:44:47.000 --> 00:44:57.000
そして、問題をうまく伝えない可能性のある一般的なエラーを取得する代わりに、クライアントはその間違いに合わせたより具体的なエラーメッセージを受け取ります。

00:44:57.000 --> 00:45:16.000
buildBlock(_:)をコピーし、説明パラメータを削除して、成分リストのみでブロックを照合し、本文をfatalError()に置き換えて、戻り値を偽造する必要がないようにします。

00:45:16.000 --> 00:45:20.000
このメソッドは正常に呼び出されないので、ボディは有効なものでなければなりません。

00:45:20.000 --> 00:45:27.000
次に、この過負荷を利用不可としてマークし、問題をより明確に説明するメッセージを提供します。

00:45:27.000 --> 00:45:33.000
この使用できない注釈は、このメソッドが実際に使用できないことを意味します。

00:45:33.000 --> 00:45:36.000
あなたがそれに呼び出しを書く場合、それはエラーです。

00:45:36.000 --> 00:45:44.000
だから今、トップに戻って再構築すると、何が間違っているのか、はるかに明確な説明が得られることがわかります。

00:45:44.000 --> 00:45:51.000
最初の成分は文字列であるべきだと言う代わりに、説明文字列が欠落していると言います。

00:45:51.000 --> 00:45:58.000
したがって、クライアントは成分が間違っていると考え始めたり、文字列が何のためにあるのか疑問に思う必要はありません。エラーは前もってそれを彼らに伝えます。

00:45:58.000 --> 00:46:01.000
それははるかに良い経験です。

00:46:01.000 --> 00:46:08.000
そして、DSLの実装について覚えておくべき最も重要なことは、それがすべてクライアントの経験を向上させることであるということです。

00:46:08.000 --> 00:46:20.000
DSLは、クライアントが定義を組み立てる仕組みを気にせずに物事を定義できるようにすることで、非常に複雑で反復的なコードをはるかにきれいにすることができます。

00:46:20.000 --> 00:46:26.000
結果ビルダーは、DSLが定義されている値を収集できるようにする強力なツールです。

00:46:26.000 --> 00:46:34.000
そして、修飾子スタイルのメソッドは、結果ビルダーがそれらをキャプチャする前に、それらの値を変更するための構成可能な方法を提供します。

00:46:34.000 --> 00:46:40.000
しかし、DSLを書く場合、クライアントはそれを使用する方法を学ばなければならないことを覚えておいてください。

00:46:40.000 --> 00:46:44.000
時間と労力に見合う価値がある場合にのみ、DSLを提供してください。

00:46:44.000 --> 00:46:49.000
だから、あなたの時間をありがとう、そしていくつかの小さな言語を構築することを楽しんでください。

00:46:49.000 --> 23:59:59.000
♪

