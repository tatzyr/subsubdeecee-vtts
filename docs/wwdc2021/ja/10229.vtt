WEBVTT

00:00:02.000 --> 00:00:15.000
こんにちは。私の名前はリニ・パテルで、GPUソフトウェアエンジニアリングチームの出身です。

00:00:15.000 --> 00:00:20.000
このセッションでは、Metalの新しいシェーダーコンパイルワークフローを紹介します。

00:00:20.000 --> 00:00:28.000
Metalシェーディング言語はC++ベースの言語であり、そのコンパイルモデルはCPUコンパイルモデルによく似ています。

00:00:28.000 --> 00:00:38.000
GPUワークロードの複雑さが増すにつれて、Metalは現代のユースケースをサポートするために必要な柔軟性とパフォーマンスに対処するために同様に進化しました。

00:00:38.000 --> 00:00:57.000
シェーダーのオーサリング中にすでに直面している可能性のある一般的な課題は、パイプライン間でユーティリティコードを共有したり、再コンパイルせずに実行時にシェーダーの動作を変更したり、アプリケーションの起動時にコンパイルされたGPUバイナリを再利用したりする機能です。

00:00:57.000 --> 00:01:02.000
では、簡単なシェーダーコードを見て、シナリオについて話し合いましょう。

00:01:02.000 --> 00:01:10.000
ここでは、条件の結果に応じて、foo()またはbar()の結果を返す単純なフラグメントシェーダーがあります。

00:01:10.000 --> 00:01:19.000
さて、これらの関数が複数のパイプラインによって呼び出された場合は、一度だけコンパイルして、代わりに各パイプラインにリンクすることをお勧めします。

00:01:19.000 --> 00:01:31.000
実行時にこれらの関数の異なる実装をリンクする必要があるかもしれませんし、baz()の新しいケースステートメントを処理するために拡張可能なフラグメントシェーダーが必要になるかもしれません。

00:01:31.000 --> 00:01:38.000
また、フラグメント関数からbaz（）の代わりに、ユーザー提供の関数bat（）を呼び出すこともできます。

00:01:38.000 --> 00:01:49.000
ご覧のとおり、シェーダーオーサリングパイプラインにはさまざまな要件があり、Metalはさまざまな実装をサポートするためのさまざまなAPIを提供しています。

00:01:49.000 --> 00:01:54.000
各アプローチは、コンパイル時間とシェーダーのパフォーマンスの間で異なるトレードオフがあります。

00:01:54.000 --> 00:02:03.000
そして今日は、パフォーマンスと柔軟性の完璧なバランスを見つけるのに役立つ新しいコンパイルワークフローについて話したいと思います。

00:02:03.000 --> 00:02:11.000
レンダリングパイプラインの動的ライブラリと、レンダリングパイプラインの関数ポインタの新しいサポートから始めます。

00:02:11.000 --> 00:02:16.000
binaryArchive APIへの追加について少し話します。

00:02:16.000 --> 00:02:19.000
その後、プライベートリンク関数が表示されます。

00:02:19.000 --> 00:02:26.000
そして最後に、メタルの可視機能をステッチするためのまったく新しい機能を紹介します。

00:02:26.000 --> 00:02:30.000
では、Metalの動的ライブラリサポートから始めましょう。

00:02:30.000 --> 00:02:34.000
動的ライブラリは、ソフトウェアエンジニアリングにおける一般的なツールです。

00:02:34.000 --> 00:02:43.000
これらは、ユーティリティコードをスタンドアロンのコンパイルユニットに区画化できる共有オブジェクトファイルです。

00:02:43.000 --> 00:02:51.000
それらは、コンパイルされたシェーダーコードの量を減らし、複数のパイプライン間で再利用するのに役立ちます。

00:02:51.000 --> 00:02:59.000
さらに、GPUバイナリコードを動的にリンク、ロード、共有することができます。

00:02:59.000 --> 00:03:14.000
昨年、コンピューティングパイプライン用の動的言語を導入し、Metalの動的ライブラリをさらに紹介するために、前年のプレゼンテーション「MetalでGPUバイナリを構築する」をチェックすることをお勧めします。

00:03:14.000 --> 00:03:19.000
今年は、レンダリングとタイルパイプラインに動的ライブラリを導入します。

00:03:19.000 --> 00:03:26.000
この追加サポートにより、すべてのコンピューティングとレンダリングワークロードでユーティリティライブラリを共有できるようになりました。

00:03:26.000 --> 00:03:32.000
そして、動的ライブラリが何であるかがわかったので、いくつかのユースケースについて話す時が来ました。

00:03:32.000 --> 00:03:38.000
ヘルパー関数は、一般的なコンピューティング、頂点、フラグメント、およびタイルシェーダーでよく使用されます。

00:03:38.000 --> 00:03:47.000
パイプラインをレンダリングするための動的ライブラリを追加することで、大量のユーティリティコードを管理し、すべてのワークロードで共有できるようになりました。

00:03:47.000 --> 00:04:01.000
パイプラインの作成中にロードされるライブラリを変更するだけで、コンパイルが遅くなることなく、実行時に使用できるライブラリを事前にコンパイルしたり、ランタイムの機能を切り替えたりできます。

00:04:01.000 --> 00:04:10.000
また、ソースを提供することなく、パイプラインの一部としてロードできるシェーダーコードをユーザーが作成するのに役立ちます。

00:04:10.000 --> 00:04:13.000
そこで、動的ライブラリを使用するタイミングについて話し合いました。

00:04:13.000 --> 00:04:16.000
それでは、それらを構築し、一緒に作業する方法を見てみましょう。

00:04:16.000 --> 00:04:25.000
フラグメントシェーダーの例では、関数 foo() と bar() を呼び出しますが、コンパイル時にどちらの実装も提供していません。

00:04:25.000 --> 00:04:32.000
代わりに、これらの関数の実装は、後でレンダリングパイプラインを作成するときにリンクするMetalライブラリに存在します。

00:04:32.000 --> 00:04:38.000
また、使用できる機能ごとに個別のライブラリを提供することも可能です。 

00:04:38.000 --> 00:04:44.000
それでは、Metalで動的ライブラリを構築することで、あなたが持っているツールと柔軟性について話し合いましょう。

00:04:44.000 --> 00:04:59.000
まず、MetalシェーダーソースをAIRにコンパイルする必要があり、ビルドプロセスの一部としてXcodeのMetalツールチェーンを使用するか、実行時にnewLibraryWithSource APIを使用してソースからコンパイルすることで、これを行うことができます。

00:04:59.000 --> 00:05:08.000
AIRでコンパイルされたMetalシェーダーを使用すると、newDynamicLibrary APIを使用するだけで動的ライブラリを作成できるようになりました。

00:05:08.000 --> 00:05:13.000
このライブラリは、GPUバイナリ形式で使用する準備ができています。

00:05:13.000 --> 00:05:16.000
しかし、後で実行して再利用したい場合はどうなりますか?

00:05:16.000 --> 00:05:25.000
これを行うには、動的ライブラリをディスクにシリアライズすることができ、これはserializeToURL APIを使用して行うことができます。

00:05:25.000 --> 00:05:32.000
そして後で、newDynamicLibraryWithURL APIを呼び出すことで再利用することができます。

00:05:32.000 --> 00:05:37.000
それでは、動的ライブラリとフラグメントシェーダーから関数を呼び出す例を見てみましょう。

00:05:37.000 --> 00:05:46.000
この例では、extern キーワードを使用して関数 foo() と bar() を宣言しますが、それらの定義は提供していません。

00:05:46.000 --> 00:05:50.000
それらを使用するには、フラグメントシェーダーからこれらの関数を呼び出すだけです。

00:05:50.000 --> 00:05:56.000
また、Metalライブラリを構築するときに外部機能の実装を提供できます。

00:05:56.000 --> 00:06:04.000
さて、これらの実装を実行時に別のものに置き換えることも可能です。

00:06:04.000 --> 00:06:11.000
これを行うには、動的ライブラリを適切なプリロードされたライブラリ配列に追加するだけです。

00:06:11.000 --> 00:06:17.000
私たちの場合、それは断片ですが、ステージとパイプラインごとに同様のプロパティが利用可能です。

00:06:17.000 --> 00:06:23.000
そして、シンボルは、ライブラリがこの配列に追加されるのと同じ順序で解決されます。

00:06:23.000 --> 00:06:27.000
このワークフローは、新しい実装を試すのに適しています。

00:06:27.000 --> 00:06:31.000
そして、それは動的ライブラリのためのものです。

00:06:31.000 --> 00:06:41.000
Metalダイナミックライブラリを使用する場合は、macOS MontereyのApple GPUファミリー7以降のコンピューティングパイプラインがサポートされています。

00:06:41.000 --> 00:06:50.000
他のGPUやほとんどのMacファミリー2デバイスでも利用できますが、Metalデバイスは動的ライブラリをサポートする必要があります。

00:06:50.000 --> 00:06:56.000
iOS 15では、この機能はすべてのApple 6デバイス以上で利用できます。

00:06:56.000 --> 00:07:03.000
レンダリングとタイルのパイプラインのサポートは、Apple 6の機能セットをサポートするすべてのデバイスで利用できます。

00:07:03.000 --> 00:07:09.000
次に、今年登場するファンクションポインタの改善について話しましょう。

00:07:09.000 --> 00:07:21.000
関数ポインタは、これまでに見たことのない関数を呼び出すことで、コードを拡張可能にするために呼び出すことができるコードを参照するための単純な構造です。

00:07:21.000 --> 00:07:32.000
昨年、コンピューティングパイプライン関数ポインタを導入しました。そのために、前年のプレゼンテーション「金属関数ポインタを知る」をチェックすることをお勧めします。

00:07:32.000 --> 00:07:38.000
今年は、Apple Siliconのレンダリングおよびタイルパイプラインに機能ポインタのサポートを拡張します。

00:07:38.000 --> 00:07:45.000
動的ライブラリと同様に、関数ポインタを使用すると、カスタマイズ可能なパイプラインを作成できます。

00:07:45.000 --> 00:07:53.000
関数ポインタを使用すると、GPUパイプラインはパイプラインのコンパイル中に見られなかったコードを呼び出すことができます。

00:07:53.000 --> 00:08:06.000
関数ポインタテーブルを使用すると、異なる関数テーブルをバインドするとき、またはGPUパイプラインが関数ポインタテーブルにインデックスを作成するときに、コード実行の動作が動的に変化する可能性があります。

00:08:06.000 --> 00:08:13.000
また、関数ポインタを使用して、コンパイルパフォーマンスとランタイムパフォーマンスのバランスをとる方法を決定することもできます。

00:08:13.000 --> 00:08:21.000
たとえば、最速のコンパイルのために、関数ポインタをGPUバイナリに事前コンパイルし、パイプラインをすばやく処理することができます。

00:08:21.000 --> 00:08:33.000
一方、最高のランタイムパフォーマンスを得るには、パイプライン参照関数のAIR表現を持つことができ、コンパイラが最大限の最適化を行うことができます。

00:08:33.000 --> 00:08:37.000
それでは、コードで関数ポインタを設定する方法を見てみましょう。

00:08:37.000 --> 00:08:40.000
3つの基本的な構成要素があります。

00:08:40.000 --> 00:08:51.000
まず、関数をインスタンス化し、これらの関数を使用してパイプラインを設定し、最後に関数テーブルを作成します。

00:08:51.000 --> 00:08:57.000
これが完了したら、新しいレンダリングループを使用することは、多くのコードを伴いません。

00:08:57.000 --> 00:09:01.000
それでは、各ステップの詳細に飛び込みましょう。

00:09:01.000 --> 00:09:10.000
関数ポインタの使用を開始するには、まず関数記述子を宣言し、関数のGPUバイナリバージョンをコンパイルするためにインスタンス化します。

00:09:10.000 --> 00:09:19.000
これにより、パイプラインの作成時間が短縮され、記述子を宣言し、バイナリにコンパイルするオプションを設定するのと同じくらい簡単です。

00:09:19.000 --> 00:09:28.000
この記述子を使用してライブラリからMetal関数fooが作成されると、関数はGPUバックエンドコンパイラによってコンパイルされます。

00:09:28.000 --> 00:09:33.000
次に、レンダリングパイプライン記述子を設定する必要があります。

00:09:33.000 --> 00:09:42.000
まず、パイプライン記述子を介して、それらが使用されるステージ（頂点、フラグメント、またはタイルステージ）に追加します。

00:09:42.000 --> 00:09:46.000
AIRまたはバイナリ形式で機能を追加することを選択できます。

00:09:46.000 --> 00:09:55.000
AIR関数を追加すると、コンパイラは目に見える関数を静的にリンクし、バックエンドコンパイラがコードを最適化できるようにします。

00:09:55.000 --> 00:10:04.000
一方、バイナリ関数を追加すると、どの外部にコンパイルされた関数が特定のパイプラインから呼び出すことができるかをドライバーに通知します。

00:10:04.000 --> 00:10:24.000
ここで注意すべきことの1つは、バイナリ関数を使用するパイプラインを作成し、ここで示すように、呼び出しているコードに複雑なコールチェーンがある場合、コンパイラは深さを決定するために静的分析を行うことができないため、必要な最大コールスタックの深さを指定することが重要です。

00:10:24.000 --> 00:10:32.000
コンパイラはデフォルトで実行される最大深度になり、深さが正しく指定されていない場合、スタックオーバーフローが発生する可能性があります。

00:10:32.000 --> 00:10:39.000
対照的に、深さを正しく指定することは、より良いリソースの概念と最適なパフォーマンスにつながります。

00:10:39.000 --> 00:10:46.000
したがって、記述子が完全に設定されたら、関数ポインタを使用する準備ができているパイプラインを作成できます。

00:10:46.000 --> 00:10:55.000
パイプラインを作成した後、次のステップは、目に見える関数テーブルを作成し、APIに関数ハンドルを入力することです。

00:10:55.000 --> 00:11:01.000
まず、記述子を使用して目に見える関数テーブルを作成し、レンダリングステージを指定します。

00:11:01.000 --> 00:11:04.000
次に、これらの関数を参照するための関数ハンドルを作成します。

00:11:04.000 --> 00:11:11.000
関数ハンドルとテーブルの両方は、特定のパイプラインと選択したステージに固有です。

00:11:11.000 --> 00:11:16.000
その後、setFunction APIを使用して関数テーブルにハンドルを挿入できます。

00:11:16.000 --> 00:11:22.000
それでは、すべてのセットアップが完了した後、この関数テーブルをどのように使用するかを見てみましょう。

00:11:22.000 --> 00:11:29.000
まず、コマンドとコーディングの一部として、目に見える関数テーブルをバッファインデックスにバインドします。

00:11:29.000 --> 00:11:39.000
シェーダー自体では、visible_function_tableがバッファバインディングとして渡され、このテーブルを介して関数を呼び出すことができます。

00:11:39.000 --> 00:11:42.000
そして、それは関数ポインタを使用する単純なケースでした。

00:11:42.000 --> 00:11:52.000
ファンクションポインタを使用する場合、1つ以上の追加機能にアクセスする必要があることを後で知るためにパイプラインを作成することは珍しくありません。

00:11:52.000 --> 00:12:03.000
さて、同じ記述子から2番目のパイプラインを作成することでそれを達成することができれば、追加機能を追加しますが、パイプラインのコンパイルがトリガーされます。

00:12:03.000 --> 00:12:09.000
このプロセスを加速するために、Metalでは、元のパイプラインを拡張する予定があるかどうかを指定できます。

00:12:09.000 --> 00:12:19.000
これにより、既存のパイプラインから新しいパイプラインをより速く作成でき、元のパイプライン用に最初に作成されたすべての関数ポインタテーブルを使用できます。

00:12:19.000 --> 00:12:31.000
コードからこれを行うには、元のパイプラインを作成するときに、拡張するすべてのステージに対して、supportAddingBinaryFunctionsオプションをYESに設定します。

00:12:31.000 --> 00:12:43.000
次に、拡張パイプラインを作成する必要がある場合は、RenderPipelineFunctionDescriptorを作成し、フラグメント長関数リストに新しいバイナリ関数bat()を含めます。

00:12:43.000 --> 00:12:56.000
最後に、renderPipeline1で追加のバイナリ関数を使用して新しいRenderPipelineStateを呼び出すと、同じですが、追加の関数ポインタバットを含むrenderPipeline2を作成します。

00:12:56.000 --> 00:12:58.000
そして、それはほとんどそれです。

00:12:58.000 --> 00:13:03.000
関数ポインタの使い方を見たので、ここでそれらを使用することができます。

00:13:03.000 --> 00:13:11.000
コンピューティングパイプラインのファンクションポインタは、Apple GPUファミリ6以上、macOS Big Sur、およびiOS 14でサポートされています。

00:13:11.000 --> 00:13:15.000
また、Macファミリー2デバイスでもサポートされています。

00:13:15.000 --> 00:13:27.000
そして今年は、Apple GPUファミリー6以降、Mac OS Monterey、およびiOS 15のレンダリングおよびタイルパイプラインの機能ポインタサポートを拡張します。

00:13:27.000 --> 00:13:33.000
私が話したい次のトピックは、バイナリ関数のコンパイルオーバーヘッドの管理です。

00:13:33.000 --> 00:13:41.000
シェーダーのコンパイルは非常に時間がかかり、アプリケーションにもたらすオーバーヘッドを制御したいと思うかもしれません。

00:13:41.000 --> 00:13:46.000
それを助けるために、私たちは昨年MetalにbinaryArchivesを追加しました。

00:13:46.000 --> 00:14:00.000
BinaryArchivesは、コンパイルされたバイナリバージョンのパイプラインを収集してディスクに保存し、コンパイル時間とその後の実行を節約し、コンパイルに関連するメモリコストを削減できます。

00:14:00.000 --> 00:14:10.000
今年は、可視機能と交差関数をbinaryArchivesに保存する機能を追加し、オーバーヘッドを大幅に削減できます。

00:14:10.000 --> 00:14:15.000
では、binaryArchivesに保存してロードする方法を見てみましょう。

00:14:15.000 --> 00:14:26.000
BinaryArchiveに関数を追加するには、addFunctionWithDescriptorを呼び出して、関数記述子とソースライブラリを引数として渡すだけです。

00:14:26.000 --> 00:14:39.000
BinaryArchiveからバイナリ関数ポインタをロードするには、関数記述子のbinaryArchives配列にBinaryArchiveを配置し、MetalライブラリメソッドnewFunctionWithDescriptorを呼び出します。

00:14:39.000 --> 00:14:48.000
配列内のアーカイブのいずれかにコンパイルされた関数ポインタがある場合、再コンパイルすることなく、すぐに返されます。

00:14:48.000 --> 00:14:55.000
newFunctionWithDescriptorがbinaryArchivesでどのように動作するかを示すルールをいくつか紹介します。

00:14:55.000 --> 00:15:00.000
まず、BinaryArchiveリストで関数のバイナリバージョンを検索します。

00:15:00.000 --> 00:15:13.000
関数が見つかった場合は返され、見つからない場合は、CompileToBinaryオプションをチェックし、バイナリコンパイルが要求されなかった場合は、関数のAIRバージョンを返します。

00:15:13.000 --> 00:15:29.000
一方、バイナリコンパイルが要求された場合、パイプラインオプションに応じて、FailOnBinaryArchiveMissは実行時に関数バイナリをコンパイルするか、nilを返します。

00:15:29.000 --> 00:15:37.000
MTLBinaryArchiveをアプリケーションに統合すると、同じアーカイブを使用してすべてのGPUコンパイルコードを保存できます。

00:15:37.000 --> 00:15:44.000
レンダリング、タイル、計算パイプライン、およびバイナリ関数ポインタ。

00:15:44.000 --> 00:15:52.000
また、アーカイブにパイプライン状態オブジェクトとバイナリ関数が事前に入力された後、それをディスクにシリアライズすることができます。

00:15:52.000 --> 00:16:01.000
この方法でGPUバイナリを収集して保存することは、その後のアプリケーションの実行にシェーダーのコンパイルを加速するのに役立ちます。

00:16:01.000 --> 00:16:09.000
関数ポインタでパイプラインを使用する場合は、パイプラインの状態オブジェクト自体をキャッシュしたい場合があります。

00:16:09.000 --> 00:16:15.000
しかし、異なる関数ポインタの組み合わせが付属するパイプラインがあるのに、なぜキャッシュする必要があるのですか?

00:16:15.000 --> 00:16:23.000
たとえば、ここでは、ユーザー関数ポインタを除いて、同一の3つのパイプライン記述子があります。

00:16:23.000 --> 00:16:30.000
したがって、AIR関数ポインタを使用している場合は、パイプラインのすべての順列をキャッシュする必要があります。

00:16:30.000 --> 00:16:42.000
ただし、バイナリ関数ポインタを使用する場合、新しい関数ポインタが追加されてもパイプラインのバイナリコードは変更されないため、単一のバリアントをキャッシュするだけで十分です。

00:16:42.000 --> 00:16:51.000
また、そのアーカイブを使用して、パイプライン記述子で使用されるバイナリ関数ポインタとは無関係に、パイプラインの他のすべてのバリアントを見つけることができます。

00:16:51.000 --> 00:16:59.000
それをまとめるには、パイプラインのコンパイルコストを制御するのに最適なツールであるため、常にMetalでbinaryArchivesを使用する必要があります。

00:16:59.000 --> 00:17:10.000
binaryArchivesのサポートはすべてのデバイスで利用できますが、BinaryArchiveへの関数ポインタの追加は、関数ポインタの能力に依存します。

00:17:10.000 --> 00:17:17.000
さて、今年の次の追加について簡単にお話ししたいと思います。これはプライベートリンク機能です。

00:17:17.000 --> 00:17:32.000
これまでのところ、動的ライブラリと関数ポインタがシェーダー開発パイプラインに多くの柔軟性を提供する方法について議論しましたが、パフォーマンス上の理由から、外部関数をパイプラインに静的にリンクしたい場合があります。

00:17:32.000 --> 00:17:39.000
昨年、AIR関数を静的にリンクすることをサポートするlinkedFunctions APIを追加しました。

00:17:39.000 --> 00:17:45.000
ただし、これは関数テーブルで使用可能であるため、関数ポインタのサポートが必要です。

00:17:45.000 --> 00:17:48.000
今年はプライベート機能を導入します。

00:17:48.000 --> 00:18:02.000
関数とprivateFunctionの両方がAIRレベルで静的にリンクされていますが、これらはプライベートであるため、関数ポインタの関数処理を行うことはできません。これにより、コンパイラはシェーダーコードを完全に最適化できます。

00:18:02.000 --> 00:18:04.000
それで、彼らはどこで利用できますか?

00:18:04.000 --> 00:18:15.000
この機能はAIRレベルのコードで動作するため、macOS MontereyとiOS 15のすべてのデバイスで利用できます。

00:18:15.000 --> 00:18:21.000
今日議論したい最後の追加、ファンクションステッチに移ります。

00:18:21.000 --> 00:18:26.000
一部のアプリケーションは、実行時に動的コンテンツを生成する必要があります。

00:18:26.000 --> 00:18:32.000
たとえば、ユーザー入力に基づいてグラフィックエフェクトのカスタマイズを実装します。

00:18:32.000 --> 00:18:37.000
または、例えば、受信データに基づく複雑なコンピューティングカーネル。

00:18:37.000 --> 00:18:41.000
ファンクションステッチは、これを解決するための素晴らしいツールです。

00:18:41.000 --> 00:18:48.000
ファンクションステッチの前に、これを行う唯一の方法は、メタルソースストリングを生成することでした。

00:18:48.000 --> 00:18:59.000
文字列操作技術はやや非効率的であり、MetalからAIRへの変換が実行時に行われることも意味します。これは高価な操作になる可能性があります。

00:18:59.000 --> 00:19:03.000
では、ファンクションステッチの仕組みを見てみましょう。

00:19:03.000 --> 00:19:11.000
関数ステッチは、実行時に計算グラフとプリコンパイルされた関数から関数を生成するメカニズムを提供します。

00:19:11.000 --> 00:19:15.000
計算グラフは指向性非巡回グラフです。

00:19:15.000 --> 00:19:26.000
そして、グラフには、生成された関数の引数を表す入力ノードと、関数呼び出しを表す関数ノードの2種類のノードがあります。

00:19:26.000 --> 00:19:41.000
また、あるノードから別のノードへのデータの流れ方を表すデータエッジと、関数呼び出しを実行する順序を表すコントロールエッジの2種類のエッジもあります。

00:19:41.000 --> 00:19:47.000
関数ステッチが計算グラフを使用して関数を生成する方法を見ていきます。

00:19:47.000 --> 00:19:51.000
ステッチ可能な関数の概念から始めます。

00:19:51.000 --> 00:19:54.000
グラフ内の関数には、ステッチ可能な属性が必要です。

00:19:54.000 --> 00:20:00.000
このような関数は、functionStitching APIで使用できる可視関数です。

00:20:00.000 --> 00:20:10.000
ステッチ可能な機能は、MetalからAIRへの翻訳コストを避けるために、アプリケーションバンドルに同梱されているMetalライブラリの一部にすることができます。

00:20:10.000 --> 00:20:18.000
ステッチプロセスは、AIRで直接機能を生成し、メタルフロントエンドを完全にスキップします。

00:20:18.000 --> 00:20:30.000
生成された関数は通常のステッチ可能な関数であるため、パイプラインにリンクしたり、関数ポインタとして直接使用したり、他の関数の生成に使用できます。

00:20:30.000 --> 00:20:39.000
したがって、前のグラフを考慮して、前述したように、ライブラリから二重関数AとCがあると仮定しましょう。

00:20:39.000 --> 00:20:43.000
では、これらの関数をグラフにバインドするとどうなるか見てみましょう。

00:20:43.000 --> 00:20:50.000
ここでのスティッチャーは、対応する関数タイプを各関数ノードに関連付けます。

00:20:50.000 --> 00:20:58.000
N0とN1はFunctionAから型を取得し、N2はFunctionCから型を取得します。

00:20:58.000 --> 00:21:06.000
その後、スティッチャーは、それらを使用して関数のパラメータ型を見て、入力ノードの型を推測します。

00:21:06.000 --> 00:21:17.000
たとえば、Input0は、N0とN1の最初の引数であるため、ポインタで考案された型であると推測されます。

00:21:17.000 --> 00:21:22.000
その後、スティッチャーは、Metalで説明されている次の関数と同等の機能を生成します。

00:21:22.000 --> 00:21:29.000
functionStitching APIを使用すると、そのような関数を含むライブラリをAIRから直接生成できます。

00:21:29.000 --> 00:21:36.000
そして今、私たちはステッチがどのように機能するかについて公正なアイデアを持っているので、APIでそれを使用する方法は次のとおりです。

00:21:36.000 --> 00:21:39.000
まず、ステッチされた関数入力を定義する必要があります。

00:21:39.000 --> 00:21:45.000
この場合、すべての引数を説明するのに十分な入力ノードを作成するだけです。

00:21:45.000 --> 00:21:51.000
次に、グラフで呼び出す各関数の関数ノードを作成します。

00:21:51.000 --> 00:22:00.000
関数呼び出しごとに、明示的な順序付け要件がある場合は、名前、引数、および制御の依存関係を定義します。

00:22:00.000 --> 00:22:10.000
そして最後に、関数名、グラフで使用される関数ノード、および適用したい関数属性を含むグラフを作成します。

00:22:10.000 --> 00:22:17.000
また、結果のステッチ関数の出力値が返されるoutputNodeも割り当てます。

00:22:17.000 --> 00:22:19.000
だから、私たちはグラフを持っています。

00:22:19.000 --> 00:22:22.000
これで、それを使って関数を作成できます。

00:22:22.000 --> 00:22:26.000
最初のステップは、StitchedLibraryDescriptorを作成することです。

00:22:26.000 --> 00:22:32.000
stitchableFunctionsとfunctionGraphをこの記述子に追加します。

00:22:32.000 --> 00:22:39.000
次に、記述子を使用してライブラリを作成し、このライブラリからステッチ関数を作成できます。

00:22:39.000 --> 00:22:48.000
このステッチ機能は、別のステッチグラフの機能を含め、ステッチ可能な機能が期待される場所ならどこでも使用できるようになりました。

00:22:48.000 --> 00:22:51.000
そして、それは機能ステッチのためです。

00:22:51.000 --> 00:22:58.000
このAPIは、macOS MontereyとiOS 15のすべてのデバイスでも利用できます。

00:22:58.000 --> 00:23:05.000
そこで、簡単な要約として、今日はレンダリングパイプラインの動的ライブラリと関数ポインタを見てみました。

00:23:05.000 --> 00:23:11.000
プライベートリンク関数は、可視関数を静的にリンクするために使用できます。

00:23:11.000 --> 00:23:17.000
そして、シェーダーを動的に作成するときに、関数ステッチがコンパイル時間を節約する方法。

00:23:17.000 --> 00:23:22.000
では、いつどちらか一方を選びますか?

00:23:22.000 --> 00:23:27.000
動的ライブラリは、ヘルパー機能とユーティリティ機能をリンクするための優れた選択肢です。

00:23:27.000 --> 00:23:35.000
また、ユーティリティ関数の固定セットがある場合に最もよく使用され、それらの関数はあまり頻繁に変更されません。

00:23:35.000 --> 00:23:43.000
関数ポインタは、シェーダーが署名以外に何も知らない関数を呼び出す機能を追加します。

00:23:43.000 --> 00:23:52.000
いくつの関数が存在するか、名前、または開発者がAIRまたはバイナリを使用して行った速度と柔軟性のトレードオフを知る必要はありません。

00:23:52.000 --> 00:23:56.000
そして今年は、関数ポインタをキャッシュすることもできます。

00:23:56.000 --> 00:24:03.000
プライベート関数は、関数をパイプライン状態オブジェクトに名前で静的にリンクする方法を提供します。

00:24:03.000 --> 00:24:15.000
それらはパイプラインの内部にあるため、目に見える関数テーブルにエンコードすることはできませんが、コンパイラが最大限の最適化を行うことを可能にし、すべてのGPUファミリでサポートされています。

00:24:15.000 --> 00:24:25.000
そして最後に、関数ステッチは、コードのスニペットをAIRに直接事前コンパイルし、実行時に関数コンパイルを実行する方法を提供します。

00:24:25.000 --> 00:24:35.000
今日メタルシェーダーストリングを合成していて、実行時にソースからコンパイルするコストを支払わなければならない場合、ファンクションステッチはこのワークフローを大幅に加速します。

00:24:35.000 --> 00:24:41.000
これらのコンパイラ機能を活用して、Metalを使用して新しい体験を開発できることを願っています。

00:24:41.000 --> 00:24:46.000
見てくれてありがとう、そしてWWDC 2021の残りの部分を楽しんでください。

00:24:46.000 --> 23:59:59.000
[音楽]。

