WEBVTT

00:00:02.000 --> 00:00:15.000
こんにちは、私の名前はAnubhavで、OSパフォーマンスチームのエンジニアです。

00:00:15.000 --> 00:00:22.000
今日は、アプリケーションからのハングを理解し、排除する方法を共有することに興奮しています。

00:00:22.000 --> 00:00:29.000
この講演を4つのセクションに分割し、「ハングとは何ですか?」を理解することから始めます。

00:00:29.000 --> 00:00:35.000
次に、ハングの一般的な原因と、開発時に何に気付き合うべきかについて話します。

00:00:35.000 --> 00:00:42.000
その後、ハングアップの監視と診断に使用できるツールについて説明します。

00:00:42.000 --> 00:00:50.000
最後に、ハングをなくすための一般的な戦略と、アプリに最適なものを選択する方法を学びます。

00:00:50.000 --> 00:00:53.000
すぐに飛び込みましょう。

00:00:53.000 --> 00:01:00.000
私の新しいレシピアプリ、デザート、私のお気に入りの飲み物やデザートの作り方を教えてくれるアプリを見てみましょう。

00:01:00.000 --> 00:01:03.000
このマンゴータンゴのスムージーは美味しそう。

00:01:03.000 --> 00:01:06.000
それをタップして、それがどのように作られているかを確認します。

00:01:06.000 --> 00:01:08.000
うーん。

00:01:08.000 --> 00:01:10.000
何も起こっていないようです。

00:01:10.000 --> 00:01:13.000
うわー。それは予想以上に時間がかかりました。

00:01:13.000 --> 00:01:19.000
アプリはちょうど立ち往生していて、数秒間私のタッチを受け入れませんでした。

00:01:19.000 --> 00:01:24.000
この経験は、「遅れている」、「遅い」、または「立ち往生」と表現できます。

00:01:24.000 --> 00:01:30.000
これらは、私や他の誰かが彼らのアプリを説明するために使いたい言葉ではありません。

00:01:30.000 --> 00:01:36.000
Appleでは、この無反応の時期を「ハング」と呼んでいます。

00:01:36.000 --> 00:01:45.000
ハングとデザートで何が起こっているのかを理解するには、まずアプリの主なランループが何であるかを理解する必要があります。

00:01:45.000 --> 00:01:56.000
メインランループは、アプリケーションのメインスレッドが入力するループで、着信イベント、主にユーザーインタラクションに応答してイベントハンドラを実行します。

00:01:56.000 --> 00:02:06.000
ユーザーがアプリと対話すると、ランループはイベントを受信して処理し、必要に応じてUIを更新します。

00:02:06.000 --> 00:02:11.000
これはすべて、ランループの1回転とメインスレッドで発生します。

00:02:11.000 --> 00:02:16.000
このプロセスは、ユーザー入力ごとに繰り返されます。

00:02:16.000 --> 00:02:23.000
これは、ランループを1回すると、メインスレッドがどのように見えるかです。

00:02:23.000 --> 00:02:33.000
イベントの処理に時間がかかる場合、ユーザー入力とUIの更新の間に遅延が発生します。

00:02:33.000 --> 00:02:41.000
さらに悪いことに、イベントはバッファリングされ、ハング中にメインスレッドでは処理できません。

00:02:41.000 --> 00:02:52.000
ハング中にアプリと対話すると、現在のハングが最初に終了するまで、そのイベントは処理されません。

00:02:52.000 --> 00:03:02.000
一般的に、1秒以上の遅延は常にハングのように見えますが、より短い遅延は1つとして認識することができます。

00:03:02.000 --> 00:03:14.000
たとえば、スクロール中の半秒の遅延は不快ですが、ビューに入ると同じ遅延がはるかに目立ちません。

00:03:14.000 --> 00:03:21.000
ハングをなくすことで、アプリは素早く、素早く、反応が良くなります。

00:03:21.000 --> 00:03:29.000
ハングがわかったので、一般的に原因を調べてみましょう。

00:03:29.000 --> 00:03:33.000
メインスレッドでの作業が多すぎると、ハングが発生します。

00:03:33.000 --> 00:03:41.000
その作業が何であるかを正確に判断するには、イベントの処理中にメインスレッドが何をしているかを確認する必要があります。

00:03:41.000 --> 00:03:44.000
今回は2つのケースに分けることができます。

00:03:44.000 --> 00:03:55.000
メインスレッド自体が作業で忙しいか、これは単一の長いタスクでも多くの短いタスクでもか、メインスレッドが別のスレッドまたはシステムリソースによってブロックされています。

00:03:55.000 --> 00:04:02.000
メインスレッドがビジーになっている一般的な原因を見ることから始めましょう。

00:04:02.000 --> 00:04:10.000
積極的に作業を行うことは、UIを更新するために必要な以上のことを行い、メインスレッドをより長くビジー状態に保ちます。

00:04:10.000 --> 00:04:17.000
Dessertedでは、レシピビューは、多くの成分画像のうち4つの画像タイルのみを表示します。

00:04:17.000 --> 00:04:27.000
メインスレッドがすべての成分画像を一度にロードすると、すべての画像の読み取り、準備、合成に時間を費やします。

00:04:27.000 --> 00:04:32.000
起こっている仕事のほとんどは、ユーザーが見ているものにさえ影響しません。

00:04:32.000 --> 00:04:40.000
ビューには4つの画像しか表示されず、その4つだけをすぐに生成する必要があります。

00:04:40.000 --> 00:04:44.000
ハングのもう1つの原因は、メインスレッドで無関係な作業を行うことです。

00:04:44.000 --> 00:04:53.000
メインスレッドサービスはメインディスパッチキューからブロックしますが、ディスパッチ同期を介して他のキューからブロックをサービスすることもできます。

00:04:53.000 --> 00:05:03.000
キューディスパッチが別のキューに同期するたびに、他のキューのすべての保留中のブロックは、新しくキューに入れられたブロックの前に実行する必要があります。

00:05:03.000 --> 00:05:08.000
優先度の低いシリアルディスパッチキュー、おそらくメンテナンスキューを持つアプリを検討してください。

00:05:08.000 --> 00:05:20.000
メインスレッドディスパッチがメンテナンスキューにブロックを同期した場合、キューに入れられたブロックが実行される前に、そのキュー上のすべての保留中のブロックが実行されるのを待つ必要があります。

00:05:20.000 --> 00:05:26.000
メインスレッドのための作業に費やされた時間のほんの一部でした。

00:05:26.000 --> 00:05:35.000
同様に、ブロックが別のキューからメインキューにディスパッチされた場合、そのブロックはメインスレッドで実行されなければなりません。

00:05:35.000 --> 00:05:42.000
これは、ブロックがディスパッチ非同期を介してキューにされた場合でも有効です。

00:05:42.000 --> 00:05:46.000
ハングのもう1つの原因は、最適でないAPIを使用することです。

00:05:46.000 --> 00:05:48.000
タスクを達成する方法はたくさんあります。

00:05:48.000 --> 00:05:55.000
手元のタスクに最適なものを使用できるように、必ずAPIドキュメントをお読みください。

00:05:55.000 --> 00:06:04.000
Dessertedは、レシピビューのすべての画像に丸みを帯びた角を追加しますが、そうすることで、このビューに入るときにレイテンシも追加されます。

00:06:04.000 --> 00:06:17.000
丸みを帯びた角を追加するには、 Desserted はビットマップベースのグラフィックス コンテキストを使用して画像をビットマップに変換し、そのビットマップに UIBezier パスを適用し、そのビットマップを画像に戻します。

00:06:17.000 --> 00:06:23.000
この一連の操作はCPU集約型で、多くのメモリを使用し、長い時間がかかることがあります。

00:06:23.000 --> 00:06:27.000
これは、間違ったハードウェアが仕事に使われているためです。

00:06:27.000 --> 00:06:32.000
CPUを使用する代わりに、GPUを活用する必要があります。

00:06:32.000 --> 00:06:38.000
レイヤーでCoreAnimationメソッドを使用することで、丸みを帯びた角を追加することは簡単かつ瞬時にできます。

00:06:38.000 --> 00:06:44.000
これは、手元のジョブに間違ったAPIを使用する一例にすぎません。

00:06:44.000 --> 00:06:53.000
アプリのメインスレッドがビジー状態になる可能性がある一般的な理由を調べたので、なぜブロックできるのかを調査しましょう。

00:06:53.000 --> 00:07:00.000
同期APIは、呼び出された時間から戻る時間まで実行をブロックします。

00:07:00.000 --> 00:07:10.000
APIが多くの作業を行う場合、または長期間ブロックする可能性がある場合は、これらをメインスレッドで使用しないでください。

00:07:10.000 --> 00:07:16.000
遅延とは別に、これらはまた、追加の障害点を追加します。

00:07:16.000 --> 00:07:23.000
そのようなケースの1つは、アプリのメインスレッドがネットワークに同期要求を行う場合です。

00:07:23.000 --> 00:07:27.000
5Gを持っている人にとっては、遅延はないかもしれません。

00:07:27.000 --> 00:07:32.000
ネットワーク速度が遅い人にとっては、これには時間がかかる場合があります。

00:07:32.000 --> 00:07:37.000
そして、信号が非常に悪い人にとっては、これは無期限にハングアップする可能性があります。

00:07:37.000 --> 00:07:47.000
これにどれくらいの時間がかかるかの保証はありません。そのため、そのような同期操作はメインスレッドで避けるべきです。

00:07:47.000 --> 00:07:54.000
メインスレッドをブロックするもう1つの方法は、システムリソースです。これらはしばしば制約されます。

00:07:54.000 --> 00:08:00.000
ファイルI/Oは、最も一般的に使用され、競合するシステムリソースの1つです。

00:08:00.000 --> 00:08:10.000
レイテンシは、ハードウェアに依存し、他の読み取りと書き込みが同時に発生し、アプリの制御を超える可能性があります。

00:08:10.000 --> 00:08:18.000
したがって、アプリはメインスレッドのI/Oを回避することで、ハングアップから守るためにできることをする必要があります。

00:08:18.000 --> 00:08:24.000
並行性をサポートしていないデータストアは特に問題です。

00:08:24.000 --> 00:08:38.000
書き込みがすでに発生している間にメインスレッドが1つから読み込もうとすると、すべてのライターが完了するまでその読み取りがプッシュされ、これは無制限になる可能性があります。

00:08:38.000 --> 00:08:41.000
ハングのもう一つの原因は同期です。

00:08:41.000 --> 00:08:53.000
定義上、同期プリミティブは実行をブロックする可能性があるため、メインスレッドからの同期を制限し、注意することが重要です。

00:08:53.000 --> 00:08:59.000
同期するスレッドは、暗黙的または明示的なロックを解放するのに長い時間がかかることがあります。

00:08:59.000 --> 00:09:10.000
これらは、@synchronizedディレクティブ、ディスパッチ同期、os unfairロック、posixロックなど、見るべき一般的なプリミティブです。

00:09:10.000 --> 00:09:19.000
具体的には、優先順位を伝播せず、プリエンプションのためにハングを長くする可能性があるため、セマフォの使用に注意してください。

00:09:19.000 --> 00:09:27.000
一般的なアンチパターンは、セマフォを待って非同期APIを同期させようとするときです。

00:09:27.000 --> 00:09:31.000
これは常にメインスレッドで避けるべきです。

00:09:31.000 --> 00:09:44.000
メインスレッドをブロックするもう1つの方法は、作業、IPC、またはシステムリソースを使用して、頻繁に変更されないものの値を取得することです。

00:09:44.000 --> 00:09:52.000
Dessertedには、ソーシャル機能のアイコンがあり、連絡先を友達として追加した場合にのみ表示されます。

00:09:52.000 --> 00:10:10.000
このビューをタップするたびにすべての連絡先を照会することは、チェックする1つの方法ですが、フレームワークのメインスレッドブロックは、ボンネットの下で高価な操作を実行しているため、不要なオーバーヘッドと遅延を追加します。

00:10:10.000 --> 00:10:23.000
さらに、私が取得している値は頻繁に変更されないので、これを頻繁に照会することは不要であり、システムリソースに負担がかかります。

00:10:23.000 --> 00:10:31.000
CPU、メモリ、ストレージなどのシステムリソースの状態は、ハングが発生した場合に大きく影響します。

00:10:31.000 --> 00:10:41.000
現場でのハードウェアとデバイスの条件が異なることは、現実世界のシナリオが机の上でテスト中に遭遇したものとは大きく異なることを意味します。

00:10:41.000 --> 00:10:51.000
堅牢なテストを行い、最も古いサポートされているハードウェアをベンチマークとして使用することで、これらのケースから防御するためにできることをすることが重要です。

00:10:51.000 --> 00:10:59.000
ハングの高レベルの原因は、メインスレッドで、またはメインスレッドに代わって行われる作業が多すぎることです。

00:10:59.000 --> 00:11:09.000
パフォーマンスを確保するためには、アプリケーションのメインスレッドがUIを更新するために必要なものに焦点を当てることが重要です。

00:11:09.000 --> 00:11:23.000
ハングの一般的な原因がわかったので、開発と生産の両方で、アプリのハングを監視し、トリアージするために使用できるいくつかの便利なツールについて話しましょう。

00:11:23.000 --> 00:11:29.000
ハングをトリアージするには、その間にアプリが何をしているのかを知りたいでしょう。

00:11:29.000 --> 00:11:40.000
タイムプロファイラインストゥルメントでは、時間の経過とともにアプリケーションのコールスタックを表示し、実行されているものを正確に示すことで、それを行うことができます。

00:11:40.000 --> 00:11:51.000
システムトレース機器は、システムコール、VM障害、I/O、およびプロセス間およびプロセス内の相互作用に関するデータでより多くのコンテキストを追加します。

00:11:51.000 --> 00:11:58.000
詳細については、2016年の「System Trace in Depth」トークをご覧ください。

00:11:58.000 --> 00:12:07.000
さて、タイムプロファイラとシステムトレース機器を使用して、デザートがハングアップする原因を見つけます。

00:12:07.000 --> 00:12:13.000
ハングの痕跡をたどった後、インストゥルメントで開かれているように見えます。

00:12:13.000 --> 00:12:26.000
システムトレース出力では、赤い線はシステムコールを示し、紫色のグラフは仮想メモリ障害を示し、水平の青いバーはメインスレッドが作業に忙しいことを示します。

00:12:26.000 --> 00:12:31.000
次のステップは、この作品が何であるかを見ることです。

00:12:31.000 --> 00:12:36.000
タイムプロファイラでは、まさにそれを行うことができます。

00:12:36.000 --> 00:12:45.000
4.7秒のハングの間、メインスレッドのコールスタックを集約することで、コールツリーを表示します。

00:12:45.000 --> 00:12:55.000
ツリーのハイライトされた部分は、このハングの4.6秒がレシピビューのloadAllMessagesメソッドによるものであることを示しています。

00:12:55.000 --> 00:12:58.000
このパターンは見覚えがある。

00:12:58.000 --> 00:13:02.000
Dessertedは、必要以上に多くの画像に読み込まれている可能性があります。

00:13:02.000 --> 00:13:09.000
アプリケーションが出荷されたら、MetricKitを使用して、フィールドでヒットしたハングのコールツリーを収集できます。

00:13:09.000 --> 00:13:16.000
これにより、顧客が最も一般的に発生している問題に基づいて修正に優先順位を付けることができます。

00:13:16.000 --> 00:13:23.000
ハングにMetricKitを使用する方法を学ぶには、2020年の「MetricKitの新機能」トークをチェックしてください。

00:13:23.000 --> 00:13:27.000
私はデザートを出荷し、MetricKitからいくつかのハングレポートを持っています。

00:13:27.000 --> 00:13:34.000
そのうちの1つを見て、トリアージしたばかりのハングに似ているかどうかを見てみましょう。

00:13:34.000 --> 00:13:40.000
MetricKitは、ハング中に取得したコールスタックを集約することで、コールツリーを返します。

00:13:40.000 --> 00:13:46.000
このツリー形式は、タイムプロファイラが提示するものに似ています。

00:13:46.000 --> 00:13:53.000
強調表示された部分は、このハングがインスツルメンツで調査したばかりのハングとは異なることを示しています。

00:13:53.000 --> 00:14:00.000
これは、連絡先を照会するディスパッチキューをブロックする、私が追加した新しいソーシャル機能によるものです。

00:14:00.000 --> 00:14:07.000
MetricKitがなければ、この問題は見つからなかったかもしれないし、現場に残るだろう。

00:14:07.000 --> 00:14:15.000
ハングを修正するときは、アプリのパフォーマンスをベースライン化し、定量化することが重要です。

00:14:15.000 --> 00:14:23.000
Xcodeオーガナイザーは、アプリバージョンごとのハングレートを表示するチャートを含むパフォーマンス指標を表示することでこれを行います。

00:14:23.000 --> 00:14:28.000
これは、回帰をトリアージするときに特に役立ちます。

00:14:28.000 --> 00:14:33.000
Xcodeオーガナイザーの詳細については、これら2つの講演をご覧ください。

00:14:33.000 --> 00:14:41.000
では、アプリのハングを修正するために使用できる一般的な戦略をいくつか確認しましょう。

00:14:41.000 --> 00:14:46.000
これらの戦略のそれぞれは、ハングの複数の原因に対処できます。

00:14:46.000 --> 00:14:54.000
どの修正がアプリに最適かを知るには、その副作用とトレードオフを調べる必要があります。

00:14:54.000 --> 00:15:02.000
ハングを排除して防御するために、メインスレッドでの作業量を減らします。

00:15:02.000 --> 00:15:05.000
これは2つの方法で行うことができます。

00:15:05.000 --> 00:15:12.000
1つ目は、メインスレッドですでに行われている作業を最適化して、実行時間を短縮することです。

00:15:12.000 --> 00:15:19.000
2つ目は、応答性を維持するために、ノンブロッキング方法でメインスレッドから作業を移動することです。

00:15:19.000 --> 00:15:26.000
キャッシングから始めて、メインスレッドの実行を減らす方法から始めましょう。

00:15:26.000 --> 00:15:34.000
キャッシュは、頻繁に使用されるアセットや以前に照会された値にすばやくアクセスするのに最適な方法です。

00:15:34.000 --> 00:15:42.000
それらはしばしばインメモリストアですが、必要に応じて複数のアプリの呼び出しでディスクに永続化できます。

00:15:42.000 --> 00:15:56.000
Dessertedの成分画像タイルのように、後で必要になる可能性のあるフォーマットされたアセットは、必要なときに毎回これらのアセットを作成するのに費用がかかるため、キャッシングに最適な候補です。

00:15:56.000 --> 00:16:05.000
これらをNSCacheにキャッシュすることで、資産の生成のオーバーヘッドはクイックメモリ読み取りに置き換えられます。

00:16:05.000 --> 00:16:11.000
これにより、Instrumentsで見たハングがなくなります。

00:16:11.000 --> 00:16:20.000
古いデータを持つことと常にキャッシュを更新することのバランスを取るために、正確なキャッシュ無効化メカニズムを持つことが重要です。

00:16:20.000 --> 00:16:31.000
この作業は、メインスレッドがイベントに応答し続けるために、セカンダリディスパッチキューで非同期に行われるはずです。

00:16:31.000 --> 00:16:37.000
通知オブザーバーは、メインスレッドでの作業を減らす別の方法です。

00:16:37.000 --> 00:16:47.000
高価なオンデマンド計算を行うことなく、アプリが値や状態の変化に反応できるようにします。

00:16:47.000 --> 00:16:52.000
どのクラスでも、自分のクラスでも通知を投稿できます。

00:16:52.000 --> 00:16:57.000
特定のクラスからの通知を見つけるには、そのAPIドキュメントを確認してください。

00:16:57.000 --> 00:17:08.000
観察可能なすべてのシステム通知を見つけるには、NSNotification.NameのApple開発者ドキュメントページをチェックしてください。

00:17:08.000 --> 00:17:13.000
これの素晴らしい候補は、デザートの社会的特徴です。

00:17:13.000 --> 00:17:24.000
abDatabaseChangedExternally通知にオブザーバーを登録することで、メインスレッドは連絡先のクエリを待つ必要がなくなりました。

00:17:24.000 --> 00:17:28.000
通知が届くと、オブザーバーが呼び出されます。

00:17:28.000 --> 00:17:34.000
この場合、キャッシュされた値を更新します。

00:17:34.000 --> 00:17:44.000
メインスレッドの応答性を維持するために、これらの更新は非同期である必要があります。これは、ハンドラを別のキューにdispatch_asyncすることで達成されます。

00:17:44.000 --> 00:17:52.000
今、私は以前と同じ機能を提供しますが、MetricKitログで見たハングはありません。

00:17:52.000 --> 00:17:57.000
ハングをなくすもう1つの方法は、メインスレッドから作業を移動することです。

00:17:57.000 --> 00:18:02.000
まず、この仕事がどうあるべきかを決定する必要があります。

00:18:02.000 --> 00:18:10.000
一般に、UIに重要な情報を提供する重要なタスクは、メインスレッドに残る必要があります。

00:18:10.000 --> 00:18:18.000
さらに、すべてのビューとビューコントローラーは、メインスレッドで作成、変更、破棄する必要があります。

00:18:18.000 --> 00:18:31.000
ただし、UI要素を更新するために必要な計算は、メインスレッドで実際の更新を実行するための完了ハンドラを使用して、別のスレッドにオフロードすることができます。

00:18:31.000 --> 00:18:37.000
このパターンは、計算に時間がかかることがわかっている場合に便利です。

00:18:37.000 --> 00:18:47.000
その他の重要度の低いタスク、メンテナンス、またはタイムクリティカルでないタスクは、別のスレッドで非同期に実行する必要があります。

00:18:47.000 --> 00:18:55.000
これらは、より低いスケジューリング優先度で実行され、メインスレッド上の作業よりも完了に時間がかかる場合があります。

00:18:55.000 --> 00:19:03.000
これは意図的であり、メインスレッドは重要な作業のみを実行すべきであるという考えを反映しています。

00:19:03.000 --> 00:19:14.000
メインスレッドから非同期操作を実行する最も簡単な方法は、同期APIの非同期対応を使用することです。

00:19:14.000 --> 00:19:18.000
ネットワーキングを例に挙げてみましょう。

00:19:18.000 --> 00:19:27.000
同期ネットワークAPIに非同期NSURL対応を使用することで、アプリは応答性が向上します。

00:19:27.000 --> 00:19:38.000
非同期APIは、多くの場合、「非同期」という単語またはメソッド名の完了ハンドラの存在によって示されます。

00:19:38.000 --> 00:19:51.000
Grand Central Dispatchは強力なマルチスレッドメカニズムであり、非同期APIバリアントがない場合、またはメインスレッドから移動したいコードが独自のものである場合に活用できます。

00:19:51.000 --> 00:20:02.000
Grand Central Dispatchは、作業ブロックを同期または非同期に別のスレッドに移動する簡単なメカニズムを提供します。

00:20:02.000 --> 00:20:10.000
これにより、GCDはハングの最も一般的な原因を排除するのに非常に効果的です。

00:20:10.000 --> 00:20:19.000
別のスレッドで作業ブロックを非同期に実行するには、そのブロックを別のディスパッチキューに非同期にディスパッチします。

00:20:19.000 --> 00:20:28.000
完了ハンドラは、メインキューにディスパッチバックすることで、非同期ブロック内に追加できます。

00:20:28.000 --> 00:20:33.000
グランドセントラルディスパッチでは、計算を事前に温めることもできます。

00:20:33.000 --> 00:20:44.000
タスクをキュー、おそらくprefetchQueueに非同期させることで、メインスレッドが他の作業を行うために自由である間にタスクが実行を開始します。

00:20:44.000 --> 00:20:53.000
これらの結果がメインスレッドで必要な場合、prefetchQueueに同期をディスパッチして、タスクが完了するのを待つことができます。

00:20:53.000 --> 00:20:57.000
GCDができることの表面に触れたところです。

00:20:57.000 --> 00:21:05.000
詳細については、2017年の「Modernizing Grand Central Dispatch」トークをご覧ください。

00:21:05.000 --> 00:21:10.000
先ほど話したソリューションとのトレードオフを理解しましょう。

00:21:10.000 --> 00:21:17.000
キャッシュはメモリを使用するため、大きなメモリの増加を避けるために、そのサイズを認識する必要があります。

00:21:17.000 --> 00:21:24.000
また、値が古くならないように、正確な無効化メカニズムがあることを確認することも重要です。

00:21:24.000 --> 00:21:27.000
通知はおしゃべりにすることができます。

00:21:27.000 --> 00:21:34.000
1つを観察するときは、その通知が発火する頻度を考慮することが重要です。

00:21:34.000 --> 00:21:43.000
複数の通知を処理または合体する前にフィルターを追加すると、CPUの解約が減少します。

00:21:43.000 --> 00:22:01.000
非同期APIを使用する場合は、オペレーティングシステムが非同期作業を優先しないため、特にUI更新に不可欠かどうかを最初に確認することで、問題の操作を非同期にする必要があるかどうかを知ることが重要です。

00:22:01.000 --> 00:22:11.000
Grand Central Dispatchを使用してタスクを非同期に実行する場合、コード内のタスクが実行される順序を変更します。

00:22:11.000 --> 00:22:19.000
アプリが壊れないようにするために、他の人にどのタスクを注文する必要があるかを覚えておくことが重要です。

00:22:19.000 --> 00:22:26.000
シリアルキューでdispatch_syncを使用することは、必要に応じて操作を同期するのに最適な方法です。

00:22:26.000 --> 00:22:35.000
ハングがユーザーエクスペリエンスにもたらす深刻な影響と比較して、これらのトレードオフは常に価値があります。

00:22:35.000 --> 00:22:42.000
ハングを解消する際に心に留めておくべきいくつかの考えは、AppleフレームワークとAPIを使用することです。

00:22:42.000 --> 00:22:52.000
これらはすでに幅広いデバイスセットと互換性があり、高性能であり、より効率的で効果的なものになるように常に更新されています。

00:22:52.000 --> 00:22:56.000
コードで反復的に改善を実行します。

00:22:56.000 --> 00:23:03.000
このようにして、ターゲットを絞った修正を行い、個々の変更の影響を見ることができます。

00:23:03.000 --> 00:23:07.000
システムリソースを使用するときは、良い隣人になりましょう。

00:23:07.000 --> 00:23:16.000
必要以上のリソースを使用すると、独自のアプリのパフォーマンスが低下するだけでなく、システム内の他の減速を引き起こす可能性があります。

00:23:16.000 --> 00:23:25.000
一緒に、私たちはどのように不快なハングができるか、そしてあなたのアプリでハングアップから守ることがいかに重要であるかを経験しました。

00:23:25.000 --> 00:23:32.000
今後は、Xcodeオーガナイザーを介してアプリのパフォーマンスベースラインを設定します。

00:23:32.000 --> 00:23:38.000
開発とコードレビュー中は、ハングを引き起こす可能性のあるアンチパターンに注意してください。

00:23:38.000 --> 00:23:42.000
私たちは最も一般的なものの7つについて話し合いました。

00:23:42.000 --> 00:23:55.000
タイムプロファイラとシステムトレース機器で出てくる問題を診断し、MetricKitを使用して、顧客が最も頻繁に発生している問題に優先順位を付けます。

00:23:55.000 --> 00:24:08.000
キャッシュを使用したり、通知を観察したり、非同期の代替案を探したり、グランドセントラルディスパッチを利用したりして、見つけたハングを解消します。

00:24:08.000 --> 00:24:17.000
これらの手順に従うことで、アプリは可能な限り最高のユーザーエクスペリエンスを提供するためにさらに優れたパフォーマンスを発揮します。

00:24:17.000 --> 00:24:19.000
ぶらぶらしてくれてありがとう。

00:24:19.000 --> 23:59:59.000
[音楽]。

