WEBVTT

00:00:00.000 --> 00:00:05.000
♪ベース音楽の演奏♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:11.000
ルイ・パウロ:こんにちは、皆さん、私はルイです。

00:00:11.000 --> 00:00:24.000
今日、同僚のエリックと私は、iOS 15とmacOS Montereyで利用可能な2つの新しいプロトコルであるHTTP/3とQUICでアプリのネットワーキングを高速化する方法について話します。

00:00:24.000 --> 00:00:30.000
HTTPの進化と、HTTP/3がどのようにパフォーマンスを向上させるかを探求することから始めます。

00:00:30.000 --> 00:00:36.000
また、HTTP/3の背後にある新しいトランスポートプロトコルであるQUICについても説明します。

00:00:36.000 --> 00:00:47.000
その後、URLSessionでHTTP/3を使用する方法と、HTTP/3をサポートするようにHTTPサーバーを設定する方法について説明します。

00:00:47.000 --> 00:00:56.000
最後に、QUICを使用するためのAPIと、QUICの上にカスタムネットワークプロトコルを実装する方法を深く掘り下げます。

00:00:56.000 --> 00:01:00.000
では、HTTPの進化から始めましょう。

00:01:00.000 --> 00:01:02.000
リソースを取得する必要があるとしましょう。

00:01:02.000 --> 00:01:09.000
接続を設定し、リクエストを送信し、サーバーが処理するのを待ち、応答を受け取ります。

00:01:09.000 --> 00:01:25.000
さて、最初のリソースが終了する前に別のリソースを取得したい場合は、接続の設定、リクエストの送信、処理の待ち、応答の受信など、同じプロセスを再度実行する必要があります。今回は濃い緑色で示されています。

00:01:25.000 --> 00:01:29.000
これは、オレンジ色の3番目のリソースの別の例です。

00:01:29.000 --> 00:01:34.000
図で概説されているように、接続の設定に多くの時間が費やされています。

00:01:34.000 --> 00:01:37.000
単一のHTTP/1接続を再利用するとどうなりますか?

00:01:37.000 --> 00:01:44.000
接続設定時間を節約しましたが、リクエストは以前の応答が終了した後にのみ送信できます。

00:01:44.000 --> 00:01:47.000
これはヘッドオブラインブロッキングとして知られています。

00:01:47.000 --> 00:01:54.000
過去には、HTTP実装では、この問題を克服するために多くの並列接続を使用していました。

00:01:54.000 --> 00:01:59.000
並列HTTP接続の数は、アプリによって設定可能でした。

00:01:59.000 --> 00:02:05.000
しかし、これはクライアントとサーバーの両方で非効率的なネットワーク動作につながりました。

00:02:05.000 --> 00:02:12.000
HTTP/2は、単一の接続で複数のストリームを多重化することで、ヘッドオブラインブロッキングを解決します。

00:02:12.000 --> 00:02:18.000
リクエストはより早く送信され、異なるストリームからのデータをインターリーブすることができます。

00:02:18.000 --> 00:02:24.000
これにより、アイドル状態の待ち時間が大幅に短縮されるため、単一のTCP接続をより効率的に使用できます。

00:02:24.000 --> 00:02:31.000
HTTP/3では、接続の設定がはるかに高速になるため、リクエストはより早く送信できます。

00:02:31.000 --> 00:02:36.000
しかし、それがHTTP/3の唯一の利点ではありません。

00:02:36.000 --> 00:02:46.000
HTTP/3ストリームは独立しており、すべてのストリームが単一のTCP接続を共有するHTTP/2とは異なります。

00:02:46.000 --> 00:02:49.000
ほとんどのネットワークでは、パケットが失われます。

00:02:49.000 --> 00:02:56.000
これはワイヤレスネットワーク上の通常の出来事であり、ネットワークの容量を検出する自然な部分です。

00:02:56.000 --> 00:03:05.000
HTTP/2では、すべてのHTTP/2ストリームが単一のTCP接続を共有しているため、パケット損失は多くのストリームに影響を与える可能性があります。

00:03:05.000 --> 00:03:10.000
HTTP/3では、対応するHTTPストリームのみが影響を受けます。

00:03:10.000 --> 00:03:14.000
他のストリームに属するデータは、より早く配信できます。

00:03:14.000 --> 00:03:22.000
HTTP/3が接続をより早く確立する方法と、パケット損失によりよく対処する方法を示しました。

00:03:22.000 --> 00:03:28.000
これらの改善は、基礎となるトランスポートプロトコルであるQUICによって有効になります。

00:03:28.000 --> 00:03:34.000
QUICは、インターネットエンジニアリングタスクフォースによって標準化された新しい信頼性の高いトランスポートプロトコルです。

00:03:34.000 --> 00:03:42.000
TCPと同じ概念に基づいていますが、エンドツーエンドの暗号化、多重化されたストリーム、および認証を提供します。

00:03:42.000 --> 00:03:48.000
QUICのセキュリティは、よく知られているTLS 1.3プロトコルの上に構築されています。

00:03:48.000 --> 00:03:51.000
QUICの主な利点は、パフォーマンスの向上です。

00:03:51.000 --> 00:03:56.000
QUICがそれをどのように達成するかを探りましょう。

00:03:56.000 --> 00:04:08.000
QUICは、安全なハンドシェイクを実行するためにTLS 1.3に依存しており、使い慣れたTCPの3ウェイハンドシェイクを必要とせず、ハンドシェイク時間を1往復に短縮します。

00:04:08.000 --> 00:04:14.000
多重化されたストリームはQUICの重要な概念であるため、ヘッドオブラインブロッキングに苦しむことはありません。

00:04:14.000 --> 00:04:28.000
QUICエンドポイントは、受信したパケットに関するより複雑な情報を他のエンドポイントに通信することができ、TCPの制限によって妨げられないため、QUIC接続では損失回復が向上します。

00:04:28.000 --> 00:04:42.000
このプロトコルは、セルラーネットワークとWi-Fi間のセッションを再確立することなく、接続が異なるネットワークインターフェイス間でシームレスに移動できるようにする接続移行もサポートしています。

00:04:42.000 --> 00:04:49.000
ネットワークの遅延について詳しく知りたい場合は、「アプリのネットワーク遅延を減らす」セッションをご覧ください。

00:04:49.000 --> 00:04:54.000
アプリでHTTP/3を使用する方法について話しましょう。

00:04:54.000 --> 00:05:04.000
URLSessionを使用している場合は、iOS 15とmacOS MontereyがデフォルトでHTTP/3が有効になっているため、アプリを変更する必要はありません。

00:05:04.000 --> 00:05:08.000
サーバーでHTTP/3を有効にしたら、大丈夫です。

00:05:08.000 --> 00:05:16.000
今後のHTTP/3 RFCバージョンと以前のHTTP/3ドラフトバージョン29の両方がサポートされています。

00:05:16.000 --> 00:05:20.000
では、アプリがHTTP/3を使用していることを確認するにはどうすればよいですか?

00:05:20.000 --> 00:05:23.000
インスツルメンツを使って調べてみよう!

00:05:23.000 --> 00:05:31.000
Xcode 13では、HTTPトラフィックを検査するためのネットワークプロファイリングテンプレート内に新しい機器を導入しています。

00:05:31.000 --> 00:05:35.000
URLSessionに直接タップするので、セットアップは必要ありません。

00:05:35.000 --> 00:05:43.000
Instrumentsを使用して、アプリがHTTP/3または以前のHTTPバージョンを使用しているかどうかを確認できます。

00:05:43.000 --> 00:05:48.000
起動時に犬の写真のセットを取得するiOSアプリを起動します。

00:05:48.000 --> 00:05:55.000
次に、HTTPヘッダーを調べて、サーバーがHTTP/3をどのように宣伝しているかを調べます。

00:05:55.000 --> 00:06:05.000
先に進んで、ネットワークプロファイリングテンプレートを選択しましょう。

00:06:05.000 --> 00:06:09.000
左上の「記録」をクリックしましょう。

00:06:09.000 --> 00:06:15.000
HTTPトラフィックを記録することのプライバシーへの影響を示すプロンプトが表示されます。

00:06:15.000 --> 00:06:29.000
同意した後、InstrumentsはHTTPトランザクションの記録を開始します。

00:06:29.000 --> 00:06:35.000
次に、Instrumentsは、アプリごとおよびドメインごとのすべてのHTTPトランザクションを含むプロットを表示します。

00:06:35.000 --> 00:06:37.000
私たちは今、必要なすべてのデータをキャプチャしました。

00:06:37.000 --> 00:06:44.000
左上にある一時停止ボタンをクリックすることができます。

00:06:44.000 --> 00:06:46.000
使用しているドメインを選択しましょう。 

00:06:46.000 --> 00:06:56.000
Optionキーを押しながらHTTPトランザクションをクリックし、ドメインを選択することで、それを行うことができます。

00:06:56.000 --> 00:07:01.000
HTTPトランザクションの詳細を表示するようにインストゥルメントを設定する必要があります。

00:07:01.000 --> 00:07:12.000
それを達成するために、左側のメニューにHTTPトランザクションが表示されていることを確認してください。

00:07:12.000 --> 00:07:16.000
最初のリクエストを選択しましょう。

00:07:16.000 --> 00:07:25.000
右にスクロールすると、このトランザクションが使用したHTTPのバージョンを識別するHTTPバージョン列を見つけることができます。

00:07:25.000 --> 00:07:30.000
うーん、私たちはまだHTTP/2を使用していますが、それはなぜですか？

00:07:30.000 --> 00:07:35.000
右側には、応答ヘッダーを含む拡張詳細ビューがあります。

00:07:35.000 --> 00:07:47.000
これは私たちに答えを与えます:サーバーはHTTP / 3のサポートを宣伝するためにHTTP代替サービスを使用しました。

00:07:47.000 --> 00:07:51.000
URLSessionは、宣伝されない限りHTTP/3を使用しません。

00:07:51.000 --> 00:07:57.000
この例では、HTTP/3はAlt-Svc HTTPヘッダーを介してアドバタイズされました。

00:07:57.000 --> 00:08:04.000
HTTPサーバーは、このヘッダーを使用してHTTP/3のサポートをアドバタイズするのが一般的です。

00:08:04.000 --> 00:08:10.000
この情報は将来の接続のために記憶されており、私たちはこれを「サービスディスカバリー」と呼んでいます。

00:08:10.000 --> 00:08:17.000
では、もう一度アプリを録画しましょう。

00:08:17.000 --> 00:08:23.000
インスツルメンツがアプリを再起動すると、同じ一連のHTTPトランザクションが行われます。

00:08:23.000 --> 00:08:30.000
繰り返しになりますが、インストゥルメントを一時停止できるようになりました。

00:08:30.000 --> 00:08:34.000
もう一度ズームインして、最初のトランザクションを調べてみましょう。

00:08:34.000 --> 00:08:41.000
サーバーがHTTP/3をサポートしていたことを思い出したので、現在はHTTP/3を使用しています。

00:08:41.000 --> 00:08:45.000
HTTP/3サービスディスカバリーは、アプリに対して透過的です。

00:08:45.000 --> 00:08:49.000
HTTP/3サーバーサポートの発見は、2つの方法で行われます。

00:08:49.000 --> 00:08:59.000
推奨されるアプローチは、HTTPSリソースレコードを通じてHTTP/3のサポートをアドバタイズするようにDNSサーバーを設定することです。

00:08:59.000 --> 00:09:07.000
h3文字列を使用してHTTP/3をアドバタイズするようにアプリケーション層プロトコルを設定するだけです。

00:09:07.000 --> 00:09:14.000
また、代替サービスを使用してHTTP/3をアドバタイズする新しいヘッダーを追加するようにサーバーを設定する必要があります。

00:09:14.000 --> 00:09:19.000
サーバーは、HTTP/3をアドバタイズするAlt-Svcヘッダーを送信する必要があります。

00:09:19.000 --> 00:09:24.000
これには、ポート番号とサービスの最大年齢（秒単位）が含まれます。

00:09:24.000 --> 00:09:37.000
DNSレコードの利点は、情報がDNSにあるため、アプリがサーバーに最初に接続しようとするときにHTTP/3接続を確立できることです。

00:09:37.000 --> 00:09:46.000
サーバーがHTTP/3をサポートしていることがわかっていて、検出プロセスを高速化したい場合は、assumesHTTP3Capableプロパティを使用できます。

00:09:46.000 --> 00:09:56.000
これにより、HTTPスタックはHTTP/3サーバーを持っていると仮定できますが、HTTP/3が使用されることを保証するものではありません。

00:09:56.000 --> 00:10:02.000
ネットワークは依然としてHTTP/3をブロックするか、サーバーが実際にHTTP/3をサポートしていない可能性があります。

00:10:02.000 --> 00:10:07.000
その場合は、HTTP/2にフォールバックします。

00:10:07.000 --> 00:10:12.000
HTTPを使用すると、クライアントは各リソースの優先順位を指定できます。

00:10:12.000 --> 00:10:21.000
リソースはしばしば関連しているため、優先順位により、サーバーはクライアントのニーズに基づいて、いくつかのリソースを他のリソースよりも早く送信できます。

00:10:21.000 --> 00:10:30.000
たとえば、Webブラウジングのユーザーエクスペリエンスは、Webページのレンダリングに最も影響を与えるリソースに優先順位を付けることで改善できます。

00:10:30.000 --> 00:10:37.000
HTTP/2では優先スキームが導入されましたが、その複雑さのためにしばしば尊重されませんでした。

00:10:37.000 --> 00:10:42.000
そのため、古い優先度モデルはHTTP/3から削除されました。

00:10:42.000 --> 00:10:49.000
HTTPヘッダーに依存する新しい、よりシンプルなモデルは、HTTP/3スタックで使用されます。

00:10:49.000 --> 00:10:57.000
このモデルでは、優先順位は緊急性パラメータ（0から7）とオプションの増分配信パラメータで指定されます。

00:10:57.000 --> 00:11:02.000
URLSessionを使用する場合、優先順位をサポートするAPIは同じままです。

00:11:02.000 --> 00:11:11.000
緊急性を使用してサーバーに伝達されるpriorityプロパティを使用して、HTTP優先度を指定します。

00:11:11.000 --> 00:11:16.000
prefersIncrementalDeliveryプロパティで増分配信を有効にできます。

00:11:16.000 --> 00:11:18.000
デフォルトの優先度は3です。

00:11:18.000 --> 00:11:28.000
URLSessionは、非同期データメソッドのような便利なAPIが使用されているかどうかに応じて、増分配信を推測します。

00:11:28.000 --> 00:11:37.000
アプリがリソース全体がダウンロードされるまで処理できないコンテンツをダウンロードしている場合は、このプロパティをfalseに設定する必要があります。

00:11:37.000 --> 00:11:44.000
リクエストが送信された後のリソースの優先度を動的に変更することもサポートされています。

00:11:44.000 --> 00:11:53.000
たとえば、より低い優先度で写真をプリフェッチし、ユーザーがアプリのそのセクションに移動するときにその優先度を上げることができます。

00:11:53.000 --> 00:12:00.000
次に、同僚のエリックが、カスタムネットワークプロトコルを変更してQUICを採用する方法を説明します。

00:12:00.000 --> 00:12:02.000
ありがとうございます。

00:12:02.000 --> 00:12:04.000
エリック・キニア:ありがとう、ルイ!

00:12:04.000 --> 00:12:20.000
先に説明したように、HTTP/3は、HTTP/2と同様の多重化されたストリームを提供するQUICの上に構築されていますが、基礎となるトランスポートとして単一のTCP接続を共有することによってもたらされる問題はありません。

00:12:20.000 --> 00:12:29.000
QUICトランスポート接続（またはQUICトンネル）は、複数の単方向または双方向のQUICストリームのデータを多重化します。

00:12:29.000 --> 00:12:42.000
ストリームは、いずれかのエンドポイントで作成でき、他のストリームとインターリーブされたデータを同時に送信でき、TCPによって提供される従来のストリームと同様の状態を持つことができます。

00:12:42.000 --> 00:12:51.000
何よりも、QUICにはTLS 1.3セキュリティが組み込まれており、変化するネットワーク条件によりよく対応できます。

00:12:51.000 --> 00:12:55.000
これらの機能は、HTTP以上の場合に役立ちます。

00:12:55.000 --> 00:13:15.000
アプリケーションが非要求/応答ベースのデータを交換している場合、基礎となるトランスポートコンテキストを共有するストリームを多重化すること、またはピアツーピア通信やRPCコールなどの他のカスタムプロトコルを実装している場合は、アプリにQUICトランスポートを使用することを検討してください。

00:13:15.000 --> 00:13:25.000
iOS 15とmacOS Montereyでは、NWProtocolQUICはNetwork.frameworkが提供する他の組み込みプロトコルに参加します。

00:13:25.000 --> 00:13:29.000
QUICを使用する接続を作成することは非常によく知られています。

00:13:29.000 --> 00:13:34.000
エンドポイントと新しく利用可能なQUICパラメータを提供するだけです。

00:13:34.000 --> 00:13:42.000
これらのパラメータは、サーバーとネゴシエートするためのアプリケーション層プロトコルであるALPN文字列を指定します。

00:13:42.000 --> 00:13:50.000
状態更新ハンドラを通常どおりに設定して、接続が進行して準備が整ったときに応答できるようにします。

00:13:50.000 --> 00:13:58.000
そして最後に、状態の更新やその他のコールバックに使用したいディスパッチキューで接続を開始します。

00:13:58.000 --> 00:14:05.000
QUICストリームが確立されたので、他のNWConnectionと同じようにデータを送受信できます。

00:14:05.000 --> 00:14:14.000
送信機能を使用して、リモートエンドポイントに送信するデータを提供し、完了したら後続の送信をスケジュールします。

00:14:14.000 --> 00:14:20.000
受信を使用して受信データを処理し、完了したら後続の受信をスケジュールします。

00:14:20.000 --> 00:14:31.000
昨年、複数の接続が関連またはグループ化されている状況を簡単に処理できるように、Network.frameworkにConnection Groupオブジェクトを導入しました。

00:14:31.000 --> 00:14:45.000
基礎となるトランスポートコンテキスト（またはトンネル）で多重化されたQUICストリームは、その関係に基づいて論理的にグループ化され、新しいグループタイプであるNWMultiplexGroupで使用できます。

00:14:45.000 --> 00:14:58.000
接続グループは、他のNetwork.frameworkオブジェクトと同様のライフサイクルをたどり、QUICストリームによって共有される基礎となるQUICトンネルの状態について推論することができます。

00:14:58.000 --> 00:15:07.000
また、特定のQUICトンネルから新しい発信ストリームを作成したり、リモートエンドポイントによって開始された新しい着信ストリームを受信したりすることもできます。

00:15:07.000 --> 00:15:13.000
多重化プロトコルの接続グループを作成するには、多重グループ記述子を使用します。

00:15:13.000 --> 00:15:19.000
この場合、ポート443でexample.comにグループ記述子を作成します。

00:15:19.000 --> 00:15:29.000
次に、その記述子とQUICパラメータを使用してNWConnectionGroupを作成し、作成時にALPN文字列を提供します。

00:15:29.000 --> 00:15:40.000
NWConnectionと同様に、状態更新ハンドラを設定しますが、今回は個々のストリームの状態ではなく、基礎となるQUICトンネルの状態を追跡しています。

00:15:40.000 --> 00:15:45.000
最後に、接続グループを開始し、コールバックキューを提供します。

00:15:45.000 --> 00:15:55.000
新しい発信ストリームは、グループからNWConnectionを初期化するか、グループの抽出関数を呼び出すことによって作成できます。

00:15:55.000 --> 00:16:03.000
リモートエンドポイントによって開始された着信ストリームは、グループに新しい接続ハンドラを設定することで処理できます。

00:16:03.000 --> 00:16:14.000
これらの接続は、ステートハンドラ（今回はストリーム状態を追跡する）で通常どおり設定でき、コールバックに使用するキューから開始できます。

00:16:14.000 --> 00:16:21.000
他のプロトコルと同様に、パラメータのオブジェクトを作成するときに設定にQUIC.Optionsを使用できます。

00:16:21.000 --> 00:16:38.000
QUICの場合、QUIC仕様に記載されているトランスポートパラメータを設定できます。また、接続グループから作成するときに個々のストリームのプロパティをカスタマイズすることもできます。たとえば、新しい単方向ストリームを作成する場合などです。

00:16:38.000 --> 00:16:49.000
NWListenerを使用してアプリでサーバーを実行している場合は、newConnectionGroupHandlerを介して新しい着信QUICトンネルを受信できるように強化されています。

00:16:49.000 --> 00:16:56.000
newConnectionGroupHandlerは、誰かがサーバーに新しいQUICトンネルを確立するたびに呼び出されます。

00:16:56.000 --> 00:17:01.000
そのハンドラー内では、通常どおりグループを設定して状態の更新を受信できます。

00:17:01.000 --> 00:17:06.000
これは、先ほど議論していた新しい接続ハンドラを設定するのにも良い場所です。

00:17:06.000 --> 00:17:15.000
このトンネルで開かれた後続のストリームを受信したい場合は、コールバックに使用するキューでグループを開始し、準備完了です!

00:17:15.000 --> 00:17:21.000
最後に、NWProtocolMetadataを使用してストリームに関する情報にアクセスできます。

00:17:21.000 --> 00:17:26.000
たとえば、新しく作成されたストリームのストリームIDを確認したい場合があります。

00:17:26.000 --> 00:17:38.000
また、ストリームが終了したら、カスタムプロトコルでapplicationErrorコードが定義されている場合は、ストリームをキャンセルする前に、メタデータを使用してエラーをリモートエンドポイントに伝えることができます。

00:17:38.000 --> 00:17:52.000
そこで、新しいNWMultiplexGroupタイプを使用してQUICトンネルを作成および管理し、そのグループから各QUICストリームに個別のNWConnectionsを作成する方法を検討しました。

00:17:52.000 --> 00:18:00.000
NWListenerを使用して着信トンネルをリッスンし、結果の接続グループを使用して新しい着信ストリームを受信できます。

00:18:00.000 --> 00:18:19.000
これらのストリームでは、他の接続と同様にデータを送受信でき、QUICプロトコルオプションを使用してトランスポートパラメータを指定し、ストリームを設定できますが、QUICプロトコルメタデータを使用してストリームを検査し、QUIC固有の情報をリモートエンドポイントに通信します。

00:18:19.000 --> 00:18:25.000
QUICを採用することでアプリのネットワーキングを改善したので、それが機能しているかどうかをどのように見分けますか?

00:18:25.000 --> 00:18:31.000
Qlogファイルを出力する新しい環境変数を使用して、デバッグ中にアプリを起動できます。

00:18:31.000 --> 00:18:45.000
qlogは、IETFで提案された新しい標準化されたロギング形式です。これにより、従来のパケットキャプチャよりも、QUIC接続がどのように動作しているかに関するさらに豊富な情報をエクスポートできます。

00:18:45.000 --> 00:18:53.000
テスト実行後、Xcodeのデバイスウィンドウを使用して、分析のためにqlogファイルを含むアプリのコンテナをダウンロードできます。

00:18:53.000 --> 00:19:02.000
また、QUIC接続の動作を内省しやすくするさまざまなオープンソースビジュアライゼーションがいくつかあります。

00:19:02.000 --> 00:19:08.000
今日は、HTTP/3がHTTPトラフィックに提供する改善点を調べました。

00:19:08.000 --> 00:19:22.000
クライアントでは、最新のネットワークAPIのユーザーはすでにデフォルトでオンになっているため、サーバーでHTTP / 3を有効にして、変化するネットワーク条件に対するパフォーマンスと回復力の向上を活用します。

00:19:22.000 --> 00:19:35.000
カスタムの非HTTPネットワーキングプロトコルを使用している場合は、Network.frameworkに組み込まれている新しい多重化プロトコルサポートを使用して、NWConnectionGroupとのQUIC接続を作成します。

00:19:35.000 --> 00:19:43.000
また、どのプロトコルを使用しても、新しいデバッグツールを使用して、次世代のネットワークプロトコルの素晴らしい利点を視覚化できます。

00:19:43.000 --> 00:19:44.000
見てくれてありがとう。

00:19:44.000 --> 23:59:59.000
♪

