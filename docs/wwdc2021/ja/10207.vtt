WEBVTT

00:00:00.000 --> 00:00:05.000
♪ベース音楽の演奏♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:13.000
ウィル・アダリオ・ターナー:こんにちは、「XCTestで予想される失敗を受け入れる」へようこそ。

00:00:13.000 --> 00:00:21.000
私の名前はウィルです。このセッションでは、プロジェクトのテストを実行するときに得られるデータを改善する方法について説明します。

00:00:21.000 --> 00:00:25.000
まず、そもそもなぜコードをテストするのかを考えてみましょう。

00:00:25.000 --> 00:00:29.000
もちろん、高いレベルでは、製品の品質を確保する方法です。

00:00:29.000 --> 00:00:37.000
しかし、より具体的には、出荷前にバグを発見するためであり、その後ではないと思います。

00:00:37.000 --> 00:00:39.000
今、テストは投資です。

00:00:39.000 --> 00:00:44.000
テストを作成、実行、維持するにはリソースが必要です。

00:00:44.000 --> 00:00:50.000
他の投資と同様に、コストを最小限に抑えながらリターンを最大化したいと考えています。

00:00:50.000 --> 00:00:54.000
このセッションでは、メンテナンスコストを削減するためのツールに焦点を当てます。

00:00:54.000 --> 00:01:02.000
メンテナンスでは、主にテストスイートで発生した障害の処理方法について言及しています。

00:01:02.000 --> 00:01:07.000
合格したテストが失敗し始めると、それは貴重な新しい情報です。

00:01:07.000 --> 00:01:21.000
これは、製品の欠陥、テスト自体の問題、または依存関係の1つ、つまり製品の上にあるすべてのフレームワークとサブシステムの問題のいずれかを示します。

00:01:21.000 --> 00:01:34.000
問題の種類に関係なく、その障害が登録されると、同じ障害のその後の報告は、すでに持っている情報を表すため、価値が大幅に低下します。

00:01:34.000 --> 00:01:38.000
理想的には、新しい障害はトリアージされ、迅速に修正されます。

00:01:38.000 --> 00:01:50.000
しかし、あなたのチームはすぐに問題を解決できないかもしれません。つまり、失敗はすぐに貴重な新しい情報から騒々しい気晴らしになります。

00:01:50.000 --> 00:01:58.000
すぐに解決できないテストの既知の失敗を考えると、ノイズを管理するためのツールは何ですか?

00:01:58.000 --> 00:02:03.000
思い浮かぶかもしれない2つのアプローチは、無効化とスキップです。

00:02:03.000 --> 00:02:13.000
これらのトレードオフを検討し、最高のツールとこのセッションのトピックであるXCTestのExpectedFailures APIについて話しましょう。

00:02:13.000 --> 00:02:17.000
Xcodeでは、テストプランまたはスキームでテストを無効にすることができます。

00:02:17.000 --> 00:02:23.000
これは既知のテストの失敗に使用できますが、1つの利点は、テストコードが引き続きコンパイルされることです。

00:02:23.000 --> 00:02:27.000
ただし、コードが実行されないため、テストレポートには表示されません。

00:02:27.000 --> 00:02:34.000
この可視性の低下により、解決が必要な問題として追跡することが難しくなります。

00:02:34.000 --> 00:02:44.000
この機能（有効または無効にするテストを選択する機能）が本当に輝いているのは、特定の目的のためにテストのコレクションをキュレーションするためのものです。

00:02:44.000 --> 00:02:49.000
しかし、既知の障害を処理する最善の方法であることはめったにありません。

00:02:49.000 --> 00:02:54.000
XCTSkipは、失敗したテストを管理する別の方法です。

00:02:54.000 --> 00:03:03.000
このアプローチでは、コードはテストで構築され続けるだけでなく、XCTSkipが呼び出されるまで実行されます。

00:03:03.000 --> 00:03:10.000
これは、テストレポートに含まれており、問題の可視性がはるかに向上することを意味します。

00:03:10.000 --> 00:03:21.000
ただし、すべてのテストが実行されるわけではないため、新しい問題や既存の問題の変更という形で潜在的に有用な情報を失うことになります。

00:03:21.000 --> 00:03:31.000
XCTSkipは、特定のOSバージョンやデバイスタイプを要求するなど、テストの構成ベースの制限を管理するための優れたツールです。

00:03:31.000 --> 00:03:37.000
この例では、iPadで実行されていない場合、テストはスキップされます。

00:03:37.000 --> 00:03:46.000
これにより、既知の障害を管理するために特別に設計されたXCTestの一連の機能であるXCTExpectFailureに導きます。

00:03:46.000 --> 00:03:55.000
Swiftでは、さまざまなユースケースに対して多くのオーバーロードがあり、Objective-Cはいくつかの異なる機能で同じ機能を提供します。

00:03:55.000 --> 00:04:05.000
このAPIでは、テストは正常に実行されますが、結果は次のように変更されます。テストの失敗は、予想される失敗として報告されます。

00:04:05.000 --> 00:04:15.000
もちろん、他のテストが失敗しない限り、そのテストを含むテストスイートの失敗は合格として報告されます。

00:04:15.000 --> 00:04:23.000
これにより、障害によって発生するノイズが排除され、テストに他の問題があるかどうかを確認しやすくなります。

00:04:23.000 --> 00:04:27.000
もちろん、ノイズを抑制しても根本的な問題は解決しません。

00:04:27.000 --> 00:04:31.000
だから、あなたがそれを追跡するのを助けるために、APIは失敗の理由を取ります。

00:04:31.000 --> 00:04:40.000
この文字列はコードに問題を文書化し、問題追跡システムのURLを埋め込むこともできます。

00:04:40.000 --> 00:04:47.000
XcodeのテストレポートUIは、通常の失敗やスキップされたテストと同じように、予想される失敗を示します。

00:04:47.000 --> 00:04:56.000
ホバーを合わせると、失敗の理由にURLが含まれている場合、リンクにジャンプできる問題追跡ボタンが表示されます。

00:04:56.000 --> 00:04:59.000
それでは、これがどのように機能するか見てみましょう!

00:04:59.000 --> 00:05:04.000
ここに私のVendorAccountクラスのいくつかの単体テストを含む簡単なプロジェクトがあります。

00:05:04.000 --> 00:05:12.000
私はテストを実行し、それらが終了すると、一方が失敗し、もう一方が合格していることがわかります。

00:05:12.000 --> 00:05:16.000
テストごとに1つずつ、3つのテスト結果アイコンを見ることができます。

00:05:16.000 --> 00:05:29.000
失敗したテストの赤いXと合格テストの緑のチェック、テストスイートの赤いX。スイート内のテストの1つが失敗したため、スイート自体が失敗したと見なします。

00:05:29.000 --> 00:05:37.000
次に、失敗したテストの開始時にXCTExpectFailureへの呼び出しを追加します。

00:05:37.000 --> 00:05:45.000
失敗の理由は、この失敗を追跡するために私が提出したバグを参照するURLで始まることがわかります。

00:05:45.000 --> 00:05:50.000
次に、テストを再実行し、これが結果にどのように影響するかを確認します。

00:05:50.000 --> 00:05:58.000
さて、失敗したテストの赤いXアイコンは、予想される失敗の指標である灰色のXに変わりました。

00:05:58.000 --> 00:06:05.000
さらに興味深いのは、テストスイートのアイコンが赤いXから緑のダッシュに変わったことです。

00:06:05.000 --> 00:06:17.000
このアイコンは、テストスイートが混合状態で合格したことを示します。つまり、1つ以上のテストは合格しませんでしたが、スキップまたは予想される失敗のいずれかでした。

00:06:17.000 --> 00:06:22.000
そのため、XCTExpectFailureを使用して失敗したテストを処理するのは簡単です。

00:06:22.000 --> 00:06:29.000
では、APIを詳しく見てみましょう。

00:06:29.000 --> 00:06:35.000
XCTExpectFailureを使用する際の最初の考慮事項は、どのAPIバリアントを呼び出すかです。

00:06:35.000 --> 00:06:52.000
2つのアプローチがあります。XCTExpectFailureを呼び出すステートフルアプローチと、テストのその後の失敗は期待どおりに扱われます。または、XCTExpectFailureに渡されたクロージャで失敗したコードをラップするスコープ付きアプローチを使用できます。

00:06:52.000 --> 00:06:55.000
いくつかの例を見てみましょう。 ではいくつかの例を見てみましょう。

00:06:55.000 --> 00:06:59.000
これは私のプロジェクトでいくつかの関数を呼び出す非常に簡単なテストです。

00:06:59.000 --> 00:07:04.000
関数がtrueを返さなくなったため、テストは失敗し始めます。

00:07:04.000 --> 00:07:11.000
デモで行ったように、ステートフルな予想される障害アプローチを使用する方法は次のとおりです。

00:07:11.000 --> 00:07:19.000
あるいは、XCTExpectFailureへの呼び出しに続くクロージャで失敗したコードをラップすることで、スコープ付きアプローチを使用できます。

00:07:19.000 --> 00:07:25.000
これは、クロージャ外のコードの障害が正常に報告されることを意味します。

00:07:25.000 --> 00:07:28.000
APIはネスティングもサポートしています。

00:07:28.000 --> 00:07:36.000
言い換えれば、別の呼び出しからのクロージャの内側を含め、テストでAPIを複数回呼び出すことができます。

00:07:36.000 --> 00:07:41.000
これは、テストライブラリコードでAPIを使用する際の重要な考慮事項です。

00:07:41.000 --> 00:07:53.000
たとえば、一般的なユーティリティ関数が失敗し始めると、多くのテストが影響を受ける可能性があり、そのうちのいくつかはすでにさまざまな問題に対してXCTExpectFailureを使用している可能性があります。

00:07:53.000 --> 00:08:11.000
XCTExpectFailureへのネストされた呼び出しのコンテキストで障害が発生した場合、問題は最初に最も近いコールサイトと照合され、マッチャーによって拒否された場合、XCTExpectFailureへの呼び出しのスタックセマンティクスで次の呼び出しなどに引き継がれます。

00:08:11.000 --> 00:08:19.000
このため、共有コードでは、クロージャベースのAPIを使用してテスト状態への影響を制限するのが最善です。

00:08:19.000 --> 00:08:24.000
次に考慮すべきことは、問題をどのように正確に一致させるかです。

00:08:24.000 --> 00:08:32.000
デフォルトでは、影響を受けるスコープの障害は捕捉されますが、イシュートマッチングフィルタを指定することで、より選択的にすることができます。

00:08:32.000 --> 00:08:41.000
この例では、XCTExpectedFailure.Options型のオブジェクトを構築し、そのissueMatcherを定義します。

00:08:41.000 --> 00:08:50.000
マッチャーには、失敗の詳細が記載されたXCTCIssueオブジェクトに渡されるため、一致するかどうかを判断する際に、その情報に完全にアクセスできます。

00:08:50.000 --> 00:08:55.000
マッチャーが失敗を拒否した場合、予想される失敗として処理されません。

00:08:55.000 --> 00:09:01.000
これは、テスト対象のコードに新しい問題が表示されたときの検出に役立ちます。

00:09:01.000 --> 00:09:07.000
オプションオブジェクトには、特定の構成で予想される障害を無効にするために使用できるプロパティもあります。

00:09:07.000 --> 00:09:15.000
例えば、私のテストはmacOSで合格しているかもしれませんが、iOSでは失敗しているので、iOSでの失敗を期待したいだけです。

00:09:15.000 --> 00:09:23.000
それを達成するために、私はオプションを介して予想される失敗を無効にしますが、それを必要としないプラットフォームに限ります。

00:09:23.000 --> 00:09:27.000
では、予想される失敗が失敗しなくなったらどうなりますか?

00:09:27.000 --> 00:09:31.000
通常、これは根本的な問題が解決されたことを意味し、それは素晴らしいことです。

00:09:31.000 --> 00:09:34.000
しかし、XCTExpectFailureはどのように動作しますか?

00:09:34.000 --> 00:09:41.000
まだAPIを呼び出していて、障害が発生していない場合は、新しい明確な障害が生成されます。

00:09:41.000 --> 00:09:50.000
私たちはこれを「比類のない予想される失敗」と呼び、XCTExpectFailureのデフォルトである厳密な動作の一部です。

00:09:50.000 --> 00:09:57.000
この動作は、APIへの不要な呼び出しを削除するように促すことで、コードを維持するのに役立ちます。

00:09:57.000 --> 00:10:02.000
しかし、時々しか失敗しないテストはどうですか?

00:10:02.000 --> 00:10:06.000
テストが失敗することもありますが、他の時には失敗しない場合があります。

00:10:06.000 --> 00:10:19.000
これらは2つのカテゴリに分類され、最初のカテゴリは決定論的であり、特定のプラットフォームでのみ失敗するテストの以前の例など、環境またはその他の知可能な条件が含まれます。

00:10:19.000 --> 00:10:23.000
一方、いくつかの失敗は本質的に非決定論的です。

00:10:23.000 --> 00:10:29.000
これらは、タイミングの問題、信頼性の低い順序の依存関係、または並行性のバグによって引き起こされる可能性があります。

00:10:29.000 --> 00:10:36.000
非決定的な失敗の場合、厳密な動作は役に立ちません。ノイズを発生させるだけです。

00:10:36.000 --> 00:10:40.000
繰り返しになりますが、オプションオブジェクトはこれを制御する方法を提供します。

00:10:40.000 --> 00:10:45.000
デフォルトでtrueであるisStrictフラグはオフにすることができます。

00:10:45.000 --> 00:10:51.000
その後、XCTExpectFailureが失敗をキャッチしない場合でも、テストに合格することができます。

00:10:51.000 --> 00:10:58.000
Swiftでは、XCTExpectFailureへの直接パラメータとして厳密な動作を指定することもできます。

00:10:58.000 --> 00:11:04.000
厳格な動作を無効にすることは、プロジェクトでフレークまたは非決定的なテストを処理するのに最適な方法です。

00:11:04.000 --> 00:11:15.000
余談ですが、非決定的な失敗を調査する必要がある場合、Xcodeはテストを複数回簡単に実行し、失敗したり、他の条件が満たされたときに停止します。

00:11:15.000 --> 00:11:19.000
これは、フレーク状のテストの失敗を追跡するのに本当に役立ちます。

00:11:19.000 --> 00:11:25.000
これの詳細については、「テストの繰り返しで信頼性の低いコードを診断する」セッションをご覧ください。

00:11:25.000 --> 00:11:33.000
それがXCTExpectFailureです -- テストスイートの結果のシグナルツーノイズを改善するためのXCTestのAPIです。

00:11:33.000 --> 00:11:38.000
これにより、新しい問題をより効率的に特定し、より高品質のコードにつながります。

00:11:38.000 --> 00:11:40.000
見てくれてありがとう!

00:11:40.000 --> 23:59:59.000
♪

