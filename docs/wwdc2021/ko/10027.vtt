WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:11.000
안녕. 제 이름은 엘리 엡스캠프 헌트입니다.

00:00:11.000 --> 00:00:13.000
나는 사파리 엔지니어로 일해.

00:00:13.000 --> 00:00:18.000
오늘, 저는 사파리에서 사용할 수 있는 새로운 웹 확장 API에 대한 개요를 제공하고 있습니다.

00:00:18.000 --> 00:00:22.000
작년에, 사파리는 macOS에서 웹 확장 API에 대한 지원을 추가했다.

00:00:22.000 --> 00:00:29.000
이 새로운 API 지원을 사용하는 지난 한 해 동안 출시된 모든 새로운 사파리 확장 프로그램을 보는 것은 놀라웠다.

00:00:29.000 --> 00:00:35.000
그리고 이번 출시와 함께, 우리는 iOS와 iPadOS에 웹 확장 프로그램을 제공하게 되어 정말 기쁩니다.

00:00:35.000 --> 00:00:42.000
전용 세션인 "iOS에서 Safari 웹 확장을 만나보세요"에서 이러한 새로운 플랫폼의 확장에 대해 자세히 알아볼 수 있습니다.

00:00:42.000 --> 00:00:47.000
그리고 일반적으로 사파리 웹 확장에 대해 더 알고 싶다면, 작년 세션을 확인할 수 있습니다.

00:00:47.000 --> 00:00:49.000
오늘, 우리는 세 가지 새로운 확장 API를 다루고 있습니다.

00:00:49.000 --> 00:00:56.000
먼저, 우리는 더 나은 성능을 위해 확장을 구성하는 방법인 비영구적인 배경 페이지에 대해 이야기할 것입니다.

00:00:56.000 --> 00:01:00.000
그런 다음, 선언적 넷 요청이라고 불리는 웹 확장을 위한 콘텐츠 차단 API를 소개하겠습니다.

00:01:00.000 --> 00:01:04.000
그리고 마지막에, 우리는 확장 프로그램이 사파리에서 새 탭을 어떻게 사용자 정의할 수 있는지 살펴볼 것입니다.

00:01:04.000 --> 00:01:09.000
이 새로운 API에 대해 더 배우기 전에, 지속적인 배경 페이지에 대해 이야기해 봅시다.

00:01:09.000 --> 00:01:13.000
웹 확장은 자바스크립트, HTML 및 CSS를 사용하여 만들어집니다.

00:01:13.000 --> 00:01:18.000
일부 확장에는 배경 페이지라고 불리는 브라우저의 배경에서 실행되는 스크립트가 있습니다.

00:01:18.000 --> 00:01:24.000
눈에 보이는 UI는 없지만, 탭 열기나 확장 프로그램의 다른 부분의 메시지와 같은 이벤트에 반응할 수 있습니다.

00:01:24.000 --> 00:01:27.000
지속적인 배경 페이지는 절대 닫히지 않는다.

00:01:27.000 --> 00:01:33.000
그래서, 브라우저에서 두 개의 확장 프로그램이 켜져 있다면, 두 개의 배경 페이지가 지속적으로 실행될 것이다.

00:01:33.000 --> 00:01:39.000
그리고 만약 내가 8개의 확장을 사용한다면, 그것은 항상 백그라운드에서 실행되는 8개의 확장 프로세스이다.

00:01:39.000 --> 00:01:41.000
우리는 여기에 문제가 있다는 것을 알 수 있다.

00:01:41.000 --> 00:01:48.000
영구적인 배경 페이지는 사용자가 절대 닫을 수 없는 보이지 않는 탭과 같으며, 메모리를 소모하고 CPU 사용량을 증가시킨다.

00:01:48.000 --> 00:01:53.000
사용자는 확장 프로그램을 사용하는 것과 브라우저에서 뛰어난 성능을 얻는 것 사이에서 타협할 필요가 없습니다.

00:01:53.000 --> 00:01:57.000
그래서 대신, 확장은 비영구적인 배경 페이지를 채택할 수 있다.

00:01:57.000 --> 00:02:05.000
이러한 유형의 페이지는 필요에 따라 오고 갈 수 있으며, 확장 프로그램을 더 성능 있게 만들고 사용자에게 전반적으로 더 나은 브라우징 경험을 제공합니다.

00:02:05.000 --> 00:02:13.000
iOS용으로 개발하는 경우, iOS 장치의 리소스 제약으로 인해 확장 프로그램에는 비영구적인 배경 페이지가 있어야 합니다.

00:02:13.000 --> 00:02:19.000
이제 우리는 비영구적인 배경 페이지를 사용하는 이유를 이해했으니, 그들이 어떻게 작동하는지 살펴봅시다.

00:02:19.000 --> 00:02:22.000
비영구적인 배경 페이지의 수명은 이벤트를 중심으로 구성되어 있다.

00:02:22.000 --> 00:02:30.000
배경 페이지는 탭 닫기 또는 확장 프로그램의 다른 부분의 메시지와 같은 브라우저에서 발생하는 일에 반응하기 위해 이벤트 리스너를 등록합니다.

00:02:30.000 --> 00:02:35.000
그리고 이러한 이벤트는 브라우저가 백그라운드 페이지를 로드하거나 언로드해야 하는지 결정하는 데 도움이 됩니다.

00:02:35.000 --> 00:02:37.000
예를 들어 봅시다.

00:02:37.000 --> 00:02:43.000
확장 프로그램이 켜지거나 업데이트되면, 배경 페이지가 로드되고 이벤트 리스너가 등록됩니다.

00:02:43.000 --> 00:02:49.000
이 예를 들어, 이 배경 페이지에 콘텐츠 스크립트의 메시지에 대해 정확히 하나의 리스너가 있다고 가정해 봅시다.

00:02:49.000 --> 00:02:57.000
시간이 흐르고 콘텐츠 스크립트가 메시지를 보내지 않으면, 백그라운드 페이지는 비활성으로 인해 브라우저에 의해 언로드됩니다.

00:02:57.000 --> 00:03:06.000
하지만 우리의 콘텐츠 스크립트가 메시지를 보내면, 배경 페이지가 깨어나서 그 메시지를 받고 반응할 수 있습니다.

00:03:06.000 --> 00:03:11.000
그리고 이벤트가 발생한 후, 배경 페이지는 로드된 상태로 유지됩니다.

00:03:11.000 --> 00:03:16.000
하지만 시간이 다시 흐르고 더 이상 이벤트가 발생하지 않으면, 배경 페이지가 언로드될 것이다.

00:03:16.000 --> 00:03:22.000
그래서 그 정신 모델을 염두에 두고, 우리는 실제로 비영구적인 배경 페이지를 구현하는 방법에 대해 이야기할 수 있다.

00:03:22.000 --> 00:03:27.000
먼저, 매니페스트의 배경 섹션에 "영구" 키를 추가할 것입니다.

00:03:27.000 --> 00:03:31.000
그리고 나서 배경 스크립트를 몇 가지 더 변경해야 할 수도 있습니다.

00:03:31.000 --> 00:03:37.000
백그라운드 페이지를 언로드할 수 있기 때문에, 필요에 따라 스토리지 API를 사용하여 디스크에 정보를 작성해야 합니다.

00:03:37.000 --> 00:03:41.000
Browser.storage를 사용하여 배경 페이지의 평생 동안 정보를 유지하세요.

00:03:41.000 --> 00:03:45.000
다음으로, 스크립트의 최상위 수준에 이벤트 리스너를 등록해야 합니다.

00:03:45.000 --> 00:03:50.000
다른 이벤트 리스너의 완료 핸들러에 리스너를 등록하지 마세요.

00:03:50.000 --> 00:03:53.000
그리고 타이머 대신 browser.alarms API를 사용하고 싶을 것입니다.

00:03:53.000 --> 00:03:57.000
백그라운드 페이지가 언로드되면 타이머가 호출되지 않습니다.

00:03:57.000 --> 00:04:00.000
이제 당신이 피하고 싶은 코드에 대해 이야기해 봅시다.

00:04:00.000 --> 00:04:03.000
Browser.extension에 대한 호출을 제거하세요. getBackgroundPage.

00:04:03.000 --> 00:04:07.000
이미 언로드되었다면 배경 페이지를 깨우지 않을 것이다.

00:04:07.000 --> 00:04:10.000
그리고 마지막으로, webRequest 리스너를 제거해야 합니다.

00:04:10.000 --> 00:04:19.000
webRequest는 웹 트래픽을 분석할 수 있는 API이며, webRequest 이벤트가 발생하는 빈도는 이 API를 비영구적인 배경 페이지와 호환되지 않게 만듭니다.

00:04:19.000 --> 00:04:22.000
그래서 이 모든 것이 어떻게 함께 작동하는지 보려면, 사파리에서 시도해 봅시다.

00:04:22.000 --> 00:04:27.000
저는 작년 사파리 확장에 대한 샘플 코드의 수정된 버전을 사용하고 있습니다.

00:04:27.000 --> 00:04:34.000
이 확장 프로그램은 웹 페이지의 단어를 이모티콘으로 대체할 수 있으며 얼마나 많은 총 교체가 발생했는지 보고합니다.

00:04:34.000 --> 00:04:37.000
먼저, 이 확장이 변경하지 않고 무엇을 하는지 봅시다.

00:04:37.000 --> 00:04:42.000
매니페스트에서 "영구" 키를 생략했기 때문에, 배경 페이지는 기본적으로 지속됩니다.

00:04:42.000 --> 00:04:45.000
나는 확장이 포함된 앱을 만들고 실행할 것이다.

00:04:45.000 --> 00:04:48.000
그리고 나서 나는 사파리의 선호도에서 그것을 켤 것이다.

00:04:48.000 --> 00:04:50.000
이제 나는 웹 페이지에서 확장 프로그램을 사용할 것이다.

00:04:50.000 --> 00:04:58.000
물고기에 관한 이 위키피디아 기사로 가자, 그리고 나는 확장 프로그램과 상호 작용하기 위해 팝오버를 사용할 것이다.

00:04:58.000 --> 00:05:03.000
"단어 바꾸기" 버튼을 클릭하면, "물고기"라는 단어의 모든 인스턴스가 물고기 이모티콘으로 대체되었습니다.

00:05:03.000 --> 00:05:09.000
팝오버를 다시 클릭하면, 대체된 총 단어 수를 볼 수 있습니다.

00:05:09.000 --> 00:05:13.000
이 확장의 배경 페이지는 교체 횟수를 추적하는 책임을 맡고 있다.

00:05:13.000 --> 00:05:17.000
활동 모니터로 가서 확장 과정을 살펴봅시다.

00:05:17.000 --> 00:05:21.000
여기서 우리는 모든 확장 코드가 실행되는 웹 프로세스를 볼 수 있습니다.

00:05:21.000 --> 00:05:30.000
우리의 확장 프로그램은 영구적인 배경 페이지를 사용하기 때문에, 이 프로세스는 Safari가 실행 중일 때, 몇 시간 후에 이 확장 프로그램 사용을 중단하더라도 항상 실행됩니다.

00:05:30.000 --> 00:05:35.000
그러니 이 확장을 조금 더 좋게 만들고 배경 페이지를 비영구적으로 만들어 봅시다.

00:05:35.000 --> 00:05:39.000
내가 가장 먼저 할 일은 매니페스트의 배경 섹션에 "영구" 키를 추가하는 것이다.

00:05:39.000 --> 00:05:42.000
그리고 여기서 멈춰서 우리의 확장이 여전히 작동하는지 봅시다.

00:05:42.000 --> 00:05:45.000
내 확장 프로그램이 포함된 앱을 만들 거야.

00:05:45.000 --> 00:05:48.000
사파리로 돌아가서 페이지를 다시 로드할게.

00:05:48.000 --> 00:05:50.000
그럼 내가 몇 단어를 바꿀게.

00:05:50.000 --> 00:05:54.000
그 후, 나는 잠시 기다리며, 배경 페이지에 유휴 상태로 갈 시간을 줄 것이다.

00:05:54.000 --> 00:05:59.000
이 데모를 위해, 저는 평소보다 훨씬 빠르게 백그라운드 페이지를 언로드하도록 사파리를 수정했습니다.

00:05:59.000 --> 00:06:06.000
우리는 배경 페이지가 실제로 웹 확장 배경 페이지 아래의 개발 메뉴에서 언로드되었는지 확인할 수 있습니다.

00:06:06.000 --> 00:06:09.000
이곳은 배경 페이지를 검사할 수 있는 곳이기도 합니다.

00:06:09.000 --> 00:06:13.000
언로드될 때 페이지를 검사하기로 선택하면 즉시 로드됩니다.

00:06:13.000 --> 00:06:16.000
이제 배경 페이지가 언로드 되었으니, 팝오버를 다시 열어봅시다.

00:06:16.000 --> 00:06:21.000
우리의 예상 카운트인 564 대신에, 우리는 0개의 단어가 대체되는 것을 본다.

00:06:21.000 --> 00:06:23.000
그래서 우리 확장에 버그가 있어.

00:06:23.000 --> 00:06:29.000
우리는 확장 프로그램이 비영구적인 배경 페이지에서 올바르게 작동하도록 돌아가서 더 많은 변경을 해야 합니다.

00:06:29.000 --> 00:06:32.000
여기 우리는 확장 프로그램의 배경 페이지 코드에 있습니다.

00:06:32.000 --> 00:06:34.000
이 배경 페이지는 두 가지 일을 한다.

00:06:34.000 --> 00:06:38.000
그것은 단어 대체 카운트에 하나를 추가하거나, 현재 카운트를 보고한다.

00:06:38.000 --> 00:06:41.000
글로벌 변수는 우리의 버그를 일으키는 원인이다.

00:06:41.000 --> 00:06:44.000
백그라운드 페이지가 다시 로드되면, 카운트는 0으로 재설정됩니다.

00:06:44.000 --> 00:06:49.000
그래서 564단어가 대체되었다는 상태를 유지하는 대신, 우리는 그것을 잃는다.

00:06:49.000 --> 00:06:55.000
그래서 이 문제를 해결할 수 있도록, browser.storage API를 사용하여 필요에 따라 단어 수를 저장하고 로드합시다.

00:06:55.000 --> 00:07:00.000
먼저, 우리는 저장소에서 그 수를 로드하기 위해 몇 가지 코드를 추가할 것이다.

00:07:00.000 --> 00:07:06.000
내가 원하는 값을 얻기 위해 스토리지 API의 결과를 구문 분석할 것이다.

00:07:06.000 --> 00:07:11.000
그리고 나는 그것이 업데이트될 때마다 그 가치를 저장소에 다시 저장할 것이다.

00:07:11.000 --> 00:07:19.000
그리고 나서 나는 그 onMessage 리스너를 스토리지 콜백의 본문으로 가져올 것이다.

00:07:19.000 --> 00:07:22.000
하지만 기다려. 우리는 문제가 있어.

00:07:22.000 --> 00:07:28.000
우리는 이벤트 청취자가 우리 대본의 최상위 수준에 등록되어야 한다는 것을 알고 있으므로, 이것은 작동하지 않을 것입니다.

00:07:28.000 --> 00:07:37.000
그래서 여기서 상황을 재구성하고 저장 통화를 청취자의 몸으로 가져오자.

00:07:37.000 --> 00:07:45.000
그리고 우리는 스토리지 API를 사용하고 있기 때문에, 매니페스트에 스토리지 권한을 추가해야 합니다.

00:07:45.000 --> 00:07:50.000
이제 앱을 다시 만들고 확장 프로그램을 다시 테스트할 것입니다.

00:07:50.000 --> 00:07:53.000
나는 이전과 똑같은 일을 할 거야.

00:07:53.000 --> 00:07:57.000
나는 물고기에 관한 위키피디아 페이지를 보고 페이지를 다시 로드할 것이다.

00:07:57.000 --> 00:08:05.000
그런 다음 나는 몇 가지 단어를 대체하고 잠시 기다리며, 우리의 배경을 내릴 시간을 줄 것이다.

00:08:05.000 --> 00:08:06.000
좋아.

00:08:06.000 --> 00:08:10.000
우리의 팝오버는 이제 대체된 정확한 단어 수를 보고합니다.

00:08:10.000 --> 00:08:16.000
우리는 영구적인 배경 페이지로 확장 프로그램을 가져갔고 비영구적인 배경 페이지를 사용하도록 성공적으로 변환했습니다.

00:08:16.000 --> 00:08:26.000
그리고 활동 모니터로 돌아가면, 비영구적인 배경 페이지를 채택하기 위해 이 작업을 했기 때문에 배경 페이지가 언로드된 후 확장 프로세스가 더 이상 존재하지 않습니다.

00:08:26.000 --> 00:08:30.000
그것은 사파리의 비영구적인 배경 페이지 지원에 대한 개요였다.

00:08:30.000 --> 00:08:37.000
iOS용 확장 프로그램을 개발하는 경우, 비영구적인 배경 페이지를 채택해야 한다는 것을 기억하십시오.

00:08:37.000 --> 00:08:41.000
다음으로, 새로운 콘텐츠 차단 API인 선언적 순 요청을 살펴봅시다.

00:08:41.000 --> 00:08:47.000
사파리는 2015년부터 웹킷 콘텐츠 규칙 목록을 사용하여 구축된 콘텐츠 차단기 확장을 지원해 왔다.

00:08:47.000 --> 00:08:53.000
올해 몇 가지 개선 사항이 있으며, Apple의 업데이트된 문서에서 확인할 수 있습니다.

00:08:53.000 --> 00:09:00.000
그러나, 웹 확장은 지금까지 그런 종류의 빠르고, 개인 정보 보호, 콘텐츠 차단 기능을 가지고 있지 않았다.

00:09:00.000 --> 00:09:06.000
최근 크롬에 의해 도입된 선언적 순 요청 API는 그 모든 상자를 확인한다.

00:09:06.000 --> 00:09:10.000
기본을 검토해 봅시다.

00:09:10.000 --> 00:09:14.000
콘텐츠 차단 규칙은 JSON 형식으로 작성됩니다.

00:09:14.000 --> 00:09:22.000
이러한 JSON 규칙은 규칙 집합이라는 파일로 논리적으로 그룹화되며, 이러한 규칙 집합을 개별적으로 켜거나 끌 수 있는 자바스크립트 API가 있습니다.

00:09:22.000 --> 00:09:29.000
그리고 크롬도 이 API를 지원하기 때문에, 여러 플랫폼에서 여러 브라우저에서 실행할 수 있는 하나의 콘텐츠 차단기를 작성할 수 있습니다.

00:09:29.000 --> 00:09:34.000
선언적 순 요청을 사용하여 콘텐츠 차단 규칙을 작성하는 방법을 살펴봅시다.

00:09:34.000 --> 00:09:38.000
첫 번째 단계는 확장의 매니페스트에 규칙 집합을 지정하는 것이다.

00:09:38.000 --> 00:09:41.000
여기, 나는 하나의 규칙을 선언했다.

00:09:41.000 --> 00:09:44.000
또한 선언적 순 요청 권한을 추가해야 합니다.

00:09:44.000 --> 00:09:49.000
다음은 우리가 규칙 집합에서 지정한 파일 안에 들어갈 선언적 순 요청 규칙의 예입니다.

00:09:49.000 --> 00:09:52.000
그건 네 조각이 있어.

00:09:52.000 --> 00:09:59.000
규칙이 적용되는 순서를 결정하는 우선 순위와 함께 고유한 ID가 있습니다.

00:09:59.000 --> 00:10:04.000
규칙의 액션 부분을 사용하면 자원의 계획을 차단, 허용 또는 업그레이드할 수 있습니다.

00:10:04.000 --> 00:10:09.000
그리고 조건은 사파리에게 어디서 어떤 조건에서 이 규칙을 실행해야 하는지 알려주는 곳입니다.

00:10:09.000 --> 00:10:12.000
이 규칙의 조건 사전에는 두 개의 키가 있다.

00:10:12.000 --> 00:10:20.000
"regexFilter"는 리소스 URL과 일치하며, "resourceTypes" 배열은 차단될 리소스 유형을 지정합니다.

00:10:20.000 --> 00:10:25.000
이 조건 사전에서 지원되는 것에 대해 더 자세히 살펴봅시다.

00:10:25.000 --> 00:10:32.000
다음은 선언적 순 요청 규칙을 사용하여 타겟팅할 수 있는 모든 리소스 유형입니다.

00:10:32.000 --> 00:10:38.000
"excludedResourceTypes" 키를 사용하면 일치시키고 싶지 않은 유형을 지정할 수 있습니다.

00:10:38.000 --> 00:10:46.000
"domainType 키"를 사용하면 로드되는 리소스의 도메인과 문서의 도메인 관계에 따라 리소스를 차단할 수 있습니다.

00:10:46.000 --> 00:10:51.000
"퍼스트 파티" 로드는 URL이 문서와 동일한 보안 출처를 갖는 모든 로드입니다.

00:10:51.000 --> 00:10:54.000
다른 모든 사례는 "제3자"이다.

00:10:54.000 --> 00:11:00.000
그리고 마지막으로, "대소문자에 민감한" 키를 사용하면 regexFilter가 대소문자를 구분하는지 여부를 제어할 수 있습니다.

00:11:00.000 --> 00:11:03.000
기본적으로, 그건 사실이야.

00:11:03.000 --> 00:11:08.000
이제 선언적 net request API를 사용하여 콘텐츠를 차단하는 웹 확장 프로그램을 구축해 봅시다.

00:11:08.000 --> 00:11:13.000
내가 가장 먼저 할 일은 매니페스트에 선언적 순 요청 섹션을 추가하는 것이다.

00:11:13.000 --> 00:11:22.000
그 선언적 순 요청 섹션 안에, 나는 ID, 그것이 켜져 있음을 나타내는 bool, 그리고 내 규칙이 포함된 JSON 파일의 경로를 작성하여 규칙 집합을 추가할 것이다.

00:11:22.000 --> 00:11:26.000
그리고 우리가 매니페스트에 있는 동안, 나는 또한 선언적 순 요청 권한을 추가할 것이다.

00:11:26.000 --> 00:11:31.000
여기서부터, 규칙 집합 JSON 파일로 들어가 봅시다.

00:11:31.000 --> 00:11:37.000
나는 모든 웹 페이지에서 이미지를 차단하는 규칙을 작성할 것이다.

00:11:37.000 --> 00:11:43.000
확장 프로그램이 포함된 앱을 만들고 사파리를 열 것이다.

00:11:43.000 --> 00:11:51.000
이 확장 프로그램은 모든 웹 페이지에서 콘텐츠를 차단할 수 있음에도 불구하고 브라우징 기록이나 웹 페이지 콘텐츠를 볼 수 없다는 점에 유의하십시오.

00:11:51.000 --> 00:11:56.000
확장 프로그램을 켜기 전에, 몇 가지 이미지가 있는 WebKit 블로그 게시물을 열 것입니다.

00:11:56.000 --> 00:12:00.000
우리는 이 웹 페이지에 두 개의 이미지가 있다는 것을 알 수 있다.

00:12:00.000 --> 00:12:10.000
기본 설정으로 돌아가서 확장 프로그램을 켠 다음 페이지를 다시 로드하면 이미지가 차단됩니다.

00:12:10.000 --> 00:12:14.000
이제 물고기에 관한 이 위키피디아 페이지와 같은 다른 웹 페이지로 가자.

00:12:14.000 --> 00:12:19.000
이미지도 여기에서 차단되었지만, 이 특정 페이지에서 이미지를 볼 수 있다면 실제로 선호합니다.

00:12:19.000 --> 00:12:24.000
그러니 여기를 제외한 모든 곳에서 이미지가 차단되도록 확장을 수정합시다.

00:12:24.000 --> 00:12:29.000
나는 Xcode로 돌아가서 이 페이지에 이미지를 허용하는 규칙을 작성할 것이다.

00:12:29.000 --> 00:12:34.000
이 규칙의 행동 유형은 "허용"이 될 것이며, 우리의 첫 번째 차단 규칙보다 우선 순위가 높은 규칙이 될 것이다.

00:12:34.000 --> 00:12:38.000
나는 내 앱을 다시 만든 다음, 사파리로 돌아갈 것이다.

00:12:38.000 --> 00:12:42.000
내가 페이지를 다시 불러올게.

00:12:42.000 --> 00:12:49.000
하지만 이 새로운 규칙은 작동하지 않았다. 왜냐하면 나는 여전히 어떤 이미지도 보이지 않기 때문이다.

00:12:49.000 --> 00:12:53.000
확장 환경 설정에서 오류 메시지를 찾아볼게.

00:12:53.000 --> 00:13:02.000
좋아요, 문자열 "이미지"가 있는 배열 대신 리소스 유형 키에 빈 배열을 사용한 것 같습니다.

00:13:02.000 --> 00:13:05.000
나는 내 실수를 고치기 위해 Xcode로 돌아올 것이다.

00:13:05.000 --> 00:13:17.000
나는 오류 메시지가 사라졌는지 확인하기 위해 다시 만들고 사파리의 환경 설정으로 돌아갈 것이다.

00:13:17.000 --> 00:13:20.000
그럼, 내가 그 페이지를 다시 불러올게.

00:13:20.000 --> 00:13:24.000
그리고 좋아요, 이미지는 더 이상 이 위키피디아 페이지에서 차단되지 않습니다.

00:13:24.000 --> 00:13:29.000
그래서 그것은 웹에서 콘텐츠를 차단할 수 있는 웹 확장 프로그램을 구축하는 방법에 대한 개요였다.

00:13:29.000 --> 00:13:34.000
선언적 순 요청을 사용하는 방법에 대한 자세한 내용은 Apple의 문서를 참조할 수 있습니다.

00:13:34.000 --> 00:13:38.000
마지막으로, 확장 프로그램이 사파리에서 새 탭을 어떻게 사용자 정의할 수 있는지 살펴봅시다.

00:13:38.000 --> 00:13:42.000
우리는 사용자가 브라우저를 개인화하는 것을 좋아한다는 것을 알고 있으며, 확장은 그렇게 하는 좋은 방법입니다.

00:13:42.000 --> 00:13:49.000
새 탭 재정의 API를 사용하면 확장 프로그램이 Safari의 새 탭 페이지를 인수하고 완전히 사용자 정의할 수 있습니다.

00:13:49.000 --> 00:13:53.000
이 API는 이미 사파리 14.1에서 공개적으로 사용할 수 있습니다.

00:13:53.000 --> 00:13:57.000
새 탭 재정의는 매니페스트에서 선언됩니다.

00:13:57.000 --> 00:14:06.000
그리고 사용자가 새 탭 재정의로 확장 프로그램을 켜면, 그들은 그 확장 프로그램이 사파리에서 새 탭을 차지할지 여부를 선택합니다.

00:14:06.000 --> 00:14:10.000
매니페스트에서 새 탭 재정의 페이지를 지적하는 방법은 다음과 같습니다.

00:14:10.000 --> 00:14:14.000
이 새로운 API를 함께 사용하는 확장 프로그램을 만들어 봅시다.

00:14:14.000 --> 00:14:17.000
나는 Sea Creator 확장 프로그램에 새로운 탭 재정의를 추가할 것이다.

00:14:17.000 --> 00:14:22.000
우리의 목표는 사파리에서 새 탭을 열 때마다 재미있는 웹 페이지가 나타나는 것입니다.

00:14:22.000 --> 00:14:29.000
내 HTML 페이지가 매니페스트의 새로운 탭 재정의라고 선언하는 것으로 시작하겠습니다.

00:14:29.000 --> 00:14:33.000
사용하고 싶은 기존 HTML과 CSS 파일이 몇 개 있습니다.

00:14:33.000 --> 00:14:36.000
그것들은 내 확장 프로그램의 리소스 폴더에 있다.

00:14:36.000 --> 00:14:39.000
나는 그것들을 Xcode 프로젝트에 추가하기만 하면 된다.

00:14:39.000 --> 00:14:42.000
Xcode 프로젝트에 파일을 추가한 적이 없다면, 걱정하지 마세요.

00:14:42.000 --> 00:14:44.000
그건 꽤 쉬워.

00:14:44.000 --> 00:14:58.000
File, Add Files to Sea Creator를 클릭한 다음, 추가하고 싶은 파일을 선택하여 앱 대상이 아닌 확장 대상의 일부인지 확인합니다.

00:14:58.000 --> 00:15:02.000
이 HTML은 재미있는 사실로 다채로운 페이지를 만든다.

00:15:02.000 --> 00:15:09.000
그래서 앱을 실행하고, 사파리에서 확장 프로그램을 켤게요.

00:15:09.000 --> 00:15:14.000
나는 이 프롬프트를 받고, 이 확장 프로그램이 내 새 탭과 창을 인수할 수 있기를 원하는지 묻는다.

00:15:14.000 --> 00:15:19.000
그렇게 하도록 허락할게.

00:15:19.000 --> 00:15:25.000
나중에 이것을 변경하고 싶다면, 일반 설정으로 들어갈 수 있습니다.

00:15:25.000 --> 00:15:29.000
하지만 이제, 사파리에서 새 탭을 만들 때, 새 탭 페이지가 나타납니다.

00:15:29.000 --> 00:15:31.000
꽤 좋아 보여!

00:15:31.000 --> 00:15:34.000
하지만 나는 몇 가지 조정을 하고 싶어.

00:15:34.000 --> 00:15:40.000
내 새 탭 재정의 페이지는 제목이 좋지 않다.

00:15:40.000 --> 00:15:48.000
그래서 Xcode로 돌아가서, 내 페이지가 사파리의 탭 바에서 잘 보이도록 제목을 추가할 것이다.

00:15:48.000 --> 00:15:54.000
페이지에서 추론된 사파리와 다른 것을 원한다면 다른 테마 색상을 선택할 수도 있습니다.

00:15:54.000 --> 00:15:57.000
내가 사용하고 있는 이 메타 태그는 새 탭 오버라이드에만 국한되지 않는다.

00:15:57.000 --> 00:15:59.000
그것은 모든 웹 페이지에서 작동할 것이다.

00:15:59.000 --> 00:16:09.000
Safari의 UI 변경 사항에 대해 더 알고 싶다면, "Design for Safari 15"라는 세션을 확인하세요.

00:16:09.000 --> 00:16:11.000
이제 그게 어떻게 생겼는지 보자.

00:16:11.000 --> 00:16:14.000
내가 다시 지을게.

00:16:14.000 --> 00:16:17.000
그리고 사파리로 돌아가서, 나는 새 탭을 만들 것이다.

00:16:17.000 --> 00:16:19.000
좋아.

00:16:19.000 --> 00:16:24.000
Sea Creator 확장 프로그램에 새 탭 재정의를 성공적으로 추가했습니다.

00:16:24.000 --> 00:16:29.000
그리고 그것은 확장 프로그램이 사파리에서 새 탭을 어떻게 사용자 정의할 수 있는지 살펴보는 것이었다.

00:16:29.000 --> 00:16:34.000
오늘, 우리는 macOS와 iOS의 Safari에서 사용할 수 있는 세 가지 새로운 웹 확장 API에 대해 논의했습니다.

00:16:34.000 --> 00:16:39.000
이 세션과 관련된 샘플 프로젝트를 다운로드하고 새로운 API를 가지고 노는 것이 좋습니다.

00:16:39.000 --> 00:16:45.000
이 확장 프로그램이 macOS에서 어떻게 작동하는지 보여줬지만, iOS에서도 작동합니다.

00:16:45.000 --> 00:16:47.000
우리는 또한 당신이 어떻게 생각하는지 알고 싶습니다.

00:16:47.000 --> 00:16:53.000
피드백 어시스턴트를 사용하여 버그를 제출하거나, 사파리 개발자 포럼에서 우리와 채팅할 수 있습니다.

00:16:53.000 --> 00:16:57.000
그리고 마지막으로, 아직 언급하지 않았다면 제가 오늘 언급한 다른 세션들을 확인해 보세요.

00:16:57.000 --> 00:16:59.000
고마워 그리고 멋진 WWDC를 보내.

00:16:59.000 --> 23:59:59.000
[에테르 타악기 음악].

