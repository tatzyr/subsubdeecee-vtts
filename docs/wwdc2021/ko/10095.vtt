WEBVTT

00:00:00.000 --> 00:00:05.000
♪ 베이스 음악 연주 ♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:11.000
Guoye Zhang: 안녕하세요, 저는 Guoye입니다.

00:00:11.000 --> 00:00:16.000
내 동료 Zhenchao와 나는 HTTP 프레임워크에서 일한다.

00:00:16.000 --> 00:00:20.000
나는 네가 지금까지 스위프트 동시성에 대해 많이 들었을 거라고 확신해.

00:00:20.000 --> 00:00:24.000
아직 하지 않았다면, "Swift에서 async/await"를 확인하세요.

00:00:24.000 --> 00:00:28.000
나는 async/await가 URLSession에서 어떻게 작동하는지에 대해 뛰어들 것이다.

00:00:28.000 --> 00:00:38.000
내가 스위프트 동시성에 대해 가장 좋아하는 것은 코드를 선형적이고 간결하게 만들고 네이티브 스위프트 오류 처리를 지원한다는 것이다.

00:00:38.000 --> 00:00:52.000
네트워킹은 본질적으로 비동기적이며, iOS 15와 macOS Monterey에서는 Swift 동시성 기능을 활용할 수 있도록 URLSession에 새로운 API 세트를 도입했습니다.

00:00:52.000 --> 00:00:58.000
당신에게 우리의 새로운 API를 보여주기 위해, 여기 우리가 async/await를 채택하기 위해 노력하고 있는 앱이 있습니다.

00:00:58.000 --> 00:01:05.000
그것은 개 애호가들만을 위한 사진 공유 앱이며, 우리는 이 사진들을 좋아할 수 있다.

00:01:05.000 --> 00:01:09.000
여기 개 사진을 가져오는 기존 코드가 있습니다.

00:01:09.000 --> 00:01:14.000
그것은 URLSession에서 completionHandler 기반 편의 방법을 사용하고 있다.

00:01:14.000 --> 00:01:17.000
그 코드는 간단해 보이며, 내 제한된 테스트에서 작동했다.

00:01:17.000 --> 00:01:20.000
하지만, 적어도 세 가지 실수가 있다.

00:01:20.000 --> 00:01:23.000
뛰어들자.

00:01:23.000 --> 00:01:26.000
먼저, 제어 흐름을 따라가자.

00:01:26.000 --> 00:01:28.000
우리는 데이터 작업을 만들고 그것을 재개한다.

00:01:28.000 --> 00:01:38.000
그런 다음 작업이 완료되면, 우리는 완료 핸들러로 뛰어들고, 응답을 확인하고, 이미지를 만들고, 제어 흐름이 끝나는 곳입니다.

00:01:38.000 --> 00:01:41.000
흠, 우리는 앞뒤로 뛰고 있어.

00:01:41.000 --> 00:01:43.000
스레딩은 어때?

00:01:43.000 --> 00:01:47.000
이 작은 코드는 놀라울 정도로 복잡하다.

00:01:47.000 --> 00:01:50.000
우리는 총 세 가지 다른 실행 맥락을 가지고 있다.

00:01:50.000 --> 00:02:02.000
가장 바깥쪽 계층은 호출자의 스레드나 대기열에서 실행되며, URLSessionTask completionHandler는 세션의 대리자 대기열에서 실행되며, 최종 완료 핸들러는 주 대기열에서 실행됩니다.

00:02:02.000 --> 00:02:11.000
컴파일러가 여기서 우리를 도울 수 없기 때문에, 우리는 데이터 경쟁과 같은 스레딩 문제를 피하기 위해 극도의 주의를 기울여야 한다.

00:02:11.000 --> 00:02:13.000
이제, 나는 뭔가 잘못된 것을 알아차렸다.

00:02:13.000 --> 00:02:18.000
completionHandler에 대한 호출은 주 대기열에 일관되게 파견되지 않는다.

00:02:18.000 --> 00:02:20.000
이건 버그일 수도 있어.

00:02:20.000 --> 00:02:23.000
또한, 우리는 여기서 일찍 돌아오는 것을 놓치고 있다.

00:02:23.000 --> 00:02:27.000
오류가 발생하면 completionHandler를 두 번 호출할 수 있습니다.

00:02:27.000 --> 00:02:32.000
이것은 발신자의 가정을 위반할 수 있다.

00:02:32.000 --> 00:02:37.000
마지막으로, 이것은 그다지 분명하지 않을 수도 있지만, UIImage 생성은 실패할 수 있다.

00:02:37.000 --> 00:02:48.000
데이터가 잘못된 형식이라면, 이 UIImage 이니셜라이저는 nil을 반환하므로, 우리는 nil 이미지와 nil 오류로 completionHandler를 호출했을 것입니다.

00:02:48.000 --> 00:02:51.000
이것은 예상되지 않을 것 같다.

00:02:51.000 --> 00:02:54.000
이제 이것은 async/await를 사용하는 새 버전입니다.

00:02:54.000 --> 00:02:56.000
와, 훨씬 더 간단해!

00:02:56.000 --> 00:03:08.000
제어 흐름은 위에서 아래로 선형이며, 우리는 이 함수의 모든 것이 동일한 동시성 컨텍스트에서 실행된다는 것을 알고 있으므로 더 이상 스레딩 문제에 대해 걱정할 필요가 없습니다.

00:03:08.000 --> 00:03:13.000
여기서, 우리는 URLSession에서 새로운 비동기 데이터 방법을 사용했습니다.

00:03:13.000 --> 00:03:23.000
차단하지 않고 현재 실행 컨텍스트를 일시 중지하고, 성공적으로 완료되면 데이터와 응답을 반환하거나 오류를 발생시킵니다.

00:03:23.000 --> 00:03:29.000
우리는 또한 응답이 예기치 않을 때 오류를 발생시키기 위해 throw 키워드를 사용했다.

00:03:29.000 --> 00:03:35.000
이를 통해 발신자는 스위프트 기본 오류 처리를 사용하여 오류를 포착하고 처리할 수 있습니다.

00:03:35.000 --> 00:03:46.000
마지막으로, 이 함수에서 선택적 UIImage를 반환하려고 하면 컴파일러가 짖을 것이므로, 본질적으로 nil을 올바르게 처리하도록 강요합니다.

00:03:46.000 --> 00:03:51.000
다음은 네트워크에서 데이터를 가져오는 데 사용한 방법의 서명입니다.

00:03:51.000 --> 00:03:58.000
URLSession.data 메소드는 URL 또는 URLRequest를 허용합니다.

00:03:58.000 --> 00:04:03.000
그것들은 기존의 데이터 작업 편의 방법과 동등하다.

00:04:03.000 --> 00:04:09.000
우리는 또한 당신이 데이터를 업로드하거나 파일을 업로드할 수 있는 업로드 방법을 제공합니다.

00:04:09.000 --> 00:04:13.000
그것들은 기존의 업로드 작업 편의 방법과 동등하다.

00:04:13.000 --> 00:04:23.000
기본 메서드 GET이 업로드를 지원하지 않기 때문에 요청을 보내기 전에 올바른 HTTP 메서드를 설정해야 합니다.

00:04:23.000 --> 00:04:28.000
다운로드 방법은 응답 본문을 메모리가 아닌 파일로 저장합니다.

00:04:28.000 --> 00:04:38.000
다운로드 작업 편의 방법과는 달리, 이 새로운 방법은 파일을 자동으로 삭제하지 않으므로, 직접 삭제하는 것을 잊지 마세요.

00:04:38.000 --> 00:04:44.000
이 예에서, 우리는 추가 처리를 위해 파일을 다른 위치로 옮기고 있습니다.

00:04:44.000 --> 00:04:49.000
스위프트 동시성의 취소는 URLSession 비동기 메소드와 함께 작동합니다.

00:04:49.000 --> 00:04:53.000
취소하는 한 가지 방법은 Concurrency Task.Handle을 사용하는 것이다.

00:04:53.000 --> 00:04:59.000
여기서, 우리는 두 개의 리소스를 하나씩 로드하는 동시성 작업을 만들기 위해 비동기를 호출합니다.

00:04:59.000 --> 00:05:04.000
나중에, 우리는 Task.Handle을 사용하여 현재 실행 중인 작업을 취소할 수 있습니다.

00:05:04.000 --> 00:05:11.000
동시성 작업은 "작업"이라는 이름을 공유하더라도 URLSessionTask와 관련이 없다는 점에 유의하십시오.

00:05:11.000 --> 00:05:19.000
우리가 방금 이야기한 방법 - 데이터, 업로드, 다운로드 - 돌아오기 전에 전체 응답 본문이 도착할 때까지 기다린다.

00:05:19.000 --> 00:05:23.000
만약 우리가 응답 본문을 점진적으로 받고 싶다면?

00:05:23.000 --> 00:05:27.000
URLSession.bytes 메소드를 소개하게 되어 기쁩니다.

00:05:27.000 --> 00:05:34.000
그들은 응답 헤더가 수신되면 반환하고 응답 본문을 바이트의 AsyncSequence로 전달합니다.

00:05:34.000 --> 00:05:40.000
그것이 어떻게 작동하는지 보여주기 위해, 제 동료 Zhenchao는 Dogs 앱에서 그것을 어떻게 채택하고 있는지 시연할 것입니다.

00:05:40.000 --> 00:05:44.000
Zhenchao Li: 고마워, Guoye! 안녕하세요, 저는 젠차오입니다.

00:05:44.000 --> 00:05:54.000
나는 얼마나 많은 사람들이 개 사진을 좋아했는지 보여주는 개 앱의 새로운 기능을 연구하고 있다.

00:05:54.000 --> 00:06:00.000
지금 당장, 스크롤 보기를 아래로 당겨서 즐겨찾기 카운트를 새로 고칠 수 있습니다.

00:06:00.000 --> 00:06:04.000
저는 이 가장 좋아하는 카운트를 실시간으로 업데이트하고 싶습니다.

00:06:04.000 --> 00:06:08.000
그렇게 하면, 앱은 훨씬 더 인터랙티브하게 느껴진다.

00:06:08.000 --> 00:06:17.000
그렇게 하기 위해, 우리의 백엔드 엔지니어들은 사진에 대한 실시간 업데이트를 제공하는 실시간 이벤트 엔드포인트를 구축했습니다.

00:06:17.000 --> 00:06:23.000
나는 응답을 검토하기 위해 엔드포인트를 확인할 것이다.

00:06:23.000 --> 00:06:32.000
응답 본문의 각 줄은 업데이트된 즐겨찾기 수와 같은 사진에 대한 업데이트를 설명하는 JSON 데이터입니다.

00:06:32.000 --> 00:06:42.000
새로운 비동기 시퀀스 API를 사용하여 엔드포인트의 응답을 소비하고 실시간 이벤트가 구문 분석됨에 따라 즐겨찾기 카운트를 업데이트합시다.

00:06:42.000 --> 00:06:50.000
사진 컬렉션 보기가 나타날 때 호출되는 작업인 onAppearHandler 기능에서 실시간 업데이트를 시작할 수 있습니다.

00:06:50.000 --> 00:07:06.000
함수 내에서, 나는 새로운 URLSession.bytes API를 호출하여 새로운 엔드포인트에서 데이터를 가져올 것이다.

00:07:06.000 --> 00:07:12.000
여기에 반환된 바이트에는 URLSession.AsyncBytes 유형이 있습니다.

00:07:12.000 --> 00:07:17.000
이것은 우리에게 반응체를 점진적으로 소비할 수 있는 방법을 제공한다.

00:07:17.000 --> 00:07:28.000
나는 또한 우리가 서버로부터 성공적인 응답을 받았는지 확인하기 위해 여기에 오류 확인을 추가했다.

00:07:28.000 --> 00:07:33.000
우리는 응답의 각 줄을 JSON 데이터로 구문 분석하고 싶습니다.

00:07:33.000 --> 00:07:42.000
그렇게 하기 위해, 우리는 AsyncBytes에서 라인 메소드를 사용할 수 있다.

00:07:42.000 --> 00:07:54.000
이것은 우리가 데이터가 수신될 때 응답 라인을 한 줄씩 소비할 수 있게 해준다.

00:07:54.000 --> 00:08:03.000
루프 내에서 JSON 데이터를 구문 분석하고 updateFavoriteCount를 호출하여 UI를 업데이트할 수 있습니다.

00:08:03.000 --> 00:08:18.000
UI 업데이트는 메인 액터에서 발생해야 하며, 이것이 제가 비동기 함수인 updateFavoriteCount를 호출하기 위해 await 구문을 사용하는 이유입니다.

00:08:18.000 --> 00:08:23.000
좋아. 이제 이 가장 좋아하는 카운트는 실시간으로 업데이트됩니다.

00:08:23.000 --> 00:08:27.000
너에게 돌아가, Guoye.

00:08:27.000 --> 00:08:35.000
Guoye: Zhenchao는 방금 AsyncSequence 내장 변환 -- 라인을 사용하여 응답 바디 라인을 한 줄씩 구문 분석하는 방법을 보여주었습니다.

00:08:35.000 --> 00:08:46.000
AsyncSequence는 많은 편의 변환을 지원하며, FileHandle과 같은 다른 시스템 프레임워크 API와 함께 AsyncSequence를 사용할 수도 있습니다.

00:08:46.000 --> 00:08:53.000
AsyncSequence에 대해 자세히 알아보려면, "Meet AsyncSequence" 비디오를 보는 것이 좋습니다.

00:08:53.000 --> 00:09:02.000
URLSession은 인증 문제, 메트릭 등과 같은 이벤트에 대한 콜백을 제공하는 대리자 모델을 중심으로 설계되었습니다.

00:09:02.000 --> 00:09:12.000
새로운 비동기 메서드는 더 이상 기본 작업을 노출하지 않으므로, 작업과 관련된 인증 문제를 어떻게 처리합니까?

00:09:12.000 --> 00:09:27.000
네, 이러한 모든 메서드는 작업별 대리자라는 추가 인수를 사용하여 이 데이터 업로드, 다운로드 또는 바이트 작업과 관련된 대리자 메시지를 처리하는 객체를 제공할 수 있습니다.

00:09:27.000 --> 00:09:36.000
우리는 또한 당신이 동일한 기능을 활용할 수 있도록 Objective-C의 NSURLSessionTask에 위임 속성을 도입하고 있습니다.

00:09:36.000 --> 00:09:42.000
대리인은 완료되거나 실패할 때까지 업무에 의해 강하게 유지된다.

00:09:42.000 --> 00:09:47.000
작업별 대리인은 백그라운드 URLSession에서 지원되지 않는다는 점은 주목할 가치가 있다.

00:09:47.000 --> 00:09:57.000
세션 대리자와 작업 대리자 모두에서 방법이 구현되면, 작업 대리자가 호출됩니다.

00:09:57.000 --> 00:10:03.000
이제, Zhenchao는 인증 문제를 처리하기 위해 작업별 대리인을 사용하는 방법을 보여줄 것이다.

00:10:03.000 --> 00:10:05.000
젠차오: 고마워, 궈예!

00:10:05.000 --> 00:10:11.000
우리의 Dogs 앱에는 새로운 비동기 API로 작성된 간단한 데이터 가져오기 레이어가 있습니다.

00:10:11.000 --> 00:10:23.000
사진을 즐겨찾기로 표시하거나 모든 즐겨찾기 사진을 가져오는 것과 같은 일부 데이터 가져오기 작업의 경우, 사용자는 인증을 받아야 합니다.

00:10:23.000 --> 00:10:29.000
지금 당장, 사진을 즐겨찾기로 탭하면, "승인되지 않은" 오류가 발생합니다.

00:10:29.000 --> 00:10:36.000
작업별 대리인을 사용하여 사용자 인증을 추가하는 방법을 살펴봅시다.

00:10:36.000 --> 00:10:40.000
먼저, URLSessionTaskDelegate를 작성해 봅시다.

00:10:40.000 --> 00:10:44.000
그것을 AuthenticationDelegate라고 부르자.

00:10:44.000 --> 00:11:00.000
AuthenticationDelegate는 URLSessionTaskDelegate 프로토콜을 준수하며, 이니셜라이저에서 signInController의 인스턴스를 허용합니다.

00:11:00.000 --> 00:11:12.000
우리가 구현한 signInController 클래스에는 이미 사용자에게 자격 증명을 요청하는 데 사용할 수 있는 몇 가지 좋은 도우미 기능이 포함되어 있습니다.

00:11:12.000 --> 00:11:20.000
다음으로, URLSession didReceive 챌린지 위임 방법을 구현해 봅시다.

00:11:20.000 --> 00:11:30.000
위임 방법 내에서, 우리는 사용자에게 자격 증명을 요청하여 HTTP 기본 인증 문제에 응답하도록 선택할 수 있습니다.

00:11:30.000 --> 00:11:35.000
물론, 우리는 오류 처리를 잊어서는 안 된다.

00:11:35.000 --> 00:11:41.000
이제 이 AuthenticationDelegate 클래스를 작업별 대리인으로 사용합시다.

00:11:41.000 --> 00:11:53.000
그렇게 하기 위해, 나는 그것의 인스턴스를 인스턴스화하고 URLSession.data 메소드의 대리자 매개 변수로 구문 분석할 수 있다.

00:11:53.000 --> 00:12:03.000
위임 객체는 인스턴스 변수가 아니며, 작업이 완료되거나 실패할 때까지 작업에 의해 강력하게 유지된다는 점에 유의하십시오.

00:12:03.000 --> 00:12:21.000
여기서 새로운 점은 대리자가 URLSession 작업의 인스턴스와 관련된 이벤트를 처리하는 데 사용할 수 있다는 것입니다. 이는 대리자 메서드 내부의 논리가 다른 작업이 아닌 특정 URLSession 작업에만 적용될 때 편리합니다.

00:12:21.000 --> 00:12:29.000
좋아. 이제 우리가 좋아하는 사진을 탭할 때...

00:12:29.000 --> 00:12:40.000
...로그인 양식이 나타납니다.

00:12:40.000 --> 00:12:53.000
우리가 로그인하면, 사진은 즐겨찾기로 표시되며, 우리가 가장 좋아하는 사진 컬렉션에 추가되었습니다.

00:12:53.000 --> 00:12:57.000
너에게 돌아가, Guoye.

00:12:57.000 --> 00:12:59.000
Guoye: 데모 고마워, Zhenchao.

00:12:59.000 --> 00:13:18.000
우리는 당신이 URLSession으로 비동기/대기를 시도하기를 기다릴 수 없으며, 함수 변경, 완료 핸들러를 비동기 함수로 전환, 반복 이벤트 핸들러를 AsyncSequences로 변경하는 것을 포함하여 코드를 개선하기 위해 동일한 비동기 개념을 적용하는 것이 좋습니다.

00:13:18.000 --> 00:13:31.000
URLSession의 발전에 대해 자세히 알아보려면, 앱의 HTTP 트래픽을 검사하는 멋진 새 도구에 대한 비디오와 URLSession의 HTTP/3 지원에 대한 비디오가 있습니다.

00:13:31.000 --> 00:13:34.000
고마워 그리고 멋진 WWDC 보내!

00:13:34.000 --> 23:59:59.000
♪

