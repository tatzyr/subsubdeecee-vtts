WEBVTT

00:00:00.000 --> 00:00:10.000
♪ ♪

00:00:10.000 --> 00:00:11.000
안녕. 내 이름은 저스틴이야.

00:00:11.000 --> 00:00:13.000
저는 사진 엔지니어입니다.

00:00:13.000 --> 00:00:19.000
제 동료인 아담과 함께, 우리는 당신의 앱에서 사진에 대한 접근을 개선하는 방법에 대해 이야기할 것입니다.

00:00:19.000 --> 00:00:24.000
먼저, 나는 우리가 시스템 사진 선택기에 개선한 것에 대해 이야기할 것이다.

00:00:24.000 --> 00:00:33.000
그런 다음, 아담은 새로운 클라우드 식별자 API와 이를 사용하여 다른 장치에서 동일한 자산을 식별하는 방법을 보여줄 것입니다.

00:00:33.000 --> 00:00:40.000
마지막으로, 그는 또한 제한된 도서관 접근 모드의 변화에 대해 논의할 것이다.

00:00:40.000 --> 00:00:42.000
사진 선택기부터 시작합시다.

00:00:42.000 --> 00:00:50.000
iOS 14에서 우리는 UIImagePickerController의 현대적인 대체품인 PHPicker를 도입했습니다.

00:00:50.000 --> 00:01:00.000
PHPicker API는 앱에 다중 이미지 선택 및 검색과 같은 필요한 기능을 제공하면서 개인 정보를 보장합니다.

00:01:00.000 --> 00:01:09.000
PHPicker에 대해 들어본 적이 없다면, WWDC 2020 "Meet the new Photos picker" 세션을 시청하여 자세히 알아볼 수 있습니다.

00:01:09.000 --> 00:01:15.000
iOS 15에서, 시스템 사진 선택기는 네 가지 주요 개선 사항이 있다.

00:01:15.000 --> 00:01:18.000
먼저, 사생활.

00:01:18.000 --> 00:01:26.000
우리는 당신의 앱이 어떤 정보에 접근할 수 있는지 사람들에게 알려주는 것이 중요하다고 생각하며, 이는 신뢰를 증가시킵니다.

00:01:26.000 --> 00:01:40.000
iOS 14에서, 어떤 사람들은 프로세스가 없는 사진 선택기만 표시하고 선택한 사진에만 액세스할 수 있더라도 앱이 전체 사진 라이브러리에 액세스할 수 있다고 가정할 수 있습니다.

00:01:40.000 --> 00:01:46.000
사람들이 그 차이를 이해할 수 있도록, 우리는 설정 &gt; 개인 정보 보호 &gt; 사진에 새로운 섹션을 추가했습니다.

00:01:46.000 --> 00:01:55.000
새로운 섹션에는 시스템 사진 선택기만 사용하는 앱이 포함되어 있으며, 해당 앱은 사람들이 선택한 사진에만 액세스할 수 있음을 설명합니다.

00:01:55.000 --> 00:02:02.000
아직 하지 않았다면 사용자 지정 피커를 시스템으로 교체하는 것이 좋습니다.

00:02:02.000 --> 00:02:06.000
다음으로, 주문한 선택에 대해 이야기해 봅시다.

00:02:06.000 --> 00:02:12.000
때때로, 사람들은 사진을 선택할 때 사진의 순서를 제어하고 싶을 수도 있다.

00:02:12.000 --> 00:02:20.000
iOS 15에서, 당신의 앱은 여기에 표시된 것처럼 선택 순서를 표시하도록 선택기를 구성할 수 있습니다.

00:02:20.000 --> 00:02:25.000
기본적으로, 우리는 여전히 선택 체크 표시를 표시할 것이다.

00:02:25.000 --> 00:02:34.000
새로운 정렬된 선택 동작을 선택하려면, 다중 선택을 활성화하고 "선택"을 "순서"로 설정하기만 하면 됩니다.

00:02:34.000 --> 00:02:40.000
PHPicker API는 누군가가 해야 할 모든 것이 새로운 사진을 선택하는 것일 때 잘 작동합니다.

00:02:40.000 --> 00:02:45.000
하지만 사람들이 피커를 사용하여 사진을 선택 해제하고 싶다면 어떨까요?

00:02:45.000 --> 00:02:51.000
iOS 15에서는 새로운 사전 선택 API를 사용할 수 있습니다.

00:02:51.000 --> 00:02:58.000
하지만 새로운 API에 대해 이야기하기 전에, PHPicker API가 현재 어떻게 사용되는지 다시 살펴봅시다.

00:02:58.000 --> 00:03:07.000
PHPickerConfiguration 객체를 만들고 그것을 사용하여 선택기를 초기화하기만 하면 됩니다.

00:03:07.000 --> 00:03:13.000
피커 세션이 완료되면, 선택한 사진이 앱으로 반환됩니다.

00:03:13.000 --> 00:03:23.000
구성이 PHPhotoLibrary 객체로 초기화된다고 가정하면, 피커 결과는 항목 제공자와 자산 식별자를 모두 포함합니다.

00:03:23.000 --> 00:03:30.000
앱은 항목 제공자를 사용하여 선택한 사진을 로드하고 표시할 수 있습니다.

00:03:30.000 --> 00:03:35.000
iOS 15에서는 처음에 선택된 일부 사진과 함께 피커를 제시할 수도 있습니다.

00:03:35.000 --> 00:03:43.000
사람들이 더 많은 사진을 선택하거나 앱에서 미리 선택한 사진을 선택 해제할 수 있습니다.

00:03:43.000 --> 00:03:48.000
그렇게 하려면, 새로운 구성 객체를 만들어야 합니다.

00:03:48.000 --> 00:03:59.000
이 경우 이전에 검색한 자산 식별자 배열, ID: 1 및 ID: 2를 구성할 수 있습니다.

00:03:59.000 --> 00:04:07.000
새로운 PHPickerViewController가 제시되면, ID: 1과 ID: 2가 있는 사진이 기본적으로 선택됩니다.

00:04:07.000 --> 00:04:13.000
사람들은 그것들을 선택 해제하거나 추가 사진을 선택할 수 있다.

00:04:13.000 --> 00:04:20.000
나중에 사용해야 하기 때문에 지금은 여전히 오래된 피커 결과를 유지하고 싶습니다.

00:04:20.000 --> 00:04:28.000
신분증: 2가 있는 사진이 선택 해제되었지만, 신분증: 3이 있는 새 사진이 선택에 추가되었다고 가정해 봅시다.

00:04:28.000 --> 00:04:33.000
피커 세션이 완료되면, 선택한 사진이 반환됩니다.

00:04:33.000 --> 00:04:39.000
하지만 첫 번째 결과는 실제 자산 데이터가 없는 자산 식별자만 가지고 있다.

00:04:39.000 --> 00:04:40.000
왜?

00:04:40.000 --> 00:04:43.000
왜냐하면 그것은 당신의 앱에 의해 선택되었기 때문입니다.

00:04:43.000 --> 00:04:50.000
앱을 사용하는 사람들이 선택하지 않은 모든 결과에는 빈 항목 제공자가 있습니다.

00:04:50.000 --> 00:04:59.000
이전 피커 결과에는 실제 자산 데이터가 있으므로 이전 ID: 1 결과를 사용하여 빈 항목 공급자로 대체할 수 있습니다.

00:04:59.000 --> 00:05:07.000
ID: 2가 더 이상 선택되지 않았기 때문에, 이전 ID: 2 결과를 삭제할 수 있습니다.

00:05:07.000 --> 00:05:08.000
알았어.

00:05:08.000 --> 00:05:13.000
이제 우리는 이전처럼 선택된 사진을 계속 처리할 수 있습니다.

00:05:13.000 --> 00:05:23.000
요약하자면: 피커 세션이 완료되면, 선택 해제되지 않은 미리 선택된 자산을 포함하여 선택된 모든 자산이 반환됩니다.

00:05:23.000 --> 00:05:31.000
그리고 미리 선택된 자산에 대한 반품된 품목 제공자는 비어 있을 것이라는 점을 명심하세요.

00:05:31.000 --> 00:05:37.000
피커 세션이 취소되는 경우, 미리 선택된 자산만 반환됩니다.

00:05:37.000 --> 00:05:41.000
모든 물품 제공자는 비어 있을 것이다.

00:05:41.000 --> 00:05:46.000
좋아, 코드를 살펴보자.

00:05:46.000 --> 00:05:56.000
미리 선택된 자산을 설정하려면, photoLibrary 객체로 구성을 초기화하고 다중 선택을 활성화하기만 하면 됩니다.

00:05:56.000 --> 00:06:04.000
새로운 preselectedAssetIdentifiers API를 사용하여 미리 선택된 자산을 설정할 수 있습니다.

00:06:04.000 --> 00:06:12.000
위임 콜백에서, 이전 피커 세션에서 existingSelection을 검색해야 합니다.

00:06:12.000 --> 00:06:17.000
그런 다음, 새로 반환된 모든 피커 결과를 반복할 수 있습니다.

00:06:17.000 --> 00:06:24.000
기존 선택의 일부인 경우 새 결과를 이전 결과로 대체해야 합니다.

00:06:24.000 --> 00:06:29.000
마지막으로, 업데이트된 선택을 저장할 수 있습니다.

00:06:29.000 --> 00:06:33.000
마지막으로, 진행 상황 보고에 대해 이야기해 봅시다.

00:06:33.000 --> 00:06:45.000
장치에서 로컬로 사용할 수 없는 경우 대용량 자산을 다운로드하는 데 시간이 걸릴 수 있으며, 이는 iCloud 사진과 저장 공간 최적화가 켜져 있는 경우 발생할 수 있습니다.

00:06:45.000 --> 00:06:53.000
이전에는 로딩하는 동안 스피너만 보여줄 수 있는데, 이는 항상 이상적인 사용자 경험은 아닙니다.

00:06:53.000 --> 00:07:02.000
iOS 15에서 앱이 피커에서 실제 로딩 진행 상황을 검색할 수 있다는 것을 발표하게 되어 기쁩니다.

00:07:02.000 --> 00:07:07.000
로딩 진행 상황은 기존 NSItemProvider API를 통해 사용할 수 있습니다.

00:07:07.000 --> 00:07:11.000
반환된 진행 상황을 사용하여 그에 따라 로딩 UI를 표시할 수 있습니다.

00:07:11.000 --> 00:07:14.000
그게 사진 선택기 업데이트의 전부입니다.

00:07:14.000 --> 00:07:21.000
이제 나는 새로운 cloudIdentifier API에 대해 더 이야기하기 위해 동료인 Adam에게 넘길 것이다.

00:07:21.000 --> 00:07:22.000
고마워, 저스틴.

00:07:22.000 --> 00:07:29.000
우리가 추가한 새로운 기능과 API를 통해, 사진 선택기는 대부분의 개발자가 앱에서 사진을 사용할 수 있는 가장 좋은 방법입니다.

00:07:29.000 --> 00:07:44.000
하지만 우리는 사진, 사용자 지정 카메라 또는 사람들에게 독특한 방식으로 사진 라이브러리를 탐색할 수 있는 방법을 제공하는 앱을 관리하거나 편집하기 위해 더 깊은 수준의 액세스 및 통합이 필요한 특별한 범주의 응용 프로그램이 있다는 것을 알고 있습니다.

00:07:44.000 --> 00:07:53.000
이러한 앱의 경우, PhotoKit은 사진 라이브러리에 저장된 사진, 비디오 및 앨범에 액세스하고 업데이트하기 위한 풍부한 API 세트를 제공합니다.

00:07:53.000 --> 00:08:03.000
자산과 앨범은 PhotoKit에 의해 앱에 저장한 다음 나중에 사진 라이브러리에서 동일한 레코드를 검색하는 데 사용할 수 있는 고유 식별자가 제공됩니다.

00:08:03.000 --> 00:08:12.000
모든 사진 라이브러리와 그 식별자는 해당 장치가 iCloud 사진과 라이브러리를 동기화하는 경우에도 실행 중인 장치에 따라 다릅니다.

00:08:12.000 --> 00:08:15.000
그러니 당신의 앱으로 다시 관심을 돌리자.

00:08:15.000 --> 00:08:24.000
사람들은 외출할 때 iPhone에서 앱을 사용할 수 있는 방식을 좋아하고, 책상으로 돌아가서 노트북이나 iPad를 사용하여 더 큰 형식을 활용합니다.

00:08:24.000 --> 00:08:29.000
당신의 고객들은 한 장치에서 다른 장치로 전환할 때 원활한 경험을 원합니다.

00:08:29.000 --> 00:08:36.000
예를 들어, 사람들이 사진과 댓글로 경험을 기록할 수 있도록 사진 저널링 앱을 만들었다고 가정해 봅시다.

00:08:36.000 --> 00:08:41.000
이동 중에도 콘텐츠를 캡처할 수 있는 iPhone 앱으로 완벽합니다.

00:08:41.000 --> 00:08:50.000
그들은 휴대폰에 추가한 모든 사진과 콘텐츠와 함께 iPad 또는 Mac에서 내 앱을 열 때 중단한 곳에서 바로 그 저널 작업을 시작할 수 있어야 합니다.

00:08:50.000 --> 00:08:52.000
그래서 그건 어떻게 작동해?

00:08:52.000 --> 00:08:58.000
각 장치에 자체 사진 라이브러리와 고유한 식별자가 있을 때 동일한 자산을 어떻게 찾나요?

00:08:58.000 --> 00:09:02.000
그것은 새로운 클라우드 식별자 API를 사용하여 작동합니다.

00:09:02.000 --> 00:09:07.000
그들은 당신에게 장치 간에 동일한 자산과 앨범을 찾을 수 있는 방법을 제공합니다.

00:09:07.000 --> 00:09:13.000
클라우드 식별자를 사용하여 각 사진 라이브러리에 고유한 로컬 식별자를 찾습니다.

00:09:13.000 --> 00:09:24.000
그리고 이러한 새로운 API는 PhotoKit을 지원하는 모든 플랫폼에서 사용할 수 있습니다: iOS, iPadOS, macOS 및 tvOS.

00:09:24.000 --> 00:09:30.000
목표는 클라우드에 대해 걱정할 필요 없이 장치 간에 자산을 매핑하는 간단한 방법을 제공하는 것입니다.

00:09:30.000 --> 00:09:42.000
iCloud 사진에 로그인한 계정에서 실행할 때 가장 잘 작동하도록 설계되었지만, 클라우드 식별자는 계정이 로그아웃되었거나 iCloud에 로그인한 적이 없는 시스템에서 실행되는 경우에도 작동합니다.

00:09:42.000 --> 00:09:45.000
그것은 모두 식별자 매핑을 기반으로 하므로, 분명히 합시다.

00:09:45.000 --> 00:09:47.000
두 종류의 식별자가 있다.

00:09:47.000 --> 00:09:54.000
로컬 식별자는 제가 앞서 이야기한 것으로, 해당 라이브러리와 관련된 장치에서 사용하는 식별자입니다.

00:09:54.000 --> 00:10:00.000
이전에 PhotoKit을 사용한 적이 있다면, API에서 localIdentifiers라고 불리는 것을 본 적이 있습니다.

00:10:00.000 --> 00:10:06.000
클라우드 식별자는 한 장치 또는 다른 장치에서 로컬 식별자를 찾는 데 사용되는 새로운 API입니다.

00:10:06.000 --> 00:10:12.000
그것들은 PHCloudIdentifier라고 불리는 새로 사용 가능한 클래스로 대표된다.

00:10:12.000 --> 00:10:14.000
그것들을 어떻게 사용하는지 알아봅시다.

00:10:14.000 --> 00:10:20.000
우리는 당신의 앱이 일부 자산에 대한 로컬 식별자 목록을 수집한 소스 장치에서 시작할 것입니다.

00:10:20.000 --> 00:10:26.000
그 지역 식별자 배열에서, 우리는 해당 클라우드 식별자를 얻고 싶다.

00:10:26.000 --> 00:10:29.000
다음은 API를 사용하여 그것들을 얻는 방법의 예입니다.

00:10:29.000 --> 00:10:37.000
사진 라이브러리에 대한 이 호출은 각 localIdentifier에 대한 cloudIdentifierMapping 객체가 있는 사전을 반환합니다.

00:10:37.000 --> 00:10:42.000
우리는 그 사전을 반복하고 cloudMapping 객체에서 cloudIdentifier를 얻을 것이다.

00:10:42.000 --> 00:10:44.000
잠시 후에 오류 처리에 대해 이야기하겠습니다.

00:10:44.000 --> 00:10:49.000
현재로서는, 우리는 클라우드 식별자가 있어야 하며 그것들을 사용할 준비가 되었습니다.

00:10:49.000 --> 00:10:58.000
그리고 클라우드 식별자의 가장 큰 이점은 모든 곳에서 사용하는 것이므로, 다른 클라우드 연결 장치와 공유해야 합니다.

00:10:58.000 --> 00:11:03.000
이 iCloud 계정에 연결된 모든 장치에서 실행될 때 앱에서 사용할 수 있도록 하고 싶습니다.

00:11:03.000 --> 00:11:10.000
클라우드 식별자를 문자열에 보관하고 CloudKit 또는 다른 네트워크 데이터 서비스를 사용하여 해당 데이터를 공유할 수 있습니다.

00:11:10.000 --> 00:11:14.000
이 데이터를 어떻게 포장하는지는 당신과 당신의 앱의 요구에 달려 있습니다.

00:11:14.000 --> 00:11:17.000
두 번째 장치에서 정보를 어떻게 사용할지 생각해 보세요.

00:11:17.000 --> 00:11:24.000
클라우드 식별자가 참조하는 콘텐츠를 포함하도록 애플리케이션 상태를 어떻게 재구성합니까?

00:11:24.000 --> 00:11:35.000
이제, 두 번째 장치에서, 클라우드 식별자를 다운로드하고 보관 해제하면, 우리는 그것들을 사용하여 라이브러리별 로컬 식별자를 찾고 싶습니다.

00:11:35.000 --> 00:11:44.000
다른 방향으로 작업하면서, 사진 라이브러리에 대한 이 호출은 각 cloudIdentifier에 대한 localIdentifierMapping 객체가 있는 사전을 반환합니다.

00:11:44.000 --> 00:11:51.000
다시 말하지만, 우리는 사전을 반복하고 이번에는 localMapping 객체에서 localIdentifier를 얻을 것이다.

00:11:51.000 --> 00:11:58.000
모든 localIdentifiers를 갖게 되면, 소스 장치에 있던 자산을 가져오고 표시하는 데 사용할 수 있습니다.

00:11:58.000 --> 00:12:13.000
API가 어떻게 양방향으로 식별자를 쉽게 찾을 수 있는지 알 수 있지만, 다른 장치 구성, 계정 설정, 네트워크 상태 및 수많은 다른 변수의 현실은 항상 그렇게 간단하지 않다는 것을 의미할 수 있습니다.

00:12:13.000 --> 00:12:23.000
그 복잡성을 처리하기 위해, API는 한 쌍의 도우미 객체를 사용하여 유효한 식별자 또는 매핑이 실패한 이유를 나타내는 오류를 보유합니다.

00:12:23.000 --> 00:12:28.000
식별자 매핑을 찾을 때 처리해야 하는 두 가지 종류의 오류가 있습니다.

00:12:28.000 --> 00:12:42.000
기본 레코드가 없거나 앱이 액세스할 수 없기 때문에 사진 라이브러리가 식별자 매핑을 해결할 수 없는 경우, API에서 반환된 매핑 객체에는 식별자를 찾을 수 없는 오류가 포함됩니다.

00:12:42.000 --> 00:12:49.000
여기서 식별자가 설정되지 않은 경우 localIdentifierMapping 객체에서 오류 코드를 어떻게 받는지 볼 수 있습니다.

00:12:49.000 --> 00:13:00.000
식별자를 찾을 수 없는 오류의 경우, 해결되지 않은 cloudIdentifier를 추적하여 UI에 자리 표시자를 넣어 이 장치에서 사진을 찾을 수 없음을 나타낼 수 있습니다.

00:13:00.000 --> 00:13:05.000
다른 유형의 오류는 식별자 매핑을 고유하게 해결할 수 없는 경우 발생합니다.

00:13:05.000 --> 00:13:10.000
즉, 제공된 클라우드 식별자와 일치하는 여러 자산이 있습니다.

00:13:10.000 --> 00:13:17.000
이것은 클라우드 상태가 이 장치에서 완전히 동기화되지 않고 라이브러리가 일치하는 것을 찾기 위해 이미지 콘텐츠에 의존해야 하는 경우 발생할 수 있습니다.

00:13:17.000 --> 00:13:28.000
이 경우, 매핑 객체에는 다중 식별자 발견 오류가 있으며, 오류 사용자 정보에는 일치하는 식별자가 포함됩니다.

00:13:28.000 --> 00:13:39.000
다중 식별자 발견 오류 코드를 사용하면 LocalIdentifiersErrorKey를 사용하여 오류 사용자 정보에서 일치하는 로컬 식별자를 얻을 수 있습니다.

00:13:39.000 --> 00:13:48.000
이 예에서, 우리는 그것들을 사전에 숨겨서 나중에 일치하는 자산을 가져오고 보여주고 고객이 결정하도록 할 수 있습니다.

00:13:48.000 --> 00:13:51.000
그것은 클라우드 식별자와 사용 방법에 대한 개요입니다.

00:13:51.000 --> 00:14:10.000
로컬 및 클라우드 식별자 간의 매핑을 찾는 것은 비용이 많이 들 수 있으므로, 사진 라이브러리와의 앱 상호 작용에서 로컬 식별자를 사용하고, 로드 및 저장 지점에서 매핑 작업을 수행한 다음, 클라우드 식별자를 저장하고 공유하여 다른 장치에서 사용할 수 있도록 하십시오.

00:14:10.000 --> 00:14:14.000
다음은 제한된 도서관입니다.

00:14:14.000 --> 00:14:20.000
제한된 라이브러리에 대한 업데이트에 뛰어들기 전에, 사진 라이브러리 액세스가 어떻게 작동하는지 빠르게 검토해 봅시다.

00:14:20.000 --> 00:14:31.000
누군가가 앱을 실행하고 PhotoKit을 사용하여 사진 데이터에 대한 액세스를 요청할 때, 시스템은 앱 액세스 권한을 부여하기 전에 권한이 필요합니다.

00:14:31.000 --> 00:14:34.000
그리고 이것이 처음 일어날 때, 그들은 이와 같은 경고를 보게 될 것이다.

00:14:34.000 --> 00:14:37.000
이것은 우리 고객들에게 정말 중요하다.

00:14:37.000 --> 00:14:50.000
그것은 그들에게 이 응용 프로그램에 얼마나 많은 접근 권한을 부여할 수 있는지를 제공합니다: 제한된 사진 선택에 대한 액세스를 허용하거나, 전체 라이브러리에 대한 완전한 액세스 권한을 허용하거나, 완전히 액세스를 거부하는 것입니다.

00:14:50.000 --> 00:14:57.000
그들이 사진 선택 옵션을 선택하면, 앱에 제한된 도서관 접근 권한이 부여됩니다.

00:14:57.000 --> 00:15:10.000
제한된 라이브러리 모드에 대한 자세한 설명과 가장 잘 작동하도록 앱을 디자인하는 방법은 WWDC '20 세션 "앱에서 제한된 사진 라이브러리 처리"를 참조할 수 있습니다.

00:15:10.000 --> 00:15:16.000
현재로서는, 제한된 라이브러리 액세스가 앱 개발자에게 투명하도록 설계되었다는 것을 아는 것으로 충분하다.

00:15:16.000 --> 00:15:24.000
일반적으로 PhotoKit API는 라이브러리에 선택된 사진만 포함된 것처럼 정상적으로 작동해야 합니다.

00:15:24.000 --> 00:15:27.000
그것은 일반적인 워크플로우와 함께 편리하게 작동한다.

00:15:27.000 --> 00:15:36.000
예를 들어, 앱이 라이브러리에 사진을 추가하면, 그 사진은 앱의 제한된 라이브러리 선택에 자동으로 포함됩니다.

00:15:36.000 --> 00:15:42.000
그들이 추가한 자산을 추적하기 위해 사용자 지정 앨범을 사용하는 앱에서 볼 수 있는 또 다른 워크플로우가 있습니다.

00:15:42.000 --> 00:15:50.000
하지만 iOS 14에서 제한된 라이브러리 모드는 사용자 지정 앨범을 만들거나 액세스할 수 없습니다.

00:15:50.000 --> 00:16:00.000
iOS 15에서 제한된 라이브러리 모드에서 실행할 때 자신의 앨범을 만들고, 가져오고, 업데이트하는 응용 프로그램에 대한 지원을 추가했습니다.

00:16:00.000 --> 00:16:08.000
이제 다른 워크플로우로 관심을 돌리고, 이를 위해, 저는 제 예시 사진 저널링 앱을 다시 참조할 것입니다.

00:16:08.000 --> 00:16:21.000
고객이 내 앱에 대한 제한된 라이브러리 액세스를 선택했을 때 훌륭한 경험을 제공하고 싶기 때문에, 새로운 저널을 만드는 일환으로 제한된 라이브러리 선택기를 제공하기 위해 인터페이스를 사용자 정의했습니다.

00:16:21.000 --> 00:16:27.000
이것은 저널을 만드는 동안 더 많은 사진을 선택할 수 있는 자연스러운 단계를 제공한다.

00:16:27.000 --> 00:16:35.000
하지만 일단 선택이 업데이트되면, 내 고객이 이 저널에서 사용하고 싶어하는 사진이기 때문에 어떤 사진이 추가되었는지 아는 것이 좋을 것이다.

00:16:35.000 --> 00:16:45.000
iOS 15의 새로운 presentLimitedLibraryPicker API를 사용하면 피커에서 방금 선택한 사진의 식별자를 제공하는 완료 핸들러를 전달할 수 있습니다.

00:16:45.000 --> 00:16:52.000
이것은 선택 업데이트가 언제 완료되고 어떤 자산을 추가했는지 알려준다.

00:16:52.000 --> 00:17:03.000
그것은 제한된 라이브러리에 대한 업데이트, 자신의 앨범을 만들고 작업할 수 있는 앱에 대한 지원, 그리고 제한된 라이브러리 선택에 추가된 것을 추적할 수 있는 방법을 제공하는 새로운 API를 다룹니다.

00:17:03.000 --> 00:17:09.000
그것이 우리가 오늘 이야기해야 했던 것의 대부분이지만, 우리가 가기 전에, 나는 당신에게 다음과 같이 남기고 싶습니다.

00:17:09.000 --> 00:17:14.000
한동안 코드를 업데이트하지 않은 사람들을 위해, 자산 라이브러리에서 벗어나야 할 때입니다.

00:17:14.000 --> 00:17:19.000
그것은 iOS 9 이후로 더 이상 사용되지 않으며, 우리는 향후 SDK에서 그것을 제거할 계획입니다.

00:17:19.000 --> 00:17:27.000
지금은 사진과의 더 깊은 통합을 위해 새로운 사진 선택기 또는 PhotoKit으로 이동할 때입니다.

00:17:27.000 --> 00:17:43.000
그리고 PhotoKit으로 이동해야 하는 또 다른 이유: 우리는 오류 처리에 오랜 격차가 있다는 것을 알고 있으며, 변경 요청 처리, 리소스 요청 및 라이브러리 액세스 호출 중에 근본적인 문제를 식별하기 위해 마침내 새로운 오류 코드로 문제를 해결했다는 것을 알려드리게 되어 매우 기쁩니다.

00:17:43.000 --> 00:17:50.000
iOS 15에서 사진 선택기와 PhotoKit에 추가한 모든 훌륭한 새로운 기능을 빨리 확인하고 싶습니다.

00:17:50.000 --> 23:59:59.000
고마워.

