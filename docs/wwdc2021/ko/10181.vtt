WEBVTT

00:00:00.000 --> 00:00:10.000
안녕하세요, 여러분.

00:00:10.000 --> 00:00:15.000
제 이름은 셰팔리 사부이고, 저는 여기 애플의 성능 도구 엔지니어입니다.

00:00:15.000 --> 00:00:19.000
우리가 함께 애플리케이션 성능을 탐색할 때 내가 너의 가이드가 되어줄게.

00:00:19.000 --> 00:00:23.000
오늘의 여행은 공연의 세계를 가로지르는 스릴 넘치는 여행이 될 것이다.

00:00:23.000 --> 00:00:29.000
당신의 앱은 우리 장치의 전반적인 소프트웨어 경험에서 중요한 역할을 합니다.

00:00:29.000 --> 00:00:40.000
앱을 계속 최적화하고 성능을 개선한다는 것은 사용자가 앱을 더 자주 사용하고, 더 많은 참여를 유지하며, 더 오랜 기간 동안 앱을 사용할 것이라는 것을 의미합니다.

00:00:40.000 --> 00:00:46.000
성능 최적화는 추적할 많은 메트릭과 사용할 도구가 있는 어려운 작업처럼 보일 수 있다.

00:00:46.000 --> 00:00:47.000
하지만 두려워하지 마.

00:00:47.000 --> 00:00:59.000
이 생존 가이드는 개발을 다음 단계로 끌어올리고 최상의 고객 경험을 보장하는 데 도움이 될 수 있는 툴링, 메트릭 및 패러다임에 대한 속도를 높일 것입니다.

00:00:59.000 --> 00:01:07.000
우리가 우리의 공연 도구와 당신이 그들과 함께 할 수 있는 훌륭한 것들을 살펴보는 동안 당신의 가이드가 되어 매우 기쁩니다.

00:01:07.000 --> 00:01:18.000
오늘 다룰 다섯 가지 주요 도구가 있을 것입니다: Xcode Organizer, MetricKit, Instruments, XCTest 및 App Store Connect API.

00:01:18.000 --> 00:01:23.000
우리는 주요 지표에 대한 빠른 소개로 시작할 것이다.

00:01:23.000 --> 00:01:31.000
그런 다음 각 도메인 영역의 몇 가지 일반적인 문제와 이를 해결하고 예방하는 방법을 살펴보세요.

00:01:31.000 --> 00:01:34.000
그리고 마지막으로, 우리는 몇 가지 다음 단계로 끝낼 것이다.

00:01:34.000 --> 00:01:38.000
성능 최적화는 정류장이 많은 긴 강과 같다.

00:01:38.000 --> 00:01:44.000
내비게이션에 필요한 몇 가지 다른 도구가 있으며, 각 정류장에는 새로운 것을 배울 수 있습니다.

00:01:44.000 --> 00:01:47.000
강을 따라 여행을 가자.

00:01:47.000 --> 00:01:49.000
먼저, 빠른 소개.

00:01:49.000 --> 00:01:54.000
오늘 다룰 다양한 성과 지표를 살펴봅시다.

00:01:54.000 --> 00:02:07.000
현재 애플리케이션 성능을 위해 추적해야 할 여덟 가지 주요 사항이 있습니다: 배터리 사용량, 시작 시간, 중단 속도, 메모리, 디스크 쓰기, 스크롤, 종료 및 MXSignposts.

00:02:07.000 --> 00:02:10.000
이 모든 것은 우리의 도구 세트를 통해 추적할 수 있다.

00:02:10.000 --> 00:02:19.000
저는 사용자가 일주일 동안 식사를 추적하고 멋진 레시피를 저장할 수 있는 MealPlanner라는 앱의 개발자입니다.

00:02:19.000 --> 00:02:26.000
여기 내 앱 내에서 특히 스크롤 히치 형태의 열악한 사용자 경험의 예가 있습니다.

00:02:26.000 --> 00:02:31.000
느리고, 건너뛰고, 불안한 스크롤을 눈치채셨나요?

00:02:31.000 --> 00:02:38.000
반대로, 여기에 원활한 사용자 경험과 문제가 없는 동일한 응용 프로그램이 있습니다.

00:02:38.000 --> 00:02:49.000
우리는 이미 두 경험 사이에 상당한 차이가 있다는 것을 알 수 있으며, 이 부드러운 스크롤은 성능 최적화를 통해 달성하도록 돕고자 하는 것입니다.

00:02:49.000 --> 00:02:54.000
각 성과 메트릭은 고유한 패러다임과 공통 툴링을 가지고 있다.

00:02:54.000 --> 00:03:00.000
각 도메인 영역의 몇 가지 일반적인 문제와 이를 해결하고 예방하는 방법에 바로 뛰어들자.

00:03:00.000 --> 00:03:05.000
강을 따라 우리의 첫 번째 정류장은 배터리 사용이다.

00:03:05.000 --> 00:03:09.000
앱이 배터리를 많이 소모하고 있다면, 사용자가 볼 수 있는 것은 다음과 같습니다.

00:03:09.000 --> 00:03:12.000
이것은 배터리 UI입니다.

00:03:12.000 --> 00:03:22.000
그것은 사용자에게 장치의 앱의 전체 배터리 소모량과 포그라운드 및 백그라운드 활동을 보여줍니다.

00:03:22.000 --> 00:03:24.000
왜 배터리 수명을 개선하는 데 신경을 써야 하나요?

00:03:24.000 --> 00:03:26.000
쉬워.

00:03:26.000 --> 00:03:32.000
사용자는 재충전할 필요 없이 하루 종일 장치를 사용할 수 있는 앱 사용을 우선시합니다.

00:03:32.000 --> 00:03:38.000
배터리 수명을 최적화함으로써, 사용자는 장치와 앱을 더 오랜 기간 동안 사용할 수 있습니다.

00:03:38.000 --> 00:03:41.000
그것은 그 자체로 승리이다.

00:03:41.000 --> 00:03:47.000
배터리 수명을 최적화할 때 주의해야 할 다양한 하위 시스템이 있습니다.

00:03:47.000 --> 00:03:53.000
주의해야 할 상위 세 가지는 CPU, 네트워킹 및 위치입니다.

00:03:53.000 --> 00:04:01.000
개발 중 또는 버전이 이미 출시된 후 몇 가지 다른 도구를 사용하여 앱의 배터리 수명을 추적하고 분류할 수 있습니다.

00:04:01.000 --> 00:04:15.000
책상에서 새로운 기능을 개발하고 테스트하는 동안, Xcode를 통해 코드를 빌드하고 실행하고, 작은 스프레이 병처럼 보이는 디버그 네비게이터를 클릭하여 Xcode가 제공하는 다양한 게이지를 볼 수 있습니다.

00:04:15.000 --> 00:04:18.000
내가 세심한 주의를 기울일 것은 에너지 게이지이다.

00:04:18.000 --> 00:04:30.000
에너지 게이지를 사용하면 앱을 테스트할 때 CPU 사용량을 추적할 수 있으며 높은 CPU 사용률과 CPU 웨이크 오버헤드 영역을 보여줍니다.

00:04:30.000 --> 00:04:42.000
높은 CPU 사용률은 CPU 사용량이 20% 이상일 때이며, CPU 웨이크 오버헤드는 CPU가 유휴 상태에서 깨어나고 에너지 비용이 발생하는 지역입니다.

00:04:42.000 --> 00:05:00.000
내 앱이 사용자 인터페이스를 그리거나, 네트워크에서 데이터를 처리하거나, 계산을 수행할 때 CPU가 급증하는 것이 일반적이지만, 이러한 작업이 완료되고 내 앱이 사용자가 다음 작업을 수행하기를 기다리고 있으면 CPU 사용량이 0에 가깝거나 0에 가까운 것을 볼 수 있습니다.

00:05:00.000 --> 00:05:11.000
여기에서 시간 프로필을 클릭하여 인스트루먼트에서 내 앱을 프로파일링하고 프로파일링된 기간 동안 열 상태, CPU 사용량 및 활성 통화 스택을 볼 수 있습니다.

00:05:11.000 --> 00:05:20.000
또한 위치 에너지 모델을 사용하여 핵심 위치의 영향을 측정하고 내 앱이 사용하지 말아야 할 때 위치를 사용하지 않는지 확인할 수 있습니다.

00:05:20.000 --> 00:05:31.000
때때로, 내 앱의 베타 또는 출시 버전에 내 책상에서 재현하기 어렵거나 디버깅을 위해 더 많은 로깅과 컨텍스트가 필요할 수 있는 버그가 있을 수 있습니다.

00:05:31.000 --> 00:05:45.000
온디바이스에서 올인원 성능 원격 측정 프레임워크로 작동하는 MetricKit은 근본 원인을 좁히고 고객이 직면한 문제에 대한 귀중한 통찰력을 제공하는 데 도움이 될 수 있습니다.

00:05:45.000 --> 00:05:57.000
MetricKit을 사용하려면 앱에 AppMetrics라는 사용자 지정 클래스를 추가하고 구현하고 이 새로운 클래스를 MXMetricManagerSubscriber 프로토콜에 맞추기만 하면 됩니다.

00:05:57.000 --> 00:06:02.000
그러면 나는 매니저에게 내 맞춤 수업에 대한 참조를 추가할 수 있다.

00:06:02.000 --> 00:06:08.000
그리고 추천 모범 사례인 deinit에 대한 내 사용자 지정 수업에 대한 참조를 제거하세요.

00:06:08.000 --> 00:06:13.000
나는 해당 didReceive 방법으로 이 데이터를 처리할 수 있다.

00:06:13.000 --> 00:06:25.000
전략적으로 완료되면, 문제가 발생했을 때 무엇이 잘못되었을 수 있는지에 대한 MetricKit의 상황별 데이터로 에너지 로그 및 CPU 메트릭과 같은 주최자에서 찾을 수 있는 많은 데이터를 보강할 수 있습니다.

00:06:25.000 --> 00:06:33.000
온디바이스 분석 파이프라인 덕분에 추가 노력 없이 이 데이터의 간단한 버전을 사용할 수 있습니다.

00:06:33.000 --> 00:06:38.000
사용자가 앱을 사용할 때, 우리는 동의한 장치에서 성능 데이터를 수집합니다.

00:06:38.000 --> 00:06:45.000
그런 다음 이 데이터는 서버에 집계되어 Xcode Organizer와 같은 많은 도구 중 하나를 통해 다시 전송됩니다.

00:06:45.000 --> 00:07:00.000
이미 앱 스토어에 있는 내 앱 버전의 성능 데이터를 보기 위해 Xcode Organizer에 액세스하는 것은 Xcode가 열려 있는 동안 메뉴 표시줄로 이동하여 창으로 이동하고 Organizer를 클릭하여 실행하는 것만큼 쉽습니다.

00:07:00.000 --> 00:07:13.000
여기에 도착하면, 배터리 사용량 메트릭을 클릭하여 지난 16개의 앱 버전에서 내 앱에 대한 집계된 데이터와 차트 오른쪽에 있는 주요 하위 구성 요소별 세부 내역을 볼 수 있습니다.

00:07:13.000 --> 00:07:25.000
내 앱의 최신 버전에 주요 회귀가 있다면, Xcode 13의 새로운 회귀 창으로 이동하면 주최자에 버전이 표시된 직후에 그것에 대해 알게 될 것입니다.

00:07:25.000 --> 00:07:36.000
이 새로운 회귀 창은 가장 최신 버전의 앱에서 크게 증가한 모든 메트릭을 분리하여 한 곳에서 집중해야 할 모든 것을 볼 수 있습니다.

00:07:36.000 --> 00:07:49.000
내 앱의 어떤 영역이 문제를 일으켰는지 결정하기 위해, 보고서 아래의 Energy Organizer를 사용하여 CPU 사용량이 높은 지역과 동의한 사용자 장치에서 수집된 로그를 볼 수도 있습니다.

00:07:49.000 --> 00:07:53.000
이것은 내 앱에서 무슨 일이 일어나고 있는지에 대한 더 자세한 모습을 제공한다.

00:07:53.000 --> 00:08:04.000
App Store Connect API를 쿼리하고 요청한 데이터와 함께 반환되는 JSON 페이로드에 대한 자체 분석을 실행하여 이 모든 데이터를 얻을 수 있습니다.

00:08:04.000 --> 00:08:11.000
이 모든 도구를 사용하면 앱에서 많은 배터리 사용량 회귀를 쉽게 포착하고 해결할 수 있습니다.

00:08:11.000 --> 00:08:25.000
배터리 수명 최적화에 대해 자세히 알아보려면 2019년의 "배터리 수명 및 성능 개선" 토크를 확인하고, 악기 사용에 대해 자세히 알아보려면 올해 "악기의 HTTP 트래픽 분석" 토크를 확인하세요.

00:08:25.000 --> 00:08:32.000
우리의 다음 정거장은 내 앱이 반응하지 않는다는 것을 전달하는 두 가지 지표인 행 속도와 스크롤링이다.

00:08:32.000 --> 00:08:40.000
중단은 앱이 최소 250밀리초 동안 사용자 입력이나 동작에 반응하지 않는 경우입니다.

00:08:40.000 --> 00:08:54.000
앱에 매달리면 고객이 앱 스위처에서 애플리케이션을 강제로 종료할 수 있으며 앱에서 사용자 경험에 대한 주요 장애물이며 우선 순위를 지정해야 합니다.

00:08:54.000 --> 00:09:00.000
새로운 콘텐츠가 다음 화면 새로 고침을 위해 준비되지 않았을 때 말더듬 스크롤이 발생합니다.

00:09:00.000 --> 00:09:08.000
이것들은 즐겁지 않은 사용자 경험과 전반적인 좌절감으로 이어질 것이며, 결과적으로 사용자는 앱에서 더 적은 시간을 소비하게 될 것입니다.

00:09:08.000 --> 00:09:18.000
앱 개발자로서, 목표는 사용자 참여를 극대화하는 것이므로, 이곳은 최적화를 시작하기에 좋은 장소입니다.

00:09:18.000 --> 00:09:20.000
우리가 아까 보여줬던 부드러운 스크롤 기억해?

00:09:20.000 --> 00:09:24.000
이것을 목표로 하는 것은 당신의 사용자에게 가장 이익이 됩니다.

00:09:24.000 --> 00:09:32.000
각각의 보기로 이동하여 Xcode Organizer에서 중단과 스크롤 메트릭을 추적할 수 있습니다.

00:09:32.000 --> 00:09:48.000
내 앱이 하는 일에 세심한 주의를 기울여야 한다는 신호는 차트가 상승하는 것을 알아차리거나, 스크롤의 경우, 그래프가 여기 그래프와 같이 녹색 막대 대신 노란색과 빨간색 막대를 더 많이 보여주는 것을 알아차린다는 것입니다.

00:09:48.000 --> 00:09:58.000
차트 오른쪽의 키에 따르면, 빨간색 막대는 우리가 이전에 비디오에서 본 열악한 스크롤 경험을 나타내며 즉시 수정되어야 합니다.

00:09:58.000 --> 00:10:03.000
이 데이터는 이제 App Store Connect API를 통해서도 사용할 수 있습니다.

00:10:03.000 --> 00:10:09.000
스레드 상태 또는 시스템 호출 추적을 사용하여 도구를 사용하여 중단의 원인을 감지할 수 있습니다.

00:10:09.000 --> 00:10:17.000
스레드 상태 추적 도구는 스레드 상태의 타임라인과 OS가 스레드를 실행하도록 예약했을 때를 보여줍니다.

00:10:17.000 --> 00:10:22.000
세부 정보 섹션에서 스레드가 얼마나 오래 차단되었는지 알 수 있습니다.

00:10:22.000 --> 00:10:29.000
시스템 통화 추적은 입력한 시스템 통화와 얼마나 오래 걸렸는지 자세히 설명하는 이야기를 보여준다.

00:10:29.000 --> 00:10:41.000
사용자의 스크롤 경험에 영향을 미칠 버그가 있는 앱 버전을 출시하지 않는지 확인하기 위해, 내 앱을 실행하고 스크롤하는 XCTest로 성능 테스트를 작성할 수 있습니다.

00:10:41.000 --> 00:10:52.000
이 테스트에서, 저는 scrollDeceleration 서브메트릭을 측정하고 싶다고 명시하고 있으며, 측정 블록의 본문에서 앱에서 기대하는 스크롤 속도로 위로 스와이프하고 있습니다.

00:10:52.000 --> 00:11:01.000
이 측정 블록은 기본적으로 다섯 번 실행되기 때문에, XCTMeasureOptions를 사용하여 실행 사이에 애플리케이션 상태를 재설정할 것입니다.

00:11:01.000 --> 00:11:09.000
나는 이것을 측정 블록에 전달하고, 측정을 중단한 다음, 내 애플리케이션 상태를 재설정할 수 있다.

00:11:09.000 --> 00:11:14.000
때때로, 강제 테스트 사례에서 반응성 문제를 재현하는 것은 쉽지 않을 수 있다.

00:11:14.000 --> 00:11:25.000
운 좋게도, MetricKit은 내 프로덕션 애플리케이션에 배포되었을 때 이러한 문제가 발생했을 때 원격 측정 및 진단을 수집할 수 있게 해준다.

00:11:25.000 --> 00:11:32.000
교수형의 경우, iOS 14에서 MetricKit은 24시간 케이던스로 이러한 진단을 나에게 제공할 것이다.

00:11:32.000 --> 00:11:42.000
iOS 15와 macOS 12의 새로운 기능, 이제 문제가 발생한 직후 앱에서 중단을 포함한 모든 진단을 받게 될 것입니다.

00:11:42.000 --> 00:11:51.000
내 자신의 원격 측정과 함께 이러한 즉각적인 진단을 사용하여, 나는 가장 시급한 반응 문제를 빠르게 근본 원인으로 해결하고 해결할 수 있다.

00:11:51.000 --> 00:12:00.000
스크롤 히치의 경우, iOS 15는 MXSignpost를 사용하여 사용자 지정 애니메이션을 태그하기 위해 MetricKit 내에 새로운 API를 도입합니다.

00:12:00.000 --> 00:12:09.000
MXSignpost는 원격 측정을 위한 중요한 코드 섹션을 표시할 수 있는 MetricKit과 함께 제공되는 래퍼 API입니다.

00:12:09.000 --> 00:12:17.000
MXSignpostAnimation- IntervalBegin API를 사용하면 사용자 지정 애니메이션의 시작을 전략적으로 표시할 수 있습니다.

00:12:17.000 --> 00:12:26.000
MXSignpost 엔드 API를 사용하여 애니메이션의 끝을 표시하고 그 간격 동안 히치레이트 원격 측정을 수집할 수 있습니다.

00:12:26.000 --> 00:12:34.000
이 두 기능은 이 간격에 대한 세분화된 성능 데이터를 캡처할 뿐만 아니라 발생하는 모든 문제를 캡처합니다.

00:12:34.000 --> 00:12:43.000
중단을 이해하고 제거하는 방법에 대해 더 알아보려면, 올해 "앱에서 중단을 이해하고 제거하는" 강연을 확인하는 것이 좋습니다.

00:12:43.000 --> 00:12:56.000
스크롤 히치 문제를 식별하는 방법에 대한 자세한 내용은 2020년부터 "XCTest를 사용하여 히치 제거" 토크와 "UI 애니메이션 히치 및 렌더링 루프 탐색" 기술 토크를 확인하는 것이 좋습니다.

00:12:56.000 --> 00:13:01.000
우리는 이제 디스크 쓰기에 대해 논의하면서 중간 지점에 접근하고 있습니다.

00:13:01.000 --> 00:13:06.000
디스크에 쓰는 것은 사용자의 NAND를 마모시킬 수 있으며, 이는 장치 상태가 좋지 않을 것이다.

00:13:06.000 --> 00:13:18.000
쓰기는 또한 많은 시간이 걸리고 자주 수행하면 사용자 경험이 좋지 않고 성능이 느려질 수 있으므로 이러한 쓰기를 일괄 처리하는 것이 중요합니다.

00:13:18.000 --> 00:13:24.000
앱 버전을 출시하기 전에, 인스트루먼트의 파일 활동 템플릿을 사용하여 앱을 프로파일링할 수 있습니다.

00:13:24.000 --> 00:13:33.000
이것은 시스템 호출의 형태로 파일 시스템 사용을 기록하므로, 앱 코드에서 파일 시스템에 액세스하는 장소를 쉽게 식별할 수 있습니다.

00:13:33.000 --> 00:13:37.000
시스템의 좋은 시민이 되고 디스크에 쓰기를 제한하는 방법에는 여러 가지가 있다.

00:13:37.000 --> 00:13:46.000
몇 가지 일반적인 것들은 쓰기 작업을 일괄 처리하고, 자주 변경되는 데이터를 위해 핵심 데이터를 사용하고, 신속한 파일 생성 및 삭제를 피하는 것입니다.

00:13:46.000 --> 00:13:59.000
내 앱을 프로파일링하는 것 외에도, 과도한 디스크 쓰기가 있는 코드가 사용자 장치에서 실행되는 것을 방지하기 위해 내 앱의 디스크 사용량을 측정하기 위해 XCTest로 성능 테스트를 작성할 수 있습니다.

00:13:59.000 --> 00:14:09.000
이것은 XCTStorageMetric의 인스턴스를 measureWithMetric API에 전달한 다음 디스크에 쓰는 코드를 호출하는 것만큼 간단합니다.

00:14:09.000 --> 00:14:16.000
이 테스트는 블록의 코드로 디스크에 기록된 데이터의 양을 측정하고 Xcode 자체 내에서 결과를 보여줍니다.

00:14:16.000 --> 00:14:25.000
블록의 코드가 그것을 초과하면 테스트가 실패하도록 디스크에 기록될 것으로 예상되는 데이터 양의 기준선을 설정할 수 있습니다.

00:14:25.000 --> 00:14:30.000
이것은 내가 버그 코드를 내놓지 않도록 하는 데 도움이 될 것이다.

00:14:30.000 --> 00:14:39.000
디스크 쓰기가 높은 앱 버전을 이미 출시했다면, 주최자를 사용하여 사용자 장치에서 성능을 추적할 수 있습니다.

00:14:39.000 --> 00:14:47.000
디스크 쓰기 메트릭은 이전에 출시된 버전에 비해 내 앱의 현재 버전이 얼마나 많은 쓰기를 하고 있는지에 대한 추세를 보여준다.

00:14:47.000 --> 00:14:52.000
그래프의 스파이크는 내 앱에 많은 양의 쓰기를 일으키는 버그가 있음을 나타낼 수 있다.

00:14:52.000 --> 00:15:00.000
나는 이 글들의 최고 출처를 확인하고, 이해하고, 그것들을 줄이는 방법을 찾아야 한다.

00:15:00.000 --> 00:15:05.000
디스크 쓰기 보고서를 보면 이 글의 출처를 찾을 수 있다.

00:15:05.000 --> 00:15:12.000
이것들은 내 앱이 24시간 동안 1GB 이상을 쓸 때 생성되는 예외 보고서 모음입니다.

00:15:12.000 --> 00:15:31.000
스택 추적은 내 코드에서 과도한 쓰기를 하고 있는 곳을 보여주며, Xcode 13의 새로운 기능인 Insights라는 추가 세부 사항을 얻을 수 있으며, 이는 시스템의 좋은 시민이 되고 내 앱의 쓰기를 줄일 수 있는 몇 가지 쉬운 최적화를 가리킵니다.

00:15:31.000 --> 00:15:37.000
이 모든 데이터는 이제 App Store Connect API를 통해 사용할 수 있습니다.

00:15:37.000 --> 00:15:42.000
나는 또한 내 애플리케이션에서 발생하는 시간에 MetricKit에서 이러한 보고서를 얻을 수 있다.

00:15:42.000 --> 00:15:56.000
MetricKit을 사용하여 앱의 디스크 사용량을 모니터링하는 경우, MXSignpost 간격으로 중요한 디스크 쓰기 경로를 예약하여 더 세분화된 원격 측정을 수집할 수 있으며, 이는 최적화 기회를 발견하는 데 도움이 될 수 있습니다.

00:15:56.000 --> 00:16:06.000
디스크 쓰기 문제를 원활하게 식별하고 해결하는 방법에 대해 자세히 알아보려면, 올해 "앱에서 전력 및 성능 회귀 진단" 토크를 시청하세요.

00:16:06.000 --> 00:16:11.000
우리가 다음 정거장에 접근함에 따라, 우리는 출시 시간과 종료에 대해 논의할 것이다.

00:16:11.000 --> 00:16:20.000
실행 시간은 사용자가 앱 아이콘을 탭할 때와 앱에서 첫 번째 프레임이 렌더링되는 시간입니다.

00:16:20.000 --> 00:16:33.000
사용자가 앱이 실행되기를 기다리는 데 오랜 시간을 소비한다면, 이는 사용자에게 의도하지 않은 좌절감을 초래할 수 있으며, 실행 시간이 연장되면 시스템이 앱을 종료할 수 있습니다.

00:16:33.000 --> 00:16:44.000
시스템이 앱을 종료하면, 사용자는 처음부터 전체 실행 흐름을 경험하게 되며, 이는 백그라운드 실행 상태에서 재개하는 것보다 훨씬 더 오래 걸립니다.

00:16:44.000 --> 00:16:53.000
프로세스 종료는 시스템 메모리 제한을 초과하거나 출시 시 시간 초과와 같은 다양한 이유로 발생할 수 있습니다.

00:16:53.000 --> 00:17:11.000
이러한 이유 중 하나로 앱이 종료될 때마다, 다음에 사용자가 앱 아이콘을 탭할 때 전체 실행 흐름을 거치며, 시간이 오래 걸릴 뿐만 아니라, 특히 자주 발생하는 경우 실망스러운 경험이기도 합니다.

00:17:11.000 --> 00:17:20.000
상태를 복원하지 않는다면, 이것은 또한 사용자가 자신의 장소를 다시 찾거나 잃어버린 작업을 다시 만들어야 하는 좌절감을 더할 수 있습니다.

00:17:20.000 --> 00:17:29.000
저는 방금 사용자가 식사에 사진과 자세한 레시피를 추가할 수 있는 기능을 갖춘 새 버전의 앱을 출시했습니다.

00:17:29.000 --> 00:17:36.000
이 새로운 기능으로 내 앱의 출시 시간이 어떻게 생겼는지 그리고 이전에 어떻게 생겼는지 봅시다.

00:17:36.000 --> 00:17:42.000
이것은 사용자가 새로운 기능이 있는 지금 내 앱을 실행하려고 할 때 보게 될 것이다.

00:17:42.000 --> 00:17:47.000
첫 번째 프레임을 렌더링하는 데 얼마나 많은 시간이 소요되었는지 알 수 있나요?

00:17:47.000 --> 00:17:51.000
내 앱은 우리가 그것을 사용할 기회가 있기도 전에 중단되었다.

00:17:51.000 --> 00:17:56.000
이에 비해, 그 기능이 추가되기 전의 출시 모습은 다음과 같습니다.

00:17:56.000 --> 00:18:01.000
그것은 마치 내 앱이 출시를 예상하고 첫 번째 프레임을 표시할 준비가 된 것과 같다.

00:18:01.000 --> 00:18:10.000
이 두 가지 예에서, 나는 이미 첫 번째 믿을 수 없을 정도로 느린 실행이 사용자가 내 앱을 생각할 때 기억하기를 바라는 것이 아니라는 것을 알고 있다.

00:18:10.000 --> 00:18:14.000
그래서 나는 이것을 가능한 한 빨리 고쳐야 할 것이다.

00:18:14.000 --> 00:18:25.000
출시 문제는 이미 사용자가 사용하고 있는 내 앱 버전에 있기 때문에, 주최자로 가서 출시 시간과 새로운 종료 창을 살펴보는 것으로 시작할 수 있습니다.

00:18:25.000 --> 00:18:37.000
출시 시간을 보면 지난 16개 버전에서 내 앱의 평균 "첫 번째 프레임 시간"이 얼마인지 알 수 있으므로, 새로운 기능이 추가되기 전에 얼마나 빨랐는지 알 수 있습니다.

00:18:37.000 --> 00:18:47.000
나는 또한 종료 창으로 가서 시작하는 데 걸리는 시간 때문에 내 앱이 시스템에 의해 얼마나 자주 종료되는지 볼 수 있다.

00:18:47.000 --> 00:18:56.000
주최자를 본 후, 이것은 실제로 내 새로운 기능과 함께 도입된 꽤 나쁜 버그인 것처럼 보이며, 많은 사용자를 강타하고 있다.

00:18:56.000 --> 00:19:00.000
내가 이걸 어떻게 고칠 수 있는지 살펴보자.

00:19:00.000 --> 00:19:07.000
Instruments의 앱 실행 템플릿을 사용하여 앱의 실행 시간을 프로파일링하여 책상에서 이 문제를 테스트할 수 있습니다.

00:19:07.000 --> 00:19:21.000
이 템플릿은 내 앱을 5초 동안 실행하며, 그 동안 앱이 실행되는 동안 무슨 일이 있었는지에 대한 시간 프로필과 스레드 상태 추적을 수집하므로 스레드가 차단된 이유를 파악하고 수정할 수 있습니다.

00:19:21.000 --> 00:19:31.000
또한 이전에 본 것과 유사한 측정 블록에서 XCTApplicationsLaunchMetric을 사용하여 성능 XCTest의 출시 시간을 측정할 수 있습니다.

00:19:31.000 --> 00:19:41.000
내 앱에 구현된 MetricKit으로 나만의 분석을 하고 싶다면, 기본적으로 일일 메트릭 페이로드의 일부로 종료 원격 측정을 받게 될 것이다.

00:19:41.000 --> 00:19:51.000
앱이 종료될 때 데이터 손실을 피하기 위한 상태 복원에 대한 자세한 내용은 "내 앱이 왜 죽나요?"를 확인하세요. 2020년부터 얘기해.

00:19:51.000 --> 00:19:53.000
야호, 우리가 해냈어.

00:19:53.000 --> 00:19:56.000
우리는 여행을 마무리하기 전에 마지막 정류장에 있다.

00:19:56.000 --> 00:19:59.000
우리의 마지막 정거장은 기억이다.

00:19:59.000 --> 00:20:04.000
메모리는 앱, OS 및 커널 간의 공유 자원이다.

00:20:04.000 --> 00:20:17.000
앱이 메모리 제한을 초과하면 시스템에 의해 종료되며, 다음에 사용자가 시작할 때 처음부터 실행되며, 이는 백그라운드 실행 상태에서 재개하는 것보다 훨씬 더 오래 걸립니다.

00:20:17.000 --> 00:20:26.000
내 앱의 새로운 기능을 통해 개발자들은 식사에 사진과 설명을 추가할 수 있으며, 이는 메모리 사용이 조금 높아질 가능성이 있다는 것을 의미합니다.

00:20:26.000 --> 00:20:39.000
이런 일이 발생하면, 내 앱이 메모리 제한을 초과하여 종료될 가능성이 있으므로, 그렇지 않은지 확인하기 위해 주최자의 메모리 및 종료 메트릭을 주시해야 합니다.

00:20:39.000 --> 00:20:51.000
종료되지 않은 것처럼 보이지만, 주최자의 서스펜션 차트에서 피크 메모리와 메모리에 따르면, 이 새로운 버전의 내 앱에서 메모리 사용량이 크게 급증하고 있다.

00:20:51.000 --> 00:20:59.000
인스트루먼트의 누출, 할당 및 VM 트래커 템플릿을 사용하여 앱의 메모리 사용을 프로파일링할 수 있습니다.

00:20:59.000 --> 00:21:04.000
누출은 내 프로세스의 힙을 검사하고 유출된 메모리를 확인할 것이다.

00:21:04.000 --> 00:21:08.000
할당은 내 앱의 메모리 수명 주기를 분석할 것이다.

00:21:08.000 --> 00:21:13.000
그리고 VM 트래커는 시간이 지남에 따라 내 앱의 가상 메모리 공간을 보여줄 것이다.

00:21:13.000 --> 00:21:18.000
나는 또한 MetricKit을 사용하여 동일한 정보를 얻고 그것에 대한 내 분석을 실행할 수 있다.

00:21:18.000 --> 00:21:33.000
종료 및 메모리 원격 측정을 포함하는 일일 메트릭 페이로드를 사용하는 것 외에도 중요한 코드 섹션을 중심으로 MXSignposts를 계측하여 메모리 사용에 대한 더 세분화된 원격 측정을 캡처할 수 있습니다.

00:21:33.000 --> 00:21:44.000
애플리케이션에 적용되기 전에 메모리 회귀를 해결하는 방법을 감지하고 이해하는 방법에 대해 자세히 알아보려면, 올해 "메모리 문제 감지 및 진단" 강연을 확인하세요.

00:21:44.000 --> 00:21:51.000
내가 너를 보내기 전에, 우리가 오늘 여기서 본 것을 마무리하고 다음 단계를 살펴봅시다.

00:21:51.000 --> 00:21:56.000
우리는 성능 최적화를 식별하는 것이 얼마나 어려운지 이해합니다.

00:21:56.000 --> 00:22:05.000
지난 몇 년 동안, 개발자들은 중요한 성능 최적화를 위해 우리가 제공하는 것과 동일한 도구를 사용했습니다.

00:22:05.000 --> 00:22:11.000
좋은 예는 수백만 명의 사람들이 매일 사용하는 앱인 스냅챗이다.

00:22:11.000 --> 00:22:19.000
스냅챗은 앱의 출시 경험을 개선하고 종료를 추진하기 위해 오랫동안 헌신해 왔다.

00:22:19.000 --> 00:22:25.000
작년에, 우리는 Snapchat의 바람직하지 않은 종료가 99% 감소한 것을 보았다.

00:22:25.000 --> 00:22:34.000
우리는 그것이 믿을 수 없다고 생각하며, 오늘 여기서 논의한 성능 도구와 데이터를 사용하면 당신도 이것을 달성할 수 있습니다.

00:22:34.000 --> 00:22:55.000
성능 도구를 처음 사용하는 경우, 잠시 시간을 내어 2020년의 "Xcode Organizer로 성능 문제 진단" 및 "MetricKit의 새로운 기능" 강연, 2020년의 "Identify Trends with the Power and Performance API" 강연 및 2019년의 "Getting Started with Instruments" 강연을 확인하는 것이 좋습니다.

00:22:55.000 --> 00:23:04.000
이러한 모든 메트릭과 도구를 살펴본 후, 우리는 당신이 App Store에서 가장 성능이 뛰어난 앱을 출시하는 데 필요한 리소스를 잘 갖추고 있기를 바랍니다.

00:23:04.000 --> 00:23:09.000
당신의 사용자들은 원활한 사용자 경험을 즐기기 때문에 이것에 대해 감사할 것입니다.

00:23:09.000 --> 00:23:22.000
여기에 많은 자료가 있었기 때문에, 재미있는 운동으로 Xcode Organizer를 사용하여 앱 성능에 대한 트렌드 데이터를 보는 것이 좋습니다.

00:23:22.000 --> 00:23:26.000
악기에서 제공되는 다양한 템플릿을 탐색하고 연주하세요.

00:23:26.000 --> 00:23:32.000
XCTests가 출시되기 전에 문제를 파악하기 위해 XCTests를 작성하도록 도전하세요.

00:23:32.000 --> 00:23:37.000
그리고 MetricKit으로 분석 범위를 넓히세요.

00:23:37.000 --> 00:23:47.000
성능을 최적화할 때 우리의 도구가 제공해야 하는 것이 너무 많기 때문에, 손을 더럽히고 함께 제공되는 모든 것을 탐구하는 것을 주저하지 마세요.

00:23:47.000 --> 00:23:54.000
오늘 여행에 함께 해주셔서 감사드리며, 올해 컨퍼런스에서 멋진 시간을 보내시길 바랍니다.

00:23:54.000 --> 23:59:59.000
[쾌활한 음악].

