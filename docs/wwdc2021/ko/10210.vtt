WEBVTT

00:00:00.000 --> 00:00:05.000
♪ 베이스 음악 연주 ♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:14.000
Jake Petroules: 안녕하세요, "Xcode에서 고급 프로젝트 구성 탐색"에 오신 것을 환영합니다.

00:00:14.000 --> 00:00:22.000
저는 제이크이고, 제 동료 프라치와 함께 Xcode 프로젝트의 빌드 구성을 최대한 활용하기 위한 전략과 기술에 대해 논의할 것입니다.

00:00:22.000 --> 00:00:26.000
우리는 세 가지 주요 주제 영역을 다룰 것이다.

00:00:26.000 --> 00:00:34.000
먼저, Prachi는 멀티플랫폼 프로젝트와 멀티플랫폼 프레임워크 목표에 대한 Xcode 13의 새로운 지원에 대해 논의할 것이다.

00:00:34.000 --> 00:00:44.000
다음으로, 계획, 대상 설정 및 종속성 관리를 통해 프로젝트를 모델링하고 구성하기 위한 모범 사례를 다루고, 단계와 규칙을 구축할 것입니다.

00:00:44.000 --> 00:00:57.000
그리고 마지막으로, Prachi는 빌드 설정에 대해 자세히 알아볼 것이며, 여기서 구조와 동작, 프로젝트 편집기 UI, 구성 설정 파일 및 구문 등을 다룰 것입니다!

00:00:57.000 --> 00:01:04.000
이 강연을 통해, 우리는 Fruta라는 멀티 플랫폼 앱 프로젝트를 사용하여 이러한 기술이 실제 프로젝트에 어떻게 적용되는지 보여줄 것입니다.

00:01:04.000 --> 00:01:09.000
그리고 이제 나는 그것을 멀티플랫폼 프레임워크에 대해 이야기할 프라치에게 넘길 것이다.

00:01:09.000 --> 00:01:10.000
프라치 파이 아스노드카르: 고마워, 제이크.

00:01:10.000 --> 00:01:16.000
Xcode 13의 새로운 기능 중 하나는 멀티플랫폼 프레임워크를 지원하는 것이다.

00:01:16.000 --> 00:01:30.000
멀티플랫폼 프레임워크를 사용하면 여러 프레임워크를 하나로 통합하여 단순화된 대상 관리, 관리할 한 세트의 빌드 단계 및 관리할 한 세트의 빌드 설정을 제공합니다.

00:01:30.000 --> 00:01:35.000
Fruta 앱을 살펴보고 이 기능을 활용하기 위해 프로젝트를 업데이트합시다.

00:01:35.000 --> 00:01:37.000
이건 프루타 앱이야.

00:01:37.000 --> 00:01:43.000
macOS, iOS 및 watchOS용으로 빌드되는 멀티플랫폼 앱입니다.

00:01:43.000 --> 00:01:51.000
또한 세 가지 프레임워크 목표가 있습니다. 앱에서 사용하는 공유 코드 세트를 포함하는 각 플랫폼에 하나씩 있습니다.

00:01:51.000 --> 00:02:04.000
세 개의 별도의 프레임워크를 유지하면 빌드 설정을 동기화하고 모든 소스 파일이 컴파일 소스 빌드 단계에 적절하게 추가되도록 하는 것과 같은 문제가 있을 수 있습니다.

00:02:04.000 --> 00:02:12.000
이러한 문제를 해결하기 위해, 우리는 프레임워크 중 하나를 멀티플랫폼 프레임워크로 변환하는 것으로 시작할 것입니다.

00:02:12.000 --> 00:02:17.000
여기에 세 가지 프레임워크가 있습니다 - 각 플랫폼에 하나씩 있습니다.

00:02:17.000 --> 00:02:24.000
이 모든 대상은 macOS에서만 빌드되는 파일이 있다는 점을 제외하고는 동일합니다.

00:02:24.000 --> 00:02:34.000
먼저, macOS 프레임워크 대상에 대한 프로젝트 네비게이터의 빌드 설정 탭으로 이동해 봅시다.

00:02:34.000 --> 00:02:43.000
다음으로, 우리는 지원되는 플랫폼 빌드 설정으로 이동하여 모든 플랫폼을 선택하여 모든 플랫폼에 대해 빌드할 프레임워크를 구성할 것입니다.

00:02:43.000 --> 00:02:49.000
또한 멀티플랫폼 빌드 허용이 자동으로 "예"로 설정된 것을 볼 수 있습니다.

00:02:49.000 --> 00:02:56.000
이것은 필요에 따라 지원되는 각 플랫폼에 대해 이 목표를 한 번 구축하기 위해 빌드 시스템을 알려줍니다.

00:02:56.000 --> 00:03:06.000
이제 이것이 멀티 플랫폼 대상이기 때문에, 원래 macOS 프레임워크에는 macOS용으로 빌드할 때만 빌드해야 하는 하나의 추가 파일이 있었다는 것을 기억하세요.

00:03:06.000 --> 00:03:14.000
이를 위해 프레임워크를 구성하기 위해, 우리는 이 파일이 macOS용으로만 빌드되어야 한다고 지정하는 플랫폼 필터를 추가할 수 있습니다.

00:03:14.000 --> 00:03:19.000
이것을 하기 위해, 우리는 먼저 빌드 단계 탭으로 갈 것이다.

00:03:19.000 --> 00:03:23.000
다음으로, 컴파일 소스 빌드 단계를 확장하세요.

00:03:23.000 --> 00:03:36.000
마지막으로, 필터 항목을 클릭하고 macOS를 제외한 모든 것을 선택 해제하여 macOS 전용 빌드하도록 Ingredient+macOS.swift를 구성하십시오.

00:03:36.000 --> 00:03:47.000
이제 새로운 멀티플랫폼 대상을 구성했으므로, 더 이상 필요하지 않기 때문에 프레임워크의 다른 두 가지 변형을 삭제할 수 있습니다.

00:03:47.000 --> 00:03:56.000
또한, 우리는 하나의 프레임워크 대상만 가지고 있기 때문에, 새로운 대상을 연결하고 포함하도록 모든 앱을 구성해야 합니다.

00:03:56.000 --> 00:04:03.000
macOS 앱의 시작부터 멀티 플랫폼 대상을 설정했기 때문에 macOS 앱은 이미 구성되어 있습니다.

00:04:03.000 --> 00:04:20.000
각 앱 대상에 대한 일반 탭으로 이동하여 프레임워크 및 라이브러리 빌드 단계에 프레임워크를 추가하여 iOS 및 watchOS 앱에 새로운 프레임워크를 추가할 수 있습니다.

00:04:20.000 --> 00:04:27.000
요약하자면: 우리는 macOS 프레임워크 목표를 iOS와 watchOS용으로 구축할 수 있도록 했습니다.

00:04:27.000 --> 00:04:32.000
우리는 macOS 전용 소스 파일을 위한 플랫폼 필터로 프레임워크를 사용자 정의했습니다.

00:04:32.000 --> 00:04:39.000
그리고 마지막으로, 우리는 새로운 단일 멀티플랫폼 프레임워크 대상을 연결하고 포함하도록 앱 대상을 구성했습니다.

00:04:39.000 --> 00:04:42.000
그리고 그것은 Xcode의 멀티플랫폼 타겟이다.

00:04:42.000 --> 00:04:47.000
이제 프로젝트 구성에 대해 더 깊이 파고들게 될 제이크로 돌아가자.

00:04:47.000 --> 00:04:48.000
제이크: 고마워, 프라치.

00:04:48.000 --> 00:04:59.000
Xcode 프로젝트를 모델링하고 구성하기 위한 모범 사례에 대해 논의하고, 빌드의 성능과 정확성을 개선하기 위해 할 수 있는 몇 가지 사항을 보여드리겠습니다.

00:04:59.000 --> 00:05:02.000
먼저, 계획에 대한 빌드 옵션을 살펴봅시다.

00:05:02.000 --> 00:05:08.000
계획 선택기, 계획 편집을 클릭한 다음 빌드 섹션으로 이동합니다.

00:05:08.000 --> 00:05:10.000
내가 여기서 구성할 수 있는 몇 가지 간단한 것들이 있다.

00:05:10.000 --> 00:05:19.000
빌드 순서의 경우, 종속성 그래프에 따라 프로젝트의 대상이 병렬로 구축될 수 있는 종속성 순서를 선택하는 것이 좋습니다.

00:05:19.000 --> 00:05:25.000
이것은 멀티코어 빌드 성능을 크게 향상시킬 수 있으며 지속적인 통합으로 더 빠른 결과를 얻을 수 있습니다.

00:05:25.000 --> 00:05:30.000
대조적으로, 수동 주문을 선택하는 것은 더 이상 사용되지 않으며 권장되지 않습니다.

00:05:30.000 --> 00:05:39.000
이 옵션을 사용하면 빌드 속도가 느려지고 계획에 나열된 대상 순서가 프로젝트의 종속성과 일치하지 않을 때 주기 오류가 발생할 수 있습니다.

00:05:39.000 --> 00:05:44.000
계획 빌드 옵션의 또 다른 중요한 설정은 암시적 종속성 찾기이다.

00:05:44.000 --> 00:05:56.000
이 옵션을 선택하면 Xcode는 빌드 설정의 링커 플래그와 빌드 단계의 연결된 라이브러리 이름과 같은 프로젝트의 정보를 기반으로 대상 간의 종속성을 자동으로 추가할 수 있습니다.

00:05:56.000 --> 00:06:04.000
이것은 관련 대상이 일반적으로 명시적인 대상 종속성을 추가할 수 없는 다른 프로젝트에 있을 때 특히 유용할 수 있습니다.

00:06:04.000 --> 00:06:19.000
다른 프로젝트에서 명시적 대상 종속성을 추가할 수 없기 때문에 수동 종속성 순서를 사용하여 특정 순서로 대상을 구축하는 경우, 종속성 순서 선택과 함께 암시적 종속성 찾기를 활성화하는 것이 종종 더 나은 해결책입니다.

00:06:19.000 --> 00:06:22.000
이제 나는 스크립트 단계에 대해 이야기하고 규칙을 만들 것이다.

00:06:22.000 --> 00:06:29.000
프로젝트의 대상 목록에서 SmoothieKit 대상을 선택한 다음, 빌드 단계 탭을 선택합니다.

00:06:29.000 --> 00:06:34.000
여기에 사용자 지정 빌드 로직이 포함된 프로세스 레시피 스크립트 단계가 있습니다.

00:06:34.000 --> 00:06:42.000
그 책임 중 하나는 우리가 순서대로 처리하는 입력당 하나의 출력으로 여러 레시피 파일에서 코드를 생성하는 것이다.

00:06:42.000 --> 00:06:47.000
이제, 당신은 이러한 계산이 서로 완전히 독립적이라는 것을 깨달을 수 있습니다.

00:06:47.000 --> 00:06:54.000
이것은 우리가 그것들을 병렬로 실행함으로써 활용할 수 있는 성능 최적화 기회를 제공한다.

00:06:54.000 --> 00:06:57.000
규칙을 세우는 것은 우리가 그것을 할 수 있게 해준다.

00:06:57.000 --> 00:07:01.000
이 작업을 빌드 규칙으로 추출할 수 있는 방법을 살펴봅시다.

00:07:01.000 --> 00:07:08.000
프레임워크에 대한 프로젝트 편집기의 빌드 규칙 탭으로 이동하여 더하기 버튼을 클릭하여 새 빌드 규칙을 추가할 것입니다.

00:07:08.000 --> 00:07:16.000
그런 다음 이 규칙이 처리하기를 원하는 파일 형식의 파일 확장자에 해당하는 파일 패턴 "*.recipe"를 입력하십시오.

00:07:16.000 --> 00:07:19.000
다음으로, 나는 이 규칙에 종속성을 추가할 것이다.

00:07:19.000 --> 00:07:26.000
입력으로 처리하는 각 입력 파일을 자동으로 받기 때문에 빌드 규칙에 추가 입력을 추가할 필요가 없습니다.

00:07:26.000 --> 00:07:33.000
그러나, 나는 빌드 시스템에 규칙이 처리하는 각 파일에 대해 생성할 출력 파일의 경로를 말해야 한다.

00:07:33.000 --> 00:07:41.000
더하기 버튼을 클릭하여 새 출력 파일을 추가하고 $(DERIVED_ FILE_ DIR)/$ (INPUT_ FILE _BASE) .compiledrecipe를 입력하겠습니다.

00:07:41.000 --> 00:07:49.000
빌드 시스템에서 관리하는 적절한 위치를 가리키기 때문에 생성된 파일을 DERIVED_FILE_DIR로 작성하는 것이 가장 좋습니다.

00:07:49.000 --> 00:07:52.000
소스 루트에서 출력 파일을 생성하는 것을 피해야 합니다.

00:07:52.000 --> 00:07:58.000
이것은 소스 제어를 방해하고 여러 빌드를 동시에 실행할 때 충돌로 이어질 수 있습니다.

00:07:58.000 --> 00:08:03.000
이제, 물론, 우리는 스크립트 단계 코드를 규칙에 복사해야 합니다.

00:08:03.000 --> 00:08:10.000
나는 스크립트 단계로 돌아가서 각 파일을 처리한 코드를 복사할 것이다.

00:08:10.000 --> 00:08:15.000
그럼 내가 규칙으로 돌아가서 그걸 붙여넣을게.

00:08:15.000 --> 00:08:18.000
규칙은 그들이 처리하는 각 입력에 대해 한 번 실행된다는 것을 기억하세요.

00:08:18.000 --> 00:08:37.000
그래서 나는 for 루프를 제거하고, $RECIPE를 처리 중인 현재 입력 파일의 절대 파일 경로에 해당하는 $SCRIPT_INPUT_FILE로 바꾸고, $DERIVED_FILE_DIR/ $RECIPE.compiledrecipe를 아래의 출력 파일 섹션에 입력한 출력 파일 경로를 참조하는 $SCRIPT_OUTPUT_FILE_0으로

00:08:37.000 --> 00:08:44.000
파일 경로의 공백과 다른 특수 문자가 올바르게 처리되도록 변수를 인용하는 것을 잊지 마세요.

00:08:44.000 --> 00:08:45.000
좋아.

00:08:45.000 --> 00:08:47.000
이제 규칙에 구성해야 할 것이 하나 더 있다.

00:08:47.000 --> 00:08:52.000
나는 규칙이 그들이 처리하는 각 입력에 대해 한 번 실행된다고 언급했다.

00:08:52.000 --> 00:08:57.000
기본적으로, 그들은 또한 대상이 컴파일하고 있는 각 아키텍처에 대해 한 번 실행된다.

00:08:57.000 --> 00:09:06.000
예를 들어, Mac 앱 대상의 규칙은 arm64에 대해 한 번 실행되고 x86_64에 대해 각 입력에 대해 한 번 실행될 수 있습니다.

00:09:06.000 --> 00:09:11.000
따라서 네 개의 입력과 두 개의 아키텍처가 있다면, 그 규칙은 여덟 번 호출될 것이다.

00:09:11.000 --> 00:09:16.000
이것은 규칙의 출력이 객체 코드와 같은 아키텍처에 의존적일 때 유용하다.

00:09:16.000 --> 00:09:28.000
그러나, 이 경우, 내 규칙은 기본 CPU 아키텍처와 독립적인 출력을 생성하므로, "아크 아키텍처당 한 번 실행"을 선택 해제할 것이다.

00:09:28.000 --> 00:09:39.000
마지막으로, 빌드 시스템이 입력 파일을 빌드 규칙으로 전파하려면, 모든 .recipe 파일을 프레임워크 대상의 컴파일 소스 빌드 단계에 추가해야 합니다.

00:09:39.000 --> 00:09:51.000
빌드 단계로 돌아가서, 소스 컴파일을 확장하고, 더하기 버튼을 사용하여 레시피 파일을 추가할 것입니다.

00:09:51.000 --> 00:09:53.000
이제 대본 단계로 돌아가자.

00:09:53.000 --> 00:10:02.000
나머지 작업은 여러 텍스트 파일의 내용을 앱에서 런타임에 더 효율적으로 로드할 수 있는 단일 파일로 병합하는 것입니다.

00:10:02.000 --> 00:10:11.000
그리고 더 나은 소스 제어 경험을 위해, 저는 프로젝트 파일 외부에 스크립트를 보관하고 여기 인라인 스크립트 편집기에서 호출하고 있습니다.

00:10:11.000 --> 00:10:16.000
그러니 코드를 보려면 package.sh에 대한 참조를 따라가자.

00:10:16.000 --> 00:10:24.000
이 경우 빌드 규칙은 적절하지 않을 것입니다. 왜냐하면 우리는 그것들을 하나로 결합하기 위해 모든 입력을 한 번에 처리해야 하기 때문입니다.

00:10:24.000 --> 00:10:32.000
따라서 병렬로 실행할 수 있는 격리된 장치로 나눌 방법이 없으므로 스크립트 단계에서 이 작업을 유지하는 것이 합리적입니다.

00:10:32.000 --> 00:10:39.000
하지만 이것은 우리를 가장 중요한 교훈 중 하나로 이끈다: 스크립트에는 입력 및 출력 종속성이 지정되어 있지 않다.

00:10:39.000 --> 00:10:52.000
이것은 빌드 작업이 잘못된 순서로 실행되고 빌드 속도가 느려질 수 있습니다. 왜냐하면 Xcode는 스크립트 단계에서 어떤 파일을 사용할 수 있는지 모르기 때문에 다른 작업을 병렬로 실행하는 것과 관련하여 더 보수적이어야 하기 때문입니다.

00:10:52.000 --> 00:11:03.000
따라서 스크립트 단계에서 수행되는 작업이 빌드의 다른 작업에 비해 올바른 순서로 수행되도록 입력 및 출력 종속성을 추가하는 것이 중요합니다.

00:11:03.000 --> 00:11:06.000
이 특정 스크립트에 대해, 나는 많은 입력을 가지고 있다.

00:11:06.000 --> 00:11:16.000
프로젝트 파일에 하나씩 입력하는 대신, xcfilelist를 사용하여 외부 파일을 통해 이 입력 목록을 관리할 수 있습니다.

00:11:16.000 --> 00:11:19.000
내가 지금 가서 프로젝트에 하나 추가할게.

00:11:19.000 --> 00:11:28.000
파일 &gt; 새 파일로 이동하여 기타 섹션에서 단계 파일 목록 빌드를 선택합니다.

00:11:28.000 --> 00:11:34.000
이 스크립트 단계에서 처리될 입력 파일 목록을 한 줄에 하나씩 붙여넣을 것입니다.

00:11:34.000 --> 00:11:41.000
원한다면, 파운드 기호로 줄을 시작하여 댓글을 쓸 수도 있으며, 이는 추가 컨텍스트를 추가하는 데 좋습니다.

00:11:41.000 --> 00:11:46.000
이제 스크립트 단계에서 이 xcfilelist를 참조하겠습니다.

00:11:46.000 --> 00:11:52.000
스크립트 단계로 돌아가서 입력 파일 목록에서 xcfilelist의 경로를 지정하겠습니다.

00:11:52.000 --> 00:12:06.000
마지막으로, 빌드 규칙에 대해 했던 것처럼 출력 내용이 기록될 파일 경로를 제공하여 출력 종속성을 지정할 것입니다.

00:12:06.000 --> 00:12:13.000
언급할 게 하나 더 있어.

00:12:13.000 --> 00:12:18.000
빌드 규칙과 마찬가지로, 스크립트 단계에서 제공되는 몇 가지 중요한 환경 변수가 있습니다.

00:12:18.000 --> 00:12:23.000
더 자세히 살펴보기 위해 package.sh로 다시 이동합시다.

00:12:23.000 --> 00:12:49.000
소스에서, 저는 SCRIPT_INPUT_FILE_LIST_COUNT를 참조합니다; 이는 스크립트 단계에 전달된 입력 파일 목록의 총 수를 나타냅니다, SCRIPT_INPUT_FILE_LIST_n; n번째 인덱스에서 입력 파일 목록의 해결된 절대 파일 경로를 참조하며, SCRIPT_OUTPUT_FILE_0; 첫 번째 --

00:12:49.000 --> 00:12:54.000
다음은 스크립트 단계에 제공되는 몇 가지 주요 환경 변수에 대한 개요입니다.

00:12:54.000 --> 00:12:59.000
대상의 빌드 설정은 스크립트 단계 환경에서도 사용할 수 있습니다.

00:12:59.000 --> 00:13:06.000
다음은 규칙을 구축하는 데 특정한 몇 가지 환경 변수와 덜 일반적인 변수에 대한 개요입니다.

00:13:06.000 --> 00:13:12.000
스크립트 단계와 마찬가지로, 대상의 빌드 설정도 빌드 규칙 환경에서 사용할 수 있습니다.

00:13:12.000 --> 00:13:23.000
좋아. 이제, 내가 그 프로젝트를 만들려고 하면, 문제가 발생할 거야.

00:13:23.000 --> 00:13:27.000
빌드 로그로 가서 자세히 살펴봅시다.

00:13:27.000 --> 00:13:40.000
SmoothieKit은 멀티플랫폼 대상이기 때문에, iOS용으로 한 번, watchOS용으로 한 번 두 번 구축되고 있으며, 이는 각 빌드가 동일한 경로에서 스크립트 단계의 출력을 생성하려고 한다는 것을 의미합니다.

00:13:40.000 --> 00:13:48.000
빌드 시스템은 전체 빌드에서 하나의 작업만 주어진 경로에서 출력을 생성할 수 있기 때문에 이것은 허용되지 않습니다.

00:13:48.000 --> 00:13:51.000
내가 이것을 해결할 수 있는 몇 가지 다른 방법이 있다.

00:13:51.000 --> 00:13:58.000
한 가지 간단한 해결책은 대상이 구축될 때마다 고유하도록 스크립트 단계의 출력 경로를 변경하는 것입니다.

00:13:58.000 --> 00:14:07.000
이 경우, 나는 플랫폼에 특화된 DERIVED_FILE_DIR과 같은 다른 빌드 설정을 사용하는 것을 고려할 수 있으며, 경로를 충분히 독특하게 만들고 충돌을 해결할 수 있다.

00:14:07.000 --> 00:14:17.000
그러나, 스크립트 단계가 수행하는 실제 작업이 각 대상의 맥락에서 동일하다면, 그것은 단순히 동일한 작업을 두 번 수행하게 할 것이다.

00:14:17.000 --> 00:14:26.000
이 경우, 스크립트 단계를 공유 프레임워크 대상이 의존하는 새로운 집계 대상으로 이동하는 것이 더 나은 옵션이 될 수 있습니다.

00:14:26.000 --> 00:14:28.000
그게 내가 내 프로젝트를 위해 할 일이야.

00:14:28.000 --> 00:14:38.000
시작하려면, 대상 목록 하단의 더하기 버튼을 클릭하고, 기타 탭을 선택한 다음, 대상 집계를 선택합니다.

00:14:38.000 --> 00:14:42.000
난 그걸 자원이라고 부를 거야.

00:14:42.000 --> 00:15:06.000
그런 다음 새로운 스크립트 단계를 추가하고 프레임워크 대상에서 이름, 스크립트 소스, 입력 및 출력을 복사할 것입니다.

00:15:06.000 --> 00:15:19.000
마지막으로, 프레임워크 대상에서 원래 스크립트 단계를 삭제한 다음 새로운 집계 대상에 대한 대상 종속성을 추가할 것입니다.

00:15:19.000 --> 00:15:34.000
이렇게 하면, 작업은 한 번만 완료되고, 출력 파일 충돌이 없으며, 프레임워크의 iOS와 watchOS 변형은 모두 해당 스크립트 단계에 비해 올바른 순서로 구축될 것입니다.

00:15:34.000 --> 00:15:37.000
성공적으로 구축하세요.

00:15:37.000 --> 00:15:41.000
그리고 이제, 프라치로 돌아가서, 누가 당신에게 빌드 설정에 대한 모든 것을 말해줄 것입니다.

00:15:41.000 --> 00:15:43.000
프라치: 고마워, 제이크!

00:15:43.000 --> 00:15:45.000
그래서 빌드 설정이 뭐야?

00:15:45.000 --> 00:15:52.000
Xcode 대상에 적용하여 구축 방법의 측면을 구성할 수 있는 속성입니다.

00:15:52.000 --> 00:15:57.000
Xcode는 빌드 설정을 구성하기 위한 두 가지 주요 메커니즘을 제공합니다.

00:15:57.000 --> 00:16:00.000
첫 번째는 빌드 설정 편집기를 통해서이다.

00:16:00.000 --> 00:16:06.000
두 번째는 구성 설정 파일이나 .xcconfig 파일을 통한 것이다.

00:16:06.000 --> 00:16:14.000
빌드 설정 편집기를 사용하여 프로젝트 내에서 설정을 관리하는 방법을 보는 것으로 시작합시다.

00:16:14.000 --> 00:16:21.000
빌드 설정 편집기를 불러올려면, 먼저 프로젝트 네비게이터에서 프로젝트를 선택해야 합니다.

00:16:21.000 --> 00:16:26.000
다음으로, 구성하려는 대상을 선택하세요.

00:16:26.000 --> 00:16:32.000
그리고 마지막으로, 탭 바에서 빌드 설정 탭을 클릭하세요.

00:16:32.000 --> 00:16:37.000
여기에서 새 빌드 설정을 추가하거나 기존 설정을 수정할 수 있습니다.

00:16:37.000 --> 00:16:46.000
빠른 도움말 관리자를 열어 선택한 빌드 설정에 대한 추가 정보를 찾을 수도 있습니다.

00:16:46.000 --> 00:16:49.000
빌드 설정은 여러 수준에서 정의됩니다.

00:16:49.000 --> 00:16:52.000
당신은 이것을 정의의 더미로 생각할 수 있습니다.

00:16:52.000 --> 00:16:59.000
사실, 이 레벨들은 레벨 필터를 클릭하여 시각화할 수 있습니다.

00:16:59.000 --> 00:17:08.000
각 열은 빌드 설정을 정의할 수 있는 다른 수준을 나타내며, 오른쪽에서 왼쪽으로 평가됩니다.

00:17:08.000 --> 00:17:35.000
가장 낮은 수준에서 시작하여 현재 선택된 SDK, 프로젝트 수준 구성 설정 파일, Xcode 프로젝트 파일의 프로젝트 수준 설정, 구성 설정 파일에 정의된 대상 설정, Xcode 프로젝트 파일에 정의된 대상 수준 설정, 그리고 마지막으로 빌드 설정의 해결된 값으로 정의되는 기본값이 있습니다.

00:17:35.000 --> 00:17:43.000
레벨에 빌드 설정에 대한 명시적인 값이 있음을 나타내는 굵은 설정이 보이면 유의하십시오.

00:17:43.000 --> 00:17:52.000
Xcode가 빌드 설정을 관리하기 위해 제공하는 다른 메커니즘은 구성 설정 파일 또는 .xcconfig 파일입니다.

00:17:52.000 --> 00:18:12.000
Xcconfig 파일의 이점 중 일부는 다음과 같습니다: 더 나은 소스 제어 관리, 대상 또는 구성 간에 설정 공유, 빌드 설정의 고급 구성, 개발 또는 테스트 환경을 기반으로 추가 xcconfig 파일을 포함할 수 있는 기능.

00:18:12.000 --> 00:18:17.000
Xcconfig 파일에서 빌드 설정을 작성하는 방법을 살펴봅시다.

00:18:17.000 --> 00:18:27.000
가장 기본적인 수준에서, 빌드 설정은 이름, 할당 연산자 및 값으로 구성되어 있다.

00:18:27.000 --> 00:18:32.000
조건부 구문을 사용하여 빌드 설정의 값을 좁힐 수 있습니다.

00:18:32.000 --> 00:18:36.000
조건부 설정은 대괄호를 사용하여 정의됩니다.

00:18:36.000 --> 00:18:44.000
지원되는 조건 중 일부는 구성, 아키텍처 및 SDK를 포함합니다.

00:18:44.000 --> 00:18:51.000
SDK 조건과 같이, 와일드카드는 매칭 목적으로 사용될 수 있습니다.

00:18:51.000 --> 00:18:57.000
친숙한 더블 슬래시 구문을 사용하여 주석을 추가할 수도 있습니다.

00:18:57.000 --> 00:19:03.000
빌드 설정은 dollar-parens 구문을 사용하여 다른 빌드 설정의 값으로 설정할 수 있습니다.

00:19:03.000 --> 00:19:09.000
여기 예시에서, MY_OTHER_BUILD_SETTING은 YES로 설정되었습니다.

00:19:09.000 --> 00:19:16.000
MY_BUILD_SETTING_NAME의 값은 dollar-parens 구문을 사용하여 MY_OTHER_BUILD_SETTING을 평가합니다.

00:19:16.000 --> 00:19:22.000
MORE_SETTINGS에서 볼 수 있듯이, 여기에서도 여러 값을 평가할 수 있습니다.

00:19:22.000 --> 00:19:28.000
그리고 마지막으로, 빌드 설정의 기존 값은 $(상속) 값과 함께 사용할 수 있습니다.

00:19:28.000 --> 00:19:34.000
이를 통해 기존 값을 모두 유지하면서 빌드 설정에 추가 값을 추가할 수 있습니다.

00:19:34.000 --> 00:19:41.000
이것은 빌드 설정 이름인 APPEND_TO_EXISTING_SETTINGS를 사용할 수 있기 때문에 편리한 양식입니다.

00:19:41.000 --> 00:19:50.000
빌드 설정 평가 구문의 또 다른 사용은 다른 빌드 설정 세트에서 빌드 설정을 함께 구성하는 것입니다.

00:19:50.000 --> 00:19:55.000
먼저, 우리는 제어 설정으로 시작합니다: IS_BUILD_SETTING_ENABLED.

00:19:55.000 --> 00:20:04.000
우리는 이 설정의 값을 두 가지 추가 빌드 설정인 MY_BUILD_SETTING_NO와 MY_BUILD_SETTING_YES의 접미사로 사용할 것입니다.

00:20:04.000 --> 00:20:14.000
마지막으로, 우리는 MY_BUILD_SETTING을 MY_BUILD_SETTING과 IS_BUILD_SETTING_ENABLED로 구성된 값을 갖도록 정의합니다.

00:20:14.000 --> 00:20:24.000
빌드 설정 평가는 내부에서 발생하기 때문에, 가장 안쪽 설정이 평가되고 IS_BUILD_SETTING_ENABLED의 값인 NO를 반환합니다.

00:20:24.000 --> 00:20:33.000
마지막으로, 구성된 BUILD_SETTING_NO는 -use_this_one의 값으로 평가됩니다.

00:20:33.000 --> 00:20:41.000
빌드 설정을 평가할 때, 가치의 몇 가지 기본 변환을 제공하는 데 사용할 수 있는 연산자 세트가 있습니다.

00:20:41.000 --> 00:20:52.000
연산자의 세 가지 분류는 문자열 연산자, 경로 연산자 및 대체 연산자입니다.

00:20:52.000 --> 00:21:09.000
지원되는 문자열 연산자는 문자열 내의 문자를 이스케이프하는 따옴표, 문자의 대소문자를 변환하는 하단 및 상단, 그리고 문자열을 다양한 형식의 유효한 식별자로 변환하는 식별자입니다.

00:21:09.000 --> 00:21:20.000
우리는 디렉토리, 파일 이름, 기본 이름, 접미사 및 표준화된 경로를 얻기 위한 일련의 경로 연산자를 제공합니다.

00:21:20.000 --> 00:21:26.000
각 경로 운영자에 대해, 값의 일부를 교체할 수 있는 대체 대응이 있습니다.

00:21:26.000 --> 00:21:36.000
빌드 설정이 비어 있는 경우 대체 값을 제공하는 기본 연산자도 있으며, 그렇지 않으면 빌드 설정의 기존 값을 사용합니다.

00:21:36.000 --> 00:21:43.000
마지막으로 살펴봐야 할 항목은 다른 xcconfig 파일에 xcconfig 파일을 포함할 수 있는 기능입니다.

00:21:43.000 --> 00:21:45.000
당신이 사용할 수 있는 두 가지 메커니즘이 있습니다.

00:21:45.000 --> 00:21:51.000
첫 번째는 xcconfig 파일이 디스크에 존재해야 하는 필수 포함입니다.

00:21:51.000 --> 00:21:55.000
파일을 찾을 수 없으면 컴파일러 오류가 발생합니다.

00:21:55.000 --> 00:22:02.000
두 번째는 디스크에 있는 경우 xconfig 파일을 포함할 수 있는 선택적 포함이다.

00:22:02.000 --> 00:22:06.000
파일이 존재하지 않는다면 이것은 실패하지 않을 것이다.

00:22:06.000 --> 00:22:12.000
경로는 Xcode 프로젝트 파일의 위치와 상대적이라는 점에 유의하십시오.

00:22:12.000 --> 00:22:20.000
그래서 이 모든 정보를 실제 시나리오에서 어떻게 모을 수 있는지 살펴봅시다.

00:22:20.000 --> 00:22:25.000
이 예시에서, 우리는 다음 문제를 해결하는 방법을 살펴볼 것이다.

00:22:25.000 --> 00:22:32.000
우리의 개발 기계에서, 컴파일러는 입력 확인에 너무 오래 걸리는 표현식에 대해 공격적으로 경고해야 한다.

00:22:32.000 --> 00:22:39.000
그러나, CI 기계는 더 느리기 때문에, 표현 확인 시간을 늘려야 한다.

00:22:39.000 --> 00:22:48.000
우리의 솔루션을 위해, 세 가지 구성 설정 파일이 있습니다: 디버그, 커먼, 그리고 ci.xcconfig.

00:22:48.000 --> 00:22:59.000
디버그 xcconfig 파일은 디버그 빌드에 사용되며, OTHER_SWIFT_FLAGS 빌드 설정을 통해 스위프트 컴파일러에 추가 플래그를 전달합니다.

00:22:59.000 --> 00:23:04.000
일반적인 xcconfig 파일은 선택적으로 ci.xcconfig 파일을 포함합니다.

00:23:04.000 --> 00:23:09.000
또한 유형 표현식 경고를 제어하기 위해 OTHER_SWIFT_FLAGS 설정을 정의합니다.

00:23:09.000 --> 00:23:27.000
$(상속)를 사용하여 debug.xcconfig 파일 및 기본값이 200인 MAX _EXPRESSION_TIME의 빌드 설정 평가와 같은 다른 플래그 설정이 포함되도록 합니다.

00:23:27.000 --> 00:23:34.000
Ci xcconfig 파일은 MAX_EXPRESSION _TIME의 재정의 값을 정의합니다.

00:23:34.000 --> 00:23:42.000
마지막으로, Xcode는 이러한 xcconfig 파일을 지원되는 구성 수준 중 하나에 적용하는 방법을 알려야 합니다.

00:23:42.000 --> 00:23:47.000
이것은 우리가 여기서 볼 수 있는 프로젝트 편집기를 통해 이루어진다.

00:23:47.000 --> 00:23:59.000
구성 섹션에서 정의된 빌드 구성에 대해 프로젝트 또는 대상 수준에서 프로젝트의 구성 파일을 적용할 수 있습니다.

00:23:59.000 --> 00:24:08.000
여기서 debug.xcconfig 파일이 Fruta의 디버그 구성을 위해 프로젝트 수준에서 적용되는 것을 볼 수 있습니다.

00:24:08.000 --> 00:24:16.000
또한, common.xcconfig 파일은 프로젝트 내의 각 대상에 대해 설정됩니다.

00:24:16.000 --> 00:24:24.000
해결책을 요약하기 위해, 기본 연산자는 MAX_EXPRESSION_TIME의 기본값을 정의하는 데 사용되었다.

00:24:24.000 --> 00:24:30.000
Ci.xcconfig 파일은 CI 시스템에만 존재하기 때문에 선택적으로 포함되었다.

00:24:30.000 --> 00:24:37.000
그리고 MAX_EXPRESSION_TIME의 기본값 재정의가 ci xcconfig 파일에 사용되었다.

00:24:37.000 --> 00:24:40.000
이것은 우리의 실용적인 예를 마무리한다.

00:24:40.000 --> 00:24:44.000
이제 우리가 다룬 모든 것을 검토하기 위해 제이크에게 돌아가자.

00:24:44.000 --> 00:24:46.000
제이크: 고마워, 프라치.

00:24:46.000 --> 00:24:47.000
요약하자.

00:24:47.000 --> 00:24:55.000
당신은 멀티플랫폼 프레임워크와 멀티플랫폼 프로젝트에서 빌드 설정을 관리하고 단계를 구축하는 더 쉬운 방법을 제공하는 방법에 대해 배웠습니다.

00:24:55.000 --> 00:25:10.000
종속성 순서에 따라 병렬로 목표를 구축하여 프로젝트 구성을 개선하고 성능을 구축하는 방법, 빌드 규칙과 빌드 단계를 올바르게 사용하는 방법, 종속성 지정의 중요성을 보았습니다.

00:25:10.000 --> 00:25:21.000
마지막으로, 빌드 설정, 구성 설정 파일을 사용하여 더 쉽게 관리할 수 있는 방법에 대해 자세히 알아보고, 구문과 그것이 제공하는 모든 구성에 대해 자세히 살펴보겠습니다.

00:25:21.000 --> 00:25:28.000
우리는 이 수업들이 당신이 개발 경험을 최대한 활용하는 데 도움이 되는 유용한 도구 세트를 제공하기를 바랍니다.

00:25:28.000 --> 00:25:29.000
봐줘서 고마워!

00:25:29.000 --> 23:59:59.000
♪

