WEBVTT

00:00:02.000 --> 00:00:12.000
안녕하세요, 제 이름은 토니이고, 저는 재단 팀의 엔지니어입니다.

00:00:12.000 --> 00:00:19.000
"재단의 새로운 기능"에 오신 것을 환영합니다. 재단 프레임워크는 모든 앱과 프레임워크에 대한 기본 기능을 제공합니다.

00:00:19.000 --> 00:00:25.000
그것은 파일 처리에서 네트워킹 및 알림에 이르기까지 모든 것을 포함하여 많은 기능을 가지고 있습니다.

00:00:25.000 --> 00:00:31.000
오늘 저는 모든 앱에 필요한 것에 집중하고 싶습니다: 국제화와 현지화.

00:00:31.000 --> 00:00:36.000
올해 출시에서, 우리는 이 API에서 가장 큰 발전 중 일부를 가지고 있다.

00:00:36.000 --> 00:00:43.000
우리는 낮은 수준에서 시작했고, 스위프트에서 귀속된 문자열이 무엇인지 다시 생각했다.

00:00:43.000 --> 00:00:50.000
우리는 Swift용 포맷터를 재구성하여 더 빠르고, 사용하기 쉽고, 새로운 기능을 추가했습니다.

00:00:50.000 --> 00:00:55.000
그리고 마지막으로, 우리는 자동 문법 계약이라는 새로운 기능을 가지고 있다.

00:00:55.000 --> 00:01:02.000
그것은 당신이 제공해야 하는 현지화된 문자열의 수를 극적으로 줄이는 동시에 코드를 더 간단하게 만듭니다.

00:01:02.000 --> 00:01:05.000
귀속된 문자열로 바로 뛰어들자.

00:01:05.000 --> 00:01:12.000
귀속 문자열은 문자, 범위 집합 및 사전의 조합이다.

00:01:12.000 --> 00:01:20.000
속성 문자열을 사용하면 키-값 쌍인 속성을 문자열의 특정 범위에 연결할 수 있습니다.

00:01:20.000 --> 00:01:25.000
가장 일반적인 속성은 SDK에 의해 정의되지만, 자신만의 속성을 만들 수도 있습니다.

00:01:25.000 --> 00:01:30.000
리치 텍스트를 지원하는 API에서 속성 문자열을 종종 찾을 수 있습니다.

00:01:30.000 --> 00:01:32.000
예를 들어 봅시다.

00:01:32.000 --> 00:01:34.000
여기 제가 작업하고 있는 카페라는 앱이 있습니다.

00:01:34.000 --> 00:01:36.000
그건 간단한 메뉴야.

00:01:36.000 --> 00:01:42.000
나는 내가 원하는 음식, 크기, 양을 고른다.

00:01:42.000 --> 00:01:47.000
그리고 마지막에, 그것은 내가 주문한 모든 것의 목록이 있는 영수증을 보여준다.

00:01:47.000 --> 00:01:52.000
여기 하단에, 나는 짧은 감사 메모를 추가하기로 결정했다.

00:01:52.000 --> 00:01:54.000
이것은 귀속된 문자열이다.

00:01:54.000 --> 00:01:58.000
문자열의 일부는 굵게 표시되어 있고 일부는 이탤릭체로 되어 있다.

00:01:58.000 --> 00:02:00.000
마지막 단어에도 링크가 있다.

00:02:00.000 --> 00:02:04.000
여기서 알 수 있듯이, 속성은 겹칠 수 있습니다.

00:02:04.000 --> 00:02:09.000
재단이 시작된 이래로, 우리는 NSAttributedString이라는 참조 유형을 가지고 있었다.

00:02:09.000 --> 00:02:17.000
올해, 우리는 스위프트가 제공하는 모든 기능을 최대한 활용하는 새로운 구조체 AttributedString을 소개합니다.

00:02:17.000 --> 00:02:21.000
무엇보다도, 그것은 가치 유형이다.

00:02:21.000 --> 00:02:26.000
그것은 또한 스위프트 스트링과 같은 문자 계산 동작을 가지고 있다.

00:02:26.000 --> 00:02:34.000
포괄적인 소프트웨어를 쉽게 작성하기 위한 노력의 일환으로, AttributedString은 이제 완전히 현지화할 수 있습니다.

00:02:34.000 --> 00:02:37.000
마지막으로, 그것은 안전과 보안을 염두에 두고 만들어졌다.

00:02:37.000 --> 00:02:45.000
여기에는 강력한 타이핑을 사용하여 컴파일 시간 안전과 Codable을 사용하여 보관하지 않는 동안의 안전이 모두 포함됩니다.

00:02:45.000 --> 00:02:51.000
새로운 AttributedString으로 무엇을 할 수 있는지 간략하게 살펴봅시다.

00:02:51.000 --> 00:02:54.000
우리는 감사의 메시지를 만들 것입니다.

00:02:54.000 --> 00:02:58.000
먼저, 우리는 간단한 이니셜라이저를 사용하여 속성 문자열을 만듭니다.

00:02:58.000 --> 00:03:01.000
이 전체 문자열에 속성을 설정하고 싶습니다.

00:03:01.000 --> 00:03:03.000
그것은 글꼴 속성을 설정하는 것만큼 간단합니다.

00:03:03.000 --> 00:03:10.000
Struct AttributedString에서는 모든 속성을 직접 사용할 수 있으며 올바른 유형을 사용합니다.

00:03:10.000 --> 00:03:14.000
예를 들어, 이 속성은 SwiftUI 글꼴이다.

00:03:14.000 --> 00:03:17.000
다음으로, 우리는 또 다른 속성 문자열을 만듭니다.

00:03:17.000 --> 00:03:23.000
이것은 우리 웹사이트에 대한 참조이므로, 우리는 링크 속성을 URL로 설정했습니다.

00:03:23.000 --> 00:03:26.000
여기서 저는 전체 문자열에 글꼴과 링크를 설정하고 있습니다.

00:03:26.000 --> 00:03:30.000
우리는 나중에 문자열의 일부만 변경하는 방법을 살펴볼 것이다.

00:03:30.000 --> 00:03:33.000
또 다른 유용한 도구는 속성 컨테이너이다.

00:03:33.000 --> 00:03:38.000
문자열 없이 속성과 값을 자체적으로 유지할 수 있는 곳입니다.

00:03:38.000 --> 00:03:44.000
여기서, 저는 제 메시지의 중요성에 따라 컨테이너를 만들고 몇 가지 속성을 설정합니다.

00:03:44.000 --> 00:03:49.000
그리고 마지막으로, 나는 그 속성을 두 속성 문자열로 병합한다.

00:03:49.000 --> 00:03:55.000
내가 언급했듯이, 귀속 문자열은 문자, 범위 및 사전의 조합이다.

00:03:55.000 --> 00:03:59.000
귀속된 문자열 자체는 그러한 것들 중 하나의 모음이 아니다.

00:03:59.000 --> 00:04:05.000
대신, 이러한 속성에 접근하기 위해, 그것은 우리가 견해라고 부르는 것을 가지고 있다.

00:04:05.000 --> 00:04:12.000
가장 중요한 두 가지 견해는 문자열에 대한 액세스를 제공하는 문자와 속성에 대한 액세스를 제공하는 실행이다.

00:04:12.000 --> 00:04:20.000
이러한 뷰는 스위프트 컬렉션이며, 이는 배열과 같은 유형에서 익숙한 기능을 여기에서도 사용할 수 있음을 의미합니다.

00:04:20.000 --> 00:04:23.000
또 다른 예를 살펴봅시다.

00:04:23.000 --> 00:04:30.000
디자이너들이 우리에게 모든 구두점을 재미있는 오렌지색으로 만들어 감사 메시지에 약간의 피자를 추가하라고 말했다고 가정해 봅시다.

00:04:30.000 --> 00:04:35.000
이렇게 하려면, 먼저 귀속 문자열에서 구두점이 어디에 있는지 찾아야 합니다.

00:04:35.000 --> 00:04:43.000
다른 스위프트 컬렉션과 마찬가지로, 속성 문자열 뷰는 단순히 컬렉션의 일부 요소의 위치인 인덱스를 사용합니다.

00:04:43.000 --> 00:04:48.000
인덱스로 반복하기 위해, 나는 표준 라이브러리 인덱스 함수를 사용한다.

00:04:48.000 --> 00:04:55.000
다음으로, 저는 이 문자가 우리가 변경해야 하는 문자인지 확인하기 위해 isPunctuation 함수를 사용합니다.

00:04:55.000 --> 00:05:02.000
마지막으로, 나는 속성 문자열인 슬라이싱의 또 다른 기능을 사용하여 전체 문자열의 하위 범위에만 속성을 적용한다.

00:05:02.000 --> 00:05:09.000
범위는 이 인덱스에서 시작하여 그 이후의 다음 인덱스까지 계속되므로, 한 문자입니다.

00:05:09.000 --> 00:05:11.000
그리고 이제 구두점은 주황색이다.

00:05:11.000 --> 00:05:13.000
다른 관점을 보자, 달린다.

00:05:13.000 --> 00:05:19.000
실행은 특정 속성의 시작 위치, 길이 및 값이다.

00:05:19.000 --> 00:05:22.000
우리는 메시지의 모든 실행을 세는 것으로 시작할 수 있다.

00:05:22.000 --> 00:05:26.000
이것은 문자열에서 속성 값의 각 연속 범위를 반복할 것이다.

00:05:26.000 --> 00:05:29.000
이 줄에는 네 번의 실행이 있다.

00:05:29.000 --> 00:05:32.000
각 실행에는 각 속성에 대한 값 또는 nil이 있습니다.

00:05:32.000 --> 00:05:40.000
문자와 실행의 범위는 서로 교환할 수 있으므로, 속성 또는 그 반대의 경우도 마찬가지입니다.

00:05:40.000 --> 00:05:48.000
여기서 저는 문자 보기의 첨자에서 속성 범위를 사용하여 결과를 독립형 문자열로 변환합니다.

00:05:48.000 --> 00:05:53.000
특정 속성에 집중하여 달리기를 보는 것이 가장 유용하다.

00:05:53.000 --> 00:05:58.000
여기서, 우리는 링크 속성만을 위해 결합하기 위해 키 경로 링크를 사용합니다.

00:05:58.000 --> 00:06:07.000
결과 컬렉션의 각 요소는 문자열에서 설정할 수 있는 다른 속성을 고려하지 않고 링크 속성의 값을 제공합니다.

00:06:07.000 --> 00:06:19.000
링크만 보면, 세 가지 실행이 있습니다: 첫 번째는 설정되지 않은 곳; 두 번째는 값으로 설정된 곳; 그리고 세 번째는 다시 설정되지 않은 문장의 마지막 마침표입니다.

00:06:19.000 --> 00:06:23.000
실행을 반복하는 것은 우리에게 값과 범위의 튜플을 제공한다.

00:06:23.000 --> 00:06:32.000
값은 유형이 안전하기 때문에, 잘못된 유형을 갖는 것에 대해 캐스팅하거나 걱정하지 않고 URL에 존재하는 구성표와 같은 API를 사용할 수 있습니다.

00:06:32.000 --> 00:06:37.000
여기서 나는 귀속된 문자열의 모든 링크가 https인지 확인하고 있다.

00:06:37.000 --> 00:06:43.000
또 다른 유용한 기술은 부분 문자열을 찾고 그 범위를 사용하여 문자나 속성을 편집하는 것이다.

00:06:43.000 --> 00:06:48.000
"방문"이라는 단어를 좀 더 후퇴적인 분위기의 무언가로 바꾸고 싶다고 가정해 봅시다.

00:06:48.000 --> 00:06:51.000
먼저, 나는 부분 문자열의 범위를 찾아본다.

00:06:51.000 --> 00:06:58.000
다음으로, 나는 그 범위를 사용하여 그 하위 범위에서만 속성과 문자를 설정한다.

00:06:58.000 --> 00:07:02.000
결과는 이와 같이 여섯 번의 실행이 있는 귀속 문자열이다.

00:07:02.000 --> 00:07:05.000
다음으로, 현지화에 대해 이야기해 봅시다.

00:07:05.000 --> 00:07:08.000
AttributedString은 완전히 현지화할 수 있다.

00:07:08.000 --> 00:07:12.000
우리는 또한 Objective-C에서 NSAttributedString에 현지화 지원을 추가했습니다.

00:07:12.000 --> 00:07:18.000
속성 문자열은 일반 문자열과 마찬가지로 앱의 문자열 파일에 있습니다.

00:07:18.000 --> 00:07:27.000
Swift에서는 이제 SwiftUI의 텍스트 보기와 마찬가지로 문자열 보간을 사용하여 String 및 AttributedString의 현지화된 서식을 지원합니다.

00:07:27.000 --> 00:07:29.000
여기 간단한 예시가 있습니다.

00:07:29.000 --> 00:07:35.000
이 함수는 사용자의 문서 이름으로 사용자 정의된 현지화된 문자열을 반환합니다.

00:07:35.000 --> 00:07:44.000
%@ 또는 %d와 같은 형식 지정자를 사용하고 형식 함수를 호출하는 대신, 이제 값을 직접 전달할 수 있습니다.

00:07:44.000 --> 00:07:49.000
같은 접근 방식이 AttributedString에도 효과가 있다.

00:07:49.000 --> 00:07:53.000
Xcode는 컴파일러를 사용하여 이 새로운 이니셜라이저에서 문자열 파일을 생성할 수 있습니다.

00:07:53.000 --> 00:08:02.000
그것을 켜려면, 빌드 설정으로 가서, 현지화 설정을 찾고, 컴파일러를 사용하여 스위프트 문자열을 추출하세요.

00:08:02.000 --> 00:08:06.000
현지화된 속성 문자열이 어떻게 속성을 얻는지 궁금할 것입니다.

00:08:06.000 --> 00:08:10.000
AttributedString에 Markdown에 대한 지원을 추가했다는 것을 알려드리게 되어 기쁩니다.

00:08:10.000 --> 00:08:15.000
다음은 SwiftUI 텍스트에서 바로 현지화된 속성 문자열을 사용하는 예입니다.

00:08:15.000 --> 00:08:18.000
나는 그냥 평범한 줄로 시작한다.

00:08:18.000 --> 00:08:25.000
텍스트 주위에 두 개의 별표를 추가함으로써, 나는 SwiftUI가 굵게 렌더링하는 것을 강하게 강조한다.

00:08:25.000 --> 00:08:32.000
SwiftUI가 이탤릭체로 렌더링하는 텍스트를 강조하기 위해 밑줄을 사용할 수 있습니다.

00:08:32.000 --> 00:08:34.000
우리는 또한 링크를 지원합니다.

00:08:34.000 --> 00:08:41.000
이것은 로컬라이저가 다른 언어에 대한 맞춤형 URL을 제공할 수 있는 좋은 기회이다.

00:08:41.000 --> 00:08:45.000
우리는 또한 취소선과 코드 음성과 같은 다른 인라인 스타일을 지원합니다.

00:08:45.000 --> 00:08:49.000
마지막으로, 귀속된 문자열을 보관하는 것에 대해 이야기해 봅시다.

00:08:49.000 --> 00:08:55.000
먼저, 우리는 NSAttributedString 참조 유형으로 변환할 수 있는 능력이 필요합니다.

00:08:55.000 --> 00:09:01.000
속성 문자열은 데이터 모델의 일부가 될 수 있으며, 이는 우리가 그것들을 인코딩하고 디코딩할 수 있어야 한다는 것을 의미합니다.

00:09:01.000 --> 00:09:06.000
마지막으로, 우리는 Markdown에서 사용자 지정 속성을 지정하는 방법을 원합니다.

00:09:06.000 --> 00:09:08.000
이 작업들은 모두 서로 관련이 있다.

00:09:08.000 --> 00:09:12.000
전환을 살펴보는 것부터 시작합시다.

00:09:12.000 --> 00:09:20.000
우리는 모두 NSAttributedString을 사용하는 많은 코드를 작성했기 때문에 구조체에서 클래스 유형으로 쉽게 변환할 수 있도록 했습니다.

00:09:20.000 --> 00:09:24.000
다음은 NSAttributedString 속성이 있는 보기입니다.

00:09:24.000 --> 00:09:30.000
변환하려면, 구조체 AttributedString을 NSAttributedString 이니셜라이저에 전달하기만 하면 됩니다.

00:09:30.000 --> 00:09:35.000
SDK의 일부인 속성의 경우, 이것이 내가 해야 할 전부이다.

00:09:35.000 --> 00:09:38.000
이제 인코딩과 디코딩을 살펴봅시다.

00:09:38.000 --> 00:09:41.000
여기 카페 앱의 영수증을 보관하고 있는 구조체가 있습니다.

00:09:41.000 --> 00:09:48.000
다시 말하지만, 저는 SwiftUI, UIKit, AppKit 및 Foundation에서 제공하는 속성을 사용하고 있습니다.

00:09:48.000 --> 00:09:53.000
그것은 AttributedString의 기본 코딩 가능한 구현이 내가 필요한 전부라는 것을 의미한다.

00:09:53.000 --> 00:09:58.000
난 그냥 영수증에 코딩 가능한 적합성을 추가했고, 난 끝났어.

00:09:58.000 --> 00:10:02.000
조금 더 나아가 사용자 지정 속성 인코딩에 대한 지원을 추가해 봅시다.

00:10:02.000 --> 00:10:05.000
우리는 속성 자체에 대해 이야기하는 것으로 시작할 것이다.

00:10:05.000 --> 00:10:09.000
속성은 두 부분이다: 키와 값.

00:10:09.000 --> 00:10:13.000
키는 새로운 AttributedStringKey 프로토콜을 준수하는 유형이다.

00:10:13.000 --> 00:10:19.000
그것은 필요한 가치의 유형과 보관을 위한 이름을 정의한다.

00:10:19.000 --> 00:10:25.000
이 키는 또한 값이 인코딩되거나 디코딩되는 방법을 사용자 정의하기 위해 다른 프로토콜을 준수할 수 있습니다.

00:10:25.000 --> 00:10:30.000
여분의 색상을 갖도록 귀속된 문자열의 범위를 정의하고 싶다고 가정해 봅시다.

00:10:30.000 --> 00:10:35.000
이 무지개 효과는 세 단계로 나선다: 평범하거나, 재미있거나, 극단적이다.

00:10:35.000 --> 00:10:41.000
우리는 열거형을 사용하여 그 값을 나타내고 이름을 무지개로 설정할 것이다.

00:10:41.000 --> 00:10:47.000
유형과 이름을 정의하는 것이 이 프로토콜의 유일한 요구 사항이다.

00:10:47.000 --> 00:10:53.000
이제, 인코딩된 속성 문자열의 일부가 되도록 이 속성을 코딩할 수 있다고 가정해 봅시다.

00:10:53.000 --> 00:10:57.000
내가 해야 할 일은 이렇게 코딩 가능한 적합성을 추가하는 것뿐이다.

00:10:57.000 --> 00:11:02.000
마지막으로, 무지개 레벨이 현지화된 문자열의 일부가 되기를 원한다고 가정해 봅시다.

00:11:02.000 --> 00:11:08.000
그것은 그것이 어디에 있든, 어떤 언어로든 문자열의 오른쪽 부분에 적용될 수 있다는 것을 의미한다.

00:11:08.000 --> 00:11:14.000
우리가 필요한 것은 선택할 수 있는 프로토콜 적합성을 하나 더하는 것이다.

00:11:14.000 --> 00:11:22.000
속성이 마크다운을 디코딩할 수 있다고 말할 때, 마크다운에서 바로 디코딩하고 속성 문자열에 삽입할 수 있습니다.

00:11:22.000 --> 00:11:25.000
필요한 것은 그 가치가 코딩 가능하다는 것이다.

00:11:25.000 --> 00:11:29.000
다음으로, 마크다운의 사용자 지정 속성 구문을 살펴봅시다.

00:11:29.000 --> 00:11:32.000
이 첫 번째 예에서, 우리는 링크에 대한 참조가 있다.

00:11:32.000 --> 00:11:39.000
링크 텍스트에는 대괄호를 사용하고 링크 대상 URL에는 괄호를 사용합니다.

00:11:39.000 --> 00:11:42.000
이 두 번째 예에서, 우리는 이미지에 대한 참조가 있다.

00:11:42.000 --> 00:11:50.000
느낌표로 시작한 다음, 이미지 설명에는 대괄호를 사용하고 이미지 소스에는 괄호를 사용합니다.

00:11:50.000 --> 00:11:53.000
이 처음 두 가지 예는 마크다운에서 일반적이다.

00:11:53.000 --> 00:11:57.000
세 번째 예는 사용자 지정 속성에 대한 구문을 보여줍니다.

00:11:57.000 --> 00:12:03.000
그것은 대괄호로 시작한 다음, 텍스트에는 대괄호를 사용하고, 속성에는 괄호를 사용합니다.

00:12:03.000 --> 00:12:06.000
속성은 JSON 5로 표시됩니다.

00:12:06.000 --> 00:12:13.000
JSON 5는 JSON과 호환되며 인용되지 않은 키, 주석 및 기타 몇 가지 기능을 허용합니다.

00:12:13.000 --> 00:12:17.000
이것은 이와 같은 인간 친화적인 끈과 잘 어울린다.

00:12:17.000 --> 00:12:22.000
우리는 또한 재단의 다른 JSON API에 JSON 5 지원을 추가했습니다.

00:12:22.000 --> 00:12:31.000
사용자 지정 속성은 JSON을 사용하기 때문에, JSONDecoder로 디코딩할 수 있는 모든 것은 새로운 사용자 지정 마크다운 구문과 자동으로 호환됩니다.

00:12:31.000 --> 00:12:39.000
여기에는 하나의 속성, 두 개의 속성, 하나의 문자열과 하나의 숫자, 그리고 여러 속성이 있는 단일 속성이 있습니다.

00:12:39.000 --> 00:12:45.000
여기에 한 가지 추가 조각이 있는데, 이는 Markdown에서 이 이름들을 Swift 유형에 연결하는 방법입니다.

00:12:45.000 --> 00:12:47.000
그 작품은 속성 범위라고 불린다.

00:12:47.000 --> 00:12:50.000
범위는 속성 키의 그룹이다.

00:12:50.000 --> 00:13:00.000
범위는 우리가 찾을 것으로 예상되는 속성, 이름 및 디코딩 방법을 알려주기 때문에 JSON 또는 Markdown에서 디코딩할 때 유용합니다.

00:13:00.000 --> 00:13:06.000
우리는 Foundation, UIKit, AppKit 및 SwiftUI에 대해 각각 하나의 범위를 정의합니다.

00:13:06.000 --> 00:13:10.000
당신은 또한 자신의 속성의 범위를 정의할 수 있습니다.

00:13:10.000 --> 00:13:13.000
카페 앱의 범위를 정의해 봅시다.

00:13:13.000 --> 00:13:19.000
우리는 AttributeScopes 내부의 범위를 중첩하고 AttributeScope 프로토콜에 준수할 것입니다.

00:13:19.000 --> 00:13:28.000
그런 다음 우리가 해야 할 일은 범위 내의 속성을 "let"로 나열하는 것입니다. 지금까지, 우리는 우리의 무지개 속성을 가지고 있다.

00:13:28.000 --> 00:13:32.000
다음으로, 우리는 우리 안에 SwiftUI 범위를 포함할 것이다.

00:13:32.000 --> 00:13:36.000
그것은 우리 자신 외에도 그 모든 속성을 허용한다.

00:13:36.000 --> 00:13:40.000
스코프는 재귀적으로 둥지를 틀기 때문에, 이것은 또한 기초 속성을 포함한다.

00:13:40.000 --> 00:13:43.000
우리의 새로운 범위에 대한 속성을 정의하는 것은 유용하다.

00:13:43.000 --> 00:13:48.000
그것은 우리가 범위를 인수로 사용하는 함수에서 키 경로 구문을 사용할 수 있게 해준다.

00:13:48.000 --> 00:13:54.000
마지막으로, 이제 사용자 지정 마크다운에서 현지화되고 다채로운 속성 문자열을 로드할 수 있습니다.

00:13:54.000 --> 00:14:00.000
또한 NSAttributedString으로의 보관 및 변환을 위한 범위 수행 기능을 찾을 수 있습니다.

00:14:00.000 --> 00:14:04.000
이것은 모든 단계에서 행동을 맞춤화할 수 있게 해준다.

00:14:04.000 --> 00:14:10.000
다음은 제목에서 사용자 지정 무지개 속성을 볼 수 있는 카페 앱의 첫 번째 화면입니다.

00:14:10.000 --> 00:14:21.000
현지화된 문자열이 Markdown에서 속성 문자열로 변환된 후, 앱은 속성을 찾고 문자열의 범위에 재미있는 효과를 적용합니다.

00:14:21.000 --> 00:14:29.000
속성은 현지화된 문자열 파일에서 나오기 때문에, 이것은 스페인어와 같이 Caffé가 지원하는 모든 언어에서 올바르게 작동합니다.

00:14:29.000 --> 00:14:31.000
하지만 우리는 이제 막 시작했어.

00:14:31.000 --> 00:14:35.000
우리는 또한 완전히 새로운 Formatter API를 가지고 있습니다.

00:14:35.000 --> 00:14:38.000
포맷터는 또 다른 오랜 재단 기능이다.

00:14:38.000 --> 00:14:47.000
그들은 숫자, 날짜, 시간 등과 같은 데이터를 지역화되고 사용자가 제시할 수 있는 문자열로 변환할 책임이 있다.

00:14:47.000 --> 00:14:54.000
포맷터는 꽤 많은 구성 데이터로 뒷받침되므로, 캐시하고 재사용하는 일반적인 패턴이다.

00:14:54.000 --> 00:14:57.000
그러나, 앱은 많은 뚜렷한 코드로 구성되어 있다.

00:14:57.000 --> 00:15:02.000
그들 모두 사이에 포맷터를 공유하는 것이 항상 말이 되지 않을 수도 있다.

00:15:02.000 --> 00:15:14.000
또한, 사람들이 날짜와 시간을 읽는 다양한 방법, 그리고 앱 작성자로서 우리의 디자인에 맞는 방식으로 이 데이터를 제시하고자 하는 우리의 열망 때문에, 엣지 케이스에 대한 많은 기회가 있습니다.

00:15:14.000 --> 00:15:21.000
올해, 우리는 Formatter API를 처음부터 재고하여 성능과 유용성을 모두 개선했습니다.

00:15:21.000 --> 00:15:25.000
간단히 말해서, 우리의 새로운 API는 형식에 초점을 맞추고 있다.

00:15:25.000 --> 00:15:31.000
캐싱 패턴이 작동하는 것을 볼 수 있는 지진 샘플 앱에서 이 코드를 살펴봅시다.

00:15:31.000 --> 00:15:34.000
그것은 2단계 과정을 가지고 있다.

00:15:34.000 --> 00:15:37.000
먼저, 포맷터를 만들고 구성하세요.

00:15:37.000 --> 00:15:41.000
다음으로, 포맷터에게 우리의 날짜를 주고 문자열을 받으세요.

00:15:41.000 --> 00:15:43.000
어떻게 그게 더 간단할 수 있어?

00:15:43.000 --> 00:15:47.000
음, 우리만의 날짜 포맷터를 만들기 위한 요구 사항을 제거하는 것으로 시작합시다.

00:15:47.000 --> 00:15:54.000
이것이 캐시되어야 한다는 것을 잊기 정말 쉬웠고, 이는 테이블의 모든 셀에 대해 동일한 포맷터를 다시 만들 수 있었다.

00:15:54.000 --> 00:15:56.000
다음으로, 포맷 단계.

00:15:56.000 --> 00:16:01.000
포맷터를 통해 날짜를 전달하는 대신, 날짜 자체를 사용합시다.

00:16:01.000 --> 00:16:03.000
이제 그것은 단지 한 줄의 코드일 뿐이다.

00:16:03.000 --> 00:16:07.000
원하는 형식을 지정하면, 그게 다야.

00:16:07.000 --> 00:16:10.000
이 숫자 형식에 대해 더 이야기해 봅시다.

00:16:10.000 --> 00:16:15.000
그것은 많은 코드는 아니지만, 약간의 복잡성을 숨기고 있으며 알아야 할 몇 가지 함정이 있다.

00:16:15.000 --> 00:16:21.000
인수가 부동 소수점 숫자가 아니라면, 여기서 완전히 잘못된 출력을 얻을 수 있습니다.

00:16:21.000 --> 00:16:30.000
독자는 문자열 상수인 수정자 집합과 함께 부동 소수점 숫자를 포맷하기 위한 특별한 경우 구문을 알고 있어야 합니다.

00:16:30.000 --> 00:16:35.000
우리는 이 코드가 이해하고, 유지하고, 읽기가 더 쉽다고 생각한다.

00:16:35.000 --> 00:16:40.000
그것은 일반 스위프트 함수를 사용하여 숫자를 어떻게 포맷할지 정확히 지정합니다.

00:16:40.000 --> 00:16:44.000
당신은 또한 자동 완성과 유형 안전을 얻을 수 있습니다.

00:16:44.000 --> 00:16:48.000
우리는 이 새로운 접근 방식을 재단의 모든 10명의 포맷터에게 적용했습니다.

00:16:48.000 --> 00:16:57.000
우리는 인터페이스를 정리하고 단순화했으며, 일반적인 함정을 피하기 위해 변경했으며, 그 과정에서 많은 새로운 기능을 추가했습니다.

00:16:57.000 --> 00:17:04.000
가장 인기 있는 두 가지 형식 유형인 날짜와 숫자를 자세히 살펴봅시다.

00:17:04.000 --> 00:17:13.000
날짜 포맷은 달력과 시간대를 사용하여 절대 시점을 인간이 날짜로 이해하는 것으로 변환하는 것이다.

00:17:13.000 --> 00:17:20.000
그리고 그 이상으로, 그것은 인간이 자신의 데이트가 어떻게 보이는지 좋아하는지에 대한 모든 선호도를 고려한다.

00:17:20.000 --> 00:17:23.000
우리는 그 선호도를 로케일이라고 부른다.

00:17:23.000 --> 00:17:28.000
날짜를 포맷하는 데 필요한 소량의 코드를 살펴봅시다.

00:17:28.000 --> 00:17:33.000
먼저, 나는 Date.now를 사용하여 현재 시점을 얻을 것이다.

00:17:33.000 --> 00:17:35.000
다음으로, 나는 포맷된 함수를 부른다.

00:17:35.000 --> 00:17:37.000
그게 다야.

00:17:37.000 --> 00:17:42.000
물론, 우리가 방금 예시에서 보았듯이, 날짜 포맷은 많은 옵션이 있는 것이다.

00:17:42.000 --> 00:17:45.000
그러니 이것을 조금 확장해 봅시다.

00:17:45.000 --> 00:17:51.000
포맷된 기능은 날짜 또는 시간만 표시하도록 구성할 수 있습니다.

00:17:51.000 --> 00:17:55.000
두 주장 모두 선택할 수 있는 몇 가지 옵션이 있다.

00:17:55.000 --> 00:18:03.000
이 새로운 서식 API의 중요한 목표는 올바른 형식을 만드는 데 가능한 한 많은 컴파일 시간을 제공하는 것입니다.

00:18:03.000 --> 00:18:16.000
마법의 문자열 값을 사용하여 포맷하는 것은 함정을 만드는 것으로 악명이 높으며, 정상적인 상황에서는 형식이 올바르게 보이지만 연말과 같이 가장자리의 경우 완전히 잘못된 값을 생성합니다.

00:18:16.000 --> 00:18:19.000
여기 다시 우리의 기본 형식이 있습니다.

00:18:19.000 --> 00:18:24.000
이것은 이와 같이 날짜와 시간 스타일을 묻는 짧은 버전이다.

00:18:24.000 --> 00:18:29.000
논픽과 간단한 스타일 버전 모두에 대해, 우리는 당신을 위한 기본 형식을 선택합니다.

00:18:29.000 --> 00:18:36.000
하지만, 정말로 날짜를 사용자 정의하고 싶다면, 여기서 가서 관심 있는 필드를 추가하세요.

00:18:36.000 --> 00:18:41.000
이 예시에서, 나는 스타일에 필드를 추가하여 형식을 구축한다.

00:18:41.000 --> 00:18:45.000
나는 해, 일, 달만 원해.

00:18:45.000 --> 00:18:49.000
다른 가능성은 시간, 분, 초 등을 포함한다.

00:18:49.000 --> 00:18:55.000
출력 형식은 사용자의 로케일에 따라 자동으로 조정됩니다.

00:18:55.000 --> 00:18:57.000
이 필드들도 구성할 수 있다.

00:18:57.000 --> 00:19:04.000
이 경우, 나는 월을 넓은 형식으로 변경하는데, 이는 전체 월 이름이 인쇄된다는 것을 의미한다.

00:19:04.000 --> 00:19:08.000
이 API를 사용하면 날짜의 일부만 포맷하는 것도 쉽습니다.

00:19:08.000 --> 00:19:10.000
여기서 나는 그냥 평일을 보내고 싶어.

00:19:10.000 --> 00:19:13.000
날짜도 다른 스타일로 포맷할 수 있다.

00:19:13.000 --> 00:19:24.000
여기서 저는 ISO 8601 형식과 iso8601을 사용하기로 선택하지만, 연도, 월, 일만 사용하고 대시로 구분합니다.

00:19:24.000 --> 00:19:28.000
이러한 예시로, 서식 패턴이 명확해진다.

00:19:28.000 --> 00:19:30.000
우리는 포맷하고 싶은 값으로 시작한다.

00:19:30.000 --> 00:19:35.000
우리는 포맷된 함수를 부르고 인수는 스타일이다.

00:19:35.000 --> 00:19:38.000
각 유형마다 하나 이상의 스타일이 있을 수 있다.

00:19:38.000 --> 00:19:42.000
예를 들어, 날짜에는 dateTime과 iso8601이 모두 있다.

00:19:42.000 --> 00:19:47.000
스타일은 기본 구성에서 사용하거나 사용자 정의할 수 있습니다.

00:19:47.000 --> 00:19:54.000
이 포맷 API는 필드 목록을 지정하여 작동하며, 그 중 일부는 추가 옵션이 있습니다.

00:19:54.000 --> 00:19:57.000
당신이 제공하는 필드의 순서는 중요하지 않습니다.

00:19:57.000 --> 00:20:04.000
각 필드는 포맷터에게 최종 출력 어딘가에 어떤 값이 포함되어야 하는지 알려줍니다.

00:20:04.000 --> 00:20:11.000
우리는 인수가 없거나 스타일 이름만 있는 가장 짧은 버전의 API에 대해 합리적인 기본값을 선택합니다.

00:20:11.000 --> 00:20:22.000
필드를 추가하기 시작하면, 출력은 사용자 정의되고 UI의 자리 표시자 텍스트와 같이 표시하기로 선택한 것만 반영합니다.

00:20:22.000 --> 00:20:26.000
또한 서로 상대적인 두 날짜를 포맷하기 위한 새로운 API가 있다.

00:20:26.000 --> 00:20:29.000
여기 몇 가지 예가 있습니다.

00:20:29.000 --> 00:20:32.000
먼저, 범위 내에서 두 개의 날짜를 포맷하세요.

00:20:32.000 --> 00:20:38.000
두 개의 날짜와 함께 일반 스위프트 범위 구문을 사용할 수 있습니다.

00:20:38.000 --> 00:20:45.000
포맷 범위는 우리가 단일 날짜로 했던 것처럼 날짜와 시간을 표시하는 구성을 허용합니다.

00:20:45.000 --> 00:20:53.000
이 범위를 기간이나 구성 요소 또는 현재에 대한 단일 날짜로 포맷할 수 있습니다.

00:20:53.000 --> 00:20:56.000
포맷의 또 다른 새로운 기능은 출력에 기인한다.

00:20:56.000 --> 00:21:05.000
이를 통해 사용자의 선호도에 맞게 재정렬한 후 포맷터가 포맷된 값의 특정 부분을 넣은 위치를 찾을 수 있습니다.

00:21:05.000 --> 00:21:09.000
물론, 이것은 우리의 새로운 구조체 AttributedString을 사용한다.

00:21:09.000 --> 00:21:13.000
포맷된 출력에 스타일링을 적용하는 것은 모든 종류의 장소에 나타난다.

00:21:13.000 --> 00:21:17.000
watchOS에서, 많은 합병증은 포맷된 문자열이다.

00:21:17.000 --> 00:21:30.000
Apple Watch는 개인용 장치이기 때문에 사용자의 선호도를 고려하는 것이 중요하지만, 날짜의 일부에 사용자가 선택한 색상을 제공하는 것과 같은 특정 종류의 디자인 언어를 적용하고 싶은 곳이기도 합니다.

00:21:30.000 --> 00:21:34.000
이것을 설정하는 것은 실제로 SwiftUI에서 꽤 재미있다.

00:21:34.000 --> 00:21:36.000
데모에서 함께 살펴봅시다.

00:21:36.000 --> 00:21:42.000
여기 당신의 다음 무료 커피가 언제인지 보여주는 카페 컴패니언 앱의 출발점이 있습니다.

00:21:42.000 --> 00:21:48.000
포맷된 날짜를 보여주는 SwiftUI 보기가 있습니다.

00:21:48.000 --> 00:21:56.000
여기서 SwiftUI 미리보기로 제어할 수 있도록 포맷에 로케일을 설정했습니다.

00:21:56.000 --> 00:22:02.000
꽤 좋은 시작이지만, 조금 더 커스터마이징하고 싶습니다.

00:22:02.000 --> 00:22:06.000
이것을 내 앱에 좀 더 구체적으로 만드는 것으로 시작합시다.

00:22:06.000 --> 00:22:15.000
나는 분, 시간, 그리고 평일에만 신경을 쓴다.

00:22:15.000 --> 00:22:20.000
그래, 꽤 좋아 보여. 이제 약간의 색을 더해 봅시다.

00:22:20.000 --> 00:22:33.000
먼저, 우리는 반환 유형을 AttributedString으로 변경하고 귀속된 출력을 요청할 것입니다.

00:22:33.000 --> 00:22:36.000
다음으로, 우리는 속성 컨테이너를 사용할 것이다.

00:22:36.000 --> 00:22:40.000
이것들은 문자열의 특정 문자에 첨부되지 않고 속성을 저장할 수 있다.

00:22:40.000 --> 00:22:46.000
우리는 날짜 형식이 출력에 넣는 평일 속성에 대해 하나를 만들 것입니다.

00:22:46.000 --> 00:22:52.000
그것은 평일을 포함하는 문자열의 범위에 설정되어 있다.

00:22:52.000 --> 00:23:00.000
다음으로, 우리는 설정하고 싶은 색상 속성을 위한 컨테이너를 만들 것입니다.

00:23:00.000 --> 00:23:13.000
그리고 마지막으로, 우리는 첫 번째 컨테이너의 속성과 일치하는 속성을 속성 문자열의 두 번째 값으로 대체하기 위해 속성 문자열 함수를 사용할 것입니다.

00:23:13.000 --> 00:23:26.000
AttributedString은 값 유형이고 교체는 돌연변이 함수이기 때문에, 우리는 "let"을 "var"로 변경해야 합니다. 좋아 보인다.

00:23:26.000 --> 00:23:28.000
더 좋은 것은, 그것은 모든 지역에서 작동한다.

00:23:28.000 --> 00:23:37.000
다시 확인하기 위해 미리보기에 몇 개를 더 추가해 봅시다.

00:23:37.000 --> 00:23:43.000
이 로케일의 형식이 지정된 날짜가 어디에 있든 평일이 주황색이라는 것을 알 수 있습니다.

00:23:43.000 --> 00:23:46.000
더 많은 새로운 포맷터 API에 대해 계속 배워봅시다.

00:23:46.000 --> 00:23:53.000
이제 날짜를 문자열로 바꾸는 방법을 보았으니, 문자열을 날짜로 바꾸는 방법에 대해 이야기해 봅시다.

00:23:53.000 --> 00:23:57.000
날짜에는 이제 전략 논쟁을 하는 이니셜라이저가 있다.

00:23:57.000 --> 00:24:02.000
이 전략은 파서에게 입력에서 어떤 필드를 기대할 수 있는지 알려주는 데 사용된다.

00:24:02.000 --> 00:24:06.000
날짜의 경우, 형식은 일종의 전략이기도 하다.

00:24:06.000 --> 00:24:14.000
그것은 출력을 표시하고 사용자가 새 날짜를 입력할 수 있는 텍스트 필드와 같이 라운드 트립 날짜에 유용합니다.

00:24:14.000 --> 00:24:16.000
여기 왕복 여행의 예가 있습니다.

00:24:16.000 --> 00:24:18.000
당신은 구문 분석이 던질 수 있다는 것을 알게 될 것입니다.

00:24:18.000 --> 00:24:23.000
이것은 입력에 따라 구문 분석이 실패할 수 있기 때문이다.

00:24:23.000 --> 00:24:27.000
일부 전략에는 구문 분석을 위한 고급 옵션이 있다.

00:24:27.000 --> 00:24:34.000
여기서, 우리는 날짜 형식이 서버에서 받은 것일 때 유용한 고정 형식을 구문 분석합니다.

00:24:34.000 --> 00:24:37.000
그것을 사용하려면, 형식 문자열로 전략을 초기화하세요.

00:24:37.000 --> 00:24:42.000
하지만, 마법의 문자열 값을 사용하는 대신, 우리는 문자열 보간을 사용합니다.

00:24:42.000 --> 00:24:48.000
이 경우, 우리는 년-월-일 형식의 문자열을 예상한다.

00:24:48.000 --> 00:24:55.000
각 보간은 필드로 명확하게 식별되며, 각각은 예상되는 형식을 정확히 지정합니다.

00:24:55.000 --> 00:24:59.000
이것에 대한 한 가지 정말 좋은 점은 자동 완성 경험이다.

00:24:59.000 --> 00:25:07.000
다른 날짜 형식을 사용하고 싶다면, 자동 완성은 각각의 의미에 대한 문서와 함께 유효한 옵션을 보여줍니다.

00:25:07.000 --> 00:25:12.000
아니요, 1년에 얼마나 많은 Y 문자를 사용해야 하는지 더 추측하세요.

00:25:12.000 --> 00:25:13.000
숫자로 넘어가자.

00:25:13.000 --> 00:25:20.000
숫자 포맷은 정수 또는 부동 소수점 값을 인간이 읽을 수 있는 것으로 변환하는 것이다.

00:25:20.000 --> 00:25:24.000
모든 포맷과 마찬가지로, 숫자가 어떻게 표시되어야 하는지에 대한 선호도를 고려합니다.

00:25:24.000 --> 00:25:30.000
여기에는 사용된 숫자의 종류부터 숫자를 그룹화하는 데 사용되는 문자에 이르기까지 모든 것이 포함됩니다.

00:25:30.000 --> 00:25:37.000
날짜 포맷과 마찬가지로, 추가 매개 변수 없이 훌륭한 출력을 쉽게 얻을 수 있습니다.

00:25:37.000 --> 00:25:40.000
지원되는 많은 종류의 옵션과 출력이 있다.

00:25:40.000 --> 00:25:47.000
여기서 우리는 백분율, 과학적 표기법, 그리고 통화를 보여준다.

00:25:47.000 --> 00:25:50.000
마지막으로, 몇 가지 형식을 합치자.

00:25:50.000 --> 00:25:54.000
목록 포맷은 이제 배열을 포맷하는 것이다.

00:25:54.000 --> 00:25:59.000
이 멤버 스타일 인수는 배열의 각 요소의 형식 스타일을 지정합니다.

00:25:59.000 --> 00:26:02.000
이것들은 숫자이기 때문에, 나는 백분율을 사용하고 싶다.

00:26:02.000 --> 00:26:05.000
출력은 모든 사용자의 로케일에 대해 정확합니다.

00:26:05.000 --> 00:26:08.000
지금까지 우리는 값을 직접 포맷하는 데 집중했다.

00:26:08.000 --> 00:26:13.000
SwiftUI는 또한 TextField에 포맷 스타일을 첨부하는 것을 지원합니다.

00:26:13.000 --> 00:26:22.000
형식 스타일에는 포맷하는 값의 종류에 대한 유형 정보가 있기 때문에, 여기 영수증의 팁 비율에 대해 읽을 수 있지만 안전한 구문을 사용할 수 있습니다.

00:26:22.000 --> 00:26:28.000
카페 앱을 다시 살펴보고 서식이 얼마나 많은 장소가 나타나는지 봅시다.

00:26:28.000 --> 00:26:31.000
우리는 재료에 대한 목록 형식을 사용합니다.

00:26:31.000 --> 00:26:34.000
우리는 가격을 위해 통화 형식을 사용합니다.

00:26:34.000 --> 00:26:39.000
우리는 수량에 대한 숫자 형식을 사용하고 주문 버튼에서 수를 현지화합니다.

00:26:39.000 --> 00:26:43.000
우리는 당신이 항상 여기 구석에서 볼 수 있는 날짜 형식을 잊을 수 없습니다.

00:26:43.000 --> 00:26:50.000
당신은 모든 곳에서 포맷된 출력을 찾을 수 있으며, 우리는 이 새로운 API가 당신의 앱에서도 쉽고 심지어 재미있게 만들 것이라고 생각합니다.

00:26:50.000 --> 00:26:54.000
현지화된 문자열과 포맷터를 도울 수 있는 더 많은 리소스가 있습니다.

00:26:54.000 --> 00:27:07.000
"SwiftUI 앱 현지화"와 "현지화된 문자열 간소화"라는 두 개의 세션이 더 있습니다. 다음으로, 자동 문법 계약이라는 새로운 기능에 대해 이야기해 봅시다.

00:27:07.000 --> 00:27:15.000
스페인어와 같은 언어의 로컬라이저는 자연스러운 번역을 표현하는 능력이 제한되어 있으며, 때로는 어색한 대화로 이어진다.

00:27:15.000 --> 00:27:27.000
이 언어들은 언어의 다른 부분 간의 성별과 복수화 합의를 달성하기 위해 변형이 필요하며 때로는 사용자가 선호하는 주소 용어에 대한 지식도 필요합니다.

00:27:27.000 --> 00:27:33.000
영어도 단수형과 복수형의 형태가 다른 명사와 함께 이 특징을 가지고 있다.

00:27:33.000 --> 00:27:37.000
나는 거기에 많은 언어 전문 용어를 버렸으니, 예를 들어 보자.

00:27:37.000 --> 00:27:42.000
내 카페 앱에서, 나는 음식 품목, 크기, 그리고 수량을 고를 수 있다.

00:27:42.000 --> 00:27:46.000
나는 작은 샐러드 1개를 선택한다.

00:27:46.000 --> 00:27:51.000
이제 내 친구가 나와 함께 할 거라고 해서, 나는 수를 2로 늘렸어.

00:27:51.000 --> 00:27:56.000
영어로, "샐러드"라는 단어는 숫자 2와 일치하도록 바뀌어야 한다.

00:27:56.000 --> 00:27:58.000
이것은 합의라고 불린다.

00:27:58.000 --> 00:28:03.000
그 모든 것은 이 문장의 단어들이 서로 일치해야 한다는 것이다.

00:28:03.000 --> 00:28:07.000
영어에서, 복수화로 인해 단어를 고치는 것은 일반적인 종류의 합의이다.

00:28:07.000 --> 00:28:16.000
이제 앱을 스페인어로 바꾸고 ensalada pequeña 1개 또는 작은 샐러드 1개를 주문합시다.

00:28:16.000 --> 00:28:23.000
내가 친구를 위해 주문할 때, 이 주문 버튼은 영어와 같은 복수형이 필요하지만 반전이 있다.

00:28:23.000 --> 00:28:31.000
스페인어로 형용사 pequeña와 명사 ensalada는 모두 백작 dos와 일치해야 한다.

00:28:31.000 --> 00:28:37.000
그래서 ensalada pequeña 대신에, 버튼에는 ensaladas pequeñas라고 쓰여 있다.

00:28:37.000 --> 00:28:40.000
다음으로, 나는 술을 마시러 넘어간다.

00:28:40.000 --> 00:28:49.000
이 문장의 경우, 버튼은 올바른 복수화뿐만 아니라 이 단어들의 문법적 성별에 대한 합의가 필요하다.

00:28:49.000 --> 00:28:52.000
주스, jugo는 남성적이다.

00:28:52.000 --> 00:28:56.000
형용사 pequeño도 일치해야 한다.

00:28:56.000 --> 00:29:02.000
이와 같은 텍스트를 올바르게 현지화하기 위해, 우리는 조합 폭발로 끝난다.

00:29:02.000 --> 00:29:07.000
음식, 크기 및 수의 각 조합에 대해 다른 현지화된 문자열이 필요합니다.

00:29:07.000 --> 00:29:15.000
코드에서, 그것은 종종 다음과 같이 끝나며, 각 항목을 전환한 다음 각 크기를 전환해야 합니다.

00:29:15.000 --> 00:29:21.000
카운트를 위해 각 문자열을 올바르게 복수화할 수 있는 stringsdict 파일도 있습니다.

00:29:21.000 --> 00:29:31.000
이제, 키보드의 제안을 지원하는 동일한 기술을 활용하여, 우리는 이러한 모든 경우 등을 쉽게 처리할 수 있는 새로운 API를 만들었습니다.

00:29:31.000 --> 00:29:41.000
시스템이 올바른 문법을 갖도록 지역화된 문자열을 자동으로 수정하기 때문에 우리는 이 기능을 자동 문법 계약이라고 부릅니다.

00:29:41.000 --> 00:29:43.000
이제 코드가 훨씬 더 간단해졌다.

00:29:43.000 --> 00:29:48.000
수량, 크기, 음식을 한 줄로 결합할 수 있습니다.

00:29:48.000 --> 00:29:53.000
자동 문법 계약은 굴절이라는 프로세스를 사용하여 문자열을 수정할 것입니다.

00:29:53.000 --> 00:29:54.000
그걸 분해하자.

00:29:54.000 --> 00:29:59.000
굴절하기 위해, 우리는 문자열의 어느 부분을 고정해야 하는지 알아야 한다.

00:29:59.000 --> 00:30:05.000
운 좋게도, 우리는 그것을 할 수 있는 스위프트 유형, AttributedString, 그리고 Markdown의 사용자 지정 속성이 있습니다.

00:30:05.000 --> 00:30:12.000
이 문자열에서, 나는 그 구문을 사용하여 음식, 크기, 그리고 우리의 굴절 속성으로 수를 감싼다.

00:30:12.000 --> 00:30:15.000
속성의 가치는 사실이다.

00:30:15.000 --> 00:30:28.000
이 프로젝트의 현지화를 내보낼 때, 주석이 달린 문자열과 음식의 이름과 크기와 같은 소스 코드의 다른 현지화된 문자열이 포함된 문자열 파일을 얻을 수 있습니다.

00:30:28.000 --> 00:30:30.000
여기 라틴 아메리카 스페인어의 문자열이 있습니다.

00:30:30.000 --> 00:30:40.000
로컬라이저는 "small" 또는 "large"와 같은 형용사가 스페인어로 명사 앞에 있기 때문에 구문 %1, %3, %2를 재정렬하는 인수를 사용했다.

00:30:40.000 --> 00:30:48.000
그들은 문자열의 이 영역을 굴절하기 위한 사용자 지정 속성 구문을 유지하고 음식과 크기에 대한 번역을 제공합니다.

00:30:48.000 --> 00:30:51.000
자동 문법 엔진은 나머지 부분을 해결한다.

00:30:51.000 --> 00:30:59.000
일부 언어는 현지화된 텍스트 자체의 단어뿐만 아니라 그 텍스트와 그것을 읽는 사람 사이의 합의를 특징으로 한다.

00:30:59.000 --> 00:31:02.000
자동 문법 합의도 도움이 될 수 있다.

00:31:02.000 --> 00:31:05.000
예를 들어, 노트에 대한 이 환영 화면을 살펴봅시다.

00:31:05.000 --> 00:31:17.000
영어로, 우리는 "메모에 오신 것을 환영합니다"라고 말한다. 스페인어로, 우리는 "Te damos la bienvenida a Notas" 또는 "Notes에 오신 것을 환영합니다"라고 말합니다. 우리는 영어로 하는 것과 같은 스페인어 경험을 하고 싶다.

00:31:17.000 --> 00:31:24.000
그러나, 스페인어로 "bienvenido"라는 단어는 사용자가 선호하는 주소 용어와 일치해야 합니다.

00:31:24.000 --> 00:31:29.000
이 용어는 몇 가지 선택 중 하나일 수 있으며, 그 선택은 텍스트를 바꾼다.

00:31:29.000 --> 00:31:34.000
올바른 주소 용어를 사용하면 더 개인적이고 포괄적인 경험을 할 수 있습니다.

00:31:34.000 --> 00:31:40.000
올해의 릴리스에서, 우리는 스페인어를 사용하는 사람들이 주소 기간을 지정할 수 있도록 했습니다.

00:31:40.000 --> 00:31:44.000
언어 및 지역 설정에는 새로운 주소 기간 옵션이 있습니다.

00:31:44.000 --> 00:31:51.000
당신이 그것을 선택할 때, 당신은 당신의 선호도를 선택하고 모든 앱과 공유하도록 선택할 수 있습니다.

00:31:51.000 --> 00:31:55.000
여기서, 당신은 여성 용어의 주소에 대한 노트에서 새로운 환영 화면을 볼 수 있습니다.

00:31:55.000 --> 00:31:57.000
그리고 여기는 남성적인 주소 용어입니다.

00:31:57.000 --> 00:32:03.000
우리가 모르거나 사용자가 지정하지 않는 것을 선호한다면, 우리는 원래 문자열을 대안으로 유지합니다.

00:32:03.000 --> 00:32:09.000
이전에 본 것과 동일한 굴절 속성은 사용자를 참조하는 현지화된 문자열에도 사용됩니다.

00:32:09.000 --> 00:32:14.000
우리의 "환영"의 경우, 우리는 bienvenido라는 단어에 굴절 속성을 적용합니다.

00:32:14.000 --> 00:32:17.000
영어 문자열은 바꿀 필요가 없다.

00:32:17.000 --> 00:32:25.000
또한 사용자의 선호도가 무엇인지에 대한 정보가 없는 경우 엔진이 사용할 대체 문자열인 굴절 대안을 추가할 수 있습니다.

00:32:25.000 --> 00:32:29.000
올해, 우리는 스페인어와 영어에 대한 자동 계약을 지원합니다.

00:32:29.000 --> 00:32:34.000
우리는 노트의 환영 화면과 같이 OS 전역의 여러 곳에서 그것을 채택했습니다.

00:32:34.000 --> 00:32:36.000
앱에서도 그것을 채택할 수 있습니다.

00:32:36.000 --> 00:32:41.000
필요한 코드 변경은 대부분 다른 문자열을 선택하기 위해 많은 논리를 삭제하는 것이다.

00:32:41.000 --> 00:32:50.000
무엇을 굴절할지에 대한 지침은 현지화된 문자열 자체의 일부이며, 로컬라이저가 문자열이 그들의 언어로 어떻게 나타나는지 더 잘 제어할 수 있게 해준다.

00:32:50.000 --> 00:32:54.000
카페 앱에 대한 자동 문법 합의를 살펴봅시다.

00:32:54.000 --> 00:32:57.000
영어로 실행되는 카페 앱을 살펴봅시다.

00:32:57.000 --> 00:33:02.000
주문에 피자를 추가하는 것으로 시작하겠습니다.

00:33:02.000 --> 00:33:05.000
나는 큰 것을 가질 것 같아. 그리고 그냥 1.

00:33:05.000 --> 00:33:10.000
버튼의 텍스트가 큰 피자 0개에서 큰 피자 1개로 어떻게 바뀌었는지 주목하세요.

00:33:10.000 --> 00:33:12.000
그건 자동으로 끝났어.

00:33:12.000 --> 00:33:16.000
내가 2개를 고르면, 다시 고쳐진다.

00:33:16.000 --> 00:33:19.000
난 그냥 하나 가질 거야.

00:33:19.000 --> 00:33:23.000
이 화면 하단의 주문 버튼이 1개의 항목으로 변경되었습니다.

00:33:23.000 --> 00:33:27.000
마실 것 어때?

00:33:27.000 --> 00:33:31.000
작은 것은 괜찮고, 이것들 중 하나만.

00:33:31.000 --> 00:33:35.000
버튼이 "항목" 대신 "항목"으로 어떻게 바뀌었는지 알아?

00:33:35.000 --> 00:33:37.000
그 끈은 자동으로 바뀌었다.

00:33:37.000 --> 00:33:41.000
확인해 보자.

00:33:41.000 --> 00:33:43.000
여기 우리의 영수증이 있습니다.

00:33:43.000 --> 00:33:46.000
그것은 포맷된 가격과 함께 우리의 피자와 주스를 나열합니다.

00:33:46.000 --> 00:33:51.000
하단에는 사용자 지정 글꼴과 웹사이트 링크가 있는 우리의 속성 문자열이 있습니다.

00:33:51.000 --> 00:33:54.000
Xcode로 돌아가서 소스를 살펴봅시다.

00:33:54.000 --> 00:34:01.000
음식 상세 보기에서 시작하겠습니다.

00:34:01.000 --> 00:34:04.000
이것은 크기 선택 화면을 보여주는 보기입니다.

00:34:04.000 --> 00:34:15.000
각 종류의 음식, 각 크기 및 각 카운트에 대해 하나가 아닌 스페인어에 대한 하나의 현지화된 문자열만 추가하면 된다는 것을 알 수 있도록 새로운 크기를 추가합시다.

00:34:15.000 --> 00:34:17.000
이 줄은 목록을 보여준다.

00:34:17.000 --> 00:34:19.000
그 목록은 우리의 모델 객체에서 나온 것이다.

00:34:19.000 --> 00:34:24.000
거기로 가자.

00:34:24.000 --> 00:34:27.000
크기 열거형은 이미 작고 크다.

00:34:27.000 --> 00:34:38.000
나는 "거대한"이라고 불리는 가장 굶주린 고객을 위해 새로운 사이즈를 추가할 것이다. 그렇게 하기 위해, 나는 현지화된 문자열과 함께 새로운 케이스를 추가할 것이다.

00:34:38.000 --> 00:34:41.000
이제 나는 거대한 크기에 대한 가격을 추가하기만 하면 된다.

00:34:41.000 --> 00:34:44.000
이 데모를 위해, 나는 그것들을 이니셜라이저에 넣었다.

00:34:44.000 --> 00:34:47.000
이제 나는 거대한 크기에 대한 가격을 추가하기만 하면 된다.

00:34:47.000 --> 00:34:57.000
이 데모를 위해, 나는 방금 그것들을 이니셜라이저에 넣었다.

00:34:57.000 --> 00:35:03.000
우리의 견해를 다시 확인해 봅시다.

00:35:03.000 --> 00:35:06.000
여기 미리보기에는 우리의 새로운 사이즈가 있습니다.

00:35:06.000 --> 00:35:08.000
우리의 출처에는 이미 영어 문자열이 포함되어 있다.

00:35:08.000 --> 00:35:10.000
난 그냥 지금 스페인어가 필요해.

00:35:10.000 --> 00:35:24.000
새로운 문자열을 생성하기 위해, 나는 컴파일러를 사용하여 "거대한"에 대한 새로운 현지화된 문자열을 찾을 것이다. 그렇게 하기 위해, 나는 제품 &gt; 수출 현지화를 선택하고, 스페인어 문자열을 저장한다.

00:35:24.000 --> 00:35:34.000
이제 스페인어 번역을 추가해 봅시다.

00:35:34.000 --> 00:35:45.000
나는 우리의 새로운 문자열을 필터링하고 스페인어 단어를 입력할 수 있다.

00:35:45.000 --> 00:35:57.000
다음으로, 나는 이 현지화를 가져와서 내 앱에 넣는다.

00:35:57.000 --> 00:36:01.000
이제 나는 스페인어로 우리 앱을 다시 실행할 거야.

00:36:01.000 --> 00:36:08.000
그렇게 하기 위해, 저는 제품 &gt; 계획 &gt; 계획 편집을 선택합니다.

00:36:08.000 --> 00:36:17.000
옵션에서, 나는 시험하고 싶은 언어를 선택할 수 있다.

00:36:17.000 --> 00:36:20.000
그리고 뛰어.

00:36:20.000 --> 00:36:23.000
당신은 우리의 헤더에서 우리가 지금 스페인어로 달리고 있다는 것을 알 수 있습니다.

00:36:23.000 --> 00:36:27.000
샐러드부터 시작해서 다른 주문을 하자.

00:36:27.000 --> 00:36:32.000
수량을 변경하면 주문 버튼이 고정되어 있습니다.

00:36:32.000 --> 00:36:37.000
우리의 새로운 거대한 크기는 2개의 샐러드를 위해 정확하게 복수화되었다.

00:36:37.000 --> 00:36:43.000
게다가, 그것은 단 하나의 문자열로 "ensalada"의 문법적 성별과 일치한다.

00:36:43.000 --> 00:36:51.000
올해 재단에는 많은 훌륭한 새로운 기능이 있으며, 오늘 앱에서 시도해 볼 준비가 되어 있습니다.

00:36:51.000 --> 00:36:59.000
AttributedString은 문자열 범위에 키-값 쌍을 추가하기 위한 빠르고 사용하기 쉬운 스위프트 우선 인터페이스를 제공합니다.

00:36:59.000 --> 00:37:05.000
텍스트에서 SwiftUI와 함께 사용하고 현지화된 문자열에서 마크다운을 사용할 수 있습니다.

00:37:05.000 --> 00:37:12.000
우리의 새로운 포맷터 API는 형식에 초점을 맞추고, 코드를 단순화하고 성능을 향상시킵니다.

00:37:12.000 --> 00:37:17.000
앱에서 데이터를 표시하는 모든 장소에서 형식을 사용하세요.

00:37:17.000 --> 00:37:28.000
마지막으로, 자동 문법 계약은 문법 성별, 수 및 사용자 자신의 주소 용어와 일치하도록 현지화된 문자열을 지능적으로 수정할 것입니다.

00:37:28.000 --> 00:37:30.000
네가 이 새로운 기능들을 좋아하길 바라.

00:37:30.000 --> 00:37:32.000
우리는 당신의 앱에서 그것들을 찾기를 기대하고 있습니다.

00:37:32.000 --> 00:37:34.000
고마워.

00:37:34.000 --> 23:59:59.000
[음악].

