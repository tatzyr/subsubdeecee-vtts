WEBVTT

00:00:00.000 --> 00:00:05.000
♪ 베이스 음악 연주 ♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:11.000
루이 파울로: 안녕하세요, 여러분, 저는 루이입니다.

00:00:11.000 --> 00:00:24.000
오늘, 제 동료 에릭과 저는 iOS 15와 macOS Monterey에서 사용할 수 있는 두 가지 새로운 프로토콜인 HTTP/3과 QUIC로 앱의 네트워킹 속도를 높이는 방법에 대해 이야기할 것입니다.

00:00:24.000 --> 00:00:30.000
우리는 HTTP의 진화와 HTTP/3이 어떻게 성능을 향상시키는지 탐구하는 것으로 시작할 것입니다.

00:00:30.000 --> 00:00:36.000
우리는 또한 HTTP/3의 새로운 전송 프로토콜인 QUIC에 대해 이야기할 것이다.

00:00:36.000 --> 00:00:47.000
그 후, URLSession에서 HTTP/3을 사용하는 방법과 HTTP/3을 지원하도록 HTTP 서버를 구성하는 방법을 설명하겠습니다.

00:00:47.000 --> 00:00:56.000
마지막으로, 우리는 QUIC를 사용하기 위한 API와 QUIC 위에 사용자 지정 네트워킹 프로토콜을 구현하는 방법에 대해 자세히 알아볼 것입니다.

00:00:56.000 --> 00:01:00.000
그런 다음 HTTP의 진화부터 시작합시다.

00:01:00.000 --> 00:01:02.000
우리가 자원을 가져와야 한다고 가정해 봅시다.

00:01:02.000 --> 00:01:09.000
우리는 연결을 설정하고, 요청을 보내고, 서버가 처리할 때까지 기다렸다가 응답을 받습니다.

00:01:09.000 --> 00:01:25.000
이제, 첫 번째 리소스가 끝나기 전에 다른 리소스를 가져오고 싶다면, 우리는 같은 과정을 다시 거쳐야 합니다: 연결 설정, 요청 전송, 처리 대기, 응답 수신, 이번에는 짙은 녹색으로 표시됩니다.

00:01:25.000 --> 00:01:29.000
여기 오렌지색의 세 번째 자원에 대한 또 다른 예가 있습니다.

00:01:29.000 --> 00:01:34.000
다이어그램에 요약된 바와 같이, 연결 설정에 많은 시간이 소요된다.

00:01:34.000 --> 00:01:37.000
단일 HTTP/1 연결을 재사용하면 어떻게 되나요?

00:01:37.000 --> 00:01:44.000
우리는 연결 설정 시간을 절약했지만, 이전 응답이 끝난 후에만 요청을 보낼 수 있습니다.

00:01:44.000 --> 00:01:47.000
이것은 헤드 오브 라인 차단으로 알려져 있다.

00:01:47.000 --> 00:01:54.000
과거에, HTTP 구현은 이 문제를 극복하기 위해 많은 병렬 연결을 사용했다.

00:01:54.000 --> 00:01:59.000
병렬 HTTP 연결의 수는 앱에서도 구성할 수 있었다.

00:01:59.000 --> 00:02:05.000
그러나, 이것은 클라이언트와 서버 모두에게 비효율적인 네트워킹 행동으로 이어졌다.

00:02:05.000 --> 00:02:12.000
HTTP/2는 단일 연결에서 여러 스트림을 다중화하여 헤드 오브 라인 차단을 해결합니다.

00:02:12.000 --> 00:02:18.000
요청은 더 일찍 전송되며, 다른 스트림의 데이터는 인터리브될 수 있다.

00:02:18.000 --> 00:02:24.000
이것은 유휴 대기 시간이 크게 줄어들기 때문에 단일 TCP 연결을 더 효율적으로 사용할 수 있게 해준다.

00:02:24.000 --> 00:02:31.000
HTTP/3을 사용하면 연결 설정이 훨씬 빠르므로 요청이 더 빨리 나갈 수 있습니다.

00:02:31.000 --> 00:02:36.000
그러나, 그것이 HTTP/3의 유일한 이점은 아니다.

00:02:36.000 --> 00:02:46.000
HTTP/3 스트림은 독립적이며, 모든 스트림이 단일 TCP 연결을 공유하는 HTTP/2와는 다릅니다.

00:02:46.000 --> 00:02:49.000
대부분의 네트워크에서 패킷이 손실된다.

00:02:49.000 --> 00:02:56.000
이것은 무선 네트워크의 정상적인 사건이며 네트워크의 용량을 감지하는 자연스러운 부분이다.

00:02:56.000 --> 00:03:05.000
HTTP/2에서 패킷 손실은 모든 HTTP/2 스트림이 단일 TCP 연결을 공유하기 때문에 많은 스트림에 영향을 미칠 수 있습니다.

00:03:05.000 --> 00:03:10.000
HTTP/3에서는 해당 HTTP 스트림만 영향을 받습니다.

00:03:10.000 --> 00:03:14.000
다른 스트림에 속한 데이터는 더 일찍 전달될 수 있다.

00:03:14.000 --> 00:03:22.000
우리는 방금 HTTP/3이 어떻게 연결을 더 빨리 설정할 수 있는지 그리고 패킷 손실에 어떻게 더 잘 대처할 수 있는지 보여주었습니다.

00:03:22.000 --> 00:03:28.000
이러한 개선은 기본 전송 프로토콜에 의해 활성화됩니다: QUIC.

00:03:28.000 --> 00:03:34.000
QUIC는 인터넷 엔지니어링 태스크포스에 의해 표준화된 새로운 신뢰할 수 있는 전송 프로토콜이다.

00:03:34.000 --> 00:03:42.000
TCP와 동일한 개념을 기반으로 하지만 종단간 암호화, 다중화 스트림 및 인증을 제공합니다.

00:03:42.000 --> 00:03:48.000
QUIC의 보안은 잘 알려진 TLS 1.3 프로토콜을 기반으로 합니다.

00:03:48.000 --> 00:03:51.000
QUIC의 주요 이점은 성능 향상이다.

00:03:51.000 --> 00:03:56.000
QUIC이 어떻게 그것을 달성하는지 탐구해 봅시다.

00:03:56.000 --> 00:04:08.000
QUIC는 안전한 핸드셰이크를 수행하기 위해 TLS 1.3에 의존하며 친숙한 TCP 3방향 핸드셰이크가 필요하지 않아 핸드셰이크 시간을 한 번의 왕복으로 줄입니다.

00:04:08.000 --> 00:04:14.000
다중 스트림은 QUIC의 핵심 개념이므로, 헤드 오브 라인 차단으로 고통받지 않습니다.

00:04:14.000 --> 00:04:28.000
QUIC 엔드포인트는 수신한 패킷에 대한 더 복잡한 정보를 다른 엔드포인트에 전달할 수 있으며 TCP의 한계에 의해 방해받지 않으므로 QUIC 연결은 향상된 손실 복구를 경험합니다.

00:04:28.000 --> 00:04:42.000
이 프로토콜은 또한 셀룰러 네트워크와 Wi-Fi 간의 세션을 다시 설정하지 않고도 연결이 다른 네트워크 인터페이스를 통해 원활하게 이동할 수 있는 연결 마이그레이션을 지원합니다.

00:04:42.000 --> 00:04:49.000
네트워킹 지연에 대해 더 알고 싶다면, "앱의 네트워크 지연 감소" 세션을 시청하세요.

00:04:49.000 --> 00:04:54.000
앱에서 HTTP/3을 어떻게 사용할 수 있는지 이야기해 봅시다.

00:04:54.000 --> 00:05:04.000
URLSession을 사용하는 경우, iOS 15와 macOS Monterey는 기본적으로 HTTP/3이 활성화되어 있기 때문에 앱을 변경할 필요가 없습니다.

00:05:04.000 --> 00:05:08.000
서버에서 HTTP/3을 활성화하면, 갈 수 있습니다.

00:05:08.000 --> 00:05:16.000
다가오는 HTTP/3 RFC 버전과 이전 HTTP/3 초안 버전 29가 모두 지원됩니다.

00:05:16.000 --> 00:05:20.000
그렇다면 앱이 HTTP/3을 사용하고 있는지 어떻게 확인할 수 있나요?

00:05:20.000 --> 00:05:23.000
악기를 사용하여 알아내자!

00:05:23.000 --> 00:05:31.000
Xcode 13에서 우리는 HTTP 트래픽을 검사하기 위해 네트워킹 프로파일링 템플릿 내에 새로운 도구를 도입하고 있습니다.

00:05:31.000 --> 00:05:35.000
URLSession을 직접 탭하므로 설정이 필요하지 않습니다.

00:05:35.000 --> 00:05:43.000
인스트루먼트를 사용하여 앱이 HTTP/3 또는 이전 HTTP 버전을 사용하고 있는지 확인할 수 있습니다.

00:05:43.000 --> 00:05:48.000
우리는 시작할 때 개 사진 세트를 가져오는 iOS 앱을 출시할 것입니다.

00:05:48.000 --> 00:05:55.000
그런 다음 HTTP 헤더를 검사하여 서버가 HTTP/3을 어떻게 광고하는지 알아볼 것입니다.

00:05:55.000 --> 00:06:05.000
네트워크 프로파일링 템플릿을 선택합시다.

00:06:05.000 --> 00:06:09.000
왼쪽 상단에 있는 기록을 클릭해 봅시다.

00:06:09.000 --> 00:06:15.000
HTTP 트래픽 기록의 개인 정보 보호 영향을 나타내는 프롬프트가 표시됩니다.

00:06:15.000 --> 00:06:29.000
우리가 동의한 후, Instruments는 HTTP 거래를 기록하기 시작할 것이다.

00:06:29.000 --> 00:06:35.000
다음으로, 악기는 앱과 도메인당 모든 HTTP 트랜잭션이 포함된 플롯을 보여줄 것이다.

00:06:35.000 --> 00:06:37.000
우리는 이제 우리가 필요한 모든 데이터를 포착했다.

00:06:37.000 --> 00:06:44.000
우리는 왼쪽 상단에 있는 일시 정지 버튼을 클릭할 수 있습니다.

00:06:44.000 --> 00:06:46.000
우리가 사용하고 있는 도메인을 선택합시다.

00:06:46.000 --> 00:06:56.000
HTTP 트랜잭션을 Option-클릭한 다음 도메인을 선택하여 그렇게 할 수 있습니다.

00:06:56.000 --> 00:07:01.000
HTTP 트랜잭션의 세부 사항을 보여주기 위해 도구를 구성해야 합니다.

00:07:01.000 --> 00:07:12.000
이를 달성하기 위해, 왼쪽 메뉴에 HTTP 트랜잭션이 표시되는지 확인하세요.

00:07:12.000 --> 00:07:16.000
첫 번째 요청을 선택합시다.

00:07:16.000 --> 00:07:25.000
오른쪽으로 스크롤하면, 이 거래가 사용한 HTTP 버전을 식별하는 HTTP 버전 열을 찾을 수 있습니다.

00:07:25.000 --> 00:07:30.000
흠, 우리는 여전히 HTTP/2를 사용하고 있는데, 왜 그래?

00:07:30.000 --> 00:07:35.000
오른쪽에서, 우리는 응답 헤더가 포함된 확장된 세부 사항 보기를 찾을 수 있습니다.

00:07:35.000 --> 00:07:47.000
이것은 우리에게 답을 준다: 서버는 HTTP/3에 대한 지원을 광고하기 위해 HTTP 대체 서비스를 사용했다.

00:07:47.000 --> 00:07:51.000
URLSession은 광고되지 않는 한 HTTP/3을 사용하지 않을 것이다.

00:07:51.000 --> 00:07:57.000
이 예에서, HTTP/3은 Alt-Svc HTTP 헤더를 통해 광고되었다.

00:07:57.000 --> 00:08:04.000
HTTP 서버는 이 헤더를 사용하여 HTTP/3에 대한 지원을 광고하는 것이 일반적이다.

00:08:04.000 --> 00:08:10.000
이 정보는 미래의 연결을 위해 기억되며, 우리는 이것을 "서비스 발견"이라고 부른다.

00:08:10.000 --> 00:08:17.000
이제 앱을 다시 녹음해 봅시다.

00:08:17.000 --> 00:08:23.000
인스트루먼트가 앱을 다시 실행하면, 동일한 HTTP 트랜잭션 세트가 이루어진다.

00:08:23.000 --> 00:08:30.000
다시 말하지만, 우리는 이제 악기를 일시 중지할 수 있습니다.

00:08:30.000 --> 00:08:34.000
다시 확대해서 첫 번째 거래를 점검해 봅시다.

00:08:34.000 --> 00:08:41.000
서버가 HTTP/3을 지원한다는 것을 기억했기 때문에, 우리는 이제 HTTP/3을 사용하고 있습니다.

00:08:41.000 --> 00:08:45.000
HTTP/3 서비스 검색은 앱에 투명합니다.

00:08:45.000 --> 00:08:49.000
HTTP/3 서버 지원의 발견은 두 가지 방법으로 이루어진다.

00:08:49.000 --> 00:08:59.000
권장되는 접근 방식은 HTTPS 리소스 레코드를 통해 HTTP/3에 대한 지원을 광고하도록 DNS 서버를 구성하는 것입니다.

00:08:59.000 --> 00:09:07.000
H3 문자열을 사용하여 HTTP/3을 광고하기 위해 애플리케이션 계층 프로토콜을 구성하기만 하면 됩니다.

00:09:07.000 --> 00:09:14.000
또한 대체 서비스를 사용하여 HTTP/3을 광고하는 새 헤더를 추가하도록 서버를 구성해야 합니다.

00:09:14.000 --> 00:09:19.000
서버는 HTTP/3을 광고하는 Alt-Svc 헤더를 보내야 합니다.

00:09:19.000 --> 00:09:24.000
여기에는 포트 번호와 서비스의 최대 연령이 몇 초 안에 포함됩니다.

00:09:24.000 --> 00:09:37.000
DNS 레코드의 장점은 정보가 DNS에 있기 때문에 앱이 처음으로 서버에 연결하려고 할 때 HTTP/3 연결을 설정할 수 있다는 것입니다.

00:09:37.000 --> 00:09:46.000
서버가 HTTP/3을 지원한다는 것을 알고 검색 프로세스의 속도를 높이고 싶다면, assumesHTTP3Capable 속성을 사용할 수 있습니다.

00:09:46.000 --> 00:09:56.000
이를 통해 HTTP 스택은 HTTP/3 서버가 있다고 가정할 수 있지만 HTTP/3이 사용될 것이라고 보장하지는 않습니다.

00:09:56.000 --> 00:10:02.000
네트워크는 여전히 HTTP/3을 차단하거나, 서버가 실제로 HTTP/3을 지원하지 않을 수 있습니다.

00:10:02.000 --> 00:10:07.000
그 경우, 우리는 HTTP/2로 돌아갈 것이다.

00:10:07.000 --> 00:10:12.000
HTTP는 클라이언트가 각 자원의 우선 순위를 지정할 수 있게 해준다.

00:10:12.000 --> 00:10:21.000
자원은 종종 관련되기 때문에, 우선 순위는 서버가 클라이언트의 필요에 따라 다른 자원보다 일찍 보낼 수 있게 해준다.

00:10:21.000 --> 00:10:30.000
예를 들어, 웹 브라우징에 대한 사용자 경험은 웹 페이지 렌더링에 가장 많은 영향을 미치는 리소스의 우선 순위를 지정하여 개선될 수 있습니다.

00:10:30.000 --> 00:10:37.000
우선 순위 체계는 HTTP/2에 도입되었지만 복잡성으로 인해 종종 존중되지 않았다.

00:10:37.000 --> 00:10:42.000
그런 이유로, 오래된 우선순위 모델은 HTTP/3에서 제거되었다.

00:10:42.000 --> 00:10:49.000
HTTP 헤더에 의존하는 새롭고 간단한 모델은 HTTP/3 스택에서 사용된다.

00:10:49.000 --> 00:10:57.000
이 모델에서 우선 순위는 긴급 매개 변수인 0에서 7과 선택적 증분 전달 매개 변수로 지정됩니다.

00:10:57.000 --> 00:11:02.000
URLSession을 사용할 때, 우선 순위를 지원하는 API는 동일하게 유지됩니다.

00:11:02.000 --> 00:11:11.000
긴급성을 사용하여 서버에 전달되는 우선 순위 속성을 사용하여 HTTP 우선 순위를 지정합니다.

00:11:11.000 --> 00:11:16.000
prefersIncrementalDelivery 속성으로 증분 배송을 활성화할 수 있습니다.

00:11:16.000 --> 00:11:18.000
기본 우선 순위는 3입니다.

00:11:18.000 --> 00:11:28.000
URLSession은 비동기 데이터 방법과 같은 편의 API가 사용되는지 여부에 따라 증분 전달을 추론합니다.

00:11:28.000 --> 00:11:37.000
앱이 전체 리소스가 다운로드될 때까지 처리할 수 없는 콘텐츠를 다운로드할 때, 이 속성을 false로 설정해야 합니다.

00:11:37.000 --> 00:11:44.000
요청이 전송된 후 자원의 우선 순위를 동적으로 변경하는 것도 지원됩니다.

00:11:44.000 --> 00:11:53.000
예를 들어, 더 낮은 우선 순위로 사진을 미리 가져온 다음 사용자가 앱의 해당 섹션으로 이동할 때 우선 순위를 높일 수 있습니다.

00:11:53.000 --> 00:12:00.000
다음으로, 제 동료 Eric은 QUIC를 채택하기 위해 사용자 지정 네트워킹 프로토콜을 어떻게 변경할 수 있는지 설명할 것입니다.

00:12:00.000 --> 00:12:02.000
고마워.

00:12:02.000 --> 00:12:04.000
에릭 키니어: 고마워, 루이!

00:12:04.000 --> 00:12:20.000
앞서 논의했듯이, HTTP/3은 HTTP/2에서 발견되는 것과 유사한 다중화 스트림을 제공하는 QUIC 위에 구축되었지만, 단일 TCP 연결을 기본 전송으로 공유함으로써 도입된 문제는 없습니다.

00:12:20.000 --> 00:12:29.000
QUIC 전송 연결 - 또는 QUIC 터널 - 다중 단방향 또는 양방향 QUIC 스트림에 대한 데이터를 다중화합니다.

00:12:29.000 --> 00:12:42.000
스트림은 엔드포인트에 의해 생성될 수 있고, 다른 스트림과 인터리브된 데이터를 동시에 보낼 수 있으며, TCP에서 제공하는 전통적인 스트림과 유사한 상태를 가질 수 있다.

00:12:42.000 --> 00:12:51.000
무엇보다도, QUIC에는 TLS 1.3 보안이 내장되어 있으며 변화하는 네트워크 조건에 더 잘 대응할 수 있습니다.

00:12:51.000 --> 00:12:55.000
이러한 기능은 단순한 HTTP 그 이상에 유용하다.

00:12:55.000 --> 00:13:15.000
애플리케이션이 비요청/응답 기반 데이터를 교환하는 경우, 기본 전송 컨텍스트를 공유하는 스트림을 다중화하거나 P2P 통신 또는 RPC 호출과 같은 다른 사용자 지정 프로토콜을 구현하는 이점을 누릴 수 있습니다. 앱에 QUIC 전송을 사용하는 것을 고려하십시오.

00:13:15.000 --> 00:13:25.000
iOS 15와 macOS Monterey에서 NWProtocolQUIC은 Network.framework에서 제공하는 다른 내장 프로토콜에 합류합니다.

00:13:25.000 --> 00:13:29.000
QUIC를 사용하는 연결을 만드는 것은 매우 친숙하다.

00:13:29.000 --> 00:13:34.000
엔드포인트와 새로 사용 가능한 QUIC 매개 변수를 제공하기만 하면 됩니다.

00:13:34.000 --> 00:13:42.000
이 매개 변수는 서버와 협상하기 위한 애플리케이션 계층 프로토콜인 ALPN 문자열을 지정합니다.

00:13:42.000 --> 00:13:50.000
평소와 같이 상태 업데이트 핸들러를 설정하여 연결이 진행되고 준비될 때 응답할 수 있습니다.

00:13:50.000 --> 00:13:58.000
그리고 마지막으로, 상태 업데이트 및 기타 콜백에 사용하고 싶은 디스패치 대기열에서 연결을 시작하세요.

00:13:58.000 --> 00:14:05.000
이제 QUIC 스트림을 설정했으므로, 다른 NWConnection과 마찬가지로 데이터를 보내고 받을 수 있습니다.

00:14:05.000 --> 00:14:14.000
전송 기능을 사용하여 원격 엔드포인트로 보내고 싶은 데이터를 제공하고, 완료되면 후속 전송을 예약하십시오.

00:14:14.000 --> 00:14:20.000
수신을 사용하여 들어오는 데이터를 처리하고, 완료되면 후속 수신을 예약하십시오.

00:14:20.000 --> 00:14:31.000
작년에, 우리는 여러 연결이 관련되거나 그룹화되는 상황을 더 쉽게 처리할 수 있도록 Network.framework에 연결 그룹 객체를 도입했습니다.

00:14:31.000 --> 00:14:45.000
기본 전송 컨텍스트 또는 터널에서 다중화되는 QUIC 스트림은 해당 관계에 따라 논리적으로 그룹화되며 새로운 그룹 유형인 NWMultiplexGroup과 함께 사용할 수 있습니다.

00:14:45.000 --> 00:14:58.000
연결 그룹은 다른 Network.framework 객체와 유사한 수명 주기를 따르며 QUIC 스트림이 공유하는 기본 QUIC 터널의 상태에 대해 추론할 수 있습니다.

00:14:58.000 --> 00:15:07.000
또한 특정 QUIC 터널에서 새로운 발신 스트림을 만들고 원격 엔드포인트에서 시작된 새로운 들어오는 스트림을 수신할 수 있습니다.

00:15:07.000 --> 00:15:13.000
다중화 프로토콜을 위한 연결 그룹을 만들려면, 멀티플렉스 그룹 설명자를 사용하세요.

00:15:13.000 --> 00:15:19.000
이 경우, 우리는 포트 443에서 example.com에 대한 그룹 설명자를 만들 것입니다.

00:15:19.000 --> 00:15:29.000
다음으로, 우리는 그 설명자와 QUIC 매개 변수로 NWConnectionGroup을 만들고, 만들 때 ALPN 문자열을 제공합니다.

00:15:29.000 --> 00:15:40.000
NWConnection과 마찬가지로 상태 업데이트 핸들러를 설정했지만, 이번에는 개별 스트림의 상태가 아닌 기본 QUIC 터널의 상태를 추적하고 있습니다.

00:15:40.000 --> 00:15:45.000
마지막으로, 우리는 콜백 대기열을 제공하는 연결 그룹을 시작합니다.

00:15:45.000 --> 00:15:55.000
그룹에서 NWConnection을 초기화하거나 그룹의 추출 함수를 호출하여 새로운 발신 스트림을 만들 수 있습니다.

00:15:55.000 --> 00:16:03.000
원격 엔드포인트에서 시작된 들어오는 스트림은 그룹에 새 연결 핸들러를 설정하여 처리할 수 있습니다.

00:16:03.000 --> 00:16:14.000
이러한 연결은 상태 핸들러(이번에는 스트림 상태를 추적)로 평소와 같이 설정할 수 있으며 콜백에 사용할 대기열로 시작할 수 있습니다.

00:16:14.000 --> 00:16:21.000
다른 프로토콜과 마찬가지로, 매개 변수의 객체를 만들 때 구성을 위해 QUIC.Options를 사용할 수 있습니다.

00:16:21.000 --> 00:16:38.000
QUIC의 경우, QUIC 사양에 나열된 전송 매개 변수를 구성할 수 있으며, 연결 그룹에서 만들 때 개별 스트림의 속성을 사용자 정의할 수도 있습니다. 예를 들어, 새로운 단방향 스트림을 만들고 싶다면.

00:16:38.000 --> 00:16:49.000
NWListener를 사용하여 앱에서 서버를 실행하는 경우, newConnectionGroupHandler를 통해 새로운 들어오는 QUIC 터널을 수신할 수 있도록 향상되었습니다.

00:16:49.000 --> 00:16:56.000
당신의 newConnectionGroupHandler는 누군가가 당신의 서버에 새로운 QUIC 터널을 설정할 때마다 호출될 것입니다.

00:16:56.000 --> 00:17:01.000
그 핸들러 안에서, 당신은 상태 업데이트를 받기 위해 평소와 같이 그룹을 설정할 수 있습니다.

00:17:01.000 --> 00:17:06.000
이것은 또한 우리가 방금 논의했던 새로운 연결 핸들러를 설정하기에 좋은 장소이다.

00:17:06.000 --> 00:17:15.000
이 터널에서 열린 후속 스트림을 받고 싶다면, 콜백에 사용할 대기열로 그룹을 시작하면 모든 준비가 됩니다!

00:17:15.000 --> 00:17:21.000
마지막으로, NWProtocolMetadata를 사용하여 스트림에 대한 정보에 접근할 수 있습니다.

00:17:21.000 --> 00:17:26.000
예를 들어, 새로 생성된 스트림의 스트림 ID를 확인하고 싶을 수도 있습니다.

00:17:26.000 --> 00:17:38.000
그리고 스트림을 마치면, 사용자 지정 프로토콜이 applicationError 코드를 정의한 경우, 스트림을 취소하기 전에 메타데이터를 사용하여 원격 엔드포인트에 오류를 전달할 수 있습니다.

00:17:38.000 --> 00:17:52.000
그래서 우리는 새로운 NWMultiplexGroup 유형을 사용하여 QUIC 터널을 만들고 관리하는 방법을 탐구했으며, 그 그룹에서 각 QUIC 스트림에 대한 개별 NWConnections를 만들었습니다.

00:17:52.000 --> 00:18:00.000
우리는 NWListener를 사용하여 들어오는 터널을 듣고, 결과 연결 그룹을 사용하여 새로운 들어오는 스트림을 수신할 수 있습니다.

00:18:00.000 --> 00:18:19.000
이러한 스트림에서 다른 연결과 마찬가지로 데이터를 보내고 받을 수 있으며, QUIC 프로토콜 옵션을 사용하여 전송 매개 변수를 지정하고 스트림을 구성할 수 있으며, QUIC 프로토콜 메타데이터를 사용하여 스트림을 검사하고 QUIC 특정 정보를 원격 엔드포인트에 통신할 수 있습니다.

00:18:19.000 --> 00:18:25.000
이제 QUIC을 채택하여 앱의 네트워킹을 개선했으니, 그것이 작동하는지 어떻게 알 수 있을까요?

00:18:25.000 --> 00:18:31.000
Qlog 파일을 출력하는 새로운 환경 변수로 디버깅하는 동안 앱을 실행할 수 있습니다.

00:18:31.000 --> 00:18:45.000
Qlog는 IETF에서 제안된 새로운 표준화된 로깅 형식으로, 전통적인 패킷 캡처에 존재하는 것보다 QUIC 연결이 어떻게 작동하는지에 대한 더 풍부한 정보를 내보낼 수 있습니다.

00:18:45.000 --> 00:18:53.000
테스트 실행 후, Xcode의 장치 창을 사용하여 분석을 위해 qlog 파일이 있는 앱의 컨테이너를 다운로드할 수 있습니다.

00:18:53.000 --> 00:19:02.000
그리고 QUIC 연결의 동작을 훨씬 쉽게 성찰할 수 있는 다양한 오픈 소스 시각화가 있습니다.

00:19:02.000 --> 00:19:08.000
오늘, 우리는 HTTP/3이 HTTP 트래픽에 제공하는 개선 사항을 조사했습니다.

00:19:08.000 --> 00:19:22.000
클라이언트에서는 최신 네트워킹 API 사용자의 경우 이미 기본적으로 켜져 있으므로 서버에서 HTTP/3을 활성화하여 변화하는 네트워크 조건에 대한 향상된 성능과 복원력을 활용할 수 있습니다.

00:19:22.000 --> 00:19:35.000
사용자 지정, 비HTTP 네트워킹 프로토콜을 사용하는 경우, Network.framework에 내장된 새로운 다중화 프로토콜 지원을 사용하여 NWConnectionGroup과 QUIC 연결을 만드세요.

00:19:35.000 --> 00:19:43.000
그리고 어떤 프로토콜을 사용하든, 새로운 디버깅 도구를 사용하여 차세대 네트워킹 프로토콜의 놀라운 이점을 시각화할 수 있습니다.

00:19:43.000 --> 00:19:44.000
봐줘서 고마워.

00:19:44.000 --> 23:59:59.000
♪

