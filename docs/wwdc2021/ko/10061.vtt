WEBVTT

00:00:02.000 --> 00:00:10.000
도나: 안녕.

00:00:10.000 --> 00:00:13.000
저는 도나 톰이고, 텍스트킷 엔지니어입니다.

00:00:13.000 --> 00:00:17.000
내 동료 크리스 윌모어는 나중에 이 비디오에서 나와 함께 할 것이다.

00:00:17.000 --> 00:00:24.000
우리는 Apple의 차세대 텍스트 엔진인 TextKit 2를 소개합니다.

00:00:24.000 --> 00:00:33.000
TextKit 2가 무엇인지 이해하려면, TextKit 1이라고 부르는 원본 TextKit을 간략하게 검토해 봅시다.

00:00:33.000 --> 00:00:39.000
TextKit 1은 모든 Apple 플랫폼에서 텍스트 레이아웃과 디스플레이를 구동하는 텍스트 엔진입니다.

00:00:39.000 --> 00:00:49.000
UIKit과 AppKit의 텍스트 컨트롤은 TextKit 1을 사용하여 저장소를 관리하고 텍스트 콘텐츠의 레이아웃을 제어합니다.

00:00:49.000 --> 00:00:55.000
TextKit 1은 20년 전에 OpenStep의 시스템에 처음 등장했다.

00:00:55.000 --> 00:01:05.000
그것은 macOS 10.0에서 iOS 7, macOS 11 및 iOS 14에 이르기까지 수년에 걸쳐 우리와 함께 성장하고 발전했습니다.

00:01:05.000 --> 00:01:12.000
TextKit 1이 여전히 모든 Apple 장치에서 많은 필수 기능을 작동시킨다는 것은 꽤 놀랍습니다.

00:01:12.000 --> 00:01:17.000
기술 설계와 엔지니어링 원칙은 수십 년 동안 많이 바뀌었다.

00:01:17.000 --> 00:01:31.000
TextKit 1은 원래 원칙에 묶여 있기 때문에, 높은 수준의 성능을 제공하면서 최신 기술과 잘 통합되는 API를 제공하는 것은 수년에 걸쳐 더 어려워지고 있습니다.

00:01:31.000 --> 00:01:34.000
그것이 우리가 TextKit 2를 만든 이유입니다.

00:01:34.000 --> 00:01:40.000
TextKit 2는 미래 지향적인 디자인 원칙을 기반으로 구축된 Apple의 차세대 텍스트 엔진이다.

00:01:40.000 --> 00:01:42.000
그리고 그거 알아?

00:01:42.000 --> 00:01:45.000
당신은 이미 Mac에서 TextKit 2를 사용하고 있습니다.

00:01:45.000 --> 00:01:52.000
Big Sur에서, 우리는 무대 뒤에서 TextKit 2를 사용하기 위해 OS 전반에 걸쳐 많은 텍스트 구성 요소를 업데이트했습니다.

00:01:52.000 --> 00:01:57.000
큰 놀라움: 당신은 macOS 11 이후로 TextKit 2를 사용해 왔습니다.

00:01:57.000 --> 00:02:01.000
이제, 우리가 이것을 할 수 있는 아키텍처를 간략하게 검토해 봅시다.

00:02:01.000 --> 00:02:05.000
TextKit 2는 TextKit 1과 공존한다.

00:02:05.000 --> 00:02:13.000
이전 모델과 마찬가지로, TextKit 2는 Foundation, Quartz 및 Core Text 위에 구축되었습니다.

00:02:13.000 --> 00:02:18.000
UIKit과 AppKit의 텍스트 컨트롤은 TextKit 2 위에 구축됩니다.

00:02:18.000 --> 00:02:23.000
TextKit 2는 또한 전임자의 MVC 디자인을 느슨하게 유지한다.

00:02:23.000 --> 00:02:35.000
보기 부분은 UIKit 및 AppKit 프레임워크의 보기 개체에 남아 있으며, 오래된 친구인 NSTextStorage 및 NSLayoutManager의 새 버전이 있습니다.

00:02:35.000 --> 00:02:42.000
이러한 새로운 버전 외에도, 모델과 컨트롤러 계층에 합류하는 더 많은 새로운 클래스와 프로토콜이 있습니다.

00:02:42.000 --> 00:02:45.000
꽤 많은 것들이 있지만, 놀라지 마세요.

00:02:45.000 --> 00:02:52.000
이 새로운 구성 요소는 간단하고, 집중적이며, 함께 강력하다.

00:02:52.000 --> 00:03:02.000
그들은 당신이 텍스트로 하고 싶은 것을 더 쉽게 표현하고 시스템이 당신이 원하는 것을 어떻게 달성하는지에 대해 덜 걱정하게 합니다.

00:03:02.000 --> 00:03:07.000
이제 시스템에 대한 건축학적 관점을 얻었으니, 세부 사항에 대해 자세히 알아봅시다.

00:03:07.000 --> 00:03:21.000
먼저, 우리는 TextKit 2의 핵심 디자인 원칙과 이러한 원칙이 앱에서 텍스트의 저장, 레이아웃 및 표시를 사용자 정의하는 것에 대해 생각하는 방식을 어떻게 바꿀 것인지에 대해 논의할 것입니다.

00:03:21.000 --> 00:03:28.000
그 후, 크리스는 우리가 레시피 책에서 협업하기 위해 만든 TextKit 2 샘플 앱을 안내할 것입니다.

00:03:28.000 --> 00:03:34.000
이 앱은 새로운 TextKit 2 클래스를 사용하여 CALayers에서 텍스트를 배치하고 표시합니다.

00:03:34.000 --> 00:03:39.000
여기서, 당신은 디자인 원칙이 실제로 어떻게 작동하는지 배우게 될 것입니다.

00:03:39.000 --> 00:03:45.000
마지막으로, 우리는 TextKit 2용 앱을 현대화하기 위한 몇 가지 중요한 기술적 세부 사항을 다룰 것입니다.

00:03:45.000 --> 00:03:49.000
그럼 디자인 원칙부터 시작합시다.

00:03:49.000 --> 00:03:57.000
TextKit 2의 핵심 고급 설계 원칙은 정확성, 안전성 및 성능입니다.

00:03:57.000 --> 00:04:00.000
우리는 균형 잡힌 접근 방식을 취했다.

00:04:00.000 --> 00:04:07.000
세 가지 원칙 모두 중요하기 때문에, 우리가 그것들을 논의하는 순서에는 우선순위가 없다.

00:04:07.000 --> 00:04:14.000
이러한 높은 수준의 설계 원칙 각각은 시스템의 특정 설계 변화를 알려준다.

00:04:14.000 --> 00:04:19.000
정확성을 위해, TextKit 2는 글리프 처리를 추상화합니다.

00:04:19.000 --> 00:04:26.000
안전을 위해, TextKit 2는 가치 의미론에 더 중점을 둔다.

00:04:26.000 --> 00:04:33.000
그리고 성능을 위해, TextKit 2는 뷰포트 기반 레이아웃과 렌더링을 사용합니다.

00:04:33.000 --> 00:04:35.000
우리는 정확성으로 시작할 것이다.

00:04:35.000 --> 00:04:43.000
이 분야에서, 우리는 국제 텍스트에 대한 일관된 경험을 제공하기 위해 글리프 처리를 추상화했습니다.

00:04:43.000 --> 00:04:57.000
Apple 기기는 전 세계 어디에서나 사용되므로, 모든 언어와 스크립트의 텍스트에 대한 올바른 레이아웃, 렌더링 및 상호 작용을 제공하는 것이 정말 중요합니다.

00:04:57.000 --> 00:05:01.000
우리는 모든 사람이 장치에서 텍스트를 읽고 상호 작용할 수 있기를 바랍니다.

00:05:01.000 --> 00:05:10.000
그리고 일부 TextKit 1 API의 디자인은 보편적으로 올바른 방식으로 국제 텍스트로 작업하는 것을 어렵게 만든다.

00:05:10.000 --> 00:05:15.000
이유를 이해하려면, 우리는 먼저 글리프가 무엇인지 이해해야 한다.

00:05:15.000 --> 00:05:21.000
글리프는 다양한 수의 문자를 시각적으로 표현한 것이다.

00:05:21.000 --> 00:05:30.000
많은 서양 언어에서, 하나의 글리프는 보통 하나의 문자를 나타내지만, 이것이 항상 사실인 것은 아니다.

00:05:30.000 --> 00:05:35.000
단일 문자를 나타내는 여러 개의 글리프를 가질 수도 있고, 그 반대일 수도 있습니다.

00:05:35.000 --> 00:05:40.000
하나의 글리프는 여러 문자를 나타낼 수 있다.

00:05:40.000 --> 00:05:46.000
여러 문자를 나타내는 데 사용되는 이 단일 글리프는 합자라고 불린다.

00:05:46.000 --> 00:05:52.000
서양 언어에는 합자가 너무 많지 않으며, 보통 텍스트의 가독성에 영향을 미치지 않는다.

00:05:52.000 --> 00:05:56.000
당신은 여전히 합자 없이도 잘 읽을 수 있습니다.

00:05:56.000 --> 00:05:59.000
하지만 그것은 모든 언어에서 사실이 아니다.

00:05:59.000 --> 00:06:06.000
아랍어와 데바나가리와 같은 스크립트는 많은 합자를 사용하며, 가독성에 영향을 미친다.

00:06:06.000 --> 00:06:09.000
아랍어 스크립트로 이 단어를 확인하세요.

00:06:09.000 --> 00:06:12.000
그것은 "순간"을 의미하는 우르두어 단어이다.

00:06:12.000 --> 00:06:17.000
이제 잠시 시간을 내어 이 두 렌더링을 비교하세요.

00:06:17.000 --> 00:06:23.000
오른쪽에 합자로 그려진 전체 단어는 왼쪽의 개별 문자와 매우 다르게 보인다.

00:06:23.000 --> 00:06:32.000
그 언어의 원주민 독자들은 왼쪽에 있는 버전을 읽을 수 없다고 생각할 것이다.

00:06:32.000 --> 00:06:38.000
TextKit 1의 많은 API는 글리프 인덱스 또는 범위로 작업해야 합니다.

00:06:38.000 --> 00:06:47.000
예를 들어, 일부 텍스트의 경계 사각형을 얻으려면, 원하는 텍스트의 글리프 범위를 알아야 합니다.

00:06:47.000 --> 00:06:53.000
텍스트가 서양 언어로 되어 있다면, 올바른 글리프 범위를 알아내는 것은 나쁘지 않다.

00:06:53.000 --> 00:07:01.000
이 영어 예시에서, 텍스트의 처음 네 문자에 대한 글리프 범위를 찾는 것은 꽤 쉽다.

00:07:01.000 --> 00:07:07.000
이제 인도의 수백만 명의 사람들이 사용하는 대본과 언어인 칸나다어를 생각해 보세요.

00:07:07.000 --> 00:07:15.000
그것은 많은 합자를 사용할 뿐만 아니라, 글리프는 모든 종류의 흥미로운 방법으로 재정렬되고 결합될 수 있다.

00:07:15.000 --> 00:07:25.000
"10월"을 의미하는 이 칸나다 단어는 문자 인덱스 4에서 분할 모음을 특징으로 하므로 두 개의 글리프로 나뉩니다.

00:07:25.000 --> 00:07:34.000
그런 다음 왼쪽에 있는 것은 두 개의 합자가 적용되기 전에 문자 1과 2를 나타내는 글리프 사이에서 재정렬됩니다.

00:07:34.000 --> 00:07:42.000
인덱스 3의 문자를 나타내는 글리프도 결합 형태로 대체된다.

00:07:42.000 --> 00:07:46.000
마지막 단어에서, 그것은 갈라진 모음의 글리프 중 하나 아래에 그려져 있다.

00:07:46.000 --> 00:07:52.000
이제, 만약 네가 내가 방금 말한 것을 하나도 이해하지 못했다면, 그건 완전히 괜찮아.

00:07:52.000 --> 00:07:59.000
이것들은 당신이 앱 구축에 집중할 수 있도록 프레임워크가 당신을 위해 처리해야 하는 세부 사항입니다.

00:07:59.000 --> 00:08:06.000
요점은, 이와 같은 텍스트의 처음 네 문자의 글리프 범위를 찾을 수 없다는 것이다.

00:08:06.000 --> 00:08:12.000
그 네 개의 문자를 나타내는 단일 글리프 범위는 없다.

00:08:12.000 --> 00:08:23.000
그리고 많은 TextKit 1 API는 글리프 범위가 필요하기 때문에, 이러한 API를 사용하면 이와 같은 복잡한 스크립트에 대한 레이아웃과 렌더링을 잠재적으로 중단할 수 있습니다.

00:08:23.000 --> 00:08:27.000
그리고 그것이 TextKit 2가 글리프 처리를 추상화하는 이유입니다.

00:08:27.000 --> 00:08:35.000
TextKit 2는 코어 텍스트로 모든 텍스트를 렌더링하므로 복잡한 스크립트에 대한 올바른 렌더링을 자동으로 얻을 수 있습니다.

00:08:35.000 --> 00:08:39.000
TextKit 2로 글리프를 전혀 관리할 필요가 없습니다.

00:08:39.000 --> 00:08:45.000
대신, 텍스트 레이아웃과 상호 작용을 제어하기 위해 더 높은 수준의 객체를 사용합니다.

00:08:45.000 --> 00:08:50.000
더 높은 수준의 객체 중 하나인 NSTextSelection을 만나보세요.

00:08:50.000 --> 00:09:03.000
그것은 세분성, 친화력 및 선택을 구성하는 텍스트의 단절된 범위와 같은 텍스트 선택을 나타내는 데 필요한 모든 컨텍스트를 포함합니다.

00:09:03.000 --> 00:09:11.000
NSTextSelection의 이러한 속성은 읽기 전용이므로, 선택 객체의 인스턴스를 수정하여 변경하지 않습니다.

00:09:11.000 --> 00:09:27.000
대신, NSTextSelectionNavigation의 인스턴스를 사용하여 텍스트 선택에 대한 작업을 수행하고, 결과 선택을 나타내는 NSTextSelection의 새로운 인스턴스를 받습니다.

00:09:27.000 --> 00:09:39.000
탐색 대상에게 화면의 한 지점에서 탭 또는 마우스 다운 이벤트로 인한 선택을 요청하거나 앞으로 또는 뒤로 탐색하여 새로운 선택을 얻을 수 있습니다.

00:09:39.000 --> 00:09:49.000
이것은 선택을 한 단어로 확장하고 올바른 결과를 얻고, 오른쪽에서 왼쪽 언어의 양방향 텍스트를 고려하는 것과 같은 일을 더 쉽게 할 수 있게 해준다.

00:09:49.000 --> 00:09:54.000
이제 저는 이 새로운 선택 API에 대한 흥미로운 것에 당신의 관심을 불러일으키고 싶습니다.

00:09:54.000 --> 00:09:57.000
이 방법은 NSTextLocation을 취한다.

00:09:57.000 --> 00:10:02.000
이것은 TextKit 2의 또 다른 새로운 객체이다.

00:10:02.000 --> 00:10:06.000
NSTextLocation과 NSTextRange를 만나보세요.

00:10:06.000 --> 00:10:15.000
이것들은 서브클래스할 필요가 없다는 점을 제외하고는 UIKit의 UITextPosition 및 UITextRange 클래스와 매우 유사합니다.

00:10:15.000 --> 00:10:22.000
대부분의 경우, TextKit 2에서 기본 위치와 범위 개체를 사용할 수 있습니다.

00:10:22.000 --> 00:10:31.000
정수 대신 객체를 사용하면 범위가 서로 상대적인 위치 측면에서 정의되기 때문에 더 표현력이 뛰어난 문서 모델을 만들 수 있습니다.

00:10:31.000 --> 00:10:36.000
HTML 문서 객체 모델은 이것의 좋은 예이다.

00:10:36.000 --> 00:10:45.000
중첩된 요소가 있기 때문에, 위치는 문서의 절대 위치와 보이는 텍스트의 위치를 모두 나타내야 합니다.

00:10:45.000 --> 00:10:49.000
이것은 단일 숫자 인덱스로 표현할 수 없습니다.

00:10:49.000 --> 00:10:52.000
그리고 그건 정확성을 위한 거야.

00:10:52.000 --> 00:10:54.000
다음은 안전입니다.

00:10:54.000 --> 00:11:07.000
이 분야에서, 우리는 Swift 및 SwiftUI와 같은 기술의 목표에 더 잘 맞추기 위해 가치 의미론에 더 중점을 둔 TextKit 2를 설계했습니다.

00:11:07.000 --> 00:11:12.000
그리고 내가 "가치 의미론"이라고 말할 때, 나는 가치 유형에 대해 말하는 것이 아니다.

00:11:12.000 --> 00:11:18.000
우리는 NSLayoutManager를 구조체로 만들지 않았다.

00:11:18.000 --> 00:11:23.000
값 유형은 데이터의 고유한 복사본을 유지하여 해당 데이터의 돌연변이를 방지합니다.

00:11:23.000 --> 00:11:30.000
이것은 의도하지 않은 공유와 관련 부작용을 제거하여 코드를 더 안전하고 안정적으로 만듭니다.

00:11:30.000 --> 00:11:35.000
하지만 가치 유형이 이 혜택을 얻을 수 있는 유일한 방법은 아니다.

00:11:35.000 --> 00:11:43.000
불변 클래스는 초기화 후 변경할 수 없는 속성을 가지고 있으며, 이는 또한 데이터의 돌연변이를 방지합니다.

00:11:43.000 --> 00:11:50.000
이 클래스들은 값 유형처럼 행동하기 때문에, 우리는 그것들을 값 의미론을 가지고 있다고 부른다.

00:11:50.000 --> 00:11:57.000
이러한 객체 중 하나의 데이터를 변경하려면, 원래 인스턴스를 대체하기 위해 새로운 인스턴스를 만들어야 합니다.

00:11:57.000 --> 00:12:03.000
그리고 TextKit 2의 많은 수업은 이런 식으로 설계되었습니다.

00:12:03.000 --> 00:12:09.000
이 디자인 변경의 이점을 설명하기 위해, TextKit 1의 디자인에 대한 기억을 새롭게 합시다.

00:12:09.000 --> 00:12:15.000
저장소에서 화면으로의 텍스트 흐름은 이렇게 작동했다.

00:12:15.000 --> 00:12:27.000
텍스트 저장소에 대한 업데이트는 레이아웃 관리자에게 통보한 다음 글리프를 생성하고, 배치하고, 보기에 직접 그릴 것입니다.

00:12:27.000 --> 00:12:37.000
글리프를 뷰에 직접 그리는 이러한 접근 방식을 사용하면, 사용자 지정 드로잉을 위한 공간을 만들기 위해 텍스트를 분리하는 위치를 파악하기가 어렵습니다.

00:12:37.000 --> 00:12:45.000
내 말이 무슨 뜻인지 이해하려면, 레시피에 대한 몇 가지 의견을 남긴 샘플 앱에서 이 몰래 엿보기 스크린샷을 확인하세요.

00:12:45.000 --> 00:12:56.000
주석이 언급하는 레시피 바로 아래에 어떻게 나타나는지 주목하세요. 그리고 그것은 이 뚜렷한 거품 모양의 남색 배경과 흰색 텍스트로 그려져 있습니다.

00:12:56.000 --> 00:13:04.000
올바른 장소에 주석을 삽입하고 나머지 텍스트와 다르게 보이게 하려면 어떤 접근 방식을 취해야 할까요?

00:13:04.000 --> 00:13:21.000
레시피 텍스트를 의미 있는 단위 또는 요소로 나누고, 각 주석을 자체 요소에 넣고, 주석을 그리는 방법에 대한 지침을 제공하면서 관련된 레시피 뒤에 각 주석을 배치함으로써 이것을 할 것으로 예상할 수 있습니다.

00:13:21.000 --> 00:13:25.000
TextKit 1을 사용하면 현실이 상당히 다르다.

00:13:25.000 --> 00:13:37.000
글리프 인덱스를 찾고, 글리프가 그래페인 클러스터의 중간에 있지 않은지 확인하고, 글리프 인덱스를 조정하고, 줄 간격을 변경하고, 선 조각 지오메트리를 사용자 정의하는 것과 같은 많은 세부 사항에 대해 걱정해야 합니다.

00:13:37.000 --> 00:13:40.000
그리고 이러한 세부 사항은 당신이 하려고 하는 것과 관련이 없습니다.

00:13:40.000 --> 00:13:46.000
그래서 TextKit 2를 통해, 우리는 기대를 현실로 만드는 것을 목표로 하고 있습니다.

00:13:46.000 --> 00:13:52.000
우리는 이와 같은 접근 방식을 가능하게 하기 위해 시스템을 통해 텍스트의 흐름을 변경했습니다.

00:13:52.000 --> 00:13:56.000
TextKit 2에서 그 흐름이 작동하는 방식은 다음과 같습니다.

00:13:56.000 --> 00:14:03.000
텍스트 저장소에 대한 업데이트는 콘텐츠 관리자라는 새로운 객체를 거칩니다.

00:14:03.000 --> 00:14:09.000
콘텐츠 관리자는 텍스트를 요소로 나누고 추적합니다.

00:14:09.000 --> 00:14:16.000
레이아웃 시간이 되면, 텍스트 레이아웃 관리자는 콘텐츠 관리자에게 요소를 요청합니다.

00:14:16.000 --> 00:14:27.000
그런 다음 텍스트 레이아웃 관리자는 요소를 텍스트 컨테이너에 배치하고 레이아웃 및 위치 정보를 포함하는 레이아웃 조각을 생성합니다.

00:14:27.000 --> 00:14:40.000
표시할 시간이 되면, 레이아웃 조각은 뷰이든 레이어이든 원하는 렌더링 표면에서 조각의 위치와 레이아웃을 조정하는 ViewportLayoutController로 전달됩니다.

00:14:40.000 --> 00:14:44.000
아시다시피, 이 과정에는 많은 새로운 물건들이 관련되어 있습니다.

00:14:44.000 --> 00:14:50.000
그리고 이것이 가치 의미론에 중점을 두는 곳이다.

00:14:50.000 --> 00:15:02.000
올바른 지점에서 시스템에 연결하고 값 의미론을 사용하는 개체에서 필요한 정보를 얻어 텍스트의 레이아웃과 표시를 제어할 수 있습니다.

00:15:02.000 --> 00:15:10.000
변경하려면, 원하는 변경 사항으로 값 객체의 새 인스턴스를 만들고 시스템에 다시 제공합니다.

00:15:10.000 --> 00:15:15.000
시스템은 레이아웃과 디스플레이를 위해 대체 개체의 값을 사용합니다.

00:15:15.000 --> 00:15:21.000
이제, 이 새로운 물체들을 만나고 당신이 그것들을 받거나 교체할 수 있는 시스템의 다른 지점을 식별해 봅시다.

00:15:21.000 --> 00:15:25.000
우리는 저장 물건부터 시작할 것이다.

00:15:25.000 --> 00:15:28.000
NSTextElement를 만나보세요.

00:15:28.000 --> 00:15:31.000
요소는 당신의 문서의 구성 요소입니다.

00:15:31.000 --> 00:15:38.000
각 요소는 콘텐츠의 일부를 나타내며 문서의 위치를 설명하는 범위를 포함합니다.

00:15:38.000 --> 00:15:41.000
그리고 요소들은 가치 의미를 가지고 있다.

00:15:41.000 --> 00:15:48.000
범위를 포함한 그들의 속성은 변경할 수 없으며 요소를 만든 후에는 변경할 수 없습니다.

00:15:48.000 --> 00:15:55.000
문서를 일련의 캐릭터가 아닌 일련의 요소로 모델링하는 것은 우리에게 훨씬 더 많은 힘을 준다.

00:15:55.000 --> 00:16:07.000
우리는 텍스트 단락, 첨부 파일 또는 기타 사용자 지정 유형이든 주어진 요소가 어떤 종류의 콘텐츠를 나타내는지 쉽게 구별할 수 있는 능력을 얻습니다.

00:16:07.000 --> 00:16:13.000
그리고 우리는 그들의 유형에 따라 요소를 배치하는 방법에 대한 결정을 내릴 수 있다.

00:16:13.000 --> 00:16:16.000
이제 NSTextContentManager를 만나자.

00:16:16.000 --> 00:16:25.000
콘텐츠 관리자는 텍스트 콘텐츠에서 요소를 생성하는 방법을 알고 있으며 전체 문서 내에서 해당 요소의 범위를 추적합니다.

00:16:25.000 --> 00:16:34.000
또한 백업 저장소와 함께 작업하는 방법과 백업 저장소의 콘텐츠가 변경될 때 업데이트된 범위로 새로운 요소를 생성하는 방법을 알고 있습니다.

00:16:34.000 --> 00:16:38.000
콘텐츠 관리자를 백킹 스토어의 래퍼로 생각하세요.

00:16:38.000 --> 00:16:46.000
콘텐츠 관리자는 원시 데이터를 요소로 변환하기 위한 인터페이스를 제공합니다.

00:16:46.000 --> 00:16:56.000
NSTextContentManager와 NSTextElement는 모두 추상적인 유형이므로, 사용자 지정 문서 모델이나 사용자 지정 백업 저장소를 사용해야 하는 경우 서브클래스할 수 있습니다.

00:16:56.000 --> 00:17:00.000
헤더와 문서는 이것을 하는 방법에 대한 지침을 제공한다.

00:17:00.000 --> 00:17:05.000
하지만 대부분의 경우, TextKit 2가 제공하는 기본 것을 사용할 수 있습니다.

00:17:05.000 --> 00:17:09.000
NSTextContentStorage와 NSTextParagraph를 만나보세요.

00:17:09.000 --> 00:17:14.000
이것들은 기본 콘텐츠 관리자와 요소 유형입니다.

00:17:14.000 --> 00:17:21.000
NSTextContentStorage는 NSTextStorage를 백업 저장소로 사용하는 콘텐츠 관리자입니다.

00:17:21.000 --> 00:17:29.000
텍스트 저장소의 내용을 NSTextParagraph의 인스턴스인 단락 요소로 나누는 방법을 알고 있다.

00:17:29.000 --> 00:17:37.000
NSTextContentStorage는 또한 텍스트 저장소의 텍스트가 변경될 때 업데이트된 단락 요소를 생성하는 방법을 알고 있습니다.

00:17:37.000 --> 00:17:40.000
이것은 나를 중요한 지점으로 이끈다.

00:17:40.000 --> 00:17:48.000
기본 텍스트 저장소를 변경할 때, 이 performEditingTransaction 방법으로 업데이트를 래핑해야 합니다.

00:17:48.000 --> 00:17:55.000
이것은 TextKit 2 시스템의 다른 부분에 변경 사항이 통보되도록 합니다.

00:17:55.000 --> 00:18:02.000
전체 NSTextContentManager 하위 클래스를 구현하지 않고도 콘텐츠 저장소 위임으로 멋진 일을 할 수 있습니다.

00:18:02.000 --> 00:18:12.000
이 비디오의 뒷부분에서 크리스는 콘텐츠 대리자를 사용하여 텍스트 저장소를 수정하지 않고 주석 글꼴과 색상을 변경하는 방법과 주석을 완전히 숨기는 방법을 다룰 것이다.

00:18:12.000 --> 00:18:16.000
그러니 더 자세한 내용은 계속 지켜봐 주세요.

00:18:16.000 --> 00:18:17.000
알았어.

00:18:17.000 --> 00:18:22.000
이제 우리는 TextKit 2가 텍스트 콘텐츠에서 요소를 만드는 방법을 이해합니다.

00:18:22.000 --> 00:18:26.000
그것은 우리의 새로운 접근 방식의 처음 두 단계를 처리한다.

00:18:26.000 --> 00:18:35.000
콘텐츠 저장소는 자동으로 텍스트를 단락 요소로 나누며, 새 주석을 위한 새 단락을 만드는 방법을 알고 있습니다.

00:18:35.000 --> 00:18:41.000
다음으로, 마지막 두 단계를 어떻게 완수할 수 있는지 알아봅시다: 의견의 위치와 표시.

00:18:41.000 --> 00:18:47.000
흐름 다이어그램으로 돌아가서, 우리는 코멘트 요소에 대한 레이아웃 정보를 얻어야 합니다.

00:18:47.000 --> 00:18:50.000
이러한 작업을 수행하는 데 도움이 되는 새로운 레이아웃 개체가 있습니다.

00:18:50.000 --> 00:18:53.000
지금 그들을 만나자.

00:18:53.000 --> 00:18:56.000
NSTextLayoutManager를 만나보세요.

00:18:56.000 --> 00:19:00.000
텍스트 레이아웃 관리자는 텍스트 레이아웃 프로세스를 제어합니다.

00:19:00.000 --> 00:19:12.000
NSTextLayoutManager는 TextKit 1의 이전 NSLayoutManager와 유사하며 한 가지 주요 차이점이 있습니다. NSTextLayoutManager는 글리프를 다루지 않습니다.

00:19:12.000 --> 00:19:23.000
대신, NSTextLayoutManager는 텍스트 요소를 가져와 텍스트 컨테이너에 배치하고, 해당 요소에 대한 레이아웃 조각을 생성합니다.

00:19:23.000 --> 00:19:27.000
텍스트 요소에 대한 레이아웃 정보를 얻기 위해 레이아웃 조각으로 작업합니다.

00:19:27.000 --> 00:19:31.000
이제 레이아웃 조각에 대해 알아봅시다.

00:19:31.000 --> 00:19:34.000
NSTextLayoutFragment를 만나보세요.

00:19:34.000 --> 00:19:39.000
레이아웃 조각에는 하나 이상의 텍스트 요소에 대한 레이아웃 정보가 포함되어 있습니다.

00:19:39.000 --> 00:19:45.000
요소와 마찬가지로, 그들은 가치 의미론을 사용하며 그들의 속성은 불변이다.

00:19:45.000 --> 00:19:56.000
따라서 텍스트 레이아웃 관리자는 각 주석 요소에 대한 레이아웃 조각을 만든 다음 레이아웃 조각의 정보를 사용하여 배치하고 표시할 수 있습니다.

00:19:56.000 --> 00:20:10.000
레이아웃 조각은 세 가지 속성을 통해 레이아웃 정보를 전달합니다: textLineFragments 배열, layoutFragmentFrame 및 renderingSurfaceBounds.

00:20:10.000 --> 00:20:17.000
레이아웃을 사용자 정의하거나 변경하려면, 이러한 각 속성에서 얻는 정보를 이해하는 것이 필수적입니다.

00:20:17.000 --> 00:20:20.000
그래서 우리는 다음에 그것을 검토할 것이다.

00:20:20.000 --> 00:20:24.000
첫 번째 부동산의 경우, 우리는 NSTextLineFragment를 만날 것이다.

00:20:24.000 --> 00:20:30.000
선 조각은 레이아웃 조각의 각 텍스트 줄에 대한 측정 정보를 포함합니다.

00:20:30.000 --> 00:20:39.000
이것들은 특정 선에 대한 기하학적 정보를 얻거나 레이아웃 조각의 선 수를 세는 데 유용합니다.

00:20:39.000 --> 00:20:48.000
두 번째 속성인 레이아웃 조각 프레임은 레이아웃 조각의 텍스트가 텍스트 컨테이너 영역 안에 어떻게 배치되는지 설명합니다.

00:20:48.000 --> 00:20:55.000
TextKit 2에서 텍스트 레이아웃은 기본적으로 컨테이너 내의 레이아웃 조각 프레임을 쌓는 것이다.

00:20:55.000 --> 00:20:57.000
이 프레임들을 타일처럼 생각해 보세요.

00:20:57.000 --> 00:21:05.000
이 시스템은 텍스트 컨테이너 영역을 타일로 나누고 있으며, 각 레이아웃 조각은 단일 타일이다.

00:21:05.000 --> 00:21:10.000
빈 선은 다이어그램과 같이 자체 레이아웃 조각 프레임을 가지고 있다.

00:21:10.000 --> 00:21:22.000
일반적으로 레이아웃 프래그먼트 프레임은 프래그먼트 콘텐츠 근처에 UI의 다른 뷰를 배치하거나 텍스트 콘텐츠의 총 높이를 계산하는 데 유용합니다.

00:21:22.000 --> 00:21:27.000
이제, 이 프레임은 텍스트 자체를 그리는 데 필요한 공간을 정확하게 나타내지 않습니다.

00:21:27.000 --> 00:21:31.000
그 정보는 세 번째 재산에서 나온다.

00:21:31.000 --> 00:21:37.000
렌더링 표면 경계는 텍스트를 그리는 데 필요한 영역을 설명한다.

00:21:37.000 --> 00:21:43.000
이것은 뷰의 좌표 공간에서 텍스트의 크기를 얻기 위해 사용하고 싶은 직사각형입니다.

00:21:43.000 --> 00:21:49.000
그리고 이것은 텍스트가 조각 프레임의 가장자리를 오버슈할 수 있기 때문에 레이아웃 조각 프레임과 다릅니다.

00:21:49.000 --> 00:21:56.000
이것은 발음 구별 부호 또는 여기에 표시된 바와 같이 이탤릭체 글꼴의 긴 디센더와 함께 발생합니다.

00:21:56.000 --> 00:22:04.000
J의 왼쪽 하단 가장자리가 레이아웃 조각 프레임에서 어떻게 조금 튀어나오는지 주목하세요.

00:22:04.000 --> 00:22:09.000
그것은 그렇게 눈에 튀지 않기 때문에, 여기에 더 극단적인 예가 있다.

00:22:09.000 --> 00:22:15.000
Zapfino와 같은 일부 글꼴은 타이포그래피 경계를 훨씬 벗어나는 글리프를 가지고 있다.

00:22:15.000 --> 00:22:21.000
이 경우 렌더링 표면 경계는 레이아웃 조각 프레임보다 훨씬 클 것이다.

00:22:21.000 --> 00:22:32.000
이제 레이아웃 조각이 제공하는 레이아웃 정보를 이해했으므로, 조금 백업하고 이 정보를 사용하여 텍스트 요소의 레이아웃을 사용자 정의하는 방법에 대해 이야기해 봅시다.

00:22:32.000 --> 00:22:40.000
레이아웃 조각은 변경할 수 없기 때문에, 조각의 레이아웃 정보를 직접 변경할 수 없습니다.

00:22:40.000 --> 00:22:53.000
흐름 다이어그램으로 돌아가서, 우리는 레이아웃 프로세스에 연결하고 우리가 바꾸고 싶은 정보로 NSTextLayoutFragment의 새로운 인스턴스를 만들어야 합니다.

00:22:53.000 --> 00:23:00.000
그리고 NSTextLayoutManager에서 이 위임 방법을 사용하여 레이아웃 프로세스에 연결됩니다.

00:23:00.000 --> 00:23:07.000
이 메서드는 텍스트 레이아웃 관리자가 요소에서 레이아웃 조각을 생성할 때 레이아웃 프로세스 중에 호출됩니다.

00:23:07.000 --> 00:23:15.000
여기서 당신은 요소에 대한 자신만의 레이아웃 조각을 만들 기회가 있습니다.

00:23:15.000 --> 00:23:19.000
그것은 논평 문제에 대한 우리의 접근 방식의 마지막 두 단계를 처리한다.

00:23:19.000 --> 00:23:31.000
우리는 NSTextLayoutFragment의 하위 클래스를 사용하고 텍스트 레이아웃 관리자 대리인에 사용자 지정 조각의 인스턴스를 제공하여 주석 레이아웃 조각의 위치 및 사용자 지정 도면을 처리할 것입니다.

00:23:31.000 --> 00:23:37.000
이 비디오의 뒷부분에서, 크리스는 이것이 우리의 샘플 앱에서 어떻게 이루어지는지 보여줄 것이다.

00:23:37.000 --> 00:23:38.000
그리고 그게 안전이야.

00:23:38.000 --> 00:23:42.000
이제 공연으로 넘어가자.

00:23:42.000 --> 00:23:46.000
성능은 모든 텍스트 엔진의 가장 큰 과제 중 하나이다.

00:23:46.000 --> 00:23:59.000
TextKit 2는 각각 몇 줄에 불과한 라벨을 빠르게 렌더링하는 것부터 대화형 속도로 스크롤되는 수백 메가바이트의 문서를 배치하는 것까지 믿을 수 없을 정도로 광범위한 시나리오에서 매우 빠릅니다.

00:23:59.000 --> 00:24:14.000
그리고 이러한 시나리오의 경우, 이러한 정말 큰 문서를 가변 속도로 스크롤할 때, 인접하지 않은 텍스트 레이아웃은 훌륭한 성능을 위해 절대적으로 필수적입니다.

00:24:14.000 --> 00:24:19.000
인접한 레이아웃과 인접하지 않은 레이아웃의 차이점을 검토해 봅시다.

00:24:19.000 --> 00:24:27.000
이 다이어그램은 노란색 직사각형이 화면에서 보이는 콘텐츠 영역을 나타내는 문서를 보여줍니다.

00:24:27.000 --> 00:24:35.000
연속 레이아웃은 문서의 시작 부분에서 시작하여 텍스트의 시작부터 끝까지 순서대로 진행됩니다.

00:24:35.000 --> 00:24:44.000
따라서 문서 중간의 어느 지점으로 스크롤하면, 인접한 레이아웃은 그 시점 이전에 온 모든 텍스트에 대한 레이아웃을 수행합니다.

00:24:44.000 --> 00:24:50.000
여기에는 처음부터 끝까지 화면에서 스크롤된 모든 텍스트가 포함됩니다.

00:24:50.000 --> 00:24:57.000
그리고 텍스트가 많다면, 성능이 느려질 수 있으며 스크롤할 때 애니메이션 딸꾹질이 발생할 수 있습니다.

00:24:57.000 --> 00:25:01.000
최악의 경우, 그것은 매달릴 수 있다.

00:25:01.000 --> 00:25:11.000
대조적으로, 인접하지 않은 레이아웃은 우리가 그 앞에 오는 부분을 배치하지 않고 문서 내의 어느 곳에나 텍스트 조각을 배치할 수 있다는 것을 의미합니다.

00:25:11.000 --> 00:25:18.000
이제 문서의 가운데로 스크롤하면, 보이는 영역에 대한 레이아웃이 바로 발생합니다.

00:25:18.000 --> 00:25:30.000
이것은 화면에 보이는 텍스트 부분과 추가 오버 스크롤 영역에 대해서만 레이아웃을 수행하여 성능을 향상시켜 더 부드러운 스크롤 경험을 제공합니다.

00:25:30.000 --> 00:25:35.000
그리고 TextKit 2의 레이아웃은 항상 인접하지 않습니다.

00:25:35.000 --> 00:25:41.000
대조적으로, 인접하지 않은 레이아웃은 TextKit 1에서 선택 사항입니다.

00:25:41.000 --> 00:25:46.000
NSLayoutManager의 부울 속성을 사용하여 활성화됩니다.

00:25:46.000 --> 00:25:57.000
이 API는 간단하지만, 간단하기 때문에 레이아웃 정보를 요청할 때 레이아웃 상태에 대한 정보를 표현할 수 없습니다.

00:25:57.000 --> 00:26:04.000
인접하지 않은 레이아웃은 문서의 다른 부분이 배치되면 나중에 변경될 수 있는 추정치에 의존한다.

00:26:04.000 --> 00:26:10.000
TextKit 1을 사용하면 인접하지 않은 레이아웃만 켜거나 끌 수 있습니다.

00:26:10.000 --> 00:26:20.000
문서의 어느 부분이 배치되는지 제어할 수 있는 기능이 없으며 레이아웃이 언제 완료되고 레이아웃 추정치가 실제 값으로 업데이트되는지 알 수 있는 방법이 없습니다.

00:26:20.000 --> 00:26:26.000
TextKit 2 API는 더 풍부하고 표현력이 풍부하다.

00:26:26.000 --> 00:26:36.000
TextKit 2는 보이는 콘텐츠 영역의 요소에 대한 일관된 레이아웃 정보를 제공하며 해당 보이는 영역의 레이아웃이 업데이트될 때 알려줍니다.

00:26:36.000 --> 00:26:39.000
이 지역은 뷰포트라고 불린다.

00:26:39.000 --> 00:26:48.000
뷰포트를 조정하거나 재배치하여 관리하고, 뷰포트 레이아웃 전, 도중, 후에 콜백을 받습니다.

00:26:48.000 --> 00:26:55.000
최적의 성능을 위해, 당신의 코드는 뷰포트 영역 내부의 레이아웃 정보 작업에 집중해야 합니다.

00:26:55.000 --> 00:27:02.000
가능한 경우 뷰포트 외부의 요소에 대한 레이아웃 정보를 요청하지 마세요.

00:27:02.000 --> 00:27:13.000
뷰포트 외부 요소의 레이아웃 정보는 해당 요소에 해당하는 텍스트 범위에 대한 레이아웃을 명시적으로 요청하지 않는 한 정확하지 않을 수 있습니다.

00:27:13.000 --> 00:27:19.000
이 통화는 특히 대용량 문서의 경우 비쌀 수 있다.

00:27:19.000 --> 00:27:28.000
이전 흐름도를 다시 살펴보면, 뷰포트를 관리하는 데 도움이 되는 또 다른 새로운 컨트롤러 클래스가 있습니다.

00:27:28.000 --> 00:27:31.000
NSTextViewportLayoutController를 만나보세요.

00:27:31.000 --> 00:27:35.000
이것은 뷰포트 레이아웃 정보에 대한 진실의 원천이다.

00:27:35.000 --> 00:27:42.000
뷰포트 영역 내의 요소에 대한 레이아웃 조각을 얻기 위해 텍스트 레이아웃 관리자와 대화합니다.

00:27:42.000 --> 00:27:48.000
텍스트 레이아웃 관리자의 속성을 통해 뷰포트 레이아웃 컨트롤러에 액세스할 수 있습니다.

00:27:48.000 --> 00:27:56.000
이제 뷰포트 레이아웃 컨트롤러를 만났으니, 뷰포트 레이아웃 프로세스에 참여하는 방법에 대해 이야기해 봅시다.

00:27:56.000 --> 00:28:16.000
뷰포트 레이아웃 컨트롤러는 뷰포트 레이아웃 프로세스 중에 대리인에 대한 세 가지 중요한 방법을 호출합니다: TextViewportLayoutController WillLayout, textViewportController configureRenderingSurface FortextLayoutFragment 및 textViewportLayoutController DidLayout.

00:28:16.000 --> 00:28:23.000
먼저, 뷰포트 레이아웃 컨트롤러는 뷰포트에 요소를 배치하기 전에 willLayout 메소드를 호출합니다.

00:28:23.000 --> 00:28:31.000
여기는 뷰나 레이어의 내용을 지우는 것과 같이 레이아웃을 준비하기 위한 설정 작업을 하는 곳입니다.

00:28:31.000 --> 00:28:39.000
다음으로, 뷰포트 레이아웃 컨트롤러는 뷰포트에 표시되는 모든 레이아웃 조각에 대해 configureRenderingSurface를 호출합니다.

00:28:39.000 --> 00:28:44.000
여기는 각 프래그먼트 뷰 또는 레이어의 지오메트리를 업데이트하는 곳입니다.

00:28:44.000 --> 00:28:54.000
마지막으로, 뷰포트 레이아웃 컨트롤러는 뷰포트에서 볼 수 있는 모든 레이아웃 조각을 레이아웃한 후 didLayout 메소드를 호출합니다.

00:28:54.000 --> 00:29:03.000
그리고 마지막 요소를 화면에 완전히 볼 수 있도록 뷰포트를 조정하려는 경우와 같이 뷰포트 레이아웃이 완료된 후 필요한 업데이트를 수행하는 곳입니다.

00:29:03.000 --> 00:29:05.000
그리고 그것은 공연을 위해 그것을 요약한다.

00:29:05.000 --> 00:29:10.000
이제 실제로 TextKit 2를 사용하는 방법을 보여주기 위해 Chris에게 넘겨줄게.

00:29:10.000 --> 00:29:11.000
고마워, 도나.

00:29:11.000 --> 00:29:18.000
우리는 TextKit 2를 사용하여 앱에서 텍스트를 배치하고 상호 작용할 수 있는 다양한 방법을 보여주는 샘플 앱을 작성했습니다.

00:29:18.000 --> 00:29:21.000
이 비디오에 사용된 샘플 코드를 다운로드할 수 있습니다.

00:29:21.000 --> 00:29:24.000
열어서 시도해 보자.

00:29:24.000 --> 00:29:31.000
우리는 이 협업 앱을 사용하여 레시피 책을 검토하여 점심으로 무엇을 만들고 싶은지 알아낼 수 있습니다.

00:29:31.000 --> 00:29:42.000
레시피를 스크롤하는 것은 예상대로 작동하지만, 무대 뒤에서 특별한 일이 일어나고 있다: 뷰포트에서 볼 수 있는 단락만 그려지고 있다.

00:29:42.000 --> 00:29:49.000
그리고 모든 단락이 같은 큰 표면에 렌더링되는 대신, 각 단락은 자체 레이어로 렌더링되고 있다.

00:29:49.000 --> 00:29:55.000
여기 도구 모음에서 경계 표시 버튼을 클릭하면, 이 색깔의 직사각형이 나타납니다.

00:29:55.000 --> 00:30:00.000
주황색 직사각형은 각 층의 경계를 보여준다.

00:30:00.000 --> 00:30:06.000
텍스트를 별도의 레이어로 그리면 재미있는 기능을 구현할 수 있습니다: 레시피에 대한 의견을 남길 수 있습니다.

00:30:06.000 --> 00:30:19.000
이제, 나는 계란 샌드위치가 꽤 좋다고 생각해, 그래서 나는 이 단락을 두 번 클릭하고 "이봐, 꽤 좋은 것 같아"라고 입력하고 Enter를 눌러 댓글을 삽입할 거야.

00:30:19.000 --> 00:30:23.000
방금 문서에 새 단락을 삽입했습니다.

00:30:23.000 --> 00:30:29.000
버블 배경은 BubbleLayoutFragment라고 불리는 NSTextLayoutFragment의 사용자 지정 하위 클래스에 의해 그려지고 있다.

00:30:29.000 --> 00:30:31.000
그것에 대한 자세한 내용은 나중에.

00:30:31.000 --> 00:30:39.000
특별한 것은, 내가 문서에 주석을 삽입할 때, 주석 아래의 모든 단락이 그것을 위한 공간을 만들기 위해 움직인다는 것이다.

00:30:39.000 --> 00:30:46.000
처음에 잡지 못했다면, 도구 모음에서 이 거북이 버튼을 클릭하여 슬로우 모드를 활성화할 것입니다.

00:30:46.000 --> 00:30:48.000
다른 댓글을 추가해 봅시다.

00:30:48.000 --> 00:30:52.000
"응, 오늘 점심으로 만들자."

00:30:52.000 --> 00:30:59.000
Enter를 누른 후, 주석은 그 아래의 문서에 추가되고, 그 아래의 모든 단락은 천천히 애니메이션된다.

00:30:59.000 --> 00:31:04.000
모든 댓글을 숨기려면, 도구 모음에서 댓글 전환 버튼을 클릭할 수 있습니다.

00:31:04.000 --> 00:31:08.000
이것은 실제로 기본 문서를 편집하는 것이 아니다.

00:31:08.000 --> 00:31:15.000
대신 레이아웃을 위한 텍스트 요소를 열거할 때 텍스트 콘텐츠 관리자에게 주석을 건너뛰도록 요청하는 것입니다.

00:31:15.000 --> 00:31:20.000
TextKit 2는 macOS에서와 마찬가지로 iOS에서도 잘 작동합니다.

00:31:20.000 --> 00:31:24.000
이것은 macOS 앱의 TextKit 2 부분을 iOS에서 재사용할 수 있다는 것을 의미합니다.

00:31:24.000 --> 00:31:28.000
아이패드에서 실행하자.

00:31:28.000 --> 00:31:35.000
우리는 이 부분을 사용하여 동일한 기능을 갖춘 협업 앱의 iOS 버전을 작성했습니다.

00:31:35.000 --> 00:31:43.000
나는 댓글을 남기기 위해 단락을 길게 누른 다음, "이봐, 좋은 생각이야"라고 타이핑하고 있어...

00:31:43.000 --> 00:31:46.000
그리고 엔터를 누르세요.

00:31:46.000 --> 00:31:53.000
macOS의 앱과 마찬가지로, 댓글 표시/숨기기 버튼을 탭하여 모든 댓글을 숨길 수 있습니다.

00:31:53.000 --> 00:31:59.000
저는 방금 TextKit 2를 사용하여 텍스트를 배치하고, 그리고, 상호 작용하는 앱을 살펴봤어요.

00:31:59.000 --> 00:32:05.000
이제 샘플 앱의 코드 중 일부와 TextKit 2가 어떻게 그것을 가능하게 하는지 살펴봅시다.

00:32:05.000 --> 00:32:23.000
이 앱은 TextKit 2가 제공하는 많은 기능을 보여주지만, 지금은 두 가지 영역에 집중하고 싶습니다: NSViewportLayoutController를 사용하여 뷰포트에서 텍스트를 배치하는 방법과 사용자 지정 숨기기 동작과 주석 렌더링을 구현하는 방법.

00:32:23.000 --> 00:32:41.000
텍스트 레이아웃 관리자가 변경되었거나, 컨테이너 크기가 변경되었거나, 문서의 이전에 보이지 않는 부분이 뷰포트로 이동했기 때문에 문서를 배치하려고 할 때, 뷰포트 레이아웃 대리인에서 textViewportLayout ControllerWillLayout을 호출합니다.

00:32:41.000 --> 00:32:48.000
우리는 여기에서 모든 텍스트 하위 레이어를 지우고 애니메이션 거래를 열기 위해 그것을 사용하고 있습니다.

00:32:48.000 --> 00:32:57.000
텍스트 레이아웃 관리자가 배치하는 각 텍스트 요소에 대해 textViewportLayoutController, configureRenderingSurfaceFor textLayoutFragment를 호출합니다.

00:32:57.000 --> 00:33:11.000
여기서 우리는 텍스트 레이아웃 조각을 표시하고, 지오메트리를 업데이트하고, 가능한 경우 새로운 위치로 애니메이션화하고, 뷰의 하위 레이어로 추가하는 레이어를 얻고 있습니다.

00:33:11.000 --> 00:33:17.000
레이아웃 관리자가 레이아웃을 마치면, textViewportLayout ControllerDidLayout을 호출할 것이다.

00:33:17.000 --> 00:33:28.000
우리는 애니메이션 거래를 커밋하고, 선택 하이라이트를 업데이트하고, 스크롤 엄지손가락이 올바르게 배치되도록 콘텐츠 크기를 업데이트합니다.

00:33:28.000 --> 00:33:30.000
이제 댓글에 대해 이야기해 봅시다.

00:33:30.000 --> 00:33:37.000
TextKit 2는 레이아웃 요소와 레이아웃 조각 생성을 사용자 정의하는 데 사용할 수 있는 몇 가지 후크를 제공합니다.

00:33:37.000 --> 00:33:48.000
문서에서 주석을 어떻게 받아들이고, 글꼴과 색상과 같은 사용자 지정 속성을 설정하고, 그 뒤에 거품을 그리는지 보여드리겠습니다.

00:33:48.000 --> 00:33:57.000
문서의 각 단락에 대해, 텍스트 콘텐츠 저장소는 대리인에게 해당 단락의 속성을 사용자 정의할 수 있는 기회를 제공합니다.

00:33:57.000 --> 00:34:07.000
구현에서, 우리는 기본 텍스트 저장소의 글꼴이나 색상을 변경할 필요 없이 주석에 사용자 지정 글꼴과 색상을 설정하고 있습니다.

00:34:07.000 --> 00:34:16.000
텍스트 콘텐츠 관리자는 또한 대리인에게 레이아웃 중에 텍스트 레이아웃 관리자에 표시할 텍스트 요소를 결정할 수 있는 기회를 제공합니다.

00:34:16.000 --> 00:34:20.000
텍스트 요소에 대해 false를 반환하면 표시되지 않습니다.

00:34:20.000 --> 00:34:29.000
여기서 우리는 기본 텍스트 저장소에서 실제로 삭제할 필요 없이 주석을 열거하지 않기로 선택하여 주석을 숨기고 있습니다.

00:34:29.000 --> 00:34:32.000
텍스트 레이아웃 관리자에도 대리인이 있다.

00:34:32.000 --> 00:34:47.000
textElement의 textLayoutManager, textLayoutFragmentFor 위치를 구현함으로써, 대리인은 주어진 NSTextElement에 대한 기본 NSTextLayoutFragment 인스턴스 대신 사용자 지정 텍스트 레이아웃 조각을 생성할 수 있습니다.

00:34:47.000 --> 00:34:59.000
이 경우, 주석을 나타내는 NSTextElement가 발생하면 NSTextLayoutFragment의 사용자 지정 하위 클래스인 BubbleLayoutFragment를 생성합니다.

00:34:59.000 --> 00:35:10.000
BubbleLayoutFragment는 NSTextLayoutFragment의 그리기 방법을 재정의하여 기본 클래스 구현을 호출하기 전에 배경 거품을 그립니다.

00:35:10.000 --> 00:35:17.000
텍스트는 이전에 설정한 사용자 지정 글꼴과 텍스트 색상으로 렌더링되고 있습니다.

00:35:17.000 --> 00:35:31.000
샘플 앱이 TextKit 2를 사용하여 뷰포트 기반 텍스트 애니메이션 레이아웃을 수행하는 방법과 텍스트 저장소의 사용자 지정 속성에서 사용자 지정 그리기에 이르기까지 다채로운 거품에서 주석을 렌더링하는 방법을 살펴봤습니다.

00:35:31.000 --> 00:35:50.000
그러나 텍스트 선택을 결정하기 위해 마우스 이벤트를 해석하고, 텍스트 선택 하이라이트를 렌더링하고, 문서의 특정 단락에 주석 팝오버를 배치하고, 문서 높이를 추정하는 것을 포함하여 TextKit 2가 제공하는 새로운 API를 활용하는 샘플 코드에 더 많은 것이 있습니다.

00:35:50.000 --> 00:35:54.000
샘플 코드에서 이러한 모든 주제에 대한 추가 논의를 찾을 수 있습니다.

00:35:54.000 --> 00:35:58.000
도나에게 돌아가서 TextKit 2용 앱을 준비하는 것에 대해 이야기합시다.

00:35:58.000 --> 00:36:00.000
고마워, 크리스.

00:36:00.000 --> 00:36:05.000
그것은 TextKit 2가 실제로 어떻게 작동하는지 보여주는 환상적인 예이다.

00:36:05.000 --> 00:36:13.000
이제 TextKit 2가 무엇을 할 수 있는지 살펴보았으니, 앱 현대화를 위한 몇 가지 접근 방식에 대해 논의해 봅시다.

00:36:13.000 --> 00:36:21.000
우리가 지금까지 이야기한 모든 것은 일반적인 뷰나 레이어와 함께 사용할 자신만의 TextKit 2 스택을 만드는 데 적용됩니다.

00:36:21.000 --> 00:36:27.000
모든 새로운 클래스는 iOS 15의 UIKit과 macOS 12의 AppKit에서 사용할 수 있습니다.

00:36:27.000 --> 00:36:34.000
그래서 이 길을 가고 싶다면, 오늘 TextKit 2로 새로운 코드를 작성하기 시작할 수 있습니다.

00:36:34.000 --> 00:36:46.000
반면에, 많은 앱은 텍스트 보기와 같은 내장 텍스트 컨트롤을 사용하여 접근성 지원 및 선택 및 편집 서비스와 같은 모든 훌륭한 무료 기능을 활용합니다.

00:36:46.000 --> 00:36:51.000
이러한 컨트롤 중 일부는 이미 TextKit 2를 사용하도록 업데이트되었습니다.

00:36:51.000 --> 00:36:57.000
앱이 내장 컨트롤을 사용하는 경우, 알아야 할 몇 가지 추가 세부 사항이 있습니다.

00:36:57.000 --> 00:37:02.000
호환성을 유지하는 것은 당신만큼 우리에게도 중요합니다.

00:37:02.000 --> 00:37:11.000
TextKit 1은 내장된 텍스트 컨트롤의 필수적인 부분이기 때문에, 우리는 그것들을 사용하는 앱의 호환성을 유지하기 위해 많은 노력을 기울일 것입니다.

00:37:11.000 --> 00:37:19.000
이것이 일부 컨트롤만이 iOS 15와 macOS 12에서 TextKit 2를 자동으로 사용하는 이유입니다.

00:37:19.000 --> 00:37:26.000
또한, 일부 컨트롤은 이러한 OS 버전에서 TextKit 2를 사용하기 위해 추가 조치를 취해야 합니다.

00:37:26.000 --> 00:37:32.000
AppKit 개발자의 경우, NSTextView는 TextKit 2를 자동으로 사용하지 않습니다.

00:37:32.000 --> 00:37:40.000
NSTextView와 함께 TextKit 2를 사용하려면, 생성 시 프로그래밍 방식으로 선택해야 합니다.

00:37:40.000 --> 00:37:42.000
이게 그걸 하는 방법이야.

00:37:42.000 --> 00:37:46.000
먼저, 텍스트 레이아웃 관리자를 만드세요.

00:37:46.000 --> 00:37:49.000
다음으로, 텍스트 컨테이너를 만드세요.

00:37:49.000 --> 00:37:57.000
그런 다음 NSTextLayoutManager의 textContainer 속성을 사용하여 텍스트 컨테이너를 텍스트 레이아웃 관리자와 연결하십시오.

00:37:57.000 --> 00:38:05.000
마지막으로, 텍스트 컨테이너와 함께 지정된 이니셜라이저를 사용하여 NSTextView를 만드세요.

00:38:05.000 --> 00:38:08.000
이제 TextKit 2를 사용하는 텍스트 보기가 있습니다.

00:38:08.000 --> 00:38:15.000
NSTextView에서 새로운 속성으로 텍스트 레이아웃 관리자와 텍스트 콘텐츠 저장소에 액세스할 수 있습니다.

00:38:15.000 --> 00:38:18.000
조심해야 할 한 가지가 있다.

00:38:18.000 --> 00:38:25.000
NSTextView에는 NSLayoutManager를 얻고 설정할 수 있는 layoutManager 속성이 있다는 것을 기억하세요.

00:38:25.000 --> 00:38:32.000
NSLayoutManager는 TextKit 1 객체이며 TextKit 2 스택과 호환되지 않습니다.

00:38:32.000 --> 00:38:39.000
텍스트 보기는 레이아웃 관리자와 텍스트 레이아웃 관리자를 동시에 가질 수 없습니다.

00:38:39.000 --> 00:38:41.000
그래서 여기 거래가 있어.

00:38:41.000 --> 00:38:47.000
우리는 필요할 때 TextKit 1로 전환하는 NSTextView를 위한 특별한 호환성 모드를 추가했습니다.

00:38:47.000 --> 00:38:56.000
텍스트 보기는 이 모드를 사용해야 하는지 여부를 자동으로 감지하고 NSTextLayoutManager를 NSLayoutManager로 대체할 수 있습니다.

00:38:56.000 --> 00:39:03.000
최적의 성능을 위해, 텍스트 보기는 그 시점부터 호환성 모드로 유지될 것이다.

00:39:03.000 --> 00:39:15.000
TextKit 2를 선택하더라도, 텍스트 보기 또는 텍스트 컨테이너에서 layoutManager 속성을 명시적으로 호출하면 텍스트 보기가 자동으로 TextKit 1로 전환됩니다.

00:39:15.000 --> 00:39:24.000
텍스트 보기는 아직 지원되지 않는 텍스트 콘텐츠가 발생하거나 TextKit 1이 필요한 다른 조건을 감지하면 전환됩니다.

00:39:24.000 --> 00:39:28.000
그리고 이것은 현장 편집자에게도 일어날 수 있다.

00:39:28.000 --> 00:39:32.000
NSTextField의 필드 편집기는 기본적으로 TextKit 2를 사용합니다.

00:39:32.000 --> 00:39:45.000
하지만 텍스트 필드 서브클래스가 필드 편집기의 레이아웃 관리자에서 레이아웃 정보를 요청하는 경우, 필드 편집기는 해당 창의 모든 텍스트 필드에 대해 TextKit 1로 전환됩니다.

00:39:45.000 --> 00:39:50.000
시스템은 텍스트 보기가 TextKit 1로 전환되기 전후에 알림을 발행할 것입니다.

00:39:50.000 --> 00:39:54.000
이 정보를 받기 위해 이 알림을 관찰할 수 있습니다.

00:39:54.000 --> 00:40:00.000
알림 객체에는 모드를 변경한 정확한 텍스트 보기에 대한 참조가 포함되어 있습니다.

00:40:00.000 --> 00:40:09.000
AppKit의 TextKit 1 호환성 모드에 대한 자세한 내용은 Apple 개발자 포털의 문서를 참조하십시오.

00:40:09.000 --> 00:40:16.000
UIKit 개발자의 경우, UITextField는 iOS 15에서 TextKit 2를 자동으로 사용합니다.

00:40:16.000 --> 00:40:23.000
TextKit 2가 있는 UITextView는 iOS 15에서 사용할 수 없습니다.

00:40:23.000 --> 00:40:30.000
우리는 UITextView를 사용하는 모든 애플리케이션에 대한 최대 호환성을 보장하기 위해 노력하고 있으며, 꽤 많이 있습니다.

00:40:30.000 --> 00:40:41.000
그 동안, UITextView의 layoutManager 속성 사용에 대한 기존 코드를 검토하고 TextKit 2로 의도를 표현하는 방법에 대해 생각할 수 있습니다.

00:40:41.000 --> 00:40:45.000
그렇게 하면, 사용할 수 있게 되면 전환할 준비가 될 것입니다.

00:40:45.000 --> 00:40:47.000
그리고 그건 포장이야.

00:40:47.000 --> 00:40:52.000
이제 당신은 우리를 미래로 데려갈 Apple의 새로운 텍스트 엔진인 TextKit 2를 만났습니다.

00:40:52.000 --> 00:40:55.000
우리는 당신이 TextKit 2로 무엇을 만들지 보기를 기대합니다.

00:40:55.000 --> 00:40:56.000
봐줘서 고마워.

00:40:56.000 --> 23:59:59.000
[쾌활한 음악].

