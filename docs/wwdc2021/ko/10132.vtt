WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:13.000
안녕하세요, 저는 여기 애플의 스위프트 팀의 엔지니어인 네이트입니다.

00:00:13.000 --> 00:00:18.000
오늘 제 동료 로버트와 저는 스위프트에서 비동기/대기에 대해 말씀드리겠습니다.

00:00:18.000 --> 00:00:21.000
비동기 프로그래밍은 여러분 중 많은 사람들에게 정기적인 활동입니다.

00:00:21.000 --> 00:00:28.000
그래서 당신은 장황하고 복잡하며 심지어 잘못된 비동기 코드를 작성하는 것이 너무 쉽다는 것을 알고 있습니다.

00:00:28.000 --> 00:00:31.000
Swift의 Async/await가 도움이 될 수 있다.

00:00:31.000 --> 00:00:36.000
그것을 사용하면 일반 코드를 작성하는 것만큼 쉽게 비동기 코드를 작성할 수 있습니다.

00:00:36.000 --> 00:00:40.000
그리고 당신이 할 때, 당신의 코드는 당신의 아이디어를 더 잘 반영할 것입니다.

00:00:40.000 --> 00:00:42.000
그것도 더 안전할 거야.

00:00:42.000 --> 00:00:48.000
게다가, SDK에는 당신이 사용할 수 있는 수백 가지의 기다릴 수 있는 방법이 있습니다.

00:00:48.000 --> 00:00:53.000
예를 들어, UIKit은 UIImage에서 썸네일을 형성하는 기능을 제공합니다.

00:00:53.000 --> 00:00:59.000
사실, 그것은 그 작업을 완료하기 위해 동기식 및 비동기식 기능을 모두 제공한다.

00:00:59.000 --> 00:01:09.000
간단히 말씀드리자면, 동기식 함수, 즉 일반 오래된 함수를 호출할 때 스레드가 차단되어 해당 함수가 완료되기를 기다린다.

00:01:09.000 --> 00:01:19.000
따라서 fetchThumbnail 함수가 preparingThumbnail-- UIKit이 제공하는 동기 함수--가 완료될 때까지 preparingThumbnail을 호출하면, 당신의 스레드는 다른 것을 할 수 없습니다.

00:01:19.000 --> 00:01:30.000
대조적으로, prepareThumbnail (of:completionHandler:)-- 그 함수의 비동기 버전을 호출하면, 실행되는 동안, 당신의 스레드는 다른 작업을 자유롭게 할 수 있습니다.

00:01:30.000 --> 00:01:35.000
완료되면, 완료 핸들러에 전화하여 알려드릴 것입니다.

00:01:35.000 --> 00:01:38.000
SDK는 많은 비동기 기능을 제공한다.

00:01:38.000 --> 00:01:42.000
그들은 당신에게 그들이 몇 가지 다른 방법으로 완료했다는 것을 알려준다.

00:01:42.000 --> 00:01:44.000
몇몇은 이와 같은 완료 핸들러를 사용한다.

00:01:44.000 --> 00:01:47.000
다른 사람들은 위임 콜백에 의존한다.

00:01:47.000 --> 00:01:50.000
그리고 많은 것들이 비동기로 표시되고 값을 반환합니다.

00:01:50.000 --> 00:01:59.000
이 비동기 기능이 모두 공통적으로 가지고 있는 것은 이것입니다: 하나를 호출할 때, 작업을 시작한 후 스레드를 빠르게 차단 해제합니다.

00:01:59.000 --> 00:02:04.000
그것은 긴 실행 작업이 완료되는 동안 스레드가 다른 일을 할 수 있게 해준다.

00:02:04.000 --> 00:02:10.000
그 차이를 보기 위해, 여러분 중 많은 사람들에게 친숙할 수 있는 예를 살펴봅시다.

00:02:10.000 --> 00:02:18.000
로버트와 내가 함께 만들고 있는 앱에는 각 행이 서버에 저장된 이미지의 썸네일을 표시하는 항목 목록이 있습니다.

00:02:18.000 --> 00:02:25.000
그 목록에 표시할 썸네일을 준비할 때가 되면, 우리의 뷰 모델에서 fetchThumbnail 메소드가 호출됩니다.

00:02:25.000 --> 00:02:30.000
일련의 단계를 통해 문자열을 UIImage로 변환합니다.

00:02:30.000 --> 00:02:36.000
먼저, 뷰 모델의 thumbnailURLRequest 메소드는 문자열에서 URLRequest를 생성합니다.

00:02:36.000 --> 00:02:42.000
다음으로, URLSession의 dataTask 메소드는 해당 요청에 대한 데이터를 가져옵니다.

00:02:42.000 --> 00:02:51.000
그런 다음 UIImage initWithData는 해당 데이터에서 이미지를 만들고, 마지막으로 UIImage의 prepareThumbnail 방법은 원본 이미지에서 썸네일을 렌더링합니다.

00:02:51.000 --> 00:02:55.000
이러한 각 작업은 이전 작업의 결과에 따라 달라집니다.

00:02:55.000 --> 00:02:59.000
그것은 그들이 순서대로 수행되어야 한다는 것을 의미한다.

00:02:59.000 --> 00:03:15.000
이러한 작업 중 일부는 값을 빠르게 반환합니다. 문자열에서 URLRequest를 구성하고 데이터에서 UIImage를 구성하는 것은 다음과 같습니다. 따라서 함수가 있는 스레드와 동기 호출이 무엇이든 간에 실행해도 괜찮습니다.

00:03:15.000 --> 00:03:17.000
하지만, 그들 중 몇몇은 시간이 걸린다.

00:03:17.000 --> 00:03:21.000
이미지를 구성하는 모든 데이터를 다운로드하는 데 시간이 좀 걸립니다.

00:03:21.000 --> 00:03:27.000
그리고 그것으로부터 멋진 썸네일을 렌더링하려면 값비싼 작업을 하기 위한 장치가 필요하다.

00:03:27.000 --> 00:03:32.000
그것이 SDK가 이러한 작업을 완료하기 위한 비동기 기능을 제공하는 이유입니다.

00:03:32.000 --> 00:03:35.000
그래서 이 호출들은 비동기적이어야 한다.

00:03:35.000 --> 00:03:43.000
로버트와 내가 스핀을 위해 비동기/기다리기 전에, 우리는 완성 핸들러를 사용하여 함수를 작성하고 있었다.

00:03:43.000 --> 00:03:52.000
이 함수는 호출자에게 출력을 돌려주는 데 사용되는 문자열, 첫 번째 작업에 대한 입력 및 완료 핸들러를 인수로 사용합니다.

00:03:52.000 --> 00:03:57.000
fetchThumbnail이 호출되면, 우리는 먼저 thumbnailURLRequest를 호출합니다.

00:03:57.000 --> 00:04:02.000
이 방법은 동기식이므로, 완료 핸들러가 필요하지 않습니다.

00:04:02.000 --> 00:04:10.000
다음으로 공유 URLSession 인스턴스에서 dataTask를 호출하여 URLRequest와 완료 핸들러를 전달합니다.

00:04:10.000 --> 00:04:17.000
비동기 작업을 시작하기 위해 재개해야 하는 URLSessionDataTask를 동기적으로 생성합니다.

00:04:17.000 --> 00:04:22.000
그런 다음 FetchThumbnail이 돌아오고, 스레드는 다른 작업을 자유롭게 할 수 있습니다.

00:04:22.000 --> 00:04:32.000
이미지를 다운로드하는 데 시간이 걸리고, 데이터가 스트리밍되기를 기다리는 스레드를 차단하고 싶지 않기 때문에 그것은 정말 중요합니다.

00:04:32.000 --> 00:04:37.000
결국 이미지 다운로드가 완료되거나 뭔가 잘못됩니다.

00:04:37.000 --> 00:04:50.000
어느 쪽이든, 요청이 완료되고 dataTask에 전달된 완료 핸들러는 데이터, 응답 및 오류와 같은 몇 가지 선택적 값으로 호출됩니다.

00:04:50.000 --> 00:04:57.000
무언가 잘못되면, 우리는 완료 핸들러를 호출하고 오류를 전달해야 합니다.

00:04:57.000 --> 00:05:03.000
모든 것이 잘 된다면, 우리는 UIImage의 initWithData를 사용하여 데이터에서 이미지를 만듭니다.

00:05:03.000 --> 00:05:08.000
동기적이기 때문에, 우리는 결과를 처리하기 위해 정상적인 직선 코드를 작성할 수 있다.

00:05:08.000 --> 00:05:11.000
이미지가 생성되지 않으면, 우리는 끝난다.

00:05:11.000 --> 00:05:19.000
그리고 이미지가 생성되었다면, 마침내 우리는 UIKit의 메소드 prepareThumbnail을 호출하고 완료 핸들러를 전달합니다.

00:05:19.000 --> 00:05:25.000
작업이 완료되는 동안, 스레드는 차단 해제되고 다른 작업을 할 수 있도록 해제됩니다.

00:05:25.000 --> 00:05:34.000
썸네일이 준비된 후, 썸네일을 준비하는 데 성공하거나 그렇지 않으면 완성 핸들러가 이미지와 함께 호출됩니다.

00:05:34.000 --> 00:05:41.000
만약 그것이 성공한다면, 우리는 완성 핸들러를 호출하고 이미지를 전달한다.

00:05:41.000 --> 00:05:44.000
하지만 로버트가 나에게 지적했듯이, 문제가 있다.

00:05:44.000 --> 00:05:51.000
FetchThumbnail의 발신자는 fetchThumbnail이 작업을 마칠 때 실패하더라도 알림을 받을 것으로 예상합니다.

00:05:51.000 --> 00:05:55.000
그리고 현재, 우리는 발신자를 곤경에 빠뜨리고 있다.

00:05:55.000 --> 00:06:01.000
나는 "guard else return"을 쓰는 것에 너무 익숙해서 완료 핸들러를 두 번 호출하는 것을 잊었다.

00:06:01.000 --> 00:06:11.000
따라서 데이터에서 UIImage를 만들거나 썸네일을 준비하는 데 실패하면, fetchThumbnail의 호출자는 알림을 받지 않으며 행은 업데이트되지 않습니다.

00:06:11.000 --> 00:06:15.000
그건 그냥 스피너를 영원히 보여줄 거야.

00:06:15.000 --> 00:06:22.000
그것이 fetchThumbnail의 저자인 우리에게 무슨 일이 있어도 발신자에게 알리는 것이 매우 중요한 이유입니다.

00:06:22.000 --> 00:06:26.000
그래서 그 기능을 통한 모든 경로는 그들에게 알려야 한다.

00:06:26.000 --> 00:06:32.000
그렇게 하려면, 오류가 발생하면 완료 핸들러를 호출하고 오류를 전달해야 합니다.

00:06:32.000 --> 00:06:36.000
일반 함수는 그것을 던져서 호출자에게 오류를 돌려준다.

00:06:36.000 --> 00:06:44.000
그리고 스위프트는 함수를 통해 실행이 어떻게 진행되든, 값이 반환되지 않으면 오류가 발생하도록 보장합니다.

00:06:44.000 --> 00:06:48.000
하지만 우리는 여기서 스위프트의 일반적인 오류 처리 메커니즘을 사용할 수 없습니다.

00:06:48.000 --> 00:06:52.000
문제가 발생하면 이러한 완료 핸들러 내에서 오류를 던질 수 없습니다.

00:06:52.000 --> 00:06:57.000
그것은 스위프트가 우리의 일을 확인할 수 없다는 것을 의미하기 때문에 불행한 일이다.

00:06:57.000 --> 00:07:02.000
스위프트에게, fetchThumbnails와 같은 완성 핸들러는 단지 폐쇄일 뿐이다.

00:07:02.000 --> 00:07:08.000
우리는 그것이 항상 호출되는지 확인하고 싶어하지만, 스위프트에서는 그것을 시행할 방법이 없다.

00:07:08.000 --> 00:07:13.000
그게 내가 그 두 경비원에게서 막 돌아왔을 때 편집 오류를 받지 못한 이유야.

00:07:13.000 --> 00:07:18.000
로버트는 내가 그것을 고치는 데 문제가 있다는 것을 지적했다.

00:07:18.000 --> 00:07:23.000
그래서 당신의 완료 핸들러가 결국 호출되도록 하는 것은 당신에게 달려 있습니다.

00:07:23.000 --> 00:07:30.000
우리 둘이 이 기능을 쓰기 위해 앉았을 때, 우리는 단지 몇 가지 작업을 하나씩 하고 싶었다.

00:07:30.000 --> 00:07:35.000
두 개는 동기식이었고 두 개는 비동기식이었고, 완료 핸들러를 받았다.

00:07:35.000 --> 00:07:43.000
우리는 성공했지만, 미묘한 버그가 스며들 수 있는 다섯 가지 기회가 포함된 약 20줄의 코드로 끝났다.

00:07:43.000 --> 00:07:53.000
우리가 원했던 것은 그 네 가지 작업을 순서대로 수행하는 것이었지만, 우리가 얻은 것은 따르기 어렵고, 바로잡기 어렵고, 우리의 의도를 모호하게 한다.

00:07:53.000 --> 00:07:56.000
이제, 우리가 이것을 좀 더 안전하게 만들 수 있는 방법이 있다.

00:07:56.000 --> 00:08:01.000
예를 들어, 우리는 표준 라이브러리의 결과 유형을 사용할 수 있었다.

00:08:01.000 --> 00:08:08.000
그리고 이것은 조금 더 안전하지만, 그것은 또한 의식을 추가하여 우리의 코드를 더 못생기고 약간 더 길게 만든다.

00:08:08.000 --> 00:08:14.000
사람들은 또한 다른 방식으로 비동기 코드를 개선하기 위해 미래와 같은 기술을 사용했다.

00:08:14.000 --> 00:08:19.000
하지만 이러한 접근 방식 중 어느 것도 우리에게 간단하고, 쉽고, 안전한 코드를 제공하지 않는다.

00:08:19.000 --> 00:08:22.000
비동기/대기로, 우리는 더 잘할 수 있다.

00:08:22.000 --> 00:08:26.000
로버트와 나는 그 네 단계를 수행하는 기능을 다시 썼다.

00:08:26.000 --> 00:08:30.000
그리고 이번에, 우리는 async/await를 사용했다.

00:08:30.000 --> 00:08:33.000
그 함수는 여전히 문자열을 인수로 받는다.

00:08:33.000 --> 00:08:40.000
하지만 지난번에는 완료 핸들러도 전달되었지만, 이번에는 대신 기능이 비동기입니다.

00:08:40.000 --> 00:08:50.000
함수 비동기를 표시할 때, 키워드는 함수 서명의 "던지기" 직전, 또는 함수가 던지지 않으면 화살표 앞에 가야 합니다.

00:08:50.000 --> 00:08:56.000
비동기 기능을 표시하면 서명이 더 간단해질 수 있습니다.

00:08:56.000 --> 00:09:01.000
이미지가 성공적으로 축소되면, 그 축소판은 단순히 반환됩니다.

00:09:01.000 --> 00:09:05.000
그리고 오류가 발생하면, 그냥 던져진다.

00:09:05.000 --> 00:09:12.000
fetchThumbnail이 호출되면, 이전과 마찬가지로, thumbnailURLRequest를 호출하는 것으로 시작됩니다.

00:09:12.000 --> 00:09:17.000
이 기능은 동기식이므로, 스레드가 차단되어 작업을 수행합니다.

00:09:17.000 --> 00:09:23.000
다음으로, 공유 URLSession에서 데이터(요청: 요청)를 호출하여 데이터 다운로드를 시작합니다.

00:09:23.000 --> 00:09:29.000
dataTask와 마찬가지로, 이 방법은 재단에서도 제공하며 비동기식이다.

00:09:29.000 --> 00:09:33.000
하지만 dataTask와 달리, 데이터 방법은 기다릴 수 있다.

00:09:33.000 --> 00:09:38.000
그래서 그것이 호출된 후, 그것은 빠르게 중단되어 스레드를 차단 해제한다.

00:09:38.000 --> 00:09:42.000
그러면 그 실은 다른 일을 자유롭게 할 수 있다.

00:09:42.000 --> 00:09:52.000
데이터 방법이 "던지기"로 표시되어 있기 때문에 "시도"가 여기에 있습니다. 이전 버전에서, 우리가 어떻게 오류를 확인한 다음 그것으로 완료 핸들러를 명시적으로 호출해야 했는지 기억하십니까?

00:09:52.000 --> 00:09:59.000
여기 기다릴 수 있는 버전에서, 그 모든 코드는 try 키워드로 요약된다.

00:09:59.000 --> 00:10:18.000
"Throws"로 표시된 함수를 호출하는 데 "시도"가 필요한 것처럼, "async"로 표시된 함수를 호출하려면 "await"가 필요합니다. 표현식에 여러 개의 비동기 함수 호출이 있는 경우, 여러 개의 던지기 함수 호출이 있는 표현식에 대해 한 번만 "시도"만 필요한 것처럼 "대기"를 한 번만 쓰면 됩니다.

00:10:18.000 --> 00:10:30.000
전체적으로, 함수 호출은 "기다려보기"로 표시되어 있다. 던지는 비동기 표현을 다룰 때, 이렇게 기다리기 전에 시도해야 합니다.

00:10:30.000 --> 00:10:38.000
결국, 데이터 다운로드가 완료되면, 데이터 방법이 재개되고 fetchThumbnail로 돌아갑니다.

00:10:38.000 --> 00:10:44.000
그 시점에서, 데이터 메소드가 반환하는 값이나 그것이 던지는 오류가 흐를 것이다.

00:10:44.000 --> 00:10:49.000
만약 그것이 오류를 던졌다면, fetchThumbnail은 그 오류를 차례로 던질 것이다.

00:10:49.000 --> 00:10:54.000
그렇지 않으면, 데이터와 응답 변수가 정의될 것이다.

00:10:54.000 --> 00:11:02.000
이것은 이전 버전의 fetchThumbnail에서 URLSession의 dataTask 메소드에 전달된 완료 핸들러가 호출되었을 때 일어난 것과 유사합니다.

00:11:02.000 --> 00:11:08.000
두 버전 모두에서, URLSession의 비동기 방법에 의해 생성된 값과 오류가 유입되었다.

00:11:08.000 --> 00:11:12.000
하지만 기다릴 수 있는 버전은 훨씬 더 간단하다.

00:11:12.000 --> 00:11:14.000
그것은 우리가 의미하는 바를 정확히 말한다.

00:11:14.000 --> 00:11:20.000
이 요청을 하고 우리가 변수로 돌아가는 값을 할당하여 사용할 수 있도록 하세요.

00:11:20.000 --> 00:11:24.000
그리고 만약 우리가 문제에 부딪치면, 오류를 던져.

00:11:24.000 --> 00:11:30.000
다음으로, fetchThumbnail은 다운로드한 데이터에서 UIImage를 만들려고 시도합니다.

00:11:30.000 --> 00:11:37.000
그것이 성공하면, 썸네일 속성에 액세스하여 해당 이미지에 대한 썸네일이 렌더링됩니다.

00:11:37.000 --> 00:11:48.000
썸네일이 형성되는 동안, 스레드는 썸네일 속성이 결국 재개되고 fetchThumbnail로 돌아올 때까지 다른 일을 자유롭게 할 수 있다.

00:11:48.000 --> 00:11:52.000
썸네일이 렌더링되면, fetchThumbnail이 반환합니다.

00:11:52.000 --> 00:11:54.000
그렇지 않으면, 오류가 발생할 것이다.

00:11:54.000 --> 00:12:03.000
완료 핸들러 버전과 달리, 썸네일이 렌더링되지 않으면, 스위프트는 여기에 오류를 발생하거나 값을 반환하도록 보장합니다.

00:12:03.000 --> 00:12:06.000
하지만 우리는 조용히 실패할 수 없어.

00:12:06.000 --> 00:12:10.000
그리고 그게 다야. 그게 우리가 필요한 모든 코드야.

00:12:10.000 --> 00:12:14.000
그 함수는 완료 핸들러 버전이 이전에 했던 것과 정확히 일치한다.

00:12:14.000 --> 00:12:17.000
하지만 20줄의 코드 대신에, 그것은 단지 6줄을 가지고 있다.

00:12:17.000 --> 00:12:20.000
그리고 그건 모두 직선 코드야.

00:12:20.000 --> 00:12:25.000
순서대로 수행되어야 하는 네 가지 작업은 다음 순서대로 나열됩니다.

00:12:25.000 --> 00:12:33.000
그리고 스위프트는 함수가 문제가 발생하면 반환하거나 던져서 완료되었을 때 항상 호출자에게 알리도록 합니다.

00:12:33.000 --> 00:12:46.000
이것은 async/await를 사용하여 비동기 스위프트 코드를 변환하여 더 안전하고 짧고 의도를 더 잘 반영할 수 있는 방법의 한 예일 뿐입니다.

00:12:46.000 --> 00:12:50.000
fetchThumbnail이 어떻게 구현되는지에 대한 몇 가지 세부 사항을 살펴봅시다.

00:12:50.000 --> 00:13:01.000
두 번째 줄에서 마지막 줄에서, 함수 호출이 없더라도, 썸네일 렌더링을 시작하는 표현식은 "대기"로 표시됩니다. 그것은 썸네일 속성이 비동기이기 때문이다.

00:13:01.000 --> 00:13:03.000
기능뿐만 아니라 비동기일 수 있다.

00:13:03.000 --> 00:13:08.000
속성도 그럴 수 있고, 이니셜라이저도 그럴 수 있다.

00:13:08.000 --> 00:13:11.000
이제, 썸네일 속성은 SDK의 일부가 아니다.

00:13:11.000 --> 00:13:13.000
그건 사실 로버트가 추가한 거야.

00:13:13.000 --> 00:13:16.000
한 번 보자.

00:13:16.000 --> 00:13:22.000
그는 UIImage의 확장에서 이 속성을 정의했고, 그 구현은 짧다.

00:13:22.000 --> 00:13:29.000
그것은 CGSize를 형성하고 ByPreparingThumbnail(ofSize)로 전달한 결과를 기다린다.

00:13:29.000 --> 00:13:35.000
그건 그렇고, 이 방법은 우리가 이전에 사용했던 방법의 기다릴 수 있는 버전이다.

00:13:35.000 --> 00:13:38.000
주목해야 할 몇 가지가 있다.

00:13:38.000 --> 00:13:40.000
첫째, 그것은 노골적인 게터가 있다.

00:13:40.000 --> 00:13:44.000
이것은 속성 비동기를 표시하는 데 필요합니다.

00:13:44.000 --> 00:13:48.000
스위프트 5.5부터, 부동산 겟터도 던질 수 있다.

00:13:48.000 --> 00:13:58.000
그리고 비동기 함수 서명과 마찬가지로, 속성이 비동기 및 throw인 경우, 비동기 키워드는 throw 직전에 진행됩니다.

00:13:58.000 --> 00:14:01.000
둘째, 그 재산에는 세터가 없다.

00:14:01.000 --> 00:14:05.000
읽기 전용 속성만 비동기일 수 있습니다.

00:14:05.000 --> 00:14:13.000
함수, 속성 및 이니셜라이저에서, 함수가 스레드를 차단 해제할 수 있는 위치를 나타내기 위해 표현식에 await를 사용할 수 있습니다.

00:14:13.000 --> 00:14:20.000
기다리는 또 다른 장소도 사용할 수 있습니다: 비동기 시퀀스를 반복하기 위한 루프.

00:14:20.000 --> 00:14:26.000
비동기 시퀀스는 요소를 비동기적으로 판매한다는 점을 제외하고는 일반 시퀀스와 같다.

00:14:26.000 --> 00:14:33.000
따라서 다음 항목을 가져오는 것은 await 키워드로 표시되어야 하며, 이는 비동기임을 나타냅니다.

00:14:33.000 --> 00:14:50.000
함수가 비동기 시퀀스를 반복함에 따라, 다음 요소를 기다리는 동안 스레드를 차단 해제한 다음 루프의 본문으로 다음 요소로 또는 남은 요소가 없는 경우 루프 후에 재개할 수 있습니다.

00:14:50.000 --> 00:14:55.000
AsyncSequence에 대해 자세히 알아보려면, "Meet AsyncSequence" 세션을 시청하세요.

00:14:55.000 --> 00:15:03.000
그리고 많은 비동기 작업을 병렬로 실행하는 데 관심이 있다면, "스위프트에서 구조화된 동시성" 세션을 확인하세요.

00:15:03.000 --> 00:15:06.000
그래서 당신이 사용할 수 있는 많은 장소가 있습니다.

00:15:06.000 --> 00:15:11.000
키워드는 비동기 기능이 중단될 수 있음을 나타냅니다.

00:15:11.000 --> 00:15:15.000
비동기 기능이 일시 중지된다는 것은 무엇을 의미합니까?

00:15:15.000 --> 00:15:19.000
그것에 답하기 위해, 함수를 호출할 때 어떤 일이 일어나는지 생각해 봅시다.

00:15:19.000 --> 00:15:27.000
어떤 함수를 호출할 때, 함수가 실행 중인 스레드를 그 함수로 직접 제어할 수 있습니다.

00:15:27.000 --> 00:15:39.000
thumbnailURLRequest와 같이 호출하는 일반 함수라면, 스레드는 끝날 때까지 그 하나의 함수를 대신하여 작업을 수행하는 데 완전히 바쁠 것입니다.

00:15:39.000 --> 00:15:45.000
그 작업은 함수 자체의 본문이나 그것이 호출하는 다른 함수에 있을 수 있다.

00:15:45.000 --> 00:15:51.000
결국, 그 함수는 값을 반환하거나 오류를 던져서 끝날 것이다.

00:15:51.000 --> 00:15:55.000
그럴 때, 그것은 당신의 기능을 다시 제어합니다.

00:15:55.000 --> 00:16:00.000
그것이 정상적인 기능이 스레드의 제어를 포기할 수 있는 유일한 방법이다: 마무리함으로써.

00:16:00.000 --> 00:16:04.000
그리고 당신의 기능은 통제할 수 있는 유일한 것입니다.

00:16:04.000 --> 00:16:09.000
만약 그것이 당신이 호출하고 있는 비동기 함수라면, 상황은 다릅니다.

00:16:09.000 --> 00:16:14.000
정상적인 기능과 마찬가지로, 완료되면, 그것은 완료되고 당신의 기능에 대한 제어를 되돌릴 것입니다.

00:16:14.000 --> 00:16:22.000
하지만 정상적인 기능과 달리, 그것은 완전히 다른 방식으로 스레드의 제어를 포기할 수 있다: 중단함으로써.

00:16:22.000 --> 00:16:28.000
일반 함수와 마찬가지로, 비동기 함수를 호출할 때 스레드를 제어할 수 있습니다.

00:16:28.000 --> 00:16:32.000
일단 실행되면, 비동기 기능이 중단될 수 있다.

00:16:32.000 --> 00:16:35.000
그럴 때, 그것은 스레드의 통제를 포기한다.

00:16:35.000 --> 00:16:41.000
하지만 당신의 기능에 제어권을 돌려주는 대신, 시스템에 스레드를 제어할 수 있습니다.

00:16:41.000 --> 00:16:46.000
그런 일이 발생하면, 당신의 기능도 중단됩니다.

00:16:46.000 --> 00:16:51.000
일시 중지는 시스템에 "당신이 해야 할 일이 많다는 것을 알고 있습니다."라고 말하는 기능의 방법입니다.

00:16:51.000 --> 00:16:55.000
네가 뭐가 가장 중요한지 결정해." 그건 얼마나 협조적이야?

00:16:55.000 --> 00:17:02.000
따라서 기능이 중단되면, 시스템은 스레드를 자유롭게 사용하여 다른 작업을 수행할 수 있습니다.

00:17:02.000 --> 00:17:11.000
어느 시점에서, 시스템은 가장 중요한 일은 이전에 중단된 비동기 기능을 계속 실행하는 것이라고 결정할 것이다.

00:17:11.000 --> 00:17:14.000
그 시점에서, 시스템은 그것을 재개할 것이다.

00:17:14.000 --> 00:17:21.000
그런 다음 그 비동기 기능은 스레드를 다시 제어하고 작업을 계속할 수 있다.

00:17:21.000 --> 00:17:25.000
그리고 그것이 원한다면, 그것은 다시 중단될 수 있다.

00:17:25.000 --> 00:17:29.000
사실, 그것은 필요한 만큼 중단될 수 있다.

00:17:29.000 --> 00:17:33.000
반면에, 그것은 스스로를 중단할 필요가 전혀 없을 수도 있다.

00:17:33.000 --> 00:17:41.000
비동기 함수가 일시 중지될 수 있지만, 비동기라고 표시되어 있다고 해서 반드시 일시 중지된다는 것을 의미하지는 않습니다.

00:17:41.000 --> 00:17:49.000
그리고 같은 이유로, 당신이 "기다림"을 본다고 해서 그 기능이 확실히 중단될 것이라는 것을 의미하지는 않습니다.

00:17:49.000 --> 00:18:02.000
하지만 결국, 일시 중지하지 않거나 마지막으로 재개한 후, 함수는 값이나 오류와 함께 스레드 제어를 함수로 다시 전달하여 완료됩니다.

00:18:02.000 --> 00:18:07.000
fetchThumbnail이 중단될 때 어떤 일이 일어날 수 있는지 다시 한 번 봅시다.

00:18:07.000 --> 00:18:19.000
fetchThumbnail이 URLSession의 비동기 데이터 메소드를 호출할 때, 데이터 메소드는 비동기 함수만 일시 중지할 수 있는 특별한 방식으로 스레드에서 실행을 멈춥니다.

00:18:19.000 --> 00:18:26.000
그것은 시스템에 스레드를 제어하고 시스템에 URLSession의 데이터 방법에 대한 작업을 예약하도록 요청합니다.

00:18:26.000 --> 00:18:32.000
하지만 이 시점에서, 시스템은 통제되고 있으며, 그 작업은 즉시 시작되지 않을 수도 있다.

00:18:32.000 --> 00:18:35.000
그 실은 대신 다른 것들에 사용될 수 있다.

00:18:35.000 --> 00:18:38.000
어떻게 그런 일이 일어날지 보자.

00:18:38.000 --> 00:18:44.000
fetchThumbnail이 호출된 후, 사용자가 일부 데이터를 업로드할 버튼을 탭한다고 가정합니다.

00:18:44.000 --> 00:18:47.000
예를 들어, 그들이 게시물에 반응한다고 가정해 봅시다.

00:18:47.000 --> 00:18:55.000
그런 다음 시스템은 이전에 대기 중인 작업 전에 사용자의 반응을 게시하기 위해 작업을 자유롭게 실행할 수 있습니다.

00:18:55.000 --> 00:19:01.000
늦은 작업이 완료되면, URLSession의 데이터 방법이 재개될 수 있습니다.

00:19:01.000 --> 00:19:04.000
아니면 시스템이 대신 다른 작업을 실행할 수도 있다.

00:19:04.000 --> 00:19:11.000
마지막으로, 데이터 메소드가 완료되면, fetchThumbnail로 돌아갑니다.

00:19:11.000 --> 00:19:19.000
함수가 일시 중지되는 동안 다른 작업을 수행할 수 있다는 사실은 Swift가 await 키워드로 비동기 호출을 표시해야 한다고 주장하는 이유입니다.

00:19:19.000 --> 00:19:25.000
기능이 중단되면 앱의 상태가 극적으로 바뀔 수 있다는 것을 알아야 합니다.

00:19:25.000 --> 00:19:29.000
이제, 이것은 완료 핸들러를 사용할 때도 마찬가지입니다.

00:19:29.000 --> 00:19:42.000
하지만 비동기/대기 코드에서 수반하는 모든 의식과 들여쓰기가 없기 때문에, await 키워드는 코드 블록이 하나의 트랜잭션으로 실행되지 않는다는 것을 알아차리는 방법입니다.

00:19:42.000 --> 00:19:49.000
함수는 일시 중지될 수 있으며, 함수의 줄 사이에 일시 중지되는 동안 다른 일이 발생할 수 있습니다.

00:19:49.000 --> 00:19:54.000
그 이상으로, 그 기능은 완전히 다른 스레드로 재개될 수 있다.

00:19:54.000 --> 00:20:00.000
이러한 문제에 대해 알아보려면, "스위프트 액터로 변경 가능한 상태 보호" 세션을 참조하십시오.

00:20:00.000 --> 00:20:03.000
여기 async/await에 대해 기억해야 할 몇 가지 중요한 사항이 있습니다.

00:20:03.000 --> 00:20:08.000
먼저, 비동기 함수를 표시할 때, 일시 중지되도록 허용할 수 있습니다.

00:20:08.000 --> 00:20:12.000
그리고 함수가 스스로 일시 중지되면, 호출자도 일시 중지합니다.

00:20:12.000 --> 00:20:15.000
그래서 그것의 발신자도 비동기여야 한다.

00:20:15.000 --> 00:20:24.000
둘째, 비동기 함수에서 한 번 또는 여러 번 중단될 수 있는 곳을 지적하기 위해, await 키워드가 사용됩니다.

00:20:24.000 --> 00:20:28.000
셋째, 비동기 함수가 일시 중단되는 동안, 스레드는 차단되지 않습니다.

00:20:28.000 --> 00:20:31.000
그래서 그 시스템은 다른 일을 자유롭게 예약할 수 있다.

00:20:31.000 --> 00:20:35.000
나중에 시작되는 작업도 먼저 실행될 수 있다.

00:20:35.000 --> 00:20:40.000
그것은 기능이 일시 중지되는 동안 앱의 상태가 크게 바뀔 수 있다는 것을 의미합니다.

00:20:40.000 --> 00:20:52.000
마지막으로, 비동기 함수가 재개되면, 비동기 함수에서 반환된 결과는 원래 함수로 돌아가고, 실행은 중단된 곳에서 바로 계속된다.

00:20:52.000 --> 00:20:56.000
당신은 Swift에서 async/await가 어떻게 작동하는지 보았습니다.

00:20:56.000 --> 00:21:00.000
이제 로버트는 당신의 프로젝트에서 그것을 사용하기 시작하는 방법을 보여줄 것입니다.

00:21:00.000 --> 00:21:02.000
고마워, 네이트.

00:21:02.000 --> 00:21:05.000
이전에, 네이트는 우리가 함께 만들고 있는 앱을 보여주었다.

00:21:05.000 --> 00:21:15.000
그가 비동기/기다림을 채택하기 위해 변환한 썸네일 함수는 몇 곳에서 호출되므로, 우리는 동시성을 채택하기 위해 그것들을 마이그레이션해야 할 것이다.

00:21:15.000 --> 00:21:20.000
현대 소프트웨어 개발에 중요한 것부터 시작합시다: 테스트.

00:21:20.000 --> 00:21:29.000
우리는 비동기 코드를 테스트하는 것이 동기 코드를 테스트하는 것만큼 쉽기를 원했기 때문에, XCTest는 즉시 비동기를 지원합니다.

00:21:29.000 --> 00:22:01.000
기대를 설정하고, 테스트 중인 API를 호출하고, 기대를 충족한 다음, 임의의 시간을 기다리는 지루한 과정은 테스트 함수에 비동기 키워드를 추가하고, XCTest 기대치, 이행 및 명시적 대기를 제거하고, 대신 Nate가 이전에 보여준 새로운 비동기 fetchThumbnail 함수를 호출하는 결과를 기다리는 것만큼 쉬워졌습니다.

00:22:01.000 --> 00:22:06.000
이제 테스트가 해결되었으니, 애플리케이션 코드 자체를 확대해 봅시다.

00:22:06.000 --> 00:22:13.000
특히, 이 목록의 각 행의 썸네일 보기 뒤에 있는 SwiftUI 코드.

00:22:13.000 --> 00:22:22.000
이미지 셀은 게시물로 생성되며, 각 게시물에는 썸네일을 비동기적으로 검색할 수 있도록 viewModel에 전달하는 ID가 있습니다.

00:22:22.000 --> 00:22:29.000
당신은 이미 테스트 코드에서 이 호출을 변환하는 방법을 보았으니, 한 번 시도해 봅시다.

00:22:29.000 --> 00:22:40.000
먼저 완료 핸들러를 제거한 다음, 오류를 처리하기 위해 "시도"가 추가되고, 비동기 함수에 대한 호출을 완료하기 위해 "기다립니다".

00:22:40.000 --> 00:22:44.000
하지만 우리가 이 코드를 만들려고 할 때, 뭔가 잘못되었다.

00:22:44.000 --> 00:22:52.000
스위프트 컴파일러는 비동기가 아닌 컨텍스트에서 비동기 함수를 호출할 수 없다고 말하고 있다.

00:22:52.000 --> 00:23:05.000
여기서, onAppear 수정자는 평범하고 비동기적인 폐쇄를 취하므로, 동기 세계와 비동기 세계 사이의 격차를 메울 수 있는 방법이 있어야 한다.

00:23:05.000 --> 00:23:09.000
해결책은 비동기 작업 기능을 사용하는 것이다.

00:23:09.000 --> 00:23:20.000
비동기 작업은 클로저에서 작업을 패키징하고 글로벌 디스패치 대기열의 비동기 함수와 같이 다음 사용 가능한 스레드에서 즉시 실행하기 위해 시스템으로 보냅니다.

00:23:20.000 --> 00:23:27.000
여기서의 주요 이점은 비동기 코드를 동기화 컨텍스트 내부에서 호출할 수 있다는 것이다.

00:23:27.000 --> 00:23:31.000
또 다른 재건 후, 컴파일러는 만족한다.

00:23:31.000 --> 00:23:41.000
비동기 작업은 친숙하고 자연스럽게 구조화된 스타일로 풍부한 동시 스위프트 코드를 구축할 수 있는 API 제품군의 일부입니다.

00:23:41.000 --> 00:23:59.000
자세한 내용은 "스위프트에서 구조화된 동시성 탐색"을 참조하십시오. 그리고 SwiftUI 앱에서 비동기 코드를 최대한 활용하는 방법을 알아보려면, "SwiftUI에서 동시성 발견"을 참조하십시오. 우리는 fetchThumbnail 함수라고 불렀던 모든 장소의 마이그레이션을 마쳤습니다.

00:23:59.000 --> 00:24:03.000
하지만 우리 앱은 비동기/대기를 채택할 수 있는 더 많은 기회가 있습니다.

00:24:03.000 --> 00:24:11.000
빠르게 시작하고 실행하려면, 기존 API에 대한 비동기 대안으로 작게 시작하는 것이 좋습니다.

00:24:11.000 --> 00:24:20.000
SDK는 당신을 대신하여 비동기 방식으로 작동하기 때문에 완료 핸들러를 수행하는 수백 개의 API를 제공합니다.

00:24:20.000 --> 00:24:27.000
이 API들이 나란히 정렬되면, 패턴이 나타나기 시작한다.

00:24:27.000 --> 00:24:35.000
비록 그들이 다른 이름과 다른 목적을 가질 수 있지만, 이 모든 기능은 동일한 필수 API 계약을 가지고 있다.

00:24:35.000 --> 00:24:42.000
당신은 그들에게 전화하고, 그들은 제공된 완료 핸들러와 함께 당신에게 다시 전화하여 그들이 얻은 결과를 전달합니다.

00:24:42.000 --> 00:24:49.000
이전에, 네이트는 당신이 더 자연스러워 보이는 코드를 작성하기 위해 비동기 함수의 결과를 기다릴 수 있다는 것을 보여주었습니다.

00:24:49.000 --> 00:24:57.000
우리가 이 콜백 블록을 이 비동기 함수로 바꿀 수 있다면 멋지지 않을까요?

00:24:57.000 --> 00:25:02.000
스위프트 5.5에서, 이것이 정확히 일어나는 일이다.

00:25:02.000 --> 00:25:10.000
스위프트 컴파일러는 Objective-C에서 가져온 완료 핸들러 코드를 자동으로 살펴보고 비동기 대안을 제공합니다.

00:25:10.000 --> 00:25:12.000
하지만 우리는 거기서 멈추지 않았어.

00:25:12.000 --> 00:25:18.000
많은 대리 API에는 완료 핸들러를 전달하는 방법도 포함되어 있습니다.

00:25:18.000 --> 00:25:24.000
핸들러를 호출하면 비동기 작업이 완료되면 프레임워크에 협력적으로 알립니다.

00:25:24.000 --> 00:25:32.000
fetchThumbnail을 호출하는 이 ClockKit 컴플리케이션 데이터 소스를 사용하여 주어진 게시물에 대한 타임라인 항목을 표시하십시오.

00:25:32.000 --> 00:25:41.000
이전과 마찬가지로, 우리는 모든 경로에서 완료 핸들러를 호출해야 하며, 폐쇄로 인해 여기에 많은 소음이 있습니다.

00:25:41.000 --> 00:25:45.000
비동기 대기와 함께, 이것은 더 이상 그럴 필요가 없다.

00:25:45.000 --> 00:25:50.000
이 위임 방법은 우리가 대신 사용할 수 있는 비동기 대안을 가지고 있다.

00:25:50.000 --> 00:26:05.000
먼저, 선행 "get"을 떨어뜨리는 비동기 대안의 이름이 사용된다. 비동기 함수는 통화 결과가 직접 반환되지 않을 때 통신하는 "get"과 같은 선행 단어를 생략하는 것이 좋습니다.

00:26:05.000 --> 00:26:13.000
결국, 이것은 비동기 대체 함수이기 때문에, 타임라인 항목을 직접 반환합니다.

00:26:13.000 --> 00:26:19.000
이제 비동기 컨텍스트가 설정되었고, 우리는 fetchThumbnail의 비동기 버전을 호출합니다.

00:26:19.000 --> 00:26:27.000
마지막으로, 우리는 지금 삭제된 완료 블록을 호출하는 대신 이 방법에서 타임라인 항목을 반환합니다.

00:26:27.000 --> 00:26:32.000
우리가 여기서 강조한 비동기 API는 표면을 거의 긁지 않는다.

00:26:32.000 --> 00:26:43.000
더 자세히 알아보려면, API 자체에 대해 훨씬 더 자세히 설명하고 async/await를 채택할 때 어떻게 사용할 수 있는지에 대해 자세히 알아보세요.

00:26:43.000 --> 00:26:49.000
이 모든 것은 스위프트가 당신을 대신하여 비동기 대안을 만드는 상황의 예입니다.

00:26:49.000 --> 00:26:56.000
하지만 필연적으로 코드에 비동기 대안을 직접 만들어야 하는 장소가 있을 것입니다.

00:26:56.000 --> 00:26:59.000
이것이 실제로 어떻게 생겼는지 봅시다.

00:26:59.000 --> 00:27:07.000
앱에서, 우리는 이 getPersistentPosts 기능을 사용하여 핵심 데이터 저장소에 유지한 게시물을 검색합니다.

00:27:07.000 --> 00:27:18.000
이 기능은 비동기 썸네일 기능보다 앱에서 훨씬 더 많은 곳에서 호출되므로, 모든 곳에서 비동기를 사용하는 것은 정말 큰 변화가 될 것입니다.

00:27:18.000 --> 00:27:26.000
그리고 우리가 NSAsynchronousFetchRequest를 사용하고 있기 때문에, 이 기능은 비동기 대안을 위한 완벽한 후보인 것 같습니다.

00:27:26.000 --> 00:27:31.000
먼저, 우리는 비동기 함수를 만들고 반환 값을 변환합니다.

00:27:31.000 --> 00:27:37.000
이 함수는 오류를 생성할 수 있기 때문에, 우리는 이 함수도 "던지기"로 표시합니다.

00:27:37.000 --> 00:27:46.000
다음으로, 우리는 getPersistentPosts의 완료 핸들러 버전을 부르고, 음, 이제 우리는 막혔습니다.

00:27:46.000 --> 00:27:53.000
콜백의 결과를 비동기 persistentPosts 함수에 대한 호출을 기다리는 장소로 반환해야 합니다.

00:27:53.000 --> 00:27:57.000
뿐만 아니라, 그 발신자들은 정지된 상태에 있다.

00:27:57.000 --> 00:28:05.000
우리는 그들이 나머지 일을 계속할 수 있도록 적절한 시점과 올바른 데이터로 그들을 재개해야 한다.

00:28:05.000 --> 00:28:12.000
이전에, 네이트는 스위프트와 시스템이 우리를 위해 비동기 코드를 재개하기 위해 어떻게 협력하는지 보여주었다.

00:28:12.000 --> 00:28:22.000
우리의 문제에 대한 비슷한 해결책을 생각해 낼 수 있는지 알아보기 위해 이 일시 중지/종료 과정이 어떻게 작동하는지 좀 더 자세히 알아봅시다.

00:28:22.000 --> 00:28:27.000
persistentPosts의 비동기 버전이 호출되면, 핵심 데이터를 호출합니다.

00:28:27.000 --> 00:28:34.000
나중에, Core Data는 완료 핸들러를 호출하고 가져오기 요청의 결과를 전달합니다.

00:28:34.000 --> 00:28:46.000
이 상황은 fetchThumbnail 함수가 Core Data가 아닌 시스템에 일시 정지된 비동기 함수 호출을 재개하도록 요청했을 때 Nate가 이전에 보여준 것과 거의 동일해 보입니다.

00:28:46.000 --> 00:28:53.000
누락된 것은 완료 핸들러를 기다리고 가져오기 요청의 결과를 재개하는 다리뿐입니다.

00:28:53.000 --> 00:28:59.000
이 패턴은 항상 나타나며, 이름이 있다: 연속.

00:28:59.000 --> 00:29:07.000
이 세션을 통해, 네이트와 나는 이미 당신에게 연속의 많은 예를 보여주었다: 완료 블록을 취하는 방법.

00:29:07.000 --> 00:29:15.000
메서드의 호출자는 함수 호출의 결과를 기다리고 다음에 무엇을 할지 지정하기 위해 클로저를 제공합니다.

00:29:15.000 --> 00:29:23.000
함수 호출이 완료되면, 호출자가 결과로 하고 싶은 것을 재개하기 위해 완료 핸들러를 호출합니다.

00:29:23.000 --> 00:29:29.000
이런 종류의 협력 실행은 정확히 스위프트에서 비동기 기능이 작동하는 방식이다.

00:29:29.000 --> 00:29:40.000
이를 명시적으로 하기 위해, 스위프트는 높은 수준의 안전한 방식으로 연속을 생성, 관리 및 재개할 수 있는 기능을 제공합니다.

00:29:40.000 --> 00:29:47.000
우리의 예로 돌아가서 연속이 비동기 대안 작성을 끝내는 데 어떻게 도움이 될 수 있는지 봅시다.

00:29:47.000 --> 00:29:56.000
withCheckedThrowingContinuation 함수는 오류가 있는 완료 블록을 해제하여 비동기 Swift 함수를 throw합니다.

00:29:56.000 --> 00:30:04.000
함수가 절대 오류를 발생시킬 수 없다는 것을 알고 있는 상황에 대해 withCheckedContinuations라는 대응이 있습니다.

00:30:04.000 --> 00:30:12.000
이러한 기능은 일시 중단된 비동기 기능을 재개하는 데 사용할 수 있는 연속 값에 액세스하는 방법입니다.

00:30:12.000 --> 00:30:19.000
이것은 또한 우리가 PersistentPosts를 얻기 위한 전화를 기다릴 수 있도록 함으로써 다리의 첫 번째 부분을 구축한다.

00:30:19.000 --> 00:30:22.000
다리 건설을 끝내자.

00:30:22.000 --> 00:30:29.000
연속 값은 완료 핸들러의 결과를 배치하는 이력서 기능을 제공합니다.

00:30:29.000 --> 00:30:38.000
뿐만 아니라, 이력서는 persistentPosts 함수의 결과를 기다리는 모든 호출을 중단 해제하는 데 필요한 누락된 링크를 제공합니다.

00:30:38.000 --> 00:30:46.000
그리고 거기에, 하나의 깔끔한 패키지에는 완료 핸들러에서 비동기 함수에 이르기까지 완성된 다리가 있습니다.

00:30:46.000 --> 00:30:56.000
연속은 비동기 기능의 실행을 수동으로 제어할 수 있는 강력한 방법을 제공하지만, 명심해야 할 몇 가지 사항이 있습니다.

00:30:56.000 --> 00:31:00.000
지속은 간단하지만 중요한 계약을 맺는다.

00:31:00.000 --> 00:31:04.000
이력서는 모든 길에서 정확히 한 번 호출되어야 한다.

00:31:04.000 --> 00:31:08.000
하지만 걱정하지 마. 스위프트는 여기 있어.

00:31:08.000 --> 00:31:18.000
재개가 호출되지 않고 연속이 폐기되면, 스위프트 런타임은 비동기 호출이 중단되지 않기 때문에 경고를 기록할 것이다.

00:31:18.000 --> 00:31:27.000
그러나 연속이 같은 기능에서 여러 번 재개된다면, 이것은 프로그램 데이터를 손상시킬 수 있기 때문에 더 심각한 오류이다.

00:31:27.000 --> 00:31:37.000
이에 대처하기 위해, 스위프트 런타임은 재개를 여러 번 호출하려는 시도를 감지하고 두 번째 재개 지점에서 치명적인 오류가 발생하도록 할 것이다.

00:31:37.000 --> 00:31:44.000
이를 염두에 두고, 체크된 연속을 사용할 수 있는 중요한 장소를 하나 더 강조해 봅시다.

00:31:44.000 --> 00:31:47.000
많은 API는 이벤트 중심이다.

00:31:47.000 --> 00:31:55.000
그들은 특정 중요한 지점에서 우리의 애플리케이션에 알리고 적절하게 대응할 수 있도록 대의원 콜백을 제공합니다.

00:31:55.000 --> 00:32:02.000
비동기/대기를 제대로 채택하기 위해, 우리는 계속을 저장하고 나중에 재개해야 할 것이다.

00:32:02.000 --> 00:32:07.000
이전과 마찬가지로, 우리는 확인된 연속을 만든다.

00:32:07.000 --> 00:32:12.000
그런 다음 우리는 그것을 저장하고 일을 시작합니다.

00:32:12.000 --> 00:32:25.000
확인된 연속의 API 계약을 존중하기 위해, 우리는 활성 연속을 재개하고, 마지막으로 그것을 제로화하여 두 번 이상 호출하지 않도록 보호합니다.

00:32:25.000 --> 00:32:37.000
항상 기억하세요: 여기서 선택된 연속 값은 이 API에 대한 비동기 호출을 수동으로 재개할 수 있는 기능을 나타내므로 모든 경로에서 호출되어야 합니다.

00:32:37.000 --> 00:32:49.000
위임 API가 여러 번 호출되거나 특정 상황에서 전혀 호출되지 않는 경우, 활성 연속을 정확히 한 번 재개하는 것이 중요합니다.

00:32:49.000 --> 00:32:58.000
연속을 포함하여 Swift 동시성의 낮은 수준의 세부 사항에 대해 자세히 알아보려면 "Swift 동시성: Behind the scenes" 세션을 참조하십시오.

00:32:58.000 --> 00:33:03.000
이것은 스위프트에서 비동기/기다림의 회오리바람 투어였다.

00:33:03.000 --> 00:33:11.000
우리는 런타임에 비동기 및 대기 키워드가 어떻게 작동하는지, 그리고 애플리케이션과 프레임워크에서 어떻게 채택할 수 있는지 보여주었습니다.

00:33:11.000 --> 00:33:23.000
시작하기 위해, 우리는 SDK에서 사용할 수 있는 비동기 API의 샘플링을 제공하고 기존 코드를 동기 세계에서 비동기 세계로 연결하는 방법을 보여주었습니다.

00:33:23.000 --> 00:33:28.000
Async/await는 스위프트 동시성 기능의 전체 우주의 기초이다.

00:33:28.000 --> 00:33:31.000
우리는 당신이 그들과 함께 무엇을 만드는지 보게 되어 기쁩니다.

00:33:31.000 --> 23:59:59.000
봐줘서 고마워.

