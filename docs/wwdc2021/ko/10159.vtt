WEBVTT

00:00:00.000 --> 00:00:05.000
♪ 베이스 음악 연주 ♪

00:00:05.000 --> 00:00:09.000
데이비드 헤이워드: 모두 환영합니다.

00:00:09.000 --> 00:00:10.000
제 이름은 데이비드 헤이워드입니다.

00:00:10.000 --> 00:00:22.000
저는 코어 이미지 팀의 수석 엔지니어이며, 오늘 Xcode 프로젝트에 사용자 지정 메탈 코어 이미지 커널을 추가할 때 최신 모범 사례를 보여주는 짧은 프레젠테이션을 할 것입니다.

00:00:22.000 --> 00:00:29.000
이 프레젠테이션에서, 나는 금속에서 사용자 지정 CIKernels를 작성하는 것의 일반적인 이점에 대해 논의할 것이다.

00:00:29.000 --> 00:00:35.000
다음으로, 나는 Metal CIKernels를 만들 수 있는 두 가지 권장 방법을 소개할 것이다.

00:00:35.000 --> 00:00:40.000
그리고 나서 나는 이것들을 당신의 프로젝트에 추가하는 방법을 단계별로 보여줄 것이다.

00:00:40.000 --> 00:00:46.000
먼저, 금속으로 사용자 지정 CIKernels를 작성하는 것의 이점을 검토해 봅시다.

00:00:46.000 --> 00:00:53.000
금속으로 CIKernels를 작성하면 자동 타일링 및 연결과 같은 핵심 이미지 기능에 액세스할 수 있습니다.

00:00:53.000 --> 00:01:02.000
커널을 컴파일하는 시간을 런타임에서 앱이 빌드될 때로 전환하여 앱의 성능을 향상시킬 것입니다.

00:01:02.000 --> 00:01:11.000
그리고 그렇게 하면 커널이 gather-reads, group-writes 및 half-float math과 같은 고성능 기능에 액세스할 수 있습니다.

00:01:11.000 --> 00:01:20.000
마지막으로, 작성할 때 구문 강조 표시와 빌드할 때 인라인 오류 검사를 통해 개발자로서의 삶을 더 쉽게 만들 수 있습니다.

00:01:20.000 --> 00:01:28.000
그래서 동기 부여를 위해, 이제 당신의 애플리케이션에 메탈 코어 이미지 커널을 추가하는 방법을 단계별로 보여드리겠습니다.

00:01:28.000 --> 00:01:35.000
이제 프로젝트에 CIKernels를 추가하는 두 가지 권장 방법이 있으며, 두 가지 방법을 자세히 설명하겠습니다.

00:01:35.000 --> 00:01:45.000
커널 함수를 extern "C"로 지정하고 사용자 지정 빌드 플래그를 사용하여 빌드해야 하기 때문에 이것을 extern 방법으로 언급할 것입니다.

00:01:45.000 --> 00:01:50.000
두 번째 방법은 iOS 15와 macOS 12의 새로운 방법이다.

00:01:50.000 --> 00:01:57.000
나는 이것을 바느질 가능한 방법으로 언급할 것이다. 왜냐하면 커널 기능이 바느질 가능한 것으로 귀속되어야 하기 때문이다.

00:01:57.000 --> 00:02:01.000
그것의 구현은 금속 동적 라이브러리를 사용한다.

00:02:01.000 --> 00:02:04.000
두 방법 모두, 따라야 할 네 가지 일반적인 단계가 있다.

00:02:04.000 --> 00:02:08.000
먼저, 프로젝트를 적절하게 구성하는 것입니다.

00:02:08.000 --> 00:02:13.000
둘째, Metal CIKernel 소스 파일을 프로젝트에 추가하는 것입니다.

00:02:13.000 --> 00:02:16.000
셋째, Metal CIKernel 코드를 작성하는 것입니다.

00:02:16.000 --> 00:02:25.000
그리고 네 번째는 Swift 또는 Objective-C 코드를 작성하여 커널을 초기화하고 적용하여 새로운 CIImage를 만드는 것입니다.

00:02:25.000 --> 00:02:32.000
먼저, 프로젝트 구성부터 시작하여 extern CIKernels를 사용할 때 이 네 단계를 설명해 봅시다.

00:02:32.000 --> 00:02:40.000
기존의 메탈 컴퓨팅 및 그래픽 셰이더와 달리, 이 코어 이미지 메탈 코드는 컴파일되고 특수 플래그와 연결되어야 합니다.

00:02:40.000 --> 00:02:48.000
이 플래그를 자동으로 사용할 수 있는 두 가지 사용자 지정 빌드 규칙을 프로젝트 대상에 추가하는 것이 좋습니다.

00:02:48.000 --> 00:02:56.000
먼저, 프로젝트의 대상 설정으로 이동하여 .ci.metal로 끝나는 파일에 대한 빌드 규칙을 추가합니다.

00:02:56.000 --> 00:03:06.000
이 확장자를 가진 파일의 경우, 이 규칙은 필요한 -fcikernel 플래그로 메탈 컴파일러를 호출하는 한 줄 스크립트를 실행합니다.

00:03:06.000 --> 00:03:12.000
이 빌드 규칙은 .ci.air로 끝날 출력 바이너리를 생성할 것이다.

00:03:12.000 --> 00:03:18.000
다음으로, .ci.air로 끝나는 파일에 대한 두 번째 빌드 규칙을 추가할 것입니다.

00:03:18.000 --> 00:03:27.000
이 확장자를 가진 파일의 경우, 이 규칙은 필요한 -cikernel 플래그로 메탈 링커를 호출하는 한 줄 스크립트를 실행합니다.

00:03:27.000 --> 00:03:36.000
이 빌드 규칙은 .ci.metallib로 끝나는 앱의 리소스 디렉토리에 출력을 생성합니다.

00:03:36.000 --> 00:03:43.000
이제 사용자 지정 빌드 규칙을 추가했으니, 프로젝트에 .ci.metal 소스를 추가하기만 하면 됩니다.

00:03:43.000 --> 00:03:54.000
그렇게 하려면, 새 Metal 파일을 추가할 파일 메뉴에서 선택한 다음 새 파일에 .ci.metal로 끝나는 이름을 지정하십시오.

00:03:54.000 --> 00:03:59.000
다음 단계는 Metal 소스 파일에 CIKernel을 작성하는 것입니다.

00:03:59.000 --> 00:04:08.000
먼저, 소스 상단에 CoreImage.h 헤더를 포함하면 Core Image가 제공하는 모든 클래스에 액세스할 수 있습니다.

00:04:08.000 --> 00:04:14.000
커널은 코어 이미지에 의해 인식되기 위해 외부 "C"로 지정되어야 합니다.

00:04:14.000 --> 00:04:19.000
실제 커널 구현의 내용은 당신의 상상력에 달려 있습니다.

00:04:19.000 --> 00:04:31.000
당신이 할 수 있는 일의 한 가지 예로, "AVFoundation을 사용한 HDR 편집 및 재생"에 대한 WWDC 2020 프레젠테이션을 보는 것이 좋습니다.

00:04:31.000 --> 00:04:37.000
마지막 단계는 스위프트 코드를 추가하여 커널을 로드하고 적용하여 새 이미지를 만드는 것입니다.

00:04:37.000 --> 00:04:46.000
커널은 일반적으로 inputImage 및 기타 입력 매개 변수와 같은 속성을 가진 CIFilter 서브클래스에서 사용됩니다.

00:04:46.000 --> 00:04:52.000
필터가 CIKernel 객체를 정적 속성으로 인스턴스화하는 것이 좋습니다.

00:04:52.000 --> 00:04:59.000
이렇게 하면, metallib 리소스를 로드하는 작업은 처음 필요할 때 한 번만 수행됩니다.

00:04:59.000 --> 00:05:10.000
앞서 설명한 사용자 지정 빌드 규칙 때문에, 소스와 같은 이름과 .ci.metallib의 확장을 가진 리소스 URL을 지정해야 합니다.

00:05:10.000 --> 00:05:16.000
마지막으로, CIFilter 서브클래스는 outputImage 속성을 재정의해야 합니다.

00:05:16.000 --> 00:05:26.000
게터에서 정적 속성에서 커널을 가져와 적용 방법을 사용하여 입력 속성을 기반으로 새 이미지를 만듭니다.

00:05:26.000 --> 00:05:31.000
그래서 그것은 외부 CIKernels를 만드는 과정을 완전히 설명한다.

00:05:31.000 --> 00:05:37.000
이제 바느질 가능한 CIKernels를 만드는 새로운 과정을 설명해 봅시다.

00:05:37.000 --> 00:05:42.000
스티치 가능한 방법을 사용하면 Xcode 프로젝트를 구성하는 데 한 번의 설정 변경만 필요합니다.

00:05:42.000 --> 00:05:47.000
이 설정은 메탈 링커에게 코어 이미지 프레임워크에 연결하라고 말할 것이다.

00:05:47.000 --> 00:05:56.000
이렇게 하려면, 프로젝트의 목표 설정으로 이동하여 "-framework CoreImage" 값으로 다른 금속 링커 플래그에 대한 빌드 설정을 추가하십시오.

00:05:56.000 --> 00:06:05.000
바느질 가능한 CIKernels는 사용자 지정 빌드 규칙이 필요하지 않기 때문에, 특별한 접미사 없이 프로젝트에 .metal 소스를 추가할 수 있습니다.

00:06:05.000 --> 00:06:09.000
하나 또는 여러 소스 파일에 커널을 추가할 수 있습니다.

00:06:09.000 --> 00:06:14.000
기본적으로, Xcode는 그들 모두를 하나의 .metallib 리소스로 구축할 것이다.

00:06:14.000 --> 00:06:18.000
다음 단계는 Metal 소스 파일에 CIKernel을 작성하는 것입니다.

00:06:18.000 --> 00:06:25.000
이전과 마찬가지로, Core Image 클래스에 액세스하기 위해 CoreImage.h 헤더를 포함할 것입니다.

00:06:25.000 --> 00:06:32.000
하지만 이 방법으로, 커널은 코어 이미지에 의해 인식되기 위해 ]로 귀속되어야 한다.

00:06:32.000 --> 00:06:39.000
다시 한번, 마지막 단계는 커널을 로드하기 위해 스위프트 코드를 추가하고, 새 이미지를 만들기 위해 적용하는 것입니다.

00:06:39.000 --> 00:06:47.000
바느질 가능한 CIKernels의 유일한 변경 사항은 default.metallib의 표준 이름으로 리소스를 로드할 수 있다는 것입니다.

00:06:47.000 --> 00:06:52.000
그것은 바느질 가능한 CIKernels를 만드는 과정을 끝낸다.

00:06:52.000 --> 00:06:56.000
이 방법을 사용하는 것의 몇 가지 이점은 언급할 가치가 있다.

00:06:56.000 --> 00:07:00.000
스티치 가능한 커널은 다른 금속 라이브러리와 연결할 수 있다.

00:07:00.000 --> 00:07:06.000
그리고 그들은 이제 정수와 부호 없는 정수 벡터 유형의 입력 매개 변수를 지원합니다.

00:07:06.000 --> 00:07:12.000
또 다른 틈새 이점은 런타임에 소스에서 바느질 가능한 커널을 컴파일할 수 있다는 것이다.

00:07:12.000 --> 00:07:18.000
대부분의 응용 프로그램은 초기 컴파일 시간이 더 길어지기 때문에 이 기능을 사용해서는 안 됩니다.

00:07:18.000 --> 00:07:24.000
즉, 이러한 유연성의 혜택을 받을 수 있는 몇 가지 응용 프로그램이 있다.

00:07:24.000 --> 00:07:28.000
이 프레젠테이션에서 다루어야 할 마지막 주제가 하나 있다.

00:07:28.000 --> 00:07:33.000
바느질 가능한 CIKernel 구현은 두 가지 중요한 금속 기능에 달려 있다.

00:07:33.000 --> 00:07:37.000
첫 번째는 새로운 금속 셰이딩 언어 버전 2.4이다.

00:07:37.000 --> 00:07:48.000
무엇보다도, 이 버전은 컴파일러가 추가 메타데이터를 각 기능과 연관시키는 ] 속성을 지원합니다.

00:07:48.000 --> 00:07:56.000
두 번째는 커널이 Core Image Metal 클래스와 연결할 수 있도록 사용되는 Metal Dynamic Libraries 기능입니다.

00:07:56.000 --> 00:08:03.000
이러한 금속 기능에 대한 자세한 내용은 "Discover Compilation Workflows in Metal" 프레젠테이션을 시청하세요.

00:08:03.000 --> 00:08:21.000
하지만 Metal Dynamic Libraries는 일부 그래픽 장치, 특히 A11 이상이 설치된 iPhone 및 iPad, Apple Silicon이 장착된 모든 Mac, AMD Navi 및 Vega GPU가 장착된 Intel Mac에서만 지원된다는 점에 유의하십시오.

00:08:21.000 --> 00:08:30.000
응용 프로그램은 바느질 가능한 CIKernels를 사용하기 전에 Metal 장치 속성 supportsDynamicLibraries를 확인해야 합니다.

00:08:30.000 --> 00:08:39.000
그래서 그것은 당신의 애플리케이션에 Metal CIKernels를 추가하는 두 가지 권장 방법을 사용하는 방법에 대한 단계별 설명을 마칩니다.

00:08:39.000 --> 00:08:46.000
각 방법에 대해 프로젝트를 구성하고, 커널 소스를 작성하고, 커널 객체를 초기화하는 방법을 다루었습니다.

00:08:46.000 --> 00:08:51.000
이를 통해 앱의 이미지와 비디오에 훌륭한 시각 효과를 추가할 수 있기를 바랍니다.

00:08:51.000 --> 00:08:55.000
감사합니다 그리고 나머지 WWDC 2021을 즐기세요!

00:08:55.000 --> 23:59:59.000
♪

