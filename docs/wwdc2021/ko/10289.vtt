WEBVTT

00:00:00.000 --> 00:00:05.000
♪ 베이스 음악 연주 ♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:16.000
제프 로버트슨: SwiftUI에서 훌륭한 Mac 앱을 만드는 것에 대한 이야기의 두 번째 부분에 오신 것을 환영합니다.

00:00:16.000 --> 00:00:21.000
저는 SwiftUI 팀의 엔지니어인 Jeff입니다.

00:00:21.000 --> 00:00:26.000
나는 네가 내 동료 마티유의 이 이야기의 첫 부분을 즐겼기를 바란다.

00:00:26.000 --> 00:00:36.000
아직 1부를 시청하지 않았다면, 여기서 멈추고 지금 그렇게 하세요. 우리는 그 강연에서 논의된 변화들을 바탕으로 구축할 것이기 때문입니다.

00:00:36.000 --> 00:00:41.000
우리의 원예 앱은 마티유의 이야기가 시작된 이후로 먼 길을 왔다.

00:00:41.000 --> 00:00:48.000
SwiftUI를 통해 우리는 매우 짧은 시간에 꽤 많은 기능을 갖춘 앱을 만들 수 있었다.

00:00:48.000 --> 00:00:58.000
그러나, 사용자들은 우리의 앱을 다양한 방식으로 사용하는 경향이 있으며, 특히 훌륭한 macOS 앱이 이를 설명할 것이다.

00:00:58.000 --> 00:01:07.000
그것을 염두에 두고, 마티유가 1부에서 설명한 원칙을 유지하면서 모두를 위한 앱을 만들 수 있는 몇 가지 방법을 살펴봅시다.

00:01:07.000 --> 00:01:19.000
먼저, 우리는 우리 자신의 앱 내에서뿐만 아니라 시스템 전체에 대한 변경 사항을 처리함으로써 완전히 사용자 정의 가능한 macOS 앱이 된다는 것이 무엇을 의미하는지 살펴볼 것입니다.

00:01:19.000 --> 00:01:30.000
사용자가 드래그 앤 드롭을 통해 데이터를 조작할 수 있는 추가 워크플로우를 추가하는 것은 유연한 사용자 경험을 제공하는 또 다른 방법입니다.

00:01:30.000 --> 00:01:37.000
그런 다음, 우리는 앱의 데이터를 내보낼 수 있도록 하여 파일 시스템으로 작업하는 방법을 살펴볼 것입니다.

00:01:37.000 --> 00:01:45.000
그리고 마지막으로, 우리는 이미지들을 앱으로 가져오기 위한 원활한 워크플로우를 만들기 위해 연속성 카메라에 대한 지원을 추가할 것입니다.

00:01:45.000 --> 00:01:56.000
제가 가장 먼저 이야기하고 싶은 것은 특정 API가 아니라 SwiftUI로 구축된 앱이 macOS의 사용자 정의 가능성에 어떻게 맞는지에 대한 것입니다.

00:01:56.000 --> 00:02:00.000
여기, 저는 시스템 환경 설정뿐만 아니라 원예 앱을 열었습니다.

00:02:00.000 --> 00:02:08.000
저는 다크 모드로 전환할 것이고, 당신은 우리 앱이 인터페이스를 자동으로 업데이트하는 것을 볼 수 있습니다.

00:02:08.000 --> 00:02:14.000
시스템 환경 설정이 열려 있는 동안, 사이드바 아이콘 크기를 크게 업데이트할 것입니다.

00:02:14.000 --> 00:02:20.000
다크 모드와 마찬가지로, 우리 앱은 시스템 환경 설정에서 설정한 대로 조정되었습니다.

00:02:20.000 --> 00:02:31.000
나는 개발자로서 이러한 작은 터치를 좋아한다. 왜냐하면 나는 그것들을 자동으로 받기 때문이다. 그리고 사용자로서. 왜냐하면 그것은 내가 사용하고 있는 앱이 내 개인적인 취향을 고려할 것이라는 것을 의미하기 때문이다.

00:02:31.000 --> 00:02:39.000
앱에 집중하기 위해 시스템 환경 설정을 떠나기 전에, 악센트 색상이 다색으로 설정되어 있다는 것을 지적하고 싶습니다.

00:02:39.000 --> 00:02:50.000
이 기능을 통해 개발자는 앱별 악센트 색상을 구성할 수 있으며, 운영 체제는 앱의 버튼, 선택 강조 표시 및 사이드바 글리프를 사용자 정의할 수 있습니다.

00:02:50.000 --> 00:03:02.000
앱에서 악센트 색상을 지원하고 싶기 때문에, 프로젝트에서 자산 카탈로그를 열고 AccentColor를 선택할 것입니다.

00:03:02.000 --> 00:03:08.000
그리고 나는 그 내용을 우리 앱의 테마와 일치하도록 시스템 그린으로 바꿀 것이다.

00:03:08.000 --> 00:03:14.000
보시다시피, 우리의 사이드바 아이콘과 선택은 모두 변경 사항을 선택했습니다.

00:03:14.000 --> 00:03:23.000
우리는 앱이 전체 운영 체제에 영향을 미치는 변경 사항에 어떻게 자동으로 반응할 수 있는지 보았지만, 앱별 설정은 어떻습니까?

00:03:23.000 --> 00:03:28.000
사용자가 원예 앱을 사용자 정의할 수 있도록 인터페이스를 추가하는 과정을 살펴봅시다.

00:03:28.000 --> 00:03:31.000
여기, 저는 GardenApp 파일을 열었습니다.

00:03:31.000 --> 00:03:36.000
그리고 WindowGroup 장면과 함께 설정 장면을 추가할 것입니다.

00:03:36.000 --> 00:03:41.000
그리고 이 장면은 우리에게 선택되었을 때 우리의 시야와 함께 창을 여는 메뉴 항목을 제공할 것이다.

00:03:41.000 --> 00:03:47.000
나는 내가 설정한 SettingsView를 사용할 것이고, 내 모델도 전달할 것이다.

00:03:47.000 --> 00:04:02.000
또한, 설정 장면은 앱의 메인 메뉴에 적절한 메뉴 항목을 추가하고 명령-쉼표의 표준 키보드 단축키로 구성합니다.

00:04:02.000 --> 00:04:04.000
이것은 우리에게 좋은 시작을 준다.

00:04:04.000 --> 00:04:08.000
이제, 인터페이스를 정의할 SettingsView를 살펴봅시다.

00:04:08.000 --> 00:04:22.000
macOS에서는 앱이 도구 모음 아이콘이 있는 설정 인터페이스를 제공하여 다른 창 사이를 전환할 수 있도록 하는 것이 일반적입니다. 특히 앱이 다른 범주로 나눌 수 있는 많은 설정을 제공하는 경우 더욱 그렇습니다.

00:04:22.000 --> 00:04:25.000
그래서 여기서 내 주요 견해를 위해, 나는 TabView를 사용할 것이다.

00:04:25.000 --> 00:04:38.000
그리고 나는 두 명의 자녀를 줄 것이다: 하나는 GeneralSettings를 위한 것이고, 다른 하나는 ViewingSettings를 위한 것이다.

00:04:38.000 --> 00:04:45.000
그리고 창 도구 모음 영역의 탭 내용에 대해, 나는 tabItem을 사용할 것이다.

00:04:45.000 --> 00:04:47.000
그리고 이것의 내용은 그냥 라벨이 될 수 있다.

00:04:47.000 --> 00:04:56.000
우리는 표시할 텍스트를 제공할 것입니다 - 이 경우, "일반" - 그리고 systemImage; 저는 GeneralSettings에 "기어"를 사용할 것입니다.

00:04:56.000 --> 00:04:59.000
그리고 나서 ViewingSettings에 대해서도 똑같이 합시다.

00:04:59.000 --> 00:05:09.000
나는 tabItem과 라벨을 추가할 것이다 - 우리는 그것을 "보기"라고 부를 것이다 - 그리고 시스템 이미지는, 내 생각에, "안경"이다.

00:05:09.000 --> 00:05:13.000
알았어. 그래서 이제 우리는 두 탭의 내용을 가지고 있다.

00:05:13.000 --> 00:05:16.000
이제 일반 설정을 작성해 봅시다.

00:05:16.000 --> 00:05:26.000
사용자에게 좋을 수 있는 것은 현재 정원이 선택되지 않을 때 기본값으로 사용할 정원을 정의할 수 있는 능력입니다.

00:05:26.000 --> 00:05:29.000
이를 위해, 나는 피커를 추가할 거야...

00:05:29.000 --> 00:05:46.000
그리고 내 생각에 첫 번째 항목은 텍스트("없음")가 될 것이다.

00:05:46.000 --> 00:05:52.000
그리고 다른 사람들을 위해, 나는 우리 데이터의 모든 정원에 ForEach를 추가할 것이다.

00:05:52.000 --> 00:06:14.000
그리고 각 정원에 대해, 나는 그냥 텍스트를 추가하고 정원의 이름과 전시 연도를 줄 것이다.

00:06:14.000 --> 00:06:21.000
우리는 또한 여기에 정원의 ID가 있는 태그를 제공해야 할 것이다.

00:06:21.000 --> 00:06:27.000
그래서 우리의 "없음" 가치에 대해, 우리는 그것에 아무것도 없는 태그를 줄 수 있다.

00:06:27.000 --> 00:06:34.000
그리고 우리의 다른 정원의 경우, 우리는 정원의 ID에 해당하는 태그를 줄 것이다.

00:06:34.000 --> 00:06:46.000
마지막으로, 우리는 피커의 선택을 위한 상태를 제공해야 한다.

00:06:46.000 --> 00:06:56.000
이와 같은 설정 인터페이스를 제공할 때, 앱이 실행 및 OS 업데이트에서 사용자의 선택을 기억할 수 있도록 상태를 유지하는 것이 중요합니다.

00:06:56.000 --> 00:07:01.000
SwiftUI에서, 이것은 AppStorage 속성 래퍼를 사용하여 수행할 수 있다.

00:07:01.000 --> 00:07:09.000
이 속성 래퍼는 UserDefaults 시스템을 사용하여 우리의 가치를 유지할 것이며, 이는 정확히 우리가 여기서 원하는 것입니다.

00:07:09.000 --> 00:07:15.000
그래서 우리의 선택 바인딩을 위해, 나는 AppStorage 속성 래퍼를 추가할 것이다.

00:07:15.000 --> 00:07:17.000
이건 열쇠가 필요해.

00:07:17.000 --> 00:07:24.000
우리는 그것을 "defaultGarden"에 줄 것이고, 우리는 그것을 "선택"이라고 부를 것이다.

00:07:24.000 --> 00:07:28.000
그것은 또한 선택 사항인 Garden.ID이다.

00:07:28.000 --> 00:07:35.000
그리고 이것이 할 일은 사용자 기본 시스템을 사용하여 우리의 선택 값을 유지하는 것이다.

00:07:35.000 --> 00:07:41.000
나는 또한 내 피커에 고정 사이즈를 추가하고 양식에 패딩을 추가할 것이다.

00:07:41.000 --> 00:07:56.000
나는 여기서 ContentView로 전환할 것이고, AppStorage를 추가하고 우리가 사용한 것과 같은 키를 줄 것이다.

00:07:56.000 --> 00:08:09.000
우리는 그것을 "defaultGardenID"라고 부를 것이며, 또한 선택 사항인 Garden.ID이기도 합니다.

00:08:09.000 --> 00:08:22.000
그리고 여기 내가 선택을 위한 이 바인딩이 있는 곳에서, 나는 이것을 바인딩으로 대체할 것이고, "get"은 먼저 selectedGardenID를 사용하는 것이다.

00:08:22.000 --> 00:08:27.000
그리고 그것이 설정되지 않았다면, 우리는 defaultGardenID로 돌아갈 것이다.

00:08:27.000 --> 00:08:32.000
그리고 세터를 위해, 우리는 선택한GardenID만 업데이트하고 싶습니다.

00:08:32.000 --> 00:08:35.000
우리는 실제로 디폴트 가든을 업데이트하고 싶지 않습니다.

00:08:35.000 --> 00:08:40.000
그래서 난 그냥 "selectedGardenID = $0"이라고 말할 거야.

00:08:40.000 --> 00:08:44.000
알았어.

00:08:44.000 --> 00:08:46.000
나는 우리 앱을 실행할 거야.

00:08:46.000 --> 00:08:56.000
여기서 환경 설정 메뉴 항목을 열면, 실내 식물을 기본 정원으로 선택할 것입니다.

00:08:56.000 --> 00:09:01.000
그리고 나는 새 창을 열 것이고, 우리는 실내 식물이 선택된 것을 볼 것이다.

00:09:01.000 --> 00:09:08.000
설정을 통해 사용자 지정 지원을 제공하는 것은 사용자를 위한 유연한 경험을 구축하는 좋은 방법 중 하나입니다.

00:09:08.000 --> 00:09:13.000
또 다른 방법은 동일한 작업에 대한 대체 워크플로우를 제공하는 것이다.

00:09:13.000 --> 00:09:19.000
우리 이야기의 첫 번째 부분에서, 마티유는 선택한 정원에 식물을 추가하기 위한 메인 메뉴 항목을 추가하는 방법을 보여주었습니다.

00:09:19.000 --> 00:09:30.000
이것은 우리 앱의 훌륭한 기능이지만, 일반적인 macOS 사용자 상호 작용을 통해 유사한 기능을 제공할 수 있는 또 다른 방법을 살펴봅시다: 드래그 앤 드롭.

00:09:30.000 --> 00:09:36.000
우리가 여기서 테이블을 사용하고 있기 때문에, 드래그 소스와 드롭 목적지가 되는 것을 지원하기 위해 몇 가지 조정을 할 것입니다.

00:09:36.000 --> 00:09:42.000
내가 가장 먼저 할 일은 이니셜라이저에서 이 "식물"을 제거하는 것이다.

00:09:42.000 --> 00:09:49.000
그럼 난 마지막에 내려가서 행 빌더를 추가할 거야.

00:09:49.000 --> 00:09:55.000
이 행 빌더의 내용을 위해, 나는 ForEach를 추가하고 우리가 이전에 가지고 있던 식물들을 사용할 것이다.

00:09:55.000 --> 00:10:05.000
그리고 각 식물에 대해, 나는 그것으로 테이블로우를 만들 것이다.

00:10:05.000 --> 00:10:12.000
그래서 이제 저는 itemProvider 수정자를 추가하여 각 TableRows를 사용자 정의할 것입니다.

00:10:12.000 --> 00:10:20.000
그리고 저는 여기에 plant.itemProvider를 반환할 것입니다. 이는 제가 모델에 설정한 계산된 자산입니다.

00:10:20.000 --> 00:10:24.000
그래서 이제 이 행들 각각은 드래그 소스가 되는 것을 지원합니다.

00:10:24.000 --> 00:10:31.000
나는 이제 내 식물을 끌어낼 수 있도록 충분한 변화를 만들었지만, 아무것도 그것을 받아들이지 않는다면 이것은 그다지 유용하지 않다.

00:10:31.000 --> 00:10:35.000
우리 테이블에 드롭 지원을 추가하여 그것을 해결합시다.

00:10:35.000 --> 00:10:39.000
onInsert 수정자는 우리의 드래그 앤 드롭 방정식의 나머지 절반이다.

00:10:39.000 --> 00:10:50.000
콘텐츠 유형 목록이 필요하며, 여기에 내 모델에 설정한 사용자 지정 유형인 Plant.draggableType을 전달할 것입니다.

00:10:50.000 --> 00:10:53.000
그것은 또한 두 개의 매개 변수를 통과하는 폐쇄가 필요하다.

00:10:53.000 --> 00:10:59.000
하나는 하락이 발생한 인덱스이고, 다른 하나는 아이템 제공자 목록이다.

00:10:59.000 --> 00:11:09.000
그런 다음 Plant.fromItemProviders에 전화하여 모델을 만들고, 그 아이템 제공 업체를 여기로 전달할 것입니다.

00:11:09.000 --> 00:11:14.000
이것은 우리가 모델을 업데이트하는 데 사용할 수 있는 식물 목록을 돌려줄 것이다.

00:11:14.000 --> 00:11:29.000
나는 그것이 발생한 색인에서 garden.plants.insert (contentsOf: plants)라고 부를 것이다.

00:11:29.000 --> 00:11:42.000
이제 실내 식물로 새 창을 열고, 뒷마당 화단에서 꽃 몇 개를 선택하고, 드래그하여 복사할 수 있습니다.

00:11:42.000 --> 00:11:50.000
드래그 앤 드롭은 앱 내에서 데이터를 이동할 수 있는 좋은 방법이지만, 앱과 운영 체제 간에 데이터를 이동하는 것은 어떻습니까?

00:11:50.000 --> 00:11:58.000
우리 사용자들은 아마도 백업 목적이나 다른 앱으로 가져오기 위해 이 모든 데이터를 내보낼 수 있다면 감사할 것입니다.

00:11:58.000 --> 00:12:08.000
이 워크플로우를 용이하게 하기 위해, 다른 응용 프로그램과 공유할 수 있는 공통 파일 형식으로 데이터베이스를 내보내기 위한 기본 메뉴 항목을 추가해 봅시다.

00:12:08.000 --> 00:12:14.000
나는 이미 명령 프로토콜을 준수하는 메뉴 항목을 포함하는 유형을 만들었다.

00:12:14.000 --> 00:12:23.000
여기 우리의 명령에서, 나는 ImportExportCommands를 추가하고 우리 가게에 전달할 것이다.

00:12:23.000 --> 00:12:26.000
지금 그 파일로 바꾸자.

00:12:26.000 --> 00:12:37.000
그리고 본문을 위해, 저는 CommandGroup을 추가하고 시스템에서 제공하는 importExport 배치를 대체할 것입니다.

00:12:37.000 --> 00:12:44.000
그리고 이것이 할 일은 파일 메뉴의 예상 위치에 메뉴 항목을 추가하는 것입니다.

00:12:44.000 --> 00:12:50.000
그래서 우리 CommandGroup의 내용을 위해, 나는 섹션과 버튼을 추가할 것이다.

00:12:50.000 --> 00:12:55.000
우리는 타원과 "수출"이라는 라벨을 붙일 것이다.

00:12:55.000 --> 00:13:02.000
줄임표는 사용자에게 해당 항목을 선택하면 창이나 저장 대화상자가 열릴 것임을 나타냅니다.

00:13:02.000 --> 00:13:13.000
그리고 버튼은 일부 상태를 수정할 수 있습니다 - "isShowingExport = true" - 그리고 그 상태도 여기에 추가합시다.

00:13:13.000 --> 00:13:24.000
그래서 이제 우리는 어떤 상태를 수정하는 버튼을 가지고 있다.

00:13:24.000 --> 00:13:29.000
나는 또한 여기에 fileExporter 수정자를 추가할 것이다.

00:13:29.000 --> 00:13:37.000
그리고 나는 그것의 isPresented 매개 변수에서 우리 상태에 대한 구속력을 줄 것이다.

00:13:37.000 --> 00:13:40.000
수출을 보여줘.

00:13:40.000 --> 00:13:42.000
문서도 필요하다.

00:13:42.000 --> 00:13:49.000
이것은 파일 문서 프로토콜 또는 참조 파일 문서 프로토콜을 준수해야 하는 유형입니다.

00:13:49.000 --> 00:13:53.000
나는 이미 내 가게에 적합성을 추가했으므로, 우리는 그것을 여기에 전달할 것이다.

00:13:53.000 --> 00:13:56.000
게다가, 그것은 콘텐츠 유형이 필요하다.

00:13:56.000 --> 00:14:07.000
우리는 CSV 유형인 Store.readableContentTypes.first를 제공할 것입니다.

00:14:07.000 --> 00:14:15.000
그리고 마지막으로, 성공 또는 실패를 나타내는 수술 결과를 통과하는 폐쇄가 필요하다.

00:14:15.000 --> 00:14:31.000
이제 내보내기 메뉴 항목을 선택하고, 저장할 파일을 "plants.csv"라고 말하고, 내보내기를 누르면 파일이 디스크에 저장됩니다.

00:14:31.000 --> 00:14:39.000
우리가 앱과 운영 체제 간에 데이터를 이동하는 주제를 다루는 동안, 마지막으로 논의하고 싶은 것이 하나 있습니다.

00:14:39.000 --> 00:14:45.000
우리 앱에는 식물에 대한 많은 텍스트 데이터가 있지만, 이미지를 추가하는 것도 좋을 것이다.

00:14:45.000 --> 00:14:49.000
사용자는 진행 상황을 추적하기 위해 시간이 지남에 따라 식물의 사진을 찍을 수 있다.

00:14:49.000 --> 00:14:53.000
이 가져오기 흐름을 활성화하는 한 가지 방법은 연속성 카메라를 사용하는 것이다.

00:14:53.000 --> 00:15:00.000
이 기능을 통해 사용자는 iOS 장치로 식물의 사진을 찍고 앱으로 직접 가져올 수 있습니다.

00:15:00.000 --> 00:15:08.000
사용자가 갤러리 보기에서 식물을 선택했을 때 이 흐름을 활성화하기 위해 메뉴 항목을 추가하는 방법을 살펴봅시다.

00:15:08.000 --> 00:15:18.000
importExportCommands 후에, 나는 ImportFromDevicesCommands를 추가할 것이고, 그것은 우리에게 메인 메뉴 항목을 제공할 것이다.

00:15:18.000 --> 00:15:35.000
또한, 저는 GardenDetail 파일로 전환할 것이며, 여기서 우리 몸의 끝에서 importsItemProviders 수정자를 추가할 것이며, 이것은 우리가 수입을 지원하고 싶은 유형의 목록을 취합니다.

00:15:35.000 --> 00:15:42.000
나는 어떤 것이 선택되었는지 여부에 기초할 것이다, 그래서 나는 여기서 우리의 선택을 사용할 것이다.

00:15:42.000 --> 00:15:50.000
그리고 만약 그것이 비어 있다면, 나는 빈 배열을 반환할 것이다.

00:15:50.000 --> 00:16:00.000
그리고 비어 있지 않다면, 시스템의 모든 이미지 유형 목록인 Plant.importImageTypes를 반환할 것입니다.

00:16:00.000 --> 00:16:07.000
그리고 이 수정자는 항목 제공자 목록을 통과하는 폐쇄를 취한다.

00:16:07.000 --> 00:16:22.000
우리는 그 공급자를 데려가서 Plant.importImageFromProviders에 전화를 걸어 공급자에게 전달할 것이며, 이것은 우리에게 이미지를 디스크에 저장한 URL을 돌려줄 것이다.

00:16:22.000 --> 00:16:27.000
그런 다음 선택된 모든 ID를 반복하여 모델을 업데이트할 것입니다...

00:16:27.000 --> 00:16:41.000
...그리고 공장에 대한 참조를 얻고 imageURL을 업데이트하세요.

00:16:41.000 --> 00:16:46.000
나는 실내 식물 정원을 선택하고 갤러리 모드로 전환할 것이다.

00:16:46.000 --> 00:16:49.000
그리고 나는 물건을 조금 더 크게 만들 거야.

00:16:49.000 --> 00:16:51.000
여기서 내 식물을 선택해.

00:16:51.000 --> 00:17:00.000
메인 메뉴 항목에서, iPhone에서 가져오기 &gt; 사진 찍기를 선택하세요.

00:17:00.000 --> 00:17:06.000
그리고 당신은 우리의 갤러리가 업데이트된 것을 볼 수 있습니다.

00:17:06.000 --> 00:17:11.000
나는 이것이 훌륭한 맥 앱을 정의하는 다양한 방법 중 일부에 대한 좋은 여행이었기를 바랍니다.

00:17:11.000 --> 00:17:16.000
저는 당신의 앱이 macOS 플랫폼을 더 좋게 만들 모든 방법을 기대하고 있습니다.

00:17:16.000 --> 00:17:20.000
멋진 WWDC 2021을 보내세요.

00:17:20.000 --> 23:59:59.000
♪

