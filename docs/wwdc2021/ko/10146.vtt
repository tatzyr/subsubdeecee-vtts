WEBVTT

00:00:00.000 --> 00:00:05.000
♪ 베이스 음악 연주 ♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:15.000
아담 소넌스타인: 안녕하세요! 제 이름은 아담이고, 저는 오늘 AVFoundation의 새로운 기능을 보여주기 위해 왔습니다.

00:00:15.000 --> 00:00:17.000
우리는 오늘 논의할 세 가지 새로운 기능이 있다.

00:00:17.000 --> 00:00:30.000
우리는 AVAsset 검사 세계의 새로운 것에 대해 이야기하는 데 대부분의 시간을 할애할 것이며, 그 다음 두 가지 다른 기능에 대한 간략한 소개를 할 것입니다: 메타데이터를 사용한 비디오 합성과 캡션 파일 작성.

00:00:30.000 --> 00:00:37.000
그래서 더 이상 고민하지 말고, AVAsset 비동기 검사라는 첫 번째 주제로 넘어가자.

00:00:37.000 --> 00:00:42.000
하지만 먼저, AVAsset에 대한 재교육으로 시작하는 약간의 배경.

00:00:42.000 --> 00:00:58.000
AVAsset은 사용자의 장치에 저장된 영화 파일, 원격 서버와 같은 다른 곳에 저장된 영화 파일, HTTP 라이브 스트림 및 구성과 같은 다른 형태의 시청각 콘텐츠와 같은 것을 나타내는 AVFoundation의 핵심 모델 객체입니다.

00:00:58.000 --> 00:01:05.000
그리고 당신이 자산이 있을 때, 당신은 가장 자주 그것을 하고 싶지만, 자주, 당신은 그것을 검사하고 싶을 것입니다.

00:01:05.000 --> 00:01:11.000
당신은 그것에 다음과 같은 질문을 하고 싶습니다, 그것의 지속 시간은 얼마입니까, 또는 그것이 포함하는 오디오와 비디오의 형식은 무엇입니까?

00:01:11.000 --> 00:01:16.000
그리고 그것이 우리가 이 주제에서 정말로 이야기할 것이다: 자산 검사.

00:01:16.000 --> 00:01:22.000
그리고 자산을 검사할 때마다, 명심해야 할 두 가지 중요한 사항이 있습니다.

00:01:22.000 --> 00:01:26.000
첫 번째는 자산 검사가 수요에 따라 이루어진다는 것이다.

00:01:26.000 --> 00:01:29.000
이것은 주로 영화 파일이 꽤 클 수 있기 때문이다.

00:01:29.000 --> 00:01:32.000
장편 영화는 몇 기가바이트의 크기가 될 수 있다.

00:01:32.000 --> 00:01:38.000
나중에 기간을 요청할 경우를 대비하여 자산이 전체 파일을 열심히 다운로드하는 것을 원하지 않을 것입니다.

00:01:38.000 --> 00:01:47.000
대신, 자산은 당신이 부동산 가치를 로드하도록 요청할 때까지 기다린 다음, 당신에게 그 가치를 제공하는 데 필요한 정보만 다운로드합니다.

00:01:47.000 --> 00:01:52.000
두 번째로 명심해야 할 것은 자산 검사가 비동기 과정이라는 것이다.

00:01:52.000 --> 00:01:55.000
네트워크 I/O는 시간이 좀 걸릴 수 있기 때문에 이것은 정말 중요하다.

00:01:55.000 --> 00:02:03.000
자산이 네트워크를 통해 저장되는 경우, AVAsset이 동기 네트워크 요청을 발행하는 동안 앱의 메인 스레드가 차단되는 것을 원하지 않을 것입니다.

00:02:03.000 --> 00:02:08.000
대신, AVAsset은 준비가 되면 비동기적으로 결과를 전달할 것이다.

00:02:08.000 --> 00:02:16.000
이 두 가지를 염두에 두고, 우리는 자산 속성을 검사하기 위한 새로운 API를 가지고 있으며, 약간 이렇게 보입니다.

00:02:16.000 --> 00:02:25.000
주목해야 할 중요한 것은 어떤 속성 값을 로드할지 알려주기 위해 속성 식별자(이 경우 .duration)를 취하는 이 새로운 로드 방법입니다.

00:02:25.000 --> 00:02:33.000
각 속성 식별자는 컴파일 타임의 결과 유형과 관련이 있으며, 이는 로드 메소드의 반환 유형을 결정합니다.

00:02:33.000 --> 00:02:38.000
이 경우, 기간은 CMTime이므로, 결과는 CMTime이다.

00:02:38.000 --> 00:02:42.000
당신이 전에 본 적이 없는 한 가지는 이 대기 키워드입니다.

00:02:42.000 --> 00:02:48.000
이것은 스위프트의 새로운 기능이며, 호출 사이트에서 로드 방법이 비동기적이라는 것을 표시하는 데 사용됩니다.

00:02:48.000 --> 00:02:58.000
Async/await와 Swift의 광범위한 동시성 노력에 대한 모든 세부 사항은 "Meet async/await in Swift"라는 세션을 확인하는 것이 좋습니다.

00:02:58.000 --> 00:03:07.000
현재로서는, 우리의 새로운 속성 로딩 방법을 사용하는 방법을 이해하는 빠른 방법으로, 나는 await 키워드를 호출 함수를 두 부분으로 나누는 것으로 생각하고 싶다.

00:03:07.000 --> 00:03:11.000
먼저, 비동기 작업이 시작되기 전에 일어나는 부분이 있다.

00:03:11.000 --> 00:03:15.000
이 경우, 우리는 자산을 만들고 그 기간을 로드하도록 요청합니다.

00:03:15.000 --> 00:03:22.000
이 시점에서, 자산은 중단되고 기간을 결정하는 데 필요한 I/O와 구문 분석을 하고 우리는 그 결과를 기다린다.

00:03:22.000 --> 00:03:30.000
우리가 기다리는 동안, 호출 함수는 일시 중지되며, 이는 대기 후에 작성된 코드가 즉시 실행되지 않는다는 것을 의미합니다.

00:03:30.000 --> 00:03:33.000
그러나, 우리가 실행하고 있던 스레드는 차단되지 않았다.

00:03:33.000 --> 00:03:36.000
대신, 우리가 기다리는 동안 더 많은 일을 하는 것은 자유롭다.

00:03:36.000 --> 00:03:42.000
비동기 기간 로딩이 완료되면, 기능의 후반부가 실행될 예정이다.

00:03:42.000 --> 00:03:50.000
이 경우, 기간 로딩이 성공하면, 기간을 로컬 상수로 저장하고 다른 기능으로 보냅니다.

00:03:50.000 --> 00:03:56.000
또는, 작업이 실패하면, 호출 함수가 재개되면 오류가 발생합니다.

00:03:56.000 --> 00:04:00.000
그래서 그것이 속성 값을 비동기적으로 로드하는 기본이다.

00:04:00.000 --> 00:04:08.000
또한 여러 속성의 값을 한 번에 로드할 수 있으며, 로드 방법에 하나 이상의 속성 식별자를 전달하기만 하면 됩니다.

00:04:08.000 --> 00:04:13.000
이 경우, 우리는 기간과 트랙을 동시에 로드하고 있습니다.

00:04:13.000 --> 00:04:16.000
이것은 편리할 뿐만 아니라, 더 효율적일 수도 있다.

00:04:16.000 --> 00:04:23.000
자산이 당신이 관심 있는 모든 속성을 알고 있다면, 값을 로드하는 데 필요한 작업을 일괄 처리할 수 있습니다.

00:04:23.000 --> 00:04:30.000
여러 속성 값을 로드한 결과는 속성 식별자에 사용한 것과 동일한 순서로 로드된 값을 가진 튜플입니다.

00:04:30.000 --> 00:04:34.000
단일 속성 값을 로드하는 것과 마찬가지로, 이것은 유형이 안전합니다.

00:04:34.000 --> 00:04:42.000
이 경우, 결과 튜플의 첫 번째 요소는 CMTime이고 두 번째 요소는 AVAssetTracks의 배열이다.

00:04:42.000 --> 00:04:47.000
그리고 물론, 단일 값을 로드하는 것과 마찬가지로, 이것은 비동기 작업이다.

00:04:47.000 --> 00:04:58.000
속성 값을 비동기적으로 로드하는 것 외에도, 새로운 status(of: ) 메서드를 사용하여 언제든지 값이 로드될 때까지 기다리지 않고도 속성의 상태를 확인할 수 있습니다.

00:04:58.000 --> 00:05:04.000
로드 메소드에 사용하는 것과 동일한 속성 식별자를 전달하면, 이것은 네 가지 가능한 사례가 있는 열거형을 반환합니다.

00:05:04.000 --> 00:05:07.000
각 속성은 .notYetLoaded로 시작합니다.

00:05:07.000 --> 00:05:16.000
자산 검사는 필요에 따라 발생한다는 것을 기억하세요, 그래서 당신이 부동산 가치를 로드하도록 요청할 때까지, 자산은 그것을 로드하기 위해 어떤 작업도 하지 않을 것입니다.

00:05:16.000 --> 00:05:21.000
로딩이 진행되는 동안 상태를 확인하면, .loading 케이스를 받게 될 것입니다.

00:05:21.000 --> 00:05:29.000
또는, 속성이 이미 로드된 경우, 관련 값으로 로드된 값과 함께 번들로 제공되는 .loaded 케이스를 받게 됩니다.

00:05:29.000 --> 00:05:38.000
마지막으로, 실패가 발생하면 - 아마도 네트워크가 다운되었기 때문에 - 무엇이 잘못되었는지 설명하는 오류와 함께 번들로 제공되는 .failed 케이스를 받게 될 것입니다.

00:05:38.000 --> 00:05:46.000
이것은 실패한 로딩 요청을 시작한 로드 메소드의 호출에 의해 던져진 것과 동일한 오류입니다.

00:05:46.000 --> 00:05:51.000
그래서 그것은 비동기 속성을 로드하고 상태를 확인하기 위한 새로운 API입니다.

00:05:51.000 --> 00:05:56.000
AVAsset은 값을 비동기적으로 로드할 수 있는 꽤 많은 속성을 가지고 있다.

00:05:56.000 --> 00:06:06.000
이들 중 대부분은 독립적인 값을 판매하지만, .tracks와 .metadata 속성은 자산의 계층 구조로 내려가는 데 사용할 수 있는 더 복잡한 객체를 판매합니다.

00:06:06.000 --> 00:06:10.000
.Tracks 속성의 경우, AVAssetTracks 배열을 얻을 수 있습니다.

00:06:10.000 --> 00:06:18.000
AVAssetTrack에는 동일한 로드 방법을 사용하여 값을 비동기적으로 로드할 수 있는 자체 속성 컬렉션이 있습니다.

00:06:18.000 --> 00:06:29.000
마찬가지로, .metadata 속성은 AVMetadataItems의 배열을 제공하며, 로드 방법을 사용하여 여러 AVMetadataItem 속성을 비동기적으로 로드할 수도 있습니다.

00:06:29.000 --> 00:06:37.000
이 영역의 새로운 API의 마지막 비트는 특정 속성 값의 특정 하위 집합을 얻는 데 사용할 수 있는 비동기 메서드 모음입니다.

00:06:37.000 --> 00:06:46.000
예를 들어, 모든 트랙을 로드하는 대신, 이 처음 세 가지 방법 중 하나를 사용하여 트랙 중 일부만 로드할 수 있습니다. 예를 들어, 오디오 트랙만 로드할 수 있습니다.

00:06:46.000 --> 00:06:51.000
AVAsset과 AVAssetTrack 모두에 이와 같은 몇 가지 새로운 방법이 있습니다.

00:06:51.000 --> 00:06:56.000
그래서 그것이 우리가 자산을 비동기적으로 검사하기 위해 가지고 있는 모든 새로운 API이다.

00:06:56.000 --> 00:07:00.000
하지만 이 시점에서, 나는 작은 고백을 해야 한다.

00:07:00.000 --> 00:07:02.000
이 기능 중 어느 것도 실제로 새로운 것이 아니다.

00:07:02.000 --> 00:07:09.000
API는 새로운 것이지만, 이 클래스들은 항상 속성 값을 비동기적으로 로드할 수 있는 능력을 가지고 있다.

00:07:09.000 --> 00:07:14.000
단지, 오래된 API를 사용하면, 당신은 이와 같은 코드를 더 많이 작성해야 했을 것입니다.

00:07:14.000 --> 00:07:16.000
그것은 3단계 과정이었다.

00:07:16.000 --> 00:07:23.000
먼저 loadValuesAsynchronously 메소드를 호출하여 어떤 속성을 로드할지 알려주는 문자열을 부여해야 합니다.

00:07:23.000 --> 00:07:29.000
그런 다음 각 속성이 실제로 성공적으로 로드되었고 실패하지 않았는지 확인해야 합니다.

00:07:29.000 --> 00:07:38.000
그런 다음, 일단 그렇게 멀리 도달하면, 해당 동기 속성을 쿼리하거나 동기 필터링 방법 중 하나를 호출하여 로드된 값을 가져올 수 있습니다.

00:07:38.000 --> 00:07:43.000
이것은 장황하고 반복적일 뿐만 아니라, 오용하기도 쉽다.

00:07:43.000 --> 00:07:49.000
예를 들어, 이러한 필수 로딩 및 상태 확인 단계를 수행하는 것을 잊는 것은 매우 쉽습니다.

00:07:49.000 --> 00:08:00.000
남은 것은 언제든지 호출할 수 있는 이러한 동기식 속성과 메서드이지만, 속성 값을 먼저 로드하지 않고 호출하면 결국 I/O를 차단하게 됩니다.

00:08:00.000 --> 00:08:06.000
만약 당신이 메인 스레드에서 이것을 한다면, 이것은 당신의 앱이 예측할 수 없는 시간에 중단될 수 있다는 것을 의미합니다.

00:08:06.000 --> 00:08:21.000
따라서 새로운 API가 단순히 사용하기 쉽다는 사실 외에도, 이러한 일반적인 오용을 제거한다는 사실은 향후 릴리스에서 Swift 클라이언트를 위한 오래된 동기 API를 중단할 계획이라는 것을 의미합니다.

00:08:21.000 --> 00:08:29.000
이것은 이러한 인터페이스의 새로운 비동기 버전으로 이동할 수 있는 좋은 시간이며, 이를 돕기 위해 짧은 마이그레이션 가이드를 준비했습니다.

00:08:29.000 --> 00:08:43.000
따라서, 값을 로드하고, 상태를 확인한 다음, 동기 속성을 잡는 삼중주를 수행하는 경우, 이제 로드 메소드를 호출하고 하나의 비동기 단계에서 모든 것을 수행할 수 있습니다.

00:08:43.000 --> 00:08:55.000
마찬가지로, 3단계 프로세스를 수행하지만 속성 대신 동기식 필터링 방법을 사용하는 경우, 이제 해당 필터링 방법에 상응하는 비동기 프로세스를 호출하여 한 단계로 수행할 수 있습니다.

00:08:55.000 --> 00:09:13.000
이전 statusOfValue(forKey: ) 메서드를 사용하여 속성의 상태를 전환한 다음 .loaded 케이스에 있는 것을 볼 때 동기 속성 값을 잡는 경우, 이제 새 상태 열거형의 .loaded 케이스가 .loaded 값과 함께 번들로 제공된다는 사실을 활용할 수 있습니다.

00:09:13.000 --> 00:09:25.000
앱이 코드의 한 부분에 속성 값을 로드한 다음 코드의 다른 부분에서 로드된 값을 가져오는 것과 같이 조금 더 흥미로운 일을 하고 있다면, 새로운 인터페이스로 이것을 할 수 있는 몇 가지 방법이 있습니다.

00:09:25.000 --> 00:09:28.000
로드 메소드를 다시 호출하는 것이 좋습니다.

00:09:28.000 --> 00:09:35.000
이것은 그것을 하는 가장 쉽고 안전한 방법이며, 재산이 이미 로드되었다면, 이것은 이미 완료된 작업을 복제하지 않을 것이다.

00:09:35.000 --> 00:09:38.000
대신, 그것은 캐시된 값을 반환할 것이다.

00:09:38.000 --> 00:09:46.000
그러나, 이것에 대한 한 가지 주의 사항이 있는데, 로드 메소드는 비동기 메소드이기 때문에 비동기 컨텍스트에서만 호출할 수 있다는 것이다.

00:09:46.000 --> 00:09:58.000
따라서 순수한 동기 컨텍스트에서 속성의 값을 정말로 얻어야 한다면, 속성의 상태를 얻고 속성의 값을 동기적으로 잡기 위해 로드되었다고 주장하는 것과 같은 일을 할 수 있습니다.

00:09:58.000 --> 00:10:06.000
여전히, 당신은 이것을 조심해야 합니다. 왜냐하면 재산이 이미 적재된 후에도 실패할 수 있기 때문입니다.

00:10:06.000 --> 00:10:19.000
마지막으로, 로딩 및 상태 확인 단계를 건너뛰고 결과를 사용할 수 있을 때까지 차단하는 속성과 방법의 현재 동작에 의존한다면, 음, 우리는 실제로 이에 대한 대체물을 제공하지 않습니다.

00:10:19.000 --> 00:10:24.000
이것은 API를 사용하는 권장되는 방법이었으며, 그래서 우리는 항상 그것을 낙담해 왔습니다.

00:10:24.000 --> 00:10:35.000
우리는 새로운 속성 로딩 API를 간단한 속성을 가져오는 것만큼 사용하기 쉽도록 설계했기 때문에, 새로운 API로 마이그레이션하는 것은 간단해야 합니다.

00:10:35.000 --> 00:10:38.000
그리고 그것과 함께, 그것이 우리의 첫 번째 주제의 전부이다.

00:10:38.000 --> 00:10:46.000
나는 스위프트의 새로운 비동기 기능을 사용하여 자산을 검사하는 우리의 새로운 방법에 대해 정말 흥분되며, 당신이 나만큼 그것들을 사용하는 것을 즐기길 바랍니다.

00:10:46.000 --> 00:10:52.000
이제 두 가지 짧은 주제 중 첫 번째로 넘어가자: 메타데이터를 사용한 비디오 합성.

00:10:52.000 --> 00:11:01.000
여기서 우리는 여러 비디오 트랙을 가져와 단일 비디오 프레임 스트림으로 구성하는 과정인 비디오 합성에 대해 이야기하고 있습니다.

00:11:01.000 --> 00:11:10.000
그리고 특히, 우리는 당신이 합성을 수행하는 코드를 제공하는 사용자 지정 비디오 컴포지터를 위한 개선 사항을 가지고 있습니다.

00:11:10.000 --> 00:11:17.000
올해 새로, 사용자 지정 컴포지터의 프레임 컴포지션 콜백에서 프레임별 메타데이터를 받을 수 있습니다.

00:11:17.000 --> 00:11:29.000
예를 들어, 일련의 GPS 데이터가 있고, 그 데이터가 타임 스탬프되고 비디오와 동기화되어 있으며, 프레임이 함께 구성되는 방식에 영향을 미치기 위해 GPS 데이터를 사용하고 싶다고 가정해 봅시다.

00:11:29.000 --> 00:11:36.000
지금 그렇게 할 수 있으며, 첫 번째 단계는 GPS 데이터를 소스 영화의 시간 측정 메타데이터 트랙에 쓰는 것입니다.

00:11:36.000 --> 00:11:43.000
AVAssetWriter로 이것을 하려면, 기존 클래스인 AVAssetWriter InputMetadataAdaptor를 확인하세요.

00:11:43.000 --> 00:11:46.000
이제 새로운 API를 살펴봅시다.

00:11:46.000 --> 00:11:51.000
특정 트랙 컬렉션이 있는 소스 영화로 시작한다고 가정해 봅시다.

00:11:51.000 --> 00:11:56.000
아마도 그것은 오디오 트랙, 두 개의 비디오 트랙, 그리고 세 개의 타임 메타데이터 트랙을 가지고 있을 것이다.

00:11:56.000 --> 00:12:04.000
하지만 4번과 5번 트랙에는 비디오 합성에 유용한 메타데이터가 포함되어 있지만, 6번 트랙은 관련이 없다고 가정해 봅시다.

00:12:04.000 --> 00:12:18.000
수행해야 할 두 가지 설정 단계가 있으며, 첫 번째는 새로운 소스 SampleDataTrackIDs 속성을 사용하여 비디오 구성 개체에 전체 비디오 구성과 관련된 모든 시간 메타데이터 트랙의 ID를 알려주는 것입니다.

00:12:18.000 --> 00:12:34.000
그렇게 하면, 두 번째 단계는 각 비디오 구성 지침을 취하고 유사한 작업을 수행하는 것이지만, 이번에는 특정 지침과 관련된 트랙 ID 또는 ID를 알리기 위해 requiredSourceSampleData TrackIDs 속성을 설정합니다.

00:12:34.000 --> 00:12:41.000
이 두 설정 단계를 모두 수행하는 것이 중요합니다. 그렇지 않으면 컴포지션 콜백에서 메타데이터를 얻지 못할 것입니다.

00:12:41.000 --> 00:12:44.000
이제 콜백 자체로 넘어가자.

00:12:44.000 --> 00:12:54.000
콜백에서 비동기 비디오 컴포지션 요청 객체를 받으면, 비디오 컴포지션의 메타데이터를 얻기 위해 사용하는 두 가지 새로운 API가 있습니다.

00:12:54.000 --> 00:13:02.000
첫 번째는 해당 요청과 관련된 메타데이터 트랙의 트랙 ID를 재생하는 소스 SampleDataTrackIDs 속성입니다.

00:13:02.000 --> 00:13:12.000
그런 다음 각 트랙 ID에 대해 sourceTimedMetadata(byTrackID :) 메서드를 사용하여 해당 트랙의 현재 시간 메타데이터 그룹을 얻을 수 있습니다.

00:13:12.000 --> 00:13:22.000
이제 AVTimedMetadataGroup은 문자열, 날짜 또는 기타 고급 객체로 구문 분석된 메타데이터의 높은 수준의 표현입니다.

00:13:22.000 --> 00:13:32.000
메타데이터의 원시 바이트로 작업하고 싶다면, sourceSampleBuffer(byTrackID: ) 메소드를 사용하여 AVTimedMetadataGroup 대신 CMSampleBuffer를 얻을 수 있습니다.

00:13:32.000 --> 00:13:42.000
메타데이터를 준비하면, 소스 비디오 프레임과 함께 메타데이터를 사용하여 출력 비디오 프레임을 생성하고 요청을 완료할 수 있습니다.

00:13:42.000 --> 00:13:52.000
그래서 그것이 사용자 지정 비디오 컴포지터 콜백에 메타데이터를 얻는 데 필요한 전부이므로 비디오 컴포지션으로 더 흥미로운 일을 할 수 있습니다.

00:13:52.000 --> 00:13:57.000
이제 우리의 마지막 주제는 캡션 파일 작성입니다.

00:13:57.000 --> 00:14:02.000
올해 macOS의 새로운 AVFoundation은 두 가지 파일 형식에 대한 지원을 추가하고 있다.

00:14:02.000 --> 00:14:07.000
먼저, 자막이 포함된 iTunes Timed Text 또는 .itt 파일이 있습니다.

00:14:07.000 --> 00:14:14.000
다른 파일 형식은 자막이 포함된 Scenarist 자막 또는 .scc 파일입니다.

00:14:14.000 --> 00:14:26.000
AVFoundation은 이 두 가지 파일 형식을 작성하고, 이러한 유형의 파일에서 캡션을 수집하고, 재생 중에 어떻게 보일지 확인하기 위해 런타임에 캡션을 미리 볼 수 있는 지원을 추가하고 있습니다.

00:14:26.000 --> 00:14:33.000
저작 측면에서, 우리는 단일 캡션을 나타내는 모델 객체인 AVCaption으로 시작하는 몇 가지 새로운 API를 가지고 있습니다.

00:14:33.000 --> 00:14:40.000
그것은 텍스트, 위치, 스타일링 및 단일 캡션의 다른 속성과 같은 속성을 가지고 있다.

00:14:40.000 --> 00:14:49.000
AVCaptions를 직접 만들고 AVAssetWriterInputCaptionAdaptor를 사용하여 이 두 파일 형식 중 하나로 쓸 수 있습니다.

00:14:49.000 --> 00:15:00.000
또한, AVCaptionConversion Validator 클래스에 새로운 유효성 검사 서비스가 있습니다. 이는 작성 중인 캡션이 선택한 파일 형식과 실제로 호환되는지 확인하는 데 도움이 됩니다.

00:15:00.000 --> 00:15:04.000
이것이 왜 중요한지에 대한 예로, .scc 파일을 고려해 보세요.

00:15:04.000 --> 00:15:19.000
여기에는 주어진 시간 동안 얼마나 많은 캡션을 가질 수 있는지에 대한 매우 구체적인 제한이 있는 형식인 CEA-608 캡션이 포함되어 있으며, 개별 문자와 스타일을 나타내는 데이터에 대한 고정 비트 예산까지 다양합니다.

00:15:19.000 --> 00:15:33.000
따라서 유효성 검사기는 캡션 스트림이 파일 형식과 호환되는지 확인하는 데 도움이 될 뿐만 아니라, 호환되도록 타임 스탬프를 조정하는 것과 같은 캡션에 대한 조정을 제안할 것입니다.

00:15:33.000 --> 00:15:43.000
캡션을 수집하기 위한 새로운 API는 AVAssetReader OutputCaptionAdaptor로, 이러한 파일 중 하나를 가져다가 AVCaption 객체에서 읽을 수 있습니다.

00:15:43.000 --> 00:15:56.000
마지막으로, AVCaptionRenderer 클래스가 있습니다. 단일 캡션 또는 캡션 그룹을 가져와 CGContext로 렌더링하여 재생 중에 어떻게 보일지 미리 볼 수 있습니다.

00:15:56.000 --> 00:16:00.000
그래서 그것은 우리의 새로운 캡션 파일 저작 API의 빙산의 일각에 불과합니다.

00:16:00.000 --> 00:16:10.000
만약 당신이 그것들을 채택하는 데 관심이 있다면, 우리는 당신이 포럼이나 컨퍼런스 랩에서 우리와 연락하는 것을 권장합니다. 그리고 우리는 당신이 가진 모든 질문에 답하는 데 도움을 줄 수 있습니다.

00:16:10.000 --> 00:16:14.000
그리고 그것이 우리의 마지막 주제였으니, 마무리하자.

00:16:14.000 --> 00:16:26.000
오늘의 가장 큰 주제는 AVAsset 속성 검사, 주문형 및 비동기적으로 그렇게 하는 것의 중요성, 이 분야의 새로운 API, 그리고 이전 API에서 마이그레이션하기 위한 몇 가지 팁이었습니다.

00:16:26.000 --> 00:16:32.000
그런 다음 우리는 시간제 메타데이터를 사용하여 사용자 지정 비디오 구성을 추가로 사용자 정의하는 것에 대해 이야기했습니다.

00:16:32.000 --> 00:16:38.000
마지막으로, 나는 캡션 파일 작성과 그 분야의 새로운 API에 대해 간략하게 소개했다.

00:16:38.000 --> 00:16:40.000
오늘은 그게 다야.

00:16:40.000 --> 00:16:44.000
WWDC21을 보고 즐겨주셔서 정말 감사합니다.

00:16:44.000 --> 23:59:59.000
♪

