WEBVTT

00:00:00.000 --> 00:00:05.000
♪ 베이스 음악 연주 ♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:11.000
마티 파이: "AVKit의 새로운 기능"에 오신 것을 환영합니다.

00:00:11.000 --> 00:00:14.000
제 이름은 마티 파이이고 AVKit 팀의 엔지니어입니다.

00:00:14.000 --> 00:00:23.000
오늘, 저는 우리가 Picture in Picture 또는 짧은 PiP와 macOS의 전체 화면 경험에 대한 몇 가지 개선 사항에 대해 이야기하고 싶습니다.

00:00:23.000 --> 00:00:27.000
Picture in Picture부터 시작합시다.

00:00:27.000 --> 00:00:33.000
Picture in Picture를 사용하면 사용자는 장치로 멀티태스킹하는 동안 비디오 콘텐츠를 계속 즐길 수 있습니다.

00:00:33.000 --> 00:00:41.000
예를 들어, 비디오를 전체 화면으로 보고 메시지를 받는 경우, 콘텐츠를 계속 보면서 해당 메시지에 간단히 답장할 수 있습니다.

00:00:41.000 --> 00:00:48.000
비디오는 자동으로 PiP에 들어가며, 답장을 마치면 전체 화면 재생을 빠르게 재개할 수 있습니다.

00:00:48.000 --> 00:00:55.000
이것은 정말 원활한 시청 경험을 제공하며, 우리는 사용자가 비디오를 볼 때마다 이러한 행동을 기대할 것이라고 생각합니다.

00:00:55.000 --> 00:01:05.000
PiP를 자신의 앱에 통합하는 방법에 대한 자세한 내용은 AVKit으로 직관적인 미디어 재생을 제공하는 2019년 세션을 시청하는 것이 좋습니다.

00:01:05.000 --> 00:01:14.000
올해 새로운, 비디오가 인라인으로 재생되는 경우, 사용자가 홈 화면으로 다시 스와이프할 때 선택적으로 PiP에 자동으로 입력하도록 허용할 수 있습니다.

00:01:14.000 --> 00:01:21.000
이 동작을 활성화하는 것은 canStartPictureInPicture AutomaticallyFromInline 속성을 통해 이루어집니다.

00:01:21.000 --> 00:01:31.000
이 속성은 기본 컨트롤을 사용하는 앱의 경우 AVPlayerViewController와 자체 사용자 지정 UI를 구현하는 앱의 경우 AVPictureInPictureController에서 사용할 수 있습니다.

00:01:31.000 --> 00:01:39.000
재생 콘텐츠가 사용자의 주요 초점이 될 때만 이 플래그를 true로 설정해야 합니다.

00:01:39.000 --> 00:01:44.000
AVPlayerViewController를 사용하여 비디오 콘텐츠를 제공하는 경우, PiP가 처리됩니다.

00:01:44.000 --> 00:01:46.000
네가 해야 할 일은 아무것도 없어.

00:01:46.000 --> 00:01:54.000
AVPlayerViewController를 사용하지 않는 경우, AVPictureInPictureController를 사용하여 앱에 기본 PiP 경험을 가져올 수 있습니다.

00:01:54.000 --> 00:02:01.000
먼저, 재생을 위해 앱의 오디오 세션 카테고리를 구성하고 PiP 백그라운드 모드를 활성화해야 합니다.

00:02:01.000 --> 00:02:08.000
그런 다음, playerLayer에 대한 참조를 전달하여 pictureInPictureController를 만들기만 하면 됩니다.

00:02:08.000 --> 00:02:17.000
그런 다음, 사용자가 제공한 버튼을 사용하여 Picture in Picture를 전환하려고 할 때, 컨트롤러 개체에서 PiP를 시작하거나 중지하기만 하면 됩니다.

00:02:17.000 --> 00:02:22.000
지금까지, 우리의 Picture in Picture 경험은 AVPlayer 기반 콘텐츠를 중심으로 구축되었다.

00:02:22.000 --> 00:02:28.000
오늘, 저는 AVSampleBufferDisplayLayer에 대한 동일한 수준의 지원을 발표하게 되어 기쁩니다.

00:02:28.000 --> 00:02:40.000
플레이어 레이어로 Picture in Picture 컨트롤러를 만드는 대신, 먼저 AVPlayerLayer 또는 AVSampleBufferDisplayLayer로 설정한 ContentSource를 만듭니다.

00:02:40.000 --> 00:02:43.000
사용자의 경우, Picture in Picture 경험은 동일할 것이다.

00:02:43.000 --> 00:02:51.000
개발자로서, AVSampleBufferDisplayLayer에 대한 PiP 지원과 관련된 몇 가지 새로운 책임이 있습니다.

00:02:51.000 --> 00:02:53.000
이 재생 대리인을 살펴봅시다.

00:02:53.000 --> 00:03:06.000
미디어 재생은 AVPlayer에 의해 관리되지 않기 때문에 PiP UI를 렌더링하기 위해 새로운 AVPictureInPictureSample BufferPlaybackDelegate를 통해 제공된 재생 상태 정보에 의존해야 합니다.

00:03:06.000 --> 00:03:12.000
사용자가 PiP UI에서 미디어를 제어하려고 할 때, 우리는 그 명령을 처리할 대리인에게 전달합니다.

00:03:12.000 --> 00:03:16.000
다섯 개의 개별 콜백을 하나씩 살펴봅시다.

00:03:16.000 --> 00:03:21.000
setPlaying 기능은 사용자가 PiP 창에서 재생/일시 정지 버튼을 누를 때 호출됩니다.

00:03:21.000 --> 00:03:25.000
skipByInterval 기능은 사용자가 건너뛰기 버튼 중 하나를 누를 때 호출됩니다.

00:03:25.000 --> 00:03:29.000
이 콜백을 사용하여 그에 따라 미디어를 제어하세요.

00:03:29.000 --> 00:03:34.000
timeRangeForPlayback 기능을 사용하면 현재 재생할 수 있는 시간 범위를 지정할 수 있습니다.

00:03:34.000 --> 00:03:39.000
이것은 우리가 타임라인을 렌더링하고 재생헤드가 현재 어디에 있는지 보여줄 수 있게 해준다.

00:03:39.000 --> 00:03:45.000
한정된 기간의 시간 범위는 항상 샘플 버퍼 디스플레이 레이어의 시간대의 현재 시간을 포함해야 합니다.

00:03:45.000 --> 00:03:50.000
라이브 콘텐츠를 나타내기 위해 무한한 기간의 시간 범위를 사용하세요.

00:03:50.000 --> 00:03:57.000
didTransitionToRenderSize 함수는 그림 속의 그림 창이 핀치 투 줌과 같이 크기를 변경할 때 호출됩니다.

00:03:57.000 --> 00:04:04.000
불필요한 디코딩 오버헤드를 피하기 위해 미디어 변형을 선택할 때 이 렌더링 크기를 고려하십시오.

00:04:04.000 --> 00:04:12.000
isPlaybackPaused 기능은 주기적으로 호출되며 일시 중지 또는 재생 상태를 반영할지 여부를 Picture in Picture UI에 알려줍니다.

00:04:12.000 --> 00:04:17.000
이것은 개념적으로 AVPlayer의 timeControlStatus와 동등하다.

00:04:17.000 --> 00:04:23.000
다음으로, macOS의 전체 화면 경험에 대한 몇 가지 개선 사항을 살펴봅시다.

00:04:23.000 --> 00:04:31.000
Big Sur에서, Mac Catalyst 앱에서 전체 화면으로 비디오를 찍을 때, 비디오는 전체 창을 채우지만 전체 화면은 채우지 않습니다.

00:04:31.000 --> 00:04:36.000
이제 macOS Monterey에서, 비디오는 전체 화면을 차지할 것이다.

00:04:36.000 --> 00:04:42.000
당신은 네이티브 macOS와 Mac Catalyst 앱 모두에서 진정한 전체 화면 경험을 하게 됩니다.

00:04:42.000 --> 00:04:44.000
재생 컨트롤은 둘 다 똑같아 보인다.

00:04:44.000 --> 00:04:48.000
모든 Mac Catalyst 앱은 이 새로운 동작을 자동으로 얻을 것이다.

00:04:48.000 --> 00:04:54.000
모든 기본 macOS 전체 화면 경험과 마찬가지로, 사용자는 앱 창으로 다시 스와이프할 수 있습니다.

00:04:54.000 --> 00:05:00.000
원본 비디오 대신 자리 표시자가 표시되며, 이는 콘텐츠가 전체 화면으로 재생되고 있음을 나타냅니다.

00:05:00.000 --> 00:05:06.000
이것은 비디오가 Picture in Picture에서 재생될 때 표시되는 자리 표시자와 매우 유사합니다.

00:05:06.000 --> 00:05:15.000
사용자가 일부 콘텐츠를 선택한 후 플레이어 뷰 컨트롤러를 전체 화면으로 표시하는 시나리오에서, 뷰 컨트롤러는 여전히 전체 창에 표시됩니다.

00:05:15.000 --> 00:05:25.000
그러나 macOS Monterey의 새로운 기능인 사용자는 창 왼쪽 상단의 녹색 전체 화면 버튼을 눌러 진정한 전체 화면 재생 경험으로 분리할 수 있습니다.

00:05:25.000 --> 00:05:32.000
전체 화면 수명 주기는 애플리케이션의 요구에 따라 더 나은 사용자 경험을 제공하기 위해 명시적으로 관리할 수 있습니다.

00:05:32.000 --> 00:05:35.000
예를 들어 봅시다.

00:05:35.000 --> 00:05:43.000
우리가 이미 보여준 것처럼, 사용자는 비디오를 전체 화면으로 찍은 다음 재생이 계속되는 동안 앱으로 다시 스와이프할 수 있어야 합니다.

00:05:43.000 --> 00:05:50.000
플레이어 뷰 컨트롤러가 뷰 계층 구조에서 제거되더라도 앱을 자유롭게 탐색할 수 있어야 합니다.

00:05:50.000 --> 00:05:57.000
언제든지, 그들은 스와이프하거나 미션 컨트롤을 사용하여 전체 화면 비디오로 돌아갈 수 있어야 합니다.

00:05:57.000 --> 00:05:59.000
그래서 그 일을 어떻게 만드는지 살펴봅시다.

00:05:59.000 --> 00:06:03.000
당신은 playerViewController의 수명 주기에 대한 책임이 있습니다.

00:06:03.000 --> 00:06:12.000
최적의 경험을 얻으려면, 앱의 보기 계층 구조에 없더라도 playerViewController를 유지해야 합니다.

00:06:12.000 --> 00:06:20.000
그렇지 않으면, 사용자가 비디오가 있는 페이지에서 벗어나면, playerViewController가 출시되면 전체 화면 재생이 종료됩니다.

00:06:20.000 --> 00:06:27.000
willBeginFullScreenPresentation 콜백을 받을 때 playerViewController에 대한 강력한 참조를 유지하기만 하면 됩니다.

00:06:27.000 --> 00:06:34.000
그런 다음, 사용자가 전체 화면을 종료하면, willEndFullScreenPresentation 콜백을 받게 됩니다.

00:06:34.000 --> 00:06:43.000
이것은 사용자가 제시된 원래 보기에서 멀어졌다고 가정하면, 당신이 살아있게 유지하고 있던 playerViewController를 놓을 수 있는 기회입니다.

00:06:43.000 --> 00:06:46.000
네이티브 macOS에도 동일하게 적용됩니다.

00:06:46.000 --> 00:06:54.000
새로운 playerViewDelegate를 사용하여 playerViewWillExitFullScreen 콜백을 받을 때까지 playerView를 유지할 수 있습니다.

00:06:54.000 --> 00:07:00.000
사용자가 전체 화면을 종료하면, 이 restoreUserInterface 콜백도 받게 됩니다.

00:07:00.000 --> 00:07:08.000
이것은 당신의 앱이 당신의 사용 사례에 적합하다고 가정하고, 비디오가 포함된 원본 페이지로 돌아갈 수 있는 기회입니다.

00:07:08.000 --> 00:07:14.000
이것은 사용자가 Picture in Picture를 중지할 때 받는 기존 콜백과 매우 유사합니다.

00:07:14.000 --> 00:07:21.000
전체 화면에서 인라인으로의 전환을 차단하지 않도록 이 완료 핸들러에서 가능한 한 빨리 돌아오세요.

00:07:21.000 --> 00:07:29.000
거짓을 반환하는 것은 복원이 실패했거나 불가능하다는 것을 나타내며, 이 경우 콘텐츠는 애니메이션 없이 전체 화면으로 종료됩니다.

00:07:29.000 --> 00:07:32.000
그것으로, 나는 오늘 세션을 마무리하고 싶다.

00:07:32.000 --> 00:07:41.000
AVPlayerLayer 대신 AVSampleBufferDisplayLayer를 사용할 때 새로운 콘텐츠 소스 API를 사용하여 앱에 Picture in Picture 지원을 추가하는 방법을 보았습니다.

00:07:41.000 --> 00:07:50.000
macOS와 Mac Catalyst의 경우, 우리는 향상된 전체 화면 경험을 검토하고 코드가 원활하게 통합되는 데 필요한 단계를 설명했습니다.

00:07:50.000 --> 00:07:56.000
오늘 세션을 즐겼기를 바라며 이러한 기능 중 일부가 앱에 통합되기를 기대합니다.

00:07:56.000 --> 00:07:58.000
남은 컨퍼런스를 즐기세요.

00:07:58.000 --> 23:59:59.000
♪

