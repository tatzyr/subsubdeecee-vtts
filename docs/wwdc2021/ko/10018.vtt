WEBVTT

00:00:00.000 --> 00:00:05.000
♪ 베이스 음악 연주 ♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:15.000
Matt Ricketson: "SwiftUI의 새로운 기능"에 오신 것을 환영합니다. 나는 맷이고, 나중에 테일러와 합류할 거야.

00:00:15.000 --> 00:00:20.000
이 세션은 모두 애플의 선언적 UI 프레임워크인 SwiftUI에 관한 것이다.

00:00:20.000 --> 00:00:25.000
SwiftUI는 아직 어리지만, 우리는 이미 왔다.

00:00:25.000 --> 00:00:36.000
SwiftUI는 2019년에 처음 출시되었으며, 선언적이고 국가 중심적인 스타일로 사용자 인터페이스를 구축하는 강력한 새로운 방법을 도입했다.

00:00:36.000 --> 00:00:46.000
우리는 SwiftUI의 두 번째 릴리스로 다음 큰 발걸음을 내디뎠고, 새로운 앱과 장면 API로 100% SwiftUI 앱을 가능하게 했습니다.

00:00:46.000 --> 00:00:55.000
올해 우리는 풍부한 새로운 기능으로 앱에서 SwiftUI의 더 깊은 채택을 지원하는 데 초점을 맞추고 있습니다.

00:00:55.000 --> 00:01:00.000
이제 아직 SwiftUI를 직접 사용해 볼 기회가 없었다면, 괜찮습니다!

00:01:00.000 --> 00:01:04.000
오직 당신만이 당신의 앱에 가장 적합한 것이 무엇인지 알고 있습니다.

00:01:04.000 --> 00:01:10.000
하지만 올해 사용 가능한 모든 새로운 기능에 대해 배울 때 명심해야 할 몇 가지 팁이 있습니다.

00:01:10.000 --> 00:01:23.000
SwiftUI에 발가락을 담그는 좋은 방법은 iOS, iPadOS 및 macOS용 Notes의 새로운 활동 스트림을 지원하는 방법과 같이 기존 앱에서 새로운 기능을 만드는 것입니다.

00:01:23.000 --> 00:01:28.000
또는 SwiftUI로 구축된 macOS의 새로운 아바타 선택기.

00:01:28.000 --> 00:01:36.000
기존 UIKit 또는 AppKit 코드와 함께 SwiftUI를 혼합할 수 있다는 것을 기억하세요.

00:01:36.000 --> 00:01:44.000
SwiftUI는 또한 SwiftUI가 macOS에서 새로운 단축키 앱을 구축하는 데 사용된 방법과 같이 앱을 새로운 플랫폼으로 확장하는 데 유용한 도구입니다.

00:01:44.000 --> 00:01:54.000
SwiftUI를 사용하면 각 장치에 대한 고유한 경험을 만드는 동시에 플랫폼 간에 공통 코드를 쉽게 공유할 수 있습니다.

00:01:54.000 --> 00:01:59.000
그리고 앱을 재설계할 준비가 되면, SwiftUI를 도입하여 도움을 받을 수 있는 완벽한 시기입니다.

00:01:59.000 --> 00:02:12.000
완전히 새로운 Apple Pay 구매 흐름은 SwiftUI를 사용하여 재설계되었으며, 이는 macOS의 새로운 도움말 뷰어와 watchOS의 팁 앱에 신선한 페인트를 가져오는 데에도 사용되었습니다.

00:02:12.000 --> 00:02:21.000
그리고 마지막으로, 우리는 SwiftUI에서 처음부터 재건된 iOS용 멋진 새로운 날씨 앱을 잊을 수 없습니다.

00:02:21.000 --> 00:02:28.000
이것들은 SwiftUI가 차세대 앱을 구축하는 데 어떻게 도움이 되는지에 대한 몇 가지 예일 뿐입니다.

00:02:28.000 --> 00:02:34.000
이 세션을 위해, 우리는 이 모든 것을 가능하게 한 훌륭한 새로운 API 중 일부를 공유하고 싶습니다.

00:02:34.000 --> 00:02:40.000
우리는 목록과 그리드로 콘텐츠 컬렉션을 구축하는 방법에 대한 개선 사항을 살펴보는 것으로 시작할 것입니다.

00:02:40.000 --> 00:02:48.000
다음으로, 우리는 목록을 넘어 데이터 기반 앱을 한 단계 끌어올리기 위한 새로운 기능을 도입할 것입니다.

00:02:48.000 --> 00:02:54.000
셋째, 우리는 그래픽과 시각 효과를 구동하기 위한 몇 가지 놀라운 새로운 도구를 선보일 것입니다.

00:02:54.000 --> 00:02:59.000
우리는 텍스트, 키보드 및 초점 기반 내비게이션의 향상에 대해 이야기할 것입니다.

00:02:59.000 --> 00:03:03.000
그리고 마지막으로, 우리는 버튼에 약간의 사랑을 줄 것이다.

00:03:03.000 --> 00:03:13.000
따라서 SwiftUI 앱 내에서 데이터를 구성하고 표시하는 데 중요한 기능인 목록과 그리드부터 시작해 봅시다.

00:03:13.000 --> 00:03:20.000
올해, 우리는 풍부한 대화형 목록과 그리드를 더 쉽게 작성할 수 있도록 하고 있습니다.

00:03:20.000 --> 00:03:22.000
재밌는 것부터 시작하자.

00:03:22.000 --> 00:03:28.000
SwiftUI는 이제 이미지를 비동기적으로 로드하기 위한 지원이 내장되어 있습니다.

00:03:28.000 --> 00:03:34.000
SwiftUI는 새로운 AsyncImage 보기로 이러한 이미지를 쉽게 로드할 수 있게 해준다.

00:03:34.000 --> 00:03:43.000
URL을 제공하면 SwiftUI는 자동으로 원격 이미지를 가져오고 표시하며, 심지어 기본 자리 표시자를 제공합니다.

00:03:43.000 --> 00:03:45.000
AsyncImage도 사용자 정의할 수 있습니다.

00:03:45.000 --> 00:03:55.000
예를 들어, 우리는 로드된 이미지에 수정자를 추가하고 재미있는 색상을 추가하기 위해 여기에서 하는 것처럼 사용자 지정 자리 표시자를 정의할 수 있습니다.

00:03:55.000 --> 00:03:58.000
우리는 심지어 사용자 지정 애니메이션과 오류 처리를 추가할 수도 있습니다!

00:03:58.000 --> 00:04:02.000
그리고 AsyncImage는 모든 플랫폼에서 사용할 수 있습니다.

00:04:02.000 --> 00:04:05.000
우리는 네가 그걸 확인하길 바라.

00:04:05.000 --> 00:04:14.000
AsyncImage는 콘텐츠를 즉시 로드하지만, 때때로 앱은 피드를 보여줄 때와 같이 요청에 따라 콘텐츠를 로드해야 합니다.

00:04:14.000 --> 00:04:23.000
이것은 새로운 새로 고침 수정자를 사용하여 iOS와 iPadOS에서 풀 투 리프레시를 지원하기 위한 훌륭한 사용 사례입니다.

00:04:23.000 --> 00:04:29.000
이 수정자는 새로 고침 작업을 구성하고 환경을 통과합니다.

00:04:29.000 --> 00:04:40.000
iOS 및 iPadOS의 목록은 이 작업을 사용하여 풀 투 리프레시를 자동으로 추가하지만, 사용자 지정 새로 고침 동작을 만드는 데 사용할 수도 있습니다.

00:04:40.000 --> 00:04:47.000
Swift 5.5의 새로운 동시성 언어 기능 중 하나인 이 새로운 await 키워드를 눈치챘을 것입니다.

00:04:47.000 --> 00:04:56.000
이것은 updateItems 메소드가 UI를 차단하지 않고 목록을 새로 고칠 수 있는 비동기 작업임을 나타냅니다.

00:04:56.000 --> 00:05:02.000
또 다른 새로운 동시성 관련 SwiftUI 기능은 작업 수정자이다.

00:05:02.000 --> 00:05:07.000
이 API를 사용하면 뷰의 수명에 비동기 작업을 첨부할 수 있습니다.

00:05:07.000 --> 00:05:14.000
즉, 보기가 처음 로드되면 작업이 시작되고 보기가 제거되면 자동으로 취소됩니다.

00:05:14.000 --> 00:05:19.000
이것은 우리가 첫 번째 사진 배치를 자동으로 로드할 수 있는 좋은 방법입니다.

00:05:19.000 --> 00:05:28.000
이 새로운 동시성 수정자는 표면적으로 단순해 보이지만, 앱에 정교한 비동기 동작을 구축하는 데 사용할 수 있습니다.

00:05:28.000 --> 00:05:35.000
예를 들어, 여기서 최신 사진을 사용할 수 있게 되면 로드하는 작업을 설정했습니다.

00:05:35.000 --> 00:05:41.000
나는 그냥 일반 루프를 썼지만, 여기서도 사용되는 대기 키워드를 알 수 있을 것이다.

00:05:41.000 --> 00:05:49.000
그것은 newestCandidates가 실제로 Swift 5.5의 또 다른 새로운 동시성 기능인 비동기 시퀀스이기 때문이다.

00:05:49.000 --> 00:05:57.000
이것은 우리가 최신 후보자를 비동기적으로 기다릴 것이며, 다음 후보자가 가능할 때만 루프를 반복한다는 것을 의미합니다.

00:05:57.000 --> 00:06:02.000
그것은 우리가 실제로 이 단일 수정자에 많은 기능을 포장하고 있다는 것을 의미한다.

00:06:02.000 --> 00:06:18.000
보기는 나타나자마자 비동기적으로 후보자를 청취하는 작업을 시작하고, 새로운 후보자를 사용할 수 있게 될 때마다 목록을 업데이트한 다음, 앱의 UI를 차단하지 않고 보기가 사라지면 자동으로 작업을 취소합니다.

00:06:18.000 --> 00:06:26.000
Swift 동시성과 SwiftUI에서 그것을 활용하는 방법에 대해 배울 것이 더 많기 때문에, 우리는 세부 사항을 파헤치기 위해 몇 가지 다른 대화를 준비했습니다.

00:06:26.000 --> 00:06:35.000
"SwiftUI에서 동시성 발견"은 동시성이 SwiftUI의 업데이트 모델과 어떻게 관련되는지 설명하고 우리가 방금 논의한 몇 가지 새로운 기능을 시연할 것입니다.

00:06:35.000 --> 00:06:45.000
그리고 "Swift concurrency: Update a sample app"에서 비동기 모델 코드로 기존 프로젝트를 업그레이드하는 과정을 단계별로 안내합니다.

00:06:45.000 --> 00:06:51.000
다음으로, 우리는 당신의 목록 콘텐츠에 상호 작용을 구축할 수 있는 새롭고 더 나은 방법을 제공하고 있습니다.

00:06:51.000 --> 00:06:58.000
이 예에서, 나는 내 슈퍼 비밀 은신처로 가는 길을 공유하기 위한 간단한 목록을 작성했다.

00:06:58.000 --> 00:07:00.000
이것은 좋아 보이지만, 텍스트는 편집할 수 없다.

00:07:00.000 --> 00:07:02.000
그걸 고치자.

00:07:02.000 --> 00:07:07.000
대신 텍스트 필드로 바꿔서 텍스트를 편집할 수 있습니다.

00:07:07.000 --> 00:07:10.000
그러나, 텍스트 필드는 텍스트에 바인딩이 필요하다.

00:07:10.000 --> 00:07:18.000
우리 목록의 콘텐츠 폐쇄 내에서, 우리는 바인딩이 아닌 컬렉션의 각 요소에 대한 일반 값만 제공됩니다.

00:07:18.000 --> 00:07:26.000
이와 같은 상황에서, 각 행의 컬렉션 요소에 바인딩하는 방법을 알아내는 것은 까다로울 수 있다.

00:07:26.000 --> 00:07:35.000
한 가지 일반적인 접근 방식은 대신 컬렉션의 인덱스를 반복하고, 첨자를 사용하여 해당 인덱스의 요소에 대한 바인딩을 얻는 것입니다.

00:07:35.000 --> 00:07:45.000
그러나, SwiftUI는 변경 사항이 있을 때 전체 목록을 다시 로드해야 하기 때문에 이 기술은 권장되지 않습니다.

00:07:45.000 --> 00:07:50.000
사실, 우리는 이 주제에 대해 훨씬 더 자세히 논의하는 전체 강연을 준비했습니다.

00:07:50.000 --> 00:07:59.000
더 알아보려면, "Demystify SwiftUI"를 보는 것을 추천합니다. 지금은, 이러한 변경 사항을 취소하고 더 나은 해결책을 살펴봅시다.

00:07:59.000 --> 00:08:08.000
올해 SwiftUI는 컬렉션 내의 개별 요소에 대한 바인딩에 접근할 수 있는 훨씬 쉬운 방법을 제공하고 있다.

00:08:08.000 --> 00:08:19.000
일반 달러 기호 연산자를 사용하여 컬렉션에 바인딩을 목록에 전달하기만 하면 SwiftUI는 클로저 내의 각 개별 요소에 바인딩을 다시 전달합니다.

00:08:19.000 --> 00:08:26.000
값만 읽으면 되는 코드는 당신이 익숙한 것처럼 이전과 정확히 동일하게 유지될 수 있습니다.

00:08:26.000 --> 00:08:40.000
하지만 이제 우리는 익숙한 일반 바인딩 구문을 사용하여 텍스트 필드와 같은 대화형 컨트롤을 쉽게 추가할 수 있습니다. 즉, 이전에 포함하는 것을 잊어버린 슈퍼 시크릿 도어 코드를 마침내 채울 수 있습니다.

00:08:40.000 --> 00:08:46.000
이 새로운 구문은 스위프트 언어의 일부이므로, 목록뿐만 아니라 어디에서나 작동합니다.

00:08:46.000 --> 00:08:51.000
예를 들어, 우리는 대신 목록 내의 ForEach 보기에서 동일한 기술을 사용할 수 있습니다.

00:08:51.000 --> 00:08:58.000
그리고 더 나아가, 이 코드를 SwiftUI가 지원하는 이전 릴리스에 다시 배포할 수도 있습니다.

00:08:58.000 --> 00:09:01.000
하지만 우리는 당신의 기존 코드를 더 쉽게 작성할 수 있도록 하는 것이 아닙니다.

00:09:01.000 --> 00:09:04.000
목록도 훌륭한 새로운 기능을 얻고 있다!

00:09:04.000 --> 00:09:08.000
목록을 시각적으로 사용자 정의할 수 있는 몇 가지 새로운 방법부터 시작합시다.

00:09:08.000 --> 00:09:19.000
새로운 listRowSeparatorTint 수정자를 사용하면 각 행의 구분 기호와 아이콘 색상을 정렬하기 위해 여기에서 한 것처럼 개별 행 구분 기호의 색상을 변경할 수 있습니다.

00:09:19.000 --> 00:09:23.000
SwiftUI는 또한 섹션 구분 기호에 대한 동등한 수정자를 가지고 있다.

00:09:23.000 --> 00:09:27.000
하지만 이 앱의 경우, 그 모든 구분 기호는 약간 산만해 보인다.

00:09:27.000 --> 00:09:31.000
나는 내 방향이 하나의 통일된 흐름처럼 느껴지기를 원한다.

00:09:31.000 --> 00:09:39.000
아마도 우리는 그것들을 제거해야 할 것 같은데, 이제 새로운 listRowSeparator 수정자로 할 수 있고, 분리기를 숨기도록 구성할 수 있습니다.

00:09:39.000 --> 00:09:42.000
이제 우리의 방향은 훨씬 덜 어수선하게 느껴진다.

00:09:42.000 --> 00:09:47.000
내가 만들고 있는 다른 앱을 보자...

00:09:47.000 --> 00:09:52.000
... 만화책 작가들이 모든 슈퍼히어로와 악당을 추적하는 데 도움을 준다.

00:09:52.000 --> 00:10:02.000
이 앱은 스와이프 동작을 사용하여 빠르고 편리하게 문자를 고정하고 삭제하지만, 추가 컨트롤로 UI를 어지럽히지 않습니다.

00:10:02.000 --> 00:10:09.000
올해 새로운 SwiftUI를 사용하면 새로운 swipeActions 수정자를 사용하여 완전히 사용자 지정 스와이프 작업을 정의할 수 있습니다.

00:10:09.000 --> 00:10:15.000
SwiftUI의 다른 종류의 메뉴와 마찬가지로 스와이프 동작을 구성하여 버튼을 사용하여 작업을 정의합니다.

00:10:15.000 --> 00:10:22.000
핀 동작을 노란색으로 만드는 데 사용하는 새로운 색조 수정자를 추가하여 색상을 사용자 정의할 수도 있습니다.

00:10:22.000 --> 00:10:27.000
기본적으로, SwiftUI는 행의 후행 가장자리에 스와이프 동작을 보여줍니다.

00:10:27.000 --> 00:10:32.000
하지만 수정자의 가장자리 매개 변수를 사용하여 앞쪽으로 전환할 수 있습니다.

00:10:32.000 --> 00:10:40.000
다른 에지 구성으로 여러 수정자를 추가하여 선행 및 후행 스와이프 동작을 모두 지원할 수도 있습니다.

00:10:40.000 --> 00:10:49.000
마지막으로, swipeActions 수정자는 이를 지원하는 모든 플랫폼에서 사용할 수 있으므로 멀티플랫폼 앱 내에서 코드를 쉽게 공유할 수 있습니다.

00:10:49.000 --> 00:10:53.000
다른 플랫폼에 대해 말하자면, 내 앱의 macOS 버전을 확인해 봅시다.

00:10:53.000 --> 00:10:59.000
Mac에서 사용할 수 있는 추가 공간을 활용하는 다중 열 인터페이스를 보여줍니다.

00:10:59.000 --> 00:11:05.000
내 모든 데이터를 사이드바에 쑤셔 넣는 대신, 내 모든 캐릭터를 나열하는 개요 탭이 있다.

00:11:05.000 --> 00:11:09.000
그것은 내가 사이드바에 고정된 캐릭터를 유지할 수 있게 해준다.

00:11:09.000 --> 00:11:11.000
하지만 이 목록은 조금 평범하게 느껴진다.

00:11:11.000 --> 00:11:13.000
조금 더 꾸미도록 해보자.

00:11:13.000 --> 00:11:15.000
여기 내 기존 코드가 있어.

00:11:15.000 --> 00:11:20.000
저는 현재 창에 목록을 원활하게 맞추기 위해 삽입 목록 스타일을 사용하고 있습니다.

00:11:20.000 --> 00:11:29.000
그리고 우리는 올해 모든 보기 스타일에서 사용할 수 있는 새로운 열거형 구문을 사용하여 코드에서 이 스타일을 아름답게 표현할 수 있습니다.

00:11:29.000 --> 00:11:33.000
또한 올해 새로운, 삽입 목록 스타일은 새로운 트릭을 얻고 있다.

00:11:33.000 --> 00:11:41.000
이제 alternatesRowBackgrounds 플래그로 스타일을 수정하기만 하면 행의 배경을 바꿀 수 있습니다.

00:11:41.000 --> 00:11:46.000
우리의 목록은 지금 훨씬 더 좋아 보이고 있으며, 각 행은 다른 행과 분명히 구별된다.

00:11:46.000 --> 00:11:53.000
하지만 macOS 앱의 경우, 여전히 우리가 창의 모든 공간을 최대한 활용하지 못하는 것처럼 느껴진다.

00:11:53.000 --> 00:11:58.000
그래서 다음 섹션에서는, 목록을 넘어 앱에서 더 많은 것을 얻을 수 있도록 합시다.

00:11:58.000 --> 00:12:05.000
이 모든 공간을 더 잘 활용할 수 있도록, 목록을 풍부한 다중 열 테이블로 업그레이드합시다!

00:12:05.000 --> 00:12:09.000
네 개의 열로, 나는 이제 하나의 가격으로 네 개의 목록을 얻는다!

00:12:09.000 --> 00:12:18.000
하지만 가장 좋은 점은 이와 같은 적당히 복잡한 테이블이 단일 슬라이드에 맞는 코드가 거의 없어 선언될 수 있다는 것이다.

00:12:18.000 --> 00:12:23.000
그것은 테이블이 SwiftUI 전반에 걸쳐 익숙한 것과 같은 종류의 선언적 구성을 사용하기 때문입니다.

00:12:23.000 --> 00:12:28.000
목록과 마찬가지로, 단일 콘텐츠 모음에서 테이블을 만들 수 있습니다.

00:12:28.000 --> 00:12:36.000
하지만 목록과 달리, 테이블은 각 시각적 열 내의 내용을 정의하는 TableColumns로 구성되어 있다.

00:12:36.000 --> 00:12:46.000
이러한 각 열은 시각적으로 표시되며 컬렉션의 데이터를 사용하여 텍스트 표시와 같은 일반적인 경우에 대한 속기 편의성으로 시각적 콘텐츠를 정의합니다.

00:12:46.000 --> 00:12:56.000
하지만 테이블은 또한 상호 작용하며, 일반 목록과 마찬가지로 단일 행과 여러 행 모두에 대한 행 선택을 지원합니다.

00:12:56.000 --> 00:13:02.000
테이블은 또한 열에서 정렬 가능한 값에 대한 키 경로의 도움으로 정렬을 지원합니다.

00:13:02.000 --> 00:13:10.000
이제, 테이블은 여러 가지 시각적 스타일과 각 열의 모양을 미세 조정하는 것을 포함하여 몇 가지 다른 기능을 지원합니다.

00:13:10.000 --> 00:13:14.000
하지만 당신이 테이블이나 목록에 제공하는 데이터에 대해 더 이야기해 봅시다.

00:13:14.000 --> 00:13:19.000
올해, 우리는 CoreData 가져오기 요청에 대한 SwiftUI의 지원에 대한 몇 가지 새로운 개선 사항이 있습니다.

00:13:19.000 --> 00:13:33.000
FetchRequests는 이제 테이블에 전달할 수 있는 정렬 설명자에 대한 바인딩을 제공하여 몇 줄의 코드로 선택 및 정렬 가능한 열로 완성된 완전한 핵심 데이터 기반 테이블을 작성할 수 있습니다.

00:13:33.000 --> 00:13:44.000
SwiftUI는 이제 단일 요청에서 구동될 수 있는 오른쪽에 있는 것과 같은 복잡한 다중 섹션 목록을 허용하는 섹션된 가져오기 요청을 제공합니다.

00:13:44.000 --> 00:13:49.000
이 예에서, 우리는 데이터가 고정되었는지 여부에 따라 섹션으로 분할합니다.

00:13:49.000 --> 00:14:00.000
우리는 여러 개의 SortDescriptors를 사용하여 데이터를 정렬하고, 첫 번째는 고정된 섹션과 고정되지 않은 섹션으로 나누고, 두 번째는 최근에 수정된 문자를 마지막으로 정렬합니다.

00:14:00.000 --> 00:14:03.000
다음으로 우리는 모든 변경 사항이 애니메이션화되어야 한다고 명시한다.

00:14:03.000 --> 00:14:12.000
그리고 마지막으로 우리는 요청 결과에 따라 목록의 섹션과 행을 동적으로 구성합니다.

00:14:12.000 --> 00:14:18.000
이 단일 요청은 모두 오른쪽에 있는 애니메이션 목록을 구동할 수 있다.

00:14:18.000 --> 00:14:28.000
macOS용 앱 구축, 테이블 작업, SwiftUI와 코어 데이터 통합에 대한 자세한 내용은 이러한 다른 회담을 확인하십시오.

00:14:28.000 --> 00:14:35.000
"SwiftUI on the Mac" 2부작 시리즈는 Mac에 최적화된 앱을 구축하는 과정을 단계별로 안내합니다.

00:14:35.000 --> 00:14:44.000
그리고 "Swift와 SwiftUI에 핵심 데이터 동시성 가져오기"는 새로운 핵심 데이터 가져오기 요청 API를 훨씬 더 자세히 다룰 것이다.

00:14:44.000 --> 00:14:50.000
이제 한 발 물러서서 사용자가 이 모든 데이터 속에서 필요한 것을 찾을 수 있도록 어떻게 도울 수 있는지 생각해 볼 때입니다.

00:14:50.000 --> 00:14:54.000
물론, 나는 검색에 대해 이야기하고 있어.

00:14:54.000 --> 00:14:57.000
검색은 우리의 모든 플랫폼에서 중요한 부분이다.

00:14:57.000 --> 00:15:01.000
그것은 사용자가 필요할 때 정확히 필요한 것을 찾을 수 있도록 도와준다.

00:15:01.000 --> 00:15:08.000
Apple TV와 같은 대형 장치에서 찾을 수 있으며, 심지어 Apple Watch와 같은 가장 작은 장치까지 찾을 수 있습니다.

00:15:08.000 --> 00:15:16.000
따라서 검색은 멀티플랫폼 문제이기 때문에, 이러한 모든 장치에서 확장할 수 있는 멀티플랫폼 솔루션이 필요합니다.

00:15:16.000 --> 00:15:24.000
운 좋게도, 앱에 검색을 추가하는 것은 더 쉬울 수 없습니다. NavigationView에서 했던 것처럼 검색 가능한 수정자를 추가하기만 하면 됩니다.

00:15:24.000 --> 00:15:35.000
이 하나의 수정자를 사용하면 SwiftUI는 앱의 적절한 위치에 검색 필드를 자동으로 추가하고 선택적으로 플랫폼 및 상황에 맞는 방식으로 제안을 표시합니다.

00:15:35.000 --> 00:15:41.000
수정자는 검색 텍스트에 바인딩하여 현재 값을 기준으로 데이터를 필터링할 수 있습니다.

00:15:41.000 --> 00:15:51.000
이제, SwiftUI의 검색에 대해 할 말이 훨씬 더 많지만, 운 좋게도 우리는 여러 플랫폼에서 검색 기능에 대해 생각하는 방법을 안내하는 전체 세션이 있습니다.

00:15:51.000 --> 00:15:55.000
자세한 내용은 "SwiftUI의 공예 검색 경험"을 확인하세요.

00:15:55.000 --> 00:16:04.000
지금까지 우리는 목록과 그리드를 사용하여 앱의 데이터를 로드, 표시, 구성 및 검색하는 방법을 탐구했습니다.

00:16:04.000 --> 00:16:08.000
이제 앱 이외의 데이터를 공유하는 방법에 대해 이야기해 봅시다.

00:16:08.000 --> 00:16:13.000
데이터를 공유하는 가장 간단한 방법 중 하나는 앱에서 끌어내는 것입니다.

00:16:13.000 --> 00:16:21.000
내 Heroes &amp; Villains 앱에서 기존 onDrag 수정자를 사용하여 드래그할 수 있도록 세부 화면의 캐릭터 아이콘을 구성했습니다.

00:16:21.000 --> 00:16:26.000
올해 새로운, 이제 드래그 가능한 보기에 사용자 지정 미리보기를 추가할 수 있습니다.

00:16:26.000 --> 00:16:32.000
이 미리보기는 드래그하는 동안 보기 대신 표시됩니다.

00:16:32.000 --> 00:16:39.000
드래그 앤 드롭은 다른 프로세스 간에 데이터를 복사하고 공유할 수 있는 항목 공급자에 의해 구동됩니다.

00:16:39.000 --> 00:16:57.000
올해 SwiftUI는 새로운 importsItemProviders 수정자를 사용하여 외부 서비스에서 항목 공급자 가져오기를 지원하도록 앱을 구성하는 것과 같은 다른 앱 및 서비스와 통합하기 위해 항목 공급자를 사용하는 몇 가지 방법을 더 제공하고 있습니다.

00:16:57.000 --> 00:17:05.000
이 예에서, 우리는 이미지를 가져오고 스토리 캐릭터에 첨부 파일로 추가할 수 있도록 보기를 구성했습니다.

00:17:05.000 --> 00:17:11.000
우리는 이 기능을 새로운 macOS 기능과 페어링할 수 있습니다: 연속성 카메라.

00:17:11.000 --> 00:17:21.000
앱의 메인 메뉴에 "장치에서 가져오기" 명령을 추가함으로써, 이제 iPhone 또는 iPad를 사용하여 사진을 찍어 Mac 앱으로 가져올 수 있습니다.

00:17:21.000 --> 00:17:23.000
한 번 해보자!

00:17:23.000 --> 00:17:26.000
뷰 빌더 슈퍼히어로의 상징은 그녀의 믿음직한 망치이다.

00:17:26.000 --> 00:17:30.000
그녀의 프로필에 사진을 첨부하면 좋을 것 같아.

00:17:30.000 --> 00:17:34.000
운 좋게도, 나는 바로 여기에 그것을 가지고 있어!

00:17:34.000 --> 00:17:42.000
내 앱 내에서 파일 메뉴의 "장치에서 가져오기" 명령에 액세스할 수 있습니다.

00:17:42.000 --> 00:17:49.000
그럼, 나는 내 아이폰을 사용하여 사진을 찍을 수 있어...

00:17:49.000 --> 00:17:56.000
....카메라 앱을 자동으로 열어서 빠르게 사진을 찍을 수 있습니다.

00:17:56.000 --> 00:18:03.000
그리고 새로운 사진은 우리가 이전에 보여준 importsItemProviders 수정자를 사용하여 내 앱에 가져와서 추가됩니다.

00:18:03.000 --> 00:18:07.000
SwiftUI는 또한 앱에서 데이터 내보내기를 지원합니다.

00:18:07.000 --> 00:18:15.000
데이터를 내보내면 앱 내에서 직접 바로 가기를 트리거할 수 있는 것과 같은 다른 서비스를 이용할 수 있습니다.

00:18:15.000 --> 00:18:20.000
SwiftUI에서는 새로운 exportsItemProviders 수정자를 사용하여 데이터를 내보낼 수 있습니다.

00:18:20.000 --> 00:18:28.000
이것은 앱의 데이터를 시스템의 나머지 부분에 노출합니다. 예를 들어, macOS의 서비스 및 단축키에서 사용할 수 있습니다.

00:18:28.000 --> 00:18:33.000
앱을 사용하는 사람들에게 이것이 어떻게 나타나는지 살펴봅시다.

00:18:33.000 --> 00:18:39.000
이제 고정된 문자 중 하나를 선택하면 앱의 서비스 메뉴에 빠른 동작이 표시되는 것을 볼 수 있습니다.

00:18:39.000 --> 00:18:48.000
이것은 최신 사진에 제목 배너를 추가하는 편리한 지름길이며, 최신 슈퍼히어로 아이디어를 친구들과 공유하는 데 사용할 수 있습니다.

00:18:48.000 --> 00:18:54.000
나는 또한 사랑스러운 개인 내 스타일라이저 슈퍼히어로를 위해 사용할 이 멋진 사진을 찾았다.

00:18:54.000 --> 00:19:00.000
내 맞춤 단축키는 이 재미있는 배너를 상단에 추가하고 영웅의 이름을 겹쳐 얹었다.

00:19:00.000 --> 00:19:02.000
내 지름길은 또한 내가 사진을 공유할 수 있게 해준다.

00:19:02.000 --> 00:19:07.000
나는 테일러의 피드백을 받고 싶어, 왜냐하면 그는 멋진 그래픽에 대해 한두 가지를 알고 있거든.

00:19:07.000 --> 00:19:15.000
테일러를 받는 사람으로 추가하고 빠른 메시지를 입력하고 보낼 수 있어!

00:19:15.000 --> 00:19:17.000
어떻게 생각해, 테일러?

00:19:17.000 --> 00:19:19.000
테일러 켈리: 고마워, 매트. 완벽해 보여.

00:19:19.000 --> 00:19:22.000
그리고 그것은 확실히 당신의 새로운 연락처 사진이 될 것입니다.

00:19:22.000 --> 00:19:26.000
이 사랑스러운 이미지는 다음 섹션인 고급 그래픽으로의 훌륭한 전환점이다.

00:19:26.000 --> 00:19:33.000
올해에는 많은 흥미로운 개선 사항이 있습니다: 상징 업데이트, 재료 및 활기에서 강력한 새로운 캔버스 보기에 이르기까지.

00:19:33.000 --> 00:19:34.000
첫 번째는 상징이다.

00:19:34.000 --> 00:19:39.000
SF 기호는 앱 전체에 아름다운 도상학을 추가하는 훌륭하고 쉬운 방법입니다.

00:19:39.000 --> 00:19:46.000
올해에는 많은 새로운 것들이 있을 뿐만 아니라, 앱에서 더 쉽고 표현적으로 사용할 수 있는 몇 가지 새로운 기능이 함께 제공됩니다.

00:19:46.000 --> 00:19:51.000
기호의 스타일을 훨씬 더 잘 제어할 수 있는 두 가지 새로운 렌더링 모드가 있습니다.

00:19:51.000 --> 00:20:02.000
계층은 현재 전경 스타일을 사용하여 흑백처럼 기호를 색칠하지만, 기호의 핵심 요소를 실제로 강조하기 위해 여러 수준의 불투명도를 자동으로 추가합니다.

00:20:02.000 --> 00:20:08.000
그리고 팔레트는 사용자 지정 채우기로 기호의 개별 레이어를 훨씬 더 세밀하게 제어할 수 있게 해줍니다.

00:20:08.000 --> 00:20:13.000
이 새로운 모드에 대한 자세한 정보와 디자인 지침은 "SF 심볼의 새로운 기능"을 확인하세요.

00:20:13.000 --> 00:20:17.000
이것들과 완벽하게 페어링하는 것은 SwiftUI에서 사용할 수 있는 색상 세트에 대한 업데이트입니다.

00:20:17.000 --> 00:20:26.000
이 색상들은 그들이 나타나는 모든 다른 구성에 최적화되어 있습니다: 라이트 및 다크 모드, 블러에 대한 특정 모양, 심지어 그들이 표시되는 특정 플랫폼까지.

00:20:26.000 --> 00:20:30.000
다른 색상 외에도, 상징은 다양한 모양으로 나온다.

00:20:30.000 --> 00:20:34.000
많은 기호에는 채워진, 동그라미 등으로 표시되는 수정자가 있다.

00:20:34.000 --> 00:20:36.000
이전에는 이러한 변형을 하드코딩해야 했습니다.

00:20:36.000 --> 00:20:41.000
하지만 그 이상으로, 당신은 어떤 맥락에서 어떤 변형을 사용하는 것이 옳은지 알아야 했습니다.

00:20:41.000 --> 00:20:50.000
iOS 휴먼 인터페이스 지침은 탭 바에서 채워진 변형을 선호하는 방법을 설명하므로, 이름에 .fill 수정자를 구체적으로 포함해야 했습니다.

00:20:50.000 --> 00:20:52.000
올해, 당신은 그것에 대해 걱정할 필요가 없습니다.

00:20:52.000 --> 00:20:56.000
SwiftUI는 당신이 사용하는 상황에 따라 당신에게 맞는 변형을 자동으로 선택할 것입니다.

00:20:56.000 --> 00:21:00.000
사용하고 싶은 기본 기호를 제공하기만 하면 됩니다.

00:21:00.000 --> 00:21:06.000
그리고 원하는 정확한 구성을 과도하게 지정하지 않음으로써, 더 재사용 가능한 코드도 얻을 수 있습니다.

00:21:06.000 --> 00:21:13.000
예를 들어, macOS에서 동일한 코드를 실행하면, 해당 플랫폼에 대한 올바른 변형을 얻을 수 있습니다: 개요.

00:21:13.000 --> 00:21:21.000
사용자 지정 보기에서 이 자동 지원과 더 많은 기호 향상을 활용하는 방법을 배우려면 "SwiftUI의 SF 기호"를 확인하세요.

00:21:21.000 --> 00:21:26.000
이제 SF 심볼이 많기 때문에, 나는 그들 모두를 탐색할 수 있는 멋진 비주얼라이저를 만들고 싶었다.

00:21:26.000 --> 00:21:30.000
이것은 SwiftUI의 새로운 캔버스 보기에 좋은 용도이다.

00:21:30.000 --> 00:21:34.000
캔버스는 UIKit 또는 AppKit의 drawRect와 유사한 즉각적인 모드 그리기를 지원합니다.

00:21:34.000 --> 00:21:41.000
개별 추적이나 무효화가 필요하지 않은 많은 그래픽 요소를 구성할 때, 이것은 훌륭한 도구입니다.

00:21:41.000 --> 00:21:45.000
여기 OS와 함께 제공되는 모든 SF 기호를 표시하는 캔버스가 있습니다.

00:21:45.000 --> 00:21:50.000
그리고 그들 중 3166명 모두에게, 그것은 그들 각각을 그들 자신의 프레임으로 끌어들인다.

00:21:50.000 --> 00:21:52.000
캔버스는 모든 플랫폼에서 작동한다.

00:21:52.000 --> 00:22:03.000
그리고 캔버스는 다른 것과 같은 보기이기 때문에, 제스처, 접근성 정보를 첨부하고, 다크 모드에 적응하는 것과 같은 상태나 환경에 따라 업데이트할 수 있습니다.

00:22:03.000 --> 00:22:07.000
여기, 저는 확대할 초점을 설정할 수 있는 제스처를 추가했습니다.

00:22:07.000 --> 00:22:11.000
그리고 나는 그것을 바탕으로 각 기호의 프레임과 불투명도를 업데이트할 것이다.

00:22:11.000 --> 00:22:18.000
이제 클릭하고 드래그할 수 있으며 커서가 화면 주위를 이동함에 따라 모든 기호가 원활하게 업데이트됩니다.

00:22:18.000 --> 00:22:23.000
우리는 또한 새로운 접근성 어린이 수정자를 활용하여 이것이 완전히 접근할 수 있도록 할 수 있습니다.

00:22:23.000 --> 00:22:31.000
정말 멋진 것은 SwiftUI에서 사용하는 것과 동일한 뷰를 재사용하여 접근성 기능을 통해 어떻게 전달되는지 다듬는 것입니다.

00:22:31.000 --> 00:22:39.000
이 경우, 기호는 이제 누군가가 목록의 요소를 탐색하는 것처럼 열거될 수 있으며, 각 요소를 탐색할 때 말할 수 있습니다.

00:22:39.000 --> 00:22:46.000
이 수정자는 캔버스에만 국한되지 않지만, 접근성 경험을 실제로 연마하기 위해 어떤 목적으로든 사용할 수 있습니다.

00:22:46.000 --> 00:22:52.000
우리가 캔버스에 추가할 수 있는 마지막 한 가지는 새로운 TimelineView를 사용하여 시간이 지남에 따라 업데이트하는 것입니다.

00:22:52.000 --> 00:22:58.000
tvOS를 위한 개선은 초점이 화면 보호기처럼 작동하여 화면 주위를 애니메이션으로 움직이게 하는 것이다.

00:22:58.000 --> 00:23:05.000
TimelineView는 일정(이 경우 애니메이션 일정)으로 생성되며 현재 렌더링 시간을 제공합니다.

00:23:05.000 --> 00:23:11.000
그래서 우리는 그 시간을 사용하여 변환의 초점 포인트를 업데이트하여 아름다운 심볼 스크린 세이버를 만들 수 있습니다.

00:23:11.000 --> 00:23:14.000
이 타임라인뷰는 훨씬 더 많은 것을 할 수 있다.

00:23:14.000 --> 00:23:17.000
Apple Watch의 정말 멋진 기능은 항상 켜져 있다는 것이다.

00:23:17.000 --> 00:23:22.000
이전에는 앱이 Always On 상태로 들어갈 때 오버레이된 시간으로 흐려질 것입니다.

00:23:22.000 --> 00:23:32.000
그리고 watchOS 8을 사용하면 앱이 기본적으로 어두워지고, SwiftUI가 어떻게 나타나는지 더 잘 제어할 수 있으며, 그 중 하나는 TimelineView입니다.

00:23:32.000 --> 00:23:39.000
시계가 항상 켜져 있는 상태로 들어가면, TimelineView는 향후 날짜에 보기 표시를 미리 로드할 수 있습니다.

00:23:39.000 --> 00:23:46.000
그리고 우리가 미래로 이동함에 따라, 그 보기는 백그라운드에서 앱을 가져가지 않고도 화면에 자동으로 표시됩니다.

00:23:46.000 --> 00:23:49.000
이것의 중요한 부분은 타임라인 일정이다.

00:23:49.000 --> 00:23:59.000
이 예에서, 저는 간단한 everyMinute 일정을 사용하고 있으므로 TimelineView는 분당 1분의 디스플레이를 미리 로드하여 브라우저에서 다음 기호를 보여줍니다.

00:23:59.000 --> 00:24:09.000
특정 시간에 이벤트가 있을 때 잘 작동하는 명시적인 날짜 모음과 같이 앱의 요구에 맞는 몇 가지 다른 종류의 일정도 있습니다.

00:24:09.000 --> 00:24:15.000
이제, 이 모드의 또 다른 중요한 측면은 다른 사람들이 볼 수 있기 때문에 사용자에게 민감한 정보를 숨기는 것이다.

00:24:15.000 --> 00:24:17.000
나는 정말 내가 가장 좋아하는 상징을 비공개로 유지하고 싶어.

00:24:17.000 --> 00:24:24.000
그리고 단순히 PrivacySensitive 수정자를 추가하면, 시계가 Always On 상태로 들어가면 자동으로 편집됩니다.

00:24:24.000 --> 00:24:29.000
Always On 디스플레이 등에 대한 자세한 내용은 "watchOS 8의 새로운 기능"을 확인하세요.

00:24:29.000 --> 00:24:33.000
그리고 이 개인 정보 보호 수정자는 위젯에서도 작동합니다.

00:24:33.000 --> 00:24:42.000
잠금 화면에 추가된 위젯은 이를 사용하여 장치가 잠겨 있는 동안 민감한 정보를 숨기고 장치가 잠금 해제되면 표시됩니다.

00:24:42.000 --> 00:24:48.000
"훌륭한 위젯의 원리"는 앱을 위한 멋진 위젯을 만드는 이것과 다른 방법에 대해 더 자세히 설명할 것입니다.

00:24:48.000 --> 00:24:58.000
자료는 Apple의 모든 플랫폼과 앱에서 콘텐츠를 강조하는 아름다운 시각 효과를 만드는 데 사용되며, 이제 SwiftUI에서 직접 만들 수 있습니다!

00:24:58.000 --> 00:25:06.000
저는 심볼 브라우저에 색상과 재료를 추가하는 것을 실험하고 있으며, 기호 수를 표시하기 위해 재료 백업 오버레이를 추가하고 있습니다.

00:25:06.000 --> 00:25:09.000
재료를 추가하는 것은 배경을 추가하는 것만큼 쉽다.

00:25:09.000 --> 00:25:14.000
저는 ultraThinMaterial을 사용하고 있으며, 채울 사용자 지정 모양을 줄 수 있습니다.

00:25:14.000 --> 00:25:23.000
이 재료들은 1차, 2차, 3차, 그리고 이제 4차 전경 스타일을 사용할 때 그 위에 콘텐츠의 예상되는 생생한 혼합과 함께 자동으로 제공됩니다.

00:25:23.000 --> 00:25:29.000
그리고 이모티콘은 자동으로 그것에서 제외되므로, 정확히 그렇게 보인다.

00:25:29.000 --> 00:25:39.000
Mac에서 사이드바와 팝오버와 같은 시스템 컨텍스트는 자동으로 흐릿한 재료 배경을 가지고 있으며 이제 그 안에 있는 콘텐츠에 대해 예상되는 생생한 모습을 갖게 될 것이다.

00:25:39.000 --> 00:25:50.000
이 새로운 자료는 새로운 safeAreaInset 수정자와 함께 잘 작동하며, 스크롤 가능한 보기 위에 콘텐츠를 배치하고 콘텐츠 위치가 예상대로 시작되고 종료되도록 할 수 있습니다.

00:25:50.000 --> 00:25:55.000
"풍부한 그래픽" 세션은 캔버스, 재료 등에 대해 훨씬 더 자세히 다룹니다.

00:25:55.000 --> 00:26:03.000
그리고 그것을 마무리하기 위해, 이러한 아름다운 사용자 지정 뷰를 정의하는 새로운 방법을 보완하는 것은 Xcode의 SwiftUI 미리보기에 대한 몇 가지 개선 사항입니다.

00:26:03.000 --> 00:26:14.000
첫 번째는 미리보기에서 iOS 장치의 방향을 지정하고 다른 방향에서 미리보기를 믹스 앤 매치할 수 있는 새로운 미리보기 방향 수정자입니다.

00:26:14.000 --> 00:26:19.000
그리고 두 번째는 미리보기에서 앱의 접근성을 편집하고 보는 방법에 대한 큰 개선입니다.

00:26:19.000 --> 00:26:27.000
속성 편집기는 이제 접근성 수정자 목록을 선별하여 뷰의 접근성 행동을 더욱 쉽게 연마할 수 있습니다.

00:26:27.000 --> 00:26:32.000
그리고 새로운 접근성 미리보기 탭으로 미리보기를 보는 완전히 새로운 방법이 있습니다.

00:26:32.000 --> 00:26:38.000
당신은 접근성 요소와 그 속성에 대한 실시간 텍스트 표현을 보게 될 것입니다.

00:26:38.000 --> 00:26:45.000
이것은 접근성 기능을 강화하는 것과 동일한 정보이지만, 이제 당신에게 더 친숙할 수 있는 형식으로 제공됩니다.

00:26:45.000 --> 00:26:53.000
"SwiftUI 접근성" 세션에서 이에 대한 자세한 정보와 앱에 대한 놀라운 접근성 경험을 만드는 방법에 대해 자세히 알아보세요!

00:26:53.000 --> 00:27:00.000
이제, 다음은 텍스트, 텍스트 관련 컨트롤 및 키보드 탐색에 대한 다양한 개선 사항입니다.

00:27:00.000 --> 00:27:02.000
텍스트는 모든 앱에서 매우 기본이다.

00:27:02.000 --> 00:27:07.000
그것은 당신의 앱이 사람들과 소통하는 주요 방법 중 하나입니다; 그것은 종종 당신이 쓰는 첫 번째 보기입니다.

00:27:07.000 --> 00:27:15.000
그리고 올해는 스타일링에서 현지화, 상호 작용 및 서식에 이르기까지 많은 새로운 흥미로운 기능을 얻고 있다.

00:27:15.000 --> 00:27:18.000
첫 번째는 마크다운 지원이다.

00:27:18.000 --> 00:27:21.000
텍스트는 이제 직접 인라인으로 마크다운 포맷을 포함할 수 있습니다.

00:27:21.000 --> 00:27:31.000
이것은 강력한 강조, 상호 작용할 수 있는 링크, 심지어 코드 스타일 프레젠테이션을 추가하는 데 사용될 수 있다.

00:27:31.000 --> 00:27:36.000
그리고 이것은 모두 Foundation의 새롭고 강력한 Swift 기반 AttributedString 위에 구축되었습니다.

00:27:36.000 --> 00:27:47.000
마크다운 지원 외에도, 풍부하고 형식에 안전한 속성의 전체 제품군과 자신의 속성을 정의하고 마크다운 구문 내에서 사용할 수 있는 기능을 제공합니다.

00:27:47.000 --> 00:27:53.000
이것과 놀라운 새로운 자동 문법 계약에 대한 자세한 내용은 "재단의 새로운 기능"을 확인하세요.

00:27:53.000 --> 00:27:58.000
중요한 것은, 텍스트는 또한 전 세계 사람들이 당신의 앱을 사용할 수 있도록 콘텐츠를 현지화한다는 것입니다.

00:27:58.000 --> 00:28:05.000
그리고 이것은 언어에 민감한 속성을 적절하게 현지화할 수 있도록 하는 새로운 마크다운 지원에서도 마찬가지입니다.

00:28:05.000 --> 00:28:09.000
현지화에 대한 또 다른 큰 개선은 Xcode 13에서 나온다.

00:28:09.000 --> 00:28:20.000
이제 Swift 컴파일러를 사용하여 LocalizedStringKey와 새로운 localizedString 및 attributedString 이니셜라이저의 모든 사용에서 문자열과 현지화 카탈로그를 생성합니다.

00:28:20.000 --> 00:28:26.000
이것과 다른 현지화 팁과 요령에 대해 자세히 알아보려면, "SwiftUI 앱 현지화"를 확인하세요.

00:28:26.000 --> 00:28:32.000
이제, 텍스트를 표시하는 이러한 새로운 방법 외에도, 텍스트를 더욱 역동적으로 만드는 새로운 방법이 있습니다.

00:28:32.000 --> 00:28:35.000
첫 번째는 중요한 접근성 기능이다: 동적 유형.

00:28:35.000 --> 00:28:47.000
SwiftUI는 처음부터 Dynamic Type을 지원해 왔으며, 올해는 UI가 지원하는 유형 크기의 범위를 제한하여 너무 크거나 너무 작지 않도록 하는 새로운 API를 가지고 있습니다.

00:28:47.000 --> 00:28:50.000
이것은 우리의 헤더가 기본 큰 크기에서 어떻게 생겼는지 보여줍니다.

00:28:50.000 --> 00:29:02.000
저는 개인적으로 내 콘텐츠에 추가 정보 밀도를 얻기 위해 Dynamic Type을 사용하며, 이것은 최소한 큰 크기로 제한되기 때문에 헤더가 작은 유형 크기에서 어떻게 같은 크기를 유지했는지 보여줍니다.

00:29:02.000 --> 00:29:11.000
스펙트럼의 다른 쪽 끝에서, 접근성 크기를 사용하면 헤더가 더 커지지만, 엑스트라 라지 크기까지만 커집니다.

00:29:11.000 --> 00:29:18.000
macOS는 동적 유형을 지원하지 않지만, 또 다른 중요한 텍스트 상호 작용을 지원합니다: 선택 가능한 텍스트.

00:29:18.000 --> 00:29:25.000
이를 통해 사람들은 앱에서 편집할 수 없는 텍스트에 대한 조치를 취할 수 있으며, 이제 textSelection 수정자를 사용하여 활성화할 수 있습니다.

00:29:25.000 --> 00:29:33.000
그 수정자는 모든 보기에 적용될 수 있으며, 그 안에 있는 모든 텍스트에 적용됩니다. 이 예에서는 이제 헤더의 텍스트에 적용됩니다.

00:29:33.000 --> 00:29:40.000
그리고 우리는 또한 iOS와 iPadOS에 이 수정자를 도입하여 길게 누르면 텍스트를 복사하거나 공유할 수 있습니다.

00:29:40.000 --> 00:29:48.000
마지막으로, 재단의 새로운 형식 스타일 API는 텍스트 포맷을 훨씬 더 간단하게 만들지만, 여전히 정확한 프레젠테이션을 가능하게 한다.

00:29:48.000 --> 00:29:51.000
여기에 기본 서식을 적용하는 날짜가 있습니다.

00:29:51.000 --> 00:29:56.000
그리고 이것은 활동 목록에서 사용되는 시간만 표시하는 변형이다.

00:29:56.000 --> 00:30:01.000
그리고 마지막으로, 표시할 정확한 구성 요소를 지정할 수 있는 확장된 형식.

00:30:01.000 --> 00:30:07.000
우리의 활동 목록은 또한 다양한 사람들을 적절하게 현지화된 프레젠테이션으로 포맷하는 것을 특징으로 한다.

00:30:07.000 --> 00:30:09.000
이걸 빨리 살펴보자.

00:30:09.000 --> 00:30:17.000
우리는 사람 값을 PersonNameComponents 배열로 매핑하고 목록 형식 스타일을 사용하여 서식을 지정하고 있습니다.

00:30:17.000 --> 00:30:24.000
그리고 목록의 각 구성원에 대해, 짧은 스타일의 PersonNameComponent 형식을 사용하여 이름만 표시합니다.

00:30:24.000 --> 00:30:27.000
그리고 마지막으로, 그것을 "그리고" 결합으로 결합하세요.

00:30:27.000 --> 00:30:34.000
모두 함께, 원하는 수의 사람들을 적절하게 처리하는 형식의 성능과 형식에 안전한 표현을 만듭니다.

00:30:34.000 --> 00:30:42.000
TextField는 또한 이러한 새로운 형식 스타일에 대한 지원을 받았으며, 일부 기본 값에 형식에 안전한 바인딩으로 편집 가능한 형식의 텍스트를 추가할 수 있습니다.

00:30:42.000 --> 00:30:50.000
새로운 참석자 필드는 PersonNameComponents 값에 바인딩되며, 표준 이름 형식을 사용하여 포맷됩니다.

00:30:50.000 --> 00:30:55.000
이것은 입력을 구문 분석하고 결과적인 사람 이름을 생성합니다.

00:30:55.000 --> 00:31:00.000
"재단의 새로운 기능"은 또한 이러한 새로운 형식 스타일의 힘에 대해 자세히 설명한다.

00:31:00.000 --> 00:31:09.000
TextField는 이제 사용자가 필드가 어떤 종류의 콘텐츠를 기대하는지 알 수 있도록 라벨과 별도로 명시적인 프롬프트를 추가하는 것을 지원합니다.

00:31:09.000 --> 00:31:17.000
그리고 macOS의 양식에 TextField를 추가할 때, 그들은 다른 컨트롤과 유사한 라벨을 정렬하고 프롬프트를 자리 표시자 콘텐츠로 사용합니다.

00:31:17.000 --> 00:31:23.000
이제, 텍스트 필드의 전체 요점은 텍스트를 추가하는 것이며, 키보드는 그렇게 하는 우리의 도구입니다.

00:31:23.000 --> 00:31:34.000
iPhone의 소프트웨어 키보드부터 소프트웨어와 하드웨어 키보드를 모두 지원하는 iPad, 그리고 물론 항상 하드웨어 키보드가 있는 macOS까지.

00:31:34.000 --> 00:31:38.000
올해, 키보드 사용 경험을 더 좋게 만들기 위한 몇 가지 개선 사항이 있습니다.

00:31:38.000 --> 00:31:47.000
새로운 onSubmit 수정자를 사용하면 Return 키를 눌러 사용자가 필드의 텍스트를 제출할 때 추가 작업을 쉽게 추가할 수 있습니다.

00:31:47.000 --> 00:31:53.000
이 수정자는 전체 형태의 컨트롤에도 적용될 수 있다는 점에서 추가적인 유연성을 제공한다.

00:31:53.000 --> 00:32:00.000
그리고 사용자에게 필드를 제출할 때 어떤 종류의 작업이 발생할지에 대한 힌트를 제공하기 위해, 새로운 submitLabel 수정자가 있습니다.

00:32:00.000 --> 00:32:04.000
소프트웨어 키보드에서, 이것은 Return 키의 라벨로 사용될 것이다.

00:32:04.000 --> 00:32:10.000
그리고 마지막으로, 우리는 새로운 키보드 도구 모음 배치를 사용하여 키보드에 액세서리 보기를 추가할 수 있게 했습니다.

00:32:10.000 --> 00:32:18.000
이러한 보기는 iOS 및 iPadOS의 소프트웨어 키보드 위의 도구 모음 또는 macOS의 Touch Bar에 표시됩니다.

00:32:18.000 --> 00:32:25.000
이것은 사용자가 앱의 편집 경험을 방해하지 않도록 해제하지 않고 키보드 위의 작업에 빠르게 액세스할 수 있는 좋은 방법입니다.

00:32:25.000 --> 00:32:40.000
키보드는 또한 탐색과 초점의 또 다른 중요한 역할을 하며, 이 기능은 모든 플랫폼에 존재합니다. watchOS에 초점을 맞추고 디지털 크라운 입력을 지시하는 것부터 Siri Remote를 사용하여 tvOS의 콘텐츠를 탐색하는 것까지.

00:32:40.000 --> 00:32:46.000
대부분의 경우, SwiftUI는 어떤 견해에 초점을 맞출 수 있는지, 그리고 그 사이에서 어떻게 움직이는지 돌본다.

00:32:46.000 --> 00:32:51.000
하지만 때로는 앱에서 더 원활한 경험을 만들기 위해 만들 수 있는 추가 개선 사항이 있습니다.

00:32:51.000 --> 00:32:57.000
그것을 돕기 위해, SwiftUI는 FocusState라는 새롭고 강력한 도구를 가지고 있다.

00:32:57.000 --> 00:33:02.000
이것은 초점 상태를 반영하고 정확한 제어를 제공하는 속성 래퍼입니다.

00:33:02.000 --> 00:33:06.000
가장 간단하게, 그것은 부울 값을 반영할 수 있다.

00:33:06.000 --> 00:33:09.000
이것은 집중된 수정자를 사용하여 초점을 맞출 수 있는 보기와 연결될 수 있다.

00:33:09.000 --> 00:33:13.000
그 견해가 집중되면, 그 값은 참이고, 그렇지 않을 때는 거짓이 될 것이다.

00:33:13.000 --> 00:33:16.000
이 값은 또한 초점을 제어하기 위해 쓸 수 있다.

00:33:16.000 --> 00:33:19.000
예를 들어, 누군가가 버튼을 누르는 것에 대한 응답으로.

00:33:19.000 --> 00:33:26.000
이 예제는 가속기 역할을 할 수 있으며, 사용자가 관련 작업을 수행한 후 즉시 입력을 시작할 수 있습니다.

00:33:26.000 --> 00:33:31.000
이 부울 버전은 모든 해시 가능한 유형을 나타내는 완전한 형태의 편리함이다.

00:33:31.000 --> 00:33:36.000
이 코드는 기능적으로 이전 슬라이드와 동일하지만 유연성이 다소 향상되었습니다.

00:33:36.000 --> 00:33:37.000
그걸 통해 걸어가자.

00:33:37.000 --> 00:33:42.000
먼저, 나는 내가 알고 싶을 수도 있는 분야의 간단한 열거를 정의했다.

00:33:42.000 --> 00:33:46.000
FocusState 속성은 현재 상태를 반영하기 위해 그 유형을 사용합니다.

00:33:46.000 --> 00:33:49.000
잠재적으로 아무도 집중하지 않았다는 것을 나타내는 것은 선택 사항이다.

00:33:49.000 --> 00:33:55.000
우리의 집중 수정자는 여전히 동일한 초점 상태에 묶여 있지만, addAttendee와 같을 때만 가능합니다.

00:33:55.000 --> 00:34:01.000
그리고 마지막으로, 우리가 그 분야에 집중하고 싶을 때, 우리는 addAttendee에 초점 상태 값을 설정합니다.

00:34:01.000 --> 00:34:11.000
이 새로운 유연성을 통해 이전부터 도구 모음 버튼을 만들고, 각 필드 간에 초점을 이동하고, 초점이 시작이나 끝에 도달하는지 반영하는 것과 같은 추가 기능을 추가할 수 있습니다.

00:34:11.000 --> 00:34:18.000
포커스 상태는 또한 iOS 앱이 가치를 지워 소프트웨어 키보드를 해제할 수 있는 좋은 방법을 제공한다.

00:34:18.000 --> 00:34:26.000
앱에서 포커스 경험을 개선하는 다른 방법에 대해 더 알고 싶다면, 올해의 세션인 "SwiftUI에서 초점을 직접하고 반영하세요"를 확인하세요.

00:34:26.000 --> 00:34:31.000
마지막으로, 우리는 버튼이 중요하기 때문에 버튼에 집중할 것이다.

00:34:31.000 --> 00:34:39.000
우리 모두는 전형적인 버튼이 어떻게 생겼는지 알고 있습니다. 플랫폼마다 다르며, 사람들이 앱과 상호 작용할 수 있도록 하는 가장 간단한 방법 중 하나입니다.

00:34:39.000 --> 00:34:43.000
그리고 특히 SwiftUI에서, 버튼은 많은 것들에 사용된다.

00:34:43.000 --> 00:34:46.000
매트는 이전에 스와이프 동작이 버튼으로 어떻게 구성되는지에 대해 논의했다.

00:34:46.000 --> 00:34:51.000
그리고 올해, 버튼이 있는 새로운 것들이 많이 있다.

00:34:51.000 --> 00:34:55.000
첫째, SwiftUI는 이제 iOS에 표준 테두리 버튼이 있습니다.

00:34:55.000 --> 00:35:01.000
이 추가 버튼으로 하는 것처럼 버튼 스타일 수정자를 추가하여 테두리가 있는 버튼을 만들 수 있습니다.

00:35:01.000 --> 00:35:06.000
다른 스타일 수정자와 마찬가지로, 이것은 컨트롤 그룹에 추가될 수 있으며 모두에 적용됩니다.

00:35:06.000 --> 00:35:10.000
주어진 버튼에 대한 특정 모양을 원하는 경우의 색조를 지원합니다.

00:35:10.000 --> 00:35:15.000
하지만 이 UI의 경우, 나는 악센트 색상을 사용하는 기본 모양을 좋아한다.

00:35:15.000 --> 00:35:18.000
더 많은 사용자 정의가 내장되어 있습니다.

00:35:18.000 --> 00:35:21.000
첫 번째는 통제 크기와 중요성이다.

00:35:21.000 --> 00:35:25.000
나는 태그를 나타내는 버튼을 사용자 정의하기 위해 이것들을 사용하고 있다.

00:35:25.000 --> 00:35:32.000
그들은 새로운 표준 소형 컨트롤 크기를 사용하고 있으며 그들을 정말로 돋보이게 하기 위해 두드러진 색조를 가지고 있다.

00:35:32.000 --> 00:35:39.000
우리는 이 같은 수정자를 사용하여 또 다른 일반적인 종류의 버튼을 만들 수 있습니다: 이 큰 크기의 것들은 이제 SwiftUI에 내장되어 있습니다.

00:35:39.000 --> 00:35:45.000
큰 제어 크기를 지정하면, 이 아름답고 둥근 직사각형 버튼을 자동으로 얻을 수 있습니다.

00:35:45.000 --> 00:35:53.000
그리고 그들에게 계층감을 주기 위해, 나는 가장 중요한 것을 수정하여 높은 대비 악센트 색상으로 채웠다.

00:35:53.000 --> 00:35:57.000
그리고 보조 버튼은 여전히 색을 칠할 수 있지만 대비가 낮다.

00:35:57.000 --> 00:36:02.000
이 버튼들은 iPad에서도 훌륭하게 만들 수 있는 수정자가 거의 없다.

00:36:02.000 --> 00:36:08.000
텍스트 라벨은 최대 너비를 가지고 있어 전체 버튼은 유연하지만 코믹하게 커지지 않습니다.

00:36:08.000 --> 00:36:18.000
그리고 기본 버튼에는 기본 동작 키보드 단축키가 있으므로, 키보드와 함께 앱을 사용할 때 Return 키를 빠르게 눌러 이 버튼을 항아리에 추가할 수 있습니다.

00:36:18.000 --> 00:36:24.000
이제, 이 API의 대부분은 이미 macOS에 존재했기 때문에 여러 플랫폼을 위한 앱을 훨씬 더 쉽게 만들 수 있습니다.

00:36:24.000 --> 00:36:31.000
한 가지 새로운 추가 사항은 눈에 띄는 색조 지원을 추가하여 이러한 밝은 버튼을 앱에 세련되게 추가할 수 있도록 하는 것입니다.

00:36:31.000 --> 00:36:40.000
이 추가 버튼과 같은 눈에 띄지 않는 버튼은 크롬이 macOS에서 상호 작용을 나타내기 때문에 색조를 표시하지 않습니다.

00:36:40.000 --> 00:36:49.000
두드러진 것에 대해 알게 된 후, 나는 그것을 모든 추가 버튼에 적용하고 싶은 유혹을 받을 수도 있지만, 화면에 눈에 띄는 버튼이 너무 많아서 압도적이고 혼란스러울 수 있다.

00:36:49.000 --> 00:36:52.000
단 하나의 주요 행동을 위해 그것을 예약하는 것이 가장 좋다.

00:36:52.000 --> 00:36:57.000
낮은 두드러진 색조는 iOS에 약간의 색상을 추가하기 위한 훌륭한 대안이다.

00:36:57.000 --> 00:37:08.000
이제, 이 새로운 버튼 스타일에 대해 제가 가장 좋아하는 점은 자동으로 예상되는 누름 및 비활성화 상태, 다크 모드 지원, 그리고 물론 완전히 접근할 수 있고 동적 유형과 호환된다는 것입니다.

00:37:08.000 --> 00:37:11.000
그리고 그들은 앱 간의 일관성을 제공하는 데 도움을 준다.

00:37:11.000 --> 00:37:13.000
그리고 버튼의 새로운 API는 여기서 멈추지 않는다.

00:37:13.000 --> 00:37:23.000
SwiftUI는 또한 버튼을 파괴적인 것으로 표시하는 것과 같은 추가 의미를 가진 버튼에 대한 일류 지원을 추가했으며, 이는 자동으로 예상되는 빨간색 색조를 제공합니다.

00:37:23.000 --> 00:37:30.000
이것이 사용될 수 있는 새로운 맥락 중 하나는 사용자가 데이터에 심각한 영향을 미치는 행동을 확인할 수 있는 확인 대화 상자이다.

00:37:30.000 --> 00:37:37.000
iOS에서는 액션 시트로, iPad에서는 팝오버로, macOS에서는 경고로 표시됩니다.

00:37:37.000 --> 00:37:42.000
SwiftUI는 각 플랫폼의 디자인 감성에 따라 자동으로 처리합니다.

00:37:42.000 --> 00:37:47.000
다음으로, "대문자 B" 버튼이 아닌 버튼에 대해 이야기해 봅시다.

00:37:47.000 --> 00:37:50.000
현재, 앱의 추가 버튼은 사용자의 기본 항아리에 추가됩니다.

00:37:50.000 --> 00:37:54.000
하지만 열렬한 수집가들을 위해, 나는 특정 항아리에 추가하는 것을 지원하고 싶다.

00:37:54.000 --> 00:37:57.000
이것은 메뉴 버튼의 완벽한 사용 사례이다.

00:37:57.000 --> 00:38:03.000
우리는 동일한 "추가" 라벨을 사용할 것이지만, 버튼을 클릭하면 가능한 모든 항아리의 메뉴를 제시할 것입니다.

00:38:03.000 --> 00:38:07.000
그러나, 이 메뉴 버튼들은 시각적으로 많은 두드러진다.

00:38:07.000 --> 00:38:12.000
우리는 올해 추가된 새로운 menuIndicator 수정자를 사용하여 지표를 숨길 수 있습니다.

00:38:12.000 --> 00:38:16.000
그리고 표시기가 없어도, 이 버튼은 여전히 클릭 시 메뉴를 표시합니다.

00:38:16.000 --> 00:38:25.000
하지만 이 버튼의 경우, 이상적으로 우리는 두 세계의 최고를 얻을 수 있습니다: 간단한 한 번의 클릭으로 기본 항아리에 추가하고 다른 사람들의 메뉴를 표시하는 유연성.

00:38:25.000 --> 00:38:30.000
올해 새로운 것은 이런 종류의 경우를 돕기 위해 메뉴의 주요 작업을 사용자 정의할 수 있는 능력이다.

00:38:30.000 --> 00:38:35.000
기본적으로, 기본 동작이 있는 메뉴는 macOS에서 두 개의 세그먼트 모양을 가지고 있다.

00:38:35.000 --> 00:38:40.000
버튼의 주요 부분은 메뉴를 표시하는 표시기의 주요 동작을 트리거합니다.

00:38:40.000 --> 00:38:47.000
그리고 지표가 숨겨져 있을 때, 그것은 다시 내가 시작했지만 행동적 차이가 있는 버튼처럼 시각적으로 보인다.

00:38:47.000 --> 00:38:51.000
클릭하면 기본 동작이 트리거되고 길게 누르면 메뉴가 표시됩니다.

00:38:51.000 --> 00:38:54.000
그리고 좋은 점은 이 같은 것이 iOS에서도 작동한다는 것입니다!

00:38:54.000 --> 00:38:59.000
이제 이 메뉴들은 당신의 앱이 어떻게 사용해야 하는지에 따라 많은 유연성을 제공합니다.

00:38:59.000 --> 00:39:03.000
버튼 스타일을 얻는 컨트롤의 또 다른 새로운 예는 토글이다.

00:39:03.000 --> 00:39:09.000
이것은 탭하면 시각적으로 켜지고 꺼지고 다른 토글과 마찬가지로 사용할 수 있는 버튼을 만듭니다.

00:39:09.000 --> 00:39:16.000
그리고 이러한 새로운 컨트롤 스타일을 결합하는 것은 관련 컨트롤을 그룹화하는 컨테이너이다; 적절하게 ControlGroup이라고 불린다.

00:39:16.000 --> 00:39:20.000
iOS에서, 그룹의 컨트롤은 도구 모음에서 조금 더 빡빡하게 구성되어 있다.

00:39:20.000 --> 00:39:26.000
그리고 macOS에는 두 개의 그룹화된 버튼을 나타내는 시각적 여유가 있다.

00:39:26.000 --> 00:39:30.000
그리고 이 모든 것을 마무리하기 위해, 자연스럽게 이 모든 것들이 함께 구성될 수 있다.

00:39:30.000 --> 00:39:35.000
예를 들어, 이러한 표준 뒤로/앞으로 버튼은 두 개의 메뉴로 구성된 ControlGroup입니다.

00:39:35.000 --> 00:39:39.000
이 메뉴들 각각에는 클릭할 때 수행되는 기본 액션이 있습니다.

00:39:39.000 --> 00:39:44.000
그리고 일단 메뉴가 오래 눌러지면, 그들은 그들의 내용물을 제시할 것이다.

00:39:44.000 --> 00:39:53.000
이제 버튼과 이러한 새로운 스타일에 대한 몇 가지 추가 사용자 지정만으로 앱에서 이러한 컨트롤을 사용할 수 있는 방법에 대한 많은 유연성이 생겼습니다.

00:39:53.000 --> 00:39:57.000
우리는 이 세션에서 많은 것을 겪었고, 우리가 다룰 시간이 없었던 것이 훨씬 더 많다.

00:39:57.000 --> 00:40:04.000
우리는 당신이 자신의 SwiftUI 앱에서 이러한 새로운 기능을 활용하고 더 많은 곳에서 SwiftUI를 채택하게 되어 기쁩니다.

00:40:04.000 --> 00:40:07.000
고마워 그리고 남은 2021년 잘 보내!

00:40:07.000 --> 23:59:59.000
♪

