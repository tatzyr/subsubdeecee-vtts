WEBVTT

00:00:02.000 --> 00:00:10.000
안녕.

00:00:10.000 --> 00:00:14.000
저는 여기 애플의 코어 데이터 팀의 엔지니어인 닉 길렛입니다.

00:00:14.000 --> 00:00:23.000
이 세션에서는 NSPersistentCloudKitContainer를 사용하여 여러 iCloud 사용자와 데이터를 공유하는 애플리케이션을 쉽게 구축하는 방법을 보여드리겠습니다.

00:00:23.000 --> 00:00:32.000
먼저, 우리는 NSPersistentCloudKitContainer와의 공유가 무엇을 의미하는지, 그리고 그것이 당신이 구축할 수 있는 경험의 유형에 어떤 영향을 미치는지에 대해 논의할 것입니다.

00:00:32.000 --> 00:00:37.000
다음으로, 우리는 공유의 메커니즘에 대해 자세히 알아볼 것이다.

00:00:37.000 --> 00:00:46.000
그리고 마지막으로, 우리는 NSPersistentCloudKitContainer가 iCloud에 저장된 민감한 데이터를 추가로 보호하는 데 어떻게 도움이 될 수 있는지에 대해 간략하게 논의할 것입니다.

00:00:46.000 --> 00:00:50.000
공유를 시작합시다.

00:00:50.000 --> 00:00:56.000
토론을 위해, 내가 이 사진을 내 친구들과 공유하고 싶다고 상상해 보자.

00:00:56.000 --> 00:00:57.000
내가 그걸 어떻게 할 수 있을까?

00:00:57.000 --> 00:01:03.000
Apple 플랫폼에서는 애플리케이션이 생성하는 데이터를 공유할 수 있는 여러 가지 방법이 있습니다.

00:01:03.000 --> 00:01:10.000
사진은 왼쪽 하단에 액션 시트를 호출할 수 있는 시스템 컨트롤을 구현합니다.

00:01:10.000 --> 00:01:16.000
그것은 공유할 수 있는 여러 가지 방법을 포함하여 내가 취할 수 있는 다양한 행동이 있다.

00:01:16.000 --> 00:01:22.000
예를 들어, 나는 그것을 내 친구들에게 iMessage나 이메일로 보낼 수 있다.

00:01:22.000 --> 00:01:31.000
하지만 이상적으로, 우리는 내 친구들과 내가 서로 사진을 공유할 수 있는 사진 앱에서 직접 한 곳을 가질 것이다.

00:01:31.000 --> 00:01:38.000
iCloud에 로그인하면, 사진은 공유를 위한 또 다른 옵션을 지원합니다: 공유 앨범.

00:01:38.000 --> 00:01:46.000
사진 공유 앨범은 다른 사용자가 볼 수 있고 원하는 경우 기여할 수 있는 공유 이미지 컬렉션을 만듭니다.

00:01:46.000 --> 00:01:53.000
나는 단순히 새 앨범에 제목을 부여한 다음 다음을 탭하여 참가자 세트를 선택합니다.

00:01:53.000 --> 00:01:56.000
여기서 나는 그 사진을 공유할 네 명의 친구를 선택했다.

00:01:56.000 --> 00:02:05.000
헤더, 저메인, 퍼시, 메리는 모두 내가 공유 기능을 구축할 때 정기적으로 사용하는 테스트 계정이다.

00:02:05.000 --> 00:02:10.000
다음을 탭하면, 내가 공유한 사진과 함께 새 앨범을 볼 수 있다.

00:02:10.000 --> 00:02:17.000
사진은 또한 오른쪽 상단에 있는 이 사람 아이콘을 탭하여 앨범의 참가자를 볼 수 있게 해준다.

00:02:17.000 --> 00:02:21.000
참가자 세트를 불러오는 탭하기.

00:02:21.000 --> 00:02:27.000
여기서 나는 그들의 초대 상태와 공유 앨범의 일부 권한을 볼 수 있다.

00:02:27.000 --> 00:02:30.000
우리가 어떻게 이런 경험을 쌓을 수 있을까?

00:02:30.000 --> 00:02:35.000
그리고 더 중요한 것은, 그러한 경험이 우리가 만드는 애플리케이션을 어떻게 바꿀 수 있을까요?

00:02:35.000 --> 00:02:37.000
음, 내가 보여줄게.

00:02:37.000 --> 00:02:47.000
공유가 NSPersistentCloudKitContainer와 어떻게 작동하는지 보여주기 위해, 저는 핵심 데이터 저장소를 클라우드와 동기화하는 샘플 애플리케이션을 사용할 것입니다.

00:02:47.000 --> 00:02:51.000
다른 iCloud 사용자와 게시물을 공유할 수 있도록 이미 수정했습니다.

00:02:51.000 --> 00:03:00.000
그리고 여기 테이블 위에, 나는 작은 장치 풀을 가지고 있으며, 각각 헤더, 저메인 또는 메리의 iCloud 계정에 로그인했다.

00:03:00.000 --> 00:03:09.000
저메인의 장치에서 애플리케이션을 실행하고 오른쪽 상단 모서리에 있는 이 더하기(+) 기호를 탭하여 새 게시물을 만드는 것으로 시작할 것입니다.

00:03:09.000 --> 00:03:17.000
간단한 제목을 줄게-- "공유 데모는 훌륭해"-- 그리고 완료를 탭해.

00:03:17.000 --> 00:03:22.000
그리고 나서 공유 컨트롤러를 불러올 수 있도록 추가한 이 새로운 액션 버튼을 탭하겠습니다.

00:03:22.000 --> 00:03:26.000
나는 각 사람에게 이메일을 통해 나와 함께 이 게시물에 대한 초대장을 보내고 싶다.

00:03:26.000 --> 00:03:31.000
그래서 나는 메일을 탭한 다음 내 친구들을 위한 정보를 입력할 것이다.

00:03:31.000 --> 00:03:36.000
나는 이미 헤더와 메리를 내 주소록에 저장했어, 그래서 그들은 쉽게 찾을 수 있어.

00:03:36.000 --> 00:03:40.000
마지막으로, 이메일을 보내기 위해 보내기를 탭하겠습니다.

00:03:40.000 --> 00:03:48.000
이제 헤더의 장치에서 메일을 열고 내가 보낸 이메일 안의 링크를 탭하면 내 신청서가 열립니다.

00:03:48.000 --> 00:03:59.000
잠시 기다린 후, 내가 저메인의 장치에서 만든 게시물은 이제 이 장치에서 볼 수 있다.

00:03:59.000 --> 00:04:07.000
메리의 장치에서, 나는 메일을 열고 내가 보낸 이메일 안에 있는 링크를 탭하면 내 신청서가 열린다.

00:04:07.000 --> 00:04:14.000
잠시 기다린 후, 내가 저메인의 장치에서 만든 게시물은 이제 이 장치에서도 볼 수 있다.

00:04:14.000 --> 00:04:16.000
하지만 이 모든 것이 어떻게 작동하나요?

00:04:16.000 --> 00:04:20.000
그리고 샘플 신청서에서 정확히 얼마를 변경해야 했나요?

00:04:20.000 --> 00:04:23.000
대답은, "별로"이다.

00:04:23.000 --> 00:04:29.000
공유는 우리가 NSPersistentCloudKitContainer에 구축한 가장 복잡한 기능입니다.

00:04:29.000 --> 00:04:37.000
그것은 CloudKit의 작동 방식과 레코드와 객체에서 작동하는 방법에 대한 엄청난 양의 도메인 지식을 제공합니다.

00:04:37.000 --> 00:04:45.000
당연히, 이 도메인 지식은 우리가 NSPersistentCloudKitContainer를 위해 구축한 API에 반영됩니다.

00:04:45.000 --> 00:04:51.000
그래서 NSPersistentCloudKitContainer가 객체를 정확히 어떻게 공유하는지 살펴봅시다.

00:04:51.000 --> 00:05:00.000
간단한 데모에서, 나는 두 개의 CloudKit 데이터베이스, .private 및 .shared 데이터베이스를 사용하는 애플리케이션을 보여주었다.

00:05:00.000 --> 00:05:09.000
이들 각각은 내 애플리케이션의 영구 저장소로 미러링되며, 하나는 .private 데이터베이스 범위를 사용하고 다른 하나는 .shared 데이터베이스 범위를 사용합니다.

00:05:09.000 --> 00:05:16.000
단일 관리 객체 컨텍스트를 사용하여, 내 애플리케이션은 두 저장소 모두에서 데이터에 액세스할 수 있다.

00:05:16.000 --> 00:05:21.000
그 변화를 좀 더 자세히 살펴봅시다.

00:05:21.000 --> 00:05:30.000
내가 해야 했던 첫 번째 변화는 NSPersistentCloudKitContainer에게 .shared CloudKit 데이터베이스를 새로운 영구 저장소에 미러링하라고 말하는 것이었다.

00:05:30.000 --> 00:05:41.000
저는 CoreDataStack을 수정하고 새로운 영구 저장소 설명을 추가하여 이것을 했습니다. 여기에 다른 URL을 가진 .private 저장소의 복사본입니다.

00:05:41.000 --> 00:05:46.000
그런 다음 CloudKit 컨테이너 옵션의 databaseScope 속성을 .shared로 설정했습니다.

00:05:46.000 --> 00:05:56.000
이것은 새로운 iOS 15이며 NSPersistentCloudKitContainer가 영구 저장소를 .shared CloudKit 데이터베이스에 미러링하도록 구성할 수 있습니다.

00:05:56.000 --> 00:06:01.000
데모를 완료하기 위해, 나는 두 가지 다른 변경을 해야 했다.

00:06:01.000 --> 00:06:06.000
나는 공유를 만들기 위해 NSPersistentCloudKitContainer에 새로운 방법을 채택했다.

00:06:06.000 --> 00:06:15.000
Share(_ managedObjects: to share: completion:)는 UICloudSharingController와 직접 페어링하도록 설계된 새로운 방법입니다.

00:06:15.000 --> 00:06:21.000
저는 단순히 UICloudSharingController의 인스턴스를 인스턴스화하기 위해 버튼 동작을 추가했습니다.

00:06:21.000 --> 00:06:30.000
Share(_ managedObjects: to share: completion:)는 UICloudSharingController 워크플로우의 생성-공유 단계에서 호출되어야 합니다.

00:06:30.000 --> 00:06:40.000
그것은 공유해야 할 모든 객체를 식별하고 필요한 경우 공유를 만들기 위해 커버 아래에서 많은 작업을 수행합니다.

00:06:40.000 --> 00:06:52.000
마지막으로, NSPersistentCloudKitContainer가 제공한 결과로 UICloudSharingController의 완료 블록을 호출하여 공유 흐름을 계속할 준비가 되었음을 알려줍니다.

00:06:52.000 --> 00:06:59.000
이것은 단 몇 줄의 코드로 NSPersistentCloudKitContainer를 사용하여 객체를 공유할 수 있다는 것을 의미합니다.

00:06:59.000 --> 00:07:27.000
내가 해야 했던 마지막 변화는 공유 초대를 수락할 수 있는 것이었고, NSPersistentCloudKitContainer에서 이 새로운 방법을 사용합니다: acceptShareInvitations(메타데이터에서: persistentStore로: AppDelegeate의 애플리케이션 userDidAcceptCloudKitShare(메타데이터와 함께:) 메소드에서 이 방법을 사용하여 들어오는 공유 메타데이터를 NS

00:07:27.000 --> 00:07:38.000
이 방법은 내가 제공하는 영구 저장소와 관련된 컨테이너에서 CloudKit 서버와의 공유를 허용합니다. 여기, 내 애플리케이션의 공유 저장소입니다.

00:07:38.000 --> 00:07:46.000
공유가 수락된 후, NSPersistentCloudKitContainer는 모든 공유 객체를 로컬 저장소에 자동으로 동기화합니다.

00:07:46.000 --> 00:07:57.000
그래서 그것이 우리가 NSPersistentCloudKitContainer를 사용하여 .private 및 .shared 데이터베이스를 결합하고, 객체에 대한 공유를 만들고, 공유 초대를 수락하는 방법입니다.

00:07:57.000 --> 00:08:02.000
하지만 우리의 애플리케이션은 일반적으로 대규모 데이터 수집을 관리하도록 설계되었습니다.

00:08:02.000 --> 00:08:16.000
이 공유 데이터를 사용하는 애플리케이션을 쉽게 구축하기 위해, NSPersistentCloudKitContainer는 사용자를 위한 유익한 사용자 인터페이스를 구축할 수 있도록 이러한 모든 객체를 이해하는 데 도움을 줄 수 있습니다.

00:08:16.000 --> 00:08:24.000
이러한 도전을 좀 더 명확하게 이해하기 위해, 우리는 공유를 위한 두 가지 중요한 개념을 식별해야 한다.

00:08:24.000 --> 00:08:28.000
첫 번째는 일련의 배우들의 개념이다.

00:08:28.000 --> 00:08:31.000
우리는 그들을 주인과 참가자들이라고 부른다.

00:08:31.000 --> 00:08:35.000
소유자는 실제로 객체를 소유한 iCloud 계정이다.

00:08:35.000 --> 00:08:40.000
소유자는 일련의 참가자와 객체를 만들고 공유한다.

00:08:40.000 --> 00:08:47.000
참가자는 어떤 식으로든 해당 개체에서 작동할 수 있는 다른 iCloud 계정입니다.

00:08:47.000 --> 00:09:05.000
참가자들은 특정 객체 집합에 대해 어떻게 행동할 수 있는지를 제한하는 다양한 역할과 권한을 가질 수 있으며, 이는 NSPersistentCloudKitContainer와 CloudKit이 이러한 공유 객체를 구성하는 방법이라는 두 번째 핵심 개념으로 우리를 안내합니다.

00:09:05.000 --> 00:09:10.000
핵심 데이터에서, 우리는 NSManagedObject의 관점에서 객체를 생각한다.

00:09:10.000 --> 00:09:19.000
NSPersistentCloudKitContainer는 관리되는 객체를 CloudKit에 저장된 CKRecord의 인스턴스로 바꿉니다.

00:09:19.000 --> 00:09:29.000
이전에 공유로 작업한 적이 있다면, 이러한 레코드가 공유라고 불리는 루트 레코드와 관련된 계층적 공유에 익숙할 것입니다.

00:09:29.000 --> 00:09:33.000
하지만 이것은 NSPersistentCloudKitContainer가 작동하는 방식이 아닙니다.

00:09:33.000 --> 00:09:44.000
NSPersistentCloudKitContainer는 Record Zone Sharing이라는 CloudKit의 새로운 기능을 사용하며, "CloudKit의 새로운 기능" 세션에서 더 자세히 다룹니다.

00:09:44.000 --> 00:09:53.000
하지만 NSPersistentCloudKitContainer가 Record Zone Sharing을 사용하여 관리되는 객체를 공유하는 방법을 살펴봅시다.

00:09:53.000 --> 00:10:04.000
CloudKit 데이터베이스에서-- 예를 들어, .private 데이터베이스-- NSPersistentCloudKitContainer는 일반적으로 애플리케이션이 생성하는 객체를 저장하기 위해 개인 영역을 관리합니다.

00:10:04.000 --> 00:10:11.000
레코드 영역 공유에서 공유 CKRecords는 공유 CKRecordZone 안에 포함되어 있습니다.

00:10:11.000 --> 00:10:17.000
공유 레코드 영역은 단일 CKShare 레코드의 존재로 식별됩니다.

00:10:17.000 --> 00:10:29.000
계층적 공유와 마찬가지로, 이 기록에는 소유자, 참가자, 권한 및 역할과 같은 영역과 함께 작업하는 데 필요한 모든 정보가 포함되어 있습니다.

00:10:29.000 --> 00:10:35.000
NSPersistentCloudKitContainer는 이러한 영역을 관리하고 자동으로 레코드를 할당합니다.

00:10:35.000 --> 00:10:47.000
루트 레코드가 없기 때문에, NSPersistentCloudKitContainer는 또한 소유자와 참가자의 개념이 전체 레코드 영역에 어떻게 적용되는지 이해해야 합니다.

00:10:47.000 --> 00:10:52.000
내가 공유하고 싶은 사람들의 모임이 있다고 상상해 봅시다.

00:10:52.000 --> 00:11:02.000
다른 사람과 공유하는 것은 흥미롭지만, NSPersistentCloudKitContainer는 훨씬 더 많은 인구를 위한 공유를 용이하게 하도록 설계되었습니다.

00:11:02.000 --> 00:11:08.000
이 참가자들 각각은 내가 그들과 공유하는 물건에 접근하고 조작할 수 있을 것이다.

00:11:08.000 --> 00:11:14.000
그리고 나는 그들이 나와 공유하는 물건에 접근하고 조작할 수 있을 것이다.

00:11:14.000 --> 00:11:19.000
각 참가자는 또한 그들만의 장치 컬렉션을 갖게 될 것이다.

00:11:19.000 --> 00:11:26.000
NSPersistentCloudKitContainer를 사용하면 애플리케이션은 모든 Apple 장치의 공유 객체에서 작동할 수 있습니다.

00:11:26.000 --> 00:11:37.000
각 참가자에 대해 NSPersistentCloudKitContainer는 두 개의 CloudKit 데이터베이스, .private 및 .shared 데이터베이스의 객체를 관리합니다.

00:11:37.000 --> 00:11:45.000
내 .private 데이터베이스에서, 나는 그 영역이 공유되는지 여부에 관계없이 내가 소유한 기록과 영역을 볼 것이다.

00:11:45.000 --> 00:11:50.000
예를 들어, NSPersistentCloudKitContainer가 관리하는 영역.

00:11:50.000 --> 00:12:03.000
공유를 통해, NSPersistentCloudKitContainer는 또한 내가 소유한 이러한 영역에 액세스할 수 있는 사람을 제어하는 CKShare 레코드로 공유 영역을 만들 것입니다.

00:12:03.000 --> 00:12:11.000
나 그리고, 허용된다면, 다른 참가자들은 이 공유 구역에서 기록을 추가하고 수정할 수 있다.

00:12:11.000 --> 00:12:17.000
내 .shared 데이터베이스에서, 나는 다른 사용자들이 나와 공유한 레코드 영역을 볼 수 있을 것이다.

00:12:17.000 --> 00:12:27.000
내가 할 수 있다면, 내가 소유한 구역에서 할 수 있는 것처럼 내가 소유한 기록을 그 구역에 추가할 수 있다.

00:12:27.000 --> 00:12:37.000
다른 사용자는 해당 영역의 소유자인지 여부에 따라 .private 및 .shared 데이터베이스에서 다른 일련의 영역을 볼 수 있습니다.

00:12:37.000 --> 00:12:45.000
예를 들어, 이 사용자는 .private 데이터베이스에서 소유한 개인 영역과 공유 영역을 가질 수 있습니다.

00:12:45.000 --> 00:12:56.000
게다가, 그들은 내가 그들과 공유하는 두 구역과 그들이 .shared 데이터베이스에 참여하는 다른 구역을 보게 될 것이다.

00:12:56.000 --> 00:13:02.000
그렇다면 NSPersistentCloudKitContainer는 당신의 기록을 어디에 보관해야 하는지 어떻게 알 수 있나요?

00:13:02.000 --> 00:13:09.000
많은 경우에, 그것은 다른 물체와의 관계에 따라 기록이 어디에 속하는지 추론할 수 있다.

00:13:09.000 --> 00:13:20.000
하지만 share(_ managedObjects: to share: completion:)에게 nil이 아닌 CKShare를 전달하여 특정 공유 영역에 객체를 저장하도록 말할 수도 있습니다.

00:13:20.000 --> 00:13:32.000
예를 들어, 기존 공유를 사용하도록 이 코드 줄을 변경하면, NSPersistentCloudKitContainer는 제공된 포스트 객체를 해당 공유에 할당하려고 시도할 것입니다.

00:13:32.000 --> 00:13:45.000
이것들은 내가 첫 번째 데모를 위해 만들어야 했던 모든 변화이지만, 내 애플리케이션은 또한 어떤 객체가 공유되는지, 누구와 공유되는지, 그리고 참가자들이 무엇을 할 수 있는지 효과적으로 전달해야 한다.

00:13:45.000 --> 00:13:53.000
우리 사용자들은 그들이 공유하기로 선택한 물건에 대해 좋은 결정을 내릴 수 있도록 그 모든 정보가 필요하다.

00:13:53.000 --> 00:13:58.000
그래서 제가 이러한 상태와 특권을 전달하기 위해 애플리케이션을 어떻게 변경했는지 살펴봅시다.

00:13:58.000 --> 00:14:08.000
샘플 애플리케이션으로 돌아가서, 첫 번째 데모의 데이터가 이제 게시물이 공유되었음을 나타내는 새로운 사용자 인터페이스 장식과 함께 표시되는 것을 볼 수 있습니다.

00:14:08.000 --> 00:14:18.000
탭하면 역할, 권한 및 수락 상태와 함께 세부 보기 컨트롤러 하단에 표시된 참가자를 볼 수 있습니다.

00:14:18.000 --> 00:14:25.000
우리는 여기서 저메인이 게시물이 포함된 주식의 소유자이고 헤더가 개인 참가자라는 것을 알 수 있다.

00:14:25.000 --> 00:14:37.000
이제 새 게시물을 추가하고, 제목을 지정하고, 완료를 탭할 것입니다.

00:14:37.000 --> 00:14:48.000
공유 컨트롤러를 불러오기 위해 액션 버튼을 탭할 것이지만, 이번에는 참가자들이 공유 내용을 편집하거나 수정할 수 없도록 공유를 읽기 전용으로 하고 싶습니다.

00:14:48.000 --> 00:14:52.000
그래서 나는 공유를 보기 전용으로 표시하기 위해 공유 옵션을 변경할 것이다.

00:14:52.000 --> 00:14:59.000
다음으로, 나는 메일을 탭하고 저메인과 메리를 초대할 것이다.

00:14:59.000 --> 00:15:03.000
마지막으로, 내가 이메일을 보낼게.

00:15:03.000 --> 00:15:08.000
메리의 장치에서, 나는 새로운 공유를 받아들일 것이고, 이제 새로운 게시물을 볼 수 있다.

00:15:08.000 --> 00:15:18.000
내가 그것을 탭하면, 편집 버튼이 비활성화되어 있고 Mary의 참가자 항목이 그녀가 공유의 읽기 전용 참가자임을 보여주는 것을 볼 수 있다.

00:15:18.000 --> 00:15:30.000
마찬가지로, 이 게시물을 삭제하기 위해 스와이프할 수 없으며, 편집 버튼을 눌러 테이블 뷰를 편집 모드로 전환하면 이 게시물을 삭제할 수 없습니다.

00:15:30.000 --> 00:15:37.000
지금 저메인의 장치에서, 나는 새로운 몫을 받아들일 것이다.

00:15:37.000 --> 00:15:42.000
그리고 이제 나는 새로운 게시물을 볼 수 있다.

00:15:42.000 --> 00:15:56.000
그것을 탭하면, 편집 버튼이 비활성화되어 있고 Jermaine의 참가자 항목은 그가 공유의 읽기 전용 참가자임을 보여줍니다.

00:15:56.000 --> 00:16:05.000
이 겸손한 샘플 응용 프로그램에서도, 나는 공유 객체에 대한 정보를 제공하기 위해 사용자 인터페이스를 여러 번 변경해야 했다.

00:16:05.000 --> 00:16:10.000
나는 어떤 것이 공유되고 있는지 나타내기 위해 포스트 테이블 셀을 장식해야 했다.

00:16:10.000 --> 00:16:19.000
또한 현재 사용자 참가자에게 할당된 권한에 따라 편집 컨트롤을 활성화하거나 비활성화하기 위한 로직을 추가해야 했습니다.

00:16:19.000 --> 00:16:28.000
그리고 마지막으로, 나는 개별 공유에 참가자에 대한 정보를 표시하기 위해 새로운 사용자 인터페이스 요소를 구축해야 했다.

00:16:28.000 --> 00:16:35.000
이 모든 작업은 특정 게시물이 있는 CKShare에 대한 메타데이터에 액세스해야 했다.

00:16:35.000 --> 00:16:42.000
NSPersistentCloudKitContainer에는 이러한 각 관심사에 부합하는 다양한 API 방법이 포함되어 있습니다.

00:16:42.000 --> 00:16:50.000
fetchShares(matching objectIDs:)는 iOS 15의 새로운 기능이며 특정 게시물에 대한 CKShare를 얻을 수 있습니다.

00:16:50.000 --> 00:17:00.000
하지만 편집을 조건화하기 위한 이 세 가지 방법은 2020년 WWDC에서 .public 데이터베이스 지원과 함께 도입되었습니다.

00:17:00.000 --> 00:17:05.000
사용자 인터페이스를 사용자 정의해야 하는 곳 어디에서나 응용 프로그램에서 이러한 방법을 사용할 수 있습니다.

00:17:05.000 --> 00:17:10.000
하지만 내 지원서에서, 나는 약간 다른 접근 방식을 취했다.

00:17:10.000 --> 00:17:21.000
NSPersistentCloudKitContainer에서 직접 메서드를 호출하는 대신, 필요한 각 사용자 지정에 대한 특정 메서드를 노출하는 프로토콜을 구축했습니다.

00:17:21.000 --> 00:17:23.000
그것은 SharingProvider라고 불린다.

00:17:23.000 --> 00:17:29.000
SharingProvider는 내 애플리케이션의 특정 통화 사이트에 직접 바인딩하는 방법을 가지고 있다.

00:17:29.000 --> 00:17:34.000
예를 들어, 나는 객체가 공유되는지 아닌지를 알아야 할 수도 있다.

00:17:34.000 --> 00:17:44.000
공유되는 경우, 사용자 인터페이스에 더 많은 정보를 표시하기 위해 CKShare 또는 참가자를 가져와야 할 수도 있습니다.

00:17:44.000 --> 00:17:52.000
마지막으로, 객체가 항상 변경 가능한 것은 아니며 개별 참가자는 동일한 객체에 대해 다른 권한을 가질 수 있습니다.

00:17:52.000 --> 00:17:58.000
이 프로토콜은 내 애플리케이션 코드에 특정 논리를 쉽게 추가할 수 있게 해준다.

00:17:58.000 --> 00:18:05.000
그리고 객체가 공유되는지 여부를 알아야 하는 MainViewController의 특정 통화 사이트를 보여주고 싶습니다.

00:18:05.000 --> 00:18:18.000
여기서 저는 isShared를 사용하여 게시물의 제목을 속성 문자열로 변환할지 여부를 결정하고 게시물이 공유의 일부임을 보여주기 위해 person.circle 기호로 접두사를 붙입니다.

00:18:18.000 --> 00:18:26.000
이와 같은 사용자 지정은 내가 공유를 지원하지 않기로 선택한 것보다 반드시 더 복잡한 코드가 필요하다.

00:18:26.000 --> 00:18:38.000
이러한 사용자 지정 중 몇 가지를 추가한 후, 모든 것이 올바르게 작동하는지 확인할 수 있는 방법이 필요하다는 것이 분명해졌고, 이는 SharingProvider가 존재하는 주된 이유인 테스트입니다.

00:18:38.000 --> 00:18:44.000
SharingProvider 프로토콜을 사용하면 주입으로 이러한 결정 지점을 쉽게 테스트할 수 있습니다.

00:18:44.000 --> 00:18:54.000
이 코드 스니펫은 테이블 셀이 게시물이 공유되는지 올바르게 나타내도록 하기 위해 MainViewController를 위해 작성한 테스트 케이스의 일부입니다.

00:18:54.000 --> 00:19:08.000
나는 샘플 데이터를 만들기 위한 비계를 중단했지만, 테스트는 이 세트에서 객체 ID의 존재에 의해 공유되거나 공유되지 않은 것으로 식별하는 관리 객체의 혼합 세트를 만든다.

00:19:08.000 --> 00:19:23.000
다음으로, 테스트를 위해 특별히 작성된 클래스인 BlockBasedShareProvider의 인스턴스를 구성하여 MainViewController가 사용하는 sharingProvider에 사용자 지정 논리를 사소하게 주입할 수 있습니다.

00:19:23.000 --> 00:19:30.000
여기서 저는 제가 만든 세트의 포함 메소드를 호출하도록 isSharedBlock을 설정하고 있습니다.

00:19:30.000 --> 00:19:38.000
이것은 제공된 objectID가 sharedObjectIDs에 있는지 간단히 확인할 수 있는 Swift의 귀여운 트릭입니다.

00:19:38.000 --> 00:19:45.000
그런 다음 BlockBasedProvider를 뷰 컨트롤러의 공급자로 설정하여 주입을 완료했습니다.

00:19:45.000 --> 00:20:02.000
마지막으로, 이 테스트는 MainViewController에게 테이블 셀을 요청하여 공유 객체 ID 세트에 포함시킨 셀이 예상되는 접두사를 가지고 있고 공유되지 않은 객체에 해당하는 셀이 없는지 확인합니다.

00:20:02.000 --> 00:20:10.000
isShared의 실제 구현은 내 애플리케이션의 지속적인 CloudKit 컨테이너를 관리하는 CoreDataStack에 있습니다.

00:20:10.000 --> 00:20:16.000
그리고 당신은 그것이 내가 테스트에서 사용한 간단한 주입보다 조금 더 복잡하다는 것을 알 수 있습니다.

00:20:16.000 --> 00:20:22.000
이제, 나는 이 구현을 한 줄씩 살펴볼 수 있지만, 그것은 여기서 중요한 것이 아니다.

00:20:22.000 --> 00:20:36.000
중요한 것은 테이블 뷰의 변경 사항을 확인하고 싶을 때마다 쉽게 운동할 수 있는 것보다 훨씬 더 복잡하다는 것이며, 그렇게 하려고 하면 개발 과정에 많은 마찰이 추가될 것이다.

00:20:36.000 --> 00:20:47.000
반면에, 이 주입 기술을 사용하면 CloudKit 서버와 대화하지 않고도 공유 객체의 다양한 구성을 쉽고 빠르게 테스트할 수 있습니다.

00:20:47.000 --> 00:21:01.000
이러한 모든 테스트를 작성하고 이러한 유형의 주입을 용이하게 하는 방식으로 응용 프로그램을 구성하는 것은 조금 더 많은 코드이지만, 그 결과의 자신감과 신뢰성은 그만한 가치가 있습니다.

00:21:01.000 --> 00:21:15.000
제가 언급했듯이, SharingProvider에는 샘플 응용 프로그램에 대한 다른 많은 중요한 방법이 포함되어 있으며, 구현과 사용자 인터페이스에 어떤 영향을 미치는지에 대해 제가 작성한 테스트를 확인하는 것이 좋습니다.

00:21:15.000 --> 00:21:25.000
대체로, 저는 1200줄이 조금 넘는 테스트 코드를 추가했고, 이 예들이 당신이 자신의 응용 프로그램에서 테스트를 정말 쉽게 만들 수 있기를 바랍니다.

00:21:25.000 --> 00:21:35.000
오늘 다루고 싶은 마지막 주제는 CloudKit의 또 다른 새로운 기능인 암호화된 CKRecord 값에 대한 지원입니다.

00:21:35.000 --> 00:21:44.000
이러한 값은 "CloudKit의 새로운 기능" 세션에 도입된 encryptedValues라는 CKRecord의 새로운 페이로드에 저장됩니다.

00:21:44.000 --> 00:21:51.000
CKRecord의 이 새로운 페이로드를 사용하면 사용자 키체인의 키 자료를 사용하여 값을 암호화할 수 있습니다.

00:21:51.000 --> 00:22:03.000
이러한 값은 CloudKit 서버에서 다운로드한 후 장치에서 로컬로 해독되며, CloudKit 서버에 업로드되기 전에 장치에서 로컬로 암호화됩니다.

00:22:03.000 --> 00:22:09.000
우리는 Xcode에서 단 한 번의 클릭으로 암호화된 값을 채택할 수 있게 했습니다.

00:22:09.000 --> 00:22:13.000
그게 실제로 실행되는지 보자.

00:22:13.000 --> 00:22:19.000
여기 Xcode에서 핵심 데이터 저장소를 클라우드와 동기화하는 샘플 애플리케이션을 열었습니다.

00:22:19.000 --> 00:22:29.000
CoreDataCloudKitDemo 관리 객체 모델을 열면, 위치라고 불리는 포스트 엔티티에 특정 속성을 보여주고 싶습니다.

00:22:29.000 --> 00:22:36.000
위치 속성을 선택하면, 오른쪽의 데이터 모델 검사기에서 구성을 볼 수 있습니다.

00:22:36.000 --> 00:22:44.000
나는 그것을 선택적인 Transformable 속성으로 구성했고 이 새로운 클라우드 암호화 허용 확인란을 선택했다.

00:22:44.000 --> 00:22:55.000
이 새로운 체크박스는 NSPersistentCloudKitContainer에게 이 속성의 값이 결과 CKRecord의 encryptedValues 페이로드에 저장되어야 한다고 알려줍니다.

00:22:55.000 --> 00:23:07.000
매트릭스를 코드로 읽는 것을 선호한다면, 모델 코드에서 이 속성을 구성하는 데 사용할 수 있는 NSAttributeDescription에 새로운 부울-- allowsCloudEncryption--이 있습니다.

00:23:07.000 --> 00:23:13.000
이제, CloudKit을 사용한 암호화는 도입 시점의 결정이다.

00:23:13.000 --> 00:23:20.000
그것은 우리가 나중에 마음을 바꿀 수 없고 오늘날 생산에서 이미 암호화되지 않은 필드를 암호화하도록 선택할 수 없다는 것을 의미합니다.

00:23:20.000 --> 00:23:26.000
마찬가지로, 이미 암호화된 필드를 암호화 해제하도록 선택할 수 없습니다.

00:23:26.000 --> 00:23:32.000
CloudKit 스키마가 프로덕션으로 푸시되면, 필드 유형을 변경할 수 없습니다.

00:23:32.000 --> 00:23:44.000
따라서 NSPersistentCloudKitContainer의 initializeSchema 방법을 사용하여 스키마를 프로덕션에 배포하기 전에 모든 필드가 존재하고 올바르게 입력되었는지 확인하십시오.

00:23:44.000 --> 00:23:52.000
공유를 지원하기 위해 NSPersistentCloudKitContainer에 변경한 몇 가지를 소개하게 되어 기쁩니다.

00:23:52.000 --> 00:23:54.000
배워야 할 새로운 API가 많이 있다.

00:23:54.000 --> 00:24:11.000
그래서 우리는 CloudKit으로 작업할 때 애플리케이션이 다른 상태 객체에 어떻게 반응하는지 확인하기 위해 테스트를 작성하는 방법을 포함하여 자신의 애플리케이션에서 사용할 수 있는 방법을 보여주기 위해 샘플 애플리케이션과 문서를 업데이트했습니다.

00:24:11.000 --> 00:24:17.000
그리고 피드백 어시스턴트에 버그를 제출하여 문제가 발생하면 저희에게 알려주세요.

00:24:17.000 --> 00:24:22.000
언제나처럼, 저는 당신이 NSPersistentCloudKitContainer로 무엇을 만드는지 빨리 보고 싶습니다.

00:24:22.000 --> 00:24:28.000
활동적인 상태를 유지하고, 반지를 닫고, 멋진 WWDC 2021을 보내세요.

00:24:28.000 --> 23:59:59.000
[음악].

