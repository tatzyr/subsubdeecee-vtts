WEBVTT

00:00:00.000 --> 00:00:05.000
♪ 베이스 음악 연주 ♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:17.000
Liu Sihui: 안녕하세요. "고급 웹 콘텐츠 개발"에 오신 것을 환영합니다. 저는 Sihui이고, Safari와 WebKit 팀의 엔지니어입니다.

00:00:17.000 --> 00:00:23.000
지난 한 해 동안 웹 개발자를 위해 WebKit과 Safari에서 만든 중요한 업데이트를 공유하게 되어 기쁩니다.

00:00:23.000 --> 00:00:28.000
내가 공유하려는 것들은 일반적으로 세 가지 범주로 나뉜다.

00:00:28.000 --> 00:00:33.000
먼저, 자바스크립트의 새로운 기능과 개선 사항을 안내해 드리겠습니다.

00:00:33.000 --> 00:00:39.000
그런 다음 웹어셈블리의 업데이트에 대한 개요를 알려드리겠습니다.

00:00:39.000 --> 00:00:47.000
그리고 마지막으로, 웹 콘텐츠에 추가 기능을 추가할 수 있는 새로운 웹 API를 소개하겠습니다.

00:00:47.000 --> 00:00:51.000
다루어야 할 것이 많으니, 자바스크립트로 우리의 뉴스부터 시작합시다.

00:00:51.000 --> 00:00:56.000
매년, 우리의 자바스크립트 엔진에는 수백 가지의 변화가 있다.

00:00:56.000 --> 00:01:02.000
자바스크립트로 작업할 때 알아야 할 가장 중요한 것들 중 일부를 다룰 것입니다.

00:01:02.000 --> 00:01:25.000
그것들은 다음과 같습니다: 새로운 클래스 필드 구문, 더 스마트한 메모리 관리를 가능하게 하는 약한 참조, await 키워드의 새로운 사용, 작업자의 모듈 지원, 국제화 API 제품군에 추가된 인터페이스.

00:01:25.000 --> 00:01:31.000
이 새로운 기능의 그림에 당신을 넣기 위해, 저는 간단한 스톱워치를 예로 사용할 것입니다.

00:01:31.000 --> 00:01:34.000
스톱워치에는 버튼이 하나밖에 없다.

00:01:34.000 --> 00:01:36.000
한 번 클릭하면, 계산이 시작됩니다.

00:01:36.000 --> 00:01:40.000
다시 클릭하면 중지되고 지난 기간을 제공합니다.

00:01:40.000 --> 00:01:46.000
이것을 명심하면 나중에 자바스크립트에서 구현할 것입니다.

00:01:46.000 --> 00:01:49.000
이제, 새로운 클래스 필드 구문을 살펴봅시다.

00:01:49.000 --> 00:01:59.000
액세스가 언어로 보호되는 실제 개인 구성원을 정의할 수 있는 새로운 개인 클래스 필드와 방법이 있습니다.

00:01:59.000 --> 00:02:02.000
액세스 규칙을 어기면 오류가 발생할 것입니다.

00:02:02.000 --> 00:02:12.000
우리는 또한 클래스의 인스턴스를 만들지 않고도 액세스할 수 있는 클래스 멤버를 선언할 수 있는 정적 필드에 대한 지원을 추가합니다.

00:02:12.000 --> 00:02:15.000
이제 당신은 기본적인 아이디어를 가지고 있습니다.

00:02:15.000 --> 00:02:19.000
스톱워치 예제와 함께 어떻게 사용할 수 있는지 확인해 봅시다.

00:02:19.000 --> 00:02:26.000
스톱워치 클래스를 구현하라는 요청을 받으면, 구현은 다음과 같이 보일 수 있습니다.

00:02:26.000 --> 00:02:30.000
StopwatchWithOneButton에는 click()이라는 하나의 방법만 있습니다.

00:02:30.000 --> 00:02:33.000
그것은 startTime 변수를 확인합니다.

00:02:33.000 --> 00:02:39.000
시작 시간이 설정되지 않은 경우, 클릭은 시작을 의미하므로 시작 시간을 설정합니다.

00:02:39.000 --> 00:02:47.000
시작 시간이 이미 설정되어 있다면, 클릭은 멈추는 것을 의미하므로, 기간을 계산하고 시작 시간을 재설정합니다.

00:02:47.000 --> 00:02:51.000
startTime은 밑줄 접두사와 함께 제공되는 것을 볼 수 있습니다.

00:02:51.000 --> 00:02:58.000
이것은 변수가 클래스 내에서만 사용되어야 한다는 것을 나타내기 위해 일반적으로 사용되는 명명 규칙이다.

00:02:58.000 --> 00:03:03.000
하지만 그것은 실제로 시작 시간이 공개적으로 접근되는 것을 막지는 않는다.

00:03:03.000 --> 00:03:06.000
새로운 개인 구문은 이것을 고치는 데 도움이 될 수 있다.

00:03:06.000 --> 00:03:11.000
밑줄을 해시로 바꾸면 실제 개인 인스턴스 필드를 선언할 수 있습니다.

00:03:11.000 --> 00:03:15.000
캡슐화는 언어에 의해 시행된다.

00:03:15.000 --> 00:03:18.000
사적인 방법에 대한 지원도 있다.

00:03:18.000 --> 00:03:30.000
예를 들어, click() 메서드를 더 구조화하기 위해, 우리는 다음과 같이 강조 표시된 콘텐츠를 대체하기 위해 두 개의 개인 메서드 start()와 stop()를 만들 수 있습니다.

00:03:30.000 --> 00:03:39.000
메서드에 해시 접두사를 추가함으로써, 우리는 멤버 함수가 클래스 내부에서만 접근할 수 있도록 합니다.

00:03:39.000 --> 00:03:45.000
새로운 개인 구문은 startedStopwatchCount와 같은 정적 필드에도 적용됩니다.

00:03:45.000 --> 00:03:52.000
여기서, startedStopwatchCount는 시작 또는 중지 시간에 스톱워치 객체로만 수정할 수 있습니다.

00:03:52.000 --> 00:04:02.000
물론, 모든 곳에서 startedStopwatchCount에 액세스하고 싶다면, 해시 접두사 없이 공개 정적 필드로 선언할 수 있습니다.

00:04:02.000 --> 00:04:06.000
공개 정적 필드는 이제 WebKit에서도 사용할 수 있습니다.

00:04:06.000 --> 00:04:14.000
개인 인스턴스 필드, 메소드, 개인 정적 필드 및 공개 정적 필드; 그것이 우리의 새로운 클래스 필드 지원입니다.

00:04:14.000 --> 00:04:19.000
그리고 또 다른 특징, 약한 참조를 계속해 봅시다.

00:04:19.000 --> 00:04:27.000
약한 참조를 사용하면 가비지 수집을 방지하지 않는 방식으로 자바스크립트 객체에 대한 참조를 유지할 수 있습니다.

00:04:27.000 --> 00:04:35.000
WeakMap과 WeakSet과 달리, 이미 참조하지 않고도 기본 객체를 얻을 수 있습니다.

00:04:35.000 --> 00:04:43.000
지원에는 가비지 수집에 대한 알림도 포함되어 있으므로, 필요한 경우 정리 작업을 수행할 수 있습니다.

00:04:43.000 --> 00:04:45.000
그리고 그것이 어떻게 사용될 수 있는지 봅시다.

00:04:45.000 --> 00:04:48.000
우리는 방금 스톱워치 수업을 시행했다.

00:04:48.000 --> 00:04:54.000
이제 다른 작업을 위해 여러 개의 스톱워치 개체를 만들었다고 상상해 보세요.

00:04:54.000 --> 00:04:57.000
테스트를 위해, 당신은 그것들을 한 번에 모두 클릭해야 합니다.

00:04:57.000 --> 00:04:59.000
넌 그걸 어떻게 할 거야?

00:04:59.000 --> 00:05:04.000
직관적인 방법은 모든 스톱워치 인스턴스 세트를 유지하는 것이다.

00:05:04.000 --> 00:05:07.000
스톱워치가 생성되면, 세트에 추가하세요.

00:05:07.000 --> 00:05:14.000
그런 다음 clickAllStopwatches 기능에서 세트를 반복하고 각 스톱워치를 클릭하세요.

00:05:14.000 --> 00:05:17.000
하지만 이 접근 방식에는 문제가 있다.

00:05:17.000 --> 00:05:28.000
우리는 자바스크립트 객체가 기본적으로 강력한 참조를 가지고 있다는 것을 알고 있으므로, 이 경우 모든 스톱워치 객체는 세트에 여전히 참조가 있기 때문에 가비지 수집할 수 없습니다.

00:05:28.000 --> 00:05:32.000
물론, 우리는 테스트를 위해 모든 스톱워치 객체를 주변에 두고 싶지는 않습니다.

00:05:32.000 --> 00:05:36.000
이것은 메모리 사용에 좋지 않다.

00:05:36.000 --> 00:05:42.000
이제, 당신은 Set를 WeakSet로 교체하는 것을 제안할 수 있지만, WeakSet은 반복할 수 없습니다.

00:05:42.000 --> 00:05:44.000
그래서 넌 뭘 할 거야?

00:05:44.000 --> 00:05:50.000
우리는 객체에 대한 약한 참조를 보유하고 있는 새로운 인터페이스 WeakRef로 그것을 해결할 수 있다.

00:05:50.000 --> 00:05:56.000
우리는 여전히 세트를 가지고 있지만, 이번에는 스톱워치 객체의 WeakRef를 세트에 추가합니다.

00:05:56.000 --> 00:06:04.000
clickAllStopwatches 기능에서, 우리는 클릭하기 전에 객체를 역참조하여 객체가 여전히 존재하는지 확인합니다.

00:06:04.000 --> 00:06:17.000
이것은 우리의 문제를 해결하는 것 같지만, 또 다른 문제가 있습니다: 우리는 세트에서 쓰레기 수거 스톱워치를 적시에 제거하지 않으며, 다음 클릭 테스트 전에 세트가 꽤 커질 수 있습니다.

00:06:17.000 --> 00:06:21.000
이제 우리는 무엇을 해야 하나요?

00:06:21.000 --> 00:06:25.000
또 다른 새로운 인터페이스인 FinalizationRegistry는 이 경우에 도움이 될 수 있다.

00:06:25.000 --> 00:06:32.000
그것으로, 당신은 어떤 객체가 가비지 수집될 때 호출될 콜백을 지정할 수 있습니다.

00:06:32.000 --> 00:06:43.000
여기서 우리는 removeStopwatch 함수로 finalizationRegistry 객체를 만들므로, 이 함수는 객체가 수집될 때마다 호출됩니다.

00:06:43.000 --> 00:06:47.000
그런 다음, 우리는 스톱워치 객체를 레지스트리에 등록합니다.

00:06:47.000 --> 00:06:54.000
각 스톱워치는 식별자로 바인딩되므로, removeStopwatch는 어떤 스톱워치를 제거할지 알고 있습니다.

00:06:54.000 --> 00:07:00.000
좋아, 이제 쓰레기 수거된 스톱워치는 모든 스톱워치에서 제거될 것이다.

00:07:00.000 --> 00:07:05.000
약한 참고 문헌을 사용하는 것은 그렇게 어렵지 않은 것 같지 않나요?

00:07:05.000 --> 00:07:12.000
하지만 자바스크립트의 가비지 수집은 매우 복잡하고 불확실성이 많다는 점에 유의하십시오.

00:07:12.000 --> 00:07:26.000
예를 들어, 수집해야 한다고 생각하는 객체는 오랜 시간까지 실제로 수집되지 않을 수 있으며, 이벤트 루프에서 실행되기 때문에 FinalizationRegistry에서 올바른 방법으로 콜백을 받지 못할 수 있습니다.

00:07:26.000 --> 00:07:33.000
따라서, 사용하기 전에 구문과 예상되는 동작을 완전히 이해했는지 확인하세요.

00:07:33.000 --> 00:07:37.000
약한 참조에서 다음 기능으로 넘어가자, 최고 수준의 기다림.

00:07:37.000 --> 00:07:40.000
이것은 모듈의 새로운 기능이다.

00:07:40.000 --> 00:07:46.000
비동기 함수 외부에서 await 키워드를 사용할 수 있습니다.

00:07:46.000 --> 00:07:55.000
이 경우, 모듈 자체는 큰 비동기 함수와 같기 때문에, 비동기 모듈은 그것들을 가져오는 모듈의 실행을 차단할 수 있다.

00:07:55.000 --> 00:08:00.000
스톱워치 수업의 예를 보여드리겠습니다.

00:08:00.000 --> 00:08:03.000
이게 우리가 방금 만든 수업이야.

00:08:03.000 --> 00:08:09.000
최상위 대기의 사용을 설명하기 위해, 그것을 모듈로 만들고 클래스를 내보내자.

00:08:09.000 --> 00:08:13.000
이것은 인라인 모듈이 포함된 HTML 파일입니다.

00:08:13.000 --> 00:08:18.000
동적 가져오기를 사용하여 스톱워치 모듈을 가져옵니다.

00:08:18.000 --> 00:08:27.000
가져오기 함수는 약속을 반환하므로, 가져오기가 완료된 후 작업을 수행하기 위해 그 때 또는 캐치 메소드를 사용할 수 있습니다.

00:08:27.000 --> 00:08:34.000
최상위 대기를 사용하면 체인 방법을 제거하고 동기 방식으로 코드를 작성할 수 있습니다.

00:08:34.000 --> 00:08:38.000
이것은 당신의 코드를 더 쉽게 따라갈 수 있게 할 수 있습니다.

00:08:38.000 --> 00:08:48.000
또한, 가져온 모듈은 로드 시간에 평가되기 때문에, 비동기 모듈은 모듈의 실행을 차단할 수 있다.

00:08:48.000 --> 00:08:59.000
즉, 스톱워치 모듈이 비동기 작업을 실행하고 결과를 기다리는 경우, 스톱워치 모듈이 실행을 완료한 후 스톱워치 변수가 초기화됩니다.

00:08:59.000 --> 00:09:03.000
최고 수준의 대기는 의존성 관리를 더 쉽게 만들었다.

00:09:03.000 --> 00:09:14.000
하지만 다시 말하지만, 이 기능은 모듈에서만 사용할 수 있으므로, 스크립트가 모듈이 아니라면...

00:09:14.000 --> 00:09:17.000
...웹 인스펙터에서 구문 오류가 표시됩니다.

00:09:17.000 --> 00:09:22.000
모듈에 대해 말하자면, 또 다른 관련 기능이 있다: 모듈 작업자.

00:09:22.000 --> 00:09:25.000
노동자들은 잘 알려진 몇 가지 혜택을 가지고 있다.

00:09:25.000 --> 00:09:31.000
백그라운드 스레드에서 스크립트를 실행할 수 있으므로 리소스를 더 효율적으로 활용할 수 있습니다.

00:09:31.000 --> 00:09:44.000
이 새로운 지원을 통해 근로자는 이제 동적 가져오기, 최적화된 로딩 및 실행, 종속성 관리를 포함한 모듈의 이점을 공유합니다.

00:09:44.000 --> 00:09:51.000
이제 무거운 작업을 메인 스레드에서 배경 스레드로 옮기는 것이 더 유익하고 쉽습니다.

00:09:51.000 --> 00:09:58.000
모듈은 이제 웹 작업자, 서비스 작업자 및 워크렛을 포함한 다양한 유형의 작업자에서 사용할 수 있습니다.

00:09:58.000 --> 00:10:07.000
웹 작업자와 서비스 작업자를 위한 모듈 작업자를 만들려면 옵션에서 모듈이 될 유형을 지정해야 합니다.

00:10:07.000 --> 00:10:12.000
오디오 워크렛과 같은 워크렛의 경우, addModule 기능을 사용할 수 있습니다.

00:10:12.000 --> 00:10:18.000
애플리케이션 속도를 높이는 데 도움이 되는 모듈 작업자를 만드는 것은 매우 쉽습니다.

00:10:18.000 --> 00:10:23.000
자바스크립트 섹션의 마지막 부분은 국제화 API에 대한 업데이트입니다.

00:10:23.000 --> 00:10:26.000
이 API는 언어 기반 서식을 제공합니다.

00:10:26.000 --> 00:10:31.000
웹 콘텐츠가 다른 지역의 사용자를 위해 만들어진다면 유용합니다.

00:10:31.000 --> 00:10:41.000
그것이 어떻게 사용될 수 있는지 보여주기 위해, 저는 이 스톱워치 레코드 페이지를 만들었습니다. 왜냐하면, 알다시피, 스톱워치는 시간과 기능 출시를 따라잡아야 하기 때문입니다.

00:10:41.000 --> 00:10:53.000
이 페이지는 기간, 시작 시간, 이벤트, 참가자 및 페이지의 사용 가능한 언어를 포함한 스톱워치의 단일 사용에 대한 세부 사항을 보여줍니다.

00:10:53.000 --> 00:10:58.000
이제, 각 섹션으로 뛰어들어 각 인터페이스를 자세히 살펴봅시다.

00:10:58.000 --> 00:11:00.000
첫 번째는 NumberFormat이다.

00:11:00.000 --> 00:11:06.000
NumberFormat은 언어에 민감한 숫자 서식을 제공하며, 기간을 포맷하는 데 사용됩니다.

00:11:06.000 --> 00:11:13.000
NumberFormat의 생성자는 두 가지 선택적 매개 변수를 사용합니다: 언어와 옵션.

00:11:13.000 --> 00:11:22.000
여기서 저는 언어를 영어로 설정하고 다른 최소 숫자 숫자를 지정하는 두 가지 옵션 객체를 만듭니다.

00:11:22.000 --> 00:11:29.000
언어와 옵션으로 두 개의 NumberFormat 객체를 만든 후, 우리는 그것들을 사용하여 기간 번호를 포맷할 수 있습니다.

00:11:29.000 --> 00:11:39.000
여기서, 숫자가 밀리초가 아니라면, 저는 Format1을 사용하여 두 자리 숫자를 유지합니다; 그렇지 않으면 Format2를 사용하여 세 자리 숫자를 유지합니다.

00:11:39.000 --> 00:11:44.000
보시다시피, 포맷 방법은 자동으로 패딩 0을 추가합니다.

00:11:44.000 --> 00:11:54.000
통화 또는 단위로 값을 지정할 수 있는 스타일과 같이 필요한 형식을 만드는 데 사용할 수 있는 다양한 옵션이 있습니다.

00:11:54.000 --> 00:12:01.000
다음은 언어에 민감한 날짜와 시간 서식을 가능하게 하는 DateTimeFormat입니다.

00:12:01.000 --> 00:12:03.000
사용법은 NumberFormat과 비슷하다.

00:12:03.000 --> 00:12:05.000
먼저, 언어를 설정하세요.

00:12:05.000 --> 00:12:07.000
그런 다음, 옵션을 설정하세요.

00:12:07.000 --> 00:12:11.000
옵션에서, 나는 날짜와 시간에 대해 다른 스타일을 설정했다.

00:12:11.000 --> 00:12:20.000
DateTimeFormat 객체는 초 또는 밀리초 동안 스타일을 지정할 수 있는 세밀한 구성을 제공합니다.

00:12:20.000 --> 00:12:28.000
그 후, 우리는 매개 변수가 있는 DateTimeFormat 객체를 만들고, 그것을 사용하여 시작 시간을 포맷할 수 있습니다.

00:12:28.000 --> 00:12:31.000
결과는 영어로 표현된다.

00:12:31.000 --> 00:12:37.000
스타일이 길기 때문에 날짜가 더 상세하다는 것을 알 수 있습니다.

00:12:37.000 --> 00:12:39.000
다음은 세그먼트입니다.

00:12:39.000 --> 00:12:43.000
언어에 민감한 문자열 분할을 할 수 있습니다.

00:12:43.000 --> 00:12:48.000
나는 이벤트 문장에서 키워드를 찾기 위해 그것을 사용했다.

00:12:48.000 --> 00:12:52.000
이것은 스톱워치 레코드 페이지의 중국어 버전입니다.

00:12:52.000 --> 00:12:56.000
먼저, 나는 강조하고 싶은 키워드의 짧은 목록을 선언한다.

00:12:56.000 --> 00:13:01.000
이벤트 문자열에는 섭씨도 기호의 유니코드도 포함되어 있습니다.

00:13:01.000 --> 00:13:04.000
여기서 우리는 중국어를 언어로 지정한다.

00:13:04.000 --> 00:13:08.000
옵션에서, 세분성은 단어로 설정되어 있다.

00:13:08.000 --> 00:13:12.000
다른 가능한 값은 문자와 문장이다.

00:13:12.000 --> 00:13:18.000
그런 다음 우리는 세그멘터를 만들고 그것을 사용하여 세그먼트 메소드로 문자열을 분할합니다.

00:13:18.000 --> 00:13:22.000
우리는 모든 세그먼트를 얻기 위해 결과 객체를 반복할 수 있다.

00:13:22.000 --> 00:13:28.000
각 세그먼트가 키워드 목록에 포함되어 있는지 확인하여 표시하세요.

00:13:28.000 --> 00:13:38.000
세그멘터는 경계라는 단어가 명확하지 않은 중국어와 같은 언어를 해석하는 데 매우 유용하다.

00:13:38.000 --> 00:13:43.000
다음은 언어에 민감한 목록 서식을 가능하게 하는 ListFormat입니다.

00:13:43.000 --> 00:13:47.000
이전과 마찬가지로, 우리는 언어와 옵션을 지정할 수 있다.

00:13:47.000 --> 00:13:52.000
ListFormat에는 다른 인터페이스만큼 많은 옵션이 없습니다.

00:13:52.000 --> 00:13:56.000
내가 찾은 가장 유용한 것은 유형과 스타일이다.

00:13:56.000 --> 00:14:03.000
언어와 옵션으로, 우리는 ListFormat을 만들고 우리가 가지고 있는 참가자 목록을 포맷할 수 있습니다.

00:14:03.000 --> 00:14:13.000
보시다시피, 유형은 결합이고 스타일은 길기 때문에, 형식 방법은 결과에 쉼표와 단어 "and"를 추가합니다.

00:14:13.000 --> 00:14:16.000
마지막 것은 DisplayNames이다.

00:14:16.000 --> 00:14:21.000
그것은 언어, 지역 및 스크립트에 대한 표시 이름의 일관된 번역을 제공한다.

00:14:21.000 --> 00:14:24.000
여기서 나는 일본어로 언어를 지정한다.

00:14:24.000 --> 00:14:27.000
DisplayNames는 언어 코드를 입력으로 사용할 수 있다.

00:14:27.000 --> 00:14:31.000
옵션에서, 우리는 유형을 언어로 설정합니다.

00:14:31.000 --> 00:14:34.000
그런 다음 DisplayNames 객체를 만들 수 있습니다.

00:14:34.000 --> 00:14:39.000
그리고 여기서, 방법을 사용하여, 우리는 번역된 결과를 얻을 수 있다.

00:14:39.000 --> 00:14:45.000
이 페이지는 영어로 만들어졌지만, 일본 사용자는 어떤 언어가 지원되는지 알 수 있습니다.

00:14:45.000 --> 00:14:52.000
그리고 이것이 내가 새로운 국제화 인터페이스로 스톱워치 레코드 페이지를 만든 방법이다.

00:14:52.000 --> 00:14:58.000
기억을 새로 고치기 위해, 여기 자바스크립트 섹션에서 방금 살펴본 것들의 목록이 있습니다.

00:14:58.000 --> 00:15:04.000
그 후, 우리의 다음 정거장은 웹어셈블리의 업데이트이다.

00:15:04.000 --> 00:15:13.000
우리는 한동안 웹어셈블리 엔진을 배송해 왔지만, 당신이 그것에 익숙하지 않은 경우, 웹어셈블리의 배경을 작성하는 것으로 시작하겠습니다.

00:15:13.000 --> 00:15:20.000
웹어셈블리는 스택 기반 가상 머신을 위한 이진 명령 형식이다.

00:15:20.000 --> 00:15:26.000
그것은 네이티브 코드에 가까운 성능을 가진 최신 웹 브라우저에서 실행할 수 있는 코드의 일종이다.

00:15:26.000 --> 00:15:42.000
WebAssembly는 C, C++ 또는 Rust와 같은 프로그래밍 언어의 휴대용 컴파일 대상으로 설계되었으므로 WebAssembly는 웹에서 해당 언어로 작성된 응용 프로그램을 배포하는 데 도움을 줄 수 있습니다.

00:15:42.000 --> 00:15:47.000
웹어셈블리의 대부분의 사용 사례에서, 그것은 자바스크립트와 함께 실행된다.

00:15:47.000 --> 00:15:52.000
그들은 WebAssembly API를 통해 서로 통신할 수 있다.

00:15:52.000 --> 00:15:59.000
웹어셈블리는 거의 네이티브 성능을 제공할 수 있으며, 웹에서 강력한 프레임워크를 사용할 수 있게 한다.

00:15:59.000 --> 00:16:04.000
자바스크립트는 DOM을 조작할 수 있으며 강력한 웹 API를 제공합니다.

00:16:04.000 --> 00:16:09.000
그들은 서로에게 좋은 추가가 될 수 있다.

00:16:09.000 --> 00:16:12.000
웹어셈블리 사용의 좋은 예는 펑키 카트이다.

00:16:12.000 --> 00:16:17.000
엠스크립팅으로 C++에서 웹어셈블리로 변환된 게임이다.

00:16:17.000 --> 00:16:22.000
보시다시피, 사파리에서 매우 원활하게 실행됩니다.

00:16:22.000 --> 00:17:24.000
올해, 우리는 다음과 같은 기능으로 웹어셈블리 엔진을 업그레이드했습니다: 메모리 블록 복사 또는 초기화와 같은 대량 메모리 작업에서 더 나은 성능을 제공하는 새로운 메모리 지침; float와 int 사이를 변환할 때 양의 오버플로와 같은 사용자 프로세스가 예외에 트랩하지 않도록 하는 새로운 지침; 부호 있는 정수를 확장할 수 있는 새로운 기호 확장 연산자; 이전 솔루션보다 간단하고 코드를 더 객체, 인수로 전달하고 저장; 마지막으로, 전체 실행 시간을 단축하는 웹어셈블리의 스트리밍 다운로드 및 컴파일.

00:17:24.000 --> 00:17:28.000
이것들은 우리의 새로운 웹어셈블리 기능의 하이라이트입니다.

00:17:28.000 --> 00:17:31.000
우리는 그들이 당신의 발전에 도움이 되기를 바랍니다.

00:17:31.000 --> 00:17:37.000
이제, 강력한 저수준 코드에서 일부 고급 API로 이동해 봅시다.

00:17:37.000 --> 00:17:42.000
이 섹션에서, 우리는 새로운 웹 API를 탐구할 것이다.

00:17:42.000 --> 00:17:52.000
제 목표는 당신에게 새로운 기능에 대해 알려줄 뿐만 아니라 당신이 그것들을 사용할 준비가 되었다고 느끼게 하는 것입니다, 그래서 당신은 몇 가지 좋은 예를 보게 될 것입니다.

00:17:52.000 --> 00:17:59.000
하지만 이것은 완전한 튜토리얼이 아니므로, 사용하기 전에 공식 문서를 확인하는 것을 잊지 마세요.

00:17:59.000 --> 00:18:02.000
이것은 내가 이야기할 기능의 미리보기이다.

00:18:02.000 --> 00:18:12.000
그들 중 일부는 음성 인식과 같이 완전히 새로운 것이고 그들 중 일부는 이미 거기에 있지만, 우리는 Storage Access와 같이 공유하고 싶은 몇 가지 업데이트가 있습니다.

00:18:12.000 --> 00:18:17.000
이제, 그들 각각에 대해 자세히 알아봅시다.

00:18:17.000 --> 00:18:24.000
우리는 웹 콘텐츠를 매력적으로 만드는 것을 알고 있으며, 놀라운 시각적 경험을 제공하는 것이 매우 중요합니다.

00:18:24.000 --> 00:18:33.000
WebGL2는 WebKit과 Safari에서 사용할 수 있으므로 아름다운 대화형 웹 콘텐츠를 더 쉽게 만들 수 있습니다.

00:18:33.000 --> 00:18:37.000
다음은 WebGL2로 무엇을 할 수 있는지에 대한 좋은 예입니다.

00:18:37.000 --> 00:18:42.000
After the Flood는 PlayCanvas가 개발한 인터랙티브 데모이다.

00:18:42.000 --> 00:18:45.000
부드러운 바람이 나무를 흔든다.

00:18:45.000 --> 00:18:48.000
사파리에서 생생해 보인다.

00:18:48.000 --> 00:18:50.000
그래서 WebGL2가 뭐야?

00:18:50.000 --> 00:18:56.000
WebGL은 2D 및 3D 그래픽을 렌더링하기 위해 매우 널리 사용되는 저수준 API이다.

00:18:56.000 --> 00:19:03.000
WebGL2는 대체를 제거하고 몇 가지 멋진 새로운 기능을 도입하는 WebGL의 업그레이드입니다.

00:19:03.000 --> 00:19:09.000
구름과 같은 체적 효과를 렌더링할 수 있도록 3D 텍스처를 추가합니다.

00:19:09.000 --> 00:19:16.000
셰이더에서 텍스처를 사용하는 방법에 대해 더 많은 유연성을 제공하는 샘플러 개체가 있습니다.

00:19:16.000 --> 00:19:23.000
GPU에서 성능 파티클 시스템을 구현하는 데 도움이 되는 변환 피드백을 제공합니다.

00:19:23.000 --> 00:19:27.000
WebGL2에는 정말 많은 훌륭한 새로운 기능이 있다.

00:19:27.000 --> 00:19:34.000
그리고 더 중요한 것은, WebGL2는 이제 모든 Apple 장치의 Safari에서 사용할 수 있습니다.

00:19:34.000 --> 00:19:39.000
그것은 당신이 모든 곳에서 멋지게 보이는 아름다운 사이트를 만들 수 있다는 것을 의미합니다.

00:19:39.000 --> 00:19:46.000
그리고 예를 들어 WebGL2에 더 익숙해지자: 주황색 사각형 만들기.

00:19:46.000 --> 00:19:50.000
그리고 이것은 당신이 작성해야 할 자바스크립트 코드입니다.

00:19:50.000 --> 00:19:57.000
이전에 WebGL을 사용해 본 적이 없다면, 이것은 당신이 상상했던 것만큼 쉽지 않을 수도 있습니다.

00:19:57.000 --> 00:20:03.000
내가 언급했듯이, WebGL은 낮은 수준의 API이기 때문에, 매우 장황할 수 있다.

00:20:03.000 --> 00:20:10.000
하지만 걱정하지 마세요; 개발을 단순화하는 데 도움이 될 수 있는 훌륭한 라이브러리와 프레임워크가 많이 있습니다.

00:20:10.000 --> 00:20:17.000
그들과 함께, 멋진 정사각형이나 그것보다 더 복잡한 것을 만드는 것은 그렇게 어렵지 않다.

00:20:17.000 --> 00:20:23.000
이제, 이미 웹 콘텐츠에서 WebGL을 사용하고 있다면, 좋은 소식도 있습니다.

00:20:23.000 --> 00:20:29.000
우리는 백엔드를 OpenGL에서 Metal로 마이그레이션하여 지원을 개선했습니다.

00:20:29.000 --> 00:20:40.000
즉, iOS 시뮬레이터는 이제 웹 콘텐츠에 GPU를 사용할 수 있어 사용자가 볼 수 있는 것을 훨씬 더 정확하게 표현할 수 있습니다.

00:20:40.000 --> 00:20:47.000
또한, Xcode Frame Debugger와 같은 금속 도구를 사용하여 WebGL 코드를 분석할 수 있습니다.

00:20:47.000 --> 00:20:54.000
WebGL로 콘텐츠를 만드는 것 외에도, 훌륭한 시각적 경험을 제공하는 또 다른 일반적인 방법은 비디오를 통한 것이다.

00:20:54.000 --> 00:21:06.000
모든 브라우저가 미디어 형식을 동일하게 지원하는 것은 아니므로, 어떤 형식을 사용할지 결정하는 것이 까다로울 수 있습니다.

00:21:06.000 --> 00:21:15.000
당신을 위해 일을 더 쉽게 하기 위해, 올해, 우리는 웹에서 일반적인 미디어 형식인 WebM에 대한 지원을 늘렸습니다.

00:21:15.000 --> 00:21:19.000
우선, 지원은 스트리밍 재생만을 위한 것입니다.

00:21:19.000 --> 00:21:28.000
macOS 11.3에서는 VP8 또는 VP9 비디오와 Vorbis 오디오가 포함된 WebM 파일 재생에 대한 지원을 추가했습니다.

00:21:28.000 --> 00:21:34.000
그리고 macOS 12에서는 Opus 오디오가 포함된 파일에 대한 지원을 추가합니다.

00:21:34.000 --> 00:21:40.000
작년에, 우리는 macOS에서 미디어 소스 확장을 통해 재생된 WebM을 지원하기 시작했습니다.

00:21:40.000 --> 00:21:44.000
이제, 우리는 iPadOS 15에 그 지원을 제공하고 있습니다.

00:21:44.000 --> 00:21:55.000
코드에서 WebM이 지원되는지 확인하려면, 사용하려는 정확한 미디어 구성을 감지할 수 있는 MediaCapabilities API를 사용할 수 있습니다.

00:21:55.000 --> 00:22:03.000
화면의 구성은 최신 사파리에서 지원되며, 이는 VP9도 현재 지원된다는 것을 의미합니다.

00:22:03.000 --> 00:22:12.000
이 비디오 코딩 형식에 대한 지원으로, 우리는 Safari와 WebKit 앱에서 더 많은 웹 콘텐츠를 사용할 수 있기를 기대합니다.

00:22:12.000 --> 00:22:16.000
스트리밍과 WebRTC 모두에서 VP9를 사용할 수 있습니다.

00:22:16.000 --> 00:22:19.000
그것은 macOS와 iPadOS에서 작동합니다.

00:22:19.000 --> 00:22:26.000
다른 장치에 대한 지원과 관련하여, 모든 Apple 실리콘 Mac에서 사용할 수 있습니다.

00:22:26.000 --> 00:22:33.000
다른 사람들을 위해, 당신은 우리가 방금 WebM에서 본 것과 마찬가지로 MediaCapabilities API로 확인할 수 있습니다.

00:22:33.000 --> 00:22:50.000
이제, 사이트에 WebM 또는 VP9 콘텐츠가 있다면, 최신 Safari와 WebKit에서 어떻게 작동하는지 확인하는 것이 좋습니다. 하지만 여전히 어떤 미디어 형식을 사용할지 결정하고 있다면, H.264 또는 HEVC를 추천합니다.

00:22:50.000 --> 00:22:54.000
H.264는 브라우저에서 성숙하고 잘 지원됩니다.

00:22:54.000 --> 00:22:58.000
HEVC는 고품질 비디오에 대한 훌륭한 지원을 제공합니다.

00:22:58.000 --> 00:23:06.000
둘 다 더 부드러운 재생과 더 긴 재생 배터리 수명을 제공할 수 있는 하드웨어 가속과 함께 제공됩니다.

00:23:06.000 --> 00:23:13.000
비디오 콘텐츠 호스팅에 대해 이야기하면서, 일반적인 사례는 우리가 콘텐츠를 소유하지 않는다는 것입니다; 대신, 우리는 제3자로부터 그것을 얻습니다.

00:23:13.000 --> 00:23:18.000
예를 들어, 나는 video.domain에서 이 멋진 비디오를 본다.

00:23:18.000 --> 00:23:29.000
내 사이트인 main.domain에 표시하려면 video.domain에서 이 비디오 소스를 로드하거나 video.domain의 iframe을 만들 수 있습니다.

00:23:29.000 --> 00:23:36.000
보안상의 이유로, 제3자 iframe 또는 리소스는 기본적으로 제1자 저장소에 액세스할 수 없습니다.

00:23:36.000 --> 00:23:46.000
즉, video.domain에 대한 리소스 요청이 main.domain에서 시작된 경우, video.domain의 쿠키는 포함되지 않습니다.

00:23:46.000 --> 00:23:53.000
이것은 video.domain의 웹 서버가 인증된 사용자에게만 콘텐츠를 제공하고 싶을 때 문제가 될 수 있습니다.

00:23:53.000 --> 00:23:57.000
그리고 쿠키가 없다는 것은 인증이 없다는 것을 의미합니다.

00:23:57.000 --> 00:24:01.000
스토리지 액세스 API는 이 문제를 해결합니다.

00:24:01.000 --> 00:24:08.000
그것은 제3자 iframe이 자사 쿠키에 접근할 수 있는 권한을 요청할 수 있게 해준다.

00:24:08.000 --> 00:24:17.000
사용자가 권한을 부여하면, 제3자 video.domain은 자사 쿠키에 액세스할 수 있습니다.

00:24:17.000 --> 00:24:22.000
스토리지 액세스 API는 3년 넘게 웹킷과 사파리에서 사용할 수 있었다.

00:24:22.000 --> 00:24:29.000
상호 운용성을 개선하기 위해, 올해 우리는 두 가지 새로운 기능을 추가했습니다.

00:24:29.000 --> 00:24:32.000
먼저, 페이지당 범위에서 접근이 허용됩니다.

00:24:32.000 --> 00:24:40.000
그것은 일단 제3자에게 허가가 부여되면, 같은 페이지의 모든 하위 자원으로 확장된다는 것을 의미합니다.

00:24:40.000 --> 00:24:45.000
각 iframe에 대해 요청할 필요가 없습니다.

00:24:45.000 --> 00:24:49.000
둘째, 우리는 중첩된 iframe이 요청을 할 수 있도록 허용합니다.

00:24:49.000 --> 00:24:58.000
이것은 iframe 내부의 iframe이 이전에는 불가능했던 자사 쿠키에 대한 액세스를 요청할 수 있다는 것을 의미합니다.

00:24:58.000 --> 00:25:08.000
새로운 사용법에 대해 자세히 알아보려면, webkit.org에서 블로그 게시물 "Storage Access API 업데이트"를 확인하세요.

00:25:08.000 --> 00:25:15.000
이제 우리는 필요한 경우 사용자 권한으로 제3자로부터 비디오 콘텐츠를 로드하거나 가져오는 방법을 알고 있습니다.

00:25:15.000 --> 00:25:18.000
스스로 무언가를 만드는 건 어때?

00:25:18.000 --> 00:25:23.000
새로운 미디어 레코더 API를 사용하면, 그것을 하는 것이 매우 쉽다.

00:25:23.000 --> 00:25:34.000
미디어 레코더 API를 사용하면 비디오 태그 또는 MediaStream 객체와 같은 HTML 미디어 요소를 포함하는 미디어 요소에서 데이터를 캡처할 수 있습니다.

00:25:34.000 --> 00:25:39.000
사용자의 입력 장치에서 기록하는 데 사용할 수 있습니다.

00:25:39.000 --> 00:25:47.000
컨테이너의 MIME 유형이나 원하는 트랙 비트 전송률과 같은 원하는 옵션을 지정할 수 있습니다.

00:25:47.000 --> 00:25:49.000
API는 간단하다.

00:25:49.000 --> 00:25:58.000
그것은 소스에서 데이터를 수집하고 당신에게 전달하는 모든 작업을 수행하는 단일 주요 인터페이스인 MediaRecorder로 구성되어 있습니다.

00:25:58.000 --> 00:26:02.000
한 가지 예를 보여드릴게요.

00:26:02.000 --> 00:26:07.000
저는 MediaRecorder API를 사용하여 "음성 메모"라는 웹 앱을 구축했습니다.

00:26:07.000 --> 00:26:09.000
이건 내 첫 번째 음성 메모야.

00:26:09.000 --> 00:26:13.000
버튼을 클릭하면, 마이크에서 녹음이 시작됩니다.

00:26:13.000 --> 00:26:16.000
다시 클릭하면, 녹음을 멈추고 재생을 제공합니다.

00:26:16.000 --> 00:26:19.000
이건 내 첫 번째 음성 메모야.

00:26:19.000 --> 00:26:21.000
그거 재밌네.

00:26:21.000 --> 00:26:25.000
그리고 이제 구현을 확인해 봅시다.

00:26:25.000 --> 00:26:29.000
우리는 두 가지 주요 기능이 있습니다: startRecording과 stopRecording.

00:26:29.000 --> 00:26:33.000
startRecording에서, 우리는 마이크를 위한 입력 미디어 스트림을 얻는다.

00:26:33.000 --> 00:26:36.000
그런 다음 우리는 그것으로 MediaRecorder 객체를 만듭니다.

00:26:36.000 --> 00:26:40.000
우리는 미디어 레코더의 두 가지 사건을 듣는다.

00:26:40.000 --> 00:26:43.000
그리고 나서 우리는 시작 방법으로 레코더를 시작할 수 있다.

00:26:43.000 --> 00:26:50.000
녹음을 중지하려면, mediaRecorder 객체에서 중지 방법을 호출하기만 하면 됩니다.

00:26:50.000 --> 00:26:52.000
여기 두 개의 이벤트 핸들러가 있습니다.

00:26:52.000 --> 00:26:57.000
캡처된 데이터를 사용할 수 있을 때, 우리는 그것을 배열에 저장합니다.

00:26:57.000 --> 00:27:05.000
녹음이 중지되면, 우리는 배열에서 수집된 데이터로 BLOB을 만들고, 재생을 위해 기존 오디오 요소로 보냅니다.

00:27:05.000 --> 00:27:09.000
그렇게 하면, 당신은 기능적인 음성 녹음기를 만들 수 있습니다.

00:27:09.000 --> 00:27:13.000
오디오 데이터를 수집한 후, 편집하고 싶을 수도 있습니다.

00:27:13.000 --> 00:27:18.000
이 경우, 새로운 Audio Worklet API를 잘 사용할 수 있습니다.

00:27:18.000 --> 00:27:27.000
오디오 워크렛 인터페이스는 웹 오디오 API의 일부이며, 이전에 웹에서 오디오 처리를 한 적이 있다면 이미 익숙할 수 있습니다.

00:27:27.000 --> 00:27:37.000
자바스크립트 또는 웹어셈블리 코드와 같은 스크립트를 실행하여 사용자 지정 AudioNodes를 지원하는 오디오 렌더링 스레드에서 오디오를 처리할 수 있습니다.

00:27:37.000 --> 00:27:49.000
ScriptProcessorNode와 비교하여 사용자 지정 스크립트를 실행하는 이전 솔루션은 렌더링 스레드와 메인 스레드 사이의 호핑을 줄이고 낮은 대기 시간을 보장합니다.

00:27:49.000 --> 00:27:55.000
오디오 워크렛으로, 나는 음성 메모에 새로운 기능을 추가했다.

00:27:55.000 --> 00:27:57.000
이건 내 왜곡된 목소리야.

00:27:57.000 --> 00:28:03.000
녹음을 위해 왜곡 상자를 선택하면, 일부 왜곡 효과가 오디오에 적용됩니다.

00:28:03.000 --> 00:28:12.000
이건 내 왜곡된 목소리야. 멋지게 들리는데, 그게 어떻게 구현되는지 살펴보자.

00:28:12.000 --> 00:28:16.000
오디오 처리를 추가하기 위해 startRecording 기능을 수정했습니다.

00:28:16.000 --> 00:28:20.000
우리는 여전히 오디오 입력을 위한 MediaStream을 먼저 가져와야 한다.

00:28:20.000 --> 00:28:23.000
Audio Worklet API를 사용하려면, 네 가지 기본 단계가 있습니다.

00:28:23.000 --> 00:28:26.000
1단계: 소스를 만드세요.

00:28:26.000 --> 00:28:34.000
2단계: AudioWorkletNode를 만들고 오디오 처리를 수행하는 Audio Worklet 프로세서와 바인딩하세요.

00:28:34.000 --> 00:28:39.000
프로세서는 모듈에 구현되어 있으며, 우리는 나중에 그것을 살펴볼 것이다.

00:28:39.000 --> 00:28:41.000
3단계: 목적지를 만드세요.

00:28:41.000 --> 00:28:46.000
4단계: 소스에서 목적지까지 경로를 연결하세요.

00:28:46.000 --> 00:28:55.000
이번에 MediaRecorder는 AudioWorklet의 출력을 소스로 가져와 왜곡된 오디오를 녹음합니다.

00:28:55.000 --> 00:28:58.000
이것은 오디오 처리 모듈입니다.

00:28:58.000 --> 00:29:01.000
우리는 여기서 DistortionProcessor 클래스를 구현합니다.

00:29:01.000 --> 00:29:09.000
AudioWorkletProcessor 클래스를 확장해야 하며 프로세스 기능을 위한 구현을 제공해야 합니다.

00:29:09.000 --> 00:29:17.000
입력은 오디오 워크릿으로 들어오는 오디오 샘플이며, 출력은 처리 후 결과 샘플입니다.

00:29:17.000 --> 00:29:21.000
다른 알고리즘을 사용하여 출력을 만들 수 있습니다.

00:29:21.000 --> 00:29:26.000
여기서, 저는 입력을 기반으로 값을 계산하기 위해 distort()라는 사용자 지정 함수를 사용합니다.

00:29:26.000 --> 00:29:32.000
프로세스 함수는 true를 반환하며, 이는 프로세서 노드가 활성화되어 있음을 의미합니다.

00:29:32.000 --> 00:29:35.000
그것이 프로세스 기능의 기본 구조이다.

00:29:35.000 --> 00:29:45.000
프로세서 클래스를 만든 후, 지정된 이름으로 전 세계적으로 등록해야 하므로 AudioWorkletNode를 구성하는 데 사용할 수 있습니다.

00:29:45.000 --> 00:29:50.000
그렇게 하면, 오디오 데이터에 음향 효과를 적용할 수 있습니다.

00:29:50.000 --> 00:29:54.000
지금까지 우리는 오디오 데이터를 생산하고 처리하는 것에 대해 논의했다.

00:29:54.000 --> 00:29:59.000
당신의 기록을 위해 그것을 저장하거나 다른 곳으로 공유하는 것은 어떨까요?

00:29:59.000 --> 00:30:04.000
브라우저를 종료한 후 녹음을 잃고 싶지 않은 것 같아요.

00:30:04.000 --> 00:30:10.000
올해 웹 공유 API 업데이트로, 그렇게 하는 것은 꽤 쉽다.

00:30:10.000 --> 00:30:13.000
웹 공유는 웹킷과 사파리에서 새로운 것이 아니다.

00:30:13.000 --> 00:30:24.000
Safari의 웹 페이지에서 링크를 공유하도록 선택하면, 메시지, 메일 또는 AirDrop과 같은 공유 대상과 함께 공유 시트가 표시됩니다.

00:30:24.000 --> 00:30:32.000
시스템 스타일과 잘 어울리는 공유 시트는 웹 공유 API로 만들어졌습니다.

00:30:32.000 --> 00:30:36.000
올해, 우리는 파일 공유에 대한 지원을 추가했습니다.

00:30:36.000 --> 00:30:43.000
그것은 당신이 지금 이 API로 이미지, 비디오, 오디오 또는 다른 유형의 파일을 공유할 수 있다는 것을 의미합니다.

00:30:43.000 --> 00:30:47.000
음성 메모에 공유 기능을 추가합시다.

00:30:47.000 --> 00:30:57.000
저장 상자를 선택하면, 음성 메모는 캡처된 데이터로 오디오 파일을 만들고 공유 버튼을 표시하여 파일을 공유할 수 있습니다.

00:30:57.000 --> 00:31:00.000
여기, 저는 이메일로 메모 파일을 공유하고 싶습니다.

00:31:00.000 --> 00:31:06.000
한 번의 클릭으로, 메모 파일이 첨부된 멋진 초안이 생성됩니다.

00:31:06.000 --> 00:31:09.000
그리고 코드를 확인해 봅시다.

00:31:09.000 --> 00:31:14.000
이것은 우리가 MediaRecorder 예시에서 본 정지 이벤트 핸들러입니다.

00:31:14.000 --> 00:31:21.000
먼저, 공유 함수에서 사용할 수 있도록 정지 이벤트 핸들러에서 blob 변수를 글로벌로 만들어 봅시다.

00:31:21.000 --> 00:31:25.000
공유 기능은 공유 버튼의 클릭 이벤트 핸들러입니다.

00:31:25.000 --> 00:31:29.000
그것은 BLOB을 파일로 변환하고 파일 이름을 부여한다.

00:31:29.000 --> 00:31:34.000
그 파일은 예상 입력 유형이기 때문에 배열에 배치된다.

00:31:34.000 --> 00:31:40.000
그런 다음 API를 사용할 수 있는지 그리고 파일을 canShare 방법으로 공유할 수 있는지 확인합니다.

00:31:40.000 --> 00:31:46.000
확인이 통과되면, 파일 배열로 navigator.share를 호출합니다.

00:31:46.000 --> 00:31:51.000
제목과 설명 텍스트와 같이 지정할 수 있는 옵션이 있습니다.

00:31:51.000 --> 00:31:57.000
네이티브 앱처럼 웹 앱이 파일을 공유하도록 만드는 것은 쉽습니다.

00:31:57.000 --> 00:32:08.000
음, 실제로 오디오 데이터와 상호 작용하고 싶지 않지만, 예를 들어 텍스트를 원한다면, 음성 명령의 경우 새로운 API도 있습니다.

00:32:08.000 --> 00:32:11.000
그건 음성 인식이야.

00:32:11.000 --> 00:32:18.000
제안된 이름처럼, 음성 인식 API는 라이브 오디오를 캡처하고 텍스트로 전사합니다.

00:32:18.000 --> 00:32:23.000
그것은 또한 당신에게 성적 증명서의 확률과 대안을 제공합니다.

00:32:23.000 --> 00:32:32.000
그것은 Siri와 동일한 음성 엔진을 사용하며, 모든 이점을 얻습니다: 여러 언어 지원과 뛰어난 정확성.

00:32:32.000 --> 00:32:41.000
그것은 또한 사용자가 API를 사용할 수 있도록 시스템 환경 설정 또는 설정에서 Siri 또는 받아쓰기를 켜야 한다는 것을 의미합니다.

00:32:41.000 --> 00:32:49.000
인식은 서버 기반일 수 있으므로, 앱에서 처음으로 인식 서비스를 사용할 때 개인 정보 보호 프롬프트를 올렸습니다.

00:32:49.000 --> 00:32:55.000
사용자는 시스템 환경 설정 또는 설정에서 권한을 변경할 수 있습니다.

00:32:55.000 --> 00:32:59.000
이제, 이 새로운 기능으로 음성 메모를 업데이트해 봅시다.

00:32:59.000 --> 00:33:04.000
인식 상자가 선택되어 있다면, 녹음을 위한 성적표를 생성하는 것을 의미합니다.

00:33:04.000 --> 00:33:07.000
이건 내 음성 메모 대본이야.

00:33:07.000 --> 00:33:10.000
기간.

00:33:10.000 --> 00:33:13.000
그리고 코드를 확인해 봅시다.

00:33:13.000 --> 00:33:16.000
그 사용법은 미디어 레코더와 약간 비슷하다.

00:33:16.000 --> 00:33:21.000
여기에 두 가지 주요 기능이 있습니다: 인식 시작과 인식 중지.

00:33:21.000 --> 00:33:25.000
먼저 webkitSpeechRecognition 객체를 만들어야 합니다.

00:33:25.000 --> 00:33:32.000
네, 우리는 호환성을 위해 WebKit 접두사를 보관하고 있으므로, 추가하는 것을 잊지 마세요.

00:33:32.000 --> 00:33:42.000
그런 다음 지속과 같은 인식의 일부 속성을 설정할 수 있으며, 이는 인식이 멈출 때까지 계속 진행하도록 요청합니다.

00:33:42.000 --> 00:33:45.000
우리는 결과와 최종 사건을 듣는다.

00:33:45.000 --> 00:33:55.000
인식 객체를 사용하면 시작 메소드를 호출하여 시작하고 중지 메소드를 호출하여 중지할 수 있습니다.

00:33:55.000 --> 00:33:59.000
결과 이벤트에서, 우리는 최종 대본을 문자열로 수집합니다.

00:33:59.000 --> 00:34:07.000
여기서, 나는 전사 대안이 확률에 따라 정렬되기 때문에 결과의 첫 번째 항목만 선택한다.

00:34:07.000 --> 00:34:13.000
인식이 멈추면, 사용자 지정 로그 기능을 사용하여 성적표를 화면에 인쇄합니다.

00:34:13.000 --> 00:34:20.000
그렇게 하면, 단 몇 줄 안에 웹 콘텐츠에 인식 기능을 추가할 수 있습니다.

00:34:20.000 --> 00:34:26.000
그것은 긴 여정이었고, 내가 언급할 가치가 있다고 생각하는 마지막 웹 API가 하나 있다.

00:34:26.000 --> 00:34:33.000
macOS와 iOS에서 지금 재생 중 위젯이 Safari에서 미디어 상태를 보여줄 수 있다는 것을 눈치챘을 것입니다.

00:34:33.000 --> 00:34:39.000
그것은 편리하지만, 보통 많은 정보를 포함하지 않는다.

00:34:39.000 --> 00:34:46.000
예를 들어, 이것은 웹 페이지의 제목만 보여줍니다; 어떤 오디오가 재생되고 있는지에 대한 정보는 없습니다.

00:34:46.000 --> 00:34:55.000
이 상황을 개선하는 데 도움이 될 수 있는 새로운 웹 API가 있습니다: 미디어 세션 API.

00:34:55.000 --> 00:35:02.000
미디어 세션 API를 사용하면 웹 페이지와 다른 플랫폼 구성 요소 간에 미디어 상태를 전달할 수 있습니다.

00:35:02.000 --> 00:35:12.000
사용자가 지금 재생 중 위젯과 같이 웹 페이지 외부의 미디어 상태를 보거나 제어하기를 원한다면, 이것은 당신이 알아야 할 API입니다.

00:35:12.000 --> 00:35:24.000
미디어 세션 API에 대한 자세한 내용은 WWDC 세션 "GroupActivities로 웹에서 미디어 재생 조정"을 확인하십시오.

00:35:24.000 --> 00:35:27.000
그리고 이것들은 우리가 방금 탐구한 새로운 기능들이다.

00:35:27.000 --> 00:35:30.000
나는 네가 그것에 대해 뭔가를 배웠다고 느끼길 바라.

00:35:30.000 --> 00:35:36.000
그리고 오늘 당신의 숙제는 이 새로운 API로 자신만의 음성 메모를 구현하는 것입니다.

00:35:36.000 --> 00:35:45.000
농담이지만, 우리는 WebKit과 Safari에서 최고의 개발 경험을 제공하는 데 도움이 되도록 당신이 할 수 있기를 바라는 몇 가지가 있습니다.

00:35:45.000 --> 00:35:53.000
최신 WebKit 및 Safari의 새로운 기능을 사용해 보고 bugs.webkit.org에서 버그 보고서를 제출하십시오.

00:35:53.000 --> 00:36:01.000
Safari Technology Preview로 적극적으로 개발 중인 새로운 기능이나 기능을 살짝 엿볼 수 있습니다.

00:36:01.000 --> 00:36:11.000
WebKit 또는 Safari에서 사용되는 웹 기술에 관심이 있거나 WebKit 커뮤니티에 가입하는 데 관심이 있다면, webkit.org가 좋은 소스입니다.

00:36:11.000 --> 00:36:20.000
WebKit에 대한 새로운 업데이트를 받고 싶거나, 우리에게 질문이 있다면, 우리를 팔로우하거나 트위터에서 우리를 태그하는 것을 잊지 마세요.

00:36:20.000 --> 00:36:25.000
이 세션을 봐줘서 고마워, 그리고 WWDC에서 좋은 시간 보내길 바라!

00:36:25.000 --> 23:59:59.000
♪

