WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:14.000
안녕! 저는 니콜이고, "스위프트의 새로운 기능"에 오신 것을 환영합니다.

00:00:14.000 --> 00:00:17.000
스위프트 5.5는 우리의 최고의 출시입니다!

00:00:17.000 --> 00:00:33.000
스위프트 언어는 스위프트에서 동시 프로그래밍을 편리하고 효율적이며 안전하게 만들기 위해 설계된 비동기 및 동시 프로그래밍을 위한 새로운 모델인 스위프트 동시성을 포함한 많은 새로운 기능과 함께 빠른 속도로 계속 진화하고 있다.

00:00:33.000 --> 00:00:46.000
또한, 우리는 패키지 경험의 발전, 새로운 표준 라이브러리 패키지 및 개발자 경험을 향상시키는 기능 덕분에 Swift에서 그 어느 때보다 쉽게 개발할 수 있게 되었습니다.

00:00:46.000 --> 00:00:56.000
이러한 발전만큼 중요한 것은, 스위프트 프로젝트의 핵심은 코드가 아니라 스위프트 프로젝트의 목표를 향해 일하는 사람들의 공동체이다.

00:00:56.000 --> 00:01:01.000
이것이 우리가 소프트웨어뿐만 아니라 지역 사회에 투자하는 것이 중요한 이유이다.

00:01:01.000 --> 00:01:06.000
저는 중요한 스위프트 커뮤니티 이니셔티브에 대해 이야기하는 것으로 시작하고 싶습니다.

00:01:06.000 --> 00:01:10.000
다양성은 스위프트 커뮤니티의 핵심 가치이다.

00:01:10.000 --> 00:01:16.000
연구는 다양한 오픈 소스 프로젝트가 더 생산적이고 더 나은 결정을 내린다는 것을 보여준다.

00:01:16.000 --> 00:01:23.000
모든 배경과 다양한 관점을 가진 사람들을 포함하는 것은 공동체가 번창하는 데 도움이 된다.

00:01:23.000 --> 00:01:35.000
우리와 스위프트 커뮤니티의 다른 구성원들은 스위프트의 다양성 이니셔티브를 통해 더 넓은 범위의 개발자들로부터 스위프트 생태계와 커뮤니티에 대한 적극적인 참여를 장려할 수 있는 기회를 보았습니다.

00:01:35.000 --> 00:01:50.000
스위프트의 다양성의 사명은 다양한 목소리를 높이고 개발자가 배경에 관계없이 스위프트에 더 쉽게 배우거나 기여할 수 있도록 함으로써 포용적인 스위프트 커뮤니티를 육성하는 것입니다.

00:01:50.000 --> 00:02:01.000
이 이니셔티브의 일환으로, 우리는 커뮤니티 내의 다양한 개발자들의 기여를 인정하고 강조하는 게시물을 포함하도록 swift.org 블로그를 확장했습니다.

00:02:01.000 --> 00:02:10.000
우리는 또한 개발자들이 비슷한 경험을 했거나 비슷한 장벽에 직면했을 수 있는 다른 사람들과 연결할 수 있도록 스위프트 포럼에 커뮤니티 그룹을 만들었습니다.

00:02:10.000 --> 00:02:18.000
Swift의 다양성에 참여하거나 더 많은 것을 알아보려면, swift.org/diversity를 방문하세요.

00:02:18.000 --> 00:02:24.000
우리는 또한 이미 커뮤니티에 있는 개발자들이 Swift로 성장하고 목표를 달성할 수 있도록 돕고 싶습니다.

00:02:24.000 --> 00:02:35.000
스위프트 오픈 소스 프로젝트에 더 접근하기 위해, 우리는 최근 신규 이민자들이 정기적인 기여자로부터 직접적인 지원과 안내를 받을 수 있도록 스위프트 멘토링 프로그램을 발표했습니다.

00:02:35.000 --> 00:02:38.000
이 프로그램은 애플의 프로젝트에만 국한되지 않는다.

00:02:38.000 --> 00:02:44.000
그것은 또한 스위프트 패키지와 오픈 소스 도구의 전체 생태계를 포함한다.

00:02:44.000 --> 00:02:48.000
다음으로, 저는 패키지에 대해 이야기하고 싶습니다.

00:02:48.000 --> 00:02:56.000
패키지는 소프트웨어 구축을 위한 기본 구성 요소로, 계속 증가하는 오픈 소스 코드 배열을 편리하게 활용할 수 있습니다.

00:02:56.000 --> 00:03:04.000
스위프트 커뮤니티의 구성원들은 개발자들이 스위프트 패키지 인덱스와 같은 패키지를 찾는 데 도움이 되는 몇 가지 훌륭한 해결책을 생각해냈다.

00:03:04.000 --> 00:03:12.000
스위프트 패키지 인덱스는 스위프트 패키지 관리자를 지원하는 패키지를 찾는 데 도움이 되는 커뮤니티에서 만든 페이지입니다.

00:03:12.000 --> 00:03:32.000
이제 Swift 5.5 및 Xcode 13에서는 개발 워크플로우의 일환으로 프로젝트에서 패키지를 더 빠르고 쉽게 사용할 수 있도록 통합 Xcode 툴링 지원을 제공하여 패키지를 찾고 액세스할 수 있는 추가 방법을 제공하고 있습니다.

00:03:32.000 --> 00:03:42.000
올해, 우리는 명령줄과 Xcode 13 모두에서 사용할 수 있는 스위프트 패키지의 엄선된 목록인 스위프트 패키지 컬렉션을 소개합니다.

00:03:42.000 --> 00:03:50.000
패키지 컬렉션을 사용하면 더 이상 인터넷에서 패키지를 검색하거나 URL을 복사하여 붙여넣을 필요가 없습니다.

00:03:50.000 --> 00:03:55.000
이제 Xcode의 새 패키지 검색 화면에서 컬렉션을 탐색하고 패키지를 추가할 수 있습니다.

00:03:55.000 --> 00:04:00.000
패키지 컬렉션은 어디서나 게시할 수 있는 간단한 JSON 파일입니다.

00:04:00.000 --> 00:04:06.000
패키지 컬렉션은 누구나 다양한 사용 사례에 대한 엄선된 패키지 목록을 만들 수 있도록 하기 위한 것입니다.

00:04:06.000 --> 00:04:22.000
예를 들어, 컴퓨터 과학 수업의 강사는 그 수업의 개념을 가르치는 데 도움이 되는 패키지 세트를 구성할 수 있거나, 누군가는 특정 도메인이나 작업에 적합하거나 조직에서 사용하는 패키지 모음을 구성할 수 있습니다.

00:04:22.000 --> 00:04:27.000
우리는 사람들이 컬렉션을 사용할 모든 다양한 방법을 보게 되어 기쁩니다.

00:04:27.000 --> 00:04:33.000
우리는 패키지 컬렉션에 대한 훌륭한 프레젠테이션을 가지고 있습니다. 더 많은 것을 배우기 위해 확인하는 것을 추천합니다.

00:04:33.000 --> 00:04:37.000
패키지 컬렉션에는 Xcode의 강력한 툴링 지원이 포함되어 있습니다.

00:04:37.000 --> 00:04:41.000
당신은 이제 당신이 가장 좋아하는 API를 사용할 수 없는 가져오기일 뿐입니다.

00:04:41.000 --> 00:04:54.000
찾을 수 없는 모듈을 가져오려고 할 때, Xcode는 구성한 패키지 컬렉션의 패키지가 해당 모듈을 제공하는지 확인하고 해당 패키지 사용을 자동으로 시작할 수 있는 기회를 제공합니다.

00:04:54.000 --> 00:05:01.000
패키지를 사용하기로 선택하면, 모든 구성은 패키지 컬렉션의 정보를 기반으로 처리됩니다.

00:05:01.000 --> 00:05:08.000
패키지 컬렉션도 검색할 수 있어 사용 사례에 맞는 패키지를 쉽게 찾을 수 있습니다.

00:05:08.000 --> 00:05:18.000
오늘 패키지 컬렉션을 사용해 보는 데 관심이 있다면, Apple이 GitHub에 게시하는 Swift 패키지의 패키지 컬렉션을 포함하여 이미 사용할 수 있는 것들이 있습니다.

00:05:18.000 --> 00:05:23.000
Xcode는 Apple 컬렉션을 사용하기 위해 미리 배선되어 제공됩니다.

00:05:23.000 --> 00:05:34.000
커뮤니티에서 이미 구할 수 있는 컬렉션을 포함하여 패키지 컬렉션에 대해 더 알고 싶다면, 패키지 컬렉션에 대한 새로운 swift.org 블로그 게시물을 확인하세요.

00:05:34.000 --> 00:05:42.000
당신이 가장 좋아하는 API에 대해 말하자면, 애플은 성장하는 오픈 소스 스위프트 패키지 제품군을 출판합니다.

00:05:42.000 --> 00:05:48.000
당신이 가장 좋아하는 패키지에 대한 몇 가지 큰 개선 외에도, 올해, 우리는 네 개의 새로운 패키지를 더 출시했습니다.

00:05:48.000 --> 00:05:55.000
먼저, 스위프트 컬렉션에 대해 말씀드리고 싶습니다.

00:05:55.000 --> 00:06:04.000
스위프트 컬렉션은 스위프트 표준 라이브러리에서 사용할 수 있는 것을 보완하는 새로운 오픈 소스 데이터 구조 패키지입니다.

00:06:04.000 --> 00:06:16.000
Swift Collections의 초기 버전은 가장 자주 요청되는 세 가지 데이터 구조인 Deque, OrderedSet 및 OrderedDictionary에 대한 구현과 함께 제공됩니다.

00:06:16.000 --> 00:06:24.000
Deque는 양쪽 끝에서 효율적인 삽입과 제거를 지원한다는 점을 제외하고는 배열과 같다.

00:06:24.000 --> 00:06:29.000
OrderedSet은 배열과 세트의 강력한 하이브리드이다.

00:06:29.000 --> 00:06:34.000
배열과 마찬가지로, OrderedSet은 요소를 순서대로 유지하고 무작위 액세스를 지원합니다.

00:06:34.000 --> 00:06:43.000
세트와 마찬가지로, OrderedSet은 각 요소가 한 번만 나타나도록 하고 효율적인 멤버십 테스트를 제공합니다.

00:06:43.000 --> 00:06:52.000
그리고 마지막으로 OrderedDictionary는 순서가 중요하거나 요소에 대한 무작위 접근이 필요할 때 사전의 유용한 대안입니다.

00:06:52.000 --> 00:06:56.000
다음으로, 스위프트 알고리즘에 대해 이야기해 봅시다.

00:06:56.000 --> 00:07:03.000
스위프트 알고리즘은 시퀀스 및 컬렉션 알고리즘의 새로운 오픈 소스 패키지이다.

00:07:03.000 --> 00:07:29.000
우리는 이미 요소 컬렉션의 모든 조합이나 순열을 생성하거나, 시퀀스의 요소를 두 개 또는 세 개 또는 술어에 의해 결정된 그룹으로 반복하거나, 컬렉션에서 가장 작은 다섯 개의 요소, 가장 큰 다섯 개 또는 무작위로 다섯 개의 요소를 선택하는 것과 같은 것들을 위해 스위프트 알고리즘에 40개 이상의 알고리즘을 추가했습니다.

00:07:29.000 --> 00:07:38.000
어휘를 배우는 데는 약간의 투자가 필요하지만, 일단 그렇게 하면, 얼마나 많은 알고리즘이 눈에 잘 띄는지 발견하는 것은 놀라운 일이 될 수 있다.

00:07:38.000 --> 00:07:49.000
더 알고 싶다면, 새로운 스위프트 알고리즘 및 컬렉션 패키지가 코드를 더 명확하고, 빠르고, 정확하게 만드는 데 어떻게 도움이 될 수 있는지 설명하는 세션이 있습니다.

00:07:49.000 --> 00:07:51.000
이제, 스위프트 시스템에 대해 이야기해 봅시다.

00:07:51.000 --> 00:08:00.000
지난 가을, 우리는 시스템 호출에 관용적이고 낮은 수준의 인터페이스를 제공하는 라이브러리인 Swift System을 오픈 소스화했습니다.

00:08:00.000 --> 00:08:05.000
시스템은 애플 플랫폼, 리눅스, 심지어 윈도우에서도 사용할 수 있다.

00:08:05.000 --> 00:08:12.000
우리는 최근에 일반적인 경로 조작 작업을 수행하기 위해 시스템의 FilePath 유형에 강력한 새로운 API를 추가했습니다.

00:08:12.000 --> 00:08:21.000
여기에는 확장을 쿼리하거나 설정하고, 구성 요소를 추가 및 제거하고, 경로 정규화를 수행하는 기능이 포함됩니다.

00:08:21.000 --> 00:08:27.000
경로는 뿌리와 상대적인 구성 요소로 분해될 수 있다.

00:08:27.000 --> 00:08:38.000
FilePath의 ComponentView는 구조화된 경로 구성 요소의 모음입니다. 즉, 즉시 Swift의 많은 일반 알고리즘을 지원합니다.

00:08:38.000 --> 00:08:47.000
그리고 Windows를 대상으로 할 때, 복잡한 루트 구성 요소가 있는 Windows 경로는 모든 새로운 FilePath API에서 완벽하게 지원됩니다.

00:08:47.000 --> 00:08:51.000
다음으로, 스위프트 숫자에 대해 이야기해 봅시다.

00:08:51.000 --> 00:08:55.000
Swift Numerics는 올해 많은 큰 추가를 받았다.

00:08:55.000 --> 00:09:00.000
우리는 작년에 Float16을 iOS, tvOS 및 watchOS에 도입했습니다.

00:09:00.000 --> 00:09:09.000
올해, 우리는 Apple Silicon Mac에 Float16 지원과 Float16 기반 복소수를 만들 수 있는 기능을 추가했습니다.

00:09:09.000 --> 00:09:18.000
올해 또 다른 추가 사항은 로그, 사인, 코사인과 같은 모든 기본 함수에 대한 복잡한 숫자 지원이다.

00:09:18.000 --> 00:09:28.000
이러한 구현은 스위프트로 작성되기 때문에, 종종 전통적인 C 라이브러리보다 더 효율적이며 그렇지 않으면 불가능한 최적화를 허용합니다.

00:09:28.000 --> 00:09:32.000
마지막으로, Swift ArgumentParser에 대해 이야기해 봅시다.

00:09:32.000 --> 00:09:44.000
우리는 Fish shell에 대한 코드 완성 스크립트를 생성하는 기능, 짧은 옵션 가입 및 개선된 오류 메시지와 같은 향상된 기능을 통해 올해 Swift ArgumentParser를 계속 개선했습니다.

00:09:44.000 --> 00:09:53.000
우리는 또한 이번 봄에 ArgumentParser가 Xcode 12.5의 Swift Package Manager에 의해 채택되었을 때 중요한 이정표를 통과했습니다.

00:09:53.000 --> 00:09:54.000
맞아!

00:09:54.000 --> 00:10:01.000
최근에 Swift Package Manager 명령줄 도구를 사용했다면, Swift ArgumentParser를 사용했을 것입니다.

00:10:01.000 --> 00:10:07.000
다음으로, 서버 개발에서 Swift를 지원하기 위해 우리가 한 몇 가지 작업에 대해 이야기하고 싶습니다.

00:10:07.000 --> 00:10:12.000
작년에, 우리는 아마존 리눅스를 포함한 여러 플랫폼에 대한 지원을 추가했습니다.

00:10:12.000 --> 00:10:21.000
올해, 우리는 스위프트 서버 애플리케이션의 성능과 기능에 투자하여 그 작업을 추적했습니다.

00:10:21.000 --> 00:10:32.000
우리는 Linux에서 정적 연결을 활성화하여 애플리케이션 시작 시간을 개선하고 이제 단일 파일로 배포할 수 있는 서버 애플리케이션의 배포를 단순화하는 것으로 시작했습니다.

00:10:32.000 --> 00:10:44.000
또한, 스위프트 5.5에서 리눅스에서 사용되는 JSON 인코딩 및 디코딩은 처음부터 다시 구현되어 가장 일반적인 사용 사례에 대한 성능 향상을 가져왔다.

00:10:44.000 --> 00:10:51.000
마지막으로, 우리는 AWS Lambda 런타임 라이브러리 자체의 성능을 향상시키고 최적화했습니다.

00:10:51.000 --> 00:11:06.000
이 모든 작업을 통해 AWS Lambda에서 실행되는 Swift 프로그램은 33% 더 빠르게 시작되었으며, AWS API 게이트웨이를 통해 라우팅된 람다의 호출 시간이 40% 더 빨라졌습니다.

00:11:06.000 --> 00:11:16.000
AWS 런타임 라이브러리 성능을 최적화하는 것 외에도, 폐쇄 대신 새로운 비동기/대기 모델을 사용하도록 리팩토링했습니다.

00:11:16.000 --> 00:11:21.000
스위프트 개발자 경험을 개선하는 것은 스위프트 5.5의 또 다른 주요 초점이다.

00:11:21.000 --> 00:11:25.000
저는 문서에 대해 이야기하는 것으로 시작하고 싶습니다.

00:11:25.000 --> 00:11:33.000
훌륭한 문서를 제공하는 것은 프레임워크 사용자에게 부드럽고 즐거운 경험을 제공하는 데 중요합니다.

00:11:33.000 --> 00:11:45.000
올해, 우리는 개발자에게 Swift 프레임워크 또는 패키지를 사용하는 방법을 가르칠 수 있도록 Xcode 13에 깊이 통합된 문서 컴파일러인 DocC를 소개합니다.

00:11:45.000 --> 00:11:51.000
이제 훌륭한 문서를 작성하고 공유하는 것이 그 어느 때보다 쉬워졌습니다.

00:11:51.000 --> 00:12:04.000
DocC는 Swift 소스 코드의 마크다운 주석과 같이 이미 알고 좋아하는 도구와 기술을 사용하여 처음부터 구축되어 문서를 쉽게 작성하고 차이를 만들 수 있습니다.

00:12:04.000 --> 00:12:10.000
Xcode에서 DocC 문서의 모든 측면을 보여주는 네 개의 환상적인 세션이 있습니다.

00:12:10.000 --> 00:12:13.000
나는 네가 그것들을 확인해 보는 것을 강력히 추천한다.

00:12:13.000 --> 00:12:20.000
그리고 이제, 저는 Swift DocC가 올해 말에 오픈 소스가 될 것이라고 발표하게 되어 기쁩니다.

00:12:20.000 --> 00:12:30.000
오픈 소싱 스위프트 DocC는 개발자들이 스위프트가 지원하는 모든 플랫폼에서 훌륭한 문서를 더 쉽게 생성할 수 있게 해준다.

00:12:30.000 --> 00:12:36.000
스위프트 5.5에서, 우리는 유형 검사기에서 품질과 성능 개선에 투자했습니다.

00:12:36.000 --> 00:12:43.000
이것의 한 가지 결과는 코드를 컴파일할 때 "표현이 너무 복잡하다" 오류가 줄어든다는 것입니다.

00:12:43.000 --> 00:12:48.000
우리는 또한 배열 리터럴의 유형 검사를 위한 성능을 가속화했다.

00:12:48.000 --> 00:12:56.000
이번 릴리스에서, 우리는 또한 증분 빌드 속도를 높이기 위한 세 가지 주요 개선으로 개발자 생산성을 향상시키고 있습니다.

00:12:56.000 --> 00:13:06.000
우선, 우리는 이제 증분 가져오기를 지원합니다. 즉, 모듈이 변경될 때 모듈을 가져오는 모든 소스 파일을 더 이상 재구성하지 않습니다.

00:13:06.000 --> 00:13:15.000
또한, 우리는 이제 모듈 종속성 그래프를 미리 계산하여 변경된 것만의 증분 빌드를 빠르게 시작할 수 있습니다.

00:13:15.000 --> 00:13:25.000
마지막으로, 우리는 확장과 함께 작동하도록 선택적 재컴파일을 확장했는데, 이는 확장의 본문을 변경할 때 재컴파일이 적다는 것을 의미합니다.

00:13:25.000 --> 00:13:43.000
SwiftDriver 오픈 소스 프로젝트를 예로 들자면, 평균적으로 Swift 5.5의 증분 가져오기와 함께, 우리는 이제 가져온 모듈이 변경될 때 파일 수의 10분의 1 미만을 다시 컴파일하고, 빌드 시간은 약 3분의 1 감소합니다.

00:13:43.000 --> 00:13:52.000
증분 가져오기의 성능 개선은 이제 빌드 성능에 큰 불이익 없이 프로젝트를 모듈화하고 가져온 모듈을 변경할 수 있다는 것을 의미합니다.

00:13:52.000 --> 00:14:04.000
그리고 그건 그렇고, 이러한 성능 개선 중 일부는 스위프트로 작성될 컴파일러의 첫 번째 부분인 스위프트 프로젝트의 중요한 이정표에 의해 가능해졌다.

00:14:04.000 --> 00:14:10.000
이것은 스위프트 소스 코드의 편집을 조정하는 프로그램인 스위프트 드라이버입니다.

00:14:10.000 --> 00:14:17.000
이 프로젝트는 2019년 말에 시작되었으며, Xcode 13 현재 Swift 편집의 기본값입니다.

00:14:17.000 --> 00:14:27.000
마지막으로, 스위프트의 메모리 관리를 더 효율적으로 만들기 위해 개선한 사항에 대해 이야기해 봅시다. 그래서 스위프트 프로그램은 메모리를 더 빨리 회수합니다.

00:14:27.000 --> 00:14:37.000
스위프트 클래스 인스턴스는 자동 참조 계산, ARC를 사용하여 주어진 시간에 특정 객체에 대한 참조 수를 추적합니다.

00:14:37.000 --> 00:14:46.000
대부분의 경우, 이것은 메모리 관리가 스위프트에서 작동한다는 것을 의미하며, 메모리 관리에 대해 직접 생각할 필요가 없습니다.

00:14:46.000 --> 00:14:52.000
ARC는 해당 인스턴스가 더 이상 필요하지 않을 때 클래스 인스턴스에서 사용하는 메모리를 자동으로 확보합니다.

00:14:52.000 --> 00:15:04.000
이를 위해, 스위프트 컴파일러는 새 참조가 생성될 때마다 유지 작업을 삽입하고 새 참조가 사용 중지될 때마다 릴리스 작업을 삽입합니다.

00:15:04.000 --> 00:15:14.000
올해, 우리는 컴파일러가 유지 및 릴리스 작업의 수를 크게 줄일 수 있도록 컴파일러 내부의 참조를 추적하는 새로운 방법을 도입했습니다.

00:15:14.000 --> 00:15:20.000
우리는 이 변화로 인해 측정 가능한 성능과 코드 크기가 개선된 것을 보았습니다.

00:15:20.000 --> 00:15:30.000
Xcode 설정인 Optimize Object Lifetimes를 추가하면 이 새롭고 더 공격적인 ARC 최적화가 코드에 미치는 영향을 볼 수 있습니다.

00:15:30.000 --> 00:15:36.000
ARC에 대한 자세한 내용은 "ARC in Swift" 세션을 확인하세요.

00:15:36.000 --> 00:15:40.000
이것들은 스위프트 5.5가 당신에게 가져온 개선 사항 중 일부일 뿐입니다.

00:15:40.000 --> 00:15:46.000
다음으로, 팀은 스위프트 동시성과 스위프트 언어의 다른 진화에 대해 이야기할 것입니다.

00:15:46.000 --> 00:15:48.000
고마워, 니콜.

00:15:48.000 --> 00:15:59.000
우리 모두는 Swift Concurrency에 대해 매우 흥분하고 있지만, 그것에 도달하기 전에, 일상적인 프로그래밍을 단순화하고 개선하기 위해 Swift에 대한 몇 가지 다른 변경 사항에 대해 논의하고 싶습니다.

00:15:59.000 --> 00:16:02.000
여기 우리가 올해 만든 인체공학적 개선 사항 목록이 있습니다.

00:16:02.000 --> 00:16:06.000
SE 숫자는 신속한 진화 제안을 식별한다.

00:16:06.000 --> 00:16:16.000
이 제안들 각각은 커뮤니티 구성원에 의해 작성되었고, 스위프트 에볼루션 포럼에서 논의되었으며, 언어로 받아들여지기 전에 스위프트 코어 팀의 승인을 받았다.

00:16:16.000 --> 00:16:25.000
수락, 거부 또는 아직 논의 중인 모든 SE 제안은 GitHub의 Swift Evolution 저장소에서 찾을 수 있습니다.

00:16:25.000 --> 00:16:27.000
이 변화들 중 몇 가지를 살펴봅시다.

00:16:27.000 --> 00:16:30.000
첫째, 결과 빌더.

00:16:30.000 --> 00:16:39.000
SwiftUI가 처음 발표되었을 때, 복잡한 객체 계층을 빠르고 쉽게 설명하는 데 사용할 수 있는 새로운 구문을 도입했다.

00:16:39.000 --> 00:16:49.000
작년에, 그 구문은 다양한 맥락에서 더 쉽게 사용될 수 있도록 스위프트 에볼루션 프로세스를 통해 표준화되고 개선되었다.

00:16:49.000 --> 00:16:57.000
이 강력한 기술을 활용하고 싶다면, 우리는 특히 결과 빌더를 사용하는 데 전념하는 세션이 있습니다.

00:16:57.000 --> 00:17:04.000
코딩 가능한 프로토콜은 데이터를 직렬화하는 편리한 방법이지만, 오랫동안 주목할 만한 누락으로 어려움을 겪었습니다.

00:17:04.000 --> 00:17:07.000
이 두 케이스 열거형을 고려해 보세요.

00:17:07.000 --> 00:17:15.000
Codable에 부합하기 위해, 당신은 이 모든 상용구를 수동으로 구현해야 했다.

00:17:15.000 --> 00:17:22.000
이제, 당신은 코딩 가능한 적합성을 선언하기만 하면, 컴파일러가 당신을 위해 그 모든 일을 할 것입니다.

00:17:22.000 --> 00:17:26.000
우리는 또한 스위프트의 유형 검사기에 몇 가지 주요 개선을 했다.

00:17:26.000 --> 00:17:31.000
아시다시피, Swift의 유형 추론은 중복 유형 정보를 생략할 수 있다는 것을 의미합니다.

00:17:31.000 --> 00:17:37.000
여기서, Coffee.regular를 .regular로 줄일 수 있습니다.

00:17:37.000 --> 00:17:40.000
하지만 열거형과 같은 구조는 다른 방식으로도 표현된다.

00:17:40.000 --> 00:17:50.000
예를 들어, 프로토콜을 준수하는 유형 모음이 있고 API에서 해당 유형의 인스턴스를 사용하고 싶을 수 있습니다.

00:17:50.000 --> 00:18:00.000
이제 프로토콜에 몇 가지 정적 속성을 선언하여 Enums에 사용하는 것과 동일한 점 표기법을 사용하여 이러한 유형의 인스턴스를 참조할 수 있습니다.

00:18:00.000 --> 00:18:12.000
이것은 스위프트의 유형 검사기를 개선하여 .large와 같은 체인 속성 참조를 포함하여 일반적인 컨텍스트의 정적 속성에 대해 더 일반적으로 추론할 수 있습니다.

00:18:12.000 --> 00:18:23.000
이를 통해 라이브러리 작성자는 자연스럽고 사용하기 쉬운 Enum과 같은 API로 정교한 일반 데이터 모델을 구축할 수 있습니다.

00:18:23.000 --> 00:18:27.000
부동산 포장지 또한 올해 개선되었다.

00:18:27.000 --> 00:18:31.000
속성 래퍼는 속성에 일반적인 의미를 적용하기 위한 편리한 도구입니다.

00:18:31.000 --> 00:18:37.000
여러분 중 많은 사람들이 구조체에 @propertyWrapper 주석을 사용하여 자신의 속성 래퍼를 구현했습니다.

00:18:37.000 --> 00:18:42.000
다음은 속성이 비어 있지 않다는 요구 사항을 추가하는 예입니다.

00:18:42.000 --> 00:18:52.000
SE-0293의 구현으로, 동일한 속성 래퍼는 이제 기능 및 폐쇄 매개 변수에 사용할 수 있습니다.

00:18:52.000 --> 00:18:58.000
누적적으로, 언어에 대한 이러한 변화와 다른 변화는 많은 일반적인 코딩 문제를 단순화할 수 있다.

00:18:58.000 --> 00:19:03.000
간단한 SwiftUI 코드 샘플의 맥락에서 그것들을 함께 살펴봅시다.

00:19:03.000 --> 00:19:16.000
다음은 설정 배열을 보유하고 있는 단일 속성과 각 설정 옆에 토글이 있는 해당 설정 목록을 표시하는 본문을 가진 SwiftUI 뷰가 있습니다.

00:19:16.000 --> 00:19:22.000
이 코드를 검토하고 새로운 스위프트 5.5 기능이 어떻게 단순화할 수 있는지 봅시다.

00:19:22.000 --> 00:19:26.000
첫째, 그 Toggle() 이니셜라이저는 분명히 중복된다.

00:19:26.000 --> 00:19:40.000
이 중복은 필요했지만, 우리는 중복성을 고려할 수 있는 toggleStyle 수정자와 같은 포스트픽스 표현식을 둘러쌀 수 있도록 #if의 사용을 완화했습니다.

00:19:40.000 --> 00:19:46.000
SwiftUI는 또한 앞서 언급한 새로운 유형 검사기 개선 사항을 활용하기 위해 업데이트되었습니다.

00:19:46.000 --> 00:19:51.000
그래서 당신은 더 많은 곳에서 자연스러운 점 표기법을 사용할 수 있습니다.

00:19:51.000 --> 00:19:58.000
설정 배열에 대한 인덱스를 지정한 다음 클로저 내에서 배열을 인덱싱하는 것은 조금 어색합니다.

00:19:58.000 --> 00:20:01.000
우리는 차라리 그 가치들을 살펴보는 게 낫겠어.

00:20:01.000 --> 00:20:08.000
이제 투영된 바인딩을 목록 생성자에 직접 전달한 다음 배열 값을 반복할 수 있습니다.

00:20:08.000 --> 00:20:16.000
부동산 래퍼 인수에 대한 새로운 지원은 우리가 달러 기호로 폐쇄 인수를 작성할 수 있게 해주며, 이는 우리에게 폐쇄에 바인딩된 설정을 제공할 것이다.

00:20:16.000 --> 00:20:21.000
그것은 차례로 우리가 래핑된 값과 바인딩 모두에 접근할 수 있게 해준다.

00:20:21.000 --> 00:20:33.000
그리고 마지막으로, Swift 컴파일러는 이제 CGFloat와 Double 사이를 투명하게 변환하여 Apple 플랫폼 API로 작업할 때 많은 중복 숫자 변환을 제거할 수 있습니다.

00:20:33.000 --> 00:20:46.000
보시다시피, 핵심 언어를 다듬기 위한 우리의 지속적인 노력은 당신이 매일 작성하는 코드를 그 어느 때보다 간단하게 만들고 도서관 작성자가 풍부하고 사용하기 쉬운 API를 구축할 수 있는 더 많은 기회를 창출하는 것입니다.

00:20:46.000 --> 00:20:54.000
올해 SwiftUI 프로그래밍이 개선된 여러 가지 방법에 대한 자세한 내용은 "SwiftUI의 새로운 기능" 세션을 시청하십시오.

00:20:54.000 --> 00:21:03.000
물론, 스위프트 5.5의 하이라이트는 비동기 및 동시 프로그래밍을 지원하는 연동 기능 세트이다.

00:21:03.000 --> 00:21:10.000
잠시 후에 이것들을 소개하겠지만, 먼저, "비동기"와 "동시"가 무슨 뜻인지 간단히 설명하겠습니다.

00:21:10.000 --> 00:21:15.000
소프트웨어 프로젝트는 어떤 순서로 실행되는 코드 블록으로 구성되어 있다.

00:21:15.000 --> 00:21:20.000
가장 간단한 경우, 그 블록들은 간단한 순서로 차례로 실행된다.

00:21:20.000 --> 00:21:22.000
하지만 다른 구조들도 흔하다.

00:21:22.000 --> 00:21:29.000
예를 들어, 네트워킹 API는 종종 비동기 스타일로 설계되었습니다.

00:21:29.000 --> 00:21:37.000
이러한 API에서는 원격 서버에 요청을 보낸 후 응답을 받고 더 많은 작업을 수행해야 할 때까지 오랜 지연이 있을 수 있습니다.

00:21:37.000 --> 00:21:46.000
이상적으로, 당신의 코드는 이 지연 동안 중단될 것이므로 응답에 대해 조치를 취할 수 있을 때까지 어떤 자원도 사용하지 않습니다.

00:21:46.000 --> 00:21:54.000
대조적으로, 동시 코드는 동시에 실행하고 싶은 두 개 이상의 코드 블록이 있을 때입니다.

00:21:54.000 --> 00:21:57.000
이것들은 종종 독립적이지만 관련된 작업이다.

00:21:57.000 --> 00:22:07.000
예를 들어, 비디오의 여러 프레임을 처리하거나 이전 결과 세트로 UI를 업데이트하는 동시에 ML 분류기의 다음 반복을 실행합니다.

00:22:07.000 --> 00:22:17.000
이러한 아이디어를 염두에 두고, 스위프트의 새로운 기능을 사용하지 않고 간단한 비동기 프로그래밍 예를 살펴봅시다.

00:22:17.000 --> 00:22:24.000
iOS 또는 macOS 프로그래밍을 많이 했다면, 이와 유사한 코드를 여러 번 작성했을 수도 있습니다.

00:22:24.000 --> 00:22:27.000
이것은 재단의 URLSession 클래스를 사용하여 네트워크 호출을 합니다.

00:22:27.000 --> 00:22:30.000
dataTask 방법은 비동기 작업이다.

00:22:30.000 --> 00:22:32.000
당신은 그것을 폐쇄 논쟁으로 부릅니다.

00:22:32.000 --> 00:22:37.000
결과를 사용할 수 있게 되면, 당신의 폐쇄는 처리할 결과와 함께 호출될 것입니다.

00:22:37.000 --> 00:22:47.000
비동기 코드를 표현하기 위해 이러한 방식으로 클로저를 사용하면 이 코드를 통해 볼 수 있듯이 다소 어색한 작업 순서가 발생합니다.

00:22:47.000 --> 00:22:53.000
먼저, 초기 설정이 있으며, dataTask 방법은 우리에게 작업 핸들을 돌려줍니다.

00:22:53.000 --> 00:22:57.000
그런 다음 백그라운드 작업을 시작하기 위해 작업 핸들을 재개합니다.

00:22:57.000 --> 00:23:01.000
fetchImage 함수는 실제로 이 시점에서 반환됩니다.

00:23:01.000 --> 00:23:08.000
우리에게 전화한 사람은 우리가 요청받은 일을 실제로 하지 않았음에도 불구하고 계속할 준비가 되어 있어야 한다.

00:23:08.000 --> 00:23:13.000
나중에, 네트워크 운영이 끝난 후, 이 폐쇄는 결과를 처리할 기회를 갖게 될 것이다.

00:23:13.000 --> 00:23:20.000
바라건대, 모든 것이 잘 되길 바라며, 우리는 최종 결과와 함께 완료 핸들러에게 전화할 수 있습니다.

00:23:20.000 --> 00:23:28.000
다소 어색한 실행 순서 외에도, 완료 핸들러를 사용하면 시도/캐치 오류 처리를 사용할 수 없습니다.

00:23:28.000 --> 00:23:38.000
dataTask가 완료 핸들러에 추가 오류 매개 변수를 제공하는 방법과 가능한 모든 오류에 대해 완료 핸들러를 호출해야 하는 방법에 주목하십시오.

00:23:38.000 --> 00:23:44.000
스위프트 5.5가 이것을 어떻게 개선하는지 보려면, 이 한 줄의 코드를 살펴봅시다.

00:23:44.000 --> 00:23:51.000
이 호출이 백그라운드 작업을 나타내는 추상 핸들인 작업을 어떻게 반환하는지 주목하세요.

00:23:51.000 --> 00:23:53.000
그건 정말 우리가 원하는 게 아니야.

00:23:53.000 --> 00:23:55.000
우리는 그저 데이터를 얻고 싶을 뿐이야.

00:23:55.000 --> 00:23:59.000
그러니 그 아이디어를 조금 밀어붙이고 우리가 어디로 가는지 보자.

00:23:59.000 --> 00:24:03.000
우리가 HTTP를 다루고 있기 때문에, 우리는 또한 일부 응답 메타데이터를 캡처해야 한다.

00:24:03.000 --> 00:24:11.000
그래서 그 함수는 실제로 한 쌍을 반환할 것이며, 실제 데이터는 첫 번째 항목이고 추가 정보는 두 번째 항목이다.

00:24:11.000 --> 00:24:21.000
이것을 데이터를 반환하는 함수 호출로 구조화함으로써, 우리는 이제 try/catch 오류 처리를 사용하여 이전 예제에서 많은 상용구를 제거할 수 있습니다.

00:24:21.000 --> 00:24:34.000
우리는 컴파일러에게 데이터 메소드가 시작되자마자 함수가 일시 중지될 수 있으며 그 작업이 완료될 때까지 할당을 완료할 수 없다는 것을 알리기 위해 약간의 구문이 필요합니다.

00:24:34.000 --> 00:24:37.000
그것이 바로 새로운 await 키워드가 하는 일이다.

00:24:37.000 --> 00:24:40.000
그것을 맥락에서 살펴봅시다.

00:24:40.000 --> 00:24:43.000
우리의 fetchImage 기능은 다음과 같습니다.

00:24:43.000 --> 00:24:46.000
보시다시피, 이 코드는 이제 따라하기가 훨씬 쉬워졌습니다.

00:24:46.000 --> 00:24:53.000
제어는 위에서 아래로 흐르며, 우리는 더 이상 중첩된 클로저가 필요하지 않으며, try/catch 오류 처리를 사용할 수 있습니다.

00:24:53.000 --> 00:25:05.000
Await 키워드는 이 fetchImage 기능이 일시 중지될 수 있는 지점을 나타내며, 계속할 수 있는 이벤트가 발생할 때까지 실행되지 않도록 따로 설정합니다.

00:25:05.000 --> 00:25:15.000
이 경우, URLSession이 요청을 시작하자마자, 작업이 다른 곳에서 수행되는 동안 Swift 런타임에 의해 기능이 일시 중지됩니다.

00:25:15.000 --> 00:25:23.000
최종 결과가 준비되면, 그것이 성공적인 응답이든 던져진 오류이든, 오직 그때만 우리의 기능이 재개될 것이다.

00:25:23.000 --> 00:25:28.000
성공적인 응답이라면, 우리는 데이터와 응답 변수의 초기화를 완료할 것이다.

00:25:28.000 --> 00:25:32.000
만약 그것이 던져진 오류라면, 우리는 그것을 우리에게 전화한 사람에게 돌려줄 것이다.

00:25:32.000 --> 00:25:37.000
비동기 함수는 일시 중지되는 동안 어떤 자원도 사용하지 않는다.

00:25:37.000 --> 00:25:40.000
특히, 그것은 실을 막고 있지 않다.

00:25:40.000 --> 00:25:46.000
이것은 스위프트 런타임이 이 기능이 다른 작업을 위해 실행되고 있던 스레드를 재사용할 수 있게 해준다.

00:25:46.000 --> 00:25:52.000
이것은 많은 비동기 프로세스 사이에서 극소수의 스레드를 공유할 수 있게 해준다.

00:25:52.000 --> 00:25:58.000
구문적으로, 비동기 및 대기 키워드는 던지고 시도하는 데 비슷하게 사용된다.

00:25:58.000 --> 00:26:05.000
비동기 함수는 이 함수가 정지를 지원하기 위해 컴파일되어야 함을 나타내기 위해 함수 선언을 장식한다.

00:26:05.000 --> 00:26:11.000
Await 키워드를 사용하여 비동기 함수, 메서드 또는 클로저에 대한 호출을 표시하십시오.

00:26:11.000 --> 00:26:15.000
물론, 전체 메커니즘은 내가 여기서 보여준 것보다 훨씬 더 흥미롭다.

00:26:15.000 --> 00:26:23.000
"Meet async/await in Swift"와 "Swift concurrency: Behind the scenes" 세션을 시청하여 이 모든 것이 어떻게 작동하는지 자세히 알아볼 수 있습니다.

00:26:23.000 --> 00:26:30.000
다음으로, 제가 방금 설명한 비동기/대기 개념을 기반으로 하는 스위프트의 새로운 동시성 지원을 살펴보겠습니다.

00:26:30.000 --> 00:26:35.000
여기 세 개의 다른 이미지를 렌더링한 다음 결합하는 기능이 있습니다.

00:26:35.000 --> 00:26:39.000
여기에 쓰여진 바와 같이, 이 작업들은 순차적이다.

00:26:39.000 --> 00:26:48.000
배경, 전경 및 제목 이미지는 차례로 렌더링되며, 각각은 이전 이미지가 완료된 후에만 시작됩니다.

00:26:48.000 --> 00:26:51.000
우리는 렌더링 작업이 병렬로 이루어지기를 바랍니다.

00:26:51.000 --> 00:27:00.000
하지만 그것들을 다른 스레드에서 실행하는 것만으로는 충분하지 않습니다: 우리는 또한 세 가지 결과를 모두 얻을 때까지 병합 작업을 보류해야 합니다.

00:27:00.000 --> 00:27:04.000
이것은 어떤 면에서 내가 방금 말했던 비동기 코딩과 비슷하다.

00:27:04.000 --> 00:27:11.000
그래서 우리는 이 기능을 "비동기"로 표시하여 다른 스레드에서 계산되는 결과를 기다려야 하는 경우 일시 중지할 수 있도록 합니다.

00:27:11.000 --> 00:27:17.000
다음으로, 우리는 비동기 let 구문을 사용하여 처음 두 작업을 병렬로 실행합니다.

00:27:17.000 --> 00:27:22.000
비동기 let는 변수 초기화처럼 보이며, 그것은 기본적으로 그것이다.

00:27:22.000 --> 00:27:28.000
하지만 이 초기화는 결과를 사용하려고 할 때까지 다른 코드와 병렬로 실행됩니다.

00:27:28.000 --> 00:27:40.000
백그라운드와 포그라운드 변수가 비동기 let로 초기화되고 있기 때문에, 스위프트의 런타임은 필요한 경우 해당 값이 준비될 때까지 병합 작업을 중단할 것이다.

00:27:40.000 --> 00:27:46.000
우리는 이것을 나타내기 위해 await 키워드로 병합 기능을 표시합니다.

00:27:46.000 --> 00:27:52.000
이 코드의 가장 중요한 점은 백그라운드 작업이 이 기능을 능가할 수 없다는 것이다.

00:27:52.000 --> 00:28:00.000
다시 말해, 이 함수는 두 개의 백그라운드 작업 중 하나가 여전히 실행 중인 경우 반환할 수 없으며 반환되지 않을 것이다.

00:28:00.000 --> 00:28:07.000
이 함수 내부의 어느 곳에서나 오류가 발생하면, 스위프트 런타임은 여전히 백그라운드 작업이 완료될 때까지 기다릴 것이다.

00:28:07.000 --> 00:28:17.000
여기서, 제목 이미지의 계산이 던질 수 있음을 나타내는 시도 마커를 강조했지만, 별도의 스레드에서 발생하더라도 모든 던진 오류에도 동일하게 적용됩니다.

00:28:17.000 --> 00:28:25.000
반응을 유지하기 위해, 던져진 오류가 있을 때, 스위프트 런타임은 미완성 작업에 신호를 보내 일찍 완료할 수 있는 기회를 줄 것이다.

00:28:25.000 --> 00:28:36.000
구조화된 동시성에 대한 우리의 세션은 이 취소 메커니즘에 대한 전체 토론과 내가 여기서 논의한 비동기 렛 구문에 대한 보다 유연한 대안을 포함하여 더 많은 세부 사항을 제공합니다.

00:28:36.000 --> 00:28:45.000
이전 섹션에서, 나는 스위프트 5.5가 어떻게 훈련되고 구조화된 방식으로 여러 스레드에서 작업을 쉽게 실행할 수 있는지 보여주었다.

00:28:45.000 --> 00:28:48.000
물론, 그건 충분하지 않아.

00:28:48.000 --> 00:28:55.000
두 개의 개별 스레드가 데이터를 공유할 때마다, 데이터가 일관성이 없거나 심지어 손상될 위험이 있습니다.

00:28:55.000 --> 00:28:59.000
스위프트의 새로운 배우 구성은 그러한 문제로부터 데이터를 보호하는 데 도움을 줍니다.

00:28:59.000 --> 00:29:04.000
다시 말하지만, 당신이 직접 작성했을 수도 있는 코드의 예부터 시작합시다.

00:29:04.000 --> 00:29:06.000
여기 통계를 수집하는 수업이 있습니다.

00:29:06.000 --> 00:29:14.000
그것은 카운터를 포함하고 있으며, 다양한 다른 코드는 흥미로운 일이 일어날 때마다 그 카운터를 업데이트하기 위해 증가 방법을 호출할 것이다.

00:29:14.000 --> 00:29:18.000
안타깝게도, 이 코드는 멀티스레드 시스템에서 잘 작동하지 않습니다.

00:29:18.000 --> 00:29:24.000
두 개 이상의 스레드가 동시에 증가 방법을 호출하면, 심하게 손상된 카운트로 끝날 수 있습니다.

00:29:24.000 --> 00:29:30.000
이 클래스를 스위프트 배우로 바꾸는 것은 그러한 부패로부터 보호한다.

00:29:30.000 --> 00:29:37.000
배우들은 특정 변경을 하는 것이 안전할 때까지 데이터 손상을 일으킬 수 있는 모든 작업을 중단함으로써 일한다.

00:29:37.000 --> 00:29:44.000
이것은 당신이 일반적으로 배우 외부에서 배우 방법을 부를 때 await를 사용해야 한다는 것을 의미합니다.

00:29:44.000 --> 00:29:47.000
배우들은 또한 비동기/기다림과 원활하게 작동한다.

00:29:47.000 --> 00:29:53.000
이 게시 방법을 비동기로 표시하면 네트워크 작업을 기다리는 동안 일시 중지할 수 있습니다.

00:29:53.000 --> 00:30:01.000
중단되는 동안, 다른 방법은 네트워크 작업이 완료될 때까지 기다리지 않고 데이터 손상의 위험 없이 이 액터에서 실행할 수 있습니다.

00:30:01.000 --> 00:30:10.000
액터들은 클래스와 같은 참조 유형이지만, 액터가 멀티스레드 환경에서 안전하게 사용할 수 있도록 설계된 많은 규칙을 준수합니다.

00:30:10.000 --> 00:30:22.000
데이터를 액터로 패키징함으로써, 당신은 이 데이터가 동시에 액세스될 것으로 예상하고 스위프트 컴파일러와 런타임이 손상을 방지하여 액세스를 조정하기를 원한다는 것을 분명히 말하고 있습니다.

00:30:22.000 --> 00:30:27.000
그리고, 물론, 우리는 스위프트의 새로운 배우 구성에 전념하는 전체 세션을 가지고 있다.

00:30:27.000 --> 00:30:32.000
그곳에서, 당신은 이것이 제공하는 모든 기능을 활용하는 방법을 찾을 수 있습니다.

00:30:32.000 --> 00:30:39.000
마무리하기 전에, 스위프트의 미래에 대해 조금 이야기해 봅시다.

00:30:39.000 --> 00:30:51.000
우리는 스위프트 5.5에서 도입한 비동기 함수, 구조화된 동시성 및 액터의 세 가지 핵심 개념이 안전하고 고성능 코드를 만들기 위한 좋은 기초라고 믿습니다.

00:30:51.000 --> 00:31:02.000
스위프트 6의 경우, 우리는 이미 컴파일러가 개발 프로세스 초기에 더 많은 종류의 동시성 실수를 포착하고 이러한 문제를 해결하는 데 더 자세한 오류와 지침을 제공하는 방법을 연구하고 있습니다.

00:31:02.000 --> 00:31:15.000
우리의 목표는, 간단히 말해서, 비동기 및 동시 프로그래밍을 다른 종류의 프로그래밍보다 더 복잡하지 않게 하기 위해 가장 일반적인 종류의 동시성 버그를 완전히 제거하는 것입니다.

00:31:15.000 --> 00:31:27.000
그리고 물론, 우리가 이러한 개념에 대한 컴파일러의 이해를 계속 개선함에 따라, 우리는 또한 이러한 새로운 구조를 사용하는 코드가 오늘날보다 훨씬 더 효율적이 될 것으로 기대합니다.

00:31:27.000 --> 00:31:32.000
스위프트는 당신의 의견을 환영하는 개방적이고 협력적인 노력입니다.

00:31:32.000 --> 00:31:37.000
스위프트 6를 더 좋게 만들기 위해, 스위프트 5.5에 대한 당신의 경험에 대해 말해주세요.

00:31:37.000 --> 00:31:42.000
이 새로운 기능들은 실제 앱 개발에서 얼마나 잘 작동하나요?

00:31:42.000 --> 00:31:45.000
Swift.org에서 찾을 수 있는 컴파일러 스냅샷 중 하나를 사용해 보세요.

00:31:45.000 --> 00:31:52.000
우리는 이러한 스냅샷을 제공하여 Xcode에 설치하고 개발할 때 새로운 기능을 사용해 볼 수 있습니다.

00:31:52.000 --> 00:31:57.000
이 스냅샷을 사용하면 다음 버전의 스위프트를 안내할 수 있습니다.

00:31:57.000 --> 00:32:01.000
스위프트 포럼은 그 프로젝트의 생명선이다.

00:32:01.000 --> 00:32:09.000
내가 논의한 각 기능은 다양한 그룹의 사람들이 그것을 작업 제안으로 다듬는 데 도움을 준 스위프트 에볼루션 포럼에서 투구함으로써 삶을 시작했다.

00:32:09.000 --> 00:32:19.000
우리는 또한 새로운 사용자를 위한 도움말 영역과 스위프트 커뮤니티에 관심 있는 뉴스를 교환할 수 있는 장소를 포함하여 스위프트의 다른 많은 측면에 전념하는 포럼을 가지고 있습니다.

00:32:19.000 --> 00:32:29.000
스위프트를 더 좋게 만들 수 있는 다른 많은 방법이 있으며, 우리는 니콜이 이 세션을 시작할 때 언급한 새로운 멘토링 프로그램을 통해 더 많은 사람들을 참여시키고자 합니다.

00:32:29.000 --> 00:32:35.000
유일한 요구 사항은 우리 지역 사회의 모든 사람들을 위해 스위프트를 개선하는 데 도움을 주고자 하는 진심 어린 열망이다.

00:32:35.000 --> 00:32:38.000
저는 당신의 소식을 듣기를 기대하고 있으며, 당신이 회의를 즐기길 바랍니다.

00:32:38.000 --> 23:59:59.000
[쾌활한 음악].

