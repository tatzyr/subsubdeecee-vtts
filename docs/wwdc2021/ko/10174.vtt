WEBVTT

00:00:00.000 --> 00:00:11.000
안녕하세요, WWDC에 오신 것을 환영합니다.

00:00:11.000 --> 00:00:22.000
저는 토리이고, 당신의 서버를 위한 새로운 기능에 대해 이야기하고 모든 인앱 구매의 상태를 추적하기 위해 효과적인 서버를 실행하기 위한 몇 가지 지침을 설정하는 데 도움을 드리게 되어 매우 기쁩니다.

00:00:22.000 --> 00:00:24.000
그럼, 바로 뛰어들자.

00:00:24.000 --> 00:00:30.000
이 세션은 인앱 구매에 초점을 맞춘 세 세션 시리즈의 두 번째 부분이다.

00:00:30.000 --> 00:00:39.000
"StoreKit 2 만나기" 또는 "고객 지원 및 환불 처리"를 아직 시청하지 않았다면, 전체 이야기를 얻을 수 있도록 이 세션을 살펴보는 것이 좋습니다.

00:00:39.000 --> 00:00:46.000
이 세션에서, 우리는 서버와 인앱 구매를 관리하기 위해 서버를 구축하는 방법에 초점을 맞출 것입니다.

00:00:46.000 --> 00:00:52.000
이 세션을 시작하기 위해, 먼저 서버를 갖는 것이 유용한 몇 가지 이유에 대해 이야기해 봅시다.

00:00:52.000 --> 00:00:59.000
서버를 갖는 것은 여러 가지 이유로 유용하며, 인앱 구매의 경우, 대부분은 추적 상태를 중심으로 진행됩니다.

00:00:59.000 --> 00:01:14.000
서버가 있는 경우, 앱 내 구매 중 하나의 상태가 App Store 서버 알림을 통해 변경될 때 실시간으로 알릴 수 있으며, 주문형으로 전화하여 서버 간 API를 사용하여 언제든지 상태를 확인할 수 있습니다.

00:01:14.000 --> 00:01:29.000
서버가 있으면 장치가 오프라인 상태이거나 앱 외부에서 상태가 변경되더라도 콘텐츠에 대한 고객 액세스를 검증할 수 있으므로 고객이 갱신 후에도 여전히 구독 중인지 또는 게임에서 구매한 동전이 환불되었는지 알 수 있습니다.

00:01:29.000 --> 00:01:34.000
이미 서버를 가지고 있다면, 이러한 이유 중 일부 이유로 서버를 설정했을 수도 있습니다.

00:01:34.000 --> 00:01:41.000
서버가 없고 서버를 구축할 생각이라면, 콘텐츠를 더 잘 제어할 수 있기 때문에 고려해야 할 강력한 이유가 있습니다.

00:01:41.000 --> 00:01:48.000
서버가 있더라도, 우리의 이야기는 여전히 iPhone, iPad 또는 인앱 구매가 있는 다른 장치에서 시작됩니다.

00:01:48.000 --> 00:02:02.000
transactionId, originalTransactionId 및 영수증과 같은 것을 포함하여 해당 구매에 대한 정보를 서버로 보내면, 이제 서버와 직접 통신하여 서버에서 해당 구매를 추적할 수 있습니다.

00:02:02.000 --> 00:02:08.000
오늘날, 이것은 verifyReceipt와 같은 API 또는 App Store 서버 알림과 같은 프레임워크를 사용하는 것을 포함한다.

00:02:08.000 --> 00:02:13.000
우리는 당신을 위해 서버와의 통합을 더 좋게 만들고 싶을 뿐이며, 이는 우리를 오늘날의 콘텐츠로 이끙게 합니다.

00:02:13.000 --> 00:02:22.000
서버 측의 모든 변경 사항과 더 좋고 강력한 서버를 구축하기 위해 이것들과 통합할 수 있는 방법을 검토하겠습니다.

00:02:22.000 --> 00:02:36.000
우선, App Store 영수증으로 액세스를 검증하고, App Store Server API로 상태를 추적한 다음, App Store 서버 알림으로 수동적으로 상태를 추적할 수 있는 방법에 대해 자세히 알아보겠습니다.

00:02:36.000 --> 00:02:45.000
나는 또한 이것이 가족 공유를 관리하는 데 무엇을 의미하는지, 그리고 샌드박스에서 서버를 테스트할 수 있는 방법을 살펴볼 것이다.

00:02:45.000 --> 00:02:49.000
영수증을 사용하여 상태 검증을 시작합시다.

00:02:49.000 --> 00:02:52.000
오늘, 우리의 영수증은 통합 앱 영수증 형식입니다.

00:02:52.000 --> 00:03:04.000
영수증의 JSON 버전을 받으려면, 앱에서 장치 내 영수증 확인을 수행하거나 서버에 대해 이야기하고 있기 때문에 서버 간 verifyReceipt 엔드포인트를 호출해야 합니다.

00:03:04.000 --> 00:03:16.000
서버 대 서버로 전화하면, 이 디코딩된 영수증과 latest_receipt_info 섹션의 새로운 거래, pending_renewal_info 섹션의 다가오는 갱신 정보 및 latest_receipt를 받게 됩니다.

00:03:16.000 --> 00:03:27.000
이 영수증은 거대할 수 있으며, 비소모품, 소모품, 구독 또는 비갱신 구독이든 전체 앱의 거래가 포함되어 있습니다.

00:03:27.000 --> 00:03:32.000
이것은 당신에게 많은 정보를 제공하지만, 우리는 그것이 너무 많을 수 있는지 궁금합니다.

00:03:32.000 --> 00:03:45.000
또한, StoreKit 2를 통해, 우리는 JWS 또는 JSON 웹 서명, 클라이언트 측의 형식에 새로운 서명된 거래를 도입하고 있으며, 서버에서 동일한 것을 제공하고자 합니다.

00:03:45.000 --> 00:03:47.000
왜 우리는 서명된 거래를 도입하기로 결정했나요?

00:03:47.000 --> 00:03:49.000
애플에서, 우리는 보안에 관심이 있다.

00:03:49.000 --> 00:03:57.000
JWS를 사용하여 이러한 거래에 서명하면 서명 및 서명 확인을 통해 보안이 강화됩니다.

00:03:57.000 --> 00:04:06.000
또한, 거래는 디코딩하고 확인하기가 쉽기 때문에, 저희에게 전화하지 않고도 서버에서 할 수 있습니다.

00:04:06.000 --> 00:04:09.000
지금 이 서명된 거래들을 살펴봅시다.

00:04:09.000 --> 00:04:13.000
우리가 서명한 거래는 기간으로 구분된 세 개의 문자열로 구성되어 있다.

00:04:13.000 --> 00:04:21.000
첫 번째 문자열은 base64로 인코딩된 JSON 헤더이며, 그 다음에는 base64로 인코딩된 JSON 페이로드이며, 그 다음에 서명이 있습니다.

00:04:21.000 --> 00:04:28.000
Base64가 헤더를 디코딩하면, 우리가 사용한 서명 알고리즘과 x5C 클레임이 포함되어 있습니다.

00:04:28.000 --> 00:04:32.000
여기에는 서명을 확인하는 데 필요한 인증서 체인이 포함되어 있습니다.

00:04:32.000 --> 00:04:34.000
우리는 잠시 후에 서명을 다시 확인할 것이다.

00:04:34.000 --> 00:04:40.000
다음으로, base64가 페이로드를 디코딩하면, 영수증 JSON을 볼 수 있습니다.

00:04:40.000 --> 00:04:50.000
즉, 트랜잭션을 디코딩하기 위해 해야 할 일은 base64 페이로드를 디코딩하는 것뿐입니다. 이는 서버에서 직접 수행할 수 있는 간단한 작업입니다.

00:04:50.000 --> 00:04:52.000
디코딩된 거래를 빠르게 살펴봅시다.

00:04:52.000 --> 00:05:01.000
그냥 쳐다본다면, 일부 데이터 유형이 이전 영수증의 문자열에서 숫자나 부울과 같은 더 적절한 데이터 유형으로 바뀌었다는 것을 알 수 있습니다.

00:05:01.000 --> 00:05:06.000
또한 우리가 시대 이후로 날짜 형식을 단 1밀리초로 줄였다는 것을 주목하세요.

00:05:06.000 --> 00:05:09.000
우리는 또한 몇 가지 새로운 필드를 추가했습니다.

00:05:09.000 --> 00:05:13.000
거래가 적용되는 콘텐츠 유형을 알려주는 "유형"이라는 필드를 추가했습니다.

00:05:13.000 --> 00:05:17.000
우리는 또한 "appAccountToken"이라는 필드를 추가했습니다.

00:05:17.000 --> 00:05:26.000
StoreKit 2 앱의 구매 시간에 StoreKit에 이 값을 제공할 때, 우리는 각 거래에서 반환하기 위해 서버에 유지합니다.

00:05:26.000 --> 00:05:35.000
우리는 또한 새로운 서명된 거래뿐만 아니라 각 거래에 대한 기존 통합 앱 영수증에서도 이것을 반환할 것입니다.

00:05:35.000 --> 00:05:40.000
내가 여기서 부르고 싶은 다음 두 분야는 정말 새로운 것이 아니라, 오히려 이름이 바뀌었다.

00:05:40.000 --> 00:05:52.000
우리는 이러한 필드의 존재가 취소일 기준으로 서비스가 취소되어야 함을 더 명확하게 하기 위해 cancellation_date와 cancellation_reason를 revocation_date와 revocation_reason로 개명했습니다.

00:05:52.000 --> 00:05:59.000
이 마지막 두 분야는 새로 보일 수 있지만 실제로 이전 영수증의 일부 정보를 단순화한 것입니다.

00:05:59.000 --> 00:06:10.000
우리는 isTrialPeriod, isIntroOfferPeriod, promotionalOfferIdentifier 및 offerCodeRefName을 offerType 및 offerIdentifier로 결합했습니다.

00:06:10.000 --> 00:06:21.000
offerType은 고객이 이 기간에 어떤 유형의 제안을 적용했는지 알려주며, 소개 제안은 1개, 구독 제안은 2개, 제안 코드는 3개입니다.

00:06:21.000 --> 00:06:30.000
제안 유형이 2 또는 3인 경우, 프로모션 제안 ID 또는 offerCodeRefName과 함께 제안 식별자 필드에 값을 볼 수 있습니다.

00:06:30.000 --> 00:06:35.000
이제, 저는 서명된 거래 정보의 서명 부분을 확인하는 것에 대해 이야기하고 싶습니다.

00:06:35.000 --> 00:06:41.000
서명을 확인하는 것은 거래가 Apple에서 왔고 신뢰할 수 있는지 확인할 수 있는 옵션입니다.

00:06:41.000 --> 00:06:46.000
거래 내용만 보고 싶다면, 이 단계는 필요하지 않습니다.

00:06:46.000 --> 00:06:54.000
그러나 서명을 확인하려면 서명된 거래 정보의 헤더 부분에서 사용할 수 있는 클레임을 사용해야 합니다.

00:06:54.000 --> 00:07:03.000
Alg 클레임을 사용하여 우리가 사용한 서명 알고리즘을 알고, x5c 클레임의 배열에서 인증서 체인을 사용하세요.

00:07:03.000 --> 00:07:10.000
이 두 가지를 갖게 되면, 가장 좋아하는 암호화 라이브러리를 사용하여 서명된 거래 정보의 서명을 확인할 수 있습니다.

00:07:10.000 --> 00:07:18.000
그래서 그것은 App Store 영수증에 대한 변경 사항 또는 우리가 지금 부르는 것처럼 서명된 거래를 다룹니다.

00:07:18.000 --> 00:07:21.000
이제, API로 상태를 확인하는 방법에 대해 넘어가겠습니다.

00:07:21.000 --> 00:07:33.000
따라서 서명된 거래의 유효성을 확인하거나 거래를 디코딩하기 위해 오늘날의 verifyReceipt와 같은 API가 필요하지 않지만, 우리는 여전히 서버에서 당신을 도울 수 있는 API를 구축하고 싶었습니다.

00:07:33.000 --> 00:07:47.000
그렇기 때문에 우리는 올해 WWDC에서 이전에 서버에서 사용할 수 없었던 몇 가지 새로운 기능을 제공하고 새로운 서명된 거래를 사용할 수 있는 App Store Server API의 새로운 라이브러리를 소개합니다.

00:07:47.000 --> 00:07:55.000
그래서 우리는 지금 두 개의 새로운 API에 대해 이야기할 것입니다: 구독 상태 API와 인앱 구매 내역 API.

00:07:55.000 --> 00:07:58.000
먼저, 구독 상태 API에 대해 이야기하고 싶습니다.

00:07:58.000 --> 00:08:07.000
구독 상태 API는 앱의 originalTransactionId로 표시된 자동 갱신 구독의 최신 상태를 제공합니다.

00:08:07.000 --> 00:08:12.000
이 API를 사용하면 구독자의 상태에 대한 빠른 답변을 얻을 수 있습니다.

00:08:12.000 --> 00:08:19.000
한 번의 간단한 확인으로 구독이 활성 상태인지, 만료되었는지, 유예 기간 또는 다른 상태인지 빠르게 알 수 있습니다.

00:08:19.000 --> 00:08:21.000
지금 한 번 보자.

00:08:21.000 --> 00:08:27.000
이 API에 대한 요청은 간단하며, URL에 originalTransactionId만 필요합니다.

00:08:27.000 --> 00:08:37.000
이 API의 응답에는 subscriptionGroupIdentifier로 그룹화된 앱에서 고객이 구독하는 모든 구독에 대한 상태가 포함되어 있습니다.

00:08:37.000 --> 00:08:46.000
각 subscriptionGroupIdentifier에 대해, 우리는 구독 그룹의 각 originalTransactionId에 대한 항목과 함께 최신 거래 목록을 제공합니다.

00:08:46.000 --> 00:08:59.000
이 배열의 각 항목에는 JWS 형식으로 서명된 상태, originalTransactionId, signedTransactionInfo 및 signedRenewalInfo가 포함되어 있습니다.

00:08:59.000 --> 00:09:03.000
이제 그 상태 필드를 자세히 살펴봅시다.

00:09:03.000 --> 00:09:11.000
상태 필드는 구독 상태에 대한 빠른 답변을 제공하므로 구독자의 서비스를 잠금 해제할지 여부를 알 수 있습니다.

00:09:11.000 --> 00:09:35.000
우리는 상태에 대한 다섯 가지 가능한 값으로 시작합니다: 1, 구독이 활성화되었음을 의미합니다; 2, 구독이 만료되었음을 의미합니다; 3, 구독이 청구 재시도 기간에 있다는 것을 의미합니다; 4, 구독이 유예 기간에 있다는 것을 의미합니다; 그리고 5, 취소 또는 다른 이벤트로 인해 구독 액세스가 취소되었음을 의미합니다.

00:09:35.000 --> 00:09:39.000
상태 필드를 보면 구독에 대한 빠른 답변을 얻을 수 있습니다.

00:09:39.000 --> 00:09:48.000
그 상태에 대한 자세한 내용은 서명된 거래 정보의 페이로드와 서명된 갱신 정보의 페이로드를 볼 수 있습니다.

00:09:48.000 --> 00:09:58.000
signedRenewalInfo를 디코딩하려면, base64가 페이로드 부분을 디코딩하여 서명된 거래 정보와 동일한 단계를 따르십시오.

00:09:58.000 --> 00:10:04.000
헤더를 사용하여 같은 방식으로 signedRenewalInfo의 서명을 추가로 확인할 수 있습니다.

00:10:04.000 --> 00:10:08.000
일단 해독되면, 당신은 이와 같은 것을 보게 될 것이다.

00:10:08.000 --> 00:10:22.000
갱신 정보에는 오늘 verifyReceipt의 보류 중인 갱신 정보 섹션에서 제공하는 것과 동일한 필드가 포함되어 있으며, 하나의 날짜 형식만 포함하고 해당되는 경우 일부 필드를 부울 또는 숫자로 만드는 것과 같은 몇 가지 업데이트가 포함되어 있습니다.

00:10:22.000 --> 00:10:28.000
우리는 또한 새로운 필드 offerType과 offerIdentifier를 signedRenewalInfo에 추가할 것입니다.

00:10:28.000 --> 00:10:33.000
이것은 고객이 다음 갱신 시 제안을 교환할 계획인지 알려줄 것입니다.

00:10:33.000 --> 00:10:45.000
구독 상태 API 외에도, 오늘 verifyReceipt의 latest_receipt_info 섹션에서 제공하는 것처럼 앱과 관련된 모든 거래를 얻을 수 있는 방법을 제공하고자 합니다.

00:10:45.000 --> 00:10:50.000
이러한 이유로, 우리는 또한 인앱 구매 내역 API를 추가하고 있습니다.

00:10:50.000 --> 00:11:00.000
인앱 구매 내역 API는 오늘 verifyReceipt의 latest_receipt_info 섹션에서 받은 것처럼 앱에 대한 모든 거래 내역을 제공합니다.

00:11:00.000 --> 00:11:12.000
여기서 주요 차이점은 각 거래가 새로운 서명된 거래 정보 형식으로 되어 있으며, API는 App Store에서 받는 응답의 크기를 제어하기 위해 페이지가 매겨진다는 것입니다.

00:11:12.000 --> 00:11:17.000
이것에 대한 초기 요청은 구독 상태 API와 마찬가지로 매우 간단합니다.

00:11:17.000 --> 00:11:23.000
우리는 당신의 요청을 처리하기 위해 당신의 원본 거래 ID만 필요합니다.

00:11:23.000 --> 00:11:34.000
응답에서 앱의 Apple ID 및 번들 ID와 같은 앱 메타데이터와 새로운 서명된 거래 정보 형식으로 앱에 대한 최신 20개의 거래 배열을 받게 됩니다.

00:11:34.000 --> 00:11:38.000
우리는 요청에 따라 20개의 서명된 거래 정보를 반환합니다.

00:11:38.000 --> 00:11:44.000
더 많은 거래가 있다면, 응답에서 hasMore와 수정 값을 보세요.

00:11:44.000 --> 00:11:49.000
앱에 더 많은 거래가 남아 있다면 hasMore는 사실일 것입니다.

00:11:49.000 --> 00:11:56.000
이 경우, 다음 20개의 트랜잭션을 얻기 위해 수정 토큰을 쿼리 매개 변수로 전달하여 다른 요청을 하세요.

00:11:56.000 --> 00:11:59.000
HasMore가 거짓이 될 때까지 이것을 반복하세요.

00:11:59.000 --> 00:12:06.000
이제 모든 App Store Server API가 어떻게 서로 일치하는지에 대해 이야기해 봅시다.

00:12:06.000 --> 00:12:16.000
그들은 모두 JWT 또는 JSON 웹 토큰 인증을 뒷받침하고, 새로운 서명된 거래를 지원하며, JSON 요청 및 응답 형식을 특징으로 합니다.

00:12:16.000 --> 00:12:26.000
그리고 무엇보다도, 그들은 모두 요청에서 영수증과 공유 비밀을 요구하기보다는 요청에서 제공하는 원본 TransactionactionId를 키오프합니다.

00:12:26.000 --> 00:12:29.000
이제, 저는 JWT 인증을 다루고 싶습니다.

00:12:29.000 --> 00:12:35.000
우리의 모든 새로운 App Store 서버 API는 JSON 웹 토큰 또는 JWT 인증을 사용합니다.

00:12:35.000 --> 00:12:41.000
우리는 우리의 서버와 당신의 서버 간의 통신 보안을 강화하기 위해 이것을 선택했습니다.

00:12:41.000 --> 00:12:46.000
이 JWT를 생성하려면, App Store Connect에서 개인 키를 다운로드해야 합니다.

00:12:46.000 --> 00:12:51.000
이 과정은 우리의 서버에 공개 키를 자동으로 등록할 것이다.

00:12:51.000 --> 00:12:56.000
그런 다음 서버를 호출하기 전에 ES256 알고리즘을 사용하여 토큰에 서명해야 합니다.

00:12:56.000 --> 00:13:03.000
App Store Connect에서 개인 키를 생성하려면, 사용자 및 액세스 페이지로 이동하여 키 탭을 방문하십시오.

00:13:03.000 --> 00:13:08.000
인앱 구매 키 옵션을 선택하면 이와 같은 페이지를 볼 수 있습니다.

00:13:08.000 --> 00:13:10.000
키를 추가하고 이름을 지정하세요.

00:13:10.000 --> 00:13:16.000
한 번만 다운로드할 수 있으므로 키를 안전한 장소에 저장하고, 키 ID를 기록하세요.

00:13:16.000 --> 00:13:20.000
이제, 이 JWT가 실제로 어떻게 생겼는지 살펴봅시다.

00:13:20.000 --> 00:13:26.000
JWT는 헤더, 페이로드, 서명의 세 부분으로 구성되어 있다.

00:13:26.000 --> 00:13:32.000
헤더에는 개인 키의 키 ID와 서명에 사용되는 알고리즘을 포함해야 합니다.

00:13:32.000 --> 00:13:38.000
SHA 256 해시 또는 ES256이 있는 타원 곡선 서명이 필요합니다.

00:13:38.000 --> 00:13:44.000
당신은 또한 이 경우 항상 JWT인 토큰 유형을 포함할 것입니다.

00:13:44.000 --> 00:13:46.000
페이로드에는 발행인 ID가 포함되어야 합니다.

00:13:46.000 --> 00:13:49.000
이 값은 App Store Connect에서 찾을 수 있습니다.

00:13:49.000 --> 00:13:55.000
토큰이 발행된 시간과 만료되어야 하는 시간을 epoch 이후 몇 초 단위로 포함할 것입니다.

00:13:55.000 --> 00:13:59.000
이 두 시간의 차이는 한 시간을 넘지 않아야 한다.

00:13:59.000 --> 00:14:03.000
항상 appstoreconnect-v1인 청중을 포함하세요.

00:14:03.000 --> 00:14:07.000
논스 또는 일회성 고유 문자열을 생성해야 합니다.

00:14:07.000 --> 00:14:12.000
마지막으로, 앱의 번들 식별자를 포함해야 합니다.

00:14:12.000 --> 00:14:23.000
이 모든 정보를 갖게 되면, ES256 알고리즘 또는 SHA 256 해시를 사용한 타원 곡선 서명을 사용하여 이 토큰의 서명을 구현해야 합니다.

00:14:23.000 --> 00:14:28.000
다음으로 넘어가기 전에, App Store 서버 API의 주요 요점을 검토해 봅시다.

00:14:28.000 --> 00:14:36.000
첫째, 우리는 거래 내역을 찾는 것과 상태를 결정하는 것을 분리했습니다. 왜냐하면 이것들은 별도의 기능이기 때문입니다.

00:14:36.000 --> 00:14:55.000
다음으로, 이러한 API는 요청에서 originalTransactionId만 필요합니다. 즉, 앱이나 서버의 응답에서 받은 서명된 거래를 가져와 originalTransactionId를 포함하여 관심 있는 필드를 저장한 다음 서명된 거래 정보를 제거할 수 있습니다.

00:14:55.000 --> 00:15:01.000
우리가 과거에 영수증으로 당신을 안내했기 때문에 더 이상 서명된 거래를 저장할 필요가 없습니다.

00:15:01.000 --> 00:15:07.000
따라서 새로운 App Store Server API로 고객 상태를 확인하는 방법을 다룹니다.

00:15:07.000 --> 00:15:15.000
이제, 저는 우리가 App Store 서버 알림을 일관성 있게 만드는 방법과 알림을 사용하여 상태를 추적할 수 있는 방법을 검토하고 싶습니다.

00:15:15.000 --> 00:15:19.000
먼저 App Store 서버 알림에 대한 빠른 검토부터 시작합시다.

00:15:19.000 --> 00:15:25.000
우리는 몇 년 동안 App Store 서버 알림에 대해 논의해왔으므로, 왜 유용한지 검토해 봅시다.

00:15:25.000 --> 00:15:35.000
App Store 서버 알림을 사용하면 거래 중 하나의 상태가 App Store에서 직접 변경될 때 알림을 받을 수 있습니다.

00:15:35.000 --> 00:15:43.000
알림을 받으면, 고객이 휴대폰에서 앱을 열지 않고도 상태를 즉시 업데이트할 수 있습니다.

00:15:43.000 --> 00:15:47.000
App Store 서버 알림을 사용하면 상태를 위해 우리에게 전화할 필요가 없습니다.

00:15:47.000 --> 00:15:50.000
뭔가 바뀌면 말해줄게.

00:15:50.000 --> 00:15:55.000
그것들은 당신의 서버가 활용할 수 있는 가장 강력한 도구 중 하나입니다.

00:15:55.000 --> 00:16:05.000
올해 우리의 목표는 새롭고 사용하기 쉬운 서명된 거래를 활용하여 App Store 서버 알림을 더욱 강력하게 만드는 것입니다.

00:16:05.000 --> 00:16:19.000
이 외에도, 우리는 하나의 사용자 작업에 대해 하나의 알림만 전송되도록 알림을 업데이트할 것이며, 페이로드를 업데이트할 것이며, 보안을 강화하기 위해 JWS를 사용하여 전체 페이로드에 서명될 것입니다.

00:16:19.000 --> 00:16:27.000
우리는 또한 당신이 준비가 되면 v2 알림을 선택할 수 있도록 허용할 것이며 한동안 기존 알림을 계속 보낼 것입니다.

00:16:27.000 --> 00:16:31.000
이것은 v1 알림에 대한 우리의 현재 알림입니다.

00:16:31.000 --> 00:16:36.000
INITIAL_BUY에서 REVOKE까지 모든 것을 포함하여 총 11가지 유형이 있습니다.

00:16:36.000 --> 00:16:45.000
V2 알림을 통해, 우리는 네 가지 알림 유형을 더 이상 사용하지 않습니다: INITIAL_BUY, INTERACTIVE_RENEWAL, CANCEL 및 PRICE_INCREASE_CONSENT.

00:16:45.000 --> 00:16:54.000
하지만 우리는 다섯 가지 새로운 유형을 추가하고 있습니다: SUBSCRIBED, OFFER_REDEEMED, EXPIRED, GRACE_PERIOD_EXPIRED, PRICE_INCREASE.

00:16:54.000 --> 00:17:00.000
새로운 알림 유형 외에도, 우리는 알림에 "하위 상태"라는 새로운 필드를 추가하고 있습니다.

00:17:00.000 --> 00:17:05.000
이것은 더 일반적인 알림 유형을 특정 사용자 작업으로 좁히는 데 도움이 될 것입니다.

00:17:05.000 --> 00:17:20.000
현재, 하위 상태는 6개의 v2 알림 유형에 적용됩니다: SUBSCRIBED, DID_CHANGE_RENEWAL_STATUS, DID_CHANGE_RENEWAL_PREFERENCES, OFFER_REDEEMED, EXPIRED 및 PRICE_INCREASE.

00:17:20.000 --> 00:17:25.000
하위 상태가 이러한 알림 유형에 어떻게 적용되는지에 대한 몇 가지 예를 살펴봅시다.

00:17:25.000 --> 00:17:30.000
먼저, 저는 구독된 알림과 그 하위 상태에 대해 이야기하고 싶습니다.

00:17:30.000 --> 00:17:37.000
고객이 처음 구매할 때, 당신은 INITIAL_BUY의 하위 상태와 함께 구독을 받게 될 것입니다.

00:17:37.000 --> 00:17:49.000
고객이 동일한 SKU 또는 다른 SKU를 재구독하면, 구독이 동일한 구독 그룹 내에 있는 한 RESUBSCRIBE의 하위 상태와 함께 SUBSCRIBED를 받게 됩니다.

00:17:49.000 --> 00:17:57.000
V1 App Store 서버 알림에 동등한 유형이 없는 새로운 알림 유형 중 하나는 OFFER_REDEEMED 알림입니다.

00:17:57.000 --> 00:17:59.000
그래서 나는 이 예시를 보고 싶다.

00:17:59.000 --> 00:18:04.000
OFFER_REDEEMED는 고객이 프로모션 제안을 교환할 때마다 수신됩니다.

00:18:04.000 --> 00:18:12.000
고객이 첫 구매에 대한 제안을 교환하면, INITIAL_BUY의 하위 상태와 함께 OFFER_REDEEMED를 받게 됩니다.

00:18:12.000 --> 00:18:21.000
고객이 동일한 비활성 구독을 재구독하겠다는 제안을 교환하면, RESUBSCRIBE의 하위 상태와 함께 OFFER_REDEEMED를 받게 됩니다.

00:18:21.000 --> 00:18:29.000
고객이 활성 구독을 업그레이드하기 위한 제안을 교환하면, UPGRADE의 하위 상태와 함께 OFFER_REDEEMED를 받게 됩니다.

00:18:29.000 --> 00:18:37.000
고객이 활성 구독을 다운그레이드하는 제안을 사용하면, DOWNGRADE의 하위 상태와 함께 OFFER_REDEEMED를 받게 됩니다.

00:18:37.000 --> 00:18:50.000
또한, 고객이 같은 기간 내에 취소한 후 활성 구독을 재구독할 수 있는 제안을 사용하면, AUTO_RENEW_ENABLED의 하위 상태와 함께 OFFER_REDEEMED를 받게 됩니다.

00:18:50.000 --> 00:18:52.000
이제, 만료된 것을 살펴봅시다.

00:18:52.000 --> 00:19:02.000
새로운 만료된 알림 유형을 사용하면, 고객이 VOLUNTARY의 하위 상태로 자동 갱신을 비활성화한 후 구독이 만료되면 만료됩니다.

00:19:02.000 --> 00:19:11.000
청구 재시도 기간이 성공적으로 복구되지 않고 종료되어 구독이 만료되면, BILLING_RETRY의 하위 상태와 함께 만료됩니다.

00:19:11.000 --> 00:19:21.000
또한, 고객이 가격 인상에 동의하지 않아 구독이 만료되면, PRICE_INCREASE의 하위 상태와 함께 만료됩니다.

00:19:21.000 --> 00:19:30.000
따라서 v2 알림 유형과 해당 하위 상태를 결합하여, 우리는 이제 20개 이상의 다양한 고객 수명 주기 이벤트를 다룹니다.

00:19:30.000 --> 00:19:42.000
알림 유형을 보는 것만으로도 구매에서 무엇이 변경되었는지에 대한 일반적인 아이디어를 얻기에 충분하지만, 하위 상태를 보면 더 자세히 알고 싶다면 더 구체적인 상태를 얻는 데 도움이 될 것입니다.

00:19:42.000 --> 00:19:46.000
이제 새로운 페이로드를 빠르게 살펴봅시다.

00:19:46.000 --> 00:19:52.000
V2 알림의 경우 알림 유형에 관계없이 항상 동일한 필드 세트를 포함할 것입니다.

00:19:52.000 --> 00:20:18.000
V2 알림을 구독한 경우 알림 유형, 하위 유형, 알림 버전, 알림이 적용되는 환경, 번들 ID, 앱 Apple ID 및 번들 버전과 같은 일부 앱 메타데이터, 새로운 signedTransactionInfo 형식의 영향을 받는 인앱에 대한 최신 거래, 그리고 새로운 signedRenewalInfo 형식의 인앱에 대한 최신 갱신 정보.

00:20:18.000 --> 00:20:30.000
이러한 변경 사항은 새로운 서명된 거래를 사용하고 영향을 받는 인앱 구매에 대한 정보만 포함하기 때문에 알림을 더 쉽게 구문 분석하고 채택하기가 더 쉬워지기를 바랍니다.

00:20:30.000 --> 00:20:37.000
앞서 언급했듯이, 전체 페이로드는 알림의 보안과 신뢰성을 높이기 위해 서명될 것이다.

00:20:37.000 --> 00:20:46.000
우리가 방금 본 페이로드는 가독성을 위해 서명되지 않았지만, 서명은 우리가 JWS 형식으로 거래 및 갱신 정보에 서명하는 방식과 유사할 것이다.

00:20:46.000 --> 00:20:50.000
우리는 당신이 준비가 되면 v2 알림을 선택할 수 있기를 바랍니다.

00:20:50.000 --> 00:20:59.000
이러한 이유로, 우리는 당신이 App Store 서버 알림 버전을 선택할 수 있도록 App Store Connect의 알림 URL에 옵션을 추가하고 있습니다.

00:20:59.000 --> 00:21:06.000
이렇게 하려면, 앱 페이지로 이동하여 새로운 App Store 서버 알림 섹션으로 스크롤하세요.

00:21:06.000 --> 00:21:15.000
프로덕션 서버 URL을 선택하면, 이제 버전 1 또는 버전 2 App Store 서버 알림을 선택할 수 있습니다.

00:21:15.000 --> 00:21:21.000
이러한 변경 사항이 올해 말에 시작되면, 버전 2 App Store 서버 알림을 선택할 수 있습니다.

00:21:21.000 --> 00:21:30.000
그래서 이제, 저는 구독의 첫 구매부터 시작하여 새로운 App Store 서버 알림을 사용하여 몇 가지 예시 시나리오를 검토하고 싶습니다.

00:21:30.000 --> 00:21:36.000
앱에서 처음 구독을 구매하는 경우, 구매 결과로 서명된 거래 정보를 받게 됩니다.

00:21:36.000 --> 00:21:50.000
앱에서 이것을 확인하고 originalTransactionId 및 기타 관련 필드를 서버로 보내거나 확인을 위해 서명된 거래 정보를 서버로 보내고 그 당시 데이터베이스에 저장할 필드를 선택할 수 있습니다.

00:21:50.000 --> 00:21:56.000
같은 시간에, 당신은 INITIAL_BUY의 하위 상태와 함께 구독 알림을 받게 될 것입니다.

00:21:56.000 --> 00:22:09.000
이제 알림의 서명된 거래 정보에 앱 계정 토큰이 포함되어 있으므로, 구매 후 서버와 앱 간의 통신이 끊어지더라도 이 알림을 인앱 사용자에게 즉시 연결할 수 있습니다.

00:22:09.000 --> 00:22:13.000
서명된 거래 정보를 확인하기 위해 서버에 전화할 필요가 없습니다.

00:22:13.000 --> 00:22:22.000
원래 TransactionId를 보내 상태 또는 앱 내 구매 내역 API를 확인하려면 언제든지 서버에 전화할 수 있습니다.

00:22:22.000 --> 00:22:25.000
이제 나는 구독 구매를 다루었다.

00:22:25.000 --> 00:22:27.000
구독 갱신으로 넘어갑시다.

00:22:27.000 --> 00:22:30.000
이제 우리는 이 구독의 갱신에 도달했습니다.

00:22:30.000 --> 00:22:35.000
이 구독이 성공적으로 갱신되면, DID_RENEW 알림 유형을 받게 됩니다.

00:22:35.000 --> 00:22:47.000
페이로드에서 서명된 거래 정보와 서명된 갱신 정보를 확인하여 구독의 다음 갱신 날짜와 다음 갱신에 대한 고객의 갱신 선호도를 확인할 수 있습니다.

00:22:47.000 --> 00:22:55.000
또한 구독 상태 API를 호출하여 갱신 시간에 구독 상태를 페일오버 메커니즘으로 확인할 수 있습니다.

00:22:55.000 --> 00:23:01.000
다시 한번, 당신이 알림에서 받은 거래를 확인하기 위해 우리에게 전화할 필요가 없습니다.

00:23:01.000 --> 00:23:07.000
물론, 자동 갱신이 항상 계획에 따라 진행되는 것은 아닙니다. 특히 청구 문제가 있는 경우 더욱 그렇습니다.

00:23:07.000 --> 00:23:11.000
그래서 이제, 저는 유예 기간과 청구 재시도를 다루고 싶습니다.

00:23:11.000 --> 00:23:15.000
이제 당신의 구독이 예상대로 갱신되지 않았다고 가정해 봅시다.

00:23:15.000 --> 00:23:19.000
이런 일이 발생하면, DID_FAIL_TO_RENEW 알림으로 알려드리겠습니다.

00:23:19.000 --> 00:23:32.000
유예 기간을 활성화하고 구독이 성공적으로 갱신하지 않고 유예 기간을 종료하는 경우, GRACE_PERIOD_EXPIRED 알림을 보내며, 고객이 청구 재시도 기간을 입력했음을 알 수 있습니다.

00:23:32.000 --> 00:23:41.000
청구 재시도 기간 동안 구독이 여전히 복구되지 않으면, BILLING_RETRY의 하위 단계와 함께 만료된 알림을 보내드리겠습니다.

00:23:41.000 --> 00:23:49.000
유예 기간 또는 청구 재시도 기간 동안 구독 청구를 복구하면, DID_RECOVER 알림을 보내드리겠습니다.

00:23:49.000 --> 00:23:59.000
갱신 결과에 상관없이, 우리는 서명된 거래 정보와 서명된 갱신 정보가 포함된 v2 알림으로 결과를 알려드립니다.

00:23:59.000 --> 00:24:06.000
이 과정의 어느 시점에서든 구독 상태 또는 기록 API를 호출하여 구독 상태를 다시 확인할 수 있습니다.

00:24:06.000 --> 00:24:11.000
이제, 우리는 구독이 고객이 당신의 앱에서 구매할 유일한 것이 아니라는 것을 알고 있습니다.

00:24:11.000 --> 00:24:16.000
이제 소비재를 처음 구매할 때 무엇을 기대해야 하는지 선회하고 다루자.

00:24:16.000 --> 00:24:23.000
앱에서 소모품을 처음 구매하는 경우, 구매의 결과로 서명된 거래 정보를 받게 됩니다.

00:24:23.000 --> 00:24:37.000
앱에서 이것을 확인하고 originalTransactionId 및 기타 관련 필드를 서버로 보내거나 확인을 위해 서명된 거래 정보를 서버로 보내고 그 당시 데이터베이스에 저장할 필드를 선택할 수 있습니다.

00:24:37.000 --> 00:24:42.000
나중에 필요할 수도 있으므로, 원래의 거래 ID를 항상 기록하세요.

00:24:42.000 --> 00:24:53.000
비소모품 및 비갱신 구독과 같은 소모품 및 기타 콘텐츠 유형의 경우, 고객이 환불을 요청하지 않는 한 해당 구매의 수명 주기 동안 많은 변화가 없습니다.

00:24:53.000 --> 00:24:56.000
그래서 나는 지금 그 사건을 다루고 싶어.

00:24:56.000 --> 00:25:00.000
이제, 고객이 소모품 구매에 대한 환불을 요청한다고 가정해 봅시다.

00:25:00.000 --> 00:25:08.000
서명된 거래 정보에 취소 날짜와 취소 사유가 포함된 환불 알림을 보내드리겠습니다.

00:25:08.000 --> 00:25:13.000
해지일 이후에 소모품 구매에 대한 액세스를 제공하는 것을 중단할 수 있습니다.

00:25:13.000 --> 00:25:21.000
언제든지 소모품 구매 상태에 대해 우려하는 경우, 인앱 히스토리 API를 호출하여 응답에서 찾을 수 있습니다.

00:25:21.000 --> 00:25:27.000
취소된 소모품은 항상 포함되므로, 거래 상태가 변경되었는지 알 수 있습니다.

00:25:27.000 --> 00:25:30.000
이제 나는 정전에 대해 이야기하고 싶다.

00:25:30.000 --> 00:25:34.000
때때로, 최선의 노력에도 불구하고, 당신은 서버에서 정전을 경험할 수 있습니다.

00:25:34.000 --> 00:25:38.000
이제 서버가 정전에서 복구할 수 있도록 어떻게 도울 수 있는지 다루겠습니다.

00:25:38.000 --> 00:25:46.000
서버에서 정전이 발생하고 App Store 서버 알림을 놓치면, 그 사이에 무엇이 바뀌었는지 알고 싶을 것입니다.

00:25:46.000 --> 00:25:49.000
인앱 히스토리 API는 여기서 당신의 해결책입니다.

00:25:49.000 --> 00:26:00.000
각 고객의 API를 호출하여 앱에서 originalTransactionId를 제공하면 앱의 최신 거래 기록을 얻을 수 있으므로 서버를 업데이트할 수 있습니다.

00:26:00.000 --> 00:26:06.000
그런 다음 구독 상태 API를 호출하여 각 구독에 대한 최신 구독 상태를 확인할 수 있습니다.

00:26:06.000 --> 00:26:11.000
이제 저는 당신의 서버에서 서명된 거래로 마이그레이션하는 마지막 사례를 다루고 싶습니다.

00:26:11.000 --> 00:26:19.000
이것은 앱 전에 서버를 업데이트할 준비가 되었거나 이전 버전의 앱에서 통합 앱 영수증을 여전히 받고 있는 경우 특히 중요합니다.

00:26:19.000 --> 00:26:26.000
서버에서 서명된 거래로 마이그레이션하는 것은 원본TransactionId만 필요하기 때문에 쉽습니다.

00:26:26.000 --> 00:26:38.000
서버가 앱에서 받은 통합 앱 영수증을 JWS 영수증으로 쉽게 변환할 수 있으므로 서버가 App Store 서버 API 및 App Store 서버 알림과 호환될 수 있습니다.

00:26:38.000 --> 00:26:46.000
이렇게 하려면, 먼저 통합 앱 영수증으로 verifyReceipt를 호출하고 응답에서 모든 고유한 원본 TransactionId를 가져오세요.

00:26:46.000 --> 00:26:54.000
이러한 originalTransactionIds 중 하나에 대한 인앱 구매 내역 API를 호출하여 서명된 거래에서 앱의 기록을 얻으십시오.

00:26:54.000 --> 00:27:04.000
그런 다음 구독 originalTransactionId에 대한 구독 상태 API를 호출하여 모든 고객 구독에 대해 서명된 거래와 서명된RenewalInformation을 받으세요.

00:27:04.000 --> 00:27:14.000
서명된 거래의 페이로드에서 관련 데이터를 기록하면, 이러한 API를 계속 사용하고 v2 App Store 서버 알림을 받을 수 있습니다.

00:27:14.000 --> 00:27:24.000
그래서 이제 저는 App Store 서버 알림에 대한 모든 변경 사항과 알림을 사용하여 고객 상태를 확인하는 방법을 다루었습니다.

00:27:24.000 --> 00:27:31.000
이제 서버에서 인앱 구매를 위한 가족 공유를 더 쉽게 관리할 수 있도록 하는 방법에 대해 이야기하고 싶습니다.

00:27:31.000 --> 00:27:43.000
앱 내 구매를 위한 가족 공유는 현재 App Store Connect에서 앱 내 구매에 대한 가족 공유를 활성화한 경우 자동 갱신 구독 및 비소모성 구매에 대해 지원됩니다.

00:27:43.000 --> 00:27:58.000
현재, 우리는 거래가 가족 공유 또는 구매인지를 나타내기 위해 inAppOwnershipType이라는 필드를 제공하며, 가족 구성원을 위한 알림의 하위 집합인 REVOKE, DID_RECOVER 및 DID_FAIL_TO_RENEW를 지원합니다.

00:27:58.000 --> 00:28:08.000
인앱 소유권 유형 필드와 기존 지원되는 알림 유형은 새로운 서명된 거래와 App Store 서버 알림 v2와 함께 유지됩니다.

00:28:08.000 --> 00:28:14.000
그러나, 올해 말에, 우리는 가족 구성원을 위한 App Store 서버 알림에 대한 더 많은 지원을 추가하고 있습니다.

00:28:14.000 --> 00:28:24.000
V1 알림의 경우, DID_CHANGE_RENEWAL_STATUS, DID_CHANGE_RENEWAL_PREF, DID_RENEW 및 INTERACTIVE_RENEWAL을 추가합니다.

00:28:24.000 --> 00:28:28.000
V2 알림의 경우, 우리는 가족 구성원을 위한 더 많은 지원을 추가하고 있습니다.

00:28:28.000 --> 00:28:44.000
DID_CHANGE_RENEWAL_STATUS, DID_CHANGE_RENEWAL_PREF 및 DID_RENEW 외에도 구매자와 가족 구성원을 위한 SUBSCRIBED, EXPIRED, GRACE_PERIOD_EXPIRED 및 OFFER_REDEEMED에 대한 지원을 추가하고 있습니다.

00:28:44.000 --> 00:28:53.000
이렇게 하면 App Store 서버 알림을 통해 구매자와 가족 모두 모든 고객의 상태를 더 쉽게 추적할 수 있습니다.

00:28:53.000 --> 00:29:06.000
따라서 올해 가족 구성원에 대한 알림을 위한 변경 사항으로 인해 기존 가족 공유 기능과 결합할 때 인앱 구매를 위한 가족 공유를 훨씬 더 쉽게 관리할 수 있습니다.

00:29:06.000 --> 00:29:11.000
이제 한 가지 더 마무리하고 싶습니다: 샌드박스에서 서버를 테스트하는 것입니다.

00:29:11.000 --> 00:29:14.000
우리는 당신이 당신의 앱과 서버에 자신감을 갖기를 바랍니다.

00:29:14.000 --> 00:29:23.000
그래서 우리는 당신이 생산 전에 샌드박스에서 새로운 App Store 서버 API 및 App Store 서버 알림과 통합할 수 있기를 바랍니다.

00:29:23.000 --> 00:29:31.000
우리가 오늘 논의한 App Store 서버 API의 경우, 그것은 그들이 샌드박스에서 완전히 테스트할 수 있다는 것을 의미하며, 지금부터 라이브입니다!

00:29:31.000 --> 00:29:35.000
여기에는 구독 상태 API와 인앱 구매 내역 API가 포함됩니다.

00:29:35.000 --> 00:29:40.000
이 외에도, 우리는 샌드박스에 몇 가지 다른 새로운 기능을 추가하고 있습니다.

00:29:40.000 --> 00:29:46.000
올해 말에, App Store Connect에 샌드박스별 알림 URL을 추가할 수 있습니다.

00:29:46.000 --> 00:29:52.000
이 추가 기능을 사용하면 생산과 샌드박스 알림을 완전히 분리할 수 있습니다.

00:29:52.000 --> 00:30:02.000
또한, 샌드박스 알림 버전을 선택할 수 있으므로 생산 전에 샌드박스에서 v2 알림을 테스트할 수 있습니다.

00:30:02.000 --> 00:30:11.000
작년에, 우리는 평가판 자격을 재설정하고 샌드박스에서 구독 관리 페이지를 제공하는 것과 같은 흥미로운 샌드박스 개선을 가져왔습니다.

00:30:11.000 --> 00:30:17.000
우리는 샌드박스에서 테스트를 더 쉽게 만들고 싶고 올해 몇 가지 새로운 개선 사항을 추가하고 있습니다.

00:30:17.000 --> 00:30:27.000
이것들은 샌드박스 애플 ID의 구매 내역을 지우고, 샌드박스 계정 지역을 변경하고, 샌드박스에서 구독 갱신율을 조정하고 있다.

00:30:27.000 --> 00:30:38.000
또한, 보안 강화로, 우리는 고객이 더 이상 TestFlight 사용자가 아니라는 것을 감지할 때 TestFlight 영수증에 대한 verifyReceipt에서 오류를 반환하고 있습니다.

00:30:38.000 --> 00:30:43.000
이러한 새로운 샌드박스 개선 사항은 App Store Connect의 샌드박스 테스터 페이지에서 액세스할 수 있습니다.

00:30:43.000 --> 00:30:51.000
구매 내역을 지우려면, 편집을 선택한 다음, 테스터를 전환하고, 구매 내역 지우기 버튼을 선택하세요.

00:30:51.000 --> 00:30:56.000
테스터의 구매 내역을 지우는 것을 확인하면, 그 조치를 되돌릴 수 없습니다.

00:30:56.000 --> 00:31:00.000
그러니 이 옵션을 선택한 테스터를 기억하세요.

00:31:00.000 --> 00:31:08.000
구매 내역 지우기는 새 계정을 만들지 않고도 무언가를 다시 구매할 수 있는 강력한 새로운 테스트 도구입니다.

00:31:08.000 --> 00:31:12.000
그것은 또한 당신이 테스트를 위한 신선하고 빈 영수증을 가질 수 있게 해준다.

00:31:12.000 --> 00:31:21.000
계정 지역을 변경하거나 구독 갱신 비율을 조정하려면, 테스터 페이지로 돌아가서 테스터 행을 선택하세요.

00:31:21.000 --> 00:31:29.000
테스터 설정에서 App Store 지역을 변경하고 구독 갱신율을 조정할 수 있는 새로운 옵션을 볼 수 있습니다.

00:31:29.000 --> 00:31:34.000
원하는 지역을 선택하여 테스터의 계정 지역을 변경할 수 있습니다.

00:31:34.000 --> 00:31:42.000
이를 통해 하나의 테스터 계정으로 샌드박스의 175개 매장에서 테스트할 수 있습니다.

00:31:42.000 --> 00:31:47.000
우리의 마지막 새로운 샌드박스 기능은 샌드박스에서 구독 갱신율을 조정하는 것입니다.

00:31:47.000 --> 00:31:51.000
이것을 편집하려면, 드롭다운에서 원하는 갱신 비율을 선택하세요.

00:31:51.000 --> 00:31:55.000
지금, 한 달은 샌드박스에서 5분과 관련이 있다.

00:31:55.000 --> 00:32:00.000
테스터의 갱신율을 조정할 수 있는 몇 가지 옵션을 더 드리겠습니다.

00:32:00.000 --> 00:32:12.000
구독 갱신율을 조정하면 구독 취소, 업그레이드 또는 다운그레이드와 같은 작업을 수행할 수 있는 더 많은 시간을 제공하며, 갱신 속도를 빠르게 단축하여 장기 고객을 시뮬레이션할 수 있습니다.

00:32:12.000 --> 00:32:15.000
그것이 우리가 올해 샌드박스에 온 전부이다.

00:32:15.000 --> 00:32:18.000
우리는 당신이 이 새로운 기능으로 테스트하는 것을 좋아하길 바랍니다.

00:32:18.000 --> 00:32:23.000
그래서 우리는 오늘 많은 새로운 정보를 다루었고, 이제 나는 당신이 그 모든 것을 탐구할 수 있기를 바랍니다.

00:32:23.000 --> 00:32:29.000
새로운 JWS 영수증을 채택하기 위해 앱과 서버를 업데이트하는 데 시간이 좀 걸리기를 바랍니다.

00:32:29.000 --> 00:32:34.000
특히 현재 살고 있는 샌드박스에서 새로운 App Store Server API를 사용하세요.

00:32:34.000 --> 00:32:42.000
그리고 아직 등록하지 않았다면 App Store 서버 알림에 등록하고 올해 말에 출시될 v2 업데이트를 준비하세요.

00:32:42.000 --> 00:32:45.000
우리의 새로운 샌드박스 개선 사항도 올해 말에 출시될 예정입니다.

00:32:45.000 --> 00:32:49.000
샌드박스 테스트 경험을 향상시키기 위해 이것들을 사용하세요.

00:32:49.000 --> 00:32:57.000
마지막으로, 이 시리즈에서 올해 다른 두 세션인 "StoreKit 2를 만나세요"와 "고객을 지원하고 환불을 처리하세요"를 확인하세요.

00:32:57.000 --> 00:33:12.000
App Store 서버 알림에 대한 자세한 배경과 설정 방법은 WWDC 2020의 "인앱 구매의 새로운 기능"과 WWDC 2019의 "인앱 구매 및 서버 간 알림 사용"을 확인하세요.

00:33:12.000 --> 00:33:20.000
우리의 영수증, API 및 알림은 서버에서 인앱 구매를 관리할 수 있는 세 가지 강력한 도구입니다.

00:33:20.000 --> 00:33:25.000
이것들을 활용함으로써, 서버와 앱을 그 어느 때보다 강력하게 만들 수 있습니다.

00:33:25.000 --> 00:33:31.000
오늘 우리가 검토한 모든 새로운 기능을 활용해 주시고, 당신의 피드백을 기다리겠습니다.

00:33:31.000 --> 00:33:37.000
오늘 들어줘서 정말 고마워, 그리고 남은 WWDC를 즐겨.

00:33:37.000 --> 23:59:59.000
[쾌활한 음악].

