WEBVTT

00:00:02.000 --> 00:00:12.000
안녕하세요, WWDC에 오신 것을 환영합니다.

00:00:12.000 --> 00:00:17.000
제 이름은 조엘이고, MusicKit으로 앱에 음악을 추가하는 방법에 대해 말씀드리고 싶습니다.

00:00:17.000 --> 00:00:25.000
MusicKit은 앱이 Swift에서 음악 항목에 액세스할 수 있는 표현적인 API를 제공하는 Apple 플랫폼을 위한 새로운 프레임워크입니다.

00:00:25.000 --> 00:00:32.000
그것은 새로운 Swift 동시성 구문을 활용하며 처음부터 SwiftUI와 함께 사용하도록 설계되었습니다.

00:00:32.000 --> 00:00:47.000
MusicKit은 앱이 Apple Music의 다양한 카탈로그 콘텐츠에 액세스하기 위한 서버 측 API 세트인 Apple Music API와 통합되는 방식을 가속화하여 Apple Music과 연결되는 매력적인 앱을 훨씬 쉽게 구축할 수 있습니다.

00:00:47.000 --> 00:00:51.000
먼저, 우리는 MusicKit으로 음악 콘텐츠를 요청하는 방법에 대해 이야기할 것입니다.

00:00:51.000 --> 00:01:23.000
다음으로, Apple Music 관련 데이터에 액세스하기 위해 앱의 동의를 요청하고, Apple Music API에 액세스하는 데 필요한 토큰을 관리하고, 구독 정보 및 관련 기능에 액세스하고, Apple Music 카탈로그에서 음악을 재생하고, 마지막으로 사용자가 아직 구독자가 아닌 경우 Apple Music에 대한 구독 제안을 표시하는 방법과 같은 앱이 Apple Music과 통합하는 방식에 중요한 다른 주제에 대해 이야기할 것입니다.

00:01:23.000 --> 00:01:30.000
MusicKit은 Apple Music API에서 콘텐츠를 가져올 수 있는 구조화된 요청과 함께 음악 항목에 액세스하기 위한 새로운 모델 레이어를 제공합니다.

00:01:30.000 --> 00:01:38.000
Apple Music 카탈로그에서 콘텐츠를 검색하거나 특정 필터를 기반으로 리소스를 가져올 수 있습니다.

00:01:38.000 --> 00:01:47.000
이러한 요청은 페이지 매김에 대한 지원이 내장된 컬렉션으로 그룹화된 항목으로 응답을 생성하여 초기 응답에서 다음 항목 배치를 얻을 수 있습니다.

00:01:47.000 --> 00:01:49.000
그래서, 이 음악 아이템들은 어떻게 생겼어?

00:01:49.000 --> 00:01:51.000
앨범과 함께 구체적인 예를 살펴봅시다.

00:01:51.000 --> 00:01:56.000
"앨범"은 세 가지 범주로 그룹화된 속성이 있는 값 유형이다.

00:01:56.000 --> 00:02:11.000
첫 번째 범주에는 "title"과 같은 문자열 속성, "isCompilation"과 같은 부울 속성 또는 "artwork"와 같은 구조화된 속성과 같은 간단한 속성이 포함되어 있어 관련 크기 정보 및 관련 색상과 함께 작품의 URL에 액세스할 수 있습니다.

00:02:11.000 --> 00:02:19.000
앨범은 또한 관련 아티스트나 장르 또는 주어진 앨범의 트랙 목록과 같은 여러 관계를 제공한다.

00:02:19.000 --> 00:02:26.000
예를 들어, "트랙" 관계의 결과는 또 다른 유형의 음악 항목인 "트랙" 유형의 값 모음입니다.

00:02:26.000 --> 00:02:34.000
마지막으로, 이러한 강력한 모델 수준의 관계 외에도, "앨범"은 관련 콘텐츠의 몇 가지 약한 연관성을 제공한다.

00:02:34.000 --> 00:02:40.000
협회는 관계와 매우 유사하지만, 일반적으로 더 일시적이거나 편집적으로 주도적이다.

00:02:40.000 --> 00:02:50.000
예를 들어, 앨범의 "appearsOn" 협회는 재생 목록 모음을 반환하지만, 관계를 위한 컬렉션과 달리, 이 앨범에는 제목도 있다.

00:02:50.000 --> 00:02:53.000
MusicKit과의 관계를 로드하고 액세스하는 것은 매우 간단합니다.

00:02:53.000 --> 00:03:06.000
앨범을 감안할 때, "아티스트"와 "트랙"과 같은 관계뿐만 아니라 "관련 앨범"과 같은 연관성을 포함하는 동일한 앨범의 또 다른 표현을 한 번의 작업으로 쉽게 가져올 수 있습니다.

00:03:06.000 --> 00:03:14.000
"With" 메서드는 특별한 Swift 키워드 "await"로 호출되어야 하며, 이는 이것이 무대 뒤에서 비동기 작업을 수행할 것임을 나타냅니다.

00:03:14.000 --> 00:03:20.000
이것은 실제로 네트워크를 통해 Apple Music API에서 이 앨범의 더 완전한 표현을 가져올 것이다.

00:03:20.000 --> 00:03:28.000
그런 다음 이 상세한 앨범에서 트랙 목록을 얻을 수 있으며, 일반 배열로 하는 것처럼 그 트랙을 반복할 수 있습니다.

00:03:28.000 --> 00:03:30.000
그리고 여기 이 코드의 콘솔 출력이 있습니다.

00:03:30.000 --> 00:03:40.000
"관련 앨범"과 같은 협회에 접근하는 것은 같은 방식으로 작동하며, 유일한 차이점은 일반적으로 컬렉션에서 직접 접근할 수 있는 제목도 포함한다는 것이다.

00:03:40.000 --> 00:03:45.000
그런 다음 같은 방식으로 컬렉션을 반복하여 관련 앨범 몇 개를 인쇄할 수 있습니다.

00:03:45.000 --> 00:03:48.000
그리고 여기 이 코드의 콘솔 출력이 있습니다.

00:03:48.000 --> 00:03:51.000
이제, MusicKit으로 음악 콘텐츠를 요청하는 데모를 살펴봅시다.

00:03:51.000 --> 00:03:57.000
저는 Apple Music에서 앨범을 찾고 즐길 수 있는 앱을 개발하고 있습니다.

00:03:57.000 --> 00:04:05.000
음악 카탈로그 검색 요청을 사용하여 일치하는 검색 결과를 로드하기 위해 이미 연결된 일부 코드인 이 검색 필드를 사용하여 앨범을 검색할 수 있습니다.

00:04:05.000 --> 00:04:09.000
이 앱은 또한 내가 최근에 본 앨범 목록을 추적한다.

00:04:09.000 --> 00:04:20.000
우리는 그것을 선택하여 "Catch A Vibe - EP"라는 제목의 이 앨범에 대한 더 많은 정보를 찾을 수 있으며, 이 세부 보기가 나타난 후 이 앨범의 트랙 목록이 애니메이션되는 것을 눈치챘을 것입니다.

00:04:20.000 --> 00:04:30.000
이것은 우리가 방금 본 것처럼 이 앨범의 "트랙" 관계를 로드하고, 이 목록을 채우는 데 사용되는 SwiftUI 보기의 상태 변수를 업데이트함으로써 이루어집니다.

00:04:30.000 --> 00:04:36.000
아트워크 아래의 재생 버튼을 사용하거나 특정 트랙을 선택하여 이 앨범의 음악을 재생할 수 있습니다.

00:04:36.000 --> 00:04:44.000
이것은 단순히 MusicKit의 재생 API를 사용하여 이 트랙 목록으로 대기열을 설정하고 플레이어의 재생 방법을 호출합니다.

00:04:44.000 --> 00:04:47.000
한 번 해보자!

00:04:47.000 --> 00:04:52.000
그래서, 내가 Karun &amp; MONBRU의 "Catch a Vibe"라는 제목의 트랙을 선택한다면...

00:04:52.000 --> 00:04:57.000
이 노래는 연주되기 시작한다.

00:04:57.000 --> 00:04:59.000
♪ 오, 오, 안돼 ♪

00:04:59.000 --> 00:05:05.000
우리 앱은 잠금 화면의 미디어 컨트롤에서도 자동으로 작동하므로 이 노래의 중간 지점까지 스크럽할 수 있습니다.

00:05:05.000 --> 00:05:18.000
하지만 나는 이 앱을 사용하여 피닉스의 이 앨범처럼 내 CD 라이브러리에서 오래된 음악을 재발견하는 데 도움이 되기를 바랐다.

00:05:18.000 --> 00:05:29.000
그래서, 저는 iPhone의 카메라를 오래된 CD의 바코드로 가리키고 이 앱이 동일한 앨범을 디지털 형식으로 표시할 수 있는 기능을 추가하고 싶습니다.

00:05:29.000 --> 00:05:32.000
나는 이미 이 기능에 대한 실험 코드를 추가했다.

00:05:32.000 --> 00:05:39.000
활성화하면, 하단에 카메라 보기를 표시하는 바코드 버튼을 볼 수 있습니다.

00:05:39.000 --> 00:05:46.000
이 CD의 바코드를 가리키면, 자동으로 바코드 값을 인식하고 표시합니다.

00:05:46.000 --> 00:05:51.000
내가 놓치고 있는 것은 해당 앨범을 찾기 위해 MusicKit을 사용하는 코드뿐이다.

00:05:51.000 --> 00:05:54.000
계속해서 그것을 우리 앱에 추가하자.

00:05:54.000 --> 00:06:01.000
그래서 MusicCatalogResourceRequest를 사용하여 앨범 요청을 만들겠습니다.

00:06:01.000 --> 00:06:07.000
나는 특별히 앨범을 찾고 있어.

00:06:07.000 --> 00:06:23.000
그리고 여기서, 우리는 바코드의 기술 용어인 Universal Product Code의 약자인 UPC 속성이 같은 앨범을 찾고 싶습니다: detectedBarcode.

00:06:23.000 --> 00:06:31.000
나는 이 요청을 비동기적으로 수행할 수 있다.

00:06:31.000 --> 00:06:36.000
앨범 요청. 응답.

00:06:36.000 --> 00:06:49.000
그리고 나서 응답에서, 나는 결과에서 첫 번째 앨범을 찾을 수 있다.

00:06:49.000 --> 00:06:57.000
그런 다음 이 첫 번째 앨범을 아래의 handleDetectedAlbum 도우미 방법으로 전달할 수 있습니다.

00:06:57.000 --> 00:07:02.000
handleDetectedAlbum (첫 번째 앨범).

00:07:02.000 --> 00:07:10.000
이 방법은 바코드 스캔 보기를 닫은 다음, 감지된 앨범의 앨범 세부 정보 보기를 푸시합니다.

00:07:10.000 --> 00:07:16.000
그리고 그것은 메인 스레드에서 실행될 수 있도록 MainActor로 장식되어 있습니다.

00:07:16.000 --> 00:07:23.000
그래서 우리가 그것을 부를 때, 우리는 await 키워드를 추가해야 한다.

00:07:23.000 --> 00:07:28.000
그러니 앱을 다시 빌드하고 실행하여 시도해 봅시다.

00:07:28.000 --> 00:07:32.000
바코드 버튼을 누르세요.

00:07:32.000 --> 00:07:38.000
내 앨범 가져가.

00:07:38.000 --> 00:07:41.000
그건 효과가 있었어!

00:07:41.000 --> 00:07:47.000
이제, 애플 뮤직에서 내 오래된 음악을 디지털 형식으로 즐기는 것이 훨씬 쉬울 것이다.

00:07:47.000 --> 00:08:01.000
MusicKit은 또한 URL을 사용하여 임의의 Apple Music API 엔드포인트에서 콘텐츠를 로드할 수 있다는 점에서 구조화된 요청과 다른 범용 데이터 요청을 제공합니다.

00:08:01.000 --> 00:08:07.000
이 요청에서 얻을 수 있는 것은 Apple Music API의 JSON 응답에 대한 원시 데이터입니다.

00:08:07.000 --> 00:08:19.000
JSONDecoder로 이 원시 데이터를 디코딩해야 하지만, Codable 프로토콜을 준수하기 때문에 기존 음악 항목 유형을 활용할 수 있기 때문에 그렇게 하는 것은 어려울 필요가 없습니다.

00:08:19.000 --> 00:08:21.000
예를 들어 봅시다.

00:08:21.000 --> 00:08:31.000
Apple Music에서 최상위 장르 목록을 로드하고 싶다면, 이 특정 URL에서 콘텐츠를 로드하여 할 수 있으며, 여기에 해당 JSON 응답이 있습니다.

00:08:31.000 --> 00:08:36.000
이 결과를 자세히 살펴보면, 중간에 장르 자원처럼 보이는 것을 볼 수 있습니다.

00:08:36.000 --> 00:08:39.000
그래서, 스위프트에서 이것을 어떻게 표현하시겠습니까?

00:08:39.000 --> 00:08:42.000
물론, MusicKit에는 장르 유형이 있다.

00:08:42.000 --> 00:08:46.000
뒤로 확대하면, 스위프트의 전체 응답을 어떻게 나타내나요?

00:08:46.000 --> 00:08:51.000
간단한 장르 배열인 데이터 멤버로 구조자를 만들 수 있습니다.

00:08:51.000 --> 00:08:54.000
그런 다음, 이 구조를 Decodable로 표시해야 합니다.

00:08:54.000 --> 00:09:02.000
그리고 이것은 "장르" 자체도 Decodable을 준수하기 때문에 추가 디코딩 로직을 작성할 필요조차 없습니다.

00:09:02.000 --> 00:09:12.000
따라서 앱에 이 데이터를 로드하려면 이 구조를 파일 상단에 넣은 다음 사용자의 특정 국가 코드를 사용하여 URL을 구성해야 합니다.

00:09:12.000 --> 00:09:20.000
이 URL을 사용하여 음악 데이터 요청을 만들고, 우리가 이미 본 것과 동일한 패턴에 따라 응답을 받으세요.

00:09:20.000 --> 00:09:29.000
응답이 있으면, MyGenresResponse 유형을 디코딩 메서드에 전달하여 JSONDecoder를 사용하여 데이터를 디코딩할 수 있습니다.

00:09:29.000 --> 00:09:30.000
그리고 그게 다야!

00:09:30.000 --> 00:09:35.000
이제 강하게 입력된 장르 응답에서 개별 장르에 접근할 수 있습니다.

00:09:35.000 --> 00:09:42.000
그리고, 보시다시피, MusicKit의 다른 요청에서 가져올 수 있는 것과 같은 종류의 음악 아이템을 얻을 수 있습니다.

00:09:42.000 --> 00:09:47.000
그래서, 그것이 Apple Music API의 임의의 URL에서 콘텐츠를 로드하는 방법입니다.

00:09:47.000 --> 00:09:56.000
그리고 이제 음악 콘텐츠를 로드하는 방법을 알았으니, 개인 정보 보호부터 시작하여 앱을 Apple Music과 통합하기 위한 몇 가지 중요한 예비 단계에 대해 논의해 봅시다.

00:09:56.000 --> 00:10:01.000
우리는 사용자가 어떤 앱이 그들의 데이터에 접근할 수 있는지 계속 통제하기를 바랍니다.

00:10:01.000 --> 00:10:12.000
따라서 사용자의 청취 기록이나 음악 라이브러리를 포함할 수 있는 Apple Music API에서 데이터를 요청하기 전에 앱이 Apple Music에 액세스할 수 있도록 사용자의 사전 동의를 받아야 합니다.

00:10:12.000 --> 00:10:17.000
이 사용자 콘텐츠를 요청하는 것은 장치별 및 앱별로 이루어져야 합니다.

00:10:17.000 --> 00:10:28.000
그리고 Apple Music 또는 자신의 재생 목록에서 재생 목록으로 운동할 수 있는 훌륭한 피트니스 앱인 Zova라는 앱의 맥락에서 사용자 동의 대화 상자가 다음과 같습니다.

00:10:28.000 --> 00:10:33.000
처음으로 운동을 시작할 때, Zova는 Apple Music에 액세스할 수 있는 권한을 요청합니다.

00:10:33.000 --> 00:10:38.000
이 대화상자는 앱이 Apple Music에 액세스해야 하는 이유를 사용자에게 전달해야 합니다.

00:10:38.000 --> 00:10:48.000
이를 위해, Info.plist에서 정의해야 하는 Apple Music에 대한 앱의 사용 설명은 이 대화 상자의 자막으로 포함되어 있습니다.

00:10:48.000 --> 00:10:51.000
다음은 MusicKit에 대한 사용자 동의를 요청하는 방법의 예입니다.

00:10:51.000 --> 00:10:59.000
앱에 MusicKit이 필요한 기능이 있으며, isAuthorizedForMusicKit 상태 변수를 사용하여 이 기능에 대한 액세스를 게이팅하고 있다고 가정해 봅시다.

00:10:59.000 --> 00:11:08.000
앱의 적절한 시점에서, MusicKit을 사용하기 전에, 이 비동기 요청 방법으로 Apple Music에 액세스할 수 있는 권한을 요청할 수 있습니다.

00:11:08.000 --> 00:11:13.000
이것은 앱이 아직 승인되지 않은 경우에만 사용자에게 메시지를 표시합니다.

00:11:13.000 --> 00:11:21.000
요청 방법은 상태 값을 반환하며, 해당 상태가 "승인"과 같으면 isAuthorizedForMusicKit 변수를 "true"로 설정할 수 있습니다.

00:11:21.000 --> 00:11:26.000
이제, Apple Music API에서 데이터를 로드하는 데 필요한 토큰에 대해 간략하게 이야기해 봅시다.

00:11:26.000 --> 00:11:32.000
Apple Music API에는 기본적으로 API로 앱을 인증하는 개발자 토큰이 필요합니다.

00:11:32.000 --> 00:11:48.000
이전에는 이 개발자 토큰을 받으려면 개발자 포털에서 MusicKit 개인 키를 만들고, 제어할 수 있는 서버에 넣고, 키를 비공개로 유지하고, 앱이 서버에서 새로운 개발자 토큰을 요청하도록 해야 했습니다.

00:11:48.000 --> 00:11:56.000
하지만 이제 Swift용 MusicKit을 사용하면 개발자 토큰이 앱에 자동으로 생성되기 때문에 더 이상 걱정할 필요가 없습니다.

00:11:56.000 --> 00:12:01.000
개발자 포털에 등록하여 이 새로운 자동 동작을 선택하기만 하면 됩니다.

00:12:01.000 --> 00:12:10.000
특히, 앱 ID를 등록하는 페이지에서 하단의 앱 서비스 탭을 선택하고 MusicKit 확인란을 활성화하십시오.

00:12:10.000 --> 00:12:11.000
그리고 넌 끝났어!

00:12:11.000 --> 00:12:17.000
또한, Apple Music API는 개인화된 엔드포인트에 대한 사용자 토큰이 필요합니다.

00:12:17.000 --> 00:12:23.000
그리고 올해 새로운 개발자 토큰과 마찬가지로, 사용자 토큰은 당신을 대신하여 자동으로 생성됩니다.

00:12:23.000 --> 00:12:30.000
앱에서 MusicKit을 사용해야 할 수도 있는 한 가지는 사용자가 활성 Apple Music 구독을 가지고 있는지 알아내는 방법입니다.

00:12:30.000 --> 00:12:47.000
MusicKit의 구독 정보는 사용자가 Apple Music 카탈로그의 콘텐츠를 재생할 수 있는지, iCloud 음악 라이브러리를 활성화했는지, 또는 아직 활성 구독이 없는 경우 구독자가 될 수 있는지 알려주는 세 가지 기능으로 노출됩니다.

00:12:47.000 --> 00:12:53.000
앱의 특정 Apple Music 관련 기능에 대한 관련 기능을 확인하십시오.

00:12:53.000 --> 00:13:02.000
예를 들어, 음악을 재생하기 위해 연결된 재생 버튼이 있는 경우, 사용자가 Apple Music의 카탈로그 콘텐츠를 재생할 수 없는 경우 비활성화 상태로 유지할 수 있습니다.

00:13:02.000 --> 00:13:07.000
음악 구독을 추적하기 위해 보기에서 상태 변수를 정의할 수 있습니다.

00:13:07.000 --> 00:13:17.000
그런 다음, 음악 구독 속성 "canPlayCatalogContent"가 "false"로 설정된 경우 비활성화된 수정자를 버튼에 적용하여 비활성화된 상태로 유지할 수 있습니다.

00:13:17.000 --> 00:13:28.000
그리고 마지막으로, 새로운 작업 수정자로 전달된 비동기 블록 내에서, 새로운 구독 업데이트 스트림을 사용하여 음악 구독의 변경 사항을 알릴 수 있습니다.

00:13:28.000 --> 00:13:31.000
이제, MusicKit으로 재생에 대해 이야기해 봅시다.

00:13:31.000 --> 00:13:37.000
MusicKit은 SystemMusicPlayer와 ApplicationMusicPlayer라고 부르는 두 개의 별개의 플레이어를 제공합니다.

00:13:37.000 --> 00:13:41.000
예시부터 시작해서, 그 선수들의 차이점에 대해 알아봅시다.

00:13:41.000 --> 00:13:55.000
소셜 미디어 앱은 시스템 음악 앱에서 재생되는 것을 변경하기 위해 SystemMusicPlayer를 사용할 수 있는 반면, 피트니스 앱은 시스템 음악 앱과 완전히 독립적으로 재생 상태를 유지하기 위해 ApplicationMusicPlayer를 사용하는 것을 선호할 수 있습니다.

00:13:55.000 --> 00:14:00.000
이 두 플레이어 모두 현재 재생 중인 정보를 자동으로 보고하고 원격 명령을 처리합니다.

00:14:00.000 --> 00:14:06.000
이것이 데모 초반에 있는 잠금 화면의 시스템 미디어 컨트롤과 깊은 통합을 제공한 것입니다.

00:14:06.000 --> 00:14:09.000
그러나, 현재 재생되고 있는 앱은 다르게 보고되었다.

00:14:09.000 --> 00:14:20.000
SystemMusicPlayer를 사용하는 경우, 음악 앱은 현재 재생되는 앱으로 보고되는 반면, ApplicationMusicPlayer를 사용하는 경우, 앱은 현재 재생되는 앱으로 보고됩니다.

00:14:20.000 --> 00:14:23.000
재생 대기열의 소유권도 다르다.

00:14:23.000 --> 00:14:33.000
SystemMusicPlayer를 사용하면 앱이 시스템 음악 앱을 원격으로 제어하는 반면, ApplicationMusicPlayer를 사용하면 앱이 완전히 별도의 재생 대기열을 소유합니다.

00:14:33.000 --> 00:14:40.000
이 두 플레이어 모두 하나 이상의 아이템으로 대기열을 설정하거나, 다음에 플레이하거나, 나중에 플레이할 아이템을 추가할 수 있습니다.

00:14:40.000 --> 00:14:50.000
그러나 ApplicationMusicPlayer만이 재생 대기열에 대한 추가 제어를 제공하여 중간에 항목을 삽입하거나 이전에 추가된 항목을 제거할 수 있습니다.

00:14:50.000 --> 00:15:04.000
마지막으로, 사용자가 아직 Apple Music 구독자가 아닌 경우, 앱 내에서 Apple Music의 무료 평가판을 시작할 수 있도록 허용할 수 있으므로, 음악으로 앱의 사용자 경험을 개선하기 위해 작업한 모든 기능을 즐길 수 있습니다.

00:15:04.000 --> 00:15:15.000
구독 제안은 "음악 재생"과 같은 앱의 기능에 더 잘 대응하도록 사용자에게 표시되는 메인 메시지를 조정하여 구성할 수 있습니다.

00:15:15.000 --> 00:15:21.000
그것은 또한 특정 노래, 앨범 또는 재생 목록을 강조하는 맥락적일 수 있다.

00:15:21.000 --> 00:15:33.000
그리고 앱에서 구독 제안서를 사용하면 Apple 서비스 성과 파트너 프로그램이라고 부르는 제휴 프로그램을 통해 새로운 Apple Music 구독자를 데려온 것에 대한 보상을 받을 수 있습니다.

00:15:33.000 --> 00:15:41.000
앱에서 상황에 맞는 음악 구독 제안을 표시하려면, 이전에 본 것처럼 음악 구독을 추적해야 합니다.

00:15:41.000 --> 00:15:46.000
또한 제안이 표시되는지 여부를 추적하기 위해 다른 상태 변수가 필요합니다.

00:15:46.000 --> 00:15:53.000
예를 들어, 앨범의 ID를 구독 제안 옵션의 itemID 속성으로 전달하세요.

00:15:53.000 --> 00:15:59.000
음악 구독에서 "canBecomeSubscriber"가 "거짓"으로 설정될 때마다 제안 버튼을 비활성화된 상태로 유지하세요.

00:15:59.000 --> 00:16:08.000
그런 다음, isShowingOffer 속성에 바인딩하고 옵션을 포함하는 musicSubscriptionOffer 수정자를 사용하세요.

00:16:08.000 --> 00:16:11.000
마지막으로, isShowingOffer 변수를 "true"로 설정하세요.

00:16:11.000 --> 00:16:16.000
앱으로 돌아가서 Apple Music의 상황에 맞는 제안이 어떻게 생겼는지 봅시다.

00:16:16.000 --> 00:16:21.000
이전 데모에서, 우리는 이미 활성 Apple Music 구독으로 로그인했습니다.

00:16:21.000 --> 00:16:33.000
따라서, Apple Music에 대한 구독 제안을 보여주는 것이 적절할 수 있는 시나리오를 시뮬레이션하려면, 설정으로 이동하여 계정에서 로그아웃할 수 있습니다.

00:16:33.000 --> 00:16:45.000
그런 다음, 내 앱으로 돌아가면, 재생 버튼이 비활성화되고 사용자가 Apple Music에 가입하도록 초대하는 다른 버튼을 위한 공간을 만들기 위해 왼쪽으로 이동한 것을 볼 수 있습니다.

00:16:45.000 --> 00:16:54.000
이 버튼을 탭하면 구독 제안이 제공되며, 앱에서 방금 보고 있던 특정 앨범을 강조합니다.

00:16:54.000 --> 00:16:59.000
그리고 그것이 사용자가 앱 내에서 Apple Music의 무료 평가판을 시작할 수 있도록 하는 방법입니다.

00:16:59.000 --> 00:17:06.000
결론적으로, 경험의 일부로 약간의 음악을 추가하여 향상시킬 수 있는 많은 유형의 앱이 있습니다.

00:17:06.000 --> 00:17:13.000
예를 들어, 게임의 분위기에 맞는 배경 음악을 재생하여 게임을 훨씬 더 몰입하게 만들 수 있습니다.

00:17:13.000 --> 00:17:18.000
또는 피트니스 앱에서 사용자에게 동기를 부여하기 위해 낙관적인 음악을 재생할 수 있습니다.

00:17:18.000 --> 00:17:25.000
그리고 소셜 미디어 앱에서는 음악을 강조하는 콘텐츠에 사용자를 더 많이 참여시킬 수 있습니다.

00:17:25.000 --> 00:17:36.000
더 나아가려면, 몇 가지 관련 세션을 확인하여 ShazamKit으로 Shazam 서명의 힘을 활용하는 방법에 대해 배우고 SwiftUI로 동시성에 대해 더 깊이 파고들 수 있습니다.

00:17:36.000 --> 00:17:39.000
시청해 주셔서 감사합니다, 그리고 WWDC 2021을 즐기세요!

00:17:39.000 --> 23:59:59.000
[타격적인 음악].

