WEBVTT

00:00:00.000 --> 00:00:05.000
♪ 베이스 음악 연주 ♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:13.000
윌 아다리오-터너: 안녕하세요, "XCTest에서 예상되는 실패를 받아들이세요"에 오신 것을 환영합니다.

00:00:13.000 --> 00:00:21.000
제 이름은 윌이고, 이 세션에서는 프로젝트의 테스트를 실행할 때 얻는 데이터를 개선하는 방법에 대해 논의할 것입니다.

00:00:21.000 --> 00:00:25.000
우선, 애초에 코드를 테스트하는 이유를 생각해 봅시다.

00:00:25.000 --> 00:00:29.000
물론, 높은 수준에서, 그것은 우리가 제품의 품질을 보장하는 방법이다.

00:00:29.000 --> 00:00:37.000
하지만 좀 더 구체적으로 말하자면, 나는 우리가 배송하기 전에 버그를 발견하는 것이지 나중에 발견하는 것이라고 말하고 싶다.

00:00:37.000 --> 00:00:39.000
이제, 테스트는 투자이다.

00:00:39.000 --> 00:00:44.000
테스트를 만들고, 실행하고, 유지하려면 자원이 필요하다.

00:00:44.000 --> 00:00:50.000
모든 투자와 마찬가지로, 우리는 비용을 최소화하면서 수익을 극대화하고 싶습니다.

00:00:50.000 --> 00:00:54.000
이 세션은 유지 보수 비용을 줄이기 위한 도구에 초점을 맞추고 있다.

00:00:54.000 --> 00:01:02.000
유지 보수를 통해, 저는 주로 테스트 스위트에서 오류가 발생할 때 실패를 처리하는 방법을 언급하고 있습니다.

00:01:02.000 --> 00:01:07.000
통과한 시험이 실패하기 시작하면, 그것은 귀중한 새로운 정보이다.

00:01:07.000 --> 00:01:21.000
이것은 제품의 결함, 테스트 자체의 문제 또는 종속성 중 하나의 문제, 즉 제품이 있는 모든 프레임워크와 하위 시스템을 나타냅니다.

00:01:21.000 --> 00:01:34.000
문제의 유형에 관계없이, 일단 그 실패가 등록되면, 동일한 실패에 대한 후속 보고서는 당신이 이미 가지고 있는 정보를 나타내기 때문에 훨씬 덜 가치가 있습니다.

00:01:34.000 --> 00:01:38.000
이상적으로, 새로운 실패는 선별되고 빠르게 수정된다.

00:01:38.000 --> 00:01:50.000
그러나, 당신의 팀은 문제를 즉시 해결하지 못할 수 있으며, 이는 실패가 귀중한 새로운 정보에서 시끄러운 산만함으로 빠르게 간다는 것을 의미합니다.

00:01:50.000 --> 00:01:58.000
즉시 해결할 수 없는 테스트에서 알려진 실패를 감안할 때, 소음을 관리하는 데 사용할 수 있는 도구는 무엇입니까?

00:01:58.000 --> 00:02:03.000
마음에 떠오를 수 있는 두 가지 접근 방식은 비활성화와 건너뛰기이다.

00:02:03.000 --> 00:02:13.000
이것들에 대한 절충안을 고려한 다음 최고의 도구와 이 세션의 주제인 XCTest의 ExpectedFailures API에 대해 이야기해 봅시다.

00:02:13.000 --> 00:02:17.000
Xcode를 사용하면 테스트 계획이나 계획에서 테스트를 비활성화할 수 있습니다.

00:02:17.000 --> 00:02:23.000
알려진 테스트 실패에 이것을 사용할 수 있으며, 한 가지 장점은 테스트 코드가 계속 컴파일된다는 것입니다.

00:02:23.000 --> 00:02:27.000
그러나, 코드가 실행되지 않기 때문에, 테스트 보고서에서 볼 수 없습니다.

00:02:27.000 --> 00:02:34.000
이러한 가시성 감소는 해결해야 할 문제로 추적하기 어렵게 만든다.

00:02:34.000 --> 00:02:44.000
이 기능 - 활성화 또는 비활성화된 테스트를 선택할 수 있는 기능 -은 특정 목적을 위한 테스트 컬렉션을 큐레이팅하기 위한 것입니다.

00:02:44.000 --> 00:02:49.000
하지만 그것은 알려진 실패를 다루는 가장 좋은 방법은 거의 없다.

00:02:49.000 --> 00:02:54.000
XCTSkip은 실패한 시험을 관리할 수 있는 또 다른 방법입니다.

00:02:54.000 --> 00:03:03.000
이 접근 방식을 통해, 코드는 테스트로 계속 구축될 뿐만 아니라, XCTSkip이 호출될 때까지 실행됩니다.

00:03:03.000 --> 00:03:10.000
이것은 그것이 시험 보고서에 포함되어 있다는 것을 의미하며, 문제에 대한 훨씬 더 나은 가시성을 제공합니다.

00:03:10.000 --> 00:03:21.000
그러나, 그것은 모든 테스트를 실행하지 않으며, 이는 새로운 문제와 기존 문제에 대한 변경의 형태로 잠재적으로 유용한 정보를 잃는다는 것을 의미합니다.

00:03:21.000 --> 00:03:31.000
XCTSkip은 특정 OS 버전이나 장치 유형을 요구하는 것과 같은 테스트에 대한 구성 기반 제한을 관리하기 위한 훌륭한 도구입니다.

00:03:31.000 --> 00:03:37.000
여기 예시에서, iPad에서 실행되지 않으면 테스트를 건너뛸 것입니다.

00:03:37.000 --> 00:03:46.000
이것은 알려진 오류를 관리하기 위해 특별히 설계된 XCTest의 기능 세트인 XCTExpectFailure로 우리를 데려온다.

00:03:46.000 --> 00:03:55.000
스위프트에서는 다양한 사용 사례에 대한 많은 과부하가 있으며, Objective-C는 몇 가지 뚜렷한 기능으로 동일한 기능을 제공합니다.

00:03:55.000 --> 00:04:05.000
이 API를 사용하면 테스트가 정상적으로 실행되지만 결과는 다음과 같이 변경됩니다. 테스트 실패는 예상 실패로 보고됩니다.

00:04:05.000 --> 00:04:15.000
그 테스트가 포함된 테스트 스위트의 실패는 물론 다른 테스트가 실패하지 않는 한 통과로 보고될 것이다.

00:04:15.000 --> 00:04:23.000
이것은 실패로 인한 소음을 제거하여 테스트에 다른 문제가 있는지 더 쉽게 확인할 수 있습니다.

00:04:23.000 --> 00:04:27.000
물론, 소음을 억제하는 것은 근본적인 문제를 해결하지 못한다.

00:04:27.000 --> 00:04:31.000
그래서 당신이 그것을 추적할 수 있도록, API는 실패 이유를 취합니다.

00:04:31.000 --> 00:04:40.000
이 문자열은 코드의 문제를 문서화하고 문제 추적 시스템의 URL을 포함할 수도 있습니다.

00:04:40.000 --> 00:04:47.000
Xcode의 테스트 보고서 UI는 정상적인 실패나 건너뛰는 테스트와 마찬가지로 예상되는 실패를 보여줍니다.

00:04:47.000 --> 00:04:56.000
호버할 때, 실패 이유에 URL이 포함된 경우, 링크로 건너뛸 수 있는 문제 추적 버튼이 나타납니다.

00:04:56.000 --> 00:04:59.000
그래서 이게 어떻게 작동하는지 보자!

00:04:59.000 --> 00:05:04.000
여기 제 VendorAccount 수업을 위한 몇 가지 단위 테스트가 있는 간단한 프로젝트가 있습니다.

00:05:04.000 --> 00:05:12.000
나는 테스트를 실행할 것이고, 그들이 끝나면, 우리는 하나는 실패하고 다른 하나는 통과하는 것을 보게 될 것이다.

00:05:12.000 --> 00:05:16.000
각 테스트마다 하나씩 세 개의 테스트 결과 아이콘을 볼 수 있습니다.

00:05:16.000 --> 00:05:29.000
실패한 테스트에 대한 빨간색 X와 통과 테스트에 대한 녹색 체크, 그리고 테스트 스위트에 대한 빨간색 X; 스위트의 테스트 중 하나가 실패했기 때문에 우리는 스위트 자체가 실패했다고 생각합니다.

00:05:29.000 --> 00:05:37.000
이제 나는 실패한 테스트를 시작할 때 XCTExpectFailure에 전화를 추가할 것이다.

00:05:37.000 --> 00:05:45.000
실패 이유가 이 실패를 추적하기 위해 제출한 버그를 참조하는 URL로 시작하는 것을 볼 수 있습니다.

00:05:45.000 --> 00:05:50.000
이제 나는 테스트를 다시 실행할 것이고 우리는 이것이 결과에 어떤 영향을 미치는지 볼 것이다.

00:05:50.000 --> 00:05:58.000
좋아요, 그래서 실패한 테스트의 빨간색 X 아이콘이 회색 X로 바뀌었고, 이는 예상 실패의 지표입니다.

00:05:58.000 --> 00:06:05.000
더 흥미로운 것은 테스트 스위트 아이콘이 빨간색 X에서 녹색 대시로 바뀌었다는 것이다.

00:06:05.000 --> 00:06:17.000
이 아이콘은 테스트 스위트가 혼합 상태로 통과했음을 나타내며, 이는 하나 이상의 테스트가 통과하지 못했지만 건너뛰거나 예상되는 실패였다는 것을 의미합니다.

00:06:17.000 --> 00:06:22.000
그래서 실패한 테스트를 처리하기 위해 XCTExpectFailure를 사용하는 것이 얼마나 쉬운지.

00:06:22.000 --> 00:06:29.000
이제 API를 자세히 살펴봅시다.

00:06:29.000 --> 00:06:35.000
XCTExpectFailure를 사용할 때 첫 번째 고려 사항은 호출할 API 변형입니다.

00:06:35.000 --> 00:06:52.000
두 가지 접근 방식이 있습니다: XCTExpectFailure를 호출하고 테스트의 후속 실패가 예상대로 처리되는 상태 저장 접근 방식; 대안으로, XCTExpectFailure에 전달된 클로저에서 실패한 코드를 래핑하는 범위 접근 방식을 사용할 수 있습니다.

00:06:52.000 --> 00:06:55.000
몇 가지 예를 살펴봅시다.

00:06:55.000 --> 00:06:59.000
여기 제 프로젝트에서 몇 가지 기능을 호출하는 매우 간단한 테스트가 있습니다.

00:06:59.000 --> 00:07:04.000
함수가 더 이상 true를 반환하지 않기 때문에 테스트가 실패하기 시작합니다.

00:07:04.000 --> 00:07:11.000
우리가 데모에서 했던 것처럼, 상태 저장 가능한 예상 실패 접근 방식을 사용하는 것은 다음과 같습니다.

00:07:11.000 --> 00:07:19.000
또는, 우리는 XCTExpectFailure에 대한 호출 후 폐쇄에서 실패한 코드를 래핑하여 범위가 지정된 접근 방식을 사용할 수 있습니다.

00:07:19.000 --> 00:07:25.000
이것은 폐쇄 외부의 코드의 실패가 정상적으로 보고될 것이라는 것을 의미합니다.

00:07:25.000 --> 00:07:28.000
API는 또한 중첩을 지원합니다.

00:07:28.000 --> 00:07:36.000
즉, 다른 호출의 폐쇄 내부를 포함하여 테스트에서 API를 두 번 이상 호출할 수 있습니다.

00:07:36.000 --> 00:07:41.000
이것은 테스트 라이브러리 코드에서 API를 사용할 때 중요한 고려 사항이다.

00:07:41.000 --> 00:07:53.000
예를 들어, 일반적인 유틸리티 기능이 실패하기 시작하면 많은 테스트가 영향을 받을 수 있으며, 그 중 일부는 이미 다른 문제에 대해 XCTExpectFailure를 사용하고 있을 수 있습니다.

00:07:53.000 --> 00:08:11.000
XCTExpectFailure에 대한 중첩된 호출의 맥락에서 실패가 발생하면, 문제는 가장 가까운 호출 사이트와 먼저 일치하며, 매처에 의해 거부되면 XCTExpectFailure에 대한 호출에 대한 스택 의미와 함께 다음 호출로 전달됩니다.

00:08:11.000 --> 00:08:19.000
이러한 이유로, 공유 코드로, 테스트 상태에 대한 영향을 제한하기 위해 폐쇄 기반 API를 사용하는 것이 가장 좋습니다.

00:08:19.000 --> 00:08:24.000
다음으로 고려해야 할 것은 그 문제를 얼마나 정확하게 일치시키는가이다.

00:08:24.000 --> 00:08:32.000
기본적으로, 영향을 받는 범위의 모든 실패는 잡히지만, 문제 매칭 필터를 지정하여 더 선택적일 수 있습니다.

00:08:32.000 --> 00:08:41.000
이 예에서, 우리는 XCTExpectedFailure.Options 유형의 객체를 구성하고 issueMatcher를 정의합니다.

00:08:41.000 --> 00:08:50.000
매처는 실패 세부 사항과 함께 XCTIssue 객체에 전달되므로, 일치 여부를 결정할 때 해당 정보에 완전히 액세스할 수 있습니다.

00:08:50.000 --> 00:08:55.000
매처가 실패를 거부하면, 예상되는 실패로 처리되지 않을 것이다.

00:08:55.000 --> 00:09:01.000
이것은 테스트 중인 코드에 새로운 문제가 나타날 때 감지하는 데 유용할 수 있다.

00:09:01.000 --> 00:09:07.000
옵션 객체에는 또한 특정 구성에서 예상되는 실패를 비활성화하는 데 사용할 수 있는 속성이 있습니다.

00:09:07.000 --> 00:09:15.000
예를 들어, 내 테스트는 macOS에서 통과할 수 있지만 iOS에서는 실패할 수 있으므로, iOS에서만 실패를 예상하고 싶습니다.

00:09:15.000 --> 00:09:23.000
그것을 달성하기 위해, 나는 옵션을 통해 예상되는 실패를 비활성화하지만, 필요하지 않은 플랫폼에서만 비활성화한다.

00:09:23.000 --> 00:09:27.000
그래서 당신의 예상 실패가 실패를 멈추면 어떻게 되나요?

00:09:27.000 --> 00:09:31.000
보통 이것은 근본적인 문제가 해결되었다는 것을 의미하며, 이는 훌륭하다.

00:09:31.000 --> 00:09:34.000
하지만 XCTExpectFailure는 어떻게 행동하나요?

00:09:34.000 --> 00:09:41.000
여전히 API를 호출하고 실패가 발생하지 않는다면, 새롭고 뚜렷한 실패를 생성할 것입니다.

00:09:41.000 --> 00:09:50.000
우리는 이것을 "비할 수 없는 예상 실패"라고 부르며 XCTExpectFailure의 기본값인 엄격한 행동의 일부입니다.

00:09:50.000 --> 00:09:57.000
이 동작은 API에 대한 불필요한 호출을 제거하라는 메시지를 표시하여 코드를 유지하는 데 도움이 됩니다.

00:09:57.000 --> 00:10:02.000
하지만 가끔만 실패하는 시험은 어떤가요?

00:10:02.000 --> 00:10:06.000
시험이 가끔 실패할 수 있지만 다른 때는 실패하지 않는 경우가 있다.

00:10:06.000 --> 00:10:19.000
이것들은 두 가지 범주로 분류되며, 첫 번째는 결정론적이며 특정 플랫폼에서만 실패하는 테스트의 이전 예와 같은 환경 또는 기타 알 수 있는 조건을 포함한다.

00:10:19.000 --> 00:10:23.000
반면에, 몇몇 실패는 본질적으로 비결정적이다.

00:10:23.000 --> 00:10:29.000
이것들은 타이밍 문제, 신뢰할 수 없는 주문 종속성 또는 동시성 버그로 인해 발생할 수 있습니다.

00:10:29.000 --> 00:10:36.000
비결정적 실패의 경우, 엄격한 행동은 도움이 되지 않는다; 그것은 단지 소음을 발생시킨다.

00:10:36.000 --> 00:10:40.000
다시 한번, 옵션 객체는 이것을 제어할 수 있는 방법을 제공한다.

00:10:40.000 --> 00:10:45.000
기본값이 true인 isStrict 플래그는 끌 수 있습니다.

00:10:45.000 --> 00:10:51.000
그런 다음, XCTExpectFailure가 실패를 포착하지 못하면, 여전히 테스트를 통과할 수 있습니다.

00:10:51.000 --> 00:10:58.000
스위프트에서는 엄격한 동작을 XCTExpectFailure의 직접 매개 변수로 지정할 수도 있습니다.

00:10:58.000 --> 00:11:04.000
엄격한 행동을 비활성화하는 것은 프로젝트에서 벗겨지거나 비결정적인 테스트를 처리하는 좋은 방법입니다.

00:11:04.000 --> 00:11:15.000
제쳐두고, 비결정적 실패를 조사해야 할 때, Xcode는 테스트를 여러 번 쉽게 실행할 수 있게 해주며, 실패하거나 다른 조건이 충족되면 중지합니다.

00:11:15.000 --> 00:11:19.000
이것은 벗겨진 테스트에서 실패를 추적하는 데 정말 도움이 될 수 있다.

00:11:19.000 --> 00:11:25.000
이에 대한 자세한 내용은 "테스트 반복으로 신뢰할 수 없는 코드 진단" 세션을 시청하세요.

00:11:25.000 --> 00:11:33.000
그래서 그것은 XCTExpectFailure입니다 -- 테스트 스위트 결과에서 신호 대 잡스를 개선하기 위한 XCTest의 API입니다.

00:11:33.000 --> 00:11:38.000
이것은 새로운 문제를 더 효율적으로 식별하여 더 높은 품질의 코드로 이어지는 데 도움이 됩니다.

00:11:38.000 --> 00:11:40.000
봐줘서 고마워!

00:11:40.000 --> 23:59:59.000
♪

