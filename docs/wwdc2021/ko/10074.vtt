WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:13.000
안녕. 저는 아만다이고, 제 동료 올리비에와 잠시 합류할 것입니다.

00:00:13.000 --> 00:00:18.000
이 강연에서, 우리는 2021년에 RealityKit에 추가한 기능을 살펴볼 것입니다.

00:00:18.000 --> 00:00:27.000
RealityKit은 현실적인 렌더링에 초점을 맞추고 AR 앱을 쉽게 만들 수 있도록 2019년에 도입된 증강 현실 저작 프레임워크입니다.

00:00:27.000 --> 00:00:38.000
ARKit을 활용하여 장치의 센서 데이터를 읽는 RealityKit을 사용하면 실제 환경에 3D 콘텐츠를 배치하고 그 콘텐츠를 가능한 한 사실적으로 보이게 할 수 있습니다.

00:00:38.000 --> 00:00:42.000
다음은 RealityKit 경험의 몇 가지 좋은 예입니다.

00:00:42.000 --> 00:00:52.000
현실 세계에서 스캐빈저 헌트를 하고, 사실상 친구들과 볼링을 하고, 심지어 박물관에서 조각품이 되고, 다채로운 벌레를 찾으세요.

00:00:52.000 --> 00:01:01.000
지난 몇 년 동안, 우리는 RealityKit으로 만든 놀라운 앱을 보았고 이 프레임워크를 더 좋게 만들기 위해 정말 좋은 피드백을 받았습니다.

00:01:01.000 --> 00:01:03.000
그리고 우리는 당신의 피드백을 들었습니다.

00:01:03.000 --> 00:01:10.000
RealityKit 2가 더 몰입형 AR 앱과 게임을 만드는 데 도움이 되는 많은 새로운 기능을 도입한다는 것을 공유하게 되어 기쁩니다.

00:01:10.000 --> 00:01:21.000
이 세션에서, 우리는 사용자 지정 셰이더 및 재료, 사용자 지정 시스템 및 새로운 캐릭터 컨트롤러 개념과 같은 가장 많이 요청된 기능을 포함하여 그 중 일부를 강조할 것입니다.

00:01:21.000 --> 00:01:25.000
그러니 스노클링 마스크를 착용하고 뛰어들자.

00:01:25.000 --> 00:01:30.000
내가 중동에서 자랄 때, 나는 걸프에서 스쿠버 다이빙을 배웠다.

00:01:30.000 --> 00:01:36.000
비록 내가 이 매우 귀여운 스팀펑크 헬멧 중 하나를 착용하지는 못했지만, 나는 모든 다채로운 물고기 학교 교육을 보는 것을 좋아했다.

00:01:36.000 --> 00:01:41.000
나는 바로 여기 내 거실에서 그 수중 분위기를 재현하는 것이 재미있을 것이라고 생각했다.

00:01:41.000 --> 00:01:49.000
올리비에와 저는 이 세션과 이번 주 후반에 두 번째 RealityKit 세션에서 보여줄 많은 기능을 사용하여 이 데모를 작성했습니다.

00:01:49.000 --> 00:01:59.000
우리는 깊이 안개 효과와 물 부식성, 해초가 파도에서 춤을 추게 하는 사용자 지정 기하학 수정자 등을 만들기 위한 사후 처리가 있습니다.

00:01:59.000 --> 00:02:04.000
기본적으로, RealityKit 2를 사용하면 이제 많은 것을 사용자 정의할 수 있습니다.

00:02:04.000 --> 00:02:09.000
이 샘플 코드는 developer.apple.com에서 사용해 볼 수 있습니다.

00:02:09.000 --> 00:02:12.000
오늘 우리가 다룰 다섯 가지 주요 주제가 있다.

00:02:12.000 --> 00:02:20.000
우리는 ECS가 무엇인지, 그리고 앱에서 물고기의 무리 행동을 구현하기 위해 새로운 사용자 지정 시스템 기능을 어떻게 사용했는지 요약할 것입니다.

00:02:20.000 --> 00:02:36.000
우리는 당신이 재료와 애니메이션, 새로운 캐릭터 컨트롤러로 할 수 있는 것의 발전을 보여줄 것입니다. 새로운 캐릭터 컨트롤러는 다이버가 거실의 AR 메쉬와 원활하게 상호 작용할 수 있는 방법이며, 이제 런타임에 자원을 생성할 수 있는 방법입니다.

00:02:36.000 --> 00:02:38.000
그럼 ECS부터 시작합시다.

00:02:38.000 --> 00:02:47.000
엔티티 구성 요소 시스템의 줄임말인 ECS는 데이터와 행동을 구조화하는 방법이며, 게임과 시뮬레이션에서 일반적으로 사용된다.

00:02:47.000 --> 00:02:57.000
항목을 기능과 해당 항목과 관련된 상태의 캡슐화된 번들로 모델링하는 경향이 있는 객체 지향 프로그래밍과는 다릅니다.

00:02:57.000 --> 00:03:11.000
하지만 ECS를 사용하면 세 가지 프롱이 있습니다: 엔티티, 구성 요소 및 시스템, 기능이 시스템에 들어가고, 상태는 구성 요소에 들어가고, 엔티티는 구성 요소 그룹의 식별자입니다.

00:03:11.000 --> 00:03:22.000
올해 RealityKit 2와 함께, 우리는 더 순수한 ECS 구현으로 나아가고 있으며, 새로운 사용자 지정 시스템으로 시스템 계층에서 더 많은 기능을 유지할 수 있도록 안내하고 있습니다.

00:03:22.000 --> 00:03:24.000
실체는 우리에게 어떤 의미인가요?

00:03:24.000 --> 00:03:28.000
엔티티는 당신의 장면에서 한 가지를 나타냅니다.

00:03:28.000 --> 00:03:31.000
여기 우리 장면에서 바다 생물을 대표하는 실체가 있습니다.

00:03:31.000 --> 00:03:35.000
엔티티는 자식 엔티티를 가질 수 있으며, 작업할 수 있는 그래프 구조를 제공합니다.

00:03:35.000 --> 00:03:42.000
예를 들어, 변환 구성 요소는 부모 엔티티의 변환을 사용하여 자체 위치를 추가합니다.

00:03:42.000 --> 00:03:46.000
엔티티 자체는 화면에 아무것도 렌더링하지 않는다.

00:03:46.000 --> 00:03:51.000
이를 위해, 당신은 모델 구성 요소를 제공하거나 모델 엔티티를 만들어야 합니다.

00:03:51.000 --> 00:03:56.000
속성, 속성 및 동작을 추가하려면 엔티티에 구성 요소를 추가합니다.

00:03:56.000 --> 00:04:00.000
말하자면, 구성 요소에 대해 이야기해 봅시다.

00:04:00.000 --> 00:04:06.000
구성 요소는 프레임 사이에 상태를 저장하고 엔티티의 시스템 참여를 표시하기 위한 것이다.

00:04:06.000 --> 00:04:10.000
하지만, 당신은 여기서 그 상태를 다루기 위한 어떤 논리도 포함할 필요가 없습니다.

00:04:10.000 --> 00:04:14.000
당신의 논리와 행동은 당신의 사용자 지정 시스템에 있습니다.

00:04:14.000 --> 00:04:18.000
당신이 만든 모든 엔티티에 이미 존재할 몇 가지 구성 요소가 있습니다.

00:04:18.000 --> 00:04:24.000
여기에 표시되지 않은 것은 내장 구성 요소입니다: 변환 및 동기화 구성 요소.

00:04:24.000 --> 00:04:26.000
그들은 이 세 단체 모두에 있다.

00:04:26.000 --> 00:04:34.000
엔티티를 화면에 표시하는 메쉬와 재료가 포함된 모델 구성 요소와 같이 자주 추가하고 싶은 다른 것들이 있습니다.

00:04:34.000 --> 00:04:41.000
동작을 동적으로 변경하려면 런타임에 엔티티에서 구성 요소를 추가하고 제거할 수도 있습니다.

00:04:41.000 --> 00:04:47.000
우리는 이 첫 번째 물고기를 무리를 짓는 시스템에 참여하는 것으로 표시하고, 조류를 먹는 것을 좋아한다고 말할 것이다.

00:04:47.000 --> 00:04:53.000
이 두 번째 물고기는 또한 첫 번째 물고기와 함께 모일 것이지만, 지금은 플랑크톤을 먹는 것을 선호한다.

00:04:53.000 --> 00:04:55.000
이 세 번째 남자는 플랑크톤이다.

00:04:55.000 --> 00:04:57.000
그것은 두 번째 물고기의 먹이가 될 것이다.

00:04:57.000 --> 00:05:02.000
그것은 뒤를 지켜봐야 한다, 왜냐하면 우리 앱에는 배고픈 생물들이 있기 때문이다.

00:05:02.000 --> 00:05:07.000
우리는 AlgaeEater나 PlanktonEater 구성 요소가 있기 때문에 어떤 것이 배가 고픈지 알고 있다.

00:05:07.000 --> 00:05:11.000
모든 프레임, 우리의 식사 시스템에는 업데이트 기능이 있습니다.

00:05:11.000 --> 00:05:22.000
여기서, 그것은 이러한 구성 요소 중 하나를 가진 장면의 모든 엔티티와 음식인 모든 엔티티를 발견하므로, 배고픈 물고기를 그들이 선호하는 음식으로 안내할 수 있다.

00:05:22.000 --> 00:05:30.000
하지만 식사 시스템이 어떤 개체가 배고프고, 어떤 개체가 음식이며, 어떤 개체가 그렇지 않은지 알아내는 성능이 뛰어난 방법은 무엇입니까?

00:05:30.000 --> 00:05:35.000
우리는 엔티티 그래프를 가로지르고 각각의 구성 요소를 확인하고 싶지 않다.

00:05:35.000 --> 00:05:38.000
대신, 우리는 엔티티 쿼리를 수행합니다.

00:05:38.000 --> 00:05:41.000
RealityKit이 당신을 위해 부기를 하게 하세요.

00:05:41.000 --> 00:05:46.000
Flocking System은 FlockingComponent가 있는 모든 엔티티를 찾고 싶어 한다.

00:05:46.000 --> 00:05:53.000
먹는 시스템은 두 종류의 배고픈 엔티티와 음식의 한 종류인 엔티티를 원한다.

00:05:53.000 --> 00:05:58.000
따라서 시스템이 엔티티 쿼리를 사용할 때 정확히 무슨 일이 일어나고 있는지 자세히 살펴봅시다.

00:05:58.000 --> 00:06:03.000
시스템에는 모든 프레임이라고 불리는 업데이트 기능이 있다.

00:06:03.000 --> 00:06:05.000
옐로우 탕 물고기를 위한 무리를 짓는 시스템을 살펴봅시다.

00:06:05.000 --> 00:06:09.000
우리는 무슨 일이 일어나고 있는지 보기 위해 이 프레임에서 잠시 멈출 것이다.

00:06:09.000 --> 00:06:18.000
Flocking System의 업데이트 기능에서, 우리는 FlockingComponent와 MotionComponent가 모두 있는 장면의 모든 엔티티를 쿼리합니다.

00:06:18.000 --> 00:06:24.000
많은 것들이 모션 컴포넌트를 가지고 있지만, 우리는 그들 모두를 원하지 않는다, 우리는 단지 우리의 무리를 원한다.

00:06:24.000 --> 00:06:32.000
우리의 쿼리는 몰려드는 물고기를 반환하므로, 이제 우리는 무리의 각 물고기에 고전적인 Boids 시뮬레이션을 적용하여 사용자 지정 게임 물리학을 운전할 수 있습니다.

00:06:32.000 --> 00:06:46.000
우리는 각 물고기의 모션 컴포넌트에 힘을 추가하며, 여기서 우리는 프레임 사이의 상태를 유지하고, 함께 달라붙는 힘, 특정 거리를 유지하는 것을 선호하며, 그들의 코를 같은 방향으로 가리키려고 노력한다.

00:06:46.000 --> 00:06:57.000
모션 시스템이 같은 프레임에서 실행되지만 플로킹 시스템이 실행된 후, 물고기의 새로운 가속, 속도 및 위치를 결정하기 위해 이 모든 힘을 롤업합니다.

00:06:57.000 --> 00:06:59.000
어떤 다른 시스템이 그것들을 추가했는지는 신경 쓰지 않는다.

00:06:59.000 --> 00:07:07.000
Eating System과 Fear System과 같은 다른 것들은 물고기를 다양한 방향으로 밀기 위해 MotionComponent에서 작동한다.

00:07:07.000 --> 00:07:10.000
그럼 코드를 보자.

00:07:10.000 --> 00:07:13.000
여기 우리 무리를 짓는 시스템의 개요가 있습니다.

00:07:13.000 --> 00:07:18.000
RealityKit.System 프로토콜을 준수하는 클래스입니다.

00:07:18.000 --> 00:07:26.000
앱 실행 시간에 사용자 지정 시스템을 등록할 때, 앱에서 장면당 이 유형 중 하나를 인스턴스화하기를 원한다고 엔진에 말하고 있습니다.

00:07:26.000 --> 00:07:30.000
초기화가 필요하며, 데이니트를 제공할 수도 있습니다.

00:07:30.000 --> 00:07:32.000
우리는 종속성을 지정할 수 있다.

00:07:32.000 --> 00:07:39.000
이 시스템은 항상 MotionSystem 이전에 실행되어야 하며, 이것이 우리가 열거 값을 사용한 이유입니다.

00:07:39.000 --> 00:07:54.000
업데이트 기능에서, 우리는 MotionComponent에 저장된 상태를 변경할 것이며, MotionSystem은 우리가 제공하는 상태에 따라 작동할 것이므로, 생산자-소비자 관계와 같은 MotionSystem 전에 FlockingSystem이 실행되도록 해야 합니다.

00:07:54.000 --> 00:07:57.000
.After 옵션을 사용할 수도 있습니다.

00:07:57.000 --> 00:08:05.000
종속성을 지정하지 않으면, 시스템의 업데이트 기능은 등록한 순서대로 실행됩니다.

00:08:05.000 --> 00:08:10.000
EntityQuery는 Flocking 및 Motion 구성 요소가 있는 모든 엔티티를 원한다고 말합니다.

00:08:10.000 --> 00:08:15.000
그것은 우리의 시뮬레이션 기간 동안 변하지 않을 것이기 때문에 정적이다.

00:08:15.000 --> 00:08:22.000
멀티플레이어 AR 경험에서, 코다블을 준수하는 구성 요소는 네트워크를 통해 자동으로 동기화됩니다.

00:08:22.000 --> 00:08:27.000
그러나, 시스템의 데이터는 네트워크를 통해 자동으로 동기화되지 않습니다.

00:08:27.000 --> 00:08:30.000
데이터는 일반적으로 구성 요소에 저장되어야 한다.

00:08:30.000 --> 00:08:34.000
이제 FlockingSystem의 업데이트 기능에 대해 알아봅시다.

00:08:34.000 --> 00:08:42.000
그 프레임에 대한 델타타임과 장면 자체에 대한 참조가 있는 SceneUpdateContext가 필요합니다.

00:08:42.000 --> 00:08:52.000
먼저, 우리는 현장에서 EntityQuery를 수행하며, 이는 FlockingComponent가 있는 엔티티에 대해 반복할 수 있는 쿼리 결과를 반환합니다.

00:08:52.000 --> 00:08:57.000
우리는 각각을 수정할 모션 컴포넌트를 얻는다.

00:08:57.000 --> 00:08:59.000
왜 우리는 FlockingComponent 자체를 얻지 못하나요?

00:08:59.000 --> 00:09:02.000
왜냐하면 그것과 관련된 데이터가 없기 때문이다.

00:09:02.000 --> 00:09:07.000
우리는 무리의 회원 자격을 나타내기 위해 그것을 태그처럼 사용한다.

00:09:07.000 --> 00:09:15.000
그런 다음 우리는 표준 Boids 시뮬레이션을 실행하여 무리를 안내하고 MotionComponent의 힘 수집을 수정합니다.

00:09:15.000 --> 00:09:28.000
결국, 우리는 원하는 방향으로 밀기 위해 각 물고기에 힘을 추가했고, 구성 요소는 가치 유형인 스위프트 구조체이기 때문에, 우리는 MotionComponent를 그것이 나온 엔티티에 다시 저장해야 합니다.

00:09:28.000 --> 00:09:31.000
시스템은 사용자 지정 업데이트 기능을 구현할 필요가 없습니다.

00:09:31.000 --> 00:09:39.000
장면 이벤트에 대한 이벤트 핸들러를 등록하는 것과 같이 init만 제공하는 시스템을 만드는 것도 유용할 수 있다.

00:09:39.000 --> 00:09:45.000
지금까지, 우리는 엔티티, 구성 요소 및 사용자 지정 시스템 간의 관계를 살펴보고 있습니다.

00:09:45.000 --> 00:09:52.000
이제 잠시 축소하고 RealityKit 2에서 가져온 몇 가지 고급 아키텍처 변경 사항에 대해 이야기해 봅시다.

00:09:52.000 --> 00:09:59.000
이전에는 모든 프레임이라고 불리는 클로저를 사용하여 SceneEvents.update 이벤트를 구독했습니다.

00:09:59.000 --> 00:10:05.000
이러한 종류의 이벤트 핸들러는 종종 게임 관리자와 같은 수업에 참여하거나 적어도 등록될 것입니다.

00:10:05.000 --> 00:10:15.000
이와 같은 폐쇄 대신, 이제 업데이트 로직을 깔끔하게 분리하고 별도의 시스템 업데이트 기능에서 공식적으로 주문할 수 있습니다.

00:10:15.000 --> 00:10:19.000
그래서 그것은 당신의 게임 관리자가 역할을 덜 할 수 있다는 것을 의미합니다.

00:10:19.000 --> 00:10:36.000
이벤트 업데이트에 대한 모든 등록을 한 다음 게임의 모든 것에 대한 업데이트를 호출하는 순서를 관리하는 대신, 이제 게임 관리자는 해당 엔티티가 쿼리에 포함되어야 한다는 것을 시스템에 알리기 위해 엔티티에 구성 요소를 추가하기만 하면 됩니다.

00:10:36.000 --> 00:10:45.000
이전에는 엔티티 유형이 특정 구성 요소를 가지고 있음을 표현하기 위해 엔티티 서브클래스에 대한 프로토콜 적합성을 선언했습니다.

00:10:45.000 --> 00:10:51.000
이제 당신은 더 이상 엔티티를 서브클래스할 필요가 없습니다. 왜냐하면 그것 또한 더 적은 역할을 할 수 있기 때문입니다.

00:10:51.000 --> 00:10:57.000
그것은 단지 객체의 식별자일 수 있으며, 그 속성은 구성 요소로 모델링될 수 있다.

00:10:57.000 --> 00:11:03.000
왜냐하면 당신이 엔티티를 서브클래스하지 않을 때, 당신은 당신의 객체를 그 구성 요소를 영원히 유지하는 것에 묶지 않기 때문입니다.

00:11:03.000 --> 00:11:06.000
경험하는 동안 구성 요소를 자유롭게 추가하고 제거할 수 있습니다.

00:11:06.000 --> 00:11:13.000
따라서 RealityKit 2를 사용하면 사용자 지정 시스템이 있기 때문에 사용자 지정 구성 요소가 훨씬 더 유용합니다.

00:11:13.000 --> 00:11:15.000
하지만 넌 여전히 어느 쪽이든 할 수 있어.

00:11:15.000 --> 00:11:17.000
그것이 게임 개발의 아름다움이다.

00:11:17.000 --> 00:11:19.000
세상은 너의 굴이야.

00:11:19.000 --> 00:11:23.000
우리의 수중 데모에서, 우리는 두 가지 방법을 모두 사용하고 있다.

00:11:23.000 --> 00:11:27.000
우리는 또한 새로운 유형의 구성 요소를 추가했습니다: TransientComponent.

00:11:27.000 --> 00:11:33.000
예를 들어, 당신의 물고기는 문어를 두려워했지만, 그들이 그것을 본 적이 있다면 말하세요.

00:11:33.000 --> 00:11:39.000
새로운 물고기 개체를 복제할 때, 당신은 복제자가 문어에 대한 물고기의 두려움을 상속받는 것을 원하지 않을 수도 있습니다.

00:11:39.000 --> 00:11:43.000
FearComponent가 TransientComponent를 준수하도록 만들 수 있습니다.

00:11:43.000 --> 00:11:47.000
그렇게 하면, 그것은 새로운 실체에 존재하지 않을 것이다.

00:11:47.000 --> 00:11:56.000
TransientComponent는 다른 종류의 구성 요소와 마찬가지로 codable을 준수하는 경우 여전히 네트워크 동기화에 포함되어 있습니다.

00:11:56.000 --> 00:11:59.000
또 다른 추가 사항은 취소 가능한 우리의 새로운 확장이다.

00:11:59.000 --> 00:12:04.000
더 이상 엔티티의 이벤트 구독 취소를 수동으로 관리할 필요가 없습니다.

00:12:04.000 --> 00:12:08.000
우리는 당신이 storeWhileEntityActive를 사용할 때 당신을 위해 그것을 할 것입니다.

00:12:08.000 --> 00:12:12.000
여기서, 우리는 물고기 개체에 대한 충돌 사건을 처리하고 있습니다.

00:12:12.000 --> 00:12:18.000
우리는 물고기 자체보다 오래 살기 위해 이 구독이 필요하지 않으므로, storeWhileEntityActive를 사용합니다.

00:12:18.000 --> 00:12:25.000
항상 그렇듯이, 게임을 만들 때, 다시 컴파일할 필요 없이 즉석에서 조정하고 싶은 많은 설정이 있습니다.

00:12:25.000 --> 00:12:36.000
우리 게임에서, 우리는 SwiftUI에서 설정 보기를 만들었고, CustomComponents로 래핑하여 백업 모델을 다양한 CustomSystems로 전달합니다.

00:12:36.000 --> 00:12:47.000
우리는 설정 인스턴스를 @StateObject로 만들고 ARViewContainer와 SwiftUI 뷰를 environmentObject로 전달합니다.

00:12:47.000 --> 00:12:51.000
우리는 SettingsComponent인 CustomComponent에 설정 객체를 래핑합니다.

00:12:51.000 --> 00:12:56.000
그런 다음 물고기 엔티티를 만들 때, SettingsComponent를 제공합니다.

00:12:56.000 --> 00:13:06.000
그렇게 하면, 이러한 설정을 원하는 CustomSystem이 올 때, "최고 속도" 값을 가져와 각 물고기의 속도를 제한하는 데 사용하는 것과 같이 거기에서 읽을 수 있습니다.

00:13:06.000 --> 00:13:12.000
그리고 이제 재료에 대해 말씀드리기 위해 제 동료인 올리비에에게 넘겨드리겠습니다.

00:13:12.000 --> 00:13:14.000
고마워, 아만다.

00:13:14.000 --> 00:13:17.000
올해, 우리는 재료에 대한 새로운 API를 추가했다.

00:13:17.000 --> 00:13:24.000
우리는 이미 baseColor, 거칠기 및 금속 특성을 가진 SimpleMaterial과 같은 몇 가지 유형을 가지고 있었다.

00:13:24.000 --> 00:13:29.000
우리는 또한 색상만 있고 조명이 없는 UnlitMaterial을 가지고 있었다.

00:13:29.000 --> 00:13:35.000
우리는 가상 물체를 숨기기 위한 마스크로 사용할 수 있는 OcclusionMaterials를 가지고 있었다.

00:13:35.000 --> 00:13:42.000
그리고 작년에, 우리는 비디오를 색상으로 사용하는 UnlitMaterials인 VideoMaterials를 도입했습니다.

00:13:42.000 --> 00:13:45.000
올해 우리는 투명성에 대한 지원을 추가했다는 점에 유의하십시오.

00:13:45.000 --> 00:13:51.000
비디오 파일에 투명도가 포함되어 있다면, 객체를 렌더링하는 데 사용됩니다.

00:13:51.000 --> 00:14:03.000
올해, 우리는 USD의 재료 스키마와 매우 유사한 PhysicallyBasedMaterial 유형부터 시작하여 재료에 대한 고급 제어를 제공하는 새로운 API를 추가했습니다.

00:14:03.000 --> 00:14:10.000
그것은 SimpleMaterial의 상위 집합이며 다른 렌더러에서 찾을 수 있는 대부분의 표준 PBR 속성을 가지고 있습니다.

00:14:10.000 --> 00:14:14.000
이것은 USD에서 로드된 엔티티에서 찾을 수 있는 자료입니다.

00:14:14.000 --> 00:14:24.000
예를 들어, 광대 물고기의 USD를 로드한 다음 재료의 개별 속성을 수정하여 금색이나 보라색으로 만들 수 있습니다.

00:14:24.000 --> 00:14:31.000
재료의 특성 중에서, 예를 들어, 메쉬의 일부가 아닌 작은 세부 사항을 추가하기 위해 일반 지도를 변경할 수 있습니다.

00:14:31.000 --> 00:14:35.000
모델의 투명성을 정의하는 텍스처를 할당할 수도 있습니다.

00:14:35.000 --> 00:14:46.000
기본적으로 투명성은 알파 블렌딩을 사용하지만, 불투명도 임계값을 할당하면 임계값 아래의 모든 조각이 폐기됩니다.

00:14:46.000 --> 00:14:52.000
앰비언트 오클루전의 텍스처를 설정하여 모델에서 모호한 그림자를 정의할 수 있습니다.

00:14:52.000 --> 00:14:59.000
그리고 더 진보된 특성의 예는 재료에 반사 페인트의 추가 층을 시뮬레이션하는 클리어코트이다.

00:14:59.000 --> 00:15:05.000
그리고 PhysicallyBasedMaterial 유형에는 다른 많은 속성이 있습니다.

00:15:05.000 --> 00:15:11.000
우리는 또한 당신의 금속 코드를 사용하여 재료를 만들기 위해 사용자 지정 재료라는 새로운 유형을 추가했습니다.

00:15:11.000 --> 00:15:15.000
이것이 우리가 이 문어 모델에 색 전환 효과를 만드는 데 사용한 것이다.

00:15:15.000 --> 00:15:21.000
우리는 렌더링에 대한 두 번째 이야기에서 이 셰이더와 사용자 지정 재료를 설명할 것이다.

00:15:21.000 --> 00:15:27.000
자료 외에도, 우리는 RealityKit에서 애니메이션에 대한 더 많은 제어를 추가했습니다.

00:15:27.000 --> 00:15:35.000
먼저, 주로 USD에서 로드된 애니메이션의 재생에 관한 애니메이션을 위한 기존 API를 살펴봅시다.

00:15:35.000 --> 00:15:38.000
USD에서 애니메이션을 로드하면, 한 번 재생할 수 있습니다.

00:15:38.000 --> 00:15:45.000
당신은 또한 무한히 반복되도록 반복할 수 있으며, 이것이 우리가 여기 다이버의 유휴 애니메이션을 위해 원하는 것입니다.

00:15:45.000 --> 00:15:49.000
애니메이션을 일시 중지, 재개 및 중지할 수도 있습니다.

00:15:49.000 --> 00:15:55.000
마지막으로, 새로운 애니메이션을 재생할 때, 전환 기간을 지정할 수 있습니다.

00:15:55.000 --> 00:16:00.000
하나를 지정하지 않으면, 캐릭터는 즉시 새로운 애니메이션으로 전환됩니다.

00:16:00.000 --> 00:16:07.000
전환 기간을 지정하면, RealityKit은 그 시간 동안 오래된 애니메이션과 새로운 애니메이션을 혼합할 것입니다.

00:16:07.000 --> 00:16:13.000
예를 들어, 이것은 다이버의 걷기와 유휴 주기 사이를 전환할 때 유용하다.

00:16:13.000 --> 00:16:17.000
하지만 우리는 여전히 그곳에서 발의 애니메이션을 개선할 수 있다.

00:16:17.000 --> 00:16:22.000
우리는 애니메이션을 더 사실적으로 만들기 위해 블렌드 레이어에 새로운 API를 사용할 수 있습니다.

00:16:22.000 --> 00:16:32.000
우리는 두 개의 분리된 블렌드 레이어에서 워킹 애니메이션과 유휴 애니메이션을 재생하며, 최상층에서 워킹 애니메이션을 재생했기 때문에, 그것이 우리가 현재 볼 수 있는 유일한 애니메이션이다.

00:16:32.000 --> 00:16:38.000
하지만 우리는 아래의 유휴 애니메이션을 드러내기 위해 워킹 애니메이션의 혼합 요소를 변경할 수 있습니다.

00:16:38.000 --> 00:16:45.000
혼합 요소가 작아짐에 따라 발자취도 어떻게 작아지는지 주목하세요.

00:16:45.000 --> 00:16:51.000
그리고 우리는 또한 다이버가 더 빠르거나 느리게 걸을 수 있도록 애니메이션의 재생 속도를 변경할 수 있습니다.

00:16:51.000 --> 00:16:55.000
여기서, 다이버는 절반 속도로 걷고 있다.

00:16:55.000 --> 00:17:01.000
마지막으로, 우리는 이 두 값을 모두 제어하기 위해 지면에 상대적인 문자의 속도를 사용합니다.

00:17:01.000 --> 00:17:08.000
이렇게 하면, 우리는 애니메이션을 더 매끄럽게 만들고 땅에 비해 발의 미끄러짐을 줄일 수 있다.

00:17:08.000 --> 00:17:14.000
지금까지, 우리는 유휴 및 워크 사이클과 같은 여러 애니메이션 클립을 사용해 왔습니다.

00:17:14.000 --> 00:17:18.000
이것들은 RealityKit에 AnimationResources로 저장됩니다.

00:17:18.000 --> 00:17:21.000
그리고 USD 파일에서 그것들을 로드하는 방법은 여러 가지가 있다.

00:17:21.000 --> 00:17:25.000
첫 번째 방법은 클립당 하나의 USD 파일을 갖는 것이다.

00:17:25.000 --> 00:17:31.000
우리는 각 USD를 엔티티로 로드하고 애니메이션을 AnimationResources로 얻을 수 있습니다.

00:17:31.000 --> 00:17:39.000
그런 다음 AnimationResource는 골격의 관절 이름이 애니메이션과 일치하는 한 모든 엔티티에서 재생할 수 있습니다.

00:17:39.000 --> 00:17:50.000
여러 애니메이션 클립을 로드하는 또 다른 방법은 동일한 타임라인에서 단일 USD로 만든 다음 AnimationViews를 사용하여 이 타임라인을 여러 클립으로 분할하는 것입니다.

00:17:50.000 --> 00:17:54.000
이것은 각 클립 사이의 타임코드를 알아야 한다.

00:17:54.000 --> 00:18:01.000
그런 다음 각 AnimationView를 AnimationResource로 변환하고 이전 방법과 정확히 같은 방식으로 사용할 수 있습니다.

00:18:01.000 --> 00:18:05.000
이제 앱에서 문어의 애니메이션을 살펴봅시다.

00:18:05.000 --> 00:18:11.000
문어는 숨어 있지만, 플레이어가 가까워지면 무서워서 새로운 은신처로 이동할 것이다.

00:18:11.000 --> 00:18:13.000
어떻게 애니메이션을 만드는지 보자.

00:18:13.000 --> 00:18:18.000
우리는 문어의 골격 애니메이션을 로딩하는 것으로 시작합니다: 점프, 수영, 착륙.

00:18:18.000 --> 00:18:24.000
이 애니메이션은 우리가 다이버를 위해 했던 것과 마찬가지로 USD에서 로드됩니다.

00:18:24.000 --> 00:18:29.000
하지만 우리는 또한 한 위치에서 다음 위치로 옮기기 위해 문어의 변형을 애니메이션화하고 싶습니다.

00:18:29.000 --> 00:18:38.000
변환을 애니메이션화하기 위해, 우리는 새로운 API를 사용하여 FromToByAnimation 유형의 애니메이션을 프로그래밍 방식으로 만듭니다.

00:18:38.000 --> 00:18:41.000
이렇게 하면, 우리는 그 위치를 애니메이션화할 수 있다.

00:18:41.000 --> 00:18:46.000
문어에서 어떻게 생겼는지 보자.

00:18:46.000 --> 00:18:53.000
더 흥미롭게 만들기 위해, 회전도 애니메이션화해 봅시다.

00:18:53.000 --> 00:18:59.000
문어는 이제 움직이는 동안 회전하지만, 옆으로 헤엄치고 있는데, 이는 그다지 현실적이지 않다.

00:18:59.000 --> 00:19:03.000
우리는 일련의 애니메이션을 만들어 이것을 개선할 수 있다.

00:19:03.000 --> 00:19:07.000
먼저, 우리는 문어를 새로운 위치로 회전시킨다.

00:19:07.000 --> 00:19:10.000
그런 다음 우리는 그것을 새로운 위치로 번역한다.

00:19:10.000 --> 00:19:15.000
그리고 마지막으로, 우리는 문어를 카메라를 향해 다시 회전시킨다.

00:19:15.000 --> 00:19:22.000
그리고 여기 전체 애니메이션이 있습니다.

00:19:22.000 --> 00:19:29.000
애니메이션을 위한 새로운 API 외에도, 우리는 캐릭터의 물리학을 관리하는 방법도 추가했습니다.

00:19:29.000 --> 00:19:31.000
그것은 캐릭터 컨트롤러라고 불린다.

00:19:31.000 --> 00:19:36.000
이것은 우리가 장면의 충돌자와 물리적으로 상호 작용할 수 있는 캐릭터를 만들 수 있게 해준다.

00:19:36.000 --> 00:19:41.000
여기서, 우리는 다이버가 바닥에서 소파로 점프하고 그 위를 걷는 것을 본다.

00:19:41.000 --> 00:19:45.000
이것은 다이버에게 캐릭터 컨트롤러를 추가함으로써 달성된다.

00:19:45.000 --> 00:19:52.000
그것으로, 다이버는 LiDAR 센서에서 생성된 환경의 메쉬와 자동으로 상호 작용할 것이다.

00:19:52.000 --> 00:19:55.000
캐릭터 컨트롤러를 만드는 것은 간단하다.

00:19:55.000 --> 00:19:59.000
캐릭터의 모양과 일치하는 캡슐을 정의하기만 하면 됩니다.

00:19:59.000 --> 00:20:05.000
생성 시, 캡슐의 높이와 반경을 지정해야 합니다.

00:20:05.000 --> 00:20:11.000
문자 컨트롤러가 엔티티에 할당된 후, 모든 프레임마다 move(to:) 함수를 호출할 수 있습니다.

00:20:11.000 --> 00:20:17.000
그것은 캐릭터를 원하는 위치로 이동하게 할 것이지만, 장애물을 통과하지 않을 것이다.

00:20:17.000 --> 00:20:22.000
반면에, 장애물을 무시하고 싶다면, 순간이동 기능을 사용할 수 있습니다.

00:20:22.000 --> 00:20:29.000
이제 아만다에게 넘겨줄게, 아만다는 우리가 이번 RealityKit 출시에 추가한 몇 가지 재미있는 기능을 더 안내해 줄 거야.

00:20:29.000 --> 00:20:31.000
좋아. 고마워, 올리비에.

00:20:31.000 --> 00:20:40.000
좋아요, 디스크에서 로드하지 않고도 즉석에서 리소스를 만들 수 있는 두 가지 새로운 API를 강조하겠습니다.

00:20:40.000 --> 00:20:47.000
먼저 SceneUnderstanding에서 사람의 얼굴 메쉬를 얻을 수 있는 방법을 보여드리고, 오디오를 생성하는 방법을 안내해 드리겠습니다.

00:20:47.000 --> 00:20:52.000
절차적으로 생성된 예술을 위해 이것들이 열리는 가능성의 바다가 있다.

00:20:52.000 --> 00:20:55.000
먼저, 얼굴 메쉬.

00:20:55.000 --> 00:21:06.000
나는 우리가 데모 앱에 있는 보라색과 주황색 문어의 모습에 너무 영감을 받았고, 내 얼굴에 하나를 칠하려고 노력했지만, 사실상 새로운 얼굴 메쉬 기능을 사용했다.

00:21:06.000 --> 00:21:18.000
SceneUnderstanding은 이제 사람들의 얼굴을 나타내는 엔티티를 제공할 수 있으며, 그 엔티티에는 ModelComponents가 있습니다. 즉, 얼굴 엔티티의 메쉬에 있는 재료의 속성을 바꿀 수 있습니다.

00:21:18.000 --> 00:21:24.000
우리는 라이브 드로잉으로 즉석에서 얼굴 메쉬에 적용할 텍스처를 생성하는 데 많은 재미를 가졌습니다.

00:21:24.000 --> 00:21:26.000
코드를 봅시다.

00:21:26.000 --> 00:21:44.000
SceneUnderstandingComponent는 이제 SceneUnderstandingSystem에 의해 설정되며 두 가지 값 중 하나를 취할 수 있는 entityType이라는 열거형 속성을 가지고 있습니다: 얼굴, 즉 실제 사람의 얼굴을 표현하거나, 재구성된 세계 메쉬의 다른 부분이라는 것을 의미하는 meshChunk.

00:21:44.000 --> 00:21:48.000
그것은 또한 0이 될 수 있는데, 이는 그 유형이 아직 알려지지 않았다는 것을 의미한다.

00:21:48.000 --> 00:21:50.000
여기 다시 EntityQuery가 있습니다.

00:21:50.000 --> 00:21:57.000
SceneUnderstandingComponent가 있는 엔티티를 쿼리하고 엔티티 유형을 확인하여 얼굴을 찾을 수 있습니다.

00:21:57.000 --> 00:22:02.000
그런 다음, 당신은 그 엔티티에서 ModelComponents를 얻고 당신이 원하는 무엇이든 할 수 있습니다.

00:22:02.000 --> 00:22:14.000
페이스 페인팅 샘플에서, 우리는 PencilKit을 사용하여 사람들이 캔버스에 그림을 그린 다음 CGImage에서 TextureResource를 만들어 결과 CGImage를 faceEntity에 감싸고 있습니다.

00:22:14.000 --> 00:22:25.000
우리는 이 페이스 페인트를 가능한 한 사실적으로 보이게 하기 위해 PhysicallyBasedMaterial을 사용하고 있으며, 우리의 모습을 위해 전화를 걸기 위해 몇 가지 속성을 설정하고 있습니다.

00:22:25.000 --> 00:22:36.000
반짝이 페인트 효과를 만들기 위해, 우리는 물리적 기반 렌더러에게 단순히 재료를 금속으로 남겼을 때와 다르게 이 표면에 빛을 어떻게 반사해야 하는지 알려주는 일반 지도 텍스처를 사용합니다.

00:22:36.000 --> 00:22:43.000
그런 다음 연필로 그린 TextureResource를 재료에 주고 엔티티에 설정합니다.

00:22:43.000 --> 00:22:47.000
그래서 그것은 우리의 새로운 생성된 자원으로 작업하는 한 가지 방법이다.

00:22:47.000 --> 00:22:51.000
이제 생성할 수 있는 또 다른 유형의 리소스는 AudioBufferResource입니다.

00:22:51.000 --> 00:23:01.000
원하는 대로 AVAudioBuffer를 얻을 수 있습니다: 마이크 입력을 녹음하거나, 절차적으로 직접 생성하거나, AVSpeechSynthesizer를 사용하여.

00:23:01.000 --> 00:23:08.000
그런 다음 AVAudioBuffer를 사용하여 AudioBufferResource를 만들고 이를 사용하여 앱에서 사운드를 재생할 수 있습니다.

00:23:08.000 --> 00:23:14.000
AVSpeechSynthesizer에 AVSpeechUtterance를 작성하여 텍스트를 음성으로 바꾸는 방법은 다음과 같습니다.

00:23:14.000 --> 00:23:17.000
우리는 콜백으로 AVAudioBuffer를 받습니다.

00:23:17.000 --> 00:23:26.000
여기서, 우리는 AudioBufferResource를 만들고 3D 위치 오디오를 사용하기 위해 inputMode를 .spatial로 설정하고 있습니다.

00:23:26.000 --> 00:23:30.000
사용 가능한 다른 입력 모드는 비공간적이고 주변적이다.

00:23:30.000 --> 00:23:33.000
그런 다음 우리는 엔티티에게 그 오디오를 재생하라고 말한다.

00:23:33.000 --> 00:23:43.000
물론, 당신은 멋진 트릭으로 오디오 버퍼를 처리하여 물고기가 물속에서 이야기하거나 당신이 생각해 낼 수 있는 재미있는 것들을 할 때 거품을 부는 것처럼 들리게 할 수 있습니다.

00:23:43.000 --> 00:23:47.000
그래서 이것은 올해 RealityKit의 새로운 기능 중 일부에 대한 개요였다.

00:23:47.000 --> 00:23:52.000
우리는 당신이 장면의 모습과 행동을 더 잘 통제할 수 있도록 하는 데 정말 집중했습니다.

00:23:52.000 --> 00:24:00.000
우리는 사용자 지정 시스템을 제공하기 위해 ECS를 수정하여 앱의 동작을 훨씬 더 유연하게 구조화할 수 있습니다.

00:24:00.000 --> 00:24:04.000
우리는 자료와 애니메이션 API에 많은 발전을 추가했습니다.

00:24:04.000 --> 00:24:10.000
우리는 당신의 엔티티가 실제 환경과 쉽게 상호 작용할 수 있도록 캐릭터 컨트롤러를 도입했습니다.

00:24:10.000 --> 00:24:15.000
마지막으로, 우리는 당신이 즉석에서 자원을 생성할 수 있는 몇 가지 방법을 강조했습니다.

00:24:15.000 --> 00:24:19.000
하지만 그것은 확실히 RealityKit 2의 새로운 모든 것의 완전한 목록은 아니다.

00:24:19.000 --> 00:24:29.000
이번 주 후반의 두 번째 RealityKit 세션에서 새로운 렌더링 기능에 대해 자세히 알아보고 수중 데모에서 몇 가지를 어떻게 구현했는지 볼 수 있습니다.

00:24:29.000 --> 00:24:32.000
기하학 수정자는 우리가 해초를 애니메이션화하는 데 사용하는 것이다.

00:24:32.000 --> 00:24:37.000
문어는 표면 셰이더를 사용하여 색상 사이를 아름답게 전환한다.

00:24:37.000 --> 00:24:43.000
푸른 깊이 안개 효과와 물 부식제는 후처리를 사용하여 만들어졌다.

00:24:43.000 --> 00:24:48.000
그리고 생성 자원의 주제에서, 당신은 동적 메쉬를 사용하는 방법을 배우게 될 것입니다.

00:24:48.000 --> 00:24:55.000
재교육을 위해, 2019년부터 "RealityKit으로 앱 구축" 세션을 확인할 수도 있습니다.

00:24:55.000 --> 00:25:01.000
감사합니다, 그리고 우리는 이 API로 당신의 창의성의 깊이를 보기를 기대합니다.

00:25:01.000 --> 23:59:59.000
[쾌활한 음악].

