WEBVTT

00:00:02.000 --> 00:00:12.000
안녕하세요, WWDC에 오신 것을 환영합니다.

00:00:12.000 --> 00:00:16.000
제 이름은 Frank Doepke이고, 저는 Vision 팀의 엔지니어입니다.

00:00:16.000 --> 00:00:20.000
비전 프레임워크는 이미지 분석에 중점을 두고 수년에 걸쳐 성장했다.

00:00:20.000 --> 00:00:26.000
더 잘 이해하기 위해, 우리는 사용 초점 측면에서 비전의 능력을 볼 수 있다.

00:00:26.000 --> 00:00:27.000
스포츠.

00:00:27.000 --> 00:00:36.000
물체 추적과 인간 포즈 분석은 스포츠 애플리케이션을 만드는 데 도움이 될 수 있는 요청 중 일부일 뿐입니다.

00:00:36.000 --> 00:00:38.000
접근성.

00:00:38.000 --> 00:00:46.000
OCR 또는 이미지 분류 및 물체 감지와 같은 비전 요청은 시각 장애가 있는 사용자에게 도움이 되고 있다.

00:00:46.000 --> 00:00:47.000
사람들.

00:00:47.000 --> 00:00:52.000
비전은 앱이 사용할 수 있는 많은 얼굴과 신체 관련 요청을 제공합니다.

00:00:52.000 --> 00:01:00.000
"비전을 사용하여 사람, 얼굴 및 포즈 감지" 세션에서 이에 대해 자세히 알아볼 수 있습니다.

00:01:00.000 --> 00:01:01.000
건강.

00:01:01.000 --> 00:01:11.000
바코드 스캔과 OCR에서 인간 포즈 분석에 이르기까지, 비전은 스마트 건강 애플리케이션을 만들기 위한 빌딩 블록을 제공합니다.

00:01:11.000 --> 00:01:13.000
전산 사진.

00:01:13.000 --> 00:01:19.000
세로 모드와 같은 기능은 얼굴 감지와 세분화에 의존한다.

00:01:19.000 --> 00:01:21.000
보안.

00:01:21.000 --> 00:01:29.000
얼굴 및 인간 감지와 같은 요청은 보안 카메라의 모션 감지와 같은 애플리케이션에 유용합니다.

00:01:29.000 --> 00:01:31.000
그리고 서류.

00:01:31.000 --> 00:01:36.000
이것이 우리가 이 세션에서 집중하고 싶은 것이다.

00:01:36.000 --> 00:01:55.000
비전은 문서 분석에 도움이 되는 다양한 요청을 제공합니다: 바코드 감지, 텍스트 인식 또는 일반적으로 OCR, 윤곽 감지, 직사각형 감지 및 올해의 새로운 문서 세분화 감지.

00:01:55.000 --> 00:01:56.000
여기 우리의 의제가 있습니다.

00:01:56.000 --> 00:01:59.000
먼저, 우리는 바코드 탐지에 대해 이야기할 것이다.

00:01:59.000 --> 00:02:01.000
그럼, 우리는 텍스트 인식에 대해 이야기할 거야.

00:02:01.000 --> 00:02:04.000
그리고 마지막으로, 우리는 문서 탐지에 대해 이야기할 것이다.

00:02:04.000 --> 00:02:07.000
바코드 감지를 살펴봅시다.

00:02:07.000 --> 00:02:12.000
올해, 우리는 바코드 탐지 요청의 새로운 개정을 도입하고 있습니다.

00:02:12.000 --> 00:02:18.000
VNDetectBarcodesRequestRevision2는 새로운 기호를 지원합니다.

00:02:18.000 --> 00:02:40.000
Codabar, GS1Databar는 Expanded and Limited, MicroPDF 및 MicroQR을 포함하며, 후자는 URL에 대한 QR 코드를 만들고 공간을 훨씬 적게 사용하기 때문에 작은 라벨이나 패키지에 배치해야 하는 경우에 특히 유용합니다.

00:02:40.000 --> 00:02:55.000
우리는 고객이 지정한 관심 지역과 관련하여 결과 경계 상자가 어떻게 보고되는지와 관련하여 이 새로운 개정판의 동작을 나머지 비전과 일치하도록 변경했습니다.

00:02:55.000 --> 00:02:58.000
그 변화를 자세히 살펴봅시다.

00:02:58.000 --> 00:03:01.000
여기, QR 코드가 있는 문서가 있습니다.

00:03:01.000 --> 00:03:10.000
ROI라고도 알려진 관심 지역을 지정하지 않으면, 경계 상자가 전체 이미지와 관련하여 보고됩니다.

00:03:10.000 --> 00:03:17.000
이제, 카메라가 보는 것의 중심 부분에만 초점을 맞추고 싶은 것처럼 ROI를 지정해 봅시다.

00:03:17.000 --> 00:03:25.000
개정판 2는 이제 다른 비전 요청과 마찬가지로 ROI와 관련하여 경계 상자를 보고합니다.

00:03:25.000 --> 00:03:29.000
안타깝게도, 개정판 1은 항상 전체 이미지와 관련하여 보고한다.

00:03:29.000 --> 00:03:34.000
하지만 우리는 그 행동을 바꾸고 싶지 않아, 왜냐하면 그것은 잠재적으로 기존 고객을 깨뜨릴 수 있기 때문이야.

00:03:34.000 --> 00:03:45.000
그리고 상기시켜 드리자면, 최신 SDK에 대해 애플리케이션을 컴파일하고 특정 수정본을 지정하지 않으면, 항상 요청에 대한 최신 수정본을 받게 됩니다.

00:03:45.000 --> 00:03:57.000
그러나 개정판 1을 지정하거나 새로운 SDK에 대해 다시 컴파일하지 않는 애플리케이션의 경우, 그들은 여전히 이전 개정판 1 동작을 얻을 것이다.

00:03:57.000 --> 00:04:03.000
Vision에서 바코드 감지 요청의 몇 가지 흥미로운 측면을 강조하겠습니다.

00:04:03.000 --> 00:04:07.000
비전은 1D 및 2D 바코드를 지원합니다.

00:04:07.000 --> 00:04:16.000
하지만 정말 흥미로운 것은 하나의 이미지 내에서 여러 코드와 여러 기호를 한 번에 감지할 수 있다는 것이다.

00:04:16.000 --> 00:04:21.000
그것은 당신이 여러 코드를 얻기 위해 반복해서 스캔할 필요가 없다는 것을 의미합니다.

00:04:21.000 --> 00:04:24.000
이것은 대부분의 휴대용 스캐너에 비해 큰 장점이다.

00:04:24.000 --> 00:04:32.000
여러 기호를 스캔하면 지정한 기호가 많을수록 더 오래 걸린다는 것을 명심하세요.

00:04:32.000 --> 00:04:40.000
그래서 당신은 당신의 사용 사례와 관련된 기호로만 요청을 설정하고 싶습니다.

00:04:40.000 --> 00:04:47.000
바코드 스캔을 위한 새로운 기호가 확장됨에 따라, 비전은 보건 분야에서 특히 유용한 역할을 할 수 있다.

00:04:47.000 --> 00:04:57.000
iPhone을 사용하면 한 번에 여러 코드를 분석할 수 있으며, 인터넷 연결 덕분에 별도의 스캐너 없이 정보를 가져올 수 있습니다.

00:04:57.000 --> 00:05:10.000
그리고 iPhone의 강력한 저조도 기능 덕분에 어두운 시나리오에서도 레이저를 쏘거나 환자가 쉬는 동안 방해하지 않고 코드를 스캔할 수 있습니다.

00:05:10.000 --> 00:05:15.000
이제, 비전이 바코드 감지를 어떻게 수행하는지 살펴봅시다.

00:05:15.000 --> 00:05:18.000
1D 코드는 선으로 스캔될 것이다.

00:05:18.000 --> 00:05:23.000
그것은 당신이 같은 코드에 대해 여러 번 탐지할 수 있다는 것을 의미합니다.

00:05:23.000 --> 00:05:33.000
바코드에 포함된 실제 데이터인 페이로드를 보면 중복을 쉽게 제거할 수 있습니다.

00:05:33.000 --> 00:05:35.000
2D 코드는 단일 단위로 스캔됩니다.

00:05:35.000 --> 00:05:39.000
그것은 당신이 전체 코드에 대해 하나의 경계 상자를 돌려 받는다는 것을 의미합니다.

00:05:39.000 --> 00:05:45.000
2D 코드의 예는 QR 코드일 것이다.

00:05:45.000 --> 00:05:49.000
각 바코드는 자체 관찰로 보고됩니다.

00:05:49.000 --> 00:05:58.000
하지만 내가 전에 언급했듯이, 1D 코드는 같은 내용으로 여러 관찰을 반환할 수 있지만, 물리적 위치는 다르다.

00:05:58.000 --> 00:06:05.000
페이로드는 바코드의 내용, 즉 이 기계가 읽을 수 있는 코드에 포함된 데이터이다.

00:06:05.000 --> 00:06:14.000
특히 QR 코드의 페이로드의 경우, 데이터 탐지기를 사용하여 인코딩된 URL을 분석할 수 있습니다.

00:06:14.000 --> 00:06:17.000
이제, 이것을 작은 데모로 살펴봅시다.

00:06:17.000 --> 00:06:24.000
좋아요, 여기 Xcode 놀이터가 있는데, 그 안에 모든 바코드가 있는 이미지가 있습니다.

00:06:24.000 --> 00:06:29.000
나는 VNDetectBarcodesRequest를 사용하고, 개정을 2로 설정했다.

00:06:29.000 --> 00:06:38.000
이제, 기호로서, 나는 단지 코다바를 가지고 있고, 우리가 이것을 볼 때, 우리는 코다바가 빨간색으로 강조 표시된 것을 본다.

00:06:38.000 --> 00:06:46.000
이제, 저는 이것을 QR로 바꿀 수 있습니다.

00:06:46.000 --> 00:06:52.000
지금 일어나는 일은 우리가 요청을 다시 실행하고, QR 코드가 강조 표시되는 것을 본다는 것이다.

00:06:52.000 --> 00:06:58.000
하지만 그것은 배열이기 때문에, 나는 그것으로 다른 요청을 지정할 수도 있습니다, ean8이라고 가정해 봅시다.

00:06:58.000 --> 00:07:06.000
그리고 내가 그렇게 할 때, 우리는 이제 우리가 ean8과 QR 코드를 둘 다 가지고 있다는 것을 알게 될 것이다.

00:07:06.000 --> 00:07:08.000
하지만 내가 그것들을 모두 얻고 싶다면 어떡하지?

00:07:08.000 --> 00:07:13.000
나는 단순히 빈 배열을 통과하고, 그 순간, 모든 상징을 읽는다.

00:07:13.000 --> 00:07:18.000
그리고 보시다시피, 지금 모두 하단의 코드로 강조 표시되어 있습니다.

00:07:18.000 --> 00:07:21.000
우리 슬라이드로 돌아가자.

00:07:21.000 --> 00:07:25.000
바코드에서, 우리는 이제 텍스트 인식을 살펴보기 위해 나아가고 있다.

00:07:25.000 --> 00:07:29.000
비전은 2019년에 텍스트 인식을 도입했다.

00:07:29.000 --> 00:07:33.000
그것은 두 가지 모드로 작동한다: 빠르고 정확하다.

00:07:33.000 --> 00:07:37.000
그 이후로, 비전은 언어 지원을 확대했다.

00:07:37.000 --> 00:07:42.000
텍스트 인식이 어떻게 작동하는지 그리고 언어가 어디에서 역할을 하는지 살펴봅시다.

00:07:42.000 --> 00:07:46.000
빠른 경로에는 라틴 문자 인식기가 있다.

00:07:46.000 --> 00:07:54.000
반면에, 정확한 경로는 단어와 선에서 작동하는 기계 학습 기반 인식기를 사용한다.

00:07:54.000 --> 00:07:59.000
인식이 완료된 후, 각 경로는 언어 교정 단계를 거친다.

00:07:59.000 --> 00:08:02.000
그리고, 결국, 우리는 인식된 텍스트를 되찾는다.

00:08:02.000 --> 00:08:05.000
언어 선택은 인식 단계에 영향을 미친다.

00:08:05.000 --> 00:08:13.000
빠른 경로에서, 그것은 독일어의 움라우트와 같이 다른 라틴 문자 집합이 지원된다는 것을 의미한다.

00:08:13.000 --> 00:08:23.000
정확한 경로에서, 그 구조가 라틴어 기반 언어와 매우 다르기 때문에 중국어를 인식해야 할 때 완전히 다른 모델이 사용된다.

00:08:23.000 --> 00:08:31.000
즉, 중국어 텍스트를 읽어야 한다면, 중국어가 요청의 기본 언어인 것이 중요합니다.

00:08:31.000 --> 00:08:40.000
언어 선택은 또한 작업에 대한 올바른 사전을 선택하기 때문에 언어 교정에 영향을 미친다.

00:08:40.000 --> 00:08:44.000
그래서, 텍스트 인식에서 언어를 사용할 때 가장 좋은 방법은 무엇인가요?

00:08:44.000 --> 00:08:56.000
고정된 언어 세트가 지원되는 것처럼 보일 수 있지만, supportedRecognitionLanguages()를 사용하여 주어진 요청 구성에 대해 지원되는 언어를 쿼리하는 것이 항상 좋습니다.

00:08:56.000 --> 00:09:01.000
여러 언어를 지정할 수 있으며, 이 경우 순서가 중요합니다.

00:09:01.000 --> 00:09:06.000
모호함이 있을 때, 그것은 언어의 순서대로 해결된다.

00:09:06.000 --> 00:09:13.000
특히 정확한 경로의 경우, 첫 번째 언어는 어떤 인식 모델이 사용될지 결정한다.

00:09:13.000 --> 00:09:22.000
그것은 당신의 사용 사례가 요청에서 어떤 언어를 사용하고 싶은지 지시한다는 것을 의미합니다.

00:09:22.000 --> 00:09:25.000
이것을 작은 데모로 봅시다.

00:09:25.000 --> 00:09:35.000
그래서, 저는 지금 샘플 코드의 개정된 버전을 가지고 있으며, 당신은 제가 다른 언어의 텍스트가 있는 이미지를 가지고 있다는 것을 알 수 있습니다.

00:09:35.000 --> 00:09:39.000
이제, 저는 개정판 2를 지정했고, 어떤 언어가 지원되는지 알 수 있습니다.

00:09:39.000 --> 00:09:45.000
우리는 영어, 프랑스어, 그리고 다른 것을 가지고 있다.

00:09:45.000 --> 00:09:52.000
이제, 예를 들어, 내가 개정판 1로 다시 전환하면, 우리는 내가 영어만 가지고 있다는 것을 알 수 있다.

00:09:52.000 --> 00:09:57.000
그리고 그것은 정확한 경로와 마찬가지로 빠른 것도 마찬가지이다.

00:09:57.000 --> 00:10:00.000
이제, 개정판 2로 돌아가자.

00:10:00.000 --> 00:10:10.000
예를 들어, 내가 지금 독일어로 바꿀 때, 나는 실제로 Grüsse aus Cupertino에서 움라우트를 정확하게 얻는다는 것을 주목하세요.

00:10:10.000 --> 00:10:15.000
하지만 나는 중국인을 위한 빠른 길에 대한 지원이 없다.

00:10:15.000 --> 00:10:22.000
정확한 경로에서, 나는 이제 중국어를 고를 수 있다.

00:10:22.000 --> 00:10:27.000
그리고 이제, 우리는 마침내 "Hello World"에 대한 올바른 중국어 문자를 얻었습니다.

00:10:27.000 --> 00:10:30.000
슬라이드로 돌아가자.

00:10:30.000 --> 00:10:34.000
마지막으로, 문서 탐지를 살펴봅시다.

00:10:34.000 --> 00:10:39.000
비전은 VNDocumentSegmentationRequest라는 새로운 요청을 소개합니다.

00:10:39.000 --> 00:10:49.000
종이, 표지판, 메모, 영수증, 라벨 등과 같은 다양한 유형의 문서에 대해 훈련한 기계 학습 기반 탐지기입니다.

00:10:49.000 --> 00:11:00.000
요청의 결과는 저해상도 세분화 마스크이며, 각 픽셀은 해당 픽셀이 감지된 문서의 일부인지 아닌지에 대한 자신감을 나타냅니다.

00:11:00.000 --> 00:11:07.000
게다가 그것은 사각형의 네 개의 코너 포인트를 제공한다.

00:11:07.000 --> 00:11:14.000
신경 엔진이 있는 장치에서, 요청은 카메라나 비디오 피드에서 실시간으로 실행될 수 있습니다.

00:11:14.000 --> 00:11:25.000
VisionKit의 VNDocumentCamera는 이제 신경 엔진이 있는 최신 장치에서 VNDetectRectanglesRequest 대신 요청을 사용하고 있습니다.

00:11:25.000 --> 00:11:33.000
VNDetectRectanglesRequest에 대해 말하자면, 둘 다 문서를 감지하는 데 사용할 수 있기 때문에 이 두 요청은 어떻게 다른가요?

00:11:33.000 --> 00:11:40.000
내가 언급했듯이, DetectDocumentsRequest는 기계 학습 기반이며 신경 엔진에서 가장 빠르게 수행된다.

00:11:40.000 --> 00:11:48.000
하지만 그것은 GPU나 CPU에서도 사용할 수 있지만, 실시간 성능을 위해 충분히 빠르지 않다.

00:11:48.000 --> 00:12:01.000
직사각형 검출기는 CPU에서만 실행되며 CPU가 다른 작업으로 포화되지 않는 한 실시간 성능을 따라잡을 수 있는 전통적인 컴퓨터 비전 알고리즘이다.

00:12:01.000 --> 00:12:09.000
문서 요청은 다양한 문서에 대한 교육을 받았으며, 주요 강점 중 하나인 모든 직사각형일 필요는 없습니다.

00:12:09.000 --> 00:12:22.000
반면에 직사각형 검출기는 사변형을 형성하는 가장자리와 교차점을 찾는 것으로 작동하며, 이는 문서에서 모서리가 가려져 있거나 접히는 데 어려움이 될 수 있다.

00:12:22.000 --> 00:12:31.000
문서 요청은 세분화 마스크와 코너 포인트를 제공하는 반면, 직사각형 검출기는 코너 포인트만 제공합니다.

00:12:31.000 --> 00:12:35.000
그리고 문서 탐지기는 하나의 문서만 찾도록 훈련받았다.

00:12:35.000 --> 00:12:39.000
직사각형 검출기는 여러 개의 직사각형을 반환할 것이다.

00:12:39.000 --> 00:12:42.000
이 직사각형들은 심지어 중첩될 수도 있다.

00:12:42.000 --> 00:12:46.000
이것을 조금 더 살펴봅시다.

00:12:46.000 --> 00:12:55.000
내가 언급했듯이, 문서 탐지기는 우리가 여기서 감지된 물체의 사각형과 함께 볼 수 있는 하나의 문서를 찾는다.

00:12:55.000 --> 00:13:04.000
하지만 직사각형 탐지기는 이미지에서 찾은 모든 직사각형에 대한 여러 관찰을 다시 제공할 것이며, 나는 여기서 몇 가지를 강조했다.

00:13:04.000 --> 00:13:08.000
어떤 직사각형이 문서인지 결정하는 것은 앱에 달려 있다.

00:13:08.000 --> 00:13:12.000
이 모든 것을 데모로 시도해 보는 게 어때?

00:13:12.000 --> 00:13:17.000
좋아, 우리는 우리가 WWDC에서 얼마나 잘 하고 있는지에 대한 작은 설문조사를 만들고 싶었어.

00:13:17.000 --> 00:13:22.000
이제, 안타깝게도, 당신은 저와 함께 있지 않습니다, 그래서 저는 여기 카메라 팀에게 당신을 위해 설문조사를 작성해 달라고 요청해야 했습니다.

00:13:22.000 --> 00:13:27.000
그래서, 나는 이제 설문조사 카드를 스캔할 수 있는 작은 앱을 만들었다.

00:13:27.000 --> 00:13:28.000
그리고 우리는 무엇을 얻나요?

00:13:28.000 --> 00:13:31.000
초보자를 위한 QuickDraw는 구식이라고 느꼈다.

00:13:31.000 --> 00:13:36.000
음, 지금은 조금 낡았어.

00:13:36.000 --> 00:13:38.000
다음으로 가자.

00:13:38.000 --> 00:13:45.000
아, 비전은 재미있고 유익했어.

00:13:45.000 --> 00:13:49.000
그리고 마지막으로, 코볼, 바로 내가 필요했던 것.

00:13:49.000 --> 00:13:52.000
누군가가 여기서 잘못된 세션에 있다.

00:13:52.000 --> 00:13:56.000
좋아, 이제 우리가 코드에서 이것을 어떻게 했는지 보자.

00:13:56.000 --> 00:14:01.000
그래서, 나는 우리를 위해 이 물건을 만드는 것이 더 쉽기 때문에 여기에 작은 놀이터를 다시 만들었다.

00:14:01.000 --> 00:14:10.000
당신이 이미 볼 수 있는 것은 내가 이미지를 로드했고, 이미지 조작을 해야 하기 때문에 CIImage를 사용했다는 것입니다.

00:14:10.000 --> 00:14:15.000
나는 requestHandler를 만들었고, 새로운 VNDetectDocument SegmentationRequest()를 사용했다.

00:14:15.000 --> 00:14:33.000
요청을 수행하면, 이제 결과를 다시 받고, 이제 원근법 수정 이미지로 사용하기 위해 핵심 이미지를 사용하는 작은 도우미 기능을 만들었고, 우리는 원근법 수정된 형태로 잘린 카드를 다시 얻습니다.

00:14:33.000 --> 00:14:35.000
그래서, 그건 쉬워.

00:14:35.000 --> 00:14:37.000
그래서, 우리는 다음에 무엇을 해야 하나요?

00:14:37.000 --> 00:14:44.000
우리는 바코드를 감지하고, 직사각형을 감지하고, 텍스트를 인식해야 합니다.

00:14:44.000 --> 00:14:50.000
이 요청을 수행하면, 어떤 것이 체크 표시되었는지 확인하기 위해 확인란을 스캔해야 합니다.

00:14:50.000 --> 00:14:58.000
좋아, 내가 이걸 조금 준비했으니, 바코드를 감지하는 것부터 시작하자.

00:14:58.000 --> 00:15:02.000
그리고 나는 기호로 QR 코드만 사용하고 있다.

00:15:02.000 --> 00:15:09.000
나는 문서 제목을 로드했다. 왜냐하면 나는 그것이 내 QR 코드의 내용이 우리가 그것에서 얻는 것의 제목이 될 것이라는 것을 알기 때문이다.

00:15:09.000 --> 00:15:12.000
다음으로, 우리는 직사각형을 감지해야 한다.

00:15:12.000 --> 00:15:18.000
다시 말하지만, 우리는 그것을 위한 작은 코드 직사각형을 가지고 있다.

00:15:18.000 --> 00:15:20.000
그래서, 나는 두 개의 배열을 만든다.

00:15:20.000 --> 00:15:25.000
분석에 필요한 데이터인 모든 checkBoxImages를 받고 싶습니다.

00:15:25.000 --> 00:15:27.000
그리고 나는 모든 직사각형을 꺼낸다.

00:15:27.000 --> 00:15:30.000
그래서, 나는 VNDetectRectanglesRequest를 사용했다.

00:15:30.000 --> 00:15:39.000
이제, 내가 여기서 하는 일은 그것들을 수직 순서로 정렬하여 올바른 순서로 결과를 다시 얻을 수 있도록 하는 것이다.

00:15:39.000 --> 00:15:44.000
좋아, 이제 우리는 우리의 문자를 인식해야 해.

00:15:44.000 --> 00:15:45.000
그건 간단해.

00:15:45.000 --> 00:15:51.000
우리는 모든 결과 텍스트 블록을 저장하고, VNRecognizeTextRequest를 사용합니다.

00:15:51.000 --> 00:15:56.000
그래서 이제, 우리가 해야 할 일은 단순히 요청을 수행하는 것이다.

00:15:56.000 --> 00:16:05.000
그리고 보시다시피, 저는 잘린 이미지를 사용하고 요청을 수행한 documentRequestHandler를 사용했습니다.

00:16:05.000 --> 00:16:14.000
그리고 내가 여기로 돌아가면, 나는 이미 올바른 QR 코드를 받았다는 것을 알 수 있지만, 내 직사각형은 뭔가 옳지 않다.

00:16:14.000 --> 00:16:16.000
난 직사각형이 하나도 없어.

00:16:16.000 --> 00:16:18.000
그래서, 내가 뭘 해야 해?

00:16:18.000 --> 00:16:25.000
음, 기본적으로 직사각형 탐지기는 이미지의 최소 20%인 직사각형만 찾습니다.

00:16:25.000 --> 00:16:26.000
그래서, 우리는 그것을 바로잡아야 해.

00:16:26.000 --> 00:16:41.000
그래서, 나는 들어가서 최소 크기를 10% 정도로 설정했다.

00:16:41.000 --> 00:16:45.000
그리고 일단 우리가 그것을 하면, 우리는 직사각형을 얻는다.

00:16:45.000 --> 00:16:48.000
그래, 음, 그건 하나뿐이야.

00:16:48.000 --> 00:16:53.000
음, 직사각형 탐지기의 또 다른 점은 얼마나 많이 돌려줘야 하는지 말해야 한다는 거야.

00:16:53.000 --> 00:16:59.000
기본적으로, 직사각형 감지는 가장 눈에 띄는 직사각형 하나만 반환합니다.

00:16:59.000 --> 00:17:00.000
하지만 나는 그것들을 모두 갖고 싶어.

00:17:00.000 --> 00:17:05.000
나는 최대 관측값을 0으로 설정하여 이것을 한다.

00:17:05.000 --> 00:17:16.000
그리고 일단 내가 그것을 하면, 나는 이제 우리의 모든 체크박스와 바코드를 얻는다. 왜냐하면 그것은 직사각형처럼 보이기 때문이다.

00:17:16.000 --> 00:17:18.000
그래, 그래서 우리는 괜찮아.

00:17:18.000 --> 00:17:23.000
이제 마지막 부분이 오고, 나는 실제로 체크박스를 스캔해야 한다.

00:17:23.000 --> 00:17:28.000
그래서, 그것을 위해, 나는 실제로 약간의 기계 학습 데모를 준비했다.

00:17:28.000 --> 00:17:31.000
저는 이전에 Create ML로 훈련한 모델이 있습니다.

00:17:31.000 --> 00:17:40.000
그것은 이미지 분류기이고, 내가 한 모든 것은 내 "예"와 "아니오" 라벨을 위해 표시된 이 체크박스 이미지 중 일부를 사용했고, 그 중 일부는 표시되지 않았다.

00:17:40.000 --> 00:17:43.000
그리고 나는 또한 그들 중 어느 것도 아닌 몇 개의 이미지를 모았다.

00:17:43.000 --> 00:17:47.000
그건 내 NotIt이야.

00:17:47.000 --> 00:17:56.000
다시 말하지만, 우리는 이것을 우리의 코드에서 사용할 수 있다.

00:17:56.000 --> 00:17:58.000
그래서, 우리는 뭘 가지고 있어?

00:17:58.000 --> 00:18:03.000
우리는 모델을 로드하여 요청을 만들고 Create ML 요청을 만듭니다.

00:18:03.000 --> 00:18:12.000
그리고 나서 우리는 모든 체크박스 이미지를 반복하고, 그것으로부터 ImageRequestHandler를 만들고, 분류를 수행합니다.

00:18:12.000 --> 00:18:14.000
이제, 나는 내 상위 분류를 볼 수 있다.

00:18:14.000 --> 00:18:22.000
만약 그것이 "예"라면, 나는 내가 가지고 있는 체크박스와 일치하는 텍스트 라인을 찾을 수 있고, 결국 우리는 무엇을 얻을 수 있을까?

00:18:22.000 --> 00:18:26.000
비전은 재미있고 유익했다.

00:18:26.000 --> 00:18:29.000
슬라이드로 돌아가자.

00:18:29.000 --> 00:18:31.000
우리가 본 것을 요약해 봅시다.

00:18:31.000 --> 00:18:35.000
문서 분석은 비전 API의 초점이다.

00:18:35.000 --> 00:18:42.000
비전의 바코드 감지는 스캐너보다 더 다재다능하며, 우리는 새로운 문서 세분화 감지를 도입하고 있습니다.

00:18:42.000 --> 00:18:49.000
OCR을 사용하는 방법에 대해 더 알고 싶다면, WWDC 2019의 세션을 보세요.

00:18:49.000 --> 00:19:02.000
WWDC 2020의 "비전 및 핵심 이미지" 세션은 이미지를 전처리하고 윤곽을 감지하여 사용자 지정 문서 분석을 수행하는 데 대한 추가 통찰력을 제공합니다.

00:19:02.000 --> 00:19:05.000
감사합니다, 그리고 나머지 WWDC를 즐기세요.

00:19:05.000 --> 23:59:59.000
[음악].

