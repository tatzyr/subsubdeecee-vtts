WEBVTT

00:00:00.000 --> 00:00:17.000
안녕하세요, 제 이름은 닐스 벡입니다. "M1이 탑재된 Mac에서 훌륭한 iPad 및 iPhone 앱의 품질"에 오신 것을 환영합니다.

00:00:17.000 --> 00:00:22.000
이미 Mac App Store에서 백만 개 이상의 iPad와 iPhone 앱을 사용할 수 있습니다.

00:00:22.000 --> 00:00:28.000
macOS Big Sur에서의 경험은 훌륭하며, 우리는 macOS Monterey에서 그것을 더욱 개선했습니다.

00:00:28.000 --> 00:00:53.000
이 비디오에서는 여러 iOS API를 해당 Mac 기능에 매핑한 방법, M1로 Mac에서 앱이 빛나는 데 도움이 되는 몇 가지 일반적인 모범 사례, macOS Big Sur 소프트웨어 업데이트 및 macOS Monterey에서 개선 사항을 논의한 다음 Mac App Store 배포 고려 사항으로 마무리할 것입니다.

00:00:53.000 --> 00:01:00.000
M1이 설치된 Mac의 iPad 및 iPhone 앱은 기존 앱의 범위를 Mac으로 확장하는 가장 쉬운 방법입니다.

00:01:00.000 --> 00:01:11.000
이것은 iOS App Store에 제출되고 승인된 수정되지 않은 iPad 또는 iPhone 앱으로, Mac App Store를 통해 M1 Mac을 사용하는 모든 사람에게 제공됩니다.

00:01:11.000 --> 00:01:15.000
이것을 가능하게 하기 위해, 우리는 호환성에 크게 집중한다.

00:01:15.000 --> 00:01:20.000
시스템 API는 가능한 한 자연스러운 Mac 등가물에 매핑됩니다.

00:01:20.000 --> 00:01:27.000
우리의 목표는 당신이 변경하지 않고도 Mac에서 원활한 앱 경험을 보장하는 것입니다.

00:01:27.000 --> 00:01:30.000
그리고 대부분의 기존 앱은 잘 작동합니다!

00:01:30.000 --> 00:01:36.000
여기에는 소형 iPhone 유틸리티부터 최첨단 iPad 게임 및 프로 앱에 이르기까지 모든 것이 포함됩니다.

00:01:36.000 --> 00:01:39.000
다양한 확장도 지원됩니다.

00:01:39.000 --> 00:01:49.000
예를 들어, 공유 확장, WidgetKit 위젯, 사진 편집 확장, VPN 네트워크 확장, 오디오 장치 등.

00:01:49.000 --> 00:01:56.000
따라서, 기존 iPad 또는 iPhone 앱은 이미 Mac에서 바로 잘 작동할 가능성이 매우 높습니다.

00:01:56.000 --> 00:02:13.000
물론, 우리는 텍스트 상호 작용, 복사 및 붙여넣기, Mac 메뉴 표시줄 등과 같은 모든 기본 기능을 지원하지만, 백그라운드 앱 새로 고침, 사용자 알림, 카메라 액세스, Siri 의도 등과 같은 많은 고급 기능도 있습니다.

00:02:13.000 --> 00:02:22.000
이러한 주제의 대부분은 "애플 실리콘 맥의 아이패드와 아이폰 앱"이라는 비디오에서 논의되므로, 자세한 내용은 확인해 보세요.

00:02:22.000 --> 00:02:30.000
그리고 앱이 Mac이 제공하는 것을 더 많이 활용하기를 원할 때, 앱의 Mac Catalyst 버전을 구축하는 것을 고려해 보세요.

00:02:30.000 --> 00:02:38.000
"훌륭한 Mac Catalyst 앱의 품질" 및 "Mac Catalyst의 새로운 기능" 비디오에서 그것에 대해 자세히 알아볼 수 있습니다.

00:02:38.000 --> 00:02:44.000
이제, 제가 방금 언급한 API 중 일부에 대해 더 자세히 알아봅시다.

00:02:44.000 --> 00:02:53.000
당신은 이미 iPad와 iPhone에서 앱을 훌륭하게 만들기 위해 이것들을 사용하고 있을 가능성이 높으며, 우리는 Mac에서 동일한 훌륭한 기능을 원활하게 제공하기 위해 그것들을 연결했습니다.

00:02:53.000 --> 00:03:02.000
당연히, Mac 키보드를 텍스트 필드에 텍스트 입력과 UIKeyCommand 키보드 단축키에 사용할 수 있습니다.

00:03:02.000 --> 00:03:11.000
하지만 더 많은 제어가 필요하고 자신만의 키프레스 처리를 작성하고 싶다면, UIResponder의 UIPress API로 할 수 있습니다.

00:03:11.000 --> 00:03:21.000
모든 Mac에는 물리적 키보드가 있으므로 iPad와 iPhone의 물리적 키보드에 대한 지원을 추가하는 데 시간이 걸린 앱은 Mac에서 동시에 크게 개선됩니다.

00:03:21.000 --> 00:03:24.000
다음으로, 메뉴 바에 대해 이야기해 봅시다.

00:03:24.000 --> 00:03:32.000
이미 잘 알고 계시겠지만, Mac 메뉴 표시줄은 앱 기능과 키보드 단축키의 발견 가능성을 돕기 위한 것입니다.

00:03:32.000 --> 00:03:38.000
메뉴 바 구조는 출시 시 결정되며, 그 이후에는 다소 일정하게 유지되어야 한다.

00:03:38.000 --> 00:03:46.000
항목은 추가되거나 제거되지 않지만, 현재 적용되는지 여부에 따라 활성화되거나 비활성화됩니다.

00:03:46.000 --> 00:03:52.000
앱의 기능을 고려하여 앱의 메뉴 표시줄을 자동으로 채웁니다.

00:03:52.000 --> 00:04:00.000
예를 들어, 새 창을 만들거나, 리치 텍스트로 작업하거나, 장치 방향을 변경하기 위해 메뉴 항목을 추가할 수 있습니다.

00:04:00.000 --> 00:04:16.000
keyCommands 속성을 통해 UIResponders에 직접 연결된 UIKeyCommands는 메뉴 표시줄에 나타나지 않지만, 키보드 단축키는 적용될 때마다 메뉴 항목의 단축키보다 우선합니다.

00:04:16.000 --> 00:04:23.000
iOS 13에서 도입한 최신 UIMenuBuilder API를 이미 사용하고 있을 수도 있습니다.

00:04:23.000 --> 00:04:27.000
이것은 UIKeyCommands에 의미 구조를 추가합니다.

00:04:27.000 --> 00:04:37.000
이 구조는 키보드가 있는 iPad에서 Command 키를 길게 누르면 나타나는 키보드 단축키 메뉴에서 볼 수 있습니다.

00:04:37.000 --> 00:04:46.000
Mac에서 빌더로 전달되는 기본 구조는 다르지만, 구조에 대한 사용자 지정은 메인 메뉴에 반영됩니다.

00:04:46.000 --> 00:04:56.000
UIKeyCommands는 응답기 체인에 의존하여 작업에 적용 가능한 대상을 찾고, 이는 메뉴 항목의 활성화 여부를 결정합니다.

00:04:56.000 --> 00:05:07.000
이에 대한 자세한 내용은 "iPad 앱을 한 단계 끌어올리세요", "iPad 키보드 내비게이션에 집중", "훌륭한 Mac Catalyst 앱의 품질" 비디오를 확인하세요.

00:05:07.000 --> 00:05:17.000
iPad와 iPhone에서 드래그 앤 드롭을 사용하는 앱의 경우, UIDragInteraction과 UIDropInteraction을 사용하면 자동으로 Mac으로 전달됩니다.

00:05:17.000 --> 00:05:27.000
이를 통해 사람들은 Qrafter에서 데스크톱으로 QR 코드를 드래그하는 이 예와 같이 앱과 다른 앱 간에 콘텐츠를 원활하게 드래그할 수 있습니다.

00:05:27.000 --> 00:05:37.000
그리고 UIPrintInteractionController로 인쇄하는 앱의 경우, 코드에서 인쇄가 시작될 때 Mac 인쇄 대화상자에 자동으로 연결됩니다.

00:05:37.000 --> 00:05:53.000
더 나아가, 새로운 Info.plist 키 "UIApplicationSupports PrintCommand"를 채택하고 해당 표준 인쇄 작업을 구현하면 PDF로 인쇄 및 내보내기 메뉴 항목이 앱의 메뉴 표시줄에 자동으로 추가됩니다.

00:05:53.000 --> 00:05:59.000
이 새로운 API에 대한 자세한 내용은 "Mac Catalyst의 새로운 기능"을 확인하세요.

00:05:59.000 --> 00:06:04.000
많은 앱이 설정 번들을 사용하며, 우리는 이것으로부터 Mac 스타일의 기본 설정 패널을 자동으로 생성할 것입니다.

00:06:04.000 --> 00:06:12.000
설정 번들에 크레딧을 넣는 것도 일반적이며, 우리는 그러한 경우를 식별하고 그 텍스트를 정보 상자로 옮깁니다.

00:06:12.000 --> 00:06:20.000
하지만 Mac의 정보 상자에 표시되는 것을 더 잘 제어하고 싶다면, 이제 번들에 크레딧 파일을 추가할 수 있는 옵션도 있습니다.

00:06:20.000 --> 00:06:27.000
Mac 앱이 하는 것과 같은 방식으로 RTF, RTFD 또는 HTML 파일을 사용할 수 있습니다.

00:06:27.000 --> 00:06:33.000
당신의 앱을 훌륭한 iPad 앱으로 만드는 데 도움이 될 많은 iPad 중심 API가 있습니다.

00:06:33.000 --> 00:06:35.000
이것들은 모두 Mac에서 훌륭하게 발견된다.

00:06:35.000 --> 00:06:40.000
그래서, 훌륭한 iPad 앱을 만들면, M1이 탑재된 Mac에서도 앱을 더 좋게 만들 수 있습니다.

00:06:40.000 --> 00:06:56.000
앱이 UIApplicationSupports MultipleScenes Info.plist 키에 따라 여러 장면을 지원하는 경우, 각 장면은 별도의 창으로 변환되며, 자동으로 메뉴 항목을 추가하여 새 장면을 만듭니다.

00:06:56.000 --> 00:07:06.000
Mac에서 시스템 차원의 설정은 앱이 종료될 때 모든 창이 닫히는지 또는 다음 실행 시 기존 창이 복원되는지 여부를 결정합니다.

00:07:06.000 --> 00:07:16.000
앱이 여러 장면을 지원하는 경우 이 설정을 존중하므로, 모든 장면이 끊어지거나 경우에 따라 상태 복원이 발생하지 않더라도 놀라지 마십시오.

00:07:16.000 --> 00:07:23.000
반면에 iPad 멀티태스킹 지원은 자동으로 macOS에서 크기를 조정할 수 있는 창으로 변환됩니다.

00:07:23.000 --> 00:07:29.000
앱이 이미 iPad에서 동적 레이아웃 변경을 지원하기 때문에, Mac에서 창의 크기를 조정할 수 있습니다.

00:07:29.000 --> 00:07:39.000
UIWindowScene의 minimumSize 및 maximumSize API를 사용하여 허용 가능한 장면 크기의 범위를 제한할 수 있습니다.

00:07:39.000 --> 00:07:43.000
창의 크기를 조정할 때 창 장면 크기만 변경된다는 점에 유의하십시오.

00:07:43.000 --> 00:07:50.000
반면에 UI 화면 크기는 장치 크기를 계속 보고할 것이며, 이 경우에는 변경되지 않습니다.

00:07:50.000 --> 00:07:59.000
따라서 iPad에서도 레이아웃 계산에 화면 크기를 사용하지 않도록 하십시오. 그렇지 않으면 UI 요소가 잘못된 위치에 있게 될 것입니다.

00:07:59.000 --> 00:08:07.000
앱이 장치의 전체 화면을 제어할 것으로 예상한다면, 우리는 고정된 장면 크기와 종횡비를 사용할 것입니다.

00:08:07.000 --> 00:08:15.000
하지만 창 콘텐츠는 필요에 따라 앱에 투명한 방식으로 확장되거나 축소될 수 있습니다.

00:08:15.000 --> 00:08:27.000
그리고 앱이 여러 사용자 인터페이스 방향을 지원하는 경우, 자동으로 추가된 메뉴 표시줄 항목을 사용하거나 창의 가장자리를 드래그하여 창 방향을 변경할 수 있습니다.

00:08:27.000 --> 00:08:38.000
여기서, 저는 Chess.com 앱의 방향을 변경하기 위해 메뉴 표시줄 항목을 사용하고 있으며, 사용자 인터페이스는 각 장치 방향을 최적으로 사용하도록 조정됩니다.

00:08:38.000 --> 00:08:54.000
이러한 매핑과 다른 매핑은 iPad 또는 iPhone 앱을 Mac으로 가져올 때 대부분의 마찰을 제거할 수 있지만, 앱이 Mac을 포함한 모든 플랫폼에서 잘 작동하는지 확인하기 위해 따라야 할 몇 가지 코딩 관행을 다루겠습니다.

00:08:54.000 --> 00:09:07.000
Apple 프레임워크를 사용할 때, 프레임워크의 문서화되지 않은 방법은 Mac에 존재하지 않거나 언제든지 변경될 수 있으므로 공식적으로 지원되는 API만 사용하는 것이 중요합니다.

00:09:07.000 --> 00:09:12.000
Mac에서는 다를 수 있으므로 파일 시스템 위치에 대한 하드 코딩 경로를 피하십시오.

00:09:12.000 --> 00:09:17.000
예를 들어, 경로 앞에 "/private" 또는 "var mobile"을 붙이지 마세요.

00:09:17.000 --> 00:09:23.000
대신, 적절한 API를 사용하여 런타임에 각 경로를 결정하십시오.

00:09:23.000 --> 00:09:39.000
마찬가지로, 직접 제어할 수 없는 UI의 경우, Mac에서 크게 다를 수 있기 때문에 보기와 경고의 화면 위치 또는 그러한 보기 계층의 정확한 설정에 대해 코드에서 가정하지 않는 것이 가장 좋습니다.

00:09:39.000 --> 00:09:47.000
또한 사용 가능한 카메라 해상도와 방향이 Mac에서 상당히 다를 수 있다는 점에 유의하십시오.

00:09:47.000 --> 00:09:56.000
예를 들어, 사진을 찍을 때 iPhone 앱이 세로 방향인 경우, 결과 카메라 사진도 세로 방향일 것으로 예상할 수 있습니다.

00:09:56.000 --> 00:10:03.000
하지만 앱이 Mac에서 세로 방향일 때 반드시 그런 것은 아니다.

00:10:03.000 --> 00:10:08.000
카메라가 배치되는 방식이기 때문에 대신 가로 방향의 이미지를 받을 수 있습니다.

00:10:08.000 --> 00:10:14.000
우리는 이미 많은 앱과의 호환성을 개선하기 위해 많은 휴리스틱을 포함시켰습니다.

00:10:14.000 --> 00:10:20.000
예를 들어, 우리는 당신이 후면 카메라를 요청했을 때에도 Mac의 전면 카메라의 사진을 제공할 것입니다.

00:10:20.000 --> 00:10:34.000
하지만 AVCaptureDeviceDiscoverySession 및 관련 AVFoundation API를 사용하여 사용 가능한 카메라와 미리보기 크기와 같은 실제 속성에 대한 정보를 수집하는 것이 훨씬 좋습니다.

00:10:34.000 --> 00:10:39.000
그리고 당신은 UI에서 가능한 모든 구성을 잘 처리하는 것을 목표로 해야 합니다.

00:10:39.000 --> 00:10:44.000
또한 Mac에서 일부 하드웨어 기능을 사용할 수 없다는 것을 명심하세요.

00:10:44.000 --> 00:10:50.000
당신의 코드는 그러한 상황을 우아하게 처리하고 대안을 제공할 수 있어야 합니다.

00:10:50.000 --> 00:10:55.000
예를 들어, ARKit을 사용한 증강 현실은 Mac에서 지원되지 않습니다.

00:10:55.000 --> 00:11:04.000
ARKit이 앱의 핵심 기능이라면, 필요한 장치 기능으로 만들었을 가능성이 높기 때문에 앱이 Mac App Store에 나타나지 않을 것입니다.

00:11:04.000 --> 00:11:12.000
하지만 ARKit이 선택적 기능이라면, 이미 적절한 ARConfiguration 하위 클래스의 isSupported 속성을 확인해야 합니다.

00:11:12.000 --> 00:11:23.000
그리고 Mac과 다른 곳에서 최고의 경험을 위해, 이 기능이 있는 장치의 UI에서만 증강 현실 기능을 표시해야 합니다.

00:11:23.000 --> 00:11:33.000
앱이 직접 멀티 터치 또는 CoreMotion에 의존하는 경우, Mac 키보드와 트랙패드에 더 적합한 대안을 추가로 제공하는 것을 고려하십시오.

00:11:33.000 --> 00:11:37.000
그렇긴 하지만, 터치 대안은 이 경우에 도움이 될 수 있다.

00:11:37.000 --> 00:11:39.000
잠시 후에 그것에 대해 더 얘기할게.

00:11:39.000 --> 00:11:47.000
그리고 CoreLocation을 사용하는 경우, 정확한 위치 데이터를 사용할 수 없더라도 앱을 사용할 수 있어야 합니다.

00:11:47.000 --> 00:11:53.000
예를 들어, Lowe의 앱이 여기에서 하는 것처럼 대안으로 수동 위치 입력을 제공할 수 있습니다.

00:11:53.000 --> 00:11:59.000
다음으로, M1과 함께 Mac을 처음 배송하기 시작한 이후로 우리가 만든 몇 가지 개선 사항을 살펴봅시다.

00:11:59.000 --> 00:12:08.000
macOS Big Sur 11.3에서, 우리는 iPad와 iPhone 앱의 윈도우가 Mac에서 작동하는 방식을 몇 가지 개선했습니다.

00:12:08.000 --> 00:12:23.000
앱이 멀티태스킹을 지원하지 않지만 큰 장치 크기를 지원하기 때문에 앱이 고정된 콘텐츠 크기를 가지고 있다면, 출시 시 앱이 실행되는 화면에 맞는 가장 큰 지원되는 장치 크기를 선택할 것입니다.

00:12:23.000 --> 00:12:32.000
앱에 관한 한, 장치 크기는 여전히 전체 세션 동안 고정되어 있지만, 창은 사용 가능한 공간을 훨씬 더 잘 활용합니다.

00:12:32.000 --> 00:12:36.000
대신 지원되는 가장 작은 장치 크기를 사용하는 것을 선호한다.

00:12:36.000 --> 00:12:41.000
그리고 앞서 언급했듯이, 창의 내용은 필요에 따라 확대되거나 축소될 것이다.

00:12:41.000 --> 00:12:52.000
예를 들어, 창을 전체 화면으로 만들 때, 창 내용은 원래 장면 종횡비를 유지하면서 사용 가능한 공간에 맞게 자동으로 확장됩니다.

00:12:52.000 --> 00:13:00.000
또는, 출시 후 창이 더 작은 화면으로 이동하면, 창이 여전히 맞는지 확인하기 위해 필요에 따라 자동으로 크기를 줄일 것입니다.

00:13:00.000 --> 00:13:14.000
이제 윈도우 줌 기능을 사용하여 두 개의 줌 요소 사이를 전환할 수도 있습니다. 하나는 UI 요소의 자연스러운 크기를 우선시하고 다른 하나는 픽셀 완벽한 정확도를 우선시합니다.

00:13:14.000 --> 00:13:21.000
여기서, 저는 이 기능을 사용하여 Chess.com 앱에서 두 개의 줌 요소 사이를 전환하고 있습니다.

00:13:21.000 --> 00:13:29.000
게임 컨트롤러는 모든 게임 지원 플랫폼에서 사용할 수 있는 GameController.framework를 통해 첫날부터 지원되었습니다.

00:13:29.000 --> 00:13:37.000
macOS Big Sur 11.3부터, 우리는 Mac의 키보드와 트랙패드를 가상 게임 컨트롤러로 사용할 수 있게 했습니다.

00:13:37.000 --> 00:13:47.000
따라서, 실제 컨트롤러가 없더라도, 키보드를 사용하여 게임이 컨트롤러 버튼에 매핑하는 모든 기능에 쉽게 액세스할 수 있습니다.

00:13:47.000 --> 00:13:57.000
그리고 macOS Monterey에서, 우리는 해당 기본 설정 패널의 이 그림과 같이 감도 슬라이더와 포인터 숨김을 추가하여 이것을 더욱 개선했습니다.

00:13:57.000 --> 00:14:02.000
이 프레임워크에 대한 자세한 내용은 "게임 컨트롤러의 발전"을 확인하세요.

00:14:02.000 --> 00:14:15.000
게다가, 첫날부터 터치 대안은 키보드와 트랙패드를 멀티 터치, 드래그, 탭 및 스와이프와 같이 Mac에서 사용하기 쉽지 않은 몇 가지 상호 작용 스타일에 매핑했습니다.

00:14:15.000 --> 00:14:20.000
그리고 MacOS 11.3을 통해, 우리는 많은 개선을 이루었다.

00:14:20.000 --> 00:14:24.000
예를 들어, 이제 장치를 사실상 기울일 수 있습니다.

00:14:24.000 --> 00:14:27.000
이것은 많은 추가 게임의 문을 열어준다.

00:14:27.000 --> 00:14:38.000
또한, 기본 설정 패널에는 이제 키보드와 트랙패드를 통해 다섯 가지 상호 작용 스타일 각각에 액세스하는 방법을 보여주는 유용한 그래픽 표현이 포함되어 있습니다.

00:14:38.000 --> 00:14:45.000
또한, 우리는 앱이 자동으로 터치 대안을 선택할 수 있도록 했습니다.

00:14:45.000 --> 00:14:52.000
선택하면, 이 기능의 발견을 돕기 위해 첫 번째 실행 시 온보딩 대화상자가 표시됩니다.

00:14:52.000 --> 00:14:58.000
그래픽은 기본 설정 패널의 그래픽과 비슷하지만, 우리는 당신이 선택한 상호 작용 스타일만 강조합니다.

00:14:58.000 --> 00:15:03.000
이 예에서는 틸트와 멀티 터치만 표시됩니다.

00:15:03.000 --> 00:15:12.000
앱이 이러한 터치 대안의 혜택을 받을 것이라고 결정한 경우, 처음부터 앱에 대한 터치 대안을 활성화할 수 있는 방법은 다음과 같습니다.

00:15:12.000 --> 00:15:21.000
"Com.apple.uikit.inputalternativ es.plist"라는 이름의 새로운.plist 파일을 번들에 추가하기만 하면 됩니다.

00:15:21.000 --> 00:15:25.000
그런 다음, 스니펫에 표시된 키와 값을 추가하세요.

00:15:25.000 --> 00:15:30.000
그리고 필요한 온보딩 어레이의 경우, 앱에 유용한 기능만 포함하세요.

00:15:30.000 --> 00:15:34.000
그렇게 하면, 그 기능들만 온보딩 대화상자에서 강조 표시됩니다.

00:15:34.000 --> 00:15:36.000
내가 이걸 보여줄게.

00:15:36.000 --> 00:15:43.000
예를 들어, M1이 설치된 Mac에서 수정되지 않은 상태로 실행되는 "Assoluto Racing"이라는 이 iPad 게임을 예로 들어 보겠습니다.

00:15:43.000 --> 00:15:51.000
이 앱은 처음부터 자동으로 터치 대안을 활성화하므로, 처음 시작할 때 이 온보딩 대화 상자는 키보드 컨트롤을 보여줍니다.

00:15:51.000 --> 00:15:57.000
하지만 먼저, 소프트웨어 키보드를 보여주고 창을 전체 화면으로 봅시다.

00:15:57.000 --> 00:16:11.000
콘텐츠는 이제 화면에 맞게 확장되었으며, iPad 종횡비를 유지합니다.

00:16:11.000 --> 00:16:16.000
프리스타일 드리프트를 위해 "공항" 레벨로 가자.

00:16:16.000 --> 00:16:21.000
이 앱은 CoreMotion을 사용하므로 iPad에서 장치를 기울여 조종할 수 있습니다.

00:16:21.000 --> 00:16:28.000
M1이 있는 Mac에서 터치 대안이 활성화되면 W, A, S 및 D 키는 기울기를 시뮬레이션합니다.

00:16:28.000 --> 00:16:35.000
그리고 여기서 나는 트랙패드를 사용하여 화면의 가속기 버튼을 클릭하는 동안 그런 식으로 차를 제어한다.

00:16:35.000 --> 00:16:38.000
그리고 이 모든 것은 앱에 완전히 투명하다.

00:16:38.000 --> 00:16:50.000
내가 어떻게 하는지 보자.

00:16:50.000 --> 00:16:52.000
그거 잘 됐어!

00:16:52.000 --> 00:16:54.000
하지만, 나는 내 표류 기술을 조금 연습해야 해.

00:16:54.000 --> 00:16:58.000
macOS Monterey를 통해, 우리는 훨씬 더 많은 개선을 이루었다.

00:16:58.000 --> 00:17:09.000
Apple Pay는 이제 macOS Big Sur의 Mac Catalyst 애플리케이션에 도입한 것과 동일한 향상된 크로스 플랫폼 API를 사용하여 M1 Mac의 iPad 및 iPhone 앱에서 사용할 수 있습니다.

00:17:09.000 --> 00:17:16.000
즉, 이제 단일 구현을 사용하여 Apple Pay를 사용할 수 있는 모든 플랫폼에서 결제를 수락할 수 있습니다.

00:17:16.000 --> 00:17:27.000
PKPaymentAuthorizationController 대리인에 "paymentAuthorizationController, didRequestMerchantSessionUpdate" 대리인 호출을 구현했는지 확인하십시오.

00:17:27.000 --> 00:17:32.000
자세한 내용은 "지갑과 Apple Pay의 새로운 기능" 비디오를 확인하세요.

00:17:32.000 --> 00:17:36.000
우리는 또한 AVKit으로 전체 화면 비디오를 더 잘 만들었습니다.

00:17:36.000 --> 00:17:43.000
AVPlayerView와 AVPlayerViewController는 이제 별도의 창을 사용하여 자동으로 비디오 전체 화면을 촬영할 수 있습니다.

00:17:43.000 --> 00:17:55.000
이것은 창이 실행 시간 해상도와 종횡비로 제한되는 앱조차도 비디오 콘텐츠에 적합한 Mac 디스플레이를 최대한 활용할 수 있다는 것을 의미합니다.

00:17:55.000 --> 00:18:05.000
그리고 전체 화면 경험에 대한 더 많은 제어가 필요한 경우, AVPlayerViewDelegate 및 AVPlayerViewControllerDelegate에 새로운 API를 추가했습니다.

00:18:05.000 --> 00:18:11.000
게다가, AVFoundation은 M1이 장착된 Mac에서 HDR 재생과 스트리밍을 지원합니다.

00:18:11.000 --> 00:18:16.000
앱에서 Mac 전용 채택 작업이 필요하지 않습니다.

00:18:16.000 --> 00:18:22.000
마지막으로, iPad 및 iPhone 앱의 AVKit 컨트롤은 이제 다른 Mac 앱과 동일하게 보입니다.

00:18:22.000 --> 00:18:28.000
우리는 심지어 새로운 제스처를 지원하는 Mac 트랙패드를 최대한 활용합니다.

00:18:28.000 --> 00:18:32.000
자세한 내용은 "AVKit의 새로운 기능" 비디오로 이동할 수 있습니다.

00:18:32.000 --> 00:18:43.000
그리고 앱이 인텐트 프레임워크를 사용하여 macOS Monterey에서 사용자 지정 SiriKit 단축키를 제공하는 경우, 이제 M1 Mac의 iPad 및 iPhone 앱에서 지원됩니다.

00:18:43.000 --> 00:18:52.000
단축키에 대한 자세한 내용은 "macOS용 단축키를 만나세요"와 "단축키, Siri 및 제안을 위한 훌륭한 동작을 디자인하세요"를 확인하세요.

00:18:52.000 --> 00:18:54.000
좋은 소식이야!

00:18:54.000 --> 00:18:56.000
Mac App Store에 접속하는 것은 쉽다.

00:18:56.000 --> 00:19:00.000
사실, 대부분의 앱은 자동으로 거기에 있다.

00:19:00.000 --> 00:19:04.000
앞서 언급했듯이, 대부분의 경우, Mac을 사용하는 것이 합리적이다.

00:19:04.000 --> 00:19:16.000
결국, 모바일로 설계된 블루투스 도어락 앱조차도 휴대폰 없이 집을 잠갔지만 M1이 있는 Mac을 가지고 있다면 유용할 수 있습니다.

00:19:16.000 --> 00:19:22.000
따라서, 이전에 Mac App Store에서 앱을 선택하지 않았다면, 지금이 재고할 때일 수 있습니다.

00:19:22.000 --> 00:19:30.000
터치 대안과 향상된 전체 화면 비디오 재생과 같은 개선으로, 당신의 앱은 Mac에 매우 적합할 수 있습니다.

00:19:30.000 --> 00:19:39.000
이 경우, App Store Connect에서 "이 앱을 사용할 수 있게 만들기" 확인란을 다시 선택하면 Mac App Store에서 앱을 사용할 수 있습니다.

00:19:39.000 --> 00:19:47.000
이전에 선택하지 않았는지 여부에 관계없이, 앱이 M1이 설치된 Mac에서 정말 잘 작동하는지 확인하고 싶을 것입니다.

00:19:47.000 --> 00:19:56.000
사용자 경험이 표준에 부합한다고 확신하면, 여기에 표시된 App Store Connect에서 호환성 확인 링크를 클릭하세요.

00:19:56.000 --> 00:20:06.000
이것은 Mac App Store에서 앱 옆에 표시되는 "macOS에 대해 확인되지 않음" 텍스트를 제거하고 "iPad용으로 설계됨"으로 대체됩니다.

00:20:06.000 --> 00:20:13.000
앱 쇼핑객들은 이것을 Mac에서 앱으로 좋은 경험을 할 수 있도록 시간을 할애했다는 표시로 삼을 것입니다.

00:20:13.000 --> 00:20:15.000
앱당 한 번만 하면 됩니다.

00:20:15.000 --> 00:20:21.000
오, 그리고 우리는 또한 Mac App Store에서 iPad와 iPhone 앱을 훨씬 더 쉽게 발견할 수 있게 만들었습니다.

00:20:21.000 --> 00:20:27.000
고객이 이름으로 검색할 때, 더 이상 iPhone 및 iPad 앱 탭으로 전환할 필요가 없습니다.

00:20:27.000 --> 00:20:35.000
Apple은 호환성에 필요한 권장 최소 macOS 버전을 자동으로 선택할 것이며, 대부분의 상황에서는 괜찮습니다.

00:20:35.000 --> 00:20:41.000
하지만 드문 경우지만, 사용자 지정 macOS 가용성으로 이것을 재정의하고 싶을 수도 있습니다.

00:20:41.000 --> 00:20:54.000
예를 들어, 비디오 앱은 Big Sur에서 잘 작동할 수 있지만, AVKit 전체 화면 개선에 액세스할 수 있도록 하려면 Monterey와 그 이상에서만 사용할 수 있다고 결정할 수 있습니다.

00:20:54.000 --> 00:20:57.000
이 경우, 두 가지 옵션이 있습니다.

00:20:57.000 --> 00:21:06.000
곧 App Store Connect의 가격 및 가용성 페이지에서 다른 최소 macOS 버전을 선택할 수 있습니다.

00:21:06.000 --> 00:21:12.000
이것은 새 버전을 다시 제출할 필요가 없기 때문에 이미 상점에 있는 앱에 적합합니다.

00:21:12.000 --> 00:21:20.000
또는 Info.plist에서 LSMinimumSystemVersion을 지정하고 다음 업데이트의 일부로 이 변경 사항을 제출할 수 있습니다.

00:21:20.000 --> 00:21:24.000
이것은 적극적으로 개발 중인 앱에 권장되는 접근 방식이다.

00:21:24.000 --> 00:21:31.000
이것은 iOS 최소 시스템 버전을 지정하는 MinimumOSVersion 키를 대체하지 않습니다.

00:21:31.000 --> 00:21:34.000
하지만 정말로, 두 옵션 모두 거의 필요하지 않아야 한다.

00:21:34.000 --> 00:21:38.000
마지막으로, 테스트에 대해 잠시 이야기해 봅시다.

00:21:38.000 --> 00:21:41.000
macOS에서의 테스트는 iPad에서의 테스트와 매우 유사하다.

00:21:41.000 --> 00:21:45.000
이미 익숙한 것과 동일한 워크플로우를 사용할 수 있습니다.

00:21:45.000 --> 00:21:56.000
Xcode에서 로컬 테스트를 위해, 실행 대상으로 My Mac(iPad용 설계)을 선택하고, 디버깅, 단위 테스트 등을 모두 다른 장치와 마찬가지로 작동합니다.

00:21:56.000 --> 00:22:09.000
베타 테스트를 위해 iPhone 및 iPad 앱을 포함한 macOS Monterey의 모든 앱에 대한 TestFlight 지원을 추가했으므로 이제 M1과 함께 Mac을 사용하는 베타 테스터에게 앱을 배포할 수 있습니다.

00:22:09.000 --> 00:22:15.000
이에 대한 자세한 내용은 "Mac에서 TestFlight 만나기" 비디오로 가세요.

00:22:15.000 --> 00:22:17.000
그래서, 맥에 온 걸 환영해!

00:22:17.000 --> 00:22:20.000
가서 앱을 확인하고 옵트인하세요.

00:22:20.000 --> 00:22:21.000
그건 쉬워.

00:22:21.000 --> 00:22:29.000
그리고 iPad와 iPhone 앱을 계속 개선하면서, M1이 있는 Mac에서도 앱을 더 좋게 만들고 있다는 것을 기억하세요.

00:22:29.000 --> 00:22:32.000
정말 고마워.

00:22:32.000 --> 23:59:59.000
[쾌활한 음악].

