WEBVTT

00:00:00.000 --> 00:00:14.000
안녕하세요, 제 이름은 타누자이고, 저는 OS 성능 팀의 엔지니어입니다.

00:00:14.000 --> 00:00:21.000
오늘 스테판과 저는 당신의 응용 프로그램에서 메모리 문제를 감지하고 진단하는 방법에 대해 이야기할 것입니다.

00:00:21.000 --> 00:00:27.000
우리는 애플리케이션의 메모리 풋프린트의 영향을 살펴보는 것으로 시작할 것이다.

00:00:27.000 --> 00:00:34.000
그런 다음 메모리 사용량을 프로파일링하는 도구와 발생할 수 있는 메모리 문제의 유형에 대해 이야기할 것입니다.

00:00:34.000 --> 00:00:38.000
바로 뛰어들자.

00:00:38.000 --> 00:00:44.000
당신이 즉시 물어볼 수 있는 한 가지 질문은, 왜 내 애플리케이션의 메모리 풋프린트에 신경을 써야 하나요?

00:00:44.000 --> 00:00:49.000
주요 이유는 앱의 사용자 경험을 엄청나게 향상시킨다는 것입니다.

00:00:49.000 --> 00:01:00.000
시스템에는 한정된 양의 메모리가 있으며 앱의 메모리 사용을 모니터링하면 시스템이 해당 메모리를 회수하기 위해 앱을 종료하는 것을 방지할 수 있습니다.

00:01:00.000 --> 00:01:16.000
이것은 앱이 백그라운드에서 상태를 유지할 수 있다는 것을 의미하며, 이는 메모리에 로드하는 데 시간이 걸리고 메모리 풋프린트를 컴팩트하게 유지하면 애플리케이션이 메모리에 남아 있을 가능성이 높아져 앱 활성화가 빨라지기 때문입니다.

00:01:16.000 --> 00:01:26.000
메모리 사용을 줄이면 사용자가 새로운 기능을 탐색할 때 정확히 원하는 역동적이고 반응이 빠른 경험을 얻을 수 있습니다.

00:01:26.000 --> 00:01:36.000
앱이 메모리에 로드된 것에 대해 전략적으로 행동함으로써, 앱은 사용자가 앱과 상호 작용할 때 메모리를 되찾기 위해 기다리는 비용을 피할 수 있습니다.

00:01:36.000 --> 00:01:48.000
메모리 사용에 대한 전략적인 것은 애니메이션을 포함한 비디오 로드 등과 같이 앱에 추가할 수 있는 더 넓은 범위의 기능에 대한 문을 열어줍니다.

00:01:48.000 --> 00:01:56.000
마지막으로, 우리의 장치는 시간이 지남에 따라 끊임없이 진화하고 있으며, 우리의 새로운 장치는 이전보다 더 많은 물리적 메모리를 가지고 있다.

00:01:56.000 --> 00:02:05.000
메모리 공간을 줄임으로써, 당신의 앱은 구형 장치에서 성능이 향상되어 앱을 즐길 수 있는 청중을 증가시킬 것입니다.

00:02:05.000 --> 00:02:15.000
앱의 메모리 공간을 모니터링함으로써, 앱은 더 빠르게 활성화되고, 더 반응하며, 복잡한 기능을 처리하고, 더 넓은 범위의 장치에서 성능을 발휘할 수 있습니다.

00:02:15.000 --> 00:02:20.000
이제 무엇이 당신의 기억력 발자국을 만드는지 살펴봅시다.

00:02:20.000 --> 00:02:27.000
애플리케이션의 메모리 프로필을 분해하는 데 사용하는 세 가지 범주가 있습니다: 더러운, 압축된, 깨끗한 메모리.

00:02:27.000 --> 00:02:31.000
이것들 각각에 무엇이 포함되어 있는지 간단히 살펴봅시다.

00:02:31.000 --> 00:02:35.000
더러운 기억은 당신의 응용 프로그램에 의해 쓰여진 기억으로 구성되어 있습니다.

00:02:35.000 --> 00:02:44.000
또한 malloc, 디코딩된 이미지 버퍼 및 프레임워크를 사용할 때와 같은 모든 힙 할당을 포함합니다.

00:02:44.000 --> 00:02:52.000
압축 메모리는 메모리 압축기가 압축한 최근에 액세스하지 않은 더러운 페이지를 의미합니다.

00:02:52.000 --> 00:02:56.000
이 페이지들은 접근 시 압축 해제될 것이다.

00:02:56.000 --> 00:03:03.000
우리는 macOS와 관련된 iOS에서 스왑의 개념이 없다는 점에 유의하십시오.

00:03:03.000 --> 00:03:05.000
그리고 마지막으로, 우리는 깨끗한 기억을 가지고 있다.

00:03:05.000 --> 00:03:10.000
클린 메모리는 기록되지 않은 메모리나 페이징할 수 있는 데이터이다.

00:03:10.000 --> 00:03:16.000
예를 들어, 이것들은 디스크에 있지만 메모리에 로드된 이미지와 같은 메모리 매핑 파일일 수 있습니다.

00:03:16.000 --> 00:03:20.000
아니면 그것들은 틀이 될 수 있다.

00:03:20.000 --> 00:03:27.000
우리가 당신의 애플리케이션의 메모리 풋프린트를 참조할 때, 우리는 정말로 당신의 앱의 더러운 메모리와 압축된 메모리를 함께 이야기하고 있습니다.

00:03:27.000 --> 00:03:31.000
깨끗한 기억은 여기에 포함되지 않는다.

00:03:31.000 --> 00:03:34.000
이것은 당신의 기억력 발자국에 대한 높은 수준의 이해입니다.

00:03:34.000 --> 00:03:43.000
더 심층적이고 자세한 설명을 위해, WWDC 2018의 iOS 메모리 딥 다이브 토크를 확인하는 것이 좋습니다.

00:03:43.000 --> 00:03:49.000
이제 메모리 발자국을 프로파일링하는 데 사용할 수 있는 도구를 살펴봅시다.

00:03:49.000 --> 00:03:58.000
Xcode는 개발 및 생산 워크플로우 전반에 걸쳐 앱의 메모리 성능을 모니터링하는 데 도움이 되는 도구 모음을 제공합니다.

00:03:58.000 --> 00:04:12.000
XCTest 프레임워크는 프로젝트의 단위 및 UI 테스트에서 직접 메모리 풋프린트를 모니터링하는 데 도움이 되며, MetricKit과 Xcode Organizer를 사용하면 고객의 프로덕션에서 메모리 메트릭을 모니터링할 수 있습니다.

00:04:12.000 --> 00:04:16.000
이 이야기의 연속은 성능 XCTests를 사용하는 맥락에서 있을 것이다.

00:04:16.000 --> 00:04:23.000
하지만 이러한 기술은 여전히 일반적인 기억 분류와 조사에 적용된다는 점에 유의하십시오.

00:04:23.000 --> 00:04:32.000
성능 XCTests를 사용하면 메모리 사용률, CPU 사용량, 디스크 쓰기 등과 같은 시스템 리소스를 측정할 수 있습니다.

00:04:32.000 --> 00:04:37.000
예시 테스트를 함께 살펴봅시다.

00:04:37.000 --> 00:04:52.000
제가 일주일 안에 먹을 것을 정리하는 데 도움이 되는 앱인 Meal Planner의 앱 개발자라고 가정해 봅시다. 사용자가 장치에 레시피를 다운로드할 수 있도록 추가한 이 새로운 식사 저장 기능의 메모리 사용량을 측정하고 싶습니다.

00:04:52.000 --> 00:05:03.000
성능 테스트에서 measure(metrics:options:block:) API를 사용하고 있으며 대상 애플리케이션의 메모리 사용을 측정하고 싶다고 지정하고 있습니다.

00:05:03.000 --> 00:05:14.000
측정 블록의 본문에서, 나는 응용 프로그램을 실행하고, 수동으로 측정 API에 측정을 시작하라고 말한 다음, 식사 저장 버튼을 탭합니다.

00:05:14.000 --> 00:05:22.000
UI에서 업데이트를 확인하여 레시피 다운로드가 완료될 때까지 최대 30초를 기다립니다.

00:05:22.000 --> 00:05:28.000
이제 Xcode의 UI에서 이 테스트를 직접 실행하여 측정값을 볼 수 있습니다.

00:05:28.000 --> 00:05:32.000
테스트 옆에 있는 회색 다이아몬드를 클릭하여 측정값에 접근할 수 있습니다.

00:05:32.000 --> 00:05:39.000
결과 팝오버 UI에는 어떤 지표가 측정되었는지 보여주는 드롭다운이 있습니다.

00:05:39.000 --> 00:05:45.000
하단의 막대 그래프는 각 개별 반복에 대한 측정값을 보여준다.

00:05:45.000 --> 00:05:50.000
다섯 번의 반복의 평균이 계산되고 표시됩니다.

00:05:50.000 --> 00:05:59.000
나는 이제 이 실행의 평균을 향후 테스트와 비교할 기준선으로 설정하고 싶은지 결정할 수 있다.

00:05:59.000 --> 00:06:04.000
평균이 설정된 기준선보다 크면 향후 테스트 실행은 이제 실패할 것이다.

00:06:04.000 --> 00:06:09.000
우리는 설정된 기준선에서의 이 편차를 회귀라고 부른다.

00:06:09.000 --> 00:06:18.000
회귀는 테스트가 통과했는지 확인하기 위해 코드를 중지하고, 조사하고, 수정해야 함을 나타냅니다.

00:06:18.000 --> 00:06:26.000
Xcode 13에서 이러한 테스트 회귀를 선별하는 데 도움이 되는 진단을 수집하는 새로운 기능을 추가하게 되어 기쁩니다.

00:06:26.000 --> 00:06:34.000
우리가 가치 있다고 생각하는 두 가지 진단이 있습니다: ktrace 파일과 메모리 그래프.

00:06:34.000 --> 00:06:37.000
Ktrace 파일은 강력하고 다재다능하다.

00:06:37.000 --> 00:06:52.000
그것들은 일반적인 시스템 조사에 사용될 수 있으며, 히치를 조사할 때 렌더링 파이프라인에 뛰어들거나 메인 스레드가 차단될 수 있는 이유를 조사하여 중단되는 것과 같은 특정 문제에 초점을 맞출 수 있습니다.

00:06:52.000 --> 00:06:59.000
이러한 ktrace 파일은 일반적인 워크플로우를 사용하여 Instruments에서 열고 분석할 수 있습니다.

00:06:59.000 --> 00:07:04.000
두 번째 진단은 메모리별 조사에 적합한 메모리 그래프이다.

00:07:04.000 --> 00:07:15.000
메모리 그래프는 Xcode의 시각적 디버거와 다양한 명령줄 도구와 함께 사용할 수 있으며, 그 중 일부는 이 이야기의 뒷부분에서 다룰 것입니다.

00:07:15.000 --> 00:07:21.000
메모리 그래프는 본질적으로 인스턴스에서 프로세스의 주소 공간의 스냅샷입니다.

00:07:21.000 --> 00:07:32.000
멤그래프는 각 가상 메모리 영역과 할당된 각 malloc 블록의 주소와 크기, 그리고 해당 영역과 블록 사이의 포인터를 기록합니다.

00:07:32.000 --> 00:07:40.000
이를 통해 힙의 개별 개체를 검사하고, 연결된 프레임워크와 관련된 데이터 영역을 볼 수 있습니다.

00:07:40.000 --> 00:07:49.000
XCTest는 새로 할당된 객체에 대한 백트레스를 캡처하는 malloc 스택 로깅을 자동으로 활성화합니다.

00:07:49.000 --> 00:07:58.000
진단 수집을 활성화하려면, enablePerformanceTestsDiagnostics 플래그와 함께 xcodebuild 명령줄 도구를 사용하세요.

00:07:58.000 --> 00:08:06.000
이 플래그는 비메모리 메트릭에 대한 ktrace 컬렉션과 메모리 메트릭에 대한 멤그래프를 가능하게 할 것이다.

00:08:06.000 --> 00:08:12.000
이전에 작성된 성능 테스트가 완료되면, 다음 내용이 콘솔에 인쇄된 것을 볼 수 있습니다.

00:08:12.000 --> 00:08:17.000
이것은 꽤 많지만, 찾아야 할 몇 가지 중요한 것들이 있다.

00:08:17.000 --> 00:08:21.000
가장 먼저 찾아야 할 것은 시험이 실패했거나 통과했는지 여부이다.

00:08:21.000 --> 00:08:25.000
이 경우, 시험은 실패했다.

00:08:25.000 --> 00:08:30.000
출력은 또한 특히 회귀로 인해 테스트가 실패했다고 부른다.

00:08:30.000 --> 00:08:35.000
우리의 새로운 평균은 기준선보다 12% 더 나쁘다.

00:08:35.000 --> 00:08:40.000
마지막으로, 우리는 xcresult 번들로 가는 길을 찾을 수 있다.

00:08:40.000 --> 00:08:49.000
Xcode에서 xcresult 번들을 열면, 테스트 이름 옆 상단에 메모리 측정값이 표시됩니다.

00:08:49.000 --> 00:08:57.000
그런 다음 테스트 로그를 확장하고 하단을 향해 첨부된 렘그래프를 찾을 수 있습니다.

00:08:57.000 --> 00:09:00.000
일단 다운로드하고 압축을 풀면, 우리는 2개의 옴그래프를 찾을 수 있다.

00:09:00.000 --> 00:09:07.000
이것은 우리가 malloc 스택 로깅을 활성화하기 위해 테스트에 추가 반복을 추가하기 때문입니다.

00:09:07.000 --> 00:09:17.000
우리는 측정된 반복의 시작 부분에 pre로 접두사가 붙은 초기 렘그래프를 수집하고, 반복이 끝날 때 포스트 접두사가 붙은 두 번째 렘그래프를 수집합니다.

00:09:17.000 --> 00:09:25.000
이를 통해 필요한 경우 한 번의 반복 기간 동안 메모리 성장을 분석할 수 있습니다.

00:09:25.000 --> 00:09:35.000
이제 malloc 스택 로깅이 활성화된 ktrace 파일과 메모리 그래프를 사용하면 회귀가 발생한 경우뿐만 아니라 회귀가 발생한 이유에 대해 답변할 준비가 되었습니다.

00:09:35.000 --> 00:09:45.000
이제 제 동료인 스테판에게 전달하여 수집한 렘그래프 진단을 살펴볼 때 발생할 수 있는 메모리 문제의 유형에 대해 이야기하겠습니다.

00:09:45.000 --> 00:09:48.000
고마워, 타누자. 안녕하세요, 여러분.

00:09:48.000 --> 00:09:50.000
저는 OS 성능 팀의 엔지니어인 스테판입니다.

00:09:50.000 --> 00:10:00.000
앱에서 찾을 수 있는 몇 가지 일반적인 메모리 문제와 이를 진단, 수정 및 예방할 수 있는 방법을 살펴볼 것입니다.

00:10:00.000 --> 00:10:09.000
나는 두 가지 유형의 메모리 문제를 살펴볼 것이다: 힙 할당 회귀와 단편화 문제로 분류될 수 있는 누출과 힙 문제.

00:10:09.000 --> 00:10:14.000
이것은 완전한 목록은 아니지만, 가장 일반적인 문제 중 일부를 다룹니다.

00:10:14.000 --> 00:10:19.000
나는 또한 이러한 문제를 진단하는 데 사용할 수 있는 몇 가지 명령줄 워크플로우를 다룰 것이다.

00:10:19.000 --> 00:10:27.000
명령줄 도구에 대한 보다 심층적인 요약을 보려면, WWDC 2018의 iOS 메모리 딥 다이브 토크를 확인하세요.

00:10:27.000 --> 00:10:31.000
메모리 누수에 대해 논의하는 것으로 시작합시다.

00:10:31.000 --> 00:10:38.000
프로세스가 객체를 할당하고 할당하지 않고 객체에 대한 모든 참조를 잃을 때 누출이 발생합니다.

00:10:38.000 --> 00:10:43.000
여기에 회색 화살표가 물체 간의 참조를 나타내는 예시 물체 그래프가 있습니다.

00:10:43.000 --> 00:10:47.000
모든 물체에 적어도 하나의 참조가 있다는 것을 주목하세요.

00:10:47.000 --> 00:10:51.000
물체 A에서 물체 B로의 점선 참조에 주목하세요.

00:10:51.000 --> 00:10:55.000
이 참조를 nil로 설정하여 제거했다고 가정해 봅시다.

00:10:55.000 --> 00:10:58.000
그 참조가 사라지면서, 객체 B는 유출되었다.

00:10:58.000 --> 00:11:00.000
그것에 대한 언급이 전혀 없다.

00:11:00.000 --> 00:11:06.000
그것은 여전히 더럽지만, 그 과정은 그것을 참조할 방법이 없고 그것이 끝날 때까지 그것을 자유롭게 할 방법이 없다.

00:11:06.000 --> 00:11:11.000
이런 이유로, 당신은 항상 누수를 고쳐야 합니다.

00:11:11.000 --> 00:11:14.000
스위프트에서 물체가 누출되는 일반적인 방법은 주기를 유지하는 것이다.

00:11:14.000 --> 00:11:18.000
이 다이어그램에서, 물체 A와 B는 유지 주기에 있다.

00:11:18.000 --> 00:11:23.000
그들은 서로를 참조하지만, 둘 중 하나에 대한 외부 참조는 없다.

00:11:23.000 --> 00:11:29.000
이것은 그 과정이 그들 중 어느 것에도 접근하거나 해제할 수 없다는 것을 의미하므로, 그들은 유출된 것으로 간주됩니다.

00:11:29.000 --> 00:11:37.000
다행히도, 스위프트의 대부분의 객체는 많은 누출을 방지하는 스위프트의 자동 참조 계산 시스템 또는 ARC에 의해 관리된다.

00:11:37.000 --> 00:11:46.000
안전하지 않은 포인터와 같이 ARC에서 관리하지 않는 객체로 작업하는 경우, 참조를 잃어버리기 전에 할당 해제해야 합니다.

00:11:46.000 --> 00:11:51.000
ARC 관리 객체조차도 유지 주기의 일부가 되기 쉽다.

00:11:51.000 --> 00:11:54.000
그러니 코드에 강력한 순환 참조를 만들지 마세요.

00:11:54.000 --> 00:12:04.000
순환 참조가 절대적으로 필요하다면, 약한 참조가 객체가 할당되는 것을 막을 수 없기 때문에, 대신 약한 참조를 고려하십시오.

00:12:04.000 --> 00:12:07.000
Meal Planner 앱의 예를 살펴봅시다.

00:12:07.000 --> 00:12:12.000
타누자는 나에게 실패한 XCTest의 사전 및 사후 렘그래프를 보냈다.

00:12:12.000 --> 00:12:17.000
지금 당장, 나는 포스트 렘그래프에서 누출이 있는지 확인하고 싶다.

00:12:17.000 --> 00:12:20.000
이것을 하기 위해, 나는 렘그래프에 누수를 실행한다.

00:12:20.000 --> 00:12:26.000
이것은 내가 가지고 있는 누출에 대한 몇 가지 유용한 정보를 보여준다.

00:12:26.000 --> 00:12:32.000
출력은 총 240개의 유출된 바이트에 대해 4개의 누출이 있음을 보여준다.

00:12:32.000 --> 00:12:41.000
더 아래로, 출력에는 각 누출에 대한 객체 그래프의 상세한 보기가 포함되어 있으며, 이는 나에게 무엇이 누출될 수 있는지에 대한 몇 가지 단서를 제공한다.

00:12:41.000 --> 00:12:47.000
객체 그래프의 상단에는 루트 사이클이 있는데, 이는 내가 유지 사이클을 다루고 있다는 것을 의미한다.

00:12:47.000 --> 00:12:49.000
여기에 몇 가지 유용한 기호가 있다.

00:12:49.000 --> 00:12:56.000
이 유지 주기는 아마도 식사 계획과 메뉴 항목 개체를 포함하는 것 같다.

00:12:56.000 --> 00:13:02.000
Malloc 스택 로깅은 XCTests에 대해 활성화되어 있기 때문에, 출력에는 각 누출에 대한 할당 호출 스택도 포함됩니다.

00:13:02.000 --> 00:13:07.000
이것은 유출된 물체를 찾는 데 매우 유용하다.

00:13:07.000 --> 00:13:12.000
종종, 당신은 코드의 기호가 있는 호출 스택의 섹션을 찾고 싶을 것입니다.

00:13:12.000 --> 00:13:16.000
여기 제 코드의 통화 스택 부분이 있습니다.

00:13:16.000 --> 00:13:21.000
새는 식사 계획 객체는 populateMealData 함수에 할당됩니다.

00:13:21.000 --> 00:13:25.000
Xcode를 열고 문제를 해결할 수 있는지 알아보겠습니다.

00:13:25.000 --> 00:13:28.000
여기 제가 누출에서 본 populateMealData 기능이 있습니다.

00:13:28.000 --> 00:13:35.000
여기서 나는 식사 계획 객체와 메뉴 항목 객체를 할당하고 있는데, 이는 내가 유지 주기에서 본 두 가지 객체이다.

00:13:35.000 --> 00:13:39.000
흠, 이 addMealToMealPlan 기능은 약간 의심스러워 보인다.

00:13:39.000 --> 00:13:41.000
내가 볼게.

00:13:41.000 --> 00:13:48.000
흠, 그래서 내가 식사 계획에서 addItem에 전화하는 것 같지만, 메뉴 항목에서 addPlan에도 전화하고 있어.

00:13:48.000 --> 00:13:56.000
이것은 우리가 계획의 모든 항목뿐만 아니라 항목과 관련된 계획을 볼 수 있는 기능을 위한 것입니다.

00:13:56.000 --> 00:14:01.000
여기 식사 계획에서 addItem은 메뉴 항목을 배열에 추가하여 참조를 저장합니다.

00:14:01.000 --> 00:14:06.000
그리고 여기 메뉴 항목에서, addPlan은 식사 계획에 대한 참조를 저장합니다.

00:14:06.000 --> 00:14:11.000
그래서 이것은 둘 다 서로에 대한 강한 참조를 가지고 있기 때문에 확실히 유지 주기이다.

00:14:11.000 --> 00:14:20.000
PopulateMealData가 종료되면, 식사 계획과 메뉴 항목 객체는 모두 범위를 벗어나므로, 외부 참조가 없을 것입니다.

00:14:20.000 --> 00:14:24.000
하지만 그들은 여전히 서로를 참조하여 누출을 일으킨다.

00:14:24.000 --> 00:14:28.000
나는 아마도 주기적인 참조 없이 해결책을 찾으려고 노력해야 할 것이다.

00:14:28.000 --> 00:14:34.000
하지만 지금은 빠른 해결책으로, 나는 식사 계획 대상에 약한 참조를 사용하기 위해 메뉴 항목을 변경할 것이다.

00:14:34.000 --> 00:14:43.000
이것은 우리가 더 이상 두 개의 주기적인 강한 참조를 가지고 있지 않기 때문에 유지 주기를 깨뜨린다.

00:14:43.000 --> 00:14:47.000
이제 힙 할당 회귀로 기어를 바꾸자.

00:14:47.000 --> 00:14:53.000
힙은 단순히 동적으로 할당된 객체가 저장되는 프로세스 주소 공간의 한 부분입니다.

00:14:53.000 --> 00:15:00.000
힙 할당 회귀는 이전보다 힙에 더 많은 객체를 할당하는 프로세스로 인한 메모리 풋프린트의 증가이다.

00:15:00.000 --> 00:15:07.000
힙 회귀를 줄이려면, 사용되지 않은 할당을 제거하고 불필요하게 큰 할당을 줄이세요.

00:15:07.000 --> 00:15:11.000
당신은 또한 당신이 한 번에 얼마나 많은 기억을 가지고 있는지에 주의를 기울여야 합니다.

00:15:11.000 --> 00:15:15.000
더 이상 사용하지 않는 메모리를 할당하고 필요할 때까지 메모리를 할당할 때까지 기다리세요.

00:15:15.000 --> 00:15:21.000
이렇게 하면 앱의 최대 풋프린트가 줄어들어 종료될 가능성이 줄어듭니다.

00:15:21.000 --> 00:15:27.000
이제 MealPlanner 앱에서 실패한 XCTest로 돌아가서 힙 회귀를 확인해 봅시다.

00:15:27.000 --> 00:15:37.000
내가 어디를 봐야 하는지 이해하기 위해, 나는 메모리가 어디에 사용되고 있는지에 대한 좋은 개요를 얻기 위해 사전 및 사후 메모리 그래프 모두에서 vmmap -summary를 실행할 것이다.

00:15:37.000 --> 00:15:42.000
사전 렘그래프에 있는 내 발자국은 약 112메가바이트이다.

00:15:42.000 --> 00:15:50.000
그리고 포스트 렘그래프에서, 내 발자국은 125메가바이트야, 그래서 그건 약 13메가바이트 차이야.

00:15:50.000 --> 00:15:56.000
더 아래로, 출력은 지역별로 분류된 내 프로세스의 메모리 사용량을 보여준다.

00:15:56.000 --> 00:16:05.000
나는 이것이 힙 할당 문제라고 의심하기 때문에, 나는 MALLOC_로 시작하는 지역을 보고 싶다. 왜냐하면 그 지역들은 내 모든 힙 객체를 포함하고 있기 때문이다.

00:16:05.000 --> 00:16:11.000
타누자의 방정식을 기억하세요: 메모리 발자국 = 더러운 메모리 + 압축 메모리.

00:16:11.000 --> 00:16:14.000
이 도구에서, "스왑"이라는 용어는 "압축"을 의미한다.

00:16:14.000 --> 00:16:19.000
그래서 이 칼럼들 중에서, 나는 "더러운 크기"와 "바운 크기"에만 관심이 있다.

00:16:19.000 --> 00:16:25.000
그리고 확실히, 출력은 MALLOC_LARGE 영역이 약 13메가바이트의 더러운 메모리를 보유하고 있다는 것을 보여준다.

00:16:25.000 --> 00:16:29.000
그것은 대략 내 회귀 크기와 같기 때문에, 나는 확실히 그것을 살펴보고 싶다.

00:16:29.000 --> 00:16:35.000
다음 단계는 어떤 종류의 객체가 이 13메가바이트 회귀에 기여하고 있는지 알아내는 것이다.

00:16:35.000 --> 00:16:41.000
그 정보를 얻기 위해, 나는 내 포스트 렘그래프에서 heap -diffFrom을 실행할 것이다.

00:16:41.000 --> 00:16:44.000
나는 사전 및 포스트 렘그래프를 논쟁으로 전달한다.

00:16:44.000 --> 00:16:50.000
이것은 포스트 렘그래프 힙에는 존재하지만 프리 렘그래프 힙에는 존재하지 않는 객체를 보여준다.

00:16:50.000 --> 00:16:57.000
상단 근처에서, 출력은 포스트 렘그래프에 약 13메가바이트의 새로운 객체가 있다는 것을 보여준다.

00:16:57.000 --> 00:17:01.000
아래에서, 힙 메모리는 객체 클래스별로 분류된다.

00:17:01.000 --> 00:17:08.000
각 객체 클래스에 대해, 출력은 객체의 수와 그 객체의 바이트 합계를 보여준다.

00:17:08.000 --> 00:17:13.000
바로, 나는 약 13메가바이트 상당의 이 "비객체" 유형을 가지고 있다는 것을 알아차렸다.

00:17:13.000 --> 00:17:16.000
스위프트에서, 이것은 보통 원시 malloced 바이트를 나타낸다.

00:17:16.000 --> 00:17:23.000
이러한 유형의 물체는 추적하기가 조금 까다로울 수 있지만, 정보를 얻는 데 사용할 수 있는 몇 가지 도구가 있습니다.

00:17:23.000 --> 00:17:27.000
우선, 나는 이 비대상들의 주소를 원한다.

00:17:27.000 --> 00:17:32.000
나는 그것들을 잡기 위해 많은 주소를 실행할 것이다.

00:17:32.000 --> 00:17:37.000
나는 크기가 최소 500킬로바이트인 비객체만 원한다는 것을 명시할 것이다.

00:17:37.000 --> 00:17:39.000
아하.

00:17:39.000 --> 00:17:44.000
이 비대상은 약 13메가바이트이므로, 이 조사의 주요 용의자이다.

00:17:44.000 --> 00:17:48.000
내가 그 주소를 잡아서 그게 뭔지에 대한 단서를 찾을 수 있는지 볼게.

00:17:48.000 --> 00:17:50.000
나는 이 시점에서 몇 가지 선택지가 있다.

00:17:50.000 --> 00:17:56.000
각각은 상황에 따라 이점이 있으므로, 나는 각각을 간략하게 살펴볼 것이다.

00:17:56.000 --> 00:18:01.000
내가 가진 한 가지 옵션은 이 주소에서 누출 --traceTree를 실행하는 것이다.

00:18:01.000 --> 00:18:04.000
이것은 나에게 이 주소를 참조하는 물체의 트리를 준다.

00:18:04.000 --> 00:18:14.000
이것은 내가 더 많은 정보를 얻고 싶은 특정 객체가 있고 내 렘그래프에 malloc 스택 로깅이나 MSL이 활성화되어 있지 않은 경우에 유용합니다.

00:18:14.000 --> 00:18:23.000
XCTest 멤그래프는 자동으로 MSL을 활성화한다는 것을 기억하지만, 그렇지 않은 멤그래프로 작업하는 경우, 이 도구를 명심하세요.

00:18:23.000 --> 00:18:26.000
나는 관련이 있어 보이는 나무의 물체를 강조했다.

00:18:26.000 --> 00:18:33.000
내 큰 비 객체는 아마도 MKTCustomMeal PlannerCollectionViewCell의 이 식사 데이터 객체와 관련이 있을 것이다.

00:18:33.000 --> 00:18:42.000
나는 또한 누출 --referenceTree를 실행할 수 있다.

00:18:42.000 --> 00:18:49.000
이것은 어떤 물체가 뿌리인지에 대한 최선의 추측과 함께 내 과정에서 모든 기억의 하향식 참조 트리를 제공한다.

00:18:49.000 --> 00:18:53.000
이 출력으로, 나는 내 앱에서 메모리가 어디에 집계되는지 알 수 있다.

00:18:53.000 --> 00:19:01.000
이 도구는 내가 큰 회귀가 있다는 것을 알지만 어떤 특정 물체가 책임이 있는지 모른다면 매우 유용하다.

00:19:01.000 --> 00:19:10.000
나는 --groupByType 인수를 유형과 같이 그룹화하여 출력을 축소하고 구문 분석하는 것을 조금 더 쉽게 만들 수 있다.

00:19:10.000 --> 00:19:19.000
종종, 회귀의 큰 덩어리는 이 트리의 단일 노드 아래에 그룹화되어 그 메모리가 무엇인지에 대한 단서를 더 쉽게 찾을 수 있다.

00:19:19.000 --> 00:19:23.000
다시 말하지만, 나는 관련 물체를 보여주는 섹션을 강조했다.

00:19:23.000 --> 00:19:28.000
여기 제가 누출 -traceTree 출력에서 본 것과 같은 식사 데이터 객체가 있습니다.

00:19:28.000 --> 00:19:33.000
출력은 이 식사 데이터 객체에 할당된 약 13메가바이트 상당의 메모리가 있음을 보여준다.

00:19:33.000 --> 00:19:36.000
나는 이 물건이 어떻게 할당되고 있는지 알고 싶다.

00:19:36.000 --> 00:19:44.000
내 렘그래프에 MSL이 활성화되어 있기 때문에, malloc_history -fullStacks를 사용하여 그것을 알아낼 수 있다.

00:19:44.000 --> 00:19:50.000
나는 이전에 힙 주소에서 가져온 큰 비물체의 주소를 전달한다.

00:19:50.000 --> 00:19:53.000
그리고 나는 그 주소에 있는 객체에 대한 할당 호출 스택을 받는다.

00:19:53.000 --> 00:20:01.000
이것은 내가 MSL을 활성화하고 내가 신경 쓰는 물건의 주소를 가지고 있을 때 매우 유용하다.

00:20:01.000 --> 00:20:07.000
그래서 내 식사 데이터 객체가 3번 줄에 표시된 saveMeal 함수에 할당된 것 같습니다.

00:20:07.000 --> 00:20:10.000
무슨 일이 일어나고 있는지 보기 위해 Xcode로 갈게.

00:20:10.000 --> 00:20:14.000
여기 내 사용자 지정 셀 뷰 컨트롤러 내부의 saveMeal 기능이 있습니다.

00:20:14.000 --> 00:20:16.000
그리고 여기 범인이 있어.

00:20:16.000 --> 00:20:20.000
나는 이 원시 버퍼를 여기에 할당한 다음 식사 데이터 객체로 감싸고 있다.

00:20:20.000 --> 00:20:25.000
나는 그것을 채우고 결과를 디스크에 저장할 수 있도록 이 버퍼만 할당하고 있다.

00:20:25.000 --> 00:20:29.000
디스크에 저장을 마치면, 이 버퍼가 더 이상 필요하지 않습니다.

00:20:29.000 --> 00:20:32.000
그래서 그게 왜 붙어 있는 거야?

00:20:32.000 --> 00:20:39.000
음, 식사 데이터는 클래스 멤버이므로, 이 클래스 인스턴스가 존재하는 한, 참조는 계속 유지될 것이다.

00:20:39.000 --> 00:20:46.000
이것은 내가 어떤 셀에서 saveMeal을 눌렀을 때, 그 셀은 그 셀이 파괴될 때까지 붙어 있을 큰 버퍼를 할당하고 보유한다는 것을 의미한다.

00:20:46.000 --> 00:20:51.000
내가 여러 끼의 식사를 절약한다면 그 기억은 정말 합산될 수 있다.

00:20:51.000 --> 00:20:53.000
그래서 내가 이걸 어떻게 고칠 수 있을까?

00:20:53.000 --> 00:21:01.000
한 가지 옵션은 saveMeal 함수에서 mealData를 정의하는 것이지만, 나는 그것이 수업의 다른 곳에서 사용된다는 것을 알고 있기 때문에 그렇게 하고 싶지 않다.

00:21:01.000 --> 00:21:06.000
또 다른 방법은 디스크에 쓰기를 마치면 mealData를 nil로 설정하는 것이다.

00:21:06.000 --> 00:21:18.000
스위프트의 데이터 객체는 최종 참조를 잃어버리면 버퍼를 자동으로 할당 해제할 수 있을 만큼 똑똑하므로, 버퍼는 이 기능의 끝을 지나서 머물지 않을 것이다.

00:21:18.000 --> 00:21:24.000
마지막으로, 분열에 대해 이야기해 봅시다.

00:21:24.000 --> 00:21:27.000
iOS에서 페이지가 어떻게 작동하는지 빠르게 살펴봅시다.

00:21:27.000 --> 00:21:33.000
페이지는 시스템이 프로세스에 부여하는 고정된 크기, 나눌 수 없는 메모리 덩어리입니다.

00:21:33.000 --> 00:21:44.000
페이지는 나눌 수 없기 때문에, 프로세스가 페이지의 어떤 부분에 쓸 때, 전체 페이지는 더러운 것으로 간주되며, 대부분의 프로세스가 사용되지 않더라도 프로세스에 대한 비용이 청구됩니다.

00:21:44.000 --> 00:21:50.000
파편화는 프로세스에 100% 활용되지 않은 더러운 페이지가 있을 때 발생한다.

00:21:50.000 --> 00:21:53.000
이것이 어떻게 일어나는지 이해하기 위해, 예를 들어 봅시다.

00:21:53.000 --> 00:21:58.000
우선, 나는 3개의 연속적인 깨끗한 페이지를 가지고 있다.

00:21:58.000 --> 00:22:05.000
프로세스가 실행됨에 따라, 할당은 이 페이지들을 채우고 더러워지기 시작한다.

00:22:05.000 --> 00:22:12.000
객체가 할당 해제되면, 다이어그램에서 "자유 메모리"로 표시된 빈 슬롯을 만듭니다.

00:22:12.000 --> 00:22:18.000
그러나, 이 페이지들은 여전히 할당된 객체가 있기 때문에 여전히 더럽다.

00:22:18.000 --> 00:22:22.000
그 시스템은 이 빈 슬롯을 향후 할당으로 채우려고 시도할 것이다.

00:22:22.000 --> 00:22:27.000
여기 오른쪽에 있는 상자로 큰 들어오는 할당이 있습니다.

00:22:27.000 --> 00:22:33.000
불행히도, 이 들어오는 할당은 내 무료 메모리 슬롯에 맞추기에는 너무 크다.

00:22:33.000 --> 00:22:41.000
빈 슬롯의 결합된 크기는 충분히 크지만, 인접하지 않으며 단일 할당에 사용할 수 없습니다.

00:22:41.000 --> 00:22:49.000
그래서 기존 빈 슬롯에 들어갈 수 없었기 때문에, 시스템은 다이어그램의 오른쪽에 있는 새로운 더러운 페이지에 내 할당을 배치했다.

00:22:49.000 --> 00:22:55.000
여유 메모리 슬롯은 채워지지 않은 상태로 남아 있으며 조각난 메모리로 간주됩니다.

00:22:55.000 --> 00:23:02.000
단편화를 줄이는 가장 좋은 방법은 메모리에서 서로 가까운 수명을 가진 물체를 할당하는 것이다.

00:23:02.000 --> 00:23:11.000
이것은 모든 객체가 함께 해방되도록 하는 데 도움이 되며, 프로세스에 향후 할당을 위해 작업할 수 있는 큰 연속 메모리 덩어리를 제공한다.

00:23:11.000 --> 00:23:18.000
이 예에서, 나는 "내 물건"으로 표시된 모든 물체를 수동으로 할당했고, 동시에 그것들을 해제할 계획이다.

00:23:18.000 --> 00:23:24.000
하지만 나는 내 코드에서 조심하지 않았고, 시스템은 결국 내 물체를 다른 물체와 인터리빙했다.

00:23:24.000 --> 00:23:33.000
이제, 내가 모든 물체를 해제할 때, 나는 네 개의 자유 메모리 슬롯을 가지고 있는데, 그 중 어느 것도 이 할당된 물체에 의해 부서지기 때문에 인접하지 않다.

00:23:33.000 --> 00:23:36.000
이것은 50%의 단편화와 네 개의 더러운 페이지를 초래한다.

00:23:36.000 --> 00:23:39.000
좋지 않아.

00:23:39.000 --> 00:23:43.000
대신 모든 객체를 함께 할당하기 위해 코드를 작성하면 어떨까요?

00:23:43.000 --> 00:23:46.000
이제 그들은 모두 두 페이지로 합쳐진다.

00:23:46.000 --> 00:23:56.000
그리고 내가 내 물건을 해제할 때, 그 과정은 시스템에 대한 두 개의 깨끗한 페이지를 확보하여 2개의 더러운 페이지와 0%의 단편화로 이어진다.

00:23:56.000 --> 00:23:59.000
단편화가 얼마나 발자국 승수인지 주목하세요.

00:23:59.000 --> 00:24:05.000
50%의 단편화는 내 발자국을 2페이지에서 4페이지로 두 배로 늘렸다.

00:24:05.000 --> 00:24:10.000
대부분의 실제 시나리오에서, 일부 단편화는 불가피하다.

00:24:10.000 --> 00:24:15.000
그래서 경험상, 약 25% 이하의 단편화를 목표로 한다.

00:24:15.000 --> 00:24:19.000
단편화를 줄이는 한 가지 방법은 자동 해제 풀을 사용하는 것이다.

00:24:19.000 --> 00:24:25.000
자동 해제 풀은 시스템이 범위를 벗어나자마자 그 안에 할당된 모든 객체를 해제하도록 지시한다.

00:24:25.000 --> 00:24:31.000
이것은 자동 해제 풀에서 생성된 모든 개체가 비슷한 수명을 갖도록 하는 데 도움이 됩니다.

00:24:31.000 --> 00:24:42.000
단편화는 모든 프로세스에 문제가 될 수 있지만, 주소 공간을 잠재적으로 단편화하기 위한 할당과 할당 해제가 많기 때문에 장기간 실행 프로세스가 특히 취약할 수 있다.

00:24:42.000 --> 00:24:51.000
예를 들어, 앱이 장기 실행 확장을 사용하는 경우, 해당 프로세스의 단편화를 살펴보십시오.

00:24:51.000 --> 00:25:00.000
내 프로세스의 단편화를 빠르게 살펴보기 위해, 나는 vmmap -summary를 실행하고 출력 하단으로 스크롤할 수 있다.

00:25:00.000 --> 00:25:02.000
이 구역은 malloc 구역으로 나뉜다.

00:25:02.000 --> 00:25:05.000
각 구역에는 다른 유형의 할당이 포함되어 있다.

00:25:05.000 --> 00:25:13.000
보통 나는 DefaultMallocZone에만 관심이 있다. 왜냐하면 그곳이 내 힙 할당이 기본적으로 끝나는 곳이기 때문이다.

00:25:13.000 --> 00:25:20.000
그러나, 이 렘그래프는 MSL을 활성화했기 때문에, 나는 실제로 MallocStackLoggingLiteZone에 관심이 있다.

00:25:20.000 --> 00:25:26.000
MSL이 활성화되어 있는 한, 이 영역은 모든 힙 할당이 끝나는 곳이다.

00:25:26.000 --> 00:25:32.000
% FRAG 열은 각 malloc 영역의 단편화로 인해 내 기억의 몇 퍼센트가 낭비되는지 보여준다.

00:25:32.000 --> 00:25:39.000
이 숫자들 중 일부는 꽤 크지만, 나는 MallocStackLoggingLiteZone에만 집중하면 된다.

00:25:39.000 --> 00:25:48.000
그것은 MallocStackLoggingLiteZone이 총 5메가바이트 중 4.3메가바이트로 가장 큰 더티 메모리를 가지고 있기 때문이다.

00:25:48.000 --> 00:25:52.000
그래서 나는 이번에 다른 구역들을 무시할 수 있다.

00:25:52.000 --> 00:26:00.000
"더러운+스왑 프래그 크기" 열은 각 malloc 영역의 단편화로 인해 얼마나 많은 메모리가 낭비되는지 정확히 보여줍니다.

00:26:00.000 --> 00:26:04.000
내 경우, 나는 분열로 인해 약 800K를 낭비하고 있다.

00:26:04.000 --> 00:26:09.000
이것은 많은 것처럼 보이지만, 내가 전에 언급했듯이, 약간의 단편화는 불가피하다.

00:26:09.000 --> 00:26:16.000
그래서 내가 25%의 단편화 아래에 앉아 있는 한, 나는 이 많은 낭비를 받아들일 수 있다고 생각할 것이다.

00:26:16.000 --> 00:26:21.000
나는 MallocStackLoggingLiteZone에서 약 19%의 단편화에 앉아 있는 것 같다.

00:26:21.000 --> 00:26:26.000
이것은 25%의 엄지손가락 규칙보다 편안하게 낮기 때문에, 나는 걱정하지 않는다.

00:26:26.000 --> 00:26:33.000
만약 내가 단편화 문제가 있었다면, 나는 Instruments 도구에서 할당 트랙을 사용할 수 있었다.

00:26:33.000 --> 00:26:42.000
특히, 나는 할당 목록 보기를 보고 내 관심 영역에서 어떤 물체가 지속되고 파괴되었는지 보고 싶다.

00:26:42.000 --> 00:26:52.000
단편화의 맥락에서, 파괴된 객체는 빈 메모리 슬롯을 만드는 반면, 지속된 객체는 페이지를 더럽게 유지하는 나머지 객체이다.

00:26:52.000 --> 00:26:57.000
둘 다 당신이 단편화를 조사할 때 조사할 가치가 있다.

00:26:57.000 --> 00:27:06.000
인스트루먼트 도구를 사용하는 방법에 대한 자세한 내용은 WWDC 2019에서 인스트루먼트 시작하기 토크를 확인하세요.

00:27:06.000 --> 00:27:18.000
이제 누출과 힙 회귀를 해결하고 단편화가 문제가 아니라는 것을 확인했으므로, XCTest를 다시 실행할 것입니다.

00:27:18.000 --> 00:27:19.000
훌륭해.

00:27:19.000 --> 00:27:22.000
XCTest는 이제 통과하고 회귀가 해결되었다.

00:27:22.000 --> 00:27:29.000
이제 메모리 문제를 감지하고 진단하는 방법에 대해 배웠으니, 자신의 앱에 사용할 수 있는 워크플로우를 검토해 봅시다.

00:27:29.000 --> 00:27:38.000
새로운 기능을 추가할 때마다, 메모리 및/또는 제공된 다른 시스템 메트릭을 모니터링하기 위해 성능 XCTest를 작성하십시오.

00:27:38.000 --> 00:27:40.000
각 테스트에 대해, 기준선을 설정하세요.

00:27:40.000 --> 00:27:48.000
그런 다음 테스트를 사용하여 회귀를 포착하고 수집된 ktrace 및 memgraph 파일을 사용하여 조사하십시오.

00:27:48.000 --> 00:27:53.000
실패한 XCTests의 렘그래프를 사용하여 메모리 문제를 진단하세요.

00:27:53.000 --> 00:27:55.000
가장 먼저 해야 할 일은 누출을 확인하는 것입니다.

00:27:55.000 --> 00:28:01.000
누출 도구를 실행하고 MSL 백트레이스를 사용하여 누출을 찾고 수정하십시오.

00:28:01.000 --> 00:28:05.000
회귀에 누출이 포함되지 않는다면, 힙을 확인하세요.

00:28:05.000 --> 00:28:10.000
메모리가 힙에 있는지 확인하기 위해 vmmap -summary로 시작하세요.

00:28:10.000 --> 00:28:15.000
그렇다면, 힙 -diffFrom을 실행하여 어떤 객체 유형이 성장을 담당하는지 확인하세요.

00:28:15.000 --> 00:28:20.000
범인이 명백해 보인다면, 힙 주소를 사용하여 주소를 얻으세요.

00:28:20.000 --> 00:28:24.000
그렇지 않다면, 몇 가지 단서를 위해 leaks -referenceTree를 보세요.

00:28:24.000 --> 00:28:31.000
마지막으로, 누출 -traceTree 및/또는 malloc_history로 범인 객체 주소를 조사하세요.

00:28:31.000 --> 00:28:36.000
마지막으로, 이러한 메모리 모범 사례를 염두에 두고 개발하고 있는지 확인하세요.

00:28:36.000 --> 00:28:38.000
앱에서 누출이 전혀 발생하지 않기 위해 노력하세요.

00:28:38.000 --> 00:28:43.000
안전하지 않은 유형으로 작업하고 있다면, 할당한 모든 것을 무료로 제공하는 것을 잊지 마세요.

00:28:43.000 --> 00:28:47.000
그리고 코드에서 주기를 유지하기 위해 조심하세요.

00:28:47.000 --> 00:28:58.000
힙 할당을 줄이거나, 더 짧은 기간 동안 보유하거나, 불필요한 할당을 완전히 없애는 방법을 찾으세요.

00:28:58.000 --> 00:29:00.000
단편화를 명심하세요.

00:29:00.000 --> 00:29:07.000
비슷한 수명을 가진 개체를 서로 옆에 할당하여 나중에 멋지고 큰 여유 메모리 덩어리를 만드세요.

00:29:07.000 --> 00:29:15.000
이러한 모범 사례와 XCTest 워크플로우를 사용하면 앱에서 메모리 문제를 감지, 진단 및 해결할 수 있습니다.

00:29:15.000 --> 00:29:19.000
타누자와 나를 대신해서, 튜닝해 주셔서 정말 감사합니다.

00:29:19.000 --> 23:59:59.000
[타격적인 음악].

