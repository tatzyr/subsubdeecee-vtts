WEBVTT

00:00:00.000 --> 00:00:05.000
♪ 베이스 음악 연주 ♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:12.000
Thomas Naudet: 안녕하세요, WWDC에 오신 것을 환영합니다.

00:00:12.000 --> 00:00:20.000
저는 애플의 현지화 팀의 토마스이며, 오늘은 현지화된 문자열을 간소화하는 방법을 보여드리겠습니다.

00:00:20.000 --> 00:00:25.000
당신은 당신의 앱이 많은 언어로 작동하도록 하는 가장 쉬운 방법을 보게 될 것입니다.

00:00:25.000 --> 00:00:28.000
우리는 UI 코드를 작성하는 것으로 시작할 것이다.

00:00:28.000 --> 00:00:32.000
그러면 우리는 당신의 목표에서 문자열을 구성하는 방법을 볼 것입니다.

00:00:32.000 --> 00:00:38.000
그 후 우리는 Xcode가 우리를 위해 무거운 일을 하도록 할 것이다.

00:00:38.000 --> 00:00:42.000
마지막으로, 우리는 고급 문자열을 위한 새로운 기술을 배울 것이다.

00:00:42.000 --> 00:00:47.000
이 모든 것을 통해, 우리는 당신의 앱이 훌륭한 번역을 위해 준비되었다는 것을 보장할 것입니다.

00:00:47.000 --> 00:00:52.000
텍스트는 우리 삶의 모든 곳에 있기 때문에 이것은 매우 중요하다.

00:00:52.000 --> 00:00:56.000
우리는 현실 세계에서 소통하고 정보를 얻기 위해 텍스트를 사용한다.

00:00:56.000 --> 00:01:05.000
그것은 분명히 우리가 매일 읽는 모든 앱, 알림 및 기사와 함께 연결된 장치에서 더욱 사실입니다.

00:01:05.000 --> 00:01:12.000
그 어느 때보다도, 텍스트를 읽고, 정확하고, 접근할 수 있는 것이 중요하다.

00:01:12.000 --> 00:01:18.000
그 모든 표지판들 사이에서 작은 가게를 찾으려고 이 거리에서 완전히 길을 잃었다고 상상해 보세요.

00:01:18.000 --> 00:01:21.000
그것은 당신의 앱 사용자에게도 같을 수 있습니다.

00:01:21.000 --> 00:01:27.000
텍스트는 핵심 기능이다 - 그것은 사용자를 안내하고 친숙함을 가져다 준다.

00:01:27.000 --> 00:01:37.000
그런 식으로, 앱을 현지화하는 것은 전 세계 모든 사용자, 특히 App Store가 제공하는 모든 시장에서 도달할 수 있는 기회입니다.

00:01:37.000 --> 00:01:44.000
개발자로서, 우리 개발자들은 이름을 짓는 것을 좋아하기 때문에, 당신은 이미 텍스트에 익숙합니다.

00:01:44.000 --> 00:01:47.000
우리는 텍스트를 "문자열"이라고 불렀다.

00:01:47.000 --> 00:01:58.000
문자열은 어디에나 있습니다: 제목, 버튼, 사용자 콘텐츠, 온라인 콘텐츠, 검색 쿼리, 그래픽, 접근성 라벨 등.

00:01:58.000 --> 00:02:02.000
앱의 모든 문자열을 영화 자막으로 생각하세요.

00:02:02.000 --> 00:02:13.000
당신이 보는 영화에서, 당신은 모든 자막이 올바른 언어로, 적절한 시간에, 올바른 맥락으로, 그리고 영화 전반에 걸쳐 일관성이 있기를 원합니다.

00:02:13.000 --> 00:02:15.000
이건 여기서도 똑같아.

00:02:15.000 --> 00:02:25.000
문자열은 시각적 콘텐츠에 의미를 전달하고 사용자가 앱의 거리를 탐색할 수 있도록 도와줍니다.

00:02:25.000 --> 00:02:31.000
이제 개발자의 관점에서 현지화 과정이 무엇인지 봅시다.

00:02:31.000 --> 00:02:35.000
사용자 인터페이스는 보기에 문자열을 표시합니다.

00:02:35.000 --> 00:02:39.000
그 문자열들은 그들 자신의 파일에 있다.

00:02:39.000 --> 00:02:48.000
이것은 모든 언어에 대한 일반적인 시각적 콘텐츠와 특정 번역 사이의 우려를 분리하는 데 도움이 됩니다.

00:02:48.000 --> 00:02:54.000
그 사이에, 재단 프레임워크는 사용자 인터페이스와 모든 문자열을 연결합니다.

00:02:54.000 --> 00:02:58.000
이 강연에서 나는 이 구성 요소들 각각에 대해 자세히 설명할 것이다.

00:02:58.000 --> 00:03:04.000
그것은 많은 것처럼 보이지만, 우리는 모든 것을 단계별로 밝힐 것이다.

00:03:04.000 --> 00:03:09.000
그런 다음 사용자 인터페이스에서 문자열을 정의하는 것으로 시작합시다.

00:03:09.000 --> 00:03:14.000
최신 Apple 기술을 결합하여 현지화된 문자열을 쉽게 표시할 수 있습니다.

00:03:14.000 --> 00:03:22.000
다시는 현지화에 대해 두 번 생각할 필요가 없도록 앱에서 이러한 기술을 사용하는 것이 좋습니다!

00:03:22.000 --> 00:03:26.000
음, UI에서 정의하는 모든 문자열은 현지화되어야 합니다.

00:03:26.000 --> 00:03:30.000
눈에 보이는 문자열에는 두 가지 유형이 있다.

00:03:30.000 --> 00:03:34.000
하나는 당신이 당신의 견해를 만들 때 직접 정의됩니다.

00:03:34.000 --> 00:03:38.000
여기서, 저는 SwiftUI와 Storyboard에서 라벨을 정의했습니다.

00:03:38.000 --> 00:03:41.000
그리고 맞아! 둘 다 현지화할 수 있다.

00:03:41.000 --> 00:03:43.000
내가 너한테 그게 쉽다고 말했잖아!

00:03:43.000 --> 00:03:54.000
두 번째 유형의 문자열은 더 일반적이며 SwiftUI의 모델 코드뿐만 아니라 AppKit 또는 UIKit에서도 찾을 수 있습니다.

00:03:54.000 --> 00:03:59.000
변수에 문자열을 저장하거나 함수에서 반환해야 할 수도 있습니다.

00:03:59.000 --> 00:04:04.000
이 모든 경우에, 당신은 NSLocalizedString을 사용할 수 있습니다.

00:04:04.000 --> 00:04:12.000
iOS 15와 macOS Monterey의 새로운 기능, Swift, String(로컬화:)에 대한 세련된 방법을 사용할 수 있습니다.

00:04:12.000 --> 00:04:17.000
잠시 SwiftUI의 첫 번째 방법에 집중합시다.

00:04:17.000 --> 00:04:31.000
인터페이스에 존재하는 모든 것은 실제로 텍스트 레이블이든 버튼이든 모두 기본적으로 현지화할 수 있으며, 향후 번역된 문자열을 호스팅할 준비가 되어 있습니다.

00:04:31.000 --> 00:04:40.000
이것은 기본적으로 활성화되어 있기 때문에, 미리보기와 같은 모의 콘텐츠가 있다면, 그대로 사용하여 옵트아웃해야 합니다.

00:04:40.000 --> 00:04:44.000
이것은 번역가들에게 불필요한 일을 피할 것이다.

00:04:44.000 --> 00:04:49.000
이 관련 세션에서 더 많은 기술을 배울 수 있습니다.

00:04:49.000 --> 00:04:54.000
이제 기본 사항을 다뤘으니, 이 문자열을 더 역동적으로 만드는 방법을 배워봅시다.

00:04:54.000 --> 00:04:59.000
저는 현재 주문하기 위해 현지화된 버튼을 보여주고 있습니다.

00:04:59.000 --> 00:05:06.000
너는 내가 콘서트를 좋아한다는 것을 모를 수도 있고, 나는 예술가들이 친구들과 함께 사는 것을 보는 것을 더 좋아한다!

00:05:06.000 --> 00:05:12.000
이 앱에서, 내가 모든 친구들을 위해 얼마나 많은 티켓을 주문하고 있는지는 분명하지 않다.

00:05:12.000 --> 00:05:18.000
그래서 내가 선택한 티켓의 수를 포함하도록 그 버튼을 개선하자.

00:05:18.000 --> 00:05:19.000
그건 쉬웠어.

00:05:19.000 --> 00:05:24.000
나는 방금 스위프트에서 익숙한 것처럼 문자열에 변수를 삽입했다.

00:05:24.000 --> 00:05:31.000
여기서, 카운트는 런타임에 실제 숫자 3으로 대체될 것이다.

00:05:31.000 --> 00:05:38.000
이제 우리는 모든 옵션을 보았으므로, 나는 일반적인 함정을 부르고 싶다: String with (format:).

00:05:38.000 --> 00:05:45.000
(포맷:) 문자열은 훌륭하지만, 현지화된 문자열에 사용하기 위한 것은 아닙니다.

00:05:45.000 --> 00:05:52.000
텍스트 방향과 숫자가 다를 수 있는 아랍어 예시로 왜 그런지 봅시다.

00:05:52.000 --> 00:05:58.000
좋은 소식은 String(localized:)을 사용할 때 둘 다 자동으로 관리된다는 것입니다.

00:05:58.000 --> 00:06:07.000
이제, 숫자 "three"는 설정에서 사용자가 선호하는 숫자에 따라 버튼에 아랍어로 올바르게 쓰여 있습니다.

00:06:07.000 --> 00:06:19.000
문자열(현지화:)은 또한 복수형과 문자열의 각 부분의 분리를 지원하며, 이는 단어가 양방향 텍스트에서 섞이지 않는다는 것을 의미합니다.

00:06:19.000 --> 00:06:22.000
마지막으로, 변수를 과도하게 사용하지 않도록 주의하세요.

00:06:22.000 --> 00:06:28.000
끈을 함께 붙이는 것은 편리하지만 번역 문제로 이어질 수 있다.

00:06:28.000 --> 00:06:39.000
여기서 "주문"이라는 단어는 지금 주문하든 나중에 주문하든 일부 언어로 다르게 쓰여질 수 있습니다.

00:06:39.000 --> 00:06:43.000
두 개의 별도의 문자열을 사용하는 것이 더 안전하다.

00:06:43.000 --> 00:06:52.000
알았어. 내가 지금까지 비밀리에 너에게 숨기고 있다는 것을 우리가 봐야 할 중요한, 마지막 측면이 하나 있다.

00:06:52.000 --> 00:06:57.000
당신이 정의한 문자열은 당신이 아닌 다른 사람이 번역해야 합니다.

00:06:57.000 --> 00:07:08.000
번역가들은 문자열을 문자열로 번역하는 동안 그들 앞에 전체 앱 UI가 없으며, 모든 문자열에서 일관성을 유지해야 합니다.

00:07:08.000 --> 00:07:16.000
그래서 당신은 코드 주석을 추가하여 동료들이 당신의 코드를 이해하도록 돕는 것처럼 그들을 도와야 합니다.

00:07:16.000 --> 00:07:20.000
나는 문자열에 상관없이, 당신은 항상 코멘트를 정의해야 한다고 주장한다.

00:07:20.000 --> 00:07:27.000
그리고 스토리보드 파일을 잊지 마세요; 신원 검사관에 댓글 필드가 있습니다.

00:07:27.000 --> 00:07:31.000
번역가들을 돕기 위한 몇 가지 팁을 공유하겠습니다.

00:07:31.000 --> 00:07:35.000
먼저, 주석은 문자열이 보이는 곳을 설명해야 한다.

00:07:35.000 --> 00:07:41.000
예를 들어, 이것은 버튼인가요? 라벨? 보이스오버 문자?

00:07:41.000 --> 00:07:51.000
이것이 행동인지 -- 주문 -- 또는 진술 -- 주문 --인지 아는 것은 매우 중요하다.

00:07:51.000 --> 00:07:54.000
둘째, 그들은 맥락을 설명해야 한다.

00:07:54.000 --> 00:08:01.000
주문을 누르면, 거래를 완료하거나 목록을 정렬하나요?

00:08:01.000 --> 00:08:04.000
마지막으로, 댓글은 변수를 설명해야 한다.

00:08:04.000 --> 00:08:16.000
로컬라이저가 당신의 문자열을 볼 때, 그들은 당신의 코드를 볼 수 없으므로, 단서를 얻기 위해 변수의 이름을 볼 수 없고, 대신 일반적인 자리 표시자만 볼 수 있습니다.

00:08:16.000 --> 00:08:22.000
그래서 여기의 마지막 예에서, "주문됨" 이전의 숫자는 무엇을 나타내나요?

00:08:22.000 --> 00:08:25.000
이게 지난 주문의 수인가요?

00:08:25.000 --> 00:08:28.000
내가 방금 주문한 티켓의 수?

00:08:28.000 --> 00:08:34.000
응! 그 의견 덕분에, 나는 그것이 총 티켓 수라는 것을 안다.

00:08:34.000 --> 00:08:44.000
많은 언어의 번역가들은 "티켓"이라는 단어의 성별에 따라 정확하게 번역할 수 있을 것이다.

00:08:44.000 --> 00:08:51.000
때때로 가장 쉬운 방법은 주석에 변수의 예시 값을 쓰는 것이다.

00:08:51.000 --> 00:08:53.000
그것을 염두에 두고, 거기에 있다.

00:08:53.000 --> 00:08:59.000
현지화를 위한 UI 코드가 준비되어 있습니다.

00:08:59.000 --> 00:09:05.000
이제, 우리는 당신이 문자열과 별도로 UI 코드를 유지할 수 있는 방법을 배울 것입니다.

00:09:05.000 --> 00:09:10.000
기본적으로, 당신은 당신의 현이 살 곳을 정리할 수 있을 것입니다.

00:09:10.000 --> 00:09:18.000
이를 위해, 재단이 어떻게 당신의 코드가 올바른 현지화된 문자열 파일을 로드하는지 봅시다.

00:09:18.000 --> 00:09:22.000
물론, 현지화는 언어로 시작한다.

00:09:22.000 --> 00:09:27.000
프로젝트 설정으로 가서 새 것을 추가할 수 있습니다.

00:09:27.000 --> 00:09:29.000
Xcode를 살펴봅시다.

00:09:29.000 --> 00:09:34.000
프로젝트를 선택하고 더하기(+) 버튼을 클릭하여 현지화를 추가하세요.

00:09:34.000 --> 00:09:39.000
당신은 메뉴가 최신 버전에서 많은 새로운 언어를 얻은 것을 보게 될 것입니다.

00:09:39.000 --> 00:09:46.000
어디 보자... 현지화 앱 목록에서, 그것은 상단의 베이스로 시작합니다.

00:09:46.000 --> 00:09:51.000
실제로, 이것은 UI 요소가 여러 언어로 공유되기 때문에 사는 곳이다.

00:09:51.000 --> 00:10:00.000
예를 들어, 스토리보드 파일은 공유됩니다; Siri Intents 파일도 공유됩니다.

00:10:00.000 --> 00:10:02.000
그러면 그들은 베이스에 추가되어야 한다.

00:10:02.000 --> 00:10:08.000
따라서 모든 공유 자산에 대한 현지화 버튼을 클릭해야 합니다.

00:10:08.000 --> 00:10:12.000
좋아요, 하지만 반면에 당신의 문자열은 공유되지 않습니다.

00:10:12.000 --> 00:10:14.000
문자열은 하나의 언어에 속한다.

00:10:14.000 --> 00:10:21.000
그래서 당신은 영어로 된 줄과 아랍어로 된 모든 줄을 갖게 될 것입니다.

00:10:21.000 --> 00:10:30.000
특정 언어로 문자열로 앱을 테스트하려면, SwiftUI에서 미리보기 환경을 변경하거나 앱 구성표 설정을 변경할 수 있습니다.

00:10:30.000 --> 00:10:37.000
장치가 앱이 지원하지 않는 언어로 되어 있다면, 재단은 최선의 대안을 찾으려고 합니다.

00:10:37.000 --> 00:10:50.000
만약 내 휴대폰이 멕시코 스페인어로 되어 있다면, 재단은 라틴 아메리카 스페인어로, 그 다음에는 스페인어로, 그리고 당신의 앱 개발 언어(예를 들어, 영어)로 대체하려고 노력할 것이다.

00:10:50.000 --> 00:10:57.000
마지막으로, 문자열이 서버에서 올 때, 사용자가 선호하는 언어를 존중해야 합니다.

00:10:57.000 --> 00:10:58.000
좋아.

00:10:58.000 --> 00:11:02.000
우리는 각 언어에 문자열 모음이 있다는 것을 보았다.

00:11:02.000 --> 00:11:08.000
그 문자열들은 "테이블"이라고 불리는 파일로 더 구성될 수 있다.

00:11:08.000 --> 00:11:12.000
이 기능을 사용하여 모든 문자열을 원하는 대로 구성할 수 있습니다.

00:11:12.000 --> 00:11:18.000
예를 들어, 각 기능 또는 각 화면에 대한 테이블을 가질 수 있습니다.

00:11:18.000 --> 00:11:25.000
이것은 기본적으로 선택 사항이므로, 모든 문자열은 Localizable이라는 테이블에 배치됩니다.

00:11:25.000 --> 00:11:31.000
구체적으로, 이것은 모든 문자열이 Localizable.strings라는 파일에 저장된다는 것을 의미합니다.

00:11:31.000 --> 00:11:36.000
우리가 지금까지 배운 것을 요약하기 위해 예시를 살펴봅시다.

00:11:36.000 --> 00:11:45.000
변수, 사용자 지정 테이블 이름 및 주석으로 문자열을 선언하는 다음 코드가 있습니다.

00:11:45.000 --> 00:11:48.000
내 앱이 프랑스어를 지원한다고 가정해 봅시다.

00:11:48.000 --> 00:11:56.000
Xcode에서는 영어의 프랑스어 번역이 포함된 UserProfile.strings 파일이 필요합니다.

00:11:56.000 --> 00:12:03.000
그것은 관습에 의해 명명된 프랑스 자원 폴더에 저장될 것이다, fr.lproj.

00:12:03.000 --> 00:12:06.000
그 논평은 프랑스 번역가에게 매우 유용했다.

00:12:06.000 --> 00:12:15.000
그들은 "장소"로 여성을 표시하기 위해 "e"를 사용했다; 티켓의 프랑스어는 여성적이다.

00:12:15.000 --> 00:12:19.000
조금 더 양념을 더하고 번들에 대해 이야기하자.

00:12:19.000 --> 00:12:24.000
이 매개 변수는 대상에 걸쳐 문자열을 로드할 수 있게 해준다.

00:12:24.000 --> 00:12:27.000
번들 매개 변수는 기본적으로 기본이다.

00:12:27.000 --> 00:12:30.000
당신의 앱에서, 당신은 그것이 필요하지 않습니다.

00:12:30.000 --> 00:12:32.000
메인은 그 앱이야.

00:12:32.000 --> 00:12:39.000
앱 확장 프로그램에서 메인은 자신의 확장을 의미하므로, 당신도 필요하지 않습니다.

00:12:39.000 --> 00:12:44.000
하지만 앱과 확장 프로그램 간에 문자열을 공유하고 싶다고 가정해 봅시다.

00:12:44.000 --> 00:12:49.000
확장 프로그램에서, 당신은 메인 앱의 번들을 제공해야 할 것입니다.

00:12:49.000 --> 00:12:54.000
그렇게 하면 둘 사이의 문자열을 복제하는 것을 피할 수 있다.

00:12:54.000 --> 00:12:58.000
당신은 또한 프레임워크에서 문자열을 얻을 수 있습니다.

00:12:58.000 --> 00:13:12.000
이 경우, 앱 코드에서 번들을 지정하여 프레임워크의 문자열을 직접 탭하거나, 프레임워크에서 직접 사용할 수 있는 변수를 제공합니다.

00:13:12.000 --> 00:13:21.000
현지화된 문자열 변수는 프레임워크의 자체 번들을 지정하여 프레임워크에서 정의되었다.

00:13:21.000 --> 00:13:31.000
모델을 되돌아봅시다. 이제야 앱이 프레임워크에서 제공하는 문자열을 로드하도록 업데이트할 것입니다.

00:13:31.000 --> 00:13:41.000
프레임워크는 문자열을 정의하고 번역이 문자열 파일의 자체 번들 안에 저장된다는 것을 재단에 알립니다.

00:13:41.000 --> 00:13:49.000
이 매개 변수가 없으면, 문자열은 대신 호스팅 앱에서 가져와서 찾을 수 없을 것이다.

00:13:49.000 --> 00:13:51.000
실제로, 그것은 이렇게 보인다.

00:13:51.000 --> 00:13:55.000
당신은 당신의 텍스트가 저장된 번들을 제공합니다.

00:13:55.000 --> 00:14:00.000
프레임워크는 자체 번들로 문자열을 찾을 것이다.

00:14:00.000 --> 00:14:02.000
그러면 당신의 앱은 쉽습니다.

00:14:02.000 --> 00:14:06.000
문자열은 간단한 코드 줄에서 사용할 수 있다.

00:14:06.000 --> 00:14:19.000
게다가, 이런 식으로 프레임워크에서 현지화를 구현한다면, "완료"가 포함된 문자열 파일을 만들 필요조차 없습니다. 이제 이유를 보자.

00:14:19.000 --> 00:14:24.000
우리는 당신이 문자열을 선언하고 정리하기 위해 코드에서 할 수 있는 모든 것을 보았습니다.

00:14:24.000 --> 00:14:30.000
하지만 우리는 당신의 번역을 저장할 파일을 실제로 만드는 방법을 찾지 못했습니다.

00:14:30.000 --> 00:14:34.000
당신이 실제로 그 문자열 파일을 만들 필요가 없다는 것이 밝혀졌습니다.

00:14:34.000 --> 00:14:40.000
Xcode는 당신을 위해 모든 .strings 파일을 만들 수 있습니다.

00:14:40.000 --> 00:14:46.000
현지화 내보내기를 사용하면 코드를 읽고 모든 문자열을 추출합니다.

00:14:46.000 --> 00:14:49.000
문자열 파일을 유지할 필요가 없기 때문에 이것은 훌륭합니다.

00:14:49.000 --> 00:14:55.000
방금 UI에서 코딩한 문자열을 현지화하는 것을 잊었다면, 이것은 당신을 위한 것입니다.

00:14:55.000 --> 00:15:00.000
만약 당신이 '젠스트링'으로 고군분투한다면, 이것도 당신을 위한 것입니다.

00:15:00.000 --> 00:15:07.000
올해 Xcode 13에서 Swift 문자열 추출을 위한 컴파일러 지원을 추가했습니다.

00:15:07.000 --> 00:15:11.000
또한, 작업 공간은 이제 완전히 지원됩니다.

00:15:11.000 --> 00:15:17.000
이것은 당신의 논리와 번역 사이의 우려를 더욱 분리합니다.

00:15:17.000 --> 00:15:23.000
Xcode는 이전에 본 Swift 및 Foundation 방법에서 텍스트를 감지하고 추출할 것입니다.

00:15:23.000 --> 00:15:30.000
해당 API를 래핑하는 사용자 지정 코드가 있다면, 기본적으로 작동하지 않습니다.

00:15:30.000 --> 00:15:41.000
일반적으로 메소드나 매크로를 사용할 필요는 없지만, 정말 필요하다면, 현지화된 문자열 매크로 이름 아래의 빌드 설정에 추가할 수 있습니다.

00:15:41.000 --> 00:15:56.000
나머지를 위해, Xcode는 Info.plist에 정의된 앱 이름과 개인 정보 보호 설명과 일반적으로 Xcode의 관리자에서 현지화된 것으로 표시된 모든 자산을 현지화하기 위해 추출합니다.

00:15:56.000 --> 00:16:03.000
기존 현지화가 있다면, 이미 새로운 UI를 위한 Xcode의 내보내기로 전환할 수 있습니다.

00:16:03.000 --> 00:16:08.000
새로운 문자열은 기존 파일에 자동으로 추가됩니다.

00:16:08.000 --> 00:16:14.000
자신의 속도로 프로젝트를 변환하고 싶다면 이것은 좋습니다.

00:16:14.000 --> 00:16:19.000
보너스로, 이제 UI 테스트의 스크린샷이 포함되어 있습니다.

00:16:19.000 --> 00:16:31.000
로컬라이저가 문자열이 있는 컨텍스트를 얻을 수 있도록 하는 것이 좋으며, App Store에서 앱의 현지화된 스크린샷을 보여주는 것은 훌륭합니다.

00:16:31.000 --> 00:16:41.000
좋아요, Xcode는 모든 현지화 카탈로그를 추출했으니, 이제 번역가들이 일할 차례라고 생각할 것입니다.

00:16:41.000 --> 00:16:43.000
사실, 너도 할 수 있어!

00:16:43.000 --> 00:16:51.000
Xcode 13의 새로운 기능, 내보낸 현지화 카탈로그는 Xcode에서 직접 보고 편집할 수 있습니다.

00:16:51.000 --> 00:16:56.000
왼쪽 번들에서 생성된 각 파일, 즉 각 테이블을 볼 수 있습니다.

00:16:56.000 --> 00:17:03.000
그리고 당신의 선택을 위해, 포함된 모든 문자열, 이미지 및 파일을 볼 수 있습니다.

00:17:03.000 --> 00:17:10.000
문자열을 필터링하고, 정렬하고, 댓글, 스크린샷을 보고, 심지어 번역할 수도 있습니다!

00:17:10.000 --> 00:17:14.000
이것은 당신이 자신의 앱을 개발하고 번역한다면 매우 편리합니다.

00:17:14.000 --> 00:17:19.000
그것은 당신이 직접 문자열을 검토하고 버그를 고칠 수 있게 해준다.

00:17:19.000 --> 00:17:30.000
번역가가 번역된 문자열 카탈로그를 다시 보내면, Xcode의 제품 메뉴를 사용하여 프로젝트로 가져올 수 있습니다.

00:17:30.000 --> 00:17:37.000
그리고 붐! 문자열 파일, 문자열 및 기타 자산이 생성되고 업데이트됩니다.

00:17:37.000 --> 00:17:45.000
명령줄 등가물을 사용하면 지속적인 통합 시스템에서 자동 내보내기 및 가져오기를 실행할 수 있습니다.

00:17:45.000 --> 00:17:55.000
그것들을 정기적으로 호출함으로써, 당신의 프로젝트는 최신 문자열을 얻고, 새로운 UI를 번역하는 데 빠른 턴어라운드를 얻을 수 있습니다.

00:17:55.000 --> 00:18:05.000
올해 세션인 "SwiftUI 앱 현지화"에서 향상된 워크플로우를 볼 수 있으며 소개 세션에서 자세히 알아볼 수 있습니다.

00:18:05.000 --> 00:18:06.000
그게 다야!

00:18:06.000 --> 00:18:10.000
당신은 앱에서 문자열이 어떻게 태어나고 사는지 목격했습니다.

00:18:10.000 --> 00:18:14.000
결론적으로, 좀 더 복잡한 문자열을 다루는 방법을 보여드리겠습니다.

00:18:14.000 --> 00:18:18.000
그리고 나는 네가 우리가 매장에 가지고 있는 새로운 기능을 좋아할 거라고 확신해.

00:18:18.000 --> 00:18:20.000
좋은 것부터 시작하자!

00:18:20.000 --> 00:18:25.000
우리는 현지화가 내장되도록 속성 문자열을 개선했습니다.

00:18:25.000 --> 00:18:30.000
이제 마크다운 구문을 지원하면 가능합니다!

00:18:30.000 --> 00:18:34.000
이제 서식을 잃지 않고 문자열을 현지화할 수 있습니다.

00:18:34.000 --> 00:18:40.000
한 단어를 굵게 만들기 위해 더 이상 위험한 캐릭터 작업은 없습니다.

00:18:40.000 --> 00:18:57.000
말하자면, 여기서 나는 "완전"에 중점을 두기 위해 별표를 사용한다. 링크, 강조, 모노스페이스 텍스트 등을 추가하는 방법을 배우기 위해 "파운데이션의 새로운 기능"을 확인하는 것이 좋습니다.

00:18:57.000 --> 00:19:03.000
우리는 당신이 코드에서 정의한 하나의 문자열이 문자열 파일에 하나의 번역을 가질 것이라는 것을 보았습니다.

00:19:03.000 --> 00:19:09.000
하지만 때때로 당신은 여러 표현을 갖기 위해 문자열이 필요합니다.

00:19:09.000 --> 00:19:17.000
이것은 당신이 정의한 규칙에 적응하는 문자열 모음인 stringsdict 파일로 가능합니다.

00:19:17.000 --> 00:19:22.000
예를 들어, 우리가 여러 장의 티켓을 주문하고 싶은 예시를 기억하시나요?

00:19:22.000 --> 00:19:31.000
영어로, 우리는 여러 장의 티켓이 있고 한 장의 티켓에 "s"가 없는 경우 접미사로 "s"를 추가할 것이다.

00:19:31.000 --> 00:19:37.000
코드를 간단하고 정확하게 유지하려면, stringsdict를 사용하여 이 복수 규칙을 정의해야 합니다.

00:19:37.000 --> 00:19:43.000
왜냐하면 앱을 현지화하면, 그 규칙은 언어마다 다르기 때문입니다.

00:19:43.000 --> 00:19:46.000
러시아어로 된 몇 가지 사례를 보세요.

00:19:46.000 --> 00:19:53.000
당신은 코드에서 그것을 다루고 싶지 않습니다, 그것은 오히려 현지화가 처리해야 할 것입니다.

00:19:53.000 --> 00:19:55.000
우리가 그것을 어떻게 구현할지 봅시다.

00:19:55.000 --> 00:20:01.000
코드 변경이 필요하지 않습니다; 우리는 여전히 위의 기존 코드를 사용할 것입니다.

00:20:01.000 --> 00:20:08.000
첫째, 당신을 위해 만들어진 문자열 파일과 비교할 때, stringsdict는 수동 옵트인입니다.

00:20:08.000 --> 00:20:15.000
따라서 Xcode 템플릿을 사용하여 하나를 만들고, 인스펙터에서 현지화를 클릭했는지 확인하세요.

00:20:15.000 --> 00:20:20.000
좋아요, 그것은 모두 당신이 코드에서 정의한 문자열로 시작됩니다.

00:20:20.000 --> 00:20:27.000
코드에 복수 문자열이 여러 개 있는 경우, 각각에 대해 이 루트 항목을 추가할 수 있습니다.

00:20:27.000 --> 00:20:30.000
내부에서, 당신은 제시된 실제 가치를 정의합니다.

00:20:30.000 --> 00:20:34.000
이 값은 검색-대체 메커니즘을 따른다.

00:20:34.000 --> 00:20:40.000
이 예에서 저는 "티켓"이라는 토큰 하나를 정의했습니다.

00:20:40.000 --> 00:20:44.000
그것은 완전한 최종 문자열을 보유할 것이다.

00:20:44.000 --> 00:20:59.000
토큰 안에 대부분의 텍스트를 포함하는 것이 가장 좋지만, 번역가가 접두사, 접미사를 추가하거나 여러 변수가 있는 경우 토큰을 이동해야 하는 경우 해당 필드를 현지화할 수 있습니다.

00:20:59.000 --> 00:21:04.000
좋아요, 그 토큰은 코드의 한 변수에 따라 달라질 것입니다.

00:21:04.000 --> 00:21:08.000
그럼 그 티켓 토큰을 정의해 봅시다.

00:21:08.000 --> 00:21:13.000
먼저, 우리는 우리가 복수화를 하고 있다는 것을 확인한다.

00:21:13.000 --> 00:21:20.000
그런 다음 우리는 변수가 C 스타일 포맷터 d가 있는 숫자임을 나타냅니다.

00:21:20.000 --> 00:21:24.000
그리고 마지막으로, 우리는 복수의 규칙을 쓸 수 있다.

00:21:24.000 --> 00:21:31.000
원한다면 영어로 "하나"와 "기타"와 "제로" 규칙을 선언할 수 있습니다.

00:21:31.000 --> 00:21:37.000
각 항목에 대해, 우리는 티켓 토큰의 실제 가치를 씁니다.

00:21:37.000 --> 00:21:45.000
그런 다음, 우리가 세 장의 티켓을 가지고 있다면, 영어로 "기타"를 사용하고 "티켓 3장 주문"을 생성할 것입니다.

00:21:45.000 --> 00:21:49.000
%D를 숫자 3으로 대체함으로써.

00:21:49.000 --> 00:21:52.000
언어에 더 많은 사례가 필요하다면, 걱정하지 마세요.

00:21:52.000 --> 00:21:55.000
Xcode는 내보내기 시간에 당신을 위해 그것들을 추가할 것입니다.

00:21:55.000 --> 00:22:02.000
러시아어로 그것은 기존 것들 위에 "소수"와 "많은"를 추가할 것이다.

00:22:02.000 --> 00:22:03.000
그게 다야!

00:22:03.000 --> 00:22:07.000
우리의 문자열은 런타임에 복수화될 것이다.

00:22:07.000 --> 00:22:10.000
우리가 넘어가기 전에, 나는 한 가지 사례를 제기하고 싶다.

00:22:10.000 --> 00:22:18.000
Stringsdict는 복수형에 사용되어야 하지만, 숫자를 포함하는 문자열을 위한 것이다.

00:22:18.000 --> 00:22:21.000
우리는 이전에 영어로 단수에 대한 "one"의 경우를 보았다.

00:22:21.000 --> 00:22:31.000
그것은 실제로 러시아어로 1위를 위한 것이지만, 21, 31 등에도 사용된다.

00:22:31.000 --> 00:22:42.000
그런 경우, stringsdict를 사용하는 것은 단지 하나만 같기를 원하기 때문에 정확하지 않을 것입니다.

00:22:42.000 --> 00:22:47.000
이 예에서, 복수형은 이것, 둘 다 또는 모두에 따라 다르다.

00:22:47.000 --> 00:22:51.000
숫자가 없습니다; stringsdict를 사용하지 마세요.

00:22:51.000 --> 00:23:01.000
내가 내 모든 친구들을 위해 21장의 티켓을 예약한다고 상상해봐, 그리고 나는 러시아어로 "모든 티켓 주문" 대신 "이 티켓 주문"을 볼 수 있을 거야.

00:23:01.000 --> 00:23:05.000
나는 너에게 "내 돈은 어디 있어?"라고 물어볼 거야.

00:23:05.000 --> 00:23:15.000
대신 모든 언어에서 세 개의 문자열 각각의 올바른 복수화를 위해 이 간단하지만 효과적인 if/else를 사용하세요.

00:23:15.000 --> 00:23:21.000
그리고 그것은 복수 지원이었지만, stringsdict는 문자열의 더 많은 변형 유형을 처리할 수 있다.

00:23:21.000 --> 00:23:26.000
더 많은 것을 배우기 위해 관련 세션을 보도록 초대합니다.

00:23:26.000 --> 00:23:32.000
이것은 훌륭하지만, 우리는 당신에게 더 간단한 방법을 제공하고 싶었습니다.

00:23:32.000 --> 00:23:36.000
네, 재단은 올해 당신을 위해 문법을 하는 방법을 배웠습니다!

00:23:36.000 --> 00:23:49.000
속성 문자열에 마크다운 지원이 추가되면, 굴절 속성과 함께 이 새로운 형식을 사용하면, 이 버튼과 같이 런타임에 계산된 올바른 값을 얻을 수 있습니다.

00:23:49.000 --> 00:23:57.000
이것은 iOS 15와 macOS Monterey에 추가된 훌륭한 새로운 기능이며, 현재 일부 언어로 제공됩니다.

00:23:57.000 --> 00:24:02.000
더 많은 제어를 원한다면, stringsdict를 사용할 수 있습니다.

00:24:02.000 --> 00:24:05.000
우리는 복수 지원을 추가하는 것을 멈추지 않았다.

00:24:05.000 --> 00:24:10.000
우리는 우리의 소프트웨어 문자열이 더 포괄적이기를 원했다.

00:24:10.000 --> 00:24:15.000
예를 들어, 앱이 사용자를 환영할 때, 영어로는 꽤 간단하다.

00:24:15.000 --> 00:24:23.000
하지만 그것은 사용자의 주소 용어에 따라 다르기 때문에 스페인어로 되어 있지 않습니다.

00:24:23.000 --> 00:24:31.000
지금까지, 당신은 정확하지만 대부분의 스페인 사용자에게 과장된 개인화되지 않은 문자열을 제시해야 했습니다.

00:24:31.000 --> 00:24:35.000
말 그대로, "우리는 당신을 환영합니다."

00:24:35.000 --> 00:24:39.000
그래서 우리가 사용자를 위해 문자열을 개인화할 수 있다면 어떨까요?

00:24:39.000 --> 00:24:43.000
우리의 새로운 마크다운 표기법으로, 당신은 지금 그것을 할 수 있습니다!

00:24:43.000 --> 00:24:49.000
문자열은 이제 장치의 언어 설정에서 선택한 주소 조건을 따를 것입니다.

00:24:49.000 --> 00:25:04.000
그래서 여성으로 언급되기를 원하는 사용자를 위한 "Bienvenida", 남성의 "Bienvenido", 그리고 우리가 모른다면, 우리는 기존의 굴절 대안을 사용할 것이다.

00:25:04.000 --> 00:25:11.000
복수형과 주소 용어에 대한 인라인 굴절은 코드나 번역에서 정의할 수 있습니다.

00:25:11.000 --> 00:25:19.000
우리는 선택 언어에 대한 이 새로운 추가에 대해 매우 흥분하고 있으며, 당신의 앱이 그것을 사용하는 것을 빨리 보고 싶습니다.

00:25:19.000 --> 00:25:25.000
마지막으로, 우리는 오늘 현지화 가능한 문자열을 작성할 수 있는 모든 방법을 보았습니다.

00:25:25.000 --> 00:25:32.000
하지만 데이터를 제시하고 싶다면, 실제로 프레임워크가 당신을 위해 그것들을 작성하도록 해야 합니다.

00:25:32.000 --> 00:25:39.000
우리의 포맷터는 수백 개의 언어와 지역 조합, 그리고 다양한 유형과 단위를 처리합니다.

00:25:39.000 --> 00:25:44.000
그러니 하드코딩하지 마세요; 열심히 합시다.

00:25:44.000 --> 00:25:49.000
그리고 올해부터 스위프트에서 포맷터를 채택하는 것이 그 어느 때보다 쉽다.

00:25:49.000 --> 00:25:55.000
우리는 그것들을 당신의 문자열 보간에서 인라인으로 사용하기 쉽게 만들었습니다.

00:25:55.000 --> 00:26:03.000
올해의 "파운데이션의 새로운 기능"을 확인하여 당신이 가장 좋아하는 새로운 API를 찾고 오늘 우리가 본 모든 것에 대한 세부 정보를 얻으십시오.

00:26:03.000 --> 00:26:10.000
이전 릴리스에 배포해야 하거나 포맷터에 대한 세부 정보를 원한다면, 작년 세션을 확인하세요.

00:26:10.000 --> 00:26:21.000
좋아요, 오늘 가져가고 싶은 것은 최신 API를 사용하여 코드를 작성하면 Xcode가 모든 문자열을 생성한다는 것입니다.

00:26:21.000 --> 00:26:30.000
번들에서 문자열을 구성하는 방법을 보았고, 문법과 서식을 쉽게 만들 수 있는 새로운 API를 발견했습니다.

00:26:30.000 --> 00:26:37.000
이 모든 기술을 따른다면, 새로운 언어를 추가하면 코드 변경이 필요하지 않습니다!

00:26:37.000 --> 00:26:40.000
마지막으로, 항상 테스트하세요.

00:26:40.000 --> 00:26:49.000
문자열을 현지화하는 데 아무리 많은 노력을 기울이더라도, 앱이 모든 언어에서 잘 실행되는지 테스트해야 합니다.

00:26:49.000 --> 00:26:54.000
그것으로, 저는 당신의 완전히 현지화된 앱으로 콘서트를 빨리 예약하고 싶습니다.

00:26:54.000 --> 00:26:58.000
나머지 WWDC를 즐기세요, 시청해 주셔서 감사합니다.

00:26:58.000 --> 23:59:59.000
♪

