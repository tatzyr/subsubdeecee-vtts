WEBVTT

00:00:02.000 --> 00:00:15.000
안녕. 제 이름은 리니 파텔이고, GPU 소프트웨어 엔지니어링 팀에서 왔어요.

00:00:15.000 --> 00:00:20.000
이 세션에서, 나는 메탈의 새로운 셰이더 컴파일 워크플로우를 소개할 것이다.

00:00:20.000 --> 00:00:28.000
메탈 셰이딩 언어는 C++ 기반 언어이며, 컴파일 모델은 CPU 컴파일 모델과 매우 유사하다.

00:00:28.000 --> 00:00:38.000
GPU 워크로드의 복잡성이 증가함에 따라, 메탈은 현대적인 사용 사례를 지원하는 데 필요한 유연성과 성능을 해결하기 위해 비슷하게 진화했다.

00:00:38.000 --> 00:00:57.000
셰이더를 작성하는 동안 이미 직면했을 수 있는 몇 가지 일반적인 과제는 파이프라인에서 유틸리티 코드를 공유하거나, 재컴파일 없이 런타임에 셰이더 동작을 수정하거나, 애플리케이션 실행 사이에 컴파일된 GPU 바이너리를 재사용할 수 있습니다.

00:00:57.000 --> 00:01:02.000
그래서, 간단한 셰이더 코드를 살펴보고 시나리오에 대해 논의해 봅시다.

00:01:02.000 --> 00:01:10.000
여기에는 조건의 결과에 따라 foo() 또는 bar()의 결과를 반환하는 간단한 조각 셰이더가 있습니다.

00:01:10.000 --> 00:01:19.000
이제, 만약 그 기능들이 여러 파이프라인에 의해 호출된다면, 우리는 그것들을 한 번만 컴파일하고 대신 각 파이프라인에 연결하고 싶을 수도 있다.

00:01:19.000 --> 00:01:31.000
런타임에 이러한 함수의 다른 구현을 연결해야 할 수도 있고, baz()에 대한 새로운 사례 문을 처리하기 위해 확장 가능한 조각 셰이더가 필요할 수도 있습니다.

00:01:31.000 --> 00:01:38.000
우리는 또한 프래그먼트 함수에서 baz() 대신 사용자 제공 함수 bat()을 호출할 수 있기를 원할 수도 있습니다.

00:01:38.000 --> 00:01:49.000
보시다시피, 셰이더 저작 파이프라인에는 다양한 요구 사항이 있으며, Metal은 다양한 구현을 지원하기 위해 다양한 API를 제공합니다.

00:01:49.000 --> 00:01:54.000
각 접근 방식은 편집 시간과 셰이더 성능 사이에 다른 절충안을 가질 것이다.

00:01:54.000 --> 00:02:03.000
그리고 오늘, 저는 성능과 유연성 사이의 완벽한 균형을 찾는 데 도움이 될 새로운 편집 워크플로우에 대해 이야기하고 싶습니다.

00:02:03.000 --> 00:02:11.000
우리는 렌더링 파이프라인을 위한 동적 라이브러리와 렌더링 파이프라인을 위한 기능 포인터에 대한 새로운 지원으로 시작할 것입니다.

00:02:11.000 --> 00:02:16.000
우리는 binaryArchive API에 대한 추가 사항에 대해 조금 이야기할 것입니다.

00:02:16.000 --> 00:02:19.000
그러면, 우리는 비공개로 연결된 기능을 보게 될 것이다.

00:02:19.000 --> 00:02:26.000
그리고 마지막으로, 우리는 금속에서 눈에 보이는 기능을 바느질하기 위한 새로운 기능을 소개할 것입니다.

00:02:26.000 --> 00:02:30.000
그래서, 메탈의 동적 라이브러리 지원부터 시작합시다.

00:02:30.000 --> 00:02:34.000
동적 라이브러리는 소프트웨어 공학의 일반적인 도구이다.

00:02:34.000 --> 00:02:43.000
그것들은 유틸리티 코드를 독립형 컴파일 단위로 구획화할 수 있는 공유 객체 파일입니다.

00:02:43.000 --> 00:02:51.000
그들은 컴파일된 셰이더 코드의 양을 줄이고 여러 파이프라인 사이에서 재사용하는 데 도움을 준다.

00:02:51.000 --> 00:02:59.000
또한, GPU 바이너리 코드를 동적으로 연결, 로드 및 공유할 수 있습니다.

00:02:59.000 --> 00:03:14.000
작년에, 우리는 컴퓨팅 파이프라인을 위한 동적 언어를 도입했고, 메탈의 동적 라이브러리에 대한 더 많은 소개를 얻기 위해, 작년의 프레젠테이션인 "메탈로 GPU 바이너리 구축"을 확인하는 것이 좋습니다.

00:03:14.000 --> 00:03:19.000
올해, 우리는 파이프라인을 렌더링하고 타일링하기 위해 동적 라이브러리를 가져오고 있다.

00:03:19.000 --> 00:03:26.000
이 추가 지원을 통해 이제 모든 컴퓨팅 및 렌더링 워크로드에서 유틸리티 라이브러리를 공유할 수 있습니다.

00:03:26.000 --> 00:03:32.000
그리고 이제 우리는 동적 라이브러리가 무엇인지 알았으니, 몇 가지 사용 사례에 대해 이야기할 때입니다.

00:03:32.000 --> 00:03:38.000
도우미 함수는 종종 일반적인 계산, 정점, 조각 및 타일 셰이더에서 사용됩니다.

00:03:38.000 --> 00:03:47.000
파이프라인을 렌더링하기 위해 동적 라이브러리를 추가하면, 이제 많은 양의 유틸리티 코드를 관리하고 모든 워크로드에서 공유할 수 있습니다.

00:03:47.000 --> 00:04:01.000
컴파일 속도가 느려지지 않고 런타임에 사용할 수 있는 라이브러리를 미리 컴파일할 수 있으며, 파이프라인을 만드는 동안 로드된 라이브러리를 변경하여 런타임의 기능을 바꿀 수도 있습니다.

00:04:01.000 --> 00:04:10.000
그들은 또한 사용자가 소스를 제공할 필요 없이 파이프라인의 일부로 로드할 수 있는 셰이더 코드를 작성할 수 있도록 도와줍니다.

00:04:10.000 --> 00:04:13.000
그래서, 우리는 언제 동적 라이브러리를 사용해야 하는지에 대해 이야기했다.

00:04:13.000 --> 00:04:16.000
이제 그들과 함께 만들고 일하는 방법을 살펴봅시다.

00:04:16.000 --> 00:04:25.000
예제 프래그먼트 셰이더에서, 우리는 함수 foo()와 bar()를 호출하지만, 컴파일 타임에는 구현을 제공하지 않습니다.

00:04:25.000 --> 00:04:32.000
대신, 이러한 기능에 대한 구현은 나중에 렌더링 파이프라인을 만들 때 연결하는 메탈 라이브러리에 존재합니다.

00:04:32.000 --> 00:04:38.000
그리고 사용할 수 있는 각 기능에 대해 별도의 라이브러리를 제공하는 것도 가능합니다.

00:04:38.000 --> 00:04:44.000
이제 Metal에서 동적 라이브러리를 구축하여 가지고 있는 도구와 유연성에 대해 논의해 봅시다.

00:04:44.000 --> 00:04:59.000
먼저 Metal 셰이더 소스를 AIR로 컴파일해야 하며, 빌드 프로세스의 일부로 Xcode의 Metal 툴체인을 사용하거나 런타임에 newLibraryWithSource API를 사용하여 소스에서 컴파일하여 이를 수행할 수 있습니다.

00:04:59.000 --> 00:05:08.000
AIR에서 컴파일된 Metal 셰이더를 사용하면 이제 새로운DynamicLibrary API를 사용하여 동적 라이브러리를 만들 수 있습니다.

00:05:08.000 --> 00:05:13.000
이 라이브러리는 GPU 바이너리 형식으로 사용할 준비가 되어 있습니다.

00:05:13.000 --> 00:05:16.000
하지만 나중에 그것을 재사용하고 싶다면 어떨까요?

00:05:16.000 --> 00:05:25.000
그렇게 하려면, 동적 라이브러리를 디스크로 직렬화할 수 있으며, 이는 serializeToURL API를 사용하여 수행할 수 있습니다.

00:05:25.000 --> 00:05:32.000
그리고 나중에, newDynamicLibraryWithURL API를 호출하여 재사용할 수 있습니다.

00:05:32.000 --> 00:05:37.000
이제 동적 라이브러리와 프래그먼트 셰이더에서 함수를 호출하는 예를 살펴봅시다.

00:05:37.000 --> 00:05:46.000
이 예에서, 우리는 extern 키워드를 사용하여 함수 foo()와 bar()를 선언하지만, 그들에 대한 정의를 제공하지는 않습니다.

00:05:46.000 --> 00:05:50.000
그것들을 사용하기 위해, 우리는 단순히 조각 셰이더에서 이 함수들을 부른다.

00:05:50.000 --> 00:05:56.000
그리고 메탈 라이브러리를 구축할 때 외부 기능에 대한 구현을 제공할 수 있습니다.

00:05:56.000 --> 00:06:04.000
이제, 런타임에 이러한 구현을 다른 것으로 교체하는 것도 가능하다는 것을 명심하세요.

00:06:04.000 --> 00:06:11.000
그리고 이렇게 하려면, 동적 라이브러리를 적절한 사전 로드된 라이브러리 배열에 추가하기만 하면 됩니다.

00:06:11.000 --> 00:06:17.000
우리의 경우, 그것은 단편이지만, 각 단계와 파이프라인에 대해 비슷한 속성을 사용할 수 있다.

00:06:17.000 --> 00:06:23.000
그리고 기호는 라이브러리가 이 배열에 추가되는 것과 같은 순서로 해결될 것이다.

00:06:23.000 --> 00:06:27.000
이 워크플로우는 새로운 구현을 실험하기에 매우 적합하다.

00:06:27.000 --> 00:06:31.000
그리고 그것은 역동적인 도서관을 위한 것이다.

00:06:31.000 --> 00:06:41.000
Metal 동적 라이브러리를 사용하려는 경우, macOS Monterey의 Apple GPU 제품군 7 이상에서 컴퓨팅 파이프라인을 지원할 수 있습니다.

00:06:41.000 --> 00:06:50.000
다른 GPU뿐만 아니라 대부분의 Mac 제품군 2 장치에서도 사용할 수 있지만, 메탈 장치 지원 동적 라이브러리를 호출해야 합니다.

00:06:50.000 --> 00:06:56.000
iOS 15에서 이 기능은 모든 Apple 6 기기 이상에서 사용할 수 있습니다.

00:06:56.000 --> 00:07:03.000
렌더링 및 타일 파이프라인 지원은 Apple 6 기능 세트를 지원하는 모든 장치에서 사용할 수 있습니다.

00:07:03.000 --> 00:07:09.000
다음으로, 올해 출시될 기능 포인터의 개선에 대해 이야기해 봅시다.

00:07:09.000 --> 00:07:21.000
함수 포인터는 이전에 본 적이 없는 함수를 호출할 수 있도록 하여 코드를 확장할 수 있도록 호출할 수 있는 코드를 참조하는 간단한 구성입니다.

00:07:21.000 --> 00:07:32.000
작년에, 우리는 컴퓨팅 파이프라인 함수 포인터를 도입했고, 그것을 위해, 나는 당신이 우리의 전년도 프레젠테이션인 "금속 함수 포인터에 대해 알아보세요"를 확인하는 것을 추천합니다.

00:07:32.000 --> 00:07:38.000
올해, 우리는 애플 실리콘의 렌더링 및 타일 파이프라인에 대한 기능 포인터 지원을 확장하고 있습니다.

00:07:38.000 --> 00:07:45.000
동적 라이브러리와 마찬가지로, 기능 포인터는 사용자 정의 가능한 파이프라인을 만들 수 있게 해준다.

00:07:45.000 --> 00:07:53.000
함수 포인터를 사용하면, GPU 파이프라인은 파이프라인 컴파일 중에 볼 수 없었던 코드를 호출할 수 있다.

00:07:53.000 --> 00:08:06.000
함수 포인터 테이블을 사용하면 다른 함수 테이블을 바인딩하거나 GPU 파이프라인이 함수 포인터 테이블에 인덱스할 때 코드 실행 동작이 동적으로 변경될 수 있습니다.

00:08:06.000 --> 00:08:13.000
또한 함수 포인터를 사용하여 컴파일 성능과 런타임 성능의 균형을 맞추는 방법을 결정할 수 있습니다.

00:08:13.000 --> 00:08:21.000
예를 들어, 가장 빠른 컴파일을 위해, 함수 포인터를 GPU 바이너리로 미리 컴파일하고 파이프라인을 빠르게 처리할 수 있습니다.

00:08:21.000 --> 00:08:33.000
반면에 최고의 런타임 성능을 위해 파이프라인 참조 AIR 함수 표현을 가질 수 있어 컴파일러가 최대 최적화를 수행할 수 있습니다.

00:08:33.000 --> 00:08:37.000
이제 코드에서 함수 포인터를 어떻게 설정할 수 있는지 봅시다.

00:08:37.000 --> 00:08:40.000
세 가지 기본 빌딩 블록이 있다.

00:08:40.000 --> 00:08:51.000
우리는 함수를 인스턴스화한 다음, 이러한 함수로 파이프라인을 구성하고, 마지막으로 함수 테이블을 만드는 것으로 시작합니다.

00:08:51.000 --> 00:08:57.000
이것이 완료되면, 새로운 렌더링 루프를 사용하는 것은 많은 코드를 포함하지 않는다.

00:08:57.000 --> 00:09:01.000
그래서 각 단계의 세부 사항에 대해 자세히 알아봅시다.

00:09:01.000 --> 00:09:10.000
함수 포인터를 사용하기 위해, 우리는 먼저 함수 설명자를 선언하고 인스턴스화하여 함수의 GPU 바이너리 버전을 컴파일합니다.

00:09:10.000 --> 00:09:19.000
이것은 파이프라인 생성 시간을 가속화할 것이며, 설명자를 선언하고 바이너리로 컴파일하는 옵션을 설정하는 것만큼 간단합니다.

00:09:19.000 --> 00:09:28.000
Metal 함수 foo가 이 설명자를 사용하여 라이브러리에서 생성되면, 함수는 GPU 백엔드 컴파일러에 의해 컴파일됩니다.

00:09:28.000 --> 00:09:33.000
다음으로, 우리는 렌더링 파이프라인 설명자를 구성해야 합니다.

00:09:33.000 --> 00:09:42.000
먼저, 우리는 파이프라인 설명자를 통해 정점, 조각 또는 타일 단계가 될 수 있는 단계에 기능을 추가합니다.

00:09:42.000 --> 00:09:46.000
우리는 AIR 또는 바이너리 형태로 기능을 추가하도록 선택할 수 있습니다.

00:09:46.000 --> 00:09:55.000
AIR 함수를 추가할 때, 컴파일러는 보이는 함수를 정적으로 연결하여 백엔드 컴파일러가 코드를 최적화할 수 있도록 합니다.

00:09:55.000 --> 00:10:04.000
반면에 이진 함수를 추가하면 주어진 파이프라인에서 외부 컴파일된 함수를 호출할 수 있는 드라이버에게 알릴 것이다.

00:10:04.000 --> 00:10:24.000
여기서 주목해야 할 한 가지 추가 사항은 이진 함수를 사용하는 파이프라인을 만들 때 호출하는 코드에 복잡한 호출 체인이 있는 경우, 여기에 설명된 바와 같이, 컴파일러가 깊이를 결정하기 위해 정적 분석을 할 수 없기 때문에 필요한 최대 호출 스택 깊이를 지정하는 것이 중요합니다.

00:10:24.000 --> 00:10:32.000
컴파일러는 실행할 최대 깊이로 기본 설정되며, 깊이가 올바르게 지정되지 않으면 스택 오버플로우가 발생할 수 있습니다.

00:10:32.000 --> 00:10:39.000
대조적으로, 깊이를 올바르게 지정하는 것은 더 나은 자원 개념과 최적의 성능으로 이어진다.

00:10:39.000 --> 00:10:46.000
따라서 설명자가 완전히 설정되면, 함수 포인터를 사용할 준비가 된 파이프라인을 만들 수 있습니다.

00:10:46.000 --> 00:10:55.000
파이프라인을 만든 후, 다음 단계는 눈에 보이는 함수 테이블을 만들고 API의 함수 핸들로 채우는 것입니다.

00:10:55.000 --> 00:11:01.000
먼저, 설명자를 사용하여 보이는 함수 테이블을 만들고 렌더링 단계를 지정합니다.

00:11:01.000 --> 00:11:04.000
그런 다음, 우리는 그 기능을 참조하기 위해 함수 핸들을 만듭니다.

00:11:04.000 --> 00:11:11.000
함수 핸들과 테이블은 모두 주어진 파이프라인과 선택된 단계에 따라 다릅니다.

00:11:11.000 --> 00:11:16.000
그런 다음 setFunction API를 사용하여 핸들을 함수 테이블에 삽입할 수 있습니다.

00:11:16.000 --> 00:11:22.000
이제 우리가 모든 설정을 마친 후에 이 기능 테이블을 어떻게 사용하는지 봅시다.

00:11:22.000 --> 00:11:29.000
먼저, 명령과 코딩의 일환으로, 우리는 보이는 함수 테이블을 버퍼 인덱스에 바인딩합니다.

00:11:29.000 --> 00:11:39.000
셰이더 자체에서, visible_function_table은 버퍼 바인딩으로 전달되며, 이 테이블을 통해 함수를 호출할 수 있습니다.

00:11:39.000 --> 00:11:42.000
그리고 그것은 함수 포인터를 사용하는 간단한 경우였다.

00:11:42.000 --> 00:11:52.000
함수 포인터를 사용할 때, 나중에 하나 이상의 추가 기능에 액세스해야 한다는 것을 알아내기 위해 파이프라인을 만드는 것은 드문 일이 아닙니다.

00:11:52.000 --> 00:12:03.000
이제, 동일한 설명자에서 두 번째 파이프라인을 만들어 그것을 달성할 수 있다면, 추가 기능을 추가하지만 파이프라인 컴파일을 트리거할 수 있습니다.

00:12:03.000 --> 00:12:09.000
이 과정을 가속화하기 위해, Metal을 사용하면 원래 파이프라인을 확장할 계획인지 지정할 수 있습니다.

00:12:09.000 --> 00:12:19.000
이렇게 하면 기존 파이프라인에서 새로운 파이프라인을 더 빠르게 만들 수 있으며, 원래 파이프라인을 위해 처음 생성된 모든 기능 포인터 테이블을 사용할 수 있습니다.

00:12:19.000 --> 00:12:31.000
코드에서 그렇게 하려면, 원래 파이프라인을 만들 때, 확장하고 싶은 모든 단계에 대해 supportAddingBinaryFunctions 옵션을 YES로 설정하세요.

00:12:31.000 --> 00:12:43.000
그런 다음 확장된 파이프라인을 만들어야 할 때, RenderPipelineFunctionDescriptor를 만들고 조각 길이 함수 목록에 새로운 이진 함수 bat()을 포함하세요.

00:12:43.000 --> 00:12:56.000
마지막으로, renderPipeline1에서 추가 바이너리 함수로 새로운 RenderPipelineState를 호출하여 동일하지만 추가 함수 포인터 배트를 포함하는 renderPipeline2를 만듭니다.

00:12:56.000 --> 00:12:58.000
그리고 그게 거의 다야.

00:12:58.000 --> 00:13:03.000
이제 우리는 함수 포인터를 사용하는 방법을 보았으므로, 여기에 그것들을 사용할 수 있는 곳이 있습니다.

00:13:03.000 --> 00:13:11.000
컴퓨팅 파이프라인의 함수 포인터는 Apple GPU 제품군 6 이상, macOS Big Sur 및 iOS 14에서 지원됩니다.

00:13:11.000 --> 00:13:15.000
그들은 또한 Mac 제품군 2 장치에서 지원됩니다.

00:13:15.000 --> 00:13:27.000
그리고 올해, 우리는 Mac OS Monterey 및 iOS 15에서 Apple GPU 제품군 6 이상에서 렌더링 및 타일 파이프라인에 대한 기능 포인터 지원을 확장하고 있습니다.

00:13:27.000 --> 00:13:33.000
내가 이야기하고 싶은 다음 주제는 이진 함수 컴파일 오버헤드를 관리하는 것이다.

00:13:33.000 --> 00:13:41.000
셰이더를 컴파일하는 것은 매우 시간이 많이 걸릴 수 있으며, 애플리케이션에 가져오는 오버헤드를 제어하고 싶을 수도 있습니다.

00:13:41.000 --> 00:13:46.000
그것을 돕기 위해, 우리는 작년에 메탈에 바이너리 아카이브를 추가했다.

00:13:46.000 --> 00:14:00.000
BinaryArchives는 컴파일된 이진 버전의 파이프라인을 수집하고 디스크에 저장하여 컴파일 시간과 후속 실행을 절약하고 컴파일과 관련된 메모리 비용을 줄일 수 있습니다.

00:14:00.000 --> 00:14:10.000
올해, 우리는 바이너리 아카이브에 가시 및 교차 기능을 저장할 수 있는 기능을 추가하여 오버헤드를 크게 줄일 수 있습니다.

00:14:10.000 --> 00:14:15.000
그래서, binaryArchives를 어떻게 저장하고 로드하는지 살펴봅시다.

00:14:15.000 --> 00:14:26.000
BinaryArchive에 함수를 추가하려면, addFunctionWithDescriptor를 호출하고 함수 설명자와 소스 라이브러리를 인수로 전달하기만 하면 됩니다.

00:14:26.000 --> 00:14:39.000
BinaryArchive에서 이진 함수 포인터를 로드하려면, 함수 설명자의 binaryArchives 배열에 BinaryArchive를 배치한 다음, Metal 라이브러리 메소드 newFunctionWithDescriptor를 호출하십시오.

00:14:39.000 --> 00:14:48.000
배열의 아카이브에 컴파일된 함수 포인터가 있다면, 다시 컴파일할 필요 없이 즉시 반환됩니다.

00:14:48.000 --> 00:14:55.000
다음은 newFunctionWithDescriptor가 binaryArchives와 함께 어떻게 작동하는지 보여주는 몇 가지 규칙입니다.

00:14:55.000 --> 00:15:00.000
우리는 먼저 BinaryArchive 목록에서 함수의 이진 버전을 검색합니다.

00:15:00.000 --> 00:15:13.000
함수가 발견되면 반환되며, 발견되지 않으면 CompileToBinary 옵션을 확인하고 이진 컴파일이 요청되지 않은 경우 함수의 AIR 버전을 반환합니다.

00:15:13.000 --> 00:15:29.000
반면에, 바이너리 컴파일이 요청된 경우, 파이프라인 옵션에 따라 FailOnBinaryArchiveMiss는 런타임에 함수 바이너리를 컴파일하거나 nil을 반환합니다.

00:15:29.000 --> 00:15:37.000
MTLBinaryArchive를 애플리케이션에 통합하면, 동일한 아카이브를 사용하여 GPU로 컴파일된 모든 코드를 저장할 수 있습니다.

00:15:37.000 --> 00:15:44.000
렌더링, 타일 및 컴퓨팅 파이프라인과 이진 함수 포인터.

00:15:44.000 --> 00:15:52.000
그리고 아카이브가 파이프라인 상태 객체와 이진 함수로 미리 채워진 후, 디스크로 직렬화할 수 있습니다.

00:15:52.000 --> 00:16:01.000
이런 식으로 GPU 바이너리를 수집하고 저장하면 셰이더 컴파일을 후속 애플리케이션 실행으로 가속화하는 데 도움이 될 것입니다.

00:16:01.000 --> 00:16:09.000
함수 포인터가 있는 파이프라인을 사용할 때, 파이프라인 상태 객체 자체를 캐시하고 싶을 수도 있습니다.

00:16:09.000 --> 00:16:15.000
하지만 다른 기능 포인터 조합과 함께 제공되는 파이프라인이 있는데 왜 캐시해야 하나요?

00:16:15.000 --> 00:16:23.000
예를 들어, 여기에는 사용자 기능 포인터를 제외하고 동일한 세 개의 파이프라인 설명자가 있습니다.

00:16:23.000 --> 00:16:30.000
따라서, AIR 기능 포인터를 사용하는 경우, 파이프라인의 모든 순열을 캐시해야 합니다.

00:16:30.000 --> 00:16:42.000
그러나, 이진 함수 포인터를 사용할 때, 새로운 함수 포인터가 추가될 때 파이프라인 이진 코드가 변경되지 않기 때문에 단일 변형을 캐시하는 것으로 충분합니다.

00:16:42.000 --> 00:16:51.000
그리고 그 아카이브를 사용하여 파이프라인 설명자에 사용되는 이진 함수 포인터와 관계없이 파이프라인의 다른 모든 변형을 찾을 수 있습니다.

00:16:51.000 --> 00:16:59.000
마무리하기 위해, 파이프라인 편집 비용을 제어할 수 있는 훌륭한 도구이기 때문에 항상 binaryArchives in Metal을 사용하고 싶습니다.

00:16:59.000 --> 00:17:10.000
binaryArchives에 대한 지원은 모든 장치에서 사용할 수 있지만, BinaryArchive에 함수 포인터를 추가하는 것은 함수 포인터 능력에 따라 다릅니다.

00:17:10.000 --> 00:17:17.000
이제, 저는 비공개 연결 기능인 올해 우리의 다음 추가에 대해 간략하게 이야기하고 싶습니다.

00:17:17.000 --> 00:17:32.000
지금까지 우리는 동적 라이브러리와 함수 포인터가 셰이더 개발 파이프라인에 많은 유연성을 제공하는 방법에 대해 논의했지만, 때로는 성능상의 이유로 외부 기능을 파이프라인에 정적으로 연결하고 싶을 수도 있습니다.

00:17:32.000 --> 00:17:39.000
작년에, 우리는 AIR 기능을 정적으로 연결하는 것을 지원하는 linkedFunctions API를 추가했습니다.

00:17:39.000 --> 00:17:45.000
그러나, 이것은 함수 테이블에서 사용할 수 있기 때문에 함수 포인터 지원이 필요합니다.

00:17:45.000 --> 00:17:48.000
올해, 우리는 개인 함수를 도입할 것이다.

00:17:48.000 --> 00:18:02.000
함수와 privateFunctions는 모두 AIR 수준에서 정적으로 연결되지만, 비공개이기 때문에 함수 포인터에 대한 함수 처리를 할 수 없으며, 이를 통해 컴파일러가 셰이더 코드를 완전히 최적화할 수 있습니다.

00:18:02.000 --> 00:18:04.000
그래서, 그것들은 어디서 구할 수 있나요?

00:18:04.000 --> 00:18:15.000
이 기능은 AIR 수준의 코드와 함께 작동하기 때문에, macOS Monterey와 iOS 15의 모든 장치에서 사용할 수 있습니다.

00:18:15.000 --> 00:18:21.000
오늘 논의하고 싶은 마지막 추가 사항인 기능 스티칭으로 넘어가세요.

00:18:21.000 --> 00:18:26.000
일부 애플리케이션은 런타임에 동적 콘텐츠를 생성해야 합니다.

00:18:26.000 --> 00:18:32.000
예를 들어, 사용자 입력을 기반으로 그래픽 효과에 대한 사용자 정의를 구현하기 위해.

00:18:32.000 --> 00:18:37.000
또는, 예를 들어, 들어오는 데이터를 기반으로 한 복잡한 컴퓨팅 커널.

00:18:37.000 --> 00:18:41.000
기능 스티칭은 이것을 해결하는 훌륭한 도구이다.

00:18:41.000 --> 00:18:48.000
기능 스티칭 이전에, 이것을 할 수 있는 유일한 방법은 금속 소스 문자열을 생성하는 것이었다.

00:18:48.000 --> 00:18:59.000
문자열 조작 기술은 다소 비효율적일 수 있으며, 금속에서 AIR로의 번역이 런타임에 일어날 것이라는 것을 의미하며, 이는 값비싼 연산이 될 수 있다.

00:18:59.000 --> 00:19:03.000
그래서 기능 스티칭이 어떻게 작동하는지 살펴봅시다.

00:19:03.000 --> 00:19:11.000
함수 스티칭은 런타임에 계산 그래프와 미리 컴파일된 함수에서 함수를 생성하는 메커니즘을 제공한다.

00:19:11.000 --> 00:19:15.000
계산 그래프는 지시된 비순환 그래프이다.

00:19:15.000 --> 00:19:26.000
그리고 그래프에는 두 종류의 노드가 있습니다: 생성된 함수의 인수를 나타내는 입력 노드와 함수 호출을 나타내는 함수 노드.

00:19:26.000 --> 00:19:41.000
또한 두 종류의 에지가 있습니다: 한 노드에서 다른 노드로 데이터가 어떻게 흐르는지를 나타내는 데이터 에지, 그리고 함수 호출이 실행되어야 하는 순서를 나타내는 제어 에지.

00:19:41.000 --> 00:19:47.000
우리는 함수 스티칭이 어떻게 계산 그래프를 사용하여 함수를 생성하는지 볼 것이다.

00:19:47.000 --> 00:19:51.000
우리는 바느질 가능한 기능의 개념으로 시작할 것이다.

00:19:51.000 --> 00:19:54.000
그래프의 함수는 바느질 가능한 속성을 가져야 한다.

00:19:54.000 --> 00:20:00.000
이러한 기능은 functionStitching API와 함께 사용할 수 있는 가시적인 기능입니다.

00:20:00.000 --> 00:20:10.000
바느질 가능한 기능은 Metal to AIR 번역 비용을 피하기 위해 애플리케이션 번들과 함께 배송되는 Metal 라이브러리의 일부가 될 수 있습니다.

00:20:10.000 --> 00:20:18.000
스티칭 공정은 AIR에서 직접 기능을 생성하고 금속 프론트엔드를 완전히 건너뜁니다.

00:20:18.000 --> 00:20:30.000
생성된 함수는 일반 스티칭 가능한 함수이므로 파이프라인에 연결하거나 함수 포인터로 직접 사용하거나 다른 함수를 생성하는 데 사용할 수 있습니다.

00:20:30.000 --> 00:20:39.000
그래서, 이전 그래프를 고려하고, 이전에 설명한 대로 라이브러리의 이중 함수 A와 C가 있다고 가정해 봅시다.

00:20:39.000 --> 00:20:43.000
이제 이 함수들을 그래프에 바인딩할 때 어떤 일이 일어나는지 봅시다.

00:20:43.000 --> 00:20:50.000
여기서 스티처는 각 함수 노드에 해당하는 함수 유형을 연관시킨다.

00:20:50.000 --> 00:20:58.000
N0과 N1은 FunctionA에서 유형을 얻고, N2는 FunctionC에서 유형을 얻는다.

00:20:58.000 --> 00:21:06.000
그 후, 스티처는 그것들을 사용하는 함수의 매개 변수 유형을 보고 입력 노드의 유형을 추론한다.

00:21:06.000 --> 00:21:17.000
예를 들어, Input0은 N0과 N1의 첫 번째 인수이기 때문에 포인터에서 고안된 유형으로 추론된다.

00:21:17.000 --> 00:21:22.000
그런 다음 스티처는 금속에 설명된 것과 동등한 기능을 생성합니다.

00:21:22.000 --> 00:21:29.000
functionStitching API를 사용하면 AIR에서 직접 이러한 기능을 포함하는 라이브러리를 생성할 수 있습니다.

00:21:29.000 --> 00:21:36.000
그리고 이제 우리는 스티칭이 어떻게 작동하는지에 대한 공정한 아이디어를 가지고 있으므로, API에서 사용할 수 있는 방법은 다음과 같습니다.

00:21:36.000 --> 00:21:39.000
먼저, 우리는 바느질된 함수 입력을 정의해야 한다.

00:21:39.000 --> 00:21:45.000
이 경우, 우리는 단순히 모든 인수를 설명하기에 충분한 입력 노드를 만든다.

00:21:45.000 --> 00:21:51.000
다음으로, 우리는 그래프에서 호출하고 싶은 각 함수에 대한 함수 노드를 만듭니다.

00:21:51.000 --> 00:22:00.000
각 함수 호출에 대해 명시적인 주문 요구 사항이 있는 경우 이름, 인수 및 제어 종속성을 정의합니다.

00:22:00.000 --> 00:22:10.000
그리고 마지막으로, 우리는 함수 이름, 그래프에 사용되는 함수 노드, 그리고 우리가 적용하고 싶은 함수 속성으로 그래프를 만듭니다.

00:22:10.000 --> 00:22:17.000
또한 결과 스티치 함수의 출력 값을 반환하는 outputNode를 할당합니다.

00:22:17.000 --> 00:22:19.000
그래서, 우리는 그래프를 가지고 있어.

00:22:19.000 --> 00:22:22.000
이제, 우리는 그것을 사용하여 함수를 만들 수 있다.

00:22:22.000 --> 00:22:26.000
첫 번째 단계는 스티치 라이브러리디스크립터를 만드는 것이다.

00:22:26.000 --> 00:22:32.000
우리는 이 설명자에 stitchableFunctions와 functionGraph를 추가합니다.

00:22:32.000 --> 00:22:39.000
그런 다음 설명자를 사용하여 라이브러리를 만들고, 이제 이 라이브러리에서 스티치 기능을 만들 수 있습니다.

00:22:39.000 --> 00:22:48.000
이 스티칭 기능은 이제 다른 스티칭 그래프의 기능을 포함하여 스티칭 가능한 기능이 예상되는 모든 곳에서 사용할 수 있습니다.

00:22:48.000 --> 00:22:51.000
그리고 그것은 기능 스티칭을 위한 것이다.

00:22:51.000 --> 00:22:58.000
이 API는 macOS Monterey와 iOS 15의 모든 장치에서도 사용할 수 있습니다.

00:22:58.000 --> 00:23:05.000
그래서, 간단히 요약하자면, 오늘, 우리는 렌더링 파이프라인을 위한 동적 라이브러리와 함수 포인터를 살펴보았다.

00:23:05.000 --> 00:23:11.000
눈에 보이는 기능을 정적으로 연결하는 데 사용할 수 있는 개인 연결 기능.

00:23:11.000 --> 00:23:17.000
그리고 함수 스티칭이 동적으로 셰이더를 만들 때 컴파일 시간을 절약할 수 있는 방법.

00:23:17.000 --> 00:23:22.000
그래서, 당신은 언제 다른 쪽보다 하나를 선택할 건가요?

00:23:22.000 --> 00:23:27.000
동적 라이브러리는 도우미와 유틸리티 기능을 연결하는 훌륭한 선택입니다.

00:23:27.000 --> 00:23:35.000
그리고 그것들은 고정된 유틸리티 기능 세트가 있을 때 가장 잘 사용되며, 그 기능들은 자주 바뀌지 않습니다.

00:23:35.000 --> 00:23:43.000
함수 포인터는 셰이더가 서명 외에는 아무것도 모르는 함수를 호출할 수 있는 기능을 추가합니다.

00:23:43.000 --> 00:23:52.000
얼마나 많은 기능이 존재하는지, 이름, 심지어 개발자가 AIR나 바이너리를 사용하여 어떤 속도-유연성 트레이드오프를 만들었는지 알 필요가 없습니다.

00:23:52.000 --> 00:23:56.000
그리고 올해, 당신은 또한 함수 포인터를 캐시할 수 있습니다.

00:23:56.000 --> 00:24:03.000
개인 함수는 이름으로 파이프라인 상태 객체에 함수를 정적으로 연결하는 방법을 제공합니다.

00:24:03.000 --> 00:24:15.000
그것들은 파이프라인 내부에 있으므로, 보이는 함수 테이블에서 인코딩할 수 없지만, 컴파일러가 최대 최적화를 할 수 있게 해주며, 모든 GPU 제품군에서 지원됩니다.

00:24:15.000 --> 00:24:25.000
그리고 마지막으로, 함수 스티칭은 코드 스니펫을 AIR로 직접 미리 컴파일하고 런타임에 함수 컴파일을 수행할 수 있는 방법을 제공합니다.

00:24:25.000 --> 00:24:35.000
오늘 메탈 셰이더 스트링을 합성하고 런타임에 소스에서 컴파일하는 비용을 지불해야 한다면, 기능 스티칭은 이 워크플로우를 크게 가속화할 것입니다.

00:24:35.000 --> 00:24:41.000
이러한 컴파일러 기능을 활용하여 Metal을 사용하여 새로운 경험을 개발할 수 있기를 바랍니다.

00:24:41.000 --> 00:24:46.000
시청해 주셔서 감사드리며, 남은 WWDC 2021을 즐기세요.

00:24:46.000 --> 23:59:59.000
[음악].

