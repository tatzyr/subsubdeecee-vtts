WEBVTT

00:00:01.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:13.000
안녕하세요, 저는 Kavon이고, 나중에 제 동료인 Joe와 합류할 것입니다.

00:00:13.000 --> 00:00:19.000
스위프트 5.5는 구조화된 동시성이라는 개념을 사용하여 동시 프로그램을 작성하는 새로운 방법을 소개합니다.

00:00:19.000 --> 00:00:30.000
구조화된 동시성의 아이디어는 구조화된 프로그래밍을 기반으로 하며, 너무 직관적이어서 거의 생각하지 않지만, 그것에 대해 생각하면 구조화된 동시성을 이해하는 데 도움이 될 것이다.

00:00:30.000 --> 00:00:34.000
그럼 뛰어들자.

00:00:34.000 --> 00:00:43.000
컴퓨팅 초기에, 프로그램은 제어 흐름이 여기저기 뛰어 넘을 수 있는 일련의 지침으로 작성되었기 때문에 읽기 어려웠다.

00:00:43.000 --> 00:00:49.000
오늘날 당신은 그것을 볼 수 없습니다. 왜냐하면 언어는 제어 흐름을 더 균일하게 만들기 위해 구조화된 프로그래밍을 사용하기 때문입니다.

00:00:49.000 --> 00:00:54.000
예를 들어, if-then 문은 구조화된 제어 흐름을 사용한다.

00:00:54.000 --> 00:01:00.000
중첩된 코드 블록은 위에서 아래로 이동하는 동안에만 조건부로 실행되도록 지정합니다.

00:01:00.000 --> 00:01:08.000
스위프트에서, 그 블록은 또한 정적 범위 지정을 존중하며, 이는 이름이 둘러싸는 블록에 정의된 경우에만 볼 수 있다는 것을 의미한다.

00:01:08.000 --> 00:01:15.000
이것은 또한 블록을 떠날 때 블록에 정의된 모든 변수의 수명이 끝날 것이라는 것을 의미합니다.

00:01:15.000 --> 00:01:23.000
그래서, 정적 범위를 가진 구조화된 프로그래밍은 제어 흐름과 가변 수명을 이해하기 쉽게 만든다.

00:01:23.000 --> 00:01:29.000
더 일반적으로, 구조화된 제어 흐름은 자연스럽게 함께 배열되고 중첩될 수 있다.

00:01:29.000 --> 00:01:33.000
이를 통해 전체 프로그램을 위에서 아래로 읽을 수 있습니다.

00:01:33.000 --> 00:01:37.000
그래서, 그것들은 구조화된 프로그래밍의 기초이다.

00:01:37.000 --> 00:01:42.000
당신이 상상할 수 있듯이, 그것은 오늘날 우리에게 매우 직관적이기 때문에 당연하게 여기기 쉽습니다.

00:01:42.000 --> 00:01:51.000
하지만 오늘날의 프로그램은 비동기 및 동시 코드를 특징으로 하며, 그 코드를 더 쉽게 작성할 수 있도록 구조화된 프로그래밍을 사용할 수 없었다.

00:01:51.000 --> 00:01:56.000
먼저, 구조화된 프로그래밍이 어떻게 비동기 코드를 더 간단하게 만드는지 생각해 봅시다.

00:01:56.000 --> 00:02:03.000
인터넷에서 많은 이미지를 가져와서 순차적으로 썸네일로 크기를 조정해야 한다고 말하세요.

00:02:03.000 --> 00:02:09.000
이 코드는 비동기적으로 작동하며, 이미지를 식별하는 문자열 모음을 받아들입니다.

00:02:09.000 --> 00:02:13.000
이 함수가 호출될 때 값을 반환하지 않는다는 것을 알게 될 것입니다.

00:02:13.000 --> 00:02:18.000
그것은 함수가 주어진 완료 핸들러에 결과 또는 오류를 전달하기 때문이다.

00:02:18.000 --> 00:02:23.000
이 패턴은 발신자가 나중에 답변을 받을 수 있게 해준다.

00:02:23.000 --> 00:02:29.000
그 패턴의 결과로, 이 기능은 오류 처리를 위해 구조화된 제어 흐름을 사용할 수 없다.

00:02:29.000 --> 00:02:35.000
그것은 함수가 아닌 함수에서 던져진 오류를 처리하는 것이 합리적이기 때문이다.

00:02:35.000 --> 00:02:39.000
또한, 이 패턴은 각 썸네일을 처리하기 위해 루프를 사용하는 것을 방지합니다.

00:02:39.000 --> 00:02:46.000
함수가 완료된 후 실행되는 코드는 핸들러 내에 중첩되어야 하기 때문에 재귀가 필요합니다.

00:02:46.000 --> 00:02:55.000
이제, 이전 코드를 살펴보고 구조화된 프로그래밍을 기반으로 하는 새로운 비동기/대기 구문을 사용하기 위해 다시 작성해 봅시다.

00:02:55.000 --> 00:02:59.000
나는 함수에서 완료 핸들러 인수를 삭제했다.

00:02:59.000 --> 00:03:04.000
대신, 그것은 유형 서명에 "async"와 "throws"로 주석을 달았다.

00:03:04.000 --> 00:03:07.000
그것은 또한 아무것도 아닌 값을 반환한다.

00:03:07.000 --> 00:03:17.000
함수 본문에서, 나는 비동기 작업이 발생하며, 그 작업 후에 실행되는 코드에는 중첩이 필요하지 않다고 말하기 위해 "await"를 사용한다.

00:03:17.000 --> 00:03:21.000
이것은 내가 이제 썸네일을 반복하여 순차적으로 처리할 수 있다는 것을 의미한다.

00:03:21.000 --> 00:03:27.000
나는 또한 오류를 던지고 잡을 수 있으며, 컴파일러는 내가 잊지 않았는지 확인할 것이다.

00:03:27.000 --> 00:03:40.000
Async/await를 자세히 보려면, "Swift에서 async/await를 만나세요" 세션을 확인하세요. 그래서, 이 코드는 훌륭하지만, 수천 개의 이미지에 대한 썸네일을 생성한다면 어떨까요?

00:03:40.000 --> 00:03:44.000
각 썸네일을 한 번에 하나씩 처리하는 것은 더 이상 이상 이상적이지 않다.

00:03:44.000 --> 00:03:50.000
게다가, 각 썸네일의 크기를 고정된 크기 대신 다른 URL에서 다운로드해야 한다면 어떨까요?

00:03:50.000 --> 00:03:56.000
이제 동시성을 추가할 수 있는 기회가 있으므로, 여러 다운로드가 병렬로 발생할 수 있습니다.

00:03:56.000 --> 00:04:00.000
프로그램에 동시성을 추가하기 위해 추가 작업을 만들 수 있습니다.

00:04:00.000 --> 00:04:05.000
작업은 비동기 기능과 함께 작동하는 Swift의 새로운 기능입니다.

00:04:05.000 --> 00:04:10.000
작업은 비동기 코드를 실행하기 위한 새로운 실행 컨텍스트를 제공한다.

00:04:10.000 --> 00:04:14.000
각 작업은 다른 실행 컨텍스트와 관련하여 동시에 실행됩니다.

00:04:14.000 --> 00:04:20.000
그들은 안전하고 효율적일 때 자동으로 병렬로 실행되도록 예정될 것이다.

00:04:20.000 --> 00:04:26.000
작업이 스위프트에 깊이 통합되어 있기 때문에, 컴파일러는 동시성 버그를 방지하는 데 도움이 될 수 있다.

00:04:26.000 --> 00:04:31.000
또한, 비동기 함수를 호출해도 호출에 대한 새로운 작업이 생성되지 않는다는 것을 명심하세요.

00:04:31.000 --> 00:04:34.000
당신은 명시적으로 작업을 만듭니다.

00:04:34.000 --> 00:04:43.000
스위프트에는 몇 가지 다른 종류의 작업이 있습니다. 왜냐하면 구조화된 동시성은 유연성과 단순성 사이의 균형에 관한 것이기 때문입니다.

00:04:43.000 --> 00:04:51.000
그래서, 이 세션의 나머지 기간 동안, 조와 나는 당신이 그들의 절충안을 이해하는 데 도움이 되도록 각 종류의 작업을 소개하고 논의할 것이다.

00:04:51.000 --> 00:04:58.000
Async-let 바인딩이라고 불리는 새로운 구문 형태로 만들어진 이러한 작업 중 가장 간단한 작업부터 시작합시다.

00:04:58.000 --> 00:05:06.000
당신이 이 새로운 구문 형식을 이해할 수 있도록, 저는 먼저 일반 렛 바인딩의 평가를 나누고 싶습니다.

00:05:06.000 --> 00:05:12.000
두 부분이 있습니다: 등가의 오른쪽에 있는 이니셜라이저 표현식과 왼쪽에 있는 변수의 이름.

00:05:12.000 --> 00:05:18.000
Let 전이나 후에 다른 진술이 있을 수 있으므로, 여기에도 포함시킬 것이다.

00:05:18.000 --> 00:05:24.000
스위프트가 렛 바인딩에 도달하면, 이니셜라이저는 값을 생성하기 위해 평가될 것이다.

00:05:24.000 --> 00:05:30.000
이 예에서, 그것은 URL에서 데이터를 다운로드하는 것을 의미하며, 이는 시간이 걸릴 수 있습니다.

00:05:30.000 --> 00:05:39.000
데이터가 다운로드된 후, 스위프트는 다음 진술로 진행하기 전에 그 값을 변수 이름에 바인딩할 것이다.

00:05:39.000 --> 00:05:45.000
각 단계를 통해 화살표로 추적된 실행의 흐름은 단 하나뿐이라는 점에 유의하십시오.

00:05:45.000 --> 00:05:54.000
다운로드가 시간이 좀 걸릴 수 있기 때문에, 당신은 프로그램이 데이터 다운로드를 시작하고 데이터가 실제로 필요할 때까지 다른 작업을 계속하기를 원합니다.

00:05:54.000 --> 00:05:59.000
이를 달성하기 위해, 기존 let 바인딩 앞에 비동기라는 단어를 추가하기만 하면 됩니다.

00:05:59.000 --> 00:06:04.000
이것은 그것을 async-let이라고 불리는 동시 바인딩으로 바꾼다.

00:06:04.000 --> 00:06:10.000
동시 바인딩의 평가는 순차적인 것과 상당히 다르므로, 그것이 어떻게 작동하는지 알아봅시다.

00:06:10.000 --> 00:06:14.000
나는 바인딩을 만나기 전에 바로 그 지점에서 시작할 것이다.

00:06:14.000 --> 00:06:21.000
동시 바인딩을 평가하기 위해, 스위프트는 먼저 그것을 만든 것의 하위 작업인 새로운 자식 작업을 만들 것이다.

00:06:21.000 --> 00:06:29.000
모든 작업은 프로그램의 실행 컨텍스트를 나타내기 때문에, 이 단계에서 두 개의 화살표가 동시에 나올 것입니다.

00:06:29.000 --> 00:06:34.000
이 첫 번째 화살표는 즉시 데이터 다운로드를 시작하는 자식 작업을 위한 것입니다.

00:06:34.000 --> 00:06:41.000
두 번째 화살표는 부모 작업을 위한 것으로, 변수 결과를 자리 표시자 값에 즉시 바인딩합니다.

00:06:41.000 --> 00:06:46.000
이 부모 작업은 이전 진술을 실행했던 것과 동일합니다.

00:06:46.000 --> 00:06:54.000
데이터가 자식에 의해 동시에 다운로드되는 동안, 부모 작업은 동시 바인딩을 따르는 문을 계속 실행한다.

00:06:54.000 --> 00:07:06.000
하지만 결과의 실제 가치가 필요한 표현에 도달하면, 부모는 결과에 대한 자리 표시자를 이행할 자식 작업의 완료를 기다릴 것이다.

00:07:06.000 --> 00:07:10.000
이 예에서, URLSession에 대한 우리의 호출은 또한 오류를 일으킬 수 있다.

00:07:10.000 --> 00:07:13.000
이것은 결과를 기다리는 것이 우리에게 오류를 줄 수 있다는 것을 의미한다.

00:07:13.000 --> 00:07:17.000
그래서 나는 그것을 처리하기 위해 "시도"를 써야 한다.

00:07:17.000 --> 00:07:18.000
그리고 걱정하지 마.

00:07:18.000 --> 00:07:22.000
결과의 값을 다시 읽는 것은 그 값을 다시 계산하지 않을 것이다.

00:07:22.000 --> 00:07:28.000
이제 async-let이 어떻게 작동하는지 보았으므로, 그것을 사용하여 썸네일 가져오기 코드에 동시성을 추가할 수 있습니다.

00:07:28.000 --> 00:07:33.000
나는 단일 이미지를 자체 기능으로 가져오는 이전 코드의 일부를 인수분해했다.

00:07:33.000 --> 00:07:44.000
이 새로운 기능은 또한 두 개의 다른 URL에서 데이터를 다운로드하고 있습니다: 하나는 전체 크기 이미지 자체를 위한 것이고 다른 하나는 최적의 썸네일 크기를 포함하는 메타데이터를 위한 것입니다.

00:07:44.000 --> 00:07:53.000
순차적 바인딩을 사용하면 let의 오른쪽에 "try await"라고 쓰세요. 왜냐하면 그것이 오류나 정지가 관찰되는 곳이기 때문입니다.

00:07:53.000 --> 00:07:59.000
두 다운로드가 동시에 이루어지도록 하려면, 이 두 가지 모두 앞에 "비동기"를 작성합니다.

00:07:59.000 --> 00:08:06.000
다운로드가 이제 자식 작업에서 일어나고 있기 때문에, 더 이상 동시 바인딩의 오른쪽에 "기다려보기"라고 쓰지 않습니다.

00:08:06.000 --> 00:08:13.000
이러한 효과는 동시에 바인딩된 변수를 사용할 때 부모 작업에 의해서만 관찰됩니다.

00:08:13.000 --> 00:08:19.000
그래서 당신은 표현이 메타데이터와 이미지 데이터를 읽기 전에 "기다려 시도"라고 씁니다.

00:08:19.000 --> 00:08:26.000
또한, 이러한 동시에 바인딩된 변수를 사용하는 것은 메소드 호출이나 다른 변경이 필요하지 않습니다.

00:08:26.000 --> 00:08:31.000
그 변수들은 순차적 바인딩에서 했던 것과 같은 유형을 가지고 있다.

00:08:31.000 --> 00:08:37.000
이제, 내가 말했던 이 자식 작업들은 실제로 작업 트리라고 불리는 계층 구조의 일부이다.

00:08:37.000 --> 00:08:40.000
이 나무는 단순한 구현 세부 사항이 아니다.

00:08:40.000 --> 00:08:43.000
그것은 구조화된 동시성의 중요한 부분이다.

00:08:43.000 --> 00:08:50.000
그것은 취소, 우선 순위 및 작업 지역 변수와 같은 작업의 속성에 영향을 미칩니다.

00:08:50.000 --> 00:08:56.000
한 비동기 함수에서 다른 비동기 함수로 호출할 때마다 동일한 작업이 호출을 실행하는 데 사용됩니다.

00:08:56.000 --> 00:09:01.000
그래서, fetchOneThumbnail 함수는 그 작업의 모든 속성을 상속한다.

00:09:01.000 --> 00:09:09.000
Async-let과 같은 새로운 구조화된 작업을 만들 때, 현재 함수가 실행 중인 작업의 자식이 됩니다.

00:09:09.000 --> 00:09:15.000
작업은 특정 기능의 자식이 아니지만, 그들의 수명은 그것에 범위가 있을 수 있다.

00:09:15.000 --> 00:09:19.000
그 나무는 각 부모와 자식 작업 사이의 링크로 구성되어 있다.

00:09:19.000 --> 00:09:26.000
링크는 부모 작업이 모든 자식 작업이 완료된 경우에만 작업을 완료할 수 있다는 규칙을 시행한다.

00:09:26.000 --> 00:09:33.000
이 규칙은 아동 작업이 기다리는 것을 막을 수 있는 비정상적인 제어 흐름에도 불구하고 적용된다.

00:09:33.000 --> 00:09:40.000
예를 들어, 이 코드에서, 나는 먼저 이미지 데이터 작업 전에 메타데이터 작업을 기다린다.

00:09:40.000 --> 00:09:49.000
처음 기다리던 작업이 오류를 던져서 끝나면, fetchOneThumbnail 함수는 그 오류를 던져서 즉시 종료해야 합니다.

00:09:49.000 --> 00:09:53.000
하지만 두 번째 다운로드를 수행하는 작업은 어떻게 될까요?

00:09:53.000 --> 00:10:03.000
비정상적인 종료 동안, 스위프트는 자동으로 대기 중인 작업을 취소된 것으로 표시한 다음 기능을 종료하기 전에 완료될 때까지 기다립니다.

00:10:03.000 --> 00:10:07.000
작업을 취소된 것으로 표시해도 작업이 중단되지 않습니다.

00:10:07.000 --> 00:10:11.000
그것은 단순히 그 결과가 더 이상 필요하지 않다는 것을 알려준다.

00:10:11.000 --> 00:10:18.000
사실, 작업이 취소되면, 그 작업의 고인인 모든 하위 작업도 자동으로 취소될 것이다.

00:10:18.000 --> 00:10:27.000
따라서 URLSession의 구현이 이미지를 다운로드하기 위해 자체 구조화된 작업을 만들었다면, 해당 작업은 취소로 표시됩니다.

00:10:27.000 --> 00:10:37.000
fetchOneThumbnail 함수는 직접 또는 간접적으로 생성된 모든 구조화된 작업이 완료되면 오류를 발생시켜 마침내 종료됩니다.

00:10:37.000 --> 00:10:40.000
이 보증은 구조화된 동시성의 기본이다.

00:10:40.000 --> 00:10:50.000
ARC가 메모리 수명을 자동으로 관리하는 것처럼 수명을 관리할 수 있도록 도와줌으로써 실수로 작업이 유출되는 것을 방지합니다.

00:10:50.000 --> 00:10:54.000
지금까지, 나는 너에게 취소가 어떻게 전파되는지에 대한 개요를 주었다.

00:10:54.000 --> 00:10:57.000
하지만 그 일은 언제 마침내 멈추나요?

00:10:57.000 --> 00:11:04.000
작업이 중요한 거래의 한가운데에 있거나 네트워크 연결이 열려 있다면, 작업을 중단하는 것은 잘못된 것입니다.

00:11:04.000 --> 00:11:08.000
그것이 스위프트의 작업 취소가 협조적인 이유이다.

00:11:08.000 --> 00:11:15.000
당신의 코드는 취소를 명시적으로 확인하고 적절한 방식으로 실행을 마무리해야 합니다.

00:11:15.000 --> 00:11:21.000
비동기이든 아니든 모든 기능에서 현재 작업의 취소 상태를 확인할 수 있습니다.

00:11:21.000 --> 00:11:29.000
이것은 특히 장기간 실행되는 계산을 포함하는 경우 취소를 염두에 두고 API를 구현해야 한다는 것을 의미합니다.

00:11:29.000 --> 00:11:38.000
사용자는 취소할 수 있는 작업에서 코드를 호출할 수 있으며, 계산이 가능한 한 빨리 중단될 것으로 예상할 것입니다.

00:11:38.000 --> 00:11:45.000
협동 취소를 사용하는 것이 얼마나 간단한지 보려면, 썸네일 가져오기 예로 돌아가 봅시다.

00:11:45.000 --> 00:11:53.000
여기서, 저는 가져오기 위해 모든 썸네일이 주어진 원래 함수를 다시 작성하여 대신 fetchOneThumbnail 함수를 사용합니다.

00:11:53.000 --> 00:12:02.000
이 함수가 취소된 작업 내에서 호출되었다면, 우리는 쓸모없는 썸네일을 만들어 애플리케이션을 보류하고 싶지 않습니다.

00:12:02.000 --> 00:12:07.000
그래서 나는 각 루프 반복의 시작 부분에 checkCancellation에 대한 호출을 추가할 수 있다.

00:12:07.000 --> 00:12:12.000
이 호출은 현재 작업이 취소된 경우에만 오류를 발생시킨다.

00:12:12.000 --> 00:12:19.000
코드에 더 적합한 경우 현재 작업의 취소 상태를 부울 값으로 얻을 수도 있습니다.

00:12:19.000 --> 00:12:27.000
이 버전의 기능에서, 저는 부분적인 결과, 요청된 썸네일 중 일부만 있는 사전을 반환하고 있습니다.

00:12:27.000 --> 00:12:34.000
이렇게 할 때, API가 부분적인 결과가 반환될 수 있다고 명확하게 명시해야 합니다.

00:12:34.000 --> 00:12:43.000
그렇지 않으면, 작업 취소는 취소 중에도 완전한 결과가 필요하기 때문에 사용자에게 치명적인 오류를 유발할 수 있습니다.

00:12:43.000 --> 00:12:52.000
지금까지, 당신은 async-let이 구조화된 프로그래밍의 본질을 포착하면서 프로그램에 동시성을 추가하기 위한 가벼운 구문을 제공한다는 것을 보았습니다.

00:12:52.000 --> 00:12:56.000
내가 너에게 말하고 싶은 다음 종류의 과제는 그룹 과제라고 불린다.

00:12:56.000 --> 00:13:03.000
그들은 구조화된 동시성의 모든 좋은 특성을 포기하지 않고 async-let보다 더 많은 유연성을 제공한다.

00:13:03.000 --> 00:13:08.000
앞서 보았듯이, async-let은 고정된 양의 동시성이 있을 때 잘 작동합니다.

00:13:08.000 --> 00:13:11.000
앞서 논의한 두 기능을 모두 고려해 봅시다.

00:13:11.000 --> 00:13:19.000
루프의 각 썸네일 ID에 대해, 우리는 그것을 처리하기 위해 fetchOneThumbnail을 호출하여 정확히 두 개의 자식 작업을 생성합니다.

00:13:19.000 --> 00:13:26.000
우리가 그 기능의 본문을 이 루프에 인라인화하더라도, 동시성의 양은 변하지 않을 것이다.

00:13:26.000 --> 00:13:28.000
Async-let은 변수 바인딩처럼 범위가 지정됩니다.

00:13:28.000 --> 00:13:34.000
그것은 다음 루프 반복이 시작되기 전에 두 개의 자식 작업이 완료되어야 한다는 것을 의미합니다.

00:13:34.000 --> 00:13:41.000
하지만 이 루프가 모든 썸네일을 동시에 가져오는 작업을 시작하기를 원한다면 어떨까요?

00:13:41.000 --> 00:13:48.000
그런 다음, 동시성의 양은 배열의 ID 수에 따라 다르기 때문에 정적으로 알려지지 않습니다.

00:13:48.000 --> 00:13:51.000
이 상황에 적합한 도구는 작업 그룹이다.

00:13:51.000 --> 00:13:56.000
작업 그룹은 역동적인 양의 동시성을 제공하도록 설계된 구조화된 동시성의 한 형태이다.

00:13:56.000 --> 00:14:01.000
withThrowingTaskGroup 함수를 호출하여 작업 그룹을 소개할 수 있습니다.

00:14:01.000 --> 00:14:08.000
이 함수는 오류를 던질 수 있는 자식 작업을 만들 수 있는 범위 그룹 객체를 제공합니다.

00:14:08.000 --> 00:14:14.000
그룹에 추가된 작업은 그룹이 정의된 블록의 범위를 능가할 수 없습니다.

00:14:14.000 --> 00:14:21.000
전체 for-loop를 블록 안에 배치했기 때문에, 이제 그룹을 사용하여 동적 수의 작업을 만들 수 있습니다.

00:14:21.000 --> 00:14:25.000
비동기 메서드를 호출하여 그룹에서 자식 작업을 만듭니다.

00:14:25.000 --> 00:14:31.000
일단 그룹에 추가되면, 자식 작업은 어떤 순서로든 즉시 실행되기 시작합니다.

00:14:31.000 --> 00:14:37.000
그룹 객체가 범위를 벗어나면, 그 안에 있는 모든 작업의 완료를 암시적으로 기다릴 것이다.

00:14:37.000 --> 00:14:44.000
이것은 내가 앞서 설명한 작업 트리 규칙의 결과이다. 왜냐하면 그룹 작업도 구조화되어 있기 때문이다.

00:14:44.000 --> 00:14:55.000
이 시점에서, 우리는 이미 우리가 원했던 동시성을 달성했습니다: fetchOneThumbnail에 대한 각 호출에 대해 하나의 작업, 그 자체로 async-let을 사용하여 두 개의 작업을 더 생성합니다.

00:14:55.000 --> 00:14:58.000
그것은 구조화된 동시성의 또 다른 좋은 속성이다.

00:14:58.000 --> 00:15:08.000
그룹 작업 내에서 async-let을 사용하거나 async-let 작업 내에서 작업 그룹을 만들 수 있으며, 트리의 동시성 수준은 자연스럽게 구성됩니다.

00:15:08.000 --> 00:15:11.000
이제, 이 코드는 실행할 준비가 되지 않았다.

00:15:11.000 --> 00:15:16.000
만약 우리가 그것을 실행하려고 한다면, 컴파일러는 우리에게 데이터 경쟁 문제에 대해 유용하게 경고할 것이다.

00:15:16.000 --> 00:15:21.000
문제는 우리가 각 자식 작업에서 단일 사전에 썸네일을 삽입하려고 한다는 것이다.

00:15:21.000 --> 00:15:25.000
이것은 프로그램에서 동시성의 양을 늘릴 때 흔한 실수입니다.

00:15:25.000 --> 00:15:28.000
데이터 경쟁은 실수로 생성된다.

00:15:28.000 --> 00:15:39.000
이 사전은 한 번에 하나 이상의 액세스를 처리할 수 없으며, 두 개의 자식 작업이 썸네일을 동시에 삽입하려고 하면 충돌이나 데이터 손상이 발생할 수 있습니다.

00:15:39.000 --> 00:15:47.000
과거에는 그 버그를 직접 조사해야 했지만, 스위프트는 애초에 그 버그가 발생하지 않도록 정적 검사를 제공합니다.

00:15:47.000 --> 00:15:55.000
새 작업을 만들 때마다, 작업이 수행하는 작업은 @Sendable 클로저라고 불리는 새로운 클로저 유형 내에 있습니다.

00:15:55.000 --> 00:16:05.000
@Sendable 클로저의 본문은 작업이 시작된 후 변수가 수정될 수 있기 때문에 어휘 컨텍스트에서 가변 변수를 캡처하는 것이 제한됩니다.

00:16:05.000 --> 00:16:09.000
이것은 당신이 작업에서 포착한 가치가 공유하기에 안전해야 한다는 것을 의미합니다.

00:16:09.000 --> 00:16:22.000
예를 들어, 그것들은 Int와 String과 같은 값 유형이거나, 액터와 같은 여러 스레드에서 액세스하도록 설계된 객체와 자체 동기화를 구현하는 클래스이기 때문입니다.

00:16:22.000 --> 00:16:30.000
우리는 "스위프트 배우와 함께 가변 상태 보호"라고 불리는 이 주제에 전념하는 전체 세션이 있으므로, 확인해 보시기 바랍니다.

00:16:30.000 --> 00:16:35.000
예제의 데이터 경쟁을 피하기 위해, 각 자식 작업이 값을 반환하도록 할 수 있습니다.

00:16:35.000 --> 00:16:40.000
이 디자인은 부모 작업에 결과를 처리하는 전적인 책임을 부여한다.

00:16:40.000 --> 00:16:49.000
이 경우, 각 자식 작업은 썸네일의 문자열 ID와 UIImage를 포함하는 튜플을 반환해야 한다고 지정했습니다.

00:16:49.000 --> 00:16:58.000
그런 다음, 각 자식 작업 내에서, 사전에 직접 쓰는 대신, 부모가 처리할 키 값 튜플을 반환하도록 합니다.

00:16:58.000 --> 00:17:04.000
부모 작업은 새로운 대기 루프를 사용하여 각 자식 작업의 결과를 반복할 수 있습니다.

00:17:04.000 --> 00:17:09.000
For-await 루프는 완료 순서대로 자식 작업의 결과를 얻습니다.

00:17:09.000 --> 00:17:17.000
이 루프는 순차적으로 실행되기 때문에, 부모 작업은 각 키 값 쌍을 사전에 안전하게 추가할 수 있습니다.

00:17:17.000 --> 00:17:23.000
이것은 for-await 루프를 사용하여 비동기 값 시퀀스에 액세스하는 한 가지 예일 뿐입니다.

00:17:23.000 --> 00:17:30.000
자신의 유형이 AsyncSequence 프로토콜을 준수한다면, for-await를 사용하여 반복할 수도 있습니다.

00:17:30.000 --> 00:17:34.000
"Meet AsyncSequence" 세션에서 더 많은 것을 찾을 수 있습니다.

00:17:34.000 --> 00:17:43.000
작업 그룹은 구조화된 동시성의 한 형태이지만, 그룹 작업과 비동기 렛 작업에 대해 작업 트리 규칙이 구현되는 방식에는 약간의 차이가 있다.

00:17:43.000 --> 00:17:50.000
이 그룹의 결과를 반복할 때, 오류로 완료된 자식 작업이 발생한다고 가정해 봅시다.

00:17:50.000 --> 00:17:57.000
그 오류가 그룹의 블록에서 던져지기 때문에, 그룹의 모든 작업은 암시적으로 취소된 다음 기다릴 것이다.

00:17:57.000 --> 00:17:59.000
이것은 async-let처럼 작동한다.

00:17:59.000 --> 00:18:05.000
차이점은 당신의 그룹이 블록에서 정상적인 출구를 통해 범위를 벗어날 때 옵니다.

00:18:05.000 --> 00:18:08.000
그렇다면, 취소는 암묵적이지 않다.

00:18:08.000 --> 00:18:17.000
이 동작을 사용하면 작업이 취소되지 않고 기다리기만 하기 때문에 작업 그룹을 사용하여 포크 조인 패턴을 더 쉽게 표현할 수 있습니다.

00:18:17.000 --> 00:18:24.000
그룹의 cancelAll 메소드를 사용하여 블록을 종료하기 전에 모든 작업을 수동으로 취소할 수도 있습니다.

00:18:24.000 --> 00:18:31.000
작업을 어떻게 취소하든, 취소는 자동으로 나무 아래로 전파된다는 것을 명심하세요.

00:18:31.000 --> 00:18:37.000
Async-let 및 그룹 작업은 Swift에서 범위가 지정된 구조화된 작업을 제공하는 두 종류의 작업입니다.

00:18:37.000 --> 00:18:42.000
이제, 나는 조에게 일을 넘길 거야, 그는 너에게 구조화되지 않은 일에 대해 말해줄 거야.

00:18:42.000 --> 00:18:43.000
고마워, 카본.

00:18:43.000 --> 00:18:45.000
안녕. 난 조야.

00:18:45.000 --> 00:18:55.000
Kavon은 작업에 명확한 계층 구조를 가진 프로그램에 동시성을 추가할 때 구조화된 동시성이 오류 전파, 취소 및 기타 부기를 어떻게 단순화하는지 보여주었습니다.

00:18:55.000 --> 00:19:00.000
하지만 우리는 당신이 프로그램에 작업을 추가할 때 항상 계층 구조를 가지고 있지 않다는 것을 알고 있습니다.

00:19:00.000 --> 00:19:08.000
스위프트는 또한 구조화되지 않은 작업 API를 제공하여 더 많은 수동 관리가 필요한 비용으로 훨씬 더 많은 유연성을 제공합니다.

00:19:08.000 --> 00:19:13.000
작업이 명확한 계층 구조에 속하지 않을 수 있는 많은 상황이 있다.

00:19:13.000 --> 00:19:21.000
가장 분명히, 비동기 코드에서 비동기 계산을 수행하기 위해 작업을 시작하려고 한다면 부모 작업이 전혀 없을 수도 있습니다.

00:19:21.000 --> 00:19:28.000
또는, 작업에 원하는 수명은 단일 범위 또는 단일 기능의 한계에 맞지 않을 수 있습니다.

00:19:28.000 --> 00:19:40.000
예를 들어, 객체를 활성 상태로 전환하는 메서드 호출에 대한 응답으로 작업을 시작한 다음 객체를 비활성화하는 다른 메서드 호출에 대한 응답으로 실행을 취소할 수 있습니다.

00:19:40.000 --> 00:19:45.000
이것은 AppKit과 UIKit에서 위임 객체를 구현할 때 많이 나타난다.

00:19:45.000 --> 00:19:57.000
UI 작업은 메인 스레드에서 이루어져야 하며, 스위프트 액터 세션이 논의함에 따라, 스위프트는 메인 액터에 속하는 UI 클래스를 선언함으로써 이를 보장합니다.

00:19:57.000 --> 00:20:02.000
컬렉션 뷰가 있고, 아직 컬렉션 뷰 데이터 소스 API를 사용할 수 없다고 가정해 봅시다.

00:20:02.000 --> 00:20:10.000
대신, 우리는 컬렉션 보기의 항목이 표시될 때 네트워크에서 썸네일을 가져오기 위해 방금 작성한 fetchThumbnails 기능을 사용하고 싶습니다.

00:20:10.000 --> 00:20:16.000
그러나, 위임 방법은 비동기가 아니므로, 우리는 비동기 함수에 대한 호출을 기다릴 수 없습니다.

00:20:16.000 --> 00:20:23.000
우리는 그것을 위한 작업을 시작해야 하지만, 그 작업은 실제로 우리가 위임 조치에 대한 응답으로 시작한 작업의 연장이다.

00:20:23.000 --> 00:20:28.000
우리는 이 새로운 작업이 여전히 UI 우선 순위를 가진 주요 배우에서 실행되기를 바랍니다.

00:20:28.000 --> 00:20:33.000
우리는 작업의 수명을 이 단일 위임 방법의 범위에 묶고 싶지 않습니다.

00:20:33.000 --> 00:20:38.000
이와 같은 상황에서, 스위프트는 우리가 구조화되지 않은 작업을 구성할 수 있게 해준다.

00:20:38.000 --> 00:20:46.000
코드의 비동기 부분을 클로저로 옮기고 그 클로저를 전달하여 비동기 작업을 구성합시다.

00:20:46.000 --> 00:20:48.000
이제 런타임에 일어나는 일은 다음과 같습니다.

00:20:48.000 --> 00:20:56.000
우리가 작업을 만드는 지점에 도달하면, 스위프트는 이 경우 주요 배우인 원래 범위와 동일한 배우에서 실행되도록 일정을 잡을 것이다.

00:20:56.000 --> 00:21:00.000
한편, 컨트롤은 즉시 발신자에게 돌아간다.

00:21:00.000 --> 00:21:07.000
썸네일 작업은 위임 방법의 메인 스레드를 즉시 차단하지 않고 그렇게 할 수 있는 구멍이 있을 때 메인 스레드에서 실행됩니다.

00:21:07.000 --> 00:21:13.000
이런 식으로 작업을 구성하는 것은 우리에게 구조화된 코드와 구조화되지 않은 코드 사이의 중간 지점을 제공한다.

00:21:13.000 --> 00:21:25.000
직접 구성된 작업은 여전히 실행된 컨텍스트의 액터(가 있다면)를 상속하며, 그룹 작업이나 async-let과 마찬가지로 원본 작업의 우선 순위와 다른 특성을 상속합니다.

00:21:25.000 --> 00:21:27.000
그러나, 새로운 작업은 범위가 없다.

00:21:27.000 --> 00:21:31.000
그것의 수명은 그것이 발사된 곳의 범위에 구속되지 않는다.

00:21:31.000 --> 00:21:34.000
기원은 비동기적일 필요조차 없다.

00:21:34.000 --> 00:21:37.000
우리는 어디에서나 범위가 없는 작업을 만들 수 있다.

00:21:37.000 --> 00:21:44.000
이 모든 유연성을 위한 거래에서, 우리는 또한 구조화된 동시성이 자동으로 처리했을 것들을 수동으로 관리해야 한다.

00:21:44.000 --> 00:21:55.000
취소와 오류는 자동으로 전파되지 않으며, 우리가 명시적인 조치를 취하지 않는 한 작업의 결과는 암시적으로 기다리지 않을 것입니다.

00:21:55.000 --> 00:22:06.000
그래서 우리는 컬렉션 보기 항목이 표시될 때 썸네일을 가져오는 작업을 시작했고, 썸네일이 준비되기 전에 항목이 시야에서 스크롤되면 해당 작업을 취소해야 합니다.

00:22:06.000 --> 00:22:10.000
우리가 범위가 없는 작업으로 작업하고 있기 때문에, 그 취소는 자동이 아니다.

00:22:10.000 --> 00:22:12.000
지금 실행하자.

00:22:12.000 --> 00:22:16.000
우리가 작업을 구성한 후, 우리가 얻은 가치를 저장합시다.

00:22:16.000 --> 00:22:25.000
나중에 해당 작업을 취소하는 데 사용할 수 있도록 작업을 만들 때 이 값을 행 인덱스에 의해 키된 사전에 넣을 수 있습니다.

00:22:25.000 --> 00:22:31.000
우리는 또한 작업이 완료되면 사전에서 제거해야 합니다. 그래서 이미 완료된 경우 작업을 취소하려고 하지 않습니다.

00:22:31.000 --> 00:22:39.000
컴파일러에 의해 플래그가 지정된 데이터 레이스를 받지 않고도 비동기 작업 안팎에서 동일한 사전에 액세스할 수 있습니다.

00:22:39.000 --> 00:22:46.000
우리의 대표 클래스는 주요 배우에게 묶여 있으며, 새로운 작업은 그것을 상속하므로, 그들은 결코 함께 병렬로 실행되지 않을 것이다.

00:22:46.000 --> 00:22:54.000
우리는 데이터 경쟁에 대한 걱정 없이 이 작업 내에서 주요 액터 바인딩 클래스의 저장된 속성에 안전하게 접근할 수 있습니다.

00:22:54.000 --> 00:23:04.000
한편, 우리의 대리인이 나중에 동일한 테이블 행이 디스플레이에서 제거되었다는 말을 듣는다면, 우리는 작업을 취소하기 위해 값에 대한 취소 방법을 호출할 수 있습니다.

00:23:04.000 --> 00:23:12.000
그래서 이제 우리는 그 작업의 원래 컨텍스트에서 특성을 상속하면서 범위와 독립적으로 실행되는 구조화되지 않은 작업을 어떻게 만들 수 있는지 보았습니다.

00:23:12.000 --> 00:23:17.000
하지만 때때로 당신은 당신의 원래 맥락에서 아무것도 상속받고 싶지 않습니다.

00:23:17.000 --> 00:23:22.000
최대의 유연성을 위해, 스위프트는 분리된 작업을 제공한다.

00:23:22.000 --> 00:23:27.000
이름에서 알 수 있듯이, 분리된 작업은 그들의 맥락과 독립적이다.

00:23:27.000 --> 00:23:28.000
그것들은 여전히 구조화되지 않은 작업이다.

00:23:28.000 --> 00:23:32.000
그들의 일생은 그들의 원래 범위에 묶여 있지 않다.

00:23:32.000 --> 00:23:36.000
하지만 분리된 작업은 원래 범위에서 다른 어떤 것도 선택하지 않는다.

00:23:36.000 --> 00:23:43.000
기본적으로, 그들은 같은 배우로 제한되지 않으며 그들이 출시된 곳과 같은 우선 순위로 달릴 필요가 없다.

00:23:43.000 --> 00:23:55.000
분리된 작업은 우선 순위와 같은 일반적인 기본값으로 독립적으로 실행되지만, 새로운 작업이 어떻게 그리고 어디서 실행되는지 제어하기 위해 선택적 매개 변수로 시작할 수도 있습니다.

00:23:55.000 --> 00:24:04.000
서버에서 썸네일을 가져온 후, 나중에 가져오려고 하면 네트워크에 다시 충돌하지 않도록 로컬 디스크 캐시에 쓰고 싶다고 가정해 봅시다.

00:24:04.000 --> 00:24:14.000
캐싱은 메인 액터에서 발생할 필요가 없으며, 모든 썸네일 가져오기를 취소하더라도, 우리가 가져온 썸네일을 캐시하는 것은 여전히 도움이 됩니다.

00:24:14.000 --> 00:24:17.000
그러니 분리된 작업을 사용하여 캐싱을 시작합시다.

00:24:17.000 --> 00:24:23.000
우리가 작업을 분리할 때, 우리는 또한 새로운 작업이 어떻게 실행되는지 설정하는 데 훨씬 더 많은 유연성을 얻는다.

00:24:23.000 --> 00:24:33.000
캐싱은 메인 UI를 방해하지 않는 낮은 우선 순위에서 발생해야 하며, 이 새로운 작업을 분리할 때 백그라운드 우선 순위를 지정할 수 있습니다.

00:24:33.000 --> 00:24:35.000
이제 잠시 미리 계획을 세우자.

00:24:35.000 --> 00:24:41.000
썸네일에서 수행하고 싶은 백그라운드 작업이 여러 개 있다면 앞으로 어떻게 해야 할까요?

00:24:41.000 --> 00:24:48.000
우리는 더 많은 백그라운드 작업을 분리할 수 있지만, 분리된 작업 내에서 구조화된 동시성을 활용할 수도 있다.

00:24:48.000 --> 00:24:55.000
우리는 각각의 강점을 활용하기 위해 모든 종류의 작업을 함께 결합할 수 있다.

00:24:55.000 --> 00:25:05.000
모든 백그라운드 작업에 대한 독립적인 작업을 분리하는 대신, 작업 그룹을 설정하고 각 백그라운드 작업을 하위 작업으로 해당 그룹으로 생성할 수 있습니다.

00:25:05.000 --> 00:25:08.000
그렇게 하면 많은 이점이 있다.

00:25:08.000 --> 00:25:17.000
향후 백그라운드 작업을 취소해야 하는 경우, 작업 그룹을 사용하면 최상위 분리된 작업을 취소하는 것만으로 모든 하위 작업을 취소할 수 있습니다.

00:25:17.000 --> 00:25:23.000
그 취소는 자동으로 자식 작업으로 전파될 것이며, 우리는 핸들 배열을 추적할 필요가 없습니다.

00:25:23.000 --> 00:25:28.000
게다가, 자녀 작업은 자동으로 부모의 우선 순위를 상속한다.

00:25:28.000 --> 00:25:44.000
이 모든 작업을 백그라운드에서 유지하려면, 분리된 작업을 백그라운드하기만 하면 되며, 이는 모든 하위 작업으로 자동으로 전파되므로, 전이적으로 백그라운드 우선 순위를 설정하는 것을 잊어버리고 실수로 UI 작업을 굶주리는 것에 대해 걱정할 필요가 없습니다.

00:25:44.000 --> 00:25:48.000
이 시점에서, 우리는 Swift에 있는 모든 주요 형태의 작업을 보았다.

00:25:48.000 --> 00:25:59.000
Async-let을 사용하면 고정된 수의 자식 작업을 가변 바인딩으로 생성할 수 있으며, 바인딩이 범위를 벗어나면 취소 및 오류 전파를 자동으로 관리할 수 있습니다.

00:25:59.000 --> 00:26:07.000
여전히 범위에 묶여 있는 동적 수의 하위 작업이 필요할 때, 우리는 작업 그룹으로 이동할 수 있습니다.

00:26:07.000 --> 00:26:18.000
범위가 잘 되어 있지 않지만 여전히 원래 작업과 관련된 작업을 중단해야 한다면, 구조화되지 않은 작업을 구성할 수 있지만 수동으로 관리해야 합니다.

00:26:18.000 --> 00:26:28.000
그리고 최대한의 유연성을 위해, 우리는 또한 출처에서 아무것도 상속받지 않는 수동으로 관리되는 작업인 분리된 작업을 가지고 있습니다.

00:26:28.000 --> 00:26:33.000
작업과 구조화된 동시성은 스위프트가 지원하는 동시성 기능의 한 부분일 뿐입니다.

00:26:33.000 --> 00:26:37.000
다른 모든 훌륭한 강연을 확인하여 나머지 언어와 어떻게 어울리는지 확인해 보세요.

00:26:37.000 --> 00:26:46.000
"Meet async/await in Swift"는 비동기 함수에 대한 자세한 정보를 제공하며, 이는 동시 코드를 작성하기 위한 구조화된 기반을 제공합니다.

00:26:46.000 --> 00:26:52.000
배우들은 데이터 경쟁으로부터 안전한 동시 시스템을 만들기 위해 데이터 격리를 제공한다.

00:26:52.000 --> 00:26:57.000
방법에 대해 자세히 알아보려면 "스위프트 배우로 변경 가능한 상태 보호" 세션을 참조하십시오.

00:26:57.000 --> 00:27:07.000
우리는 작업 그룹에서 "for await" 루프를 보았고, 이는 비동기 데이터 스트림으로 작업하기 위한 표준 인터페이스를 제공하는 AsyncSequence의 한 예일 뿐입니다.

00:27:07.000 --> 00:27:13.000
"Meet AsyncSequence" 세션은 시퀀스 작업을 위해 사용 가능한 API에 더 깊이 들어간다.

00:27:13.000 --> 00:27:25.000
작업은 낮은 오버헤드와 높은 확장성을 달성하기 위해 핵심 OS와 통합되며, "Swift concurrency: Behind the scenes" 세션은 그것이 어떻게 달성되는지에 대한 더 많은 기술적 세부 사항을 제공합니다.

00:27:25.000 --> 00:27:42.000
이러한 모든 기능은 스위프트에서 동시 코드를 쉽고 안전하게 작성하기 위해 함께 제공되며, 앱의 흥미로운 부분에 집중하면서 장치를 최대한 활용하는 코드를 작성할 수 있으며, 동시 작업 관리 메커니즘이나 멀티스레딩으로 인한 잠재적인 버그에 대한 걱정에 대해 덜 생각할 수 있습니다.

00:27:42.000 --> 00:27:44.000
봐줘서 고마워.

00:27:44.000 --> 00:27:46.000
나는 네가 남은 컨퍼런스를 즐기길 바라.

00:27:46.000 --> 23:59:59.000
[쾌활한 음악].

