WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:11.000
안녕하세요, 여러분.

00:00:11.000 --> 00:00:12.000
저는 Core Data 팀의 Michael LeHew입니다.

00:00:12.000 --> 00:00:22.000
그리고 오늘, 저는 Core Data와 Swift로 작업하는 것을 정말 훌륭한 경험으로 만들기 위해 팀이 만든 몇 가지 개선 사항에 대해 이야기하게 되어 정말 기쁩니다.

00:00:22.000 --> 00:00:30.000
저는 Core Data가 모든 Apple 플랫폼에서 고객의 데이터 지속성 요구를 위한 훌륭한 솔루션이라는 것을 검토하는 것으로 시작하겠습니다.

00:00:30.000 --> 00:00:38.000
그런 다음 Core Data가 Swift 런타임에서 새로운 동시성 기회를 채택한 몇 가지 방법에 대한 논의를 진행하겠습니다.

00:00:38.000 --> 00:00:45.000
다음으로, Swift에서 코드를 더 표현하기 위해 Core Data API에 대한 몇 가지 개선 사항을 다루겠습니다.

00:00:45.000 --> 00:00:55.000
그런 다음 Core Data가 2020년에 도입한 기존 SwiftUI 지원에 추가하고 있는 동적 기능에 대한 탐구로 토론을 마무리하세요.

00:00:55.000 --> 00:01:03.000
하지만, 당신이 어떤 Apple 플랫폼을 개발하고 있든, 당신은 단순히 응용 프로그램을 가지고 있는 처음부터 시작합시다.

00:01:03.000 --> 00:01:10.000
어느 시점에서, 당신의 애플리케이션은 결국 사용자 데이터를 접하게 될 것이며, 당신은 그것을 어딘가에 저장해야 할 것입니다.

00:01:10.000 --> 00:01:14.000
그 필요를 위한 훌륭한 선택은 핵심 데이터를 사용하는 것이다.

00:01:14.000 --> 00:01:23.000
Core Data는 강력하고 기능이 풍부한 방식으로 사용자의 데이터를 유지하려는 애플리케이션 개발자를 위한 Apple의 특징적인 프레임워크입니다.

00:01:23.000 --> 00:01:34.000
이 프레임워크는 메모리의 객체 그래프로 표현되는 방식부터 스토리지에서 모델링되는 방식에 이르기까지 사용자 데이터를 적절하게 관리하는 많은 복잡성을 처리합니다.

00:01:34.000 --> 00:01:41.000
이 프레임워크는 또한 메모리 사용 및 대기 시간과 같은 중요한 런타임 고려 사항을 관리하기 위해 많은 노력을 기울입니다.

00:01:41.000 --> 00:01:44.000
프레임워크가 제공하는 기능도 확장 가능하다.

00:01:44.000 --> 00:01:56.000
간단하고 로컬로 지속된 저장소로 시작하여 여러 실행 컨텍스트를 사용하여 성능을 개선하고 CloudKit을 통해 강력한 공유 데이터 경험을 만들 수 있습니다.

00:01:56.000 --> 00:02:00.000
핵심 데이터는 또한 Apple이 지원하는 모든 플랫폼에서 작동합니다.

00:02:00.000 --> 00:02:03.000
그리고 저는 이 마지막 요점을 정말 강조하고 싶습니다.

00:02:03.000 --> 00:02:13.000
코어 데이터를 사용하기 시작하면, 배운 모든 것은 Mac에서 iPhone 또는 Apple Watch에 이르기까지 각 플랫폼에서 작동합니다.

00:02:13.000 --> 00:02:17.000
그리고, 물론, 코어 데이터는 스위프트에서도 잘 작동한다.

00:02:17.000 --> 00:02:25.000
지난 몇 년 동안, 우리는 Swift에서 가능한 한 표현하기 위해 Core Data API를 지속적으로 개선해 왔습니다.

00:02:25.000 --> 00:02:33.000
그리고 올해는 언어와 런타임에 완전히 새로운 동시성 기능이 도입된 스위프트에게 꽤 흥미로운 해입니다.

00:02:33.000 --> 00:02:41.000
처음부터, Core Data는 항상 코드를 동시에 실행하는 것에 신경을 겨왔고, 여기에는 정말 좋은 이유가 있다.

00:02:41.000 --> 00:02:50.000
지속적인 데이터는 일부 외부 저장 매체에 읽고 쓰는 것을 필요로 하며, 이는 새로운 동시성 모델을 지원하는 것을 자연스럽게 만든다.

00:02:50.000 --> 00:02:56.000
지진 샘플 응용 프로그램의 맥락에서 이것이 어떻게 작동하는지 살펴봅시다.

00:02:56.000 --> 00:03:09.000
이 응용 프로그램은 미국 지질조사국의 데이터 피드를 읽고 핵심 데이터를 사용하여 규모, 위치 및 사건이 발생한 날짜와 같은 최근 지진에 대한 정보를 저장합니다.

00:03:09.000 --> 00:03:19.000
건축학적으로, 지진은 UI를 구동하기 위한 뷰 컨텍스트와 USGS가 제공하는 데이터를 수집하기 위한 배경 컨텍스트가 있는 스위프트 애플리케이션이다.

00:03:19.000 --> 00:03:28.000
우리의 샘플에는 애플리케이션을 위한 로컬 컨테이너가 있으며 USGS의 JSON 피드에서 지진 데이터를 수집합니다.

00:03:28.000 --> 00:03:38.000
데이터를 다운로드할 때 JSON 파서에 전달한 다음 백그라운드 컨텍스트로 가져와 관리 객체로 전환되어 로컬 저장소에 저장됩니다.

00:03:38.000 --> 00:03:43.000
그런 다음 뷰 컨텍스트는 변경 사항을 병합하여 마법처럼 UI를 업데이트합니다.

00:03:43.000 --> 00:03:50.000
2020년에, 우리는 배치 작업을 통해 이 데이터를 효율적으로 처리하는 방법에 초점을 맞추었다.

00:03:50.000 --> 00:03:54.000
그러나 이제, 저는 우리가 이러한 작업을 동시에 수행하는 방법에 집중하고 싶습니다.

00:03:54.000 --> 00:04:01.000
특히, 저는 우리가 애플리케이션으로 데이터를 가져오기 위해 취하는 세 가지 단계에 초점을 맞추고 싶습니다.

00:04:01.000 --> 00:04:09.000
첫 번째 단계는 원시 데이터를 다운로드하는 것이며, 성공적으로 다운로드되면 응용 프로그램은 이를 특정 지역 대표로 변환해야 합니다.

00:04:09.000 --> 00:04:13.000
그리고 마지막으로, 새로운 물체를 영구 저장소에 저장하세요.

00:04:13.000 --> 00:04:17.000
이것을 고급 코드로 변환해 봅시다.

00:04:17.000 --> 00:04:21.000
나는 각 작업을 자체 기능이나 폐쇄로 추상화했다.

00:04:21.000 --> 00:04:35.000
앱은 먼저 서버에서 원시 데이터를 검색하고, 편리한 로컬 표현으로 처리한 다음, 백그라운드 관리 객체 컨텍스트에서 배치 삽입 요청을 하여 객체를 코어 데이터로 가져옵니다.

00:04:35.000 --> 00:04:40.000
이렇게 쓰여서, 잠재적인 병목 현상을 시각화하는 것이 조금 더 쉽다.

00:04:40.000 --> 00:04:46.000
네트워크를 통해 데이터를 로드하는 것은 비동기적으로 작업을 수행하는 것을 고려할 수 있는 좋은 기회가 될 것이다.

00:04:46.000 --> 00:04:49.000
전환은 또한 고려해야 할 장소일 수 있다.

00:04:49.000 --> 00:04:55.000
게다가, 우리의 지속적인 저장소로 데이터를 가져오는 것은 꽤 적절해 보인다.

00:04:55.000 --> 00:05:05.000
하지만 역사적으로, 이러한 모든 경우에, 당신은 그러한 비동기 메커니즘을 직접 구현하거나 프레임워크별 구현에 크게 의존해야 할 것입니다.

00:05:05.000 --> 00:05:10.000
코어 데이터의 구체적인 추상화에 대해 이야기해 봅시다.

00:05:10.000 --> 00:05:19.000
핵심 데이터의 경우, performAndWait을 호출할 때, 관리되는 객체 컨텍스트는 자체 보호된 실행 환경 내에서 제공된 클로저를 실행합니다.

00:05:19.000 --> 00:05:24.000
이것은 잠재적으로 작업이 완료될 때까지 호출 스레드를 묶을 수 있다.

00:05:24.000 --> 00:05:32.000
만약 우리가 이것을 시각화한다면, 우리는 내가 BEFORE, DURING, AFTER로 분류한 세 개의 코드 블록을 상상할 수 있다.

00:05:32.000 --> 00:05:39.000
우리의 코드가 실행될 때, 먼저 BEFORE로 표시된 코드는 원래 스레드에서 실행할 수 있는 기회를 얻습니다.

00:05:39.000 --> 00:05:47.000
그런 다음 performAndWait을 호출하면, 호출 스레드는 폐쇄 중에 발생하는 작업이 완료될 때까지 차단됩니다.

00:05:47.000 --> 00:05:52.000
그 작업이 완료되면, 이후에 설명된 코드가 실행될 것이다.

00:05:52.000 --> 00:05:58.000
물론, 폐쇄가 끝날 때까지 기다릴 필요가 없다면, 우리는 항상 완전히 비동기 변형을 제공했습니다.

00:05:58.000 --> 00:06:09.000
하지만 올해 새로운 스위프트는 코어 데이터가 API의 의도를 더 정확하게 설명할 수 있는 딥 언어 통합으로 강력한 동시성 모델을 얻었다.

00:06:09.000 --> 00:06:11.000
구문은 조금 다르다.

00:06:11.000 --> 00:06:22.000
당신은 수행 결과를 기다리라고 요청하지만, 이 새로운 API를 사용하기 위한 정신 모델은 관리 객체가 항상 지원했던 것과 정확히 동일합니다.

00:06:22.000 --> 00:06:30.000
그러나 장점은 동시성이 더 이상 숨겨진 구현 세부 사항이 아니라 스위프트 언어에 깊이 통합된다는 것이다.

00:06:30.000 --> 00:06:43.000
이 때문에, 컴파일러는 데이터 레이스와 교착 상태와 같은 많은 일반적인 동시성 버그를 자동으로 방지할 수 있으며, 작업이 결과를 기다리는 것으로 알려져 있을 때 자원을 효율적으로 사용할 수도 있다.

00:06:43.000 --> 00:06:49.000
코드로 돌아가서 이것을 실제로 사용하는 것이 어떤지 봅시다.

00:06:49.000 --> 00:06:53.000
우리가 보았듯이, 당신은 비동기 선언된 기능을 기다리라고 요청합니다.

00:06:53.000 --> 00:07:01.000
이것은 비동기 함수가 반환하여 제어를 산출할 때까지 호출 실행 컨텍스트를 중단할 가능성이 있다.

00:07:01.000 --> 00:07:11.000
또한 예상대로 던져진 오류를 호출 프레임으로 라우팅하여 Swift의 기존 구조화된 오류 처리와 원활하게 작동합니다.

00:07:11.000 --> 00:07:25.000
이제 비동기 함수를 호출하는 예를 보았으므로, 관리되는 객체 컨텍스트 내에서 비동기 작업을 수행하는 Core Data의 새로운 방법을 살펴봅시다.

00:07:25.000 --> 00:07:36.000
스위프트 코드의 이 작은 절에는 꽤 많은 기능이 포함되어 있지만, 몇 가지 중요한 세부 사항에 대해서만 이야기한 다음 실제로 어떻게 사용할 수 있는지 보여줄 것입니다.

00:07:36.000 --> 00:07:39.000
새로운 성능 과부하 선언부터 시작합니다.

00:07:39.000 --> 00:07:50.000
반환할 수 있는 결과의 종류에 따라 일반적이며 Swift의 새로운 동시성 기능에 이 기능을 선택하는 새로운 비동기 키워드로 장식되어 있음을 알 수 있습니다.

00:07:50.000 --> 00:08:02.000
아마도 이 새로운 API의 가장 중요한 측면은 제공된 클로저를 통해 이제 오류를 발생하거나 값을 반환할 수 있어 이를 직접 호출 프레임으로 다시 라우팅하는 노력을 절약할 수 있다는 것입니다.

00:08:02.000 --> 00:08:07.000
몇 가지 다른 시나리오를 탐구하여 이것이 얼마나 멋진지 봅시다.

00:08:07.000 --> 00:08:20.000
역사적으로, 동시성이 우리의 구현 내부에 숨어 있었기 때문에, performAndWait 외부에서 오류를 라우팅하는 유일한 방법 중 하나는 옵션을 닫은 다음 나중에 확인하는 것이었습니다.

00:08:20.000 --> 00:08:33.000
완전 비동기 버전의 성능을 사용하는 경우 이것은 더 복잡할 수 있습니다. 왜냐하면 완료 핸들러를 전달하고 일관되게 사용했는지 확인하여 많은 배관을 해야 하기 때문입니다.

00:08:33.000 --> 00:08:37.000
스위프트의 새로운 동시성 모델로, 모든 배관이 당신을 위해 처리됩니다!

00:08:37.000 --> 00:08:47.000
그냥 당신의 비동기 작업을 기다려 보세요, 그리고 오류가 발생하면, 그냥 던지세요, 그러면 자연스럽게 호출 프레임으로 풀릴 것입니다.

00:08:47.000 --> 00:08:51.000
그래서 이제, 우리는 오류에 집중했지만, 결과는 어떻습니까?

00:08:51.000 --> 00:08:54.000
음, 내가 설명한 모든 것은 정확히 똑같아.

00:08:54.000 --> 00:08:57.000
구체적인 예를 살펴봅시다.

00:08:57.000 --> 00:09:01.000
코드에 뛰어들기 전에 우리가 하고 싶은 것을 스케치해 봅시다.

00:09:01.000 --> 00:09:09.000
이 예에서, 지난 5시간 동안 발생한 지진의 수를 식별하기 위해 가져오기 요청을 구성하고 싶습니다.

00:09:09.000 --> 00:09:13.000
한 문장으로, 이것은 설명하기 쉬운 작업이다.

00:09:13.000 --> 00:09:17.000
하지만 코드에서, 우리는 물건을 조금 재정렬해야 할 것이다.

00:09:17.000 --> 00:09:26.000
우리는 먼저 5시간 전이 언제인지 알아내야 하며, 이를 위해 캘린더 API를 사용하여 이를 강력한 방식으로 계산할 수 있습니다.

00:09:26.000 --> 00:09:33.000
그런 다음 해당 날짜의 관점에서 술어로 가져오기 요청을 구성하고 카운트 결과 유형을 요청할 것입니다.

00:09:33.000 --> 00:09:37.000
코드에서, 그것은 우리의 계획과 거의 비슷해 보인다.

00:09:37.000 --> 00:09:49.000
우리는 캘린더의 오프셋 API를 사용하여 5시간 전에 계산한 다음, 우리가 관심 있는 날짜와 일치하는 조건자와 함께 카운트 결과를 반환하도록 Quake FetchRequest를 구성합니다.

00:09:49.000 --> 00:09:54.000
역사적으로, 반환 결과는 우리가 오류를 포착한 방식과 비슷한 패턴을 따랐다.

00:09:54.000 --> 00:10:05.000
돌연변이가 필요한 모든 상태를 닫고, 관리되는 객체 컨텍스트에서 계산을 수행한 다음, 나중에 제어를 되찾은 후 결과를 사용할 수 있습니다.

00:10:05.000 --> 00:10:14.000
이제, 우리는 단순히 수행 호출의 결과를 기다리고 호출 프레임에 직접 수행 결과를 반환할 수 있습니다.

00:10:14.000 --> 00:10:17.000
나머지 코드는 정확히 동일합니다.

00:10:17.000 --> 00:10:26.000
그 코드가 가지고 있었을 수도 있는 잠재적인 버그나 뉘앙스와 함께 우리가 피하는 것은 오직 손 값 라우팅일 뿐이다.

00:10:26.000 --> 00:10:30.000
이 새로운 코드는 꽤 간결하고 표현력이 있다.

00:10:30.000 --> 00:10:35.000
그러나, 당신이 조심해야 할 때가 있다는 것은 언급할 가치가 있다.

00:10:35.000 --> 00:10:39.000
이유를 알아보기 위해 다른 예를 살펴봅시다.

00:10:39.000 --> 00:10:44.000
이 예는 가장 최근의 지진을 관리되는 물체로 되돌리려고 시도한다.

00:10:44.000 --> 00:10:53.000
새로운 API를 사용하면 값을 정말 쉽게 반환할 수 있지만, 이미 관리 객체 컨텍스트에 등록된 관리 객체를 반환하는 것은 안전하지 않습니다.

00:10:53.000 --> 00:11:00.000
수행 요청의 종료 내에서 그러한 등록된 객체를 참조하는 것은 유효하다.

00:11:00.000 --> 00:11:15.000
대신, 다른 실행 컨텍스트 사이에서 관리되는 객체를 참조해야 하는 경우, 객체 ID를 사용하고 필요에 따라 다시 가져오거나, 가져오기 요청의 사전 표현 옵션을 사용하세요.

00:11:15.000 --> 00:11:21.000
이제 한 가지 예를 더 보기 전에, 저는 제가 아직 이야기하지 않은 세부 사항을 다루고 싶습니다.

00:11:21.000 --> 00:11:23.000
그리고 그 세부 사항은 ScheduledTaskType이다.

00:11:23.000 --> 00:11:32.000
지금까지, 우리가 본 모든 비동기 성능은 이 옵션의 기본값 측면에서였다: .immediate.

00:11:32.000 --> 00:11:43.000
.Enqueued라는 두 번째 옵션이 있으며, 이 두 스케줄링 접근 방식의 차이점을 이해하기 위해, 작업 일정을 요청할 때 관리 객체 컨텍스트 내에서 구체적으로 어떤 일이 일어나는지 생각하는 것이 도움이 됩니다.

00:11:43.000 --> 00:11:50.000
우리가 보았듯이, .immediate는 performAndWait의 Swift-async-aware 버전처럼 많이 행동한다.

00:11:50.000 --> 00:12:05.000
다른 실행 컨텍스트에서 실행하고 백그라운드 컨텍스트에서 수행되는 작업을 기다리라고 요청하는 경우, 예약되고 완료될 때까지 기다릴 것입니다.

00:12:05.000 --> 00:12:13.000
그러나 만약 당신이 이미 같은 실행 컨텍스트에 있다면, 그 작업은 즉시 낙관적으로 예정될 것이다.

00:12:13.000 --> 00:12:16.000
반면에, .enqueued는 조금 더 간단하다.

00:12:16.000 --> 00:12:24.000
그것은 단순히 원래 호출 사이트의 선호도에 관계없이 항상 요청된 작업을 컨텍스트 작업 세트의 끝에 추가합니다.

00:12:24.000 --> 00:12:27.000
계속해서 한 가지 예를 더 살펴봅시다.

00:12:27.000 --> 00:12:31.000
이 모든 비동기 기능은 당신도 채택할 수 있습니다.

00:12:31.000 --> 00:12:40.000
여기서, 나는 우리가 이야기해 온 가져오기 논리를 새로운 비동기 키워드로 장식된 새로운 importQuakes 함수로 고려했다.

00:12:40.000 --> 00:12:46.000
이 기능은 차례로 다른 비동기 기능의 관점에서 구현된다.

00:12:46.000 --> 00:12:52.000
이제 누구나 Swift의 새로운 동시성 기능을 활용하기 위해 이 새로운 기능을 기다릴 수 있습니다.

00:12:52.000 --> 00:12:55.000
우리가 지금까지 본 것을 요약해 봅시다.

00:12:55.000 --> 00:13:02.000
전체적으로, 이 새로운 API는 Swift의 구조화된 동시성에 대한 지원을 핵심 데이터로 바로 제공합니다.

00:13:02.000 --> 00:13:11.000
Perform API의 새로운 변형은 당신이 이미 알고 있고 사랑하는 기존 Core Data API의 Swift 동시성 인식 버전일 뿐입니다.

00:13:11.000 --> 00:13:17.000
우리는 당신이 당신의 애플리케이션에서 이 새로운 API를 활용할 것을 강력히 권장합니다.

00:13:17.000 --> 00:13:25.000
또한, NSManagedObjectContext는 보호된 동시성 도메인 내에서 작업 수행을 지원하는 핵심 데이터의 유일한 유형이 아닙니다.

00:13:25.000 --> 00:13:31.000
우리는 또한 NSPersistentContainer와 NSPersistentStoreCoordinator에 유사한 API를 추가하고 있습니다.

00:13:31.000 --> 00:13:36.000
이 API의 일반적인 모양과 동작은 내가 이미 설명한 것과 매우 유사하다.

00:13:36.000 --> 00:13:45.000
하지만 그 모든 동시 전력으로, 나는 당신이 마음대로 사용할 수 있는 기존 디버깅 도구를 사용하는 조언을 제공하지 않는 것이 태만할 것이다.

00:13:45.000 --> 00:13:52.000
물론, Xcode가 제공하는 주소와 스레드 소독제는 당신이 존재하지도 모를 수도 있는 버그를 잡는 데 매우 유용합니다.

00:13:52.000 --> 00:13:59.000
이것들은 둘 다 계획 편집기의 실행 설정의 진단 창에서 찾을 수 있습니다.

00:13:59.000 --> 00:14:08.000
각 소독제는 안전한 메모리 사용 가정의 검증과 여러 스레드의 데이터의 적절한 사용을 포함하여 다양한 종류의 문제를 감지합니다.

00:14:08.000 --> 00:14:17.000
사용자 커뮤니티에 소프트웨어를 출시하기 전에 두 소독제로 애플리케이션과 관련 테스트를 모두 검증하는 것은 항상 좋은 생각입니다.

00:14:17.000 --> 00:14:27.000
그리고 소독제는 모든 상황에서 유용하지만, Core Data가 더 많은 도메인별 도움을 받을 수 있는 특별한 런타임 플래그를 제공한다는 것을 강조하고 싶습니다.

00:14:27.000 --> 00:14:40.000
이 옵션을 활성화함으로써, 코어 데이터는 내부 잠금을 검증하고 다양한 코어 데이터 유형의 적절한 사용을 확인하기 위해 여러 가지 유용한 주장을 켤 것이다.

00:14:40.000 --> 00:14:44.000
스위프트 동시성 지원을 채택하는 것이 올해 핵심 데이터에 대한 유일한 변화는 아니다.

00:14:44.000 --> 00:14:55.000
CloudKit 공유에서 새로운 Spotlight 통합에 이르기까지 우리가 도입하는 모든 새로운 API는 Swift의 프레젠테이션을 염두에 두고 만들어졌습니다.

00:14:55.000 --> 00:15:01.000
올해, 우리는 이 주제들 각각에 대해 별도의 세션이 있으며, 그것들을 확인해 보시기 바랍니다.

00:15:01.000 --> 00:15:14.000
우리는 또한 스위프트를 개선할 수 있는 다른 장소를 식별하기 위해 전체 프레임워크를 통과했으며, 우리가 지원하는 다양한 영구 상점부터 시작하여 이 중 몇 가지를 보여주고 싶습니다.

00:15:14.000 --> 00:15:20.000
리콜, 영구적인 상점은 고객의 데이터를 물리적으로 어떻게 저장하고 싶은지 설명합니다.

00:15:20.000 --> 00:15:27.000
코어 데이터는 현재 네 개의 저장소를 제공합니다: XML, 바이너리, 인메모리 및 SQLite.

00:15:27.000 --> 00:15:31.000
그리고 당신은 항상 이 식별자를 사용합니다.

00:15:31.000 --> 00:15:36.000
올해 새로, 우리는 스위프트에서 더 자연스러운 이름을 붙였다.

00:15:36.000 --> 00:15:47.000
기존 이름은 계속 작동할 것이지만, 이것들을 사용하는 새로운 API는 짧은 이름과 이러한 기호를 자동 완성할 수 있는 능력으로 인해 사용하기에 훨씬 더 인체 공학적일 것이다.

00:15:47.000 --> 00:15:53.000
물론, 지속적인 저장소가 핵심 데이터에서 유형과 관련된 유일한 것은 아니다.

00:15:53.000 --> 00:16:00.000
결국, 프레임워크는 모두 입력된 데이터를 저장하는 것에 관한 것이며, 그러한 유형은 속성 설명으로 설명된다.

00:16:00.000 --> 00:16:09.000
그리고 올해, 우리는 그들의 유형으로 작업하기 위한 훨씬 더 자연스러운 구문을 제공하는 속성 설명에 새로운 확장 가능한 열거형을 추가하고 있습니다.

00:16:09.000 --> 00:16:17.000
런타임 모델이 Xcode 모델 빌더에서 설계한 것과 일치하는지 확인할 수 있는 단위 테스트를 작성하여 이것들을 실제로 살펴봅시다.

00:16:17.000 --> 00:16:26.000
단순화를 위해, 우리는 지진 물체 모델에 의해 정의된 단일 런타임 유형을 검증하려고 노력할 것이지만, 이것이 어떻게 확장될지 상상할 수 있습니다.

00:16:26.000 --> 00:16:34.000
이것은 쓰기 위한 작은 테스트처럼 보일지 모르지만, 미래에 더 흥미로운 진단 속도를 높일 수 있기 때문에 검증하는 것은 좋은 일이다.

00:16:34.000 --> 00:16:39.000
이 테스트를 작성하기 위해, 우리는 새로운 속성 유형 측면에서 빠른 도우미 함수를 작성할 것입니다.

00:16:39.000 --> 00:16:42.000
이제 이 기능을 설명해 봅시다.

00:16:42.000 --> 00:16:53.000
우리는 속성 이름, 우리가 신경 쓰는 엔티티 설명, 그리고 새로운 AttributeType 열거의 관점에서 설명된 유형을 기대하는 서명으로 시작할 것입니다.

00:16:53.000 --> 00:16:56.000
이 유틸리티의 정의는 상당히 간단하다.

00:16:56.000 --> 00:17:03.000
우리는 먼저 제공된 이름을 가진 속성이 있는지 확인하고, 찾을 수 없다면 테스트에 실패합니다.

00:17:03.000 --> 00:17:06.000
그리고 나서 우리는 속성의 유형이 예상대로인지 확인합니다.

00:17:06.000 --> 00:17:08.000
그리고 그게 정말 거기에 있는 전부야.

00:17:08.000 --> 00:17:17.000
우리는 각 엔티티와 재산에 대해 이것을 반복할 수 있고 우리의 런타임 행동이 우리가 정의한 모델과 일치한다는 마음의 평화를 누릴 수 있다.

00:17:17.000 --> 00:17:26.000
그리고 이것은 우리가 올해 Swift의 핵심 데이터 열거에 대해 만든 인체 공학적 개선 사항 중 일부의 샘플일 뿐입니다.

00:17:26.000 --> 00:17:35.000
지금까지, 저는 많은 낮은 수준의 프레임워크 상호 작용과 그것이 Swift에서 어떻게 나타나는지에 초점을 맞추고 있지만, 사용자에게 데이터를 제시하는 것은 어떻습니까?

00:17:35.000 --> 00:17:41.000
2020년에, 우리는 SwiftUI에서 Core Data로 작업하기 위한 많은 편의를 도입했습니다.

00:17:41.000 --> 00:17:47.000
그리고 이제, 제 동료인 Scott은 우리가 올해 소개할 새로운 개선 사항에 대해 당신과 공유할 것이 꽤 있습니다.

00:17:47.000 --> 00:17:48.000
스콧?

00:17:48.000 --> 00:17:49.000
고마워, 마이클!

00:17:49.000 --> 00:18:03.000
올해 SwiftUI와 함께 코어 데이터를 사용하는 경험에 대한 많은 개선 사항이 있으며, 가져오기 요청의 게으른 엔티티 해결을 시작으로, 이는 앱이 뷰를 구성하기 전에 코어 데이터 스택을 설정해야 한다는 요구 사항을 완화합니다.

00:18:03.000 --> 00:18:10.000
또한 올해, 가져오기 요청은 정렬 설명자와 조건자에 대한 동적 구성을 선택합니다.

00:18:10.000 --> 00:18:15.000
그리고 마을에는 섹션화된 가져오기를 지원하는 새로운 종류의 가져오기 요청이 있다.

00:18:15.000 --> 00:18:24.000
나는 게으른 엔티티 해결부터 시작하여 마이클이 앞서 이야기에서 언급한 지진 샘플 앱을 사용하여 이들 각각을 살펴볼 것이다.

00:18:24.000 --> 00:18:28.000
아마도 당신의 앱에는 이와 같은 코드가 있을 것입니다.

00:18:28.000 --> 00:18:35.000
이 컨테이너 속성은 이 유형의 코드나 더 넓은 앱을 지원하는 데 실제로 필요하지 않습니다.

00:18:35.000 --> 00:18:39.000
그 모든 것들은 QuakesProvider 유형에서 직접 필요한 것을 얻는다.

00:18:39.000 --> 00:18:49.000
아니요, 이 속성은 모델이 로드되기 전에 환경의 뷰가 엔티티를 참조하기 전에 코어 데이터 스택이 설정되었는지 확인하기 위해 존재합니다.

00:18:49.000 --> 00:18:57.000
ContentView가 초기화된 후 환경 보기 수정자가 호출되는 것을 보세요.

00:18:57.000 --> 00:19:02.000
이 트릭은 올해의 SDK에 배포할 때 더 이상 필요하지 않습니다.

00:19:02.000 --> 00:19:16.000
FetchRequest 속성 래퍼는 이제 가져오기 시간에 이름으로 엔티티를 게으르게 찾습니다. 이 시점에서 환경은 코어 데이터 스택이 설정되었음을 보장했기 때문에 이제 이 속성을 삭제하는 것이 안전합니다...

00:19:16.000 --> 00:19:20.000
그리고 그냥 참조해...

00:19:20.000 --> 00:19:25.000
QuakesProvider는 환경 호출에서 직접 컨테이너를 공유했다.

00:19:25.000 --> 00:19:31.000
몇 가지 새로운 API로 넘어가면, FetchRequest는 이제 동적 구성을 지원합니다.

00:19:31.000 --> 00:19:53.000
요청의 술어와 정렬 설명자를 직접 변경하기 위한 래핑된 값에는 두 가지 새로운 속성이 있으며, 이는 익숙한 NSSortDescriptors와 자동으로 생성된 관리 객체 하위 클래스로 엔티티를 가져올 때 더 많은 편리함과 안전성을 제공하는 새로운 SortDescriptor 값 유형으로 표현됩니다.

00:19:53.000 --> 00:20:00.000
그리고 마지막으로, 뷰와의 더 쉬운 통합을 위해 래핑된 값과 동일한 속성 세트를 가진 구성 바인딩이 있습니다.

00:20:00.000 --> 00:20:14.000
이 새로운 API 이전에, 나는 정렬과 조건자 매개 변수가 뷰의 이니셜라이저를 통해 전달되도록 내 뷰를 디자인해야 했지만, 도구 모음에서 컨트롤을 사용하여 가져오기 요청을 구성하는 것과 같은 것을 지원하는 것이 정말 까다로웠다.

00:20:14.000 --> 00:20:23.000
이 마찰은 이러한 새로운 동적 구성 속성에 의해 제거되며, 지진 샘플 앱에 정렬 및 필터링을 추가하여 사용하는 방법을 보여주고 싶습니다.

00:20:23.000 --> 00:20:26.000
먼저 정렬 설명자를 살펴봅시다.

00:20:26.000 --> 00:20:36.000
기본적으로, 지진 앱은 최신성별로 정렬되지만, 크기별로 주문하고 싶기 때문에 결과의 순서를 제어할 수 있는 메뉴를 추가할 것입니다.

00:20:36.000 --> 00:20:41.000
정적 튜플 배열을 추가하는 것으로 시작하겠습니다...

00:20:41.000 --> 00:20:46.000
내가 지원하고 싶은 정렬 설명자와 그들의 이름을 포함하고 있다.

00:20:46.000 --> 00:20:52.000
그들이 새로운 SortDescriptor 유형을 사용하고 있다는 것을 여기에서 확인하세요.

00:20:52.000 --> 00:20:58.000
나는 또한 내가 현재 사용하고 있는 정렬 순서를 추적하기 위해 약간의 상태를 원할 것이다.

00:20:58.000 --> 00:21:05.000
나는 이미 이것을 위한 유형을 만들었기 때문에, 콘텐츠 보기의 속성으로 추가할 것이다.

00:21:05.000 --> 00:21:11.000
이제 목록 보기에 도구 모음 메뉴를 추가할게...

00:21:11.000 --> 00:21:20.000
그것은 선택한 정렬과 가져오기 요청의 정렬 설명자를 업데이트하는 onChange 수정자를 수정합니다.

00:21:20.000 --> 00:21:27.000
이제 미리보기에서, 우리는 새로운 메뉴를 볼 수 있고, 나는 그것을 사용하여 지진을 규모별로 분류할 수 있다.

00:21:27.000 --> 00:21:29.000
좋아!

00:21:29.000 --> 00:21:32.000
이제 필터링을 추가하세요.

00:21:32.000 --> 00:21:36.000
지진 장소를 기준으로 필터링하고 싶습니다.

00:21:36.000 --> 00:21:42.000
내가 가장 먼저 필요한 것은 검색 필드의 텍스트에 대한 상태이다.

00:21:42.000 --> 00:21:48.000
그리고 나는 구속력 있는 재산을 만들 거야...

00:21:48.000 --> 00:21:56.000
가져오기 요청을 업데이트하는 검색 필드를 위해.

00:21:56.000 --> 00:21:59.000
그것들이 제자리에 있으면, 내가 필요한 것은 UI뿐이다.

00:21:59.000 --> 00:22:04.000
편리하게...

00:22:04.000 --> 00:22:11.000
Searchable은 문자열에 바인딩되므로, 우리는 바로 여기에 그것을 넣을 수 있습니다.

00:22:11.000 --> 00:22:22.000
이제 미리보기에서, 우리는 이 새로운 필드에 "샌드위치"를 입력하기만 하면 샌드위치와 일치하는 장소 근처의 모든 지진을 좁힐 수 있습니다.

00:22:22.000 --> 00:22:25.000
그리고 그것은 FetchRequest의 동적 구성이다.

00:22:25.000 --> 00:22:35.000
또 다른 일반적으로 요청되는 기능은 SectionedFetchRequest라는 새로운 속성 래퍼 유형으로 올해 도착하는 섹션 가져오기에 대한 지원입니다.

00:22:35.000 --> 00:22:50.000
이 유형은 FetchRequest와 동일한 새로운 동적 구성 속성을 지원하지만, NSFetchedResultsController와 같이 섹션을 식별하는 속성의 키 경로인 추가 매개 변수로 초기화됩니다.

00:22:50.000 --> 00:22:57.000
하지만 가져온 결과 컨트롤러와 달리, 섹션을 식별하는 속성은 해시할 수 있는 한 원하는 유형을 가질 수 있습니다.

00:22:57.000 --> 00:23:05.000
이것은 SectionedFetchRequest의 추가 일반 매개 변수를 사용하여 유형 시스템에서 인코딩됩니다.

00:23:05.000 --> 00:23:09.000
마지막으로, 이 새로운 유형은 2차원 결과 유형을 감싼다.

00:23:09.000 --> 00:23:15.000
SectionedFetchResults는 섹션 모음이며, 각각은 그 자체로 결과 모음입니다.

00:23:15.000 --> 00:23:21.000
각 섹션에는 섹션 식별자가 있는 속성도 있습니다.

00:23:21.000 --> 00:23:26.000
이것은 채택하기 정말 쉽기 때문에, 나는 Earthquakes 앱에 섹션 가져오기를 추가할 것이다.

00:23:26.000 --> 00:23:34.000
먼저, 저는 FetchRequest 선언을 업데이트합니다.

00:23:34.000 --> 00:23:41.000
퀘이크는 이미 하루 동안의 재산을 가지고 있기 때문에, 나는 그것을 섹션 키 경로에 사용할 것이다.

00:23:41.000 --> 00:23:49.000
다음으로, 나는 신체 속성을 업데이트해야 해...

00:23:49.000 --> 00:23:53.000
새로운 섹션 결과 유형과 일치하기 위해.

00:23:53.000 --> 00:24:12.000
여기의 외부 루프는 섹션을 반복하므로, 나는 여기서 섹션 보기를 방출하고 있으며, 각 섹션 자체는 퀘이크의 모음이므로, 이 내부 ForEach는 내가 전에 결과를 반복했던 것처럼 섹션을 반복한다.

00:24:12.000 --> 00:24:18.000
우리가 미리보기를 살펴보면, 나는 이제 시간별로 지진을 주문하고 낮별로 구분했다.

00:24:18.000 --> 00:24:27.000
그리고 SwiftUI는 심지어 축소 섹션에 대한 자동 지원을 제공합니다.

00:24:27.000 --> 00:24:39.000
이 새로운 SectionedFetchRequest 유형은 FetchRequest와 동일한 동적 구성 속성과 섹션 식별자 키 경로에 대한 추가 구성 속성을 지원합니다.

00:24:39.000 --> 00:24:44.000
이것은 우리가 더 이상 분류를 바꾸는 것이 실제로 안전하지 않기 때문에 매우 중요하다.

00:24:44.000 --> 00:24:53.000
시간과 지진 규모는 완벽하게 상관관계가 없기 때문에 섹션이 인접하지 않을 수 있으며, 이는 아마도 최선일 것이다.

00:24:53.000 --> 00:24:59.000
이것을 고치기 위해, 나는 정렬을 업데이트해야 한다...

00:24:59.000 --> 00:25:05.000
그래서 각각은 해당 섹션 식별자 키 경로를 가지고 있다.

00:25:05.000 --> 00:25:09.000
다음으로, 도구 모음에서...

00:25:09.000 --> 00:25:16.000
정렬 설명자를 업데이트할 때마다 섹션 식별자 키 경로를 업데이트해야 합니다.

00:25:16.000 --> 00:25:19.000
하지만 여기 중요한 부분이 있어.

00:25:19.000 --> 00:25:29.000
결과 게터가 호출될 때마다 요청에 대한 변경 사항이 커밋되므로, 정렬과 섹션을 모두 안전하게 업데이트하기 위해...

00:25:29.000 --> 00:25:36.000
로컬로 가져온 결과에 대한 참조에 대한 구성을 업데이트해야 합니다.

00:25:36.000 --> 00:25:42.000
이제 미리보기에서, 우리는 순서를 변경하면 섹션도 변경된다는 것을 알 수 있습니다.

00:25:42.000 --> 00:25:54.000
우리는 시간별로 정렬된 지진, 일별로 구분된 지진, 그리고 규모별로 정렬된 지진 사이를 전환할 수 있습니다.

00:25:54.000 --> 00:26:07.000
그리고 우리는 그것을 가지고 있습니다: 게으른 스택 초기화, 동적 구성 및 섹션된 가져오기, 모두 iOS 15와 macOS Monterey를 사용하는 기존 앱에 쉽게 적용할 수 있습니다.

00:26:07.000 --> 00:26:15.000
요약하자면, Core Data는 모든 Apple 플랫폼에서 앱의 데이터 지속성 요구를 관리하기 위한 원스톱 상점입니다.

00:26:15.000 --> 00:26:24.000
새로운 성능 API를 통해 Swift에서 사용할 수 있는 새로운 동시성 기능을 활용하며, 여전히 강력한 스레드 안전 디버깅이 내장되어 있습니다.

00:26:24.000 --> 00:26:34.000
Swift에서 저장소 및 속성 유형을 더욱 자연스럽게 사용할 수 있는 새로운 열거형 인터페이스와 CloudKit 공유 및 Spotlight 통합이 있습니다.

00:26:34.000 --> 00:26:43.000
그리고 동적 구성과 분할된 가져오기로 SwiftUI를 사용하여 데이터를 뷰에 연결하는 것이 그 어느 때보다 쉬워졌습니다.

00:26:43.000 --> 00:26:46.000
이 주제들과 관련하여 배워야 할 더 많은 새로운 것들이 있다.

00:26:46.000 --> 00:26:52.000
"SwiftUI로 단순화하고 Swift Concurrency를 만나세요" 컬렉션을 확인하는 것이 좋습니다.

00:26:52.000 --> 00:26:53.000
그리고 그게 다야!

00:26:53.000 --> 00:26:57.000
저는 여러분 모두가 이 새로운 API로 무엇을 만드는지 정말 기대하고 있습니다.

00:26:57.000 --> 23:59:59.000
[쾌활한 음악].

