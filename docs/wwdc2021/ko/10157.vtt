WEBVTT

00:00:02.000 --> 00:00:15.000
안녕! 제 이름은 에고르이고, 오늘, 메탈 디버거의 모든 개선 사항과 새로운 기능에 대해 말씀드리고 싶습니다.

00:00:15.000 --> 00:00:23.000
올해, 우리는 레이 트레이싱 및 기능 포인터와 같은 더 많은 금속 기능을 지원하고 있습니다.

00:00:23.000 --> 00:00:35.000
Apple 플랫폼에서 GPU를 최대한 활용할 수 있도록 GPU 타임라인과 일관된 GPU 성능 상태와 같은 새로운 프로파일링 워크플로우를 추가했습니다.

00:00:35.000 --> 00:00:45.000
우리는 셰이더 검증에 대한 광범위한 지원과 정확한 캡처 컨트롤을 포함하여 당신이 알고 사랑하는 다른 디버깅 워크플로우를 개선했습니다.

00:00:45.000 --> 00:00:53.000
우리는 또한 내 동료 아만다가 나중에 이야기할 텍스처 압축의 발전을 소개하고 있다.

00:00:53.000 --> 00:00:56.000
먼저, 레이 트레이싱에 대해 이야기해 봅시다.

00:00:56.000 --> 00:01:11.000
작년에 우리는 새로운 메탈 레이 트레이싱 API를 도입했으며, 이제 Xcode 13에서 셰이더에 유연성을 제공하는 기능 포인터 및 기능 테이블과 함께 메탈 디버거에서 지원합니다.

00:01:11.000 --> 00:01:18.000
그리고 추상적이고 재사용 가능한 셰이더 라이브러리 코드를 구축할 수 있는 방법을 제공하는 동적 라이브러리.

00:01:18.000 --> 00:01:25.000
또한, 레이 트레이싱을 위해, 우리는 새로운 도구인 가속 구조 뷰어를 도입하고 있습니다.

00:01:25.000 --> 00:01:28.000
금속 디버거에서 레이 트레이싱을 보세요.

00:01:28.000 --> 00:01:33.000
ModernRenderer 샘플 앱의 GPU 추적을 열었습니다.

00:01:33.000 --> 00:01:41.000
그림자와 주변 폐색과 같은 효과를 얻기 위해 금속 광선 추적을 사용하도록 수정되었다.

00:01:41.000 --> 00:01:45.000
이 인코더는 아름다운 광선 추적 그림자 지도를 만든다.

00:01:45.000 --> 00:01:51.000
바인딩된 자원에서 가속 구조를 볼 수 있도록 디스패치 콜을 선택했습니다.

00:01:51.000 --> 00:01:58.000
여기서부터, 나는 우리의 새로운 가속 구조 뷰어로 가기 위해 가속 구조를 열 것이다.

00:01:58.000 --> 00:02:07.000
여기서, 당신은 오른쪽에 있는 친숙한 비스트로 장면의 기하학과 왼쪽에 있는 윤곽을 볼 수 있습니다.

00:02:07.000 --> 00:02:14.000
장면에서 인스턴스를 클릭하면 뷰어와 장면 개요에서 선택됩니다.

00:02:14.000 --> 00:02:20.000
변환 매트릭스와 다른 인스턴스 속성을 확장하여 볼 수 있습니다.

00:02:20.000 --> 00:02:26.000
장면 뷰어를 클릭하는 동안 Option 키를 눌러 개별 지오메트리를 선택할 수도 있습니다.

00:02:26.000 --> 00:02:32.000
이것은 또한 장면 개요에서 그것을 선택할 것이며, 그 반대도 마찬가지입니다.

00:02:32.000 --> 00:02:40.000
또한 바로 여기 뷰어에서 가속 구조와 함께 사용되는 관련 교차 기능을 볼 수 있습니다.

00:02:40.000 --> 00:02:46.000
하지만 가속 구조 뷰어는 단순히 지오메트리를 표시하는 것 이상을 할 수 있다.

00:02:46.000 --> 00:02:54.000
여기 오른쪽 하단에서, 당신은 또한 장면의 일부 속성을 시각화하는 데 도움이 되는 많은 강조 모드를 찾을 수 있습니다.

00:02:54.000 --> 00:03:01.000
예를 들어, 경계 볼륨 횡단 모드는 기하학의 복잡성을 시각화하는 데 도움이 될 수 있습니다.

00:03:01.000 --> 00:03:11.000
더 깊은 파란색은 경계 볼륨 계층 구조가 다른 부분에 비해 횡단하는 데 계산 비용이 더 많이 드는 영역을 보여줍니다.

00:03:11.000 --> 00:03:18.000
모든 모드의 경우, 장면의 다른 부분을 가리킬 때 관련 정보를 보여주는 작은 보기가 있습니다.

00:03:18.000 --> 00:03:25.000
여기서, 그것은 경계 상자 횡단과 원시적인 교차로의 수를 표시합니다.

00:03:25.000 --> 00:03:30.000
당신에게 더 많은 유연성을 제공하기 위해, 우리는 또한 횡단 설정을 포함시켰습니다.

00:03:30.000 --> 00:03:40.000
그것들을 사용하면 셰이더 내부의 인터섹터 객체에서 찾을 수 있는 것과 동일한 속성을 사용하여 가속 구조 뷰어를 구성할 수 있습니다.

00:03:40.000 --> 00:03:43.000
레이 트레이싱에 관해서는 이야기할 것이 훨씬 더 많다.

00:03:43.000 --> 00:04:01.000
더 알고 싶다면, 올해의 세션 "메탈 레이 트레이싱으로 하이브리드 렌더링을 살펴보세요"를 확인하세요. 그리고 일반적으로 API에 대해 더 알고 싶다면, 작년의 강연인 "금속으로 레이 트레이싱을 발견하세요"를 확인하세요. 다음으로, 프로파일링에 대해 이야기해 봅시다.

00:04:01.000 --> 00:04:07.000
앱을 프로파일링하는 것은 중요한 단계이며, 우리는 이미 당신이 사용할 수 있는 많은 훌륭한 도구를 가지고 있습니다.

00:04:07.000 --> 00:04:20.000
예를 들어, 악기에서 금속 시스템 추적을 사용하면 다양한 렌더링 단계, GPU 카운터 및 셰이더 타임라인에 대한 CPU 및 GPU 지속 시간을 보여주는 타임라인 보기를 탐색할 수 있습니다.

00:04:20.000 --> 00:04:31.000
그리고 메탈 디버거에서 GPU 카운터는 인코더당 또는 드로우당 GPU에서 직접 풍부한 측정 세트를 보여줍니다.

00:04:31.000 --> 00:04:36.000
둘 다 앱의 성능에 대한 보완적인 견해를 제공하는 훌륭한 도구입니다.

00:04:36.000 --> 00:04:40.000
하지만 그러한 견해를 조정하는 것은 추가적인 노력이 필요할 수 있다.

00:04:40.000 --> 00:04:50.000
그래서 금속 시스템 추적과 GPU 카운터를 통합 경험으로 결합한 새로운 GPU 프로파일링 도구를 보여드리게 되어 기쁩니다.

00:04:50.000 --> 00:04:57.000
Apple GPU를 위해 특별히 설계된 새로운 도구인 Metal Debugger의 GPU 타임라인을 소개합니다.

00:04:57.000 --> 00:05:06.000
성능 데이터에 대한 다른 관점을 제공하며, 앱에서 잠재적인 최적화 지점을 찾는 데 도움이 될 수 있습니다.

00:05:06.000 --> 00:05:12.000
우리의 프로파일링 도구 제품군에 대한 이 최신 추가 사항을 살펴봅시다.

00:05:12.000 --> 00:05:16.000
GPU 타임라인은 성능 패널에서 사용할 수 있습니다.

00:05:16.000 --> 00:05:21.000
앱에서 프레임을 캡처한 후 디버그 네비게이터에서 찾을 수 있습니다.

00:05:21.000 --> 00:05:28.000
공연 패널을 열면, 병렬로 배치된 다양한 트랙 세트가 당신을 맞이할 것입니다.

00:05:28.000 --> 00:05:33.000
우리가 계속하기 전에, 나는 왜 인코더 트랙이 병렬로 있는지 설명하고 싶다.

00:05:33.000 --> 00:05:42.000
Apple GPU에서 다른 렌더링 패스의 정점 및 조각 단계와 컴퓨팅 디스패치가 동시에 실행될 수 있습니다.

00:05:42.000 --> 00:05:57.000
이것은 Apple GPU 아키텍처와 "타일 기반 지연 렌더링"이라는 렌더링 기술의 사용에 의해 활성화됩니다. 우리는 당신이 앱의 맥락에서 Apple GPU의 이러한 병렬 특성을 볼 수 있는 것이 중요하다고 생각했습니다.

00:05:57.000 --> 00:06:00.000
그리고 그것이 GPU 타임라인이 유용한 곳이다.

00:06:00.000 --> 00:06:10.000
상단에서 정점, 조각 및 컴퓨팅 인코더 타임라인을 볼 수 있으며, 각 인코더는 사용하는 리소스를 한 눈에 보여줍니다.

00:06:10.000 --> 00:06:17.000
인코더 아래에서 점유, 대역폭 및 제한 카운터를 찾을 수 있습니다.

00:06:17.000 --> 00:06:21.000
인코더 타임라인을 자세히 살펴봅시다.

00:06:21.000 --> 00:06:27.000
각 인코더 트랙을 확장하여 집계된 셰이더 타임라인을 볼 수 있습니다.

00:06:27.000 --> 00:06:35.000
타임라인을 더욱 확장하면 폭포와 같은 방식으로 각 개별 셰이더를 보여줄 것입니다.

00:06:35.000 --> 00:06:38.000
인코더를 탐색하는 것은 쉽다.

00:06:38.000 --> 00:06:43.000
오른쪽에 있는 모든 인코더 목록을 보려면 인코더 트랙을 선택하세요.

00:06:43.000 --> 00:06:48.000
거기서, 당신은 그것들을 평균 기간에 따라 정렬할 수 있습니다.

00:06:48.000 --> 00:06:54.000
타임라인에서 개별 인코더를 클릭하면 사이드바에 더 많은 정보가 표시됩니다.

00:06:54.000 --> 00:07:01.000
예를 들어, 여기서 이 렌더링 명령 인코더의 첨부 파일을 볼 수 있습니다.

00:07:01.000 --> 00:07:09.000
인코더를 선택할 때, 활성화된 시간 범위가 모든 트랙에서 강조 표시된다는 것을 눈치챘을 것입니다.

00:07:09.000 --> 00:07:18.000
이를 통해 서로 다른 단계가 어떻게 겹치는지 쉽게 검사할 수 있으며, 인코더의 카운터 값을 상호 연관시킬 수 있습니다.

00:07:18.000 --> 00:07:31.000
타임라인 보기에서 벗어나, 카운터 탭으로 전환하여 GPU 카운터에 액세스하거나, 인코더의 컨텍스트 메뉴를 열고 거기에서 카운터에서 표시할 수 있습니다.

00:07:31.000 --> 00:07:36.000
그리고 이것은 GPU 타임라인을 살짝 엿보는 것이다.

00:07:36.000 --> 00:07:56.000
메탈 디버거를 사용하여 앱의 성능을 이해하는 방법에 대해 자세히 알아보려면, 올해의 세션 "Apple GPU를 위한 고급 게임 최적화"를 확인하세요. 이제 앱을 프로파일링하는 새로운 방법을 보여줬으니, 그 성능은 몇 가지 요인에 달려 있다는 것을 이해하는 것이 중요합니다.

00:07:56.000 --> 00:08:02.000
우리가 금속에 대해 이야기할 때, GPU 성능 상태는 매우 중요한 요소이다.

00:08:02.000 --> 00:08:14.000
그것은 운영 체제에 의해 관리되며, 장치 열, 시스템 설정, GPU 활용도 및 기타 매개 변수에 따라 상태를 낮추거나 올릴 수 있습니다.

00:08:14.000 --> 00:08:20.000
이러한 상태 변화는 당신이 보고 있는 프로파일링 결과에 영향을 미칠 수 있습니다.

00:08:20.000 --> 00:08:26.000
올해, 우리는 당신이 더 일관된 결과로 앱을 프로파일링할 수 있는 새로운 방법을 소개하고 있습니다.

00:08:26.000 --> 00:08:49.000
라이브 공연 녹음을 위한 악기 및 금속 시스템 추적부터 시작하여 금속 디버거, GPU 추적 프로파일링, 마지막으로 일반적인 사용 사례를 위한 Xcode의 장치 조건 등 전체 금속 도구 제품군에서 GPU 성능 상태를 보고 변경할 수 있는 방법을 추가했습니다.

00:08:49.000 --> 00:08:53.000
먼저, 악기에 대해 이야기해 봅시다.

00:08:53.000 --> 00:08:59.000
올해, 우리는 금속 시스템 추적에 GPU 성능 상태에 대한 트랙을 추가했습니다.

00:08:59.000 --> 00:09:06.000
다른 트랙과 함께 사용하여 앱의 성능을 장치의 성능 상태와 연관시키세요.

00:09:06.000 --> 00:09:12.000
하지만, 성능 상태를 볼 수 있다는 것은 방정식의 일부일 뿐이라는 것을 명심하세요.

00:09:12.000 --> 00:09:21.000
일관되고 재현 가능한 프로파일링 결과를 얻으려면, 장치에서 GPU 성능 상태를 설정하는 방법도 필요합니다.

00:09:21.000 --> 00:09:29.000
올해의 새로운 기능은 Instruments에서 추적을 기록할 때 특정 GPU 성능 상태를 유도할 수 있는 기능입니다.

00:09:29.000 --> 00:09:35.000
녹음 옵션으로 이동하여 녹음이 시작되기 전에 공연 상태를 선택하기만 하면 됩니다.

00:09:35.000 --> 00:09:40.000
그 후, 평소와 같이 성능 추적을 기록할 수 있습니다.

00:09:40.000 --> 00:09:45.000
장치가 그것을 유지할 수 있다면, 악기는 추적 기간 동안 당신이 선택한 상태를 유도할 것입니다.

00:09:45.000 --> 00:09:54.000
때로는 기존 인스트루먼트 추적이 녹화 중에 GPU 성능 상태가 유도되었는지 확인해야 할 수도 있습니다.

00:09:54.000 --> 00:10:01.000
이 정보는 정보 팝오버의 "녹음 설정" 섹션에서 찾을 수 있습니다.

00:10:01.000 --> 00:10:06.000
그리고 이제, 당신은 인스트루먼트에서 GPU 성능 상태를 보고 유도하는 방법을 알고 있습니다.

00:10:06.000 --> 00:10:12.000
일관된 GPU 성능 상태를 활용하는 두 번째 방법은 메탈 디버거를 사용하는 것이다.

00:10:12.000 --> 00:10:20.000
기본적으로, 앱의 GPU 추적을 캡처할 때, Xcode는 당신을 위해 추적을 프로파일링할 것입니다.

00:10:20.000 --> 00:10:26.000
그리고 그것은 캡처 당시 장치가 있었던 것과 동일한 성능 상태를 사용하여 그렇게 할 것이다.

00:10:26.000 --> 00:10:31.000
그 상태는 우리가 이전에 언급한 요인에 따라 변동했을 수 있다.

00:10:31.000 --> 00:10:39.000
대신, 특정 성능 상태를 직접 선택하려면, 디버그 표시줄의 스톱워치 버튼을 사용하세요.

00:10:39.000 --> 00:10:44.000
선택한 후, 메탈 디버거는 GPU 추적을 다시 프로파일링할 것입니다.

00:10:44.000 --> 00:10:51.000
완료되면, 버튼은 일관된 성능 상태가 달성되었다는 것을 반영하기 위해 강조 표시됩니다.

00:10:51.000 --> 00:11:00.000
또한, 요약 페이지의 "성능" 섹션은 이제 새로운 성능 데이터와 선택한 성능 상태를 한 눈에 보여줍니다.

00:11:00.000 --> 00:11:04.000
이 두 가지 접근 방식은 금속 도구 제품군과 연결되어 있다.

00:11:04.000 --> 00:11:10.000
하지만 때로는 프로파일링 워크플로우 외부에서 일관된 성능 상태를 유도하고 싶을 수도 있습니다.

00:11:10.000 --> 00:11:17.000
GPU 성능 상태를 설정하는 세 번째 방법은 장치 조건을 통한 것이다.

00:11:17.000 --> 00:11:24.000
다른 GPU 성능 상태에서 앱이 어떻게 작동하는지 테스트하고 싶다면, 이것이 당신을 위한 옵션입니다.

00:11:24.000 --> 00:11:30.000
Xcode 13에서 우리는 GPU 성능 상태 장치 조건을 추가했습니다.

00:11:30.000 --> 00:11:39.000
그것은 운영 체제가 장치에서 지정된 상태를 유지 할 수 있고 Xcode에 연결된 상태를 유지하도록 강요한다.

00:11:39.000 --> 00:11:54.000
Xcode에서 이 조건을 추가할 수 있습니다. 창, 장치 및 시뮬레이터로 이동하여 장치를 선택한 다음 "장치 조건" 섹션으로 스크롤하여 원하는 수준으로 "GPU 성능 상태" 조건을 추가할 수 있습니다.

00:11:54.000 --> 00:11:59.000
장치에 GPU 성능 상태 변경을 적용하려면 시작을 누르세요.

00:11:59.000 --> 00:12:03.000
그런 다음, 끝나면, 중지를 누르세요.

00:12:03.000 --> 00:12:11.000
도구에서 바로 GPU 성능 상태를 보고 변경하는 이러한 새로운 방법은 앱을 프로파일링하고 테스트하는 데 도움이 될 것입니다.

00:12:11.000 --> 00:12:20.000
그리고 저는 당신이 프로파일링 워크플로우에 대한 우리의 최신 추가 사항과 개선을 좋아할 것이라고 생각하며, 그들이 당신의 앱을 더 좋게 만드는 데 도움이 되기를 바랍니다.

00:12:20.000 --> 00:12:26.000
이제, 올해 메탈 디버거에 가져올 몇 가지 다른 개선 사항에 대해 이야기해 봅시다.

00:12:26.000 --> 00:12:31.000
먼저, 셰이더 검증 개선에 대해 말씀드리겠습니다.

00:12:31.000 --> 00:12:34.000
그럼, 정확한 캡처 컨트롤을 보여드릴게요.

00:12:34.000 --> 00:12:40.000
그리고 그 후에, 새로운 파이프라인 상태 워크플로우를 살펴보겠습니다.

00:12:40.000 --> 00:12:50.000
마지막으로, 셰이더 디버깅 및 프로파일링, 별도의 디버그 정보 및 선택적 셰이더 디버깅과 관련된 두 가지 새로운 기능을 소개하고 싶습니다.

00:12:50.000 --> 00:13:02.000
작년에 Xcode 12에서 우리는 범위를 벗어난 액세스와 같은 GPU의 런타임 오류를 진단하는 데 도움이 되는 셰이더 유효성 검사를 도입했습니다.

00:13:02.000 --> 00:13:19.000
셰이더 유효성 검사가 활성화되고 인코더가 유효성 검사 오류를 발생시키면 문제 네비게이터에서 런타임 문제가 발생하여 결함이 있는 호출에 대한 CPU와 GPU 백트레이스를 모두 보여줍니다.

00:13:19.000 --> 00:13:46.000
우리는 이미 이것을 더 자세히 다루는 세션이 있으므로, 셰이더 유효성 검사 사용에 대해 자세히 알아보려면 "메탈의 GPU 측 오류 디버깅"이라는 작년 강연을 확인하세요. 올해, 우리는 더 많은 사용 사례를 지원하기 위해 셰이더 검증을 확장하여 간접 명령 버퍼, 동적 라이브러리, 함수 포인터 및 테이블을 사용할 때 사용할 수 있도록 합니다.

00:13:46.000 --> 00:13:53.000
이를 통해 개발 중에 앱 전반에 걸쳐 셰이더 유효성 검사를 더 광범위하게 사용할 수 있습니다.

00:13:53.000 --> 00:13:58.000
다음으로, 저는 당신에게 우리의 새로운 정확한 캡처 컨트롤을 보여주고 싶습니다.

00:13:58.000 --> 00:14:04.000
하지만 먼저, 이제 금속 로고처럼 보이는 캡처 버튼을 보세요.

00:14:04.000 --> 00:14:09.000
그것은 Xcode 창 하단의 디버그 바에 있습니다.

00:14:09.000 --> 00:14:12.000
클릭하면, 새로운 메뉴가 나타납니다.

00:14:12.000 --> 00:14:16.000
이 메뉴를 사용하면 캡처 범위를 선택할 수 있습니다.

00:14:16.000 --> 00:14:23.000
기본값은 한 프레임을 캡처하는 것이지만, 캡처할 수 있는 수를 최대 5개까지 지정할 수 있습니다.

00:14:23.000 --> 00:14:42.000
또한 동일한 부모 장치 또는 명령 큐가 있는 여러 명령 버퍼와 특정 Metal 레이어를 나타내는 명령 버퍼, 심지어 MTLCaptureScope API를 사용하여 앱의 코드에서 정의할 수 있는 사용자 지정 범위를 캡처하도록 선택할 수 있습니다.

00:14:42.000 --> 00:14:51.000
이 새로운 컨트롤은 메탈 콜이 언제 어떻게 캡처되는지 결정할 때 즉시 사용할 수 있는 놀라운 전력을 제공합니다.

00:14:51.000 --> 00:14:56.000
다음으로, 금속 도서관과 파이프라인 상태에 대해 이야기해 봅시다.

00:14:56.000 --> 00:15:00.000
이것들은 Metal 앱의 필수 구성 요소입니다.

00:15:00.000 --> 00:15:07.000
그리고 Xcode 13에서 우리는 당신의 앱이 사용하고 있는 모든 파이프라인 상태와 라이브러리를 그 어느 때보다 쉽게 검사할 수 있도록 했습니다.

00:15:07.000 --> 00:15:11.000
이제, 그것이 실제로 어떻게 보이는지 봅시다.

00:15:11.000 --> 00:15:16.000
여기서, 저는 ModernRenderer 샘플 앱에서 GPU 추적을 캡처했습니다.

00:15:16.000 --> 00:15:23.000
나는 GBuffer 파이프라인 상태가 어떻게 작동하는지 보고 싶었고, 그래서 나는 이 무승부 호출을 선택했다.

00:15:23.000 --> 00:15:28.000
바인딩된 자원을 살펴보면, 이제 사용된 파이프라인 상태를 볼 수 있다.

00:15:28.000 --> 00:15:32.000
그것을 열면 Pipeline State Viewer로 이동합니다.

00:15:32.000 --> 00:15:39.000
여기에서, 나는 기능을 검토하고 파이프라인 상태가 만들어진 다른 속성을 볼 수 있다.

00:15:39.000 --> 00:15:49.000
또한, 뷰어에서 상태와 관련된 성능 데이터를 확인하거나 메모리 뷰어로 이동하여 상태를 표시할 수 있습니다.

00:15:49.000 --> 00:15:57.000
Xcode 13에서 메모리 뷰어는 이제 파이프라인 상태가 앱에서 얼마나 많은 메모리를 차지하고 있는지 보여줍니다.

00:15:57.000 --> 00:16:06.000
이것들은 앱의 GPU 흔적을 볼 때 메탈 디버거에서 파이프라인 상태를 더 쉽게 검사할 수 있는 추가 사항 중 일부일 뿐입니다.

00:16:06.000 --> 00:16:11.000
다음으로, 메탈 디버거의 셰이더 디버깅과 프로파일링에 대해 이야기해 봅시다.

00:16:11.000 --> 00:16:16.000
지금 당장, 이 기능들을 사용하고 싶다면, 두 가지 선택이 있습니다.

00:16:16.000 --> 00:16:21.000
첫 번째 옵션은 앱이 실행 중일 때 소스 코드에서 라이브러리를 컴파일하는 것입니다.

00:16:21.000 --> 00:16:30.000
두 번째, 더 나은 옵션은 오프라인에 내장된 소스로 Metallib 파일을 만든 다음 런타임에 로드하는 것입니다.

00:16:30.000 --> 00:16:37.000
하지만, App Store 규칙은 이러한 디버그 Metallibs로 앱을 게시하는 것을 허용하지 않습니다.

00:16:37.000 --> 00:16:54.000
이 모든 것은 라이브러리를 오프라인으로 컴파일하고 셰이더를 디버깅할 수 있기를 원한다면, 두 번 컴파일해야 한다는 것을 의미합니다: 한 번은 소스가 포함된 경우, 개발 중에 사용하기 위해, 한 번은 소스 없이 배포를 위해.

00:16:54.000 --> 00:16:57.000
올해, 우리는 그것을 바꾸고 있다.

00:16:57.000 --> 00:17:03.000
이제 Metallib을 컴파일하는 동안 소스 및 기타 디버깅 정보가 포함된 별도의 파일을 생성할 수 있습니다.

00:17:03.000 --> 00:17:14.000
이 파일들은 Metallibsym 확장자를 가지고 있으며, 라이브러리 자체에 추가 정보를 포함하지 않고도 셰이더를 디버깅하고 프로파일링할 수 있습니다.

00:17:14.000 --> 00:17:21.000
그것들을 따로 갖는 것의 가장 중요한 이점은 이제 같은 Metallib의 두 가지 버전을 가질 필요가 없다는 것입니다.

00:17:21.000 --> 00:17:34.000
또 다른 이점은 이러한 Metallibsym 파일을 사용하면 셰이더 소스를 손상시키지 않고도 앱의 릴리스 버전에서도 셰이더를 디버깅할 수 있다는 것입니다.

00:17:34.000 --> 00:17:42.000
셰이더 소스 파일을 Metallibsym 파일과 함께 Metallib로 컴파일하는 방법의 예를 보여드리겠습니다.

00:17:42.000 --> 00:17:48.000
Metallib을 정상적으로 컴파일하는 xcrun 터미널 명령으로 시작하겠습니다.

00:17:48.000 --> 00:17:58.000
Metallibsym 파일을 생성하려면, "플랫" 옵션으로 "레코드 소스" 플래그를 추가한 다음 컴파일러를 실행하기만 하면 됩니다.

00:17:58.000 --> 00:18:07.000
이제, 별도의 디버그 정보 파일로 컴파일된 셰이더를 디버깅하려고 할 때, 그것을 가져오라는 메시지가 표시됩니다.

00:18:07.000 --> 00:18:15.000
소스 가져오기를 클릭하면 모든 라이브러리와 소스 파일을 가져왔는지 여부를 나열하는 대화상자가 열립니다.

00:18:15.000 --> 00:18:25.000
여기에서 Metallibsym 파일을 가져올 수 있으며, 일단 가져오면 라이브러리와 소스가 자동으로 일치합니다.

00:18:25.000 --> 00:18:34.000
가져오기가 끝나면 대화상자를 닫을 수 있으며, 이제 셰이더의 소스를 보고 디버깅할 수 있습니다.

00:18:34.000 --> 00:18:38.000
내가 너에게 보여주고 싶은 마지막 디버깅 개선 사항이 하나 있어.

00:18:38.000 --> 00:18:48.000
그것은 "선택적 셰이더 디버깅"이라고 불린다. 앱이 큰 셰이더를 사용하는 경우, 셰이더 디버깅을 시작하는 데 시간이 걸릴 수 있다는 것을 알아차렸을 것입니다.

00:18:48.000 --> 00:18:53.000
그러한 경우를 돕기 위해, 올해, 우리는 선택적 셰이더 디버깅을 가져오고 있다.

00:18:53.000 --> 00:18:59.000
디버깅 범위를 좁히는 데 도움이 되므로 셰이더를 더 빨리 디버깅할 수 있습니다.

00:18:59.000 --> 00:19:03.000
그런 큰 셰이더 중 하나로 작동하는 것을 봅시다.

00:19:03.000 --> 00:19:08.000
이 GPU ASTCDecoder를 디버깅하고 싶습니다.

00:19:08.000 --> 00:19:14.000
이 전체 커널을 디버깅하려고 하면 셰이더 디버거를 시작하는 데 오랜 시간이 걸릴 것이라는 것을 알고 있습니다.

00:19:14.000 --> 00:19:23.000
그렇게 오래 기다리고 싶지 않아서, 대신 디버깅 범위를 이 함수인 decodeIntegerSequence로 좁힐 수 있습니다.

00:19:23.000 --> 00:19:28.000
그렇게 하려면, 마우스 오른쪽 버튼으로 클릭하고 디버그 함수를 선택할 수 있습니다.

00:19:28.000 --> 00:19:33.000
이것은 기능 범위가 이미 선택된 "디버그할 기능" 메뉴를 엽니다.

00:19:33.000 --> 00:19:40.000
이제, 디버거는 거의 즉시 시작될 것이다.

00:19:40.000 --> 00:19:45.000
선택적 셰이더 디버깅은 거대한 셰이더에서 버그를 빠르게 찾아내는 좋은 방법입니다.

00:19:45.000 --> 00:19:50.000
이것들은 제가 오늘 당신에게 보여주고 싶었던 모든 금속 공구 개선 사항입니다.

00:19:50.000 --> 00:19:54.000
그리고 이제, 아만다는 우리가 텍스처 압축에서 만든 발전에 대해 말해줄 것이다.

00:19:54.000 --> 00:19:56.000
아만다?

00:19:56.000 --> 00:19:57.000
고마워, Egor.

00:19:57.000 --> 00:20:02.000
올해 텍스처 압축 도구에 대한 업데이트를 안내해 드리겠습니다.

00:20:02.000 --> 00:20:08.000
도구에 뛰어들기 전에, 나는 애플 플랫폼에서 텍스처 압축의 기본에 대해 간략하게 논의할 것이다.

00:20:08.000 --> 00:20:13.000
이 경우 텍스처 압축은 텍스처 데이터의 고정 속도, 손실 압축이다.

00:20:13.000 --> 00:20:19.000
이것은 주로 데칼이나 일반 지도와 같은 정적 텍스처 데이터의 오프라인 압축을 위한 것입니다.

00:20:19.000 --> 00:20:24.000
런타임에 동적 텍스처 데이터를 압축할 수 있지만, 그것은 제가 오늘 다루고 있는 것이 아닙니다.

00:20:24.000 --> 00:20:31.000
대부분의 텍스처 압축은 텍스처를 블록으로 나누고 각 블록을 한 쌍의 색상으로 압축함으로써 작동합니다.

00:20:31.000 --> 00:20:38.000
이 쌍은 이러한 엔드포인트에서 보간된 다른 색상과 이 팔레트에서 선택하는 픽셀당 인덱스를 포함하여 현지화된 팔레트를 정의합니다.

00:20:38.000 --> 00:20:43.000
각 형식은 다른 종류의 텍스처 데이터에 맞는 다른 강점을 가지고 있다.

00:20:43.000 --> 00:20:50.000
Apple GPU는 또한 A12 장치에서 시작하는 무손실 프레임 버퍼 압축을 지원하며, 대역폭을 최적화하는 데 적합합니다.

00:20:50.000 --> 00:20:58.000
작년 세션 "GPU 카운터로 금속 앱과 게임 최적화"를 확인하여 GPU가 앱에 사용하는 메모리 대역폭 측정에 대해 자세히 알아보세요.

00:20:58.000 --> 00:21:07.000
또 다른 옵션은 이 프레젠테이션에서 다루고 있는 GPU 텍스처 압축 위에 텍스처 파일의 무손실 압축을 수행하는 것입니다.

00:21:07.000 --> 00:21:11.000
이렇게 하면 앱 다운로드 크기를 추가로 줄일 수 있습니다.

00:21:11.000 --> 00:21:17.000
이제 이 강연을 위해 텍스처 압축을 정의했으므로, 텍스처 압축이 앱에 가져올 수 있는 이점에 대해 이야기하겠습니다.

00:21:17.000 --> 00:21:21.000
텍스처 압축은 앱 개발에서 중요한 단계입니다.

00:21:21.000 --> 00:21:26.000
일반적으로, 게임의 대부분의 메모리 발자국은 텍스처로 구성되어 있다.

00:21:26.000 --> 00:21:34.000
텍스처 압축을 사용하면 더 많은 텍스처를 메모리에 로드하고, 더 자세한 텍스처를 사용하여 시각적으로 매력적인 게임을 만들 수 있습니다.

00:21:34.000 --> 00:21:39.000
압축을 사용하면 앱의 크기와 메모리 공간을 줄일 수 있습니다.

00:21:39.000 --> 00:21:45.000
이제 기본 사항을 다뤘으니, Apple 플랫폼에서 텍스처 압축 도구의 현재 상태에 대해 논의하겠습니다.

00:21:45.000 --> 00:21:50.000
iOS SDK의 기존 TextureTool은 비교적 간단한 파이프라인을 가지고 있다.

00:21:50.000 --> 00:21:59.000
TextureTool은 입력 이미지를 읽고, 원하는 경우 mipmaps를 생성하고, 텍스처를 압축하고, 블록 단위로 블록한 다음, 결과를 새 출력 파일에 씁니다.

00:21:59.000 --> 00:22:05.000
하지만 그래픽 알고리즘의 복잡성이 증가함에 따라, 텍스처는 고급 처리가 필요하다.

00:22:05.000 --> 00:22:14.000
이러한 프로세스의 핵심은 숫자 정밀도 간의 변환에서 반올림을 최소화하면서 올바른 색 공간에서 작업을 수행하는 것이다.

00:22:14.000 --> 00:22:24.000
이를 이해하기 위해, 우리는 텍스처 처리 정교함의 필요한 증가를 처리하고 새로운 옵션에 대한 액세스를 제공하기 위해 TextureConverter라는 새로운 압축 도구를 설계했습니다.

00:22:24.000 --> 00:22:31.000
Apple 플랫폼에서 텍스처 처리 파이프라인을 어떻게 개편했는지 자세히 살펴봅시다.

00:22:31.000 --> 00:22:39.000
텍스처 처리 파이프라인은 처음부터 다시 구축되어 TextureConverter로 모든 기능을 갖춘 텍스처 처리 파이프라인에 액세스할 수 있습니다.

00:22:39.000 --> 00:22:50.000
TextureConverter는 업계에서 인정받는 압축기 세트를 활용하여 다양한 압축 형식을 지원하며, 압축 속도와 이미지 품질을 절충할 수 있는 옵션을 제공합니다.

00:22:50.000 --> 00:22:58.000
사용할 압축기를 지정하거나 압축 형식, 품질 수준 및 기타 옵션에 따라 TextureConverter가 선택할 수 있도록 허용할 수 있습니다.

00:22:58.000 --> 00:23:04.000
각 단계는 이제 당신이 완전히 구성할 수 있으며, 텍스처 처리는 감마 인식입니다.

00:23:04.000 --> 00:23:13.000
모든 콘텐츠 파이프라인과의 통합을 지원하기 위해, TextureConverter는 macOS와 Windows 모두에서 사용할 수 있으며, Apple Silicon과 함께 사용하기에 최적화되어 있습니다.

00:23:13.000 --> 00:23:17.000
감마부터 시작하여 확장된 파이프라인의 각 단계를 살펴봅시다.

00:23:17.000 --> 00:23:22.000
감마 보정은 이미지의 휘도를 인코딩하고 디코딩하는 비선형 작업이다.

00:23:22.000 --> 00:23:25.000
텍스처는 많은 감마 공간에서 인코딩될 수 있다.

00:23:25.000 --> 00:23:29.000
최선의 선택은 텍스처가 나타내는 데이터 유형에 달려 있다.

00:23:29.000 --> 00:23:36.000
데칼이나 라이트 맵과 같은 대부분의 시각적 데이터는 sRGB와 같은 비선형 공간에서 인코딩될 때 가장 잘 수행됩니다.

00:23:36.000 --> 00:23:41.000
일반 지도와 같은 비시각적 데이터는 선형 공간에서 인코딩되어야 한다.

00:23:41.000 --> 00:23:45.000
이 선택은 필요한 어두운 영역에서 더 많은 정확성을 제공합니다.

00:23:45.000 --> 00:23:49.000
일반 지도와 같은 비시각적 데이터는 선형 공간에서 인코딩되어야 한다.

00:23:49.000 --> 00:23:55.000
압축은 "gamma_in"과 "gamma_out" 옵션으로 지정된 대상 색상 공간에서 수행되어야 합니다.

00:23:55.000 --> 00:24:03.000
선형 감마 공간에 대한 부동 값을 입력하거나 문자열 "sRGB"를 사용하여 해당 색상 공간을 지정할 수 있습니다.

00:24:03.000 --> 00:24:08.000
당신은 또한 이러한 옵션을 사용하여 다른 목표 공간으로 전환할 수 있는 유연성이 있습니다.

00:24:08.000 --> 00:24:13.000
Mipmap 생성과 같은 다른 작업은 선형 공간에서 수행되어야 한다.

00:24:13.000 --> 00:24:17.000
나는 지금 선형 공간 처리 단계를 걸을 것이다.

00:24:17.000 --> 00:24:26.000
이제 입력이 선형 감마 공간으로 변환되었으므로, 입력 텍스처가 지정된 대상 감마 공간으로 변환되기 전에 선형 공간 작업이 수행됩니다.

00:24:26.000 --> 00:24:34.000
세 단계는 물리적 변환, 렙맵 생성, 알파 처리이며, 이들 중 일부는 하위 단계가 있다.

00:24:34.000 --> 00:24:36.000
나는 물리적 변형으로 시작할 것이다.

00:24:36.000 --> 00:24:43.000
모든 축의 최대 크기를 정의함으로써, 최상위 mipmap에 필요한 대로 이미지를 축소할 수 있습니다.

00:24:43.000 --> 00:24:48.000
이 단계에서, 당신은 또한 크기 조정 필터와 크기 조정 반올림 모드를 제어할 수 있습니다.

00:24:48.000 --> 00:24:55.000
크기 조정 필터 옵션은 차원 크기가 내려갈 때 빤맵의 흐릿함을 줄이기 위해 다양한 알고리즘을 사용합니다.

00:24:55.000 --> 00:25:01.000
크기 조정 라운드 모드는 이미지 크기를 조정할 때 max_extent와 함께 사용됩니다.

00:25:01.000 --> 00:25:07.000
Max_extent를 초과하면, 원본 이미지의 측면을 유지하여 소스 이미지의 크기를 조정합니다.

00:25:07.000 --> 00:25:11.000
지정된 라운드 모드는 목표 치수를 찾을 때 사용됩니다.

00:25:11.000 --> 00:25:19.000
어떤 크기 조정 필터나 반올림 모드를 사용할지 확실하지 않다면, 우리는 대부분의 경우 잘 작동하는 기본값을 선택했습니다.

00:25:19.000 --> 00:25:27.000
그리고 이 단계의 플립 옵션을 사용하면 X, Y 및 Z 축의 선형 변환을 제어할 수 있습니다.

00:25:27.000 --> 00:25:34.000
변환 후 대부분의 일반적인 텍스처 처리 상황에서 사용되는 mipmap 생성입니다.

00:25:34.000 --> 00:25:43.000
Mipmaps는 렌더링 속도를 높이고 앨리어싱을 줄이는 데 사용되는 시퀀스보다 해상도를 줄이는 미리 계산된 이미지 시퀀스입니다.

00:25:43.000 --> 00:25:48.000
각 레벨의 높이와 너비는 이전 레벨보다 두 개의 작은 힘이다.

00:25:48.000 --> 00:25:55.000
Mipmap 생성을 사용자 정의할 때, 원하는 최대 수와 사용할 mip 필터를 지정하십시오.

00:25:55.000 --> 00:26:03.000
TextureConverter는 기본적으로 Kaiser 필터링이며, "상자" 및 "삼각형" 필터링 옵션이 있습니다.

00:26:03.000 --> 00:26:08.000
선형 공간 처리의 마지막 단계는 알파 처리이다.

00:26:08.000 --> 00:26:15.000
알파에서 커버리지가 활성화되면, 지정된 알파 참조 값을 사용하여 이것이 먼저 적용됩니다.

00:26:15.000 --> 00:26:18.000
알파 투 커버리지는 알파 블렌딩을 커버리지 마스크로 대체한다.

00:26:18.000 --> 00:26:29.000
안티앨리어싱 또는 반투명 텍스처를 사용하면 주문 독립적인 투명성을 제공하며, 게임에서 빽빽한 녹지를 렌더링하는 데 특히 유용한 도구입니다.

00:26:29.000 --> 00:26:36.000
그 후, 알파 채널을 폐기, 보존 또는 미리 곱할 수 있는 옵션이 제공됩니다.

00:26:36.000 --> 00:26:44.000
미리 곱한 알파에서, 이미지의 부분적으로 투명한 픽셀은 매트 색상으로 미리 곱해질 것입니다.

00:26:44.000 --> 00:26:52.000
선형 공간 처리 단계가 끝날 때, 우리는 목표 감마 공간으로 돌아가서 처리된 mip 레벨을 압축할 준비가 되었습니다.

00:26:52.000 --> 00:26:55.000
텍스처 처리의 마지막 단계는 압축이다.

00:26:55.000 --> 00:27:01.000
압축 단계는 채널 매핑과 인코딩의 두 하위 단계로 나눌 수 있다.

00:27:01.000 --> 00:27:08.000
채널 매핑은 특정 데이터 유형에 대한 범용 텍스처 압축 알고리즘을 최적화하는 기술이다.

00:27:08.000 --> 00:27:11.000
TextureConverter에서 채널 매핑을 지정하는 것은 선택 사항입니다.

00:27:11.000 --> 00:27:19.000
사용하고 싶다면, TextureConverter는 현재 채널 매핑의 두 가지 모드인 RGBM 인코딩과 일반 맵 인코딩을 지원합니다.

00:27:19.000 --> 00:27:24.000
나는 RGBM 인코딩을 시작으로 이 두 가지 형식을 더 깊이 다룰 것이다.

00:27:24.000 --> 00:27:35.000
RGBM 인코딩은 알파 채널에 승수를 저장하고 이 승수로 RGB 채널을 스케일링하여 LDR 형식으로 HDR 데이터를 압축하는 기술이다.

00:27:35.000 --> 00:27:38.000
여기 교실의 HDR 이미지 예시가 있습니다.

00:27:38.000 --> 00:27:44.000
그리고 여기 그레이스케일로 볼 수 있는 알파 채널에 저장된 승수와 같은 교실 이미지가 있습니다.

00:27:44.000 --> 00:27:49.000
코드 예제로 RGBM으로 인코딩할 승수를 계산하는 방법을 보여드리겠습니다.

00:27:49.000 --> 00:27:57.000
EncodeRGBM은 RGBM 인코딩 메커니즘을 이해하는 데 도움이 되는 단순화된 의사 코드 함수입니다.

00:27:57.000 --> 00:28:05.000
이 스니펫에는 RGBM의 범위를 설정하고 기본값을 6.0으로 설정하기 위한 새로운 매개 변수인 RGBM_Range의 사용이 포함되어 있습니다.

00:28:05.000 --> 00:28:15.000
RGBM 알파 값을 계산하기 위해, 승수는 먼저 입력 텍스처의 빨간색, 녹색 및 파란색 채널의 최대값을 결정할 것입니다.

00:28:15.000 --> 00:28:18.000
이것은 메탈의 max3 기능으로 이루어진다.

00:28:18.000 --> 00:28:21.000
그러면 이 최대값은 RGBM_Range로 나뉜다.

00:28:21.000 --> 00:28:36.000
인코딩된 RGBM의 빨간색, 녹색 및 파란색 채널 값을 계산하기 위해, 먼저 이전에 계산된 승수는 알파 채널의 저장 값을 조정하는 데 사용된 RGBM_Range로 다시 곱합니다.

00:28:36.000 --> 00:28:41.000
그런 다음, 입력 텍스처는 최종 승수 값으로 나뉩니다.

00:28:41.000 --> 00:28:49.000
셰이더에서 RGBM을 디코딩하려면, 인코딩 함수에서 보여준 것처럼 샘플의 RGB에 알파와 고정 계수를 곱합니다.

00:28:49.000 --> 00:28:53.000
DecodeRGBM 코드 스니펫을 살펴보고 어떻게 하는지 보여드리겠습니다.

00:28:53.000 --> 00:29:02.000
스케일링 계수는 승수가 저장된 RGBM 알파 채널에 RGBM_Range를 곱하여 재계산됩니다.

00:29:02.000 --> 00:29:09.000
원래 텍스처의 RGB는 RGBM 샘플에 계산된 승수를 곱하여 계산됩니다.

00:29:09.000 --> 00:29:14.000
이제 RGBM 인코딩을 소개했으니, 일반 지도 인코딩으로 넘어가겠습니다.

00:29:14.000 --> 00:29:20.000
대부분의 경우, 일반 지도를 언급할 때, 우리는 특히 객체 공간 일반 지도를 언급하고 있다.

00:29:20.000 --> 00:29:31.000
객체 공간에서 우리의 법절을 인코딩할 때, 우리는 각 법절이 단위 벡터라는 것을 알고 있으며, 이는 런타임에 사소하게 파생할 수 있는 세 번째 축을 가진 두 축으로 표현될 수 있다는 이점이 있다.

00:29:31.000 --> 00:29:42.000
이를 통해 이 두 채널을 다시 매핑하여 텍스처 압축 알고리즘을 최대한 활용하고 XYZ를 RGB로 압축하는 것에 비해 우수한 압축 품질을 달성할 수 있습니다.

00:29:42.000 --> 00:29:45.000
채널을 다시 매핑하는 방법은 압축 형식에 따라 다릅니다.

00:29:45.000 --> 00:29:51.000
이 차트를 가이드로 사용하여 ASTC로 노멀을 인코딩하는 예를 살펴보겠습니다.

00:29:51.000 --> 00:30:00.000
ASTC로 인코딩할 때, 빨간색, 녹색 및 파란색 채널은 X 구성 요소로 설정되고, 알파 채널은 Y 구성 요소로 설정됩니다.

00:30:00.000 --> 00:30:07.000
색상은 인코딩된 노멀을 샘플링할 때 X와 Y 구성 요소가 재할당될 채널에 해당합니다.

00:30:07.000 --> 00:30:16.000
TextureConverter는 일반 맵 매개 변수를 전달하면 선택한 형식으로 자동으로 리매핑하여 인코딩 리매핑을 처리합니다.

00:30:16.000 --> 00:30:21.000
셰이더에서 일반 맵을 샘플링할 때, 채널 매핑을 아는 것이 중요합니다.

00:30:21.000 --> 00:30:29.000
X 구성 요소는 빨간색 또는 알파 채널에서 읽히지만, Y 구성 요소는 압축 형식에 따라 알파 또는 녹색 채널에서 나옵니다.

00:30:29.000 --> 00:30:41.000
ASTC 예제로 돌아가서, 텍스처를 샘플링하기 위해, X 구성 요소는 빨간색 채널에서 샘플링되고, Y 구성 요소는 알파 채널에서 샘플링되며, 이는 정규가 인코딩된 방식의 반대입니다.

00:30:41.000 --> 00:30:49.000
모든 장치에서 최상의 품질을 달성하기 위해 여러 형식으로 인코딩하는 경우, 이 매핑은 런타임에 처리해야 합니다.

00:30:49.000 --> 00:30:55.000
나는 메탈 텍스처 스위즐을 사용하여 런타임 노멀 샘플링의 예를 살펴보겠습니다.

00:30:55.000 --> 00:31:02.000
다른 형식이 다른 채널 매핑을 사용하는 경우 여러 형식으로 인코딩하면 여러 셰이더 변형이 필요할 수 있습니다.

00:31:02.000 --> 00:31:07.000
이를 피하기 위해, 금속은 질감에 사용자 지정 스위즐을 적용할 수 있습니다.

00:31:07.000 --> 00:31:14.000
Swizzles를 사용하면 X 및 Y 구성 요소를 빨간색과 녹색 채널로 다시 매핑할 수 있으므로 셰이더가 압축 형식 중립적일 수 있습니다.

00:31:14.000 --> 00:31:22.000
다음은 이전에 다이어그램에서 본 것처럼 ASTC로 압축된 일반 지도를 위해 채널을 빨간색과 녹색으로 다시 매핑하는 예입니다.

00:31:22.000 --> 00:31:32.000
텍스처 설명자가 초기화된 후, 빨간색 채널은 MTLTextureSwizzleRed로 설정되고, 녹색 채널은 MTLTextureSwizzleAlpha로 설정됩니다.

00:31:32.000 --> 00:31:36.000
이것은 일반 지도이기 때문에, 샘플링에는 두 개의 채널만 필요합니다.

00:31:36.000 --> 00:31:46.000
빨간색과 녹색 채널은 이제 원래 빨간색과 알파 채널로 인코딩된 X와 Y 구성 요소에 할당되기 때문에, 파란색과 알파 채널은 0으로 설정됩니다.

00:31:46.000 --> 00:31:55.000
완료되면, 마지막 줄은 MTLTextureSwizzleChannelsMake를 사용하여 다시 매핑된 채널로 최종 스위즐을 조립하는 것입니다.

00:31:55.000 --> 00:32:00.000
X와 Y 채널이 셰이더에서 샘플링되면, Z 구성 요소를 재구성할 수 있습니다.

00:32:00.000 --> 00:32:06.000
어떻게 하는지 보여주기 위해 ReconstructNormal 기능을 안내해 드리겠습니다.

00:32:06.000 --> 00:32:14.000
첫째, 코드는 X와 Y 구성 요소를 올바른 범위로 리바이어스하며, 이는 정상에 대해 일대일로 음수이다.

00:32:14.000 --> 00:32:23.000
다음 단계는 점 곱의 결과가 올바른 기호를 갖도록 하기 위해 X와 Y 구성 요소의 점 곱을 하나에서 빼는 것이다.

00:32:23.000 --> 00:32:29.000
그런 다음 포화 기능은 0에서 1의 범위 내에서 이 결과를 고정하는 데 사용됩니다.

00:32:29.000 --> 00:32:36.000
Z 구성 요소를 계산하는 마지막 단계는 포화 함수 출력의 제곱근을 취하는 것이다.

00:32:36.000 --> 00:32:48.000
이제 채널 매핑에 사용할 수 있는 RGBM과 일반 지도 인코딩 옵션을 설명했으므로, 최종 압축 하위 상태인 인코딩으로 텍스처 압축 파이프라인에 대한 논의를 마치겠습니다.

00:32:48.000 --> 00:32:55.000
모든 TextureConverter 명령줄은 compression_format 인수를 사용하여 대상 압축 형식을 지정해야 합니다.

00:32:55.000 --> 00:33:04.000
또한 사용할 압축기를 지정하거나 TextureConverter가 선택한 압축 형식 및 기타 옵션에 따라 선택하도록 할 수 있습니다.

00:33:04.000 --> 00:33:08.000
이 네 가지 옵션에서 압축 품질을 선택할 수도 있습니다.

00:33:08.000 --> 00:33:20.000
압축 속도와 이미지 품질 사이에는 절충점이 있으며, 게임을 반복하는 동안 더 낮은 압축 품질을 선택할 수 있지만, 출시된 빌드에는 최고 품질을 사용할 수 있습니다.

00:33:20.000 --> 00:33:25.000
이제, 당신이 선택할 수 있는 텍스처 압축 형식을 다루겠습니다.

00:33:25.000 --> 00:33:30.000
다음은 Apple 플랫폼에서 지원되는 텍스처 압축 형식 제품군의 개요입니다.

00:33:30.000 --> 00:33:40.000
iOS 및 Apple Silicon 플랫폼은 ASTC 및 PVRTC 제품군을 지원하며, 모든 macOS 플랫폼은 BCn 제품군을 지원합니다.

00:33:40.000 --> 00:33:46.000
이 형식의 각 제품군을 더 자세히 살펴보고, 당신의 필요에 가장 적합한 것을 선택하는 데 도움이 되는 몇 가지 지침을 드리겠습니다.

00:33:46.000 --> 00:33:49.000
BCn 포맷으로 시작하겠습니다.

00:33:49.000 --> 00:33:58.000
BCn은 모두 4x4 픽셀 블록을 사용하여 작동하는 일곱 가지 형식 세트이며, 픽셀당 4비트 또는 8비트를 사용합니다.

00:33:58.000 --> 00:34:02.000
각 압축 형식은 다른 데이터 형식에 이상적입니다.

00:34:02.000 --> 00:34:16.000
BC1과 BC3는 일반적으로 RGB 및 RGBA 압축에 사용되며, BC6는 HDR 이미지에 이상적이며, 이중 독립 채널이 있는 BC5는 일반 지도 인코딩에 이상적입니다.

00:34:16.000 --> 00:34:25.000
다음은 LDR, sRGB 및 HDR 색 공간의 RGBA 형식 제품군인 ASTC입니다.

00:34:25.000 --> 00:34:33.000
ASTC 형식 제품군은 모든 크기에서 최고 품질을 허용하므로 PVRTC보다 더 일반적으로 권장됩니다.

00:34:33.000 --> 00:34:37.000
각 형식에 대한 픽셀당 비트와 품질 범위가 있습니다.

00:34:37.000 --> 00:34:45.000
ASTC를 사용하면, 각 블록의 바이트 크기는 형식에 관계없이 동일하지만, 그것이 나타내는 텍셀의 수는 다양하다.

00:34:45.000 --> 00:34:58.000
이것은 4x4 블록 크기에서 최고 품질의 압축이지만 가장 낮은 압축률과 12 x 12 블록 크기에서 가장 낮은 압축 품질이지만 가장 높은 압축률 사이의 연속성을 제공합니다.

00:34:58.000 --> 00:35:05.000
LDR, sRGB 및 HDR 변형은 압축된 ASTC 텍스처의 색상 범위를 설명합니다.

00:35:05.000 --> 00:35:17.000
LDR과 sRGB는 둘 다 선형 또는 sRGB 공간에서 0대1 범위에 있는 반면, HDR 변형은 0대1 범위를 벗어난 데이터를 위한 것이다.

00:35:17.000 --> 00:35:24.000
마지막으로, PVRTC 형식은 2비트 또는 4비트 모드에서 RGB 및 RGBA로 사용할 수 있습니다.

00:35:24.000 --> 00:35:36.000
이 형식의 데이터 블록은 항상 8바이트를 차지하므로, 2비트 모드에서는 8x4 픽셀마다 하나의 블록이 있고, 4비트 모드에서는 4x4 픽셀마다 하나의 블록이 있습니다.

00:35:36.000 --> 00:35:43.000
이제 지원되는 형식 제품군을 소개했으므로, 앱의 형식을 선택하기 위한 몇 가지 권장 사항을 드리겠습니다.

00:35:43.000 --> 00:35:55.000
iOS 장치에서는 A7 GPU 및 이전 버전을 지원하는 경우에만 PVRTC 압축 및 장치별 숱을 추가하여 항상 ASTC 압축을 기본적으로 사용해야 합니다.

00:35:55.000 --> 00:36:04.000
HDR 텍스처가 있다면, A13 이상 GPU에서 ASTC HDR을 활용할 수 있습니다.

00:36:04.000 --> 00:36:08.000
macOS의 경우, BCn은 전반적으로 사용할 수 있습니다.

00:36:08.000 --> 00:36:16.000
Apple Silicon Mac에서는 ASTC를 사용할 수 있는 옵션도 있으며, iOS 기기를 대상으로 하는 경우 이 옵션을 고려해야 합니다.

00:36:16.000 --> 00:36:24.000
PVRTC는 Apple Silicon에서 사용할 수 있지만, 이 옵션은 권장하지 않으며, iOS 레거시 지원만을 위한 것입니다.

00:36:24.000 --> 00:36:36.000
각 압축 형식 제품군 내에서 선택할 수 있는 다양한 형식이 있기 때문에, 앱에 가장 효과적인 텍스처 압축 형식을 선택하는 지침은 가능한 경우 텍스처별 및 대상별을 선택하는 것입니다.

00:36:36.000 --> 00:36:49.000
모든 텍스처가 RGB 또는 RGBA 데이터가 아니라면, 일반 데이터에 대해 두 개의 독립적인 채널로 압축할 수 있는 형식을 선택하는 것과 같이 압축하는 데이터 유형에 따라 압축 형식을 선택해야 합니다.

00:36:49.000 --> 00:36:54.000
ASTC 형식으로 압축할 때, 형식의 하위 집합을 선택할 수 있습니다.

00:36:54.000 --> 00:37:02.000
더 높은 압축 속도로 받아들일 수 있는 것보다 최고 품질이 필요한 텍스처의 버킷 텍스처를 고려하십시오.

00:37:02.000 --> 00:37:04.000
이제, 우리가 다룬 것을 검토해 봅시다.

00:37:04.000 --> 00:37:13.000
우리는 새로운 TextureConverter 도구로 파이프라인의 모든 단계를 완벽하게 제어할 수 있도록 TextureTool에서 텍스처 처리 파이프라인을 완전히 재구성했습니다.

00:37:13.000 --> 00:37:25.000
저는 이 새로운 파이프라인의 각 단계를 살펴보고 각 단계에서 사용할 수 있는 모든 옵션을 살펴보고, Apple 플랫폼에서 지원되는 채널 매핑 및 텍스처 압축 형식 제품군을 소개했습니다.

00:37:25.000 --> 00:37:35.000
TextureTool에서 TextureConverter로 워크플로우를 가능한 한 쉽게 업데이트하고 싶기 때문에, 명령줄을 전환할 수 있도록 호환성 모드를 추가했습니다.

00:37:35.000 --> 00:37:44.000
TextureTool 호환성 모드를 사용하거나 네이티브 옵션으로 TextureConverter를 호출하든, xcrun TextureConverter로 호출하십시오.

00:37:44.000 --> 00:37:49.000
다음은 TextureTool 옵션으로 호출되는 TextureConverter의 명령줄 예시입니다.

00:37:49.000 --> 00:38:01.000
TextureConverter는 옵션을 네이티브 TextureConverter 옵션으로 번역하고, 압축을 한 다음, 새로운 네이티브 옵션이 무엇인지 알려주므로 빌드 스크립트를 쉽게 업데이트할 수 있습니다.

00:38:01.000 --> 00:38:03.000
그것은 TextureConverter에 대한 소개였다.

00:38:03.000 --> 00:38:04.000
여기 그걸 얻는 방법이 있어.

00:38:04.000 --> 00:38:10.000
TextureConverter는 Xcode 13의 일부로 제공되며 시드 1에서 사용할 수 있습니다.

00:38:10.000 --> 00:38:19.000
Windows에서 TextureConverter는 developer.apple.com에서 사용할 수 있는 Metal Developer Tools for Windows 2.0 패키지의 일부로 배송됩니다.

00:38:19.000 --> 00:38:21.000
씨앗 1은 지금 이용 가능합니다.

00:38:21.000 --> 00:38:32.000
Windows에서는 레거시 iOS 플랫폼을 지원하기 위해 macOS에서 PVRTC를 사용할 수 있기 때문에 PVRTC 형식으로 압축을 지원하지 않는다는 점에 유의하십시오.

00:38:32.000 --> 00:38:37.000
Windows용 Metal Developer Tools의 또 다른 중요한 부분은 Windows용 Metal Compiler입니다.

00:38:37.000 --> 00:38:44.000
윈도우용 메탈 컴파일러는 작년에 메탈 셰이딩 언어 버전 2.3을 지원하여 도입되었다.

00:38:44.000 --> 00:38:48.000
일년 내내 업데이트는 Xcode에서 제공되는 메탈 컴파일러의 업데이트를 반영했다.

00:38:48.000 --> 00:38:55.000
최신 릴리스 버전은 1.2이며, Apple Silicon Macs의 Metal Shading Language에 대한 지원이 포함되어 있습니다.

00:38:55.000 --> 00:39:05.000
버전 2.0의 시드 1은 이제 Metal Shading Language 2.4의 모든 훌륭한 새로운 기능을 지원합니다.

00:39:05.000 --> 00:39:12.000
여기 우리가 오늘 다룬 모든 것에 대한 요약이 있습니다: Egor는 레이 트레이싱 및 기능 포인터와 같은 더 많은 금속 기능에 대한 지원에 대해 논의했습니다.

00:39:12.000 --> 00:39:23.000
그는 모든 Apple 플랫폼에서 GPU를 최대한 활용할 수 있도록 GPU 타임라인과 일관된 GPU 성능 상태와 같은 새로운 프로파일링 워크플로우를 도입했습니다.

00:39:23.000 --> 00:39:31.000
그리고 그는 셰이더 유효성 검사와 정확한 캡처 컨트롤에 대한 더 많은 지원을 제공하기 위해 이미 익숙한 디버깅 워크플로우의 개선을 시연했습니다.

00:39:31.000 --> 00:39:43.000
그리고 텍스처 처리 파이프라인과 Apple 플랫폼에서 사용할 수 있는 모든 지원되는 텍스처 압축 형식을 최대한 활용하는 데 도움이 되는 새로운 도구인 TextureConverter를 소개했습니다.

00:39:43.000 --> 00:39:46.000
고마워, 그리고 남은 WWDC 2021 잘 보내.

00:39:46.000 --> 23:59:59.000
[음악].

