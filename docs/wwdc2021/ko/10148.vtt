WEBVTT

00:00:02.000 --> 00:00:11.000
WWDC에 오신 것을 환영합니다.

00:00:11.000 --> 00:00:13.000
안녕하세요, 저는 조나단 메츠가입니다.

00:00:13.000 --> 00:00:16.000
저는 애플의 금속 생태계 팀의 일원입니다.

00:00:16.000 --> 00:00:21.000
우리는 게임 개발자들이 Apple GPU에서 최고의 그래픽 성능을 얻을 수 있도록 돕습니다.

00:00:21.000 --> 00:00:26.000
더스틴과 나는 애플 GPU를 위해 하이엔드 게임을 최적화하는 방법을 보여줄 것이다.

00:00:26.000 --> 00:00:30.000
이 비디오에서, 나는 우리가 게임을 최적화하는 데 사용하는 과정을 다룰 것이다.

00:00:30.000 --> 00:00:37.000
그런 다음, Baldur's Gate 3와 Metro Exodus 게임에 사용되는 최적화의 종류를 보여드리겠습니다.

00:00:37.000 --> 00:00:49.000
그리고 마지막으로, 더스틴은 게임 Divinity: Original Sin 2를 특징으로 하는 도구 시연을 할 것이며, Xcode 13에서 새로운 GPU 타임라인을 소개할 것이다.

00:00:49.000 --> 00:00:52.000
뛰어들어 최적화에 대해 이야기해 봅시다.

00:00:52.000 --> 00:01:00.000
그래서, 지난 한 해 동안, 우리는 Larian Studios 및 4A Games와 협력하여 Apple GPU용 게임의 그래픽 성능을 조정할 수 있는 방법을 찾았습니다.

00:01:00.000 --> 00:01:11.000
나는 당신이 세부 사항을 보게 되어 흥분할 것이라고 확신하며, 잠시 시간을 내어 이 프레젠테이션에서 개발 자료를 보여줄 수 있도록 허락해 주신 Larian Studios와 4A Games 모두에게 감사드립니다.

00:01:11.000 --> 00:01:19.000
한 해를 되돌아보면, 우리는 많은 게임을 분석하고 그래픽 성능에 영향을 미치는 몇 가지 일반적인 시나리오를 확인했습니다.

00:01:19.000 --> 00:01:31.000
당신은 아마도 자신의 게임을 최적화할 수 있는 기회를 찾는 데 관심이 있을 것이므로, 우리는 GPU 도구가 이러한 문제 영역을 정확히 찾아내고 이를 해결하는 방법을 제안하는 데 특히 어떻게 도움이 되는지 강조하기 위해 이 세션을 준비했습니다.

00:01:31.000 --> 00:01:37.000
그리고, 특히, 저는 우리 팀이 개발자들이 게임을 최적화할 수 있도록 돕기 위해 사용하는 몇 가지 원칙을 공유하고 싶습니다.

00:01:37.000 --> 00:01:45.000
그래픽 애플리케이션을 최적화할 때, 특정 문제를 해결하는 방법을 정의하는 일련의 원칙인 방법론을 갖는 것이 중요합니다.

00:01:45.000 --> 00:01:49.000
그래서, 4단계 과정을 보여드리겠습니다.

00:01:49.000 --> 00:01:56.000
먼저, 어떤 데이터를 수집하거나 측정할지 선택해야 하므로, 게임에서 무슨 일이 일어나고 있는지 이해하는 데 도움이 될 것입니다.

00:01:56.000 --> 00:02:02.000
데이터 측정을 시작한 직후, 몇 가지 성능 목표를 선택하거나, 완료했을 때 어디에 있고 싶은지 선택하고 싶을 것입니다.

00:02:02.000 --> 00:02:13.000
GPU 프레임 캡처 및 금속 시스템 추적, 장면 복잡성, 그래픽 설정 및 프레임 시간과 같은 기타 중요한 메트릭을 취할 게임 내 위치를 결정할 수 있습니다.

00:02:13.000 --> 00:02:17.000
그런 다음, 당신은 엔진의 동작에 대해 배우기 위해 데이터를 분석합니다.

00:02:17.000 --> 00:02:21.000
심층 분석은 병목 현상이 발생하는 장소와 이유를 찾는 데 도움이 됩니다.

00:02:21.000 --> 00:02:31.000
병목 현상을 일으키는 원인을 알게 되면, 게임을 개선할 수 있지만, 일반적으로 한 번에 한두 가지를 선택하므로 각 변경의 영향을 이해할 수 있습니다.

00:02:31.000 --> 00:02:37.000
마지막으로, 새로운 측정값을 원래 측정값과 비교하여 개선 사항을 확인합니다.

00:02:37.000 --> 00:02:43.000
최적화는 과정이기 때문에, 성과 목표가 달성될 때까지 돌아가서 반복할 것입니다.

00:02:43.000 --> 00:02:56.000
이러한 게임의 경우, 우리는 Xcode의 Metal Debugger를 사용하여 성능과 프레임 그래프가 어떻게 구성되어 있는지에 대한 통찰력을 제공하며, Instruments의 Metal System Trace를 사용하여 시간이 지남에 따라 게임의 성능에 대해 배웁니다.

00:02:56.000 --> 00:03:04.000
최적화 전후의 전후 데이터를 가질 수 있도록 GPU 추적 파일과 인스트루먼트 추적 파일을 저장하는 것은 좋은 생각입니다.

00:03:04.000 --> 00:03:10.000
그래서, 저는 당신이 게임에서 고려하거나 찾을 수 있는 것들의 작은 목록을 가지고 있습니다.

00:03:10.000 --> 00:03:16.000
제가 언급했듯이, Xcode와 Instruments는 Metal 애플리케이션을 이해하는 데 도움이 되는 훌륭한 도구입니다.

00:03:16.000 --> 00:03:22.000
최적화는 셰이더 성능에서 메모리 대역폭에 이르기까지 여러 영역을 최대한 활용하는 것입니다.

00:03:22.000 --> 00:03:28.000
또 다른 영역은 정점, 조각 및 컴퓨팅 워크로드에서 잘 겹치는 것입니다.

00:03:28.000 --> 00:03:34.000
그리고 비행 중 여러 프레임을 렌더링하는 동안, 일부 Apple GPU는 그들 사이의 워크로드와 겹칠 수 있다.

00:03:34.000 --> 00:03:40.000
중복을 방지할 수 있는 자원 의존성에 도움이 되는 몇 가지 포인터를 보여드리겠습니다.

00:03:40.000 --> 00:03:47.000
그리고 일부 개발자들은 셰이더에 사용자 지정 워크플로우를 사용하기 때문에, 컴파일러 설정이 성능에 어떤 영향을 미칠 수 있는지 보여드리겠습니다.

00:03:47.000 --> 00:03:53.000
마지막으로, 중복 바인딩의 영향을 줄이는 방법에 대해 이야기하겠습니다.

00:03:53.000 --> 00:03:58.000
라리안 스튜디오의 발더스 게이트 3부터 시작합시다.

00:03:58.000 --> 00:04:05.000
발두르의 게이트 3는 20년의 게임 유산을 기반으로 한 RPG 건물이며 영화 같은 시각 효과로 두드러진다.

00:04:05.000 --> 00:04:12.000
Larian Studios와의 협력은 Apple GPU를 위한 놀라운 렌더링 엔진을 최적화할 수 있는 방법을 식별하는 데 도움이 되었습니다.

00:04:12.000 --> 00:04:17.000
먼저, 우리는 여기서 볼 수 있는 황폐한 해변 장면과 같은 GPU 프레임 캡처로 시작했습니다.

00:04:17.000 --> 00:04:21.000
그런 다음, 우리는 그 장면을 프레임 그래프로 나눴다.

00:04:21.000 --> 00:04:26.000
프레임 그래프는 각 렌더링 패스의 순서와 목적에 대한 분석이다.

00:04:26.000 --> 00:04:36.000
하이엔드 게임에는 앰비언트 오클루전, 섀도우 매핑, 사후 처리 등과 같은 특정 시각 효과를 달성하는 데 특화된 많은 렌더링 패스가 있습니다.

00:04:36.000 --> 00:04:42.000
Baldur's Gate 3은 복잡한 프레임 그래프를 가지고 있으므로, 이것은 단순화된 버전이다.

00:04:42.000 --> 00:04:49.000
Xcode의 메탈 디버거를 사용하여 GPU 추적을 캡처하여 게임의 모든 렌더링 패스를 볼 수 있습니다.

00:04:49.000 --> 00:04:55.000
종속성 표시를 클릭하면 이동하고 확대/축소할 수 있는 시각화가 나타납니다.

00:04:55.000 --> 00:05:01.000
그것은 당신의 렌더링 패스가 무슨 일이 일어나고 있는지 이해하는 데 도움이 되는 이전 결과의 결과에 어떻게 의존하는지 보여줍니다.

00:05:01.000 --> 00:05:06.000
예를 들어, 나는 더 많은 세부 사항을 얻기 위해 이 지연된 데칼 렌더링 단계를 확대하고 있다.

00:05:06.000 --> 00:05:11.000
다음으로, 악기 도구를 보여드리겠습니다.

00:05:11.000 --> 00:05:18.000
우리는 악기 추적, 금속 시스템 추적 또는 게임 성능 템플릿을 사용하여 게임을 분석하는 데 시간을 할애합니다.

00:05:18.000 --> 00:05:30.000
Metal System Trace는 GPU 실행 및 스케줄링 분석에 집중하고 싶다면 이상적이며, 게임 성능은 스레드 스톨이나 열 알림과 같은 다른 문제를 해결하기 위해 확장됩니다.

00:05:30.000 --> 00:05:36.000
프레임에서 프레임까지 엔진의 동작을 보려면 Metal System Trace를 선택합시다.

00:05:36.000 --> 00:05:40.000
도구를 사용하면 타임라인을 따라 여러 채널의 데이터를 볼 수 있습니다.

00:05:40.000 --> 00:05:45.000
여기서, 우리는 첫 번째 문제를 찾습니다: 렌더링 패스의 값비싼 작업량.

00:05:45.000 --> 00:05:48.000
비싼 작업량은 우리가 셰이더를 최적화해야 한다는 것을 의미할 수 있다.

00:05:48.000 --> 00:05:52.000
예를 들어, 우리는 프레임의 나머지 부분을 지탱하는 긴 컴퓨팅 셰이더를 본다.

00:05:52.000 --> 00:05:55.000
우리는 이 틈을 "거품"이라고 부른다.

00:05:55.000 --> 00:06:00.000
GPU 추적으로 다시 전환하고 이것을 더 조사해 봅시다.

00:06:00.000 --> 00:06:02.000
이것은 "이전" GPU 추적이다.

00:06:02.000 --> 00:06:06.000
그룹을 API CALL에서 PIPELINE STATE로 변경합시다.

00:06:06.000 --> 00:06:11.000
파이프라인 상태가 실행 시간에 따라 정렬된다는 것을 알 수 있습니다.

00:06:11.000 --> 00:06:13.000
첫 번째 컴퓨팅 파이프라인을 확인해 봅시다.

00:06:13.000 --> 00:06:18.000
우리는 통계를 자세히 살펴보기 위해 계산 함수 세부 사항을 확장할 수 있습니다.

00:06:18.000 --> 00:06:22.000
여기에 4천 반 이상의 지침이 있다는 것을 주목하세요.

00:06:22.000 --> 00:06:25.000
그건 꽤 많아. 그래서, 또 뭐야?

00:06:25.000 --> 00:06:30.000
이 컴퓨팅 함수에서 어떤 자원이 사용되고 있는지 봅시다.

00:06:30.000 --> 00:06:36.000
입력 데이터에 따라, 이 기능은 최대 120개의 텍스처를 사용하여 출력을 생성합니다.

00:06:36.000 --> 00:06:42.000
그러나, 우리는 6개에서 12개만이 실제로 90%의 시간 동안 사용된다는 것을 발견했다.

00:06:42.000 --> 00:06:46.000
그래서, 이 셰이더가 어떻게 개선될 수 있는지에 대해 이야기해 봅시다.

00:06:46.000 --> 00:06:54.000
다양한 조건을 처리해야 하는 셰이더는 필요한 것보다 더 많은 레지스터를 예약할 수 있으며, 이는 병렬로 실행되는 스레드의 수를 줄일 수 있다.

00:06:54.000 --> 00:07:02.000
워크로드를 더 적은 레지스터가 필요한 더 작고 집중적인 셰이더로 나누면 셰이더 코어의 활용도를 향상시킬 수 있습니다.

00:07:02.000 --> 00:07:10.000
따라서 셰이더에서 적절한 알고리즘을 선택하는 대신 GPU 워크로드를 발행할 때 적절한 셰이더 순열을 선택할 수 있습니다.

00:07:10.000 --> 00:07:21.000
또한, 너무 많은 레지스터를 사용하는 셰이더 기능은 실행 장치에 빠른 레지스터 메모리가 부족하고 대신 장치 메모리를 사용해야 할 때 레지스터 압력을 초래할 수 있습니다.

00:07:21.000 --> 00:07:32.000
그것은 플로트와 같은 32비트 유형보다 레지스터 공간의 절반을 사용하기 때문에 적절한 경우 절반과 같은 16비트 유형을 사용하는 한 가지 이유입니다.

00:07:32.000 --> 00:07:41.000
이 경우, Larian Studios는 이미 반정밀 부동 소수점을 사용하도록 셰이더를 최적화했고 대신 전용 셰이더 변형을 만들기로 결정했습니다.

00:07:41.000 --> 00:07:44.000
그래서, 무슨 일이 일어났는지 보자.

00:07:44.000 --> 00:08:00.000
이전 숫자를 비교할 때, 왼쪽 상자의 오른쪽 상자의 숫자와 함께, 지침 수는 84% 감소했고, 분기는 90% 감소했고, 레지스터는 25% 감소했으며, 텍스처 읽기는 92% 감소했다.

00:08:00.000 --> 00:08:03.000
이 셰이더 변형은 90%의 시간 동안 사용된다.

00:08:03.000 --> 00:08:06.000
우리는 또한 금속 시스템 추적에서 이것을 볼 수 있다.

00:08:06.000 --> 00:08:12.000
여기, 이전 흔적에서, 우리가 이전에 본 거품에 주목하세요.

00:08:12.000 --> 00:08:15.000
그리고 여기, 사후 추적에서, 그것들은 최소화되었다.

00:08:15.000 --> 00:08:20.000
라리안 스튜디오는 이 셰이더를 평균 8밀리초 줄일 수 있었다.

00:08:20.000 --> 00:08:22.000
그건 엄청난 승리야!

00:08:22.000 --> 00:08:29.000
가장 비싼 파이프라인 상태 객체와 셰이더를 보면, 단순화될 수 있는 복잡한 셰이더를 찾을 수 있습니다.

00:08:29.000 --> 00:08:34.000
이것은 그 셰이더의 결과가 나중에 패스에 의해 사용되는 경우 특히 사실이다.

00:08:34.000 --> 00:08:39.000
이것은 게임에 대한 큰 개선이었지만, 개발자의 성능 목표에 미치지 못했다.

00:08:39.000 --> 00:08:47.000
우리는 방금 메모리를 문제로 언급했고, GPU의 기능 중 하나는 특정 조건에서 활성화되는 무손실 압축이다.

00:08:47.000 --> 00:08:51.000
그래서, 아마도 우리가 실수로 설정했거나 설정하는 것을 잊어버린 깃발이 있었을 것이다.

00:08:51.000 --> 00:09:00.000
무손실 압축은 타일에서 장치 메모리로 저장될 때 텍스처를 압축하여 대역폭을 줄이는 데 도움이 됩니다.

00:09:00.000 --> 00:09:07.000
요약 페이지의 대역폭 통찰력을 보면, 일부 텍스처에 대한 무손실 압축 경고를 알 수 있습니다.

00:09:07.000 --> 00:09:13.000
그들은 이러한 텍스처가 무손실 압축될 수 없으며, 대역폭 벌금을 지불할 수 있다고 말합니다.

00:09:13.000 --> 00:09:17.000
금속 디버거는 또한 이러한 텍스처를 무손실로 압축할 수 없는 이유를 알려줄 것입니다.

00:09:17.000 --> 00:09:21.000
여기서 우리는 그것이 ShaderWrite 사용 플래그 때문이라는 것을 알 수 있다.

00:09:21.000 --> 00:09:25.000
메모리 섹션으로 이동하여 모든 사용 플래그를 볼 수 있습니다.

00:09:25.000 --> 00:09:29.000
메모리 섹션에 들어가면, 렌더링 타겟으로 필터링할 수 있습니다.

00:09:29.000 --> 00:09:35.000
그런 다음, 테이블 헤더를 마우스 오른쪽 버튼으로 클릭하고, 텍스처를 선택한 다음, 사용을 선택하세요.

00:09:35.000 --> 00:09:41.000
이제, 우리는 사용량별로 정렬하고 ShaderWrite를 사용하여 텍스처를 찾을 수 있습니다.

00:09:41.000 --> 00:09:47.000
텍스처를 만들 때 ShaderWrite 또는 PixelFormatView 플래그를 설정하면 무손실 압축을 비활성화합니다.

00:09:47.000 --> 00:09:51.000
이 깃발들을 좀 더 자세히 살펴봅시다.

00:09:51.000 --> 00:09:57.000
Unknown, ShaderWrite 및 PixelFormatView 플래그는 텍스처가 무손실 압축되는 것을 방지합니다.

00:09:57.000 --> 00:10:01.000
일반적인 경험 법칙은 필요할 때만 이 깃발을 사용하는 것이다.

00:10:01.000 --> 00:10:09.000
예를 들어, write() 메서드를 사용하여 조각이나 계산 함수의 텍스처에 값을 저장하는 경우 ShaderWrite 플래그를 사용할 수 있습니다.

00:10:09.000 --> 00:10:14.000
색상 첨부 파일로 바인딩된 텍스처로 렌더링하려면 ShaderWrite 플래그가 필요하지 않습니다.

00:10:14.000 --> 00:10:19.000
그리고 구성 요소 값을 다른 순서로만 읽어야 하는 경우 PixelFormatView 옵션을 설정하지 마십시오.

00:10:19.000 --> 00:10:24.000
대신, 새로운 순서를 지정하기 위해 스위즐 패턴을 사용하여 텍스처 뷰를 만드세요.

00:10:24.000 --> 00:10:33.000
마찬가지로, 텍스처 뷰가 선형 공간과 sRGB 사이에서만 변환되는 경우 PixelFormatView 옵션을 설정하지 마십시오.

00:10:33.000 --> 00:10:35.000
자세한 내용은 문서를 확인하세요.

00:10:35.000 --> 00:10:46.000
셰이더 최적화와 무손실 압축은 우리에게 도움이 된 두 가지 기술이지만, 또 다른 문제 영역은 정점, 조각 및 컴퓨팅 채널에서 잘 겹치는 것이다.

00:10:46.000 --> 00:10:50.000
채널 전반에 걸쳐 워크로드를 최적화하는 두 가지 방법을 살펴봅시다.

00:10:50.000 --> 00:10:53.000
먼저, 우리는 금속 시스템 추적을 다시 보는 것으로 시작할 것이다.

00:10:53.000 --> 00:10:58.000
여기서, 우리는 정점, 조각 및 컴퓨팅 채널에서 중첩이 적다는 것을 알 수 있다.

00:10:58.000 --> 00:11:02.000
GPU를 바쁘게 유지하기 위해 이것을 개선하는 것이 좋을 것이다.

00:11:02.000 --> 00:11:07.000
이 문제를 해결하는 한 가지 방법은 프레임 그래프에서 인코딩 순서를 재구성할 수 있는지 확인하는 것이다.

00:11:07.000 --> 00:11:12.000
다시 말해, 우리는 이 작업을 정점 단계의 점유율이 매우 낮은 곳으로 옮기고 싶다.

00:11:12.000 --> 00:11:20.000
우리는 이전 렌더링 패스의 조각 단계와 함께 그 정점을 더 일찍 처리하고 싶습니다.

00:11:20.000 --> 00:11:26.000
우리는 프레임 그래프를 이 의사 코드 예제와 같은 렌더링 작업 목록으로 생각할 수 있습니다.

00:11:26.000 --> 00:11:31.000
잘 겹치는 것은 프레임 그래프에서 렌더링 작업의 순서를 변경하는 것만큼 간단할 수 있습니다.

00:11:31.000 --> 00:11:36.000
일부 작업은 이전 작업의 결과에 의존할 수 있지만, 항상 그런 것은 아니다.

00:11:36.000 --> 00:11:45.000
정점 셰이더가 무거운 CascadedShadowBuffer 단계는 종속성이 거의 없기 때문에 몇 가지 작업을 더 일찍 이동할 수 있다는 것이 밝혀졌다.

00:11:45.000 --> 00:11:53.000
그리고 이제, 우리는 중첩이 적은 우리 지역이 정점과 조각 채널을 더 잘 활용하여 우리에게 또 다른 1ms의 승리를 제공한다는 것을 알 수 있다.

00:11:53.000 --> 00:11:57.000
하지만 우리가 시도해 볼 수 있는 또 다른 최적화가 있다.

00:11:57.000 --> 00:12:00.000
게임은 종종 두 개에서 세 개의 프레임을 가지고 있다.

00:12:00.000 --> 00:12:11.000
따라서 타일 기반 지연 렌더링 또는 TBDR 아키텍처 GPU의 멋진 기능은 리소스 종속성이 없을 때 두 프레임의 워크로드를 겹치는 것입니다.

00:12:11.000 --> 00:12:15.000
그래서, 나는 너에게 이 가능성을 위해 최적화하는 방법을 보여줄 거야.

00:12:15.000 --> 00:12:19.000
인스트루먼트의 GPU 트랙을 다시 한 번 살펴봅시다.

00:12:19.000 --> 00:12:24.000
여기서, 당신은 이 프레임들이 거의 연속적으로 처리되는 것을 볼 수 있습니다.

00:12:24.000 --> 00:12:32.000
이것은 blit 인코더를 사용하여 프레임당 애니메이션 데이터와 같은 일정한 버퍼를 업데이트함으로써 발생합니다.

00:12:32.000 --> 00:12:43.000
개별 GPU로 일정한 버퍼 데이터를 효율적으로 업데이트하기 위해, 우리는 CPU의 공유 버퍼에서 프레임을 렌더링하는 데 사용될 GPU의 개인 버퍼로 전송합니다.

00:12:43.000 --> 00:12:51.000
이 전략은 개별 메모리가 있는 GPU에 효율적이므로, 그 목적을 위해 이 동작을 유지하고 싶습니다.

00:12:51.000 --> 00:12:59.000
장치에 통합 메모리 아키텍처가 있다면, blit 인코더를 사용하여 데이터를 개인 버퍼에 복사할 필요가 없습니다.

00:12:59.000 --> 00:13:12.000
그러나 링 버퍼 패턴에서 공유 버퍼를 사용할 때, CPU가 현재 GPU에서 읽고 있는 데이터에 쓰면 시각적 손상이 발생할 수 있기 때문에 동기화 문제를 주의해야 합니다.

00:13:12.000 --> 00:13:16.000
이것이 실제로 실행되는지 봅시다.

00:13:16.000 --> 00:13:21.000
여기서, 당신은 이 다이어그램에서 프레임의 인코딩과 렌더링을 볼 수 있습니다.

00:13:21.000 --> 00:13:31.000
우리는 프레임의 시작 부분에 업데이트되는 공유 버퍼를 나타내기 위해 색상을 사용하고 있습니다: 버퍼 1의 경우 파란색, 버퍼 2의 경우 녹색, 버퍼 3의 경우 노란색.

00:13:31.000 --> 00:13:38.000
링 버퍼는 일반적으로 컴팩트한 양의 메모리를 사용해야 하는 대기열을 구현하는 데 사용됩니다.

00:13:38.000 --> 00:13:46.000
여기서, 공유 버퍼에 대한 우리의 작성과 읽기가 상호 배타적이기 때문에, 이 배열에 대한 데이터 경쟁 조건에 대한 우려는 없습니다.

00:13:46.000 --> 00:13:51.000
프레임 인코딩과 프레임 렌더링 사이에 지연이 있는 것은 매우 일반적이다.

00:13:51.000 --> 00:13:55.000
이것은 렌더링이 실제로 시작될 때의 변화를 일으킨다.

00:13:55.000 --> 00:13:59.000
대기 시간이 너무 길지 않는 한, 데이터 경합 상태가 없을 것입니다.

00:13:59.000 --> 00:14:04.000
하지만, 대기 시간이 계속 증가하면 어떻게 되나요?

00:14:04.000 --> 00:14:12.000
음, 이것은 GPU가 프레임을 렌더링하는 동안 메인 스레드가 공유 버퍼를 업데이트하는 데이터 경쟁 조건을 소개합니다.

00:14:12.000 --> 00:14:18.000
그리고 그런 일이 발생하면, 프레임의 요소가 이 데이터에 의존한다면 시각적 손상을 받을 수 있습니다.

00:14:18.000 --> 00:14:30.000
Baldur's Gate 3의 경우, 개인 버퍼와 blit 인코더를 제거하면 동기화 지점이 제거되었지만, 일시적인 안티앨리어싱 렌더링 패스에 영향을 미치는 경쟁 조건을 도입했다.

00:14:30.000 --> 00:14:34.000
그래서, 이 상황을 피하는 방법을 봅시다.

00:14:34.000 --> 00:14:40.000
이 경쟁 조건을 피하려면, GPU가 읽고 있는 것과 동일한 리소스에 기록하지 않도록 해야 합니다.

00:14:40.000 --> 00:14:48.000
예를 들어, 완료 핸들러를 활용한 다음, 인코딩 스레드에서 공유 버퍼를 업데이트하는 것이 안전할 때까지 기다릴 수 있습니다.

00:14:48.000 --> 00:14:53.000
하지만 우리가 어떻게 대기 시간을 피했는지 보여줄게.

00:14:53.000 --> 00:14:59.000
우리는 완료 핸들러를 유지했지만, 대기를 피하기 위해 링 버퍼에 추가 버퍼를 추가했습니다.

00:14:59.000 --> 00:15:02.000
추가 버퍼는 하단 다이어그램에서 보라색으로 칠해 있다.

00:15:02.000 --> 00:15:06.000
메모리 소비는 개별 GPU와 동일하게 유지됩니다.

00:15:06.000 --> 00:15:13.000
하지만 메모리를 절약해야 하고 CPU 대기 시간이 게임의 프레임 속도에 영향을 미치지 않는다면, 세 개의 버퍼를 사용할 수 있습니다.

00:15:13.000 --> 00:15:22.000
그래서, 의사 코드 예제로 얼마나 많은 공유 및 개인 버퍼를 만들 것인지 결정하는 쉬운 방법을 살펴봅시다.

00:15:22.000 --> 00:15:29.000
이 코드 스니펫에서는 초기화 시 공유 및 개인 버퍼 수를 선택하는 방법을 볼 수 있습니다.

00:15:29.000 --> 00:15:39.000
장치를 만들면, 장치에 통합 메모리가 있는지 확인한 다음 추가 공유 버퍼를 만들거나 개인 버퍼를 사용할 수 있습니다.

00:15:39.000 --> 00:15:47.000
이 추가 버퍼는 데이터 경합 상태를 피하기 위해 사용하는 완료 핸들러를 기다리는 영향을 줄이는 데 도움이 될 것입니다.

00:15:47.000 --> 00:15:54.000
그리고 이제, 우리는 이전 프레임의 조각 워크로드가 다음 프레임의 정점 워크로드와 어떻게 겹치는지 볼 수 있습니다.

00:15:54.000 --> 00:15:58.000
전반적으로, 이것은 현장에 따라 우리에게 1~2밀리초를 줄 수 있다.

00:15:58.000 --> 00:16:09.000
그리고 물론, 이 접근 방식은 이 예제에서 보여준 일정한 버퍼 데이터뿐만 아니라 CPU에서 GPU로 전송하는 모든 버퍼 데이터에 적용될 수 있습니다.

00:16:09.000 --> 00:16:11.000
그럼, 검토해 봅시다.

00:16:11.000 --> 00:16:33.000
Larian Studios는 다음과 같은 최적화를 적용하여 성능 목표를 달성할 수 있었습니다: 거품을 줄이기 위해 가장 비싼 셰이더를 최적화하고, 대역폭을 개선하기 위해 무손실 압축을 선택하고, 더 나은 GPU 활용을 얻기 위해 정점 및 프래그먼트 워크로드를 겹치고, 프레임 중첩을 방지하는 리소스 종속성을 확인합니다.

00:16:33.000 --> 00:16:41.000
그들이 끝났을 때, Larian Studios는 성능 목표를 달성했을 뿐만 아니라, 게임의 프레임 시간이 33% 개선되었다.

00:16:41.000 --> 00:16:47.000
그리고 이제, 우리는 메트로 엑소더스 게임으로 다른 최적화 세트를 살펴볼 것이다.

00:16:47.000 --> 00:16:54.000
메트로 엑소더스는 이 일련의 게임 플레이 클립에서 볼 수 있듯이 서사시적인 스토리와 까다로운 시각 효과로 유명합니다.

00:16:54.000 --> 00:17:00.000
우리가 제안한 최적화를 통합한 후, 4A Games는 성능 목표를 달성할 수 있었다.

00:17:00.000 --> 00:17:05.000
이제, 메트로 엑소더스의 게임 내 장면을 살펴봅시다.

00:17:05.000 --> 00:17:13.000
Metro Exodus는 사용자 지정 워크플로우를 사용하여 렌더링 명령을 Metal API 명령으로 변환하며, 이는 크로스 플랫폼 게임에서 매우 일반적입니다.

00:17:13.000 --> 00:17:22.000
그들이 사용하고 있는 번역 계층은 금속에 최적화되어 있지만, 실제로 두 개의 복잡한 시스템이 함께 모일 때 몇 가지 문제가 발생할 수 있다.

00:17:22.000 --> 00:17:28.000
그래서, 그들의 프로젝트 목표를 달성하기 위해 추가적인 성능 튜닝이 필요했다.

00:17:28.000 --> 00:17:33.000
이전 게임과 마찬가지로, 우리는 프레임이 어떻게 렌더링되는지 조사하는 것으로 시작합니다.

00:17:33.000 --> 00:17:40.000
현대 렌더러는 다양한 기술을 가지고 있으므로 먼저 높은 수준의 프레임 그래프를 이해하려고 노력합니다.

00:17:40.000 --> 00:17:44.000
다시 말하지만, 우리는 GPU 추적을 보고 분석을 시작합니다.

00:17:44.000 --> 00:17:48.000
그것은 항상 우리에게 게임 성능에 대한 유용한 통찰력을 제공한다.

00:17:48.000 --> 00:17:53.000
그래서 먼저, 개발자 성능 목표를 충족시키지 못하는 GPU 시간부터 시작합시다.

00:17:53.000 --> 00:17:57.000
그래서, 가장 시간이 많이 걸리는 셰이더나 파이프라인을 찾아봅시다.

00:17:57.000 --> 00:18:03.000
이것을 하기 위해, 우리는 다시 한 번 파이프라인 상태별로 그룹화하고 가장 비싼 것을 살펴볼 것이다.

00:18:03.000 --> 00:18:06.000
그것의 통계를 빨리 살펴봅시다.

00:18:06.000 --> 00:18:12.000
합계에 비해 ALU 지침이 많다는 것을 알 수 있습니다. 즉, 이것은 수학이 많은 셰이더입니다.

00:18:12.000 --> 00:18:17.000
우리는 또한 셰이더가 사용하는 레지스터의 수가 꽤 많다는 것을 알 수 있다.

00:18:17.000 --> 00:18:23.000
특정 셰이더가 사용하는 레지스터의 수는 실행 중에 워크로드가 어떻게 확장되는지에 직접적인 영향을 미친다.

00:18:23.000 --> 00:18:28.000
이 숫자가 높을수록, GPU가 병렬로 수행할 수 있는 작업이 줄어든다.

00:18:28.000 --> 00:18:41.000
때로는 많은 계산과 레지스터가 필요한 이 예제의 SSAO와 같은 복잡한 셰이더일 뿐이지만, 때로는 컴파일러 설정이 생성된 명령과 레지스터 할당에도 영향을 미칠 수 있습니다.

00:18:41.000 --> 00:18:44.000
셰이더 컴파일러 옵션도 살펴봅시다.

00:18:44.000 --> 00:18:48.000
그리고 이 셰이더는 빠른 수학 플래그가 비활성화된 상태에서 컴파일된 것으로 밝혀졌다.

00:18:48.000 --> 00:18:56.000
빠른 수학을 통해 셰이더 컴파일러는 다양한 명령을 최적화할 수 있으며, 기본적으로 메탈 셰이더 컴파일러에 사용할 수 있습니다.

00:18:56.000 --> 00:19:03.000
그러나, 예를 들어 사용자 지정 셰이더 워크플로우를 사용하여 이 컴파일 플래그를 비활성화할 수 있는 경우가 있을 수 있습니다.

00:19:03.000 --> 00:19:13.000
이 경우, 우리는 4A Games가 컴파일러를 호출하는 데 사용하고 있던 번역 계층이 빠른 수학을 사용하지 않도록 기본 동작이 설정되어 있다는 것을 발견했습니다.

00:19:13.000 --> 00:19:15.000
그래서, 빠른 수학이 뭐야?

00:19:15.000 --> 00:19:22.000
빠른 수학은 속도와 정확성 사이에서 거래되는 부동 소수점 산술을 위한 일련의 최적화이다.

00:19:22.000 --> 00:19:30.000
예를 들어, 결과나 인수로 NAN, 무한대 또는 부호 있는 0이 없을 것이라고 가정할 수 있다.

00:19:30.000 --> 00:19:39.000
빠른 수학 최적화는 또한 대수적으로 동등한 변환을 적용할 수 있으며, 이는 부동 소수점 결과의 정밀도에 영향을 미칠 수 있다.

00:19:39.000 --> 00:19:43.000
그러나 대부분의 시나리오에서, 빠른 수학은 게임을 위한 훌륭한 선택이다.

00:19:43.000 --> 00:19:48.000
이것은 특히 ALU에 묶인 경우 성능을 크게 향상시킬 수 있다.

00:19:48.000 --> 00:20:00.000
셰이더가 방금 언급한 것에 의존하지 않는다면, 빠른 수학을 활성화했는지 확인하기 위해 컴파일러 옵션을 확인하는 것이 좋습니다.

00:20:00.000 --> 00:20:04.000
빠른 수학 플래그는 프론트엔드와 백엔드 컴파일러 수준에서 작동한다.

00:20:04.000 --> 00:20:12.000
셰이더 소스를 구축할 때, 프런트 엔드 셰이더 컴파일러는 중간 코드에 사용될 빠른 수학 함수를 선택합니다.

00:20:12.000 --> 00:20:18.000
이것은 백엔드 셰이더 컴파일러에 더 최적의 GPU 기계 코드를 생성할 수 있다는 것을 암시할 것이다.

00:20:18.000 --> 00:20:26.000
여기서, 이 셰이더를 다시 컴파일한 후 오른쪽 상자에서 왼쪽의 지침과 등록 카운터가 어떻게 개선되었는지 볼 수 있습니다.

00:20:26.000 --> 00:20:38.000
그래서, 모든 셰이더에 대한 빠른 수학을 가능하게 하기 위해 번역 레이어의 동작을 변경한 후, 우리는 내장된 게임 벤치마크를 사용하여 테스트 워크로드에서 21% 프레임 시간을 줄였습니다.

00:20:38.000 --> 00:20:43.000
그래서, 내가 이야기하고 싶은 다음 영역은 중복 바인딩이다.

00:20:43.000 --> 00:20:51.000
요약 페이지로 돌아가서 API 통찰력을 보면, 프레임을 렌더링할 때 많은 중복 바인딩이 있다는 것을 알 수 있습니다.

00:20:51.000 --> 00:21:01.000
중복 바인딩은 텍스처, 버퍼 및 샘플러와 같은 리소스 또는 깊이 스텐실 상태, 뷰포트 구성 등과 같은 렌더링 상태일 수 있습니다.

00:21:01.000 --> 00:21:11.000
리소스를 반복적으로 바인딩하면 인코딩 시간에 부정적인 영향을 미칠 수 있지만, 중복 렌더링 상태 변경은 GPU 시간에도 영향을 미칠 수 있습니다.

00:21:11.000 --> 00:21:16.000
Metal System Trace의 인코딩과 GPU 시간을 살펴봅시다.

00:21:16.000 --> 00:21:24.000
주어진 프레임의 경우, 모든 명령을 인코딩하는 데 8밀리초 반이 걸리고 GPU가 이 프레임을 렌더링하는 데 약 22밀리초가 걸린다.

00:21:24.000 --> 00:21:32.000
중복 바인딩의 원인을 조사했을 때, 우리는 번역 계층이 그것들을 줄이기 위해 수정될 수 있다는 것을 발견했다.

00:21:32.000 --> 00:21:38.000
그래서, 중복 바인딩을 확인하고 줄이는 방법을 보여주는 의사 코드 예제를 보여드리겠습니다.

00:21:38.000 --> 00:21:45.000
텍스처를 인코더에 직접 바인딩하는 대신, 미리 캐시하고 변경된 경우에만 바인딩할 수 있습니다.

00:21:45.000 --> 00:21:56.000
그리고 API와의 상호 작용을 최소화하기 위해, 하나씩 루프에서 설정하는 대신 setFragmentTextures 메소드를 한 번 호출하여 모든 텍스처를 설정할 수 있습니다.

00:21:56.000 --> 00:22:04.000
또한, 다른 셰이더 단계와 버퍼 및 샘플러와 같은 다른 바인딩 유형과 렌더링 상태에 유사한 접근 방식을 적용할 수 있습니다.

00:22:04.000 --> 00:22:09.000
그래서, Metal System Trace에서 무슨 일이 일어났는지 봅시다.

00:22:09.000 --> 00:22:21.000
4A 게임은 번역 레이어가 동일한 리소스와 렌더링 상태를 반복적으로 바인딩하지 않았기 때문에 장면에 따라 30%에서 50% 사이의 인코딩 시간을 줄일 수 있었다.

00:22:21.000 --> 00:22:29.000
그러나 GPU 시간도 최대 3밀리초까지 감소했고, 전반적으로 게임 내 벤치마크에서 15%의 속도가 빨라졌다.

00:22:29.000 --> 00:22:39.000
몇 가지 중복 바인딩 경고가 있다면, 그것은 문제가 되지 않지만, 우리는 확실히 수백 또는 수천 개의 중복 바인딩에 영향을 미칩니다.

00:22:39.000 --> 00:22:45.000
그래서, 중복 바인딩을 피하면 평균 프레임 시간이 15% 더 단축되었다.

00:22:45.000 --> 00:22:50.000
이 두 가지 개선 후, 4A Games는 성능 목표를 달성할 수 있었다.

00:22:50.000 --> 00:22:57.000
이제, Apple GPU를 위해 Metro Exodus를 최적화하면서 배운 것을 요약해 봅시다.

00:22:57.000 --> 00:23:06.000
먼저, 셰이더에 대한 사용자 지정 워크플로우를 사용하는 경우, 컴파일러 설정을 확인하여 Metal 애플리케이션에 가장 적합한 옵션을 사용하고 있는지 확인해야 합니다.

00:23:06.000 --> 00:23:17.000
그리고 메탈 디버거에서 중복 바인딩 경고를 많이 본다면, 엔진이나 사용 중인 번역 계층에 적용할 수 있는 인코딩 및 GPU 시간 오버헤드를 줄이는 기술을 보여주었습니다.

00:23:17.000 --> 00:23:27.000
그리고 이제, 저는 그것을 Divinity: Original Sin 2에 대해 이야기하고 새로운 Xcode GPU 타임라인 기능을 시연할 Dustin에게 넘겨주고 싶습니다.

00:23:27.000 --> 00:23:29.000
고마워, 조나단.

00:23:29.000 --> 00:23:33.000
안녕하세요, 제 이름은 더스틴이고, 저는 여기 애플의 GPU 소프트웨어 팀에서 일하고 있습니다.

00:23:33.000 --> 00:23:41.000
그리고 오늘, 저는 Larian Studios 히트 타이틀인 Divinity: Original Sin 2의 초기 빌드를 최적화하는 실습 데모를 보여드리게 되어 기쁩니다.

00:23:41.000 --> 00:23:48.000
작년에, Larian은 비평가들의 찬사를 받은 롤플레잉 게임 Divinity: Original Sin 2를 iPad에 가져올 것이라고 발표했다.

00:23:48.000 --> 00:23:55.000
그리고 지난 한 해 동안, 라리안은 애플 GPU에서 훌륭하게 실행되도록 게임을 최적화하기 위해 열심히 노력했으며, 이 게임은 매우 재미있다.

00:23:55.000 --> 00:24:09.000
라리안은 새로운 GPU 타임라인을 추가하여 올해 Xcode 13에서 더 나아지고 있는 메탈 디버거와 메탈 시스템 트레이스의 훌륭한 도구 세트의 도움으로 이러한 결과를 달성할 수 있었다.

00:24:09.000 --> 00:24:15.000
앞서 캡처한 Divinity: Original Sin 2의 프레임을 살펴보는 것으로 시작합시다.

00:24:15.000 --> 00:24:22.000
우리는 당신이 게임을 디버깅하고 최적화할 때 당신을 안내하는 데 도움이 되는 프레임의 개요가 포함된 요약 페이지에 있습니다.

00:24:22.000 --> 00:24:30.000
요약 페이지에서, 우리는 새로운 GPU 타임라인을 포함하여 메탈 디버거가 제공하는 모든 훌륭한 도구로 빠르게 이동할 수 있습니다.

00:24:30.000 --> 00:24:34.000
그리고 여기에 접근하는 것은 여기서 새로운 성능 페이지를 클릭하는 것만큼 쉽습니다.

00:24:34.000 --> 00:24:37.000
그래서, 내가 가서 그걸 할게.

00:24:37.000 --> 00:24:40.000
새로운 GPU 타임라인을 소개합니다.

00:24:40.000 --> 00:24:47.000
타임라인은 각 GPU 파이프라인 단계를 병렬로 실행할 수 있는 Apple GPU의 고유한 아키텍처를 중심으로 설계되었습니다.

00:24:47.000 --> 00:24:57.000
성능을 극대화하기 위해, 우리는 타임라인을 통해 쉽게 볼 수 있는 중복을 극대화하여 모든 파이프라인 단계를 가능한 한 바쁘게 유지해야 합니다.

00:24:57.000 --> 00:25:00.000
타임라인은 두 섹션으로 구성되어 있다.

00:25:00.000 --> 00:25:11.000
상단에는 각 파이프라인 단계에 대한 별도의 트랙으로 구성된 GPU 섹션이 있어 어떤 단계가 활성화되고 병렬로 실행되는지 쉽게 볼 수 있습니다.

00:25:11.000 --> 00:25:29.000
아래에는 셰이더 점유, 대역폭 및 성능 제한기와 같은 큐레이팅된 중요한 카운터 세트가 포함된 카운터 섹션이 있어 GPU의 시스템 성능이 워크로드 과정에서 어떻게 변하는지에 대한 더 깊은 통찰력을 제공합니다.

00:25:29.000 --> 00:25:35.000
GPU 트랙의 인코더는 클릭 한 번으로 더 많은 유용한 정보를 제공합니다.

00:25:35.000 --> 00:25:41.000
렌더링 인코더를 선택하면 현재 선택된 항목에 대한 추가 정보가 포함된 타임라인의 사이드바가 나타납니다.

00:25:41.000 --> 00:25:49.000
이 경우, 사이드바에는 텍스처 세부 사항, 로드/저장 작업 및 그리기 호출 수와 같은 렌더링 패스 정보가 포함되어 있습니다.

00:25:49.000 --> 00:25:57.000
렌더링 인코더는 두 개의 셰이더 단계로 구성되어 있기 때문에 정점과 조각 단계도 강조 표시됩니다.

00:25:57.000 --> 00:26:06.000
대신 조각 트랙을 선택하면, 사이드바에는 타임라인의 모든 인코더가 포함되어 있으며, 시간에 따라 정렬할 수 있습니다.

00:26:06.000 --> 00:26:15.000
하지만 그것이 전부는 아닙니다. 왜냐하면 우리가 조각 트랙을 확장하여 셰이더 타임라인을 공개할 수 있기 때문입니다. 셰이더 타임라인은 실행 중에 인코더가 사용하는 모든 셰이더를 보여줍니다.

00:26:15.000 --> 00:26:22.000
우리는 오래 지속되는 셰이더와 다른 셰이더와 병렬로 실행되는 셰이더를 쉽게 식별할 수 있습니다.

00:26:22.000 --> 00:26:26.000
조각 트랙의 경우, 로드/저장 작업을 위한 두 개의 추가 트랙이 있습니다.

00:26:26.000 --> 00:26:38.000
이것은 GPU가 로컬 메모리와 메인 메모리 사이에 첨부 텍스처를 로드하고 저장할 때를 볼 수 있는 데 유용하며, 대역폭 사용을 줄이기 위해 중요한 고려 사항입니다.

00:26:38.000 --> 00:26:49.000
셰이더를 선택하면 타임라인에서 활성화된 모든 영역이 강조 표시되며, 사이드바에 표시된 컴파일러 통계 및 런타임 성능 메트릭에서 자세히 알아볼 수 있습니다.

00:26:49.000 --> 00:27:01.000
셰이더 타임라인을 확장하면 각 셰이더가 자체 트랙에 표시되며, 이는 GPU 워크로드의 흐름과 셰이더 실행 순서를 이해하는 데 유용합니다.

00:27:01.000 --> 00:27:13.000
이제 새로운 GPU 타임라인에 좀 더 익숙하고 직접 사용할 수 있는 모든 방법을 생각했으므로, GPU 타임라인을 사용하여 성능 병목 현상을 찾는 것이 얼마나 쉬운지 보여드리겠습니다.

00:27:13.000 --> 00:27:26.000
셰이더 성능은 많은 요인의 결과로 어려움을 겪을 수 있으며, 그 중 하나는 레지스터 압력이며, 이런 일이 발생하면 GPU는 빠른 레지스터 메모리가 부족하고 대신 메인 메모리를 사용해야 합니다.

00:27:26.000 --> 00:27:30.000
높은 ALU 제한기만으로는 성능 병목 현상을 나타내지 않는다.

00:27:30.000 --> 00:27:33.000
당신의 셰이더가 수학이 무거울 수도 있습니다.

00:27:33.000 --> 00:27:43.000
그러나, 낮은 셰이더 점유율과 결합될 때, 이것은 셰이더가 레지스터 압력을 경험하는 지표가 될 수 있으며, 이로 인해 셰이더가 느려질 수 있습니다.

00:27:43.000 --> 00:27:57.000
오늘의 데모에서 이것을 더 잘 강조하기 위해, 왼쪽에 있는 "플러스" 버튼을 클릭하여 ALU 트랙과 셰이더 점유 트랙을 타임라인 상단에 고정하겠습니다.

00:27:57.000 --> 00:28:08.000
내가 이 두 트랙을 스캔할 때, 내가 가장 먼저 알아차린 것은 ALU가 급증하고 동시에 셰이더 점유가 떨어지는 이 지역이다.

00:28:08.000 --> 00:28:12.000
타임라인에서 영역을 강조하여 실행하는 데 얼마나 걸리는지 볼 수 있습니다.

00:28:12.000 --> 00:28:17.000
제가 이것을 할 때, 사이드바의 카운터는 선택한 지역에 따라 동적으로 업데이트됩니다.

00:28:17.000 --> 00:28:21.000
이 지역은 실행하는 데 약 3.7밀리초가 걸린다.

00:28:21.000 --> 00:28:25.000
확대해서 자세히 살펴봅시다.

00:28:25.000 --> 00:28:30.000
우리의 문제는 앰비언트 오클루전 패스의 처음 네 개의 인코더와 관련이 있는 것 같습니다.

00:28:30.000 --> 00:28:36.000
셰이더 타임라인을 보고 어떤 셰이더가 사용되고 있는지 봅시다.

00:28:36.000 --> 00:28:41.000
우리의 문제는 사용 중인 유일한 셰이더이기 때문에 이 셰이더와 관련이 있는 것 같습니다.

00:28:41.000 --> 00:28:52.000
사이드바의 런타임 성능 지표에서, 이 셰이더 ALU 집약적일 뿐만 아니라 플로트도 무겁기 때문에, 부동 소수점 활용 트랙을 살펴봅시다.

00:28:52.000 --> 00:28:56.000
내가 이 트랙 위에 마우스를 올려놓을 때, 이 셰이더는 F32만 사용하고 있다.

00:28:56.000 --> 00:28:59.000
F16은 0%이다.

00:28:59.000 --> 00:29:06.000
타임라인에서, 우리는 셰이더를 마우스 오른쪽 버튼으로 클릭하고 열어 셰이더 소스로 직접 이동할 수 있습니다.

00:29:06.000 --> 00:29:12.000
여기 소스 편집기에서, 우리는 데모 목적으로 셰이더 소스의 단순화된 버전을 볼 수 있습니다.

00:29:12.000 --> 00:29:18.000
소스와 함께, 우리는 또한 셰이더 프로파일러의 도움으로 라인당 비용 정보를 볼 수 있습니다.

00:29:18.000 --> 00:29:28.000
셰이더 프로파일러 파이 차트 위에 마우스를 올려놓으면 ALU와 플로트가 무겁기 때문에 이 기능이 레지스터 압력을 유발할 가능성이 있음을 확인할 수 있습니다.

00:29:28.000 --> 00:29:41.000
이와 같은 상황은 F16을 사용하기 위한 후보이며, 이는 F32의 완전한 정밀도가 필요하지 않은 곳에서 레지스터의 양을 두 배로 제공하며, 이는 레지스터 압력을 줄이는 데 도움이 될 것이다.

00:29:41.000 --> 00:29:46.000
메탈 디버거를 사용하면 소스 편집기 내에서 직접 소스 코드를 업데이트하는 것이 정말 편리합니다.

00:29:46.000 --> 00:29:54.000
F32와 F16의 혼합물을 사용하는 셰이더의 업데이트된 버전을 사용하는 변경을 드리겠습니다.

00:29:54.000 --> 00:30:08.000
이 변경을 한 후, 하단의 "쉐이더 다시 로드" 버튼을 클릭하면 셰이더 업데이트를 트리거하여 셰이더를 다시 컴파일하고 다시 프로파일하고 라인당 셰이더 비용을 업데이트할 수 있습니다.

00:30:08.000 --> 00:30:12.000
타임라인으로 돌아가서 이 변화가 어떤 영향을 미쳤는지 봅시다.

00:30:12.000 --> 00:30:20.000
내가 가장 먼저 하고 싶은 것은 앰비언트 오클루전 패스의 처음 네 개의 인코더가 얼마나 오래 걸리는지 보는 것이다.

00:30:20.000 --> 00:30:25.000
여기 이 지역은 실행하는 데 약 2.6밀리초가 걸리는 것 같다.

00:30:25.000 --> 00:30:34.000
우리가 방금 만든 변화는 셰이더 실행 시간을 1밀리초 이상 또는 30% 향상시켰으며, 이는 엄청난 개선이다.

00:30:34.000 --> 00:30:41.000
이전의 카운터 중 일부를 살펴보면, ALU는 여전히 높지만, 그것은 수학이 많은 셰이더에 대해 예상될 것이다.

00:30:41.000 --> 00:30:48.000
하지만 이제 주목하세요, 우리의 셰이더 점유가 거의 두 배로 향상됨에 따라, 우리의 셰이더는 등록 압력을 덜 경험하고 있습니다.

00:30:48.000 --> 00:30:56.000
이것은 부동 소수점 활용 트랙을 사용하여 볼 수 있는 F32와 F16의 혼합물을 사용하여 달성되었다.

00:30:56.000 --> 00:31:04.000
GPU 타임라인은 내가 문제를 식별하고, 문제가 있는 곳으로 이동하고, 그것을 고치는 것을 정말 쉽게 만들었다.

00:31:04.000 --> 00:31:13.000
GPU 타임라인은 셰이더 성능 문제뿐만 아니라 메모리 대역폭 및 기타 여러 종류의 문제를 식별할 수 있는 훌륭한 도구입니다.

00:31:13.000 --> 00:31:24.000
새로운 GPU 타임라인의 데모를 즐겼고 Apple GPU에서 더 잘 실행되도록 게임을 최적화하는 데 사용할 모든 방법을 이미 생각하고 있기를 바랍니다.

00:31:24.000 --> 00:31:27.000
감사합니다, 그리고 나머지 WWDC를 즐기세요.

00:31:27.000 --> 00:31:28.000
조나단에게 돌아가.

00:31:28.000 --> 00:31:31.000
더스틴, 그 놀라운 데모 고마워.

00:31:31.000 --> 00:31:33.000
그리고 봐줘서 고마워.

00:31:33.000 --> 00:31:40.000
Apple GPU의 기능을 활용하기 위해 Larian Studios 및 4A Games와 어떻게 협력했는지 공유하게 되어 기쁩니다.

00:31:40.000 --> 00:31:46.000
그들은 무손실 압축에서 겹치는 셰이더 워크로드에 이르기까지 성능을 향상시키는 많은 방법을 제공합니다.

00:31:46.000 --> 00:31:53.000
그리고 Metal System Trace와 Xcode의 새로운 GPU 타임라인과 같은 우리의 도구는 게임을 개선할 때 정말 도움이 될 것입니다.

00:31:53.000 --> 00:32:03.000
내가 당신에게 남길 수 있는 한 가지가 있다면, 당신의 렌더링에 대한 철저한 검사는 고도로 최적화된 게임을 제공하는 데 필수적이며, 우리의 도구는 당신을 돕기 위해 있습니다.

00:32:03.000 --> 00:32:17.000
더 자세히 알고 싶다면, 올해 WWDC의 관련 세션인 "금속 디버깅, 프로파일링 및 자산 생성 도구 발견" 또는 WWDC20의 "GPU 카운터로 금속 앱 및 게임 최적화"를 참조하십시오.

00:32:17.000 --> 00:32:20.000
고마워, 그리고 잘 가!

00:32:20.000 --> 23:59:59.000
[음악].

