WEBVTT

00:00:00.000 --> 00:00:05.000
♪ 베이스 음악 연주 ♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:14.000
코트랜드 이드스트롬: 안녕하세요, 제 이름은 코트랜드 이드스트롬이고, 저는 RealityKit 팀의 엔지니어입니다.

00:00:14.000 --> 00:00:19.000
이 비디오에서는 RealityKit 2의 새로운 렌더링 기능을 사용하는 방법을 보여드리겠습니다.

00:00:19.000 --> 00:00:24.000
RealityKit은 AR 앱을 간단하고 직관적으로 구축할 수 있도록 설계된 프레임워크입니다.

00:00:24.000 --> 00:00:30.000
렌더링은 매우 사실적이고 물리적으로 기반한 렌더링을 중심으로 하는 RealityKit의 핵심 부분이다.

00:00:30.000 --> 00:00:36.000
2019년 첫 출시 이후, 우리는 당신의 피드백을 위해 노력해 왔으며 RealityKit에 대한 주요 업데이트를 배송하고 있습니다.

00:00:36.000 --> 00:00:52.000
"Dive into Reality Kit 2" 세션에서, 우리는 ECS 시스템 업데이트, 더 진화된 재료 및 애니메이션 기능, 런타임에 오디오 및 텍스처 리소스 생성에 이르기까지 많은 개선 사항을 제공하는 RealityKit의 진화를 다루었습니다.

00:00:52.000 --> 00:00:58.000
이러한 개선 사항을 보여주기 위해, 우리는 당신의 거실을 수중 수족관으로 바꾸는 앱을 만들었습니다.

00:00:58.000 --> 00:01:02.000
이 강연에서, 우리는 앱에 들어간 새로운 렌더링 기능 중 일부를 보여줄 것이다.

00:01:02.000 --> 00:01:10.000
RealityKit 2는 객체가 렌더링되는 방식에 대한 제어와 유연성을 제공하여 더 나은 AR 경험을 만들 수 있습니다.

00:01:10.000 --> 00:01:18.000
올해 우리는 재료 시스템에 발전을 가져다주며, 맞춤형 금속 셰이더를 작성하여 자신만의 재료를 추가할 수 있습니다.

00:01:18.000 --> 00:01:24.000
사용자 지정 포스트 효과를 사용하면 RealityKit의 포스트 효과를 직접 보강할 수 있습니다.

00:01:24.000 --> 00:01:31.000
새로운 메쉬 API는 런타임에 메쉬 생성, 검사 및 수정을 허용합니다.

00:01:31.000 --> 00:01:37.000
RealityKit 2에서 가장 많이 요청된 기능부터 시작하겠습니다. 사용자 지정 셰이더를 지원합니다.

00:01:37.000 --> 00:01:41.000
RealityKit의 렌더링은 물리적 기반 렌더링 모델을 중심으로 한다.

00:01:41.000 --> 00:01:47.000
내장된 셰이더를 사용하면 다양한 조명 조건에서 실제 물체 옆에 자연스럽게 보이는 모델을 쉽게 만들 수 있습니다.

00:01:47.000 --> 00:01:56.000
올해, 우리는 이러한 물리적 기반 셰이더를 구축하고 셰이더를 사용하여 모델의 기하학과 표면을 사용자 정의할 수 있는 능력을 노출하고 있습니다.

00:01:56.000 --> 00:01:59.000
우리의 셰이더 API 중 첫 번째는 지오메트리 수정자이다.

00:01:59.000 --> 00:02:10.000
지오메트리 수정자는 금속 셰이딩 언어로 작성된 프로그램으로, GPU에서 렌더링되는 모든 프레임에서 객체의 정점을 변경할 수 있는 기회를 제공합니다.

00:02:10.000 --> 00:02:16.000
여기에는 그것들을 옮기고 색상, 일반 또는 UV와 같은 속성을 사용자 정의하는 것이 포함됩니다.

00:02:16.000 --> 00:02:24.000
그것은 RealityKit의 정점 셰이더 내부에서 실행되며, 주변 애니메이션, 변형, 입자 시스템 및 광고판에 적합합니다.

00:02:24.000 --> 00:02:27.000
우리의 해초는 앰비언트 애니메이션의 좋은 예이다.

00:02:27.000 --> 00:02:31.000
해초는 주변의 물의 움직임으로 인해 천천히 움직이고 있다.

00:02:31.000 --> 00:02:33.000
좀 더 자세히 살펴보자.

00:02:33.000 --> 00:02:41.000
여기서 당신은 우리 예술가가 만든 해초의 와이어프레임을 볼 수 있습니다; 이것은 메쉬를 구성하는 정점과 삼각형을 보여줍니다.

00:02:41.000 --> 00:02:46.000
우리는 모션을 만들기 위해 각 정점에서 실행되는 셰이더 프로그램을 작성할 것이다.

00:02:46.000 --> 00:02:50.000
우리는 움직임을 만들기 위해 간단한 주기 함수인 사인파를 사용할 것이다.

00:02:50.000 --> 00:02:59.000
우리는 물 흐름을 시뮬레이션하고 있으므로 근처의 정점이 모델의 규모나 방향에 관계없이 비슷하게 작동하기를 원합니다.

00:02:59.000 --> 00:03:04.000
이러한 이유로, 우리는 정점의 세계 위치를 사인 함수에 대한 입력으로 사용합니다.

00:03:04.000 --> 00:03:08.000
우리는 시간이 지남에 따라 움직일 수 있도록 시간 값도 포함합니다.

00:03:08.000 --> 00:03:12.000
우리의 첫 번째 사인파는 업다운 움직임을 만들기 위해 Y차원에 있다.

00:03:12.000 --> 00:03:16.000
운동 기간을 제어하기 위해, 우리는 공간 스케일을 추가할 것이다.

00:03:16.000 --> 00:03:21.000
그리고 우리는 진폭으로 그 움직임의 양을 통제할 수 있다.

00:03:21.000 --> 00:03:26.000
우리는 X와 Z 차원에 동일한 기능을 적용하여 세 축 모두에서 움직일 것입니다.

00:03:26.000 --> 00:03:30.000
이제, 모델 전체를 살펴봅시다.

00:03:30.000 --> 00:03:39.000
우리가 아직 설명하지 않은 한 가지: 줄기의 바닥에 가까운 정점은 움직일 여지가 거의 없는 반면, 꼭대기에 있는 것들은 움직일 수 있는 가장 높은 자유를 가지고 있다.

00:03:39.000 --> 00:03:53.000
이것을 시뮬레이션하기 위해, 우리는 물체의 원점에 대한 정점의 y 좌표를 세 축 모두의 스케일링 요소로 사용할 수 있으며, 이는 우리에게 최종 공식을 제공합니다.

00:03:53.000 --> 00:03:58.000
이제 셰이더에 대한 계획이 있으니, 이 매개 변수를 어디서 찾을 수 있는지 살펴봅시다.

00:03:58.000 --> 00:04:02.000
기하학 매개 변수는 몇 가지 범주로 구성되어 있다.

00:04:02.000 --> 00:04:07.000
첫 번째는 유니폼이며, 한 프레임 내의 물체의 모든 정점에 대해 동일한 값이다.

00:04:07.000 --> 00:04:10.000
우리는 해초를 위한 시간이 필요해.

00:04:10.000 --> 00:04:18.000
텍스처에는 모델의 일부로 작성된 모든 텍스처와 당신이 적합하다고 생각하는 대로 사용할 수 있는 추가 사용자 지정 슬롯이 포함되어 있습니다.

00:04:18.000 --> 00:04:26.000
재료 상수에는 색조 또는 불투명도 스케일과 같은 매개 변수가 있으며, 객체로 작성되거나 코드를 통해 설정됩니다.

00:04:26.000 --> 00:04:32.000
기하학에는 현재 정점의 모델 위치 또는 정점 ID와 같은 읽기 전용 값이 포함되어 있습니다.

00:04:32.000 --> 00:04:38.000
우리는 해초 운동을 위한 모델과 세계 위치가 모두 필요하다.

00:04:38.000 --> 00:04:44.000
기하학은 또한 일반, UV 및 모델 위치 오프셋을 포함한 읽기-쓰기 값을 가지고 있다.

00:04:44.000 --> 00:04:49.000
오프셋을 계산하면, 정점을 이동하기 위해 여기에 저장할 것입니다.

00:04:49.000 --> 00:04:52.000
메탈 셰이더에 뛰어들자.

00:04:52.000 --> 00:04:55.000
우리는 RealityKit.h를 포함하는 것으로 시작합니다.

00:04:55.000 --> 00:04:59.000
이제 우리는 보이는 함수 속성을 가진 함수를 선언합니다.

00:04:59.000 --> 00:05:04.000
이것은 컴파일러가 다른 기능과 별도로 사용할 수 있도록 지시한다.

00:05:04.000 --> 00:05:09.000
이 함수는 RealityKit의 geometry_parameters인 단일 매개 변수를 사용합니다.

00:05:09.000 --> 00:05:12.000
우리는 이 객체를 통해 모든 값을 검색할 것이다.

00:05:12.000 --> 00:05:18.000
매개 변수의 기하학 멤버를 사용하여, 우리는 세계 위치와 모델 위치를 모두 요청할 것이다.

00:05:18.000 --> 00:05:24.000
다음으로 우리는 정점과 시간의 세계 위치에 따라 위상 오프셋을 계산합니다.

00:05:24.000 --> 00:05:29.000
그런 다음 우리는 이 정점의 오프셋을 계산하기 위해 공식을 적용합니다.

00:05:29.000 --> 00:05:34.000
우리는 정점의 모델 위치에 추가될 지오메트리에 오프셋을 저장합니다.

00:05:34.000 --> 00:05:39.000
우리는 기하학 수정자를 가지고 있지만, 아직 해초에 연결되지 않았다.

00:05:39.000 --> 00:05:43.000
Swift로 작성된 ARView 하위 클래스로 전환합시다.

00:05:43.000 --> 00:05:47.000
셰이더가 포함된 앱의 기본 메탈 라이브러리를 로드하는 것으로 시작합니다.

00:05:47.000 --> 00:05:52.000
다음으로 셰이더의 이름과 라이브러리를 사용하여 geometryModifier를 구성합니다.

00:05:52.000 --> 00:05:56.000
해초의 각 재료에 대해, 우리는 새로운 맞춤형 재료를 만듭니다.

00:05:56.000 --> 00:06:07.000
우리는 기존 재료를 첫 번째 매개 변수로 CustomMaterial에 전달하여 기하학 수정자를 추가하면서 기본 재료에서 텍스처와 재료 특성을 상속합니다.

00:06:07.000 --> 00:06:12.000
꽤 좋아 보여! 우리가 물 속에 있기 때문에, 우리는 애니메이션을 꽤 느리게 유지했다.

00:06:12.000 --> 00:06:19.000
진폭과 위상을 조정함으로써, 같은 효과가 잔디, 나무 또는 다른 단풍으로 확장될 수 있다.

00:06:19.000 --> 00:06:23.000
이제 기하학을 수정하는 방법을 보여줬으니, 음영에 대해 이야기해 봅시다.

00:06:23.000 --> 00:06:28.000
이것은 수중 장면의 문어이며, 내장된 셰이더로 멋지게 보입니다.

00:06:28.000 --> 00:06:32.000
그들이 하는 것처럼, 우리의 문어는 여러 외모 사이에서 전환한다.

00:06:32.000 --> 00:06:35.000
두 번째 모습은 붉은 색이다.

00:06:35.000 --> 00:06:40.000
우리 예술가는 각 모양에 대해 하나씩 두 가지 기본 색상 텍스처를 작성했습니다.

00:06:40.000 --> 00:06:46.000
색상 변화 외에도, 붉은 문어는 더 높은 거칠기 값을 가지고 있어 반사성이 줄어든다.

00:06:46.000 --> 00:06:52.000
그리고, 우리의 문어를 더욱 특별하게 만들기 위해, 우리는 외모 사이에 멋진 전환을 만들고 싶었다.

00:06:52.000 --> 00:06:56.000
여기서 당신은 작동 중인 전환을 볼 수 있습니다.

00:06:56.000 --> 00:06:58.000
매혹적인.

00:06:58.000 --> 00:07:05.000
각 모양은 물리적 기반 재료로 설명될 수 있지만, 전환 자체를 위해 표면 셰이더를 작성해야 합니다.

00:07:05.000 --> 00:07:07.000
그래서 표면 셰이더가 뭐야?

00:07:07.000 --> 00:07:11.000
표면 셰이더를 사용하면 물체의 모양을 정의할 수 있습니다.

00:07:11.000 --> 00:07:15.000
그것은 물체의 보이는 모든 픽셀에 대해 프래그먼트 셰이더 내부에서 실행된다.

00:07:15.000 --> 00:07:22.000
색상 외에도, 여기에는 정상, 반사 및 거칠기와 같은 표면 특성이 포함됩니다.

00:07:22.000 --> 00:07:28.000
물체의 모양을 향상시키거나 완전히 대체하여 새로운 효과를 만드는 셰이더를 작성할 수 있습니다.

00:07:28.000 --> 00:07:31.000
우리는 문어의 두 가지 기본 색상 질감을 보았다.

00:07:31.000 --> 00:07:36.000
전환 효과를 위해, 우리 예술가는 우리를 위해 특별한 질감을 인코딩했다.

00:07:36.000 --> 00:07:40.000
이 질감은 실제로 세 개의 다른 층의 조합이다.

00:07:40.000 --> 00:07:44.000
상단에 지역화된 전환 패턴을 만드는 노이즈 레이어가 있다.

00:07:44.000 --> 00:07:51.000
우리는 머리에서 시작하여 촉수를 향해 움직이는 전반적인 움직임을 지시하는 전환층을 가지고 있다.

00:07:51.000 --> 00:07:59.000
그리고 촉수의 눈과 밑면과 같이 우리가 색을 바꾸고 싶지 않은 부분을 위한 마스크 레이어가 있습니다.

00:07:59.000 --> 00:08:06.000
이 세 개의 레이어는 사용자 지정 텍스처 슬롯에 할당하는 텍스처의 빨간색, 녹색 및 파란색 채널로 결합됩니다.

00:08:06.000 --> 00:08:12.000
텍스처를 설정한 후, 표면 셰이더에서 이것들에 접근하는 방법을 살펴봅시다.

00:08:12.000 --> 00:08:18.000
기하학 수정자와 유사하게, 표면 셰이더는 균일, 질감 및 재료 상수에 접근할 수 있다.

00:08:18.000 --> 00:08:21.000
시간은 우리의 문어 전환에 대한 입력이다.

00:08:21.000 --> 00:08:29.000
우리는 모델로 작성된 텍스처를 샘플링하고 재료 상수를 읽어 아티스트가 모델 전체를 조정할 수 있도록 할 것입니다.

00:08:29.000 --> 00:08:33.000
위치, 정상 또는 UV와 같은 기하학은 기하학 구조에 나타난다.

00:08:33.000 --> 00:08:37.000
이것들은 버텍스 셰이더의 보간된 출력이다.

00:08:37.000 --> 00:08:40.000
우리는 UV0을 질감 좌표로 사용할 것이다.

00:08:40.000 --> 00:08:42.000
표면 셰이더는 표면 구조를 쓴다.

00:08:42.000 --> 00:08:48.000
속성은 기본값으로 시작하며, 우리는 적합하다고 생각하는 어떤 방식으로든 이러한 값을 자유롭게 계산할 수 있습니다.

00:08:48.000 --> 00:08:51.000
우리는 기본 색상과 정상을 계산할 것이다.

00:08:51.000 --> 00:08:56.000
그런 다음, 네 가지 표면 매개 변수: 거칠기, 금속, 주변 폐색 및 반사.

00:08:56.000 --> 00:09:00.000
이제 우리의 가치가 어디에 있는지 알았으니, 셰이더를 쓰기 시작합시다.

00:09:00.000 --> 00:09:02.000
우리는 이것을 세 단계로 할 것이다.

00:09:02.000 --> 00:09:09.000
먼저 전이 값을 계산하세요. 여기서 0은 완전히 보라색 문어이고 1은 완전히 빨간색입니다.

00:09:09.000 --> 00:09:16.000
전환 값을 사용하여, 우리는 색상과 정상을 계산한 다음 재료 속성을 할당하여 미세 조정할 것입니다.

00:09:16.000 --> 00:09:17.000
시작하자.

00:09:17.000 --> 00:09:19.000
첫 번째 단계: 전환.

00:09:19.000 --> 00:09:24.000
우리는 surface_parameters 인수를 취하는 문어 표면 함수를 만들고 있다.

00:09:24.000 --> 00:09:27.000
우리는 텍스처를 사용하고 있기 때문에, 샘플러를 선언합니다.

00:09:27.000 --> 00:09:33.000
오른쪽에서, 당신은 빈 표면 셰이더로 우리의 문어가 어떻게 생겼는지 볼 수 있습니다 - 그것은 회색이고 약간 반짝입니다.

00:09:33.000 --> 00:09:38.000
RealityKit을 사용하면 모델의 외모에 기여하거나 기여하지 않는 것을 완벽하게 제어할 수 있습니다.

00:09:38.000 --> 00:09:41.000
색을 계산하기 위해, 우리가 먼저 해야 할 몇 가지가 있다.

00:09:41.000 --> 00:09:44.000
우리는 몇 가지 편의 변수를 저장할 것이다.

00:09:44.000 --> 00:09:48.000
우리는 텍스처 좌표로 사용할 UV0에 접근합니다.

00:09:48.000 --> 00:09:56.000
금속과 USD는 질감 좌표계가 다르므로, USD에서 로드된 질감과 일치하도록 y 좌표를 반전할 것입니다.

00:09:56.000 --> 00:10:01.000
이제 우리는 우리의 예술가가 만든 3층 텍스처인 전환 텍스처를 샘플링할 것이다.

00:10:01.000 --> 00:10:09.000
우리 아티스트는 마스크 값과 시간을 더한 작은 기능을 설정하고, 블렌드와 컬러 블렌드에 대해 0에서 1 값을 반환합니다.

00:10:09.000 --> 00:10:13.000
두 번째 단계: 색과 정상.

00:10:13.000 --> 00:10:19.000
이전에 계산된 블렌드 변수로, 우리는 이제 문어의 색을 계산하고 전환을 볼 수 있다.

00:10:19.000 --> 00:10:27.000
이를 위해, 우리는 두 가지 질감을 샘플링합니다: 기본 색상과 2차 기본 색상은 emissive_color에 저장했습니다.

00:10:27.000 --> 00:10:32.000
그런 다음 우리는 이전에 계산된 colorBlend를 사용하여 두 색상을 혼합합니다.

00:10:32.000 --> 00:10:38.000
우리는 재료의 값인 base_color_tint를 곱하고 표면에 기본 색상을 설정할 것입니다.

00:10:38.000 --> 00:10:46.000
다음으로 우리는 머리와 촉수에서 가장 눈에 띄는 표면 편차를 추가하는 일반 지도를 적용할 것이다.

00:10:46.000 --> 00:10:52.000
우리는 일반 지도 텍스처를 샘플링하고, 값을 풀고, 표면 객체에 설정합니다.

00:10:52.000 --> 00:10:55.000
물질적 특성에 대해.

00:10:55.000 --> 00:10:58.000
여기 지금까지의 문어가 있습니다, 색과 정상입니다.

00:10:58.000 --> 00:11:01.000
표면 특성이 외관에 어떤 영향을 미치는지 봅시다.

00:11:01.000 --> 00:11:13.000
하체에서 볼 수 있는 거칠기; 하부 부분을 어둡게 하는 주변 폐색; 그리고 눈에 좋은 반사와 신체에 대한 추가적인 정의를 제공하는 반사.

00:11:13.000 --> 00:11:15.000
이것들을 셰이더에 추가합시다.

00:11:15.000 --> 00:11:19.000
우리는 모델에서 각 속성에 대해 하나씩 네 개의 텍스처를 샘플링합니다.

00:11:19.000 --> 00:11:23.000
다음으로 우리는 재료 설정으로 이러한 값을 확장합니다.

00:11:23.000 --> 00:11:29.000
게다가, 우리는 또한 보라색에서 빨간색으로 전환하면서 거칠기를 늘리고 있다.

00:11:29.000 --> 00:11:32.000
그리고 나서 우리는 네 가지 값을 표면에 설정했다.

00:11:32.000 --> 00:11:36.000
이전과 마찬가지로, 우리는 셰이더를 모델에 적용해야 합니다.

00:11:36.000 --> 00:11:41.000
우리는 이 자료를 ARView 하위 클래스의 모델에 할당합니다.

00:11:41.000 --> 00:11:46.000
먼저 두 개의 추가 텍스처를 로드한 다음, 표면 셰이더를 로드합니다.

00:11:46.000 --> 00:11:55.000
이전과 마찬가지로, 우리는 이번에는 표면 셰이더와 두 개의 추가 텍스처로 물체의 기본 재료로 새로운 재료를 만들고 있습니다.

00:11:55.000 --> 00:11:57.000
그리고 우리는 끝났어.

00:11:57.000 --> 00:12:05.000
요약하자면, 우리는 기하학 수정자를 사용하여 해초 애니메이션과 표면 셰이더로 문어 전환을 만드는 방법을 보여주었습니다.

00:12:05.000 --> 00:12:11.000
우리가 그것들을 별도로 시연하는 동안, 당신은 훨씬 더 흥미로운 효과를 위해 두 가지를 결합할 수 있습니다.

00:12:11.000 --> 00:12:18.000
고도로 요청된 또 다른 기능으로 넘어가서, 사용자 지정 사후 처리 효과 추가를 지원합니다.

00:12:18.000 --> 00:12:29.000
RealityKit은 모션 블러, 카메라 노이즈 및 피사계 심도와 같은 카메라와 일치하는 다양한 포스트 효과 제품군과 함께 제공됩니다.

00:12:29.000 --> 00:12:35.000
이러한 효과는 모두 가상과 실제 물체가 같은 환경의 일부인 것처럼 느껴지도록 설계되었습니다.

00:12:35.000 --> 00:12:38.000
이것들은 ARView에서 사용자 정의할 수 있습니다.

00:12:38.000 --> 00:12:43.000
올해, 우리는 또한 당신이 자신만의 전체 화면 효과를 만들 수 있는 능력을 드러내고 있습니다.

00:12:43.000 --> 00:12:50.000
이를 통해 사진 리얼리즘을 위해 RealityKit을 활용하고 새로운 효과를 추가하여 앱의 결과를 조정할 수 있습니다.

00:12:50.000 --> 00:12:52.000
그래서 포스트 프로세스가 뭐야?

00:12:52.000 --> 00:13:00.000
포스트 프로세스는 객체가 렌더링되고 점등된 후에 실행되는 셰이더 또는 일련의 셰이더입니다.

00:13:00.000 --> 00:13:04.000
그것은 또한 RealityKit 포스트 효과 이후에 발생한다.

00:13:04.000 --> 00:13:09.000
그것의 입력은 두 가지 질감이다: 색상과 깊이 버퍼.

00:13:09.000 --> 00:13:16.000
깊이 버퍼는 여기에 그레이스케일로 표시됩니다; 카메라에 대한 각 픽셀의 거리 값을 포함합니다.

00:13:16.000 --> 00:13:20.000
포스트 프로세스는 결과를 대상 색상 텍스처에 기록합니다.

00:13:20.000 --> 00:13:25.000
가장 간단한 포스트 효과는 소스 색상을 대상 색상으로 복사할 것이다.

00:13:25.000 --> 00:13:27.000
우리는 이것들을 몇 가지 방법으로 만들 수 있다.

00:13:27.000 --> 00:13:36.000
애플의 플랫폼에는 코어 이미지, 메탈 퍼포먼스 셰이더, 스프라이트킷과 같은 포스트 효과와 잘 통합되는 다양한 기술이 함께 제공됩니다.

00:13:36.000 --> 00:13:39.000
메탈 셰이딩 언어로 직접 쓸 수도 있습니다.

00:13:39.000 --> 00:13:42.000
몇 가지 핵심 이미지 효과부터 시작합시다.

00:13:42.000 --> 00:13:45.000
코어 이미지는 이미지 처리를 위한 애플 프레임워크이다.

00:13:45.000 --> 00:13:53.000
이미지와 비디오에 적용할 수 있는 수백 가지의 색상 처리, 양식화 및 변형 효과가 있습니다.

00:13:53.000 --> 00:13:58.000
열은 깔끔한 효과입니다 - 수중 물고기 찾기를 위해 켤 수 있는 것입니다.

00:13:58.000 --> 00:14:01.000
RealityKit과 통합하는 것이 얼마나 쉬운지 봅시다.

00:14:01.000 --> 00:14:04.000
우리의 모든 포스트 효과는 같은 패턴을 따를 것이다.

00:14:04.000 --> 00:14:13.000
렌더링 콜백을 설정하고, 장치로 준비하도록 응답한 다음, 포스트 프로세스는 모든 프레임에 호출됩니다.

00:14:13.000 --> 00:14:16.000
렌더링 콜백은 RealityKit의 ARView에 존재합니다.

00:14:16.000 --> 00:14:20.000
우리는 prepareWithDevice와 postProcess 콜백을 모두 원합니다.

00:14:20.000 --> 00:14:24.000
장치로 준비하면 MTLDevice와 함께 한 번 호출됩니다.

00:14:24.000 --> 00:14:30.000
이것은 텍스처를 만들고, 컴퓨팅을 로드하거나 파이프라인을 렌더링하고, 장치 기능을 확인할 수 있는 좋은 기회입니다.

00:14:30.000 --> 00:14:33.000
이곳은 우리가 핵심 이미지 컨텍스트를 만드는 곳이다.

00:14:33.000 --> 00:14:36.000
포스트프로세스 콜백은 각 프레임마다 호출됩니다.

00:14:36.000 --> 00:14:40.000
우리는 소스 색상 텍스처를 참조하여 CIImage를 만들 것입니다.

00:14:40.000 --> 00:14:43.000
다음으로 우리는 열 필터를 만듭니다.

00:14:43.000 --> 00:14:48.000
다른 코어 이미지 필터를 사용하는 경우, 다른 매개 변수를 구성할 수 있습니다.

00:14:48.000 --> 00:14:56.000
그런 다음 출력 색상 텍스처를 대상으로 하고 컨텍스트의 명령 버퍼를 활용하는 렌더링 대상을 만듭니다.

00:14:56.000 --> 00:15:01.000
우리는 Core Image에게 이미지의 방향을 보존하고 작업을 시작하도록 요청합니다.

00:15:01.000 --> 00:15:02.000
그게 다야!

00:15:02.000 --> 00:15:07.000
코어 이미지를 통해, 우리는 사용할 수 있는 수백 개의 사전 구축 효과를 잠금 해제했습니다.

00:15:07.000 --> 00:15:12.000
이제 메탈 퍼포먼스 셰이더를 사용하여 새로운 효과를 만드는 방법을 봅시다.

00:15:12.000 --> 00:15:13.000
꽃에 대해 얘기하자.

00:15:13.000 --> 00:15:22.000
블룸은 실제 렌즈 효과를 시뮬레이션하여 밝은 조명 물체 주위에 빛을 만드는 스크린 공간 기술이다.

00:15:22.000 --> 00:15:28.000
코어 이미지에는 블룸 효과가 포함되어 있지만, 우리는 프로세스의 모든 단계를 제어할 수 있도록 우리만의 효과를 만들 것입니다.

00:15:28.000 --> 00:15:35.000
우리는 고도로 최적화된 컴퓨팅 및 그래픽 셰이더 모음인 메탈 퍼포먼스 셰이더로 효과를 구축할 것입니다.

00:15:35.000 --> 00:15:40.000
이 셰이더를 만들기 위해, 우리는 색상을 소스로 사용하여 필터 그래프를 구성할 것입니다.

00:15:40.000 --> 00:15:43.000
우리는 먼저 밝은 지역을 고립시키고 싶다.

00:15:43.000 --> 00:15:47.000
이를 위해, 우리는 "0 임계값"이라는 연산을 사용합니다.

00:15:47.000 --> 00:15:52.000
그것은 색상을 휘도로 변환하고 모든 픽셀을 특정 밝기 수준 이하로 0으로 설정합니다.

00:15:52.000 --> 00:15:58.000
그런 다음 가우스 블러를 사용하여 결과를 흐리게 하여 인접한 지역에 빛을 퍼뜨립니다.

00:15:58.000 --> 00:16:02.000
효율적인 흐림은 구현하기 어려울 수 있으며 종종 여러 단계가 필요합니다.

00:16:02.000 --> 00:16:05.000
금속 성능 셰이더는 우리를 위해 이것을 처리한다.

00:16:05.000 --> 00:16:11.000
그런 다음 우리는 이 흐릿한 질감을 원래 색상에 추가하여 밝은 영역 주위에 빛을 더합니다.

00:16:11.000 --> 00:16:15.000
이 그래프를 포스트 효과로 구현해 봅시다.

00:16:15.000 --> 00:16:18.000
우리는 중간 블룸텍스처를 만드는 것으로 시작합니다.

00:16:18.000 --> 00:16:24.000
그런 다음 ThresholdToZero 작업을 실행하여 sourceColor에서 읽고 bloomTexture에 쓰세요.

00:16:24.000 --> 00:16:28.000
그런 다음 우리는 제자리에서 가우시안 블러를 수행합니다.

00:16:28.000 --> 00:16:32.000
마지막으로, 우리는 원래의 색과 이 피는 색을 함께 추가한다.

00:16:32.000 --> 00:16:33.000
그게 다야!

00:16:33.000 --> 00:16:41.000
이제 포스트 효과를 만드는 몇 가지 방법을 보았으니, SpriteKit을 사용하여 출력 위에 효과를 올리는 방법에 대해 이야기해 봅시다.

00:16:41.000 --> 00:16:46.000
SpriteKit은 고성능, 배터리 효율적인 2D 게임을 위한 Apple의 프레임워크이다.

00:16:46.000 --> 00:16:49.000
3D 뷰 위에 몇 가지 효과를 추가하는 데 완벽합니다.

00:16:49.000 --> 00:16:57.000
우리는 그것을 사용하여 동일한 prepareWithDevice 및 postProcess 콜백을 사용하여 포스트 효과로 화면에 거품을 추가할 것입니다.

00:16:57.000 --> 00:16:59.000
우리는 이전과 같은 두 단계를 가지고 있다.

00:16:59.000 --> 00:17:04.000
prepareWithDevice에서 SpriteKit 렌더러를 만들고 거품이 포함된 장면을 로드할 것입니다.

00:17:04.000 --> 00:17:13.000
그런 다음 포스트프로세스 콜백에서 소스 색상을 대상 색상으로 복사하고, SpriteKit 장면을 업데이트하고, 3D 콘텐츠 위에 렌더링할 것입니다.

00:17:13.000 --> 00:17:20.000
prepareWithDevice는 꽤 간단합니다 - 우리는 렌더러를 만들고 파일에서 장면을 로드합니다.

00:17:20.000 --> 00:17:26.000
우리는 AR 장면 위에 이것을 그릴 것이므로, SpriteKit 배경이 투명해야 합니다.

00:17:26.000 --> 00:17:34.000
포스트프로세스에서, 우리는 먼저 소스 색상을 targetColorTexture로 변환합니다; 이것은 SpriteKit이 앞에서 렌더링하는 배경이 될 것입니다.

00:17:34.000 --> 00:17:40.000
그런 다음 SpriteKit 장면을 새로운 시간으로 진행하여 거품이 위로 이동하도록 합니다.

00:17:40.000 --> 00:17:44.000
RenderPassDescriptor를 설정하고 렌더링하세요.

00:17:44.000 --> 00:17:45.000
그리고 그게 다야!

00:17:45.000 --> 00:17:53.000
우리는 포스트 효과를 만들기 위해 기존 프레임워크를 활용하는 방법을 보여주었지만, 때로는 처음부터 만들어야 합니다.

00:17:53.000 --> 00:17:58.000
컴퓨팅 셰이더를 작성하여 전체 화면 효과를 작성할 수도 있습니다.

00:17:58.000 --> 00:18:05.000
수중 데모를 위해, 우리는 가상 물체와 카메라 패스스루에 적용되는 안개 효과가 필요했습니다.

00:18:05.000 --> 00:18:11.000
안개는 매체를 통해 빛의 산란을 시뮬레이션한다; 그 강도는 거리에 비례한다.

00:18:11.000 --> 00:18:17.000
이 효과를 만들기 위해, 우리는 각 픽셀이 장치에서 얼마나 멀리 떨어져 있는지 알아야 했다.

00:18:17.000 --> 00:18:23.000
다행히도, ARKit과 RealityKit은 둘 다 깊이 정보에 대한 접근을 제공한다.

00:18:23.000 --> 00:18:31.000
LiDAR 지원 장치의 경우, ARKit은 카메라에서 미터 단위의 거리를 포함하는 sceneDepth에 대한 액세스를 제공합니다.

00:18:31.000 --> 00:18:36.000
이 값들은 전체 화면보다 낮은 해상도에서 매우 정확하다.

00:18:36.000 --> 00:18:42.000
우리는 이 깊이를 직접 사용할 수 있지만 가상 물체를 포함하지 않기 때문에 올바르게 안개가 끼지 않을 것이다.

00:18:42.000 --> 00:18:53.000
포스트프로세스에서 RealityKit은 가상 콘텐츠에 대한 깊이에 대한 액세스를 제공하며 - 장면 이해가 활성화되면 - 실제 물체에 대한 대략적인 메쉬를 제공합니다.

00:18:53.000 --> 00:18:59.000
메쉬는 당신이 움직일 때 점진적으로 구축되므로, 현재 스캔하지 않은 구멍이 몇 개 있습니다.

00:18:59.000 --> 00:19:03.000
이 구멍들은 마치 무한히 멀리 있는 것처럼 안개를 보여줄 것이다.

00:19:03.000 --> 00:19:08.000
우리는 이 불일치를 해결하기 위해 이 두 깊이 텍스처의 데이터를 결합할 것입니다.

00:19:08.000 --> 00:19:11.000
ARKit은 깊이 값을 텍스처로 제공한다.

00:19:11.000 --> 00:19:16.000
각 픽셀은 샘플링된 지점의 거리(미터)이다.

00:19:16.000 --> 00:19:28.000
센서가 iPhone 또는 iPad의 고정된 방향에 있기 때문에, 우리는 ARKit에게 센서의 방향에서 현재 화면 방향으로 변환한 다음 결과를 반전하도록 요청할 것입니다.

00:19:28.000 --> 00:19:34.000
가상 콘텐츠 깊이를 읽으려면, RealityKit이 깊이를 어떻게 포장하는지에 대한 약간의 정보가 필요합니다.

00:19:34.000 --> 00:19:40.000
ARKit의 장면 깊이와 달리, 더 밝은 값이 카메라에 더 가깝다는 것을 알게 될 것입니다.

00:19:40.000 --> 00:19:46.000
값은 무한 역방향 Z 투영을 사용하여 0에서 1 범위에 저장됩니다.

00:19:46.000 --> 00:19:52.000
이것은 단지 0이 무한히 멀리 떨어져 있다는 것을 의미하고, 1은 카메라의 가까운 비행기에 있다는 것을 의미한다.

00:19:52.000 --> 00:19:58.000
우리는 가까운 평면 깊이를 샘플링된 깊이로 나누어 이 변환을 쉽게 되돌릴 수 있다.

00:19:58.000 --> 00:20:01.000
이것을 하기 위해 도우미 함수를 작성합시다.

00:20:01.000 --> 00:20:05.000
우리는 샘플의 깊이와 투영 매트릭스를 취하는 금속 기능을 가지고 있다.

00:20:05.000 --> 00:20:08.000
가상 콘텐츠가 없는 픽셀은 정확히 0이다.

00:20:08.000 --> 00:20:12.000
우리는 0으로 나누는 것을 막기 위해 작은 엡실론에 고정할 것이다.

00:20:12.000 --> 00:20:19.000
원근법 분할을 취소하기 위해, 우리는 마지막 열의 z 값을 취하고 샘플링된 깊이로 나눕니다.

00:20:19.000 --> 00:20:20.000
좋아!

00:20:20.000 --> 00:20:26.000
이제 두 개의 깊이 값이 있으므로, 안개 함수에 대한 입력으로 최소 두 값을 사용할 수 있습니다.

00:20:26.000 --> 00:20:35.000
우리의 안개에는 몇 가지 매개 변수가 있습니다: 최대 거리, 그 거리의 최대 강도, 그리고 전력 곡선 지수.

00:20:35.000 --> 00:20:38.000
정확한 값은 실험적으로 선택되었다.

00:20:38.000 --> 00:20:42.000
그들은 우리가 원하는 안개 밀도를 달성하기 위해 우리의 깊이 값을 형성한다.

00:20:42.000 --> 00:20:44.000
이제 우리는 그 조각들을 모을 준비가 되었다.

00:20:44.000 --> 00:20:51.000
우리는 ARKit의 깊이 값, RealityKit의 선형화된 깊이 값, 그리고 안개 기능을 가지고 있습니다.

00:20:51.000 --> 00:20:53.000
컴퓨팅 셰이더를 작성해 봅시다.

00:20:53.000 --> 00:20:57.000
각 픽셀에 대해, 우리는 두 선형 깊이 값을 샘플링하는 것으로 시작합니다.

00:20:57.000 --> 00:21:04.000
그런 다음 선형 깊이를 0에서 1 값으로 바꾸는 튜닝 매개 변수를 사용하여 안개 기능을 적용합니다.

00:21:04.000 --> 00:21:12.000
그런 다음 fogBlend의 값에 따라 소스 색상과 안개 색상을 혼합하여 결과를 outColor에 저장합니다.

00:21:12.000 --> 00:21:19.000
요약하자면, RealityKit의 새로운 포스트 프로세스 API는 다양한 포스트 효과를 가능하게 한다.

00:21:19.000 --> 00:21:23.000
코어 이미지로, 우리는 수백 개의 기성품 효과를 잠금 해제했습니다.

00:21:23.000 --> 00:21:33.000
Metal Performance Shaders로 새로운 것을 쉽게 만들고, SpriteKit으로 화면 오버레이를 추가하고, Metal으로 처음부터 직접 작성할 수 있습니다.

00:21:33.000 --> 00:21:40.000
코어 이미지 또는 메탈 퍼포먼스 셰이더에 대한 자세한 내용은 나열된 세션을 참조하십시오.

00:21:40.000 --> 00:21:46.000
이제 렌더링 효과를 다뤘으니, 다음 주제인 동적 메쉬로 넘어가자.

00:21:46.000 --> 00:21:49.000
RealityKit에서 메쉬 리소스는 메쉬 데이터를 저장합니다.

00:21:49.000 --> 00:21:54.000
이전에는 이 불투명한 유형을 사용하면 엔티티에 메쉬를 할당할 수 있었습니다.

00:21:54.000 --> 00:22:01.000
올해, 우리는 런타임에 메쉬를 검사하고, 만들고, 업데이트할 수 있는 기능을 제공하고 있습니다.

00:22:01.000 --> 00:22:05.000
다이버에게 특수 효과를 추가할 수 있는 방법을 살펴봅시다.

00:22:05.000 --> 00:22:10.000
이 데모에서, 우리는 다이버 주변의 나선형 윤곽이 있는 나선형 효과를 보여주고 싶습니다.

00:22:10.000 --> 00:22:16.000
당신은 또한 나선이 움직임을 움직이기 위해 시간이 지남에 따라 메쉬를 어떻게 바꾸고 있는지 볼 수 있습니다.

00:22:16.000 --> 00:22:20.000
새로운 메쉬 API를 사용하여 이것을 만드는 방법을 살펴봅시다.

00:22:20.000 --> 00:22:24.000
그 효과는 세 단계로 요약된다.

00:22:24.000 --> 00:22:29.000
우리는 메쉬 검사를 사용하여 정점을 검사하여 모델을 측정합니다.

00:22:29.000 --> 00:22:33.000
그런 다음 우리는 측정을 가이드로 사용하여 나선형을 만든다.

00:22:33.000 --> 00:22:38.000
그리고 마지막으로, 우리는 시간이 지남에 따라 나선형을 업데이트할 수 있다.

00:22:38.000 --> 00:22:40.000
메쉬 검사로 시작합니다.

00:22:40.000 --> 00:22:44.000
메쉬가 어떻게 저장되는지 설명하기 위해, 다이버 모델을 살펴봅시다.

00:22:44.000 --> 00:22:48.000
RealityKit에서, 다이버의 메쉬는 메쉬 자원으로 표현된다.

00:22:48.000 --> 00:22:53.000
올해의 출시와 함께, MeshResource에는 이제 Contents라는 회원이 포함되어 있습니다.

00:22:53.000 --> 00:22:57.000
가공된 모든 메쉬 기하학이 사는 곳이 있다.

00:22:57.000 --> 00:23:02.000
내용에는 인스턴스와 모델 목록이 포함되어 있습니다.

00:23:02.000 --> 00:23:08.000
모델은 원시 정점 데이터를 포함하는 반면, 인스턴스는 이를 참조하고 변환을 추가합니다.

00:23:08.000 --> 00:23:13.000
인스턴스는 데이터를 복사하지 않고도 동일한 지오메트리를 여러 번 표시할 수 있게 해준다.

00:23:13.000 --> 00:23:15.000
모델은 여러 부품을 가질 수 있다.

00:23:15.000 --> 00:23:19.000
부품은 하나의 재료가 있는 기하학 그룹이다.

00:23:19.000 --> 00:23:28.000
마지막으로, 각 부분에는 위치, 법선, 텍스처 좌표 및 인덱스와 같은 우리가 관심 있는 정점 데이터가 포함되어 있습니다.

00:23:28.000 --> 00:23:32.000
먼저 코드에서 이 데이터에 어떻게 접근할 수 있는지 살펴봅시다.

00:23:32.000 --> 00:23:38.000
우리는 각 정점의 위치로 폐쇄를 호출하는 MeshResource.Contents를 확장할 것입니다.

00:23:38.000 --> 00:23:41.000
우리는 모든 사례를 살펴보는 것으로 시작한다.

00:23:41.000 --> 00:23:43.000
이 사례들 각각은 모델에 매핑된다.

00:23:43.000 --> 00:23:47.000
각 경우에 대해, 우리는 엔티티에 대한 상대적인 변환을 찾습니다.

00:23:47.000 --> 00:23:53.000
그런 다음 모델의 각 부품에 들어가서 부품의 속성에 접근할 수 있습니다.

00:23:53.000 --> 00:23:56.000
이 기능을 위해, 우리는 위치에만 관심이 있다.

00:23:56.000 --> 00:24:02.000
그런 다음 정점을 엔티티 공간 위치로 변환하고 콜백을 호출할 수 있습니다.

00:24:02.000 --> 00:24:07.000
이제 정점을 방문할 수 있으므로, 이 데이터를 어떻게 사용하고 싶은지 살펴봅시다.

00:24:07.000 --> 00:24:10.000
우리는 다이버를 수평 조각으로 나눌 것이다.

00:24:10.000 --> 00:24:18.000
각 슬라이스에 대해, 우리는 모델의 경계 반경을 찾고, 모든 슬라이스에 대해 이것을 할 것이다.

00:24:18.000 --> 00:24:23.000
이것을 구현하기 위해, 우리는 numSlices 요소로 0으로 채워진 배열을 만드는 것으로 시작할 것이다.

00:24:23.000 --> 00:24:28.000
그런 다음 우리는 조각을 만들기 위해 y축을 따라 메쉬의 경계를 알아낸다.

00:24:28.000 --> 00:24:38.000
우리가 방금 만든 기능을 사용하여, 모델의 각 정점에 대해, 우리는 어떤 슬라이스가 들어가는지 알아내고 그 슬라이스의 가장 큰 반경으로 반경을 업데이트합니다.

00:24:38.000 --> 00:24:44.000
마지막으로, 우리는 반지름과 경계를 포함하는 슬라이스 객체를 반환합니다.

00:24:44.000 --> 00:24:49.000
이제 메쉬가 얼마나 큰지 분석했으니, 나선형 메쉬를 만드는 방법을 살펴봅시다.

00:24:49.000 --> 00:24:52.000
나선은 동적으로 생성된 메쉬이다.

00:24:52.000 --> 00:24:57.000
이 메쉬를 만들기 위해, 우리는 RealityKit에 데이터를 설명해야 합니다.

00:24:57.000 --> 00:24:59.000
우리는 메쉬 설명자로 이것을 한다.

00:24:59.000 --> 00:25:06.000
메쉬 설명자는 위치, 법선, 텍스처 좌표, 프리미티브 및 재료 인덱스를 포함합니다.

00:25:06.000 --> 00:25:09.000
메쉬 설명자가 있으면, 메쉬 리소스를 생성할 수 있습니다.

00:25:09.000 --> 00:25:14.000
이것은 메쉬를 최적화하는 RealityKit의 메쉬 프로세서를 호출합니다.

00:25:14.000 --> 00:25:23.000
그것은 중복된 정점을 병합하고, 쿼드와 다각형을 삼각 측량하고, 렌더링을 위한 가장 효율적인 형식으로 메쉬를 나타낼 것이다.

00:25:23.000 --> 00:25:28.000
이 처리의 결과는 우리가 엔티티에 할당할 수 있는 메쉬 자원을 제공한다.

00:25:28.000 --> 00:25:32.000
법선, 질감 좌표 및 재료는 선택 사항입니다.

00:25:32.000 --> 00:25:37.000
우리의 메쉬 프로세서는 자동으로 올바른 법질을 생성하고 채웁니다.

00:25:37.000 --> 00:25:43.000
최적화 과정의 일환으로, RealityKit은 메쉬의 토폴로지를 재생성할 것이다.

00:25:43.000 --> 00:25:48.000
특정 토폴로지가 필요하다면, MeshResource.Contents를 직접 사용할 수 있습니다.

00:25:48.000 --> 00:25:52.000
이제 메쉬를 만드는 방법을 알았으니, 나선형을 만드는 방법을 살펴봅시다.

00:25:52.000 --> 00:25:58.000
나선형을 모델링하기 위해, 한 섹션을 자세히 살펴봅시다.

00:25:58.000 --> 00:26:01.000
나선은 나선으로도 알려져 있다.

00:26:01.000 --> 00:26:04.000
우리는 이것을 균등하게 간격을 둔 세그먼트로 만들 것이다.

00:26:04.000 --> 00:26:12.000
우리는 분석된 메쉬의 나선의 수학적 정의와 반경을 사용하여 각 점을 계산할 수 있습니다.

00:26:12.000 --> 00:26:17.000
나선의 각 세그먼트에 대해 이 기능을 사용하여, 우리는 네 개의 정점을 정의할 수 있다.

00:26:17.000 --> 00:26:21.000
P0과 P1은 정확히 p()가 반환하는 값이다.

00:26:21.000 --> 00:26:28.000
P2와 P3를 계산하기 위해, 우리는 주어진 두께로 P0과 P1을 수직으로 상쇄할 수 있다.

00:26:28.000 --> 00:26:31.000
우리는 삼각형을 만들고 있기 때문에, 대각선이 필요하다.

00:26:31.000 --> 00:26:34.000
우리는 이 점들을 사용하여 두 개의 삼각형을 만들 것이다.

00:26:34.000 --> 00:26:37.000
다 모을 시간이야.

00:26:37.000 --> 00:26:41.000
우리의 generateSpiral 기능은 위치와 인덱스를 저장해야 합니다.

00:26:41.000 --> 00:26:44.000
위치의 참조 값을 지수한다.

00:26:44.000 --> 00:26:53.000
각 세그먼트에 대해, 우리는 네 개의 위치를 계산하고 인덱스를 저장할 것입니다 -- i0은 배열에 추가될 때 p0의 인덱스입니다.

00:26:53.000 --> 00:26:59.000
그런 다음 우리는 두 개의 삼각형에 대해 네 개의 위치와 여섯 개의 인덱스를 배열에 추가합니다.

00:26:59.000 --> 00:27:03.000
기하학을 갖게 되면, 메쉬를 만드는 것은 간단합니다.

00:27:03.000 --> 00:27:06.000
먼저, 새로운 MeshDescriptor를 만드세요.

00:27:06.000 --> 00:27:08.000
그런 다음 위치와 기본을 할당하세요.

00:27:08.000 --> 00:27:13.000
우리는 삼각형 프리미티브를 사용하고 있지만, 쿼드나 다각형을 선택할 수도 있다.

00:27:13.000 --> 00:27:17.000
그 두 필드가 채워지면, 우리는 MeshResource를 생성하기에 충분하다.

00:27:17.000 --> 00:27:24.000
법선, 텍스처 좌표 또는 재료 할당과 같은 다른 정점 속성을 제공할 수도 있습니다.

00:27:24.000 --> 00:27:26.000
우리는 메쉬를 만드는 방법을 다루었다.

00:27:26.000 --> 00:27:30.000
우리의 나선형 예시에서 마지막 것은 메쉬 업데이트이다.

00:27:30.000 --> 00:27:34.000
우리는 다이버 주위를 움직이기 위해 나선형을 얻기 위해 메쉬 업데이트를 사용합니다.

00:27:34.000 --> 00:27:37.000
메쉬를 업데이트하려면, 두 가지 방법이 있다.

00:27:37.000 --> 00:27:42.000
우리는 MeshDescriptors API를 사용하여 각 프레임마다 새로운 MeshResource를 만들 수 있습니다.

00:27:42.000 --> 00:27:48.000
하지만 이것은 각 프레임의 메쉬 옵티마이저를 통해 실행되기 때문에 효율적인 경로가 아니다.

00:27:48.000 --> 00:27:52.000
더 효율적인 경로는 MeshResource의 내용을 업데이트하는 것이다.

00:27:52.000 --> 00:27:56.000
새로운 MeshContents를 생성하고 메쉬를 교체하는 데 사용할 수 있습니다.

00:27:56.000 --> 00:27:58.000
하지만, 한 가지 주의 사항이 있다.

00:27:58.000 --> 00:28:05.000
MeshDescriptor를 사용하여 원래 메쉬를 만들었다면, RealityKit의 메쉬 프로세서는 데이터를 최적화할 것입니다.

00:28:05.000 --> 00:28:08.000
토폴로지는 또한 삼각형으로 축소된다.

00:28:08.000 --> 00:28:14.000
결과적으로, 업데이트를 적용하기 전에 메쉬가 어떻게 영향을 받는지 알아야 합니다.

00:28:14.000 --> 00:28:17.000
나선형을 업데이트하는 방법에 대한 코드를 살펴봅시다.

00:28:17.000 --> 00:28:21.000
우리는 기존 나선의 내용을 저장하는 것으로 시작합니다.

00:28:21.000 --> 00:28:24.000
기존 모델에서 새 모델을 만드세요.

00:28:24.000 --> 00:28:29.000
그런 다음, 각 부분에 대해, 우리는 triangleIndices를 인덱스의 하위 집합으로 바꿉니다.

00:28:29.000 --> 00:28:34.000
마지막으로, 새로운 내용으로, 우리는 기존 MeshResource를 대체할 수 있다.

00:28:34.000 --> 00:28:36.000
그리고 그것은 역동적인 메쉬를 위한 것이다.

00:28:36.000 --> 00:28:43.000
동적 메쉬의 핵심 사항을 요약하기 위해, 우리는 MeshResource에 새로운 콘텐츠 필드를 도입했습니다.

00:28:43.000 --> 00:28:48.000
이 컨테이너를 사용하면 메쉬의 원시 데이터를 검사하고 수정할 수 있습니다.

00:28:48.000 --> 00:28:50.000
MeshDescriptor를 사용하여 새로운 메쉬를 만들 수 있습니다.

00:28:50.000 --> 00:28:59.000
이 유연한 경로를 사용하면 삼각형, 쿼드 또는 다각형을 사용할 수 있으며, RealityKit은 렌더링을 위해 최적화된 메쉬를 생성합니다.

00:28:59.000 --> 00:29:07.000
마지막으로, 메쉬를 업데이트하기 위해, 우리는 잦은 업데이트에 이상적인 MeshResource의 콘텐츠를 업데이트할 수 있는 기능을 제공했습니다.

00:29:07.000 --> 00:29:13.000
마무리하자면, 오늘 우리는 RealityKit 2의 새로운 렌더링 기능 중 일부를 선보였습니다.

00:29:13.000 --> 00:29:17.000
기하학 수정자를 사용하면 정점을 이동하고 수정할 수 있습니다.

00:29:17.000 --> 00:29:21.000
표면 셰이더를 사용하면 모델의 표면 모양을 정의할 수 있습니다.

00:29:21.000 --> 00:29:31.000
포스트 효과를 사용하여 최종 프레임에 효과를 적용할 수 있으며, 동적 메쉬를 사용하면 런타임에 메쉬를 쉽게 만들고 수정할 수 있습니다.

00:29:31.000 --> 00:29:36.000
올해의 더 많은 기능을 보려면, "Dive into RealityKit 2"를 놓치지 마세요.

00:29:36.000 --> 00:29:41.000
그리고 RealityKit에 대한 자세한 내용은 "RealityKit으로 앱 구축"을 보세요.

00:29:41.000 --> 00:29:46.000
우리는 올해의 출시에 대해 매우 흥분하고 있으며, 당신이 그것으로 만든 경험을 빨리 보고 싶습니다.

00:29:46.000 --> 00:29:47.000
고마워.

00:29:47.000 --> 23:59:59.000
♪

