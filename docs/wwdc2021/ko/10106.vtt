WEBVTT

00:00:00.000 --> 00:00:05.000
♪ 베이스 음악 연주 ♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:25.000
개럿 데이비슨: 안녕하세요, 저는 인증 경험 팀의 엔지니어인 개럿입니다. 우리가 작업하고 있는 것을 엿볼 수 있게 되어 매우 기쁩니다: 애플이 암호로부터의 업계 전반의 전환을 지원하기 위해 취하고 있는 첫 번째 단계입니다.

00:00:25.000 --> 00:00:31.000
오늘 앱이나 웹사이트에 로그인할 때마다, 당신은 아마 비밀번호를 입력하고 있을 것입니다.

00:00:31.000 --> 00:00:42.000
상징적인 사용자 이름과 비밀번호 필드 쌍은 즉시 알아볼 수 있고 사용하기 정말 쉽고, 대부분의 사람들은 그것을 만났을 때 무엇을 해야 할지 즉시 알고 있다.

00:00:42.000 --> 00:00:57.000
그러나 개발자, 사용자 및 업계 전체는 계정에 로그인하기 위해 빠르게 인증할 수 있는 이러한 큰 편리함이 계정 보안에 비용이 든다는 것을 집단적으로 배웠습니다.

00:00:57.000 --> 00:01:04.000
인증 기술이 수년에 걸쳐 발전함에 따라, 업계가 배운 몇 가지 근본적인 교훈이 있다.

00:01:04.000 --> 00:01:10.000
우선, 특히 그 비밀이 공유될 때, 비밀을 보호하는 것은 어렵다.

00:01:10.000 --> 00:01:22.000
오늘날 대부분의 인증은 계정이 생성될 때 비밀번호와 같은 비밀을 공유하는 사용자와 서버에 의존하며, 모든 인증 중에 그 비밀을 다시 공유한다.

00:01:22.000 --> 00:01:30.000
그 비밀이 공유될 때마다, 의도된 수신자가 아닌 다른 누군가가 그 비밀을 배울 위험이 있다.

00:01:30.000 --> 00:01:38.000
가짜 이메일과 전화 또는 오해의 소지가 있는 웹사이트와 같은 피싱은 잘못된 당사자가 비밀을 배우는 가장 일반적인 방법이다.

00:01:38.000 --> 00:01:48.000
그리고 비밀번호와 같은 비밀이 나가면, 약한 비밀번호를 사용하거나 여러 계정에서 동일한 비밀번호를 재사용하면 문제를 빠르게 악화시킬 수 있습니다.

00:01:48.000 --> 00:02:01.000
사실, 2020년 버라이즌 데이터 유출 조사 보고서에 따르면, 해킹 관련 데이터 유출의 80% 이상이 자격 증명의 무차별적인 힘이나 분실되거나 도난당한 자격 증명을 사용하는 것과 관련이 있다.

00:02:01.000 --> 00:02:03.000
이런 식일 필요는 없어.

00:02:03.000 --> 00:02:09.000
인증 기술은 이러한 위험 중 일부를 완화하기 위해 계속 진화해 왔다.

00:02:09.000 --> 00:02:13.000
처음에, 비밀번호는 대부분 사람들의 머릿속에 저장되었다.

00:02:13.000 --> 00:02:21.000
하지만 사람들은 일반적으로 모든 계정에 대해 강력하고 고유한 비밀번호를 생각해내고 기억하는 데 능숙하지 않다는 것이 밝혀졌습니다.

00:02:21.000 --> 00:02:29.000
비밀번호 관리자는 계정당 강력하고 고유한 비밀번호를 만들 수 있으며, 가능한 피싱의 몇 가지 형태에 대한 힌트를 제공할 수 있습니다.

00:02:29.000 --> 00:02:40.000
iCloud 키체인의 비밀번호 관리자는 Apple 기기에 내장되어 있으며, 제3자가 자신의 비밀번호 관리자를 시스템에 통합할 수 있도록 API를 만들었습니다.

00:02:40.000 --> 00:02:54.000
서비스 소유자는 또한 비밀번호와 OTP와 같은 추가 요소를 요구하는 것과 같은 추가 단계를 로그인 흐름에 추가할 수 있습니다. 예를 들어, SMS 또는 생성된 일회성 인증 코드.

00:02:54.000 --> 00:03:09.000
macOS Monterey와 iOS 15에는 iCloud 키체인 비밀번호 관리자에 코드 생성기가 내장되어 있으며, 팀 동료 Eryn의 "iCloud 키체인 인증 코드로 보안 로그인" 비디오에서 자세히 알아볼 수 있습니다.

00:03:09.000 --> 00:03:19.000
일부 앱과 웹사이트는 Apple로 로그인과 같은 연합 인증을 통해 제3자에게 인증을 완전히 아웃소싱하도록 선택합니다.

00:03:19.000 --> 00:03:27.000
연합 인증은 사람들이 소수의 고도로 보호된 계정에 신뢰를 유지할 수 있게 해준다.

00:03:27.000 --> 00:03:32.000
하지만 이 비디오에서, 나는 비연합 인증 옵션에 초점을 맞출 것이다.

00:03:32.000 --> 00:03:34.000
이것들이 어떻게 비교되는지 이야기해 봅시다.

00:03:34.000 --> 00:03:43.000
그것들은 모두 사용하기 쉽고, 대부분의 장치에서 작동하며, 거의 항상 당신과 함께 있습니다.

00:03:43.000 --> 00:03:46.000
하지만 보안 수준이 더 나을 수도 있다.

00:03:46.000 --> 00:03:52.000
기억할 수 있는 비밀번호는 아마도 모든 계정에서 강력하고 독특하지 않을 것이다.

00:03:52.000 --> 00:04:03.000
비밀번호 관리자는 강력하고 고유한 비밀번호를 만드는 데 사용할 수 있지만, 보호하는 데 사용하는 비밀번호와 잠재적으로 추가 요소만큼만 강력합니다.

00:04:03.000 --> 00:04:13.000
그리고 일회용 코드도 도움이 될 수 있지만 여전히 입력할 수 있고, 피싱할 수 있고, 공유 비밀이기 때문에 비밀번호와 같은 많은 문제가 발생할 수 있습니다.

00:04:13.000 --> 00:04:17.000
또한, 비밀번호가 머릿속에 있다면, 잊어버릴 수 있습니다.

00:04:17.000 --> 00:04:24.000
이것은 앱과 웹사이트가 별도의 복구 흐름이 필요하다는 것을 의미하며, 오늘날에는 일반적으로 이메일의 링크입니다.

00:04:24.000 --> 00:04:32.000
이것은 전체 계정의 보안 수준을 이메일 공급자의 보안 수준으로 낮출 수 있으며, 이는 일반적으로 당신이 통제하는 것이 아닙니다.

00:04:32.000 --> 00:04:39.000
일부 비밀번호 관리자와 두 번째 요소 솔루션은 복구에 도움이 될 수 있지만 비슷한 문제에 직면하는 경향이 있다.

00:04:39.000 --> 00:04:44.000
기억된 비밀번호는 또한 어떤 종류의 피싱 저항도 제공하지 않는다.

00:04:44.000 --> 00:04:58.000
비밀번호 관리자는 그렇지 않으면 합법적으로 보이는 피싱 사이트에서 비밀번호를 입력할 것을 제안하지 않는 것과 같은 피싱에 대한 힌트를 제공할 수 있지만, 여전히 누군가가 수동으로 비밀번호를 입력하고 피싱을 당하는 것을 막을 수는 없습니다.

00:04:58.000 --> 00:05:04.000
일회성 코드는 비슷한 문제를 가지고 있지만, 당신이 시행할 수 있는 몇 가지 현대적인 완화책이 있습니다.

00:05:04.000 --> 00:05:17.000
그리고 마지막으로, 이러한 모든 방법은 사용자와 서버 간의 공유된 비밀에 의존하여, 공유된 비밀의 가장 약한 보호보다 근본적으로 강하지 않습니다.

00:05:17.000 --> 00:05:23.000
그 차트를 염두에 두고, 비밀번호 문제에 대한 실제 해결책의 속성에 대해 이야기해 봅시다.

00:05:23.000 --> 00:05:29.000
우선, 비밀번호 교체는 설계상 안전해야 합니다.

00:05:29.000 --> 00:05:36.000
모든 모범 사례를 따른다면, 비밀번호는 합리적으로 안전할 수 있다.

00:05:36.000 --> 00:05:42.000
그러나, 경험은 모든 사람이 항상 하는 것이 꽤 어렵다는 것을 우리에게 보여주었다.

00:05:42.000 --> 00:05:48.000
비밀번호 교체는 처음부터 보안을 구축해야 한다.

00:05:48.000 --> 00:05:51.000
하지만 우리는 유용성에서도 거꾸로 가고 싶지 않다.

00:05:51.000 --> 00:05:56.000
비밀번호는 사용하기 쉽기 때문에 오랫동안 우리와 함께 해왔다.

00:05:56.000 --> 00:05:58.000
우리는 그걸 잃고 싶지 않아.

00:05:58.000 --> 00:06:04.000
쉽다는 것은 항상 이용 가능하고 어디에서나 사용할 수 있는 것을 포함한다.

00:06:04.000 --> 00:06:11.000
오늘날, 내가 내 비밀번호를 알고 있거나 찾을 수 있는 한, 나는 내가 로그인하고 싶은 장치가 그것을 지원한다고 가정할 수 있다.

00:06:11.000 --> 00:06:20.000
새로운 장치에서 인증에 대한 추가적인 마찰은 빠르게 로그인하고 싶은 사람들의 채택에 해를 끼칠 것이다.

00:06:20.000 --> 00:06:27.000
그리고 마지막으로, 회복은 사후 고려로 추가되는 것이 아니라 일류 기능이 되어야 한다.

00:06:27.000 --> 00:06:40.000
사람들은 실수를 하고, 나쁜 일이 발생하며, 비밀번호에 대한 해결책은 전반적인 보안을 손상시키지 않으면서 인간이 되는 것을 다룰 수 있을 만큼 충분히 내결함성이 있어야 한다.

00:06:40.000 --> 00:06:50.000
오늘날 가장 강력한 보안 옵션 중 하나는 보안 키, 특히 높은 보안 상황에서 일반적으로 두 번째 요소로 사용되는 하드웨어 동글 또는 포브입니다.

00:06:50.000 --> 00:06:57.000
그것들은 모든 사람에게 열려 있는 웹 인증 또는 WebAuthn 표준을 기반으로 합니다.

00:06:57.000 --> 00:07:01.000
그리고 그들 중 대부분은 초기 학습 곡선 이후에 사용하기가 꽤 쉽다.

00:07:01.000 --> 00:07:05.000
그리고 그것들은 단순한 비밀번호보다 훨씬 더 안전하다.

00:07:05.000 --> 00:07:10.000
이 강점의 대부분은 WebAuthn에서 비롯되며, 나는 조금 더 이야기할 것이다.

00:07:10.000 --> 00:07:15.000
최신 웹 브라우저는 또한 대부분의 최신 장치에서 보안 키를 지원합니다.

00:07:15.000 --> 00:07:23.000
macOS와 iOS의 Safari는 한동안 USB, NFC 및 Lightning 보안 키를 지원했습니다.

00:07:23.000 --> 00:07:31.000
대부분의 보안 키는 또한 하나 이상의 연결 방법을 지원하므로, 하나의 하드웨어 키를 다양한 장치에서 사용할 수 있습니다.

00:07:31.000 --> 00:07:35.000
WebAuthn과 비밀번호를 비교해 봅시다.

00:07:35.000 --> 00:07:41.000
WebAuthn의 가장 큰 장점 중 하나는 공유 비밀 대신 공개/개인 키 쌍을 사용한다는 것이다.

00:07:41.000 --> 00:07:47.000
오늘 비밀번호가 어떻게 작동하는지 조사하면, 먼저 비밀번호를 입력하십시오.

00:07:47.000 --> 00:07:57.000
그런 다음, 그것은 보통 해싱과 소금에 절인 것과 같은 것을 통해 난독화되며, 그 결과 소금에 절인 해시는 서버로 전송됩니다.

00:07:57.000 --> 00:08:09.000
이제, 서버의 사본이 난독화되었음에도 불구하고, 당신과 서버 모두 비밀의 복사본을 가지고 있으며, 둘 다 그 비밀을 보호할 책임이 있습니다.

00:08:09.000 --> 00:08:12.000
이게 우리가 없애고 있는 거야.

00:08:12.000 --> 00:08:18.000
비밀번호 대신 공개/개인 키 쌍을 사용하면 장치가 한 쌍의 키를 생성합니다.

00:08:18.000 --> 00:08:23.000
이 키들 중 하나는 공개입니다; 당신의 사용자 이름만큼 공개됩니다.

00:08:23.000 --> 00:08:28.000
그것은 누구와도 공유할 수 있으며, 비밀이 아니다.

00:08:28.000 --> 00:08:30.000
다른 열쇠는 비공개입니다.

00:08:30.000 --> 00:08:35.000
이 개인 키는 비밀이며 당신의 장치에 의해 보호됩니다.

00:08:35.000 --> 00:08:40.000
당신의 장치는 이 키를 다른 사람, 심지어 서버와도 공유하지 않습니다.

00:08:40.000 --> 00:08:47.000
계정을 만들 때, 당신의 장치는 이 두 개의 관련 키를 생성합니다.

00:08:47.000 --> 00:08:51.000
그런 다음 공개 키를 서버와 공유합니다.

00:08:51.000 --> 00:08:59.000
이제, 서버는 공개 정보이기 때문에 비밀번호와 동일한 보호 요구 사항이 없는 공개 키의 복사본을 가지고 있습니다.

00:08:59.000 --> 00:09:07.000
개인 키는 당신의 장치에 남아 있으며, 오직 그 장치만이 그것을 보호할 책임이 있습니다.

00:09:07.000 --> 00:09:12.000
나중에, 로그인하고 싶을 때, 서버에 비밀을 보내지 않습니다.

00:09:12.000 --> 00:09:21.000
대신 당신은 당신의 장치가 당신의 계정의 공개 키와 관련된 개인 키를 알고 있다는 것을 증명함으로써 그것이 당신의 계정임을 증명합니다.

00:09:21.000 --> 00:09:24.000
그 교환은 이렇게 작동한다.

00:09:24.000 --> 00:09:28.000
먼저, 나는 내 계정에 로그인하러 간다.

00:09:28.000 --> 00:09:34.000
그런 다음, 웹사이트는 내 장치에 그것이 실제로 내 계정이라는 것을 증명하도록 요청한다.

00:09:34.000 --> 00:09:45.000
그것은 내 장치가 내 개인 키가 무엇인지 실제로 말하지 않고 내 계정의 공개 키와 관련된 개인 키를 가지고 있다는 것을 증명하기 위해 "도전"이라고 불리는 것을 수행함으로써 이것을 한다.

00:09:45.000 --> 00:09:50.000
그렇게 하기 위해, 서버는 일회용 챌린지를 다시 보낸다.

00:09:50.000 --> 00:09:59.000
내 장치에는 개인 키가 있으므로, 그 도전을 받아들이고 내 개인 키를 사용하여 도전의 "서명"이라고 불리는 것을 한다.

00:09:59.000 --> 00:10:03.000
내 개인 키만이 내 계정에 유효한 서명을 생성할 수 있다.

00:10:03.000 --> 00:10:06.000
그런 다음 이 서명은 서버로 다시 전송됩니다.

00:10:06.000 --> 00:10:13.000
서버는 이미 내 공개 키를 가지고 있으므로, 그 공개 키에 대해 이 서명을 확인할 수 있다.

00:10:13.000 --> 00:10:19.000
내 공개 키를 가진 사람은 누구나 서명이 그 키와 일치하는지 쉽게 확인할 수 있다.

00:10:19.000 --> 00:10:26.000
그러나, 나만이 개인 키를 가지고 있기 때문에 도전에 대한 유효한 서명을 만들 수 있다.

00:10:26.000 --> 00:10:35.000
그러므로, 누구나 내 비밀이 무엇인지 배우지 않고도 내 신원을 쉽게 확인할 수 있다.

00:10:35.000 --> 00:10:43.000
그리고 마지막으로, 서명이 실제로 내 공개 키와 일치한다고 가정하면, 서버는 내가 로그인했다고 말한다!

00:10:43.000 --> 00:10:46.000
내 개인 키가 내 장치를 떠나지 않았다는 것을 알아두세요.

00:10:46.000 --> 00:10:58.000
서버는 내 비밀 - 내 개인 키 -가 실제로 무엇인지 배우지 않고도 이것이 내 계정인지 확인할 수 있었다.

00:10:58.000 --> 00:11:14.000
공개/개인 키 쌍은 자격 증명이 장치에 의해 생성되고 관리된다는 것을 의미하기 때문에 - 개인 키는 서버와 공유되지 않습니다 - 이러한 키는 결코 추측하거나, 재사용되거나, 약하거나, 서버가 위반되는 것에 취약하지 않을 것입니다.

00:11:14.000 --> 00:11:21.000
WebAuthn은 또한 인간이 아닌 브라우저와 운영 체제에 대한 신뢰를 쌓는다.

00:11:21.000 --> 00:11:34.000
이 소프트웨어는 자격 증명이 만들어진 웹사이트와 앱에서만 사용할 수 있도록 엄격하게 시행하여 누군가가 잘못된 웹사이트에서 인증을 시도하는 것을 방지합니다.

00:11:34.000 --> 00:11:45.000
그리고 WebAuthn의 모든 자격 증명은 공개/개인 키 쌍이기 때문에, 서버는 더 이상 인증 비밀을 유지할 책임이 없습니다.

00:11:45.000 --> 00:11:59.000
이것은 비밀을 안전하게 유지하기 위해 서버 측에서 더 적은 작업을 의미하며, 공격자가 훔칠 수 있는 인증 비밀이 없기 때문에 서버는 공격자에게 덜 가치 있는 대상이다.

00:11:59.000 --> 00:12:05.000
보안 키를 그 차트의 다른 항목과 비교해 봅시다.

00:12:05.000 --> 00:12:09.000
그것들은 초기 학습 곡선 이후에 사용하기가 꽤 쉽다.

00:12:09.000 --> 00:12:16.000
그것들은 당신의 모든 Apple 기기와 많은 최신 비Apple 기기에서 작동합니다.

00:12:16.000 --> 00:12:19.000
하지만 그들이 항상 당신과 함께 있는 것은 아닙니다.

00:12:19.000 --> 00:12:24.000
당신은 항상 추가 하드웨어를 구매하고 휴대해야 합니다.

00:12:24.000 --> 00:12:31.000
이것은 입양을 위한 진입 장벽이 될 수 있으며, 비밀번호에 비해 사용성에서 한 걸음 물러나는 것이다.

00:12:31.000 --> 00:12:35.000
하지만 보안 수준은 매우 좋다.

00:12:35.000 --> 00:12:48.000
보안 키의 자격 증명은 여러 계정에서 쉽게 추측하거나 재사용할 수 없으며, OS 수준에서 피싱 보호 기능이 내장되어 있습니다.

00:12:48.000 --> 00:12:50.000
하지만, 그 보안에는 대가가 따른다.

00:12:50.000 --> 00:13:00.000
자격 증명이 단일 보안 키에 연결되어 있고 해당 보안 키가 분실, 도난 또는 손상된 경우, 모든 자격 증명도 마찬가지입니다.

00:13:00.000 --> 00:13:11.000
입양인은 추가 보안 키를 구매하고, 안전한 곳에 보관하고, 동시에 둘 다 잃지 않기를 바라는 것과 같은 백업 시스템을 갖추고 있어야 합니다.

00:13:11.000 --> 00:13:21.000
하지만 WebAuthn 덕분에, 그들은 매우 강력한 피싱 저항을 제공하고 서버에 저장된 비밀의 필요성을 제거합니다.

00:13:21.000 --> 00:13:28.000
iOS 14.5에서는 iOS의 모든 브라우저에서 작동하도록 보안 키 지원을 확장했습니다.

00:13:28.000 --> 00:13:40.000
macOS Monterey와 iOS 15의 새로운 기능, 우리는 또한 macOS와 iOS의 모든 앱에서 처음으로 보안 키 API를 사용할 수 있도록 하고 있습니다.

00:13:40.000 --> 00:13:51.000
이 API는 웹의 WebAuthn API와 동등한 기본으로 AuthenticationServices 프레임워크의 ASAuthorization API 제품군에 추가되고 있습니다.

00:13:51.000 --> 00:14:03.000
ASAuthorization은 비밀번호, Apple로 로그인 및 보안 키를 포함하여 시스템이 지원하는 모든 메커니즘으로 로그인할 수 있는 원스톱 상점입니다.

00:14:03.000 --> 00:14:09.000
하지만 보안 키와 같은 추가 하드웨어를 가지고 다니는 것이 반드시 모든 사람을 위한 것은 아니다.

00:14:09.000 --> 00:14:23.000
우리는 이 API가 사용자의 유용성 절충이 특별한 보안 요구 사항보다 중요한 특히 높은 보안 컨텍스트에서 앱에 유용할 것이라고 믿으며, 해당 범주에 속하는 경우 시도해 볼 수 있게 되어 기쁩니다.

00:14:23.000 --> 00:14:30.000
이제, 키 쌍을 사용하는 암호 없는 인증은 인증 기술의 다음 큰 것이다.

00:14:30.000 --> 00:14:40.000
이 표준은 계정 보안을 추진하기 위해 플랫폼 공급업체와 서비스 소유자 모두의 업계 전반에 걸친 공동 노력이었다.

00:14:40.000 --> 00:14:49.000
WebAuthn에 대한 지원은 운영 체제, 앱 플랫폼, 웹 브라우저 및 웹사이트에서 증가하고 있다.

00:14:49.000 --> 00:15:13.000
이 비디오의 나머지 부분에 대해 이야기할 것이며, 여기서 소개하게 되어 정말 기쁩니다. 포스트 패스워드 세계에 대한 Apple의 기여에 대한 미리보기입니다. 모든 iPhone, iPad 및 Mac에 WebAuthn의 보안을 구축하여 모든 곳에서 비밀번호를 대체하는 새로운 기능입니다.

00:15:13.000 --> 00:15:17.000
그것은 "아이클라우드 키체인의 비밀번호"라고 불린다.

00:15:17.000 --> 00:15:23.000
이 새로운 기능은 iCloud 키체인에 "암호"라고 불리는 새로운 유형의 자격 증명을 저장합니다.

00:15:23.000 --> 00:15:36.000
암호키는 모든 장치에서 백업, 동기화 및 작업의 유용성과 결합된 표준이 제공하는 놀라운 보안을 갖춘 WebAuthn 자격 증명입니다.

00:15:36.000 --> 00:15:40.000
우리는 그것들을 iCloud 키체인에 저장하고 있습니다.

00:15:40.000 --> 00:15:47.000
iCloud 키체인의 다른 모든 것과 마찬가지로, 그것들은 종단간 암호화되어 있기 때문에 Apple도 읽을 수 없습니다.

00:15:47.000 --> 00:15:50.000
네 비밀은 네 비밀이야.

00:15:50.000 --> 00:15:53.000
그리고 그것들은 사용하기 매우 쉽다.

00:15:53.000 --> 00:15:58.000
대부분의 경우, 로그인하려면 한 번의 탭이나 클릭만 하면 됩니다.

00:15:58.000 --> 00:16:09.000
그리고 그들은 WebAuthn과 iCloud 키체인의 결합된 보안 덕분에 오늘날 대부분의 암호 플러스 초 요소 솔루션보다 강력합니다.

00:16:09.000 --> 00:16:21.000
그리고 한 번의 탭으로 로그인하기 때문에, 오늘날 거의 모든 일반적인 형태의 인증보다 동시에 더 쉽고, 빠르고, 더 안전합니다.

00:16:21.000 --> 00:16:23.000
그걸 그 차트에 추가하자.

00:16:23.000 --> 00:16:29.000
제가 방금 말했듯이, 그것은 사용하기 매우 쉽습니다; 보통 한 번의 탭이나 클릭으로 로그인할 수 있습니다.

00:16:29.000 --> 00:16:35.000
macOS Monterey와 iOS 15의 일부로 출시하는 것은 모든 Apple 기기에서 작동합니다.

00:16:35.000 --> 00:16:44.000
물론, 모든 사람의 비밀번호를 대체하려면, 이 기술은 iCloud 키체인을 지원하지 않는 장치를 포함하여 모든 장치에서 작동해야 합니다.

00:16:44.000 --> 00:16:49.000
그 기능은 macOS Monterey와 iOS 15에는 존재하지 않는다.

00:16:49.000 --> 00:16:56.000
모든 Apple 기기에 내장되어 있기 때문에, iPhone, iPad 또는 Mac이 근처에 있을 때 언제든지 사용할 수 있습니다.

00:16:56.000 --> 00:16:59.000
추가 하드웨어가 필요하지 않습니다.

00:16:59.000 --> 00:17:06.000
그것은 WebAuthn 표준과 iCloud 키체인의 일부인 모든 고급 보호 기능을 기반으로 합니다.

00:17:06.000 --> 00:17:13.000
그리고 iCloud 키체인에 의해 뒷받침되기 때문에, 모든 Apple 기기를 잃어버리더라도 자격 증명을 다시 받을 수 있습니다.

00:17:13.000 --> 00:17:18.000
그것은 보안 키와 동일한 강력한 플랫폼 제공 피싱 저항을 가지고 있다.

00:17:18.000 --> 00:17:31.000
그리고 그것은 공개/개인 키 쌍을 사용하기 때문에, 또한 서버가 인증 비밀을 저장하는 사업에서 벗어날 수 있다는 것을 의미하며, 공격자에게 덜 가치 있는 표적이 된다.

00:17:31.000 --> 00:17:34.000
그래서 이게 작동하는 방식이야.

00:17:34.000 --> 00:17:42.000
이것은 우리가 가장 좋아하는 인증 데모 앱인 Shiny이며, 이 비디오의 관련 링크에서 소스 코드를 찾을 수 있습니다.

00:17:42.000 --> 00:17:45.000
먼저, 저는 제 계정을 만들어야 합니다.

00:17:45.000 --> 00:17:51.000
사용자 이름을 입력하고 계정 만들기 버튼을 탭할 것입니다.

00:17:51.000 --> 00:17:58.000
그런 다음, 신뢰할 수 있는 시스템 시트는 자격 증명과 내가 그것을 사용할 것으로 예상할 수 있는 곳에 대한 정보를 제공합니다.

00:17:58.000 --> 00:18:03.000
나는 계속, Face ID를 탭할 거야, 그리고 난 끝났어.

00:18:03.000 --> 00:18:14.000
나는 정말로 그것에 대해 생각할 필요가 없었지만, 이제 내 iCloud 키체인에 안전하게 저장된 이 계정에 대한 매우 강력한 공개/개인 키 자격 증명을 가지고 있다.

00:18:14.000 --> 00:18:19.000
내가 이 앱으로 돌아와서 로그인하고 싶을 때, 그것은 똑같이 쉽다.

00:18:19.000 --> 00:18:28.000
시트가 나오면, 나는 내가 로그인하고 있는 앱의 이름과 내 계정을 포함하여 매우 명확한 질문을 받는다.

00:18:28.000 --> 00:18:34.000
그게 내가 원하는 거야, 그래서 나는 계속, Face ID를 탭할 거야, 그리고 난 끝났어.

00:18:34.000 --> 00:18:35.000
그게 다야!

00:18:35.000 --> 00:18:40.000
이것이 사람들이 이 새로운 자격 증명을 만들고 사용하는 데 필요한 전부입니다.

00:18:40.000 --> 00:18:57.000
그리고 그들은 시스템 관리 공용/개인 키 쌍이기 때문에, 재사용되거나 추측할 수 없으며, 앱이나 웹사이트의 침해에 취약하지 않으며, 운영 체제와 브라우저에 매우 강력한 피싱 보호가 내장되어 있습니다.

00:18:57.000 --> 00:19:01.000
브라우저에 대해 말하자면, 이러한 자격 증명은 웹에서도 작동합니다.

00:19:01.000 --> 00:19:08.000
여기 저는 WebAuthn을 채택한 Shiny 웹사이트의 홈페이지에 있는 Safari에 있습니다.

00:19:08.000 --> 00:19:17.000
로그인 버튼을 탭하면, 방금 만든 자격 증명이나 보안 키를 사용할 수 있는 옵션이 있습니다.

00:19:17.000 --> 00:19:23.000
여기서 계속, Face ID를 탭하면 앱에서처럼 로그인할 수 있습니다.

00:19:23.000 --> 00:19:27.000
이것은 또한 iOS의 모든 웹 브라우저 앱에서 작동합니다.

00:19:27.000 --> 00:19:29.000
그리고 그건 Mac에서도 작동해!

00:19:29.000 --> 00:19:42.000
이러한 자격 증명은 iCloud 키체인에 저장되므로 모든 장치에서 동기화되며, 모든 종류의 Mac 앱과 Safari의 웹에서도 작동합니다.

00:19:42.000 --> 00:19:46.000
이제 구현을 살펴봅시다.

00:19:46.000 --> 00:19:56.000
우선, 강력한 플랫폼 제공 피싱 보호가 앱에서 작동하려면, 장치는 앱과 웹사이트 간의 강력한 연관성이 필요합니다.

00:19:56.000 --> 00:20:02.000
이것은 "webcredentials" 연결 유형을 사용하여 관련 도메인을 통해 수행됩니다.

00:20:02.000 --> 00:20:10.000
여기서 너무 자세히 설명하지는 않겠지만, 몇 년 전의 "앱용 비밀번호 자동 완성 소개" 비디오를 보고 더 많은 것을 배울 수 있습니다.

00:20:10.000 --> 00:20:13.000
다음으로, 계정을 만드는 것에 대해 이야기해 봅시다.

00:20:13.000 --> 00:20:16.000
여기 코드는 사실 꽤 간단하다.

00:20:16.000 --> 00:20:18.000
그걸 분해하자.

00:20:18.000 --> 00:20:31.000
우리의 createAccount 기능은 세 가지 입력이 필요합니다: 서버에서 가져온 일회용 챌린지, 계정의 사용자 이름, 그리고 일반적으로 백엔드 계정의 식별자인 사용자 ID.

00:20:31.000 --> 00:20:36.000
먼저, 요청 객체를 만들려면 요청 제공자가 필요합니다.

00:20:36.000 --> 00:20:41.000
relyingPartyIdentifier는 WebAuthn 설정에 따라 다르지만, 일반적으로 도메인 이름입니다.

00:20:41.000 --> 00:20:49.000
해당 공급자를 사용하여 등록 요청을 만들고 인증 컨트롤러에 요청을 전달하십시오.

00:20:49.000 --> 00:20:55.000
마지막으로, 권한 부여 컨트롤러에 대리인과 presentationContextProvider를 설정하고 요청을 시작하세요.

00:20:55.000 --> 00:21:00.000
이렇게 하면 이전부터 그 시트가 나타나서 자격 증명을 만들 것을 요청할 것입니다.

00:21:00.000 --> 00:21:07.000
거래가 완료되면, 새 자격 증명의 세부 사항이 포함된 대리자 콜백을 받게 될 것입니다.

00:21:07.000 --> 00:21:10.000
이제, 로그인은 매우 비슷하다.

00:21:10.000 --> 00:21:12.000
몇 가지만 바뀌어야 해.

00:21:12.000 --> 00:21:21.000
등록 요청을 만드는 대신, 이제 로그인할 때 사용되는 WebAuthn 용어인 assertionRequest를 생성합니다.

00:21:21.000 --> 00:21:25.000
주장 요청은 도전만 있으면 된다.

00:21:25.000 --> 00:21:27.000
그리고 그게 네가 바꿔야 할 전부야.

00:21:27.000 --> 00:21:33.000
인증 컨트롤러에 대한 이 매개 변수가 배열이라는 것을 강조하고 싶습니다.

00:21:33.000 --> 00:21:43.000
비밀번호와 Apple로 로그인을 포함하여 앱이 지원하는 모든 다양한 인증 메커니즘에 대한 요청 목록을 여기에 전달할 수 있습니다.

00:21:43.000 --> 00:21:48.000
이전의 그 시트는 현재 사용 가능한 자격 증명으로 채워질 것이다.

00:21:48.000 --> 00:21:56.000
유일한 주의 사항은 공개 키 등록 요청이 비등록 옵션과 섞일 수 없다는 것입니다.

00:21:56.000 --> 00:22:02.000
좋아요, 마지막으로, 승인이 완료되면 대리자 객체에 대한 콜백에 대해 이야기해 봅시다.

00:22:02.000 --> 00:22:07.000
자격 증명은 제공된 인증 객체의 속성이다.

00:22:07.000 --> 00:22:13.000
사용자가 새로운 플랫폼 자격 증명을 등록하면, 플랫폼 자격 증명 등록을 받게 됩니다.

00:22:13.000 --> 00:22:21.000
그들이 기존 플랫폼 자격 증명으로 로그인했다면, 당신은 플랫폼 자격 증명 주장을 받게 될 것입니다.

00:22:21.000 --> 00:22:28.000
또는 그들이 당신이 지원하는 다른 것으로 로그인했다면, 당신은 여기에서도 그것을 처리할 수 있습니다.

00:22:28.000 --> 00:22:39.000
어쨌든, 웹에서처럼 자격 증명 객체에서 필요한 속성을 읽고, 그 값을 서버로 보내고, 확인하고, 작업을 완료해야 합니다.

00:22:39.000 --> 00:22:41.000
그리고 그게 작동하는 방식이야.

00:22:41.000 --> 00:22:44.000
이제, 저는 단지 몇 가지 세부 사항을 더 언급하고 싶습니다.

00:22:44.000 --> 00:22:51.000
비밀번호에서 벗어나는 것은 시간이 걸릴 것이며, 세부 사항을 올바르게 파악하는 것이 중요합니다.

00:22:51.000 --> 00:23:00.000
macOS Monterey와 iOS 15에서 iCloud 키체인의 암호키는 기술 미리보기로 출시되며 기본적으로 꺼져 있습니다.

00:23:00.000 --> 00:23:05.000
iOS에서는 설정 앱의 개발자 설정 섹션에 새로운 스위치가 있습니다.

00:23:05.000 --> 00:23:11.000
이것을 켜면 앱과 웹 모두에서 동기화된 키를 사용할 수 있습니다.

00:23:11.000 --> 00:23:15.000
그리고 macOS에서, 스위치는 사파리의 개발 메뉴에 있다.

00:23:15.000 --> 00:23:20.000
먼저, 사파리의 고급 설정에서 개발 메뉴를 켜야 합니다.

00:23:20.000 --> 00:23:25.000
이에 대한 설정은 Safari 환경 설정의 고급 창 하단에서 찾을 수 있습니다.

00:23:25.000 --> 00:23:32.000
그런 다음, 개발 메뉴에서 동기화 플랫폼 인증기를 켜는 옵션을 찾을 수 있습니다.

00:23:32.000 --> 00:23:35.000
테스트할 때 반드시 기능을 켜세요.

00:23:35.000 --> 00:23:42.000
macOS Monterey와 iOS 15에서, 이 암호키는 프로덕션 계정이 아닌 테스트를 위한 것입니다.

00:23:42.000 --> 00:23:50.000
이 미리보기의 강조점은 iCloud 키체인 기반 WebAuthn 구현인 인증 기술이다.

00:23:50.000 --> 00:23:59.000
암호에서 벗어나는 업계 전반의 전환은 이 미리보기의 일부가 아닌 사려 깊고 일관되게 적용된 디자인 패턴이 필요할 것이다.

00:23:59.000 --> 00:24:05.000
그리고 마지막으로, 이것은 미리보기이기 때문에, 우리는 그것이 꺼졌을 때 우아하게 작동하는지 확인했습니다.

00:24:05.000 --> 00:24:16.000
플랫폼 등록 요청은 오류를 반환하며, 다른 자격 증명 요청 유형과 혼합된 경우에도 스위치가 꺼져 있을 때 플랫폼 주장 요청은 자동으로 무시됩니다.

00:24:16.000 --> 00:24:19.000
그래서 여기 네가 다음에 할 수 있는 게 있어.

00:24:19.000 --> 00:24:25.000
공개 키 기반의 피싱 방지 자격 증명은 계정 인증의 다음 개척지이다.

00:24:25.000 --> 00:24:32.000
시작하는 데 도움이 되도록 이 비디오에서 링크된 개발자 문서와 샘플 코드를 확인하세요.

00:24:32.000 --> 00:24:42.000
그리고 아직 가지고 있지 않다면, 서버에 WebAuthn 구현을 불러와서 WebAuthn 기반 자격 증명을 사용해 볼 수 있습니다.

00:24:42.000 --> 00:24:54.000
이제, 제가 가장 좋아하는 부분: iCloud 키체인에서 패스키의 기술 미리보기를 사용하여 웹사이트와 앱의 기존 워크플로우에 어떻게 맞는지 확인해 보세요.

00:24:54.000 --> 00:25:00.000
시도해 볼 때, 개발자 포럼과 피드백 어시스턴트에서 어떻게 생각하는지 알려주세요.

00:25:00.000 --> 00:25:02.000
우리는 정말 네 소식을 듣고 싶어.

00:25:02.000 --> 00:25:12.000
앞서 언급했듯이, 이것은 비밀번호를 교체하기 위한 다년간의 노력의 첫 번째 단계이며, 우리는 여러분 모두가 말해야 하는 것에 매우 관심이 있습니다.

00:25:12.000 --> 00:25:14.000
봐줘서 고마워!

00:25:14.000 --> 23:59:59.000
♪

