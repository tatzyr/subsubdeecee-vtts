WEBVTT

00:00:00.000 --> 00:00:05.000
♪ 베이스 음악 연주 ♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:12.000
네이선 태너: 안녕하세요, WWDC에 오신 것을 환영합니다!

00:00:12.000 --> 00:00:16.000
제 이름은 네이선이고, 저는 접근성 팀의 엔지니어입니다.

00:00:16.000 --> 00:00:22.000
오늘 우리는 기본을 넘어 탁월하고 접근하기 쉬운 SwiftUI 앱을 제공하는 방법을 배울 것입니다.

00:00:22.000 --> 00:00:27.000
올해는 SwiftUI의 접근성을 위한 큰 도약이다.

00:00:27.000 --> 00:00:30.000
애플에서 접근성은 우리의 핵심 가치 중 하나이다.

00:00:30.000 --> 00:00:40.000
모든 플랫폼에서 우리의 보조 기술은 물리적, 시각적, 청각 또는 운동 장애에 관계없이 누구나 앱을 사용할 수 있도록 합니다.

00:00:40.000 --> 00:00:47.000
우리 팀과 저는 대부분의 앱에 기본적으로 액세스할 수 있도록 노력하고 있지만, 경험을 풍요롭게 하기 위해 항상 더 많은 것을 할 수 있습니다.

00:00:47.000 --> 00:00:53.000
오늘 저는 이 경험을 쉽게 풍요롭게 하는 SwiftUI를 위한 새로운 도구와 API를 보여드리겠습니다.

00:00:53.000 --> 00:00:56.000
Xcode의 툴링 개선부터 시작합시다.

00:00:56.000 --> 00:00:59.000
SwiftUI Previews는 우리 중 얼마나 많은 사람들이 앱을 개발하는지 바꿨다.

00:00:59.000 --> 00:01:09.000
앱을 실행할 필요 없이 여러 환경에서 뷰를 반복할 수 있는 능력을 획기적으로 향상시킵니다.

00:01:09.000 --> 00:01:15.000
클릭 한 번으로 가장 중요한 접근성 수정자를 만들기 위해, 우리는 엄선된 접근성 편집기 목록을 추가했습니다.

00:01:15.000 --> 00:01:19.000
나는 이것이 모든 사람들이 항상 그들의 견해에 접근할 수 있도록 장려하기를 바란다.

00:01:19.000 --> 00:01:21.000
하지만 더 있어.

00:01:21.000 --> 00:01:31.000
접근성 수정자는 미리보기에 시각적으로 변경되지 않기 때문에, Xcode를 떠나지 않고도 보기의 접근성을 검사할 수 있는 새로운 도구가 개발되었습니다.

00:01:31.000 --> 00:01:36.000
편집자 패널에서 새로운 접근성 패널로 전환합시다.

00:01:36.000 --> 00:01:42.000
Xcode 13에서 배송, SwiftUI 미리보기는 이제 접근성 미리보기도 특징으로 합니다.

00:01:42.000 --> 00:01:46.000
그것으로, 당신은 실시간으로 미리보기를 위해 접근성 요소를 검사할 수 있습니다.

00:01:46.000 --> 00:01:48.000
그리고 이건 게임 체인저야.

00:01:48.000 --> 00:01:56.000
접근성 미리보기는 각 보조 기술에 대한 깊은 이해가 없더라도 접근 가능한 앱을 만드는 데 도움이 될 것입니다.

00:01:56.000 --> 00:02:01.000
접근성 미리보기에 변화가 어떻게 반영되는지 자세히 살펴봅시다.

00:02:01.000 --> 00:02:04.000
이것은 우리가 방금 본 보기의 단순화된 버전이다.

00:02:04.000 --> 00:02:12.000
미리보기를 실행한 후, VStack을 선택할 수 있으며 접근성 미리보기가 정렬된 순서로 요소를 표시하도록 업데이트됩니다.

00:02:12.000 --> 00:02:20.000
각 요소는 항상 라벨과 특성과 같은 기본 속성을 표시합니다.

00:02:20.000 --> 00:02:25.000
예를 들어, 텍스트 보기는 문자열을 레이블로 하는 접근성 요소를 만들 것이다.

00:02:25.000 --> 00:02:28.000
그것은 또한 .isStaticText 특성을 얻는다.

00:02:28.000 --> 00:02:35.000
미리보기는 .isHeader 특성을 추가하는 것과 같은 접근성 변경 사항에 대해 업데이트될 것입니다.

00:02:35.000 --> 00:02:43.000
또한 자동 SF 심볼 라벨과 같이 무대 뒤에서 일어나는 자동 접근성을 볼 수 있습니다.

00:02:43.000 --> 00:02:49.000
예를 들어, checkmark.seal.fill 기호는 기본적으로 "확인됨"으로 표시됩니다.

00:02:49.000 --> 00:02:55.000
기호의 기본 라벨에 의존하고 있다면, 인터페이스를 정확하게 설명하는지 확인하는 것이 중요합니다.

00:02:55.000 --> 00:03:03.000
우리는 앱의 모든 사용자에게 탁월한 경험을 제공하는 데 도움이 되는 다섯 가지 중요한 영역을 거치면서 접근성 미리보기를 계속 사용할 것입니다.

00:03:03.000 --> 00:03:08.000
우리는 사용자 지정 컨트롤에 접근할 수 있는 가장 좋은 방법을 검토하는 것으로 시작할 것입니다.

00:03:08.000 --> 00:03:12.000
다음으로, 우리는 아이들과 함께 경치에 접근할 수 있도록 하는 방법에 대해 논의할 것이다.

00:03:12.000 --> 00:03:19.000
일반적인 탐색 문제에 대해 앱을 감사하는 방법과 접근성 미리보기가 이를 어떻게 도울 수 있는지 강조하겠습니다.

00:03:19.000 --> 00:03:25.000
그런 다음 VoiceOver 로터로 앱의 내비게이션을 과급하는 방법을 보여드리겠습니다.

00:03:25.000 --> 00:03:31.000
그리고 마지막으로, 우리는 초점과 그것이 보조 기술과 어떤 관련이 있는지 살펴볼 것이다.

00:03:31.000 --> 00:03:35.000
나는 Wallet Pal이라고 부르는 새로운 금융 앱의 프로토타입을 만들고 있다.

00:03:35.000 --> 00:03:39.000
아직 초기 단계에 있지만, 지금까지는 초기 디자인에 꽤 만족합니다.

00:03:39.000 --> 00:03:43.000
나는 초기 베타 테스터들도 그것을 좋아한다는 소식을 듣고 기뻤다.

00:03:43.000 --> 00:03:49.000
이제 UI를 다듬었으니, 접근성 인터페이스를 다듬는 데 시간을 할애해야 한다.

00:03:49.000 --> 00:03:54.000
접근성 인터페이스는 모든 사람이 사용할 수 있도록 시각적 경험을 보완합니다.

00:03:54.000 --> 00:04:02.000
저는 몇몇 VoiceOver 사용자에게 Wallet Pal 테스트를 도와달라고 요청했고 앱이 탐색하기 어렵고 완전히 접근할 수 없다고 들었습니다.

00:04:02.000 --> 00:04:08.000
부품이 VoiceOver에 접근할 수 없다면, 다른 보조 기술에도 접근할 수 없습니다.

00:04:08.000 --> 00:04:14.000
누구나 Wallet Pal을 사용할 수 있는 것이 중요하므로, 어디에서 경험을 개선할 수 있는지 조사해 봅시다.

00:04:14.000 --> 00:04:20.000
우리는 사용자가 Wallet Pal의 중요한 기능인 예산을 편집할 수 없다는 보고서로 시작할 것입니다.

00:04:20.000 --> 00:04:27.000
이것은 사용자가 음식, 엔터테인먼트 및 저축 예산을 편집할 수 있는 예산 플래너 보기입니다.

00:04:27.000 --> 00:04:32.000
Wallet Pal의 디자인에 맞추기 위해, 나는 결국 사용자 지정 슬라이더를 만들어야 했다.

00:04:32.000 --> 00:04:39.000
나는 모양에서 예산 슬라이더를 만들고 상호 작용을 위해 드래그 제스처를 사용하여 이것을 달성했다.

00:04:39.000 --> 00:04:50.000
SwiftUI의 모양은 놀랍고 독특한 뷰를 쉽게 만들 수 있게 해주지만, 기본적으로 접근할 수 없기 때문에 내 예산 슬라이더도 아니다.

00:04:50.000 --> 00:04:54.000
이것이 일부 사용자가 예산을 편집할 수 없는 이유임에 틀림없다.

00:04:54.000 --> 00:05:01.000
SwiftUI 미리보기를 실행하고 SliderShape를 선택하여 액세스할 수 없다는 것을 확인할 수 있습니다.

00:05:01.000 --> 00:05:07.000
접근성 미리보기는 요소가 없다는 것을 보여주므로, 이 컨트롤에 접근할 수 없습니다.

00:05:07.000 --> 00:05:14.000
이상적으로, 우리는 변경할 수 있는 값을 가진 단일 라벨이 지정된 접근성 요소를 가져야 한다.

00:05:14.000 --> 00:05:23.000
대조적으로, 표준 컨트롤은 기본적으로 접근할 수 있으며, 이는 훌륭한 경험을 제공하기 위해 추가 노력이 거의 또는 전혀 필요하지 않다는 것을 의미합니다.

00:05:23.000 --> 00:05:34.000
SwiftUI는 뷰 유형과 초기화 매개 변수를 사용하여 접근성 요소의 레이블, 값, 특성 및 작업을 자동으로 도출합니다.

00:05:34.000 --> 00:05:38.000
그래서 우리의 맞춤형 예산 슬라이더에 접근할 수 있는 가장 좋은 방법은 무엇인가요?

00:05:38.000 --> 00:05:48.000
표준 슬라이더는 기본적으로 액세스할 수 있기 때문에, 우리 팀과 나는 한 뷰의 접근성이 다른 뷰로 표현될 수 있는 API를 갖는 것이 좋을 것이라고 생각했다.

00:05:48.000 --> 00:05:51.000
이것이 우리가 접근성 표현(표현:)을 만들도록 이끌었다.

00:05:51.000 --> 00:05:57.000
한 뷰의 접근성이 다른 뷰에 의해 정의될 수 있도록 하는 API입니다.

00:05:57.000 --> 00:06:05.000
나는 이것이 보조 기술에 의해 슬라이더로 인식되기를 원하기 때문에, 그것이 내가 접근성 표현을 위해 사용할 것이다.

00:06:05.000 --> 00:06:11.000
접근성 대표(대표:)를 통해, 우리는 이제 이 예산 슬라이더에 접근할 수 있도록 하고 있습니다.

00:06:11.000 --> 00:06:18.000
슬라이더의 경험을 개선하는 데 필요한 유일한 변화는 가치를 달러로 설명하는 것이다.

00:06:18.000 --> 00:06:23.000
그리고 좋아요, 그것처럼, 이제 우리의 예산 슬라이더에 완벽하게 접근할 수 있습니다.

00:06:23.000 --> 00:06:27.000
macOS에서, 제어 유형은 VoiceOver 사용자에게도 말할 것이다.

00:06:27.000 --> 00:06:34.000
그래서 우리의 예산 슬라이더 표현에서 슬라이더 보기를 사용함으로써, 그것은 슬라이더로 발표될 것이다.

00:06:34.000 --> 00:06:40.000
사용자 지정 컨트롤에 액세스할 수 있도록 가능한 경우 accessibilityRepresentation(representation:)을 사용하는 것이 좋습니다.

00:06:40.000 --> 00:06:43.000
이것은 접근성 대표(대표:)를 사용하는 한 가지 방법일 뿐입니다.

00:06:43.000 --> 00:06:47.000
그것의 유연성은 더 많은 창의적인 사용을 가능하게 한다.

00:06:47.000 --> 00:06:51.000
앱에서 다른 접근성 버그를 수정하는 데 사용할 수 있는지 봅시다.

00:06:51.000 --> 00:06:59.000
이제 예산을 편집할 수 있는 기능적 기능을 수정했지만, 일부 사용자는 예산 플래너 보기로 이동하는 방법을 찾을 수 없다고 보고했습니다.

00:06:59.000 --> 00:07:03.000
Wallet Pal을 디자인할 때, 우리는 모든 버튼에 SF 기호를 사용하기로 결정했습니다.

00:07:03.000 --> 00:07:10.000
SF 심볼은 훌륭한 기본 접근성 라벨을 가지고 있을 수 있지만, 항상 의도된 사용 사례에 맞지 않을 수 있습니다.

00:07:10.000 --> 00:07:15.000
문제가 잘못 표시된 버튼인지 조사해 봅시다.

00:07:15.000 --> 00:07:19.000
NavigationBarView에는 예산 편집 버튼이 포함되어 있습니다.

00:07:19.000 --> 00:07:27.000
우리는 많은 버튼에 대해 SF 심볼에 의존하기 때문에, SymbolButtonStyle이라는 사용자 지정 버튼 스타일을 만들었습니다.

00:07:27.000 --> 00:07:36.000
하지만 "예산 편집" 라벨로 버튼을 초기화했음에도 불구하고, 버튼의 라벨은 slider.vertical.3인 것으로 보인다.

00:07:36.000 --> 00:07:41.000
그래서 접근성 라벨은 SF 심볼에서 파생되고 있다.

00:07:41.000 --> 00:07:45.000
SymbolButtonStyle을 자세히 살펴봅시다.

00:07:45.000 --> 00:07:49.000
SymbolButtonStyle의 makeBody(configuration:) 메서드는 이미지 뷰를 반환합니다.

00:07:49.000 --> 00:07:55.000
버튼을 초기화하는 예산 편집 문자열은 구성의 라벨로 텍스트 보기를 생성합니다.

00:07:55.000 --> 00:07:59.000
하지만 이 스타일은 구성의 라벨을 완전히 무시한다.

00:07:59.000 --> 00:08:04.000
이것이 버튼이 "예산 편집"이라고 표시되어 있지 않은 이유입니다.

00:08:04.000 --> 00:08:12.000
우리는 SF 기호가 시각적으로 나타나기를 원하지만, 버튼의 접근성이 구성의 라벨로 표현되기를 원합니다.

00:08:12.000 --> 00:08:17.000
그래서 이것은 접근성 표현(표현:)을 위한 훌륭한 사용 사례처럼 보인다.

00:08:17.000 --> 00:08:26.000
accessibilityRepresentation(representation:)을 사용하여 이미지 보기의 접근성을 다른 보기, 이 경우 구성의 라벨로 대체할 수 있습니다.

00:08:26.000 --> 00:08:30.000
이렇게 하면, 우리는 버튼을 만드는 데 사용한 라벨을 보존할 수 있습니다.

00:08:30.000 --> 00:08:40.000
accessibilityRepresentation(representation:)은 사용자 지정 컨트롤에 접근할 수 있도록 하는 이상적이고 권장되는 방법일 뿐만 아니라, 뷰에 접근할 수 있도록 하는 새로운 창의적인 가능성을 열어줍니다.

00:08:40.000 --> 00:08:46.000
다음으로, 아이들과 접근성 컨테이너 간의 관계에 대해 논의해 봅시다.

00:08:46.000 --> 00:08:53.000
기억하시겠지만, 접근성 요소는 접근성 컨테이너의 자식으로 그룹으로 함께 포장될 수 있습니다.

00:08:53.000 --> 00:09:00.000
이것은 accessibilityElement(children:) 수정자와 포함 아동 행동으로 이루어집니다.

00:09:00.000 --> 00:09:11.000
익숙하지 않은 경우, 포함된 자식 행동은 기존 접근성 요소를 자식으로 감싸는 접근성 컨테이너를 만드는 데 사용할 수 있습니다.

00:09:11.000 --> 00:09:18.000
하지만 대신 접근성 요소가 있고 그 아이들을 설정하고 싶다면 어떨까요?

00:09:18.000 --> 00:09:23.000
나는 예산 이력 그래프에 접근하려고 할 때 이 사건에 부딪치고 있다.

00:09:23.000 --> 00:09:26.000
사용자들은 그래프에 완전히 접근할 수 없다고 보고했다.

00:09:26.000 --> 00:09:35.000
그래서 이것은 보조 기술이 예산 기록 헤더에 초점을 맞추고 다음 요소로 이동하려고 할 때, 그들은 Alerts 헤더에서 끝난다는 것을 의미합니다.

00:09:35.000 --> 00:09:38.000
VoiceOver 사용자는 이 그래프가 존재한다는 사실조차 모를 것이다.

00:09:38.000 --> 00:09:41.000
나는 새로운 캔버스 뷰를 사용하여 그래프를 만들었다.

00:09:41.000 --> 00:09:44.000
캔버스는 모양 모음을 더 쉽게 그릴 수 있게 해준다.

00:09:44.000 --> 00:09:51.000
캔버스에 대한 자세한 내용은 앱에 풍부한 그래픽을 추가하는 데 사용할 수 있는 방법에 대한 제이콥의 프레젠테이션을 확인하세요.

00:09:51.000 --> 00:09:56.000
접근성을 위한 가장 중요한 테이크아웃은 캔버스가 모양 모음을 그린다는 것이다.

00:09:56.000 --> 00:10:01.000
그리고 우리가 BudgetSlider에서 본 것처럼, 모양은 기본적으로 접근할 수 없습니다.

00:10:01.000 --> 00:10:08.000
모든 사용자는 예산 내역을 볼 수 있어야 하므로, 모든 사람이 접근할 수 있도록 합시다.

00:10:08.000 --> 00:10:12.000
기본부터 시작해서, 캔버스에 라벨을 붙여봅시다.

00:10:12.000 --> 00:10:17.000
이것은 자동으로 캔버스에 대한 새로운 접근성 요소를 만들고 라벨을 할당할 것이다.

00:10:17.000 --> 00:10:23.000
이제, 그래프의 각 막대가 자체 접근성 요소로 표현되기를 원합니다.

00:10:23.000 --> 00:10:29.000
이것은 우리가 접근성 요소를 가지고 있고 그 아이들을 제공하고자 하는 사용 사례이다.

00:10:29.000 --> 00:10:34.000
이를 위해, 나는 새로운 접근성 어린이(어린이:) 수정자를 사용할 것이다.

00:10:34.000 --> 00:10:42.000
이것은 접근성 요소를 접근성 컨테이너로 변환하여 라벨과 같은 다른 접근성 속성을 보존할 것이다.

00:10:42.000 --> 00:10:50.000
수정자는 ViewBuilder를 사용하여 접근성 컨테이너의 자식으로 새 뷰를 설정할 수 있습니다.

00:10:50.000 --> 00:10:59.000
우리의 예산 이력 그래프가 수평 막대 그래프를 그리고 있다는 것을 기억하세요, 그래서 우리는 HStack을 사용하고 각 예산에 대한 보기를 반환할 것입니다.

00:10:59.000 --> 00:11:06.000
프레임이 사용 가능한 모든 수직 공간을 채울 수 있도록 각 접근성 요소에 직사각형을 사용할 것입니다.

00:11:06.000 --> 00:11:11.000
이것은 각 접근성 요소의 프레임을 시각적으로 표시된 것보다 더 크게 만들 것이며, 괜찮습니다.

00:11:11.000 --> 00:11:23.000
크지만 일관된 프레임을 사용하면 VoiceOver 사용자가 화면을 가로질러 손가락을 드래그하여 접근성 요소를 스캔할 때 iOS에서 더 쉽게 탐색할 수 있습니다.

00:11:23.000 --> 00:11:32.000
accessibilityChildren(children:) 수정자 내에서 HStack을 선택하면, Accessibility Preview는 그래프의 각 막대에 대해 요소가 생성되었음을 확인합니다.

00:11:32.000 --> 00:11:38.000
이것들은 모두 캔버스 접근성 컨테이너의 어린이로서 접근할 수 있을 것이다.

00:11:38.000 --> 00:11:47.000
이러한 변화로, 예산 이력 그래프는 이제 완전히 접근할 수 있으며, 보조 기술은 그래프의 각 막대를 탐색할 수 있습니다.

00:11:47.000 --> 00:11:52.000
각 요소의 프레임이 동일하다는 것을 주목하세요, 이는 이상적입니다.

00:11:52.000 --> 00:11:56.000
더 복잡한 차트의 경우, 우리는 그것들을 접근할 수 있는 다른 방법이 있다.

00:11:56.000 --> 00:12:01.000
그것을 위해, 차트에 접근성을 가져오는 것에 대한 프레스턴의 프레젠테이션을 확인하세요.

00:12:01.000 --> 00:12:09.000
하지만 접근성 어린이의 경우, 뷰의 접근성 요소는 시각적으로 제시된 것과 다를 수 있으므로 훌륭한 경험을 조정할 수 있습니다.

00:12:09.000 --> 00:12:15.000
하지만 접근성 아이들은 또한 결합 행동의 도움으로 접근성을 구성하는 데 사용될 수 있다.

00:12:15.000 --> 00:12:25.000
빠른 새로 고침으로, 결합 자식 행동은 여러 접근성 요소의 속성을 신규 또는 기존 접근성 요소로 병합합니다.

00:12:25.000 --> 00:12:34.000
하지만 접근성 어린이 API를 추가하면, 이제 일반적인 방식으로 접근성을 구성하는 데에도 사용할 수 있습니다.

00:12:34.000 --> 00:12:40.000
접근성 표현으로, 원래의 접근성은 완전히 대체된다.

00:12:40.000 --> 00:12:51.000
이것은 어떤 구성도 일어날 수 없다는 것을 의미한다; 반면에 접근성 아이들은 부가적이다.

00:12:51.000 --> 00:12:57.000
이것은 당신이 나중에 아이들을 결합하여 그들의 속성을 원래 요소로 병합할 수 있다는 것을 의미합니다.

00:12:57.000 --> 00:13:03.000
이것은 접근성 어린이(어린이:) 수정자의 고급 사용 사례이지만, 제가 강조하고 싶은 기능입니다.

00:13:03.000 --> 00:13:08.000
이 프레젠테이션의 접근성 카탈로그 샘플 프로젝트에는 예시가 있습니다.

00:13:08.000 --> 00:13:13.000
저는 여러분 중 많은 사람들이 이런 종류의 구성으로 무엇이 가능한지 탐구하는 것을 보기를 바랍니다.

00:13:13.000 --> 00:13:17.000
accessibilityChildren(children:)은 컨테이너의 자식을 제어할 수 있게 해준다.

00:13:17.000 --> 00:13:25.000
그리고 그것으로, 캔버스로 그려진 복잡한 그래프는 당신이 이미 익숙한 수정자와 보기로 접근할 수 있습니다.

00:13:25.000 --> 00:13:30.000
그리고 결합된 아동 행동으로, 단일 보기의 접근성은 많은 것으로 구성될 수 있다.

00:13:30.000 --> 00:13:38.000
이제 앱의 개별 구성 요소에 액세스할 수 있도록 하는 방법을 배웠으므로, 내비게이션 경험을 개선하기 위해 함께 작업을 시작할 수 있습니다.

00:13:38.000 --> 00:13:42.000
나는 VoiceOver로 Wallet Pal을 탐색하는 것이 혼란스럽고 어렵다고 들었다.

00:13:42.000 --> 00:13:49.000
그래서 우리는 훌륭한 접근 가능한 앱을 제공하고 싶다면 해야 할 일이 더 있다.

00:13:49.000 --> 00:13:53.000
맨 위에 있는 프렌즈 회전목마를 자세히 살펴봅시다.

00:13:53.000 --> 00:13:58.000
나는 아직 이 기능을 구축하지 않았지만, Wallet Pal에 일종의 게임화를 추가할 계획이다.

00:13:58.000 --> 00:14:03.000
그래서 저는 각 친구 보기의 왼쪽 상단에 도전 버튼을 추가했습니다.

00:14:03.000 --> 00:14:09.000
우리는 이미 SymbolButtonStyle을 수정했으므로, 챌린지 버튼은 이제 제대로 표시될 것입니다.

00:14:09.000 --> 00:14:13.000
하지만 사용자들이 내비게이션이 혼란스럽다고 보고하고 있기 때문에, 다른 문제가 있나요?

00:14:13.000 --> 00:14:19.000
그것에 답하기 위해, 우리는 먼저 보조 기술이 Wallet Pal을 어떻게 탐색할지 이해해야 한다.

00:14:19.000 --> 00:14:28.000
기본적으로 접근성 요소는 왼쪽 상단에서 오른쪽 하단까지 다른 요소와 관련된 기하학적 위치에 따라 정렬됩니다.

00:14:28.000 --> 00:14:42.000
즉, 콘텐츠를 차별화하기 위한 접근성 컨테이너 없이 VoiceOver는 각 챌린지 버튼, 이미지 및 친구 추가 버튼, 그리고 마지막으로 사용자 이름이 있는 텍스트를 탐색할 수 있습니다.

00:14:42.000 --> 00:14:48.000
접근성 미리보기의 가장 큰 특징은 접근성 요소를 정렬된 순서대로 보여준다는 것이다.

00:14:48.000 --> 00:14:54.000
이를 통해 보조 기술이 Xcode 내에서 바로 탐색하는 방법을 쉽게 시각화할 수 있습니다.

00:14:54.000 --> 00:14:58.000
예상대로, 정렬된 순서는 우리가 이전에 본 것과 일치한다.

00:14:58.000 --> 00:15:02.000
그리고 이 순서는 확실히 탐색하기에 혼란스러울 것이다.

00:15:02.000 --> 00:15:07.000
이제 접근성 요소의 정렬 순서를 수정할 수 있는 여러 가지 방법이 있습니다.

00:15:07.000 --> 00:15:11.000
우리가 할 수 있는 한 가지는 접근성 컨테이너를 도입하는 것이다.

00:15:11.000 --> 00:15:16.000
포함 동작과 함께 accessibilityElement(children:) 수정자를 추가하겠습니다.

00:15:16.000 --> 00:15:22.000
이것은 각 FriendCellView의 접근성 요소를 접근성 컨테이너에 포장할 것이다.

00:15:22.000 --> 00:15:30.000
이것은 접근성 컨테이너의 자식이 다음 접근성 요소로 이동하기 전에 탐색되기 때문에 탐색 순서를 수정합니다.

00:15:30.000 --> 00:15:39.000
이 변경으로, VoiceOver는 다음 접근성 요소로 이동하기 전에 접근성 컨테이너의 자식을 탐색할 것이다.

00:15:39.000 --> 00:15:42.000
그래서 우리는 훨씬 더 바람직한 내비게이션 순서를 달성한다.

00:15:42.000 --> 00:15:45.000
하지만 우리가 이 경험을 개선하기 위해 더 잘할 수 있을까요?

00:15:45.000 --> 00:15:51.000
한 가지 문제는 사용자가 누구인지 알기 전에 챌린지 버튼이 탐색된다는 것이다.

00:15:51.000 --> 00:15:59.000
VoiceOver 사용자는 챌린지를 보내기 전에 사용자의 이름을 알고 싶어하므로, 이 버튼은 실제로 마지막으로 정렬되어야 합니다.

00:15:59.000 --> 00:16:04.000
우리는 이것을 해결하기 위해 accessibilitySortPriority(_:) 수정자를 사용할 수 있습니다.

00:16:04.000 --> 00:16:10.000
accessibilitySortPriority(_:)는 접근성 컨테이너 내의 요소의 순서를 변경하는 데 사용할 수 있습니다.

00:16:10.000 --> 00:16:16.000
우선 순위가 높은 요소는 먼저 정렬되는 반면, 우선 순위는 낮은 요소는 마지막으로 정렬됩니다.

00:16:16.000 --> 00:16:22.000
우선 순위가 동일한 요소는 기하학적 위치에 따라 정렬됩니다.

00:16:22.000 --> 00:16:29.000
탐색 순서를 개선하기 위해 챌린지 버튼에 accessibilitySortPriority(_:) 수정자를 추가하겠습니다.

00:16:29.000 --> 00:16:37.000
챌린지 버튼의 정렬 순서를 마지막으로 강제하기 위해 기본값이 0이기 때문에 -1의 우선 순위를 사용할 것입니다.

00:16:37.000 --> 00:16:39.000
이제 챌린지 버튼은 마지막으로 탐색될 것이다.

00:16:39.000 --> 00:16:48.000
VoiceOver 사용자가 누구에게 도전을 보내는지 혼란스러워할 가능성이 적기 때문에 이것은 좋은 개선이지만, 여전히 좋지 않다.

00:16:48.000 --> 00:16:55.000
각 FriendCellView를 접근성 컨테이너에 감싸는 대신, 우리는 아이들을 단일 요소로 결합할 수 있습니다.

00:16:55.000 --> 00:17:01.000
결합은 자식의 속성을 기존 또는 새로운 접근성 요소로 병합한다는 것을 기억하세요.

00:17:01.000 --> 00:17:06.000
결합 동작은 또한 최고의 기본 결과를 위해 병합되는 속성을 큐레이팅합니다.

00:17:06.000 --> 00:17:11.000
예를 들어, 챌린지 버튼은 "챌린지 보내기"라는 액션이 되었다.

00:17:11.000 --> 00:17:16.000
이것 또한 내비게이션 순서를 수정하고 접근성 요소의 수를 줄인다.

00:17:16.000 --> 00:17:23.000
이제 각 사용자에 대한 단일 요소가 있으며, 각 요소에는 Send Challenge 액션이 있습니다.

00:17:23.000 --> 00:17:28.000
ForEach에 표시되는 뷰의 접근성 요소를 결합하는 것이 이상적입니다.

00:17:28.000 --> 00:17:33.000
당신이 지금까지 배웠을 수도 있듯이, 결합은 매우 유용한 아동 행동입니다.

00:17:33.000 --> 00:17:39.000
아이들이 개별적으로 탐색할 수 있는 대신, 그것은 그들의 속성을 하나의 탐색 가능한 요소로 병합한다.

00:17:39.000 --> 00:17:46.000
단일 요소가 필요하지만 자식으로부터 속성을 상속하는 것을 원하지 않을 때, 무시 동작을 사용하세요.

00:17:46.000 --> 00:17:54.000
그리고 마지막으로, 포함 아동 행동은 아동을 접근성 컨테이너에 감싸고 관련된 견해 그룹을 표현하는 데 사용되어야 한다.

00:17:54.000 --> 00:17:59.000
이것은 기본 정렬 순서를 향상시킬 뿐만 아니라 보조 기술에 대한 다른 장점이 있다.

00:17:59.000 --> 00:18:03.000
새로운 접근성 미리보기를 통해 이러한 내비게이션 문제를 쉽게 발견할 수 있습니다.

00:18:03.000 --> 00:18:07.000
그리고 몇 가지 작은 변화로, 당신은 경험을 극적으로 향상시킬 수 있습니다.

00:18:07.000 --> 00:18:14.000
하지만 VoiceOver 사용자에게 진정으로 뛰어난 내비게이션 경험을 제공하기 위해, 당신은 로터를 고려하고 싶을 것입니다.

00:18:14.000 --> 00:18:19.000
이제 접근성이 처음이라면, "로터는 무엇입니까?"라고 생각할 수도 있습니다.

00:18:19.000 --> 00:18:22.000
간단히 말해서, 로터는 강력한 내비게이션 도구이다.

00:18:22.000 --> 00:18:27.000
그것들은 사용자가 그들 사이를 빠르게 탐색할 수 있는 책갈피로 생각할 수 있다.

00:18:27.000 --> 00:18:35.000
제목과 컨테이너 로터와 같은 시스템 로터는 이 과급 형태의 내비게이션의 기초를 제공한다.

00:18:35.000 --> 00:18:40.000
예를 들어, 사용자는 제목 로터를 사용하여 섹션을 빠르게 탐색할 수 있습니다.

00:18:40.000 --> 00:18:52.000
섹션 보기가 헤더 보기에 isHeader 특성을 자동으로 추가하기 때문입니다. 섹션 보기를 사용하지 않는 경우 accessibilityAddTraits(_:)를 사용하여 isHeader 특성을 보기에 추가할 수 있습니다.

00:18:52.000 --> 00:19:01.000
마찬가지로, 접근성 컨테이너는 컨테이너의 로터에 추가되며, 앞서 보았듯이 accessibilityElement(children:) 수정자로 생성됩니다.

00:19:01.000 --> 00:19:12.000
보시다시피, 제목 로터를 지원하는 것은 믿을 수 없을 정도로 쉽고, 컨테이너의 로터는 포함 아동 행동으로 접근성 요소를 그룹화하는 이점을 더합니다.

00:19:12.000 --> 00:19:19.000
이제 Wallet Pal의 기본 내비게이션 경험이 개선되었으므로, 로터로 한 걸음 더 나아갑시다.

00:19:19.000 --> 00:19:29.000
Wallet Pal에서 경고는 예산이 한도에 가깝거나 초과할 때 동기 부여 메시지와 경고를 제공하여 사용자의 지출 습관을 확인하는 데 도움이 됩니다.

00:19:29.000 --> 00:19:32.000
우리는 다양한 유형의 경고에 대해 SF 기호를 통합했습니다.

00:19:32.000 --> 00:19:36.000
이것들은 시각적 사용자가 목록을 빠르게 스캔할 수 있게 해준다.

00:19:36.000 --> 00:19:42.000
하지만 이 도상은 VoiceOver 사용자에게 도움이 되지 않을 것이다.

00:19:42.000 --> 00:19:47.000
그들은 대신 경고가 있는지 알기 위해 모든 경고를 탐색해야 할 것이다.

00:19:47.000 --> 00:19:58.000
시력이 있는 사용자가 가지고 있는 유사한 경험을 복제하려면, VoiceOver 사용자는 경고를 독점적으로 탐색할 수 있어야 하며, 그렇게 하면 즉시 다음 경고 경고로 이동할 수 있습니다.

00:19:58.000 --> 00:20:01.000
이것을 하기 위해, 우리는 로터를 사용할 수 있다.

00:20:01.000 --> 00:20:10.000
사용자 지정 로터의 더 많은 예와 효율성에 중요한 이유는 2020년부터 "사용자 지정 로터를 위한 보이스오버 효율성" 프레젠테이션을 확인하십시오.

00:20:10.000 --> 00:20:17.000
AlertsView에 경고 로터를 추가하려면, 가장 먼저 할 일은 접근성 컨테이너에 로터를 추가하는 것입니다.

00:20:17.000 --> 00:20:32.000
SwiftUI의 일부 보기는 기본적으로 List 또는 LazyVStack과 같은 접근성 컨테이너이지만 VStacks와 HStacks는 그렇지 않으므로 포함 자식 동작과 함께 accessibilityElement(children:) 수정자를 추가하겠습니다.

00:20:32.000 --> 00:20:39.000
다음으로, 나는 accessibilityRotor(_:entries:) 수정자로 로터를 만들어 "경고"라는 이름을 붙일 것이다.

00:20:39.000 --> 00:20:46.000
그리고 마지막으로, 나는 어떤 경고를 경고 로터에 포함시키고 싶은지 선언할 것이다. 이 경우 모든 경고 경고.

00:20:46.000 --> 00:20:47.000
그리고 그게 다야!

00:20:47.000 --> 00:20:52.000
앱의 내비게이션을 과급하는 것은 매우 쉽습니다.

00:20:52.000 --> 00:21:02.000
이러한 간단한 사용 사례에서 로터를 쉽게 만드는 것 중 하나는 SwiftUI가 ID를 기반으로 한 접근성 요소와 로터 항목을 자동으로 일치시킬 수 있다는 것입니다.

00:21:02.000 --> 00:21:08.000
이것은 우리의 로터 항목의 ID가 ForEach에 의해 AlertCellView에 주어진 ID와 일치하기 때문입니다.

00:21:08.000 --> 00:21:12.000
뷰의 정체성은 접근성 로터를 이해하는 데 중요하다.

00:21:12.000 --> 00:21:20.000
따라서 보기 신원이 불분명하거나 재교육을 원한다면, "Demystifying SwiftUI" 프레젠테이션을 확인하여 자세히 알아볼 것을 강력히 권장합니다.

00:21:20.000 --> 00:21:25.000
이제 너는 이렇게 생각할지도 몰라, "안아, 내 견해는 이렇게 간단하지 않아.

00:21:25.000 --> 00:21:28.000
ForEach 내에 있지 않은 견해는 어떤가요?"

00:21:28.000 --> 00:21:33.000
걱정하지 마세요, 접근성 로터 API는 간단한 보기에서 복잡한 보기로 확장할 수 있습니다.

00:21:33.000 --> 00:21:40.000
이 간단한 케이스는 AlertCellView를 위한 단일 접근성 요소가 있기 때문에 우아하게 작동합니다.

00:21:40.000 --> 00:21:45.000
그리고 AlertCellView는 경고의 ID로 식별됩니다.

00:21:45.000 --> 00:21:50.000
모든 경고에 대해 액션 뷰도 있다면 어떨까요?

00:21:50.000 --> 00:21:58.000
이 경우, VStack은 이제 ForEach의 루트 뷰이며, 경고의 신원을 받게 될 VStack입니다.

00:21:58.000 --> 00:22:06.000
따라서 경고 로터에 AlertCellView를 포함하려면 로터 항목으로 명시적으로 표시해야 합니다.

00:22:06.000 --> 00:22:09.000
우리는 accessibilityRotorEntry 수정자로 그것을 할 수 있다.

00:22:09.000 --> 00:22:20.000
이 수정자는 네임스페이스와 ID가 필요하며, 이는 AccessibilityRotorEntry를 만드는 데 사용된 ID와 네임스페이스와 일치하는 한 무엇이든 될 수 있습니다.

00:22:20.000 --> 00:22:25.000
그리고 마지막으로, 우리는 각 로터 항목에 이 네임스페이스를 포함해야 할 것이다.

00:22:25.000 --> 00:22:39.000
명시적인 네임스페이스를 참조할 수 있는 기능은 접근성 로터 API가 간단한 사용 사례에서 복잡한 사용 사례로 확장될 수 있게 하여 여러 뷰에 걸쳐 있는 접근성 요소를 동일한 로터에 포함할 수 있도록 합니다.

00:22:39.000 --> 00:22:43.000
텍스트 탐색을 풍부하게 하기 위해 접근성 로터를 추가할 수도 있습니다.

00:22:43.000 --> 00:22:51.000
그렇게 하려면, 텍스트 범위의 배열을 제공할 수 있는 접근성 로터 수정자의 다른 변형을 사용하세요.

00:22:51.000 --> 00:23:01.000
이 수정자는 VoiceOver 사용자가 이메일, 링크 또는 전화번호와 같은 텍스트 편집기 내의 특정 문자열에 빠르고 쉽게 액세스할 수 있도록 하는 데 적합합니다.

00:23:01.000 --> 00:23:05.000
접근성 로터는 VoiceOver 사용자에게 복잡한 탐색을 쉽게 해준다.

00:23:05.000 --> 00:23:12.000
그리고 새로운 SwiftUI 로터 API를 사용하면, 이 뛰어난 내비게이션 경험을 제공하는 것이 그 어느 때보다 쉬워졌습니다.

00:23:12.000 --> 00:23:15.000
오늘의 마지막 주제는 초점이다.

00:23:15.000 --> 00:23:24.000
초점 요소의 개념은 당신이 이미 익숙할 수 있는 것이지만, 당신이 모를 수도 있는 것은 우리의 많은 보조 기술이 그들만의 초점 상태를 가지고 있다는 것입니다.

00:23:24.000 --> 00:23:27.000
이것이 우리가 "접근성 초점"이라고 부르는 것이다.

00:23:27.000 --> 00:23:33.000
그것은 내가 탐색하는 보조 기술을 언급할 때 당신이 변화를 보고 있는 집중된 관점입니다.

00:23:33.000 --> 00:23:37.000
보조 기술의 커서 위치는 사용자 경험에 매우 중요하다.

00:23:37.000 --> 00:23:46.000
VoiceOver에서 초점이 변경되면, 커서는 요소에 대한 설명을 말하는 것 외에도 초점을 맞춘 요소의 경로와 일치하도록 이동합니다.

00:23:46.000 --> 00:23:48.000
그래서 초점은 언제 바뀌나요?

00:23:48.000 --> 00:23:53.000
세 가지 사건 중 하나가 발생할 때 초점이 항상 바뀔 수는 있지만 항상 바뀔 수는 없다.

00:23:53.000 --> 00:24:00.000
첫 번째이자 가장 일반적인 사용 사례는 사용자가 다른 접근성 요소로 이동할 때 초점 변화를 주도할 때입니다.

00:24:00.000 --> 00:24:08.000
두 번째 경우는 UI가 변경되고, 이전에 초점을 맞춘 보기가 더 이상 화면에 없거나 모달 보기로 덮여 있을 때이다.

00:24:08.000 --> 00:24:13.000
이런 일이 발생하면, 초점은 종종 첫 번째 정렬된 접근성 요소로 재설정됩니다.

00:24:13.000 --> 00:24:19.000
이것은 새로 제시된 보기의 첫 번째 접근성 요소로 이동하는 것과 같은 많은 사용 사례를 자동으로 다룹니다.

00:24:19.000 --> 00:24:26.000
하지만 그것은 당신의 앱에서 가장 좋은 행동이 아닐 수도 있기 때문에 프로그래밍 요청에 따라 초점을 변경할 수도 있습니다.

00:24:26.000 --> 00:24:33.000
그러나, VoiceOver 사용자의 초점을 옮기는 것은 매우 파괴적일 수 있기 때문에, 이것은 신중하게 처리되어야 한다.

00:24:33.000 --> 00:24:38.000
그 메모에서, 마지막 사건에 집중합시다.

00:24:38.000 --> 00:24:48.000
올해 우리는 보조 기술이 현재 초점을 맞추고 있는 곳을 읽는 것 외에도 초점을 옮기기 위해 보조 기술을 요청할 수 있는 새로운 API를 가지고 있습니다.

00:24:48.000 --> 00:24:56.000
여기서 우리는 알림을 추적하는 간단한 보기를 가지고 있으며, 그것이 존재한다면, 사용자 지정 NotificationBanner를 오버레이합니다.

00:24:56.000 --> 00:25:02.000
우리는 Wallet Pal에서 이 보기를 사용하여 앱이 전경에 있는 동안 수신된 푸시 알림에 대한 알림을 표시하고 싶습니다.

00:25:02.000 --> 00:25:08.000
NotificationBanner가 추가되면, 보조 기술은 자동으로 그것에 초점을 맞추지 않을 것이다.

00:25:08.000 --> 00:25:13.000
하지만 우리는 그들이 새로운 AccessibilityFocusState로 그렇게 하도록 요청할 수 있습니다.

00:25:13.000 --> 00:25:23.000
AccessibilityFocusState는 보조 기술에 초점을 맞추고 프로그래밍 방식의 초점 변경을 요청하는 방법을 모두 제공하는 속성 래퍼입니다.

00:25:23.000 --> 00:25:30.000
내 보기에 하나를 추가하고 accessibilityFocused(_:) 수정자로 NotificationBanner에 바인딩할 것입니다.

00:25:30.000 --> 00:25:35.000
다음으로, 나는 새로운 알림을 받을 때 추적하기 위해 onChange(of:perform:) 수정자를 사용할 것이다.

00:25:35.000 --> 00:25:42.000
우선 순위가 높은 알림을 받았을 때만 우리는 접근성 초점을 변경할 것을 요청합니다.

00:25:42.000 --> 00:25:50.000
사용자 상호 작용이 발생하지 않으면 프로그래밍 방식으로 초점을 이동하는 것이 매우 파괴적일 수 있다는 점에 유의하는 것이 특히 중요합니다.

00:25:50.000 --> 00:25:55.000
그것은 사용자가 현재 집중하고 있는 어떤 맥락에서든 벗어나게 되므로, 주의해서 다루어야 한다.

00:25:55.000 --> 00:26:01.000
그래서 우선 순위가 낮은 알림을 위해, 나는 VoiceOver가 발표할 수 있도록 접근성 알림을 게시할 것이다.

00:26:01.000 --> 00:26:08.000
이렇게 하면, VoiceOver 사용자는 여전히 새로운 알림이 나타났다는 것을 알고 있으며 원하는 경우 탐색할 수 있습니다.

00:26:08.000 --> 00:26:11.000
이제 NotificationBanner 보기 안으로 들어가 봅시다.

00:26:11.000 --> 00:26:15.000
알림이 나타나면, 타이머가 시작됩니다.

00:26:15.000 --> 00:26:19.000
완료되면, 알림은 nil로 설정됩니다.

00:26:19.000 --> 00:26:24.000
그 전에 알림이 0일 때, NotificationBanner는 숨겨질 것이다.

00:26:24.000 --> 00:26:37.000
즉, VoiceOver 사용자가 알림 배너에 집중하고 타이머가 만료되면 보기가 제거되기 때문에 초점이 재설정됩니다. 이것은 훌륭한 사용자 경험이 아닙니다.

00:26:37.000 --> 00:26:45.000
이것을 해결하기 위해, 우리의 NotificationBanner가 보조 기술에 초점을 맞추고 있는지, 만약 그렇다면, 알림 해고를 연기하는지 봅시다.

00:26:45.000 --> 00:26:47.000
이게 이상적인 해결책이야.

00:26:47.000 --> 00:26:53.000
초점을 맞추는 동안 보기가 더 이상 제거되지 않기 때문에 VoiceOver 사용자의 초점은 더 이상 재설정되지 않습니다.

00:26:53.000 --> 00:27:08.000
또한, 우리는 보조 기술 사용자에게 콘텐츠를 소화하고 원하는 경우 상호 작용할 수 있는 무제한의 시간을 제공했습니다. 보조 기술 사용자가 그렇게 하는 데 훨씬 더 오래 걸릴 수 있는 두 가지.

00:27:08.000 --> 00:27:15.000
AccessibilityFocusState는 올해와 그 이후에 탁월하고 접근 가능한 SwiftUI 앱을 제공하는 데 필요한 마지막 작품입니다.

00:27:15.000 --> 00:27:21.000
그것으로, 당신은 보기 간의 원활한 전환을 만들기 위해 보조 기술의 초점을 읽고 지시할 수 있습니다.

00:27:21.000 --> 00:27:25.000
와우, 우리는 오늘 SwiftUI 접근성을 위해 많은 것을 다루었습니다.

00:27:25.000 --> 00:27:43.000
우리는 SwiftUI 접근성을 개발하고 디버깅할 수 있는 방법을 향상시키는 새로운 접근성 미리보기를 소개받았습니다. 사용자 지정 컨트롤과 복잡한 그래프에 액세스할 수 있도록 하는 방법을 다루었습니다. 그리고 그룹화, 로터 및 포커스로 탐색 경험을 어떻게 개선할 수 있는지 배우는 데 시간이 걸렸습니다.

00:27:43.000 --> 00:27:48.000
모든 것을 합치면, 그것은 정말로 올해 접근성을 위한 큰 도약이었다.

00:27:48.000 --> 00:27:55.000
접근성 API의 간단하고 복잡한 예를 보려면, 접근성 카탈로그 샘플 프로젝트를 확인하세요.

00:27:55.000 --> 00:28:00.000
그것은 우리가 오늘 다룰 수 없었던 더 많은 예시와 우리가 권장하는 모범 사례를 특징으로 한다.

00:28:00.000 --> 00:28:01.000
나와 함께 해줘서 정말 고마워.

00:28:01.000 --> 00:28:05.000
우리는 당신이 어떻게 모든 사람이 당신의 앱에 접근할 수 있는지 보기를 기대합니다.

00:28:05.000 --> 23:59:59.000
♪

