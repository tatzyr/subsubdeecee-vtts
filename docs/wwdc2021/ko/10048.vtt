WEBVTT

00:00:00.000 --> 00:00:09.000
♪ ♪

00:00:09.000 --> 00:00:14.000
안녕하세요, 제 이름은 브렛 카토이고, 저는 시스템 경험 팀의 엔지니어입니다.

00:00:14.000 --> 00:00:23.000
오늘 우리는 훌륭한 위젯의 원리에 대해 이야기할 것이며, 가능한 최고의 위젯을 만드는 데 도움이 되는 몇 가지 뜨거운 주제에 대해 이야기할 것입니다.

00:00:23.000 --> 00:00:26.000
iOS 14에서, 우리는 위젯킷을 도입했다.

00:00:26.000 --> 00:00:37.000
WidgetKit을 사용하면 iOS, iPadOS 및 macOS의 사용자의 홈 화면에서 바로 아름답고 역동적인 멀티플랫폼 위젯을 만들 수 있습니다.

00:00:37.000 --> 00:00:50.000
이제, 시작하기 전에, WWDC 2020의 회담을 놓쳤다면, WidgetKit 프레임워크와 핵심 개념에 대한 소개를 제공하는 "Meet WidgetKit"과 같은 정말 훌륭한 회담이 있습니다.

00:00:50.000 --> 00:00:57.000
"Widgets code-along"은 기본에서 고급까지 복잡성이 증가하는 위젯을 만드는 세 부분으로 구성된 시리즈입니다.

00:00:57.000 --> 00:01:04.000
"위젯을 위한 SwiftUI 뷰 구축"은 SwiftUI를 최대한 활용하여 위젯에 적응 가능한 뷰를 구축하는 방법을 자세히 설명합니다.

00:01:04.000 --> 00:01:13.000
마지막으로, "디자인 훌륭한 위젯"은 많은 예와 함께 휴먼 인터페이스 그룹의 디자인 고려 사항을 탐구합니다.

00:01:13.000 --> 00:01:22.000
오늘 우리는 훌륭한 위젯을 위한 두 가지 주제를 다룰 것입니다: 관련성을 유지하고 위젯 사용자 지정을 활성화하는 것입니다.

00:01:22.000 --> 00:01:25.000
그러니 관련성을 가지고 시작합시다.

00:01:25.000 --> 00:01:33.000
위젯이 최신 상태이고 환경에 적응할 수 있는지 확인하기 위해 깊이 논의할 세 가지 유형의 관련성이 있습니다.

00:01:33.000 --> 00:01:39.000
우리는 시간, 프레젠테이션 및 위치 관련성에 대해 이야기할 것이다.

00:01:39.000 --> 00:01:41.000
위젯킷의 중심에는 타임라인이 있다.

00:01:41.000 --> 00:01:45.000
이것은 하루 종일 관련성을 유지하기 위한 위젯의 핵심 메커니즘이다.

00:01:45.000 --> 00:01:49.000
타임라인은 하나 이상의 타임라인 항목으로 구성되어 있다.

00:01:49.000 --> 00:01:56.000
이 예에서, 당신은 세 개의 항목을 볼 수 있습니다, 하나는 오전 9시, 오전 9시, 오전 10시입니다.

00:01:56.000 --> 00:02:06.000
이제, 시스템이 위젯에 타임라인을 요청하면, 결과 타임라인이 보관되고 미래에 지정한 특정 시간에 항목이 렌더링됩니다.

00:02:06.000 --> 00:02:12.000
이를 통해 시스템은 사용자가 필요할 때 바로 표시되도록 즉시 사용자 인터페이스를 준비할 수 있습니다.

00:02:12.000 --> 00:02:20.000
가장 단순한 것부터 시작하여 타임라인의 몇 가지 예를 살펴보고, 그 안에 있을 수 있는 콘텐츠의 유형을 살펴봅시다.

00:02:20.000 --> 00:02:26.000
다음은 단 하나의 항목으로 가장 간단한 타임라인의 예입니다: 스크린 타임.

00:02:26.000 --> 00:02:40.000
이제, 스크린 타임은 미래의 데이터를 예측하거나 예측할 수 없고 사용자의 장치가 어떻게 사용되었는지에 대한 통계 기록을 엄격하게 기반으로 하기 때문에, 타임라인에서 여러 항목을 잘 활용할 수 없기 때문에, 하나의 항목만 사용합니다.

00:02:40.000 --> 00:02:43.000
이것은 당신이 가질 수 있는 가장 단순한 타임라인입니다.

00:02:43.000 --> 00:02:53.000
그렇긴 하지만, 모든 위젯이 단일 항목일 필요는 없으며, 사실, 대부분의 경우 타임라인에서 여러 항목을 제공하지 않는 이유를 고려하고 질문하는 것이 좋습니다.

00:02:53.000 --> 00:03:05.000
미래 지향적인 콘텐츠가 있거나, 중요한 날짜나 마감일이 있거나, 미래에 콘텐츠를 예측할 수 있다면, 위젯은 실제로 타임라인의 여러 항목을 활용해야 합니다.

00:03:05.000 --> 00:03:07.000
여기 날씨의 또 다른 예가 있습니다.

00:03:07.000 --> 00:03:13.000
보시다시피, 날씨의 타임라인은 하루 종일 마지막 시간까지 여러 항목을 제공합니다.

00:03:13.000 --> 00:03:23.000
이제, 여기의 첫 번째 항목은 현재 날씨를 나타내기 때문에 가장 정확하며, 다른 모든 후속 항목은 나중에 예측 데이터를 나타냅니다.

00:03:23.000 --> 00:03:30.000
이 추가 예측 데이터는 위젯 재장전이 지정한 정확한 시간에 다시 로드되는 것이 보장되지 않기 때문에 매우 유용합니다.

00:03:30.000 --> 00:03:42.000
그리고 재장전이 원하는 시점에 정확히 목표 날짜에 도달하지 않으면, 이제 시스템은 사용자 경험을 극복하기 위해 추가 예측 콘텐츠를 가지고 있습니다.

00:03:42.000 --> 00:03:44.000
여기 사진의 예가 있습니다.

00:03:44.000 --> 00:03:51.000
사진 타임라인은 하루 중 특정 시간에 나타날 수 있는 많은 개인 및 관련 사진을 제공한다는 것을 알 수 있습니다.

00:03:51.000 --> 00:03:55.000
나에게, 이것들은 정말, 정말 좋은 추억이다.

00:03:55.000 --> 00:04:05.000
그리고 이제, 위젯은 하루에 몇 번만 다시 로드되지만, 이러한 여러 타임라인 항목에서 새롭고 신선한 콘텐츠를 제시함으로써 내내 활기찬 느낌을 준다.

00:04:05.000 --> 00:04:22.000
여기에서 볼 수 있듯이, 사진의 이 예에서와 같이 날씨와 같이 예측할 수 있는 데이터가 없더라도, 타임라인에서 이러한 여러 항목을 활용하여 놀라움과 즐거움을 줄 수 있는 방식으로 사용자와 관련된 콘텐츠를 통합할 수 있습니다.

00:04:22.000 --> 00:04:27.000
이제, 일부 위젯은 다른 위젯보다 더 많이 보기 때문에, 우리는 위젯에 업데이트에 대한 공정성 요소를 제공하기로 결정했습니다.

00:04:27.000 --> 00:04:30.000
우리는 이것을 업데이트 예산이라고 부른다.

00:04:30.000 --> 00:04:37.000
예산은 하루 종일 할당되고 축적되며, 사용자 시청 습관에 크게 영향을 받는다.

00:04:37.000 --> 00:04:52.000
자주 보는 위젯은 하루에 약 40~70개의 배경 업데이트를 받을 것으로 예상할 수 있으며, 이는 사용자가 깨어 있는 정상적인 시간 동안 균등하게 간격을 둔 경우 대략 15분에서 30분마다 업데이트로 변환됩니다.

00:04:52.000 --> 00:05:01.000
그러나, 물론 모든 재장전이 이렇게 균등하게 간격을 둔 것은 아니며, 우리의 목표는 다양한 요구 사항에 대한 다양한 업데이트 케이던스를 활성화하고 지원하는 것이었습니다.

00:05:01.000 --> 00:05:14.000
예를 들어, 좋아하는 팀을 위한 다가오는 경기까지 대부분 유휴 상태인 스포츠 위젯이 있을 수 있으며, 경기 전, 도중, 심지어 경기 후에도 점수 업데이트를 받을 수 있습니다.

00:05:14.000 --> 00:05:21.000
WidgetKit은 스마트하며, 사용자가 자고 있을 때와 같이 오랜 시간 동안 장치를 사용하지 않을 때 업데이트를 보류할 수 있습니다.

00:05:21.000 --> 00:05:27.000
그렇지 않으면, 위젯 업데이트는 특정 위젯에 대한 예산을 사용할 수 있을 때까지 보류될 수 있습니다.

00:05:27.000 --> 00:05:31.000
하지만, 재장전이 매초마다 작동하는 것은 아니다.

00:05:31.000 --> 00:05:36.000
위젯은 홈 화면에서 라이브 러닝 경험을 만드는 것이 아니다.

00:05:36.000 --> 00:05:41.000
이제, 당신의 위젯이 하루 종일 새로 고쳐질 수 있는 다양한 방법이 있습니다.

00:05:41.000 --> 00:05:50.000
그리고 우리는 그것들이 무엇인지, 어떻게 작동하는지, 그리고 우리가 방금 소개한 예산과 관련하여 어떻게 작동하는지 이해하기 위해 이것들 각각을 간략하게 살펴볼 것입니다.

00:05:50.000 --> 00:05:54.000
첫 번째는 WidgetKit의 API인 TimelineReloadPolicy입니다.

00:05:54.000 --> 00:05:59.000
이것은 재장전이 자동으로 발생하는 핵심 메커니즘입니다.

00:05:59.000 --> 00:06:04.000
타임라인을 제공할 때, 당신은 또한 그것과 함께 재장전 정책을 제공합니다.

00:06:04.000 --> 00:06:10.000
이 재장전 정책은 백그라운드에서 위젯을 자동으로 새로 고치고 싶을 때 시스템에 알려줍니다.

00:06:10.000 --> 00:06:17.000
이러한 자동 업데이트는 예산이 책정되고 위젯의 현재 사용 가능한 예산에서 인출됩니다.

00:06:17.000 --> 00:06:20.000
다음은 위젯센터 리로드 API입니다.

00:06:20.000 --> 00:06:26.000
이것은 위젯의 기존 데이터를 무효화하는 이벤트가 발생할 때 위젯을 새로 고치는 API입니다.

00:06:26.000 --> 00:06:34.000
이제, 일반적으로, 이 API를 사용하는 요청은 사용 가능한 예산을 소비할 것이며, 이는 예산을 사용할 수 있을 때까지 업데이트가 발생하지 않는다는 것을 의미합니다.

00:06:34.000 --> 00:06:42.000
그러나, 이러한 재장전이 즉각적이고 예산 없이 발생할 수 있는 몇 가지 상황적 예외가 있다.

00:06:42.000 --> 00:06:52.000
이는 컨테이너 앱이 사용자에게 포그라운드이거나 앱이 내비게이션 또는 오디오 재생 중과 같은 사용자 세션에 참여할 때입니다.

00:06:52.000 --> 00:06:59.000
이 API는 TimelineReloadPolicy API의 자동 백그라운드 업데이트를 보완합니다.

00:06:59.000 --> 00:07:03.000
위젯은 또한 중요한 위치 변경이 발생했을 때 업데이트할 수 있습니다.

00:07:03.000 --> 00:07:10.000
시스템이 중요한 위치 변경을 감지하고 위젯이 위치를 사용하면, 시스템은 예산 없는 업데이트를 제공합니다.

00:07:10.000 --> 00:07:17.000
이 새로 고침은 사용자가 다음에 위젯을 볼 때 발생하여 위치를 적절하게 해결할 수 있습니다.

00:07:17.000 --> 00:07:24.000
이제, 이것이 위치 변경이 발생할 때 바로 일어날 것이라고 보장되는 것이 아니라, 다음 번에 사용자가 위젯을 볼 때 발생한다는 점에 유의하십시오.

00:07:24.000 --> 00:07:27.000
우리는 나중에 위치에 대해 조금 더 이야기할 것이다.

00:07:27.000 --> 00:07:31.000
프레젠테이션 환경이 변경되면 시스템도 위젯을 새로 고칠 수 있습니다.

00:07:31.000 --> 00:07:44.000
예를 들어, 사용자가 동적 텍스트나 굵은 텍스트와 같은 접근성 기본 설정을 변경하거나, 언어 또는 지역 변경, iCloud 또는 App Store 계정 변경, 상당한 시간 변경 등이 있을 수 있습니다.

00:07:44.000 --> 00:07:53.000
마지막으로, 예산 책정으로 인해, 사용자가 거의 볼 수 없는 위젯을 가지고 있다면, 개발자가 선호하는 만큼 많은 업데이트를 받지 못할 수도 있습니다.

00:07:53.000 --> 00:08:00.000
시스템은 타임라인의 날짜, 선호하는 새로 고침 시간 및 사용자의 일반적인 보기 기록을 알고 있습니다.

00:08:00.000 --> 00:08:05.000
시스템은 사용자가 볼 때 데이터가 오래될 수 있다고 생각되면 예산 없는 재장전을 허용할 수 있다.

00:08:05.000 --> 00:08:10.000
물론, 이 모든 시스템 시작 업데이트는 항상 예산이 없다.

00:08:10.000 --> 00:08:18.000
우리가 조금 전에 배웠듯이, 각 타임라인은 백그라운드에서 자동으로 업데이트해야 하는 시기를 설명하는 다시 로드 정책과 짝을 이룬다.

00:08:18.000 --> 00:08:24.000
WidgetKit은 여기에 세 가지 선택을 제공합니다: atEnd, afterDate, 그리고 Never.

00:08:24.000 --> 00:08:28.000
이 세 가지 재장전 정책 중 어느 것이 당신의 위젯에 적합합니까?

00:08:28.000 --> 00:08:37.000
문맥에 대한 몇 가지 예와 함께 각각에 대해 이야기하기 위해 뛰어들고, 각각에 대해 무엇을 염두에 두어야 하는지에 대해 이야기할 것입니다.

00:08:37.000 --> 00:08:41.000
우리가 논의할 첫 번째 정책은 atEnd 재장전 정책이다.

00:08:41.000 --> 00:08:49.000
이 정책은 타임라인이 끝날 때, 즉 마지막 항목이 관련성이 있을 때 위젯을 새로 고칠 수 있는 자격을 표시할 것입니다.

00:08:49.000 --> 00:08:53.000
이 경우, 오전 10시 30분입니다.

00:08:53.000 --> 00:09:03.000
또한, 이 시간은 단순히 위젯이 새로 고칠 수 있는 시간이며, 이 시간에 정확히 새로 고칠 것이라고 보장하지는 않습니다.

00:09:03.000 --> 00:09:14.000
또한, 이전에 이야기한 스크린 타임 예제와 같이 단일 항목 타임라인이 있는 위젯과 함께 atEnd를 사용하는 경우, 시스템은 위젯에 적합한 시간을 선택할 것입니다.

00:09:14.000 --> 00:09:21.000
위젯에 이미 현재 타임라인의 수명을 넘어서는 콘텐츠가 있는 경우 atEnd가 권장됩니다.

00:09:21.000 --> 00:09:24.000
나는 네 콘텐츠에 창문을 보는 것처럼 그것에 대해 생각하고 싶어.

00:09:24.000 --> 00:09:27.000
예를 들어 봅시다.

00:09:27.000 --> 00:09:31.000
여기에 요약된 것은 6월 7일 달력 위젯의 현재 타임라인입니다.

00:09:31.000 --> 00:09:33.000
네 개의 항목이 있다.

00:09:33.000 --> 00:09:38.000
나는 창문을 선보이기 위해 과거와 미래의 콘텐츠를 포함시켰다.

00:09:38.000 --> 00:09:46.000
그리고 우리가 6월 8일의 타임라인을 변경함에 따라, 당신은 그 내용에 대한 창을 보는 것이 무엇을 의미하는지 알 수 있습니다.

00:09:46.000 --> 00:09:48.000
그리고 다시 6월 9일 타임라인을 위해.

00:09:48.000 --> 00:09:53.000
우리는 이미 이용 가능하고 사용자가 제공한 데이터에 대한 관점을 바꾸고 있습니다.

00:09:53.000 --> 00:10:00.000
이러한 유형의 콘텐츠는 실제로 atEnd 정책을 사용하는 것이 빛나는 곳이다.

00:10:00.000 --> 00:10:07.000
이제 atEnd 정책을 사용하는 위젯의 몇 가지 예로는 미리 알림, 캘린더, 사진, 팁 등이 있습니다.

00:10:07.000 --> 00:10:14.000
다시 말하지만, 이것들은 단순히 창을 볼 수 있는 미래에 잘 알려진 끝없는 콘텐츠가 있는 모든 위젯입니다.

00:10:14.000 --> 00:10:23.000
시스템이 당신을 위해 재장전 시간을 선택할 것이기 때문에 단일 항목 타임라인에 적합하지 않으며, 아마도 당신이 원하는 것이 아닐 것입니다.

00:10:23.000 --> 00:10:30.000
타임라인이 시간이 지남에 따라 관련성이나 정확성을 잃는 콘텐츠를 투사한 경우 AtEnd는 권장되지 않습니다.

00:10:30.000 --> 00:10:43.000
우리는 단순히 당신의 콘텐츠가 가장 관련성이 있기를 원하며, 업데이트할 수 있는 가장 관련성이 없을 때 타임라인이 끝날 때까지 기다린다면, 그것은 최고의 사용자 경험으로 이어지지 않습니다.

00:10:43.000 --> 00:10:47.000
그래서 그게 끝이야. 이제, AfterDate에 대해 이야기해 봅시다.

00:10:47.000 --> 00:10:53.000
afterDate 다시 로드 정책을 사용하면 지정된 날짜 이후에 위젯을 다시 로드할 수 있습니다.

00:10:53.000 --> 00:10:58.000
afterDate와 함께, 당신은 자격 시간을 완전히 통제할 수 있습니다.

00:10:58.000 --> 00:11:04.000
이 예에서, 타임라인이 오전 9시부터 대략 오전 11시까지 유효한 척 합시다.

00:11:04.000 --> 00:11:12.000
위젯의 예측 데이터가 9시 45분경에 정확성을 잃기 시작하기 때문에 오전 9시 30분 위젯 재장전 정책 날짜가 선택되었다.

00:11:12.000 --> 00:11:21.000
이것은 9시 30분에 즉시 재장전되지 않더라도 9시 30분 이후에도 여전히 예측 데이터를 보여줄 수 있는 많은 활주로를 위젯에 제공한다.

00:11:21.000 --> 00:11:33.000
afterDate는 하루 종일 예측할 수 없거나 예기치 않게 변경될 수 있는 콘텐츠와 정확성이나 관련성이 주기적으로 변경되는 데이터에 가장 적합합니다.

00:11:33.000 --> 00:11:40.000
afterDate를 사용하는 위젯의 예로는 주식, 날씨, 뉴스, 메일 등이 있습니다.

00:11:40.000 --> 00:11:47.000
이것들은 하루 종일 예측할 수 없거나 예기치 않게 변경될 수 있는 콘텐츠가 있는 모든 위젯입니다.

00:11:47.000 --> 00:11:52.000
이제, AfterDate와 함께, 당신은 몇 가지 잠재적인 문제에 대해 정말로 조심해야 합니다.

00:11:52.000 --> 00:11:55.000
거의 즉각적인 재장전을 조심하세요.

00:11:55.000 --> 00:12:01.000
1분 정도 떨어진 날짜를 지정하는 것은 유효할 수 있지만 일반적으로 매우 좁은 시간대에만 유효합니다.

00:12:01.000 --> 00:12:08.000
이 해상도 수준에서 너무 많은 새로 고침을 요청하면 나중에 다시 로드할 수 있습니다.

00:12:08.000 --> 00:12:12.000
또한 장치 간에 위젯 새로 고침 날짜를 정렬하는 경우 주의하십시오.

00:12:12.000 --> 00:12:25.000
예를 들어, 미국 주식 시장은 동부 해안에서 오전 9시 30분에 열리고 서버에서 당일 초기 데이터를 가져오기 위해 정확히 오전 9시 30분에 새로 고침을 예약합니다.

00:12:25.000 --> 00:12:33.000
기억하세요, 당신의 위젯은 수천 또는 수백만 개의 장치에 있을 수 있으며, 잠재적으로 각 장치에서도 여러 번 있을 수 있습니다.

00:12:33.000 --> 00:12:44.000
그리고 이와 같은 시간 정렬 데이터 풀이 있어야 한다면, 캐싱 서버를 누르는 것 외에도 이러한 날짜에 일정 수준의 무작위 지터를 추가하는 것을 고려해야 합니다.

00:12:44.000 --> 00:12:51.000
이것들은 잠재적으로 계획되지 않거나 불필요한 비용을 피하기 위해 고려하는 것이 특히 중요하다.

00:12:51.000 --> 00:12:56.000
마지막으로, 내가 가장 좋아하는 재장전 정책에 대해 이야기해 봅시다.

00:12:56.000 --> 00:13:01.000
절대 다시 로드하지 않는 정책은 자동으로 다시 로드되지 않기 때문에 가장 간단한 정책이다.

00:13:01.000 --> 00:13:13.000
위젯의 콘텐츠가 포그라운드인 컨테이너 애플리케이션이나 푸시 알림과 같은 개별 이벤트를 통해서만 변경할 수 있다면, 위젯을 위한 좋은 선택이 될 수 없습니다.

00:13:13.000 --> 00:13:23.000
절대 정책을 사용할 때, 위젯Center가 컨테이너 또는 기타 액세서리 확장에서 API를 다시 로드하는 경우에만 위젯을 최신 상태로 유지할 수 있습니다.

00:13:23.000 --> 00:13:32.000
이것은 필요할 때만 발생하는 재장전을 최소화하고 예산과 사용자의 배터리 수명에 미치는 영향을 최소화합니다.

00:13:32.000 --> 00:13:38.000
위젯이 아직 만족되지 않은 앱에서 명시적인 사용자 조건을 요구하는 경우에도 적절하지 않습니다.

00:13:38.000 --> 00:13:43.000
예를 들어, 서비스에 로그인하거나 특정 콘텐츠를 구매할 수도 있습니다.

00:13:43.000 --> 00:13:49.000
앱에서 이러한 유형의 조건이 충족되기 전에 위젯이 의미 있는 콘텐츠를 생성할 수 없다면 절대 고려하지 마세요.

00:13:49.000 --> 00:13:57.000
절대 정책을 사용하는 위젯의 좋은 예로는 TV, 노트, 음악, 팟캐스트, 연락처 등이 있습니다.

00:13:57.000 --> 00:14:06.000
이것들은 콘텐츠 변경을 유도하기 위해 앱에서 사용자 상호 작용이 필요하거나 콘텐츠 업데이트에 대한 푸시를 받는 모든 위젯과 앱입니다.

00:14:06.000 --> 00:14:10.000
요약하자면, 타임라인 항목을 유리하게 활용하세요.

00:14:10.000 --> 00:14:20.000
위젯에 대한 올바른 다시 로드 정책을 선택하고, WidgetCenter의 다시 로드 API를 사용하여 개별 이벤트에서 타임라인 이벤트를 다시 로드하십시오.

00:14:20.000 --> 00:14:24.000
좋아, 프레젠테이션 관련성으로 넘어가자.

00:14:24.000 --> 00:14:31.000
위젯은 iOS 또는 macOS의 특정 컨텍스트에서 표시될 수 있으므로 위젯의 모양이 바뀔 수 있습니다.

00:14:31.000 --> 00:14:36.000
위젯은 때때로 타임라인 업데이트 없이 다시 렌더링될 수 있습니다.

00:14:36.000 --> 00:14:40.000
그리고 훌륭한 위젯은 항상 이러한 프레젠테이션 환경에 적절하게 적응할 것이다.

00:14:40.000 --> 00:14:50.000
그래서 우리는 색 구성표, 다크 및 라이트 모드, iOS 15의 새로운 부분 개인 정보 보호 편집, 그리고 완전한 개인 정보 보호 편집에 대해 이야기할 것입니다.

00:14:50.000 --> 00:14:56.000
WidgetKit은 시스템 설정이 변경됨에 따라 라이트 모드와 다크 모드 간에 콘텐츠를 이동하는 것을 자동으로 처리합니다.

00:14:56.000 --> 00:15:00.000
이것은 우리가 SwiftUI의 힘을 사용하기 때문이다.

00:15:00.000 --> 00:15:04.000
이제 위젯이 각각의 맥락에서 어떻게 보이길 원하는지 생각해 보세요.

00:15:04.000 --> 00:15:11.000
여기서 당신은 밝고 어두운 계획 모두에서 노트와 달력의 예를 볼 수 있습니다.

00:15:11.000 --> 00:15:17.000
하지만, 모든 위젯이 반드시 배경과 텍스트 색상을 변경하여 라이트와 다크 모드를 준수해야 하는 것은 아니라는 것을 기억하세요.

00:15:17.000 --> 00:15:22.000
예를 들어, 음악과 주식과 같이 색상을 바꾸지 않는 몇 가지 위젯이 있습니다.

00:15:22.000 --> 00:15:33.000
애플리케이션 디자인이 어둡고 밝은 스타일의 고대비 콘텐츠에 구애받지 않는다면, 위젯에 맞는 색 구성표를 자유롭게 계속할 수 있습니다.

00:15:33.000 --> 00:15:38.000
Xcode 미리보기를 통해 Xcode에서 위젯의 색 구성표 변경 사항을 미리 볼 수도 있습니다.

00:15:38.000 --> 00:15:44.000
다음은 라이트 모드에서 systemSmall 위젯을 미리 보는 빠른 예입니다.

00:15:44.000 --> 00:15:46.000
그리고 이제 다크 모드에 있어.

00:15:46.000 --> 00:15:52.000
우리가 해야 할 일은 이 환경에서 위젯이 어떻게 보일지 미리 보기 위해 colorScheme 환경 재정의를 추가하는 것뿐입니다.

00:15:52.000 --> 00:16:02.000
그리고 여기에 표시된 것처럼 라이트 및 다크 모드의 시스템 표준 배경색을 원한다면, 채우기 위해 BackgroundStyle을 사용하세요.

00:16:02.000 --> 00:16:08.000
위젯은 또한 iOS의 잠금 화면과 같이 개인 정보 보호에 민감할 수 있는 프레젠테이션 환경의 적용을 받습니다.

00:16:08.000 --> 00:16:14.000
iOS 15의 새로운 기능, 위젯은 이제 이러한 상황에서 부분 콘텐츠를 편집할 수 있습니다.

00:16:14.000 --> 00:16:20.000
자, 그건 정말 혼란스럽게 들릴 수 있으니, 내가 여기서 무슨 말을 하고 있는지 예를 들어 보자.

00:16:20.000 --> 00:16:25.000
특정 계좌에서 사용 가능한 잔액을 보여주는 은행 위젯이 있는 척 합시다.

00:16:25.000 --> 00:16:31.000
이 경우, 제 계좌에 128.45달러가 있습니다.

00:16:31.000 --> 00:16:44.000
이제, 우리가 잠금 화면으로 가서 장치를 잠글 때, WidgetKit은 장치가 잠겼을 때 잔액 정보를 동적으로 편집할 방법이 없었기 때문에 이 계정 잔액은 여전히 iOS 14에 나타납니다.

00:16:44.000 --> 00:16:52.000
그러나, 그것은 이제 iOS 15에서 변경되었으며, 이제 이러한 상황에서 편집할 특정 보기를 상황에 맞게 표시할 수 있습니다.

00:16:52.000 --> 00:17:00.000
이제, 어떻게 하는지 보여주기 위해, 우리가 하는 일은 잔액 금액을 나타내는 텍스트에 .privacySensitive 보기 수정자를 삽입하기만 하면 됩니다.

00:17:00.000 --> 00:17:08.000
그래서 암호가 잠겨 있지 않을 때, 여기에서 볼 수 있듯이, 보기는 여전히 예상대로 잔액을 렌더링합니다.

00:17:08.000 --> 00:17:15.000
하지만 우리가 이제 장치를 잠그면, 잔액이 마스킹되거나 편집됩니다.

00:17:15.000 --> 00:17:21.000
이 수정자는 hstacks 및 vstacks와 같은 컨테이너 뷰를 포함한 모든 뷰에 적용될 수 있다는 점에 유의하십시오.

00:17:21.000 --> 00:17:26.000
그리고 컨테이너에 적용하면, 전체 컨테이너가 편집될 것이다.

00:17:26.000 --> 00:17:44.000
예를 들어, 앱이 iOS 장치가 암호로 잠겨 있는 동안 만질 수 없는 완전한 데이터 보호를 활용한다면, 앱이 건강 데이터를 사용하고 위젯 구축을 건너뛰거나 잠금 화면에 표시되어야 한다고 생각했기 때문에 포함시키는 것을 두려워했을 수 있습니다. 이 기능은 정말 당신을 위한 것입니다.

00:17:44.000 --> 00:17:54.000
WidgetKit은 콘텐츠의 전체 편집을 위해 장치가 암호로 잠겨 있을 때 활성 타임라인 콘텐츠를 자리 표시자 콘텐츠로 자동으로 대체할 수 있습니다.

00:17:54.000 --> 00:17:59.000
그리고 장치가 암호로 잠겨 있는 동안 업데이트를 보류할 수도 있습니다.

00:17:59.000 --> 00:18:04.000
이것은 여기에 나열된 기본 데이터 보호 자격을 채택할 때 모두 가능합니다.

00:18:04.000 --> 00:18:09.000
당신의 타임라인 데이터는 당신의 소원에 따라 장치의 데이터 클래스에 저장될 것입니다.

00:18:09.000 --> 00:18:12.000
우리는 여기서 당신의 데이터 프라이버시를 진지하게 받아들입니다.

00:18:12.000 --> 00:18:15.000
마지막으로, 나는 위치 관련성에 대해 이야기하고 싶다.

00:18:15.000 --> 00:18:26.000
앱과 같은 위젯은 현재 물리적 위치 또는 단순히 어떤 식으로든 사용자와 관련된 위치에 대한 문맥 정보를 제공할 수 있습니다.

00:18:26.000 --> 00:18:31.000
애플리케이션이 정상적으로 위치를 사용한다면, 위젯도 그래야 할 가능성이 높습니다.

00:18:31.000 --> 00:18:46.000
위젯은 홈 화면과 Mac의 알림 센터에 여러 인스턴스를 가질 수 있기 때문에, 의도의 힘을 통해 날씨 위젯과 마찬가지로 현재 위치를 사용하는 것 외에도 위젯에 대해 미리 선택되고 검색 가능한 위치를 제공하는 것을 고려하십시오.

00:18:46.000 --> 00:18:51.000
이제, 위젯에서 현재 위치를 가져오려면, 몇 단계만 있으면 됩니다.

00:18:51.000 --> 00:18:56.000
먼저, Info.plist에서 NSWidgetUsesLocation 키를 지정해야 합니다.

00:18:56.000 --> 00:19:01.000
이를 통해 시스템은 위젯 확장 프로그램의 위치를 사용할 것임을 알 수 있습니다.

00:19:01.000 --> 00:19:10.000
둘째, 위젯 확장 프로그램의 TimelineProvider를 제외하고 평소처럼 CLLocationManager를 사용하세요.

00:19:10.000 --> 00:19:19.000
거친 위치를 해결하는 것이 더 빠르기 때문에 위젯에 필요한 해상도를 고려하십시오. 초정확한 위치가 필요하지 않은 경우 더 나은 사용자 경험을 얻을 수 있습니다.

00:19:19.000 --> 00:19:25.000
일반적으로, 요청된 위치가 정확할수록, 해결하는 데 더 오래 걸릴 것이다.

00:19:25.000 --> 00:19:33.000
마지막으로, CLLocationManager의 isAuthorizedForWidgetUpdates API를 사용하여 위젯이 위치 업데이트 권한이 있는지 확인할 수 있습니다.

00:19:33.000 --> 00:19:38.000
이것은 사용자가 위치를 사용할 수 있는 위젯 권한을 부여했는지 여부를 알려줄 것입니다.

00:19:38.000 --> 00:19:44.000
권한에 대해 말하자면, 위젯의 위치 권한을 더 자세히 살펴보고 어떻게 작동하는지 봅시다.

00:19:44.000 --> 00:19:48.000
위젯에 대한 권한은 일반적으로 앱 컨테이너와 공유됩니다.

00:19:48.000 --> 00:19:54.000
여기에서 설정 앱에서 사용할 수 있는 사용 가능한 위치 권한 목록을 볼 수 있습니다.

00:19:54.000 --> 00:20:08.000
사용자가 "앱을 사용하는 동안"을 선택하는 경우, 위젯의 컨테이너 앱이 사용자에게 전경이거나 탐색 세션에 있는 것과 같이 앱을 사용 중인 것으로 간주하는 다른 상황에서만 위젯에서 사용자의 위치를 사용할 수 있습니다.

00:20:08.000 --> 00:20:19.000
사용자가 "앱 또는 위젯을 사용하는 동안"을 선택하면, 위치는 "앱을 사용하는 동안"에서 이전과 동일하게 사용할 수 있지만 위젯과 관련된 추가 수당이 있습니다.

00:20:19.000 --> 00:20:26.000
이를 통해 위젯 권한은 위젯을 마지막으로 본 후 최대 15분까지 위치를 받을 수 있습니다.

00:20:26.000 --> 00:20:41.000
그리고 이 두 권한 세트 중 하나로 위치를 해결할 수 없는 경우, 대체 콘텐츠, 사용 가능한 경우 이전 콘텐츠 또는 단순히 위치를 해결할 수 없음을 나타내는 것을 고려하십시오.

00:20:41.000 --> 00:20:48.000
사용자가 권한으로 "항상"을 선택하면, 위젯은 항상 위치에 액세스할 수 있는 권한이 있습니다.

00:20:48.000 --> 00:20:51.000
마지막으로, 사용자 정의 가능한 위젯을 만드는 것에 대해 이야기해 봅시다.

00:20:51.000 --> 00:20:58.000
우리는 사용자가 위젯 경험을 개인화할 수 있는 수단으로 크기, 종류 및 구성에 대해 이야기할 것입니다.

00:20:58.000 --> 00:21:00.000
이제, 위젯은 다양한 크기로 제공됩니다.

00:21:00.000 --> 00:21:06.000
그리고 사용자가 위젯을 배치할 때 선택할 수 있도록 가능한 한 많은 크기를 지원하는 것이 좋습니다.

00:21:06.000 --> 00:21:17.000
장치 간의 크기 조정에는 작은 차이가 존재하며, 가능한 경우 시스템 표준 패딩, 여백, 텍스트 스타일 및 텍스트 크기를 사용하는 것이 가장 좋습니다.

00:21:17.000 --> 00:21:22.000
이제, 이 아이패드를 보면, 그것은 정말 콘텐츠 쇼케이스로 변모했습니다.

00:21:22.000 --> 00:21:31.000
분명하지 않다면, iPad를 위해 특별히 iOS 15에 새로운 크기가 추가되었고, 우리는 그것을 엑스트라 라지라고 부릅니다.

00:21:31.000 --> 00:21:32.000
당신이 더 잘 볼 수 있도록 여기 있습니다.

00:21:32.000 --> 00:21:39.000
큰 위젯과 같은 높이이지만 iPad에서 사용할 수 있는 더 많은 콘텐츠를 선보일 수 있습니다.

00:21:39.000 --> 00:21:42.000
그리고 위젯에 추가하는 방법은 다음과 같습니다.

00:21:42.000 --> 00:21:47.000
여기서 저는 이미 systemLarge 제품군을 지원하는 기존 위젯 구성에 추가했습니다.

00:21:47.000 --> 00:22:00.000
기본적으로, 위젯 구성에서 지원되는 가족을 지정하지 않으면, iOS 15 SDK 이상으로 빌드하면 새 크기가 자동으로 지원됩니다.

00:22:00.000 --> 00:22:03.000
개인화의 다음 축은 위젯 종류이다.

00:22:03.000 --> 00:22:08.000
위젯의 종류는 당신의 데이터나 콘텐츠에 대해 다른 관점을 제공합니다.

00:22:08.000 --> 00:22:12.000
그러니 앱에서 어떤 종류의 위젯이 가장 의미가 있을지 생각해 보세요.

00:22:12.000 --> 00:22:16.000
이것들을 설명하는 가장 좋은 방법은 실제로 예시를 보여주는 것이다.

00:22:16.000 --> 00:22:18.000
여기 시계의 예가 있습니다.

00:22:18.000 --> 00:22:30.000
왼쪽에는 단일 도시의 시간을 추적하는 도시 위젯이 있고, 오른쪽에는 같은 보기에서 많은 다른 도시를 수용할 수 있는 세계 시계 위젯이 있습니다.

00:22:30.000 --> 00:22:31.000
여기 주식의 또 다른 예가 있습니다.

00:22:31.000 --> 00:22:40.000
왼쪽에는 주어진 주식의 주가를 보여주는 주식 기호 위젯이 있습니다. 이 경우 Apple과 오른쪽에는 개요 위젯이 있습니다.

00:22:40.000 --> 00:22:45.000
개요 위젯은 사용자의 주식 앱에 반영된 일련의 주식을 보여줄 것이다.

00:22:45.000 --> 00:22:49.000
그래서 당신은 이 다양한 종류의 위젯을 어떻게 게시하나요?

00:22:49.000 --> 00:22:53.000
음, 여러 종류의 위젯을 게시하는 것은 매우 사소하다.

00:22:53.000 --> 00:23:00.000
이전의 주식 예시를 사용하여, 왼쪽 상단에 심볼 위젯과 개요 위젯이 있습니다.

00:23:00.000 --> 00:23:08.000
이것들을 게시하려면, WidgetBundle 객체에 다른 위젯 구성을 반환하고 WidgetBundle에 @main 속성을 포함하기만 하면 됩니다.

00:23:08.000 --> 00:23:11.000
그렇게 쉬워.

00:23:11.000 --> 00:23:15.000
위젯이 번들에 정의되는 순서도 매우 중요하다는 점에 유의하십시오.

00:23:15.000 --> 00:23:19.000
이 순서는 위젯이 위젯 갤러리에 어떻게 나타날지 반영합니다.

00:23:19.000 --> 00:23:24.000
따라서 나열된 첫 번째 위젯이 영웅 사용 사례인지 확인하세요.

00:23:24.000 --> 00:23:32.000
마지막으로, 앱이 설치되면 위젯의 가용성을 동적으로 게시하거나 동적으로 철회할 수 없습니다.

00:23:32.000 --> 00:23:39.000
따라서 시간이 지남에 따라 위젯의 지원에 약간의 관심과 생각이 적용되어야 합니다.

00:23:39.000 --> 00:23:42.000
사용자 정의의 마지막 축은 구성을 통한 것이다.

00:23:42.000 --> 00:23:47.000
그리고 위젯은 두 가지 유형을 지원합니다: 정적 구성과 의도 기반 구성.

00:23:47.000 --> 00:23:53.000
정적 위젯 구성은 각 위젯 인스턴스에 대해 동일한 콘텐츠를 제공합니다.

00:23:53.000 --> 00:23:55.000
이전의 주식 개요 예시를 기억하시나요?

00:23:55.000 --> 00:24:02.000
음, 각각은 사용자 장치의 다른 위치에 있더라도 정확히 같은 콘텐츠를 보여줄 것입니다.

00:24:02.000 --> 00:24:11.000
정적 위젯은 매우 간단하며, 사용자로부터 구성이나 설정을 받지 않기 때문에 우아한 위젯 정의입니다.

00:24:11.000 --> 00:24:18.000
반면에, 의도 위젯 구성은 각 인스턴스에 대해 사용자 구성 콘텐츠를 제공합니다.

00:24:18.000 --> 00:24:22.000
오른쪽에 있는 이 스톡 심볼 위젯을 확인하세요.

00:24:22.000 --> 00:24:27.000
이 사용자는 각각 다른 주식을 보여주는 많은 다른 인스턴스를 구성했다.

00:24:27.000 --> 00:24:28.000
이제, 이건 꽤 달콤한 것들이야.

00:24:28.000 --> 00:24:35.000
그리고 사용자는 이 모든 것을 홈 화면의 위젯 스택으로 결합하여 공간을 절약하기 위해 뒤집을 수도 있습니다.

00:24:35.000 --> 00:24:39.000
그래서 이것들은 사용자에 의해 어떻게 구성되는지, 당신은 물어볼 수 있습니다.

00:24:39.000 --> 00:24:44.000
음, 사용자의 관점에서, 시스템은 주변의 모든 UI 조각을 제공할 것이다.

00:24:44.000 --> 00:24:50.000
그리고 의도를 지원하는 편집 모드에서 위젯을 탭한 후, 구성 플래터가 표시됩니다.

00:24:50.000 --> 00:24:54.000
그것은 사용자가 구성할 수 있는 인텐트의 매개 변수 목록을 제공한다.

00:24:54.000 --> 00:25:02.000
그리고 이 예에서, 심볼이 추적할 단일 매개 변수가 있으며 그 값은 현재 애플 주식의 문자열 AAPL입니다.

00:25:02.000 --> 00:25:07.000
이제, 사용자가 매개 변수를 탭하면, 입력 컨트롤러가 사용자로부터 입력을 수집하는 것처럼 나타납니다.

00:25:07.000 --> 00:25:10.000
그리고 완료되면, 위젯은 자동으로 업데이트될 것이다.

00:25:10.000 --> 00:25:20.000
이제, 인텐트로 할 수 있는 수많은 사용자 정의가 있으며, 인텐트 구성을 원한다면 시작할 수 있도록 잠시 공유할 WWDC 2020의 훌륭한 이야기가 있습니다.

00:25:20.000 --> 00:25:29.000
그 동안, 의도를 기반으로 위젯을 코딩하는 것과 정적 구성을 코딩하는 것의 차이점을 빠르게 강조해 봅시다.

00:25:29.000 --> 00:25:31.000
정적 구성은 정말 간단하다.

00:25:31.000 --> 00:25:36.000
표준 TimelineProvider로 StaticConfiguration 객체를 인스턴스화하기만 하면 됩니다.

00:25:36.000 --> 00:25:40.000
그것을 의도 구성과 대조해 봅시다.

00:25:40.000 --> 00:25:49.000
여기서 다른 모든 것은 StaticConfiguration이 IntentConfiguration으로 대체되고 TimelineProvider가 IntentTimelineProvider로 대체된다는 것입니다.

00:25:49.000 --> 00:25:57.000
이들 각각은 인텐트를 지원하기 위해 약간 수정된 인터페이스를 가지고 있으며, 이를 통해 타임라인을 채울 때 사용자가 구성한 인텐트를 받을 수 있습니다.

00:25:57.000 --> 00:26:12.000
지원되는 다양한 데이터 유형과 구성 UI에서 어떻게 보이는지에 대한 개요를 포함하여 위젯의 인텐트 생성 및 구성에 대한 자세한 내용은 WWDC 2020의 "위젯에 구성 및 인텔리전스 추가" 토크를 확인하십시오.

00:26:12.000 --> 00:26:23.000
마무리하기 위해, 우리는 훌륭한 위젯이 타임라인 항목을 어떻게 활용하고, 재장전 정책을 마스터하고, 프레젠테이션과 잠재적으로 물리적 환경에 적응하는지 검토했습니다.

00:26:23.000 --> 00:26:30.000
사용자에게 역동적이고 개인화된 경험을 제공하기 위해 다양한 크기, 종류 및 구성을 제공할 계획을 세우세요.

00:26:30.000 --> 23:59:59.000
고마워.

