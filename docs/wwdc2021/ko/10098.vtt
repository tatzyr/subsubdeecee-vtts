WEBVTT

00:00:00.000 --> 00:00:05.000
♪ 베이스 음악 연주 ♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:13.000
David Stites: 안녕하세요, "Showcase app data in Spotlight"에 오신 것을 환영합니다.

00:00:13.000 --> 00:00:17.000
제 이름은 David Stites이고, 저는 Core Data 팀의 엔지니어입니다.

00:00:17.000 --> 00:00:26.000
이 세션에서는 NSCoreDataCoreSpotlightDelegate를 사용하여 앱에 스포트라이트 인덱싱을 추가하는 방법을 보여드리게 되어 기쁩니다.

00:00:26.000 --> 00:00:43.000
이 세션의 의제는 NSCoreDataCoreSpotlightDelegate 객체와 그것을 사용해야 하는 이유에 대해 배우고, 간단한 구현을 설정하고, 구현을 사용자 정의하는 방법을 배우고, 마지막으로 전체 텍스트 검색을 추가하여 코드를 검증하는 것입니다.

00:00:43.000 --> 00:00:48.000
먼저, 핵심 데이터와 스포트라이트를 살펴봅시다.

00:00:48.000 --> 00:00:53.000
사람들은 당신의 앱에 많은 훌륭하고 중요한 콘텐츠를 만들고 저장할 것입니다.

00:00:53.000 --> 00:01:08.000
앱 사용과 데이터 세트의 크기가 증가함에 따라, 그들은 표준 검색 방법과 스포트라이트 검색과 같은 앱 외부를 사용하여 앱 내부에서 데이터를 빠르게 찾을 수 있기를 원할 것입니다.

00:01:08.000 --> 00:01:13.000
앱 내부의 데이터가 스포트라이트에 표시되는 것이 좋지 않을까요?

00:01:13.000 --> 00:01:17.000
음, 여기가 핵심 데이터가 당신을 도울 수 있는 곳입니다.

00:01:17.000 --> 00:01:27.000
NSCoreDataCore SpotlightDelegate 객체는 모든 무거운 작업을 수행하며 앱에서 제공하는 콘텐츠를 빠르고 효율적으로 인덱싱하는 API 세트를 제공합니다.

00:01:27.000 --> 00:01:30.000
넌 그냥 그걸 켜기만 하면 돼!

00:01:30.000 --> 00:01:38.000
일단 인덱싱되면, 검색 결과는 앱 외부의 스포트라이트 검색 사용자 인터페이스에도 나타납니다.

00:01:38.000 --> 00:01:46.000
스포트라이트 대리인은 그래프의 관리 대상에 대한 변경 사항을 자동으로 처리한 다음 그에 따라 스포트라이트 인덱스를 업데이트합니다.

00:01:46.000 --> 00:01:58.000
또한, 개인 장치 전용 인덱스와 상호 작용할 수 있는 강력한 인덱스 관리 기능을 제공하며 원하는 대로 인덱스 결과를 조정할 수 있습니다.

00:01:58.000 --> 00:02:05.000
사실, 당신의 영구 저장소에 있는 모든 콘텐츠는 인덱싱될 수 있습니다.

00:02:05.000 --> 00:02:29.000
스포트라이트 대리자를 사용하는 이유는 세 가지입니다: (1) 스포트라이트 대리자는 코어 스포트라이트 API와 기능 패리티를 유지하고, (2) 필요한 많은 구현 코드를 제거하고, (3) 이 세션의 뒷부분에서 논의할 훌륭한 추가 기능 세트를 제공합니다.

00:02:29.000 --> 00:02:41.000
이전 요점을 설명하기 위해, 이것은 검색 인덱스에 항목만 추가하고... 이것으로 줄이는 코어 스포트라이트 API를 사용하는 매우 간단한 구현입니다!

00:02:41.000 --> 00:02:43.000
두 줄!

00:02:43.000 --> 00:02:45.000
간단하고, 읽고 유지하기 쉽다.

00:02:45.000 --> 00:02:49.000
내 말은, 누가 더 적은 코드를 선호하지 않겠어?

00:02:49.000 --> 00:02:53.000
바로 설치하고 달리는 방법을 살펴봅시다.

00:02:53.000 --> 00:02:58.000
이 간단한 예시는 무엇을 인덱싱할지 결정하고 대리인을 만드는 것을 다룰 것이다.

00:02:58.000 --> 00:03:07.000
이 세션 내내, 나는 간단한 사진 태그 응용 프로그램인 내가 직접 쓴 태그라는 앱을 언급할 것이다.

00:03:07.000 --> 00:03:12.000
이 샘플 앱은 내가 오늘 논의하고 있는 많은 API를 통합할 것이다.

00:03:12.000 --> 00:03:24.000
스포트라이트 지원을 추가하기 전에, "Natural Bridges State Park"에 대한 스포트라이트 검색 쿼리 결과가 없기 때문에 모든 태그와 사진 데이터가 태그 안에 갇혀 있는 것을 볼 수 있습니다.

00:03:24.000 --> 00:03:25.000
그걸 바꾸자!

00:03:25.000 --> 00:03:34.000
NSCoreDataCoreSpotlightDelegate를 사용하는 구현의 첫 번째 단계는 Spotlight에서 무엇을 인덱싱할지 결정하는 것입니다.

00:03:34.000 --> 00:03:37.000
스포트라이트에서 색인되는 것은 전적으로 당신에게 달려 있습니다.

00:03:37.000 --> 00:03:48.000
태그에서 엔티티 사진의 userSpecifiedName 속성과 엔티티 태그의 이름 속성을 인덱싱하기로 결정했습니다.

00:03:48.000 --> 00:04:01.000
인덱싱을 위한 모델을 준비하기 위해, Xcode에서 프로젝트의 핵심 데이터 모델을 열고, 인덱싱하고 싶은 각 속성을 선택하고, 속성 관리자의 Spotlight 체크박스를 체크했습니다.

00:04:01.000 --> 00:04:09.000
코어 데이터 스포트라이트 표시 이름을 설정해야 하기 때문에 우리의 작업은 코어 데이터 모델 편집기에서 계속됩니다.

00:04:09.000 --> 00:04:13.000
코어 데이터 스포트라이트 표시 이름은 NSExpression이다.

00:04:13.000 --> 00:04:23.000
인덱싱 시, 이 표현식은 Spotlight에 의해 인덱싱된 속성이 있는 각 관리 객체로 평가되고 결과가 저장됩니다.

00:04:23.000 --> 00:04:33.000
나중에, 스포트라이트 검색 사용자 인터페이스가 표시되면, 이러한 저장된 결과는 검색 결과의 "표시 이름"으로 사용됩니다.

00:04:33.000 --> 00:04:35.000
NSExpression이 뭐야?

00:04:35.000 --> 00:04:42.000
음, 표현식은 키 경로를 평가하는 것만큼 간단할 수 있습니다. 이 경우 Tag.name.

00:04:42.000 --> 00:04:48.000
그러나 이 물체는 주요 경로를 평가하는 것 외에도 할 수 있는 몇 가지 트릭을 더 가지고 있다.

00:04:48.000 --> 00:04:51.000
이 예에서, 그것은 당신을 위해 수학을 하고 있습니다.

00:04:51.000 --> 00:04:59.000
그 표현은 숫자 집합의 표준 편차를 계산하는 것과 같이 훨씬 더 복잡할 수 있다.

00:04:59.000 --> 00:05:09.000
태그에서 스포트라이트 표시 이름은 엔티티 사진의 userSpecifiedName과 엔티티 태그의 이름으로 설정됩니다.

00:05:09.000 --> 00:05:15.000
이제 모델이 인덱싱을 위해 준비 되었으니, 스포트라이트 대리자를 만들어 봅시다.

00:05:15.000 --> 00:05:24.000
iOS 15와 macOS Monterey를 시작으로, StoreWith: model:의 이니셜라이저는 이제 더 이상 사용되지 않습니다.

00:05:24.000 --> 00:05:28.000
스포트라이트 대리인을 초기화하는 새로운 방법은 forStoreWith: 코디네이터를 사용하는 것입니다.

00:05:28.000 --> 00:05:39.000
새로운 지정된 이니셜라이저를 채택함으로써, 더 이상 코디네이터에 매장을 추가하기 전에 스토어 옵션에 스포트라이트 대리인의 인스턴스를 추가할 필요가 없습니다.

00:05:39.000 --> 00:05:47.000
그러나 Spotlight 대리인이 작업을 시작하려면 startSpotlightIndexing을 호출해야 합니다.

00:05:47.000 --> 00:05:52.000
NSCoreDataCoreSpotlightDelegate를 사용하기 위한 몇 가지 요구 사항을 밝히고 싶습니다.

00:05:52.000 --> 00:05:59.000
인덱싱할 저장소의 저장소 유형은 SQLite여야 하며 지속적인 기록 추적이 활성화되어 있어야 합니다.

00:05:59.000 --> 00:06:01.000
그리고 그것으로, 넌 끝났어!

00:06:01.000 --> 00:06:02.000
그게 다야!

00:06:02.000 --> 00:06:08.000
당신은 다른 일을 할 필요가 없으며 당신의 데이터는 Spotlight에 인덱싱될 것입니다.

00:06:08.000 --> 00:06:13.000
나는 방금 내 태그 앱에 스포트라이트 인덱싱을 추가하는 것이 얼마나 쉬운지 보여주었다.

00:06:13.000 --> 00:06:18.000
이제 기본 사항을 설명했으니, 그 구현을 조금 사용자 정의해 봅시다.

00:06:18.000 --> 00:06:24.000
구현을 사용자 정의하는 첫 번째 방법은 도메인과 인덱스 이름을 정의하는 것입니다.

00:06:24.000 --> 00:06:34.000
우선, 저는 NSCoreDataCoreSpotlightDelegate의 하위 클래스인 TagsSpotlightDelegate 클래스를 정의할 것입니다.

00:06:34.000 --> 00:06:39.000
이제, 저는 구현으로 domainName과 indexName을 재정의할 것입니다.

00:06:39.000 --> 00:06:49.000
이러한 선택기를 재정의하면 스포트라이트가 인덱싱된 데이터를 어디에 저장할지 알려주고, 특히 여러 인덱스가 있는 경우 나중에 더 잘 식별할 수 있습니다.

00:06:49.000 --> 00:06:56.000
domainIdentifier를 재정의하지 않으면, 기본 도메인 식별자는 저장소 식별자입니다.

00:06:56.000 --> 00:07:02.000
indexName을 재정의하지 않으면, 기본 인덱스 이름은 nil입니다.

00:07:02.000 --> 00:07:08.000
스포트라이트 대리자를 사용자 정의하는 다음 단계는 속성 세트를 정의하는 것입니다.

00:07:08.000 --> 00:07:21.000
이 세션의 설정 부분에서 NSCoreDataCore SpotlightDelegate 객체는 Spotlight의 인덱스 확인란을 체크하여 Spotlight로 반환된 속성 세트를 정의했습니다.

00:07:21.000 --> 00:07:28.000
이제, 나는 인덱싱에 사용될 속성을 지정하는 방법을 정확히 보여줄 것이다.

00:07:28.000 --> 00:07:36.000
인덱싱해야 하는 속성을 지정하면 인덱싱된 내용과 검색 방법을 더 명시적으로 제어할 수 있습니다.

00:07:36.000 --> 00:07:40.000
그렇게 하려면, CSSearchableItemAttributeSet을 사용하세요.

00:07:40.000 --> 00:07:52.000
속성 세트에는 검색 결과로 나타날 때 지정된 관리 대상에 대해 표시할 메타데이터를 지정할 수 있는 여러 사전 정의된 속성이 포함되어 있습니다.

00:07:52.000 --> 00:07:56.000
당신이 선택하는 속성은 당신의 도메인에 전적으로 달려 있습니다.

00:07:56.000 --> 00:08:05.000
CSSearchableItemAttributeSet에서 사용할 수 있는 미리 정의된 속성을 사용하거나 자신만의 속성을 정의할 수 있습니다.

00:08:05.000 --> 00:08:13.000
태그 앱은 미리 정의된 속성 키워드, displayName 및 썸네일 데이터를 사용합니다.

00:08:13.000 --> 00:08:24.000
속성 세트의 속성에 대한 동시 액세스에는 정의되지 않은 동작이 있으므로 한 번에 하나의 스레드에 설정된 속성만 수정해야 한다는 점에 유의하는 것이 중요합니다.

00:08:24.000 --> 00:08:31.000
TagsSpotlightDelegate 클래스로 돌아가서, attributeSet(객체의 경우)을 재정의하여 이것이 어떻게 작동하는지 봅시다.

00:08:31.000 --> 00:08:36.000
재정의 구현에서, 객체가 사진 유형 객체인지 결정하는 것으로 시작하세요.

00:08:36.000 --> 00:08:42.000
다음으로, 콘텐츠 유형 .image로 attributeSet을 초기화하세요.

00:08:42.000 --> 00:08:55.000
그런 다음, Photo 객체의 적절한 속성을 사용하여 속성 세트에 속성 식별자, displayName 및 thumbnailData를 설정하십시오.

00:08:55.000 --> 00:09:01.000
이제, 사진 개체 태그 세트의 태그를 속성 세트의 키워드 배열에 추가하세요.

00:09:01.000 --> 00:09:15.000
이 시점에서 모델이 관계를 인덱싱하는 경우, attributeSet(객체:)을 재정의하여 특히 그 관계에 대해 인덱싱되는 것을 정의해야 한다는 점을 언급할 가치가 있습니다.

00:09:15.000 --> 00:09:19.000
마지막으로, 속성 세트를 반환하세요.

00:09:19.000 --> 00:09:25.000
모델이 태그 객체를 인덱싱하고 있기 때문에, 코드는 태그의 경우를 처리해야 한다.

00:09:25.000 --> 00:09:37.000
그것을 위해, contentType .text로 설정된 속성을 만들고, 표시 이름을 태그 이름으로 설정한 다음, 속성 세트를 반환하십시오.

00:09:37.000 --> 00:09:45.000
마지막 단계로, 이전 단계에서 모델 편집기에서 설정된 Core Data Spotlight 표시 이름을 제거하십시오.

00:09:45.000 --> 00:09:52.000
더 나아가 인덱싱을 시작하고 멈추기 위한 이벤트 루프를 정의해 봅시다.

00:09:52.000 --> 00:10:00.000
이전에, 우리가 스포트라이트 대리자를 설정할 때, startSpotlightIndexing은 스포트라이트 대리자를 만든 직후에 호출되었다.

00:10:00.000 --> 00:10:11.000
NSCoreDataCoreSpotlightDelegate가 인덱싱 작업을 수행할 때를 정확하게 제어할 수 있도록 stopSpotlightIndexing도 프레임워크에 추가되었습니다.

00:10:11.000 --> 00:10:25.000
이 두 선택기를 사용하면 앱이 강렬한 CPU 또는 디스크 활동 작업을 수행하는 경우 필요에 따라 인덱싱 작업을 시작하고 중지할 수 있습니다.

00:10:25.000 --> 00:10:31.000
이제, 인덱스 업데이트가 완료되면 알림을 받을 수 있는 지원을 추가해 봅시다.

00:10:31.000 --> 00:10:41.000
Spotlight에서 인덱싱된 엔티티 또는 엔티티에 변경이 발생하면, 해당 인덱스는 비동기적으로 업데이트됩니다.

00:10:41.000 --> 00:10:48.000
iOS 15와 macOS Monterey에서 Core Data 프레임워크는 인덱스 업데이트 알림을 추가했습니다.

00:10:48.000 --> 00:11:01.000
인덱스 업데이트가 완료되면 알림을 받으려면, Spotlight 대리인이 게시한 NSCoreDataCoreSpotlightDelegate .indexDidUpdateNotification을 구독하십시오.

00:11:01.000 --> 00:11:11.000
이러한 알림은 저장 요청을 처리한 후 게시됩니다: NSManagedObjectContext 또는 배치 작업이 완료된 후.

00:11:11.000 --> 00:11:14.000
이것이 실제로 실행되는지 봅시다.

00:11:14.000 --> 00:11:18.000
먼저, 인덱싱이 활성화되었는지 확인하세요.

00:11:18.000 --> 00:11:23.000
만약 그렇다면, indexDidUpdateNotification에 등록하세요.

00:11:23.000 --> 00:11:50.000
그런 다음 핸들러에서 원격 변경 알림과 유사한 두 개의 키-값 쌍을 포함하는 userInfo 사전이 있는 알림을 검사하십시오: 스포트라이트 대리자가 인덱스를 업데이트한 저장소의 NSString UUID와 스포트라이트 대리자가 인덱스를 업데이트한 저장소의 영구 이력 토큰.

00:11:50.000 --> 00:11:59.000
이 두 키를 모두 사용하여 관심 있는 상점이 최신 영구 기록 토큰까지 인덱싱되었는지 확인할 수 있습니다.

00:11:59.000 --> 00:12:07.000
인덱싱이 활성화되지 않은 경우, 알림에서 관찰자로서 자신을 제거할 수 있습니다.

00:12:07.000 --> 00:12:21.000
올해 이전에, 앱에서 인덱싱된 데이터를 삭제하는 유일한 방법은 Core Spotlight API를 구현하여 인덱스 항목을 제거하거나 Core Data에서 전체 클라이언트 그래프를 삭제하는 것이었습니다.

00:12:21.000 --> 00:12:36.000
결정적으로, iOS 15와 macOS Monterey의 새로운 Core Data는 개발자에게 클라이언트 그래프를 삭제하지 않고 스포트라이트 인덱스를 관리할 수 있는 새로운 방법을 제공했으며, 이는 사용자 개인 정보 보호에 큰 승리입니다!

00:12:36.000 --> 00:12:39.000
먼저, 코드는 인덱싱을 멈출 것이다.

00:12:39.000 --> 00:12:43.000
그런 다음, deleteSpotlightIndex를 호출하세요.

00:12:43.000 --> 00:12:47.000
마지막으로, 완료 핸들러에서 발생하는 오류를 처리하세요.

00:12:47.000 --> 00:12:58.000
이 방법을 호출하면 Core Data 및 Core Spotlight와 같은 하위 계층 종속성에서 오류가 발생할 수 있으며 이를 처리할 준비가 되어 있어야 합니다.

00:12:58.000 --> 00:13:09.000
이제 Spotlight 대리자의 구현을 사용자 정의하는 방법을 보여드렸으니, Core Spotlight API를 사용하여 태그 앱에 전체 텍스트 검색을 추가하여 설정을 검증해 봅시다.

00:13:09.000 --> 00:13:13.000
그 결과는 이전에 색인된 것이 될 것이다.

00:13:13.000 --> 00:13:25.000
UISearchResultsUpdating 프로토콜과 함수 updateSearchResults(컨트롤러용)를 채택한 PhotosViewController의 확장을 정의하는 것으로 시작하세요.

00:13:25.000 --> 00:13:29.000
태그 사용자 인터페이스에는 UISearchController가 있습니다.

00:13:29.000 --> 00:13:33.000
우리는 그 검색 컨트롤러의 검색창에서 사용자 입력을 받을 것이다.

00:13:33.000 --> 00:13:42.000
사용자 입력이 비어 있는 경우, 데이터 공급자로부터 모든 이미지를 가져온 다음 검색 쿼리가 없기 때문에 컬렉션 보기를 다시 로드하십시오.

00:13:42.000 --> 00:13:46.000
이제 검색 쿼리가 있는 경우를 처리해 봅시다.

00:13:46.000 --> 00:13:51.000
시작하려면, 사용자 입력 문자열을 이스케이프하여 삭제하세요.

00:13:51.000 --> 00:13:56.000
다음으로, 사용자의 삭제된 입력 문자열을 사용하여 쿼리 문자열을 정의하십시오.

00:13:56.000 --> 00:14:04.000
쿼리 문자열은 CSSearchableItemAttributeSet 객체의 속성과 관련된 값에서 작동합니다.

00:14:04.000 --> 00:14:11.000
이 경우, 코드는 이전 단계에서 설정된 키워드 속성에서 작동할 것이다.

00:14:11.000 --> 00:14:17.000
검색 쿼리에서 수정자 c, d, w가 사용되고 있다.

00:14:17.000 --> 00:14:20.000
C는 대소문자를 구분하지 않는다.

00:14:20.000 --> 00:14:22.000
D는 발음 구별 부진을 위한 것이다.

00:14:22.000 --> 00:14:27.000
그리고 w는 단어 기반 검색이다.

00:14:27.000 --> 00:14:42.000
이제, 방금 생성된 형식이 지정된 쿼리 문자열과 CSSearchableItemAttributeSet에 의해 정의된 속성에 해당하는 속성 이름 배열을 지정하여 CSSearchQuery 객체를 만드세요.

00:14:42.000 --> 00:14:53.000
이 검색 쿼리 객체는 Spotlight 대리 API를 사용하여 이전에 인덱싱한 앱 콘텐츠를 검색할 때 적용할 기준을 관리합니다.

00:14:53.000 --> 00:14:56.000
그 다음에, foundItemsHandler를 설정하세요.

00:14:56.000 --> 00:15:02.000
이 핸들러는 이전에 정의된 검색 쿼리와 일치하는 항목으로 반복적으로 호출됩니다.

00:15:02.000 --> 00:15:11.000
한 번 호출될 쿼리에 대한 completionHandler에서 오류를 확인하고 잠재적으로 일부 오류 처리를 수행합니다.

00:15:11.000 --> 00:15:23.000
오류가 없으면, 메인 큐에 블록을 발송하여 데이터 공급자를 사용하여 스포트라이트가 찾은 항목에 대한 가져오기를 수행하고 사용자 인터페이스에 로드하십시오.

00:15:23.000 --> 00:15:28.000
마지막으로, 그리고 가장 중요한 것은, 쿼리를 시작하는 것을 잊지 마세요.

00:15:28.000 --> 00:15:36.000
이제 태그 앱에 콘텐츠를 인덱싱하는 스포트라이트 대리인이 있기 때문에, 데이터는 앱 내에서 해제되었습니다!

00:15:36.000 --> 00:15:51.000
Spotlight에 가서 이전에 추가한 태그를 검색하면 두 가지 결과가 반환됩니다: 태그 이름 자체와 키워드 "Natural Bridges State Park"로 태그한 특정 사진.

00:15:51.000 --> 00:16:15.000
마무리하면서, 우리는 NSCoreDataCoreSpotlightDelegate에 대해 배웠고, 사용자가 Spotlight 검색에서 앱 내부와 앱 외부에서 콘텐츠를 찾고, Spotlight 대리자를 빠르고 쉽게 설정하여 큰 코드 부담 없이 인덱싱을 시작하고, 이번 릴리스에서 사용할 수 있는 새로운 API 중 일부를 사용하여 Spotlight 대리자를 사용자 정의하는 방법을 배웠습니다.

00:16:15.000 --> 00:16:24.000
이 정보가 유용하고 사용자가 콘텐츠를 찾을 수 있도록 프로젝트에 NSCoreDataCoreSpotlightDelegate를 채택하는 것을 고려하기를 바랍니다.

00:16:24.000 --> 00:16:27.000
멋진 WWDC 되세요!

00:16:27.000 --> 23:59:59.000
♪

