WEBVTT

00:00:00.000 --> 00:00:05.000
♪ 베이스 음악 연주 ♪

00:00:05.000 --> 00:00:09.000
♪

00:00:09.000 --> 00:00:13.000
Willem Mattelaer: 안녕하세요, 제 이름은 Willem이고 저는 그룹 활동에서 일하는 엔지니어입니다.

00:00:13.000 --> 00:00:19.000
저는 앵거스와 아담과 함께 그룹 활동으로 맞춤형 경험을 만들 수 있는 방법에 대해 이야기할 것입니다.

00:00:19.000 --> 00:00:27.000
우선, 이 세션에서 작업할 앱을 소개하고 그룹 활동 지원을 추가할 수 있는 훌륭한 후보자인 이유를 설명하겠습니다.

00:00:27.000 --> 00:00:35.000
다음으로, 우리는 활동 생성 및 세션 관리 단계를 검토하고 미디어 경험을 만드는 것과의 차이점을 설명할 것입니다.

00:00:35.000 --> 00:00:41.000
마지막으로, 앱을 사용하는 동안 사용자가 가진 경험을 연마할 수 있는 몇 가지 방법을 언급하겠습니다.

00:00:41.000 --> 00:00:47.000
그룹 활동을 사용하면 SharePlay로 장치 간에 공유 경험을 구축할 수 있습니다.

00:00:47.000 --> 00:00:56.000
초점은 미디어 경험을 만드는 데 있지만, 창의력을 발휘하고 여러 장치에서 앱을 어떻게 경험할 수 있는지 보는 것을 방해해서는 안 됩니다.

00:00:56.000 --> 00:01:02.000
우리는 "그룹 활동과 미디어 경험 조정" 세션에서 소개된 몇 가지 개념을 기반으로 할 것입니다.

00:01:02.000 --> 00:01:06.000
나는 그것을 확인하는 것을 강력히 추천한다.

00:01:06.000 --> 00:01:13.000
이 세션에서, 우리는 당신이 FaceTime에서 함께 그릴 수 있는 DrawTogether라는 앱을 작업할 것입니다.

00:01:13.000 --> 00:01:19.000
거의 모든 화면이 캔버스이고 모든 사람이 그리는 데 사용할 수 있는 임의의 색상을 얻는 꽤 간단한 앱입니다.

00:01:19.000 --> 00:01:26.000
하지만 단순함에도 불구하고, 내 친구들과 그림을 그리고 그들 중 몇몇의 훌륭한 기술에 감탄하거나 그들의 형편없는 그림을 비웃는 것은 여전히 믿을 수 없을 정도로 재미있다.

00:01:26.000 --> 00:01:29.000
나는 확실히 두 번째 범주에 속한다.

00:01:29.000 --> 00:01:38.000
우리가 무엇을 향해 나아갈 것인지에 대한 간단한 데모를 보여드리겠습니다.

00:01:38.000 --> 00:01:40.000
얘들아, 무슨 일이야?

00:01:40.000 --> 00:01:42.000
아담, 네가 나한테 질문이 있는 걸 봤어.

00:01:42.000 --> 00:01:48.000
아담 사이드: 그래. 그래서 앵거스와 나는 이야기하고 있었고, 그는 네가 피카소 등급처럼 정말 좋은 예술가라고 말했어.

00:01:48.000 --> 00:01:49.000
그래서 넌 우리에게 보여줘야 해, 친구!

00:01:49.000 --> 00:01:53.000
앵거스 버튼: 나는 윌렘의 그림 중 일부를 보았고, 그것들은 인상적이다.

00:01:53.000 --> 00:01:56.000
윌렘: 내 생각에, 앵거스, 너는 조금 과장하고 있는 것 같아.

00:01:56.000 --> 00:01:58.000
하지만 내가 뭘 할 수 있는지 보여줄 수 있어서 기뻐.

00:01:58.000 --> 00:02:00.000
DrawTogether 앱으로 가자.

00:02:00.000 --> 00:02:01.000
아담: 알았어.

00:02:01.000 --> 00:02:06.000
목가적인 풍경을 할 수 있을까요?

00:02:06.000 --> 00:02:09.000
빌렘: 물론이지, 어... 집을 그리는 것부터 시작할게, 아마도.

00:02:09.000 --> 00:02:13.000
아담: 알았어.

00:02:13.000 --> 00:02:15.000
앵거스: 빌렘, 이 집은 꽤 평범해 보여.

00:02:15.000 --> 00:02:18.000
아마 내가 태양과 함께 너를 도와줄게.

00:02:18.000 --> 00:02:20.000
아담: 내가 나무를 시도해 볼게.

00:02:20.000 --> 00:02:23.000
빌렘: 그 나무는 너무 커.

00:02:23.000 --> 00:02:27.000
아담: 아니, 태양이 너무 낮아, 친구.

00:02:27.000 --> 00:02:29.000
윌렘: 잔디를 좀 추가할게.

00:02:29.000 --> 00:02:32.000
아담: 내가 나무를 좀 더 그릴게.

00:02:32.000 --> 00:02:35.000
윌렘: 알았어. 음, 내가 그걸 부를 것 같아.

00:02:35.000 --> 00:02:39.000
우리는 예술가가 아니며 우리가 지금 하고 있는 일을 멈춰야 한다.

00:02:39.000 --> 00:02:43.000
하자 -- 나중에 얘기하자, 알았지?

00:02:43.000 --> 00:02:45.000
아담: 알았어 앵거스: 안녕.

00:02:45.000 --> 00:02:52.000
윌렘: 보셨듯이, 그룹 활동 API의 핵심 경험 중 하나는 물리적으로 떨어져 있는 동안 함께 일을 할 수 있도록 하는 것입니다.

00:02:52.000 --> 00:03:01.000
잠금을 해제할 수 있는 실시간 상호 작용과 사용자가 얻을 수 있는 즉각적인 반응은 다른 모든 사람들을 보고 들을 수 있기 때문에 진정으로 마법 같은 순간으로 이어질 수 있습니다.

00:03:01.000 --> 00:03:07.000
이것은 앱에 그룹 활동을 통합하는 방법을 고려할 때 명심해야 할 것입니다.

00:03:07.000 --> 00:03:12.000
그룹 활동을 채택하는 두 단계가 있습니다: 활동 생성과 세션 관리.

00:03:12.000 --> 00:03:16.000
우리는 "코로어 미디어 경험" 세션에서 이것을 더 자세히 다루었다.

00:03:16.000 --> 00:03:24.000
이 세션에서는 활동 생성을 시작으로 사용자 지정 경험을 구축할 때 이러한 단계가 어떻게 바뀌는지 살펴봅시다.

00:03:24.000 --> 00:03:27.000
그룹 활동을 만드는 데는 두 부분이 있다.

00:03:27.000 --> 00:03:32.000
먼저 활동을 구성하고, 그 다음에 활동을 활성화합니다.

00:03:32.000 --> 00:03:38.000
미디어 그룹 활동과 비교할 때, 사용자 지정 활동에는 구성 부분만 다릅니다.

00:03:38.000 --> 00:03:44.000
활동을 구성할 때, 모든 참가자들 사이에서 공유하고 싶은 구체적인 경험에 대해 생각해야 합니다.

00:03:44.000 --> 00:03:49.000
그 활동에는 그 경험 내내 일정하게 유지되는 모든 정보가 포함되어야 한다.

00:03:49.000 --> 00:03:55.000
"그룹 활동과 미디어 경험 조정" 세션을 본 적이 있다면, 이것은 친숙해 보일 것입니다.

00:03:55.000 --> 00:04:04.000
우리는 GroupActivity 프로토콜을 준수하는 DrawTogether 구조를 정의했으며, 제목과 관련된 메타데이터를 구성하는 메타데이터 속성을 구현했습니다.

00:04:04.000 --> 00:04:10.000
이제 이것을 사용자 지정 활동으로 만들려면, 메타데이터에 올바른 유형을 설정하기만 하면 됩니다.

00:04:10.000 --> 00:04:15.000
그것을 일반으로 설정함으로써, 우리는 이 활동을 사용자 지정 활동으로 구성합니다.

00:04:15.000 --> 00:04:19.000
그리고 그것이 미디어 활동과 비교하여 사용자 지정 활동을 구성할 때 해야 할 전부입니다.

00:04:19.000 --> 00:04:25.000
이제 Xcode로 바로 뛰어들어 DrawTogether 앱에서 사용자 지정 그룹 활동을 만들기 시작합시다.

00:04:25.000 --> 00:04:29.000
먼저, 우리가 시작하는 코드를 빠르게 안내해 드리겠습니다.

00:04:29.000 --> 00:04:33.000
DrawTogether는 SwiftUI 앱 수명 주기를 사용하는 SwiftUI 앱입니다.

00:04:33.000 --> 00:04:36.000
ContentView는 앱의 주요 보기이다.

00:04:36.000 --> 00:04:41.000
보기 상단에는 그림을 그릴 때 사용할 색상을 보여주는 표시기가 있습니다.

00:04:41.000 --> 00:04:44.000
그 아래에는 캔버스뷰가 있다.

00:04:44.000 --> 00:04:51.000
이것은 캔버스를 사용하며 캔버스의 모든 스트로크를 그리고 사용자 입력을 기반으로 캔버스를 업데이트할 책임이 있습니다.

00:04:51.000 --> 00:04:57.000
마지막으로, 하단에는 그리는 동안 유용할 수 있는 몇 가지 컨트롤이 포함된 ControlBar가 있습니다.

00:04:57.000 --> 00:05:02.000
현재 우리는 캔버스를 지우고 처음부터 시작할 수 있는 단일 버튼이 있습니다.

00:05:02.000 --> 00:05:09.000
캔버스 자체는 각 스트로크에 색상, 식별자 및 포인트 목록이 있는 스트로크 배열로 구성되어 있다.

00:05:09.000 --> 00:05:19.000
캔버스에는 또한 로컬 사용자가 현재 그리는 스트로크를 나타내는 activeStroke와 사용자가 사용할 스트로크 색상이 있습니다.

00:05:19.000 --> 00:05:22.000
이제 우리의 활동을 구성하는 것부터 시작합시다.

00:05:22.000 --> 00:05:25.000
우리가 그것을 하기 전에, 나는 그룹 활동 자격을 추가해야 할 것이다.

00:05:25.000 --> 00:05:32.000
프로젝트 설정으로 가서 서명 및 기능 탭에서 새로운 기능을 추가할 것입니다.

00:05:32.000 --> 00:05:38.000
그룹 활동을 검색하고 선택하겠습니다.

00:05:38.000 --> 00:05:42.000
이제 우리가 자격이 되었으니, 마침내 우리의 활동을 구성합시다.

00:05:42.000 --> 00:05:48.000
파일 &gt; 신규 &gt; 파일로 이동하여 새 파일을 추가할 것입니다...

00:05:48.000 --> 00:05:51.000
그리고 스위프트 파일을 선택하세요.

00:05:51.000 --> 00:05:52.000
난 그걸 "DrawTogether"라고 부를 거야...

00:05:52.000 --> 00:05:58.000
...그리고 만들기를 클릭하세요.

00:05:58.000 --> 00:06:00.000
먼저, 나는 우리의 프레임워크를 가져올 것이다.

00:06:00.000 --> 00:06:11.000
다음으로, 나는 GroupActivity 프로토콜을 준수하는 "DrawTogether"라는 새로운 구조를 정의할 것이다.

00:06:11.000 --> 00:06:17.000
GroupActivity 프로토콜에는 구현되어야 하는 두 가지 속성이 있습니다: activityIdentifier와 메타데이터.

00:06:17.000 --> 00:06:20.000
activityIdentifier의 경우, 나는 기본 구현에 의존할 것이다.

00:06:20.000 --> 00:06:23.000
그러나 메타데이터 속성은 여전히 필요하다.

00:06:23.000 --> 00:06:29.000
그럼 그걸 추가하자.

00:06:29.000 --> 00:06:36.000
이 계산된 속성에서 GroupActivityMetadata 객체를 만들고 제목을 설정합니다.

00:06:36.000 --> 00:06:39.000
나는 또한 그 유형을 일반으로 설정했다.

00:06:39.000 --> 00:06:42.000
이것은 맞춤 활동에 매우 중요하다.

00:06:42.000 --> 00:06:48.000
마지막으로, 나는 메타데이터 객체를 반환한다.

00:06:48.000 --> 00:06:53.000
이제 우리가 활동을 구성했으므로, 우리는 여전히 적절한 순간에 그것을 활성화해야 합니다.

00:06:53.000 --> 00:06:57.000
나는 그것을 활성화하기 위해 새로운 버튼을 추가할 것이다 - 그리고 우리의 컨트롤 바보다 더 좋은 장소는 어디인가?

00:06:57.000 --> 00:06:59.000
HStack의 시작 부분에 버튼을 추가하겠습니다.

00:06:59.000 --> 00:07:07.000
버튼의 라벨을 위해, 우리는 SF 기호를 사용하고 있습니다.

00:07:07.000 --> 00:07:14.000
그리고 액션 클로저에서, 우리는 사용자 지정 그룹 활동의 새로운 인스턴스를 만들고 활성화를 호출할 것입니다.

00:07:14.000 --> 00:07:18.000
그리고 그것이 우리의 활동을 활성화하는 데 필요한 전부입니다.

00:07:18.000 --> 00:07:22.000
나는 방금 사용자 지정 그룹 활동을 구성하는 방법과 그것을 활성화하는 방법을 보여주었다.

00:07:22.000 --> 00:07:26.000
이것들은 활동 생성 단계에 필요한 두 부분이다.

00:07:26.000 --> 00:07:31.000
이제, 세션 관리 단계에 대해 알려줄 앵거스에게 넘겨줄게.

00:07:31.000 --> 00:07:32.000
앵거스: 고마워, 윌렘.

00:07:32.000 --> 00:07:38.000
다음으로, 우리는 그룹 활동을 사용하여 애플리케이션에서 사용자 지정 데이터를 보내고 받을 수 있는 방법에 대해 이야기할 것입니다.

00:07:38.000 --> 00:07:44.000
이것은 그룹 활동으로 독특한 SharePlay 경험을 만드는 핵심이다.

00:07:44.000 --> 00:07:56.000
"그룹 활동과 미디어 경험 조정"이라는 제목의 이전 세션에서 세션을 받고, 재생을 준비하고, 세션에 참여하는 세 단계를 숙지해야 합니다.

00:07:56.000 --> 00:08:01.000
재생 동기화 대신, 사용자 지정 경험을 위해 세션을 구성해야 합니다.

00:08:01.000 --> 00:08:07.000
하지만 우리가 그것에 뛰어들기 전에, 그룹 세션을 받고 참여할 수 있는 코드를 추가합시다.

00:08:07.000 --> 00:08:17.000
Xcode로 돌아가서, 우리가 가장 먼저 할 일은 ContentView로 이동하여 GroupActivities를 가져오는 것입니다.

00:08:17.000 --> 00:08:26.000
다음으로, 우리는 GroupSession을 받기 위한 비동기 작업을 만들 것이다.

00:08:26.000 --> 00:08:33.000
이제 우리는 GroupSession을 가지고 있기 때문에, 우리는 그것을 보관할 장소가 필요하다.

00:08:33.000 --> 00:08:40.000
"configureGroupSession"이라고 부르는 새로운 방법을 사용하여 캔버스 객체에 저장합시다.

00:08:40.000 --> 00:08:50.000
이제 캔버스로 이동하여 configureGroupSession 메소드를 구현해 봅시다.

00:08:50.000 --> 00:08:55.000
우리는 맨 위로 가서 GroupActivities를 가져오는 것으로 시작할 것이다.

00:08:55.000 --> 00:09:03.000
파일 하단으로 가서 다음에 새로운 방법을 구현해 봅시다.

00:09:03.000 --> 00:09:13.000
여기서 우리는 우리가 받은 groupSession 객체를 우리 수업의 새로운 속성에 할당했다.

00:09:13.000 --> 00:09:19.000
또한 groupSession 속성을 설정하기 전에 캔버스를 재설정한다는 점에 유의하십시오.

00:09:19.000 --> 00:09:24.000
마지막으로, groupSession에 가입할 코드를 추가해 봅시다.

00:09:24.000 --> 00:09:32.000
이 시점에서, 우리는 프로젝트를 구축하고 컴파일할 수 있어야 한다.

00:09:32.000 --> 00:09:40.000
이제 제품 &gt; 빌드로 이동하여 테스트해 봅시다.

00:09:40.000 --> 00:09:41.000
좋아.

00:09:41.000 --> 00:09:50.000
이제 그룹 세션을 수신하고 참여할 수 있는 코드를 설정했으므로, 애플리케이션에서 사용자 지정 데이터를 보내고 받기 위한 세션을 구성하는 방법을 살펴보겠습니다.

00:09:50.000 --> 00:10:02.000
세션을 구성하기 위해, 우리는 그룹 세션 내의 참가자들에게 원시 데이터 또는 구조화된 메시지를 보내고 받을 수 있는 간단한 API를 제공하는 GroupSessionMessenger를 사용할 것입니다.

00:10:02.000 --> 00:10:07.000
다음으로 GroupSessionMessenger를 사용하는 방법을 살펴봅시다.

00:10:07.000 --> 00:10:12.000
우선, 우리는 그룹세션에서 그룹세션메신저를 만들 것이다.

00:10:12.000 --> 00:10:20.000
GroupSessionMessenger를 사용하는 첫 번째 단계는 애플리케이션의 참가자 간에 어떤 유형의 데이터를 교환해야 하는지 정의하는 것입니다.

00:10:20.000 --> 00:10:27.000
DrawTogether에서, 우리가 다른 장치와 공유해야 하는 특정 데이터는 스트로크 그 자체이다.

00:10:27.000 --> 00:10:33.000
우리는 세 가지 속성으로 획을 나타낼 수 있다: 식별자, 색상, 그리고 좌표점.

00:10:33.000 --> 00:10:38.000
UpsertStrokeMessage가 Codable 프로토콜을 준수하도록 한다는 점에 유의하십시오.

00:10:38.000 --> 00:10:50.000
GroupSessionMessenger를 사용하면 구조화된 메시지를 보내고 받을 수 있으며 메시지가 코딩 가능한 한 직렬화 및 역직렬화를 자동으로 처리하기 때문입니다.

00:10:50.000 --> 00:10:58.000
세션을 구성하는 두 번째 단계는 GroupSessionMessenger의 메시지 API를 사용하여 데이터를 수신하는 것입니다.

00:10:58.000 --> 00:11:02.000
DrawTogether의 경우, 우리는 UpsertStrokeMessages 수신을 처리해야 합니다.

00:11:02.000 --> 00:11:18.000
여기에 표시된 메시지 API는 코드 가능한 유형을 취할 수 있으며 비동기 시퀀스를 반환할 수 있습니다. 이 시퀀스는 해당 유형의 메시지를 포함하는 튜플과 메시지를 둘러싼 컨텍스트를 제공합니다. 여기에는 어떤 참가자가 해당 메시지를 보냈는지와 같은 정보를 포함합니다.

00:11:18.000 --> 00:11:24.000
세션을 구성하는 세 번째 단계는 GroupSessionMessenger에서 보내기 API를 사용하여 데이터를 보내는 것입니다.

00:11:24.000 --> 00:11:30.000
DrawTogether를 위해, 우리는 그룹 내의 모든 참가자들에게 UpsertStrokeMessage를 보낼 것입니다.

00:11:30.000 --> 00:11:33.000
Send API는 비동기 던지기 방법이라는 점에 유의하십시오.

00:11:33.000 --> 00:11:37.000
그것이 던지는 오류는 당신의 지원서에 의해 적절하게 처리되어야 합니다.

00:11:37.000 --> 00:11:41.000
이제 Xcode로 가서 GroupSessionMessenger 코드를 추가합시다.

00:11:41.000 --> 00:11:52.000
우리는 캔버스 소스 파일로 이동하여 그룹 세션에서 GroupSessionMessenger를 만드는 것으로 시작할 것입니다.

00:11:52.000 --> 00:11:57.000
우리는 방금 만든 메신저 객체를 저장할 캔버스에 메신저 속성을 추가할 것입니다.

00:11:57.000 --> 00:12:10.000
다음으로 우리는 참가자들 간에 보내고 받을 UpsertStrokeMessage를 정의해야 합니다.

00:12:10.000 --> 00:12:12.000
이것을 위한 새 파일을 만들어 봅시다.

00:12:12.000 --> 00:12:17.000
우리는 파일 &gt; 신규 &gt; 파일로 이동하여 그것을 할 것입니다...

00:12:17.000 --> 00:12:19.000
스위프트 파일 선택...

00:12:19.000 --> 00:12:22.000
...그리고 그것을 우리의 모델 폴더에 붙이자.

00:12:22.000 --> 00:12:27.000
그리고 그것을 "메시지"라고 부르자.

00:12:27.000 --> 00:12:34.000
이제 UpsertStrokeMessage를 정의하는 코드를 추가해 봅시다.

00:12:34.000 --> 00:12:41.000
이제 GroupSessionMessenger로 보내고 받을 메시지를 정의했으므로, 보내고 받을 코드를 작성해 봅시다.

00:12:41.000 --> 00:12:47.000
우리는 이것을 하기 위해 캔버스로 돌아갈 것이다.

00:12:47.000 --> 00:12:57.000
파일 하단으로 가서 메시지를 받을 코드를 추가합시다.

00:12:57.000 --> 00:13:05.000
여기서, 우리는 비동기 시퀀스에서 UpsertStrokeMessages를 수신하고 메시지를 처리하기 위해 새로운 메서드 핸들을 호출하기 위해 분리된 작업을 만듭니다.

00:13:05.000 --> 00:13:09.000
다음에 그걸 실행하자.

00:13:09.000 --> 00:13:20.000
이 코드에서, 우리는 식별자를 확인하여 이미 스트로크가 있는지 확인하고, 그렇다면, 포인트를 추가합니다.

00:13:20.000 --> 00:13:27.000
그렇지 않으면, 우리는 새로운 스트로크를 만들고, 포인트를 추가하고, 스트로크 배열에 스트로크를 추가합니다.

00:13:27.000 --> 00:13:31.000
다음으로, 우리는 메시지를 보내기 위한 코드를 작성할 것이다.

00:13:31.000 --> 00:13:37.000
우리는 위의 방법으로 넘어갈 것입니다, addPointToActiveStroke.

00:13:37.000 --> 00:13:43.000
멋져!

00:13:43.000 --> 00:13:49.000
이제 앱을 빌드하고 실행하고 공유된 DrawTogether 경험을 실제로 봅시다.

00:13:49.000 --> 00:13:54.000
그래서 나는 내 두 장치로 갈 것이고, 나 자신과 FaceTime 통화를 시작할 것이다.

00:13:54.000 --> 00:13:56.000
전화 앱으로 가서 나 자신에게 전화할게.

00:13:56.000 --> 00:13:59.000
그리고 나서 나는 내 다른 장치에서 대답할 거야.

00:13:59.000 --> 00:14:07.000
마이크를 꺼.

00:14:07.000 --> 00:14:13.000
이제 이 장치에서, 나는 공유 DrawTogether 경험을 시작할 것이다.

00:14:13.000 --> 00:14:16.000
왼쪽 하단 아이콘을 탭하겠습니다.

00:14:16.000 --> 00:14:20.000
그리고 다른 장치에서, 나는 그룹 세션에 참여할 것이다.

00:14:20.000 --> 00:14:25.000
그리고 이제 나는 나 자신과 틱택토를 할 거야.

00:14:25.000 --> 00:14:37.000
내가 먼저 옮길게.

00:14:37.000 --> 00:14:39.000
내가 이긴 것 같아.

00:14:39.000 --> 00:14:42.000
멋지다. 우리 코드가 작동하는 것 같아.

00:14:42.000 --> 00:15:02.000
먼저 메시지를 정의한 다음 메시지를 수신하고 마지막으로 메시지를 보내 GroupSessionMessenger를 사용하여 세션을 구성하는 방법에 대해 이야기했으므로 GroupSessionMessenger를 사용할 때 고려해야 할 몇 가지 다른 사항에 대해 이야기해 봅시다.

00:15:02.000 --> 00:15:11.000
GroupSessionMessenger는 그룹의 모든 활성 참가자에게 신뢰할 수 있고 FIFO가 주문한 메시지 전달을 제공합니다.

00:15:11.000 --> 00:15:17.000
당신이 보내는 메시지에는 제약이 있습니다; 너무 크면, 전송 API에서 오류가 발생합니다.

00:15:17.000 --> 00:15:26.000
GroupSessionMessenger는 더 작은 페이로드를 위한 것이며 파일, 이미지 또는 비디오와 같은 큰 자산을 스트리밍하는 데 사용해서는 안 됩니다.

00:15:26.000 --> 00:15:30.000
메시지를 보낼 때 고려해야 할 또 다른 것은 흐름 제어와 속도 제한이다.

00:15:30.000 --> 00:15:39.000
루프와 같이 빠르게 연속적으로 메시지를 보내면 전송 API에서 오류가 발생할 수 있습니다.

00:15:39.000 --> 00:15:46.000
마지막으로, GroupSessionMessenger와 함께 사용할 메시지를 정의할 때, 애플리케이션 프로토콜에 버전 관리를 추가하는 것을 고려하십시오.

00:15:46.000 --> 00:15:52.000
이를 통해 애플리케이션은 이전 버전의 소프트웨어를 실행하는 장치와의 상호 운용을 지원할 수 있습니다.

00:15:52.000 --> 00:15:59.000
이제 당신이 GroupActivities 경험을 어떻게 연마할 수 있는지에 대해 이야기할 Adam에게 넘겨줄게.

00:15:59.000 --> 00:16:00.000
아담: 고마워, 앵거스!

00:16:00.000 --> 00:16:07.000
이제 앱이 사용자 지정 경험을 위해 필요할 수 있는 몇 가지 마무리 작업에 대해 이야기해 봅시다.

00:16:07.000 --> 00:16:10.000
먼저, 늦은 조이너에 대해 이야기해 봅시다.

00:16:10.000 --> 00:16:15.000
늦은 참여자는 세션이 시작된 후 활동 세션에 참여하는 장치이다.

00:16:15.000 --> 00:16:23.000
적절한 경험을 보장하기 위해, 늦은 조인들은 모든 장치가 동일한 데이터로 작동하도록 최신 정보를 제공해야 합니다.

00:16:23.000 --> 00:16:30.000
이 시나리오에 대한 회계는 일관된 사용자 경험을 보장하는 데 중요하지만, 모두에게 맞는 것은 아니다.

00:16:30.000 --> 00:16:34.000
이 캐치업 프로세스에 필요한 데이터는 앱과 경험에 따라 달라집니다.

00:16:34.000 --> 00:16:38.000
그래서 그것이 DrawTogether 앱에 어떻게 적용되는지 봅시다.

00:16:38.000 --> 00:16:40.000
그룹 세션에 두 개의 장치가 있다고 가정해 봅시다.

00:16:40.000 --> 00:16:46.000
이 두 장치는 같은 정보를 가지고 있다: 캔버스에 그려진 웃는 얼굴.

00:16:46.000 --> 00:16:52.000
그림이 일어났을 때 둘 다 세션에 있었기 때문에 경험 전반에 걸쳐 동일한 데이터를 가지고 있다는 것을 알 수 있습니다.

00:16:52.000 --> 00:16:54.000
이제, 다른 장치를 추가해 봅시다.

00:16:54.000 --> 00:16:59.000
이 시점에서, 새로운 장치는 GroupSession에 가입을 호출하지만, 캔버스에는 아무것도 없다.

00:16:59.000 --> 00:17:04.000
그래서 우리는 구름을 그리고 -- 오, 그건 -- 그건 좋지 않아!

00:17:04.000 --> 00:17:09.000
새로운 장치에는 사전 맥락이 없었기 때문에, 우리의 웃는 얼굴은 이제 구름이 있다.

00:17:09.000 --> 00:17:11.000
이제 돌아가서 다시 해보자.

00:17:11.000 --> 00:17:17.000
새로운 장치가 가입하자마자 웃는 얼굴 쇼를 가질 수 있도록 이것을 어떻게 고칠 수 있을까요?

00:17:17.000 --> 00:17:27.000
새 장치가 그룹 세션에 가입하면, 그룹 세션에 가입한 다른 모든 장치는 GroupSession fire에서 활성 참가자 속성을 볼 수 있습니다.

00:17:27.000 --> 00:17:34.000
그 신호를 관찰하는 장치는 캐치업 데이터(이 경우 기존 드로잉 캔버스)를 새로 연결된 장치로 보낼 것이다.

00:17:34.000 --> 00:17:40.000
이제 새로운 장치가 연결되면, 이미 웃는 얼굴이 있다는 것을 알 수 있으므로 우리는 그 주위를 그릴 수 있습니다!

00:17:40.000 --> 00:17:43.000
그래서 이제, 우리는 이것을 코드로 어떻게 하나요?

00:17:43.000 --> 00:17:48.000
우리가 해야 할 첫 번째 일은 앱이 캐치업 메시지에서 어떤 데이터를 전송해야 하는지 이해하는 것이다.

00:17:48.000 --> 00:18:01.000
우리는 DrawTogether 경험이고 우리의 목표는 캔버스가 모든 사람의 장치에서 동일하도록 하는 것이기 때문에, "CanvasMessage"라는 Message.swift 파일에 새로운 메시지를 만들어 봅시다.

00:18:01.000 --> 00:18:11.000
이 구조체는 우리가 가지고 있는 모든 획과 어떤 메시지가 가장 최신인지 계산하기 위한 휴리스틱으로 사용될 "pointCount"라고 부를 변수를 포함할 것이다.

00:18:11.000 --> 00:18:12.000
멋져!

00:18:12.000 --> 00:18:15.000
이제, 이 메시지를 받는 것을 어떻게 처리해야 하나요?

00:18:15.000 --> 00:18:27.000
Canvas.swift에서 캔버스 모델로 넘어가면, Angus가 이전에 보여준 것처럼 GroupSessionMessenger를 사용하여 configureGroupSession에서 메시지 핸들러를 설정할 수 있습니다.

00:18:27.000 --> 00:18:39.000
여기에서, 당신은 우리가 핸들 기능을 호출하는 것을 볼 수 있으므로, 계속해서 그것을 구현합시다.

00:18:39.000 --> 00:18:49.000
이 코드에서, 당신은 우리가 현재 가지고 있는 것보다 더 새로운 캐치업 메시지만 받아들이기 위해 pointCount 휴리스틱을 경계한다는 것을 알 수 있습니다.

00:18:49.000 --> 00:18:56.000
그것이 통과되면, 우리는 catchupMessage의 스트로크로 캔버스의 스트로크를 재정의합니다.

00:18:56.000 --> 00:19:05.000
이제, 우리가 앞서 논의했듯이, 우리는 우리가 소통해야 할 새로운 참가자가 있는지 알아내기 위해 활동적인 참가자들이 바뀌는 것을 들어야 한다.

00:19:05.000 --> 00:19:12.000
그럼 가서 그것을 configureGroupSession 기능에 추가해 봅시다.

00:19:12.000 --> 00:19:21.000
이 핸들러에서, 당신은 우리가 새로운 활성 참가자와 오래된 활성 참가자 사이의 델타를 잡는 것을 볼 수 있습니다.

00:19:21.000 --> 00:19:26.000
이것은 우리가 새로 합류한 참가자들에게만 따라잡기 메시지를 보낼 수 있도록 보장한다.

00:19:26.000 --> 00:19:27.000
좋아!

00:19:27.000 --> 00:19:31.000
이제 우리는 그냥 메시지를 형성하고 보낸다.

00:19:31.000 --> 00:19:40.000
이 메시지에는 현재 캔버스 상태가 포함되어 있으며 새로운 참가자에게만 보낼 것입니다.

00:19:40.000 --> 00:19:41.000
그리고 그게 다야!

00:19:41.000 --> 00:19:43.000
그건 따라잡기야!

00:19:43.000 --> 00:19:51.000
그래서, 이제 우리는 특정 활동을 위해 그룹 세션을 진행하기 위한 모든 부분을 제자리에 두었으니, 우리가 활동을 완전히 바꾸면 어떻게 해야 할까요?

00:19:51.000 --> 00:19:57.000
이것은 드로잉 캔버스를 바꾸거나 영화를 바꾸는 것과 같은 것일 수 있다.

00:19:57.000 --> 00:20:06.000
우리의 API는 활동을 변경하는 두 가지 방법을 제공합니다: 새 그룹 세션을 만들거나 기존 그룹 세션의 모든 사람을 위한 활동을 업데이트할 수 있습니다.

00:20:06.000 --> 00:20:10.000
그럼, 그 둘에 대해 이야기해 봅시다.

00:20:10.000 --> 00:20:19.000
콘텐츠를 변경하는 첫 번째이자 선호되는 방법은 그룹 세션을 시작한 동일한 API를 호출하는 것입니다: prepareForActivation on GroupActivity.

00:20:19.000 --> 00:20:34.000
이 접근 방식은 GroupSession의 입구와 출구에 대한 깨끗한 장벽을 제공하기 때문에 참가자 간의 일관된 상태에 대해 더 쉽게 추론할 수 있으므로 이전 GroupSession에서 필요하지 않은 느린 상태나 메시지에 대해 걱정할 필요가 없습니다.

00:20:34.000 --> 00:20:42.000
이것은 사용자가 새로운 메모나 영화를 검색하는 것과 같은 다음 것을 찾기 위해 활동에서 물러날 때 매우 유용합니다.

00:20:42.000 --> 00:20:48.000
이것은 또한 시스템에 사용자에게 알리는 데 사용될 주요 변화의 표시를 제공한다.

00:20:48.000 --> 00:20:58.000
이 통화 후, 그룹 세션을 시작하는 것과 같은 방식으로, GroupActivity의 세션 비동기 시퀀스를 통해 새로운 GroupSession을 받게 됩니다.

00:20:58.000 --> 00:21:05.000
이제, 당신의 애플리케이션에 여러 곡이 서로 재생되는 것과 같이 전환할 활동 목록이 있다면 어떨까요?

00:21:05.000 --> 00:21:14.000
우리의 GroupSession API는 GroupSession에서 활동 속성을 설정하기만 하면 모든 사람을 위한 업데이트를 트리거할 수 있는 간단한 방법을 제공합니다.

00:21:14.000 --> 00:21:17.000
거기에서, 당신은 활동 속성 변경을 듣습니다.

00:21:17.000 --> 00:21:24.000
우리의 API는 장치가 항상 동일한 활동에 수렴되도록 보장하므로 걱정할 필요가 없습니다.

00:21:24.000 --> 00:21:29.000
이제 우리가 그 둘을 개념적으로 이해했으니, DrawTogether 앱에 어떤 것을 사용해야 할까요?

00:21:29.000 --> 00:21:35.000
우리 앱은 각각의 새로운 드로잉 캔버스에 깨끗한 슬레이트를 원하기 때문에, 새로운 세션 API는 우리가 원하는 것을 정확히 제공할 것이다.

00:21:35.000 --> 00:21:40.000
이제 Xcode로 가서 그것을 구현하는 방법을 봅시다.

00:21:40.000 --> 00:21:44.000
여기서 첫 번째 단계는 새로운 세션을 어떻게 촉발할지 결정하는 것이다.

00:21:44.000 --> 00:21:51.000
우리의 경우, 고객이 재설정 버튼을 사용할 때, 우리는 계속해서 새로운 GroupSession을 만들 수 있도록 합시다.

00:21:51.000 --> 00:22:00.000
ControlBar 코드를 보면, 로컬 상태를 재설정하기 위해 캔버스 모델을 호출하는 캡슐버튼이 이미 있다는 것을 알 수 있습니다.

00:22:00.000 --> 00:22:06.000
그러니 계속해서 그 기능을 수정하여 GroupSession을 무너뜨리고 새로운 것을 만들어 봅시다.

00:22:06.000 --> 00:22:19.000
이 코드에서, 우리는 GroupSession에 대한 모든 작업과 취소 가능한 작업을 취소할 것입니다.

00:22:19.000 --> 00:22:27.000
우리는 또한 GroupSession이 있는지 확인할 것입니다. 그리고 만약 있다면, 그것을 남겨두고 DrawTogether 유형의 활성화 속성을 호출하십시오.

00:22:27.000 --> 00:22:32.000
거기서부터, 그룹세션을 받기 위한 우리의 정상적인 흐름이 일어날 것이고, 우리는 갈 수 있습니다!

00:22:32.000 --> 00:22:38.000
우리는 이제 새로운 캔버스로 전환할 수 있는 깨끗한 방법을 가지고 있다.

00:22:38.000 --> 00:22:44.000
이제, 사용자에게 친구들과 SharePlay 경험을 시도할 수 있다는 것을 나타내기 위해 UI를 변경하고 싶다면 어떨까요?

00:22:44.000 --> 00:22:55.000
예를 들어, 드로잉 앱에서, 우리는 캔버스가 이것에서 이것으로 바뀌기를 원합니다. 여기서 GroupSession을 받을 자격이 있을 때, 이제 캔버스를 공유할 수 있는 버튼을 보여준다는 것을 알 수 있습니다.

00:22:55.000 --> 00:22:58.000
그래서 우리는 이걸 어떻게 해?

00:22:58.000 --> 00:23:05.000
GroupStateObserver API를 사용하면 게시자의 말을 듣고 장치가 언제 그룹 세션을 받을 수 있는지 알 수 있습니다.

00:23:05.000 --> 00:23:09.000
그런 다음 이것을 사용하여 버튼을 동적으로 표시하고 숨길 수 있습니다.

00:23:09.000 --> 00:23:14.000
그러니 가서 실행하자!

00:23:14.000 --> 00:23:18.000
우리가 본 것처럼, 우리는 응용 프로그램의 왼쪽 하단에 작은 버튼을 원한다.

00:23:18.000 --> 00:23:30.000
우리 애플리케이션에는 이미 ControlBar 보기에 공유 버튼이 있기 때문에, GroupStateObserver를 기반으로 버튼을 표시하고 숨기기 위해 동작을 변경합시다.

00:23:30.000 --> 00:23:34.000
먼저 우리는 계속해서 우리의 groupStateObserver를 우리의 관점에 추가한다.

00:23:34.000 --> 00:23:51.000
이제 우리가 그룹세션을 받을 자격이 있고 이미 이 그룹세션에 있지 않은 경우에만 보여주기 위해 캡슐버튼을 둘러싸자.

00:23:51.000 --> 00:23:52.000
그리고 그게 다야!

00:23:52.000 --> 00:23:57.000
우리의 버튼은 이제 사용자에게 도움이 될 때만 동적으로 표시됩니다.

00:23:57.000 --> 00:24:01.000
이제 우리가 이 세션에서 본 것을 살펴봅시다.

00:24:01.000 --> 00:24:10.000
우리는 간단한 드로잉 앱을 만드는 전체 과정을 거친 다음 그룹 활동을 활용하여 이전과 같이 동기화되고 연결되도록 변경했습니다.

00:24:10.000 --> 00:24:20.000
하지만 더 중요한 것은, 우리는 당신이 창의력을 완전히 발휘하고 그룹 활동으로 사용자 지정 SharePlay 경험을 만드는 데 필요한 모든 단계를 거쳤다는 것입니다.

00:24:20.000 --> 00:24:36.000
우리는 일반 유형으로 사용자 지정 활동을 만들고, 동기화된 통신을 위해 GroupSession과 GroupSessionMessenger를 구성하고 활용하고, 앱이 진정으로 풍부한 사용자 경험을 만들기 위해 채택해야 하는 엣지 케이스와 API에 대해 이야기했습니다.

00:24:36.000 --> 00:24:43.000
나는 당신이 우리와 함께 이 맞춤형 경험을 만드는 것을 즐겼기를 바라며, 우리는 그룹 활동 프레임워크로 당신의 창의력이 발휘되는 것을 기대합니다!

00:24:43.000 --> 00:24:53.000
그룹 활동에 대해 배우는 동안 다음 단계는 "그룹 활동을 위한 디자인" 세션이어야 하며, 아직 보지 못했다면, "그룹 활동으로 미디어 경험 구축" 세션도 확인하세요.

00:24:53.000 --> 00:24:56.000
질문이 있으시면, 그룹 활동 연구실에서 우리를 찾아주세요.

00:24:56.000 --> 00:25:00.000
그리고 마지막으로, 시청해 주셔서 감사드리며 멋진 WWDC를 보내십시오.

00:25:00.000 --> 00:25:02.000
우리는 네가 뭘 만드는지 빨리 보고 싶어!

00:25:02.000 --> 23:59:59.000
♪

