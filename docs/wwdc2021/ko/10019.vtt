WEBVTT

00:00:02.000 --> 00:00:12.000
안녕하세요, "SwiftUI에서 동시성 발견"에 오신 것을 환영합니다.

00:00:12.000 --> 00:00:15.000
저는 SwiftUI 팀의 엔지니어인 Curt Clifton입니다.

00:00:15.000 --> 00:00:18.000
나중에, 나는 내 동료 제시카와 합류할 것이다.

00:00:18.000 --> 00:00:24.000
스위프트 5.5는 스위프트 코드에서 동시성을 관리하기 위한 다양한 새로운 도구를 소개합니다.

00:00:24.000 --> 00:00:32.000
이 강연에서 제시카와 저는 이러한 개선 사항이 SwiftUI 앱과 어떻게 상호 작용하는지 이해하는 데 도움을 줄 것입니다.

00:00:32.000 --> 00:00:40.000
새로운 도구가 데이터 모델을 더 좋게 만드는 데 어떻게 도움이 될 수 있는지 살펴보고 SwiftUI가 새로운 주요 배우와 어떻게 작동하는지 보여드리겠습니다.

00:00:40.000 --> 00:00:52.000
그런 다음 제시카는 동시 데이터 모델을 SwiftUI 뷰에 연결하는 방법을 보여주고 Swift의 새로운 동시성 도구를 활용하는 훌륭한 새로운 API를 소개합니다.

00:00:52.000 --> 00:00:59.000
제시카와 내가 공유할 정보를 최대한 활용하려면, 스위프트의 새로운 동시성 지원에 대한 배경 지식을 갖는 것이 중요하다.

00:00:59.000 --> 00:01:09.000
이 비디오의 나머지 부분에 뛰어들기 전에 "Meet async/await in Swift"와 "Explore structured concurrency in Swift"를 보는 것이 좋습니다.

00:01:09.000 --> 00:01:12.000
내가 어렸을 때, 나는 항상 우주비행사가 되는 것을 꿈꿨다.

00:01:12.000 --> 00:01:17.000
나는 가끔 우주선에서 일하지만, 그렇지 않으면 그 특별한 어린 시절의 꿈은 이루어지지 않았다.

00:01:17.000 --> 00:01:21.000
여전히, 나는 우주에 대한 열정을 잃지 않았다.

00:01:21.000 --> 00:01:27.000
그래서 저는 SwiftUI 엔지니어로서의 실제 기술을 적용하여 공간 관련 사진을 다운로드할 수 있는 앱을 만들기로 결정했습니다.

00:01:27.000 --> 00:01:31.000
내가 계획한 앱을 살펴보자.

00:01:31.000 --> 00:01:33.000
그 앱은 무작위 우주 사진 목록을 보여준다.

00:01:33.000 --> 00:01:35.000
이 색깔들은 정말 아름다워.

00:01:35.000 --> 00:01:40.000
내가 정말 좋아하는 사진을 보면, 나중에 볼 수 있도록 저장할 수 있다.

00:01:40.000 --> 00:01:47.000
이 아름다운 이미지를 가져오기 위해, 내 앱은 REST API를 사용하여 웹 서비스와 상호 작용할 것이다.

00:01:47.000 --> 00:01:52.000
이것은 스위프트에 도입된 새로운 동시성 기능을 완벽하게 사용하는 것처럼 들린다.

00:01:52.000 --> 00:01:55.000
데이터 모델부터 시작합시다.

00:01:55.000 --> 00:02:00.000
저는 단일 이미지에 대한 정보를 보관하기 위해 SpacePhoto 구조를 사용하고 있습니다.

00:02:00.000 --> 00:02:12.000
구조체에는 제목, 사진 설명, 이미지가 게시된 날짜, 실제 이미지를 가리키는 URL과 같은 필드가 있습니다.

00:02:12.000 --> 00:02:24.000
서버 응답에서 인스턴스를 쉽게 인스턴스화하거나 디스크에 저장할 수 있도록 내 유형을 Codable으로 만들었고, ForEach 및 기타 데이터 기반 보기에서 사용할 수 있도록 식별할 수 있습니다.

00:02:24.000 --> 00:02:27.000
다음으로, 저는 이 항목들의 목록을 표시하고 싶습니다.

00:02:27.000 --> 00:02:32.000
그것을 위해, 나는 그것들을 가져오고 보관할 모델이 필요하다.

00:02:32.000 --> 00:02:36.000
나는 이것을 위해 사진 수업을 사용하고 있어.

00:02:36.000 --> 00:02:45.000
내 사진 클래스가 ObservableObject를 준수하도록 함으로써, 내 SwiftUI 뷰는 내 데이터가 업데이트될 때마다 자동으로 업데이트됩니다.

00:02:45.000 --> 00:02:51.000
저는 SpacePhotos 배열을 저장하기 위해 게시된 속성을 사용하고 있습니다.

00:02:51.000 --> 00:02:56.000
REST 엔드포인트에서 업데이트된 항목을 가져오기 위해, 저는 항목 업데이트 방법을 사용하고 있습니다.

00:02:56.000 --> 00:02:59.000
나는 그것에 대해 더 자세히 곧 이야기할 것이다.

00:02:59.000 --> 00:03:03.000
하지만 먼저 저는 기본적인 사용자 인터페이스를 거칠게 하고 싶습니다.

00:03:03.000 --> 00:03:06.000
이것은 내가 만들고 싶은 사용자 인터페이스이다.

00:03:06.000 --> 00:03:13.000
지금까지, 나는 탭 뷰와 기본 포토뷰를 가지고 있다.

00:03:13.000 --> 00:03:17.000
내 포토뷰는 우주 사진을 찍고 제목을 표시한다.

00:03:17.000 --> 00:03:21.000
그것은 내 데이터 모델이 작동하는 것을 볼 수 있을 만큼 충분한 배관이다.

00:03:21.000 --> 00:03:24.000
다음에 카탈로그 보기를 봅시다.

00:03:24.000 --> 00:03:27.000
내 카탈로그 보기는 사진 목록을 보여줄 것이다.

00:03:27.000 --> 00:03:34.000
그렇게 하기 위해, 나는 상태 객체를 추가하고 내 사진 관찰 가능한 객체로 인스턴스화할 것이다.

00:03:34.000 --> 00:03:38.000
내 보기의 본문에서, 나는 NavigationView를 추가할 것이다.

00:03:38.000 --> 00:03:43.000
여기서 내비게이션 보기를 사용하면 곧 큰 내비게이션 제목을 추가할 수 있습니다.

00:03:43.000 --> 00:03:47.000
다음으로, 내 NavigationView 안에 목록을 추가할 것이다.

00:03:47.000 --> 00:03:56.000
그리고 내 목록 안에, 나는 ForEach를 사용하여 내 사진 위에 매핑하고, 그들 각각에 대한 PhotoView를 보여줄 것이다.

00:03:56.000 --> 00:04:00.000
그것으로, 나는 내 샘플 데이터를 볼 수 있다.

00:04:00.000 --> 00:04:05.000
그것은 내가 지금 가야 할 만큼이지만, 여기에 조금 더 광택을 더 넣자.

00:04:05.000 --> 00:04:08.000
먼저, 여기 약속된 내비게이션 제목이 있습니다.

00:04:08.000 --> 00:04:21.000
이제, 여기의 기본 삽입 목록 스타일은 멋져 보이지만, 내 우주 사진을 과시하기 위해, 사진이 검은색 배경에 정말 튀어나올 수 있도록 일반 스타일로 전환하고 싶습니다.

00:04:21.000 --> 00:04:27.000
여기서 새로운 열거형과 같은 정적 멤버 구문을 사용하여 목록 스타일을 평범하게 만들 수 있습니다.

00:04:27.000 --> 00:04:36.000
이 구문으로, SwiftUI의 스타일 수정자는 Xcode 13에서 자동 완성을 더 잘 지원하여 더 간결한 철자를 얻는다.

00:04:36.000 --> 00:04:43.000
마지막으로, 올해 SwiftUI의 또 다른 새로운 기능을 사용하겠습니다: 목록 구분 기호 제어.

00:04:43.000 --> 00:04:50.000
내 ForEach 안에서, 나는 listRowSeparator 수정자를 사용하여 구분 기호를 숨길 수 있다.

00:04:50.000 --> 00:04:55.000
가끔 SwiftUI로 사용자 인터페이스를 연마할 때, 나는 멈추기가 어렵다는 것을 알게 된다.

00:04:55.000 --> 00:04:57.000
하지만 지금은 UI를 떠날 거야.

00:04:57.000 --> 00:05:01.000
제시카는 내가 데이터 모델을 끝낸 후에 그것을 끝낼 계획이다.

00:05:01.000 --> 00:05:09.000
하지만 데이터 모델을 파고들기 전에, SwiftUI가 관찰 가능한 객체와 어떻게 상호 작용하는지에 대해 조금 이야기하고 싶습니다.

00:05:09.000 --> 00:05:16.000
그리고 스위프트 5.5의 새로운 동시성 기능이 이 상호 작용을 그 어느 때보다 쉽게 만드는 방법.

00:05:16.000 --> 00:05:25.000
Dub Dub 2020에서 "SwiftUI의 Data Essentials"에서 제 동료 Raj는 SwiftUI 업데이트 수명 주기에 대해 이야기했습니다.

00:05:25.000 --> 00:05:33.000
나는 이 수명 주기를 구동하는 코드를 "실행 루프"라고 부를 것이다. 스위프트 5.5를 사용하면, 런 루프는 주요 배우에서 실행된다.

00:05:33.000 --> 00:05:44.000
일반적으로 배우에 대한 자세한 내용은 "스위프트 배우와 함께 가변 상태를 보호하세요"라는 강연을 확인하세요. 제시카와 나는 이 강연에서 주연 배우에게 집중할 것이다.

00:05:44.000 --> 00:05:51.000
SwiftUI 실행 루프는 사용자로부터 이벤트를 수신하고, 모델을 업데이트한 다음, SwiftUI 뷰를 화면으로 렌더링합니다.

00:05:51.000 --> 00:06:01.000
나는 이 업데이트를 "런 루프의 틱"이라고 부르는 것을 좋아한다. 여러 틱을 연속으로 볼 수 있도록 이 루프를 풀자.

00:06:01.000 --> 00:06:07.000
SwiftUI에서 ObservableObjects는 몇 가지 흥미로운 방식으로 SwiftUI 실행 루프와 상호 작용할 수 있다.

00:06:07.000 --> 00:06:12.000
Photos ObservableObject로 돌아가서 updateItems 방법을 살펴봅시다.

00:06:12.000 --> 00:06:17.000
나는 내 SwiftUI 뷰에서 updateItems를 호출할 것이고 그것은 주요 배우에서 실행될 것이다.

00:06:17.000 --> 00:06:23.000
이 파란색 사각형을 사용하여 updateItems가 실행되는 시간을 보여드리겠습니다.

00:06:23.000 --> 00:06:29.000
가져온 사진을 내 "항목" 속성에 할당하는 이 코드 줄에 집중하고 싶습니다.

00:06:29.000 --> 00:06:46.000
"항목"은 게시된 속성이기 때문에, 이 할당은 objectWillChange 이벤트를 트리거하고, 즉시 가져온 사진을 "항목"의 저장소에 기록합니다. SwiftUI가 이 objectWillChange를 볼 때, 내 항목의 스냅샷을 찍는다.

00:06:46.000 --> 00:06:53.000
스냅샷 후 실행 루프의 다음 틱에서 SwiftUI는 스냅샷을 현재 값과 비교합니다.

00:06:53.000 --> 00:06:59.000
이러한 값이 다르기 때문에, SwiftUI는 사진에 의존하는 내 견해를 업데이트하는 것을 알고 있다.

00:06:59.000 --> 00:07:09.000
objectWillChange, 스토리지 업데이트 및 실행 루프 틱은 모두 메인 액터에서 발생하기 때문에 순서대로 발생하도록 보장됩니다.

00:07:09.000 --> 00:07:17.000
2020년 "데이터 에센셜" 강연에서, 라지는 당신의 견해가 신체에서 너무 많은 일을 할 때 느린 업데이트를 설명합니다.

00:07:17.000 --> 00:07:24.000
모델 코드가 메인 액터에서 너무 많은 작업을 하는 경우에도 느린 업데이트가 발생할 수 있습니다.

00:07:24.000 --> 00:07:33.000
예를 들어, 다운로드가 완료되기를 기다리는 동안 fetchPhotos 기능이 차단되고 연결이 느리다고 가정해 봅시다.

00:07:33.000 --> 00:07:38.000
내가 주연 배우를 막고 있기 때문에, 나는 이 런 루프의 틱이 그리워.

00:07:38.000 --> 00:07:42.000
이것은 내 사용자들에게 차질로 보인다.

00:07:42.000 --> 00:07:51.000
과거에는 작업을 수행하기 위해 다른 대기열로 파견했을 수도 있으므로, 값비싼 fetchPhotos가 메인 스레드에서 발생합니다.

00:07:51.000 --> 00:07:56.000
이것은 잘 작동하는 것처럼 보일지 모르지만, 나는 여기서 까다로운 문제가 있다.

00:07:56.000 --> 00:08:00.000
나는 주요 배우에서 ObservableObject를 바꾸고 있다.

00:08:00.000 --> 00:08:04.000
내 변화와 런 루프 틱이 인터리브할 수 있다.

00:08:04.000 --> 00:08:15.000
예를 들어, "항목"에 할당하고 SwiftUI가 objectWillChange 스냅샷을 찍을 때, 실행 루프의 체크 표시 직전에 발생할 수 있습니다.

00:08:15.000 --> 00:08:23.000
상태 변경은 아직 일어나지 않았기 때문에, SwiftUI는 스냅샷을 변경되지 않은 값과 비교합니다.

00:08:23.000 --> 00:08:31.000
실제 상태 변경은 실행 루프 틱 후에 발생하지만, SwiftUI는 그 변화를 볼 수 없기 때문에 내 견해는 업데이트되지 않는다.

00:08:31.000 --> 00:08:44.000
올바르게 업데이트하려면, SwiftUI는 이러한 이벤트가 순서대로 발생해야 합니다: objectWillChange, ObservableObject의 상태가 업데이트되고, 실행 루프가 다음 틱에 도달합니다.

00:08:44.000 --> 00:08:49.000
만약 내가 이 모든 것이 주연 배우에게 일어나도록 보장할 수 있다면, 나는 이 주문을 보장할 수 있다.

00:08:49.000 --> 00:08:57.000
스위프트 5.5 이전에, 나는 내 상태를 업데이트하기 위해 메인 대기열로 다시 파견했을 수도 있지만, 지금은 훨씬 쉬워졌다.

00:08:57.000 --> 00:08:59.000
그냥 기다려!

00:08:59.000 --> 00:09:08.000
메인 액터로부터 비동기 전화를 걸기 위해 await를 사용함으로써, 나는 비동기 작업이 일어나는 동안 메인 액터에 대한 다른 작업을 계속하도록 했다.

00:09:08.000 --> 00:09:13.000
이것은 주연 배우를 "양보"라고 부른다.

00:09:13.000 --> 00:09:24.000
updateItems에서, 나는 장기 실행 I/O 동안 메인 액터가 SwiftUI로 돌아오기 위해 await를 사용할 수 있으므로, 실행 루프를 똑딱거리게 유지하고 UI 문제를 피할 수 있다.

00:09:24.000 --> 00:09:33.000
비동기 작업이 완료되면, 스위프트는 내 updateItems 메소드를 메인 액터에 다시 입력하여 내 상태를 업데이트할 수 있습니다.

00:09:33.000 --> 00:09:35.000
이게 어떻게 작동하는지 보자.

00:09:35.000 --> 00:09:41.000
다른 대기열로 파견하는 대신, 나는 단순히 장기 실행 작업의 결과를 기다린다.

00:09:41.000 --> 00:09:49.000
내가 wait를 쓸 때, updateItems 함수는 실행 루프가 계속될 수 있도록 메인 액터의 제어를 제공한다.

00:09:49.000 --> 00:10:04.000
기다리던 가져오기가 완료되면, 주요 액터는 내 기능을 다시 입력하여 게시된 속성을 안전하게 업데이트하고, objectWillChange를 트리거하고, SwiftUI에서 새로운 값을 사용할 수 있도록 합니다.

00:10:04.000 --> 00:10:09.000
Xcode로 들어가서 내가 가져오기를 할 수 있는지 보자.

00:10:09.000 --> 00:10:12.000
여기 제가 슬라이드에서 보여준 updateItems 방법이 있습니다.

00:10:12.000 --> 00:10:17.000
fetchPhotos를 구현하려면, 한 장의 사진을 가져오는 코드를 추가하는 것으로 시작합시다.

00:10:17.000 --> 00:10:27.000
나는 내 fetchPhoto 방법으로 나머지 엔드포인트에서 사진의 URL을 가져와 SpacePhoto를 반환하도록 할 것이다.

00:10:27.000 --> 00:10:35.000
다음으로, URLSession에서 데이터 편의성의 새로운 비동기 버전을 사용하여 URL에서 데이터를 가져올 것입니다.

00:10:35.000 --> 00:10:54.000
이것을 스텁에 넣기 위해, 나는 강제 시도를 사용하고 있다.

00:10:54.000 --> 00:11:01.000
내가 곧 치울게.

00:11:01.000 --> 00:11:07.000
아, 데이터 방법은 비동기이기 때문에, 나는 await를 사용해야 해.

00:11:07.000 --> 00:11:13.000
그리고 그것은 내가 fetchPhoto 메소드를 비동기적으로 만들어야 한다는 것을 의미한다.

00:11:13.000 --> 00:11:14.000
그래, 좋아.

00:11:14.000 --> 00:11:19.000
이제 내 데이터가 있으니, 데코딩 가능한 이니셜라이저를 사용하여 사진을 인스턴스화하고 반환할 것이다.

00:11:19.000 --> 00:11:30.000
다음에 fetchPhotos를 봅시다.

00:11:30.000 --> 00:11:34.000
나는 무작위로 날짜를 선택하고 그것들을 반복하기 위해 몇 가지 코드를 찔렀다.

00:11:34.000 --> 00:11:43.000
배열을 만들고 싶기 때문에, var를 "다운로드"하고 루프에 날짜 변수를 추가할 것입니다.

00:11:43.000 --> 00:11:59.000
루프 내부에서, 나는 이미 특정 날짜를 가져오기 위해 나머지 엔드포인트 URL을 구성해야 하는 도우미 메소드를 호출할 것이다.

00:11:59.000 --> 00:12:03.000
그런 다음, 나는 fetchPhoto 메소드를 호출하고 결과를 내 배열에 추가할 것이다.

00:12:03.000 --> 00:12:16.000
그리고 짓자.

00:12:16.000 --> 00:12:23.000
아, fetchPhoto는 비동기이기 때문에, 나는 결과를 기다려야 해.

00:12:23.000 --> 00:12:27.000
그리고 그것은 fetchPhotos도 비동기여야 한다는 것을 의미한다.

00:12:27.000 --> 00:12:31.000
나는 단순함을 위해 사진을 순차적으로 가져오기 위해 이러한 호출을 하고 있다.

00:12:31.000 --> 00:12:37.000
더 강력한 옵션을 위해 Swift 5.5의 작업 그룹을 확인하세요.

00:12:37.000 --> 00:12:43.000
이제, 나는 슬라이드에서 보여준 것처럼 사진을 가져오기를 기다려야 한다.

00:12:43.000 --> 00:12:47.000
그리고 그것으로, 내 업데이트 논리가 제자리에 있다.

00:12:47.000 --> 00:12:52.000
이제, 아마도 당신은 가져오기를 실현하기 위한 이러한 강제적인 시도에 대해 나만큼 긴장하고 있을 것입니다.

00:12:52.000 --> 00:12:53.000
그거 치우자.

00:12:53.000 --> 00:12:56.000
지금은 다운로드가 실패하면 nil을 돌려줄게.

00:12:56.000 --> 00:13:20.000
그런 다음 fetchPhotos에서, 나는 내 배열에 nil이 아닌 값만 추가할 것이다.

00:13:20.000 --> 00:13:30.000
이제 Photos가 async-await를 사용하므로, 메인 액터에서 실행되는 한, 내가 논의한 까다로운 objectWillChange 버그에 부딪히지 않을 것이라고 확신할 수 있습니다.

00:13:30.000 --> 00:13:32.000
하지만 내가 그걸 어떻게 보장할 수 있을까?

00:13:32.000 --> 00:13:35.000
운 좋게도, 스위프트 컴파일러가 여기서 나를 도울 수 있다.

00:13:35.000 --> 00:13:46.000
사진에 새로운 @MainActor 주석을 추가함으로써, 컴파일러는 사진의 속성과 방법이 주요 행위자에서만 액세스할 수 있도록 보장할 것입니다.

00:13:46.000 --> 00:13:49.000
그렇게 하면, 그 모델은 제자리에 있다.

00:13:49.000 --> 00:13:58.000
다음으로, 제시카는 우리의 견해를 모델에 연결하고 앱에서 동시성을 활용하기 위한 훌륭한 새로운 SwiftUI API를 보여줄 것입니다.

00:13:58.000 --> 00:14:00.000
제시카?

00:14:00.000 --> 00:14:01.000
고마워, 커트.

00:14:01.000 --> 00:14:09.000
CatalogView로 전환하고 Curt가 방금 보여준 updateItems 방법을 사용합시다.

00:14:09.000 --> 00:14:13.000
카탈로그가 표시될 때마다 updateItems에 전화하고 싶습니다.

00:14:13.000 --> 00:14:20.000
과거에는 onAppear를 사용했을 수도 있지만, 올해 SwiftUI에서 작업 수정자를 사용하세요.

00:14:20.000 --> 00:14:24.000
작업을 사용하면 비동기 작업을 뷰와 연결할 수 있습니다.

00:14:24.000 --> 00:14:27.000
그 작업은 뷰의 일생의 시작 부분에서 시작된다.

00:14:27.000 --> 00:14:42.000
작업은 기본적으로 비동기이므로, 클로저 내에서 myPhotos 객체에서 updateItems를 호출하고 결과를 기다릴 수 있습니다.

00:14:42.000 --> 00:14:46.000
이것은 작업의 훌륭한 사용이지만, 이 새로운 수정자에게는 훨씬 더 많은 것이 있다.

00:14:46.000 --> 00:14:54.000
작업의 수명은 뷰의 수명과 관련이 있으므로, 비동기 시퀀스를 기다리고 그 값에 응답하는 것과 같은 일을 할 수 있습니다.

00:14:54.000 --> 00:14:58.000
그리고 그 작업은 보기의 수명이 끝나면 자동으로 취소될 것이다.

00:14:58.000 --> 00:15:08.000
평생 보기에 대한 자세한 내용은 "SwiftUI의 신비화" 강연을 확인하세요. 라이브 미리보기를 사용하면 항목이 업데이트되는 것을 볼 수 있습니다.

00:15:08.000 --> 00:15:10.000
하지만 우리는 여전히 아름다운 이미지를 놓치고 있다.

00:15:10.000 --> 00:15:15.000
나는 이미 커트가 이전에 보여준 포토뷰를 업데이트하고 있다.

00:15:15.000 --> 00:15:18.000
제목 뒤에 배경 자료를 추가하겠습니다.

00:15:18.000 --> 00:15:20.000
이제, 이미지를 추가해 봅시다.

00:15:20.000 --> 00:15:27.000
다행히도, 새로운 AsyncImage API를 사용하여 원격 서버에서 이미지를 로드하는 것이 그 어느 때보다 쉬워졌습니다.

00:15:27.000 --> 00:15:34.000
항목에서 가져오고 싶은 이미지 URL을 가져와서 AsyncImage에 전달하기만 하면 됩니다.

00:15:34.000 --> 00:16:00.000
음, 이것은 전체 크기로 조금 너무 크므로, 사용자가 이미지가 로드되고 있다는 것을 알 수 있도록 이미지를 조정하고 자리 표시자를 표시할 수 있는 AsyncImage의 과부하를 사용합시다.

00:16:00.000 --> 00:16:29.000
다음으로, 이미지의 크기를 조정할 수 있게 하고 공간을 채우기 위해 종횡비를 설정하겠습니다.

00:16:29.000 --> 00:16:53.000
마지막으로, 나는 내 이미지를 유연하게 만들기 위해 최소 너비와 높이를 추가할 것이다.

00:16:53.000 --> 00:16:59.000
0이 아닌 최소 높이를 사용하면 진행 상황 보기가 내 제목 영역을 엿볼 수 있습니다.

00:16:59.000 --> 00:17:20.000
SwiftUI의 나머지 부분과 마찬가지로, AsyncImage는 지능형 기본값으로 구축되므로, 이미지를 로드하는 데 오류가 있더라도, 결과는 자리 표시자를 계속 표시하게 될 것입니다.

00:17:20.000 --> 00:17:24.000
오류 처리 동작을 사용자 정의하도록 선택할 수도 있습니다.

00:17:24.000 --> 00:17:33.000
그렇게 하려면, "단계를 사용하는 AsyncImage의 과부하"를 확인하세요. 사용자가 나중에 볼 수 있도록 좋아하는 이미지를 저장할 수 있다면 좋을 것이다.

00:17:33.000 --> 00:17:36.000
그렇게 하기 위해 이 제목 영역에 버튼을 추가해 봅시다.

00:17:36.000 --> 00:17:41.000
이 버튼은 이미지 항목을 디스크에 저장하기 위한 비동기 동작을 트리거합니다.

00:17:41.000 --> 00:17:45.000
저장된 항목은 앱의 저장된 탭에 나타날 것입니다.

00:17:45.000 --> 00:17:47.000
나는 이미 이것을 하기 위해 찔렀다.

00:17:47.000 --> 00:17:51.000
여기에 추가하겠습니다, 그러면 우리는 그 코드를 살펴볼 수 있습니다.

00:17:51.000 --> 00:18:05.000
여기 내 저장 버튼의 스텁인 버전이 있습니다.

00:18:05.000 --> 00:18:09.000
사진을 저장하기 위한 조치를 추가해 봅시다.

00:18:09.000 --> 00:18:14.000
SwiftUI의 버튼 동작은 동기식이지만, 내 "저장" 방법은 비동기적이다.

00:18:14.000 --> 00:18:21.000
그 방법을 호출하기 위해, 나는 비동기 작업을 시작할 것이다.

00:18:21.000 --> 00:18:37.000
그런 다음, 폐쇄 내부에서, 나는 "사진"에서 "저장" 방법을 부를 것이다. 그건 비동기적이야, 그래서 난 그냥 await를 사용할 거야.

00:18:37.000 --> 00:18:41.000
저장이 진행되는 동안 진행 상황을 보여주는 것이 좋을 것 같아요.

00:18:41.000 --> 00:18:44.000
그렇게 하기 위해, 나는 국가 재산을 추가할 것이다.

00:18:44.000 --> 00:19:02.000
그런 다음, 나는 저장하기 위해 내 통화에 대한 상태를 업데이트할 것이다.

00:19:02.000 --> 00:19:25.000
그런 다음, 저장이 발생할 때 진행 상황 보기를 표시하기 위해 버튼의 라벨을 업데이트하겠습니다.

00:19:25.000 --> 00:19:31.000
저는 "불투명성"을 사용하여 저장 라벨과 진행률 보기를 보여주기 위해 오버레이를 숨기고 있습니다.

00:19:31.000 --> 00:20:18.000
이 조합은 "저장"이라는 단어의 현지화에 따라 버튼이 같은 크기를 유지하도록 보장합니다. 마지막으로, 저장이 진행되는 동안 버튼을 비활성화할 것입니다.

00:20:18.000 --> 00:20:24.000
이것이 라이브 프리뷰에서 어떻게 작동하는지 봅시다.

00:20:24.000 --> 00:20:26.000
그거 꽤 멋지다!

00:20:26.000 --> 00:20:36.000
카탈로그 보기로 돌아가서 모든 것을 합치자.

00:20:36.000 --> 00:20:42.000
SwiftUI는 올해 사람들에게 수동으로 데이터를 새로 고칠 수 있는 기능을 제공하는 데 사용할 수 있는 훌륭한 새로운 수정자를 가지고 있습니다.

00:20:42.000 --> 00:20:49.000
내 목록에 새로 고침 수정자를 추가함으로써, 나는 SwiftUI에게 이 콘텐츠가 새로 고침 가능하다고 말한다.

00:20:49.000 --> 00:20:56.000
새로 고칠 수 있는 비동기 클로저를 제공하고 updateItems 메소드를 호출하여 목록을 업데이트할 수 있습니다.

00:20:56.000 --> 00:21:10.000
앞서 "작업"으로 보여줬듯이, 나는 이 비동기 방법에서 await를 사용할 것이다.

00:21:10.000 --> 00:21:16.000
새로 고침 표시기는 비동기 작업이 완료되면 자동으로 해제됩니다.

00:21:16.000 --> 00:21:29.000
이제, 아래로 당겨 이미지를 새로 고치고, 저장을 탭하여 마음에 드는 이미지를 저장하고, 저장된 탭으로 전환하여 저장된 이미지를 볼 수 있습니다.

00:21:29.000 --> 00:21:34.000
스위프트의 새로운 기능은 동시 데이터로 쉽게 작업할 수 있게 해준다.

00:21:34.000 --> 00:21:40.000
SwiftUI는 Swift의 동시성 기능과 잘 통합되어 기본적으로 최상의 동작을 제공합니다.

00:21:40.000 --> 00:21:46.000
많은 경우, 동시성의 힘을 활용하기 위해 await를 사용하기만 하면 됩니다.

00:21:46.000 --> 00:21:55.000
당신의 뷰와 잘 작동하는 방식으로 객체가 업데이트되는지 더 강력하게 확인하기 위해 ObservableObject를 "@MainActor"로 표시하세요.

00:21:55.000 --> 00:22:03.000
SwiftUI의 API 추가 기능을 활용하여 최소한의 노력으로 안전하고 성능이 뛰어난 동시 앱을 작성하세요.

00:22:03.000 --> 00:22:07.000
AsyncImage를 사용하여 이미지를 동시에 로드하세요.

00:22:07.000 --> 00:22:15.000
사용자가 수동으로 데이터를 새로 고칠 수 있도록 보기 계층에 "새로 고침 가능" 수정자를 추가하십시오.

00:22:15.000 --> 00:22:22.000
저장 버튼으로 본 것처럼, 사용자 지정 보기에서 스위프트의 새로운 동시성 기능을 사용할 수 있습니다.

00:22:22.000 --> 00:22:25.000
우리 모두가 알다시피, 동시성은 까다롭다.

00:22:25.000 --> 00:22:35.000
어려운 문제이지만, 이러한 새로운 언어 기능과 SwiftUI API를 사용하면 이제 앱의 복잡성을 관리할 수 있는 도구가 있습니다.

00:22:35.000 --> 00:22:47.000
우리는 당신이 Swift 5.5와 SwiftUI의 훌륭한 새로운 동시성 도구에 대해 배우는 것을 즐겼기를 바라며, 앱의 까다로운 문제를 해결하기 위해 그것들을 사용하는 모든 방법을 볼 수 있기를 기대합니다.

00:22:47.000 --> 23:59:59.000
[음악].

