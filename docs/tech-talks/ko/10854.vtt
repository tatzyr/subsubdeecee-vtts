WEBVTT

00:00:01.000 --> 00:00:05.000
안녕. 난 제리 메이슨이야. 저는 HomePod 팀의 소프트웨어 엔지니어입니다.

00:00:05.000 --> 00:00:13.000
그리고 이제 클라우드 확장으로 구동되는 SiriKit Media Intents로 미디어 서비스를 집으로 가져오는 과정을 안내해드리겠습니다.

00:00:13.000 --> 00:00:17.000
개발을 시작하는 데 필요한 모든 것부터 시작합시다.

00:00:17.000 --> 00:00:38.000
먼저, 우리는 서비스를 효과적으로 개발하기 위한 몇 가지 중요한 전제 조건을 다룰 것입니다: 테스트 홈을 구성하는 방법, 테스트를 위해 HomePod를 설정하는 방법, 개발을 위해 iOS 장치를 설정하는 방법, 그리고 마지막으로, 서비스를 집에 온보딩하기 위해 앱에서 MediaSetup 프레임워크를 채택하는 방법.

00:00:38.000 --> 00:00:46.000
이러한 단계를 수행하면, 콘텐츠를 사랑하는 사람들을 위해 HomePod에서 멋진 재생 경험을 만들 수 있습니다.

00:00:46.000 --> 00:00:48.000
전제 조건에 대해 자세히 알아봅시다.

00:00:48.000 --> 00:00:55.000
HomePod에서 SiriKit 미디어 인텐트를 지원하려면, 서비스는 이미 iOS 앱에서 미디어 인텐트를 지원해야 합니다.

00:00:55.000 --> 00:01:00.000
Developer.apple.com/siri에서 프로그램을 신청해야 합니다.

00:01:00.000 --> 00:01:09.000
신청 후, 서비스가 구현해야 하는 클라우드 확장 API 사양에 액세스하는 것에 대한 자세한 내용을 받게 될 것입니다.

00:01:09.000 --> 00:01:14.000
그런 다음 우리와 함께 서비스를 등록하여 개발을 시작하기 위한 자격과 프로필을 얻을 수 있습니다.

00:01:14.000 --> 00:01:27.000
그리고 마지막으로, HomePod가 Cloud Extension API를 통해 서비스에 연락할 수 있기 전에, OAuth 흐름과 사양에 정의된 구성 웹 서비스를 구현해야 합니다.

00:01:27.000 --> 00:01:29.000
등록에 대해 더 이야기해 봅시다.

00:01:29.000 --> 00:01:47.000
서비스를 등록하려면 서비스 이름, 장치에서 서비스를 확인하기 위해 만든 공개 서명 키, 가정의 iOS 장치에서 서비스 아이콘을 검색하는 정적 URL 및 서비스를 사용하는 앱의 번들 ID 목록을 제공해야 합니다.

00:01:47.000 --> 00:01:53.000
이 정보는 테스트 및 개발 장치에 설치할 수 있는 개발 프로필을 만드는 데 사용됩니다.

00:01:53.000 --> 00:01:58.000
프로필이 있는 장치만 서비스를 테스트할 수 있습니다.

00:01:58.000 --> 00:02:07.000
클라우드 확장 API가 웹 기술을 사용하기 때문에 OAuth 2.0 엔드포인트를 사용하여 인증을 채택한 것은 놀라운 일이 아닙니다.

00:02:07.000 --> 00:02:13.000
하지만 앱이 신뢰할 수 있는 클라이언트의 역할을 하기 때문에, 클라이언트 자격 증명 흐름을 구현하는 서비스가 필요합니다.

00:02:13.000 --> 00:02:19.000
집에 추가된 각 서비스 계정에는 고유한 ClientID와 ClientSecret이 필요합니다.

00:02:19.000 --> 00:02:30.000
이러한 흐름은 흔하지 않지만, Auth 서비스에 직접 제공된 이러한 자격 증명의 일반적인 재사용을 피하기 위해 갱신 토큰을 발행하는 것이 좋습니다.

00:02:30.000 --> 00:02:35.000
갱신 토큰 흐름이 없으면 ClientID와 ClientSecret이 오래 지속될 수 있기 때문입니다.

00:02:35.000 --> 00:02:41.000
누군가가 집에서 당신의 서비스를 사용하는 한, 갱신 토큰이나 원래 인증을 지원해야 합니다.

00:02:41.000 --> 00:02:51.000
iOS 앱은 서비스에서 요청하고 iOS 미디어 설정 API에 제공하여 이러한 자격 증명을 제공할 수 있어야 합니다.

00:02:51.000 --> 00:02:54.000
HomePod는 의도를 해결하기 위해 서비스에 연락합니다.

00:02:54.000 --> 00:02:59.000
iOS에서, 당신이 지원하는 의도에 대한 세부 사항은 앱 번들의 일부입니다.

00:02:59.000 --> 00:03:08.000
클라우드 확장에서는 지원되는 엔드포인트와 그에 도달하는 데 사용하는 URL을 식별하는 하나 이상의 구성 리소스 엔드포인트를 구현해야 합니다.

00:03:08.000 --> 00:03:10.000
여기에는 많은 융통성이 있다.

00:03:10.000 --> 00:03:20.000
여러 정적 URL을 갖거나 동적으로 생성하는 엔드포인트를 구현할 수 있으며, 이 모든 것은 개발 및 준비 테스트 구성에 유용합니다.

00:03:20.000 --> 00:03:26.000
엔드포인트는 요청 인증 헤더를 확인하여 구성을 검색하는 계정을 식별할 수도 있습니다.

00:03:26.000 --> 00:03:35.000
구성의 본문은 자바스크립트 객체 서명 및 암호화 표준을 사용하여 인코딩되며, 장치가 수락하려면 올바르게 서명되어야 합니다.

00:03:35.000 --> 00:03:44.000
리소스를 제공하더라도, 클라이언트가 자주 검색할 필요가 없도록 표준 HTTP 캐시 제어 헤더를 제공해야 합니다.

00:03:44.000 --> 00:03:51.000
앱이 홈에 서비스를 추가할 때마다, 이 리소스의 URL과 클라이언트 자격 증명을 제공합니다.

00:03:51.000 --> 00:03:57.000
이러한 전제 조건이 충족되면, 테스트 홈을 구성하는 것에 대해 이야기해 봅시다.

00:03:57.000 --> 00:04:04.000
서비스를 개발하고 테스트하는 동안, Apple Home 앱에 전용 테스트 홈을 갖는 것이 강력히 권장됩니다.

00:04:04.000 --> 00:04:13.000
그렇게 하면, 개인적으로 사용할 수 있는 HomeKit 홈에 영향을 미치지 않으며, 테스트 홈에서 장치의 구성만 관리하면 됩니다.

00:04:13.000 --> 00:04:19.000
또한 같은 집에서 다른 계정으로 서비스를 테스트할 수 있도록 여러 개의 테스트 iCloud 계정을 갖고 싶을 것입니다.

00:04:19.000 --> 00:04:25.000
그리고 자연스럽게, 당신은 HomePod와 iOS 테스트 장치에서 동일한 계정을 사용하고 있는지 확인하고 싶습니다.

00:04:25.000 --> 00:04:28.000
홈 앱에서 새 집을 만드는 것은 쉽다.

00:04:28.000 --> 00:04:37.000
먼저, 홈 설정을 탭하고, 집을 추가하고, 집 이름을 입력하십시오.

00:04:37.000 --> 00:04:44.000
이제 다른 테스트 사용자인 사람들을 추가할 수 있습니다.

00:04:44.000 --> 00:04:50.000
알았어. 이제 테스트 홈을 설정했으니, HomePod를 추가한 다음 설정해야 합니다.

00:04:50.000 --> 00:04:59.000
당신은 보통 HomePod에 최신 tvOS 개발자 베타 릴리스 또는 Apple이 현재 개발을 위해 조언하는 릴리스를 설치하고 싶을 것입니다.

00:04:59.000 --> 00:05:05.000
앱을 제출할 준비가 될 때까지 일반 tvOS 릴리스를 사용할 수 없다는 것을 아는 것이 중요합니다.

00:05:05.000 --> 00:05:12.000
그때까지, iOS의 홈 앱에서 서비스를 위해 Apple이 제공하는 개발 프로필을 설치해야 합니다.

00:05:12.000 --> 00:05:17.000
집에서 테스트할 각 장치에 대해 이 과정을 반복해야 합니다.

00:05:17.000 --> 00:05:22.000
새 버전의 tvOS로 업데이트할 때, 프로필을 다시 설치해야 할 수도 있습니다.

00:05:22.000 --> 00:05:29.000
HomePod에 프로필을 설치하려면, 먼저 홈 앱에서 테스트 홈이 선택되었는지 확인하세요.

00:05:29.000 --> 00:05:32.000
iOS 기기에서 프로필을 여세요.

00:05:32.000 --> 00:05:36.000
설치할 장치 유형으로 HomePod를 선택하세요.

00:05:36.000 --> 00:05:45.000
설치를 탭하고, 암호를 입력하고, 계약에 동의하고, 설치를 탭하여 설치를 완료하십시오.

00:05:45.000 --> 00:05:49.000
그런 다음 테스트 홈에서 프로필을 설치할 HomePod를 선택할 수 있습니다.

00:05:49.000 --> 00:05:51.000
그게 다야.

00:05:51.000 --> 00:05:56.000
테스트와 개발을 위해 iOS 기기도 설정해야 합니다.

00:05:56.000 --> 00:06:00.000
iOS 기기에서 개발자 베타를 사용해야 합니다.

00:06:00.000 --> 00:06:07.000
보통, 당신은 tvOS와 동시에 출시된 버전을 원하지만, Apple에 최신 권장 버전을 확인하십시오.

00:06:07.000 --> 00:06:11.000
HomePod와 마찬가지로, 개발 프로필을 설치해야 합니다.

00:06:11.000 --> 00:06:23.000
이메일이나 iMessage 첨부 파일에서 모바일 구성 번들을 탭하고, iOS 기기에 설치하도록 선택하고 설정에서 프로필을 수락하고 설치하는 일반적인 흐름을 따르십시오.

00:06:23.000 --> 00:06:30.000
이 시점에서 iOS 장치와 HomePod 장치가 예상 릴리스를 실행하고 있는지 확인하는 것이 좋습니다.

00:06:30.000 --> 00:06:33.000
필요한 모든 테스트 장치에 대해 이 설정을 반복할 수 있습니다.

00:06:33.000 --> 00:06:37.000
그것들은 iPhone 또는 iPad 장치일 수 있다.

00:06:37.000 --> 00:06:42.000
장치를 구성하면, 이제 앱에서 MediaSetup 프레임워크를 채택할 수 있습니다.

00:06:42.000 --> 00:06:48.000
이것은 궁극적으로 사람들이 집에서 사용할 수 있도록 당신의 서비스를 설정할 수 있게 해줄 것입니다.

00:06:48.000 --> 00:07:04.000
MediaSetup을 사용하려면, OAuth 자료를 검색하거나 만들기 위해 앱에서 기능을 구현하고, 온보딩 중인 계정에 적합한 구성 리소스 URL을 선택한 다음, Apple에 서비스를 등록한 후 받은 권한을 추가해야 합니다.

00:07:04.000 --> 00:07:07.000
그렇지 않으면, 당신은 프레임워크를 사용할 수 없을 것입니다.

00:07:07.000 --> 00:07:17.000
MSSetupSession을 사용하여 계정 설치 흐름을 트리거하기 위해 앱에 눈에 띄는 발견 가능한 온보딩 프레젠테이션 컨텍스트를 추가하십시오.

00:07:17.000 --> 00:07:20.000
사람들은 홈 계정 설정 과정을 안내받을 것이다.

00:07:20.000 --> 00:07:29.000
설정 프로세스는 OAuth 서비스를 사용하여 API 토큰을 검색하고 구성 리소스 URL이 제대로 서명되고 구문 분석 가능한지 확인합니다.

00:07:29.000 --> 00:07:35.000
그래서 내가 앞서 언급한 모든 전제 조건은 성공적인 설정이 완료되기 전에 충족되어야 한다.

00:07:35.000 --> 00:07:40.000
Developer.apple.com에서 더 자세한 정보를 얻을 수 있습니다.

00:07:40.000 --> 00:07:46.000
이제 개발 및 테스트 환경이 준비되었으므로, 테스트 홈의 HomePod가 서비스에 연락할 수 있습니다.

00:07:46.000 --> 00:07:50.000
클라우드에서 의도를 처리하는 시스템 아키텍처를 살펴봅시다.

00:07:50.000 --> 00:08:00.000
iPhone, iPad 또는 Apple TV에서 Siri에게 iOS 앱에서 미디어를 재생하도록 요청할 때, 직접 또는 앱 번들의 확장 프로그램을 통해 의도를 처리합니다.

00:08:00.000 --> 00:08:14.000
일반적으로, 누군가가 Siri에게 앱에서 콘텐츠를 재생하도록 요청할 때, Siri는 이 요청을 처리하고, 앱 번들을 인텐트의 대상으로 식별하고, 인텐트 해결을 구현하는 앱 확장을 로드합니다.

00:08:14.000 --> 00:08:23.000
확장 프로그램은 서비스와 통신할 수 있으며, 의도를 처리하면 앱 실행을 트리거하여 재생을 시작하거나 변경 사항을 처리하도록 신호를 보냅니다.

00:08:23.000 --> 00:08:36.000
클라우드 확장을 사용하면 HomePod가 대신 클라우드 확장 인텐트 엔드포인트에 직접 도달함에 따라 이러한 의도를 해결하는 프로세스는 장치의 확장 구현에서 서비스의 API로 이동합니다.

00:08:36.000 --> 00:08:41.000
클라우드 확장 API는 인텐트 처리를 위해 설계된 웹 API 사양입니다.

00:08:41.000 --> 00:08:51.000
OpenAPI 스키마를 사용하여 iOS에서 이미 익숙한 SiriKit Intent API를 밀접하게 따르는 객체를 정의합니다.

00:08:51.000 --> 00:08:59.000
우리가 시작할 때 논의한 구성 URL도 사양의 일부이며, 그 내용은 그 안에 정의되어 있다.

00:08:59.000 --> 00:09:08.000
각 SiriKit 미디어 인텐트 유형에는 프로토콜 엔드포인트 구성이 있으며, 구현에 필요한 다른 URL에 연결할 수 있습니다.

00:09:08.000 --> 00:09:15.000
지원되는 프로토콜은 다음과 같습니다: 미디어 재생, 미디어 추가 및 미디어 선호도 업데이트.

00:09:15.000 --> 00:09:23.000
iOS 기기와 달리 HomePod에 결과를 표시할 컨텍스트가 없기 때문에 HomePod에서 검색 프로토콜이 제공되지 않는다는 것을 알 수 있습니다.

00:09:23.000 --> 00:09:26.000
Siri에게 콘텐츠를 재생하라고 말하면 어떻게 되는지 봅시다.

00:09:26.000 --> 00:09:33.000
내가 Siri에게 "Play 'Strange' by Celeste"라고 말할 때, 이것은 PlayMediaIntentHandling 흐름을 촉발시킨다.

00:09:33.000 --> 00:09:38.000
HomePod는 미디어 검색 객체로 PlayMediaIntent를 해결하기 시작합니다.

00:09:38.000 --> 00:09:42.000
그것은 JSON으로 직렬화되어 당신의 서비스로 전송됩니다.

00:09:42.000 --> 00:09:48.000
미디어 검색을 카탈로그에서 적절한 것과 일치시키면, 응답 객체가 생성됩니다.

00:09:48.000 --> 00:09:58.000
미디어 항목에는 Siri가 사용자에게 "이제 Celeste의 'Strange'를 재생하고 있습니다."라고 말하기 위해 대화를 공식화하는 데 사용할 수 있는 식별자, 유형 및 추가 메타데이터가 있습니다.

00:09:58.000 --> 00:10:04.000
또한, 이 프로토콜에는 의도에 대한 다른 필드를 해결한 후 호출되는 핸들 방법이 있습니다.

00:10:04.000 --> 00:10:10.000
의도의 필드가 이미 허용된다면, 최종 핸들 방법을 반환하는 것을 지연시킬 이유가 없습니다.

00:10:10.000 --> 00:10:13.000
그러니 초기 요청에 대한 응답에 포함시키세요.

00:10:13.000 --> 00:10:20.000
그렇게 하지 않으면 불필요하게 서비스에 대한 추가 왕복 여행이 발생하고 의도 응답 시간이 느려집니다.

00:10:20.000 --> 00:10:32.000
핸들 응답 안에는 HomePod가 콘텐츠를 재생하기 시작할 때 서비스로 반환될 persistentIdentifier와 userInfo가 포함된 UserActivity라는 객체를 포함할 수 있습니다.

00:10:32.000 --> 00:10:42.000
귀하의 서비스는 이러한 결과로 응답하고 HomePod가 이러한 결과를 처리하고 재생 세션을 시작할 때 요청에 따라 재생할 콘텐츠 대기열을 형성하기 시작할 수 있습니다.

00:10:42.000 --> 00:10:49.000
이제, 당신의 서비스에서 미디어가 재생될 때, 내가 Siri에게 "이것을 내 라이브러리에 추가하세요"라고 말할 때 어떤 일이 일어나는지 생각해 봅시다.

00:10:49.000 --> 00:11:03.000
AddMediaIntentHandling 흐름은 Siri가 현재 서비스에서 재생 중인 것을 알고 있다는 점을 제외하고는 이전과 같이 미디어 항목을 해결하는 것으로 시작하며, 현재 재생 중인 콘텐츠의 식별자도 미디어 검색 매개 변수의 일부입니다.

00:11:03.000 --> 00:11:10.000
이전과 마찬가지로, 당신의 서비스는 재생되는 콘텐츠를 식별하고 요청하는 데 사용된 계정의 라이브러리에 추가해야 합니다.

00:11:10.000 --> 00:11:19.000
그런 다음 ResolveMediaItem을 나타내는 개체를 만들고 이 작업이 성공했음을 나타내는 핸들 메서드 결과를 함께 묶습니다.

00:11:19.000 --> 00:11:25.000
그런 다음 Siri가 결과를 확인할 HomePod에 응답을 반환할 것입니다.

00:11:25.000 --> 00:11:27.000
그리고 마지막으로, 내가 Siri에게 말할 때, "난 이게 좋아!"

00:11:27.000 --> 00:11:47.000
UpdateMediaAffinityIntentHandling은 이전과 같이 미디어 항목을 해결하는 것으로 다시 시작되며, 서비스는 콘텐츠를 식별하고, ResolveMediaItem 결과를 만들고, 요청을 인증하는 데 사용된 계정의 맛 프로필에 대해 이 친화력을 등록하고, 이전 예와 마찬가지로 핸들 메소드 결과를 포함합니다.

00:11:47.000 --> 00:11:56.000
이러한 상황에 맞는 요청에는 요청이 있을 때 서비스가 HomePod에서 재생되는 서비스인 경우에만 콘텐츠 식별자가 포함됩니다.

00:11:56.000 --> 00:12:03.000
또한, 청취자들이 현재 라이브러리에 재생되지 않는 것을 추가하고 싶다고 말할 수 있다는 것을 잊지 마세요.

00:12:03.000 --> 00:12:08.000
이 경우, 해결해야 할 미디어 이름과 아티스트 이름이 제공됩니다.

00:12:08.000 --> 00:12:11.000
하지만 이것은 덜 흔한 사용 사례이다.

00:12:11.000 --> 00:12:18.000
프로토콜에서 JSON으로 보이는 기본 재생 미디어 요청과 응답을 봅시다.

00:12:18.000 --> 00:12:29.000
HomePod에 서비스에서 음악을 재생하기 위한 가장 기본적인 요청을 요청하면, 서비스의 의도 엔드포인트에 대한 모든 요청은 해결해야 할 첫 번째 항목 전에 세션 설명을 제공할 것입니다.

00:12:29.000 --> 00:12:35.000
사양의 대부분의 객체는 제시되는 객체의 클라우드 확장 버전 번호를 포함한다.

00:12:35.000 --> 00:12:39.000
당신의 서비스는 가능한 경우 이러한 객체의 이전 버전을 지원해야 합니다.

00:12:39.000 --> 00:12:44.000
최신 버전은 또한 새로운 주요 버전 번호까지 이전 버전과 호환되어야 합니다.

00:12:44.000 --> 00:12:51.000
의도 해결 세션에는 HTTPS 요청의 헤더에도 전달되는 식별자가 있습니다.

00:12:51.000 --> 00:13:00.000
의도 상호 작용을 해결하는 동안 동일하게 유지될 것이며, 이 의도를 해결하기 위해 여러 요청이 이루어진다면, 이 식별자는 그들 사이에서 일관성이 있을 것이다.

00:13:00.000 --> 00:13:09.000
두 개의 타임 스탬프가 제공됩니다 - 요청이 준비된 UTC 시간과 고객이 요청을 시간으로 처리한 마감일 시간.

00:13:09.000 --> 00:13:14.000
마감일을 놓치면, Siri는 서비스가 의도를 해결할 수 없다고 설명할 것이다.

00:13:14.000 --> 00:13:17.000
시기적절한 응답을 제공하는 것은 중요하다.

00:13:17.000 --> 00:13:30.000
타임아웃은 10초 후에 발생하므로, 서비스가 HomePod의 요청 사이의 시간을 활용할 수 있도록 의도 결과를 반환하고 재생을 위한 콘텐츠를 준비하는 작업을 어떻게 분리할 수 있는지 고려하십시오.

00:13:30.000 --> 00:13:34.000
이러한 제약과 플레이어 컨텍스트 객체는 나중에 더 깊이 논의될 것이다.

00:13:34.000 --> 00:13:40.000
그들은 요청이 이루어졌을 때 HomePod에서 무슨 일이 일어나고 있는지에 대한 중요한 정보를 제공한다.

00:13:40.000 --> 00:13:44.000
대부분의 요청은 프로토콜의 resolveMediaItems 방법으로 시작됩니다.

00:13:44.000 --> 00:13:49.000
이 요청의 가장 중요한 부분은 매개 변수와 의도 객체에 있다.

00:13:49.000 --> 00:13:59.000
이것은 PlayMediaIntent이며, 모든 PlayMediaIntent 객체에는 Siri가 음성에서 구문 분석한 미디어 속성을 정의하는 mediaSearch가 있습니다.

00:13:59.000 --> 00:14:10.000
의도의 다른 매개 변수에는 콘텐츠를 셔플하거나 반복하거나 콘텐츠 재생을 재개하도록 요청했는지, 또는 지금 대신 다음 또는 나중에 재생하라고 말했는지에 대한 정보가 포함됩니다.

00:14:10.000 --> 00:14:16.000
이미 iOS에서 PlayMediaIntents를 처리했다면 이 객체는 당신에게 친숙해 보일 것입니다.

00:14:16.000 --> 00:14:22.000
이 요청에서 돌아오는 응답도 친숙해 보이지만, 몇 가지 새로운 반전이 있습니다.

00:14:22.000 --> 00:14:38.000
결과 배열 내부에서는 메서드 이름, 결과 객체, 이 경우 하나의 항목이 있는 resolutionResult 배열, 이 메서드에 적합한 resolutionResult 클래스를 제공합니다. 이 경우 성공 속성입니다.

00:14:38.000 --> 00:14:45.000
그리고 보시다시피, 이 resolvedMediaItem은 내 취향 프로필을 기반으로 한 방송국인 Your Favorites를 나타냅니다.

00:14:45.000 --> 00:14:47.000
여기 클라우드 확장을 위한 새로운 것이 있습니다.

00:14:47.000 --> 00:14:53.000
처리하는 각 방법은 서비스가 결과를 제공하는 데 몇 초가 걸렸는지 설명하는 메트릭 객체를 반환해야 합니다.

00:14:53.000 --> 00:15:02.000
애플은 이 데이터를 총체적으로 사용하여 청취자의 경험을 대략적으로 결정하고 네트워크 연결로 인한 지연을 더 잘 평가할 수 있다.

00:15:02.000 --> 00:15:07.000
다음 결과 항목이 여기서 휴식을 엿보고 있는 것을 볼 수 있습니다-- 이 프로토콜의 핸들 방법.

00:15:07.000 --> 00:15:16.000
핸들 메소드의 결과는 그 의도에 적합한 응답 객체이며, 상태 코드와 UserActivity 객체에 대한 설명이 있습니다.

00:15:16.000 --> 00:15:21.000
사용자 활동을 의도 결과를 나타내는 기념품으로 생각하세요.

00:15:21.000 --> 00:15:33.000
MediaIntent 결과를 재생하기 위해, UserActivity는 콘텐츠의 재생을 시작하거나 수정할 때 사용되는 반면, iOS 기기에서는 UserActivity 객체가 실행될 때 앱에서 사용할 수 있습니다.

00:15:33.000 --> 00:15:41.000
HomePod에서, 당신의 서비스는 미디어 큐브 재생을 위한 다른 클라우드 확장 API로 청취 경험을 정의합니다.

00:15:41.000 --> 00:15:48.000
이 시점까지, 이전에 iOS에서 SiriKit Media Intents를 구현했다면 의도 처리는 매우 친숙했을 것입니다.

00:15:48.000 --> 00:15:52.000
클라우드 서비스에서 미디어를 재생하는 것은 클라우드 확장의 주요 기능입니다.

00:15:52.000 --> 00:16:00.000
그리고 이 부분에서는 클라우드에서 미디어 대기열을 구현하기 위한 개념과 세부 사항을 제공하겠습니다.

00:16:00.000 --> 00:16:04.000
사람이 Siri에게 HomePod에서 미디어를 재생하도록 요청할 때 어떤 일이 일어나는지 다시 검토해 봅시다.

00:16:04.000 --> 00:16:12.000
요청은 Siri에 의해 처리되며, 클라우드 미디어 서비스 확장 프로그램은 귀하의 서비스를 대신하여 처리하도록 선택됩니다.

00:16:12.000 --> 00:16:18.000
HomePod는 의도를 해결하기 위해 서비스에 의해 구현된 클라우드 확장 API를 사용합니다.

00:16:18.000 --> 00:16:28.000
의도를 해결하면, 클라우드 미디어 플레이어 구성 요소는 서비스의 대기열 엔드포인트에 연락하며, 재생할 콘텐츠를 결정하는 것은 대기열 엔드포인트입니다.

00:16:28.000 --> 00:16:33.000
대부분의 서비스에서, 콘텐츠 배포 서비스는 종종 재생할 실제 오디오 파일을 제공한다.

00:16:33.000 --> 00:16:36.000
여기에 두 개의 홈팟이 묘사되어 있다는 것을 알 수 있습니다.

00:16:36.000 --> 00:16:43.000
특정 상황에서, 의도를 해결하는 HomePod는 콘텐츠를 재생하는 HomePod와 같지 않을 수 있습니다.

00:16:43.000 --> 00:16:57.000
가족이 여러 개의 홈팟을 가지고 있다면, 거실에 있는 누군가와 가장 가까운 홈팟은 당신의 서비스가 이미 집안의 여러 위치에서 재생되고 그 세션이 부엌에서 시작되었더라도 그들의 요청에 응답할 수 있습니다.

00:16:57.000 --> 00:17:00.000
당신의 서비스가 대기열을 통해 어떻게 콘텐츠를 제공하는지 봅시다.

00:17:00.000 --> 00:17:09.000
다양한 관용구와 다양한 청취 경험을 위한 사용 사례를 포함하여 미디어 대기열의 높은 수준의 개념을 안내해드리겠습니다.

00:17:09.000 --> 00:17:13.000
그리고 나서 대기열 관리와 그들의 수명에 대한 세부 사항을 살펴보세요.

00:17:13.000 --> 00:17:18.000
그리고 마지막으로, 당신의 서비스가 HomePod의 재생 컨트롤을 어떻게 정의하는지 설명하겠습니다.

00:17:18.000 --> 00:17:23.000
좋아요, 당신의 서비스에서 대기열을 제공하는 것이 무엇을 의미하는지 살펴봅시다.

00:17:23.000 --> 00:17:29.000
클라우드 확장이 지원하는 모든 청취 경험은 콘텐츠 항목의 대기열을 재생하여 정의됩니다.

00:17:29.000 --> 00:17:36.000
대기열은 의도 해결로 인한 사용자 활동 객체를 서비스에 제출하여 생성되거나 수정됩니다.

00:17:36.000 --> 00:17:41.000
당신의 서비스는 콘텐츠 항목의 대기열을 한 번에 또는 세그먼트로 반환합니다.

00:17:41.000 --> 00:17:46.000
몇 가지 사용 사례와 그것들을 대기열로 개념화하는 방법을 살펴봅시다.

00:17:46.000 --> 00:17:58.000
인터넷 라디오 콘텐츠는 종종 프로모션 트랙으로 시작하고, 많은 노래, 종종 광고, 더 많은 노래로 시작하며, 청취자가 재생을 멈출 때까지 무기한으로 계속됩니다.

00:17:58.000 --> 00:18:06.000
주문형 음악 요청은 단일 앨범이나 재생 목록과 같은 다른 컬렉션으로 해결될 수 있으며 한정된 대기열로 제한될 수 있습니다.

00:18:06.000 --> 00:18:15.000
그리고 라이브 스트리밍 콘텐츠는 종종 라이브 스트림 소스를 참조하는 하나의 콘텐츠가 있는 최소한의 대기열 응답을 형성하는 단일 콘텐츠 항목을 가질 것이다.

00:18:15.000 --> 00:18:24.000
대기열의 콘텐츠 항목은 식별자, URL 및 콘텐츠 이름, 아티스트와 같은 다양한 설명 속성으로 설명할 수 있습니다.

00:18:24.000 --> 00:18:35.000
콘텐츠 선택은 엄격한 앨범 트랙 순서에서 완전히 역동적인 선택에 이르기까지 서비스에서 원하는 수의 알고리즘 형태를 취할 수 있습니다.

00:18:35.000 --> 00:18:38.000
대기열은 이러한 모든 사용 사례를 지원하기 위한 것이다.

00:18:38.000 --> 00:18:45.000
이제 대기열에서 일련의 콘텐츠 항목을 관용적으로 표현할 수 있는 다양한 방법에 대해 이야기해 봅시다.

00:18:45.000 --> 00:18:50.000
내가 설명할 숙어는 다른 목적을 위해 세그먼트로 나누어진 대기열을 사용하는 변형이다.

00:18:50.000 --> 00:18:55.000
그래서 여기서 우리는 객체에 의해 설명된 시간이 지남에 따라 개념적으로 실현된 콘텐츠를 가지고 있다.

00:18:55.000 --> 00:19:02.000
이 네 가지 콘텐츠가 의도 해결의 결과로 표현하고 싶은 완전한 청취 경험이라고 가정해 봅시다.

00:19:02.000 --> 00:19:09.000
자체 식별자와 이러한 모든 콘텐츠 항목의 간단한 배열이 있는 대기열 객체로 패키징할 수 있습니다.

00:19:09.000 --> 00:19:11.000
그건 꽤 기본적인 대기열 객체야.

00:19:11.000 --> 00:19:17.000
이것은 대기열에 유한하고 변하지 않는 콘텐츠 목록이 포함된 정적 콘텐츠 관용구이다.

00:19:17.000 --> 00:19:24.000
그것은 하나의 대기열 세그먼트에 맞을 수도 있고 그렇지 않을 수도 있지만, 개념적으로, 순서대로 재생할 수 있는 콘텐츠 항목의 엄격한 목록이다.

00:19:24.000 --> 00:19:36.000
이 관용구의 사용 사례에는 앨범이나 재생 목록에 대한 주문형 음악 요청 또는 대기열이 무기한으로 스트리밍되는 하나의 콘텐츠에 대한 간단한 래퍼인 라이브 스트림 사용 사례가 포함됩니다.

00:19:36.000 --> 00:19:40.000
그러나, 당신의 서비스는 더 복잡한 대기열을 가질 수 있습니다.

00:19:40.000 --> 00:19:47.000
대기열은 세그먼트로 나눌 수 있으며, URL 참조를 통해 내부적으로 다음 콘텐츠와 이전 콘텐츠 항목으로 연결됩니다.

00:19:47.000 --> 00:20:04.000
HomePod는 서비스가 정의함에 따라 이러한 세그먼트를 검색하며, 특정 세그먼트는 동적으로 생성되고 청취 세션이 새로운 세그먼트로 이동함에 따라 자연스럽게 전환하거나 콘텐츠 항목을 앞뒤로 건너뛰어 다른 결과를 반환할 수 있습니다.

00:20:04.000 --> 00:20:10.000
이 특정 예는 서비스가 고정 콘텐츠 세그먼트 세트 내에서 광고를 제공하는 사용 사례에 적합할 수 있습니다.

00:20:10.000 --> 00:20:16.000
그리고 플레이어가 대기열 세그먼트 B를 만날 때마다, 다른 광고가 재생될 수 있다.

00:20:16.000 --> 00:20:24.000
이것은 서비스 대기열 콘텐츠가 동적으로 검색된다는 것을 의미하므로, 당신의 서비스는 입력된 것보다 각 대기열 세그먼트에 대해 더 많은 요청을 경험할 것입니다.

00:20:24.000 --> 00:20:28.000
당신의 서비스는 콘텐츠와 재생 옵션에 대한 가장 개별적인 제어를 원할 수 있습니다.

00:20:28.000 --> 00:20:38.000
그리고 완전히 역동적인 관용구에서, 모든 대기열 세그먼트에는 하나의 콘텐츠 항목이 포함되어 있으며, 리스너가 진행함에 따라 대기열에 대한 새로운 콘텐츠를 동적으로 검색할 수 있습니다.

00:20:38.000 --> 00:20:43.000
이것은 대기열이 일반적으로 무기한 크기이기 때문에 인터넷 라디오 사용 사례에서 인기 있는 관용구이다.

00:20:43.000 --> 00:20:47.000
그리고 또한 대기열 콘텐츠 자체가 듣기 행동의 기능이기 때문이다.

00:20:47.000 --> 00:20:58.000
Siri 의도를 통해 트랙을 건너뛰고 콘텐츠 선호도를 제공하면 계정과 관련된 취향 프로필이 변경될 수 있으므로 향후 콘텐츠 항목을 다르게 선택할 수 있습니다.

00:20:58.000 --> 00:21:04.000
당연히, 이것은 또한 당신의 서비스에서 가장 많은 요청 처리를 나타내는 관용구이기도 합니다.

00:21:04.000 --> 00:21:17.000
이러한 관용구는 동일한 큐 아키텍처를 사용하는 다른 방법이기 때문에, 서비스는 이러한 관용구의 조합을 사용하여 대기열을 제공할 수 있으며, 특정 종류의 요청에 대해 구현할 대체 관용구를 선택할 수도 있습니다.

00:21:17.000 --> 00:21:22.000
그것들은 복잡성과 능력의 절충을 고려하는 데 유용하다.

00:21:22.000 --> 00:21:27.000
충분한 이론. 당신의 서비스가 이러한 대기열을 어떻게 만들고 관리하는지에 대해 이야기해 봅시다.

00:21:27.000 --> 00:21:42.000
PlayMediaIntentHandling 요청이 인텐트 엔드포인트에서 반환되면, 서비스는 대기열의 표현을 만들기 시작해야 합니다. 왜냐하면 얼마 지나지 않아 대기열 재생 미디어 엔드포인트에 대한 요청이 초기 또는 완전한 대기열 세그먼트를 검색하기 위해 이루어지기 때문입니다.

00:21:42.000 --> 00:21:50.000
각 세그먼트는 서비스가 원하는 대로 다음 및 이전 세그먼트에 연결할 수 있으며, 잠재적으로 무한하거나 순환되는 콘텐츠 세트를 제공합니다.

00:21:50.000 --> 00:21:54.000
보통, 새로 검색된 대기열은 첫 번째 콘텐츠 항목에서 재생되기 시작합니다.

00:21:54.000 --> 00:22:07.000
이전 세션에서 재생 재개를 지원하기 위해, PlayPointer 객체는 초기 대기열 세그먼트에 제공될 수 있으며, 재생은 귀하가 제공한 시간 오프셋에 표시된 콘텐츠 항목에서 시작됩니다.

00:22:07.000 --> 00:22:20.000
부드럽고 간격이 없는 재생을 지원하기 위해, 청취 지점이 대기열 세그먼트의 마지막 콘텐츠 항목의 끝에 가깝기 때문에, 다음 세그먼트는 구성 가능한 프리롤 간격으로 검색되고 추가됩니다.

00:22:20.000 --> 00:22:28.000
PlayMusicIntent를 성공적으로 처리한 후 서비스와 교환된 실제 JSON 객체를 살펴보겠습니다.

00:22:28.000 --> 00:22:31.000
모든 요청과 마찬가지로, 우리는 고객의 버전으로 시작합니다.

00:22:31.000 --> 00:22:42.000
집에는 균일하지 않은 장치 세트가 있을 수 있으므로, 콘텐츠를 재생하는 장치에서 지원하는 버전은 실제로 의도를 해결한 버전보다 오래되거나 최신 버전일 수 있습니다.

00:22:42.000 --> 00:22:48.000
PlayMedia 요청의 식별자는 의도 해결에 사용된 식별자를 상속합니다.

00:22:48.000 --> 00:22:54.000
어떤 이유로든 재생을 다시 시작해야 한다면, 이 식별자는 새로운 고유 식별자일 수 있습니다.

00:22:54.000 --> 00:23:03.000
이러한 식별자가 디버깅에 유용할 수 있지만, 의도 결과를 사용자 활동이 훨씬 더 적절한 대기열과 연결하기 위해 이것에 의존해서는 안 됩니다.

00:23:03.000 --> 00:23:08.000
제약 객체는 장치에서 재생에 대한 특정 제한을 정의합니다.

00:23:08.000 --> 00:23:13.000
당신은 그것이 의도 엔드포인트에서도 제공된다는 것을 기억할 수 있으며, 나중에 이것들에 대해 더 자세히 설명하겠습니다.

00:23:13.000 --> 00:23:24.000
마지막으로, 의도 해결이 UserActivity 객체를 반환한 경우, 해당 객체는 대기열 엔드포인트가 이 세션을 위한 콘텐츠 항목을 어떻게 준비해야 하는지에 대한 컨텍스트를 제공하기 위해 포함됩니다.

00:23:24.000 --> 00:23:27.000
당신의 서비스는 대기열 객체로 요청에 응답합니다.

00:23:27.000 --> 00:23:37.000
그것은 나중에 보고와 문맥과 의도를 위해 제시될 식별자를 가지고 있으며 일반적으로 같은 대기열의 다른 세그먼트 간에 동일하게 유지됩니다.

00:23:37.000 --> 00:23:44.000
이 작은 예에서는 하나의 항목만 제공되지만, 재생할 수 있는 콘텐츠 항목의 배열을 제공할 수 있습니다.

00:23:44.000 --> 00:23:56.000
각 콘텐츠 항목을 설명하는 속성, 전체 카탈로그가 아닌 경우 이 대기열에 고유해야 하는 각 항목의 식별자 및 콘텐츠 본문에 대한 URL이 있습니다.

00:23:56.000 --> 00:24:00.000
다음은 세그먼트에 대한 이전 및 다음 콘텐츠 링크가 설명된 곳입니다.

00:24:00.000 --> 00:24:06.000
이 URL의 응답 본문은 이것과 매우 비슷한 또 다른 대기열 세그먼트 정의이다.

00:24:06.000 --> 00:24:18.000
마지막으로, 배열의 마지막 콘텐츠 항목의 재생이 끝나기 약 5초 전에 5초의 프리롤을 지정함으로써, 대기열 콘텐츠를 앞으로 확장하기 위해 다음 콘텐츠 URL이 검색됩니다.

00:24:18.000 --> 00:24:22.000
그것이 HomePod가 콘텐츠 재생을 시작하는 데 필요한 전부입니다.

00:24:22.000 --> 00:24:28.000
이제, 누군가가 이미 당신의 대기열을 듣고 있는 동안 Siri에게 다음에 다른 트랙을 재생해 달라고 요청하면 어떨까요?

00:24:28.000 --> 00:24:34.000
이것은 재생 대기열 위치를 다음으로 해결함으로써 PlayMediaIntentHandling 프로토콜에 표시됩니다.

00:24:34.000 --> 00:24:41.000
HomePod가 이 예제 대기열에서 두 번째 콘텐츠 항목을 재생하고 있다면, 완전히 새로운 대기열 결과를 제공하고 싶지 않을 것입니다.

00:24:41.000 --> 00:24:46.000
이 경우, 당신은 말 그대로 이 대기열 안에 하나 이상의 콘텐츠 항목을 삽입하고 싶습니다.

00:24:46.000 --> 00:25:02.000
현재 재생 중인 것과 동일한 대기열 식별자와 세그먼트에서 전달되는 콘텐츠가 현재 대기열 세그먼트에 삽입되어야 하는 위치에 대한 insertPointer 객체를 가진 PlayMedia 엔드포인트의 대기열 세그먼트를 제공하여 이를 수행합니다.

00:25:02.000 --> 00:25:10.000
삽입 지점에 특정 콘텐츠 식별자가 제공되지 않으면, 항목은 현재 재생 중인 항목 뒤에도 삽입됩니다.

00:25:10.000 --> 00:25:19.000
이 행동은 의도를 해결하고 대기열을 업데이트하는 것 사이의 전환에서 콘텐츠 재생으로 경쟁 조건의 영향을 줄입니다.

00:25:19.000 --> 00:25:25.000
서비스가 완전 동적 대기열 관용구를 사용하더라도 이 기술을 사용하는 것이 좋습니다.

00:25:25.000 --> 00:25:30.000
마지막으로, 대기열 관리의 몇 가지 뉘앙스를 다루겠습니다.

00:25:30.000 --> 00:25:47.000
서비스 엔드포인트에서 가장 많은 수의 요청이 발생하지만, 완전히 역동적인 관용구는 대부분의 미디어 서비스에 콘텐츠를 제공하는 가장 유연한 방법을 특징으로 하며 콘텐츠가 본질적으로 완전히 정적이지 않은 경우 개념적으로 관리하기가 더 쉽습니다.

00:25:47.000 --> 00:26:00.000
대기열 프로토콜이 대기열을 탐색할 때 콘텐츠 세트를 제공할 수 있을 만큼 유연함에도 불구하고, 청취자가 대기열에서 뒤로 탐색할 수 있도록 허용하는 경우 대기열 기록의 일관성을 유지하는 것이 가장 좋습니다.

00:26:00.000 --> 00:26:16.000
반복 및 셔플 동작을 구현하려면, 서비스는 의도 처리에서 이러한 옵션을 식별하고 셔플된 순서로 대기열 콘텐츠를 제공하거나 대기열에서 이전에 재생된 항목으로 이어지는 다음 콘텐츠 URL과 같은 기술로 무기한으로 반복해야 합니다.

00:26:16.000 --> 00:26:24.000
이러한 행동은 대기열 범위에 대한 완전한 지식 없이는 수행할 수 없기 때문에 HomePod는 기본적으로 지원하려고 시도조차 하지 않습니다.

00:26:24.000 --> 00:26:38.000
다음 및 이전 콘텐츠 URL을 템플릿화할 수 있으므로 대기열 세그먼트의 마지막 콘텐츠 항목이나 현재 재생 중인 활동 대기열 또는 콘텐츠 식별자와 같은 소량의 컨텍스트를 구현에 제공할 수 있습니다.

00:26:38.000 --> 00:26:46.000
서비스가 대기열 업데이트 사용자 활동 엔드포인트를 구현하는 경우, 이벤트 보고를 통해 재생 대기열을 업데이트할 수도 있습니다.

00:26:46.000 --> 00:26:48.000
곧 보고에 대해 얘기할게.

00:26:48.000 --> 00:26:58.000
당신의 서비스가 유연하고 시기적절한 콘텐츠 검색 및 업데이트를 제공하는 데 사용할 수 있는 풍부한 대기열 관리 도구 세트를 잘 이해하기를 바랍니다.

00:26:58.000 --> 00:27:06.000
마지막으로, 이 섹션에서는 재생을 제어하고 청취자가 서비스와 상호 작용하는 방법을 정의하는 방법을 확장하겠습니다.

00:27:06.000 --> 00:27:11.000
모든 종류의 대기열이 같은 것은 아니며, 대기열의 모든 콘텐츠가 동일하게 취급될 수 있는 것은 아니다.

00:27:11.000 --> 00:27:17.000
예를 들어, 인터넷 라디오 사용 사례는 일반적으로 대기열을 통한 순방향 움직임만 지원합니다.

00:27:17.000 --> 00:27:23.000
게다가, 광고가 재생될 때, 당신은 그 콘텐츠를 건너뛰는 것을 전혀 지원하고 싶지 않을 수도 있습니다.

00:27:23.000 --> 00:27:32.000
라디오 방송국 대기열에서 건너뛰는 것은 프리미엄 구독, 프리미엄 모델, 기타 더 난해한 제한 등 많은 변수에 의해 제한될 수 있습니다.

00:27:32.000 --> 00:27:36.000
완전히 역동적인 관용구는 종종 이러한 요구 사항을 지원하는 유일한 방법이다.

00:27:36.000 --> 00:27:41.000
대기열에서 다른 콘텐츠 사이를 이동하는 것은 임의로 제한될 수 있다.

00:27:41.000 --> 00:27:44.000
이 상호 작용을 어떻게 정의하는지에 대해 이야기해 봅시다.

00:27:44.000 --> 00:27:52.000
클라우드 확장 대기열 API를 사용하면 서비스가 대기열 객체에서 제공하는 PlayMediaControl 객체와의 상호 작용을 정의할 수 있습니다.

00:27:52.000 --> 00:27:59.000
각 PlayMediaControl 객체는 몇 가지 일반적인 사용 사례를 지원하는 미리 정의된 구성표를 선택할 수 있습니다.

00:27:59.000 --> 00:28:05.000
이 정의된 상호 작용 세트는 제어 속성으로 각 콘텐츠 항목에 지정할 수 있습니다.

00:28:05.000 --> 00:28:14.000
노래가 산재된 광고가 있는 주문형 서비스에 적합할 수 있는 예시 제어 정의를 살펴봅시다.

00:28:14.000 --> 00:28:18.000
모든 대기열 객체에 대한 컨트롤 속성 안에 이러한 정의를 포함합니다.

00:28:18.000 --> 00:28:33.000
이 예에는 두 가지 정의가 있습니다. 콘텐츠 항목이 컨트롤을 지정하지 않을 때 사용되는 필수 기본 정의와 광고인 모든 콘텐츠 항목에 지정된 광고 정의가 있습니다.

00:28:33.000 --> 00:28:36.000
모든 제어 정의에는 프로토타입 계획이 있다.

00:28:36.000 --> 00:28:43.000
기본적으로, 대기열의 콘텐츠 항목은 온디맨드 스킴이 될 것이며, 광고 콘텐츠의 경우 광고 스킴이 될 것이다.

00:28:43.000 --> 00:28:48.000
이 계획은 사용자가 다음 콘텐츠 항목으로 이동하도록 요청할 때 Siri 대화를 수정합니다.

00:28:48.000 --> 00:28:52.000
그러면 Siri는 광고를 건너뛰는 것이 허용되지 않는다고 대답할 수 있다.

00:28:52.000 --> 00:28:59.000
이 계획은 또한 모든 탐색 명령을 비활성화하도록 기본 설정하지만, 선택적으로 다시 활성화할 수 있습니다.

00:28:59.000 --> 00:29:10.000
명령을 활성화하는 예도 여기에 제공되며, 일반적으로 기본적으로 비활성화된 dislikeTrack 및 likeTrack 명령이 주문형 콘텐츠에 의해 활성화되고 있습니다.

00:29:10.000 --> 00:29:18.000
대기열의 항목에 연결된 작은 제어 정의 세트로 콘텐츠와의 상호 작용을 실질적으로 사용자 정의할 수 있는 방법을 알 수 있습니다.

00:29:18.000 --> 00:29:31.000
마지막으로, 제어 정의를 통해 사용자 활동 보고 옵션을 지정할 수 있으며, 이는 서비스가 선택적 명령 이벤트, 탐색 정보 및 콘텐츠의 재생 상태를 수신하는 방법입니다.

00:29:31.000 --> 00:29:34.000
이것들은 내가 다음에 다루려고 하는 모든 주제들이다.

00:29:34.000 --> 00:29:41.000
지금까지, 당신은 HomePod가 의도를 해결하고 재생할 콘텐츠 대기열을 관리하기 위해 서비스에 어떻게 도달하는지 보았습니다.

00:29:41.000 --> 00:30:03.000
이제 서비스가 재생 이벤트를 인식하고 시간이 지남에 따라 요청을 맥락화할 수 있는 방법에 대해 이야기하겠습니다. 청취 활동이 서비스에 보고될 수 있는 방법, 이미 서비스에서 대기열을 재생할 때 재생 컨텍스트가 제공되는 방법, 그리고 마지막으로 서비스가 특정 재생 제약을 어떻게 존중해야 하는지에 대해 이야기하겠습니다.

00:30:03.000 --> 00:30:06.000
그럼 보고부터 시작합시다.

00:30:06.000 --> 00:30:13.000
리스너 활동은 클라우드 확장 API의 미디어 대기열 업데이트 활동 엔드포인트를 사용하여 보고됩니다.

00:30:13.000 --> 00:30:20.000
이 엔드포인트는 기술적으로 선택 사항이지만, 대부분의 서비스는 사람들이 콘텐츠를 들을 때 HomePod에서 상태 보고서를 얻기 위해 이를 구현합니다.

00:30:20.000 --> 00:30:30.000
당신의 서비스는 트랙에서 건너뛰기, 일시 정지, 재생 계속 및 스크러빙과 같은 전환 및 미디어 제어 이벤트에 대한 보고서를 받습니다.

00:30:30.000 --> 00:30:36.000
특히 부분적으로 또는 완전히 동적 대기열 관용구를 구현한 경우, 대기열 콘텐츠는 이러한 보고서의 영향을 받을 수 있습니다.

00:30:36.000 --> 00:30:40.000
당신의 서비스는 응답으로 새로운 대기열 세그먼트를 반환할 수도 있습니다.

00:30:40.000 --> 00:30:58.000
업데이트 활동 요청은 대기열의 콘텐츠 검색에서 비동기적으로 이루어지기 때문에, 트랙 건너뛰기 보고서에 새 대기열을 반환하면 대기열 콘텐츠를 깔끔하게 표시하지 않을 수 있으며 정상적인 전환 논리와 싸울 수 있으므로 재생에서 일부 가청 점프가 발생할 수 있습니다.

00:30:58.000 --> 00:31:04.000
보고에서 대기열 응답을 사용하여 재생을 완전히 변경하거나 새 콘텐츠를 삽입하십시오.

00:31:04.000 --> 00:31:10.000
콘텐츠 URL 템플릿을 사용하여 대기열 세그먼트가 검색된 이유에 대한 더 많은 컨텍스트를 얻으십시오.

00:31:10.000 --> 00:31:15.000
업데이트 활동 엔드포인트에 대한 예시 요청을 살펴봅시다.

00:31:15.000 --> 00:31:18.000
이 예에서, 나는 Siri에게 다음 트랙으로 건너뛰라고 요청했다.

00:31:18.000 --> 00:31:22.000
이러한 간단한 상호 작용은 의도가 아니라 미디어 제어이다.

00:31:22.000 --> 00:31:25.000
JSON에서, 보고서는 다음과 같이 보인다.

00:31:25.000 --> 00:31:30.000
보시다시피, 작성 중인 보고서 유형은 skip_next로 태그되어 있습니다.

00:31:30.000 --> 00:31:42.000
전체 보고 유형 세트는 사양에 정의되어 있으며 트랙 간의 자연스러운 전환, 트랙 내 스크러빙 및 새 대기열이 기존 대기열을 대체할 때를 포함합니다.

00:31:42.000 --> 00:31:50.000
활동, 대기열 및 contentIdentifiers와 현재 재생된 콘텐츠에 대한 오프셋을 포함한 nowPlaying 컨텍스트가 제공됩니다.

00:31:50.000 --> 00:31:54.000
전환을 위해, 이전에 재생된 컨텍스트도 제공됩니다.

00:31:54.000 --> 00:32:02.000
재생 중인 마지막 콘텐츠와 관련된 식별자와 재생이 전환될 때 콘텐츠 내부의 오프셋을 나타냅니다.

00:32:02.000 --> 00:32:06.000
그들이 빨리 건너뛰면 이것을 사용하여 청취자의 취향 프로필을 업데이트할 수 있습니다.

00:32:06.000 --> 00:32:12.000
하지만 이 경우, offsetInMillis 값에서 알 수 있듯이, 나는 그 노래의 상당 부분을 들었다.

00:32:12.000 --> 00:32:17.000
그래서 당신의 서비스는 내가 그것을 좋아했을 것이라고 가정할 수 있습니다, 적어도 상대적인 등급을 낮추지 않을 만큼.

00:32:17.000 --> 00:32:29.000
그리고 대기열 API의 다른 엔드포인트와 마찬가지로, 사용자 정보 데이터가 서비스가 상태를 복구하고 이 정보를 빠르게 처리하는 데 유용한 경우를 대비하여 사용자 활동 객체가 완전히 표시됩니다.

00:32:29.000 --> 00:32:32.000
당신의 서비스가 사용할 수 있는 고급 기능도 있습니다.

00:32:32.000 --> 00:32:42.000
예를 들어, 콘텐츠가 재생 중일 때 특정 지점에 도달했거나 특정 반복 간격이 경과할 때마다 재생 간격 보고서를 요청할 수 있습니다.

00:32:42.000 --> 00:32:50.000
iOS 장치가 HomePod에서 재생을 제어할 때 특정 MPRemoteCommandCenter 명령에 대한 보고를 활성화하고 받을 수 있습니다.

00:32:50.000 --> 00:32:57.000
likeTrack과 dislikeTrack에 대한 원격 명령은 업데이트 미디어 선호도 의도 처리와 동일하지 않습니다.

00:32:57.000 --> 00:33:02.000
그것들은 음성 의도가 아니라, 집안 어디에서나 iOS 기기의 간단한 탭이다.

00:33:02.000 --> 00:33:11.000
이전에 새 대기열을 반환하는 것에 대해 논의했지만, 업데이트된 버전의 개체를 반환하여 재생 중에 사용자 활동 개체를 업데이트할 수도 있습니다.

00:33:11.000 --> 00:33:17.000
다음은 활동 정의를 포함하는 사용자 지정 제어 계획의 이전 예입니다.

00:33:17.000 --> 00:33:27.000
기본 컨트롤에는 60초의 playElapsedInterval이 포함되어 있습니다. 즉, 제어 속성이 없는 콘텐츠 항목이 재생됨에 따라 60초마다 보고서가 생성됩니다.

00:33:27.000 --> 00:33:36.000
하지만 광고의 제어 속성이 있는 항목의 경우, 콘텐츠의 5초가 경과하자마자 보고서가 생성되고 10초마다 또 다른 보고서가 생성됩니다.

00:33:36.000 --> 00:33:42.000
사양에 정의된 보고 간격에는 몇 가지 제한이 있습니다.

00:33:42.000 --> 00:33:51.000
보고는 서비스에 많은 데이터를 제공하지만, 수백만 명의 청취자가 의도를 처리하기 때문에 서비스에서 그 맥락을 추적하는 것은 비용이 많이 들 수 있습니다.

00:33:51.000 --> 00:33:59.000
대기열 재생과 의도 처리 엔드포인트 컨텍스트를 연결하는 데 도움이 되도록 세션 컨텍스트를 서비스에 제공할 수 있습니다.

00:33:59.000 --> 00:34:05.000
세션 컨텍스트는 HomePod가 현재 서비스에서 미디어를 재생하고 있는 경우에만 사용할 수 있습니다.

00:34:05.000 --> 00:34:18.000
Siri에게 특정 콘텐츠를 좋아한다고 말할 때, 당신의 인텐트 서비스 엔드포인트는 보고 섹션에서 논의된 nowPlaying 객체가 모든 보고서에 전송되는 방식과 마찬가지로 playerContext 객체를 받습니다.

00:34:18.000 --> 00:34:24.000
플레이어 컨텍스트에는 콘텐츠, 대기열 및 사용자 활동 영구 식별자 값이 포함됩니다.

00:34:24.000 --> 00:34:41.000
이것들은 내가 이전에 도입한 세 가지 수준의 정의를 포함한다 - 잠재적으로 오래 지속되는 청취 세션을 정의하는 Activity persistentIdentifier, 현재 청취자의 경험과 의도 해결 시점에 현재 재생되고 있는 특정 콘텐츠를 정의하는 Queue.

00:34:41.000 --> 00:34:48.000
이 항목은 또한 인텐트 미디어 검색 객체에 있으며, 이미 iOS 기기에서 사용하는 데 익숙할 수 있습니다.

00:34:48.000 --> 00:34:58.000
세션 컨텍스트가 업데이트 활동 엔드포인트를 구현할 필요성을 피하고 더 복잡한 보고 이벤트를 처리하기 위해 서비스에 충분한 정보인지 고려하십시오.

00:34:58.000 --> 00:35:08.000
이 예에서 UpdateMediaAffinityIntentHandling 요청, HomePod는 이미 서비스에서 대기열을 재생하고 있었기 때문에 playerContext 객체가 인텐트 엔드포인트에 제공됩니다.

00:35:08.000 --> 00:35:16.000
세션 객체 내에서, 서비스가 현재 재생되고 있지 않은 경우 playerContext 또는 null 값을 찾을 수 있습니다.

00:35:16.000 --> 00:35:27.000
서비스의 취향 프로필이 미디어 선호도와 재생 미디어 요청에 의해서만 명시적으로 구동되는 경우, 플레이어 컨텍스트는 전체 보고를 구현하지 않고 모든 요구 사항을 처리할 수 있습니다.

00:35:27.000 --> 00:35:35.000
하지만 당신의 서비스가 이러한 도구의 맛 프로필 정보를 사용하기 전에, 그것은 또한 모든 요청과 함께 전송된 사용에 대한 제약을 존중해야 합니다.

00:35:35.000 --> 00:35:41.000
집에는, 당신의 서비스가 알아야 하고 존중해야 하는 다른 종류의 문맥 인식이 있습니다.

00:35:41.000 --> 00:35:46.000
각 HomePod는 서비스에 제약을 주는 특정 옵션으로 구성할 수 있습니다.

00:35:46.000 --> 00:35:53.000
예를 들어, 어린이 방에 있는 HomePod에는 결과에서 노골적인 콘텐츠를 제외할 수 있는 옵션이 있을 수 있습니다.

00:35:53.000 --> 00:35:58.000
이 HomePod에서 요청이 이루어질 때마다, 노골적인 콘텐츠를 반환해서는 안 됩니다.

00:35:58.000 --> 00:36:06.000
하지만 설정이 활성화되지 않은 침실의 HomePod에 대한 요청은 노골적인 콘텐츠를 반환할 수 있어야 합니다.

00:36:06.000 --> 00:36:07.000
제약은 선택 사항이 아니다.

00:36:07.000 --> 00:36:11.000
당신의 서비스는 제시된 제약의 의미를 따라야 합니다.

00:36:11.000 --> 00:36:22.000
우리 집의 손님이 어떤 종류의 콘텐츠를 재생해 달라고 요청할 때, 그들은 당신의 서비스에 대한 요청을 할 수 있고 일시적으로 내 계정을 사용하지만, 이 상호 작용은 내 취향 프로필에 영향을 미치지 않아야 합니다.

00:36:22.000 --> 00:36:32.000
Siri는 내가 어떻게 들리는지 꽤 좋은 생각을 가지고 있기 때문에, 우리는 그 요청이 내가 하지 않았다는 것을 감지하고 당신의 서비스에 내 취향 프로필을 변경하기 위해 이 요청을 사용하지 말라고 말한다.

00:36:32.000 --> 00:36:39.000
제약 조건은 서비스 계정 설정의 기존 제한만 추가로 제한해야 합니다.

00:36:39.000 --> 00:36:47.000
귀하의 서비스에 유사한 제한에 대한 계정별 제어가 있는 경우, 청취자가 귀하의 서비스에서 기대하는 것을 제공하기 위해 결합되어야 합니다.

00:36:47.000 --> 00:36:53.000
여기 세션 객체와 제약 정의로 시작하는 의도 요청의 한 가지 예가 더 있습니다.

00:36:53.000 --> 00:37:00.000
그것들은 작은 물건이지만, 당신의 서비스가 가정 환경에서 상호 작용하는 방식에 상당한 영향을 미칩니다.

00:37:00.000 --> 00:37:13.000
updateUserTasteProfile은 이 의도의 해결이 좋아요, 싫어요, 재생 횟수 및 내 계정과 관련된 서비스의 눈에 보이는 청취 기록을 추적하는 데 사용될지 여부를 나타내는 부울 제약 조건입니다.

00:37:13.000 --> 00:37:20.000
거짓일 때, 당신의 서비스는 사용된 계정이 재생을 제어하거나 시작하는 사람의 계정이라고 가정할 수 없습니다.

00:37:20.000 --> 00:37:28.000
이 HomePod는 내 목소리를 인식할 때에도 내 계정의 취향 프로필에 기여하지 않도록 구성되었을 수도 있기 때문에 거짓일 수도 있습니다.

00:37:28.000 --> 00:37:35.000
내 거실에 홈팟이 있다고 상상해봐, 그리고 나는 정기적으로 어린 아이들을 대신하여 음악을 연주해 달라고 부탁해.

00:37:35.000 --> 00:37:42.000
이 옵션을 설정할 방법이 없었다면, 내가 가장 좋아하는 음악 방송국은 내가 좋아하는 것보다 훨씬 더 절충적일 수 있다.

00:37:42.000 --> 00:37:47.000
allowExplicitContent는 HomePod 및 Home 앱별 설정을 반영하는 또 다른 부울 제약 조건입니다.

00:37:47.000 --> 00:37:52.000
그리고 당신의 서비스는 의도의 결과에서 노골적인 콘텐츠를 필터링하기 위해 그것을 고려해야 합니다.

00:37:52.000 --> 00:38:07.000
사실, 검색과 일치하는 명시적이지 않은 콘텐츠가 없기 때문에 특정 의도 요청을 이행할 수 없는 경우, resolvedMediaItem 방법에 대한 특정 오류 결과가 SiriKit Media Intents에 제공됩니다.

00:38:07.000 --> 00:38:10.000
마지막으로, 하드웨어조차도 제약이 있다.

00:38:10.000 --> 00:38:14.000
대기열 세그먼트는 한정된 크기일 수 있으며, 그 값은 장치당 동적이다.

00:38:14.000 --> 00:38:20.000
대기열이 이 값보다 크면, 이 제한을 준수하기 위해 세분화된 대기열 관용구를 구현해야 합니다.

00:38:20.000 --> 00:38:24.000
최소 크기는 세그먼트당 100개의 콘텐츠 항목입니다.

00:38:24.000 --> 00:38:28.000
나는 오늘 많은 것을 다루었고, 모든 것을 소화하는 데 시간이 좀 걸릴 수도 있다.

00:38:28.000 --> 00:38:32.000
일단 당신이 접근할 수 있게 되면, 사양을 더 자세히 살펴보는 것이 좋습니다.

00:38:32.000 --> 00:38:37.000
그것은 내가 오늘 다룬 모든 끝점에 대해 훨씬 더 자세하게 설명한다.

00:38:37.000 --> 00:38:48.000
이 사양에는 구현해야 하는 서비스 엔드포인트에 대한 개방형 API 정의가 있으며, 서비스를 개발할 때 기본 데이터 모델 구문 분석 및 검증 코드를 생성할 수 있을 만큼 완벽합니다.

00:38:48.000 --> 00:38:50.000
그건 정말 유용해.

00:38:50.000 --> 00:38:56.000
클라우드 확장 API 정의는 새 릴리스마다 iOS SiriKit 미디어 API의 변경 사항을 추적합니다.

00:38:56.000 --> 00:39:03.000
몇 가지 예외를 제외하고, 장치의 SiriKit Media API를 통해 사용할 수 있는 거의 모든 것은 Cloud Extension API를 통해 사용할 수 있습니다.

00:39:03.000 --> 00:39:10.000
그리고 대기열 API는 강력한 재생 정의, 제어 및 보고를 서비스에 직접 제공합니다.

00:39:10.000 --> 23:59:59.000
SiriKit Media Intents에 관심을 가져주셔서 감사드리며, developer.apple.com/siri에서 향후 SiriKit Media API 변경 사항에 대한 최신 정보를 확인하세요.

