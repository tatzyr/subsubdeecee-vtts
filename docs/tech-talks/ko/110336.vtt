WEBVTT

00:00:03.000 --> 00:00:08.000
안녕. 제 이름은 케이티입니다. Apple Pay와 주문 추적을 구현하는 이 세션에 오신 것을 환영합니다.

00:00:08.000 --> 00:00:10.000
오늘의 안건을 살펴봅시다.

00:00:10.000 --> 00:00:14.000
먼저, Apple Pay를 시작하는 데 필요한 기본 사항을 안내해 드리겠습니다.

00:00:14.000 --> 00:00:19.000
그런 다음 결제 요청을 만들고 결제 시트의 변경 사항에 응답하는 방법을 보여드리겠습니다.

00:00:19.000 --> 00:00:23.000
사용자가 주문을 추적할 수 있도록 결제 흐름 끝에 주문 세부 정보를 추가할 수도 있습니다.

00:00:23.000 --> 00:00:28.000
주문 세부 사항을 통해 지갑은 주문한 패키지를 검색할 수 있으며, 만드는 방법을 보여드리겠습니다.

00:00:28.000 --> 00:00:31.000
마지막으로, 주문을 업데이트하는 방법을 보여드리겠습니다.

00:00:31.000 --> 00:00:33.000
그럼 시작하자.

00:00:33.000 --> 00:00:36.000
Apple Pay는 쉽고 안전하며 사적인 결제 방법입니다.

00:00:36.000 --> 00:00:42.000
웹사이트나 앱의 개발자라면, Apple Pay를 사용하여 전환과 사용자 경험을 향상시킬 수 있습니다.

00:00:42.000 --> 00:00:44.000
시작하기 위해 만들어야 할 두 가지 필수 항목이 있습니다.

00:00:44.000 --> 00:00:50.000
첫 번째는 당신을 지불을 수락할 수 있는 상인으로 고유하게 식별하는 식별자입니다.

00:00:50.000 --> 00:00:54.000
하나를 만들려면, Apple Developer 포털의 식별자 섹션으로 이동해야 합니다.

00:00:54.000 --> 00:00:58.000
전통적인 형식은 "상인"이라는 단어로 시작하는 역방향 DNS이다.

00:00:58.000 --> 00:01:02.000
새로운 판매자 식별자를 사용하여 결제 처리 인증서를 만드세요.

00:01:02.000 --> 00:01:09.000
매우 간결하게 말하면, Apple Pay는 등록된 판매자 식별자와 공개 인증서로 각 페이로드를 암호화합니다.

00:01:09.000 --> 00:01:13.000
그런 다음 이 페이로드는 당신의 쪽에서 해독되고 처리될 수 있습니다.

00:01:13.000 --> 00:01:16.000
그런 다음 결제가 성공했는지 실패했는지 여부를 반환할 수 있습니다.

00:01:16.000 --> 00:01:19.000
결제 처리에 대한 자세한 내용은 결제 서비스 제공 업체에 문의하십시오.

00:01:19.000 --> 00:01:24.000
앱과 웹사이트 간에 Apple Pay를 설정하는 다양한 단계가 있습니다.

00:01:24.000 --> 00:01:32.000
앱에서 사용할 Apple Pay를 설정하려면 Xcode의 서명 및 기능 탭으로 이동하여 Apple Pay 기능에 따라 판매자 식별자를 추가하기만 하면 됩니다.

00:01:32.000 --> 00:01:37.000
웹사이트를 만들고 있고 그곳에서 Apple Pay를 설정하고 싶다면, 몇 가지 추가 단계가 필요합니다.

00:01:37.000 --> 00:01:44.000
Apple Developer 포털의 식별자 섹션에서 수행할 수 있는 Apple Pay 거래를 처리할 도메인을 등록해야 합니다.

00:01:44.000 --> 00:01:51.000
그곳에 있는 동안, 이전에 만든 판매자 식별자와 연결된 Apple Pay 판매자 신원 인증서를 만들 수 있습니다.

00:01:51.000 --> 00:01:55.000
이 인증서는 Apple Pay 서버에 세션을 인증하는 데 사용됩니다.

00:01:55.000 --> 00:02:04.000
앱을 통합하든 웹을 통합하든, 전자 상거래 플랫폼이나 결제 서비스 제공 업체와 함께 작업하는 경우, 이러한 단계 중 일부를 단순화할 수 있으므로 특정 지침을 확인하십시오.

00:02:04.000 --> 00:02:07.000
이제 Apple Pay를 실제로 구현하는 방법을 살펴봅시다.

00:02:07.000 --> 00:02:14.000
Apple Pay 관련 콘텐츠를 표시하기 전에, 사용자가 현재 구성으로 결제할 수 있는지 확인해야 합니다.

00:02:14.000 --> 00:02:21.000
기능은 3D 보안 또는 신용 카드 또는 직불 카드와 같이 시트가 현재 수락할 수 있는 지불 유형을 나타냅니다.

00:02:21.000 --> 00:02:26.000
나중에 지불 요청을 구성할 때 수락하는 기능을 지정할 것입니다.

00:02:26.000 --> 00:02:33.000
현재 사용 가능한 카드가 없는 경우 사용자가 더 많은 카드를 추가할 수 있다는 점을 염두에 두고 사용자가 이미 사용 가능한 네트워크를 확인할 수 있습니다.

00:02:33.000 --> 00:02:38.000
이제 사용자가 결제할 수 있다는 것을 알았으니, Apple Pay 버튼을 표시할 시간입니다.

00:02:38.000 --> 00:02:43.000
사용자가 취해야 할 작업에 맞춰 가장 적합한 콜투액션과 버튼 유형을 선택해야 합니다.

00:02:43.000 --> 00:02:49.000
Apple Pay 버튼을 접기 위에, 그리고 첫 번째 결제 옵션으로 표시하세요.

00:02:49.000 --> 00:02:53.000
Apple Pay 버튼은 완전히 현지화되어 있으며 사용자의 설정에 맞게 조정할 수도 있습니다.

00:02:53.000 --> 00:03:02.000
UIKit으로 앱에 Apple Pay 버튼을 표시하려면, 먼저 버튼의 유형과 스타일을 지정하여 PKPaymentButton을 만드세요.

00:03:02.000 --> 00:03:08.000
유형은 지불의 종류를 설명합니다; 예를 들어, Apple Pay로 기부하거나 Apple Pay로 계속하세요.

00:03:08.000 --> 00:03:12.000
스타일은 밝은지 어두운지와 같은 버튼의 모양을 제어합니다.

00:03:12.000 --> 00:03:16.000
버튼의 자동 스타일을 사용하여 사용자의 설정에 따라 동적으로 변경하십시오.

00:03:16.000 --> 00:03:20.000
웹에서 자바스크립트 애플 페이 버튼을 사용하세요.

00:03:20.000 --> 00:03:25.000
하나를 추가하려면, 먼저, 버튼 스크립트를 콘텐츠 전송 네트워크의 웹 페이지에 로드하세요.

00:03:25.000 --> 00:03:31.000
JavaScript Apple Pay 버튼을 사용하면 유형, 스타일 및 현지화를 지정할 수 있습니다.

00:03:31.000 --> 00:03:35.000
CSS를 사용하여 버튼의 크기를 추가로 사용자 정의할 수도 있습니다.

00:03:35.000 --> 00:03:39.000
우리는 지불 시트가 무엇을 기대해야 하는지 알 수 있도록 지불 요청을 만들어야 합니다.

00:03:39.000 --> 00:03:43.000
앱에서, 우리는 PKPaymentRequest를 만들어 그것을 할 수 있다.

00:03:43.000 --> 00:03:55.000
필요에 따라 요청에 따라 설정할 수 있는 많은 필드가 있지만, 필수 사항에는 이전에 만든 판매자 식별자, 수락할 수 있는 결제 유형, 결제 국가 및 통화 코드가 포함됩니다.

00:03:55.000 --> 00:03:58.000
결제를 수락하는 네트워크를 지정하세요.

00:03:58.000 --> 00:04:03.000
이것은 선호하는 순서대로 이루어져야 하므로 Apple Pay와 cobatched 카드에 대해 선호하는 네트워크를 선택해야 합니다.

00:04:03.000 --> 00:04:07.000
마지막으로, 요약 항목은 이 거래의 일부로 포함되어 있다.

00:04:07.000 --> 00:04:10.000
요약 항목을 자세히 살펴봅시다.

00:04:10.000 --> 00:04:17.000
그렇게 하기 위해, 우리는 당신이 온라인 애완동물 용품 가게를 운영하고 고객에게 Apple Pay로 주문을 확인할 수 있는 기능을 제공하고 싶다고 상상할 수 있습니다.

00:04:17.000 --> 00:04:23.000
이 요약 항목은 고객이 선택한 항목의 총 비용에서 할인을 뺀 금액으로 구성됩니다.

00:04:23.000 --> 00:04:26.000
그들은 고객에게 비용을 절감하는 데 도움을 주어야 한다.

00:04:26.000 --> 00:04:32.000
마지막 요약 항목은 항상 합계이며, 이 합계의 라벨은 지불을 받는 회사여야 합니다.

00:04:32.000 --> 00:04:36.000
여기 배열에 적어도 하나의 항목이 있어야 합니다.

00:04:36.000 --> 00:04:39.000
이제, 우리는 결제 시트를 표시할 준비가 되었습니다.

00:04:39.000 --> 00:04:46.000
먼저, 우리는 PKPayment AuthorizationViewController를 만들고, 얼마 전에 설정한 요청을 보냅니다.

00:04:46.000 --> 00:04:50.000
당신은 당신에게 반환된 뷰컨트롤러를 제시하는 것을 담당하고 있습니다.

00:04:50.000 --> 00:04:53.000
이제, 우리가 설정하고 있는 이 대표를 살펴봅시다.

00:04:53.000 --> 00:05:03.000
PKPaymentAuthorization ViewControllerDelegate는 사용자가 새 이메일 주소를 선택하거나 거래를 승인할 때와 같이 시트가 변경 사항을 전달하는 방법입니다.

00:05:03.000 --> 00:05:14.000
당신은 당신에게 적합한 변경 사항에 응답해야 합니다; 그러나, 당신은 항상 지불 시트를 기각할 책임이 있으며 이를 처리하기 위해 paymentAuthorizationViewControll erDidFinish를 구현해야 합니다.

00:05:14.000 --> 00:05:21.000
문제를 해결하는 데 도움이 되는 유용한 설명과 함께 가능한 한 빨리 사용자에게 오류를 반환하려고 노력해야 합니다.

00:05:21.000 --> 00:05:29.000
예를 들어, 사용자의 새 배송 주소에 문제가 있는 경우, PKPaymentRequest ShippingContactUpdate의 일부로 오류를 반환해야 합니다.

00:05:29.000 --> 00:05:37.000
didAuthorizePayment는 사용자가 세부 사항에 만족하고 Face ID, Touch ID 또는 암호를 사용하여 거래를 진행할 때 호출됩니다.

00:05:37.000 --> 00:05:43.000
직접 보내거나 결제 프로세서에 전달하여 PKPayment를 처리해야 합니다.

00:05:43.000 --> 00:05:47.000
적절한 결과로 핸들러를 불러야 합니다.

00:05:47.000 --> 00:05:52.000
iOS 16에서, 우리는 SwiftUI에서 Apple Pay 버튼을 쉽게 만들 수 있는 기능을 도입했습니다.

00:05:52.000 --> 00:06:01.000
Apple Pay로 결제 버튼을 만들 때 결제 요청을 전달하기만 하면 사용자가 버튼과 상호 작용할 때 결제 시트가 자동으로 표시됩니다.

00:06:01.000 --> 00:06:05.000
버튼의 유형과 선택적으로 스타일을 설정할 수도 있습니다.

00:06:05.000 --> 00:06:10.000
지불 승인 변경은 우리가 이전 슬라이드에서 살펴본 대리인과 유사하다.

00:06:10.000 --> 00:06:13.000
사용자 업데이트에 대응하는 방법을 살펴봅시다.

00:06:13.000 --> 00:06:25.000
사용자가 방금 결제를 승인했고 결제 승인 단계 변경은 앱에 이 앱을 알리고 결제 정보를 서버로 보내고 결제를 처리하도록 요청합니다.

00:06:25.000 --> 00:06:33.000
서버 결과가 성공을 나타내는지 확인하고 서버에서 반환한 오류를 처리하여 적절한 오류로 결과 핸들러를 호출할 수 있도록 하십시오.

00:06:33.000 --> 00:06:39.000
서버 결과가 성공을 나타내는 경우, 적절한 승인 결과로 결제를 완료하십시오.

00:06:39.000 --> 00:06:46.000
당신이 반환하는 결과는 지불을 처리하려고 할 때 일어난 일을 포함해야 합니다; 예를 들어, 우편 주소가 유효하지 않은 경우.

00:06:46.000 --> 00:06:50.000
대부분의 경우, 지불은 성공하거나 실패할 것이다.

00:06:50.000 --> 00:06:55.000
결제가 실패하면, 중요도에 따라 하나 이상의 오류를 반환할 수도 있습니다.

00:06:55.000 --> 00:06:58.000
그것은 그들이 다시 거래를 시도할 수 있도록 사용자에게 표시될 것이다.

00:06:58.000 --> 00:07:03.000
이 승인 결과는 선택적으로 주문 세부 사항을 포함할 수 있으며, 우리는 곧 살펴볼 것입니다.

00:07:03.000 --> 00:07:06.000
이제 웹에서 이것을 하는 방법을 살펴봅시다.

00:07:06.000 --> 00:07:11.000
W3C 결제 요청 API는 웹에서 결제를 처리할 수 있는 개방형 표준입니다.

00:07:11.000 --> 00:07:29.000
PaymentRequest 객체를 만들고 Apple Pay를 사용할 수 있음을 지정할 수 있는 방법, 합계 및 배송 방법과 같은 거래에 대한 정보가 포함된 세부 정보, 사용자가 제공할 정보를 지정하는 옵션으로 채울 수 있습니다.

00:07:29.000 --> 00:07:35.000
서버에서 가맹점 검증을 완료해야 하므로, 새로운 가맹점 세션을 만들고 전체 기능으로 전달하십시오.

00:07:35.000 --> 00:07:43.000
네이티브와 마찬가지로, 사용자가 결제 시트에서 하는 상호 작용에 응답할 수 있으며 사용자가 인증할 때 결제 응답을 처리해야 합니다.

00:07:43.000 --> 00:07:47.000
이제 여러분 모두가 Apple Pay와 통합되었기 때문에, 우리는 실제로 주문을 시작할 수 있습니다.

00:07:47.000 --> 00:07:50.000
iOS 16에서, 우리는 주문 추적을 도입했다.

00:07:50.000 --> 00:07:55.000
고객은 이제 지갑 앱 내에서 주문 세부 사항과 추적 정보를 볼 수 있습니다.

00:07:55.000 --> 00:08:04.000
그들은 언제 주문을 픽업할 수 있는지, 주문이 배달되었는지, 문제가 있었는지 또는 알림을 받았는지 즉시 알 수 있을 것이다.

00:08:04.000 --> 00:08:10.000
이제 애완동물 가게 사업을 Apple Pay와 성공적으로 통합했으므로, 주문 추적을 추가할 수도 있습니다.

00:08:10.000 --> 00:08:12.000
어떻게 하는지 보자.

00:08:12.000 --> 00:08:16.000
주문을 시작하는 것이 Apple Pay를 설정하는 것과 비슷하다는 것을 알게 될 것입니다.

00:08:16.000 --> 00:08:23.000
개발자 포털의 식별자 섹션으로 돌아가서 주문 유형 식별자를 만드세요.

00:08:23.000 --> 00:08:28.000
이것은 당신의 조직을 주문 정보를 제공하는 단체로 식별합니다.

00:08:28.000 --> 00:08:36.000
상인 식별자와 마찬가지로, 이번에는 "주문"이라는 단어에 앞서 유사한 역방향 DNS 스타일의 명명 체계를 사용하는 것이 좋습니다.

00:08:36.000 --> 00:08:42.000
다음으로, 개발자 포털의 인증서 섹션에서 주문 유형 ID 인증서를 만드세요.

00:08:42.000 --> 00:08:48.000
인증서를 사용하여 주문 패키지를 만들고, 주문을 업데이트하고, 알림을 보낼 것입니다.

00:08:48.000 --> 00:08:54.000
이제 설정을 완료했으므로, Apple Pay 구매 흐름 내에서 바로 지갑에 주문을 추가할 수 있습니다.

00:08:54.000 --> 00:09:00.000
그렇게 하기 위해, 당신이 이전에 인식해야 할 간단한 지불 처리 흐름을 되돌아봅시다.

00:09:00.000 --> 00:09:03.000
우리는 이미 당신의 서버가 처리를 위해 지불 정보를 보냈다는 것을 알고 있습니다.

00:09:03.000 --> 00:09:08.000
결제가 성공적으로 처리되면, 서버는 주문을 생성해야 합니다.

00:09:08.000 --> 00:09:14.000
반품한 결과에서 주문 추적을 지원하려면, 당신이 만든 주문에 대한 몇 가지 세부 사항도 포함해야 합니다.

00:09:14.000 --> 00:09:19.000
이러한 주문 세부 사항을 통해 장치는 서버에서 비동기적으로 주문을 요청할 수 있습니다.

00:09:19.000 --> 00:09:23.000
그런 다음 서버는 주문 패키지를 장치로 전환하여 지갑에 표시됩니다.

00:09:23.000 --> 00:09:30.000
현재로서는, PKPayment 승인 결과의 일부로 반품해야 할 주문 세부 사항을 자세히 살펴봅시다.

00:09:30.000 --> 00:09:33.000
주문 세부 사항은 네 개의 필드로 구성되어 있다.

00:09:33.000 --> 00:09:37.000
주문 유형 식별자는 단순히 이전에 만든 것입니다.

00:09:37.000 --> 00:09:43.000
주문을 식별하는 방법을 생성해야 하지만, 주문 유형 식별자의 범위 내에서 고유해야 합니다.

00:09:43.000 --> 00:09:47.000
웹 서비스의 URL을 포함하세요.

00:09:47.000 --> 00:09:51.000
마지막으로, 당신의 서버는 안전한 인증 토큰을 생성해야 합니다.

00:09:51.000 --> 00:09:54.000
이것은 사용자의 장치와 서버 간의 공유 비밀입니다.

00:09:54.000 --> 00:10:00.000
장치는 주문 패키지를 요청할 때 이 토큰을 사용하여 스스로를 인증할 것이다.

00:10:00.000 --> 00:10:05.000
이 예는 처음에 우리가 이전에 본 일반적인 지불 승인 흐름과 매우 유사해 보인다.

00:10:05.000 --> 00:10:07.000
주문 세부 사항을 추가해 봅시다.

00:10:07.000 --> 00:10:19.000
먼저, serverResult에서 가져온 다음 PKPaymentOrderDetails 객체를 만들고 주문 유형 ID, 주문 ID, 웹 서비스 URL 및 인증 토큰을 설정합니다.

00:10:19.000 --> 00:10:23.000
이것을 PKPayment 승인 결과에 할당하세요.

00:10:23.000 --> 00:10:29.000
웹에서 W3C 지불 요청 API를 사용하여 주문 세부 정보를 추가하는 것도 간단합니다.

00:10:29.000 --> 00:10:33.000
이전과 마찬가지로, 서버 결과에서 주문 세부 사항을 추출하세요.

00:10:33.000 --> 00:10:38.000
이 주문 세부 사항과 결제를 완료한 데이터를 반환하세요.

00:10:38.000 --> 00:10:44.000
주문 세부 사항이 장치가 반환된 후, 이러한 세부 사항은 각 사용자의 장치에서 동기화됩니다.

00:10:44.000 --> 00:10:49.000
각 장치는 주문 세부 사항을 제공하는 서버에서 주문 패키지를 요청할 것입니다.

00:10:49.000 --> 00:10:54.000
주문 세부 사항과 함께 보낸 토큰과 일치시켜 인증 토큰을 확인하세요.

00:10:54.000 --> 00:10:59.000
인증 토큰이 일치하는 경우, 주문 패키지를 장치로 반환하십시오.

00:10:59.000 --> 00:11:03.000
이제 주문이 그 장치의 지갑에 표시될 준비가 되었습니다.

00:11:03.000 --> 00:11:09.000
장치가 요청하는 즉시 사용할 수 있도록 가능한 한 빨리 주문을 수리하려고 시도해야 합니다.

00:11:09.000 --> 00:11:16.000
서버가 주문을 반환하지 못하면, 장치는 기하급수적인 백오프로 여러 번의 재시도 시도를 시도할 것입니다.

00:11:16.000 --> 00:11:22.000
우리는 지금 이 주문 패키지가 여러 번 참조되는 것을 보았지만, 정확히 무엇으로 구성되어 있나요?

00:11:22.000 --> 00:11:25.000
주문은 주문 패키지로 배포됩니다.

00:11:25.000 --> 00:11:29.000
그것들은 당신의 주문을 사용자에게 표시하고 그것이 당신에게서 왔다는 것을 증명하는 데 필요한 모든 것을 포함합니다.

00:11:29.000 --> 00:11:38.000
주문 패키지에는 주문, 로고와 같은 이미지 및 주문의 각 항목에 대한 인라인 이미지를 설명하는 JSON 사전이 포함되어 있습니다.

00:11:38.000 --> 00:11:43.000
이미지 제작에 대한 지침은 휴먼 인터페이스 지침과 추천 출처를 참조하십시오.

00:11:43.000 --> 00:11:47.000
또한 문자열 파일과 같은 현지화된 리소스를 포함하세요.

00:11:47.000 --> 00:11:51.000
총 주문 크기를 주시하고 관련된 것만 포함하세요.

00:11:51.000 --> 00:11:56.000
이 모든 내용은 "매니페스트"라고 불리는 또 다른 JSON 사전에 설명되어 있다.

00:11:56.000 --> 00:11:58.000
당신은 그것을 목차처럼 생각할 수 있습니다.

00:11:58.000 --> 00:12:02.000
그것은 주문 패키지의 모든 파일에 대한 참조를 포함한다.

00:12:02.000 --> 00:12:11.000
항목의 키는 상대 파일 경로이며 값은 구문 분석에 사용되는 것과 다른 체크섬인 파일의 SHA256 체크섬입니다.

00:12:11.000 --> 00:12:15.000
이제 우리가 해야 할 일은 그 진위를 증명하기 위해 소포에 서명하는 것이다.

00:12:15.000 --> 00:12:20.000
서명은 주문 패키지가 신뢰할 수 있는 출처인 당신으로부터 유래했다는 것을 확인합니다.

00:12:20.000 --> 00:12:26.000
그것은 구문 분석과 같은 매니페스트의 분리된 암호화 메시지 서명이다.

00:12:26.000 --> 00:12:36.000
주문 유형 ID 인증서와 Apple Worldwide Developer Relations Intermediate 인증서와 관련된 개인 키로 매니페스트에 서명하여 갱신된 버전의 인증서를 사용할 수 있습니다.

00:12:36.000 --> 00:12:42.000
주문 작성을 완료하려면, 패키지를 압축하고 파일 확장자를 주문으로 변경하기만 하면 됩니다.

00:12:42.000 --> 00:12:45.000
이제 주문을 업데이트할 시간입니다.

00:12:45.000 --> 00:12:53.000
주문 정보는 시간이 지남에 따라 종종 바뀝니다. 예를 들어, 고객이 이전에 만든 애완 동물 상품 주문이 지금 진행 중입니다.

00:12:53.000 --> 00:12:59.000
자동 업데이트를 지원하면 이 업데이트를 고객에게 빠르고 안전하게 전달할 수 있습니다.

00:12:59.000 --> 00:13:07.000
당신의 고객은 이제 지갑에 애완동물 용품 주문을 가지고 있으며, 주문은 업데이트 지원을 나타내므로, 장치는 당신의 웹 서비스에 등록할 것입니다.

00:13:07.000 --> 00:13:15.000
나중에, 고객의 주문은 이제 배송을 위해 발송되었으므로, 서버는 등록 정보를 사용하여 등록된 모든 장치에 알릴 것입니다.

00:13:15.000 --> 00:13:21.000
고객의 장치가 푸시 알림을 받으면, 이제 서버에서 주문을 요청할 것입니다.

00:13:21.000 --> 00:13:25.000
그런 다음 서버는 업데이트된 주문 패키지를 장치로 반환합니다.

00:13:25.000 --> 00:13:32.000
이제 기본 주문 흐름이 어떻게 작동하는지 알았으니, 주문 업데이트를 지원하기 위해 취해야 할 정확한 단계를 분석해 봅시다.

00:13:32.000 --> 00:13:36.000
먼저, 주문에 대한 업데이트를 지원한다는 것을 표시하세요.

00:13:36.000 --> 00:13:43.000
지갑에 주문이 업데이트를 지원한다고 말하는 것은 매우 쉽습니다. 주문 패키지에 두 가지 정보를 포함하기만 하면 됩니다.

00:13:43.000 --> 00:13:47.000
Order.json에서, 원하는 webServiceURL을 추가하세요.

00:13:47.000 --> 00:13:51.000
이것은 당신이 주문 세부 사항에서 제공한 것과 동일합니다.

00:13:51.000 --> 00:13:57.000
또한 지갑이 주문 업데이트를 요청할 때 진위를 증명하는 데 사용할 인증 토큰 필드를 추가하세요.

00:13:57.000 --> 00:14:02.000
장치가 등록에서 추가 또는 제거를 요청할 때 관리해야 합니다.

00:14:02.000 --> 00:14:07.000
당신의 서버는 등록 정보의 추가 또는 제거를 처리할 수 있어야 합니다.

00:14:07.000 --> 00:14:11.000
주문 업데이트를 위해 등록한 장치를 찾을 수 있어야 합니다.

00:14:11.000 --> 00:14:15.000
이렇게 하면 주문을 업데이트할 때 서버가 이러한 장치에 알릴 수 있습니다.

00:14:15.000 --> 00:14:23.000
서버는 또한 어떤 업데이트된 주문이 해당 장치와 관련이 있는지 알 수 있도록 장치가 등록한 주문을 찾을 수 있어야 합니다.

00:14:23.000 --> 00:14:26.000
이 정보를 구조화할 수 있는 다양한 방법이 있습니다.

00:14:26.000 --> 00:14:35.000
한 가지 방법은 두 개의 엔티티(하나는 장치용, 다른 하나는 주문용)와 등록을 위한 다대다 관계가 있는 관계형 데이터베이스를 사용하는 것이다.

00:14:35.000 --> 00:14:40.000
주문이 업데이트되면, 서버는 등록된 장치에 알려야 합니다.

00:14:40.000 --> 00:14:50.000
따라서 서버는 저장된 등록 정보를 기반으로 관련 장치를 잡은 다음 푸시 토큰을 사용하여 각 장치에 푸시 알림을 보내야 합니다.

00:14:50.000 --> 00:14:54.000
주문 유형 ID는 푸시 토픽으로 두 배가 되며, 페이로드는 비어 있어야 합니다.

00:14:54.000 --> 00:14:59.000
주문 유형 ID 인증서를 사용하여 APNs와 통신할 수 있습니다.

00:14:59.000 --> 00:15:08.000
알림에 대해 주의해야 할 한 가지 더 사항은 주문 패키지에서 열거형 속성 변경 알림을 설정하여 주문 알림을 전달하는 방법을 사용자 정의할 수 있다는 것입니다.

00:15:08.000 --> 00:15:16.000
사용 가능한 옵션은 항상 주문 업데이트 알림을 보내고 기본값인 활성화되어 있습니다.

00:15:16.000 --> 00:15:26.000
지갑이 알림을 복제하지 않도록 하려면, 사용자가 주문 패키지에 나열한 앱이 설치되어 있는 경우 알림을 보내지 않는 disableIfAppInstalled를 설정하십시오.

00:15:26.000 --> 00:15:32.000
등록된 장치는 각각 서버가 제공할 새로운 주문 패키지를 요청할 것입니다.

00:15:32.000 --> 00:15:38.000
장치가 푸시 알림을 받으면, 푸시 알림이 비어 있기 때문에 어떤 주문이 변경되었는지 아직 알 수 없습니다.

00:15:38.000 --> 00:15:44.000
서버와 함께, 장치는 마지막으로 요청한 이후로 어떤 주문이 변경되었는지 파악합니다.

00:15:44.000 --> 00:15:50.000
서버에 저장된 등록 정보를 사용하여 관련 주문을 찾은 다음 ID를 반환하십시오.

00:15:50.000 --> 00:15:58.000
업데이트 시간을 추적하고 향후 요청에 의해 반환되는 주문 ID 수를 제한하기 위해 응답에 수정 태그를 포함하세요.

00:15:58.000 --> 00:16:01.000
예를 들어, 타임스탬프를 사용할 수 있습니다.

00:16:01.000 --> 00:16:03.000
그 값은 장치에 불투명하다.

00:16:03.000 --> 00:16:08.000
그 장치는 다음에 변경을 요청할 때 수정 태그를 제공할 것이다.

00:16:08.000 --> 00:16:13.000
마지막으로, 장치는 서버가 업데이트된 각 주문에 대한 최신 패키지를 요청할 것입니다.

00:16:13.000 --> 00:16:16.000
우리는 오늘 많은 것을 다루었다.

00:16:16.000 --> 00:16:19.000
가능한 최고의 고객 경험을 제공하기 위해 이러한 관행을 따르세요.

00:16:19.000 --> 00:16:26.000
Apple Pay를 구현할 때, 제품이나 장바구니 페이지에 Apple Pay 버튼을 표시하여 익스프레스 체크아웃을 제공하십시오.

00:16:26.000 --> 00:16:31.000
사용자는 결제 시트에서 직접 배송 옵션과 주소를 선택하고 아무것도 입력하지 않고 체크아웃할 수 있습니다.

00:16:31.000 --> 00:16:38.000
주문 추적을 구현할 때, 고객 선호도에 대한 지식을 사용하여 관련 현지화만 제공하십시오.

00:16:38.000 --> 00:16:43.000
또한, 주문 패키지 크기를 작게 유지하기 위해 포함하는 자산의 수에 유의하십시오.

00:16:43.000 --> 00:16:48.000
주문을 업데이트할 때, 업데이트를 위해 등록된 장치에 즉시 알리십시오.

00:16:48.000 --> 00:16:51.000
지갑의 주문은 주문의 실제 상태와 일치해야 합니다.

00:16:51.000 --> 00:16:58.000
주문 추적과 Apple Pay 버튼 표시에 대한 휴먼 인터페이스 지침도 확인하십시오.

00:16:58.000 --> 00:17:02.000
오늘, 저는 건물을 통해 Apple Pay를 구현하고 주문을 업데이트하는 것을 다루었습니다.

00:17:02.000 --> 00:17:12.000
이 강연은 Apple Pay 및 주문 추적 구현을 소개하기 위한 것이지만, 자세한 내용을 자세히 알아보려면 세션 노트에 링크된 문서를 반드시 확인해야 합니다.

00:17:12.000 --> 00:17:16.000
게다가, 당신은 우리의 가장 최근의 WWDC 비디오를 확인할 수 있습니다.

00:17:16.000 --> 00:17:19.000
오늘 시간 내줘서 정말 고마워.

00:17:19.000 --> 23:59:59.000
그리고 남은 하루 즐겁게 보내길 바라.

