WEBVTT

00:00:00.000 --> 00:00:10.000
메탈 2는 A11 GPU의 아키텍처와 새로운 기능을 활용하기 위해 새로운 API 세트와 셰이딩 언어 변경을 소개합니다.

00:00:10.000 --> 00:00:14.000
A11에서 Metal 2의 새로운 기능을 검토해 봅시다.

00:00:14.000 --> 00:00:18.000
애플은 GPU 아키텍처의 빠른 혁신을 가능하게 하기 위해 메탈을 설계했다.

00:00:18.000 --> 00:00:24.000
그리고 차례로, 애플 GPU 아키텍처는 메탈의 디자인을 알렸다.

00:00:24.000 --> 00:00:35.000
하드웨어와 소프트웨어의 깊고 원활한 통합은 그래픽, 컴퓨팅, 기계 학습 앱 및 게임에 대한 흥미진진한 새로운 가능성을 가능하게 합니다.

00:00:35.000 --> 00:00:45.000
메탈이 도입된 지 불과 3년 만에, 우리는 WWDC 2017에서 차세대 메탈인 메탈 2를 소개했다.

00:00:45.000 --> 00:01:06.000
깨끗하고 잘 구성된 디자인을 기반으로 하는 Metal 2는 GPU 기반 렌더링과 같은 GPU의 기능에 액세스할 수 있는 최첨단 방법을 포함하도록 확장되어 GPU가 그래픽 워크로드를 자체적으로 발송하여 효율성을 더욱 높이고 드로우 콜 비용을 최대 10배까지 줄일 수 있습니다.

00:01:06.000 --> 00:01:11.000
2015년에 메탈은 맥과 데스크톱 GPU를 지원하기 위해 확장했다.

00:01:11.000 --> 00:01:19.000
이제 Metal 2는 기본 GPU 아키텍처에 관계없이 주요 기능을 균일하게 노출하기 위해 API를 정렬합니다.

00:01:19.000 --> 00:01:34.000
다양한 영역에서 기계 학습의 증가와 함께, Metal 2는 성능과 효율성을 개선하기 위해 추론 작업을 가속화하는 것을 목표로 하는 더 넓고 정교한 기능 세트를 제공합니다.

00:01:34.000 --> 00:01:43.000
Metal 2는 또한 Apple 플랫폼에서 GPU의 힘을 훨씬 더 쉽게 활용할 수 있는 새로운 최적화 도구 세트를 제공합니다.

00:01:43.000 --> 00:01:50.000
그리고 이제, 우리는 WWDC에서 발표하지 않은 더 많은 Metal 2 기능을 공개할 수 있습니다.

00:01:50.000 --> 00:02:02.000
메탈 2에는 최신 A-시리즈 칩인 A11에서 애플이 설계한 GPU의 고유한 기능을 드러내는 강력한 새로운 기능이 포함되어 있습니다.

00:02:02.000 --> 00:02:13.000
A11 GPU 아키텍처와 기능의 세부 사항에 들어가기 전에, 고전적인 GPU와 타일 기반 지연 렌더링 아키텍처의 아키텍처를 검토해 봅시다.

00:02:13.000 --> 00:02:17.000
이것은 고전적인 GPU 아키텍처의 단순화된 도표이다.

00:02:17.000 --> 00:02:20.000
GPU는 대규모 병렬 기계이다.

00:02:20.000 --> 00:02:27.000
이 다이어그램에 표시된 정점과 조각 단계는 여러 번 복제되며, 병렬로 실행됩니다.

00:02:27.000 --> 00:02:37.000
또한 이 다이어그램에 표시되지 않은 캐시 계층 구조, FIFO, 초기 거친 깊이 테스트 등과 같은 많은 최적화가 있습니다.

00:02:37.000 --> 00:02:46.000
기본적으로, 고전적인 아키텍처를 가진 GPU는 프리미티브를 취하고 깊이, 색상, 데이터 버퍼 및 텍스처를 생성합니다.

00:02:46.000 --> 00:02:55.000
이 아키텍처의 정의 특성 중 하나는 정점 단계의 출력이 조각 단계로 직접 공급된다는 것이다.

00:02:55.000 --> 00:03:01.000
TBDR로도 알려진 타일 기반 지연 렌더링 아키텍처를 살펴봅시다.

00:03:01.000 --> 00:03:06.000
모든 A 시리즈 GPU는 TBDR 아키텍처를 기반으로 한다.

00:03:06.000 --> 00:03:11.000
TBDR은 고전적인 GPU 아키텍처에 몇 가지 중요한 변화를 일으킨다.

00:03:11.000 --> 00:03:17.000
첫 번째 주요 차이점은 정점 단계가 파편 단계로 직접 공급되지 않는다는 것이다.

00:03:17.000 --> 00:03:26.000
대신, 그들이 정점 단계에서 나올 때, 프리미티브는 화면 정렬된 작은 타일에 저장되어 메모리에 저장된다.

00:03:26.000 --> 00:03:31.000
이 변화는 정점 단계가 조각 단계에 비해 비동기적으로 실행될 수 있게 해준다.

00:03:31.000 --> 00:03:39.000
렌더패스의 프래그먼트 단계를 실행하는 동안, 하드웨어는 미래의 렌더패스의 정점 단계를 실행한다.

00:03:39.000 --> 00:03:44.000
정점 단계를 비동기적으로 실행하면 상당한 성능 향상을 제공합니다.

00:03:44.000 --> 00:03:52.000
정점 단계는 일반적으로 고정 기능 하드웨어를 많이 사용하는 반면, 조각 단계는 수학과 대역폭의 많은 사용자이다.

00:03:52.000 --> 00:03:58.000
그것들을 완전히 겹치면 GPU의 모든 하드웨어 블록을 동시에 사용할 수 있습니다.

00:03:58.000 --> 00:04:03.000
타일에 있는 프리미티브를 사용하면 타일의 모든 프리미티브를 모두 함께 처리할 수 있습니다.

00:04:03.000 --> 00:04:06.000
우리가 그것을 어떻게 활용할 수 있는지 봅시다.

00:04:06.000 --> 00:04:14.000
우리는 셰이더 코어 옆에 있는 칩에 타일 크기의 전체 해상도, 깊이, 스텐실 및 프레임 버퍼를 배치했습니다.

00:04:14.000 --> 00:04:17.000
우리는 이것을 메모리 타일 메모리라고 부른다.

00:04:17.000 --> 00:04:20.000
타일 메모리에는 세 가지 중요한 특징이 있다.

00:04:20.000 --> 00:04:33.000
첫째, 셰이더 코어와 타일 메모리 사이의 대역폭은 GPU와 외부 메모리 사이의 대역폭보다 몇 배 더 높으며, 셰이더 코어 수에 비례하여 확장됩니다.

00:04:33.000 --> 00:04:40.000
둘째, 타일 메모리에 대한 메모리 액세스 대기 시간은 외부 메모리에 대한 액세스 대기 시간보다 몇 배 낮습니다.

00:04:40.000 --> 00:04:46.000
마지막으로, 타일 메모리는 외부 메모리보다 훨씬 낮은 전력을 소비한다.

00:04:46.000 --> 00:04:54.000
TBDR은 두 가지 주요 최적화를 위해 이 저지연, 저전력 소비, 고대역폭 메모리를 사용합니다.

00:04:54.000 --> 00:05:12.000
첫째, 타일 깊이/스텐실 메모리를 사용하면 하드웨어가 셰이딩 코어가 처리를 시작하기 전에 불투명한 물체에 대한 전체 깊이와 스텐실 버퍼 정보를 생성할 수 있으므로 하드웨어가 셰이더 코어로 보내기 전에 가려진 조각을 완벽하게 차단할 수 있습니다.

00:05:12.000 --> 00:05:26.000
후속 렌더링 패스에 깊이 버퍼가 필요하지 않은 경우, 메모리 없는 렌더링 대상을 사용하여 풀 사이즈 깊이 버퍼를 완전히 제거하여 많은 양의 메모리 대역폭, 저장 및 전력을 절약할 수 있습니다.

00:05:26.000 --> 00:05:30.000
둘째, 타일 메모리는 칩에 색상 버퍼를 저장하는 데 사용됩니다.

00:05:30.000 --> 00:05:37.000
블렌딩 작업은 외부 메모리의 풀사이즈 프레임 버퍼에 액세스할 필요가 없기 때문에 빠릅니다.

00:05:37.000 --> 00:05:45.000
타일 메모리는 전체 타일이 처리된 후 한 번만 기록되며, 상당한 양의 전력, 성능 및 대역폭을 절약합니다.

00:05:45.000 --> 00:05:49.000
더 빠른 메모리 덕분에 더 높은 점유율을 얻을 수 있다.

00:05:49.000 --> 00:05:55.000
프레임버퍼 가져오기 기능을 사용하면 사용자 지정 블렌딩을 구현하고 몇 가지 고급 기술을 사용할 수 있습니다.

00:05:55.000 --> 00:06:02.000
메모리 없는 프레임 버퍼와 결합하여, 이러한 많은 기술은 외부 메모리를 소비할 필요가 없다.

00:06:02.000 --> 00:06:08.000
결과적으로, TBDR은 대역폭이 제한된 경우에도 훌륭한 성능을 제공합니다.

00:06:08.000 --> 00:06:14.000
TBDR은 배터리 구동 장치에 필수적인 훨씬 낮은 전력을 소비한다.

00:06:14.000 --> 00:06:17.000
이제 기어를 A11 GPU로 전환합시다.

00:06:17.000 --> 00:06:29.000
A11에서 GPU 아키텍처에 대한 첫 번째 주요 변경 사항은 조각 함수에서 타일 메모리에 있는 데이터를 직접 제어할 수 있도록 하는 것입니다.

00:06:29.000 --> 00:06:33.000
이미지 블록은 타일 메모리에 있는 이미지 데이터에 대한 최적화된 액세스를 제공합니다.

00:06:33.000 --> 00:06:41.000
애플리케이션에 적합한 방식으로 픽셀을 배치할 수 있지만, 여전히 효율적으로 렌더링할 수 있습니다.

00:06:41.000 --> 00:06:45.000
이미지 블록은 타일 메모리의 2D 데이터 구조이다.

00:06:45.000 --> 00:06:49.000
너비, 높이, 깊이 및 형식을 지정할 수 있습니다.

00:06:49.000 --> 00:06:58.000
Metal 2는 음영 언어에 텍스처 픽셀 형식을 추가하여 포장된 데이터 유형을 통해 픽셀 레이아웃을 완벽하게 제어할 수 있습니다.

00:06:58.000 --> 00:07:06.000
두 번째 주요 아키텍처 변경을 통해 타일 메모리에 동시에 저장된 모든 픽셀에 액세스할 수 있습니다.

00:07:06.000 --> 00:07:15.000
타일 셰이딩은 렌더링 패스 내에서 인라인 컴퓨팅 기능을 제공하는 Apple의 A11 GPU의 새로운 프로그래밍 가능한 단계입니다.

00:07:15.000 --> 00:07:21.000
타일 셰이딩은 메탈 2에서 완전히 새로운 수준의 성능과 효율성을 가능하게 한다.

00:07:21.000 --> 00:07:28.000
렌더링 및 컴퓨팅 작업은 이제 더 높은 대역폭, 더 낮은 대기 시간 및 더 낮은 전력 타일 메모리를 통해 데이터를 공유할 수 있습니다.

00:07:28.000 --> 00:07:31.000
타일 셰이딩은 이미지 블록과 깊이 통합되어 있다.

00:07:31.000 --> 00:07:41.000
이미지 블록 콘텐츠를 분석하고, 해당 콘텐츠를 요약하고, 이미지 블록을 중간 장면에 저장하고, 심지어 이미지 블록 레이아웃을 변경할 수도 있습니다.

00:07:41.000 --> 00:07:45.000
일반 컴퓨팅 커널처럼 스레드 그룹 메모리를 사용할 수도 있습니다.

00:07:45.000 --> 00:07:49.000
타일 셰이더의 경우, 스레드 그룹 메모리는 지속적이다.

00:07:49.000 --> 00:07:57.000
타일 셰이더의 각 연속 호출은 이전 타일 셰이더에서 남은 값부터 시작하여 스레드 그룹 메모리에서 작동할 수 있습니다.

00:07:57.000 --> 00:08:00.000
이것은 이미지블록 메모리에도 해당된다.

00:08:00.000 --> 00:08:04.000
그들은 타일과 조각 셰이더의 호출 사이에서 지속적이다.

00:08:04.000 --> 00:08:11.000
또한, 우리는 이미지 블록과 타일 셰이딩을 지원하는 래스터 주문 그룹의 고급 버전을 도입하고 있습니다.

00:08:11.000 --> 00:08:19.000
그리고 마지막으로, 우리는 멀티 샘플링 이미지 블록의 샘플 커버리지를 완벽하게 제어할 수 있도록 금속 셰이딩 언어를 확장하고 있습니다.

00:08:19.000 --> 00:08:27.000
새로운 아키텍처와 새로운 Metal 2 기능을 잘 활용할 수 있는 렌더링 기술 세트를 봅시다.

00:08:27.000 --> 00:08:36.000
타일 셰이더, 이미지 블록 및 래스터 주문 그룹은 인터리브, 렌더링 및 컴퓨팅 패스를 단일 결합 패스로 결합할 수 있는 좋은 방법입니다.

00:08:36.000 --> 00:08:40.000
지연 렌더링과 타일 순방향 렌더링은 이런 식으로 가속화될 수 있다.

00:08:40.000 --> 00:08:44.000
타일로 된 전진 구현을 예로 들어 봅시다.

00:08:44.000 --> 00:09:02.000
지오메트리를 전달하여 먼저 온칩 깊이 정보를 만든 다음, 타일 셰이더를 실행하여 타일 최소 최대 깊이 정보를 만들고, 다른 타일 셰이더를 실행하여 스레드 그룹 메모리에 컬 라이트 목록을 만든 다음, 재료 셰이더를 실행할 수 있습니다.

00:09:02.000 --> 00:09:11.000
이러한 모든 작업은 하나의 결합 패스로 수행할 수 있으며, 많은 양의 대역폭, 스토리지 및 전력을 제거하여 성능을 향상시킬 수 있습니다.

00:09:11.000 --> 00:09:20.000
이러한 기능은 또한 주문 독립적인 투명성, 다층 알파 블렌딩 및 지표하 산란의 효율적인 구현을 가능하게 한다.

00:09:20.000 --> 00:09:31.000
샘플 커버리지 제어, 타일 셰이더 및 이미지 블록은 사용자 지정 MSAA 해결, MSAA 톤 매핑 및 표면 집계를 훨씬 더 효율적으로 수행할 수 있습니다.

00:09:31.000 --> 00:09:44.000
이러한 사용 사례 중 일부가 어떻게 가속화될 수 있는지 보여주기 위해, 우리는 지연 렌더링, 타일 순방향, 다층 알파 블렌딩 및 표면 집계를 위한 샘플 코드를 공개하고 있습니다.

00:09:44.000 --> 00:09:56.000
A11의 Metal 2는 이미지블록, 타일 셰이더, 이미지블록 샘플 커버리지 제어 및 래스터 주문 그룹을 도입하여 TBDR 아키텍처를 발전시킨다.

00:09:56.000 --> 00:10:06.000
또한, 우리는 컴퓨팅 스레드와 스레드 그룹 간에 데이터를 공유할 수 있는 새롭고 효율적인 메커니즘을 제공하기 위해 새로운 메탈 셰이딩 언어 변경을 도입했습니다.

00:10:06.000 --> 00:10:13.000
A11의 이것들과 다른 추가 기능과 성능 개선을 간략하게 검토해 봅시다.

00:10:13.000 --> 00:10:15.000
이미지 블록부터 시작합시다.

00:10:15.000 --> 00:10:19.000
이미지 블록은 타일 메모리의 2D 데이터 구조이다.

00:10:19.000 --> 00:10:27.000
조각 함수는 위치에 해당하는 단일 픽셀에만 액세스할 수 있는 반면, 커널은 전체 이미지 블록에 액세스할 수 있습니다.

00:10:27.000 --> 00:10:36.000
각 픽셀은 여러 구성 요소로 구성된 매우 복잡할 수 있으며, 각 구성 요소는 자체 이미지 평면으로 처리될 수 있다.

00:10:36.000 --> 00:10:40.000
이미지 블록은 또한 GPU의 포맷 변환 하드웨어에 대한 대량 액세스를 제공한다.

00:10:40.000 --> 00:10:48.000
부동 소수점 픽셀은 장치 메모리에 저장될 때 대상 텍스처 형식으로 변환됩니다.

00:10:48.000 --> 00:10:53.000
타일 셰이더는 렌더링 패스 내에서 인라인으로 컴퓨팅 기능을 제공합니다.

00:10:53.000 --> 00:11:00.000
타일 셰이더는 전체 이미지 블록에 액세스할 수 있으며, 일반 컴퓨팅 커널과 마찬가지로 스레드 그룹 메모리를 지원합니다.

00:11:00.000 --> 00:11:11.000
컴퓨팅 커널의 스레드 그룹 메모리와 달리, 타일 셰이더의 스레드 그룹 메모리는 색상 데이터가 그리기에서 지속되는 것처럼 타일의 수명 동안 지속됩니다.

00:11:11.000 --> 00:11:24.000
따라서 이전에는 프레임버퍼 가져오기 기능을 사용하여 픽셀 범위 내에서 그리기를 통해 통신하는 것으로 제한되기 전에, 이제 더 넓은 타일 범위를 사용하여 타일 디스패치와 조각 그리기 호출 간에 통신할 수 있습니다.

00:11:24.000 --> 00:11:29.000
이제 A11이 이전 세대에 비해 MSAA를 어떻게 향상시키는지 살펴봅시다.

00:11:29.000 --> 00:11:34.000
애플의 A-시리즈 GPU는 매우 효율적인 MSAA 구현을 가지고 있다.

00:11:34.000 --> 00:11:41.000
조각이 가장자리 조각이 아닌 경우, 하드웨어 블렌딩은 샘플당 한 번이 아니라 조각당 한 번 실행됩니다.

00:11:41.000 --> 00:11:49.000
또한, 타일 메모리에서 해결 첨부 파일로 직접 해결하고 추가 메모리 대역폭이 발생하지 않도록 할 수 있습니다.

00:11:49.000 --> 00:11:57.000
메탈의 메모리리스 렌더링 대상 기능을 사용하여 MSAA 렌더링 대상 메모리 스토리지를 완전히 제거할 수도 있습니다.

00:11:57.000 --> 00:12:01.000
A11의 Metal 2와 함께, 우리는 MSAA를 훨씬 더 발전시켰다.

00:12:01.000 --> 00:12:14.000
현재 A-시리즈 GPU는 이미 픽셀의 가장자리를 추적하지만, A11 GPU는 각 픽셀 내의 고유한 샘플 수를 추적하여 이 추적을 훨씬 더 미세한 세분화로 확장합니다.

00:12:14.000 --> 00:12:21.000
이 하드웨어 변경은 애플리케이션을 변경하지 않고도 멀티샘플 애플리케이션을 더 빠르게 만듭니다.

00:12:21.000 --> 00:12:29.000
A11을 사용하면 Metal 2는 이미지 블록 샘플 커버리지 제어를 통해 이 추적 메타데이터를 완벽하게 제어할 수 있습니다.

00:12:29.000 --> 00:12:34.000
또한 스레드 그룹 이미지 블록 및 타일 셰이더와 함께 이 기능을 활용할 수 있습니다.

00:12:34.000 --> 00:12:49.000
이미지블록 샘플 커버리지 제어를 통해 타일 파이프라인은 GPU의 샘플 커버리지 추적 데이터를 수정할 수 있으므로 사용자 지정 해결 알고리즘으로 렌더링 패스에서 언제든지 샘플 데이터를 해결할 수 있습니다.

00:12:49.000 --> 00:12:57.000
래스터 순서 그룹을 사용하면 제출 순서대로 겹치는 조각 함수에서 메모리에 액세스할 수 있으며, 조각 함수가 통신할 수 있습니다.

00:12:57.000 --> 00:13:01.000
A11은 래스터 주문 그룹의 기능을 확장한다.

00:13:01.000 --> 00:13:05.000
먼저, A11은 GPU의 내부 타일 메모리를 노출시킨다.

00:13:05.000 --> 00:13:12.000
래스터 주문 그룹은 타일 메모리를 예측 가능한 순서로 액세스하여 타일 메모리를 더 유용하게 만듭니다.

00:13:12.000 --> 00:13:27.000
둘째, 다른 GPU의 래스터 주문 그룹이 픽셀당 하나의 뮤텍스로 제한되는 경우, A11은 그보다 더 미세하게 갈 수 있어 더 가벼운 터치를 허용하고 스레드가 액세스를 기다리는 빈도를 최소화할 수 있습니다.

00:13:27.000 --> 00:13:32.000
이제 Metal 2가 스레드와 스레드 그룹 간의 데이터 공유를 어떻게 가속화하는지 살펴봅시다.

00:13:32.000 --> 00:13:38.000
메탈 2 셰이딩 언어는 메모리 순서와 범위 속성으로 원자 기능을 확장합니다.

00:13:38.000 --> 00:13:44.000
이러한 새로운 추가 사항은 스레드 간에 유연하고 효율적인 데이터 공유의 새로운 방법을 가능하게 한다.

00:13:44.000 --> 00:13:55.000
메탈 2 이전에, 스레드 그룹 간에 통신하려면 커널 실행을 완료하고 첫 번째 커널의 스레드 그룹의 출력을 소비하기 위해 새 커널을 발행해야 했다.

00:13:55.000 --> 00:13:59.000
메탈 2에서, 스레드 그룹은 서로 직접 통신할 수 있다.

00:13:59.000 --> 00:14:10.000
또한, 이러한 새로운 기능이 추가됨에 따라, 스레드 그룹 내의 스레드는 장벽을 사용하지 않고 통신할 수 있어 성능이 향상됩니다.

00:14:10.000 --> 00:14:16.000
우리는 또한 A11의 Metal 2에 몇 가지 다른 중요한 특징과 기능을 추가했습니다.

00:14:16.000 --> 00:14:24.000
A11에서, f16 수학은 반올림과 최대 값 처리 개선을 통해 전반적으로 더 나은 정확도를 가지고 있다.

00:14:24.000 --> 00:14:31.000
A11은 텍스처 큐브 배열에 대한 지원을 추가하고, 읽기-쓰기 텍스처 기능을 소개합니다.

00:14:31.000 --> 00:14:36.000
A11을 사용하면, 다양한 샘플러 커버리지가 A-시리즈 GPU에 제공됩니다.

00:14:36.000 --> 00:14:44.000
A11은 사후 심층 커버리지 기능을 추가하고 컴퓨팅 커널을 파견하는 보다 유연한 방법을 제공한다.

00:14:44.000 --> 00:14:48.000
A11은 쿼드 스코프 퍼뮤트 작업에 대한 지원도 추가한다.

00:14:48.000 --> 00:14:54.000
이러한 기능에 대한 자세한 내용은 Metal 2 문서를 확인하세요.

00:14:54.000 --> 00:14:58.000
A11은 GPU에 많은 중요한 성능을 향상시킨다.

00:14:58.000 --> 00:15:06.000
컴퓨터 비전, 이미지 처리 및 기계 학습 작업과 관련하여 최대 2배의 수학 성능을 가지고 있습니다.

00:15:06.000 --> 00:15:10.000
하지만 그것이 성과를 위한 유일한 개선 영역은 아니다.

00:15:10.000 --> 00:15:14.000
A11 GPU의 향상된 성능과 기능을 검토해 봅시다.

00:15:14.000 --> 00:15:22.000
우리는 A10 GPU와 비교할 때 클럭 사이클당 F16 수학 및 텍스처 필터링 속도를 두 배로 늘렸다.

00:15:22.000 --> 00:15:31.000
참고: A11에서 가능한 경우 셰이더에서 F16 데이터 유형을 사용하면 성능 차이가 훨씬 더 큽니다.

00:15:31.000 --> 00:15:36.000
우리는 A11에서 최대 스레드 그룹 크기를 512에서 1K로 두 배로 늘렸다.

00:15:36.000 --> 00:15:42.000
최대 다중 렌더링 대상 크기가 256비트에서 512비트로 증가했습니다.

00:15:42.000 --> 00:15:47.000
최대 스레드 그룹 메모리 크기는 16K에서 32K로 두 배가 되었다.

00:15:47.000 --> 00:15:51.000
우리는 또한 피드백 작업의 성과를 크게 개선했다.

00:15:51.000 --> 00:15:55.000
그것들은 알파 테스트와 폐기로도 알려져 있다.

00:15:55.000 --> 00:16:05.000
Metal 2에 대한 자세한 정보와 샘플 코드에 대한 링크는 개발자 웹사이트 developer.apple.com/metal을 방문하십시오.

00:16:05.000 --> 23:59:59.000
봐줘서 고마워!

