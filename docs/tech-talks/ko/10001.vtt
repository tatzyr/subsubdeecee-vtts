WEBVTT

00:00:01.000 --> 00:00:05.000
안녕하세요, 저는 GPU 소프트웨어 팀의 라이오넬 르마리에입니다.

00:00:05.000 --> 00:00:12.000
이 세션에서, 우리는 런타임에 정확한 GPU 타이밍을 얻기 위해 Metal Counter API를 사용할 것입니다.

00:00:12.000 --> 00:00:14.000
우리는 몇 가지 주제를 다룰 것이다.

00:00:14.000 --> 00:00:19.000
우리는 Metal Counter API의 빠른 소개로 시작할 것입니다.

00:00:19.000 --> 00:00:25.000
그런 다음 우리는 전형적인 라이브 프로파일링 HUD의 주요 특징을 간략하게 살펴볼 것입니다.

00:00:25.000 --> 00:00:31.000
우리는 프로파일링 정보를 수집하기 위해 API를 단계별로 사용할 것입니다.

00:00:31.000 --> 00:00:36.000
그리고 우리는 이 데이터가 HUD에 어떻게 맞는지 살펴서 결론을 내릴 것이다.

00:00:36.000 --> 00:00:40.000
그러니 API의 빠른 소개부터 시작합시다.

00:00:40.000 --> 00:00:44.000
메탈 카운터 API는 iOS 14의 새로운 기능이다.

00:00:44.000 --> 00:00:49.000
그것은 macOS Catalina에서 사용할 수 있었고 macOS Big Sur에서 확장되었다.

00:00:49.000 --> 00:00:55.000
Apple Silicon이 있는 iOS와 macOS에서는 무대 경계 타이밍에 액세스할 수 있습니다.

00:00:55.000 --> 00:01:01.000
즉, 정점, 조각 및 계산 패스의 정확한 시작 및 종료 시간입니다.

00:01:01.000 --> 00:01:12.000
인텔과 AMD GPU에서는 개별 패스 내에서도 그리기 경계 타이밍, 정확한 GPU 타임스탬프를 얻을 수 있습니다.

00:01:12.000 --> 00:01:18.000
다음으로, 라이브 프로파일링 HUD의 주요 기능을 간략하게 요약해 봅시다.

00:01:18.000 --> 00:01:22.000
라이브 HUD를 사용하여 런타임에 앱의 성능을 추적할 수 있습니다.

00:01:22.000 --> 00:01:28.000
Xcode 또는 Instruments에서 오프라인으로 조사해야 하는 문제 영역을 찾는 데 도움이 될 수 있습니다.

00:01:28.000 --> 00:01:34.000
예를 들어, 장치당 해상도와 품질 설정을 조정하는 데 사용할 수도 있습니다.

00:01:34.000 --> 00:01:39.000
예를 들어, 전형적인 라이브 HUD는 이렇게 보일 수 있다.

00:01:39.000 --> 00:01:51.000
프레임 시간은 스크롤 라인 차트로서 프레임 히치, 메모리 사용량, 해상도 등에 대한 통계 및 CPU 이벤트의 타임라인을 잡는 데 도움이 됩니다.

00:01:51.000 --> 00:01:55.000
그리고 오늘, 우리는 타임라인에 GPU 이벤트를 추가할 것이다.

00:01:55.000 --> 00:02:05.000
일반적으로 CPU 마커의 경우, 시작 및 종료 타임스탬프를 얻기 위해 mach_absolute_time을 사용하여 가장 중요한 기능을 계측할 것입니다.

00:02:05.000 --> 00:02:16.000
CPU 마커의 좋은 시작은 명령 버퍼 작업 주위에 두는 것입니다. 만들 때 시작 마커와 커밋할 때 끝 마커입니다.

00:02:16.000 --> 00:02:21.000
그것은 렌더링의 CPU 비용에 대한 개요를 제공합니다.

00:02:21.000 --> 00:02:25.000
이제 우리는 동등한 GPU 마커를 추가하고 싶습니다.

00:02:25.000 --> 00:02:31.000
여기서 볼 수 있듯이 Metal System Trace 타임라인의 GPU 이벤트에 익숙할 수 있습니다.

00:02:31.000 --> 00:02:37.000
이 예에서 iOS에서는 타일 기반 지연 렌더링 아키텍처의 여러 단계를 보여줍니다.

00:02:37.000 --> 00:02:42.000
여기서 우리는 정점과 조각 처리 작업을 본다.

00:02:42.000 --> 00:02:48.000
이를 위해, GPU 펌웨어는 정점 단계의 시작과 끝을 기록한다.

00:02:48.000 --> 00:02:52.000
그런 다음 조각 단계의 시작과 끝을 기록한다.

00:02:52.000 --> 00:02:57.000
그리고 금속 시스템 추적은 타임라인에 단계를 표시합니다.

00:02:57.000 --> 00:03:02.000
즉시 모드 GPU의 경우, 그리기 호출 그룹에 대한 이벤트를 기록할 수 있습니다.

00:03:02.000 --> 00:03:10.000
예를 들어, 모든 그리기 호출 전에 렌더링 객체 1의 시작을 기록한 다음 렌더링 객체 2의 시작을 기록합니다.

00:03:10.000 --> 00:03:13.000
그리고 마지막으로, 목표 2의 끝.

00:03:13.000 --> 00:03:20.000
그런 다음 GPU가 각 개체를 렌더링하는 데 얼마나 많은 시간을 소비하는지 정확하게 보여주는 타임라인이 있습니다.

00:03:20.000 --> 00:03:25.000
이제 그것을 달성하기 위해 Metal Counter API를 사용합시다.

00:03:25.000 --> 00:03:28.000
우리는 어떤 카운터 샘플링 모드를 사용할 수 있는지 확인하는 것으로 시작할 것입니다.

00:03:28.000 --> 00:03:39.000
우리는 GPU가 단계 경계, 정점, 조각 또는 계산 단계에 대해 기록해야 하는지, 아니면 우리가 방금 본 것처럼 그리기 경계에 기록해야 하는지 알아야 합니다.

00:03:39.000 --> 00:03:52.000
우리는 단순히 supportsCounterSampling API를 사용하여 현재 장치가 TBDR GPU의 스테이지 경계를 지원하는지 또는 무제한 모드 GPU의 경계를 그리는지 확인합니다.

00:03:52.000 --> 00:03:56.000
다음으로 우리는 장치에서 어떤 카운터 세트를 사용할 수 있는지 확인합니다.

00:03:56.000 --> 00:04:02.000
카운터 세트에는 타임스탬프, 스테이지 활용 및 파이프라인 통계가 포함됩니다.

00:04:02.000 --> 00:04:07.000
GPU 마커의 경우, 타임스탬프를 수집하는 카운터 세트가 필요합니다.

00:04:07.000 --> 00:04:14.000
그래서 우리는 장치에서 사용 가능한 모든 카운터 세트를 열거하고 타임스탬프를 위한 것을 선택합니다.

00:04:14.000 --> 00:04:23.000
올바른 카운터 세트가 있으면, 일부 장치가 지원하지 않을 수 있으므로 타임스탬프가 있는지 검사하십시오.

00:04:23.000 --> 00:04:25.000
우리는 초기 설정을 마쳤다.

00:04:25.000 --> 00:04:29.000
이제 각 프레임 동안 런타임에 무엇이 필요한지 봅시다.

00:04:29.000 --> 00:04:31.000
네 가지 쉬운 단계가 있다.

00:04:31.000 --> 00:04:38.000
먼저 우리는 방금 찾아본 크기, 저장 모드 및 카운터 세트로 샘플 버퍼를 만들 것입니다.

00:04:38.000 --> 00:04:41.000
그런 다음 우리는 패스 설명자에 샘플 버퍼를 추가할 것입니다.

00:04:41.000 --> 00:04:45.000
패스당 적어도 하나의 버퍼가 필요하다는 것을 의미합니다.

00:04:45.000 --> 00:04:52.000
다음으로, 드로우 경계에서 샘플링을 사용한다면, 중요한 지점에 샘플링 명령을 추가할 것입니다.

00:04:52.000 --> 00:04:56.000
마지막으로, 완료 핸들러에서, 우리는 카운터를 해결할 것이다.

00:04:56.000 --> 00:05:01.000
그리고 우리는 필요하다면 CPU와 GPU 타임스탬프를 정렬하는 것에 대해 이야기할 것이다.

00:05:01.000 --> 00:05:05.000
각 단계를 자세히 확인해 봅시다.

00:05:05.000 --> 00:05:09.000
먼저, 우리는 설명자를 사용하여 샘플 버퍼를 만듭니다.

00:05:09.000 --> 00:05:15.000
우리는 그것이 보관할 수 있는 최대 샘플 수를 지정하므로, 올바른 크기를 가지고 있습니다.

00:05:15.000 --> 00:05:19.000
우리는 여기서 여섯 개의 샘플을 사용할 것이지만, 당신은 일반적으로 그 이상을 사용할 것입니다.

00:05:19.000 --> 00:05:21.000
그리고 나서 우리는 저장 모드를 설정했다.

00:05:21.000 --> 00:05:24.000
공유 모드는 여기서 훌륭하다.

00:05:24.000 --> 00:05:29.000
그것은 많은 데이터가 아니며, 카운터에 더 쉽게 접근할 수 있게 해준다.

00:05:29.000 --> 00:05:33.000
우리는 사용할 카운터 세트, 타임스탬프를 위한 카운터 세트를 지정합니다.

00:05:33.000 --> 00:05:36.000
마지막으로, 우리는 샘플 버퍼를 만듭니다.

00:05:36.000 --> 00:05:41.000
지금까지는, 아주 좋아. 이제 우리는 여섯 개의 샘플을 위한 버퍼가 있다.

00:05:41.000 --> 00:05:45.000
예를 들어, 렌더링 인코더에서 사용합시다.

00:05:45.000 --> 00:05:49.000
당신은 컴퓨팅과 blit 인코더에 대해서도 똑같이 할 것입니다.

00:05:49.000 --> 00:05:55.000
이를 위해, 렌더링 패스 설명자의 샘플 버퍼 첨부 파일을 사용합니다.

00:05:55.000 --> 00:05:58.000
만약 우리가 무대 경계를 사용하고 있다면, 이것이 우리가 그것을 설정한 곳이다.

00:05:58.000 --> 00:06:02.000
우리는 정점 단계의 시작과 끝을 지정합니다.

00:06:02.000 --> 00:06:06.000
우리는 그것들을 인덱스 0과 샘플 버퍼의 1에 넣고 있다.

00:06:06.000 --> 00:06:12.000
그것이 GPU가 각 샘플을 어디에 쓸지 그리고 어디에서 검색할지 아는 방법입니다.

00:06:12.000 --> 00:06:15.000
조각 단계의 시작과 끝도 마찬가지입니다.

00:06:15.000 --> 00:06:22.000
마지막으로, 우리는 그 샘플을 저장하기 위해 방금 만든 샘플 버퍼를 지적했다.

00:06:22.000 --> 00:06:28.000
그리기 경계를 샘플링하려면, 명령 스트림의 핵심 지점에 샘플 명령을 추가합니다.

00:06:28.000 --> 00:06:34.000
이것들에 대한 첫 번째 명백한 배치는 모든 무승부 호출 전후이다.

00:06:34.000 --> 00:06:39.000
따라서 새 인코더를 만든 후, 즉시 샘플 명령을 추가합니다.

00:06:39.000 --> 00:06:46.000
우리는 이미 스테이지 경계 샘플을 위한 처음 네 개의 슬롯을 예약했기 때문에 그것을 인덱스 4에 넣을 것이다.

00:06:46.000 --> 00:06:54.000
모든 무승부 호출 후, 인코더를 끝내기 직전에 인덱스 5에 샘플 명령을 추가합니다.

00:06:54.000 --> 00:07:00.000
그래서 GPU는 그 인코더의 모든 작업 전후에 타임스탬프를 기록할 것이다.

00:07:00.000 --> 00:07:05.000
중요한 이정표를 표시하기 위해 그리기 호출 그룹 사이에 더 많은 샘플 명령을 추가할 수 있습니다.

00:07:05.000 --> 00:07:11.000
샘플 버퍼가 사전에 충분한 공간이 할당되었는지 확인하세요.

00:07:11.000 --> 00:07:17.000
말하자면, 우리는 단계 경계와 그리기 경계 샘플링 모두에 충분히 큰 버퍼를 할당했습니다.

00:07:17.000 --> 00:07:28.000
상호 배타적이기 때문에 무대에 충분히 할당하거나 경계 샘플링을 별도로 그려 쉽게 최적화할 수 있습니다.

00:07:28.000 --> 00:07:35.000
맞아. GPU는 단계에서 타임스탬프 카운터를 샘플링하거나 경계를 그리도록 지시받았다.

00:07:35.000 --> 00:07:40.000
다음으로, 우리는 렌더링이 완료될 때까지 기다린 다음, 핸들러에서 데이터를 수집합니다.

00:07:40.000 --> 00:07:43.000
우리가 인코더당 샘플 버퍼를 만들었다는 것을 기억하세요.

00:07:43.000 --> 00:07:49.000
따라서 일반적인 버퍼 완료 핸들러에서 여러 샘플 버퍼를 구문 분석해야 할 수도 있습니다.

00:07:49.000 --> 00:07:52.000
각각에 대해, 우리는 카운터를 해결한다.

00:07:52.000 --> 00:07:59.000
그것은 다른 특정 데이터를 구문 분석하기 매우 쉬운 통합 금속 구조체로 변환합니다.

00:07:59.000 --> 00:08:03.000
단순히 그것을 가리키고 CounterResult 구조를 사용하세요.

00:08:03.000 --> 00:08:09.000
우리가 vertexStart가 인덱스 0에 있어야 한다고 명시했기 때문에, 우리는 거기에서 직접 읽었다.

00:08:09.000 --> 00:08:13.000
그러면 우리는 다른 모든 샘플에 대해서도 똑같이 할 것이다.

00:08:13.000 --> 00:08:16.000
여기서 몇 가지 오류 확인이 필요하다는 점에 유의하십시오.

00:08:16.000 --> 00:08:27.000
GPU가 샘플 버퍼를 채우지 못했을 가능성이 있으므로 결과 단계가 예상 샘플 수를 수집하고 각 샘플이 유효한지 확인해야 합니다.

00:08:27.000 --> 00:08:34.000
GPU는 특정 타임스탬프를 얻을 수 없는 경우 미리 정의된 오류 값을 사용합니다.

00:08:34.000 --> 00:08:44.000
iOS 및 Apple Silicon 장치에서 GPU 타임스탬프는 mach_absolute_time에 정렬되어 있으므로 CPU 타임스탬프와 직접 비교할 수 있습니다.

00:08:44.000 --> 00:08:48.000
인텔과 AMD GPU에서는 추가 단계가 필요합니다.

00:08:48.000 --> 00:08:51.000
그것들은 벤더 특정 시간 영역에서 번역되어야 한다.

00:08:51.000 --> 00:09:05.000
이것은 GPU가 얼마나 바쁜지, 얼마나 많은 전력을 소비하는지, 얼마나 뜨거운지에 따라, 클럭 주파수는 시간이 지남에 따라 지속적으로 조정되어 타임스탬프에 영향을 미치기 때문입니다.

00:09:05.000 --> 00:09:15.000
즉시 모드 GPU에서 이 문제를 해결하려면, 샘플 타임스탬프의 API를 사용하여 주어진 시간에 일치하는 CPU 및 GPU 타임스탬프를 쿼리합니다.

00:09:15.000 --> 00:09:21.000
당신은 표류를 피하고 시간이 지남에 따라 정확한 상관 관계를 유지하기 위해 정기적으로 그것을 합니다.

00:09:21.000 --> 00:09:27.000
그런 다음 수집된 샘플의 간단한 선형 보간을 합니다.

00:09:27.000 --> 00:09:35.000
예를 들어, 공통 버퍼 완료 핸들러 내부의 샘플 타임스탬프를 호출하여 프레임당 하나의 상관 관계를 얻을 수 있습니다.

00:09:35.000 --> 00:09:39.000
T0에서 CPU와 GPU 타임스탬프를 쿼리한다고 가정해 봅시다.

00:09:39.000 --> 00:09:43.000
그리고 다음 프레임에서, 당신은 t1에서 그들에게 질문합니다.

00:09:43.000 --> 00:09:50.000
샘플 버퍼의 모든 GPU 카운터는 이제 CPU 도메인으로 다시 스케일링하고 오프셋할 수 있습니다.

00:09:50.000 --> 00:09:57.000
그리고 그게 우리가 필요한 전부야. 그래서 그것이 어떻게 모두 함께 표시될 수 있는지 봅시다.

00:09:57.000 --> 00:09:59.000
우리는 CPU 마커를 보고 있어.

00:09:59.000 --> 00:10:02.000
우리는 mach_absolute_time으로 그들을 잡았다.

00:10:02.000 --> 00:10:08.000
우리는 정점, 조각 및 컴퓨팅 단계가 모두 겹치고 CPU 활동과 정렬되는 것을 보고 있다.

00:10:08.000 --> 00:10:21.000
제시된 핸들러 내부에서 mach_absolute_time을 수집하여 모든 마커를 실제 유리 대 유리 프레임에 정렬하고 각 프레임 내의 모든 이벤트를 정확하게 표시할 수도 있습니다.

00:10:21.000 --> 00:10:34.000
이 HUD를 사용하면 CPU 또는 GPU 바운드 여부, 종속성 및 동기화 지점, 정점, 조각 및 컴퓨팅 작업의 고장 및 서로에 미치는 영향에 대한 훌륭한 시각을 얻을 수 있습니다.

00:10:34.000 --> 00:10:38.000
그 모든 것, 라이브, 바로 당신의 앱 안에 있습니다.

00:10:38.000 --> 00:10:41.000
당신이 조심할 수 있는 몇 가지가 있습니다.

00:10:41.000 --> 00:10:43.000
HUD를 너무 자주 업데이트하지 마세요.

00:10:43.000 --> 00:10:48.000
FPS 카운터와 마찬가지로, 라이브 데이터는 끊임없이 변화한다면 읽기 어려울 수 있다.

00:10:48.000 --> 00:10:55.000
예를 들어, 매 프레임마다 타임스탬프를 수집할 수 있지만, 초당 한 번만 화면의 마커를 업데이트할 수 있습니다.

00:10:55.000 --> 00:10:58.000
그것은 따라가는 것을 훨씬 더 쉽게 만든다.

00:10:58.000 --> 00:11:01.000
둘째, GPU 활동은 클럭 속도에 달려 있다.

00:11:01.000 --> 00:11:07.000
높은 GPU 점유율을 보는 것이 반드시 최대치라는 것을 의미하지는 않는다.

00:11:07.000 --> 00:11:13.000
그 시스템은 필요한 만큼의 전력만 사용하기 때문에, 전력과 성능의 균형을 맞출 것이다.

00:11:13.000 --> 00:11:17.000
결과적으로, 당신은 HUD에서 GPU가 80% 바쁜 것을 볼 수 있습니다.

00:11:17.000 --> 00:11:27.000
하지만 그것이 최대 클럭 속도의 절반으로 실행된다면, 그것은 실제로 최고 성능의 40%로 실행되고 충분한 헤드룸을 가질 것이다.

00:11:27.000 --> 00:11:32.000
그리고 항상 그렇듯이, 당신은 오류를 처리해야 하지만, 불일치도 조심해야 합니다.

00:11:32.000 --> 00:11:41.000
예를 들어, 카운터는 오버플로우할 수 있으며, 이로 인해 새로운 값이 이전 값보다 작아지고 음의 지속 시간을 유발할 수 있습니다.

00:11:41.000 --> 00:11:48.000
또는 카운터를 샘플링하는 동안 장치를 절전 모드로 전환하거나 최대 절전 모드로 전환하면 큰 이상값이 발생할 수 있습니다.

00:11:48.000 --> 00:11:54.000
그것들은 드문 사건이며, 디스플레이나 로그의 결함을 피하기 위해 우아하게 건너뛰어야 합니다.

00:11:54.000 --> 00:12:01.000
요약하자면, 우리는 Metal Counter API를 사용하여 GPU 타임스탬프를 수집하는 단계를 거쳤습니다.

00:12:01.000 --> 00:12:08.000
그렇게 하기 위해, 우리는 어떤 샘플링 모드가 지원되는지 알아내기 위해 장치 supportsCounterSampling 방법을 사용했습니다.

00:12:08.000 --> 00:12:13.000
우리는 GPU 타임스탬프가 있는 세트를 찾기 위해 카운터 세트를 열거했다.

00:12:13.000 --> 00:12:20.000
우리는 설명자를 사용하여 새로운 샘플 버퍼를 만들고 렌더링 명령 인코더에 사용했습니다.

00:12:20.000 --> 00:12:23.000
당신은 blit과 컴퓨팅 인코더로도 똑같이 하고 싶을 것입니다.

00:12:23.000 --> 00:12:28.000
우리는 모든 추첨 전후에 특정 샘플 명령을 추가했습니다.

00:12:28.000 --> 00:12:33.000
과거 타이밍을 얻기 위해 무승부, 디스패치 및 블리츠 사이에 그것들을 추가할 수 있습니다.

00:12:33.000 --> 00:12:37.000
우리는 카운터를 CPU 메모리로 해결했다.

00:12:37.000 --> 00:12:40.000
그리고 마지막으로, 우리는 필요하다면 그것들을 재정렬했다.

00:12:40.000 --> 00:12:48.000
그리고 그것으로, 당신은 강력한 라이브 GPU 프로파일링 HUD가 앱 위에 표시되는 데 필요한 모든 데이터를 가지고 있습니다.

00:12:48.000 --> 00:12:52.000
그리고 이 API를 사용하면 GPU 타임스탬프 이상의 것에 접근할 수 있습니다.

00:12:52.000 --> 00:12:58.000
단계별 정보를 요약할 수 있으며, 타임라인에서 이벤트를 그리지 않으면 더 쉽게 처리할 수 있습니다.

00:12:58.000 --> 00:13:08.000
그리고 중요한 것은, 정점 및 프래그먼트 셰이더, 컴퓨팅 커널 등에 대한 호출 수와 같은 심층적인 통계를 얻을 수 있다는 것입니다.

00:13:08.000 --> 00:13:18.000
Metal Counter API에는 탐색하기에 충분하며, 런타임에 GPU 성능을 프로파일링할 수 있는 많은 정보에 액세스할 수 있습니다.

00:13:18.000 --> 00:13:19.000
그게 이 세션을 위한 거야.

00:13:19.000 --> 23:59:59.000
봐줘서 고마워.

