WEBVTT

00:00:00.000 --> 00:00:05.000
안녕하세요, "유니폼 유형 식별자에 대한 재소개"에 오신 것을 환영합니다.

00:00:05.000 --> 00:00:10.000
제 이름은 조나단 그린스펀이고, 저는 애플의 앱 디스커버리 및 참여 팀에서 일하고 있습니다.

00:00:10.000 --> 00:00:16.000
우리가 마지막으로 유니폼 유형 식별자에 대해 이야기한 것은 WWDC 2004에서였다.

00:00:16.000 --> 00:00:21.000
그것은 오래 전이었지만, 나는 그것을 어제처럼 기억한다.

00:00:21.000 --> 00:00:35.000
애플의 2004년 제품 라인업은 파워북 G4의 모든 알루미늄 디자인, 아이팟 미니의 눈길을 끄는 색상, 아이맥 G5의 마법 같은 홈 시어터 경험과 같은 제품으로 고전적으로 멋졌다.

00:00:35.000 --> 00:00:42.000
애플은 굉장했지만, 2004년은 정말 오래 전이었다는 것을 인정해야 한다.

00:00:42.000 --> 00:00:50.000
그래서 우리는 오늘 애플의 운영 체제가 파일 유형을 결정하는 방법부터 시작하여 기본 사항을 다룰 것입니다.

00:00:50.000 --> 00:00:57.000
그런 다음 우리는 시스템에 모르는 새로운 파일 유형에 대해 말하는 방법과 그것들을 처리하는 방법을 탐구할 것이다.

00:00:57.000 --> 00:01:05.000
마지막으로, 우리는 파일 형식 작업을 쉽게 할 수 있는 iOS 14와 macOS Big Sur의 새로운 API를 살펴볼 것입니다.

00:01:05.000 --> 00:01:11.000
당신이 그 주제를 처음 접하든 아니든, 우리는 당신을 위한 무언가를 가지고 있으니, 주변에 머무르세요.

00:01:11.000 --> 00:01:17.000
누군가의 컴퓨터에 있을 수 있는 파일을 살펴봅시다: 아이패드 미니를 사용하는 고양이의 사진.

00:01:17.000 --> 00:01:22.000
그 사진을 디스크에 저장하면, 일반 파일이라고 불리는 것을 생성합니다.

00:01:22.000 --> 00:01:26.000
그것은 디스크에 저장된 일련의 바이트에 대한 POSIX 용어이다.

00:01:26.000 --> 00:01:34.000
나중에, 이 사진을 다시 열고 싶을 때, 두 번 클릭하면 미리보기와 같은 이미지 뷰어에서 열립니다.

00:01:34.000 --> 00:01:44.000
하지만 시스템은 이것이 텍스트 파일이나 MP3 트랙 또는 페이지 문서가 아닌 JPEG로 저장된 이미지라는 것을 어떻게 알 수 있습니까?

00:01:44.000 --> 00:01:54.000
파일은 바이트 시퀀스이므로, 시스템이 파일의 유형을 알아야 할 때, 그것을 열고 그것을 알아내기 위해 내부의 비트를 읽을 것으로 예상할 수 있습니다.

00:01:54.000 --> 00:02:03.000
사실, 그 시스템은 매우 비싸고 대부분의 프로세스가 가지고 있지 않은 읽기 권한이 필요하기 때문에 거의 그렇게 하지 않는다.

00:02:03.000 --> 00:02:09.000
사실, 운영 체제는 파일의 경로 확장에 대한 대부분의 결정을 기반으로 한다.

00:02:09.000 --> 00:02:18.000
그것은 공백이나 제어 문자를 포함하지 않는 한, 마지막 마침표 문자 다음에 나오는 대소문자 정규화된 부분 문자열이다.

00:02:18.000 --> 00:02:24.000
애플의 플랫폼에서, 우리는 일반적으로 사용자에게 인식된 경로 확장을 보여주지 않지만, 그들은 여전히 거기에 있다.

00:02:24.000 --> 00:02:32.000
이 파일의 경로 확장자를 공개하면, J-P-E-G임을 알 수 있으므로, 이것은 JPEG 이미지입니다.

00:02:32.000 --> 00:02:37.000
그래서 .jpeg는 JPEG 이미지를 의미합니다, 그렇죠?

00:02:37.000 --> 00:02:41.000
네, 하지만 JPEG 이미지에는 다른 경로 확장이 있습니다.

00:02:41.000 --> 00:02:45.000
.Jpg와 .jpe가 가장 일반적이다.

00:02:45.000 --> 00:02:48.000
그러나, 웹에서, 그것은 다른 이야기이다.

00:02:48.000 --> 00:02:52.000
웹 서버는 일반적으로 경로 확장자로 파일을 식별하지 않습니다.

00:02:52.000 --> 00:02:57.000
대신, 그들은 MIME 유형이나 미디어 유형이라고 불리는 것을 사용한다.

00:02:57.000 --> 00:03:01.000
JPEG의 경우, 그것은 이미지/jpeg입니다.

00:03:01.000 --> 00:03:11.000
물론, 인생에서 그렇게 간단한 것은 없으며, 일부 서버는 대신 일반적이지만 비표준 이미지/jpg MIME 유형을 사용합니다.

00:03:11.000 --> 00:03:16.000
그것은 다섯 개의 다른 메타데이터 조각이며, 모두 정확히 같은 것을 나타낸다.

00:03:16.000 --> 00:03:26.000
음, 애플의 플랫폼에서는 괜찮습니다. 왜냐하면 우리는 이 파일 형식을 표준적으로 식별하기 위해 균일한 유형 식별자라는 단일 문자열을 사용하기 때문입니다.

00:03:26.000 --> 00:03:31.000
JPEG 이미지의 경우, 균일한 유형 식별자는 public.jpeg입니다.

00:03:31.000 --> 00:03:37.000
이 하나의 문자열은 로컬이든 웹이든 모든 JPEG 이미지를 나타냅니다.

00:03:37.000 --> 00:03:41.000
이제, 파일 형식의 흥미로운 속성은 그들이 계층 구조에 존재한다는 것이다.

00:03:41.000 --> 00:03:49.000
모든 JPEG 이미지는 PNG 이미지, TIFF 이미지 등과 마찬가지로 더 추상적인 이미지이다.

00:03:49.000 --> 00:03:57.000
균일한 유형 식별자에 대해 이야기할 때, 우리는 JPEG 유형이 더 추상적인 이미지 유형을 준수한다고 말한다.

00:03:57.000 --> 00:04:01.000
이 적합성 트리는 암시적으로 다중 상속을 허용한다.

00:04:01.000 --> 00:04:07.000
생각해보면, 이것은 스위프트와 오브젝티브-C에서 프로토콜이 작동하는 방식과 같다.

00:04:07.000 --> 00:04:11.000
구체적인 클래스나 구조체는 여러 프로토콜에서 상속될 수 있다.

00:04:11.000 --> 00:04:13.000
내 말이 무슨 뜻인지 보여줄게.

00:04:13.000 --> 00:04:15.000
여기 public.jpeg가 있습니다.

00:04:15.000 --> 00:04:22.000
그리고 여기 모든 이미지 파일 형식을 설명하는 추상적인 유형인 public.image가 있습니다.

00:04:22.000 --> 00:04:27.000
하지만 모든 이미지 파일 형식은 바이트 시퀀스로 표현될 수 있다.

00:04:27.000 --> 00:04:39.000
따라서 public.image는 저장 위치에 관계없이 디스크의 일반 파일 또는 실제로 모든 바이트 시퀀스를 나타내는 매우 추상적인 유형인 public.data를 준수합니다.

00:04:39.000 --> 00:04:44.000
차례로, public.data는 하나의 최종 유형인 public.item을 준수한다.

00:04:44.000 --> 00:04:54.000
파일, 폴더, 심볼릭 링크 또는 POSIX 파이프와 같은 더 난해한 모든 파일 시스템 객체는 public.item으로 표시됩니다.

00:04:54.000 --> 00:04:58.000
우리가 계층 구조로 올라갈 수 있는 것처럼, 우리는 그것을 따라 내려갈 수 있다.

00:04:58.000 --> 00:05:07.000
Public.png 및 public.tiff와 같은 JPEG 이외의 이미지 형식이 있으며, public.image의 하위 유형이기도 합니다.

00:05:07.000 --> 00:05:11.000
그러나, 그들은 public.jpeg의 적합성 계층 구조의 일부가 아니다.

00:05:11.000 --> 00:05:13.000
그들은 그냥 형제자매일 뿐이야.

00:05:13.000 --> 00:05:24.000
우리가 레벨을 올라가고 public.data에 집중한다면, 컴퓨터의 거의 모든 것이 일련의 바이트로 표현될 수 있기 때문에, 그것에 부합하는 많은 유형이 있다는 것을 알 수 있습니다.

00:05:24.000 --> 00:05:33.000
여기서, 우리는 가청 소리를 설명하는 추상적인 유형인 public.audio와 읽을 수 있는 텍스트를 설명하는 추상적인 유형인 public.text를 볼 수 있습니다.

00:05:33.000 --> 00:05:39.000
그것들은 public.data의 하위 유형이며 public.image의 형제자매이다.

00:05:39.000 --> 00:05:44.000
나는 얼마 전에 균일한 유형 식별자로 다중 상속이 가능하다고 언급했다.

00:05:44.000 --> 00:05:55.000
그리고 이미지는 데이터이지만 사용자가 신경 쓰는 콘텐츠이기도 하며, 사용자가 iCloud Drive에 업로드하거나 AirDrop을 통해 공유하고 싶을 수도 있기 때문에 이미지도 마찬가지입니다.

00:05:55.000 --> 00:06:09.000
따라서 public.image는 또한 파일 시스템에서 구체적인 것을 나타내지 않는 public.content를 준수하지만, 하위 유형을 사용자에게 중요한 것으로 취급해야 한다고 알려줍니다.

00:06:09.000 --> 00:06:13.000
나는 균일한 유형 식별자가 파일을 어떻게 나타내는지에 꽤 집중했다.

00:06:13.000 --> 00:06:17.000
그것은 아마도 사용자에 관한 한 그들에게 가장 일반적인 사용일 것이다.

00:06:17.000 --> 00:06:22.000
하지만 우리는 다른 목적으로도 플랫폼 전반에 걸쳐 그것들을 사용합니다.

00:06:22.000 --> 00:06:26.000
예를 들어, 우리는 또한 그것들을 표준 유형의 페이스트보드 콘텐츠로 사용합니다.

00:06:26.000 --> 00:06:30.000
결국, 디스크에 저장할 수 있다면, 복사하여 붙여넣을 수도 있습니다.

00:06:30.000 --> 00:06:34.000
우리는 또한 파일과 아무 관련이 없는 계층을 위해 그것들을 사용합니다.

00:06:34.000 --> 00:06:41.000
이것은 약간의 애플의 비밀이지만, 우리는 또한 우리가 배송하는 다양한 하드웨어 모델을 식별하기 위해 균일한 유형 식별자를 사용합니다.

00:06:41.000 --> 00:06:46.000
예를 들어, 모든 Mac 모델은 com.apple.mac을 준수합니다.

00:06:46.000 --> 00:06:56.000
그리고 우리가 가설을 세우고 싶다면, 생명의 나무와 같은 컴퓨터와 관련이 없는 계층을 참조하기 위해 균일한 유형 식별자를 사용할 수도 있습니다.

00:06:56.000 --> 00:07:00.000
그것이 균일한 유형 식별자이며 우리가 플랫폼에서 그것들을 사용하는 방식이다.

00:07:00.000 --> 00:07:07.000
많은 앱이 자체 데이터 형식을 만들고 유지하며, 이러한 형식은 고유한 유형을 가질 자격이 있다.

00:07:07.000 --> 00:07:12.000
새로운 유형을 만들 때, 유형 계층 구조에 어떻게 추가하나요?

00:07:12.000 --> 00:07:16.000
시스템에 의해 선언된 유형을 사용하고 있다면, 많은 것을 할 필요가 없습니다.

00:07:16.000 --> 00:07:23.000
우리는 /System/Library/CoreServices의 CoreTypes라는 번들에 많은 유형을 포함합니다.

00:07:23.000 --> 00:07:30.000
해당 번들의 Info.plist의 모든 균일한 유형 식별자는 추가 변경 없이 앱에서 참조할 수 있습니다.

00:07:30.000 --> 00:07:37.000
하지만 당신이 발명했거나 다른 앱에서 빌린 유형의 경우, 시스템에 대해 말해야 할 수도 있습니다.

00:07:37.000 --> 00:07:43.000
그렇게 하려면, 자신만의 유니폼 유형 식별자를 만들어야 합니다.

00:07:43.000 --> 00:07:48.000
자신만의 균일한 유형 식별자를 만들 때, 따라야 할 몇 가지 명명 규칙이 있습니다.

00:07:48.000 --> 00:07:57.000
첫째, 균일한 유형 식별자는 항상 대소문자를 구분하지 않는 ASCII이며 com.example.file과 같이 항상 역방향 DNS입니다.

00:07:57.000 --> 00:08:00.000
이상적으로, 당신은 좀 더 설명적인 식별자를 사용할 것입니다.

00:08:00.000 --> 00:08:04.000
Com.example.file은 디버깅을 쉽게 만들지 않는다.

00:08:04.000 --> 00:08:13.000
Com.example.imagetemplate 또는 com.example.encrypteddatabase 또는 그와 비슷한 것이 더 나을 것이다.

00:08:13.000 --> 00:08:21.000
애플은 식별자에 일부 접두사나 네임스페이스를 보유하고 있으며, 이러한 네임스페이스를 사용하는 자체 식별자를 만들어서는 안 됩니다.

00:08:21.000 --> 00:08:24.000
당신이 그렇게 한다면 시스템은 그것들을 무시할 수 있습니다.

00:08:24.000 --> 00:08:29.000
첫 번째는 애플이 표준화된 유형을 선언하기 위해 사용할 수 있도록 예약된 "공개"이다.

00:08:29.000 --> 00:08:35.000
만약 우리가 표준화된 유형을 놓치고 있다면, 피드백 어시스턴트를 통해 알려주세요.

00:08:35.000 --> 00:08:42.000
동적의 줄임말인 dyn은 호환성 심을 생성할 때 운영 체제에서 사용할 수 있도록 예약되어 있다.

00:08:42.000 --> 00:08:49.000
그것들은 일반적으로 불투명한 문자열이며, OS 릴리스 간에 변경할 수 있으므로 값을 하드 코딩하지 마십시오.

00:08:49.000 --> 00:08:51.000
실제로, 그들은 요즘 꽤 드물다.

00:08:51.000 --> 00:08:57.000
일반적으로 인식할 수 없는 경로 확장자를 가진 파일을 만날 때만 볼 수 있습니다.

00:08:57.000 --> 00:09:03.000
Com.example은 템플릿, 예제, 샘플 코드 등 전용입니다.

00:09:03.000 --> 00:09:09.000
마지막으로, com.apple은 Apple이 사용할 수 있도록 예약되어 있습니다.

00:09:09.000 --> 00:09:15.000
시스템이 인식할 수 있는 유형을 애플리케이션에 추가할 때 취해야 할 두 가지 광범위한 단계가 있습니다.

00:09:15.000 --> 00:09:17.000
첫 번째 단계는 유형을 선언하는 것이다.

00:09:17.000 --> 00:09:25.000
유형을 선언하는 것은 기본적으로 앱이 "이 유형이 존재한다"고 말하는 것을 의미하지만, 유형을 열 수 있다는 것을 의미하지는 않습니다.

00:09:25.000 --> 00:09:33.000
실제로 유형을 열고 싶다면, "누가 유형을 선언하든, 나는 그것을 열 수 있다"고 말하는 앱의 방식인 유형을 지원해야 합니다.

00:09:33.000 --> 00:09:37.000
이 두 단계는 뚜렷하다.

00:09:37.000 --> 00:09:42.000
유형을 선언할 때, 수입할지 수출할지 결정해야 합니다.

00:09:42.000 --> 00:09:50.000
다른 사람이 발명하거나 설계한 유형을 사용하거나 주로 다른 응용 프로그램과 함께 사용하는 경우, 일반적으로 해당 유형을 가져와야 합니다.

00:09:50.000 --> 00:09:55.000
그것은 시스템에 "이 유형이 존재한다"고 말한다. 여기 그것에 대한 몇 가지 정보가 있습니다."

00:09:55.000 --> 00:10:02.000
하지만 그것을 발명한 앱이 설치되면, 그 앱은 더 권위 있는 정보를 제공할 수 있다.

00:10:02.000 --> 00:10:09.000
반면에, 유형을 발명했거나 앱과 함께 특별히 사용하기 위한 것이라면, 내보내는 것이 적절합니다.

00:10:09.000 --> 00:10:13.000
이것은 시스템에 "나는 이 유형에 대해 권위가 있다"고 말한다.

00:10:13.000 --> 00:10:20.000
마지막으로, 핵심 유형의 일부로 시스템과 함께 제공되는 유형을 사용하는 경우, 가져오거나 내보낼 필요가 없습니다.

00:10:20.000 --> 00:10:28.000
시스템은 이미 선언을 제공했으며, 유형의 균일한 유형 식별자를 즉시 사용할 수 있습니다.

00:10:28.000 --> 00:10:33.000
앱에서 유형을 선언하는 방법과 그것을 여는 것을 지원하는 시스템을 보여주는 방법을 보여주고 싶습니다.

00:10:33.000 --> 00:10:39.000
그래서 제가 웹을 통해 새로운 레스토랑 경험을 위해 열심히 일하고 있는 Xcode를 살펴봅시다.

00:10:39.000 --> 00:10:46.000
이 앱은 우리가 디자인한 JSON 기반 형식으로 저장된 레스토랑 메뉴를 읽을 수 있습니다.

00:10:46.000 --> 00:10:51.000
우리는 앱에서 메뉴 파일을 열 수 있기를 원하므로, 먼저 유형을 선언해야 합니다.

00:10:51.000 --> 00:10:58.000
우리가 이 유형을 직접 만들었고 형식을 소유하고 있기 때문에, 유형을 내보내는 것이 합리적이다.

00:10:58.000 --> 00:11:03.000
Xcode에서 가장 먼저 할 일은 프로젝트 자체를 선택하여 설정을 공개하는 것입니다.

00:11:03.000 --> 00:11:06.000
우리는 우리 앱에 해당하는 대상을 선택하고 싶습니다.

00:11:06.000 --> 00:11:12.000
지금, 저는 iOS 앱을 보고 있지만, 우리는 macOS 앱에 대해서도 같은 일을 할 것입니다.

00:11:12.000 --> 00:11:18.000
그런 다음 앱의 Info.plist 파일의 내용을 나타내는 정보 탭으로 전환할 것입니다.

00:11:18.000 --> 00:11:21.000
수출된 유형 식별자 섹션을 확장하세요.

00:11:21.000 --> 00:11:25.000
새 유형을 추가하려면 섹션 하단의 추가 버튼을 클릭하세요.

00:11:25.000 --> 00:11:32.000
우리가 가장 먼저 추가하고 싶은 것은 우리가 생각해낸 균일한 유형 식별자이다.

00:11:32.000 --> 00:11:37.000
이 데모를 위해, 우리는 com.example.restaurantmenu를 사용할 것이다.

00:11:37.000 --> 00:11:42.000
기억하세요, com.example은 Apple이 예제와 데모에 사용하기 위해 예약했습니다.

00:11:42.000 --> 00:11:46.000
당신은 보통 당신이 소유한 역방향 DNS 이름을 사용하고 싶을 것입니다.

00:11:46.000 --> 00:11:53.000
예를 들어, Claris는 com.claris를 사용하고 Beats는 com.beatsbydre를 사용할 것이다.

00:11:53.000 --> 00:11:58.000
이제 우리는 적합성에 대해 생각해야 한다.

00:11:58.000 --> 00:12:11.000
파일 시스템의 파일을 나타내는 유형은 일반 파일인 경우 public.data, 즉 바이트 시퀀스 또는 운영 체제가 파일로 취급해야 하는 디렉토리인 경우 com.apple.package를 준수해야 합니다.

00:12:11.000 --> 00:12:17.000
이 유형은 스위프트의 JSON 인코더를 사용하여 디스크에 저장될 것이며, 이는 바이트 시퀀스임을 의미합니다.

00:12:17.000 --> 00:12:22.000
그것은 일반 파일을 의미하며, 그것은 public.data를 의미한다.

00:12:22.000 --> 00:12:24.000
우리가 결정을 내려야 할 것 같아.

00:12:24.000 --> 00:12:30.000
이 파일들은 JSON 데이터를 포함하기 때문에, JSON 파일을 읽을 수 있는 모든 것을 읽을 수 있습니다.

00:12:30.000 --> 00:12:34.000
그것은 그 유형이 또한 public.json을 준수할 수 있다는 것을 의미한다.

00:12:34.000 --> 00:12:39.000
그것은 수동으로 편집할 수 있는 능력이 중요한 일부 파일 유형에 정말 유용한 속성이다.

00:12:39.000 --> 00:12:44.000
하지만 다른 유형의 경우, 그것은 구현 세부 사항일 뿐입니다.

00:12:44.000 --> 00:12:47.000
우리는 이 유형에 대해 public.json에 적합성을 추가할 것이다.

00:12:47.000 --> 00:12:57.000
다른 개발자가 의존하는 것을 원하지 않거나 향후 유형 형식이 변경될 것으로 예상되는 경우 유형을 만들 때 이러한 종류의 구현 세부 사항을 건너뛸 수 있습니다.

00:12:57.000 --> 00:13:03.000
이 파일 형식은 사용자가 직접 상호 작용할 가치가 있는 문서나 콘텐츠를 고려할 것이다.

00:13:03.000 --> 00:13:08.000
그래서 우리는 또한 그것이 public.content에 부합하는지 확인할 것이다.

00:13:08.000 --> 00:13:15.000
다음으로, 우리는 유형과 연결할 파일 이름 확장자를 결정해야 합니다.

00:13:15.000 --> 00:13:23.000
이 확장자는 유형을 파일 시스템에 다시 연결하고 시스템이 적절하게 명명된 파일에 이 유형이 있다는 것을 인식할 수 있도록 합니다.

00:13:23.000 --> 00:13:31.000
우리는 3자 확장을 사용하고 싶은 유혹을 받을 수도 있지만, 1995년 이후로 어떤 주요 플랫폼 공급 업체도 3자 확장을 요구하지 않았다.

00:13:31.000 --> 00:13:37.000
우리는 여기서 숨을 쉴 여지가 많으며, 다른 개발자의 유형 선언과의 충돌을 피하는 것이 중요합니다.

00:13:37.000 --> 00:13:42.000
그래서 우리는 더 긴 확장, 레스토랑 메뉴를 사용할 것이다.

00:13:42.000 --> 00:13:43.000
우리가 거기에 점을 넣지 않았다는 것을 알아두세요.

00:13:43.000 --> 00:13:48.000
운영 체제는 파일 이름을 만들 때 우리를 위해 그것을 추가하는 것을 알고 있다.

00:13:48.000 --> 00:13:53.000
마지막으로, 이것은 또한 이 유형의 사람이 읽을 수 있는 이름을 생각해 낼 수 있는 좋은 기회이다.

00:13:53.000 --> 00:14:03.000
우리의 앱은 단순히 레스토랑이라고 불리고, 확장 레스토랑 메뉴를 선택했기 때문에, 우리는 이것을 단순하게 유지하고 레스토랑 메뉴라고 부를 것입니다.

00:14:03.000 --> 00:14:07.000
이 문자열은 InfoPlist.strings 파일에서 현지화할 수 있습니다.

00:14:07.000 --> 00:14:10.000
현지화할 때 방금 입력한 문자열을 키로 사용하세요.

00:14:10.000 --> 00:14:15.000
이제 유형을 선언했으므로, 우리는 시스템에 앱이 그것을 열 수 있다고 말해야 합니다.

00:14:15.000 --> 00:14:18.000
문서 유형 섹션을 확장하세요.

00:14:18.000 --> 00:14:23.000
지원되는 새로운 유형을 추가하려면 섹션 하단의 추가 버튼을 클릭하세요.

00:14:23.000 --> 00:14:27.000
이 섹션은 내보낸 유형 식별자 섹션보다 간단합니다.

00:14:27.000 --> 00:14:33.000
우리가 지정해야 하는 유일한 것은 앱이 지원하는 균일한 유형 식별자 목록입니다.

00:14:33.000 --> 00:14:40.000
유연성을 위해, 우리는 여기에 하나의 항목 또는 항목당 하나의 항목에 대해 여러 유형을 지정할 수 있습니다.

00:14:40.000 --> 00:14:47.000
나는 개인적으로 항목당 하나의 유형을 선호하지만, 그것은 대부분 탭 대 공백과 같은 개인적인 취향의 문제이다.

00:14:47.000 --> 00:14:55.000
어쨌든, 우리는 이 필드에 균일한 유형 식별자를 추가할 것입니다.

00:14:55.000 --> 00:14:59.000
우리는 또한 이 항목의 핸들러 순위를 소유자로 설정해야 한다.

00:14:59.000 --> 00:15:06.000
이 단계는 필수는 아니지만 시스템이 주어진 작업에 적합한 앱을 지능적으로 선택하는 데 도움이 되기 때문에 강력히 권장됩니다.

00:15:06.000 --> 00:15:09.000
우리가 이 유형을 발명했기 때문에, 우리는 그것을 소유하고 있다.

00:15:09.000 --> 00:15:17.000
macOS에는 편집기 또는 뷰어로 파일을 열 수 있는지 여부를 지정할 수 있는 추가 규칙 필드가 있습니다.

00:15:17.000 --> 00:15:22.000
편집자는 주어진 유형의 파일을 열고 저장할 수 있지만, 시청자는 파일만 열 수 있습니다.

00:15:22.000 --> 00:15:27.000
우리 앱은 이 파일들을 읽고 쓸 수 있기 때문에, 우리는 편집기를 지정할 것이다.

00:15:27.000 --> 00:15:30.000
우리는 정보 섹션 편집을 마쳤다.

00:15:30.000 --> 00:15:32.000
우리 앱은 이제 레스토랑 메뉴 파일을 열 수 있습니다.

00:15:32.000 --> 00:15:40.000
시스템이 문서를 전달하면 문서를 처리하기 위해 SwiftUI, UIkit 또는 AppKit 코드를 작성해야 합니다.

00:15:40.000 --> 00:15:49.000
Swift UI에서 문서 기반 애플리케이션을 구축하는 방법에 대한 자세한 내용은 WWDC20의 "SwiftUI에서 문서 기반 앱 빌드"를 확인하세요.

00:15:49.000 --> 00:15:58.000
UIkit과 AppKit을 사용하여 문서 기반 애플리케이션을 구축하기 위한 문서는 developer.apple.com에서 온라인으로 확인할 수 있습니다.

00:15:58.000 --> 00:16:01.000
우리 앱에는 App Store의 경쟁자인 Compy's Food가 있습니다.

00:16:01.000 --> 00:16:07.000
많은 식당 주인들이 그 앱을 사용하고 그 앱이 소유한 파일 형식으로 메뉴를 저장했다.

00:16:07.000 --> 00:16:10.000
우리는 또한 그 파일들을 읽는 것을 지원하고 싶다.

00:16:10.000 --> 00:16:16.000
이 유형은 다른 누군가에 의해 발명되었고, 우리는 그것을 빌리고 있기 때문에, 수출하는 대신 수입해야 한다.

00:16:16.000 --> 00:16:22.000
앱 대상의 정보 탭으로 돌아가서 가져온 유형 식별자를 선택합시다.

00:16:22.000 --> 00:16:27.000
우리가 새로운 SwiftUI 앱을 만들었기 때문에, 여기에 예시 유형에 대한 기존 항목이 있습니다.

00:16:27.000 --> 00:16:32.000
우리는 양식의 내용을 우리 자신의 데이터로 대체할 수 있으며, 그것이 제가 할 일입니다.

00:16:32.000 --> 00:16:38.000
대상에 기존 예제 유형이 없다면, 물론 아래의 추가 버튼으로 새로운 유형을 추가할 수 있습니다.

00:16:38.000 --> 00:16:42.000
Compy's Food에 명시된 정보 섹션을 작성하겠습니다.

00:16:42.000 --> 00:16:45.000
물론, 여기의 세부 사항은 예시일 뿐입니다.

00:16:45.000 --> 00:16:53.000
실제 경쟁자 유형에 대한 지원을 추가하는 경우, Info.plist 파일에 포함된 것과 일치하도록 노력해야 합니다.

00:16:53.000 --> 00:16:59.000
이 유형은 가져오기 때문에, Compy's Food 앱에서 생성된 파일의 종류에 대해 시스템에 알려줍니다.

00:16:59.000 --> 00:17:07.000
하지만 사용자가 그 앱을 설치했다면, 시스템은 더 권위 있는 것으로 내보내야 하는 선언을 선호할 수 있다.

00:17:07.000 --> 00:17:13.000
우리는 이제 사용자가 그 중 하나를 열고 싶을 때 시스템이 앱을 선택할 수 있도록 이러한 파일을 여는 것에 대한 지원을 추가할 것입니다.

00:17:13.000 --> 00:17:17.000
우리는 문서 유형 섹션으로 돌아갈 것이다.

00:17:17.000 --> 00:17:23.000
우리는 Compy의 음식 목록에 대한 별도의 항목을 만들고 새로운 유형 식별자를 추가할 것입니다.

00:17:23.000 --> 00:17:28.000
이 항목은 우리가 그 유형의 소유자가 아니기 때문에 다른 항목과 조금 다르다.

00:17:28.000 --> 00:17:32.000
대신, 우리는 핸들러 순위가 대체되기를 원한다.

00:17:32.000 --> 00:17:38.000
우리 앱은 이러한 파일을 읽을 수 있지만 쓸 수 없기 때문에, 우리는 macOS에서 뷰어의 역할을 지정할 것입니다.

00:17:38.000 --> 00:17:47.000
시스템은 이제 이 파일을 열 수 있다는 것을 알고 있지만, 해당 앱이 파일 형식의 소유자이기 때문에 사용자가 Compy's Food를 설치한 경우 최선의 선택이 아닐 수도 있습니다.

00:17:47.000 --> 00:17:56.000
우리는 플랫폼에서 좋은 시민이 되고 싶기 때문에, 우리 둘 다 우리의 코드가 경쟁사의 코드보다 훨씬 낫다는 것을 알고 있음에도 불구하고 이런 식으로 유형 소유권을 존중하는 것이 중요합니다.

00:17:56.000 --> 00:18:03.000
우리 자신의 레스토랑 메뉴 유형과 마찬가지로, 앱에서 이러한 파일을 실제로 읽으려면 Swift 또는 Objective-C를 작성해야 합니다.

00:18:03.000 --> 00:18:07.000
자세한 정보는 developer.apple.com을 확인하세요.

00:18:07.000 --> 00:18:14.000
그래서 이제 우리는 유형을 선언하고 우리가 그것을 지원하는 시스템에 말했으므로, 코드에서 그 유형으로 작업할 때입니다.

00:18:14.000 --> 00:18:21.000
이 섹션에서는 당신이 적어도 핵심 서비스 프레임워크의 균일한 유형 식별자의 API에 광범위하게 익숙하다고 가정합니다.

00:18:21.000 --> 00:18:25.000
여기에 디렉토리나 파일 URL 세트를 안내하는 작은 프로그램이 있습니다.

00:18:25.000 --> 00:18:34.000
표현된 각 파일의 균일한 유형 식별자를 얻은 다음 해당 유형 식별자에 대한 현지화된 설명을 인쇄합니다.

00:18:34.000 --> 00:18:41.000
파일이 이미지라면, 어딘가에 그리고, 오디오 클립이라면, 사용자의 스피커나 에어팟을 통해 재생됩니다.

00:18:41.000 --> 00:18:45.000
바로, 여기에 보이는 몇 가지 문제가 있다.

00:18:45.000 --> 00:18:51.000
글로벌 UTType 함수와 함께 사용하기 위해 문자열을 CFStrings로 명시적으로 캐스팅해야 합니다.

00:18:51.000 --> 00:18:57.000
그리고 우리는 UTTypeCopyDescription에서 얻은 CFString의 수명을 수동으로 관리해야 합니다.

00:18:57.000 --> 00:19:11.000
하지만, 이에 대해 이야기하게 되어 매우 기쁩니다. iOS 14와 macOS Big Sur에서, 우리는 유니폼 유형 식별자에 일류의 신속성을 제공하는 새로운 유니폼 유형 식별자 프레임워크를 도입했습니다.

00:19:11.000 --> 00:19:19.000
이전에 유형 식별자를 나타내기 위해 CFStrings를 사용한 경우, 이제 UTType을 사용하여 유형과 속성을 나타낼 수 있습니다.

00:19:19.000 --> 00:19:24.000
이 코드를 살펴보고 새로운 프레임워크를 사용하도록 변환해 봅시다.

00:19:24.000 --> 00:19:36.000
포함된 API에 액세스하기 위해 프레임워크를 가져왔고, 이제 유형 식별자 URL 속성을 새로운 구조체 UTType의 인스턴스인 contentType으로 변경할 것입니다.

00:19:36.000 --> 00:19:42.000
이 구조체는 그것에 대한 메타데이터와 함께 균일한 유형 식별자를 캡슐화한다.

00:19:42.000 --> 00:19:45.000
다음으로, 우리는 이 유지되지 않은 가치를 고칠 것이다.

00:19:45.000 --> 00:19:48.000
UTType에는 현지화된 설명 속성이 있습니다.

00:19:48.000 --> 00:19:55.000
이와 같은 속성은 유형의 속성과 글로벌 함수로 작업하는 훨씬 더 자연스러운 방법입니다.

00:19:55.000 --> 00:20:02.000
이 속성의 값은 Xcode에 입력한 설명 문자열에 해당하며, 앱을 현지화할 때 현지화됩니다.

00:20:02.000 --> 00:20:07.000
다음으로, 또 다른 글로벌 함수인 UTTypeConformsTo로 넘어가자.

00:20:07.000 --> 00:20:12.000
이 함수는 명시적인 캐스트가 필요한 CFString을 취한다.

00:20:12.000 --> 00:20:16.000
놀랍지 않게도, UTType은 멤버를 준수하는 방법을 가지고 있다.

00:20:16.000 --> 00:20:20.000
하지만 이것들은 무엇인가요: .이미지와 .오디오?

00:20:20.000 --> 00:20:22.000
이 슬라이드 기억해?

00:20:22.000 --> 00:20:35.000
우리가 이 새로운 프레임워크를 설계할 때, 우리는 시스템에 의해 선언된 유형 집합과 이전 API에 노출된 CFString 상수 집합을 살펴보고, 그것들을 명명된 상수로 새로운 프레임워크로 가져왔습니다.

00:20:35.000 --> 00:20:42.000
새로운 프레임워크에는 가장 일반적으로 사용되는 시스템 정의 유형을 다루는 120개 이상의 상수가 정의되어 있다.

00:20:42.000 --> 00:20:46.000
물론, 이 세션 초반에, 우리는 앱에서 몇 가지 유형을 선언했다.

00:20:46.000 --> 00:20:51.000
우리가 그들을 위해 상수를 노출시킬 수 있다면 좋지 않을까요?

00:20:51.000 --> 00:20:55.000
나는 오늘 좋은 소식으로 가득 차 있어, 왜냐하면 너는 정확히 그걸 할 수 있거든.

00:20:55.000 --> 00:21:01.000
내보내는 유형과 가져오는 유형에 대해 명명된 상수를 선언하기 위한 API가 있습니다.

00:21:01.000 --> 00:21:04.000
의미론은 각각 조금씩 다르다.

00:21:04.000 --> 00:21:11.000
유형을 내보낼 때, 당신은 "나는 이 유형을 소유하고 있다"고 말하는 것이다. 내가 만들었어. 내 앱은 이 유형의 권한이다."

00:21:11.000 --> 00:21:17.000
그래서 우리는 당신이 이 유형에 대한 모든 것을 알고 있다는 것을 알고 안전하게 당신을 위해 UTType의 인스턴스를 만듭니다.

00:21:17.000 --> 00:21:27.000
유형을 가져올 때, 당신은 "나는 이 유형에 대해 알고 있지만, 다른 누군가가 나보다 더 많이 알 수도 있다"고 말하고 있으며, 그 유형의 소유자는 당신이 했던 것과 다르게 유형을 선언할 수 있습니다.

00:21:27.000 --> 00:21:33.000
만약 그런 일이 일어난다면, 우리는 가장 일반적인 사용 사례에서 즉석에서 그 유형을 대체할 수 있다.

00:21:33.000 --> 00:21:35.000
하지만 우리는 당신의 협조가 필요합니다.

00:21:35.000 --> 00:21:49.000
가져온 유형을 상수로 선언하는 대신 정적 계산 변수로 선언하여 앱 설치로 인해 선언이 변경되면 업데이트된 유형을 자동으로 선택할 수 있습니다.

00:21:49.000 --> 00:21:53.000
우리는 당신이 선언한 유형의 문제를 감지하기 위해 Xcode에 지원을 구축했습니다.

00:21:53.000 --> 00:22:01.000
Info.plist에서 내보내거나 가져온 유형이 누락되었거나 잘못된 상수 이니셜라이저를 사용했는지 감지할 수 있습니다.

00:22:01.000 --> 00:22:07.000
우리는 시간이 지남에 따라 지원을 개선하기 위해 노력할 것이며, 당신의 의견은 여기서 매우 귀중할 것이므로, 피드백을 제공해주세요.

00:22:07.000 --> 00:22:13.000
많은 프레임워크가 iOS 14와 macOS Big Sur의 새로운 API를 지원합니다.

00:22:13.000 --> 00:22:24.000
재단에는 방금 보여준 URL 속성이 있으며, 문자열이나 URL과 UTType의 인스턴스를 기반으로 권장 파일 이름을 생성하는 유틸리티도 있습니다.

00:22:24.000 --> 00:22:27.000
SwiftUI는 UTType을 광범위하게 지원합니다.

00:22:27.000 --> 00:22:34.000
onDrop 이벤트 핸들러와 같은 붙여넣기 및 드래그 앤 드롭 API는 독점적으로 사용합니다.

00:22:34.000 --> 00:22:39.000
그리고 문서 기반 앱에 대한 SwiftUI의 새로운 지원은 UTType을 사용하도록 설계되었습니다.

00:22:39.000 --> 00:22:47.000
WWDC 20의 "SwiftUI에서 문서 기반 앱 빌드"를 확인하여 자세히 알아보는 것이 좋습니다.

00:22:47.000 --> 00:22:52.000
AppKit을 사용할 때, NSWorkspace를 사용하면 모든 UTType에 대한 아이콘을 얻을 수 있습니다.

00:22:52.000 --> 00:22:56.000
그리고 NSOpenPanel과 NSSavePanel은 UTTypes를 지원합니다.

00:22:56.000 --> 00:23:02.000
UIkit은 문서 선택기와 문서 브라우저를 제시할 때 UTTypes 사용을 지원합니다.

00:23:02.000 --> 00:23:06.000
그리고 Core Spotlight를 사용하면 UTType에서 속성 세트를 만들 수 있습니다.

00:23:06.000 --> 00:23:13.000
이 릴리스에는 UTType을 지원하지 않는 많은 API가 있으며, 그들과 상호 작용해야 할 수도 있습니다.

00:23:13.000 --> 00:23:15.000
어렵지 않아.

00:23:15.000 --> 00:23:23.000
균일한 유형 식별자를 API에 전달해야 하는 경우, UTType의 식별자 속성을 가져와 CFString으로 캐스팅하십시오.

00:23:23.000 --> 00:23:32.000
균일한 유형 식별자를 UTType으로 다시 변환하려면 CFString에서 String으로 캐스팅하고 해당 문자열로 UTType을 초기화하십시오.

00:23:32.000 --> 00:23:37.000
이것은 실패할 수 있는 이니셜라이저이므로, nil을 확인하는 것을 잊지 마세요.

00:23:37.000 --> 00:23:42.000
Objective-C에서, 그것은 조금 더 장황하지만, 아이디어는 동일하다.

00:23:42.000 --> 00:23:51.000
UTType의 식별자를 CFStringRef로 캐스팅하거나 CFString을 NSString으로 캐스팅하고 UTType을 만드세요.

00:23:51.000 --> 00:24:01.000
우리는 오늘 시스템이 메타데이터에서 파일의 유형을 어떻게 도출하는지, 그리고 애플이 균일한 유형 식별자를 사용하여 그 정보를 어떻게 캡슐화하는지 보았다.

00:24:01.000 --> 00:24:09.000
우리는 우리 자신의 유형을 선언하고 사용하는 방법과 여러 응용 프로그램 간에 공유될 수 있는 유형과 상호 작용하는 방법을 배웠습니다.

00:24:09.000 --> 00:24:17.000
그리고 우리는 유형과 상호 작용하는 현대적이고 객체 지향적인 방법을 제공하는 새로운 균일한 유형 식별자 프레임워크를 도입했습니다.

00:24:17.000 --> 00:24:22.000
저는 당신이 이 지식과 새로운 프레임워크를 사용하여 앱을 구축하는 방법을 보기를 기대합니다.

00:24:22.000 --> 23:59:59.000
고마워.

