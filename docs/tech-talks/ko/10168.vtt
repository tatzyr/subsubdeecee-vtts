WEBVTT

00:00:00.000 --> 00:00:06.000
안녕하세요, 제 이름은 Ari이고, 사용자 지정 의도를 App Intents로 마이그레이션하는 방법에 대해 이야기하게 되어 기쁩니다.

00:00:06.000 --> 00:00:18.000
이 비디오에서는 새로운 앱 인텐트 프레임워크를 채택해야 하는 이유, 이전 버전과의 호환성을 포함하여 마이그레이션이 어떻게 작동하는지, 그리고 실제로 앱 인텐트로 변환하는 방법을 다룰 것입니다.

00:00:18.000 --> 00:00:24.000
먼저, 앱 인텐트를 채택해야 하는 이유와 이전 프레임워크와 어떻게 다른지 알아봅시다.

00:00:24.000 --> 00:00:38.000
우리는 2016년에 SiriKit Intents 프레임워크를 도입했는데, 이는 메시징, 운동, 전화 통화 등과 같은 일반적인 사용 사례에 대한 완벽한 사용자 경험을 제공하는 일련의 목적 중심의 시스템 의도와 함께 제공됩니다.

00:00:38.000 --> 00:00:48.000
다음으로, 우리는 모든 사용 사례에 대한 자신의 의도를 정의할 수 있는 사용자 지정 의도를 도입하여 앱의 기능을 Siri, 단축키 및 제안에 제공합니다.

00:00:48.000 --> 00:00:54.000
그리고 우리는 위젯 구성과 예측을 위해 사용자 지정 의도를 사용하는 WidgetKit을 추가했습니다.

00:00:54.000 --> 00:01:03.000
WWDC22에서, 우리는 앱에서 시스템으로 인텐트를 제공하는 새로운 스위프트 네이티브 프레임워크인 앱 인텐트를 도입했습니다.

00:01:03.000 --> 00:01:09.000
앱 인텐트는 현대적이고 강력하며 사용자에게 쉽기 때문에 채택하기에 훌륭한 프레임워크이다.

00:01:09.000 --> 00:01:14.000
그것은 스위프트를 위해 기본적으로 설계되었기 때문에 현대적이다.

00:01:14.000 --> 00:01:20.000
최신 언어 기능 덕분에, 동일한 기능을 지원하기 위해 극적으로 적은 코드를 작성할 수 있습니다.

00:01:20.000 --> 00:01:26.000
우리는 또한 의도 정의 파일을 유지하고 코드 생성을 사용할 필요성을 제거했습니다.

00:01:26.000 --> 00:01:30.000
그리고 이제 가벼운 SwiftUI 뷰로 스니펫을 제공할 수 있습니다.

00:01:30.000 --> 00:01:35.000
엔티티와 쿼리가 더 깊은 사용 사례를 가능하게 했기 때문에 강력하다.

00:01:35.000 --> 00:01:41.000
확장 프로그램을 제공하지 않고도 앱 프로세스에서 직접 앱 인텐트를 실행할 수 있습니다.

00:01:41.000 --> 00:01:46.000
그리고 사람들이 당신의 의도를 설정하고 실행할 때 사용자 경험을 사용자 정의할 수 있는 새로운 기회가 있습니다.

00:01:46.000 --> 00:01:49.000
그것은 또한 사람들이 사용하기 쉽다.

00:01:49.000 --> 00:01:56.000
의도는 설정 없이 즉시 사용할 수 있는 앱 단축키로 쉽게 노출될 수 있습니다.

00:01:56.000 --> 00:02:05.000
게다가, 사람들이 당신의 단축키를 발견할 수 있는 새로운 방법이 있습니다. 왜냐하면 그것들은 Spotlight 상단과 앱에 포함할 수 있는 Siri 팁에 표시되기 때문입니다.

00:02:05.000 --> 00:02:13.000
새로운 프레임워크의 모든 이점을 얻으려면, Siri를 위해 만든 사용자 지정 인텐트와 앱 인텐트의 단축키를 업그레이드해야 합니다.

00:02:13.000 --> 00:02:16.000
SiriKit 의도는 여전히 완전히 지원됩니다.

00:02:16.000 --> 00:02:25.000
따라서 메시징이나 미디어와 같은 Siri 도메인을 구축하거나 WidgetKit과 함께 인텐트를 사용하는 경우, 그대로 두어야 합니다.

00:02:25.000 --> 00:02:32.000
앱 인텐트 프레임워크에 대해 자세히 알아보려면, WWDC22의 세션인 "앱 인텐트에 뛰어들어보세요"를 확인하세요.

00:02:32.000 --> 00:02:43.000
그리고 사람들이 Siri와 Spotlight에서 앱의 기능을 매우 쉽게 사용할 수 있는 앱 단축키에 대해 자세히 알아보려면, "앱 의도로 앱 단축키 구현"을 확인하세요.

00:02:43.000 --> 00:02:45.000
다음으로, 이주에 대해 알아봅시다.

00:02:45.000 --> 00:02:52.000
마이그레이션을 사용하면 Xcode에서 한 번의 클릭으로 기존 인텐트 정의를 앱 인텐트로 변환할 수 있습니다.

00:02:52.000 --> 00:02:57.000
동일한 앱 바이너리로 iOS 15와 iOS 16을 모두 지원할 수 있습니다.

00:02:57.000 --> 00:03:03.000
그리고 사람들의 기존 단축키를 사용하여 새로운 앱 인텐트 작업을 계속할 수 있습니다.

00:03:03.000 --> 00:03:12.000
인텐트 정의를 앱 인텐트로 변환하려면 인텐트 정의 파일로 이동하여 앱 인텐트로 변환 버튼을 누르기만 하면 됩니다.

00:03:12.000 --> 00:03:17.000
Xcode는 이전 인텐트 정의와 동등한 앱 인텐트 코드를 생성합니다.

00:03:17.000 --> 00:03:21.000
그런 다음, 이전 콘텐츠 핸들러 코드를 리팩토링하여 코드를 채울 수 있습니다.

00:03:21.000 --> 00:03:25.000
우리는 다음 섹션에서 이것에 대해 더 깊이 이야기할 것이다.

00:03:25.000 --> 00:03:34.000
앱이 앱 인텐트로 업그레이드할 때 사람들이 원활한 경험을 할 수 있도록, 시스템은 이전 인텐트에서 새로운 인텐트로의 매핑을 자동으로 처리합니다.

00:03:34.000 --> 00:03:36.000
그게 어떻게 작동하는지 얘기하자.

00:03:36.000 --> 00:03:45.000
CustomIntentMigratedAppIntent 프로토콜을 채택함으로써, 시스템은 오래된 의도와 새로운 의도 사이를 번역하는 방법을 알 수 있는 충분한 정보를 갖게 될 것이다.

00:03:45.000 --> 00:03:54.000
이 프로토콜을 채택할 때, 이전 사용자 지정 인텐트에 사용된 클래스 이름인 인텐트 클래스 이름 속성을 제공합니다.

00:03:54.000 --> 00:03:57.000
대부분의 경우, 당신은 이것을 직접 제공할 필요가 없습니다.

00:03:57.000 --> 00:04:03.000
앱 인텐트로 변환 버튼을 사용할 때, 결과 코드는 이미 이 프로토콜을 채택하고 있습니다.

00:04:03.000 --> 00:04:10.000
앱 인텐트의 마이그레이션 기능 때문에, 앱 인텐트로 업그레이드하기 위해 앱이 iOS 16을 대상으로 할 때까지 기다릴 필요가 없습니다.

00:04:10.000 --> 00:04:16.000
사실, 동일한 앱 바이너리로 최신 및 구형 운영 체제를 모두 쉽게 지원할 수 있습니다.

00:04:16.000 --> 00:04:21.000
이렇게 하려면, 레거시 인텐트 핸들러와 앱 인텐트를 모두 앱에 포함하세요.

00:04:21.000 --> 00:04:27.000
코드 공유를 극대화하려면, 공통의 비즈니스 논리 세트보다 두 인텐트 핸들러 세트를 모두 고려하십시오.

00:04:27.000 --> 00:04:36.000
마이그레이션된 앱 인텐트 프로토콜을 채택한다고 가정하면, 앱에 두 세트를 모두 포함할 때 단축키가 자동으로 인텐트를 중복 제거합니다.

00:04:36.000 --> 00:04:47.000
따라서 iOS 15 및 이전 버전에서 바로 가기 앱은 레거시 인텐트 구현만 표시되며, iOS 16 및 이후 버전에서는 앱 인텐트의 구현만 표시됩니다.

00:04:47.000 --> 00:04:56.000
최소 배포 대상을 iOS 16 이상으로 전환하면, 마이그레이션한 인텐트에 대한 레거시 인텐트 핸들러와 정의를 안전하게 삭제할 수 있습니다.

00:04:56.000 --> 00:04:59.000
그것들은 더 이상 필요하지 않다.

00:04:59.000 --> 00:05:09.000
마이그레이션할 때 생각해야 할 한 가지는 사람들이 단축키 앱에서 만들거나 앱의 Siri에 추가 버튼을 사용하여 추가했을 수 있는 오래된 의도에 의존하는 기존 단축키를 가지고 있다는 것입니다.

00:05:09.000 --> 00:05:17.000
좋은 소식은 이러한 단축키가 마이그레이션된 앱 인텐트 프로토콜을 채택하는 한 새로운 앱 인텐트와 계속 작동할 것이라는 것입니다.

00:05:17.000 --> 00:05:24.000
사람들의 단축키는 새로운 앱 인텐트를 사용하기 위해 덮어쓰지 않습니다; 그들은 새로운 인텐트와 오래된 인텐트 모두에서 작동하는 공통 형식을 자동으로 사용합니다.

00:05:24.000 --> 00:05:31.000
이것이 작동하려면, 레거시 인텐트와 앱 인텐트의 스키마는 호환되어야 한다.

00:05:31.000 --> 00:05:39.000
호환되기 위해, 사용자 지정 의도와 앱 의도의 매개 변수는 동일한 이름과 동등한 유형을 가져야 합니다.

00:05:39.000 --> 00:05:43.000
스키마 호환성을 깨지 않고 만들 수 있는 몇 가지 변경 사항이 있습니다.

00:05:43.000 --> 00:05:49.000
특히, 매개 변수를 추가하거나 제거하거나 기존 매개 변수를 선택 사항이 아닌으로 만들 수 있습니다.

00:05:49.000 --> 00:05:56.000
Xcode에서 스키마 호환성을 확인하려면, 매개 변수 목록이 있는 이전 의도 정의 파일을 확인하세요.

00:05:56.000 --> 00:05:59.000
각 매개 변수에는 이름과 유형이 있다.

00:05:59.000 --> 00:06:03.000
인스펙터 창에는 인텐트의 클래스 이름에 대한 필드도 있습니다.

00:06:03.000 --> 00:06:13.000
앱 인텐트 코드에서 작업할 때, 인텐트 클래스 이름이 인텐트 정의 파일에 있던 것과 일치하는지 확인하여 시스템이 새로운 인텐트를 이전 인텐트와 동등한 것으로 간주할 수 있도록 하십시오.

00:06:13.000 --> 00:06:19.000
그리고 앱 인텐트 코드의 매개 변수 이름과 유형이 호환되는지 확인하세요.

00:06:19.000 --> 00:06:24.000
다시 말하지만, Xcode의 앱 의도로 변환 버튼은 자동으로 스키마 호환성을 보장합니다.

00:06:24.000 --> 00:06:29.000
그래서 만약 당신이 그 도구를 사용하고 어떤 변화도 하지 않는다면, 당신은 좋은 상태가 될 것입니다.

00:06:29.000 --> 00:06:34.000
다음으로, 기존 의도를 실제로 앱 의도로 변환하는 방법에 대해 이야기해 봅시다.

00:06:34.000 --> 00:06:37.000
의도를 마이그레이션하는 두 단계가 있다.

00:06:37.000 --> 00:06:43.000
첫 번째 단계는 인텐트 정의 파일을 마이그레이션하는 것이고 두 번째 단계는 코드를 마이그레이션하는 것입니다.

00:06:43.000 --> 00:06:45.000
의도 정의부터 시작합시다.

00:06:45.000 --> 00:06:51.000
저는 수프의 열렬한 팬이며, 사람들이 수프를 주문할 수 있는 수프 셰프라는 예시 앱이 있습니다.

00:06:51.000 --> 00:06:59.000
어떤 수프를 주문할지, 얼마나 많은지, 어떤 토핑을 추가할지, 픽업 또는 배송 위치에 대한 매개 변수로 주문하려는 의도가 있습니다.

00:06:59.000 --> 00:07:07.000
이것을 앱 인텐트로 변환할 준비가 되었으므로, Xcode의 인텐트 정의 파일로 이동하여 변환 버튼을 누르겠습니다.

00:07:07.000 --> 00:07:11.000
다음으로, 나는 어떤 의도를 전환할지 선택한다 - 이 경우의 의도만.

00:07:11.000 --> 00:07:16.000
그런 다음 새로운 인텐트 코드를 저장할 위치와 그것을 포함할 대상을 선택할 것입니다.

00:07:16.000 --> 00:07:21.000
내가 하나를 추가했다면 그것은 내 앱 타겟이나 앱 인텐트 확장 타겟이 될 수 있다.

00:07:21.000 --> 00:07:25.000
이 경우, 앱 타겟과 시계 타겟도 확인하겠습니다.

00:07:25.000 --> 00:07:28.000
앱 의도는 프레임워크 대상에 추가할 수 없습니다.

00:07:28.000 --> 00:07:32.000
다음으로, Xcode가 생성한 앱 인텐트 코드를 볼 것입니다.

00:07:32.000 --> 00:07:40.000
인텐트 정의 파일에 포함된 모든 인텐트, 열거형 및 사용자 지정 유형을 나타내는 몇 개의 파일에서 분리됩니다.

00:07:40.000 --> 00:07:46.000
나는 이전된 나의 오래된 의도 정의의 몇 가지 특정 영역에 주의를 환기시키고 싶다.

00:07:46.000 --> 00:07:51.000
새로운 코드에는 App Intent 프로토콜을 준수하는 orderSoup 구조체가 있습니다.

00:07:51.000 --> 00:07:56.000
이 구조는 iOS 16 이상에서 사용할 수 있는 것으로 표시되어 있습니다.

00:07:56.000 --> 00:08:04.000
iOS 16 이전에 앱을 배포하는 경우 앱 인텐트 프레임워크를 사용하는 모든 코드에 주석을 적용해야 합니다.

00:08:04.000 --> 00:08:12.000
내 인텐트 정의 파일의 각 매개 변수는 메타데이터와 함께 앱 인텐트 구조의 @Parameter 선언으로 마이그레이션되었습니다.

00:08:12.000 --> 00:08:18.000
모든 단축키 앱 매개 변수 요약이 이 매개 변수 요약 선언으로 마이그레이션되었습니다.

00:08:18.000 --> 00:08:26.000
매개 변수 관계로 표현되었던 것은 이제 ParameterSummary의 Switch, Case 또는 When 문을 사용하여 표현할 수 있습니다.

00:08:26.000 --> 00:08:33.000
내 수프와 토핑 사용자 지정 유형은 이제 나중에 작성해야 할 몇 가지 할 일을 포함하여 앱 엔티티입니다.

00:08:33.000 --> 00:08:36.000
OrderDetails는 이제 일시적인 앱 엔티티이다.

00:08:36.000 --> 00:08:42.000
나중에 조회하는 데 사용할 수 있는 고유 식별자가 없기 때문에 일시적인 것으로 간주됩니다.

00:08:42.000 --> 00:08:46.000
그리고 내 OrderType 사용자 지정 열거형은 이제 앱 열거형이다.

00:08:46.000 --> 00:08:52.000
사람이 읽을 수 있는 이름은 대소문자 표시 표현으로 옮겨졌다.

00:08:52.000 --> 00:08:59.000
마지막으로, 인텐트 응답의 모든 대화상자는 IntentDialog의 확장으로 마이그레이션되었습니다.

00:08:59.000 --> 00:09:02.000
이 대화상자는 내 수행 방법에 사용될 수 있다.

00:09:02.000 --> 00:09:13.000
마이그레이션자는 필요한 것보다 더 많은 문자열을 생성할 수 있으므로, "Just to confirm, you wanted \ (soup)?"와 같이 이전 인텐트 핸들러에서 실제로 사용되지 않는 문자열을 본다면, 자유롭게 제거하세요.

00:09:13.000 --> 00:09:18.000
이제 인텐트 정의를 마이그레이션했으니, 인텐트 처리 코드를 마이그레이션해 봅시다.

00:09:18.000 --> 00:09:26.000
자동 생성된 앱 인텐트에는 perform() 메서드에 대한 자리 표시자가 있으며, 이를 작성해야 한다는 점에 유의하십시오.

00:09:26.000 --> 00:09:28.000
그걸 어떻게 하는지 보자.

00:09:28.000 --> 00:09:34.000
이전 프레임워크에서는 인텐트 정의 파일과 인텐트 처리 코드 세트를 제공했습니다.

00:09:34.000 --> 00:09:38.000
새로운 프레임워크에서, 모든 것이 코드로 표현된다.

00:09:38.000 --> 00:09:42.000
이전 의도 정의의 매개 변수는 이미 새 코드로 마이그레이션되었습니다.

00:09:42.000 --> 00:09:51.000
이전 코드의 해결, 확인 및 처리 메서드는 의도가 실행될 때 호출되는 단일 수행 메서드로 결합되어야 합니다.

00:09:51.000 --> 00:09:57.000
그리고 사용자 지정 유형과 동적 옵션은 엔티티와 쿼리로 리팩토링되어야 합니다.

00:09:57.000 --> 00:10:03.000
그래서 해결부터 시작하여 의도 처리의 각 단계를 마이그레이션하는 방법을 살펴봅시다.

00:10:03.000 --> 00:10:10.000
해결 단계에서, 인텐트 핸들러는 인텐트의 각 매개 변수를 검증하고 필요한 경우 사용자에게 값을 요청합니다.

00:10:10.000 --> 00:10:18.000
해결 방법을 마이그레이션할 때, 가능한 경우 앱 인텐트의 새로운 자동 해결 동작을 활용해야 합니다.

00:10:18.000 --> 00:10:22.000
그렇지 않으면 해결 논리를 수행 방법으로 리팩토링해야 합니다.

00:10:22.000 --> 00:10:25.000
몇 가지 예를 살펴봅시다.

00:10:25.000 --> 00:10:28.000
여기 수프 매개 변수에 대한 오래된 해결 방법이 있습니다.

00:10:28.000 --> 00:10:32.000
이것은 오래된 의도 프레임워크의 일반적인 패턴을 따른다.

00:10:32.000 --> 00:10:34.000
수프 매개 변수를 풀어 보세요.

00:10:34.000 --> 00:10:39.000
0이면, 사용자에게 모호함을 사용하여 수프를 고르라고 요청하는 해결 결과를 반환하세요.

00:10:39.000 --> 00:10:45.000
그것이 설정되었다면, 성공적으로 해결 결과를 반환하고 이미 지정된 것과 동일한 수프를 전달하세요.

00:10:45.000 --> 00:10:51.000
이러한 종류의 상용구판은 자동 해결 덕분에 앱 인텐트에 더 이상 필요하지 않습니다.

00:10:51.000 --> 00:10:57.000
이전에 이런 식으로 해결된 매개 변수가 있다면, 새로운 기능을 활용하는 방법은 다음과 같습니다.

00:10:57.000 --> 00:11:06.000
기본적으로 마이그레이션된 매개 변수는 선택 사항이지만 유형을 비선택 사항으로 변경하여 자동 해결 동작을 얻을 수 있습니다.

00:11:06.000 --> 00:11:16.000
매개 변수를 선택 사항이 아닌 것으로 만들 때, 앱 인텐트는 SoupAppEntity의 쿼리에서 제안된 엔티티를 사용하여 비어 있는 경우 사용자에게 값을 자동으로 요청합니다.

00:11:16.000 --> 00:11:27.000
그런 다음, 매개 변수 선언에 대화상자를 추가하여 해결 시스템이 "어떤 수프를 원하십니까?"와 같은 값을 요청할 때 사용자가 특정 질문을 받을 수 있도록 합니다.

00:11:27.000 --> 00:11:31.000
일단 이것을 하면, 더 이상 이 매개 변수에 대한 해상도 코드가 필요하지 않습니다.

00:11:31.000 --> 00:11:44.000
다른 모든 유형의 해결의 경우, 해결 구현을 perform() 메서드의 맨 위로 이동하고 API 사용을 변경하여 적절한 새 API를 사용하여 사용자에게 설명을 요청해야 합니다.

00:11:44.000 --> 00:11:58.000
예를 들어, 수량에 대한 오래된 해결 방법이 수량을 풀고 누락된 경우 needsValue를 던진 다음 수량이 실제로 사용 가능한 수프의 수보다 큰지 확인하고 오류를 반환한다고 가정해 봅시다.

00:11:58.000 --> 00:12:06.000
이 코드를 앱 인텐츠로 옮길 때, 수량 매개 변수를 선택 사항이 아닌 것으로 따로 만들 수 있기 때문에 더 이상 첫 번째 부분이 필요하지 않습니다.

00:12:06.000 --> 00:12:18.000
두 번째 부분의 경우, 우리는 지원되지 않는 해상도 결과로 완료 핸들러를 일으킨 코드를 가져와 재고가 충분하지 않다는 것을 나타내는 오류를 발생시키는 코드로 대체하고 싶습니다.

00:12:18.000 --> 00:12:25.000
우리는 오류를 오류와 사용자 지정 현지화된 문자열 리소스 컨버터블 프로토콜을 준수하는 열거형으로 정의해야 합니다.

00:12:25.000 --> 00:12:30.000
그렇게 하면, 우리는 이 사건이 발생했을 때 사용자에게 말하거나 표시되는 대화상자를 제공할 수 있습니다.

00:12:30.000 --> 00:12:39.000
이 예제와 같이 동적으로 반환되고 needsValue 결과가 필요한 코드가 있었다면, 그것을 needsValueError를 던지는 코드로 바꿀 수 있습니다.

00:12:39.000 --> 00:12:48.000
needsValueError를 던지면, 시스템은 사용자가 제공한 대화상자로 값을 입력하라는 메시지를 표시한 다음 처음부터 perform 메소드를 다시 실행합니다.

00:12:48.000 --> 00:12:52.000
또 다른 옵션은 requestValue 방법을 사용하는 것이다.

00:12:52.000 --> 00:12:59.000
requestValue를 사용하면 사용자에게 값을 요청하고 다시 시작하지 않고 수행 방법을 계속 실행할 수 있습니다.

00:12:59.000 --> 00:13:08.000
requestValue 방법 외에도 이전 API 사용을 대체하는 데 사용할 수 있는 requestDisambiguation 및 requestConfirmation 방법도 있습니다.

00:13:08.000 --> 00:13:11.000
다음으로 확인에 대해 이야기해 봅시다.

00:13:11.000 --> 00:13:19.000
확인은 추가 검증을 하고 시스템이 사용자에게 진행하기를 원하는지 확인하도록 요청할 수 있는 정보를 제공할 수 있는 기회입니다.

00:13:19.000 --> 00:13:25.000
검증을 위해, 확인 방법에 있던 모든 검증 논리를 수행 방법으로 옮겨야 합니다.

00:13:25.000 --> 00:13:30.000
사용자에게 확인을 요청하기 위해, 우리는 새로운 간단한 requestConfirmation() API를 가지고 있습니다.

00:13:30.000 --> 00:13:33.000
새로운 API는 단일 메소드 호출일 뿐이다.

00:13:33.000 --> 00:13:40.000
Async/await를 사용하면, 이 방법은 수행 방법을 계속하기 전에 사용자가 확인할 때까지 기다립니다.

00:13:40.000 --> 00:13:46.000
그들이 취소하면, 오류가 발생하고, 당신의 수행 방법의 실행이 멈출 것입니다.

00:13:46.000 --> 00:14:07.000
requestConfirmation 방법은 Siri가 말하거나 표시하는 대화 상자, 스니펫에 표시되는 SwiftUI 보기, 확인 버튼에 사용되는 레이블(이 경우 순서) 및 대화 상자가 화면에 프롬프트로 표시되어야 하는지 여부를 제어하는 showPrompt 인수를 포함하여 확인 프롬프트에 영향을 미치는 몇 가지 인수를 포함합니다.

00:14:07.000 --> 00:14:12.000
대화상자와 보기가 서로 같은 정보를 포함할 때 이것은 false로 설정되어야 합니다.

00:14:12.000 --> 00:14:16.000
그래서 Siri가 대화를 말하지만 보여주지 않는 것이 합리적이다.

00:14:16.000 --> 00:14:18.000
다음으로, 핸들을 살펴봅시다.

00:14:18.000 --> 00:14:25.000
핸들 리팩토링의 경우, 코드를 핸들 메소드에서 perform 메소드로 이동하기만 하면 됩니다.

00:14:25.000 --> 00:14:32.000
이제 하나의 방법으로 해결, 확인 및 처리가 모두 발생하기 때문에 이전 핸들 방법에서 일부 유효성 검사 코드를 제거할 수 있어야 합니다.

00:14:32.000 --> 00:14:42.000
예를 들어, 핸들에서 이전 코드를 복사했다면, 이제 삭제할 수 있는 더 이상 선택 사항이 아닌 매개 변수를 풀기 위한 코드로 끝날 것입니다.

00:14:42.000 --> 00:14:46.000
수행 방법이 끝나면, 의도 결과를 반환해야 합니다.

00:14:46.000 --> 00:14:53.000
그 결과는 Siri가 말할 수 있는 대화나 보여줄 스니펫 보기와 같은 다양한 필드를 포함할 수 있다.

00:14:53.000 --> 00:15:05.000
각각은 대화상자의 경우 ProvidesDialog와 SwiftUI 스니펫 보기의 경우 ShowSnippetView와 같은 적절한 프로토콜로 수행 방법의 반환 유형에 주석을 달 필요가 있습니다.

00:15:05.000 --> 00:15:08.000
마지막으로, 동적 옵션 마이그레이션을 살펴봅시다.

00:15:08.000 --> 00:15:13.000
매개 변수 유형에 따라 쿼리 또는 DynamicOptionsProvider를 입력해야 합니다.

00:15:13.000 --> 00:15:18.000
Xcode는 당신이 그것들을 채워야 하는 이 장소들에서 할 일을 제공할 것입니다.

00:15:18.000 --> 00:15:31.000
쿼리의 경우, 식별자, 검색 가능한 경우 문자열로 엔티티를 반환하는 방법, 그리고 사용자가 단축키에서 해당 매개 변수를 탭할 때 나타날 제안된 엔티티 세트를 구현해야 합니다.

00:15:31.000 --> 00:15:36.000
동적 옵션의 경우, 결과 방법의 모든 옵션을 반환할 수 있습니다.

00:15:36.000 --> 00:15:37.000
그리고 그게 다야!

00:15:37.000 --> 00:15:40.000
앱 인텐트 마이그레이션을 마쳤습니다.

00:15:40.000 --> 00:15:45.000
네가 정말 끝내기 전에, 내가 보고 싶은 게 몇 가지 더 있어.

00:15:45.000 --> 00:15:47.000
첫 번째는 앱 단축키를 채택하는 것이다.

00:15:47.000 --> 00:15:54.000
이것은 당신이 당신의 의도를 발견할 수 있게 하고 사람들이 Siri에게 몇 마디 말함으로써 그것들을 사용할 수 있게 할 것입니다.

00:15:54.000 --> 00:16:01.000
사람들이 앱의 기능을 사용하기 위해 Siri에게 무슨 말을 해야 할지 배울 수 있도록 Siri 팁을 UI에 추가하세요.

00:16:01.000 --> 00:16:04.000
이것들은 이전에 가지고 있던 Siri에 추가 버튼을 대체해야 합니다.

00:16:04.000 --> 00:16:15.000
이전 버전의 앱으로 단축키를 만들고 새 버전의 앱에서 올바르게 작동하는지 테스트하여 고객 업그레이드 경로를 테스트하십시오.

00:16:15.000 --> 00:16:19.000
그리고 앱이 여러 로케일에서 작동한다면, 현지화에 대해 생각해 보세요.

00:16:19.000 --> 00:16:32.000
앱 인텐트를 현지화하려면, 앱 인텐트에 포함된 모든 문자열은 현지화된 문자열 리소스로 제공되어야 하며, 해당 문자열과 함께 해당 현지화 가능한 .strings 파일을 제공하여 현지화할 수 있습니다.

00:16:32.000 --> 00:16:37.000
복수 문자열을 사용하는 경우, .strings dict 파일을 사용할 수도 있습니다.

00:16:37.000 --> 00:16:50.000
앱 단축키를 현지화할 때, AppShortcuts.strings라는 파일에 문자열을 추가하고 해당 문자열의 변수를 ${ } 표기법으로 바꾸세요.

00:16:50.000 --> 00:17:01.000
요약하자면, iOS 16의 새로운 기능과 앱 인텐트의 새로운 간단한 개발 모델의 모든 이점을 얻기 위해 사용자 지정 인텐트를 앱 인텐츠로 업그레이드하는 것이 좋습니다.

00:17:01.000 --> 00:17:07.000
사람들이 앱의 기능을 쉽게 발견하고 사용할 수 있도록 앱 단축키를 추가하세요.

00:17:07.000 --> 00:17:16.000
그리고 훌륭한 사용자 경험을 구성하는 방법에 대해 자세히 알아보려면, WWDC22의 "디자인 앱 단축키" 세션을 확인하세요.

00:17:16.000 --> 23:59:59.000
고마워.

