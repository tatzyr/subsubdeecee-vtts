WEBVTT

00:00:01.000 --> 00:00:02.000
알레한드로 이사자: 안녕. 난 알레한드로야.

00:00:02.000 --> 00:00:08.000
오늘 데이비드와 나는 데이터 조작과 탐사를 위한 새로운 프레임워크인 TabularData를 소개할 것이다.

00:00:08.000 --> 00:00:16.000
빠른 소개로 시작한 다음 데이터 탐색, 데이터 변환, 모범 사례에 대해 이야기하고 요약으로 마무리하겠습니다.

00:00:16.000 --> 00:00:17.000
뛰어들자.

00:00:17.000 --> 00:00:20.000
먼저 제가 이야기해 드리겠습니다, 표 데이터가 무엇인가요?

00:00:20.000 --> 00:00:26.000
가장 간단한 용어로, 표 데이터는 스프레드시트와 유사한 행과 열로 구성된 데이터이다.

00:00:26.000 --> 00:00:29.000
하지만 수백 개의 열과 수백만 개의 행이 있다고 상상해 보세요.

00:00:29.000 --> 00:00:32.000
이것이 TabularData 프레임워크가 들어오는 곳이다.

00:00:32.000 --> 00:00:33.000
그래서 그게 뭐야?

00:00:33.000 --> 00:00:36.000
그것은 우리가 작업해온 새로운 프레임워크이다.

00:00:36.000 --> 00:00:40.000
그것은 이미 macOS, iOS, tvOS 및 watchOS에서 사용할 수 있습니다.

00:00:40.000 --> 00:00:44.000
그것은 당신이 구조화되지 않은 데이터를 탐색하고 조작하는 데 도움이 될 것입니다.

00:00:44.000 --> 00:00:49.000
내가 "구조화되지 않은 데이터"라고 말할 때, 나는 미리 정의된 방식으로 배열되지 않은 데이터를 의미한다.

00:00:49.000 --> 00:00:56.000
예를 들어, 기술 사양이 없는 데이터 세트를 다운로드할 때; 예를 들어, 날씨 데이터나 인구 통계.

00:00:56.000 --> 00:00:59.000
그리고 탐험은 새로운 데이터 세트를 만났을 때 가장 먼저 하는 일입니다.

00:00:59.000 --> 00:01:01.000
당신은 거기에 어떤 종류의 정보가 있는지 알고 싶어합니다.

00:01:01.000 --> 00:01:03.000
같은 것들, 가치는 무엇인가요?

00:01:03.000 --> 00:01:05.000
어떤 종류들이야? 데이터는 어떻게 표현되나요?

00:01:05.000 --> 00:01:07.000
누락된 값이 있나요? 그리고 계속.

00:01:07.000 --> 00:01:14.000
데이터 세트를 제대로 이해하고 다음 단계인 조작으로 이동할 수 있으려면 이러한 질문에 답할 수 있어야 합니다.

00:01:14.000 --> 00:01:19.000
조작은 데이터 세트를 해결하려는 문제에 가장 적합한 형태로 변환하는 곳입니다.

00:01:19.000 --> 00:01:26.000
예를 들어, 날짜를 문자열 대신 날짜 유형으로 나타내거나, x와 y 좌표를 점 유형으로 결합할 수 있습니다.

00:01:26.000 --> 00:01:30.000
TabularData 프레임워크는 대규모 데이터 세트를 다루는 데 적합합니다.

00:01:30.000 --> 00:01:32.000
다음은 몇 가지 일반적인 사용 사례입니다.

00:01:32.000 --> 00:01:36.000
몇 가지 기준에 따라 데이터를 그룹화하는 것; 예를 들어, 연령별로 사람들을 그룹화하는 것.

00:01:36.000 --> 00:01:38.000
공통 가치에 대한 데이터 세트 결합하기.

00:01:38.000 --> 00:01:43.000
예를 들어, 구매자의 정보와 거래 테이블을 결합하는 것.

00:01:43.000 --> 00:01:48.000
점진적으로 처리하거나 전체 데이터 세트의 하위 집합으로 필터링하기 위해 데이터를 분할하거나 분할합니다.

00:01:48.000 --> 00:01:53.000
그리고 데이터 파이프라인 구축; 예를 들어, 기계 학습을 위한 기능 엔지니어링을 할 때.

00:01:53.000 --> 00:01:57.000
프레임워크의 맥락에서, 테이블은 DataFrame으로 알려져 있다.

00:01:57.000 --> 00:02:00.000
DataFrame에는 스프레드시트와 유사한 행과 열이 포함되어 있습니다.

00:02:00.000 --> 00:02:04.000
하지만 스프레드시트와 달리, 모든 열은 특정 유형의 값만 포함할 수 있다.

00:02:04.000 --> 00:02:08.000
하지만 이것은 또한 열이 모든 유형, 심지어 자신의 사용자 지정 유형을 보유할 수 있다는 것을 의미합니다.

00:02:08.000 --> 00:02:12.000
예를 들어, 사전, GPS 좌표 또는 원시 오디오 샘플.

00:02:12.000 --> 00:02:18.000
DataFrame 또는 DataFrame 슬라이스를 나타내는 테이블을 표시할 때마다 왼쪽에 인덱스 열을 포함한다는 것을 알아두세요.

00:02:18.000 --> 00:02:21.000
이것은 데이터 인덱스로 행에 액세스해야 할 때와 관련이 있습니다.

00:02:21.000 --> 00:02:29.000
필터와 같은 일부 작업은 데이터가 변경되지 않는 반면, 정렬과 같은 다른 작업은 결과 데이터 프레임의 인덱스를 변경할 수 있습니다.

00:02:29.000 --> 00:02:31.000
그것을 분해하고 열을 확대해 봅시다.

00:02:31.000 --> 00:02:35.000
내가 언급했듯이, 열에는 특정 요소 유형이 있다; 이 경우, Int.

00:02:35.000 --> 00:02:37.000
그것은 또한 데이터 프레임에서 고유해야 하는 이름을 가지고 있다.

00:02:37.000 --> 00:02:41.000
열은 배열과 마찬가지로 컬렉션인 열 유형으로 표시됩니다.

00:02:41.000 --> 00:02:45.000
이름으로 열을 참조할 수 있지만, 대부분의 경우 유형도 필요합니다.

00:02:45.000 --> 00:02:51.000
열의 이름과 유형을 보유하고 있으며 특정 열을 참조하는 데 사용할 수 있는 ColumnID라는 구조체가 있습니다.

00:02:51.000 --> 00:02:56.000
가능하다면, 열을 참조하기 위해 문자열 리터럴보다 미리 정의된 ColumnID를 사용하는 것이 좋습니다.

00:02:56.000 --> 00:03:00.000
또한 DataFrame의 모든 열에는 동일한 수의 요소가 있어야 합니다.

00:03:00.000 --> 00:03:04.000
하지만 nil 값으로 표현되는 누락된 요소가 항상 있을 수 있다.

00:03:04.000 --> 00:03:06.000
기둥과 비슷하게, 행 유형이 있다.

00:03:06.000 --> 00:03:10.000
열 이름이나 인덱스로 행의 각 요소에 접근할 수 있습니다.

00:03:10.000 --> 00:03:12.000
당신은 로우를 프록시로 생각할 수 있습니다.

00:03:12.000 --> 00:03:17.000
그것은 실제로 행의 요소를 포함하지 않습니다; 대신, DataFrame의 행을 가리키는 참조입니다.

00:03:17.000 --> 00:03:19.000
그래서 DataFrame은 어떻게 만드나요?

00:03:19.000 --> 00:03:20.000
내가 보여줄게.

00:03:20.000 --> 00:03:25.000
사전 리터럴에서 DataFrame을 만들거나 한 번에 하나의 열을 만들 수 있습니다.

00:03:25.000 --> 00:03:28.000
이것은 사전 문자 그대로의 건축의 예이다.

00:03:28.000 --> 00:03:35.000
사전 리터럴을 사용할 때, 문자열, 숫자, 부울 값 및 날짜와 같은 기본 스위프트 유형을 사용해야 합니다.

00:03:35.000 --> 00:03:39.000
또한 모든 열에는 같은 수의 요소가 있어야 한다는 것을 명심하세요.

00:03:39.000 --> 00:03:45.000
DataFrame을 구축하는 더 일반적인 방법은 한 번에 하나의 열을 만든 다음 DataFrame에 열을 추가하는 것입니다.

00:03:45.000 --> 00:03:46.000
여기 예시가 있어.

00:03:46.000 --> 00:03:48.000
먼저, 나는 빈 데이터프레임을 만든다.

00:03:48.000 --> 00:03:50.000
그리고 나서 나는 기둥을 만든다.

00:03:50.000 --> 00:03:52.000
그리고 나서 DataFrame에 열을 추가합니다.

00:03:52.000 --> 00:04:00.000
모든 열에 대한 프로세스를 반복할 수 있지만, 다시 말하지만, 모든 열에 동일한 수의 요소가 있고 열 이름이 고유한지 확인하십시오.

00:04:00.000 --> 00:04:03.000
이제 DataFrame이 무엇인지 알았으니, 데이터 탐색을 좀 해봅시다.

00:04:03.000 --> 00:04:05.000
가장 먼저 하고 싶은 일은 데이터 세트를 로드하는 것입니다.

00:04:05.000 --> 00:04:10.000
TabularData는 쉼표로 구분된 값, CSV 및 JSON 파일 읽기를 지원합니다.

00:04:10.000 --> 00:04:16.000
그리고 모든 기본 옵션을 사용하여 로드되는 파일 URL로 이니셜라이저를 호출하는 것만큼 간단합니다.

00:04:16.000 --> 00:04:19.000
CSV를 로드할 때 사용할 수 있는 몇 가지 옵션을 살펴봅시다.

00:04:19.000 --> 00:04:23.000
이전에 CSV를 사용한 적이 있다면, 항상 쉼표가 있는 것은 아니라는 것을 알 수 있습니다.

00:04:23.000 --> 00:04:26.000
구분 기호는 탭이나 세미콜론일 수 있다.

00:04:26.000 --> 00:04:29.000
또는 열 이름이 있는 헤더 행이 있을 수도 있고 없을 수도 있습니다.

00:04:29.000 --> 00:04:34.000
또한 문자열이 특수 문자에 대해 이스케이프되는 방법과 누락된 값이 어떻게 표현되는지에 대한 변형이 있다.

00:04:34.000 --> 00:04:37.000
TabularData는 모든 변형을 처리할 수 있다.

00:04:37.000 --> 00:04:45.000
이 예에서는 사용자 지정 nil 인코딩을 사용하고, 빈 줄을 무시하고, 세미콜론 구분 기호를 사용하여 헤더 행이 없다는 것을 지정하고 있습니다.

00:04:45.000 --> 00:04:49.000
전체 옵션 세트와 기본값을 보려면 문서를 참조하십시오.

00:04:49.000 --> 00:04:54.000
더 큰 파일이 있다면, 한 번에 행의 하위 집합만 로드할 수 있습니다.

00:04:54.000 --> 00:04:55.000
행 옵션으로 이것을 할 수 있습니다.

00:04:55.000 --> 00:04:59.000
예를 들어, 이것은 처음 100개의 행만 로드할 것이다.

00:04:59.000 --> 00:05:02.000
마찬가지로, 열의 하위 집합을 선택할 수 있습니다.

00:05:02.000 --> 00:05:04.000
이렇게 하려면, 열 인수를 사용하세요.

00:05:04.000 --> 00:05:09.000
이것은 또한 당신이 열을 재구성할 수 있게 해준다는 점에 유의하세요.

00:05:09.000 --> 00:05:13.000
CSV 파일을 로드할 때 유형 추론이 어떻게 작동하는지 간략하게 이야기하겠습니다.

00:05:13.000 --> 00:05:15.000
CSV 파일은 모두 텍스트 기반입니다.

00:05:15.000 --> 00:05:18.000
하지만 모든 열을 문자열 유형으로 하는 것은 그다지 편리하지 않다.

00:05:18.000 --> 00:05:26.000
따라서 CSV 파일을 로드할 때, TabularData는 문자열로 기본 설정하기 전에 값을 숫자, 부울 값 및 날짜로 변환하려고 시도합니다.

00:05:26.000 --> 00:05:32.000
값을 특정 유형으로 강제하거나 로딩 속도를 조금 높이고 싶다면, 열의 유형을 명시적으로 지정할 수 있습니다.

00:05:32.000 --> 00:05:34.000
당신은 유형 논쟁으로 이것을 합니다.

00:05:34.000 --> 00:05:39.000
이 예에서, 우리는 id 열의 정수 유형과 이름 열의 문자열 유형을 지정하고 있습니다.

00:05:39.000 --> 00:05:45.000
이것은 로딩 프로세스의 속도를 높일 뿐만 아니라, 지정된 유형으로 변환할 수 없는 값이 있는 경우 오류가 발생합니다.

00:05:45.000 --> 00:05:56.000
이것은 당신이 기대하는 것과 다른 유형의 열로 끝나는 대신 문제를 일찍 파악하고 적절하게 처리할 수 있기 때문에 좋습니다. 이로 인해 나중에 앱에서 충돌이 발생할 수 있습니다.

00:05:56.000 --> 00:05:58.000
마지막으로, 날짜 구문 분석에 대해 언급하겠습니다.

00:05:58.000 --> 00:06:02.000
TabularData는 기본적으로 ISO8601 형식으로 날짜를 감지하고 구문 분석합니다.

00:06:02.000 --> 00:06:08.000
CSV 파일에 다른 형식의 날짜가 포함되어 있다면, 사용자 지정 날짜 구문 분석 전략을 지정해야 합니다.

00:06:08.000 --> 00:06:12.000
데이비드가 이것에 대해 이야기하게 하고 우리가 데모에 들어갈 때 너에게 예시를 보여줄게.

00:06:12.000 --> 00:06:15.000
이제 기어를 바꾸고 데이터를 작성하는 것에 대해 이야기해 봅시다.

00:06:15.000 --> 00:06:18.000
처음이자 가장 간단한 선택은 스위프트의 인쇄 기능을 사용하는 것이다.

00:06:18.000 --> 00:06:21.000
이것은 터미널에서 멋지게 인쇄된 테이블을 생성할 것이다.

00:06:21.000 --> 00:06:29.000
인쇄된 출력에는 행 인덱스, 열 이름, 열 유형, 처음 몇 줄의 데이터, 행과 열 수가 포함됩니다.

00:06:29.000 --> 00:06:34.000
그것은 또한 모든 행이 화면에 맞지 않으며 모든 열이 화면에 맞지 않는다는 것을 나타냅니다.

00:06:34.000 --> 00:06:38.000
이 경우, 표시되지 않는 열이 10개 더 있습니다.

00:06:38.000 --> 00:06:42.000
인쇄는 탐색과 디버깅에 좋지만, 분명히 데이터 저장에는 좋지 않다.

00:06:42.000 --> 00:06:47.000
DataFrame을 CSV 파일로 저장하려면, writeCSV 방법을 사용하세요.

00:06:47.000 --> 00:06:51.000
주목해야 할 한 가지 중요한 점은 writeCSV가 모든 값의 기본 문자열 변환을 사용한다는 것입니다.

00:06:51.000 --> 00:06:58.000
생성된 CSV는 다시 읽을 수 있는 것이 아닐 수 있으므로 열에서 사용자 지정 유형을 사용할 때 주의하십시오.

00:06:58.000 --> 00:07:05.000
일반적으로 CSV로 쓸 때 열의 기본 스위프트 유형만 사용하며, 일부 열을 변환해야 할 수 있습니다.

00:07:05.000 --> 00:07:08.000
writeCSV에는 읽기 옵션과 비슷한 몇 가지 옵션이 있습니다.

00:07:08.000 --> 00:07:11.000
CSV 데이터가 작성되는 방식을 사용자 정의할 수 있습니다.

00:07:11.000 --> 00:07:16.000
다음은 사용자 지정 nil 인코딩과 사용자 지정 구분 기호를 사용하여 헤더를 비활성화하는 예입니다.

00:07:16.000 --> 00:07:20.000
특정 행에 접근하려면, 행 첨자를 사용할 수 있습니다.

00:07:20.000 --> 00:07:23.000
그러면 그 행의 특정 열에 접근할 수 있습니다.

00:07:23.000 --> 00:07:26.000
하지만 가능할 때마다, 대신 먼저 열에 접근한 다음 행에 접근해야 합니다.

00:07:26.000 --> 00:07:28.000
이것이 당신이 칼럼에 접근하는 방법입니다.

00:07:28.000 --> 00:07:33.000
이름으로 열에 접근하는 경우, 첨자에서 열: 라벨을 생략할 수 있습니다.

00:07:33.000 --> 00:07:35.000
행의 하위 집합에 접근할 수도 있습니다.

00:07:35.000 --> 00:07:37.000
이 경우, DataFrame 슬라이스를 얻을 수 있습니다.

00:07:37.000 --> 00:07:40.000
DataFrame 슬라이스는 DataFrame과 매우 유사하다.

00:07:40.000 --> 00:07:47.000
그것은 기본적으로 원래 DataFrame에 대한 참조입니다. 대부분의 상황에서, 당신은 그것이 전체 DataFrame인지 슬라이스인지 알 필요조차 없습니다.

00:07:47.000 --> 00:07:50.000
그리고 마지막으로, 열의 하위 집합을 선택할 수도 있습니다.

00:07:50.000 --> 00:07:53.000
이것은 그 열만 포함하는 새로운 DataFrame을 반환할 것이다.

00:07:53.000 --> 00:07:56.000
필터 방법으로 행의 하위 집합을 선택할 수도 있습니다.

00:07:56.000 --> 00:08:00.000
필터 작업의 결과는 행 범위를 선택하는 것과 유사한 DataFrame 슬라이스입니다.

00:08:00.000 --> 00:08:05.000
하지만 다양한 행과 달리, 필터는 인접하지 않은 행을 반환할 수 있다.

00:08:05.000 --> 00:08:08.000
DataFrame 슬라이스 인덱스를 다룰 때 조심해야 합니다.

00:08:08.000 --> 00:08:12.000
배열 슬라이스와 마찬가지로, 그들의 인덱스는 원래 행의 인덱스를 반영한다.

00:08:12.000 --> 00:08:18.000
특히, 첫 번째 인덱스는 0이 아닐 수도 있고, 다음 인덱스는 현재 인덱스 플러스 1이 아닐 수도 있다.

00:08:18.000 --> 00:08:27.000
문자열 인덱스와 마찬가지로, 0 대신 startIndex, count 대신 endIndex, 하나를 추가하는 대신 index(after:)를 사용하고 싶습니다.

00:08:27.000 --> 00:08:31.000
이제 기본 사항을 다뤘으니, 앱을 만들어 실행에 옮기자.

00:08:31.000 --> 00:08:34.000
샌프란시스코에서 주차장을 찾는 것은 어렵다.

00:08:34.000 --> 00:08:38.000
데이비드와 나는 거리의 인근 주차 공간을 보여주는 아이폰 앱을 만들고 싶다.

00:08:38.000 --> 00:08:44.000
우리는 현재 주차가 허용되는 곳 근처에 있는 주차 미터기를 식별하기 위해 도시에서 발표한 데이터를 사용하고 싶습니다.

00:08:44.000 --> 00:08:47.000
우리는 데이터 세트가 있다는 것을 알고 있지만 그것이 무엇을 포함하고 있는지 정확히 알지 못한다.

00:08:47.000 --> 00:08:51.000
그래서 첫 번째 단계는 우리가 가진 것을 이해하기 위해 데이터 세트를 탐구하는 것이다.

00:08:51.000 --> 00:08:53.000
내가 그걸 데이비드에게 넘겨줄게.

00:08:53.000 --> 00:08:54.000
데이비드 핀들레이: 고마워, 알레한드로.

00:08:54.000 --> 00:08:57.000
안녕. 저는 프레임워크 엔지니어인 데이비드입니다.

00:08:57.000 --> 00:09:01.000
이 데모에서는 TabularData를 사용하여 데이터 세트를 탐색하는 방법의 예를 살펴보겠습니다.

00:09:01.000 --> 00:09:05.000
주차 정책의 CSV 파일을 살펴보는 것으로 시작하겠습니다.

00:09:05.000 --> 00:09:11.000
첫 번째 단계는 데이터 URL을 DataFrame 이니셜라이저에 전달하여 쉽게 할 수 있는 데이터를 로드하는 것입니다.

00:09:11.000 --> 00:09:16.000
이니셜라이저는 던질 수 있으며, 잠재적인 구문 분석 오류를 처리할 때 유용하다고 생각합니다.

00:09:16.000 --> 00:09:26.000
다음으로, 간단한 인쇄로 처음 몇 개의 행과 열을 탐색할 수 있습니다.

00:09:26.000 --> 00:09:32.000
로드하는 데 몇 초가 걸렸고, 이는 DataFrame이 백만 개 이상의 행과 15개의 열을 메모리에 로드했기 때문입니다.

00:09:32.000 --> 00:09:43.000
처음으로 데이터 세트를 탐색할 때, 나는 보통 전체 데이터 세트가 필요하지 않으므로, 탐색 속도를 높이기 위해 데이터를 로드할 때 행 범위를 지정할 것이다.

00:09:43.000 --> 00:09:46.000
다음으로, 나는 칼럼을 살펴볼 것이다.

00:09:46.000 --> 00:09:50.000
그들 중 두 개는 화면에 맞지 않기 때문에 오른쪽에 숨겨져 있다는 것을 주목하세요.

00:09:50.000 --> 00:09:56.000
포맷 옵션으로 그것을 고치는 방법을 보여드리겠습니다.

00:09:56.000 --> 00:09:59.000
포맷 옵션을 사용하면 데이터가 표시되는 방식을 구성할 수 있습니다.

00:09:59.000 --> 00:10:09.000
이 경우, 나는 최대 LineWidth를 250으로 늘리고, 열 너비를 15로 줄이고, 인쇄된 결과를 스크롤하는 것을 방지하기 위해 행을 5로 줄일 것이다.

00:10:09.000 --> 00:10:21.000
그런 다음 설명 방법을 사용하여 인쇄 문에 서식 옵션을 간단히 추가할 수 있습니다.

00:10:21.000 --> 00:10:26.000
좋아! 이제 내 모든 칼럼을 살펴볼 수 있으니, 나는 보관할 몇 가지 흥미로운 칼럼을 고를 것이다.

00:10:26.000 --> 00:10:31.000
또한 내가 원하는 순서대로 나열하여 칼럼을 재구성할 수 있는 좋은 기회이다.

00:10:31.000 --> 00:10:37.000
저는 Hourly Rate, DayOfWeek, 시작 및 종료 시간, 시작 날짜 및 PostID가 있습니다.

00:10:37.000 --> 00:10:45.000
다음으로 해야 할 일은 DataFrame을 로드할 때 이 열을 매개 변수로 추가하는 것입니다.

00:10:45.000 --> 00:10:48.000
좋아, 이건 이미 탐험하기가 훨씬 쉬워.

00:10:48.000 --> 00:10:51.000
문자열 유형이 있는 StartDate 열을 살펴보세요.

00:10:51.000 --> 00:10:55.000
그것은 ISO8601 날짜만 자동으로 감지되기 때문이다.

00:10:55.000 --> 00:10:59.000
다른 날짜 형식을 명시적으로 지정해야 합니다.

00:10:59.000 --> 00:11:03.000
나는 알레한드로가 이전에 설명한 CSVReadingOptions를 사용하여 그것을 고칠 수 있다.

00:11:03.000 --> 00:11:07.000
파운데이션 날짜 구문 분석 API를 사용하여 날짜 구문 분석 전략을 추가할 것입니다.

00:11:07.000 --> 00:11:15.000
나는 형식을 년, 월, 일로, 로케일을 미국 영어로, 그리고 시간대를 태평양 표준시로 지정할 것이다.

00:11:15.000 --> 00:11:23.000
그런 다음 DataFrame을 로드할 때 CSVReadingOptions를 전달할 것입니다.

00:11:23.000 --> 00:11:30.000
이제 StartDate 열에 올바른 유형이 있으므로, 활성 주차 정책만 가질 수 있도록 DataFrame을 쉽게 필터링할 수 있습니다.

00:11:30.000 --> 00:11:37.000
현재 날짜를 나타내는 변수로 시작한 다음, 필터 방법을 사용하여 DataFrame을 필터링할 것입니다.

00:11:37.000 --> 00:11:43.000
필터 메서드는 열 이름 -- 이 경우, StartDate -- 및 유형 -- Date를 사용합니다.

00:11:43.000 --> 00:11:51.000
클로저에서, 선택적 날짜를 풀고, 날짜 값이 nil일 때 false를 반환하여 필터 결과에 나타나지 않습니다.

00:11:51.000 --> 00:11:55.000
그리고 마지막으로, 나는 현재 날짜보다 작거나 같은 시작 날짜를 유지한다.

00:11:55.000 --> 00:12:04.000
필터링된 결과를 보여주기 위해 인쇄물을 변경하겠습니다.

00:12:04.000 --> 00:12:07.000
이제부터, 나는 StartDate 열이 필요하지 않을 것이므로, 계속해서 제거할 것이다.

00:12:07.000 --> 00:12:11.000
하지만 DataFrame 슬라이스에서 열을 제거할 수 없기 때문에 조심해야 합니다.

00:12:11.000 --> 00:12:18.000
열을 제거하는 것은 돌연변이 방법이기 때문에 먼저 DataFrame으로 변환하고 var의 필터링된 정책을 만들어야 합니다.

00:12:18.000 --> 00:12:27.000
이제 removeColumn 방법을 사용하여 열을 제거하고 StartDate 열을 제거할 열로 지정할 수 있습니다.

00:12:27.000 --> 00:12:31.000
좋아, 그게 내가 주차 정책 데이터 세트에서 탐구하고 싶었던 전부야.

00:12:31.000 --> 00:12:36.000
다음 섹션에서, 알레한드로는 표 데이터를 보강할 수 있는 방법에 대해 논의할 것입니다.

00:12:36.000 --> 00:12:38.000
너에게 돌아가, 알레한드로!

00:12:38.000 --> 00:12:39.000
알레한드로: 고마워, 데이비드.

00:12:39.000 --> 00:12:41.000
이제 나는 데이터 세트에 대한 훌륭한 통찰력을 가지고 있다.

00:12:41.000 --> 00:12:46.000
다음 단계는 우리의 필요에 맞게 그것을 변형하고 보강하는 것이다.

00:12:46.000 --> 00:12:50.000
가장 간단한 종류의 변환은 열 내의 값을 바꾸는 것이다.

00:12:50.000 --> 00:12:55.000
이것은 각 값이 다른 유형의 새로운 값으로 매핑되는 지도 작업의 형태를 취할 수 있다.

00:12:55.000 --> 00:13:00.000
TabularData는 편의를 위해 지도의 현장 버전을 제공합니다: transformColumn.

00:13:00.000 --> 00:13:06.000
이 예에서, 저는 DayOfWeek 열을 문자열에서 평일을 나타내는 정수로 변환하고 있습니다.

00:13:06.000 --> 00:13:08.000
이것이 코드의 모습일 것이다.

00:13:08.000 --> 00:13:14.000
각 요소에 대해, 우리는 문자열을 Int로 변환합니다.

00:13:14.000 --> 00:13:18.000
transformColumn과 마찬가지로, 디코딩 방법은 데이터 디코딩을 처리합니다.

00:13:18.000 --> 00:13:24.000
CSV 파일을 다룰 때, CSV에 JSON 값으로 포함된 배열이나 사전이 발생할 수 있습니다.

00:13:24.000 --> 00:13:26.000
TabularData는 이를 위한 디코딩 방법을 제공한다.

00:13:26.000 --> 00:13:30.000
다음은 왼쪽의 DataFrame에 JSON 데이터 BLOB이 포함된 예입니다.

00:13:30.000 --> 00:13:37.000
디코드를 사용하면 JSONDecoder를 사용하여 열을 자신만의 유형으로 변환할 수 있습니다. 이 예에서는 환경 설정입니다.

00:13:37.000 --> 00:13:39.000
그리고 이것이 코드가 어떻게 생겼는지이다.

00:13:39.000 --> 00:13:48.000
환경 설정 유형은 Decodable 프로토콜을 준수해야 하며, 열은 JSONDecoder가 입력으로 기대하는 데이터 유형의 요소를 포함해야 한다는 것을 명심하십시오.

00:13:48.000 --> 00:13:51.000
또 다른 유용한 작업은 채워진 방법이다.

00:13:51.000 --> 00:13:54.000
열의 모든 누락된 값을 기본값으로 바꿀 수 있습니다.

00:13:54.000 --> 00:13:58.000
그리고 열 작업 목록을 끝내기 위해, 나는 요약을 언급하고 싶다.

00:13:58.000 --> 00:14:01.000
요약은 열의 내용에 대한 간략한 개요를 제공합니다.

00:14:01.000 --> 00:14:03.000
요약 방법은 범주형 요약을 반환합니다.

00:14:03.000 --> 00:14:14.000
그것은 설명에 someCount로 표시된 요소의 수, noneCount로 표시된 누락된 요소의 수, 고유한 요소의 수, 그리고 모드로 알려진 가장 빈번한 값을 포함합니다.

00:14:14.000 --> 00:14:18.000
숫자 값이 포함된 열에서만 사용할 수 있는 숫자 요약도 있습니다.

00:14:18.000 --> 00:14:23.000
여기에는 카운트, 평균, 표준 편차 및 기타 통계도 포함됩니다.

00:14:23.000 --> 00:14:25.000
여기, 저는 요약의 인쇄 결과를 보여주고 있습니다.

00:14:25.000 --> 00:14:29.000
하지만 요약 구조를 직접 사용하여 통계에 접근할 수도 있습니다.

00:14:29.000 --> 00:14:34.000
예를 들어, 75번째 백분위수로 점수를 필터링하고 싶다면.

00:14:34.000 --> 00:14:38.000
좋아, 그건 많은 열 변환이었지만, 열 변환은 가장 흥미롭지 않아.

00:14:38.000 --> 00:14:41.000
데이터프레임 변환은 정말 흥미로워지는 곳이다.

00:14:41.000 --> 00:14:45.000
열 변환과 달리, DataFrame 변환은 한 번에 여러 열을 조작합니다.

00:14:45.000 --> 00:14:47.000
간단한 예는 정렬이다.

00:14:47.000 --> 00:14:50.000
우리 모두는 정렬이 어떻게 작동하는지 알고 있지만, 명확하게 설명하겠습니다.

00:14:50.000 --> 00:14:52.000
이 표를 점수로 분류해 봅시다.

00:14:52.000 --> 00:14:53.000
이것은 모든 열에 영향을 미친다.

00:14:53.000 --> 00:14:59.000
또한 정렬할 때 행 인덱스가 바뀐다는 점에 유의하세요.

00:14:59.000 --> 00:15:02.000
또 다른 흥미로운 DataFrame 변환은 combineColumns이다.

00:15:02.000 --> 00:15:06.000
combineColumns 방법을 사용하면 여러 열을 하나로 결합할 수 있습니다.

00:15:06.000 --> 00:15:12.000
예를 들어, 위도와 경도에 대해 별도의 열이 있지만 CLLocation 유형으로 결합하고 싶다고 상상해 보세요.

00:15:12.000 --> 00:15:14.000
여기 이것을 하는 예가 있습니다.

00:15:14.000 --> 00:15:17.000
먼저, 나는 결합하고 싶은 열을 지정한다.

00:15:17.000 --> 00:15:18.000
그리고 나서 나는 새 칼럼에 이름을 붙인다.

00:15:18.000 --> 00:15:23.000
그런 다음 입력 열과 새 열의 유형을 지정하고, 모든 것이 선택 사항이어야 한다는 점에 유의합니다.

00:15:23.000 --> 00:15:28.000
나는 누락된 가치 사례를 처리하고, 새로운 가치를 구축한다.

00:15:28.000 --> 00:15:31.000
열과 마찬가지로, DataFrame에 대한 요약 방법도 있다.

00:15:31.000 --> 00:15:33.000
그것은 모든 열에 대한 요약 통계를 반환합니다.

00:15:33.000 --> 00:15:39.000
큰 DataFrame이 있는 경우 비용이 많이 들 수 있습니다. 관심 있는 열만 요약하는 것이 더 나을 수 있습니다.

00:15:39.000 --> 00:15:42.000
또 다른 흥미로운 방법은 폭발이다.

00:15:42.000 --> 00:15:47.000
요소 배열을 포함하는 열을 취하고 배열의 모든 요소에 대해 새 행을 만듭니다.

00:15:47.000 --> 00:15:49.000
이 예시를 살펴봅시다.

00:15:49.000 --> 00:15:53.000
이번에는 점수 열에 각 사람에 대한 점수 배열이 포함되어 있습니다.

00:15:53.000 --> 00:15:57.000
폭발 작업을 DataFrame에 적용하면, 이들 각각은 새로운 행이 된다.

00:15:57.000 --> 00:16:00.000
우리는 여러 점수를 가진 사람들을 위해 이름을 반복했다.

00:16:00.000 --> 00:16:05.000
이것은 각 개별 점수를 살펴야 하는 다른 작업을 필터링하거나 수행할 때 유용합니다.

00:16:05.000 --> 00:16:11.000
우리의 무기고에 있는 이 도구들로 나는 그것을 데이비드에게 돌려줄 것이다. 데이비드는 우리가 미터 데이터를 필요한 형태로 얻는 데 도움을 줄 것이다.

00:16:11.000 --> 00:16:13.000
데이비드, 우리에게 코드를 좀 보여줘.

00:16:13.000 --> 00:16:14.000
데이비드: 고마워, 알레한드로.

00:16:14.000 --> 00:16:18.000
나는 너에 대해 모르지만, 나에게 주차에 대한 가장 중요한 부분은 위치야.

00:16:18.000 --> 00:16:21.000
운 좋게도, 나는 내가 필요한 것을 가지고 있는 또 다른 CSV 파일을 가지고 있다.

00:16:21.000 --> 00:16:23.000
그 안에 뭐가 있는지 보여줄게.

00:16:23.000 --> 00:16:28.000
이전과 마찬가지로, 나는 데이터를 로드하는 것으로 시작할 것이지만, 이번에는 내가 관심 있는 열을 이미 알고 있다.

00:16:28.000 --> 00:16:37.000
저는 POST_ID, STREET_NAME, STREET_NUM, LATITUDE 및 LONGITUDE를 가지고 있으며, 이전 데모와 동일한 서식 옵션을 사용하여 결과를 인쇄할 것입니다.

00:16:37.000 --> 00:16:44.000
내가 원하는 첫 번째 보강은 위도와 경도 열을 핵심 위치 유형이 있는 새로운 열로 결합하는 것이다.

00:16:44.000 --> 00:16:47.000
combineColumns 방법은 그 작업에 완벽하다.

00:16:47.000 --> 00:16:52.000
여기서, 저는 위도와 경도 열을 위치라는 새로운 열로 결합하고 있습니다.

00:16:52.000 --> 00:16:58.000
클로저에서, 저는 위도와 경도 매개 변수 유형과 핵심 위치 반환 유형을 지정합니다.

00:16:58.000 --> 00:17:03.000
다음으로, 선택적 위도와 경도 값을 풀고, 둘 중 하나가 nil인 경우 nil을 반환합니다.

00:17:03.000 --> 00:17:08.000
그리고 마지막으로, 위도와 경도 값을 핵심 위치 이니셜라이저로 전달합니다.

00:17:08.000 --> 00:17:15.000
내 DataFrame의 위치로, 나는 내 앱의 첫 번째 기능을 구축하기 시작할 수 있다: 위치가 주어지면, 가장 가까운 주차 미터를 검색한다.

00:17:15.000 --> 00:17:22.000
위치, DataFrame 및 검색 결과에 포함할 주차 미터의 양을 차지하는 closestParking이라는 함수를 작성할 것입니다.

00:17:22.000 --> 00:17:24.000
로컬 카피로 시작하겠습니다.

00:17:24.000 --> 00:17:30.000
그리고 나서 알레한드로가 이전에 도입한 transformColumn 방법을 사용하여, 나는 위치를 거리로 바꿀 것이다.

00:17:30.000 --> 00:17:34.000
그리고 나서, 물론, 나는 위치 열의 이름을 거리로 바꿀 것이다.

00:17:34.000 --> 00:17:40.000
마지막으로, 거리 열을 오름차순으로 정렬하고 반환할 지점의 수를 제한하겠습니다.

00:17:40.000 --> 00:17:44.000
그냥 재미로, 샌프란시스코에 있는 애플 스토어를 사용하여 이것을 테스트해 봅시다.

00:17:44.000 --> 00:17:51.000
Apple Maps, 미터 DataFrame에서 찾은 좌표를 연결하고 검색 결과를 5개의 주차 공간으로 제한하겠습니다.

00:17:51.000 --> 00:17:56.000
완벽해! 포스트 스트리트에 있는 애플 스토어 근처에 주차장이 많은 것 같다.

00:17:56.000 --> 00:18:01.000
앱의 첫 번째 기능은 잘 작동하지만, 가장 가까운 주차장이 모두 이미 이용되었다면 어떨까요?

00:18:01.000 --> 00:18:05.000
이 앱의 다음 기능은 주차 공간이 가장 많은 거리를 찾는 것이다.

00:18:05.000 --> 00:18:10.000
하지만 이 기능을 구현하기 전에, 그룹화라는 새로운 개념을 소개하겠습니다.

00:18:10.000 --> 00:18:13.000
그룹화하면 그룹화 열이 주어지면 데이터를 그룹으로 나눕니다.

00:18:13.000 --> 00:18:15.000
예를 들어, STREET_NAME 열.

00:18:15.000 --> 00:18:25.000
그룹 방법은 먼저 포스트 스트리트, 캘리포니아 스트리트, 미션 스트리트와 같은 고유한 거리 이름 값을 식별한 다음 행을 해당 그룹으로 나눕니다.

00:18:25.000 --> 00:18:27.000
각 그룹은 DataFrame 슬라이스이다.

00:18:27.000 --> 00:18:30.000
이제, 코드로 다시 들어가 봅시다.

00:18:30.000 --> 00:18:34.000
나는 그룹화된 방법을 사용하여 거리 이름으로 미터를 그룹화할 것이다.

00:18:34.000 --> 00:18:39.000
그러면 나는 각 거리 그룹이 얼마나 많은 주차 미터를 가지고 있는지 세고 결과를 내림차순으로 제공할 수 있다.

00:18:39.000 --> 00:18:44.000
주차 공간이 가장 많은 거리는 결과의 맨 위에 있으며, 이것이 내 앱에 필요한 것이다.

00:18:44.000 --> 00:18:45.000
이건 정말 멋져!

00:18:45.000 --> 00:18:47.000
내 앱을 위한 두 가지 훌륭한 기능.

00:18:47.000 --> 00:18:50.000
하지만 잠시만요, 저는 방금 첫 번째 기능에 버그가 있다는 것을 깨달았습니다.

00:18:50.000 --> 00:18:53.000
가장 가까운 주차 미터는 미터 데이터 프레임만 고려합니다.

00:18:53.000 --> 00:18:58.000
내가 정말로 필요한 것은 활성 주차 정책이 있는 가장 가까운 주차 미터기이다.

00:18:58.000 --> 00:19:02.000
그 정보가 데모의 데이터에 있기 때문에, 이것은 점점 흥미로워지고 있다.

00:19:02.000 --> 00:19:08.000
버그를 고칠 수 있도록 두 개의 다른 소스의 데이터를 결합하는 방법을 보여드리겠습니다.

00:19:08.000 --> 00:19:12.000
이전에 관계형 데이터베이스를 사용한 적이 있다면 가입에 익숙할 수 있습니다.

00:19:12.000 --> 00:19:15.000
키를 사용하여 두 개의 데이터프레임을 함께 결합할 수 있습니다.

00:19:15.000 --> 00:19:18.000
키는 두 데이터프레임 모두에 나타나는 값이다.

00:19:18.000 --> 00:19:23.000
미터와 정책 데이터프레임에서, 열쇠는 주차 미터를 고유하게 식별하는 POST_ID이다.

00:19:23.000 --> 00:19:30.000
조인 작업은 미터의 POST_ID가 정책의 POST_ID와 일치하는 행이 있는 DataFrame을 생성합니다.

00:19:30.000 --> 00:19:35.000
행은 왼쪽 DataFrame과 오른쪽 DataFrame의 일치하는 데이터로 구성되어 있습니다.

00:19:35.000 --> 00:19:38.000
열 이름에는 왼쪽 또는 오른쪽 접두사가 있습니다.

00:19:38.000 --> 00:19:41.000
이것은 열의 조인 중 어느 쪽에서 왔는지를 나타낸다.

00:19:41.000 --> 00:19:45.000
접두사는 조인 결과에서 명명 충돌을 피하는 데 도움이 된다.

00:19:45.000 --> 00:19:48.000
이 작업은 기본값인 내부 조인이었다.

00:19:48.000 --> 00:19:52.000
다른 세 가지 결합 종류가 있습니다: 왼쪽 바깥쪽, 오른쪽 바깥쪽, 그리고 전체 바깥쪽.

00:19:52.000 --> 00:19:56.000
여기서 자세한 내용은 다루지 않겠지만, 자세한 내용은 문서를 참조하십시오.

00:19:56.000 --> 00:20:00.000
좋아, 그게 내가 표 데이터 증강에서 다루고 싶었던 전부야.

00:20:00.000 --> 00:20:03.000
다음 섹션에서, 알레한드로는 모범 사례에 대해 이야기할 것이다.

00:20:03.000 --> 00:20:05.000
알레한드로: 고마워, 데이비드.

00:20:05.000 --> 00:20:08.000
이제 우리가 필요한 형태로 모든 데이터를 가졌으니, 앱을 구축할 때입니다.

00:20:08.000 --> 00:20:13.000
프로덕션을 준비하면서 탐색 코드를 재사용할 수 있는 방법에 대해 이야기하겠습니다.

00:20:13.000 --> 00:20:17.000
CSV 파일을 로드하기 위해 우리가 시작한 코드로 돌아가겠습니다.

00:20:17.000 --> 00:20:19.000
이렇게 하면, 열에는 알 수 없는 유형이 있을 것이다.

00:20:19.000 --> 00:20:25.000
이것은 필터나 미리 유형을 알아야 하는 조인과 같은 작업에 문제가 있습니다.

00:20:25.000 --> 00:20:29.000
사용자가 제공한 소스에서 데이터를 로드하는 경우, 유형에 대한 가정은 위험합니다.

00:20:29.000 --> 00:20:31.000
앱 충돌로 이어질 수 있습니다.

00:20:31.000 --> 00:20:36.000
대신, 이 예와 같이 데이터를 로드할 때 예상되는 유형을 선언해야 합니다.

00:20:36.000 --> 00:20:39.000
여기서, 나는 내가 신경 쓰는 모든 열에 대한 열 ID를 정의하고 있다.

00:20:39.000 --> 00:20:44.000
그리고 나서 나는 CSV 이니셜라이저에 열 이름과 열 유형을 모두 제공하고 있다.

00:20:44.000 --> 00:20:49.000
열을 참조하는 모든 방법에서 문자열 대신 열 ID를 사용할 수 있다는 것을 기억하세요.

00:20:49.000 --> 00:20:55.000
이제, 유효하지 않은 값이 있는 경우, 예를 들어 사용자에게 오류를 표시하여 처리할 수 있는 예외가 발생합니다.

00:20:55.000 --> 00:20:58.000
이렇게 하면 당신이 기대하는 열과 열 유형을 가질 수 있습니다.

00:20:58.000 --> 00:21:08.000
이것은 사용자 지정 날짜 형식을 사용할 때 특히 중요합니다. 열이 날짜 유형이라고 지정하지 않으면 날짜 구문 분석이 자동으로 실패하고 대신 문자열 열을 생성할 수 있기 때문입니다.

00:21:08.000 --> 00:21:15.000
날짜를 강제로 사용하면 실패한 셀의 내용을 포함하는 예외가 발생하여 문제를 디버깅하는 데 도움이 될 것입니다.

00:21:15.000 --> 00:21:19.000
오류에 대해 말하자면, 이것들은 CSV 파일을 로드할 때 예상해야 하는 일종의 오류입니다.

00:21:19.000 --> 00:21:24.000
사용자 지정 날짜 파서를 사용하고 셀이 구문 분석에 실패할 때 구문 분석에 실패하면 생성됩니다.

00:21:24.000 --> 00:21:28.000
다른 것들은 자명하지만, 문서를 참조하십시오.

00:21:28.000 --> 00:21:31.000
그리고 끝내기 위해, 공연에 대해 간단히 언급하겠습니다.

00:21:31.000 --> 00:21:37.000
대부분의 경우 성능에 대해 걱정할 필요가 없지만, 대규모 데이터 세트로 작업할 때 큰 영향을 미칠 수 있는 몇 가지 경우가 있습니다.

00:21:37.000 --> 00:21:40.000
첫 번째는 CSV를 로드할 때 날짜 구문 분석이다.

00:21:40.000 --> 00:21:45.000
날짜 구문 분석에는 많은 특별한 사례와 고려 사항이 있으며, 따라서 느린 경향이 있다.

00:21:45.000 --> 00:21:50.000
CSV 파일을 로드하는 데 몇 초 이상 걸린다면, 이것은 당신이 개선해야 할 첫 번째 장소입니다.

00:21:50.000 --> 00:21:52.000
한 가지 옵션은 구문 분석을 지연시키는 것이다.

00:21:52.000 --> 00:21:56.000
이것은 날짜 정보가 즉시 필요하지 않을 때 특히 잘 작동합니다.

00:21:56.000 --> 00:21:58.000
예를 들어, 먼저 필터링이나 그룹화 작업을 수행하고 싶습니다.

00:21:58.000 --> 00:22:04.000
그것이 옵션이 아니라면, 날짜 문자열의 성능을 최적화하는 날짜 파서를 손으로 만드는 것을 고려해 보세요.

00:22:04.000 --> 00:22:10.000
그룹화할 때, 항상 문자열이나 Int와 같은 기본 Swift 유형을 그룹 열로 포함하는 열을 사용하세요.

00:22:10.000 --> 00:22:12.000
이것은 그룹화 성능을 가속화할 것이다.

00:22:12.000 --> 00:22:19.000
하나 이상의 열로 그룹화하는 경우, 먼저 열을 간단한 유형의 단일 열로 결합한 다음 그룹화하는 것을 고려하십시오.

00:22:19.000 --> 00:22:25.000
예를 들어, 요일과 미터 유형별로 그룹화하려면, 이 두 속성을 문자열로 결합하는 것을 고려해 보세요.

00:22:25.000 --> 00:22:26.000
예를 들어, 데이 타입.

00:22:26.000 --> 00:22:32.000
마찬가지로, 가입할 때, 기본 스위프트 유형이 포함된 열에 가입하는 것을 고려해 보세요.

00:22:32.000 --> 00:22:34.000
이것으로, 우리는 앱을 끝낼 준비가 되었습니다.

00:22:34.000 --> 00:22:36.000
데이비드, 마무리하자.

00:22:36.000 --> 00:22:41.000
데이비드: TabularData 모범 사례를 사용하여 앱의 검색 기능을 작성하겠습니다.

00:22:41.000 --> 00:22:44.000
주차 구조체는 결합된 미터와 정책 DataFrame을 저장할 것이다.

00:22:44.000 --> 00:22:48.000
그리고 나는 여러 방법이 필요하기 때문에 위치 ColumnID를 정의했다.

00:22:48.000 --> 00:22:51.000
loadMeters 방법의 세부 사항에 대해 자세히 알아봅시다.

00:22:51.000 --> 00:22:57.000
맨 위에는 미터기를 적재하는 데 필요한 열 ID가 있습니다.

00:22:57.000 --> 00:23:02.000
그런 다음, 나는 미터를 로드하고 각 열의 예상 유형을 지정한다.

00:23:02.000 --> 00:23:06.000
제공된 CSV 파일에 불일치가 있으면 던져질 것이다.

00:23:06.000 --> 00:23:12.000
다음으로 나는 해결된 열이 정확히 내가 예상했던 것인지 확인하고, 그렇지 않으면 사용자 지정 ParkingError를 던질 것이다.

00:23:12.000 --> 00:23:20.000
마지막으로, 위도, 경도 및 위치 열 ID를 사용하기 위해 combineColumns 작업을 리팩토링했습니다.

00:23:20.000 --> 00:23:22.000
그것으로, 앱의 검색 기능은 생산 준비가 되어 있다.

00:23:22.000 --> 00:23:27.000
TabularData 프레임워크의 요약을 위해 알레한드로에게 돌려줄게.

00:23:27.000 --> 00:23:29.000
알레한드로: 고마워, 데이비드. 요약하자.

00:23:29.000 --> 00:23:35.000
오늘 우리는 TabularData를 통해 알 수 없는 데이터 세트를 탐색하고, 조작하고, 앱으로 가져올 수 있는 방법을 보여주었습니다.

00:23:35.000 --> 00:23:43.000
우리는 데이터 세트를 탐구하고, 일부 열과 데이터 변환을 살펴보고, 오류 처리 및 성능에 대한 몇 가지 모범 사례로 마무리했습니다.

00:23:43.000 --> 00:23:46.000
나는 네가 훌륭한 앱을 만들기 위해 TabularData를 어떻게 사용하는지 빨리 보고 싶어.

00:23:46.000 --> 23:59:59.000
고마워!

