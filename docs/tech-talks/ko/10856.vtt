WEBVTT

00:00:01.000 --> 00:00:11.000
안녕. 제 이름은 Charles Circlaeys이고, 이 강연에서 우리는 렌더 루프의 커밋 단계에서 애니메이션 히치에서 스크롤에 뛰어들 것입니다.

00:00:11.000 --> 00:00:14.000
iOS는 렌더링 루프를 사용하여 보기를 표시합니다.

00:00:14.000 --> 00:00:24.000
터치 이벤트는 앱으로 전송되고, 보기를 변경하여 응답하며, 해당 보기는 iOS에 의해 디스플레이에 렌더링됩니다.

00:00:24.000 --> 00:00:30.000
우리는 렌더 루프의 커밋 단계에서 애니메이션 문제를 찾고 고치는 데 집중할 것이다.

00:00:30.000 --> 00:00:40.000
전체 렌더링 루프와 히치가 무엇인지에 대해 알아보려면, "UI 애니메이션 히치와 렌더링 루프 탐색" 비디오를 보세요.

00:00:40.000 --> 00:00:44.000
우리는 먼저 커밋 거래를 정의하는 것을 살펴볼 것입니다...

00:00:44.000 --> 00:00:48.000
도구를 사용하여 히치를 찾으세요...

00:00:48.000 --> 00:00:52.000
그리고 우리는 커밋 히치를 피하기 위해 우리의 권장 사항을 공유할 것이다.

00:00:52.000 --> 00:00:54.000
커밋 거래를 정의하는 것으로 시작합시다.

00:00:54.000 --> 00:01:01.000
여기, 현재 이벤트를 기다리고 있는 앱 뷰 계층 구조의 예가 있습니다.

00:01:01.000 --> 00:01:10.000
터치 이벤트를 받은 후, 뷰는 그것에 응답하고 일부 하위 뷰의 배경색이나 프레임을 변경하여 이벤트를 처리합니다.

00:01:10.000 --> 00:01:18.000
시스템은 이러한 하위 뷰가 다음 커밋 거래 중에 레이아웃이나 디스플레이가 필요하다는 것을 기록합니다.

00:01:18.000 --> 00:01:28.000
커밋 거래 중에, 디스플레이나 레이아웃이 필요한 뷰는 drawRect 또는 layoutSubviews를 호출하여 그에 따라 업데이트됩니다.

00:01:28.000 --> 00:01:32.000
커밋 거래와 관련된 여러 단계를 살펴봅시다.

00:01:32.000 --> 00:01:41.000
네 단계가 있습니다: 레이아웃 단계, 디스플레이 단계, 준비 단계, 그리고 마지막으로 커밋 단계.

00:01:41.000 --> 00:01:46.000
레이아웃 단계에서, 레이아웃이 필요한 모든 보기에 대해 layoutSubviews가 호출될 것이다.

00:01:46.000 --> 00:01:56.000
뷰 위치를 변경하거나, 뷰를 추가 또는 제거하거나, 뷰에서 setNeedsLayout을 명시적으로 호출하여 필요한 레이아웃을 표시할 수 있습니다.

00:01:56.000 --> 00:02:01.000
디스플레이 단계에서, drawRect는 디스플레이가 필요한 모든 보기에 대해 호출될 것이다.

00:02:01.000 --> 00:02:11.000
drawRect를 재정의하는 뷰 계층에 뷰를 추가하거나 setNeedsDisplay를 명시적으로 호출하여 디스플레이가 필요하다는 것을 나타낼 수 있습니다.

00:02:11.000 --> 00:02:18.000
준비 단계에서, 아직 해독되지 않은 이미지는 이 단계에서 해독될 것이다.

00:02:18.000 --> 00:02:23.000
이런 종류의 작업은 큰 이미지에 상당한 시간이 걸릴 수 있다.

00:02:23.000 --> 00:02:31.000
또한, 이미지가 GPU가 직접 작업할 수 없는 색상 형식인 경우, 이 단계에서 변환됩니다.

00:02:31.000 --> 00:02:40.000
이것은 원본에 포인터를 보내는 대신 이미지를 복사해야 하며, 이는 추가 시간과 메모리 비용이 들 것이다.

00:02:40.000 --> 00:02:48.000
앱의 이미지 최적화에 대해 자세히 알아보려면, "이미지 및 그래픽 모범 사례" 비디오를 시청하세요.

00:02:48.000 --> 00:02:56.000
마지막으로, 커밋 단계에서 뷰 계층 구조는 재귀적으로 패키징되어 렌더링 서버로 전송됩니다.

00:02:56.000 --> 00:03:01.000
딥 뷰 계층은 포장되는 데 더 오래 걸릴 것이라는 점에 유의하십시오.

00:03:01.000 --> 00:03:10.000
이제 커밋 거래의 세부 사항을 설명했으니, 두 번째 주제로 넘어가자: 악기로 히치 찾기.

00:03:10.000 --> 00:03:16.000
Xcode 12에서, 우리는 당신의 앱에서 히치를 프로파일링하기 위한 새로운 악기 템플릿을 출시했습니다.

00:03:16.000 --> 00:03:23.000
이것은 감지된 히칭 프레임에 대한 렌더링 루프를 시각화하고 조사하는 데 도움이 될 것입니다.

00:03:23.000 --> 00:03:26.000
예시 앱에서 몇 가지 걸쇠를 살펴봅시다.

00:03:26.000 --> 00:03:31.000
우리는 응용 프로그램에서 스크롤할 때 악기에 흔적을 기록할 것이다.

00:03:31.000 --> 00:03:43.000
그래서 여기서 우리는 스크롤 성능의 기록된 흔적을 가지고 있으며, 감지된 모든 히치를 볼 수 있습니다.

00:03:43.000 --> 00:03:48.000
히치 16을 자세히 살펴봅시다.

00:03:48.000 --> 00:03:56.000
우리는 왼쪽에서 프레임을 구성하는 데 필요한 렌더링 루프 단계에 해당하는 모든 트랙을 볼 수 있습니다.

00:03:56.000 --> 00:04:01.000
히치 트랙은 히치와 그 지속 시간을 보여준다.

00:04:01.000 --> 00:04:08.000
사용자 이벤트 트랙은 히칭 프레임으로 수신된 사용자 이벤트를 보여줍니다.

00:04:08.000 --> 00:04:14.000
커밋 트랙은 커밋 단계와 이 단계에서 커밋된 프로세스를 보여줍니다.

00:04:14.000 --> 00:04:22.000
패트릭은 "렌더 단계에서 히치의 신비화 및 제거"에서 렌더링과 GPU 트랙에 대해 더 많이 이야기할 것이다.

00:04:22.000 --> 00:04:28.000
프레임 라이프타임 트랙은 히칭 프레임을 구성하는 전체 기간을 보여줍니다.

00:04:28.000 --> 00:04:36.000
내장 디스플레이 트랙은 VSYNC 이벤트와 함께 디스플레이에 나타난 모든 프레임을 보여줍니다.

00:04:36.000 --> 00:04:46.000
프레임 수명을 히치 기간의 시작과 비교하여 프레임이 표시할 준비가 되어 있어야 하는 예상 간격을 시각화할 수 있습니다.

00:04:46.000 --> 00:04:49.000
이 간격은 허용 가능한 대기 시간이라고 불린다.

00:04:49.000 --> 00:04:53.000
그 이후의 모든 시간은 히치 기간이다.

00:04:53.000 --> 00:04:59.000
트랙 아래에서 히치 트랙이 선택되었을 때 히치에 대한 자세한 메트릭을 볼 수 있습니다.

00:04:59.000 --> 00:05:06.000
데모 앱에는 많은 문제가 있지만, 우리는 여기서 히치 16에 집중해 왔습니다.

00:05:06.000 --> 00:05:09.000
우리는 히치 기간을 볼 수 있어...

00:05:09.000 --> 00:05:12.000
허용 가능한 대기 시간...

00:05:12.000 --> 00:05:15.000
그리고 히치 타입.

00:05:15.000 --> 00:05:22.000
히치 유형은 프레임이 지연된 단계와 조사를 어디서 시작해야 하는지에 대한 힌트를 얻는 데 유용하다.

00:05:22.000 --> 00:05:31.000
이 예에서, 우리는 선택된 히칭 프레임이 커밋과 GPU 단계에 의해 발생했다는 것을 알 수 있다.

00:05:31.000 --> 00:05:43.000
커밋 단계에서 어떤 코드가 너무 오래 걸리는지 찾고 싶습니다. 고맙게도 애니메이션 히치 템플릿에는 시간 프로파일러가 포함되어 있으므로 이 히치가 발생할 때 어떤 코드가 실행되고 있는지 볼 수 있습니다.

00:05:43.000 --> 00:05:50.000
여기에서, 나는 내가 조사하고 싶은 간격을 선택하고 커밋된 과정을 검색할 수 있다.

00:05:50.000 --> 00:05:54.000
이 과정의 주요 스레드를 선택할 수 있습니다...

00:05:54.000 --> 00:05:58.000
그리고 콜 트리를 표시하세요.

00:05:58.000 --> 00:06:02.000
이제 우리는 어떤 통화가 비쌀 수 있는지 분석할 수 있다.

00:06:02.000 --> 00:06:14.000
우리는 이 호출 트리가 커밋 트랜잭션에서 비롯되었다는 것을 알 수 있으며, QSTEM CollectionViewCell의 updateTags라는 메소드에서 약 10밀리초를 보냈다는 것을 보여줍니다.

00:06:14.000 --> 00:06:17.000
이 앱에 무엇이 있는지 봅시다.

00:06:17.000 --> 00:06:32.000
그것은 일반적인 CollectionView로 구성되어 있으며, 각 셀은 UIImageView를 사용하는 사진 썸네일, UILabel을 사용하는 일부 텍스트 및 사용자 지정 TagLabel 보기를 사용하는 일부 태그를 보여줍니다.

00:06:32.000 --> 00:06:40.000
QSTEM CollectionViewCell 클래스의 구현과 특히 이 메서드가 호출되는 곳을 살펴봅시다.

00:06:40.000 --> 00:06:45.000
여기서 우리는 menuItem에 부동산 관찰자가 있다는 것을 알 수 있다.

00:06:45.000 --> 00:06:54.000
이 속성 관찰자는 두 가지 시나리오에서 updateTags를 호출할 것입니다: 유효한 menuItem이 설정되었거나 nil로 설정되었습니다.

00:06:54.000 --> 00:06:58.000
첫 번째 시나리오에서, 우리는 표시하고 싶은 태그 배열을 구문 분석합니다.

00:06:58.000 --> 00:07:03.000
두 번째 시나리오에서, 우리는 빈 배열을 구문 분석하여 남은 태그를 제거합니다.

00:07:03.000 --> 00:07:08.000
이제 updateTags 메소드 구현을 살펴봅시다.

00:07:08.000 --> 00:07:15.000
예상대로, 우리는 빈 태그 배열의 경우 뷰 계층 구조에서 모든 뷰를 제거합니다.

00:07:15.000 --> 00:07:19.000
그렇지 않으면, 우리는 필요하다면 StackView를 만든다.

00:07:19.000 --> 00:07:24.000
그런 다음 각 태그에 대해 기존 태그 라벨을 만들거나 재사용합니다.

00:07:24.000 --> 00:07:33.000
그 후, 우리는 이 셀의 이전 사용이 새 것보다 더 많은 태그를 가지고 있을 경우를 대비하여 기존의 사용하지 않은 태그 라벨을 제거합니다.

00:07:33.000 --> 00:07:41.000
우리의 호출 범위로 돌아가서 사물이 어떻게 구현되는지에 대한 더 잘 알고 있는 지금 잠재적인 문제를 살펴봅시다.

00:07:41.000 --> 00:07:48.000
QSTEM CollectionViewCell은 셀이 재사용을 위해 큐에서 제거될 때 호출되는 prepareForReuse 메소드를 재정의합니다.

00:07:48.000 --> 00:07:52.000
그리고 이 방법 안에서, 우리는 menuItem을 nil로 설정했다.

00:07:52.000 --> 00:08:04.000
그렇게 하면 재사용 구현 논리를 활용하지 않고 셀 뷰 계층 구조에서 이전의 모든 TagLabels를 제거하는 두 번째 시나리오가 발생합니다.

00:08:04.000 --> 00:08:15.000
이것은 모든 제거된 셀에 대해 이전의 모든 라벨 하위 뷰를 제거하고 모든 라벨을 표시하는 데 필요한 모든 단일 뷰를 재확인한다는 것을 의미합니다.

00:08:15.000 --> 00:08:19.000
이것은 최적이 아니며, 이것은 문제를 일으킬 수 있다.

00:08:19.000 --> 00:08:22.000
이것에 대한 해결책은 꽤 간단하다.

00:08:22.000 --> 00:08:28.000
우리는 menuItem을 지울 필요가 없으며, 구현에서 prepareForReuse 방법을 제거할 수 있습니다.

00:08:28.000 --> 00:08:37.000
이제 새로운 셀 메뉴 항목을 설정할 때, 재사용 가능한 논리를 활용하고 값비싼 뷰 계층 구조를 피할 수 있습니다.

00:08:37.000 --> 00:08:46.000
수정 후 새로운 추적을 기록하면, 첫 번째 추적에 비해 감지된 히치 수를 크게 개선한다는 것을 알 수 있습니다.

00:08:46.000 --> 00:08:53.000
인스트루먼트의 타임 프로파일러는 어떤 코드가 너무 오래 걸리고 문제를 일으키는지 찾는 데 매우 도움이 되었다.

00:08:53.000 --> 00:08:59.000
Time Profiler에 대해 더 알아보려면, "Using Time Profiler in Instruments" 비디오를 보세요.

00:08:59.000 --> 00:09:07.000
Instruments로 응용 프로그램을 프로파일링하는 방법을 배운 후, 커밋 단계에서 히치를 피하기 위한 몇 가지 권장 사항에 대해 논의해 봅시다.

00:09:07.000 --> 00:09:10.000
첫 번째 규칙은 당신의 견해를 가볍게 유지하는 것입니다.

00:09:10.000 --> 00:09:21.000
그렇게 하려면, GPU가 가속화된 CALayer에서 사용할 수 있는 속성에서 가능한 한 많이 활용하고 CPU 사용자 지정 그리기를 피하십시오.

00:09:21.000 --> 00:09:25.000
만약 그것이 정당화될 경우, 그것의 성과를 측정해야 한다.

00:09:25.000 --> 00:09:35.000
시스템이 추가 작업을 수행해야 하므로 drawRect의 빈 구현을 피하십시오. 이는 향후 거래 중에 추가 시간과 메모리 사용량이 필요합니다.

00:09:35.000 --> 00:09:42.000
추가 및 제거와 같은 값비싼 뷰 계층 구조를 피하기 위해 가능한 한 뷰를 재사용하세요.

00:09:42.000 --> 00:09:51.000
뷰 제거와 관련하여, 애니메이션 중에 특정 뷰를 표시하는 것을 중단해야 하는 경우 "숨겨진" 뷰 속성을 활용하십시오.

00:09:51.000 --> 00:09:53.000
이건 훨씬 저렴해.

00:09:53.000 --> 00:09:58.000
두 번째 규칙은 비싸고 중복된 레이아웃을 줄이는 것이다.

00:09:58.000 --> 00:10:02.000
레이아웃을 업데이트해야 할 때만 setNeedsLayout에 의존하세요.

00:10:02.000 --> 00:10:07.000
layoutIfNeeded는 현재 거래 수명을 소비하고 걸쇠를 일으킬 수 있습니다.

00:10:07.000 --> 00:10:11.000
대부분의 경우, 레이아웃을 업데이트하기 위해 다음 실행 루프를 기다릴 수 있습니다.

00:10:11.000 --> 00:10:17.000
이것을 해결하기 위한 복잡성이 증가하는 것을 피하기 위해 최소한의 제약을 사용하세요.

00:10:17.000 --> 00:10:25.000
마지막으로, 견해는 그 자체나 자녀만 무효화해야 하지만, 형제자매나 부모의 견해는 무효화하지 않는다.

00:10:25.000 --> 00:10:29.000
그렇지 않으면, 뷰의 레이아웃은 다시 재귀적으로 무효화될 것이다.

00:10:29.000 --> 00:10:38.000
성능 레이아웃과 이미지 및 그래픽 모범 사례에 대한 자세한 내용을 보려면 아래에 언급된 두 개의 WWDC 회담을 보는 것이 좋습니다.

00:10:38.000 --> 00:10:49.000
이제 커밋 트랜잭션 파이프라인을 이해했으므로 값비싼 커밋을 피할 수 있으며, 인스트루먼트의 새로운 애니메이션 히치 템플릿을 사용하여 히치를 감지하고 조사할 수 있습니다.

00:10:49.000 --> 00:11:03.000
당신은 prepareForReuse가 추가 작업을 초래하지 않도록 하고, 뷰 계층 구조를 얕고 가볍게 유지하며, 비싸고 중복된 레이아웃을 피하는 것과 같은 커밋 히치를 방지하기 위한 몇 가지 전략을 배웠습니다.

00:11:03.000 --> 00:11:13.000
또한, "렌더 단계에서 히치를 신비화하고 제거" 비디오에서 렌더링 루프의 다음 단계에 대해 알아보세요.

00:11:13.000 --> 23:59:59.000
고마워.

