WEBVTT

00:00:00.000 --> 00:00:04.000
데이브 로버츠: 안녕. 저는 애플의 GPU 소프트웨어 팀의 데이브 로버츠입니다.

00:00:04.000 --> 00:00:10.000
새로운 Apple A15 Bionic 칩의 GPU 업데이트 중 일부를 공유하게 되어 정말 기쁩니다.

00:00:10.000 --> 00:00:18.000
나중에, GPU 소프트웨어 팀의 동료인 케이틀린 힌슨이 GPU의 새로운 메탈 기능에 대해 모두 알려줄 것입니다.

00:00:18.000 --> 00:00:25.000
그녀는 또한 멋진 사용 사례를 탐색하면서 메탈 앱에서 이러한 기능을 사용하는 방법을 보여줄 것입니다.

00:00:25.000 --> 00:00:37.000
A15 Bionic은 CPU, GPU, 신경 엔진 및 기타 사용자 경험 향상 기술에 대한 업데이트를 통해 Metal 앱과 게임을 위한 강력한 새로운 플랫폼입니다.

00:00:37.000 --> 00:00:46.000
A15 GPU는 A14 바이오닉과 동일한 타일 기반 지연 렌더러와 통합 메모리 아키텍처를 기반으로 합니다.

00:00:46.000 --> 00:00:54.000
우리가 다양한 분야에서 많은 마이크로 아키텍처 개선을 했지만, 내가 강조해야 할 성능에 대한 몇 가지 중요한 변화가 있다.

00:00:54.000 --> 00:01:04.000
A15의 GPU는 최대 5개의 셰이더 코어를 가지고 있으며, 다섯 번째 코어는 동일한 GPU 코어 주파수에서 25%의 성능 향상을 제공합니다.

00:01:04.000 --> 00:01:12.000
셰이더 코어는 이제 수학이 많은 워크로드에서 GPU 성능을 향상시킬 수 있는 F32 부동 소수점 수학 단위의 두 배이다.

00:01:12.000 --> 00:01:18.000
A15의 GPU는 또한 UI를 더욱 반응적으로 만들고 배터리 수명을 더욱 연장시킨다.

00:01:18.000 --> 00:01:23.000
그리고 코드를 수정하지 않고도 이 모든 훌륭한 개선 사항을 무료로 얻을 수 있습니다.

00:01:23.000 --> 00:01:25.000
하지만 그게 전부는 아니야!

00:01:25.000 --> 00:01:31.000
우리는 당신이 Metal 앱을 더 좋게 만드는 데 사용할 수 있는 몇 가지 새로운 기능을 A15 GPU에 도입했습니다.

00:01:31.000 --> 00:01:38.000
그리고 이러한 모든 새로운 기능은 AppleGPUFamily8로 알려진 새로운 금속 기능 세트에 속합니다.

00:01:38.000 --> 00:01:50.000
나머지 이야기 동안, 케이틀린과 나는 이러한 새로운 기능에 초점을 맞추고 그것들이 무엇인지, 왜 유용한지 설명하고, 그것들을 지원하는 새로운 메탈 API와 셰이딩 언어의 변경 사항을 다룰 것이다.

00:01:50.000 --> 00:01:57.000
먼저, A15의 새로운 그래픽 처리 기능.

00:01:57.000 --> 00:02:03.000
이미지 품질에 최소한의 영향을 미치는 앱의 텍스처 메모리 사용량을 사용하는 손실 압축.

00:02:03.000 --> 00:02:09.000
이 새로운 A15 기능은 무손실 압축과 동일한 텍스처 메모리 대역폭 절약을 제공합니다.

00:02:09.000 --> 00:02:15.000
잠시 후에 더 자세한 내용과 함께 메탈 앱에서 손실 압축을 사용하는 방법을 보여드리겠습니다.

00:02:15.000 --> 00:02:27.000
나중에, 케이틀린은 A15 GPU가 스파스 깊이와 스텐실 텍스처로 렌더링을 포함하여 스파스 텍스처에 대한 기존 지원을 어떻게 확장하는지 보여줄 것입니다.

00:02:27.000 --> 00:02:32.000
케이틀린은 또한 새로운 컴퓨팅 특정 기능을 다룰 것이다: SIMD 그룹 셔플과 채우기.

00:02:32.000 --> 00:02:37.000
A15는 이 새로운 지침을 GPU 핵심 명령 세트에 추가합니다.

00:02:37.000 --> 00:02:47.000
그녀는 이 기능을 설명하고 이미지 처리와 같은 적용 가능한 사용 사례에 대한 컴퓨팅 커널 실행 시간을 줄여 앱 성능을 향상시키는 방법을 보여줄 것입니다.

00:02:47.000 --> 00:02:51.000
나는 손실 압축을 자세히 살펴보는 것으로 시작할 것이다.

00:02:51.000 --> 00:02:57.000
손실 압축을 더 잘 이해하기 위해, 무손실 압축을 다시 방문할 가치가 있다.

00:02:57.000 --> 00:03:06.000
A12 바이오닉은 2018년에 무손실 텍스처 압축을 처음 도입했으며, A14 바이오닉은 2020년에 이 기능을 더욱 개선했다.

00:03:06.000 --> 00:03:14.000
무손실 텍스처 압축은 메모리 대역폭을 절약하여 전력을 절약하므로 앱은 한 번의 배터리 충전으로 더 많은 것을 할 수 있습니다.

00:03:14.000 --> 00:03:19.000
무손실 압축은 항상 질감 디테일을 보존하도록 보장합니다.

00:03:19.000 --> 00:03:24.000
사실, 당신의 앱은 이미 A12 Bionic 이상에서 무손실 압축을 활용할 수 있습니다.

00:03:24.000 --> 00:03:37.000
무손실 압축에 대한 자세한 내용은 기술 토크인 "Discover Metal enhancements for A14 Bionic"과 developer.apple.com의 "Optimizemizing Texture Data" 기사를 확인하세요.

00:03:37.000 --> 00:03:43.000
로시는 A15 바이오닉에서 텍스처 압축을 한 단계 끌어올린다.

00:03:43.000 --> 00:03:51.000
무손실 압축이 제공하는 대역폭 절약 외에도, 손실 압축은 압축되지 않은 텍스처의 메모리 풋프린트의 절반만 사용합니다.

00:03:51.000 --> 00:03:55.000
손실 압축은 가능한 모든 곳에서 질감 품질을 유지합니다.

00:03:55.000 --> 00:04:03.000
그리고 무엇보다도, 이것을 A15의 렌더링 대상에 쉽게 적용하여 메모리 절약을 최대한 활용할 수 있습니다.

00:04:03.000 --> 00:04:11.000
텍스처 설명자의 새로운 압축 유형 속성을 손실로 설정하기만 하면 손실 압축을 활성화할 수 있습니다.

00:04:11.000 --> 00:04:13.000
그렇다면 왜 손실 압축을 사용하나요?

00:04:13.000 --> 00:04:20.000
음, 압축은 무손실 또는 손실 여부를 선택하든 상당한 텍스처 메모리 대역폭을 절약합니다.

00:04:20.000 --> 00:04:26.000
메모리에 기록되기 전에 텍스처 데이터를 압축하여 대역폭을 절약하는 압축 장치입니다.

00:04:26.000 --> 00:04:31.000
무손실 압축을 사용할 때, GPU는 텍스처 디테일을 완벽하게 보존해야 합니다.

00:04:31.000 --> 00:04:39.000
따라서 금속은 어떤 양의 압축도 보장할 수 없으며 압축되지 않은 전체 텍스처 크기를 커버할 수 있는 충분한 메모리를 할당해야 합니다.

00:04:39.000 --> 00:04:46.000
그러나, 손실 압축을 사용할 때, 텍스처는 무손실 메모리 풋프린트의 절반만 사용합니다.

00:04:46.000 --> 00:04:57.000
A15 GPU가 50% 더 작은 메모리 풋프린트에 맞게 텍스처를 무손실로 압축할 수 없다면, 텍스처 영역의 충실도를 감소시킬 것이다.

00:04:57.000 --> 00:05:04.000
손실 압축은 대부분의 픽셀 형식과 텍스처 유형을 지원하며, 렌더링 대상에서 사용할 수 있습니다.

00:05:04.000 --> 00:05:10.000
많은 경우, 앱을 더 이상 수정하지 않고도 텍스처에서 활성화할 수 있습니다.

00:05:10.000 --> 00:05:16.000
품질 절충이 허용되는 모든 곳에서 당신의 앱이 손실 압축을 가능하게 하는 것을 추천합니다.

00:05:16.000 --> 00:05:23.000
그것을 활성화하는 가장 쉬운 장소는 품질 손실을 알아차릴 가능성이 가장 적은 최종 렌더링 목표입니다.

00:05:23.000 --> 00:05:30.000
중간 렌더링 대상에 손실 압축을 사용하는 것을 고려하고 텍스처 해상도를 높이는 것과 같은 다른 것들을 위해 메모리를 절약하는 것을 고려하십시오.

00:05:30.000 --> 00:05:38.000
그리고 후처리 변경 사항을 검토하여 손실 압축의 혜택을 받을 수 있는 렌더링 대상 후보를 찾으십시오.

00:05:38.000 --> 00:05:42.000
여기 몇 가지 사용 사례가 자세히 있습니다.

00:05:42.000 --> 00:05:49.000
최종 렌더링 대상에 대해 손실 압축을 활성화하면 시각적 차이를 살펴보세요.

00:05:49.000 --> 00:05:56.000
이 분할 이미지는 왼쪽의 무손실과 오른쪽의 손실과 비교하며, 그 차이는 꽤 미묘하다.

00:05:56.000 --> 00:06:01.000
그는 무손실 압축과 손실 압축 사이의 픽셀당 차이를 보여주는 이미지이다.

00:06:01.000 --> 00:06:09.000
검은색 픽셀은 차이가 없다; 파란색과 녹색은 작은 차이를 나타낸다; 빨간색은 가장 큰 변화를 나타낸다.

00:06:09.000 --> 00:06:16.000
이 이미지의 빨간색과 노란색 픽셀은 최종 렌더링에서 가장 큰 차이가 있는 몇 개의 고립된 영역을 보여줍니다.

00:06:16.000 --> 00:06:24.000
스쿠터로 지역 중 하나를 확대하면, 왼쪽과 오른쪽 이미지의 차이를 보는 데 어려움을 겪습니다.

00:06:24.000 --> 00:06:29.000
중간 렌더링 대상은 손실 압축에서도 잘 작동합니다.

00:06:29.000 --> 00:06:36.000
여기 무손실 압축과 손실 압축을 비교하는 웅덩이의 반사를 나란히 볼 수 있습니다.

00:06:36.000 --> 00:06:44.000
픽셀당 차이 표현으로 다시 전환하면, 손실 압축 반사는 무손실 버전과 최소한의 차이만 있습니다.

00:06:44.000 --> 00:06:51.000
또한 텍스처의 해상도를 높여 손실 압축으로 저장한 메모리로 더 많은 세부 사항을 추가할 수 있습니다.

00:06:51.000 --> 00:07:01.000
예를 들어, 동일한 양의 메모리를 사용하면서 무손실 버전보다 더 많은 세부 사항을 보여주는 고해상도 반사가 있습니다.

00:07:01.000 --> 00:07:07.000
이 데모의 오른쪽은 장면의 모든 렌더링 가능한 텍스처에 대해 손실 압축을 사용합니다.

00:07:07.000 --> 00:07:17.000
그것이 움직일 때, 장면은 매우 안정적으로 보이며, 왼쪽의 무손실 버전과 비교하면 차이를 감지하기가 매우 어렵습니다.

00:07:17.000 --> 00:07:22.000
금속을 사용하면 앱에서 손실 압축을 쉽게 사용할 수 있습니다.

00:07:22.000 --> 00:07:24.000
여기 방법이 있어.

00:07:24.000 --> 00:07:32.000
평소와 같이 텍스처 설명자를 초기화하는 것으로 시작한 다음, 압축 유형 속성을 손실로 설정하십시오.

00:07:32.000 --> 00:07:34.000
다음으로, 저장 모드를 비공개로 설정하세요.

00:07:34.000 --> 00:07:36.000
마지막으로, 질감을 만드세요.

00:07:36.000 --> 00:07:42.000
그리고 당신의 앱은 이제 손실 압축과 그것이 제공하는 비용 절감을 최대한 활용할 수 있습니다.

00:07:42.000 --> 00:07:48.000
몇 가지 예외를 제외하고 대부분의 구성에 대해 손실 압축을 위한 텍스처를 만들 수 있습니다.

00:07:48.000 --> 00:07:55.000
예를 들어, 2D, 3D, 배열 및 큐브를 포함한 가장 일반적인 텍스처 유형에 대해 손실 압축을 사용할 수 있습니다.

00:07:55.000 --> 00:07:59.000
하지만 그 기능은 덜 흔한 유형 중 일부를 지원하지 않는다.

00:07:59.000 --> 00:08:07.000
마찬가지로, 손실 압축은 가장 일반적인 픽셀 형식을 지원하지만, 포장된 색상 채널이 있는 형식은 지원하지 않습니다.

00:08:07.000 --> 00:08:16.000
손실 압축은 렌더링 대상, blit 작업 및 샘플 및 읽기 작업으로 액세스할 때 텍스처를 지원합니다.

00:08:16.000 --> 00:08:22.000
그러나, 셰이더 쓰기 작업으로 손실 텍스처를 채울 수 없다는 점에 유의하십시오.

00:08:22.000 --> 00:08:25.000
손실 압축은 개인 저장소의 텍스처만 지원합니다.

00:08:25.000 --> 00:08:30.000
공유 또는 관리되는 스토리지 노드를 사용할 수 없습니다.

00:08:30.000 --> 00:08:37.000
그리고 마지막으로, 손실 텍스처는 MSAA, sRGB 및 mipmapping과 같은 다른 일반적인 기능과 함께 작동합니다.

00:08:37.000 --> 00:08:45.000
손실 압축 지원에 대한 자세한 내용은 developer.apple.com에서 금속 기능 세트 테이블을 확인하세요.

00:08:45.000 --> 00:08:54.000
그래서 요약하자면, 손실 압축은 무손실 압축과 동일한 대역폭을 절약하는 동시에 텍스처 메모리의 50%를 절약합니다.

00:08:54.000 --> 00:09:01.000
사용 사례와 앱에서 손실 압축을 얼마나 사용하기로 선택했는지에 따라 상당한 양의 메모리를 저장할 수 있습니다.

00:09:01.000 --> 00:09:09.000
손실 압축은 텍스처 디테일을 보존하는 것을 목표로 하지만 압축된 텍스처 데이터가 맞지 않는 영역의 품질을 약간 낮추는 것을 목표로 한다.

00:09:09.000 --> 00:09:22.000
그리고 마지막으로, 손실 압축은 일반적인 텍스처 유형, 일반적인 픽셀 형식 및 셰이더 쓰기 이외의 모든 GPU 액세스 모드를 지원하므로 손실 압축을 쉽게 사용할 수 있습니다.

00:09:22.000 --> 00:09:27.000
들어줘서 고마워, 그리고 이제 케이틀린에게 넘겨줄게.

00:09:27.000 --> 00:09:28.000
케이틀린 힌슨: 고마워, 데이브.

00:09:28.000 --> 00:09:33.000
A15 바이오닉의 새로운 스파스 텍스처 확장을 소개하게 되어 기쁩니다.

00:09:33.000 --> 00:09:40.000
스파스 텍스처는 메탈에서 메모리 예산을 관리하면서 고해상도 텍스처를 만들 수 있는 좋은 방법입니다.

00:09:40.000 --> 00:09:48.000
A13 Bionic은 스파스 텍스처 지원을 처음 도입하여 GPU 타임라인에서 텍스처 타일을 매핑하고 매핑 해제할 수 있습니다.

00:09:48.000 --> 00:09:56.000
앱에서 스파스 텍스처를 사용하는 방법에 대한 자세한 내용은 2019년 가을과 2020년 가을의 회담을 참조하십시오.

00:09:56.000 --> 00:10:01.000
A15 바이오닉은 깊이와 스텐실 부착물을 포함하여 희소한 지원을 확장합니다.

00:10:01.000 --> 00:10:07.000
희박한 질감의 기본 원리는 "사용하지 않을 것을 할당하지 마세요"입니다.

00:10:07.000 --> 00:10:12.000
예를 들어, 이 앱은 UI 요소 뒤에 타일을 매핑할 필요가 없습니다.

00:10:12.000 --> 00:10:20.000
희박한 깊이와 스텐실 텍스처로, 이 앱은 항상 이 모호한 타일을 매핑되지 않은 상태로 둘 수 있습니다.

00:10:20.000 --> 00:10:24.000
희박한 깊이 첨부 파일로 그림자 지도를 최적화할 수 있습니다.

00:10:24.000 --> 00:10:30.000
섀도 매핑에 익숙하지 않다면, 이 기술을 사용하는 메탈의 지연 조명 샘플을 확인하세요.

00:10:30.000 --> 00:10:37.000
그림자 패스는 빛의 관점에서 그림자 지도를 렌더링하고, 조명 패스는 그것을 다시 읽는다.

00:10:37.000 --> 00:10:41.000
그림자 지도에서 샘플링된 텍셀은 항상 투영된 frustum 안에 있다.

00:10:41.000 --> 00:10:45.000
이 시나리오는 희박한 질감을 위한 완벽한 후보이다.

00:10:45.000 --> 00:10:52.000
조명 패스가 이 타일을 샘플링하지 않기 때문에 그림자 텍스처의 많은 부분을 매핑할 필요가 없습니다.

00:10:52.000 --> 00:10:56.000
여기 그림자 매핑과 렌더링된 그림자 지도를 사용하는 장면이 있습니다.

00:10:56.000 --> 00:11:05.000
이 앱은 타일에서 다시 쓰거나 읽을 필요가 없기 때문에 뷰 프루스텀 외부의 타일에서 메모리를 복구할 수 있습니다.

00:11:05.000 --> 00:11:12.000
캐스케이드 섀도우 매핑은 여러 개의 개별 섀도우 맵을 사용하여 장면을 더 효율적으로 커버하는 섀도우를 위한 고급 기술이다.

00:11:12.000 --> 00:11:20.000
그것은 카메라 근처에 고해상도 섀도우 맵과 카메라에서 더 멀리 떨어진 저해상도 맵을 할당합니다.

00:11:20.000 --> 00:11:24.000
예를 들어, 이 장면은 세 개의 겹치는 그림자 지도를 사용한다.

00:11:24.000 --> 00:11:32.000
각 그림자 지도는 동일한 텍스처 해상도를 가지고 있으며 카메라에서 멀어질수록 점점 더 큰 영역으로 매핑됩니다.

00:11:32.000 --> 00:11:38.000
그림자 지도에서 녹색으로 강조 표시된 영역은 조명이 샘플을 통과하는 텍셀을 나타낸다.

00:11:38.000 --> 00:11:48.000
조명은 열 지도로 표시된 이 타일에서 균일하지 않은 샘플을 통과하며, 파란색 타일은 언더샘플링되고 빨간색 오버샘플링됩니다.

00:11:48.000 --> 00:11:57.000
희박한 타일 섀도우 맵을 사용하여 이러한 텍스처를 샘플링 속도에 따라 해상도를 조정 가능한 단일 표면으로 대체할 수 있습니다.

00:11:57.000 --> 00:12:03.000
스파스 타일 섀도우 맵 또는 STSM을 사용하면 단일 스파스 깊이 표면을 만들 수 있습니다.

00:12:03.000 --> 00:12:09.000
고정 해상도 텍스처를 사용하는 대신, 표면은 희박한 렙맵 체인을 가로질러 타일을 매핑했다.

00:12:09.000 --> 00:12:14.000
이 기술은 원하는 샘플링 속도와 일치하는 데 필요한 타일만 매핑합니다.

00:12:14.000 --> 00:12:21.000
다음은 상대적인 mip 레벨의 각 타일의 물리적 해상도에 대한 삽화입니다.

00:12:21.000 --> 00:12:29.000
다른 mips에 걸쳐 타일을 매핑하여 장면에서 그림자 지도의 해상도를 자유롭고 효율적으로 조정할 수 있습니다.

00:12:29.000 --> 00:12:32.000
여기 STSM 기술의 주요 단계가 있습니다.

00:12:32.000 --> 00:12:37.000
먼저, 샘플링 속도를 기반으로 밀도 지도를 생성하세요.

00:12:37.000 --> 00:12:42.000
그런 다음 밀도 지도에 따라 표면과 지도 타일을 구성하세요.

00:12:42.000 --> 00:12:46.000
그런 다음 적응형 표면으로 렌더링하고 샘플링하세요.

00:12:46.000 --> 00:12:53.000
밀도 맵을 생성하기 위해, 지오메트리 패스는 다른 패스에 대한 밀도 맵 버퍼를 채웁니다.

00:12:53.000 --> 00:12:57.000
첫 번째 단계는 섀도우 맵에서 샘플링 속도를 얻는 것이다.

00:12:57.000 --> 00:13:04.000
예상 샘플 밀도는 렌더링된 기하학의 그림자 공간 도함수를 추적하여 계산됩니다.

00:13:04.000 --> 00:13:13.000
프래그먼트 셰이더는 원자를 사용하여 2D 그리드에 파생물을 저장하여 shadowUV 공간에서 샘플링 속도를 수집합니다.

00:13:13.000 --> 00:13:21.000
밀도 맵이 있으면, 그것을 사용하여 희소 깊이 텍스처를 위한 타일을 배치하고 목차 버퍼를 생성하십시오.

00:13:21.000 --> 00:13:25.000
이 목차 버퍼는 당신의 조명 패스에 의해 사용될 것입니다.

00:13:25.000 --> 00:13:35.000
먼저, 하단 mip부터 시작하여 표면을 반복적으로 분할하고 각 mip 레벨의 매핑을 예약하여 깊이 텍스처의 타일을 매핑하십시오.

00:13:35.000 --> 00:13:41.000
어떤 타일을 매핑할지 알아내려면, 밀도 맵에서 현재 mip의 샘플링 속도를 확인하는 것으로 시작하세요.

00:13:41.000 --> 00:13:49.000
이 예에서, 밀도 맵은 현재 mip이 부적절하다는 것을 나타내지만, 다음 mip 레벨은 잘 맞습니다.

00:13:49.000 --> 00:13:55.000
이 경우, 다음 mip을 매핑하고 현재 mip의 매핑을 해제하여 전체 타일을 홍보합니다.

00:13:55.000 --> 00:13:58.000
여기 또 다른, 더 복잡한 시나리오가 있습니다.

00:13:58.000 --> 00:14:03.000
밀도 지도는 현재 mip이 적어도 하나의 사분면에 만족스럽다는 것을 나타낸다.

00:14:03.000 --> 00:14:12.000
다음 mip의 경우, 샘플 속도와 밀도 맵은 두 사분면의 목표를 충족하고, 나머지 두 개는 목표 속도 아래에 있다.

00:14:12.000 --> 00:14:18.000
이 경우, 현재 mip의 타일을 매핑하고 다음 타일의 절반을 매핑하세요.

00:14:18.000 --> 00:14:28.000
다음으로 컴퓨팅 셰이더는 목차 또는 TOC 버퍼에 저장된 UV와 mip 레벨 사이를 변환하는 2D 테이블을 작성합니다.

00:14:28.000 --> 00:14:37.000
STSM에서 텍셀을 샘플링하기 전에, TOC 버퍼는 mip을 얻기 위해 테이블을 인덱싱하여 조명 패스에 의해 읽힌다.

00:14:37.000 --> 00:14:43.000
그런 다음 섀도 맵을 샘플링할 때 mip은 명시적인 LOD 매개 변수로 사용됩니다.

00:14:43.000 --> 00:14:46.000
다음 단계는 희박한 그림자 지도를 렌더링하는 것이다.

00:14:46.000 --> 00:14:55.000
먼저, TOC 버퍼를 사용하여 그림자를 컬링한 다음, 간접 그리기 명령을 인코딩하여 희박한 깊이 텍스처로 렌더링하세요.

00:14:55.000 --> 00:15:00.000
각 mip 맵을 간접 명령 버퍼로 개별적으로 채워서 표면을 렌더링하세요.

00:15:00.000 --> 00:15:11.000
ICB는 컴퓨팅 패스가 상주 영역에 대해 각 그림자 기하학 메쉬를 병렬로 선별하고 정렬할 수 있기 때문에 이 작업에 완벽하게 적합합니다.

00:15:11.000 --> 00:15:19.000
컴퓨팅 셰이더는 타일의 경계 볼륨에 대해 메쉬를 테스트하여 명령을 개별 ICB로 인코딩합니다.

00:15:19.000 --> 00:15:34.000
섀도우 맵을 가로질러 뻗어 있는 큰 물체의 경우, 셰이더는 각 mip의 관련 타일에 대해 물체를 테스트합니다. 그리고 적어도 하나의 타일이 겹치면 mip의 ICB에 그리기 명령을 인코딩합니다.

00:15:34.000 --> 00:15:42.000
Mip에 겹치는 타일이 없다면, 그 mip의 ICB에 개체에 대한 그리기 명령을 방출하지 마세요.

00:15:42.000 --> 00:15:52.000
각 개체에 대한 최적화된 그리기 명령 세트는 병렬 컴퓨팅 스레드에서 모든 교차 테스트를 실행하여 섀도우 컬 컴퓨팅 패스로 인코딩됩니다.

00:15:52.000 --> 00:15:59.000
빨간색 메쉬가 카메라에 가장 가까웠기 때문에, 그림자 지도의 11개의 타일에 가장 큰 영향을 미쳤다.

00:15:59.000 --> 00:16:06.000
세 개의 타일에서 가장 작은 영향을 미친 카메라에서 가장 먼 주황색 메쉬와 비교하세요.

00:16:06.000 --> 00:16:13.000
간접 그리기 명령이 완료되면, STSM은 조명 패스에서 샘플링할 준비가 되었습니다.

00:16:13.000 --> 00:16:19.000
이 표는 STSM을 그림자 매핑 및 캐스케이드 그림자 매핑과 비교합니다.

00:16:19.000 --> 00:16:27.000
STSM 샘플 속도와 효과적인 품질은 단일 섀도우 맵과 거의 동일하지만 메모리를 훨씬 적게 사용합니다.

00:16:27.000 --> 00:16:33.000
사실, 그것은 동일한 해상도에 대해 메모리 풋프린트의 퍼센트 미만을 사용한다.

00:16:33.000 --> 00:16:42.000
이 딥 다이빙이 희소 타일 섀도우 맵으로 메탈 앱에서 효율적이고 고품질의 섀도우를 만드는 방법에 대한 아이디어를 제공하기를 바랍니다.

00:16:42.000 --> 00:16:50.000
마지막으로, A15의 메탈 컴퓨팅에 새로 추가된 것을 소개하게 되어 기쁩니다: SIMD 셔플과 채우기.

00:16:50.000 --> 00:16:57.000
현대 이미지 처리에서 컨벌루션 커널은 가장자리 감지, 흐림 및 선명도와 같은 필터에 적용됩니다.

00:16:57.000 --> 00:17:02.000
여기 우리의 현대적인 렌더링 데모의 이미지에 적용된 컨벌루션이 있습니다.

00:17:02.000 --> 00:17:11.000
이와 같은 워크로드는 일반적으로 텍스처 샘플링이나 스레드 그룹 메모리의 읽기에 의해 제한되며, GPU의 수학 단위가 충분히 활용되지 않습니다.

00:17:11.000 --> 00:17:19.000
애플 실리콘은 이러한 워크로드를 최적화하는 데 도움이 되도록 메탈 컴퓨팅 셰이더에 사용할 수 있는 풍부한 SIMD 지침 세트를 제공합니다.

00:17:19.000 --> 00:17:28.000
SIMD 그룹의 스레드가 락스텝에서 동시에 실행됨에 따라, SIMD 그룹 기능은 이 락스텝 실행을 악용하여 스레드 간에 데이터를 공유합니다.

00:17:28.000 --> 00:17:37.000
기존 SIMD 기능에 대한 자세한 내용은 소개된 A13 Bionic 및 A14 Bionic에 대한 회담을 참조하십시오.

00:17:37.000 --> 00:17:41.000
이제 사용 가능한 새로운 SIMD 지침에 대해 논의해 봅시다.

00:17:41.000 --> 00:17:47.000
A15 Bionic의 새로운 것은 SIMD와 쿼드 셔플 및 채우기를 지원합니다.

00:17:47.000 --> 00:17:55.000
이 지침은 이전에 표시된 에지 감지 컨벌루션과 같은 슬라이딩 윈도우 이미지 작업을 개선하도록 설계되었습니다.

00:17:55.000 --> 00:18:03.000
이러한 기능은 메모리를 사용하지 않고 주어진 SIMD 그룹의 이웃 스레드 간에 데이터를 공유하여 컴퓨팅 워크로드를 최적화합니다.

00:18:03.000 --> 00:18:09.000
먼저 A13에서 처음 지원되는 쿼드 셔플 다운의 동작을 살펴봅시다.

00:18:09.000 --> 00:18:19.000
데이터 버퍼에는 쿼드 스레드의 레지스터에 로드되는 내용 A, B, C 및 D가 있습니다: 0, 1, 2, 3.

00:18:19.000 --> 00:18:29.000
1의 시프트에 셔플을 적용할 때, 스레드 0, 1, 2의 레지스터 데이터는 스레드 1, 2, 3에서 데이터를 얻는다.

00:18:29.000 --> 00:18:37.000
계산된 쿼드 레인 ID는 랩되지 않으므로, 결과의 스레드 3은 시프트되지 않은 값 D를 가지고 있다.

00:18:37.000 --> 00:18:45.000
대신, 쿼드 셔플과 채우기 명령이 사용되는 경우, 결과에서 스레드 3을 업데이트하기 위해 채우기 버퍼가 제공됩니다.

00:18:45.000 --> 00:18:51.000
이제 스레드 0의 채우기 데이터는 스레드 3의 출력 데이터로 섞입니다.

00:18:51.000 --> 00:19:05.000
마찬가지로, 쿼드 셔플업과 2의 시프트로 채우기의 경우, A와 B가 스레드 2와 3으로 셔플되는 것을 볼 수 있으며, 채우기 버퍼의 데이터는 출력의 하단 차선으로 셔플됩니다.

00:19:05.000 --> 00:19:09.000
애플 실리콘에서, SIMD 그룹은 32개의 스레드로 구성되어 있다.

00:19:09.000 --> 00:19:18.000
그리고 동일한 셔플 및 채우기 동작은 하단 델타 레인이 채우기 데이터의 상단 레인으로 채워진 SIMD 레인에 적용될 수 있습니다.

00:19:18.000 --> 00:19:25.000
새로운 SIMD와 쿼드 셔플 및 채우기 명령에는 선택적 모듈로 인수가 있습니다.

00:19:25.000 --> 00:19:28.000
이것은 사용자가 지정한 벡터 너비를 허용합니다.

00:19:28.000 --> 00:19:33.000
8개의 모듈의 경우, SIMD 그룹은 효과적으로 네 개의 벡터로 나뉜다.

00:19:33.000 --> 00:19:41.000
데이터 버퍼 값은 먼저 두 개의 인덱스를 섞고, 채우기 데이터는 8개의 스레드의 각 세트로 섞인다.

00:19:41.000 --> 00:19:53.000
최신 렌더링 이미지의 가장자리 감지에 사용되는 커널을 SIMD 셔플과 채우기를 사용하여 최적화할 수 있는 예에서 이러한 새로운 지침을 사용합시다.

00:19:53.000 --> 00:20:00.000
최종 결과를 생성하기 위해, 5 x 5 컨벌루션 커널이 입력 이미지에 적용됩니다.

00:20:00.000 --> 00:20:09.000
출력 이미지는 SIMD 그룹 세트로 나뉘며, 각 SIMD 그룹은 4x8 청크이며, 각 스레드는 단일 출력에 기록됩니다.

00:20:09.000 --> 00:20:13.000
단일 SIMD 그룹의 출력을 생성하는 데 집중합시다.

00:20:13.000 --> 00:20:19.000
5 x 5 컨벌루션의 경우, 각 스레드는 입력에서 5 x 5 픽셀을 읽어야 합니다.

00:20:19.000 --> 00:20:25.000
각 4-by-8 SIMD 그룹에 대해, 컴퓨팅 셰이더에서 8-by-12 영역을 샘플링해야 합니다.

00:20:25.000 --> 00:20:31.000
이 컨벌루션의 순진한 구현은 각 출력 스레드에 대해 25개의 샘플이 필요할 것이다.

00:20:31.000 --> 00:20:35.000
이것은 우리 SIMD 그룹 전체에서 큰 중복을 초래한다.

00:20:35.000 --> 00:20:45.000
이것은 셔플 및 채우기 지침에 의해 최적화될 수 있으며, SIMD 그룹 내에서 중복 샘플을 제거하고 레지스터 셔플을 통해 데이터를 공유할 수 있습니다.

00:20:45.000 --> 00:20:49.000
왜 우리가 이 장소들에서 읽어야 하는지 봅시다.

00:20:49.000 --> 00:21:03.000
첫 번째 A는 SIMD 그룹의 각 스레드가 단일 픽셀을 샘플링하는 4-x-8 창으로 로드됩니다. 그런 다음 오른쪽 상단 창의 경우 B, 왼쪽 하단의 경우 C, 마지막으로 오른쪽 하단의 경우 D입니다.

00:21:03.000 --> 00:21:10.000
빨간색 윤곽선 직사각형은 출력 이미지의 SIMD 그룹의 대상 영역을 나타냅니다.

00:21:10.000 --> 00:21:19.000
스레드당 네 개의 샘플을 통해, 8-x-12 입력 영역은 겹치는 샘플 없이 SIMD 그룹에 로드되었습니다.

00:21:19.000 --> 00:21:26.000
스레드 0의 5-by-5 영역에 다시 초점을 맞추면, 이 샘플들은 5-by-5 이웃으로 표현될 수 있다.

00:21:26.000 --> 00:21:36.000
쿼드 셔플과 채우기는 이웃의 첫 번째 행에 액세스하는 데 사용할 수 있으며, 먼저 A의 데이터를 셔플하고 B의 데이터로 채울 수 있습니다.

00:21:36.000 --> 00:21:42.000
그런 다음 이전 행의 32개의 넓은 벡터가 다음 행을 위해 섞인다.

00:21:42.000 --> 00:21:51.000
데이터가 전체 행 아래로 섞이기 때문에, 32 와이드 벡터의 상단 레인에서 C와 D의 샘플을 섞기 위해 채우기 벡터가 필요합니다.

00:21:51.000 --> 00:22:00.000
동일한 접근 방식을 사용하여 SIMD와 쿼드 셔플 다운을 사용하여 5x5 영역에서 나머지 샘플을 얻을 수 있습니다.

00:22:00.000 --> 00:22:08.000
전체 이웃이 섞이면, 이 샘플들은 가장자리 감지 알고리즘에 대한 입력으로 사용된다.

00:22:08.000 --> 00:22:24.000
순진한 구현이 새로운 SIMD 및 쿼드 셔플 및 채우기 지침과 함께 각 스레드의 전체 이웃을 샘플링하는 동안, 각 SIMD 그룹의 샘플 수는 84% 감소하여 이웃 스레드에서 겹치는 샘플을 제거합니다.

00:22:24.000 --> 00:22:36.000
새로운 SIMD 작업을 사용하여, 많은 일반적인 이미지 처리 및 기계 학습 알고리즘은 SIMD 그룹 전체에서 공유 데이터를 최적화하기 위해 동일한 접근 방식을 적용할 수 있습니다.

00:22:36.000 --> 00:22:39.000
그리고 그것은 SIMD 셔플과 채우기를 위한 것이다.

00:22:39.000 --> 00:22:42.000
우리가 배운 것을 요약해 봅시다.

00:22:42.000 --> 00:22:52.000
손실 압축은 텍스처의 품질을 유지하면서 메모리 풋프린트와 대역폭을 절약하는 사용하기 쉬운 기능입니다.

00:22:52.000 --> 00:22:58.000
희박한 깊이와 스텐실 텍스처는 효율적이고 고품질의 섀도우 맵을 만드는 데 도움이 됩니다.

00:22:58.000 --> 00:23:10.000
새로운 컴퓨팅 지침 SIMD 셔플과 채우기는 중첩을 줄이고 기계 학습 및 이미지 처리 애플리케이션을 위한 슬라이딩 윈도우 이미지 작업을 개선합니다.

00:23:10.000 --> 00:23:22.000
그리고 마지막으로, 모든 메탈 앱은 A15 바이오닉 GPU의 전반적인 아키텍처 개선으로 성능, 반응성 및 전력 절감을 추가로 향상시킵니다.

00:23:22.000 --> 23:59:59.000
봐줘서 고마워.

