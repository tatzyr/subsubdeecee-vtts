WEBVTT

00:00:00.000 --> 00:00:05.000
안녕하세요, 저는 Cloud FileProvider 팀의 Johannes Fortmann입니다.

00:00:05.000 --> 00:00:15.000
오늘 우리는 iOS 16에 도입된 새로운 FileProvider API를 사용하여 데스크톱 클래스 동기화를 iOS로 가져오는 방법에 대해 이야기할 것입니다.

00:00:15.000 --> 00:00:21.000
소개 후, 우리는 파일 제공자의 목표를 간략하게 요약할 것이다.

00:00:21.000 --> 00:00:29.000
우리는 당신의 앱을 설계하기 위한 최적의 접근 방식과 iOS에서 특히 중요한 모범 사례에 대해 논의할 것입니다.

00:00:29.000 --> 00:00:34.000
마지막으로, iOS에서 실행되는 공급자의 빠른 데모를 보여드리겠습니다.

00:00:34.000 --> 00:00:39.000
Big Sur는 파일을 Mac에 동기화하기 위한 선언적 API를 도입했습니다.

00:00:39.000 --> 00:00:43.000
이 API는 많은 클라우드 공급 업체에 의해 큰 성공을 거두었다.

00:00:43.000 --> 00:00:51.000
우리 팀은 API를 개선하기 위해 꾸준히 노력해 왔으며, iOS 16에서도 사용할 수 있게 되어 기쁩니다.

00:00:51.000 --> 00:00:58.000
이 API를 사용하면 iOS 앱이 "데스크탑 클래스 동기화"라고 부르는 것을 제공할 수 있습니다.

00:00:58.000 --> 00:01:01.000
그게 무슨 뜻이야?

00:01:01.000 --> 00:01:09.000
iOS의 앱이 더 강력해짐에 따라, 파일 시스템의 공유 위치에 액세스할 수 있는 것이 중요해진다.

00:01:09.000 --> 00:01:16.000
사람들은 이러한 강력한 앱이 모든 유형의 파일 시스템 객체에 접근할 수 있기를 원한다.

00:01:16.000 --> 00:01:21.000
그들이 선택하면, 그들의 앱은 폴더에 액세스하고 새 파일을 만들 수 있어야 한다.

00:01:21.000 --> 00:01:26.000
우리는 일관성을 보장하면서 이 모든 일이 일어나기를 바란다.

00:01:26.000 --> 00:01:28.000
일관성은 무엇을 의미하나요?

00:01:28.000 --> 00:01:34.000
iOS에서 백그라운드 런타임은 역사적으로 전력 문제로 인해 제한되어 왔다.

00:01:34.000 --> 00:01:39.000
동시에, 변경 사항은 백그라운드에서 업로드될 것으로 예상된다.

00:01:39.000 --> 00:01:45.000
이 문제를 해결하기 위해 최신 FileProvider API가 도입되었다.

00:01:45.000 --> 00:01:59.000
기본 수준에서, 항목을 열거하고, 콘텐츠를 가져오고 업로드하고, 원격으로 변경되는 경우 항목 목록을 업데이트하는 앱 확장 프로그램을 구현합니다.

00:01:59.000 --> 00:02:07.000
시스템은 당신이 제공하는 정보를 노출하고 일관성을 유지할 책임이 있습니다.

00:02:07.000 --> 00:02:14.000
시스템의 중요한 임무는 오류를 추적하고 필요한 경우 다시 시도하는 것이다.

00:02:14.000 --> 00:02:19.000
내용 가져오기와 같은 일부 작업의 경우, 재시도 자연스럽게 발생합니다.

00:02:19.000 --> 00:02:26.000
사용자는 다운로드를 적극적으로 기다리고 있으며 아마도 진행률 표시줄을 면밀히 모니터링하고 있을 것이다.

00:02:26.000 --> 00:02:29.000
반면에 업로드는 일정이 필요하다.

00:02:29.000 --> 00:02:36.000
디스크에 있는 항목의 상태를 추적함으로써, 시스템은 업데이트된 콘텐츠가 업로드되도록 합니다.

00:02:36.000 --> 00:02:41.000
필요한 경우 업로드를 다시 시도하기 위해 진행 상황과 오류를 추적합니다.

00:02:41.000 --> 00:02:45.000
또 다른 복잡한 주제는 업로드 중 일관성이다.

00:02:45.000 --> 00:02:57.000
이 시스템은 파일 내용의 클론을 관리하여 업로드하는 동안 파일에 대한 후속 액세스가 성공하고 올바른 데이터를 보여줄 수 있도록 합니다.

00:02:57.000 --> 00:03:10.000
이러한 작업 중에, 시스템은 또한 여러 앱이 액세스하는 경우에도 로컬 버전이 일관성을 유지하도록 보장하며, 여기에는 원격 서버의 동기화 다운이 포함됩니다.

00:03:10.000 --> 00:03:18.000
이것은 APFS 기능과 파일 조정을 사용하여 투명하게 구현됩니다.

00:03:18.000 --> 00:03:24.000
저장 제한은 모바일 장치의 중요한 제약이다.

00:03:24.000 --> 00:03:31.000
이 시스템은 APFS 기능을 사용하여 로컬 파일의 변경 상태를 원자적으로 추적합니다.

00:03:31.000 --> 00:03:40.000
이를 통해 디스크 사용량과 가장 최근에 사용된 상태에 따라 로컬 변경 사항이 없는 파일을 투명하게 퇴거할 수 있습니다.

00:03:40.000 --> 00:03:47.000
완전히 업로드된 파일은 설정의 저장소 관리 창에서 앱에 포함되지 않습니다.

00:03:47.000 --> 00:03:53.000
당신은 지금까지 우리가 시스템과 확장에 대해 이야기했다는 것을 눈치챘을 것입니다.

00:03:53.000 --> 00:03:56.000
당신의 앱이 어디에서 오는지에 대해 이야기해 봅시다.

00:03:56.000 --> 00:04:00.000
나는 당신이 우려를 엄격하게 분리하는 것을 추천한다.

00:04:00.000 --> 00:04:07.000
그 시스템은 디스크의 구조를 관리하고 작업을 계획할 책임이 있다.

00:04:07.000 --> 00:04:12.000
당신의 확장 프로그램은 위아래로 동기화하기 위해 이러한 작업을 수행할 책임이 있습니다.

00:04:12.000 --> 00:04:18.000
시스템은 파일 계층 구조에 대한 모든 상태와 동기화가 필요한 부분을 추적합니다.

00:04:18.000 --> 00:04:22.000
그것은 당신의 확장이 매우 가벼울 수 있다는 것을 의미합니다.

00:04:22.000 --> 00:04:26.000
그것은 어떤 항목별 상태도 전혀 추적할 필요가 없다.

00:04:26.000 --> 00:04:30.000
당신의 애플리케이션은 동기화에 대해 책임을 지지 않습니다.

00:04:30.000 --> 00:04:35.000
이상적으로는, 서버와 전혀 이야기할 필요가 없다.

00:04:35.000 --> 00:04:41.000
대신, 그것은 두 가지 메커니즘을 통해 당신의 확장과 상호 작용합니다.

00:04:41.000 --> 00:04:47.000
그것은 시스템의 다른 응용 프로그램과 같은 방식으로 확장과 간접적으로 상호 작용할 수 있다.

00:04:47.000 --> 00:04:53.000
루트를 포함한 모든 관리 항목의 파일 URL을 가져오는 API가 있습니다.

00:04:53.000 --> 00:05:00.000
그런 다음 이러한 위치는 일반 파일 시스템 API를 사용하여 액세스할 수 있습니다.

00:05:00.000 --> 00:05:06.000
또는, 앱은 확장 프로그램에 대한 직접 XPC 서비스 연결을 요청할 수 있습니다.

00:05:06.000 --> 00:05:17.000
이것은 파일 공유 또는 충돌 해결과 같은 파일 시스템 조작으로 표현할 수 없는 작업을 처리하는 데 특히 유용합니다.

00:05:17.000 --> 00:05:26.000
이 두 메커니즘 모두 FileProvider UI 확장 프로그램에서 파일 앱에서 추가 통합 지점을 제공하기 위해 사용할 수 있습니다.

00:05:26.000 --> 00:05:32.000
저는 무국적 제공자들에게 특히 중요한 세 가지 점에 대해 언급하고 싶습니다.

00:05:32.000 --> 00:05:35.000
먼저, 업로드에 대해 이야기해 봅시다.

00:05:35.000 --> 00:05:42.000
앞서 언급했듯이, 시스템은 업로드를 추적하고 업로드를 수행할 수 있는 연장 시간을 부여할 것입니다.

00:05:42.000 --> 00:05:50.000
이것의 중요한 결과는 진행 상황을 보고하여 업로드가 실제로 진행되고 있다는 것을 시스템에 인식해야 한다는 것입니다.

00:05:50.000 --> 00:05:54.000
업로드 작업이 진행되지 않으면, 취소됩니다.

00:05:54.000 --> 00:06:03.000
이 시스템은 업로드를 깨끗하게 마무리할 수 있는 유예 기간을 제공하지만, 취소가 너무 오래 걸리면 연장이 종료됩니다.

00:06:03.000 --> 00:06:05.000
코드를 확인해 봅시다.

00:06:05.000 --> 00:06:12.000
취소 핸들러를 구현하려면, 작업별 방법의 진행률 반환에 설정하기만 하면 됩니다.

00:06:12.000 --> 00:06:16.000
업로드의 경우, 그것은 modifyItem입니다.

00:06:16.000 --> 00:06:22.000
핸들러에서, 당신은 당신이 수행하고 있던 실제 업로드 작업을 취소합니다.

00:06:22.000 --> 00:06:27.000
물론, 취소 오류가 발생했다는 신호를 보내기 위해 완료 핸들러를 호출해야 합니다.

00:06:27.000 --> 00:06:37.000
여기에 있는 코드 예제는 이를 편리하게 하기 위해 비동기 작업 취소를 사용하지만, 완료 핸들러를 수동으로 호출할 수도 있습니다.

00:06:37.000 --> 00:06:40.000
다음으로, 동기화 경로에 대해 이야기해 봅시다.

00:06:40.000 --> 00:06:47.000
사용자가 파일과 상호 작용할 때, 메인 앱은 서버에서 변경 사항을 받기 위해 실행되지 않습니다.

00:06:47.000 --> 00:06:52.000
원격 변경 사항에 대해 시스템에 알리려면, 푸시 알림을 구현해야 합니다.

00:06:52.000 --> 00:06:57.000
PushKit은 파일 제공자를 위한 특정 푸시 유형을 노출합니다.

00:06:57.000 --> 00:07:01.000
확장 프로그램에서 바로 이 푸시를 등록할 수 있습니다.

00:07:01.000 --> 00:07:05.000
서버에서, 당신은 잘 정의된 페이로드로 푸시를 보냅니다.

00:07:05.000 --> 00:07:09.000
시스템은 푸시를 받고 적절한 경우 현재 상태를 새로 고칠 것이다.

00:07:09.000 --> 00:07:22.000
다른 유형의 작업과 마찬가지로, 시스템은 배터리 상태 또는 사용자가 현재 파일을 보고 있는지 여부와 같은 상황에 따라 실제 새로 고침을 지연시킬 수 있습니다.

00:07:22.000 --> 00:07:30.000
이 마지막 것은 제가 당신의 관심을 끌고 싶은 것입니다: 시스템은 당신의 확장 프로그램이 보고하는 폴더 계층 구조를 관리합니다.

00:07:30.000 --> 00:07:33.000
이것은 전체 폴더 계층 구조를 판매할 수 있게 해준다.

00:07:33.000 --> 00:07:36.000
당신의 연장선은 여기서 추가로 아무것도 할 필요가 없습니다.

00:07:36.000 --> 00:07:40.000
이것은 최신 파일 공급자에 대해 기본적으로 활성화되어 있습니다.

00:07:40.000 --> 00:07:45.000
마지막 기능이 어떤 종류의 워크플로우를 가능하게 하는지 빠르게 시연해 봅시다.

00:07:45.000 --> 00:07:48.000
이 세션의 샘플 코드로 장치를 설정했습니다.

00:07:48.000 --> 00:07:51.000
우리는 샘플 코드를 iOS로 포팅했습니다.

00:07:51.000 --> 00:07:58.000
우리는 서버에 로그인하기 위해 iOS 앱을 구축했지만 확장 프로그램은 macOS 버전에서 거의 변경되지 않았습니다.

00:07:58.000 --> 00:08:01.000
나는 지금 내 아이패드에서 샘플 코드를 실행하고 있어.

00:08:01.000 --> 00:08:06.000
오른쪽에 파일이 실행되고 있고 이미 내 파일이 동기화되었습니다.

00:08:06.000 --> 00:08:09.000
나는 또한 폴더 선택을 활용하는 앱을 작성했다.

00:08:09.000 --> 00:08:13.000
내 앱은 폴더의 모든 이미지에 세피아 필터를 적용한다.

00:08:13.000 --> 00:08:22.000
이러한 유형의 응용 프로그램은 각 개별 항목에 대한 상호 작용을 강요하지 않고 폴더의 모든 항목에서 작동할 수 있기 때문에 폴더 액세스의 이점을 누릴 수 있습니다.

00:08:22.000 --> 00:08:29.000
데스크톱 클래스 동기화를 사용하면 파일 앱에서 폴더를 배치 편집기로 드래그할 수 있습니다.

00:08:29.000 --> 00:08:35.000
진행 상황을 모니터링할 수 있도록 폴더와 파일을 불러올게요.

00:08:35.000 --> 00:08:40.000
그런 다음 버튼을 누르면 모든 사진이 다운로드되고 수정됩니다.

00:08:40.000 --> 00:08:45.000
수정 후, 그것들은 자동으로 업로드됩니다.

00:08:45.000 --> 00:08:53.000
확장 프로그램에 의해 보고된 업로드 진행 상황은 루프를 유지하기 위해 파일 앱 하단의 사용자에게 표시됩니다.

00:08:53.000 --> 00:08:57.000
내 앱으로 이런 것을 구현하고 싶었다고 가정해 봅시다.

00:08:57.000 --> 00:09:00.000
먼저, 아이템을 드래그하는 것을 구현해 봅시다.

00:09:00.000 --> 00:09:04.000
드래그를 시작하려면, onDrag 메소드를 구현합니다.

00:09:04.000 --> 00:09:07.000
그 방법은 NSItemProvider를 반환할 것이다.

00:09:07.000 --> 00:09:14.000
드래그할 파일 유형으로 itemProvider에 파일 표현을 등록합니다.

00:09:14.000 --> 00:09:17.000
우리의 경우, 그것은 폴더이다.

00:09:17.000 --> 00:09:23.000
getUserVisibleURL 메소드를 사용하여 URL을 가져오세요.

00:09:23.000 --> 00:09:30.000
수신 측에서, 보기를 드롭 타겟으로 표시하기 위해 onDrop을 구현하세요.

00:09:30.000 --> 00:09:35.000
그런 다음 적절한 항목 공급자로부터 파일 URL을 로드할 수 있습니다.

00:09:35.000 --> 00:09:40.000
이것은 당신의 샌드박스 밖에 있는 파일이 될 것이라는 점에 유의하세요.

00:09:40.000 --> 00:09:47.000
앱이 액세스하려면 URL의 보안 범위를 소비하고 해제해야 합니다.

00:09:47.000 --> 00:09:49.000
당신의 다음 단계는 무엇인가요?

00:09:49.000 --> 00:09:54.000
우리는 iOS 앱을 포함하도록 샘플 코드를 업데이트했습니다.

00:09:54.000 --> 00:09:59.000
그것을 다운로드하고 간단한 상태 비주 제공자를 설정하는 것을 실험해 보세요.

00:09:59.000 --> 00:10:04.000
처음부터 시작하는 경우, 업데이트된 Xcode 템플릿을 사용하세요.

00:10:04.000 --> 00:10:07.000
시작하기 위한 기본 프레임이 포함되어 있습니다.

00:10:07.000 --> 00:10:19.000
파일 공급자와 이를 구현하는 방법에 대해 자세히 알아보려면 WWDC21의 "macOS에서 FileProvider로 클라우드에 파일 동기화"를 참조하십시오.

00:10:19.000 --> 00:10:20.000
봐줘서 고마워.

00:10:20.000 --> 23:59:59.000
iOS 기기에서 당신의 성능과 신뢰할 수 있는 공급자를 사용하게 되어 기쁩니다.

