WEBVTT

00:00:01.000 --> 00:00:11.000
이 프레젠테이션에서 우리는 렌더링 패스 내에서 인라인으로 컴퓨팅 기능을 제공하는 Apple의 A11 GPU의 새로운 프로그래밍 가능한 단계인 타일 셰이딩에 초점을 맞출 것입니다.

00:00:11.000 --> 00:00:15.000
타일 셰이딩은 메탈 2에서 완전히 새로운 수준의 성능과 효율성을 가능하게 한다.

00:00:15.000 --> 00:00:22.000
렌더링 및 컴퓨팅 작업은 이제 더 높은 대역폭과 저전력 타일 메모리를 통해 데이터를 공유할 수 있습니다.

00:00:22.000 --> 00:00:25.000
타일 셰이딩은 이미지 블록과 깊이 통합되어 있다.

00:00:25.000 --> 00:00:34.000
이미지 블록 콘텐츠를 분석하거나, 해당 콘텐츠를 요약하거나, 이미지 블록을 중간 장면에 저장하거나, 이미지 블록 레이아웃을 변경할 수 있습니다.

00:00:34.000 --> 00:00:43.000
타일 셰이딩은 또한 스레드 그룹 메모리와 긴밀하게 통합되어 있으며 이후 타일 또는 조각 단계에 대한 타일 상수 데이터를 캐시하는 데 사용할 수 있습니다.

00:00:43.000 --> 00:00:47.000
타일 셰이딩의 필요성에 동기를 부여하는 것으로 시작합시다.

00:00:47.000 --> 00:00:51.000
렌더링 패스 간의 계산을 수행하는 것은 최근 몇 년 동안 더 흔해졌다.

00:00:51.000 --> 00:00:59.000
예를 들어, 타일 지연 및 순방향 렌더링 알고리즘은 음영 비용을 줄이기 위해 화면 정렬 타일과 조명을 교차합니다.

00:00:59.000 --> 00:01:11.000
이 알고리즘의 이면에 있는 아이디어는 모든 조명이 모든 픽셀에 영향을 미치는 것은 아니지만, 픽셀당 컬링은 너무 비쌀 수 있으므로 타일 영역에 대한 비용을 상각한다는 것입니다.

00:01:11.000 --> 00:01:23.000
이전에 Metal for A Series GPU에서 컴퓨팅 미드 렌더링을 수행하려면 타일 메모리에 캐시된 렌더링 대상 데이터를 장치 메모리로 다시 저장하여 컴퓨팅 패스가 소비할 수 있도록 해야 했습니다.

00:01:23.000 --> 00:01:29.000
그런 다음 컴퓨팅은 렌더링이 재개되기 전에 결과를 장치 메모리에 다시 저장해야 합니다.

00:01:29.000 --> 00:01:36.000
로컬 메모리와 외부 메모리 간의 반복되는 데이터 이동은 대역폭 집약적이다.

00:01:36.000 --> 00:01:46.000
Metal 2와 A11 GPU를 사용하면, 이러한 알고리즘은 이제 컴퓨팅 패스를 대신하는 타일 셰이딩을 사용하여 노출된 타일 메모리 내에서만 작동할 수 있습니다.

00:01:46.000 --> 00:01:50.000
렌더링 대상 콘텐츠는 이제 타일 메모리에 한 번 캐시됩니다.

00:01:50.000 --> 00:02:01.000
그런 다음 타일 셰이딩은 이미지 블록에서 직접 작동하며 결과를 스레드 그룹 메모리로 만들 수 있으며, 이는 나중에 렌더링하여 사용할 수 있도록 타일 메모리에 의해 뒷받침됩니다.

00:02:01.000 --> 00:02:10.000
이제 타일 셰이더를 통해 타일 메모리 내에서 더 자주 작동할 수 있는 방법을 보았으니, 타일 셰이딩이 그림과 어떻게 상호 작용하는지 자세히 살펴보겠습니다.

00:02:10.000 --> 00:02:18.000
컴퓨팅 패스 내에서 스레드를 실행하는 것을 디스패치라고 하며, 메탈은 렌더링 패스 내에서 타일 셰이딩 작업에 동일한 이름을 채택한다.

00:02:18.000 --> 00:02:24.000
타일 디스패치는 추첨과 자유롭게 인터리브할 수 있으며 API 제출 순서로 실행됩니다.

00:02:24.000 --> 00:02:31.000
금속은 파견이 실행될 때 파견 전에 발행된 추첨 결과를 볼 수 있도록 보장합니다.

00:02:31.000 --> 00:02:38.000
마찬가지로, 금속은 다음 추첨 또는 파견이 실행될 때 각 파견의 결과를 볼 수 있도록 보장합니다.

00:02:38.000 --> 00:02:42.000
이 동기화 보증은 타일 메모리에 경주 없이 접근할 수 있게 해준다.

00:02:42.000 --> 00:02:46.000
하지만 추첨 사이에는 그러한 보장이 이루어지지 않는다.

00:02:46.000 --> 00:02:52.000
타일 셰이딩의 또 다른 중요한 개념은 스레드가 스레드 그룹과 그리드로 구성되는 방법입니다.

00:02:52.000 --> 00:02:58.000
전통적인 컴퓨팅 디스패치로, 스레드 그룹은 단단히 포장된 그리드로 구성되어 있다.

00:02:58.000 --> 00:03:06.000
그러나 렌더링 패스 내에서 타일 그리드는 전체 패스에서 일정하지만, 스레드 그룹 크기는 디스패치마다 다를 수 있습니다.

00:03:06.000 --> 00:03:16.000
타일을 확대하면 각 스레드를 고유한 픽셀로 매핑하거나 각 스레드를 여러 픽셀로 매핑할 수 있습니다.

00:03:16.000 --> 00:03:20.000
스레드를 자원에 매핑하는 것은 금속에 특별한 의미가 없다.

00:03:20.000 --> 00:03:28.000
이전에 논의한 라이트 컬링 예제의 경우와 같이 픽셀에 매핑되지 않은 스레드를 실행할 수 있습니다.

00:03:28.000 --> 00:03:35.000
그 예에서, 당신의 스레드 그룹 크기는 교차로 테스트가 필요한 조명의 수와 일치할 수 있습니다.

00:03:35.000 --> 00:03:40.000
타일 셰이딩 스레드 그룹은 존재하는 기하학에 관계없이 각 타일에 대해 시작됩니다.

00:03:40.000 --> 00:03:46.000
예를 들어, 타일의 하위 집합에 영향을 미치는 삼각형은 그 타일에 의해서만 처리되어야 한다.

00:03:46.000 --> 00:03:51.000
그러나 후속 타일 발송은 화면의 모든 타일에 의해 처리될 것이다.

00:03:51.000 --> 00:03:59.000
그 파견은 그 타일에 착륙할 수 있는 나중의 기하학을 위해 타일 메모리를 초기화할 수 있기 때문에 그렇게 하는 것이 중요하다.

00:03:59.000 --> 00:04:02.000
뷰포트와 가위 상태도 타일 음영을 제한하지 않습니다.

00:04:02.000 --> 00:04:06.000
일반적으로, 타일 음영은 전통적인 렌더링 상태의 영향을 받지 않는다.

00:04:06.000 --> 00:04:12.000
좋아요, 이제 타일 셰이딩을 지원하는 API 변경 사항으로 돌아가 봅시다.

00:04:12.000 --> 00:04:18.000
렌더링 패스는 이미지 블록 크기를 결정하는 세 가지 타일 크기 중 하나로 구성할 수 있습니다.

00:04:18.000 --> 00:04:29.000
GPU의 기본 처리 단계의 오버헤드를 최소화하기 위해 이미지 블록에 맞는 가장 큰 타일 크기를 선택하고 싶습니다. 이는 A11 GPU에서 32KB입니다.

00:04:29.000 --> 00:04:40.000
그러나 일부 알고리즘은 셰이더 코어의 타일 병렬 처리량을 늘리기 위해 조각이나 타일 처리가 특히 복잡할 때 더 작은 타일 크기를 선택하는 것이 도움이 될 수 있다.

00:04:40.000 --> 00:04:49.000
우리가 이미 보았듯이, 스레드 그룹 메모리는 타일 메모리에서 공급되므로 크기가 타일 크기 선택을 제한할 수도 있습니다.

00:04:49.000 --> 00:04:53.000
타일 셰이딩 파이프라인을 만드는 것은 전통적인 파이프라인을 만드는 것과 비슷하다.

00:04:53.000 --> 00:04:58.000
파이프라인 상태를 만들기 위해 파이프라인 설명자에 함수를 첨부합니다.

00:04:58.000 --> 00:05:02.000
타일 셰이딩을 위해, 금속은 새로운 파이프라인 설명자 유형을 도입한다.

00:05:02.000 --> 00:05:08.000
기존 렌더링 파이프라인 설명자와 비슷하지만, 블렌딩과 같은 렌더링 상태 속성을 제거합니다.

00:05:08.000 --> 00:05:14.000
그것은 또한 하나의 함수만 바인딩될 수 있기 때문에 기존 컴퓨팅 파이프라인 설명자와 유사하다.

00:05:14.000 --> 00:05:19.000
그러나 그 함수는 컴퓨팅 커널이나 프래그먼트 함수일 수 있다.

00:05:19.000 --> 00:05:24.000
컴퓨팅 커널은 우리가 지금까지 논의한 모든 타일 셰이딩 및 이미지블록 기능에 대한 액세스를 제공합니다.

00:05:24.000 --> 00:05:31.000
조각 기반 타일 음영은 더 제한적이지만 나중에 이야기할 구체적이고 중요한 역할을 한다.

00:05:31.000 --> 00:05:36.000
먼저, 타일 파이프라인의 이미지 블록 기능을 다루고 싶습니다.

00:05:36.000 --> 00:05:45.000
타일 셰이딩은 렌더링과 인라인으로 컴퓨팅 디스패치를 실행하기 때문에, 프래그먼트 함수와 마찬가지로 암시적 및 명시적 이미지 블록 모두에 액세스할 수 있습니다.

00:05:45.000 --> 00:05:51.000
그러나 프래그먼트 기능과 달리, 커널 기반 타일 셰이더는 전체 이미지 블록에 액세스할 수 있습니다.

00:05:51.000 --> 00:05:54.000
구문을 살펴봅시다.

00:05:54.000 --> 00:06:01.000
우리는 두 번째 템플릿 인수를 사용하여 템플릿 이미지 블록 유형의 암시적 형태와 명시적 형태 사이를 명확히 합니다.

00:06:01.000 --> 00:06:05.000
우리는 각각 다른 접근 의미를 가지고 있기 때문에 명확해야 한다.

00:06:05.000 --> 00:06:12.000
암시적 형태는 가치 의미론을 가지고 있는데, 이는 우리가 픽셀을 이미지 블록 안팎으로 복사한다는 것을 의미한다.

00:06:12.000 --> 00:06:19.000
명시적인 형태는 이전 프레젠테이션에서 논의된 참조 의미를 가지고 있다.

00:06:19.000 --> 00:06:27.000
우리는 이미 렌더링 패스 내의 이미지 블록이 타일의 수명 동안 어떻게 지속되는지, 그리고 이것을 활용하여 드로우와 디스패치 간에 통신하는 방법을 보았습니다.

00:06:27.000 --> 00:06:32.000
우리의 오프닝 예시에서 나는 또한 스레드 그룹 메모리에 대해서도 마찬가지라고 언급했다.

00:06:32.000 --> 00:06:40.000
영구 스레드 그룹 메모리는 타일 셰이딩에 고유하며 컬링 라이트 목록과 같이 타일 전체에 일정한 데이터를 저장하는 데 적합합니다.

00:06:40.000 --> 00:06:44.000
셰이딩 언어에서 이것을 어떻게 활용하는지 살펴봅시다.

00:06:44.000 --> 00:06:51.000
이 예에서, 우리의 커널 기반 타일 기능은 타일 경계에 대해 컬링을 위한 전체 라이트 목록을 제공합니다.

00:06:51.000 --> 00:06:57.000
또한 이전 타일 디스패치에서 타일의 최소 및 최대 깊이가 주어집니다.

00:06:57.000 --> 00:07:04.000
그런 다음 나중에 프래그먼트 셰이더가 접근할 수 있도록 선별된 결과를 스레드 그룹 메모리에 배치합니다.

00:07:04.000 --> 00:07:11.000
타일 디스패치와 프래그먼트 드로우 모두 스레드 그룹 바인딩 지점에 동의해야 합니다.

00:07:11.000 --> 00:07:15.000
마지막으로 조각 기반 타일 파이프라인의 역할을 고려해 봅시다.

00:07:15.000 --> 00:07:21.000
타일 셰이딩은 이전에 여러 패스였던 것을 병합하여 타일 메모리를 활용할 수 있도록 장려합니다.

00:07:21.000 --> 00:07:27.000
타일 메모리는 귀중한 자원이므로, 그 공간에 더 많은 데이터를 포장하려면 명시적인 이미지 블록이 필요합니다.

00:07:27.000 --> 00:07:38.000
하지만 전체 패스에 대한 정적 타일 메모리 레이아웃은 여전히 맞을 것 같지 않으므로, 계산의 다른 단계를 거치면서 타일 메모리 레이아웃을 유연하게 전환해야 합니다.

00:07:38.000 --> 00:07:41.000
조각 기반 타일 파이프라인은 이러한 전환을 가능하게 한다.

00:07:41.000 --> 00:07:48.000
앞서 설명한 장벽 의미는 전환이 시작되기 전에 모든 타일 메모리 액세스가 완료되도록 합니다.

00:07:48.000 --> 00:07:55.000
그리고 프래그먼트 셰이더가 이미지 블록과 데이터를 복사하기 때문에, 우리는 각 픽셀이 원자적으로 전환되도록 할 수 있습니다.

00:07:55.000 --> 00:07:58.000
예를 들어 봅시다.

00:07:58.000 --> 00:08:09.000
이 예에서, 우리는 지연된 렌더링 단계를 마쳤고 멀티 레이어 알파 블렌딩이라는 대략적인 순서 독립적인 투명성 기술을 구현하기 위해 이미지 블록을 재구성하고 싶습니다.

00:08:09.000 --> 00:08:17.000
우리는 이전 레이아웃을 입력으로 사용하고 새 레이아웃을 반환하는 조각 기반 타일 함수를 사용합니다.

00:08:17.000 --> 00:08:23.000
그리고 종종 그렇듯이, 이전 레이아웃의 데이터를 사용하여 새 레이아웃을 초기화해야 합니다.

00:08:23.000 --> 00:08:29.000
여기서 우리는 지연된 렌더링 단계에서 최종 조명 값을 가져옵니다.

00:08:29.000 --> 00:08:33.000
타일 셰이딩을 더 잘 이해하려면, 샘플 코드를 확인하세요.

00:08:33.000 --> 00:08:37.000
그것은 한 번에 많은 조명으로 그늘을 효율적으로 전달하는 방법을 보여줍니다.

00:08:37.000 --> 00:08:42.000
타일 셰이딩은 타일에 영향을 미치지 않는 조명을 끄는 데 사용됩니다.

00:08:42.000 --> 00:08:50.000
마지막으로, Xcode의 GPU 디버거를 사용하면 셰이더에서 사용하는 방법에 따라 데이터를 포맷하여 스레드 그룹 메모리를 쉽게 검사할 수 있습니다.

00:08:50.000 --> 00:08:59.000
Xcode의 GPU 디버거로 캡처한 후, 바인딩된 리소스 보기의 타일 섹션에서 각 스레드 그룹 메모리를 버퍼로 볼 수 있습니다.

00:08:59.000 --> 00:09:07.000
거기에서 버퍼 뷰어를 사용하여 셰이더가 사용하는 것과 같은 방식으로 포맷된 데이터를 검사할 수 있습니다.

00:09:07.000 --> 00:09:18.000
이 프레젠테이션에서, 우리는 타일 셰이딩을 통해 개발자가 전체 타일 콘텐츠를 분석하고 조작하고, 그림을 통해 통신하고, 다양한 계산 단계를 통해 타일 메모리를 재활용할 수 있는 방법을 보았습니다.

00:09:18.000 --> 00:09:29.000
타일 셰이더를 사용하면 개발자가 A11 GPU의 더 높은 대역폭과 낮은 전력 타일 메모리를 더 잘 활용하기 위해 여러 렌더링과 컴퓨팅 패스를 병합할 수 있습니다.

00:09:29.000 --> 00:09:38.000
Metal 2에 대한 자세한 정보와 샘플 코드에 대한 링크는 개발자 웹사이트 developer.apple.com/metal을 방문하십시오.

00:09:38.000 --> 23:59:59.000
봐줘서 고마워!

