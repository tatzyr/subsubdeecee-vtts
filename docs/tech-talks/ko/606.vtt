WEBVTT

00:00:01.000 --> 00:00:15.000
이미지블록과 타일 셰이딩을 기반으로 하는 이미지블록 샘플 커버리지 컨트롤은 멀티샘플링 렌더링 패스를 최적화할 수 있는 새로운 기회를 제공하며 A11 GPU의 향상된 멀티샘플링 하드웨어를 위해 설계되었습니다.

00:00:15.000 --> 00:00:23.000
Imageblock Sample Coverage는 A11의 새로운 Metal 2 기능에 초점을 맞춘 일련의 프레젠테이션 중 세 번째이다.

00:00:23.000 --> 00:00:31.000
메탈 2의 향상된 멀티샘플링 기능에 뛰어들기 전에, 멀티샘플 안티앨리어싱에 대해 빠르게 재교육해 봅시다.

00:00:31.000 --> 00:00:42.000
멀티샘플 안티앨리어싱 또는 MSAA는 여러 깊이와 색상 샘플로 각 픽셀을 표현하여 원시 가장자리의 모양을 개선하는 데 사용되는 기술입니다.

00:00:42.000 --> 00:00:47.000
먼저 GPU가 멀티샘플링 없이 삼각형을 렌더링하는 방법을 살펴봅시다.

00:00:47.000 --> 00:00:53.000
여기 당신의 색상 첨부 파일을 나타내는 4 x 4 픽셀 그리드가 있습니다.

00:00:53.000 --> 00:00:59.000
GPU의 래스터라이저는 픽셀의 중심을 샘플링하여 원시적으로 덮여 있는지 확인합니다.

00:00:59.000 --> 00:01:02.000
삼각형을 가져오자.

00:01:02.000 --> 00:01:06.000
원시적으로 덮인 모든 픽셀 센터는 빨간색이다.

00:01:06.000 --> 00:01:14.000
각 픽셀에 단일 샘플 위치만 있는 경우, 픽셀은 픽셀 중심만을 기준으로 덮여 있거나 덮여 있지 않은 것으로 분류됩니다.

00:01:14.000 --> 00:01:22.000
결과 이미지에서 가장자리 앨리어싱의 고전적인 증상을 볼 수 있습니다: jaggies라고도 알려진 계단 유물.

00:01:22.000 --> 00:01:26.000
멀티샘플 안티앨리어싱으로 렌더링된 동일한 삼각형을 봅시다.

00:01:26.000 --> 00:01:33.000
이 예에서, 각 픽셀은 네 개의 고르게 분포된 샘플링 위치를 가지고 있다.

00:01:33.000 --> 00:01:40.000
픽셀당 네 개의 샘플로, GPU의 래스터라이저는 원시적인 것에 대한 더 미세한 커버리지를 결정할 수 있다.

00:01:40.000 --> 00:01:49.000
멀티샘플링된 첨부 파일이 해결되면, GPU는 샘플의 값을 평균하여 각 픽셀의 최종 색상을 결정합니다.

00:01:49.000 --> 00:01:54.000
이것은 더 매끄러운 가장자리를 만들고 계단 효과의 모양을 줄인다.

00:01:54.000 --> 00:02:12.000
전통적인 멀티샘플링 구현에서, 개선된 에지 외관에 대한 절충안은 각 샘플을 혼합하는 계산 오버헤드, 멀티샘플링된 첨부 파일 텍스처의 더 큰 메모리 풋프린트, 픽셀당 여러 샘플을 저장하고 해결하기 위한 더 높은 메모리 대역폭이다.

00:02:12.000 --> 00:02:21.000
애플의 A-시리즈 GPU는 이러한 절충안을 직접 해결하는 매우 효율적인 MSAA 구현을 갖추고 있다.

00:02:21.000 --> 00:02:31.000
하드웨어는 각 픽셀에 기본 가장자리가 포함되어 있는지 여부를 추적하여 혼합이 샘플 값이 다른 픽셀에 대해서만 샘플당 실행되도록 합니다.

00:02:31.000 --> 00:02:40.000
A 시리즈 GPU의 Metal을 사용하면 멀티샘플링된 첨부 파일에 메모리 없는 렌더링 대상을 사용하여 추가 메모리 저장 요구 사항을 제거할 수 있습니다.

00:02:40.000 --> 00:02:45.000
전체 샘플 데이터는 타일 메모리에만 일시적으로 존재합니다.

00:02:45.000 --> 00:02:57.000
Metal의 멀티샘플 해결 저장소 작업을 사용하면 타일 메모리에서 해결 첨부 파일로 직접 해결하여 추가 시스템 메모리 대역폭이 발생하지 않습니다.

00:02:57.000 --> 00:03:06.000
또한, Metal 2는 샘플 위치를 선택하고 샘플링 패턴을 제어할 수 있도록 프로그래밍 가능한 샘플 위치를 도입했습니다.

00:03:06.000 --> 00:03:12.000
A11의 메탈 2로, 우리는 멀티샘플링을 블렌딩에서 훨씬 더 효율적으로 만들었다.

00:03:12.000 --> 00:03:26.000
현재 A-시리즈 GPU는 이미 가장자리가 각 픽셀과 교차하는지 여부를 추적하지만, A11 GPU는 각 픽셀 내의 고유한 샘플 수를 추적하여 이 추적을 훨씬 더 미세한 세분화로 확장합니다.

00:03:26.000 --> 00:03:38.000
다른 Metal 2 기능을 사용하지 않더라도, 기존의 멀티샘플링 애플리케이션은 A11의 GPU의 향상된 멀티샘플링 하드웨어와 더 효율적으로 혼합될 것입니다.

00:03:38.000 --> 00:03:53.000
Imageblocks 및 타일 셰이딩과 같은 다른 Metal 2 기능의 유연성을 활용하여 Imageblock Sample Coverage Control을 사용하면 각 픽셀의 샘플 커버리지 추적 데이터에 액세스하여 멀티샘플 렌더링 패스를 더욱 제어할 수 있습니다.

00:03:53.000 --> 00:04:04.000
이미지블록 샘플 커버리지 컨트롤을 사용하면 타일 파이프라인은 사용자 지정 해결 알고리즘을 사용하여 렌더링 패스에서 언제든지 샘플 데이터를 해결할 수 있습니다.

00:04:04.000 --> 00:04:14.000
이미지블록 샘플 커버리지 컨트롤이 제공하는 추가적인 유연성을 이해하려면, 먼저 A-시리즈 GPU에서 에지 추적이 어떻게 작동하는지 이해해야 합니다.

00:04:14.000 --> 00:04:24.000
현재 A-시리즈 GPU는 타일로 장면을 래스터화하며, 각 타일에는 픽셀에 기본 가장자리가 포함되어 있는지 여부를 추적하는 메타데이터가 포함되어 있습니다.

00:04:24.000 --> 00:04:30.000
이 이미지에서, 빨간색 픽셀은 원시적인 가장자리를 포함하고, 흰색 픽셀은 그렇지 않다.

00:04:30.000 --> 00:04:35.000
가장자리를 포함하는 픽셀의 수는 장면의 기하학의 밀도에 비해 증가합니다.

00:04:35.000 --> 00:04:41.000
픽셀에 원시적인 가장자리가 포함되어 있을 때, 그것은 여러 개의 고유한 샘플 값을 가지고 있다는 것을 의미한다.

00:04:41.000 --> 00:04:46.000
이러한 이유로, 블렌드 방정식은 가장자리를 포함하는 픽셀에 대해 샘플당 실행된다.

00:04:46.000 --> 00:04:50.000
가장자리를 포함하지 않는 픽셀은 한 번만 혼합해야 합니다.

00:04:50.000 --> 00:04:54.000
A11 GPU는 더 미세한 세밀함으로 가장자리를 추적한다.

00:04:54.000 --> 00:04:58.000
가장자리를 포함하는 픽셀은 종종 몇 개의 독특한 샘플만 가지고 있다.

00:04:58.000 --> 00:05:04.000
A11 GPU의 향상된 멀티샘플링은 고유한 샘플만 추적하고 혼합합니다.

00:05:04.000 --> 00:05:10.000
메탈 셰이딩 언어에서, 우리는 이 독특한 샘플에 이름을 붙입니다: 색상.

00:05:10.000 --> 00:05:15.000
그래서 A11 GPU가 멀티샘플 블렌딩 성능을 어떻게 향상시키는지 살펴봅시다.

00:05:15.000 --> 00:05:21.000
원시 가장자리를 포함하는 픽셀의 경우, A11 GPU는 해당 픽셀의 고유한 색상 수를 추적합니다.

00:05:21.000 --> 00:05:28.000
원시인이 교차하거나 픽셀을 완전히 덮을 때, 그 픽셀에 포함된 색상의 수는 증가하고 줄어들 것이다.

00:05:28.000 --> 00:05:32.000
A11 GPU는 이러한 전환을 자동으로 추적한다.

00:05:32.000 --> 00:05:38.000
오른쪽 다이어그램에서, 픽셀은 네 개의 샘플을 포함하지만, 두 가지 색상만 포함한다.

00:05:38.000 --> 00:05:45.000
A11 GPU가 다음 프리미티브를 이 픽셀과 혼합해야 할 때, 혼합할 두 개의 고유한 샘플만 있습니다.

00:05:45.000 --> 00:05:52.000
그리고 프로그래밍 가능한 블렌딩을 사용하는 고급 렌더링 알고리즘의 경우, 비용 절감이 상당할 것이다.

00:05:52.000 --> 00:05:56.000
그래서 이러한 색상 추적 전환 중 몇 가지를 통해 단편을 살펴봅시다.

00:05:56.000 --> 00:06:02.000
처음에, 각 조각은 모든 샘플을 나타내는 단일 색상을 포함한다.

00:06:02.000 --> 00:06:06.000
이것은 렌더링 패스가 시작될 때 당신의 선명한 색상이 될 것입니다.

00:06:06.000 --> 00:06:15.000
원시 가장자리가 픽셀을 자르면, A11 GPU는 새로운 고유한 색상을 만들고 덮인 샘플을 새로운 색상에 할당합니다.

00:06:15.000 --> 00:06:20.000
이 녹색 삼각형으로 덮인 두 샘플은 새로운 색상에 할당됩니다.

00:06:20.000 --> 00:06:25.000
커버되지 않은 샘플은 여전히 색상 0에 할당됩니다.

00:06:25.000 --> 00:06:30.000
이 픽셀과 교차하는 다음 원시가 빨간색 반투명 삼각형이라고 가정해 봅시다.

00:06:30.000 --> 00:06:33.000
빨간 삼각형은 세 개의 샘플을 덮고 있다.

00:06:33.000 --> 00:06:38.000
현재 A-시리즈 GPU는 세 개의 커버된 샘플 각각을 혼합할 것이다.

00:06:38.000 --> 00:06:45.000
A11 GPU는 두 개의 커버된 샘플이 동일한 색상 인덱스를 공유하기 때문에 두 번만 혼합됩니다.

00:06:45.000 --> 00:06:55.000
이 경우, 색상 1은 녹색과 빨간색의 혼합이며, GPU는 새롭고 독특한 색상이기 때문에 인덱스 2에서 새로운 색상을 만듭니다.

00:06:55.000 --> 00:07:00.000
원시가 픽셀을 자를 때 픽셀의 고유한 색상의 수가 증가할 수 있다.

00:07:00.000 --> 00:07:05.000
하지만 하드웨어가 고유한 색상의 수를 줄일 때가 있다.

00:07:05.000 --> 00:07:10.000
여기서, 불투명하고 혼합되지 않은 삼각형은 픽셀을 완전히 덮는다.

00:07:10.000 --> 00:07:23.000
네 개의 샘플은 모두 파란색으로 완전히 대체되므로, 모든 파란색 샘플은 다시 단일 색상으로 나타낼 수 있기 때문에 A11 GPU는 세 가지 색상을 다시 하나로 병합할 것입니다.

00:07:23.000 --> 00:07:36.000
A11 GPU의 향상된 멀티샘플링 하드웨어는 매우 강력하여 Imageblock Sample Coverage Control을 통해 샘플 커버리지를 명시적으로 제어할 수 있도록 Metal 셰이딩 언어를 확장했습니다.

00:07:36.000 --> 00:07:46.000
이 새로운 기능으로, 타일 파이프라인은 픽셀의 색상 범위를 변경하여 렌더링 패스 중간에 샘플 데이터를 해결할 수 있습니다.

00:07:46.000 --> 00:07:52.000
그리고 당신이 메탈 셰이딩 언어로 커널을 작성하기 때문에, 그것은 당신이 자신만의 사용자 지정 해결 필터를 작성할 수 있다는 것을 의미합니다.

00:07:52.000 --> 00:07:55.000
간단한 예시를 살펴봅시다.

00:07:55.000 --> 00:08:00.000
먼저, 우리는 이미지블록 인수가 있는 커널을 가지고 있다.

00:08:00.000 --> 00:08:05.000
다음으로, 우리는 이미지 블록의 주어진 좌표에서 색상 수를 쿼리합니다.

00:08:05.000 --> 00:08:14.000
픽셀당 네 개의 샘플이 있는 렌더링 패스의 경우, 반환된 값은 해당 픽셀에 얼마나 많은 고유한 색상이 있는지에 따라 1, 2, 3 또는 4가 될 수 있습니다.

00:08:14.000 --> 00:08:20.000
멀티샘플링된 이미지블록은 각 샘플이나 색상에 대한 이미지블록 데이터를 반환할 수 있습니다.

00:08:20.000 --> 00:08:25.000
이 예에서, 우리는 컬러 c에 대한 이미지 블록 데이터를 얻을 것이다.

00:08:25.000 --> 00:08:33.000
이 예제는 고유한 색상의 수를 반복하고 있기 때문에, 우리는 또한 각 색상으로 덮인 샘플의 수를 고려해야 합니다.

00:08:33.000 --> 00:08:41.000
우리는 이 색상 인덱스에 대한 커버리지 마스크를 얻고 마스크의 세트 비트 수를 얻기 위해 팝 카운트를 호출하여 이것을 합니다.

00:08:41.000 --> 00:08:52.000
다음으로, 픽셀당 샘플 수로 나누고 전체 샘플 마스크로 해결된 값을 이미지 블록에 다시 기록하여 색상 해결을 마칩니다.

00:08:52.000 --> 00:09:00.000
전체 샘플 마스크로 단일 값을 작성함으로써, A11 GPU는 모든 샘플 데이터를 단일 색상으로 다시 병합합니다.

00:09:00.000 --> 00:09:11.000
이제 이것은 기본적인 해결의 예이지만, 타일 파이프라인이기 때문에, 애플리케이션에 가장 적합한 방식으로 샘플 데이터를 해결하기 위해 커널을 작성할 수 있습니다.

00:09:11.000 --> 00:09:14.000
그래서 당신은 방금 사용자 지정 해결 필터를 작성하는 예를 보았습니다.

00:09:14.000 --> 00:09:18.000
샘플 데이터를 해결하기 위해 타일 셰이딩을 사용해야 하는 또 다른 이유에 대해 논의해 봅시다.

00:09:18.000 --> 00:09:26.000
이제, 일부 응용 프로그램은 많은 불투명한 기하학과 입자와 같은 반투명 기하학이 많은 복잡한 장면을 렌더링합니다.

00:09:26.000 --> 00:09:41.000
A11 GPU는 각 픽셀의 고유한 색상만 혼합하기 위해 최선을 다하지만, 장면에 많은 양의 오버드로와 함께 많은 혼합 형상이 있다는 것을 알고 있다면, 무거운 혼합 단계 전에 타일 파이프라인으로 샘플 데이터를 해결하고 싶을 수도 있습니다.

00:09:41.000 --> 00:09:53.000
이미지블록 샘플 커버리지 컨트롤을 사용하면 불투명한 지오메트리를 렌더링한 후 타일 파이프라인으로 샘플 데이터를 해결하여 혼합하기 전에 모든 픽셀이 단일 고유 색상을 포함하도록 할 수 있습니다.

00:09:53.000 --> 00:09:59.000
샘플 데이터의 범위를 변경하기 위해 타일 파이프라인을 사용하는 고급 예제를 살펴봅시다.

00:09:59.000 --> 00:10:06.000
타일 파이프라인은 컴퓨팅 함수로 구현될 수 있기 때문에, 단순히 평균 값을 함께 하는 것보다 훨씬 더 많은 것을 할 수 있습니다.

00:10:06.000 --> 00:10:19.000
표면 집계 샘플 앱은 멀티샘플 싱글 패스 지연 셰이딩 알고리즘으로 시작하며 타일 기반 커널 디스패치를 사용하여 지연 패스의 음영 샘플 수를 줄입니다.

00:10:19.000 --> 00:10:29.000
이 알고리즘의 목표는 멀티샘플 안티앨리어싱의 가장자리를 부드럽게 하는 이점을 유지하면서 값비싼 지연 패스에서 더 적은 수의 샘플을 음영 처리하는 것이다.

00:10:29.000 --> 00:10:36.000
우리는 알고리즘의 모든 세부 사항에 대해 자세히 알아보지 않을 것이므로, 표면 집계 샘플 앱을 다운로드하여 탐색하십시오.

00:10:36.000 --> 00:10:41.000
하지만 이제 이 기술이 어떻게 셰이딩 비용을 줄이는지 시각화해 봅시다.

00:10:41.000 --> 00:10:47.000
두 이미지는 g-버퍼에서 픽셀당 하나 이상의 샘플을 포함하는 픽셀을 시각화한다.

00:10:47.000 --> 00:10:55.000
왼쪽 이미지는 표면을 병합하기 전에 g 버퍼를 보여주고, 오른쪽 이미지는 표면을 병합한 후 g 버퍼를 보여줍니다.

00:10:55.000 --> 00:11:01.000
표면 집계 커널은 음영 처리가 필요한 g-버퍼 샘플의 수를 줄일 수 있다.

00:11:01.000 --> 00:11:09.000
오른쪽 이미지에서 볼 수 있듯이, 여러 개의 고유한 샘플을 포함하는 유일한 픽셀은 진정한 주름과 깊이 경계에 있습니다.

00:11:09.000 --> 00:11:20.000
A11 GPU의 메탈 2 이전에, 이 알고리즘은 알고리즘의 각 단계에 대해 별도의 렌더링 패스가 필요하며, 시스템 메모리로 여러 번 왕복해야 합니다.

00:11:20.000 --> 00:11:29.000
하지만 Imageblock Sample Coverage Control을 사용하면 알고리즘의 세 단계를 모두 하나의 렌더링 패스로 병합하여 앱에 엄청난 메모리 대역폭을 절약할 수 있습니다.

00:11:29.000 --> 00:11:36.000
다이어그램에서 볼 수 있듯이, 세 단계 모두 타일 메모리 안에 모든 작업 데이터를 유지하는 이미지 블록에서 작동합니다.

00:11:36.000 --> 00:11:40.000
먼저, g-버퍼를 타일 메모리의 이미지 블록으로 렌더링할 것입니다.

00:11:40.000 --> 00:11:50.000
그리고 다음으로, 당신은 표면 집계 타일 파이프라인을 파견하여 g-버퍼 샘플의 수를 더 적은 집계 g-버퍼 샘플로 줄일 것입니다.

00:11:50.000 --> 00:11:56.000
마지막으로, 지연된 셰이딩 패스는 각 집계 샘플만 음영 처리합니다.

00:11:56.000 --> 00:12:04.000
이 기술에 대해 더 알고 싶다면, 이 프레젠테이션 끝에 있는 링크를 방문하여 샘플 앱을 다운로드하세요.

00:12:04.000 --> 00:12:10.000
요약하자면, 우리는 먼저 A11 GPU의 멀티샘플링에 대한 하드웨어 개선에 대해 이야기했다.

00:12:10.000 --> 00:12:17.000
A11 GPU는 블렌딩 비용을 줄이기 위해 모든 픽셀의 고유한 샘플 수를 추적합니다.

00:12:17.000 --> 00:12:23.000
이 최적화는 API 블렌딩과 프로그래밍 가능한 블렌딩 모두에 적용됩니다.

00:12:23.000 --> 00:12:31.000
그런 다음 우리는 이 강력한 하드웨어 기능을 타일 셰이딩에 사용되는 커널에 노출시키는 A11 GPU용 Metal 2의 개선 사항에 대해 논의했습니다.

00:12:31.000 --> 00:12:42.000
Imageblock Sample Coverage Control을 사용하면 사용자 지정 해결 커널을 작성하고 언제든지 렌더링 패스로 발송하여 강력한 새로운 최적화를 구현할 수 있습니다.

00:12:42.000 --> 00:12:53.000
함께, A11 GPU의 향상된 멀티샘플링과 Metal 2의 새로운 셰이딩 언어 기능은 데이터를 더 오래 유지할 수 있는 새로운 기술을 가능하게 합니다.

00:12:53.000 --> 00:13:00.000
이 기능을 사용하여 단일 렌더링 패스에서 표면 집계와 같은 알고리즘을 구현할 수 있습니다.

00:13:00.000 --> 00:13:10.000
Metal 2에 대한 자세한 정보와 샘플 코드에 대한 링크는 개발자 웹사이트 developer.apple.com/metal을 방문하십시오.

00:13:10.000 --> 23:59:59.000
봐줘서 고마워.

