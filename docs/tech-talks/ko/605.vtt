WEBVTT

00:00:01.000 --> 00:00:08.000
래스터 주문 그룹은 메탈 2의 새로운 기능이며 새로운 A11 GPU를 위해 특별히 확장되었습니다.

00:00:08.000 --> 00:00:12.000
이 비디오는 A11의 새로운 GPU 기능을 설명하는 다섯 가지 중 하나이다.

00:00:12.000 --> 00:00:18.000
그것을 최대한 활용하려면, 이전에 이미지블록과 타일 셰이더에서 비디오를 보고 싶을 것입니다.

00:00:18.000 --> 00:00:25.000
새로운 A11의 새로운 기능으로 넘어가기 전에 메탈 2에서 이미 사용할 수 있는 래스터 주문 그룹에 대한 간략한 검토로 시작하겠습니다.

00:00:25.000 --> 00:00:33.000
래스터 순서 그룹은 GPU가 겹치는 다른 스레드와 순서대로 조각 셰이더 스레드의 일부를 실행해야 하는 기능입니다.

00:00:33.000 --> 00:00:41.000
이 순서는 렌더패스 내의 드로우 호출의 제출 순서와 그 드로우 호출 내의 각 삼각형의 순서에서 비롯됩니다.

00:00:41.000 --> 00:00:44.000
중복은 래스터라이저에 의해 결정된다.

00:00:44.000 --> 00:00:53.000
두 개의 조각 스레드는 동일한 프레임버퍼 X와 Y 위치, 동일한 샘플 및 동일한 레이어를 대상으로 하는 경우 겹치는 것으로 결정됩니다.

00:00:53.000 --> 00:01:01.000
예를 들어, 두 조각이 동일한 깊이 버퍼 샘플에 대해 깊이 테스트를 할 경우 겹치는 것으로 간주됩니다.

00:01:01.000 --> 00:01:08.000
이것은 파란색 삼각형이 먼저이고 녹색 삼각형이 두 번째인 두 개의 삼각형의 전형적인 경우이다.

00:01:08.000 --> 00:01:14.000
고전적인 그래픽 프레임 버퍼에 접근하기 위해, 블렌딩은 항상 GPU가 순서대로 실행하는 것이다.

00:01:14.000 --> 00:01:20.000
GPU는 프레임에서 프레임으로의 일정 변화 때문에 갑자기 뒤쪽의 녹색 삼각형을 혼합하지 않을 것이다.

00:01:20.000 --> 00:01:24.000
하지만 조각 셰이더는 동시에 순서대로 실행될 것이다.

00:01:24.000 --> 00:01:32.000
래스터 주문 그룹이 없으면, 작업은 조각 셰이딩이 완료된 후에만 직렬화되지만, 혼합하기 전에 직렬화됩니다.

00:01:32.000 --> 00:01:34.000
하지만 만약 당신이 프레임버퍼에 섞이지 않는다면 어떨까요?

00:01:34.000 --> 00:01:40.000
그래픽 알고리즘의 많은 최근 발전은 프래그먼트 셰이더에서 더 흥미로운 데이터 구조를 구축하려고 시도합니다.

00:01:40.000 --> 00:01:45.000
더 나은 후처리 또는 독립적인 투명성을 위한 다층 인코딩이 있습니다.

00:01:45.000 --> 00:01:49.000
복소화와 특수 목적의 혼합 기능이 있다.

00:01:49.000 --> 00:01:57.000
이 모든 것은 단순히 색상을 출력 텍스처에 혼합하는 것이 아니라 메모리의 사용자 지정 데이터 구조에 데이터를 저장하는 프래그먼트 셰이더를 기반으로 합니다.

00:01:57.000 --> 00:02:05.000
하지만 프래그먼트 셰이더의 몸체에서 메모리에 대한 직접적인 접근이 어떤 순서로든, 언제든지, 그리고 동시에 일어날 수 있다면, 그것은 심각하게 제한적이다.

00:02:05.000 --> 00:02:13.000
이러한 데이터 경쟁을 다루는 것은 그러한 알고리즘의 기존 구현을 그렇지 않은 경우보다 훨씬 더 비쌌다.

00:02:13.000 --> 00:02:19.000
우리가 정말로 원하는 것은 그 블렌딩과 같은 정렬된 행동을 얻는 것이지만, 우리의 프래그먼트 셰이더가 끝난 후가 아니라 그 안에서 하는 것이다.

00:02:19.000 --> 00:02:24.000
우리는 우리의 메모리 액세스가 순서대로 일어나고 있다는 환상을 효과적으로 원한다.

00:02:24.000 --> 00:02:27.000
그것이 래스터 오더 그룹이 하는 일이다.

00:02:27.000 --> 00:02:31.000
래스터 주문 그룹으로 기억에 대한 포인터에 주석을 달 수 있습니다.

00:02:31.000 --> 00:02:35.000
그런 다음 이러한 포인터를 통한 액세스는 픽셀당 제출 순서로 이루어집니다.

00:02:35.000 --> 00:02:44.000
하드웨어는 현재 스레드가 진행되기 전에 현재 스레드와 겹치는 오래된 조각 셰이더 스레드가 완료되기를 기다릴 것입니다.

00:02:44.000 --> 00:02:47.000
이것은 효과적으로 당신에게 상호 배제를 주지만, 더 좋습니다.

00:02:47.000 --> 00:02:56.000
그것은 어떤 스레드가 중요한 섹션에 먼저 들어갈 것인지, 그리고 어떤 스레드가 두 번째로 그렇게 할 것인지 알 수 있는 정렬된 상호 배제를 제공합니다.

00:02:56.000 --> 00:03:07.000
이 기능은 Metal 2 소개 세션에서 WWDC 2017에서 더 자세하게 제시되었기 때문에, 더 깊은 다이빙을 원한다면, 그 비디오를 볼 수 있습니다.

00:03:07.000 --> 00:03:12.000
그래서 기본 사항을 다루면서, A11 GPU의 새로운 것으로 넘어가자.

00:03:12.000 --> 00:03:17.000
래스터 주문 그룹은 A11에서 더 유용하고, 더 강력하며, 더 높은 성능을 발휘한다.

00:03:17.000 --> 00:03:22.000
먼저, A11은 GPU의 내부 타일 메모리를 노출시킨다.

00:03:22.000 --> 00:03:33.000
장치 및 텍스처 액세스와 마찬가지로, 타일 메모리는 예측 가능한 순서로 액세스할 수 있다면 훨씬 더 유용하므로 래스터 주문 그룹은 이제 타일 메모리에도 적용할 수 있습니다.

00:03:33.000 --> 00:03:46.000
둘째, 다른 GPU의 래스터 주문 그룹이 픽셀당 하나의 뮤텍스로 제한되는 경우, A11은 그보다 더 미세하게 갈 수 있어 더 가벼운 터치를 허용하고 스레드가 액세스를 기다리는 빈도를 최소화할 수 있습니다.

00:03:46.000 --> 00:03:55.000
몇 가지 일반적인 그래픽 알고리즘에서 새로운 성능을 잠금 해제하기 위해 이러한 기능을 사용하는 방법을 보여주는 한 쌍의 예를 보여드리고 싶습니다.

00:03:55.000 --> 00:03:58.000
첫 번째 예는 고전적인 지연 음영이다.

00:03:58.000 --> 00:04:03.000
전통적인 GPU에서, 지연된 셰이딩은 두 패스로 이루어진다.

00:04:03.000 --> 00:04:14.000
먼저 G-버퍼를 채우고 여러 텍스처를 출력한 다음, 그 텍스처에서 읽고, 라이트 볼륨을 렌더링하고, 셰이딩 결과를 계산하는 두 번째 렌더패스.

00:04:14.000 --> 00:04:17.000
하지만 지연된 음영은 많은 메모리 대역폭을 태우는 경향이 있다.

00:04:17.000 --> 00:04:33.000
A-시리즈 GPU의 훌륭한 능력 중 하나는 칩에서 가능한 한 많은 대역폭을 유지하고, 두 패스를 하나로 통합하여 이러한 중간 텍스처를 제거하고, GPU 내의 이미지 블록으로 완전히 타일 크기의 덩어리에 G-버퍼를 유지하는 것입니다.

00:04:33.000 --> 00:04:37.000
이 두 작업 모두 하나의 렌더링패스의 단계가 된다.

00:04:37.000 --> 00:04:49.000
A11 이미지블록과 타일 셰이딩 비디오에서 이러한 결합된 RenderRasses를 만드는 방법에 대한 훨씬 더 깊은 다이빙을 볼 수 있으며, 이 비디오는 동기화 측면에만 초점을 맞출 것입니다.

00:04:49.000 --> 00:04:54.000
단일 패스 지연 셰이딩의 성능은 여러 래스터 주문 그룹을 활용하여 훨씬 더 좋아집니다.

00:04:54.000 --> 00:04:59.000
그것을 살펴보기 위해, 2단계의 세부 사항 중 일부를 파헤쳐봅시다: 조명.

00:04:59.000 --> 00:05:06.000
우리의 기본 조명 과정은 빛의 영향을 포함하는 볼륨을 그리는 것으로 시작하며, 조각 셰이더 스레드를 산란합니다.

00:05:06.000 --> 00:05:10.000
각 스레드는 하나의 빛을 하나의 픽셀에 효과적으로 적용하고 있다.

00:05:10.000 --> 00:05:13.000
우리의 조명 스레드는 G-버퍼 필드를 읽는 것으로 시작합니다.

00:05:13.000 --> 00:05:19.000
A-시리즈 GPU에서는 사용 가능한 가장 빠른 메모리인 이미지블록에서 직접 읽고 싶을 것입니다.

00:05:19.000 --> 00:05:25.000
그런 다음 일반적으로 꽤 많은 수학인 선택한 셰이딩 모델을 실행할 것이며, 실행하는 데 시간이 좀 걸릴 수 있습니다.

00:05:25.000 --> 00:05:29.000
마지막으로, 당신은 이 빛의 기여를 이미지 블록으로 다시 합산할 것입니다.

00:05:29.000 --> 00:05:31.000
아주 빠른 단계.

00:05:31.000 --> 00:05:35.000
그런 다음 우리는 두 번째 스레드에 의해 두 번째 빛을 적용합니다.

00:05:35.000 --> 00:05:41.000
A11 이전의 단일 패스 지연 셰이딩 구현의 경우, 다음과 같이 보일 것이다.

00:05:41.000 --> 00:05:48.000
이미지 블록에서 처음 읽을 때 주문이 부과되는 것을 볼 수 있으며, 이 두 조명의 전체 실행이 연속적으로 실행되도록 합니다.

00:05:48.000 --> 00:05:59.000
이는 단일 래스터 주문 그룹만 지원하는 GPU가 이후 스레드의 액세스가 시작되기 전에 이전 스레드의 모든 액세스가 완료될 때까지 기다려야 하기 때문입니다.

00:05:59.000 --> 00:06:05.000
이것은 두 접근이 실제로 서로 충돌하지 않는 읽기인 경우에도 적용됩니다.

00:06:05.000 --> 00:06:10.000
여러 래스터 주문 그룹에 대한 A11의 지원은 이러한 과도한 동기화를 제거합니다.

00:06:10.000 --> 00:06:20.000
여러 그룹을 사용하면 이러한 충돌하지 않는 읽기를 동시에 실행할 수 있으며, 결과를 축적하는 셰이더의 매우 짧은 끝에서만 동기화할 수 있습니다.

00:06:20.000 --> 00:06:29.000
당신은 우리의 세 개의 G-버퍼 필드가 한 그룹에 있고 우리의 축적된 조명 결과가 두 번째 그룹에 있다고 선언함으로써 이것을 달성할 수 있습니다.

00:06:29.000 --> 00:06:31.000
하드웨어는 이제 그것들을 별도로 주문할 수 있다.

00:06:31.000 --> 00:06:37.000
한 그룹에 대한 뛰어난 쓰기는 다른 그룹의 읽기를 기다릴 필요가 없다.

00:06:37.000 --> 00:06:41.000
한 그룹 내의 여러 독자는 서로를 기다릴 필요가 없다.

00:06:41.000 --> 00:06:52.000
이것은 주어진 시간에 더 많은 스레드를 실행할 수 있으며, G-Buffers를 처음부터 유지함으로써 얻을 수 있는 것 이상으로 더 많은 병렬성과 향상된 성능을 허용할 수 있다는 것을 의미합니다.

00:06:52.000 --> 00:06:55.000
그 코드는 간단하다.

00:06:55.000 --> 00:07:02.000
내 세 개의 G-Buffer 필드는 동시에 읽고 함께 쓰여서, 그래서 나는 그것들을 모두 0 그룹에 넣기 위해 주석을 달 것이다.

00:07:02.000 --> 00:07:07.000
누산기는 다른 시간에 읽고 쓰여지므로, 나는 그것을 그룹 1에 주석을 달 것이다.

00:07:07.000 --> 00:07:10.000
입양에 관한 한, 그것은 정말로 그것에 관한 것이다.

00:07:10.000 --> 00:07:15.000
래스터 주문 그룹은 사용하기 매우 쉬운 기능이다.

00:07:15.000 --> 00:07:17.000
두 번째 예로.

00:07:17.000 --> 00:07:22.000
나는 다른 단계를 추가하여 지연된 셰이딩 예제를 더 복잡하게 만들 것이다.

00:07:22.000 --> 00:07:32.000
불투명한 콘텐츠의 조명 버전을 얻은 후, 믹스에 투명도 단계를 추가하고, 앞으로 음영 처리하고, 백 투 프론트 블렌딩 순서를 근사할 것입니다.

00:07:32.000 --> 00:07:39.000
A11이 정말 잘하는 한 가지 방법은 색상과 깊이 쌍의 배열을 저장하기 위해 이미지 블록을 선언하는 것입니다.

00:07:39.000 --> 00:07:45.000
각 순방향 셰이딩 조각은 오버플로 처리와 함께 이 배열에 항목을 추가합니다.

00:07:45.000 --> 00:07:52.000
그리고 내 타일의 끝에서, 나는 저장된 깊이를 사용하여 앞뒤로 정렬하고 혼합하여 앞뒤로 블렌딩할 것이다.

00:07:52.000 --> 00:07:58.000
그래서 이것은 한 타일의 수명과 왼쪽에서 오른쪽으로 이미지 블록을 보여주는 타임라인이다.

00:07:58.000 --> 00:08:04.000
나는 지연된 음영을 위해 배치된 A11의 이미지 블록으로 시작하고, 내 음영의 불투명한 색으로 끝난다.

00:08:04.000 --> 00:08:11.000
결국, 나는 색상과 깊이의 배열을 만들고 분류하는 투명성 단계가 있다.

00:08:11.000 --> 00:08:19.000
이러한 각 패스 내에서, 래스터 주문 그룹은 조각 스레드 간에 얼마나 많은 병렬 처리가 가능한지 제어할 것이다.

00:08:19.000 --> 00:08:24.000
성능상의 이유로, 나는 정말로 이 두 작업이 하나의 렌더패스가 되기를 바란다.

00:08:24.000 --> 00:08:29.000
나는 나중에 다시 로드하기 위해 장치 메모리에 아무것도 저장하고 싶지 않다.

00:08:29.000 --> 00:08:38.000
하지만 이미지 블록 선언은 데이터 유형과 래스터 주문 그룹 할당 모두에서 내 장면의 첫 번째와 두 번째 부분 사이에서 매우 다르다.

00:08:38.000 --> 00:08:43.000
A11은 당신의 한 단계로 이 전환을 할 수 있습니다.

00:08:43.000 --> 00:08:47.000
이 단계들 사이의 격차를 메우려면, 그 사이에 타일 셰이더를 넣어야 합니다.

00:08:47.000 --> 00:08:53.000
타일 셰이더는 전체 타일 메모리와 이미지 블록에 액세스할 수 있는 컴퓨팅 스레드 그룹입니다.

00:08:53.000 --> 00:09:02.000
타일 셰이더는 래스터 주문 그룹 선언에 관계없이 이전에 모든 프래그먼트 셰이더 스레드가 완료될 때까지 실행되지 않는 동작을 가지고 있습니다.

00:09:02.000 --> 00:09:07.000
이를 통해 이 타일 셰이딩 스레드 그룹이 이 메모리에 독점적으로 접근할 수 있다는 것을 확신할 수 있습니다.

00:09:07.000 --> 00:09:20.000
타일 셰이더를 사용하면 전체 타일을 읽고 쓸 수 있으며, 원하는 대로 다시 포맷할 수 있으며, 특히 이전 나가는 유형을 통해 이미지 블록에서 읽고, 새로운 유형을 사용하여 이미지 블록의 내용을 다시 초기화할 수 있습니다.

00:09:20.000 --> 00:09:28.000
타일 셰이더가 실행하기 전에 완전한 장벽을 가지고 있는 것처럼, 실행 후에도 완전한 장벽이 있다.

00:09:28.000 --> 00:09:38.000
후속 조각 셰이더 스레드는 이후 단계에서 래스터 주문 그룹을 어떻게 설정했는지에 관계없이 타일 셰이더가 완전히 완료될 때까지 메모리에 액세스하지 않습니다.

00:09:38.000 --> 00:09:45.000
이것은 투명성 작업이 시작되기 전에 이 초기화가 완료되는 것에 의존할 수 있다는 것을 의미합니다.

00:09:45.000 --> 00:09:47.000
여기서의 요구 사항은 꽤 간단하다.

00:09:47.000 --> 00:09:58.000
이미지 블록 내용을 재정렬하거나 래스터 주문 그룹이 보호하는 필드를 변경하려면, 전환이 잘 정돈되고 안전할 수 있도록 중간에 타일 셰이더를 놓아야 합니다.

00:09:58.000 --> 00:10:04.000
우리가 A11을 위해 게시하고 있는 샘플 코드 중 몇몇은 실제로 이 순서를 보여준다.

00:10:04.000 --> 00:10:09.000
그래서 그것이 A11에서 래스터 오더 그룹의 확장된 기능을 활용하는 데 있는 전부입니다.

00:10:09.000 --> 00:10:15.000
당신은 래스터 주문 그룹이 다른 GPU보다 A11에서 얼마나 더 유연한지 보았습니다.

00:10:15.000 --> 00:10:20.000
하드웨어는 여러 그룹을 지원하여 과도한 동기화를 제거하고 성능을 향상시킬 수 있습니다.

00:10:20.000 --> 00:10:34.000
그들은 A11의 프래그먼트 셰이더의 타일 메모리 액세스와 함께 작동하며 타일 셰이더를 사용하여 렌더링 패스 중간에 래스터 주문 그룹 구성을 포함하여 이미지 블록의 특성을 완전히 변경할 수 있습니다.

00:10:34.000 --> 00:10:43.000
이 모든 것을 종합하면, 대역폭이 믿을 수 없을 정도로 가볍고 성능이 매우 좋은 A11에서 워크로드를 구축할 수 있습니다.

00:10:43.000 --> 00:10:49.000
메탈 2와 A11에 대한 자세한 정보와 샘플 코드에 대한 링크는 메탈 개발자 웹사이트를 방문하십시오.

00:10:49.000 --> 23:59:59.000
봐줘서 고마워.

