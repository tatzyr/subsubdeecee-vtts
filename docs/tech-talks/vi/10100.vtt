WEBVTT

00:00:01.000 --> 00:00:02.000
Alejandro Isaza: Xin chào. Tôi là Alejandro.

00:00:02.000 --> 00:00:08.000
Hôm nay David và tôi sẽ giới thiệu TabularData, một khuôn khổ mới để thao tác và khám phá dữ liệu.

00:00:08.000 --> 00:00:16.000
Tôi sẽ bắt đầu với phần giới thiệu nhanh và sau đó chúng ta sẽ nói về khám phá dữ liệu, chuyển đổi dữ liệu, các phương pháp hay nhất và kết thúc bằng bản tóm tắt.

00:00:16.000 --> 00:00:17.000
Hãy nhảy vào.

00:00:17.000 --> 00:00:20.000
Đầu tiên hãy để tôi nói về, dữ liệu dạng bảng là gì?

00:00:20.000 --> 00:00:26.000
Nói một cách đơn giản nhất, dữ liệu dạng bảng là dữ liệu được sắp xếp theo hàng và cột, tương tự như bảng tính.

00:00:26.000 --> 00:00:29.000
Nhưng hãy tưởng tượng bạn có hàng trăm cột và hàng triệu hàng.

00:00:29.000 --> 00:00:32.000
Đây là nơi khung TabularData xuất hiện.

00:00:32.000 --> 00:00:33.000
Vậy nó là gì?

00:00:33.000 --> 00:00:36.000
Đó là một khuôn khổ hoàn toàn mới mà chúng tôi đang làm việc.

00:00:36.000 --> 00:00:40.000
Nó đã có sẵn trong macOS, iOS, tvOS và watchOS.

00:00:40.000 --> 00:00:44.000
Nó sẽ giúp bạn khám phá và thao tác dữ liệu phi cấu trúc.

00:00:44.000 --> 00:00:49.000
Khi tôi nói "dữ liệu phi cấu trúc", ý tôi là dữ liệu chưa được sắp xếp theo cách được xác định trước.

00:00:49.000 --> 00:00:56.000
Ví dụ, khi bạn tải xuống một tập dữ liệu không có thông số kỹ thuật; giả sử, dữ liệu thời tiết hoặc thống kê dân số.

00:00:56.000 --> 00:00:59.000
Và khám phá là điều đầu tiên bạn làm khi gặp một tập dữ liệu mới.

00:00:59.000 --> 00:01:01.000
Bạn muốn biết loại thông tin nào ở đó.

00:01:01.000 --> 00:01:03.000
Những thứ như, những giá trị là gì?

00:01:03.000 --> 00:01:05.000
Các loại là gì? Dữ liệu được thể hiện như thế nào?

00:01:05.000 --> 00:01:07.000
Có thiếu giá trị không? Và cứ thế.

00:01:07.000 --> 00:01:14.000
Bạn cần có khả năng trả lời những câu hỏi này để hiểu đúng tập dữ liệu và có thể chuyển sang bước tiếp theo, đó là thao tác.

00:01:14.000 --> 00:01:19.000
Thao tác là nơi bạn chuyển đổi tập dữ liệu thành một biểu mẫu phù hợp nhất với vấn đề bạn đang cố gắng giải quyết.

00:01:19.000 --> 00:01:26.000
Ví dụ, bạn có thể muốn biểu diễn ngày như một loại ngày thay vì một chuỗi, hoặc bạn có thể muốn kết hợp tọa độ x và y thành một loại điểm, v.v.

00:01:26.000 --> 00:01:30.000
Khung TabularData rất phù hợp để xử lý các bộ dữ liệu lớn.

00:01:30.000 --> 00:01:32.000
Đây là một số trường hợp sử dụng phổ biến.

00:01:32.000 --> 00:01:36.000
Nhóm dữ liệu theo một số tiêu chí; ví dụ, nhóm người theo độ tuổi.

00:01:36.000 --> 00:01:38.000
Tham gia các bộ dữ liệu trên các giá trị chung.

00:01:38.000 --> 00:01:43.000
Ví dụ, tham gia bảng giao dịch với thông tin của người mua.

00:01:43.000 --> 00:01:48.000
Tách hoặc phân đoạn dữ liệu để xử lý từng bước hoặc lọc thành một tập hợp con của toàn bộ tập dữ liệu.

00:01:48.000 --> 00:01:53.000
Và xây dựng đường ống dữ liệu; ví dụ, khi thực hiện kỹ thuật tính năng cho học máy.

00:01:53.000 --> 00:01:57.000
Trong bối cảnh của khuôn khổ, một bảng được gọi là DataFrame.

00:01:57.000 --> 00:02:00.000
Khung dữ liệu chứa các hàng và cột, tương tự như bảng tính.

00:02:00.000 --> 00:02:04.000
Nhưng không giống như bảng tính, mỗi cột chỉ có thể chứa một loại giá trị cụ thể.

00:02:04.000 --> 00:02:08.000
Nhưng điều này cũng có nghĩa là các cột có thể chứa bất kỳ loại nào, ngay cả các loại tùy chỉnh của riêng bạn.

00:02:08.000 --> 00:02:12.000
Ví dụ, từ điển, tọa độ GPS hoặc mẫu âm thanh thô.

00:02:12.000 --> 00:02:18.000
Biết rằng bất cứ khi nào chúng tôi hiển thị một bảng đại diện cho một DataFrame hoặc một lát DataFrame, chúng tôi bao gồm một cột chỉ mục ở bên trái.

00:02:18.000 --> 00:02:21.000
Điều này có liên quan khi bạn cần truy cập các hàng theo chỉ mục dữ liệu.

00:02:21.000 --> 00:02:29.000
Một số thao tác như bộ lọc, dữ liệu không thay đổi, trong khi các thao tác khác như sắp xếp có thể thay đổi các chỉ số trên khung dữ liệu kết quả.

00:02:29.000 --> 00:02:31.000
Hãy chia nhỏ nó và phóng to một cột.

00:02:31.000 --> 00:02:35.000
Như tôi đã đề cập, một cột có một loại phần tử cụ thể; trong trường hợp này, Int.

00:02:35.000 --> 00:02:37.000
Nó cũng có một cái tên phải là duy nhất trong khung dữ liệu.

00:02:37.000 --> 00:02:41.000
Một cột được biểu diễn bằng loại Cột, là một tập hợp, giống như mảng.

00:02:41.000 --> 00:02:45.000
Bạn có thể tham khảo một cột theo tên nhưng trong hầu hết các trường hợp, bạn cũng cần loại đó.

00:02:45.000 --> 00:02:51.000
Có một cấu trúc được gọi là ColumnID chứa tên và loại của một cột, và có thể được sử dụng để chỉ một cột cụ thể.

00:02:51.000 --> 00:02:56.000
Bất cứ khi nào có thể, tôi khuyên bạn nên sử dụng ColumnID được xác định trước thay vì các ký tự chuỗi để tham chiếu đến các cột.

00:02:56.000 --> 00:03:00.000
Cũng lưu ý rằng tất cả các cột trong Khung dữ liệu phải có cùng số phần tử.

00:03:00.000 --> 00:03:04.000
Nhưng luôn có thể có các phần tử bị thiếu, được biểu diễn dưới dạng các giá trị nil.

00:03:04.000 --> 00:03:06.000
Tương tự như Cột, có một loại Hàng.

00:03:06.000 --> 00:03:10.000
Bạn có thể truy cập từng phần tử của một hàng theo tên cột hoặc theo chỉ mục.

00:03:10.000 --> 00:03:12.000
Bạn có thể nghĩ về Row như một proxy.

00:03:12.000 --> 00:03:17.000
Nó không thực sự chứa các phần tử trong hàng; thay vào đó, nó là một tham chiếu trỏ trở lại một hàng trong DataFrame.

00:03:17.000 --> 00:03:19.000
Vậy làm thế nào để bạn tạo một DataFrame?

00:03:19.000 --> 00:03:20.000
Để tôi chỉ cho bạn.

00:03:20.000 --> 00:03:25.000
Bạn có thể tạo một DataFrame từ một từ điển theo nghĩa đen hoặc bằng cách xây dựng từng cột một.

00:03:25.000 --> 00:03:28.000
Đây là một ví dụ về việc xây dựng từ một từ điển theo nghĩa đen.

00:03:28.000 --> 00:03:35.000
Lưu ý rằng khi sử dụng từ điển theo nghĩa đen, bạn bị hạn chế sử dụng các loại Swift cơ bản như chuỗi, số, giá trị boolean và ngày tháng.

00:03:35.000 --> 00:03:39.000
Cũng nên nhớ rằng mỗi cột phải có cùng số phần tử.

00:03:39.000 --> 00:03:45.000
Một cách tổng quát hơn để xây dựng DataFrame là xây dựng từng cột một và sau đó thêm các cột vào DataFrame.

00:03:45.000 --> 00:03:46.000
Đây là một ví dụ.

00:03:46.000 --> 00:03:48.000
Đầu tiên, tôi tạo một DataFrame trống.

00:03:48.000 --> 00:03:50.000
Sau đó tôi tạo một Cột.

00:03:50.000 --> 00:03:52.000
Và sau đó tôi thêm cột vào DataFrame.

00:03:52.000 --> 00:04:00.000
Tôi có thể lặp lại quy trình cho tất cả các cột, nhưng một lần nữa, hãy đảm bảo rằng mọi cột đều có cùng số phần tử và tên cột đó là duy nhất.

00:04:00.000 --> 00:04:03.000
Bây giờ bạn đã biết DataFrame là gì, hãy thực hiện một số khám phá dữ liệu.

00:04:03.000 --> 00:04:05.000
Điều đầu tiên bạn muốn làm là tải một tập dữ liệu.

00:04:05.000 --> 00:04:10.000
TabularData hỗ trợ đọc các giá trị được phân tách bằng dấu phẩy, tệp CSV và JSON.

00:04:10.000 --> 00:04:16.000
Và nó đơn giản như gọi trình khởi tạo bằng URL tệp, tệp này sẽ tải bằng tất cả các tùy chọn mặc định.

00:04:16.000 --> 00:04:19.000
Hãy cùng khám phá một số tùy chọn có sẵn khi tải CSV.

00:04:19.000 --> 00:04:23.000
Nếu bạn đã sử dụng CSV trước đây, bạn có thể biết rằng không phải lúc nào cũng có dấu phẩy.

00:04:23.000 --> 00:04:26.000
Dấu phân cách có thể là một tab hoặc dấu chấm phẩy.

00:04:26.000 --> 00:04:29.000
Hoặc có thể có hoặc không có một hàng tiêu đề với tên cột.

00:04:29.000 --> 00:04:34.000
Ngoài ra còn có các biến thể về cách thoát chuỗi cho các ký tự đặc biệt và cách biểu diễn các giá trị bị thiếu.

00:04:34.000 --> 00:04:37.000
TabularData có thể xử lý tất cả các biến thể.

00:04:37.000 --> 00:04:45.000
Trong ví dụ này, tôi đang chỉ định rằng không có hàng tiêu đề, sử dụng mã hóa nil tùy chỉnh, bỏ qua các dòng trống và sử dụng dấu phân cách dấu chấm phẩy.

00:04:45.000 --> 00:04:49.000
Vui lòng tham khảo tài liệu để xem toàn bộ tùy chọn cũng như mặc định.

00:04:49.000 --> 00:04:54.000
Nếu bạn có một tệp lớn hơn, bạn có thể chỉ muốn tải một tập hợp con các hàng tại một thời điểm.

00:04:54.000 --> 00:04:55.000
Bạn có thể làm điều này với tùy chọn hàng.

00:04:55.000 --> 00:04:59.000
Ví dụ, điều này sẽ chỉ tải 100 hàng đầu tiên.

00:04:59.000 --> 00:05:02.000
Tương tự, bạn có thể chọn một tập hợp con của các cột.

00:05:02.000 --> 00:05:04.000
Để làm điều này, hãy sử dụng đối số cột.

00:05:04.000 --> 00:05:09.000
Lưu ý rằng điều này cũng sẽ cho phép bạn sắp xếp lại các cột.

00:05:09.000 --> 00:05:13.000
Hãy để tôi nói ngắn gọn về cách suy luận kiểu hoạt động khi tải tệp CSV.

00:05:13.000 --> 00:05:15.000
Tất cả các tệp CSV đều dựa trên văn bản.

00:05:15.000 --> 00:05:18.000
Nhưng việc mọi cột thuộc loại chuỗi không thuận tiện lắm.

00:05:18.000 --> 00:05:26.000
Vì vậy, khi tải tệp CSV, TabularData sẽ cố gắng chuyển đổi các giá trị thành số, giá trị boolean và ngày tháng trước khi mặc định thành chuỗi.

00:05:26.000 --> 00:05:32.000
Nếu bạn muốn buộc các giá trị cho một loại cụ thể hoặc muốn tăng tốc độ tải lên một chút, bạn có thể chỉ định rõ ràng loại cột.

00:05:32.000 --> 00:05:34.000
Bạn làm điều này với đối số kiểu.

00:05:34.000 --> 00:05:39.000
Trong ví dụ này, chúng tôi đang chỉ định loại số nguyên cho cột id và loại chuỗi cho cột tên.

00:05:39.000 --> 00:05:45.000
Điều này sẽ không chỉ đẩy nhanh quá trình tải mà còn gây ra lỗi nếu có giá trị không thể chuyển đổi sang loại được chỉ định.

00:05:45.000 --> 00:05:56.000
Điều này tốt vì nó cho phép bạn phát hiện sớm các vấn đề và xử lý chúng một cách thích hợp thay vì kết thúc bằng một cột thuộc loại không phải là những gì bạn mong đợi, điều này có thể dẫn đến sự cố sau này trong ứng dụng của bạn.

00:05:56.000 --> 00:05:58.000
Cuối cùng, hãy để tôi đề cập đến việc phân tích cú pháp ngày tháng.

00:05:58.000 --> 00:06:02.000
TabularData, theo mặc định, sẽ phát hiện và phân tích ngày tháng ở định dạng ISO8601.

00:06:02.000 --> 00:06:08.000
Nếu tệp CSV của bạn chứa ngày ở định dạng khác, bạn sẽ cần chỉ định chiến lược phân tích cú pháp ngày tùy chỉnh.

00:06:08.000 --> 00:06:12.000
Tôi sẽ để David nói về điều này và cho bạn xem một ví dụ khi chúng ta đi vào bản demo.

00:06:12.000 --> 00:06:15.000
Bây giờ chúng ta hãy chuyển bánh răng và nói về việc viết dữ liệu ra.

00:06:15.000 --> 00:06:18.000
Lựa chọn đầu tiên và đơn giản nhất là sử dụng chức năng in của Swift.

00:06:18.000 --> 00:06:21.000
Điều này sẽ tạo ra một bảng được in đẹp mắt trong Terminal.

00:06:21.000 --> 00:06:29.000
Đầu ra được in bao gồm chỉ mục hàng, tên cột, các loại cột, một vài hàng dữ liệu đầu tiên và số lượng hàng và cột.

00:06:29.000 --> 00:06:34.000
Nó cũng chỉ ra rằng không phải tất cả các hàng đều vừa trên màn hình và không phải tất cả các cột đều vừa trên màn hình.

00:06:34.000 --> 00:06:38.000
Trong trường hợp này, có thêm 10 cột không được hiển thị.

00:06:38.000 --> 00:06:42.000
In ấn rất tốt để khám phá và gỡ lỗi, nhưng rõ ràng là không tuyệt vời để lưu trữ dữ liệu.

00:06:42.000 --> 00:06:47.000
Nếu bạn muốn lưu DataFrame dưới dạng tệp CSV, hãy sử dụng phương thức writeCSV.

00:06:47.000 --> 00:06:51.000
Một điều quan trọng cần lưu ý là writeCSV sẽ sử dụng chuyển đổi chuỗi mặc định của mọi giá trị.

00:06:51.000 --> 00:06:58.000
Hãy cẩn thận khi sử dụng các loại tùy chỉnh trong các cột của bạn, bởi vì CSV được tạo có thể không phải là thứ mà bạn có thể đọc lại.

00:06:58.000 --> 00:07:05.000
Theo nguyên tắc chung, chỉ sử dụng các loại Swift cơ bản trong các cột của bạn khi ghi vào CSV, điều này có thể yêu cầu chuyển đổi một số cột của bạn.

00:07:05.000 --> 00:07:08.000
writeCSV có một số tùy chọn tương tự như các tùy chọn đọc.

00:07:08.000 --> 00:07:11.000
Họ cho phép bạn tùy chỉnh cách dữ liệu CSV được viết.

00:07:11.000 --> 00:07:16.000
Đây là một ví dụ mà tôi đang vô hiệu hóa các tiêu đề bằng cách sử dụng mã hóa nil tùy chỉnh và sử dụng dấu phân cách tùy chỉnh.

00:07:16.000 --> 00:07:20.000
Để truy cập một hàng cụ thể, bạn chỉ có thể sử dụng chỉ số hàng con.

00:07:20.000 --> 00:07:23.000
Sau đó, bạn có thể truy cập một cột cụ thể của hàng đó.

00:07:23.000 --> 00:07:26.000
Nhưng bất cứ khi nào có thể, thay vào đó bạn nên truy cập cột trước và sau đó là hàng.

00:07:26.000 --> 00:07:28.000
Đây là cách bạn truy cập một cột.

00:07:28.000 --> 00:07:33.000
Trong trường hợp truy cập một cột theo tên, bạn có thể bỏ qua nhãn cột: khỏi chỉ số phụ.

00:07:33.000 --> 00:07:35.000
Bạn cũng có thể truy cập một tập hợp con các hàng.

00:07:35.000 --> 00:07:37.000
Trong trường hợp này, bạn nhận được một lát DataFrame.

00:07:37.000 --> 00:07:40.000
Một lát DataFrame rất giống với một DataFrame.

00:07:40.000 --> 00:07:47.000
Về cơ bản, nó là một tham chiếu đến DataFrame ban đầu Trong hầu hết các tình huống, bạn thậm chí không cần phải biết đó là một DataFrame đầy đủ hay một lát cắt.

00:07:47.000 --> 00:07:50.000
Và cuối cùng, bạn cũng có thể chọn một tập hợp con của các cột.

00:07:50.000 --> 00:07:53.000
Điều này sẽ trả về một DataFrame mới chỉ bao gồm các cột đó.

00:07:53.000 --> 00:07:56.000
Bạn cũng có thể chọn một tập hợp con của các hàng bằng phương pháp lọc.

00:07:56.000 --> 00:08:00.000
Kết quả của thao tác lọc là một lát DataFrame, tương tự như chọn một loạt các hàng.

00:08:00.000 --> 00:08:05.000
Nhưng không giống như một loạt các hàng, bộ lọc có thể trả về các hàng không liền kề.

00:08:05.000 --> 00:08:08.000
Bạn cần phải cẩn thận khi xử lý các chỉ số lát cắt DataFrame.

00:08:08.000 --> 00:08:12.000
Tương tự như các lát mảng, các chỉ số của chúng phản ánh các chỉ số của các hàng ban đầu.

00:08:12.000 --> 00:08:18.000
Cụ thể, chỉ số đầu tiên có thể không bằng 0 và chỉ số tiếp theo có thể không phải là chỉ số hiện tại cộng với một.

00:08:18.000 --> 00:08:27.000
Như với các chỉ mục chuỗi, bạn muốn sử dụng startIndex thay vì zero, endIndex thay vì count và index(after:) thay vì thêm một.

00:08:27.000 --> 00:08:31.000
Bây giờ tôi đã đề cập đến những điều cơ bản, hãy áp dụng nó vào thực tế bằng cách xây dựng một ứng dụng.

00:08:31.000 --> 00:08:34.000
Tìm chỗ đậu xe ở San Francisco thật khó.

00:08:34.000 --> 00:08:38.000
David và tôi muốn xây dựng một ứng dụng iPhone hiển thị các điểm đỗ xe gần đó trên đường phố.

00:08:38.000 --> 00:08:44.000
Chúng tôi muốn sử dụng dữ liệu do thành phố công bố để xác định đồng hồ đỗ xe gần nơi bãi đậu xe hiện được cho phép.

00:08:44.000 --> 00:08:47.000
Chúng tôi biết có một tập dữ liệu nhưng chúng tôi không biết chính xác nó chứa những gì.

00:08:47.000 --> 00:08:51.000
Vì vậy, bước đầu tiên sẽ là khám phá tập dữ liệu để hiểu những gì chúng ta có.

00:08:51.000 --> 00:08:53.000
Tôi sẽ giao nó cho David.

00:08:53.000 --> 00:08:54.000
David Findlay: Cảm ơn, Alejandro.

00:08:54.000 --> 00:08:57.000
Xin chào. Tôi là David, một kỹ sư khung.

00:08:57.000 --> 00:09:01.000
Trong bản demo này, tôi sẽ xem qua một ví dụ về cách bạn có thể sử dụng TabularData để khám phá một tập dữ liệu.

00:09:01.000 --> 00:09:05.000
Tôi sẽ bắt đầu bằng cách khám phá tệp CSV về các chính sách đỗ xe.

00:09:05.000 --> 00:09:11.000
Bước đầu tiên là tải dữ liệu, điều mà tôi có thể làm dễ dàng bằng cách chuyển url tệp vào trình khởi tạo DataFrame.

00:09:11.000 --> 00:09:16.000
Lưu ý rằng trình khởi tạo có thể ném được, điều mà tôi thấy hữu ích khi xử lý các lỗi phân tích cú pháp tiềm ẩn.

00:09:16.000 --> 00:09:26.000
Tiếp theo, với một bản in đơn giản, tôi có thể khám phá một vài hàng và cột đầu tiên.

00:09:26.000 --> 00:09:32.000
Quá trình tải mất vài giây và đó là vì DataFrame đã tải hơn một triệu hàng và 15 cột vào bộ nhớ.

00:09:32.000 --> 00:09:43.000
Khi tôi khám phá một tập dữ liệu lần đầu tiên, tôi thường không cần toàn bộ tập dữ liệu, vì vậy tôi sẽ chỉ định một phạm vi hàng khi tải dữ liệu để tăng tốc độ khám phá của mình.

00:09:43.000 --> 00:09:46.000
Tiếp theo, tôi sẽ xem xét các cột.

00:09:46.000 --> 00:09:50.000
Lưu ý rằng hai trong số chúng được ẩn ở bên phải, vì chúng sẽ không vừa với màn hình.

00:09:50.000 --> 00:09:56.000
Hãy để tôi chỉ cho bạn cách khắc phục điều đó với các tùy chọn định dạng.

00:09:56.000 --> 00:09:59.000
Các tùy chọn định dạng cho phép tôi định cấu hình cách dữ liệu được trình bày.

00:09:59.000 --> 00:10:09.000
Trong trường hợp này, tôi sẽ tăng chiều rộng dòng tối đa của mình lên 250, giảm chiều rộng cột xuống còn 15 và giảm các hàng xuống còn năm để tránh cuộn qua kết quả đã in.

00:10:09.000 --> 00:10:21.000
Sau đó, tôi có thể chỉ cần thêm Tùy chọn định dạng vào câu lệnh in của mình bằng phương pháp mô tả.

00:10:21.000 --> 00:10:26.000
Tuyệt vời! Bây giờ tôi có thể khám phá tất cả các cột của mình, tôi sẽ chọn một vài cột thú vị để giữ lại.

00:10:26.000 --> 00:10:31.000
Đây cũng là một cơ hội tốt để sắp xếp lại các cột bằng cách liệt kê chúng theo thứ tự mà tôi muốn.

00:10:31.000 --> 00:10:37.000
Tôi có HourlyRate, DayOfWeek, thời gian bắt đầu và kết thúc, StartDate và PostID.

00:10:37.000 --> 00:10:45.000
Tất cả những gì tôi cần làm tiếp theo là thêm các cột này làm tham số khi tải DataFrame của mình.

00:10:45.000 --> 00:10:48.000
Được rồi, điều này đã dễ dàng hơn rất nhiều để khám phá.

00:10:48.000 --> 00:10:51.000
Hãy nhìn vào cột StartDate, có một loại chuỗi.

00:10:51.000 --> 00:10:55.000
Đó là bởi vì chỉ có ngày ISO8601 được phát hiện tự động.

00:10:55.000 --> 00:10:59.000
Tôi sẽ cần chỉ định rõ ràng bất kỳ định dạng ngày nào khác.

00:10:59.000 --> 00:11:03.000
Tôi có thể khắc phục điều đó bằng cách sử dụng CSVReadingOptions mà Alejandro đã giải thích trước đó.

00:11:03.000 --> 00:11:07.000
Sử dụng API phân tích cú pháp ngày nền tảng, tôi sẽ thêm chiến lược phân tích cú pháp ngày.

00:11:07.000 --> 00:11:15.000
Tôi sẽ chỉ định định dạng là năm, tháng, ngày; ngôn ngữ là tiếng Anh Mỹ; và múi giờ là Giờ chuẩn Thái Bình Dương.

00:11:15.000 --> 00:11:23.000
Sau đó, tôi sẽ vượt qua CSVReadingOptions khi tải DataFrame của mình.

00:11:23.000 --> 00:11:30.000
Bây giờ cột StartDate có loại phù hợp, tôi có thể dễ dàng lọc DataFrame để tôi chỉ có các chính sách đỗ xe đang hoạt động.

00:11:30.000 --> 00:11:37.000
Bắt đầu với biến để biểu diễn ngày hiện tại, sau đó tôi sẽ lọc DataFrame bằng phương pháp lọc.

00:11:37.000 --> 00:11:43.000
Phương thức lọc lấy tên cột - trong trường hợp này là StartDate - và một loại - Date.

00:11:43.000 --> 00:11:51.000
Trong phần đóng, tôi mở gói ngày tùy chọn, trả về sai khi giá trị ngày bằng không để nó không xuất hiện trong kết quả bộ lọc của tôi.

00:11:51.000 --> 00:11:55.000
Và cuối cùng, tôi giữ ngày bắt đầu nhỏ hơn hoặc bằng ngày hiện tại của tôi.

00:11:55.000 --> 00:12:04.000
Tôi sẽ tiếp tục và thay đổi bản in của mình để hiển thị cho bạn kết quả đã lọc.

00:12:04.000 --> 00:12:07.000
Từ bây giờ, tôi sẽ không cần cột StartDate, vì vậy tôi sẽ tiếp tục và xóa nó.

00:12:07.000 --> 00:12:11.000
Nhưng tôi cần phải cẩn thận, vì tôi không thể xóa một cột khỏi lát DataFrame.

00:12:11.000 --> 00:12:18.000
Trước tiên tôi sẽ phải chuyển đổi sang DataFrame và tạo filteredPolicies của var, vì việc xóa một cột là một phương pháp đột biến.

00:12:18.000 --> 00:12:27.000
Bây giờ tôi có thể xóa cột bằng cách sử dụng phương thức removeColumn và chỉ định cột StartDate làm cột cần xóa.

00:12:27.000 --> 00:12:31.000
Được rồi, đó là tất cả những gì tôi muốn khám phá trong tập dữ liệu chính sách đỗ xe.

00:12:31.000 --> 00:12:36.000
Trong phần tiếp theo, Alejandro sẽ thảo luận về các cách mà bạn có thể tăng cường dữ liệu dạng bảng của mình.

00:12:36.000 --> 00:12:38.000
Quay lại với bạn, Alejandro!

00:12:38.000 --> 00:12:39.000
Alejandro: Cảm ơn, David.

00:12:39.000 --> 00:12:41.000
Bây giờ tôi có một số thông tin chi tiết tuyệt vời về tập dữ liệu.

00:12:41.000 --> 00:12:46.000
Bước tiếp theo sẽ là chuyển đổi và tăng cường nó để phù hợp với nhu cầu của chúng tôi.

00:12:46.000 --> 00:12:50.000
Loại chuyển đổi đơn giản nhất là thay đổi các giá trị trong một cột.

00:12:50.000 --> 00:12:55.000
Điều này có thể ở dạng một thao tác bản đồ trong đó mỗi giá trị được ánh xạ đến một giá trị mới, có thể thuộc một loại khác nhau.

00:12:55.000 --> 00:13:00.000
TabularData cung cấp một phiên bản bản đồ tại chỗ để thuận tiện: transformColumn.

00:13:00.000 --> 00:13:06.000
Trong ví dụ này, tôi đang chuyển đổi cột DayOfWeek từ một chuỗi thành một số nguyên đại diện cho ngày trong tuần.

00:13:06.000 --> 00:13:08.000
Đây là mã sẽ trông như thế nào.

00:13:08.000 --> 00:13:14.000
Đối với mỗi phần tử, chúng tôi chuyển đổi chuỗi thành một Int.

00:13:14.000 --> 00:13:18.000
Tương tự như transformColumn, phương pháp giải mã xử lý việc giải mã dữ liệu.

00:13:18.000 --> 00:13:24.000
Khi xử lý các tệp CSV, bạn có thể gặp các mảng hoặc từ điển được nhúng trong CSV dưới dạng các giá trị JSON.

00:13:24.000 --> 00:13:26.000
TabularData cung cấp một phương pháp giải mã cho việc này.

00:13:26.000 --> 00:13:30.000
Đây là một ví dụ trong đó DataFrame ở bên trái có một đốm màu dữ liệu JSON được nhúng.

00:13:30.000 --> 00:13:37.000
Giải mã cho phép bạn sử dụng JSONDecoder để chuyển đổi cột thành loại của riêng bạn; trong ví dụ này, Tùy chọn.

00:13:37.000 --> 00:13:39.000
Và đây là mã sẽ trông như thế nào.

00:13:39.000 --> 00:13:48.000
Hãy nhớ rằng loại Tùy chọn cần phải phù hợp với giao thức Giải mã và cột cần chứa các phần tử của loại Dữ liệu, đó là những gì JSONDecoder mong đợi làm đầu vào.

00:13:48.000 --> 00:13:51.000
Một thao tác hữu ích khác là phương pháp điền.

00:13:51.000 --> 00:13:54.000
Nó cho phép bạn thay thế tất cả các giá trị bị thiếu trong một cột bằng một giá trị mặc định.

00:13:54.000 --> 00:13:58.000
Và để hoàn thành danh sách các hoạt động của cột, tôi muốn đề cập đến bản tóm tắt.

00:13:58.000 --> 00:14:01.000
Tóm tắt cung cấp cho bạn cái nhìn tổng quan nhanh về nội dung của một cột.

00:14:01.000 --> 00:14:03.000
Phương pháp tóm tắt trả về một bản tóm tắt phân loại.

00:14:03.000 --> 00:14:14.000
Nó bao gồm số lượng các phần tử, được hiển thị trong phần mô tả là someCount; số lượng các phần tử bị thiếu, được hiển thị là noneCount; số lượng các phần tử duy nhất; và các giá trị thường xuyên nhất, được gọi là chế độ.

00:14:14.000 --> 00:14:18.000
Ngoài ra còn có numericSummary, chỉ có sẵn cho các cột chứa các giá trị số.

00:14:18.000 --> 00:14:23.000
Nó cũng bao gồm số lượng, cộng với giá trị trung bình, độ lệch chuẩn và các số liệu thống kê khác.

00:14:23.000 --> 00:14:25.000
Ở đây, tôi đang hiển thị kết quả in của bản tóm tắt.

00:14:25.000 --> 00:14:29.000
Nhưng bạn cũng có thể sử dụng cấu trúc tóm tắt trực tiếp để truy cập số liệu thống kê.

00:14:29.000 --> 00:14:34.000
Ví dụ, nếu bạn muốn lọc điểm số thành những điểm trong phân vị thứ 75.

00:14:34.000 --> 00:14:38.000
Được rồi, đó là rất nhiều phép biến đổi cột, nhưng phép biến đổi cột không phải là thú vị nhất.

00:14:38.000 --> 00:14:41.000
Chuyển đổi DataFrame là nơi nó thực sự trở nên thú vị.

00:14:41.000 --> 00:14:45.000
Không giống như các phép biến đổi cột, các phép biến đổi DataFrame thao tác nhiều cột cùng một lúc.

00:14:45.000 --> 00:14:47.000
Một ví dụ đơn giản là sắp xếp.

00:14:47.000 --> 00:14:50.000
Tất cả chúng ta đều biết cách phân loại hoạt động, nhưng hãy để tôi minh họa cho rõ ràng.

00:14:50.000 --> 00:14:52.000
Hãy sắp xếp bảng này theo điểm số.

00:14:52.000 --> 00:14:53.000
Điều này ảnh hưởng đến tất cả các cột.

00:14:53.000 --> 00:14:59.000
Cũng lưu ý rằng các chỉ số hàng thay đổi khi sắp xếp.

00:14:59.000 --> 00:15:02.000
Một chuyển đổi DataFrame thú vị khác là combineColumns.

00:15:02.000 --> 00:15:06.000
Phương pháp combineColumns cho phép bạn kết hợp nhiều cột thành một.

00:15:06.000 --> 00:15:12.000
Ví dụ, hãy tưởng tượng rằng bạn có các cột riêng biệt cho vĩ độ và kinh độ, nhưng bạn muốn kết hợp chúng thành một loại CLLocation.

00:15:12.000 --> 00:15:14.000
Đây là một ví dụ về việc làm điều này.

00:15:14.000 --> 00:15:17.000
Đầu tiên, tôi chỉ định các cột mà tôi muốn kết hợp.

00:15:17.000 --> 00:15:18.000
Sau đó tôi đặt tên cho cột mới.

00:15:18.000 --> 00:15:23.000
Sau đó, tôi chỉ định các loại cột đầu vào và cột mới, và lưu ý rằng mọi thứ phải là tùy chọn.

00:15:23.000 --> 00:15:28.000
Tôi xử lý trường hợp giá trị bị thiếu và tôi xây dựng giá trị mới.

00:15:28.000 --> 00:15:31.000
Tương tự như cột, cũng có một phương pháp tóm tắt cho DataFrame.

00:15:31.000 --> 00:15:33.000
Nó trả về số liệu thống kê tóm tắt cho mọi cột.

00:15:33.000 --> 00:15:39.000
Lưu ý rằng điều này có thể tốn kém nếu bạn có Khung dữ liệu lớn; tốt hơn là chỉ tóm tắt các cột mà bạn quan tâm.

00:15:39.000 --> 00:15:42.000
Một phương pháp thú vị khác là bùng nổ.

00:15:42.000 --> 00:15:47.000
Nó cần một cột chứa một mảng các phần tử và tạo ra một hàng mới cho mọi phần tử trong mảng.

00:15:47.000 --> 00:15:49.000
Hãy nhìn vào ví dụ này.

00:15:49.000 --> 00:15:53.000
Lần này, cột điểm chứa một mảng điểm được nhúng cho mỗi người.

00:15:53.000 --> 00:15:57.000
Nếu tôi áp dụng thao tác bùng nổ cho DataFrame, mỗi thứ này sẽ trở thành một hàng mới.

00:15:57.000 --> 00:16:00.000
Chúng tôi đã lặp lại tên cho những người có nhiều điểm.

00:16:00.000 --> 00:16:05.000
Điều này rất hữu ích khi lọc hoặc thực hiện các thao tác khác yêu cầu xem xét từng điểm số riêng lẻ.

00:16:05.000 --> 00:16:11.000
Với những công cụ này trong kho vũ khí của chúng tôi, tôi sẽ chuyển nó lại cho David, người sẽ giúp chúng tôi đưa dữ liệu đồng hồ vào dạng mà chúng tôi cần.

00:16:11.000 --> 00:16:13.000
David, cho chúng tôi xem một số mã.

00:16:13.000 --> 00:16:14.000
David: Cảm ơn, Alejandro.

00:16:14.000 --> 00:16:18.000
Tôi không biết bạn thế nào, nhưng đối với tôi, phần quan trọng nhất về bãi đậu xe là vị trí.

00:16:18.000 --> 00:16:21.000
May mắn thay, tôi có một tệp CSV khác có những gì tôi cần.

00:16:21.000 --> 00:16:23.000
Để tôi chỉ cho bạn những gì trong đó.

00:16:23.000 --> 00:16:28.000
Tương tự như trước đây, tôi sẽ bắt đầu bằng cách tải dữ liệu, nhưng lần này, tôi đã biết các cột mà tôi quan tâm.

00:16:28.000 --> 00:16:37.000
Tôi có POST_ID, STREET_NAME, STREET_NUM, LATITUDE và LONGITUDE, và tôi sẽ in kết quả bằng cách sử dụng cùng một tùy chọn định dạng từ bản demo trước đó.

00:16:37.000 --> 00:16:44.000
Lần tăng cường đầu tiên tôi muốn là kết hợp các cột vĩ độ và kinh độ thành một cột mới với loại vị trí cốt lõi.

00:16:44.000 --> 00:16:47.000
Phương pháp combineColumns hoàn hảo cho công việc.

00:16:47.000 --> 00:16:52.000
Ở đây, tôi đang kết hợp các cột vĩ độ và kinh độ thành một cột mới có tên là location.

00:16:52.000 --> 00:16:58.000
Trong phần đóng, tôi chỉ định các loại tham số vĩ độ và kinh độ và loại trả về vị trí cốt lõi.

00:16:58.000 --> 00:17:03.000
Tiếp theo, tôi mở gói các giá trị vĩ độ và kinh độ tùy chọn, trả về số không trong trường hợp một trong hai giá trị là số không.

00:17:03.000 --> 00:17:08.000
Và cuối cùng, chuyển các giá trị vĩ độ và kinh độ sang trình khởi tạo vị trí cốt lõi.

00:17:08.000 --> 00:17:15.000
Với vị trí trong DataFrame của mình, tôi có thể bắt đầu xây dựng tính năng đầu tiên cho ứng dụng của mình: đưa ra một vị trí, tìm kiếm đồng hồ đỗ xe gần nhất.

00:17:15.000 --> 00:17:22.000
Tôi sẽ viết một hàm có tên closestParking lấy vị trí, DataFrame và số lượng đồng hồ đỗ xe để đưa vào kết quả tìm kiếm.

00:17:22.000 --> 00:17:24.000
Tôi sẽ bắt đầu với một bản sao địa phương.

00:17:24.000 --> 00:17:30.000
Và sau đó sử dụng phương pháp transformColumn mà Alejandro đã giới thiệu trước đó, tôi sẽ chuyển đổi vị trí thành khoảng cách.

00:17:30.000 --> 00:17:34.000
Và sau đó, tất nhiên, tôi sẽ đổi tên cột vị trí thành khoảng cách.

00:17:34.000 --> 00:17:40.000
Cuối cùng, tôi sẽ sắp xếp cột khoảng cách theo thứ tự tăng dần và giới hạn số lượng điểm quay trở lại.

00:17:40.000 --> 00:17:44.000
Chỉ để cho vui thôi, hãy thử nghiệm điều này bằng cách sử dụng Apple Store ở San Francisco.

00:17:44.000 --> 00:17:51.000
Tôi sẽ cắm tọa độ mà tôi tìm thấy trên Apple Maps, đồng hồ đo DataFrame và giới hạn kết quả tìm kiếm ở năm điểm đỗ xe.

00:17:51.000 --> 00:17:56.000
Hoàn hảo! Có vẻ như có rất nhiều bãi đậu xe gần Apple Store trên Phố Bưu điện.

00:17:56.000 --> 00:18:01.000
Tính năng đầu tiên của ứng dụng đang hoạt động tốt, nhưng nếu tất cả các bãi đậu xe gần nhất đã được sử dụng thì sao?

00:18:01.000 --> 00:18:05.000
Tính năng tiếp theo của ứng dụng là tìm những con phố có nhiều chỗ đậu xe nhất.

00:18:05.000 --> 00:18:10.000
Nhưng trước khi tôi triển khai tính năng này, hãy để tôi giới thiệu một khái niệm mới gọi là nhóm.

00:18:10.000 --> 00:18:13.000
Nhóm chia dữ liệu của bạn thành các nhóm, đưa ra một cột nhóm.

00:18:13.000 --> 00:18:15.000
Ví dụ, cột STREET_NAME.

00:18:15.000 --> 00:18:25.000
Phương pháp nhóm trước tiên xác định các giá trị tên đường duy nhất - Phố Bưu điện, Phố California và Phố Mission - và sau đó chia các hàng thành các nhóm tương ứng.

00:18:25.000 --> 00:18:27.000
Mỗi nhóm là một lát DataFrame.

00:18:27.000 --> 00:18:30.000
Bây giờ, hãy quay trở lại mã.

00:18:30.000 --> 00:18:34.000
Tôi sẽ nhóm đồng hồ theo tên đường bằng cách sử dụng phương pháp được nhóm lại.

00:18:34.000 --> 00:18:39.000
Sau đó, tôi có thể đếm xem mỗi nhóm đường phố có bao nhiêu đồng hồ đỗ xe và phục vụ kết quả theo thứ tự giảm dần.

00:18:39.000 --> 00:18:44.000
Những con phố có nhiều chỗ đậu xe nhất nằm ở đầu kết quả, đó là những gì tôi cần cho ứng dụng của mình.

00:18:44.000 --> 00:18:45.000
Điều này thật tuyệt vời!

00:18:45.000 --> 00:18:47.000
Hai tính năng tuyệt vời cho ứng dụng của tôi.

00:18:47.000 --> 00:18:50.000
Nhưng đợi một chút, tôi vừa nhận ra có một lỗi trong tính năng đầu tiên.

00:18:50.000 --> 00:18:53.000
Đồng hồ đỗ xe gần nhất chỉ xem xét đồng hồ đo DataFrame.

00:18:53.000 --> 00:18:58.000
Những gì tôi thực sự cần là đồng hồ đỗ xe gần nhất với các chính sách đỗ xe đang hoạt động.

00:18:58.000 --> 00:19:02.000
Điều này đang trở nên thú vị, vì thông tin đó nằm trong dữ liệu từ bản demo một.

00:19:02.000 --> 00:19:08.000
Hãy để tôi chỉ cho bạn cách nối dữ liệu từ hai nguồn khác nhau để tôi có thể sửa lỗi.

00:19:08.000 --> 00:19:12.000
Bạn có thể quen thuộc với việc tham gia nếu bạn đã từng sử dụng cơ sở dữ liệu quan hệ trước đây.

00:19:12.000 --> 00:19:15.000
Nó cho phép bạn kết hợp hai DataFrames với nhau bằng cách sử dụng một khóa.

00:19:15.000 --> 00:19:18.000
Chìa khóa là một giá trị xuất hiện trong cả hai DataFrames.

00:19:18.000 --> 00:19:23.000
Trong đồng hồ đo và chính sách DataFrames, chìa khóa là POST_ID, xác định duy nhất đồng hồ đo đỗ xe.

00:19:23.000 --> 00:19:30.000
Thao tác tham gia dẫn đến một DataFrame với các hàng trong đó POST_ID từ mét khớp với POST_ID từ các chính sách.

00:19:30.000 --> 00:19:35.000
Các hàng bao gồm dữ liệu phù hợp từ Khung dữ liệu bên trái và Khung dữ liệu bên phải.

00:19:35.000 --> 00:19:38.000
Lưu ý rằng tên cột có tiền tố trái hoặc phải.

00:19:38.000 --> 00:19:41.000
Điều này cho biết cạnh nào của cột nối đến từ đâu.

00:19:41.000 --> 00:19:45.000
Các tiền tố giúp tránh va chạm đặt tên trong kết quả tham gia.

00:19:45.000 --> 00:19:48.000
Thao tác này là một sự kết hợp bên trong, đó là mặc định.

00:19:48.000 --> 00:19:52.000
Có ba loại tham gia khác: bên ngoài bên trái, bên ngoài bên phải và bên ngoài đầy đủ.

00:19:52.000 --> 00:19:56.000
Tôi sẽ không đi vào chi tiết ở đây, nhưng vui lòng tham khảo tài liệu để tìm hiểu thêm.

00:19:56.000 --> 00:20:00.000
Được rồi, đó là tất cả những gì tôi muốn đề cập đến trong việc tăng cường dữ liệu dạng bảng.

00:20:00.000 --> 00:20:03.000
Trong phần tiếp theo, Alejandro sẽ nói về các phương pháp hay nhất.

00:20:03.000 --> 00:20:05.000
Alejandro: Cảm ơn, David.

00:20:05.000 --> 00:20:08.000
Bây giờ chúng tôi đã có tất cả dữ liệu trong biểu mẫu mà chúng tôi cần, đã đến lúc xây dựng ứng dụng của chúng tôi.

00:20:08.000 --> 00:20:13.000
Hãy để tôi nói về cách bạn có thể sử dụng lại mã khám phá của mình trong khi làm cho nó sẵn sàng sản xuất.

00:20:13.000 --> 00:20:17.000
Hãy để tôi quay lại mã mà chúng tôi đã bắt đầu để tải tệp CSV.

00:20:17.000 --> 00:20:19.000
Nếu bạn làm điều này, các cột sẽ có các loại không xác định.

00:20:19.000 --> 00:20:25.000
Đây là vấn đề đối với các hoạt động như lọc hoặc tham gia nơi bạn cần biết trước loại.

00:20:25.000 --> 00:20:29.000
Nếu bạn đang tải dữ liệu từ nguồn do người dùng cung cấp, việc đưa ra các giả định về loại này là rủi ro.

00:20:29.000 --> 00:20:31.000
Nó có thể dẫn đến ứng dụng của bạn gặp sự cố.

00:20:31.000 --> 00:20:36.000
Thay vào đó, bạn nên khai báo các loại mà bạn mong đợi khi tải dữ liệu, như trong ví dụ này.

00:20:36.000 --> 00:20:39.000
Ở đây, tôi đang xác định ID cột cho mọi cột mà tôi quan tâm.

00:20:39.000 --> 00:20:44.000
Và sau đó tôi đang cung cấp cả tên cột và loại cột cho trình khởi tạo CSV.

00:20:44.000 --> 00:20:49.000
Hãy nhớ rằng bạn có thể sử dụng ID cột thay vì một chuỗi trong bất kỳ phương thức nào đề cập đến một cột.

00:20:49.000 --> 00:20:55.000
Bây giờ, nếu có các giá trị không hợp lệ, bạn sẽ nhận được một ngoại lệ mà bạn có thể xử lý, ví dụ, bằng cách trình bày lỗi cho người dùng.

00:20:55.000 --> 00:20:58.000
Bằng cách này bạn có thể đảm bảo bạn có các cột và loại cột mà bạn mong đợi.

00:20:58.000 --> 00:21:08.000
Điều này đặc biệt quan trọng khi sử dụng các định dạng ngày tùy chỉnh bởi vì nếu bạn không chỉ định rằng cột của bạn thuộc loại ngày, việc phân tích cú pháp ngày có thể thất bại âm thầm và thay vào đó tạo ra một cột chuỗi.

00:21:08.000 --> 00:21:15.000
Buộc nó là một ngày sẽ ném một ngoại lệ bao gồm nội dung của ô không thành công, điều này sẽ giúp bạn gỡ lỗi sự cố.

00:21:15.000 --> 00:21:19.000
Nói về lỗi, đây là loại lỗi bạn nên mong đợi khi tải tệp CSV.

00:21:19.000 --> 00:21:24.000
Phân tích cú pháp không thành công sẽ được tạo khi sử dụng trình phân tích cú pháp ngày tùy chỉnh và một ô không thể phân tích cú pháp.

00:21:24.000 --> 00:21:28.000
Những cái khác tự giải thích, nhưng vui lòng tham khảo tài liệu.

00:21:28.000 --> 00:21:31.000
Và để kết thúc, hãy để tôi đề cập ngắn gọn đến hiệu suất.

00:21:31.000 --> 00:21:37.000
Hầu hết thời gian, bạn không cần phải lo lắng về hiệu suất, nhưng có một vài trường hợp bạn sẽ thấy tác động lớn khi làm việc với các bộ dữ liệu lớn.

00:21:37.000 --> 00:21:40.000
Cái đầu tiên là phân tích cú pháp ngày khi tải CSV.

00:21:40.000 --> 00:21:45.000
Phân tích cú pháp ngày có rất nhiều trường hợp và cân nhắc đặc biệt và do đó, nó có xu hướng chậm.

00:21:45.000 --> 00:21:50.000
Nếu tệp CSV của bạn mất hơn vài giây để tải, đây là nơi đầu tiên bạn nên tìm kiếm để cải thiện.

00:21:50.000 --> 00:21:52.000
Một lựa chọn là trì hoãn việc phân tích cú pháp.

00:21:52.000 --> 00:21:56.000
Điều này hoạt động đặc biệt tốt khi bạn không cần thông tin ngày ngay lập tức.

00:21:56.000 --> 00:21:58.000
Ví dụ, bạn muốn thực hiện lọc hoặc nhóm trước.

00:21:58.000 --> 00:22:04.000
Nếu đó không phải là một lựa chọn, hãy cân nhắc thủ công trình phân tích cú pháp ngày để tối ưu hóa hiệu suất cho chuỗi ngày của bạn.

00:22:04.000 --> 00:22:10.000
Khi nhóm, luôn sử dụng một cột chứa một loại Swift cơ bản làm cột nhóm, chẳng hạn như chuỗi hoặc Int.

00:22:10.000 --> 00:22:12.000
Điều này sẽ tăng tốc hiệu suất nhóm.

00:22:12.000 --> 00:22:19.000
Nếu bạn đang nhóm theo nhiều hơn một cột, trước tiên hãy cân nhắc kết hợp các cột thành một cột duy nhất thuộc loại đơn giản trước và sau đó nhóm lại.

00:22:19.000 --> 00:22:25.000
Ví dụ, nếu bạn muốn nhóm theo ngày trong tuần và loại đồng hồ, hãy cân nhắc kết hợp hai thuộc tính đó thành một chuỗi.

00:22:25.000 --> 00:22:26.000
Ví dụ, kiểu ngày.

00:22:26.000 --> 00:22:32.000
Tương tự, khi tham gia, hãy cân nhắc tham gia vào một cột chứa một loại Swift cơ bản.

00:22:32.000 --> 00:22:34.000
Với điều này, chúng tôi đã sẵn sàng để hoàn thành ứng dụng.

00:22:34.000 --> 00:22:36.000
David, hãy kết thúc nó.

00:22:36.000 --> 00:22:41.000
David: Sử dụng các phương pháp hay nhất của TabularData, tôi sẽ viết chức năng tìm kiếm của ứng dụng.

00:22:41.000 --> 00:22:44.000
Cấu trúc Bãi đậu xe sẽ lưu trữ các đồng hồ đo và chính sách DataFrame được nối.

00:22:44.000 --> 00:22:48.000
Và tôi đã xác định một ColumnID vị trí, vì nhiều phương pháp cần nó.

00:22:48.000 --> 00:22:51.000
Hãy đi sâu vào các chi tiết trong phương pháp loadMeters.

00:22:51.000 --> 00:22:57.000
Ở trên cùng, tôi có ID Cột mà tôi cần để tải đồng hồ.

00:22:57.000 --> 00:23:02.000
Sau đó, tôi tải đồng hồ và chỉ định các loại dự kiến của mỗi cột.

00:23:02.000 --> 00:23:06.000
Điều này sẽ xảy ra nếu có bất kỳ sự không phù hợp nào trong tệp CSV được cung cấp.

00:23:06.000 --> 00:23:12.000
Tiếp theo, tôi xác minh các cột đã giải quyết chính xác như những gì tôi mong đợi và nếu không tôi sẽ ném một ParkingError tùy chỉnh.

00:23:12.000 --> 00:23:20.000
Cuối cùng, tôi đã tái cấu trúc hoạt động combineColumns để sử dụng ID cột vĩ độ, kinh độ và vị trí.

00:23:20.000 --> 00:23:22.000
Cùng với đó, chức năng tìm kiếm của ứng dụng đã sẵn sàng sản xuất.

00:23:22.000 --> 00:23:27.000
Tôi sẽ đưa nó lại cho Alejandro để tóm tắt lại khung TabularData.

00:23:27.000 --> 00:23:29.000
Alejandro: Cảm ơn, David. Hãy tóm tắt lại.

00:23:29.000 --> 00:23:35.000
Hôm nay chúng tôi đã chỉ cho bạn cách TabularData cho phép bạn khám phá một tập dữ liệu không xác định, thao tác nó và đưa nó vào ứng dụng của bạn.

00:23:35.000 --> 00:23:43.000
Chúng tôi đã khám phá một tập dữ liệu, xem xét một số chuyển đổi cột và dữ liệu, và chúng tôi đã hoàn thành một số phương pháp hay nhất xung quanh việc xử lý lỗi và hiệu suất.

00:23:43.000 --> 00:23:46.000
Tôi nóng lòng muốn xem cách bạn sử dụng TabularData để tạo ra các ứng dụng tuyệt vời.

00:23:46.000 --> 23:59:59.000
Cảm ơn bạn!

