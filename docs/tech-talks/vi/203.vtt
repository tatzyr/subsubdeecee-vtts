WEBVTT

00:00:01.000 --> 00:00:11.000
Cập nhật ứng dụng watchOS 4 của bạn cho Apple Watch Series 3 giúp kết nối dễ dàng hơn bao giờ hết và cho phép bạn tận dụng máy đo độ cao khí quyển mới.

00:00:11.000 --> 00:00:18.000
Apple Watch bắt đầu với sự phụ thuộc vào kết nối với iPhone cho tất cả các mạng.

00:00:18.000 --> 00:00:33.000
Tuy nhiên, kể từ watchOS 2, Apple Watch đã có khả năng giao tiếp qua Wi-Fi nếu iPhone của bạn tắt hoặc ngoài phạm vi và bạn đang ở trong phạm vi điểm truy cập Wi-Fi mà iPhone của bạn đã kết nối trước đó.

00:00:33.000 --> 00:00:45.000
Apple Watch Series 3 với mạng di động hiện cho phép ứng dụng của bạn giao tiếp trực tiếp qua kết nối di động nếu iPhone của bạn nằm ngoài phạm vi và Wi-Fi không khả dụng ở nơi bạn đang ở.

00:00:45.000 --> 00:00:57.000
Ứng dụng của bạn không chỉ có thể cập nhật dữ liệu từ mọi nơi mà thông báo đẩy mà iPhone của bạn nhận được sẽ tự động chuyển tiếp đến Apple Watch của bạn khi nó ở trên kết nối di động.

00:00:57.000 --> 00:01:09.000
Để đảm bảo rằng ứng dụng của bạn hoạt động trên bất kỳ và tất cả các khả năng kết nối, giờ đây việc sử dụng URLSession cho các yêu cầu kết nối mạng trong ứng dụng đồng hồ của bạn thậm chí còn quan trọng hơn.

00:01:09.000 --> 00:01:16.000
URLSession là lớp được sử dụng để tạo và quản lý các kết nối mạng trong watchOS.

00:01:16.000 --> 00:01:24.000
Sử dụng URLSession từ mã ứng dụng đồng hồ của bạn, cho phép bạn bắt đầu các yêu cầu mạng trực tiếp từ Apple Watch.

00:01:24.000 --> 00:01:33.000
Khi iPhone của bạn nằm trong phạm vi của Apple Watch, những yêu cầu này sẽ được proxy đằng sau hậu trường thông qua iPhone để tận dụng kết nối của nó.

00:01:33.000 --> 00:01:40.000
Nếu không, các yêu cầu sẽ xảy ra trực tiếp thông qua các điểm truy cập Wi-Fi hoặc kết nối di động.

00:01:40.000 --> 00:01:49.000
Khi sử dụng URLSession trong khi Apple Watch chỉ có kết nối di động, hãy lưu ý rằng các phiên có thể được hệ thống xử lý hơi khác một chút.

00:01:49.000 --> 00:01:53.000
Hãy xem xét các loại phiên khác nhau và những gì bạn có thể mong đợi.

00:01:53.000 --> 00:02:01.000
Đối với các phiên mặc định và phù du, các loại phiên này sẽ hoạt động như bình thường khi trạng thái ứng dụng đang hoạt động.

00:02:01.000 --> 00:02:10.000
Bạn có thể kiểm tra trạng thái ứng dụng hiện tại bằng cách sử dụng thuộc tính applicationState trên đối tượng WKExtension được chia sẻ.

00:02:10.000 --> 00:02:18.000
Tuy nhiên, các loại phiên này không được phép nếu trạng thái ứng dụng không hoạt động hoặc nền.

00:02:18.000 --> 00:02:26.000
Có một cảnh báo về điều này, vì chúng được cho phép nếu ứng dụng của bạn hiện đang sử dụng chế độ điều hướng nền.

00:02:26.000 --> 00:02:29.000
Tiếp theo, hãy xem xét các phiên nền.

00:02:29.000 --> 00:02:41.000
Với các phiên nền, các chuyển nhỏ hơn được ưu tiên và bất kỳ chuyển nào cũng có thể được hoãn lại cho đến khi hệ thống có cơ hội tốt hơn để thực hiện các yêu cầu mạng.

00:02:41.000 --> 00:02:52.000
Điều này được xác định ở cấp độ hệ thống và tính đến nhiều khía cạnh như mức năng lượng, sức mạnh kết nối và các nhiệm vụ mà các ứng dụng khác đang cần hoàn thành.

00:02:52.000 --> 00:03:05.000
Với các phiên nền, một khi yêu cầu đã được thực hiện và phản hồi đã được trả về, nếu ứng dụng của bạn ở trạng thái frontmostapp, ứng dụng của bạn sẽ được đánh thức ngay lập tức và đưa ra phản hồi.

00:03:05.000 --> 00:03:18.000
Bên ngoài trạng thái ứng dụng ngoài cùng, hệ thống sẽ đánh thức ứng dụng của bạn với phản hồi khi xác định đây là thời điểm tốt để làm như vậy hoặc khi trạng thái ứng dụng hoạt động trở lại.

00:03:18.000 --> 00:03:25.000
Bây giờ chúng ta hãy xem qua một vài phương pháp hay nhất để đảm bảo bạn tận dụng tối đa mã mạng của mình trên watchOS.

00:03:25.000 --> 00:03:33.000
Đầu tiên là sử dụng thuộc tính waitsForConnectivity mới trên đối tượng URLSessionConfiguration của bạn.

00:03:33.000 --> 00:03:44.000
Đặt điều này thành true trên một phiên không phải nền sẽ cho phép hệ thống đợi cho đến khi kết nối đủ để thực hiện yêu cầu, thay vì thất bại ngay lập tức.

00:03:44.000 --> 00:03:50.000
Có một phương thức đại diện để biết khi nào kết nối đang chờ, vì vậy bạn có thể xử lý tình huống.

00:03:50.000 --> 00:04:01.000
Chúng tôi khuyến khích sử dụng thuộc tính này cho tất cả các yêu cầu không phụ thuộc vào việc ngay lập tức, vì chúng sẽ kích hoạt ngay lập tức miễn là có kết nối.

00:04:01.000 --> 00:04:07.000
Nếu không, hệ thống sẽ đợi đưa ra yêu cầu cho đến khi kết nối tiếp tục.

00:04:07.000 --> 00:04:14.000
Điều này cho phép bạn tập trung vào những gì làm cho ứng dụng của bạn trở nên tuyệt vời thay vì tập trung vào mã khả năng tiếp cận.

00:04:14.000 --> 00:04:30.000
Sử dụng phương thức applicationWillResignActive trên đối tượng WKExtensionDelegate cho phép bạn tối ưu hóa những gì xảy ra khi trạng thái ứng dụng thay đổi từ hoạt động sang không hoạt động hoặc nền khi bạn đang xử lý yêu cầu mạng.

00:04:30.000 --> 00:04:35.000
Nói cách khác, khi ai đó đặt cổ tay xuống trong khi sử dụng ứng dụng của bạn.

00:04:35.000 --> 00:04:44.000
Bằng cách sử dụng phương pháp này, bạn có thể quyết định hủy yêu cầu hiện tại của mình hoặc tạo lại nó dưới dạng phiên nền.

00:04:44.000 --> 00:04:54.000
Cuối cùng, tốt nhất là luôn sử dụng đối tượng URLSession singleton được chia sẻ cho nhiều tác vụ, thay vì tạo một phiên cho mỗi tác vụ.

00:04:54.000 --> 00:05:05.000
Tạo và vô hiệu hóa nhiều phiên tạo ra chi phí không cần thiết cho hệ thống và tốt nhất là sử dụng phiên được chia sẻ hoặc ít khi cần thiết.

00:05:05.000 --> 00:05:08.000
Hãy chuyển sang khung Kết nối Đồng hồ.

00:05:08.000 --> 00:05:20.000
Khi Apple Watch trở nên độc lập hơn với kết nối của nó, điều quan trọng là phải xác định nơi sử dụng Kết nối Đồng hồ có thể giúp tạo ra trải nghiệm ứng dụng đồng hồ tuyệt vời.

00:05:20.000 --> 00:05:26.000
Sự ra mắt ban đầu của một ứng dụng trên Apple Watch có thể yêu cầu mã thông báo để xác thực với một dịch vụ.

00:05:26.000 --> 00:05:33.000
Sử dụng Kết nối Đồng hồ là một cách tuyệt vời để chuyển thông tin này có thể đã được thiết lập trong ứng dụng iPhone.

00:05:33.000 --> 00:05:43.000
Nếu ứng dụng của bạn là một ứng dụng huấn luyện để tập luyện hoặc một cái gì đó tương tự, ban đầu bạn có thể muốn chuyển một số tệp âm thanh lớn hơn sang Apple Watch khi ai đó bắt đầu sử dụng ứng dụng của bạn.

00:05:43.000 --> 00:05:53.000
Watch Connectivity có thể xử lý các loại chuyển khoản này và có thể giúp cài đặt ứng dụng của bạn vẫn nhỏ và bổ sung ứng dụng với các tài nguyên sau này.

00:05:53.000 --> 00:06:05.000
Phương thức updateApplicationContext trên WCSession cho phép bạn yêu cầu iPhone gửi qua từ điển dữ liệu mà ứng dụng đồng hồ có quyền truy cập vào lần kích hoạt tiếp theo.

00:06:05.000 --> 00:06:17.000
Đây là một cách hay để giữ cho dữ liệu mới chảy vào ứng dụng đồng hồ trong trường hợp ứng dụng iPhone nhận được dữ liệu mới hơn và ứng dụng đồng hồ vẫn chưa có cơ hội cập nhật.

00:06:17.000 --> 00:06:25.000
Khi ứng dụng đồng hồ khởi chạy, bạn có thể hiển thị dữ liệu mới hơn này trong khi bạn bắt đầu yêu cầu mạng để có thêm dữ liệu cập nhật.

00:06:25.000 --> 00:06:31.000
Điều rất quan trọng là bạn xây dựng khả năng dự phòng cho một yêu cầu mạng.

00:06:31.000 --> 00:06:41.000
Với Apple Watch độc lập hơn, ít đảm bảo rằng ứng dụng đồng hồ của bạn sẽ có dữ liệu cập nhật từ iPhone.

00:06:41.000 --> 00:06:54.000
Bây giờ chúng ta hãy chuyển sự chú ý của chúng ta sang máy đo độ cao khí quyển mới trong Apple Watch Series 3, cho phép bạn thêm độ cao hoặc giảm vào bản tóm tắt tập luyện khi ai đó ở xa iPhone của họ.

00:06:54.000 --> 00:07:03.000
Điều này cũng giúp cung cấp các tính toán đốt cháy năng lượng hoạt động chính xác hơn cho HealthKit, và đến lượt nó, ứng dụng của bạn.

00:07:03.000 --> 00:07:12.000
Sử dụng Core Motion, ứng dụng của bạn hiện có thể được thông báo về sự thay đổi độ cao tương đối từ nơi ứng dụng của bạn bắt đầu nhận được các bản cập nhật.

00:07:12.000 --> 00:07:26.000
Thay đổi độ cao tương đối có nghĩa là nếu bạn bắt đầu cập nhật trong khi đứng ở độ cao 800 mét và di chuyển độ cao hơn 50 mét, giá trị độ cao tương đối sẽ là 50 mét.

00:07:26.000 --> 00:07:35.000
Nếu bạn di chuyển thấp hơn 80 mét so với nơi bạn bắt đầu, giá trị độ cao tương đối sau đó sẽ âm 80 mét.

00:07:35.000 --> 00:07:41.000
Core Motion bao gồm lớp CMAltimeter, bạn sẽ sử dụng để nhận các bản cập nhật.

00:07:41.000 --> 00:07:48.000
CMAltimeter có thể xác định và cho bạn biết liệu thiết bị có khả năng cập nhật độ cao tương đối hay không.

00:07:48.000 --> 00:07:55.000
Bạn nên luôn kiểm tra điều này trước khi hỏi Core Motion nhiều hơn về độ cao tương đối.

00:07:55.000 --> 00:08:03.000
Trong watchOS 4, CMAltimeter hiện có thể cung cấp cho bạn trạng thái ủy quyền cho hoạt động Chuyển động và Thể dục.

00:08:03.000 --> 00:08:11.000
Tùy thuộc vào những gì ứng dụng của bạn được phép truy cập, bạn có thể cần xử lý các trường hợp ủy quyền bị từ chối hoặc hạn chế.

00:08:11.000 --> 00:08:18.000
Cuối cùng, CMAltimeter cung cấp khả năng bắt đầu và dừng cập nhật độ cao tương đối.

00:08:18.000 --> 00:08:27.000
Các bản cập nhật này được phân phối theo nhịp hai giây rưỡi trên watchOS 4, do bộ lọc tín hiệu mà chúng tôi áp dụng cho dữ liệu cảm biến thô.

00:08:27.000 --> 00:08:34.000
Khi bạn nhận được bản cập nhật, bạn sẽ có một trình xử lý chuyển cho bạn một đối tượng CMAltitudeData.

00:08:34.000 --> 00:08:41.000
Đối tượng CMAltitudeData cung cấp cho bạn dữ liệu thay đổi độ cao tương đối cho bản cập nhật đó.

00:08:41.000 --> 00:08:45.000
Điều này bao gồm các phần dữ liệu sau: đầu tiên là dấu thời gian.

00:08:45.000 --> 00:08:52.000
Đối tượng này là một khoảng thời gian và được đưa ra dưới dạng số giây kể từ ngày tham chiếu.

00:08:52.000 --> 00:09:02.000
Để chuyển đổi giá trị này thành đối tượng Date, bạn có thể dễ dàng sử dụng phương thức khởi tạo timeIntervalSinceReferenceDate trên lớp Date.

00:09:02.000 --> 00:09:05.000
Thuộc tính tiếp theo là độ cao tương đối.

00:09:05.000 --> 00:09:09.000
Điều này thể hiện sự thay đổi độ cao kể từ sự kiện được báo cáo cuối cùng.

00:09:09.000 --> 00:09:20.000
Hãy nhớ rằng đây sẽ là một giá trị tương đối, vì vậy nếu thiết bị di chuyển độ cao thấp hơn hoặc cao hơn, giá trị này sẽ đại diện cho sự thay đổi độ cao chứ không phải độ cao cụ thể.

00:09:20.000 --> 00:09:22.000
Giá trị này được tính bằng mét.

00:09:22.000 --> 00:09:25.000
Tài sản cuối cùng là áp lực.

00:09:25.000 --> 00:09:34.000
Vì máy đo độ cao trên tàu là máy đo độ cao khí quyển, Core Motion có thể cung cấp cho bạn áp suất được ghi lại cùng với sự thay đổi độ cao tương đối.

00:09:34.000 --> 00:09:39.000
Giá trị này được tính bằng kilopascals.

00:09:39.000 --> 00:09:51.000
Hãy xem qua một ví dụ về cách bắt đầu cập nhật độ cao tương đối bằng CMAltimeter, cũng như cách kiểm tra đúng khả năng của thiết bị và trạng thái ủy quyền.

00:09:51.000 --> 00:10:03.000
Trước phương thức startAltitudeUpdates này, tôi đã nhập khung Core Motion vào lớp của mình và tạo một biến thể hiện được gọi là altimeter, thuộc loại CMAltimeter.

00:10:03.000 --> 00:10:09.000
Đó là đối tượng chúng tôi sẽ sử dụng để bắt đầu và dừng cập nhật độ cao tương đối sau này.

00:10:09.000 --> 00:10:16.000
Trong chức năng của chúng tôi, điều đầu tiên chúng ta nên làm là kiểm tra xem độ cao tương đối có sẵn trên thiết bị hay không.

00:10:16.000 --> 00:10:25.000
Nếu không, chúng tôi có thể muốn thay đổi giao diện người dùng để cho người đó biết rằng dữ liệu này sẽ không khả dụng khi họ sử dụng ứng dụng.

00:10:25.000 --> 00:10:30.000
Tiếp theo, chúng ta cần kiểm tra xem trạng thái ủy quyền có bị từ chối hay bị hạn chế hay không.

00:10:30.000 --> 00:10:37.000
Ở đây, chúng tôi đang đảm bảo trạng thái ủy quyền không bị từ chối, cũng không bị hạn chế.

00:10:37.000 --> 00:10:51.000
Nếu trạng thái ủy quyền được ủy quyền, chúng tôi có thể tiếp tục và nếu trạng thái ủy quyền không được xác định, hệ thống sẽ nhắc truy cập, nếu người đó chưa được nhắc trước đó.

00:10:51.000 --> 00:11:00.000
Khi ứng dụng được phép sử dụng hoạt động Chuyển động và Thể dục, chúng tôi có thể yêu cầu Core Motion bắt đầu cập nhật độ cao tương đối.

00:11:00.000 --> 00:11:16.000
Cuộc gọi này trên một đối tượng CMAltimeter được tạo trước đó yêu cầu chúng tôi vượt qua hàng đợi hoạt động mà chúng tôi muốn nhận thông tin cập nhật, cũng như cung cấp trình xử lý để chạy mỗi khi Core Motion chuyển dữ liệu mới cho chúng tôi.

00:11:16.000 --> 00:11:23.000
Trong trường hợp này, chúng tôi đã đặt hàng đợi hoạt động thành hàng đợi chính vì chúng tôi sẽ cập nhật giao diện người dùng trong trình xử lý.

00:11:23.000 --> 00:11:36.000
Di chuyển đến trình xử lý, nó chuyển cho chúng tôi một đối tượng CMAltitudeData, chứa các giá trị mà chúng tôi quan tâm hoặc có thể là lỗi nếu có sự cố xảy ra trong bản cập nhật.

00:11:36.000 --> 00:11:48.000
Sau khi đảm bảo chúng tôi không có lỗi nào cần xử lý, chúng tôi chỉ cần lấy giá trị relativeAltitude từ đối tượng CMAltitudeData, lưu trữ giá trị float của nó và sử dụng giá trị đó để cập nhật giao diện người dùng.

00:11:48.000 --> 00:11:54.000
Chúng ta có thể dễ dàng sử dụng dấu thời gian hoặc các thuộc tính áp suất, như đã đề cập trước đó.

00:11:54.000 --> 00:12:04.000
Khi chúng tôi không còn cần nhận bản cập nhật nữa, chúng tôi yêu cầu Core Motion dừng cập nhật độ cao tương đối, sử dụng đối tượng CMAltimeter đã sử dụng trước đây của chúng tôi.

00:12:04.000 --> 00:12:07.000
Và thế là xong!

00:12:07.000 --> 00:12:17.000
Để biết thêm thông tin về việc phát triển cho Apple Watch và sử dụng URLSession và Core Motion, vui lòng xem các liên kết tài nguyên ở trang sau.

00:12:17.000 --> 23:59:59.000
Cảm ơn bạn.

