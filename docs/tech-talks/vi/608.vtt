WEBVTT

00:00:00.000 --> 00:00:04.000
Jaap van Muijden: Chào mừng đến với Metal Enhancements cho A13 Bionic.

00:00:04.000 --> 00:00:08.000
Tên tôi là Jaap van Muijden, từ nhóm Phần mềm GPU tại Apple.

00:00:08.000 --> 00:00:17.000
Hôm nay tôi sẽ giới thiệu cho bạn GPU mới nhất do Apple thiết kế trong A13 Bionic và các tính năng Metal mới mà nó cho phép.

00:00:17.000 --> 00:00:25.000
Sau đó tôi sẽ chỉ cho bạn cách sử dụng các tính năng đó để giảm mức sử dụng bộ nhớ của ứng dụng và tối ưu hóa hiệu suất thời gian chạy của nó.

00:00:25.000 --> 00:00:41.000
A13 Bionic mới tiếp tục sự phát triển nhanh chóng của GPU do Apple thiết kế bằng cách tập trung vào ba lĩnh vực chính: hiệu suất chung, cải tiến kiến trúc đáp ứng tốt hơn nhu cầu phát triển của các ứng dụng hiện đại và các tính năng Metal tiên tiến.

00:00:41.000 --> 00:00:43.000
Hãy cùng xem qua từng cái.

00:00:43.000 --> 00:00:55.000
GPU trong A13 Bionic nhanh hơn gần ba lần so với A10 Fusion về hiệu suất chung và được xây dựng dựa trên những cải tiến hiệu suất tuyệt vời của GPU A11 và A12 Bionic.

00:00:55.000 --> 00:01:06.000
Các ứng dụng hiện tại chạy nhanh hơn trên A13 và có thể hoàn thành từng khung hình trong thời gian ngắn hơn, từ đó dẫn đến tiết kiệm năng lượng và sử dụng ứng dụng mở rộng.

00:01:06.000 --> 00:01:11.000
Kiến trúc GPU do Apple thiết kế đã nhanh chóng phát triển để đáp ứng tốt hơn nhu cầu của các ứng dụng hiện đại.

00:01:11.000 --> 00:01:26.000
Bắt đầu với A11, tốc độ dấu phẩy động và kết cấu 16 bit đã được tăng lên để giảm bớt các tắc nghẽn phổ biến trong trò chơi và độ chính xác số của các hoạt động dấu phẩy động 32 bit đã được cải thiện để xử lý tốt hơn khối lượng công việc tính toán nâng cao.

00:01:26.000 --> 00:01:34.000
GPU A12 cải thiện đáng kể băng thông bộ nhớ bằng cách nén và giải nén nội dung kết cấu đến và đi từ bộ nhớ một cách không mất dữ liệu.

00:01:34.000 --> 00:01:44.000
Nó cũng bổ sung phần cứng chuyên dụng để hỗ trợ giao diện người dùng, đảm bảo thời gian phản hồi nhanh hơn, nhưng cũng giảm tác động của các yếu tố giao diện người dùng đối với các ứng dụng tiền cảnh.

00:01:44.000 --> 00:01:51.000
Và A12 và các GPU mới hơn nâng cao trải nghiệm iPad bằng cách chia sẻ tài nguyên của nó giữa các ứng dụng hiệu quả hơn.

00:01:51.000 --> 00:01:54.000
Và bây giờ chúng ta có GPU A13.

00:01:54.000 --> 00:02:08.000
Kiến trúc GPU A13 cải thiện đáng kể việc xử lý nội dung dải động cao trên GPU, bằng cách tăng gấp đôi tốc độ hoạt động của dấu phẩy động 16 bit và thêm hỗ trợ cho các số nhỏ 16 bit để duy trì mức độ đen tốt hơn.

00:02:08.000 --> 00:02:17.000
GPU A13 cũng cung cấp hỗ trợ tốt hơn đáng kể cho công việc tính toán độc lập thực hiện đồng thời với khối lượng công việc kết xuất.

00:02:17.000 --> 00:02:32.000
Các GPU do Apple thiết kế đã hỗ trợ khả năng tính toán không đồng bộ này kể từ A9, nhưng GPU A13 đưa nó lên một tầm cao mới bằng cách thêm nhiều kênh phần cứng hơn và giảm thiểu tác động đến các tác vụ kết xuất nhạy cảm hơn về thời hạn.

00:02:32.000 --> 00:02:43.000
Bây giờ trước khi chúng tôi mô tả các tính năng Metal mới của A13, chúng ta cũng hãy nhanh chóng tóm tắt lại một số tính năng chính của Metal được giới thiệu trên GPU A11 và A12.

00:02:43.000 --> 00:02:45.000
Hãy bắt đầu với A11.

00:02:45.000 --> 00:03:00.000
Bóng gạch, khối hình ảnh và bộ nhớ nhóm luồng liên tục đều là các tính năng được thiết kế để tận dụng rõ ràng kiến trúc kết xuất hoãn dựa trên ô của Apple và làm việc cùng nhau để tối ưu hóa việc sử dụng băng thông của nhiều kỹ thuật kết xuất hiện đại.

00:03:00.000 --> 00:03:12.000
Các nhóm thứ tự Rasterization cho phép bạn quản lý các cấu trúc dữ liệu phức tạp, trên mỗi pixel trên GPU và điều khiển tốc độ màu tối ưu hóa việc sử dụng khử răng cưa đa mẫu trong các thuật toán kết xuất nâng cao.

00:03:12.000 --> 00:03:14.000
Và bây giờ đến A12.

00:03:14.000 --> 00:03:26.000
Kết xuất theo lớp cho phép mỗi nguyên thủy được kết xuất nhắm mục tiêu một lát cắt duy nhất của mảng kết cấu 2D, trong khi kết xuất đa cổng xem cho phép mỗi nguyên thủy làm tương tự cho tối đa 16 khung nhìn và hình chữ nhật cắt kéo.

00:03:26.000 --> 00:03:40.000
Phản hồi Stencil cho phép mỗi đoạn thiết lập một giá trị tham chiếu stprint duy nhất cho các hiệu ứng nâng cao trên mỗi pixel, trong khi độ phân giải stprint cho phép tái sử dụng bộ đệm stprint trên các đường truyền MSAA và không phải MSAA.

00:03:40.000 --> 00:03:52.000
Và mặc dù nén không mất dữ liệu được bật theo mặc định bất cứ khi nào có thể, Metal cũng cung cấp quyền kiểm soát trực tiếp đối với nén tại chỗ và giải nén kết cấu chế độ lưu trữ được chia sẻ khi cần đọc lại tối ưu.

00:03:52.000 --> 00:03:58.000
Vì vậy, bây giờ hãy giới thiệu Apple GPU Family 6 mới hỗ trợ GPU A13.

00:03:58.000 --> 00:04:09.000
Kết cấu thưa thớt cho phép phát trực tuyến kết cấu chất lượng cao hơn cho các trò chơi thế giới mở với ngân sách bộ nhớ cố định, bằng cách theo dõi các khu vực quan trọng nhất của mỗi kết cấu và sau đó chỉ ánh xạ các khu vực đó vào bộ nhớ.

00:04:09.000 --> 00:04:19.000
Bản đồ tốc độ rasterization tập trung rasterization và đổ bóng chất lượng cao vào các khu vực hình ảnh quan trọng nhất, đồng thời giảm tốc độ ở nơi khác, tiết kiệm cả bộ nhớ và hiệu suất.

00:04:19.000 --> 00:04:27.000
Sự khuếch đại đỉnh loại bỏ quá trình xử lý đỉnh dư thừa mà nếu không sẽ xảy ra với các kết xuất nhiều lớp chia sẻ hình học.

00:04:27.000 --> 00:04:38.000
Các đường ống do GPU điều khiển cho phép bạn vẽ các cảnh lớn hơn và nhập vai hơn, và với bộ đệm đối số cấp 2, các ứng dụng có thể thực hiện khối lượng công việc do GPU điều khiển linh hoạt hơn bao giờ hết.

00:04:38.000 --> 00:04:45.000
Hướng dẫn nhóm SIMD tối ưu hóa việc chia sẻ và đồng bộ hóa giữa các luồng của nhóm SIMD trong quá trình đổ bóng.

00:04:45.000 --> 00:04:53.000
Và ASTC HDR mang lại khả năng nén mất dữ liệu chất lượng cao cho các kết cấu dải động cao, tiết kiệm bộ nhớ và băng thông đáng kể.

00:04:53.000 --> 00:04:58.000
Hãy xem xét từng thứ này chi tiết hơn, bắt đầu với kết cấu thưa thớt.

00:04:58.000 --> 00:05:08.000
Kết cấu thưa thớt là một tính năng hoàn toàn mới được giới thiệu trên GPU A13 cho phép bạn kiểm soát việc lưu trữ và cư trú của kết cấu Kim loại ở độ chi tiết tốt.

00:05:08.000 --> 00:05:11.000
Kết cấu thưa thớt không hoàn toàn cư trú trong bộ nhớ.

00:05:11.000 --> 00:05:16.000
Nhưng thay vào đó, bạn có thể phân bổ các phần của chúng trên một đống bộ nhớ đặc biệt được gọi là đống thưa thớt.

00:05:16.000 --> 00:05:21.000
Ở đây bạn có thể thấy hai kết cấu thưa thớt có các phần dữ liệu của chúng được phân bổ trong một đống thưa thớt như vậy.

00:05:21.000 --> 00:05:27.000
Một đống duy nhất có thể cung cấp dung lượng lưu trữ cho nhiều kết cấu thưa thớt, tất cả đều chia sẻ một nhóm bộ nhớ được phân bổ trước duy nhất.

00:05:27.000 --> 00:05:36.000
Tất cả các kết cấu thưa thớt được chia thành các đơn vị được gọi là gạch thưa thớt, có cùng dấu chân bộ nhớ độc lập với độ phân giải kết cấu hoặc định dạng pixel.

00:05:36.000 --> 00:05:38.000
Vậy các ứng dụng của tính năng này là gì?

00:05:38.000 --> 00:05:40.000
Một trong số đó là phát trực tuyến kết cấu.

00:05:40.000 --> 00:05:49.000
Phát trực tuyến kết cấu cho phép bạn hiển thị các cảnh cực kỳ lớn với dấu chân bộ nhớ cố định bằng cách chỉ tải các mipmap kết cấu cần thiết cho chế độ xem hiện tại.

00:05:49.000 --> 00:05:58.000
Với phát trực tuyến kết cấu truyền thống, các mipmap riêng lẻ được tải khi được yêu cầu và bị loại bỏ khi không còn cần thiết hoặc khi các kết cấu quan trọng hơn cần bộ nhớ.

00:05:58.000 --> 00:06:04.000
Phát trực tuyến kết cấu theo truyền thống quản lý cư trú kết cấu ở độ chi tiết mipmap.

00:06:04.000 --> 00:06:10.000
Các cấp thấp nhất của kim tự tháp mipmap được giữ thường trú trong trường hợp yêu cầu mipmap chất lượng cao hơn, nhưng chưa được phát trực tuyến.

00:06:10.000 --> 00:06:17.000
Nó có thể chưa khả dụng vì hoạt động tải chưa hoàn tất hoặc không đủ bộ nhớ phát trực tuyến được phân bổ.

00:06:17.000 --> 00:06:24.000
Có sẵn mipmap cấp thấp nhất đảm bảo rằng luôn có một số dữ liệu hợp lệ để lấy mẫu, mặc dù nó có độ phân giải thấp hơn.

00:06:24.000 --> 00:06:30.000
Tính năng kết cấu thưa thớt của Metal cải thiện mô hình phát trực tuyến kết cấu này theo hai cách.

00:06:30.000 --> 00:06:38.000
Đầu tiên, kết cấu thưa thớt cung cấp bộ đếm truy cập kết cấu mà bạn có thể sử dụng để xác định tần suất truy cập từng vùng của kết cấu thưa thớt.

00:06:38.000 --> 00:06:45.000
Điều này cho phép bạn ưu tiên tải kết cấu, vì các khu vực được trình kết xuất truy cập thường xuyên hơn thường hiển thị rõ hơn trong chế độ xem hiện tại.

00:06:45.000 --> 00:06:51.000
Thứ hai, cư trú có thể được quản lý ở độ chi tiết gạch thưa thớt thay vì độ chi tiết mipmap.

00:06:51.000 --> 00:06:58.000
Điều này cho phép bạn thậm chí còn hiệu quả hơn với bộ nhớ kết cấu của mình và cho phép chi tiết kết cấu dễ nhìn thấy hơn ở nơi nó được tính.

00:06:58.000 --> 00:07:05.000
Kết hợp với nhau, kết cấu thưa thớt cho phép bạn phát trực tuyến chi tiết rõ ràng hơn với cùng ngân sách bộ nhớ, cải thiện chất lượng.

00:07:05.000 --> 00:07:09.000
Bây giờ hãy xem cách bạn tạo và sử dụng các kết cấu thưa thớt trong Metal.

00:07:09.000 --> 00:07:16.000
Để bắt đầu sử dụng kết cấu thưa thớt, trước tiên bạn tạo một đống thưa thớt và sau đó phân bổ một hoặc nhiều kết cấu từ nó.

00:07:16.000 --> 00:07:20.000
Các kết cấu thưa thớt mới được tạo ra ban đầu mà không có bất kỳ ô thưa thớt nào được ánh xạ.

00:07:20.000 --> 00:07:25.000
Bạn cần yêu cầu ánh xạ bộ nhớ từ đống bằng GPU.

00:07:25.000 --> 00:07:31.000
Bộ nhớ được ánh xạ theo các đơn vị có kích thước ô được gọi là ô thưa thớt, tương tự như các trang bộ nhớ ảo.

00:07:31.000 --> 00:07:36.000
Tương tự như vậy, bạn cần yêu cầu GPU hủy ánh xạ các ô khi chúng không còn cần thiết nữa.

00:07:36.000 --> 00:07:43.000
Lấy mẫu một kết cấu thưa thớt hoạt động giống như một kết cấu thông thường và lấy mẫu các vùng chưa được ánh xạ trả về số không.

00:07:43.000 --> 00:07:55.000
Cuối cùng, các bộ đếm truy cập kết cấu có thể được đọc lại từ một kết cấu thưa thớt, để ước tính tần suất mỗi ô được truy cập, để bạn có thể kiểm soát và ưu tiên chính xác khi bạn ánh xạ các ô cho kết cấu của mình.

00:07:55.000 --> 00:07:58.000
Hãy xem xét từng bước này chi tiết hơn.

00:07:58.000 --> 00:08:03.000
Ở đây chúng tôi có một số mã Kim loại tạo ra một đống kết cấu thưa thớt với kích thước bộ nhớ nhất định.

00:08:03.000 --> 00:08:08.000
Đầu tiên chúng tôi tính toán kích thước của đống của mình và đảm bảo rằng nó là bội số của kích thước gạch thưa thớt.

00:08:08.000 --> 00:08:15.000
Ở đây chúng tôi sử dụng chức năng trợ giúp cục bộ để làm tròn kích thước dữ liệu của chúng tôi đến bội số gần nhất của kích thước ô thưa thớt.

00:08:15.000 --> 00:08:22.000
Sau đó, chúng tôi có thể tạo mô tả đống thưa thớt; chúng tôi đặt loại đống thành thưa thớt và chỉ định kích thước đống của chúng tôi tính bằng byte.

00:08:22.000 --> 00:08:27.000
Sau đó, chúng tôi tạo ra đống thưa thớt bằng cách sử dụng đối tượng MTLDevice của chúng tôi.

00:08:27.000 --> 00:08:30.000
Tạo ra một kết cấu thưa thớt rất dễ dàng.

00:08:30.000 --> 00:08:37.000
Đầu tiên, chúng tôi tạo một bộ mô tả kết cấu như bình thường, và sau đó chúng tôi tạo kết cấu bằng cách sử dụng đối tượng đống thưa thớt.

00:08:37.000 --> 00:08:44.000
Bây giờ chúng ta đã thấy cách bạn có thể tạo ra kết cấu thưa thớt, chúng ta hãy xem cách ánh xạ các vùng vào bộ nhớ.

00:08:44.000 --> 00:08:52.000
Việc ánh xạ và hủy ánh xạ các vùng của một kết cấu được thực hiện bằng cách mã hóa các lệnh bản đồ và hủy ánh xạ trong bộ mã hóa lệnh trạng thái tài nguyên.

00:08:52.000 --> 00:09:00.000
Bộ mã hóa này có thể được sử dụng để lên lịch các hoạt động bản đồ và hủy bản đồ trên dòng thời gian GPU, tương tự như mã hóa các lệnh kết xuất khác trong Metal.

00:09:00.000 --> 00:09:03.000
Hãy xem cái này trông như thế nào trong mã.

00:09:03.000 --> 00:09:06.000
Đầu tiên chúng ta tạo ra bộ mã hóa.

00:09:06.000 --> 00:09:14.000
Và sau đó chúng tôi chỉ cần mã hóa một thao tác bản đồ; chúng tôi chỉ định kết cấu và vùng, lát cắt và mức mip nào của kết cấu mà chúng tôi muốn ánh xạ.

00:09:14.000 --> 00:09:20.000
Khu vực hiện đã được ánh xạ và bạn có thể bật hoặc tạo dữ liệu kết cấu của mình vào bộ nhớ được ánh xạ.

00:09:20.000 --> 00:09:26.000
Để hủy ánh xạ một phần, chúng tôi làm theo cùng một quy trình; sự khác biệt duy nhất là chế độ cập nhật mà chúng tôi mã hóa.

00:09:26.000 --> 00:09:32.000
Bây giờ bạn đã tạo và ánh xạ dữ liệu kết cấu của chúng tôi, hãy chuyển sang lấy mẫu kết cấu thưa thớt.

00:09:32.000 --> 00:09:36.000
Lấy mẫu từ một kết cấu thưa thớt không khác gì lấy mẫu từ một kết cấu bình thường.

00:09:36.000 --> 00:09:40.000
Có hành vi được xác định rõ ràng trong trường hợp một phần chưa được ánh xạ được truy cập.

00:09:40.000 --> 00:09:46.000
Lấy mẫu một vùng chưa được ánh xạ trả về một vectơ gồm các số 0 và mọi lần ghi đều bị loại bỏ.

00:09:46.000 --> 00:09:54.000
Ngoài các chức năng lấy mẫu tiêu chuẩn, Metal cung cấp một hàm mẫu thưa thớt có thể được sử dụng trong các bộ đổ bóng để kiểm tra các vùng chưa được ánh xạ.

00:09:54.000 --> 00:10:01.000
Bây giờ bạn đã thấy cách tạo, lập bản đồ và lấy mẫu kết cấu thưa thớt, hãy xem xét một cách triển khai đơn giản.

00:10:01.000 --> 00:10:06.000
Một cách để lấy mẫu hiệu quả các kết cấu thưa thớt là thực hiện lấy mẫu dự phòng.

00:10:06.000 --> 00:10:15.000
Trong bộ đổ bóng của bạn, trước tiên bạn có thể thử tìm nạp texels bằng phương thức sparse_sample và nếu không thành công, bạn có thể quay lại mipmap cấp thấp hơn.

00:10:15.000 --> 00:10:20.000
Bằng cách luôn giữ cho mipmap thấp hơn được tải, bạn được đảm bảo tìm thấy một mẫu hợp lệ.

00:10:20.000 --> 00:10:29.000
Và để hỗ trợ lấy mẫu dự phòng tốt hơn, ngôn ngữ đổ bóng kim loại cũng hỗ trợ một lập luận mới về các phương pháp kết cấu được gọi là kẹp LOD tối thiểu.

00:10:29.000 --> 00:10:34.000
Kẹp LOD tối thiểu cho phép bạn đặt mipmap cao nhất trong chuỗi có thể truy cập được.

00:10:34.000 --> 00:10:40.000
Điều này cho phép bạn đảm bảo một mẫu hợp lệ bằng cách chỉ định mipmap cao nhất mà bạn biết bạn có dữ liệu.

00:10:40.000 --> 00:10:43.000
Hãy xem xét điều đó trong mã.

00:10:43.000 --> 00:10:47.000
Ở đây chúng tôi có một bộ đổ bóng mảnh lấy mẫu từ một kết cấu thưa thớt.

00:10:47.000 --> 00:10:53.000
Bạn bắt đầu lấy mẫu kết cấu thưa thớt của mình bằng cách sử dụng phương thức thưa_mẫu, phương thức này trả về một đối tượng màu thưa thớt.

00:10:53.000 --> 00:10:59.000
Sau đó, bạn có thể gọi phương thức cư trú trên đối tượng được trả về để xác định xem GPU có lấy mẫu dữ liệu được ánh xạ hay không.

00:10:59.000 --> 00:11:03.000
Nếu có, bạn lấy lại giá trị mẫu và trả lại.

00:11:03.000 --> 00:11:10.000
Nếu không, bạn sẽ lấy mẫu lại kết cấu thưa thớt, nhưng lần này bằng kẹp LOD để buộc bộ lấy mẫu bỏ qua các mipmap cao hơn.

00:11:10.000 --> 00:11:18.000
Vì bạn đảm bảo rằng mipmap này và mipmap thấp hơn có dữ liệu, cuộc gọi lấy mẫu thứ hai được thực hiện bằng phương pháp mẫu thông thường.

00:11:18.000 --> 00:11:29.000
Bây giờ bạn đã thấy các chức năng để lập bản đồ và lấy mẫu dữ liệu kết cấu thưa thớt, hãy nói một chút về cách quyết định khi nào nên lập bản đồ hoặc các ô kết cấu thưa thớt miễn phí.

00:11:29.000 --> 00:11:36.000
Các hệ thống phát trực tuyến kết cấu truyền thống thu thập thủ công số liệu thống kê cấp ứng dụng để giúp ưu tiên cư trú kết cấu.

00:11:36.000 --> 00:11:41.000
Những phương pháp này thường thô ở mipmap hoặc độ chi tiết lưới để giúp quản lý chi phí.

00:11:41.000 --> 00:11:46.000
Thay vào đó, kim loại hỗ trợ một giải pháp hạt mịn được gọi là bộ đếm truy cập kết cấu.

00:11:46.000 --> 00:11:53.000
Các bộ đếm này theo dõi chính xác tần suất truy cập các ô thưa thớt bởi GPU với chi phí rất thấp.

00:11:53.000 --> 00:11:56.000
Bộ đếm truy cập kết cấu được truy vấn từ GPU.

00:11:56.000 --> 00:11:59.000
Hãy xem cái này hoạt động như thế nào.

00:11:59.000 --> 00:12:03.000
Ví dụ Metal này sẽ thu thập các bộ đếm truy cập kết cấu từ GPU.

00:12:03.000 --> 00:12:07.000
Bạn bắt đầu bằng cách tạo một bộ đệm để chứa các bộ đếm được lấy mẫu.

00:12:07.000 --> 00:12:16.000
Và sau đó bạn mã hóa một blit để sao chép các bộ đếm từ kết cấu thưa thớt của chúng tôi sang bộ đệm của chúng tôi, chỉ định mức mip, lát cắt và khu vực bạn quan tâm.

00:12:16.000 --> 00:12:25.000
Các kỹ thuật phát trực tuyến kết cấu truyền thống đã phục vụ chúng tôi rất tốt trong những năm qua và với ngân sách bộ nhớ cố định, chúng tôi có thể phát trực tuyến ở mức mip cho các kết cấu mà người dùng nhìn thấy.

00:12:25.000 --> 00:12:33.000
Khi ngân sách kết cấu cạn kiệt, chúng ta không còn có thể phát trực tuyến ở mức mip có độ phân giải cao hơn và chúng ta bắt đầu thấy các kết cấu mờ đồng đều.

00:12:33.000 --> 00:12:37.000
Nhưng với kết cấu thưa thớt, giờ đây bạn có thể sử dụng trí nhớ của mình tốt hơn.

00:12:37.000 --> 00:12:47.000
Bạn có thể lập bản đồ bộ nhớ để nhường chỗ cho các ô kết cấu riêng lẻ mà người dùng nhìn thấy, ở mức chất lượng phù hợp nhất cho từng ô kết cấu trong một mức mip nhất định.

00:12:47.000 --> 00:12:52.000
Điều này cho phép bạn phân phối bộ nhớ kết cấu cho các ô tạo ra tác động trực quan nhất.

00:12:52.000 --> 00:13:06.000
Ngoài ra, tính năng này tiết kiệm băng thông khi phát trực tuyến kết cấu, vì API kết cấu thưa thớt cho phép bạn ánh xạ và hủy ánh xạ các ô riêng lẻ thay vì phải sao chép và sắp xếp lại toàn bộ chuỗi mipmap trong bộ nhớ trong khi phát trực tuyến.

00:13:06.000 --> 00:13:12.000
Đó là nó cho kết cấu thưa thớt, một tối ưu hóa bộ nhớ thực sự quan trọng cũng sẽ cải thiện chất lượng phát trực tuyến kết cấu.

00:13:12.000 --> 00:13:17.000
Bây giờ hãy chuyển sang kỹ thuật tối ưu hóa thời gian chạy được gọi là bản đồ tốc độ rasterization.

00:13:17.000 --> 00:13:29.000
Bản đồ tốc độ Rasterization cho phép bạn sử dụng tốt hơn màn hình Retina bằng cách rasterizing và tô bóng các khu vực hình ảnh quan trọng nhất ở độ phân giải cao nhất, đồng thời giảm chất lượng ở những nơi không được cảm nhận.

00:13:29.000 --> 00:13:42.000
Bản đồ tốc độ Rasterization cho phép bạn rasterize và tô bóng ở nhiều độ phân giải bằng cách xác định cả không gian màn hình và kích thước mục tiêu hiển thị vật lý và ánh xạ không đồng nhất giữa hai không gian, để kiểm soát chất lượng của từng khu vực.

00:13:42.000 --> 00:13:47.000
Độ phân giải vật lý nhỏ hơn không gian màn hình, tiết kiệm băng thông và giảm dung lượng bộ nhớ.

00:13:47.000 --> 00:13:57.000
Và ánh xạ không đồng nhất dẫn đến hình ảnh chất lượng cao hơn so với bản đồ cao cấp đồng nhất thường được sử dụng trong các trò chơi với một phần nhỏ chi phí hiển thị toàn bộ màn hình ở độ phân giải gốc.

00:13:57.000 --> 00:14:01.000
Chúng ta hãy xem xét kỹ hơn cách thức hoạt động của nó.

00:14:01.000 --> 00:14:05.000
Đây là ảnh chụp màn hình của một lớp khuếch tán từ bộ đệm g của trình kết xuất mẫu.

00:14:05.000 --> 00:14:15.000
Kết xuất truyền thống vẽ hình học bằng cách tính toán tọa độ không gian màn hình của mỗi đỉnh, và sau đó rasterizing các nguyên thủy kết quả trong không gian màn hình để tạo ra các mảnh vỡ.

00:14:15.000 --> 00:14:21.000
Các tọa độ không gian màn hình này có ánh xạ 1-1 đến tọa độ của mục tiêu kết xuất vật lý trong quá trình rasterization.

00:14:21.000 --> 00:14:35.000
Với bản đồ tốc độ rasterization, bạn có thể định cấu hình rasterizer để ánh xạ tọa độ không gian màn hình không đồng đều khi tạo các đoạn, do đó giảm số lượng tổng số đoạn được tạo ra và đồng thời hiển thị đến mục tiêu kết xuất nhỏ hơn.

00:14:35.000 --> 00:14:40.000
Trong cả hai hình ảnh, lưới trắng tương ứng với lưới cách đều nhau trong không gian màn hình ảo.

00:14:40.000 --> 00:14:44.000
Nhưng như bạn có thể thấy ở đây, nó được phân bố không đồng đều trong không gian vật lý.

00:14:44.000 --> 00:14:53.000
Trong ví dụ này, chúng tôi đã sử dụng bản đồ tốc độ rasterization để giữ độ phân giải màn hình ở giữa màn hình, nhưng giảm nó về phía các cạnh của màn hình.

00:14:53.000 --> 00:14:57.000
Để thấy điều này rõ ràng hơn, hãy phóng to một trong những ô trung tâm.

00:14:57.000 --> 00:15:03.000
Độ phân giải của ô vật lý này khớp với độ phân giải của cùng một vùng trong bộ đệm g.

00:15:03.000 --> 00:15:11.000
Nhưng khi bạn di chuyển về phía cạnh của màn hình, chất lượng sẽ giảm đi bằng cách giảm hiệu quả không gian vật lý dành riêng cho ô đó.

00:15:11.000 --> 00:15:19.000
Điều này dẫn đến một hình ảnh bị bóp méo trong hình ảnh vật lý của bạn, nhưng chúng tôi sẽ chỉ ra rằng ánh xạ này có thể được đảo ngược để tạo ra một hình ảnh cuối cùng không bị bóp méo.

00:15:19.000 --> 00:15:22.000
Nhưng trước tiên, chúng ta hãy xem cách các ánh xạ được xác định.

00:15:22.000 --> 00:15:28.000
Ánh xạ được định nghĩa là hai hàm 1D trong trục X và Y của không gian màn hình.

00:15:28.000 --> 00:15:35.000
Bạn mô tả các chức năng này trong Metal bằng cách sử dụng một loạt các điểm kiểm soát xác định các yêu cầu chất lượng.

00:15:35.000 --> 00:15:41.000
Trong hình ảnh này, chúng ta có thể thấy tốc độ rasterization hiệu quả trên màn hình, với hai hàm 1D của chúng ta dọc theo trục.

00:15:41.000 --> 00:15:48.000
Mức chất lượng của một có nghĩa là bộ đổ bóng phân đoạn được gọi cho mọi điểm ảnh không gian màn hình dọc theo trục.

00:15:48.000 --> 00:15:55.000
Và mức chất lượng .5 có nghĩa là đối với ít nhất 50 phần trăm các điểm ảnh, một bộ đổ bóng phân đoạn được gọi dọc theo một trục nhất định.

00:15:55.000 --> 00:16:00.000
Mức chất lượng bằng không có nghĩa là mỗi bộ đổ bóng phân đoạn sẽ được gọi ở tốc độ tối thiểu được hỗ trợ bởi Metal.

00:16:00.000 --> 00:16:04.000
Metal sẽ mẫu lại các điểm kiểm soát này để tạo bản đồ tỷ lệ cuối cùng.

00:16:04.000 --> 00:16:11.000
Mặc dù bạn không kiểm soát trực tiếp bản đồ cuối cùng, Metal đảm bảo rằng chất lượng tối thiểu của bạn được giữ nguyên.

00:16:11.000 --> 00:16:13.000
Bây giờ hãy tạo bản đồ này với Metal.

00:16:13.000 --> 00:16:18.000
Đây là mã Kim loại xây dựng bản đồ tỷ lệ rasterization mà bạn vừa thấy.

00:16:18.000 --> 00:16:21.000
Đầu tiên, bạn xác định hàm rasterization.

00:16:21.000 --> 00:16:28.000
Trong ví dụ này, chúng tôi sẽ sử dụng năm giá trị mà chúng tôi đã hiển thị trước đây cho cả trục ngang và dọc của bản đồ của chúng tôi.

00:16:28.000 --> 00:16:33.000
Sau đó, bạn điền vào bộ mô tả lớp để mô tả chất lượng trên bản đồ tỷ lệ rasterization của chúng tôi.

00:16:33.000 --> 00:16:37.000
Sau đó, bạn tạo một cái bằng cách cung cấp các chức năng chất lượng ngang và dọc.

00:16:37.000 --> 00:16:46.000
Với chất lượng của bạn được xác định, bây giờ bạn tạo một bộ mô tả bản đồ tốc độ rasterization Metal từ bộ mô tả lớp và độ phân giải không gian màn hình cuối cùng của chúng tôi.

00:16:46.000 --> 00:16:53.000
Cuối cùng, bạn sử dụng thiết bị Metal của mình để khởi tạo đối tượng bản đồ tốc độ rasterization bằng cách sử dụng bộ mô tả đó.

00:16:53.000 --> 00:16:58.000
Tiếp theo chúng ta cần tạo mục tiêu kết xuất vật lý cho bản đồ này.

00:16:58.000 --> 00:17:06.000
Bởi vì tốc độ bản đồ tỷ lệ rasterization thực tế phụ thuộc vào việc triển khai, trước tiên bạn cần truy vấn kích thước vật lý của tài nguyên từ bản đồ.

00:17:06.000 --> 00:17:15.000
Sau đó, bạn tạo mục tiêu kết xuất vật lý như bình thường: chỉ định các thuộc tính lưu trữ và sử dụng chính xác và khởi tạo kết cấu bằng đối tượng thiết bị Kim loại của bạn.

00:17:15.000 --> 00:17:22.000
Cuối cùng, bạn kết hợp kết cấu đã tạo và bản đồ rasterization để thiết lập đường chuyền kết xuất và kết xuất như bình thường.

00:17:22.000 --> 00:17:26.000
Và với điều đó, bạn đã rasterized bộ đệm g của mình một cách không đồng đều.

00:17:26.000 --> 00:17:29.000
Nhưng còn việc tô bóng bộ đệm g trong các đường chuyền sau thì sao?

00:17:29.000 --> 00:17:40.000
Với đường ống tạo bóng hoãn truyền thống, bạn có thể tiếp tục chiếu sáng với cùng một bản đồ tốc độ rasterization vì hình học ánh sáng của bạn sẽ được rasterized chính xác trong cùng một không gian màn hình với bộ đệm g của bạn.

00:17:40.000 --> 00:17:44.000
Với trình kết xuất hoãn lát gạch, bạn sẽ cần phải làm thêm một chút công việc.

00:17:44.000 --> 00:17:52.000
Nếu bạn chưa quen thuộc với kết xuất hoãn lát gạch, vui lòng xem buổi nói chuyện Kết xuất hiện đại với kim loại của chúng tôi tại WWDC 2019.

00:17:52.000 --> 00:18:01.000
Với gạch bị trì hoãn, không gian vật lý của mục tiêu kết xuất của bạn được chia thành các khối pixel có kích thước bằng nhau và mỗi khối thực hiện loại bỏ và tô bóng gạch nhẹ.

00:18:01.000 --> 00:18:08.000
Trong hình ảnh được trình bày, mã mẫu của chúng tôi hiển thị bản đồ nhiệt cho số lượng đèn trên mỗi khối là 32 x 32 pixel.

00:18:08.000 --> 00:18:16.000
Bởi vì không gian màn hình không còn tương ứng với không gian vật lý, việc tích hợp bản đồ tốc độ rasterization với các trình kết xuất hoãn lát gạch yêu cầu một bước bổ sung.

00:18:16.000 --> 00:18:22.000
Bộ đổ bóng ánh sáng sẽ cần chuyển đổi tọa độ điểm ảnh trong không gian vật lý thành không gian màn hình ảo.

00:18:22.000 --> 00:18:25.000
Đây là ánh xạ ngược được sử dụng trong quá trình rasterization.

00:18:25.000 --> 00:18:29.000
Hãy xem cách bạn có thể thực hiện ánh xạ ngược này trong bộ đổ bóng của mình.

00:18:29.000 --> 00:18:34.000
Trước tiên, bạn phải làm cho các thông số bản đồ tốc độ rasterization có thể truy cập được đối với bộ đổ bóng.

00:18:34.000 --> 00:18:39.000
Để làm điều này, trước tiên bạn tạo một MTLBuffer có thể giữ các tham số.

00:18:39.000 --> 00:18:42.000
Sau đó bạn sao chép dữ liệu tham số vào MTLBuffer.

00:18:42.000 --> 00:18:45.000
Và cuối cùng, liên kết MTLBuffer với shader của bạn.

00:18:45.000 --> 00:18:48.000
Bây giờ bản đồ đã bị ràng buộc, hãy sử dụng nó.

00:18:48.000 --> 00:18:55.000
Trong bộ đổ bóng, bây giờ bạn có quyền truy cập vào đối tượng rasterization_rate_map_data tại điểm liên kết bộ đệm tương ứng.

00:18:55.000 --> 00:18:59.000
Bạn có thể sử dụng đối tượng đó để khởi tạo một đối tượng rasterization_rate_map _decoder.

00:18:59.000 --> 00:19:04.000
Và sau đó sử dụng bộ giải mã để chuyển đổi giữa tọa độ vật lý và tọa độ màn hình.

00:19:04.000 --> 00:19:11.000
Quay trở lại trình kết xuất hoãn lát gạch của chúng tôi, chúng tôi sử dụng bộ giải mã để thực hiện loại bỏ ô trong không gian màn hình ảo.

00:19:11.000 --> 00:19:19.000
Điều chỉnh việc loại bỏ ánh sáng của bạn thành không gian màn hình ảo có nghĩa là các ô của bạn không còn vuông nữa, nhưng bây giờ hãy đi theo đúng khu vực trong không gian màn hình.

00:19:19.000 --> 00:19:23.000
Hãy so sánh bản đồ nhiệt này với kết xuất độ phân giải đầy đủ, đồng đều.

00:19:23.000 --> 00:19:26.000
Và quay lại phiên bản bản đồ tỷ lệ rasterization.

00:19:26.000 --> 00:19:34.000
Như bạn có thể thấy, với bản đồ tốc độ rasterization, chúng tôi đã giảm đáng kể số lượng ô được tô bóng trên màn hình của mình.

00:19:34.000 --> 00:19:41.000
Cuối cùng, hãy xem xét cách các bản đồ tỷ lệ rasterization được chuẩn bị cho việc tổng hợp và trình bày cuối cùng.

00:19:41.000 --> 00:19:51.000
Trước khi hiển thị hình ảnh cuối cùng lên màn hình, bạn cần mở gói nó bằng cách sử dụng đường chuyền toàn màn hình để biến kết cấu không gian vật lý thành bề mặt có độ phân giải cao bằng cách sử dụng ánh xạ đổ bóng vừa được mô tả.

00:19:51.000 --> 00:20:01.000
Như bạn có thể thấy, rất khó để nhận thấy sự đánh đổi chất lượng bất chấp sự sụt giảm mạnh mẽ đã được chọn cho mẫu này.

00:20:01.000 --> 00:20:08.000
Chúng tôi hy vọng các bản đồ tỷ lệ rasterization sẽ được kết hợp với các kỹ thuật khác, chẳng hạn như độ sâu trường ảnh, để che giấu sự đánh đổi chất lượng.

00:20:08.000 --> 00:20:10.000
Đó là nó cho bản đồ tỷ lệ rasterization.

00:20:10.000 --> 00:20:14.000
Hãy chuyển sang khuếch đại đỉnh.

00:20:14.000 --> 00:20:20.000
Bộ khuếch đại đỉnh cho phép bạn giảm xử lý hình học trong các trường hợp kết xuất đa chế độ xem.

00:20:20.000 --> 00:20:27.000
Kết xuất nhiều lớp và đa cổng xem làm giảm số lượng cuộc gọi vẽ cần thiết để nhắm mục tiêu mỗi chế độ xem bằng cách sử dụng instancing.

00:20:27.000 --> 00:20:32.000
Nhưng điều đó không loại bỏ chi phí GPU xử lý từng trường hợp này.

00:20:32.000 --> 00:20:36.000
Nhiều kỹ thuật kết xuất đa lớp và đa khung nhìn chia sẻ hình học giữa các chế độ xem.

00:20:36.000 --> 00:20:41.000
Ví dụ, giữa các tầng của bản đồ bóng tối hoặc các cạnh của bản đồ môi trường.

00:20:41.000 --> 00:20:46.000
Mỗi trường hợp đó thường biến đổi hình học đó theo cách gần như giống nhau.

00:20:46.000 --> 00:20:54.000
Vì vậy, mặc dù vị trí là duy nhất cho mỗi chế độ xem, các thuộc tính như chuẩn, tiếp tuyến và tọa độ kết cấu giống hệt nhau.

00:20:54.000 --> 00:21:01.000
Bộ khuếch đại đỉnh cho phép bạn xử lý các thuộc tính được chia sẻ đó chỉ một lần, tăng hiệu quả của việc tô bóng đỉnh của bạn.

00:21:01.000 --> 00:21:06.000
Hãy xem xét trường hợp sử dụng bản đồ bóng đổ xuống chi tiết hơn.

00:21:06.000 --> 00:21:14.000
Tùy thuộc vào khoảng cách xem, trình kết xuất có thể chia bản đồ bóng của nó thành một, hai hoặc ba hoặc nhiều tầng bóng chồng chéo lên nhau.

00:21:14.000 --> 00:21:21.000
Khi chúng tôi tăng số lượng thác, chúng tôi cũng tăng kích thước của thế giới ảo mà mỗi tầng bao phủ.

00:21:21.000 --> 00:21:28.000
Điều này làm cho các thác lớn hơn, xa hơn tích lũy nhiều hình học hơn trong đó, so với các tầng gần hơn.

00:21:28.000 --> 00:21:34.000
Và với nhiều tầng hơn, số lượng đối tượng hiển thị thành nhiều hơn một tầng tăng lên.

00:21:34.000 --> 00:21:40.000
Bây giờ chúng ta hãy xem xét cách các bản đồ bóng đổ theo tầng được hiển thị theo truyền thống và các chi phí liên quan.

00:21:40.000 --> 00:21:44.000
Trước khi kết xuất nhiều chế độ xem, bạn chỉ cần vẽ vào từng tầng riêng biệt.

00:21:44.000 --> 00:21:48.000
Điều này làm tăng cả GPU và CPU trên cao.

00:21:48.000 --> 00:21:54.000
Mỗi đỉnh phải được tìm nạp và tô bóng nhiều lần, và mỗi đỉnh cũng được xuất ra nhiều lần.

00:21:54.000 --> 00:22:00.000
Kết xuất phiên bản đa chế độ xem sử dụng ID phiên bản để ánh xạ từng nguyên thủy đến chế độ xem đích của nó.

00:22:00.000 --> 00:22:06.000
Nó loại bỏ chi phí CPU của nhiều lần gọi rút thăm, nhưng chi phí GPU vẫn giữ nguyên.

00:22:06.000 --> 00:22:18.000
Sử dụng instancing để kết xuất theo lớp cũng làm phức tạp việc kết xuất hình học thể hiện thực tế, vì ID phiên bản hiện phải mã hóa cả ID phiên bản thực tế và lớp đích.

00:22:18.000 --> 00:22:22.000
Sự khuếch đại đỉnh giúp loại bỏ việc tìm nạp, đổ bóng và đầu ra trùng lặp.

00:22:22.000 --> 00:22:25.000
Nó cũng cung cấp một ID khuếch đại riêng biệt.

00:22:25.000 --> 00:22:29.000
Chúng ta hãy xem xét sự khuếch đại đỉnh đang hoạt động.

00:22:29.000 --> 00:22:33.000
Các hàm đỉnh hiện có có thể dễ dàng thích nghi với khuếch đại đỉnh.

00:22:33.000 --> 00:22:42.000
Trong ví dụ này, chúng ta sẽ tính toán một vị trí duy nhất trên mỗi lần khuếch đại, nhưng chia sẻ tính toán màu sắc trên tất cả các khuếch đại.

00:22:42.000 --> 00:22:46.000
Chúng tôi bắt đầu bằng cách khai báo VertexOutput của mình với hai thuộc tính.

00:22:46.000 --> 00:22:55.000
Trình biên dịch thường có thể suy ra nếu một thuộc tính là duy nhất hoặc được chia sẻ, nhưng đối với các trình đổ bóng phức tạp, bạn cũng có thể rõ ràng về thuộc tính nào được chia sẻ.

00:22:55.000 --> 00:23:02.000
Trình biên dịch sẽ báo cáo lỗi khi các phép tính thuộc tính được chia sẻ phụ thuộc vào ID khuếch đại.

00:23:02.000 --> 00:23:06.000
Tiếp theo chúng tôi khai báo một đối số hàm giữ ID khuếch đại.

00:23:06.000 --> 00:23:11.000
Bất kỳ tính toán nào liên quan đến ID này đều được khuếch đại cho mỗi lần gọi đổ bóng.

00:23:11.000 --> 00:23:16.000
Thuộc tính màu sắc không được liên kết với ID đó nên nó sẽ chỉ được thực thi một lần.

00:23:16.000 --> 00:23:23.000
Nhưng vị trí phụ thuộc vào ID để tra cứu ma trận chiếu chế độ xem chính xác, và do đó toàn bộ biểu thức được khuếch đại.

00:23:23.000 --> 00:23:25.000
Đó là nó cho mã đổ bóng.

00:23:25.000 --> 00:23:29.000
Bây giờ hãy xem cách chúng tôi thiết lập các cuộc gọi rút thăm khuếch đại.

00:23:29.000 --> 00:23:33.000
Hãy bắt đầu bằng cách tạo một đối tượng trạng thái đường ống cho phép khuếch đại.

00:23:33.000 --> 00:23:38.000
Hệ số khuếch đại tối đa được hỗ trợ bởi Metal có thể được truy vấn từ thiết bị.

00:23:38.000 --> 00:23:42.000
Trong trường hợp này, giả sử bạn muốn có hệ số khuếch đại là hai.

00:23:42.000 --> 00:23:46.000
Nếu được hỗ trợ, bạn đặt thành hệ số khuếch đại tối đa cho đường ống.

00:23:46.000 --> 00:23:53.000
Nếu không được hỗ trợ, bạn có thể quay lại chế độ xem đa dạng truyền thống thông qua việc tham gia hoặc dựa vào việc thực hiện nhiều cuộc gọi rút thăm.

00:23:53.000 --> 00:23:56.000
Cuối cùng, bạn tạo ra đường ống.

00:23:56.000 --> 00:24:02.000
Khi đường ống được tạo và giả sử rằng khuếch đại được hỗ trợ, bạn có thể bắt đầu mã hóa các lần rút thăm của mình.

00:24:02.000 --> 00:24:07.000
Vẽ với khuếch đại yêu cầu thiết lập số lượng khuếch đại và liên kết viewMappings.

00:24:07.000 --> 00:24:13.000
viewMappings mô tả cách ánh xạ ID khuếch đại đến lớp đích hoặc khung nhìn.

00:24:13.000 --> 00:24:22.000
Nếu trình đổ bóng đỉnh cũng xuất mục tiêu kết xuất hoặc chỉ mục mảng khung nhìn, chỉ mục đó sẽ đóng vai trò là phần bù cơ sở vào mảng viewMappings.

00:24:22.000 --> 00:24:26.000
Bây giờ bạn có thể thiết lập khuếch đại mong muốn và mã hóa các lần rút thăm.

00:24:26.000 --> 00:24:29.000
Chúng ta hãy xem xét kỹ hơn trình gỡ lỗi khung kim loại.

00:24:29.000 --> 00:24:37.000
Trong kết xuất mẫu này, chúng tôi sử dụng VertexAmplification để khuếch đại tất cả các bản vẽ được kết xuất cho cả tầng 2 và 3.

00:24:37.000 --> 00:24:42.000
Ở đây chúng ta thấy rằng cuộc gọi vẽ này được hiển thị với ViewMapping chỉ định hai mục tiêu kết xuất.

00:24:42.000 --> 00:24:51.000
Lưới được hiển thị đồng thời thành tầng thứ hai được hiển thị ở bên trái và tầng thứ ba, được hiển thị cả ở bên phải và trong trình xem hình học.

00:24:51.000 --> 00:24:53.000
Đó là nó để khuếch đại đỉnh.

00:24:53.000 --> 00:24:59.000
Hãy chuyển sang bộ đệm đối số và cách chúng được mở rộng cho A13.

00:24:59.000 --> 00:25:02.000
Chúng tôi đã giới thiệu bộ đệm đối số với Metal 2.

00:25:02.000 --> 00:25:08.000
Bộ đệm đối số cho phép bạn mã hóa hằng số, kết cấu, bộ lấy mẫu và đối số bộ đệm vào MTLBuffers.

00:25:08.000 --> 00:25:16.000
Bằng cách mã hóa tất cả các đối số vẽ của bạn thành một bộ đệm đối số Kim loại duy nhất, bạn có thể hiển thị các cảnh phức tạp với chi phí CPU tối thiểu.

00:25:16.000 --> 00:25:22.000
Sau khi được mã hóa, bạn có thể sử dụng lại bộ đệm đối số để tránh liên kết tài nguyên dư thừa lặp đi lặp lại.

00:25:22.000 --> 00:25:31.000
Bộ đệm đối số cũng cần thiết để kích hoạt các đường ống do GPU điều khiển, bằng cách cung cấp quyền truy cập vào toàn bộ đối số vẽ của cảnh trên GPU.

00:25:31.000 --> 00:25:38.000
Sau đó, bạn có thể sửa đổi bộ đệm đối số trong các hàm tính toán để tự động định cấu hình cảnh của mình, đúng lúc.

00:25:38.000 --> 00:25:42.000
Bộ đệm đối số cấp 2 tăng cường đáng kể khả năng của bộ đệm đối số.

00:25:42.000 --> 00:25:48.000
Với A13, các hàm Metal của bạn có thể lấy mẫu hoặc ghi vào bất kỳ kết cấu nào trong bộ đệm đối số.

00:25:48.000 --> 00:25:53.000
Bạn cũng có thể truy cập số lượng kết cấu hầu như không giới hạn và nhiều bộ lấy mẫu.

00:25:53.000 --> 00:25:58.000
Và bộ đệm đối số bây giờ cũng có thể tham chiếu đến các bộ đệm đối số khác với nhiều cấp độ gián tiếp.

00:25:58.000 --> 00:26:10.000
Điều này mở ra khả năng mã hóa một bộ đệm đối số duy nhất cho tất cả dữ liệu cảnh của bạn và truy cập nó trong bản vẽ của bạn mà không cần phải lắp ráp bộ đệm đối số trước thời hạn trên GPU hoặc CPU.

00:26:10.000 --> 00:26:11.000
Hãy xem xét một ví dụ.

00:26:11.000 --> 00:26:15.000
Đây là một hệ thống phân cấp mô hình đối tượng cảnh ví dụ.

00:26:15.000 --> 00:26:21.000
Chúng tôi đã đưa ra một ví dụ tương tự tại buổi nói chuyện về Kết xuất Hiện đại với Kim loại của chúng tôi tại WWDC 2019.

00:26:21.000 --> 00:26:25.000
Hệ thống phân cấp mô tả tất cả dữ liệu hình học, vật liệu và dữ liệu mô hình của bạn.

00:26:25.000 --> 00:26:29.000
Với bộ đệm đối số, chúng ta có thể mã hóa trực tiếp mô hình đối tượng này.

00:26:29.000 --> 00:26:33.000
Nhưng với sự hỗ trợ Cấp 2, chúng tôi cũng có thể sử dụng hệ thống phân cấp trực tiếp trong quá trình kết xuất.

00:26:33.000 --> 00:26:36.000
Hãy cùng xem một ví dụ về shader.

00:26:36.000 --> 00:26:45.000
Để bắt đầu, hãy nhớ lại rằng bộ đệm đối số của chúng tôi được khai báo trong ngôn ngữ đổ bóng kim loại dưới dạng cấu trúc của hằng số, kết cấu, bộ lấy mẫu và bộ đệm.

00:26:45.000 --> 00:26:50.000
Những khai báo này phản ánh trực tiếp hệ thống phân cấp đối tượng ví dụ vừa được mô tả.

00:26:50.000 --> 00:26:58.000
Đầu tiên là đại diện vật chất của chúng tôi, và thứ hai là cảnh của chúng tôi tham chiếu đến tập hợp các mắt lưới, vật liệu và mô hình.

00:26:58.000 --> 00:27:03.000
Được rồi, vậy bây giờ chúng ta hãy xem xét một chức năng phân đoạn có thể tô màu trực tiếp bằng cách sử dụng cảnh của chúng ta.

00:27:03.000 --> 00:27:07.000
Tham số hàm đầu tiên là bộ đệm đối số cảnh của chúng tôi.

00:27:07.000 --> 00:27:11.000
Tham số hàm thứ hai là hằng số trên mỗi lần vẽ của chúng tôi.

00:27:11.000 --> 00:27:19.000
Trong ví dụ này, nó mã hóa ID mô hình cho lần rút thăm này, cũng như mức độ chi tiết rời rạc, cả hai đều được chọn trong một đường chuyền tính toán trước đó.

00:27:19.000 --> 00:27:25.000
Sau đó, chúng tôi sử dụng các ID này để lấy tài liệu của mình từ hiện trường bằng cách sử dụng các ID được tính toán trước đó.

00:27:25.000 --> 00:27:32.000
Và chúng tôi tính toán màu phân đoạn bằng cách sử dụng kết cấu, hằng số và bộ lấy mẫu từ bộ đệm đối số lồng nhau.

00:27:32.000 --> 00:27:33.000
Và thế là xong!

00:27:33.000 --> 00:27:39.000
Không còn phải vượt qua tính toán can thiệp để thu thập các tham số vật liệu vào bộ đệm đối số trên mỗi lần vẽ.

00:27:39.000 --> 00:27:43.000
Bộ đổ bóng phân đoạn chỉ sử dụng bộ đệm đối số cảnh trực tiếp.

00:27:43.000 --> 00:27:48.000
Tuy nhiên, trước khi chúng ta tiếp tục, tôi muốn làm nổi bật sự hỗ trợ công cụ mạnh mẽ cho bộ đệm đối số.

00:27:48.000 --> 00:27:55.000
Với bộ đệm đối số và đường ống điều khiển GPU, thiết lập cảnh của bạn chuyển sang GPU và bất kỳ việc gỡ lỗi nào cũng vậy.

00:27:55.000 --> 00:28:03.000
Trình gỡ lỗi khung kim loại cho phép bạn dễ dàng gỡ lỗi và kiểm tra cả bộ đệm đối số và bộ đổ bóng sử dụng chúng.

00:28:03.000 --> 00:28:12.000
Bạn có thể sử dụng trình xem bộ đệm để kiểm tra tất cả các tài nguyên trong bộ đệm đối số của mình và nhanh chóng chuyển đến các tài nguyên này để kiểm tra thêm.

00:28:12.000 --> 00:28:19.000
Bạn cũng có thể sử dụng trình gỡ lỗi đổ bóng để hiểu cách trình đổ bóng của bạn đang truy cập hoặc xây dựng bộ đệm đối số.

00:28:19.000 --> 00:28:26.000
Điều này đặc biệt quan trọng khi tính toán các chỉ số bộ đệm đối số hoặc sửa đổi bộ đệm đối số trên GPU.

00:28:26.000 --> 00:28:29.000
Đó là nó cho bộ đệm đối số Cấp 2.

00:28:29.000 --> 00:28:34.000
Bây giờ hãy chuyển sang một lớp kỹ thuật tối ưu hóa đổ bóng mới.

00:28:34.000 --> 00:28:39.000
Các chức năng nhóm SIMD là một công cụ mạnh mẽ để tối ưu hóa các chức năng tính toán và đồ họa.

00:28:39.000 --> 00:28:46.000
Chúng cho phép khối lượng công việc GPU chia sẻ dữ liệu và kiểm soát thông tin luồng bằng cách tận dụng kiến trúc của GPU.

00:28:46.000 --> 00:28:52.000
Hãy giải nén điều đó bằng cách nhanh chóng xem lại mô hình thực thi SIMD trong Metal.

00:28:52.000 --> 00:29:00.000
Metal luôn tổ chức các luồng thành các nhóm SIMD để khai thác Hướng dẫn duy nhất, nhiều bản chất dữ liệu của GPU.

00:29:00.000 --> 00:29:09.000
Bạn có thể đã tận dụng các nhóm SIMD trong các chức năng tính toán Metal để giảm chi phí đồng bộ hóa toàn bộ nhóm luồng bằng cách sử dụng các rào cản nhóm SIMD thay thế.

00:29:09.000 --> 00:29:14.000
Các luồng của một nhóm SIMD thực thi theo từng bước khóa, vì vậy không cần các rào cản thực thi.

00:29:14.000 --> 00:29:19.000
Do đó, rào cản nhóm SIMD chỉ đồng bộ hóa các hoạt động của bộ nhớ.

00:29:19.000 --> 00:29:32.000
Các chức năng của nhóm SIMD khai thác việc thực thi bước khóa này để chia sẻ dữ liệu giữa các luồng của nó bằng cách sử dụng thanh ghi thay vì bộ nhớ nhóm luồng và có thể cải thiện đáng kể hiệu suất khi bộ nhớ nhóm luồng bị ràng buộc.

00:29:32.000 --> 00:29:36.000
Chúng cũng có sẵn cho cả chức năng tính toán và kết xuất.

00:29:36.000 --> 00:29:40.000
Và như chúng ta sẽ thấy một chút, điều này cho phép một kỹ thuật tối ưu hóa kết xuất rất thú vị.

00:29:40.000 --> 00:29:46.000
Trước tiên hãy bắt đầu bằng cách xây dựng một trực giác tốt hơn để thực thi SIMD với một ví dụ.

00:29:46.000 --> 00:29:52.000
Ở phía bên trái, chúng tôi đại diện cho một nhóm SIMD là 32 làn xe bắt đầu bằng Làn đường 0.

00:29:52.000 --> 00:29:54.000
Làn đường là một luồng duy nhất trong nhóm SIMD.

00:29:54.000 --> 00:29:57.000
Bây giờ hãy làm cho nhóm SIMD này thực hiện một số công việc.

00:29:57.000 --> 00:30:04.000
Đầu tiên chúng ta có tất cả các làn đường lập chỉ mục một mảng, A, theo laneID của nó và lưu trữ kết quả trong một biến X.

00:30:04.000 --> 00:30:07.000
Lưu ý cách mỗi làn đường có giá trị X riêng.

00:30:07.000 --> 00:30:17.000
Trong mô hình thực thi này, hướng dẫn tải dữ liệu từ A chỉ được tìm nạp một lần và được thực thi đồng thời bởi 32 luồng có chỉ mục riêng.

00:30:17.000 --> 00:30:23.000
Bây giờ chúng ta đọc một mảng thứ hai, B, được lập chỉ mục bởi laneID và lưu trữ kết quả trong Y.

00:30:23.000 --> 00:30:28.000
Cuối cùng chúng tôi lưu trữ kết quả nhân X và Y trong mảng thứ ba, C.

00:30:28.000 --> 00:30:35.000
Vì lệnh được thực thi chỉ được tìm nạp một lần cho toàn bộ nhóm, tất cả các luồng nhóm SIMD thực thi theo bước khóa.

00:30:35.000 --> 00:30:43.000
Các chức năng của nhóm SIMD cho phép mỗi luồng trong nhóm kiểm tra các giá trị đăng ký của toàn bộ nhóm SIMD với chi phí tối thiểu.

00:30:43.000 --> 00:30:47.000
Khả năng này cho phép một số chức năng thú vị.

00:30:47.000 --> 00:30:52.000
Đầu tiên hãy giới thiệu simd_max và áp dụng nó cho biến Y.

00:30:52.000 --> 00:30:58.000
Mỗi luồng nhận được một giá trị Z với giá trị lớn nhất từ Y, như được thấy bởi bất kỳ luồng nào trong nhóm SIMD.

00:30:58.000 --> 00:31:01.000
Tiếp theo chúng tôi đã phát sóng và áp dụng nó cho X.

00:31:01.000 --> 00:31:08.000
Trong ví dụ này, chúng tôi phát sóng giá trị của Làn đường 0 cho tất cả các làn đường khác trong một thao tác duy nhất.

00:31:08.000 --> 00:31:17.000
Metal cho A13 hỗ trợ nhiều chức năng SIMD hoạt động tương tự khác như xáo trộn, uốn và xoay trên tất cả các làn đường.

00:31:17.000 --> 00:31:25.000
Đối với ví dụ cuối cùng của chúng tôi, chúng tôi sẽ xem xét simd_all, cho mỗi làn đường biết liệu một biểu thức có đánh giá giống nhau cho tất cả các làn đường hay không.

00:31:25.000 --> 00:31:32.000
Trong ví dụ này, biến Z thực sự là chín cho tất cả các làn đường, và do đó chúng tôi trả về true.

00:31:32.000 --> 00:31:37.000
Tương tự như vậy, simd_any cho biết liệu một biểu thức có đánh giá là đúng với bất kỳ làn đường nào hay không.

00:31:37.000 --> 00:31:45.000
Bạn có thể sử dụng simd_all để giảm sự phân kỳ trong bộ đổ bóng của mình bằng cách chọn đi theo con đường tối ưu hơn khi tất cả các luồng đều có cùng nhu cầu.

00:31:45.000 --> 00:31:47.000
Hãy xem xét một ví dụ.

00:31:47.000 --> 00:31:53.000
Đây là trình đổ bóng phân đoạn của chúng tôi từ trước đó với một số tối ưu hóa sử dụng các chức năng của nhóm SIMD.

00:31:53.000 --> 00:32:00.000
Tóm lại, hàm này lấy làm đầu vào cảnh được mã hóa dưới dạng bộ đệm đối số, đồng phục và đỉnh stage_in.

00:32:00.000 --> 00:32:10.000
Thông thường, các chức năng chiếu sáng đánh giá các thành phần khác nhau của màu cuối cùng khác nhau đối với các mảnh trong suốt và do đó yêu cầu luồng điều khiển động tại các điểm khác nhau.

00:32:10.000 --> 00:32:22.000
Bây giờ, thay vì đánh giá độ mờ đục cho mọi đoạn, ở đây chúng tôi sử dụng simd_all để kiểm tra động xem tất cả các luồng trong nhóm SIMD có đang tính toán ánh sáng cho các đoạn mờ đục hay không.

00:32:22.000 --> 00:32:27.000
Nếu có, chúng ta sẽ đi theo một con đường tối ưu chỉ giả định các vật thể mờ đục.

00:32:27.000 --> 00:32:33.000
Và nếu không, chúng ta quay trở lại con đường trước đó có thể thắp sáng cả những mảnh vỡ mờ đục và trong suốt.

00:32:33.000 --> 00:32:37.000
Đó là nó cho các chức năng nhóm SIMD trên A13.

00:32:37.000 --> 00:32:44.000
Hãy chuyển số và xem xét một số bổ sung thú vị cho ASTC trên A13.

00:32:44.000 --> 00:32:55.000
Như đã đề cập trước đó trong video, GPU A13 tăng gấp đôi tốc độ hoạt động dấu phẩy động 16 bit và bổ sung hỗ trợ cho các số nhỏ 16 bit để xử lý xử lý HDR tốt hơn.

00:32:55.000 --> 00:33:03.000
Các ứng dụng tận dụng những cải tiến này mà không cần bất kỳ sửa đổi nào; Xử lý HDR trên GPU chỉ trở nên nhanh hơn và chính xác hơn.

00:33:03.000 --> 00:33:14.000
Apple Family 6 cũng bổ sung hỗ trợ cho một bộ định dạng pixel mới hỗ trợ lưu trữ và lấy mẫu dữ liệu HDR hiệu quả được gọi là ASTC HDR.

00:33:14.000 --> 00:33:24.000
ASTC là một công nghệ nén kết cấu được hỗ trợ trên nhiều nền tảng, cung cấp chất lượng hình ảnh kết cấu cao ở một phần nhỏ băng thông và bộ nhớ.

00:33:24.000 --> 00:33:28.000
Nó làm như vậy bằng cách hỗ trợ nhiều tốc độ bit và định dạng đầu vào.

00:33:28.000 --> 00:33:37.000
Cấu hình dải động thấp ASTC đã được hỗ trợ kể từ Apple GPU Family 2 và thích hợp để nén các giá trị trong phạm vi từ 0 đến một.

00:33:37.000 --> 00:33:44.000
Nếu ứng dụng của bạn chưa sử dụng ASTC để tiết kiệm bộ nhớ và băng thông, chúng tôi thực sự khuyến khích bạn làm như vậy.

00:33:44.000 --> 00:33:50.000
Cấu hình dải động cao là cần thiết để mã hóa các giá trị độ sáng lớn hơn được tìm thấy trong hình ảnh HDR.

00:33:50.000 --> 00:33:59.000
Không có ASTC HDR, những hình ảnh như vậy thường được lưu trữ ở định dạng pixel dấu phẩy động 16 bit với chi phí bộ nhớ cao hơn nhiều.

00:33:59.000 --> 00:34:03.000
Vậy ASTC HDR có thể tiết kiệm được bao nhiêu dung lượng lưu trữ?

00:34:03.000 --> 00:34:04.000
Rất nhiều.

00:34:04.000 --> 00:34:05.000
Hãy xem xét một ví dụ.

00:34:05.000 --> 00:34:16.000
Các trò chơi HDR thường sử dụng kết cấu bản đồ khối lập phương có độ phân giải thấp để thể hiện các bản đồ môi trường dải động cao để chiếu sáng cảnh của chúng và thường đặt nhiều đầu dò như vậy trên khắp thế giới hoặc cấp độ trò chơi.

00:34:16.000 --> 00:34:26.000
Nếu không có ASTC HDR, mỗi đầu dò có thể tiêu thụ một lượng bộ nhớ đáng kể và tất cả các đầu dò như vậy có thể dễ dàng tiêu thụ một phần lớn ngân sách bộ nhớ trò chơi của bạn.

00:34:26.000 --> 00:34:32.000
Trong ví dụ này, chỉ riêng bản đồ khối thăm dò 256 x 256 tiêu thụ 3MB.

00:34:32.000 --> 00:34:37.000
Với ASTC HDR, cùng một đầu dò sẽ tiêu thụ ít bộ nhớ hơn nhiều lần.

00:34:37.000 --> 00:34:41.000
Bạn thậm chí có thể thay đổi tốc độ bit để thực sự giảm dấu chân.

00:34:41.000 --> 00:34:46.000
Tạo ra một kết cấu HDR đơn giản như một kết cấu tương đương LDR.

00:34:46.000 --> 00:34:51.000
Trong ví dụ này, chúng tôi đang tạo ra một kết cấu ASTC LDR bốn x bốn.

00:34:51.000 --> 00:35:00.000
Có định dạng HDR phù hợp cho mọi định dạng LDR nên việc chuyển đổi định dạng này thành kết cấu HDR chỉ yêu cầu thay đổi định dạng pixel.

00:35:00.000 --> 00:35:04.000
Được rồi, điều đó kết thúc các tính năng Metal mới cho GPU A13.

00:35:04.000 --> 00:35:07.000
Hãy tóm tắt lại những gì chúng ta đã học được.

00:35:07.000 --> 00:35:11.000
Nó cho phép phát trực tuyến kết cấu chất lượng cao hơn với kết cấu thưa thớt.

00:35:11.000 --> 00:35:20.000
Nó cho phép bạn tập trung đổ bóng đắt tiền vào nơi cần thiết với bản đồ tốc độ rasterization và loại bỏ xử lý đỉnh dư thừa bằng khuếch đại đỉnh.

00:35:20.000 --> 00:35:29.000
Nó cũng cho phép các đường ống dựa trên GPU linh hoạt hơn với bộ đệm đối số Cấp 2 và chia sẻ nhóm SIMD với hướng dẫn xáo trộn và bỏ phiếu.

00:35:29.000 --> 00:35:35.000
Và cuối cùng, Metal bây giờ cho phép bạn lưu bộ nhớ trong các đường ống HDR với ASTC.

00:35:35.000 --> 00:35:44.000
Để biết thêm thông tin về Metal, GPU A13 và để tìm mã mẫu mới nhất của chúng tôi, vui lòng truy cập developer.apple.com.

00:35:44.000 --> 23:59:59.000
Cảm ơn bạn.

