WEBVTT

00:00:00.000 --> 00:00:06.000
Xin chào, tên tôi là Ari, và tôi rất hào hứng được nói về cách di chuyển ý định tùy chỉnh sang App Intents.

00:00:06.000 --> 00:00:18.000
Trong video này, tôi sẽ đề cập đến lý do tại sao bạn nên áp dụng khung Ý định ứng dụng mới; cách di chuyển hoạt động, bao gồm khả năng tương thích ngược; và cách thực sự chuyển đổi sang Ý định ứng dụng.

00:00:18.000 --> 00:00:24.000
Đầu tiên, hãy đề cập đến lý do tại sao bạn nên áp dụng App Intents và nó khác với các khuôn khổ trước đó như thế nào.

00:00:24.000 --> 00:00:38.000
Chúng tôi đã giới thiệu khung SiriKit Intents vào năm 2016, đi kèm với một tập hợp các ý định hệ thống có mục đích cung cấp trải nghiệm người dùng hoàn chỉnh cho các trường hợp sử dụng phổ biến như nhắn tin, tập luyện, cuộc gọi điện thoại và hơn thế nữa.

00:00:38.000 --> 00:00:48.000
Tiếp theo, chúng tôi đã giới thiệu ý định tùy chỉnh cho phép bạn xác định ý định của riêng mình cho bất kỳ trường hợp sử dụng nào, đưa chức năng ứng dụng của bạn lên Siri, phím tắt và đề xuất.

00:00:48.000 --> 00:00:54.000
Và chúng tôi đã thêm WidgetKit sử dụng ý định tùy chỉnh để cấu hình và dự đoán tiện ích.

00:00:54.000 --> 00:01:03.000
Tại WWDC22, chúng tôi đã giới thiệu App Intents, một khung Swift-native mới để cung cấp ý định từ ứng dụng của bạn cho hệ thống.

00:01:03.000 --> 00:01:09.000
App Intents là một khuôn khổ tuyệt vời để áp dụng, bởi vì nó hiện đại, mạnh mẽ và dễ dàng cho người dùng.

00:01:09.000 --> 00:01:14.000
Nó hiện đại vì nó được thiết kế nguyên bản cho Swift.

00:01:14.000 --> 00:01:20.000
Nhờ các tính năng ngôn ngữ mới nhất, bạn có thể viết ít mã hơn đáng kể để hỗ trợ cùng một chức năng.

00:01:20.000 --> 00:01:26.000
Chúng tôi cũng đã loại bỏ nhu cầu duy trì các tệp định nghĩa ý định và sử dụng việc tạo mã.

00:01:26.000 --> 00:01:30.000
Và bây giờ bạn có thể cung cấp các đoạn trích dưới dạng chế độ xem SwiftUI nhẹ.

00:01:30.000 --> 00:01:35.000
Nó mạnh mẽ vì các thực thể và truy vấn cho phép các trường hợp sử dụng sâu hơn.

00:01:35.000 --> 00:01:41.000
Bạn có thể chạy App Intents trực tiếp trong quy trình ứng dụng của mình mà không cần cung cấp tiện ích mở rộng.

00:01:41.000 --> 00:01:46.000
Và có những cơ hội mới để tùy chỉnh trải nghiệm người dùng khi mọi người thiết lập và chạy ý định của bạn.

00:01:46.000 --> 00:01:49.000
Nó cũng dễ dàng cho mọi người sử dụng.

00:01:49.000 --> 00:01:56.000
Ý định có thể dễ dàng hiển thị dưới dạng Phím tắt ứng dụng có thể sử dụng ngay lập tức mà không cần thiết lập.

00:01:56.000 --> 00:02:05.000
Thêm vào đó, có những cách mới để mọi người khám phá các phím tắt của bạn vì chúng sẽ được hiển thị ở đầu Spotlight và trong các mẹo Siri mà bạn có thể đưa vào ứng dụng của mình.

00:02:05.000 --> 00:02:13.000
Để có được tất cả các lợi ích của khuôn khổ mới, bạn sẽ cần nâng cấp bất kỳ ý định tùy chỉnh nào mà bạn đã xây dựng cho Siri và các phím tắt cho App Intents.

00:02:13.000 --> 00:02:16.000
Ý định của SiriKit vẫn được hỗ trợ đầy đủ.

00:02:16.000 --> 00:02:25.000
Vì vậy, nếu bạn đang xây dựng cho các miền Siri như nhắn tin hoặc phương tiện hoặc nếu bạn đang sử dụng ý định với WidgetKit, bạn nên để nguyên chúng.

00:02:25.000 --> 00:02:32.000
Để tìm hiểu thêm về khung Ý định ứng dụng, hãy xem phiên của chúng tôi từ WWDC22, "Đi sâu vào ý định ứng dụng."

00:02:32.000 --> 00:02:43.000
Và để tìm hiểu thêm về Phím tắt ứng dụng, giúp mọi người dễ dàng sử dụng chức năng ứng dụng của bạn từ Siri và Spotlight, hãy xem "Phím tắt ứng dụng triển khai với ý định ứng dụng".

00:02:43.000 --> 00:02:45.000
Tiếp theo, hãy đề cập đến việc di chuyển.

00:02:45.000 --> 00:02:52.000
Với việc di chuyển, bạn có thể chuyển đổi các định nghĩa ý định hiện có của mình thành Ý định ứng dụng chỉ bằng một cú nhấp chuột trong Xcode.

00:02:52.000 --> 00:02:57.000
Bạn có thể hỗ trợ cả iOS 15 và iOS 16 với cùng một ứng dụng nhị phân.

00:02:57.000 --> 00:03:03.000
Và bạn có thể kích hoạt các phím tắt hiện có của mọi người để tiếp tục làm việc với Ý định ứng dụng mới của bạn.

00:03:03.000 --> 00:03:12.000
Để chuyển đổi định nghĩa ý định của bạn thành Ý định ứng dụng, tất cả những gì bạn phải làm là điều hướng đến tệp định nghĩa ý định của mình và nhấn nút Chuyển đổi thành Ý định ứng dụng.

00:03:12.000 --> 00:03:17.000
Xcode sẽ tạo ra mã App Intents tương đương với định nghĩa ý định cũ của bạn.

00:03:17.000 --> 00:03:21.000
Sau đó, bạn có thể điền mã bằng cách cấu trúc lại mã xử lý nội dung cũ của mình.

00:03:21.000 --> 00:03:25.000
Chúng ta sẽ nói về điều này sâu hơn trong phần tiếp theo.

00:03:25.000 --> 00:03:34.000
Để mọi người có trải nghiệm liền mạch khi ứng dụng của bạn nâng cấp lên Ý định ứng dụng, hệ thống sẽ tự động xử lý việc lập bản đồ từ ý định cũ của bạn sang ý định mới.

00:03:34.000 --> 00:03:36.000
Hãy nói về cách nó hoạt động.

00:03:36.000 --> 00:03:45.000
Chỉ bằng cách áp dụng giao thức CustomIntentMigratedAppIntent, hệ thống sẽ có đủ thông tin để biết cách dịch giữa ý định cũ và mới.

00:03:45.000 --> 00:03:54.000
Khi bạn áp dụng giao thức này, bạn cung cấp thuộc tính tên lớp ý định, đó là tên lớp đã được sử dụng cho ý định tùy chỉnh cũ của bạn.

00:03:54.000 --> 00:03:57.000
Trong hầu hết các trường hợp, bạn không cần phải tự cung cấp cái này.

00:03:57.000 --> 00:04:03.000
Khi bạn sử dụng nút Chuyển đổi thành Ý định Ứng dụng, mã kết quả đã áp dụng giao thức này.

00:04:03.000 --> 00:04:10.000
Do khả năng di chuyển của App Intent, bạn không cần phải đợi cho đến khi ứng dụng của mình nhắm mục tiêu iOS 16 để nâng cấp lên App Intents.

00:04:10.000 --> 00:04:16.000
Trên thực tế, bạn có thể dễ dàng hỗ trợ cả hệ điều hành mới hơn và cũ hơn với cùng một ứng dụng nhị phân.

00:04:16.000 --> 00:04:21.000
Để làm điều này, hãy bao gồm cả trình xử lý ý định kế thừa và Ý định ứng dụng của bạn trong ứng dụng của bạn.

00:04:21.000 --> 00:04:27.000
Để tối đa hóa việc chia sẻ mã, hãy tính đến cả hai bộ xử lý ý định so với một tập hợp logic kinh doanh chung.

00:04:27.000 --> 00:04:36.000
Giả sử bạn áp dụng giao thức App Intent đã di chuyển, các phím tắt sẽ tự động sao chép ý định của bạn khi bạn bao gồm cả hai bộ trong ứng dụng của mình.

00:04:36.000 --> 00:04:47.000
Vì vậy, trên iOS 15 trở về trước, ứng dụng Phím tắt sẽ chỉ hiển thị triển khai ý định kế thừa; và trên iOS 16 trở lên, nó sẽ chỉ hiển thị triển khai của App Intent.

00:04:47.000 --> 00:04:56.000
Khi bạn chuyển mục tiêu triển khai tối thiểu của mình sang iOS 16 hoặc mới hơn, bạn có thể xóa một cách an toàn các trình xử lý và định nghĩa ý định kế thừa cho các ý định mà bạn đã di chuyển.

00:04:56.000 --> 00:04:59.000
Chúng không còn cần thiết nữa.

00:04:59.000 --> 00:05:09.000
Một điều cần suy nghĩ khi di chuyển là mọi người có các phím tắt hiện có dựa trên ý định cũ của bạn, mà họ có thể đã thực hiện trong ứng dụng Phím tắt hoặc được thêm vào bằng cách sử dụng nút Thêm vào Siri trong ứng dụng của bạn.

00:05:09.000 --> 00:05:17.000
Tin tốt là các phím tắt đó sẽ tiếp tục hoạt động với Ý định ứng dụng mới của bạn miễn là chúng áp dụng giao thức Ý định ứng dụng đã di chuyển.

00:05:17.000 --> 00:05:24.000
Các phím tắt của mọi người không bị ghi đè để sử dụng Ý định ứng dụng mới; họ tự động sử dụng một định dạng chung hoạt động cho cả ý định mới và cũ.

00:05:24.000 --> 00:05:31.000
Để điều này hoạt động, các lược đồ của các ý định kế thừa và Ý định ứng dụng phải tương thích.

00:05:31.000 --> 00:05:39.000
Để tương thích, các thông số của ý định tùy chỉnh và Ý định ứng dụng phải có cùng tên và các loại tương đương.

00:05:39.000 --> 00:05:43.000
Có một số thay đổi mà bạn có thể thực hiện mà không phá vỡ khả năng tương thích lược đồ.

00:05:43.000 --> 00:05:49.000
Cụ thể, bạn có thể thêm hoặc xóa các tham số hoặc làm cho các tham số hiện có không tùy chọn.

00:05:49.000 --> 00:05:56.000
Để kiểm tra khả năng tương thích của lược đồ trong Xcode, hãy kiểm tra tệp định nghĩa ý định cũ nơi có danh sách các tham số.

00:05:56.000 --> 00:05:59.000
Mỗi tham số có một tên và một loại.

00:05:59.000 --> 00:06:03.000
Trong ngăn thanh tra, cũng có một trường cho tên lớp của ý định.

00:06:03.000 --> 00:06:13.000
Khi làm việc trên mã App Intents của bạn, hãy đảm bảo tên lớp ý định khớp với những gì có trong tệp định nghĩa ý định, để hệ thống có thể xem xét ý định mới tương đương với ý định cũ.

00:06:13.000 --> 00:06:19.000
Và đảm bảo rằng các tên và loại tham số trong mã App Intents vẫn tương thích.

00:06:19.000 --> 00:06:24.000
Một lần nữa, nút Chuyển đổi thành Ý định Ứng dụng trong Xcode sẽ tự động đảm bảo khả năng tương thích với lược đồ.

00:06:24.000 --> 00:06:29.000
Vì vậy, nếu bạn sử dụng công cụ và không thực hiện bất kỳ thay đổi nào, bạn sẽ ở trong tình trạng tốt.

00:06:29.000 --> 00:06:34.000
Tiếp theo, hãy nói về cách thực sự chuyển đổi ý định hiện tại của bạn thành Ý định ứng dụng.

00:06:34.000 --> 00:06:37.000
Có hai bước để di chuyển một ý định.

00:06:37.000 --> 00:06:43.000
Bước một là di chuyển tệp định nghĩa ý định và bước hai là di chuyển mã của bạn.

00:06:43.000 --> 00:06:45.000
Hãy bắt đầu với định nghĩa ý định.

00:06:45.000 --> 00:06:51.000
Tôi là một fan hâm mộ lớn của súp, và chúng tôi có một ứng dụng ví dụ gọi là Soup Chef cho phép mọi người đặt hàng súp.

00:06:51.000 --> 00:06:59.000
Nó có mục đích đặt hàng với các thông số để đặt món súp nào và bao nhiêu, thêm lớp phủ nào và địa điểm nhận hoặc giao hàng.

00:06:59.000 --> 00:07:07.000
Tôi đã sẵn sàng chuyển đổi cái này thành App Intents, vì vậy tôi sẽ điều hướng đến tệp định nghĩa ý định trong Xcode và nhấn nút chuyển đổi.

00:07:07.000 --> 00:07:11.000
Tiếp theo, tôi chọn ý định chuyển đổi - chỉ là ý định trong trường hợp này.

00:07:11.000 --> 00:07:16.000
Sau đó, tôi sẽ chọn nơi lưu mã ý định mới của mình và mục tiêu nào để đưa nó vào.

00:07:16.000 --> 00:07:21.000
Đó có thể là mục tiêu ứng dụng của tôi hoặc mục tiêu mở rộng App Intents nếu tôi đã thêm một mục tiêu.

00:07:21.000 --> 00:07:25.000
Trong trường hợp này, tôi sẽ kiểm tra mục tiêu ứng dụng và cả mục tiêu đồng hồ nữa.

00:07:25.000 --> 00:07:28.000
Ý định ứng dụng không thể được thêm vào các mục tiêu khung.

00:07:28.000 --> 00:07:32.000
Tiếp theo, tôi sẽ xem mã App Intents mà Xcode đã tạo.

00:07:32.000 --> 00:07:40.000
Nó được chia nhỏ trên một vài tệp đại diện cho tất cả các loại ý định, liệt kê và tùy chỉnh được bao gồm trong tệp định nghĩa ý định.

00:07:40.000 --> 00:07:46.000
Tôi muốn kêu gọi sự chú ý đến một vài lĩnh vực cụ thể trong định nghĩa ý định cũ của tôi đã được di chuyển.

00:07:46.000 --> 00:07:51.000
Trong mã mới, có một cấu trúc orderSoup phù hợp với giao thức App Intent.

00:07:51.000 --> 00:07:56.000
Lưu ý rằng cấu trúc này được đánh dấu là có sẵn trong iOS 16 trở lên.

00:07:56.000 --> 00:08:04.000
Bạn sẽ cần áp dụng chú thích đó cho tất cả mã sử dụng khung App Intents nếu bạn đang triển khai ứng dụng của mình sớm hơn iOS 16.

00:08:04.000 --> 00:08:12.000
Mỗi tham số trong tệp định nghĩa ý định của tôi, cùng với siêu dữ liệu của nó, đã được chuyển sang khai báo @Parameter trong cấu trúc Ý định ứng dụng.

00:08:12.000 --> 00:08:18.000
Tất cả các bản tóm tắt tham số ứng dụng Phím tắt đã được chuyển sang khai báo Tóm tắt tham số này.

00:08:18.000 --> 00:08:26.000
Những gì từng được biểu diễn dưới dạng các mối quan hệ tham số giờ đây có thể được biểu diễn bằng cách sử dụng các câu lệnh Switch, Case hoặc When trong ParameterSummary.

00:08:26.000 --> 00:08:33.000
Các loại tùy chỉnh Soup và Toppings của tôi hiện là các thực thể ứng dụng, bao gồm một số việc cần làm mà tôi sẽ cần điền sau.

00:08:33.000 --> 00:08:36.000
OrderDetails hiện là một thực thể ứng dụng tạm thời.

00:08:36.000 --> 00:08:42.000
Nó được coi là thoáng qua vì nó không có mã định danh duy nhất có thể được sử dụng để tra cứu nó sau này.

00:08:42.000 --> 00:08:46.000
Và enum tùy chỉnh OrderType của tôi bây giờ là một enum ứng dụng.

00:08:46.000 --> 00:08:52.000
Các tên có thể đọc được của con người đã được chuyển sang các biểu diễn hiển thị trường hợp.

00:08:52.000 --> 00:08:59.000
Cuối cùng, tất cả các hộp thoại trong phản hồi ý định đã được chuyển sang tiện ích mở rộng trên IntentDialog.

00:08:59.000 --> 00:09:02.000
Những hộp thoại này có thể được sử dụng cho phương pháp thực hiện của tôi.

00:09:02.000 --> 00:09:13.000
Trình di chuyển có thể tạo ra nhiều chuỗi hơn mức cần thiết, vì vậy nếu bạn thấy những chuỗi không thực sự được sử dụng trong trình xử lý ý định cũ như, "Chỉ để xác nhận, bạn muốn \ (súp)?," vui lòng xóa chúng.

00:09:13.000 --> 00:09:18.000
Bây giờ chúng tôi đã di chuyển định nghĩa ý định của mình, hãy tiếp tục và di chuyển mã xử lý ý định của chúng tôi.

00:09:18.000 --> 00:09:26.000
Lưu ý rằng App Intent được tạo tự động có trình giữ chỗ cho phương thức perform() với lưu ý phải làm rằng nó cần được điền vào.

00:09:26.000 --> 00:09:28.000
Hãy xem làm thế nào để làm điều đó.

00:09:28.000 --> 00:09:34.000
Trong khuôn khổ cũ, bạn đã cung cấp một tệp định nghĩa ý định và một bộ mã xử lý ý định.

00:09:34.000 --> 00:09:38.000
Trong khuôn khổ mới, mọi thứ đều được thể hiện bằng mã.

00:09:38.000 --> 00:09:42.000
Các tham số trong định nghĩa ý định cũ của bạn đã được chuyển sang mã mới.

00:09:42.000 --> 00:09:51.000
Các phương thức giải quyết, xác nhận và xử lý trong mã cũ của bạn sẽ cần được kết hợp thành một phương thức thực hiện duy nhất được gọi khi ý định của bạn được chạy.

00:09:51.000 --> 00:09:57.000
Và các loại tùy chỉnh và các tùy chọn động sẽ cần được cấu trúc lại thành các thực thể và truy vấn.

00:09:57.000 --> 00:10:03.000
Vì vậy, chúng ta hãy xem cách di chuyển từng giai đoạn xử lý ý định, bắt đầu với giải quyết.

00:10:03.000 --> 00:10:10.000
Trong giai đoạn giải quyết, trình xử lý ý định của bạn xác thực từng tham số trong ý định của bạn và nhắc người dùng nhập giá trị nếu cần.

00:10:10.000 --> 00:10:18.000
Khi di chuyển các phương pháp giải quyết, bạn nên tận dụng hành vi giải quyết tự động mới của App Intents nếu có thể.

00:10:18.000 --> 00:10:22.000
Nếu không, bạn nên tái cấu trúc logic phân giải của mình thành phương pháp thực hiện.

00:10:22.000 --> 00:10:25.000
Hãy xem xét một số ví dụ.

00:10:25.000 --> 00:10:28.000
Đây là phương pháp phân giải cũ của chúng tôi cho tham số súp.

00:10:28.000 --> 00:10:32.000
Điều này tuân theo một mô hình phổ biến trong khuôn khổ ý định cũ.

00:10:32.000 --> 00:10:34.000
Cố gắng mở gói thông số súp.

00:10:34.000 --> 00:10:39.000
Nếu đó là số không, hãy trả về kết quả giải quyết yêu cầu người dùng chọn một món súp bằng cách sử dụng định hướng.

00:10:39.000 --> 00:10:45.000
Nếu nó được thiết lập, hãy trả về kết quả giải quyết thành công và chuyển lại cùng một món súp đã được chỉ định.

00:10:45.000 --> 00:10:51.000
Loại boilerplate này không còn cần thiết với App Intents nhờ độ phân giải tự động.

00:10:51.000 --> 00:10:57.000
Nếu bạn có các tham số đã được giải quyết theo cách này trước đây, đây là cách tận dụng chức năng mới.

00:10:57.000 --> 00:11:06.000
Theo mặc định, các tham số đã di chuyển của bạn sẽ là tùy chọn nhưng bạn có thể nhận được hành vi phân giải tự động bằng cách thay đổi loại thành không tùy chọn.

00:11:06.000 --> 00:11:16.000
Khi bạn tạo một tham số không tùy chọn, App Intents sẽ tự động yêu cầu người dùng cung cấp một giá trị nếu nó trống bằng cách sử dụng các thực thể được đề xuất từ truy vấn của SoupAppEntity.

00:11:16.000 --> 00:11:27.000
Sau đó, thêm một hộp thoại vào khai báo tham số của bạn để người dùng được hỏi một câu hỏi cụ thể khi hệ thống phân giải nhắc một giá trị như, "Bạn muốn món súp nào?"

00:11:27.000 --> 00:11:31.000
Một khi bạn làm điều này, bạn không cần bất kỳ mã giải pháp nào cho tham số này nữa.

00:11:31.000 --> 00:11:44.000
Đối với tất cả các loại giải pháp khác, bạn nên di chuyển việc triển khai giải quyết của mình lên đầu phương thức perform() và thay đổi cách sử dụng API của bạn để sử dụng các API mới thích hợp để yêu cầu người dùng làm rõ.

00:11:44.000 --> 00:11:58.000
Ví dụ: giả sử phương pháp giải quyết số lượng cũ của bạn sẽ mở gói số lượng và ném needsValue nếu nó bị thiếu và sau đó kiểm tra xem số lượng có lớn hơn số lượng súp thực sự có sẵn hay không và trả về lỗi nếu có.

00:11:58.000 --> 00:12:06.000
Khi chúng tôi chuyển mã này sang App Intents, chúng tôi hoàn toàn không cần phần đầu tiên nữa, bởi vì chúng tôi có thể riêng biệt chỉ cần làm cho tham số số lượng không tùy chọn.

00:12:06.000 --> 00:12:18.000
Đối với phần thứ hai đó, chúng tôi sẽ muốn lấy mã khiến trình xử lý hoàn thành có kết quả phân giải không được hỗ trợ và thay thế nó bằng mã gây ra lỗi cho thấy rằng không có đủ súp trong kho.

00:12:18.000 --> 00:12:25.000
Chúng ta sẽ cần xác định lỗi như một enum, phù hợp với lỗi và các giao thức chuyển đổi tài nguyên chuỗi được bản địa hóa tùy chỉnh.

00:12:25.000 --> 00:12:30.000
Bằng cách đó, chúng tôi có thể cung cấp hộp thoại được nói hoặc hiển thị cho người dùng khi trường hợp này xảy ra.

00:12:30.000 --> 00:12:39.000
Nếu bạn đã từng có mã trả về và kết quả needsValue động như trong ví dụ này, bạn có thể thay thế mã đó bằng mã ném needsValueError.

00:12:39.000 --> 00:12:48.000
Khi bạn ném needsValueError, hệ thống sẽ nhắc người dùng nhập giá trị bằng hộp thoại bạn cung cấp và sau đó sẽ chạy lại phương thức thực hiện của bạn ngay từ đầu.

00:12:48.000 --> 00:12:52.000
Một lựa chọn khác là sử dụng phương thức requestValue.

00:12:52.000 --> 00:12:59.000
Khi bạn sử dụng requestValue, bạn có thể nhắc người dùng cho một giá trị và tiếp tục chạy phương thức thực hiện của mình mà không cần bắt đầu lại.

00:12:59.000 --> 00:13:08.000
Ngoài phương thức requestValue, còn có các phương thức requestDisambiguation và requestConfirmation mà bạn có thể sử dụng để thay thế việc sử dụng API trước đây của mình.

00:13:08.000 --> 00:13:11.000
Tiếp theo hãy nói về xác nhận.

00:13:11.000 --> 00:13:19.000
Xác nhận là một cơ hội để thực hiện xác thực bổ sung và cung cấp thông tin cho hệ thống để yêu cầu người dùng xác nhận rằng họ muốn tiếp tục.

00:13:19.000 --> 00:13:25.000
Để xác thực, bạn nên di chuyển tất cả logic xác thực trong phương thức xác nhận sang phương thức thực hiện của bạn.

00:13:25.000 --> 00:13:30.000
Để yêu cầu người dùng xác nhận, chúng tôi có một API requestConfirmation() đơn giản mới.

00:13:30.000 --> 00:13:33.000
API mới chỉ là một lệnh gọi phương thức duy nhất.

00:13:33.000 --> 00:13:40.000
Sử dụng async/await, phương pháp này sẽ đợi cho đến khi người dùng xác nhận trước khi tiếp tục với phương pháp thực hiện của bạn.

00:13:40.000 --> 00:13:46.000
Nếu họ hủy, một lỗi sẽ được ném ra và việc thực hiện phương thức thực hiện của bạn sẽ dừng lại.

00:13:46.000 --> 00:14:07.000
Phương thức requestConfirmation bao gồm một số đối số ảnh hưởng đến lời nhắc xác nhận, bao gồm hộp thoại được Siri nói hoặc hiển thị, chế độ xem SwiftUI được hiển thị trong đoạn mã, nhãn được sử dụng cho nút xác nhận - trong trường hợp này là thứ tự - và đối số showPrompt, kiểm soát xem hộp thoại có nên được hiển thị trên màn

00:14:07.000 --> 00:14:12.000
Điều này nên được đặt thành sai khi hộp thoại và chế độ xem chứa cùng thông tin với nhau.

00:14:12.000 --> 00:14:16.000
Vì vậy, thật hợp lý khi Siri nói đoạn hội thoại nhưng không hiển thị nó.

00:14:16.000 --> 00:14:18.000
Tiếp theo, hãy xem xét xử lý.

00:14:18.000 --> 00:14:25.000
Để tái cấu trúc xử lý, bạn có thể chỉ cần di chuyển mã của mình từ phương thức xử lý sang phương thức thực hiện.

00:14:25.000 --> 00:14:32.000
Bạn sẽ có thể xóa một số mã xác thực khỏi phương thức xử lý cũ vì việc giải quyết, xác nhận và xử lý hiện xảy ra tất cả trong một phương thức duy nhất.

00:14:32.000 --> 00:14:42.000
Ví dụ: nếu bạn sao chép mã cũ của mình từ tay cầm, bạn có thể sẽ kết thúc với mã để mở các tham số không còn là tùy chọn mà bây giờ có thể bị xóa.

00:14:42.000 --> 00:14:46.000
Khi kết thúc phương pháp thực hiện của bạn, bạn nên trả về một kết quả có ý định.

00:14:46.000 --> 00:14:53.000
Kết quả có thể bao gồm nhiều trường khác nhau như hộp thoại để Siri nói hoặc chế độ xem đoạn mã để hiển thị.

00:14:53.000 --> 00:15:05.000
Mỗi cái yêu cầu bạn chú thích loại trả về của phương thức thực hiện của mình bằng các giao thức thích hợp, như ProvidesDialog cho hộp thoại và ShowSnippetView cho chế độ xem đoạn mã SwiftUI.

00:15:05.000 --> 00:15:08.000
Cuối cùng, hãy xem xét việc di chuyển các tùy chọn động.

00:15:08.000 --> 00:15:13.000
Bạn sẽ cần điền vào Truy vấn hoặc DynamicOptionsProvider tùy thuộc vào loại tham số.

00:15:13.000 --> 00:15:18.000
Xcode sẽ cung cấp những việc cần làm ở những nơi mà bạn cần điền chúng vào.

00:15:18.000 --> 00:15:31.000
Đối với một truy vấn, bạn sẽ cần triển khai các phương thức để trả về các thực thể theo định danh, theo chuỗi nếu nó có thể tìm kiếm được và tập hợp các thực thể được đề xuất sẽ xuất hiện khi người dùng nhấn vào tham số đó trong Phím tắt.

00:15:31.000 --> 00:15:36.000
Đối với các tùy chọn động, bạn chỉ có thể trả về tất cả các tùy chọn trong phương thức kết quả.

00:15:36.000 --> 00:15:37.000
Và thế là xong!

00:15:37.000 --> 00:15:40.000
Bạn đã hoàn thành việc di chuyển sang App Intents.

00:15:40.000 --> 00:15:45.000
Trước khi bạn thực sự hoàn thành, có một vài điều nữa tôi khuyên bạn nên xem xét.

00:15:45.000 --> 00:15:47.000
Đầu tiên là áp dụng Phím tắt Ứng dụng.

00:15:47.000 --> 00:15:54.000
Điều này sẽ cho phép bạn làm cho ý định của mình có thể khám phá được và cho phép mọi người sử dụng chúng chỉ bằng cách nói một vài từ với Siri.

00:15:54.000 --> 00:16:01.000
Thêm các mẹo Siri vào giao diện người dùng của bạn để mọi người có thể tìm hiểu những gì cần nói với Siri để sử dụng chức năng ứng dụng của bạn.

00:16:01.000 --> 00:16:04.000
Những thứ này sẽ thay thế bất kỳ nút Thêm vào Siri nào bạn đã có trước đây.

00:16:04.000 --> 00:16:15.000
Đảm bảo kiểm tra đường dẫn nâng cấp của khách hàng bằng cách tạo các phím tắt với phiên bản trước của ứng dụng của bạn và kiểm tra xem chúng có hoạt động chính xác với các phiên bản mới của ứng dụng của bạn hay không.

00:16:15.000 --> 00:16:19.000
Và nếu ứng dụng của bạn hoạt động ở nhiều ngôn ngữ, hãy nghĩ về bản địa hóa.

00:16:19.000 --> 00:16:32.000
Để bản địa hóa Ý định ứng dụng của bạn, tất cả các chuỗi có trong Ý định ứng dụng của bạn phải được cung cấp dưới dạng tài nguyên chuỗi được bản địa hóa và bạn có thể bản địa hóa chúng bằng cách cung cấp tệp .strings có thể định vị tương ứng với các chuỗi đó.

00:16:32.000 --> 00:16:37.000
Nếu bạn sử dụng các chuỗi số nhiều, bạn cũng có thể sử dụng tệp dict .strings.

00:16:37.000 --> 00:16:50.000
Khi bản địa hóa Phím tắt ứng dụng, hãy thêm các chuỗi vào một tệp có tên AppShortcuts.strings và thay thế bất kỳ biến nào trong các chuỗi đó bằng ký hiệu ${ }.

00:16:50.000 --> 00:17:01.000
Tóm lại, chúng tôi khuyên bạn nên nâng cấp ý định tùy chỉnh của mình lên App Intents để nhận được tất cả các lợi ích của các tính năng mới của iOS 16 và mô hình phát triển mới đơn giản hơn của App Intents.

00:17:01.000 --> 00:17:07.000
Đảm bảo thêm Phím tắt ứng dụng để mọi người có thể dễ dàng khám phá và sử dụng chức năng ứng dụng của bạn.

00:17:07.000 --> 00:17:16.000
Và để tìm hiểu thêm về cách kết hợp trải nghiệm người dùng tuyệt vời, hãy xem phiên "Thiết kế phím tắt ứng dụng" từ WWDC22.

00:17:16.000 --> 23:59:59.000
Cảm ơn bạn.

