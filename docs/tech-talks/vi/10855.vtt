WEBVTT

00:00:00.000 --> 00:00:03.000
Xin chào, tôi là Patrick, và tôi làm việc trong một nhóm biểu diễn tại Apple.

00:00:03.000 --> 00:00:09.000
Hôm nay chúng ta sẽ thảo luận về việc cuộn và hoạt hình trong các ứng dụng của bạn và xem xét chi tiết Vòng lặp kết xuất.

00:00:09.000 --> 00:00:13.000
Đầu tiên, chúng ta sẽ có được cảm giác chung về những gì là một trở ngại.

00:00:13.000 --> 00:00:18.000
Sau đó, chúng ta sẽ thảo luận về Vòng lặp kết xuất và các loại trở ngại khác nhau có thể xảy ra.

00:00:18.000 --> 00:00:21.000
Cuối cùng, chúng ta sẽ thảo luận về cách đo lường những trở ngại.

00:00:21.000 --> 00:00:24.000
Vậy trước tiên, một trở ngại là gì?

00:00:24.000 --> 00:00:27.000
Trong ứng dụng của bạn, một người có thể kéo ngón tay của họ trên màn hình để cuộn.

00:00:27.000 --> 00:00:33.000
Họ có thể nhấn vào một nút và mong đợi phản hồi hoặc chuyển đổi giữa các chế độ xem trong một hệ thống phân cấp.

00:00:33.000 --> 00:00:38.000
Những hình ảnh động này xây dựng cảm giác kết nối trực quan giữa con người và nội dung trên màn hình.

00:00:38.000 --> 00:00:46.000
Những trở ngại về hoạt hình có thể gây ra những cú nhảy trong hoạt hình và phá vỡ kết nối đó, gây nhầm lẫn thay vì thích thú.

00:00:46.000 --> 00:00:50.000
Một trở ngại là bất cứ khi nào một khung hình xuất hiện trên màn hình muộn hơn dự kiến.

00:00:50.000 --> 00:00:55.000
Hãy xem xét một ví dụ phổ biến về việc cuộn chế độ xem bộ sưu tập.

00:00:55.000 --> 00:00:59.000
Ở đây chúng tôi có một ứng dụng lập kế hoạch bữa ăn giúp chúng tôi sắp xếp các công thức nấu ăn yêu thích của mình.

00:00:59.000 --> 00:01:04.000
Khi người dùng kéo ngón tay của họ lên màn hình, chế độ xem cuộn sẽ phản hồi bằng cách di chuyển nội dung lên trên.

00:01:04.000 --> 00:01:07.000
Nhưng trong khi cuộn, chúng tôi nhận thấy một bước nhảy vọt trong nội dung.

00:01:07.000 --> 00:01:17.000
Nếu chúng ta nhìn vào từng khung hình này, chúng ta có thể thấy ngón tay của mình di chuyển với nội dung trong ba khung hình đầu tiên, nhưng trong khung hình tiếp theo, nội dung dường như bị đình trệ.

00:01:17.000 --> 00:01:22.000
Đó là bởi vì khung thứ ba thực sự lặp lại, ở trên màn hình cho một khung hình khác.

00:01:22.000 --> 00:01:28.000
Cuối cùng cũng đến khung hình thứ tư, và nó dường như nhảy về phía trước đến vị trí ngón tay của chúng ta.

00:01:28.000 --> 00:01:33.000
Khung thứ ba lặp lại vì khung thứ tư đến muộn và người dùng đã nhìn thấy một trở ngại.

00:01:33.000 --> 00:01:37.000
Quá giang được gây ra khi Vòng lặp kết xuất không hoàn thành khung hình đúng hạn.

00:01:37.000 --> 00:01:40.000
Vì vậy, hãy xem xét Vòng lặp Kết xuất.

00:01:40.000 --> 00:01:49.000
Vòng lặp kết xuất là một quá trình liên tục theo đó các sự kiện cảm ứng được chuyển đến một ứng dụng và sau đó các thay đổi đối với giao diện người dùng được gửi đến hệ điều hành nơi khung được hoàn thiện.

00:01:49.000 --> 00:01:52.000
Đó là một vòng lặp, và nó xảy ra ở tốc độ làm mới của thiết bị.

00:01:52.000 --> 00:02:00.000
Trên iPhone và iPad, đây là 60 khung hình mỗi giây, có nghĩa là một khung hình mới có thể được hiển thị sau mỗi 16,67 mili giây.

00:02:00.000 --> 00:02:08.000
Trên iPad Pro, đây là 120 khung hình mỗi giây, có nghĩa là một khung hình mới có thể được hiển thị sau mỗi 8,33 mili giây.

00:02:08.000 --> 00:02:12.000
Khi bắt đầu một khung hình, phần cứng phát ra một sự kiện gọi là VSYNC.

00:02:12.000 --> 00:02:16.000
VSYNC biểu thị khi nào một khung mới phải sẵn sàng.

00:02:16.000 --> 00:02:20.000
Chúng tôi làm nổi bật chúng trong bản nhạc hiển thị, vì vậy thật dễ dàng để xem thời hạn.

00:02:20.000 --> 00:02:22.000
Vòng lặp kết xuất được hẹn giờ thành VSYNCs.

00:02:22.000 --> 00:02:27.000
Nó phải chạm vào các trạm kiểm soát trên đường đi để có một khung sẵn sàng.

00:02:27.000 --> 00:02:29.000
Nó được chia thành ba giai đoạn.

00:02:29.000 --> 00:02:34.000
Giai đoạn đầu tiên là trong ứng dụng của bạn, nơi các sự kiện được xử lý và các thay đổi được thực hiện đối với giao diện người dùng.

00:02:34.000 --> 00:02:38.000
Công việc đó phải hoàn thành trước VSYNC tiếp theo, vì vậy giai đoạn tiếp theo có thể bắt đầu.

00:02:38.000 --> 00:02:42.000
Giai đoạn tiếp theo xảy ra trong một quy trình riêng biệt được gọi là máy chủ kết xuất.

00:02:42.000 --> 00:02:45.000
Đây là nơi giao diện người dùng của bạn thực sự được hiển thị.

00:02:45.000 --> 00:02:53.000
Giai đoạn này cũng phải hoàn thành trước VSYNC tiếp theo, để khung có thể được hiển thị, đây là giai đoạn thứ ba và cuối cùng.

00:02:53.000 --> 00:02:58.000
Một cảnh báo quan trọng đối với quy trình ba giai đoạn là khung được xử lý cho hai khung hình trước khi hiển thị.

00:02:58.000 --> 00:03:01.000
Chúng tôi gọi đây là bộ đệm kép, nhưng có một chế độ khác.

00:03:01.000 --> 00:03:09.000
Để tránh trở ngại, hệ thống có thể chuyển sang bộ đệm ba lần, trong đó máy chủ kết xuất được cung cấp thêm một thời lượng khung hình để hoàn thành công việc của nó.

00:03:09.000 --> 00:03:15.000
Vì đây là chế độ dự phòng, chúng ta sẽ tập trung vào bộ đệm kép trong khi nói về các trở ngại trong Vòng lặp kết xuất.

00:03:15.000 --> 00:03:19.000
Nhìn chung, toàn bộ Render Loop được tạo thành từ năm giai đoạn.

00:03:19.000 --> 00:03:22.000
Vòng lặp bắt đầu với giai đoạn đầu tiên, giai đoạn sự kiện.

00:03:22.000 --> 00:03:27.000
Tại đây, ứng dụng của bạn xử lý các sự kiện cảm ứng và quyết định xem có cần thay đổi trong giao diện người dùng hay không.

00:03:27.000 --> 00:03:29.000
Tiếp theo là giai đoạn cam kết.

00:03:29.000 --> 00:03:34.000
Trong giai đoạn cam kết, ứng dụng của bạn cập nhật giao diện người dùng của nó và gửi nó đến máy chủ kết xuất để kết xuất.

00:03:34.000 --> 00:03:41.000
Trên VSYNC tiếp theo, máy chủ kết xuất sẽ thực hiện việc gửi bài đó và trong giai đoạn chuẩn bị kết xuất, chuẩn bị nó để vẽ trên GPU.

00:03:41.000 --> 00:03:51.000
Trong giai đoạn thực thi kết xuất, GPU vẽ giao diện người dùng của bạn thành hình ảnh cuối cùng, vì vậy trên VSYNC tiếp theo, khung có thể được hiển thị cho người dùng của bạn.

00:03:51.000 --> 00:03:57.000
Mỗi giai đoạn đều rất quan trọng để có trải nghiệm người dùng mượt mà trên mọi khung hình, ngay cả công việc kết xuất.

00:03:57.000 --> 00:04:06.000
Mặc dù nó xảy ra trong một quy trình riêng biệt, nhưng nó hoạt động thay mặt cho ứng dụng của bạn, vì vậy bạn phải đảm bảo cây lớp của bạn có thể được xử lý và vẽ kịp thời.

00:04:06.000 --> 00:04:11.000
Để hiểu thêm một chút về điều này, hãy xem xét một ví dụ.

00:04:11.000 --> 00:04:16.000
Trong ví dụ này, chúng ta sẽ theo dõi khung hình này thông qua Vòng lặp kết xuất để xem từng giai đoạn trên đường đi.

00:04:16.000 --> 00:04:20.000
Đầu tiên là giai đoạn sự kiện, nơi ứng dụng sẽ nhận được các sự kiện.

00:04:20.000 --> 00:04:25.000
Những sự kiện này là những thứ như chạm, gọi lại mạng, nhấn bàn phím và hẹn giờ.

00:04:25.000 --> 00:04:30.000
Ứng dụng có thể phản hồi các sự kiện này theo bất kỳ cách nào bằng cách thay đổi hệ thống phân cấp lớp của nó.

00:04:30.000 --> 00:04:37.000
Ví dụ, ứng dụng có thể thay đổi màu nền của một lớp, hoặc thậm chí thay đổi kích thước và vị trí của một lớp.

00:04:37.000 --> 00:04:42.000
Nhưng khi ứng dụng cập nhật giới hạn của một lớp, Core Animation cũng gọi setNeedsLayout.

00:04:42.000 --> 00:04:47.000
Điều này xác định tất cả các lớp, phải tính toán lại bố cục của chúng để phản hồi.

00:04:47.000 --> 00:04:56.000
Hệ thống sẽ kết hợp các yêu cầu "cần bố cục" này và thực hiện chúng theo thứ tự trong giai đoạn cam kết để giảm công việc trùng lặp.

00:04:56.000 --> 00:05:02.000
Nếu cần bất kỳ bố cục nào, giai đoạn cam kết sẽ tự động bắt đầu sau khi giai đoạn sự kiện kết thúc.

00:05:02.000 --> 00:05:10.000
Đầu tiên, hệ thống lấy tất cả các lớp yêu cầu bố cục và bố trí từng lớp một, từ cha mẹ đến con cái.

00:05:10.000 --> 00:05:17.000
Bố cục là một nút cổ chai hiệu suất phổ biến, vì vậy hãy nhớ rằng ứng dụng của bạn chỉ có vài mili giây để hoàn thành công việc này.

00:05:17.000 --> 00:05:23.000
Một số chế độ xem cũng yêu cầu bản vẽ tùy chỉnh, như nhãn, chế độ xem hình ảnh hoặc bất kỳ chế độ xem nào ghi đè drawRect.

00:05:23.000 --> 00:05:29.000
Nếu những chế độ xem này yêu cầu cập nhật trực quan, họ phải gọi setNeedsDisplay.

00:05:29.000 --> 00:05:36.000
Giống như bố cục, hệ thống sẽ kết hợp các yêu cầu này để thực hiện chúng sau khi tất cả bố cục đã hoàn thành.

00:05:36.000 --> 00:05:44.000
Trong quá trình vẽ, mọi lớp vẽ tùy chỉnh sẽ nhận được bối cảnh Đồ họa cốt lõi được hỗ trợ bởi kết cấu mà chúng sẽ vẽ vào.

00:05:44.000 --> 00:05:48.000
Liên quan đến Core Animation, các lớp này bây giờ chỉ là hình ảnh.

00:05:48.000 --> 00:05:57.000
Và bây giờ tất cả các lớp đã được bố trí và vẽ, toàn bộ cây lớp đã thay đổi được thu thập và gửi đến máy chủ kết xuất để kết xuất.

00:05:57.000 --> 00:06:04.000
Bây giờ chúng tôi đang ở trong máy chủ kết xuất, chịu trách nhiệm biến cây lớp của chúng tôi thành một hình ảnh có thể hiển thị thực tế.

00:06:04.000 --> 00:06:13.000
Trong giai đoạn chuẩn bị, máy chủ kết xuất lặp lại thông qua cây lớp của ứng dụng và chuẩn bị một đường ống tuyến tính mà GPU sau đó có thể thực thi.

00:06:13.000 --> 00:06:24.000
Bắt đầu từ lớp trên cùng, nó hoạt động theo cách của nó từ cha mẹ đến con cái và anh chị em đến anh chị em để các lớp được sắp xếp từ sau ra trước.

00:06:24.000 --> 00:06:30.000
Tiếp theo, đường ống tuyến tính này được truyền qua GPU, nơi mỗi lớp được tổng hợp thành một kết cấu cuối cùng.

00:06:30.000 --> 00:06:37.000
Một số lớp có thể mất nhiều thời gian hơn để hiển thị và đây là một nút cổ chai hiệu suất phổ biến khác mà chúng ta sẽ thảo luận trong thời gian ngắn.

00:06:37.000 --> 00:06:38.000
Tuyệt vời.

00:06:38.000 --> 00:06:44.000
Vì vậy, một khi GPU thực thi và hiển thị hình ảnh ở bên phải, nó đã sẵn sàng để được hiển thị trên VSYNC tiếp theo.

00:06:44.000 --> 00:06:48.000
Mỗi giai đoạn của Vòng lặp Kết xuất đều nhạy cảm với hiệu suất và có thời hạn.

00:06:48.000 --> 00:06:50.000
Hạn chót là VSYNC tiếp theo.

00:06:50.000 --> 00:06:58.000
Để đạt được tốc độ khung hình mục tiêu và duy trì độ trễ đầu vào thấp, toàn bộ quá trình này thực sự đang diễn ra song song với mọi khung hình.

00:06:58.000 --> 00:07:05.000
Bằng cách này, đường ống trở nên đồng thời và ứng dụng của chúng tôi có thể chuẩn bị một khung mới trong khi hệ thống đang hiển thị khung hình trước đó.

00:07:05.000 --> 00:07:09.000
Đây là lý do tại sao bất kỳ thời hạn nào bị bỏ lỡ đều rất quan trọng.

00:07:09.000 --> 00:07:15.000
Bây giờ bạn đã thấy Vòng lặp kết xuất hoạt động như thế nào, hãy đi sâu vào loại trở ngại nào bạn có thể thấy trong ứng dụng của mình.

00:07:15.000 --> 00:07:23.000
Có hai loại chính: quá giang cam kết, xảy ra trong quy trình của ứng dụng và quá giang kết xuất, xảy ra trong máy chủ kết xuất.

00:07:23.000 --> 00:07:29.000
Một trở ngại của cam kết là khi ứng dụng mất quá nhiều thời gian để xử lý các sự kiện hoặc cam kết.

00:07:29.000 --> 00:07:39.000
Ở đây, cam kết mất quá nhiều thời gian và bỏ lỡ thời hạn, vì vậy trong VSYNC tiếp theo, máy chủ kết xuất không có gì để xử lý và bây giờ phải đợi VSYNC tiếp theo bắt đầu kết xuất.

00:07:39.000 --> 00:07:42.000
Và bây giờ chúng tôi đã trì hoãn thời gian giao hàng khung hình một khung hình.

00:07:42.000 --> 00:07:47.000
Tính bằng mili giây, đó là 16,67 mili giây trên iPhone hoặc iPad.

00:07:47.000 --> 00:07:52.000
Chúng tôi gọi khoảng thời gian trì hoãn này là "thời gian trì hoãn" và chúng tôi đo nó bằng mili giây.

00:07:52.000 --> 00:08:00.000
Nếu công việc cam kết thậm chí còn mất nhiều thời gian hơn và vượt qua VSYNC tiếp theo, thì khung hình sẽ bị trễ hai khung hình, hoặc 33,34 mili giây.

00:08:00.000 --> 00:08:06.000
Đó là 33,34 mili giây mà người dùng không nhìn thấy một cuộn mượt mà.

00:08:06.000 --> 00:08:13.000
Để hiểu thêm về các trở ngại cam kết và cách bạn có thể khắc phục chúng trong ứng dụng của mình, hãy xem "Tìm và khắc phục các quá giang trong giai đoạn cam kết".

00:08:13.000 --> 00:08:16.000
Loại quá giang thứ hai là quá giang kết xuất.

00:08:16.000 --> 00:08:22.000
Những điều này xảy ra khi máy chủ kết xuất không thể chuẩn bị hoặc thực thi cây lớp của chúng tôi đúng hạn.

00:08:22.000 --> 00:08:26.000
Ở đây, giai đoạn thực thi kết xuất mất quá nhiều thời gian và vượt quá ranh giới VSYNC.

00:08:26.000 --> 00:08:33.000
Do đó, khung hình chưa sẵn sàng đúng giờ và khung màu xanh lá cây được hiển thị muộn hơn một khung so với dự kiến.

00:08:33.000 --> 00:08:36.000
Một lần nữa, chúng ta có thời gian quá giang 16 mili giây.

00:08:36.000 --> 00:08:44.000
Để hiểu thêm về các quá giang kết xuất và cách tối ưu hóa cây lớp của bạn, hãy xem "Demystify and Eliminate Hitches trong Giai đoạn Kết xuất."

00:08:44.000 --> 00:08:46.000
Tuyệt vời.

00:08:46.000 --> 00:08:48.000
Vì vậy, đó là hai loại quá giang chính.

00:08:48.000 --> 00:08:53.000
Bây giờ chúng ta hãy chuyển trọng tâm của chúng ta sang cách chúng ta đo lường và định lượng các trở ngại.

00:08:53.000 --> 00:08:55.000
Chúng tôi đã xem xét thời gian quá giang trong các trang trình bày trước đó.

00:08:55.000 --> 00:09:04.000
Nó rất hữu ích khi nói về một trở ngại duy nhất, nhưng có thể trở nên khó hiểu khi thảo luận về các sự kiện dài hạn như cuộn, hoạt ảnh hoặc chuyển tiếp.

00:09:04.000 --> 00:09:13.000
Thứ nhất, rất khó để so sánh trừ khi mỗi cuộn hoặc hoạt ảnh mất cùng một lượng thời gian, và do đó cùng một số lượng khung hình chính xác.

00:09:13.000 --> 00:09:18.000
Điều tồi tệ hơn là các thiết bị iOS không phải lúc nào cũng cập nhật màn hình.

00:09:18.000 --> 00:09:22.000
Nếu không có cam kết nào được gửi đến máy chủ kết xuất, không có khung mới nào được gửi.

00:09:22.000 --> 00:09:27.000
Điều đó khiến việc so sánh thời gian quá giang giữa các bài kiểm tra và thiết bị trở nên khó khăn hơn.

00:09:27.000 --> 00:09:30.000
Vì vậy, thay vào đó, chúng tôi sử dụng một số liệu được gọi là "tỷ lệ thời gian khâu".

00:09:30.000 --> 00:09:36.000
Tỷ lệ thời gian quá giang là tổng thời gian quá giang trong một khoảng thời gian chia cho thời gian của nó.

00:09:36.000 --> 00:09:42.000
Bởi vì nó được chuẩn hóa thành tổng thời gian, chúng ta có thể so sánh nó giữa các trải nghiệm.

00:09:42.000 --> 00:09:49.000
Nó được đo bằng quá giang mili giây mỗi giây, vì vậy nó đại diện cho số mili giây mà thiết bị đã quá giang mỗi giây.

00:09:49.000 --> 00:09:55.000
Để tìm hiểu về cách bạn có thể sử dụng số liệu này để đo lường hiệu suất ứng dụng của riêng mình, hãy xem "Có gì mới trong MetricKit".

00:09:55.000 --> 00:10:02.000
Để xem cách theo dõi tỷ lệ thời gian quá giang trong bộ thử nghiệm của bạn, hãy xem "Loại bỏ quá giang hoạt hình bằng XCTest".

00:10:02.000 --> 00:10:07.000
Cuối cùng, hãy xem xét một ví dụ trong đó tỷ lệ thời gian quá giang có thể được sử dụng.

00:10:07.000 --> 00:10:12.000
Ở đây chúng tôi có 30 khung hình, trên iPhone là công việc đáng giá nửa giây.

00:10:12.000 --> 00:10:16.000
Mỗi khung hình đạt đến thời hạn của nó, và người dùng không thấy trở ngại nào.

00:10:16.000 --> 00:10:21.000
Thời gian quá giang bằng không, và tỷ lệ thời gian quá giang cũng bằng không.

00:10:21.000 --> 00:10:25.000
Nhưng bây giờ chúng ta thấy một bản nhạc hiển thị ở phía dưới với các khoảng rời rạc.

00:10:25.000 --> 00:10:30.000
Một số khung hình trên màn hình dài hơn những khung hình khác, và một số cam kết và kết xuất đang gây ra trở ngại.

00:10:30.000 --> 00:10:35.000
Nếu chúng ta cộng lại thời gian quá giang này, chúng ta sẽ nhận được 100,02 mili giây.

00:10:35.000 --> 00:10:41.000
Hơn nửa giây, chúng ta có tỷ lệ thời gian quá giang là 200,04 mili giây mỗi giây.

00:10:41.000 --> 00:10:42.000
Đây chỉ là một ví dụ.

00:10:42.000 --> 00:10:48.000
Nói chung, đây là những tỷ lệ quá giang mục tiêu mà chúng tôi đề xuất và sử dụng trong các công cụ của chúng tôi tại Apple.

00:10:48.000 --> 00:10:57.000
Mặc dù mục tiêu này là không quá giang mili giây mỗi giây, bất cứ điều gì dưới năm quá giang mili giây mỗi giây đều được coi là tốt và hầu như không được người dùng chú ý.

00:10:57.000 --> 00:11:05.000
Từ năm đến mười mili giây mỗi giây, người dùng sẽ nhận thấy một số gián đoạn và những điều này cần được điều tra.

00:11:05.000 --> 00:11:15.000
Hơn mười phần nghìn giây mỗi giây, quá giang đang ảnh hưởng lớn đến trải nghiệm người dùng và bạn nên điều tra ngay cách tối ưu hóa Vòng lặp kết xuất của mình.

00:11:15.000 --> 00:11:20.000
Tóm lại, hôm nay chúng ta đã thảo luận về Vòng lặp kết xuất và cách một khung mới được hiển thị cho người dùng.

00:11:20.000 --> 00:11:25.000
Chúng tôi đã xem xét một quá giang là gì và hai loại, một quá giang cam kết và một quá giang kết xuất.

00:11:25.000 --> 00:11:32.000
Cuối cùng, chúng tôi đã xác định tỷ lệ thời gian quá giang để đo lường số lần quá giang mà người dùng đã trải qua trong một khoảng thời gian nhất định.

00:11:32.000 --> 00:11:40.000
Để tìm hiểu thêm về các loại quá giang và cách bắt và khắc phục chúng trong ứng dụng của bạn, vui lòng xem hai cuộc nói chuyện của chúng tôi về quá giang cam kết và kết xuất quá giang.

00:11:40.000 --> 23:59:59.000
Chúng tôi nóng lòng muốn xem các ứng dụng bơ mịn của bạn và cảm ơn vì đã xem.

