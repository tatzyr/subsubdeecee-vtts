WEBVTT

00:00:01.000 --> 00:00:05.000
Xin chào, tôi là Lionel Lemarié từ nhóm phần mềm GPU.

00:00:05.000 --> 00:00:12.000
Trong phiên này, chúng ta sẽ sử dụng Metal Counter API để có được thời gian GPU chính xác trong thời gian chạy.

00:00:12.000 --> 00:00:14.000
Chúng tôi sẽ đề cập đến một vài chủ đề.

00:00:14.000 --> 00:00:19.000
Chúng ta sẽ bắt đầu với phần giới thiệu nhanh về Metal Counter API.

00:00:19.000 --> 00:00:25.000
Sau đó, chúng ta sẽ xem xét ngắn gọn các tính năng chính của HUD hồ sơ trực tiếp điển hình.

00:00:25.000 --> 00:00:31.000
Chúng tôi sẽ sử dụng API từng bước để thu thập thông tin hồ sơ.

00:00:31.000 --> 00:00:36.000
Và chúng tôi sẽ kết luận bằng cách xem xét dữ liệu này phù hợp với HUD như thế nào.

00:00:36.000 --> 00:00:40.000
Vì vậy, hãy bắt đầu với phần giới thiệu nhanh về API.

00:00:40.000 --> 00:00:44.000
Metal Counter API là mới trong iOS 14.

00:00:44.000 --> 00:00:49.000
Nó đã có sẵn trong macOS Catalina và đã được mở rộng trong macOS Big Sur.

00:00:49.000 --> 00:00:55.000
Trên iOS và macOS với Apple Silicon, nó cho phép bạn truy cập vào thời gian ranh giới sân khấu.

00:00:55.000 --> 00:01:01.000
Đó là, thời gian bắt đầu và kết thúc chính xác cho các đường đỉnh, phân đoạn và tính toán.

00:01:01.000 --> 00:01:12.000
Trên GPU Intel và AMD, bạn có thể nhận được thời gian ranh giới rút ra, dấu thời gian GPU chính xác ngay cả trong các lần vượt qua riêng lẻ.

00:01:12.000 --> 00:01:18.000
Tiếp theo, hãy tóm tắt nhanh các tính năng chính của HUD hồ sơ trực tiếp.

00:01:18.000 --> 00:01:22.000
Bạn sẽ sử dụng HUD trực tiếp để theo dõi hiệu suất ứng dụng của mình trong thời gian chạy.

00:01:22.000 --> 00:01:28.000
Nó có thể giúp bạn tìm ra các khu vực có vấn đề cần được điều tra ngoại tuyến trong Xcode hoặc Instruments.

00:01:28.000 --> 00:01:34.000
Ví dụ, bạn cũng có thể sử dụng chúng để điều chỉnh độ phân giải và cài đặt chất lượng cho mỗi thiết bị.

00:01:34.000 --> 00:01:39.000
Ví dụ, một HUD sống điển hình có thể trông giống như thế này.

00:01:39.000 --> 00:01:51.000
Thời gian khung hình, dưới dạng biểu đồ đường cuộn, để giúp bạn nắm bắt các mốc khung hình, số liệu thống kê về việc sử dụng bộ nhớ, độ phân giải và hơn thế nữa và dòng thời gian của các sự kiện CPU.

00:01:51.000 --> 00:01:55.000
Và hôm nay, chúng ta sẽ thêm các sự kiện GPU vào dòng thời gian.

00:01:55.000 --> 00:02:05.000
Thông thường, đối với các điểm đánh dấu CPU của bạn, bạn sẽ thiết bị các chức năng quan trọng nhất của mình bằng cách sử dụng mach_absolute_time để có được dấu thời gian bắt đầu và kết thúc.

00:02:05.000 --> 00:02:16.000
Một khởi đầu tốt với các điểm đánh dấu CPU là đặt chúng xung quanh công việc bộ đệm lệnh của bạn - một điểm đánh dấu bắt đầu khi bạn tạo nó và một điểm đánh dấu kết thúc khi bạn cam kết nó.

00:02:16.000 --> 00:02:21.000
Điều đó cung cấp cho bạn cái nhìn tổng quan về chi phí CPU của kết xuất của bạn.

00:02:21.000 --> 00:02:25.000
Bây giờ chúng tôi muốn thêm các điểm đánh dấu GPU tương đương.

00:02:25.000 --> 00:02:31.000
Bạn có thể quen thuộc với các sự kiện GPU trên dòng thời gian Metal System Trace, như chúng ta đang thấy ở đây.

00:02:31.000 --> 00:02:37.000
Trên iOS trong ví dụ này, nó cho thấy các giai đoạn khác nhau của kiến trúc kết xuất hoãn lại dựa trên ô.

00:02:37.000 --> 00:02:42.000
Ở đây chúng ta thấy công việc xử lý đỉnh và phân mảnh.

00:02:42.000 --> 00:02:48.000
Để làm điều này, phần sụn GPU ghi lại sự bắt đầu và kết thúc của giai đoạn đỉnh.

00:02:48.000 --> 00:02:52.000
Sau đó, nó ghi lại sự bắt đầu và kết thúc của giai đoạn phân đoạn.

00:02:52.000 --> 00:02:57.000
Và Metal System Trace hiển thị các giai đoạn trên dòng thời gian.

00:02:57.000 --> 00:03:02.000
Đối với GPU chế độ tức thì, bạn có thể ghi lại các sự kiện cho các nhóm cuộc gọi rút thăm.

00:03:02.000 --> 00:03:10.000
Ví dụ, bạn sẽ ghi lại sự bắt đầu của đối tượng kết xuất một trước tất cả các cuộc gọi vẽ của nó và sau đó ghi lại sự bắt đầu của đối tượng kết xuất hai.

00:03:10.000 --> 00:03:13.000
Và cuối cùng, phần cuối của đối tượng hai.

00:03:13.000 --> 00:03:20.000
Sau đó, bạn có một dòng thời gian hiển thị chính xác thời gian GPU hiển thị từng đối tượng.

00:03:20.000 --> 00:03:25.000
Bây giờ hãy sử dụng Metal Counter API để đạt được điều đó.

00:03:25.000 --> 00:03:28.000
Chúng tôi sẽ bắt đầu bằng cách kiểm tra chế độ lấy mẫu bộ đếm nào có sẵn.

00:03:28.000 --> 00:03:39.000
Chúng ta cần biết liệu GPU có nên ghi ở ranh giới giai đoạn, cho đỉnh, phân đoạn hoặc giai đoạn tính toán hay không, hoặc nếu nó nên ghi ở ranh giới vẽ, như chúng ta vừa thấy.

00:03:39.000 --> 00:03:52.000
Chúng tôi chỉ cần sử dụng supportCounterSampling API để kiểm tra xem thiết bị hiện tại có hỗ trợ ranh giới giai đoạn, cho GPU TBDR hay ranh giới cho GPU chế độ không giới hạn.

00:03:52.000 --> 00:03:56.000
Tiếp theo chúng tôi kiểm tra xem bộ đếm nào có sẵn trên thiết bị.

00:03:56.000 --> 00:04:02.000
Bộ đếm bao gồm dấu thời gian, sử dụng giai đoạn và thống kê đường ống.

00:04:02.000 --> 00:04:07.000
Đối với các điểm đánh dấu GPU của chúng tôi, chúng tôi cần bộ đếm thu thập dấu thời gian.

00:04:07.000 --> 00:04:14.000
Vì vậy, chúng tôi liệt kê tất cả các bộ đếm có sẵn trên thiết bị và chọn một bộ cho dấu thời gian.

00:04:14.000 --> 00:04:23.000
Khi bạn đã đặt bộ đếm phù hợp, hãy kiểm tra nó để đảm bảo rằng nó có dấu thời gian, vì một số thiết bị có thể không hỗ trợ chúng.

00:04:23.000 --> 00:04:25.000
Chúng tôi đã hoàn thành thiết lập ban đầu.

00:04:25.000 --> 00:04:29.000
Bây giờ hãy xem những gì cần thiết trong thời gian chạy trong mỗi khung hình.

00:04:29.000 --> 00:04:31.000
Chỉ có bốn bước đơn giản.

00:04:31.000 --> 00:04:38.000
Đầu tiên chúng ta sẽ tạo một bộ đệm mẫu với kích thước, chế độ lưu trữ và bộ đếm mà chúng ta vừa tra cứu.

00:04:38.000 --> 00:04:41.000
Sau đó, chúng tôi sẽ thêm bộ đệm mẫu vào bộ mô tả vượt qua.

00:04:41.000 --> 00:04:45.000
Lưu ý rằng điều đó có nghĩa là bạn cần ít nhất một bộ đệm cho mỗi lần vượt qua.

00:04:45.000 --> 00:04:52.000
Tiếp theo, nếu chúng tôi đang sử dụng lấy mẫu tại ranh giới vẽ, chúng tôi sẽ thêm các lệnh lấy mẫu tại các điểm quan trọng.

00:04:52.000 --> 00:04:56.000
Cuối cùng, trong trình xử lý hoàn thành, chúng tôi sẽ giải quyết các bộ đếm.

00:04:56.000 --> 00:05:01.000
Và chúng ta sẽ nói về việc căn chỉnh dấu thời gian CPU và GPU nếu cần.

00:05:01.000 --> 00:05:05.000
Hãy kiểm tra chi tiết từng bước.

00:05:05.000 --> 00:05:09.000
Đầu tiên, chúng tôi tạo một bộ đệm mẫu bằng cách sử dụng bộ mô tả.

00:05:09.000 --> 00:05:15.000
Chúng tôi chỉ định số lượng mẫu tối đa mà nó có thể chứa, vì vậy nó có kích thước phù hợp.

00:05:15.000 --> 00:05:19.000
Chúng tôi sẽ sử dụng sáu mẫu ở đây, nhưng bạn thường sẽ sử dụng nhiều hơn thế.

00:05:19.000 --> 00:05:21.000
Sau đó chúng tôi thiết lập chế độ lưu trữ.

00:05:21.000 --> 00:05:24.000
Chế độ chia sẻ ở đây rất tuyệt.

00:05:24.000 --> 00:05:29.000
Nó không có nhiều dữ liệu, và nó làm cho việc truy cập các quầy trở nên dễ dàng hơn.

00:05:29.000 --> 00:05:33.000
Chúng tôi chỉ định bộ đếm được đặt để sử dụng, bộ đếm cho dấu thời gian.

00:05:33.000 --> 00:05:36.000
Cuối cùng, chúng tôi tạo ra bộ đệm mẫu.

00:05:36.000 --> 00:05:41.000
Cho đến nay, rất tốt. Bây giờ chúng tôi có một bộ đệm cho sáu mẫu.

00:05:41.000 --> 00:05:45.000
Ví dụ, hãy sử dụng nó trong bộ mã hóa kết xuất.

00:05:45.000 --> 00:05:49.000
Bạn sẽ làm điều đó tương tự cho các bộ mã hóa tính toán và blit.

00:05:49.000 --> 00:05:55.000
Đối với điều này, bạn sử dụng tệp đính kèm bộ đệm mẫu từ bộ mô tả vượt qua kết xuất.

00:05:55.000 --> 00:05:58.000
Nếu chúng ta đang sử dụng ranh giới giai đoạn, đây là nơi chúng ta thiết lập nó.

00:05:58.000 --> 00:06:02.000
Chúng tôi chỉ định sự bắt đầu và kết thúc của giai đoạn đỉnh.

00:06:02.000 --> 00:06:06.000
Chúng tôi đang đặt chúng ở chỉ số 0 và một trong bộ đệm mẫu.

00:06:06.000 --> 00:06:12.000
Đó là cách GPU biết nơi để viết từng mẫu và cách bạn biết lấy chúng từ đâu.

00:06:12.000 --> 00:06:15.000
Tương tự cho sự bắt đầu và kết thúc của giai đoạn phân đoạn.

00:06:15.000 --> 00:06:22.000
Cuối cùng, chúng tôi đã chỉ vào bộ đệm mẫu mà chúng tôi vừa tạo để lưu trữ các mẫu đó.

00:06:22.000 --> 00:06:28.000
Để lấy mẫu ranh giới vẽ, bạn thêm các lệnh mẫu tại các điểm chính của luồng lệnh của mình.

00:06:28.000 --> 00:06:34.000
Vị trí rõ ràng đầu tiên cho những thứ này là trước và sau tất cả các cuộc gọi rút thăm.

00:06:34.000 --> 00:06:39.000
Vì vậy, sau khi bạn đã tạo một bộ mã hóa mới, bạn ngay lập tức thêm một lệnh mẫu.

00:06:39.000 --> 00:06:46.000
Chúng tôi sẽ đặt nó ở chỉ số bốn, vì chúng tôi đã đặt trước bốn vị trí đầu tiên cho các mẫu ranh giới giai đoạn.

00:06:46.000 --> 00:06:54.000
Sau tất cả các cuộc gọi rút thăm của bạn, ngay trước khi kết thúc bộ mã hóa của bạn, bạn thêm một lệnh mẫu tại chỉ mục năm.

00:06:54.000 --> 00:07:00.000
Vì vậy, GPU sẽ ghi lại dấu thời gian trước và sau tất cả công việc cho bộ mã hóa đó.

00:07:00.000 --> 00:07:05.000
Bạn có thể thêm nhiều lệnh mẫu hơn giữa các nhóm cuộc gọi vẽ để đánh dấu các cột mốc quan trọng.

00:07:05.000 --> 00:07:11.000
Chỉ cần đảm bảo bộ đệm mẫu của bạn được phân bổ trước với đủ dung lượng.

00:07:11.000 --> 00:07:17.000
Nói về điều đó, chúng tôi đã phân bổ một bộ đệm đủ lớn cho cả ranh giới giai đoạn và lấy mẫu ranh giới vẽ.

00:07:17.000 --> 00:07:28.000
Bạn có thể dễ dàng tối ưu hóa nó bằng cách phân bổ vừa đủ cho việc lấy mẫu giai đoạn hoặc vẽ ranh giới một cách riêng biệt, vì chúng loại trừ lẫn nhau.

00:07:28.000 --> 00:07:35.000
Đúng rồi. GPU đã được hướng dẫn lấy mẫu bộ đếm dấu thời gian ở giai đoạn hoặc ranh giới vẽ.

00:07:35.000 --> 00:07:40.000
Tiếp theo, chúng tôi đợi kết xuất hoàn tất và trong trình xử lý, chúng tôi thu thập dữ liệu.

00:07:40.000 --> 00:07:43.000
Hãy nhớ rằng chúng tôi đã tạo một bộ đệm mẫu cho mỗi bộ mã hóa.

00:07:43.000 --> 00:07:49.000
Vì vậy, trong trình xử lý hoàn thành bộ đệm chung, chúng ta có thể cần phân tích nhiều bộ đệm mẫu.

00:07:49.000 --> 00:07:52.000
Đối với mỗi người, chúng tôi giải quyết các quầy.

00:07:52.000 --> 00:07:59.000
Điều đó dịch các dữ liệu cụ thể khác nhau thành cấu trúc Kim loại thống nhất siêu dễ phân tích cú pháp.

00:07:59.000 --> 00:08:03.000
Chỉ cần chỉ vào nó và sử dụng cấu trúc CounterResult.

00:08:03.000 --> 00:08:09.000
Như chúng tôi đã chỉ định rằng vertexStart phải ở chỉ mục 0, chúng tôi đọc nó trực tiếp từ đó.

00:08:09.000 --> 00:08:13.000
Sau đó chúng tôi sẽ làm điều tương tự cho tất cả các mẫu khác.

00:08:13.000 --> 00:08:16.000
Lưu ý rằng một số kiểm tra lỗi là cần thiết ở đây.

00:08:16.000 --> 00:08:27.000
Có thể GPU không điền được bộ đệm mẫu, vì vậy bạn cần kiểm tra xem bước kết quả có thu thập được số lượng mẫu dự kiến hay không và mỗi mẫu có hợp lệ hay không.

00:08:27.000 --> 00:08:34.000
GPU sẽ sử dụng giá trị lỗi được xác định trước nếu nó không thể nhận được dấu thời gian cụ thể.

00:08:34.000 --> 00:08:44.000
Trên các thiết bị iOS và Apple Silicon, dấu thời gian GPU được căn chỉnh với mach_absolute_time để bạn có thể so sánh trực tiếp chúng với dấu thời gian CPU.

00:08:44.000 --> 00:08:48.000
Trên GPU Intel và AMD, cần thêm một bước nữa.

00:08:48.000 --> 00:08:51.000
Chúng cần được dịch từ miền thời gian cụ thể của nhà cung cấp.

00:08:51.000 --> 00:09:05.000
Điều này là do tùy thuộc vào mức độ bận rộn của GPU, mức độ tiêu thụ năng lượng và mức độ nóng của nó khi chạy, tần số xung nhịp của nó được điều chỉnh liên tục theo thời gian, điều này ảnh hưởng đến dấu thời gian.

00:09:05.000 --> 00:09:15.000
Để giải quyết vấn đề này trên GPU chế độ tức thì, bạn sử dụng API của dấu thời gian mẫu để truy vấn dấu thời gian CPU và GPU phù hợp tại một thời điểm nhất định.

00:09:15.000 --> 00:09:21.000
Bạn làm điều đó đều đặn để tránh trôi dạt và giữ mối tương quan chính xác theo thời gian.

00:09:21.000 --> 00:09:27.000
Sau đó, bạn thực hiện nội suy tuyến tính đơn giản của các mẫu được thu thập.

00:09:27.000 --> 00:09:35.000
Ví dụ, bạn có thể gọi dấu thời gian mẫu bên trong trình xử lý hoàn thành bộ đệm chung để bạn có được một mối tương quan trên mỗi khung.

00:09:35.000 --> 00:09:39.000
Giả sử bạn truy vấn dấu thời gian CPU và GPU tại t0.

00:09:39.000 --> 00:09:43.000
Và sau đó ở khung tiếp theo, bạn truy vấn chúng ở t1.

00:09:43.000 --> 00:09:50.000
Tất cả các bộ đếm GPU từ bộ đệm mẫu hiện có thể được thu nhỏ và bù đắp trở lại miền CPU.

00:09:50.000 --> 00:09:57.000
Và đó là tất cả những gì chúng ta cần. Vì vậy, hãy xem tất cả có thể được hiển thị cùng nhau như thế nào.

00:09:57.000 --> 00:09:59.000
Chúng tôi đang thấy các điểm đánh dấu CPU.

00:09:59.000 --> 00:10:02.000
Chúng tôi đã bắt chúng bằng mach_absolute_time.

00:10:02.000 --> 00:10:08.000
Chúng ta đang thấy các giai đoạn đỉnh, phân đoạn và tính toán đều chồng chéo và phù hợp với hoạt động của CPU.

00:10:08.000 --> 00:10:21.000
Bạn thậm chí có thể thu thập mach_absolute_time bên trong trình xử lý được trình bày để căn chỉnh tất cả các điểm đánh dấu với các khung kính thực tế và hiển thị chính xác tất cả các sự kiện trong mỗi khung.

00:10:21.000 --> 00:10:34.000
Sử dụng HUD này, bạn sẽ có cái nhìn tuyệt vời về việc bạn bị ràng buộc bởi CPU hay GPU, các phụ thuộc và điểm đồng bộ hóa của bạn, sự phân tích của đỉnh, phân đoạn và công việc tính toán và cách chúng ảnh hưởng lẫn nhau.

00:10:34.000 --> 00:10:38.000
Tất cả những điều đó, trực tiếp, ngay bên trong ứng dụng của bạn.

00:10:38.000 --> 00:10:41.000
Có một vài điều bạn có thể đề phòng.

00:10:41.000 --> 00:10:43.000
Đừng cập nhật HUD quá thường xuyên.

00:10:43.000 --> 00:10:48.000
Cũng giống như bộ đếm FPS, dữ liệu trực tiếp có thể khó đọc nếu nó liên tục thay đổi.

00:10:48.000 --> 00:10:55.000
Ví dụ, bạn có thể thu thập dấu thời gian mỗi khung hình nhưng chỉ cập nhật các điểm đánh dấu trên màn hình một lần mỗi giây.

00:10:55.000 --> 00:10:58.000
Nó làm cho việc theo dõi dễ dàng hơn đáng kể.

00:10:58.000 --> 00:11:01.000
Thứ hai, hoạt động của GPU phụ thuộc vào tốc độ xung nhịp của nó.

00:11:01.000 --> 00:11:07.000
Nhìn thấy công suất GPU cao không nhất thiết có nghĩa là nó được tối đa hóa.

00:11:07.000 --> 00:11:13.000
Vì hệ thống chỉ sử dụng nhiều năng lượng khi cần thiết, nó sẽ cân bằng giữa công suất và hiệu suất.

00:11:13.000 --> 00:11:17.000
Kết quả là, bạn có thể thấy GPU đang bận 80% trong HUD.

00:11:17.000 --> 00:11:27.000
Nhưng nếu nó đang chạy với tốc độ một nửa tốc độ xung nhịp tối đa, thì nó thực sự sẽ chạy ở mức 40% hiệu suất cao nhất và có nhiều khoảng không.

00:11:27.000 --> 00:11:32.000
Và như mọi khi, bạn nên xử lý các lỗi, nhưng bạn cũng nên đề phòng sự không nhất quán.

00:11:32.000 --> 00:11:41.000
Ví dụ, bộ đếm có thể tràn, điều này sẽ khiến giá trị mới nhỏ hơn giá trị trước đó và có thể kích hoạt thời lượng âm.

00:11:41.000 --> 00:11:48.000
Hoặc đặt thiết bị của bạn vào chế độ ngủ hoặc ngủ đông trong khi lấy mẫu cũng có thể gây ra các ngoại lệ lớn.

00:11:48.000 --> 00:11:54.000
Đó là những sự kiện hiếm hoi và bạn nên bỏ qua chúng một cách duyên dáng để tránh trục trặc trong màn hình hoặc nhật ký của mình.

00:11:54.000 --> 00:12:01.000
Tóm lại, chúng tôi vừa trải qua các bước sử dụng Metal Counter API để thu thập dấu thời gian GPU.

00:12:01.000 --> 00:12:08.000
Để làm điều đó, chúng tôi đã sử dụng thiết bị hỗ trợ phương pháp CounterSampling để tìm ra chế độ lấy mẫu nào được hỗ trợ.

00:12:08.000 --> 00:12:13.000
Chúng tôi đã liệt kê các bộ đếm để tìm bộ có dấu thời gian GPU.

00:12:13.000 --> 00:12:20.000
Chúng tôi đã tạo một bộ đệm mẫu mới bằng cách sử dụng bộ mô tả của nó và sử dụng nó trong bộ mã hóa lệnh kết xuất.

00:12:20.000 --> 00:12:23.000
Bạn cũng sẽ muốn làm điều tương tự với bộ mã hóa blit và tính toán.

00:12:23.000 --> 00:12:28.000
Chúng tôi đã thêm các lệnh mẫu cụ thể trước và sau tất cả các lần rút thăm.

00:12:28.000 --> 00:12:33.000
Bạn cũng có thể thêm chúng giữa các lần rút thăm, công văn và điểm sáng để có được thời gian trong quá khứ.

00:12:33.000 --> 00:12:37.000
Chúng tôi đã giải quyết các bộ đếm vào bộ nhớ CPU.

00:12:37.000 --> 00:12:40.000
Và cuối cùng, chúng tôi đã sắp xếp lại chúng nếu cần.

00:12:40.000 --> 00:12:48.000
Và với điều đó, bạn có tất cả dữ liệu cần thiết cho một HUD hồ sơ GPU trực tiếp, mạnh mẽ để hiển thị trên ứng dụng của bạn.

00:12:48.000 --> 00:12:52.000
Và API này cung cấp cho bạn quyền truy cập vào nhiều thứ hơn là chỉ dấu thời gian GPU.

00:12:52.000 --> 00:12:58.000
Bạn có thể nhận được thông tin tóm tắt theo từng giai đoạn, điều này sẽ dễ xử lý hơn nếu bạn không vẽ các sự kiện trên dòng thời gian.

00:12:58.000 --> 00:13:08.000
Và quan trọng, bạn có thể nhận được một số thống kê chuyên sâu, chẳng hạn như số lượng lời gọi cho bộ đổ bóng đỉnh và đoạn và hạt nhân tính toán và hơn thế nữa.

00:13:08.000 --> 00:13:18.000
Có đủ để khám phá trong Metal Counter API và nó cung cấp cho bạn quyền truy cập vào rất nhiều thông tin để lập hồ sơ hiệu suất GPU của bạn trong thời gian chạy.

00:13:18.000 --> 00:13:19.000
Đó là nó cho phiên này.

00:13:19.000 --> 23:59:59.000
Cảm ơn vì đã xem.

