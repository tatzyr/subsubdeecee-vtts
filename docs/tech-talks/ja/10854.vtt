WEBVTT

00:00:01.000 --> 00:00:05.000
こんにちは。私はジェリ・メイソンです。私はHomePodチームのソフトウェアエンジニアです。

00:00:05.000 --> 00:00:13.000
そして、Cloud Extensionsを搭載したSiriKit Media Intentsを使用して、メディアサービスを家庭に持ち込むことをご案内します。

00:00:13.000 --> 00:00:17.000
開発を始めるのに必要なものすべてから始めましょう。

00:00:17.000 --> 00:00:38.000
まず、サービスを効果的に開発するためのいくつかの重要な前提条件について説明します。テストホームの設定方法、テスト用にHomePodを設定する方法、開発用にiOSデバイスを設定する方法、そして最後に、サービスをホームにオンボーディングするためにアプリにMediaSetupフレームワークを採用します。

00:00:38.000 --> 00:00:46.000
これらの手順を実行したら、あなたのコンテンツを愛する人々のためにHomePodで素晴らしい再生体験を生み出すことができます。

00:00:46.000 --> 00:00:48.000
前提条件に飛び込みましょう。

00:00:48.000 --> 00:00:55.000
HomePodでSiriKitメディアインテントをサポートするには、サービスがすでにiOSアプリのメディアインテントをサポートしている必要があります。

00:00:55.000 --> 00:01:00.000
Developer.apple.com/siriでプログラムに申し込む必要があります。

00:01:00.000 --> 00:01:09.000
申請後、サービスが実装する必要があるCloud Extension API仕様へのアクセスに関する詳細が届きます。

00:01:09.000 --> 00:01:14.000
その後、当社にサービスを登録して、開発を開始するための資格とプロファイルを取得できます。

00:01:14.000 --> 00:01:27.000
そして最後に、HomePodがCloud Extension APIを介してサービスに手を差し伸べる前に、OAuthフローと仕様で定義された構成Webサービスを実装する必要があります。

00:01:27.000 --> 00:01:29.000
登録についてもっと話しましょう。

00:01:29.000 --> 00:01:47.000
サービスを登録するには、サービス名、デバイスでサービスを確認するために作成した公開署名キー、ホームのiOSデバイスからサービスのアイコンを取得するための静的URL、およびサービスを使用しているアプリのバンドルIDのリストを提供する必要があります。

00:01:47.000 --> 00:01:53.000
この情報は、テストおよび開発デバイスにインストールできる開発プロファイルを作成するために使用されます。

00:01:53.000 --> 00:01:58.000
プロファイルを持つデバイスのみがサービスをテストできます。

00:01:58.000 --> 00:02:07.000
Cloud Extension APIはWeb技術を使用しているため、OAuth 2.0エンドポイントを使用した認証を採用しているため、驚くことではありません。

00:02:07.000 --> 00:02:13.000
しかし、あなたのアプリは信頼できるクライアントの役割を担うため、クライアントの資格情報フローを実装するサービスが必要です。

00:02:13.000 --> 00:02:19.000
ホームに追加されたサービスアカウントごとに、一意のClientIDとClientSecretが必要です。

00:02:19.000 --> 00:02:30.000
このフローではまれですが、Authサービスに直接提供されるこれらの資格情報の一般的な再利用を避けるために、更新トークンの発行が推奨されます。

00:02:30.000 --> 00:02:35.000
これは、更新トークンフローがなければ、ClientIDとClientSecretが長生きする可能性があるためです。

00:02:35.000 --> 00:02:41.000
誰かが自宅からあなたのサービスを使用している限り、更新トークンまたは元の認証のいずれかをサポートする必要があります。

00:02:41.000 --> 00:02:51.000
iOSアプリは、サービスから要求し、iOSメディアセットアップAPIに提供することで、これらの資格情報を提供できる必要があります。

00:02:51.000 --> 00:02:54.000
HomePodは、意図を解決するためにあなたのサービスに手を差し伸べます。

00:02:54.000 --> 00:02:59.000
iOSでは、サポートする意図の詳細は、アプリのバンドルの一部です。

00:02:59.000 --> 00:03:08.000
クラウド拡張機能では、サポートされているエンドポイントと、それらに到達するために使用するURLを識別する1つ以上の構成リソースエンドポイントを実装する必要があります。

00:03:08.000 --> 00:03:10.000
ここには多くの柔軟性があります。

00:03:10.000 --> 00:03:20.000
複数の静的URLを持つか、それらを動的に作成するエンドポイントを実装することができます。これらはすべて、開発およびステージングテスト構成に役立ちます。

00:03:20.000 --> 00:03:26.000
エンドポイントは、リクエスト承認ヘッダーをチェックして、設定を取得するアカウントを特定することもできます。

00:03:26.000 --> 00:03:35.000
構成の本体は、JavaScriptオブジェクト署名および暗号化標準を使用してエンコードされており、デバイスがそれを受け入れるには適切に署名する必要があります。

00:03:35.000 --> 00:03:44.000
リソースを提供する場合でも、クライアントが頻繁に取得する必要がないように、標準のHTTPキャッシュ制御ヘッダーを提供する必要があります。

00:03:44.000 --> 00:03:51.000
アプリがホームにサービスを追加するたびに、このリソースのURLとクライアントの資格情報を提供します。

00:03:51.000 --> 00:03:57.000
これらの前提条件が満たされて、テストホームの設定について話しましょう。

00:03:57.000 --> 00:04:04.000
サービスの開発とテスト中に、Apple Homeアプリで専用のテストホームを持つことを強くお勧めします。

00:04:04.000 --> 00:04:13.000
そうすれば、個人的に使用できるHomeKitホームには影響せず、テストホームのデバイスの構成を管理するだけで済みます。

00:04:13.000 --> 00:04:19.000
また、同じホームで異なるアカウントでサービスをテストできるように、複数のテストiCloudアカウントを持つこともできます。

00:04:19.000 --> 00:04:25.000
そして当然のことながら、HomePodとiOSテストデバイスで同じアカウントを使用していることを確認する必要があります。

00:04:25.000 --> 00:04:28.000
ホームアプリで新しい家を作るのは簡単です。

00:04:28.000 --> 00:04:37.000
まず、ホーム設定をタップし、ホームを追加し、ホームの名前を入力します。

00:04:37.000 --> 00:04:44.000
これで、他のテストユーザーである人を追加できます。

00:04:44.000 --> 00:04:50.000
わかりました。テストホームを設定したので、HomePodを追加してから設定する必要があります。 設定する必要があります。

00:04:50.000 --> 00:04:59.000
通常、最新のtvOS Developer BetaリリースをHomePodまたはAppleが現在開発に推奨しているリリースにインストールしたいと思うでしょう。

00:04:59.000 --> 00:05:05.000
アプリを提出する準備が整うまで、通常のtvOSリリースを使用できないことを知っておくことが重要です。

00:05:05.000 --> 00:05:12.000
それまでは、iOSのホームアプリにサービスのためにAppleが提供する開発プロファイルをインストールする必要があります。

00:05:12.000 --> 00:05:17.000
自宅でテストする予定のデバイスごとに、必ずこのプロセスを繰り返してください。

00:05:17.000 --> 00:05:22.000
tvOSの新しいバージョンにアップデートすると、プロファイルを再インストールする必要があるかもしれません。

00:05:22.000 --> 00:05:29.000
HomePodにプロファイルをインストールするには、まずホームアプリでテストホームが選択されていることを確認してください。

00:05:29.000 --> 00:05:32.000
iOSデバイスでプロファイルを開きます。

00:05:32.000 --> 00:05:36.000
インストールするデバイスタイプとしてHomePodを選択します。

00:05:36.000 --> 00:05:45.000
「インストール」をタップし、パスコードを入力し、契約に同意し、「インストール」をタップしてインストールを完了します。

00:05:45.000 --> 00:05:49.000
その後、テストホームでプロファイルをインストールするHomePodを選択できます。

00:05:49.000 --> 00:05:51.000
それでおそれ。

00:05:51.000 --> 00:05:56.000
テストと開発のためにiOSデバイスも設定する必要があります。

00:05:56.000 --> 00:06:00.000
iOSデバイスで開発者ベータ版を使用する必要があります。

00:06:00.000 --> 00:06:07.000
通常、tvOSと同時にリリースされたバージョンが必要ですが、最新の推奨バージョンについてはAppleに確認してください。

00:06:07.000 --> 00:06:11.000
HomePodと同様に、開発プロファイルをインストールする必要があります。

00:06:11.000 --> 00:06:23.000
電子メールまたはiMessage添付ファイルのモバイル設定バンドルをタップし、iOSデバイスにインストールすることを選択し、設定でプロファイルを受け入れてインストールするための一般的なフローに従います。

00:06:23.000 --> 00:06:30.000
この時点で、iOSデバイスとHomePodデバイスが予想されるリリースを実行していることを確認することをお勧めします。

00:06:30.000 --> 00:06:33.000
この設定は、必要なテストデバイスに対して繰り返すことができます。

00:06:33.000 --> 00:06:37.000
それらはiPhoneまたはiPadデバイスにすることができます。

00:06:37.000 --> 00:06:42.000
デバイスを設定することで、アプリでMediaSetupフレームワークを採用できるようになりました。

00:06:42.000 --> 00:06:48.000
これは、最終的に、人々が自宅で使用するためにあなたのサービスを設定することを可能にするものです。

00:06:48.000 --> 00:07:04.000
MediaSetupを使用するには、OAuthマテリアルを取得または作成するための機能をアプリに実装し、オンボーディングされるアカウントに適した構成リソースURLを選択し、Appleにサービスを登録した後に受け取った資格を追加する必要があります。

00:07:04.000 --> 00:07:07.000
そうしないと、フレームワークを使用できなくなります。

00:07:07.000 --> 00:07:17.000
MSSetupSessionを使用してアカウントのインストールフローをトリガーするために、目立つ検出可能なオンボーディングプレゼンテーションコンテキストをアプリに追加してください。

00:07:17.000 --> 00:07:20.000
人々はホームアカウントの設定プロセスを案内されます。

00:07:20.000 --> 00:07:29.000
セットアッププロセスは、OAuthサービスを使用してAPIトークンを取得し、構成リソースURLが適切に署名され、解析可能であることを確認します。

00:07:29.000 --> 00:07:35.000
したがって、セットアップが成功する前に、先に述べたすべての前提条件が満たされている必要があります。

00:07:35.000 --> 00:07:40.000
詳細については、developer.apple.comをご覧ください。

00:07:40.000 --> 00:07:46.000
開発環境とテスト環境の準備が整ったので、テストホームのHomePodがあなたのサービスに手を差し伸べることができます。

00:07:46.000 --> 00:07:50.000
クラウドでインテントを処理するシステムアーキテクチャを見てみましょう。

00:07:50.000 --> 00:08:00.000
iPhone、iPad、またはApple TVでは、iOSアプリでメディアを再生するようにSiriに依頼すると、インテントを直接処理するか、アプリバンドルの拡張機能を介して処理します。

00:08:00.000 --> 00:08:14.000
通常、誰かがSiriにアプリからコンテンツを再生するように頼むと、Siriはこのリクエストを処理し、アプリバンドルをインテントのターゲットとして識別し、インテント解決を実装するアプリ拡張機能をロードします。

00:08:14.000 --> 00:08:23.000
拡張機能はサービスと通信することができ、インテントの処理は、アプリの起動をトリガーして再生を開始するか、変更を処理するように通知します。

00:08:23.000 --> 00:08:36.000
Cloud Extensionを使用すると、これらのインテントを解決するプロセスは、デバイス上の拡張機能の実装からサービス上のAPIに移行し、HomePodは代わりにCloud Extension Intentエンドポイントに直接到達します。

00:08:36.000 --> 00:08:41.000
Cloud Extension APIは、インテント処理用に設計されたWeb API仕様です。

00:08:41.000 --> 00:08:51.000
OpenAPIスキーマを使用して、iOSですでに慣れ親しんでいるSiriKit Intent APIに密接に従ったオブジェクトを定義します。

00:08:51.000 --> 00:08:59.000
開始時について議論した設定URLも仕様の一部であり、その内容はその中で定義されています。

00:08:59.000 --> 00:09:08.000
各SiriKit Media Intentタイプにはプロトコルエンドポイント構成があり、実装の必要に応じて異なるURLに手を差し伸べることができます。

00:09:08.000 --> 00:09:15.000
サポートされているプロトコルは、メディアの再生、メディアの追加、メディアのアフィニティの更新です。

00:09:15.000 --> 00:09:23.000
iOSデバイスとは異なり、HomePodに結果を表示するコンテキストがないため、検索プロトコルがHomePodで提供されていないことに気付くかもしれません。

00:09:23.000 --> 00:09:26.000
Siriにコンテンツを再生するように言うとどうなるか見てみましょう。

00:09:26.000 --> 00:09:33.000
Siriに「Celesteの「Strange」を再生」と言うと、PlayMediaIntentHandlingフローがトリガーされます。

00:09:33.000 --> 00:09:38.000
HomePodは、メディア検索オブジェクトでPlayMediaIntentの解決を開始します。

00:09:38.000 --> 00:09:42.000
それはJSONでシリアル化され、あなたのサービスに送信されます。

00:09:42.000 --> 00:09:48.000
メディア検索をカタログ内の適切なものに一致させると、応答オブジェクトが作成されます。

00:09:48.000 --> 00:09:58.000
メディアアイテムには、Siriが対話を策定するために使用できる識別子、タイプ、および追加のメタデータがあり、「Celesteの「Strange」を再生中」とユーザーに伝えます。

00:09:58.000 --> 00:10:04.000
さらに、このプロトコルには、インテントに関する他のフィールドを解決した後に呼び出されるハンドルメソッドがあります。

00:10:04.000 --> 00:10:10.000
インテントのフィールドがすでに受け入れられる場合、最終的なハンドルメソッドの返却を遅らせる理由はありません。

00:10:10.000 --> 00:10:13.000
だから、最初の要求への応答にそれを含めてください。

00:10:13.000 --> 00:10:20.000
そうしないことは、不必要にあなたのサービスへの余分な往復を引き起こし、意図応答時間を遅くします。

00:10:20.000 --> 00:10:32.000
ハンドル応答の中に、HomePodがコンテンツの再生を開始するときにサービスに返されるpersentIdentifierとuserInfoを含むUserActivityというオブジェクトを含めることができます。

00:10:32.000 --> 00:10:42.000
あなたのサービスはこれらの結果に返信し、HomePodがこれらの結果を処理し、再生セッションを開始するときに、リクエストに基づいて再生するコンテンツのキューを形成し始める可能性があります。

00:10:42.000 --> 00:10:49.000
さて、あなたのサービスからメディアが再生されているとき、私がSiriに「これを私のライブラリに追加してください」と言ったらどうなるか考えてみましょう。

00:10:49.000 --> 00:11:03.000
AddMediaIntentHandlingフローは、以前と同様にメディアアイテムの解決から始まりますが、Siriがサービスから現在再生されているものを知っていることを除いて、現在再生中のコンテンツの識別子もメディア検索パラメータの一部です。

00:11:03.000 --> 00:11:10.000
以前と同様に、サービスは再生中のコンテンツを識別し、リクエストに使用されたアカウントのライブラリに追加する必要があります。

00:11:10.000 --> 00:11:19.000
次に、ResolveMediaItemを表すオブジェクトを作成し、この操作が成功したことを示すハンドルメソッドの結果をバンドルします。

00:11:19.000 --> 00:11:25.000
その後、その応答をHomePodに返し、そこでSiriが結果を確認します。

00:11:25.000 --> 00:11:27.000
そして最後に、私がSiriに「私はこれが好きです！」と言うとき

00:11:27.000 --> 00:11:47.000
UpdateMediaAffinityIntentHandlingは、以前と同様にメディアアイテムの解決で再び開始され、サービスはコンテンツを識別し、ResolveMediaItem結果を作成し、アカウントが要求を認証するために使用したテイストプロファイルに対してこのアフィニティを登録し、前の例と同様に、ハンドルメソッドの結果を含めます。

00:11:47.000 --> 00:11:56.000
これらのコンテキスト固有のリクエストには、リクエストが行われたときにサービスがHomePodで再生されているサービスである場合にのみ、コンテンツ識別子が含まれます。

00:11:56.000 --> 00:12:03.000
また、リスナーは、現在再生されていないものをライブラリに追加したいと言うことができることを忘れないでください。

00:12:03.000 --> 00:12:08.000
この場合、解決するためのメディア名とアーティスト名が提供されます。

00:12:08.000 --> 00:12:11.000
しかし、これはあまり一般的ではないユースケースです。

00:12:11.000 --> 00:12:18.000
プロトコルでJSONとして見えるように、基本的な再生メディア要求と応答を見てみましょう。

00:12:18.000 --> 00:12:29.000
あなたのサービスで音楽を再生するために、私のHomePodに最も基本的な要求を尋ねると、あなたのサービス上のインテントエンドポイントへのすべての要求は、解決する最初の項目の前にセッションの説明を提供します。

00:12:29.000 --> 00:12:35.000
仕様のほとんどのオブジェクトには、提示されるオブジェクトのCloud Extensionバージョン番号が含まれています。

00:12:35.000 --> 00:12:39.000
サービスは、可能であれば、これらのオブジェクトの古いバージョンをサポートする必要があります。

00:12:39.000 --> 00:12:44.000
新しいバージョンも、新しいメジャーバージョン番号まで下位互換性があるはずです。

00:12:44.000 --> 00:12:51.000
インテント解決セッションには識別子があり、HTTPSリクエストのヘッダーにも搭載されます。

00:12:51.000 --> 00:13:00.000
インテントインタラクションの解決中は同じままであり、このインテントを解決するために複数の要求が行われた場合、この識別子はそれらの間で一貫しています。

00:13:00.000 --> 00:13:09.000
2つのタイムスタンプが提供されます。リクエストが準備されたUTC時間と、クライアントがリクエストをタイムアウトする締め切り時間です。

00:13:09.000 --> 00:13:14.000
締め切りに間に合わなかった場合、Siriはサービスが意図を解決できないと説明します。

00:13:14.000 --> 00:13:17.000
タイムリーな対応を提供することが重要です。

00:13:17.000 --> 00:13:30.000
タイムアウトは10秒後に発生するので、サービスがHomePodからのリクエスト間の時間を利用できるように、意図結果を返して再生用のコンテンツを準備する作業を分割する方法を検討してください。

00:13:30.000 --> 00:13:34.000
これらの制約とプレイヤーのコンテキストオブジェクトについては、後で詳しく説明します。

00:13:34.000 --> 00:13:40.000
彼らは、リクエストが行われたときにHomePodで何が起こっているかについての重要な情報を提供します。

00:13:40.000 --> 00:13:44.000
ほとんどのリクエストは、プロトコルのresolveMediaItemsメソッドで始まります。

00:13:44.000 --> 00:13:49.000
このリクエストの最も重要な部分は、パラメータとインテントオブジェクトにあります。

00:13:49.000 --> 00:13:59.000
これはPlayMediaIntentであり、すべてのPlayMediaIntentオブジェクトには、Siriが音声から解析したメディアの属性を定義するmediaSearchがあります。

00:13:59.000 --> 00:14:10.000
意図の他のパラメータには、シャッフルまたは繰り返しコンテンツを再生するように頼んだかどうか、またはコンテンツの再生を再開するように頼んだかどうか、または今ではなく次または後で何かを再生するように言ったかどうかに関する情報が含まれます。

00:14:10.000 --> 00:14:16.000
iOSでPlayMediaIntentsをすでに処理している場合は、このオブジェクトは身近に見えるはずです。

00:14:16.000 --> 00:14:22.000
このリクエストから返される応答も見覚えがあるはずですが、いくつかの新しいひねりがあります。

00:14:22.000 --> 00:14:38.000
結果の配列内では、メソッド名、結果オブジェクト、この場合は1つの項目を持つresolutionResult配列、このメソッドに適したresolutionResultクラスを提供します。この場合は、成功プロパティです。

00:14:38.000 --> 00:14:45.000
そして、ご覧のとおり、この resolvedMediaItemは、私の好みのプロフィールに基づいたステーションであるYour Favoritesを表しています。

00:14:45.000 --> 00:14:47.000
クラウドエクステンションの新機能をご紹介します。

00:14:47.000 --> 00:14:53.000
処理する各メソッドは、サービスが結果を提供するのにかかった時間を秒単位で説明するメトリクスオブジェクトを返す必要があります。

00:14:53.000 --> 00:15:02.000
Appleは、このデータを集計して、リスナーの経験を大まかに判断し、遅延がネットワーク接続によって引き起こされたときをよりよく評価する場合があります。

00:15:02.000 --> 00:15:07.000
次の結果項目がここで休憩の周りを覗いているのを見ることができます-このプロトコルのハンドルメソッドです。

00:15:07.000 --> 00:15:16.000
ハンドルメソッドの結果は、そのインテントに適した応答オブジェクトであり、ステータスコードとUserActivityオブジェクトの説明があります。

00:15:16.000 --> 00:15:21.000
ユーザーアクティビティは、意図的な結果を表す記念品と考えてください。

00:15:21.000 --> 00:15:33.000
MediaIntentの結果を再生するには、コンテンツの再生を開始または変更するときにUserActivityが使用されますが、iOSデバイスでは、UserActivityオブジェクトは起動時にアプリで利用可能になります。

00:15:33.000 --> 00:15:41.000
HomePodでは、サービスはメディアキューブ再生用の別のCloud Extension APIでリスニング体験を定義します。

00:15:41.000 --> 00:15:48.000
これまで、以前にiOSにSiriKit Media Intentsを実装したことがあれば、インテント処理は非常に使い慣れていたはずです。

00:15:48.000 --> 00:15:52.000
クラウドサービスからメディアを再生することは、クラウド拡張機能の駆動機能です。

00:15:52.000 --> 00:16:00.000
そして、この部分では、クラウドにメディアキューを実装するための概念と詳細を提供します。

00:16:00.000 --> 00:16:04.000
人がSiriにHomePodでメディアを再生するように頼んだときに何が起こるかをもう一度見てみましょう。

00:16:04.000 --> 00:16:12.000
リクエストはSiriによって処理され、当社のクラウドメディアサービス拡張機能は、お客様のサービスに代わって処理するために選択されます。

00:16:12.000 --> 00:16:18.000
HomePodは、サービスによって実装されたクラウド拡張APIを使用して、意図を解決します。

00:16:18.000 --> 00:16:28.000
意図を解決したら、Cloud Media Playerコンポーネントがサービスのキューエンドポイントに連絡し、再生するコンテンツを決定するキューエンドポイントです。

00:16:28.000 --> 00:16:33.000
ほとんどのサービスでは、コンテンツ配信サービスは、多くの場合、再生する実際のオーディオファイルを提供します。

00:16:33.000 --> 00:16:36.000
ここには2つのHomePodが描かれていることに気付くかもしれません。

00:16:36.000 --> 00:16:43.000
特定の状況では、意図を解決するHomePodは、コンテンツを再生しているHomePodと同じではない場合があります。

00:16:43.000 --> 00:16:57.000
家族が複数のHomePodを持っている場合、あなたのサービスがすでに家の中の複数の場所で再生されていて、そのセッションがキッチンで始まっていたとしても、リビングルームの誰かに最も近いHomePodは彼らの要求に応えるかもしれません。

00:16:57.000 --> 00:17:00.000
サービスがキューを介してどのようにコンテンツを提供するかを見てみましょう。

00:17:00.000 --> 00:17:09.000
さまざまなイディオムやさまざまなリスニング体験のユースケースなど、メディアキューの高レベルの概念をいくつか説明します。

00:17:09.000 --> 00:17:13.000
そして、キューの管理とその寿命の詳細に飛び込みます。

00:17:13.000 --> 00:17:18.000
そして最後に、あなたのサービスがHomePodの再生コントロールをどのように定義しているかを説明します。

00:17:18.000 --> 00:17:23.000
さて、あなたのサービスからキューを提供することが何を意味するのかを探りましょう。

00:17:23.000 --> 00:17:29.000
Cloud Extensionでサポートされているすべてのリスニングエクスペリエンスは、コンテンツアイテムのキューを再生することによって定義されます。

00:17:29.000 --> 00:17:36.000
キューは、意図解決に起因するユーザーアクティビティオブジェクトをサービスに送信することによって作成または変更されます。

00:17:36.000 --> 00:17:41.000
サービスは、コンテンツアイテムのキューを一度に返すか、おそらくセグメントで返します。

00:17:41.000 --> 00:17:46.000
いくつかのユースケースと、それらをキューとして概念化する方法を見てみましょう。

00:17:46.000 --> 00:17:58.000
インターネットラジオコンテンツは、多くの場合、プロモーショントラックから始まり、その後、多くの曲、多くの場合、広告、より多くの曲から始まり、リスナーが再生を停止するまで無期限に続きます。

00:17:58.000 --> 00:18:06.000
オンデマンドの音楽リクエストは、単一のアルバムやプレイリストなどの他のコレクションに解決され、有限のキューに制限されます。

00:18:06.000 --> 00:18:15.000
また、ライブストリーミングコンテンツは、多くの場合、ライブストリームソースを参照する1つのコンテンツを持つ最小限のキュー応答を形成する単一のコンテンツアイテムを持ちます。

00:18:15.000 --> 00:18:24.000
キュー内のコンテンツアイテムは、識別子、URL、およびコンテンツの名前、アーティストなどのさまざまな記述属性で記述できます。

00:18:24.000 --> 00:18:35.000
コンテンツの選択は、厳格なアルバムトラックの順序から完全に動的な選択まで、サービス内の任意の数のアルゴリズム形式を取ることができます。

00:18:35.000 --> 00:18:38.000
キューは、これらすべてのユースケースをサポートすることを目的としています。

00:18:38.000 --> 00:18:45.000
それでは、キュー内のコンテンツアイテムのシーケンスを慣用的に表現できるさまざまな方法について話しましょう。

00:18:45.000 --> 00:18:50.000
私が説明するイディオムは、さまざまな目的のためにセグメントに分割されたキューを使用する際のバリエーションです。

00:18:50.000 --> 00:18:55.000
そこで、ここでは、オブジェクトによって記述された時間の経過とともに概念的に実現されたコンテンツを持っています。

00:18:55.000 --> 00:19:02.000
これらの4つのコンテンツは、意図的な解決の結果として表現したい完全なリスニング体験であるとします。

00:19:02.000 --> 00:19:09.000
独自の識別子とこれらすべてのコンテンツアイテムの単純な配列を持つキューオブジェクトにそれらをパッケージ化することができます。

00:19:09.000 --> 00:19:11.000
それはかなり基本的なキューオブジェクトです。

00:19:11.000 --> 00:19:17.000
これは、キューに有限で不変のコンテンツリストが含まれている静的コンテンツイディオムです。

00:19:17.000 --> 00:19:24.000
1つのキューセグメントに収まる場合と収まらない場合がありますが、概念的には、順番に再生できるコンテンツアイテムの厳格なリストです。

00:19:24.000 --> 00:19:36.000
このイディオムのユースケースには、アルバムやプレイリストのオンデマンド音楽リクエスト、またはキューが無期限にストリーミングされる1つのコンテンツのシンプルなラッパーであるライブストリームのユースケースが含まれます。

00:19:36.000 --> 00:19:40.000
しかし、あなたのサービスはより複雑なキューを持つことができます。

00:19:40.000 --> 00:19:47.000
キューはセグメントに分割でき、URL参照を介して次のコンテンツと以前のコンテンツアイテムに内部的にリンクします。

00:19:47.000 --> 00:20:04.000
HomePodは、サービスが定義するようにこれらのセグメントを取得し、特定のセグメントを動的に生成し、リスニングセッションが新しいセグメントに移動するにつれて、自然に遷移するか、コンテンツアイテムを前方または後方にスキップすることによって、異なる結果を返すことができます。

00:20:04.000 --> 00:20:10.000
この特定の例は、サービスが一連の固定コンテンツセグメント内で広告を提供するユースケースに当てはまる可能性があります。

00:20:10.000 --> 00:20:16.000
そして、プレイヤーがキューセグメントBに遭遇するたびに、異なる広告が再生される可能性があります。

00:20:16.000 --> 00:20:24.000
これは、サービスキューのコンテンツが動的に取得されるため、サービスが入力された場合よりも各キューセグメントに対してより多くの要求を経験することを意味します。

00:20:24.000 --> 00:20:28.000
あなたのサービスは、コンテンツと再生オプションを最も個別に制御したいと思うかもしれません。

00:20:28.000 --> 00:20:38.000
また、完全に動的なイディオムでは、すべてのキューセグメントには1つのコンテンツアイテムが含まれており、リスナーがキューを進めるにつれてキューの新しいコンテンツを動的に取得できます。

00:20:38.000 --> 00:20:43.000
これは、キューが通常無期限のサイズであるため、インターネットラジオのユースケースで人気のある慣用句です。

00:20:43.000 --> 00:20:47.000
また、キューコンテンツ自体がリスニング動作の機能であるためです。

00:20:47.000 --> 00:20:58.000
トラックをスキップし、Siriの意図を通じてコンテンツの親和性を提供すると、アカウントに関連付けられた味覚プロファイルが変更される可能性があるため、今後のコンテンツアイテムは異なる方法で選択される可能性があります。

00:20:58.000 --> 00:21:04.000
当然のことながら、これはあなたのサービスで最も多くのリクエスト処理を表す慣用句でもあります。

00:21:04.000 --> 00:21:17.000
これらのイディオムは同じキューアーキテクチャを使用するさまざまな方法であるため、サービスはこれらのイディオムの任意の組み合わせを使用してキューを提供でき、特定の種類のリクエストに対して実装する代替イディオムを選択することもできます。

00:21:17.000 --> 00:21:22.000
それらは、複雑さと能力のトレードオフを考慮するのに役立ちます。

00:21:22.000 --> 00:21:27.000
十分な理論。サービスがこれらのキューをどのように作成および管理するかについて話しましょう。

00:21:27.000 --> 00:21:42.000
PlayMediaIntentHandlingリクエストがインテントエンドポイントから戻ると、サービスはキューの表現の作成を開始する必要があります。なぜなら、その後まもなく、キュー再生メディアエンドポイントでリクエストが初期または完全なキューセグメントを取得するために行われるためです。

00:21:42.000 --> 00:21:50.000
各セグメントは、サービスが望むように次のセグメントと前のセグメントにリンクすることができ、潜在的に無限または循環的なコンテンツのセットを提供します。

00:21:50.000 --> 00:21:54.000
通常、新しく取得したキューは、最初のコンテンツアイテムから再生を開始します。

00:21:54.000 --> 00:22:07.000
以前のセッションからの再生の再開をサポートするために、最初のキューセグメントでplayPointerオブジェクトを提供し、提供した時間オフセットで示されたコンテンツ項目から再生が開始されます。

00:22:07.000 --> 00:22:20.000
スムーズでギャップのない再生をサポートするために、リスニングポイントがキューセグメントの最後のコンテンツ項目の終わりに近いため、次のセグメントは設定可能なプレロール間隔で取得され、追加されます。

00:22:20.000 --> 00:22:28.000
PlayMusicIntentを正常に処理した後、サービスと交換された実際のJSONオブジェクトを見てみましょう。

00:22:28.000 --> 00:22:31.000
すべてのリクエストと同様に、クライアントのバージョンから始めます。

00:22:31.000 --> 00:22:42.000
家庭には非均質なデバイスセットがあるかもしれないので、あなたのコンテンツを再生するデバイスでサポートされているバージョンは、実際には意図を解決したものよりも古いか新しいかもしれません。

00:22:42.000 --> 00:22:48.000
PlayMediaリクエストの識別子は、インテント解決で使用される識別子を継承します。

00:22:48.000 --> 00:22:54.000
ただし、何らかの理由で再生を再起動しなければならない場合、この識別子は新しい一意の識別子である可能性があります。

00:22:54.000 --> 00:23:03.000
これらの識別子はデバッグに役立つかもしれませんが、ユーザーアクティビティがはるかに適切なキューとインテント結果をリンクするためにこれに頼るべきではありません。

00:23:03.000 --> 00:23:08.000
制約オブジェクトは、デバイスでの再生の特定の制限を定義します。

00:23:08.000 --> 00:23:13.000
インテントエンドポイントでも提供されていることを覚えているかもしれませんが、これらについては後で詳しく説明します。

00:23:13.000 --> 00:23:24.000
最後に、インテント解決がUserActivityオブジェクトを返した場合、そのオブジェクトは、キューエンドポイントがこのセッションのコンテンツアイテムを準備する方法のコンテキストを提供するために含まれます。

00:23:24.000 --> 00:23:27.000
サービスは、キューオブジェクトを使用してリクエストに応答します。

00:23:27.000 --> 00:23:37.000
これには、後でレポートとコンテキストと意図のために提示される識別子があり、通常、同じキューの異なるセグメント間で同じままです。

00:23:37.000 --> 00:23:44.000
再生するコンテンツアイテムの配列を提供できますが、この小さな例では、1つのアイテムのみが提供されます。

00:23:44.000 --> 00:23:56.000
各コンテンツアイテムを記述する属性、カタログ全体ではないにしても、このキューに固有の各アイテムの識別子、およびコンテンツの本文へのURLがあります。

00:23:56.000 --> 00:24:00.000
ここでは、セグメントの前と次のコンテンツリンクについて説明します。

00:24:00.000 --> 00:24:06.000
これらのURLからの応答の本文は、これとよく似ています。

00:24:06.000 --> 00:24:18.000
最後に、配列の最後のコンテンツ項目の再生が終了する約5秒前に5秒のプレロールを指定すると、次のコンテンツURLが取得され、キューのコンテンツを前方に拡張します。

00:24:18.000 --> 00:24:22.000
HomePodがコンテンツの再生を開始するために必要なのはそれだけです。

00:24:22.000 --> 00:24:28.000
さて、すでにあなたのキューを聴いている間に、誰かがSiriに次に別のトラックを再生するように頼んだらどうなりますか?

00:24:28.000 --> 00:24:34.000
これは、再生キューの場所を次へ解決することにより、PlayMediaIntentHandlingプロトコルで示されます。

00:24:34.000 --> 00:24:41.000
HomePodがこの例のキューで2番目のコンテンツアイテムを再生している場合、おそらくまったく新しいキューの結果を提供したくないでしょう。

00:24:41.000 --> 00:24:46.000
この場合、文字通りこのキュー内に1つ以上のコンテンツアイテムを挿入したいと考えています。

00:24:46.000 --> 00:25:02.000
これを行うには、PlayMediaエンドポイントからキューセグメントを提供し、現在再生されているものと同じキュー識別子と、セグメントで運ばれるコンテンツを現在のキューセグメントに挿入する場所に関するinsertPointerオブジェクトを提供します。

00:25:02.000 --> 00:25:10.000
挿入ポイントに特定のコンテンツ識別子が提供されていない場合、アイテムは現在再生中のアイテムの後にも挿入されます。

00:25:10.000 --> 00:25:19.000
この動作は、意図の解決とキューの更新の間の移行中の再生コンテンツとして、競合状態の影響を軽減します。

00:25:19.000 --> 00:25:25.000
サービスが完全に動的キューのイディオムを使用している場合でも、このテクニックを使用することをお勧めします。

00:25:25.000 --> 00:25:30.000
最後に、キュー管理のニュアンスを取り上げましょう。

00:25:30.000 --> 00:25:47.000
サービスエンドポイントで最大数のリクエストが発生しますが、完全に動的なイディオムは、ほとんどのメディアサービスにコンテンツを提供する最も柔軟な方法を特徴とし、コンテンツが本質的に完全に静的でない場合、概念的に管理が容易です。

00:25:47.000 --> 00:26:00.000
キュープロトコルは、キューをナビゲートするときに一連のコンテンツを提供するのに十分な柔軟性がありますが、リスナーがキュー内で後方に移動することを許可する場合は、キュー履歴の一貫性を維持することが最善です。

00:26:00.000 --> 00:26:16.000
リピートとシャッフルの動作を実装するには、サービスはインテント処理からこれらのオプションを特定し、シャッフルされた順序でキューコンテンツを提供するか、キュー内の以前に再生されたアイテムにつながる次のコンテンツURLなどのテクニックによって無期限に繰り返す必要があります。

00:26:16.000 --> 00:26:24.000
これらの動作は、キューの範囲を完全に知らずに実行することは不可能であるため、HomePodはそれらをネイティブにサポートしようとさえしません。

00:26:24.000 --> 00:26:38.000
次と前のコンテンツURLをテンプレート化できるため、キューセグメントの最後のコンテンツアイテムや、現在再生中のアクティビティキューやコンテンツ識別子など、少量のコンテキストを実装に提供できます。

00:26:38.000 --> 00:26:46.000
サービスがキュー更新ユーザーアクティビティエンドポイントを実装している場合は、イベントの報告を介して再生キューを更新することもできます。

00:26:46.000 --> 00:26:48.000
まもなく報告について話します。

00:26:48.000 --> 00:26:58.000
柔軟でタイムリーなコンテンツ検索と更新を提供するために、サービスが使用できる豊富なキュー管理ツールを十分に把握していることを願っています。

00:26:58.000 --> 00:27:06.000
最後に、このセクションでは、再生を制御し、リスナーがサービスとどのようにやり取りするかを定義します。

00:27:06.000 --> 00:27:11.000
すべての種類のキューが同じではなく、キュー内のすべてのコンテンツを同じように扱うことができるわけではありません。

00:27:11.000 --> 00:27:17.000
たとえば、インターネットラジオのユースケースは、通常、キューを通る前方移動のみをサポートします。

00:27:17.000 --> 00:27:23.000
さらに、広告が再生されているときは、そのコンテンツのスキップをまったくサポートしたくない場合があります。

00:27:23.000 --> 00:27:32.000
ラジオ局のキューで先に進むことは、プレミアムサブスクリプション、フリーミアムモデル、その他のより難解な制限など、多くの変数によって制限される可能性があります。

00:27:32.000 --> 00:27:36.000
完全にダイナミックなイディオムは、多くの場合、これらの要件をサポートする唯一の方法です。

00:27:36.000 --> 00:27:41.000
キュー内の異なるコンテンツ間の移動は、任意に制限される場合があります。

00:27:41.000 --> 00:27:44.000
このインタラクションをどのように定義するかについて話しましょう。

00:27:44.000 --> 00:27:52.000
Cloud ExtensionキューAPIを使用すると、サービスはキューオブジェクトで提供するPlayMediaControlオブジェクトとの相互作用を定義できます。

00:27:52.000 --> 00:27:59.000
各PlayMediaControlオブジェクトは、いくつかの一般的なユースケースをサポートする事前定義されたスキームを選択できます。

00:27:59.000 --> 00:28:05.000
この定義されたインタラクションのセットは、コントロール属性を使用して各コンテンツ項目で指定できます。

00:28:05.000 --> 00:28:14.000
広告に曲が散在するオンデマンドサービスに適したコントロール定義の例を見てみましょう。

00:28:14.000 --> 00:28:18.000
これらの定義は、すべてのキューオブジェクトのコントロール属性内に含めます。

00:28:18.000 --> 00:28:33.000
この例では、コンテンツ項目がコントロールを指定しない場合に使用される必須のデフォルト定義と、広告であるすべてのコンテンツ項目で指定された広告定義の2つの定義があります。

00:28:33.000 --> 00:28:36.000
すべての制御定義にはプロトタイプスキームがあります。

00:28:36.000 --> 00:28:43.000
デフォルトでは、キュー内のコンテンツアイテムはオンデマンドスキームになり、広告コンテンツの場合は広告スキームになります。

00:28:43.000 --> 00:28:48.000
このスキームは、ユーザーが次のコンテンツ項目に移動するように要求したときにSiriダイアログを変更します。

00:28:48.000 --> 00:28:52.000
その後、Siriは広告をスキップすることは許可されていないと返信するかもしれません。

00:28:52.000 --> 00:28:59.000
このスキームでは、すべてのナビゲーションコマンドを無効にすることもデフォルト設定されていますが、選択的に再度有効にすることができます。

00:28:59.000 --> 00:29:10.000
コマンドを有効にする例もここで提供され、通常はデフォルトで無効になっている dislikeTrackコマンドとlikeTrackコマンドがオンデマンドコンテンツによって有効になっています。

00:29:10.000 --> 00:29:18.000
キュー内のアイテムにリンクされたコントロール定義の小さなセットを使用して、コンテンツとのインタラクションを実質的にカスタマイズする方法を確認できます。

00:29:18.000 --> 00:29:31.000
最後に、コントロール定義では、サービスがオプションのコマンドイベント、ナビゲーション情報、コンテンツの再生ステータスを受け取る方法であるユーザーアクティビティレポートのオプションを指定することもできます。

00:29:31.000 --> 00:29:34.000
これらはすべて私が次にカバーしようとしているトピックです。

00:29:34.000 --> 00:29:41.000
これまでのところ、HomePodが意図を解決し、再生するコンテンツのキューを管理するためにあなたのサービスに手を差し伸べる方法を見てきました。

00:29:41.000 --> 00:30:03.000
次に、サービスがどのように再生イベントを認識し、時間の経過とともに要求をコンテキスト化できるか、リスニングアクティビティをサービスに報告する方法、サービスからキューをすでに再生しているときに再生コンテキストがどのように提供されるか、最後に、サービスが特定の再生制約をどのように尊重する必要があるかについて話します。

00:30:03.000 --> 00:30:06.000
では、報告から始めましょう。

00:30:06.000 --> 00:30:13.000
リスナーアクティビティは、Cloud Extension APIのメディアキューアップデートアクティビティエンドポイントを使用して報告されます。

00:30:13.000 --> 00:30:20.000
このエンドポイントは技術的にはオプションですが、ほとんどのサービスは、人々がコンテンツを聴くときにHomePodからステータスレポートを取得するためにそれを実装しています。

00:30:20.000 --> 00:30:30.000
サービスは、スキップ、一時停止、再生の継続、トラック内のスクラブなどのトランジションやメディアコントロールイベントのレポートを受け取ります。

00:30:30.000 --> 00:30:36.000
特に部分的または完全に動的なキューイディオムを実装している場合、キューのコンテンツはこれらのレポートの影響を受ける可能性があります。

00:30:36.000 --> 00:30:40.000
サービスは、応答として新しいキューセグメントを返すことさえできます。

00:30:40.000 --> 00:30:58.000
更新アクティビティ要求はキューのコンテンツ検索から非同期に行われるため、トラックスキップのレポートに新しいキューを返すと、キューのコンテンツがきれいに表示されず、通常のトランジションロジックと戦う可能性があるため、再生時にいくつかの可聴ジャンプが発生する可能性があります。

00:30:58.000 --> 00:31:04.000
レポートからのキュー応答のみを使用して、再生を完全に変更したり、新しいコンテンツを挿入したりします。

00:31:04.000 --> 00:31:10.000
コンテンツURLテンプレートを使用して、キューセグメントが取得された理由のコンテキストを取得します。

00:31:10.000 --> 00:31:15.000
更新アクティビティエンドポイントに対して行われたリクエストの例を見てみましょう。

00:31:15.000 --> 00:31:18.000
この例では、Siriに次のトラックにスキップするように頼みました。

00:31:18.000 --> 00:31:22.000
これらの単純な相互作用は意図ではなく、メディアコントロールです。

00:31:22.000 --> 00:31:25.000
JSONでは、レポートは次のようになります。

00:31:25.000 --> 00:31:30.000
ご覧のとおり、作成されているレポートのタイプはskip_nextとしてタグ付けされています。

00:31:30.000 --> 00:31:42.000
レポートタイプのフルセットは仕様で定義されており、トラック間の自然な遷移、トラック内のスクラブ、および新しいキューが既存のキューを置き換えるときが含まれます。

00:31:42.000 --> 00:31:50.000
アクティビティ、キュー、contentIdentifier、現在再生されているコンテンツへのオフセットなど、nowPlayingコンテキストが提供されます。

00:31:50.000 --> 00:31:54.000
トランジションには、以前に再生したコンテキストも提供されます。

00:31:54.000 --> 00:32:02.000
これは、最後に再生されるコンテンツに関連付けられた識別子と、再生が移行されたときのコンテンツ内のオフセットを表します。

00:32:02.000 --> 00:32:06.000
リスナーがすぐにスキップした場合、これを使用してリスナーの味覚プロファイルを更新することができます。

00:32:06.000 --> 00:32:12.000
しかし、この場合、offsetInMillisの値でわかるように、私はその曲のかなりの部分を聴きました。

00:32:12.000 --> 00:32:17.000
だから、あなたのサービスは、少なくともその相対的な評価を下げないように、私がおそらくそれを気に入ったと仮定するかもしれません。

00:32:17.000 --> 00:32:29.000
また、キューAPIの他のエンドポイントと同様に、ユーザー情報データがサービスが状態を回復し、この情報を迅速に処理するのに役立つ場合に備えて、ユーザーアクティビティオブジェクトが完全に表示されます。

00:32:29.000 --> 00:32:32.000
サービスが使用できるより高度な機能もあります。

00:32:32.000 --> 00:32:42.000
たとえば、コンテンツが再生中に再生間隔レポートを要求して、特定のポイントに到達したこと、または特定の繰り返し間隔が経過するたびに知ることができます。

00:32:42.000 --> 00:32:50.000
iOSデバイスがHomePodで再生を制御するときに、特定のMPRemoteCommandCenterコマンドのレポートを有効にして受信できます。

00:32:50.000 --> 00:32:57.000
likeTrackと dislikeTrackのリモートコマンドは、更新メディアアフィニティインテント処理と同じではないことに注意してください。

00:32:57.000 --> 00:33:02.000
それらは音声の意図ではなく、家のどこにでもあるiOSデバイスからの簡単なタップです。

00:33:02.000 --> 00:33:11.000
以前、新しいキューを返すことについて説明しましたが、更新されたバージョンのオブジェクトを返すことで、再生中にユーザーアクティビティオブジェクトを更新することもできます。

00:33:11.000 --> 00:33:17.000
これは、アクティビティ定義を含むカスタム制御スキームの先ほど見た例です。

00:33:17.000 --> 00:33:27.000
デフォルトのコントロールには、60秒のplayElapsedIntervalが含まれています。つまり、コントロール属性を持たないコンテンツアイテムが再生されると、60秒ごとにレポートが生成されます。

00:33:27.000 --> 00:33:36.000
しかし、広告の制御属性を持つアイテムの場合、コンテンツの5秒が経過するとすぐにレポートが生成され、10秒ごとに別のレポートが生成されます。

00:33:36.000 --> 00:33:42.000
仕様で定義されているレポート間隔にはいくつかの制限があります。

00:33:42.000 --> 00:33:51.000
レポートはサービスに多くのデータを提供しますが、何百万人ものリスナーが意図を処理するため、サービスでそのコンテキストを追跡することは高価になる可能性があります。

00:33:51.000 --> 00:33:59.000
セッションコンテキストをサービスに提供して、キューの再生とインテント処理のエンドポイントコンテキストをブリッジすることができます。

00:33:59.000 --> 00:34:05.000
セッションコンテキストは、HomePodが現在サービスからメディアを再生している場合にのみ利用できます。

00:34:05.000 --> 00:34:18.000
特定のコンテンツが好きだとSiriに伝えると、レポートセクションで説明されているnowPlayingオブジェクトがすべてのレポートで送信されるのと同じように、インテントサービスエンドポイントはplayerContextオブジェクトを受け取ります。

00:34:18.000 --> 00:34:24.000
プレイヤーコンテキストには、コンテンツ、キュー、ユーザーアクティビティの persistentIdentifier 値が含まれます。

00:34:24.000 --> 00:34:41.000
これらは、私が以前に導入した3つのレベルの定義を網羅しています。潜在的に長寿命のリスニングセッションを定義するActivity persistentIdentifier、キューは、現在のリスナーの経験と、意図解決時に現在再生されている特定のコンテンツを定義します。

00:34:41.000 --> 00:34:48.000
このアイテムはインテントメディア検索オブジェクトにも搭載されており、すでにiOSデバイスでの使用に精通している可能性があります。

00:34:48.000 --> 00:34:58.000
更新アクティビティエンドポイントを実装する必要性を回避し、より複雑なレポートイベントを処理するために、セッションコンテキストがサービスに十分な情報であるかどうかを検討してください。

00:34:58.000 --> 00:35:08.000
この例では、UpdateMediaAffinityIntentHandlingのリクエストでは、HomePodはすでにサービスからキューを再生していたため、playerContextオブジェクトがインテントエンドポイントに提供されます。

00:35:08.000 --> 00:35:16.000
セッションオブジェクト内では、サービスが現在再生されていない場合は、playerContextまたはnull値が見つかります。

00:35:16.000 --> 00:35:27.000
サービスのテイストプロファイルがメディアアフィニティと再生メディアリクエストによってのみ明示的に駆動される場合、プレーヤーコンテキストは完全なレポートを実装せずにすべての要件を処理する場合があります。

00:35:27.000 --> 00:35:35.000
しかし、サービスがこれらのツールの味覚プロファイル情報を使用する前に、すべてのリクエストで送信された使用の制約も尊重する必要があります。

00:35:35.000 --> 00:35:41.000
家庭では、あなたのサービスが知り、尊重しなければならない異なる種類の文脈意識があります。

00:35:41.000 --> 00:35:46.000
各HomePodは、サービスに制約を形成する特定のオプションで設定できます。

00:35:46.000 --> 00:35:53.000
たとえば、子供部屋のHomePodには、結果から露骨なコンテンツを除外するオプションがあるかもしれません。

00:35:53.000 --> 00:35:58.000
このHomePodでリクエストが行われるたびに、露骨なコンテンツを返すべきではありません。

00:35:58.000 --> 00:36:06.000
しかし、設定が有効になっていない寝室のHomePodへのリクエストは、露骨なコンテンツを返すことを許可する必要があります。

00:36:06.000 --> 00:36:07.000
制約はオプションではありません。

00:36:07.000 --> 00:36:11.000
あなたのサービスは、提示された制約の影響に従わなければなりません。

00:36:11.000 --> 00:36:22.000
私の家のゲストが何らかのコンテンツを再生するように頼んだとき、彼らはあなたのサービスにリクエストすることができ、彼らは一時的に私のアカウントを使用しますが、この相互作用は私の好みのプロフィールに影響を与えるべきではありません。

00:36:22.000 --> 00:36:32.000
Siriは私がどのように聞こえるかかなり良い考えを持っているので、私たちは要求が私によって行われたものではないことを検出し、私の味覚プロファイルを変更するためにこの要求を使用しないようにあなたのサービスに伝えます。

00:36:32.000 --> 00:36:39.000
制約値は、サービスのアカウント設定の既存の制限をさらに制限する必要があります。

00:36:39.000 --> 00:36:47.000
サービスに同様の制限に対するアカウント固有のコントロールがある場合は、これらを組み合わせて、リスナーがサービスに期待するものを提供する必要があります。

00:36:47.000 --> 00:36:53.000
セッションオブジェクトと制約定義で始まるインテント要求のもう1つの例を次に示します。

00:36:53.000 --> 00:37:00.000
それらは小さな物体ですが、あなたのサービスが家庭環境でどのように相互作用するかに大きな影響を与えます。

00:37:00.000 --> 00:37:13.000
updateUserTasteProfileは、この意図の解決が、好き、嫌い、再生数、および私のアカウントに関連付けられているサービスの目に見えるリスニング履歴を追跡するために使用されるかどうかを示すブール制約です。

00:37:13.000 --> 00:37:20.000
虚偽の場合、サービスは、使用されるアカウントが再生を制御または開始する人のアカウントであると仮定することはできません。

00:37:20.000 --> 00:37:28.000
また、このHomePodは、私の声を認識しても、私のアカウントの味覚プロファイルに決して貢献しないように設定されている可能性があるため、虚偽である可能性があります。

00:37:28.000 --> 00:37:35.000
私がファミリールームにHomePodを持っていて、定期的に小さな子供たちに代わって音楽を演奏するように頼んでいると想像してみてください。

00:37:35.000 --> 00:37:42.000
このオプションを設定する方法がなければ、私のお気に入りの音楽ステーションは私が好きなよりもかなり折衷的かもしれません。

00:37:42.000 --> 00:37:47.000
allowExplicitContentは、HomePodとホームアプリごとの設定を反映する別のブール制約です。

00:37:47.000 --> 00:37:52.000
そして、あなたのサービスは、意図からの結果で明示的なコンテンツをフィルタリングするためにそれを考慮する必要があります。

00:37:52.000 --> 00:38:07.000
実際、検索に一致する非明示的なコンテンツがないために特定のインテント要求を満たすことができない場合、ResolvedMediaItemメソッドの特定のエラー結果はSiriKit Media Intentsで提供されます。

00:38:07.000 --> 00:38:10.000
最後に、ハードウェアにも制約があります。

00:38:10.000 --> 00:38:14.000
キューセグメントは有限サイズのみで、その値はデバイスごとに動的です。

00:38:14.000 --> 00:38:20.000
キューがこの値より大きい場合は、この制限に準拠するためにセグメント化されたキューイディオムを実装する必要があります。

00:38:20.000 --> 00:38:24.000
最小サイズは、セグメントごとに100個のコンテンツアイテムです。

00:38:24.000 --> 00:38:28.000
今日はたくさん取り上げましたが、それをすべて消化するのにしばらく時間がかかるかもしれません。

00:38:28.000 --> 00:38:32.000
アクセスできたら、仕様をさらに詳しく調べることをお勧めします。

00:38:32.000 --> 00:38:37.000
今日取り上げたすべてのエンドポイントについて詳しく説明します。

00:38:37.000 --> 00:38:48.000
この仕様には、実装する必要があるサービスエンドポイントのオープンAPI定義があり、サービスを開発する際に基本的なデータモデルの解析と検証コードを生成するのに十分完全です。

00:38:48.000 --> 00:38:50.000
それはとても役に立ちます。

00:38:50.000 --> 00:38:56.000
Cloud Extension APIの定義は、新しいリリースごとにiOS SiriKit Media APIの変更を追跡します。

00:38:56.000 --> 00:39:03.000
ほんの数例外を除いて、デバイス上のSiriKit Media APIを通じて利用可能なほとんどすべてのものは、Cloud Extension APIを通じて利用可能です。

00:39:03.000 --> 00:39:10.000
また、キューAPIは、強力な再生定義、制御、レポートをサービスに直接提供します。

00:39:10.000 --> 23:59:59.000
SiriKit Media Intentsにご関心をお寄せいただきありがとうございます。今後のSiriKit Media APIの変更については、developer.apple.com/siriで最新の情報を入手してください。

