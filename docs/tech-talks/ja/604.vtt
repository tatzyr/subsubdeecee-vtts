WEBVTT

00:00:01.000 --> 00:00:11.000
このプレゼンテーションでは、レンダリングパス内でインラインでコンピューティング機能を提供するAppleのA11 GPUの新しいプログラム可能なステージであるタイルシェーディングに焦点を当てます。

00:00:11.000 --> 00:00:15.000
タイルシェーディングは、Metal 2のまったく新しいレベルのパフォーマンスと効率を可能にします。

00:00:15.000 --> 00:00:22.000
レンダリングとコンピューティング操作は、より高い帯域幅と低消費電力のタイルメモリを介してデータを共有できるようになりました。

00:00:22.000 --> 00:00:25.000
タイルシェーディングはイメージブロックと深く統合されています。

00:00:25.000 --> 00:00:34.000
イメージブロックのコンテンツを分析したり、そのコンテンツを要約したり、シーンの途中でイメージブロックを保存したり、イメージブロックのレイアウトを変更したりすることもできます。

00:00:34.000 --> 00:00:43.000
タイルシェーディングもスレッドグループメモリと緊密に統合されており、後のタイルまたはフラグメントステージのタイル定数データをキャッシュするために使用できます。

00:00:43.000 --> 00:00:47.000
タイルシェーディングの必要性を動機づけることから始めましょう。

00:00:47.000 --> 00:00:51.000
レンダーパス間の計算の実行は、近年より一般的になっています。

00:00:51.000 --> 00:00:59.000
たとえば、タイル繰延レンダリングおよびフォワードレンダリングアルゴリズムは、シェーディングコストを削減するために、スクリーン整列タイルに対してライトを交差させます。

00:00:59.000 --> 00:01:11.000
これらのアルゴリズムの背後にある考え方は、すべてのライトがすべてのピクセルに影響を与えるわけではありませんが、ピクセルあたりの淘汰は高すぎる可能性があるため、タイル領域のコストを償却します。

00:01:11.000 --> 00:01:23.000
以前はMetal for AシリーズGPUでは、コンピューティングミッドレンダリングを実行するには、コンピューティングパスがそれを消費できるように、タイルメモリにキャッシュされたレンダリングターゲットデータをデバイスメモリに保存する必要がありました。

00:01:23.000 --> 00:01:29.000
コンピュートは、レンダリングが再開される前に、結果をデバイスのメモリに保存する必要があります。

00:01:29.000 --> 00:01:36.000
ローカルメモリと外部メモリ間のこの繰り返されるデータ移動は、帯域幅集約的です。

00:01:36.000 --> 00:01:46.000
Metal 2とA11 GPUを使用すると、このようなアルゴリズムは、コンピューティングパスの代わりにタイルシェーディングを使用して、露出したタイルメモリ内でのみ動作できるようになりました。

00:01:46.000 --> 00:01:50.000
レンダリングターゲットコンテンツは、一度タイルメモリにキャッシュされるようになりました。

00:01:50.000 --> 00:02:01.000
その後、タイルシェーディングはイメージブロックで直接動作し、その結果をスレッドグループメモリにすることもできます。これは、レンダリングによって後で使用するためにタイルメモリによってバックアップされます。

00:02:01.000 --> 00:02:10.000
タイルシェーダーがタイルメモリ内でより頻繁に操作できるようにする方法を見たので、タイルシェーディングがドローとどのように相互作用するかを詳しく見てみましょう。

00:02:10.000 --> 00:02:18.000
コンピューティングパス内のスレッドの起動はディスパッチと呼ばれ、Metalはレンダリングパス内のタイルシェーディング操作に同じ名前を採用します。

00:02:18.000 --> 00:02:24.000
タイルディスパッチは、ドローと自由にインターリーブすることができ、API提出順序で実行されます。

00:02:24.000 --> 00:02:31.000
金属は、そのディスパッチが実行されたときに、ディスパッチ前に発行されたドローの結果が見えることを保証します。

00:02:31.000 --> 00:02:38.000
同様に、Metalは、次のドローまたはディスパッチが実行されたときに各ディスパッチの結果が表示されることを保証します。

00:02:38.000 --> 00:02:42.000
この同期保証は、タイルメモリへのレースフリーアクセスを可能にします。

00:02:42.000 --> 00:02:46.000
しかし、引き分けの間にはそのような保証はありません。

00:02:46.000 --> 00:02:52.000
タイルシェーディングのもう1つの重要な概念は、スレッドがスレッドグループとグリッドにどのように編成されるかです。

00:02:52.000 --> 00:02:58.000
従来のコンピューティングディスパッチでは、スレッドグループはぎっしり詰まったグリッドに編成されます。

00:02:58.000 --> 00:03:06.000
ただし、レンダリングパス内では、タイルグリッドはパス全体で一定ですが、スレッドグループのサイズはディスパッチごとに異なる場合があります。

00:03:06.000 --> 00:03:16.000
タイルを拡大すると、各スレッドを一意のピクセルにマッピングしたり、各スレッドを複数のピクセルにマッピングしたりできることがわかります。

00:03:16.000 --> 00:03:20.000
しかし、スレッドからリソースへのマッピングは、Metalにとって特別な意味はありません。

00:03:20.000 --> 00:03:28.000
以前に説明したライトカリングの例の場合のように、ピクセルへのマッピングがまったくないスレッドを起動できます。

00:03:28.000 --> 00:03:35.000
その例では、スレッドグループのサイズは、交差点テストが必要なライトの数と一致する可能性があります。

00:03:35.000 --> 00:03:40.000
タイルシェーディングスレッドグループは、存在するジオメトリに関係なく、タイルごとに起動されます。

00:03:40.000 --> 00:03:46.000
たとえば、タイルのサブセットに影響を与える三角形は、それらのタイルによってのみ処理する必要があります。

00:03:46.000 --> 00:03:51.000
ただし、その後のタイルディスパッチは、画面のすべてのタイルによって処理されます。

00:03:51.000 --> 00:03:59.000
そのディスパッチは、それらのタイルに着地できる後のジオメトリのタイルメモリを初期化している可能性があるため、そうすることは重要です。

00:03:59.000 --> 00:04:02.000
ビューポートとシザー状態は、タイルのシェーディングも制限しません。

00:04:02.000 --> 00:04:06.000
一般に、タイルシェーディングは従来のレンダリング状態の影響を受けません。

00:04:06.000 --> 00:04:12.000
さて、タイルシェーディングをサポートするAPIの変更に目を向けましょう。

00:04:12.000 --> 00:04:18.000
レンダリングパスは、イメージブロックの寸法を決定する3つのタイルサイズのいずれかで設定できます。

00:04:18.000 --> 00:04:29.000
ほとんどの場合、A11 GPUで32KBであるイメージブロックに適合する最大のタイルサイズを選択して、GPUのプリミティブ処理段階のオーバーヘッドを最小限に抑えます。

00:04:29.000 --> 00:04:40.000
ただし、一部のアルゴリズムは、シェーダーコアのタイル並列性の量を増やすために、フラグメントまたはタイル処理が特に複雑な場合に、より小さなタイルサイズを選択することで恩恵を受ける場合があります。

00:04:40.000 --> 00:04:49.000
すでに見たように、スレッドグループメモリもタイルメモリから供給されるため、サイズによってタイルサイズの選択が制限される可能性があります。

00:04:49.000 --> 00:04:53.000
タイルシェーディングパイプラインの作成は、従来のパイプラインの作成に似ています。

00:04:53.000 --> 00:04:58.000
パイプライン記述子に関数をアタッチして、パイプライン状態を作成します。

00:04:58.000 --> 00:05:02.000
タイルシェーディングのために、Metalは新しいパイプライン記述子タイプを導入します。

00:05:02.000 --> 00:05:08.000
既存のレンダリングパイプライン記述子に似ていますが、ブレンドなどのレンダリング状態プロパティを削除します。

00:05:08.000 --> 00:05:14.000
また、バインドできる関数は1つしかないため、既存の計算パイプライン記述子にも似ています。

00:05:14.000 --> 00:05:19.000
ただし、その関数は、計算カーネルまたはフラグメント関数のいずれかです。

00:05:19.000 --> 00:05:24.000
計算カーネルは、これまでに説明したすべてのタイルシェーディングとイメージブロック機能へのアクセスを提供します。

00:05:24.000 --> 00:05:31.000
フラグメントベースのタイルシェーディングはより限られていますが、後で説明する具体的で重要な役割を果たします。

00:05:31.000 --> 00:05:36.000
まず、タイルパイプラインのイメージブロック機能に触れたいと思います。

00:05:36.000 --> 00:05:45.000
タイルシェーディングはレンダリングとインラインで計算ディスパッチを実行するため、フラグメント関数と同様に、暗黙の画像ブロックと明示的な画像ブロックの両方にアクセスできます。

00:05:45.000 --> 00:05:51.000
ただし、フラグメント関数とは異なり、カーネルベースのタイルシェーダーはイメージブロック全体にアクセスできます。

00:05:51.000 --> 00:05:54.000
構文を見てみましょう。 

00:05:54.000 --> 00:06:01.000
2番目のテンプレート引数を使用して、テンプレート化されたイメージブロックタイプの暗黙的な形式と明示的な形式を曖昧にします。

00:06:01.000 --> 00:06:05.000
それぞれが異なるアクセスセマンティクスを持っているため、曖昧さを解消する必要があります。

00:06:05.000 --> 00:06:12.000
暗黙の形式には値のセマンティクスがあります。つまり、画像ブロックのインと外にピクセルをコピーします。

00:06:12.000 --> 00:06:19.000
明示的な形式には、前回のプレゼンテーションで説明した参照セマンティクスがあります。

00:06:19.000 --> 00:06:27.000
レンダリングパス内のイメージブロックがタイルの存続期間中どのように持続するか、そしてこれを活用してドローとディスパッチ間で通信する方法をすでに見てきました。

00:06:27.000 --> 00:06:32.000
冒頭の例では、スレッドグループメモリにも同じことが当てはまることにも言及しました。

00:06:32.000 --> 00:06:40.000
永続的なスレッドグループメモリは、タイルシェーディングに固有であり、淘汰されたライトリストなど、タイル全体に一定のデータを格納するのに適しています。

00:06:40.000 --> 00:06:44.000
これをシェーディング言語でどのように活用するかを見てみましょう。

00:06:44.000 --> 00:06:51.000
この例では、カーネルベースのタイル関数は、そのタイル境界に対して淘汰するための完全なライトリストが提供されています。

00:06:51.000 --> 00:06:57.000
また、以前のタイルディスパッチからのタイルの最小深さと最大深さも与えられています。

00:06:57.000 --> 00:07:04.000
次に、淘汰された結果をスレッドグループメモリに配置し、後のフラグメントシェーダーがアクセスできるようにします。

00:07:04.000 --> 00:07:11.000
タイルディスパッチとフラグメント描画の両方が、スレッドグループバインドポイントに一致する必要があります。

00:07:11.000 --> 00:07:15.000
最後に、フラグメントベースのタイルパイプラインが果たす役割を考えてみましょう。

00:07:15.000 --> 00:07:21.000
タイルシェーディングは、以前は複数のパスだったものをマージすることで、タイルメモリを活用することを奨励します。

00:07:21.000 --> 00:07:27.000
タイルメモリは貴重なリソースであるため、より多くのデータをそのスペースにパックするには、明示的な画像ブロックが必要です。

00:07:27.000 --> 00:07:38.000
しかし、パス全体の静的タイルメモリレイアウトはまだ適合しそうにないため、計算のさまざまな段階を移動する際に、タイルメモリレイアウトを柔軟に移行する必要があります。

00:07:38.000 --> 00:07:41.000
フラグメントベースのタイルパイプラインは、この移行を可能にします。

00:07:41.000 --> 00:07:48.000
先に説明したバリアセマンティクスは、移行が始まる前にすべてのタイルメモリアクセスが完了していることを保証します。

00:07:48.000 --> 00:07:55.000
また、フラグメントシェーダーはイメージブロックとの間でデータをコピーするため、各ピクセルがアトミックに遷移されるようにすることができます。

00:07:55.000 --> 00:07:58.000
例を見てみましょう。 例を見てみましょう。

00:07:58.000 --> 00:08:09.000
この例では、遅延レンダリングフェーズを終了し、マルチレイヤーアルファブレンディングと呼ばれるおおよその順序に依存しない透明度技術を実装するためにイメージブロックを再構成したいと考えています。

00:08:09.000 --> 00:08:17.000
古いレイアウトを入力として受け取り、新しいレイアウトを返すフラグメントベースのタイル関数を使用します。

00:08:17.000 --> 00:08:23.000
また、よくあることですが、古いレイアウトのデータを使用して新しいレイアウトを初期化する必要があることがよくあります。

00:08:23.000 --> 00:08:29.000
ここでは、繰延レンダリングフェーズから最終的な点灯値を持ち込みます。

00:08:29.000 --> 00:08:33.000
タイルのシェーディングをよりよく理解するために、サンプルコードを必ず確認してください。

00:08:33.000 --> 00:08:37.000
これは、1回のパスで多くのライトで効率的にシェードを前進させる方法を示しています。

00:08:37.000 --> 00:08:42.000
タイルシェーディングは、タイルに影響を与えないライトを淘汰するために使用されます。

00:08:42.000 --> 00:08:50.000
最後に、XcodeのGPUデバッガを使用すると、シェーダーでの使用方法に基づいてデータをフォーマットすることで、スレッドグループメモリを簡単に検査できます。

00:08:50.000 --> 00:08:59.000
XcodeのGPUデバッガでキャプチャした後、バインドされたリソースビューのタイルセクションで各スレッドグループメモリをバッファとして見ることができます。

00:08:59.000 --> 00:09:07.000
そこから、バッファビューアを使用して、シェーダーが使用するのと同じ方法でフォーマットされたデータを検査できます。

00:09:07.000 --> 00:09:18.000
このプレゼンテーションでは、タイルシェーディングにより、開発者がタイルの内容全体を分析および操作し、ドロー間で通信し、さまざまな計算段階を通じてタイルメモリを再利用する方法を見ました。

00:09:18.000 --> 00:09:29.000
まとめると、タイルシェーダーは、A11 GPUのより高い帯域幅と低電力のタイルメモリをよりよく活用するために、開発者が複数のレンダリングとコンピューティングパスをマージすることを可能にします。

00:09:29.000 --> 00:09:38.000
メタル2の詳細とサンプルコードへのリンクについては、開発者のウェブサイト（developer.apple.com/metal）をご覧ください。

00:09:38.000 --> 23:59:59.000
見てくれてありがとう!

