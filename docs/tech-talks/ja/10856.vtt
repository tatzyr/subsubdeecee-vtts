WEBVTT

00:00:01.000 --> 00:00:11.000
こんにちは。私の名前はCharles Circlaeysです。この講演では、レンダリングループのコミットフェーズでアニメーションヒッチのスクロールに飛び込みます。

00:00:11.000 --> 00:00:14.000
iOSはレンダリングループを使用してビューを表示します。

00:00:14.000 --> 00:00:24.000
タッチイベントはアプリに送信され、ビューを変更して応答し、それらのビューはiOSによってディスプレイにレンダリングされます。

00:00:24.000 --> 00:00:30.000
レンダリングループのコミットフェーズでアニメーションヒッチを見つけて修正することに焦点を当てます。

00:00:30.000 --> 00:00:40.000
レンダリングループ全体とヒッチについて学ぶには、ビデオ「UIアニメーションヒッチとレンダリングループを探索する」をご覧ください。

00:00:40.000 --> 00:00:44.000
まず、コミットトランザクションを定義するものを調べます。

00:00:44.000 --> 00:00:48.000
楽器を使ってヒッチを見つける...

00:00:48.000 --> 00:00:52.000
そして、コミットヒッチを回避するための推奨事項を共有します。

00:00:52.000 --> 00:00:54.000
コミットトランザクションを定義することから始めましょう。

00:00:54.000 --> 00:01:01.000
ここでは、現在イベントを待っているアプリビュー階層の例があります。

00:01:01.000 --> 00:01:10.000
タッチイベントを受信すると、ビューがそれに応答し、一部のサブビューの背景色またはフレームを変更してイベントを処理します。

00:01:10.000 --> 00:01:18.000
システムは、これらのサブビューが次のコミットトランザクション中にレイアウトまたは表示を必要とすることを記録します。

00:01:18.000 --> 00:01:28.000
コミットトランザクション中に、表示またはレイアウトが必要なビューは、drawRectまたはlayoutSubviewsを呼び出すことで、それに応じて更新されます。

00:01:28.000 --> 00:01:32.000
コミットトランザクション中のさまざまなフェーズを見てみましょう。 コミットトランザクション中に関連するさまざまなフェーズを見てみましょう。

00:01:32.000 --> 00:01:41.000
レイアウトフェーズ、表示フェーズ、準備フェーズ、最後にコミットフェーズの4つのステップがあります。

00:01:41.000 --> 00:01:46.000
レイアウトフェーズでは、レイアウトが必要なビューごとにlayoutSubviewsが呼び出されます。

00:01:46.000 --> 00:01:56.000
ビューの位置を変更したり、ビューを追加または削除したり、ビューのsetNeedsLayoutを明示的に呼び出したりすることで、必要なレイアウトをマークできます。

00:01:56.000 --> 00:02:01.000
表示フェーズでは、表示が必要なすべてのビューに対してdrawRectが呼び出されます。

00:02:01.000 --> 00:02:11.000
drawRectをオーバーライドするビュー階層にビューを追加するか、setNeedsDisplayを明示的に呼び出すことで、表示が必要であることを示すことができます。

00:02:11.000 --> 00:02:18.000
準備段階では、まだデコードされていない画像は、このステップでデコードされます。

00:02:18.000 --> 00:02:23.000
この種の操作は、大きな画像にはかなりの時間がかかることがあります。

00:02:23.000 --> 00:02:31.000
また、画像がGPUが直接作業できないカラー形式の場合、このステップで変換されます。

00:02:31.000 --> 00:02:40.000
これには、画像にポインタを送信する代わりに画像をコピーする必要があり、追加の時間とメモリがかかります。

00:02:40.000 --> 00:02:48.000
アプリ内の画像の最適化の詳細については、「画像とグラフィックスのベストプラクティス」ビデオをご覧ください。

00:02:48.000 --> 00:02:56.000
最後に、コミットフェーズでは、ビュー階層が再帰的にパッケージ化され、レンダリングサーバーに送信されます。

00:02:56.000 --> 00:03:01.000
ディープビュー階層はパッケージ化に時間がかかることに注意してください。

00:03:01.000 --> 00:03:10.000
コミットトランザクションの詳細を説明したので、2番目のトピックに移りましょう。インストゥルメントでヒッチを見つける。

00:03:10.000 --> 00:03:16.000
Xcode 12では、アプリのヒッチをプロファイリングするための新しいインストゥルメントテンプレートをリリースしました。

00:03:16.000 --> 00:03:23.000
これは、検出されたヒッチングフレームのレンダリングループを視覚化して調査するのに役立ちます。

00:03:23.000 --> 00:03:26.000
アプリの例でいくつかのヒッチを見てみましょう。

00:03:26.000 --> 00:03:31.000
アプリケーションでスクロールすると、Instrumentsにトレースを記録します。

00:03:31.000 --> 00:03:43.000
ここでは、スクロールパフォーマンスの記録があり、検出されたすべてのヒッチを見ることができます。

00:03:43.000 --> 00:03:48.000
ヒッチ16を詳しく見てみましょう。

00:03:48.000 --> 00:03:56.000
左側には、フレームの作成に必要なレンダリングループフェーズに対応するすべてのトラックが表示されます。

00:03:56.000 --> 00:04:01.000
ヒッチトラックは、ヒッチとその持続時間を示しています。

00:04:01.000 --> 00:04:08.000
ユーザーイベントトラックは、ヒッチングフレームで受信したユーザーイベントを表示します。

00:04:08.000 --> 00:04:14.000
コミットトラックは、コミットフェーズと、このフェーズ中にコミットしたプロセスを示します。

00:04:14.000 --> 00:04:22.000
パトリックは、「レンダリングフェーズでのヒッチを解明し、排除する」で、レンダリングとGPUトラックについて詳しく説明します。

00:04:22.000 --> 00:04:28.000
Frame Lifetimesトラックは、ヒッチングフレームを構成するための全期間を示します。

00:04:28.000 --> 00:04:36.000
内蔵ディスプレイトラックには、VSYNCイベントとともに表示されたすべてのフレームが表示されます。

00:04:36.000 --> 00:04:46.000
フレームの寿命とヒッチ期間の開始を比較して、フレームが表示の準備ができているはずの予想される間隔を視覚化できます。

00:04:46.000 --> 00:04:49.000
この間隔は許容レイテンシと呼ばれます。

00:04:49.000 --> 00:04:53.000
その後のすべての時間はヒッチ持続時間です。

00:04:53.000 --> 00:04:59.000
トラックの下には、ヒッチトラックが選択されているときにヒッチの詳細なメトリックを見ることができます。

00:04:59.000 --> 00:05:06.000
私たちのデモアプリには多くのヒッチがありますが、ここではヒッチ16に焦点を当てています。

00:05:06.000 --> 00:05:09.000
ヒッチの持続時間を見ることができます...

00:05:09.000 --> 00:05:12.000
許容可能なレイテンシ...

00:05:12.000 --> 00:05:15.000
そしてヒッチタイプ。

00:05:15.000 --> 00:05:22.000
ヒッチタイプは、フレームが遅れた段階と調査を開始する場所のヒントを得るのに便利です。

00:05:22.000 --> 00:05:31.000
この例では、選択したヒッチングフレームがコミットとGPUフェーズによって引き起こされたことがわかります。

00:05:31.000 --> 00:05:43.000
コミットフェーズでどのコードに時間がかかりすぎているかを見つけたいのですが、ありがたいことに、アニメーションヒッチテンプレートにはタイムプロファイラが含まれているので、このヒッチが発生したときにどのコードが実行されているかを確認できます。

00:05:43.000 --> 00:05:50.000
ここから、調査したい間隔を選択し、コミットしていたプロセスを検索できます。

00:05:50.000 --> 00:05:54.000
このプロセスのメインスレッドを選択できます...

00:05:54.000 --> 00:05:58.000
そして、そのコールツリーを表示します。

00:05:58.000 --> 00:06:02.000
これで、どの通話が高価になるかを分析することができます。

00:06:02.000 --> 00:06:14.000
このコールツリーはコミットトランザクションに由来することが確認でき、QSTEM CollectionViewCellのupdateTagsと呼ばれるメソッド内で約10ミリ秒を費やしたことを示しています。

00:06:14.000 --> 00:06:17.000
このアプリに何が入っているか見てみましょう。

00:06:17.000 --> 00:06:32.000
一般的なCollectionViewで構成されており、各セルにはUIImageViewを使用した写真のサムネイル、UILabelを使用したテキスト、カスタムTagLabelビューを使用したタグが表示されます。

00:06:32.000 --> 00:06:40.000
QSTEM CollectionViewCellクラスの実装と、より具体的には、このメソッドが呼び出されている場所を見てみましょう。

00:06:40.000 --> 00:06:45.000
ここでは、メニュー項目にプロパティオブザーバーがあることがわかります。

00:06:45.000 --> 00:06:54.000
このプロパティオブザーバーは、2つのシナリオでupdateTagsを呼び出します。有効な menuItem が設定されたか、nil に設定されました。

00:06:54.000 --> 00:06:58.000
最初のシナリオでは、表示したいタグの配列を解析します。

00:06:58.000 --> 00:07:03.000
2番目のシナリオでは、空の配列を解析して、残りのタグを削除します。

00:07:03.000 --> 00:07:08.000
では、updateTagsメソッドの実装を見てみましょう。

00:07:08.000 --> 00:07:15.000
予想通り、空のタグ配列の場合、ビュー階層からすべてのビューを削除します。

00:07:15.000 --> 00:07:19.000
それ以外の場合は、必要に応じてStackViewを作成します。

00:07:19.000 --> 00:07:24.000
次に、タグごとに既存のタグラベルを作成または再利用します。

00:07:24.000 --> 00:07:33.000
その後、このセルの以前の使用で新しいセルよりも多くのタグがあった場合に備えて、既存の未使用のタグラベルを削除します。

00:07:33.000 --> 00:07:41.000
呼び出し範囲に戻り、物事がどのように実装されているかについてより良い知識を得た今、潜在的な問題を見てみましょう。

00:07:41.000 --> 00:07:48.000
QSTEM CollectionViewCellは、セルが再利用のためにキューから解除されたときに呼び出されるprepareForReuseメソッドを上書きします。

00:07:48.000 --> 00:07:52.000
そして、この方法では、menuItemをnilに設定します。

00:07:52.000 --> 00:08:04.000
そうすると、2番目のシナリオが発生し、再利用実装ロジックを利用せずに、セルビュー階層から以前のすべてのタグラベルが削除されます。

00:08:04.000 --> 00:08:15.000
これは、キューから外されたセルごとに、以前のラベルサブビューをすべて削除し、すべてのラベルを表示するために必要なすべてのビューを再確認することを意味します。

00:08:15.000 --> 00:08:19.000
これは最適ではなく、ヒッチを引き起こしている可能性があります。

00:08:19.000 --> 00:08:22.000
これに対する解決策は非常に簡単です。

00:08:22.000 --> 00:08:28.000
menuItemをクリアする必要はなく、prepareForReuseメソッドを実装から削除するだけです。

00:08:28.000 --> 00:08:37.000
これで、新しいセルメニューアイテムを設定すると、再利用可能なロジックを活用し、高価なビュー階層操作を回避できます。

00:08:37.000 --> 00:08:46.000
修正後に新しいトレースを記録すると、最初のトレースと比較して検出されたヒッチの数が大幅に改善されることがわかります。

00:08:46.000 --> 00:08:53.000
インスツルメントのタイムプロファイラは、どのコードが時間がかかりすぎてヒッチを引き起こしているかを見つけるのに非常に役立ちました。

00:08:53.000 --> 00:08:59.000
タイムプロファイラーの詳細については、「インストゥルメントでのタイムプロファイラの使用」ビデオをご覧ください。

00:08:59.000 --> 00:09:07.000
Instrumentsでアプリケーションをプロファイリングする方法を学んだ後、コミットフェーズでのヒッチを回避するための推奨事項について話し合いましょう。

00:09:07.000 --> 00:09:10.000
ルール1は、ビューを軽量に保つことです。

00:09:10.000 --> 00:09:21.000
これを行うには、GPUアクセラレーションされたCALayerで利用可能なプロパティをできるだけ活用し、CPUカスタム描画を避けるようにしてください。

00:09:21.000 --> 00:09:25.000
それが正当化される場合は、必ずそのパフォーマンスを測定してください。

00:09:25.000 --> 00:09:35.000
システムは余分な作業を行う必要があるため、drawRectの空の実装は避けてください。これにより、次のトランザクション中に追加の時間とメモリの使用が必要になります。

00:09:35.000 --> 00:09:42.000
追加と削除などの高価なビュー階層操作を避けるために、ビューをできるだけ再利用するようにしてください。

00:09:42.000 --> 00:09:51.000
ビューの削除に関連して、アニメーション中に特定のビューの表示を停止する必要がある場合は、ビュープロパティ「非表示」を利用してみてください。

00:09:51.000 --> 00:09:53.000
これはずっと安いです。

00:09:53.000 --> 00:09:58.000
ルール2は、高価で冗長なレイアウトを減らすことです。

00:09:58.000 --> 00:10:02.000
レイアウトを更新する必要がある場合にのみ、setNeedsLayoutに頼るようにしてください。

00:10:02.000 --> 00:10:07.000
layoutIfNeededは、現在のトランザクションの寿命を消費し、ヒッチを引き起こす可能性があります。

00:10:07.000 --> 00:10:11.000
ほとんどの場合、レイアウトを更新するために次の実行ループを待つことができます。

00:10:11.000 --> 00:10:17.000
これを解決するための複雑さを増さないように、最小数の制約を使用するようにしてください。

00:10:17.000 --> 00:10:25.000
最後に、ビューは自分自身またはその子のみを無効にし、その兄弟またはその親ビューは無効にはなりません。

00:10:25.000 --> 00:10:29.000
それ以外の場合、ビューのレイアウトは再び再帰的に無効になります。

00:10:29.000 --> 00:10:38.000
パフォーマンスレイアウトと画像とグラフィックスのベストプラクティスの詳細については、以下の2つのWWDCトークを見ることをお勧めします。

00:10:38.000 --> 00:10:49.000
コミットトランザクションパイプラインを理解したので、高価なコミットを回避できます。Instrumentsの新しいAnimation Hitchesテンプレートを使用して、ヒッチを検出して調査できます。

00:10:49.000 --> 00:11:03.000
prepareForReuseが追加の作業を行わないようにし、ビュー階層を浅く軽量に保ち、高価で冗長なレイアウトを避けるなど、コミットヒッチを防止するためのいくつかの戦略を学びました。

00:11:03.000 --> 00:11:13.000
また、ビデオ「レンダリングフェーズでのヒッチの謎を解除して排除する」で、レンダリングループの次のフェーズについて必ず学んでください。

00:11:13.000 --> 23:59:59.000
ありがとうございます。

