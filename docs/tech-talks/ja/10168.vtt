WEBVTT

00:00:00.000 --> 00:00:06.000
こんにちは、私の名前はアリです。カスタムインテントをアプリインテントに移行する方法について話すことに興奮しています。

00:00:06.000 --> 00:00:18.000
このビデオでは、新しいApp Intentsフレームワークを採用すべき理由、下位互換性を含む移行の仕組み、実際にApp Intentsに変換する方法について説明します。

00:00:18.000 --> 00:00:24.000
まず、アプリインテントを採用すべき理由と、それが以前のフレームワークとどのように異なるかを取り上げましょう。

00:00:24.000 --> 00:00:38.000
2016年にSiriKit Intentsフレームワークを導入しました。これには、メッセージング、ワークアウト、電話などの一般的なユースケースに完全なユーザーエクスペリエンスを提供する一連の目的主導のシステムインテントが付属しています。

00:00:38.000 --> 00:00:48.000
次に、あらゆるユースケースに対して独自のインテントを定義できるカスタムインテントを導入し、アプリの機能をSiri、ショートカット、および提案にもたらしました。

00:00:48.000 --> 00:00:54.000
また、ウィジェットの設定と予測にカスタムインテントを使用するWidgetKitを追加しました。

00:00:54.000 --> 00:01:03.000
WWDC22では、アプリからシステムにインテントを提供する新しいSwiftネイティブフレームワークであるApp Intentsを導入しました。

00:01:03.000 --> 00:01:09.000
App Intentsは、モダンでパワフルでユーザーにとって簡単であるため、採用するのに最適なフレームワークです。

00:01:09.000 --> 00:01:14.000
Swift用にネイティブに設計されているため、モダンです。

00:01:14.000 --> 00:01:20.000
最新の言語機能のおかげで、同じ機能をサポートするために劇的に少ないコードを書くことができます。

00:01:20.000 --> 00:01:26.000
また、インテント定義ファイルを維持し、コード生成を使用する必要性を排除しました。

00:01:26.000 --> 00:01:30.000
また、スニペットを軽量のSwiftUIビューとして提供できるようになりました。

00:01:30.000 --> 00:01:35.000
エンティティとクエリにより深いユースケースが可能になったため、強力です。

00:01:35.000 --> 00:01:41.000
拡張機能を提供せずに、アプリのプロセスでApp Intentsを直接実行できます。

00:01:41.000 --> 00:01:46.000
そして、人々があなたの意図を設定して実行するときに、ユーザーエクスペリエンスをカスタマイズする新しい機会があります。

00:01:46.000 --> 00:01:49.000
人々が使うのも簡単です。

00:01:49.000 --> 00:01:56.000
意図は、セットアップなしですぐに使用可能なアプリショートカットとして簡単に公開できます。

00:01:56.000 --> 00:02:05.000
さらに、Spotlightの上部とアプリに含めることができるSiriのヒントに表示されるため、ショートカットを発見するための新しい方法があります。

00:02:05.000 --> 00:02:13.000
新しいフレームワークのすべての利点を得るには、Siri用に構築したカスタムインテントとアプリインテントへのショートカットをアップグレードする必要があります。

00:02:13.000 --> 00:02:16.000
SiriKitの意図はまだ完全にサポートされています。

00:02:16.000 --> 00:02:25.000
したがって、メッセージングやメディアなどのSiriドメインを構築している場合、またはWidgetKitでインテントを使用している場合は、そのままにしておく必要があります。

00:02:25.000 --> 00:02:32.000
App Intentsフレームワークの詳細については、WWDC22のセッション「Dive into App Intents」をご覧ください。

00:02:32.000 --> 00:02:43.000
また、SiriやSpotlightからアプリの機能を非常に簡単に使用できるApp Shortcutsの詳細については、「App IntentsでApp Shortcutsを実装する」をチェックしてください。

00:02:43.000 --> 00:02:45.000
次に、移行を取り上げましょう。

00:02:45.000 --> 00:02:52.000
移行では、Xcodeでワンクリックで既存のインテント定義をアプリインテントに変換できます。

00:02:52.000 --> 00:02:57.000
同じアプリバイナリでiOS 15とiOS 16の両方をサポートできます。

00:02:57.000 --> 00:03:03.000
また、人々の既存のショートカットを有効にして、新しいアプリインテントで作業を続けることができます。

00:03:03.000 --> 00:03:12.000
インテント定義をアプリインテントに変換するには、インテント定義ファイルに移動し、[アプリインテントに変換]ボタンを押すだけです。

00:03:12.000 --> 00:03:17.000
Xcodeは、古いインテント定義と同等のApp Intentsコードを生成します。

00:03:17.000 --> 00:03:21.000
次に、古いコンテンツハンドラコードをリファクタリングすることで、コードに入力できます。

00:03:21.000 --> 00:03:25.000
これについては、次のセクションで詳しく説明します。

00:03:25.000 --> 00:03:34.000
アプリがApp Intentsにアップグレードしたときに人々がシームレスな体験をできるように、システムは古い意図から新しい意図へのマッピングを自動的に処理します。

00:03:34.000 --> 00:03:36.000
それがどのように機能するかについて話しましょう。

00:03:36.000 --> 00:03:45.000
CustomIntentMigratedAppIntentプロトコルを採用するだけで、システムは古いインテントと新しいインテントの間で変換する方法を知るのに十分な情報を持つことになります。

00:03:45.000 --> 00:03:54.000
このプロトコルを採用すると、古いカスタムインテントに使用されたクラス名であるインテントクラス名プロパティを提供します。

00:03:54.000 --> 00:03:57.000
ほとんどの場合、これを自分で提供する必要はありません。

00:03:57.000 --> 00:04:03.000
[App Intentに変換]ボタンを使用すると、結果のコードはすでにこのプロトコルを採用しています。

00:04:03.000 --> 00:04:10.000
App Intentの移行機能のため、App IntentsにアップグレードするためにアプリがiOS 16をターゲットにするまで待つ必要はありません。

00:04:10.000 --> 00:04:16.000
実際、同じアプリバイナリで新しいオペレーティングシステムと古いオペレーティングシステムの両方を簡単にサポートできます。

00:04:16.000 --> 00:04:21.000
これを行うには、レガシーインテントハンドラとアプリインテントの両方をアプリに含めます。

00:04:21.000 --> 00:04:27.000
コード共有を最大化するには、両方のインテントハンドラを共通のビジネスロジックのセットに考慮します。

00:04:27.000 --> 00:04:36.000
移行されたApp Intentプロトコルを採用すると仮定すると、アプリに両方のセットを含めると、ショートカットは自動的にインテントの重複排除になります。

00:04:36.000 --> 00:04:47.000
したがって、iOS 15以前では、ショートカットアプリはレガシーインテントの実装のみを表示します。iOS 16以降では、アプリインテントの実装のみが表示されます。

00:04:47.000 --> 00:04:56.000
最小展開ターゲットをiOS 16以降に切り替えると、移行したインテントのレガシーインテントハンドラと定義を安全に削除できます。

00:04:56.000 --> 00:04:59.000
それらはもはや必要ありません。

00:04:59.000 --> 00:05:09.000
移行時に考えるべきことの1つは、人々があなたの古い意図に依存する既存のショートカットを持っているということです。これは、ショートカットアプリで作成したか、アプリの「Siriに追加」ボタンを使用して追加した可能性があります。

00:05:09.000 --> 00:05:17.000
良いニュースは、これらのショートカットは、移行されたApp Intentプロトコルを採用している限り、新しいApp Intentsで動作し続けることです。

00:05:17.000 --> 00:05:24.000
人々のショートカットは、新しいアプリインテントを使用するために上書きされません。彼らは自動的に新しいインテントと古いインテントの両方で動作する共通のフォーマットを使用します。

00:05:24.000 --> 00:05:31.000
これが機能するためには、レガシーインテントとアプリインテントのスキーマが互換性がある必要があります。

00:05:31.000 --> 00:05:39.000
互換性があるためには、カスタムインテントとアプリインテントのパラメータが同じ名前と同等のタイプである必要があります。

00:05:39.000 --> 00:05:43.000
スキーマの互換性を壊すことなく行うことができるいくつかの変更があります。

00:05:43.000 --> 00:05:49.000
具体的には、パラメータを追加または削除したり、既存のパラメータを非オプションにしたりできます。

00:05:49.000 --> 00:05:56.000
Xcodeでスキーマの互換性を確認するには、パラメータのリストがある古いインテント定義ファイルをチェックしてください。

00:05:56.000 --> 00:05:59.000
各パラメータには名前と型があります。

00:05:59.000 --> 00:06:03.000
インスペクタペインには、インテントのクラス名のフィールドもあります。

00:06:03.000 --> 00:06:13.000
App Intentsコードで作業するときは、インテントクラス名がインテント定義ファイルにあったものと一致していることを確認してください。そうすれば、システムは新しいインテントが古いインテントと同等であると考えることができます。

00:06:13.000 --> 00:06:19.000
そして、App Intentsコードのパラメータ名とタイプが互換性を維持していることを確認してください。

00:06:19.000 --> 00:06:24.000
繰り返しになりますが、Xcodeの「App Intentsに変換」ボタンは自動的にスキーマの互換性を保証します。

00:06:24.000 --> 00:06:29.000
したがって、このツールを使用して変更を加えなければ、良い状態になります。

00:06:29.000 --> 00:06:34.000
次に、既存のインテントを実際にアプリインテントに変換する方法について話しましょう。

00:06:34.000 --> 00:06:37.000
インテントを移行するには2つのステップがあります。

00:06:37.000 --> 00:06:43.000
ステップ1はインテント定義ファイルを移行し、ステップ2はコードを移行することです。

00:06:43.000 --> 00:06:45.000
意図の定義から始めましょう。

00:06:45.000 --> 00:06:51.000
私はスープの大ファンで、スープを注文できるスープシェフというサンプルアプリがあります。

00:06:51.000 --> 00:06:59.000
それは、注文するスープの数、追加するトッピング、ピックアップまたは配達場所のパラメータで注文する意図を持っています。

00:06:59.000 --> 00:07:07.000
これをApp Intentsに変換する準備ができているので、XcodeのIntent定義ファイルに移動し、変換ボタンを押します。

00:07:07.000 --> 00:07:11.000
次に、変換する意図を選択します。この場合のみです。

00:07:11.000 --> 00:07:16.000
次に、新しいインテントコードを保存する場所と、それを含めるターゲットを選択します。

00:07:16.000 --> 00:07:21.000
私が追加した場合、それは私のアプリターゲットまたはアプリインテント拡張ターゲットである可能性があります。

00:07:21.000 --> 00:07:25.000
この場合、アプリのターゲットと時計のターゲットもチェックします。

00:07:25.000 --> 00:07:28.000
アプリの意図をフレームワークターゲットに追加することはできません。

00:07:28.000 --> 00:07:32.000
次に、Xcodeが生成したApp Intentsコードを見ていきます。

00:07:32.000 --> 00:07:40.000
インテント定義ファイルに含まれていたすべてのインテント、列挙型、およびカスタムタイプを表すいくつかのファイルで分割されています。

00:07:40.000 --> 00:07:46.000
移行された私の古い意図定義のいくつかの特定の分野に注意を喚起したいと思います。

00:07:46.000 --> 00:07:51.000
新しいコードには、App Intentプロトコルに準拠したorderSoup構造体があります。

00:07:51.000 --> 00:07:56.000
この構造は、iOS 16以降で利用可能としてマークされていることに注意してください。

00:07:56.000 --> 00:08:04.000
iOS 16より前にアプリを展開する場合は、App Intentsフレームワークを使用するすべてのコードにその注釈を適用する必要があります。

00:08:04.000 --> 00:08:12.000
私のインテント定義ファイルの各パラメータは、そのメタデータとともに、App Intent構造の@Parameter宣言に移行されました。

00:08:12.000 --> 00:08:18.000
すべてのショートカットアプリのパラメータサマリーは、このパラメータサマリー宣言に移行されました。

00:08:18.000 --> 00:08:26.000
以前はパラメータ関係として表現されていたものを、ParameterSummaryのSwitch、Case、またはWhenステートメントを使用して表現できるようになりました。

00:08:26.000 --> 00:08:33.000
私のスープとトッピングのカスタムタイプは、後で記入する必要があるいくつかのToDoを含むアプリエンティティになりました。

00:08:33.000 --> 00:08:36.000
OrderDetailsは一時的なアプリエンティティになりました。

00:08:36.000 --> 00:08:42.000
後で検索するために使用できる一意の識別子がないため、一時的と見なされます。

00:08:42.000 --> 00:08:46.000
そして、私のOrderTypeカスタム列挙型は、アプリ列挙型になりました。

00:08:46.000 --> 00:08:52.000
人間が読める名前は、ケース表示表現に移行されました。

00:08:52.000 --> 00:08:59.000
最後に、インテントレスポンスのすべてのダイアログがIntentDialogの拡張機能に移行されました。

00:08:59.000 --> 00:09:02.000
これらのダイアログは、私の実行方法に使用できます。

00:09:02.000 --> 00:09:13.000
移行者は必要以上に多くの文字列を生成する可能性があるので、「確認するために、あなたは\（スープ）が欲しかったですか？」のように、古いインテントハンドラで実際に使用されていないものが表示された場合は、それらを自由に削除してください。

00:09:13.000 --> 00:09:18.000
インテント定義を移行したので、インテント処理コードを移行しましょう。

00:09:18.000 --> 00:09:26.000
自動生成されたApp Intentには、記入する必要があることを指摘するto-doを持つperform()メソッドのプレースホルダがあることに注意してください。

00:09:26.000 --> 00:09:28.000
それを行う方法を見てみましょう。 

00:09:28.000 --> 00:09:34.000
古いフレームワークでは、インテント定義ファイルと一連のインテント処理コードを提供しました。

00:09:34.000 --> 00:09:38.000
新しいフレームワークでは、すべてがコードで表されます。

00:09:38.000 --> 00:09:42.000
古いインテント定義のパラメータはすでに新しいコードに移行されています。

00:09:42.000 --> 00:09:51.000
古いコードの解決、確認、および処理メソッドは、インテントが実行されたときに呼び出される単一の実行メソッドに組み合わせる必要があります。

00:09:51.000 --> 00:09:57.000
また、カスタムタイプと動的オプションをエンティティとクエリにリファクタリングする必要があります。

00:09:57.000 --> 00:10:03.000
それでは、解決から始めて、インテント処理の各フェーズを移行する方法を見てみましょう。

00:10:03.000 --> 00:10:10.000
解決フェーズでは、インテントハンドラーはインテントの各パラメータを検証し、必要に応じてユーザーに値を求めます。

00:10:10.000 --> 00:10:18.000
解決方法を移行するときは、可能な限りApp Intentsの新しい自動解決動作を利用する必要があります。

00:10:18.000 --> 00:10:22.000
それ以外の場合は、解決ロジックをperformメソッドにリファクタリングする必要があります。

00:10:22.000 --> 00:10:25.000
いくつかの例を見てみましょう。 ではいくつかの例を見てみましょう。

00:10:25.000 --> 00:10:28.000
これがスープパラメータの古い分解方法です。

00:10:28.000 --> 00:10:32.000
これは、古い意図フレームワークの一般的なパターンに従います。

00:10:32.000 --> 00:10:34.000
スープのパラメータを開封してみてください。

00:10:34.000 --> 00:10:39.000
Nilの場合、曖昧さ回避を使用してスープを選ぶようにユーザーに求める解決結果を返します。

00:10:39.000 --> 00:10:45.000
設定されている場合は、成功して解決結果を返し、すでに指定されているのと同じスープを返します。

00:10:45.000 --> 00:10:51.000
自動解決のおかげで、この種の定型本はApp Intentsでは不要になりました。

00:10:51.000 --> 00:10:57.000
以前にこの方法で解決されたパラメータがある場合、新しい機能を利用する方法は次のとおりです。

00:10:57.000 --> 00:11:06.000
デフォルトでは、移行されたパラメータはオプションですが、タイプを非オプションに変更することで自動解決動作を取得できます。

00:11:06.000 --> 00:11:16.000
パラメータを非オプションにすると、App Intentsは、SoupAppEntityのクエリから提案されたエンティティを使用して、空の場合、自動的にユーザーに値を尋ねます。

00:11:16.000 --> 00:11:27.000
次に、パラメータ宣言にダイアログを追加して、解決システムが「どのスープが欲しいですか?」などの値を求めるときに、ユーザーが特定の質問をするようにします。

00:11:27.000 --> 00:11:31.000
これを行うと、このパラメータの解決コードはもう必要ありません。

00:11:31.000 --> 00:11:44.000
他のすべてのタイプの解決については、解決の実装をperform（）メソッドの上部に移動し、APIの使用状況を変更して、適切な新しいAPIを使用してユーザーに説明を求める必要があります。

00:11:44.000 --> 00:11:58.000
たとえば、数量の古い解決方法が数量をアンラップし、欠落している場合はneedsValueをスローし、数量が実際に利用可能なスープの数よりも大きいかどうかを確認し、その場合はエラーを返します。

00:11:58.000 --> 00:12:06.000
このコードをApp Intentsに移動すると、数量パラメータを非オプションにできるため、最初の部分がまったく必要なくなります。

00:12:06.000 --> 00:12:18.000
その2番目の部分では、サポートされていない解決結果で完了ハンドラを引き起こしたコードを取り、十分なスープの在庫がないことを示すエラーをスローするコードに置き換えたいと思います。

00:12:18.000 --> 00:12:25.000
エラーとカスタムローカライズされた文字列リソースコンバーチブルプロトコルに準拠して、エラーを列挙型として定義する必要があります。

00:12:25.000 --> 00:12:30.000
そうすれば、このケースがヒットしたときにユーザーに話されたり表示されたりするダイアログを提供できます。

00:12:30.000 --> 00:12:39.000
この例のように動的に返されたコードとneedsValueの結果が使われていた場合は、needsValueErrorをスローするコードに置き換えることができます。

00:12:39.000 --> 00:12:48.000
needsValueErrorをスローすると、システムは指定したダイアログで値をユーザーに促し、最初から実行メソッドを再度実行します。

00:12:48.000 --> 00:12:52.000
もう1つのオプションは、requestValueメソッドを使用することです。

00:12:52.000 --> 00:12:59.000
requestValueを使用すると、ユーザーに値を要求し、最初からやり直すことなくperformingメソッドを実行し続けることができます。

00:12:59.000 --> 00:13:08.000
requestValueメソッドに加えて、以前のAPI使用を置き換えるために使用できるrequestDisambiguationメソッドとrequestConfirmationメソッドもあります。

00:13:08.000 --> 00:13:11.000
次は確認について話しましょう。

00:13:11.000 --> 00:13:19.000
確認は、追加の検証を行い、システムがユーザーに続行することを確認するように依頼するための情報を提供する機会です。

00:13:19.000 --> 00:13:25.000
検証のために、確認メソッドにあったすべての検証ロジックを実行メソッドに移動する必要があります。

00:13:25.000 --> 00:13:30.000
ユーザーに確認を求めるために、新しいシンプルなrequestConfirmation() APIがあります。

00:13:30.000 --> 00:13:33.000
新しいAPIは、単一のメソッド呼び出しにすぎません。

00:13:33.000 --> 00:13:40.000
Async/awaitを使用すると、このメソッドはユーザーが確認するまで待ってから実行メソッドを続行します。

00:13:40.000 --> 00:13:46.000
キャンセルすると、エラーがスローされ、実行メソッドの実行が停止します。

00:13:46.000 --> 00:14:07.000
requestConfirmationメソッドには、Siriが話したり表示したりするダイアログ、スニペットに表示されるSwiftUIビュー、確認ボタンに使用されるラベル（この場合は順序）、ダイアログをプロンプトとして画面に表示するかどうかを制御するshowPrompt引数など、確認プロンプトに影響を与えるいくつかの引数が含まれています。

00:14:07.000 --> 00:14:12.000
ダイアログとビューに互いに同じ情報が含まれている場合、これはfalseに設定する必要があります。

00:14:12.000 --> 00:14:16.000
だから、Siriが対話を話すが、それを示さないのは理にかなっています。

00:14:16.000 --> 00:14:18.000
次に、ハンドルを見てみましょう。

00:14:18.000 --> 00:14:25.000
ハンドルをリファクタリングするには、コードをハンドルメソッドから実行メソッドに移動するだけです。

00:14:25.000 --> 00:14:32.000
解決、確認、および処理がすべて1つのメソッドで行われるため、古いハンドルメソッドからいくつかの検証コードを削除できるはずです。

00:14:32.000 --> 00:14:42.000
たとえば、ハンドルから古いコードをコピーした場合、オプションではなくなったパラメータをアンラップするためのコードになり、削除できる可能性があります。

00:14:42.000 --> 00:14:46.000
実行メソッドの最後に、インテント結果を返す必要があります。

00:14:46.000 --> 00:14:53.000
結果には、Siriが話すためのダイアログや表示するスニペットビューなど、さまざまなフィールドを含めることができます。

00:14:53.000 --> 00:15:05.000
それぞれでは、ダイアログのProvidesDialogやSwiftUIスニペットビューのShowSnippetViewなど、適切なプロトコルを使用して、実行メソッドの戻り値タイプに注釈を付ける必要があります。

00:15:05.000 --> 00:15:08.000
最後に、動的オプションの移行を見てみましょう。

00:15:08.000 --> 00:15:13.000
パラメータの種類に応じて、クエリまたはDynamicOptionsProviderに入力する必要があります。

00:15:13.000 --> 00:15:18.000
Xcodeは、あなたが記入する必要があるこれらの場所でToDoを提供します。

00:15:18.000 --> 00:15:31.000
クエリの場合、識別子、検索可能な場合は文字列、およびユーザーがショートカットでそのパラメータをタップしたときに表示される提案されたエンティティのセットでエンティティを返すメソッドを実装する必要があります。

00:15:31.000 --> 00:15:36.000
動的オプションの場合は、resultsメソッドのすべてのオプションを返すだけです。

00:15:36.000 --> 00:15:37.000
そして、それだけです!

00:15:37.000 --> 00:15:40.000
App Intentsへの移行が完了しました。

00:15:40.000 --> 00:15:45.000
あなたが本当に終わる前に、私が見ることをお勧めするものがいくつかあります。

00:15:45.000 --> 00:15:47.000
1つ目は、アプリのショートカットを採用することです。

00:15:47.000 --> 00:15:54.000
これにより、あなたの意図を発見可能にし、Siriにいくつかの単語を言うだけで人々がそれらを使用できるようにします。

00:15:54.000 --> 00:16:01.000
SiriのヒントをUIに追加して、アプリの機能を使うためにSiriに何を言うべきかを人々が学ぶことができます。

00:16:01.000 --> 00:16:04.000
これらは、以前に持っていた「Siriに追加」ボタンに取って代わるはずです。

00:16:04.000 --> 00:16:15.000
アプリの以前のバージョンでショートカットを作成し、アプリの新しいバージョンで正しく動作することをテストして、顧客のアップグレードパスをテストしてください。

00:16:15.000 --> 00:16:19.000
また、アプリが複数のロケールで動作する場合は、ローカリゼーションについて考えてください。

00:16:19.000 --> 00:16:32.000
アプリインテントをローカライズするには、アプリインテントに含まれるすべての文字列をローカライズされた文字列リソースとして提供する必要があり、それらの文字列を含む対応するローカライズ可能な.stringsファイルを提供することでローカライズできます。

00:16:32.000 --> 00:16:37.000
複数形の文字列を使用する場合は、.strings dict ファイルを使用することもできます。

00:16:37.000 --> 00:16:50.000
App Shortcutsをローカライズするときは、文字列をAppShortcuts.stringsというファイルに追加し、それらの文字列内の変数を${ }表記に置き換えます。

00:16:50.000 --> 00:17:01.000
要約すると、iOS 16の新機能とApp Intentsの新しいよりシンプルな開発モデルのすべての利点を得るために、カスタムIntentsをApp Intentsにアップグレードすることをお勧めします。

00:17:01.000 --> 00:17:07.000
人々がアプリの機能を簡単に発見して使用できるように、アプリのショートカットを追加してください。

00:17:07.000 --> 00:17:16.000
また、優れたユーザーエクスペリエンスをまとめる方法の詳細については、WWDC22の「デザインアプリショートカット」セッションをご覧ください。

00:17:16.000 --> 23:59:59.000
ありがとうございます。

