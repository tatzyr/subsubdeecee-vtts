WEBVTT

00:00:00.000 --> 00:00:05.000
こんにちは、「一様型識別子の再導入」へようこそ。

00:00:05.000 --> 00:00:10.000
私の名前はジョナサン・グリンスパンで、アップルのアプリディスカバリーとエンゲージメントチームで働いています。

00:00:10.000 --> 00:00:16.000
前回、統一型識別子について話したのはWWDC 2004でした。

00:00:16.000 --> 00:00:21.000
それはずいぶん前のことですが、昨日のことのように覚えています。

00:00:21.000 --> 00:00:35.000
Appleの2004年の製品ラインナップは、PowerBook G4の全アルミニウムデザイン、iPod Miniの目を見張るような色、iMac G5の魔法のホームシアター体験などの製品で、クラシックでクールでした。

00:00:35.000 --> 00:00:42.000
アップルは素晴らしいままですが、2004年は本当にずっと前だったことを認めなければなりません。

00:00:42.000 --> 00:00:50.000
そこで、今日は、Appleのオペレーティングシステムがファイルの種類をどのように決定するかから始めて、基本について説明します。

00:00:50.000 --> 00:00:57.000
次に、知らない新しいファイルタイプと、それらを処理する方法をシステムに伝える方法を探ります。

00:00:57.000 --> 00:01:05.000
最後に、iOS 14とmacOS Big Surで、ファイルタイプの操作を簡単にする新しいAPIを探ります。

00:01:05.000 --> 00:01:11.000
あなたがその主題に慣れていないかどうかにかかわらず、私たちはあなたのために何かを持っているので、近くにいてください。

00:01:11.000 --> 00:01:17.000
誰かのコンピュータにある可能性のあるファイルを見てみましょう。iPad Miniを使用している猫の写真です。

00:01:17.000 --> 00:01:22.000
その画像をディスクに保存すると、通常のファイルと呼ばれるものが生成されます。

00:01:22.000 --> 00:01:26.000
これは、ディスクに保存されている一連のバイトのPOSIX用語です。

00:01:26.000 --> 00:01:34.000
後で、この写真をもう一度開きたい場合は、ダブルクリックすると、プレビューのような画像ビューアで開きます。

00:01:34.000 --> 00:01:44.000
しかし、システムは、これがテキストファイルやMP3トラック、Pagesドキュメントではなく、JPEGとして保存された画像であることをどのように知っていますか?

00:01:44.000 --> 00:01:54.000
ファイルはバイトのシーケンスであるため、システムがファイルの種類を知る必要があるときに、それをクラックして開き、内部のビットを読み取りてそれを把握することを期待するかもしれません。

00:01:54.000 --> 00:02:03.000
実際、システムは非常に高価であり、ほとんどのプロセスが持っていない読み取り権限を必要とするため、システムはほとんどそれをしません。

00:02:03.000 --> 00:02:09.000
実際、オペレーティングシステムの決定のほとんどは、ファイルのパス拡張に基づいています。

00:02:09.000 --> 00:02:18.000
これは、空白や制御文字が含まれていない限り、最後のピリオド文字に続く大文字と小文字を正規化された部分文字列です。

00:02:18.000 --> 00:02:24.000
Appleのプラットフォームでは、通常、認識されたパス拡張機能をユーザーに表示しませんが、まだそこにあります。

00:02:24.000 --> 00:02:32.000
このファイルのパス拡張子を明らかにすると、J-P-E-Gであることがわかりますので、これはJPEG画像です。

00:02:32.000 --> 00:02:37.000
.jpegはJPEG画像を意味しますよね?

00:02:37.000 --> 00:02:41.000
はい、しかし、JPEG画像には他のパス拡張があります。

00:02:41.000 --> 00:02:45.000
.Jpgと.jpeが最も一般的です。

00:02:45.000 --> 00:02:48.000
しかし、ウェブ上では、それは別の話です。

00:02:48.000 --> 00:02:52.000
Webサーバーは通常、パスの拡張子でファイルを識別しません。

00:02:52.000 --> 00:02:57.000
代わりに、MIMEタイプまたはメディアタイプと呼ばれるものを使用します。

00:02:57.000 --> 00:03:01.000
JPEGの場合、それはimage/jpegです。

00:03:01.000 --> 00:03:11.000
もちろん、人生でそれほど単純なものはなく、一部のサーバーは代わりに一般的だが非標準の画像/jpg MIMEタイプを使用します。

00:03:11.000 --> 00:03:16.000
それは5つの異なるメタデータで、すべてまったく同じものを表しています。

00:03:16.000 --> 00:03:26.000
まあ、Appleのプラットフォームでは、このファイル形式を正規に識別するために、統一型識別子と呼ばれる単一の文字列を使用するので、それは大丈夫です。

00:03:26.000 --> 00:03:31.000
JPEG画像の場合、一様型識別子はpublic.jpegです。

00:03:31.000 --> 00:03:37.000
この1つの文字列は、ローカルであろうとウェブ上であろうと、すべてのJPEG画像を指します。

00:03:37.000 --> 00:03:41.000
さて、ファイルタイプの興味深い特性は、それらが階層に存在することです。

00:03:41.000 --> 00:03:49.000
すべてのJPEG画像は、PNG画像、TIFF画像などと同様に、より抽象的に画像です。

00:03:49.000 --> 00:03:57.000
統一型識別子について話すとき、JPEG型はより抽象的な画像型に準拠していると言います。

00:03:57.000 --> 00:04:01.000
この適合ツリーは暗黙的に複数の継承を可能にします。

00:04:01.000 --> 00:04:07.000
考えてみると、これはSwiftとObjective-Cでのプロトコルの仕組みのようなものです。

00:04:07.000 --> 00:04:11.000
具体的なクラスまたは構造体は、任意の数のプロトコルから継承できます。

00:04:11.000 --> 00:04:13.000
私の言いたいことをお見せしましょう。

00:04:13.000 --> 00:04:15.000
これがpublic.jpegです。

00:04:15.000 --> 00:04:22.000
そして、これはすべての画像ファイル形式を記述する抽象タイプであるpublic.imageです。

00:04:22.000 --> 00:04:27.000
しかし、すべての画像ファイル形式はバイトシーケンスとして表すことができます。

00:04:27.000 --> 00:04:39.000
したがって、public.imageはpublic.dataに準拠しています。これは、保存されている場所に関係なく、ディスク上の通常のファイル、または実際には任意のバイトシーケンスを表す非常に抽象的なタイプです。

00:04:39.000 --> 00:04:44.000
次に、public.dataは1つの最終的なタイプであるpublic.itemに準拠しています。

00:04:44.000 --> 00:04:54.000
ファイル、フォルダ、シンボリックリンク、またはPOSIXパイプなどのより難解なものであっても、すべてのファイルシステムオブジェクトは、public.itemで表されます。

00:04:54.000 --> 00:04:58.000
階層を上ることができるのと同じように、私たちはそれを下ることができます。

00:04:58.000 --> 00:05:07.000
public.pngやpublic.tiffなど、JPEG以外の画像形式があり、public.imageのサブタイプでもあります。

00:05:07.000 --> 00:05:11.000
ただし、public.jpegの適合階層の一部ではありません。

00:05:11.000 --> 00:05:13.000
彼らはただの兄弟です。

00:05:13.000 --> 00:05:24.000
レベルを上げてpublic.dataに焦点を当てると、コンピュータ上のほぼすべてのものがバイトシーケンスで表現できるため、それに準拠した多くのタイプがあることがわかります。

00:05:24.000 --> 00:05:33.000
ここでは、可聴音を記述する抽象的なタイプであるpublic.audioと、読みやすいテキストを記述する抽象的なタイプであるpublic.textが表示されます。

00:05:33.000 --> 00:05:39.000
それらはpublic.dataのサブタイプであり、public.imageの兄弟です。

00:05:39.000 --> 00:05:44.000
しばらく前に、均一な型識別子で複数の継承が可能であると述べました。

00:05:44.000 --> 00:05:55.000
そして、画像はデータですが、ユーザーが気にするコンテンツでもあり、ユーザーがiCloud Driveにアップロードしたり、AirDropで共有したりする可能性があるため、画像にも当てはまります。

00:05:55.000 --> 00:06:09.000
したがって、public.imageはpublic.contentにも準拠しており、ファイルシステムでは具体的なものを表すものではありませんが、そのサブタイプをユーザーにとって重要なものとして扱う必要があることを教えてくれます。

00:06:09.000 --> 00:06:13.000
私は、一様型識別子がファイルをどのように表すかにかなり重点を置いていました。

00:06:13.000 --> 00:06:17.000
ユーザーに関する限り、それはおそらく彼らにとって最も一般的な用途です。

00:06:17.000 --> 00:06:22.000
しかし、私たちは他の目的のためにも私たちのプラットフォーム全体でそれらを使用しています。

00:06:22.000 --> 00:06:26.000
たとえば、ペーストボードコンテンツの正規タイプとしても使用します。

00:06:26.000 --> 00:06:30.000
結局のところ、ディスクに保存できれば、コピーして貼り付けることもできます。

00:06:30.000 --> 00:06:34.000
また、ファイルとは関係のない階層にも使用します。

00:06:34.000 --> 00:06:41.000
これは少しAppleの秘密ですが、私たちはまた、私たちが出荷するハードウェアの異なるモデルを識別するために均一なタイプ識別子を使用しています。

00:06:41.000 --> 00:06:46.000
たとえば、すべてのMacモデルはcom.apple.macに準拠しています。

00:06:46.000 --> 00:06:56.000
また、仮説を立てたい場合は、一様型識別子を使用して、生命のツリーなど、コンピュータとは無関係の階層を参照することもできます。

00:06:56.000 --> 00:07:00.000
それが、統一型識別子とは何か、そして私たちのプラットフォームでそれらをどのように使用するかです。

00:07:00.000 --> 00:07:07.000
多くのアプリは独自のデータ形式を作成して維持しており、これらの形式は独自のタイプに値します。

00:07:07.000 --> 00:07:12.000
新しいタイプを作成するとき、どのようにタイプ階層に追加しますか?

00:07:12.000 --> 00:07:16.000
システムによって宣言された型を使用している場合は、多くのことをする必要はありません。

00:07:16.000 --> 00:07:23.000
/System/Library/CoreServicesのCoreTypesと呼ばれるバンドルに多数のタイプが含まれています。

00:07:23.000 --> 00:07:30.000
そのバンドルのInfo.plistの均一な型識別子は、追加の変更なしにアプリで参照できます。

00:07:30.000 --> 00:07:37.000
しかし、あなたが発明したタイプや、別のアプリから借りているタイプについては、それらについてシステムに伝える必要があるかもしれません。

00:07:37.000 --> 00:07:43.000
これを行うには、独自の統一型識別子を作成する必要があります。

00:07:43.000 --> 00:07:48.000
独自のユニフォーム型識別子を作成するときは、従うべきいくつかの命名規則があります。

00:07:48.000 --> 00:07:57.000
まず、一様型識別子は常に大文字と小文字を区別しないASCIIであり、com.example.fileなどのリバースDNSです。

00:07:57.000 --> 00:08:00.000
理想的には、より説明的な識別子を使用します。

00:08:00.000 --> 00:08:04.000
Com.example.fileは、デバッグが簡単ではありません。

00:08:04.000 --> 00:08:13.000
Com.example.imagetemplateまたはcom.example.encrypteddatabaseまたはそのようなものが良いでしょう。

00:08:13.000 --> 00:08:21.000
Appleは識別子にいくつかのプレフィックスまたは名前空間を留保しており、これらの名前空間を使用する独自の識別子を作成するべきではありません。

00:08:21.000 --> 00:08:24.000
あなたがそうするなら、システムはそれらを無視するかもしれません。

00:08:24.000 --> 00:08:29.000
1つ目は「パブリック」で、Appleが標準化されたタイプを宣言するために使用するために予約されています。

00:08:29.000 --> 00:08:35.000
標準化されたタイプが欠落している場合は、フィードバックアシスタントでお知らせください。

00:08:35.000 --> 00:08:42.000
Dynは、dynamicの略で、互換性のシムを生成するときにオペレーティングシステムで使用するために予約されています。

00:08:42.000 --> 00:08:49.000
それらは通常、不透明な文字列であり、OSリリース間で変更できるので、その値をハードコードしないでください。

00:08:49.000 --> 00:08:51.000
実際には、最近はかなりまれです。

00:08:51.000 --> 00:08:57.000
通常、パスの拡張子が認識されないファイルに遭遇した場合にのみ、それらが表示されます。

00:08:57.000 --> 00:09:03.000
Com.exampleは、テンプレート、例、サンプルコードなどのために予約されています。

00:09:03.000 --> 00:09:09.000
最後に、com.appleはAppleが使用するために予約されています。

00:09:09.000 --> 00:09:15.000
システムが認識するタイプをアプリケーションに追加する際には、幅広い手順が2つあります。

00:09:15.000 --> 00:09:17.000
最初のステップは、タイプを宣言することです。

00:09:17.000 --> 00:09:25.000
タイプを宣言することは、基本的にアプリが「このタイプは存在する」と言っていることを意味しますが、タイプを開くことができるという意味ではありません。

00:09:25.000 --> 00:09:33.000
実際にタイプを開きたい場合は、タイプをサポートする必要があります。これは、「誰がタイプを宣言しても、私はそれを開くことができます」というアプリの言い方です。

00:09:33.000 --> 00:09:37.000
この2つのステップは異なります。

00:09:37.000 --> 00:09:42.000
タイプを宣言するときは、インポートするかエクスポートするかを決める必要があります。

00:09:42.000 --> 00:09:50.000
他の誰かによって発明または設計されたタイプを使用している場合、または主に別のアプリケーションで使用する場合は、通常、そのタイプをインポートする必要があります。

00:09:50.000 --> 00:09:55.000
それはシステムに「このタイプは存在します。ここにそれに関するいくつかの情報があります。

00:09:55.000 --> 00:10:02.000
しかし、それを発明したアプリがインストールされている場合、そのアプリはより権威のある情報を提供できます。

00:10:02.000 --> 00:10:09.000
一方、タイプを発明した場合、またはアプリで特に使用する場合は、それをエクスポートするのが適切です。

00:10:09.000 --> 00:10:13.000
これは、「私はこのタイプに権威があります」とシステムに伝えます。

00:10:13.000 --> 00:10:20.000
最後に、コアタイプの一部としてシステムに同梱されているタイプを使用している場合は、インポートまたはエクスポートする必要はありません。

00:10:20.000 --> 00:10:28.000
システムはすでに宣言を提供しており、タイプのユニフォーム型識別子をすぐに使用できます。

00:10:28.000 --> 00:10:33.000
アプリでタイプを宣言する方法と、それを開くのをサポートするシステムを表示する方法を紹介したいと思います。

00:10:33.000 --> 00:10:39.000
それでは、私が真新しいレストランオーバーザウェブ体験に懸命に取り組んでいるXcodeを見てみましょう。

00:10:39.000 --> 00:10:46.000
このアプリは、私たちが設計したJSONベースの形式で保存されたレストランのメニューを読む機能を備えています。

00:10:46.000 --> 00:10:51.000
これらのメニューファイルをアプリで開けるようにしたいので、まずそれらのタイプを宣言する必要があります。

00:10:51.000 --> 00:10:58.000
このタイプを自分で作成し、フォーマットを所有しているため、タイプをエクスポートすることは理にかなっています。

00:10:58.000 --> 00:11:03.000
Xcodeで最初に行うことは、プロジェクト自体を選択して設定を明らかにすることです。

00:11:03.000 --> 00:11:06.000
アプリに対応するターゲットを選択したい。

00:11:06.000 --> 00:11:12.000
今、私はiOSアプリを見ていますが、macOSアプリで同じことをします。

00:11:12.000 --> 00:11:18.000
次に、アプリのInfo.plistファイルの内容を表す[情報]タブに切り替えます。

00:11:18.000 --> 00:11:21.000
エクスポートされたタイプ識別子のセクションを展開します。

00:11:21.000 --> 00:11:25.000
セクションの下部にある[追加]ボタンをクリックして、新しいタイプを追加します。

00:11:25.000 --> 00:11:32.000
最初に追加したいのは、私たちが思いついた統一型識別子です。

00:11:32.000 --> 00:11:37.000
このデモでは、com.example.restaurantmenuを使用します。

00:11:37.000 --> 00:11:42.000
com.exampleは、例やデモで使用するためにAppleによって予約されていることを忘れないでください。

00:11:42.000 --> 00:11:46.000
通常、所有している逆DNS名を使用したいと思うでしょう。

00:11:46.000 --> 00:11:53.000
たとえば、Claris社はcom.clarisを使用し、Beatsはcom.beatsbydreを使用します。

00:11:53.000 --> 00:11:58.000
今、私たちは適合性について考えなければなりません。

00:11:58.000 --> 00:12:11.000
ファイルシステム内のファイルを表すタイプは、通常のファイルの場合はpublic.data、つまりバイトシーケンス、またはオペレーティングシステムがファイルとして扱うべきディレクトリの場合はcom.apple.packageに準拠する必要があります。

00:12:11.000 --> 00:12:17.000
このタイプは、SwiftのJSONエンコーダを使用してディスクに保存されます。つまり、バイトのシーケンスです。

00:12:17.000 --> 00:12:22.000
それは通常のファイルを意味し、それはpublic.dataを意味します。

00:12:22.000 --> 00:12:24.000
私たちは決断しなければならないようです。

00:12:24.000 --> 00:12:30.000
これらのファイルにはJSONデータが含まれているため、JSONファイルを読み取ることができるものなら何でも読み取ることができます。

00:12:30.000 --> 00:12:34.000
つまり、このタイプはpublic.jsonにも準拠できるということです。

00:12:34.000 --> 00:12:39.000
これは、手動で編集する機能が重要ないくつかのファイルタイプにとって本当に便利なプロパティです。

00:12:39.000 --> 00:12:44.000
しかし、他のタイプでは、実装の詳細のみです。

00:12:44.000 --> 00:12:47.000
このタイプのpublic.jsonにコンフォーマンスを追加します。

00:12:47.000 --> 00:12:57.000
他の開発者に頼りたくない場合や、タイプが将来変更される可能性があると予想される場合は、タイプを作成するときに、これらの種類の実装の詳細をスキップできます。

00:12:57.000 --> 00:13:03.000
このファイルタイプは、ユーザーが直接対話する価値のある文書やコンテンツを検討するものです。

00:13:03.000 --> 00:13:08.000
だから、私たちはまた、それがpublic.contentに準拠していることを確認します。

00:13:08.000 --> 00:13:15.000
次に、タイプに関連付けるファイル名の拡張子を決定する必要があります。

00:13:15.000 --> 00:13:23.000
この拡張機能は、タイプをファイルシステムに結び付け、適切な名前のファイルにこのタイプがあることをシステムが認識できるようにします。

00:13:23.000 --> 00:13:31.000
3文字の拡張機能を使用したくなるかもしれませんが、1995年以来、主要なプラットフォームベンダーは3文字の拡張機能を必要としていません。

00:13:31.000 --> 00:13:37.000
ここには呼吸する余地がたくさんあり、他の開発者のタイプ宣言との競合を避けることが重要です。

00:13:37.000 --> 00:13:42.000
だから、私たちはより長い拡張、レストランメニューを使用します。

00:13:42.000 --> 00:13:43.000
私たちはそこに点を置かなかったことに注意してください。

00:13:43.000 --> 00:13:48.000
オペレーティングシステムは、ファイル名を作成するときに私たちのためにそれを追加することを知っています。

00:13:48.000 --> 00:13:53.000
最後に、これはこのタイプの人間が読める名前を思いつく良い機会でもあります。

00:13:53.000 --> 00:14:03.000
私たちのアプリは単にレストランと呼ばれ、拡張レストランメニューを選んだので、これをシンプルに保ち、レストランメニューと名付けます。

00:14:03.000 --> 00:14:07.000
この文字列は、InfoPlist.stringsファイルでローカライズ可能です。

00:14:07.000 --> 00:14:10.000
ローカライズするときは、入力した文字列をキーとして使用してください。

00:14:10.000 --> 00:14:15.000
タイプを宣言したので、アプリが開くことができることをシステムに伝える必要があります。

00:14:15.000 --> 00:14:18.000
ドキュメントタイプセクションを展開します。

00:14:18.000 --> 00:14:23.000
セクションの下部にある[追加]ボタンをクリックして、新しいサポートされているタイプを追加します。

00:14:23.000 --> 00:14:27.000
このセクションは、エクスポートされたタイプ識別子セクションよりも簡単です。

00:14:27.000 --> 00:14:33.000
指定する必要があるのは、アプリがサポートする統一型識別子のリストだけです。

00:14:33.000 --> 00:14:40.000
柔軟性を高めるために、ここで1つのエントリに複数のタイプを指定するか、エントリごとに1つずつ指定できます。

00:14:40.000 --> 00:14:47.000
私は個人的にエントリごとに1つのタイプを持つことを好みますが、それは主にタブとスペースのような個人的な好みの問題です。

00:14:47.000 --> 00:14:55.000
とにかく、このフィールドにユニフォームタイプ識別子を追加します。

00:14:55.000 --> 00:14:59.000
また、このエントリのハンドラーランクをオーナーに設定する必要があります。

00:14:59.000 --> 00:15:06.000
このステップは必須ではありませんが、システムが特定の仕事に適したアプリをインテリジェントに選択するのに役立つため、強くお勧めします。

00:15:06.000 --> 00:15:09.000
私たちがこのタイプを発明して以来、私たちはそれを所有しています。

00:15:09.000 --> 00:15:17.000
macOSでは、エディタまたはビューアとしてファイルを開くことができるかどうかを指定できる追加のルールフィールドがあります。

00:15:17.000 --> 00:15:22.000
編集者は特定のタイプのファイルを開いたり保存したりできますが、視聴者はファイルしか開くことができません。

00:15:22.000 --> 00:15:27.000
私たちのアプリはこれらのファイルを読み書きできるので、エディタを指定します。

00:15:27.000 --> 00:15:30.000
情報セクションの編集が完了しました。

00:15:30.000 --> 00:15:32.000
私たちのアプリは、レストランメニューファイルを開くことができるようになりました。

00:15:32.000 --> 00:15:40.000
システムが私たちに渡したら、ドキュメントを処理するために、SwiftUI、UIkit、またはAppKitコードを書く必要があります。

00:15:40.000 --> 00:15:49.000
Swift UIでドキュメントベースのアプリケーションを構築する方法の詳細については、WWDC20の「SwiftUIでドキュメントベースのアプリを構築する」をチェックしてください。

00:15:49.000 --> 00:15:58.000
UIkitとAppKitを使用してドキュメントベースのアプリケーションを構築するためのドキュメントは、developer.apple.comでオンラインで入手できます。

00:15:58.000 --> 00:16:01.000
私たちのアプリには、App Storeの競合他社であるCompy's Foodがあります。

00:16:01.000 --> 00:16:07.000
多くのレストランオーナーがそのアプリを使用し、そのアプリが所有するファイル形式でメニューを保存しています。

00:16:07.000 --> 00:16:10.000
また、これらのファイルの読み取りもサポートしたいと考えています。

00:16:10.000 --> 00:16:16.000
このタイプは他の誰かによって発明され、私たちはそれを借りているだけなので、輸出するのではなく輸入する必要があります。

00:16:16.000 --> 00:16:22.000
アプリターゲットの[情報]タブに戻り、[インポートされたタイプ識別子]を選択しましょう。

00:16:22.000 --> 00:16:27.000
新しいSwiftUIアプリを作成したため、ここに例タイプの既存のエントリがあることに注意してください。

00:16:27.000 --> 00:16:32.000
フォームの内容を独自のデータに置き換えることができます。そうします。

00:16:32.000 --> 00:16:38.000
ターゲットに既存の例の型がない場合は、もちろん、下の[追加]ボタンで新しい型を追加できます。

00:16:38.000 --> 00:16:42.000
Compy's Foodで指定された情報セクションに記入します。

00:16:42.000 --> 00:16:45.000
もちろん、ここでの詳細は例にすぎません。

00:16:45.000 --> 00:16:53.000
実際の競合他社のタイプのサポートを追加する場合は、Info.plistファイルに含まれているものと一致するように努力する必要があります。

00:16:53.000 --> 00:16:59.000
このタイプはインポートされるため、Compy's Foodアプリによって生成されるファイルの種類をシステムに伝えます。

00:16:59.000 --> 00:17:07.000
しかし、ユーザーがそのアプリをインストールしている場合、システムは宣言を好むことができ、より権威あるものとしてエクスポートする必要があります。

00:17:07.000 --> 00:17:13.000
ユーザーがそのうちの1つを開きたいときにシステムがアプリを選択できるように、これらのファイルを開くためのサポートを追加します。

00:17:13.000 --> 00:17:17.000
ドキュメントタイプセクションに戻ります。

00:17:17.000 --> 00:17:23.000
Compyの食品リストに別のエントリを作成し、新しいタイプ識別子を追加します。

00:17:23.000 --> 00:17:28.000
このエントリは、私たちがそのタイプの所有者ではないため、他のエントリとは少し異なります。

00:17:28.000 --> 00:17:32.000
代わりに、ハンドラーランクを代替にしたい。

00:17:32.000 --> 00:17:38.000
私たちのアプリはこれらのファイルを読むことはできますが、書き込むことはできないので、macOSでビューアの役割を指定します。

00:17:38.000 --> 00:17:47.000
システムは現在、このファイルを開くことができることを知っていますが、そのアプリがファイルタイプの所有者であるため、ユーザーがCompy's Foodをインストールしている場合、私たちは最良の選択ではないかもしれません。

00:17:47.000 --> 00:17:56.000
私たちはプラットフォーム上で善良な市民になりたいので、私たちのコードが競合他社のコードよりもはるかに優れていることを知っているにもかかわらず、このようにタイプの所有権を尊重することが重要です。

00:17:56.000 --> 00:18:03.000
独自のレストランメニュータイプと同様に、アプリでこれらのファイルを実際に読み込むには、SwiftまたはObjective-Cを書く必要があります。

00:18:03.000 --> 00:18:07.000
詳細については、developer.apple.comをチェックしてください。

00:18:07.000 --> 00:18:14.000
だから、タイプを宣言し、それをサポートしていることをシステムに伝えたので、コードでそのタイプを操作する時が来ました。

00:18:14.000 --> 00:18:21.000
このセクションでは、コアサービスフレームワークのユニフォームタイプ識別子のAPIに少なくとも広く精通していることを前提としています。

00:18:21.000 --> 00:18:25.000
ここでは、ディレクトリまたはファイルURLのセットを歩く小さなプログラムがあります。

00:18:25.000 --> 00:18:34.000
表現された各ファイルの統一型識別子を取得し、その型識別子のローカライズされた説明を出力します。

00:18:34.000 --> 00:18:41.000
ファイルが画像の場合はどこかに描画し、オーディオクリップの場合は、ユーザーのスピーカーまたはAirPodsで再生します。

00:18:41.000 --> 00:18:45.000
すぐに、ここに目に見えるいくつかの問題があります。

00:18:45.000 --> 00:18:51.000
グローバルUTType関数で使用するには、文字列をCFStringsに明示的にキャストする必要があります。

00:18:51.000 --> 00:18:57.000
また、UTTypeCopyDescriptionから取得したCFStringの寿命を手動で管理する必要があります。

00:18:57.000 --> 00:19:11.000
しかし、これについてお話しできることを大変うれしく思いますが、iOS 14とmacOS Big Surでは、ユニフォームタイプ識別子にファーストクラスのスウィフトネスをもたらす、まったく新しいユニフォームタイプ識別子フレームワークを導入しました。

00:19:11.000 --> 00:19:19.000
以前はCFStringsを使用して型識別子を表現していましたが、UTTypeを使用して型とそのプロパティを表現できるようになりました。

00:19:19.000 --> 00:19:24.000
このコードを順を追って、新しいフレームワークを使用するように変換しましょう。

00:19:24.000 --> 00:19:36.000
含まれているAPIにアクセスするためにフレームワークをインポートしました。今度は、タイプ識別子URLプロパティをcontentTypeに変更します。その値は新しい構造体UTTypeのインスタンスです。

00:19:36.000 --> 00:19:42.000
この構造体は、一様型識別子とそれに関するメタデータをカプセル化します。

00:19:42.000 --> 00:19:45.000
次に、この保持されていない値を修正します。

00:19:45.000 --> 00:19:48.000
UTTypeにはローカライズされた説明プロパティがあります。

00:19:48.000 --> 00:19:55.000
このようなプロパティは、型の属性とグローバル関数を操作するはるかに自然な方法です。

00:19:55.000 --> 00:20:02.000
このプロパティの値は、Xcodeで入力した説明文字列に対応し、アプリをローカライズするとローカライズされます。

00:20:02.000 --> 00:20:07.000
次に、別のグローバル関数であるUTTypeConformsToに目を向けましょう。

00:20:07.000 --> 00:20:12.000
この関数は、明示的なキャストを必要とするCFStringを取ります。

00:20:12.000 --> 00:20:16.000
当然のことながら、UTTypeにはconforms-to memberメソッドがあります。

00:20:16.000 --> 00:20:20.000
しかし、これらは何ですか: .imageと.audio?

00:20:20.000 --> 00:20:22.000
このスライドを覚えていますか？

00:20:22.000 --> 00:20:35.000
この新しいフレームワークを設計するとき、システムによって宣言されたタイプのセットと、古いAPIで公開されているCFString定数のセットを見て、それらを名前付き定数として新しいフレームワークに持ち込みました。

00:20:35.000 --> 00:20:42.000
新しいフレームワークでは、最も一般的に使用されるシステム定義型をカバーする120以上の定数が定義されています。

00:20:42.000 --> 00:20:46.000
もちろん、このセッションの早い段階で、アプリでいくつかのタイプを宣言しました。

00:20:46.000 --> 00:20:51.000
彼らも定数を公開できたらいいのではないでしょうか？

00:20:51.000 --> 00:20:55.000
あなたはまさにそれができるので、今日は良いニュースでいっぱいです。

00:20:55.000 --> 00:21:01.000
エクスポートする型とインポートする型の名前付き定数を宣言するためのAPIがあります。

00:21:01.000 --> 00:21:04.000
意味論はそれぞれ少し異なります。

00:21:04.000 --> 00:21:11.000
タイプをエクスポートするとき、あなたは「私はこのタイプを所有しています。私はそれを作りました。私のアプリはこのタイプの権限です。

00:21:11.000 --> 00:21:17.000
そこで、私たちは先に進み、あなたがこのタイプについてすべてを知っているという知識で安全な、あなたのためにUTTypeのインスタンスを作成します。

00:21:17.000 --> 00:21:27.000
タイプをインポートすると、「私はこのタイプについて知っていますが、他の誰かが私よりも知っているかもしれません」と言い、そのタイプの所有者はあなたとは異なるタイプを宣言するかもしれません。

00:21:27.000 --> 00:21:33.000
その場合、最も一般的なユースケースでは、そのタイプをその場で置き換えることができます。

00:21:33.000 --> 00:21:35.000
しかし、私たちはあなたの協力が必要です。

00:21:35.000 --> 00:21:49.000
インポートした型を定数として宣言するのではなく、静的計算変数として宣言し、アプリのインストールによって宣言が変更された場合、更新された型を自動的に選択できるようにします。

00:21:49.000 --> 00:21:53.000
宣言したタイプの問題を検出するためのサポートをXcodeに組み込みました。

00:21:53.000 --> 00:22:01.000
エクスポートまたはインポートされたタイプがInfo.plistに欠落しているかどうか、または間違った定数初期化子を使用したかどうかを検出できます。

00:22:01.000 --> 00:22:07.000
私たちは時間の経過とともにサポートの改善に取り組み、あなたの意見はここで非常に貴重になりますので、フィードバックを提供してください。

00:22:07.000 --> 00:22:13.000
多くのフレームワークが、iOS 14とmacOS Big Surの新しいAPIをサポートしています。

00:22:13.000 --> 00:22:24.000
Foundationには、先ほどお見せしたURLプロパティがあり、文字列またはURLとUTTypeのインスタンスに基づいて推奨されるファイル名を生成するためのユーティリティもあります。

00:22:24.000 --> 00:22:27.000
SwiftUIはUTTypeを幅広くサポートしています。

00:22:27.000 --> 00:22:34.000
onDropイベントハンドラなどのペーストボードおよびドラッグアンドドロップAPIは、それらを排他的に使用します。

00:22:34.000 --> 00:22:39.000
また、ドキュメントベースのアプリに対するSwiftUIの新しいサポートは、UTTypeを使用するように設計されています。

00:22:39.000 --> 00:22:47.000
詳細については、WWDC 20の「SwiftUIでドキュメントベースのアプリを構築する」をチェックすることをお勧めします。

00:22:47.000 --> 00:22:52.000
AppKitを使用する場合、NSWorkspaceでは任意のUTTypeのアイコンを取得できます。

00:22:52.000 --> 00:22:56.000
また、NSOpenPanelとNSSavePanelはUTTypesをサポートしています。

00:22:56.000 --> 00:23:02.000
UIkitは、ドキュメントピッカーやドキュメントブラウザを提示する際のUTTypeの使用をサポートしています。

00:23:02.000 --> 00:23:06.000
また、Core Spotlightでは、UTTypeから属性セットを作成できます。

00:23:06.000 --> 00:23:13.000
このリリースではUTTypeをサポートしていないAPIがいくつかあり、それらと対話する必要があるかもしれません。

00:23:13.000 --> 00:23:15.000
難しくありません。

00:23:15.000 --> 00:23:23.000
統一型識別子をAPIに渡す必要がある場合は、UTTypeの識別子プロパティを取得し、CFStringにキャストします。

00:23:23.000 --> 00:23:32.000
ユニフォーム型識別子をUTTypeに変換したい場合は、CFStringからStringにキャストし、その文字列でUTTypeを初期化します。

00:23:32.000 --> 00:23:37.000
これは失敗可能な初期化子なので、ゼロをチェックすることを忘れないでください。

00:23:37.000 --> 00:23:42.000
Objective-Cでは、それは少し冗長ですが、アイデアは同じです。

00:23:42.000 --> 00:23:51.000
UTTypeの識別子をCFStringRefにキャストするか、CFStringをNSStringにキャストし、そこからUTTypeを作成します。

00:23:51.000 --> 00:24:01.000
今日、システムがメタデータからファイルの型を導き出す方法と、Appleが統一型識別子を使用してその情報をカプセル化する方法を見ました。

00:24:01.000 --> 00:24:09.000
独自の型を宣言して使用する方法と、複数のアプリケーション間で共有される可能性のある型と対話する方法を学びました。

00:24:09.000 --> 00:24:17.000
そして、型と対話するための最新のオブジェクト指向の方法を提供する新しい統一型識別子フレームワークを導入しました。

00:24:17.000 --> 00:24:22.000
この知識と新しいフレームワークを使用してアプリを構築する方法を楽しみにしています。

00:24:22.000 --> 23:59:59.000
ありがとうございます。

