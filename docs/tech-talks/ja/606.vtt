WEBVTT

00:00:01.000 --> 00:00:15.000
イメージブロックとタイルシェーディングに基づいて構築されたイメージブロックサンプルカバレッジコントロールは、マルチサンプリングレンダリングパスを最適化する新しい機会を提供し、A11のGPUの強化されたマルチサンプリングハードウェア用に設計されています。

00:00:15.000 --> 00:00:23.000
イメージブロックサンプルカバレッジは、A11の新しいメタル2機能に焦点を当てた一連のプレゼンテーションの3番目です。

00:00:23.000 --> 00:00:31.000
Metal 2の強化されたマルチサンプリング機能に飛び込む前に、マルチサンプルアンチエイリアシングを簡単に復習しましょう。

00:00:31.000 --> 00:00:42.000
マルチサンプルアンチエイリアシング、またはMSAAは、複数の深さと色のサンプルで各ピクセルを表現することによって、原始的なエッジの外観を改善するために使用される技術です。

00:00:42.000 --> 00:00:47.000
まず、GPUがマルチサンプリングなしで三角形をレンダリングする方法を見てみましょう。

00:00:47.000 --> 00:00:53.000
これは、カラーアタッチメントを表すピクセルの4×4のグリッドです。

00:00:53.000 --> 00:00:59.000
GPUのラスタライザは、ピクセルの中心をサンプリングして、プリミティブで覆われているかどうかを判断します。

00:00:59.000 --> 00:01:02.000
三角形を持ち込みましょう。

00:01:02.000 --> 00:01:06.000
プリミティブで覆われているすべてのピクセルセンターは赤く着色されています。

00:01:06.000 --> 00:01:14.000
各ピクセルが単一のサンプル位置しか持っていない場合、ピクセルはピクセル中心のみに基づいてカバーされているかカバーされていないかに分類されます。

00:01:14.000 --> 00:01:22.000
結果の画像では、エッジエイリアシングの古典的な症状を見ることができます:ジャギーとしても知られる階段アーティファクト。

00:01:22.000 --> 00:01:26.000
マルチサンプルアンチエイリアスでレンダリングされた同じ三角形を見てみましょう。

00:01:26.000 --> 00:01:33.000
この例では、各ピクセルには4つの均等に分散したサンプリング位置があります。

00:01:33.000 --> 00:01:40.000
ピクセルあたり4つのサンプルで、GPUのラスタライザはプリミティブのより細かいグレインカバレッジを決定できます。

00:01:40.000 --> 00:01:49.000
マルチサンプリングアタッチメントが解決されると、GPUはサンプルの値を平均して、各ピクセルの最終的な色を決定します。

00:01:49.000 --> 00:01:54.000
これにより、エッジが滑らかになり、階段効果の外観が低下します。

00:01:54.000 --> 00:02:12.000
従来のマルチサンプリングの実装では、改善されたエッジの外観のトレードオフは、各サンプルをブレンドする計算オーバーヘッド、マルチサンプルアタッチメントテクスチャのより大きなメモリフットプリント、およびピクセルごとに複数のサンプルを保存および解決するためのより高いメモリ帯域幅です。

00:02:12.000 --> 00:02:21.000
AppleのAシリーズGPUは、これらのトレードオフに直接対処する非常に効率的なMSAA実装を備えています。

00:02:21.000 --> 00:02:31.000
ハードウェアは、各ピクセルにプリミティブエッジが含まれているかどうかを追跡し、ブレンドはサンプル値が異なるピクセルに対してのみサンプルごとに実行されます。

00:02:31.000 --> 00:02:40.000
Metal on AシリーズGPUを使用すると、マルチサンプリングアタッチメントにメモリレスレンダリングターゲットを使用することで、余分なメモリストレージ要件を排除できます。

00:02:40.000 --> 00:02:45.000
完全なサンプルデータは、タイルメモリに一時的にしか存在しません。

00:02:45.000 --> 00:02:57.000
Metalのマルチサンプル解決ストアアクションを使用することで、タイルメモリから解決アタッチメントに直接解決することで、追加のシステムメモリ帯域幅が発生することを回避できます。

00:02:57.000 --> 00:03:06.000
さらに、Metal 2は、サンプル位置を選択し、サンプリングパターンを制御できるように、プログラマブルサンプル位置を導入しました。

00:03:06.000 --> 00:03:12.000
A11のMetal 2では、ブレンドでマルチサンプリングをさらに効率的にしました。

00:03:12.000 --> 00:03:26.000
現在のAシリーズGPUは、エッジが各ピクセルと交差するかどうかをすでに追跡していますが、A11 GPUは、各ピクセル内の一意のサンプル数を追跡することで、この追跡をさらに細かい粒度に拡張します。

00:03:26.000 --> 00:03:38.000
他のMetal 2機能を使用しなくても、既存のマルチサンプリングアプリケーションは、A11のGPUの強化されたマルチサンプリングハードウェアとより効率的に融合します。

00:03:38.000 --> 00:03:53.000
Imageblocksやタイルシェーディングなどの他のMetal 2機能の柔軟性を活用して、Imageblock Sample Coverage Controlを使用すると、各ピクセルのサンプルカバレッジ追跡データにアクセスして、マルチサンプリングレンダリングパスをさらに制御できます。

00:03:53.000 --> 00:04:04.000
Imageblock Sample Coverage Controlを使用すると、タイルパイプラインは、独自のカスタム解決アルゴリズムを使用して、レンダリングパスでいつでもサンプルデータを解決できます。

00:04:04.000 --> 00:04:14.000
Imageblock Sample Coverage Controlが提供する追加の柔軟性を理解するには、まずAシリーズGPUでエッジトラッキングがどのように機能するかを理解する必要があります。

00:04:14.000 --> 00:04:24.000
現在のAシリーズGPUはシーンをタイルでラスタライズし、各タイルにはピクセルにプリミティブエッジが含まれているかどうかを追跡するメタデータが含まれています。

00:04:24.000 --> 00:04:30.000
この画像では、赤いピクセルには原始的なエッジが含まれていますが、白いピクセルには含まれていません。

00:04:30.000 --> 00:04:35.000
エッジを含むピクセルの数は、シーンのジオメトリの密度に対して増加します。

00:04:35.000 --> 00:04:41.000
ピクセルにプリミティブエッジが含まれている場合、それは複数の一意のサンプル値を持っていることを意味します。

00:04:41.000 --> 00:04:46.000
このため、ブレンド方程式は、エッジを含むピクセルのサンプルごとに実行されます。

00:04:46.000 --> 00:04:50.000
エッジを含まないピクセルは、一度だけブレンドする必要があります。

00:04:50.000 --> 00:04:54.000
A11 GPUは、より細かい粒度でエッジを追跡します。

00:04:54.000 --> 00:04:58.000
エッジを含むピクセルには、多くの場合、いくつかのユニークなサンプルしかありません。

00:04:58.000 --> 00:05:04.000
A11 GPUの強化されたマルチサンプリングは、ユニークなサンプルのみを追跡し、ブレンドします。

00:05:04.000 --> 00:05:10.000
メタルシェーディング言語では、これらのユニークなサンプルに名前を付けます:色。

00:05:10.000 --> 00:05:15.000
それでは、A11 GPUがマルチサンプリングブレンド性能をどのように向上させるかを見てみましょう。

00:05:15.000 --> 00:05:21.000
プリミティブエッジを含むピクセルの場合、A11 GPUはそのピクセル内の一意の色の数を追跡します。

00:05:21.000 --> 00:05:28.000
プリミティブがピクセルを交差または完全に覆うと、そのピクセルに含まれる色の数が増減します。

00:05:28.000 --> 00:05:32.000
A11 GPUはこれらのトランジションを自動的に追跡します。

00:05:32.000 --> 00:05:38.000
右側の図では、ピクセルには4つのサンプルが含まれていますが、2色のみです。

00:05:38.000 --> 00:05:45.000
A11 GPUが次のプリミティブをこのピクセルとブレンドする必要がある場合、ブレンドするユニークなサンプルは2つしかありません。

00:05:45.000 --> 00:05:52.000
また、プログラム可能なブレンドを使用する高度なレンダリングアルゴリズムの場合、大幅な節約になります。

00:05:52.000 --> 00:05:56.000
それでは、これらのカラートラッキングトランジションのいくつかを通して断片を取りましょう。

00:05:56.000 --> 00:06:02.000
当初、各フラグメントには、すべてのサンプルを表す単一の色が含まれています。

00:06:02.000 --> 00:06:06.000
これは、レンダリングパスが始まるときのあなたの明確な色になります。

00:06:06.000 --> 00:06:15.000
プリミティブエッジがピクセルをカットした場合、A11 GPUは新しいユニークな色を作成し、カバーされたサンプルを新しい色に割り当てます。

00:06:15.000 --> 00:06:20.000
この緑色の三角形で覆われた2つのサンプルは、新しい色のものに割り当てられています。

00:06:20.000 --> 00:06:25.000
カバーされていないサンプルは、まだカラーゼロに割り当てられています。

00:06:25.000 --> 00:06:30.000
このピクセルと交差する次のプリミティブは、赤い半透明の三角形だとしましょう。

00:06:30.000 --> 00:06:33.000
赤い三角形は3つのサンプルをカバーしています。

00:06:33.000 --> 00:06:38.000
現在のAシリーズGPUは、カバーされた3つのサンプルのそれぞれをブレンドします。

00:06:38.000 --> 00:06:45.000
A11 GPUは、カバーされた2つのサンプルが同じカラーインデックスを共有しているため、2回しかブレンドしません。

00:06:45.000 --> 00:06:55.000
この場合、カラー1は緑と赤のブレンドであり、GPUは新しいユニークな色であるため、インデックス2で新しい色を作成します。

00:06:55.000 --> 00:07:00.000
ピクセル内のユニークな色の数は、プリミティブがピクセルをカットすると増加する可能性があります。

00:07:00.000 --> 00:07:05.000
しかし、ハードウェアがユニークな色の数を減らす場合があります。

00:07:05.000 --> 00:07:10.000
ここでは、不透明な非ブレンドの三角形がピクセルを完全にカバーしています。

00:07:10.000 --> 00:07:23.000
4つのサンプルはすべて完全に青に置き換えられるため、すべての青いサンプルは再び1つの色で表すことができるため、A11 GPUは3色を1つに戻します。

00:07:23.000 --> 00:07:36.000
A11 GPUの強化されたマルチサンプリングハードウェアは非常に強力で、Metalシェーディング言語を拡張して、Imageblock Sample Coverage Controlでサンプルカバレッジを明示的に制御できるようにしました。

00:07:36.000 --> 00:07:46.000
この新機能により、タイルパイプラインは、ピクセルのカラーカバレッジを変更することにより、レンダリングパスの途中でサンプルデータを解決する機能を備えています。

00:07:46.000 --> 00:07:52.000
そして、Metal Shading Languageでカーネルを書くので、独自のカスタム解決フィルタを書くことができます。

00:07:52.000 --> 00:07:55.000
簡単な例を見てみましょう。

00:07:55.000 --> 00:08:00.000
まず、imageblockの引数を持つカーネルがあります。

00:08:00.000 --> 00:08:05.000
次に、画像ブロック内の指定された座標で色の数を照会します。

00:08:05.000 --> 00:08:14.000
ピクセルあたり4つのサンプルを持つレンダリングパスの場合、返される値は、そのピクセルにあるユニークな色の数に応じて、1、2、3、または4になります。

00:08:14.000 --> 00:08:20.000
マルチサンプリングされたイメージブロックは、サンプルまたは色ごとにイメージブロックデータを返すことができます。

00:08:20.000 --> 00:08:25.000
この例では、カラーcのイメージブロックデータを取得します。

00:08:25.000 --> 00:08:33.000
この例は一意の色の数をループしているため、各色でカバーされているサンプルの数も考慮する必要があります。

00:08:33.000 --> 00:08:41.000
これを行うには、このカラーインデックスのカバレッジマスクを取得し、ポップカウントを呼び出してマスク内のセットビット数を取得します。

00:08:41.000 --> 00:08:52.000
次に、ピクセルあたりのサンプル数で割って、解決された値を完全なサンプルマスクでイメージブロックに書き戻すことで、色の解決を終了します。

00:08:52.000 --> 00:09:00.000
完全なサンプルマスクで単一の値を書き込むことで、A11 GPUはすべてのサンプルデータを単一の色にマージします。

00:09:00.000 --> 00:09:11.000
これは基本的な解決の例ですが、タイルパイプラインであるため、アプリケーションに最適な方法でサンプルデータを解決するためのカーネルを書くことができます。

00:09:11.000 --> 00:09:14.000
だから、あなたはちょうどカスタム解決フィルタを書く例を見ました。

00:09:14.000 --> 00:09:18.000
タイルシェーディングを使用してサンプルデータを解決するもう1つの理由について話し合いましょう。

00:09:18.000 --> 00:09:26.000
現在、一部のアプリケーションは、多くの不透明なジオメトリと粒子のような半透明のジオメトリがたくさんある複雑なシーンをレンダリングします。

00:09:26.000 --> 00:09:41.000
A11 GPUは各ピクセルのユニークな色のみをブレンドするために最善を尽くしますが、シーンに多くのブレンドジオメトリがあり、大量のオーバードローがあることがわかっている場合は、重いブレンドフェーズの前にタイルパイプラインでサンプルデータを解決することをお勧めします。

00:09:41.000 --> 00:09:53.000
Imageblock Sample Coverage Controlを使用すると、不透明なジオメトリをレンダリングした後、タイルパイプラインでサンプルデータを解決し、ブレンドする前にすべてのピクセルに単一の一意の色が含まれていることを確認できます。

00:09:53.000 --> 00:09:59.000
タイルパイプラインを使用してサンプルデータのカバレッジを変更するより高度な例を見てみましょう。

00:09:59.000 --> 00:10:06.000
タイルパイプラインは計算関数で実装できるため、単に平均値よりもはるかに多くのことを行うことができます。

00:10:06.000 --> 00:10:19.000
当社のSurface Aggregationサンプルアプリは、マルチサンプリングシングルパス遅延シェーディングアルゴリズムから始まり、タイルベースのカーネルディスパッチを使用して、遅延パスのシェーディングサンプルの数を減らします。

00:10:19.000 --> 00:10:29.000
このアルゴリズムの目標は、マルチサンプルアンチエイリアシングのエッジスムージングの利点を維持しながら、高価な遅延パスでより少ないサンプルをシェーディングすることです。

00:10:29.000 --> 00:10:36.000
アルゴリズムの詳細をすべて掘り下げることはありませんので、必ずSurface Aggregationサンプルアプリをダウンロードして探索してください。

00:10:36.000 --> 00:10:41.000
しかし、今度は、この技術がどのようにシェーディングのコストを削減するかを視覚化しましょう。

00:10:41.000 --> 00:10:47.000
2つの画像は、gバッファ内のピクセルあたり複数のサンプルを含むピクセルを視覚化します。

00:10:47.000 --> 00:10:55.000
左側の画像はサーフェスをマージする前のgバッファを示し、右側の画像はサーフェスをマージした後のgバッファを示しています。

00:10:55.000 --> 00:11:01.000
表面凝集カーネルは、シェーディングする必要があるgバッファサンプルの数を減らすことができます。

00:11:01.000 --> 00:11:09.000
右の画像でわかるように、複数のユニークなサンプルを含む唯一のピクセルは、真の折り目と深さの境界にあります。

00:11:09.000 --> 00:11:20.000
A11 GPUのMetal 2の前に、このアルゴリズムはアルゴリズムのフェーズごとに個別のレンダリングパスを必要とし、システムメモリへの複数のラウンドトリップが発生します。

00:11:20.000 --> 00:11:29.000
しかし、Imageblock Sample Coverage Controlを使用すると、アルゴリズムの3つのフェーズすべてを1つのレンダリングパスにマージし、アプリに大量のメモリ帯域幅を節約できます。

00:11:29.000 --> 00:11:36.000
図でわかるように、3つのフェーズはすべてイメージブロックで動作し、すべての作業データをタイルメモリ内に保持します。

00:11:36.000 --> 00:11:40.000
まず、gバッファをタイルメモリのイメージブロックにレンダリングします。

00:11:40.000 --> 00:11:50.000
次に、表面集約タイルパイプラインをディスパッチして、gバッファサンプルの数をより少ない集約gバッファサンプルに減らします。

00:11:50.000 --> 00:11:56.000
最後に、遅延シェーディングパスは、各集計サンプルのみをシェーディングします。

00:11:56.000 --> 00:12:04.000
このテクニックについてもっと知りたい場合は、このプレゼンテーションの最後にあるリンクにアクセスして、サンプルアプリをダウンロードしてください。

00:12:04.000 --> 00:12:10.000
要約すると、まず、A11 GPUのマルチサンプリングのハードウェア強化について話しました。

00:12:10.000 --> 00:12:17.000
A11 GPUは、すべてのピクセルの一意のサンプル数を追跡し、ブレンドコストを削減します。

00:12:17.000 --> 00:12:23.000
この最適化は、APIブレンドとプログラム可能なブレンドの両方に適用されます。

00:12:23.000 --> 00:12:31.000
次に、この強力なハードウェア機能をタイルシェーディングで使用されるカーネルに公開するA11 GPUのMetal 2の機能強化について議論しました。

00:12:31.000 --> 00:12:42.000
Imageblock Sample Coverage Controlを使用すると、独自のカスタムリゾルブカーネルを作成し、いつでもレンダリングパスでそれらをディスパッチして、強力な新しい最適化を実装できます。

00:12:42.000 --> 00:12:53.000
一緒に、A11 GPUの強化されたマルチサンプリングとMetal 2の新しいシェーディング言語機能により、データをより長くオンチップに保つための新しい技術が可能になります。

00:12:53.000 --> 00:13:00.000
この機能を使用して、Surface Aggregationなどのアルゴリズムを1回のレンダリングパスで実装できます。

00:13:00.000 --> 00:13:10.000
Metal 2の詳細とサンプルコードへのリンクについては、開発者のウェブサイトdeveloper.apple.com/metalをご覧ください。

00:13:10.000 --> 23:59:59.000
ご覧いただきありがとうございます。

