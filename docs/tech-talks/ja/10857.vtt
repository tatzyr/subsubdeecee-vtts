WEBVTT

00:00:02.000 --> 00:00:05.000
こんにちは。私はアップルのOSパフォーマンスチームのパトリックです。

00:00:05.000 --> 00:00:11.000
今日は、あなたのアプリのレンダリングヒッチの謎解きと排除に飛び込みます。

00:00:11.000 --> 00:00:20.000
iOSはレンダリングループを使用してビューを表示し、ヒッチはレンダリングループが表示に間に合うようにフレームを完了しないときはいつでもです。

00:00:20.000 --> 00:00:26.000
レンダリングループ全体の概要については、私の講演「UIアニメーションヒッチとレンダリングループを探索する」をチェックしてください。

00:00:26.000 --> 00:00:34.000
ここでは、レンダリング準備とレンダリング実行フェーズの遅さによって引き起こされるヒッチであるレンダリングヒッチに焦点を当てます。

00:00:34.000 --> 00:00:44.000
まず、これら2つのレンダリングフェーズが何であるかを見てから、InstrumentsとXcodeビューデバッガを使用してアプリでレンダリングヒッチをキャッチしてトリアージする方法を確認します。

00:00:44.000 --> 00:00:52.000
最後に、レイヤーツリーを最適化し、ヒッチがユーザーエクスペリエンスを中断するのを止めるための推奨事項をいくつか見ていきます。

00:00:52.000 --> 00:00:55.000
レンダリングフェーズを定義することから始めましょう。

00:00:55.000 --> 00:01:01.000
コミットフェーズでは、アプリはUIを変更し、更新されたUIレイヤーツリーを送信して処理します。

00:01:01.000 --> 00:01:09.000
これらの提出を「コミット」と呼び、レンダリングサーバーはすべてのフォアグラウンドプロセスのコミットをレンダリングする責任があります。

00:01:09.000 --> 00:01:14.000
レンダリングサーバーでの作業に1フレームの持続時間が長い場合、ヒッチする可能性があります。

00:01:14.000 --> 00:01:25.000
作業はアプリのプロセスの外で行われますが、レンダリング作業はアプリに代わって行われるため、アプリのレイヤーツリーをレンダリングするのにかかる時間はお客様の責任です。

00:01:25.000 --> 00:01:30.000
レンダリングサーバーには、レンダリング準備とレンダリング実行の2つのフェーズがあります。

00:01:30.000 --> 00:01:38.000
レンダリング準備フェーズは、レイヤーツリーがGPUが実行するための簡単な操作のパイプラインにコンパイルされる場所です。

00:01:38.000 --> 00:01:42.000
いくつかのフレームで行われるアニメーションもここで処理されます。

00:01:42.000 --> 00:01:49.000
レンダリング実行フェーズ中に、GPUはアプリのレイヤーを表示できる最終画像に描画します。

00:01:49.000 --> 00:01:54.000
これらのフェーズのいずれも、フレームの納期が遅れる可能性があります。

00:01:54.000 --> 00:01:58.000
これらの概念を理解するために、レンダリングの例を見てみましょう。

00:01:58.000 --> 00:02:00.000
このフレームのレンダリングを歩きます。

00:02:00.000 --> 00:02:04.000
影が円とバーの両方の周りにあることに注意してください。

00:02:04.000 --> 00:02:06.000
これは後で重要になります。

00:02:06.000 --> 00:02:10.000
アプリが左側のレンダリングサーバーに提出したレイヤーツリーから始めます。

00:02:10.000 --> 00:02:20.000
レンダリングサーバーは、レイヤーごとにステップして、GPUがUIを背面から前面に描画できるようにする描画コマンドのパイプラインをコンパイルします。

00:02:20.000 --> 00:02:32.000
ルートノードから始めて、レンダリングサーバーは階層内のすべてのレイヤーを持つまで、兄弟から兄弟、親から子へと歩きます。

00:02:32.000 --> 00:02:38.000
最後に、GPUが次の実行段階で実行できるパイプライン全体があります。

00:02:38.000 --> 00:02:44.000
GPUの仕事は、このパイプラインを取り、各ステップを中央の最終的なテクスチャに描画することです。

00:02:44.000 --> 00:02:49.000
ディスプレイフェーズ中に画面に表示されるのは、このテクスチャです。

00:02:49.000 --> 00:02:53.000
最初の青いレイヤーから始めて、指定された境界に色を描画します。

00:02:53.000 --> 00:02:59.000
次に、濃い青がその境界に引き込まれ、次のレイヤーに進みます。

00:02:59.000 --> 00:03:02.000
しかし今、GPUは影を描かなければならない。

00:03:02.000 --> 00:03:09.000
影の形状は次の2つのレイヤーで定義されるため、GPUはどの形状で影を描くべきかわかりません。

00:03:09.000 --> 00:03:15.000
しかし、最初に円と小節を描くと、影が黒でそれらを隠し、正しくないように見えます。

00:03:15.000 --> 00:03:22.000
つまり、GPUが障害に当たったことを意味し、続行するには、影の形を把握するために別のテクスチャに切り替える必要があります。

00:03:22.000 --> 00:03:28.000
最終的なテクスチャ以外の場所で描画しているため、これを「オフスクリーンレンダリング」と呼んでいます。

00:03:28.000 --> 00:03:32.000
ここから、円とバーを描くことができます。

00:03:32.000 --> 00:03:37.000
そして今、それはオフスクリーンテクスチャで分離された影の形を持っています。

00:03:37.000 --> 00:03:43.000
最初にレイヤーを黒くしてからぼかして、影の形を整えるのに必要なものがすべて揃っています。

00:03:43.000 --> 00:03:50.000
その後、そのオフスクリーンテクスチャを最終的なテクスチャにコピーすることができ、シャドウレイヤーが完了しました。

00:03:50.000 --> 00:03:55.000
次のステップは、円を描き、次に長方形を再び描くことです。

00:03:55.000 --> 00:04:00.000
アプリが上に描いたテキストの画像をコピーすることで終了します。

00:04:00.000 --> 00:04:05.000
これで両方のレンダリングフェーズが完了し、フレームを表示する準備が整いました。

00:04:05.000 --> 00:04:10.000
しかし、影をレンダリングするために特別なトリックを行なければならなかったため、レンダリングに時間がかかりました。

00:04:10.000 --> 00:04:14.000
これはオフスクリーンパスと呼ばれます。

00:04:14.000 --> 00:04:21.000
オフスクリーンパスは、GPUが最初に別の場所にレンダリングしてからコピーしてレイヤーをレンダリングする必要がある場合です。

00:04:21.000 --> 00:04:25.000
影で、それは最終的な形を把握するために層を描かなければならなかった。

00:04:25.000 --> 00:04:33.000
オフスクリーンパスは加算され、レンダリングがヒッチハイクする可能性があるため、アプリでそれらを監視して回避することが重要です。

00:04:33.000 --> 00:04:41.000
最適化できるオフスクリーンパスには、影、マスク、丸みを帯びた長方形、視覚効果の4つの主なタイプがあります。

00:04:41.000 --> 00:04:45.000
レンダリングの例で、オフスクリーンの影の例を見ました。

00:04:45.000 --> 00:04:53.000
この場合、レンダラーは、最初にアタッチされたレイヤーを描画せずに影を描画するのに十分な情報を持っていません。

00:04:53.000 --> 00:04:57.000
2番目のタイプのオフスクリーンは、レイヤーまたはレイヤーのツリーにマスキングが必要な場合です。

00:04:57.000 --> 00:05:00.000
レンダラーはマスクされたサブツリーをレンダリングする必要があります。

00:05:00.000 --> 00:05:05.000
しかし、それはまた、マスクされた形状の外側のピクセルを上書きすることを避ける必要があります。

00:05:05.000 --> 00:05:14.000
したがって、マスクされた形状内のピクセルのみを最終的なテクスチャにコピーする前に、サブツリー全体をオフスクリーンにレンダリングします。

00:05:14.000 --> 00:05:20.000
このオフスクリーンは、ユーザーが決して見ることのない多くのピクセルをレンダリングする可能性があります。

00:05:20.000 --> 00:05:23.000
3番目のタイプはマスキングに関連しています。

00:05:23.000 --> 00:05:27.000
レイヤーの角を丸めるには、オフスクリーンが必要になることがあります。

00:05:27.000 --> 00:05:38.000
十分な情報が与えられていない場合、レンダラーはビュー全体を画面外に描画し、丸みを帯びた形状内のピクセルをコピーする必要があるかもしれません。

00:05:38.000 --> 00:05:40.000
4番目のタイプは視覚効果ビューからです。

00:05:40.000 --> 00:05:45.000
UI Kitは、鮮やかさとぼかしの2種類の視覚効果を提供します。

00:05:45.000 --> 00:05:52.000
これらのエフェクトを適用するには、レンダラーは視覚効果ビューの下にあるものをオフスクリーンパスで別のテクスチャにコピーする必要があります。

00:05:52.000 --> 00:05:57.000
次に、視覚効果タイプを結果に適用し、コピーします。

00:05:57.000 --> 00:06:07.000
これは、iOS、tvOS、macOSで非常に一般的であるため、UIナビゲーションバー、UIタブバー、その他多くの標準コントロールで表示されます。

00:06:07.000 --> 00:06:12.000
したがって、これらの4つのオフスクリーンタイプは、レンダリングを遅くし、レンダリングヒッチを引き起こす可能性があります。

00:06:12.000 --> 00:06:25.000
レンダリングフェーズの詳細を説明し、多数のオフスクリーンパスがどのようにそれらを引き起こすかを見たので、2番目のトピックに移りましょう。Instrumentsでヒッチを見つけることです。

00:06:25.000 --> 00:06:31.000
インスツルメンツ12では、アプリのヒッチをプロファイリングするための新しいインストゥルメントテンプレートをリリースしました。

00:06:31.000 --> 00:06:41.000
一部のユーザーは、Meal Plannerアプリのヒッチについて文句を言っており、私は調査したいので、Instrumentから始めて、アプリでスクロールし始めます。

00:06:41.000 --> 00:06:45.000
そして、これはアニメーションヒッチテンプレートを使用して、Meal Plannerアプリの痕跡です。

00:06:45.000 --> 00:06:49.000
スクロール中に見たヒッチのいくつかに飛び込みたいと思っています。

00:06:49.000 --> 00:06:54.000
ヒッチ16を見つけるために、ヒッチトラックを拡大して拡大しましょう。

00:06:54.000 --> 00:06:59.000
各トラックは、先ほど説明したレンダリングループのステージに対応しています。

00:06:59.000 --> 00:07:03.000
頂上に沿って最も重要なトラックがあります。ヒッチ間隔を表示します。

00:07:03.000 --> 00:07:07.000
これは、フレームが準備できているはずの時間です。

00:07:07.000 --> 00:07:14.000
ユーザーイベントトラックは、ヒッチングフレームに関連付けられたユーザーイベントを表示します。

00:07:14.000 --> 00:07:19.000
コミットトラックは、そのフレーム中にレンダリングサーバーに送信されたすべてのコミットフェーズを表示します。

00:07:19.000 --> 00:07:25.000
特にこれらのトラックの詳細については、「コミットフェーズでヒッチを見つけて修正する」を必ず見てください。

00:07:25.000 --> 00:07:28.000
そして、これがこのビデオで私たちが焦点を当ててきたものです。

00:07:28.000 --> 00:07:33.000
レンダリングとGPUトラックは、レンダリングサーバーによって実行された作業を表示します。

00:07:33.000 --> 00:07:40.000
Frame Lifetimesトラックは、イベントから表示までフレームを構成するのにかかった全期間を示します。

00:07:40.000 --> 00:07:48.000
そして最後に、内蔵ディスプレイトラックは、途中で発生したVSYNCとともに、ディスプレイに現れたすべてのフレームを表示します。

00:07:48.000 --> 00:07:57.000
フレームの寿命とヒッチ期間の開始を比較して、フレームの構成を行うべき予想間隔を視覚化できます。

00:07:57.000 --> 00:08:05.000
このヒッチでは、2つのフレームオーバーになり、VSYNCに従うことで、コミットフェーズとレンダリングフェーズの両方が時間の経過とともに経過したことがわかります。

00:08:05.000 --> 00:08:14.000
この間隔は許容レイテンシと呼ばれ、その後のすべての時間はヒッチ持続時間です。

00:08:14.000 --> 00:08:19.000
トラックの下には、ヒッチトラックが選択されたときにヒッチの詳細なメトリックが表示されます。

00:08:19.000 --> 00:08:21.000
私たちはヒッチ16を見ていました。

00:08:21.000 --> 00:08:24.000
ヒッチ時間と許容可能なレイテンシを見ることができます。

00:08:24.000 --> 00:08:29.000
これは私たちがフレームを完成させなければならなかった時間です。

00:08:29.000 --> 00:08:34.000
バッファカウントは、ヒッチ時にレンダリングサーバーが使用するバッファの数です。

00:08:34.000 --> 00:08:41.000
デフォルト値は2ですが、レンダリングフレームが遅れ、レンダリングサーバーが追いつこうとしている場合は3になる可能性があります。

00:08:41.000 --> 00:08:49.000
ダブルバッファリングモードでは、iPhoneには2つのフレーム、つまり33.34ミリ秒があり、これはレイテンシ列で見られるものです。

00:08:49.000 --> 00:08:57.000
上記のHitch Durationトラックに従うことを常に忘れないでください。これは、バッファー数に関係なく、関心のある領域を常に強調表示します。

00:08:57.000 --> 00:08:59.000
最後に、ヒッチタイプがあります。

00:08:59.000 --> 00:09:05.000
ヒッチタイプは、ヒッチの種類を表面化し、アプリで何を掘り下げるべきかについてのコンテキストを提供するのに役立ちます。

00:09:05.000 --> 00:09:12.000
ここでは、高価なコミットと高価なGPU時間の両方があることがわかります。これは、上記のトラックで見たものです。

00:09:12.000 --> 00:09:21.000
拡大すると、レンダリングとGPUのトラックに焦点を当て、それらを選択して、準備と実行のフェーズに関する詳細情報を含むアナライザを見ることができます。

00:09:21.000 --> 00:09:28.000
重要な列はレンダリングカウントで、GPUが行わなければならなかったオフスクリーンパスの数を見ることができます。

00:09:28.000 --> 00:09:35.000
レンダリングヒッチがあったことを知っているので、これらのオフスクリーンを見て、何がそれらを引き起こしているのか、どのように修正できるのかを理解する必要があります。

00:09:35.000 --> 00:09:38.000
レイヤーツリーを見る最善の方法は、Xcodeビューデバンカーを使用することです。

00:09:38.000 --> 00:09:42.000
そのために、デモに行きましょう。

00:09:42.000 --> 00:09:46.000
ここでは、Meal Plannerアプリが一時停止したビューデバッガにあります。

00:09:46.000 --> 00:09:51.000
左側には、ビューコントローラー、ウィンドウ、制約、ビューが表示されます。

00:09:51.000 --> 00:09:55.000
しかし、Xcode 11.2から始めて、レイヤーを表示することもできます。

00:09:55.000 --> 00:10:01.000
エディターをクリックすると、新しいレイヤーを表示項目をクリックしましょう。

00:10:01.000 --> 00:10:03.000
かっこいい。

00:10:03.000 --> 00:10:10.000
ナビゲーターの左側で、任意のビューをクリックして、そのレイヤーとそのすべてのサブレイヤーを見ることができます。

00:10:10.000 --> 00:10:17.000
レイヤーを選択すると、レイヤーの有用な特性にサービスを提供するこの真新しいレイヤーインスペクタが表示されます。

00:10:17.000 --> 00:10:28.000
したがって、ここでは、タグビューのバッキングレイヤーがあり、背景色、不透明度、masksToBoundsを有効にしたかどうか、その他多くのプロパティを確認できます。

00:10:28.000 --> 00:10:31.000
重要なのは、オフスクリーンのカウントを見ることができることです。

00:10:31.000 --> 00:10:34.000
これは、このレイヤーをレンダリングするのにかかったオフスクリーンの数です。

00:10:34.000 --> 00:10:37.000
その下には、オフスクリーンフラグと呼ばれるものがあります。

00:10:37.000 --> 00:10:40.000
これらは、オフスクリーンの理由を説明しています。

00:10:40.000 --> 00:10:46.000
たとえば、オフスクリーンマスクのような特定のフラグは、複数のオフスクリーンをトリガーできます。

00:10:46.000 --> 00:10:48.000
例えば、ここには2つあります。

00:10:48.000 --> 00:10:58.000
しかし、アプリ全体の各レイヤーを掘り下げてオフスクリーン数を確認する場合、これらのオフスクリーンパスを減らすのに十分な洞察はまだありません。

00:10:58.000 --> 00:11:10.000
ビューとレイヤー階層のパフォーマンス最適化を特定して提案するために、Xcode 12に新しいランタイム問題タイプを追加し、最適化の機会と呼んでいます。

00:11:10.000 --> 00:11:17.000
これらはデフォルトで有効になっていますが、最適化の機会を表示の下のエディタメニューにオプションがあります。

00:11:17.000 --> 00:11:27.000
これらの最適化の機会は、何年もアプリのレンダリングパフォーマンスを最適化した後、Appleのパフォーマンスチームによって開発され、書かれた素晴らしいリソースです。

00:11:27.000 --> 00:11:33.000
これらは、レイヤーの全体的な外観に影響を与えない、シンプルでありながら価値のある変更を提案することを目的としています。

00:11:33.000 --> 00:11:41.000
ナビゲーターでは、いくつかのレイヤーで紫色のランタイム問題インジケーターを見ることができます。

00:11:41.000 --> 00:11:43.000
ここには星の層があります。

00:11:43.000 --> 00:11:46.000
検査官では、それが5つのオフスクリーンを取ることがわかります。

00:11:46.000 --> 00:11:51.000
インジケーターを強調表示すると、動的な影が原因であることが明らかになります。

00:11:51.000 --> 00:11:57.000
詳細については、ランタイムイシューナビゲーターを見てみましょう。

00:11:57.000 --> 00:12:00.000
問題のメッセージを読むことができるのはここです。

00:12:00.000 --> 00:12:04.000
レイヤーは、レンダリングにコストがかかる動的シャドウを使用していると書かれています。

00:12:04.000 --> 00:12:11.000
可能であれば、shadowPathを設定するか、影を画像に事前にレンダリングしてレイヤーの下に置いてみてください。

00:12:11.000 --> 00:12:14.000
スライドでは、このタイプのオフスクリーンについて議論します。

00:12:14.000 --> 00:12:21.000
レンダラーには十分な情報がなく、影の形を把握するためにレイヤーを画面外に描画する必要があります。

00:12:21.000 --> 00:12:31.000
CALayerのshadowPathプロパティを使用することで、実際にレンダラーに5つのオフスクリーンすべてを使用して排除するための正確な手順を与えることができます。

00:12:31.000 --> 00:12:37.000
これらは本当に私たちのアプリに加算されるので、コードを見て、この変更を加えましょう。

00:12:37.000 --> 00:12:40.000
ここでは、影を設定する星の層があります。

00:12:40.000 --> 00:12:45.000
最適化テキストは、任意のCGPathを受け入れるshadowPathを設定するように指示しました。

00:12:45.000 --> 00:12:50.000
すでに作成したスターパスを再利用しましょう。

00:12:50.000 --> 00:12:54.000
そのようにして、CollectionViewCellごとに5つのオフスクリーンパスを排除しました。

00:12:54.000 --> 00:12:57.000
それは大きな修正です。

00:12:57.000 --> 00:13:02.000
デバッグナビゲーターに戻ると、まだ他のランタイムの問題インジケーターが表示されます。

00:13:02.000 --> 00:13:06.000
タグビューでは、レイヤーにランタイムの問題が表示されます。

00:13:06.000 --> 00:13:11.000
ナビゲーターでは、オフスクリーンマスクによって引き起こされる2つのオフスクリーンが表示されます。

00:13:11.000 --> 00:13:15.000
このレイヤーは、画像ビューとラベルビューで構成されています。

00:13:15.000 --> 00:13:20.000
赤い背景から逃げることを心配していたので、マスクレイヤーを追加しました。

00:13:20.000 --> 00:13:27.000
ランタイムツールのヒントでは、原因が単純な背景色のマスキングであることがわかります。

00:13:27.000 --> 00:13:30.000
イシューナビゲーターには、機会のテキストが表示されます。

00:13:30.000 --> 00:13:35.000
このレイヤーは、背景色がマスクとして設定されたシンプルなレイヤーを使用していると書かれています。

00:13:35.000 --> 00:13:43.000
代わりに、マスクと同じフレームとコーナー半径のコンテナレイヤーを使用し、両方のmasksToBoundsを「はい」に設定します。

00:13:43.000 --> 00:13:51.000
オフスクリーンは、レンダラーが最初にマスクレイヤーをレンダリングする必要があることによって引き起こされ、提案はこのレイヤーを完全に排除することです。

00:13:51.000 --> 00:13:56.000
コードで調べてみましょう。

00:13:56.000 --> 00:13:58.000
ここにタグビューがあります。

00:13:58.000 --> 00:14:03.000
マスクレイヤーを作成し、黒い背景色と角の半径を与えます。

00:14:03.000 --> 00:14:08.000
このマスクレイヤーはシンプルで、単純なレイヤーは決してマスクであってはならない。

00:14:08.000 --> 00:14:15.000
代わりに、レンダラーが描画を最適化できるように、この要求されたマスク形状を実際のレイヤーで定義する必要があります。

00:14:15.000 --> 00:14:21.000
代わりに、好きなように角の半径を10に設定し、masksToBoundsを「True」に設定できます。

00:14:21.000 --> 00:14:25.000
次に、マスクを完全に削除します。

00:14:25.000 --> 00:14:28.000
しかし、それは1つのオフスクリーンを排除するだけです。

00:14:28.000 --> 00:14:34.000
サブレイヤーがあるため、masksToBoundsは、ビューが正しくクリップされていることを確認するために、オフスクリーンパスを行う必要があります。

00:14:34.000 --> 00:14:39.000
しかし、私たちの見解では、サブレイヤーがタグビューの境界を超えないようにしました。

00:14:39.000 --> 00:14:42.000
実際、実際にはマスキングは全く必要ありません。

00:14:42.000 --> 00:14:45.000
そのmasksToBoundsコールを削除しましょう。

00:14:45.000 --> 00:14:49.000
そして今、私たちは両方のオフスクリーンを排除しました。すごい。

00:14:49.000 --> 00:14:53.000
これまでのところ、3行のコードで、CollectionViewCellごとに7つのオフスクリーンを保存しました。

00:14:53.000 --> 00:14:58.000
これは途方もない改善ですが、もう1つ探すべき問題があります。

00:14:58.000 --> 00:15:03.000
ナビゲーターに戻りましょう。

00:15:03.000 --> 00:15:05.000
画像ビューを選択しましょう。

00:15:05.000 --> 00:15:11.000
角が丸みを帯びていることがわかります。ランタイムの問題を強調すると、「シンプルな形状のマスキング」と書かれています。

00:15:11.000 --> 00:15:16.000
もう一度、ランタイムナビゲーターに移動して詳細を学びます。

00:15:16.000 --> 00:15:23.000
レイヤーは、rect、roundedRect、または楕円のパスを持つCAShapeLayerによってマスクされていると書かれています。

00:15:23.000 --> 00:15:30.000
代わりに、cornerRadiusとmasksToBoundsが設定された適切に変換されたコンテナレイヤーを使用してください。

00:15:30.000 --> 00:15:35.000
オフスクリーンは、レンダラーが再び別のレイヤーにマスクする必要があることによって引き起こされます。

00:15:35.000 --> 00:15:37.000
しかし、今回は単純なレイヤーではありません。

00:15:37.000 --> 00:15:42.000
何が起こっているのかを理解するために、コードを見てみましょう。

00:15:42.000 --> 00:15:45.000
このコードでは、画像ビューがあることがわかります。

00:15:45.000 --> 00:15:53.000
まず、CAShapeLayerを作成し、UIBezierPath APIを使用してパスを作成し、それをマスクとして使用します。

00:15:53.000 --> 00:15:58.000
ここで起こっていることは、有効なタイプのマスクである可能性のあるシェイプレイヤーを使用していることです。

00:15:58.000 --> 00:16:04.000
しかし、Xcodeは複雑な形状ではなく、丸みを帯びた長方形を作成しているだけです。

00:16:04.000 --> 00:16:11.000
このコードを書いた理由は、時々スクイクルと呼ばれる特別なタイプの丸みを帯びた長方形を作成しようとしていたからです。

00:16:11.000 --> 00:16:15.000
このタイプの丸みを帯びた長方形は、iOSで非常に人気があります。

00:16:15.000 --> 00:16:18.000
しかし、これはその効果を得るための最良の方法ではありません。

00:16:18.000 --> 00:16:25.000
iOS 13以降、cornerCurveプロパティを使用して、cornerRadius効果をスクイクル形状にすることができます。

00:16:25.000 --> 00:16:35.000
これで、shapeLayerを完全に排除し、cornerRadiusとcornerCurveを「連続」に設定するだけです。

00:16:35.000 --> 00:16:40.000
このように、提供されたAPIを使用するだけで、さらに2つのオフスクリーンを排除しました。

00:16:40.000 --> 00:16:45.000
そのため、オフスクリーンカウントを本当に最適化し、36からゼロに引き下げることができました。

00:16:45.000 --> 00:16:49.000
それはすごい。

00:16:49.000 --> 00:16:53.000
ビューデバッガに戻ると、レンダリングに関連しない他のランタイムの問題がいくつか表示されます。

00:16:53.000 --> 00:16:58.000
それにもかかわらず、私たちは同僚のチャールズにそれらを見せて、彼がそれらを最適化できるようにしたいと思います。

00:16:58.000 --> 00:17:05.000
以前は、チャールズが私たちと同じデバイスを持っていて、彼のアプリに接続し、ビューデバッガで一時停止する必要があります。

00:17:05.000 --> 00:17:15.000
しかし、今ではビューデバッガの状態を保存して、電子メールで送信したり、同僚と共有したり、フィードバックレポートに添付したりすることができます。

00:17:15.000 --> 00:17:21.000
これを行うには、ファイル、エクスポートビュー階層を選択できます。

00:17:21.000 --> 00:17:23.000
「保存」をクリックして、ほら。

00:17:23.000 --> 00:17:31.000
これで、すべてのビュー、レイヤー、制約、ランタイムの問題をカプセル化した送信可能なファイルがあります。

00:17:31.000 --> 00:17:39.000
これにより、リモートでのコラボレーションがはるかに簡単になり、不要なオフスクリーンをすべて追跡しようとするときに本当に役立ちます。

00:17:39.000 --> 00:17:47.000
Xcodeビューデバッガがアプリの画面外の問題をどのように強調表示できるかを見たので、いくつかの推奨事項をまとめてみましょう。

00:17:47.000 --> 00:17:52.000
すべてのアプリで最も重要なことは、常に提供されたAPIを使用することです。

00:17:52.000 --> 00:17:58.000
シャドウを設定するときは、多数のオフスクリーンパスを保存するようにshadowPathを設定してください。

00:17:58.000 --> 00:18:03.000
長方形を丸めるときは、cornerRadiusとcornerCurveのプロパティを使用します。

00:18:03.000 --> 00:18:08.000
丸みを帯びた長方形の形を形成するためにマスクや角の内容を使用することは避けてください。

00:18:08.000 --> 00:18:11.000
これらは不必要なオフスクリーンを引き起こします。

00:18:11.000 --> 00:18:19.000
ほとんどのレイヤーでは、レイヤーの境界をcornerRadiusに丸めてUIBezierPathを作成することは、良いshadowPathを設定するために必要なすべてです。

00:18:19.000 --> 00:18:23.000
2番目のステップは、アプリ全体でマスキングを最適化することです。

00:18:23.000 --> 00:18:29.000
masksToBoundsを使用して、長方形、丸みを帯びた長方形、または楕円にマスクします。

00:18:29.000 --> 00:18:32.000
カスタムマスクレイヤーよりもはるかにパフォーマンスが高いです。

00:18:32.000 --> 00:18:35.000
全体として、マスキングが実際に必要であることを確認してください。

00:18:35.000 --> 00:18:41.000
サブツリーのコンテンツが境界を超えない場合は、masksToBoundsを完全に無効にします。

00:18:41.000 --> 00:18:43.000
これらは推奨事項にすぎません。

00:18:43.000 --> 00:18:53.000
Instrumentsを使用してアプリをプロファイリングし、最適化の機会を利用してレイヤーツリーを検査し、全体的なオフスクリーンカウントを減らすためのシンプルで重要なヒントを確認することが重要です。

00:18:53.000 --> 00:19:02.000
最後に、ビュー階層の状態を保存してチームと共有したり、フィードバックレポーターアプリでフィードバックを添付したりできることを覚えておいてください。

00:19:02.000 --> 00:19:07.000
全体として、これらのツールと推奨事項は、レンダリングのヒッチを避けるのに役立ちます。

00:19:07.000 --> 00:19:13.000
コミットヒッチについては、「コミットフェーズでヒッチを見つけて修正する」を必ずチェックしてください。

00:19:13.000 --> 00:19:20.000
一緒に、これらのトークは、アプリのヒッチタイム比を減らし、ユーザーのスクロールをスムーズに保つのに役立ちます。

00:19:20.000 --> 23:59:59.000
見てくれてありがとう。

