WEBVTT

00:00:00.000 --> 00:00:04.000
デイブ・ロバーツ:こんにちは。私はアップルのGPUソフトウェアチームのデイブ・ロバーツです。

00:00:04.000 --> 00:00:10.000
新しいApple A15 BionicチップのGPUのアップデートを共有できることを本当に楽しみにしています。

00:00:10.000 --> 00:00:18.000
その後、GPUソフトウェアチームの同僚であるケイトリン・ヒンソンが、GPUの新しいメタル機能についてすべてお話しします。

00:00:18.000 --> 00:00:25.000
彼女はまた、いくつかのクールなユースケースを探索しながら、Metalアプリでこれらの機能を使用する方法を紹介します。

00:00:25.000 --> 00:00:37.000
A15 Bionicは、CPU、GPU、ニューラルエンジン、その他のユーザーエクスペリエンス向上技術のアップデートを備えた、Metalアプリやゲームのための強力な新しいプラットフォームです。

00:00:37.000 --> 00:00:46.000
A15 GPUは、A14 Bionicと同じタイルベースの遅延レンダラーとユニファイドメモリアーキテクチャに基づいて構築されています。

00:00:46.000 --> 00:00:54.000
私たちはさまざまな分野で多くのマイクロアーキテクチャの改善を行いましたが、私が強調すべきパフォーマンスのためのいくつかの重要な変更があります。

00:00:54.000 --> 00:01:04.000
A15のGPUには最大5つのシェーダーコアがあり、その5番目のコアは同じGPUコア周波数で25%のパフォーマンス向上を提供します。

00:01:04.000 --> 00:01:12.000
シェーダーコアは、数学の多いワークロードでGPUのパフォーマンスを向上させることができるF32浮動小数点数学ユニットの2倍になりました。

00:01:12.000 --> 00:01:18.000
A15のGPUはまた、UIをさらに反応良くし、バッテリー寿命をさらに延ばします。

00:01:18.000 --> 00:01:23.000
そして、コードを変更することなく、これらの素晴らしい改善をすべて無料で得ることができます。

00:01:23.000 --> 00:01:25.000
しかし、それがすべてではありません!

00:01:25.000 --> 00:01:31.000
A15 GPUには、Metalアプリをさらに良くするために使用できる新機能が追加されました。

00:01:31.000 --> 00:01:38.000
そして、これらの新機能はすべて、AppleGPUFamily8と呼ばれる新しいMetal機能セットに属しています。

00:01:38.000 --> 00:01:50.000
残りの講演では、Katelynと私はこれらの新機能に焦点を当て、それらが何であるか、なぜ有用であるかを説明し、それらをサポートする新しいMetal APIとシェーディング言語の変更をカバーします。

00:01:50.000 --> 00:01:57.000
まず、A15の新しいグラフィックス処理機能。

00:01:57.000 --> 00:02:03.000
画像の品質への影響を最小限に抑えながら、アプリのテクスチャメモリ使用量を使用する損失圧縮。

00:02:03.000 --> 00:02:09.000
この新しいA15機能は、ロスレス圧縮と同じテクスチャメモリ帯域幅の節約を提供します。

00:02:09.000 --> 00:02:15.000
Metalアプリで非可逆圧縮を使用する方法を、もう少し詳しく説明します。

00:02:15.000 --> 00:02:27.000
後で、Katelynは、A15 GPUがスパース深度とステンシルテクスチャの両方にレンダリングを含めることで、スパーステクスチャの既存のサポートをどのように拡張するかを紹介します。

00:02:27.000 --> 00:02:32.000
Katelynは、SIMDグループシャッフルとフィルという新しいコンピューティング固有の機能もカバーします。

00:02:32.000 --> 00:02:37.000
A15は、これらの新しい命令をGPUコア命令セットに追加します。

00:02:37.000 --> 00:02:47.000
彼女はこの機能を説明し、画像処理などの該当するユースケースのコンピューティングカーネルの実行時間を短縮することで、アプリのパフォーマンスを向上させる方法を紹介します。

00:02:47.000 --> 00:02:51.000
まず、非可逆圧縮を詳しく見ていきます。

00:02:51.000 --> 00:02:57.000
損失圧縮をよりよく理解するために、損失圧縮を再検討する価値があります。

00:02:57.000 --> 00:03:06.000
A12 Bionicは2018年に初めてロスレステクスチャ圧縮を導入し、A14 Bionicは2020年に機能にさらなる改善を加えました。

00:03:06.000 --> 00:03:14.000
可逆テクスチャ圧縮はメモリ帯域幅を節約し、電力を節約するため、アプリは1回のバッテリー充電でさらに多くのことができます。

00:03:14.000 --> 00:03:19.000
ロスレス圧縮は、常にテクスチャの詳細を保持することを保証します。

00:03:19.000 --> 00:03:24.000
実際、あなたのアプリはすでにA12 Bionic以降のロスレス圧縮を利用しているかもしれません。

00:03:24.000 --> 00:03:37.000
ロスレス圧縮の詳細については、developer.apple.comのテクニカルトーク「Discover Metal enhancements for A14 Bionic」と「Optimizing Texture Data」の記事をご覧ください。

00:03:37.000 --> 00:03:43.000
Lossyは、A15 Bionicでテクスチャ圧縮を次のレベルに引き上げます。

00:03:43.000 --> 00:03:51.000
ロスレス圧縮による帯域幅の節約に加えて、非可逆圧縮は非圧縮テクスチャのメモリフットプリントの半分しか使用しません。

00:03:51.000 --> 00:03:55.000
ロッシー圧縮は、可能な限りテクスチャ品質を維持します。

00:03:55.000 --> 00:04:03.000
そして何よりも、これをA15のレンダリングターゲットに簡単に適用して、これらのメモリ節約を最大限に活用できます。

00:04:03.000 --> 00:04:11.000
テクスチャ記述子の新しい圧縮タイププロパティを損失設定するだけで、損失圧縮を有効にできます。

00:04:11.000 --> 00:04:13.000
では、なぜ非可逆圧縮を使用するのですか?

00:04:13.000 --> 00:04:20.000
さて、圧縮は、ロスレスまたはロスを使用するかどうかにかかわらず、かなりのテクスチャメモリ帯域幅を節約します。

00:04:20.000 --> 00:04:26.000
これは、メモリに書き込まれる前にテクスチャデータを圧縮することで帯域幅を節約する圧縮ユニットです。

00:04:26.000 --> 00:04:31.000
ロスレス圧縮を使用する場合、GPUはテクスチャの詳細を完全に保持する必要があります。

00:04:31.000 --> 00:04:39.000
したがって、金属は圧縮の量を保証できず、完全な非圧縮テクスチャサイズをカバーするのに十分なメモリを割り当てる必要があります。

00:04:39.000 --> 00:04:46.000
ただし、非可逆圧縮を使用する場合、テクスチャはロスレスのメモリフットプリントの半分しか使用しません。

00:04:46.000 --> 00:04:57.000
A15 GPUが50%小さいメモリフットプリント内に収まるようにテクスチャを可逆圧縮できない場合、テクスチャの領域の忠実度が低下します。

00:04:57.000 --> 00:05:04.000
Lossy圧縮は、ほとんどのピクセルフォーマットとテクスチャタイプをサポートしており、レンダリングターゲットで使用できます。

00:05:04.000 --> 00:05:10.000
多くの場合、アプリをさらに変更することなく、テクスチャで有効にすることができます。

00:05:10.000 --> 00:05:16.000
品質のトレードオフが受け入れられる場所ならどこでも、あなたのアプリが損失圧縮を有効にすることをお勧めします。

00:05:16.000 --> 00:05:23.000
それを有効にする最も簡単な場所は、品質の低下に気付く可能性が最も低い最終的なレンダリングターゲットです。

00:05:23.000 --> 00:05:30.000
中間レンダリングターゲットに非可逆圧縮を使用し、テクスチャ解像度の向上など、他のことにそのメモリ節約を使用することを検討してください。

00:05:30.000 --> 00:05:38.000
また、後処理の変更を確認して、損失圧縮の恩恵を受ける可能性のあるレンダリングターゲット候補を見つけてください。

00:05:38.000 --> 00:05:42.000
詳細なユースケースをいくつか紹介します。

00:05:42.000 --> 00:05:49.000
最終的なレンダリングターゲットに対してのみ非可逆圧縮を有効にした場合、視覚的な違いを見てみましょう。

00:05:49.000 --> 00:05:56.000
この分割画像は、左側の可逆と右側の可逆を比較し、違いはかなり微妙です。

00:05:56.000 --> 00:06:01.000
彼は、ロスレス圧縮と非可逆圧縮のピクセル単位の違いを示す画像です。

00:06:01.000 --> 00:06:09.000
黒いピクセルは違いを表しません。青と緑は小さな違いを表し、赤は最大の変化を表します。

00:06:09.000 --> 00:06:16.000
この画像の赤と黄色のピクセルは、最終的なレンダリングで最大の違いを持ついくつかの孤立した領域を示しています。

00:06:16.000 --> 00:06:24.000
スクーターで地域の1つにズームインすると、左の画像と右の画像の違いを見るのに苦労します。

00:06:24.000 --> 00:06:29.000
中間レンダリングターゲットは、非可逆圧縮でもうまく機能します。

00:06:29.000 --> 00:06:36.000
これは、可逆圧縮と非可逆圧縮を比較する水たまりの反射を並べて見ています。

00:06:36.000 --> 00:06:44.000
ピクセルごとの差表現に再度切り替えると、非可逆圧縮反射はロスレスバージョンと最小限の違いしかありません。

00:06:44.000 --> 00:06:51.000
さらに、テクスチャの解像度を上げて、非可逆圧縮で保存したメモリで詳細を追加できます。

00:06:51.000 --> 00:07:01.000
たとえば、同じ量のメモリを使用しながら、ロスレスバージョンよりも詳細を示す高解像度の反射があります。

00:07:01.000 --> 00:07:07.000
このデモの右側では、シーン内のすべてのレンダリング可能なテクスチャに非可逆圧縮を使用します。

00:07:07.000 --> 00:07:17.000
動いているとき、シーンは非常に安定しているように見え、左側のロスレスバージョンと比較すると、違いを検出することは非常に困難です。

00:07:17.000 --> 00:07:22.000
Metalを使用すると、アプリで非可逆圧縮を簡単に使用できます。

00:07:22.000 --> 00:07:24.000
方法は次のとおりです。

00:07:24.000 --> 00:07:32.000
いつものようにテクスチャ記述子を初期化することから始め、圧縮タイプのプロパティを非可逆に設定します。

00:07:32.000 --> 00:07:34.000
次に、ストレージモードをプライベートに設定します。

00:07:34.000 --> 00:07:36.000
最後に、テクスチャを作成します。

00:07:36.000 --> 00:07:42.000
そして、あなたのアプリは、非可逆圧縮とそれが提供する節約を最大限に活用できるようになりました。

00:07:42.000 --> 00:07:48.000
いくつかの例外を除いて、ほとんどの構成で非可逆圧縮用のテクスチャを作成できることに注意してください。

00:07:48.000 --> 00:07:55.000
たとえば、2D、3D、配列、キューブなど、最も一般的なテクスチャタイプに非可逆圧縮を使用できます。

00:07:55.000 --> 00:07:59.000
しかし、この機能は、あまり一般的ではないタイプのいくつかをサポートしていません。

00:07:59.000 --> 00:08:07.000
同様に、非可逆圧縮は最も一般的なピクセルフォーマットをサポートしていますが、パックされたカラーチャンネルを持つフォーマットはサポートしていません。

00:08:07.000 --> 00:08:16.000
損失圧縮は、レンダリングターゲットとして、blit操作で、およびサンプル操作と読み取り操作でそれらにアクセスするときにテクスチャをサポートします。

00:08:16.000 --> 00:08:22.000
ただし、シェーダーの書き込み操作で非可逆テクスチャを入力することはできないことに注意してください。

00:08:22.000 --> 00:08:25.000
損失圧縮は、プライベートストレージ内のテクスチャのみをサポートします。

00:08:25.000 --> 00:08:30.000
共有または管理されたストレージノードは使用できません。

00:08:30.000 --> 00:08:37.000
そして最後に、非可逆テクスチャは、MSAA、sRGB、mipmappingなどの他の一般的な機能で動作します。

00:08:37.000 --> 00:08:45.000
非可逆圧縮サポートの詳細については、developer.apple.comのMetal機能セットテーブルをご覧ください。

00:08:45.000 --> 00:08:54.000
したがって、要約すると、非可逆圧縮は、可逆圧縮と同じ帯域幅を節約し、テクスチャメモリの50%を節約します。

00:08:54.000 --> 00:09:01.000
ユースケースと、アプリで損失圧縮を使用する量に応じて、かなりの量のメモリを節約できます。

00:09:01.000 --> 00:09:09.000
損失圧縮は、テクスチャの詳細を維持することを目的としていますが、圧縮されたテクスチャデータが収まらない領域の品質をわずかに低下させるだけです。

00:09:09.000 --> 00:09:22.000
そして最後に、非可逆圧縮は、一般的なテクスチャタイプ、一般的なピクセルフォーマット、およびシェーダー書き込み以外のすべてのGPUアクセスモードをサポートしているため、非可逆圧縮を簡単に使用できます。

00:09:22.000 --> 00:09:27.000
聞いてくれてありがとう、今度はケイトリンに引き渡します。

00:09:27.000 --> 00:09:28.000
ケイトリン・ヒンソン:ありがとう、デイブ。

00:09:28.000 --> 00:09:33.000
A15 Bionicの新しいスパーステクスチャ拡張機能を紹介することに興奮しています。

00:09:33.000 --> 00:09:40.000
スパーステクスチャは、Metalでメモリ予算を管理しながら、高解像度のテクスチャを作成するのに最適な方法です。

00:09:40.000 --> 00:09:48.000
A13 Bionicは最初にスパーステクスチャサポートを導入し、GPUタイムライン上のテクスチャタイルをマッピングおよびアンマップできるようにしました。

00:09:48.000 --> 00:09:56.000
アプリでスパーステクスチャを使用する方法の詳細については、2019年秋と2020年の講演を参照してください。

00:09:56.000 --> 00:10:01.000
A15 Bionicは、深さとステンシルアタッチメントを含めることで、まばらなサポートを拡張します。

00:10:01.000 --> 00:10:07.000
まばらなテクスチャの指針は、「使わないものを割り当てるな」です。

00:10:07.000 --> 00:10:12.000
たとえば、このアプリはUI要素の背後にタイルをマッピングする必要はありません。

00:10:12.000 --> 00:10:20.000
まばらな深さとステンシルテクスチャにより、このアプリは常にこれらの不明瞭なタイルを未マッピングのままにすることができます。

00:10:20.000 --> 00:10:24.000
まばらな深さのアタッチメントでシャドウマップを最適化できます。

00:10:24.000 --> 00:10:30.000
シャドウマッピングに精通していない場合は、この技術を使用するメタルの遅延照明サンプルをチェックしてください。

00:10:30.000 --> 00:10:37.000
シャドウパスは光の視点からシャドウマップをレンダリングし、照明パスはそれを読み返します。

00:10:37.000 --> 00:10:41.000
シャドウマップからサンプリングされたテクセルは、常に投影されたフルスタム内にあります。

00:10:41.000 --> 00:10:45.000
このシナリオは、まばらなテクスチャの完璧な候補です。

00:10:45.000 --> 00:10:52.000
照明パスはこれらのタイルをサンプリングしないため、シャドウテクスチャの大部分はマッピングする必要はありません。

00:10:52.000 --> 00:10:56.000
これは、シャドウマッピングとそのレンダリングされたシャドウマップを使用するシーンです。

00:10:56.000 --> 00:11:05.000
このアプリは、それらのタイルから書き戻したり読み返したりする必要がないため、ビューフスタムの外側のタイルのメモリを回復できます。

00:11:05.000 --> 00:11:12.000
カスケードシャドウマッピングは、複数の個々のシャドウマップを使用してシーンをより効率的にカバーするシャドウのより高度な技術です。

00:11:12.000 --> 00:11:20.000
カメラの近くに高解像度のシャドウマップを割り当て、カメラから遠く離れた低解像度のマップを割り当てます。

00:11:20.000 --> 00:11:24.000
たとえば、このシーンは3つの重なり合うシャドウマップを使用します。

00:11:24.000 --> 00:11:32.000
各シャドウマップは同じテクスチャ解像度を持ち、カメラから離れれば離れるほど、ますます大きな領域にマッピングされます。

00:11:32.000 --> 00:11:38.000
シャドウマップの緑色のハイライトされた領域は、照明がサンプルを通過するテクセルを表しています。

00:11:38.000 --> 00:11:48.000
照明は、これらのタイルから不均一にサンプルを通過します - ヒートマップとして表されます - 青いタイルはアンダーサンプリングされ、赤はオーバーサンプリングされています。

00:11:48.000 --> 00:11:57.000
スパースタイルシャドウマップを使用して、これらのテクスチャをサンプリングレートに基づいて調整可能な解像度を持つ単一のサーフェスに置き換えることができます。

00:11:57.000 --> 00:12:03.000
スパースタイルシャドウマップ（またはSTSM）を使用すると、単一のスパース深度サーフェスを作成します。

00:12:03.000 --> 00:12:09.000
固定解像度のテクスチャを使用する代わりに、サーフェスはスパースミップマップチェーン全体にタイルをマッピングしました。

00:12:09.000 --> 00:12:14.000
この手法は、目的のサンプリングレートを一致させるために必要なタイルのみをマッピングします。

00:12:14.000 --> 00:12:21.000
これは、相対的なミップレベルの各タイルの物理的な解像度の図です。

00:12:21.000 --> 00:12:29.000
異なるミップにまたがるタイルをマッピングすることで、シーン全体のシャドウマップの解像度を自由かつ効率的に調整できます。

00:12:29.000 --> 00:12:32.000
STSMテクニックの主なステップは次のとおりです。

00:12:32.000 --> 00:12:37.000
まず、サンプリングレートに基づいて密度マップを生成します。

00:12:37.000 --> 00:12:42.000
次に、密度マップに従ってサーフェスとマップタイルを構築します。

00:12:42.000 --> 00:12:46.000
そして、アダプティブサーフェスにレンダリングしてサンプリングします。

00:12:46.000 --> 00:12:53.000
密度マップを生成するために、ジオメトリパスは他のパスの密度マップバッファに入力します。

00:12:53.000 --> 00:12:57.000
最初のステップは、シャドウマップ全体でサンプリングレートを取得することです。

00:12:57.000 --> 00:13:04.000
予想されるサンプル密度は、レンダリングされたジオメトリのシャドウ空間微分を追跡することによって計算されます。

00:13:04.000 --> 00:13:13.000
フラグメントシェーダーは、アトミックを使用してデリバティブを2Dグリッドに格納し、shadowUV空間全体でサンプリングレートを収集します。

00:13:13.000 --> 00:13:21.000
密度マップを取得したら、それを使用して、まばらな深度テクスチャのタイルをレイアウトし、目次バッファを生成します。

00:13:21.000 --> 00:13:25.000
この目次バッファは、ライティングパスで使用されます。

00:13:25.000 --> 00:13:35.000
まず、表面を反復的に分割し、下部のミップから始めて、各ミップレベルのマッピングをスケジュールすることで、深度テクスチャのタイルをマッピングします。

00:13:35.000 --> 00:13:41.000
どのタイルをマッピングするかを把握するには、まず密度マップから現在のMIPのサンプリングレートを確認します。

00:13:41.000 --> 00:13:49.000
この例では、密度マップは現在のミップが不十分であることを示していますが、次のミップレベルは適しています。

00:13:49.000 --> 00:13:55.000
この場合、次のミップをマッピングし、現在のミップをアンマップすることで、タイル全体を昇格します。

00:13:55.000 --> 00:13:58.000
これは別の、より複雑なシナリオです。

00:13:58.000 --> 00:14:03.000
密度マップは、現在のmipが少なくとも1つの象限で満足のいくものであることを示しています。

00:14:03.000 --> 00:14:12.000
次のmipでは、サンプルレートと密度マップは2つの象限の目標を満たし、残りの2つは目標レートを下回っています。

00:14:12.000 --> 00:14:18.000
この場合、現在のミップでタイルをマッピングし、次のミップでタイルの半分をマッピングします。

00:14:18.000 --> 00:14:28.000
次に、コンピューティングシェーダーは、目次またはTOCバッファに格納されるUVレベルとmipレベルの間で変換する2Dテーブルを書き込みます。

00:14:28.000 --> 00:14:37.000
STSMからテクセルをサンプリングする前に、TOCバッファはmipを取得するためにテーブルをインデックスすることによって照明パスによって読み取られます。

00:14:37.000 --> 00:14:43.000
シャドウマップをサンプリングすると、mipが明示的なLODパラメータとして使用されます。

00:14:43.000 --> 00:14:46.000
次のステップは、まばらなシャドウマップをレンダリングすることです。

00:14:46.000 --> 00:14:55.000
まず、TOCバッファを使用して影を淘汰し、間接描画コマンドをエンコードして、まばらな深度テクスチャにレンダリングします。

00:14:55.000 --> 00:15:00.000
各ミップマップを間接コマンドバッファで個別に塗りつぶして、サーフェスをレンダリングします。

00:15:00.000 --> 00:15:11.000
ICBは、コンピューティングパスが並列に、常駐領域に対して各シャドウジオメトリメッシュを淘汰してソートできるため、このタスクに最適です。

00:15:11.000 --> 00:15:19.000
計算シェーダーは、タイルの境界ボリュームに対してメッシュをテストすることによって、個々のICBにドローコマンドをエンコードします。

00:15:19.000 --> 00:15:34.000
シャドウマップ全体に伸びる大きなオブジェクトの場合、シェーダーは各mipの関連するタイルに対してオブジェクトをテストします。少なくとも1つのタイルが重なった場合、drawコマンドをmipのICBにエンコードします。

00:15:34.000 --> 00:15:42.000
mipに重なるタイルがない場合は、そのmipのICBにオブジェクトの描画コマンドを発行しないでください。

00:15:42.000 --> 00:15:52.000
各オブジェクトの最適化された描画コマンドセットは、並列計算スレッドですべての交差テストを実行することにより、シャドウ淘汰計算パスによってエンコードされます。

00:15:52.000 --> 00:15:59.000
赤いメッシュはカメラに最も近いので、シャドーマップの11枚のタイルで最大の影響を与えました。

00:15:59.000 --> 00:16:06.000
3つのタイルで最小の衝撃を持っていたカメラから最も遠いオレンジ色のメッシュと比較してください。

00:16:06.000 --> 00:16:13.000
間接描画コマンドが完了すると、STSMはライティングパスでサンプリングされる準備が整います。

00:16:13.000 --> 00:16:19.000
この表は、STSMとシャドウマッピングとカスケードシャドシャドマッピングを比較しています。

00:16:19.000 --> 00:16:27.000
STSMのサンプルレートと有効品質は、単一のシャドウマップとほぼ同じですが、メモリ使用量ははるかに少ないです。

00:16:27.000 --> 00:16:33.000
実際、同じ解像度でメモリフットプリントの1パーセント未満しか使用していません。

00:16:33.000 --> 00:16:42.000
この深いダイビングが、まばらなタイル張りのシャドウマップを使用して、Metalアプリで効率的で高品質のシャドウを作成する方法について、いくつかのアイデアを与えてくれることを願っています。

00:16:42.000 --> 00:16:50.000
最後に、A15のメタルコンピューティングに新しく追加されたSIMDシャッフルとフィルを紹介することに興奮しています。

00:16:50.000 --> 00:16:57.000
現代の画像処理では、畳み込みカーネルはエッジ検出、ぼかし、シャープなどのフィルターに適用されます。

00:16:57.000 --> 00:17:02.000
これは、現代のレンダリングデモから画像に適用された畳み込みです。

00:17:02.000 --> 00:17:11.000
このようなワークロードは、通常、テクスチャサンプリングまたはスレッドグループメモリからの読み取りによって制限され、GPUの数学ユニットは十分に活用されていません。

00:17:11.000 --> 00:17:19.000
Appleシリコンは、これらのワークロードを最適化するために、メタルコンピューティングシェーダーで使用できる豊富なSIMD命令セットを提供します。

00:17:19.000 --> 00:17:28.000
SIMDグループのスレッドがロックステップで同時に実行されると、SIMDグループ関数はこのロックステップの実行を利用してスレッド間でデータを共有します。

00:17:28.000 --> 00:17:37.000
既存のSIMD機能の詳細については、紹介されたA13 BionicとA14 Bionicの講演を参照してください。

00:17:37.000 --> 00:17:41.000
それでは、利用可能な新しいSIMDの指示について話し合いましょう。

00:17:41.000 --> 00:17:47.000
A15 Bionicの新機能は、SIMDとクワッドシャッフルとフィルのサポートです。

00:17:47.000 --> 00:17:55.000
これらの指示は、以前に示したエッジ検出畳み込みのように、スライドウィンドウ画像操作を改善するように設計されています。

00:17:55.000 --> 00:18:03.000
これらの機能は、メモリを使用せずに特定のSIMDグループ内の隣接するスレッド間でデータを共有することで、コンピューティングワークロードを最適化します。

00:18:03.000 --> 00:18:09.000
まず、A13で最初にサポートされているクワッドシャッフルダウンの動作を見てみましょう。

00:18:09.000 --> 00:18:19.000
データバッファには、コンテンツA、B、C、およびDがあり、クワッドのスレッドのレジスタにロードされます：0、1、2、3。

00:18:19.000 --> 00:18:29.000
1のシフトでシャッフルダウンを適用すると、スレッド0、1、および2のレジスタデータは、スレッド1、2、3からデータを取得します。

00:18:29.000 --> 00:18:37.000
計算されたクアッドレーンIDはラップされないため、結果のスレッド3にはシフトされていない値Dがあります。

00:18:37.000 --> 00:18:45.000
代わりに、クワッドシャッフルとフィルダウン命令を使用すると、結果のスレッド3を更新するためのフィルバッファが提供されます。

00:18:45.000 --> 00:18:51.000
これで、スレッドゼロの塗りつぶしデータがスレッド3の出力データにシャッフルされます。

00:18:51.000 --> 00:19:05.000
同様に、クワッドシャッフルアップと2のシフトでフィルすると、AとBがスレッド2と3にシャッフルされ、フィルバッファからのデータが出力の下位レーンにシャッフルされます。

00:19:05.000 --> 00:19:09.000
Appleシリコンでは、SIMDグループは32本のスレッドで構成されています。

00:19:09.000 --> 00:19:18.000
そして、同じシャッフルとフィルの動作は、下のデルタレーンがフィルデータの上のレーンで満たされているSIMDレーン全体に適用できます。

00:19:18.000 --> 00:19:25.000
新しいSIMDとクワッドシャッフルとフィル命令には、オプションのモジュロ引数もあります。

00:19:25.000 --> 00:19:28.000
これにより、ユーザーが指定したベクトル幅が可能になります。

00:19:28.000 --> 00:19:33.000
8つのモジュールの場合、SIMDグループは効果的に4つのベクトルに分割されます。

00:19:33.000 --> 00:19:41.000
データバッファ値は最初に2つのインデックスをシャッフルし、塗りつぶしデータは8つのスレッドの各セットにシャッフルされます。

00:19:41.000 --> 00:19:53.000
最新のレンダリング画像のエッジ検出に使用されるカーネルをSIMDシャッフルと塗りつぶしを使用して最適化できる例で、これらの新しい手順を使用しましょう。

00:19:53.000 --> 00:20:00.000
最終結果を生成するために、5×5の畳み込みカーネルが入力画像に適用されます。

00:20:00.000 --> 00:20:09.000
出力画像は一連のSIMDグループに分割され、各SIMDグループは4×8のチャンクで、各スレッドは単一の出力に書き込まれます。

00:20:09.000 --> 00:20:13.000
単一のSIMDグループの出力を生成することに集中しましょう。

00:20:13.000 --> 00:20:19.000
5×5の畳み込みでは、各スレッドは入力から5×5ピクセルを読み取る必要があります。

00:20:19.000 --> 00:20:25.000
4×8のSIMDグループごとに、8×12の領域をコンピューティングシェーダーでサンプリングする必要があります。

00:20:25.000 --> 00:20:31.000
この畳み込みの素朴な実装には、出力スレッドごとに25のサンプルが必要です。

00:20:31.000 --> 00:20:35.000
これにより、SIMDグループ全体で大きな重複が生じます。

00:20:35.000 --> 00:20:45.000
これは、シャッフルと記入の指示によって最適化され、SIMDグループ内の重複サンプルを排除し、レジスタシャッフルを通じてデータを共有できます。

00:20:45.000 --> 00:20:49.000
なぜこれらの場所から読む必要があるのか見てみましょう。

00:20:49.000 --> 00:21:03.000
最初にAが読み込まれます。これは、SIMDグループの各スレッドが1つのピクセルをサンプリングする4×8のウィンドウです。次に、右上のウィンドウはB、左下のウィンドウはC、最後に右下のDです。

00:21:03.000 --> 00:21:10.000
赤いアウトラインの長方形は、出力画像のSIMDグループの宛先領域を示します。

00:21:10.000 --> 00:21:19.000
スレッドごとに4つのサンプルを通じて、8×12の入力領域は、重複するサンプルなしでSIMDグループ全体にロードされました。

00:21:19.000 --> 00:21:26.000
スレッドゼロの5×5の領域に再び焦点を合わせると、これらのサンプルは5×5の近傍として表すことができます。

00:21:26.000 --> 00:21:36.000
クワッドシャッフルとフィルダウンを使用して、ネイバーの最初の行にアクセスし、最初にAのデータをシャッフルし、Bのデータで埋めることができます。

00:21:36.000 --> 00:21:42.000
次に、前の行の32の広いベクトルが次の行にシャッフルされます。

00:21:42.000 --> 00:21:51.000
データが全行にシャッフルされるため、32ワイドベクトルの上部レーンのCとDからサンプルをシャッフルするには、塗りつぶしベクトルが必要です。

00:21:51.000 --> 00:22:00.000
同じアプローチを使用して、SIMDとクワッドシャッフルダウンを使用して、5×5領域の残りのサンプルを取得できます。

00:22:00.000 --> 00:22:08.000
完全な近傍がシャッフルされると、これらのサンプルはエッジ検出アルゴリズムへの入力として使用されます。

00:22:08.000 --> 00:22:24.000
素朴な実装は、各スレッドの完全な近隣をサンプリングしましたが、新しいSIMDとクワッドのシャッフルと塗りつぶし命令により、各SIMDグループのサンプル数が84%削減され、隣接するスレッド間で重複するサンプルが排除されます。

00:22:24.000 --> 00:22:36.000
新しいSIMD操作を使用して、多くの一般的な画像処理と機械学習アルゴリズムは、SIMDグループ間で共有データを最適化するために同じアプローチを適用できます。

00:22:36.000 --> 00:22:39.000
そして、それはSIMDシャッフルとフィルのためのものです。

00:22:39.000 --> 00:22:42.000
私たちが学んだことをまとめましょう。

00:22:42.000 --> 00:22:52.000
ロッシー圧縮は、テクスチャの品質を維持しながら、メモリフットプリントと帯域幅を節約する、簡単に有効にできる機能です。

00:22:52.000 --> 00:22:58.000
まばらな深さとステンシルテクスチャは、効率的で高品質のシャドウマップを作成するのに役立ちます。

00:22:58.000 --> 00:23:10.000
新しい計算命令SIMDシャッフルと塗りつぶしは、オーバーラップを減らし、機械学習と画像処理アプリケーションのスライドウィンドウ画像操作を改善します。

00:23:10.000 --> 00:23:22.000
そして最後に、すべてのMetalアプリは、A15 Bionic GPUの全体的なアーキテクチャ改善により、パフォーマンス、応答性、省電力がさらに向上します。

00:23:22.000 --> 23:59:59.000
ご覧いただきありがとうございます。

