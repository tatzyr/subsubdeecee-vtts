WEBVTT

00:00:02.000 --> 00:00:05.000
Betsy Langowski: 2017年、iPhone Xがリリースされました。

00:00:05.000 --> 00:00:12.000
iOS 11 SDKとリンクすることで、アプリは美しい新しいディスプレイを利用できます。

00:00:12.000 --> 00:00:19.000
今年は、iPhone XS、iPhone XS Max、iPhone XRを紹介します。

00:00:19.000 --> 00:00:32.000
iPhone XSはゼロから完全に再設計されましたが、画面サイズはiPhone Xと同じなので、このビデオはまったく新しい解像度のiPhone XS MaxとiPhone XRに焦点を当てます。

00:00:32.000 --> 00:00:39.000
アプリが主にUIKitフレームワークを使用していて、すでにアプリをiPhone Xに適応させている場合は、素晴らしい状態にあるはずです。

00:00:39.000 --> 00:00:45.000
あなたがする必要があるのは、これらの素晴らしい新しい携帯電話を最大限に活用するために、iOS 12とリンクすることだけです。

00:00:45.000 --> 00:00:56.000
iPhone X、そしてiPhone XS MaxとiPhone XR用のアプリを更新する方法について復習が必要な場合は、「iPhone X用アプリの構築」のビデオをチェックしてください。

00:00:56.000 --> 00:01:08.000
このビデオでは、TrueDepthカメラがUIを遮らないようにすること、UI要素がホームインジケーターから離れて配置されていることを確認すること、および行う必要があるその他の一般的な調整について説明します。

00:01:08.000 --> 00:01:21.000
重い作業のほとんどはUIKitによって行われますが、アプリを最適化する必要があるかもしれません。このビデオは、iPhone XS MaxとiPhone XR、そしてiPhone Xに最適なガイダンスを提供します。

00:01:21.000 --> 00:01:29.000
iPhone XS MaxとiPhone XRのアプリのアップデートを簡単にするために、今年あなたのために改善したいくつかのことについて話しましょう。

00:01:29.000 --> 00:01:35.000
「iPhone X用アプリの構築」を見た場合、ランドスケープモードでのテストの重要性を覚えています。

00:01:35.000 --> 00:01:39.000
これが重要な場所の1つは、コレクションビューです。

00:01:39.000 --> 00:01:48.000
私は、タブバーコントローラーに埋め込まれたナビゲーションコントローラーに埋め込まれた、単なるコレクションビューコントローラーであるこの本当にシンプルなサンプルアプリを構築しました。

00:01:48.000 --> 00:01:52.000
セルの間隔をあけるためのオフセットがありますが、それ以外の場合はデフォルトを使用しているだけです。

00:01:52.000 --> 00:01:55.000
一見すると、肖像画では、それは本当によく見えます。

00:01:55.000 --> 00:02:01.000
しかし、横向きでは、このアプリには問題があります。左側のセルはTrueDepthカメラの後ろにあります。

00:02:01.000 --> 00:02:09.000
これに対処するには、コレクションビューのセクションインセット参照を、デフォルトのコンテンツインセットではなく、セーフエリアに設定する必要があります。

00:02:09.000 --> 00:02:14.000
これはコードで行うことができ、iPhone Xが最初にリリースされたとき、それが唯一の方法でした。

00:02:14.000 --> 00:02:20.000
しかし、このアプリはストーリーボードで構築されたため、最近のXcodeでは、インターフェイスビルダーで直接この変更を行うことができます。

00:02:20.000 --> 00:02:29.000
ストーリーボードでコレクションビューを選択すると、サイズインスペクタを選択し、インセットを値からセーフエリアに変更できます。

00:02:29.000 --> 00:02:37.000
今、アプリを構築して実行すると、私のコレクションビューは横向きのTrueDepthカメラを回避し、コードの変更は必要ありません。

00:02:37.000 --> 00:02:40.000
自動レイアウトは、ココアとココアタッチのレイアウトシステムです。

00:02:40.000 --> 00:02:50.000
アプリが自動レイアウトを使用している場合、iPhone XS MaxやiPhone XRのような新しい画面サイズを最適化する作業のほとんどは、あなたのために行われていることがわかります。

00:02:50.000 --> 00:03:00.000
自動レイアウトから得られる大きな利点を利用していない場合は、今年はパフォーマンスを劇的に向上させたため、今は間違いなく更新する時です。

00:03:00.000 --> 00:03:09.000
以下は、iOS 12の青色の自動レイアウト性能と比較して、灰色のiOS 11の自動レイアウト性能の例です。

00:03:09.000 --> 00:03:14.000
iOS 11と比較して、iOS 12で木を動かすのがどれだけ短い時間を取るかを見てください。

00:03:14.000 --> 00:03:17.000
アプリで自動レイアウトを使用する方がずっと速くなりました。

00:03:17.000 --> 00:03:26.000
私たちがそれをどのようにやったかを舞台裏で見たい場合は、WWDC 2018のビデオ「ハイパフォーマンスオートレイアウト」をチェックしてください。

00:03:26.000 --> 00:03:34.000
iPhone XS MaxとiPhone XRの1つの変更点の1つは、ランドスケープでのUISplitViewControllerの動作です。

00:03:34.000 --> 00:03:38.000
これは、iPadのポートレートモードでのメールの仕組みによく似ています。

00:03:38.000 --> 00:03:44.000
iPhone XS Maxシミュレーターで実行して作ったこの非常にシンプルなテストアプリを見てください。

00:03:44.000 --> 00:03:49.000
4つのセルを持つ私のマスタービューは、ボタンを押すだけで入ってきて、同様に却下されます。

00:03:49.000 --> 00:03:55.000
私のアプリは、displayModeButtonItemを設定したため、新しいハードウェアで自動的にこの動作をしました。

00:03:55.000 --> 00:03:59.000
この動作は、presentsWithGestureを使用する場合にも設定されます。

00:03:59.000 --> 00:04:01.000
これがコードでどのように見えるかを覗いてみましょう。

00:04:01.000 --> 00:04:12.000
私のアプリデリゲートでは、UISplitViewControllerのdisplayModeButtonItemを入手し、顧客がタップするためのナビゲーションバーの左バーボタン項目として設定しました。

00:04:12.000 --> 00:04:17.000
だから今、私はiPhone XS MaxとiPhone XRの動作をオプトインしています。

00:04:17.000 --> 00:04:21.000
また、presentsWithGestureをtrueに設定しています。

00:04:21.000 --> 00:04:25.000
これにより、顧客はスワイプでマスタービューにアクセスできます。

00:04:25.000 --> 00:04:28.000
これはオプションで、アプリの必要に応じてfalseに設定できます。

00:04:28.000 --> 00:04:29.000
注意すべきことが1つあります。

00:04:29.000 --> 00:04:35.000
preferredDisplayModeを自動に設定することに依存している場合、これは自動動作です。

00:04:35.000 --> 00:04:46.000
カスタマイズを行い、この動作をオプトアウトしたい場合は、displayModeButtonItemを完全に使用し、presentsWithGestureをfalseに設定してください。

00:04:46.000 --> 00:04:49.000
preferredDisplayModeをallVisibleに設定することもできます。

00:04:49.000 --> 00:04:50.000
わかりました。

00:04:50.000 --> 00:04:54.000
一般的な落とし穴について話しましょう。 では。

00:04:54.000 --> 00:05:00.000
一部のアプリでは、背景画像が特定の寸法に設定されているか、特定のアセットが画面上のスポットに固定されている場合があります。

00:05:00.000 --> 00:05:05.000
これはゲームで最も一般的ですが、アプリはさまざまな理由でこのようなテクニックを使用する可能性があります。

00:05:05.000 --> 00:05:14.000
アプリがスケーリングされた画像を設定している場合、iPhone XS MaxまたはiPhone XRで実行すると、コンテンツが誤ってスケーリングされていることに気付くことがあります。

00:05:14.000 --> 00:05:26.000
標準のUIKitフレームワークを使用するアプリとは異なり、これらの携帯電話はまだ新しいですが、少し特別なケースを行い、アプリまたはアプリが使用しているフレームワークに新しい画面を伝える必要があるかもしれません。

00:05:26.000 --> 00:05:35.000
iPhone XRとiPhone XS Maxの両方のディスプレイ寸法は、幅414ポイント、高さ896ポイントです。

00:05:35.000 --> 00:05:44.000
資産を構築する際に、iPhone XRは2倍のデバイスであり、iPhone XS Maxは3倍のデバイスであることを覚えておいてください。

00:05:44.000 --> 00:05:52.000
したがって、ピクセルでは、iPhone XRの解像度は828 x 1,792ピクセルです。

00:05:52.000 --> 00:06:01.000
iPhone XS Maxの解像度は1,242 x 2,688ピクセルです。

00:06:01.000 --> 00:06:02.000
注意！

00:06:02.000 --> 00:06:07.000
フレームワークが絶対に必要とする場合にのみ、画面の寸法をハードコードする必要があります。

00:06:07.000 --> 00:06:14.000
これにより、ゲームや同様のアプリがゲートからすぐに機能する可能性がありますが、絶対に必要でない限り、これらの方法の使用は避けるべきです。

00:06:14.000 --> 00:06:19.000
UIKitに仕事をさせて、代わりに自動レイアウトを使ってください。

00:06:19.000 --> 00:06:28.000
さまざまなハードウェアモデルでアプリを特定の方法で動作させるのは魅力的かもしれませんが、ハードウェアごとに特別なケースを作ることは避けるべきです。

00:06:28.000 --> 00:06:33.000
これは新機能の開発に時間がかかり、大部分が冗長な作業です。

00:06:33.000 --> 00:06:39.000
さらに、コードが認識されない携帯電話のモデルで実行されている場合、予期しない問題が発生する可能性があります。

00:06:39.000 --> 00:06:43.000
すぐにアプリを更新できない場合、これは顧客を傷つける可能性があります。

00:06:43.000 --> 00:06:52.000
iOSアプリをiPhone Xで実行するための特別なケースを作った場合、iPhone XS MaxとiPhone XRのためにすべてのハードワークをやり直す必要があります。

00:06:52.000 --> 00:07:00.000
グラフィカルなニーズに対応するためにアプリ内で寸法を設定する必要がある場合でも、その文字列チェックの背後にあるデバイスモデルとゲートの動作を検索しないでください。

00:07:00.000 --> 00:07:04.000
「これはiPhone Xですか?」というようなコードを書くべきではありません。Aをしてください。

00:07:04.000 --> 00:07:06.000
他？Bをしてください。」

00:07:06.000 --> 00:07:15.000
これは、アプリ全体にユニバーサルセーフエリアインセットを採用し、将来の自分に多くの時間と労力を節約する絶好の機会です。

00:07:15.000 --> 00:07:22.000
今は、機能の可用性を探しているときに、コードをどのように分岐させるかについて本当に勤勉になるのに最適な時期です。

00:07:22.000 --> 00:07:34.000
iPhone SEやすべてのiPadなど、すでにサポートしている他のiPhoneと同様に、iPhone XRは3D Touchやデュアルカメラをサポートしていないため、これらの動作に頼らないことが重要です。

00:07:34.000 --> 00:07:36.000
例として3D Touchを使ってみましょう。

00:07:36.000 --> 00:07:49.000
ホームアプリは、サポートされているデバイスで3D Touchを使用するが、3D Touchをサポートしていないデバイス、またはそれをオフにした可能性のあるユーザーに完全な機能セットを提供するアプリケーションの素晴らしい例です。

00:07:49.000 --> 00:07:52.000
デバイスが3D Touchを使用しているかどうかを確認するのは簡単です。

00:07:52.000 --> 00:07:55.000
サンプルコードを見てみましょう。 サンプルコードを見てみましょう。

00:07:55.000 --> 00:08:01.000
まず、ここで強調表示されているように、起動時にデバイスが機能をサポートしているかどうかを確認します。

00:08:01.000 --> 00:08:06.000
ただし、アプリの実行中にユーザーが3D Touchをオフにできることを覚えておいてください。

00:08:06.000 --> 00:08:13.000
したがって、t traitCollectionDidChangeデリゲートメソッドの実装の一部として、このチェックも行う必要があります。

00:08:13.000 --> 00:08:25.000
いずれの場合も、3D TouchをサポートしていないデバイスにUILongPressGestureRecognizerなどの代替手段を使用するようにコードを分岐し、すべてのデバイスで完全な機能セットが表現されるようにします。

00:08:25.000 --> 00:08:33.000
疑わしい場合は、コードがnilを処理でき、予期しないものを取り戻すときに優雅に失敗するのに十分堅牢であることを確認してください。

00:08:33.000 --> 00:08:44.000
ほとんどのアプリでは、特にすでにiPhone X用に最適化されている場合は、今年はiPhone XS、iPhone XS Max、iPhone XRをサポートする作業はあまりありません。

00:08:44.000 --> 00:08:52.000
サポートが必要な場合は、iPhone Xのビデオや今年のWWDC 2018セッションからたくさん入手できます。

00:08:52.000 --> 23:59:59.000
関連コンテンツをチェックして、developer.apple.comで詳細を見つけることができます。

