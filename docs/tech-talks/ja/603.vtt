WEBVTT

00:00:01.000 --> 00:00:09.000
このプレゼンテーションでは、GPUが効率的に操作できるタイルメモリ内の画像データを記述できる画像ブロックに焦点を当てます。

00:00:09.000 --> 00:00:14.000
イメージブロックは、タイルメモリに存在する画像データへの最適化されたアクセスを提供します。

00:00:14.000 --> 00:00:17.000
また、A11 GPUを使用すると、直接制御できます。

00:00:17.000 --> 00:00:26.000
アプリケーションにとって意味のある方法でピクセルをレイアウトしたり、データを明示的に移動したりできます。

00:00:26.000 --> 00:00:31.000
イメージブロックは、フラグメント処理と新しいタイルシェーディングステージと深く統合されています。

00:00:31.000 --> 00:00:33.000
従来のコンピューティングでも利用できます。

00:00:33.000 --> 00:00:41.000
どの段階にいても、画像ブロックは2Dデータのグリッドへのアクセスを最適化するため、画像を表現することをお勧めします。

00:00:41.000 --> 00:00:47.000
イメージブロックは、このプレゼンテーションシリーズで説明する他のいくつかの機能の重要な構成要素です。

00:00:47.000 --> 00:00:50.000
イメージブロックをより正確に定義することから始めましょう。

00:00:50.000 --> 00:00:54.000
イメージブロックは、タイルメモリ内の2Dデータ構造です。

00:00:54.000 --> 00:00:57.000
幅、高さ、ピクセル深度があります。

00:00:57.000 --> 00:01:02.000
フラグメント関数は、その場所に対応する単一のピクセルにしかアクセスできません。

00:01:02.000 --> 00:01:07.000
一方、計算カーネルは、イメージブロック全体にアクセスできます。

00:01:07.000 --> 00:01:15.000
各ピクセルは非常に複雑で、複数のコンポーネントで構成され、各コンポーネントは独自の画像面として対処できます。

00:01:15.000 --> 00:01:22.000
これにより、隣接するコンポーネントを一括操作としてデバイスメモリ内の1つ以上のテクスチャに効率的に保存できます。

00:01:22.000 --> 00:01:27.000
イメージブロックは、GPUのフォーマット変換ハードウェアへの一括アクセスも提供します。

00:01:27.000 --> 00:01:33.000
浮動小数点ピクセルは、デバイスメモリに保存すると、宛先テクスチャ形式に変換されます。

00:01:33.000 --> 00:01:42.000
それでは、画像ブロックを使用して、タイルメモリから画像データの移動を加速することの利点の1つを詳しく見てみましょう。

00:01:42.000 --> 00:01:50.000
イメージブロックの前に、おそらく一度に1ピクセルずつ操作する前に、テクスチャの一部をスレッドグループメモリに移動したでしょう。

00:01:50.000 --> 00:01:59.000
しかし、GPUはあなたが画像データを操作していることを理解していなかったので、それらのピクセルを一度に1ピクセルずつデバイスのメモリテクスチャに保存する必要がありました。

00:01:59.000 --> 00:02:06.000
イメージブロックを使用すると、代わりに単一の操作を使用して画像データを保存でき、はるかに効率的です。

00:02:06.000 --> 00:02:10.000
それでは、イメージブロックのプロパティをMetalに記述する方法に目を向けましょう。

00:02:10.000 --> 00:02:15.000
計算パスでは、ここに示されているAPIを使用して、画像ブロックの幅と高さを記述します。

00:02:15.000 --> 00:02:18.000
ディスパッチごとに寸法が異なる場合があります。

00:02:18.000 --> 00:02:22.000
イメージブロックのピクセル深度は、構造としてシェーディング言語で説明されています。

00:02:22.000 --> 00:02:28.000
画像ブロック全体は、その構造体によって型がテンプレート化された引数として利用可能になります。

00:02:28.000 --> 00:02:32.000
シェーディング言語の構文を詳しく見てみましょう。

00:02:32.000 --> 00:02:38.000
この例では、それぞれがさまざまな数のコンポーネントを持つ3つの要素で構成されるピクセルを記述しています。

00:02:38.000 --> 00:02:42.000
イメージブロックは、引数としてカーネルで利用可能になります。

00:02:42.000 --> 00:02:54.000
カーネルは、その場所を引数として取り、threadgroup_imageblockと呼ばれる新しいアドレス空間へのポインタを返すデータメソッドを使用して、参照によってイメージブロック内の任意の場所にアクセスします。

00:02:54.000 --> 00:03:01.000
特定の場所を参照して、その場所の要素を読み書きできます。

00:03:01.000 --> 00:03:06.000
先に述べたように、イメージブロックは、デバイスのメモリテクスチャに効率的に格納できる平面に配置されています。

00:03:06.000 --> 00:03:11.000
シェーディング言語では、スライスを一緒に格納できる隣接する平面と呼びます。

00:03:11.000 --> 00:03:14.000
カーネルの例を見てみましょう。 

00:03:14.000 --> 00:03:24.000
この例では、ソーステクスチャをイメージブロックにロードし、そのブロックでいくつかの画像処理を実行し、カラー要素を宛先テクスチャに保存する準備が整いました。

00:03:24.000 --> 00:03:32.000
書き込みを実行するには、スレッドグループのスレッドが1つだけ必要なので、すべてのスレッドがイメージブロックの処理を完了していることを確認するために、まずバリアする必要があります。

00:03:32.000 --> 00:03:40.000
Metalがバリアに新しいメモリターゲットを追加し、イメージブロックへの書き込みが完了するのを待つだけでよいと宣言していることに注意してください。

00:03:40.000 --> 00:03:45.000
次に、スライスメソッドを使用して、イメージブロックから目的のスライスを取得します。

00:03:45.000 --> 00:03:49.000
スライスメソッドは、スライスの一部である任意のピクセル要素への参照を取ります。

00:03:49.000 --> 00:03:55.000
最後に、スライスを宛先のテクスチャに書き込みます。

00:03:55.000 --> 00:04:02.000
各画像ブロックはおそらくテクスチャの領域のみを表すため、画像ブロックを書き込むテクスチャオフセットを指定します。

00:04:02.000 --> 00:04:07.000
それでは、フラグメント関数のイメージブロックの指定方法を見てみましょう。

00:04:07.000 --> 00:04:16.000
計算パスのイメージブロックとは異なり、レンダリングパスのイメージブロックの寸法はパス全体で一定であり、ここに示すプロパティを使用して設定されます。

00:04:16.000 --> 00:04:22.000
イメージブロックのピクセル深度は、カーネルにすでに示したように、シェーディング言語で構造体として宣言できます。

00:04:22.000 --> 00:04:28.000
ただし、フラグメント関数は、レンダリングパスアタッチメントを使用してピクセル深度を宣言することもサポートしています。

00:04:28.000 --> 00:04:31.000
構文を見てみましょう。 

00:04:31.000 --> 00:04:35.000
この例では、シェーディング言語でピクセル構造を明示的に宣言しました。

00:04:35.000 --> 00:04:46.000
フラグメント関数はイメージブロック内の暗黙の場所にのみアクセスできるため、引数タイプは構造体自体ですが、imageblock_data属性でタグ付けされています。

00:04:46.000 --> 00:04:50.000
また、同じ属性で戻り値にタグを付ける必要があります。

00:04:50.000 --> 00:04:55.000
そうすることで、Metalは正しいアクセス命令を生成できます。

00:04:55.000 --> 00:05:03.000
それでは、従来のレンダリングパスアタッチメントを使用してピクセル構造を宣言するときに、この同じ例がどのように見えるかを見てみましょう。

00:05:03.000 --> 00:05:06.000
この形式は、あなたがすでに知っている構文と同じです。

00:05:06.000 --> 00:05:13.000
実際、タイルメモリは常にAシリーズGPUの重要な側面であるため、レンダリングパスでは常にイメージブロックを使用してきました。

00:05:13.000 --> 00:05:18.000
新しいのは、Metal 2がタイルメモリに一般的にアクセス可能になったことです。

00:05:18.000 --> 00:05:25.000
このフォームは、レンダリングパスにアタッチされたテクスチャから派生した基礎となるイメージブロックストレージフォーマットを抽象化します。

00:05:25.000 --> 00:05:34.000
テクスチャストレージタイプに関係なく、データはフラグメント関数で浮動小数点または整数として表示されます。

00:05:34.000 --> 00:05:40.000
A11と以前のアーキテクチャのもう1つの違いは、これらの暗黙のイメージブロックフォーマット変換が発生する場所です。

00:05:40.000 --> 00:05:47.000
A7からA10 GPUでは、ストレージフォーマットはタイルメモリの浮動小数点に拡張されました。

00:05:47.000 --> 00:05:56.000
これが、Metalがピクセルフォーマットごとに2つのサイズを文書化する理由です。1つはデバイスメモリに保存されている場合、もう1つはレンダリングパスアタッチメントとしてタイルメモリに保存されている場合です。

00:05:56.000 --> 00:06:03.000
A11では、フォーマット変換は各ロードで行われ、タイルメモリからシェーダーコアの一時レジスタに保存されます。

00:06:03.000 --> 00:06:09.000
そうすることで、タイルメモリからさらに多くの使用を絞り出すことができます。

00:06:09.000 --> 00:06:15.000
ピクセル構造を宣言する方法を選択できるようになりましたので、決定に役立つベストプラクティスを確認しましょう。

00:06:15.000 --> 00:06:23.000
暗黙のイメージブロックは、フラグメント関数が基礎となるストレージ形式を抽象化するため、複数のレンダリングパスアタッチメントレイアウトをサポートする必要がある場合に最適です。

00:06:23.000 --> 00:06:30.000
暗黙のイメージブロックは、構造がAPIによって知られているため、ロードおよびストアアクションとも互換性があります。

00:06:30.000 --> 00:06:35.000
一方、明示的な画像ブロックを使用すると、より複雑なピクセル構造を表現できます。

00:06:35.000 --> 00:06:45.000
明示的なイメージブロックもメインメモリバッキングを必要としないため、レンダリングパスの範囲内で完全に生成および消費される一時的なデータに最適です。

00:06:45.000 --> 00:06:50.000
では、複雑なピクセル構造の意味を詳しく見てみましょう。

00:06:50.000 --> 00:06:59.000
この例では、ピクセルごとに複数の半透明の色とその深さを保存し、後でソートして合成して、より正確な透明度効果を得ることができます。

00:06:59.000 --> 00:07:10.000
単一のフラグメント宣言から始めて、それらの配列を宣言し、シェーダーとの間で渡すことができるトップレベルの構造体にそれをネストします。

00:07:10.000 --> 00:07:17.000
レンダリングパスの添付ファイルを使用してこの構造を表現することは厄介であり、著者の意図を覆い隠すだろう。

00:07:17.000 --> 00:07:23.000
もちろん、Metalでは仕事に適したツールを選択できるため、暗黙の形式と明示的な形式を選択する必要はありません。

00:07:23.000 --> 00:07:33.000
また、ミキシングを使用すると、イメージブロックをコードベースに段階的に採用し、明示的なフォームの恩恵を受ける既存のシェーダーに新機能を簡単に統合できます。

00:07:33.000 --> 00:07:37.000
両方のフォームを一緒に使用するのは簡単で、2つのイメージブロック引数を提供するだけです。

00:07:37.000 --> 00:07:40.000
例を見てみましょう。 例を見てみましょう。

00:07:40.000 --> 00:07:45.000
ご覧のとおり、入力と出力の両方として2つの画像ブロックを提供できます。

00:07:45.000 --> 00:07:52.000
colorとimageblock_data属性は、どのスライスがレンダリングパスアタッチメントから派生し、どのスライスが派生しないかをMetalに明確にします。

00:07:52.000 --> 00:07:58.000
入力と出力ごとに最大2つの画像ブロックを各関数で宣言できます。

00:07:58.000 --> 00:08:03.000
明示的なイメージブロックを使用すると、パックされたタイプを使用してピクセルレイアウトを正確に制御できます。

00:08:03.000 --> 00:08:11.000
Metalシェーディング言語は、伝統的に頂点と定数データレイアウトを記述してきたパックされた浮動小数点ベクトル型をすでに提供しています。

00:08:11.000 --> 00:08:19.000
しかし、今は、暗黙のイメージブロックとテクスチャピクセル形式を使用して以前に記述できたものと一致するパックタイプが必要です。

00:08:19.000 --> 00:08:22.000
メタル2は、シェーディング言語にそのようなタイプを追加します。

00:08:22.000 --> 00:08:28.000
これらのフォーマットは、先ほど説明したロード/ストアハードウェアを使用して、浮動小数点との間で変換されます。

00:08:28.000 --> 00:08:34.000
さらに、これらの新しいパック形式は、頂点と一定のデータレイアウトを記述するためにも使用できます。

00:08:34.000 --> 00:08:38.000
シェーディング言語でこれらの新しいタイプを宣言する方法を見てみましょう。

00:08:38.000 --> 00:08:44.000
この例では、画像ブロックと頂点データの両方を記述するために使用される新しいパック型のいくつかを見てみます。

00:08:44.000 --> 00:08:54.000
これらのタイプでは、シェーダーコア内で使用されるストレージ形式とアンパック形式の両方を宣言する必要があります。

00:08:54.000 --> 00:08:58.000
では、追加されたすべての新しいパックされたデータタイプを見てみましょう。

00:08:58.000 --> 00:09:07.000
ご覧のとおり、メタルシェーディング言語は、1つ、2つ、4つのコンポーネント正規化タイプを追加し、それぞれが8ビットまたは16ビットコンポーネントをサポートします。

00:09:07.000 --> 00:09:20.000
また、署名済みバリアントと未署名バリアントの両方を追加し、10a2、ミニフロート、共有指数、sRGBなどのより特殊な32ビットフォーマットのサポートも追加しました。

00:09:20.000 --> 00:09:27.000
最後に、XcodeのGPUデバッガは、イメージブロックの視覚化と検査を直接サポートします。

00:09:27.000 --> 00:09:31.000
各スライスは、まるでテクスチャであるかのように検査することができます。

00:09:31.000 --> 00:09:35.000
ここでは、上部にサンプルコードのGバッファレイアウトの例があります。

00:09:35.000 --> 00:09:41.000
そして、下部には、XcodeのGPUデバッガに同じイメージブロックショーがあります。

00:09:41.000 --> 00:09:46.000
バインドされたリソースビューのタイルセクションは、イメージブロックスライスをテクスチャのセットとして表示します。

00:09:46.000 --> 00:09:51.000
ここから、他のテクスチャと同じように各スライスを検査できます。

00:09:51.000 --> 00:10:04.000
このプレゼンテーションでは、イメージブロックがタイルメモリからデバイスメモリに複数のピクセルを効率的に移動し、ストレージ密度を向上させるためにタイルメモリ内の画像データのレイアウトを正確に制御する方法を見ました。

00:10:04.000 --> 00:10:13.000
また、A11 GPUの新しいパック/アンパックハードウェアを、イメージブロックと他のアドレス空間の両方で活用する方法も見ました。

00:10:13.000 --> 00:10:21.000
メタル2の詳細とサンプルコードへのリンクについては、開発者のウェブサイト（developer.apple.com/metal）をご覧ください。

00:10:21.000 --> 23:59:59.000
見てくれてありがとう!

