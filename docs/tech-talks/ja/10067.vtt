WEBVTT

00:00:00.000 --> 00:00:05.000
こんにちは、Cloud FileProviderチームのJohannes Fortmannです。

00:00:05.000 --> 00:00:15.000
今日は、iOS 16で導入された新しいFileProvider APIを使用して、デスクトップクラスの同期をiOSにもたらす方法について説明します。

00:00:15.000 --> 00:00:21.000
紹介の後、ファイルプロバイダの目的を簡単にまとめます。

00:00:21.000 --> 00:00:29.000
アプリを設計するための最適なアプローチと、iOSで特に重要になるベストプラクティスについて説明します。

00:00:29.000 --> 00:00:34.000
最後に、iOSで実行されているプロバイダーの簡単なデモをお見せします。

00:00:34.000 --> 00:00:39.000
Big Surは、ファイルをMacに同期するための宣言型APIを導入しました。

00:00:39.000 --> 00:00:43.000
このAPIは、多くのクラウドベンダーによって採用され、大きな成功を収めています。

00:00:43.000 --> 00:00:51.000
私のチームは着実にAPIの改善に取り組んでおり、iOS 16でも利用できるようにすることに興奮しています。

00:00:51.000 --> 00:00:58.000
このAPIにより、iOSアプリは「デスクトップクラス同期」と呼ばれるものを提供できるようになります。

00:00:58.000 --> 00:01:01.000
それはどういう意味ですか? 

00:01:01.000 --> 00:01:09.000
iOSのアプリがより強力になるにつれて、ファイルシステム上の共有場所にアクセスできることが重要になります。

00:01:09.000 --> 00:01:16.000
人々は、これらの強力なアプリがあらゆる種類のファイルシステムオブジェクトにアクセスできることを望んでいます。

00:01:16.000 --> 00:01:21.000
彼らが選択すれば、彼らのアプリはフォルダにアクセスし、新しいファイルを作成できるはずです。

00:01:21.000 --> 00:01:26.000
私たちは、一貫性を保証しながら、これらすべてが起こることを望んでいます。

00:01:26.000 --> 00:01:28.000
一貫性とはどういう意味ですか?

00:01:28.000 --> 00:01:34.000
iOSでは、バックグラウンドランタイムは歴史的に電力の懸念から制限されてきた。

00:01:34.000 --> 00:01:39.000
同時に、変更はバックグラウンドでアップロードされる予定です。

00:01:39.000 --> 00:01:45.000
この問題を解決するために、最新のFileProvider APIが導入されました。

00:01:45.000 --> 00:01:59.000
基本レベルでは、アイテムの列挙、コンテンツの取得とアップロード、リモートで変更された場合のアイテムのリストの更新を担当するアプリ拡張機能を実装します。

00:01:59.000 --> 00:02:07.000
システムは、お客様が提供した情報を公開し、一貫性を維持する責任があります。

00:02:07.000 --> 00:02:14.000
システムの重要なタスクは、エラーを追跡し、必要に応じて再試行することです。

00:02:14.000 --> 00:02:19.000
コンテンツの取得など、一部の操作では、再試行が自然に実行されます。

00:02:19.000 --> 00:02:26.000
ユーザーは積極的にダウンロードを待っており、おそらくプログレスバーを注意深く監視しています。

00:02:26.000 --> 00:02:29.000
一方、アップロードにはスケジューリングが必要です。

00:02:29.000 --> 00:02:36.000
ディスク上のアイテムの状態を追跡することで、システムは更新されたコンテンツがアップロードされることを保証します。

00:02:36.000 --> 00:02:41.000
進捗状況とエラーは追跡され、必要に応じてアップロードを再試行します。

00:02:41.000 --> 00:02:45.000
もう1つの複雑なトピックは、アップロード中の一貫性です。

00:02:45.000 --> 00:02:57.000
システムは、ファイルの内容のクローンを管理し、アップロード中にファイルへのその後のアクセスが成功し、正しいデータを表示するようにします。

00:02:57.000 --> 00:03:10.000
これらの操作中、システムはまた、複数のアプリがアクセスしていても、ローカルバージョンが一貫性を保つことを保証し、それにはリモートサーバーからの同期ダウンが含まれます。

00:03:10.000 --> 00:03:18.000
これは、APFS機能とファイル調整を使用して透過的に実装されます。

00:03:18.000 --> 00:03:24.000
ストレージの制限は、モバイルデバイスの重要な制約です。

00:03:24.000 --> 00:03:31.000
このシステムは、APFS機能を使用して、ローカルファイルの変更状態を原子的に追跡します。

00:03:31.000 --> 00:03:40.000
これにより、ディスクの使用状況と最も最近使用されたステータスに基づいて、ローカルな変更がないファイルを透過的に立ち退かせることができます。

00:03:40.000 --> 00:03:47.000
完全にアップロードされたファイルは、設定のストレージ管理ペインでアプリにカウントされません。

00:03:47.000 --> 00:03:53.000
これまでのところ、システムと拡張機能について話し合ったことに気付いたかもしれません。

00:03:53.000 --> 00:03:56.000
あなたのアプリがどこから来るのかについて話しましょう。

00:03:56.000 --> 00:04:00.000
懸念事項の厳格な分離を採用することをお勧めします。

00:04:00.000 --> 00:04:07.000
このシステムは、ディスク上の構造を管理し、タスクをスケジュールする責任があります。

00:04:07.000 --> 00:04:12.000
あなたの拡張機能は、これらのタスクを上下に同期する責任があります。

00:04:12.000 --> 00:04:18.000
システムは、ファイル階層に関するすべての状態と、どの部分が同期を必要とするかを追跡します。

00:04:18.000 --> 00:04:22.000
つまり、あなたの拡張機能は非常に軽量になる可能性があるということです。

00:04:22.000 --> 00:04:26.000
アイテム固有の状態をまったく追跡する必要はありません。

00:04:26.000 --> 00:04:30.000
あなたのアプリケーションは、いかなる同期に対しても責任を負いません。

00:04:30.000 --> 00:04:35.000
理想的には、サーバーとまったく話す必要はありません。

00:04:35.000 --> 00:04:41.000
代わりに、2つのメカニズムを介して拡張機能と相互作用します。

00:04:41.000 --> 00:04:47.000
システム上の他のアプリケーションと同じように、拡張機能と間接的に対話できます。

00:04:47.000 --> 00:04:53.000
ルートを含む任意の管理対象アイテムのファイルURLを取得するAPIがあります。

00:04:53.000 --> 00:05:00.000
これらの場所は、通常のファイルシステムAPIを使用してアクセスできます。

00:05:00.000 --> 00:05:06.000
または、アプリは拡張機能への直接XPCサービス接続をリクエストすることもできます。

00:05:06.000 --> 00:05:17.000
これは、ファイルの共有や競合の解決など、ファイルシステムの操作として表現できないタスクを処理する場合に特に便利です。

00:05:17.000 --> 00:05:26.000
これらのメカニズムの両方は、Filesアプリで追加の統合ポイントを提供するために、FileProvider UI拡張機能でも使用できます。

00:05:26.000 --> 00:05:32.000
無国籍プロバイダーで特に重要になる3つの点に触れたいと思います。

00:05:32.000 --> 00:05:35.000
まず、アップロードについて話しましょう。

00:05:35.000 --> 00:05:42.000
先に述べたように、システムはアップロードを追跡し、アップロードを実行するための延長時間を許可します。

00:05:42.000 --> 00:05:50.000
これの重要な結果は、進捗状況を報告することで、アップロードが実際に進行していることをシステムに認識させる必要があることです。

00:05:50.000 --> 00:05:54.000
アップロードタスクが進まない場合は、キャンセルされます。

00:05:54.000 --> 00:06:03.000
システムはアップロードをきれいに終了するための猶予期間を提供しますが、キャンセルに時間がかかりすぎると、延長は終了します。

00:06:03.000 --> 00:06:05.000
コードを確認しましょう。

00:06:05.000 --> 00:06:12.000
キャンセルハンドラを実装するには、タスク固有のメソッドからの進捗リターンに設定するだけです。

00:06:12.000 --> 00:06:16.000
アップロードの場合、それはmodifyItemです。

00:06:16.000 --> 00:06:22.000
ハンドラでは、実行していた実際のアップロード作業をキャンセルします。

00:06:22.000 --> 00:06:27.000
もちろん、完了ハンドラーを呼び出すと、キャンセルエラーが発生したことを通知する必要があります。

00:06:27.000 --> 00:06:37.000
ここでのコード例では、これを便利にするために非同期タスクのキャンセルを使用していますが、完了ハンドラを手動で呼び出すこともできます。

00:06:37.000 --> 00:06:40.000
次に、同期ダウンパスについて話しましょう。

00:06:40.000 --> 00:06:47.000
ユーザーがファイルを操作すると、メインアプリはサーバーから変更を受信するために実行されません。

00:06:47.000 --> 00:06:52.000
リモートの変更についてシステムに通知するには、プッシュ通知を実装する必要があります。

00:06:52.000 --> 00:06:57.000
PushKitは、ファイルプロバイダーの特定のプッシュタイプを公開します。

00:06:57.000 --> 00:07:01.000
これらのプッシュは、拡張機能から直接登録できます。

00:07:01.000 --> 00:07:05.000
サーバーでは、明確に定義されたペイロードでプッシュを送信します。

00:07:05.000 --> 00:07:09.000
システムはプッシュを受け取り、必要に応じて現在の状態を更新します。

00:07:09.000 --> 00:07:22.000
他のタイプのタスクと同様に、バッテリーの状態やユーザーが現在ファイルを見ているかどうかなど、状況に応じて、システムは実際の更新を遅らせる可能性があります。

00:07:22.000 --> 00:07:30.000
この最後のことは、私があなたに注意を喚起したいものです。システムは、拡張機能が報告するフォルダ階層を管理します。

00:07:30.000 --> 00:07:33.000
これにより、フォルダ階層全体を販売できます。

00:07:33.000 --> 00:07:36.000
あなたの内線番号は、ここで余分なことをする必要はありません。

00:07:36.000 --> 00:07:40.000
これは、最新のファイルプロバイダーではデフォルトで有効になっています。

00:07:40.000 --> 00:07:45.000
最後の機能でどのようなワークフローが可能になるかを簡単に実演しましょう。

00:07:45.000 --> 00:07:48.000
このセッションのサンプルコードでデバイスを設定しました。

00:07:48.000 --> 00:07:51.000
サンプルコードをiOSに移植しました。

00:07:51.000 --> 00:07:58.000
サーバーへのログインを処理するためにiOSアプリを構築しましたが、拡張機能はmacOSバージョンとほとんど変更されていません。

00:07:58.000 --> 00:08:01.000
私は今、iPadでサンプルコードを実行しています。

00:08:01.000 --> 00:08:06.000
右側でファイルが実行されていて、すでにファイルを同期しています。

00:08:06.000 --> 00:08:09.000
フォルダの選択を利用するアプリも書きました。

00:08:09.000 --> 00:08:13.000
私のアプリは、フォルダ内のすべての画像にセピアフィルターを適用します。

00:08:13.000 --> 00:08:22.000
このタイプのアプリケーションは、個々のアイテムのインタラクションを強制することなく、フォルダ内のすべてのアイテムを操作できるため、フォルダアクセスの恩恵を受けます。

00:08:22.000 --> 00:08:29.000
デスクトップクラスの同期では、ファイルアプリからバッチエディタにフォルダをドラッグするだけです。

00:08:29.000 --> 00:08:35.000
進捗状況を監視できるように、フォルダとファイルをプルアップさせてください。

00:08:35.000 --> 00:08:40.000
その後、ボタンを押すと、すべての写真がダウンロードされ、変更されます。

00:08:40.000 --> 00:08:45.000
変更後、それらは自動的にアップロードされます。

00:08:45.000 --> 00:08:53.000
拡張機能によって報告されたアップロードの進捗状況は、ファイルアプリの下部にあるユーザーに現れ、それらをループに保ちます。

00:08:53.000 --> 00:08:57.000
私のアプリでこのようなものを実装したかったとしましょう。

00:08:57.000 --> 00:09:00.000
まず、アイテムのドラッグを実装しましょう。

00:09:00.000 --> 00:09:04.000
ドラッグを開始できるようにするには、onDragメソッドを実装します。

00:09:04.000 --> 00:09:07.000
このメソッドはNSItemProviderを返します。

00:09:07.000 --> 00:09:14.000
ドラッグするファイルの種類を使用して、itemProviderにファイル表現を登録します。

00:09:14.000 --> 00:09:17.000
私たちの場合、それはフォルダです。

00:09:17.000 --> 00:09:23.000
getUserVisibleURLメソッドを使用してURLを取得します。

00:09:23.000 --> 00:09:30.000
受信側では、onDropを実装して、ビューをドロップターゲットとしてマークします。

00:09:30.000 --> 00:09:35.000
その後、適切なアイテムプロバイダーからファイルURLを読み込むことができます。

00:09:35.000 --> 00:09:40.000
これはあなたのサンドボックスの外にあるファイルになることに注意してください。

00:09:40.000 --> 00:09:47.000
アプリがアクセスするには、URLのセキュリティ範囲を消費して解放する必要があります。

00:09:47.000 --> 00:09:49.000
あなたの次のステップは何ですか?

00:09:49.000 --> 00:09:54.000
iOSアプリを含むようにサンプルコードを更新しました。

00:09:54.000 --> 00:09:59.000
ダウンロードして、シンプルなステートレスプロバイダーの設定を試してみてください。

00:09:59.000 --> 00:10:04.000
ゼロから始める場合は、必ず更新されたXcodeテンプレートを使用してください。

00:10:04.000 --> 00:10:07.000
始めるための基本的なフレームが含まれています。

00:10:07.000 --> 00:10:19.000
ファイルプロバイダーとその実装方法の詳細については、WWDC21の「macOSのFileProviderでファイルをクラウドに同期する」を参照してください。

00:10:19.000 --> 00:10:20.000
ご覧いただきありがとうございます。

00:10:20.000 --> 23:59:59.000
iOSデバイスであなたのパフォーマンスと信頼性の高いプロバイダーを使用することに興奮しています。

