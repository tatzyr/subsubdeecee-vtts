WEBVTT

00:00:01.000 --> 00:00:05.000
こんにちは、GPUソフトウェアチームのライオネル・ルマリエです。

00:00:05.000 --> 00:00:12.000
このセッションでは、Metal Counter APIを使用して、実行時に正確なGPUタイミングを取得します。

00:00:12.000 --> 00:00:14.000
私たちはいくつかのトピックを取り上げます。

00:00:14.000 --> 00:00:19.000
メタルカウンターAPIの簡単なイントロから始めます。

00:00:19.000 --> 00:00:25.000
次に、典型的なライブプロファイリングHUDの主な特徴を簡単に見ていきます。

00:00:25.000 --> 00:00:31.000
APIを段階的に使用して、プロファイリング情報を収集します。

00:00:31.000 --> 00:00:36.000
そして、このデータがHUDにどのように適合するかを見て締めくくります。

00:00:36.000 --> 00:00:40.000
それでは、APIの簡単なイントロから始めましょう。

00:00:40.000 --> 00:00:44.000
メタルカウンターAPIはiOS 14で新しく登場します。

00:00:44.000 --> 00:00:49.000
macOS Catalinaで利用可能で、macOS Big Surで拡張されました。

00:00:49.000 --> 00:00:55.000
Apple Siliconを搭載したiOSとmacOSでは、ステージの境界タイミングにアクセスできます。

00:00:55.000 --> 00:01:01.000
つまり、頂点、フラグメント、計算パスの正確な開始時間と終了時間です。

00:01:01.000 --> 00:01:12.000
インテルとAMDのGPUでは、個々のパス内でも描画境界タイミング、正確なGPUタイムスタンプを取得できます。

00:01:12.000 --> 00:01:18.000
次に、ライブプロファイリングHUDの主な機能を簡単にまとめましょう。

00:01:18.000 --> 00:01:22.000
ライブHUDを使用して、実行時にアプリのパフォーマンスを追跡します。

00:01:22.000 --> 00:01:28.000
XcodeやInstrumentsでオフラインで調査する必要がある問題領域を見つけるのに役立ちます。

00:01:28.000 --> 00:01:34.000
たとえば、デバイスごとに解像度と品質の設定を調整するためにも使用できます。

00:01:34.000 --> 00:01:39.000
例として、典型的なライブHUDは次のようになります。

00:01:39.000 --> 00:01:51.000
フレームタイムは、スクロール折れ線グラフとして、フレームヒッチ、メモリ使用量、解像度などに関する統計、CPUイベントのタイムラインをキャッチするのに役立ちます。

00:01:51.000 --> 00:01:55.000
そして今日は、GPUイベントをタイムラインに追加します。

00:01:55.000 --> 00:02:05.000
通常、CPUマーカーの場合、mach_absolute_timeを使用して最も重要な機能を計測し、開始タイムスタンプと終了タイムスタンプを取得します。

00:02:05.000 --> 00:02:16.000
CPUマーカーの良いスタートは、コマンドバッファワークの周りにそれらを置くことです。作成時の開始マーカーとコミット時の終了マーカーです。

00:02:16.000 --> 00:02:21.000
これにより、レンダリングのCPUコストの概要がわかります。

00:02:21.000 --> 00:02:25.000
次に、同等のGPUマーカーを追加したい。

00:02:25.000 --> 00:02:31.000
ここで見ているように、Metal System TraceタイムラインのGPUイベントに精通しているかもしれません。

00:02:31.000 --> 00:02:37.000
この例のiOSでは、タイルベースの遅延レンダリングアーキテクチャのさまざまな段階を示しています。

00:02:37.000 --> 00:02:42.000
ここでは、頂点とフラグメントの処理作業を見ることができます。

00:02:42.000 --> 00:02:48.000
これを行うには、GPUファームウェアは頂点ステージの開始と終了を記録します。

00:02:48.000 --> 00:02:52.000
次に、フラグメントステージの開始と終了を記録します。

00:02:52.000 --> 00:02:57.000
そして、メタルシステムトレースはタイムラインにステージを表示します。

00:02:57.000 --> 00:03:02.000
即時モードGPUの場合、ドローコールのグループのイベントをログに記録できます。

00:03:02.000 --> 00:03:10.000
たとえば、すべての描画呼び出しの前にレンダリングオブジェクト1の開始を記録し、レンダリングオブジェクト2の開始を記録します。

00:03:10.000 --> 00:03:13.000
そして最後に、オブジェクト2の終わり。

00:03:13.000 --> 00:03:20.000
次に、GPUが各オブジェクトのレンダリングに費やした時間を正確に示すタイムラインがあります。

00:03:20.000 --> 00:03:25.000
それでは、それを達成するためにメタルカウンターAPIを使いましょう。

00:03:25.000 --> 00:03:28.000
まず、どのカウンターサンプリングモードが利用可能かを確認することから始めます。

00:03:28.000 --> 00:03:39.000
先ほど見たように、GPUがステージ境界、頂点、フラグメント、または計算ステージで記録すべきかどうか、またはドロー境界で記録すべきかどうかを知る必要があります。

00:03:39.000 --> 00:03:52.000
supportsCounterSampling APIを使用して、現在のデバイスがステージ境界、TBDR GPU、または無制限モードGPUの境界を描画しているかどうかを確認します。

00:03:52.000 --> 00:03:56.000
次に、デバイスで利用可能なカウンターセットを確認します。

00:03:56.000 --> 00:04:02.000
カウンターセットには、タイムスタンプ、ステージ使用率、パイプライン統計が含まれます。

00:04:02.000 --> 00:04:07.000
GPUマーカーには、タイムスタンプを収集するカウンターセットが必要です。

00:04:07.000 --> 00:04:14.000
したがって、デバイスで利用可能なすべてのカウンタセットを列挙し、タイムスタンプ用のものを選択します。

00:04:14.000 --> 00:04:23.000
適切なカウンターを設定したら、一部のデバイスがタイムスタンプをサポートしていない可能性があるため、タイムスタンプがあることを確認してください。

00:04:23.000 --> 00:04:25.000
初期設定は終わりました。

00:04:25.000 --> 00:04:29.000
それでは、各フレームの実行時に必要なものを見てみましょう。

00:04:29.000 --> 00:04:31.000
簡単なステップは4つだけです。

00:04:31.000 --> 00:04:38.000
まず、サイズ、ストレージモード、先ほど調べたカウンタセットのサンプルバッファを作成します。

00:04:38.000 --> 00:04:41.000
次に、サンプルバッファをパス記述子に追加します。

00:04:41.000 --> 00:04:45.000
これは、パスごとに少なくとも1つのバッファが必要であることを意味することに注意してください。

00:04:45.000 --> 00:04:52.000
次に、ドロー境界でサンプリングを使用している場合は、重要なポイントでサンプリングコマンドを追加します。

00:04:52.000 --> 00:04:56.000
最後に、完了ハンドラでは、カウンタを解決します。

00:04:56.000 --> 00:05:01.000
そして、必要に応じてCPUとGPUのタイムスタンプを揃えることについて話します。

00:05:01.000 --> 00:05:05.000
各ステップを詳細に確認しましょう。

00:05:05.000 --> 00:05:09.000
まず、記述子を使用してサンプルバッファを作成します。

00:05:09.000 --> 00:05:15.000
適切なサイズになるように、保持できるサンプルの最大数を指定します。

00:05:15.000 --> 00:05:19.000
ここでは6つのサンプルを使用しますが、通常はそれ以上のものを使用します。

00:05:19.000 --> 00:05:21.000
次に、ストレージモードを設定します。

00:05:21.000 --> 00:05:24.000
共有モードはここで素晴らしいです。

00:05:24.000 --> 00:05:29.000
データはそれほど多くなく、カウンターへのアクセスがさらに簡単になります。

00:05:29.000 --> 00:05:33.000
使用するカウンタセット、タイムスタンプ用のカウンタセットを指定します。

00:05:33.000 --> 00:05:36.000
最後に、サンプルバッファを作成します。

00:05:36.000 --> 00:05:41.000
これまでのところ、とても良いです。今、私たちは6つのサンプルのためのバッファを持っています。

00:05:41.000 --> 00:05:45.000
例として、レンダリングエンコーダで使用しましょう。

00:05:45.000 --> 00:05:49.000
コンピューティングエンコーダとBlitエンコーダでも同じことを行います。

00:05:49.000 --> 00:05:55.000
このためには、レンダリングパス記述子のサンプルバッファアタッチメントを使用します。

00:05:55.000 --> 00:05:58.000
ステージ境界を使用している場合は、ここで設定します。

00:05:58.000 --> 00:06:02.000
頂点ステージの開始と終了を指定します。

00:06:02.000 --> 00:06:06.000
サンプルバッファのインデックス0と1に配置しています。

00:06:06.000 --> 00:06:12.000
それが、GPUが各サンプルをどこに書き込むか、どこから取り出すかを知る方法です。

00:06:12.000 --> 00:06:15.000
フラグメントステージの開始と終了についても同じです。

00:06:15.000 --> 00:06:22.000
最後に、これらのサンプルを保存するために作成したサンプルバッファを指摘しました。

00:06:22.000 --> 00:06:28.000
ドロー境界をサンプリングするには、コマンドストリームの重要なポイントにサンプルコマンドを追加します。

00:06:28.000 --> 00:06:34.000
これらの最初の明らかな配置は、すべてのドローコールの前と後です。

00:06:34.000 --> 00:06:39.000
したがって、新しいエンコーダを作成したら、すぐにサンプルコマンドを追加します。

00:06:39.000 --> 00:06:46.000
ステージ境界サンプルのために最初の4つのスロットをすでに予約しているので、インデックス4に置きます。

00:06:46.000 --> 00:06:54.000
すべてのドローコールの後、エンコーダを終了する直前に、インデックス5にサンプルコマンドを追加します。

00:06:54.000 --> 00:07:00.000
したがって、GPUは、そのエンコーダのすべての作業の前後にタイムスタンプを記録します。

00:07:00.000 --> 00:07:05.000
重要なマイルストーンをマークするために、描画呼び出しのグループ間でより多くのサンプルコマンドを追加できます。

00:07:05.000 --> 00:07:11.000
サンプルバッファが事前に十分なスペースで割り当てられていることを確認してください。

00:07:11.000 --> 00:07:17.000
そういえば、ステージ境界とドロー境界サンプリングの両方に十分な大きさのバッファを割り当てました。

00:07:17.000 --> 00:07:28.000
相互に排他的であるため、ステージに十分な量を割り当てたり、境界サンプリングを単独で描画したりすることで、簡単に最適化できます。

00:07:28.000 --> 00:07:35.000
そうです。GPUは、ステージでタイムスタンプカウンタをサンプリングするか、境界を描画するように指示されています。

00:07:35.000 --> 00:07:40.000
次に、レンダリングが完了するのを待ち、ハンドラでデータを収集します。

00:07:40.000 --> 00:07:43.000
エンコーダごとにサンプルバッファを作成したことを忘れないでください。

00:07:43.000 --> 00:07:49.000
したがって、一般的なバッファ補完ハンドラでは、複数のサンプルバッファを解析する必要があるかもしれません。

00:07:49.000 --> 00:07:52.000
それぞれについて、カウンターを解決します。

00:07:52.000 --> 00:07:59.000
これにより、さまざまな特定のデータを、解析が非常に簡単な統一された金属構造体に変換します。

00:07:59.000 --> 00:08:03.000
単にそれを指して、CounterResult構造体を使用してください。

00:08:03.000 --> 00:08:09.000
vertexStartはインデックスゼロであるべきだと指定したため、そこから直接読みました。

00:08:09.000 --> 00:08:13.000
その後、他のすべてのサンプルで同じことをします。

00:08:13.000 --> 00:08:16.000
ここではいくつかのエラーチェックが必要であることに注意してください。

00:08:16.000 --> 00:08:27.000
GPUがサンプルバッファを埋められなかった可能性があるため、結果ステップが予想されるサンプル数を収集し、各サンプルが有効であることを確認する必要があります。

00:08:27.000 --> 00:08:34.000
特定のタイムスタンプを取得できない場合、GPUは事前定義されたエラー値を使用します。

00:08:34.000 --> 00:08:44.000
iOSおよびApple Siliconデバイスでは、GPUタイムスタンプはmach_absolute_timeに整列されているため、CPUタイムスタンプと直接比較できます。

00:08:44.000 --> 00:08:48.000
インテルとAMDのGPUでは、追加のステップが必要です。

00:08:48.000 --> 00:08:51.000
ベンダー固有のタイムドメインから翻訳する必要があります。

00:08:51.000 --> 00:09:05.000
これは、GPUの忙しさ、消費する電力、実行中の熱さに応じて、クロック周波数が時間の経過とともに常に調整され、タイムスタンプに影響するためです。

00:09:05.000 --> 00:09:15.000
即時モードGPUでこれに対処するには、サンプルタイムスタンプのAPIを使用して、特定の時間に一致するCPUとGPUのタイムスタンプを照会します。

00:09:15.000 --> 00:09:21.000
漂流を避け、時間の経過とともに正確な相関関係を維持するために、一定の間隔でそれを行います。

00:09:21.000 --> 00:09:27.000
次に、収集されたサンプルの簡単な線形補間を行います。

00:09:27.000 --> 00:09:35.000
例として、一般的なバッファ補完ハンドラ内でサンプルタイムスタンプを呼び出すと、フレームごとに1つの相関が得られます。

00:09:35.000 --> 00:09:39.000
CPUとGPUのタイムスタンプをt0で照会したとしましょう。

00:09:39.000 --> 00:09:43.000
そして、次のフレームで、t1でそれらを照会します。

00:09:43.000 --> 00:09:50.000
サンプルバッファからのすべてのGPUカウンタをスケーリングし、CPUドメインにオフセットできるようになりました。

00:09:50.000 --> 00:09:57.000
そして、それが私たちが必要とするすべてです。それでは、それをすべて一緒に表示する方法を見てみましょう。

00:09:57.000 --> 00:09:59.000
私たちはCPUマーカーを見ています。

00:09:59.000 --> 00:10:02.000
私たちはmach_absolute_timeでそれらを捕獲しました。

00:10:02.000 --> 00:10:08.000
頂点、フラグメント、計算段階がすべて重なり、CPUアクティビティと整列しています。

00:10:08.000 --> 00:10:21.000
提示されたハンドラ内でmach_absolute_timeを収集して、すべてのマーカーを実際のガラス対ガラスフレームに整列させ、各フレーム内のすべてのイベントを正確に表示することもできます。

00:10:21.000 --> 00:10:34.000
このHUDを使用すると、CPUまたはGPUにバインドされているかどうか、依存関係と同期ポイント、頂点、フラグメント、コンピューティング作業の内訳、およびそれらが互いにどのように影響するかを把握できます。

00:10:34.000 --> 00:10:38.000
そのすべては、ライブ、あなたのアプリの中にあります。

00:10:38.000 --> 00:10:41.000
気をつけられることがいくつかあります。

00:10:41.000 --> 00:10:43.000
HUDをあまり頻繁に更新しないでください。

00:10:43.000 --> 00:10:48.000
FPSカウンタと同様に、ライブデータが常に変化している場合、読みにくい場合があります。

00:10:48.000 --> 00:10:55.000
フレームごとにタイムスタンプを収集できますが、たとえば、画面上のマーカーは1秒に1回しか更新できません。

00:10:55.000 --> 00:10:58.000
従うのがかなり簡単になります。

00:10:58.000 --> 00:11:01.000
第二に、GPUのアクティビティはクロックレートに依存します。

00:11:01.000 --> 00:11:07.000
高いGPU占有率を見ることは、必ずしもそれが最大になるという意味ではありません。

00:11:07.000 --> 00:11:13.000
システムは必要なだけの電力しか使わないので、電力とパフォーマンスのバランスが取れます。

00:11:13.000 --> 00:11:17.000
その結果、HUDでGPUが80%ビジー状態になっているのがわかるかもしれません。

00:11:17.000 --> 00:11:27.000
しかし、最大クロックレートの半分で実行されている場合、実際にはピークパフォーマンスの40%で動作し、十分なヘッドルームがあります。

00:11:27.000 --> 00:11:32.000
そして、いつものように、エラーを処理する必要がありますが、矛盾にも注意する必要があります。

00:11:32.000 --> 00:11:41.000
たとえば、カウンタがオーバーフローする可能性があるため、新しい値が前の値よりも小さくなり、負の期間が発生する可能性があります。

00:11:41.000 --> 00:11:48.000
または、サンプリングカウンター中にデバイスをスリープ状態にしたり、休止状態にしたりすると、大きな外れ値が発生する可能性があります。

00:11:48.000 --> 00:11:54.000
これらはまれなイベントであり、ディスプレイやログの不具合を避けるために、それらを優雅にスキップする必要があります。

00:11:54.000 --> 00:12:01.000
要約すると、Metal Counter APIを使用してGPUタイムスタンプを収集する手順を実行しました。

00:12:01.000 --> 00:12:08.000
これを行うには、デバイスサポートCounterSamplingメソッドを使用して、どのサンプリングモードがサポートされているかを調べました。

00:12:08.000 --> 00:12:13.000
GPUのタイムスタンプでセットを見つけるためにカウンターセットを列挙しました。

00:12:13.000 --> 00:12:20.000
記述子を使用して新しいサンプルバッファを作成し、レンダリングコマンドエンコーダで使用しました。

00:12:20.000 --> 00:12:23.000
Blitとコンピューティングエンコーダでも同じことをしたいと思うでしょう。

00:12:23.000 --> 00:12:28.000
すべてのドローの前後に特定のサンプルコマンドを追加しました。

00:12:28.000 --> 00:12:33.000
描画、ディスパッチ、ブリットの間にも追加して、過去のタイミングを取得できます。

00:12:33.000 --> 00:12:37.000
カウンタをCPUメモリに解決しました。

00:12:37.000 --> 00:12:40.000
そして最後に、必要に応じてそれらを再調整しました。

00:12:40.000 --> 00:12:48.000
そして、強力なライブGPUプロファイリングHUDがアプリの上に表示するために必要なすべてのデータがあります。

00:12:48.000 --> 00:12:52.000
そして、このAPIは、GPUのタイムスタンプ以上のものへのアクセスを提供します。

00:12:52.000 --> 00:12:58.000
ステージ情報ごとに要約できます。これは、タイムラインにイベントを描画していない場合は、より簡単に処理できます。

00:12:58.000 --> 00:13:08.000
そして重要なことに、頂点やフラグメントシェーダーの呼び出し数やコンピューティングカーネルなど、詳細な統計を取得できることです。

00:13:08.000 --> 00:13:18.000
Metal Counter APIには十分に探索でき、実行時にGPUのパフォーマンスをプロファイリングするための多くの情報にアクセスできます。

00:13:18.000 --> 00:13:19.000
このセッションはこれでおそれです。

00:13:19.000 --> 23:59:59.000
見てくれてありがとう。

