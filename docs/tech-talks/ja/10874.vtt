WEBVTT

00:00:00.000 --> 00:00:03.000
サイモン・マニング:こんにちは、私はサイモンで、CloudKitチームのエンジニアです。

00:00:03.000 --> 00:00:10.000
今日は、CloudKitを使用してアプリのユーザー間でデータ共有をサポートする方法を実演します。

00:00:10.000 --> 00:00:15.000
まず、GitHubで入手可能な共有サンプルアプリを紹介します。

00:00:15.000 --> 00:00:23.000
次に、共有の作成をサポートし、他のユーザーをアプリでそれらの共有に参加するように招待する方法を説明します。

00:00:23.000 --> 00:00:42.000
アプリが参加ユーザーに代わって招待を共有して受け入れる方法、共有レコードを取得する方法、アプリがカスタマイズされた共有体験を提供する方法、そして最後にCloudKitで利用可能なゾーンベースの共有モデルについて説明します。

00:00:42.000 --> 00:00:45.000
まず、共有サンプルアプリです。

00:00:45.000 --> 00:00:51.000
リマインダーとして、CloudKitは、アプリケーションがiCloud上のデータベースにアクセスできるようにするフレームワークです。

00:00:51.000 --> 00:00:58.000
これは、複数のCKDatabaseにアクセスできるCKContainerとしてAPIに公開されます。

00:00:58.000 --> 00:01:04.000
各コンテナには、すべてのユーザーが潜在的にレコードを読み書きできる1つのパブリックデータベースがあります。

00:01:04.000 --> 00:01:12.000
デバイスにiCloudアカウントがログインしている場合、アプリはそのユーザーのデータを含むプライベートデータベースにもアクセスできます。

00:01:12.000 --> 00:01:23.000
また、アプリが共有をサポートしている場合、現在のiCloudユーザーと共有されているデータは、共有CKDatabaseでアプリで利用可能になります。

00:01:23.000 --> 00:01:35.000
レコードを所有するユーザーから共有を開始することと、参加者として共有への招待を受け入れることを実証するために、Apple GitHubアカウントで利用可能なサンプルアプリを参照します。

00:01:35.000 --> 00:01:38.000
共有は、連絡先アプリの最小限の例です。

00:01:38.000 --> 00:01:50.000
ユーザーのプライベートデータベースで新しい連絡先レコードの作成、アプリの他のユーザーと個々の連絡先の共有、他のユーザーから現在のユーザーと共有されたすべての連絡先の表示をサポートします。

00:01:50.000 --> 00:02:01.000
共有リポジトリには、Swift並行性を使用した実装と、別々のブランチで利用可能な完了ハンドラベースの実装が含まれています。

00:02:01.000 --> 00:02:07.000
共有を開始するには、まず新しい連絡先レコードを作成し、所有者のプライベートデータベースに保存します。

00:02:07.000 --> 00:02:12.000
addContact関数は、Sharing's Add New Contact UIによって呼び出されます。

00:02:12.000 --> 00:02:19.000
連絡先のrecordTypeで新しいCKRecordを作成し、名前と電話番号を保存します。

00:02:19.000 --> 00:02:23.000
その後、レコードはプライベートデータベースに保存されます。

00:02:23.000 --> 00:02:30.000
共有アプリの他のユーザーとの連絡先レコードの共有は、共有を作成することから始まります。

00:02:30.000 --> 00:02:35.000
CloudKitでの共有は、CKShareと呼ばれる特殊な種類のレコードに依存しています。

00:02:35.000 --> 00:02:43.000
ユーザーが他の人とレコードを共有したい場合は、彼らに代わってCKShareを作成し、プライベートデータベースに保存します。

00:02:43.000 --> 00:02:50.000
このユーザーは共有されているすべてのレコードを所有しているため、共有レコード自体の所有者でもあります。

00:02:50.000 --> 00:03:00.000
この共有レコードは、どのデータが共有されているか、誰と共有されているか、参加者を共有するためにどのような許可が利用できるかについての真実の源です。

00:03:00.000 --> 00:03:05.000
共有権限は、共有の所有者が共有レコードへのアクセスを制御する方法です。

00:03:05.000 --> 00:03:12.000
publicPermissionプロパティは、共有へのリンクを持つすべてのユーザーの権限レベルを表します。

00:03:12.000 --> 00:03:17.000
デフォルトでは、URLのみを持つユーザーはアクセスできません。

00:03:17.000 --> 00:03:24.000
このプロパティをより許容値に設定すると、共有のURLを持つすべてのユーザーが参加できます。

00:03:24.000 --> 00:03:29.000
招待された各参加者には、株式の所有者によって決定された許可レベルもあります。

00:03:29.000 --> 00:03:38.000
参加者オブジェクトは、ユーザーの身元や招待の受け入れ状況など、特定のユーザーの共有への参加を記述します。

00:03:38.000 --> 00:03:49.000
権限は各参加者オブジェクトに個別に設定され、各参加者はCKShareの参加者配列に追加されます。

00:03:49.000 --> 00:03:56.000
ユーザーのプライベートデータベースからレコードの共有を開始するには、まず共有のルートレコードを決定します。

00:03:56.000 --> 00:04:00.000
ルートレコードとそのすべての子レコードは、この共有に含まれます。

00:04:00.000 --> 00:04:10.000
次に、CKShareレコードを作成し、ルートレコードとCKShareの両方を現在のユーザーのプライベートデータベースに保存します。

00:04:10.000 --> 00:04:16.000
共有では、createShare関数は共有する連絡先レコードでCKShareを初期化します。

00:04:16.000 --> 00:04:27.000
CKShareとルートレコードは所有者のプライベートデータベースに保存され、CKShareはUIに戻されて招待プロセスを開始します。

00:04:27.000 --> 00:04:32.000
CKShareとルートレコードの両方を同じ操作で一緒に保存する必要があります。

00:04:32.000 --> 00:04:38.000
ルートレコードがCloudKitにすでに存在していても、CKShareのみを保存するとエラーが発生します。

00:04:38.000 --> 00:04:43.000
ルートレコードを共有すると、子レコードも共有されます。

00:04:43.000 --> 00:04:51.000
アプリが共有を作成したので、共有に参加するためのユーザー招待状を設定して送信する方法について説明します。

00:04:51.000 --> 00:04:58.000
サンプルアプリは、UICloudSharingControllerという名前のUIKitが提供するビューコントローラーを使用します。

00:04:58.000 --> 00:05:11.000
このコントローラーをアプリに実装すると、ユーザーは参加者をCKShareに簡単に招待したり、権限を設定したり、参加を表示および管理したり、レコードの共有をすべて停止したりできます。

00:05:11.000 --> 00:05:18.000
新しい連絡先レコードを共有するときに、UICloudSharingControllerが共有サンプルアプリに表示される方法は次のとおりです。

00:05:18.000 --> 00:05:25.000
ユーザーは共有招待状の送信方法を選択でき、権限は共有オプションセクションで設定できます。

00:05:25.000 --> 00:05:35.000
コントローラのデリゲートプロトコルを実装して、共有に関する追加情報を提供し、共有イベントやエラーに関する通知を受信します。

00:05:35.000 --> 00:05:45.000
ここで説明する方法に加えて、共有招待状に表示するアイテムタイトル、アイテムタイプ、およびサムネイル画像を設定する方法があります。

00:05:45.000 --> 00:05:53.000
共有の所有者が他の人に招待状を送ったので、アプリは招待された参加者に代わって共有を処理して受け入れる必要があります。

00:05:53.000 --> 00:05:58.000
アプリのInfo.plistでCKSharingSupported booleanを有効にします。

00:05:58.000 --> 00:06:07.000
これにより、アプリは共有をサポートしていることをシステムに知らせ、招待URLを処理し、関連するデリゲート関数を呼び出す必要があります。

00:06:07.000 --> 00:06:15.000
共有招待が開かれ、受け入れられると、アプリはデリゲートメソッドのコールバックを通じてCKShare.Metadataオブジェクトを受け取ります。

00:06:15.000 --> 00:06:28.000
アプリはこのメタデータを使用して、現在のユーザーがコンテナの受け入れ機能またはCKAcceptSharesOperationを通じてこの共有を受け入れ、参加していることをCloudKitに通知します。

00:06:28.000 --> 00:06:38.000
applicationDelegateライフサイクルでは、システムはアプリを起動し、userDidAcceptCloudKitShareWith: shareMetadataデリゲートメソッドを呼び出します。

00:06:38.000 --> 00:06:44.000
shareMetadataオブジェクトで指定された識別子を使用して、CKContainerオブジェクトを初期化します。

00:06:44.000 --> 00:06:55.000
次に、CKContainerでacceptを呼び、shareMetadataオブジェクトを渡して、現在のユーザーが共有を受け入れたことをCloudKitに知らせます。

00:06:55.000 --> 00:07:08.000
アプリがプライベートレコードを共有するための招待状を送信し、それらの招待状を処理して受け入れるようになったので、アプリがユーザーが参加している共有レコードを取得して変更する方法について説明します。

00:07:08.000 --> 00:07:15.000
現在のiCloudユーザーと共有されているレコードは、アプリコンテナのsharedCloudDatabase内で利用できます。

00:07:15.000 --> 00:07:25.000
プライベートデータベースとパブリックデータベース内のデータをフェッチ、クエリ、操作するための同じCloudKit APIは、共有データベースで使用できます。

00:07:25.000 --> 00:07:30.000
サンプルアプリでは、共有レコードはfetchSharedContacts関数でフェッチされます。

00:07:30.000 --> 00:07:36.000
recordZoneChanges操作を使用して、変更を徐々に取得して処理します。

00:07:36.000 --> 00:07:46.000
この操作が完了するたびに、フェッチにさらに変更があるかどうかを表すmoreComing booleanプロパティを返します。

00:07:46.000 --> 00:07:52.000
また、ゾーンの履歴の特定の変更へのポインタであるchangeTokenを返します。

00:07:52.000 --> 00:07:57.000
このchangeTokenを使用して、その時点以降に発生した変更のみを取得できます。

00:07:57.000 --> 00:08:05.000
最初のフェッチ、またはゾーンの履歴のすべての変更を再フェッチするには、changeTokenをnilに設定します。

00:08:05.000 --> 00:08:08.000
アクティブな共有の管理は、現在のユーザーによって異なります。

00:08:08.000 --> 00:08:16.000
共有の所有者の場合、所有者のプライベートデータベースからCKShareレコードを削除することで、共有を停止できます。

00:08:16.000 --> 00:08:20.000
所有者は、共有ルートレコードを完全に削除することもできます。

00:08:20.000 --> 00:08:29.000
CKShareレコードオブジェクトのremoveParticipant関数は、参加者プロパティにある個々の参加者を削除する方法を提供します。

00:08:29.000 --> 00:08:38.000
そして最後に、UICloudSharingController UIは、所有者がすべての参加者との共有を停止することを可能にします。

00:08:38.000 --> 00:08:48.000
共有の参加者ユーザーの場合、ユーザーの共有データベースからルートCKRecordを削除するか、UICloudSharingController UIを使用して参加を停止できます。

00:08:48.000 --> 00:09:01.000
ユーザーの共有データベースからルートCKRecordを削除すると、共有への参加が停止されるだけであることに注意してください。元のルートレコードは、所有者のプライベートデータベースに引き続き存在します。

00:09:01.000 --> 00:09:16.000
共有サンプルアプリはUICloudSharingControllerを使用して参加者の検索と招待を処理しますが、CloudKit APIでこの機能を実装し、共有の所有者と参加者の両方にカスタムユーザーエクスペリエンスを構築することもできます。

00:09:16.000 --> 00:09:27.000
まず、CKShareに招待する参加者を検索するには、関連するCKContainerでCKFetchShare ParticipantsOperationまたはshareParticipants関数を使用します。

00:09:27.000 --> 00:09:33.000
電話番号、電子メール、およびユーザーレコードIDは、パラメータとしてサポートされています。

00:09:33.000 --> 00:09:42.000
次に、この参加の特定の権限レベルを設定し、addParticipant関数を使用して参加者をCKShareに追加します。

00:09:42.000 --> 00:09:47.000
変更されたCKShareを常にプライベートデータベースに保存してください。

00:09:47.000 --> 00:09:55.000
保存されたCKShareレコードには、招待された参加者に送信して受け入れて処理できるURLプロパティがあります。

00:09:55.000 --> 00:10:06.000
招待URLを使用して、共有のCKShare.Metadataを取得し、アプリのコンテナのaccept(shareMetadata)機能を使用して参加を確認できます。

00:10:06.000 --> 00:10:16.000
共有アプリは、単一のレコードがルートレコードとして共有され、そのレコードの子も共有される階層的な共有モデルでCloudKit共有を実証します。

00:10:16.000 --> 00:10:24.000
iOS 15で導入された新しいモデルであるゾーン共有では、代わりにレコードのゾーン全体を共有できます。

00:10:24.000 --> 00:10:30.000
ゾーンを共有する場合、単一のレコードの階層だけでなく、ゾーン内のすべてのレコードが共有されます。

00:10:30.000 --> 00:10:40.000
ゾーン共有はレコードゾーン内のすべてのレコードに影響を与えるため、このタイプの共有は同じレコードゾーンの階層共有と共存することはできません。

00:10:40.000 --> 00:10:47.000
ゾーンに1つ以上の階層的な共有、または単一のゾーン全体の共有を持つことができます。

00:10:47.000 --> 00:10:54.000
ゾーン共有と階層共有にはそれぞれ利点があり、どちらもユースケースに応じて利用する必要があります。

00:10:54.000 --> 00:11:02.000
共有サンプルアプリのコンテキストでは、ゾーン共有は、連絡先のグループが別々のレコードゾーンに整理されている場合に役立ちます。

00:11:02.000 --> 00:11:07.000
ゾーン共有は、これらの連絡先グループを他のユーザーと共有するために使用できます。

00:11:07.000 --> 00:11:14.000
ゾーン共有の詳細については、WWDC21の「CloudKitの新機能」をご覧ください。

00:11:14.000 --> 00:11:23.000
新しいゾーン全体の共有を作成するには、共有するカスタムレコードゾーンのIDで初期化し、プライベートデータベースに保存します。

00:11:23.000 --> 00:11:29.000
共有招待を受け入れ、共有データベースからレコードを取得するプロセスは、以前と同じです。

00:11:29.000 --> 00:11:36.000
シェアがゾーン全体のシェアであるかどうかを判断するには、そのrecordIDのrecordNameプロパティを確認してください。

00:11:36.000 --> 00:11:46.000
値がCKRecordNameZoneWideShareの場合、共有は共有レコードゾーンを管理しています。それ以外の場合は、共有レコード階層を管理しています。

00:11:46.000 --> 00:11:55.000
アプリでの共有をサポートする方法がわかったので、CKShareレコードの作成を開始し、ユーザーが他のユーザーと協力できるようにします。

00:11:55.000 --> 00:12:02.000
UICloudSharingControllerを使用して共有UIをジャンプスタートするか、ニーズに合わせてカスタム実装を構築します。

00:12:02.000 --> 00:12:08.000
使い慣れたフェッチと変更APIを使用して、共有クラウドデータベースから共有レコードにアクセスします。

00:12:08.000 --> 00:12:15.000
そして、ゾーン共有の実装から恩恵を受けることができる、アプリで新しい共有ユースケースの探索を始めましょう。

00:12:15.000 --> 23:59:59.000
見てくれてありがとう!

