WEBVTT

00:00:00.000 --> 00:00:10.000
Metal 2は、A11 GPUのアーキテクチャと新機能を活用するために、APIとシェーディング言語の変更の新しいセットを導入します。

00:00:10.000 --> 00:00:14.000
A11のMetal 2の新機能を確認しましょう。

00:00:14.000 --> 00:00:18.000
Appleは、GPUアーキテクチャの急速な革新を可能にするためにMetalを設計しました。

00:00:18.000 --> 00:00:24.000
そして、AppleのGPUアーキテクチャはMetalの設計を知らせました。

00:00:24.000 --> 00:00:35.000
ハードウェアとソフトウェアのこの深くシームレスな統合は、グラフィックス、コンピューティング、機械学習アプリ、ゲームのエキサイティングな新しい可能性を可能にします。

00:00:35.000 --> 00:00:45.000
メタルの導入からわずか3年後、WWDC 2017で次世代のメタルであるメタル2を導入しました。

00:00:45.000 --> 00:01:06.000
クリーンで十分なファクタリングされた設計に基づいて、Metal 2は、GPUがグラフィックスワークロードを自分自身にディスパッチし、効率をさらに向上させ、ドローコールコストを最大10倍に削減できるGPU駆動型レンダリングなど、GPUの機能にアクセスするためのさらに最先端の方法を含むように拡張します。

00:01:06.000 --> 00:01:11.000
2015年、MetalはMacとデスクトップGPUをサポートするように拡張した。

00:01:11.000 --> 00:01:19.000
現在、Metal 2は、基礎となるGPUアーキテクチャに関係なく、主要な機能を均一に公開するためにAPIを調整しています。

00:01:19.000 --> 00:01:34.000
さまざまなドメインにわたる機械学習の台頭により、Metal 2は、パフォーマンスと効率を向上させるための推論操作を加速することを目的とした、より広く、より洗練された機能セットをもたらします。

00:01:34.000 --> 00:01:43.000
Metal 2はまた、AppleプラットフォームでGPUのパワーを巧みに活用する方がはるかに簡単になる新しい最適化ツールセットも提供します。

00:01:43.000 --> 00:01:50.000
そして今、私たちはWWDCで発表しなかったより多くのメタル2の機能を明らかにすることができます。

00:01:50.000 --> 00:02:02.000
Metal 2には、最新のAシリーズチップであるA11でAppleが設計したGPUのユニークな機能を公開する一連の強力な新機能が含まれています。

00:02:02.000 --> 00:02:13.000
A11 GPUアーキテクチャと機能の詳細に入る前に、古典的なGPUとタイルベースの遅延レンダリングアーキテクチャのアーキテクチャを確認しましょう。

00:02:13.000 --> 00:02:17.000
これは、古典的なGPUアーキテクチャの簡略化された図です。

00:02:17.000 --> 00:02:20.000
GPUは大規模に並列マシンです。

00:02:20.000 --> 00:02:27.000
この図に示されている頂点とフラグメントの段階は何度も複製され、並行して実行されます。

00:02:27.000 --> 00:02:37.000
また、キャッシュ階層、FIFO、初期の粗い深度テストなど、この図には示されていない多くの最適化もあります。

00:02:37.000 --> 00:02:46.000
基本的に、古典的なアーキテクチャを持つGPUはプリミティブを取り、深さ、色、データバッファ、テクスチャを生成します。

00:02:46.000 --> 00:02:55.000
このアーキテクチャの決定的な特徴の1つは、頂点ステージの出力がフラグメントステージに直接供給されることです。

00:02:55.000 --> 00:03:01.000
TBDRとも呼ばれるタイルベースの遅延レンダリングアーキテクチャを見てみましょう。 タイルベースの遅延レンダリングアーキテクチャを見てみましょう。

00:03:01.000 --> 00:03:06.000
すべてのAシリーズGPUはTBDRアーキテクチャに基づいています。

00:03:06.000 --> 00:03:11.000
TBDRは、古典的なGPUアーキテクチャにいくつかの重要な変更を加えます。

00:03:11.000 --> 00:03:17.000
最初の大きな違いは、頂点ステージがフラグメントステージに直接供給されないことです。

00:03:17.000 --> 00:03:26.000
代わりに、頂点段階から出てくると、プリミティブは画面に整列した小さなタイルにビンに入れられ、メモリに保存されます。

00:03:26.000 --> 00:03:31.000
この変更により、頂点ステージはフラグメントステージに対して非同期に実行できます。

00:03:31.000 --> 00:03:39.000
レンダーパスのフラグメントステージを実行している間、並行して、ハードウェアは将来のレンダーパスの頂点ステージを実行します。

00:03:39.000 --> 00:03:44.000
頂点ステージを非同期に実行すると、パフォーマンスが大幅に向上します。

00:03:44.000 --> 00:03:52.000
頂点ステージは通常、固定機能ハードウェアを多用していますが、フラグメントステージは数学と帯域幅のヘビーユーザーです。

00:03:52.000 --> 00:03:58.000
それらが完全に重なっているため、GPU上のすべてのハードウェアブロックを同時に使用できます。

00:03:58.000 --> 00:04:03.000
プリミティブをタイルにビンニングすることで、タイル内のすべてのプリミティブをすべて一緒に処理できます。

00:04:03.000 --> 00:04:06.000
それをどのように活用できるか見てみましょう。

00:04:06.000 --> 00:04:14.000
シェーダーコアの横にあるチップにタイルサイズのフル解像度、深さ、ステンシル、フレームバッファーを置きます。

00:04:14.000 --> 00:04:17.000
私たちはこのメモリをタイルメモリと呼んでいます。

00:04:17.000 --> 00:04:20.000
タイルメモリには3つの重要な特徴があります。

00:04:20.000 --> 00:04:33.000
まず、シェーダーコアとタイルメモリ間の帯域幅は、GPUと外部メモリ間の帯域幅よりも何倍も高く、シェーダーコアの数に比例してスケールします。

00:04:33.000 --> 00:04:40.000
第二に、タイルメモリへのメモリアクセスレイテンシは、外部メモリへのアクセスのレイテンシよりも何倍も低い。

00:04:40.000 --> 00:04:46.000
最後に、タイルメモリは外部メモリよりも大幅に低い電力を消費します。

00:04:46.000 --> 00:04:54.000
TBDRは、この低遅延、低消費電力、高帯域幅のメモリを使用して、2つの主要な最適化を提供します。

00:04:54.000 --> 00:05:12.000
まず、タイル深度/ステンシルメモリにより、ハードウェアはシェーディングコアが処理を開始する前に、不透明なオブジェクトの完全な深さとステンシルバッファ情報を生成できます。これにより、ハードウェアはシェーダーコアに送信する前に隠蔽されたフラグメントを完全に淘汰することができます。

00:05:12.000 --> 00:05:26.000
後続のレンダーパスにデプスバッファが必要ない場合は、メモリレスレンダーターゲットを使用してフルサイズのデプスバッファを完全に排除し、大量のメモリ帯域幅、ストレージ、および電力を節約できます。

00:05:26.000 --> 00:05:30.000
第二に、タイルメモリは、チップにカラーバッファを格納するために使用されます。

00:05:30.000 --> 00:05:37.000
ブレンド操作は、外部メモリ上のフルサイズのフレームバッファにアクセスする必要がないため、高速です。

00:05:37.000 --> 00:05:45.000
タイルメモリは、タイル全体が処理された後、一度だけ書き込まれ、電力、パフォーマンス、帯域幅を大幅に節約します。

00:05:45.000 --> 00:05:49.000
このより高速なメモリのおかげで、より高い占有率が達成されます。

00:05:49.000 --> 00:05:55.000
フレームバッファフェッチ機能を使用すると、カスタムブレンディングを実装し、いくつかの高度なテクニックを有効にします。

00:05:55.000 --> 00:06:02.000
メモリレスフレームバッファと組み合わせることで、これらの技術の多くは外部メモリを消費する必要もありません。

00:06:02.000 --> 00:06:08.000
その結果、TBDRは帯域幅が限られている場合でも優れたパフォーマンスをもたらします。

00:06:08.000 --> 00:06:14.000
TBDRははるかに低い電力を消費しますが、これはバッテリー駆動のデバイスに不可欠です。

00:06:14.000 --> 00:06:17.000
それでは、ギアをA11 GPUに切り替えましょう。

00:06:17.000 --> 00:06:29.000
A11では、GPUアーキテクチャの最初の大きな変更は、フラグメント関数からタイルメモリに存在するデータを直接制御できるようにすることです。

00:06:29.000 --> 00:06:33.000
イメージブロックは、タイルメモリに存在する画像データへの最適化されたアクセスを提供します。

00:06:33.000 --> 00:06:41.000
アプリケーションにとって意味のある方法でピクセルをレイアウトすることができますが、それでも効率的にレンダリングすることができます。

00:06:41.000 --> 00:06:45.000
イメージブロックは、タイルメモリ内の2Dデータ構造です。

00:06:45.000 --> 00:06:49.000
幅、高さ、奥行き、フォーマットを指定できます。

00:06:49.000 --> 00:06:58.000
Metal 2は、シェーディング言語にテクスチャピクセルフォーマットを追加し、パックされたデータタイプを介してピクセルレイアウトを完全に制御できるようにします。

00:06:58.000 --> 00:07:06.000
2番目の大きなアーキテクチャの変更により、タイルメモリに同時に保存されているすべてのピクセルにアクセスできます。

00:07:06.000 --> 00:07:15.000
タイルシェーディングは、レンダリングパス内でインラインでコンピューティング機能を提供するAppleのA11 GPUの新しいプログラム可能なステージです。

00:07:15.000 --> 00:07:21.000
タイルシェーディングは、Metal 2のまったく新しいレベルのパフォーマンスと効率を可能にします。

00:07:21.000 --> 00:07:28.000
レンダリングとコンピューティング操作は、より高い帯域幅、より低いレイテンシー、低消費電力のタイルメモリを介してデータを共有できるようになりました。

00:07:28.000 --> 00:07:31.000
タイルシェーディングはイメージブロックと深く統合されています。

00:07:31.000 --> 00:07:41.000
イメージブロックの内容を分析したり、そのコンテンツを要約したり、シーンの途中でイメージブロックを保存したり、イメージブロックのレイアウトを変更したりすることもできます。

00:07:41.000 --> 00:07:45.000
通常のコンピューティングカーネルと同じように、スレッドグループメモリを使用することもできます。

00:07:45.000 --> 00:07:49.000
タイルシェーダーの場合、スレッドグループメモリは永続的です。

00:07:49.000 --> 00:07:57.000
タイルシェーダーの各連続した呼び出しは、前のタイルシェーダーから残された値から始めて、スレッドグループメモリを操作できます。

00:07:57.000 --> 00:08:00.000
これはイメージブロックメモリにも当てはまります。

00:08:00.000 --> 00:08:04.000
それらはタイルとフラグメントシェーダーの呼び出しの間に永続的です。

00:08:04.000 --> 00:08:11.000
さらに、イメージブロックとタイルシェーディングをサポートするラスターオーダーグループの高度なバージョンを導入しています。

00:08:11.000 --> 00:08:19.000
そして最後に、マルチサンプル画像ブロックのサンプルカバレッジを完全に制御するために、メタルシェーディング言語を拡張しています。

00:08:19.000 --> 00:08:27.000
新しいアーキテクチャと新しいMetal 2の機能を最大限に活用できる一連のレンダリング技術を見てみましょう。

00:08:27.000 --> 00:08:36.000
タイルシェーダー、イメージブロック、ラスターオーダーグループは、インターリーブ、レンダリング、計算パスを1つの結合パスにまとめるのに最適な方法です。

00:08:36.000 --> 00:08:40.000
遅延レンダリングとタイル張りのフォワードレンダリングは、この方法で加速できます。

00:08:40.000 --> 00:08:44.000
例として、タイル張りの前方実装を見てみましょう。

00:08:44.000 --> 00:09:02.000
ジオメトリを渡して最初にオンチップ深度情報を作成し、次にタイルシェーダーを実行してタイルごとの最小最大深度情報を作成し、別のタイルシェーダーを実行してスレッドグループメモリに淘汰されたライトリストを作成し、マテリアルシェーダーを実行できます。

00:09:02.000 --> 00:09:11.000
これらの操作はすべて1つの複合パスで実行でき、大量の帯域幅、ストレージ、電力を排除することでパフォーマンスが向上します。

00:09:11.000 --> 00:09:20.000
これらの機能により、注文に依存しない透明性、多層アルファブレンド、および表面下散乱の効率的な実装も可能になります。

00:09:20.000 --> 00:09:31.000
サンプルカバレッジコントロール、タイルシェーダー、およびイメージブロックは、カスタムMSAA解決、MSAAトーンマッピング、およびサーフェスアグリゲーションを行うはるかに効率的な方法を可能にします。

00:09:31.000 --> 00:09:44.000
これらのユースケースの一部をどのように加速できるかを示すために、遅延レンダリング、タイルフォワード、多層アルファブレンド、および表面集約のサンプルコードをリリースしています。

00:09:44.000 --> 00:09:56.000
A11のMetal 2は、イメージブロック、タイルシェーダー、イメージブロックサンプルカバレッジコントロール、およびラスターオーダーグループを導入することにより、TBDRアーキテクチャを進歩させます。

00:09:56.000 --> 00:10:06.000
さらに、コンピューティングスレッドとスレッドグループ間でデータを共有するための新しく効率的なメカニズムを提供するために、新しいメタルシェーディング言語の変更を導入しました。

00:10:06.000 --> 00:10:13.000
A11のこれらおよびその他の追加機能とパフォーマンスの向上を簡単に見てみましょう。

00:10:13.000 --> 00:10:15.000
イメージブロックから始めましょう。

00:10:15.000 --> 00:10:19.000
イメージブロックは、タイルメモリ内の2Dデータ構造です。

00:10:19.000 --> 00:10:27.000
フラグメント関数は、その位置に対応する単一のピクセルにしかアクセスできませんが、カーネルはイメージブロック全体にアクセスできます。

00:10:27.000 --> 00:10:36.000
各ピクセルは非常に複雑で、複数のコンポーネントで構成され、各コンポーネントは独自の画像面として対処できます。

00:10:36.000 --> 00:10:40.000
イメージブロックは、GPUのフォーマット変換ハードウェアへの一括アクセスも提供します。

00:10:40.000 --> 00:10:48.000
浮動小数点ピクセルは、デバイスメモリに保存すると、宛先テクスチャ形式に変換されます。

00:10:48.000 --> 00:10:53.000
タイルシェーダーは、レンダリングパス内でインラインで計算機能を提供します。

00:10:53.000 --> 00:11:00.000
タイルシェーダーはイメージブロック全体にアクセスでき、通常のコンピューティングカーネルと同様に、スレッドグループメモリをサポートしています。

00:11:00.000 --> 00:11:11.000
コンピューティングカーネルのスレッドグループメモリとは異なり、タイルシェーダーのスレッドグループメモリは、カラーデータが描画全体で持続するように、タイルの寿命にわたって持続します。

00:11:11.000 --> 00:11:24.000
そのため、以前はフレームバッファフェッチ機能を使用してピクセルの範囲内でドロー間で通信することに限定されていましたが、より広いタイルスコープを使用してタイルディスパッチとフラグメントドロー呼び出しの間で通信できるようになりました。

00:11:24.000 --> 00:11:29.000
それでは、A11が前の世代よりもMSAAをどのように改善するかを見てみましょう。

00:11:29.000 --> 00:11:34.000
AppleのAシリーズGPUは、非常に効率的なMSAA実装を備えています。

00:11:34.000 --> 00:11:41.000
フラグメントがエッジフラグメントでない場合、ハードウェアブレンディングはサンプルごとに1回ではなく、フラグメントごとに1回実行されます。

00:11:41.000 --> 00:11:49.000
さらに、タイルメモリから解決アタッチメントに直接解決し、追加のメモリ帯域幅の発生を避けることができます。

00:11:49.000 --> 00:11:57.000
Metalのメモリレスレンダリングターゲット機能を使用することで、MSAAレンダリングターゲットメモリストレージを完全に排除することもできます。

00:11:57.000 --> 00:12:01.000
A11のMetal 2で、私たちはMSAAをさらに進めました。

00:12:01.000 --> 00:12:14.000
現在のAシリーズGPUはすでにピクセル内のエッジを追跡していますが、A11 GPUは、各ピクセル内の一意のサンプル数を追跡することで、この追跡をさらに細かい粒度に拡張します。

00:12:14.000 --> 00:12:21.000
このハードウェアの変更により、アプリケーションを変更することなく、マルチサンプルアプリケーションが高速になります。

00:12:21.000 --> 00:12:29.000
A11では、Metal 2は、イメージブロックサンプルカバレッジコントロールを使用して、このトラッキングメタデータを完全に制御することもできます。

00:12:29.000 --> 00:12:34.000
この機能は、スレッドグループイメージブロックやタイルシェーダーと組み合わせて活用することもできます。

00:12:34.000 --> 00:12:49.000
イメージブロックサンプルカバレッジコントロールを使用すると、タイルパイプラインはGPUのサンプルカバレッジ追跡データを変更できるため、独自のカスタム解決アルゴリズムを使用して、レンダリングパスでいつでもサンプルデータを解決できます。

00:12:49.000 --> 00:12:57.000
ラスター順序グループを使用すると、送信順序で重複するフラグメント関数からメモリにアクセスし、フラグメント関数が通信できるようにします。

00:12:57.000 --> 00:13:01.000
A11は、ラスターオーダーグループの機能を拡張します。

00:13:01.000 --> 00:13:05.000
まず、A11はGPUの内部タイルメモリを公開します。

00:13:05.000 --> 00:13:12.000
ラスターオーダーグループは、予測可能な順序でタイルメモリにアクセスできるようにすることで、タイルメモリをより便利にします。

00:13:12.000 --> 00:13:27.000
第二に、他のGPUのラスターオーダーグループがピクセルあたり1つのミューテックスに制限されている場合、A11はそれよりもきめ細かくすることができ、さらに軽いタッチを可能にし、スレッドがアクセスを待っている頻度を最小限に抑えます。

00:13:27.000 --> 00:13:32.000
それでは、Metal 2がスレッドとスレッドグループ間のデータ共有をどのように加速するかを見てみましょう。

00:13:32.000 --> 00:13:38.000
Metal 2シェーディング言語は、メモリ順序とスコープ属性でアトミック機能を拡張します。

00:13:38.000 --> 00:13:44.000
これらの新しい追加により、スレッド間で柔軟かつ効率的にデータを共有する新しい方法が可能になります。

00:13:44.000 --> 00:13:55.000
Metal 2の前に、スレッドグループ間で通信するには、カーネルの実行を完了し、最初のカーネルのスレッドグループの出力を消費するために新しいカーネルを発行する必要がありました。

00:13:55.000 --> 00:13:59.000
メタル2では、スレッドグループは互いに直接通信できます。

00:13:59.000 --> 00:14:10.000
さらに、これらの新機能の追加により、スレッドグループ内のスレッドはバリアを使用せずに通信でき、パフォーマンスが向上します。

00:14:10.000 --> 00:14:16.000
また、A11のMetal 2に他の重要な機能と機能を追加しました。

00:14:16.000 --> 00:14:24.000
A11では、f16数学は、丸めの改善と最大値処理を通じて、全体的に精度が向上しています。

00:14:24.000 --> 00:14:31.000
A11は、テクスチャキューブ配列のサポートを追加し、読み取り/書き込みテクスチャ機能を導入しています。

00:14:31.000 --> 00:14:36.000
A11では、AシリーズのGPUに一連のサンプラーカバレッジが提供されます。

00:14:36.000 --> 00:14:44.000
A11は、ポストデプスカバレッジ機能を追加し、コンピューティングカーネルをディスパッチするより柔軟な方法を提供します。

00:14:44.000 --> 00:14:48.000
A11は、クアッドスコープのパーミュート操作のサポートも追加します。

00:14:48.000 --> 00:14:54.000
これらの機能の詳細については、Metal 2のドキュメントを確認してください。

00:14:54.000 --> 00:14:58.000
A11は、GPUに多くの大幅なパフォーマンス改善をもたらします。

00:14:58.000 --> 00:15:06.000
コンピュータビジョン、画像処理、機械学習のタスクに関しては、最大2倍の数学パフォーマンスを備えています。

00:15:06.000 --> 00:15:10.000
しかし、パフォーマンスの改善分野はそれだけではありません。

00:15:10.000 --> 00:15:14.000
A11 GPUのパフォーマンスと機能の向上を見直しましょう。

00:15:14.000 --> 00:15:22.000
A10 GPUと比較して、クロックサイクルあたりのF16数学とテクスチャフィルタリングレートを2倍にしました。

00:15:22.000 --> 00:15:31.000
ご注意：A11では、可能であればシェーダーでF16データ型を使用すると、パフォーマンスの違いがはるかに大きくなります。

00:15:31.000 --> 00:15:36.000
A11で最大スレッドグループサイズを512から1Kに2倍にしました。

00:15:36.000 --> 00:15:42.000
最大複数レンダリングターゲットサイズが256ビットから512ビットに増加しました。

00:15:42.000 --> 00:15:47.000
最大スレッドグループのメモリサイズが16Kから32Kに倍増しました。

00:15:47.000 --> 00:15:51.000
また、フィードバック業務のパフォーマンスを大幅に改善しました。

00:15:51.000 --> 00:15:55.000
それらはアルファテストと破棄とも呼ばれます。

00:15:55.000 --> 00:16:05.000
Metal 2の詳細とサンプルコードへのリンクについては、開発者のウェブサイトdeveloper.apple.com/metalをご覧ください。

00:16:05.000 --> 23:59:59.000
見てくれてありがとう!

