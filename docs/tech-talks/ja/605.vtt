WEBVTT

00:00:01.000 --> 00:00:08.000
ラスターオーダーグループはMetal 2の新機能であり、新しいA11 GPU専用にさらに拡張されています。

00:00:08.000 --> 00:00:12.000
このビデオは、A11の新しいGPU機能を説明する5つのうちの1つです。

00:00:12.000 --> 00:00:18.000
それを最大限に活用するには、以前にImageblocksとTile Shadersでビデオを見たことがあるでしょう。

00:00:18.000 --> 00:00:25.000
新しいA11の新機能に移行する前に、メタル2ですでに利用可能なラスターオーダーグループの簡単なレビューから始めます。

00:00:25.000 --> 00:00:33.000
ラスターオーダーグループは、GPUが重複する他のスレッドと順番にフラグメントシェーダースレッドの一部を実行する必要がある機能です。

00:00:33.000 --> 00:00:41.000
この順序は、renderpass内のドローコールの送信順序と、そのドローコール内の各三角形の順序に由来します。

00:00:41.000 --> 00:00:44.000
オーバーラップはラスタライザーによって決定されます。

00:00:44.000 --> 00:00:53.000
2つのフラグメントスレッドは、同じフレームバッファXとYの場所、同じサンプル、同じレイヤーをターゲットにすると、重なると判断されます。

00:00:53.000 --> 00:01:01.000
たとえば、同じ深度バッファサンプルに対して両方の深度テストを行う場合、2つのフラグメントが重なると見なされます。

00:01:01.000 --> 00:01:08.000
これは2つの三角形の典型的なケースで、最初に青い三角形、次に緑の三角形があります。

00:01:08.000 --> 00:01:14.000
古典的なグラフィックフレームバッファにアクセスするために、ブレンドは常にGPUが順番に実行するものです。

00:01:14.000 --> 00:01:20.000
GPUは、フレームからフレームへのスケジュールの変動のため、緑色の三角形を突然後ろにブレンドすることはありません。

00:01:20.000 --> 00:01:24.000
しかし、フラグメントシェーダーは同時に実行され、順不同になります。

00:01:24.000 --> 00:01:32.000
ラスターオーダーグループがなければ、作業はフラグメントシェーディングが完了した後、ブレンドする前にのみシリアル化されます。

00:01:32.000 --> 00:01:34.000
しかし、フレームバッファに溶け込んでいない場合はどうなりますか?

00:01:34.000 --> 00:01:40.000
グラフィックアルゴリズムの最近の開発の多くは、フラグメントシェーダーからより興味深いデータ構造を構築しようとしています。

00:01:40.000 --> 00:01:45.000
より良い後処理や注文に依存しない透明性のための多層エンコーディングがあります。

00:01:45.000 --> 00:01:49.000
ボクセル化と特別な目的のブレンド機能があります。

00:01:49.000 --> 00:01:57.000
これらはすべて、単に色を出力テクスチャにブレンドするのではなく、メモリ内のカスタムデータ構造にデータを保存するフラグメントシェーダー上に構築されています。

00:01:57.000 --> 00:02:05.000
しかし、フラグメントシェーダーの本体からのメモリへの直接アクセスが、任意の順序で、いつでも、同時に発生する可能性がある場合、それは厳しく制限されます。

00:02:05.000 --> 00:02:13.000
これらのデータレースに対処することで、これらのアルゴリズムの既存の実装は、そうでない場合よりもはるかに高価になりました。

00:02:13.000 --> 00:02:19.000
私たちが本当に望んでいることは、そのブレンドのような順序付けられた動作を得ることですが、フラグメントシェーダーの終了後ではなく、その内部です。

00:02:19.000 --> 00:02:24.000
私たちは、メモリアクセスが順番に連続して起こっているという錯覚を効果的に望んでいます。

00:02:24.000 --> 00:02:27.000
それがラスターオーダーグループがやっていることです。

00:02:27.000 --> 00:02:31.000
ラスターオーダーグループを使用して、メモリへのポインタに注釈を付けることができます。

00:02:31.000 --> 00:02:35.000
これらのポインタを介したアクセスは、ピクセルごとの提出順序で行われます。

00:02:35.000 --> 00:02:44.000
ハードウェアは、現在のスレッドが続行される前に、現在のスレッドと重なる古いフラグメントシェーダースレッドが終了するのを待ちます。

00:02:44.000 --> 00:02:47.000
これは効果的に相互排除を与えますが、より良いです。

00:02:47.000 --> 00:02:56.000
これは、どのスレッドが最初に重要なセクションに入り、どのスレッドが2番目に入力するかを知る、順序付けられた相互除外を提供します。

00:02:56.000 --> 00:03:07.000
この機能は、Metal 2の紹介セッションでWWDC 2017でより詳細に提示されたので、より深く掘り下げたい場合は、そのビデオを見ることができます。

00:03:07.000 --> 00:03:12.000
では、基本をカバーして、A11 GPUの新機能に移りましょう。

00:03:12.000 --> 00:03:17.000
ラスターオーダーグループは、A11でより便利で、より強力で、より高いパフォーマンスを発揮します。

00:03:17.000 --> 00:03:22.000
まず、A11はGPUの内部タイルメモリを公開します。

00:03:22.000 --> 00:03:33.000
デバイスやテクスチャアクセスと同様に、タイルメモリは予測可能な順序でアクセスできる方がはるかに便利なので、ラスター注文グループもタイルメモリに適用できるようになりました。

00:03:33.000 --> 00:03:46.000
第二に、他のGPUのラスター注文グループがピクセルあたり1つのミューテックスに制限されている場合、A11はそれよりもきめ細かくなり、さらに軽いタッチを可能にし、スレッドがアクセスを待っている頻度を最小限に抑えることができます。

00:03:46.000 --> 00:03:55.000
これらの機能を使用して、いくつかの一般的なグラフィックスアルゴリズムで新しいパフォーマンスのロックを解除する方法を示す一対の例を紹介したいと思います。

00:03:55.000 --> 00:03:58.000
最初の例は、古典的な遅延シェーディングです。

00:03:58.000 --> 00:04:03.000
従来のGPUでは、遅延シェーディングは2回のパスで行われます。

00:04:03.000 --> 00:04:14.000
最初にGバッファを充填して複数のテクスチャを出力し、次にそれらのテクスチャから読み取り、光量をレンダリングし、シェーディング結果を計算する2番目のレンダーパス。

00:04:14.000 --> 00:04:17.000
しかし、遅延シェーディングは多くのメモリ帯域幅を燃やす傾向があります。

00:04:17.000 --> 00:04:33.000
AシリーズGPUの優れた能力の1つは、チップ上でできるだけ多くの帯域幅を維持し、両方のパスを1つに合体させることでこれらの中間テクスチャを排除し、GPU内のイメージブロックで完全にタイルサイズのチャンクにG-Bufferを維持することです。

00:04:33.000 --> 00:04:37.000
これらのタスクは両方とも、1つのレンダーパスのフェーズになります。

00:04:37.000 --> 00:04:49.000
A11 ImageblockとTile Shadingのビデオで、これらの合体したRenderRassesを構築する方法のより深い説明を見ることができますが、このビデオは同期の側面だけに焦点を当てます。

00:04:49.000 --> 00:04:54.000
複数のラスター注文グループを活用することで、シングルパス遅延シェーディングのパフォーマンスがさらに向上します。

00:04:54.000 --> 00:04:59.000
それを見るために、フェーズ2の詳細のいくつかを掘り下げてみましょう:照明。

00:04:59.000 --> 00:05:06.000
私たちの基本的な照明プロセスは、光の影響を包含するボリュームを描き、フラグメントシェーダースレッドを産卵することから始まります。

00:05:06.000 --> 00:05:10.000
各スレッドは、1つのピクセルに1つの光を効果的に適用しています。

00:05:10.000 --> 00:05:13.000
私たちの照明スレッドは、Gバッファフィールドを読むことから始まります。

00:05:13.000 --> 00:05:19.000
AシリーズのGPUでは、利用可能な最速のメモリであるイメージブロックから直接これを読みたいと思うでしょう。

00:05:19.000 --> 00:05:25.000
次に、選択したシェーディングモデルを実行します。これは通常、かなりの数学であり、実行に時間がかかる場合があります。

00:05:25.000 --> 00:05:29.000
最後に、この光の寄与を画像ブロックに合計します。

00:05:29.000 --> 00:05:31.000
非常に迅速なステップ。

00:05:31.000 --> 00:05:35.000
次に、2番目のスレッドで2番目のライトが適用されます。

00:05:35.000 --> 00:05:41.000
A11より前のシングルパス遅延シェーディングの実装では、次のようになります。

00:05:41.000 --> 00:05:48.000
画像ブロックからの最初の読み取り時に注文が課され、これら2つのライトの実行全体が連続して実行されることがわかります。

00:05:48.000 --> 00:05:59.000
これは、単一のラスター注文グループのみをサポートするGPUは、後のスレッドからのアクセスを開始する前に、以前のスレッドからのすべてのアクセスが完了するのを待たなければならないためです。

00:05:59.000 --> 00:06:05.000
これは、両方のアクセスが実際に競合しない読み取りであっても適用されます。

00:06:05.000 --> 00:06:10.000
複数のラスター注文グループに対するA11のサポートは、この過剰同期を排除します。

00:06:10.000 --> 00:06:20.000
複数のグループでは、これらの競合しない読み取りを同時に実行し、結果を蓄積するシェーダーの非常に短い端でのみ同期することができます。

00:06:20.000 --> 00:06:29.000
3つのGバッファフィールドが1つのグループにあり、蓄積された照明結果が2番目のグループにあると宣言することで、これを達成できます。

00:06:29.000 --> 00:06:31.000
ハードウェアはそれらを別々に注文できるようになりました。

00:06:31.000 --> 00:06:37.000
あるグループへの未処理の書き込みは、別のグループでの読み取りを待つ必要はありません。

00:06:37.000 --> 00:06:41.000
1つのグループ内の複数の読者は、お互いを待つ必要はありません。

00:06:41.000 --> 00:06:52.000
これは、より多くのスレッドがいつでも実行できることを意味し、G-Buffersを最初にオンチップに保つことで得られるものを超えて、より多くの並列性とパフォーマンスの向上を可能にします。

00:06:52.000 --> 00:06:55.000
コードも同じようにシンプルです。

00:06:55.000 --> 00:07:02.000
私の3つのGバッファフィールドは同時に読み込まれ、一緒に書きされるので、それらをすべて注釈してグループゼロにします。

00:07:02.000 --> 00:07:07.000
アキュムレータは別の時間に読み書きされるので、グループ1に注釈を付けます。

00:07:07.000 --> 00:07:10.000
養子縁組に関しては、それは本当にそれについてです。

00:07:10.000 --> 00:07:15.000
ラスターオーダーグループは、使い始めるのが非常に簡単な機能です。

00:07:15.000 --> 00:07:17.000
2番目の例に。

00:07:17.000 --> 00:07:22.000
別のフェーズを追加して、遅延シェーディングの例をより複雑にします。

00:07:22.000 --> 00:07:32.000
不透明なコンテンツの点灯バージョンを取得した後、ミックスに透明フェーズを追加し、フォワードシェーディングし、バックツーフロントのブレンド順序を近似します。

00:07:32.000 --> 00:07:39.000
A11が本当に得意な方法の1つは、色と深さのペアの配列を格納するためにイメージブロックを宣言することです。

00:07:39.000 --> 00:07:45.000
各フォワードシェーディングフラグメントは、オーバーフローの処理を伴うエントリをこの配列に追加します。

00:07:45.000 --> 00:07:52.000
そして、私のタイルの最後に、保存された深さを使用して、前後に並べ替えてブレンドし、バックツーフロントのブレンドを可能にします。

00:07:52.000 --> 00:07:58.000
したがって、これは1つのタイルの寿命とそのイメージブロックを左から右に示すタイムラインです。

00:07:58.000 --> 00:08:04.000
私は遅延シェーディングのためにレイアウトされたA11のイメージブロックから始めて、私のシェードの不透明な色で終わります。

00:08:04.000 --> 00:08:11.000
最後に、私は色と深さの配列を構築し、並べ替えている透明フェーズを持っています。

00:08:11.000 --> 00:08:19.000
これらの各パス内で、ラスターオーダーグループは、フラグメントスレッド間で可能な並列性の量を制御します。

00:08:19.000 --> 00:08:24.000
パフォーマンス上の理由から、私は本当にこれら2つの操作を1つのレンダーパスにしたいです。

00:08:24.000 --> 00:08:29.000
後でリロードするためだけに、デバイスのメモリに何も保存したくありません。

00:08:29.000 --> 00:08:38.000
しかし、イメージブロック宣言は、データタイプとラスター注文グループの割り当ての両方で、私のシーンの最初の部分と2番目の部分の間で大きく異なります。

00:08:38.000 --> 00:08:43.000
A11は、あなたの側でワンステップでこの移行を行うことができます。

00:08:43.000 --> 00:08:47.000
これらのフェーズ間のギャップを埋めるには、その間にタイルシェーダーを置く必要があります。

00:08:47.000 --> 00:08:53.000
タイルシェーダーは、タイルメモリとイメージブロック全体にアクセスできる計算スレッドグループです。

00:08:53.000 --> 00:09:02.000
タイルシェーダーは、ラスターオーダーグループの宣言に関係なく、以前にすべてのフラグメントシェーダースレッドが完了するまで起動しないという動作があります。

00:09:02.000 --> 00:09:07.000
これにより、このタイルシェーディングスレッドグループがこのメモリに排他的にアクセスできることを保証できます。

00:09:07.000 --> 00:09:20.000
タイルシェーダーを使用すると、タイル全体を読み書きし、必要に応じて再フォーマットし、特に古い発信タイプを介してイメージブロックから読み、新しいタイプを使用してイメージブロックの内容を再初期化することができます。

00:09:20.000 --> 00:09:28.000
タイルシェーダーが実行前に完全なバリアを持っているように、実行後も完全なバリアを持っています。

00:09:28.000 --> 00:09:38.000
後の段階でラスター注文グループをどのように設定したかに関係なく、タイルシェーダーが完全に完了するまで、後続のフラグメントシェーダースレッドはメモリにアクセスしません。

00:09:38.000 --> 00:09:45.000
これは、透明性の作業が始まる前に、この初期化が完了することに頼ることができることを意味します。

00:09:45.000 --> 00:09:47.000
ここでの要件はかなり簡単です。

00:09:47.000 --> 00:09:58.000
イメージブロックの内容を並べ替えたり、ラスターオーダーグループが保護するフィールドを変更したりする場合は、中央にタイルシェーダーを配置して、その移行を整然と安全にする必要があります。

00:09:58.000 --> 00:10:04.000
A11用に公開しているサンプルコードのいくつかは、実際にこのシーケンスを示しています。

00:10:04.000 --> 00:10:09.000
だから、A11でラスターオーダーグループの拡張された機能を利用するのは本当にそれだけです。

00:10:09.000 --> 00:10:15.000
ラスターオーダーグループが他のどのGPUよりもA11でさらに柔軟であるのを見てきました。

00:10:15.000 --> 00:10:20.000
ハードウェアは複数のグループをサポートしているため、過剰同期を排除し、パフォーマンスを向上させることができます。

00:10:20.000 --> 00:10:34.000
A11のフラグメントシェーダーのタイルメモリへのアクセスと連携し、タイルシェーダーを使用して、レンダリングパスの途中でラスターオーダーグループ設定を含むイメージブロックの文字を完全に変更できます。

00:10:34.000 --> 00:10:43.000
すべてをまとめると、帯域幅が信じられないほど軽く、非常に優れたパフォーマンスのA11でワークロードを構築できます。

00:10:43.000 --> 00:10:49.000
メタル2とA11の詳細、およびサンプルコードへのリンクについては、メタル開発者のウェブサイトをご覧ください。

00:10:49.000 --> 23:59:59.000
ご覧いただきありがとうございます。

