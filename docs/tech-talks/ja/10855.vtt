WEBVTT

00:00:00.000 --> 00:00:03.000
こんにちは、私はパトリックで、アップルのパフォーマンスチームで働いています。

00:00:03.000 --> 00:00:09.000
今日は、アプリのスクロールとアニメーションのヒッチについて話し合い、レンダリングループを詳しく見ていきます。

00:00:09.000 --> 00:00:13.000
まず、ヒッチとは何かを一般的に理解します。

00:00:13.000 --> 00:00:18.000
次に、レンダリングループと、起こりうるさまざまな種類のヒッチについて説明します。

00:00:18.000 --> 00:00:21.000
最後に、ヒッチを測定する方法について話し合います。

00:00:21.000 --> 00:00:24.000
まず、ヒッチとは何ですか?

00:00:24.000 --> 00:00:27.000
アプリでは、人が画面上で指をドラッグしてスクロールすることがあります。

00:00:27.000 --> 00:00:33.000
ボタンをタップして、階層内のビュー間のフィードバックや遷移を期待するかもしれません。

00:00:33.000 --> 00:00:38.000
これらのアニメーションは、画面上の人とコンテンツの間の視覚的なつながりの感覚を構築します。

00:00:38.000 --> 00:00:46.000
アニメーションのヒッチは、アニメーションのジャンプを引き起こし、その接続を壊し、喜びの代わりに混乱を引き起こす可能性があります。

00:00:46.000 --> 00:00:50.000
ヒッチとは、フレームが予想よりも遅く画面に表示される場合です。

00:00:50.000 --> 00:00:55.000
コレクションビューをスクロールする一般的な例を見てみましょう。

00:00:55.000 --> 00:00:59.000
ここには、お気に入りのレシピをキュレーションするのに役立つ食事プランナーアプリがあります。

00:00:59.000 --> 00:01:04.000
ユーザーが指を画面上にドラッグすると、スクロールビューはコンテンツを上に移動することで応答します。

00:01:04.000 --> 00:01:07.000
しかし、スクロール中に、コンテンツのジャンプに気づきます。

00:01:07.000 --> 00:01:17.000
このフレームをフレームごとに見ると、最初の3つのフレームのコンテンツで指が動いているのが見えますが、次のフレームではコンテンツが失速しているように見えます。

00:01:17.000 --> 00:01:22.000
それは、3番目のフレームが実際に繰り返され、別のフレームのためにディスプレイにとどまるからです。

00:01:22.000 --> 00:01:28.000
最後に4番目のフレームが来て、それは私たちの指がある場所に前方にジャンプするように見えます。

00:01:28.000 --> 00:01:33.000
4番目のフレームが遅れて到着し、ユーザーがヒッチを見たため、3番目のフレームが繰り返されました。

00:01:33.000 --> 00:01:37.000
ヒッチは、レンダリングループがフレームを時間通りに終了できない場合に発生します。

00:01:37.000 --> 00:01:40.000
では、レンダリングループを見てみましょう。

00:01:40.000 --> 00:01:49.000
レンダリングループは、タッチイベントがアプリに渡され、UIへの変更がフレームが確定されるオペレーティングシステムに送信される継続的なプロセスです。

00:01:49.000 --> 00:01:52.000
これはループであり、デバイスのリフレッシュレートで発生します。

00:01:52.000 --> 00:02:00.000
iPhoneとiPadでは、これは毎秒60フレームです。つまり、16.67ミリ秒ごとに新しいフレームを表示できます。

00:02:00.000 --> 00:02:08.000
iPad Proでは、これは毎秒120フレームです。つまり、8.33ミリ秒ごとに新しいフレームを表示できます。

00:02:08.000 --> 00:02:12.000
フレームの先頭で、ハードウェアはVSYNCと呼ばれるイベントを発行します。

00:02:12.000 --> 00:02:16.000
VSYNCは、新しいフレームの準備が整っている必要があるときを示します。

00:02:16.000 --> 00:02:20.000
ディスプレイトラックでそれらを強調表示するので、締め切りを簡単に確認できます。

00:02:20.000 --> 00:02:22.000
レンダリングループはVSYNCにタイミングが合います。

00:02:22.000 --> 00:02:27.000
フレームを準備するには、途中でチェックポイントに当たらなければなりません。

00:02:27.000 --> 00:02:29.000
それは3つの段階に分かれています。

00:02:29.000 --> 00:02:34.000
最初の段階はアプリで、イベントが処理され、UIに変更が加えられます。

00:02:34.000 --> 00:02:38.000
その作業は、次のVSYNCの前に完了する必要があるため、次の段階を開始できます。

00:02:38.000 --> 00:02:42.000
次の段階は、レンダリングサーバーと呼ばれる別のプロセスで行われます。

00:02:42.000 --> 00:02:45.000
これは、あなたのUIが実際にレンダリングされる場所です。

00:02:45.000 --> 00:02:53.000
このステージは、3番目で最後のステージであるフレームを表示できるように、次のVSYNCの前に完了する必要があります。

00:02:53.000 --> 00:02:58.000
3段階のプロセスに対する重要な注意点は、表示前にフレームが2つのフレームに対して処理されることです。

00:02:58.000 --> 00:03:01.000
私たちはこれをダブルバッファリングと呼んでいますが、別のモードがあります。

00:03:01.000 --> 00:03:09.000
ヒッチを避けるために、システムはトリプルバッファリングに切り替えることができ、レンダリングサーバーには作業を完了するために1つの余分なフレーム期間が与えられます。

00:03:09.000 --> 00:03:15.000
これはフォールバックモードなので、レンダリングループのヒッチについて話しながら、ダブルバッファリングに焦点を当てます。

00:03:15.000 --> 00:03:19.000
全体として、レンダリングループ全体は5つのフェーズで構成されています。

00:03:19.000 --> 00:03:22.000
ループは、第1段階、イベントフェーズから始まります。

00:03:22.000 --> 00:03:27.000
ここでは、アプリはタッチイベントを処理し、UIで変更が必要かどうかを決定します。

00:03:27.000 --> 00:03:29.000
次はコミットフェーズです。

00:03:29.000 --> 00:03:34.000
コミットフェーズでは、アプリはUIを更新し、レンダリングのためにレンダリングサーバーに送信します。

00:03:34.000 --> 00:03:41.000
次のVSYNCでは、レンダリングサーバーがその送信を受け取り、レンダリング準備フェーズでGPUに描画するために準備します。

00:03:41.000 --> 00:03:51.000
レンダリング実行フェーズでは、GPUはUIを最終的な画像に描画するので、次のVSYNCでフレームをユーザーに表示できます。

00:03:51.000 --> 00:03:57.000
各段階は、すべてのフレーム、レンダリング作業でさえもスムーズなユーザーエクスペリエンスを持つために不可欠です。

00:03:57.000 --> 00:04:06.000
それは別のプロセスで起こりますが、アプリに代わって機能するので、レイヤーツリーを時間内に処理して描画できるようにするのはあなたです。

00:04:06.000 --> 00:04:11.000
これをもう少し理解するために、例を見てみましょう。

00:04:11.000 --> 00:04:16.000
この例では、レンダリングループを通してこのフレームをたどって、途中で各フェーズを確認します。

00:04:16.000 --> 00:04:20.000
1つ目は、アプリがイベントを受信するイベントフェーズです。

00:04:20.000 --> 00:04:25.000
これらのイベントは、タッチ、ネットワーキングコールバック、キーボードプレス、タイマーのようなものです。

00:04:25.000 --> 00:04:30.000
アプリは、レイヤー階層を変更することで、これらのイベントに何らかの方法で応答できます。

00:04:30.000 --> 00:04:37.000
たとえば、アプリはレイヤーの背景色を変更したり、レイヤーのサイズや位置を変更したりできます。

00:04:37.000 --> 00:04:42.000
しかし、アプリがレイヤーの境界を更新すると、Core AnimationはsetNeedsLayoutも呼び出します。

00:04:42.000 --> 00:04:47.000
これはすべてのレイヤーを識別し、それに応じてレイアウトを再計算する必要があります。

00:04:47.000 --> 00:04:56.000
システムは、これらの「必要なレイアウト」要求を合体し、重複作業を減らすためにコミットフェーズ中に順番に実行します。

00:04:56.000 --> 00:05:02.000
レイアウトが必要な場合は、イベントフェーズが終了するとコミットフェーズが自動的に開始されます。

00:05:02.000 --> 00:05:10.000
まず、システムはレイアウトを必要とするすべてのレイヤーを取り、親から子まで、一度に1つずつレイアウトします。

00:05:10.000 --> 00:05:17.000
レイアウトは一般的なパフォーマンスのボトルネックなので、アプリはこの作業を完了するのに数ミリ秒しかないことを覚えておいてください。

00:05:17.000 --> 00:05:23.000
一部のビューでは、ラベル、画像ビュー、またはdrawRectをオーバーライドするビューなど、カスタム描画も必要です。

00:05:23.000 --> 00:05:29.000
これらのビューに視覚的な更新が必要な場合は、setNeedsDisplayを呼び出す必要があります。

00:05:29.000 --> 00:05:36.000
レイアウトと同様に、すべてのレイアウトが完了したら、システムはこれらの要求を合体して実行します。

00:05:36.000 --> 00:05:44.000
描画プロセス中、すべてのカスタム描画レイヤーは、描画するテクスチャに裏打ちされたCore Graphicsコンテキストを受け取ります。

00:05:44.000 --> 00:05:48.000
コアアニメーションに関する限り、これらのレイヤーは今や単なる画像です。

00:05:48.000 --> 00:05:57.000
そして、すべてのレイヤーがレイアウトされ、描画されたので、変更されたレイヤーツリー全体が収集され、レンダリングのためにレンダリングサーバーに送信されます。

00:05:57.000 --> 00:06:04.000
今、私たちはレンダリングサーバーにいて、レイヤーツリーを実際の表示可能な画像に変える責任があります。

00:06:04.000 --> 00:06:13.000
準備フェーズでは、レンダリングサーバーはアプリのレイヤーツリーを反復し、GPUが実行できる線形パイプラインを準備します。

00:06:13.000 --> 00:06:24.000
最上層から始めて、親から子へ、兄弟から兄弟へと機能し、レイヤーが後ろから前に配置されます。

00:06:24.000 --> 00:06:30.000
次に、この線形パイプラインはGPUを通過し、各レイヤーが最終的なテクスチャに合成されます。

00:06:30.000 --> 00:06:37.000
一部のレイヤーはレンダリングに時間がかかることがあり、これはまもなく説明する別の一般的なパフォーマンスのボトルネックです。

00:06:37.000 --> 00:06:38.000
すごい。

00:06:38.000 --> 00:06:44.000
したがって、GPUが右側の画像を実行してレンダリングすると、次のVSYNCに表示する準備が整います。

00:06:44.000 --> 00:06:48.000
レンダリングループの各フェーズはパフォーマンスに敏感で、締め切りがあります。

00:06:48.000 --> 00:06:50.000
締め切りは次のVSYNCです。

00:06:50.000 --> 00:06:58.000
ターゲットフレームレートを達成し、低い入力レイテンシを維持するために、このプロセス全体が実際にすべてのフレームで並行して行われています。

00:06:58.000 --> 00:07:05.000
このようにして、パイプラインは並行し、システムが前のフレームをレンダリングしている間、アプリは新しいフレームを準備できます。

00:07:05.000 --> 00:07:09.000
これが、締め切りを逃したことが非常に重要である理由です。

00:07:09.000 --> 00:07:15.000
レンダーループの仕組みがわかったので、アプリで見られるヒッチの種類を掘り下げてみましょう。

00:07:15.000 --> 00:07:23.000
アプリのプロセス内で発生するコミットヒッチと、レンダリングサーバーで発生するレンダリングヒッチの2つの主要なタイプがあります。

00:07:23.000 --> 00:07:29.000
コミットヒッチは、アプリがイベントの処理やコミットに時間がかかりすぎる場合です。

00:07:29.000 --> 00:07:39.000
ここでは、コミットに時間がかかりすぎて締め切りに間に合わないため、次のVSYNCでは、レンダリングサーバーは処理するものがなく、次のVSYNCがレンダリングを開始するのを待たなければなりません。

00:07:39.000 --> 00:07:42.000
そして今、私たちはフレームの納期を1フレーム遅らせました。

00:07:42.000 --> 00:07:47.000
ミリ秒単位で、iPhoneやiPadでは16.67ミリ秒です。

00:07:47.000 --> 00:07:52.000
私たちはこの遅延時間を「ヒッチタイム」と呼び、ミリ秒単位で測定します。

00:07:52.000 --> 00:08:00.000
コミット作業がさらに時間がかかり、次のVSYNCを通過した場合、フレームは2フレーム、つまり33.34ミリ秒遅れます。

00:08:00.000 --> 00:08:06.000
ユーザーにスムーズなスクロールが表示されないのは33.34ミリ秒です。

00:08:06.000 --> 00:08:13.000
コミットヒッチとアプリで修正する方法の詳細については、「コミットフェーズでヒッチを見つけて修正する」をチェックしてください。

00:08:13.000 --> 00:08:16.000
2番目のタイプのヒッチはレンダーヒッチです。

00:08:16.000 --> 00:08:22.000
これらは、レンダリングサーバーがレイヤーツリーを時間通りに準備または実行できない場合に発生します。

00:08:22.000 --> 00:08:26.000
ここでは、レンダリング実行フェーズが時間がかかりすぎて、VSYNCの境界を越えます。

00:08:26.000 --> 00:08:33.000
したがって、フレームは時間通りに準備ができておらず、緑色のフレームは予想よりも1フレーム遅れて表示されました。

00:08:33.000 --> 00:08:36.000
もう一度、16ミリ秒のヒッチタイムがあります。

00:08:36.000 --> 00:08:44.000
レンダリングヒッチとレイヤーツリーを最適化する方法の詳細については、「レンダリングフェーズでヒッチを解明して排除する」をチェックしてください。

00:08:44.000 --> 00:08:46.000
すごい。

00:08:46.000 --> 00:08:48.000
だから、それらは2つの主要なタイプのヒッチです。

00:08:48.000 --> 00:08:53.000
それでは、ヒッチを測定し、定量化する方法に焦点を当てましょう。

00:08:53.000 --> 00:08:55.000
前のスライドでヒッチタイムを見ました。

00:08:55.000 --> 00:09:04.000
単一のヒッチについて話すときに非常に便利ですが、スクロール、アニメーション、トランジションなどの長期的なイベントについて話し合うときには扱いにくいことがあります。

00:09:04.000 --> 00:09:13.000
まず、各スクロールやアニメーションにまったく同じ時間、したがってまったく同じ数のフレームがかからない限り、比較は困難です。

00:09:13.000 --> 00:09:18.000
さらに悪いことに、iOSデバイスが常に画面を更新するとは限りません。

00:09:18.000 --> 00:09:22.000
レンダリングサーバーに送信されたコミットがない場合、新しいフレームは送信されません。

00:09:22.000 --> 00:09:27.000
これにより、テストとデバイス間でヒッチ時間を比較することがさらに難しくなります。

00:09:27.000 --> 00:09:30.000
そのため、代わりに「ヒッチ時間比」と呼ばれるメトリックを使用します。

00:09:30.000 --> 00:09:36.000
ヒッチ時間比は、間隔の合計ヒッチ時間をその持続時間で割った値です。

00:09:36.000 --> 00:09:42.000
合計時間に正規化されているため、経験間で比較できます。

00:09:42.000 --> 00:09:49.000
ヒッチミリ秒/秒で測定されるため、デバイスが毎秒ヒッチングしていたミリ秒の量を表します。

00:09:49.000 --> 00:09:55.000
このメトリックを使用して独自のアプリのパフォーマンスを測定する方法については、「MetricKitの新機能」をチェックしてください。

00:09:55.000 --> 00:10:02.000
テストスイートでヒッチタイム比を追跡する方法を確認するには、「XCTestでアニメーションヒッチを解消する」をチェックしてください。

00:10:02.000 --> 00:10:07.000
最後に、ヒッチタイム比を使用できる例を見てみましょう。

00:10:07.000 --> 00:10:12.000
ここには30フレームがあり、iPhoneでは0.5秒分の仕事です。

00:10:12.000 --> 00:10:16.000
各フレームは締め切りに間に合い、ユーザーはヒッチを見ません。

00:10:16.000 --> 00:10:21.000
ヒッチ時間はゼロで、ヒッチ時間比もゼロです。

00:10:21.000 --> 00:10:25.000
しかし今、下部にバラバラな間隔でディスプレイトラックが見えます。

00:10:25.000 --> 00:10:30.000
一部のフレームは他のフレームよりも長く画面に表示され、一部のコミットとレンダリングはヒッチを引き起こしています。

00:10:30.000 --> 00:10:35.000
このヒッチ時間を合計すると、100.02ミリ秒になります。

00:10:35.000 --> 00:10:41.000
半秒以上、ヒッチタイム比は毎秒200.04ミリ秒です。

00:10:41.000 --> 00:10:42.000
これはほんの一例です。

00:10:42.000 --> 00:10:48.000
一般的に、これらは私たちが推奨し、ここAppleのツールで使用するターゲットヒッチ比です。

00:10:48.000 --> 00:10:57.000
この目標は毎秒ゼロヒッチミリ秒ですが、毎秒5ヒッチミリ秒未満のものは、ユーザーによっては良好であり、ほとんど目立たないと見なされます。

00:10:57.000 --> 00:11:05.000
毎秒5〜10ヒッチミリ秒の間で、ユーザーはいくつかの中断に気づくことになり、これらを調査する必要があります。

00:11:05.000 --> 00:11:15.000
毎秒10ミリ秒以上のヒッチは、ユーザーエクスペリエンスに大きな影響を与えており、レンダリングループを最適化する方法をすぐに調査する必要があります。

00:11:15.000 --> 00:11:20.000
要約すると、今日はレンダリングループと、新しいフレームがユーザーにどのように表示されるかについて議論しました。

00:11:20.000 --> 00:11:25.000
ヒッチとは何か、コミットヒッチとレンダリングヒッチの2つのタイプを調べました。

00:11:25.000 --> 00:11:32.000
最後に、特定の期間内にユーザーが経験するヒッチングの量を測定するために、ヒッチタイム比を定義しました。

00:11:32.000 --> 00:11:40.000
ヒッチの種類とアプリでそれらをキャッチして修正する方法の詳細については、コミットヒッチとレンダリングヒッチに関する2つの講演をご覧ください。

00:11:40.000 --> 23:59:59.000
あなたのバターのような滑らかなアプリを見るのが待ちきれません、そして見てくれてありがとう。

