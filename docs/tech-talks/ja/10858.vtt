WEBVTT

00:00:00.000 --> 00:00:03.000
A14 Bionicのメタルアップデートへようこそ。

00:00:03.000 --> 00:00:09.000
私の名前はAnand Poovekurussiで、AppleでGPUソフトウェアで働いています。

00:00:09.000 --> 00:00:14.000
A14 Bionicは、iPhone 12と新しいiPad Airの中心にあります。

00:00:14.000 --> 00:00:25.000
このビデオでは、同僚のスワミと私は、A14 BionicのGPU機能とそれを可能にする新しいメタル機能を紹介します。

00:00:25.000 --> 00:00:34.000
A14には、CPU、GPU、ニューラルエンジン、およびiOSエクスペリエンスを推進するその他のカスタム技術が大幅に更新されています。

00:00:34.000 --> 00:00:45.000
画期的な5ナノメートルプロセス技術を使用しており、チップのほぼすべての面で新機能、パフォーマンスの向上、さらに高い電力効率をもたらします。

00:00:45.000 --> 00:00:50.000
私たちはA14 Bionicに世界クラスのモバイルGPUを構築しました。

00:00:50.000 --> 00:00:57.000
可能な限り低い電力で最大の持続可能なパフォーマンスを提供するために拡張された4つのコアを持っています。

00:00:57.000 --> 00:01:05.000
さて、Metalに関しては、A14にはMetalアプリのパフォーマンスを向上させるいくつかの特定の変更があります...

00:01:05.000 --> 00:01:08.000
GPU駆動のパイプラインから始めます。

00:01:08.000 --> 00:01:16.000
Metalの間接コマンドバッファを使用すると、作業をGPUに移動し、GPUタイムラインでコマンドをエンコードできます。

00:01:16.000 --> 00:01:21.000
これにより、アプリで他のタスクを実行するための貴重なCPU時間が解放されます。

00:01:21.000 --> 00:01:27.000
A14 GPUアーキテクチャは、このような使用モデルをより効率的にします。

00:01:27.000 --> 00:01:35.000
次に、並列コンピューティングをよりよくサポートするために、GPUスレッドグループメモリの設計のパフォーマンスを大幅に改善しました。

00:01:35.000 --> 00:01:44.000
スレッドグループスコープアトミックなどの同期プリミティブは、これらの変更の結果として大きなパフォーマンスの利点を見ることを期待しています。

00:01:44.000 --> 00:01:51.000
最後に、メモリ帯域幅を節約する能力は、当社のプラットフォームの重要な設計上の優位性であり続けています。

00:01:51.000 --> 00:01:58.000
A14 GPUは、アプリにさらに多くの帯域幅を節約する新しい圧縮ハードウェアを活用しています。

00:01:58.000 --> 00:02:08.000
フレームバッファの圧縮は平均して15%以上改善すると予想され、深度バッファは平均して40%以上の改善が見られるはずです。

00:02:08.000 --> 00:02:18.000
A14 GPUのすべての新機能は、Apple GPUファミリー7と呼ばれる新しいMetal機能セットに属しています。

00:02:18.000 --> 00:02:21.000
このビデオで取り上げる内容は次のとおりです。

00:02:21.000 --> 00:02:25.000
まず、重心座標とプリミティブIDについて話します。

00:02:25.000 --> 00:02:34.000
また、これらの機能の両方を一緒に使用して、可視性バッファなどの遅延レンダリング技術を実装する方法も紹介します。

00:02:34.000 --> 00:02:39.000
その後、A14の新しいテクスチャアドレッシングモードをすばやく紹介します。

00:02:39.000 --> 00:02:44.000
また、コンピューティングを行うアプリのためのまったく新しい機能もあります。

00:02:44.000 --> 00:02:56.000
講演の2番目のセクションでは、同僚のSwamiが、アプリケーションがSIMDグループスコープで削減操作を実行するための効率的な方法を提供する新しいSIMD削減手順について説明します。

00:02:56.000 --> 00:03:02.000
彼はまた、A14のMetalの新しいSIMDマトリックス乗算命令をカバーします。

00:03:02.000 --> 00:03:10.000
これらの新しい命令は、機械学習と画像計算で使用される大規模な行列乗算に大きなパフォーマンス向上を提供します。

00:03:10.000 --> 00:03:14.000
これらのそれぞれをもっと詳しく見てみましょう....

00:03:14.000 --> 00:03:19.000
重心座標とプリミティブIDから始まります。

00:03:19.000 --> 00:03:25.000
Apple GPUファミリー7は、バリセントリック座標とプリミティブIDへのアクセスを提供するようになりました。

00:03:25.000 --> 00:03:30.000
バリセントリック座標は、プリミティブ内のフラグメントの正確な位置を定義します。

00:03:30.000 --> 00:03:34.000
そして今、フラグメントシェーダーでこれらの座標にアクセスできます。

00:03:34.000 --> 00:03:45.000
右の写真でわかるように、ポイントPのフラグメントの位置は、三角形を形成する頂点の加重和として定義され、重みの合計は1です。

00:03:45.000 --> 00:03:51.000
メタルシェーディング言語では、フラグメントの重心座標はフロートのベクトルとして公開されます。

00:03:51.000 --> 00:03:58.000
重心座標を使用することで恩恵を受けることができる技術を見てみましょう。

00:03:58.000 --> 00:04:05.000
手続き生成は、モデル、アニメーション、エフェクトをアルゴリズム的に生成するために使用される技術のクラスです。

00:04:05.000 --> 00:04:13.000
粒子システム、地形、植生など、プリミティブの表面にあらゆる種類の手続き効果をその場で行うことができます。

00:04:13.000 --> 00:04:16.000
カスタム線を描くことは、そのような例の1つです。

00:04:16.000 --> 00:04:21.000
バリセントリック座標をこれにどのように使用できるかを見てみましょう。

00:04:21.000 --> 00:04:29.000
手続き型生成を使用して、三角形にカスタムの高品質のアンチエイリアス線と境界線を描きたいとしましょう。

00:04:29.000 --> 00:04:36.000
これを行うには、プリミティブの端からのフラグメントの距離に興味深い数学関数を適用することができます。

00:04:36.000 --> 00:04:42.000
本質的にあなたの断片のバリセントリック座標は、エッジからの距離を与えます。

00:04:42.000 --> 00:04:51.000
上記の例は、オンザフライ効果を生成するために、フラグメントシェーダーの重心座標に適用されるいくつかの興味深い関数を示しています。

00:04:51.000 --> 00:04:56.000
A14のMetalのもう1つの新機能は、プリミティブIDです。

00:04:56.000 --> 00:05:02.000
プリミティブIDは、現在のフラグメントが入力ジオメトリでどのプリミティブに対応するかを示します。

00:05:02.000 --> 00:05:11.000
右側では、フラグメントシェーダーでその三角形内のフラグメントのプリミティブIDがフェッチされたときに、三角形にリストされているIDが返されます。

00:05:11.000 --> 00:05:17.000
これで、三角形がハードウェアによってクリップされた場合、子三角形は親のプリミティブIDを継承します。

00:05:17.000 --> 00:05:23.000
そして、テッセレーションの存在下では、プリミティブIDは単にパッチIDに対応します。

00:05:23.000 --> 00:05:27.000
メタルシェーディング言語では、プリミティブIDは符号なし整数です。

00:05:27.000 --> 00:05:32.000
プリミティブIDのユースケースを見てみましょう。

00:05:32.000 --> 00:05:39.000
一時的なアンチエイリアシングは、フレーム間の動きによって引き起こされるゴーストときらめくアーティファクトを減らす技術です。

00:05:39.000 --> 00:05:45.000
これは、前のフレームからピクセルデータを蓄積し、それをフラグメントの現在のレンダリング結果とブレンドすることによって機能します。

00:05:45.000 --> 00:05:51.000
プリミティブIDは、時間的アンチエイリアスで使用して、前のフレームのサンプルを検証できます。

00:05:51.000 --> 00:05:55.000
では、実際にこれをどのように行いますか?

00:05:55.000 --> 00:06:01.000
まず、フラグメントシェーダーで、前のフレームの結果を再投影して、ピクセル履歴を取得します。

00:06:01.000 --> 00:06:07.000
次に、ピクセルを内省して、データが現在のフレームと一致していることを確認します。

00:06:07.000 --> 00:06:11.000
これは、2つのサンプルのプリミティブIDを比較することで実行できます。

00:06:11.000 --> 00:06:15.000
IDが一致する場合は、前のフレームからの貢献を蓄積することを選択できます。

00:06:15.000 --> 00:06:23.000
ピクセル履歴は、イントロスペクション後に蓄積またはリセットして、結果を次のフレームに転送できます。

00:06:23.000 --> 00:06:29.000
重心座標とプリミティブIDを導入したので、もっと深く掘り下げてみましょう...

00:06:29.000 --> 00:06:34.000
遅延レンダリングから始めて、あなたがすでによく知っている可能性が高いテクニックです。

00:06:34.000 --> 00:06:38.000
遅延レンダリングは、古典的に2つの段階で動作します。

00:06:38.000 --> 00:06:46.000
第1段階は、Gバッファと呼ばれるサーフェス属性バッファを生成し、第2段階はGバッファを消費し、シーンに照明を適用します。

00:06:46.000 --> 00:06:57.000
しかし、高解像度で実行している場合、またはマルチサンプリングを使用している場合、Gバッファのサイズは非常に大きくなる可能性があり、これらのバッファの読み取りと書き込みは帯域幅コストがかかる可能性があります。

00:06:57.000 --> 00:07:06.000
この問題に対処するために、Gバッファは、サーフェス属性の最小セットを含む薄いバッファに置き換えることができます。

00:07:06.000 --> 00:07:11.000
このバッファは可視性バッファと呼ばれます。

00:07:11.000 --> 00:07:18.000
可視性バッファは、この段階からの出力を大幅に簡素化することで、ジオメトリ段階での作業を最小限に抑えます。

00:07:18.000 --> 00:07:27.000
Gバッファでマテリアルプロパティを生成するために、遅延レンダリングでフラグメントシェーダーで通常実行するすべてのマテリアルロジックは、照明フェーズに移動されました。

00:07:27.000 --> 00:07:33.000
これにより、すべての材料特性を中間バッファに保存する必要がなくなります。

00:07:33.000 --> 00:07:43.000
材料機能がなければ、ジオメトリステージの複雑さが大幅に軽減され、頂点シェーダーとフラグメントシェーダーの間の高い充填率と最小トラフィックが可能になります。

00:07:43.000 --> 00:07:52.000
この技術は、可視性バッファ内の最小限のデータセットから材料入力を再構築するために、照明パス中に新しい再構築ステップを追加します。

00:07:52.000 --> 00:07:57.000
可視性バッファに何が含まれているかを見てみましょう。

00:07:57.000 --> 00:08:03.000
可視性バッファには、ジオメトリの再構築を容易にするために2つの属性を含めるだけで済みます。

00:08:03.000 --> 00:08:12.000
プリミティブIDを使用して、頂点バッファから頂点データを手動で取得し、遅延頂点フェッチを効果的に実行できます。

00:08:12.000 --> 00:08:16.000
重心座標は、現在のフラグメントの頂点データを補間するために使用されます。

00:08:16.000 --> 00:08:22.000
前述のように、A14のフラグメントシェーダーでこれらの属性にアクセスできます。

00:08:22.000 --> 00:08:27.000
可視性バッファパイプラインの2つの段階を詳しく見てみましょう。

00:08:27.000 --> 00:08:37.000
高いレベルでは、可視性バッファアプローチには、可視性バッファを生成するジオメトリステージと、それを消費する照明ステージの2つのステージがあります。

00:08:37.000 --> 00:08:44.000
ジオメトリ段階では、頂点シェーダーの変換はラスタライズに必要な位置のみを生成します。

00:08:44.000 --> 00:08:55.000
フラグメントステージは、追加のバリエーションを必要とせずに、新しいA14メタルシェーディング言語属性でプリミティブIDとバリセントリック座標を生成できます。

00:08:55.000 --> 00:09:08.000
照明段階では、新しい再構築ステップは、プリミティブIDに基づいて遅延頂点フェッチを使用し、重心座標を使用して頂点データを補間して材料関数入力を生成します。

00:09:08.000 --> 00:09:16.000
素材と照明シェーダーは効果的に手つかずで、延期されたレンダリングの実装と同じです。

00:09:16.000 --> 00:09:22.000
これらのステージ間のインターフェースがどのように最小化されたかを見てみましょう。

00:09:22.000 --> 00:09:26.000
頂点シェーダーは、ラスタライズする位置のみを必要とします。

00:09:26.000 --> 00:09:34.000
フラグメントシェーダーは、再構築ステップに供給される可視性バッファの表面IDと重心座標を生成します。

00:09:34.000 --> 00:09:44.000
そして、再構築ステップの後にのみ、材料モデルと照明機能で使用される大きな再構築された材料入力データをメモリに保存します。

00:09:44.000 --> 00:09:52.000
インターフェイスを導入したので、これらの入力と出力を生成しているシェーダーを見てみましょう。

00:09:52.000 --> 00:09:57.000
単純な頂点とフラグメントシェーダーを持つジオメトリフェースから始めましょう。

00:09:57.000 --> 00:10:02.000
頂点シェーダーは、位置を変換して出力するだけです。

00:10:02.000 --> 00:10:08.000
フラグメントシェーダーでは、メタルシェーディング言語で利用可能な新しいプリミティブIDとバリセントリック座標を使用します。

00:10:08.000 --> 00:10:19.000
プリミティブIDと追加の描画インデックスをサーフェス識別子に組み合わせて、後で見るように、頂点バッファ全体でプリミティブを識別できます。

00:10:19.000 --> 00:10:22.000
では、照明のステージを見てみましょう。

00:10:22.000 --> 00:10:29.000
高レベルでは、照明ステージには、再構築、材料モデル、照明機能の3つのステップがあります。

00:10:29.000 --> 00:10:36.000
再構築ステップは、表面識別子とバリセントリック座標からの材料入力を再構築します。

00:10:36.000 --> 00:10:41.000
その後、遅延シェーダーで行うように、材料モデルステップを実行できます。

00:10:41.000 --> 00:10:46.000
そして最後に、照明機能を適用して、最終的な照明ピクセルを書き出します。

00:10:46.000 --> 00:10:52.000
前述のように、素材と照明のステージは古典的な延期と同じです。

00:10:52.000 --> 00:10:58.000
では、再建のステップをもっと詳しく見てみましょう。

00:10:58.000 --> 00:11:06.000
再構築ステップの主な目的は、着信可視性バッファフラグメントを材料入力に変換することです。

00:11:06.000 --> 00:11:14.000
まず、サーフェス識別子に含まれるプリミティブIDとドローIDを使用して、特定のフラグメントの頂点データを生成する必要があります。

00:11:14.000 --> 00:11:20.000
追加のインデックスは、フラグメント間で異なる頂点バッファを持つことを容易にします。

00:11:20.000 --> 00:11:25.000
このために、ドロー識別子を使用してドローコールを参照します。

00:11:25.000 --> 00:11:30.000
第二に、重心座標は再構築ステップの補間に使用されます。

00:11:30.000 --> 00:11:33.000
逆参照ツリーを調べてみましょう。

00:11:33.000 --> 00:11:43.000
ここでは、可視性バッファピクセルを元の補間頂点属性に戻すために必要な逆参照ツリーを示します。

00:11:43.000 --> 00:11:46.000
可視性バッファには、2つの重心座標が含まれています。

00:11:46.000 --> 00:11:52.000
3番目の座標は、3つすべての合計が1つであるため、他の2つから取得できます。

00:11:52.000 --> 00:11:57.000
また、前述のように、ドローIDとプリミティブIDの組み合わせも含まれています。

00:11:57.000 --> 00:12:05.000
描画IDから、描画状態を取得でき、ビュー投影行列などの描画ごとのプロパティにアクセスできます。

00:12:05.000 --> 00:12:10.000
そこから、メッシュ状態から頂点とインデックスバッファを取得できます。

00:12:10.000 --> 00:12:14.000
これらのインデックスは、頂点データを取得するために必要です。

00:12:14.000 --> 00:12:20.000
また、同じパスを使用して、必要な材料固有のデータを取得することもできます。

00:12:20.000 --> 00:12:28.000
これで、材料モデルがより複雑になった場合、特定の材料ロジックを実行するための材料関数ポインタを追加できます。

00:12:28.000 --> 00:12:33.000
シェーダーコードで再構築がどのように見えるかを見てみましょう。

00:12:33.000 --> 00:12:41.000
再構築関数で最初に行うことは、プリミティブIDを取得し、可視性バッファからIDとバリセントリック座標を描画することです。

00:12:41.000 --> 00:12:47.000
その後、ドローIDを使用してドロー状態からメッシュIDを取得できます。

00:12:47.000 --> 00:12:56.000
インデックスバッファは、プリミティブIDとメッシュIDを使用して頂点バッファ内の頂点インデックスを取得するために逆参照する必要があります。

00:12:56.000 --> 00:13:02.000
その後、頂点バッファデータをバリセントリック座標にわたって読み取り、補間することができます。

00:13:02.000 --> 00:13:13.000
さらに、行列やその他の描画ごとの情報を取得して、法線や接線などのジオメトリで遅延頂点変換を行うことができます。

00:13:13.000 --> 00:13:21.000
材料入力が生成されると、前述のように、データは材料ロジックと照明機能に入力されます。

00:13:21.000 --> 00:13:25.000
実行中の可視性バッファを見てみましょう。

00:13:25.000 --> 00:13:30.000
これは、iPhoneで実行されている可視性バッファを使用しているモダンなレンダリングシーンです。

00:13:30.000 --> 00:13:37.000
複数の素材と光で満たされたシーンを利用するタイル照明技術を実装しています。

00:13:37.000 --> 00:13:46.000
通常、古典的な延期では、これは通常、アルベド、粗さなどの複数のGバッファチャネルを必要とし、かなり大きなGバッファを占めます。

00:13:46.000 --> 00:13:54.000
しかし、可視性バッファでは、サーフェスIDと重心座標だけが必要です。

00:13:54.000 --> 00:14:04.000
まず、生成されたサーフェス識別子を保存し、それぞれドローIDとプリミティブIDを示す明るさと色相でここに視覚化されます。

00:14:04.000 --> 00:14:12.000
次に、ここで視覚化されたバリセントリック座標を、赤、緑、青のカラーチャンネルで保存します。

00:14:12.000 --> 00:14:20.000
これら2つの特性は、ジオメトリを効率的に再構築し、遅延材料シェーディングと照明モデルを適用するのに十分です。

00:14:20.000 --> 00:14:28.000
この技術により、薄い視認性バッファーを使用してA14でGバッファサイズが大幅に縮小されます。

00:14:28.000 --> 00:14:35.000
この例では、古典的な繰延と比較して、Gバッファサイズの40%以上を節約しています。

00:14:35.000 --> 00:14:41.000
バリセントリック座標とプリミティブIDの深い掘り下げを締めくくります。

00:14:41.000 --> 00:14:46.000
それでは、A14の新しいテクスチャアドレッシングモードを簡単に見てみましょう。

00:14:46.000 --> 00:14:56.000
これらのモードは、サンプリング範囲外のテクスチャ座標の処理方法を指定すると、テクスチャアトラスを使用しているときに非常に便利です。

00:14:56.000 --> 00:15:00.000
A14用のMetalに2つの新しいアドレッシングモードを追加しました。

00:15:00.000 --> 00:15:08.000
エッジアドレッシングモードへのミラークランプでは、範囲の範囲内のテクスチャ座標が軸全体にミラーリングされます。

00:15:08.000 --> 00:15:10.000
そして、彼らが外に落ちるとき、彼らはクランプされます。

00:15:10.000 --> 00:15:14.000
右側の写真でこれを見ることができます。

00:15:14.000 --> 00:15:22.000
また、透明な黒、不透明な黒、不透明な白の間でプリセットの1つを選択できるボーダーカラークランプモードも追加しました。

00:15:22.000 --> 00:15:25.000
使い方はかなり簡単です。

00:15:25.000 --> 00:15:29.000
まず、サンプラー記述子オブジェクトを作成する必要があります。

00:15:29.000 --> 00:15:37.000
次に、アドレスモードを設定することで、深さ、幅、高さの座標のクランプモードを個別に指定できます。

00:15:37.000 --> 00:15:42.000
clampToBorderColorを使用している場合は、Metalでサポートされているプリセットの1つを設定できます。

00:15:42.000 --> 00:15:48.000
この後、サンプラー記述子を使用してsamplerStateオブジェクトを作成できます。

00:15:48.000 --> 00:15:54.000
それがA14の新しいグラフィック機能の概要でした。

00:15:54.000 --> 00:16:03.000
今、私はSIMD削減から始めて、A14 GPUが可能にする新しいコンピューティング機能を説明するために、同僚のスワミにそれを手渡したいと思います。

00:16:03.000 --> 00:16:04.000
ありがとう、アナンド。

00:16:04.000 --> 00:16:09.000
私はスワミ・ナラヤナンで、GPUソフトウェアで働いています。

00:16:09.000 --> 00:16:21.000
Metalは、高性能グラフィックスを可能にするだけでなく、データ並列計算を実行するように設計されており、GPUの驚異的なパワーを活用するさまざまな高度なコンピューティング機能を提供します。

00:16:21.000 --> 00:16:31.000
A14 Bionicでは、Metalは現在、アプリが信じられないほど効率的に削減を実行する方法を提供するSIMDスコープ削減命令を提供しています。

00:16:31.000 --> 00:16:36.000
それらがどのように機能するかを理解するために、並列削減操作を簡単に復習しましょう。

00:16:36.000 --> 00:16:41.000
削減操作は、配列の要素を単一の結果に減らすために使用されます。

00:16:41.000 --> 00:16:46.000
たとえば、合計削減は、配列のすべての要素を合計するために使用されます。

00:16:46.000 --> 00:16:49.000
これは平均の計算に役立ちます。

00:16:49.000 --> 00:16:54.000
もう1つの例は、シーンの最小値と最大値を計算することです。

00:16:54.000 --> 00:16:58.000
これらの値は、トーンマッピングアルゴリズムで使用できます。

00:16:58.000 --> 00:17:03.000
古典的には、これらの操作はすべてCPU上で連続して計算されました。

00:17:03.000 --> 00:17:12.000
しかし、MetalはGPUの並列性を利用して、削減をはるかに効率的に計算することができます。

00:17:12.000 --> 00:17:18.000
A14 GPUでは、MetalはいくつかのSIMDスコープ削減命令をサポートするようになりました。

00:17:18.000 --> 00:17:26.000
simd_sumとsimd_productは、SIMDグループ内のすべてのスレッドで変数の合計と積を生成します。

00:17:26.000 --> 00:17:32.000
Simd_minimumとsimd_maximumは、最小値と最大値を見つけるために使用できます。

00:17:32.000 --> 00:17:38.000
これらの4つの命令は、浮動小数点型と整数型で動作します。

00:17:38.000 --> 00:17:44.000
さらに、Metalは、ビット単位の演算子「and」、「or」、および「xor」を使用した削減をサポートするようになりました。

00:17:44.000 --> 00:17:48.000
当然のことながら、これらは整数型でのみ機能します。

00:17:48.000 --> 00:17:56.000
削減操作について詳しく説明する前に、スレッドがスレッドグループとSIMDグループにどのように編成されているかを見てみましょう。

00:17:56.000 --> 00:18:03.000
計算ディスパッチは、グリッドとして表される個々のスレッドのセットを起動します。

00:18:03.000 --> 00:18:09.000
このスレッドのグリッドは、スレッドグループと呼ばれる小さなサブグリッドに分かれています。

00:18:09.000 --> 00:18:15.000
スレッドグループは、SIMDグループと呼ばれる32のスレッドのグループにさらに編成されます。

00:18:15.000 --> 00:18:19.000
SIMDグループのスレッドは、ロックステップで同時に実行されます。

00:18:19.000 --> 00:18:25.000
SIMDグループ関数は、このロックステップ実行を悪用して、これらのスレッド間でデータを共有します。

00:18:25.000 --> 00:18:34.000
SIMDグループとスレッドグループがどのように構成されているかを見たので、SIMDグループでスレッドがどのように実行されるかを見てみましょう。

00:18:34.000 --> 00:18:39.000
SIMDグループには、ここの左側に表される32の車線があります。

00:18:39.000 --> 00:18:43.000
これらの各レーンは、コンピューティングディスパッチからスレッドを実行します。

00:18:43.000 --> 00:18:49.000
それでは、SIMDグループ内のすべてのスレッドにレーンIDを変数Xに保存させましょう。

00:18:49.000 --> 00:18:54.000
各レーンがXの独自の値を持っていることに注目してください。

00:18:54.000 --> 00:19:05.000
SIMDグループ実行モデルでは、変数XをレーンIDに設定する命令は一度だけフェッチされ、32スレッドによってロックステップで同時に実行されます。

00:19:05.000 --> 00:19:13.000
SIMDグループ関数を使用すると、これらのスレッドのそれぞれが最小限のオーバーヘッドでSIMDグループ内の他のスレッドの変数を検査して使用できます。

00:19:13.000 --> 00:19:20.000
A14に追加された新しい指示の1つであるsimd_sumを見てみましょう。

00:19:20.000 --> 00:19:28.000
simd_sumは、SIMDグループ内のすべてのアクティブなスレッドで変数の値を加算し、合計をすべてのスレッドにブロードキャストします。

00:19:28.000 --> 00:19:34.000
ここでは、SIMDグループの32レーンに変数Xの値を追加します。

00:19:34.000 --> 00:19:40.000
命令が実行されると、結果の合計は変数Fで利用可能になります。

00:19:40.000 --> 00:19:48.000
すべてのアクティブなスレッドは、変数Fのコピーを検査して、計算された合計496を取得できることに注意してください。

00:19:48.000 --> 00:19:51.000
非アクティブなスレッドは計算で正しくスキップされます。

00:19:51.000 --> 00:19:55.000
彼らは最終的な金額に貢献しません。

00:19:55.000 --> 00:20:01.000
それでは、simd_sumを使用して大きな配列の要素の追加を高速化する方法を見てみましょう。

00:20:01.000 --> 00:20:04.000
ここでは、入力アレイはデバイスメモリにあります。

00:20:04.000 --> 00:20:11.000
各SIMDグループは、入力配列の小領域を読み取り、simd_sum命令を使用してその合計を計算します。

00:20:11.000 --> 00:20:15.000
この合計は、スレッドグループメモリ内の配列に書き込まれます。

00:20:15.000 --> 00:20:22.000
すべてのSIMDグループには、スレッドグループ合計配列にインデックスを作成するために使用できる個別のIDがあります。

00:20:22.000 --> 00:20:29.000
スレッドグループで最後に実行したSIMDグループは、simd_sum命令を再度使用して最終的な合計を取得します。

00:20:29.000 --> 00:20:34.000
Simd_sumを使用することで、スレッドグループバリアの数とスレッドグループメモリの使用を減らしました。

00:20:34.000 --> 00:20:41.000
simd_sum命令は、SIMDグループ内のすべてのスレッドの合計を計算するために一度だけ実行されます。

00:20:41.000 --> 00:20:45.000
では、コンピューティングカーネルの実装に進みましょう。

00:20:45.000 --> 00:20:50.000
ここには、simd_sumを使用して並列削減を実装するコードがあります。

00:20:50.000 --> 00:20:55.000
SIMDグループの各スレッドは、入力配列から対応する要素を読み取ります。

00:20:55.000 --> 00:21:01.000
次に、simd_sum命令を使用して最初のsimdgroup_sumを計算します。

00:21:01.000 --> 00:21:08.000
この合計は、SIMDグループIDを使用してインデックス化されたスレッドグループメモリ内の配列に書き込まれます。

00:21:08.000 --> 00:21:13.000
スレッドグループメモリ内の配列にアクセスするには、バリアが必要であることに注意してください。

00:21:13.000 --> 00:21:21.000
各スレッドグループの最後のSIMDグループは、simd_sum命令を再度使用して最終的な合計を取得します。

00:21:21.000 --> 00:21:26.000
A14で導入した他の削減操作を見てみましょう。

00:21:26.000 --> 00:21:33.000
私たちはすでに、すべてのアクティブなレーンでXの値を合計するsimd_sumを見ました。

00:21:33.000 --> 00:21:36.000
では、simd_maxを見て、それを変数Xに適用しましょう。

00:21:36.000 --> 00:21:43.000
その後、すべてのレーンは、SIMDグループ内のすべてのスレッドで最大値（31）を取得します。

00:21:43.000 --> 00:21:51.000
同様に、simd_minは、すべてのアクティブレーンにわたって、この場合はたまたま0であるXの最小値を格納します。

00:21:51.000 --> 00:21:56.000
最後に、Xのすべての値を乗算するsimd_productがあります。

00:21:56.000 --> 00:22:02.000
変数の1つがたまたま0であるため、ブロードキャストされる最終製品は0です。

00:22:02.000 --> 00:22:08.000
これらの命令は、整数型と浮動小数点スカラーとベクトル型の両方で機能します。

00:22:08.000 --> 00:22:13.000
削減操作は、積分型のビット単位の操作でもサポートされています。

00:22:13.000 --> 00:22:20.000
各レーンには、ここに示すように、レーンIDを使用して製造されたビットフィールド値を持つようになりました。

00:22:20.000 --> 00:22:24.000
その後、変数Xでsimd_or命令を使用できます。

00:22:24.000 --> 00:22:30.000
すべてのアクティブレーンのXの値は一緒にor-edされ、変数Fにブロードキャストされます。

00:22:30.000 --> 00:22:35.000
この最終的な値は、この例ではたまたま0x1F3です。

00:22:35.000 --> 00:22:45.000
同様に、simd_xorはXのxor値を計算し、結果の値をブロードキャストし、0x0であることが判明します。

00:22:45.000 --> 00:22:51.000
最後に、SIMDグループ内のすべてのスレッドでXのすべての値を合計するsimd_andがあります。

00:22:51.000 --> 00:22:55.000
これは定数0x3であることが判明しました。

00:22:55.000 --> 00:23:02.000
これは、A14 GPUで利用可能な新しいSIMDスコープ縮小命令の概要でした。

00:23:02.000 --> 00:23:09.000
それでは、行列の乗算を大幅に改善する新しい一連のSIMDスコープ命令を見てみましょう。

00:23:09.000 --> 00:23:17.000
行列乗算は、GPUコンピューティングの非常に一般的な操作であり、多くの並列コンピューティングワークロードの基本的な構成要素です。

00:23:17.000 --> 00:23:25.000
たとえば、機械学習では、畳み込みと完全に接続されたニューロン層を計算するときに使用されます。

00:23:25.000 --> 00:23:30.000
線形代数は、方程式のシステムを表現し、解くために使用されます。

00:23:30.000 --> 00:23:39.000
A14は、大きな行列乗算を非常に効率的に実装することを可能にする、まったく新しい一連のSIMDスコープ命令を導入しています。

00:23:39.000 --> 00:23:45.000
以前に見た削減操作と同様に、これらはSIMDグループスコープ操作です。

00:23:45.000 --> 00:23:51.000
これらのビルディングブロックの上に、より大きく、より洗練された機能を簡単に構築できるようになりました。

00:23:51.000 --> 00:24:00.000
Metalシェーディング言語では、8×8と4×4の行列を表すSIMDグループスコープデータ構造があります。

00:24:00.000 --> 00:24:06.000
その後、SIMDグループスコープ付き行列操作のmultiplyまたはmultiply_accumulateバージョンを使用できます。

00:24:06.000 --> 00:24:14.000
これらの関数を使用して、スレッドグループ内の2つの16×16行列を掛ける例を見てみましょう。

00:24:14.000 --> 00:24:22.000
8×8のSIMDグループ行列演算を使用して、16×16の3番目のグループ行列乗算を構築します。

00:24:22.000 --> 00:24:26.000
まず、結果マトリックスを4つのSIMDグループに分割します。

00:24:26.000 --> 00:24:32.000
各SIMDグループは、結果の1つの8×8象限を計算する責任があります。

00:24:32.000 --> 00:24:35.000
次に、最初の入力行列を分割します。

00:24:35.000 --> 00:24:40.000
ここでは、行内の各SIMDグループが1つのブロック列を共有します。

00:24:40.000 --> 00:24:42.000
次に、2番目の入力を分割します。

00:24:42.000 --> 00:24:47.000
ここでは、列内の各SIMDグループが1つのブロック行を共有します。

00:24:47.000 --> 00:24:52.000
その後、8×8の結果の最初のセットから製品を蓄積します...

00:24:52.000 --> 00:24:53.000
そして2番目。

00:24:53.000 --> 00:24:57.000
では、これをメタルシェーディング言語で書く方法を見てみましょう。

00:24:57.000 --> 00:25:05.000
A14では、新しいSIMDグループ行列オブジェクトと乗算演算をMetalシェーディング言語に導入しました。

00:25:05.000 --> 00:25:11.000
これらの新しいプリミティブは、シェーダーでの行列乗算のパフォーマンスを大幅に向上させます。

00:25:11.000 --> 00:25:16.000
使いやすく、わずか数行のシェーダーコードで実行できます。

00:25:16.000 --> 00:25:23.000
ここでは、32ビットの浮動小数点形式のデータで8×8の行列を表す3つのオブジェクトを定義します。

00:25:23.000 --> 00:25:28.000
各入力のマトリックスと結果のマトリックスがあります。

00:25:28.000 --> 00:25:35.000
次に、結果の各象限にまたがる4つのSIMDグループを分割するために必要なアドレス算術を実行します。

00:25:35.000 --> 00:25:44.000
次に、各ソースマトリックスからいくつかの行列を蓄積し、適切な行と列を各SIMDグループにブロードキャストします。

00:25:44.000 --> 00:25:46.000
最後に、結果を保存します。

00:25:46.000 --> 00:25:52.000
これらの新しいプリミティブを使用して、より複雑なシェーダーを構築するのがいかに簡単かがわかります。

00:25:52.000 --> 00:26:04.000
メタルパフォーマンスシェーダーを使用している場合は、SIMDグループスコープマトリックス乗算の恩恵を受けて、行列乗算だけでなくCNN畳み込みも加速します。

00:26:04.000 --> 00:26:10.000
任意のサイズの行列乗算は、MPS行列乗算を使用して実行できます。

00:26:10.000 --> 00:26:16.000
ここでは、M行とN列で結果を計算するためにカーネルをエンコードしています。

00:26:16.000 --> 00:26:21.000
CNN畳み込みは、MPSCNNConvolutionを使用して実行できます。

00:26:21.000 --> 00:26:25.000
ここでは、画像のバッチに畳み込みカーネルをエンコードしています。

00:26:25.000 --> 00:26:33.000
これらのカーネルは両方とも、iOS 14で今年導入された新しいメタルパフォーマンスシェーダーグラフを使用して利用できます。

00:26:33.000 --> 00:26:40.000
MPS Graphを使用すると、これらの基本的なカーネルを使用して複雑な機械学習ネットワークを構築できます。

00:26:40.000 --> 00:26:46.000
例として、以前の行列乗算カーネルをグラフでどのように使用できるかを見てみましょう。

00:26:46.000 --> 00:26:50.000
ここでは、操作用の新しいグラフを初期化します。

00:26:50.000 --> 00:26:55.000
次に、2つの入力行列を表すノードを定義します。

00:26:55.000 --> 00:27:02.000
次に、行列乗算操作を使用して、入力から新しい結果ノードを構築します。

00:27:02.000 --> 00:27:04.000
最後に、グラフを実行します。

00:27:04.000 --> 00:27:13.000
MPSカーネルとグラフ操作の使用方法の詳細については、以前に利用可能なWWDCプレゼンテーションを参照してください。

00:27:13.000 --> 00:27:23.000
前述のように、MPSはこれらの操作に自動的にA14を利用します。

00:27:23.000 --> 00:27:30.000
ここでは、A13に対するA14の一般的な行列乗算のスループットの向上を見ることができます。

00:27:30.000 --> 00:27:38.000
A14では、新しいSIMDグループ行列乗算操作を使用して、平均パフォーマンスが37%向上します。

00:27:38.000 --> 00:27:45.000
A14のCNN畳み込みは、A13から平均36%の改善を示しています。

00:27:45.000 --> 00:27:54.000
そして、Inception V3のような完全な機械学習ネットワークのトレーニングを見ると、A14は22%向上します。

00:27:54.000 --> 00:27:58.000
これにより、SIMDグループスコープ行列の乗算が終了します。

00:27:58.000 --> 00:28:03.000
A14の新しいメタル機能を要約しましょう。

00:28:03.000 --> 00:28:11.000
バリセントリック座標とプリミティブIDは、可視性バッファレンダリングを含む新しい遅延レンダリング技術を可能にします。

00:28:11.000 --> 00:28:16.000
テクスチャアトラスを使用する際に便利な新しいテクスチャアドレッシングモード。

00:28:16.000 --> 00:28:22.000
スレッド間のより良いコミュニケーションを可能にするSIMDグループスコープ縮小命令。

00:28:22.000 --> 00:28:30.000
また、SIMDグループスコープ行列乗算命令を使用して、コンピューティングと機械学習のパフォーマンスを改善しました。

00:28:30.000 --> 00:28:44.000
そして最後に、A14上のMetalは、多くのアーキテクチャの改善を活用し、改善されたロスレス圧縮、より速く、より効率的なローカルメモリ、より良いGPU駆動パイプラインで帯域幅を節約します。

00:28:44.000 --> 23:59:59.000
ご覧いただきありがとうございます。

