WEBVTT

00:00:01.000 --> 00:00:05.000
デビッド・ウェンドランド:皆さん、こんにちは、私はApp Storeの商業技術提唱者であるデビッド・ウェンドランドです。

00:00:05.000 --> 00:00:10.000
私は今日、バーチャルでここにいて、チーム全体が取り組んできたことを共有できることに興奮しています。

00:00:10.000 --> 00:00:15.000
始める前に、クパチーノを拠点とする同僚に自己紹介をしてもらいたいです。

00:00:15.000 --> 00:00:21.000
Manjeet Chawla:こんにちは、私の名前はManjeet Chawlaで、App Storeのテクニカルプログラムマネージャーです。

00:00:21.000 --> 00:00:23.000
ジョー・マニ:こんにちは、私はジョーです。

00:00:23.000 --> 00:00:26.000
私はApp Storeのプログラムマネージャーです。

00:00:26.000 --> 00:00:34.000
David: 今日、私たち3人は「StoreKit 2とApp Store Server APIで顧客をサポートする」というタイトルの3部構成のシリーズを紹介します。

00:00:34.000 --> 00:00:44.000
StoreKit 2フレームワークとApp Store Server APIの機能が、アプリ内購入、カスタマーサポート、払い戻しの処理をどのように改善できるかに焦点を当てます。

00:00:44.000 --> 00:00:52.000
これらの3つの部分は、アプリとカスタマーエクスペリエンスの強化を計画する際に考慮すべき洞察、アプローチ、および利点を提供することを願っています。

00:00:52.000 --> 00:00:59.000
秋の発売の概要と、クライアントからサーバー、サンドボックスまでの新機能から始めて、アプリ内購入に着手します。

00:00:59.000 --> 00:01:07.000
そして、これらのアップデートを統合する際に、戦略を立て、ロードマップに優先順位を付けるのに役立ついくつかの実装アプローチについて説明します。

00:01:07.000 --> 00:01:09.000
新しいことから始めましょう。 

00:01:09.000 --> 00:01:18.000
iOS 15では、スタートに戻り、StoreKit 2でクライアントの実装を簡素化するために、まったく新しく改良されたフレームワークを作成しました。

00:01:18.000 --> 00:01:27.000
これにより、デバイス上の機能が改善され、ステータス情報が改善され、トランザクションはセキュリティを強化するためにJWS形式が使用されるようになりました。

00:01:27.000 --> 00:01:35.000
さらに、アプリ内で直接顧客により多くのサービスを提供するために、3つのスタンドアロン機能を導入しました。

00:01:35.000 --> 00:01:42.000
サーバー側から、バージョン2の起動により、既存のApp Storeサーバー通知を大幅に更新しました。

00:01:42.000 --> 00:01:49.000
これにより、サポートされている購入イベントの数が大幅に拡大し、新しいJWS形式も使用されます。

00:01:49.000 --> 00:01:53.000
最後に、App Store Server APIで一連の機能をリリースしました。

00:01:53.000 --> 00:02:02.000
顧客の購入履歴の取得や、加入者の現在のサブスクリプションステータスの提供など、さまざまな機能をサポートするエンドポイントの配列があります。

00:02:02.000 --> 00:02:10.000
他の能力は、私の同僚であるManjeetとJoeがまもなくカバーするさまざまな顧客管理シナリオをカバーしています。

00:02:10.000 --> 00:02:15.000
今年の広範なアップデートリストは、StoreKitでのアプリ内購入への継続的な投資を示しています。

00:02:15.000 --> 00:02:24.000
全体として、これらはセキュリティを改善し、複雑さを軽減し、SandboxとXcodeでのアプリ内購入のテストを容易にします。

00:02:24.000 --> 00:02:37.000
Touch IDやFace IDなどの機能を備えたプラットフォームを見ると、安全なバイオメトリクスと摩擦のない認証を使用して、顧客が15億台以上のデバイスで安全かつ便利に購入できるようにします。

00:02:37.000 --> 00:02:44.000
App Storeには現在、40以上の言語で175の店舗で毎週6億人の訪問者がいます。

00:02:44.000 --> 00:02:57.000
地域ごとに価格帯を調整でき、来年はサポートされている価格帯の数を500以上に拡大し、より多くの価格オプションを提供し、通貨と市場ごとにカスタマイズされた価格ポイントを提供します。

00:02:57.000 --> 00:03:08.000
195の支払い方法で45の通貨がサポートされているため、お客様が好みの支払い方法とそれらを積み重ねる機能をより便利にするために取り組んでいます。

00:03:08.000 --> 00:03:18.000
これらのプラットフォームの改善を続けていますが、StoreKit 2を掘り下げて、オリジナルのStoreKitよりもその利点と重要な機能強化を強調したいと思います。

00:03:18.000 --> 00:03:27.000
StoreKit 2の主な機能を見ると、すべての顧客のデバイスで新しいアプリ内購入トランザクションを自動的に同期します。

00:03:27.000 --> 00:03:31.000
これにより、アプリで一貫性のある信頼性の高いエクスペリエンスを提供できます。

00:03:31.000 --> 00:03:40.000
このフレームワークは、デバイス上の購入検証をサポートし、以前のフレームワークと比較して合理化されているため、サーバーサイドの購入検証に完全に依存する必要はありません。

00:03:40.000 --> 00:03:46.000
すべてのトランザクションはJWSを使用して署名されるため、各トランザクションの真正性を確認できます。

00:03:46.000 --> 00:03:55.000
また、このフレームワークは、デバイス上でエンタイトルメントステータス情報を提供するため、複雑さが軽減され、適切なエンタイトルメントアクセスを確保できます。

00:03:55.000 --> 00:04:04.000
そして、iOS 15の新機能はappAccountTokenで、購入を開始したアプリ内アカウントを設定し、完了したトランザクションで返品することができます。

00:04:04.000 --> 00:04:10.000
さらに、オリジナルのStoreKitフレームワークと一緒に動作できるユニークなスタンドアロンのStoreKit 2機能がいくつかあります。

00:04:10.000 --> 00:04:21.000
したがって、iOS 15でオリジナルのStoreKitを使用している今日のアプリは、これらの独立したStoreKit 2機能を追加して、通常はアプリの外で発生するアプリ内体験を提供することもできます。

00:04:21.000 --> 00:04:23.000
1つ目はshowManageSubscriptionsです。

00:04:23.000 --> 00:04:27.000
これにより、加入者はアプリを離れることなくサブスクリプションを管理できます。

00:04:27.000 --> 00:04:36.000
次に、RefundRequestを開始し、アプリ内から払い戻しリクエストを開始できる顧客に取引を提示することができます。

00:04:36.000 --> 00:04:42.000
そして、これにより、サンドボックスでは、保留中から承認または拒否への払い戻しをテストしてシミュレートすることができます。

00:04:42.000 --> 00:04:48.000
また、顧客の入門オファーの適格性を簡単に確認できるようにする機能も導入しました。

00:04:48.000 --> 00:04:56.000
無料トライアルのようなオファーをマーチャンダイジングする際に、購入が完了すると、実際にオファーが与えられることを保証したいので、これは重要です。

00:04:56.000 --> 00:05:04.000
StoreKit 2では、このチェックはisEligibleForIntroOfferメソッドですばやく実行でき、サブスクリプショングループIDを渡すことができます。

00:05:04.000 --> 00:05:11.000
これは、そのサブスクリプショングループ内のサブスクリプションに対して何らかの種類の入門オファーを消費したことがあるかどうかをチェックします。

00:05:11.000 --> 00:05:17.000
さらに、StoreKitによって返品された場合にのみ、入門オファーをマーチャンダイジングする必要があります。

00:05:17.000 --> 00:05:23.000
それはProduct.SubscriptionOfferから来ており、可能であれば紹介オファーの詳細を返します。

00:05:23.000 --> 00:05:29.000
そうでない場合は、StoreKitによって返却されないため、利用できないオファーをマーチャンダイジングできなくなります。

00:05:29.000 --> 00:05:38.000
したがって、これはハードコードされていないことが重要であり、代わりに、アプリはApp Store Connectで設定された開始日と終了日を使用するStoreKitを活用します。

00:05:38.000 --> 00:05:47.000
今、私はサーバー側を移動し、顧客との相互作用なしにサーバーからサーバーへのリクエストが行われるApp Store Server APIの機能について議論したいと思います。

00:05:47.000 --> 00:05:48.000
サブスクリプションのステータスから始めます。

00:05:48.000 --> 00:05:52.000
これは、アプリでの顧客のサブスクリプションの状態を提供します。

00:05:52.000 --> 00:06:01.000
また、複数のサブスクリプションサービスがある場合は、サブスクリプションごとに資格状態があり、それぞれが一意の元のトランザクションIDで表されます。

00:06:01.000 --> 00:06:17.000
サブスクリプションステータスの大部分は、各サブスクリプションの現在のJWS署名トランザクションのみを返すため、サーバー上のロジックが顧客のトランザクション履歴を解析し、現在のトランザクションまたはどの製品に資格を与えるかを判断する必要はありません。

00:06:17.000 --> 00:06:30.000
マルチプラットフォームサービスプロバイダーの場合、このサービスを使用して、アプリを実行せずに、サーバーからサーバー間でいつでも現在のステータスを取得できます。必要なのは、顧客の元のトランザクションIDだけです。アプリの領収書はもうありません。

00:06:30.000 --> 00:06:33.000
推奨するベストプラクティスをいくつか紹介します。

00:06:33.000 --> 00:06:40.000
購入またはトランザクションを復元するたびに、常に一意の元のトランザクションIDをデータベースに保存することが重要です。

00:06:40.000 --> 00:06:50.000
この値は、最初の購入から更新、請求の問題と回復、またはアップグレードとダウングレードまでのサブスクリプションライフサイクルを追跡するために不可欠な各サブスクリプションの提供を表します。

00:06:50.000 --> 00:06:56.000
このIDは、サーバー通知とともに、クライアントとサーバーAPIで使用されます。

00:06:56.000 --> 00:07:01.000
最後に、サブスクリプションステータスは、セキュリティのベストプラクティスとしてサーバーからサーバーへのみ使用する必要があります。

00:07:01.000 --> 00:07:07.000
アプリから直接ステータスを確認する必要がある場合は、StoreKit 2フレームワークに解決策があります。

00:07:07.000 --> 00:07:16.000
サーバーAPIの次の機能は、アプリ内購入履歴です。ここでは、サーバー間、顧客の取引の完全かつ最新の履歴を取得できます。

00:07:16.000 --> 00:07:29.000
履歴には、すべての非消耗品、非更新サブスクリプション、自動更新サブスクリプション、および未完成の消耗品購入が含まれ、すべてが安全で、JWSが署名したトランザクションになります。

00:07:29.000 --> 00:07:43.000
現在、トランザクションの履歴とすべての元のトランザクションIDを持つことは、払い戻し要求を開始するために顧客が選択できるトランザクションを表面化する必要があるため、beginRefundRequest APIを実装する際に役立ちます。

00:07:43.000 --> 00:07:54.000
元のStoreKitを使用したアプリでの非サブスクリプションアプリ内購入の場合、verifyReceiptから離れ、このAPIを使用して成功した購入を検証したり、停止が発生した場合に更新を確認したりできます。

00:07:54.000 --> 00:08:02.000
ベストプラクティスとして、一部の顧客は多くの購入を行う可能性があるため、応答には一度に最大20件のトランザクションが含まれます。

00:08:02.000 --> 00:08:06.000
追加のトランザクションがある場合は、必ずhasMoreフィールドを使用してください。

00:08:06.000 --> 00:08:12.000
Trueの場合、その応答とその後のリクエストでリビジョントークンを使用して、トランザクションの次のページを取得します。

00:08:12.000 --> 00:08:17.000
hasMoreフィールドがfalseを返すまで繰り返し、将来のためにそのリビジョントークンを保存します。

00:08:17.000 --> 00:08:26.000
これにより、記録されたリビジョントークンを使用して顧客の最新のトランザクションをすばやく取得し、再びページ分割する必要はありません。

00:08:26.000 --> 00:08:32.000
もう1つの重要なベストプラクティスは、製品やサービスが配信された後にfinishTransactionを使用することです。

00:08:32.000 --> 00:08:38.000
未完成の取引はキューに残り、アプリが顧客に配信する必要がある購入を追跡するのに役立ちます。

00:08:38.000 --> 00:08:42.000
これは、デバイス上で中断があった場合に重要です。

00:08:42.000 --> 00:08:53.000
返金または取り消された取引に関する最終的な推奨事項は、これらの更新を可能な限り迅速かつ効率的に受信したい場合は、バージョン2のサーバー通知を見ることです。

00:08:53.000 --> 00:08:57.000
これらは、当社のAPIをポーリングするよりもはるかに効率的です。

00:08:57.000 --> 00:08:59.000
では、サーバーの通知を見てください。

00:08:59.000 --> 00:09:05.000
これらは、主要な購入イベントとステータスの変更のために、ほぼリアルタイムでサーバーに直接送信されます。

00:09:05.000 --> 00:09:14.000
今年は、バージョン2でこの機能を劇的に洗練し、より効果的で使いやすく、より粒度を提供します。

00:09:14.000 --> 00:09:18.000
サポートされているイベントの数を2倍にし、その合計を28のユニークなイベントにしました!

00:09:18.000 --> 00:09:25.000
バージョン2では、イベントごとに1つの通知のみを送信するため、受信時に特定のアクションを実行できます。

00:09:25.000 --> 00:09:31.000
また、これらの通知は、アプリ内購入のためにファミリー共有を通じてアクセスできる家族にも適用されます。

00:09:31.000 --> 00:09:40.000
また、通知の配信に失敗した場合は、停電を考慮して、7日間で最大5回再試行します。

00:09:40.000 --> 00:09:46.000
そしてもちろん、バージョン2はサンドボックスで利用できるので、テスト環境で安全に開発できます。

00:09:46.000 --> 00:09:55.000
いくつかのベストプラクティスでは、これらの通知を受信するときは、正常に受信されたときにHTTP 200応答コードで応答することが重要です。

00:09:55.000 --> 00:10:01.000
これは、お客様が通知を受け取り、再送信する必要がないことを示しています。

00:10:01.000 --> 00:10:07.000
サーバーがエラーを返したり、応答しない場合、App Storeは同じ通知ペイロードを再送信します。

00:10:07.000 --> 00:10:13.000
各通知にはsignedDateがあります。元の通知がいつ送信されたかを正確に知ることができます。

00:10:13.000 --> 00:10:23.000
また、JWSが署名したトランザクション情報を使用して、受信した通知の真正性を検証できるため、これらがApp Storeによって署名されたことを確信できます。

00:10:23.000 --> 00:10:29.000
また、サンドボックスや本番イベントに一意のサーバーURLを提供する新しい機能を活用してください。

00:10:29.000 --> 00:10:33.000
そして、最終的なベストプラクティスとして、通知の更新をすぐに適用します。

00:10:33.000 --> 00:10:37.000
一部のイベントは、アップグレードや払い戻しなど、時間に敏感です。

00:10:37.000 --> 00:10:41.000
したがって、これらをほぼリアルタイムで処理することは有益です。

00:10:41.000 --> 00:10:47.000
そして、あなたに説明する最後のアップデートは、サンドボックスでのアプリ内購入のテストに役立つApp Store Connectのアップデートです。

00:10:47.000 --> 00:10:52.000
これらの機能は、サンドボックステスターの下の[ユーザーとアクセス]タブでアクセスできます。

00:10:52.000 --> 00:10:58.000
すでにご存知かもしれませんが、今日のサンドボックスでは、サブスクリプションはテストをサポートするために加速された速度で更新されます。

00:10:58.000 --> 00:11:06.000
これで、XcodeでのStoreKitテストと同じように、Sandbox Apple IDごとに更新率を遅くまたは加速する機能を追加しました。

00:11:06.000 --> 00:11:12.000
これは、更新の間にアクションを実行するためにより多くの時間が必要なシナリオに役立つはずです。

00:11:12.000 --> 00:11:18.000
さまざまなストアフロントでのテストを支援するために、いつでもSandbox Apple IDのストアフロントを変更できるようになりました。

00:11:18.000 --> 00:11:33.000
また、単一のサンドボックスApple IDの使用をさらに拡大するために、自動更新サブスクリプションと非消耗品の購入履歴を消去できるようになりました。たとえば、コンテンツを購入したり、紹介オファーを繰り返し引き換えたりすることができます。

00:11:33.000 --> 00:11:44.000
StoreKit 2とサーバーAPIの利点とベストプラクティスのいくつかを取り上げたので、これらの機能と能力をアプリやサーバーに統合する準備をする際に考慮すべきいくつかのアプローチを確認しましょう。

00:11:44.000 --> 00:11:51.000
アプリ内購入について考えるとき、私たちは主に顧客に購入の資格を付与し、ステータスの変更を処理することを考えます。

00:11:51.000 --> 00:12:02.000
これを行うには、サーバーバックエンドなしですべてをローカルで行うオンデバイスアプローチを選択するか、サーバーが真実の源であるサーブツーサーバーAPIを活用するかを選択する必要があります。

00:12:02.000 --> 00:12:03.000
デバイス上から始めましょう。

00:12:03.000 --> 00:12:12.000
これは、StoreKit 2フレームワークがアプリにアプリ内購入を完全に管理し、サーバーを必要とせずにデバイス上のすべてのステータス変更機能を提供する場所です。

00:12:12.000 --> 00:12:17.000
これは、中小企業や既存のサーバーバックエンドを持たない企業にとって非常に役立ちます。

00:12:17.000 --> 00:12:23.000
これを行うには、購入フローをサポートするために、StoreKit 2のこれら3つのコア機能部分から始めます。

00:12:23.000 --> 00:12:30.000
アプリは、製品を使用して利用可能な製品とその詳細を取得し、アプリ内のマーチャンダイジングを推進します。

00:12:30.000 --> 00:12:34.000
これにより、常に正確で、App Storeと同期しています。

00:12:34.000 --> 00:12:45.000
そして今、StoreKit 2では、VerificationResultとPurchaseResultがあり、これらは一緒に購入または復元されたトランザクションが成功した後にトランザクションの真正性を検証するために使用されます。

00:12:45.000 --> 00:12:52.000
StoreKit 2フレームワークのもう1つの重要な利点は、あらゆるトランザクションでアプリを最新の状態に保つことができることです。

00:12:52.000 --> 00:13:00.000
顧客は複数のデバイスを持っている可能性があり、Transaction.updatesを使用すると、トランザクションが開始されたデバイスに関係なく、アプリは同期されます。

00:13:00.000 --> 00:13:16.000
currentEntitlementメソッドを使用すると、アプリは顧客の購入の即時ステータスをすばやく取得できるため、最新のトランザクションの詳細を持っているので、ログインやリストア購入の実行を必要とせずに、それらの製品を顧客にすぐに付与できます。

00:13:16.000 --> 00:13:26.000
最後に、製品自体だけでなく、現在の加入者のステータスと今後の更新期間について、デバイス上で自動更新サブスクリプション情報を取得することがいかに重要であるかを理解しています。

00:13:26.000 --> 00:13:29.000
そのために、Product.SubscriptionInfoがあります。

00:13:29.000 --> 00:13:40.000
したがって、先ほど説明したこれらの6つのコア機能を使用すると、iOS 15のStoreKit 2を活用し、サーバーへの依存度を削減または排除して、最高の顧客体験を提供できます。

00:13:40.000 --> 00:13:55.000
さて、サーバー間アーキテクチャについて考えるとき、これは顧客がサービスに確実にアクセスすることを期待するマルチプラットフォームまたはマルチアプリサービスにとって重要であり、システムはいつでもリアルタイムで購入状況を最新の状態に保つ必要があります。

00:13:55.000 --> 00:14:04.000
通常、この設定では、サーバーを真実のソースとして、24時間365日オンラインで、いつでもApp Storeで更新を受信して確認できます。

00:14:04.000 --> 00:14:07.000
しかし、あなたのアプリの観点からこの流れを見てみましょう。

00:14:07.000 --> 00:14:17.000
ここでは、お客様のデバイスがあり、アプリが元のStoreKitフレームワークを使用して購入を開始し、購入検証にApp Store verifyReceiptサーバーを使用して実行されていると仮定しましょう。

00:14:17.000 --> 00:14:26.000
これは、購入または復元イベント後に、アプリがBase64でエンコードされたアプリレシートをサーバーに送信し、verifyReceiptサーバーに送信されることを意味します。

00:14:26.000 --> 00:14:39.000
App Storeは顧客のトランザクションで応答します。現在、サーバーはこれらのトランザクションを解析して、ステータスと、サーバー側またはアプリ内でどのようなアクションを実行する必要があるかを評価および決定する必要があります。

00:14:39.000 --> 00:14:41.000
さて、あなたは自分自身にこの質問をしたかもしれません。

00:14:41.000 --> 00:14:48.000
良いニュースは、App Store Server APIは、StoreKit 2フレームワーク全体を採用するアプリに依存していません。

00:14:48.000 --> 00:14:56.000
これは、アプリがオリジナルのStoreKitを使用し続けている間、App Store Server APIで利用可能な新機能をすぐに利用できることを意味します。

00:14:56.000 --> 00:14:59.000
これを行う方法を見ていきましょう。

00:14:59.000 --> 00:15:02.000
同じデザインでは、2つの主要な変更を加える必要があります。

00:15:02.000 --> 00:15:06.000
まず、元のトランザクションIDを取得するためにアプリを更新します。

00:15:06.000 --> 00:15:10.000
次に、App Store Server APIを使用するようにサーバーを更新します。

00:15:10.000 --> 00:15:18.000
これら2つの変更により、アプリはオリジナルのStoreKitまたはStoreKit 2を使用できるため、どのiOSバージョンでも最新のアプリバージョンを簡単にサポートできます。

00:15:18.000 --> 00:15:26.000
最初の変更を行い、今後original_transaction_IDの使用を開始するには、Base64アプリのレシートを取得するロジックを置き換えます。

00:15:26.000 --> 00:15:30.000
これを行うには、アプリのレシートURLメソッドを使用していた可能性があります。

00:15:30.000 --> 00:15:35.000
さあ、自動更新サブスクリプションのためにこのプロパティに置き換えてください。

00:15:35.000 --> 00:15:39.000
また、他のアプリ内購入タイプでは、この同様のプロパティを使用します。

00:15:39.000 --> 00:15:43.000
それでは、App Store Server APIを使用するようにサーバーを更新しましょう。

00:15:43.000 --> 00:15:47.000
/verifyReceiptから/Historyまたは/SubscriptionStatus URLに変更します。

00:15:47.000 --> 00:15:53.000
リクエストは承認にJWTを使用し、今後は元のトランザクションIDを使用します。

00:15:53.000 --> 00:16:04.000
これらの変更が完了すると、サーバーで維持するエンタイトルメントロジックがなくなり、安全なJWS署名付きトランザクションを使用でき、アプリの領収書を保存する必要がなくなりました。

00:16:04.000 --> 00:16:12.000
したがって、アプリが古いバージョンのiOSをサポートしている場合、これはApp Store Server APIが提供するものを利用するためのパスを提供します。

00:16:12.000 --> 00:16:18.000
先ほど、StoreKit 2とサーバーAPIがサブスクリプション状態の決定をどのように処理するかについて言及しました。

00:16:18.000 --> 00:16:24.000
ベストプラクティスとして、アプリは常にアプリの起動時に加入者の状態を決定する必要があります。

00:16:24.000 --> 00:16:28.000
状態が決まったら、ローカルに保存し、必要に応じて更新できます。

00:16:28.000 --> 00:16:35.000
私たちが返すこれらの5つの州と、それぞれについて取るべき行動と、検討する機会を簡単に検討したいと思います。

00:16:35.000 --> 00:16:42.000
さて、新しい顧客はこれらの状態のいずれかを持っていないことに留意すべきであり、それはあなたのアプリも管理する必要がある状態です。

00:16:42.000 --> 00:16:48.000
アクティブ状態から始めて、これは、有効期限まで顧客にサービスを提供する必要があることを意味します。

00:16:48.000 --> 00:16:55.000
複数のレベルのサービスを提供する場合、1つの機会は、プロモーションオファーを使用してアプリ内でアップグレードオファーを表示することです。

00:16:55.000 --> 00:17:00.000
このようなオファーは、過去のサブスクリプション履歴に基づいて顧客に合わせて調整する必要があることに注意してください。

00:17:00.000 --> 00:17:04.000
これで、サブスクリプションが完全に解約されると、期限切れの状態になります。

00:17:04.000 --> 00:17:09.000
サービスを提供する必要はなく、現在のサブスクリプションの提供を商品化することができます。

00:17:09.000 --> 00:17:15.000
オプションで、プロモーションオファーまたはサブスクリプションオファーコードを活用して、ウィンバックオファーを提示することができます。

00:17:15.000 --> 00:17:24.000
有効期限から60日以内に再購読した場合、既存の未払いの有給サービス日数は85%の収益率に向けて再開されます。

00:17:24.000 --> 00:17:26.000
次は請求の再試行期間です。

00:17:26.000 --> 00:17:32.000
私たちは皆、時々請求の問題を経験します。クレジットカードが期限切れになるか、ストアクレジットが消費される可能性があります。

00:17:32.000 --> 00:17:39.000
これらのサブスクリプションは自動更新されると予想されていましたが、支払い方法の問題により、請求再試行期間と呼ばれるものに陥りました。

00:17:39.000 --> 00:17:47.000
サブスクリプションの有効期限が切れており、サービスを提供する必要はありませんが、お客様は再購読する必要はありません。請求の問題を解決するだけです。

00:17:47.000 --> 00:17:55.000
開発者のアクションなしで、さまざまな顧客コミュニケーションを通じて、最大60日間のサブスクリプションの再試行と回復を自動的に再試行します。

00:17:55.000 --> 00:18:05.000
しかし、アプリ内メッセージングを使用すると、顧客に請求の問題を直接警告し、顧客を支払い情報ページに深くリンクして解決できる貴重な行動を促すことができます。

00:18:05.000 --> 00:18:14.000
次は猶予期間で、請求の再試行に関連していますが、App Store ConnectでApp Store請求猶予期間をオプトインした場合にのみ、購読者に適用されます。

00:18:14.000 --> 00:18:20.000
この州では、猶予期間が満了するまで、中断することなくサービスを提供し続けます。

00:18:20.000 --> 00:18:25.000
猶予期間中に加入者を回復した場合、加入者は元の請求サイクルを保持します。

00:18:25.000 --> 00:18:31.000
したがって、サービスの中断はなく、プロバイダーは失われた請求可能な日数を回避します。

00:18:31.000 --> 00:18:37.000
請求の再試行と同様に、同じアプリ内メッセージングも提供して、請求の問題を警告したいと考えています。

00:18:37.000 --> 00:18:42.000
最後に、取り消された状態が表示された場合、これは家族で共有可能なサブスクリプションに適用されます。

00:18:42.000 --> 00:18:51.000
これらの家族はもはやそのサービスやコンテンツを受ける権利がないため、アクセスを取り消すことができ、これらの顧客を再獲得するためのオファーを商品化することができます。

00:18:51.000 --> 00:18:59.000
最後の部分では、App Storeサーバー通知を使用する際に考慮すべきいくつかの実装アプローチについて掘り下げたいと思います。

00:18:59.000 --> 00:19:05.000
サポートされているこれらすべてのイベントを見ると、かなりの数があり、あなたのビジネスに適用される場合と適用されない場合があることがわかります。

00:19:05.000 --> 00:19:09.000
多くはサブスクリプションライフサイクルの一部ですが、他のものはすべてのアプリ内購入タイプに適用されます。

00:19:09.000 --> 00:19:18.000
サブスクリプションを提供していない場合は、サブスクリプションがより複雑であり、単に適用されないイベントの多くを回避できるため、実装アプローチはより簡単です。

00:19:18.000 --> 00:19:22.000
しかし、あなたが検討するために、実装のこれらの異なる段階を見直しましょう。

00:19:22.000 --> 00:19:28.000
私たちはそれを3つに分割しました：始めること、ライフサイクルをサポートすること、そして洞察に基づいて行動を起こすこと。

00:19:28.000 --> 00:19:37.000
バージョン2を採用する場合、この開始段階は、ビジネスモデルに関係なく、またはバージョン1の通知を採用しているかどうかにかかわらず、すべての人に適用されます。

00:19:37.000 --> 00:19:41.000
最初のステップは、App Store Connectでバージョン2を有効にすることです。

00:19:41.000 --> 00:19:45.000
この機能は「App Store Server Notifications」というタイトルのApp Informationの下にあります。

00:19:45.000 --> 00:19:50.000
そして、秋のアップデートでは、サンドボックスとプロダクション専用のURLを選択できるようになりました。

00:19:50.000 --> 00:19:54.000
そのURLを追加して、受信するバージョンを選択できます。

00:19:54.000 --> 00:20:03.000
また、すでにバージョン1を受け取っている場合は、本番環境で有効にする前に開発を可能にするために、サンドボックスでバージョン2のみを有効にすることをお勧めします。

00:20:03.000 --> 00:20:11.000
バージョン2を有効にしたので、優先順位付けを見たいので、ビジネスモデルと使用状況に基づいて、最初にサポートする通知を評価します。

00:20:11.000 --> 00:20:18.000
助けるために、あなたのビジネスとロードマップに最も当てはまる重要な大量のイベントに焦点を当てる必要があります。

00:20:18.000 --> 00:20:21.000
すべてのアプリ内購入タイプに適用されるイベントの1つは、払い戻しです。

00:20:21.000 --> 00:20:27.000
顧客に返金される取引ごとに、単一の払い戻し通知が届きます。

00:20:27.000 --> 00:20:31.000
これらのイベントをどのように処理するかは、ポリシーとビジネスモデル次第です。

00:20:31.000 --> 00:20:43.000
現在、サブスクリプションベースのビジネスの場合、これらの4つの通知は、最初の購入または再購読から更新の成功、または失敗、有効期限まで、サブスクリプションジャーニーの主要なイベントに適用されます。

00:20:43.000 --> 00:20:51.000
これら5つの通知タイプに対して行動を起こすことを優先することで、受信できるイベントの大部分をサポートできることを意味します。

00:20:51.000 --> 00:20:56.000
その第1段階は強固な基盤を提供し、リターンを最大化することができました。

00:20:56.000 --> 00:21:01.000
これで、この次の段階ですべての通知タイプのサポートを完了することができます。

00:21:01.000 --> 00:21:07.000
サブスクリプションベースの通知はいくつか残っていますが、他の通知は機能の採用に依存しています。

00:21:07.000 --> 00:21:08.000
復習しましょう。

00:21:08.000 --> 00:21:13.000
これら2つのタイプは、すべてのサブスクリプションベースのアプリ、DID_CHANGE_RENEWAL_STATUSとreferenceに適用されます。

00:21:13.000 --> 00:21:17.000
これらは、サービスレベルをキャンセルまたは変更する顧客を特定するために重要です。

00:21:17.000 --> 00:21:21.000
これらの残りのタイプを考慮すると、これらはあなたの使用状況に依存します。

00:21:21.000 --> 00:21:26.000
したがって、App Store Connectで請求猶予期間を有効にしている場合は、GRACE_PERIOD_EXPIREDが適用されます。

00:21:26.000 --> 00:21:32.000
RENEWAL_EXTENDEDは、App Store Server APIで加入者の更新を延長した場合に送信されます。

00:21:32.000 --> 00:21:38.000
また、アプリ内購入でファミリー共有が有効になっている場合、REVOKEが適用されます。

00:21:38.000 --> 00:21:44.000
OFFER REDEEMEDは、サブスクリプションオファーコードまたはプロモーションオファーを使用する場合に適用されます。

00:21:44.000 --> 00:21:49.000
また、自動更新サブスクリプションの価格が引き上げられた場合、PRICE_INCREASEが送信されます。

00:21:49.000 --> 00:21:52.000
そして、REFUND_DECLINEDとCONSUMPTION_REQUESTがあります。

00:21:52.000 --> 00:21:57.000
ジョーは、払い戻しの処理に関する彼の部分でこれらを詳細にカバーします。

00:21:57.000 --> 00:22:01.000
最後に、洞察フェーズのアクションに進むことができます。

00:22:01.000 --> 00:22:06.000
この時点で、あなたは今、あなたのビジネスに関連するすべてのイベントを受け取り、行動を起こしています。

00:22:06.000 --> 00:22:17.000
これにより、サービスがすべての顧客サブスクリプションの現在のステータス、または購入した消耗品、非消耗品、または非更新サブスクリプションへのアクセス変更を確実に知ることができます。

00:22:17.000 --> 00:22:32.000
サブスクリプションでは、次の通知は非常に特定の状態の顧客を識別し、ビジネスが特定の積極的な行動を取ることができ、加入者を特定し、インテリジェントに関与し、維持し、取り戻すことができます。

00:22:32.000 --> 00:22:44.000
ここでは、顧客と関わる機会のウィンドウで重要なイベントを特定したり、プロアクティブなアプリ内メッセージングを提供したり、カスタマイズされたサブスクリプションオファーを提示したりできる通知タイプの例をいくつか紹介します。

00:22:44.000 --> 00:22:48.000
1つの例を見てみましょう。サブスクリプションをキャンセルする顧客です。

00:22:48.000 --> 00:22:54.000
このシナリオでは、加入者が11月25日に毎月のサブスクリプションを購入したとしましょう。

00:22:54.000 --> 00:22:59.000
その後、12月5日、加入者は現在の期間の残り20日でキャンセルすることを選択しました。

00:22:59.000 --> 00:23:06.000
これは、加入者がキャンセルしてから、サブスクリプションが期限切れになり、自発的に解約されるまでの保存期間です。

00:23:06.000 --> 00:23:21.000
そのキャンセルアクションが発生すると、自動更新状態はfalseに設定され、すぐにApp StoreがAUTO_RENEW_DISABLEDのサブタイプでDID_CHANGE_RENEWAL_STATUS通知を送信し、保存期間の開始をリアルタイムで警告します。

00:23:21.000 --> 00:23:28.000
この機会の窓により、サービスは期限が切れる前にカスタマイズされたアプリ内メッセージングや商品保存オファーを提示することができます。

00:23:28.000 --> 00:23:34.000
このようなオファーが調整され、各顧客コホートの適格基準を持つことが重要です。

00:23:34.000 --> 00:23:36.000
これで私の部分が終わります。

00:23:36.000 --> 00:23:39.000
では、同僚のマンジートを紹介したいと思います。

00:23:39.000 --> 00:23:45.000
マンジート:ありがとう、デイブ!私の名前はManjeet Chawlaで、App Storeのテクニカルプログラムマネージャーです。

00:23:45.000 --> 00:23:53.000
さて、Daveは、StoreKit 2とApp Store Server APIを使用してアプリ内購入を改善する方法について話しました。

00:23:53.000 --> 00:23:58.000
では、カスタマーサポートの観点からまったく同じAPIを確認しましょう。

00:23:58.000 --> 00:24:08.000
顧客がアプリ内購入で今日直面する一般的なサポートシナリオと、これらのAPIをこれらのシナリオに活用するためのベストプラクティスについて話します。

00:24:08.000 --> 00:24:16.000
しかし、カスタマーサポートについて話す前に、サポートを提供することが全体的な顧客管理にどのように影響するかを理解しましょう。

00:24:16.000 --> 00:24:25.000
買収、分析、カスタマーサポート、さまざまなマーケティングコミュニケーションチャネルなど、さまざまなCRMツールやシステムに依存している可能性があります。

00:24:25.000 --> 00:24:34.000
また、サポートを提供することで、顧客を満足させ、製品とエンゲージメントを維持し、全体的な顧客関係と満足度を向上させます。

00:24:34.000 --> 00:24:43.000
今、私たちは顧客があなたに助けを求めていることを知っており、App Storeはサポートを提供し、問題を効率的に解決するためのツールを作成しました。

00:24:43.000 --> 00:24:53.000
そして今日は、検索注文IDから始めて、すべてのサポートチャネルでの問い合わせを支援する5つの新しいカスタマーサポートツールについて説明します。

00:24:53.000 --> 00:25:04.000
今日、顧客がアプリ内購入を行うと、Apple IDに領収書が送信され、アカウント設定での購入履歴を見ることで、いつでもこの領収書にアクセスすることもできます。

00:25:04.000 --> 00:25:18.000
そして今、顧客があなたに連絡すると、サポートチームはこの領収書の注文IDを顧客に尋ね、新しいApp Store Server APIを呼び出すために、注文IDを使用してその領収書の顧客のアプリ内購入を検索することができます。

00:25:18.000 --> 00:25:27.000
また、このAPIを使用して、領収書の真正性を検証し、その領収書内のトランザクションを顧客に関連付けることもできます。

00:25:27.000 --> 00:25:32.000
さらに、このAPIを使用して、購入内の問題を特定できます。

00:25:32.000 --> 00:25:46.000
たとえば、トランザクションにApp Storeによってすでに返金または取り消された購入が含まれている場合は、応答でrevocationDateとrevocationReasonを見て、払い戻しの詳細を得ることができます。

00:25:46.000 --> 00:25:54.000
そして、このAPIを実装すると、顧客がサポートのためにあなたに連絡したときに、注文IDの過去の購入を検索することができます。

00:25:54.000 --> 00:26:01.000
ベストプラクティスについては、すべてのアプリ内購入のoriginal_transaction_idを顧客アカウントデータベースに保存してください。

00:26:01.000 --> 00:26:10.000
また、顧客がサポートを求める連絡をすると、このAPIを使用して、アカウントデータベース内で顧客の購入を検索して関連付けることができます。

00:26:10.000 --> 00:26:21.000
このAPIを電話、電子メール、ウェブなどの既存のカスタマーサポートチャネルと統合して、顧客に一貫したサポート体験を提供することもできます。

00:26:21.000 --> 00:26:25.000
次に、払い戻しの検索について話しましょう。

00:26:25.000 --> 00:26:35.000
WWDC20では、App Storeは、顧客がアプリ内購入の払い戻しに成功したたびにサーバーに通知する払い戻し通知を導入しました。

00:26:35.000 --> 00:26:43.000
払い戻し検索は、顧客の返金されたすべての取引を検索できる、まったく新しいApp Store Server APIです。

00:26:43.000 --> 00:26:52.000
このAPIを使用すると、いつでも迅速かつ簡単に払い戻しを調べることで、サーバーの停止を処理したり、メンテナンスをスケジュールしたりできます。

00:26:52.000 --> 00:26:59.000
さらに、すべてのアプリ内購入タイプで、顧客の払い戻し履歴全体を特定できます。

00:26:59.000 --> 00:27:11.000
また、このAPIを使用して、払い戻しや疑わしい活動の急増を監視し、払い戻しにつながる可能性のあるコンテンツ配信の問題に対応することもできます。

00:27:11.000 --> 00:27:23.000
ベストプラクティスとして、各アプリ内購入のoriginal_transaction_idを顧客アカウントデータベースに保存している場合は、元の_transaction_idのいずれかを使用して過去の払い戻しを検索できます。

00:27:23.000 --> 00:27:31.000
また、払い戻し検索APIを使用して、払い戻しにつながる可能性のある顧客のコンテンツ配信の問題をトラブルシューティングできます。

00:27:31.000 --> 00:27:36.000
それでは、自動更新サブスクリプションについて具体的に話すためにギアをシフトしましょう。

00:27:36.000 --> 00:27:46.000
たとえば、停止やイベントがキャンセルされたシナリオは、スポーツ、ライブテレビ、ビデオなどのストリーミングベースのアプリでより一般的かもしれません。

00:27:46.000 --> 00:27:51.000
これらの停止やキャンセルされたイベントのために、どのように顧客をなだめることができますか?

00:27:51.000 --> 00:28:02.000
新しいRenewal Extension Server APIを使用して、有料のアクティブサブスクリプションの更新日を延長し、顧客にさらに時間無料サービスを提供できるようになりました。

00:28:02.000 --> 00:28:11.000
このAPIを使用して、一時的な停止を処理し、柔軟な対応を提供できます。たとえば、顧客がサービスで悪い経験をした場合などです。

00:28:11.000 --> 00:28:22.000
実際のサブスクリプション期間に関係なく、顧客のサブスクリプションの更新日を1年以内に2回、毎回最大90日間延長できることに注意してください。

00:28:22.000 --> 00:28:31.000
また、この延長期間は、85%の収益率を受け取るために必要な1年間の有料サービスにはカウントされません。

00:28:31.000 --> 00:28:38.000
ベストプラクティスについては、original_transaction_idを保存して、更新日を延長するサブスクリプションを特定します。

00:28:38.000 --> 00:28:46.000
ビジネスモデルに最適な延長期間を特定し、顧客のサブスクリプションを延長するときにアプリ内メッセージを表示します。

00:28:46.000 --> 00:28:57.000
また、顧客1人あたり1年に2回しか延長できないため、延長の対象となる顧客の資格基準を維持したいと思うかもしれません。

00:28:57.000 --> 00:29:05.000
また、常にビジネスチームやマーケティングチームと連携して、すべてのコミュニケーションチャネルで一貫したメッセージングを提供します。

00:29:05.000 --> 00:29:14.000
それでは、サブスクリプションに1回限りの割引を提供することで、顧客に補償したい別のシナリオについて話し合いましょう。

00:29:14.000 --> 00:29:26.000
iOS 14では、App Storeは、期間限定で割引または無料でサブスクリプションを提供することで、購読者を獲得し、維持し、獲得するのに役立つサブスクリプションオファーコードを導入しました。

00:29:26.000 --> 00:29:32.000
オンラインまたはオフラインのチャネルを使用して、これらの1回限りの一意のコードを配布できます。

00:29:32.000 --> 00:29:38.000
また、顧客サービスの問題については、サービス問題の補償としてこれらのワンタイムコードを提供できます。

00:29:38.000 --> 00:29:49.000
また、これを代替サブスクリプションオプションを提案する機会として使用することもできます。たとえば、低価格でより多くの価値を提供するより長い期間のプランです。

00:29:49.000 --> 00:30:03.000
iOS 14およびiPadOS 14以降のお客様は、1回限りのコード引き換えURLを介してApp Storeで、またはStoreKitにpresentCodeRedemptionSheet APIを実装している場合はアプリ内でオファーコードを引き換えることができます。

00:30:03.000 --> 00:30:16.000
さて、ベストプラクティスとして、顧客が情報に基づいた決定を下すのを助けるために、カスタマイズされたアプリ内メッセージングとオファーコードの説明とともに、顧客がコードを引き換えるためのアプリ内の償還フローを提供します。

00:30:16.000 --> 00:30:29.000
また、電話、電子メール、ウェブなどの既存のカスタマーサポートチャネル内、または顧客がライブチャットセッションでサポートチームとチャットしている場合など、アプリ内でもこれを使用します。

00:30:29.000 --> 00:30:38.000
現在、電子メールなどのデジタルマーケティングチャネルでこれらのコードを配布する場合、各コードには、コードが事前に入力された関連する償還URLがあります。

00:30:38.000 --> 00:30:47.000
一意のURLを使用して、電子メールからApp Storeで発生する償還フローに顧客をシームレスにディープリンクすることができます。

00:30:47.000 --> 00:31:05.000
このURLは2つの値で構成されています。IDは、アプリケーションのIDを表すため、アプリケーションごとに静的になります。2番目の値はコードで、加入者の一意の英数字値をURLに動的に入力します。

00:31:05.000 --> 00:31:12.000
さて、そのURLが電子メールに埋め込まれている場合、タップすると、ユーザーはApp Storeに移動してトランザクションを完了します。

00:31:12.000 --> 00:31:25.000
注意すべき点：ここの加入者は、このフロー中にコードを見ることはなく、完了すると、顧客がアプリケーションを再度起動したときにアプリが実行する必要がある別の外部トランザクションになります。

00:31:25.000 --> 00:31:31.000
次に、顧客がサブスクリプションを管理したいシナリオを取り上げましょう。

00:31:31.000 --> 00:31:40.000
StoreKit 2では、既存の管理サブスクリプションをアプリ内に表示できる新しい管理サブスクリプションAPIを立ち上げました。

00:31:40.000 --> 00:31:48.000
アプリ内でサブスクリプション管理をサポートすることは、顧客がアプリを離れることなくサブスクリプションをアップグレード、ダウングレード、またはキャンセルできることを意味します。

00:31:48.000 --> 00:31:57.000
これはまた、一般的な加入者の問題に助けを提供し、顧客が検討するための代替オファーを提示する自然な場所を提供します。

00:31:57.000 --> 00:32:07.000
また、この機会を利用して、サブスクリプションの管理ページが表示される前に、パーソナライズされた保存オファーを提示することができます。たとえば、エンゲージメントが低い場合などです。

00:32:07.000 --> 00:32:14.000
または、キャンセルする場合は、出口調査を提示して、キャンセルの詳細を入手することもできます。

00:32:14.000 --> 00:32:15.000
さて、ベストプラクティスです。

00:32:15.000 --> 00:32:24.000
StoreKit APIを使用すると、アプリを離れることなくサブスクリプションを管理またはキャンセルするのに役立つ一貫したエクスペリエンスを提示できます。

00:32:24.000 --> 00:32:30.000
システムが提供する管理UIを補完するために、ブランドのコンテキストエクスペリエンスを作成することを検討してください。

00:32:30.000 --> 00:32:41.000
たとえば、顧客の好みや使用状況に基づいて、パーソナライズされた提案や代替プランを提供するために、人気のあるプレミアム層を提供することができます。

00:32:41.000 --> 00:32:49.000
そして、すべての異なるチャネルにわたるカスタマーサポートジャーニーに関連して、全体的なサブスクリプション管理エクスペリエンスを確認します。

00:32:49.000 --> 00:32:56.000
では、アプリのサブスクリプション管理UIのサンプルを見てみましょう。

00:32:56.000 --> 00:32:59.000
ユーザーがサブスクリプションを管理するため。

00:32:59.000 --> 00:33:08.000
そして、顧客がこのボタンをタップすると、App Storeには、現在アクティブなサブスクリプションと更新オプションを含む既存のサブスクリプション管理ページが表示されます。

00:33:08.000 --> 00:33:19.000
これは、お客様がApp Storeの[アカウント設定]で[サブスクリプションの管理]にアクセスし、サブスクリプションを表示、アップグレード、ダウングレード、またはキャンセルできるときによく知っているのと同じビューです。

00:33:19.000 --> 00:33:27.000
これで、お客様がサブスクリプションをキャンセルすることを選択した場合、キャンセルの詳細とサービスの有効期限が記載された確認画面が表示されます。

00:33:27.000 --> 00:33:38.000
また、ユーザーがこのページで実行する可能性のあるアクションについては、App Storeサーバー通知が届き、StoreKit 2フレームワークを実装した場合、アプリに通知されます。

00:33:38.000 --> 00:33:46.000
では、今日取り上げた新しいカスタマーサポートツールで、これらのAPIを使用してサポートを提供することの利点について話しましょう。

00:33:46.000 --> 00:33:54.000
アプリ内でアプリ内購入のコンテキストとシームレスなサポートを提供することで、全体的な顧客体験を向上させることができます。

00:33:54.000 --> 00:34:05.000
これにより、全体的なリテンションが向上し、顧客満足度が向上し、エンゲージメントが向上し、最終的にはアプリの肯定的な評価とレビューが向上します。

00:34:05.000 --> 00:34:11.000
さて、同僚のジョーを招待して、払い戻しの処理について話したいと思います。

00:34:11.000 --> 00:34:18.000
ジョー：Manjeet、発売された新しいカスタマーサポートツールのベストプラクティスとユースケースを提供してくれてありがとう。

00:34:18.000 --> 00:34:23.000
みなさん、こんにちは。私の名前はジョー・マニで、App Storeのプログラムマネージャーです。

00:34:23.000 --> 00:34:34.000
払い戻しはデリケートなトピックであり、App Storeは、払い戻しがアプリに与える影響と、これらのツールを活用して顧客体験を向上させる方法を理解するためのツールを作成しました。

00:34:34.000 --> 00:34:41.000
これらのツールを使用することの利点を強調し、払い戻しの処理に関する包括的なメッセージを提供したいと思います。

00:34:41.000 --> 00:34:46.000
昨年、私たちは払い戻しに影響を与える2つの新しいツールを立ち上げました。

00:34:46.000 --> 00:34:51.000
まず、beginRefundRequest APIについて話し合いましょう。

00:34:51.000 --> 00:34:58.000
App Storeは問題を報告し、Appleサポートは顧客が払い戻しを要求するためのパスを確立しました。

00:34:58.000 --> 00:35:09.000
現在、iOS 15では、App Storeは、顧客がアプリ内購入の払い戻しをリクエストできるように、StoreKit 2フレームワークに新しい beginRefundRequest APIを導入しました。

00:35:09.000 --> 00:35:13.000
beginRefundRequest APIを実装するには、複数の利点があります。

00:35:13.000 --> 00:35:19.000
聴いている人のほとんどは、アプリ内購入の払い戻しをリクエストした顧客がいます。

00:35:19.000 --> 00:35:28.000
新しい beginRefundRequest APIを使用すると、顧客をリダイレクトしたり、アプリ内で支援を提供したりすることなく、同じ機能を提供できます。

00:35:28.000 --> 00:35:38.000
アプリ内購入の潜在的な問題を認識している場合は、このAPIを使用して、顧客が問題のトラブルシューティングを行い、より迅速な解決策を得ることができます。

00:35:38.000 --> 00:35:47.000
iOS 15では、App Storeは特に2つの追加通知を作成しているので、払い戻しが承認されたか拒否されたかを知ることができます。

00:35:47.000 --> 00:35:54.000
払い戻しが承認されると、アプリに通知され、サーバーはApp Storeから払い戻し通知を受け取ります。

00:35:54.000 --> 00:35:59.000
払い戻しが拒否された場合、サーバーは新しいREFUND_DECLINED通知を受け取ります。

00:35:59.000 --> 00:36:06.000
この機能を使用するには、iOS 15以上を使用する必要があることに注意してください。

00:36:06.000 --> 00:36:08.000
ベストプラクティスについて話し合いましょう。

00:36:08.000 --> 00:36:16.000
元のトランザクションIDを保存し、ほとんどの払い戻しリクエストは購入後30日以内に発生することに注意してください。

00:36:16.000 --> 00:36:27.000
顧客がイライラし、払い戻しを要求する状況がある場合でも、カスタマイズされた顧客体験を作成するカスタムビルドのアプリ内メッセージングを提供できます。

00:36:27.000 --> 00:36:33.000
過去の購入に関するコンテキスト情報を顧客に柔軟に表示できます。

00:36:33.000 --> 00:36:47.000
顧客が返金するトランザクションを選択すると、顧客が理由コードのリストから選択できる払い戻しリクエストシートを表示するAPIを呼び出すことができます。これは、Appleの「問題を報告する」に表示されるものと一致します。

00:36:47.000 --> 00:36:57.000
自動更新サブスクリプションの場合、払い戻しが成功するとサブスクリプションがキャンセルされるため、アプリ内で顧客のエンゲージメントを維持するための保持戦略を特定できます。

00:36:57.000 --> 00:37:05.000
beginRefundRequestを見たので、その後に何が起こるか、どのようにもっと関与できるかについて話しましょう。

00:37:05.000 --> 00:37:23.000
App Storeは、払い戻しを要求する前にアイテムを消費したかどうかなど、顧客の消耗品のアプリ内購入に関する消費情報をAppleに送信することで、払い戻しプロセスを通知し、改善する機会を提供する新しいサーバーAPIを導入しました。

00:37:23.000 --> 00:37:30.000
高レベルでは、各払い戻し要求は、払い戻し決定システムを通過して決定を下します。

00:37:30.000 --> 00:37:39.000
払い戻し決定システムには、問題の取引に関する情報や、お客様の購入履歴や払い戻し履歴などのその他の要因が含まれます。

00:37:39.000 --> 00:37:45.000
Appleが決定を下す前に、App StoreはサーバーにCONSUMPTION_REQUEST通知を送信します。

00:37:45.000 --> 00:37:53.000
サーバーは、この通知に応答して消費データをApp Storeに送り返し、払い戻しの決定に影響を与える可能性があります。

00:37:53.000 --> 00:38:01.000
消費ペイロードは一握りのフィールドで構成されており、今日は3つの重要なフィールドについて議論したいと思います。

00:38:01.000 --> 00:38:07.000
消費では、アプリ内購入が完全に消費されたのか、部分的に消費されたのか、まったく消費されていないのかを簡単に伝えることができます。

00:38:07.000 --> 00:38:18.000
たとえば、アプリに物々交換がある交換プラットフォームがある場合、またはあるアカウントから別のアカウントに転送されたアプリ内がある場合、それは消費されたと見なされます。

00:38:18.000 --> 00:38:26.000
コンテンツの配信では、停止を経験したり、アプリ内購入を配信できなかったりする可能性があり、顧客に返金したい場合があります。

00:38:26.000 --> 00:38:29.000
今、あなたは単に配達されていないアイテムを提供することができます。

00:38:29.000 --> 00:38:46.000
StoreKit 2で起動されるappAccountTokenでは、お客様が作成したアプリのユーザーアカウントに関連付けられた標準のUUID形式を使用しており、購入を開始し、購入用のコンテンツを消費しています。これは、再販業者を特定するのに役立ちます。

00:38:46.000 --> 00:38:54.000
ベストプラクティスとして、ほとんどの払い戻し要求は30日以内に行われるため、それに応じて取引の消費データを保存します。

00:38:54.000 --> 00:39:03.000
Appleがデータを要求しているトランザクションを見つけることができるように、各消耗品のアプリ内購入の元の_transaction_IDを保存します。

00:39:03.000 --> 00:39:12.000
Appleが意思決定のためにあなたのデータを確実に組み込むために、消費要求通知を受け取ってから12時間以内に返信してください。

00:39:12.000 --> 00:39:19.000
最初のリクエスト後に何か変更があった場合は、その12時間以内に更新されたペイロードを自由に送信してください。

00:39:19.000 --> 00:39:26.000
要求された消費データをApp Storeに送信する前に、顧客の同意を得ていることを確認してください。

00:39:26.000 --> 00:39:35.000
そして最後に、消費ペイロード内では、すべてのフィールドは必須ではなく、未申告のフィールドとしてマークできるAppleのドキュメントを確認してください。

00:39:35.000 --> 00:39:40.000
今日のセッションを要約すると、重要なアクションのチェックリストを提供したいと思います。

00:39:40.000 --> 00:39:53.000
これらの機能を採用して実装するための次のステップでは、App Store ConnectにURLを入力し、Sandboxでバージョン2を有効にすることで、サーバーがApp Storeサーバー通知を受信するための設定と有効化を開始できます。

00:39:53.000 --> 00:40:02.000
カスタマーサポートツールについては、電話、電子メール、ウェブ、アプリ内サポートのいずれかで、既存のサポートチャネルに統合します。

00:40:02.000 --> 00:40:14.000
アプリでは、新しいbeginRefundRequest、isEligibleforIntroOffer、およびshowManageSubcriptions APIをサポートするために必要なStoreKit 2を使用して、iOS 15のクライアントの変更を特定します。

00:40:14.000 --> 00:40:28.000
最後に、ストアフロントの変更、購入履歴の消去、払い戻しのテスト、サブスクリプション更新率の調整など、サンドボックスのテストの更新を最大限に活用するために、サンドボックスのアップデートを活用してください。

00:40:28.000 --> 23:59:59.000
これでプレゼンテーションは終わりです。本日はご参加いただき、StoreKit 2とApp Store Server APIでお客様をサポートすることについて詳しく学んでいただき、誠にありがとうございます。

