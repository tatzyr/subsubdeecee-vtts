[
  {
    "text": "Welcome to Metal updates for the A14 Bionic. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=0"
  },
  {
    "text": "My name is Anand Poovekurussi, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=3"
  },
  {
    "text": "and I work in GPU software at Apple.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=5"
  },
  {
    "text": "The A14 Bionic is at the heart of iPhone 12 and the new iPad Air. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=9"
  },
  {
    "text": "In this video, my colleague Swami and I ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=14"
  },
  {
    "text": "will introduce you to the GPU capabilities of the A14 Bionic ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=16"
  },
  {
    "text": "and the new Metal features that it enables.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=21"
  },
  {
    "text": "The A14 has big updates to our CPU, GPU, neural engine ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=25"
  },
  {
    "text": "and other custom technologies that drive the iOS experience. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=29"
  },
  {
    "text": "It uses breakthrough 5-nanometer process technology, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=34"
  },
  {
    "text": "which brings new features, increased performance ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=37"
  },
  {
    "text": "and even more power efficiency in nearly every aspect of the chip.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=40"
  },
  {
    "text": "We have built a world-class mobile GPU into the A14 Bionic. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=45"
  },
  {
    "text": "It has four cores scaled to deliver ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=50"
  },
  {
    "text": "the maximum sustainable performance at the lowest possible power.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=52"
  },
  {
    "text": "Now, in terms of Metal, there are some specific changes in the A14 ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=57"
  },
  {
    "text": "that will improve the performance of your Metal apps... ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=61"
  },
  {
    "text": "starting off with GPU-driven pipelines. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=65"
  },
  {
    "text": "Indirect command buffers in Metal enable you to move work to the GPU ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=68"
  },
  {
    "text": "and let you encode commands on the GPU timeline. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=73"
  },
  {
    "text": "This frees up valuable CPU time ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=76"
  },
  {
    "text": "for you to perform other tasks in your apps. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=78"
  },
  {
    "text": "The A14 GPU architecture makes such usage models more efficient.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=81"
  },
  {
    "text": "Next, we have made significant performance improvements ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=87"
  },
  {
    "text": "to the design of GPU threadgroup memory ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=90"
  },
  {
    "text": "to better support parallel computing. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=93"
  },
  {
    "text": "We expect synchronization primitives such as threadgroup scoped atomics ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=95"
  },
  {
    "text": "to see great performance benefits as a result of these changes.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=99"
  },
  {
    "text": "Finally, the ability to conserve memory bandwidth ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=104"
  },
  {
    "text": "continues to be a significant design advantage of our platforms. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=107"
  },
  {
    "text": "The A14 GPU leverages brand-new compression hardware ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=111"
  },
  {
    "text": "which brings even more bandwidth savings to your apps. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=115"
  },
  {
    "text": "Frame buffer compression is expected to improve by 15% or more on average ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=118"
  },
  {
    "text": "and depth buffers should see 40% or more improvement on average. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=123"
  },
  {
    "text": "All the new capabilities of the A14 GPU belong to a new Metal feature set ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=128"
  },
  {
    "text": "called Apple GPU family 7.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=133"
  },
  {
    "text": "Here's what we'll be covering in this video. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=138"
  },
  {
    "text": "First up, I will talk about barycentric coordinates and primitive ID. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=141"
  },
  {
    "text": "I will also show you how both of these features can be used together ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=145"
  },
  {
    "text": "to implement deferred rendering techniques such as the visibility buffer.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=149"
  },
  {
    "text": "After that, I will quickly introduce the new texture addressing modes in A14. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=154"
  },
  {
    "text": "We also have brand-new features for apps doing compute.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=159"
  },
  {
    "text": "In the second section of the talk, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=164"
  },
  {
    "text": "my colleague Swami will talk about the new SIMD reduction instructions ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=166"
  },
  {
    "text": "that provide an efficient way for applications ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=170"
  },
  {
    "text": "to perform reduction operations at SIMD group scope.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=172"
  },
  {
    "text": "He will also cover the new SIMD matrix multiply instructions ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=176"
  },
  {
    "text": "in Metal on A14. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=180"
  },
  {
    "text": "These new instructions provide significant performance boost ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=182"
  },
  {
    "text": "for large matrix multiplies ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=184"
  },
  {
    "text": "that are used in machine learning and image compute.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=186"
  },
  {
    "text": "Let's look at each of these in more detail... ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=190"
  },
  {
    "text": "starting with barycentric coordinates and primitive ID.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=194"
  },
  {
    "text": "Apple GPU family 7 now provides access ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=199"
  },
  {
    "text": "to barycentric coordinates and primitive ID. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=202"
  },
  {
    "text": "Barycentric coordinates define ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=205"
  },
  {
    "text": "the exact location of a fragment within a primitive. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=206"
  },
  {
    "text": "And now, you can access these coordinates right in your fragment shader. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=210"
  },
  {
    "text": "As you can see in the picture on the right, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=214"
  },
  {
    "text": "the location of the fragment at point P ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=216"
  },
  {
    "text": "is defined as a weighted sum of the vertices that form the triangle, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=218"
  },
  {
    "text": "where the sum of the weights is 1.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=222"
  },
  {
    "text": "In the Metal shading language, the barycentric coordinates of the fragment ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=225"
  },
  {
    "text": "are exposed as a vector of floats. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=229"
  },
  {
    "text": "Let's take a look at a technique ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=231"
  },
  {
    "text": "which can benefit from using barycentric coordinates.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=233"
  },
  {
    "text": "Procedural generation is a class of techniques ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=238"
  },
  {
    "text": "used to algorithmically generate models, animations and effects. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=240"
  },
  {
    "text": "You can do all sorts of procedural effects on the surface of the primitives, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=245"
  },
  {
    "text": "such as particle systems, terrains or vegetation on the fly. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=248"
  },
  {
    "text": "Drawing custom lines is one such example. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=253"
  },
  {
    "text": "Let's take a look at how barycentric coordinates can be used for this.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=256"
  },
  {
    "text": "Let's say you wanted to use procedural generation ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=261"
  },
  {
    "text": "to draw custom high-quality anti-aliased lines and borders on triangles.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=264"
  },
  {
    "text": "To do this, you can apply interesting mathematical functions ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=269"
  },
  {
    "text": "on the distance of the fragment from the edges of your primitive.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=272"
  },
  {
    "text": "Barycentric coordinates of your fragment ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=276"
  },
  {
    "text": "in essence give you the distance from the edges.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=278"
  },
  {
    "text": "The examples above show some interesting functions ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=282"
  },
  {
    "text": "applied on the barycentric coordinates in your fragment shader ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=285"
  },
  {
    "text": "to generate on-the-fly effects.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=288"
  },
  {
    "text": "Another new feature of Metal on A14 is primitive ID.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=291"
  },
  {
    "text": "Primitive ID tells you which primitive ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=296"
  },
  {
    "text": "the current fragment corresponds to in the input geometry. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=298"
  },
  {
    "text": "On the right, the IDs listed on triangles ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=302"
  },
  {
    "text": "will be returned when primitive ID is fetched ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=304"
  },
  {
    "text": "for any fragment within that triangle in your fragment shader. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=306"
  },
  {
    "text": "Now if the triangle gets clipped by the hardware, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=311"
  },
  {
    "text": "a child triangle inherits the primitive ID of its parent. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=313"
  },
  {
    "text": "And in the presence of tessellation, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=317"
  },
  {
    "text": "the primitive ID simply corresponds to the patch ID.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=319"
  },
  {
    "text": "In the Metal shading language, primitive ID is an unsigned integer. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=323"
  },
  {
    "text": "Let's take a look at a use case for primitive ID.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=327"
  },
  {
    "text": "Temporal anti-aliasing is a technique ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=332"
  },
  {
    "text": "that reduces the ghosting and shimmering artifacts ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=334"
  },
  {
    "text": "caused by motion between frames. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=337"
  },
  {
    "text": "It works by accumulating pixel data from the previous frame ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=339"
  },
  {
    "text": "and blending it with the current render results for the fragment. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=342"
  },
  {
    "text": "Primitive ID can be used with temporal anti-aliasing ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=345"
  },
  {
    "text": "to validate the sample from the previous frame. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=348"
  },
  {
    "text": "So how would you actually do this in practice? ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=351"
  },
  {
    "text": "First, in your fragment shader, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=355"
  },
  {
    "text": "you re-project the results from the previous frame ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=357"
  },
  {
    "text": "to fetch pixel history. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=359"
  },
  {
    "text": "Then you introspect the pixel ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=361"
  },
  {
    "text": "to ensure that the data is consistent with the current frame. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=363"
  },
  {
    "text": "This can be done by comparing the primitive IDs of the two samples. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=367"
  },
  {
    "text": "If the IDs match, you can choose to accumulate ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=371"
  },
  {
    "text": "the contribution from the previous frame. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=373"
  },
  {
    "text": "The pixel history can be accumulated or reset post-introspection, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=375"
  },
  {
    "text": "forwarding the results on to the next frame.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=379"
  },
  {
    "text": "Now that we have introduced barycentric coordinates and primitive ID, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=383"
  },
  {
    "text": "let's take a deeper dive...",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=386"
  },
  {
    "text": "starting with deferred rendering, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=389"
  },
  {
    "text": "a technique you're likely already familiar with. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=391"
  },
  {
    "text": "Deferred rendering classically operates in two stages. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=394"
  },
  {
    "text": "The first stage, generating the surface attribute buffer, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=398"
  },
  {
    "text": "called the G-buffer, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=400"
  },
  {
    "text": "and the second stage, which consumes the G-buffer ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=402"
  },
  {
    "text": "and applies lighting on the scene. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=404"
  },
  {
    "text": "But if you're running at high resolution or using multi-sampling, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=406"
  },
  {
    "text": "the size of the G-buffer can be quite large, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=410"
  },
  {
    "text": "and reading and writing of these buffers could have prohibitive bandwidth costs. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=413"
  },
  {
    "text": "To address this problem, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=417"
  },
  {
    "text": "the G-buffer could be replaced with a thin buffer, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=419"
  },
  {
    "text": "which contains the minimal set of surface attributes. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=422"
  },
  {
    "text": "This buffer is called a visibility buffer.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=426"
  },
  {
    "text": "The visibility buffer minimizes the work in the geometry stage ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=431"
  },
  {
    "text": "by greatly simplifying the output from this stage. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=434"
  },
  {
    "text": "All the material logic ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=438"
  },
  {
    "text": "you would typically perform in the fragment shader in deferred rendering ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=439"
  },
  {
    "text": "to generate material properties in the G-buffer ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=442"
  },
  {
    "text": "are now moved to the lighting phase. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=445"
  },
  {
    "text": "By doing this, we no longer have to store all material properties ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=447"
  },
  {
    "text": "in the intermediate buffer. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=451"
  },
  {
    "text": "Without material function, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=453"
  },
  {
    "text": "the complexity of the geometry stage is greatly reduced, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=454"
  },
  {
    "text": "allowing for a high fill rate ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=457"
  },
  {
    "text": "and minimum traffic between the vertex shader and the fragment shader.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=459"
  },
  {
    "text": "This technique adds a new reconstruction step during the lighting pass ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=463"
  },
  {
    "text": "to reconstruct the material inputs ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=467"
  },
  {
    "text": "from the minimal data set inside the visibility buffer. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=469"
  },
  {
    "text": "Let's take a look at what the visibility buffer will contain.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=472"
  },
  {
    "text": "The visibility buffer only needs to contain two attributes ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=477"
  },
  {
    "text": "to facilitate geometry reconstruction. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=481"
  },
  {
    "text": "The primitive ID can be used ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=483"
  },
  {
    "text": "to manually retrieve vertex data from the vertex buffer, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=485"
  },
  {
    "text": "effectively doing a deferred vertex fetch.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=488"
  },
  {
    "text": "Barycentric coordinates are used ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=492"
  },
  {
    "text": "to interpolate vertex data for the current fragment. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=493"
  },
  {
    "text": "As mentioned before, you can access these attributes ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=496"
  },
  {
    "text": "in your fragment shader on A14. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=499"
  },
  {
    "text": "Let's take a closer look at the two stages of the visibility buffer pipeline.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=502"
  },
  {
    "text": "At a high level, the visibility buffer approach has two stages: ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=507"
  },
  {
    "text": "the geometry stage, which produces the visibility buffer, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=511"
  },
  {
    "text": "and the lighting stage that consumes it.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=514"
  },
  {
    "text": "In the geometry stage, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=517"
  },
  {
    "text": "the vertex shader's transformation ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=518"
  },
  {
    "text": "only generates the position needed for rasterization. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=520"
  },
  {
    "text": "The fragment stage can generate ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=524"
  },
  {
    "text": "the primitive ID and barycentric coordinates ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=525"
  },
  {
    "text": "with the new A14 Metal shading language attributes ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=528"
  },
  {
    "text": "without the need for any additional varyings.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=531"
  },
  {
    "text": "In the lighting stage, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=535"
  },
  {
    "text": "a new reconstruction step will use a deferred vertex fetch ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=537"
  },
  {
    "text": "based on the primitive ID ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=540"
  },
  {
    "text": "and interpolate the vertex data using barycentric coordinates ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=542"
  },
  {
    "text": "to generate material function inputs.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=545"
  },
  {
    "text": "The material and lighting shaders are effectively untouched ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=548"
  },
  {
    "text": "and are identical to the deferred rendering implementations.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=552"
  },
  {
    "text": "Let's take a look at how interfaces between these stages have been minimized.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=556"
  },
  {
    "text": "The vertex shader only requires the position to rasterize.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=562"
  },
  {
    "text": "The fragment shader generates the surface ID and barycentric coordinates ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=566"
  },
  {
    "text": "for the visibility buffer that is fed into the reconstruction step. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=570"
  },
  {
    "text": "And only after the reconstruction step ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=574"
  },
  {
    "text": "do we have the large reconstructed material input data in memory, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=576"
  },
  {
    "text": "which is used by the material model and the lighting functions. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=580"
  },
  {
    "text": "Now that we have introduced the interfaces, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=584"
  },
  {
    "text": "let's take a look at the shaders that are generating these inputs and outputs.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=586"
  },
  {
    "text": "Let's start with the geometry face, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=592"
  },
  {
    "text": "which has a simple vertex and fragment shader.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=594"
  },
  {
    "text": "The vertex shader only needs to transform and output the position. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=597"
  },
  {
    "text": "In the fragment shader, we make use of the new primitive ID ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=602"
  },
  {
    "text": "and barycentric coordinates available in the Metal shading language. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=605"
  },
  {
    "text": "We combine the primitive ID and additional draw index ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=608"
  },
  {
    "text": "into our surface identifier ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=611"
  },
  {
    "text": "so we can identify primitives across vertex buffers, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=613"
  },
  {
    "text": "as we will see later. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=617"
  },
  {
    "text": "Now let's take a look at the lighting stage.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=619"
  },
  {
    "text": "At a high level, the lighting stage has three steps: ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=622"
  },
  {
    "text": "reconstruction, material model and lighting function. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=625"
  },
  {
    "text": "The reconstruction step will reconstruct material input ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=629"
  },
  {
    "text": "from our surface identifier and barycentric coordinates. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=632"
  },
  {
    "text": "Then we can execute our material model steps, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=636"
  },
  {
    "text": "as we do in our deferred shader. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=638"
  },
  {
    "text": "And finally we apply our lighting function to write out the final lit pixel. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=641"
  },
  {
    "text": "As mentioned previously, the material and the lighting stages ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=646"
  },
  {
    "text": "are identical to classic deferred. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=649"
  },
  {
    "text": "So let's take a look at the reconstruction step in more detail.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=652"
  },
  {
    "text": "The main purpose of the reconstruction step ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=658"
  },
  {
    "text": "is the transformation of the incoming visibility buffer fragment ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=660"
  },
  {
    "text": "to material inputs.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=663"
  },
  {
    "text": "First, this requires generating vertex data for a given fragment ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=666"
  },
  {
    "text": "using primitive ID and draw ID ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=669"
  },
  {
    "text": "contained in the surface identifier. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=672"
  },
  {
    "text": "An additional index facilitates having different vertex buffers across fragments. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=674"
  },
  {
    "text": "For this, we use a draw identifier to reference the draw call.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=680"
  },
  {
    "text": "Second, the barycentric coordinates are used ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=685"
  },
  {
    "text": "for interpolation in the reconstruction step. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=687"
  },
  {
    "text": "Let's examine the dereferencing tree.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=690"
  },
  {
    "text": "Here we show the dereferencing tree ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=693"
  },
  {
    "text": "needed to resolve a visibility buffer pixel ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=696"
  },
  {
    "text": "back to the original interpolated vertex attributes.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=698"
  },
  {
    "text": "The visibility buffer contains two barycentric coordinates. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=703"
  },
  {
    "text": "The third coordinate can be retrieved from the other two ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=706"
  },
  {
    "text": "since the sum of all three is unity.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=708"
  },
  {
    "text": "It also contains a combination of the draw ID and primitive ID, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=712"
  },
  {
    "text": "as mentioned before. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=715"
  },
  {
    "text": "From the draw ID, the draw state can be retrieved, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=717"
  },
  {
    "text": "allowing access to per-draw properties ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=720"
  },
  {
    "text": "such as view projection matrix.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=722"
  },
  {
    "text": "From there, we can retrieve the vertex and the index buffer ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=725"
  },
  {
    "text": "from the mesh state. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=728"
  },
  {
    "text": "These indices are needed to fetch the vertex data.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=730"
  },
  {
    "text": "And we can also use the same path ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=734"
  },
  {
    "text": "to retrieve material-specific data that we need.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=736"
  },
  {
    "text": "Now if our material model becomes more complicated, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=740"
  },
  {
    "text": "we can add a material function pointer to execute specific material logic.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=743"
  },
  {
    "text": "Let's take a look at how reconstruction looks in shader code.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=748"
  },
  {
    "text": "The first thing to do in your reconstruction function ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=753"
  },
  {
    "text": "is to retrieve the primitive ID, draw ID and barycentric coordinates ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=755"
  },
  {
    "text": "from the visibility buffer.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=759"
  },
  {
    "text": "After that, you can proceed to retrieve the mesh ID from the draw state ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=761"
  },
  {
    "text": "using the draw ID. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=765"
  },
  {
    "text": "The index buffer needs to be dereferenced ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=767"
  },
  {
    "text": "to retrieve the vertex indices within the vertex buffers ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=770"
  },
  {
    "text": "using primitive ID and mesh ID.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=773"
  },
  {
    "text": "Then the vertex buffer data ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=776"
  },
  {
    "text": "can be read and interpolated across barycentric coordinates. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=778"
  },
  {
    "text": "Additionally, matrices and other per-draw info ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=782"
  },
  {
    "text": "can be retrieved to do deferred vertex transformations ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=785"
  },
  {
    "text": "on geometries such as normals and tangents.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=788"
  },
  {
    "text": "Once the material input has been generated, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=793"
  },
  {
    "text": "the data is fed into the material logic and lighting functions, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=795"
  },
  {
    "text": "as discussed previously.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=798"
  },
  {
    "text": "Let's take a look at visibility buffer in action.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=801"
  },
  {
    "text": "Here's a modern rendering scene ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=805"
  },
  {
    "text": "that is using the visibility buffer running on the iPhone. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=807"
  },
  {
    "text": "It is implementing a tile lighting technique ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=810"
  },
  {
    "text": "that makes use of multiple materials ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=812"
  },
  {
    "text": "and a scene filled with lights. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=814"
  },
  {
    "text": "Normally, in classic deferred, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=817"
  },
  {
    "text": "this would have required multiple G-buffer channels ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=819"
  },
  {
    "text": "such as normal, albedo, roughness, etc., ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=821"
  },
  {
    "text": "accounting for quite a large G-buffer. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=824"
  },
  {
    "text": "But with visibility buffer, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=826"
  },
  {
    "text": "we only need a surface ID and barycentric coordinates.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=828"
  },
  {
    "text": "First, we store the generated surface identifier, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=834"
  },
  {
    "text": "visualized here with a brightness and a hue ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=837"
  },
  {
    "text": "showing draw ID and primitive ID respectively.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=839"
  },
  {
    "text": "Second, we store the barycentric coordinates, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=844"
  },
  {
    "text": "visualized here, with the red, green and blue color channels.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=847"
  },
  {
    "text": "These two properties are enough to efficiently reconstruct the geometry ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=852"
  },
  {
    "text": "and apply deferred material shading and lighting models.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=856"
  },
  {
    "text": "With this technique, the G-buffer size is significantly reduced on the A14 ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=860"
  },
  {
    "text": "using the thin visibility buffer. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=865"
  },
  {
    "text": "In our example, we save more than 40% of our G-buffer size ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=868"
  },
  {
    "text": "compared to classic deferred.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=872"
  },
  {
    "text": "So that wraps up our deep dive ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=875"
  },
  {
    "text": "on barycentric coordinates and primitive ID.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=877"
  },
  {
    "text": "Now let's take a quick look at the new texture addressing modes in A14. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=881"
  },
  {
    "text": "These modes specify how to handle texture coordinates ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=886"
  },
  {
    "text": "that are outside the sampling range ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=889"
  },
  {
    "text": "and are quite handy when you're using texture atlas.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=891"
  },
  {
    "text": "We've added two new addressing modes in Metal for A14.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=896"
  },
  {
    "text": "With mirror clamp to edge addressing mode, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=900"
  },
  {
    "text": "the texture coordinates within the range of the extents ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=903"
  },
  {
    "text": "are mirrored across the axis. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=905"
  },
  {
    "text": "And when they fall outside, they're clamped. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=908"
  },
  {
    "text": "You can see this in the picture on the right. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=910"
  },
  {
    "text": "We've also added border color clamp mode, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=914"
  },
  {
    "text": "where you can choose one of the presets ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=916"
  },
  {
    "text": "between transparent black, opaque black and opaque white. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=918"
  },
  {
    "text": "The usage is fairly simple.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=922"
  },
  {
    "text": "First, you need to create a sampler descriptor object. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=925"
  },
  {
    "text": "Then you can specify the clamp modes ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=929"
  },
  {
    "text": "for depth, width and height coordinates independently ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=932"
  },
  {
    "text": "by setting the address modes. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=934"
  },
  {
    "text": "If you're using clampToBorderColor, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=937"
  },
  {
    "text": "you can set one of the presets supported in Metal.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=939"
  },
  {
    "text": "After this, you can create the samplerState object ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=942"
  },
  {
    "text": "with the sampler descriptor.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=945"
  },
  {
    "text": "So that was an overview of the new graphics features in A14.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=948"
  },
  {
    "text": "Now I would like to hand it off to my colleague Swami ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=954"
  },
  {
    "text": "to describe the new compute features that the A14 GPU enables, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=956"
  },
  {
    "text": "starting with SIMD reduction.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=960"
  },
  {
    "text": "Thank you, Anand. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=963"
  },
  {
    "text": "I am Swami Narayanan, and I work with GPU software. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=964"
  },
  {
    "text": "Metal is designed to enable high-performance graphics ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=969"
  },
  {
    "text": "as well as to perform data parallel calculations ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=971"
  },
  {
    "text": "and it provides a variety of advanced compute features ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=974"
  },
  {
    "text": "that leverage the tremendous power of the GPU. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=977"
  },
  {
    "text": "On the A14 Bionic, Metal now provides SIMD scope reduction instructions, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=981"
  },
  {
    "text": "which provide a way for apps to perform reductions incredibly efficiently.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=985"
  },
  {
    "text": "To understand how they work, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=991"
  },
  {
    "text": "let's briefly review parallel reduction operations. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=992"
  },
  {
    "text": "Reduction operations are used to reduce the elements of an array ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=996"
  },
  {
    "text": "to a single result. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=999"
  },
  {
    "text": "For example, a sum reduction ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1001"
  },
  {
    "text": "is used to add up all the elements of an array. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1003"
  },
  {
    "text": "This can be useful for computing averages. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1006"
  },
  {
    "text": "Another example is to compute the min and max values of a scene. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1009"
  },
  {
    "text": "Those values can then be used in tone mapping algorithms. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1014"
  },
  {
    "text": "Classically, all these operations were computed serially on the CPU. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1018"
  },
  {
    "text": "However, Metal can take advantage of the parallel nature of the GPU ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1023"
  },
  {
    "text": "to compute reductions much more efficiently.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1027"
  },
  {
    "text": "On the A14 GPU, Metal now supports several SIMD scope reduction instructions.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1032"
  },
  {
    "text": "simd_sum and simd_product generate the sum and product of a variable ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1038"
  },
  {
    "text": "across all threads in a SIMD group.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1043"
  },
  {
    "text": "simd_minimum and simd_maximum ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1046"
  },
  {
    "text": "can be used to find the minimum and maximum values. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1048"
  },
  {
    "text": "These four instructions work on floating point and integer types.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1052"
  },
  {
    "text": "In addition, Metal now supports reductions ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1058"
  },
  {
    "text": "using bit-wise operators \"and,\" \"or\" and \"xor.\" ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1060"
  },
  {
    "text": "Naturally, these work only on integer types. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1064"
  },
  {
    "text": "Before going over the reduction operations in more detail, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1068"
  },
  {
    "text": "let's look at how threads are organized into threadgroups and SIMD groups.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1071"
  },
  {
    "text": "Compute dispatches launch a set of individual threads ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1076"
  },
  {
    "text": "that are represented as a grid.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1080"
  },
  {
    "text": "This grid of threads are divided into smaller subgrids ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1083"
  },
  {
    "text": "that are called threadgroups.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1086"
  },
  {
    "text": "Threadgroups are further organized into groups of 32 threads ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1089"
  },
  {
    "text": "that are called SIMD groups. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1092"
  },
  {
    "text": "The threads of a SIMD group run concurrently in lockstep.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1095"
  },
  {
    "text": "SIMD group functions exploit this lockstep execution ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1099"
  },
  {
    "text": "to share data between these threads.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1102"
  },
  {
    "text": "Now that we have seen how SIMD groups and threadgroups are organized, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1105"
  },
  {
    "text": "let's take a look at how threads are executed in SIMD groups.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1109"
  },
  {
    "text": "A SIMD group has 32 lanes ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1114"
  },
  {
    "text": "that are represented down the left side here. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1116"
  },
  {
    "text": "Each of these lanes will run a thread from the compute dispatch.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1119"
  },
  {
    "text": "Now let's have all the threads in the SIMD group ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1123"
  },
  {
    "text": "store their lane IDs into the variable X. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1126"
  },
  {
    "text": "Notice how each lane has its own value of X.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1129"
  },
  {
    "text": "In the SIMD group execution model, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1134"
  },
  {
    "text": "the instruction that sets the variable X to the lane ID ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1136"
  },
  {
    "text": "is only fetched once ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1139"
  },
  {
    "text": "and is then executed simultaneously in lockstep ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1140"
  },
  {
    "text": "by the 32 threads. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1143"
  },
  {
    "text": "SIMD group functions allow each of these threads ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1145"
  },
  {
    "text": "to inspect and use variables of the other threads in the SIMD group ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1148"
  },
  {
    "text": "with minimal overhead. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1151"
  },
  {
    "text": "Let's take a look at simd_sum, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1153"
  },
  {
    "text": "one of the new instructions added in A14.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1155"
  },
  {
    "text": "simd_sum adds up values of a variable ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1160"
  },
  {
    "text": "across all active threads in the SIMD group ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1163"
  },
  {
    "text": "and broadcasts the sum back to all the threads. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1165"
  },
  {
    "text": "Here we are adding the values of the variable X ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1168"
  },
  {
    "text": "across the 32 lanes of the SIMD group.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1171"
  },
  {
    "text": "Once the instruction is executed, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1174"
  },
  {
    "text": "the resulting sum is then available in the variable F.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1176"
  },
  {
    "text": "Note that all active threads can inspect their copy of the variable F ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1180"
  },
  {
    "text": "to get at the computed sum of 496.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1184"
  },
  {
    "text": "Inactive threads are skipped in the computation correctly. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1188"
  },
  {
    "text": "They do not contribute to the final sum.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1191"
  },
  {
    "text": "Now let's take a look at how we can use simd_sum ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1195"
  },
  {
    "text": "to speed up adding the elements of a large array. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1198"
  },
  {
    "text": "Here the input array is in device memory.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1201"
  },
  {
    "text": "Each SIMD group reads a subregion of the input array ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1204"
  },
  {
    "text": "and computes its sum using the simd_sum instruction.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1207"
  },
  {
    "text": "This sum is then written to an array in threadgroup memory. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1211"
  },
  {
    "text": "Every SIMD group has a distinct ID ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1215"
  },
  {
    "text": "that it can use to index into the threadgroup sum array.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1217"
  },
  {
    "text": "The last executing SIMD group in the threadgroup ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1222"
  },
  {
    "text": "uses the simd_sum instruction again to get the final sum. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1224"
  },
  {
    "text": "By using simd_sum, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1229"
  },
  {
    "text": "we have decreased the number of threadgroup barriers ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1230"
  },
  {
    "text": "and the usage of threadgroup memory. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1232"
  },
  {
    "text": "The simd_sum instruction also gets executed only once ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1234"
  },
  {
    "text": "to compute the sum of all the threads in the SIMD group. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1238"
  },
  {
    "text": "Now let's go to the implementation of the compute kernel.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1241"
  },
  {
    "text": "Here we have the code that implements parallel reduction using simd_sum.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1245"
  },
  {
    "text": "Each thread in the SIMD group reads its corresponding element ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1250"
  },
  {
    "text": "from the input array.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1253"
  },
  {
    "text": "Then it computes a first simdgroup_sum ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1255"
  },
  {
    "text": "using the simd_sum instruction.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1258"
  },
  {
    "text": "This sum is then written to an array in threadgroup memory ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1261"
  },
  {
    "text": "which is indexed using the SIMD group ID.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1264"
  },
  {
    "text": "Note that we need a barrier before we can access the array in threadgroup memory.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1268"
  },
  {
    "text": "The last SIMD group in each threadgroup ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1273"
  },
  {
    "text": "then uses the simd_sum instruction again to get the final sum.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1275"
  },
  {
    "text": "Let us take a look at the other reduction operations we have introduced in A14.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1281"
  },
  {
    "text": "We have already seen simd_sum, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1286"
  },
  {
    "text": "which adds up the values of X across all the active lanes.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1288"
  },
  {
    "text": "Now let's look at simd_max and apply it to the variable X. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1293"
  },
  {
    "text": "Every lane then gets the maximum value, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1296"
  },
  {
    "text": "which is 31, across all the threads in the SIMD group.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1299"
  },
  {
    "text": "Similarly, simd_min stores the minimum value of X, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1303"
  },
  {
    "text": "which happens to be 0 in this case, across all the active lanes.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1306"
  },
  {
    "text": "Finally, we have simd_product, which multiplies up all the values of X. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1311"
  },
  {
    "text": "As one of the variables happens to be 0, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1316"
  },
  {
    "text": "the final product that is broadcast is 0. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1318"
  },
  {
    "text": "These instructions work on both integer and floating point ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1322"
  },
  {
    "text": "scalar and vector types.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1325"
  },
  {
    "text": "Reduction operations are also supported for bit-wise operations on integral types. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1328"
  },
  {
    "text": "Each lane now has a bit field value ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1333"
  },
  {
    "text": "manufactured using the lane ID as shown here.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1336"
  },
  {
    "text": "We can then use the simd_or instruction on the variable X. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1340"
  },
  {
    "text": "The values of X across all the active lanes ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1344"
  },
  {
    "text": "are or-ed together and broadcasted back to the variable F. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1346"
  },
  {
    "text": "This final value happens to be 0x1F3 in our example.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1350"
  },
  {
    "text": "Similarly, simd_xor computes the xor values of X ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1355"
  },
  {
    "text": "and broadcasts back the resulting value, which turns out to be 0x0.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1359"
  },
  {
    "text": "Finally, we have simd_and, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1365"
  },
  {
    "text": "which adds up all the values of X across all the threads in the SIMD group. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1367"
  },
  {
    "text": "This turns out to be the constant 0x3.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1371"
  },
  {
    "text": "That was an overview of the new SIMD scope reduction instructions ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1375"
  },
  {
    "text": "available in the A14 GPU.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1378"
  },
  {
    "text": "Now let's take a look at a new set of SIMD scope instructions ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1382"
  },
  {
    "text": "that greatly improves matrix multiplication. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1386"
  },
  {
    "text": "Matrix multiplication is a very common operation for GPU compute ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1389"
  },
  {
    "text": "and is the basic building block for many parallel computing workloads. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1393"
  },
  {
    "text": "For example, in machine learning, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1397"
  },
  {
    "text": "it is used when computing convolutions and fully connected neuron layers.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1399"
  },
  {
    "text": "Linear algebra is used to represent and solve systems of equations. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1405"
  },
  {
    "text": "The A14 introduces a brand new set of SIMD scope instructions ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1410"
  },
  {
    "text": "which allows you to implement large matrix multiplies very efficiently.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1414"
  },
  {
    "text": "Like the reduction operations we saw before, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1419"
  },
  {
    "text": "these are SIMD group scope operations. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1422"
  },
  {
    "text": "You can now easily build larger, more sophisticated functions ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1425"
  },
  {
    "text": "on top of these building blocks. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1428"
  },
  {
    "text": "In the Metal shading language, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1431"
  },
  {
    "text": "we now have SIMD group scope data structures ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1433"
  },
  {
    "text": "to represent 8 by 8 and 4 by 4 matrices. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1436"
  },
  {
    "text": "You can then use multiply or multiply_accumulate versions ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1440"
  },
  {
    "text": "of the SIMD group scoped matrix operations. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1443"
  },
  {
    "text": "Let's look at an example of multiplying two 16 by 16 matrices ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1446"
  },
  {
    "text": "in a threadgroup using these functions.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1451"
  },
  {
    "text": "We're going to use the 8 by 8 SIMD group matrix operation ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1454"
  },
  {
    "text": "to build a 16 by 16 third group matrix multiplication.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1457"
  },
  {
    "text": "First we partition the result matrix across four SIMD groups. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1462"
  },
  {
    "text": "Each SIMD group will be responsible for computing ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1466"
  },
  {
    "text": "one 8 by 8 quadrant of the result. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1469"
  },
  {
    "text": "Next, we partition the first input matrix. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1472"
  },
  {
    "text": "Here, each SIMD group in a row shares a single block column.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1475"
  },
  {
    "text": "Then we partition the second input. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1480"
  },
  {
    "text": "Here each SIMD group in a column shares a single block row.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1482"
  },
  {
    "text": "Then we will accumulate the products from the first set of 8 by 8 results... ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1487"
  },
  {
    "text": "and the second. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1492"
  },
  {
    "text": "Now let's look at how to write this in the Metal shading language. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1493"
  },
  {
    "text": "With A14, we have introduced new SIMD group matrix objects ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1497"
  },
  {
    "text": "and multiplication operations into the Metal shading language. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1501"
  },
  {
    "text": "These new primitives will greatly improve ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1505"
  },
  {
    "text": "the performance of your matrix multiplications in your shader. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1507"
  },
  {
    "text": "It's easy to use and can be done with just a few lines of shader code.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1511"
  },
  {
    "text": "Here we define three objects to represent 8 by 8 matrices ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1516"
  },
  {
    "text": "with data in 32-bit floating point format. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1520"
  },
  {
    "text": "We have a matrix for each of our inputs and one for our result.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1523"
  },
  {
    "text": "Next, we perform the address arithmetic necessary ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1528"
  },
  {
    "text": "to partition our four SIMD groups across each quadrant of the result.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1530"
  },
  {
    "text": "Then we accumulate some matrices from each source matrix, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1535"
  },
  {
    "text": "broadcasting the appropriate row and column to each SIMD group.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1539"
  },
  {
    "text": "Finally, we store the results. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1544"
  },
  {
    "text": "You can see how easy it is to construct more complex shaders ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1546"
  },
  {
    "text": "using these new primitives.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1550"
  },
  {
    "text": "If you're using Metal performance shaders, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1552"
  },
  {
    "text": "you will benefit from SIMD group scope matrix multiplies ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1555"
  },
  {
    "text": "to accelerate not only matrix multiplication ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1558"
  },
  {
    "text": "but also CNN convolutions. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1561"
  },
  {
    "text": "Matrix multiplication for arbitrary sizes ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1564"
  },
  {
    "text": "can be performed using MPS matrix multiplication.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1566"
  },
  {
    "text": "Here we're encoding a kernel to compute a result ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1570"
  },
  {
    "text": "with M rows and N columns.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1573"
  },
  {
    "text": "CNN convolutions can be performed using MPSCNNConvolution. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1576"
  },
  {
    "text": "Here we're encoding a convolution kernel on a batch of images. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1581"
  },
  {
    "text": "Both of these kernels are available ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1585"
  },
  {
    "text": "using the new Metal Performance Shaders graph ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1587"
  },
  {
    "text": "introduced this year with iOS 14.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1589"
  },
  {
    "text": "MPS Graph allows you to take these basic kernels ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1593"
  },
  {
    "text": "and build complex machine learning networks with them. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1596"
  },
  {
    "text": "As an example, let's look at how ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1600"
  },
  {
    "text": "the matrix multiplication kernel from earlier ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1601"
  },
  {
    "text": "can be used in the graph. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1604"
  },
  {
    "text": "Here we'll initialize a new graph for our operation. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1606"
  },
  {
    "text": "Then we define nodes to represent our two input matrices. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1610"
  },
  {
    "text": "Then we construct a new result node from our inputs ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1615"
  },
  {
    "text": "using a matrix multiplication operation.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1618"
  },
  {
    "text": "Finally, we execute the graph. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1622"
  },
  {
    "text": "For more details on how to use MPS kernels and graph operations, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1624"
  },
  {
    "text": "please refer to previously available WWDC presentations. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1628"
  },
  {
    "text": "As mentioned before, MPS will automatically take advantage of A14 ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1633"
  },
  {
    "text": "for these operations.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1637"
  },
  {
    "text": "Here we can see the improved throughput ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1643"
  },
  {
    "text": "of general matrix multiplications on A14 relative to A13.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1645"
  },
  {
    "text": "On A14, using the new SIMD group matrix multiply operations, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1650"
  },
  {
    "text": "average performance is improved by 37%.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1654"
  },
  {
    "text": "CNN convolutions on A14 ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1658"
  },
  {
    "text": "show an average improvement of 36% from A13. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1661"
  },
  {
    "text": "And when we look at training a full machine learning network ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1665"
  },
  {
    "text": "like Inception V3, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1669"
  },
  {
    "text": "A14 improves by 22%.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1670"
  },
  {
    "text": "That wraps up SIMD group scope matrix multiplication.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1674"
  },
  {
    "text": "Let's recap the new Metal features for the A14.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1678"
  },
  {
    "text": "Barycentric coordinates and primitive ID ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1683"
  },
  {
    "text": "enable new deferred rendering techniques including visibility buffer rendering.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1685"
  },
  {
    "text": "New texture addressing modes, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1691"
  },
  {
    "text": "which are useful when using texture atlases. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1692"
  },
  {
    "text": "SIMD group scope reduction instructions ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1696"
  },
  {
    "text": "that enable better communication between threads.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1699"
  },
  {
    "text": "We have also improved compute and machine learning performance ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1702"
  },
  {
    "text": "with SIMD group scope matrix multiply instructions. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1706"
  },
  {
    "text": "And finally, Metal on A14 ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1710"
  },
  {
    "text": "takes advantage of a host of architectural improvements, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1712"
  },
  {
    "text": "saving bandwidth with improved lossless compression, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1716"
  },
  {
    "text": "faster and more efficient local memory ",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1719"
  },
  {
    "text": "and better GPU-driven pipelines.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1721"
  },
  {
    "text": "Thank you for watching.",
    "link": "https://developer.apple.com/videos/play/tech-talks-10858/?time=1724"
  }
]