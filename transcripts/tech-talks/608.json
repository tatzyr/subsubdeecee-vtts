[
  {
    "text": "Jaap van Muijden: Welcome to Metal Enhancements ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=0"
  },
  {
    "text": "for A13 Bionic. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2"
  },
  {
    "text": "My name is Jaap van Muijden, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=4"
  },
  {
    "text": "from the GPU Software team at Apple. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=5"
  },
  {
    "text": "Today I’m going to introduce you to the latest Apple-designed GPU ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=8"
  },
  {
    "text": "in the A13 Bionic, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=12"
  },
  {
    "text": "and the new Metal features it enables. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=14"
  },
  {
    "text": "I will then then show you how to use those features ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=17"
  },
  {
    "text": "to reduce your app’s memory usage, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=19"
  },
  {
    "text": "and optimize its run-time performance. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=21"
  },
  {
    "text": "The new A13 Bionic continues the rapid evolution ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=25"
  },
  {
    "text": "of Apple-designed GPUs ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=28"
  },
  {
    "text": "by focusing on three major areas: ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=30"
  },
  {
    "text": "general performance, architectural improvements ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=33"
  },
  {
    "text": "that better meet the evolving needs of modern apps, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=35"
  },
  {
    "text": "and advanced Metal features. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=38"
  },
  {
    "text": "Let’s take a look at each. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=41"
  },
  {
    "text": "The GPU in A13 Bionic is almost three times faster ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=43"
  },
  {
    "text": "than the A10 Fusion in general performance, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=47"
  },
  {
    "text": "and builds on the great performance improvements ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=50"
  },
  {
    "text": "of the A11 and A12 Bionic GPUs. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=52"
  },
  {
    "text": "Existing apps run faster on the A13 ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=55"
  },
  {
    "text": "and can complete each frame in less time, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=58"
  },
  {
    "text": "which in turn leads to power savings ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=61"
  },
  {
    "text": "and extended app usage. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=63"
  },
  {
    "text": "The Apple-designed GPU architecture has quickly evolved ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=66"
  },
  {
    "text": "to better meet the demands of modern apps. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=69"
  },
  {
    "text": "Beginning with the A11, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=71"
  },
  {
    "text": "the 16-bit floating point and texturing rates were increased ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=73"
  },
  {
    "text": "to alleviate common bottlenecks in games, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=76"
  },
  {
    "text": "and the numerical accuracy ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=79"
  },
  {
    "text": "of 32-bit floating point operations were improved ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=80"
  },
  {
    "text": "to better handle advanced compute workloads. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=83"
  },
  {
    "text": "The A12 GPU greatly improves memory bandwidth ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=86"
  },
  {
    "text": "by losslessly compressing and decompressing texture content ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=90"
  },
  {
    "text": "to and from memory. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=93"
  },
  {
    "text": "It also adds dedicated hardware to support the user interface, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=94"
  },
  {
    "text": "ensuring even faster response times, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=98"
  },
  {
    "text": "but also reducing the impact of UI elements on foreground apps. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=100"
  },
  {
    "text": "And the A12 and later GPUs enhance the iPad experience ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=104"
  },
  {
    "text": "by sharing its resources between apps more efficiently. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=108"
  },
  {
    "text": "And now we have the A13 GPU. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=111"
  },
  {
    "text": "The A13 GPU architecture greatly improves the processing ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=114"
  },
  {
    "text": "of high dynamic range content on the GPU, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=118"
  },
  {
    "text": "by doubling the rate of 16-bit floating point operations ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=121"
  },
  {
    "text": "and adding support for small 16-bit numbers ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=123"
  },
  {
    "text": "that better preserve black levels. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=126"
  },
  {
    "text": "The A13 GPU also provides significantly better support ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=128"
  },
  {
    "text": "for independent compute work ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=132"
  },
  {
    "text": "that executes concurrently with rendering workloads. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=134"
  },
  {
    "text": "Apple-designed GPUs have supported ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=137"
  },
  {
    "text": "this asynchronous compute capability since the A9, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=139"
  },
  {
    "text": "but the A13 GPU takes it to the next level ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=143"
  },
  {
    "text": "by adding more hardware channels and minimizing impact ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=146"
  },
  {
    "text": "to the more deadline-sensitive rendering tasks. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=149"
  },
  {
    "text": "Now before we describe the new Metal features of the A13, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=152"
  },
  {
    "text": "let’s also quickly recap some of the major Metal features ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=155"
  },
  {
    "text": "introduced on the A11 and A12 GPUs. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=158"
  },
  {
    "text": "Let’s start with the A11. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=163"
  },
  {
    "text": "Tile shading, imageblocks, and persistent threadgroup memory ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=165"
  },
  {
    "text": "all are features designed to explicitly leverage ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=169"
  },
  {
    "text": "Apple’s tile-based deferred rendering architecture ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=171"
  },
  {
    "text": "and work together to optimize the bandwidth usage ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=174"
  },
  {
    "text": "of many modern rendering techniques. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=177"
  },
  {
    "text": "Rasterization order groups allow you to manage complex, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=180"
  },
  {
    "text": "per-pixel data structures on the GPU, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=182"
  },
  {
    "text": "and color rate control ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=185"
  },
  {
    "text": "optimizes the use of multi-sample anti-aliasing ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=186"
  },
  {
    "text": "in advanced rendering algorithms. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=189"
  },
  {
    "text": "And now on to the A12. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=192"
  },
  {
    "text": "Layered rendering lets each rendered primitive ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=194"
  },
  {
    "text": "target a unique slice of a 2D texture array, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=197"
  },
  {
    "text": "while multi-viewport rendering lets each primitive do the same ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=200"
  },
  {
    "text": "for up to 16 viewports and scissor rectangles. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=203"
  },
  {
    "text": "Stencil feedback lets each fragment ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=206"
  },
  {
    "text": "set a unique stencil reference value ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=209"
  },
  {
    "text": "for advanced per-pixel effects, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=211"
  },
  {
    "text": "while stencil resolve allows for stencil buffer reuse ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=213"
  },
  {
    "text": "across MSAA and non-MSAA passes. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=216"
  },
  {
    "text": "And although lossless compression ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=220"
  },
  {
    "text": "is enabled by default wherever possible, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=221"
  },
  {
    "text": "Metal also provides direct control ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=223"
  },
  {
    "text": "over in-place compression and decompression ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=225"
  },
  {
    "text": "of shared storage mode textures ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=228"
  },
  {
    "text": "when optimal readback is required. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=230"
  },
  {
    "text": "So now let’s introduce the new Apple GPU Family 6 ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=232"
  },
  {
    "text": "that supports the A13 GPU. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=235"
  },
  {
    "text": "Sparse textures enable higher-quality texture streaming ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=238"
  },
  {
    "text": "for open-world games at a fixed memory budget, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=241"
  },
  {
    "text": "by tracking the most important regions of each texture ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=244"
  },
  {
    "text": "and then mapping only those regions to memory. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=247"
  },
  {
    "text": "Rasterization rate maps focus high-quality ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=249"
  },
  {
    "text": "rasterization and shading to the image areas that matter most, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=252"
  },
  {
    "text": "while reducing rates elsewhere, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=255"
  },
  {
    "text": "saving both memory and performance. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=257"
  },
  {
    "text": "Vertex amplification eliminates redundant vertex processing ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=259"
  },
  {
    "text": "that would otherwise occur ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=263"
  },
  {
    "text": "with layered renders that share geometry. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=264"
  },
  {
    "text": "GPU-driven pipelines enable you to draw larger ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=267"
  },
  {
    "text": "and more immersive scenes, and with argument buffer tier 2, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=270"
  },
  {
    "text": "apps can execute their GPU-driven workloads ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=273"
  },
  {
    "text": "more flexibly than ever before. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=276"
  },
  {
    "text": "SIMD group instructions ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=278"
  },
  {
    "text": "optimize sharing and synchronization ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=280"
  },
  {
    "text": "among the threads of an SIMD group during shading. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=282"
  },
  {
    "text": "And ASTC HDR brings high-quality lossy compression ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=285"
  },
  {
    "text": "to high-dynamic range textures, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=289"
  },
  {
    "text": "saving significant memory and bandwidth. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=290"
  },
  {
    "text": "Let’s look at each of these in more detail, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=293"
  },
  {
    "text": "starting with sparse textures. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=295"
  },
  {
    "text": "Sparse textures is a brand new feature ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=298"
  },
  {
    "text": "introduced on the A13 GPU ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=300"
  },
  {
    "text": "that let you control the storage and residency of Metal textures ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=302"
  },
  {
    "text": "at a fine granularity. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=306"
  },
  {
    "text": "Sparse textures are not fully resident in memory. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=308"
  },
  {
    "text": "But instead, you can allocate sections of them ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=311"
  },
  {
    "text": "on a special memory heap called a sparse heap. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=313"
  },
  {
    "text": "Here you can see two sparse textures ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=316"
  },
  {
    "text": "that have parts of their data allocated in such a sparse heap. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=318"
  },
  {
    "text": "A single heap can provide storage ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=321"
  },
  {
    "text": "for many sparse textures, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=323"
  },
  {
    "text": "all sharing a single pre-allocated pool of memory. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=324"
  },
  {
    "text": "All sparse textures are split up in units called sparse tiles, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=327"
  },
  {
    "text": "which have the same memory footprint ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=331"
  },
  {
    "text": "independent of texture resolution or pixel format. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=333"
  },
  {
    "text": "So what are the applications of this feature? ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=336"
  },
  {
    "text": "One of them is texture streaming. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=338"
  },
  {
    "text": "Texture streaming lets you render incredibly large scenes ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=340"
  },
  {
    "text": "with a fixed memory footprint ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=344"
  },
  {
    "text": "by loading only the texture mipmaps ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=346"
  },
  {
    "text": "that are needed for the current view. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=347"
  },
  {
    "text": "With traditional texture streaming, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=349"
  },
  {
    "text": "individual mipmaps are loaded when required ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=351"
  },
  {
    "text": "and evicted when no longer needed, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=353"
  },
  {
    "text": "or when more important textures need the memory. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=355"
  },
  {
    "text": "Texture streaming traditionally manages texture residency ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=358"
  },
  {
    "text": "at mipmap granularity. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=362"
  },
  {
    "text": "The lowest levels of the mipmap pyramid are kept resident ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=364"
  },
  {
    "text": "in case a higher quality mipmap is requested, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=366"
  },
  {
    "text": "but not yet streamed in. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=369"
  },
  {
    "text": "It may not be available yet ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=370"
  },
  {
    "text": "because the loading operation has not completed, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=372"
  },
  {
    "text": "or there is insufficient allocated streaming memory. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=374"
  },
  {
    "text": "Having the lowest level mipmaps available ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=377"
  },
  {
    "text": "ensures that there is always some valid data to sample, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=379"
  },
  {
    "text": "even though it is of lower resolution. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=382"
  },
  {
    "text": "Metal’s sparse texture feature ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=384"
  },
  {
    "text": "improves on this texture streaming model in two ways. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=386"
  },
  {
    "text": "First, sparse textures provide texture access counters ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=390"
  },
  {
    "text": "that you can use to determine ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=393"
  },
  {
    "text": "how often each region of a sparse texture is accessed. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=395"
  },
  {
    "text": "This lets you prioritize texture loading, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=398"
  },
  {
    "text": "as regions that are accessed more often by the renderer ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=400"
  },
  {
    "text": "are generally more visible in the current view. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=402"
  },
  {
    "text": "Secondly, residency can be managed ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=405"
  },
  {
    "text": "at the sparse tile granularity instead of mipmap granularity. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=408"
  },
  {
    "text": "This lets you be even more efficient ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=411"
  },
  {
    "text": "with your texture memory, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=413"
  },
  {
    "text": "and allows for more visible texture detail where it counts. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=414"
  },
  {
    "text": "Taken together, sparse textures ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=418"
  },
  {
    "text": "let you stream more visible detail ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=420"
  },
  {
    "text": "with the same memory budget, improving quality. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=422"
  },
  {
    "text": "Now let’s look at how you create and use ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=425"
  },
  {
    "text": "sparse textures in Metal. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=427"
  },
  {
    "text": "To start using sparse textures, you first create a sparse heap ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=429"
  },
  {
    "text": "and then allocate one or more textures from it. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=433"
  },
  {
    "text": "New sparse textures are created initially ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=436"
  },
  {
    "text": "without any mapped sparse tiles. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=438"
  },
  {
    "text": "You need to request memory mappings from the heap ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=440"
  },
  {
    "text": "using the GPU. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=443"
  },
  {
    "text": "The memory is mapped in tile-sized units ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=445"
  },
  {
    "text": "called sparse tiles, similar to virtual memory pages. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=447"
  },
  {
    "text": "Likewise, you need request the GPU to unmap tiles ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=451"
  },
  {
    "text": "when they are no longer needed. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=455"
  },
  {
    "text": "Sampling a sparse texture works just like a regular texture, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=456"
  },
  {
    "text": "and sampling unmapped regions return zeros. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=460"
  },
  {
    "text": "Finally, the texture access counters ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=463"
  },
  {
    "text": "can be read back from a sparse texture, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=465"
  },
  {
    "text": "to get estimates for how often each tile is accessed, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=467"
  },
  {
    "text": "so that you can precisely control and prioritize ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=470"
  },
  {
    "text": "when you map tiles for your textures. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=473"
  },
  {
    "text": "Let’s look at each of these steps in more detail. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=475"
  },
  {
    "text": "Here we have some Metal code ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=478"
  },
  {
    "text": "that creates a sparse texture heap ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=480"
  },
  {
    "text": "with a given memory size. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=481"
  },
  {
    "text": "We first calculate the size of our heap, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=483"
  },
  {
    "text": "and make sure it is a multiple of the sparse tile size. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=485"
  },
  {
    "text": "Here we use a local helper function ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=488"
  },
  {
    "text": "to round up our data size ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=490"
  },
  {
    "text": "to the nearest multiple of the sparse tile size. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=491"
  },
  {
    "text": "We can then generate the sparse heap descriptor; ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=495"
  },
  {
    "text": "we set the heap type to sparse, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=497"
  },
  {
    "text": "and specify the size of our heap in bytes. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=499"
  },
  {
    "text": "We then create the sparse heap using our MTLDevice object. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=502"
  },
  {
    "text": "Creating a sparse texture is very easy. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=507"
  },
  {
    "text": "First, we create a texture descriptor as normal, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=510"
  },
  {
    "text": "and then we create the texture using the sparse heap object. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=513"
  },
  {
    "text": "Now that we have seen how you can create the sparse texture, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=517"
  },
  {
    "text": "let’s take a look at how to map regions onto memory. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=520"
  },
  {
    "text": "The mapping and unmapping of regions of a texture ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=524"
  },
  {
    "text": "is done by encoding map and unmap commands ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=527"
  },
  {
    "text": "in a resource state command encoder. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=529"
  },
  {
    "text": "This encoder can be used to schedule ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=532"
  },
  {
    "text": "the map and unmap operations on the GPU timeline, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=534"
  },
  {
    "text": "similar to encoding other render commands in Metal. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=537"
  },
  {
    "text": "Let’s see how this looks in code. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=540"
  },
  {
    "text": "First we create the encoder. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=543"
  },
  {
    "text": "And then we simply encode a map operation; ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=546"
  },
  {
    "text": "we specify the texture and what regions, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=549"
  },
  {
    "text": "slice, and mip level of the texture we want to map. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=551"
  },
  {
    "text": "The region is now mapped, and you can blit ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=554"
  },
  {
    "text": "or create your texture data onto the mapped memory. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=556"
  },
  {
    "text": "To unmap a section, we follow the same procedure; ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=560"
  },
  {
    "text": "the only difference is the mode of the update we encode. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=563"
  },
  {
    "text": "Now that you have created and mapped our texture data, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=566"
  },
  {
    "text": "let’s move on to the sampling of sparse textures. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=568"
  },
  {
    "text": "Sampling from a sparse texture is no different ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=572"
  },
  {
    "text": "than sampling from a normal texture. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=574"
  },
  {
    "text": "There is well-defined behavior ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=576"
  },
  {
    "text": "in case an unmapped section is accessed. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=578"
  },
  {
    "text": "Sampling an unmapped region returns a vector of zeroes, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=580"
  },
  {
    "text": "and any writes are discarded. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=583"
  },
  {
    "text": "In addition to the standard sampling functions, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=586"
  },
  {
    "text": "Metal provides a sparse_sample function ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=588"
  },
  {
    "text": "that can be used in shaders to test for unmapped regions. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=590"
  },
  {
    "text": "Now that you’ve seen how to create, map, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=594"
  },
  {
    "text": "and sample sparse textures, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=596"
  },
  {
    "text": "let’s look at a simple implementation. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=598"
  },
  {
    "text": "One way to efficiently sample sparse textures ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=601"
  },
  {
    "text": "is to perform fallback sampling. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=604"
  },
  {
    "text": "In your shader, you can first try to fetch texels ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=606"
  },
  {
    "text": "using the sparse_sample method, and if that fails, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=609"
  },
  {
    "text": "you can fall back to a lower-level mipmap. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=612"
  },
  {
    "text": "By always keeping the lower mipmap loaded, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=615"
  },
  {
    "text": "you are guaranteed to find a valid sample. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=617"
  },
  {
    "text": "And to better support fallback sampling, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=620"
  },
  {
    "text": "the Metal shading language also supports a new argument ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=623"
  },
  {
    "text": "on texture methods called min LOD clamp. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=626"
  },
  {
    "text": "Min LOD clamp lets you set ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=629"
  },
  {
    "text": "the highest mipmap in the chain that can be accessed. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=631"
  },
  {
    "text": "This lets you guarantee a valid sample ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=634"
  },
  {
    "text": "by specifying the highest mipmap that you know you have data for. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=636"
  },
  {
    "text": "Let’s look at that in code. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=640"
  },
  {
    "text": "Here we have a fragment shader ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=643"
  },
  {
    "text": "that samples from a sparse texture. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=644"
  },
  {
    "text": "You start sampling your sparse texture ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=647"
  },
  {
    "text": "using the sparse_sample method, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=649"
  },
  {
    "text": "which returns a sparse_color object. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=651"
  },
  {
    "text": "You can then call the resident method on the returned object ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=653"
  },
  {
    "text": "to determine if the GPU sampled mapped data. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=656"
  },
  {
    "text": "If it did, you retrieve the sampled value and return it. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=659"
  },
  {
    "text": "Otherwise you sample the sparse texture again, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=663"
  },
  {
    "text": "but this time with an LOD clamp ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=665"
  },
  {
    "text": "to force the sampler to bypass higher mipmaps. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=668"
  },
  {
    "text": "Since you guaranteed that this mipmap ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=670"
  },
  {
    "text": "and lower mipmaps have data, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=672"
  },
  {
    "text": "the second sampling call is made using the normal sample method. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=674"
  },
  {
    "text": "Now that you’ve seen the functions ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=678"
  },
  {
    "text": "for mapping and sampling sparse texture data, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=679"
  },
  {
    "text": "let’s talk a little bit about how to decide ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=682"
  },
  {
    "text": "when to map or free sparse texture tiles. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=684"
  },
  {
    "text": "Traditional texture streaming systems ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=689"
  },
  {
    "text": "manually collect app-level statistics ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=690"
  },
  {
    "text": "to help prioritize texture residency. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=693"
  },
  {
    "text": "These methods are often coarse ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=696"
  },
  {
    "text": "at the mipmap or mesh granularity ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=697"
  },
  {
    "text": "to help manage the overhead. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=700"
  },
  {
    "text": "Metal instead supports a fine-grained solution ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=701"
  },
  {
    "text": "called texture access counters. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=704"
  },
  {
    "text": "These counters accurately track ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=706"
  },
  {
    "text": "how often sparse tiles are accessed by the GPU ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=708"
  },
  {
    "text": "with very low overhead. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=711"
  },
  {
    "text": "Texture access counters are queried from the GPU. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=713"
  },
  {
    "text": "Let’s look at how this works. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=716"
  },
  {
    "text": "This Metal example will collect the texture access counters ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=719"
  },
  {
    "text": "from the GPU. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=722"
  },
  {
    "text": "You start by creating a buffer to contain the sampled counters. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=723"
  },
  {
    "text": "And then you encode a blit to copy the counters ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=727"
  },
  {
    "text": "from our sparse texture to our buffer, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=729"
  },
  {
    "text": "specifying the mip level, slice, and region you’re interested in. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=732"
  },
  {
    "text": "Traditional texture streaming techniques ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=736"
  },
  {
    "text": "have served us very well over the years, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=738"
  },
  {
    "text": "and given a fixed memory budget, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=740"
  },
  {
    "text": "we can stream in the mip levels for the textures that user sees. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=742"
  },
  {
    "text": "When the texture budget gets exhausted, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=745"
  },
  {
    "text": "we can no longer stream in higher resolution mip levels ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=747"
  },
  {
    "text": "and we start seeing uniformly blurry textures. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=750"
  },
  {
    "text": "But with sparse textures, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=753"
  },
  {
    "text": "you can now get a better usage of your memory. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=755"
  },
  {
    "text": "You can map the memory to make room ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=757"
  },
  {
    "text": "for the individual texture tiles that the user sees, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=759"
  },
  {
    "text": "at the quality level that is most appropriate ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=761"
  },
  {
    "text": "for each texture tile within a given mip level. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=764"
  },
  {
    "text": "This allows you to distribute texture memory ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=767"
  },
  {
    "text": "for the tiles that make the most visual impact. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=769"
  },
  {
    "text": "Additionally, this feature saves bandwidth ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=772"
  },
  {
    "text": "when streaming textures, as the sparse texture API ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=775"
  },
  {
    "text": "allows you to map and unmap individual tiles ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=778"
  },
  {
    "text": "instead of having to copy and rearrange ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=781"
  },
  {
    "text": "entire mipmap chains in memory during streaming. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=783"
  },
  {
    "text": "That’s it for sparse textures, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=786"
  },
  {
    "text": "a really important memory optimization ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=787"
  },
  {
    "text": "that will also improve texture streaming quality. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=789"
  },
  {
    "text": "Now let’s move on to the runtime optimization technique ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=792"
  },
  {
    "text": "called rasterization rate maps. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=795"
  },
  {
    "text": "Rasterization rate maps ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=797"
  },
  {
    "text": "let you make better use of Retina displays ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=798"
  },
  {
    "text": "by rasterizing and shading the image areas that matter most ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=801"
  },
  {
    "text": "at highest resolution, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=804"
  },
  {
    "text": "while reducing quality where it's not perceived. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=806"
  },
  {
    "text": "Rasterization rate maps ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=809"
  },
  {
    "text": "let you rasterize and shade at multiple resolutions ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=810"
  },
  {
    "text": "by defining both a screen space and physical render target size, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=813"
  },
  {
    "text": "and a nonuniform mapping between the two spaces, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=817"
  },
  {
    "text": "to control the quality of each region. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=820"
  },
  {
    "text": "The physical resolution is smaller than the screen space, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=822"
  },
  {
    "text": "saving bandwidth and reducing the memory footprint. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=825"
  },
  {
    "text": "And the nonuniform mapping ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=827"
  },
  {
    "text": "results in higher-quality visuals ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=829"
  },
  {
    "text": "than the uniform upscale often used in games ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=831"
  },
  {
    "text": "at a fraction of the cost of rendering the entire screen ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=833"
  },
  {
    "text": "at native resolution. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=836"
  },
  {
    "text": "Let’s take a closer look at how this works. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=837"
  },
  {
    "text": "Here is a screenshot of a diffuse layer ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=841"
  },
  {
    "text": "from the g-buffer of a sample renderer. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=843"
  },
  {
    "text": "Traditional rendering draws geometry ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=845"
  },
  {
    "text": "by calculating the screen space coordinates of each vertex, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=847"
  },
  {
    "text": "and then rasterizing the resulting primitives ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=850"
  },
  {
    "text": "in screen space to produce fragments. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=852"
  },
  {
    "text": "These screen space coordinates have a one-to-one mapping ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=855"
  },
  {
    "text": "to the coordinates of the physical render target ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=857"
  },
  {
    "text": "during rasterization. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=860"
  },
  {
    "text": "With rasterization rate maps, you can configure the rasterizer ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=861"
  },
  {
    "text": "to map screen space coordinates unevenly when creating fragments ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=865"
  },
  {
    "text": "thus reducing the number of total fragments produced ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=869"
  },
  {
    "text": "and simultaneously rendering to a smaller render target. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=871"
  },
  {
    "text": "In both images, the white grid corresponds ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=875"
  },
  {
    "text": "to an evenly spaced grid in virtual screen space. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=877"
  },
  {
    "text": "But as you can see here, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=880"
  },
  {
    "text": "it is distributed unevenly in physical space. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=882"
  },
  {
    "text": "In this example, we’ve used rasterization rate maps ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=884"
  },
  {
    "text": "to keep the screen resolution in the center of the screen, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=887"
  },
  {
    "text": "but reducing it towards the edges of the screen. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=890"
  },
  {
    "text": "To see this more clearly, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=893"
  },
  {
    "text": "let’s zoom in on one of the center tiles. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=894"
  },
  {
    "text": "The resolution of this physical tile ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=897"
  },
  {
    "text": "matches the resolution of the same region ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=900"
  },
  {
    "text": "within the g-buffer. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=902"
  },
  {
    "text": "But as you move towards the edge of the screen, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=903"
  },
  {
    "text": "the quality is reduced ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=905"
  },
  {
    "text": "by effectively reducing the physical space ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=907"
  },
  {
    "text": "dedicated to that tile. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=909"
  },
  {
    "text": "This leads to a distorted image in your physical image, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=911"
  },
  {
    "text": "but we will show that this mapping ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=913"
  },
  {
    "text": "can be reversed to create an undistorted final image. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=915"
  },
  {
    "text": "But first, let’s take a look at how the mappings are defined. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=919"
  },
  {
    "text": "The mapping is defined as two 1D functions ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=922"
  },
  {
    "text": "in the X and Y axes of the screen space. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=926"
  },
  {
    "text": "You describe these functions in Metal ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=928"
  },
  {
    "text": "using a series of control points ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=930"
  },
  {
    "text": "defining the quality requirements. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=932"
  },
  {
    "text": "In this image, we can see the effective rasterization rate ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=935"
  },
  {
    "text": "across the screen, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=937"
  },
  {
    "text": "given our two 1D functions along the axis. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=939"
  },
  {
    "text": "A quality level of one means that fragment shader is invoked ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=941"
  },
  {
    "text": "for every screen space pixel along the axis. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=945"
  },
  {
    "text": "And a quality level of .5 ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=948"
  },
  {
    "text": "means that for at least 50 percent of the pixels, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=950"
  },
  {
    "text": "a fragment shader is invoked along a given axis. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=952"
  },
  {
    "text": "A quality level of zero means that each fragment shader ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=955"
  },
  {
    "text": "will be invoked at the minimum rate supported by Metal. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=957"
  },
  {
    "text": "Metal will resample these control points ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=960"
  },
  {
    "text": "to create a final rate map. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=962"
  },
  {
    "text": "Even though you don’t control the final mapping directly, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=964"
  },
  {
    "text": "Metal guarantees that your minimum quality is preserved. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=967"
  },
  {
    "text": "Now let’s create this mapping with Metal. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=971"
  },
  {
    "text": "Here is the Metal code ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=973"
  },
  {
    "text": "that builds the rasterization rate map you just saw. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=974"
  },
  {
    "text": "First, you define the rasterization function. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=978"
  },
  {
    "text": "In this example we will use the five values we showed previously ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=981"
  },
  {
    "text": "for both the horizontal and vertical axis of our map. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=985"
  },
  {
    "text": "You then fill the layer descriptor ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=988"
  },
  {
    "text": "to describe the quality across our rasterization rate map. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=989"
  },
  {
    "text": "You then create one ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=993"
  },
  {
    "text": "by providing the horizontal and vertical quality functions. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=994"
  },
  {
    "text": "With your quality defined, you now create ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=997"
  },
  {
    "text": "a Metal rasterization rate map descriptor ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1000"
  },
  {
    "text": "from the layer descriptor ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1002"
  },
  {
    "text": "and our final screen space resolution. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1003"
  },
  {
    "text": "Finally, you use your Metal device ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1006"
  },
  {
    "text": "to instantiate a rasterization rate map object ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1008"
  },
  {
    "text": "using that descriptor. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1011"
  },
  {
    "text": "Next we need to create the physical render target ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1013"
  },
  {
    "text": "for this map. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1015"
  },
  {
    "text": "Because the actual rasterization rate map rates ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1018"
  },
  {
    "text": "are implementation dependent, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1020"
  },
  {
    "text": "you need to first query the physical size of the resource ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1022"
  },
  {
    "text": "from the map. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1024"
  },
  {
    "text": "You then create the physical render target as usual: ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1026"
  },
  {
    "text": "specify the correct usage and storage properties, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1028"
  },
  {
    "text": "and instantiate the texture using your Metal device object. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1031"
  },
  {
    "text": "Finally, you combine the created texture and rasterization map ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1035"
  },
  {
    "text": "to set up your render pass and render as usual. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1038"
  },
  {
    "text": "And with that, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1042"
  },
  {
    "text": "you have rasterized your g-buffer nonuniformly. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1043"
  },
  {
    "text": "But what about shading the g-buffer in later passes? ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1046"
  },
  {
    "text": "With a traditional deferred shading pipeline, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1049"
  },
  {
    "text": "you can continue lighting ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1051"
  },
  {
    "text": "with the same rasterization rate map ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1053"
  },
  {
    "text": "because your light geometry will get correctly rasterized ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1054"
  },
  {
    "text": "in the same screen space as your g-buffer. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1057"
  },
  {
    "text": "With tiled deferred renderers, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1060"
  },
  {
    "text": "you will need to do a little more work. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1062"
  },
  {
    "text": "If you’re not already familiar ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1064"
  },
  {
    "text": "with the tiled deferred rendering, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1065"
  },
  {
    "text": "please see our Modern Rendering with Metal talk at WWDC 2019. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1066"
  },
  {
    "text": "With tiled deferred, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1072"
  },
  {
    "text": "your render target's physical space ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1073"
  },
  {
    "text": "is split into equally sized blocks of pixels ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1075"
  },
  {
    "text": "and each block performs light tile culling and shading. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1077"
  },
  {
    "text": "In the presented image, our sample code shows a heat map ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1081"
  },
  {
    "text": "for the number of lights per block of 32 by 32 pixels. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1084"
  },
  {
    "text": "Because screen space no longer corresponds to physical space, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1088"
  },
  {
    "text": "integrating rasterization rate maps ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1091"
  },
  {
    "text": "with tiled deferred renderers requires one additional step. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1093"
  },
  {
    "text": "The lighting shader will need to transform ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1096"
  },
  {
    "text": "the pixel coordinates in physical space ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1098"
  },
  {
    "text": "to the virtual screen space. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1100"
  },
  {
    "text": "This is the reverse mapping used during rasterization. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1102"
  },
  {
    "text": "Let’s take a look at how you can perform this reverse mapping ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1105"
  },
  {
    "text": "in your shaders. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1108"
  },
  {
    "text": "First you have to make ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1109"
  },
  {
    "text": "the rasterization rate map parameters ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1111"
  },
  {
    "text": "accessible to the shader. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1112"
  },
  {
    "text": "To do this, first you create a MTLBuffer ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1114"
  },
  {
    "text": "that can hold the parameters. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1116"
  },
  {
    "text": "You then copy the parameter data ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1119"
  },
  {
    "text": "into a MTLBuffer. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1120"
  },
  {
    "text": "And finally, bind the MTLBuffer to your shader. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1122"
  },
  {
    "text": "Now that the map is bound, let’s use it. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1125"
  },
  {
    "text": "In the shader, you now have access ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1128"
  },
  {
    "text": "to a rasterization_rate_map_data object ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1130"
  },
  {
    "text": "at the corresponding buffer bind point. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1132"
  },
  {
    "text": "You can use that object to instantiate ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1135"
  },
  {
    "text": "a rasterization_rate_map _decoder object. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1137"
  },
  {
    "text": "And then use the decoder ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1139"
  },
  {
    "text": "to transform between the physical and screen coordinates. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1141"
  },
  {
    "text": "Returning to our tiled deferred renderer, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1144"
  },
  {
    "text": "we use the decoder to perform tile culling ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1146"
  },
  {
    "text": "in the virtual screen space. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1148"
  },
  {
    "text": "Adapting your light culling to virtual screen space ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1151"
  },
  {
    "text": "means your tiles are no longer square, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1154"
  },
  {
    "text": "but now follow the correct area in screen space. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1156"
  },
  {
    "text": "Let’s compare this heat map ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1159"
  },
  {
    "text": "to the full, uniform resolution render. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1160"
  },
  {
    "text": "And back to the rasterization rate map version. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1163"
  },
  {
    "text": "As you can see, with rasterization rate maps, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1166"
  },
  {
    "text": "we’ve significantly reduced the amount of shaded tiles ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1169"
  },
  {
    "text": "on our screen. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1172"
  },
  {
    "text": "Finally, let’s consider how rasterization rate maps ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1174"
  },
  {
    "text": "are prepared for compositing and final presentation. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1176"
  },
  {
    "text": "Before displaying the final image to the screen, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1181"
  },
  {
    "text": "you need to unwrap it using a full screen pass ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1183"
  },
  {
    "text": "that transforms the physical space texture ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1185"
  },
  {
    "text": "to a high-resolution surface ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1187"
  },
  {
    "text": "using the shader mapping just described. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1189"
  },
  {
    "text": "As you can see, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1191"
  },
  {
    "text": "it is very difficult to notice the quality trade-offs ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1193"
  },
  {
    "text": "despite the aggressive falloffs ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1196"
  },
  {
    "text": "that were chosen for this sample. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1197"
  },
  {
    "text": "We expect rasterization rate maps ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1201"
  },
  {
    "text": "to be combined with other techniques, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1202"
  },
  {
    "text": "such as depth of field, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1204"
  },
  {
    "text": "to hide the quality tradeoff. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1206"
  },
  {
    "text": "That’s it for rasterization rate maps. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1208"
  },
  {
    "text": "Let’s move on to vertex amplification. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1210"
  },
  {
    "text": "Vertex amplification lets you reduce geometry processing ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1214"
  },
  {
    "text": "in multi-view rendering cases. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1217"
  },
  {
    "text": "Multi-layer and multi-viewport rendering ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1220"
  },
  {
    "text": "reduce the number of draw calls needed ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1222"
  },
  {
    "text": "to target each view using instancing. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1224"
  },
  {
    "text": "But that doesn’t eliminate the GPU cost ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1227"
  },
  {
    "text": "of processing each of these instances. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1229"
  },
  {
    "text": "Many multi-layer and multi-viewport ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1232"
  },
  {
    "text": "rendering techniques share geometry between views. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1233"
  },
  {
    "text": "For example, between the cascades of shadow maps ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1236"
  },
  {
    "text": "or the sides of an environment map. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1239"
  },
  {
    "text": "Each of those instances ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1241"
  },
  {
    "text": "typically transform that geometry ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1242"
  },
  {
    "text": "in almost the same way. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1244"
  },
  {
    "text": "So even though the position is unique per view, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1246"
  },
  {
    "text": "attributes such as normals, tangents, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1249"
  },
  {
    "text": "and texture coordinates are identical. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1251"
  },
  {
    "text": "Vertex amplification lets you process ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1254"
  },
  {
    "text": "those shared attributes only once, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1256"
  },
  {
    "text": "increasing the efficiency of your vertex shading. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1258"
  },
  {
    "text": "Let’s consider the use case of cascaded shadow maps ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1261"
  },
  {
    "text": "in more detail. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1264"
  },
  {
    "text": "Depending on the view distance, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1266"
  },
  {
    "text": "a renderer might split its shadow maps ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1268"
  },
  {
    "text": "into one, two, or three or more overlapping shadow cascades. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1270"
  },
  {
    "text": "As we increase the number of cascades, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1274"
  },
  {
    "text": "we also increase the size of the virtual world ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1276"
  },
  {
    "text": "that each cascade covers. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1279"
  },
  {
    "text": "This causes the larger, more distant cascades ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1281"
  },
  {
    "text": "to accumulate more geometry in them, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1284"
  },
  {
    "text": "compared to closer cascades. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1285"
  },
  {
    "text": "And with more cascades, the number of objects ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1288"
  },
  {
    "text": "that render into more than one cascade increases. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1291"
  },
  {
    "text": "Now let’s consider how cascaded shadow maps ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1294"
  },
  {
    "text": "are traditionally rendered and the associated costs. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1296"
  },
  {
    "text": "Before multi-view rendering, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1300"
  },
  {
    "text": "you would simply draw into each cascade separately. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1302"
  },
  {
    "text": "This increased both the GPU and CPU overhead. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1304"
  },
  {
    "text": "Each vertex must be fetched and shaded multiple times, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1308"
  },
  {
    "text": "and each vertex is also output multiple times. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1311"
  },
  {
    "text": "Multi-view instance rendering uses the instance ID ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1314"
  },
  {
    "text": "to map each primitive to its destination view. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1317"
  },
  {
    "text": "It eliminates the CPU cost of multiple draw calls, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1320"
  },
  {
    "text": "but the GPU cost remains the same. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1323"
  },
  {
    "text": "Using instancing for layered rendering ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1326"
  },
  {
    "text": "also complicates rendering of actual instanced geometry, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1328"
  },
  {
    "text": "since instance ID now has to encode ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1331"
  },
  {
    "text": "both the actual instance ID and the target layer. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1334"
  },
  {
    "text": "Vertex amplification eliminates the duplicate fetch, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1338"
  },
  {
    "text": "shading, and output. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1340"
  },
  {
    "text": "It also provides a separate amplification ID. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1342"
  },
  {
    "text": "Let’s take a look at a vertex amplification in action. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1345"
  },
  {
    "text": "Existing vertex functions can be easily adapted ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1349"
  },
  {
    "text": "to vertex amplification. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1351"
  },
  {
    "text": "In this example, we’re going to calculate ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1353"
  },
  {
    "text": "a unique position per amplification, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1355"
  },
  {
    "text": "but share the color calculation across all amplifications. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1358"
  },
  {
    "text": "We start by declaring our VertexOutput ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1362"
  },
  {
    "text": "with two attributes. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1364"
  },
  {
    "text": "The compiler can usually infer ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1366"
  },
  {
    "text": "if an attribute is unique or shared, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1367"
  },
  {
    "text": "but for complicated shaders, you can also be explicit ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1370"
  },
  {
    "text": "about which attributes are shared. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1373"
  },
  {
    "text": "The compiler will report an error ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1375"
  },
  {
    "text": "when shared attribute calculations ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1377"
  },
  {
    "text": "are dependent on amplification ID. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1379"
  },
  {
    "text": "Next we declare a function argument ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1382"
  },
  {
    "text": "holding the amplification ID. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1383"
  },
  {
    "text": "Any calculations associated with this ID ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1386"
  },
  {
    "text": "are amplified per shader invocation. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1388"
  },
  {
    "text": "The color attribute is not associated with that ID ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1391"
  },
  {
    "text": "so it will only be executed once. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1393"
  },
  {
    "text": "But the position is dependent on the ID ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1396"
  },
  {
    "text": "to look up the correct view projection matrix, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1398"
  },
  {
    "text": "and so the entire expression is amplified. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1400"
  },
  {
    "text": "That’s it for the shader code. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1403"
  },
  {
    "text": "Now let's see how we set up the amplified draw calls. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1405"
  },
  {
    "text": "Let’s start by creating a pipeline state object ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1409"
  },
  {
    "text": "that enables amplification. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1411"
  },
  {
    "text": "The maximum amplification factor supported by Metal ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1413"
  },
  {
    "text": "can be queried from the device. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1416"
  },
  {
    "text": "In this case, let’s say you want an amplification factor of two. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1418"
  },
  {
    "text": "If supported, you set to maximum amplification factor ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1422"
  },
  {
    "text": "for the pipeline. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1425"
  },
  {
    "text": "If not supported, you can fall back ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1426"
  },
  {
    "text": "to traditional multi-view through instancing ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1428"
  },
  {
    "text": "or rely on doing multiple draw calls. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1431"
  },
  {
    "text": "Finally, you create the pipeline. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1433"
  },
  {
    "text": "Once the pipeline is created, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1436"
  },
  {
    "text": "and assuming that amplification is supported, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1437"
  },
  {
    "text": "you can start to encode your draws. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1440"
  },
  {
    "text": "Drawing with amplification requires ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1442"
  },
  {
    "text": "setting the amplification count and binding the viewMappings. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1444"
  },
  {
    "text": "viewMappings describe how to map the amplification ID ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1447"
  },
  {
    "text": "to target layer or viewport. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1451"
  },
  {
    "text": "If the vertex shader also exports a render target ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1453"
  },
  {
    "text": "or viewport array index, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1456"
  },
  {
    "text": "that index will serve as a base offset ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1457"
  },
  {
    "text": "into the viewMappings array. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1459"
  },
  {
    "text": "Now you can set the desired amplification ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1462"
  },
  {
    "text": "and encode the draws. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1464"
  },
  {
    "text": "Let’s take a closer look through the Metal frame debugger. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1466"
  },
  {
    "text": "In this sample render, we use VertexAmplification ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1469"
  },
  {
    "text": "to amplify all the draws that are rendered ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1472"
  },
  {
    "text": "to both cascades 2 and 3. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1474"
  },
  {
    "text": "Here we see that this draw call is rendered with a ViewMapping ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1477"
  },
  {
    "text": "that specifies two render targets. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1480"
  },
  {
    "text": "The mesh is rendered simultaneously ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1482"
  },
  {
    "text": "into the second cascade shown on the left, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1484"
  },
  {
    "text": "and the third cascade, shown both on the right ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1486"
  },
  {
    "text": "and in the geometry viewer. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1489"
  },
  {
    "text": "That’s it for vertex amplification. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1491"
  },
  {
    "text": "Let’s move on to argument buffers ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1493"
  },
  {
    "text": "and how they’ve been extended for the A13. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1495"
  },
  {
    "text": "We introduced argument buffers with Metal 2. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1499"
  },
  {
    "text": "Argument buffers allow you to encode constants, textures, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1502"
  },
  {
    "text": "samplers, and buffer arguments into MTLBuffers.",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1504"
  },
  {
    "text": "By encoding all your draw arguments ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1508"
  },
  {
    "text": "into a single Metal argument buffer, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1510"
  },
  {
    "text": "you can render complex scenes with minimal CPU overhead. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1512"
  },
  {
    "text": "Once encoded, you can reuse argument buffers ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1516"
  },
  {
    "text": "to avoid repeated redundant resource binding. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1519"
  },
  {
    "text": "Argument buffers are also necessary ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1522"
  },
  {
    "text": "to enable GPU-driven pipelines, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1524"
  },
  {
    "text": "by providing access to the entire scene’s draw arguments ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1526"
  },
  {
    "text": "on the GPU. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1529"
  },
  {
    "text": "You can then modify argument buffers in compute functions ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1531"
  },
  {
    "text": "to dynamically configure your scene, just in time. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1534"
  },
  {
    "text": "Tier 2 argument buffers dramatically enhance ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1538"
  },
  {
    "text": "the capabilities of argument buffers. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1540"
  },
  {
    "text": "With A13, your Metal functions can sample or write ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1542"
  },
  {
    "text": "to any texture in an argument buffer. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1545"
  },
  {
    "text": "You can also access a virtually unlimited number of textures ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1548"
  },
  {
    "text": "and many samplers. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1551"
  },
  {
    "text": "And argument buffers can now also reference ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1553"
  },
  {
    "text": "other argument buffers with multiple levels of indirection. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1555"
  },
  {
    "text": "This unlocks the ability to encode a single argument buffer ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1558"
  },
  {
    "text": "for all your scene data and access it in your draw ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1561"
  },
  {
    "text": "without needing to assemble argument buffers ahead of time ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1565"
  },
  {
    "text": "on GPU or CPU. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1567"
  },
  {
    "text": "Let’s look at an example. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1570"
  },
  {
    "text": "Here is an example scene object model hierarchy. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1571"
  },
  {
    "text": "We showed a similar example at ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1575"
  },
  {
    "text": "our Modern Rendering with Metal talk at WWDC 2019. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1576"
  },
  {
    "text": "The hierarchy describes all your geometry data, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1581"
  },
  {
    "text": "materials, and model data. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1583"
  },
  {
    "text": "With argument buffers, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1585"
  },
  {
    "text": "we can encode this object model directly. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1586"
  },
  {
    "text": "But with Tier 2 support ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1589"
  },
  {
    "text": "we can also use the hierarchy directly during rendering. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1590"
  },
  {
    "text": "Let’s take a look at an example shader. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1593"
  },
  {
    "text": "To start, recall that our argument buffers ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1596"
  },
  {
    "text": "are declared in the Metal shading language ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1599"
  },
  {
    "text": "as structures of constants, textures, samplers, and buffers. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1601"
  },
  {
    "text": "These declarations directly mirror ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1605"
  },
  {
    "text": "the example object hierarchy just described. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1607"
  },
  {
    "text": "The first is our material representation, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1610"
  },
  {
    "text": "and the second is our scene ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1612"
  },
  {
    "text": "that references the set of meshes, materials, and models. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1614"
  },
  {
    "text": "OK, so now let’s take a look at a fragment function ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1618"
  },
  {
    "text": "that shades using our scene directly. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1621"
  },
  {
    "text": "The first function parameter is our scene argument buffer. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1623"
  },
  {
    "text": "The second function parameter is our per-draw constants. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1627"
  },
  {
    "text": "In this example, it encodes the model ID for this draw, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1631"
  },
  {
    "text": "as well as the discrete level of detail, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1634"
  },
  {
    "text": "both chosen in an earlier compute pass. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1636"
  },
  {
    "text": "We then use these IDs ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1639"
  },
  {
    "text": "to fetch our material from the scene ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1641"
  },
  {
    "text": "using the IDs computed earlier. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1643"
  },
  {
    "text": "And we calculate the fragment color using the textures, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1645"
  },
  {
    "text": "constants, and samplers from the nested argument buffer. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1648"
  },
  {
    "text": "And that’s it! ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1652"
  },
  {
    "text": "No more intervening compute pass to gather material parameters ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1653"
  },
  {
    "text": "into per-draw argument buffers. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1657"
  },
  {
    "text": "The fragment shader ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1659"
  },
  {
    "text": "just uses the scene argument buffer directly. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1660"
  },
  {
    "text": "Before we move on though, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1663"
  },
  {
    "text": "I’d like to highlight the robust tool support ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1664"
  },
  {
    "text": "for argument buffers. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1666"
  },
  {
    "text": "With argument buffers and GPU-driven pipelines, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1668"
  },
  {
    "text": "your scene setup moves to the GPU, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1671"
  },
  {
    "text": "and so does any debugging. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1673"
  },
  {
    "text": "The Metal frame debugger allows you to easily debug and inspect ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1675"
  },
  {
    "text": "both argument buffers and the shaders that use them. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1680"
  },
  {
    "text": "You can use the buffer viewer to inspect all resources ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1683"
  },
  {
    "text": "in your argument buffer, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1686"
  },
  {
    "text": "and quickly jump to these resources ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1687"
  },
  {
    "text": "for further inspection. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1690"
  },
  {
    "text": "You can also use the shader debugger ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1692"
  },
  {
    "text": "to understand how your shaders are accessing or building ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1694"
  },
  {
    "text": "argument buffers. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1697"
  },
  {
    "text": "This is especially important ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1699"
  },
  {
    "text": "when calculating argument buffer indices ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1701"
  },
  {
    "text": "or modifying argument buffers on the GPU. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1703"
  },
  {
    "text": "That's it for Tier 2 argument buffers. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1706"
  },
  {
    "text": "Now let’s move on to a new class ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1709"
  },
  {
    "text": "of shader optimization techniques. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1710"
  },
  {
    "text": "SIMD group functions are a powerful tool ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1714"
  },
  {
    "text": "for optimizing compute and graphics functions. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1716"
  },
  {
    "text": "They allow a GPU workload to share data ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1719"
  },
  {
    "text": "and control flow information ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1722"
  },
  {
    "text": "by leveraging the architecture of the GPU. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1723"
  },
  {
    "text": "Let's unpack that by quickly reviewing ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1726"
  },
  {
    "text": "the SIMD execution model in Metal. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1728"
  },
  {
    "text": "Metal has always organized threads into SIMD groups ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1732"
  },
  {
    "text": "to exploit the single Instruction, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1736"
  },
  {
    "text": "multiple data nature of GPUs. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1738"
  },
  {
    "text": "You may have leveraged SIMD groups ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1740"
  },
  {
    "text": "in Metal compute functions ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1742"
  },
  {
    "text": "to reduce the costs of synchronizing ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1743"
  },
  {
    "text": "entire threadgroups by using SIMD group barriers instead. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1745"
  },
  {
    "text": "The threads of a SIMD group execute in lockstep, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1749"
  },
  {
    "text": "so execution barriers are not needed. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1752"
  },
  {
    "text": "A SIMD group barrier therefore ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1754"
  },
  {
    "text": "only synchronizes memory operations. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1756"
  },
  {
    "text": "SIMD group functions exploit this lockstep execution ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1759"
  },
  {
    "text": "to share data between its threads ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1763"
  },
  {
    "text": "using registers instead of threadgroup memory, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1765"
  },
  {
    "text": "and can significantly improve performance ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1768"
  },
  {
    "text": "when threadgroup memory bound. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1770"
  },
  {
    "text": "They’re also available for both compute and render functions. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1772"
  },
  {
    "text": "And as we’ll see in a bit, this enables ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1776"
  },
  {
    "text": "a very interesting render optimization technique. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1777"
  },
  {
    "text": "Let’s first start by building a better intuition ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1780"
  },
  {
    "text": "for SIMD execution with an example. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1783"
  },
  {
    "text": "Down the left side we represent a SIMD group as 32 lanes ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1786"
  },
  {
    "text": "starting with Lane 0. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1790"
  },
  {
    "text": "A lane is a single thread in a SIMD group. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1792"
  },
  {
    "text": "Now let’s make this SIMD group perform some work. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1794"
  },
  {
    "text": "First we have all lanes index an array, A, by its laneID ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1797"
  },
  {
    "text": "and store the result in a variable X. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1801"
  },
  {
    "text": "Note how each lane has its own value of X. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1804"
  },
  {
    "text": "In this execution model, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1807"
  },
  {
    "text": "the instruction to load the data from A is only fetched once ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1809"
  },
  {
    "text": "and executed simultaneously by 32 threads ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1812"
  },
  {
    "text": "that have their own indices. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1815"
  },
  {
    "text": "Now we read a second array, B, indexed by laneID ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1817"
  },
  {
    "text": "and store the result in Y. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1821"
  },
  {
    "text": "Finally we store the result of multiplying X and Y ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1823"
  },
  {
    "text": "in a third array, C. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1826"
  },
  {
    "text": "Since the instruction executed is only fetched once ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1828"
  },
  {
    "text": "for the whole group, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1831"
  },
  {
    "text": "all SIMD group threads execute in lockstep. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1832"
  },
  {
    "text": "SIMD group functions allow each thread in the group ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1835"
  },
  {
    "text": "to inspect register values of the entire SIMD group ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1838"
  },
  {
    "text": "with minimal overhead. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1841"
  },
  {
    "text": "This ability allows for some interesting functions.",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1843"
  },
  {
    "text": "First let’s introduce simd_max and apply it to variable Y. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1847"
  },
  {
    "text": "Each thread gets a Z value with the largest value from Y, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1852"
  },
  {
    "text": "as seen by any thread in the SIMD group. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1856"
  },
  {
    "text": "Next we have broadcast and apply it to X. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1858"
  },
  {
    "text": "In this example, we broadcast the value of Lane 0 ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1861"
  },
  {
    "text": "to all the other lanes in a single operation. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1865"
  },
  {
    "text": "Metal for A13 supports ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1868"
  },
  {
    "text": "many other similarly operating SIMD functions ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1870"
  },
  {
    "text": "such as shuffle, permute, and rotate across all lanes. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1873"
  },
  {
    "text": "For our final example we’ll take a look at simd_all, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1877"
  },
  {
    "text": "which tells each lane ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1880"
  },
  {
    "text": "whether an expression evaluates the same for all lanes. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1882"
  },
  {
    "text": "In this example the Z variable is indeed nine for all lanes, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1885"
  },
  {
    "text": "and we therefore return true. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1890"
  },
  {
    "text": "Likewise, simd_any tells whether an expression evaluates to true ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1892"
  },
  {
    "text": "for any lane. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1896"
  },
  {
    "text": "You can use simd_all to reduce divergence in your shaders ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1897"
  },
  {
    "text": "by choosing to take a more optimal path ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1901"
  },
  {
    "text": "when all threads have the same need. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1903"
  },
  {
    "text": "Let’s take a look at an example. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1905"
  },
  {
    "text": "Here is our fragment shader from earlier ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1907"
  },
  {
    "text": "with some optimizations using SIMD group functions. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1909"
  },
  {
    "text": "To recap, this function takes as inputs ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1913"
  },
  {
    "text": "the scene encoded as an argument buffer, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1915"
  },
  {
    "text": "uniforms, and the vertex stage_in. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1917"
  },
  {
    "text": "Typically, lighting functions evaluate various components ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1920"
  },
  {
    "text": "of the final color differently for transparent fragments ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1923"
  },
  {
    "text": "and thus require dynamic control flow at various points. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1926"
  },
  {
    "text": "Now, instead of evaluating the opacity for every fragment, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1930"
  },
  {
    "text": "here we use simd_all to check dynamically ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1934"
  },
  {
    "text": "if all the threads in the SIMD group ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1937"
  },
  {
    "text": "are computing the lighting for opaque fragments. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1939"
  },
  {
    "text": "If they are, we take an optimal path ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1942"
  },
  {
    "text": "that assumes only opaque objects. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1944"
  },
  {
    "text": "And if not, we fall back to the earlier path ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1947"
  },
  {
    "text": "that can light both opaque and transparent fragments. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1950"
  },
  {
    "text": "That’s it for SIMD group functions on A13. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1953"
  },
  {
    "text": "Let’s switch gears ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1957"
  },
  {
    "text": "and look at some of the exciting additions to ASTC on A13. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1958"
  },
  {
    "text": "As mentioned earlier in the video, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1964"
  },
  {
    "text": "the A13 GPU doubles the rate ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1965"
  },
  {
    "text": "of 16-bit floating point operations ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1968"
  },
  {
    "text": "and adds support for small 16-bit numbers ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1970"
  },
  {
    "text": "to better handle HDR processing. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1972"
  },
  {
    "text": "Apps take advantage of these improvements ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1975"
  },
  {
    "text": "without any modification; ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1977"
  },
  {
    "text": "HDR processing on the GPU just gets faster and more accurate. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1978"
  },
  {
    "text": "Apple Family 6 also adds support for a new set of pixel formats ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1983"
  },
  {
    "text": "that support the efficient storage and sampling of HDR data ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1987"
  },
  {
    "text": "called ASTC HDR. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1991"
  },
  {
    "text": "ASTC is a texture compression technology ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1994"
  },
  {
    "text": "supported on many platforms, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1997"
  },
  {
    "text": "providing high texture image quality ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=1999"
  },
  {
    "text": "at a fraction of the bandwidth and memory. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2001"
  },
  {
    "text": "It does so by supporting multiple bit rates ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2004"
  },
  {
    "text": "and input formats. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2006"
  },
  {
    "text": "The ASTC low dynamic range profile ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2008"
  },
  {
    "text": "has been supported since Apple GPU Family 2 ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2010"
  },
  {
    "text": "and is appropriate for compressing values ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2013"
  },
  {
    "text": "in the zero to one range. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2015"
  },
  {
    "text": "If your app is not already using ASTC ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2017"
  },
  {
    "text": "to save memory and bandwidth, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2019"
  },
  {
    "text": "we highly encourage you to do so. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2021"
  },
  {
    "text": "The high dynamic range profile is needed ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2024"
  },
  {
    "text": "to encode the larger brightness values found in HDR images. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2026"
  },
  {
    "text": "Without ASTC HDR, such images are typically stored ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2030"
  },
  {
    "text": "in 16-bit floating point pixel formats ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2034"
  },
  {
    "text": "at much higher memory cost. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2036"
  },
  {
    "text": "So how much storage can ASTC HDR save? ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2039"
  },
  {
    "text": "A lot. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2043"
  },
  {
    "text": "Let’s consider an example. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2044"
  },
  {
    "text": "HDR games often use low-resolution cube map textures ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2045"
  },
  {
    "text": "to represent high dynamic range environment maps ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2049"
  },
  {
    "text": "to light their scene, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2051"
  },
  {
    "text": "and typically place many such probes ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2052"
  },
  {
    "text": "across the game world or level. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2054"
  },
  {
    "text": "Without ASTC HDR, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2056"
  },
  {
    "text": "each probe can consume a significant amount of memory, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2058"
  },
  {
    "text": "and all such probes can easily consume ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2061"
  },
  {
    "text": "a large portion of your game’s memory budget. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2063"
  },
  {
    "text": "In this example, a 256 by 256 probe cube map alone ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2066"
  },
  {
    "text": "consumes 3MB. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2070"
  },
  {
    "text": "With ASTC HDR, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2072"
  },
  {
    "text": "the same probe would consume many times less memory. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2074"
  },
  {
    "text": "You can even vary the bit rate to really reduce the footprint. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2077"
  },
  {
    "text": "Creating an HDR texture is as simple as an LDR equivalent. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2081"
  },
  {
    "text": "In this example, we’re creating a four by four ASTC LDR texture. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2086"
  },
  {
    "text": "There is matching HDR format for every LDR format ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2091"
  },
  {
    "text": "so converting this to an HDR texture ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2095"
  },
  {
    "text": "just requires changing the pixel format. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2097"
  },
  {
    "text": "All right, that wraps up the new Metal features ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2100"
  },
  {
    "text": "for the A13 GPU. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2103"
  },
  {
    "text": "Let’s recap what we’ve learned. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2104"
  },
  {
    "text": "It enables higher quality texture streaming ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2107"
  },
  {
    "text": "with sparse textures. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2110"
  },
  {
    "text": "It lets you focus expensive shading to where needed ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2111"
  },
  {
    "text": "with rasterization rate maps, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2114"
  },
  {
    "text": "and eliminate redundant vertex processing ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2116"
  },
  {
    "text": "with vertex amplification. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2118"
  },
  {
    "text": "It also enables more flexible GPU-driven pipelines ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2120"
  },
  {
    "text": "with argument buffer Tier 2, and SIMD group sharing ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2123"
  },
  {
    "text": "with shuffle and ballot instructions. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2126"
  },
  {
    "text": "And finally, Metal now lets you save memory in HDR pipelines ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2129"
  },
  {
    "text": "with ASTC. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2133"
  },
  {
    "text": "For more information about Metal, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2135"
  },
  {
    "text": "the A13 GPU, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2137"
  },
  {
    "text": "and to find our latest sample code, ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2138"
  },
  {
    "text": "please visit developer.apple.com. ",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2140"
  },
  {
    "text": "Thank you.",
    "link": "https://developer.apple.com/videos/play/tech-talks-608/?time=2144"
  }
]