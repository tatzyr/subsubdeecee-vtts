[
  {
    "text": "♪ instrumental hip hop music ♪ ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=0"
  },
  {
    "text": "Hello and welcome. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=9"
  },
  {
    "text": "My name is Alè Segovia Azapian from the GPU Software team here at Apple. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=10"
  },
  {
    "text": "And I’m Mayur, also from the GPU Software team. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=15"
  },
  {
    "text": "Alè: In this session we are going to talk about bindless rendering. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=18"
  },
  {
    "text": "The bindless binding model is a modern way to provide resources to your shaders, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=21"
  },
  {
    "text": "unlocking advanced rendering techniques, such as ray tracing. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=25"
  },
  {
    "text": "For today, I'll start with a brief recap of how the bindless binding model works, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=29"
  },
  {
    "text": "and how you can easily adopt bindless in your games and apps with Metal 3.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=34"
  },
  {
    "text": "Bindless rendering aggregates data, which opens up new opportunities ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=40"
  },
  {
    "text": "to improve performance on the CPU and GPU. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=44"
  },
  {
    "text": "I'll give you two specific tips today to improve your CPU and GPU times.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=47"
  },
  {
    "text": "Then I'll hand it over to Mayur, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=53"
  },
  {
    "text": "and he’ll show you how the tools can help you adopt a bindless model.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=54"
  },
  {
    "text": "In the bindless model, resources are aggregated ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=59"
  },
  {
    "text": "and linked together with argument buffers. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=62"
  },
  {
    "text": "Conceptually, this is what this looks like. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=65"
  },
  {
    "text": "In this example, an array aggregates all the meshes in a scene. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=67"
  },
  {
    "text": "Unlike the traditional binding model, where you bind each resource independently ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=72"
  },
  {
    "text": "to a specific slot in a pipeline, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=75"
  },
  {
    "text": "in the bindless model, resources are first linked together in memory. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=77"
  },
  {
    "text": "This lets you bind a single buffer that your shaders can freely navigate ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=82"
  },
  {
    "text": "and access the resources they need ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=85"
  },
  {
    "text": "to calculate elaborate surfaces and lighting. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=87"
  },
  {
    "text": "After the app goes bindless, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=92"
  },
  {
    "text": "the ray tracing shaders can access all the data they need ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=94"
  },
  {
    "text": "to beautifully shade the reflections. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=97"
  },
  {
    "text": "The app makes the 3D models and textures, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=99"
  },
  {
    "text": "including the floor, the trucks, their materials, and even the sky, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=102"
  },
  {
    "text": "available to the ray tracing shaders ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=106"
  },
  {
    "text": "by placing all its data into argument buffers. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=108"
  },
  {
    "text": "Even better, when bindless rendering is paired with ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=112"
  },
  {
    "text": "other Metal features like Heaps, apps and games enjoy better performance, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=114"
  },
  {
    "text": "thanks to less pressure on the CPU. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=119"
  },
  {
    "text": "I'll talk about four specific enhancements in Metal 3 ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=122"
  },
  {
    "text": "that you may find useful for bindless rendering.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=125"
  },
  {
    "text": "Argument buffers are the fundamental Metal construct ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=129"
  },
  {
    "text": "that allows you to link your resources together. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=132"
  },
  {
    "text": "They reference resources such as textures and other buffers. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=135"
  },
  {
    "text": "Metal 3 makes writing argument buffers easier than ever ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=140"
  },
  {
    "text": "because now you no longer need an Argument encoder object. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=144"
  },
  {
    "text": "And the same is true for unbounded arrays. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=148"
  },
  {
    "text": "You can now allocate acceleration structures ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=151"
  },
  {
    "text": "from a Metal Heap ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=154"
  },
  {
    "text": "and the Shader Validation Layer alerts you ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=156"
  },
  {
    "text": "when resources aren’t resident in GPU memory. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=159"
  },
  {
    "text": "Together, these four features make it easier than ever to go bindless.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=162"
  },
  {
    "text": "In particular, writing argument buffers in Metal 3 is a joy. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=168"
  },
  {
    "text": "To encode a scene into argument buffers, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=174"
  },
  {
    "text": "you write into these buffers the scene data, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=176"
  },
  {
    "text": "such as instances, meshes, materials, and textures. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=178"
  },
  {
    "text": "In Metal 2, this is accomplished with an argument encoder. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=183"
  },
  {
    "text": "So first, I will recap how these objects work, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=187"
  },
  {
    "text": "and then I will show you how Metal 3 helps simplify your code. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=190"
  },
  {
    "text": "With argument encoders, the first step is to create the encoder instance. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=194"
  },
  {
    "text": "You do this via shader function reflection ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=199"
  },
  {
    "text": "or by describing the struct members to Metal. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=201"
  },
  {
    "text": "With the encoder instance, set its recording destination and offset ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=205"
  },
  {
    "text": "to the target argument buffer. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=209"
  },
  {
    "text": "And use its methods to write data into the buffer. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=212"
  },
  {
    "text": "Please check out the bindless session from last year ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=216"
  },
  {
    "text": "for a detailed refresher on argument buffers and argument encoders. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=218"
  },
  {
    "text": "Now this mechanism is great, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=222"
  },
  {
    "text": "but the encoder objects can sometimes be challenging to manage. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=224"
  },
  {
    "text": "Metal provides two mechanisms for creating argument encoders. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=228"
  },
  {
    "text": "It might not be clear which one is appropriate for your app. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=231"
  },
  {
    "text": "Additionally, using an argument encoder from multiple threads requires care. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=235"
  },
  {
    "text": "Developers, intuitively understand how to write a C struct, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=240"
  },
  {
    "text": "and with Metal 3, you can now do just that for your argument buffers. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=244"
  },
  {
    "text": "Metal 3 simplifies writing argument buffers by allowing you ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=249"
  },
  {
    "text": "to directly write into them like any other CPU-side structure. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=252"
  },
  {
    "text": "You now have access to the virtual GPU address ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=256"
  },
  {
    "text": "and Resource IDs of your resources. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=260"
  },
  {
    "text": "When you write these directly into your argument buffer, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=263"
  },
  {
    "text": "Metal now understands what resources you are referencing. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=266"
  },
  {
    "text": "It is functionally the same as previously encoding the reference ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=269"
  },
  {
    "text": "using an argument encoder, except an encoder isn't needed anymore. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=272"
  },
  {
    "text": "This capability is supported all devices with argument buffers tier 2 support. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=277"
  },
  {
    "text": "That is, any Mac from 2016 or newer, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=281"
  },
  {
    "text": "and any iOS device with the A13 bionic chip or newer.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=285"
  },
  {
    "text": "If you are unsure whether a device supports argument buffers tier 2, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=291"
  },
  {
    "text": "there is a convenient feature query in the MTLDevice object that you can use. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=294"
  },
  {
    "text": "This is what the process now looks like in Metal 3. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=300"
  },
  {
    "text": "First, define your CPU-visible structs, using a 64-bit type for buffer addresses, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=303"
  },
  {
    "text": "and MTLResourceID for textures. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=309"
  },
  {
    "text": "Then, allocate the argument buffer. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=313"
  },
  {
    "text": "You allocate buffers either directly from the MTLDevice, or from a MTLHeap. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=316"
  },
  {
    "text": "You get the buffer's contents and cast it to the argument buffer struct type. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=323"
  },
  {
    "text": "And finally, write the addresses and resource IDs to the struct members. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=329"
  },
  {
    "text": "Take a look at how this is done in the hybrid rendering demo. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=334"
  },
  {
    "text": "Here is the code. Notice how simple it is. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=337"
  },
  {
    "text": "The host-side struct directly stores the GPU address of the normals buffer. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=341"
  },
  {
    "text": "This is a 64-bit unsigned integer so I used uint64_t. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=346"
  },
  {
    "text": "Now that there is no encoder object, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=352"
  },
  {
    "text": "you simply use the size of the struct for your argument buffer. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=354"
  },
  {
    "text": "Metal guarantees that the size and alignment of the GPU and CPU structs ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=359"
  },
  {
    "text": "match across clang and the Metal shader compiler.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=363"
  },
  {
    "text": "Next, allocate the buffer as usual. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=368"
  },
  {
    "text": "And if a buffer’s storage mode is Managed or Shared, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=373"
  },
  {
    "text": "get a direct pointer to the buffer and cast it to the struct type. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=376"
  },
  {
    "text": "And finally, set the normals member to the gpuAddress, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=381"
  },
  {
    "text": "and optionally, an offset that you must align to the GPU’s memory requirements.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=385"
  },
  {
    "text": "One thing I want to highlight is how the structure declaration changes ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=392"
  },
  {
    "text": "between the Metal Shading Language and the C declaration. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=395"
  },
  {
    "text": "In this example, these are kept separate, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=399"
  },
  {
    "text": "but if you prefer, you can have a single struct declaration in a shared header ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=402"
  },
  {
    "text": "and use conditional compilation to distinguish between ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=406"
  },
  {
    "text": "the shader compiler types and the C types.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=409"
  },
  {
    "text": "Here’s a unified declaration in C. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=413"
  },
  {
    "text": "The __METAL_VERSION__ macro is only defined when compiling shader code. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=416"
  },
  {
    "text": "Use it to separate GPU and CPU code in header declarations. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=420"
  },
  {
    "text": "If your app targets C++, you can take this further ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=425"
  },
  {
    "text": "and use templates to make the declarations even more uniform.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=429"
  },
  {
    "text": "Check out the argument buffer sample code for the best practices. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=433"
  },
  {
    "text": "Now that's how you write one struct, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=438"
  },
  {
    "text": "but you can also write many structs using unbounded arrays. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=440"
  },
  {
    "text": "You could already implement unbounded arrays in Metal using argument encoders, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=444"
  },
  {
    "text": "but Metal 3 simplifies the process even further ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=448"
  },
  {
    "text": "by bringing it closer to just filling out an array of structs.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=451"
  },
  {
    "text": "Here's what's different compared to just writing one struct. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=456"
  },
  {
    "text": "You now need to allocate enough storage for all structs you want to store. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=460"
  },
  {
    "text": "And then, iterate over the array, writing the data for each struct.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=466"
  },
  {
    "text": "Back to the code sample, first, expand the size of the buffer ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=473"
  },
  {
    "text": "to store as many structs as meshes in the scene. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=477"
  },
  {
    "text": "Notice how this is exactly the same you do for a CPU buffer: ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=481"
  },
  {
    "text": "multiply the size of the struct times the mesh count. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=485"
  },
  {
    "text": "I want to take a moment to note how powerful this is. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=490"
  },
  {
    "text": "This single variable completely controls the size of the array. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=493"
  },
  {
    "text": "The shader does not need to declare this size ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=497"
  },
  {
    "text": "to the Metal shader compiler at any point ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=499"
  },
  {
    "text": "and it's free to index into any position. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=501"
  },
  {
    "text": "This is part of the reason the bindless model is so flexible in Metal, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=504"
  },
  {
    "text": "because you write shaders that access arrays of any size with no constraints. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=508"
  },
  {
    "text": "It just works! ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=512"
  },
  {
    "text": "Next, allocate the buffer of this size ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=516"
  },
  {
    "text": "and cast the pointer to the contents to the correct mesh struct type.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=520"
  },
  {
    "text": "Now that the buffer is large enough, walk it with a simple for loop, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=526"
  },
  {
    "text": "straddling the size of the mesh struct. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=530"
  },
  {
    "text": "And finally, directly set the GPUAddress of each struct in the array, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=535"
  },
  {
    "text": "and optionally, an aligned offset.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=539"
  },
  {
    "text": "From the GPU side in the shader, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=544"
  },
  {
    "text": "this is one way to represent the unbounded array. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=546"
  },
  {
    "text": "Here, I declare it as a mesh pointer parameter that I pass to the shader.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=549"
  },
  {
    "text": "This makes it possible to freely access the contents directly, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=556"
  },
  {
    "text": "just as you would for any C array.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=559"
  },
  {
    "text": "Another option is to pull all the unbounded arrays into a struct. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=565"
  },
  {
    "text": "This helps keep shaders neat by aggregating data in a single place. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=570"
  },
  {
    "text": "In this example, all the meshes and materials ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=575"
  },
  {
    "text": "are brought together in a scene struct.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=577"
  },
  {
    "text": "Using the scene struct, the scene is passed directly to the shader ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=582"
  },
  {
    "text": "by binding a single buffer, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=585"
  },
  {
    "text": "instead of passing every unbounded array separately.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=587"
  },
  {
    "text": "And access is just like before, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=592"
  },
  {
    "text": "but now, the mesh array is reached through the scene struct.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=594"
  },
  {
    "text": "And that’s how to write argument buffers and unbounded arrays in Metal 3. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=599"
  },
  {
    "text": "The completely revamped API now makes it more intuitive ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=604"
  },
  {
    "text": "and matches what you do for CPU structs, or arrays of structs. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=607"
  },
  {
    "text": "With this year's ray tracing update, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=612"
  },
  {
    "text": "ray tracing acceleration structures can be allocated from Metal Heaps, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=614"
  },
  {
    "text": "along with your buffers and textures.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=617"
  },
  {
    "text": "This means they can be aggregated together amongst themselves ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=621"
  },
  {
    "text": "and with other resource types. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=624"
  },
  {
    "text": "This is great, because when you aggregate all acceleration structures into heaps, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=626"
  },
  {
    "text": "you can flag them all resident in a single call to useHeap. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=630"
  },
  {
    "text": "This is a huge opportunity for significant CPU savings ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=635"
  },
  {
    "text": "in your application's render thread.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=638"
  },
  {
    "text": "Here are some tips for working with acceleration structures in heaps. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=642"
  },
  {
    "text": "First, when allocated from heaps, acceleration structures have ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=646"
  },
  {
    "text": "alignment and size requirements that vary per device. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=649"
  },
  {
    "text": "There is a new query to check for the size and alignment ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=653"
  },
  {
    "text": "of an acceleration structure for heap allocation. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=656"
  },
  {
    "text": "Use the heapAccelerationStructureSize andAlignWithDescriptor method ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=660"
  },
  {
    "text": "of the MTLDevice to determine the SizeAndAlignment ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=663"
  },
  {
    "text": "for structure descriptors. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=666"
  },
  {
    "text": "Keep in mind, this is different ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=669"
  },
  {
    "text": "from the accelerationStructureSizes WithDescriptor method ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=671"
  },
  {
    "text": "in MTLDevice.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=674"
  },
  {
    "text": "Now that acceleration structures are in a MTLHeap object, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=678"
  },
  {
    "text": "call useHeap: to make them all resident in a single call. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=682"
  },
  {
    "text": "This is faster than calling useResource on each individual resource. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=685"
  },
  {
    "text": "And keep in mind that unless you opt your heap into hazard tracking, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=691"
  },
  {
    "text": "Metal does not prevent race conditions for resources allocated from them, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=695"
  },
  {
    "text": "so you will need to synchronize the acceleration structure builds ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=699"
  },
  {
    "text": "between one another and with ray tracing work. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=701"
  },
  {
    "text": "Don't worry though, I will talk more about this in a moment.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=704"
  },
  {
    "text": "For more details on this ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=708"
  },
  {
    "text": "and other ray tracing performance advances in Metal 3, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=710"
  },
  {
    "text": "make sure to check out ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=713"
  },
  {
    "text": "the \"Maximize your Metal ray tracing performance\" talk this year. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=714"
  },
  {
    "text": "Using heap-allocated acceleration structures provides an opportunity ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=718"
  },
  {
    "text": "to reduce your app's CPU usage when it matters the most. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=722"
  },
  {
    "text": "Last but not least, here's one of my favorite features this year: ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=726"
  },
  {
    "text": "Shader validation enhancements.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=729"
  },
  {
    "text": "On the topic of useResource and useHeap, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=733"
  },
  {
    "text": "it is very important that apps flag residency to Metal ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=736"
  },
  {
    "text": "for all indirectly accessed resources. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=739"
  },
  {
    "text": "Forgetting to do it means that the memory pages backing those resources ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=742"
  },
  {
    "text": "may not be present at rendering time. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=745"
  },
  {
    "text": "This can cause command buffer failures, GPU restarts, or even image corruption. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=748"
  },
  {
    "text": "Unfortunately, it is very common to run into these problems ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=754"
  },
  {
    "text": "when starting the bindless journey, because in bindless, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=757"
  },
  {
    "text": "the majority of scene resources are accessed indirectly, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=760"
  },
  {
    "text": "and shaders make pointer navigation decisions at runtime. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=763"
  },
  {
    "text": "This year, Metal 3 introduces new functionality ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=768"
  },
  {
    "text": "in the shader validation layer that will help you track down ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=771"
  },
  {
    "text": "missing residency of resources during command buffer execution. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=774"
  },
  {
    "text": "I'll show you a concrete example. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=778"
  },
  {
    "text": "During the update process of the Hybrid Rendering app, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=781"
  },
  {
    "text": "we encountered a real problem where reflections sometimes looked incorrect. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=783"
  },
  {
    "text": "I'll show you how the validation layer helped diagnose and fix this problem.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=789"
  },
  {
    "text": "To flag residency to Metal, the app stores all individual resources ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=795"
  },
  {
    "text": "not backed by heaps into a mutable set at load time. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=799"
  },
  {
    "text": "The app adds buffers and it adds textures. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=804"
  },
  {
    "text": "At rendering time, before the app dispatches the ray tracing kernel, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=808"
  },
  {
    "text": "it indicates to Metal that it uses all resources in the set. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=812"
  },
  {
    "text": "This is a simple process where the app iterates over the set ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=817"
  },
  {
    "text": "and calls useResource on each element. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=819"
  },
  {
    "text": "Metal then makes all these resources resident ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=823"
  },
  {
    "text": "before starting the ray tracing work. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=826"
  },
  {
    "text": "Here's part of the code where the app collects the resources into this set. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=829"
  },
  {
    "text": "The app does this as part of its argument buffer writing process. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=833"
  },
  {
    "text": "The app's loading function iterates over each submesh. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=838"
  },
  {
    "text": "It nabs the data it needs to write to the argument buffer-- ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=843"
  },
  {
    "text": "that is, index data and texture data for materials-- ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=846"
  },
  {
    "text": "then it stores the index buffer's address in the argument buffer. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=851"
  },
  {
    "text": "For materials, it then loops over the texture array, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=856"
  },
  {
    "text": "writing the texture GPU resource IDs into the argument buffer. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=858"
  },
  {
    "text": "And at the end, it adds all individual textures ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=864"
  },
  {
    "text": "from the submesh materials to the sceneResources set, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=867"
  },
  {
    "text": "so it can flag them resident at dispatch time.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=871"
  },
  {
    "text": "Unfortunately, there is a subtle bug here. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=875"
  },
  {
    "text": "The app would run the command buffer, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=879"
  },
  {
    "text": "and in some cases, reflections would be missing. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=881"
  },
  {
    "text": "Previously, it was hard to track this down. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=885"
  },
  {
    "text": "Now in Metal 3, the shader validation layer comes to the rescue. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=889"
  },
  {
    "text": "These kinds of problems now produce an error during command buffer execution, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=893"
  },
  {
    "text": "indicating what the problem is. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=897"
  },
  {
    "text": "The error message indicates ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=901"
  },
  {
    "text": "the name of the shader function that triggered the problem, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=903"
  },
  {
    "text": "the name of the pass, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=907"
  },
  {
    "text": "the metal file and line of code where it detected the access, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=909"
  },
  {
    "text": "and even the label of the buffer, its size, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=914"
  },
  {
    "text": "and the fact that it was not resident. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=917"
  },
  {
    "text": "As a pro tip, this is why it's always a good practice to label Metal objects. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=920"
  },
  {
    "text": "The tools use the labels, which is helpful when trying to identify ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=924"
  },
  {
    "text": "which object is which while debugging your app. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=927"
  },
  {
    "text": "With all this detailed information in hand, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=930"
  },
  {
    "text": "it's now easy to find the missing resource in the shader code. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=932"
  },
  {
    "text": "What's even better is that when the debug breakpoint is enabled, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=936"
  },
  {
    "text": "Xcode conveniently shows the exact line in the shader code ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=940"
  },
  {
    "text": "where shader validation detects the problem. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=944"
  },
  {
    "text": "In the case of the demo app, it is the indices buffer that is not resident. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=947"
  },
  {
    "text": "The fix is now straightforward. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=951"
  },
  {
    "text": "Going back to the code, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=955"
  },
  {
    "text": "the app now stores the missing index buffer ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=957"
  },
  {
    "text": "into the resident resource set. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=959"
  },
  {
    "text": "With these changes, later at ray tracing time, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=962"
  },
  {
    "text": "Metal knows to make the index buffers available to the GPU, solving the issue. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=965"
  },
  {
    "text": "This is an essential tool, and a complete game changer, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=970"
  },
  {
    "text": "that will potentially save you hours of debugging time in your bindless journey. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=973"
  },
  {
    "text": "So those are the enhancements Metal 3 brings to help you organize ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=979"
  },
  {
    "text": "and refer to bindless resources. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=982"
  },
  {
    "text": "Now I'm going to switch gears and talk about how to maximize ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=984"
  },
  {
    "text": "your game's performance when going bindless. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=987"
  },
  {
    "text": "In this section, I will cover two topics: ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=990"
  },
  {
    "text": "unretained resources, and untracked resources. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=992"
  },
  {
    "text": "These tips will help you get more performance out of both your CPU ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=996"
  },
  {
    "text": "and your GPU when you have long-lived and aggregate resources. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1000"
  },
  {
    "text": "Now, to talk about how to improve CPU performance with long-lived resources, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1004"
  },
  {
    "text": "I will first recap the Metal resource lifecycle. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1008"
  },
  {
    "text": "Objective-C and Swift handle object lifecycles via reference counting. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1011"
  },
  {
    "text": "Metal resources follow this model. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1016"
  },
  {
    "text": "Resources start with a retainCount of 1 ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1019"
  },
  {
    "text": "and the runtime deallocates them when all strong references disappear. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1022"
  },
  {
    "text": "Because the CPU and GPU operate in parallel, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1027"
  },
  {
    "text": "it would be a problem if the CPU deallocated a resource ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1031"
  },
  {
    "text": "by allowing its retainCount to reach 0 while the GPU is still using it.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1034"
  },
  {
    "text": "To prevent this, Metal command buffers create strong references ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1039"
  },
  {
    "text": "to all resources they use, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1043"
  },
  {
    "text": "ensuring their retainCount is always at least 1. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1045"
  },
  {
    "text": "Metal creates strong references for ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1050"
  },
  {
    "text": "resources you directly bind to a pipeline ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1053"
  },
  {
    "text": "with functions such as setVertexBuffer or setFragmentTexture-- ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1055"
  },
  {
    "text": "and this also includes render attachments-- ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1059"
  },
  {
    "text": "Metal heap objects you flag resident via the useHeap API, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1062"
  },
  {
    "text": "and indirect resources that you make resident ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1068"
  },
  {
    "text": "via the useResource API, even if they are part of a heap. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1070"
  },
  {
    "text": "For more details on Metal object lifecycles, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1075"
  },
  {
    "text": "please check out the \"Program Metal in C++ with metal-cpp\" talk this year. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1078"
  },
  {
    "text": "Now, it's very useful that Metal creates these references, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1083"
  },
  {
    "text": "because as a programmer, you never have to worry ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1086"
  },
  {
    "text": "that you might be deallocating an object while the GPU is still using it. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1088"
  },
  {
    "text": "This safety guarantee Metal gives you is very fast to execute, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1093"
  },
  {
    "text": "but it does comes with a small CPU cost. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1097"
  },
  {
    "text": "Now, in the bindless model, apps aggregate resources into heaps ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1100"
  },
  {
    "text": "and these tend to be long lived, matching the application's domain. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1105"
  },
  {
    "text": "For example, in a game, resources are alive for the duration of a whole level. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1108"
  },
  {
    "text": "When this is the case, it becomes unnecessary for Metal ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1114"
  },
  {
    "text": "to provide additional guarantees about resource lifecycles.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1116"
  },
  {
    "text": "What you can do then is recoup this CPU cost ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1121"
  },
  {
    "text": "by asking Metal command buffers not to retain resources they reference.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1124"
  },
  {
    "text": "To turn off Metal's automatic resource retaining, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1130"
  },
  {
    "text": "simply create a command buffer with unretained references. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1133"
  },
  {
    "text": "You do this directly from the MTLCommandQueue, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1137"
  },
  {
    "text": "just like you create any regular command buffer. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1140"
  },
  {
    "text": "You don't need to make any other changes to your app, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1143"
  },
  {
    "text": "as long as you are already guaranteeing your resource lifecycles.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1145"
  },
  {
    "text": "Keep in mind that the granularity level for this setting ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1149"
  },
  {
    "text": "is the entire command buffer. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1152"
  },
  {
    "text": "It will either retain all referenced resources or none of them.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1154"
  },
  {
    "text": "In a small microbenchmark, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1159"
  },
  {
    "text": "we measured a CPU usage reduction of 2% in the command buffer's lifecycle ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1161"
  },
  {
    "text": "just by switching to command buffers with unretained references. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1166"
  },
  {
    "text": "but this time was spent entirely ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1169"
  },
  {
    "text": "creating and destroying unnecessary strong references.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1172"
  },
  {
    "text": "In summary, unretained resources provides an opportunity for some extra CPU savings ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1177"
  },
  {
    "text": "when you are already guaranteeing resource lifecycles. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1182"
  },
  {
    "text": "Similar to unretained resources, untracked resources ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1186"
  },
  {
    "text": "provides an opportunity to disable a safety feature ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1189"
  },
  {
    "text": "to obtain more performance. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1192"
  },
  {
    "text": "Many visual techniques consist in rendering to intermediate textures ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1195"
  },
  {
    "text": "and writing into buffers and then consuming them in later passes. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1198"
  },
  {
    "text": "Shadow mapping, skinning, and post-processing are good examples of this. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1202"
  },
  {
    "text": "Now, producing and immediately consuming resources ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1207"
  },
  {
    "text": "introduces read-after-write hazards. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1211"
  },
  {
    "text": "Additionally, when several passes write to the same resource, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1215"
  },
  {
    "text": "such as two render passes ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1218"
  },
  {
    "text": "drawing into the same attachment, one after the other, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1219"
  },
  {
    "text": "or two blit encoders write into the same resource, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1222"
  },
  {
    "text": "it produces write-after-write hazards ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1226"
  },
  {
    "text": "because of the way Metal schedules work on the GPU. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1228"
  },
  {
    "text": "When you use tracked resources, Metal automatically uses ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1233"
  },
  {
    "text": "synchronization primitives to avoid hazards on the GPU timeline. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1236"
  },
  {
    "text": "For example, Metal makes the GPU wait ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1241"
  },
  {
    "text": "for a compute skinning pass to finish writing into a buffer ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1243"
  },
  {
    "text": "before starting a scene rendering pass that reads from the same buffer.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1246"
  },
  {
    "text": "This is great, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1251"
  },
  {
    "text": "and it's a big part of why Metal is such an approachable graphics API, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1252"
  },
  {
    "text": "but there are some performance considerations for apps ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1257"
  },
  {
    "text": "that aggregate resources into heaps.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1259"
  },
  {
    "text": "Consider this example. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1263"
  },
  {
    "text": "Here, the GPU is busy, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1265"
  },
  {
    "text": "drawing two frames that do vertex skinning, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1266"
  },
  {
    "text": "render the scene, and apply tone mapping, one after the other. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1269"
  },
  {
    "text": "As the app keeps the GPU busy, Metal identifies opportunities ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1273"
  },
  {
    "text": "where render and compute work can overlap, based on resource dependencies. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1277"
  },
  {
    "text": "When there are no dependencies, and the conditions are right, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1282"
  },
  {
    "text": "Metal schedules work to overlap and run in parallel. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1286"
  },
  {
    "text": "This saturates the GPU and allows it to get more work done ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1289"
  },
  {
    "text": "in the same amount of wall-clock time.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1293"
  },
  {
    "text": "Now, when the app aggregates resources together in a heap, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1298"
  },
  {
    "text": "all of its subresources appear as a single one to Metal. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1301"
  },
  {
    "text": "This is what makes heaps so efficient to work with. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1305"
  },
  {
    "text": "But this means that Metal sees read and write work on the same resource ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1308"
  },
  {
    "text": "and must conservatively schedule work to avoid any race conditions, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1312"
  },
  {
    "text": "even when no actual hazard exists.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1316"
  },
  {
    "text": "This situation is called \"false sharing\" and, as you might expect, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1322"
  },
  {
    "text": "it increases the execution wall-clock time of the GPU work. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1326"
  },
  {
    "text": "So here's the performance tip. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1330"
  },
  {
    "text": "If you know there are no dependencies between the resources in the heap, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1332"
  },
  {
    "text": "then you can avoid this behavior.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1336"
  },
  {
    "text": "To avoid false sharing, you can opt resources out of hazard tracking ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1338"
  },
  {
    "text": "and directly signal fine-grained dependencies to Metal. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1343"
  },
  {
    "text": "You opt out of resource tracking ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1347"
  },
  {
    "text": "by setting a resource descriptor's hazardTracking property to Untracked. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1349"
  },
  {
    "text": "Because this is so important, it is the default behavior for heaps, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1354"
  },
  {
    "text": "as it allows you to unlock more opportunities for the GPU ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1357"
  },
  {
    "text": "to run your work in parallel right out of the gate. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1360"
  },
  {
    "text": "Once you start using untracked resources, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1363"
  },
  {
    "text": "you express dependencies using the following primitives. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1365"
  },
  {
    "text": "Depending on the situation, use Fences, Events, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1369"
  },
  {
    "text": "Shared events, or Memory barriers. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1374"
  },
  {
    "text": "Metal Fences synchronize access to one or more resources ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1378"
  },
  {
    "text": "across different render and compute passes, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1382"
  },
  {
    "text": "within the context of a single command queue. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1384"
  },
  {
    "text": "This is a split barrier kind-of primitive, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1387"
  },
  {
    "text": "so the consumer pass waits until the producer signals the Fence.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1390"
  },
  {
    "text": "The only requirement you need to keep in mind when using Fences ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1398"
  },
  {
    "text": "is to commit or enqueue your producer command buffers ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1402"
  },
  {
    "text": "before your consuming command buffers. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1406"
  },
  {
    "text": "When you can't guarantee this order, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1409"
  },
  {
    "text": "or need to synchronize across multiple queues on the same device, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1411"
  },
  {
    "text": "use MTL Events. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1414"
  },
  {
    "text": "Using Events, the consumer command buffer waits for the producer command buffer ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1417"
  },
  {
    "text": "to signal the Event with a given value. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1421"
  },
  {
    "text": "After it signals the value, it is safe to read the resource. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1425"
  },
  {
    "text": "Use Events to tell a GPU to pause work until a command signals an Event. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1428"
  },
  {
    "text": "MTLSharedEvents behave very similarly to regular Events, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1434"
  },
  {
    "text": "but work at larger scope that goes beyond a single GPU. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1438"
  },
  {
    "text": "Use these to synchronize access to resources ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1442"
  },
  {
    "text": "across different Metal devices and even with the CPU. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1444"
  },
  {
    "text": "For example, use Shared Events to process the results ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1448"
  },
  {
    "text": "of a GPU calculation from the CPU. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1451"
  },
  {
    "text": "Here is an example. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1454"
  },
  {
    "text": "The GPU in this case skins a mesh in a compute pass ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1456"
  },
  {
    "text": "and the CPU stores the pose to disk. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1459"
  },
  {
    "text": "Because these two are independent devices, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1463"
  },
  {
    "text": "use a Shared Event to have the CPU wait until the GPU produces the resource. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1465"
  },
  {
    "text": "In the beginning, the CPU unconditionally starts to wait ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1471"
  },
  {
    "text": "for the GPU to signal the Shared Event. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1474"
  },
  {
    "text": "When the GPU produces the resource and places it into unified memory, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1478"
  },
  {
    "text": "it signals the Shared Event. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1482"
  },
  {
    "text": "At this point, the waiting thread on the CPU wakes up ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1484"
  },
  {
    "text": "and safely consumes the resource.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1487"
  },
  {
    "text": "The last primitive type is Memory Barriers. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1492"
  },
  {
    "text": "A Memory Barrier forces all subsequent commands within a single render ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1495"
  },
  {
    "text": "or compute pass to wait until all the previous commands finish. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1498"
  },
  {
    "text": "The cost of a barrier is similar to the cost of a Fence in almost all cases. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1502"
  },
  {
    "text": "There is, however, one exception.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1508"
  },
  {
    "text": "That exception is barriers after the fragment stage in a render pass. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1514"
  },
  {
    "text": "These barriers have a very high cost ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1519"
  },
  {
    "text": "that’s similar to splitting the render pass. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1521"
  },
  {
    "text": "Metal disables barriers after the fragment stage on Apple GPUs ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1524"
  },
  {
    "text": "to help your apps stay on the fastest driver path. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1528"
  },
  {
    "text": "The Metal debug layer even generates a validation error ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1532"
  },
  {
    "text": "if you add an after-fragment barrier on Apple GPUs. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1535"
  },
  {
    "text": "It is recommended to use a Fence to synchronize resources ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1539"
  },
  {
    "text": "after the fragment stage.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1543"
  },
  {
    "text": "Here's a short summary of the synchronization primitives ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1546"
  },
  {
    "text": "and when to use them. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1548"
  },
  {
    "text": "Prefer using Fences for the lowest overhead ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1551"
  },
  {
    "text": "when committing or enqueueing work ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1554"
  },
  {
    "text": "to a single command queue in producer, then consumer order. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1555"
  },
  {
    "text": "Fences are great for the majority of common cases. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1559"
  },
  {
    "text": "When the submission order can't be guaranteed, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1564"
  },
  {
    "text": "or there are multiple command queues, use Metal Events. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1566"
  },
  {
    "text": "Shared Events allows synchronization of multiple GPUs ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1571"
  },
  {
    "text": "between themselves and with the CPU. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1574"
  },
  {
    "text": "Use them only in these specific multi-device cases. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1576"
  },
  {
    "text": "Use Memory Barriers for cases where it's desired to synchronize within a pass. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1580"
  },
  {
    "text": "Barriers are a fast primitive in most cases, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1585"
  },
  {
    "text": "such as concurrent compute passes, and vertex stages between draw calls. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1588"
  },
  {
    "text": "But friendly reminder, use a Fence between passes instead of a barrier ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1592"
  },
  {
    "text": "for synchronizing after the fragment stages, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1596"
  },
  {
    "text": "because these barriers are very expensive and Apple GPUs don't allow it.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1598"
  },
  {
    "text": "Using untracked resources and manual fine-grained tracking, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1604"
  },
  {
    "text": "you can now have all the advantages of data aggregation, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1607"
  },
  {
    "text": "while maximizing GPU parallelism. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1611"
  },
  {
    "text": "And those are the performance tips to get the most out of the CPU ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1615"
  },
  {
    "text": "and GPU when going bindless. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1619"
  },
  {
    "text": "I've talked a lot about how Metal 3 unlocks simplified ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1622"
  },
  {
    "text": "and efficient bindless workflows. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1625"
  },
  {
    "text": "But writing code is only half the equation. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1627"
  },
  {
    "text": "The other half is how the available tools can help you verify ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1629"
  },
  {
    "text": "how the GPU sees and executes work. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1632"
  },
  {
    "text": "I am now going to hand it over to Mayur ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1635"
  },
  {
    "text": "to talk about what's new with Metal 3 tooling for bindless. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1636"
  },
  {
    "text": "Mayur: Thank you Alè. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1639"
  },
  {
    "text": "Today, I'm excited to show you some of the great new features ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1642"
  },
  {
    "text": "in the Metal Debugger that will help you debug and optimize your bindless Apps. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1646"
  },
  {
    "text": "I just took a frame capture of the HybridRendering app ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1651"
  },
  {
    "text": "that Alè just showed you. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1654"
  },
  {
    "text": "When you capture a frame in the Metal Debugger, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1657"
  },
  {
    "text": "you'll arrive to the Summary page, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1659"
  },
  {
    "text": "which provides you with an overview of your frame ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1661"
  },
  {
    "text": "alongside helpful insights on how to improve your app's performance. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1664"
  },
  {
    "text": "But today, I’m excited to show you the new dependency viewer. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1670"
  },
  {
    "text": "To open it, just click on Dependencies here on the left. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1674"
  },
  {
    "text": "Here is the new dependency viewer ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1680"
  },
  {
    "text": "and it features a brand new design that’s packed with powerful new features. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1682"
  },
  {
    "text": "The dependency viewer shows you a graph-based representation ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1688"
  },
  {
    "text": "of your workload. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1692"
  },
  {
    "text": "Each node in the graph represents a pass, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1694"
  },
  {
    "text": "which is encoded by a command encoder, and its output resources. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1698"
  },
  {
    "text": "The edges represent resource dependencies between passes. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1705"
  },
  {
    "text": "New this year, you can analyze your workload ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1711"
  },
  {
    "text": "by focusing on two types of dependencies. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1714"
  },
  {
    "text": "data flow and synchronization. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1717"
  },
  {
    "text": "The solid lines represent data flow ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1720"
  },
  {
    "text": "and they show you how data flows in your app. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1723"
  },
  {
    "text": "The dotted lines represent synchronization and they show you dependencies ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1727"
  },
  {
    "text": "that introduce GPU synchronization between passes. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1732"
  },
  {
    "text": "To learn more, you can click on any encoder, resource, or edge, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1737"
  },
  {
    "text": "and the debugger will show you a lot of detailed information in the new sidebar. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1743"
  },
  {
    "text": "For example, this edge adds synchronization ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1749"
  },
  {
    "text": "and also has data flow between these passes. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1752"
  },
  {
    "text": "By default, the dependency viewer shows both data flow ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1757"
  },
  {
    "text": "and synchronization dependencies, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1761"
  },
  {
    "text": "but you can use this menu down here at the bottom ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1763"
  },
  {
    "text": "to focus on just one of the dependency types. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1767"
  },
  {
    "text": "Here, I will focus on just synchronization. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1771"
  },
  {
    "text": "As Alè said earlier, false sharing is a common problem ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1777"
  },
  {
    "text": "when reading and writing different resources from a tracked heap. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1781"
  },
  {
    "text": "The dependency viewer makes it easy to catch these issues. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1785"
  },
  {
    "text": "This demo I captured is from an early development version ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1790"
  },
  {
    "text": "that has this issue. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1794"
  },
  {
    "text": "If I click on this heap, the dependency viewer shows me ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1797"
  },
  {
    "text": "that this heap is tracked ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1802"
  },
  {
    "text": "and therefore adds synchronization between these two passes. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1804"
  },
  {
    "text": "The dependency viewer also highlights the resources allocated inside the heap, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1809"
  },
  {
    "text": "such as this render target texture that the render encoder stores, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1816"
  },
  {
    "text": "and a buffer that the compute encoder reads and writes to. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1821"
  },
  {
    "text": "The problem is this synchronization between these two passes is not needed ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1826"
  },
  {
    "text": "because the compute encoder is not using any resources from previous encoders. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1832"
  },
  {
    "text": "To remove this dependency, I can modify the app to use an untracked heap ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1839"
  },
  {
    "text": "and insert Fences where synchronization is needed. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1844"
  },
  {
    "text": "With that change, these two passes can now run in parallel. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1848"
  },
  {
    "text": "Another great improvement in Xcode 14 ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1855"
  },
  {
    "text": "to help debug your bindless apps is the new resource list. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1858"
  },
  {
    "text": "I can navigate to a draw call that I want to debug and open it. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1862"
  },
  {
    "text": "When using bindless, hundreds or even thousands of resources ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1869"
  },
  {
    "text": "are available to the GPU at any time. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1873"
  },
  {
    "text": "This year, the Metal debugger gives you the ability ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1877"
  },
  {
    "text": "to check which of these resources a draw call accessed, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1880"
  },
  {
    "text": "just by clicking on the \"Accessed\" mode at the top. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1884"
  },
  {
    "text": "Now the debugger shows me only the handful of resources ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1889"
  },
  {
    "text": "that this draw call accesses and the type of each access. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1893"
  },
  {
    "text": "This is really useful for understanding what resources your shader has accessed ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1900"
  },
  {
    "text": "from argument buffers. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1906"
  },
  {
    "text": "Knowing what resources your draw call uses is great, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1908"
  },
  {
    "text": "but if it shows resources that you weren’t expecting, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1913"
  },
  {
    "text": "you can use the shader debugger to figure out what’s going on. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1916"
  },
  {
    "text": "To start the shader debugger, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1921"
  },
  {
    "text": "just click on the debug button here in the bottom bar, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1923"
  },
  {
    "text": "select the pixel that you want to debug, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1927"
  },
  {
    "text": "and hit the Debug button. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1931"
  },
  {
    "text": "And now you are in the shader debugger. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1935"
  },
  {
    "text": "The shader debugger shows how your code was executed line by line, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1939"
  },
  {
    "text": "including which resources were accessed. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1944"
  },
  {
    "text": "For these lines, this shader reads textures from an argument buffer. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1949"
  },
  {
    "text": "I can expand the detailed views on the right sidebar ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1955"
  },
  {
    "text": "to check which resources were read. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1959"
  },
  {
    "text": "This can help identify issues where your shader accesses ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1963"
  },
  {
    "text": "the wrong argument buffer element. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1967"
  },
  {
    "text": "In this demo, I’ve shown you how to use the new dependency viewer ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1971"
  },
  {
    "text": "to analyze and validate resource dependencies, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1976"
  },
  {
    "text": "how to use the new resource list to understand what resources ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1979"
  },
  {
    "text": "a draw call accessed, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1983"
  },
  {
    "text": "and how to use the shader debugger to analyze, line by line, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1985"
  },
  {
    "text": "how a shader was executed. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1989"
  },
  {
    "text": "I can’t wait to see how you use these new features ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1992"
  },
  {
    "text": "to create great Metal bindless apps. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1995"
  },
  {
    "text": "Back to you Alè. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1997"
  },
  {
    "text": "Alè: Thank you, Mayur. That was an awesome demo. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=1999"
  },
  {
    "text": "To wrap up, Metal 3 brings a lot to the table for going bindless. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=2003"
  },
  {
    "text": "With simplified argument buffer encoding, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=2007"
  },
  {
    "text": "acceleration structures from heaps, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=2009"
  },
  {
    "text": "improvements to the validation layer and tools, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=2011"
  },
  {
    "text": "Metal 3 is an excellent API ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=2014"
  },
  {
    "text": "to bring effective and performant bindless to your games and apps. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=2016"
  },
  {
    "text": "With this year's enhancements, the hybrid rendering app is looking better than ever. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=2020"
  },
  {
    "text": "We are releasing this updated version of the app ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=2025"
  },
  {
    "text": "with full source code in the Metal sample code gallery. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=2027"
  },
  {
    "text": "You can download, study, and modify it, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=2031"
  },
  {
    "text": "and as an exercise, I challenge you to take it even further ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=2033"
  },
  {
    "text": "and add recursive reflections to the mirror surfaces. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=2036"
  },
  {
    "text": "I can't wait to see what you do with it. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=2039"
  },
  {
    "text": "There has never been a better time to go bindless with Metal 3. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=2041"
  },
  {
    "text": "Thank you for watching. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=2044"
  },
  {
    "text": "♪ instrumental hip hop music ♪",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10101/?time=2046"
  }
]