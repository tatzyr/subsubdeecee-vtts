[
  {
    "text": " ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=0"
  },
  {
    "text": "- Hello and welcome. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=9"
  },
  {
    "text": "My name is Marco Giordano, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=11"
  },
  {
    "text": "and I'm with the GPU Software Engineering team here at Apple. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=13"
  },
  {
    "text": "In this session I'll talk to you about ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=17"
  },
  {
    "text": "how to scale workloads across Apple M1 GPUs. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=19"
  },
  {
    "text": "If you work on complex compute workloads and want to know how to ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=23"
  },
  {
    "text": "take full advantage of Apple silicon hardware and achieve great scaling, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=26"
  },
  {
    "text": "this talk is the one for you. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=31"
  },
  {
    "text": "I will start by discussing compute scalability concepts ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=33"
  },
  {
    "text": "and how applications can naturally scale performance across the M1 GPU family. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=36"
  },
  {
    "text": "And then, I'll share step-by-step \"how-tos\" ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=42"
  },
  {
    "text": "and talk about what tools are available ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=45"
  },
  {
    "text": "to maximize compute scaling for your workloads. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=48"
  },
  {
    "text": "Let's start by understanding what scalability is ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=52"
  },
  {
    "text": "and why it is important for your workload.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=55"
  },
  {
    "text": "The Apple M1 GPU was designed from the ground up to scale ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=59"
  },
  {
    "text": "and to let your workload achieve excellent performance across the entire SOC family. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=62"
  },
  {
    "text": "The same GPU supporting all Metal 3 features scales from your 8-core iPad ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=68"
  },
  {
    "text": "all the way to your 64-core Mac Studio.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=73"
  },
  {
    "text": "To take advantage of the high level of scaling, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=77"
  },
  {
    "text": "having an app optimized for M1 is a great starting point. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=80"
  },
  {
    "text": "Many prominent pro apps have already been optimized for Apple M1 ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=84"
  },
  {
    "text": "and have been experiencing excellent scaling across all devices.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=89"
  },
  {
    "text": "For example, here we have Affinity Photo and DaVinci Resolve-- ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=94"
  },
  {
    "text": "photo and video editors from the post-production industry. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=99"
  },
  {
    "text": "These apps are achieving great scaling. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=104"
  },
  {
    "text": "Let's define what scalability really means and how you can achieve \"ideal\" scaling. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=107"
  },
  {
    "text": "GPU workload scalability is the capacity to improve performance ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=113"
  },
  {
    "text": "with an increased number of GPU cores. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=118"
  },
  {
    "text": "The chart on the right shows application speed-up ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=121"
  },
  {
    "text": "with an increasing GPU cores count. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=124"
  },
  {
    "text": "Linear proportion improvement is considered ideal.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=127"
  },
  {
    "text": "However, while working on your app, you might notice a type of scaling ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=132"
  },
  {
    "text": "which hits a plateau and scales with diminishing returns, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=136"
  },
  {
    "text": "or doesn't scale at all due to gaps in the GPU timeline.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=140"
  },
  {
    "text": "Or you might see another type scaling where the performance improves ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=145"
  },
  {
    "text": "but not uniformly across the stack ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=150"
  },
  {
    "text": "where the workload is hitting some GPU limiters, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=152"
  },
  {
    "text": "like here, between 24 to 32 or 48 to 64 cores.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=157"
  },
  {
    "text": "Your goal is to get as close as possible to linear scaling, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=164"
  },
  {
    "text": "and I will show you the tools and techniques ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=168"
  },
  {
    "text": "to identify bottlenecks and achieve the result you want.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=171"
  },
  {
    "text": "In the next section I will discuss the approaches to maximize GPU scaling. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=176"
  },
  {
    "text": "For every workload, you should first identify where the bottleneck is. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=181"
  },
  {
    "text": "Workloads can be limited either by computation or bandwidth. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=186"
  },
  {
    "text": "During the optimization process, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=191"
  },
  {
    "text": "you might end up bouncing between one and the other. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=194"
  },
  {
    "text": "If you are computational-bound, you might try to shift some of the load ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=196"
  },
  {
    "text": "to leverage memory to reduce computation, or vice versa. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=201"
  },
  {
    "text": "Bottlenecks can shift when you scale up. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=206"
  },
  {
    "text": "One good solution could be using Apple frameworks ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=209"
  },
  {
    "text": "like MPS or MPSGraph. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=212"
  },
  {
    "text": "if you can leverage their primitives, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=215"
  },
  {
    "text": "we made sure every compute kernel runs best on all the hardware. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=217"
  },
  {
    "text": "However, you can't replace everything with MPS, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=221"
  },
  {
    "text": "so it is critical to profile and understand your workload.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=224"
  },
  {
    "text": "I will first cover three items that can help minimize GPU gaps: ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=230"
  },
  {
    "text": "Improve your work distribution, eliminate GPU timeline gaps, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=234"
  },
  {
    "text": "and atomics operation considerations.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=238"
  },
  {
    "text": "Then I will explain how to optimize for GPU limiters ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=242"
  },
  {
    "text": "by first investigating the effect of compute grid shapes ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=246"
  },
  {
    "text": "and memory layouts of your workload ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=250"
  },
  {
    "text": "and finally by looking at a specific example in Blender Cycles. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=253"
  },
  {
    "text": "Start by focusing on minimizing GPU gaps. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=258"
  },
  {
    "text": "This kind of scaling can be the result of the GPU not being fully utilized, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=262"
  },
  {
    "text": "with gaps in the GPU timeline where the hardware is idle.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=267"
  },
  {
    "text": "Let's see if we can improve scaling by investigating work distribution.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=272"
  },
  {
    "text": "Small workloads usually do not saturate the whole GPU, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=277"
  },
  {
    "text": "and kernel synchronization has its cost, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=281"
  },
  {
    "text": "so both can prevent proper scaling. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=284"
  },
  {
    "text": "It is very important to understand how the workload gets mapped to the hardware, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=287"
  },
  {
    "text": "so let's talk about it.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=293"
  },
  {
    "text": "A workload is dispatched in the form of a 3D grid of threadgroups. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=295"
  },
  {
    "text": "Threadgroups are uniformly distributed to the GPU cores ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=300"
  },
  {
    "text": "and have access to threadgroup memory, which is limited in size, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=304"
  },
  {
    "text": "but very fast, local to the GPU core.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=309"
  },
  {
    "text": "A single threadgroup is further broken down into SIMD-groups, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=312"
  },
  {
    "text": "which are also known as waves or warps in other compute dialects.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=316"
  },
  {
    "text": "Checking the \"threadExecutionWidth\" on the compute pipeline state object ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=321"
  },
  {
    "text": "will return the SIMD width, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=326"
  },
  {
    "text": "and on all Apple GPUs, it is equal to 32.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=328"
  },
  {
    "text": "Threadgroups can have up to 1024 threads per threadgroup ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=333"
  },
  {
    "text": "and threads can share up to 32K of threadgroup memory.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=337"
  },
  {
    "text": "To keep the GPU busy, there should be enough work to do ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=342"
  },
  {
    "text": "on all the GPU cores.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=345"
  },
  {
    "text": "Here is an example of a grid to dispatch. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=348"
  },
  {
    "text": "Threadgroups are dispatched to GPU Clusters ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=351"
  },
  {
    "text": "and distributed among GPU cores.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=354"
  },
  {
    "text": "If there are too few threadgroups, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=359"
  },
  {
    "text": "the workload won't fully saturate the machine. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=361"
  },
  {
    "text": "Here's how to fix this.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=364"
  },
  {
    "text": "Start by computing how many threads the workload produces ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=368"
  },
  {
    "text": "and roughly see if the dispatch will saturate the whole machine.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=371"
  },
  {
    "text": "For relatively complex kernels, 1K to 2K concurrent threads per shader core ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=376"
  },
  {
    "text": "is considered a very good occupancy, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=382"
  },
  {
    "text": "so take 1 to 2K threads per GPU core as a rule of thumb. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=384"
  },
  {
    "text": "Now you can compute if you have enough work to fully saturate the hardware. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=390"
  },
  {
    "text": "The table here shows the lowest recommended number of threads ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=395"
  },
  {
    "text": "to saturate different SOCs.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=399"
  },
  {
    "text": "Another thing to consider would be avoiding ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=403"
  },
  {
    "text": "using unnecessarily large threadgroup sizes. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=405"
  },
  {
    "text": "Making threadgroups smaller will map the load to the hardware more uniformly. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=408"
  },
  {
    "text": "Using larger threadgroups might prevent a more uniform distribution, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=414"
  },
  {
    "text": "leading to imbalance in the GPU cores.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=418"
  },
  {
    "text": "It's best to use the smallest multiple of the SIMD width ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=422"
  },
  {
    "text": "that maps well to your workload.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=425"
  },
  {
    "text": "By using smaller threadgroups, the GPU has more opportunities ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=428"
  },
  {
    "text": "to better balance its workload.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=432"
  },
  {
    "text": "Please always check your kernel runtime performance ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=436"
  },
  {
    "text": "with Xcode or Instruments GPU Tools.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=439"
  },
  {
    "text": "In this GPU capture, for example, there is a kernel performing some computation. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=443"
  },
  {
    "text": "Occupancy is pretty low, which is unexpected. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=448"
  },
  {
    "text": "The compiler statistics show that max theoretical occupancy, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=452"
  },
  {
    "text": "which is new in Xcode 14, is 100%. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=456"
  },
  {
    "text": "This indicates there might not be enough threads--and indeed, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=460"
  },
  {
    "text": "we can see the algorithms starts to dispatch fewer and fewer threads, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=464"
  },
  {
    "text": "not saturating the machine anymore.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=468"
  },
  {
    "text": "Low occupancy might have several other causes. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=471"
  },
  {
    "text": "To get all the details, check the Metal Compute on MacBook Pro Tech talk.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=475"
  },
  {
    "text": "OK, now that workload is correctly distributed, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=481"
  },
  {
    "text": "it's time to make sure the GPU is always busy.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=485"
  },
  {
    "text": "Under-utilizing the GPU never leads to ideal scaling, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=489"
  },
  {
    "text": "and the worst case of under-utilizing is keeping it idle. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=493"
  },
  {
    "text": "The GPU can be idle because of GPU timeline gaps.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=498"
  },
  {
    "text": "Consider this example. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=503"
  },
  {
    "text": "Here is a workload using only 50% of the GPU ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=506"
  },
  {
    "text": "due to work serialization between CPU and GPU. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=510"
  },
  {
    "text": "In this case, overall task duration is the sum of CPU and GPU work ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=514"
  },
  {
    "text": "with no overlaps.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=519"
  },
  {
    "text": "Doubling the GPU cores makes the GPU track complete faster, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=522"
  },
  {
    "text": "but the CPU track is not affected. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=526"
  },
  {
    "text": "Overall performance increases only by 33%, far from ideal scaling.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=529"
  },
  {
    "text": "If the GPU cores are doubled again, the workload is even faster on the GPU, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=537"
  },
  {
    "text": "but overall latency is reduced by only 60% compared to the original time! ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=542"
  },
  {
    "text": "So GPU cores scaling brings diminishing returns in such cases. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=548"
  },
  {
    "text": "This is far from ideal. Let's fix it! ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=553"
  },
  {
    "text": "This Instrument trace from a M1 pro shows big GPU timeline gaps, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=557"
  },
  {
    "text": "and this will clearly prevent proper scaling.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=563"
  },
  {
    "text": "On M1 Ultra the same workload is indeed a bit faster, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=568"
  },
  {
    "text": "but the GPU idle time became higher ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=571"
  },
  {
    "text": "and the workload is not scaling well. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=574"
  },
  {
    "text": "The big gaps are caused by CPU synchronization ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=578"
  },
  {
    "text": "using the waitUntilCompleted on the command buffer.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=581"
  },
  {
    "text": "After changing the waiting logic and removing serialization, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=585"
  },
  {
    "text": "the GPU became fully utilized, which is great.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=589"
  },
  {
    "text": "Comparing the workload scaling ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=594"
  },
  {
    "text": "before and after, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=596"
  },
  {
    "text": "we can state that the scaling ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=597"
  },
  {
    "text": "became much closer to the ideal scaling.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=598"
  },
  {
    "text": "In the previous example, it was possible to remove ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=603"
  },
  {
    "text": "CPU/GPU synchronization altogether, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=606"
  },
  {
    "text": "however this is not always the case, due to your application nature. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=609"
  },
  {
    "text": "There are other approaches you can take to reduce idle time. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=615"
  },
  {
    "text": "Use MTLSharedEvents to signal the CPU, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=620"
  },
  {
    "text": "pipeline more work, consider using GPU-driven encoding, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=623"
  },
  {
    "text": "and using concurrent dispatches. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=627"
  },
  {
    "text": "So let's discuss those approaches to minimize GPU timeline gaps. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=630"
  },
  {
    "text": "Some of them might fit your workflow.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=635"
  },
  {
    "text": "Waiting on the CPU for GPU completion leads to not ideal scaling. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=639"
  },
  {
    "text": "If your application is using WaitUntilCompleted, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=644"
  },
  {
    "text": "you might want to try to use MTLSharedEvents instead.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=646"
  },
  {
    "text": "MTLSharedEvents have lower overhead ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=651"
  },
  {
    "text": "and can help you reduce the timeline gaps. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=654"
  },
  {
    "text": "The next thing to consider ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=657"
  },
  {
    "text": "is pipelining the workload.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=658"
  },
  {
    "text": "If the algorithm has the data necessary ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=662"
  },
  {
    "text": "for the next batch to work on, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=664"
  },
  {
    "text": "it's possible to encode one or more batches in advance ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=666"
  },
  {
    "text": "before waiting on the MTLSharedEvents. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=669"
  },
  {
    "text": "By doing so, the GPU will not become drained ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=673"
  },
  {
    "text": "and will always have work to process.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=675"
  },
  {
    "text": "If work can't be encoded in advance on the same queue, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=679"
  },
  {
    "text": "consider using a second queue to overlap work. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=683"
  },
  {
    "text": "Using multiple queues allows you to submit independent work, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=686"
  },
  {
    "text": "and they do not stall the other submission thread ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=690"
  },
  {
    "text": "when waiting on an event. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=693"
  },
  {
    "text": "This way, the GPU has the chance to keep receiving and processing work.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=695"
  },
  {
    "text": "In some cases, an algorithm can encode work directly from the GPU.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=701"
  },
  {
    "text": "Using indirect command buffer, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=707"
  },
  {
    "text": "you can move the encoding of the next batch directly on the GPU, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=709"
  },
  {
    "text": "avoiding any need for synchronization. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=713"
  },
  {
    "text": "For more details about indirect command buffers, please check ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=716"
  },
  {
    "text": "\"Modern Rendering with Metal.\" ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=720"
  },
  {
    "text": "The workload now removes or minimizes expensive synchronizations ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=722"
  },
  {
    "text": "between CPU and GPU as much as possible. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=726"
  },
  {
    "text": "But even with a busy GPU timeline, scaling challenges may still exist. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=729"
  },
  {
    "text": "Let's investigate. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=735"
  },
  {
    "text": "This graph is from an image processing workload ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=737"
  },
  {
    "text": "where images are processed 1 frame at a time. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=740"
  },
  {
    "text": "A lot of back-to-back compute serial dispatches can also limit scaling. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=743"
  },
  {
    "text": "The GPU is busy, but kernel synchronization ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=749"
  },
  {
    "text": "has a cost and additionally, every dispatch has a small ramp up ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=751"
  },
  {
    "text": "where the threadgroups are being distributed ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=756"
  },
  {
    "text": "and not yet saturating the cores. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=758"
  },
  {
    "text": "Likewise, when threadgroups finish and retire, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=761"
  },
  {
    "text": "there might not be enough work to fully saturate the cores anymore. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=765"
  },
  {
    "text": "In this situation, the advice is to overlap independent work when possible. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=769"
  },
  {
    "text": "Let's see a visual example. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=774"
  },
  {
    "text": "Here we have a workload processing two images, one after the other. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=776"
  },
  {
    "text": "Normally, kernels need to synchronize between each other. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=780"
  },
  {
    "text": "However, this is not the only way to schedule work. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=784"
  },
  {
    "text": "You can interleave independent work of two images using concurrent dispatches. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=787"
  },
  {
    "text": "Here the driver is able to interleave different work, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=793"
  },
  {
    "text": "thanks to concurrent dispatches. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=796"
  },
  {
    "text": "We can see that the two kernels that previously were back-to-back ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=799"
  },
  {
    "text": "are now separated by some independent work. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=802"
  },
  {
    "text": "However, when you use MTLDispatchTypeConcurrent, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=807"
  },
  {
    "text": "barriers must be put in manually. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=810"
  },
  {
    "text": "Concurrent dispatches enable the driver to pack the work more tightly, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=813"
  },
  {
    "text": "hiding most of the synchronization cost between dependent kernels, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=818"
  },
  {
    "text": "as well as fill the ramp up and tail end of the various kernels. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=822"
  },
  {
    "text": "This optimization greatly improved the workload performance ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=827"
  },
  {
    "text": "and scaling when moving from M1 Max to M1 Ultra. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=830"
  },
  {
    "text": "The workload runs 30% faster with two images interleaved, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=835"
  },
  {
    "text": "70% faster with 3 images in parallel, compared to the previous scaling.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=839"
  },
  {
    "text": "It's important to carefully consider atomic operations that kernels are doing. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=847"
  },
  {
    "text": "Let's make sure it is made in the most efficient way. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=851"
  },
  {
    "text": "Atomic operation allows reading and writing data ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=855"
  },
  {
    "text": "from multiple threads in a safe manner. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=859"
  },
  {
    "text": "Global atomics are coherent across the whole GPU. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=862"
  },
  {
    "text": "When many threads attempt to read and write the same global value, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=866"
  },
  {
    "text": "this leads to contention. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=869"
  },
  {
    "text": "Increasing numbers of GPU cores doesn't help and in fact leads to more contention. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=872"
  },
  {
    "text": "Let's investigate how you can improve atomics behavior ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=878"
  },
  {
    "text": "in an algorithm with an example.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=881"
  },
  {
    "text": "Here is a reduction algorithm, where all of the values in a buffer ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=885"
  },
  {
    "text": "will be summed up together. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=889"
  },
  {
    "text": "The simplest approach is to perform an atomic add operation ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=891"
  },
  {
    "text": "per thread in main memory. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=894"
  },
  {
    "text": "However, this is not ideal because that puts a great level of pressure ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=897"
  },
  {
    "text": "on a single value in main memory, effectively serializing each memory write.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=902"
  },
  {
    "text": "There are two things that the hardware offers to help with ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=909"
  },
  {
    "text": "atomic memory contention: ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=911"
  },
  {
    "text": "Simd-group instruction and threadgroup atomics.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=914"
  },
  {
    "text": "SIMD instructions like prefix_exlusive sum and simd_min and many more ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=918"
  },
  {
    "text": "allow to do operations and exchange memory between registers ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=924"
  },
  {
    "text": "in a SIMD-group without round trip to memory. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=928"
  },
  {
    "text": "Threadgroup atomics are fulfilled by the threadgroup memory. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=931"
  },
  {
    "text": "Each GPU core has its own threadgroup memory ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=935"
  },
  {
    "text": "allowing to scale with the number of GPU cores. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=938"
  },
  {
    "text": "Let's see how these two features can help you improve your workload.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=942"
  },
  {
    "text": "Here we have the same reduction problem, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=948"
  },
  {
    "text": "but this time it start using a SIMD-group instruction, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=950"
  },
  {
    "text": "an inclusive memory sum. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=954"
  },
  {
    "text": "Such operation will leave the sum of all the numbers in the SIMD-group ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=956"
  },
  {
    "text": "in the last thread. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=961"
  },
  {
    "text": "The last thread from each SIMD-group can then perform a single atomic add ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=963"
  },
  {
    "text": "in threadgroup memory to reduce all SIMD-groups to a single value ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=968"
  },
  {
    "text": "in threadgroup memory. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=972"
  },
  {
    "text": "In this way, using SIMD-group instruction and threadgroup memory, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=974"
  },
  {
    "text": "a whole threadgroup was reduced without touching main memory at all. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=979"
  },
  {
    "text": "Each group will be able to reduce independently and in parallel.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=984"
  },
  {
    "text": "Now that each threadgroup has been reduced to a single value, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=989"
  },
  {
    "text": "one thread per threadgroup can perform ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=992"
  },
  {
    "text": "a single atomic in main memory. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=995"
  },
  {
    "text": "Not only this requires only ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=997"
  },
  {
    "text": "one atomic per threadgroup, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=999"
  },
  {
    "text": "but since threadgroups complete ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1001"
  },
  {
    "text": "at different times, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1003"
  },
  {
    "text": "it scatters atomics over time, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1004"
  },
  {
    "text": "reducing memory contention even further. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1007"
  },
  {
    "text": "To recap, to maximize atomics effectiveness, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1010"
  },
  {
    "text": "try to leverage memory locality, try to use SIMD-group operation, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1014"
  },
  {
    "text": "as well as to leverage threadgroup memory atomics. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1019"
  },
  {
    "text": "All this should greatly help reduce atomic operation pressure that prevents scaling.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1022"
  },
  {
    "text": "Now that GPU gaps are fixed, it's time to see if the scaling is closer to ideal. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1028"
  },
  {
    "text": "GPU Limiters in Xcode and Metal System Trace help to optimize ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1035"
  },
  {
    "text": "any bottlenecks and inefficiencies in GPU cores execution pipeline. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1039"
  },
  {
    "text": "For example, inefficient memory access patterns ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1045"
  },
  {
    "text": "always cause high Last Level Cache or Memory Management Unit, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1048"
  },
  {
    "text": "or MMU limiters, and pretty low utilizations. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1053"
  },
  {
    "text": "The first thing to address is the way to tune threadgroups and memory layout. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1056"
  },
  {
    "text": "The key in reducing memory span and divergence ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1063"
  },
  {
    "text": "is to have a clear understanding of the workload memory access pattern, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1066"
  },
  {
    "text": "both spatially and temporally. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1070"
  },
  {
    "text": "Once that's understood, there are two possible tuning directions: ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1074"
  },
  {
    "text": "Re-organize the data layout to improve data access locality, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1078"
  },
  {
    "text": "or tune the access pattern to better match the data layout ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1081"
  },
  {
    "text": "and improve memory and cache locality. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1085"
  },
  {
    "text": "Let's see an example.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1089"
  },
  {
    "text": "Here it is a memory buffer where the data is laid out horizontally, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1092"
  },
  {
    "text": "one row after the other. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1096"
  },
  {
    "text": "However, when the compute kernel is dispatched, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1098"
  },
  {
    "text": "it is common to have a 2D like pattern ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1101"
  },
  {
    "text": "with square threadgroups being distributed, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1104"
  },
  {
    "text": "which is quite spatially localized. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1107"
  },
  {
    "text": "This access pattern and data layout is not great for data locality.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1109"
  },
  {
    "text": "For example, when the first SIMD-group access the data, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1116"
  },
  {
    "text": "the requests are packed in a cache lines. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1119"
  },
  {
    "text": "Most of the cache line won't be used, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1122"
  },
  {
    "text": "however still occupying space in the cache. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1125"
  },
  {
    "text": "Re-arrange the data to fit the access pattern better, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1130"
  },
  {
    "text": "where, for example, instead of spanning the whole row, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1133"
  },
  {
    "text": "it is localized into stripes.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1136"
  },
  {
    "text": "With this new memory layout, a threadgroup will be able ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1141"
  },
  {
    "text": "to utilize most of the data that will be requested ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1144"
  },
  {
    "text": "in a cache line, reducing divergence and improving cache efficiency.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1147"
  },
  {
    "text": "The other option is to change how the 3D grid is dispatched ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1152"
  },
  {
    "text": "to better fit the current data layout. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1156"
  },
  {
    "text": "Try to play with the threadgroup size to create groups that map better ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1159"
  },
  {
    "text": "to your memory layout, like a more rectangular shape, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1163"
  },
  {
    "text": "for example. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1167"
  },
  {
    "text": "In this case, the access pattern is aligned with the memory layout, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1169"
  },
  {
    "text": "giving a much higher cache efficiency. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1173"
  },
  {
    "text": "You might need to experiment to find the best fit for your workload. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1177"
  },
  {
    "text": "Sometimes you might need to make trade-offs, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1181"
  },
  {
    "text": "sacrifice thread divergence for memory locality, or vice versa, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1184"
  },
  {
    "text": "change your data layout, grid dispatch, or a combination of them all. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1189"
  },
  {
    "text": "Every workload and access pattern is different.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1194"
  },
  {
    "text": "Now that you're aware of ways to improve memory locality, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1200"
  },
  {
    "text": "let's see a more concrete example in Blender Cycles.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1203"
  },
  {
    "text": "Cycles is Blender's physically-based path tracer for production rendering. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1208"
  },
  {
    "text": "It is designed to provide physically based results out-of-the-box, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1213"
  },
  {
    "text": "with artistic control and flexible shading nodes for production needs.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1217"
  },
  {
    "text": "This Instrument trace clearly shows low Read Bandwidth, high Top GPU Limiter, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1224"
  },
  {
    "text": "high Cache Limiter and low Last Level Cache Utilization.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1230"
  },
  {
    "text": "Keeping bandwidth and MMU limiters in control is important for scaling. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1236"
  },
  {
    "text": "If your Top limiter is the Last Level Cache or MMU, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1242"
  },
  {
    "text": "you need to reduce your memory span and maximize data locality. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1245"
  },
  {
    "text": "Let's see an example.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1250"
  },
  {
    "text": "Cycles use sorting of data to try to reduce divergence. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1253"
  },
  {
    "text": "It does that by sorting the ray hits by material type. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1257"
  },
  {
    "text": "This is great to reduce thread divergence, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1261"
  },
  {
    "text": "but it increases spatial memory divergence, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1264"
  },
  {
    "text": "resulting in a high MMU Limiter. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1267"
  },
  {
    "text": "To help with this, we experimented with partitioning the memory range ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1271"
  },
  {
    "text": "before sorting to increase data locality. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1274"
  },
  {
    "text": "Let's visualize it. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1277"
  },
  {
    "text": "When rays are shot into the scene to simulate light traveling, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1278"
  },
  {
    "text": "they hit objects and data is collected into buffers. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1284"
  },
  {
    "text": "At the point of intersection we know many things-- ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1288"
  },
  {
    "text": "the material type that was hit, like glass, metal and so on, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1290"
  },
  {
    "text": "the intersection position, the ray, and more. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1294"
  },
  {
    "text": "For simplicity, let's focus on the material type only. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1299"
  },
  {
    "text": "Here are the materials in a buffer in memory.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1303"
  },
  {
    "text": "Since a lot of data is gathered per ray hit, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1307"
  },
  {
    "text": "the memory buffer can become quite large. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1309"
  },
  {
    "text": "To avoid moving a lot of memory around, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1313"
  },
  {
    "text": "populate a list of indices and sort those instead. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1315"
  },
  {
    "text": "After the sort, the indices for the same material type ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1320"
  },
  {
    "text": "are now packed closed together. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1323"
  },
  {
    "text": "SIMD-groups can start loading the indices and process the materials. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1326"
  },
  {
    "text": "The SIMD-group will use the index to load the corresponding data ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1331"
  },
  {
    "text": "in the original buffer.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1335"
  },
  {
    "text": "However, the SIMD-group would be reading across the whole memory span, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1338"
  },
  {
    "text": "putting pressure on the MMU. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1342"
  },
  {
    "text": "Let's investigate the new approach. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1345"
  },
  {
    "text": "The memory range is partitioned in an idealized partition ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1348"
  },
  {
    "text": "that simply won't let indices from different partition mix. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1352"
  },
  {
    "text": "When sorting, it is apparent that the range of data accessed is contained ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1356"
  },
  {
    "text": "inside the partition instead of spanning the full memory range like before. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1361"
  },
  {
    "text": "It is a trade-off and balance between thread divergence and memory divergence. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1366"
  },
  {
    "text": "The number of partitions and size that is ideal ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1372"
  },
  {
    "text": "is highly dependent on the workload. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1375"
  },
  {
    "text": "You might have to experiment to see which one works best. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1378"
  },
  {
    "text": "Let's take another Metal System Trace and let see if the workload improved. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1382"
  },
  {
    "text": "Here we see the limiters and utilizations for the optimized version. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1387"
  },
  {
    "text": "The Top Performance limiter went down, as well as Last Level Cache limiter. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1391"
  },
  {
    "text": "As a result, bandwidth and shader runtime substantially improved. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1397"
  },
  {
    "text": "Let's see how much. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1402"
  },
  {
    "text": "Top limiter and LLC limiter reduced by around 20%. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1404"
  },
  {
    "text": "That means data flow is more efficient. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1409"
  },
  {
    "text": "GPU Read bandwidth increased significantly, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1412"
  },
  {
    "text": "allowing to push more data to the GPU cores.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1415"
  },
  {
    "text": "Overall, increasing memory locality with this experiment ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1419"
  },
  {
    "text": "improved performance between 10 to 30%, depending on the scene. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1423"
  },
  {
    "text": "This was just an example of many ways you can try to improve memory access pattern. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1428"
  },
  {
    "text": "Keep experimenting and optimizing for the Top Performance Limiter. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1434"
  },
  {
    "text": "The GPU tools have more useful counters to tune for.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1438"
  },
  {
    "text": "Xcode has a new theoretical occupancy in the compiler statistic window. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1443"
  },
  {
    "text": "Both Xcode and Instruments now have several MMU related limiters and counters, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1448"
  },
  {
    "text": "specifically a new MMU Limiter, MMU Utilization Counter, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1455"
  },
  {
    "text": "and MMU TLB Miss Rate Counter.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1460"
  },
  {
    "text": "I have covered a lot of ground today. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1464"
  },
  {
    "text": "I discussed GPU scalability and how bottlenecks can shift when scaling up, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1467"
  },
  {
    "text": "and how the tools can help you find and fix scalability issues. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1472"
  },
  {
    "text": "I also discussed how you might need to experiment and make trade-offs ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1476"
  },
  {
    "text": "to get the best result for your application. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1480"
  },
  {
    "text": "I am looking forward to seeing all your great apps scale amazingly well ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1483"
  },
  {
    "text": "on Apple silicon. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1487"
  },
  {
    "text": "Thank you for watching.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10159/?time=1488"
  }
]