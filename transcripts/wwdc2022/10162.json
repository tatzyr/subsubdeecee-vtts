[
  {
    "text": " ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=1"
  },
  {
    "text": "- Hi! My name is Andrei. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=9"
  },
  {
    "text": "I'm a GPU software engineer with Metal Frameworks team. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=11"
  },
  {
    "text": "Today, I'm excited to introduce to you Metal mesh shaders. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=15"
  },
  {
    "text": "Mesh shaders is the new flexible pipeline in Metal ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=19"
  },
  {
    "text": "for GPU-driven geometry creation and processing. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=23"
  },
  {
    "text": "It improves on the vertex/fragment pipeline, adding a lot of flexibility ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=26"
  },
  {
    "text": "and removing the limitations of per-vertex processing. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=31"
  },
  {
    "text": "It has multiple applications, , but not limited to: ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=35"
  },
  {
    "text": "fine-grained geometry culling, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=38"
  },
  {
    "text": "scalable procedural geometry creation on the GPU, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=41"
  },
  {
    "text": "and allowing custom geometry inputs ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=44"
  },
  {
    "text": "such as compressed vertex streams, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=47"
  },
  {
    "text": "meshlets and complex procedural algorithms. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=49"
  },
  {
    "text": "I would like to cover these three things today. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=52"
  },
  {
    "text": "First, I will go over what Metal mesh shaders are. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=55"
  },
  {
    "text": "Then, I would like to tell you about two mesh shaders use cases. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=59"
  },
  {
    "text": "Mesh shaders are great for generating procedural geometry ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=63"
  },
  {
    "text": "such as rendering procedural hair. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=66"
  },
  {
    "text": "Mesh shaders also help improve scene processing and rendering. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=69"
  },
  {
    "text": "A primary example of this is using mesh shaders ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=73"
  },
  {
    "text": "to implement GPU-driven meshlet culling. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=75"
  },
  {
    "text": "Let's start with introducing mesh shaders. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=79"
  },
  {
    "text": "Here is the Stanford Bunny, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=81"
  },
  {
    "text": "which represents a typical mesh that you could render on the GPU. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=83"
  },
  {
    "text": "In order to render this mesh, the vertex and index data ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=87"
  },
  {
    "text": "would first have to be placed in the device memory. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=91"
  },
  {
    "text": "You would then have to use render command encoder to execute a draw call. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=94"
  },
  {
    "text": "A traditional rendering pipeline consists of three fundamental stages: ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=99"
  },
  {
    "text": "A programmable vertex shader stage, a fixed-function rasterization stage, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=104"
  },
  {
    "text": "and a programmable fragment shader stage. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=109"
  },
  {
    "text": "The vertex shader stage would take geometry ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=112"
  },
  {
    "text": "from device memory as an input and process it. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=114"
  },
  {
    "text": "The rasterizer would produce screen space fragments, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=117"
  },
  {
    "text": "and the fragment shader would shade them to produce the final image. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=120"
  },
  {
    "text": "This pipeline has been, and still is, serving its purpose extremely well. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=124"
  },
  {
    "text": "However, it lacks flexibility and has certain limitations. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=128"
  },
  {
    "text": "Let's step through an example. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=133"
  },
  {
    "text": "Imagine that you want to generate some procedural geometry on the GPU. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=135"
  },
  {
    "text": "For example, you've decided to add procedural fur to this bunny. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=139"
  },
  {
    "text": "Let me show you how this task is handled by the traditional geometry pipeline. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=145"
  },
  {
    "text": "Traditionally, in order to generate procedural geometry, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=150"
  },
  {
    "text": "you would also need to have a compute command encoder ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=153"
  },
  {
    "text": "that would perform a compute kernel dispatch. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=157"
  },
  {
    "text": "The compute kernel would take the original mesh as an input, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=160"
  },
  {
    "text": "generate procedural geometry and output it back into device memory. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=164"
  },
  {
    "text": "You would then use a render command encoder to execute a draw call ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=169"
  },
  {
    "text": "that would take procedural geometry as an input and produce a final image . ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=172"
  },
  {
    "text": "Not only does this approach require two command encoders, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=177"
  },
  {
    "text": "it also requires you to allocate additional memory ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=180"
  },
  {
    "text": "to store the procedural geometry. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=183"
  },
  {
    "text": "In case of indirect draw calls or high expansion factors, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=185"
  },
  {
    "text": "the amount of this memory can be quite high and hard to predict. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=189"
  },
  {
    "text": "There is also a barrier between the two encoders, serializing work across the GPU. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=193"
  },
  {
    "text": "Metal mesh shaders addresses all of those issues. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=198"
  },
  {
    "text": "Mesh shaders is a new geometry pipeline ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=201"
  },
  {
    "text": "that replaces the vertex shader stage with two new programmable stages-- ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=204"
  },
  {
    "text": "the object shader stage and the mesh shader stage. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=209"
  },
  {
    "text": "In this example, the object shader would take geometry as an input , ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=212"
  },
  {
    "text": "process it and output some data-- which we call \"payload\"-- ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=216"
  },
  {
    "text": "to the mesh shader. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=220"
  },
  {
    "text": "It is up to you to decide what this data is. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=221"
  },
  {
    "text": "The mesh shader, in turn, would use this data to generate procedural geometry. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=225"
  },
  {
    "text": "This procedural geometry would only exist inside the draw call, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=230"
  },
  {
    "text": "so it would not require you to allocate any device memory. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=234"
  },
  {
    "text": "It would be pipelined straight to the rasterizer ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=238"
  },
  {
    "text": "and then to a fragment shader that would produce the final image. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=242"
  },
  {
    "text": "Mesh draw calls are performed using the same type of render command encoder ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=246"
  },
  {
    "text": "as the traditional draw calls. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=250"
  },
  {
    "text": "Mesh draw calls and traditional draw calls can be mixed and matched. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=252"
  },
  {
    "text": "Now, let's take a look at two new programmable stages.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=256"
  },
  {
    "text": "In contrast to vertex shaders, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=262"
  },
  {
    "text": "object and mesh shaders are similar to compute kernels. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=263"
  },
  {
    "text": "They are launched in grids of thread groups. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=267"
  },
  {
    "text": "Each thread group is a grid of individual threads that, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=270"
  },
  {
    "text": "like compute threads, can communicate with each other. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=273"
  },
  {
    "text": "Additionally, each object thread group can spawn a mesh grid ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=277"
  },
  {
    "text": "and programmatically define the size of the mesh grid it launches, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=281"
  },
  {
    "text": "providing plenty of flexibility. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=285"
  },
  {
    "text": "Each object thread group passes payload data to the mesh grid it spawns. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=288"
  },
  {
    "text": "As the name suggests, the object stage processes objects. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=293"
  },
  {
    "text": "Object is an abstract concept that you can define according to your needs. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=297"
  },
  {
    "text": "It can be a scene model, a part of a scene model or, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=301"
  },
  {
    "text": "for example, a region of space where you want to generate procedural geometry. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=304"
  },
  {
    "text": "The mesh stage is designed to build meshes ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=309"
  },
  {
    "text": "and send geometry data directly to the rasterizer. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=312"
  },
  {
    "text": "The next two examples will cover the relation between objects and meshes. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=315"
  },
  {
    "text": "The first one is using mesh shaders to implement hair rendering. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=320"
  },
  {
    "text": "To simplify this task, instead of the Bunny model, I'll use a simple plane. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=323"
  },
  {
    "text": "To generate a patch of hair, I'll divide the input geometry into tiles, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=328"
  },
  {
    "text": "where each tile will calculate a level of detail ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=332"
  },
  {
    "text": "and the number of strands it needs to produce, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=335"
  },
  {
    "text": "and then generate each individual strand of hair. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=338"
  },
  {
    "text": "Let me show you how to procedurally generate hair on this plane ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=341"
  },
  {
    "text": "using mesh shaders. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=345"
  },
  {
    "text": "The plane can be split into tiles, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=346"
  },
  {
    "text": "where each tile corresponds to an object threadgroup. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=349"
  },
  {
    "text": "Each object threadgroup will calculate the number of hair strands ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=352"
  },
  {
    "text": "and generate the curve control points for each strand. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=355"
  },
  {
    "text": "This will become the payload. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=359"
  },
  {
    "text": "Our object threadgroup then launches a mesh grid, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=361"
  },
  {
    "text": "where each mesh threadgroup represents a single strand of hair. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=364"
  },
  {
    "text": "Each mesh threadgroup outputs the mesh to the rasterizer. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=368"
  },
  {
    "text": "The new geometry pipeline allows you to map ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=371"
  },
  {
    "text": "your geometry processing closely to hardware ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=374"
  },
  {
    "text": "and enables you to take full advantage of all the threads your GPU offers. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=376"
  },
  {
    "text": "In a mesh render pipeline, input geometry is split into tiles ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=381"
  },
  {
    "text": "for the object shader grid. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=385"
  },
  {
    "text": "Each object shader threadgroup can independently generate a payload ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=387"
  },
  {
    "text": "and launch a mesh grid. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=391"
  },
  {
    "text": "Each mesh shader threadgroup from the grid generates a metal::mesh ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=393"
  },
  {
    "text": "which is further processed in the rest of the rendering pipeline. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=397"
  },
  {
    "text": "Let's take a closer look at the data produced by each of those stages. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=401"
  },
  {
    "text": "The payload is defined in the object shader. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=406"
  },
  {
    "text": "Each object threadgroup passes the customized payload ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=408"
  },
  {
    "text": "to the generated mesh grid that an object threadgroup spawns. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=411"
  },
  {
    "text": "In the case of hair rendering, the payload consists of the curve control points. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=415"
  },
  {
    "text": "Meanwhile, the mesh shader outputs vertex and primitive data ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=420"
  },
  {
    "text": "through a new metal::mesh type, which I will discuss in further detail in a bit.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=423"
  },
  {
    "text": "The object and mesh stages output mesh data ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=429"
  },
  {
    "text": "that is consumed by rest of the pipeline. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=432"
  },
  {
    "text": "Similar to the vertex output from the traditional pipeline, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=435"
  },
  {
    "text": "the mesh data is first consumed by the rasterizer, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=438"
  },
  {
    "text": "then the fragment shader executes. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=441"
  },
  {
    "text": "Let's take a deeper dive into how to set up a hair rendering mesh pipeline. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=445"
  },
  {
    "text": "First, the plane that is to be covered in hair is split into tiles, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=450"
  },
  {
    "text": "where each tile corresponds to an object threadgroup. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=454"
  },
  {
    "text": "The object threadgroup determines the mesh grid size ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=458"
  },
  {
    "text": "and initializes the payload data that it passes to the mesh grid. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=461"
  },
  {
    "text": "In this case, the tile has six strands of hair and generates a 3x2 mesh grid, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=465"
  },
  {
    "text": "along with a curve payload data for each strand.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=470"
  },
  {
    "text": "Each threadgroup can generate unique mesh grid sizes. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=474"
  },
  {
    "text": "For the next threadgroup, only four strands of hair ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=477"
  },
  {
    "text": "need to be generated, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=479"
  },
  {
    "text": "so a 2x2 mesh grid is set ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=481"
  },
  {
    "text": "along with initializing curve payload data for 4 strands. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=483"
  },
  {
    "text": "This is how the object shader that implements this approach looks like. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=487"
  },
  {
    "text": "The object attribute has been added to Metal ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=491"
  },
  {
    "text": "to specify what code is an object shader. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=494"
  },
  {
    "text": "In addition to the payload attribute and object_data address space, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=497"
  },
  {
    "text": "allow payload arguments to be used in shaders.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=501"
  },
  {
    "text": "The mesh grid properties argument is used to encode the mesh grid size. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=506"
  },
  {
    "text": "The next step is pipeline initialization. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=511"
  },
  {
    "text": "First, allocate the mesh render pipeline descriptor, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=514"
  },
  {
    "text": "then initialize the object function and specify the desired payload length, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=518"
  },
  {
    "text": "along with the maximum number of threads per threadgroup. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=524"
  },
  {
    "text": "There are certain constraints on object shaders. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=527"
  },
  {
    "text": "Payload format and contents are fully customizable. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=530"
  },
  {
    "text": "However, payload size can't exceed the limit of 16 kilobytes. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=534"
  },
  {
    "text": "Also, the maximum number of mesh threadgroups ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=538"
  },
  {
    "text": "that each object threadgroup produces can't exceed 1024. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=541"
  },
  {
    "text": "The next step after getting the object shader stage ready ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=546"
  },
  {
    "text": "is initializing the mesh shader stage. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=548"
  },
  {
    "text": "The mesh shader has the user defined payload as an input. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=551"
  },
  {
    "text": "In this example, the payload is the set of curve control points. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=555"
  },
  {
    "text": "Each mesh threadgroup produces a metal::mesh, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=559"
  },
  {
    "text": "which is a single strand of hair. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=562"
  },
  {
    "text": "The output mesh of the mesh shader must have a metal::mesh type. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=565"
  },
  {
    "text": "A metal::mesh is a built-in structure in Metal that provides you an interface ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=569"
  },
  {
    "text": "to output vertex and primitive data to the rasterizer and fragment shader. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=573"
  },
  {
    "text": "Each metal::mesh defines a vertex data type, much like the output type ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=578"
  },
  {
    "text": "of a vertex shader, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=583"
  },
  {
    "text": "a primitive data type, the maximum number of vertices, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=585"
  },
  {
    "text": "the maximum number of primitives, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=589"
  },
  {
    "text": "and finally, the mesh topology-- either point, line, or triangle. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=591"
  },
  {
    "text": "The mesh attribute was added to Metal shading language ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=597"
  },
  {
    "text": "to specify what code is a mesh shader. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=601"
  },
  {
    "text": "Metal::mesh is used as an output structure in the mesh shader.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=604"
  },
  {
    "text": "Mesh shaders are great for GPU-driven geometry processing ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=609"
  },
  {
    "text": "as they allow you to produce these metal::meshes on the fly ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=613"
  },
  {
    "text": "for the rasterizer to consume. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=615"
  },
  {
    "text": "Mesh shaders leverage the metal::mesh to their advantage ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=618"
  },
  {
    "text": "so you can put more processing into render commands ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=621"
  },
  {
    "text": "without having additional compute passes. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=624"
  },
  {
    "text": "Encoding a mesh is done across threads within the same thread group. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=627"
  },
  {
    "text": "In this example, the first 9 threads of a thread group will encode the vertex, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=631"
  },
  {
    "text": "index, and primitive data of this hair strand. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=635"
  },
  {
    "text": "Threads 0 through 4 each encode one vertex in the mesh. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=639"
  },
  {
    "text": "The remaining threads in the thread group do not encode vertices in the mesh. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=645"
  },
  {
    "text": "Next, all 9 threads encode one index into the mesh indices.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=650"
  },
  {
    "text": "Next, the first three threads encode primitive data for the three triangles. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=657"
  },
  {
    "text": "The rest of the threads don't encode any primitive data. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=663"
  },
  {
    "text": "And lastly, one thread shall encode the primitive count for the metal::mesh. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=667"
  },
  {
    "text": "Let me show you the source code for this mesh shader. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=672"
  },
  {
    "text": "The mesh shader is organized to avoid as much divergence in threads ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=676"
  },
  {
    "text": "as possible--following the same steps to encode vertex, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=679"
  },
  {
    "text": "index and primitive data, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=683"
  },
  {
    "text": "and finally the primitive count.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=686"
  },
  {
    "text": "Let's switch back to initializing the mesh pipeline descriptor. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=690"
  },
  {
    "text": "On the mesh pipeline descriptor, the mesh function ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=694"
  },
  {
    "text": "along with the maximum threads per mesh thread group, is set. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=697"
  },
  {
    "text": "There are limits that metal::mesh structure needs to adhere to. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=701"
  },
  {
    "text": "Metal::mesh shaders have the following limits: ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=705"
  },
  {
    "text": "metal::mesh supports up to 256 vertices and up to 512 primitives. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=707"
  },
  {
    "text": "The total size of metal::mesh cannot exceed 16 kilobytes. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=714"
  },
  {
    "text": "Now that the mesh grid has generated the metal::meshes, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=718"
  },
  {
    "text": "these are then fed to the rasterizer and finally the fragment shader is run. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=721"
  },
  {
    "text": "So, similar to the traditional render pipeline, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=726"
  },
  {
    "text": "the fragment function is set on the mesh pipeline descriptor. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=729"
  },
  {
    "text": "Now that the descriptor has been initialized, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=733"
  },
  {
    "text": "the pipeline state is created ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=735"
  },
  {
    "text": "through the \"make render pipeline state with mesh descriptor\" method ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=738"
  },
  {
    "text": "on the Metal device. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=742"
  },
  {
    "text": "Encoding a mesh pipeline is very similar to encoding a traditional draw call. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=743"
  },
  {
    "text": "The pipeline state is set on the encoder. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=749"
  },
  {
    "text": "Each stage in the pipeline can have resources bound. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=751"
  },
  {
    "text": "In this example the bound resources are: ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=754"
  },
  {
    "text": "an object buffer to an object stage, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=758"
  },
  {
    "text": "a texture to a mesh stage, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=760"
  },
  {
    "text": "and a fragment buffer to a fragment stage. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=762"
  },
  {
    "text": "Next, I'm defining a few constants that I'll need to launch the mesh pipeline: ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=766"
  },
  {
    "text": "object grid dimensions, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=771"
  },
  {
    "text": "number of threads per object threadgroup, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=774"
  },
  {
    "text": "number of threads per mesh threadgroup, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=776"
  },
  {
    "text": "and use these constants to encode the draw ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=779"
  },
  {
    "text": "through the new \"draw mesh threadgroups\" method. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=782"
  },
  {
    "text": "The same approach that is used to render a plane of hair ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=784"
  },
  {
    "text": "can be applied to the whole bunny ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=787"
  },
  {
    "text": "to procedurally generate fur through a mesh pipeline. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=789"
  },
  {
    "text": "Next, let's look at another way to use mesh shaders. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=793"
  },
  {
    "text": "Mesh shaders can be used to efficiently process ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=796"
  },
  {
    "text": "and render large amounts of geometry using meshlet culling. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=799"
  },
  {
    "text": "The basis for this technique is splitting the scene meshes up ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=803"
  },
  {
    "text": "into smaller pieces called meshlets.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=806"
  },
  {
    "text": "Splitting scene geometry into meshlets increases the granularity of the scene, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=813"
  },
  {
    "text": "allowing more efficient and fine-grained culling. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=816"
  },
  {
    "text": "This allows you to greatly reduce geometry overhead. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=819"
  },
  {
    "text": "Leveraging meshlet granularity processing ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=822"
  },
  {
    "text": "allows for efficient occlusion and culling algorithms ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=824"
  },
  {
    "text": "such as screen space occlusion culling and normal filtering. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=827"
  },
  {
    "text": "You can use mesh shaders to implement a fully GPU-driven culling ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=831"
  },
  {
    "text": "and rendering pipeline.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=834"
  },
  {
    "text": "Here is a traditional GPU-driven pipeline ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=836"
  },
  {
    "text": "that performs scene processing and rendering ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=839"
  },
  {
    "text": "using one compute and one render pass. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=842"
  },
  {
    "text": "The scene data is split into meshlets ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=845"
  },
  {
    "text": "and fed into the compute pass, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=847"
  },
  {
    "text": "which is responsible for frustum culling, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=850"
  },
  {
    "text": "LOD selection, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=852"
  },
  {
    "text": "and encoding the draws to device memory. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=854"
  },
  {
    "text": "The render pass then executes the draw commands for the scene ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=857"
  },
  {
    "text": "and produces the final image. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=860"
  },
  {
    "text": "Using mesh shaders, it is possible to remove synchronization points ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=863"
  },
  {
    "text": "and avoid the intermediate draw commands by merging two passes ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=867"
  },
  {
    "text": "into a single mesh shader dispatch. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=871"
  },
  {
    "text": "Let me show you how it can be done. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=873"
  },
  {
    "text": "Here is a single render pass ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=875"
  },
  {
    "text": "that executes a mesh shader dispatch. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=877"
  },
  {
    "text": "The object shader performs frustum culling ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=879"
  },
  {
    "text": "and calculates LODs for each of the visible meshlets. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=882"
  },
  {
    "text": "The payload to the mesh shader is a list of meshlet IDs that should be encoded. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=885"
  },
  {
    "text": "The mesh shader then encodes the metal::mesh objects ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=890"
  },
  {
    "text": "that shall be rasterized and shaded. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=893"
  },
  {
    "text": "The final image is then shaded in the fragment shader, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=895"
  },
  {
    "text": "identical to the traditional pipeline. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=898"
  },
  {
    "text": "The geometry processing is done entirely ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=900"
  },
  {
    "text": "within the mesh threadgroups command ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=902"
  },
  {
    "text": "and within a single encoder. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=904"
  },
  {
    "text": "There is no longer a need for an intermediate buffer ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=906"
  },
  {
    "text": "to store these draw commands, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=908"
  },
  {
    "text": "as the triangle data is encoded in the mesh shader.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=909"
  },
  {
    "text": "Let's turn our attention to culling now-- ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=913"
  },
  {
    "text": "specifically, an implementation of meshlet culling. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=916"
  },
  {
    "text": "The scene consists of models represented by the shapes here. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=919"
  },
  {
    "text": "In this implementation, each model of the scene will become part of the object grid. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=922"
  },
  {
    "text": "The mesh grids spawned by the object shader threadgroups ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=927"
  },
  {
    "text": "will consist of meshlets-- ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=930"
  },
  {
    "text": "patches of triangles that make up the surface of the model. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=932"
  },
  {
    "text": "The new geometry pipeline is very flexible. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=935"
  },
  {
    "text": "It is up to you to decide how to map your scene onto an object grid. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=938"
  },
  {
    "text": "In this example, I'm mapping each model to an object threadgroup, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=941"
  },
  {
    "text": "but you can use the mapping that better suits your task. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=945"
  },
  {
    "text": "Now, the object shader will determine the visibility of meshlets ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=949"
  },
  {
    "text": "using the viewing frustum ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=951"
  },
  {
    "text": "and dispatch work only for what will be presented in the final image. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=953"
  },
  {
    "text": "Let's focus on two models from the scene. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=958"
  },
  {
    "text": "The object shader launches mesh grids based on determined visibility. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=960"
  },
  {
    "text": "The mesh shader then processes the meshlets and constructs metal::meshes. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=964"
  },
  {
    "text": "The programmable mesh grid size enables flexible dispatching ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=969"
  },
  {
    "text": "so only visible meshlets get processed by the mesh shader. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=972"
  },
  {
    "text": "This reduces the time spent processing unseen geometry later in the pipeline. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=976"
  },
  {
    "text": "The fixed function rasterizer only receives surfaces that are known to be ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=981"
  },
  {
    "text": "visible and will reduce time spent ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=985"
  },
  {
    "text": "processing and clipping out unseen geometry.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=987"
  },
  {
    "text": "Finally, the programmable fragment shader is invoked and produces the final image.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=990"
  },
  {
    "text": "As you can see, there are a wide variety of problems ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=995"
  },
  {
    "text": "that the new geometry pipeline allows you to address ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=998"
  },
  {
    "text": "such as creating procedural meshes or making your draw calls more efficient, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=1001"
  },
  {
    "text": "as demonstrated in this meshlet culling example. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=1005"
  },
  {
    "text": "Metal now includes a new geometry pipeline that is modern and flexible. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=1008"
  },
  {
    "text": "It is now easier than ever before to create procedural geometry, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=1012"
  },
  {
    "text": "as demonstrated in the hair rendering example. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=1016"
  },
  {
    "text": "Additionally, the possibilities for GPU-driven work ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=1019"
  },
  {
    "text": "in a single render pass have expanded ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=1022"
  },
  {
    "text": "without requiring additional compute passes or intermediate buffers, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=1024"
  },
  {
    "text": "as seen in the meshlet culling demo.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=1028"
  },
  {
    "text": "This new geometry pipeline is available in Family7 and Mac2 devices.",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=1031"
  },
  {
    "text": "To help you start learning and experimenting with mesh shaders, ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=1038"
  },
  {
    "text": "a sample code is available on Apple developer web site ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=1041"
  },
  {
    "text": "that shows how to use the new API. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=1044"
  },
  {
    "text": "I'm excited to see how you use this feature ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=1047"
  },
  {
    "text": "and utilize the massively parallel nature of Apple GPUs ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=1049"
  },
  {
    "text": "to fit your geometry processing needs. ",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=1052"
  },
  {
    "text": "Thank you so much for watching!",
    "link": "https://developer.apple.com/videos/play/wwdc2022-10162/?time=1055"
  }
]