10055

♪ ♪

Dima: こんにちは、「iOS 17のUIKitの新機能」へようこそ。

私はUIKitチームのエンジニアリングマネージャーであるDimaです。

アプリケーションの背後にある強力なフレームワークであるUIKitは、iOS 17の新機能をサポートするようにアップグレードされました。

このビデオでは、新しい主要機能とコアアーキテクチャの改善、言語設定に関係なくすべてのユーザーのためのインターフェイスの構築の進歩、iPadOSアプリの改善、およびリリースに含まれる多数の一般的な機能強化について説明します。

UIKitに主要なアーキテクチャの強化を導入し、強力なアプリケーションの作成を容易にし、SwiftUIとの統合を劇的に改善しました。

5つの主要な新機能をご案内します。

Xcodeプレビューのサポート、コントローラーのライフサイクルの更新、トレイトシステムの進歩、アニメーションシンボル画像、アプリの空の状態を表す新しいAPIについて説明します。

まず、大きな変化。

XcodeのプレビューはUIKitで直接使用できます。

この機能を利用するには、プレビューマクロを使用してプレビューの名前を指定し、ビューコントローラーを返します。

プレビューにデータを設定して入力するためだけに、ビューコントローラーの任意のプロパティを設定できます。

UIViewsを直接プレビューすることもでき、ビューコントローラーは必要ありません。

プレビューは、UIコンポーネントを視覚化し、コードを反復する際に即座にフィードバックを与えるのに役立ちます。

そして、アプリが作成されると、Xcodeプレビューは構成と設定の配列にわたるテストを可能にします。

次に、ビューコントローラーを提示したり、ナビゲーションコントローラーを押したりポップしたりするときなど、外観遷移中のビューコントローラーのライフサイクルの重要な改善をカバーしたいと思います。

viewIsAppearingという名前の新しいビューコントローラーコールバックがあり、viewWillAppearの後、viewDidAppearの前に呼び出されます。

viewIsAppearingは、ビューが表示されるたびに物事を行うのに最適な場所です。

呼び出されると、ビューコントローラーとビューの両方に最新のトレイトコレクションがあります。

さらに、ビューは階層に追加され、そのスーパービューによってレイアウトされています。

これにより、viewIsAppearingは、サイズを含むビューの初期ジオメトリに依存するコードを実行するための理想的なコールバックになります。

最後に、この新しいviewIsAppearingメソッドはiOS 13に展開されるため、アプリが古いバージョンのiOSで実行されている場合でも、それを活用できます。

これは、新しいviewIsAppearingコールバックが、典型的なビューコントローラーの外観遷移中に他の重要なイベントとどのように適合するかの図です。

いくつか指摘したいことがあります。

まず、ビューが階層に追加される前、およびレイアウトが始まる前に、viewWillAppearがどのように呼び出されるかに注意してください。

このため、特性コレクションを使用したり、ビューのサイズやその他のジオメトリに依存することをするのは時期尚早です。

次に、アニメーションが行われた後、最後に別のCATransactionでviewDidAppearがどのように呼び出されるかに注目してください。

つまり、viewDidAppearで行った変更は、トランジションが完了するまで表示されなくなるため、トランジション中に表示したい変更を行うには遅すぎます。

一方、viewIsAppearingはviewWillAppearと同じトランザクション内で呼び出されます。

これは、これらのコールバックのいずれかで行った変更が、トランジションの最初のフレームから同時にユーザーに表示されることを意味します。

最後に、タイミングは似ているかもしれませんが、viewIsAppearingとviewWillLayoutSubviewsのようなレイアウトコールバックの間には重要な違いがあります。

レイアウトコールバックは、ビューがlayoutSubviewsを実行するたびに行われます。これは、トランジション中に複数回、またはビューが表示されている間に発生する可能性があります。

しかし、viewIsAppearingは外観遷移中に一度だけ呼び出され、ビューがレイアウトを必要としない場合でも呼び出されます。

これが、viewIsAppearingをGoldilocksのコールバックとして考えるのが好きな理由です。早すぎたり、遅すぎたり、頻繁に呼び出されたりしません。

それはちょうどいい。

UIKitの特性システムは、iOS 17でアップグレードされました。

特性は、アプリの階層を通じて自動的にデータを伝播します。

UITraitCollectionには、ユーザーインターフェイススタイル、水平および垂直サイズクラス、優先コンテンツサイズカテゴリなど、多くのシステム特性が含まれています。

これで、カスタムトレイトを定義して、独自のデータをUITraitCollectionに追加できます。

これは、アプリのビューとビューコントローラーにデータを伝播するためのまったく新しい方法です。

また、任意のビューまたはビューコントローラーのトレイト値を簡単に変更するために、新しいトレイトオーバーライドAPIを追加しました。

また、サブクラスでtraitCollectionDidChangeをオーバーライドする代わりに、特性が値を変更したときにコールバックを受け取るために、より柔軟なAPIを採用することもできます。

最後に、カスタムUIKit特性とカスタムSwiftUI環境キーをブリッジして、アプリ内のUIKitとSwiftUIコンポーネント間でデータをシームレスに渡すことができます。

これらのエキサイティングな新しい機能強化についてすべて学ぶには、ビデオ「UIKit特性システムを解き放つ」をチェックしてください。

すべてのプラットフォームで、SFシンボルはツールバーのアイコン、ナビゲーションバー、その他のUI要素の一貫した外観を可能にします。

それらはテキストラベルと自動的に整列するように設計されており、アプリのデザインに合わせて重量、スケール、外観を簡単にカスタマイズできます。

iOS 17では、UIKitは新しいシンボルエフェクトAPIでアニメーションシンボルをサポートしています。

これらの効果は、カスタム画像であっても、あらゆるシンボル画像に適用できます。

シンボル効果を適用するには、UIImageViewで新しいaddSymbolEffect()メソッドを使用します。

ここでは、バウンス効果を追加します。これにより、シンボルが1回バウンスします。

次に、可変色効果を追加します。

バウンスとは異なり、可変色効果は追加すると無期限にアニメーション化されます。

removeSymbolEffect() メソッドを使用して効果を終了します。

最後に、新しいsetSymbolImage()メソッドを使用して、シンボル間でトランジション効果を実行できます。

私が調べた3つの機能よりも、シンボル効果にはもっと多くのものがあります。

詳細については、ビデオ「アプリでシンボルをアニメーション化」をご覧ください。

次に、空の状態を簡単に表現できるように、新しいAPIを追加しました。

空の状態は、アプリに表示するコンテンツがない瞬間です。

コンテンツが作成されていないため、通常、アプリの最初の起動時に発生します。

また、インターネット接続の欠如などの制限により、アプリがコンテンツを表示できない場合にも発生します。

UIContentUnavailableConfigurationは、空の状態の構成可能な説明であり、画像やテキストなどのプレースホルダコンテンツを提供できます。

この例では、表示するお気に入りの翻訳がないことをお知らせします。

この空の状態を表すために、設定をビューコントローラーのcontentUnavailableConfigurationとして設定しました。

.Empty() 設定に加えて、UIKit は準備中のコンテンツを表す .loading() 設定を提供します。

さらに、UIHostingConfiguration APIを活用して、SwiftUIビューでアプリの空の状態を表すことができます。

これは、セルでUIHostingConfigurationを使用するのと同じように機能します。

ビューコントローラーのコンテンツ利用できない構成を更新するのに最適な場所は、新しいメソッド、updateContentUnavailableConfiguration（使用：状態）です。

この例では、結果を返さないクエリ用に設計された .search 設定を使用しています。

この設定は、ローカライズされたプライマリテキストとセカンダリテキストを提供し、クエリは近くの検索コントローラーから補間されます。

ビューコントローラーのコンテンツの可用性が変更されるたびに、setNeedsUpdateContentUnavailable Configurationを呼び出すと、更新をリクエストします。

すべてのAppleプラットフォームで、言語設定に関係なく、一貫性のある高品質のエクスペリエンスを提供することが不可欠です。

それを促進するために、私たちはフォントとテキストレンダリングの分野で大きな進歩を遂げました。

このセクションでは、特定のフォントや言語でのテキストのクリッピングや衝突を防ぐのに役立つ動的な行の高さ調整について説明します。

また、改善された改行ルールとハイフネーションルール、およびロケールに基づいて画像を要求する新しいAPIについても学びます。

まず、フォントとその指標を詳しく見てみましょう。

フォントメトリックは、いくつかの用語を使用して定義されます。

ベースラインは、文字や単語が休む架空の線を表します。

線の高さは、これらのベースラインの間のスペースを指します。

そして、x-heightは小文字の上にある線です。

一部のフォントには、これらの行を超えて広がるアセンダとディセンダーがあります。

アセンダーは、x-heightの上に伸びるフォントの一部です。

一方、ディセンダーはベースラインの下にぶら下がっています。

アラビア語、ヒンディー語、タイ語などの一部の言語では、これらの要素はラテン文字よりもはるかに多くの垂直空間を必要とし、衝突やクリッピングの問題につながる可能性があります。

すべての言語でアセンダとディセンダーの重複を防ぐために、動的な線の高さ調整機能を導入しました。

これにより、UILabelsなどのテキスト要素は、最適な読みやすさのために、行の高さと垂直方向の寸法を自動的に調整できます。

また、中国語、ドイツ語、日本語、韓国語などの言語の改行行動を大幅に強化しました。

これらの改善は、使用しているテキストスタイルの種類に応じて異なるルールを適用します。

テキストスタイルを採用している限り、ほとんどの場合、これは自動的に機能しますが、ベストプラクティスとアプリがすべての言語で動作することを確認する方法の詳細については、「テキストとテキストインタラクションの新機能」をチェックしてください。

特定の状況では、UIのかなりの部分が、ユーザーが選択した言語とは異なる言語で表示される場合があります。

例えば、コンテンツがウェブから来たとき。

このような場合、新しい組版言語特性を使用してインターフェイスの言語を示すことができ、それに応じて行の高さとハイフネーションのルールを調整するのに役立ちます。

UIKitは、画像の特定のローカライズされたバリアントへのアクセスをサポートするようになりました。

たとえば、character.textbox SFシンボルには8つの異なるロケールベースのバリアントがあります。

デフォルトでは、UIKitはデバイスの現在の言語設定に一致するバリアントを引き出します。

したがって、現在の言語が米国の場合英語、その後、ラテン語の変種が表示されます。

iOS 17では、アプリは画像の構成でロケールを提供することで、特定のバリアントを要求できます。

ここでは、日本語のロケールで設定を提供することで、シンボルの日本語版を調べます。

テキストレンダリングとロケールサポートに対するこれらすべての変更により、あなたのアプリは誰にとっても自宅に近いと感じることができます。

では、iPad用のアプリを構築するための改善を案内します。

新しいウィンドウのドラッグインタラクション、ステージマネージャーのサイドバーの動作の強化、キーボードスクロールのサポート、ドキュメント中心のアプリの構築の進歩、新しいApple Pencilの機能とAPIの5つの分野の改善について説明します。

iOS 17では、ドラッグジェスチャーを開始できる領域を拡大することで、ステージマネージャーのウィンドウドラッグ機能を更新しました。

これで、UINavigationBar内の任意の場所をドラッグすると、ウィンドウの移動が開始されます。

このジェスチャーは、パンやスワイプジェスチャーなど、アプリに存在する可能性のある他のジェスチャーリコグナイザとうまく機能します。

アプリのUIの一部としてUINavigationBarを使用していない場合は、UIWindowSceneDragInteractionを採用し、任意のビューに追加できます。

また、アプリで他のパンジェスチャーとのジェスチャー関係を設定して、競合がないことを確認することもできます。

これは、箱から出してすぐにMac Catalystでも機能します。

列スタイルのUISplitViewControllersは、ステージマネージャーで優雅に新しいサイズ変更動作を獲得しました。

サイドバーは必要に応じて自動的に非表示になり、表示が特に要求されるまで非表示のままになります。

サイドバーが狭い幅で要求された場合、UISplitViewControllerは必要に応じてオーバーレイを使用するか、動作を置き換えます。

ウィンドウのサイズが大きくなると、オーバーレイされたサイドバーが持続します。

より大きな幅で却下され、リコールされると、タイル張りで戻ってきます。

メールなどの3列分割ビューコントローラは、同様に動作します。

この新しい動作は、ダブルカラムまたはトリプルカラムスタイルで作成されたUISplitViewControllersで発生します。

要約すると、自動動作は可能な限り列をタイル化し、幅が小さくなると必要に応じてサイドバーを非表示にし、サイドバーボタンがタップされたときにタイルをタイルするのに十分なスペースがない場合は、セカンダリ列をサイドバーにオーバーレイまたは置き換え、preferredDisplayModeとpreferredSplitBehaviorを使用してアプリケーションの動作をオーバーライドできます。

iPadOS 17では、ドキュメント中心のアプリのサポートを改善しました。

UIKitは、コンテンツビューコントローラーの基本クラスとして機能する新しいUIDocumentViewControllerを提供します。

システムのデフォルトのエクスペリエンスを保証し、タイトルメニューの自動設定、共有、ドラッグアンドドロップ、キーコマンドなど、追加の採用なしで多くの機能を提供します。

さらに、UIDocumentはUINavigationItemRenameDelegateに準拠し、ビューコントローラーのナビゲーションアイテムの名前変更デリゲートとして設定すると、完全な名前変更エクスペリエンスを提供します。

ドキュメント管理に焦点を当てたアプリのこれらの機能やその他の新機能の詳細については、「より良いドキュメントベースのアプリを構築する」をチェックしてください。

Apple PencilはiPadOSアプリに余分なファセットを追加し、新しいAPIもたくさんあります。

新しいiPad ProとiOS 16.4では、Apple Pencilでホバーを導入しました。

鉛筆からホバーをキャプチャするには、UIHoverGestureRecognizerを使用できます。

Zオフセットは、0から1の範囲の画面からの正規化されたホバー距離を反映します。

また、ホバー範囲内で鉛筆の高度と方位角をキャプチャして、ブラシストロークが画面上でどのように見えるかのプレビューを正確にレンダリングすることもできます。

鉛筆ホバーを使用すると、ホーム画面やアプリのツールバーアイコンにホバーを置くこともできます。

UIPointerInteractionを使用している場合は、追加の採用は必要ありません。

しかし、注目すべきは、マウスやトラックパッドの入力とApple Pencilの入力を使用する際の視覚的な相互作用はわずかに異なります。

たとえば、Apple Pencilを使用している間は、システムポインタなどのポインタスタイルは表示されません。

アプリでペンシルホバーを試してみてください。

iOS 17では、PencilKitはさらに表現力豊かになり、新しいインクが導入されます。

モノラインペンは細部に最適で、一貫したサイズの幅を提供します。

万年筆は、厚いダウンストロークと薄いアップストロークで、書道を模倣しています。

水彩画は美しいストロークと表現力を可能にします。

そして、クレヨンは楽しい追加です。

新しいインクでは、下位互換性を念頭に置いてください。

以前のバージョンのiOSでは、新しいインクを含むPKDrawingsを読み込めません。

PKDrawing、PKStrokeなどのデータモデルタイプの新しいコンテンツバージョンプロパティは、オブジェクトをロードするために必要なPencilKitバージョンを示します。

1のコンテンツバージョンは、iOS 14と2で出荷されたインクを示し、iOS 17の新しいインク用です。

優れたユーザーエクスペリエンスを提供するために、このAPIを使用して非互換性を検出し、メッセージを提供したり、フォールバックイメージをレンダリングしたりします。

下位互換性を維持できない場合は、新しいmaximumSupportedContentVersion APIを使用して、キャンバスとツールピッカーを介して利用可能な機能を制限します。

Magic Keyboardのようなハードウェアキーボードと組み合わせると、iPadをさらにパワフルにするために、キーボードスクロールのサポートを追加しました。

iOS 17の新機能では、UIScrollViewsは、可能であれば、ページアップ、ページダウン、ホーム、および終了キーを使用してスクロールできます。

UIScrollViewの新しいAPIを使用してこの動作をオーバーライドすることができ、KeyboardScrollingを許可します。

最後に、UIKitの複数の分野で行った一般的な機能強化をご案内します。

コレクションビューの改善、新しい春のアニメーションパラメータ、テキストインタラクションなど、8つの一般的な機能強化についてお話しします。

iOS 17で多くのパフォーマンスが向上し、大幅に最適化されたコレクションビューから始めます。

これらのグラフは、多数のアイテムで操作を実行する場合、iOS 17でコレクションビューがどれだけ高速であるかを示しています。

iOS 17は、1万個のアイテムを含むコレクションビューの並べ替え順序を反転させるのはiOS 16のほぼ2倍の速さで、それらのアイテムの半分を削除するアップデートを実行するのはほぼ3倍の速さです。

さらに、アニメーションなしで更新を実行すると、コレクションビューのパフォーマンスがさらに向上します。

スナップショットを差分可能なデータソースに適用する場合でも、バッチ更新を手動で実行する場合でも、iOS 17ではコレクションビューが全面的に高速になります。

これらの改善により、アプリの応答性が向上し、アプリのヒッチが減りなくなります。

さて、最初にかなり典型的なレイアウトの例から始めて、コンポジションレイアウトの強力な新機能について話します。

これはiPadの新しい健康アプリです。お気に入りセクションは、2つのアイテムの行を持つ構成レイアウトを使用しており、すべてNSCollectionLayoutDimension.estimatedを使用して自己サイジングしています。

薬の細胞の高さが隣の細胞の高さと一致しないことに注目してください。

この行のアイテムが同じ高さであれば、これははるかに良く見えるでしょう。

iOS 17では、Compositional Layoutはまったく新しいレイアウトディメンションを取得します：uniformAcrossSiblings。

この新機能により、レイアウト内のセルフサイジングアイテムは、最大のアイテムのサイズに基づいて一貫したサイズを受け取ることができます。

この種のレイアウトが必要な場合は、推定寸法をuniformAcrossSiblingsに置き換えるだけです。

この機能を使用する場合は、最大のアイテムのサイズを決定するために、すべての兄弟アイテムを作成し、サイズ設定する必要があります。したがって、グループに多数のアイテムがある場合は使用しないでください。

この健康アプリの例に戻ります。

このグループには、アイテムの高さが異なる2つのアイテムがあります。

このレイアウトのすべてのアイテムを更新して、uniformAcrossSiblingsを使用するようにしました。これにより、MedicationsセルはSound Levelsセルの高さに合わせて成長し、必要なレイアウトになります。

次に、春のアニメーションでは、理解しやすく、作業しやすいパラメータを指定する新しい方法を洗練しています。

持続時間とバウンスの2つのパラメータのみを使用します。

期間は、アニメーションが完全に完了するのにかかる時間ではなく、春のアニメーションが落ち着くまでの長さを定義し、バウンスとは無関係です。

そして、ゼロからバウンスを増やすと、アニメーションの感触を変えることなく、アニメーションにバウンスが追加されます。

これらのスプリングパラメータを取る新しいメソッドをUIViewに追加しました。

そして、それらはすべてオプションなので、今では「アニメーション」だけを書いて、システムのデフォルトに一致する春のアニメーションを取得することもできます。

スプリングを記述するこの新しい方法についてのより多くの洞察を得るために、「スプリングでアニメーション」トークを見てください。

次に、テキストと対話するための新機能とAPIについて説明します。

私たちは、新しい再設計された選択ルーペを含む、iOS 17のテキストカーソルとテキスト選択UIにいくつかの重要な改善を行いました。

ワードプロセッサなどのカスタムテキストビューを持つ開発者は、UITextInteractionをすべて採用することなく、選択UIにシステムが提供するビューを使用できるようになりました。

テキストビューのテキストアイテムのインタラクションは、UITextViewDelegateの新しいAPIを通じてよりカスタマイズ可能になり、リンクやテキスト添付ファイルなどのテキストアイテムのプライマリアクションやメニューを変更できるようになりました。

さらに、コンテンツのカスタム範囲にタグを付けてインタラクションを有効にすることもできます。これにより、リンクではないテキストにアクションやメニューを簡単に追加できます。

テキストカーソルの改善とテキスト項目のアクションとメニューの詳細については、「テキストとテキストのインタラクションの新機能」をご覧ください。

次に、iOSの確立された要素であるステータスバーに関する最新情報を提供します。

iOSのステータスバーのスタイリングは、その下のアプリケーションによって制御され、アプリまたはビューコントローラーがダークモードまたはライトモードになっていることに基づいて切り替わるデフォルトのスタイルです。

ユーザーコンテンツでは、コントラストを確保するために正しく取得するのが難しい場合があります。

アプリが明るいユーザーインターフェイスを使用しているため、ここでのデフォルトのスタイルは暗いです。

しかし、ユーザーコンテンツの一部は暗いです。

現在、iOS 17では、デフォルトのスタイルはアプリのコンテンツに継続的に調整され、コントラストを維持するためにダークスタイルとライトスタイルの間で自動的に変更されます。

必要に応じて、ステータスバーがスタイルをこぼすことさえできます。

アプリはこれらすべてのケースでダークとライトを明示的に指定する必要がなくなったため、カスタマイズコードを削除し、デフォルトのスタイルを利用する機会があります。

iOS 17では、ドラッグ&ドロップがより強力になっています。

サポートされているファイルとコンテンツは、ホーム画面のアイコンにドロップし、それぞれのアプリで直接開くことができます。

これは今日、多くのドキュメントベースのアプリで変更なしで自動的に機能します。

システムは、アプリのInfo.plistファイルで定義されているCFBundleDocumentTypesを使用して、ドロップされたファイルがサポートされているかどうかを判断します。

ドロップすると、他のURLと同様に、既存のシーンデリゲートメソッドを使用してファイルが開かれます。

この機能を選択するには、アプリがサポートされているドキュメントタイプを定義していることを確認してください。

UIKitはISO HDR画像のサポートを追加し、これらの画像をUIImageViewで簡単に表示したり、UIGraphicsImageRendererで操作したりできます。

さらに、新しいUIImageReaderを使用すると、カメラロールからISO HDRなど、一部のHDR画像形式を変換するなど、画像の読み込み時により多くの制御が提供されます。

詳細については、「アプリでHDR画像をサポートする」セッションをご覧ください。

UIPageControlは、分数ページの進行状況を表す新機能を獲得しました。

今日、ページコントロールは、設定された期間、またはビデオコンテンツに沿って自動的にページングするスライドショーコンテンツを表示するためにアプリで一般的に使用されています。

新しい進行状況とタイマー進行状況APIを使用すると、アクティブなインジケーターで分数ページの進行状況を表すことができ、ページがいつ変更されるかについてのより良いコンテキストを提供できます。

分数の進捗ページコントロールを設定するには、UIPageControlの新しい進捗プロパティを進捗オブジェクトで設定するだけです。

UIPageControlTimerProgressには、各ページの期間を簡単に設定するためのタイマーが組み込まれています。

UIPageControlは、タイマーの期間が満たされると、自動的にページを変更します。

独自の真実のソースを持つビデオプレーヤーや外部タイマーに従う必要があるページについては、基本UIPageControlProgressタイプを使用して、コンテンツが進むにつれてcurrentProgress値を手動で更新します。

iOS 17とmacOS Sonomaはパレットメニューを導入します。

パレットは、アイテムのコレクションから選択するために一般的に使用されるメニュー要素の列です。

このスタイルのコントロールは、iOSのBooksアプリ、またはMacのMailとFinderで見つけることができます。

今では、UIKitでファーストクラスのコントロールとして利用可能になりました。

メニューをパレットに変えるには、.displayAsPaletteをこのようにオプションに追加するだけです。

パレットの要素は比較的小さいため、通常のメニュー要素と同様に、選択はチェックマークで示されません。

代わりに、UIKitは提供された画像に基づいて適切な選択インジケーターを選択します。

パレット内のすべての要素が単色のSFシンボルまたはテンプレート画像を使用している場合、選択した要素はアプリの色合いで着色されます。

要素にマルチカラーのSF記号がある場合、選択したものの周りに色合いのストロークが描画されます。

メニュー要素に完全にカスタム画像を使用している場合、または独自の選択インジケーターを提供して組み込みの動作をオーバーライドしたい場合は、UIMenuLeafプロトコルで新しいselectedImageプロパティを使用できます。

この例では、選択したImageがUIActionの初期化子に設定されています。

UIKitのメニューAPIは、iOS、iPadOS、Mac Catalystで利用でき、同じ使い慣れたAPIで複雑なメニューを構築できます。

そして、tvOS 17以降、同じAPIはすべて、まったく新しい外観とネイティブtvOSの動作でApple TVで利用できます。

うわー！私たちは多くの分野をカバーしました。

UIKitは確かに一連の機能を獲得し、その機能をさらに強化しています。

次は何ですか?

iOS 17 SDKを使用してアプリをコンパイルします。

新しいUIKit機能を組み込み、Xcodeプレビューをプロジェクトで活用してください。

また、UIが柔軟で、非ラテン語のさまざまなテキストメトリックに対応していることを確認してください。

これらのトピックの簡単な概要を楽しんでいただければ幸いです。

より詳細な外観については、関連するビデオをチェックしてください。

ありがとうございます。

♪ ♪