10170

♪ ♪

エヴァン：こんにちは、私の名前はエヴァンです。

今日、私たちは構造化された並行性の基本を超えて、構造化されたタスクが有用な動作の実現を簡素化する方法を模索しています。

始める前に、初めての場合、または構造化された並行性を確認したい場合は、WWDC 2021の「Swiftで構造化された並行性を探索する」セッションと「Swift並行性：舞台裏」セッションを自由にご覧ください。

今日は、タスク階層と、それが自動タスクキャンセル、優先順位の伝播、および有用なタスクローカル値の動作のロックを解除する方法を確認します。

次に、リソースの使用状況を管理するのに役立つタスクグループでいくつかのパターンをカバーします。

最後に、これらすべてが組み合わされ、サーバー環境でのプロファイリングとトレースタスクを容易にする方法を見ていきます。

構造化された並行性を使用すると、「if」ブロックと「for」ループが同期コードで制御フローがどのように振る舞うかを定義するのと同様に、実行が分岐して同時に実行され、その実行の結果が再結合する明確に定義されたポイントを使用して、並行コードについて推論することができます。

「Async let」、タスクグループ、またはタスクまたは切り離されたタスクを作成すると、同時実行がトリガーされます。

結果は、「待機」で示される停止ポイントで現在の実行に再結合します。

すべてのタスクが構造化されているわけではありません。

構造化タスクは「async let」とタスクグループを使用して作成され、非構造化タスクはTaskとTask.detachedを使用して作成されます。

構造化されたタスクは、ローカル変数のように宣言されたスコープの最後まで生き、スコープ外になると自動的にキャンセルされ、タスクの存続期間を明確にします。

可能な限り、構造化されたタスクを好みます。

後で説明する構造化並行性の利点は、必ずしも非構造化タスクに適用されるとは限りません。

コードに飛び込む前に、具体的な例を考えましょう。

複数のシェフがスープを準備しているキッチンがあるとします。

スープの準備は複数のステップで構成されています。

シェフは材料を切り、鶏肉をマリネし、スープを沸騰させ、最後に、準備が整う前にスープを調理する必要があります。

一部のタスクは並行して実行できますが、他のタスクは特定の順序で実行する必要があります。

これをコードで表現する方法を見てみましょう。

今のところ、makeSoup機能に焦点を当てます。

関数に並行性を追加するために非構造化タスクを作成し、必要に応じてその値を待っているかもしれません。

これは、どのタスクが同時に実行でき、どのタスクが実行できないかを表しますが、これはSwiftで並行性を使用する推奨される方法ではありません。

これは、構造化された並行性を使用して表現される同じ関数です。

作成する子タスクの数が知られているので、便利な「async let」構文を使用できます。

これらのタスクは、親タスクと構造化された関係を形成します。

なぜこれが重要なのか、まもなく話します。

makeSoupは多くの非同期関数を呼び出します。

そのうちの1つは「chopIngredients」で、材料のリストを取り、タスクグループを使用してそれらをすべて同時に切り刻みます。

makeSoupに慣れたので、タスク階層を見てみましょう。 タスク階層を見てみましょう。

子タスクは色付きのボックスで示され、矢印は親タスクから子タスクを指しています。

makeSoupには、材料を切り刻む、鶏肉をマリネし、スープを沸騰させるための3つの子供のタスクがあります。

chopIngredientsは、タスクグループを使用して、各成分の子タスクを作成します。

私たちが3つの材料を持っていれば、それも3人の子供を作るでしょう。

この親子階層は、ツリー、タスクツリーを形成します。

タスクツリーを導入したので、それがコードにどのように役立つかを特定し始めましょう。

タスクのキャンセルは、アプリがタスクの結果を必要としなくなり、タスクが停止して部分的な結果を返すか、エラーをスローする必要があることを知らせるために使用されます。

私たちのスープの例では、その顧客が去った場合、何か他のものを注文したいと決めた場合、または閉店時間になった場合、スープの注文をやめたいと思うかもしれません。

タスクのキャンセルの原因は何ですか?

構造化タスクは、スコープ外になると暗黙的にキャンセルされますが、タスクグループで「cancelAll」を呼び出して、すべてのアクティブな子と将来の子タスクをキャンセルできます。

非構造化タスクは、「キャンセル」機能で明示的にキャンセルされます。

親タスクをキャンセルすると、すべての子タスクがキャンセルされます。

キャンセルは協力的なので、子供のタスクはすぐには停止されません。

そのタスクに「isCancelled」フラグを設定するだけです。

実際にキャンセルに基づいて行動することは、あなたのコードで行われます。

キャンセルはレースです。

チェックの前にタスクがキャンセルされた場合、「makeSoup」は「SoupCancellationError」をスローします。

警備員の実行後にタスクがキャンセルされた場合、プログラムはスープの準備に続けます。

部分的な結果を返す代わりにキャンセルエラーをスローする場合は、「Task.checkCancellation」を呼び出すことができ、タスクがキャンセルされた場合に「CancellationError」をスローします。

結果がまだ必要であることを確認するために、高価な作業を開始する前に、タスクのキャンセル状況を確認することが重要です。

キャンセルチェックは同期的であるため、キャンセルに反応する非同期または同期の機能は、続行する前にタスクのキャンセルステータスを確認する必要があります。

「isCancelled」または「checkCancellation」によるキャンセルのポーリングは、タスクが実行されているときに便利ですが、AsyncSequenceを実装するときのように、タスクが一時停止され、コードが実行されていない間は、キャンセルに応答する必要がある場合があります。

これは「withTaskCancellationHandler」が便利な場所です。

シフト機能を紹介しましょう。

料理人は、タスクのキャンセルによって通知され、シフトの終わりまで注文が入ってくるので、スープを作る必要があります。

1つのキャンセルシナリオでは、非同期for-loopはキャンセルされる前に新しい注文を取得します。

「makeSoup」関数は、先に定義したようにキャンセルを処理し、エラーをスローします。

別のシナリオでは、タスクが中断されている間にキャンセルが行われ、次の注文を待つことがあります。

このケースは、タスクが実行されていないため、より興味深いため、キャンセルイベントを明示的にポーリングすることはできません。

代わりに、キャンセルハンドラを使用してキャンセルイベントを検出し、非同期のfor-loopから抜け出す必要があります。

注文はAsyncSequenceから生成されます。

AsyncSequencesは、非同期の「次の」関数を定義するAsyncIteratorによって駆動されます。

同期イテレータと同様に、「次」関数はシーケンス内の次の要素を返すか、シーケンスの最後にいることを示すためにnilを返します。

多くのAsyncSequencesは、実行中のシーケンスを停止するために使用するステートマシンで実装されています。

ここでの例では、「isRunning」が真の場合、シーケンスは注文を発し続ける必要があります。

タスクがキャンセルされたら、シーケンスが完了し、シャットダウンする必要があることを示す必要があります。

これを行うには、シーケンスステートマシンで「キャンセル」関数を同期的に呼び出します。

キャンセルハンドラはすぐに実行されるため、ステートマシンはキャンセルハンドラと本体の間で可変状態が共有され、同時に実行できることに注意してください。

ステートマシンを保護する必要があります。

俳優はカプセル化された状態を保護するのに最適ですが、ステートマシン上の個々のプロパティを変更して読みたいので、俳優はこれに適したツールではありません。

さらに、操作がアクターで実行される順序を保証できないため、キャンセルが最初に実行されることを保証することはできません。

私たちは何か他のものが必要になります。

Swift Atomicsパッケージのアトミックを使用することにしましたが、ディスパッチキューまたはロックを使用できます。

これらのメカニズムにより、共有状態を同期し、競合状態を回避しながら、キャンセルハンドラに非構造化タスクを導入することなく、実行中のステートマシンをキャンセルすることができます。

タスクツリーは自動的にタスクのキャンセル情報を伝播します。

キャンセルトークンと同期を心配する代わりに、Swiftランタイムに安全に処理させます。

キャンセルはタスクの実行を停止せず、キャンセルされたことをタスクに通知するだけで、できるだけ早く実行を停止する必要があることを覚えておいてください。

キャンセルを確認するのはあなたのコード次第です。

次に、構造化されたタスクツリーが優先順位を伝播し、優先順位の反転を回避するのにどのように役立つかを考えてみましょう。

まず、優先順位とは何ですか、そしてなぜ私たちは気にするのですか?

優先順位は、特定のタスクがどれほど緊急であるかをシステムに伝える方法です。

ボタン押下への応答などの特定のタスクは、すぐに実行する必要があるか、アプリがフリーズして表示されます。

一方、サーバーからのコンテンツのプリフェッチなどの他のタスクは、誰にも気づかれずにバックグラウンドで実行できます。

第二に、優先度反転とは何ですか?

優先度の反転は、優先度の高いタスクが優先度の低いタスクの結果を待っているときに発生します。

デフォルトでは、子タスクは親から優先度を継承するので、makeSoupが中優先度のタスクで実行されていると仮定すると、すべての子タスクも中優先度で実行されます。

スープを求めて私たちのレストランに来るVIPゲストとしましょう。

私たちは良いレビューを得るために、彼らのスープをより優先します。

彼らがスープを待つとき、すべての子タスクの優先順位がエスカレートし、優先順位の高いタスクが優先順位の低いタスクを待っていないことを確認し、優先順位の反転を回避します。

優先度の高いタスクの結果を待つと、タスクツリー内のすべての子タスクの優先度がエスカレートします。

タスクグループの次の結果を待つと、次に完了する可能性が最も高いものがわからないため、グループ内のすべての子タスクがエスカレートすることに注意してください。

並行性ランタイムは優先度キューを使用してタスクをスケジュールするため、優先度の高いタスクは優先度の低いタスクの前に実行するように選択されます。

タスクは、その寿命の残りの期間、エスカレートされた優先順位を維持します。

優先エスカレーションを元に戻すことはできません。

私たちは迅速なスープ配達でVIPゲストを効果的に満足させ、良いレビューを得たので、私たちのキッチンは今人気になり始めています。

私たちは、リソースを効果的に使用していることを確認したいし、多くのチョッピングタスクを作成していることに気づきました。

タスクグループとの並行性を管理するための便利なパターンをいくつか調べてみましょう。

私たちは非常に多くのまな板のためのスペースしかありません。

同時に材料を切り刻みすぎると、他のタスクのためのスペースが足りなくなるので、同時に切り刻まれる材料の数を制限したいと考えています。

コードに戻って、チョッピングタスクを作成するループを調査したい。

各成分の元のループを、チョッピングタスクの最大数まで起動するループに置き換えます。

次に、結果を収集するループで、以前のタスクが終了するたびに新しいタスクを開始します。

新しいループは、実行中のタスクの1つが終了するまで待機し、まだチョップする材料がありますが、次の成分をチョップする新しいタスクを追加します。

パターンをより明確に見るために、このアイデアを抽出しましょう。

最初のループは、最大数の同時タスクを作成し、作成しすぎないようにします。

最大数のタスクが実行されたら、1つが終了するのを待ちます。

それが終了し、停止条件に達していない後、進歩し続けるための新しいタスクを作成します。

これにより、以前のタスクが終了するまで新しい作業を開始しないため、グループ内の同時タスクの数が制限されます。

先ほど、シフトで働くシェフと、シフトがいつ終わったかを示すためにキャンセルを使用することについて話しました。

これは、シフトを処理するキッチンサービスコードです。

各料理人は別々のタスクでシフトを開始します。

料理人が働いたら、タイマーを始めます。

タイマーが終了したら、進行中のシフトをすべてキャンセルします。

どのタスクも値を返さないことに注意してください。

Swift 5.9の新機能には、withDiscardingTaskGroup APIがあります。

タスクグループを破棄することは、完了した子タスクの結果を保持しません。

タスクで使用されるリソースは、タスクが終了した直後に解放されます。

実行メソッドを変更して、破棄タスクグループを利用することができます。

タスクグループを破棄すると、自動的に子がクリーンアップされるため、グループを明示的にキャンセルしてクリーンアップする必要はありません。

破棄タスクグループには、兄弟の自動キャンセルもあります。

子タスクのいずれかがエラーをスローすると、残りのタスクはすべて自動的にキャンセルされます。

これはここでのユースケースに最適です。

シフトが終わったら「TimeToCloseError」をスローすることができ、すべてのシェフのシフトが自動的に終了します。

新しい破棄タスクグループは、結果を収集する必要がある通常のタスクグループとは異なり、タスクが終了すると自動的にリソースを解放します。

これは、リクエストのストリームを処理しているときなど、何も返す必要がないタスクがたくさんあるときに、メモリ消費量を減らすのに役立ちます。

状況によっては、タスクグループから値を返すだけでなく、同時タスクの数を制限したいこともあります。

あるタスクの完了を使用して別のタスクを開始し、タスクの爆発を回避するための一般的なパターンを取り上げました。

私たちはこれまで以上に効率的にスープを作っていますが、まだもっとスケールアップする必要があります。

プロダクションをサーバーに移行する時が来ました。

それに伴い、処理される注文を追跡するという課題が伴います。

タスクローカルの値は助けるためにここにあります。

タスクローカル値は、特定のタスク、より正確にはタスク階層に関連付けられたデータです。

これはグローバル変数のようなものですが、タスクローカル値にバインドされた値は、現在のタスク階層からのみ使用できます。

タスクローカル値は、「TaskLocal」プロパティラッパーで静的プロパティとして宣言されます。

タスクをローカルにオプションにするのは良い習慣です。

値が設定されていないタスクは、オプションのnilで簡単に表されるデフォルト値を返す必要があります。

ローカルのバインドされていないタスクには、そのデフォルト値が含まれています。

私たちの場合、オプションの文字列があるので、それはnilであり、現在のタスクに関連付けられたクックはありません。

タスクローカル値は明示的に割り当てることはできませんが、特定のスコープにバインドする必要があります。

バインディングはスコープの期間中持続し、スコープの最後に元の値に戻ります。

タスクツリーに戻ると、各タスクにはタスクローカル値に関連する場所があります。

スープを作る前に、「さくら」という名前を「クック」タスクローカル変数にバインドしました。

makeSoupのみがバインドされた値を保存します。

子は、タスクローカルストレージに保存された値を持っていません。

タスクローカル変数にバインドされた値を探すには、その値を持つタスクを見つけるまで、各親を再帰的に歩く必要があります。

値がバインドされたタスクが見つかった場合、ローカルのタスクはその値を想定します。

親がないタスクによって示されるルートに到達すると、ローカルタスクはバインドされておらず、元のデフォルト値を取得します。

Swiftランタイムは、これらのクエリをより高速に実行するために最適化されています。

木を歩く代わりに、探している鍵でタスクを直接参照します。

タスクツリーの再帰的な性質は、前者の値を失うことなく、値をシャドーイングするのに適しています。

スープ製造プロセスの現在のステップを追跡したいとします。

「step」変数を「makeSoup」の「soup」にバインドし、「chopIngredients」の「chop」に再バインドできます。

chopIngredientsにバインドされた値は、元の値を観察する chopIngredientsから戻るまで、前者の値をシャドウします。

ビデオ編集の魔法の力を通じて、私たちはスープの需要に追いつくためにサービスをクラウドに移行しました。

私たちはまだ同じスープ作り機能を持っていますが、代わりにサーバー上にあります。

注文がシステムを通過するのを観察し、タイムリーに完了していることを確認し、予期しない障害を監視する必要があります。

サーバー環境は多くのリクエストを同時に処理するため、特定の順序を追跡できる情報を含める必要があります。

手作業でのロギングは反復的で冗長であり、微妙なバグやタイプミスにつながります。

ああ、いや、注文IDだけでなく、誤って注文全体をログに記録してしまいました。

タスクローカル値を使用して、ロギングの信頼性を高める方法を見つけましょう。

Appleデバイスでは、OSLog APIを直接使い続けたいと思うでしょうが、アプリケーションの一部がクラウドに移行するにつれて、他のソリューションが必要になります。

SwiftLogは、複数のバッキング実装を備えたロギングAPIパッケージで、サーバーに変更を加えることなく、ニーズに合ったロギングバックエンドをドロップすることができます。

MetadataProviderは、SwiftLog 1.5の新しいAPIです。

メタデータプロバイダーを実装すると、ロギングロジックを簡単に抽象化し、関連する値に関する一貫した情報を確実に送信できます。

メタデータプロバイダーは、辞書のような構造を使用し、ログに記録される値に名前をマッピングします。

orderIDタスクローカル変数を自動的にログに記録したいので、定義されているかどうかを確認し、定義されている場合は辞書に追加します。

複数のライブラリは、ライブラリ固有の情報を探すために独自のメタデータプロバイダーを定義できるため、MetadataProviderは、複数のメタデータプロバイダーを受け取り、それらを1つのオブジェクトに結合する「マルチプレックス」関数を定義します。

メタデータプロバイダーができたら、そのプロバイダーでロギングシステムを初期化し、ロギングを開始する準備が整いました。

ログには、メタデータプロバイダーで指定された情報が自動的に含まれるので、ログメッセージに含めることを心配する必要はありません。

ログは、注文0がキッチンに入り、シェフがその注文を受け取る場所として表示されます。

メタデータプロバイダーの値はログに明確にリストされているため、スープ製造プロセスを通じて注文を簡単に追跡できます。

タスクローカル値を使用すると、タスク階層に情報を添付できます。

切り離されたタスクを除くすべてのタスクは、現在のタスクからタスクローカル値を継承します。

それらは特定のスコープで特定のタスクツリーにバインドされており、タスク階層を介して追加のコンテキスト情報を伝播するための低レベルのビルディングブロックを提供します。

次に、タスク階層とツールを使用して、同時分散システムをトレースしてプロファイリングします。

Appleプラットフォームで並行性を扱うとき、Instrumentsはあなたの友達です。

Swift Concurrencyインストゥルメントは、構造化されたタスク間の関係についての洞察を提供します。

詳細については、セッション「Swiftの並行性の視覚化と最適化」をチェックしてください。

インスツルメンツはまた、「インスツルメント内のHTTPトラフィックを分析する」セッションでHTTPトラフィックインスツルメントを導入しました。

HTTPトラフィックアナライザは、ローカルで発生するイベントのトレースのみを表示します。

プロファイルには、サーバーからの応答を待っている間に灰色のボックスが表示されるので、サーバーのパフォーマンスを向上させる方法を理解するには、より多くの情報が必要です。

新しいSwift分散トレーシングパッケージをご紹介します。

タスクツリーは、単一のタスク階層で子タスクを管理するのに最適です。

分散トレースを使用すると、複数のシステムにわたるタスクツリーの利点を活用して、パフォーマンス特性とタスク関係についての洞察を得ることができます。

Swift Distributed TracingパッケージにはOpenTelemetryプロトコルが実装されているため、ZipkinやJaegerなどの既存のトレースソリューションは箱から出してすぐに機能します。

Swift Distributed Tracingの目標は、Xcode Instrumentsの不透明な「応答待ち」に、サーバーで何が起こっているかに関する詳細情報を記入することです。

どこに集中する必要があるかを把握するために、サーバーコードを計測する必要があります。

分散トレースは、ローカルでのトレースプロセスとは少し異なります。

関数ごとのトレースを取得する代わりに、「withSpan」APIを使用してスパンでコードを計測します。

スパンを使用すると、トレースシステムで報告されるコードの領域に名前を割り当てることができます。

スパンは機能全体をカバーする必要はありません。

それらは、特定の機能の特定の部分についてより多くの洞察を提供することができます。

withSpanは、追加のトレースIDやその他のメタデータを使用してタスクに注釈を付け、トレースシステムがタスクツリーを単一のトレースにマージできるようにします。

トレースシステムには、タスクのランタイムパフォーマンス特性に関する情報とともに、タスク階層に関する洞察を提供するのに十分な情報があります。

スパン名はトレースUIに表示されます。

混乱することなく、特定のスパンに関する情報を簡単に見つけることができるように、それらを短く説明的に保ちたいと思うでしょう。

スパン属性を使用して追加のメタデータを添付できるので、スパン名をオーダーIDで乱雑にする必要はありません。

ここでは、スパン名を「#function」ディレクティブに置き換えて、スパン名を関数名で自動的に塗りつぶし、スパン属性を使用して現在の注文IDをトレーサーに報告されたスパン情報に添付しました。

トレースシステムは通常、特定のスパンを検査しながら属性を提示します。

ほとんどのスパンには、HTTPステータスコード、要求と応答のサイズ、開始時間と終了時間、その他のメタデータが付属しており、システムを通過する情報を簡単に追跡できます。

前のスライドで述べたように、独自の属性を定義できます。

スパンを活用する方法のその他の例については、swift-distributed-tracing-extrasリポジトリをご覧ください。

タスクが失敗してエラーが発生した場合、その情報もスパンで表示され、トレースシステムで報告されます。

スパンにはタイミング情報とツリー内のタスクの関係の両方が含まれているため、タイミングレースによって引き起こされるエラーを追跡し、それらが他のタスクにどのように影響するかを特定するのに役立つ方法です。

トレースシステムと、トレースIDを使用してタスクツリーを再構築する方法、および独自の属性をスパンに添付する方法について話しましたが、まだ分散システムへの作業を開始していません。

トレースシステムの美しさは、これ以上やるべきことがないことです。

キッチンサービスからチョッピングサービスを考慮し、同じコードを保持すると、トレースシステムは自動的にトレースを拾い、分散システムの異なるマシンに関連付けます。

トレースビューは、スパンが別のマシンで実行されていることを示しますが、それ以外は同じになります。

分散トレースは、HTTPクライアント、サーバー、その他のRPCシステムなど、システムのすべての部分がトレースを受け入れる場合に最も強力です。

Swift Distributed Tracingは、タスクツリー上に構築されたタスクローカル値を活用して、信頼性の高いクロスノードトレースを生成するために必要なすべての情報を自動的に伝播します。

構造化されたタスクは、並行システムの秘密を解き明かし、操作を自動的にキャンセルし、優先順位情報を自動的に伝播し、複雑な分散ワークロードの追跡を容易にするツールを提供します。

これらのすべては、Swiftの並行性の構造化された性質のために機能します。

このセッションが構造化された並行性についてあなたを興奮させ、構造化されていない代替手段を使用する前に構造化されたタスクに到達することを願っています。

見てくれてありがとう!

構造化された並行性を使用して、他にどのような有用なパターンを思いつくかを見るのが待ちきれません。

うーん、スープ！

♪ ♪