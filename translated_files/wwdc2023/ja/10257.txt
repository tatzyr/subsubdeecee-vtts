10257

♪ ♪

ポール：こんにちは。

私はポールで、SFシンボルアプリに取り組んでいます。

導入以来、SFシンボルは、Appleプラットフォームの見た目と感触を大きくする大きな部分を占めています。

シンボルは一貫しています。Appleのプラットフォームには何千ものシンボルが組み込まれており、共通のビジュアルデザインと行動を共有しています。

彼らはアプリやインターフェースをすぐに身近に感じさせることができます。

シンボルはカスタマイズ可能です。ニーズに合った組み込みシンボルがない場合は、SFシンボルアプリを使用して、システムが提供するものと同じ強力な機能を備えた独自のシンボルを作成できます。

そしてもちろん、シンボルは表現力豊かです。

シンボルは、少量の画面の不動産で複雑な概念を伝えることができます。

彼らは言語を超越した方法でアイデアを伝えることができます。

そして、彼らはあなたのアプリをより生き生きと遊び心のある気分にさせることができます。

そして今、SFシンボル5で、シンボルはアニメーションで表現力の全く新しい次元を獲得しています。

そして、SFシンボルアプリは、この新しい次元を探求するのに役立ちます。

今日は、SFシンボルアプリを使用して新しいアニメーション効果をテストドライブする方法、新しいカスタムシンボルを作成し、既存のカスタムシンボルを更新して、すべての新しいアニメーション機能と完璧に機能するようにする方法、独自のカスタムシンボルに基づいて使い慣れた認識可能なシンボルを作成する新しい方法、そして最後に、古いプラットフォームでもアプリで使用しているシンボルが素晴らしく見えるようにする方法について説明します。

それでは、SFシンボルアプリを起動して、いくつかの例を見てみましょう。

ツアーの最初の停留所は、ここサイドバーの新しいタブです。

これはアニメーションインスペクタであり、ご想像のとおり、新しいアニメーション効果をプレビューするために使用できます。

より良い外観を得るために、ギャラリービューに切り替えましょう。

そして、内蔵スピーカーシンボルの1つをつかんで実験します。

このポップアップボタンから新しいアニメーション効果を選択できます。

バウンスアニメーションは始めるのに最適な場所です。

プレビューボタンを押すと、メインギャラリービュー、その下のシンボル行、サイドバーのプレビュー領域でアニメーションが再生されるので、すべての異なるレンダリングモードで見ることができます。

プレビューボタンの周りには、アニメーションを設定するためのコントロールが表示されます。

シンボルが上向きにバウンスするか下向きにバウンスするか、シンボルのレイヤーを別々にバウンスするか、シンボル全体を一度にバウンスするかなどのオプションを選択できます。

これらの設定の一部を変更すると、プレビュー領域の下のラベルが「自動」から「変更」に変更されました。

アプリのコードを書くときは、すべてのアニメーションタイプにデフォルト設定が付属しています。

SFシンボルアプリを起動すると、これらのデフォルト設定が事前に選択され、ここに「自動」という単語が表示されます。

デフォルト以外のものに切り替えると、ここに「変更済み」という単語が表示され、設定を変更したことを知らせます。

ここに表示されるリセットボタンをクリックして、デフォルトに戻ることができます。

気に入った設定を見つけたら、コードで直接指定したい場合は、このボタンをクリックして、SwiftまたはObjective-C APIに必要なエフェクトの名前をコピーできます。

しかし、新しいアニメーションのチェックに戻りましょう。

このスピーカーシンボルは、可変色もサポートしています。

では、可変カラーアニメーションを試してみましょう。

累積オプションを選択すると、可変カラーレイヤーが徐々にアクティブになり、すべて一緒にフェードアウトします。

Iterativeを選択すると、一度に1つのレイヤーのみがアクティブになります。

そして、反転オプションをオンにして、この設定がどのように異なる感覚を生み出すかを確認できます。

だから、新しいアニメーション効果を簡単に見てみましょう。

システムが提供するSFシンボルを使用してプレビューしてきましたが、いつものように、組み込みのシンボルはストーリーの半分にすぎません。

アプリにカスタムシンボルがある場合、SFシンボルアプリは、アニメーションの脚光を浴びる準備ができていることを確認するのに役立ちます。

今、私は娘と一緒にパズルキューブを解く練習をするのに役立つアプリに取り組んでいたときの昨年からいくつかのカスタムシンボルを持っています。

今年、私はスピードキューブを卒業したので、キューブを解くのにかかる時間を追跡するためにアプリを更新したいです。

昨年のカスタムシンボルをつかんで、アニメーションの準備を始めましょう。

これが去年作った3x3のキューブシンボルです。

階層レンダリングとマルチカラーレンダリングのために注釈を付け、可変色を適用できるように前面を異なるレイヤーに分割しました。

私のシンボルは可変色なので、箱から出してすぐに可変色のアニメーションをサポートしています。

これをローディングインジケーターに使用できます。

他のアニメーションを見てみましょう。 ではいくつかのアニメーションを見てみましょう。

パルスは、私の解決タイマーが一時停止されたときに最適です。

しかし、プレビューボタンを押すと、バイレイヤー設定が選択されているにもかかわらず、シンボル全体が脈打っています。

ここの注釈リストには、By Layer設定を使用しているときにどのレイヤーをパルスするかを指定できる新しいコントロールがあります。

私のシンボルのレイヤーのどれもマークされていない場合、シンボル全体が脈動します。

では、前面を構成するすべてのレイヤーをパルスにマークし、もう一度プレビューしてみましょう。

それが私たちが望む行動です。

私のタイマーが一時停止すると、これは素晴らしく見えるでしょう。

他のすべてのアニメーションはモーションを使用しているので、次に確認する必要があります。

SFシンボルアプリのバージョン4以前からエクスポートされたシンボルがある場合、またはXcode 14と互換性があるようにエクスポートされている場合は、モーション情報は含まれず、常にアプリでシンボル全体として移動します。

しかし、Xcode 15で使用するために、このバージョンのSFシンボルアプリバージョン5からエクスポートするとどうなるか見てみましょう。

バウンスアニメーションに戻り、パズルキューブのシンボルで再生します。

それはたくさんの動きです!

デフォルトでは、By Layerが選択されている場合、シンボル内のすべてのレイヤーは独立して移動します。

今、私はシンボルアニメーションにかなり興奮していますが、これはあまりにも良いことかもしれません。

注釈の新機能でこれを修正できます。

これで、すべてのサブレイヤーを一緒にアニメーション化できるレイヤーのグループを作成できます。

前面を構成するすべてのレイヤーを選択し、新しいレイヤーグループに追加します。

レイヤーグループ内では、すべてのレイヤーはまだ独自の注釈と設定を保持していますが、今ではすべて一緒に移動しています。

今は動きが少なくなっていますが、キューブの異なる部分が別々に動くのはまだ少し奇妙に見えます。

では、シンボルのすべてのレイヤーを元に戻して選択し、それらをすべて1つのグループに追加しましょう。

それはこのシンボルの精神と一致します。

キューブの異なる面は実際には別々に移動せず、この図面では実際には異なるレベルの深さではありません。

これらすべてのレイヤーをグループ化することで、コードがレイヤーごとに要求した場合でも、キューブが常に単一のユニットとしてアニメーション化されるようにしました。

最終的には、カスタムシンボルを個別に見て、それぞれに適したモーショングループを決定する必要があります。

さて、先ほど述べたように、シンボルの強みの1つは一貫性と親しみやすさです。

これは、カスタムシンボルで作業する際に覚えておくべき重要な概念です。

これは私が昨年取り組んでいた別のカスタムシンボルです。

それは私のパズルキューブですが、それは満たされた円の上に置かれています。

この円形のエンクロージャは、SFシンボルの一般的なデザイン要素です。

組み込みライブラリには、このビデオシンボルのように、同様の円形処理を使用するシンボルがたくさんあります。

そして、円形の境界線やスラッシュやバッジのような修飾子など、SFシンボルのレパートリー全体にこの種の再利用可能なデザインパターンの他の多くの例があります。

これらの治療の一貫性は、SFシンボルを即座に認識し、身近にする重要なものの1つです。

カスタムシンボルは、その親しみやすさのすべての利点を得るために、これらの治療法を一致させようとする必要があります。

では、カスタムシンボルがシステムと一致していることを確認するにはどうすればよいですか?

さて、私はシステムシンボルのライブラリを見て、同様のシンボルの例を見つけ、その新しい図面をベースにすることができます。

そして、シンボルが異なるレンダリングモードのそれぞれでどのように注釈付けされるか、レイヤーによってアニメーション化されたときにどのように動くか、どのように脈打つのか、そしてこのエンクロージャでその可変色設定がどのように変化するかを見ることができました。

そして、他のエンクロージャ、スラッシュ、バッジなど、他の一般的なデザインパターンでも同じことができます。

しかし、それは覚えておくべきことがたくさんあります。

そして、私はむしろ私のパズルキューブの最上層を解決する最速の方法を覚えておくためにその精神的な空間を使いたいです。

SFシンボルの目標の1つは、一貫性のある使い慣れた体験を提供するために、カスタムシンボルがシステムが提供するシンボルと一緒にできるだけ簡単に収まるようにすることです。

だから、今年はシンボルコンポーネントを紹介することにとても興奮しています。

シンボルコンポーネントは、システムが提供するSFシンボルのように見え、感じるアートワークと動作を提供します。

カスタムシンボルの1つを取り、シンボルコンポーネントと組み合わせると、すぐに、組み込みの友人のように見え、感じる新しいシンボルが手になります。

いくつかのコンポーネントを私の信頼できるパズルキューブシンボルと組み合わせて、それらがどのように機能するかを見てみましょう。

まず、カスタムシンボルのコンテキストメニューを表示し、シンボルとコンポーネントを組み合わせることを選択します。

表示されるシートでは、コンポーネントのライブラリを見て、使用したいものを選択できます。

エンクロージャ、バッジ、スラッシュコンポーネントがあります。

スラッシュ、バッジプラス、サークル、サークルフィルから始めます。

そして、それだけです。

これらの新しいシンボルが私のカスタムシンボルライブラリに登場していることがわかりますが、すでに見栄えがします。

プラスバッジはマルチカラーに正しく着色されています。

スラッシュはすでにその背後にあるパズルキューブとは別にアニメーション化されています。

そして、.circle.fillバージョンは、階層モードでプライマリレイヤーを使用するようにすでに設定されていますが、その背後にある円を通してモノクロで消去されます。

そして、それは私の可変色の設定さえ保持しました。

ベースシンボルの外観とデザインに応じて、追加の調整を行うこともできます。これは、通常アノテーションコントロールがあるサイドバーで行うことができます。

たとえば、視覚的なアーティファクトを避けるためにバッジの位置を少し押したり、シンボルの反対側に移動したりすることもできます。

または、スラッシュの長さを変更して、シンボルが十分にカバーされていることを確認することもできます。

今、あなたはまた、あなたの新しいシンボルがシンボルがサポートするさまざまなスケールとウェイトのすべてで素晴らしく見えることを確認したいと思うでしょう。

3つのスケールと9つのウェイトで、合計27の異なるバリエーションがあります。

しかし、良いニュースは、シンボルコンポーネントがあなたのためにほとんどの作業を処理する可変テンプレートによって供給されているということです。

可変テンプレートはSFシンボル3で導入されました。小規模で3つの図面を提供するだけで済みます。超軽量、レギュラー、ブラックウェイト用にそれぞれ1つずつです。

その後、各図面で使用したベジェパスで互換性がある限り、システムは図面を混在させて残りの24の可能なバリアントを作成できます。

そして、あなたが私に尋ねるなら、3の価格で27のシンボルを得ることはかなり大きな取引です。

シンボルコンポーネントは同じように機能します。スモール+ウルトラライト、スモール+レギュラー、スモール+ブラックのバリエーションを制御できます。

ギャラリービューの上部にプレビューのセットがあるので、3つの異なる重みでシンボルを表示し、それらをすばやく切り替えることができます。

多くの場合、このスラッシュを長くしたときのように、レギュラーウェイトを調整するだけで、変更はウルトラライトとブラックに引き継がれます。

しかし、エンクロージャのオーバーラップなどの問題が発生した場合、またはシンボルの形状に異なるアライメントが必要な場合は、超軽量またはブラックウェイトのオーバーライドチェックボックスをクリックして、追加の調整を行うことができます。

密閉されたキューブのスケールを少し下げて、もう少し呼吸の余地を与えます。

このシステムは、セミボールドのような重みの間に自動的に作成するときに、これらの新しい調整を考慮に入れます。

そして実際、システムはこのようなエンクロージャの舞台裏でさらに多くの作業を行っています。

ベースシンボルがエンクロージャに収まるように縮小されると、システムはベースシンボルの可変テンプレートを使用して重量補償を適用し、サイズが減少するにつれてシンボルの重量と厚さを増やしています。これは、より大きく、囲まれていないバージョンとそれを取り巻く円の両方と一貫性を保つのに役立ちます。

また、シンボルコンポーネントの他の多くの部分と同様に、囲まれたシンボルの重みをさらに微調整して、最終的な視覚的な結果を得ることができます。

そして、それがシンボルコンポーネントの強力な方法です。

これらは、システムが提供するSFシンボルのレパートリーに一致する動作とアートワークを使用して、既存のカスタムシンボルに基づいて新しいシンボルを作成するための迅速かつ簡単な方法です。

シンボルコンポーネントは、必要に応じて重量補償を適用できるように、可変テンプレートから作られたカスタムシンボルと連携する必要があることを忘れないでください。

これはまた、変数テンプレートにある可能性のある個々のバリアントのオーバーライドが、コンポーネントと組み合わせると無視されることを意味します。

そして最後に、コンポーネントを使用して作成されたシンボルから編集可能なテンプレートをエクスポートできないことに注意してください。

シンボルコンポーネントは、調整後に図面を処理するように設計されているため、手動で編集する必要はありません。

今年のSFシンボルアプリには40以上のコンポーネントが含まれています。

締めくくる前に、考慮すべき重要な分野がもう1つあります。

新機能を採用する際には、アプリを使用している多くの人々が古いプラットフォーム上にあり、素晴らしいアプリ内体験に値することを覚えておくことも重要です。

SFシンボルアプリ内のエクスペリエンスを再設計し、アプリがサポートするすべてのプラットフォームでシンボルの外観と動作を確実にできるようにしました。古いものでも。

編集可能なテンプレートをエクスポートしてシンボルの形状と構造を変更すると、以前にテンプレートに表示されていた塗りつぶされた図形ではなく、ワイヤーフレームビューが表示されます。

動きに最適化されたシンボルには、感嘆符バッジの周りのこの余分な境界線のように、レンダリング中に他の図形の一部を消去するために使用される図形が含まれることがよくあります。

描画段階でシンボルを構成する図形に焦点を当て、アプリでシンボルに注釈を付けるまで待って、どの図形が色を描き、どの図形が消去されるかをマークする方が良いことがわかりました。

テンプレートのこのワイヤーフレームスタイルは、まさにそれを行うのに役立ちます。

テンプレートをエクスポートするときに、新しい互換性ピッカーもあります。

デフォルトでは、最新かつ最高のシンボルを取得し、その多くは動きのために再描画されています。

しかし、古いプラットフォームをターゲットにしている場合、SFシンボルアプリはそのプラットフォームにより適したテンプレートを提供します。

たとえば、iOS 15とmacOS Montereyに対応するSFシンボル3をターゲットにしている場合、モーションに使用するレイヤー構造がSFシンボル3で完全にサポートされていなかったため、モーション用に最適化されていないよりシンプルな図面を取得します。

また、iOS 14とmacOS Big Surに対応するSFシンボル2をターゲットにしている場合は、SFシンボル3で可変テンプレートが導入されたため、自動的に静的テンプレートを取得します。

カスタムシンボルに注釈を付けるときにも同じ概念が適用されます。

デフォルトでは、アプリが提供するすべての注釈機能にアクセスできます。

しかし、特定のプラットフォームをターゲットにするようにシンボルを設定することができ、アプリはシンボルの準備ができていることを確認するのに役立ちます。

たとえば、SFシンボル3以前を選択した場合、モノクロアノテーションはSFシンボル4までカスタマイズできなかったため、シンボルのモノクロアノテーションを編集できなくなります。

そして最後に、シンボルをXcode用にエクスポートする準備ができたら、使用するXcodeのバージョンをアプリに伝えるだけです。

アプリは、エクスポートするのに最適なファイル形式を選択し、古いプラットフォームをターゲットとするアプリにコンパイルされたときにファイルが正しく動作することを確認するのに役立ちます。

だから、SFシンボルアプリでアニメーションの準備ができているシンボルを作成するのがどれほど簡単で速いかです。

アニメーションインスペクタ、新しい注釈機能、シンボルコンポーネント、互換性チェックを使用すると、数回クリックするだけです。

実際には、スピードキュービングを学んだ私の経験によく似ています。

考慮すべき多くの角度、多くの異なる可動部分があり、管理すべき情報のトンのように思えますが、適切なツールがあれば、その速さに驚かれることでしょう...

それはすべて一緒に来るだけです。

見てくれてありがとう。

♪ ♪