10128

♪ ♪

Pawel Szczerbuk: こんにちは、私の名前はPawel Szczerbukで、GPUソフトウェアエンジニアです。

Metalは、レイトレーシングアプリケーションを複雑で詳細なシーンに拡張するのに役立ちます。

レイトレーシングはプロダクションレンダリングにおける画像の忠実度の基本であり、ゲームのレイトレーシングは視覚品質を向上させながら高いフレームレートに焦点を当てています。

ディズニーのモアナアイランドシーンのこの画像は、メタルレイトレーシングでレンダリングされました。

今日は、メタルレイトレーシングの使い方について話します。

ゲームやプロダクションレンダラーでレイトレーシングを加速するために使用できるエキサイティングな新機能を強調します。

レイトレーシングアプリケーションは、シーンの周りに跳ね返る個々の光線をシミュレートします。メタルレイトレーシングでレンダリングするには、最初のステップはシーンジオメトリを定義することです。

次に、Metalはジオメトリを含む加速構造を構築し、GPUアクセラレーションを使用して交差点を効率的に照会できます。

GPU関数で、シーンと交差する光線を作成します。

シェーダーにインターセクターオブジェクトを作成し、光線と加速度構造の両方を提供します。

これにより、ピクセルをシェーディングするか、さらに処理するために必要なすべての情報を含む交差結果が返されます。

これらの各ピースが連携して、シーンを構築し、インスタンシングを使用して視覚的な複雑さを追加し、レイ交差を実行できるようにします。

そして、レイトレーシングアプリケーションで作業するのに役立つ素晴らしいツールがいくつかあります。

すべてはあなたのシーンを構築することから始まります。

メタルレイトレーシングAPIは、いくつかの異なるタイプのジオメトリをサポートしています。

このジオメトリはすべて加速度構造に格納されています。

加速度構造は、ジオメトリを再帰的に分割することにより、レイトレーシングプロセスを高速化します。

これにより、光線と交差しないジオメトリをすばやく排除できます。

3つのステップで加速構造を設定できます。

実際のジオメトリを提供する加速度構造記述子を作成します。

記述子を取得したら、加速度構造を割り当ててから構築できます。

加速度構造記述子には、1つ以上のジオメトリ記述子が含まれています。

メタルには3種類のジオメトリ記述子があります。

三角形は、私たち全員が知っていて愛しているプリミティブであり、コンピュータグラフィックスでほとんどすべてをモデル化するために使用されます。

バウンディングボックスプリミティブは、レイが囲むバウンディングボックスに当たったときにMetalが呼び出すカスタム交差関数によって完全に定義されます。

そして今年は新しい、曲線。

これらは髪や毛皮をレンダリングするのに最適です。

三角形を使用して加速度構造を作成するには、個々のジオメトリの三角形ジオメトリ記述子を作成します。

頂点バッファ、インデックスバッファ、および三角形カウントを提供します。

バウンディングボックスのジオメトリも同様に機能しますが、頂点の代わりに、ジオメトリを囲むバウンディングボックスを提供します。

さらに、レイがバウンディングボックスプリミティブに当たったときにMetalが呼び出す交差関数を提供します。

交差機能の設定方法の詳細については、2020年の「金属でレイトレーシングを発見する」トークを参照してください。

髪、毛皮、植生などの幾何学は、数千または数百万のプリミティブを持つことができます。

これらは通常、微細で滑らかな曲線としてモデル化されています。

三角形を使用してこれらの曲線を近似する代わりに、Metalの新しい曲線プリミティブを使用できます。

これらの曲線は、カメラがズームインしても滑らかなままです。

そして、三角形と比較して、曲線はよりコンパクトなメモリフットプリントを持ち、より高速な加速構造の構築を可能にします。

フルカーブは、一連の接続されたカーブセグメントで構成されています。

曲線上のすべてのセグメントは独自のプリミティブであり、Metalは各セグメントに一意のプリミティブIDを割り当てます。

これらの各セグメントは、曲線の形状を制御する一連の制御ポイントによって定義されます。

これらの制御点は、一連の基本関数を使用して補間されます。

基底関数に応じて、各曲線セグメントは2、3、または4つのコントロールポイントを持つことができます。

Metalは、Bezier、Catmull-Rom、B-Spline、Linearの4つの異なる曲線基底関数を提供します。

これらの基本機能にはそれぞれ独自の利点がありますので、ユースケースに最適なものを選択してください。

金属には、コントロールポイントインデックスバッファも必要です。

各曲線セグメントには、セグメントの最初のコントロールポイントを表すこのバッファに1つのインデックスがあります。

たとえば、4つのコントロールポイントがあるとします。

最初のコントロールポイントのインデックスを使用して曲線セグメントを定義するので、インデックスバッファにゼロを追加します。

この例では、Catmull-Rom基底関数を使用しているため、実際の曲線セグメントはコントロールポイント1と2の間でのみ定義されます。

別のカーブセグメントを接続するために必要なのは、もう1つのコントロールポイントを追加することだけです。

この追加の曲線セグメントは、コントロールポイント1から4を使用するので、インデックスバッファに1を追加します。

これらの2つの曲線セグメントは、インデックスバッファのために3つのコントロールポイントを共有しています。これは、曲線がメモリを節約できる理由の1つです。

カーブを完成させるには、これを何度でも繰り返します。

新しい曲線を開始するには、以前のコントロールポイントと重複しない追加のコントロールポイントを追加し、対応するインデックスをインデックスバッファに追加するだけです。

これまでのところ、私が説明した曲線は抽象的な数学的オブジェクトでした。

それらをレンダリングするには、何らかの3D形状が必要です。

各制御点には、曲線の長さに沿って補間される半径もあります。

デフォルトでは、曲線は3D円筒断面でレンダリングされます。

これは、クローズアップから見える曲線に最適です。

遠くからしか見られない曲線の場合、金属は平らな曲線もサポートします。

これにより、完全な3Dジオメトリを必要としないときはいつでもパフォーマンスを向上させることができます。

三角形や境界ボックスと同様に、曲線ジオメトリは曲線ジオメトリ記述子で表されます。

コントロールポイント、対応する半径、およびコントロールポイントインデックスを含むバッファを取り付けます。

コントロールポイントバッファ内のコントロールポイントの数と、実際のカーブセグメントの数を設定します。

これは、インデックスバッファ内のインデックスの数と同じである必要があります。

使用している曲線の種類を指定します。

この例では、曲線セグメントごとに4つの制御点を持つ丸いベジェ曲線を使用しています。

カーブジオメトリ記述子を設定するために必要なのはそれだけです。

ジオメトリ記述子を作成したので、加速度構造記述子を設定できます。

三角形、境界ボックス、曲線などのプリミティブジオメトリには、プリミティブ加速度構造記述子を使用します。

加速度構造記述子にジオメトリ記述子を追加します。

複数のジオメトリ記述子を単一の加速度構造に追加して、ジオメトリを組み合わせることができます。

加速度構造記述子の準備ができたら、加速度構造にメモリを割り当てることができます。

メタルを使用すると、このメモリがいつ、どこに割り当てられるかを完全に制御できます。

これは2部構成の操作です。

まず、ビルドに必要なオブジェクトのサイズを計算します。

金属装置は、加速構造に必要な割り当てサイズを計算する方法を提供します。

金属デバイスから直接加速構造のストレージを割り当てることは可能ですが、ヒープから割り当てると、後でリソース管理のオーバーヘッドを削減できます。

ヒープには追加のサイズとアライメント要件があり、Metalデバイスで別の方法を使用してクエリできます。

これらのサイズを使用すると、加速度構造を格納するためにメモリを割り当てることができます。

このストレージは、MTL Acceleration Structureオブジェクトで表されます。

これらのオブジェクトの1つを割り当てるには、ヒープまたはメタルデバイスでmake Acceleration Structureメソッドを呼び出し、サイズを渡します。

また、加速構造を構築する際にMetalが使用するスクラッチメモリも割り当てます。

このメモリはGPUのみがアクセスする必要があるため、Metalデバイスからプライベートストレージモードバッファを割り当てることでこれを行うことができます。

これで、実際に加速構造を構築する準備が整いました。

ビルド操作をスケジュールすると、MetalがGPUでアクセラレーションを構築します。

これを行うには、加速構造コマンドエンコーダを使用します。

このエンコーダには、加速構造を構築および変更するために使用できるいくつかの方法があります。

この場合、宛先加速構造、記述子、およびスクラッチバッファを使用してビルドメソッドを呼び出します。

Metalはジオメトリの原始的な加速構造を構築し、その後のGPUコマンドで使用できるようになります。

それが、シーンのジオメトリを原始的な加速度構造で表現する方法です。

より大きなシーンにスケーリングできるように、Metalはインスタンスアクセラレーション構造もサポートしています。

モアナ島のシーンのような複雑で詳細な環境を単一の原始的な加速構造に格納するには、膨大な量のメモリが必要です。

しかし、この複雑なシーンは、何千もの木、何百万もの葉、その他のオブジェクトに反復的な構造を持ち、シーンを効率的にレンダリングするために悪用することができます。

山、サンゴ、木など、シーン内のすべてのユニークなオブジェクトは、原始的な加速構造として表現できます。

これらは、シーン全体を表すインスタンスアクセラレーション構造に組み合わせることができます。

したがって、原始的な加速度構造にはジオメトリが含まれていますが、インスタンス加速度構造には、完全なシーンを構成するために異なる位置、サイズ、および向きに変換された他の加速度構造への参照が含まれています。

各インスタンスには、シーンで参照する加速度構造を配置するための変換マトリックスがあります。

インスタンス加速構造を構築することは、原始的な加速構造を構築するのと似ています。

記述子を作成することから始めます。

今回は、ジオメトリの代わりに、参照する加速度構造や、それをシーンに配置する変換行列など、各インスタンスに関する情報を含むバッファを提供します。

次に、原始的な加速構造を構築するのと同じ方法で、GPUに加速構造を構築します。

記述子を作成するには、MTLインスタンスアクセラレーション構造記述子を構築し、含まれるインスタンスの数を設定します。

次に、インスタンスによって参照できるプリミティブアクセラレーション構造の配列を提供し、インスタンスバッファに含まれるインスタンス記述子のタイプを指定します。

Metalは、ユースケースに応じて選択できるいくつかのインスタンス記述子タイプを提供しています。

アクセラレーション構造のインスタンスを2つのステップで設定します。

まず、インスタンスごとのデータを格納するためのバッファを割り当てます。

このバッファのサイズは、インスタンスの数と各インスタンス記述子のサイズによって異なりますが、他のメタルバッファと同様に割り当てられます。

バッファを割り当てたら、インスタンスアクセラレーション構造記述子に割り当てます。

次に、アクセラレーション構造内のすべてのインスタンスに関する情報をインスタンスバッファに塗りつぶします。

インスタンスごとに、記述子を作成し、このインスタンスが参照する加速度構造を指定します。

インスタンス加速度構造記述子に設定した配列にインデックスで加速度構造を識別します。

各インスタンスには、使用しているインスタンス記述子のタイプに応じて、変換マトリックス、可視性マスク、およびその他のプロパティもあります。

最後のステップは、原始的な加速構造と同じプロセスである実際の加速構造を構築することです。

ビルドがCPUで実行できる前のすべてのステップ。

しかし、インスタンスの数が多い場合、インスタンスバッファを記入するプロセスは計算集約的になる可能性があります。

インスタンス記述子は通常のMetalバッファに格納されているため、GPUからこれらの記述子に入力することで、このステップを加速できます。

GPUに作業を渡す前に、アクセラレーション構造にいくつのインスタンスが含まれるかを知っていれば、これはGPUアクセラレーションにとって絶好の機会です。

しかし、インスタンスカリングのようなものをしたい場合は、記述子で最終的なインスタンス数を設定できるように、CPU上のインスタンスをキュールする必要があります。

今年の新機能では、新しい間接インスタンスアクセラレーション構造記述子を使用して、GPUでこのプロセスを駆動できます。

この間接記述子を使用すると、インスタンスを淘汰し、インスタンスバッファを埋め、最終的なインスタンス数をGPUに完全に設定できます。

GPU駆動のアクセラレーション構造ビルドを実行するには、間接インスタンスアクセラレーション構造記述子を作成します。

記述子の最大インスタンス数と、GPUから最終的なインスタンス数を書き込むバッファを設定します。

次に、インスタンス記述子バッファを設定するだけで、GPUでインスタンスの設定を開始する準備が整いました。

インスタンスバッファでは、異なるタイプの記述子を使用します。

間接インスタンス記述子は、直接インスタンス記述子に似ていますが、記述子に割り当てるだけでインスタンス化構造を識別できます。

それが、インスタンスアクセラレーション構造を構築する方法です。

これまでのところ、私は2レベルのインスタンス化モデルについて話しました。

このモデルでは、モアナ島のシーンの森は、さまざまな木の何千ものインスタンスで構成されています。

しかし、より深く掘り下げると、木自体は同じ葉の多くのコピーを持つ幹です。

新しいマルチレベルインスタンス機能を使用して、この構造を活用できます。

マルチレベルのインスタンス化により、インスタンス加速構造には、原始的な加速構造だけでなく、他のインスタンス加速構造も含めることができます。

たとえば、このシーンでは、ヤシの木は幹と葉のインスタンスを含むインスタンス加速構造として表現できますが、シーン全体にヤシの木のインスタンスを含めることができます。

モアナ島のシーンは、マルチレベルインスタンシングの力の素晴らしい例です。

2つのレベルのインスタンスを使用する場合、シーンに1種類のツリーを追加すると、ツリーの部分の数百または数千のコピーを追加する可能性があります。

しかし、マルチレベルのインスタンス化では、その部分の繰り返しインスタンスで定義された複雑なツリーのインスタンスを追加できます。

これにより、モアナ島のシーン全体で何百万ものインスタンスが節約されます。

しかし、マルチレベルのインスタンス化は、プロダクションレンダラーだけのものではありません。

また、ゲームのようなリアルタイムアプリにも価値があります。

ゲームはまた、2レベルの加速構造パターンを使用し、ゲームオブジェクトのインスタンスから世界を構築します。

しかし、ゲームはプロダクションレンダラーとは異なります。

プロダクションレンダラーはオブジェクトを再利用するために深い階層を使用しますが、ゲームはゲームオブジェクトのインスタンスの長いリストを使用します。

ゲームはまた、動的コンテンツの各フレームのインスタンスアクセラレーション構造を再構築し、高いインスタンス数は再構築のための多くのGPU時間を意味します。

しかし、ゲームでは、多くのコンテンツは静的であり、すべてのフレームを更新する必要はありません。

世界を静的および動的加速構造に分割して、加速構造の更新を変更したコンテンツのみに制限することができます。

これは、通常、静的コンテンツよりもはるかに少ない動的コンテンツを再構築することを意味します。

この静的コンテンツと動的コンテンツの分割を適用する場合、階層の深さとレイトラバーサルの追加コストのバランスをとることが重要です。

加速構造の建物とレイトレーシングを備えたフレームでは、3つのレベルのインスタンス化を使用すると、トレース時間にわずかな影響だけでビルド時間を短縮でき、全体的にフレーム時間を短縮できます。

マルチレベルのインスタンス化は、メモリ使用量を削減し、再構築をスピードアップするための優れたツールです。

また、メタルレイトレーシングアプリを最適化する他の方法もあります。

そのうちの1つは、並列化の構築です。

典型的なアプリケーションは、さまざまなシーンやシーンのさまざまな部分を表す多くのアクセラレーション構造を構築または更新する必要があります。

これらのビルドを並行して実行することで、起動時間を大幅に短縮できます。

可能な限り、複数のビルドを同じコマンドエンコーダにエンコードして、並行して実行できるように、ビルドをバッチ処理してください。

作業セットがメモリに収まるようにしながら、できるだけ多くのビルドを並列化したいと思うでしょう。

また、加速構造の構築が完了すると、スクラッチバッファは不要になることを忘れないでください。

これは、アクセラレーション構造ビルドの1つのバッチから次のバッチにスクラッチバッファを再利用できることを意味します。

時には、加速構造の再構築に費やす時間を短縮する最善の方法は、再構築を完全に避けることです。

ここで加速構造のリフィッティングの出番です。

Metalが加速構造を構築すると、近くのプリミティブをボックスの階層にグループ化します。

プリミティブが移動すると、これらのボックスはシーンを正確に表さなくなり、加速構造を更新する必要があります。

しかし、ジオメトリがわずかにしか変わらない場合でも、階層は合理的かもしれません。

新しい加速構造をゼロから構築する代わりに、Metalは既存の加速構造を改造して、ジオメトリのプリミティブの新しい位置を反映することができます。

これは、加速構造をゼロから再構築するよりも安いです。

Refitには、ビルド操作のようなスクラッチバッファが必要です。

リフィットスクラッチバッファのサイズは、以前に加速度構造を割り当てるために使用したのと同じ構造体にあります。

リフィット操作はGPU上で実行され、アクセラレーション構造コマンドエンコーダでエンコードされます。

修理は、その場で、または別の加速構造で動作することができます。

最後に、圧縮はメモリ内の加速度構造のサイズを小さくする素晴らしい方法です。

最初に加速構造を構築するとき、Metalは必要なメモリ量を正確に知ることができないので、保守的な見積もりを行う必要があります。

加速構造を構築したら、金属はそれを表現するために必要な最小サイズを計算できます。

圧縮を使用すると、最小サイズで新しい加速構造を割り当て、GPUを使用して現在の加速構造から新しい加速構造にコピーできます。

これは、原始的な加速構造にとって特に貴重です。

圧縮を使用するには、コマンドをエンコードして、GPU上の加速構造の圧縮されたサイズを計算します。

コマンドを実行すると、Metalはあなたが提供するバッファに圧縮されたサイズを書き込みます。

圧縮されたサイズを読んだら、そのサイズで新しい加速構造を割り当て、古いものから新しい加速構造への「コピーとコンパクト」操作をエンコードすることができます。

このコマンドバッファが完了したら、元の加速構造を解放できます。

メタルレイトレーシングアプリの最適化の詳細については、2022年の「メタルレイトレーシングパフォーマンスの最大化」セッションをご覧ください。

このセクションでは、インスタンス化を設定し、新しいマルチレベルインスタンス化機能を活用し、インスタンス化を大規模に処理する方法について説明します。

今、光線をシーンと交差させる時が来ました。

Metalでは、コマンドの一部として実行されるGPU関数で光線を交差させます。

Apple Siliconでは、計算コマンドとレンダリングコマンドの両方で光線を交差させることができ、AMDとIntelでは計算コマンドで光線を交差させることができます。

光線を交差させる準備をするには、加速構造をコマンドエンコーダにバインドします。

これで、GPU機能でこの加速構造と光線を交差させることができます。

加速度構造パラメータで関数を宣言し、セクター間オブジェクトを作成します。

このインターセクターにプロパティを設定して、最高のパフォーマンスのためにレイ交差を設定できます。

光線とシーンを交差させるには、光線を作成し、インターセクターオブジェクトの交差メソッドを呼び出すだけで、光線と加速度構造をパラメータとして渡します。

これは、交差する光線のプリミティブの種類、交差点までの距離、プリミティブのIDなど、交差点について知る必要があるすべてを返します。

三角形の交点に関する詳細情報を取得するには、インターセクタータイプと「交差結果」タイプに「三角形データ」タグを追加します。

これにより、三角形の重心座標が交差結果で利用可能になります。

それは、原始的な加速構造と交差する光線をカバーしています。

交差する光線とインスタンス加速度構造は非常によく似ています。

インスタンスアクセラレーション構造を、プリミティブアクセラレーション構造をバインドするのと同じ方法でバインドし、useResourceまたはuseHeapを呼び出すようにして、インスタンスアクセラレーション構造で参照されるアクセラレーション構造をGPUで使用できるようにします。

レイとインスタンスアクセラレーション構造と交差するには、GPU機能にいくつかの変更を加えるだけで済みます。

まず、加速度構造タイプにインスタンスタグを追加します。

次に、インスタンシングタグと「最大レベル」タグをインターセクターと「インターセクション結果」に追加します。

「最大レベル」タグは、加速構造のインスタンス化レベルの数を指定します。

例えば、モアナ島のシーンを表す加速構造は、3段階の加速構造です。

最初のレベルは、シーン全体を含むインスタンスアクセラレーション構造です。

2番目のレベルには、サンゴ、木、地形の例があります。

3番目のレベルには、葉、花、幹などの木の部分の例があります。

光線がこのシーンと交差すると、プリミティブだけでなく、プリミティブを含むインスタンスも交差します。

光線がこの木の葉と交差する場合、木のインスタンスと木の葉のインスタンスも交差します。

メタルは、交差する各インスタンスのIDを記録することで、これを追跡します。

この場合、最初の交差するインスタンスはIDが6のツリーで、2番目の交差するインスタンスはIDが1のリーフです。

光線は1つのインスタンスだけと交差することもできる。

たとえば、レイが地形と交差する場合、Metalは地形インスタンスのIDのみを記録します。

交差したインスタンスの数と交差したインスタンスのIDは、交差結果で確認できます。

それが、原始的な加速構造やインスタンス加速構造と光線を交差させる方法です。

曲線プリミティブを使用する際に留意すべき点がいくつかあります。

デフォルトでは、Metalは、レイ交差を実行するときに曲線プリミティブを使用していないことを前提としています。

インターセクターオブジェクトにジオメトリタイプを設定することで、曲線を使用していることをMetalに伝えることができます。

ジオメトリタイプを設定したら、曲線を交差させる準備が整いました。

以前と同様に、交差点結果の交差点に関する情報を見つけます。

「曲線データ」タグを使用すると、交差結果には曲線パラメータも含まれます。

これは、曲線の基底関数に差し込んで、光線と交差する曲線に沿った点を計算できる値です。

これらの機能は、メタルシェーディング言語で実装されています。

メタルシェーディング言語の仕様で詳細を学ぶことができます。

多くのアプリケーションでは、曲線ジオメトリは1種類の曲線で表されます。

たとえば、シーン内のすべての曲線は、円形の断面を持つ立方体ベジエ曲線として表現される場合があります。

この場合、セクター間オブジェクトに曲線のプロパティを設定することで、シーンが使用する曲線の種類をMetalに伝えることができます。

これにより、カーブプリミティブを使用する際に最高のパフォーマンスを得ることができます。

それがあなたのシーンと光線を交差させる方法です。

また、Xcodeを使用して、レイトレーシングワークロードをデバッグおよびプロファイルすることができます。

デバッグが難しい問題に対処する際に使用できるツールの1つは、シェーダーバリデーションです。

シェーダーでランタイムチェックを実行し、クラッシュや破損につながる可能性のある問題をキャッチします。

シェーダー検証は、最新のレイトレーシング機能を含むすべてのMetal APIをカバーするようになりました。

さらに、シェーダー検証により、シェーダーのコンパイル時間への影響が大幅に減少しました。

これは、レイトレーシングアプリケーションで一般的に見られるような、長くて複雑なシェーダーで作業しているときに非常に役立ちます。

あなたを助けることができるもう1つのツールは、最先端の加速構造ビューアです。

これにより、交差点テストに使用するシーンを検査できます。

加速構造ビューアを開くと、加速構造の個々のビルディングブロックをジオメトリプリミティブまでナビゲートするためのアウトラインが左側にあります。

ここでは、三角形のジオメトリを構成する個々の三角形をリストします。

右側にはビューポートがあり、さまざまなハイライトモードで加速構造を検査できます。

たとえば、「Axis-Aligned Bounding Box Traversals」ハイライトモードは、より高価な交差点テストに対応する、より深いレベルのトラバーサルを持つ領域を視覚化できます。

シーンの上にポインタを移動すると、インスペクターは光線が尖った方向に当たる交差点の数を更新します。

もう1つの例は、加速構造のハイライトモードです。

これは、加速構造をさまざまな色で視覚化します。

加速構造ビューアは、新しいマルチレベルインスタンシング機能と曲線ジオメトリをサポートしています。

ビューポートでカメラを動かすと、いくつかの木のインスタンス加速構造といくつかの葉の曲線を見つけることができます。

加速度構造を識別するには、ビューポートをクリックしてアウトラインに表示できます。

さて、これらのヤシの葉の加速構造を詳しく見てみましょう。

この加速構造では、ヤシの葉は曲線で構成されています。

ビューポートをプリミティブハイライトモードに変更して、カーブセグメントを視覚化できます。

カーブセグメントをよりよく検査するために、少しズームインします。

先ほどのシーンで加速構造を選択するのと同様に、ここでは、クリックして各セグメントを選択できます。

レイトレーシングワークロードを調べる際のもう1つの便利なツールは、シェーダーデバッガーです。

これは、シェーダーコードの問題のトラブルシューティングに役立ちます。

ここでは、シェーダーで交差テストを実行するコンピューティングディスパッチにいます。

シェーダーのデバッグを開始するには、シェーダーデバッグボタンを押し、ポップオーバーでスレッドを選択し、デバッグボタンをクリックします。

データの収集が完了したら、シェーダー実行中の任意の時点で各変数の値を調べることができます。

プリミティブIDの値を詳しく見てみましょう。

より多くのデバッグコンテキストを提供するために、Shader Debuggerは近隣のスレッドからのデータも提供します。

ここでは、値ビューにポインタを合わせると、同じスレッドグループのプリミティブIDを検査できます。

パフォーマンスは、あらゆるアプリのもう1つの重要な側面です。

プロファイリングタイムラインは、レイトレーシングワークロードのパフォーマンスの概要を提供し、さまざまなパフォーマンスメトリックを並べて検査して関連付けることができます。

さらに、デバッグナビゲーターを変更して、ワークロード内のすべてのパイプライン状態を表示できます。

また、シェーダープロファイリングデータを使用すると、ナビゲーターは最も高価なパイプラインの状態を上部に一覧表示します。

パイプライン状態をさらに拡張すると、シェーダーコードが明らかになります。

シェーダーを開いた後、個々のシェーダーが実行時間をどこでどのように費やすかについて、行ごとのシェーダープロファイリングの洞察を得ることができます。

サイドバーのパイチャートの上にポインタを移動すると、そのコード行のコストのより詳細な内訳を含むポップオーバーが表示されます。

これらのツールは、Metalの新しいレイトレーシング機能をすべてサポートし、Metalアプリで作業しているときに優れたデバッグとプロファイリングの補助を提供できます。

メタルレイトレーシングは、プロダクションレンダラーでシーンをアニメーション化するためのプリミティブおよびインスタンスモーション、カスタム交差機能、アルファテストなどの機能強化によるレイ交差のカスタマイズ、クエリベースのAPIからの移植性のための交差クエリなど、さらに多くの機能もサポートしています。

Metal Ray Tracing API、Language、Toolsは、ゲームやプロダクションレンダラーなどのリアルタイムレンダリングアプリをサポートしています。

最新のメタルレイトレーシングAPIを使用して、曲線のようなジオメトリを含む原始的な加速構造を使用してシーンを構築できます。

インスタンス化、特に新しいマルチレベルのインスタンス化機能により、より大きく、より複雑なシーンに拡張できます。

GPU関数は、Metal Ray Tracing APIを直接呼び出すことができます。

そして最後に、Xcodeはアプリのデバッグとプロファイリングに役立ちます。

これらのトピックの多くと、サンプルコードとドキュメントをより詳細に取り上げた以前のレイトレーシングトークを必ずチェックしてください。

見てくれてありがとう。

♪ ♪