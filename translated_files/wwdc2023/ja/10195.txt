10195

♪ ♪

Rishi: こんにちは、私の名前はRishi Vermaです。このセッションでは、SwiftDataのスキーマを構築するためにモデルをコーディングする方法について説明します。

まず、スキーママクロを最大限に活用する方法と、アプリの変更に合わせてスキーマ移行でスキーマを進化させる方法について説明します。

始める前に、このコンテンツはこれらのビデオで紹介された概念に基づいて発展するので、「SwiftDataに会う」と「SwiftDataでアプリを構築する」を見てください。

SwiftDataは、データモデリングと管理のための強力なフレームワークであり、最新のSwiftアプリを強化します。

SwiftUIと同様に、外部ファイル形式なしでコードに完全に焦点を当て、Swiftの新しいマクロシステムを使用してシームレスなAPIエクスペリエンスを作成します。

私は、ユーザーが今後の旅行を計画できるSampleTripsアプリに取り組んでいます。

各旅行は、名前、目的地、開始日と終了日で作成されます。

旅行には、バケットリストのアイテムや旅行者が滞在する場所の関係を含めることもできます。

SwiftDataの追加は、インポートを追加して@ModelでTripを飾るのと同じくらい簡単です。

それでおそれ。

@Modelマクロは、私のTripクラスをPersistentModelに適合させ、説明的なスキーマを生成します。

私のモデルを定義するコードは、今や私のアプリケーションのスキーマの真実の源です。

私の旅行モデルのデフォルトの動作は良いですが、少し微調整できると思います。

SwiftDataのスキーママクロを使用すると、永続性エクスペリエンスの動作をカスタマイズして、アプリに合わせて完璧に機能させることができます。

元のスキーマでアプリを公開したとき、各旅行名が一意であることを確認しませんでした。

これは、私が今解決する必要がある同じ名前の旅行の間にいくつかの競合を引き起こしました。

これは、@Attributeスキーママクロと一意のオプションを使用して修正できます。

SwiftDataは、永続的なバックエンドに保存した旅行が一意の名前を持つことを保証する旅行のモデルのスキーマを生成します。

その名前のトリップがすでに存在する場合、永続的なバックエンドは最新の値に更新されます。

これはアップサートと呼ばれます。

アップサートはインサートとして始まります。

インサートが既存のデータと衝突すると、更新になり、既存のデータのプロパティが更新されます。

数値、文字列、UUIDなどのプリミティブな値タイプである限り、他のプロパティにも一意の制約を適用したり、1つの関係を飾ることもできます。

私のスキーマにはもう少し作業が必要です。

最初に指定したstart_dateとend_dateからこれらの厄介なアンダースコアを削除したい。

変数の名前を変更すると、これは生成されたスキーマの新しいプロパティと見なされます。

SwiftDataにこれらの新しいプロパティを作成してほしくない。

代わりに、既存のデータをそのまま保存したい。

@Attributeを使用して元の名前をプロパティ名にマッピングし、originalName:パラメータを指定するだけで、これを行うことができます。

これらを元の名前からマッピングすることで、データの損失を回避できます。

これはまた、私のスキーマの更新がSampleTripsアプリの次のリリースのための簡単な移行になることを保証します。

また、@Attributeマクロは、大規模なデータを外部に保存し、変換可能なサポートを提供するなど、さらに多くのことを行うことができます。

私の旅行はうまくいっていますが、今は人間関係に取り組みたいです。

私の旅行に新しいバケットリストアイテムや住居を追加すると、SwiftDataは暗黙のうちに私のモデル間の逆を発見し、私のためにそれらを設定します。

暗黙の逆は注釈を必要としません。

彼らはただ働くだけです。

暗黙の逆は、旅行が削除されたときにバケットリストアイテムと居住宿泊施設のプロパティを無効にするデフォルトの削除ルールを使用します。

しかし、バケットリストのアイテムと住居を旅行と一緒に削除したいです。

カスケード削除ルールで@Relationshipマクロを追加することで、簡単にそれを行うことができます。

今、私が旅行を削除すると、それらの関係も削除されます。

そして、@Relationshipマクロは、originalName修飾子や、to-many関係の最小カウントと最大カウントを指定する機能など、はるかに多くのことを行います。

SampleTripsアプリはうまく形成されていますが、まだアップデートがあります。

さて、旅行を何回見たかを追跡する方法を追加したいと思います。

このようにして、私は休暇を取ることにどれだけ興奮しているかを測ることができます。

待ちきれない！

ただし、このビューカウントがSwiftDataによって保持されることを望んでおらず、@Transientマクロで簡単に行うことができます。

私は単に@Transientで私のプロパティを飾るだけで、この特定のプロパティは持続しません。

それはとても簡単です。

@Transientマクロは、不要なデータの永続化を避けるのに役立ちます。

一時的なプロパティのデフォルト値を必ず指定してください。

これにより、SwiftDataからフェッチされたときに論理値を持つことが保証されます。

これらのスキーママクロの活用の詳細については、SwiftDataのドキュメントをご覧ください。

SampleTripsアプリのスキーマは、永続性の経験を調整しながら、いくつかの進化を遂げました。

私のアプリがリリースからリリースまでこれらのアップデートを処理できることを確認する必要があります。

また、プロパティの追加や削除など、スキーマに変更を加えると、データの移行が発生します。

これらの移行は難しいシナリオになる可能性がありますが、SwiftDataはそれを簡単にします。

VersionedSchemaとSchemaMigrationPlanは、それを支援するためにここにいます。

SwiftDataモデルを変更してアプリの新しいバージョンをリリースする準備をするときはいつでも、以前にリリースされたスキーマをカプセル化するVersionedSchemaを定義してください。

スキーマの各異なるバージョンは、SwiftDataがそれらの間でどのような変更が発生したかを知ることができるように、VersionedSchemaとして定義する必要があります。

次に、VersionedSchemasの合計順序を使用して、SchemaMigrationPlanを作成します。

これにより、SwiftDataは必要な移行を順番に実行できます。

移行計画で注文したスキーマを設定したら、各移行段階の定義を開始できます。

利用可能な移行段階には2つの異なるタイプがあります。

1つ目は軽量の移行段階です。

軽量移行は、次のアプリリリースのために既存のデータを移行するために追加のコードを必要としません。

日付プロパティにoriginalNameを追加したり、関係に削除ルールを指定したりするなどの変更は、軽量移行の対象となります。

ただし、旅行の名前をユニークにすることは、軽量な移行の対象にはなりません。

名前がユニークになる前に、旅行の重複排除が可能なこの変更のためのカスタム移行ステージを作成する必要があります。

私は最初のリリースから元のスキーマを取り、それをVersionedSchemaにカプセル化することから始めます。

私はこのバージョンのスキーマSampleTripsSchemaV1と名付けます。

私のバージョン管理されたスキーマのそれぞれは、それらが定義するモデルクラスをリストします。

私のスキーマのバージョン2は、旅行名に一意性制約を追加した場所です。

Tripモデルクラスに加えた変更もカプセル化する別のバージョン制スキーマを作成します。

スキーマのバージョン3でも同じことをして、開始日と終了日に行われた名前の変更をキャプチャします。

VersionedSchemasがすべてわかったので、リリースからリリースへの移行を処理する方法を説明するSchemaMigrationPlanを構築します。

それはかなり単純です。

アプリケーションのスキーマの総順序を提供するだけです。

次に、どの移行が軽量またはカスタムであるかに注釈を付ける必要があります。

V1からV2の場合、データを移行する前に操作を実行できるカスタムステージが必要です。

willMigrateの閉鎖では、移行が起こる前に旅行の重複を解除することができます。

SwiftDataは、V1からV2への移行がいつ行われるかを検出し、このクロージャを実行します。

originalNameの他の移行は軽量なので、その段階も追加できます。

移行計画に関するすべての詳細を定義したので、移行を実行する時が来ました。

現在のスキーマと移行計画でModelContainerをセットアップし、完了です。

私のユーザーは任意のバージョンから最新のリリースにアップグレードすることができ、データが確実に保存されるようにしました。

SampleTripsアプリを使って今後の休暇を計画するのが待ちきれません。

スキーママクロを活用してスキーマの追加メタデータを伝え、アプリケーションが進化するにつれて、それらの進化をVersionedSchemaでキャプチャして、アプリが以前のリリースから移行できるようにします。

これらの他の講演をチェックして、皆さんがSwiftDataで作る素晴らしいものを見るのを楽しみにしています。

光栄でした。