10268

♪ ♪

Cyndy: こんにちは、私はCyndyで、Languages and Runtimesチームのコンパイラエンジニアです。

このセッションでは、マージ可能なライブラリについて会います。

これは、静的リンカーを搭載したライブラリを構築して配布するための新しいモデルです。

アプリの構築と実行を高速化するために、マージ可能なライブラリがどのように機能するかを共有します。

次に、Xcode 15でマージ可能なライブラリを有効にする方法を実演します。

そして最後に、マージ可能なライブラリを使用する際の考慮事項と推奨するものについて説明します。

飛び込む前に、静的ライブラリと動的ライブラリの概要を簡単に説明します。

これは、マージ可能なものの利点を強調します。

静的ライブラリはオブジェクトファイルのコレクションです。

ビルド時に、静的リンカーはそれらのライブラリから使用するAPIを見つけ、そのコードをアプリバイナリにコピーします。

そして、それはコピーされているので、図書館は構築後は必要ありません。

静的ライブラリのコードが変更された場合、またはより多くのライブラリが使用された場合、ビルド時間の減速が発生します。

これは、それらがどのようにアーカイブされ、アプリにリンクされているかの結果であり、反復的な構築とデバッグが遅くなります。

代わりに、動的ライブラリを使用してこれを防ぐことができます。

動的ライブラリは一般にディリブと呼ばれます。

これらは、Xcodeのフレームワークターゲットのバイナリファイルタイプです。

フレームワークのコードは実行可能ファイルにコピーされません。

むしろ、静的リンカーは、後でのためにライブラリのインストールされたパスをアプリバイナリに記録します。

Apple SDKにないフレームワークは、アプリバンドルに埋め込む必要があります。

主な違いは、動的ライブラリが追加または更新されると、静的リンカがコードをコピーする必要がないことです。

これにより、ビルドが高速化されます。

しかし、それは実行時にアプリが使用されるときに複雑さを増します。

これは、動的リンカーが必要な場所です。

アプリが起動されると、dyldという名前の動的リンカーはフレームワークの依存関係を見つけてロードする必要があります。

これには、それらのフレームワークが依存するライブラリが含まれます。

より多く使用されるにつれて、これによりメモリ消費とアプリの起動時間が着実に増加します。

また、Apple SDKからの依存関係を考慮すると、アプリはしばしば何百ものフレームワークをロードすることができます。

当社のプラットフォームは、これを考慮するために大幅に最適化されたシステムライブラリを持っています。

しかし、これはアプリに組み込まれるフレームワークには適用されません。

要約すると、静的ライブラリと動的ライブラリの使用を決定する際には、いくつかのトレードオフがあります。

動的ライブラリはビルド時間にほとんど影響を与えませんが、起動時間の影響は顕著ですが、静的ライブラリは起動時間の影響を最小限に抑えますが、ビルド時間にコストがかかります。

このため、私たちは歴史的にあなたのアプリに最適なものを測定することを推奨してきました。

マージ可能なライブラリでは、これはもはや必要ありません。

マージ可能なライブラリは、両方のリンク戦略を最大限に活用します。

マージ可能なライブラリがパフォーマンスと開発のためにどのように最適化できるかを説明します。

実行可能ファイルのようなバイナリイメージを考えてみましょう。

このバイナリが依存するフレームワークは、静的リンカーに与えられます。

これらの依存関係はマージ可能なライブラリになる可能性があります。

そして、リンクされた出力はマージされたバイナリになることができます。

しかし、これらの依存関係をマージ可能にする理由は何ですか?

これは、それらがどのように構築されているかによって説明できます。

任意の動的ライブラリはマージ可能として構築できます。

静的リンカーがライブラリを作成すると、メタデータも生成されます。

メタデータはバイナリ内にあり、全体のサイズが大きくなります。

リンク依存関係として使用される場合、リンカーはライブラリを静的ライブラリと同様に扱うことができます。

メタデータを使用すると、ライブラリのユーザーは、通常の動的ライブラリとして静的にリンクするか、マージするかを選択できます。

マージされたバイナリ出力は、アプリのような実行可能ファイル、またはフレームワークのような別の動的ライブラリにすることができます。

マージは、静的ライブラリがどのようにリンクされるかに匹敵します。

最終的には、ライブラリのセグメントを含むバイナリが残ります。

そして、その出力バイナリは同じファイルタイプのままです。

マージはXcode 15で真新しいものです。

新しく実装された静的リンカーは、これを可能にするものです。

これは、新しいリンカーオプションを使用して機能します。

まず、マージするライブラリはオプション-make_mergeableで構築されます。

これは、メタデータを記録するようにリンカーに指示します。

次に、マージされたバイナリの場合、リンカーはそのメタデータとライブラリを使用して、オプション-merge_libraryまたは-merge_frameworkで最終出力を生成します。

Xcodeはこれらの詳細を処理します。

ただし、ビルドログを検査すると、これらのオプションが適用されていることがわかります。

しかし、単なるリンクよりもマージの方が良いのはどうですか?

さて、マージ後のサイズを考えてみましょう。

まず、ライブラリとそのメタデータは不要で、マージ後に削除できます。

したがって、唯一の焦点は、マージされたバイナリのサイズです。

マージすると、リンカはすべてのライブラリで文字列などのコンテンツの重複排除を解除できます。

たとえば、冗長なシンボル参照、Objective-Cセレクタ、およびobjc_msgsendスタブを削除します。

これにより、全体的なアプリバンドルが小さくなります。

最終的なバイナリの画像タイプも同じままです。

これは、すでにサポートされているリンカーの最適化を適用できることを意味します。

これはアプリの立ち上げにも良い影響を与えます。

ロードされるフレームワークが少なくなると、アプリを起動するときに必要な作業とカーネルが削減され、メモリ使用量が削減され、ユーザーを満足させます。

しかし、コードをライブラリに分離することは、効果的な開発とメンテナンスに不可欠であることを知っています。

マージ可能なライブラリを使用すると、両方を持つことができます。

マージ可能なライブラリは、最小限のコードと構成の変更でこれを可能にします。

そして、これは新しいフレームワークを採用するにつれてうまく拡張されます。

動的リンクに関する以前の図を再検討しましょう。

リンカーがメタデータを生成できるため、これらの組み込みフレームワークはすべてマージ可能になる可能性があります。

他のライブラリの内容をマージするフレームワークを作成できます。

したがって、埋め込むフレームワークは1つだけです。

Dyldは、埋め込まれたフレームワーク全体のすべてのセグメントを含む1つのライブラリをロードするだけです。

このようにして、マージすると、大規模な依存関係チェーンを大幅に簡素化できます。

それがマージ可能なライブラリが達成できることです。

それらを有効にする方法について話しましょう。

Xcodeでライブラリのマージを有効にするには2つの方法があります。

最も単純な自動マージから始めます。

次に、マージ可能なものを管理したいときはいつでも、手動マージに入ります。

デバッグモードでは、マージ可能なライブラリがどのように最適なビルド時間を提供できるかを説明します。

そしてその後、マージ可能なライブラリにデバッグしてシンボリック化する必要があるときに何を期待するかを共有します。

自動マージは、組み込みフレームワークターゲットであるすべての直接依存関係をマージするようにビルドシステムに通知します。

アプリのターゲットで特に便利です。

見せてあげるよ。

例として、SwiftとC++ Forestプロジェクトを使っています。

4つのフレームワークにリンクするアプリターゲットがあります。

Apple SDKから来ているSwiftUIがあります。

他の3つ、ForestBuilder、ForestUI、Forestは、プロジェクトに組み込まれています。

自動マージを有効にすると、3つのフォレストフレームワークがマージ可能になります。

SwiftUIはシステムライブラリなので、そのまま残っています。

アプリをリンクしている間、これらのフレームワークはアプリのバイナリに直接マージされます。

つまり、これらのフレームワークは起動時に必要とされず、ディスクから削除できます。

Xcodeでこれをオンにする方法を見てみましょう。

プロジェクト内では、すでにSwiftとC++アプリのターゲットをクリックし、ビルド設定タブに入っています。

MERGED_BINARY_TYPEのビルド設定を更新する必要があります。

フィルターテキストボックスを使って検索できます。

「Create Merged Binary」は、まさに私が更新したいものです。

これは、設定 MERGED_BINARY_TYPE にマッピングされるオプションです。

設定をクリックして、その値を自動に更新します。

そして、それだけです!

マージ可能なライブラリの設定は、一般的なリンクオプションの下にあります。

それらは「Linking - Mergeable Libraries」という名前の独自のセクションに便利に表示されます。

アプリがライブラリのマージを有効にすると、ライブラリのセグメントはアプリのバイナリに直接リンクされます。

これにより、静的ライブラリと同様のパフォーマンスが得られます。

しかし、マージ可能なライブラリのエクスポートはアプリに保存されます。

アプリがシンボルをエクスポートすることは適用されないことが多く、サイズとビルド時間に悪影響を及ぼします。

これを防ぐには、リンカーオプション-no_exported_symbolsを使用します。

これは、他のリンカーフラグを「-Wl、-no_exported_symbols」で更新することで、Xcodeで適用できます。

アプリにアプリ拡張機能のエントリポイントが必要な場合は、これらのシンボルを一覧表示するエクスポートリストを使用して、これを厳密に制御します。

これは、エクスポートされたシンボルファイルを使用して、同じ一般的なリンクオプションで設定できます。

これにより、静的リンカーは、デッドコードストリッピングなどのサイズの最適化に最も効果的です。

それは自動マージでしたが、フレームワークの一部のみをマージする必要がある場合があります。

Xcodeは手動マージでこれをサポートしています。

手動マージは、マージするライブラリを指定するためのきめ細かなアプローチです。

これは、いくつかの依存関係がアプリバンドルにとどまる必要がある場合に便利です。

検討事項について議論するときは、後で詳しく説明します。

包括的なターゲットにMERGED_BINARY_TYPE =手動を設定することで有効になります。

最終的にマージされた製品を構成するライブラリは、MERGEABLE_LIBRARYをYESに設定することで認識されます。

また、ディスクにとどまるべきライブラリについては、MERGEABLE_LIBRARYのデフォルト設定をNOにしてください。

SwiftとC++のフォレストプロジェクトに戻ってデモをしましょう。

自動マージに関連する変更なしに、新しく始めています。

アプリのターゲットと、それがリンクしている4つのフレームワークがまだあります。

しかし今、私はテストも検討しています。

プロジェクトにはXCTestターゲットとサポートフレームワークがあります。

テストはフォレストフレームワークにも依存します。

プロジェクトのフレームワーク間では、依存関係はすべて絡み合っています。

この例では、XCTestターゲットがありますが、プロジェクトでは、同様の外観の依存関係グラフを作成するアプリ拡張機能などのターゲットがあるかもしれません。

マージ可能なライブラリを活用するために、3つのフォレストフレームワークのアプリの依存関係を分離します。

アプリに必要なライブラリをマージするフレームワーク、ForestKitを作成しますが、テストの依存性も満たします。

ForestKitは、私のアプリとテストの両方が依存するマージ可能なライブラリをカプセル化するため、グループライブラリと見なされます。

手動モードを有効にすると、マージ可能にするフレームワークを明示的に設定します。

この場合、それはForestBuilder、ForestUI、Forestです。

これらの依存関係はForestKitにマージされます。

ライブラリの読み込みを減らすことで、私のアプリは起動時間とバンドルサイズを改善しました。

Xcodeでこれをオンにしましょう。

プロジェクトを再起動し、自動マージに使用される設定を削除しました。

他のフレームワークをマージするフレームワークターゲットを作成することから始めます。

これは私のグループライブラリ、ForestKitです。

ターゲットセクションの下部をクリックしてこれを行うことができます。

テンプレートポップアップのmacOSタブにいて、フィルターテキストボックスを使用してフレームワークテンプレートを見つけます。

製品名をForestKitに設定し、[完了]をクリックします。

このフレームワークでは、フォレストテストサポートフレームワークを除くすべてのライブラリをマージしたい。

しかし、私の依存関係は絡み合っているので、当分の間、それらすべてに対してリンクします。

これを行うには、「Link Binary with Libraries」ビルドフェーズを更新して、プラス記号を使用してフレームワークを追加します。

ライブラリのポップアップが表示されたら、Forestフレームワークをクリックし、SHIFTとDOWNキーを押したままにして、Xcodeプロジェクトの他のフレームワークを強調表示します。

次に、このターゲットで手動マージを有効にする必要があります。

これを行うには、[ビルド設定]タブに移動し、もう一度「Create Merged Binary」を探します。

フィルターテキストボックスを使用して「マージ」と入力します。

今回は、値として「マニュアル」を選択します。

それは私がグループライブラリのターゲットに設定する必要があるすべてです。

各フレームワークターゲットのビルド設定に移動して、マージするライブラリを選択できます。

ターゲットセクションをナビゲートして、フォレストフレームワークから始めます。

[ビルド設定] タブで、[マージ可能なライブラリのビルド] をクリックできます。

このオプションはビルド設定 MERGEABLE_LIBRARY にマッピングされ、この値を「はい」に更新します。

ForestUIとForest Builderにも同じことをする必要があります。

マージされたForestKitフレームワークの作成が完了しました。

しかし、私はいくつかの依存関係を更新する必要があります。

ほとんどの動的ライブラリをカプセル化するフレームワークを作成したので、アプリとテストが他のライブラリではなくForestKitにリンクしていることを確認する必要があります。

SwiftとC++アプリのターゲットをクリックして、まずアプリを修正します。

ビルドフェーズタブに戻り、「バイナリをライブラリにリンクする」に戻ります。

ここで不要なフレームワークを削除します。

Forestを選択し、SHIFTとUPを保持してForestUIとForestBuilderを収集して削除します。

最後のステップはテストです。

XCTestターゲットをクリックし、「バイナリをライブラリとリンクする」の下のビルドフェーズタブに移動します。

テーブルの名前をクリックして削除して、Forestフレームワークを削除します。

次に、プラス記号を使用してForestKitを追加します。

ポップアップが表示されたら、ForestKitをダブルクリックします。

そして、これは手動マージを設定する方法です。

SwiftとC++フォレストプロジェクトでは、リリースモードで作業しています。

これは、ライブラリがマージされ、ディスクから削除されるときです。

ただし、静的ライブラリのビルド時間の動作と同様に、マージにはビルド時間のオーバーヘッドがあり、開発にコストがかかる可能性があります。

Xcodeでの反復開発をサポートするために、リンカーはデバッグモードでマージされません。

ビルドシステムは、代わりにライブラリを再エクスポートするようにリンカーに指示します。

再エクスポートは、コードの実装を1つの動的ライブラリに実装できるが、別の動的ライブラリに実装されているかのように表示するリンカーオプションです。

言い換えれば、これは、アプリの拡張機能やテストなど、マージされたターゲットに依存するだけで、すべてのライブラリのAPIに到達できることを意味します。

これにより、動的ライブラリと同様のビルド時間の利点が得られます。

起動時に、dyldは、マージされたバイナリから直接来ることを期待するのではなく、再エクスポートされたライブラリへの参照をリダイレクトします。

つまり、デバッグの場合、マージ可能なライブラリはディスクにとどまります。

デバッグといえば、マージ可能なライブラリにある可能性のあるシンボルを見てみましょう。

私は整数を取り込み、その2乗結果を返す関数を持っています。

これはビルドされるコードです。

しかし、これはマシンが実行するコードではないことを知っています。

代わりに、このコードは多くの変換を経ます。

そのコードでバグを調べる必要があるまで、これはすべて問題ありません。

これが、Xcodeがシンボリック化をサポートする理由です。

シンボリック化は、これらの機械命令を元のソースコードに関連付けるプロセスです。

これは、クラッシュログを理解したり、コードをプロファイリングしてデバッグしたりするのに便利です。

これはマージされたバイナリでどのように機能しますか?

マージを有効にしても、ソース位置情報は元のライブラリから保持されます。

つまり、デバッグの経験は同じままです。

ただし、スタックトレースのようにライブラリ情報が表示されると、マージされたバイナリへのパスが表示されることを覚えておいてください。

この情報は、クラッシュログ、Instruments内、およびデバッガに表示されます。

独自のプロジェクトがマージ可能なライブラリをどのように採用できるかを考慮する時が来ました。

多くの場合、それらを有効にするには、いくつかのXcode設定が必要です。

しかし、注目に値するいくつかの要因があります。

考えるべき重要な5つのトピックを取り上げます。

まず、マージ可能なライブラリに関する既存の依存関係をどのように処理すべきかから始めます。

次に、自動リンクとは何か、それがマージ可能なライブラリでどのように機能するかについて説明します。

また、dlopenやバンドルインターフェイスなどのランタイムルックアップAPIを使用する場合は、いくつかの制限があります。

マージはXcode 15の静的リンカーによって駆動されるため、それと前任者との重要な違いについて言及します。

そして、最後の考慮事項は、フレームワークを他の開発者に出荷することに興味がある人々のためのものです。

ライブラリの依存関係については、ディルドの仕事を示す図に戻りましょう。

マージ可能なライブラリの依存関係（たとえば、他の実行可能ファイルなど）がある場合は、マージ可能なライブラリがディスクから削除されるため、マージされたフレームワークに依存するように更新する必要があります。

これが出てくるもう1つの方法は、アプリが自動リンクに依存している場合です。

自動リンクは、デフォルトでオンになっているコンパイラオプションです。

コンパイラがソースコードでモジュールのインポートを見つけると、フレームワークの依存関係を検出してリンカーに渡します。

したがって、マージ可能なライブラリからモジュールをインポートする場合、動的リンクの問題が発生する可能性があります。

ただし、自動リンクを無効にする必要はありません。

ここでの解決策は以前と同じです。マージされたフレームワークに対するリンクです。

これを行う最も一般的な方法は、「ライブラリとバイナリをリンクする」ビルドフェーズにマージされたフレームワークを追加し、すでにある場合はマージ可能なフレームワークを削除することです。

そうしないと、dyldはアプリに適したフレームワークを読み込むことができません。

ほとんどの開発者は、dlopenのような動的リンクAPIを使用する必要はありません。

しかし、その場合、これらの入力パスもマージされたフレームワークターゲットを指す必要があります。

同様に、リソースの検索はライブラリのマージによって影響を受ける可能性があります。

これは、ランタイムが期待していることのためです。

Swiftでは、bundleはランタイムがフレームワークのバンドルをロードするためのAPIです。

Objective-Cの同等のAPIは、NSBundleのbundleForClassです。

これらのAPIは、バンドルの構造を考慮することなく、フレームワークのリソースを操作するために使用されます。

iOS 12までは、ランタイムはバンドルを発見するためにフレームワークのバイナリが必要でしたが、マージ可能なフレームワークには、プロセスが実行されるまでにバイナリはありません。

朗報！

iOS 12では、このシナリオのルックアップを可能にするフックが追加されました。

つまり、バンドルルックアップサポートに依存している場合は、マージ可能なライブラリを使用するには、最小展開バージョンをiOS 12以降に更新する必要があります。

しかし、これらのAPIに依存しない場合は、新しいリンカーオプション-no_merged_libraries_hookでこのサポートを無効にすることができます。

そうすれば、アプリのデプロイバージョンを更新する必要はありません。

バンドルリソースを含まないフレームワークをマージする場合は、バンドルフックも必要ないかもしれません。

その場合は、起動時間のパフォーマンスを向上させるために、とにかくこのオプションを追加することを検討する必要があります。

この講演を通して、私はいくつかの新しいリンカーオプションについて言及しました。

これらのオプションは、新しく実装されたリンカーでのみ機能します。

しかし、ツールチェーンの中を覗くと、2つの静的リンカーがあることに気付くでしょう。

古いリンカーは、下位互換性のためにまだサポートされています。

最も注目すべきは、そのリンカはまだarmv7k用に構築できますが、新しいリンカはそうではありません。

armv7kアーキテクチャをサポートする最後のプラットフォームはwatchOS 8でした。

watchOS 8以前に展開する必要がない場合は、展開バージョンをwatchOS 9にアップグレードして、新しいリンカーを使用してください。

アプリでマージ可能なライブラリを構築して使用する方法を説明しましたが、他の人が使用できるようにマージ可能なライブラリを出荷したい場合はどうなりますか?

これを行うには、Swift Package ManagerまたはXcodeでXCFrameworkを作成できます。

これにより、配布用のメタデータを含むフレームワークを構築できます。

他の開発者がフレームワークを使用する場合、マージを有効にするかどうかを決定できます。

マージ可能なメタデータは、dylibのサイズの約2倍になります。

アプリを構築した後、メタデータはマージ可能なライブラリとともに破棄されるため、これはアプリのサイズには影響しません。

そうでなければ、そのメタデータはアプリに埋め込むときに肥大化を防ぐために削除されます。

マージ可能なライブラリにいくつかのニュアンスを説明しました。

今、私たちの推奨事項を共有します。

マージされたバイナリへの依存関係を設定することは、シームレスに採用するための鍵です。

これは、リンクの依存関係に必要です。

スクリプトフェーズでバイナリを期待するツールにライブラリをフィードする場合は特に重要です。

静的リンカーは、直接的な依存関係のみをマージします。

したがって、より多くのマージ可能なライブラリを含めるには、明示的なリンク依存関係として設定する必要があります。

マージの設定は、フレームワークのバイナリをディスクから削除するようにXcodeビルドシステムに指示します。

これは意図的でない場合は副作用を引き起こすので、Xcodeのターゲットレベルで有効にすることをお勧めします。

そして最後に、パフォーマンスを最適化しながら生産性の最大の利益を得るには、動的にマージ可能な静的ライブラリの更新を検討してください。

マージ可能なライブラリは、利便性と柔軟性を提供します。

自動ワークフローと手動ワークフローの間で、余暇にマージ可能なライブラリを再構築して追加し、必要なライブラリをディスクに残すことができます。

この柔軟性は、徐々に採用またはプロファイリングする場合に役立ちます。

マージ可能なライブラリは、フレームワークと実行可能ターゲットに適用すると、サイズ、ビルド、およびランタイムの改善を提供します。

自動設定を使用して、ビルドシステムにすべての直接フレームワークの依存関係をマージさせることができます。

しかし、マージする依存関係を選択して選択する必要がある場合、これは手動モードで行うことができます。

そして最後に、マージ可能なライブラリを使用するようにプロジェクトを更新するときは、それらのライブラリのすべての依存者が、削除されるライブラリではなく、マージされたバイナリに依存していることを確認してください。

マージ可能なライブラリに関するドキュメントについては、「マージ可能なライブラリを使用するようにプロジェクトを設定する」を参照してください。

また、静的および動的リンクの詳細については、セッション「高速リンク：ビルドと起動時間の改善」をチェックしてください。

マージ可能なライブラリがプロジェクトでどのように使用されるかを学ぶことに興奮しています。

参加してくれてありがとう。 