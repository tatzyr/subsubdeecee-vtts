10168

♪ ♪

ソフィア：こんにちは、「パラメータパックでAPIを一般化する」へようこそ。

私の名前はソフィアで、Swiftコンパイラチームで働いています。

今日は、Swiftパラメータパックと、それらが一般的なプログラミングで新しい次元の柔軟性を提供する方法についてお話しします。

これは高度な話であり、既存のジェネリックシステムに基づいています。

このトピックに慣れていない場合は、WWDC22の「Embrace Swift generics」を見ることをお勧めします。

今日は、パラメータパックが解決できる問題の種類、ライブラリでパラメータパックに遭遇したときにパラメータパックについて考える方法、そして最後に、パラメータパックを利用する独自のコードを実装する方法について説明します。

パラメータパックに飛び込む前に、それらが存在する理由を知ることが重要です。

だから私はジェネリックとvariadicsについて少し話すことから始めます。

あなたが書くコードは、基本的に値と型の2つのカテゴリで構成されています。

異なる値をパラメータとして受け入れる関数を書くことで、値を抽象化できます。

例としては、入力として度を表す任意のダブル値を受け入れ、出力のためにラジアンを表す新しいダブル値を返すラジアン(from:)関数があります。

パラメータにさまざまなタイプを受け入れるジェネリックコードを書くことで、オーバータイプを抽象化できます。

たとえば、標準ライブラリアレイタイプは、それを埋めたい任意の形式のデータを保持するように設計されています。

これには、配列の特定のインスタンスに使用する具体的な型のプレースホルダである要素型パラメータがあります。

どちらの場合も、具体的な値または具体的なタイプが抽象化の引数として渡されます。

ほとんどの汎用コードは、型と値の両方を抽象化します。

これを調べるために、サーバーにクエリを送信するためのコードを書くつもりです。

その基本的な実装は、いくつかのペイロードタイプの要求を受け取り、それをクエリとしてサーバーに渡し、最後にペイロードタイプのサーバー応答を返します。

この関数には1つのパラメータがありますが、同じ呼び出しで複数のリクエストを照会することをサポートしたいです。

可変数の引数を持つ能力のために、可変パラメータがあります。

可変パラメータにより、関数は単一のタイプの任意の数の引数を柔軟に受け入れることができます。

しかし、可変パラメータには限界があります。

たとえば、指定された引数を、長さが引数の数と同じタプルにマッピングしたい場合があります。

ただし、可変パラメータでは、引数の長さに基づく戻り値の型を宣言する方法はありません。

また、可変パラメータが型消去を使用せずにさまざまな型を受け入れる方法がないため、各引数の特定の静的型情報を保持する方法はありません。

ジェネリックシステムと可変パラメータに欠けているのは、型情報を維持し、引数の数を変える能力です。

今日、これを行う唯一の方法はオーバーロードであり、サポートする引数の上限を選択することを余儀なくされます。

2つのパラメータで十分でしょうか？おそらくそうではありません。

最大3つのパラメータを処理する方が良いです。

しかし、私たちが4つ欲しい場合はどうなりますか?

このオーバーロードパターンとその制限は、さまざまな数の型パラメータを概念的に処理するAPI全体に浸透しています。

このアプローチには冗長性の欠点がありますが、さらに重要なのは、サポートされる引数の数に任意の上限を強制的に選択することです。

選択した制限を超えると、追加の引数に関するコンパイラエラーが発生します。

これは、パラメータパックが解決する種類の問題です。

この過負荷パターンに陥っていることに気付いた場合、それはパラメータパックを使用したいという強い兆候です。

Swift 5.9では、ジェネリックシステムは「パラメータパック」と呼ばれる新しい構造で、引数の長さに対する抽象化のファーストクラスのサポートを獲得しています。

今から、APIでパラメータパックを見ると、パラメータパックが何を意味するのかについて話します。

コードでは、ほとんどの場合、単一のタイプまたは値で作業します。

パラメータパックは、任意の量の型または値を保持し、それらを一緒にパックして関数の引数として渡すことができます。

個々のタイプを保持するパックは、タイプパックと呼ばれます。

たとえば、Bool、Int、Stringの3つの個別のタイプを保持するタイプパックを持つことができます。

個々の値を保持するパックは、バリューパックと呼ばれます。

たとえば、true、数値10、空の文字列の3つの個々の値を保持する値パックを持つことができます。

タイプパックとバリューパックは一緒に使用されます。

タイプパックは、バリューパック内の個々の値ごとに個々のタイプを提供します。

対応するタイプと値は、それぞれのパックで同じ位置にあります。

位置0で、値trueの型はBoolです。

位置1では、整数リテラル10のタイプはIntです。

そして、位置2では、空の文字列リテラルのタイプは文字列です。

パラメータパックを使用すると、パック内のすべての個々の要素で動作する一般的なコードを1つ書くことができます。

Swiftでコレクションを使用するときに、異なる個々の要素で動作する1つのコードを書くことに慣れているので、この概念は身近に聞こえるかもしれません。

そのようなコードを書く方法は、反復を通してです。

たとえば、for-inループの本体は、配列の個々の要素を操作します。

パラメータパックがコレクションと異なるのは、パック内の各要素が異なる静的型を持ち、型レベルでパックを操作できることです。

通常、角括弧内に型パラメータを宣言することで、異なる具体的なタイプで動作する汎用コードを記述します。

Swift 5.9では、キーワード「each」で型パラメータのパックを宣言できます。

単一の型パラメータを持つ代わりに、関数はクエリする各ペイロード型を受け入れます。

これはタイプパラメータパックと呼ばれます。

タイプパックとバリューパックの名前を自然に読み取るには、「各ペイロード」ではなく「各ペイロード」などの単一の命名規則を使用します。

パラメータパックを使用する汎用コードは、繰り返しパターンを使用して各ペイロードを個別に操作できます。

繰り返しパターンは「繰り返し」キーワードを使用して表現され、その後にパターンタイプと呼ばれるタイプが続きます。

パターンには、パック要素への1つ以上の参照が含まれます。

「繰り返し」は、指定された引数パック内のすべての要素に対してパターンタイプが繰り返されることを示します。

「それぞれ」は、すべての反復で個々のパック要素に置き換えられるプレースホルダとして機能します。

この交換が、Bool、Int、Stringを含む具体的なタイプのパックでどのように機能するかを見てみましょう。

パターンは3回繰り返され、プレースホルダ「各ペイロード」は各繰り返しの間にパック内の具体的なタイプに置き換えられます。

結果は、タイプのカンマ区切りリストです: Boolの要求、Intの要求、および文字列の要求。

繰り返しパターンは、カンマで区切られたタイプのリストを生成するため、自然にカンマで区切られたリストを受け入れる位置でのみ使用できます。

これには、タプル型または単一型のいずれかである括弧で囲まれた型が含まれます。

さらに、それらは関数パラメータリストで使用でき、繰り返しパターンは一般的な引数リストで使用できます。

繰り返しパターンを関数パラメータのタイプとして使用すると、その関数パラメータが値パラメータパックに変換されます。

これにより、呼び出し元の任意の数のリクエストインスタンスを渡すことができ、引数値はパックに収集され、関数に渡されます。

これは、パラメータパックの基本的な概念と使用される構文をカバーしています。

次に、APIの機能を簡素化および拡張する方法を実証するために、クエリAPIに戻りましょう。

可変要求引数と対応する戻り値タイプを提供するために、複数の汎用オーバーロードを追加しました。

各過負荷の宣言は、予測可能なパターンに従います。

各オーバーロードには、それぞれ1、2、3、および4つのタイプのパラメータがあります。

各オーバーロードは、各タイプのパラメータをパラメータリストのそのタイプのリクエストにマップします。

そして、各オーバーロードには、戻り値タイプの各型パラメータのリストが含まれています。

パラメータパックを使用すると、これらの4つのオーバーロードを1つの関数に折りたたむことができます。

まず、型パラメータ宣言、次に関数パラメータリスト、そして最後に戻り値の型を考えてみましょう。

各タイプパラメータは、タイプパラメータパックに折りたたむことができます。

個々のリクエストパラメータは、値パラメータパックに折りたたむことができます。

また、リターンタイプは、各ペイロードタイプを繰り返すことによって構築されたタプルに折りたたむことができます。

これで、任意の数のリクエスト引数を処理できるクエリ関数が1つあります。

関数パラメータと戻り値タイプは、どちらもタイプパラメータパック「各ペイロード」の従属タイプであるため、関数の値パラメータパックの長さは常に返されるタプル内の要素数と一致することがわかります。

このAPIでパラメータパックを採用したので、この単一のクエリ関数を1つの引数または3つの引数、または任意の量で呼び出すことができます。

パラメータパックは、すべての引数の長さを同じように処理します。

3つの議論で電話に集中しましょう。

具体的な引数パックは、コールサイトの引数から推測されます。

プレースホルダ「各ペイロード」のすべての具体的なタイプは、引数リストからタイプパックに収集されます。

そして、コンクリートタイプのパックは、リターンタイプを生成するために代用されます。

「各ペイロード」は、パラメータリストと戻り値タイプに表示されます。

コンクリートタイプのパック「Int、String、Bool」は両方の場所で置き換えられ、パターンが3回繰り返されます。

結局のところ、実行されるコードは、タイプパックの3つのタイプすべての反復に相当します。

では、クエリAPIに戻って、パラメータパックに制約を追加する方法を見てみましょう。

クエリペイロードがEquatableであると仮定します。

タイプパラメータパックの後にコロンとプロトコル名Equatableを追加することで、ペイロードパック内のすべての要素がEquatableに準拠する必要があります。

より一般的な要件は、通常のジェネリック医薬品と同様に、「where」句で宣言できます。

パラメータパックには0個以上の引数を含めることができることを覚えておいてください、このサーバークエリAPIにはゼロ引数を受け入れる特別な理由がないと思うかもしれません。

幸いなことに、最小の引数の長さを要求する簡単なテクニックがあります。

この場合、関数に何かを与えるために、少なくとも1つの引数を要求したい。

これを達成するために、タイプパラメータパックの前に通常のタイプパラメータを追加し、値パラメータパックの前に対応する値パラメータを追加します。

型パラメータパックの制約は、新しい型パラメータにも適用する必要があります。この例では、Equatableに準拠しています。

今、あなたの関数への呼び出し者は、少なくとも1つの引数を提供する必要があります。

この時点で、どのパラメータパックが解決し、APIでそれらを読む方法の基礎をカバーしました。

次に、パラメータパックを使用するコードを実装する方法について説明します。

パラメータパックを使用してサーバークエリの実装を構築します。

クエリ関数は、個々の要素がタイプパック内のすべての要素に対するリクエストである値パックを受け入れます。

リクエスト構造体には、ペイロードと呼ばれる単一の型パラメータと、ペイロードのインスタンスを返す評価メソッドがあります。

クエリ関数の本体は、「項目」値パックで動作します。

クエリの本文内で、バリューパック内のすべての項目について評価メソッドを呼び出したい。

繰り返しパターンを使ってこれを表現できます。

繰り返しパターンは、型レベルと値レベルで同じ構文を使用して表現されます。

値レベルでは、「repeat」キーワードの後にパターン式が続きます。

パターン式には、1つ以上のバリューパックが含まれます。

パックは、含まれているすべての値を介して反復され、式は値ごとに1回評価されます。

タプルに含まれるすべての評価結果のリストを作成するには、パターン式を括弧で囲むことができます。

関数に渡される値パックが空の場合、結果は空のタプルになります。

値パックに単一の要素がある場合、結果は別の単一の値になります。

バリューパックに複数の要素がある場合、結果はタプルになります。

そして、それだけです。

これで、結果の値パックを受け入れ、すべての個々の要求を評価し、すべての要求の結果をタプルで一緒に返すクエリ関数があります。

これは、コードでパラメータパックを使用する方法の基礎です。

これは、パラメータパックではなく複数のオーバーロードを使用した以前の例よりもはるかに少ないコードであり、そのバージョンには実装さえありませんでした。

メンテナンスはより簡単で、反復的なコードパターンからしばしば発生するエラーはなくなりました。

では、もう少し柔軟性を加えましょう。

私の例をリファクタリングして、クエリAPIが状態を保存できるようにし、各リクエスト評価が異なる入力タイプと出力タイプを持つようにし、パラメータパックの反復中に制御フローを管理します。

クエリ関数を評価者構造体内に移動し、タイプパラメータパックをクエリメソッドから評価者タイプに持ち上げます。

Evaluator struct は、リクエスト パックを括弧で囲んでタプル値にすることで、保存されたプロパティに格納できます。

具体的なペイロードタイプの引数パックが与えられた場合、「項目」変数は、単一の要求またはすべての要求のタプルのいずれかになります。

次に、リクエストを構造体から、Outputという名前の関連型を持つプロトコルに変更します。

そして、Inputという名前のリクエストプロトコルに別の関連タイプを追加します。

次に、リクエストの評価メソッドを更新して、その引数をプロトコルの入力タイプにします。

これにより、メソッドの戻り値の型が引数の型の型と異なることができます。

この後、すべてのペイロードタイプがリクエストに準拠するように評価者を更新し、それに応じて「アイテム」の保存プロパティを単に「各ペイロード」タイプに更新します。しかし、現時点では、評価者のタイプパラメータパックの「ペイロード」という名前はあまり当てはまらない。

ペイロードは、もはやリクエストに含まれるものではなく、代わりにリクエスト全体に準拠しています。

したがって、ペイロードの名前をRequestに変更し、プロトコルの名前をRequestProtocolに変更します。

クエリメソッドは、各リクエストの入力タイプのパックを受け入れることができ、各リクエストの出力タイプのリストを返します。

最後に、クエリメソッドへの新しいパラメータ「input」は、すべての項目の評価メソッドの呼び出しに渡す必要があります。

これで、サーバーの応答から、クエリに含まれるデータの種類とは異なるタイプを返すことができます。

メソッドの値引数パックの長さは、そのタイプが両方とも評価者の型パックに基づいているため、返される値パックの長さと一致することを知ることができます。

保存されたプロパティ「item」の引数の長さについても同様です。

パラメータパックの使用が反復の一形態であることを考えると、反復から早期に終了したい場合は、制御フローについて疑問に思うかもしれません。

おそらく、クエリのコレクションの結果は、すべてのクエリが成功した場合にのみ有効になるはずです。

これにはスローエラーを使用できます。

この例では、RequestProtocolの評価メソッドをスロー関数に更新し、評価者のクエリメソッドの戻り値タイプをオプションに変更できます。

クエリメソッドの本文をdo-catchステートメントに移動し、do句内にreturnステートメントを配置し、catch句からnilを返すことができます。

これで、個々のクエリの評価は、必要に応じて、すべてのクエリの反復を停止することができます。

このセッションでは、パラメータパックで型を抽象化する方法と、汎用コードの引数について話しました。

パラメータパックを使用して、以前は多数のオーバーロードが必要だった単一の汎用実装を書くことで、コードの制限を簡素化および削除する方法について説明しました。

最後に、パラメータパックを利用しながらサーバーへのクエリの送信を実装するためのコードを書きました。

ジェネリックの詳細については、WWDC22のセッション「Embrace Swiftジェネリック」をチェックしてください。

また、プロトコルとタイプの消去の詳細については、WWDC22のセッション「Swiftでプロトコルインターフェイスを設計する」をチェックしてください。

Swiftパラメータパックは、一般的なジェネリックパターンを簡素化することを可能にすると同時に、ジェネリックコードで可能なことを拡張するための強力なツールです。

あなたが彼らと一緒に何を作るかを見るのが待ちきれません。

ご覧いただきありがとうございます。