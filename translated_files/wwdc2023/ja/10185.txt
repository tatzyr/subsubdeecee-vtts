10185

♪ ♪

ジェフ：こんにちは、ライブアクティビティチームのエンジニア、ジェフです。

プッシュ通知でライブアクティビティの更新をあなたと共有できることを嬉しく思います。

ライブアクティビティは、進行中のアクティビティについて誰かに glanceable情報を表示するのに最適な方法です。

ActivityKitを使用すると、アプリはライブアクティビティを開始、更新、終了できます。

次に、WidgetKitとSwiftUIを利用することで、ユーザーに情報を表示するUIを構築できます。

これらの技術についてもっと知りたい場合は、Canの「Meet ActivityKit」セッションをチェックしてください。

「Meet ActivityKit」セッションでは、ヒーローの冒険のステータスを表示するために、Emoji Rangersに新しいライブアクティビティを追加しました。

でも、ヒーローに仲間がいたらもっと楽しいと思います。

そのため、複数のユーザーがヒーローとパーティーを結成し、一緒に冒険に送ることができる新機能を追加したいと思います。

最高のユーザーエクスペリエンスを提供するために、ライブアクティビティを更新して、パーティー内のすべてのヒーローのイベントを表示します。

これを達成するために、私はデバイス上でそれを行うのではなく、冒険を追跡するためのサーバーを紹介します。

サーバーは、ライブアクティビティを最新の状態に保つ責任があります。

また、計算はサーバーで行われるため、アプリはライブアクティビティを更新するためにフォアグラウンドランタイムを必要としないはずです。

これにより、ユーザーのバッテリー寿命への影響が減少します。

ActivityKitのプッシュ通知でライブアクティビティを更新することは、この機能を実装する素晴らしい方法だと思います。

このセッションでは、私が最初に取り上げるのは、プッシュアップデートでライブアクティビティを更新できるようにするために必要な準備です。

その後、コンピュータから最初のプッシュアップデートを送信します。

第三に、更新の優先順位とユーザーに警告する方法の違いについて説明します。

最後に、プッシュアップデートに追加の機能強化を行い、次のレベルに引き上げます。

準備を始めましょう。

プッシュアップデートでライブアクティビティの更新を開始する前に、アプリとサーバーがAppleプッシュ通知サービスとどのようにやり取りするかを理解すると便利です。

すべてはあなたのアプリから始まります。

新しいライブアクティビティが開始されると、ActivityKitはAppleプッシュ通知サービス、略してAPNsからプッシュトークンを取得します。

このプッシュトークンは、リクエストするライブアクティビティごとに一意です。

そのため、アプリはプッシュ更新の送信を開始する前にサーバーに送信する必要があります。

その後、ライブアクティビティを更新する必要があるときはいつでも、サーバーはトークンを使用してプッシュリクエストをAPNsに送信します。

最後に、APNsはペイロードをデバイスに送信し、ウィジェット拡張機能をウェイクしてUIをレンダリングします。

この新機能をサポートするために、APNsは新しいライブアクティビティプッシュタイプを導入しました。

このプッシュタイプは、APNsへのトークンベースの接続を持つサーバーでのみ使用できます。

プッシュリクエストの送信の詳細については、「APNsへの通知リクエストの送信」のドキュメントを参照してください。

トークンベースの接続の詳細については、「APNsへのトークンベースの接続の確立」を参照してください。

次のステップは、ライブアクティビティがプッシュアップデートを受け取るように設定されるようにアプリを変更することです。

Xcodeで、アプリのターゲットに移動します。

「署名と機能」タブで、プッシュ通知機能を追加します。

これにより、ActivityKitはアプリに代わってプッシュトークンをリクエストできるようになります。

今からコードに飛び込みます。

これは、ライブアクティビティを要求する絵文字レンジャーズのコードのスニペットです。

アクティビティリクエストメソッドに、冒険の属性と最初のコンテンツ状態を与えます。

プッシュ更新の受信をサポートするには、pushTypeパラメータをメソッドに追加し、その値を「トークン」に設定します。

これにより、ActivityKitは、作成時にライブアクティビティのプッシュトークンを要求することを知らせます。

アクティビティが作成されると、アプリはプッシュトークンをサーバーに送信する必要があります。

アクティビティタイプには、プッシュトークンに同期的にアクセスできるpushTokenプロパティがあります。

ただし、アクティビティの作成直後にはアクセスしないでください。

あなたが得る価値は、ほとんどの場合ゼロになります。

これは、プッシュトークンの要求が非同期プロセスであるためです。

また、システムはアクティビティの存続期間中、プッシュトークンを更新することも可能です。

したがって、アプリはそれに応じて処理する必要があります。

プッシュトークンを適切に処理する方法は、まず非同期タスクを作成することです。

次に、アクティビティのpushTokenUpdates非同期シーケンスから値を観察するfor-awaitループを開始します。

Forループ内のコードは、ライブアクティビティの新しいプッシュトークンがあるたびに実行されます。

最初のプッシュトークンだけでなく、その後のプッシュトークンの更新も処理できるため、ここでは非同期forループを使用することが重要です。

トークンを受け取ったら、それを16進数の文字列に変換し、デバッグコンソールに記録します。

これは、次のセクションのテスト中に役に立ちます。

次に、最後に、アプリに必要な他のデータと一緒にプッシュトークンをサーバーに送信します。

プッシュトークンはアクティビティごとに一意であるため、ユーザーが開始するライブアクティビティごとに追跡することが重要です。

また、システムが既存のアクティビティの新しいプッシュトークンを要求すると、アプリにはそれに応じて処理するためのフォアグラウンドランタイムが与えられます。

新しいプッシュトークンをサーバーに送信し、古いプッシュトークンを無効にすることが重要です。そうすれば、その後のプッシュ更新が正しく送信されます。

準備が完了したので、最初のプッシュアップデートを送信する時が来ました。

プッシュ更新を送信するには、APNsにHTTPリクエストを送信する必要があります。

リクエストは、APNsヘッダーとAPNsペイロードの2つの部分で構成されています。

通常のHTTPヘッダーに加えて、提供する必要があるヘッダーが3つあります。

1つ目はapnsプッシュタイプです。価値は活動です。

次はapns-topicで、これはアプリのバンドルIDで、その後に.push-type.liveactivityが続きます。

3つ目はapns-priorityで、値は5または10です。

5は、このプッシュリクエストが優先度が低いことを示し、10は優先度が高いことを示します。

ライブアクティビティがすぐに更新されるため、テスト中に高優先度を使用します。

最初のAPNsペイロードでは、3つのフィールドで構成されるものを送信します。

1つ目は「タイムスタンプ」で、1970年以降の秒単位の時間間隔です。

システムはタイムスタンプを使用して、常に最新のコンテンツ状態をレンダリングしていることを確認します。

2つ目は「イベント」です。

ライブアクティビティで実行したいアクションです。

その値は「更新」または「終了」のいずれかです。

この最初のAPNsリクエストは「更新」に設定する必要があります。

3番目のフィールドは「コンテンツ状態」です。

これは、アクティビティのコンテンツ状態タイプにデコードできるJSONオブジェクトです。

コンテンツの状態を正しい形式で取得するために、アプリ内からFoundationのJSONEncoderタイプを使用できます。

ここでは、ライブアクティビティのContentStateのインスタンスを作成します。

次に、JSONEncoderをインスタンス化します。

最後に、コンテンツの状態をJSONデータにエンコードし、その文字列表現をコンソールに記録します。

キャメルケースキーを使用したこのJSON出力は、私が期待していた通りのように見えます。

コンテンツ状態JSONは、常にデフォルトのデコード戦略を持つJSONDecoderを使用してデコードされます。

したがって、コンテンツの状態をエンコードするときは、カスタムエンコーディング戦略を設定しないでください。

そうしないと、JSONが不一致になり、システムがライブアクティビティの更新に失敗します。

プッシュリクエストに何が含まれているかがわかったので、次のステップは送信をテストすることです。

私は開発中に素早く反復できることの大ファンです。

だから私は、サーバーを変更せずにライブアクティビティのプッシュ通知をテストするのが好きです。

ターミナルから直接APNsにプッシュリクエストを送信することで、これを実現できます。

これを行うためのコマンドラインを設定するには、「コマンドラインツールを使用してプッシュ通知を送信する」の記事を参照してください。

「トークンを使用してプッシュ通知を送信する」というセクションの指示に従っていることを確認してください。

認証トークン変数を印刷することで、すべてが正しく設定されていることをすばやく確認できます。

次に必要な情報はプッシュトークンです。

前のセクションでは、プッシュトークンをコンソールに記録するコードを追加しました。

だから、そこから私はそれを得るでしょう。

同じアプローチを取った場合は、アプリをデバイスにデプロイし、ライブアクティビティを開始してください。

アプリは、アクティビティが開始された直後にプッシュトークンをログに記録します。

プッシュトークンをコピーして、ターミナルのアクティビティプッシュトークン変数として設定します。

APNsリクエストを送信するには、curlコマンドを実行します。

これは私が冒険のライブアクティビティのために構築したものです。

「apns-topic」ヘッダーは、アプリのバンドルIDの後にプッシュタイプの接尾辞が続きます。

次に、「apns-push-type」ヘッダーがアクティブに設定されます。

第三に、「apns-priority」は10に設定されているので、私のリクエストはすぐに配信されます。

最終的なHTTPヘッダー「authorization」は「bearer」に設定され、その後に認証トークン変数が続きます。

データに関しては、APNsペイロード全体が含まれています。

日付コマンドを使用してタイムスタンプを自動的に作成し、数字が秒単位で正確であることを確認しています。

最後に、URLについては、HTTP2を使用していることを確認してください。

そして、URLの最後に、前のステップで設定されたアクティビティプッシュトークン変数を参照します。

そして、それだけです。

このcurlコマンドを実行すると、ライブアクティビティはペイロードで提供される新しいコンテンツ状態で更新されます。

場合によっては、ライブアクティビティが期待どおりに更新されなかった状況が表示されることがあります。

最初に確認すべきことは、curlコマンドを実行するときにエラー応答がないことです。

エラーは、リクエストのフィールドが正しくないことを示しているか、環境の設定時に問題があった可能性があります。

APNsが成功した応答を返したが、ライブアクティビティがまだ更新されなかった場合は、コンソールアプリを使用してデバイスログを表示し、問題をトリアージしようとすることができます。

関連するログを持つ可能性のあるプロセスは、liveactivitiesd、apsd、およびchronodです。

ライブアクティビティがプッシュ通知でどのように更新されているかに満足したら、サーバーを変更して実際のプッシュ更新の送信を開始する時間になります。

そして、それはあなたのユーザーエクスペリエンス、優先順位、アラートを設計する際の重要な部分に私を連れて行きます。

最高のユーザーエクスペリエンスを確保するためには、各アップデートに正しいプッシュ優先度を選択することが重要です。

常に最初に使用することを考慮すべき優先順位は低優先度です。

優先度の低いアップデートは日和見的に配信されるため、ユーザーのバッテリー寿命への影響が低下します。

ただし、これは、プッシュリクエストが送信されたときにライブアクティビティがすぐに更新されない可能性があることを意味します。

したがって、時間の制約の低い更新には低優先度を使用する必要があります。

私の冒険ライブアクティビティでは、一般的な戦利品を見つけたり、いくつかのヘルスポイントを癒すヒーローを見つけるなどの更新は、ユーザーの即時の注意を必要としません。

だからこそ、彼らは優先順位の低いアップデートを使用するための素晴らしい候補者です。

低優先度を使用するもう1つの利点は、送信できる更新の数に制限がないことです。

これを利用するには、ライブアクティビティの更新の大部分に低優先度を使用する必要があります。

一方、特定のアップデートでは、ヒーローがノックダウンされたときや主要なボスが敗北したときなど、ユーザーの即時の注意が必要です。

このような場合は、優先度の高い更新を選択します。

優先度の高いアップデートはすぐに配信されます。

そのため、時間に敏感なアップデートに最適です。なぜなら、それらは時間に敏感なアップデートです。

しかし、ユーザーのバッテリー寿命への影響により、システムはデバイスの状態に応じて予算を課します。

アプリが予算を超えた場合、システムはプッシュ更新を制限し、ユーザーエクスペリエンスに劇的な影響を与えます。

あなたは自分のアプリを一番よく知っているので、どのアップデートにどの優先順位を使うべきかを慎重に検討することが重要です。

絵文字レンジャーズでは、パーティーが次々と主要なボスと戦う特別なタイプの冒険を紹介しています。

この集中的なライブアクティビティに最高のユーザーエクスペリエンスを提供するために、サーバーが優先度の高いプッシュを頻繁に送信して最新の状態に保つ必要があります。

これをサポートするために、アプリのライブアクティビティの頻繁な更新機能を有効にします。

この機能を有効にすると、アプリがより高い更新予算を取得できるため、ライブアクティビティの更新が制限される可能性が低くなります。

この機能を採用するには、NSSupportsLiveActivitiesFrequentUpdatesと呼ばれる情報plistに新しいキーを追加し、その値をYESに設定するだけです。

ユーザーは、設定でライブアクティビティとは無関係に頻繁な更新を無効にすることができます。

そのため、ActivityAuthorizationInfo frequentPushesEnabledプロパティにアクセスすることで、頻繁な更新機能のステータスを検出できます。

サーバーはこの値に従って更新頻度を調整する必要があるので、プッシュ更新の送信を開始する前にサーバーに送信していることを確認してください。

この値は、アクティビティの開始後に一度だけ確認する必要があります。

この値が変更された場合、システムは進行中のすべてのアクティビティを終了するため、サーバーはアクティビティの存続期間中に頻繁に更新が切り替えられることを心配する必要はありません。

アドベンチャーライブアクティビティでは、ヒーローがノックダウンされたとき、すぐに更新することに加えて、私はまた、彼らがすぐにアプリに入って癒しのポーションを使用できるように、ユーザーの注意を引きたいと思います。

これを行うには、ペイロードに3つのフィールドを持つ追加の「アラート」オブジェクトを追加します。

「タイトル」は通知のタイトルになります。

「ボディ」は、アップデートに関する短いメッセージになります。

「サウンド」は、アラートがトリガーされたときに再生される音を示します。

絵文字レンジャーズは複数の言語をサポートしているので、英語でアラートを送信するだけでは理想的ではありませんが、私のサーバーでのローカリゼーションの処理は非常にトリッキーです。

ありがたいことに、アラートオブジェクトの「タイトル」フィールドと「ボディ」フィールドを設定する別の方法があります。

文字列を渡す代わりに、ローカライズされた文字列オブジェクトとして設定できます。

「Loc-key」フィールドは、アプリのローカリゼーションファイルにあるローカリゼーションキーになります。

「Loc-args」フィールドは、ローカライズされた文字列に挿入される値のリストになります。

これで、デバイスはユーザーのロケールに応じて通知を自動的にローカライズします。

アラートに最後のタッチを加えるために、さまざまなアップデートのカスタムサウンドを追加したいと思います。

これを実現するには、まず、リソースとしてアプリのターゲットにサウンドファイルを追加する必要があります。

次に、アラートオブジェクトの「サウンド」フィールドをサウンドのファイル名に設定します。

そして、それだけです。今、私のアラートは素晴らしく見え、聞こえます。

今、私はライブアクティビティのユーザーエクスペリエンスを本当に磨くために強化を行うつもりです。

冒険が終わったら、ライブアクティビティを終了し、一定時間後に却下したい。

これを行うには、イベントが終了するように設定されたプッシュペイロードを送信します。

ライブアクティビティをロック画面から削除するタイミングを制御したいので、カスタムの「解雇日」を提供します。

このフィールドを省いて、ライブアクティビティをいつ却下するかをシステムが決定できるようにすることができます。

「解雇日」の値は、1970年以降の秒単位の時間間隔である必要があります。

また、ライブアクティビティに最終的な更新を提供するために、最終的なコンテンツの状態も提供しています。

これもオプションであり、省略された場合、アクティビティは却下されるまで以前のコンテンツ状態を表示し続けるだけです。

場合によっては、ユーザーのデバイスがプッシュ通知を受信できないことがあります。

そして、アドベンチャーライブアクティビティはまだ時代遅れの健康値を表示しているかもしれません。

これらのシナリオでは、Live Activity UIのユーザーに不正確な情報が表示されている可能性があることを警告したいと思います。

これを達成するために、ペイロードに「stale-date」フィールドを追加します。

システムは、この日付を使用して、古いビューをいつレンダリングするかを決定します。

ウィジェット拡張機能で宣言されたActivityConfigurationから古いビューを提供できます。

私がしなければならないのは、私のビューがActivityViewContextのisStaleプロパティの値に反応することだけです。

同時に複数のアドベンチャーライブアクティビティがある場合は、ロック画面で正しく注文されていることを確認したいです。

より重要なアップデートがあるものはトップの近くにあり、最も重要なものはダイナミックアイランドにあるべきです。

オプションの「relevance-score」フィールドを提供することで、これを手配できます。

数字が高いほど、関連性が高いことを示します。

ライブアクティビティをプッシュ通知で更新する方法がわかったので、アプリに追加する時が来ました。

最初にすべきことは、ActivityKitのプッシュ通知をサポートするようにサーバーとアプリを設定することです。

次に、端末からプッシュ更新の送信をテストして、すばやく反復します。

それに満足したら、サーバーにエンド・トゥ・エンドのサポートを実装し始めてください。

一方、ユーザーエクスペリエンスを念頭に置いて、適切な優先順位を使用し、必要に応じてユーザーに警告する必要があります。

私と一緒にライブアクティビティについて学ぶのを楽しんでいただければ幸いです。

あなたがダイナミックアイランドとロック画面にもたらすすべての創造的なアイデアを見るのが待ちきれません。

見てくれてありがとう。

♪ ♪