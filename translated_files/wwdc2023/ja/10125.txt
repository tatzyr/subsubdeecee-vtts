10125

♪ ♪

ゲオルギ:こんにちは、ようこそ!

GPU、グラフィックス、ディスプレイソフトウェアのソフトウェアエンジニア、Georgi Rakidovです。

このセッションは、ゲームをMacに持ち込むのに役立つ3部構成のシリーズの3番目です。

最初のセッションでは、新しいゲームポーティングツールキットを使用してMac上で変更されたWindowsゲームを実行し、グラフィックス、オーディオ、およびディスプレイ機能を評価する方法について説明します。2番目のセッションでは、新しいメタルシェーダーコンバーターツールを使用して既存のHLSLシェーダーをMetalにコンパイルすることで、開発時間を節約できるかを示します。

このセッションでは、レンダラーをMetalに移植し、Apple Siliconから優れたパフォーマンスを得る方法についての詳細な洞察を提供することで、ゲームをMacに持ち込むプロセスを完了します。

レンダラーをMetalに移植すると、エンジンが他のプラットフォームグラフィックスAPIからMetalに概念をマッピングする必要があることに気付くでしょう。

それを支援するために、このセッションでは、Metalのベストプラクティスを含む4つのトピックを取り上げているため、Apple GPUの強力なアーキテクチャを活用できます。

各ゲームは、テクスチャやデータバッファを含むGPUリソースをGPUで使用できるようにし、シェーダーがそれらにアクセスする方法を設定する責任があります。

あなたのゲームは、GPUにコマンドを送信する方法を最適化することで、Appleプロセッサの強力なグラフィックスアーキテクチャを活用できます。

ゲームは通常、間接レンダリングを使用して現代のレンダリング技術を実装します。

MetalFXは、より低い解像度にレンダリングし、MetalFXで最終的な解像度にアップスケーリングすることで、ゲームが各フレームの時間を節約するのに役立ちます。

リソースの管理に関しては、各エンジンはGPUが各テクスチャ、データバッファなどにどのようにアクセスするかを決定する必要があります。

Metalでは、シェーダーにバインディングでリソースへのアクセスを提供し、リソースをGPUアクセス可能なメモリに常駐させ、それらへのアクセスを同期させることを考えることが重要です。

リソースバインディングとシェーダーは一緒になります。

今年の新しいツールであるMetal Shader Converterを使用して、既存のシェーダーを翻訳することから始めましょう。これにより、シェーダーをMetalに移植する多くの時間を節約できます。

このシリーズの「シェーダーをコンパイルする」セッションから詳細を学ぶことができます。

メタルシェーダーコンバーターは、2つのバインディングモデルから選択できます。

「自動レイアウト」を使用すると、コンバーターは自動的にバインディング情報を生成するか、「明示的なレイアウト」でバインディング情報をMetal Shader Converterに渡すことができます。

明示的なレイアウトは非常に柔軟で、他のプラットフォームからバインディングモデルを実装する必要がある場合に役立ちます。

たとえば、一部のAPIデザインはシェーダールートシグネチャを使用しており、ここでは4つのエントリを持つ典型的なものです。一連のテクスチャを指す記述子テーブル、バッファルートパラメータ、32ビット定数、および一連のサンプラーを指す別の記述子テーブルです。

各記述子テーブルは、すべてのテクスチャ、すべてのサンプラー、またはすべてのバッファなど、同じタイプの要素を含むリソース配列です。

メタルの引数バッファは、要素が複数のタイプである可能性があるという点で、より柔軟です。

しかし、エンジンが均質な配列を期待している場合は、引数バッファで簡単にエンコードできます。

この例では、テクスチャ記述子テーブルに相当するものをエンコードします。

これは、各テクスチャのMetalリソースIDを格納することにより、テクスチャ記述子テーブルとして機能するMetalバッファを割り当てることから始まります。

各テクスチャを作成すると、コードはリソースIDをテーブルに直接保存します。

良い部分は、レンダリングループの前面と外側でこのようなコードを実行できることです!

サンプラー記述子テーブルをエンコードするプロセスはほぼ同じです。

テクスチャと同様に、コードはサンプラー記述子テーブルとして機能するMetalバッファを作成することから始まります。

コードが各サンプラーの記述子を設定すると、supportArgumentBuffersプロパティをyesに設定します。

コードが記述子を使用してサンプラーを作成した後、サンプラーのリソースIDをテーブルに保存します。

引数バッファを使用して、トップレベルのルート署名自体を表すこともできます。

この例では、ルートシグネチャの構造を定義し、その1つのインスタンスを保存できるMetalバッファを作成します。

コードは、テクスチャとサンプラーテーブルのGPUアドレスを含む適切な値を持つ構造体のフィールドの各フィールドを割り当てます。

ルート署名を変換するために必要なのはそれだけです。

議論バッファはメタル3で超効率的です!

これで、トップレベルの引数バッファをシェーダーにバインドできます。

この部分はレンダリングループで行われますが、レンダリングループの外側で事前に記述子テーブルとルート構造を作成できます。

Metal 3引数バッファは、ルートシグネチャや記述子テーブルなど、他のバインディングモデルを変換するための柔軟でパフォーマンスの高い方法を提供します。

リソースは、シェーダーがアクセスするために、特定のパスまたはレンダリングステージの実行中に常駐する必要があります。

また、リソースがパス間で共有されている場合は、それらのパスの実行順序を同期する必要があります。

Metal引数バッファを使用したバインドレスリソースの使用には、すべてのGPUアーキテクチャで明示的なレジデンシー管理が必要であり、Metalはレジデンシーを制御する効率的な方法を提供します。

推奨事項は、すべての読み取り専用リソースを大きなヒープにグループ化することです。

そうすれば、エンコーダごとに1回useHeapを呼び出すだけで、そのパスまたはレンダリングステージの期間中、すべての読み取り専用リソースが常駐し、シェーダーがアクセスできるようになります。

これがあなたのやり方です。

すべての読み取り専用リソースを割り当てるために必要なサイズのヒープを作成し、このヒープから各リソースを割り当てます。

そして、レンダリング時に、useHeapを呼び出すだけで、これらすべてのリソースを常駐させます。

書き込み可能なリソースについては、ストーリーは少し異なります。

書き込み可能なリソースを個別に割り当て、適切な使用フラグでuseResourceを呼び出すことを検討してください。

この場合、Metalはあなたのために同期を処理し、パフォーマンスを最適化します。

これにより、Metalエンコーダ間でリソースを手動で同期する負担を回避できます。

以前と同様に、リソースを割り当てることから始めますが、今回はヒープに裏打ちされていません。

次に、これらのリソースにアクセスするエンコーダに対してのみ、適切な使用フラグでuseResourceを呼び出します。

この例では、エンコーダはテクスチャに書き込み、バッファから読み取っています。

これはこの推奨事項の表です。

読み取り専用リソースと書き込み可能なリソースの両方が、トップレベルの引数バッファからアクセスされます。

理想的なケースでは、エンコーダごとに1回だけ設定してください。

読み取り専用リソースは、ヒープにグループ化され、ハザードトラッキングモードは追跡なしに設定されています。

ヒープ内のすべてのリソースを常駐させるには、エンコーダごとに1回useHeapを呼び出します。

書き込み可能なリソースは、個別に割り当てられ、ハザードトラッキングと同期をMetalに残します。

そして、各リソース呼び出しについて、エンコーダごとに1回resourceを使用します。

これは効率的なアプローチです!

CPUオーバーヘッドの少ないバインドレスモデルを実装し、アプリケーションはハザードトラッキングと同期、深刻な労力を必要とする複雑なタスク、開発時間を心配する必要はありません。

バインドレス、レジデンシー、同期の詳細については、セッション「Go bindless with Metal 3」を参照してください。リソースバインディング、レジデンシー、および同期がコードに実装されると、画面上で何かをレンダリングするために、エンジンはレンダラーにコマンドを送信する必要があります。

Appleプロセッサには、コマンドの実行を最適化するための多くの機能があります。

GPUは、CPUとGPUがシステムメモリを共有しているユニファイドメモリアーキテクチャを備えたタイルベースの遅延レンダラー（TBDR）です。

また、GPUにはTile Memoryと呼ばれる高速なオンチップメモリがあります。

このアーキテクチャを活用するために、Metalはパスの概念を持っており、あなたの目標はレンダリングコマンドをパスにグループ化し、それらのパスを適切に設定することです。

TBDRアーキテクチャの詳細については、関連するプレゼンテーション「MetalアプリをApple Silicon Macに持ち込む」と「AppleGPUをMetalで活用する」を参照してください。

他のAPIは、異なるタイプのGPUコマンドを混合する連続ストリームを持つことができ、あなたのエンジンはこれを想定するかもしれません。

コマンドをMetalに変換して、まずコマンドバッファを作成します。

次に、コマンド、グラフィックス、コンピュート、またはBlitの種類に応じて、それらをパスにグループ化します。

コマンドエンコーダを使用して、各パスのコマンドをコマンドバッファに書き込みます。

最後に、すべてのコマンドがエンコードされたら、GPUによって実行するためにコマンドバッファをコマンドキューに送信します。

エンジンは、レンダリングコマンドをMetalに効率的に変換するための4つのベストプラクティスを検討できます。

レンダリング開始前にコピーを事前にバッチ処理し、同じタイプのコマンドをグループ化し、レンダリングターゲットをクリアするための空のエンコーダを避けることから始めます。

そして最後に、Metal LoadとStoreのアクションを最適化して、メモリ帯域幅を最小限に抑えます。

これらのベストプラクティスは、例を使って簡単に説明できます。

次のシーケンスがあるとします。レンダリングターゲットクリア、ドロー、コピー、ディスパッチ、および別のドローです。

特に、このシーケンスで生成されたシステムとタイルメモリ間のすべてのメモリトラフィックを見てください。

これは理想的ではありません!

ストリームの中央にあるコピーは、後続のドロー、この場合はドロー1の均一なデータをコピーします。

可能であれば、レンダリングパスの中断を避けるために、レンダリング前にこれらのコピーを移動してバッチ処理することをお勧めします。

変更後、コピーが最初になり、次にクリア、描画0、ディスパッチ、描画1です。

2つのドローコールとディスパッチの間に依存関係がない場合は、ドローとディスパッチを一緒にバッチ処理できるように、それらを並べ替える必要があります。

この例では、ドローとディスパッチコールの順序を切り替えた後、互いに2つのレンダリングパスを持つようになりました。

このシナリオは、同じレンダリングターゲットを共有している場合、それらを単一のレンダリングパスにマージするのに最適で、メモリ帯域幅を大幅に節約できます。

そうすれば、データがタイルメモリからシステムメモリに移動し、2つの描画の間に戻る必要がないため、不要なメモリトラフィックを削除できます。

これはすでに優れていますが、さらに最適化される可能性があります。

クリアは空のエンコーダで、1つの目的しかありません。次のドローで使用されるレンダリングターゲットをクリアすることです。

金属では、これを行うための非常に効率的な方法があります。

レンダリングターゲットを使用する最初のレンダリングパスには、LoadActionClearを使用するだけです。

これははるかに優れていますが、ロードとストアアクションを最適化できる推奨事項がもう1つあります。

次のパスで使用されるレンダリングターゲットの内容をシステムメモリに保存するだけです。

この例から、ドロー1の後、最初のレンダリングターゲットのみが使用されると仮定します。

他のすべてのレンダリングターゲットは中間であり、コンテンツを保存する必要はありません。

メタルを使用すると、各レンダリングターゲットのストアアクションを制御できます。

この場合、最初のレンダリングターゲットにはStoreActionStoreを使用し、他のターゲットにはStoreActionDontCareを使用できます。

そして、それだけです!これが最初のコマンドシーケンスです。

タイルメモリとシステムメモリの間には5回の往復があります。

そして、これはいくつかの簡単な最適化の後、コマンドシーケンスがどのように見えるかです。

タイルメモリからシステムメモリへの最後のフラッシュは1回だけです。

メモリ帯域幅が大幅に削減されました!

そして、レンダリング前にコピーを移動し、同じタイプのコマンドをグループ化し、空のエンコーダでレンダリングターゲットをクリアすることを避け、ロードとストアアクションを最適化することによって達成されました。

GPUツールは、これらの問題を特定するのに役立ちます。

Xcodeのメタルデバッガは自動的に最適化の機会を見つけるので、ゲームで最高のパフォーマンスを得ることができます。

これにより、Metalパスの依存関係を検査して理解することができ、フル機能のデバッグおよびプロファイリングツールスイートが付属しています。

メタルデバッガを使用して、言及された問題を特定するのは簡単です。

メタルワークロードをキャプチャすると、メタルデバッガーはサマリービューアを表示します。

下部のインサイトセクションには、メモリ、帯域幅、パフォーマンス、API使用の4つのカテゴリに分類された最適化の機会が表示されます。

このワークロードで強調したい帯域幅の洞察が2つあります。

1つ目は未使用のリソース用です。

インサイトを選択すると、右側のパネルでそれに対処するための要約と実用的なアドバイスを見つけることができます。

GBufferパスは、必要以上に多くの添付ファイルを保存しています。

この場合、GBufferパスはアルベド/アルファテクスチャをロードして保存します。

ただし、アルベドテクスチャはこのフレームの後半では使用されないため、ストアは冗長であるため、ストアアクションをDontCareに設定することで修正できます。

次のインサイトを確認しましょう。

レンダリングパスを組み合わせることは、帯域幅を減らすのに役立ち、ここでの洞察は、GBufferとForwardパスを1つのパスに組み合わせることができることを示唆しています。

また、右側の[依存関係で表示]ボタンをクリックして、依存関係ビューアでこのレンダリングパスを見つけると、これらのパスが何を読み書きしているかについて詳しく知ることができます。

依存関係ビューアは、パス間の依存関係を検査するための素晴らしいツールです!

ここでは、レンダリング添付ファイルの上下に示されているロードとストアのアクションを一目で確認できます。

このパスのすべての添付ファイルにはストアアクションストアがありますが、将来のパスではカラー0と深度アタッチメントのみが使用されます。

以前の洞察はこれを明らかにした。

少しズームアウトすると、データエッジがGBufferパスからフォワードパスに流れるように表示されます。

洞察が示すように、GBufferパスとフォワードパスは、同じ添付ファイルから保存およびロードしているため、帯域幅を節約するためにマージできます。

これら2つのパスをマージすると、帯域幅が節約され、パフォーマンスが向上します。

これは、Metal Debuggerを使用してゲームの最適化の機会を見つける方法の一例にすぎません。

Metal Debuggerの詳細については、関連するセッション「Xcode 12でMetalアプリの洞察を得る」と「Metalのデバッグ、プロファイリング、アセット作成ツールを発見」をご覧ください。

間接レンダリングは、ハイエンドゲームが高度なレンダリング技術を実装するために使用する重要な機能です。

このトピックでは、ExecuteIndirectの仕組みと、この特定のコマンドをMetalに翻訳する方法について説明します。

間接レンダリングでは、複数のドローコマンドをエンコードする代わりに、それらの引数はメモリ内の通常のバッファに格納され、1つのExecuteIndirectコマンドのみがバッファを参照してエンコードされ、バッファからそれぞれの引数を取得することによってGPUが実行しなければならないドロー呼び出しの数を指定します。

このアプローチの主なアイデアは、ExecuteIndirectコマンドの前に実行がスケジュールされた計算シェーダーによって間接バッファのコンテンツに入力できるようにすることです。

このようにして、GPUは自分で作業を準備し、何をレンダリングするかを決定します。

間接引数によるコマンドの実行は、GPU駆動のレンダリングループなどの高度な技術を実装するための重要な機能です。

このコマンドをMetalに変換するには、Draw IndirectとMetal Indirect Command Buffers（ICB）の2つの方法があります。

Metalでは、レンダラーは各ExecuteIndirectをDrawIndirectへの一連のAPI呼び出しに変換しなければなりません。

それぞれがバッファを参照し、描画引数のオフセットを提供します。

これがコードです。

このExecuteIndirectが持つ可能性のあるドロー呼び出しの最大数を調べてください。

それぞれについて、間接引数バッファとそのバッファ内のオフセットを指定する別々のドローをエンコードします。

反復の最後に、オフセットを次の間接引数のセットを指すように移動します。

このアプローチは実装が非常に簡単で、ほとんどすべての状況で機能します。

ただし、何千ものドローコールのシーンがあり、ゲームのパフォーマンスがCPUエンコーディング時間によって制限されている場合は、Metalの間接コマンドバッファを検討する必要があります。

ICBは、間接ドロー引数を持つバッファのスーパーセットです。

引数を描画するだけでなく、バッファバインディングを設定し、GPUからパイプライン状態オブジェクトをレンダリングすることもできます。

GPUで実行するためにICBからのコマンドをスケジュールするには、executeCommandsInBufferコマンドをエンコードする必要があります。

通常、ExecuteIndirectでは、すべてのドロー呼び出しは同じパイプライン状態オブジェクトを共有します。

また、PSOが変更されるたびに、新しいExecuteIndirectコマンドをエンコードする必要があります。

ICBを使用している場合は、頻繁に状態変更によって間接実行コマンドを分割する必要はありません。

すべてのPSOとバッファバインディングはICBから設定できるので、エンコードする必要はありません。

シーンの構造によっては、エンコード時間が大幅に短縮される可能性があります。

ICBを活用するには、間接引数を入力する既存のシェーダーを変更する必要はありません。

同じシェーダーを他のプラットフォームと共有し、Metal Shader Converterでコンパイルし、間接引数の生成後、間接レンダリングパスの前に小さな計算カーネルを追加して、描画引数をICBに変換できます。

コンピューティングカーネルでICBをエンコードするには、Metal Shading Languageで記述します。

シェーダへの入力として、翻訳したい間接引数へのポインタがあります。

次に、引数が有効かどうかを確認し、その場合にのみコマンドをエンコードします。

encodeCommand関数で、レンダリングパイプライン状態、バッファバインディング、およびドロー呼び出しを設定します。

これは、描画引数を間接コマンドバッファのレンダリングコマンドに変換します。

そして、それが間接レンダリングをMetalに変換する方法です。

一連のdraw間接コマンドまたはMetal Indirectコマンドバッファを使用できます。

間接レンダリングを使用して高度なレンダリング技術を実装する方法を学びたい場合は、「Metalによるモダンレンダリング」サンプルコードをチェックしてください。

ゲームがリソースをパイプラインにバインドし、コマンドをコマンドバッファに適切にエンコードすることで正しい画像を生成すると、アップスケーリングを活用してプレイヤーのデバイスからパフォーマンスを向上させることができます。

MetalFXを介したアップスケーリングは、GPUの作業量を減らすことで、ゲームが各フレームの時間を節約するのに役立ちます。

MetalFXは、アップスケーリングパイプラインを実装するためのターンキーソリューションです。

これは、出力解像度で直接レンダリングするよりも短い時間で、低解像度の画像をターゲット出力解像度までスケーリングすることで機能します。

MetalFXは昨年Mac用に導入され、高性能なアップスケーリングを提供します!

MetalFXは、最高のパフォーマンスのための「Spatial」と、出力解像度のネイティブレンダリングに近づく品質のための「Temporal」の2つのアップスケーリングアルゴリズムをサポートしています。

MetalFXをエンジンに統合すると、より高い解像度でより良いパフォーマンスでレンダリングすることで、プレイヤーの体験が向上します。

今年の新機能には、iOSのサポート、最大3倍のアップスケーリング、Metal-cppのサポートが含まれます。

エンジンがすでに他のプラットフォームで既存のアップスケーリングソリューションをサポートしている場合、MetalFXの統合はエンジン側で多くのコーディングと変更を必要としません。

MetalFXをサポートするには、エンジンのアップスケーリングサポートが必要です。

もう1つの要件は、マテリアルシェーダーのテクスチャサンプリングの詳細レベルを手動で制御するレンダラーです。

時間的アップスケーリングには、ジッタシーケンスとモーションベクトルが必要です。

エンジンが一時的なアンチエイリアシングをサポートしている場合は、おそらくすでにそれらを持っているでしょう。

MetalFXの一時的なアップスケーリングは、レンダリングの露出を考慮に入れることができ、2つの選択肢があります。

レンダラーが1×1の露出テクスチャをサポートしている場合は、それを使用してください。

それ以外の場合は、自動露光機能を有効にして、品質が向上するかどうかを確認できます。

カメラのカットや極端なカメラの動きの履歴をリセットすることを忘れないでください。

MetalFXをアプリケーションに統合する方法の詳細については、昨年のドキュメントと「MetalFXアップスケーリングによるパフォーマンスの向上」を参照してください。

Metalは、アプリのレンダリング時間を最大限に活用するためのいくつかの強力なオプションを提供します。

リソースを管理し、できるだけ効率的にバインドすることができます。

シェーダーがそれらにアクセスする方法に基づいて、リソースを共有するパスが正しい順序で実行されるようにし、リソースを常駐してGPUで利用可能にします。

アプリは、XcodeのMetal Debuggerで最適化の機会を見つけて適用し、コマンド送信を最適化することで、Appleの強力なグラフィックスアーキテクチャの可能性を最大限に活用できます。

間接レンダリングを実装することで、GPUが自分で作業を決定することができます。これは、多くの最新のレンダリング技術の鍵になる可能性があります。

MetalFXでレンダリングをアップスケーリングすることで、レンダリングゲームをアップします。これにより、レンダリングループでアプリの貴重な時間を節約できます。

より多くのレンダリングのヒントとガイドラインについては、「AppleシリコンMacのメタルパフォーマンスの最適化」をチェックしてください。

見てくれてありがとう!

♪ ♪