10192

♪ ♪

アレックス：こんにちは。私の名前はアレックスです。私はビデオエンジニアリングチームの出身です。

今日、同僚のアントワーヌと私は、RoomPlanの新機能を共有します。

RoomPlanは、ARKitを搭載した洗練された機械学習アルゴリズムを使用して、壁、窓、ドア、開口部、その他の部屋を定義するオブジェクトを検出します。

RoomCaptureView APIを使用すると、スキャン体験をアプリに直接統合できます。

スキャンが完了すると、アプリは結果の3Dモデルを表示し、USDZファイルにエクスポートできます。

このセッションでは、RoomPlanの新機能について説明します。

カスタムARSessionを使用して、RoomPlanとARKitを組み合わせる新しい方法から始めます。

その後、マルチルームサポートに注意を向けます。

個々のルームスキャンを1つの大きな構造にマージする新しいマルチルームAPIを提供します。

次に、RoomCaptureViewの新しいVoiceOverサポートを紹介します。

最後に、RoomPlanの表現のいくつかの改善と、新しいワークフローを可能にするためのエクスポート機能の強化について確認します。

カスタムARSessionサポートから始めましょう。

前述のように、RoomPlanはスキャン中に壁、窓、ドア、開口部、その他のオブジェクトを検出するためにARKitからの情報に依存しています。

このため、RoomCaptureSessionはデフォルトのARSessionで実行されています。

iOS 17の新機能であるRoomPlanでは、ARWorldTrackingConfigurationでカスタムARSessionを使用できます。

これにより、同じワークフロー内でRoomPlanとARKitの使用を組み合わせるいくつかの新しい方法が可能になります。

いくつかの例を見てみましょう。 ではいくつかの例を見てみましょう。

カスタムARSessionでRoomPlanを使用する1つの方法は、RoomPlanの結果とARKitシーンジオメトリと平面検出を組み合わせて、仮想コンテンツと現実世界のジオメトリの間のより没入感のある相互作用を実現することです。

さらに、ARKitから高品質の画像キャプチャを使用して、RoomPlanでより豊かな不動産リストを作成することで、スペースの写真表現を収集できます。

また、既存のAR体験の一部としてRoomPlanを使用している場合は、既存のARAnchorsを中断することなく、RoomPlanの結果を組み合わせることができます。

これらは、カスタムARSessionが提供できるいくつかのユースケースにすぎません。

カスタムARSessionをRoomPlanに渡す方法を確認するために、いくつかのコードを見てみましょう。

これは、以前のRoomPlanのinitとstop機能です。

そして、カスタムARSessionをinit関数に渡す方法は次のとおりです。

ARWorldTrackingConfigurationを使用したカスタムARSessionは、RoomCaptureSession内で尊重されます。

また、停止機能には、基礎となるARSessionを一時停止するかどうかを判断するための新しいオプションが含まれています。

RoomCaptureSessionが停止した後もARSessionを実行し続ける場合は、Booleanをfalseに設定できます。

次のセクションでは、複数のスキャンを1つの大きな構造にマージするなど、ARSessionでの作業がどのように新しいワークフローを可能にするかを見ていきます。マルチルームサポートに注意を向けましょう。

マルチルームサポートとは何ですか?

以前のRoomPlanでは、1回のスキャンを行い、シングルルームの3Dモデルを取得できました。

ダイニングルーム、キッチン、リビングルーム、廊下、寝室など、家のさまざまな部屋のスキャンを数回行ったとします。

それらをマージしたい場合は、いくつかの課題に直面するでしょう。

まず、それらはすべて独自の座標系にあります。つまり、世界座標の原点と向きは部屋ごとに異なります。

第二に、手動でステッチしても、壁が重複し、オブジェクトが重複する可能性があります。

まず、異なる座標系に取り組みましょう。

ここで達成したいのは、すべてのスキャンを同じ座標系で撮影することです。

ここでは、複数の部屋をスキャンするための2つのアプローチが提案されています。

まず、継続的なARSessionを使用してください。

第二に、ARSessionの再ローカリゼーションを使用します。

連続ARSessionの使い方を見てみましょう。

以前のRoomPlanでは、RoomCaptureSessionが停止すると、ARSessionは一時停止されます。

各スキャンには異なる座標系があります。

新しいAPIには、stop関数に新しい引数があり、pauseARSessionをfalseに設定できます。

これにより、ARSessionは、最終的に再びARSessionを一時停止することを決定するまで、その後のスキャンであっても、次のスキャンのために実行し続けることができます。

このアプローチを使用すると、同じARSessionが複数のスキャンで実行されるようにすることができます。

これにより、すべてのスキャンに1つの共通の世界座標系を持つことができます。

これがコードでどのように機能するかを見てみましょう。

連続ARSessionでRoomCaptureSessionを実行する例を次に示します。

RoomCaptureSession.runで最初のスキャンを開始します。

次に、ここに重要な部分があります。

RoomCaptureSession.stopの新しいAPIでは、pauseARSessionをfalseに設定する必要があります。

これにより、次のスキャンのためにARSessionを実行し続けます。

その後、2回目のスキャンに同じroomCaptureSessionインスタンスを使用します。

次に、2回目のスキャンを停止します。

最後に、同じ座標系で1番目と2番目のスキャン結果を得ることができました。

同じ座標空間内で個々の部屋スキャンを行うもう1つのアプローチは、ARSessionの再ローカリゼーションを使用することです。

このアプローチは、翌日または週に同じ場所に戻ってくるなど、異なる時間に個々の部屋のスキャンを行う場合に最適です。

これがどのように機能するかを見てみましょう。

繰り返しになりますが、これはシングルルームの3Dモデルを取得するためのシングルスキャンです。

RoomCaptureSessionを停止し、ARSessionを一時停止するため、将来のスキャンのために再ローカリゼーションが機能するために、ARWorldMapをディスクに保存する必要があります。

ARSessionが一時停止したときに前のスキャンを続行したい場合は、一時停止したARSessionからARWorldMapをロードしてスキャンを再開できます。

このARWorldMapを使用すると、以前のスキャンの環境に対して再ローカライズして、一連のスキャンがすべて共通の座標系を共有することを確認できます。

再ローカリゼーションによるスキャンワークフローのサンプルコードを見てみましょう。

まず、最初のスキャンを実行します。

次に、ARSessionを一時停止して最初のスキャンを停止します。

その後、再ローカリゼーションが機能するには、ARSessionが一時停止されたときにARWorldMapを保存する必要があります。

2回目のスキャンを実行する前に、以前のARWorldMapを復元する必要があります。

まず、ARWorldMapをロードします。

そして、ロードされたARWorldMapをARWorldTrackingConfigurationに割り当てます。initialWorldMap。

次に、ARSessionを実行して再ローカリゼーションをトリガーします。

再ローカリゼーションが完了すると、以前のARSessionが読み込まれます。

現在の世界座標は、以前の世界座標と一致しています。

その後、2回目のスキャンを実行できます。

最後に、2回目のスキャンを停止します。

これらすべてのステップで、1回目と2回目のスキャン結果は同じ3D世界座標になります。

同じ3D座標系で複数のスキャンをリンクする2つのアプローチを見てきました。

次に、新しいMultiRoom APIを使用して、それらを1つの結合構造にマージする方法を見ていきます。

スキャンごとに、RoomBuilder APIを実行して、個々のCapturedRoomを生成できます。

前に示したように、継続的なARSessionとARSessionの再ローカリゼーションにより、すべてのCapturedRoomは同じ3D世界空間にあります。

これは、3つのCapturedRoomsを備えたRoomBuilderからの出力です。

次に、新しいマージAPIであるStructureBuilderを提供し、それらをすべて1つの大きな構造であるCapturedStructureにマージします。

次に、StructureBuilder APIのサンプルコードを見てみましょう。

StructureBuilder APIを使用して複数のスキャンをマージする方法は次のとおりです。

まず、設定オプションでStructureBuilderインスタンスを作成します。

次に、以前にスキャンした複数のCapturedRoomsをロードする配列を作成します。

その後、StructureBuilder APIを呼び出すと、マージされた結果である capturedStructureを取得します。

最後に、キャプチャされたStructureをUSDZファイルにエクスポートできます。

そして、これがCapturedStructureの定義です。

まず、それは部屋のプロパティを持っています。

これはCapturedRoomインスタンスの配列です。

次に、マージされた壁、ドア、窓、開口部、およびオブジェクトのプロパティがあります。

最後に、USDZファイルにエクスポートする機能があります。

マルチルームの動作を見てみましょう。

複数のスキャンをStructureBuilder APIとマージし、USDZファイルにエクスポートできるsample.appを提供しています。

私たちのUSDZファイルは、iOSとmacOSの両方でプレビューする準備ができています。

USDZファイルをBlenderなどのデジタルコンテンツ作成ツールに読み込むことで、これをさらに一歩進めることができます。

3Dモデルにいくつかの美化を適用した後、結果はさらに良く見えます。

最後に、マルチルームサポートで最高のマルチルーム体験を得るためのいくつかの考慮事項について話しましょう。

マルチルームは、1〜4つのベッドルーム、リビングルーム、キッチン、ダイニングルームの典型的なセットアップで、1階建ての住宅に最適です。

個々の部屋をスキャンしてマージするには、2,000平方フィートまたは約186平方メートルの最大総面積をお勧めします。

さらに、RoomPlanがクリアなビデオストリームと優れたARトラッキングパフォーマンスでスキャンできるように、50ルクス以上の良好な照明が推奨されます。

さて、アントワーヌがiOS 17のRoomPlanのさらなる機能強化について教えてくれます。

アントワーヌ:ありがとう、アレックス。

ここからピックアップして、アクセシビリティについて話しましょう。

レンダリングについて話すとき、私たちのほとんどは視覚的なモダリティについて考えますが、弱視の人にとっては、このモダリティは最も有用なものではありません。

今年、RoomPlanはVoiceOverが有効になっているときにオーディオフィードバックを追加し、携帯電話がスキャンに関するガイドラインを提供し、見たものを説明できるようにしました。

VoiceOver: デバイスを移動して起動します。

壁の下端にあるポイントカメラ。

暖炉。壁。

窓。

アントワーヌ：それでは、RoomPlanが部屋から収集できる新しい情報と、それがどのようにレンダリングされるかについて話しましょう。

RoomPlanを使用すると、幅広い部屋を簡単にスキャンできます。

しかし、これまでのところ、それは部屋の状況の有限セットを正確に表すことに限定されていました。

RoomPlanは現在、傾斜した壁や湾曲した壁だけでなく、食器洗い機、オーブン、シンクなどのくぼんだキッチン要素を含む、さらに多種多様な部屋をサポートしています。

RoomPlanは、特定のカテゴリのオブジェクトの構成を検出するためにも改善されました。

たとえば、シングルシートからL字型、そしてRoomPlanが新しいバージョンで検出するシンプルな四角いソファまで、多くのタイプのソファがあります。

RoomPlanを紹介したとき、RoomPlanがスキャンできる2つの要素、サーフェスとオブジェクトについて話しました。

今、私たちは部屋の中の領域を記述するための新しい要素を追加しています。

私たちはそれらをセクションと呼んでいます。

壁は、傾斜した壁や梁のある壁などの不均一な壁を扱うために、ポリゴンとして記述できるようになりました。

これまでのところ、湾曲した壁と窓はデータのみのAPIの一部でした。

これで、RoomCaptureViewの最終結果は、湾曲した壁をレンダリングすることもできます。

表面カテゴリに加えて、フロアカテゴリはポリゴンとしても記述できる別の追加です。

オブジェクトには、カテゴリ内のさまざまな構成をよりよく記述するための属性を持つようになりました。

サーフェスとオブジェクトに新しい親変数が追加されました。

親の識別子が含まれています。

たとえば、窓の親は壁、椅子の親はテーブル、食器洗い機の親は収納になります。

これらのすべての改善を例で詳しく説明しましょう。

各セクションでは、あなたの部屋や家のさまざまなエリアについて説明しています。

セクションには、リビングルーム、ベッドルーム、バスルーム、キッチン、ダイニングルームなどのラベルがあります。

それは、特定のフロアで、特定の位置を持っています。

不均一な壁は、polygonCorner変数を使用してポリゴンとしてレンダリングできます。

床はスキャン中に長方形として表現され、スキャン終了時に多角形として美化されるようになりました。

食器洗い機、オーブン、シンクの親は現在、レンダリングに刻まれています。

RoomPlanを導入したとき、オブジェクトを記述するためにカテゴリが使用されました。

しかし、この表現には限界がありました。

椅子の例を見てみましょう。 

いくつかの種類の椅子は、スツール、ダイニングチェア、オフィスチェアなど、このカテゴリを表すことができます。

それらはすべて異なる目的を持っています。

オブジェクトをよりよく表現するために、属性を追加しています。

この例では、属性を使用して、スキャンされたものをより忠実に理解しています。

RoomPlan APIでは、属性は列挙型のポリモーフィック配列を介して利用できます。

しかし、列挙型は属性を理解するための最良の方法ではありません。

次のセクションでは、より魅力的な表現に到達するための新しい方法を探ります。

属性は、スキャン中にキャプチャされた他の新しい情報とともに、エクスポートされた結果に含めることができます。

エクスポートできるデータの種類には、USDZノードからメタデータを取り戻すためのファイルと、エクスポートされたUSDZをモデルで充実させる構造という2つの追加があります。

ルームをメッシュとしてエクスポートする場合、サーフェスとオブジェクトのノードツリーを含むUSDZを作成します。

今年は、セクションセンターを含むセクショングループを追加しました。

しかし、そうすると、壁やオブジェクトの寸法だけでなく、オブジェクト属性など、スキャンからかなりの量の情報が欠落しています。

ルームをエクスポートするときにマッピングファイルを作成できるようになりました。

これは、USDZの一意のノード名とその識別子によって一意に識別されるCapturedRoom要素の間のブリッジを作成する、文字列からUUIDへのエンコードされた辞書です。

RoomPlan APIでどのように展開するか見てみましょう。

以前のバージョンのRoomPlanでは、ルームは2つの方法でエクスポートできます。USDZとして、エクスポート機能を介して、およびJSONまたはPlistとして、CapturedRoom構造をエンコードします。

iOS 17の新機能で、エクスポート機能で部屋をUSDZにマップするメタデータURLを指定すると、エクスポートされた2つの情報を関連付けることができます。

このようにして、スキャンした部屋をレンダリングするときに、サーフェスまたはオブジェクトに関する追加情報を照会できます。

新しいマッピングファイルとともに、以前はボックスとして表現されていたオブジェクトを、スキャンされた属性に一致するモデルに置き換えるために、モデルプロバイダーを導入しています。

ここでやりたいことは、オブジェクトを3Dモデル、より具体的にはそのURLに関連付けることです。

このようにして、オブジェクトを表すために使用されるバウンディングボックスを、より説得力のある真実のレンダリングに置き換えることができます。

その目的のために、新しい構造がRoomPlan: ModelProviderで利用可能です。

ModelProviderは、カテゴリと属性のセットをモデルURLにマップします。

カテゴリと属性を持つオブジェクトから、対応するモデルURLを提供するようにModelProviderに依頼することができます。

カテゴリと属性を持つセクション、サーフェス、オブジェクトのコレクションである部屋全体に一般化すると、エクスポート機能で指定されたModelProviderインスタンスは、3DモデルURLを部屋の各オブジェクトに関連付けることができます。

モデルの関連付けを処理する構造ができたら、モデルプロバイダーとどのように連携できるかを見てみましょう。

ModelProviderに入力する方法はたくさんあります。

たとえば、データベースから一連の属性に一致するモデルを取得したり、既存のカタログに注釈を付けたりできます。

ここでは、独自の小さな資産カタログを作成するための非常に簡単な例を紹介します。

4つのステップでカタログを作成して使用します。

まず、RoomPlanがサポートするカテゴリと属性を解析します。

次に、各カテゴリと属性セットのモデルを関連付けます。

その後、ModelProviderをインスタンス化します。

そして最後に、それを使って部屋をエクスポートします。

属性を発見し、いくつかのモデルを使用してモデルプロバイダーを作成する方法を見てみましょう。

まず、RoomPlanがサポートするすべてのカテゴリを反復します。

次に、サポートされている各カテゴリのフォルダを作成します。

後で各フォルダにモデルを追加できます。

次に、カテゴリごとに、RoomPlanでサポートされている属性の組み合わせを要求します。

サポートされている属性のセットごとに、フォルダを作成します。

これらの各フォルダに、カテゴリまたは属性のセットに対応する3Dモデルを追加できます。

カタログの内容の準備が整ったので、インデックスファイルを作成する必要があります。

以下は、カタログインデックスを処理する構造の例です。

要素の配列が含まれており、それぞれにカテゴリまたは属性のセットが含まれています。

各要素には、対応するモデルのパスへの参照があります。

これで、インデックスファイルをplistとして、カタログをバンドルとして保存できます。

モデルで部屋をエクスポートするたびに、またはモデルプロバイダーを使用してオブジェクトをモデルに関連付けるたびに、このカタログバンドルを使用してModelProviderを生成できるようになりました。

私たちがしなければならないのは、カタログのカテゴリと属性を反復したり、対応するモデルURLを見つけたり、属性がない場合はモデルURLをカテゴリに関連付けたり、モデルURLを属性セットに関連付けたりすることだけです。

最後のステップは、エクスポート関数を呼び出して、出力URL、モデルプロバイダーインスタンス、および.modelオプションを指定することです。

出来上がり！私たちが得るのは、あなたのスキャンに対応する3Dモデルを備えたUSDZです。

さらに進むために、オプションでUSDZをBlenderのようなDCCツールに取り込んで、光と影を追加して、数分でさらに現実的な結果を得ることができます。

説得力のある結果を生み出すために、サンプルコードに事前に入力されたカタログを追加しました。

戻るよ、アレックス!

アレックス:ありがとう、アントワーヌ。

今日共有したものを見てみましょう。そして、私たちが共有したものを見てみましょう。

まず、カスタムARSessionサポートは、不動産リストを改善するためにスキャンと一緒に高品質の画像やビデオをキャプチャするなどの新しいユースケースを可能にします。

これで、複数の部屋をスキャンし、新しいStructureBuilder APIを使用して、家全体のマージされた3Dモデルを生成することもできます。

ロービジョンユーザーのスキャン体験を向上させるために、RoomPlanはRoomCaptureViewを使用する際にVoiceOverをサポートするようになりました。

RoomPlanの新しいオブジェクト属性を使用すると、スキャンした部屋をより正確に表現できます。

そして最後に、新しいエクスポートAPIを使用して、カスタムカタログから対応するスキャンされたオブジェクトに3Dモデルを割り当てることができます。

それがiOS 17のRoomPlanです。

私たちはあなたがそれで何を作るかを見るのが待ちきれません。