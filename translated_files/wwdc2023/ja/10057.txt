10057

♪ ♪

タイラー：「UIKit特性システムを解き放つ」へようこそ。

私はUIフレームワークエンジニアのタイラー・フォックスです。iOS 17で活用できる素晴らしい新しいUIKit機能についてお伝えできることを嬉しく思います。

まず、UIKitの特性システムに関する基礎を確認します。

次に、UITraitCollectionに独自のデータを追加するためのカスタム特性を定義する機能、アプリの階層に特性オーバーライドを適用する簡単な方法、特性が変更されたときに処理するより柔軟な方法など、新しい機能と機能をご案内します。

最後に、UIKitの特性とSwiftUI環境キーをブリッジして、アプリ内のUIKitとSwiftUIコンポーネント間でデータをシームレスに渡す方法を説明します。

いくつかのファンダメンタルズを見直す時が来ました。

特性は、システムがアプリ内のすべてのビューコントローラーとビューに自動的に伝播する独立したデータです。

UIKitは、ユーザーインターフェイススタイル、水平サイズクラス、優先コンテンツサイズカテゴリなど、多くの組み込みシステム特性を提供します。

iOS 17では、独自のカスタム特性も定義できます。

これにより、アプリのビューコントローラーとビューにデータを提供する強力な新しい方法が解放されます。

カスタム特性については、少し後でお話しします。

UIKitで特性を扱う主な方法は、特性コレクションを使用することです。

トレイトコレクションには、トレイトとその関連値が含まれています。

iOS 17には、トレイトコレクションの操作を容易にする新しいAPIがいくつかあります。

まず、クロージャを取る新しい初期化子があります。

そのクロージャの中で、値を設定できる変更可能な特性コンテナを受け取ります。

この可変コンテナは、UIMutableTraitsという名前の新しいプロトコルに準拠しています。

クロージャの中で、ユーザーインターフェイスのイディオムを電話に設定し、水平サイズクラスをレギュラーに設定しました。

クロージャの実行が終了すると、初期化子は、クロージャ内で設定したすべてのトレイト値を含む不変のUITraitCollectionインスタンスを返します。

また、クロージャ内の元のトレイトコレクションから値を変更して新しいインスタンスを作成できる新しいmodifytTraitsメソッドもあります。

ここでは、水平サイズクラスをコンパクトに変更し、ユーザーインターフェイススタイルの暗い値を入力しました。

私はユーザーインターフェイスのイディオムを変更していないので、それは私の元の特性コレクションから電話と等しいままです。

このような独自のトレイトコレクションを作成できますが、ほとんどの場合、トレイト環境からトレイトコレクションを取得します。

アプリの特性環境は、ウィンドウシーン、ウィンドウ、プレゼンテーションコントローラー、ビューコントローラー、ビューです。

これらの特性環境にはそれぞれ独自の特性コレクションがあり、各特性コレクションには異なる値が含まれている場合があります。

特性環境は、特性階層に接続されています。これは、特性がアプリを流れる方法です。

以下は、各ウィンドウシーンから個々のビューコントローラーとビューまで、トレイト階層のツリー構造の例です。

各トレイト環境は、親環境からトレイト値を継承します。

可能な限り最も具体的な特性環境の特性コレクションを常に使用してください。

特性がビューコントローラーとビューを流れる方法をより深く掘り下げます。

以下は、子ビューコントローラーを含む親ビューコントローラーの例です。

破線はビューコントローラーの階層を表します。

親コントローラはビューを所有し、それらを接続する実線はそれらの関係を表します。

親ビューには1つのサブビューがあり、ビューを通る破線はビュー階層を表します。

最後に、子コントローラのビューは、その中間ビューのサブビューです。

まず、iOS 17より前に、ビューコントローラーとビューで特性がどのように流れていたかを説明します。

ビューコントローラーは、親のビューコントローラーから直接特性を継承しました。

そして、ビューコントローラーが所有するビューは、ビューコントローラーから直接特性を継承しました。

最後に、ビューコントローラーのないビューは、スーパービューから直接特性を継承しました。

この動作は、ビュー階層内の特性の流れが、ビューコントローラーが所有する各ビューで停止することを意味します。

たとえば、親コントローラのビューからのトレイト値は、その直接サブビューによってのみ継承されます。

子コントローラのビューは、それらのビューの下のビュー階層のサブビューであるにもかかわらず、その値を受け取りません。

この行動は驚くべきことかもしれません。

iOS 17では、ビューコントローラーとビューの特性階層を統一することで、この問題を排除しました。

ビューコントローラーは、親ビューコントローラーから直接ではなく、ビューのスーパービューからトレイトコレクションを継承するようになりました。

これにより、ビューコントローラーとビューを介して特性の単純な線形フローが作成されます。

ビューコントローラーがまだ親ビューコントローラーから特性を継承する方法に注意してください、それはそれらの間のビューを介して間接的に起こります。

ビューコントローラーはビュー階層から特性を継承するようになったため、ビューコントローラーが更新された特性を受け取るには、ビューコントローラーのビューが階層にある必要があります。

その結果、ビューが階層に追加される前にビューコントローラーのトレイトコレクションにアクセスすると、ビューコントローラーはそのトレイトの最新の値を持ちません。

影響を受けるコードを見つける最も一般的な場所は、ビューが階層に追加される前に常に呼び出されるため、viewWillAppear内です。

代わりに使用できるviewIsAppearingという名前の新しいコールバックがあります。

viewIsAppearingは、ビューが階層に追加され、ビューコントローラーとビューの両方が最新のトレイトコレクションを持つと、viewWillAppearの後に呼び出されます。

viewIsAppearingは、今日viewWillAppearを使用しているほぼすべてのケースのドロップイン代替品です。

そして、最良の部分は、この新しい方法がiOS 13に展開されることです。

「UIKitの新機能」を見て、この新しいコールバックとそれがビューコントローラーのライフサイクルにどのように適合するかについて詳しく学んでください。

iOS 17は、ビュー特性の更新の一貫性とパフォーマンスも向上させます。

ビューは、階層内にある場合にのみ、特性コレクションを更新します。

そして、階層に入ると、各ビューはレイアウトを実行する直前にトレイトコレクションを更新するだけです。

ベストプラクティスは、レイアウト中に特性を使用することです。

ビューの場合、それはlayoutSubviewsメソッド内からtraitCollectionを使用することを意味します。

layoutSubviewsは、setNeedsLayoutがビューで呼び出されるたびに再び実行されるので、実装は複数回呼び出された場合、作業の重複を避ける必要があります。

カスタム特性は、iOS 17の強力な新機能です。

彼らは、あなたのビューコントローラーとビューにデータを提供するための全く新しい方法を開きます。

アプリでデータを扱う際には、新しいカスタム特性を定義するタイミングを決定するのに役立つ次の点を考慮してください。

特性は、親ビューコントローラーから複数の子ビューコントローラー、またはスーパービューからすべてのサブビューなど、多くの子にデータを伝播する必要がある場合に最適です。

また、特性を使用して、多くのレイヤーに深くネストされている可能性のある他のコンポーネントにデータを渡すこともできます。

特性は階層を通じて継承されるため、含まれているビューコントローラーに関する情報を提供するなど、環境に関するビューやビューコントローラーにコンテキストを提供できます。

特性システムは強力ですが、それを使用してデータを伝播することは自由ではありません。

最高のパフォーマンスを得るには、価値を追加するときに特性を使用しますが、データを直接簡単に渡すことができる場合は特性を使用しないでください。

これで、最初のカスタム特性を定義する準備が整いました。

アプリに設定画面があり、ビューが設定ビューコントローラーに含まれているかどうかを示す特性を実装したいと想像してみてください。

ほんの数行のコードでカスタムトレイトを定義できます。

まず、新しい構造体を宣言し、UITraitDefinitionプロトコルに準拠します。

必要な静的プロパティであるdefaultValueを実装します。

これは、値が設定されていない場合のトレイのデフォルト値です。

各トレイト定義には、defaultValueから推測される関連する値タイプがあります。

この場合、falseのdefaultValueを割り当てているので、この特性の値のタイプはBoolであると推測されます。

以前にSwiftUIでカスタム環境キーを定義したことがあるなら、これは非常に身近に感じるはずです。

トレイトを定義したら、UITraitCollectionとUIMutableTraitsの新しいAPIですぐに使用できます。

この特性は、値を取得して設定するために使用するキーと考えることができます。

新しいUITraitCollectionイニシャライザ内では、UIMutableTraitsの添字演算子を使用して、トレイトの値を設定できます。

そして、UITraitCollectionの添字演算子を使用して、特性の値を読み戻すことができます。

2つの簡単な拡張機能を追加すると、すべてのシステム特性と同様に、標準のプロパティ構文を使用してこの特性にアクセスできます。

ここでは、不変のUITraitCollectionクラスの拡張で読み取り専用プロパティを宣言しました。

そして、UIMutableTraitsプロトコルの拡張で読み取り/書き込みプロパティを宣言しました。

これらの非常にシンプルな拡張機能を追加したので、標準のプロパティ構文を使用して、どこでも自分の特性にアクセスできます。

独自のカスタム特性を定義するときは、常にこれらの拡張機能を書いてください。

私は別のカスタム特性のアイデアを持っています。

私のアプリでカスタムカラーテーマのサポートを構築していると想像してみてください。

私のアプリがサポートする4つの異なるカラーテーマを表すMyAppThemeという名前の列挙型があります。

私が最初に行うことは、UITraitDefinitionプロトコルに準拠した新しい構造体を宣言することです。

この特性のデフォルト値として標準テーマを使用します。

この新しいテーマ特性をアプリのカスタムダイナミックカラーで使用する予定なので、この特性が色の外観に影響し、この特性が変更されるとシステムが自動的にビューを再描画することを示しています。

色の外観に影響を与える特性ははるかに高価であるため、これを控えめに、まれに変化する特性にのみ使用してください。

トレイトには、デバッガにトレイトを印刷するなどに使用される名前もあります。

デフォルトでは、特性タイプ自体の名前を使用しますが、「テーマ」のような短い名前を付けることができます。そして最後に、識別子文字列を提供できます。

この識別子により、特性はエンコーディングなどの追加機能の対象となります。

リバースDNS形式を使用して、各特性の識別子がアプリでグローバルに一意であることを確認します。

通常のプロパティ構文を使用してこの特性を設定して取得できるようにしたいので、前の例と同じように、UITraitCollectionとUIMutableTraitsを拡張してプロパティを宣言します。

そして、カスタムテーマ特性を実装するために必要なのはそれだけです。

今、私はこの新しい特性を使い始めることができます。

たとえば、テーマに基づいて外観を変更するカスタムダイナミックカラーを定義する方法は次のとおりです。

動的プロバイダー初期化子を使用して新しいUIColorを作成します。

クロージャの中では、どの色を返すかを決定するために渡される特性コレクションのテーマを使用します。

これで、このカスタム背景色をビューに設定できます。

この特性は、定義したときに色の外観に影響することを示したため、このカスタム背景色を使用するビューは、テーマが変更されると自動的に更新されます。

特性を定義するとき、考慮すべき最も重要なことは、特性の値の関連データ型です。

最良の特性は、単純な構造体や列挙型など、価値タイプを中心に構築されています。

Swiftのクラスに基づく特性は避けてください。

特性の最も効率的なデータ型は、Bool、Int、Double、またはIntの生値を使用する列挙型です。

列挙型は、特性に最も有用なデータ型の1つです。

最大限の効率を得るには、列挙型の生データ型としてIntを明示的に指定してください。

特性値として使用するカスタム構造体データ型には、Equatableプロトコルの効率的な実装が必要です。

システムは、特性値がいつ変化したかを判断するために特性値を頻繁に比較するので、あなたの等しい機能はできるだけ速くする必要があります。

Objective-Cを使用するアプリを使用している人のために、新しい特性システム機能もそこで利用可能です。

カスタム特性のAPIは、SwiftとObjective-Cで異なります。

ただし、Swiftで1つのカスタムトレイトを定義し、Objective-Cで1つのカスタムトレイトを定義し、両方とも同じ基礎データを指すことができます。

詳細と特別な考慮事項については、ドキュメントを参照してください。

カスタムトレイトを定義したら、次のステップは、アプリのトレイト階層にデータを入力することです。

トレイトオーバーライドは、トレイト階層内のデータを変更するために使用するメカニズムです。

iOS 17では、特性オーバーライドを適用することがこれまで以上に簡単になりました。

ウィンドウシーン、ウィンドウ、ビュー、ビューコントローラー、プレゼンテーションコントローラーなど、各トレイト環境クラスに新しい traitOverridesプロパティがあります。

トレイト階層の図に戻ると、トレイトオーバーライドは、このツリー内の任意の場所でトレイトの値を変更します。

この階層内のトレイト環境の1つにトレイトオーバーライドを適用すると、そのオブジェクトとそのすべての子孫のトレイトコレクション内のそのトレイトの値が変更されます。

トレイト階層から親子トレイト環境を取ると、トレイトオーバーライドが両方にどのように影響するかを次に示します。

親に適用される特性上書きは、親自身の特性コレクションに影響します。

そして、親の特性コレクションの値は子に継承されます。

最後に、子の特性オーバーライドは、継承した値に適用され、独自の特性コレクションを生成します。

特性オーバーライドをオプションの入力として、特性コレクションを出力として考えてください。

オーバーライドのない特性は、親から継承されます。

トレイトオーバーライドを使用して、アプリの特定の部分のカラーテーマを変更する例を見ていきます。

右側には、私のアプリの特性階層のイラストがあります。

当初、テーマトレイトの値を入力するためにオーバーライドを適用していないため、これらのトレイトコレクションはすべて、標準テーマであるデフォルト値を持っています。

まず、ウィンドウシーンのこの階層のルートにトレイトオーバーライドを適用します。

traitOverridesプロパティは、UIMutableTraitsプロトコルを活用して、トレイト値を簡単に設定できます。

したがって、先ほど説明したUIMutableTraitsの拡張機能を使用して、標準プロパティ構文でカスタム特性のオーバーライド値を設定できます。

ウィンドウシーンのトレイトオーバーライドでテーマをパステルに設定すると、そのウィンドウシーン内のすべてのウィンドウ、ビュー、ビューが、トレイトコレクションのパステル値を継承するようになりました。

したがって、階層のルートにある1か所にテーマを設定することで、その階層内のすべてに伝播される基本値を変更しました。

たとえば、そのウィンドウシーン内のビューコントローラーのトレイトコレクションからテーマを読み、パステルを取り戻すことができます。

次に、階層の奥深くにあるビューで traitOverrides プロパティを使用して、そのビューとその下のテーマを変更できます。

ここでは、このビューのモノクロテーマトレイトオーバーライドを設定しています。

したがって、このモノクロ値は、そのサブビューによって継承されるものであり、階層の上位からパステル値を上書きします。

トレイトオーバーライドの変更は、トレイトコレクションにすぐに反映されない場合があります。

たとえば、ビューはレイアウトの直前にトレイトコレクションを更新するため、ビューのトレイトオーバーライドへの変更は、layoutSubviewsを実行する直前までトレイトコレクションに反映されません。

traitOverridesプロパティでは、オーバーライドが適用されているかどうかを確認し、オーバーライドを完全に削除することもできます。

以下は、オーバーライドが存在するかどうかを確認するためにcontainsメソッドと、オーバーライドを完全に削除する removeメソッドを使用してオーバーライドを切り替える例です。

このメソッドが呼び出されるたびに、既存のオーバーライドを削除するか、まだテーマオーバーライドがなかったときに新しいテーマオーバーライドを適用します。

特性オーバーライドは、値を設定するための入力メカニズムです。

Trait 値を読み取るには、常に traitCollection プロパティを使用します。

オーバーライドが設定されていないときにtraitOverridesから読み取ると、例外が発生します。

トレイトオーバーライドを使用する際に留意すべきパフォーマンスの考慮事項をいくつか紹介します。

まず、各トレイトオーバーライドはコストが小さいため、必要な場所にトレイトオーバーライドのみを設定し、使用されていないトレイトオーバーライドの設定を避けてください。

そして、トレイトオーバーライドを変更するたびに、システムは階層内の子孫のトレイトコレクションを更新する必要があります。

したがって、特性オーバーライドを変更する回数を最小限に抑えます。

最後に、ウィンドウシーンやウィンドウなど、階層のルートの近くに適用される特性オーバーライドは、その下のすべてに影響します。

これは非常に便利で、ウィンドウシーンやウィンドウに特性オーバーライドを適用するための多くの素晴らしいユースケースがあります。

ただし、トレイトが階層の奥深くにある少数のビューにしか影響しない場合は、代わりに、共通のスーパービューやビューコントローラーなど、それらのビューの最も近い共通の祖先にトレイトオーバーライドを適用します。

そうすれば、階層のごく一部だけがそのデータを使用しているときに、階層全体に特性を伝播するコストを支払うことはありません。

特性を定義し、階層にデータを入力する方法がわかったので、値が変更されたときに処理する必要があります。

traitCollectionDidChangeはiOS 17では非推奨です。

traitCollectionDidChangeを実装すると、システムは実際にどの特性を気にしているかを知らないため、特性が値を変更するたびにそのメソッドを呼び出す必要があります。

しかし、ほとんどのクラスはほんの一握りの特性しか使用せず、他の変化を気にしません。

これが、より多くのカスタム特性を追加するにつれて、traitantCollectionDidChangeが拡張されない理由です。

その代わりに、より柔軟でパフォーマンスを向上させる新しい特性登録APIがあります。

特定の特性への変更を登録することで、システムはあなたが依存している特性を正確に把握します。

新しいAPIを使用すると、ターゲットアクションパターンまたはクロージャを使用してコールバックを受信できます。

また、サブクラスのメソッドをオーバーライドする必要がなくなったため、どこからでも特性の変化を簡単に観察できるようになりました。

まず、t traitCollectionDidChange の既存の実装を更新する方法を説明します。

これが私の既存の実装です。

そのメソッドはこの1つのトレイトにのみ依存しているため、updateViewsを呼び出す前にhorizontalSizeClassトレイトが変更されたかどうかを確認する方法に注意してください。

アプリを古いiOSバージョンにデプロイしているため、traitCollectionDidChangeを使用し続ける必要がある場合は、実装が気になる特定の特性が変更されたかどうかをチェックしていることを確認してください。

次に、この実装をiOS 17の新しい特性登録方法に置き換えます。

クロージャベースの方法から始めます。

registerForTraitChangesを呼び出し、登録する特性の配列を渡します。

水平サイズクラス用のこのような、すべてのシステム特性に新しいUITraitシンボルがあります。

次に、それらの特定の特性が変化したときに呼び出されるクロージャを渡します。

クロージャは、他の特性への変更が求められていないため、ここで古い特性値と新しい特性値を比較する必要はありません。

特性が変更されたオブジェクトは、クロージャの最初のパラメータとして渡されます。

このパラメータを使用すると、そのオブジェクトへの弱い参照をキャプチャする必要はありません。

自己の特性変更を登録するときは、常にここに「自己：自己」と書いてください。

また、異なる特性環境の特性の変化を観察することもできます。

ここでは、以前に定義した水平サイズクラスとContainedInSettingsカスタムトレイトという2つの特性の変更を登録しています。

クロージャは、これらの特性のいずれかがこの他のビューで変化したときに実行されます。

クロージャの最初のパラメータとして、登録しているビューのタイプを書きます。

これは、新しいターゲットアクションベースのメソッドの例です。

registerForTraitChangesを呼び出し、登録する特性の配列と、変更を呼び出すターゲットとアクションメソッドを渡します。

ターゲットパラメータはオプションです。

省略すると、ターゲットはregisterForTraitChangesが呼び出されるのと同じオブジェクトになります。

この場合、それは自己です。

クロージャ方法と同様に、他のトレイト環境の変更を登録することもできます。

ここでは、別のビューで特性の変更を登録していますが、selfnamed handleTraitChangeのメソッドの呼び出しを設定しています。

ターゲットアクションを使用して特性変更を登録する場合、アクションメソッドは0、1、または2つのパラメータを持つことができます。

最初のパラメータは、常に特性が変化しているオブジェクトです。

このパラメータを使用して、新しいtraitCollectionを取得します。

2番目のパラメータは、変更前のオブジェクトの以前のトレイトコレクションです。

個々の特性の登録に加えて、システム特性の新しいセマンティックセットを使用して登録することもできます。

たとえば、systemTraitsAffectingColorAppearanceがあり、システムの動的色の解決方法に影響を与える可能性のあるシステム特性を返します。

また、UIImage(named:)を使用して画像をロードするときに考慮されるシステム特性のサブセットを返すsystemTraitsAffectingImageLookupもあります。

これらのセットのいずれかをregisterForTraitChangesに直接渡して、カスタム無効化を実行します。

新しい方法を使用して特性変更を登録すると、登録は自動的にクリーンアップされます。

高度なユースケースがある場合は、各登録方法によって返されるトークンを使用して手動で登録を解除できます。

しかし、これらのケースは非常にまれであるため、通常、registerForTraitChangesを呼び出すときに戻り値を無視する必要があります。

新しい特性登録APIを採用する際に、覚えておくべき2つのベストプラクティスがあります。

まず、無関係な特性が価値を変えたときに作業を実行しないように、実際に依存している特性のみを登録します。

最後に、すぐに更新せずに、特性の変更に応じて無効にしてみてください。

たとえば、ビューサブクラスのlayoutSubviewsメソッド内でトレイトを使用する場合は、setNeedsLayoutを呼び出してトレイトの変更を無効にします。

これは、レイアウトサブビューを受信するようにビューをスケジュールしますが、すぐに更新を実行しません。

UIKitのトレイトシステムを使用して独自のデータを伝播できるようになったので、アプリ内のUIKitとSwiftUIコンポーネント間でデータをシームレスに渡すためのまったく新しい方法のロックを解除します。

UIKitのカスタム特性は、SwiftUIのカスタム環境キーと非常によく似ています。

それらをブリッジして、UIKitとSwiftUIの両方から同じデータにアクセスできます。

UIKit内にSwiftUIコンポーネントを埋め込む場合でも、SwiftUI内にUIKitコンポーネントを埋め込む場合でも、ブリッジデータはそれらの間でシームレスに通過します。

UIKitコードのトレイトAPIとSwiftUIコードの環境APIを使用して、同じ基礎となるデータを読み書きできます。

アプリのUIKitコード用に定義した新しいカラーテーマの特性を、SwiftUIの対応する環境キーにブリッジするのは信じられないほど簡単です。

UIKitにカスタムトレイトがあり、同じデータを表すSwiftUIにカスタム環境キーがあると仮定すると、それらをブリッジするために必要なのは、UITraitBridgedEnvironmentKeyプロトコルへの適合性を追加することだけです。

これを行うには、UIKitからトレイトを読み取り、値をSwiftUIに返す1つのメソッドと、UIKitトレイトにSwiftUI環境値を書き込む1つのメソッドを実装します。

そして今、UIKit特性とSwiftUI環境キーの両方が統合ストレージにアクセスするので、どちらかのフレームワークを使用して書かれたコンポーネントから同じデータを読み書きすることができます。

ブリッジされた特性と環境キーを使用する方法の例を次に示します。

アプリのルートでは、UIKitウィンドウシーンにテーマトレイトのトレイトオーバーライドを適用します。

これは、そのウィンドウシーンに含まれるすべてのものにモノクロのテーマ値を伝播します。

次に、そのウィンドウシーンのウィンドウの奥深くに、UIKitコレクションビューがあります。

このコレクションビューには、各セルにSwiftUIビューを表示するようにUIHostingConfigurationを使用して設定されたセルが含まれています。

SwiftUI CellViewの内部には、Environmentプロパティラッパーを使用してSwiftUI環境から値を読み取ります「theme」という名前のプロパティがあります。

環境の値は、UIKitのブリッジされた特性の同じ値に対応します。

そして最後に、テーマプロパティを使用して、このSwiftUIビュー内のテキストの色を制御します。

SwiftUIは自動的にデータの依存関係を追跡するため、UIKitウィンドウシーンでテーマトレイトが上書きされ、別の値に変更されると、SwiftUIセルビューは自動的に更新され、新しいテーマが反映されます。

ブリッジングは別の方向でも機能します。

ここには、アプリの設定を表示するSwiftUIビューがあります。

環境修飾子を使用して標準テーマを設定し、設定コントローラーのすべてに適用されます。

これは概念的には、UIKitで特性オーバーライドを適用することと同等です。

次に、UIViewControllerRepresentableに含まれるUIKitベースの設定ビューコントローラーで、ブリッジされたトレイトからテーマ値を読み取り、それを使用してこのビューコントローラーに表示されるタイトルを更新します。

これは、ブリッジされたUIKit特性とSwiftUI環境キーを使用して、データにシームレスにアクセスするのがいかに簡単かです。

これらの強力な新機能について学んだので、アプリ内で特性システムを活用して、独自のカスタム特性を定義することでデータを自動的に伝播できる場所を見つけてください。

次に、新しい traitOverrides プロパティを採用して、トレイト階層のデータを簡単に変更します。

そして、より柔軟な特性登録APIを使用して、使用する正確な特性に正確な依存関係を作成します。

最後に、カスタムUIKit特性とカスタムSwiftUI環境キーをブリッジし、アプリ内のUIKitとSwiftUIコンポーネント間でデータがシームレスに流れるようにします。

今、特性の力を解き放つのはあなた次第です。

見てくれてありがとう。

♪ ♪