10127

♪ ♪

みなさん、こんにちは。私はガウリ・ジョグで、ここアップルのメタルエコシステムチームで働いています。

Metalを使用したGPUレンダラーの最適化についてお話しできることを嬉しく思います。

最新のデジタルコンテンツ作成アプリケーションとゲームエンジンにより、コンテンツクリエイターは3Dアセットのマテリアルをインタラクティブに作成および変更できます。

実行時にこれらの複雑で動的な材料を処理するための一般的なテクニックがいくつかあります。

個々のシェーダーにマテリアルをコンパイルするアプリケーションもあれば、uberシェーダーやシェーダー仮想マシンなどのデータ駆動型ソリューションを使用するアプリケーションもあります。

これらの材料中心のワークフローには、2つの主なパフォーマンス目標があります。

資料のオーサリングは、高速な反復と最高の経験のために応答する必要があります。

レンダリングパフォーマンスは、リアルタイムのインタラクティブ性と効率的な最終フレームレンダリングのために、可能な限り良好である必要があります。

Blender 3Dのこのデモンストレーションでは、マテリアル編集はレスポンシブです。

ユーザーインターフェイスでマテリアルスライダーを変更すると、シェーダーの再コンパイルによるスタッターなしで、結果がビューポートに即座に表示されます。

素材が変更されると、結果のレンダリングパフォーマンスは高速でインタラクティブになり、コンテンツ作成者は作業結果を効率的に表示できます。

アプリケーションでレスポンシブでパフォーマンスの高いワークフローを実現するには、主要なMetal機能を活用し、Metalのベストプラクティスを実装できます。

Metalは、複雑なシェーダーのパフォーマンスを最大化し、非同期コンパイルを活用してアプリケーションの応答性を維持し、動的リンクでより速くコンパイルし、新しいMetalコンパイラオプションでコンピューティングシェーダーを調整するのに役立ちます。

シェーダーを最適化することがパフォーマンスの鍵です。

Uberシェーダーは、あらゆる可能な素材をレンダリングするために使用できる長くて複雑なシェーダーの例です。

これらのタイプのシェーダーは、あらゆる可能な組み合わせのための多くの枝を持っています。

アーティストがマテリアルを作成すると、マテリアルパラメータはマテリアルシェーダーで使用されるメタルバッファに保存されます。

このバッファはパラメータを変更すると更新されますが、再コンパイルは必要ありません。

このアプローチは、優れたレスポンシブオーサリング体験を提供します。

ただし、uberシェーダーは、すべての可能なオプションを考慮する必要があるため、最適ではありません。

最も最適なシェーダーバリアントを作成するには、関数定数を持つ金属特殊化を使用する必要があります。

メタルシェーダーで関数定数を宣言し、変更時に実行時に値を設定するだけです。

マテリアルバッファの内容は、シェーダーパイプライン状態では単に定数になり、動的分岐は排除されます。

特殊な材料はあなたに最高のパフォーマンスを与えます。

これは、Blender 3D、Wanderer、Tree Creatureの2つの一般的なテストアセットからのリアルタイムパフォーマンスデータの比較です。

1つ目は、ウーバーシェーダーを使用したシーンのフレーム/秒のベースラインパフォーマンスです。

2つ目は、はるかに高速に実行する関数定数を備えた特殊なシェーダーアプローチです。

最速の特殊なシェーダーバリアントを作成するには、関数定数を使用して未使用の機能を無効にし、分岐を排除します。

Uberシェーダーは、実行時に条件付きブランチを実行するバッファからマテリアルパラメータを照会し、機能を有効または無効にします。

関数定数では、材料フィーチャごとに1つの定数を宣言します。

これで、機能コードパスの動的ブランチが関数定数に置き換えられ、未使用のコードがすべて排除されます。

これは、関数定数を使用しているのと同じuberシェーダーです。

メタルコンパイラは、これらを一定のブール値として折りたたんで、未使用のコードを削除することができます。

Falseに解決するブランチ式は最適化され、真のブランチのみが残ります。

未使用の制御フローはすべて最適化されています。

特殊なシェーダーは、材料データを照会する必要が不要になり、制御フローがはるかにシンプルになりました。

メモリの負荷とブランチが削除され、ランタイムのパフォーマンスが向上しました。

機能の特殊化は、定数の折り畳みにも役立ちます。

変化しない材料パラメータは定数に置き換えられます。

このサンプルマテリアルは、メタルバッファからの入力パラメータのコレクションを使用します。

パラメータは、色、重量、光沢色などである可能性があります。

材料作成時に、これらの静的パラメータは関数定数に置き換えることができます。

関数定数は、バッファ読み取りを必要とせず、最も最適なコードを生成します。

ホスト側では、特殊なパイプライン状態を作成するときに関数定数値が提供されます。

MaterialParameter構造は、材料に対して一定であるすべてのパラメータを表すために使用できます。

IsGlossyは、光沢を制御するブール材料機能フラグの例です。

MaterialColorは、色を記述するために使用されるベクトルパラメータの例です。

特殊なパイプライン状態オブジェクトを作成するには、MetalFunctionConstantValuesセットを反復し、setConstantValueを使用して値を挿入します。

次に、通常どおりレンダリングパイプラインを作成します。

唯一の違いは、フラグメント関数を作成するときに、constantValuesでnewFunctionWithNameのバリアントを使用することです。

最後に、パイプライン状態オブジェクトを作成します。

結果として得られるシェーダーは、この材料の最も最適なパフォーマンスバリアントです。

関数定数を使用することの影響を確認するには、常にXcodeのGPUデバッガパフォーマンスセクションを使用してください。

オリジナルのウーバーシェーダーは、多数のALU命令と大量の流出を示しています。

メモリの待ち時間も多いです。

専門的なアプローチは、ALUと流出を即座に救済します。

これは、デッドコードの消去と定数の折り畳みによるものです。

また、メモリの待ち時間の数は大幅に少なくなっています。

ランタイムシェーダーの実行コストで元のuberシェーダーを観察し、GPUはメモリ待機にかなりの時間を費やしています。

対照的に、専門的なアプローチは、メモリ待機に費やす時間がはるかに少なく、他の効率の利点とともに、より生産的なALU利用を可能にします。

GPUデバッガのタイムラインビューでは、uberシェーダーを使用してマテリアルパスをレンダリングするのに58ミリ秒かかります。

そして、特殊なバージョンでレンダリングするのにわずか12.5ミリ秒です。

それはかなり劇的な改善です。

材料の特殊化にはランタイムシェーダーのコンパイルが必要であり、これらの特殊な材料が作成されるのをブロックして待つと、ヒッチハイチになることがよくあります。

Metal非同期コンパイルAPIを使用すると、汎用のuberシェーダーを使用し、バックグラウンドで特殊なバージョンを生成しながら、ユーザーエクスペリエンスをインタラクティブで応答性に保つことができます。

非同期パイプライン状態の作成をオプトインするには、完了ハンドラを提供します。

これらの通話はすぐに返され、ユーザーエクスペリエンスをインタラクティブで応答性に保つことができます。

特殊なパイプライン状態の準備ができたら、完了ハンドラが呼び出され、すぐに最適なシェーダーに切り替えることができます。

これは非同期材料ワークフローの図です。

デフォルトでは、素材がまだ特化したものではない場合は、uberシェーダーを使用します。

同時に、Metalは特殊なシェーダーをバックグラウンドでコンパイルします。

これが完了したら、ユーバーシェーダーを高速特殊材料に切り替えることができます。

ランタイムメタルシェーダーのコンパイルは、バランスのとれたレベルの並列性を提供するように設計されています。

しかし、現代のコンテンツ作成アプリケーションは、マルチマテリアル編集ワークフローを提供する必要があり、その結果、多くのシェーダーの再コンパイルが発生します。

このような重いオーサリングのニーズを支援するために、メタルにシェーダーコンパイルの並列性を最大化するように依頼することをお勧めします。

Metalデバイスには、macOS13.3にshould-Maximize-Concurrent-Compilationという新しいプロパティがあります。

「はい」に設定すると、MetalコンパイラはCPUコアを最大限に活用します。

同時コンパイルを最大化することは、マルチマテリアルオーサリングワークフローにとって本当に素晴らしいです。

追加のコンパイラジョブが利用可能になると、特殊なマテリアルバリアントがはるかに早く利用可能になります。

これがすべて実際にどのように機能するかです。

材料パラメータが変更されると、材料の現在の特殊なバリアントが無効になり、オーサリング流体を維持するためにuberシェーダーを使用するためのスイッチがあります。

新しい非同期ジョブがキューに入れられ、完了すると、特殊な資料が従事すると、大幅なパフォーマンスの向上を観察できます。

ほとんどの最新のアプリは非常に複雑な素材を持っているので、特殊なバリアントが準備されるのにかなりの時間がかかることがあります。

Metalの動的ライブラリは、ユーティリティ関数を事前にコンパイルし、全体的な材料のコンパイル時間を短縮するために使用できます。

これを行うには、機能のグループを別々の動的ライブラリに分割します。

ランタイムコンパイルをさらに高速化するために、ユーティリティライブラリをオフラインでプリコンパイルできます。

そして、実行時にはるかに少ないコードをコンパイルすることになります。

もし私が以前のウーバーシェーダーを取り、それをディリブに分割するなら。

1つのアプローチは、共通の機能グループによってそれを分割することです。

この場合、1つの数学ユーティリティライブラリと照明機能用のもう1つ。

リンク用に関数記号を表示させるには、「デフォルト」の可視性を割り当てます。

シンボルは、可視性を「非表示」に割り当てることで、外部プログラムから非表示にすることもできます。

Metalデバイスが動的ライブラリをサポートしているかどうかを確認するための2つのプロパティがあります。

レンダリングパイプラインの場合は、MetalデバイスのsupportsRenderDynamicLibrariesプロパティを使用する必要があります。

これは現在、Apple6以上のGPUファミリを搭載したデバイスで利用可能です。

コンピューティングパイプラインの場合は、supportsDynamicLibrariesプロパティを照会する必要があります。

これは、Apple6以上およびほとんどのMac2 GPUファミリで利用できます。

既存のMetalライブラリから動的ライブラリを作成するには、newDynamicLibraryを呼び出してMetalライブラリに渡すだけです。

URLから作成するには、newDynamicLibraryWithURLメソッドを呼び出して、保存された動的ライブラリへのパスを指定します。

メタルコンパイラツールチェーンを使用して、動的ライブラリをオフラインで事前コンパイルできます。

実行時にプリコンパイルされた動的ライブラリをロードすると、コンパイルは完全に回避されます。

リンクフェーズでdylibsを指定するには、パイプライン記述子のpreloadedLibrariesパラメータにMetal Dynamic Libraryオブジェクトの配列を渡します。

他のシェーダーライブラリをコンパイルするときに、メタルコンパイルオプションを介してこの動的ライブラリの配列を提供するオプションもあります。

ユーティリティコードの大部分を動的ライブラリに移動すると、ランタイムコンパイルが大幅に短縮されます。

そして最後に、コンパイラオプションのチューニングは、最終的な生産品質レンダリングにおけるパストレースのような計算ケースにとって本当に重要です。

そして、最終的なレンダリングから最大限のパフォーマンスを引き出すための追加のメタル機能が1つあります。

メタルコンパイラのオプションと占有ヒントにより、ダイナミックリンクで作業するときに、特にこれらのコンピューティングカーネルのパフォーマンスを調整できます。

すべてのGPUワークロードには、分析と評価が必要なパフォーマンススイートスポットがあります。

希望するGPU占有率をターゲットとするMetal APIがあり、現在は動的ライブラリでも利用可能です。

これにより、元のコードやアルゴリズムを変更することなく、既存のワークロードのパフォーマンスをアンロックできます。

パフォーマンス特性はGPUアーキテクチャによって異なる可能性があるため、デバイスごとにチューニングを実行する必要があることは注目に値します。

Metal compute pipeline descriptorプロパティを使用すると、Max-Total-Threads-Per-Threadgroup値を指定して、目的の占有レベルを表現できます。

値が高いほど、コンパイラが目指すと示唆する占有率が高くなります。

これで、動的ライブラリ用のこの新しいMetal-Compile-Optionsプロパティを使用すると、パイプライン状態オブジェクトの希望する占有レベルを一致させることができます。

Max-Total-Threads-Per-Threadgroupは、iOS 16.4とmacOS 13.3のMetalCompileOptionsで利用できます。

これで、最適なパフォーマンスのためにMetalダイナミックライブラリをチューニングしながら、パイプライン状態オブジェクトの望ましい占有率を簡単に一致させることができます。

Blender Cyclesシェーディングと交差計算カーネルのパフォーマンスのこのグラフは、Max-Total-Threads-Per-Threadgroupの変更の影響を示しています。

それが、パイプライン状態オブジェクトとディリブに対して変更された唯一の変数でした。

この場合、カーネルが最高のパフォーマンスを発揮するスイートスポットがあります。

各ワークロードとデバイスは一意であり、Max-Total-Threads-Per-Threadgroupの最適値はカーネルの性質によって異なります。

最適な値は、必ずしもGPUがサポートするスレッドグループあたりのスレッドの最大数であるとは限りません。

カーネルを試して、使用したい最適な値を見つけて、コードで焼きます。

これはBlender Cyclesシェーディングカーネルです。コンパイラの統計は、カーネルが非常に複雑であることを示しています。

実際のランタイムに影響を与えるパラメータがいくつかあります。

流出の量、使用されるレジスタの数、およびメモリ負荷などのその他の操作。

Max-Total-Threads-Per-Threadgroupを調整することで、目標占有率を変更し、そのパフォーマンススイートスポットを見つけることができます。

スイートスポットを見つけた後、流出は少し増加しますが、全体的な占有率の増加により、カーネルのパフォーマンスが大幅に向上しました。

Blender 3D 3.5内のサイクルパストレーサーは現在、金属用に十分に最適化されており、今日説明したすべてのベストプラクティスを使用しています。

関数の特殊化を使用して大規模で複雑なシェーダーのシェーダーパフォーマンスを最大化し、非同期コンパイルを使用して、バックグラウンドで最適化されたシェーダーを生成しながらアプリケーションの応答性を維持し、実行時にコンパイルを高速化するための動的リンクを有効にし、最適なパフォーマンスを得るために新しいMetalコンパイラオプションでコンピューティングカーネルを調整することを忘れないでください。

Apple GPUの計算ワークロードを拡張する方法を学び、Metalでより多くのコンパイルワークフローを発見できる以前のセッションを必ずチェックしてください。

ご覧いただきありがとうございます。

♪ ♪