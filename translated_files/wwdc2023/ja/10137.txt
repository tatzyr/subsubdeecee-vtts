10137

♪ ♪

ラスマス:こんにちは、私はラスマスです。私はコンピュータビデオを扱うカメラアルゴリズムチームのエンジニアです。

私はすでにシネマティックモードに興奮しています。

そして今、新しいシネマティックAPIを使用して、シネマティックモードの魔法を独自のアプリに統合する方法を示すことにさらに興奮しています。

このプレゼンテーションでは、新しいAPIを使用して、再生と編集を行うサンプルアプリを構築し、シネマティックモードの素晴らしい機能を実現するために、必要な手順を説明します。

しかし、統合について話し始める前に、まずシネマティックモードとは何か、それをキャプチャする方法、そしてキャプチャ後に何ができるかをお見せしましょう。

私たちはiPhone 13でシネマティックモードを導入しました、そしてそれは本当にあなたのポケットの中の小さな映画クルーです。

それはあなたに美しい浅い被写界深度と自然な焦点のフォールオフを持つカメラ、焦点を変更することによって注意と物語を指示する監督、そして事前にキーフレームを予測し、フォーカスポイント間のスムーズな移行を作成するフォーカスプーラーをもたらします。

では、どのようにシネマティックモードをキャプチャしますか?

iPhone 13と14のラインナップのどのデバイスでもカメラアプリでキャプチャされ、録画時にレンダリングプレビューを提供します。

これは、あなたが意欲的なインディーズ映画制作者であろうと、キャンプ旅行のビデオに魔法のタッチを加えたいであろうと、非常にアクセスしやすくなります。

そして、私は映画製作者になることを夢見ていましたが、自分の家族のシネマティックモードを捉えるのが大好きです。

しかし、魔法はここで止まりません。

シネマティックモードには、目に見える以上のものがあります。

それはあなたがキャプチャ後にいくつかのかなり驚くべき非破壊的な編集を行うことを可能にします。

絞りを変更し、それによってボケ味の量を変更できます。

そして、代替検出を使用して焦点と物語をリダイレクトすることができます。

これは写真でのキャプチャ後の編集を示していますが、編集はiMovie、Final Cut Pro、Motionなどのアプリでも行うことができます。

そして今、シネマティックAPIの導入により、シネマティックモードのビデオを使用して、独自の素晴らしいアプリで再生および編集することができます。

Cinematic APIは、新しいmacOS Sonoma、iOS 17、iPadOS 17、tvOS 17で広く利用可能です。

だから、これは本当にエキサイティングです。

まず、特別なシネマティックモードのアセットとデータフローに関するいくつかの基礎から始めます。

次に、絞りの変更など、簡単な再生調整でシネマティックモードのアセットを取得して再生するための特定の手順を実行します。

そして、シネマティックモードでフォーカスを駆動する非破壊編集を行う方法と、これらの編集変更を保存してロードする方法。

新しいシネマティックAPI呼び出しのいくつかを見て、詳細な参照として使用できるサンプルコードアプリも提供します。

しかし、約束通り、シネマティックモードに関するいくつかの基礎を説明することから始めましょう。

シネマティックモードは、実際には2つのファイルと、一方から他方へのデータフローで構成されています。

まず、レンダリングされた資産があります。

これは、シネマティックモードエフェクトが適用されたベイクドファイルで、通常のQuickTimeムービーとしてエクスポート、共有、再生できます。

そして、レンダリングされたアセットを作成するために必要なすべての情報を含む特別なシネマティックモードアセットがあります。

絞りを変更したり、物語に再フォーカスしたりするなど、非破壊的なキャプチャ後の編集を行うことができます。

まず、レンダリングされたアセットを見て、小さなシネマトグラフィー101でショットを分解しましょう。

オープニングショット:私たちは明らかにストリートハンドボールの重要なゲームであるものに入り、メインの主題に焦点を当てることで、彼が大きなプレーをする準備をするにつれて、私たちは本当に緊張を感じます。

彼はチームプレーヤーをチェックします。彼も準備ができています。

彼に焦点を当てることは、彼がどれだけ準備ができているかを強調しています。

私たちは主なテーマに焦点を合わせます。

これです。ナイフで緊張を断ち切ることができます。

彼は芝居を作り、それを完全に台無しにし、いくつかのコミカルな救済を設定します。

さて、ショットの早い段階で彼に焦点を当てることで、物語をチームプレーヤーについてに変更し、行ったり来たりする代わりに、彼に焦点を合わせましょう。

私は彼の考えの声になります。

「愛してるよ、相棒、でもあなたはいつも永遠にかかる。」

はい、準備はできていますが、期待は低いです。

「なんて時間の無駄だ。ブラボー。」だから、これはiPhone 13で撮影され、シネマティックモードが提供するストーリーテリングのための映画撮影ツールを紹介しました。

そして、このレンダリングされたアセットを生成するために、特別なシネマティックモードアセットがあります。

非破壊的なキャプチャ後の編集をサポートするために、シネマティックモードのアセットには実際には複数のトラックがあります。

1つ目は、キャプチャされたオリジナルのQuickTimeムービーであるビデオトラックです。

HDR/SDR、毎秒30フレームで1080p、iPhone 14、24、25、毎秒30フレームで4Kでもかまることができます。

このトラックは通常のビデオとして再生できますが、レンダリングされたアセットと比較して美学とストーリーテリングが欠けています。

サスペンスもコミックリリーフもなく、私たちは何人かの人々が路地裏でゲームをするのを見ているだけです。

2番目のトラックには、同じシーンを見ている2つのカメラから見られるピクセルシフトである格差が含まれています。

近いオブジェクトは、遠く離れたオブジェクトよりもシフトされています。

片方の目を閉じて、もう片方の目を閉じて、オブジェクトが異なる距離でどのようにシフトするかを自分でテストできます。

格差は、焦点を合わせ、浅い被写界深度をレンダリングするために使用されます。

格差マップはビデオトラックよりも低い解像度です。

色分けとして表示されるトラックには、絶対格差ではなく相対的な格差が含まれています。つまり、焦点格差に対する相対的なレンダリングや2つの焦点格差間の遷移など、同じマップ内の他のサンプルに対してのみ使用できます。

相対的な格差と大きな深さのダジャレについての洞察については、WWDC17「iPhone写真で深みを捉える」を強くお勧めします。

3番目のトラックには、レンダリングと編集のための重要なメタデータが含まれています。

トラックは2つのもので構成されています。

まず、フォーカスの格差と絞りをf数として保持するレンダリング属性。

これらはレンダリングを駆動します。

オーバーレイとして表示されるフォーカスはシネマティックエンジンによって決定され、絞りはユーザーによって選択されます。

そして、すべての自動シーン検出を保持するシネマティックスクリプトがあります。

このシーンは、顔、頭、胴体を示し、可能であれば時間の経過とともにそれらをリンクするIDでグループ化されます。

スクリプトはまた、フォーカスの決定を保持し、どの検出にフォーカスを維持するかを決定します。

フォーカスの決定は、他の検出に従うようにキャプチャ後に変更することができ、それによって物語とレンダリングを変更することができます。

これは、シネマティックモードアセットからレンダリングされたアセットへのデータフローです。

先ほど説明したように、シネマティックモードアセットは、レンダリングとキャプチャ後のフォーカスと絞りの変更に必要なすべての情報を保持します。

以下はオプションの編集で、変更は非破壊的であり、いつでも元に戻すことができます。

編集が行われない場合、シネマティックエンジンはフォーカスの格差を自動的に制御し、キャプチャ時にユーザーが設定した絞りは変更されません。

焦点格差と絞りで、レンダリングは格差マップを使用して正確な焦点フォールオフで浅い被写界深度を適用します。

そして最後に、効果が適用されたレンダリングされたアセットを取得します。これは、通常の共有可能なQuickTimeムービーです。

シネマティックモードをよりよく理解して、再生アプリの構築を開始する時が来ました。

しかし、まずシネマティックモードのアセットを手に入れる必要があるので、それを得るためにコードを見てみましょう。

フォトライブラリからシネマティックモードのアセットを選ぶのはとても簡単です。

シネマティックビデオには、写真ピッカーとフィルターを使用するだけです。

ピッカーは、選択したファイルのローカル識別子を取得します。

非コード関連の補足として、シネマティックモードアセットをまだお持ちでない場合は、レンダリングされたアセットとシネマティックモードアセットの両方を含めるために、すべての写真データオプションを使用して、異なるユーザーデバイス間でAirDropすることができます。

コーディングに戻りましょう。

ピックのアセット識別子を使用して、リクエストする前にシネマティックモードアセットに関する情報を含む写真アセットを取得できるようになりました。

元のバージョンを取得するためのリクエストオプションを設定し、アセットがiCloudにある場合にネットワークアクセスを許可し、最後にシネマティックモードアセットをAVAssetとしてリクエストする必要があります。

そして今、エキサイティングな部分へ。

シネマティックモードのアセットを手に入れました。

再生を統合しましょう。

レンダリングされたアセットは、AVPlayerとAVPlayerItemを使用して通常のムービーとして再生でき、シネマティックモードアセット内のムービートラックも再生できます。

しかし、シネマティックモードアセットの可能性を実現するには、複数のトラック、ユーザー変更を処理できるカスタムビデオコンポジターを追加し、最後にシネマティックレンダラーを呼び出して出力を作成する必要があります。

このカスタムコンポジターは、サムネイルやオフラインエクスポートにも使用できますが、シネマティックモードのアセットの再生と編集に使用することに焦点を当てましょう。

Cinematic APIに固有の詳細のみ詳しく説明しますので、カスタムビデオコンポジタークラスとHDRに関する追加の洞察については、WWDC20「AVFoundationでHDRビデオを編集して再生する」をお勧めします。

シネマティックAPIを使い始めましょう。

Cinematic APIはプレフィックスCNを使用するため、浅い被写界深度をレンダリングするレンダリングセッションを設定するために必要な3つのAPI呼び出しを見つけることができるかもしれません。

最初の呼び出しは、シネマティックアセットからレンダリング属性を取得します。

2つ目は、これらの属性を持つレンダリングセッションを設定します。

レンダリングセッションはGPUを使用するため、金属コマンドキューを提供する必要があります。

そして、最後の呼び出しは、エクスポートするレンダリング品質を設定します。

品質は、パフォーマンスや品質の制約に応じて、プレビューやエクスポートなどの異なる列挙型に設定できます。

これらと次のコードスニペットでは、コアコードに集中するために、ガードレットエラーのようなグッドプラクティスエラーチェックを削除しました。

カスタムコンポジターには、出力をレンダリングするために必要なシネマティックアセット情報を含むコンポジションが必要です。

一般的なケースでは、複数のトラックを追加するには複数のステップが必要ですが、幸いなことに、私たちは1つのステップでこれを行う簡単な方法を提供します。

アセット情報からコンポジションまで、すべてのトラックを直接追加できます。

シネマティックコンポジション情報は、シネマティックアセット情報に似ていますが、コンポジショントラックを指しています。

その後、シネマティックアセットからシネマティックスクリプトを取得します。

シネマティックスクリプトは、すべての検出とフォーカスの決定を保持します。

そして、これについては後で詳しく説明します。

カスタムコンポジターでは、レンダリングセッション、アセットトラックを使用したコンポジション、シネマティックスクリプト、および絞りをf番号として設定します。

このカスタムインストラクションでは、レンダリングされたシネマティックコンテンツを構成する方法について説明します。

ビデオを再生するには、ビデオコンポジションが必要です。これにシネマティックコンポジションからトラックIDを追加し、エフェクトを作成するためにレンダラーが呼び出されるサンプルカスタムコンポジターを追加し、コンポジション命令を追加します。

カスタムコンポジターで何が起こっているのかを詳しく見てみましょう。

カスタムコンポジターのstartRequest関数には、シネマティックAPIに固有の重要な点がいくつかあります。

シネマティックコンポジションのトラックIDを使用して、元のビデオトラック、格差トラック、メタデータトラックから現在のフレームのソースバッファを取得し、最後にレンダリングされた出力のバッファを作成します。

これらのバッファを使用すると、編集や新しいレンダリングを行うことができます。

メタデータバッファから、レンダリングを駆動するレンダリングフレーム属性を取得できます。

メタデータは不透明な構造なので、CNRenderingSessionを使用してフレーム属性を直接取得します。

フレーム属性を使用すると、UI要素からの絞り変更を保持する指示に従って絞りf番号を変更することで、オプションの再生変更を行うことができます。

フォーカスの格差も同様の方法で変更できますが、後で検出を使用してシーン主導の変更に戻ります。

この時点で、私たちは再生を達成するために本当に、本当に近づいています。

構成された出力をGPUでレンダリングできるように、レンダリングコマンドキューでコマンドバッファを取得する必要があります。

更新されたフレーム属性と画像と格差バッファを使用してレンダリングをエンコードします。

ビデオコンポジションに渡される出力バッファの完了ハンドラを追加します。

そして最後にコマンドバッファをコミットします。

では、サンプルアプリで再生してみましょう。

フォトライブラリからシネマティックモードアセットを選択できるようになりました。

そして、アセットを再生すると、その効果はリアルタイムで適用されます。

前後にスクラブして絞りを変更して、ボケ味の量を変更することができます。

停止すると、効果が最小限に抑えられます。

開放はそれを増加させる。

たぶん、これは多すぎます。

これは良さそうだと思います。

アプリはすでにかなりクールですが、今後の編集セクションではさらにクールになります。

そして、参考として、各部品のコードはサンプルアプリで入手できます。

私は今、シネマティックスクリプトを変更し、それによってフォーカスを変更することによって、より高度で非破壊的な編集を行うために、再生アプリとカスタムビデオコンポジターを拡張するために進みます。

しかし、シネマティックモードの写真アプリの編集環境を再検討し、オブジェクトを検出し、どこで何を焦点を合わせるかを決定することによって、キャプチャ中に自動的に駆動されるフォーカスを具体的に見てみましょう。

これらの検出と決定はすべてシネマティックスクリプトにあり、スクリプトはあなたの物語に変更することができます。

フォーカス検出は黄色の正方形で表示され、タイムラインの下にはキーフレームとフォーカスの決定の変更があります。

これがどのように機能するかをよりよく理解するために、簡単な例で映画のスクリプト構造を分解しましょう。

短いシーケンスで2つのシネマティックスクリプトフレームから始めましょう。

それぞれが特定の時点ですべての検出を保持し、この場合は2つの検出のみを保持します。

検出は、顔、頭、胴体を一緒にグループ化するグループIDで時間の経過とともに追跡されます。

さらに、猫、犬、ボールが検出され、追跡されますが、ここではアクター1とアクター2の顔しかありません。

自動ベース決定は、最初のフレームでアクター1に焦点を当て、フォーカスは新しい決定までこのトラックに従います。

アクター3がシーンに入り、新しい顔と検出トラックを導入した後でも、焦点はアクター1のままです。

フレーム5では、自動キーフレームイベントが決定とフォーカスをアクター2に変更します。

そして、わずか4フレームの後、アクター3は彼女が値する集中的な注目を得ることなく、落胆した出口を行います。

残りのシーケンスでは、アクター2にフォーカスが残ります。

これらの自動基本決定は、誰がカメラに直面するか、誰が離れて見るか、誰が近くにいるか、何が面白いかなど、さまざまなパラメータで決定されます。

そして、私たちは良い物語を作成するために最善を尽くしますが、あなたは別の物語を持っているかもしれません。

幸いなことに、決定は変更することができ、実際には2つの方法で変更できます。

1つ目は、弱いユーザーの決定を追加することです。

これは、彼女がシーンに入るときにアクター3に焦点を合わせます。

ただし、弱い決定は、フレーム5で発生する次のベースまたはユーザーの決定までトラックに続くだけで、基本決定は残りのフレームのフォーカスをアクター2に変更します。

したがって、アクター3に集中したい場合は、フレーム5に別の弱い決定を追加するか、より強力なものを使うことができます。

はい、あなたはそれを推測したかもしれません、強力なユーザーの決定です。

強力な決定は、他の場所に焦点を当てる次のユーザーの決定または検出トラックの終わりまで、主題に焦点を当て続けます。

強力な決定を追加すると、アクター3が焦点になり、次の基本決定が上書きされます。

アクター3の検出トラックが終了した後、焦点はアクター2に焦点を当てるという基本決定に戻ります。

決定階層は次のように機能します。基本決定の上にユーザーの決定、ユーザーの決定は可能な限り適用され、基本決定はギャップを埋めます。

したがって、この例で行ったように、ユーザーはスクリプトの一部だけを変更できます。

そして、検出トラックが終了すると、両方の決定は基本決定に戻りますが、強力な決定はできるだけ長くフォーカストラックを保持します。

スクリプトを変更する前に、スクリプトフレームを取得し、検出ボックスを描きましょう。

まず、ビデオコンポジションのリクエストからフレームタイムを取得し、その現在の時点のシネマティックスクリプトフレームを取得する必要があります。

このスクリプトフレームは、フォーカス検出を含むすべての検出を保持します。

検出ボックスを描くのが簡単になりました。

スクリプト内のすべての検出を反復することで、各検出矩形を取得し、drawコマンドを使用してrenderEncoderにアタッチされたテクスチャに描画できます。

この例では、検出は白で描かれています。

そして、現在のfocusDetectionを強調するために、それを別の色で描きましょう。

私はシネマティックスクリプトフレームから直接フォーカス検出を取得し、対応する長方形を取得し、それを目立たせるために、フォーカス長方形を黄色で描きます。

検出オーバーレイを追加した再生アプリを試してみましょう。

新しい検出オーバーレイを有効にして、検出を描画できるようになりました。

このシーンでは、顔、頭、胴体は白で、焦点検出は黄色です。

アプリにとって理にかなっている場合にのみ、検出の特定のサブセットを表示するようにオーバーレイをカスタマイズできます。

再生を開始すると、フォーカスとレンダリングが映画を通して黄色のフォーカス検出に続き、代替検出が白で表示されていることに注目してください。

これらの代替検出を使用して焦点を変更する方法を紹介します。

検出ボックスの描き方を知ったら、実際にUIタッピングポイントでスクリプトを変更することは非常によく似ています。

繰り返しますが、すべての検出を反復し、タッピングポイントが検出内にある場合は、対応する検出IDを取得し、新しい決定を作成します。

意思決定の強さはUIで設定できます。

サンプルアプリでは、弱いものはシングルタップで設定され、強いものはダブルタップで設定されますが、UIは本当にあなた次第です。

そして最後に、この新しいユーザーの決定をシネマティックスクリプトに追加し、スクリプトが変更されました。

それでは、更新されたスクリプトがどのように焦点を集中させるかについて話しましょう。

これを通常のクリップの長さと考え、3つの決定と対応するフォーカス検出トラックを見てみましょう。

2Dプロットで時間と距離に応じてフォーカストラックを配置しましょう。

シネマティックエンジンは更新されたスクリプト全体を知っているので、事前にスムーズなフォーカスの移行を行うことができます。

フォーカスラックが事前に開始され、各キーフレームの先頭にフォーカスに到達すると、このように見えます。

それはかなり魔法であり、セットマーカーを知ることで、注意を向け、事前にフォーカスをラックすることができるフォーカスプラーのように機能します。

ラックされたフォーカスの格差は、更新されたシネマティックスクリプトのフレームから直接アクセスできます。

私はすでにスクリプトフレームを抽出する方法を示しており、フォーカスのフレーム属性を変更することは絞りの変更に似ています。

更新されたスクリプトからスクリプトフレームを取得したら、フォーカス格差のフレーム属性を直接更新できます。

これにより、更新されたスクリプトに従ってスムーズなトランジションでフォーカスがレンダラーに渡されます。

タップしてスクリプトを変更し、サンプルアプリでフォーカスしてみましょう。

再生モードから編集に移行して、シネマティックスクリプトを更新できるようになりました。

黄色の破線ボックスとして表示されている弱い決定を得るためにシングルタップするか、強い決定と固体の黄色のボックスを得るためにダブルタップすることによって、焦点の決定を変更することができます。

異なるプレーヤーをタップすると、ユーザーの入力に応じてフォーカスとレンダリングがどのように変化するかを確認できます。

これは超かっこいいと思います。

スクラブ、スクラブ。

タップ、タップ、タップ。

絞りを変更します。

スクラブ、タップ、タップ、ダブルタップ。

そして、編集が完了したので、これらの編集変更を保存するにはどうすればよいですか?

スクリプトの変更は別のデータファイルに保存でき、変更を別々に保存すると、オリジナルは変更されません。

そして、変更はいつでも元に戻すことができます。

だから私はスクリプトの変更を取得し、コンパクトなバイナリ表現として変更を取得し、データファイルに変更を書き込みます。

Cinematic APIはデータ表現を処理します。

また、ニーズに合わせてリロードできるように、このデータをアプリに保存する必要があります。

スクリプトの変更の読み込みは、3つの同様に簡単なステップで行われます。

データファイルからバイナリデータを取得し、スクリプトの変更を解凍し、変更をシネマティックスクリプトにリロードします。

変更は、元のスクリプトと同時に読み込むこともできます。

そのため、シネマティックスクリプトの変更を編集、レンダリング、保存、ロードすることができます。

前述のように、カスタムビデオコンポジターを使用して、レンダリングされたビデオをエクスポートできます。

そして、これらはすぐにフォトライブラリにレンダリングすることができます。

これはサンプルコードで詳しく説明されています。

APIには、自動検出なしでオブジェクトに使用できるトラッカーCNObjectTrackerも含まれています。

サンプルコードは、検出せずにオブジェクトをタップすることでトラッカーをエンゲージする方法をカバーしています。

また、トラッカーは検出トラックを提供し、スクリプトに追加できます。

そして今、いくつかのより高度な可能性に。

また、独自のトラッカーを提供することでカスタムトラッキングを追加し、独自のカスタム検出トラックをスクリプトに追加することもできます。

また、フレームごとにレンダリング属性にカスタム変更を加えることができ、カスタムトランジションと絞りの変更が可能です。

個人的には、シネマティックモードと新しいAPIでできることにとても興奮しています。

そして、それがシンプルなアプリであろうと複雑なエディタであろうと、私たちが考えもしなかったアイデアを思いつくことができると確信しています。

これは、再生調整で再生用のシネマティックモードビデオアセットを統合し、シネマティックスクリプトとフォーカスを変更して非破壊的な編集と新しいレンダリングを行い、これらのスクリプトの変更を保存してロードできる新しいシネマティックAPIの紹介でした。

付属のサンプルアプリでこれなどをチェックしてください。

あなたの集中と幸せなコーディングに感謝します。

♪ ♪