10250

♪ ♪

Dariusz: こんにちは、私はDariuszで、Xcode Playgroundsチームのエンジニアです。

Xcode Playgroundsの改善により、プロジェクトの新機能のプロトタイプを簡単にする方法をお見せしたいと思います。

Xcode Playgroundsがワークフローを改善できるシナリオはたくさんあります。

まず第一に、新機能のプロトタイプを作成したり、コードの小さな変更を試したりしたいときはいつでも、プロジェクトの再構築と再起動をスキップすることができます。

また、ショッピングアプリで注文サマリーを生成するロジックのように、そうでなければ到達するのが非常に難しいコードの実行がはるかに簡単になります。

もちろん、そのようなコードはテストで検証することができ、検証する必要がありますが、プレイグラウンドはそれらを開発するための素晴らしい出発点にもなります。

また、プロジェクトに新しい依存関係を導入する前にコードを試すのに最適な環境です。

Xcode Playgroundsが私のプロジェクトでどのように役立っているかをお見せしたいと思います。

私は野生動物の写真撮影に役立つ小さなアプリに取り組んできました。

現時点では、私のアプリは、私がすでに発見して撮影した種を追跡するのに役立ちます。

さて、このアプリは、野生動物写真の非常に重要な側面の1つで私を助けたいと思っています。それは、実際に最初に動物を見つけることです。

チェックリストビューの新しいタブを紹介したいと思います。

私はすでにビューを実装し始めており、このユーザーインターフェイスに非常に満足しています。

各鳥にはチェックボックスがあり、進捗状況を追跡できます。

しかし、リストに2,000羽以上の鳥が載っているので、私はおそらくあまり進歩しているようには感じないでしょう。

このリストを少し絞り込むのは素晴らしいことです。

これを行うには、カスタムChecklistViewでbirdsToShowの計算プロパティを調整する必要があります。

現時点では、北米用に設定された私のBirdProviderタイプを作成し、大陸全体で見つかったすべての鳥種を返します。

プロジェクトを頻繁に再構築して再起動し、ChecklistViewに移動して変更を確認することを避けるために、Xcode Playgroundでこのコードを調整してみます。

私のプロジェクトに新しい遊び場を追加することから始めます。

これはiOSアプリなので、iOSのテンプレートに固執します。

フィルターバーに「遊び場」と入力し、空白の遊び場を選択します。

この場合、いくつかのことを試してみたら、おそらく遊び場を取り除くので、デフォルトの「MyPlayground」の名前を保つことができます。

遊び場のデフォルトの内容を取り除きます。

さらに高速に反復するには、下部バーの実行ボタンを長押しすると表示されるメニューで「自動実行」に切り替えます。

これにより、変更を停止するたびに、プレイグラウンドは自動的にコード全体を実行します。

プロジェクトに追加されたプレイグラウンドには、デフォルトで2つの設定が有効になっていることに注意してください。ビルドアクティブスキームとインポートアプリタイプです。

彼らは、各プレイグラウンドの実行前にアクティブなスキームが構築され、アプリのターゲットモジュールが自動的にインポートされることを保証します。

これにより、プロジェクト内で定義されたタイプをはるかに簡単に操作できます。

私は遊び場のためのもう少しスペースを与えるために検査官を閉じることができます。

私のChecklistViewのbirdsToShowプロパティで見たように、BirdProviderインスタンスを宣言することから始めましょう。

エディタの右側にある結果サイドバーは、この宣言がプレイグラウンドの結果を生成したことを示しています。

インライン結果のトグルを使用して、詳細を確認できます。

インラインの結果は、このBirdProviderインスタンスの詳細と、鳥の配列と提供された領域の2つのプロパティを示しています。

Xcode 15では、各行にはタイプ情報の短い要約を示すタイプ情報ラベルもあり、各行のツールチップを使用して詳細を表示できます。

たとえば、ツールチップは、BirdProviderタイプが私のアプリモジュールから来ており、領域列挙型がその構造体内で定義されていることを示しています。

配列行を展開して、鳥の詳細を見てみましょう。

インライン結果ビューと対話し始めると、Xcode 15は結果を生み出したソースコードを強調表示することに注意してください。

この場合、ビューはbirdProvider定数に割り当てられた値を表示します。

これにより、表示された値を理解しやすくなります。

配列要素を詳しく見てみましょう。

地域と鳥の配列プロパティの素敵な要約を見ましたが、デフォルトでは、各鳥を表す行は配列インデックスについてのみ教えてくれます。

なぜなら、カスタムバードタイプには説明が定義されていないからです。

BirdタイプをCustomStringConvertibleプロトコルに準拠させることで、これを改善できます。

遊び場またはそのソースディレクトリに拡張機能を追加できます。

これらのオプションは両方とも、遊び場の範囲内の鳥のタイプにのみ影響し、デバッガのようなそれらに依存する他の場所では素敵な新しい説明を得ることはありません。

そのため、Birdタイプを定義するファイルに拡張子を追加します。

新しい説明の定義では、各行は鳥の共通名と学名を示す必要があります。

遊び場に戻って、新しい説明の動作を見てみましょう。

プレイグラウンド実行の自動モードでは、プレイグラウンドは再度開くと自動的に再実行されます。

鳥の配列行をもう一度展開して、説明を確認しましょう。

これははるかに良いです。

これで、行が展開せずに何を表すかは明らかですが、バードタイプの他のプロパティを見てみましょう。

私はすでにこれらの鳥のいくつかを見つけて撮影しました、そして、あなたはそれらのいくつかがすでにこの大西洋ツノメドリのような写真のプロパティを持っていることがわかります。

その行をクリックすると、写真は新しい分割ビューベースのユーザーインターフェイスに表示され、プレビューとともにオブジェクトの構造を見ることができます。

デフォルトでは、行をクリックすると、カスタムBirdタイプのプレビューはありません。

私はすべての種の名前にそれほど精通していないので、すでにここで写真を見るのは素晴らしいことです。

それを達成するために、私はCustomPlaygroundDisplayConvertibleプロトコルを使用することができます。

プロトコルの名前が示すように、この適合性はプレイグラウンドの表現にのみ影響するので、今回はプレイグラウンドのソースディレクトリに拡張機能を追加します。

アプリモジュールをインポートしてBirdタイプにアクセスし、photoプロパティをplaygroundDescriptionとして返す簡単な拡張機能を追加します。

リターンステートメントでAnyに明示的に写真をキャストしていることに注意してください。

それがなければ、コンパイラは、値がオプションであることに関する重要な情報を失っていると警告します。

Xcode Playgroundsは、playgroundDescriptionプロパティでnilを返さないオブジェクトのカスタム説明のみを作成することで、オプションを処理するため、この場合は問題ありません。

もう一度遊び場に戻って、新しい説明を確認しましょう。

Xcode 15では、CustomPlaygroundDisplayConvertibleに準拠したタイプによって返されたplaygroundDescriptionが、オブジェクトの構造に沿って分割ビューに表示されます。

今、すでに写真を持っている鳥は、列を広げることなく、すぐにそれを表示します。

これにより、このカスタムタイプの大規模なコレクションでの作業がはるかに簡単になります。

しかし、今日は、まだ写真を持っていない鳥に焦点を当てたいと思います。

このインライン結果を閉じて、すでに写真を持っているすべての鳥をフィルタリングしましょう。

これら2つのサイドバーの注釈が少し違って見えることがわかります。

それは、新しい行に複数の式があるからです。

新しいコントロールをクリックすると、各式のおなじみの要約を見ることができます。

インライン結果のトグルにカーソルを合わせると、ソースコードの範囲が強調表示されます。

これにより、配列はbirdsToFind定数に割り当てられた結果であり、trueはフィルタ関数に渡されたクロージャによって生成される最新の値であることを明確にします。

結果のサイドバーによると、私がまだ撮影していないすべての鳥の数はまだ1,800を超えており、これは非常に威圧的です。

これは最終的に目標かもしれませんが、フクロウなどの鳥の小さなグループに焦点を当てることで、それを低くしたいと思います。

6月はオウリングに行くのに最適な月ですが、それは別のセッションのトピックです。

他の家族から鳥をフィルタリングしましょう。

配列には5つの要素しかありません。これははるかに心強いです。

この小さな鳥のグループでカスタムチェックリストビューを試してみたいと思います。

これを行うには、ChecklistViewインスタンスを作成し、各鳥を1つずつ追加します。

ChecklistViewのインライン結果を開きましょう。

UIViewサブクラスとして、スナップショットとともにいくつかのプロパティも表示されるようになりました。

値履歴モードに切り替えることができ、新しいスプリットビューベースのユーザーインターフェイスも使用できるようになりました。

これにより、各ループ反復でChecklistViewがどのように見えるかを確認できます。

それは実際に私の見解に問題を見つけるのに役立ちました。これは、たった1羽の鳥のヘッダーに「鳥」と間違って書かれています。

新しい文字列カタログで定義された文字列を調整することで、これを修正できるはずです。

最初の行は、私のチェックリストビューのヘッダーで使用されているもののようです。

コンテキストメニューを表示し、Vary By Pluralを選択します。

そうすると、影響を受ける行の状態が「レビューが必要」に変更されます。

この文字列の単数形を調整します。

新しい文字列カタログの詳細については、「文字列カタログの発見」セッションを確認してください。

遊び場に戻って、この変更でチェックリストがどのように見えるかを見てみましょう。

ヘッダーは各ループ反復で正しく見えます。

私は今、このインライン結果を閉じることができます。

私のChecklistViewは使えると思います。

鳥のリストを絞り込むために使用したコードをすぐに私のプロジェクトに持ってきます。

この3行をChecklistViewのbirdsToShowプロパティにコピーします。

また、新しい、はるかに小さな鳥の配列でリターンステートメントを追加します。

プロジェクトを再実行する前に、もう1つの機能のプロトタイプを作成したいと思います。

カスタムチェックリストビューの各行に開示インジケーターがあることがわかります。

リスト内の行を選択すると、簡単なマップビューが開きます。

まだそれほど役に立ちませんが、選択した鳥の最新の目撃に関するデータを取得し、地図に表示したいと思います。

そのためには、ChecklistViewで目撃情報ToShow(鳥の場合:)機能を調整する必要があります。

それを助けるために、私はすでに私のプロジェクトに1つの依存関係を追加しました。

BirdSightingsパッケージを使用すると、人々が目撃情報を報告する市民科学ウェブサイトの1つからデータを簡単に取得できます。

私は以前にそのパッケージを使ったことがないので、まだそのAPIに精通していません。

幸いなことに、このパッケージには、いくつかの例を示す遊び場の形でドキュメントが含まれています。

これは、パッケージのクライアントが提供されたAPIを試すのに最適な方法です。

fetchSightings関数に2つの引数を提供する必要があるようです。探す鳥のコードと見回す場所です。

予想される結果についてもっと知るために、この遊び場を実行することができます。

遊び場に戻って使ってみよう。そして使ってみよう。

ナビゲーターを閉じて、エディタエリアにもっとスペースを与えることができます。

関数を呼び出す前に、2つのインポートステートメントを追加する必要があります。

座標で作業できるようにCoreLocationフレームワークをインポートし、APIを使用するためにBirdSightingフレームワークをインポートします。

関数引数については、リストから最初の鳥から始めることができます。

短耳のフクロウを探しているようです。

ここで強制包装解除を使用したことに注目してください。

Playgrounds環境でのエラー処理についてそれほど心配する必要はありませんが、コードをプロジェクトに持ち込むときは、それを念頭に置いておくことが重要です。

場所に関しては、私はおそらくほとんどの場合、現在の場所を使用しますが、特定の座標を提供する能力は、コードのテストとすべてのロードトリップの計画という2つのことに最適です。

アップルパーク周辺で何が見つかるか見てみよう。

ネットワークコールを導入する前に、プレイグラウンド実行の手動モードに切り替えて、不要な呼び出しを回避できるようにします。

このようなリクエストにはしばらく時間がかかることがあり、できるだけ早く新機能を反復したいです。

これを行うには、もう一度下のバーのメニューを表示し、手動で実行を選択します。

今、私は実行すべきコードの部分を完全に制御できます。

フェッチコードを追加しましょう。

ソースエディタの溝のコントロールは、これらの2行を実行すると、上記ですでに実行したすべての行が再実行されないことを示しています。

新しい行を実行して、データが得られるかどうか見てみましょう。

幸いなことに、いくつかの目撃情報があります。

最新のはずの最初のものを見てみましょう。これは最新のはずです。

短耳のフクロウは最近、昌門崖保護区で見られたようです。

私はまだこの地域のすべてのバードウォッチングホットスポットに精通していないので、私のSightingMapViewで目撃に関するデータを見るのは素晴らしいことです。

フェッチされた照準データで初期化しましょう。

マップビューのような複雑なユーザーインターフェイス要素では、プレイグラウンドのライブビューを使用して、大きくて完全にインタラクティブなプレビューを見ることができます。

それを使用するには、まずPlaygroundSupportフレームワークをインポートする必要があります。

これで、ライブビューを設定し、プレイグラウンドを実行する準備が整いました。

ファイルの上部にimportステートメントを追加して、プレイグラウンドのすでに実行された部分を変更したので、ソースエディタのガターのコントロールは、ファイル全体を再実行する必要があることを教えてくれます。

前回の実行で結果を失いますが、この場合は問題ないはずですので、先に進んで遊び場を実行します。

アップルパークに近すぎる島は覚えていません。

ライブビューは完全にインタラクティブなので、iPhoneシミュレータのように少しズームアウトして、私たちがどこにいるかを見ることができます。

私たちは東が遠すぎるようです。

エディタオプションのライブビューを閉じて、問題が導入された場所を見てみましょう。

私のSightingMapViewはmostRecentSighting定数で初期化されたので、その値を確認しましょう。

インライン結果を開く代わりに、サイドバーの目のアイコンをクリックして値を簡単に見ることができます。

Xcode 15では、MapKitとCoreLocationタイプの一部のプレイグラウンドの結果を改善しました。

プレイグラウンドはCLLocationCoordinate2Dのプレビューを表示できるようになりましたので、ロケーションプロパティを見てみましょう。

これは同じ場所を指しているように見えるので、これは私のSightingMapViewによって引き起こされたのではないようです。

BirdSightingsパッケージから間違った場所を得たので、パッケージの問題によって引き起こされるか、最初に間違った場所を通過した可能性があります。

後者を検証しましょう。

これはアップルパークにも近くないようです。

私たちは東が遠すぎるので、これは西と東を混ぜるだけの問題かもしれないと思います。

経度の前にマイナス記号を追加し、遊び場を再実行して、これを修正してみましょう。

今、これは間違いなくアップルパークです。

更新された場所で遊び場の残りの部分を実行し、エディタオプションでライブビューを再度開きましょう。

それはもっとそれのようなものです。

今、私はコヨーテヒルズが新種を撮影するのに最適な場所かもしれないことを知っています。

すばやく取得コードを私のChecklistViewに持ち込みましょう。

この3行を目撃情報表示機能にコピーします。

ここでハードコードされたApple Parkの場所を常に使用するのではなく、CLLocationManagerから取得したlastCurrentLocationに置き換えます。

また、新しいmostRecentSightingで返品明細書を追加します。

ついに私たちの変更でプロジェクトを実行する時が来ました。

チェックリストは、私たちが鳥の小さなグループに焦点を当てた今、はるかに現実的に見えます。

今、行をクリックするとどうなるか見てみましょう。 

それはすごい。

私のアプリは、選択した鳥の最新の目撃情報を表示できるようになりました。

もちろん、まだ改善の余地はたくさんあります。

たとえば、目撃情報がバックグラウンドで取得されている間に進行状況インジケーターを表示する必要がありますが、これは素晴らしい出発点です。

このアプリはすでに私に大いに役立ち、Xcode Playgroundsはこれらの改善作業をはるかに簡単にしました。

このセッションでは、Xcode Playgroundsを使用して、プロジェクトの新機能をすばやくプロトタイプ化しました。

CustomStringConvertibleとCustomPlaygroundDisplayConvertibleプロトコルを使用して、カスタムタイプの表現をカスタマイズしました。

プレイグラウンドの実行モードを調整することで、ワークフローを高速化する方法を見ました。

値履歴モードを使用すると、クラスが複数の入力にどのように反応するかをすばやく確認できます。

最後に、プレイグラウンドのライブビューを使用して、複雑なユーザーインターフェイス要素を詳しく調べました。

ご覧いただきありがとうございます。