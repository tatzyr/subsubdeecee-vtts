10226

♪ ♪

ネイサン：みなさん、こんにちは。私の名前はネイサンです。

そして、私はXcode Debugger UIチームのエンジニアです。

今日は、Xcode 15に登場する真新しいデバッグコンソールを紹介できることを嬉しく思います。

このセッションでは、デバッグコンソールをすぐにご案内します。

次に、自分のアプリケーションで実際のバグを診断することで、デバッグコンソールがどれほど有用であるかを示します。

次に、LLDBにいくつかの改善点を紹介します。

そして最後に、AppleのUnified Logging APIを活用して診断体験を向上させる方法についてのヒントを共有します。

掘り下げて、デバッグコンソールの新機能を見てみましょう。

私のデバイスで、Backyard Birdsアプリを起動しました。

このアプリを使用すると、ユーザーは裏庭を管理し、仮想鳥の世話をすることができます。

アプリケーションを起動した後、デバッグコンソールに多くのログが入力されました。

すぐに、コンソールが私が慣れているメタデータを各ログの前に付けていないことに気づきました。

代わりに、注意は開発者が私に表示することを意図した根本的なメッセージに焦点を当てています。

もちろん、これらのログに関連する追加情報を表示したい場合がありますので、デバッグコンソールの左下にあるメタデータオプションボタンを選択し、現在のニーズに最適なタイプを選択することで、これを表示する機能を提供します。

この場合、タイプ、ライブラリ、サブシステム、カテゴリを選択します。

これを有効にすると、メタデータはコンソールの各ログの下に配置され、意図した出力から奪わないように、より小さく、より微妙になります。

私はまた、黄色または赤の背景を持つログに出くわすかもしれません。

これは、これらのログがより重要であり、それぞれエラーと障害を表していることを示しています。

すべてのログのメタデータを同時に見たくない場合は、コンソールで問題のログを選択し、スペースを押してすばやく確認することで、単一のログのメタデータを検査できます。

これにより、利用可能なすべてのメタデータを提供するポップアップウィンドウが表示されます。

これには、最初にログを発行した関数の名前が表示されるコールサイトなどの情報も含まれます。

この追加のメタデータを見ることは素晴らしいことですが、新しいデバッグコンソールが本当に輝いているのは、そのフィルタリング機能です。

コンソールが私が気にしないログでいっぱいになるのは簡単ですが、Xcode 15では、それらをフィルタリングすることがこれまで以上に簡単です。

これで、コンソールは複雑でトークン化されたフィルタリングを実行して、私のニーズに最も関連性の高いログを簡単に見つけることができます。

コンソールには、これらのフィルターを作成するさまざまな方法もあります。

もちろん、フィルターはこのようにフィルターバーに直接入力できます。

そうしている間、オートコンプリートポップオーバーが表示され、入力しようとしているフィルターの作成を支援します。

さらに、フィルターメニューでは、特定の種類のログのフィルターにすばやくアクセスできるため、表示したいタイプを選択できます。

そして最後に、多かれ少なかれ興味のあるログをセカンダリクリックすると、コンソールは、このようなビューから特定のログセットにすばやく集中または除外するために、同様のログを非表示にして表示するオプションを提供します。

これらのフィルタリング方法はすべて、私が持っているすべての出力を迅速かつ効率的にカットすることを可能にし、現在のデバッグニーズに最も関連性の高いログを見つけることができます。

では、新しいデバッグコンソールを使用して、私のアプリケーションの実際の問題を見つけて修正しましょう。

一部のユーザーがプロフィールを更新した後、コンテンツが保存されていないように見えることに気づいたという報告を受けました。

優れたロギングプラクティスと新しいデバッグコンソールからの少しの助けを利用して、このバグの原因を迅速かつ簡単に特定する方法を発見しましょう。

まず、タブバーの[アカウント]を選択して、問題を再現してみます。

鉛筆を選択してアカウントを編集します。

最後に、表示名を変更してみます。

この後、うまくいったようですが、ページを終了してアカウントを確認すると、変更が失われるようです。

さて、うまくいかなかったかもしれないいくつかのことが頭に浮かびますが、新しいデバッグコンソールがこの問題の根源を見つけるためにこれを絞り込むのにどのように役立つかを探りましょう。

これらの手順を実行している間、デバッグコンソールで大量の出力が生成されました。

ありがたいことに、新しいコンソールでは、私が最も興味を持っているものを見つけるためにフィルターを設定できるので、あまりにも多くのログを見つけることは常に素晴らしいことです。

この場合、アカウント管理のみに特化したカテゴリがいくつかあります。

これらに焦点を当てるために、フィルターフィールドに入力し、ポップアップからカテゴリフィルターを選択して、「アカウント」を含むプロジェクト内のすべてのカテゴリをフィルタリングします。

これにより、私のコードのアカウント関連の部分からすべてのログが残ります。

このフィルターセットを使用すると、出力ははるかに管理しやすくなります。

これらのログのいくつかは、私が「displayName」プロパティを設定するように要求したことを示しているようです。

私のアプリが期待どおりに機能しなかった理由を見つけるために、より深く調査しましょう。

さて、このコードがどこにあるのか正確に思い出せないので、ログにカーソルを合わせることで、私はより興味があり、右下隅のソースの場所を選択します...

Xcodeはログのソースにジャンプし、この場合、表示名を設定するように要求しました。

ソースコードを確認した後、現在のアカウントのsetDisplayName関数を呼び出すと、実際にこの操作を実行するようです。

この問題をより深く調査するために、アカウント情報の更新を担当する機能に飛び込みましょう。

このコードをさらに確認したところ、これらの変更を中央アカウントデータベースに送信している間に、ローカルアカウントのキャッシュを更新するのを忘れてしまったようです。

データベースを更新した後、このようにローカル表示名を新しいものに設定する必要があります。

その間、メールアドレスに同じバグがあることに気づきました。

ありがたいことに、これは同じように修正できます。

それでは、ライン上のブレークポイントを設定して、私の疑いを確認し、これが私の問題を解決したことを確認しましょう。

次に、アプリケーションを再構築し、この場所で一時停止する前の手順を再作成します。

この場所に着いた後、私の疑いが正しいことを確認したい。

これを行うには、アカウントの現在の状態を「po」し、期待している古いデータを取得することを確認します。

ああ、いや。私はこのオブジェクトのアドレスしか取得していないようです。

さて、それはなぜですか?

「Po」は非常に一般的ですが、このクラスの独自のカスタムデバッグ記述を宣言していないため、実行したい式のタイプではないことが判明しました。

実際、この場合、私はただ「p」を実行したいので、今それをさせてください。

さて、これは私が望んでいたものであり、これはデータベースを更新することによって表示名が単独で設定されていないという私の疑いを確認します。

追加した行を越え、表示名が更新されたことを確認しましょう。

完璧--私のアップデートでこの問題を解決したようです。

今、私は鳥に餌をやることに戻ることができます。

それでは、Xcode 15内のLLDBに「ステップイン」して、最も単純なLLDB式をさらに良くしましょう。

そのバグを解決していたときを思い出すと、私はそれが正しくない場所で「po」を使用していることに気づきました。

せいぜい、これは式の実行に時間がかかることがありますが、最悪の場合、CustomStringConvertibleを実装していないときに、単にプロパティのアドレスを返すことができます。

これは私をイライラさせ、より良い選択肢があればいいのにと思います。

その後、プロパティで「p」を実行し、正しい結果が得られました。

しかし、「式」、「v」、「vo」、「フレーム変数」など、覚えておく必要があるかもしれない他の多くのコマンドがあります。

これは難しい場合がありますので、開発者を支援するために、Do What I Mean Printを導入しています。

Do What I Mean Printを使用すると、1つのコマンドを使用してコード内の多くの異なる式を評価し、可能な限り最速の方法で結果を返すことで時間を節約できます。

もちろん、変数を調べるたびにこの長いコマンドを入力したくありません。 変数を調べるたびにこの長いコマンドを入力する必要があります。

したがって、以前の「p」エイリアスを置き換えて、Do What I Mean Printを実行しました。

これにより、ほとんどのユースケースで「p」を実行するだけです。

さらに、実際に変数のカスタムオブジェクト記述を印刷したい場合は、オプションのオブジェクト記述フラグを使用してDo What I Mean Printコマンドを実行できます。

ただし、以前の「po」エイリアスを置き換えて、Do What I Mean Printをカスタムオブジェクトの説明で実行しました。

新しいDo What I Mean Print関数を使用することで、以前は、可能な限り最速の方法で意図した出力を取得するために複数の異なるコマンドを必要とする多くの異なる式に対して2つのコマンドのいずれかを実行できるようになりました。

最後に、誰もがロギングを最大限に活用できるようにする方法を確認しましょう。したがって、デバッグエクスペリエンスを向上させ、再作成が難しい問題や、ユーザーが受信したレポートに依存する可能性のある問題をより効果的に見つけて解決できるようにします。

まず、標準のI/OはコマンドラインUI用で、OSLogはデバッグ用であることを皆さんに思い出させます。

したがって、プログラムの実行中のイベントをログに記録するために「印刷」を使用することはめったにありません。

OSLogを使用して、エンドユーザーから構造化ロギングを取得し、デバッグコンソールで構造を保持する方がはるかに良いです。

それでは、標準I/OからOSLogへの変換がいかに簡単かを示すいくつかの例を見ていきましょう。

これは、追加のロギングを追加したいシンプルな機能です。

実行されているタスクと、それらのタスクを実行した結果を記録するのは良い習慣です。

私が知っている最善の方法でこれを追加するために少し時間を取らせてください。

素晴らしい--私は今、このコードに従うのを助けるためにいくつかの簡単な「印刷」ステートメントを追加しました。

私は今、この機能で行っているアクションを印刷し、タスクが結果で完了したときに印刷しています。

しかし、私のプロジェクト内のより多くの場所にこれをした後、この出力のすべてがどこから来ているのかを見つけるのが難しくなりました。

これにより、多くの人が必要としていたように、私のプリントにマーカーを追加し始めました。

しかし、これは手に負えなくなっているように感じます。

この追加出力をすべて追加した後、それは私のコンソールをさらに乱雑にしました。

余分な作業なしで、このメタデータをすべて取得するためのより良い方法があればいいのにと思います。

さて、OSLogは私が必要とすることをすることがわかりました。

さて、この機能をアップデートして、Unified Loggingを活用したいと思います。

開始するには、まずOSLogをプロジェクトにインポートしてから、ログハンドルを作成できるようにする必要があります。

これは、ログが表現するサブシステムとカテゴリを指定する場所です。

これらは、デバッグフィルタリングを容易にする任意の文字列にすることができますが、サブシステムとカテゴリのクラスまたはコンポーネント名にバンドル識別子を使用するのが一般的です。

ロガーを作成したら、ロガーオブジェクトで提供された関数を呼び出すだけで、ログのレベルを指定し、表示したいメッセージが表示されます。

これにより、読み取りがはるかに良くなり、長期的にはコードが大幅に少なくなります。

今、私がそれを実行するとき、これがコンソールでどのように見えるかを見てみましょう。

このために、これらのログの2つを分離して、このすべてのメタデータがどこから来るのかを検査できるようにしましょう。

ログ出力では、有効になっている場合、そのすぐ下のログに指定した追加のメタデータで出力するつもりだったメッセージが見つかります。

このメタデータの一部は、メッセージやレベルなど、最初のログを書いた場所から収集されます。

その他は、サブシステムやカテゴリなど、繰り返しを保存するためにログハンドルを作成したときから収集されます。

そして、いくつかはバックグラウンドで処理されます。

これらには、タイムスタンプ、ライブラリ名、プロセスID、スレッドID、ソースの場所などが含まれます。

この情報はすべて、必要なときに大いに役立ちますが、ニーズに関係なく、すべてのログに印刷すると大量のスペースがかかります。

ありがたいことに、新しいデバッグコンソールでは、そのビューをカスタマイズして、あなたが望むものだけを提供することができます。

最後に、ロギングを最大限に活用するには、アプリケーションを構築する際にこれを考慮してください。

まず、アプリケーションのさまざまなコンポーネントに対して常に別々のログハンドルを作成する必要があります。したがって、基礎となるメタデータに意味のある検索用語を設定して、アプリケーションのセクションに最も関連性の高いログをより迅速に見つけることができます。

また、OSLogStoreを利用して、現場でアプリケーションに問題が発生した場合に貴重な診断を収集します。

そして最後に、OSLogは追跡施設であることを覚えておいてください。

これは、Instrumentsなどのツールを使用して、アプリケーションの複雑なパフォーマンス分析を提供できることを意味します。

この例では、ロギングプロファイリングテンプレートを使用して、OSLogとサインポストを使用してアプリケーションのパフォーマンスを分析しています。

さて、先ほど調べたことと、あなた自身のプログラミング体験を向上させるために何ができるかをまとめましょう。

まず、Xcode 15の新しいデバッグコンソールを探索する必要があります。そこでは、すべてのロギングニーズに多くの改善を提供しました。

次に、コードを標準のI/OからOSLogに移行し、新しいデバッグコンソールが提供するすべての新機能を提供する必要があります。

次に、LLDBの新しいDo What I Mean Printまたは「p」コマンドを試して、最初に可変検査を実行するときに必ずこれを使用してください。

そして最後に、AppleのUnified Logging APIの詳細については、以前のセッション「ロギングを使用したパフォーマンスの測定」と「Swiftでのログインを探る」をご覧ください。

幸せなロギング、そして見てくれてありがとう。