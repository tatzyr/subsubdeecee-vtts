10171

♪ ♪

Si：こんにちは、私はAppleのSwift on ServerチームのSiです。

このビデオでは、Swift OpenAPI GeneratorがサーバーAPIの操作にどのように役立つかを紹介します。

iOSアプリを拡張する場合でも、Swiftでバックエンドサーバーを作成する場合でも、この新しいSwiftパッケージプラグインはワークフローを合理化し、コードベースを簡素化できます。

今年は、デバイス上のデータ操作がこれまで以上に簡単になったことを見てきました。

しかし、実装したい機能には、サーバーコンポーネントによって提供される動的コンテンツが必要になる場合があります。

これは、リモートサービスにネットワーク要求を行い、そのAPIを呼び出すことを意味します。

しかし、適切なネットワーク要求を行うためには、考慮すべきことがたくさんあります。

サーバーのベースURLは何ですか?

APIエンドポイントを構成するパスコンポーネントは何ですか?

どのようなHTTPメソッドを使用すべきですか?

そして、どのようにパラメータを提供するべきですか?

これらは、サーバーAPIを呼び出す際に考慮すべき質問のほんの一部です。

より複雑なAPIについては、さらに多くのことを考慮する必要があります。

では、これらの質問にどのように答えますか?

ほとんどのサービスには、何らかの形のAPIドキュメントがあります。

しかし、手書きの文書は、特にサービスが急速に進化している場合、不正確または時代遅れになることがよくあります。

ソースコードにアクセスできる場合は、実装を見るか、手動でAPIを試すことができます。

しかし、これはサービスの動作の不完全な理解につながる可能性があります。

サポートフォーラムを検索したり、他の機関の知識に頼ることができます。

しかし、最も善意の個人でさえ、十分な情報不足であるか、一貫性のない答えを提供し、あなたが始めたよりも多くの質問を残します。

これらのリソースはいくつかの助けを提供しますが、全体像ではありません。

APIのより正式で構造化された説明を使用すると、曖昧さを排除するのに役立ちます。

HTTPサービスを定義するためのオープン仕様であるOpenAPIをご紹介します。

OpenAPIは業界標準であり、その広範な採用と成熟度は、APIを操作するのに役立つ確立された慣習とベストプラクティスがあることを意味します。

OpenAPIを使用すると、サービスの動作をYAMLまたはJSONのいずれかで文書化し、これらの機械読み取り可能な形式により、豊富なツールのエコシステムの恩恵を受けることができます。

テスト生成、ランタイム検証、相互運用性などのツールがあります。

OpenAPIが特に知られていることの1つは、インタラクティブなドキュメントを生成するためのツールです。

しかし、OpenAPIの中核的な動機は、採用者がスペック主導の開発を使用できるようにするコード生成です。

APIエンドポイントの例を覚えていますか？

さて、このリクエストを受け取ると、サーバーはJSONオブジェクトでパーソナライズされた挨拶を返します。

コード生成を使用せずに、このAPIを呼び出すために書く必要があるコードを見てみましょう。

まず、そのコンポーネントに変換するサーバーのベースURLを知る必要があります。

次に、パスコンポーネントを追加してAPIエンドポイントを構築し、パラメータをクエリ項目として指定します。

次に、URLRequestを構築し、URLSessionを使用してHTTPリクエストを作成します。

次に、予想されるタイプの応答に、予想されるステータスコードとコンテンツタイプがあることを確認する必要があります。

次に、Decodeableに準拠したSwift型を定義し、JSONDecoderを使用して、応答からバイトをデコードする必要があります。

最後に、応答からメッセージプロパティを返します。

このコードを書くことは問題ありませんが、これは些細なAPI操作のための単一の要求でした。

多くの現実世界のAPIには、豊富なリクエストタイプとレスポンスタイプ、ヘッダーフィールド、パラメータなど、何百もの操作があります。

すべての操作に対してこのコードを書くことは、反復的で、冗長で、エラーが発生しやすくなります。

そして、あなたのコードベースのこの儀式のすべては、あなたのアプリのコアロジックを損ないます。

OpenAPIを使用すると、ツールを使用してこのコードのほとんどを生成できるため、ユーザーがやり取りするコードに集中できます。

サンプルAPIを使用して、OpenAPIドキュメントを探索します。

すべてのOpenAPIドキュメントは、使用しているOpenAPI仕様のバージョンを宣言します。

名前とバージョン、サーバーURLのリストなど、APIに関するメタデータを提供します。

次に、APIを構成するパスとHTTPメソッドを一覧表示します。

このAPIには、 greet パス上の GET メソッドの動作を定義する getGreeting という名前の操作が 1 つだけです。

この例では、サーバーは常にOKのHTTPステータスコードである200で応答し、JSONスキーマを使用して定義されたJSONオブジェクトを返します。

この図では、シンプルにしましたが、操作には異なるステータスコードとコンテンツタイプを持つ複数の応答を持つことができるため、エラーが発生した場合に何が起こるかを含め、すべてのシナリオを文書化できます。

また、操作がパラメータを受け入れる場合、これらはOpenAPIドキュメントに含めることもできます。

この操作は、挨拶をパーソナライズするために使用される文字列値である「name」と呼ばれる1つのオプションのクエリパラメータをサポートしています。

Swift OpenAPI Generatorの助けを借りて、はるかに少ないコードで同じAPI呼び出しを行うことができます。

型安全な入力を使用でき、出力値は豊富な列挙型であるため、コンパイラは文書化されたすべての応答とコンテンツタイプを確実に処理するのに役立ちます。

また、応答本文の関連する値は、型安全なプロパティを持つ値型です。

入力のエンコード、要求の作成、応答の解析、出力のデコードに関連するすべての儀式は、すべて生成されたコードによって処理されます。

Swift OpenAPI Generatorは、ビルド時に実行されるSwift Packageプラグインです。

これは、生成されたコードが常にOpenAPIドキュメントと同期しており、ソースリポジトリにコミットする必要がないことを意味します。

Swiftパッケージプラグインの詳細については、「Meet Swiftパッケージプラグイン」という名前のセッションをチェックしてください。

シンプルなiOSアプリでSwift OpenAPI Generatorを使用する方法を見てみましょう。

このためには、呼び出すことができるAPIが必要になります。

このデモでは、10匹の猫の顔の絵文字の1つをランダムに返すシンプルなAPIを呼び出します。

テンプレートSwiftUIアプリから始めて、サンプルコンテンツを大きな絵文字と、タップするたびにサーバーから新しいものを取得するボタンに置き換えます。

すでにサーバーが実行されており、localhostでリッスンしており、curlを使用してターミナルからクエリできます。

これが素晴らしいAPIであることは否定できない。

しかし、さらに良いのは、OpenAPIを使用して定義されていることです。

非常に異なる種類の猫を使って、このサービスのOpenAPIドキュメントを表示しましょう。

このAPIにはgetEmojiという名前の単一の操作があり、アプリからUIを更新するために呼び出します。

はじめに、Xcodeに切り替えます。

このサンプルiOSアプリには、SwiftUIを使用して定義された基本的なUIがあり、Xcodeのプレビューで見ることができます。

次の数分で、UIコンポーネントを動的コンテンツに置き換え、サーバーから取得します。

また、Swift OpenAPI Generatorを使用して、API呼び出しを行うために手書きしなければならないコードを簡素化します。

まず、必要なパッケージの依存関係をプロジェクトに追加します。

次に、コード生成にプラグインを使用するようにターゲットを設定し、OpenAPIドキュメントとプラグイン設定ファイルをターゲットソースディレクトリに追加します。

プロジェクトが構成されたら、UIコンポーネントを置き換え、生成されたクライアントタイプを使用してサーバーへのAPI呼び出しを行います。

Swift OpenAPI Generatorを使用するようにアプリを設定するには、プロジェクトエディタに移動し、[パッケージの依存関係]タブを選択し、クリックして新しい依存関係を追加します。

このデモでは、ローカルパッケージコレクションを使用していますが、セッションノートでパッケージのURLを見つけることができます。

まず、パッケージプラグインを提供するswift-openapi-generatorへの依存関係を追加します。

次に、生成されたコードで使用される一般的なタイプと抽象化を提供するswift-openapi-runtimeへの依存関係を追加します。

また、生成されたコードは特定のHTTPクライアントライブラリに関連付けられていないため、使用するライブラリの統合パッケージを選択する必要があります。

iOSアプリを構築しているので、URLSessionパッケージを使用しますが、他の例や独自の書き方については、ドキュメントを確認してください。

依存関係があれば、OpenAPI Generatorプラグインを使用するようにターゲットを設定できます。

ターゲット設定で、ビルドフェーズを選択し、「ビルドツールプラグインを実行」という名前のセクションを展開します。

クリックして新しいプラグインを追加し、リストからOpenAPIGeneratorを選択します。

プラグインは、ターゲットのソースディレクトリに2つの入力ファイルを期待しています。OpenAPIドキュメントとプラグイン設定ファイルで、今からプロジェクトに追加します。

プラグインの設定は、プラグインが生成するコードを指定する単純なYAMLスキーマを使用して書かれています。

この場合、OpenAPIドキュメントから派生した再利用可能なタイプである「タイプ」を生成します。

また、任意のHTTPクライアントでAPI呼び出しを行うために使用できるクライアントコードも生成します。

ContentView.swiftに切り替えて、プロジェクトを再コンパイルして、生成されたコードをアプリで使用できるようになります。

セキュリティ対策として、初めて使用するときにプラグインを信頼するように求められます。

プロジェクトを再コンパイルしたので、UIコンポーネントを置き換え、生成されたクライアントタイプを使用してサーバーにAPI呼び出しを行い、ビューを更新することができます。

まず、絵文字のビューに新しい状態プロパティを追加し、プレースホルダ値で初期化します。

次に、地球画像を絵文字を含むテキストビューに置き換え、「Hello, world」メッセージをボタンに置き換え、ビューのボタンスタイルを設定します。

生成されたコードは、API呼び出しを行うために使用できるクライアントという名前の型を提供します。

しかし、まず、OpenAPIランタイムとトランスポートモジュールをインポートする必要があります。

これで、クライアントプロパティをビューに追加し、OpenAPIドキュメントで定義されているローカルホストサーバーURLを使用するように設定する初期化子を追加できます。

次に、このクライアントを使用してサーバーにAPI呼び出しを行う関数を追加します。

APIリクエストを行うために手書きで書く必要があるコードは、それだけです。

他のすべては、生成されたコードによって処理されます。

応答は、文書化されたすべての応答とコンテンツタイプをモデル化するタイプの列挙値であり、すべてのシナリオを処理することを奨励します。

そのため、スイッチステートメントを使用して、応答本文から絵文字を抽出する必要があります。

ここに何かが欠けています。

コンパイラは、すべてのシナリオを処理していないと教えてくれました。

不足しているスイッチケースをXcodeに記入させます。

サーバーがOpenAPIドキュメントで指定されていないもので応答しても、それを優雅に処理する機会があります。

このデモでは、コンソールに警告を印刷し、絵文字を猫以外のものに更新します。

これで、ボタンがタップされたときにこの関数を呼び出すことができます。

また、ボタンを使用して新しい猫の絵文字を取得し、UIを更新することができます。

サーバーに新機能が追加されると、そのAPIは進化します。

また、サーバーがOpenAPIを使用して文書化されている場合、Swift OpenAPI Generatorを使用すると、アプリからこれらの新機能を簡単に使用できます。

OpenAPIドキュメントが進化するにつれて、アプリを更新する方法の例を見てみましょう。

絵文字に関しては、より多くのことなので、複数の絵文字を取得するために使用できる新しいオプションのクエリパラメータ、カウントを取るためにサービスAPIを拡張しました。

1匹ではなく3匹の猫を取得する別のボタンでアプリを拡張します。

まず、OpenAPIドキュメントにパラメータを追加します。

そして、プロジェクトを再コンパイルすると、パラメータはアプリで使用できるようになります。

次に、このパラメータを使用してAPI呼び出しを行う新しいボタンを作成します。

OpenAPIドキュメントに新しいパラメータを追加することから始めます。

このパラメータは「count」という名前です。

これはオプションのパラメータです。

URLクエリの一部として提供され、整数値です。

ContentView.swiftに戻り、updateEmoji関数を拡張してパラメータも取りましょう。

そして、API呼び出しを行うときにこのパラメータを使用しましょう。

ボタンを複製し、ラベルを「More cats」に変更します。

このボタンをタップすると、同じ関数を呼び出しますが、今回は3を数えます。

プレビューでは、「Get cat」をタップして1匹の猫を、または「More cats」をタップして3匹を獲得できます。

この間ずっと、私たちは実際のサーバーにリクエストをしてきましたが、特に開発中は、必ずしも実用的で望ましいとは限りません。

生成されたクライアントタイプはSwiftプロトコルに準拠しているため、ネットワーク接続やトランスポートライブラリを必要としないモックを書くのは簡単です。

生成されたプロトコルはAPIProtocolという名前なので、このプロトコルを採用する新しいMockClientタイプを定義することから始めます。

次に、APIProtocolに準拠した任意のタイプに対してビューをジェネリックに更新し、依存性注入をサポートするように初期化子を更新します。

次に、XcodeでUIをプレビューするときにMockClientを使用します。

MockClientタイプを宣言することから始めます。

このタイプはAPIProtocolを採用すると宣言したため、コンパイラはプロトコル要件を満たしていることを確認します。

XcodeにAPI操作の不足しているハンドラーを追加させます。

そして、ロボットの絵文字を返すビジネスロジックを追加して、実際のサービスと区別します。

これで、このプロトコルに準拠したタイプに対してビューをジェネリックにし、ジェネリックタイプパラメータを使用するようにクライアントプロパティを更新することができます。

クライアントをパラメータとして取る初期化子を追加し、既存の初期化子を一般的なwhere句で更新しますので、クライアントが提供されない場合は、以前と同じものを使用します。

アプリが起動されると、実際のサーバーを使用し続けますが、XcodeでUIをプレビューするときにMockClientを注入できるようになりました。

これで、UIプレビューでボタンをタップすると、猫の代わりにロボットを取得し、ネットワーク接続や実行中のサーバーを必要としません。

モッククライアントを追加するまで、私たちのiOSアプリは私のローカルマシンで実行されている実際のサーバーにリクエストをしていました。

このサーバーはまた、Swift OpenAPI Generatorの助けを借りてSwiftで書かれました。

サーバーは、コード生成にSwift OpenAPI Generatorパッケージプラグインを使用するシンプルなSwiftパッケージです。

生成されたサーバーコードを使用するには、APIProtocolという名前の生成されたプロトコルに準拠したタイプを定義し、API操作のビジネスロジックのみを実装しました。

また、サーバーを設定するために、生成された関数registerHandlersを使用して、API操作の着信HTTPリクエストをビジネスロジックを提供するハンドラーに接続しました。

見てみましょう。 

コンソールを拡張すると、デモiOSアプリからの実際のリクエストを確認できます。

そして、これは私たちがサーバーを実装するために手で書く必要があったすべてのSwiftコードです。

OpenAPIを使用してこのサービスを文書化する代わりに、OpenAPIドキュメントから開始し、Swift OpenAPI Generatorを使用して、API仕様を実装するサーバーの作成を簡素化しました。

生成されたAPIProtocolに準拠し、API運用にビジネスロジックのみを提供するタイプを定義しました。

そして、生成された関数を使用して、そのメソッドをAPIエンドポイントのHTTPサーバーに登録しました。

このデモでは、Swift用のオープンソースのWebフレームワークであるVaporを使用しています。

しかし、生成されたコードは、Swift OpenAPI Generatorの統合パッケージを提供する任意のWebフレームワークで使用できます。

他のオプションや自分で書く方法については、ドキュメントを確認してください。

主な機能では、OpenAPIトランスポートを作成するために使用する新しいVaporアプリケーションを作成します。

次に、ハンドラータイプのインスタンスを作成し、生成されたregisterHandlers関数を使用して、各API操作のHTTPサーバー内のルーティングを設定します。それ以外の場合は、手動で行う必要があります。

最後に、手動で設定したのと同じ方法で、Vaporアプリを実行します。

Swiftはサーバー開発に最適な言語であり、Swiftでバックエンドサービスを書くことについてもっと知りたい場合は、「サーバーサイド開発にXcodeを使用する」という名前のセッションをチェックしてください。

Swift OpenAPI Generatorを使用するようにパッケージがどのように構成されているかを見てみましょう。

サーバーはSwiftパッケージとして実装され、Package.swiftファイルを使用して定義されます。

このパッケージには、Swift OpenAPI Generatorプラグインを使用するCatServiceと呼ばれる単一の実行可能ターゲットがあります。

生成されたサーバーコードは、ランタイムライブラリからの共通のタイプと抽象化に依存し、統合パッケージを提供する任意のWebフレームワークで使用できるため、このターゲットはswift-openapi-runtime、swift-openapi-vapor、およびvapor itselfに依存しています。

ターゲットソースディレクトリに、デモiOSアプリで使用したのと同じOpenAPIドキュメントとプラグイン設定ファイルを追加しました。

このターゲットでは、タイプとサーバースタブを生成しています。

スペック主導の開発により、このサービスに新機能を追加する方法を簡単にする方法を見てみましょう。

猫の絵文字は素晴らしいですが、多くの証拠が、インターネットが主に猫のビデオの交換のために構築されたことを示唆しているので、その機能をサーバーに追加します。

スペック主導の開発では、新しいAPI操作を追加するには2つのステップしか必要ありません。

まず、OpenAPIドキュメントに新しい操作を追加します。

次に、生成されたプロトコルに新しい関数要件があるため、コンパイラはハンドラでメソッドを定義し、ビジネスロジックを実装することを主張します。

始める前に、ターゲットのリソースフォルダに追加した猫のビデオが必要です。

OpenAPIドキュメントに向かい、新しい操作を追加します。

この操作はgetClipと呼ばれ、応答本文にビデオデータが含まれていることを示すコンテンツタイプのバイナリ応答があります。

パッケージを再コンパイルしようとすると、失敗します。

これは、ハンドラが生成されたプロトコルに準拠しなくなったためです。なぜなら、新しい操作のための機能を提供していないからです。

Xcodeにプロトコルスタブを記入させ、ビデオリソースファイルからバイトを読み取り、バイナリボディでOK応答を返すビジネスロジックを提供します。

タイプセーフ生成コードは、この操作のOpenAPIドキュメントで指定されているため、この関数からバイナリ応答本文のみを返すことができることに注意してください。

パッケージを再コンパイルすると、成功し、サーバーを再起動できます。

また、Safariに切り替えると、新しいAPIエンドポイントをテストできます。

そのため、OpenAPIを使用してサービスを文書化することで、あいまいさを排除し、仕様主導の開発を可能にする方法を見てきました。

Swift OpenAPI GeneratorがiOSアプリのサーバーAPIの操作を簡素化する方法を示しました。

最後に、Swiftの言語機能と成長するSwift-on-serverエコシステムがどのようにバックエンドサービスを実装するための素晴らしい選択であるかを見てきました。

だからこそ、Swift OpenAPI Generatorはオープンソースであり、GitHubで利用でき、成長を続けるにつれてプロジェクトにもっと学び、貢献することさえできます。

このセッションを見てくれてありがとう。

ニャー、それだけ！