10136

♪ ♪

クリストファー:こんにちは、ようこそ!

私の名前はクリストファーで、ScreenCaptureKitチームのソフトウェアエンジニアです。

同僚のナタリー・リンゼイが参加し、アプリケーションのスクリーンキャプチャ機能を強化する新機能を紹介します。

ScreenCaptureKitは、アプリケーションの画面共有体験を作成するために、macOS 12.3で導入されました。

ScreenCaptureKitは、共有したいコンテンツをカスタマイズできるAPIと、アプリケーションのニーズに合ったコントロールを提供し、そのすべてをストリームに動的に適用できます。

このフレームワークは、グローバルなセーフガードでプライバシーを念頭に置きながら、ディスプレイのネイティブ解像度とフレームレートまでのパフォーマンスに焦点を当てた高品質のコンテンツを提供します。

今年、ScreenCaptureKitは、新しいmacOS機能と統合するいくつかの開発者APIを提供します。

プレゼンターオーバーレイは、キャプチャされたコンテンツに自分自身を埋め込むことで、画面共有やプレゼンテーションをより個人的なものにできる機能です。

新しい画面共有ピッカーを使用すると、画面共有でキャプチャした内容にシステム全体のエクスペリエンスを統合できます。

最後に、スクリーンキャプチャはライブストリームだけでなく、今年は、選択したコンテンツの高解像度スクリーンショットをキャプチャできる新しいAPIがあります。

人々は世界中で毎日交流しています。

これらの相互作用は、私たちの考えやアイデアを共有し、重要な問題を解決する場所です。

彼らはプロフェッショナルで個人的です。

この目的のために、あなたのアプリはプレゼンターオーバーレイと呼ばれる新しいビデオエフェクトでシームレスに動作することができます。

コンテンツを共有するとき、プレゼンターオーバーレイは、共有コンテンツの上にプレゼンターを含めることでプレゼンターの存在感を高め、より生産的なリモートコールのための個人的なタッチを追加します。

小さなオーバーレイは、高度なセグメンテーションアルゴリズムのおかげで、プレゼンターを可動ウィンドウに配置し、大きなオーバーレイはプレゼンターの顔と体を背景から分離し、より没入感のある効果のためにそれらの間に画面コンテンツを重ねます。

プレゼンターオーバーレイは、ScreenCaptureKitを使用するすべてのアプリケーションで利用できます。

作成されたSCStreamごとに、ScreenCaptureKitは画面共有ピッカーに通知し、ストリームのコントロールを含むライブプレビューが新しいビデオメニューバー項目に表示されます。

ビデオメニューバーには、アクティブなストリームを持つすべてのアプリケーションが表示され、任意のアプリケーションに関連付けられたストリームのライブプレビューが表示されます。

このメニューバーから、ストリーム全体の画面共有ピッカーを表示することで、ストリームコンテンツを制御できます。

これは、プレゼンターオーバーレイが有効になっている場所でもあり、カメラフレームをコンテンツストリームに埋め込みます。

また、これを使用して、画面共有を置き換えたり終了したりするなど、ストリームを制御することもできます。

ここには、カメラとマイクの効果をカスタマイズするための他の便利な機能があります。

ScreenCaptureKitとカメラを一緒に使用するすべてのアプリケーションは、これらの機能を自動的に機能させます。

現在、ストリームにはScreenCaptureKitからプロセスに送信されたコンテンツフレームがあります。

これで、アプリケーションがアクティブなストリーム中にカメラの使用を開始すると、プレゼンターオーバーレイがビデオメニュー項目で利用可能になります。

有効にすると、ScreenCaptureKitはカメラを取り、アプリケーションがすでに実行されている選択したストリームにレンダリングを適用します。

アクティブなストリームから合成フレームが自動的に取得されます。

では、プレゼンターオーバーレイがいつ適用されたかを明示的に知りたい場合はどうなりますか?

新しいストリームを作成し、自己をデリゲートとして追加することから始めましょう。

次に、SCStream、outputEffectDidStartに新しいデリゲートコールバックを実装します。

これは、プレゼンターオーバーレイが適用されたときに通知される方法です。

通知されたら、効果が開始されたか停止したかを確認したいと思う。

プレゼンターオーバーレイは、新しいmacOSシステム機能であり、オーバーレイが適用されたときにアプリケーションが取りたいと思ういくつかの考慮事項があります。

プレゼンターオーバーレイをオンにすると、AVCaptureSessionは一般的なライブカメラストリームを送信しません。

それは、あなたのカメラがオーバーレイで直接使用されるからです。

これは、この変更を考慮してアプリケーションUIを更新する絶好の機会です。

たとえば、ビデオ会議アプリケーションは、共有コンテンツがカメラと混在していることを考慮して、オーディオとビデオの同期を調整したい場合があります。

また、より最適化された外観のために、プレゼンターのカメラタイルを非表示にすることもできます。

プレゼンターオーバーレイはカメラとビデオ機能なので、アプリケーションはより高いフレームレートのために最適化する必要があります。

プレゼンターオーバーレイに加えて、新しいシステム全体の画面共有ピッカーを利用することもできます。これにより、アプリケーションは、ユーザーが共有したいコンテンツを選択する方法を中心としたいくつかの機能と完全に統合できます。

これらは、ストリームの作成に使用する一般的な構造です。

現在、SCSharableContentに電話して、共有できる利用可能なすべての画面コンテンツを取得します。

それを使用してSCContentFilterを作成します。

SCContentFilterは、キャプチャするものを決定するために使用するものです。

現在、あなたはそれをSCSharableContentから構築していますが、今年はピッカーを通じてコンテンツフィルターを取得できます。

ピッカーがSCContentFiltersを生成するには2つの方法があります。

まず、目的のコンテンツはシステムピッカーを通じて共有できます。

第二に、コンテンツは開いているウィンドウから直接選択できます。

どちらの場合も、システムはSCContentFilterをアプリケーションと共有します。

しかし、どのようにして新しいコンテンツフィルターをアプリケーションに取り込むのですか?

新しいAPI、SCContentSharingPickerを使用することで。

SCContentSharingPickerは、アプリケーションとOSの間のインターフェイスとして機能し、新しいストリームリクエスト、新しいコンテンツフィルタ、現在のストリームとコンテンツフィルタの更新をアプリケーションにデリゲートコールバックします。

SCContentSharingPickerには、ウィンドウ、アプリ、さらにはディスプレイに基づいてコンテンツを選択できるシステムレベルのコンテンツピッカーが組み込まれています。

アプリケーションのボタン、新しいビデオメニューバー、またはウィンドウから直接コンテンツの選択を開始するかどうかにかかわらず、アプリケーションはSCContentSharingPickerを利用して、進行中のストリームのアクティブな選択を追加、削除、または置き換えることができます。

また、新しいストリームがいつ要求されるかをアプリケーションが知ることができるストリームリクエストコールバックも組み込まれています。

そして最後に、ストリームごとのカスタマイズが付属しており、システムエクスペリエンスが各ストリームにどのように適用されるかを定義できます。

SCStreamのフィルタを取得するための構造は、SCSharableContentの使用から、SCContentSharingPickerシングルトンを使用したシステムピッカーインターフェイスを使用してSCContentFilterを渡すようになりました。

アプリケーションがこの新しい画面共有ピッカーを利用するのがいかに簡単かをお見せしましょう。

SCContentSharingPickerの共有インスタンスから始めて、selfをオブザーバーとして追加して、すべての適切なクラスコールバックを取得できます。

システムが私のピッカーインスタンスを認識するには、アクティブに設定します。

アクティブになると、システムはピッカーについて知り、アプリケーションはシステムUIに含まれ、人々はそれと対話できるようになります。

人々がピッカーを介してウィンドウを選択できるストリームを作成したいので、singletonメソッドpicker.presentを呼び出し、nilと提示したいピッカーのスタイルをパスします。

ユーザーがUIボタンを押すと、ピッカーが表示され、キャプチャしたいウィンドウを選択できます。

そのコンテンツが選択されると、新しいフィルタのオブザーバーコールバックを介して通知されます。

そして、新しいストリームを作成したり、このフィルターを使用して既存のストリームを更新したりできるようになりました。

残りのオブザーバーコールバックも同様に重要です。

ピッカーをアクティブにして提示することで、ピッカーを再度設定します。

また、提示を依頼したときにピッカーが失敗したかどうかも知りたいでしょう。

失敗した場合は、アプリケーションに通知を投稿して人々に通知する必要があります。

また、ピッカーが提示されたがキャンセルされた場合、つまりコンテンツが選択されなかった場合は、それに応じてストリームの状態を設定する必要があります。

SCContentSharingPickerには、ストリームごとのレベルでシステムがどのように動作するかをカスタマイズできるメソッドも付属しています。

SCContentSharingPickerConfigurationでは、いくつかのカスタマイズが可能です。

AllowedPickingModesは、ウィンドウ、アプリケーション、およびコンテンツフィルタの表示選択の間でどのピッキングモードが許可されているかをシステムに伝えます。

また、システムエクスペリエンスで選択できない除外WindowIDとbundleIDの明示的な宣言も可能です。

ユーザーが変更したくないストリームがある場合、SCContentSharingPickerConfigurationにはその機能を強制できるプロパティがあります。

まず、共有ピッカーインスタンスを取得します。

自己をオブザーバーとして追加し、ピッカーをアクティブに設定することから始めます。

次に、適切な構成設定を設定します。

このストリームでは、2つの特定のアプリケーションの選択を除外し、再選択を許可したくないかもしれません。

設定が設定されたら、ピッカーで設定設定を呼び出し、設定とアプリケーティブストリームを渡します。

これで、ピッカーは特定のストリームに対してどのように振る舞うかを正確に知ることができます。

また、各ストリームは、アプリケーションのニーズに合わせて異なるピッカー構成を持つ可能性があることに注意してください。

要約すると、すべてのScreenCaptureKitストリームがmacOSエクスペリエンスに統合され、どのアプリケーションでもプレゼンターオーバーレイなどの新機能を活用できるようになりました。

そして、アプリケーションを新しいシステムピッカーUIに統合するための新しいAPIであるSCContentSharingPickerを紹介しました。

しかし、アプリケーションでの画面キャプチャはライブストリームだけではないので、この新しいスクリーンショットAPIについてもっと話すために、同僚のナタリーに渡したいと思います。

ナタリー:ありがとう、クリストファー。

今年は、ScreenCaptureKitに新しいAPIがあり、画面から静止画を簡単に取得できるように設計されています。

新しいスクリーンショットAPIは、スクリーンショットにScreenCaptureKitストリーミングの利点をもたらします。

アプリやウィンドウによる高度なフィルタリング、複数のピクセルフォーマットや色空間、カーソルの可視性などの他のオプションなどの機能が利用できます。

これで、使い慣れたScreenCaptureKit構造を使用して、必要な正確な画面コンテンツの画像を効率的に取得できるようになります。

新しいAPIは非同期です。

出力画像では、CMSampleBufferまたはCGImage形式から選択できます。

CMSampleBufferオプションには、追加のピクセルフォーマットが利用可能で、特定のフォーマットに興味がある場合に最適です。

コードでCGImageをすでに使用している場合は、この形式を使用すると統合が容易になります。

どちらのフォーマットでも、スクリーンショットはScreenCaptureKitストリーミングとほぼ同じ構成オプションを使用し、同様のセットアップフローに従います。

CGWindowListCreateImageを使用している場合、ScreenCaptureKitへの移行を容易にするものがいくつかあります。

CGWindowList APIで利用可能なすべてのウィンドウ画像オプションは、ScreenCaptureKitのSCStreamConfigurationクラス内にあります。

特定のウィンドウID上のすべてのウィンドウを取得するなど、ウィンドウリストのオプションは、SCShareableContent内で提供されます。

また、CGImage出力での作業に慣れている場合、新しいスクリーンショットAPIは、既存のコードに簡単に統合できるCGImage出力形式を提供します。

スクリーンショットを撮ることは、ScreenCaptureKitストリーミングと同様のフローに従いますが、SCStreamを作成する代わりに、スクリーンショットAPIを呼び出します。

まず、ストリームの作成と同様に、SCShareableContentを使用して目的のコンテンツを取得し、SCContentFilterを作成します。

スクリーンショットにすべてのオプションを使用してSCStreamConfigurationを設定することを忘れないでください。

コンテンツフィルタとストリーム設定が完了したら、スクリーンショットAPIを呼び出すと、それらを渡します。

APIはSCScreenshotManagerクラスのクラスメソッドであるため、スクリーンショットを撮るためにSCScreenshotManagerオブジェクトを作成する必要はありません。

スクリーンショット画像の準備ができたら、選択した形式で非同期に返されます。

また、新しいシステムピッカーを使用してコンテンツフィルタを作成し、それを使用してスクリーンショットAPIを呼び出すこともできます。

これは、人々が直感的な方法で必要なコンテンツを選択できるようにする素晴らしい方法です。

スクリーンショットを撮るときは、必要なものに応じて、APIの2つのバージョンから選択できます。1つはCMSampleBuffer出力タイプ用、もう1つはCGImage出力タイプ用です。

それ以外は、2つのバージョンは同じように動作し、スクリーンショットを非同期に返します。

以下は、スクリーンショットAPIの使用方法のコード例です。

SCContentFilterとSCStreamConfigurationを設定することから始めます。

それらの準備ができたら、スクリーンショットAPIを呼び出すことができ、それが戻ってくるのを待つと、スクリーンショットを取得します。

そして、それがScreenCaptureKitの新機能のすべてです。

要約すると、システムレベルのUIを使用してアプリケーションと完全に統合された画面共有エクスペリエンスを作成するSCContentFiltersを作成する新しいAPIがあります。

新しいプレゼンターオーバーレイビデオエフェクトは、よりダイナミックな画面共有体験を提供し、新しいスクリーンショットAPIを使用すると、ScreenCaptureKitの力で1回限りのスクリーンキャプチャを取得できます。

ScreenCaptureKitの詳細については、昨年のセッション「Meet ScreenCaptureKit」と「ScreenCaptureKitを次のレベルに引き上げる」を必ずチェックしてください。

見てくれてありがとう。