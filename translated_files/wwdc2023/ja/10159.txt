10159

♪ ♪

ハリー：こんにちは、私はSwiftUIチームのエンジニア、ハリーです。

Beyond Scroll Viewsへようこそ。SwiftUIのスクロールビューの新しい改善について説明します。

私たちのデバイスがやりたいことは、固定画面サイズに含めることはめったにありません。

この複雑さに対処する方法の1つは、スクロールを導入することです。

これにより、画面に収まらないものをすべて表示できます。

SwiftUIは、スクロールを自分のアプリに統合できるいくつかの異なるコンポーネントを提供しています。

今日は、これらのコンポーネントの1つについて話します。

スクロールビュー。

ScrollViewは、コンテンツをスクロールできるビルディングブロックです。

スクロールビューには、スクロール可能な方向を定義する軸があります。

スクロールビューにはコンテンツがあります。

そのコンテンツがScrollViewのサイズを超えると、そのコンテンツの一部がクリップされ、人々はそれを表示するためにスクロールする必要があります。

スクロールビューは、セーフエリアをそのコンテンツをアウトセットする余白に解決することによって、コンテンツがセーフエリア内に配置されていることを確認します。

ScrollViewは、デフォルトでコンテンツを熱心に評価します。

遅延スタックを使用して、この動作を変更できます。

コンテンツ内でScrollViewがスクロールされる場所の正確な位置は、コンテンツオフセットと呼ばれます。

SwiftUIは、コンテンツオフセットを制御する方法としてScrollViewReader APIを提供しました。

今年、SwiftUIは、ScrollViewによって管理されるコンテンツオフセットに影響を与え、反応するより多くの方法を導入しています。

この講演では、ScrollViewのマージンに影響を与える方法と、それらが安全なエリアとどのように関連しているかについて議論することから始めます。

次に、スクロールターゲットとスクロール位置によるScrollViewのコンテンツオフセットの管理について説明します。

最後に、スクロールトランジションでアプリに本当の才能を追加する方法を紹介します。

私がColorsアプリを作り始めて以来、私のユーザーは私のお気に入りの色の組み合わせのいくつかを私に見せるのが本当に好きでした。

他の人が楽しめるように、これらの組み合わせのいくつかを特集したいと思います。

これを行うために、私はColorsアプリにギャラリー機能を追加することに取り組んできました。

私はすでに私のギャラリーの実装でいくつかの進歩を遂げました。

この講演を通して、私はギャラリーの特集セクションのヘッダーと内容の両方を磨きます。

私のギャラリーでは、怠惰なスタックを包む水平スクロールビューがあります。

まず、このビューをいくつかの余白で少しきれいに見せます。

あなたの最初の本能は、ScrollViewにパディングを追加することかもしれません、そしてこれはScrollViewを挿入しますが、スクロールするときにそのコンテンツがクリップされていることに注意してください。

ScrollView自体を設定する代わりに、ScrollViewのコンテンツマージンを拡張したいと思います。

私は新しい安全なエリアパディング修飾子でそれを行うことができます。

これは通常のパディング修飾子のように動作しますが、コンテンツをパディングする代わりに、安全な領域にパディングを追加します。

これで、私のScrollViewは全体の幅を拡大し、次のアイテムを覗くことができます。

先に進む前に、ScrollViewに関連する安全な領域について少し話します。

安全なエリアは、最も一般的には、アプリが実行されているデバイスから来ています。

また、セーフエリアパディングやセーフエリアインセット修飾子などのAPIからも来ることができます。

ScrollViewは、セーフエリアをコンテンツに適用する余白に解決します。

これには、あなたが責任を負うコンテンツだけでなく、スクロールビューが担当するスクロールインジケーターなどの追加コンテンツも含まれます。

これは、セーフエリアを変更することで、異なる種類のコンテンツに対して異なるインセットを設定することができないことを意味します。

異なるインセットを適用したい場合は、新しいcontentMargins APIを使用できます。

このAPIを使用すると、スクロールインジケーターとは別にScrollViewのコンテンツを挿入できます。

または、コンテンツとは別にインジケーターを挿入します。

ギャラリーに戻って、セーフエリアのパディング修飾子を更新して、コンテンツマージンAPIを使用します。

私のビューに少し余白が適用されたので、私がやりたいことの1つは、誰かが指を離すとScrollViewがスクロールするコンテンツのオフセットを制御することです。

デフォルトでは、ScrollViewはスクロールの速度とともに標準の減速速度を使用して、スクロールが終了するターゲットコンテンツのオフセットを計算します。

ScrollViewのサイズやそのコンテンツなどを考慮していません。

しかし、時にはそれらのことが重要です。

SwiftUIの新機能では、ScrollViewがこのターゲットコンテンツのオフセットを計算する方法をscrollTargetBehavior修飾子で変更できます。

この修飾子は、scrollTargetBehaviorプロトコルに準拠した型を取ります。

ここでは、ページングの動作を指定しました。

今、私のScrollViewは一度に1ページずつスワイプします。

ページングの動作は特別です。

カスタム減速率があり、ScrollView自体の包含サイズに基づいてスクロールする場所を選択します。

これはiOSではうまく機能しますが、iPadOSの大きな画面では少し大きくなります。

ScrollViewの包含サイズに整列する代わりに、個々のビューに整列したいと思います。

ビューの整列動作はScrollViewをビューに整列させるので、ScrollViewは整列のためにどのビューを考慮すべきかを知る必要があります。

これらのビューはスクロールターゲットと呼ばれ、どのビューがスクロールターゲットであるかを指定できる新しい修飾子ファミリーがあります。

ここでは、スクロールターゲットレイアウト修飾子を使用して、遅延スタック内の各ヒーロービューをスクロールターゲットとみなします。

スクロールターゲット修飾子を使用して、個々のビューをターゲットとしてマークすることもできます。

しかし、レイジースタックを使用する場合は、スクロールターゲットレイアウト修飾子を使用することが重要です。

可視領域外のビューはまだ作成されていません。

ただし、レイアウトはどのビューを作成するかを知っているので、ScrollViewが正しい場所にスクロールするようにすることができます。

今、私のScrollViewはiPadでずっと良く見えます。

ページングとビューの整列動作は、新しいScrollTargetBehaviorプロトコルに基づいて構築されています。

SwiftUIはこれらの一般的な動作を提供しますが、以前に導入されたレイアウトプロトコルを採用するのと同様に、独自のタイプをこのプロトコルに適合させ、独自のカスタム動作を実装することもできます。

必要なメソッドを1つ実装して、ScrollTargetBehaviorに独自のタイプを適合させます: updateTarget。

SwiftUIは、スクロールが終了する場所を計算するときにこのメソッドを呼び出しますが、ScrollViewがサイズを変更したときなどの他のコンテキストでも呼びます。

動作のカスタマイズは簡単です。

ここで、ターゲットがScrollViewの上部に近く、スクロールが上にフリックされている場合は、提供されたターゲットを変更して、ScrollViewの正確な上部までスクロールすることを好みます。

これにより、ScrollViewはスクロールの終点として別のコンテンツオフセットを選択します。

そして、ScrollViewがスクロールすることを選択した場所に影響を与えるために、私自身のカスタムコードを挿入するために必要なのはそれだけです。

私のギャラリービューに戻りましょう。

レイアウトについて話したいのですが。

私のヒーロービューは、デバイスの全体的な幅に関連してサイズが設定されていることに注意してください。

そして、iPadを見ると、2つのビューがデバイスの幅に均等に収まります。

以前は、これを達成するためにGeometryReaderを使用する必要がありましたが、今年はSwiftUIがcontainerRelativeFrame修飾子と呼ばれる新しいAPIでこれをはるかに簡単にします。

私のヒーロービューがこのAPIをどのように使用しているかをお見せします。

固定高さを指定するフレーム修飾子とともに、カラービューのスタックから始めます。

containerRelativeFrame修飾子をビューに追加します。

ここでは、ビューがコンテナの幅を取ることができる水平軸を指定します。

私の場合、コンテナは周囲のScrollViewになりますが、ナビゲーション分割ビューの最も近い列、またはアプリのウィンドウである可能性があります。

コンテナの幅が変わると、ビューのサイズが自動的に更新されます。

カウントと間隔を指定することで、これらのビューのグリッドのようなレイアウトを作成できます。

水平サイズクラスに基づいてカウントを条件付けして、iPadに2つの列、電話で1つの列を持つことができます。

さらに良いのは、水平sizeClass環境プロパティがすべてのプラットフォームで利用可能になったため、OSの条件を削除できることです。

最後に、固定高さをハードコーディングするのではなく、幅に対して相対的な高さを持つために、aspectario修飾子を使用します。

だから、ギャラリーのレイアウトとスクロールの動作を完成させました。

もう少し変更を加えたいことがあります。

あなたが気づくことの1つは、スクロールインジケーターです。

それらを削除したいのですが。

既存のscrollIndicators APIを使用してこれを達成できます。

これはiPadで指をスワイプするときに素晴らしく見えますが、私はよくMacでギャラリーを使います。

また、Macでは、マウスやその他の入力デバイスを使用するときのように、水平方向のスワイプジェスチャーを簡単に実行できないかもしれません。

そして、マウスを接続すると、非表示にするように要求したにもかかわらず、インジケーターが表示されます。

マウスを使用すると、スクロールインジケーターなしでスクロールが困難または不可能になる可能性があります。

このため、scrollIndicators修飾子のデフォルトの動作は、トラックパッドなどのより柔軟な入力デバイスを使用するときにインジケーターを非表示にすることですが、マウスが接続されているときにインジケーターを表示できるようにすることです。

scrollIndicators修飾子にneverの値を指定して、入力デバイスに関係なく常にインジケーターを非表示にすることができます。

しかし、私のアプリはまだマウスを使用する人々をサポートする必要があります。

だから、私は彼らのために私のギャラリーをスクロールする別の手段を提供する必要があります。

スクロールインジケーターの代わりに、ユーザーがクリックで前または次のビューにスクロールできるビューをレンダリングします。

それを構築し始めるために、私のScrollViewを少しクリーンアップしましょう。

ヘッダービューでScrollViewをVStackに移動します。

次に、ヘッダービューに焦点を当てます。

ヘッダービューにカスタムパドルビューを追加します。

過去のバージョンのSwiftUIでは、ScrollViewReaderに手を伸ばしてパドルに渡して適切なビューにスクロールしただろう。

しかし、SwiftUIの新機能はscrollPosition修飾子です。

この修飾子は、識別子をラップする状態へのバインディングを関連付けます。

私はそれを、ScrollViewが読み取る私のscrollPosition修飾子に渡し、私のヘッダービューに渡します。

ヘッダービューのパドルでは、他の状態と同じようにバインディングに書き込むことができます。

バインディングが書き込まれると、ScrollViewはそのIDでビューにスクロールします。

View aligned ScrollTargetBehaviorと同様に、スクロール位置モディファイアは、スクロールターゲットレイアウトモディファイアを使用して、アイデンティティ値を照会するためにどのビューを検討するかを知る。

スクロール位置修飾子を使用すると、現在スクロールされているビューのアイデンティティを知ることもできます。

そのため、現在スクロールされているヒーロー画像の値を示すテキストをヘッダービューに追加できます。

ScrollViewで最も主要なビューが変更されると、バインディングは自動的に更新されます。

今、私のマウスユーザーは私のギャラリーをスクロールすることができます。

このビューに追加したい磨く最後のビットがあります。

どのビューが現在スクロールされているかを知るのが便利なように、スクロールビュー内のどこにあるかに基づいてビューを視覚的に変更したい場合があります。

SwiftUIにはScrollTransitionsと呼ばれる新しいAPIがあり、これを本当に簡単にします。

スクロールトランジションは、通常のトランジションによく似ています。

トランジションは、ビューが出現または消滅したときに受けるべき変更を記述します。

ビューが表示されたとき、それはカスタマイズを適用すべきではないアイデンティティ段階にあります。

ScrollTransitionは、同様の一連の変更をトランジションとして記述しますが、代わりにビューがScrollViewの可視領域に入り、可視領域を離れるときにそれらを適用します。

デフォルトでは、ビューが可視領域の中央にある場合、ScrollTransitionのアイデンティティフェーズにあります。

私のヒーロービューの文脈でこれを見てみましょう。

ScrollTransitionsに集中するために、これを少しクリーンアップします。

ビューがScrollViewの端に近づくと、サイズを少し縮小したいと思います。

scrollTransition修飾子を追加することから始めます。

このAPIは、コンテンツとフェーズを取り、フェーズに基づいてコンテンツの視覚的な変更を指定できます。

ここでは、ビューがアイデンティティフェーズにない場合のスケールの縮小を指定します。

それは素晴らしいですね！

ScrollTransitionsは、VisualEffectと呼ばれる新しいプロトコルで動作します。

このプロトコルは、スクロールビューのコンテンツオフセットなどのレイアウトの機能として安全に使用できるビューコンテンツの一連のカスタマイズを提供します。

それらの多くはあなたに見覚えがあるかもしれません。

あなたはすでにスケール効果について知っています。

ビュー修飾子と同じように、回転やオフセットをカスタマイズすることもできます。

ただし、すべてのビュー修飾子がscrollTransition内で安全に使用できるわけではありません。

たとえば、フォントのカスタマイズはサポートされておらず、ビルドされません。

ScrollViewの全体的なコンテンツサイズを変更するものは、scrollTransition修飾子内で使用することはできません。

うわー、私たちは多くのことをカバーしたので、簡単なレビューをしましょう。

セーフエリアとcontentMarginsの違いと、ScrollViewsとの関係について話しました。

ページングとビューで整列されたscrollTargetBehaviorsを使用して、ScrollViewの動作に影響を与える方法と、scrollTargetBehaviorプロトコルに独自の適合性を書き込む方法を示しました。

containerRelativeFrame修飾子を使用して、コンテナを基準にしてレイアウトを作成するのがいかに簡単かを学びました。

scrollPosition修飾子を使用してScrollViewの状態に接続し、プログラムでスクロールし、どのビューが現在スクロールされているかを知らせることができました。

そして最後に、scrollTransition APIを使用してScrollViewのコンテンツオフセットに基づいて視覚効果を作成しました。

ScrollViewsのこれらの改善について学ぶことを楽しんだことを願っています。

ありがとう、そして素晴らしいWWDCをお過ごしください。

♪ ♪