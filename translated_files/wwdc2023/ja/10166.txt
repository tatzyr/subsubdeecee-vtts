10166

♪ ♪

アレックス・ホッペン:誰が反復的な定型コードを書くのが好きですか?

誰もしない！

だからこそ、Swift 5.9ではSwiftマクロを導入しています。

Swiftマクロを使用すると、コンパイル時にその繰り返しコードを生成できるため、アプリのコードベースがより表現力豊かで読みやすくなります。

私の名前はアレックス・ホッペンです。今日は、自分のマクロを書く方法を紹介します。

まず、マクロの仕組みの概要をお伝えします。

その後、Xcodeに直接ジャンプして、最初のマクロを作成する方法を確認します。

Xcodeで最初のマクロを見たので、マクロを使用できるより多くの役割を探求し、現在取り組んでいるアプリのコードベースを簡素化するためにマクロをどのように使用したかを紹介します。

最後に、特定のコンテキストで適用されない場合、マクロがエラーや警告をコンパイラに通信する方法を紹介します。

では、始めましょう。

ここでは、1年生が算術スキルを練習するために使用できる計算のリストがあります。

結果は左側に整数として、計算はタプルの右側に文字列リテラルとしてあります。

結果が実際に計算と一致することを誰も保証できないので、これが反復的で、冗長で、さらにはエラーになりやすいことに注目してください。

幸いなことに、Swift 5.9では、これを簡素化するために文字列化マクロを定義できます。

このマクロは、たまたまXcodeのテンプレートに含まれているマクロでもあります。

Stringifyマクロは、計算を単一のパラメータとしてのみ取ります。

コンパイル時に、以前に見たタプルに拡張され、計算と結果が一致することを保証します。

では、これはどのように機能しますか?

マクロ自体の定義を見てみましょう。 マクロ自体の定義を見てみましょう。

関数によく似ていることに注目してください。

Stringifyマクロは、入力パラメータとして整数を受け取り、結果、整数、および計算文字列を含むタプルを出力します。

マクロ式の引数がマクロのパラメータと一致しない場合、または自分でチェックをタイプしない場合、コンパイラはマクロ展開を適用せずにエラーを発行します。

たとえば、このマクロに文字列リテラルを渡すと、コンパイラは「String」が期待される引数型「Int」に変換できないと訴えます。

これは、たとえば、タイプチェック前のプリプロセッサ段階で評価されるCマクロとは異なります。

しかし、マクロをジェネリックにできるなど、Swift関数からあなたが知っていて愛しているすべての力を使うことができます。

また、このマクロは自立式マクロの役割で宣言されていることに注意してください。

これは、式を使用できる場所であればどこでもマクロを使用できることを意味し、#stringifyで見られるように、ハッシュ文字で示されます。

他の種類のマクロは、宣言を拡張できるアタッチされたマクロです。

それらを後でカバーします。

すべての引数がマクロのパラメータと一致することを確認した後、コンパイラはマクロ展開を実行します。

それがどのように機能するかを見るために、単一のマクロ式に焦点を当てましょう。

拡張を実行するために、各マクロはコンパイラプラグインでの実装を定義します。

コンパイラは、マクロ式全体のソースコードをそのプラグインに送信します。

マクロプラグインが最初に行うことは、マクロのソースコードをSwiftSyntaxツリーに解析することです。

このツリーは、マクロのソースの正確な構造表現であり、マクロが動作する基礎になります。

たとえば、「stringify」マクロは、マクロ展開式ノードとしてツリーで表されます。

その式にはマクロ名「stringify」があります。

そして、2と3に適用される中置演算子プラスである単一の引数が必要です。

Swiftマクロの本当に強力なのは、マクロの実装自体がSwiftで書かれたプログラムであり、必要な構文ツリーへの変換を実行できることです。

私たちの場合、前に見たようなタプルを生成します。

その後、生成された構文ツリーを再びソースコードにシリアライズし、コンパイラに送信し、マクロ式を拡張コードに置き換えます。

それは本当にクールですが、今、私はこれらすべてが実際にコードでどのように見えるかを理解したいです。

Xcodeの新しいマクロテンプレートは、先ほど見たstringifyマクロを定義します。

そのテンプレートを見て、マクロの定義、拡張の仕組み、マクロのテスト方法を探りましょう。

テンプレートを作成するには、[ファイル]、[新規]、[パッケージ]をクリックし、Swiftマクロテンプレートを選択します。

最初のマクロを「WWDC」と呼びましょう。

では、テンプレートで何を得るのですか?

ここでは、以前に見たものと同様に、#stringifyマクロの呼び出しがあります。

パラメータ「a + b」を受け取り、結果とそれを生成したコードを返します。

マクロが何に展開されるのかを知りたい場合は、マクロを右クリックして[マクロを展開] を選択できます。

それはまさに私たちが前に見たものです。

しかし、マクロはどのように定義されていますか?

その定義にジャンプしましょう。

ここでは、以前の「stringify」マクロのわずかに一般化されたバージョンがあります。

整数を取る代わりに、このマクロは一般的であり、任意のタイプTを受け取ることができます。

マクロは外部マクロとして宣言されています。

これは、拡張を実行するには、WWDCMacrosモジュールのStringifyMacroタイプを調べる必要があることをコンパイラに伝えます。

そのタイプはどのように定義されていますか?

詳しく見てみましょう。そしてもっと詳しく見てみましょう

stringifyは自立式マクロとして宣言されているため、StringifyMacroタイプはExpressionMacroプロトコルに準拠する必要があります。

このプロトコルには、拡張機能という単一の要件があります。

マクロ式自体の構文ツリーと、コンパイラとの通信に使用できるコンテキストを取ります。

その後、展開関数は書き換えられた式構文を返します。

それは実装で何をしますか?

最初は、単一の引数をマクロ式に取得します。

Stringifyは単一のパラメータを取ると宣言され、マクロ展開を適用する前にすべての引数をタイプチェックする必要があるため、この引数が存在することを知っています。

次に、文字列補間を使用してタプルの構文ツリーを作成します。

最初の要素は引数自体で、2番目の要素は引数のソースコードを含む文字列リテラルです。

関数がここで文字列を返していないことに注意してください。

式構文を返しています。

マクロは自動的にSwiftパーサーを呼び出して、このリテラルを構文ツリーに変換します。

また、2番目の引数にリテラル補間スタイルを使用しているため、リテラルの内容が適切にエスケープされていることを確認します。

虫が好きな人はいない。

しかし、私がさらに好きなのは、マクロを展開して明示的に要求しない限り、見られないコードのバグです。

そのため、マクロが十分にテストされていることを確認したいのです。

マクロには副作用がなく、構文ツリーのソースコードは比較しやすいので、それらをテストする素晴らしい方法は単体テストを書くことです。

マクロテンプレートにはすでに1つが付属しています。

このテストケースでは、SwiftSyntaxパッケージの「assertMacroExpansion」関数を使用して、「stringify」マクロが正しく展開されることを確認します。

入力として、以前に見た「#stringify(a + b)」式を取ります。

そして、マクロが展開された後、「a + b」と文字列リテラル「a + b」を含むタプルが生成されると主張します。

マクロを拡張する方法をテストケースに伝えるために、マクロ「#stringify」を「StringifyMacro」タイプを使用して展開することを指定する「testMacros」パラメータを渡します。

アプリのテストをすでに実行しているのと同じ方法でテストを実行して、実際に合格したかどうかを確認しましょう。

テストに合格し、それで、私たちはすでに最初のマクロを持っています。

その中で、私たちはその基本的な構成要素を見ました。

マクロ宣言は、マクロの署名を定義します。

また、マクロの役割も宣言します。

コンパイラプラグインは拡張を実行します。

これは、それ自体がSwiftで書かれ、SwiftSyntaxツリーで動作するプログラムです。

また、マクロは構文ツリーの決定論的変換であり、構文ツリーのソースコードは比較しやすいため、非常にテスト可能であることがわかりました。

だから、「他にどのような状況でマクロを使用できますか?」と疑問に思うかもしれません。

私たちはすでに自立式のマクロを見てきました。

要約すると、このマクロはハッシュで綴られ、マクロ式全体を書き換えることができます。

式の代わりに宣言に拡張する自立宣言の役割もあります。

他の種類のマクロはアタッチされたマクロです。

これらは、属性と同じように@で綴られ、マクロが添付されている宣言を拡張できるようにします。

たとえば、アタッチされたメンバーマクロは、アタッチされたタイプの新しいメンバーを追加します。

これらの他の役割の詳細については、ベッカがそれらを非常に詳細に説明する「Expand on Swiftマクロ」を見ることを強くお勧めします。

しかし、現在取り組んでいるアプリのコードベースを改善するのに役立ったので、添付のメンバーの役割に集中したいと思います。

私はスキーインストラクターでもあり、最近、生徒を連れて行きたいツアーを計画できるアプリに取り組んでいます。

スキーインストラクターとして絶対に避けたいことの1つは、初心者を難しすぎるゲレンデに連れて行くことです。

それを強制するためにSwift型システムを使いたい。

そのため、私のお気に入りのスキーリゾートのすべてのゲレンデを含むスロープ列挙型に加えて、初心者に適したゲレンデのみを含むEasySlopeタイプもあります。

勾配が本当に簡単な場合は、勾配を簡単な勾配に変換する初期化子と、簡単な勾配を一般的な勾配に戻すための計算されたプロパティがあります。

これは素晴らしいタイプの安全性を提供しますが、それは本当に反復的です。

簡単なスロープを追加したい場合は、スロープに追加する必要があります...

EasySlope、初期化子、および計算されたプロパティ。

マクロを使って物事を改善できるかどうか見てみましょう。

私たちがやりたいことは、初期化子と計算されたプロパティを自動的に生成することです。

どうすればこれができますか?

イニシャライザと計算されたプロパティの両方がEasySlopeタイプのメンバーであるため、添付されたメンバーマクロを宣言する必要があります。

次に、マクロの実装を含むコンパイラプラグインを作成します。

マクロが期待どおりに動作することを確認するために、テスト駆動の方法で開発したいと考えています。

したがって、テストケースを書くまで、その実装を空のままにします。

テストケースでマクロの動作を定義した後、そのテストケースと一致するように実装を書きます。

そして最後に、新しいマクロを私のアプリに統合します。

すべてがうまくいけば、初期化子を削除し、マクロに生成してもらうことができます。

マクロを開発するには、先ほど作成したテンプレートで作業します。

そして、私のアプリに「#stringify」マクロは本当に必要ないので、私はすでにそれを削除しました。

「@Attached(member)」属性を使用して、新しい添付メンバーマクロを宣言することから始めます。

EasySlopeはSlopeのサブセットなので、私はそれをSlopeSubsetと呼んでいます。

マクロは、導入するメンバーの名前も定義します。

このデモでは、初期化子を生成する方法を紹介します。

計算されたプロパティの生成は、すべてのケースを切り替える単なるスイッチステートメントであるため、非常によく似ています。

この宣言では、マクロを定義しましたが、実際に実行する展開を実装していません。

このため、マクロは WWDCMacros モジュールの SlopeSubsetMacro タイプを参照します。

本当にエキサイティングな部分である実際のマクロ実装を続けることができるように、そのタイプを作成しましょう。

SlopeSubsetをアタッチされたメンバーマクロとして宣言したため、対応する実装はMemberMacroプロトコルに準拠する必要があります。

このプロトコルには、ExpressionMacroに似た「拡張」関数という単一の要件があります。

「拡張」関数は、マクロを宣言に適用する属性と、マクロが適用される宣言を取ります。

私たちの場合、これはEasySlope列挙宣言になります。

次に、マクロは、その宣言に追加したいすべての新しいメンバーのリストを返します。

この変換をすぐに実装し始めるのは非常に魅力的であることは知っていますが、テストケースを書くことから始めたいことに同意しました。

今のところ、新しいメンバーを追加すべきではないことを示す空の配列を返しましょう。

最後に、SlopeSubsetをコンパイラに表示する必要があります。

このために、私はここで「providingMacros」プロパティに追加します。

もっと深く掘り下げる前に、私たちがこれまでに持っているものがうまくいくことを確認したいです。

Xcodeでマクロを適用して拡張されたコードを見てみることができますが、回帰を導入していないことを確認するために、マクロに変更を加えるたびに再実行できるテストケースを書くことを好みます。

テンプレートのテストケースと同様に、「assertMacroExpansion」関数を使用してマクロの動作を検証します。

テストしたいのは、EasySlopeタイプに適用したときにマクロが生成するものなので、それをテストケースの入力として使用します。

そして、マクロはまだ何もしていないので、属性を削除し、新しいメンバーを追加しないことを期待しているので、期待される拡張コードは「@SlopeSubset」なしで入力と同じです。

最後に、SlopeSubsetMacroの実装を使用してマクロSlopeSubsetを拡張する必要があることをテストケースに知らせる必要があります。

そのために、マクロ名を「testMacros」辞書の実装タイプにマッピングし、その辞書をアサーション関数に渡す必要があります。

これまでに書いたことが実際に機能することを確認するために、今テストを実行しましょう。

そうです。

すごい。

しかし、私たちが本当に欲しいのは、属性を削除するだけでなく、マクロが実際に初期化子を生成することを確認することです。

だから、以前に手書きで書いたコードをテストケースにコピーします。なぜなら、本当に、それがプラグインに生成してほしいものだからです。

もう一度テストを実行すると、マクロがまだ初期化子を生成していないため、失敗します。

今すぐそれを変えましょう。

初期化子は、EasySlopes列挙型で宣言されたすべての列挙要素を切り替えます。

したがって、最初にする必要があるのは、宣言からこれらの列挙要素を取得することです。

列挙要素は列挙宣言内でのみ宣言できるため、列挙宣言に「宣言」をキャストすることから始めます。

マクロが列挙型ではない型にアタッチされている場合は、エラーを発するはずです。

後で行うことを忘れないようにTODOを追加し、今のところ空の配列を返します。

次に、列挙型が宣言するすべての要素を取得する必要があります。

その方法を理解するために、SwiftSyntaxツリーの列挙型の構文構造を調べたいと思います。

マクロの実装は普通のSwiftプログラムなので、Xcodeから知っているすべてのツールを使ってプログラムをデバッグできます。

たとえば、拡張関数内にブレークポイントを設定し、テストケースを実行してそのブレークポイントにヒットすることができます。

マクロの実装内でデバッガが一時停止され、「enumDecl」はEasySlopes列挙型です。

「Po enumDecl」と入力すると、デバッガに印刷できます。

出力を調べてみましょう。

構文ツリーの最も内側のノードは、列挙要素、「beginnersParadise」、および「practiceRun」の斜面を表します。

それらを取得するには、構文ツリーで概説されている構造に従う必要があります。

その構造を段階的に説明し、アクセスコードを書きましょう。

列挙型宣言には「memberBlock」という子があります。

このメンバーブロックには、中括弧と実際のメンバーの両方が含まれています。

したがって、メンバーにアクセスするには、「enumDecl.memberBlock.members」から始めます。

これらのメンバーには、実際の宣言とオプションのセミコロンが含まれています。

私たちは宣言、特に実際に列挙ケースを宣言する宣言に興味があります。

コンパクトマップを使用して、列挙ケースであるすべてのメンバー宣言のリストを取得しています。

各ケース宣言は、複数の要素を宣言できます。

これは、別々のケースキーワードの後に新しい行に各スロープを宣言する代わりに、「ケースビギナーズパラダイス、練習ラン」と同じ行に書くことができたからです。

それらすべてを取得するには、「フラットマップ」を使用できます。

そして、すべての要素を取得したので、実際にEasySlopeに追加したい初期化子の構築を開始できます。

イニシャライザ宣言には単一の項目があります:スイッチ式。

このスイッチ式には、列挙型内の各要素のケースと、nilを返すデフォルトのケースが含まれています。

これらすべてに対して構文ノードを作成する必要があります。

作成する構文ノードを見つける2つの優れた方法は、以前のように構文ツリーを印刷するか、SwiftSyntaxのドキュメントを読むことです。

InitializerDeclSyntaxを構築することから始めます。

このタイプは、結果ビルダーを使用してボディを構築し、ヘッダー、つまり「init」キーワードとすべてのパラメータを指定することで構築できます。

これにより、結果ビルダー内のforループを使用して、必要なすべての要素を反復することができます。

テストケースからinitヘッダーをコピーするだけです。

体内では、スイッチ表現が必要です。

このタイプには、ヘッダーと結果ビルダーを取る初期化子もあります。

もう一度使いましょう。

これで、以前に収集したすべての要素を反復することで、結果ビルダーの力を使うことができます。

各要素について、「#stringify」で見たように、文字列補間を使用して構築できる新しいケースアイテムを作成します。

また、nilを返すデフォルトのケースを追加する必要があります。

そして最後に、初期化子を返すことができます。

テストを実行して、実際に正しい初期化子を生成しているかどうかを確認します。

私たちはそうです。

だから、私たちはマクロが機能し、私のアプリでそれを使い始めることができることを知っています。

マクロパッケージをXcodeプロジェクトに追加するには、それを右クリックして「パッケージの依存関係を追加」を選択します。

作成したばかりのローカルパッケージを選択できるようになりました。

マクロを使用できるように、WWDCターゲットをアプリの依存関係として追加します。

パッケージからWWDCモジュールをインポートし、SlopeSubsetマクロをEasySlopeタイプに適用できるようになりました。

...もし私たちが建てるなら...

...コンパイラは、手書きの初期化子が無効な再宣言であると不平を言います。

そして、それはマクロが今私たちのためにそれを生成するからです。

だから、私たちはそれを削除することができます。

コードを削除するのはいつも楽しいです。でしょ？

したがって、マクロが実際に生成したものを見たい場合は、SlopeSubsetを右クリックし、[マクロを展開]をクリックします。

また、マクロが何をするかを忘れた場合は、Optionキーを押しながらクリックしてドキュメントを読むこともできます。

次のステップは、計算されたプロパティも生成することですが、今日は後で行います。

マクロを使用することで、反復的なコードを書くことなく、EasySlopesのタイプの安全性を得ることができました。

どうやってやったの？

私たちはSwiftマクロパッケージテンプレートから始めました。

構文ツリーの構造を調べるために、マクロの実行を停止し、デバッガ内に構文ノードを印刷しました。

これにより、すべての列挙要素を取得するためにどのプロパティにアクセスする必要があるかを見ることができました。

そして、テストケースを使用して自分でマクロを開発するのは本当に簡単でした。

アプリに追加した後、すぐに機能しました。

しかし、マクロがサポートしていない状況で使用された場合はどうなりますか?

初心者のスキーヤーを困難な斜面に連れて行きたくないのと同じように、マクロに予期しない展開を実行させたり、コンパイルされないコードを生成させたりしたくありません。

マクロがサポートしていない方法で使用されている場合は、生成されたコードを読んでマクロをデバッグさせるのではなく、何が間違っているかを養子縁組者に知らせるエラーメッセージを常に送信します。

その精神で、コードベースに残したTODOを修正しましょう。

SlopeSubsetが列挙型ではない型に適用されると、マクロは列挙型にのみ適用可能であるというエラーを発するはずです。

以前と同じように、テストケースを追加することから始めましょう。

今回は、SlopeSubsetマクロを構造体に適用します。

構造体には列挙要素がないため、マクロが初期化子を生成するとは期待していません。

代わりに、SlopeSubsetは列挙型にのみ適用できることを知らせるエラーである診断を発行する必要があります。

このテストを実行すると...

...まだエラーメッセージを出力していないため、失敗します。

さあ、コンパイラプラグインに行きましょう。

マクロエラーは、Swift Errorプロトコルに準拠した任意のタイプで表すことができます。

SlopeSubsetが列挙型ではない型に適用される場合、エラーメッセージを記述するために、単一のケースを持つ列挙型を使用します。

展開関数からエラーをスローすると、マクロ展開を呼び出す属性に表示されます。

属性とは異なる場所にエラーメッセージを表示したり、警告を生成したり、XcodeでFix-Itsを表示したりする場合は、コンテキストパラメータに「addDiagnostic」メソッドがあり、豊富な診断を生成できます。

しかし、この場合、属性に単純なエラーメッセージを表示するのが効率的だと思います。

さて、私たちがすべて正しいことをしたかどうか、そしてテストに合格したかどうかを見てみましょう。

素晴らしい、彼らはそうします。

では、SlopeSubsetを構造体に適用すると、Xcodeではどのように見えますか?

このために、テストケースをファイルにコピーさせてください。

Xcodeは、他のすべてのコンパイルエラーとインラインでカスタムエラーメッセージを表示します。

これにより、私のマクロの採用者は、彼らが何が間違っているのかを簡単に確認できます。

そして、あなたは何を知っていますか?

エラー処理が良好になったので、このマクロは、スロープだけでなく、列挙型サブセットを指定する他の開発者にも役立つかもしれないと思います。

それを一般化しに行きましょう。

これまでスロープとしてハードコードされている列挙型のスーパーセットを指定するには、マクロ宣言に汎用パラメータを追加します。

また、マクロはスロープに固有ではなくなったため、SlopeSubsetを右クリックしてRefactor、Renameを選択してEnumSubsetに名前を変更しましょう。

また、コマンドキーを押しながらクリックすることで、文字列リテラルとコメント内のすべての出現の名前を変更することもできます。

ハードコードされたSlopesタイプではなく、一般的なパラメータを使用するようにマクロ実装を調整する必要があります。

「enumDecl」と同様に、デバッガ内に属性を印刷してレイアウトを調べると、属性の名前の「genericArgumentClause」の最初の引数の「argumentType」にアクセスすることで、汎用パラメータを取得できることがわかります。

ジェネリックパラメータを取得したので、これまでハードコードされたスロープタイプを変数「supersetType」に置き換えることができます。

イニシャライザのパラメータの名前の変更、マクロ実装の型名の変更、ドキュメントの更新など、さらにいくつかの変更を加える必要があります。

後でやります。

代わりに、今のところ、私たちのテストがまだ合格していることを確認しましょう。

EnumSubsetをジェネリックにしたので、EnumSubsetマクロに汎用パラメータとしてスロープを渡すことで、EasySlopeがスロープのサブセットであることを明示的に指定する必要があります。

テストが今合格しているかどうか見てみましょう。

彼らはそうです。

このマクロをSwiftパッケージとして他の人に公開することを本当に検討すべきです。

だから、それは私たちが今日カバーした多くの分野です。

私たちが経験したことを要約しましょう。

マクロを作成するには、素晴らしい出発点としてstringifyマクロを含むマクロパッケージテンプレートから始めることができます。

マクロを開発する際には、マクロが生成するコードが実際に有効であることを確認するために、テストケースを書くことを強くお勧めします。

また、これを行う場合は、拡張関数にブレークポイントを設定し、テストを実行し、デバッガに構文ツリーを印刷することで、構文ツリーのレイアウトを検査できます。

そして最後に、特定の状況でマクロが適用されない場合は、物事がうまくいかなくてもマクロが輝くように、常にカスタムエラーメッセージを発行する必要があります。

見てくれてありがとう、そして私はあなたがどのようなマクロを作成するかを見て興奮しています。

♪ ♪