10143

♪ ♪

Dave: こんにちは、App Store Commerceチームの開発者アドボケートであるDave Wendlandです。

同僚のアレックスと私は、新しいApp Storeサーバーライブラリと、その機能のセットが、サーバーがApp Store Server APIのJWTの生成から購入検証のためにverifyReceiptエンドポイントから移行することまで、さまざまな機能を利用できるようにする方法について話し合います。

振り返ってみると、アプリが無料または有料だった2008年にApp Storeが発売されました。

すぐに、私たちはアプリ内購入を追加し、それ以来、開発者コミュニティは世界中で規模と複雑さを増しています。

App Storeは、グローバルでダイナミックなモバイルアプリエコシステムをサポートするために、開発者や顧客向けのアップデートを展開し続けています。

2021年には、改良されたStoreKit Framework、App Store Server API、App Store Server Notifications v2を備えたStoreKitツールの次の時代をリリースしました。

2022年と今年もWWDC 2023でさらに更新されます。

これらのツールは、署名されたJWS形式でトランザクションとステータスを提供します。

また、開発者に堅牢な情報、クライアント側、サーバー側を提供するように設計されています。

この一連のAPIは、App Store Server Libraryに影響を与えました。

このライブラリが一連の機能を提供していることを誇りに思います。これにより、開発者コミュニティが現在および将来利用可能な最新のAPIを採用し、統合することが容易になります。

ライブラリのベータリリースは、Swift、Java、Node、Pythonの4つの言語をサポートしており、バックエンドと専門知識を最もよくサポートする言語を柔軟に選択できます。

各言語のApp StoreサーバーライブラリはGitHubで入手できますので、ご意見やご意見をお待ちしております。

図書館が提供するものを4つの重要な機能に分解しました。

最初で最も堅牢な機能は、App Store Server APIです。

JWTの作成を合理化することで、App Store Server APIが提供する12の異なるエンドポイントのいずれかを使用できます。

次に、JWSの署名されたデータを検証するコア機能なので、トランザクションとサーバー通知がAppleによって生成され、署名されていることを確認できます。

次は、抽出レシートトランザクションユーティリティです。

このシンプルなツールは、アプリの領収書からトランザクション識別子を抽出します。

これにより、verifyReceiptエンドポイントを使用する必要性を軽減し、購入検証と追加機能のためにApp Store Server APIに移行することができます。

これは、現在およびレガシーアプリのバージョンをサポートするための明確なパスを提供します。

最後に、サブスクリプションプロモーションオファーの署名を生成するユーティリティです。

このユーティリティは、アプリ内購入の秘密鍵を使用してオファーに署名して生成する重い作業を行います。

サブスクリプションプロモーションオファーに精通していない場合は、「サブスクリプションオファーのベストプラクティス」というタイトルのセッションで詳細をご覧ください。

次に、これらのコアライブラリ機能の3つを深く掘り下げてみましょう。

App Store Server API、署名されたデータ検証、およびApp Store Server APIへの移行。

App Store Server APIから始めましょう。

サーバーAPIの基盤は、トランザクション履歴の取得エンドポイントです。

トランザクションIDを使用するだけで、このAPIは顧客の完全なアプリ内購入トランザクション履歴を提供します。

そして、このエンドポイントを超えてさらに多くの機能を備えています。

このAPIには12のエンドポイントがあり、そのすべてにJSON Webトークンという認証形式が必要です。

JWTの生成は重要なステップであり、このプロセスに精通していない場合は、ライブラリの出番です。

アレックスに渡して、App Store Server APIで使用するためのライブラリのセットアップを実演します。

アレックス：こんにちは、App Storeサーバーエンジニアのアレックス・ベイカーです。

App Store Serverライブラリの使用を開始する方法と、それを使用してApp Store Server APIを呼び出す方法を実演します。

このデモでは、App Storeサーバーライブラリを設定するために必要な情報を収集し、APIクライアントを作成してAPIを呼び出す例を示します。

ライブラリでApp Store Server APIを使用するために必要な情報を取得するために、App Store Connectから始めています。

ユーザーとアクセスモジュールに移動します...

次に、[キー]タブ、次に[アプリ内購入]オプション。

ここには役に立つ情報がいくつかあります。

まず、発行者IDです。

次に、新しい秘密鍵を生成します。

名前を付けてから、[生成]をクリックします。

キーの生成には、キーIDと秘密鍵をダウンロードするオプションの2つの情報があります。

ダウンロードは一度しかできません。

Apple公開鍵インフラストラクチャWebサイトに切り替えて、左上のAppleルート証明書セクションに焦点を当てます。

ルート証明書をダウンロードしてください。

これは、Gradleビルドシステムを使用した簡単なJavaプロジェクトです。

まず、App Store Serverライブラリへの依存関係を追加します。

ExampleAppクラスに移動すると、先ほど入手した情報、issuerId、keyId、秘密鍵があります。

さらに、アプリのbundleIdを保存します--このデモンストレーションでは、私はサンドボックスを使用しています--そして適切な列挙値を保存します。

これらの情報を使用して、AppStoreServerAPIClientをインスタンス化します。

このクライアントでは、テスト通知のリクエストエンドポイントを呼び出し、App StoreサーバーにApp Store Connectで設定したURLにTESTタイプの通知を送信するように要求します。

最後に、testNotificationTokenを印刷します。

これを実行すると、testNotificationTokenが印刷され、予想通り、このトークンが表示されます。

これは、App Store Serverライブラリを使用して、App Store Server APIとApp Store Connectから必要な情報を簡素化する方法を示しました。

さて、デイブに戻ります。

デイブ:ありがとう、アレックス。

そのデモは、このライブラリがサーバーAPIで使用するためにJWTをセットアップして生成する速さを示しています。

このライブラリは、APIを採用する際の実装タイムラインの短縮に有意義な影響を与えます。

ライブラリの使用は便利で簡単ですが、アプリ内購入の秘密鍵を安全に保管することほど重要なものはありません。

また、キーが侵害されたと思われる場合は、いつでもApp Store Connectで新しいキーを生成してください。

開発を開始するには、サンドボックスとTestFlightトランザクションから始めることをお勧めします。

そして最後に、更新されたAppleルート認証局を定期的に確認してください。

それでは、署名されたデータ検証がアプリ内購入でビジネスの基礎的な行動である理由について話し合いましょう。

まず、署名されたデータには何が含まれているのか、なぜそれが重要なのかについて話し合いましょう。

StoreKit署名データは、JSON Web署名形式でApp Storeによって生成および署名されたことを意味し、アプリ内購入、アプリ内購入、顧客イベント、および顧客のサブスクリプションステータスに関するデータが含まれています。

最も一般的な2つの署名付きデータペイロードは、JWSトランザクションとJWS更新情報です。

次に、appTransactionには、最初に購入したアプリのバージョンと、現在デバイスにインストールされているバージョンの詳細が含まれています。

そして、App Store Server Notifications V2があり、通知自体は署名されたデータであり、さらにJWSトランザクションとJWS更新情報が含まれている場合があります。

念のため、このJWS署名データは、iOS 15以降のStoreKit 2とApp Store Server APIとApp Store Server Notifications v2でのみ見つかります。

次のいずれかのイベントの後に、JWS署名されたデータを確認することをお勧めします。デバイスでコンテンツを配信またはロック解除するとき、またはサーバーが署名されたデータを受信したとき、それが自分のアプリ、別のサーバー、またはApp Storeサーバーの通知からであるかどうか。

そして最後に、App StoreサーバーAPIから応答を受け取ったとき。

JWSの署名されたデータを検証する方法と、ライブラリがこれをどのように処理するかをデモするアレックスです。

アレックス：このセクションでは、App Storeから署名されたデータを確認する方法を紹介します。

実行する必要がある検証プロセスについて説明します。

次に、App Store Server LibraryのSignedDataVerifierクラスがこのプロセスを実行する方法について説明します。

私が説明しようとしている操作の背後にあるRFCやプロトコルに精通していない場合は、App Store Server Libraryのようなツールを使用することが非常に賢明であることを強調したいと思います。

以下はApp Storeからの署名入りデータです。

ここではたくさんのことが起こっているようです。

カラーコーディングは、3つのセクションがあることを明らかにします。

各セクションはピリオドで区切られており、Base64 URLでエンコードされています。

最初で最大のセクションはヘッダーです。

デコードされると、ヘッダーはJWS仕様で定義されたフィールドを持つJSON構造です。

この場合、ヘッダーには2つのフィールドしかありません。まず、アルゴリズムで、常にES256です。

次に、x5cというフィールド。

これは、JWSに署名した予想される公開鍵を計算するために使用される証明書の配列です。

証明書チェーンの構築プロセスを見直しましょう。

配列の最初の証明書はリーフ証明書です。

この証明書の公開鍵はJWSに署名しました。

この証明書がAppleからのものであることを確認するには、既知の信頼できるソース、この場合はAppleのルート認証局への信頼の連鎖を構築します。

配列の次の証明書は、Apple Worldwide Developer Relationsの中間認証局です。

これは、開発者に焦点を当てたApple Root Certificate Authorityのより専門的なバージョンと考えてください。

チェーンの最後の証明書はAppleのルート認証局なので、どのAppleの認証局がこのチェーンを起源としているのかを理解しています。

リマインダー、証明書が以前にAppleの公開鍵インフラストラクチャWebサイトから取得したルート証明書と正確に一致することを確認することが重要です。

最初のステップは、各証明書がチェーン内の前の証明書によって署名されていることを確認することです。

次に、各証明書に有効な日付、適切にフォーマットされていることを確認するなど、追加の検証手順を実行します。

次に、これらの証明書がAppleからのものであり、その目的がApp Storeデータに署名することであり、App Storeデータに署名することは有効ではない無関係なユースケースとは対照的に、検証します。

リーフ証明書を確認するには、Mac App Storeレシート署名のオブジェクト識別子またはOIDの存在をチェックして、その目的を確認します。

中間証明書については、Apple Worldwide Developer Relationsの中間機関OIDを確認してください。

最後に、前述のように、ルート認証局がAppleルート認証局として保存した証明書の1つであることを確認してください。

それでは、実際にリーフ証明書をデコードし、これらの値をチェックする方法を観察しましょう。

これは、OpenSSL x509コマンドによって生成された証明書のX.509 v3拡張セクションです。

下部には、前のスライドに記載されているOIDがあり、証明書の目的がApp Storeの領収書署名であることを示しています。

ただし、チェックすべき重要な追加のフィールドがいくつかあります。

ここでは、発行者に関する情報を提供し、重要なことに、証明書が取り消されたかどうかを確認するための情報を提供する権限情報アクセスセクションが表示されます。

オンライン証明書ステータスプロトコル（OCSP）を使用する。

検証プロセスを進める前に、証明書が取り消されたかどうかを確認してください。

そうするためのプロセスと暗号化手順は、RFC 6960で定義されています。

証明書チェーンを確認した後、JWSがリーフ証明書の公開鍵で署名されていることを確認します。

以前からリーフ証明書を取得し、リーフ証明書の公開鍵を抽出し、キーと元のJWSを取得し、それらをJWS署名検証機能に渡します。

検証機能は、データが公開鍵で署名されていることをチェックし、ペイロードをデコードします。

プロセスはほぼ完了していますが、追加の検証手順が1つあります。

これはデコードされたApp Storeサーバーのテスト通知です。

前の手順では、データがApp Storeから来たことを確認しました。

ただし、通知が正しいアプリケーションと環境を対象としていることも確認してください。

appAppleIdとbundleIdをチェックして、通知が正しいアプリケーションを対象としていることを確認してください。

環境が予想される環境と一致していることを確認します。

検証プロセスの他の手順と同様に、App Store Serverライブラリも検証を実行するときにこれらをチェックします。

これにより、App Storeから署名されたデータを確認するプロセスが完了します。

次に、以前からプロジェクトを拡張して、App Storeサーバーライブラリに含まれているSignedDataVerifierクラスを使用して署名されたデータを検証します。

SignedDataVerifierクラスは、以前に説明した検証手順を実行します。

このデモでは、先ほどリクエストしたテスト通知を受け取り、署名された通知を検証してデコードします。

テスト通知のリクエストと、サーバーで受信された通知との間に少し遅れがあります。

したがって、5秒の遅延を追加します。

次に、以前に取得したtestNotificationTokenを使用して、Get Test Notification Statusエンドポイントを呼び出します。

最後に、通知の最初の数文字を印刷して成功を確認します。

Get Test Notification Statusエンドポイントは、送信試行の結果と通知ペイロードを返します。

そのペイロードの始まりは、私たちが見るべきものです。

予想通り、通知の最初の数文字が表示されます。

次に、署名されたデータ検証者を作成します。

これには、Apple Root認証局のリストから始まる3つの情報が必要です。

先ほどダウンロードした証明書は、リソースフォルダにあります。

ルート証明書をセットにインポートします。

私はサンドボックスを使用しているので、アプリのApple IDは必要ありません。

代わりにサンドボックスでnullを渡します。

最後に、失効チェックを実行するかどうか。

通知を受け取ったばかりなので、onlineChecksは真であるべきです。

数ヶ月または数年前に受け取った通知については、証明書の有効期限が切れている可能性があるため、これは虚偽である必要があります。

これらのフィールドを新しいSignedDataVerifierに渡します。

次に、以前に受信した通知を渡し、結果を印刷してからプログラムを実行します。

プログラムが完了すると、プログラムには検証済みでデコードされた通知が表示されます。

これはテスト通知であるため、他のいくつかのフィールドとともに、ペイロードにTESTの種類とアプリのバンドル識別子があります。

予想通り、TESTタイプのデコードされた通知が表示されます。

SignedDataVerifierオブジェクトを実演するために、以前のデモを拡張しました。

ここでは、いくつかのベストプラクティスを確認するデイブです。

デイブ：うわー、それは署名されたデータを検証するために必要なすべての手順と、ライブラリがその複雑さをどのように処理できるかを本当に示しているので、サーバー側の検証にSignedDataVerifierを必ず利用してください。

重要なリマインダー：データを確認するときは、正しいアプリまたはサービスの購入を許可または取り消すことを確認するために、アプリと製品識別子を確認する必要があります。

最後に、証明書の有効期限が切れて取り消すことができるので、証明書、クライアント側またはサーバー側をハードコードせず、常にアクティブであることを検証してください。

次に、サーバー側のアプリレシート検証をverifyReceiptエンドポイントからApp Store Server APIに移動するのを支援するために、別のApp Storeサーバーユーティリティを確認します。

App Store Serverライブラリは、この移行を具体的に支援するユーティリティを提供し、アプリが取り残されないようにします。

App Store Server APIへの移行を検討する際には、ロードマップでこの作業を優先する理由はたくさんあります。

このAPIは購入検証をサポートし、カスタマーサポート、アピーズメント、およびApp Store Server Notifications V2のテストに役立つ追加のエンドポイントが含まれています。

更新と新しいプロパティのリリースを継続するにつれて、これらはStoreKit 2、App Store Server API、およびApp Store Server Notifications V2でサポートされているJWS署名付きデータでのみリリースされます。

追加の利点、記録する必要がある唯一のデータは、元のトランザクションIDまたはトランザクションIDです。

Base64でエンコードされた領収書をアカウントシステムに保存する必要がなくなりました。

また、最新のAPIへの継続的な投資により、verifyReceiptエンドポイントが非推奨になったことを発表しました。

詳細については、セッション「App StoreサーバーAPIの新機能」をチェックして、詳細なアップデートとガイダンスを確認してください。

アレックスは、App Storeのサーバーライブラリが移行にどのように役立つかを共有します。

アレックス？

アレックス:ありがとう、デイブ。

では、アプリレシートのフロー図を見ていきましょう。

StoreKit 2とApp Store Server APIは使用するのに最適なツールですが、最近更新されておらず、アプリレシートのみがサーバーに提供できる古いデバイスやユーザーのクライアントをサポートすることが重要です。

これらのデバイスが以前にどのようにサポートされていたか、そしてverifyReceiptの廃止後、これらのクライアントをどのようにサポートし続けることができるかを紹介します。

まず、デバイスはサーバーに領収書を送信します。

古いモデルでは、サーバーはこのレシートをverifyReceiptに渡し、デコードされたレシートを受け取ります。

応答には、App Store Server APIのGet Transaction Historyエンドポイントに渡されるoriginalTransactionIdが含まれています。

App Storeサーバーは、顧客にサービスを提供するために使用する署名済みのトランザクションを返します。

verifyReceiptが非推奨になったので、このセクションを置き換えましょう。

App Storeサーバーライブラリのレシートユーティリティは、レシートからトランザクションIDを直接抽出します。

トランザクションIDをApp Store Server APIに渡すと、2回の往復を行う必要がなくなります。

この後、エンドポイントからリビジョンを保存します。

これにより、毎回履歴全体を再解析する必要がなくなります。

アプリのレシートから抽出された値は、元のトランザクションIDである場合とそうでない可能性があるため、トランザクション履歴の取得エンドポイントを含む多くのエンドポイントが、元のトランザクションIDだけでなく、任意のトランザクションIDをパラメータとしてサポートしていることを発表できることを嬉しく思います。

次に、App Store Serverライブラリを使用して、Get Transaction Historyエンドポイントで使用するトランザクションIDの抽出を実演します。

ここでは、アプリの領収書を取得し、トランザクションIDを抽出し、IDを使用してGet Transaction Historyエンドポイントを呼び出します。

まず、アプリの領収書。

デバイスまたはApp Store Server Notification V1からアプリの領収書を入手できます。

私はすでにここに1つ持っています。

次に、ReceiptUtilityクラスのインスタンスを作成します。

トランザクションIDを抽出するには、アプリのレシートメソッドから抽出トランザクションIDを呼び出します。

すべての領収書にトランザクションIDがあるわけではありません。

ユーザーが何も購入していない可能性があります。

したがって、ヌルチェックを追加します。

この問題にもう少し深みを提供するために、このユーザーの最新の消耗品に関する情報を入手し、取り消された消耗品を除外したいと想像してください。

トランザクション履歴要求オブジェクトを作成し、取り消されたトランザクションを除外するCONSUMABLEタイプの製品のみが求められ、データを降順で返されることを指定します。

2つのヘルパーオブジェクト、応答変数、およびトランザクションのリストが必要です。

Do whileは、トランザクション履歴エンドポイントからの応答を介してページをループします。

これが最初の要求でない場合は、前の応答からリビジョントークンを取得して、データをページングし続けます。

次に、アプリのレシート、リクエストオブジェクト、およびリビジョンからのトランザクションIDを使用して、トランザクション履歴の取得エンドポイントを呼び出します。

最後に、応答からすべてのトランザクションをトランザクションリストに追加します。

応答のhasMoreフィールドがfalseになるまで、このプロセスを繰り返します。

トランザクションを印刷して結果を確認してください。

ここでは、APIから返されたトランザクションのリストが表示されます。

前のデモのSignedDataVerifierを使用してデコードできます。

App Store Server APIでApp Receiptsを使用する方法を示した最終デモンストレーションにご参加いただきありがとうございます。

私たちを包むためにデイブに戻ります。

デイブ：新しいApp Store Serverライブラリに本当に興奮しており、これらの機能がAPIの採用を容易にし、App Store Server APIに移行すると思います。

これは、GithubのApp Store Server API Javaリポジトリのスクリーンショットです。

このページでは、ドキュメントへのリンクを見つけたり、プルリクエストを送信したり、ライブラリの使用方法の例を見つけることができます。

すぐにApp Store ServerライブラリBETAをダウンロードして、App Store Server APIの採用計画を開始できます。

フィードバックや機能のリクエストをお待ちしております。

フィードバックアシスタントとGithubでお問い合わせください。

ありがとうございます。

♪ ♪