10160

♪ ♪

人物：こんにちは、「Demystify SwiftUI Performance」へようこそ。

SwiftUIを使用すると、複雑で強力なアプリを簡単に構築でき、リストやテーブルなどの多数の機能と複雑なコントロールを提供します。

始めたばかりで、アプリがあまり複雑ではない場合、パフォーマンスの問題はそれほど明白ではありません。

しかし、アプリの複雑さが増すにつれて、パフォーマンスがより重要になります。

小さな問題は増幅される可能性があり、プロトタイプでうまく機能するコードは本番ではうまく機能しないかもしれません。

このセッションは、SwiftUIでのパフォーマンスのためのメンタルモデルを構築することです。なぜなら、開発プロセスの最初から高速コードを書く方法を理解していれば、アプリがより複雑になるにつれて問題が少なくなるからです。

パフォーマンスの問題に対処するためのフィードバックループを調べてみましょう。

パフォーマンスの問題は症状から始まります。

おそらく、遅いナビゲーションプッシュ、壊れたアニメーション、またはmacOSで回転する待機カーソルが表示されている可能性があります。

パフォーマンスの問題を特定するとき、それに対処するための最初のステップは測定することです。

症状が存在することを測定および確認したら、その原因の特定に取り組みます。

これは、物事がどのように機能するかについての直感を必要とするため、このループのトリッキーな段階の1つになることがよくあります。

アプリが誤った仮定をしていると、バグが発生します。

このセッションでは、アプリの仮定と現実の不一致を特定するのに役立ちます。

根本原因を特定した後、最適化を通じて問題を解決します。

しかし、パフォーマンスの問題は、根本原因を見つけてコードを最適化した後に終わらない。

問題が解決していることを確認するために、修正を再測定し、再確認する必要があります。

これはすべてのバグにとって良い習慣ですが、パフォーマンスにとって特に重要です。

問題が解決したことを確認したら、ループを壊します。

この図は、このセッションを文脈に置きます。

理想的には、このサイクルで終わることはなく、プロトタイピング時に高速なコードを書くことで、多くのパフォーマンスの問題を回避できます。

しかし、アプリがより複雑になるにつれて、パフォーマンスのバグになってしまうことは避けられません。

それは私たちの最高に起こります。

そして、パフォーマンスの問題に遭遇した場合、それらをトリアージして修正するために、できるだけ多くのツールを自由に使うのは良いことです。

このセッションは、ループを簡単に通過することを目的としています。

これは高度なセッションであり、いくつかの前提条件があります。

暗黙のアイデンティティと明示的なアイデンティティの違いを含め、SwiftUIのアイデンティティを大まかに理解する必要があります。

また、ビューの有効期間とビューのアイデンティティの区別を知ることも重要です。

これらの前提条件がない場合は、心配しないでください。 心配しないでください。

WWDC21の「Demystify SwiftUI」セッションをカバーしました。

今日のセッションは、そのセッションが中断したところから再開します。

議題を確認しましょう。

依存関係の詳細な議論から始め、SwiftUIの更新プロセスを詳細に検討します。

次に、アップデートの議論と、SwiftUIがインターフェイスを更新する速度を向上させる方法に進みます。

最後になりましたが、リストと表でアイデンティティについて話し合います。

その過程で、SwiftUIのボンネットの下を覗いて、開発時に使ういくつかのヒントやコツをチェックします。

このセッションは、主にビュー階層の遅い更新に関係していますが、アプリを開発する際に発生する可能性のあるすべてのパフォーマンスの問題を徹底的に調べることではありません。

依存関係から始めましょう。

前回の「Demystify SwiftUI」セッションから数年が経ちましたが、犬をテーマにしたアプリに取り組むのを逃しました。

だから、そのセッションのテーマを継続して、私はお気に入りの毛皮のような友人を追跡し、彼らと遊ぶ時間を設定できる新しいアプリに取り組んできました。

これは景色の1つで、すべての犬を示すテーブルです。

このアプリには、iPhoneでここに表示されている詳細ビューもあり、各犬の全体像、犬の好みを表示し、プレイする時間を設定するためのボタンを提供します。

これが同じビューのコードです。

ビューはパラメータとして犬を取り込み、それがプレイ時間であるかどうかを知るための環境プロパティも持っています。

前回のDemystifyセッションで述べたように、これは犬とプレイ時間変数がビューの依存関係であることを意味し、このビューを表示する別の方法はグラフです。

これは、ほぼ同じビューを表す基本的なグラフです。

各矢印はビューの本体を表します。

ドッグビューはスタックを生成します。

そして、スタックには、いくつかのテキスト、スケーラブルな犬の画像、詳細ビュー、ボタンなど、複数の子があります。

続けると、これらのビューのそれぞれに子があり、グラフは画像、テキスト、色などのリーフビューに達するまで続きます。

すべてのビューは最終的にリーフビューに解決されます。

SwiftUIには多くのリーフビューがあるので、ここではそれらすべてをカバーするわけではありません。

詳細については、ドキュメントを確認してください。

アプリに戻りましょう。

アプリを使っているときはいつでも、友達と遊ぶときはいつでもログインできます。

私はここでロッキーとフェッチをプレイし終えたばかりなので、ボタンと画像を更新するアプリでそれをメモしました。

ロッキーはかなり幸せそうに見えますが、彼は間違いなく疲れすぎて今は遊べません。

このデータがモデルで変更されると、SwiftUIはこのビューを更新します。

グラフに戻り、この変更が発生したときに何が起こるかを見て、更新プロセスを詳しく見てみましょう。

これがまた私たちのグラフです。

これは、以前のDemystifyセッションが中断した場所であり、ビューがグラフを形成し、SwiftUIがコードを評価する際に依存関係を調べることを説明します。

ズームインして、これらの依存関係がどこから来て、どのように制御できるかをより詳しく見てみましょう。

各子ビューは、その祖先によって生成されるビュー値に依存します。

しかし、他の形態の依存関係もあります。

動的プロパティは、依存関係の一般的なソースでもあります。

たとえば、DogViewは、@Environmentプロパティラッパーを使用して、環境からの再生時間かどうかを読み取ります。

したがって、それは親によって生成された値と環境からの値の両方に依存します。

X軸で時間を視覚化する場合、更新プロセスの最初のステップは、ビューの新しい値を生成することです。

この値は、dog 値や動的プロパティの初期値など、ビューのすべての保存されたプロパティを網羅します。

次に、SwiftUIはビューのすべての動的プロパティを更新し、その値をグラフの現在の値に置き換えます。

最後に、更新された値で、ボディはビューの子を生成するために実行されます。

グラフをもう一度持ち込んでみましょう。

このプロセスは、インターフェイスを更新するために再帰し、新しい値またはその他の変更された依存関係を持つビューのみを更新します。

ロッキーを疲れたとしてマークすると、私たちは新しい犬を手に入れます-申し訳ありませんが、新しい犬の構造値ですが、それはまだ同じロッキーです。

私たちのデータは値型であるため、変異すると新しいコピーが作成されます。

その結果、DogViewはスタックの新しいコンテンツを生成し、スタックの子を更新します。

ここではScalableDogImageのみに焦点を当てていますが、犬の値に依存する場合、他のビューが更新される可能性があります。

ScalableDogImageは、最終的に新しい画像を生成します。

画像はリーフビューなので、残りの作業はここからSwiftUIによって行われます。

その後、プロセスが終了し、新しいレンダリングが生成されます。

それが依存関係グラフの見方です。

このプロセスを改善するためのヒントをいくつか見てみましょう。

更新を必要なものだけに減らすことが重要です。

ビューがいつ更新されるかを理解するために、SwiftUIにはprintChangesメソッドがあります。

これにより、SwiftUIグラフ評価者がビューの本文に呼び出された理由を印刷できます。

使い方の例を見ていきましょう。 

ここには、状態の一部を含むスケーラブルな犬の画像があります。

画像をタップすると、状態がこのように変化します。

画像ビューのみに焦点を当て、LLDBコンソールからビューの本体にブレークポイントを設定すると、「式」LLDBコマンドを使用してSelf._printChangesを呼び出すことができます。

printChangesは、SwiftUIがビューの本文を要求した理由を最善を尽くして説明するデバッグのみの機能です。

この場合、scaleToFillが変更されたためです。

printChangesを使用して、ビューに余分な依存関係があるかどうかを理解できます。

たとえば、現在アプリとデバッグを実行しており、このビューに余分な依存関係があるかどうかを確認したいと考えています。

このビューの本文にprintChangesへの呼び出しを追加して、ビューの本文にアクセスするたびに印刷できます。

ただし、printChangesにはアンダースコアが先頭に付きます。

この場合、つまり、常に存在することは保証されることはなく、将来のリリースで削除される可能性があるため、このメソッドへの呼び出しをアプリストアに送信しないでください。

後でこの電話を削除する必要があります。

これはデバッグのみを目的としており、ランタイムのパフォーマンスに影響します。

アプリを再実行し、ロッキーのお気に入りのおやつ、例えばビスケットからキュウリのような他のものに変更すると、私たちの画像からコンソールのログに気づきます。

「自己」が変わったと書かれています。

これは、ビュー値が変更されたことを意味するため、スケーラブルな画像ビューは治療にある程度依存する必要がありますが、実際にはする必要はありません。

コードに焦点を当てると、ビューの値にはscaleToFillメンバーとdogプロパティしかありません。

scaleToFillはSwiftUIの動的プロパティであるため、変更された場合は変更ログに表示されていたため、ここでの「@Self」は犬の値が変更されたことを意味します。

しかし、このビューを見ると、私たちはイメージだけを気にします。

したがって、代わりに画像のみを使用することで、この依存関係を排除することができます。

そして今、画像に関係のない犬のプロパティを変更すると、ログが表示されません。

ビューの依存関係は厳密にスコープされています。

このテクニックに従う場合は、printChangesの呼び出しを削除することを忘れないでください。

一致するように親ビューを更新しましょう。

これが親犬のビューのコードです。

画像を取り込むために、ScalableDogImageの初期化子を更新する必要があります。

ScalableDogImageを抽出することで、依存関係を重要なものだけに減らしました。

ヘッダーでも同じことを行い、独自のビューに抽出できます。

これには多くの利点があります。

このコードは読みやすくなり、DogHeaderの依存関係は使用サイトで明らかです。

このテクニックは小さなビューに最適ですが、非常に大きな構造体には注意してください。

すべての依存関係がこのようにスコープされるに値するわけではありません。

最善の判断を下す必要があります。

アップデートが少ないと、アプリのデータが変更されたときのパフォーマンスが向上します。

先ほど検討したように、これを行う1つの方法は、依存関係を減らすことです。

ビューの値を、実際に依存しているデータのみに減らしてみてください。

もう1つのヒントは、依存関係を減らすためにビューを抽出することです。

そして最後に、新しいObservableプロトコルは、依存関係を読み取りのみに自動的に制限することで、依存関係のスコーピングにも役立ちます。

詳細については、「SwiftUIで観察を発見する」セッションをチェックしてください。

それは、依存関係を見る方法の簡単なツアーでした。

より迅速な更新について話しましょう。

このセクションでは、各SwiftUIアップデートのコストを削減する方法について説明します。

SwiftUIの更新が遅いと、ハングやヒッチなどの応答性の低下など、アプリに多くの悪影響を及ぼす可能性があります。

ハングは、最初に表示されるのに長い時間がかかるビューのように、ユーザーインタラクションへの応答の遅延です。

WWDC2023の「Instrumentsのハングを分析する」セッションでは、SwiftUI関連の作業によってハングが原因である可能性があるかどうかを特定する方法など、Instrumentsを使用してハングを分析する方法について詳しく説明します。

ヒッチは、スクロール中の一時停止やアニメーションのフレームのスキップなど、ユーザーが知覚できるアニメーションの問題です。

特にSwiftUIでは、ハングやヒッチの根本原因はしばしば関連しています。

システムレンダリングループの仕組みなど、ヒッチの詳細については、「UIアニメーションヒッチとレンダリングループを探索する」テックトークビデオをご覧ください。

SwiftUIの両方のハングとヒッチは、多くの場合、遅いアップデートに起因します。

これらの遅い更新には、いくつかの一般的な原因があります。

1つ目は、状態オブジェクトの割り当てと初期化、状態の初期化など、高価な動的プロパティのインスタンス化です。

もう一つの情報源は、体で行われた仕事です。

高価な文字列補間や、データフィルタリングなどの操作や体内内のその他の作業を必ず確認してください。

体自体ができるだけ安いことが重要です。

これらはすべて相互に関連しています。

たとえば、動的プロパティはビューの本体から計算できるため、ビューは評価に費用がかかります。

遅い識別は、ビューの体内でも頻繁に発生します。

フェッチアプリの例を見ることから始めましょう。

この例では、犬のリストを作成するために使用するオブジェクトを持つアプリのルートビューに取り組んできました。

このスライドのコードハイライトに続いて、ボディ内のmodel.dogsにアクセスすると、オブジェクトが遅延してインスタンス化し、犬のリストを取得する初期化子が表示されます。

コードコメントが言うように、これには長い時間がかかる可能性があります。

これは同期作業です。

これを修正する1つの方法は、タスク修飾子を使用することです。

まず、フェッチを非同期にします。

ここでは、非同期キーワードの追加を表示しているだけです。

次に、タスク修飾子で、ドッグリストを待機して非同期に取得します。

そうすれば、高価なデータ読み込み操作が発生したとき、アプリは応答します。

あなたのアプリに影響を与えていることに気づいていないかもしれない他の仕事のソースがあります。

たとえば、文字列の補間はしばしば高価になる可能性があるため、頻繁に使用する必要がある可能性のある文字列をキャッシュするようにしてください。

同様に、バンドルから値を調べることは高価になる可能性があります。

そしてもちろん、クラスに縛られたタイプなど、ヒープの割り当ては加算できます。

リストとテーブルに移りましょう。

リストとテーブルは、シンプルなレイアウト、選択の追加、スワイプアクション、並べ替えのサポートなどを超えた豊富な機能をサポートしています。

これらは複雑で高度なコントロールであり、アイデンティティを理解することは、アプリでうまく機能するために不可欠です。

このセクションでは、リストと表のアイデンティティについて議論し、これらの組み込みコンポーネントの更新パフォーマンスを最大化する方法をわかりやすく説明します。

このテーマに飛び込む前に、いくつかの改善点に触れたいと思います。

macOS SonomaとiOS 17では、SwiftUIには、フィルタリングやスクロールなどのケースのために、多くの最適化があります。

これらの改善は、あなたの側で最小限の労力で可能であり、多くの場合、より大きなリストやテーブルの負荷と更新時間が大幅に向上する可能性があります。

ただし、パフォーマンスを向上させるリストとテーブルを構築するには、特定の方法があります。

リストとテーブルは識別子を使用して、データにどのような変更が発生したかを知る。

一貫性を保つために、リストとテーブルのすべてのIDが熱心に収集されます。

したがって、リストとテーブルの内容の識別子をすばやく生成できるため、読み込みと更新時間が短縮されます。

アイデンティティは、SwiftUIがビューの寿命を管理するのに役立ちます。これは、階層の増分更新に不可欠です。

アイデンティティの変更は、ビューが変更されたことを意味します。

これはアニメーションとパフォーマンスにとって重要です。

アニメーションの詳細については、「SwiftUIアニメーションの基礎」セッションをご覧ください。

特にリストやテーブルの場合、識別子が頻繁に収集されるため、識別性能は重要です。

リスト識別モデルを見てみましょう。

私はアプリの犬のリストで一生懸命取り組んできました。

私はたった1列から始めました。

これがリストのコードで、中にDogCellが1つ入っています。

次のステップは、ForEachを使用してすべての犬を反復することです。

この例は簡単ですが、アイデンティティに直接関係しており、リストにForEachを追加することはパフォーマンスを評価する重要な時期です。

その理由を理解するために、次にForEachの一般的な署名を見てみましょう。

これはSwiftUIのForEachの署名です。

ForEachは、データのコレクションを結果のビューのシーケンスにマッピングし、各ビューの明示的なアイデンティティを生成します。

Listを使用する場合は、表示する行の数と、各行の識別子を把握する必要があります。

したがって、事前にデータ収集を訪問し、各要素のIDを決定します。

コンテンツクロージャは、各ビューを生成するために呼び出されます。

行はオンデマンドで作成されます。

リストは、アイデンティティとコンテンツの合成を使用してリスト行を生成します。

オンデマンドで作成された行は、可視領域と相関し、プリフェッチまたはアクセシビリティのためのいくつかのシステム決定バッファと相関します。

ビューがスクロールされると、より多くのビューが現存します。

これがこのForEachを生成するコードスニペットです。

ここでは、内部にHStackを使用しているため、コンテンツは単なるDogCellであり、それ自体が単一のビューであることに注意してください。

ForEachは、リストで使用される究極の行IDを決定する上で非常に重要です。

そして、リストはすべてのIDを事前に知る必要があります。

しかし、コンテンツが一定の行数に解決した場合にのみ、すべてのコンテンツにアクセスしずに効率的にこれを行うことができます。

例として、ボールを取りたい犬だけを表示するようにリストをリファクタリングしたいとしましょう。

このような条件付きビューを使用してフィルターを追加するのは魅力的かもしれません。

ここでは、ビューの数は可変です。1かゼロのどちらかです。

これは、各要素がいくつのビューに解決されるかわからないため、行識別子を取得するためにすべてのビューを構築する必要があるため、悪いです。

AnyViewを使用する場合も同様です。

ここでは、ビュー数は現在完全に不明です。

したがって、以前と同じ問題があります。すべての行を作成する必要があります。

フィルターをデータ収集自体に移動したらどうなりますか?

これで、要素ごとの一定数のビューに戻り、必要なビューのみが行の内容を構築していますが、注意してください。ここのインラインフィルタは、コレクションの上に線形です。

これはプロトタイプで機能するかもしれませんが、コレクションがスケールすると、この操作はすぐに高価になり、更新が遅くなる可能性があります。

モデルに移動した方が良いです。 

今、私たちは両方の長所を持っています。フィルターはキャッシュされているため、このリストが構築されるたびに実行されず、要素ごとのビュー数は一定です。

ビュー数が一定であることを確認するためのヒントをいくつか紹介します。

カウントを表示するこのアプローチは、これらのコンポーネントが事前に識別子を収集するため、リストとテーブル内のForEachのコンテキストでのみ関連していることに注意してください。

先ほど述べたように、AnyViewと偏った条件の使用は避けてください。

必要に応じて明示的なスタックを使用することもできますが、listRowBackgroundのような特定の修飾子は、スタック内ではなくスタックの後に行く必要があることに注意してください。

最後に、可能であれば、ネストされたForEach構造を平らにしてみてください。

ただし、ネストされたForEachが貴重なセクションリストになる場所が1つあります。

例を見てみましょう。 例を見てみましょう。

この例では、各犬のお気に入りのおもちゃで区切られた犬のリストがあります。

ForEachを使用して、動的な数のセクションを作成しています。

そして、各セクションには、ForEachをネストすることで、その中に動的な数の行があります。

リストはすべての識別子を取得する必要がありますが、ここではセクションを使用しているため、SwiftUIはこの構成を理解し、リストがまだレンダリングが速いことを保証します。

動的セクションは、ネストされたForEachを使用する場合の良い例です。

考えるべき基本的な方程式は、リスト内のForEachから生じる行数は、各要素に対して生成されたビューの数を乗じた要素の数に等しいということです。

要素ごとのビュー数が定数であることを確認する必要があります。または、SwiftUIは行を識別するために識別子に加えてビューを構築する必要があります。

これまでのところ、リストについて話しましたが、これらのルールは一般的にテーブルにも適用されます。

Tableはビューの代わりにTableRowを使用し、TableRowは常に単一の行に解決されます。

表の例を見てみましょう。 

ここには、中にForEachがある犬のテーブルがあります。

TableRowは常に1行であるため、ここでの合計行数は、犬コレクションの要素の数にすぎません。

この構造は非常に一般的であるため、iOS 17とmacOS Sonomaで新しく、SwiftUIは、単にあなたのデータ収集のForEachを作成し、あなたに代わってテーブル行を作成できる合理化された初期化子を提供します。

この初期化子は新しいですが、テーブルが利用可能な以前のすべてのオペレーティングシステムバージョンに再展開されます。

この構造はシンプルであるだけでなく、ForEachコンテンツに一定数の行を強制し、識別パフォーマンスに役立ちます。

しかし、私が呼び出したい意味的な変化があり、それは新しいものです。

このようなコードがある場合、最新のOSバージョンでは動作が異なる場合があります。

この例では、犬の上にForEachがあり、犬の列も作成します。

しかし、ここの犬は一致しません。

価値観は犬の親友です。

iOS 16では、各行がその値で識別されました。

iOS 17では、この動作はパフォーマンスを向上させるために変化しました。

その理由は、ForEachを調べて各テーブル行を識別する必要がないからです。

したがって、この例では、TableRowの値ではなく、各犬のIDがあります。

バックデプロイが必要な場合は、コレクションにマッピングするか、IDキーパスを明示的に指定することで、古い動作を取得できます。

考えるべき基本的な方程式は、リスト内のForEachから生じる行数は、各要素に対して生成されたビューの数を乗じた要素の数に等しいということです。

テーブルでは、これは似ていますが、要素ごとのTableRowsの数です。

ここでは、より高速なリストとテーブルのためのいくつかのヒントとコツを取り上げました。つまり、識別子が安価に作成でき、ForEachコンテンツのビュー数が一定であることを確認する必要があります。

今日は多くのことを取り上げました。

依存関係を理解し、最適化するためにグラフを探索することから始めました。

次に、遅い更新と応答性を向上させる方法を調べました。

そして最後に、リストとテーブルでアイデンティティの重要性について話し合いました。

適切なメンタルモデルを使用すると、開発プロセスの最初から簡単に優れたパフォーマンスを発揮できるため、アプリの詳細に集中できます。

見てくれてありがとう。

♪ ♪