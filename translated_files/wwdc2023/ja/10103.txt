10103

♪ ♪

ローマン・エフィモフ:みなさん、こんにちは。

私の名前はローマン・エフィモフで、ショートカットチームのエンジニアです。

今日は、App Intentsのエキサイティングな新機能と機能強化を取り上げ、さらに優れたアプリを作成するお手伝いをします。

まず、ウィジェットから始めます。

ご存知のように、ウィジェットはiOSのユーザーエクスペリエンスのますます重要な部分になっています。

そして今、アプリのインテントとウィジェットはシームレスに連携し、インタラクティブ性と構成を通じて新しい体験を提供します。

次に、今年行った開発者体験の改善に移ります。

フレームワークのサポートや、静的抽出の最近の強化など、いくつかの品質改善について説明します。

そして最後に、App Intentsとのショートカットアプリの統合のアップデートに飛び込みます。

私たちはかなりぎっしり詰まった議題を持っているので、ウィジェットのエキサイティングなアップデートから始めましょう。

まず、ウィジェットの設定について話しましょう。

設定可能なウィジェットを作成するときに、ウィジェットの裏側でその人が選択できるようにするオプションを指定できます。

これらのオプションはパラメータと呼ばれ、アプリにSiriとショートカットのサポートを追加するために使用するのと同じシステムを使用してそれらを定義できます: 意図。

ウィジェットの設定UIは、対応するインテントに含まれるパラメータの順序付きリストを表示します。

インテントに追加された各パラメータは、ウィジェット設定インターフェイスで行として表示されます。

以前は、インテント定義ファイルを使用してXcodeでインテントを宣言する必要がありました。

iOS 17では、ウィジェット拡張コードでApp Intentsを使用して、ウィジェットの設定のスキーマを定義することをさらに簡単にしました。

これを行うには、まず、以前にウィジェットの設定に使用した可能性のあるIntentConfigurationの代わりに、AppIntentConfiguration WidgetConfigurationタイプの使用を開始する必要があります。

次に、WidgetConfigurationIntentプロトコルに準拠した新しいタイプを定義します。

WidgetConfigurationIntentはApp Intentのサブプロトコルであり、Widget Extensionコードで直接準拠できます。

私は、特定の停留所の次の定期バスの時間とルートを表示するバススケジュールアプリのウィジェットに取り組んできました。

これにより、完全なアプリを開くことなく、次のバスがいつ到着するかをすばやく確認できます。

App Intentsを使用して、ウィジェットの設定Intentを提供します。

ユーザーが次のバスウィジェットを設定できるようにするには、WidgetConfigurationIntentプロトコルに準拠し、次のパラメータを含む構造体を定義することから始めます。保存された停留所のリストから選択されたバス停、または新しい停留所、特定のバスルート、および選択したルートの移動方向を検索します。

ウィジェットの設定に必要なパラメータの定義が完了したら、各パラメータタイプに動的オプションを提供する必要があります。

以前は、パラメータの動的オプションを提供するには、別のインテント拡張を作成する必要がありました。

App Intentsを使用すると、ウィジェット拡張機能内で直接クエリと動的オプションプロバイダーを実装でき、よりクリーンで効率的なプロジェクトにつながります。

動的オプションプロバイダーとクエリの詳細については、「Dive into App Intents」ビデオをチェックすることをお勧めします。

では、既存のウィジェットをSiriKitからApp Intentsに移行することについて話しましょう。

既存のウィジェット設定をApp Intentsに移行するのは簡単です。

実際、Xcodeでワンクリックで行うことができます。

ウィジェットを移行すると、ウィジェットをアプリインテントに変換する前に、最新のOSバージョンと以前のバージョンの両方をサポートできます。

既存の設定済みのウィジェットは引き続き動作できます。

以前のOSバージョンをサポートする必要がなくなったら、SiriKit Intent定義ファイルを削除できます。

移行するには、Intent定義ファイル内のSiriKitウィジェット設定Intentに移動し、[App Intentに変換]ボタンをクリックします。

Xcodeは、古いIntent定義と同等のApp Intentsコードを生成します。

スキーマが同じであることを確認する必要があります。つまり、すべてのApp Intentパラメータ名とタイプは、Intent定義にあるものと一致する必要があります。

App Intentに新しいパラメータを自由に追加してください。

オプションのパラメータ、またはデフォルト値を持つ必須のパラメータを追加することもできます。

パラメータが追加される前に作成された既存のウィジェットは、そのパラメータの空の値、または指定した場合はデフォルト値を選択します。

以前のiOSバージョンで人々をサポートし、その新しいパラメータを使用させる予定がある場合は、SiriKit Intent定義ファイルを維持し、そこに新しいパラメータを追加する必要があります。

顧客がアプリを更新するたびに、ウィジェットは自動的に移行されます。

アプリには1回しか機会がないため、移行がスムーズに進むことをテストすることが重要です。

移行の詳細については、「カスタムインテントをアプリのインテントに移行する」ビデオを見ることをお勧めします。

ウィジェットのインタラクティブ性に移ります。

ウィジェットはボタンのタップやトグルに反応し、ホーム画面から直接設定を調整したり、メディアを再生したり、アプリからその他の重要な機能にアクセスしたりできるようになりました。

ネクストバスウィジェットでは、タイムボタンをタップ可能にしたいと思います。

人々がこれらのボタンの1つをタップすると、アプリでアラームを設定して、いつ出発すべきかを正確に把握して、バスに乗り遅れないようにしたい!

どうや 

SwiftUIボタンとトグルは、アプリのインテントをサポートするように更新され、ウィジェットにインタラクティブ性を簡単に追加できます。

以前にアプリインテントを実装した場合は、すぐにそれに慣れているはずです。

まず、App Intentプロトコルに準拠した構造体を定義する必要があります。

次に、パラメータプロパティラッパーでキープロパティに注釈を付けて、アクションを実行するために関連情報が必要であることをシステムに知らせます。

その後、実際にアクションを実行する実行メソッドを実装する必要があります。

最後に、ウィジェットビューでは、SetAlarmアプリの意図をボタンに関連付けるだけです。

SwiftUIとApp Intentsの統合は、インタラクティブなウィジェットだけでなく、通常のSwiftUIアプリでも利用できます。

コードをApp Intentsに統合することで、冗長性を減らし、アプリ全体で一貫した動作を確保できます。

アプリインテントは、構成とインタラクティブアクションのプロバイダーの両方として機能するため、ショートカットのインテントコードを再利用するのは非常に簡単です。

たとえば、ShowNextBusウィジェット構成インテントは、ウィジェット構成とショートカットアクションの両方として使用でき、必要なときに最新情報を提供できます。

さらに、ウィジェットにインタラクティブ性を追加するために使用したアプリインテントは、優れたショートカットアクションとしても機能し、人々が好みのバス到着時刻のアラームを設定できるようにします。

ウィジェットのインタラクティブ性の詳細については、「ウィジェットに命を吹き込みます」をチェックしてください。

ウィジェット設定の機能とデザインを強化できるいくつかの高度なテクニックに移りましょう。

まず、動的オプションとクエリの強化について話しましょう。

動的オプションは、App Intentのパラメータに利用可能な値を提供するためのインターフェイスであり、DynamicOptionsProviderまたはEntityQueryプロトコルファミリに準拠することで実装できます。

場合によっては、別のパラメータの値に基づく特定の条件が満たされた場合にのみ利用可能なオプションを表示したい場合があります。

たとえば、ウィジェットの設定では、バス停パラメータに基づいて利用可能なルートオプションのみを表示したいと考えています。

これを行うには、iOS 17でIntentParameterDependencyと呼ばれる新しいAPIを使用できます。

これは、DynamicOptionsProviderまたはクエリ内で、インテントからパラメータにアクセスできるプロパティラッパーです。

これらのパラメータを読み取り、それらを使用して、より動的でコンテキストを意識したオプションを作成できます。

私の例では、ユーザーが選択したバス停でフィルタリングされた利用可能なバス路線を返します。

IntentParameterDependencyは、ウィジェット、ショートカット、フォーカスフィルターなど、すべての環境で機能します。

私の例では、EntityQueryプロトコルに準拠したBusRouteQueryという構造体があります。

この構造体には、IntentParameterDependencyプロパティラッパーでラップされたShowNextBusというプロパティがあります。

これは、バスルートクエリがshowNextBus App Intent、特にバス停パラメータに依存していることを意味します。

suggestedEntitiesメソッドに注目してください。

提案されたルートオブジェクトの配列を返します。

まず、showNextBus Intentプロパティが非nilであるかどうかをチェックします。

その場合は、利用可能なルートをフィルタリングして、指定されたバス停に一致するルートのみが表示されます。

IntentParameterDependencyは、複数のパラメータに依存することもできます。

たとえば、方向クエリでは、バス停とルートパラメータの両方を使用して方向オプションを提供したいと考えています。

また、同じクエリまたは動的オプションプロバイダー内の複数のアプリインテントに依存することもできます。

私の方向クエリは、ShowNextBusとShowFavoriteRouteの2つのインテントからパラメータを読み取ります。

IntentParameterDependency プロパティ ラッパーは、ShowNextBus Intent の busStop パラメータとルート パラメータ、および ShowFavoriteRoute Intent の route パラメータの依存関係を指定するために使用されます。

ルート計算プロパティは、どちらが利用可能かに応じて、showNextBusまたはshowFavoriteRouteのいずれかから値を返します。

ウィジェットの設定には、多くの場合、配列パラメータがあります。

たとえば、私のお気に入りのルートウィジェットは、人のお気に入りのルートのバススケジュールを表示できます。

ただし、画面スペースが限られているため、最大3つのルートしか選択できないはずです。

では、どうすればそれを宣言できますか?

iOS 17の新機能で、Arrayパラメータを定義するときにサイズを宣言できるようになりました。

ここのサイズは、大きなウィジェットが小さなウィジェットよりも多くのアイテムを収容できる場合があるため、ウィジェットファミリからアレイサイズへのマッピングを受け入れることもできます。

ウィジェット設定アプリの意図とそのパラメータを定義したら、これらのパラメータのどれがいつユーザーに表示されるかを定義したいと思うかもしれません。

ParameterSummaryは、App Intentのパラメータの視覚的表現を定義します。

ショートカットエディタ、フォーカスフィルター、およびウィジェット設定でアプリインテントの外観を強化します。

パラメータサマリーを使用して、どのパラメータが表示され、どの条件で表示されるかを定義できます。

ウィジェットの場合、UIは最初に要約文のパラメータを表示し、次にクロージャにリストされている追加のパラメータを表示します。

ここでは、文にはルートパラメータが含まれており、クロージャにはincludeWeatherInfoが含まれているため、設定UIでその順序で表示されます。

iOS 17の新機能で、ウィジェットファミリでWhenステートメントを使用できるようになりました。ウィジェットのサイズに基づいてウィジェットの設定を変更できます。

たとえば、大きなウィジェットでのみ気象情報を表示するトグルを表示したいのですが、他のサイズにはこの機能はありません。

そこで、大きなウィジェットに対してのみ、パラメータサマリーにincludeWeatherInfoパラメータを追加します。

そうでなければ、小さなウィジェットの場合は追加しないので、パラメータは非表示になります。

App Intentsを使用してウィジェットの設定を実装したので、その人がそれをタップしたときに何が起こるかを判断するにはどうすればよいですか?

その人は、私のウィジェットのどこかをタップするたびに、私のアプリに連れて行かれます。

ウィジェットの設定で選択した特定のルートに関する情報を表示する画面に直接移動したいと思います。

ユーザーがウィジェットをタップしてアプリを起動すると、ユーザーアクティビティでwidgetConfigurationIntentメソッドを呼び出すことで、関連する設定Intentを取得できます。

アプリインテントを取得したら、それを使用してアプリのUIを適宜更新できます。

ここでは、Configuration Intentからコンテンツを抽出し、それを使用して、対応する停留所とルートの特定のバス停ビューにアプリをナビゲートします。

ウィジェットを構築するときは、人々がスマートスタックで適切なタイミングでそれを見るようにしたいと思うでしょう。

これを行うには、iOSとwatchOSのウィジェットの提案に新しいRelevantContext APIを使用できます。

以前のINInteraction、INDailyRoutine、およびINRelevantShortcut APIからインスピレーションを得て、よりスウィフトフレンドリーで、アプリインテントとシームレスに連携するように、新しいRelevantIntentManagerとRelevantIntentを設計しました。

ゲーム中にウィジェットを浮上させたいスポーツアプリを想像してみてください。

新しいRelevantContext APIを使用すると、このインテントと関連する日付範囲を指定できます。

この関連する日付情報を提供することで、スポーツアプリウィジェットはスマートスタック内で自動的に提案され、人々が最も重要なときにゲーム情報に簡単にアクセスできるようにします。

関連性APIは、時計のコンプリケーションを浮上させるのにも最適です。

watchOSの関連性の詳細については、「Apple Watchでスマートスタック用のウィジェットを構築する」をチェックしてください。

ウィジェットを取り上げたので、iOS 17とXcode 15で行った開発者体験の改善に飛び込みましょう。

フレームワークサポートから始めます。

アプリがメインアプリとApp Intents拡張機能の両方からApp Intentsを実行する機能が必要な場合は、現在、App Intentコードを両方のターゲットにコンパイルする必要があります。

残念ながら、このアプローチはコードの重複につながり、メンテナンスの問題が発生し、エラーや矛盾の可能性を高める可能性があります。

これはまた、バイナリサイズを肥大化し、アプリのパフォーマンスと人々のダウンロード時間に悪影響を及ぼす可能性があります。

iOS 17とXcode 15では、フレームワークがアプリの意図を直接公開できるようになったので、コードを2回コンパイルする必要はもうありません。

AppIntentsPackage APIを使用して、アプリ内の依存関係を再帰的にインポートできるようになりました。

AppIntentsPackageプロトコルにタイプを適合させることで、アプリとフレームワークの両方が他のフレームワークからメタデータを再エクスポートできます。

フレームワークサポートを使用して、バススケジュールアプリの実装を簡素化します。

バススケジュールを表示するためのさまざまなアプリインテントを提供するBusScheduleIntentsというフレームワークがあります。

依存関係なく再輸出できるようになります。

私は、バススケジュールアプリのカスタムインターフェイス要素を提供するBusScheduleUIと呼ばれる別のフレームワークを持っています。

このフレームワークは、BusScheduleIntentsフレームワークに依存し、再エクスポートします。

最後に、バススケジュールアプリからBusScheduleUIフレームワークをインポートします。

AppIntentsPackageはプロトコルなので、SwiftUIアプリの構造体にそれを適合させることができます。

バススケジュールアプリは、BusScheduleUIフレームワークへの直接的な依存について言及するだけで済みます。

ShowSchedule App Intentを実行することで、お気に入りのバスルートを表示するSwiftUIボタンをバススケジュールアプリ内に作成できるようになりました。

同じアプリインテントであるShowScheduleは、ショートカットユーザーも利用できます。つまり、カスタムショートカットを作成して、アプリを開かずにお気に入りのバス路線のスケジュールにすばやくアクセスできます。

アプリインテントをフレームワークに移動すると、コードベースがよりシンプルで合理化されます。

新しいフレームワークのサポートは、アプリとウィジェット拡張機能の両方から同じインテントにアクセスする必要がある可能性があるため、アプリインテントでウィジェットを構築する場合に特に素晴らしいです。

App Intentsコードをよりモジュラーに保つためのもう1つのヒント：AppShortcutsProviderを作成し、App Intents拡張機能でApp Shortcutsを定義できるようになりました。

以前は、メインのアプリバンドルでアプリのショートカットを完全に定義する必要がありました。

これは、アプリショートカットが実行されているときに、アプリが常にバックグラウンドで起動されることを意味します。

これで、App Intents拡張機能でApp Shortcutsを定義できます。

これは、メインアプリ全体よりも高速にApp Intents拡張機能を最適化し、UI、分析、またはその他の重要でないコードの起動を避けることができるため、パフォーマンスに最適です。

これらの機能はすべて、Xcode 15で行った静的メタデータ抽出の強化に依存しています。

それでは、コードが構築されている間、App Intentsのコンテンツがどのように静的に抽出されるかについて話しましょう。

Swiftコンパイラは、コードで利用可能な型に関する情報と、App Intentsの実装から型レベルと値レベルの情報を出力します。

別のツールは、この情報を解析して、ビルド製品にMetadata.appIntentsディレクトリを生成します。これには、アプリの意図、パラメータ、エンティティ、クエリなどを記述するファイルが含まれています。

Xcode 15では、静的抽出プロセスが大幅に改善されました。

今ではより速く、より信頼性が高く、これまで以上に多くのケースで機能します。

Xcode 15でアプリを構築する場合、Xcodeが期待するものを静的に抽出できない場合は、行番号とともにXcodeエディタに直接エラーメッセージが表示されるので、どこに行って問題を解決すべきかがわかります。

ショートカットの統合について話す前に、今年App Intentsに追加した2つの素晴らしい能力があり、言及する価値があります。

まず、そのインテントが以前にバックグラウンドで実行されていたとしても、アプリでインテントの実行を継続する機能です。

私たちはこれをForegroundContinuableIntentプロトコルと呼んでいます。

たとえば、次のバスを取得するアプリインテントが、無効なパラメータや接続の問題のためにバススケジュールを取得できない場合、問題を解決するためにアプリで続行するように依頼することができます。

そのために、まず、App IntentをForegroundContinuableIntentプロトコルに適合させます。

ForegroundContinuableIntentプロトコルは、最初にバックグラウンドで作業を開始するが、フォアグラウンドで継続を要求する必要がある可能性のあるインテント向けに設計されています。

次に、needsToContinueInForegroundErrorメソッドを呼び出すと、エラーが返されます。

そのエラーをスローすると、システムはApp Intentの実行を停止し、フォアグラウンドで実行を続行するようユーザーに求めます。

また、フォアグラウンドに入った後にアプリの状態を更新するために、メインスレッドで実行されるオプションの継続クロージャを提供することもできます。

ここでは、このクロージャを使用して、アプリをエラー画面に移動しています。

前の例のように、インテントの実行を停止し、続行するアクションを要求する場合は、needsToContinueInForegroundErrorを使用します。

アプリインテントを完全に停止するのではなく、引き続き実行したい場合は、使用できる別のAPIがあります。

その場合は、requestToContinueInForegroundメソッドを呼び出します。

バスアプリがバスルートにメンテナンスの問題があることを検出し、アプリでカスタムUIを表示して代替ルートを選択したいときに、これを使用するかもしれません。

人がルートを選択したら、アプリからその更新されたルートを返し、アプリインテントの実行を続けることができます。

今回は、エラーをスローする代わりに、単にtry and awaitでメソッドを呼び出しています。

渡されたクロージャは値を返すことができ、私はそれを私のパフォーマンス内に戻すことができます。

これにより、ユーザーから入力を得た後、アプリインテントの実行を続けることができます。

ここでは、ユーザーが選択した代替ルートを取り、そのルートの次のバスを示すスニペットを返します。

要約すると、App Intentの実行を完全に停止したい場合は、スローメソッドを使用します。

それ以外の場合は、その人から結果を取得し、それを使用してApp Intentの実行を完了したい場合は、requestToContinueInForegroundを使用して結果を待ちます。

今年は、App IntentsにApple Payのサポートも追加しました。

実行方法内で直接Apple Payトランザクションを開始できるようになりました。

パフォーマンスでApple Payを使うのは簡単です。

PKPaymentRequestインスタンスを作成し、必要な情報で設定します。

次に、PKPaymentAuthorizationControllerを使用してApple Payの支払いシートを提示し、承認を処理します。

ガードステートメントは、コントローラーが正常に提示されたかどうかを確認します。

そうでない場合は、「支払いを処理できません」というダイアログを返します。

そうでなければ、支払いは正常に処理されます。

最後に、App IntentsとShortcutsアプリの統合に関するいくつかのアップデートを掘り下げてみましょう。

アプリインテントが統合されているシステム内のさまざまな場所から始めましょう。

App Intentsは、ショートカットアクションを構築するための最新の方法であり、App Shortcutsを使用すると、Siriとショートカットアプリでアプリの機能を簡単に見つけて使用できます。

Apple Watch Ultraのフォーカスフィルターやアクションボタンとの統合もあります。

iOS 17では、インタラクティブライブアクティビティ、ウィジェットの設定とインタラクティブ性、SwiftUIとの統合により、アプリインテントはさらに広くアクセスできるようになりました。

アプリのショートカットも成長し、Spotlight Top HitsとAutomationsのサポートも含まれています。

これらの統合はすべて、同じApp Intentsコードをさまざまな方法で再利用できることを意味します。

アプリインテントは現在、主要なシステムコンポーネントに深く統合されているため、作成したアプリインテントが善良な市民であることを確認することが非常に重要です。

優れたパラメータサマリーを提供することは、アプリインテントがシステム全体で表面化したときに見栄えを良くするために不可欠です。

折り畳みの下に隠されたオプションのパラメータで、文のように読むようにパラメータの要約を書いてください。

その後、システムは、コンテキストに基づいてパラメータサマリーの最適な視覚的表現を決定します。

アプリインテントがどこでもうまく機能することが望ましいですが、アプリ内またはインタラクティブなウィジェットで使用するためにアプリインテントを作成する必要があり、システムの他の部分からそれらを非表示にしたい場合があります。

たとえば、アプリインテントがアプリ内のローカル関数を呼び出すと、便利なショートカットアクションは実行されません。

その場合、App IntentのisDiscoverableプロパティをfalseに設定できます。

サーバーから最新のデータを取得するNext Busウィジェットに更新ボタンを追加します。

それは私のウィジェットの目的を果たしますが、便利なショートカットアクションにはなりません。

このアプリインテントをインタラクティブウィジェットからのみ使用したいので、isDiscoverableをfalseに設定します。

検出不能とマークされたアプリインテントは、アプリショートカットにも参加できないことに注意してください。

私のアプリのインテントはかなり迅速に実行されますが、すべてのインテントが実行されるわけではありません。

今年は、長期的な意図に進歩を提供する新しい方法を導入しました。

進捗状況を報告するには、App IntentをProgressReportingIntentプロトコルに準拠させるだけです。

Perform() メソッド内では、提供された進捗オブジェクトにアクセスできます。

totalUnitCountを設定し、Intentの実行が進むにつれてcompletementUnitCountをインクリメントして、進行状況を更新します。

ショートカットアプリは、App Intentの実行の進行状況を自動的に表示するようになりました。

進捗報告の実施は、長期にわたる意図にとって特に重要です。

人々がそのフィードバックを持つことは本当に貴重なので、彼らは意図のパフォーマンスが前進し、それがいつ完了するかを知っています。

今年は、アプリが検索アクションと統合する方法も改善しました。

ショートカットユーザーは、メモを見つけるなどのアクションで、特定の基準でアプリ内のコンテンツを見つけることができるのが大好きです。

これらのアクションの出力は、電子メールの送信など、他のショートカットアクションに送信でき、多くの強力なワークフローが可能になります。

iOS 16では、EntityPropertyQueryを実装し、ユーザーが指定できる基準を宣言することで、アプリの検索アクションを自動的に取得できます。

iOS 17以降、代わりにEnumerableEntityQueryプロトコルを使用することもできます。

それは本当にシンプルで採用が簡単です。

EnumerableEntityQueryの実装は、allEntities()メソッドでエンティティのすべての可能な値を返すのと同じくらい簡単です。

ショートカットとアプリインテントはそこからそれを取り、自動的に検索アクションを生成します。

EnumerableEntityQueryとEntityPropertyQueryの違いは、EntityPropertyQueryを使用すると、開発者、基準を送信し、ユーザーに代わって検索を実行することです。

つまり、多くの場合、限られた一連の結果を返すことになります。

EnumerableEntityQueryを使用すると、フレームワークにすべての可能なエンティティを与え、ショートカットがフィルタリングを行います。

すべてのエンティティを返すため、EnumerableEntityQueryは本当に使いやすいですが、少数のエンティティにも最適化されています。

Safariのタブグループなどのケースではうまく機能しますが、Notesアプリに典型的な多数のエンティティには適していません。

また、多くのメモリを消費する非常に大きなエンティティには適していません。

この場合、EntityPropertyQueryを使用して、すべての可能なエンティティを一度に返すのではなく、あなたの側で検索を実行できます。

最後に、IntentDescriptionのアップデートについてお伝えしたいと思います。

これは、アクションに関する詳細情報を取得するために詳細ボタンをタップしたときに人々が見るショートカットUIに記入するために使用するタイプです。

IntentDescriptionには、説明テキスト、カテゴリ名、検索キーワードが含まれます。

iOS 17では、Intent DescriptionタイプがresultValueNameという新しいプロパティで更新されたため、アクションの出力に対してよりわかりやすい名前を指定できます。

ここで、「リマインダーを追加」は、作成して返されたリマインダーの「新しいリマインダー」の結果ValueNameを提供します。

ここでの「リマインダーを追加」アクションが結果表示アクションに接続されている場合、結果表示アクションのパラメータには「新しいリマインダー」という名前が表示されます。

resultValueNameを提供するには、IntentDescriptionで新しい初期化子を使用するだけです。

iOS 17以降では、EntityPropertyQueryまたはEnumerableEntityQueryプロトコルを使用して生成された検索アクションのインテントの説明を含めることもできます。

これを行うには、クエリタイプ内でfindIntentDescriptionプロパティを採用するだけです。

アクションをcategoryNameで分類すると、アプリでサポートされているアクションのリストで、生成された検索アクションを目的のカテゴリの下に表示できます。

要約すると、アプリインテントは、アプリの機能をシステムとユーザーに公開する素晴らしい方法です。

アプリのインテントをアプリのショートカットに変えて、人々がすぐに使用できるようにする方法についてさらに学ぶには、「アプリのショートカットでアプリをスポットライトする」セッションをチェックすることをお勧めします。

今年、App Intentsを使用すると、設定可能でインタラクティブなウィジェットとライブアクティビティを構築し、ショートカットアプリへのより深い統合により、さらにスムーズな開発者体験を提供します。

あなたのアプリが新しいApp Intentsテクノロジーをどのように活用して驚きと喜びを喜ばせるかを見て、本当に興奮しています。

参加してくれてありがとう。

。