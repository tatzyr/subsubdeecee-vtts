10054

♪ ♪

Aasim：こんにちは、私はAasim Kandrikarです。後でRaleigh Ledetが参加します。

私たちは両方ともAppKitチームのエンジニアです。

このビデオでは、macOS Sonomaの「AppKitの新機能」について説明します。

AppKitコントロールの新機能とAPI強化、まったく新しい実装によるメニューの改善、macOSでのアプリのアクティベーションの仕組みの変更、グラフィックの改良と画像とシンボルの新機能、新しいテキスト入力体験、英語以外の言語のテキストレイアウトの改善、SwiftとSwiftUIでの作業の改善など、幅広いトピックを取り上げます。

macOS Sonomaには、AppKitコントロールにいくつかのエキサイティングな新機能とAPIの改良が含まれています。

NSTableViewとNSOutlineViewは、箱から出してすぐに使用できる多くの機能を提供し、AppKitを使用して優れたMacアプリを設計する上で重要な要素となっています。

macOS Sonomaでは、列のカスタマイズメニューを表示する新しいAPIがあります。

メニューを使用すると、ユーザーはテーブル内の列の可視性を切り替えることができます。

以前は、このメニューを作成して表示するためにカスタム実装が必要でしたが、今ではわずか3行のコードでこれを追加できます。

新しいデリゲートメソッドtableView userCanChangeVisibilityOfを採用します。

ユーザーが非表示にできる列を指定すると、AppKitはメニューのローカライズや再起動時に非表示の列の状態を復元するなど、残りを処理します。

FoundationのProgressタイプは、アプリケーションが実行する作業を表します。

アプリでこれを使用して、進行中のダウンロードや処理中の画像を表すことができます。

macOS Sonomaでは、NSProgressIndicatorでFoundationのProgressタイプを使用できるようになりました。

新しい observedProgressプロパティに進行状況を割り当てると、進行状況インジケーターは、バックグラウンドスレッドでも、進行状況の変化に応じて自動的に値が更新されます。

ボタンベゼルスタイルAPIが更新され、まったく新しいベゼルスタイルから始まり、自動です。

このベゼルスタイルは、ボタンの内容とビュー階層のどこにあるかに応じて、最も適切なスタイルに適応します。

たとえば、ボタンがウィンドウにある場合、プッシュボタンのスタイルを選択します。

ボタンがツールバーに配置されると、ツールバーのスタイルが選択されます。

背の高いコンテンツの場合、ボタンは柔軟なプッシュボタンスタイルを選択します。

自動ベゼルスタイルは、すべてのボタン初期化子のデフォルトのベゼルスタイルになりました。

既存のベゼルスタイル名は、その意味的な使用法に基づいて、外観の説明から現代的な名前に更新されました。

たとえば、以前は「埋め込み」という名前のボタンは「アクセサリーバー」ボタンになり、このベゼルスタイルがアクセサリーバーで最も一般的に使用されていることを示しています。

落胆したベゼルスタイルは非推奨になりました。

非推奨は、明確なセマンティック使用法を持つ代替ベゼルスタイルを参照するようになりました。

私たちは、まったく新しいスプリットビュータイプ、検査官を導入しました。

インスペクタは、ドキュメントで現在選択されているコンテンツに関するコンテキスト情報を表示する末尾の分割ビュー項目です。

サイドバーと同様に、インスペクタはフルサイズのコンテンツビューマスクが設定されている場合、ウィンドウの全高値を使用します。

新しい検査官はmacOS Big Surに再び展開します。

アプリにインスペクタを追加するのは簡単です。

まず、新しいinspectorWithViewController初期化子を使用して、新しい分割ビュー項目を作成します。

次に、新しいsplitViewItemを既存のスプリットビューコントローラーに追加します。

次に、ツールバーデリゲートを更新して、新しいトグルインスペクタツールバー項目を含めます。

一般的に、トグルインスペクタ項目をウィンドウの後縁のインスペクタの上に配置したい。

これを行うには、トグルインスペクタアイテムの前に、新しいインスペクタ追跡セパレータと柔軟なスペースを追加します。

NSPopoverにいくつかの改善をもたらしました。

まず、ツールバー項目からポップオーバーをアンカーするサポートを追加しました。

また、フルサイズのポップオーバーコンテンツをサポートする方法も追加したので、あなたのビューはポップオーバーの境界全体を埋めます。

ツールバーのアンカーから始めます。

ツールバー項目を基準にしてポップオーバーを表示する新しい方法があります。

ツールバー項目がオーバーフローメニューにある場合、ポップオーバーはオーバーフローシェブロンに固定されて優雅に表示されます。

次に、ポップオーバーコンテンツがポップオーバーシェブロンに拡張できるようになりました。

色付きの背景ヘッダービューのポップオーバーがあれば、こんな感じだったかもしれません。

ヘッダーの背景の色はポップオーバーシェブロンに拡張されないことに注意してください。

ポップオーバーコンテンツをシェブロン領域に拡張するには、新しいhasFullSizeContentプロパティをtrueに設定します。

セーフエリアrectを使用して、ポップオーバー内で隠すべきではないコンテンツをレイアウトします。

そして今、私はそれをローリーに渡して、メニューのエキサイティングな変更について話します。

ローリー:ありがとう、アーシム。

メニューはCocoaを完全に使用するために書き直されました。

これにより、メモリとCPU使用率を大幅に削減することで、AppKitの二酸化炭素排出量が削減されます。

また、新機能も有効にします。

具体的には、セクションヘッダー、パレットメニュー、新しい選択動作、バッジについて説明します。

これらの機能は、新しい機会を開き、書く必要があるコードの量を減らします。

セクションヘッダーは、メニューでグループを伝えるのに役立つ新しい追加であり、1行のコードで作成できます。

新しいクラス関数、sectionHeader(title:)を使用して作成し、他のメニュー項目と同様にメニューに追加します。

この例では、3つのメニューセクションが作成され、それぞれにセクションヘッダーと2つの項目があります。

パレットメニューは、アイテムが水平シリーズでレイアウトされているメニューを構築できるエキサイティングな新機能です。

例えば、このシンプルなカラーピッカー。

メニューのpresentationStyleを.paletteに設定することで、任意のメニューをパレットメニューに変えることができます。

メニュー項目ごとに、その画像を設定します。

テンプレート画像の場合、AppKitは自動的に適切な選択色合いを追加します。

または、offStateImageとonStateImageを設定することもできます。

onStateImageは、選択を示すために使用されます。

選択できる選択モードがいくつかあります。

.selectAnyは個々のメニュー項目の状態を切り替えますが、グループ内の他の項目の状態は変更されません。

.selectOneは、グループの他のメンバーの状態をオフに設定しながら、選択したメニュー項目の状態をオンに設定します。

selectedItems プロパティを使用して、どのアイテムがオン状態にあるかを取得または設定することもできます。

注: selectionMode と selectedItems は、同じターゲット/アクションのペアを持つメニュー項目を論理グループに整理することで機能します。

パレットメニュー項目を手動で作成する場合は、新しいselectionModeとselectedItemsの動作を利用するために、各項目に同じターゲット/アクションペアを与えます。

そして、ここにヒントがあります:このテクニックはパレットメニューに限定されません。

また、通常のメニューで同じターゲット/アクションペアを持つメニュー項目にも機能します。

NSMenuは、一般的なパレットメニューを作成するための便利な機能も提供します。

色の配列は、パレットアイテムの数とその色合いを決定します。

タイトルはアクセシビリティに使用されるので、必ず追加してください。

オプションのテンプレートパラメータは、着色に使用するテンプレート画像を指定します。

例えば、ここで使われている旗のシンボル画像。

テンプレートを指定しない場合、AppKitはデフォルトで塗りつぶされた円になります。

オプションのクロージャパラメータもあります。

このクロージャは、ユーザーがパレットのメニュー項目を切り替えるときはいつでも呼び出されます。

メニューは閉鎖に渡されます。

そこから、selectedItemsプロパティを使用して、on状態のメニュー項目の配列を取得できます。

メニュー項目は、さまざまな方法でバッジを付けできるようになりました。

単純な文字列を使用するか、カウントのみを使用できます。

また、新しいアイテム、アラート、アップデートの3つの特殊なカウントバッジもあります。

これらのバッジの1つを使用すると、AppKitは自動的に適切なテキストを追加します。

さらに、AppKitはテキストも適切にローカライズします。

この例では、日本語。

ただし、メニュー項目自体と一般的な文字列バッジバリアントをローカライズする責任があることに注意してください。

これは、パフォーマンス、バッジ、パレット、セクションヘッダーの改善など、まったく新しいメニューの実装です。

macOS Sonomaでは、Cooperative App Activationを導入しました。

協力的なアプリのアクティベーションは、入力中のアプリスイッチなど、予期しないアプリケーションスイッチを減らします。

協力的なアプリのアクティベーションには2つの部分があります。

アクティベートは、コマンドとは対照的に、リクエストになりました。

システムは、アクティベーション要求が適切かどうかを判断するために、ユーザーが行っていることのより広い文脈を考慮します。

新しいイールドAPIにより、アプリケーションは将来のアクティベーションリクエストのコンテキストに影響を与えることができます。

これでアクティベーションはリクエストなので、無視OtherApps パラメータとオプションは無視されます。

そのため、macOS Sonomaでは、activate(ignoringOtherApps:)機能とactivateIgnoringOtherAppsオプションはどちらも非推奨です。

NSApplicationとNSRunningApplicationの新しいアクティベートAPIに置き換えてください。

アクティブなアプリケーションのみがアクティベートコンテキストに影響を与えることができます。

これは、ターゲットアプリケーションがアクティブ化される前に、明示的なターゲットアプリケーションに屈することによって行います。

次に、ターゲットアプリケーションがアクティベーションを要求すると、システムは決定を下す際にコンテキストの一部として歩留まりを使用します。

リクエストが尊重されると、アクティブなアプリが無効になり、ターゲットアプリがアクティブになります。

それ以外の場合、アクティブなアプリはアクティブなままです。

NSWorkspaceは、URLやアプリケーションを開くときに自動的にこれを処理します。

他のケースでは、別のアプリケーションに手動でアクティベーションを手渡すには、ターゲットNSRunningApplicationまたはバンドル識別子にyieldActivationします。

システムは、ターゲットアプリがアクティベーションを要求するとき、またはそれに代わってアクティベートされたときに、イールドコンテキストを使用します。

それが新しい協力的なアプリのアクティベーション行動です。

また、いくつかの重要な変更を加え、macOS Sonomaのグラフィックと描画に新しいAPIを追加しました。

NSBezierPathsからCGPathsを作成できるようになり、その逆も同様です。

NSBezierPathは、新しいinit(cgPath:)初期化子とcgPathプロパティを取得します。

cgPath でイニシッティング、設定、または取得すると、常にパスのコピーが作成されます。

NSBezierPathのさらなる突然変異は、オリジナルまたはコピーのCGPathインスタンスに反映されません。

つまり、それらはフリーダイヤルブリッジではありません。

この追加により、1行のコードであるCAShapeLayerのpathプロパティなど、CGPath APIでNSBezierPathを使用できます。

macOSでCADisplayLinkオブジェクトを作成できるようになりました。

これは、あなたがiOSからよく知っているかもしれないのと同じCADisplayLinkです。

CADisplayLinkに精通していない人にとっては、アプリが図面をディスプレイのリフレッシュレートに同期させることを可能にするタイマーオブジェクトです。

直接初期化されたディスプレイリンクオブジェクトはメインディスプレイと同期されますが、macOSは単一のディスプレイに限定されません。

したがって、macOSでは、新しいdisplayLink(target:selector:)機能を使用して、NSView、NSWindow、またはNSScreenから直接ディスプレイリンクオブジェクトを取得できます。

最善のアプローチは、最も特定の適用可能な要素、通常はビューから直接CADisplayLinkオブジェクトを取得することです。

これは、ビューまたはウィンドウから作成すると、CADisplayLinkは、ディスプレイにないときに自分自身を一時停止するなど、デスクトップ上を移動するウィンドウのディスプレイまたはビューを自動的に追跡するためです。

このビューサブクラスでは、2行のコードでstartAnimatingが呼び出されると、stepAnimation関数を呼び出すDisplayLinkオブジェクトを作成し、ビューがオンになっているディスプレイに同期し、共通モードのメインランループにdisplayLinkを追加します。

アニメーションが完了すると、無効化を呼び出して表示リンクを停止し、登録されたすべてのランループモードから削除します。

NSColorは現在、背景形状を埋めるための5つの新しいシステムカラーを提供しています。

塗りつぶし色は、さまざまなサイズの形状にさまざまなレベルの重点を提供します。

スライダートラックやプログレスバーの背景のスケールの小さな図形は、システムフィルやセカンダリシステムフィルなど、より高いレベルの強調を使用して目立ちます。

グループボックスやフォントの背景などの大きな図形は、四元数や五分システムの塗りつぶしなど、より微妙なレベルの強調を好みます。

これらの塗りつぶし色は動的なので、コントラストの増加やダークモードなど、さまざまな外観に自動的に適応します。

カスタムUI要素を構築している場合、これらの新しい塗りつぶし色は、システム設計に適合し、アクセシビリティをサポートする便利な方法です。

NSViewsは、描画内容を限界までクリップします。

それは時々、FreeFormアラートウィンドウのこのヒンディー語グリフの下部のように、あなたが望むように表示しない描画につながります。

これが起こりうる一般的な場所は、フォントレンダリング、シャドウ、またはその他のサブビューのアクセント、販売用の「ホット」アイテムのバッジや炎などです。

これを解決する方法があります。

たとえば、結合されたビューをより大きなビューに兄弟として埋め込みます。

しかし、それぞれのテクニックには独自の欠点があります。

この場合、囲むビューと単純な水平スタックのボタンを組み合わせると、デフォルトではテキストのベースラインが並べられません。

そして今、あなたは解決すべき別の問題があります。

もっといい方法があります。

macOS Sonomaでリンクすると、ほとんどのNSViewはデフォルトで境界にクリップされなくなりました。

ヒットテストは変更されず、ビューのジオメトリによって決定されます。

もちろん、hitTestをオーバーライドしてこれを変更できます。

ビューがその境界の外に描画される可能性があるので、その計算されたvisibleRectもその境界を超えて拡張する可能性があります。

visibleRectを使用するコードを確認し、それに応じて調整します。

これは、ドロー関数のdirtyRectパラメータにも影響します。

具体的には、dirtyRectはビューの境界に制約されません。

AppKitは、ビューの境界よりも大きいdirtyRectを渡す権利を留保します。

AppKitはまた、図面を必要な数の長方形に細分化する権利を留保します。

これがあなたにとって意味することは、dirtyRectを使用して、どこに描くかではなく、何を描くかを決める必要があるということです。

これは、発生する可能性のある予期しない描画結果の例です。

このドローオーバーライドは、dirtyRectで渡されたものを背景色で塗りつぶし、塗りつぶしがビューの境界の外にこぼれ、ウィンドウ内の他のUIをカバーします。

ビューは、フレームを描画するためにdirtyRectを使用していません。

同様に、その背景の塗りつぶしは、あなたのデザインが必要とするものを正確に塗りつぶす必要があります。

dirtyRectの外に絵を描くことは常に安全です。

dirtyRectのパフォーマンスの利点は、このパスで描画を避けることができるデータのどの部分を決定するために使用されるときに発生します。

おそらく、この派手なスタイルで私の名前のストロークパスを計算するのは高価です。

dirtyRectがこの小さなコーナーであれば、テキストフレームと交差しないので、ビューはそれらの高価な計算を避けることができます。

背景とフレームの描画はまだ必要ですが、境界全体を満たし、このパスでフレーム全体を描くことは、AppKitが図面をdirtyRectにクリップするため、ビューの他のすでに描画された部分には影響しません。

新しいNSView .clipsToBoundsプロパティは、OS X Mavericks 10.9までさかのぼって利用できます。

しかし、古いOSでは、.clipsToBoundsをオフにすると、いくつかの粗いエッジがある可能性があることに注意してください。

それに応じてテストしてください。

ほとんどのビューは、クリッピングのオンとオフの両方で問題なく動作します。

一部のコンテナビューは、独自の明示的な決定を下します。

NSClipViewは、その名前に忠実で、このように動作します。

ビューのデフォルトのクリッピング動作に同意し、選択的に変更する必要がある特定の場合があります。

あなた自身のビューのどれが明示的なclipsToBounds値を必要とするかをケースバイケースで検討してください。

正しい選択は、あなたのアプリのビジョンを実現するものです。

さて、画像について話すためにアーシムに戻ります。

アーシム:ありがとう、ローリー。

シンボルは、アプリの設計に不可欠な部分です。

macOS Sonomaでは、シンボルはまったく新しい機能、シンボル効果を得ます。

シンボル効果を使用すると、シンボルはバウンス、置換トランジション、パルスアニメーションなどの効果を持つことができます。

シンボル効果は、アプリで発生したアクションや状態の変化を強調する素晴らしい方法です。

シンボル効果の追加は簡単です。

まず、imageViewの画像プロパティをシンボル画像に設定します。

次に、エフェクトが必要な場合は、画像ビューにaddSymbolEffectを呼び出すだけです。

これは、NSImageViewがシンボル画像を使用している場合にのみ機能することに注意してください。

シンボルエフェクトの使用の詳細については、「アプリでシンボルをアニメーション化する」ビデオをご覧ください。

macOS Venturaでは、ユーザーの現在のロケールに自動的に適応するためのSFシンボルのサポートを導入しました。

macOS Sonomaでは、アセットカタログの画像とシンボルが同じ機能を取得します。

macOS VenturaのSFシンボルと同様に、デフォルトではシステムロケールに従います。

画像ロケールメソッドを使用して、固定ロケールで画像を取得します。

次に、ハイダイナミックレンジのコンテンツ、略してHDRについて話します。

HDRコンテンツは、標準コンテンツをはるかに超える光レベルを表現できます。

macOSはいくつかのリリースで拡張ダイナミックレンジをサポートしており、Macbook ProのLiquid Retina XDRやPro Display XDRなどのディスプレイを最大限に活用できます。

macOS Sonomaは、NSImageViewがHDRコンテンツをサポートすることで、アプリにHDRコンテンツをこれまで以上に簡単に表示できるようにします。

HDRコンテンツを含む画像は、拡張ダイナミックレンジ対応ハードウェアでHDRで表示されるようになりました。

標準のダイナミックレンジでHDRコンテンツを表示するには、preferredImageDynamicRangeプロパティを使用してオーバーライドします。

このAPIの採用の詳細については、「アプリでHDR画像をサポートする」ビデオをご覧ください。

Xcode 15以降、アセットカタログの画像と色は、NSImageとNSColorの静的プロパティとして自動的にコードに反映されます。

これにより、文字列で初期化するのではなく、クリーンなドット表記を使用して画像にアクセスできます。

画像はオプションではないので、強制的なアンラッピングやガードチェックを削除することもできます。

アセットカタログを変更して画像を削除または名前を変更すると、コンパイラはコードとの不一致をキャッチし、アプリの構築時にエラーが発生し、後で実行時にキャッチするのではなく、すぐに修正することができます。

macOS Sonomaでは、タイピング体験が大幅に変更され、英語以外の言語のテキストレイアウトが改善されました。

それは、現在のアクセントカラーに適応する真新しい挿入インジケーターから始まり、テキストを口述する際に後続の輝きを残します。

次に、挿入インジケーターの下にカーソルアクセサリがあり、入力モード、ディクテーション状態、caps lock状態などの重要な情報が表示されます。

アクセサリは現在の挿入位置を追跡し、挿入位置が可視ビューの外にある場合、ドキュメントの下部に固定されます。

標準のAppKitテキストビューを使用するアプリは、これを自動的に取得します。

カスタムテキストビューをお持ちの場合は、採用できる新しいAPIがあります。

カスタムテキスト挿入インジケータの描画をNSTextInsertionIndicatorビューに置き換えることができます。

このビューをカスタムテキストビューのサブビューとして追加すると、OS全体で一貫性のある新しい挿入インジケーターが表示されます。

挿入インジケーターのフレームの更新と、それが表示されているかどうかを担当することに注意してください。

テキストビューがファーストレスポンダーを辞任したときにdisplayModeプロパティを非表示に更新してインジケーターを非表示にします。

MacOS Sonomaは、英語以外の言語のテキストレイアウトにいくつかの改善が施されています。

重要なハイライトは、テキストコンテキストに応じて改行に異なるルールを必要とする言語によって、ラッピングとハイフネーションのために行った変更です。

たとえば、韓国語の伝統的な組版では、本文テキストは単語の真ん中に改行があるかもしれませんが、タイトルテキストは単語の境界でのみラップされます。

タイトルの単語を壊すと、韓国語で耳障りに感じることがあります。

マップのこのシートでは、韓国語の「時間」は2行に分かれています。

macOS Sonomaは、使用するテキストスタイルのフォントに応じて異なる改行を実行するようになりました。

韓国語では、このシートのようなタイトルと見出しのテキストスタイルは、単語の境界でラップされません。

必要に応じて、本文テキストスタイルは単語内に改行がある場合があります。

これは別の例です。

狭いレイアウトでは、一部のドイツ語の単語は行幅全体よりも長くなる可能性があり、個々の文字が次の行にこぼれる可能性があります。

このラッピングは理想的ではありません。

それは不均衡に見え、形態素と呼ばれる単語の構成要素があり、それは行に分割されています。

macOS Sonomaでは、ハイフネーションが無効になっているタイトルテキストフィールドがある場合、macOSは文字の折り返しではなく、形態素の境界でテキストを自動的にハイフネーションします。

結果として得られるレイアウトは、よりバランスが取れており、読みやすくなっています。

これは、アプリでテキストスタイルを採用するのに最適な時期です。

macOS Sonomaでは、AppKitが更新され、Swiftの並行性や譲渡可能などのSwiftファースト機能の採用が容易になりました。

SwiftUIも更新され、AppKitアプリのより多くの場所でSwiftUIビューと修飾子を使用できるようになります。

AppKitクラスの大半はメインスレッドに制限されています。

Swiftの並行性では、これらのクラスは適切なコンパイラエラーを生成するためのメインアクターとしてマークされます。

ただし、AppKitには、NSColorやNSShadowなど、メインスレッドの外で安全にアクセスできる特定のクラスがあります。

macOS Sonomaでは、これらのクラスはSendableプロトコルに準拠しており、アクターの境界を越えて自由に転送できることを示します。

Transferableは、オブジェクトをシリアライズおよびデシリアライズする方法を説明するSwiftプロトコルです。

これは、SwiftUIでのドラッグ&ドロップや共有などの機能を強化します。

macOS Sonoma NSImageでは、NSColor、およびNSSoundはTransferableプロトコルに準拠しています。

これにより、AppKitアプリはSwiftUIビューでのドラッグ&ドロップや共有などの機能を簡単に採用できます。

macOS Ventura 13.3では、NSViewControllerの新しいプロパティラッパー、ViewLoadingを導入しました。

loadViewで初期化されたプロパティでViewLoadingを使用します。

これらのプロパティが以前にオプションだった場合は、オプションと関連するチェックを削除できます。

ビューコントローラーは、loadViewIfNeededを呼び出すことで、プロパティが初期化されていることを確認します。

同様のプロパティラッパーであるWindowLoadingは、NSWindowControllerのプロパティでも使用できます。

Xcode 15では、プレビューを使用してAppKitビューとビューコントローラーを表示できるようになりました。

新しいプレビューマクロを使用し、名前を指定し、ビューまたはビューコントローラーを返します。

コードを変更すると、プレビューは最新の状態に保たれます。

詳細については、「XcodeプレビューでプログラマティックUIを構築する」ビデオをご覧ください。

NSHostingViewとNSHostingControllerは、AppKitアプリにSwiftUIを段階的に採用する素晴らしい方法です。

macOS Sonomaには、より多くの場所でSwiftUIを採用できる新機能がいくつかあります。

ツールバーやナビゲーションタイトルなどのSwiftUI修飾子がNSWindowsで動作するようになりました。

hostingViewがウィンドウのcontentViewの場合、SwiftUIは利用可能なすべてのシーン修飾子を自動的にNSWindowにブリッジします。

より多くの制御のために、NSHostingViewとNSHostingControllerに新しいプロパティ、sceneBridgingOptionsがあります。

これを使用すると、SwiftUIビューからNSWindowにブリッジする必要があるプロパティを明示的に述べることができます。

これは、macOS SonomaのAppKitの新機能のほんの一部です。

次は何ですか?

まず、macOS Sonoma SDKを使用してアプリをコンパイルし、それを監査して、クリッピングとアクティベーションの変更が望ましくない副作用を引き起こさないことを確認します。

次に、新しいフルハイトインスペクタや新しいテーブル列のカスタマイズAPIなど、新しいコントロールAPIを採用します。

macOS Sonomaのシンボル効果を利用するために、アプリのデザインを更新してください。

そして最後に、TransferableやNSHostingViewの改善など、新しいSwiftに焦点を当てたAppKitの追加を使用して、アプリのより多くの場所でSwiftUIを採用します。

見てくれてありがとう。

macOS Sonomaのすべての新機能をお楽しみください!

♪ ♪