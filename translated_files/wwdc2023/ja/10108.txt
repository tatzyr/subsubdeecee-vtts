10108

♪ ♪

ジャレッド：こんにちは、「バックグラウンドアセットの新機能」へようこそ。

私の名前はジャレッドで、アップルのソフトウェアエンジニアです。

背景資産で今年の新しいことをすべてあなたと共有することを本当に楽しみにしています。

さて、私たちのチームは昨年、いくつかのことを変えました。

ただし、バックグラウンドアセットが導入された私の前のセッションをチェックすることをお勧めします。

そこには、この新しいセッションが構築する多くの詳細な情報があります。

このセッションでは、バックグラウンドアセットの概要と、それをアプリに採用すべき理由を説明することから始めます。

次に、私たちのチームがあなたと共有することに本当に興奮している全く新しい機能を含むバックグラウンドアセットの今年の新機能について話し合います。

次に、自分でダウンロードできるバックグラウンドアセットのサンプル実装を順を追って説明し、この技術を採用することでアプリのユーザーエクスペリエンスを大幅に向上させる方法を紹介します。

次に、アプリ拡張機能のデバッグとそのエントリポイントのシミュレーションに関するガイダンスを提供します。

オーケー！バックグラウンドアセットの簡単な要約を見てみましょう。

バックグラウンドアセットの背後にある主な目標の1つは、待つことを防ぐことです。

ユーザーが体験したい最後のことは、アプリを起動し、大量のダウンロードが完了するのを待たなければならないことです。

バックグラウンドアセットは、そのフレームワークと関連するアプリ拡張機能を組み合わせてこの問題を解決します。

この新技術は、macOS Venturaの最初のリリースと同時にiOS 16.1で導入されました。

CDNプロバイダーまたは管理するサーバーを使用して、アプリの追加コンテンツをダウンロードする機能をサポートしています。

たとえば、このコンテンツは、最初のアプリのインストール時、アプリの更新時、またはユーザーがアプリを使用していないときに定期的にバックグラウンドで取得される場合があります。

ペアリングされたアプリ拡張機能を通じて、アプリがユーザーによってアクティブに使用されていないときに実行されるコードを書くことができます。

この技術は現在、macOS、iOS、iPadOSでサポートされているため、お気に入りのプラットフォームですでに利用可能です。

バックグラウンドアセットの使用に関する最良の部分の1つは、ユーザーがアプリを起動する前に拡張機能を実行できることです。

これは、アプリがApp Storeからインストールされた瞬間にアセットの取得を開始する方法を提供します。

拡張機能は、バックグラウンドでシステムによって定期的に起動されることもあります。

これは、ユーザーがアプリを起動したときに、新規または更新されたアセットが存在することを確認するためです。

この拡張機能は、アプリが実行されていないときにダウンロードにサービスを提供するためにも使用されます。

たとえば、ファイルのダウンロードが完了すると、ファイルを最終目的地に移動できるように拡張子が起動します。

覚えておくべきことは、拡張機能のランタイムが限られているということです。

これは、ユーザーのデバイスが電力とパフォーマンスに最適化されていることを確認するためです。

これについてすぐに詳しく説明します。

また、バックグラウンドアセットで使用するために開発したアプリ拡張機能が、特殊なサンドボックスに配置されていることを知っておくことも重要です。

これは、拡張機能がバックグラウンドアセットを介してコンテンツを管理するためにのみ使用されていることを確認するためです。

サンドボックス内で機能やAPIが利用できない場合は、フィードバックアシスタントを通じてお問い合わせください。

先ほど、アプリの拡張機能は、アプリのインストール、アプリのアップデート、および定期的にバックグラウンドで3つのシステムイベント中に呼び出されると述べました。

このライフサイクルがどのように管理されているかを見てみましょう。

拡張機能のライフサイクルは、App Storeがデバイスにアプリをインストールまたは更新したときに始まります。

その後、バックグラウンドアセットシステムサービスが通知され、アプリの起動を防ぎます。

その後、システムはアプリバンドルを検査し、BAManifestURLキーのInfo.plistを読み取ります。

システムは、そのキーで参照されるマニフェストのダウンロードを開始し、ダウンロードの進捗状況をApp Storeに報告します。

マニフェストがダウンロードされると、システムは特定のインストールまたは更新イベントのコンテンツリクエストを発行して拡張機能をスリープ解除します。

コンテンツリクエストには、ダウンロードしたマニフェストへのパスが含まれています。

拡張機能は、マニフェストを使用して、URL、ファイルサイズ、およびダウンロードをスケジュールするアセットを決定する必要があります。

その後、拡張機能がダウンロードする必要があるアセットを決定したら、それらのダウンロードをBADownloadsのセットとして返します。

その後、システムはアプリの拡張機能を一時停止するか、時には終了して、デバイスの電力とパフォーマンスを節約します。

その後、ダウンロードが開始され、拡張機能は完了後すぐに通知されます。

定期的なコンテンツ要求は、アプリのインストールイベントとほぼ同じですが、唯一の重要な違いは、デバイスがイベントがいつ発生するかを決定することです。

デバイスは、ユーザーがデバイスをどのように使用しているかに基づいてこの決定を下します。

低電力モード、バックグラウンドアプリの更新、またはアプリの起動頻度などの重要な要素はすべて考慮されます。

さて、もう少し深く掘り下げて、エクステンションが定期的に実行されるときに寄与する要因を見てみましょう。

私たちはデバイスの全体的なパフォーマンスと電力使用量を非常に気にかけているため、バックグラウンドアセットは拡張機能のランタイムに制限を設けています。

これには、拡張機能のメモリ使用量の強制が含まれます。

拡張機能が数メガバイトのメモリを超えると、システムによって終了される可能性があります。

したがって、デバイスのストレージによってバックアップされたメモリマップされたデータはこの制限にカウントされないため、拡張機能が読み取る必要がある大きなファイルのメモリマッピングを検討することをお勧めします。

アプリが最初にインストールされると、1日あたり数分のランタイムのデフォルト割り当てが提供されます。

これはあまり聞こえないかもしれませんが、適切に設計された拡張機能では、これは長い道のりを行くことができます。

ランタイムはアプリの使用状況によっても変わります。

アプリがしばらく起動されていない場合、システムは拡張機能の起動を抑制し始める可能性があります。

たとえば、めったに使用されないアプリでは、ランタイムがより厳しく制限される可能性がありますが、一般的に使用されるアプリには追加のランタイムが与えられる場合があります。

BADownloaderExtensionプロトコルは、アプリ拡張機能へのエントリポイントとして使用される機能を定義します。

ランタイムは、関数がシステムによって呼び出されたときにカウントされ始め、その関数がスコープを終了したときにカウントされなくなります。

関数がスコープを終了するか、拡張機能のランタイムが使い果たされると、システムは拡張機能を一時停止または終了する可能性があります。

すぐに例を挙げます。

ただし、拡張機能のランタイムを制御する関数スコープには1つの例外があります。

非同期排他的制御APIが呼び出された場合、その完了ハンドラが呼び出されて返されるまで、拡張機能は実行され続けます。

拡張機能のランタイムがユーザーによって制御される方法はいくつかあります。

たとえば、デバイスが低電力モードの場合、またはバックグラウンドアプリの更新が無効になっている場合、それがグローバルであろうと特定のアプリであろうと、拡張機能は決して実行されなくなります。

以前、拡張ランタイムが関数スコープに基づいてどのように決定されるかについて言及しました。

それがどのように機能するかをよりよく理解するために、例を見てみましょう。

このコードは、バックグラウンドダウンロードにサービスを提供する拡張機能のインターフェースを表しています。

BADownloaderExtensionプロトコルは、システムが拡張機能に呼び出す機能を定義します。

それでは、このプロトコルに準拠するために必要な機能の1つを追加しましょう。

「リクエストのダウンロード」機能は、拡張機能への主要なエントリポイントの1つです。

そのBAContentRequestは、アプリのインストール中、アプリの更新中、またはバックグラウンドでの定期的なチェックの一部として呼び出されるかどうかを定義します。

manifestURL引数は、拡張機能が呼び出される前にダウンロードされたローカルファイルへのパスを提供します。

マニフェストファイルは、現在ダウンロードされているものと、サーバーで利用可能なダウンロードを比較するために一般的に使用されます。

関数定義の戻り値タイプには、BADownloadタイプに準拠した一連のダウンロードオブジェクトが必要です。

これは、この関数の要求に応答するには、関数がスコープを終了する前にダウンロードする必要があるコンテンツを同期的に返す必要があることを意味します。

しかし、この考案された例では、parseManifestという関数を呼び出すとしましょう。

この関数は、ダウンロードしたマニフェストを読み取り、ダウンロードする必要があるBADownloadオブジェクトを返します。

ただし、parseManifest関数の実装が不十分で、ダウンロードの解析と構築に30分かかるとしましょう。

これは、拡張機能のランタイムを大幅に超過し、拡張機能は終了します。

拡張機能のランタイムは、「リクエストのダウンロード」関数が呼び出された瞬間から、スコープを終了して返されるまで計算されることを覚えておくことが重要です。

別の問題のある例を見てみましょう。

BADownloaderExtensionプロトコル機能のいずれかがスコープを終了するたびに、拡張が一時停止されてから終了する可能性があります。

プロトコルはどの機能も突然変異として定義しておらず、これには正当な理由があることに気づくでしょう。

拡張機能が終了すると、インスタンス変数やインメモリ状態は保存されません。

拡張機能が何らかの状態を維持する必要がある場合は、その状態をディスクにシリアライズする必要があります。

次に、ダウンロードを管理するために拡張機能とアプリの両方から使用するAPIについて話しましょう。

フレームワーク内のダウンロードマネージャは、バックグラウンドアセットシステムサービスと通信する主な方法です。

マネージャーは、アプリ全体で使用できるシングルトンオブジェクトです。

マネージャーを使用すると、バックグラウンドでアセットのダウンロードをスケジュールし、すでにスケジュールされているダウンロードをフォアグラウンドにプロモートできます。

ダウンロードマネージャーから、アプリが起動する前に拡張機能によってスケジュールされていた可能性がある、現在飛行中のダウンロードを管理することもできます。

また、アプリと関連する拡張機能の両方が同時に同様の操作を実行していないことを確認するために使用できる同期メカニズムもあります。

ダウンロードマネージャーについて最後に持ち出したいのは、BADownloaderExtensionプロトコルと同様に、ダウンロードに関するコールバックを受信するためのデリゲートがあることです。

BADownloadManagerにデリゲートを登録すると、拡張機能の代わりにそれらのコールバックが届きます。

これは、アプリが実行中にダウンロードを管理する方法を提供するので便利です。

ダウンロードの管理方法について簡単に復習したので、すでにユーザーのデバイスにファイルがインストールされているときに、それらのファイルを管理する方法について話しましょう。

バックグラウンドアセットでダウンロードしたファイルはパージ可能とマークされています。つまり、システムは重大な状況下でそれらを削除する可能性があります。

システムのセキュリティアップデート、またはユーザーが子供の最初のステップのビデオをキャプチャする必要があるかどうかを考えてください。

ただし、ダウンロードしたアセットを変更または拡張した場合、それらのファイルはシステムによって追跡されないため、パージできません。

資産を変更したり、そこからデータを抽出したりする方法について慎重に考える必要があります。

ダウンロードしたアセットを誤って管理すると、ユーザーのデバイスのバックアップのサイズを大きくしたり、重要なセキュリティアップデートがダウンロードされないようにしたりする可能性があります。

したがって、ダウンロードしたアセットをキャッシュディレクトリに保存してみてください。

そうすれば、システムは、そうすることが重要なときにそれらをパージできることを知っています。

これで、これらすべてがどのように機能するかを完全に要約したので、バックグラウンドアセットで今年の新機能を見てみましょう。

今年初め、アプリのインストールまたは更新中にコンテンツを取得する方法を提供する必須ダウンロードを導入しました。

これは、ダウンロードがiOSのホーム画面、macOS Launchpad、およびApp Storeに完全に統合されていることを意味します。

エンドユーザーにとって、アセットのダウンロードは、アプリがまだApp Storeからダウンロードされているかのように表示されます。

これはまた、必須ダウンロードが飛行中である間、ユーザーがアプリを起動できないことを意味します。

ユーザーができることは、インストールをキャンセルまたは一時停止することだけです。

一時停止がサポートされているため、再開ができるように、サーバーはHTTP範囲をサポートする必要があります。

必須ダウンロードはアプリのインストール中に発生するため、必須ではないダウンロードよりも優先されます。

見てみましょう。 

すべては、App StoreまたはTestFlightからアプリが要求されたときに始まります。

アプリのInfo.plistに必須のアセットキーが含まれている場合、進捗状況がデバイスに設定され、このフローを通過します。

アプリがダウンロードされてインストールされると、システムはコンテンツのリクエストを発行して拡張機能をウェイクします。これには、アプリのインストール、アプリのアップデート、または定期的なフェッチのリクエストが含まれます。

この間、マニフェストをダウンロードするために認証チャレンジが送信される場合があります。

その後、あなたの拡張機能は、本質的なダウンロードと非本質的なダウンロードの組み合わせを返送します。

補足として、この機能が戻るまで、アプリのダウンロードの進行状況がユーザーにフリーズして表示されるため、拡張機能がダウンロードをすばやく返すことが重要です。

拡張機能がダウンロードを提供した瞬間、必須としてマークされたダウンロードはすぐに開始されます。

この間、エクステンションも追加の認証チャレンジを受ける可能性があります。

すべての必須ダウンロードが完了すると、システムは拡張機能を終了し、アプリはユーザーによって起動可能になります。

その後、拡張機能は、成功したダウンロードと失敗した可能性のあるダウンロードのバッチを受け取ります。

ダウンロードに失敗した場合は、BADownloadManagerを使用して不要として再キューに入れることができます。

拡張機能が必須ダウンロードの完了メッセージを受信しているため、システムはすぐに非必須資産のダウンロードを開始します。

必須でないダウンロードは、ダウンロードが完了すると拡張機能に送信されます。

それでは、iOSホーム画面のApp Storeのインストールの進捗状況に不可欠なダウンロードがどのように統合されているかを見てみましょう。

進捗インジケーターの割合は、基本アプリのダウンロードにかかる時間、インストールにかかる時間、続いて重要な資産のダウンロードに必要な時間に分類されます。

アプリのInfo.plistで定義された新しいBAEssentialDownloadAllowanceキーは、最初の全体的な進捗インジケータを設定するために使用されます。

次に、contentForRequestが拡張機能に呼び出され、拡張機能がダウンロードを返すと、各必須ダウンロードのファイルサイズが一緒に追加され、実際にダウンロードされている量が決定されます。

ダウンロードをスケジュールする金額が必須ダウンロード許容量よりも大幅に少ない場合、進行状況インジケータはかなり速く動く可能性があります。

ユーザーの円滑な進行を確実にするために、実際にダウンロードされているものに近い必須ダウンロード許容量を得ることを目指すべきです。

私たちが議論したことはすべて、ユーザーによって無効にされる可能性があることを覚えておくことが重要です。

App Storeの設定ペインには、アプリ内コンテンツを無効にするためのセクションがあります。

これはバックグラウンドアセット全体を無効にしませんが、ユーザーがアプリを起動する前に、重要なアセットのダウンロードと拡張機能の実行を防ぎます。

したがって、不可欠な資産をまさにそれと考えることが重要です。不可欠ですが、アプリを起動するための要件ではありません。

したがって、アプリが起動されたときに、必須資産がまだデバイス上にないフローを処理することが重要です。

エッセンシャルアセットを使用する機能は、実際には春の初めにiOS 16.4とmacOS Ventura 13.3の一部として導入されました。

新しいAPIは非常に最小限で、既存の拡張機能に簡単に追加する必要があります。

必須ダウンロードをサポートするために作成された最初のAPIは、実際にはBAURLDownloadの新しい初期化子でした。

この機能をサポートするために特別に追加した2つの新しい引数があります。

本質的な議論は、その名前が示すように、ダウンロードを必須としてマークする必要があるかどうかを指定し、本質的な手段はアプリの全体的なダウンロードとインストールの進捗状況に貢献することを意味します。

ファイルサイズの引数は、ダウンロードされるアセットのサイズです。

重要なダウンロードを作成するときは、ファイルサイズが正確でなければなりません。

ユーザーのデバイスにアプリのインストールの進行状況が正しく表示されるように、この情報が必要です。

バックグラウンドアセットがダウンロードしたファイルがここで提供されたファイルサイズと一致しない場合、ダウンロードが必須としてマークされている場合、ダウンロードは失敗します。

拡張子がファイルのサイズがわからない場合は、拡張子が起動する前に拡張子に提供されるBAManifestURLにファイルサイズを含める必要があります。

導入された別のAPIは、ダウンロードの非本質的な表現を作成するための簡単なワンライナーを提供します。

必須ダウンロードはcontentForRequest関数でのみキューに入れられるため、このAPIは多くの場合に役立ちます。

たとえば、ネットワークの問題やファイルが一時的に利用できなくなったため、必須ダウンロードの取得に失敗したとします。

さて、拡張機能内のバックグラウンドダウンロード失敗関数では、そのダウンロードの不要な表現を簡単に作成し、それを再キューに入れることができます。

その後、ダウンロードはバックグラウンドで開始され、拡張機能またはアプリが完了すると通知されます。

それでは、アプリのInfo.plistに存在する必要がある必要なキーのいくつかを見てみましょう。

昨年のセッションでは、これらの各キーを詳細に説明しました。

より詳細な説明をご希望の場合は、その講演をチェックすることをお勧めします。

これらのキーは、バックグラウンドアセットフレームワークを使用するだけでなく、アプリをApp Storeに提出するためにも必要であることを覚えておくことが重要です。

今年は、重要な資産をサポートするために必要な2つの新しいキーがあります。BAEssentialDownloadAllowanceとBAEssentialMaxInstallSizeです。

必須ダウンロード許容量はバイト単位で表され、すべての必須資産の合計がダウンロードに要する金額の上限を定義します。

ユーザーがアプリをインストールしたときにダウンロードの進行がスムーズになるように、この番号をキューに入れる必須アセットのサイズにできるだけ近づけることが重要です。

もう1つの新しいキーであるBAEssentialMaxInstallSizeは、ユーザーのデバイスに抽出されたアセットの最大サイズを表します。

この数字は、重要な資産がインストールされた後、アプリが使用するストレージの量をユーザーに伝える方法として、App Storeに表示されます。

これは、重要な資産のために追加した新しいAPIをほぼ要約しています。

先ほど見たように、既存のアプリに不可欠なアセットサポートを追加することは、最小限のコード変更で行うことができます。

それは本当に簡単です。 

さて、楽しい部分のために。

URLSessionを使用する既存のアプリをバックグラウンドアセットの使用に拡張する方法を見てみましょう。

今日お見せするアプリは、これと同じようにWWDCセッションをダウンロードし、オフラインで視聴できるようにデバイスに保存します。

現在、ビデオがダウンロードされる前にアプリを起動する必要があります。

バックグラウンドアセットを採用することで、アプリが起動する前にビデオがすでにダウンロードされていることで、この待ち時間をなくすことができます。

見てみましょう。 

これが私たちが今日構築するアプリです。

起動した瞬間に、セッションがすぐにダウンロードされ始めることに気づくでしょう。

このアプリの現在の仕組みは、WWDCセッションのリストを含むサーバーからのマニフェストのダウンロードです。

マニフェストがフェッチされた後、セッションはダウンロードを開始し、タップすると表示可能になります。

このプロジェクトにバックグラウンドアセットを採用するために必要なものを見てみましょう。

バックグラウンドアセットAPIの使用を開始する前に、最初に追加するのは、先ほど説明した最初のInfo.plistキーです。

これらのキーは、アプリバンドルのInfo.plistファイルに存在する必要があります。

次に行う必要があるのは、バックグラウンドダウンロード拡張機能を追加してアプリに埋め込むことです。

拡張機能のバンドル識別子にアプリのバンドル識別子が先頭に付けられていることを確認する必要があります。

また、アプリグループとは、拡張機能がダウンロードしたアセットをアプリと共有する方法であるため、アプリとその拡張機能の両方が共通のアプリグループにあることを確認する必要があります。

最後に確認したいのは、アプリとその拡張機能の両方がチーム識別子で署名されていることです。

これらのステップを邪魔にならないようにして、バックグラウンドアセットの採用を開始できます。

目の前には、先ほど見たアプリのXcodeプロジェクトがあります。

私はすでにダウンロード拡張機能を作成し、アプリに埋め込みました。

また、必要なInfo.plistキーも追加しました。

そのすべてを邪魔にならないように、SessionManagerに移動することから始めましょう。

このプロジェクトのSessionManagerは現在、URLSessionを使用して最新のダウンロードを取得しています。

URLSessionは素晴らしいAPIです。

マニフェストを取得するためにアプリ内で引き続き使用します。

ただし、バックグラウンドアセットを使用して実際のセッションを取得するように移行します。

これは、アプリが起動時にフォアグラウンドに作成しようとしている拡張機能によって、バックグラウンドでスケジュールされたアセットを宣伝できるようにするためのものです。

まず、バックグラウンドアセットフレームワークモジュールをインポートすることから始めます。

その後、下にスクロールして、URLSessionに関連付けられた変数を削除します。

次に、「ダウンロードの開始」方法に移動します。

ご覧のとおり、既存のコードは、URLSessionダウンロードタスクによってダウンロードするセッションを追跡していました。

これはもう必要ないので、削除しましょう。

ここで物事が面白くなり始めます。

バックグラウンドアセットで作業するときは、拡張機能とアプリが同時に実行されている可能性について考えることが重要です。

これをほぼ楽な方法で調整するには、withExclusiveControlを使用して、他のプロセスとの相互排除を必要とする作業がそうできることを保証する必要があります。

今、それを追加しましょう。

わかるように、このAPIは非同期でエスケープです。

拡張機能がこのAPIも使用している場合、クロージャ内でスケジュールされた作業は、拡張機能から独立して実行されることが保証されます。

すぐに拡張機能を実装しますが、今のところはアプリに集中しましょう。

相互に排他的なコンテキストで実行されていることを知っているので、現在飛行中のダウンロードがあるかどうか、ダウンロードマネージャーに聞いてみましょう。

拡張機能がすでにスケジュールされている場合、ダウンロードを再スケジュールする理由はありません。

しかし、私たちができることの1つは、既存のダウンロードを見つけたら、それをフォアグラウンドに宣伝できることです。

ダウンロードをフォアグラウンドに宣伝すると、ダウンロードが終了するまでにかかる時間を大幅に短縮できます。

ユーザーは現在アプリを使用しているため、できるだけ早くダウンロードを取得する絶好の機会です。

ユーザーはそれを見たいと思うかもしれません。

ダウンロードがまだ存在しない場合は、作成します。

その後、ダウンロードを作成したばかりか、拡張機能が作成したかにかかわらず、フォアグラウンドで開始します。

バックグラウンドからフォアグラウンドにダウンロードを宣伝しても、ダウンロードが再起動することはなく、そのトランジションで中断したところから再開されるだけです。

リストの次のことは、BADownloadManagerDelegateを実装することですが、その前に、古いURLSessionDelegateを削除します。

古いデリゲートがなくなったので、バックグラウンドアセットデリゲートを作成しましょう。

セッションマネージャーはデリゲートに準拠しているため、これらのメッセージを実際に受信するために配線されていることが重要です。

だから私はイニシャライザに行き、今それを配線します。

BADownloadManagerはシステムスケジューラに直接接続するので、シングルトンオブジェクトです。

このデリゲートをダウンロードマネージャーに添付すると、アプリが現在実行されている場合、アプリは拡張機能を介してメッセージを受信します。

では、実装する必要がある機能に戻りましょう。

このアプリには、実装するデリゲートプロトコルに3つの特定の機能があります。

1つ目は進捗処理です。今すぐそれを実行しましょう。

UIの進捗状況を盲目的に更新する前に、進捗状況メッセージを受信しているダウンロードが、マニフェストが現在追跡しているものであることを確認します。

ダウンロードが追跡されている場合は、進捗状況をSwiftUIに直接送信するアプリ内のヘルパー機能であるupdateDownloadProgressを呼び出します。

次に、ダウンロードが終了したときに何が起こるかを実装します。

それはほぼ同じ方法で始まります。これは、予想されるダウンロードのみを処理していることを確認することです。

次に、replaceItemAtは、バックグラウンドアセットが私たちに与えた一時的な場所から最終的な場所にオブジェクトを移動するために使用されます。

デバイスのスペースが少なくなると、システムがファイルを追跡してパージするため、ここで移動操作を使用することが重要です。

したがって、アプリがファイルが欠落しているかどうかを常にチェックし、必要に応じて再フェッチすることを確認する必要があります。

ここで最後に起こることは、タスクがMainActorに対して生成され、状態がダウンロード済みとしてマークされ、アプリがセッションのサムネイルの取得を開始することです。

さて、すべてのダウンロードが成功すると言いたいです。

しかし、不幸な真実は、サーバーにそのリソースがなくなったからであろうと、ネットワークの問題があるからであろうと、失敗する可能性があるということです。

バックグラウンドアセットは再試行し、ネットワーク接続の問題を待ちますが、特定の時点を過ぎると、ファイルが進行中ではないことを知っておく必要があります。

もう一つ覚えておくべきことは、ネットワーク接続に問題がある場合、フォアグラウンドに昇格されたダウンロードはほぼ即座に失敗するということです。

ダウンロードに失敗したとき、私たちのアプリがする必要があることはあまりありません。

UIを表示したり、スケジュールを変更したりできますが、この例では、問題があったことをログに記録しましょう。

デリゲートが完全に実装されたので、アプリを再起動して、どのように見えるか見てみましょう。

まあ、驚くことではありませんが、それは同じように見えます、そしてそれは私たちがここで本当に見たかったものです。

URLSessionの代わりにバックグラウンドアセットを追加するのはとても簡単です。

次にお見せするのは、バックグラウンドダウンロードを処理するためのアプリ拡張機能を実装する方法です。

このアプリ拡張機能を追加することは、アプリがインストールまたは更新される前にバックグラウンドアセットを活用してコンテンツを取得する方法であり、重要な資産をキューイングするためのサポートを提供します。

本質的に、拡張機能は、アプリが実行されていない間にダウンロードをスケジュールする責任があります。

見てみましょう。 

ここでは、バックグラウンドアセットに関連する拡張機能内のメッセージを受信するバックグラウンドダウンロードハンドラです。

拡張機能から、私が最初に行うことは、拡張機能の実行中にConsole.appから確認できるようにロガーを作成することです。

次に、BADownloaderExtensionプロトコルの一部であるcontentForRequest関数を実装します。

この拡張機能が最初に行うことは、拡張機能が起動される前に事前にダウンロードされたマニフェストを解析することです。

ダウンロードされたマニフェストが何らかの形で無効な場合、拡張機能はダウンロードをキューに入れないように設定されます。

拡張機能がマニフェストが有効であることを知ったら、アトミックにアプリグループに保存されます。

これは、アプリと拡張機能がローカルでマニフェストの最新バージョンを持ち、後で参照できるようにすることです。

この保存はアトミックで行われるため、withExclusiveControlを使用する必要はありません。

その後、拡張機能は、拡張機能がスケジュールされるシステムに戻るダウンロードオブジェクトの可変セットを作成します。

先に説明したように、必須ダウンロードはアプリのインストールまたはアプリのアップデート中にのみサポートされています。

次に、リモートのすべてのセッションのマニフェストを反復します。これは、この文脈では、それらがダウンロードされていないことを意味します。

その後、スケジュールする必要があるダウンロードごとにBAURLDownloadオブジェクトが作成されます。

ダウンロードには、一意の識別子、URLRequest、ダウンロードを必須としてフェッチする必要があるかどうかの注釈、そのファイルサイズ、アセットがダウンロードされるアプリグループ、およびスケジューラが最初に開始するダウンロードを制御する相対的な優先順位が与えられます。

覚えておくべき重要なことの1つは、必須としてマークされたダウンロードには正確なファイルサイズがなければならないということです。そうしないと、ダウンロードは失敗としてマークされます。

これは、iOSのホーム画面、macOS Launchpad、App Storeでのスムーズな進行をサポートするためです。

ダウンロードのキューイングをサポートしたので、成功したダウンロードの処理を見てみましょう。

アプリが実行されていない場合、またはアプリにBADownloadManagerにデリゲートが割り当てられていない場合、拡張機能はダウンロードを処理します。

ダウンロード完了ハンドラで最初に実装することは、非同期に排他的な制御を取得することです。

排他的な制御の取得は非同期であるため、拡張子が私たちに販売した一時ファイルにしがみつく必要があります。

ご覧のとおり、私はこの関数の範囲よりも長生きする一時的な場所にファイルを移動することで、これを達成しています。

また、拡張機能がダウンロードする一時的なファイルが常にクリーンアップされるように、Swift deferを追加します。

システムはファイルを削除しますが、自分で管理するのがベストプラクティスです。

次に、アプリグループからマニフェストをロードし、その有効性を確認します。

その後、拡張機能は、処理されているダウンロードされた識別子がマニフェストで期待されるセッションと一致していることを確認します。

その後、拡張子はそのファイルを一時的な場所からアプリグループ内の最終目的地に移動します。

その後、LocalSessionは、セッションが適切な場所にダウンロードされたことをすばやく検証するために構築されます。

最後に処理するのは、ダウンロードの失敗です。

一般的に忘れられている重要なことは、BAManifestURLがダウンロードに失敗した場合、拡張機能が実際にそれについて通知されることです。

そのタイプはBAURLDownloadを継承しています。

しかし、それは正確な内部タイプではありません。

したがって、拡張機能は、BAURLDownloadオブジェクトのみを扱うようにフィルタリングします。

重要な資産はフォアグラウンドでダウンロードされるため、これらのダウンロードはアプリのインストールの進行状況に影響を与えるため、ネットワーク接続を数秒待つだけです。

したがって、失敗した場合は、必須のダウンロードを必須ではないものとして再エンキューに入れることをお勧めします。

必須ダウンロードを簡単に非必須に変換できる方法の1つは、新しいremoverEssential（）関数を使用することです。

その関数は不要なコピーを返します。

次に、そのコピーをBADownloadManagerのscheduleDownload機能に配布します。

その後、システムは適切なタイミングでダウンロードを取得します。

私たちのアプリとその拡張機能は完全にバックグラウンドアセットを採用したので、特定のセッションが必須としてダウンロードされたことを示すUIを追加しましょう。

重要なのは、アプリのインストールとアプリのアップデートが、アセットが完全にダウンロードされるまでアプリの起動を禁止することを意味することを忘れないでください。

ただし、起動がブロックされているアプリは、App StoreまたはTestFlightからのインストール中にのみ発生するため、インジケーターが存在することは、これを目に見えて認識する良い方法です。

このインジケーターは、VideoSelectorビュー内のSwiftUIに実装されます。

セッションがマニフェストで必須としてマークされている場合、ナビゲーションビューに緑色の円が描画されます。

そして、それがすべてです。

バックグラウンドアセットの実装がいかに簡単かがわかったので、拡張機能のデバッグとそのエントリポイントのシミュレーションを見てみましょう。

先に説明したように、拡張機能はアプリのインストール中、アプリのアップデート中、または定期的にバックグラウンドで起動します。

アプリのインストールはApp Storeによって制御され、定期的なイベントはデバイスによって制御されるため、デバッグするために拡張機能を強制的に起動する方法が必要になります。

幸いなことに、私たちのチームはXcodeに同梱されているツールを作成しました。これは、拡張機能を起動し、そのエントリポイントをシミュレートするために使用できます。

このツールはターミナルからアクセスでき、xcrun backgroundassets-debugと入力することで起動できます。

ヘルプ情報とそれに付随するマニュアルページもあります。

backgroundassets-debugを使用する場合は、さまざまな種類のBAContentRequestsをトリガーする機能を提供するシミュレーション引数を渡します。

これらのシミュレーションメッセージのいずれかがデバイスに送信されると、拡張機能のランタイムがリセットされ、デバッグが容易になります。

Backgroundassets-debugは、複数のデバイスのサポートなど、多数の機能を提供します。

デバイスがMacとペアリングされている限り、拡張機能をシミュレートするために使用できます。

これらのコマンドは、デバイスをUSB経由でMacにテザリングする必要がないように、BluetoothまたはWi-Fi経由で送信できます。

最後に、デバイスがbackgroundassets-debugによってトリガーされたシミュレーションイベントを尊重するには、開発者モードをオンにする必要があります。

これは、デバイスの設定アプリ内のプライバシーとセキュリティセクションから簡単に有効にすることができます。

それでは、先ほど構築したデモアプリでbackgroundassets-debugツールを使用することを見てみましょう。

私たちはターミナルにいます。

XcodeはこのMacにインストールされているので、先に進んで接続されたデバイスをリストアップします。

現在、接続されているデバイスが1つしかなく、それはたまたま私のiPhoneであることがわかります。

シミュレートすることを選択したデバイスのUUIDをコピーしたいと思うでしょう。

提供された引数では、デバイスのUUIDがアプリのバンドル識別子とともに存在していることがわかります。

App-install引数と混在したシミュレーション引数を使用してツールを呼び出します。

これにより、アプリ拡張機能は、最初のアプリインストールイベント中に起動されているかのように起動します。

Enterキーを押したので、ツールはアプリのインストールイベントがデバイスに送信されたことを通知します。

アプリを起動して、それがどのように見えるか見てみましょう。

ご覧のとおり、すべてのセッションビデオはダウンロードのためにキューにされています。

私が話しているように、それらのいくつかはすでにダウンロードを終えています。

そして、それは行動中のバックグラウンド資産です。

あなたが私のような人なら、あなたはおそらくすでにあなたのアプリでの待ち時間を減らすための多くの潜在的な方法について考え始めているでしょう。

アプリ拡張機能をデバッグする方法をお見せしたので、覚えておくべき重要なことをいくつか見てみましょう。

エッセンシャルアセットはアプリでダウンロードし、アプリのインストールの進行に貢献します。

したがって、これらのタイプのアセットは、拡張機能内のBAContentRequestインストールまたは更新イベント中にのみスケジュール可能です。

拡張機能によってキューにされた必須ダウンロードが失敗した場合、アプリは最終的に起動可能になります。

これらの資産が必要な場合は、拡張機能内または最初のアプリの起動時に、必須ダウンロードを必須ではないものとして再キューに入れる必要があります。

必須としてマークされていないダウンロードは、アプリがインストールまたは更新された後にダウンロードされ、バックグラウンドダウンロードの優先順位を受け取ります。

また、拡張機能はメモリ使用量によって制限されていることを覚えておくことも重要です。

したがって、拡張機能をデバッグして、書き込むコードがメモリのしきい値をはるかに下回っていることを確認してください。

拡張機能が過剰なメモリを使用している場合、デバッグ中にメモリ例外でクラッシュすることに気づくでしょう。

アプリのインストールまたはアプリの更新コンテンツリクエスト中に拡張機能がクラッシュした場合、アプリはすぐに起動可能になります。

そして最後に、ダウンロードしたアセットを適切に管理することで、アプリを善良な市民にすることを忘れないでください。

これらの資産を管理する1つの方法は、アプリのキャッシュディレクトリに配置することです。

だから、それが私たちがバックグラウンドアセットのために今年持っているものです。

このセッションから取り除くべきものがあれば、それはあなたのアプリでの待ち時間を排除することです。

待ち時間を排除する1つの方法は、バックグラウンドアセットを採用し、新しい必須アセット機能を使用することです。

アプリをApp Storeに提出する前に、必ずTestFlightを利用してください。

TestFlightを使用すると、重要なアセットがアプリでダウンロードされたときにどのように見えるかを確認できます。

ご質問がある場合は、開発者ドキュメントをチェックして、Apple Developer Forumsにお気軽にお問い合わせください。

また、フィードバックアシスタントを利用することをお勧めします。

私たちのチームはバックグラウンドアセットを常に改善しており、あなたがそれをアプリに採用することを楽しみにしています。

ああ、まだしていない場合は、バックグラウンドアセットが導入された以前のセッションをチェックすることをお勧めします。

そこにはたくさんの追加情報があります。

そして、今日は参加してくれてありがとう。

アップルのみんなを代表して、見てくれてありがとう。