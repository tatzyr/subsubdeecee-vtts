10180

♪ ♪

Siraj:みなさん、こんにちは。

私の名前はSirajで、CoreLocationのエンジニアです。

「Discover Streamlined Location Updates」に参加していただきありがとうございます。ここでは、場所を取得するための新しいCoreLocation APIについて話します。

始めましょう。

位置情報の更新を取得するのは、この1行のコードを書くのと同じくらい簡単です。

なんてかっこいい！そうじゃないの？

これは私たちの新しいSwiftネイティブAPIで、場所の更新を取得するための最新の迅速な並行性をすぐにサポートしています。

では、深く掘り下げてみましょう。

新しいCLLocationUpdate APIの構造を詳しく説明し、このAPIを使用して位置情報の更新を取得する方法について説明します。

次に、バックグラウンドで位置情報の更新を取得するために何をする必要があるかを調べます。

続いて、更新を自動的に一時停止して再開する方法が続きます。

最後に、このAPIを通じて更新されるアプリのライフサイクルを説明して締めくくります。

CLocationUpdate APIの構造を探りましょう。

Updatesと呼ばれるAsyncSequenceを返す静的関数liveUpdatesを持つ新しいクラスCLLocationUpdateを導入しています。

for/try/awaitを使用して直接反復して、CLLocationUpdateタイプの要素を生成し、CLLocationタイプの場所と、自動、一時停止、再開を管理するためのブールフラグisStationaryを生成します。

liveUpdatesは、LiveConfiguration列挙型の選択的な引数も消費します。

では、コードのウォークスルーを行い、この新しいAPIを使用して更新を取得する方法を見てみましょう。

フォアグラウンドから位置情報の更新を開始する基本的なアプリを構築しましょう。

最初にCoreLocationをインポートします。

次に、CLLocationUpdateクラスによって提供される静的ファクトリ関数liveUpdatesを呼び出して、Updates AsyncSequenceを取得します。

これは、for/try/awaitを使用して直接反復して、クロージャでCLLocationUpdateを取得できます。

そして、その場所のプロパティにアクセスして場所を取得します。

さて、この時点で私たちのアップデートが始まりました。

私たちがそれを止めなければならない場合はどうですか?

停止は、forループから壊れるのと同じくらい簡単です。

isStationaryを覚えていますか？

このisStationaryがtrueであると報告されたら、forループから抜け出し、自動的に更新を停止しましょう。

明示的な開始メッセージと停止メッセージはもう必要ありません。

CLLocationUpdate APIによって返されたAsyncSequenceを見てみましょう。

要素の検索、選択、除外など、AsyncSequenceでできるすべての強力なことも、この更新シーケンスで実行できます。

この例では、AsyncSequenceで最初のフィルターを直接使用する方法を説明します。

ボンネットの下で更新が開始され、各要素の位置が速度がチェックされます。

速度が200を超えるアップデートが見つかるとすぐに、その最初の要素が返され、操作が完了します。

最初のマッチが見つかると、更新は自動的に停止します。

しかし、あなたはここでのスピードに気づきましたか?

これは毎秒200メートルなので、およそ時速約447マイルです。

それは速すぎますよね?

したがって、一致が見つかるまで実行がスタックするため、これらのフィルターを使用する際には注意する必要があります。また、水平精度に基づいて場所をフィルタリングするためにこれを使用しようとする場合は、さらに注意する必要があります。

さて、これは、liveUpdatesの設定を指定していない更新を取得するための前のスライドのサンプルコードです。

したがって、それらはデフォルトの設定で自動的に設定されます。

しかし、liveUpdates APIは明示的な設定を取ることができます。

この設定は、このAPIの一部として導入する新しい列挙型です。

この列挙型のメンバーとその用途を見てみましょう。 

LiveConfiguration列挙型は、アプリが更新を開始するために選択できる、事前に焼かれた設定のコレクションです。

デフォルト、automotiveNavigation、otherNavigation、fitness、airborneをメンバーとしています。

アプリがすでに既存のロケーション更新APIで特定のCLActivityTypeを使用している場合は、新しいAPIを採用しながら、同じロケーションエクスペリエンスを持つ対応するLiveConfigurationメンバーを選択できます。

しかし、特定のアクティビティタイプが必要ない場合は、デフォルトの設定で更新を開始するか、設定をまったく指定しないでください。

では、この「更新」AsyncSequenceは何をもたらしますか?

反復すると、CLLocationUpdateタイプのオブジェクトが表示されます。

CLLocationタイプのオプションの場所が含まれています。

利用可能な場所がない場合は、場所がnilとしてマークされたアップデートを配信します。

また、位置更新の自動一時停止/再開を管理するブールプロパティisStationaryも含まれています。

さて、フォアグラウンドからアップデートを取得する方法を取り上げました。

では、アプリがバックグラウンドで実行されているときにアップデートを取得する方法について話しましょう。

LiveActivityは、バックグラウンドの場所の更新を有効にするための最良の方法です。

LiveActivityがアクティブなままである限り、アプリは他の追加設定なしでアップデートを受け取ることができます。

しかし、あなたのアプリにまだLiveActivityがなくても心配しないでください。

これは、新しいAPIを採用するためのブロッカーにはなりません。

代わりに、CLBackgroundActivitySessionを使用できます。

それがどのように機能するかを探りましょう。

あなた方の多くは、使用中に許可されたアプリがバックグラウンドで更新を取得するときに表示されるこの青い背景位置インジケータにすでに精通しているかもしれません。

CLBackgroundActivitySessionは同じインジケーターを使用して、アプリにバックグラウンド位置情報機能を提供します。

これは、バックグラウンドで使用されている位置情報サービスに関するユーザーの可視性を維持することによって行います。

また、可視性が維持されているため、アプリを効果的に使用できるため、バックグラウンドからでも場所にアクセスできます。

CLBackgroundActivitySessionは、アプリ全体の承認をサポートしています。

そのため、アプリはバックグラウンドで更新を受信するだけでなく、CLMonitorを使用してイベントを監視することもできます。

BackgroundActivitySessionは、更新の開始に依存しません。

セッションを作成するだけで、アプリがバックグラウンドにあるときにインジケーターが表示され、必要に応じてアップデートやイベントを受け取ることができます。

CLBackgroundActivitySessionを使用するには、インスタンス化して保持する必要があります。

オブジェクトの割り当て解除により、アプリのバックグラウンドロケーションへのアクセスが終了する可能性のあるセッションが自動的に無効になるため、保留部分には注意してください。

BackgroundActivitySessionを効果的に機能させるには、アプリがUIBackgroundModes配列に位置情報を持つ必要があります。

未処理のセッションがない場合は、フォアグラウンドから新しいセッションを開始する必要がありますが、バックグラウンドから既存のセッションに再参加できます。

簡単なコードウォークスルーを行い、backgroundActivitySessionの使い方を見てみましょう。

これは、前のセクションと同じ「アップデートの入手方法」のコードスライドです。

更新を開始する前に、CLBackgroundActivitySessionオブジェクトをインスタンス化して、新しいセッションを開始する必要があります。

セッションをself.backgroundActivityに割り当てていることに注意してください。self.backgroundActivityはプロパティであり、ローカル変数ではありません。

そして、ローカル変数を使用した場合、それがスコープ外になると、それが保持するオブジェクトが割り当て解除され、セッションが無効になり、アプリの場所へのアクセスが終了する可能性があるため、これは重要です。

次に、セッションを終了したい場合は、無効なメッセージを送信するか、オブジェクトを破棄することで行うことができます。

そのため、アプリはLiveActivityまたはCLBackgroundActivitySessionを通じて、バックグラウンドでアップデートを取得できます。

それでは、この新しいAPIが自動的に更新を一時停止して再開することで、バッテリー寿命にどのように貢献するかを見てみましょう。

ユーザーが移動している間、アプリがアップデートを受信していると仮定しましょう。

しかし、1日に複数回、デバイスは静止します。

たとえば、ユーザーがオフィスに到着すると、デバイスを机の上に置いておくことがあります。

このような状況では、私たちはあなたのアプリに同じ場所を何度も与えるでしょう。

代わりに、更新を一時停止することで、ここで電力効率を高めることができます。

これは、処理する冗長な場所を与えないことで、アプリもロードします。

したがって、デバイスが十分な時間静止状態になると、CLLocationUpdate APIはこれを認識し、自動一時停止をトリガーします。

一時停止がトリガーされると、nil以外の場所とtrueとしてマークされたisStationaryフラグで更新を送信します。

これは、ユーザーが場所が利用できなくなるのではなく、移動をやめたことを知る方法です。

その後、デバイスが非静止状態になると、ユーザーの操作なしで更新が自動的に再開されます。

この再開アップデートでは、FalseとマークされたisStationaryを送信し、アプリへのアップデートの配信を継続します。

したがって、アプリがバックグラウンドにある間に自動的に更新を一時停止して再開することは、そのライフサイクルに影響を与えます。

バックグラウンドで実行中にアプリが受けるさまざまなライフサイクルフェーズと、バックグラウンド更新の継続性を維持するためにどのようなアクションを取る必要があるかを見てみましょう。

フォアグラウンドで実行し、更新を受信している間のアプリは、フォアグラウンド実行からバックグラウンド実行に移行し、その逆も同様です。

しかし、この新しいAPIでは、アプリがバックグラウンド実行状態から一時停止状態に移行する場合があります。

これは、配信する更新がない場合に発生する可能性があります。

たとえば、自動一時停止のため、静止したデバイスのため、または位置情報サービスが位置情報の修正を計算できないためです。

でも、心配しないで！

CLLocationUpdateは、アプリを一時停止状態のままにするつもりはありません。

代わりに、自動履歴書が開始されたか、場所が利用可能になったため、更新が利用可能になるとすぐに、アプリの一時停止を解除し、バックグラウンド実行状態に戻します。

アプリが一時停止状態から再開された場合、バックグラウンドで更新を継続するためのアクションは必要ありません。

一時停止は唯一の州ではありません。

アプリが終了状態に移行できる可能性があります。

そして、この移行はいくつかの方法で起こる可能性があります。

それらを通り抜けましょう。

まず、アプリのクラッシュ、またはリソースが制限されているときのユーザー終了またはシステム終了によるバックグラウンド実行から直接。

第二に、アプリは、ユーザークローズまたはリソースの制約により、一時停止状態からでも終了状態に移行できます。

しかし、私たちはあなたに良いニュースがあります。

当社のAPIは、ほとんどの場合、終了してまったく実行されていない場合でも、アプリを回復できます。

バックグラウンドで起動することで、位置情報の更新が利用可能になり次第、アプリを回復します。これにより、アプリが終了からバックグラウンド実行に移行しますが、起動後、バックグラウンド位置情報セッションを継続できるように、いくつかの手順を実行する必要があります。

liveUpdatesを呼び出して更新を再開する必要があり、アプリが以前にバックグラウンドアクティビティセッションを使用していた場合は、CLBackgroundActivitySessionを再作成する必要があります。

私が言ったことを覚えておいてください、あなたはバックグラウンドから既存のCLBackgroundActivitySessionに再参加することができますが、新しいものを始めることはできませんか?

それについてもう少し説明があります。

再作成したばかりのバックグラウンドアクティビティセッションオブジェクト?

それは新しいセッションの始まりではありません。

新しいセッションオブジェクトを作成したばかりです。

さて、アプリは終了する前にすでにセッションを開始しているため、このレクリエーションにより、アプリはバックグラウンドから既存のセッションに再参加することができ、アプリはバックグラウンド位置情報の更新を継続できます。

さて、バックグラウンドアプリの起動を受信した後、ライブアップデートとバックグラウンドアクティビティセッションをどのように再作成するかについて話し合いました。

レクリエーションに関連して、注意すべきことはほとんどありません。

アプリは、バックグラウンドアプリの起動を受信するとすぐにレクリエーションを実行する必要があります。

これらのオブジェクトのレクリエーションは、アプリがバックグラウンド起動を受信したときに実行される場所に配置します。

サンプルアプリの場合、アプリの起動が完了すると呼び出されるUIApplicationDelegateのdidFinishLaunchingWithOptionsにレクリエーションを配置しました。

わかった！

これは、採用が簡素化され、バッテリー性能が向上した新しいロケーションアップデートAPIです。

今年からすべてのプラットフォームで利用可能になります。

アプリでCLLocationUpdateを試して、フィードバックアシスタントを通じて貴重なフィードバックを提供することを強くお勧めします。

また、この新しいAPIの使用方法を紹介するサンプルアプリもあり、リソースセクションからダウンロードできます。

CLLocationUpdateのApple Developerドキュメントは、APIの詳細も入手できます。

また、今年追加するCore Location Monitoring APIをカバーする「Meet Core Location Monitor」セッションを見ることをお勧めします。

それは「合理化された場所の更新を発見する」に関する私の側からのすべてです。

見てくれてありがとう!

♪ ♪