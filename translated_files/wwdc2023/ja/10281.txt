10281

♪ ♪

スペンサー:みなさん、こんにちは。

私の名前はスペンサー・ルーソンです。

今日は、ここ数年でキーボードがどのように変化したか、そして「キーボードに合わせる」ようにアプリをデザインする方法についてお話ししたいと思います。

ご存知のように、iPhoneのキーボードはもともと2007年に導入され、それ以来大幅に進化してきました。

現在、多くの異なる言語をサポートしており、それぞれがレイアウトのサイズが異なる場合があります。

そしてもちろん、キーボードは多くの異なるデバイスにも搭載されています。

しかし、キーボードがどのように進化したかと同じように、システムはマルチタスクやフローティングキーボードなどのエキサイティングな機能を追加し、キーボードがアプリの境界を超越できるようにしました。

昨年、iPadでまったく新しいレベルの生産性を解き放つStage Managerを導入しました。

複数のシーンが複数のディスプレイで実行されるようになったため、ハードウェアキーボードとマウスの使用はこれまで以上に魅力的になりました。

だからこそ、今日は、キーボードの再構築でこの多種多様なキーボードシナリオを可能にする方法と、それがアプリにどのように影響するかについてお話ししたいと思います。

また、できるだけ少ない労力で、可能な限りキーボードとシームレスに動作するようにアプリを設計するためのヒントやコツを共有したいと思います。

そして最後に、テキスト入力の世界でいくつかのエキサイティングな新機能を紹介したいと思います。

では、新しいアウトオブプロセスキーボードについて話しましょう。

アプリのプロセスからキーボードを取り外すと、セキュリティを向上させ、ユーザーが入力したもののプライバシーを確保することができます。

また、複数のアプリで実行されている複数のインスタンスではなく、キーボードが1つしかないため、アプリやシステム全体のメモリを解放します。

そして、この新しいアーキテクチャにより、将来に向けて設計し、エキサイティングな新機能を実装することができます。

それでは、それがどのように機能するかについて少し話しましょう。

iOS 17以前は、キーボードのビューとロジックはアプリプロセス内で実行されていました。

しかし、iOS 17のiPhoneでは、キーボードは独自のプロセスに移行され、アプリの外でほぼ完全に実行されています。

これらすべてがどのように機能するかをお見せできることに興奮していますが、まず、違いがわかるように、その過程でどのように機能するかについて話しましょう。

処理中、アプリは、タッチに応答してbeonFirstResponderを呼び出すなど、最初にキーボードを要求し、これはすべてのビューを初期化するための一連の同期作業を開始します。

それが完了すると、システムはキーボードを呼び出すためにアニメーションを実行します。

その後、アプリはアイドル状態になるか、タッチイベントが入り、テキスト挿入が生成されるまで、アプリサイドワークを実行します。

プロセス外では、これは少し違った方法で機能するようになりました。

アプリがキーボードを要求すると、beonFirstResponderを呼び出すなど、アプリはいくつかの初期計算を実行し、キーボードプロセスはUIを非同期に初期化します。

その間、アプリはアイドル状態になるか、アプリのサイドワークを実行します。

準備ができたら、キーボードを上げて、2つのプロセス間でアニメーションを調整します。

キーボードUIが起動したので、キーボードの範囲内で発生するタッチイベントを待ち、アプリのテキスト挿入に変換します。

ほとんどのアプリでは、これらの変更は完全に透明であり、あなたからの採用を必要としません。

しかし、この新しい非同期アプローチの側面は現在、キーボード全体に存在し、タイミングにわずかな違いをもたらす可能性があります。

したがって、アプリがテキスト入力、選択の変更、またはその他のテキスト関連の操作のタイミングに特に敏感な場合は、この新しいアーキテクチャを念頭に置いておく必要があります。

iOSでのタイピングの多様性について少しお話ししたので、アプリを設計する際に考慮すべき比較的新しいシナリオについて話しましょう。

もちろん、私たちは皆、最も一般的なユースケースに精通しています。キーボード付きのフルスクリーンアプリです。

これは、アプリとキーボードの両方がフルスクリーンである比較的簡単なユースケースであり、キーボードの調整は、たまたまキーボードの高さである値でビューを上に移動するのと同じくらい簡単です。

しかし、ステージマネージャーでは、システムはそのモデルから遠ざかっています。

高度なマルチタスクでは、アプリは必ずしもフルスクリーンであるとは限りません。

つまり、キーボードが起動すると、アプリのビューを正しく調整するために特別な注意を払う必要があります。

それは、キーボードのシーンとアプリのシーンが並ばなくなったからです。

そして、そのコンテキストに合わせてアプリを適切に調整するために、いくつかの追加の変換を行う必要があります。

たとえば、このシナリオでは、アプリの調整は実際にはYではなく、キーボードの高さであり、キーボードとアプリの交差によって調整する必要があります。

そして今、画面上に複数のシーンがあり、それぞれが異なる計算と調整が必要なため、計算するための単一の調整さえないかもしれません。

ハードウェアキーボードで最近導入されたシナリオもあります。

ハードウェアキーボードが接続されると、システムは画面の中央にアシスタントツールバーを表示します。

このフルサイズのツールバーが存在する場合、キーボードの一部として機能するため、ビューを邪魔にならないように調整する必要があります。

フリックジェスチャーを使用すると、このツールバーを最小化することもできます。

ステージマネージャーの外では、このミニツールバーがキーボードの一部として機能せず、ビューと重なる既存の動作を保持しています。

ユーザーは、ツールバーを画面の反対側にドラッグすることで、下のコンテンツにアクセスできます。

ただし、ステージマネージャーでは、ミニツールバーがキーボードの一部として機能し、ユースケースに応じて、スクロールオフセットを更新したり、入力アクセサリビューを押し上げたり、必要に応じて他のレイアウト調整を行うことができます。

さて、私たちはここで説明すべき多くのシナリオとニュアンスがあることを知っていますが、良いニュースは、適切なAPIがあれば、システムがあなたのためにほとんどの仕事をするということです。

では、キーボードレイアウトガイドについて話しましょう。

iOS 15で導入されたキーボードレイアウトガイドに精通しているかもしれません。

キーボードを自動的に調整する簡単な自動レイアウトガイドを提供し、昨年追加してきました。

実際、現在、SpotlightやMessagesなどの複雑なAppleアプリで使用されています。

採用は、ビューとガイドの間に制約を追加するために1行と同じくらい簡単にできるため、推奨されるアプローチです。

さて、これがあなたに何を得るかについて正確に話しましょう。

既存のデフォルトの動作は次のとおりです。キーボードレイアウトガイドは、キーボードが画面に表示され、ドッキングされたときにキーボードに従います。

つまり、キーボードが画面の下部に触れているときです。

iPadに浮かんでいるときなど、キーボードがドッキングされていない場合、ガイドの高さはビューの下部の安全な領域と一致します。

最後に、ガイドは、タッチポイントがガイドと交差すると、キーボードの閉じるジェスチャーを追跡します。

あなたが望む正確な動作を得るためにこれらを変更できるように、iOS 17のカスタマイズオプションを拡張したことをお伝えできることを嬉しく思います。

現在、UIKeyboardLayoutGuideには3つのプロパティがあります。

まず、UndockedKeyboardに従います。

デフォルトでは、ガイドはフローティングキーボードまたはミニツールバーをオフスクリーンキーボードと同じように扱います。

ただし、trueに設定すると、ガイドは、アプリのウィンドウ上にある限り、フローティングされていてもキーボードをたどり続けます。

次はuseBottomSafeエリアです。

デフォルトでは、キーボードレイアウトガイドは、キーボードが却下されたときに安全な領域の高さを追跡します。

しかし、falseに設定すると、useBottomSafeAreaは代わりにビューの下部を追跡します。この場合は画面の下部です。

これはいつ役に立ちますか?

さて、これにより、キーボードが却下されたときに画面の下部を覆うように背景を拡張し、キーボードが取り上げられたときに調整することができ、InputAccessoryViewと同様に動作します。

そして実際、それはこのプロパティにとって本当に興味深いユースケースなので、それがどのように機能するかについて話しましょう。

これは、下部の安全な領域の上にとどまるテキストフィールドと、キーボードが却下されたときにのみビューの下部まで伸びる背景を持つ、そのシンプルな入力アクセサリーのようなビューを取得するコードです。

注：この場合は興味深いものなので、ここでは垂直方向の制約のみを扱います。

まず、usesBottomSafeAreaをfalseに設定しましょう。

次に、テキストフィールドの上部を背景の上部に結び付け、2つの間のシステム間隔を使用して、少しパディングを与えましょう。

次に、少なくともシステム間隔で、ガイドの上部をテキストフィールドの下部に制限することで、テキストフィールドが常にキーボードの上にあることを確認してください。

より大きいことがここで重要です。

キーボードが画面外にある場合、テキストフィールドは、下部の安全な領域のインセットの上にとどまるのに十分な柔軟性が必要になります。

また、ガイドの上部アンカーを背景の下部に結び付けましょう。

これにより、ガイドがオフスクリーンのときに背景が下まで続くことが保証されますが、useBottomSafeAreaをfalseに設定したためです。

最後に、下部のセーフ領域をテキストフィールドの下部とシステム間隔に制限します。

そして再び、私たちはここで制約よりも大きなものを使用して、キーボードが出てきたときにキーボードに従うのに十分な柔軟性があることを確認しています。

そして、それに伴い、ビューの一番下まで伸びる背景を持つアダプティブビューがありますが、入力アクセサリビューのように、キーボードの上にテキストフィールドシステムの間隔を保ち、キーボードの上部の背景を保つように調整します。

第三に、キーボードディスミスパディングがあります。

これにより、スクロールのパラメータが調整されます。

過去にキーボードレイアウトガイドを使用してInputAccessoryのようなビューを作成しようとしたことがあるなら、タッチがキーボードと交差するまでキーボードの閉じるジェスチャーが始まらないことに気づいたかもしれません。

この新しいプロパティを使ってそれを修正しましょう。

keyboardDismissPaddingプロパティを使用すると、キーボードの閉じるジェスチャーに応答するキーボードの上にあるパディングを指定できます。

これは比較的簡単です。

あなたが望むようにあなたのビューの高さをつかみ、プロパティを設定するだけです。

完了。

これで、タッチがビューと交差すると、キーボードの却下ジェスチャーが始まります。

もちろん、アプリが構築されているフレームワークはUIKitだけではありません。

SwiftUIもあります。

幸いなことに、SwiftUIは一般的なケースを自動的に処理します。

SwiftUIでは、キーボードはセーフエリアの一部として含まれており、キーボードが却下されると、画面の下部にある小さなホームアフォーダンスを追跡します。

キーボードが起動すると、システムは安全領域をアニメーション化して調整し、ビューのサイズを自動的に変更するので、書くキーボードコードはまったくありません。

ただし、ビューが必要に応じてサイズ変更または再配置されていることを確認するために、レイアウトの作業を行う必要があるかもしれません。

SwiftUIには、私がリストアップできる以上の素晴らしいリソースがたくさんあるので、これについてもっと知るには、以下にリンクされているドキュメントをご覧ください。

さて、キーボード、キーボード通知を統合するより手動的な方法について話しましょう。

SwiftUIとキーボードレイアウトガイドの前に、キーボードをアプリケーションに統合する唯一の方法は、一連のキーボード通知（willShow、didShow、willHide、didHide）をリッスンし、通知のフレームとアニメーション情報に基づいてレイアウトを手動で調整することでした。

これらはまだありますが、システムがあなたのために仕事をしていないので、より慎重な取り扱いが必要です。

そして、ステージマネージャーの導入により、そのハンドリングが100%機能しなくなったため、一般的に使用されるパターンの増加に気付きました。

このパターンは通常、キーボード通知を受信し、キーボードの高さから生の値を直接使用することに重点を置いています。

先ほど、キーボードの高さと画面上のアプリの位置がどのように相互作用するかのニュアンスについて話し合っていたときのことを覚えていますか?

これが通知でどのように機能するかについて話し合いましょう。

各通知は、画面座標に対するキーボードの予想されるフレームを指定します。

アプリがフルスクリーンの場合など、画面の座標空間とアプリの座標空間が一致する場合、通知に含まれる生の高さの値は、たまたまビューが期待どおりに調整されます。

ただし、画面の座標空間とアプリの座標空間が異なる場合、この生の高さ値はビューを調整するための正しい値ではなくなります。

これにより、あなたのビューがあまりにも高く押され、間違った場所に表示される可能性があります。

幸いなことに、物事を再びスムーズに機能させるために、通知処理にいくつかの変更を加えることができます。

iOS 16.1では、キーボード通知は対応するUIScreenを通知のオブジェクトとして含め始めました。

まず、キーボードがアプリと同じ画面に表示されていることを確認しましょう。そうしないと、調整は必要ありません。

次に、ビューに対するキーボードの配置を表すrectを計算しましょう。

これを行うには、キーボードの期待されるエンドフレーム、通知とビューによって提供される座標空間を取得し、それらを使用してkeyboardFrameEndを座標空間に変換します。

この新しいrectを使用すると、ビューと変換されたKeyboardFrameEndの交差を計算することで、ビューに必要なオフセットを決定できます。

ビューとキーボードが重なっている場合、必要なオフセットは、ビューとキーボードの間の交差の高さになります。

それにより、制約やレイアウトを好きなように調整できます。

さて、新しいプロセスアーキテクチャでは、知っておくべき通知の動作に小さな変化があるかもしれません。

では、少し時間を取ってそれについて話しましょう。

キーボードプロセスのライフサイクルを概説したこの図を覚えていますか?

「アニメーションを育成する」と呼ばれるアニメーションフェーズにズームインしましょう。

インプロセスアーキテクチャでは、アプリがキーボードを要求すると、システムはキーボードUIを同期的に初期化し、通知を投稿し、アニメーションを実行します。

ただし、新しいプロセス外アーキテクチャでは、アプリがキーボードを要求すると、システムはキーボードUIを非同期に初期化し、非同期に通知を投稿してアニメーションを実行します。

これにより、タイミングにわずかな違いがあるため、アプリがbeonFirstResponderを呼び出すことからある種の「コールバック」として通知のタイミングに依存している場合、または通知の処理が遅れる可能性のあるメインスレッドで重要な作業を行っている場合は、アプリに影響を与える可能性があるため、この新しいモデルを念頭に置いておく必要があります。

ユーザーがアプリにできるだけ簡単に入力できるように、これらすべてのヒントとコツを確認したので、テキスト入力をさらに高速化する新機能とAPIを導入することに興奮しています。

そして、それはインライン予測です。

iOS 17では、英語のキーボードがテキストフィールドとインラインで次の数語の予測を提供するようになりました。

これらの予測はデバイス上で安全に生成され、フォーカスされたテキストフィールドで提供されるコンテキスト情報のみを使用します。

これらの予測を採用するのも本当に簡単です。

ここにはUITextInputTraitsプロトコルがあり、ご覧のとおり、新しいinlinePredictionTypeプロパティが追加され、いくつかのオプションが付属しています。

デフォルトでは、インライン予測はほとんどのテキスト入力フィールドでアクティブになりますが、検索フィールドやパスワードフィールドなど、予測が適切ではないフィールドでは自動的に無効になります。

もちろん、プロパティを「はい」または「いいえ」に明示的に設定することで、アプリの動作をカスタマイズすることもできます。

そして、それで、いくつかの重要なポイントを要約しましょう。

覚えておいてください: どのように表示されても、キーボードとシームレスに動作するようにアプリを設計してください。

時間に敏感なコードを書くときは、新しいプロセスキーボードモデルを念頭に置いてください。

そして、テキスト入力を加速するAPIを採用することで、アプリのエクスペリエンスを向上させます。

キーボードに追いついてくれてありがとう。

♪ ♪