10266

♪ ♪

ロバート：こんにちは、私の名前はロバート・ケンドール・クッペです。今日は、私たちが「環境制約」と呼んでいる新しいmacOS機能について話します。

機能豊富なMacアプリは、多くの場合、1つのプロセスやファイル以上のものです。

フレームワークとライブラリを使用すると、アプリ全体や他の開発者からコードを再利用することができます。

ヘルパーツール、ヘルパーアプリ、XPCサービスを使用すると、作業を分割して攻撃面を減らすことができます。

起動エージェント、起動デーモン、およびログイン項目を使用すると、バックグラウンドまたはユーザーログインで作業を行うことができます。

また、アプリの拡張機能を使用すると、他のアプリで便利な機能を提供できます。

しかし、あなたのアプリは潜在的に敵対的な環境で実行されます。

アプリアーキテクトは、ソフトウェアと一緒に実行されている、またはフレームワークを使用して、未知のソフトウェアの潜在的な影響を考慮する必要があります。

ヘルパーツールまたはXPCサービスの実行により、攻撃者はキーチェーンデータにアクセスできますか?

iCloudのデータやその他の特権はどうですか？

予期しないコードがプロセスに注入された場合、どうなりますか?

実際の親子関係と同様に、親プロセスは子供の行動に大きな影響を与えます。

macOSでは、posix_spawnのパワーは別のプロセスを与え、親は子供へのほぼすべての入力を制御する能力を与えます。

親プロセスは、子のシステムリソースへのアクセスを制限することもできます。

このレベルの制御により、子が予期しないコードをロードしたり、予期しない機能を実行したり、プロセスが攻撃に対してより脆弱になるような振る舞いをしたりする可能性があります。

しかし、親子関係を超えて、プロセスは生成するディスクレイアウトに信頼を置きます。

ディスク上のファイルを変更できる悪意のあるプロセスは、被害者プロセスに予期しないデータをフィードしたり、被害者プロセスからランタイム保護を削除したり、システム上で永続的な実行を取得したり、プロセスの権限を盗んだりできる可能性があります。

これらすべての脅威に直面して、macOSはアプリを保護するためのツールを提供します。

特に、アプリが侵害された場合の影響を制限するために、アプリサンドボックスを採用することができます。

また、強化されたランタイムとライブラリの検証を採用して、実行時にプロセスの整合性を保護することができます。

ゲートキーパーと公証は、顧客のシステムに既知の悪意のあるコードのない状態に保つのにも役立ちます。

前に述べた脅威について考えると、既存の保護は実行環境ではなく実行プロセスに焦点を当てていることに気づきました。

そのため、環境制約を導入しています。

環境の制約により、プロセスを実行できる状況と、プロセス内でコードを混在させる方法を新しいレベルで制御できます。

この講演の残りの部分では、環境制約がmacOSのセキュリティアーキテクチャにどのように適合するか、環境制約がどのように構成されているか、アプリに環境制約をどのように採用できるかについて説明します。

しばらく下がって、macOSのセキュリティスタックについて話しましょう。

デフォルトでは、macOSはこれらすべての技術を活用して、ブートチェーンを保護し、OSの整合性を確保し、特権分離を強制し、悪意のあるソフトウェアからユーザーを保護します。

macOS Venturaでは、オペレーティングシステムプロセス間の関係をよりよく保護するために、環境制約を使用し始めました。

彼らはOSにセキュリティの新しい次元を提供します。

macOS Sonomaでは、環境制約の使用を拡大し、アプリで使用できるように開放しました。

では、環境の制約とは何ですか?

基本的に、それらはコードが何であるかだけでなく、コードがどのように存在し、システム上で実行されることが期待されるかを記述する方法です。

macOSでは、さまざまな目的で環境制約を使用します。

たとえば、プロセスが信頼できるバンドルリソースを使用していることを確認するために、署名されたシステムボリュームからOSプロセスを実行する必要があります。

特権デーモンが予期しない引数やMachポートで実行されないようにするために、システムデーモンは保護されたlaunchd.plistに基づいてのみ実行する必要があります。

システムアプリの攻撃面を減らすために、アプリケーションとしてLaunch Servicesから実行する必要があり、バックグラウンドアイテムのユーザー承認に歯があることを確認するために、環境制約を使用して変更を検出します。

今、あなたは尋ねているかもしれません。「私のアプリは環境制約を採用する必要がありますか？」

環境の制約は完全にオプションですが、あらゆるアプリの攻撃面を減らすことができることを強調したいと思います。

この講演の後半で、より具体的なユースケースについて説明します。

ただし、アプリに複数のプロセスがある場合や、異なる開発者チームによって署名されたコードがロードされている場合、環境の制約が特に役立つ可能性があることに注意してください。

環境制約にはいくつかの種類があるので、まず起動制約について話しましょう。

起動制約は特定のバイナリに埋め込まれ、そのプロセスのプロパティ、その親になることができるプロセスのプロパティ、またはそれを担当できるプロセスのプロパティのいずれかを定義します。

これらのプロパティを「自己制約」、「親プロセス制約」、および「責任あるプロセス制約」と呼びます。

3つすべてをバイナリに適用するか、最も理にかなっているものを選ぶことができます。

必要なプロパティのいずれかが満たされない場合、起動制約が埋め込まれたプロセスは実行されません。

それでは、いくつかのプロセス関係を見て、起動制約を使用してそれらを保護する方法について話しましょう。

まず、MyDemo.appがあなたのアプリであると仮定します。

MyDemo.appで自己制約を設定して、Launch Servicesからアプリケーションとして起動するように要求できます。

アプリがXPCサービスへの接続を要求すると、launchdはXPCサービスを生成し、そのXPCサービスの親ですが、アプリはそのXPCサービスに「責任」があります。

MyXPCDemo.xpcに責任あるプロセス制約を設定して、MyDemo.appだけが責任を負うことを示すことができます。

アプリが後でNSTaskまたはposix_spawnを使用してヘルパーを起動する場合、それはそのヘルパーの親であり、その責任者です。

MyDemo.appのみが親になることを要求するように、MyFirstHelperで親プロセス制約を設定できます。

次に、最初のヘルパーが2番目のヘルパーをposix_spawnsする場合、最初のヘルパーは2番目のヘルパーの親ですが、アプリは2番目のヘルパーを担当します。

MySecondHelperの場合、MyFirstHelperによってのみ起動されることを要求する親プロセス制約を設定でき、MyDemo.appのみが責任を負うことを要求するように責任あるプロセス制約を設定できます。

起動エージェントと起動デーモンのlaunchd plistsで環境制約を指定することもできます。

SMAppService APIを使用してplistを登録すると、OSは制約を満たすプロセスのみがplistに代わって起動されることを強制します。

この機能は、アプリのバックグラウンドアクティビティに対するユーザーの承認に基づいて、悪意のあるコードが永続的な実行を得ないようにするのに役立ちます。

最後に、ライブラリの負荷制約を使用して、アドレス空間にロードできるコードを具体的に制御できます。

ライブラリの負荷制約の前に、ライブラリの検証を採用するか、採用しないかのどちらかです。

ライブラリの検証により、プロセスは、あなたが署名したコードまたはAppleによって署名されたコードをロードすることができます。

ライブラリの負荷制約を使用すると、任意のコードがプロセスにロードされるのを防ぎながら、ライブラリの検証が許可するよりも制限の少ないコードセットを記述できます。

ただし、Apple署名入りのコードをプロセスの読み込みから除外することはできず、独自のコードを許可するには1つ以上のプロパティを指定する必要があることに注意してください。

環境制約とは何か、どのように使用できるかがわかったので、それらがどのように定義されているかについて話し合いましょう。

環境制約は、コードが満たさなければならない一連の条件を記述します。

それらは、キーがコードについて真実でなければならない事実、または事実または述語間の必要な関係を示す演算子を表す辞書としてエンコードされています。

トップレベルでは、暗黙的に、各キーと値のペアの結果が一緒にANDされ、制約が満たされるかどうかが決定されます。

これらは辞書であるため、各キーは辞書レベルごとに1回しか表示されないことに注意してください。

あなたが使いたいかもしれないいくつかの事実を見てみましょう。

左側は関連する環境制約キーで、右側は共同設計コマンドから出力されます。

署名識別キーを使用すると、特定のコードに固有である文字列を指定できますが、そのコードのバージョン間で同じままです。

署名識別キーは、共同設計出力の識別子フィールドを参照します。

Cdhashキーを使用すると、許可するコードの一意のハッシュを指定でき、チーム識別キーを使用すると、特定の開発チームによって署名されたコードを指定できます。

事実はコードの特定の特性を示しますが、演算子を使用して、事実のセットを論理的に結合したり、事実の許容値のセットを定義したりできます。

ご想像のとおり、$と$or演算子を使用すると、決定後に論理的に結合される述語の辞書を指定できます。

$and-arrayと$or-array演算子は、複数の$または述語または複数の$と述語をANDしたい場合に、辞書のネストを制限するために存在します。

そして最後に、$in演算子を使用すると、事実を満たす値の配列を指定できます。

この制約の例を見てみましょう。 

左側には、制約のplist表現があります。

右側は、XMLの意味を示す疑似コードです。

Plistの最上位レベルには、$or-arrayという1つのキーがあります。

値は3つのタプルの配列です。

各タプルには、その演算子が適用される演算子と辞書が含まれているため、この制約により、チーム識別子によって署名されたすべてのコード、または2番目のチーム識別子によって署名されたライブラリB、または3番目のチーム識別子によって署名されたライブラリCが許可されます。

最初のタプルでは、単一の要素であるため、$or演算子を使用することもできます。

制約を定義できるようになったので、プロジェクトでそれらを採用する方法を見てみましょう。

この議論の目的のために、ローンチエージェント、ヘルパーツール、XPCサービスを含むフレームワーク、および別の開発チームによって署名されたライブラリを含むメインアプリを検討してください。

それでは、環境の制約が軽減できる潜在的な問題をいくつか考えてみましょう。

おそらく、キーチェーンデータへのアクセスやiCloudコンテナへのアクセスなど、ヘルパーツールに特権を割り当てた可能性があります。

ヘルパーツールはアプリによってのみ起動でき、他のものは起動できないようにすることをお勧めします。

ヘルパーツールに親プロセスの制約を設定することで、アプリのみがヘルパーツールを起動できるようにすることができます。

これを行うには、チーム識別子とメインアプリの署名識別子を必要とするコード要件plistファイルを作成します。

次に、「Launch Constraint Parent Process Plist」設定で、ヘルパーツールの署名設定に制約を追加します。

詳しく見てみましょう。 

ここには、私が言及したプロパティを含むXcodeのデモプロジェクトがあります。

MyDemo.appはメインアプリのターゲットであり、demohelperはヘルパーツールです。

アプリを起動しましょう。

このボタンを押すと、アプリはヘルパーツールを生成し、ヘルパーツールはいくつかの作業を行い、アプリに応答します。

ターミナルのdemohelperの署名を見てみましょう。

起動制約が設定されていないことが確認でき、demohelperを実行できます。

しかし、それを見てください。

--cloud引数でdemohelperを実行すると、demohelperはアプリのiCloudデータにアクセスできます。

私たちは、任意のプロセスがdemohelperを実行し、iCloudデータを変更できるようにしたくありません。

Xcodeに戻って、demohelperに親の制約を設定しましょう。

ここでは、メインアプリMyDemoを識別するための制約plistファイルがすでに入力されています。

署名設定に制約を追加しましょう。

では、アプリを再構築しましょう。

私たちは再びアプリを起動することができます...

そして、メインアプリはまだヘルパーを生成することができます。

しかし、ターミナルに戻ると...

デモヘルパーには起動の制約があることがわかります...

そして、それはもはやターミナルから実行することはできません。

打ち上げ制約違反のために打ち上げがブロックされると、制約に違反したことを示すクラッシュレポートが生成されます。

それでは、環境の制約が軽減できるいくつかの問題について話しましょう。

XPCサービスを使用して、異なるプロセス間で権限を分離することをお勧めします。

しかし、XPCサービスを構築すると、バンドルからこれらのサービスを抽出し、他のコードから呼び出すことができます。

XPCサービスに何らかの権限を割り当てている場合は、期待されるプロセスのみがその権限にアクセスできるようにする必要があります。

コードだけがそのXPCサービスにアクセスできるようにする1つの方法は、責任あるプロセス起動制約を設定することです。

ここでは、XPCサービスにアクセスできるはずのバンドル内の各プロセスの署名識別子のリストを使用して、チームによって署名されたコードを許可する起動制約plistを示します。

「Launch Constraint Responsible Process Plist」設定で、署名設定に制約を追加できます。

考慮すべきもう一つの問題。

macOS Ventura以降、ユーザーはアプリに代わってインストールされたバックグラウンドタスクを承認するよう求められます。

これは、ユーザーがその作業がアプリに代わってのみ行われることを期待していることを意味します。

攻撃者がplistが実行することを期待するコードを置き換えることができる場合、攻撃者はアプリに代わって永続的なバックグラウンド実行を得る可能性があります。

登録されたplistが期待するコードの実行にのみ使用できるように、SpawnConstraintキーを使用してlaunchd plist制約を設定できます。

ここでは、SpawnConstraintキーで完全な起動plistを見ることができます。

この制約は、私たちのチームとDemoMenuBarエージェントを特定します。

最後に、ライブラリの読み込みについて話しましょう。

変更せずに別の開発チームからライブラリをリンクする義務がある場合は、強化されたランタイムでアプリを公証するには、disable-library-validation資格を採用する必要があります。

残念ながら、それはあなたのアプリが、あなたがライブラリを入手した信頼できる開発者だけでなく、誰でも署名したコードを読み込むことができることを意味します。

この問題に対処するには、ライブラリの負荷制約を採用できます。

ここでは、チームまたは信頼できるライブラリサプライヤーによって署名されたコードをロードできる制約を示します。

また、これを1つ以上の署名識別子の事実を使用して、特定のライブラリまたはライブラリのセットにさらに制限することもできます。

起動制約と同様に、Xcode署名設定で「Library Load Constraint Plist」設定を設定すると、ライブラリのロード制約がプロセスにサインインします。

では、環境制約はどこで利用できますか?

ライブラリの負荷制約と起動plistの制約は、任意のmacOSバージョンをターゲットとするアプリに含めることができます。

それらはmacOS Sonomaで開始されます。

起動制約は、macOS 13.3以降をターゲットとするアプリに追加でき、macOS 13.3から強制されます。

環境制約で使用できるサポートされているキーと値のセットは、macOSのバージョン間で変更される可能性があることに注意してください。

完全な可用性情報については、ドキュメントを参照してください。

アプリのプロセス関係、起動済みplist、およびライブラリを見て、環境制約を使用してアプリをより安全にできるかどうかを確認してください。

見てくれてありがとう。

♪ ♪