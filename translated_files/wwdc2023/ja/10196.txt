10196

♪ ♪

ニック・ジレット：こんにちは、私はAppleのSwiftDataチームのエンジニア、ニック・ジレットです。

このセッションでは、この豊かで強力な新しいフレームワークを活用するために、SwiftDataで構築されたアプリケーションがどのように進化するかを詳細に検討します。

まず、アプリケーションで永続性を設定する方法を調べます。

次に、ModelContextを使用して変更を追跡し、永続化する方法について説明します。

最後に、コード内のオブジェクトを操作するときにSwiftDataを最大限に活用する方法を調べます。

このセッションは、「Meet Swift Data」と「Model your Schema with SwiftData」で導入された概念とAPIに基づいて構築されていることに注意したいと思います。

このセッションを続ける前に、これらのセッションを確認することを強くお勧めします。

この講演では、SwiftDataでアプリケーションを構築するのがいかに簡単かを実証するために、今年構築した新しいサンプルアプリケーション、SampleTripsを参照します。

SampleTripsを使用すると、いつ、どこで旅行したいかについてのアイデアを簡単に整理できます。

SwiftDataはまた、ユーザーがアプリケーションを切り替えたときの取り消しや自動保存などの標準的なプラットフォームプラクティスを簡単に実装できるようにします。

SwiftDataは、Swiftを使用するアプリケーションでデータを永続化する新しい方法です。

クラスや構造体など、コードですでに使用しているタイプで動作するように設計されています。

この概念の中核には、新しいマクロ@Modelで説明されているモデルがあり、永続化したいタイプについてSwiftDataに伝えます。

これはSampleTripsアプリケーションのトリップクラスです。

旅行に関する情報と、SampleTripsで使用される他のオブジェクトへの参照をキャプチャするためのいくつかのプロパティがあります。

私たちは、私がここで持っているように、通常永続性なしで書くコードと、永続性を持って書かなければならないコードとの間に最小限の距離を提供するようにSwiftDataを設計しました。

ほんの少しの変更で、この旅行は私が持続したいモデルであることをSwiftDataに伝え、BucketListItemとLivingAccommodationsとの関係がどのように振る舞うべきかを説明しました。

可能であれば、SwiftDataは、書き込むコードから使用する構造を自動的に推測します。

しかし、SwiftDataは、データの保存方法を正確に説明するのに役立つ強力なカスタマイズセットも提供しています。

「SwiftDataでスキーマをモデル化」では、モデルの力についてすべて学ぶことができます。

Tripクラスへのこれらの注釈により、SwiftDataで2つの重要な役割を果たすことができます。

1つ目は、スキーマと呼ばれるアプリケーションのオブジェクトグラフを記述することであり、2つ目は、Tripクラスがコードを書くことができるインターフェイスになることです。

この二重性、両方の部分を再生する能力は、@Modelマクロで注釈付けされたクラスをSwiftDataを使用するアプリケーションの中心的な連絡先にし、これらの役割のそれぞれをサポートするための整列されたAPIコンセプトがあります。

スキーマは、データの永続化方法を記述するために、ModelContainerと呼ばれるクラスに適用されます。

ModelContainerはスキーマを消費して、Modelクラスのインスタンスを保持できるデータベースを生成します。

コードでModelクラスのインスタンスを操作する場合、これらのインスタンスはメモリ内の状態を追跡および管理するModelContextにリンクされます。

この二元性はSwiftDataの中核であり、このセクションでは、持続性の構造とそれがModelContainerでどのように機能するかを説明するために、モデルの最初の役割を詳しく見ていきます。

ModelContainerは、データがデバイスにどのように保存されるか、または保持されるかを説明する場所です。

ModelContainerは、スキーマとその永続性の間の架け橋と考えることができます。

メモリ内かディスクかなど、オブジェクトがどのように保存されるかに関する説明が、バージョン管理、移行、グラフ分離などのストレージの運用および進化的セマンティクスを満たす場所です。

スキーマでコンテナをインスタンス化するのは簡単です。

私は私が作業したいタイプだけを提供することができ、SwiftDataは私のためにスキーマの残りの部分を把握します。

たとえば、Tripクラスは他のモデルタイプに関連しているため、単一のタイプしか渡していないにもかかわらず、ModelContainerは実際にこのスキーマを推測します。

ModelContainerには、ModelConfigurationと呼ばれるクラスを使用してますます複雑な構成を可能にするために、コードとともに成長するように設計された他の多くの強力な初期化子があります。

ModelConfigurationは、スキーマの永続性を記述します。

一時的なデータのメモリや永続的なデータのディスクなど、データが保存されている場所を制御します。

ModelConfigurationは、選択した特定のファイルURLを使用するか、グループコンテナエンタイトルメントなどのアプリケーションのエンタイトルメントを使用して自動的に生成できます。

この設定では、永続ファイルを読み取り専用モードでロードし、機密データやテンプレートデータへの書き込みを防ぐ必要があることも説明できます。

そして最後に、複数のCloudKitコンテナを使用するアプリケーションは、スキーマのModelConfigurationの一部として指定できます。

新しいPersonとAddressクラスを使用して、SampleTripsに連絡先情報を追加したいと想像してみましょう。

まず、使用するすべてのタイプを含む合計スキーマが宣言されます。

次に、Trip、BucketListItem、およびLivingAccommodationsモデルを含むSampleTripsデータの構成が宣言されます。

この特定のオブジェクトグラフのデータを保存するために使用するファイルのURLと、SampleTripsデータをCloudKitに同期するときに使用するCloudKitコンテナのコンテナ識別子を宣言します。

次に、人とアドレスを持つ新しいスキーマのモデルは、このデータをTripsグラフから分離するために、一意のファイルURLとCloudKitコンテナ識別子を使用して独自の構成で宣言されます。

最後に、スキーマと構成を組み合わせてModelContainerを形成します。

ModelConfigurationの力により、どんなに複雑であっても、アプリケーションの永続性要件を簡単に説明できます。

SwiftUIアプリケーションは、手でコンテナをインスタンス化することに加えて、新しいmodelContainer修飾子を使用して、作業したいコンテナを作成できます。

modelContainer修飾子は、アプリケーション内の任意のビューまたはシーンに追加でき、シンプルなものから強力なものまで、そしてその間のすべてでModelContainersをサポートします。

このセクションでは、ModelContainerを使用してスキーマと永続性を組み合わせる方法を調べました。

これまで以上に強力な機能とオブジェクトグラフを構築するにつれて、アプリケーションとともに成長します。

そして、ModelConfigurationを使用して強力な永続性機能のロックを解除する方法を実証しました。

「Meet SwiftData」で学んだように、ModelとModelContextは、ユーザーインターフェイスの書き込みやモデルオブジェクトの操作時に最も頻繁に使用される概念の2つです。

このセクションでは、ModelContextがどのように変更を追跡し、ModelContainerを通じて編集を永続化するかを深く掘り下げます。

ビューまたはシーンコードでmodelContainer修飾子を使用すると、特定の方法でアプリケーションの環境を準備します。

修飾子は、環境内の新しいmodelContextキーをコンテナのmainContextにバインドします。

主なコンテキストは、シーンやビューでModelObjectsを操作するための特別なMainActorアライメントモデルコンテキストです。

環境からモデルコンテキストを使用することで、ビューコードはここでクエリで使用されるコンテキストに簡単にアクセスできるため、ここで削除などのアクションを実行できます。

したがって、モデルのコンテキストは使いやすくアクセスしやすいですが、実際には何をしますか?

ModelContextは、アプリケーションが管理するデータに対するビューと考えることができます。

作業したいデータは、使用されるモデルコンテキストにフェッチされます。

SampleTripsでは、今後のトリップビューがリストのデータをロードすると、各トリップオブジェクトがメインコンテキストにフェッチされます。

旅行が編集された場合、その変更はモデルコンテキストによってスナップショットとして記録されます。

新しいトリップの挿入や既存のトリップの削除など、他の変更が行われると、コンテキストは「context.save（）」を呼び出すまで、これらの変更に関する状態を追跡し、維持します。

これは、削除されたトリップがリストに表示されなくなったとしても、その削除がsaveを呼び出すことによって持続するまで、ModelContextにまだ存在することを意味します。

saveが呼び出されると、コンテキストはModelContainerへの変更を永続化し、その状態をクリアします。

リストに表示するなど、コンテキスト内のオブジェクトをまだ参照している場合は、完了するまでコンテキストに存在します。

その時点で、彼らは解放され、文脈は空になります。

ModelContextは、バインドされているModelContainerと連携して動作します。

ビューでフェッチしたオブジェクトを追跡し、保存が実行されたときに変更を伝播します。

ModelContextは、必要に応じてキャッシュされた状態をクリアするためのロールバックやリセットなどの機能もサポートしています。

これは、取り消しや自動保存などのプラットフォーム機能をサポートするのに理想的な場所です。

SwiftUIアプリケーションでは、modelContainer修飾子には、ウィンドウの取り消しマネージャをコンテナのmainContextにバインドするこのisUndoEnabled引数があります。

つまり、メインコンテキストで変更が行われると、3本指のスワイプやシェイクなどのシステムジェスチャーを使用して、追加のコードなしで変更を元に戻したり、やり直したりできます。

ModelContextは、モデルオブジェクトに変更が加えられると、取り消しとやり直しのアクションを自動的に登録します。

modelContainer修飾子は、通常、ウィンドウまたはウィンドウグループの一部としてシステムによって提供される環境のundoManagerを使用します。

このため、3本指のスワイプやシェイクなどのシステムジェスチャーは、アプリケーションで自動的に機能します。

ModelContextでサポートされているもう1つの標準システム機能は、自動保存です。

自動保存を有効にすると、モデルコンテキストは、フォアグラウンドやバックグラウンドに入るアプリケーションなどのシステムイベントに応答して保存されます。

メインコンテキストは、アプリケーションが使用されるときに定期的に保存されます。

自動保存はアプリケーションでデフォルトで有効になっており、modelContainer修飾子のisAutosaveEnabled引数を使用して必要に応じて無効にすることができます。

手作業で作成されたモデルコンテキストでは、自動保存が無効になっています。

「Meet SwiftData」では、アプリケーションでModelContextを操作する方法と、SwiftUIとの組み合わせについて多くのことを学びました。

しかし、アプリケーションがモデルオブジェクトを操作する必要があるのは、ユーザーインターフェイスだけではありません。

このセクションでは、SwiftDataが強力でスケーラブルなコードの作成をこれまで以上に簡単かつ安全にする方法について説明します。

バックグラウンドキューのデータ操作、リモートサーバーやその他の永続性メカニズムとの同期、バッチ処理などのタスクは、セットやグラフで頻繁にモデルオブジェクトで動作します。

これらのタスクの多くは、ModelContextのフェッチメソッドを介して作業するオブジェクトのセットを取得することから始まります。

この例では、TripモデルのFetchDescriptorは、trips配列がTripオブジェクトのコレクションであることをSwiftに伝えます。

心配するキャスティングや複雑な結果タプルはありません。

FetchDescriptorを使用すると、新しい述語マクロを使用して複雑なクエリを簡単に作成できます。

例えば、特定のホテルに滞在することを含むすべての旅行は何ですか?

または、どの旅行にまだ予約が必要なアクティビティがありますか？

SwiftDataでは、サブクエリと結合をサポートする複雑なクエリはすべて純粋なスウィフトで記述できます。

Predicateは作成したモデルを使用し、SwiftDataはこれらのモデルから生成されたスキーマを使用して、これらの述語をデータベースクエリに変換します。

FetchDescriptorは、新しいFoundation Predicateマクロのパワーとスキーマを組み合わせて、コンパイラが検証したクエリを初めてAppleプラットフォーム上の永続性にもたらします。

FetchDescriptorやSortDescriptorなどの関連クラスは、ジェネリックを使用して結果型を形成し、使用できるモデルのプロパティについてコンパイラに伝えます。

オフセットやリミット、フォールトやプリフェッチのパラメータなど、あなたが知り、愛するようになった多くのチューニングオプションがあります。

このすべてのパワーは、ModelContextの新しい列挙関数に結合されます。

単一のコールサイトでプラットフォームのベストプラクティスをカプセル化することで、バッチトラバーサルと列挙の厄介なパターンを暗黙的に効率的にするのに役立つように設計されています。

Enumerateは、単純なものから強力なものまで、複雑さに関係なく、FetchDescriptorsでうまく機能します。

Enumerateは、バッチ処理や突然変異ガードなどのトラバーサルのプラットフォームのベストプラクティスを自動的に実装します。

これらは、特定のユースケースのニーズに合わせてカスタマイズ可能です。

たとえば、列挙するバッチサイズは、デフォルトを5,000オブジェクトに使用します。

しかし、メモリの成長を犠牲にして、トラバーサル中のI / O操作を減らすために10,000に変更することができます。

画像、ムービー、またはその他の大きなデータブロブを含むような、より重いオブジェクトグラフは、より小さなバッチサイズを使用することを選択できます。

バッチサイズを小さくすると、メモリの成長は減少しますが、列挙中にI/Oが増加します。

Enumerateには、デフォルトで突然変異ガードも含まれています。

大規模なトラバーサルのパフォーマンスの問題の最も頻繁な原因の1つは、列挙中にコンテキストに閉じ込められる突然変異です。

allowEscapingMutationsは、これが意図的であることを列挙に伝えます。設定されていない場合、列挙を実行するModelContextが汚れていることを発見した場合、列挙はスローされ、すでにトラバースされたオブジェクトを解放するのを防ぎます。

このセッションでは、スキーマとモデル構成を使用して強力な永続性構成を作成する方法を学びました。

また、ModelContainerとModelContextで取り消しややり直しなどの標準的なシステムプラクティスを採用するのがいかに簡単かを学びました。

そして、今日SwiftDataを使用して、FetchDescriptor、predicate、enumerateを使用して、これまでにないほど安全でパフォーマンスの高いコードをプロジェクトに書き込むことができます。

今後数ヶ月から数年の間に、この新しいフレームワークで可能なことの限界を押し広げる方法を見るのが待ちきれません。

見てくれてありがとう、そして幸せなコーディング。