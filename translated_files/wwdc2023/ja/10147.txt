10147

♪ ♪

ニヴァシュ:皆さん、こんにちは。

私はコアロケーションフレームワークチームのエンジニア、Nivash Raaja Karukankaatur Murugasamyです。

コアロケーションモニターに関する私の講演へようこそ。

私たちの新しいCLMonitor APIについて話すことに本当に興奮しています。

Swiftでわずか数行のコードで、シンプルで強力な監視ロジックを書くことができます。

モニターを作成し、条件を追加し、イベントを待つだけです。

そこにあります。こんにちは、CLMonitor!

CLMonitor APIの詳細を見てみましょう。 

ユーザーの位置やビーコンを監視するための新しいシンプルで強力な方法であるCLMonitor APIの概要から始めます。

次に、監視できる条件の種類と、それらを追加または削除する方法について説明します。

次に、監視記録、それらに含まれるもの、およびアプリのライフサイクル中にそれらにアクセスする方法について説明します。

監視対象の条件のいずれかがイベントに遭遇した場合に、アプリで実行する必要がある手順に従います。

そして最後に、CLMonitorを使用する際に役立ついくつかの要件と推奨事項をまとめます。

まず、モニターとは何か、監視用のモニターを作成する方法を見てみましょう。

CLMonitorはトップレベルのSwiftアクターであり、各CLMonitorインスタンスは監視へのゲートウェイとして機能します。

アクターであるため、スレッドとタスクの同期のオーバーヘッドから解放されます。

したがって、CLMonitorのコンテンツにアクセスしたり、いつでも条件を追加または削除したりするのを待つ必要があります。

モニターを作成するには、英数字の文字列でモニターのinitメソッドを呼び出します。

その名前の既存のモニターがない場合は、新しいモニターが作成されます。

そうでなければ、既存のものが開かれます。

いずれにせよ、モニターインスタンスが返されます。

いつでも開くことができるのは、指定された名前のインスタンスが1つだけであることに注意してください。

監視されているエンティティは条件と呼ばれます。

監視用の条件をCLMonitorインスタンスに追加し、addメソッドを使用して識別子に関連付けることができます。

識別子は英数字の文字列です。

たとえば、この例の「作業」は、ユーザーが作業中に満たされる条件の記録を一意に識別します。

レコードオブジェクトとその内容は、この識別子によってアクセスでき、条件は削除されるまで監視されます。

同じ識別子でremoveを呼び出すことで、監視から条件を削除できます。

条件を削除すると、対応するレコードも削除されます。

モニターインスタンスの作成方法とそれが条件とどのように関連しているかがわかったので、利用可能な条件の種類と、それを作成して監視用に追加する方法を見てみましょう。

iOSでサポートされている条件には2種類あります。

まず、CircularGeographicCondition。

円形の地理的条件は、中心と半径によって定義されます。

中心は条件の地理的位置を定義します。

半径は、条件が満たされていると見なされる領域を定義します。

その地域以外の場所では、その状態が満たされていないと報告します。

これは、iOS 16および以前のリリースのCLCircularRegionに似ています。

関心のある緯度と経度でCLLocationCoordinate2Dを構築することで、中心を定義します。

次に、その中心と関心のある半径でCircularGeographicConditionを作成します。

iOSでサポートされている他のタイプの条件は、BeaconIdentityConditionです。

BeaconIdentityConditionは、iOS 16以前のリリースで使用した可能性のあるCLBeaconIdentityConstraintまたはCLBeaconRegionに似ています。

会社が異なる場所に複数のサイトがある場合は、ビーコンを展開して、ユーザーがいずれかのサイト、特定のサイト、または特定のサイトの特定のセクションにいるかどうかをアプリで検出できます。

複数のサイトのオフィスで利用可能な簡単な例として、Appleのカフェテリアを考えてみましょう。

関連するアプリで位置情報ベースの動作を有効にするために、ビーコンを効果的に展開する方法を見てみましょう。

そして、私たちが行くにつれて、そのアプリがさまざまな状況でBeaconIdentityConditionの異なるフレーバーを使用して、これらのビーコンを監視する方法について話します。

ビーコンを定義するものを簡単に見てみましょう。

UUID文字列、メジャー番号、マイナー番号が含まれています。

BeaconIdentityConditionを使用すると、UUID、メジャー、マイナーの3つすべてを指定することで、特定のビーコンを監視できます。

または、UUIDとメジャーのみ、またはUUIDのみを指定することで、ビーコンのグループから任意の単一のビーコンを一致させるためにワイルドカードで一致させることができます。

マイナーまたはメジャーとマイナーを未指定のままにすると、それらのプロパティの値を持つビーコンが一致する可能性があります。

この例でこれをどのように使用できるか見てみましょう。

私たちは、すべて同じUUIDを持つこれらのカフェテリアサイトにビーコンを展開することができます。

また、アプリでは、このUUIDを監視するためのBeaconIdentityConditionを作成できます。

その後、ユーザーがこれらのビーコンの1つに近づくと、条件が満たされます。

そうでなければ、それは満足していないと判断されます。

コードでは、UUIDのみを指定するinitメソッドを呼び出すことでこれを行うことができます。

必要な場所にビーコンを展開したので、ユーザーが特定のサイトの1つにいるかどうかを検出することに興味があるかもしれません。

この場合、ユーザーがアップルパークのサイトにいるかどうかを監視する方法を見てみましょう。

これを達成するために、各サイトに展開されたビーコンは、一意の主要な番号を共有する必要があります。

その後、アプリで、そのメジャーと全体的なUUIDでBeaconIdentityConditionを監視できます。

条件の状態は、デバイスがビーコンがUUIDとメジャー値の両方と一致するサイトにある場合にのみ、満たされていると判断されます。

他のサイトでは満足できないままです。

コードでは、UUIDとメジャーのみを指定するinitメソッドを呼び出すことで、BeaconIdentityConditionを作成できます。

これで、すべてのサイトまたは特定のサイトを監視する方法がわかりました。

ただし、特定のサイト内の特定のセクションを監視することもできます。

これは、対応するマイナーな値を持つ各サイト内の異なる場所（例えば、料理ステーション）にビーコンを配置することで達成できます。

アプリでは、UUIDとメジャーとともに、特定のマイナー値のBeaconIdentityConditionを監視できます。

このような状態は、そのマイナーと全体的なUUIDとメジャーを持つビーコンが検出された場合にのみ満たされます。

コードでは、これはUUID、メジャー、マイナーを渡すことによってBeaconIdentityConditionを作成することを意味します。

BeaconIdentityConditionを作成するときは、ニーズに合ったinitメソッドを使用してください。

さて、さまざまなタイプとフレーバーの条件を作成する方法がわかったので、監視のためにそれらを追加する方法を見てみましょう。

CLMonitorインスタンスで識別子と呼ばれる英数字の文字列でaddメソッドを呼び出すことで、監視の条件を追加できます。

条件は識別子に関連付けられます。

条件がすでに指定された識別子で監視されている場合は、渡された新しい条件に置き換えられます。

条件を追加すると、コアロケーションによって決定されるまで、初期状態は不明になります。

追加する前に、条件の現在の状態を認識している場合があります。

そのような場合、監視のために追加するときに状態を渡すことで、デフォルトの初期状態を上書きできます。

この例では、あなたのアプリはあなたがアップルパークのサイトにいないと推測し、条件が満たされていないことを期待していると仮定しましょう。

通話に「assuming: .unsatisfied」を追加できます。

その後、監視は「不満」に設定された状態から始まります。

でも、心配しないでください。

状態の仮定が間違っている場合、コアロケーションは、それが決定されると正しい状態を提供します。

モニタリングから条件を削除するには、条件が追加されたときに渡された識別子でremoveメソッドを呼び出すことができます。

これで、条件とは何か、どのタイプがサポートされているか、監視から条件を追加または削除する方法がわかりました。

レコードの内容と、レコードまたはモニター内のすべてのレコードをいつでも検査する方法を詳しく見てみましょう。

以前のスライドから思い出せる場合、監視の条件を追加すると、Core Locationはレコードを作成し、そのレコードに条件を追加します。

条件に加えて、レコードにはイベントと呼ばれる別のオブジェクトが含まれています。

イベントには、満足しているかどうか、満足していないかどうか、不明であるかどうかにかかわらず、条件の現在の観察状態を表す状態と、条件が状態に遭遇した日時が含まれます。

今、あなたはなぜイベントに別の条件のインスタンスがあるのか疑問に思うかもしれません。

これは洗練と呼ばれています。

それは何のためですか?

BeaconIdentityConditionから呼び出すことができれば、アプリはUUID、UUIDとメジャー、またはUUIDとメジャーとマイナーだけを監視できます。

メジャーとマイナーのワイルドカードを持つ条件が満たされた場合、そのイベントは改良が入力された状態で配信されます。

その改良条件は、UUIDだけでなく、観察されたビーコンの主要な情報とマイナーな情報も運びます。

その後、条件が満たされなくなると、絞り込みはゼロにリセットされます。

条件が追加されたときに渡された識別子によって一意にアドレスされた各レコードを持つレコードのインスタンスが複数ある可能性があります。

lastEventsと識別子に条件を関連付けるモニターのすべてのレコードは、アプリに保存されます。

これにより、いつでも最後に観察された条件とその対応する状態を照会できます。

それがコードでどのように見えるか見てみましょう。

条件に関連付けられたレコードを取得するには、その識別子でレコードメソッドを呼び出すことができます。

渡した識別子で条件が監視されていない場合は、nilが返されます。

その後、条件プロパティにアクセスすることで、基礎となる監視条件を取得できます。

また、lastEventプロパティにアクセスすることで、その条件のlastEventをアプリに配信できます。

その後、イベントから、最近観察された状態、日付、および洗練を得ることができます。

今、あなたは1つのレコードを取得する方法を知っています。

すべての監視記録はどうやって取得しますか?

すべての識別子を追跡する必要がありますか? 

まあ、あなたはする必要はありません。

モニターの識別子プロパティでリストを維持します。

簡単に反復して、各レコードとその内容を取得できます。

レコードの内容にアクセスする方法がわかったので、変更が発生したときにイベントを消費する方法を見てみましょう。

イベントを受信するコードは、タスクにラップされた単純なループを使用して実装できます。

Core LocationがlastEventで報告された状態とは異なる監視対象の状態を観察すると、Core Locationはモニターのイベント非同期シーケンスプロパティを介して新しいイベントを配信し、待機ループを再開します。

配信されるイベントオブジェクトは、新しい状態と影響を受ける条件の識別子をもたらします。

または、新しいイベントの処理中に、識別子を使用して、その条件のレコードとlastEventを取得することもできます。

その情報を使用して、今起こったことについてより多くの文脈を得ることができます。

そこにある！

私たちのシンプルなグリータープログラムが完成しました。

CLMonitorの仕組みがわかったので、最適な使い方についてアドバイスがあります。

3つの重要な要件から始めましょう。

まず、異なる条件の処理を別々にするために、異なる名前の複数のモニターを持つことができますが、特定の名前に対して一度に1つだけをインスタンス化する必要があります。

CLMonitorは監視している条件の状態を維持しているため、同じ名前の別の状態を初期化しようとすると、望ましくない動作が発生する可能性があります。

第二に、イベントは予測不可能に到着する可能性があるため、モニターのイベントシーケンスに常にタスクを待機させるのが最善です。

イベントは、あなたがそれを処理した後にのみ、いくつかのレコードの最後のイベントになることができます。

したがって、イベントを待っていない間に状態が変更された場合、モニターは新しい状態を反映しません。

最後に、アプリが終了した場合、監視された条件がイベントに遭遇すると、ユーザーの位置情報を受け取ることが許可されている限り、コアロケーションはバックグラウンドでアプリを起動します。

つまり、アプリは、監視している状態の状態に興味がある場合は、起動するたびにモニターを再監視し、イベントを待つ必要があります。

これを行う1つの方法は、didFinishLaunchingWithOptionsアプリデリゲートコールバックを聞くことです。

新しいAPIは起動動作をもたらすので、あなたのアプリからのみCLMonitorを使用することを強くお勧めします。

ウィジェットやプラグインで使用すると、代わりにアプリが起動し、一度に特定の名前のモニターが1つしか存在しないことが複雑になります。

最後に、先に述べたように、条件とその状態は持続し、CLMonitorが監視している条件の1つで状態の変化を観察したときにイベントが生成されるため、CLMonitorがそれらを自分のテーブルに維持するのではなく、それらを表すようにそれらの状態を見て、到着したイベントと同期しないことを強くお勧めします。

とはいえ、SwiftUIビジュアライゼーションなどの一部のアプリケーションでは、別の表現を保持する必要があるかもしれません。

それを行う必要がある場合は、その表現をSwiftUI用に予約し、予想されるイベントについて推論するために使用しないでください。

それがCLMonitorです!

私たちの新しいAPIには本当に興奮しています。

試してみて！

監視体験が大幅に向上することを願っています。

私たちはあなたのフィードバックを聞きたいです。

また、CLMonitorの動作を実証するサンプルアプリもあります。

このビデオのリソースセクションで入手できます。

ダウンロードして試してみてください。

最後に、場所の更新について同僚のSirajによるセッションをチェックアウトします。

見てくれてありがとう!