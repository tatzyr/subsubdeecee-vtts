10149

♪ ♪

フィリップ：こんにちは、私の名前はフィリップです。

Swift: Observationで魔法の新機能を発表できることを本当に嬉しく思います。

この機能を使用すると、標準のSwift構文を使用してモデルを定義し、それらのタイプを使用してUIがそのモデルの変更に応答させることができます。

これにより、SwiftUIでの開発がシームレスで直感的になります。

今日はいくつかのトピックを取り上げます。観察の概要、SwiftUIのプロパティラッパーを使用するタイミングに関する一連の便利なルール、次に、観測可能なより高度な使用法のいくつかを取り上げます。

そして、ObservableObjectの使用から新しい@Observableマクロにコードを更新する方法に関するいくつかの例で締めくくります。

オブザベーションは、プロパティの変更を追跡するための新しいSwift機能です。

それは通常のSwiftタイプで動作し、マクロの魔法でそれらを変換します。

私たちはしばしばデータモデルタイプを書き、それらは最終的にSwiftUIで使用したいと思う多くのプロパティを持っています。

データモデルの変更にUIを応答させるために必要なのは、@Observableを追加するだけだと言ったらどうなりますか？

Swift 5.9の新機能により、モデルをこれまで以上にシンプルにすることができます。

これは、Swiftの新しいマクロシステムを使用します。

「@Observable」は、Swiftコンパイラに、あなたが書いたものから、タイプを観察できるようにする拡張形式にコードを変換するように指示します。

観察可能なタイプを使用して、SwiftUIビューを強化できます。

そして、驚くべき部分は、彼らが働くためにプロパティラッパーの任意の種類を必要としないということです。

ドーナツフードトラックアプリからおいしいサンプルをいくつか持っているので、すぐに飛び込みましょう。

ここでは、ドーナツを示す簡単なビューがあります。

SwiftUIは、ボディコールを実行するときにモデルが特定のプロパティにアクセスすることを知っています。

この場合、ドーナツメニュービューの本体を実行するときに、プロパティ「ドーナツ」がアクセスされたことを検出できます。

bodyが実行されると、SwiftUIは「Observable」タイプから使用されるプロパティへのすべてのアクセスを追跡します。

次に、その追跡情報を取り、それを使用して、それらの特定のインスタンスのこれらのプロパティの次の変更がいつ変更されるかを判断します。

ここでは、ドーナツの追加ボタンをクリックしてドーナツ配列を変更すると、ドーナツメニュービューが無効になり、それに応じてUIが更新されます。

きちんとしているのは、注文が追加された場合、そのプロパティはビューの本文の実行時に決定された追跡されたプロパティの一部ではないため、ビューは無効にならないということです。

次に、計算されたプロパティを使用すると何が起こるかを取り上げましょう。

計算されたプロパティを追加すると、以前と同じルールに従います。

使用されるプロパティが変更されると、UIが更新されます。

新しく追加されたコンテンツでは、モデルのorderCountが呼び出され、ordersプロパティにアクセスします。

つまり、この例では、注文が変更された場合、orderCountが注文のプロパティにアクセスするため、そのテキストが更新されます。

「@Observable」マクロを使用すると、オブザベーションをサポートできるようにタイプが拡張されます。

これにより、SwiftUIはこれらのプロパティへのアクセスを追跡し、次のプロパティがそのオブザベーションからいつ変更されるかを観察できます。

そのようなものを追跡すると、UIはそれらの特定のプロパティが変更されたときにのみビューの本体を再計算し、そこから本当に素晴らしいパフォーマンスの改善が見られました。

マクロを深く掘り下げたい場合は、「Write Swiftマクロ」と「Expand on Swiftマクロ」セッションをチェックしてください。

Observableを使用すると、SwiftUIのプロパティラッパーがこれまで以上に簡単になります。

状態、環境、およびバインド可能は、SwiftUIを操作するための3つの主要なプロパティラッパーです。

SwiftUIで観測可能なタイプとインタフェースするためにプロパティラッパーを必要としないケースはすでに説明しましたが、そのケースを掘り下げてみましょう。

@Stateから始めます。

ビューが独自の状態をモデルに格納する必要がある場合は、@Stateプロパティを使用します。

ここでは、シートプレゼンテーションで使用されている観測可能なモデルオブジェクトドーナツがあります。

シートが表示されると、donutToAdd状態変数が編集可能なフィールドに値をバインドするために使用されます。

「donutToAdd」プロパティは、含まれているビューの寿命によって管理されます。

次は@Environmentです。

環境では、値をグローバルにアクセス可能な値として伝播させることができます。

これにより、多くの場所で物事を共有できます。

観察可能なタイプは、それらによって作成された更新はアクセスに基づいているため、ここでは素晴らしく機能します。

フードトラックメニュービューの本体を呼び出すと、アカウントオブジェクトのプロパティuserNameがアクセスされます。

したがって、ユーザー名が変更されると、メニュービューが更新されます。

不動産ラッパーファミリーの最新作は「@Bindable」です。

バインド可能なプロパティラッパーは本当に軽量です。

そのタイプからバインディングを作成できるようにするだけです。

バインド可能なラップされたプロパティからバインディングを取得するのは本当に簡単です。

$構文を使用して、そのプロパティへのバインディングを取得するだけです。

ほとんどの場合、これは観測可能な型へのバインディングになります。

ドーナツビューでは、名前がテキストで表示されます。

しかし、実際には、私たちはその名前を編集できるようにしたいと思っています。

したがって、テキストの代わりに、テキストフィールドを使用できます。

そのTextFieldはバインディングを取ります。

バインディングから読み込んでTextFieldの値を入力しますが、ユーザーが値を変更したときにバインディングに書き戻します。

ドーナツにバインディングするには、ドーナツプロパティの「@Bindable」プロパティラッパーを使用するだけです。

プロパティラッパーアノテーションを使用すると、「$donut.name」構文を使用し、使用時にバインディングを作成できます。

ラッパーを締めくくるために、SwiftUIで観測可能なモデルを使用するために必要な質問は3つだけです。

このモデルはビュー自体の状態である必要がありますか?

もしそうなら、「@State」を使ってください。

このモデルは、アプリケーションのグローバル環境の一部である必要がありますか?

もしそうなら、「@Environment」を使ってください。

このモデルにはバインディングだけが必要ですか?

その場合は、新しい「@Bindable」を使用してください。

そして、これらの質問のどれも「はい」という答えがない場合は、モデルをビューのプロパティとして使用してください。

これまでのところ、保存されているモデルで始まるプロパティを取り上げました。

Observableはもっと多くのことができます。

SwiftUIはインスタンスごとにフィールドへのアクセスを追跡するため、配列、オプション、またはそのことについては、観測可能なモデルを含む任意のタイプを使用できることを意味します。

ドーナツリストビューには、ドーナツモデルの配列があります。

各モデル自体は「@Observable」です。

これらのドーナツの名前のいずれかが変更されると、SwiftUIはその特定のインスタンスでそのプロパティへのアクセスを検出し、ビューを無効にするタイミングを知るために追跡します。

したがって、ランダム化ボタンでドーナツ名が変更されると、ビューはそれに応じて更新されます。

これにより、モデルを好きなように構築できます。

観察されるモデルの配列、または他の観測可能なモデルタイプを含むモデルタイプを持つこともできます。

一般的なルールはObservableの場合で、使用されるプロパティが変更されると、ビューが更新されます。

その規則が完全に適用されないケースがあります。

計算されたプロパティに保存されたプロパティがない場合は、オブザベーションで機能させるために2つの追加手順を実行する必要があります。

これは、観察されるプロパティが、観測可能なタイプの格納されたプロパティの何らかの構成によって変更されない場合にのみ行う必要があります。

この場合、必要なのは、プロパティがいつアクセスされ、プロパティが変更されたときにオブザベーションに伝えることだけです。

これは、Observationがプロパティへのアクセスを正常に合成する方法ですが、ここでは、観測不可能な場所を読み取ることができ、名前を保存できるように、これらのカスタムアクセスポイントを手動で書き換えました。

ほとんどの場合、これらのタイプの手動ケースは必要ありません。なぜなら、ほとんどの場合、問題のモデルのプロパティは他の保存されたプロパティから構成されるからです。

しかし、その高度な機能を必要とするまれなケースでは、観察は十分に柔軟ですが、自分で行うのに十分簡単です。

SwiftUIは、これらのプロパティへのアクセスによって観測可能な型を追跡するため、コンポジションの変化を識別できます。

これは、計算されたプロパティが他の保存されたプロパティから構成されている場合、オブザベーションが機能することを意味します。

ただし、それが真実ではないいくつかのケースでは、直接観察を使用して、アクセスと突然変異にフラグを立てるためにこれらの呼び出しを手動で追加することができます。

以前はフードトラックアプリで、ObservableObjectを使用して、新しい@Observableマクロで行ったのと同じことをいくつか達成しました。

今日SwiftUIを使用するアプリがあれば、非常によく似た状況にあるかもしれません。

観測可能なマクロはコードを簡素化することができ、おそらく、あなたもまともなパフォーマンスの向上を見るかもしれません。

変更前は、FoodTruckModelタイプにはObservableObjectコンフォーマンスがあり、@Publishedプロパティラッパーでマークされた多くのプロパティがありました。

@Observableマクロへの切り替えはかなり簡単でした。

私たちがする必要があるのは、ObservableObjectへの適合性を削除し、「@Published」を削除し、「@Observable」マクロでマークすることだけです。

ビューに関しては、「@ObservedObject」と「@EnvironmentObject」のプロパティラッパーがいくつかありました。

「@ObservedObject」ラッパーのすべてのケースで、消えたか、バインディングだけを必要とし、新しい「@Bindable」に変更しました。

「@EnvironmentObject」ラッパーは、単に「@Environment」に変身しました。

ObservableObjectから新しい「@Observable」マクロへの変更は、ほとんどが注釈を削除するだけでした。

または、@State、@Environment、@Bindableの3つの主要なプロパティラッパーに簡素化します。

これにより、考慮すべきオプションが少ないため、新機能を書くことを推論しやすくなります。

観察はちょうど良いレベルの魔法を持っています。

簡単に始めることができ、@Observableマクロを使用してデータモデルを直接操作できます。

必要なときに、高度なユースケースのマニュアルバージョンを書くことができます。

新しい開発では、Observableを使用することが最も簡単な方法です。

また、既存のアプリケーションでは、Observableを使用すると、モデルを簡素化し、新しい機能を追加する際のパフォーマンスを向上させることができます。

試してみて、その魔法を自分で利用することをお勧めします。

♪ ♪