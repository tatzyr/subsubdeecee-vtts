10248

♪ ♪

ヨアヒム・クルツ：「楽器でハングアップを分析する」へようこそ。

私の名前はヨアヒムで、インスツルメンツチームで働くエンジニアです。

今日は、Hangsを詳しく見てみたい。

まず、ハングとは何かの概要を説明します。そうするには、人間の知覚について話す必要があります。

次に、ハングがどのように引き起こされるかを理解するための基礎を形成するため、イベント処理とレンダリングループについて簡単に説明します。

この理論的な知識を武器に、Instrumentsに飛び込んで、ビジーなメインスレッドハング、非同期ハング、ブロックされたメインスレッドハングの3つの異なるハング例を見ていきます。

これらのそれぞれについて、それらを認識する方法、それらを分析するときに何を探すべきか、そして詳細を学ぶためにドキュメントに他の機器を追加するタイミングを知る方法を紹介します。

始める前に：このセッションの一部では、Instrumentsにいくらか精通しておくと便利です。

Instrumentsでアプリケーションをプロファイリングしたことがあるなら、行っても大丈夫です。

それ以外の場合は、2019年のセッション「Instrumentsを使い始める」をチェックしてください。ハングアップを扱う場合：通常3つのステップがあります。

ハングを見つけ、ハングを分析してそれがどのように起こるかを理解し、それを修正します(そして、それが実際に修正されていることを確認します)。

今日は、あなたがすでにハングを見つけたと仮定し、分析部分に焦点を当て、いくつかの修正について議論します。

ハングの検索についてもっと知りたい場合は、WWDC22のセッション「Xcodeとデバイス上の検出によるトラックダウンハング」をご覧ください。

インストゥルメント、iOS開発者設定で有効にできるオンデバイスハング検出、Xcodeオーガナイザーなど、ハングを見つけるためのすべてのツールをカバーしています。

今日は、インスツルメンツを使って、すでに見つけたハングを分析します。

ハングアップをよりよく理解するために、人間の知覚について話し、光をつけましょう。

電球とケーブルが必要です。

ああ、はるかに良い。

ランプのように、ケーブルを差し込むと電源が入りました。

そして、私が再びそれを引き抜くと、それは停止します。即座に。

しかし、もし遅延があった場合はどうなりますか?

プラグを差し込みます。

そして、ここで電源を入れるのに少し時間がかかりました。

さらに奇妙なことに、ケーブルを再び引き抜くときにも同じことが起こります。

ケーブルが差し込まれてライトが点灯するまでの遅延はわずか500ミリ秒でした。

しかし、それはすでにこの箱の中で何が起こっているのか疑問に思います。

ランプが直接オン/オフしないのは正しいとは感じません。

しかし、他の状況では、500ミリ秒の遅延は大丈夫かもしれません。

どのような遅延が許容されるかは、状況によって異なります。

「カメはどのようにコミュニケーションをとるのか」というような会話を耳にしたとしましょう。

「シェルフォン」

ここでは、質問と回答の間に1秒の遅れがありました。

そして、それは完全に自然に感じました。

しかし、これはそうではありません:それはなぜですか?

カメとユニコーンの会話は、要求と応答スタイルの相互作用ですが、ランプを差し込むことは実際のオブジェクトを直接操作します。

実際の物体は即座に反応します。

実在のものをシミュレートすると、即座に反応する必要があります。

そうでなければ、それは幻想を破ります。

ケーブルが差し込まれてライトが点灯することの間に遅延がなかったときに、私がここに実際のランプを持っていると主張することに問題はありませんでした。

しかし、大幅な遅延があると、あなたの脳は突然「ちょっと待ってください、それはこのようなものの仕組みではありません」と言います。

しかし、インスタントはどれくらい速いですか?

私たちが気づかないほど小さな遅延は何ですか?

これが遅延のないベースラインです。

100ミリ秒はどうですか？

私にとっては、電源を入れるのに少し遅れがあることに気づいたように感じましたが、電源を切るときではなく、よく見るとだけです。

あなたの経験は違うかもしれません。

100ミリ秒はややしきい値です。

大幅に小さな遅延は、もはや実際には知覚できません。

250ミリ秒を試してみましょう。

250ミリ秒はもはやインスタントを感じません。

遅くはありませんが、遅延は間違いなく目立ちます。

この種の知覚しきい値は、ハングレポートにも通知します。

ボタンをタップするなど、離散的なインタラクションで約100ミリ秒未満の遅延は、通常、瞬時に感じられます。

その下でも行きたいかもしれない特別なケースがいくつかありますが、それは目指すべき良い目標です。

その上、それは状況によります。

250ミリ秒まで、あなたはそれを逃れるかもしれません。

それよりも長く、少なくとも無意識のうちに顕著になります。

それは連続的なスケールですが、250ミリ秒を超えると、確かにもう瞬時に感じません。

したがって、ほとんどのツールはデフォルトで250ミリ秒からハングを報告し始めますが、無視しやすいため、これらを「マイクロハング」と呼びます。

文脈によっては、それらは大丈夫かもしれませんが、多くの場合そうではありません。

500ミリ秒を超えるものはすべて、適切なハングを検討します。

これに基づいて、これらのしきい値を大まかに使用できます。何かを瞬時に感じたい場合は、100ミリ秒以下の遅延を目指します。

リクエストとレスポンススタイルのインタラクションがある場合は、追加のフィードバックなしで500ミリ秒で大丈夫かもしれません。

しかし、実際には、私たちはしばしば相互作用で両方を持っています。

例を見てみましょう。 例を見てみましょう。

このセッションの準備を手伝ってくれたすべての同僚にこのメールを書き終えたばかりで、それを送る準備ができています。

マウスを[送信]ボタンに移動してクリックすると、しばらくすると、メールウィンドウがアニメーション表示され、送信中であることを示します。

ここで起こったことは、あなたが実際に2つのことが起こっているのを見たということです。

まず、ボタンが強調表示され、次に500ミリ秒の小さな遅延があり、次に電子メールウィンドウがアニメーション化されました。

しかし、ボタンの強調表示のためにリクエストが受信されたことをすでに知っていたので、この遅延は問題なく感じました。

私たちはボタンを「本物」のものとして扱い、即座に「現実の」時間で更新されることを期待しています。

したがって、インターフェイスの実際のUI要素については、通常、この「インスタント」アップデートを目指したいと考えています。

UI要素が「即座に」反応できるようにするには、メインスレッドをUI以外の作業から解放することが不可欠です。

その理由を知るために、イベントの処理とレンダリングループを詳しく見て、Appleプラットフォームでイベントがどのように処理され、ユーザーの入力がどのように画面の更新につながるかを見てみましょう。

ある時点で、誰かがデバイスと対話します。

私たちはそれがいつ起こるかをコントロールできません。

まず、通常、マウスやタッチスクリーンなどのハードウェアが関係しています。

インタラクションを検出し、イベントを作成し、オペレーティングシステムに送信します。

オペレーティングシステムは、イベントを処理する必要があるプロセスを把握し、アプリなど、そのプロセスに転送します。

アプリでは、イベントを処理するのはアプリのメインスレッドの責任です。

これは、ほとんどのUIコードが実行される場所です。

UIの更新方法を決定します。

その後、このUIアップデートは、個々のUIレイヤーを合成し、次のフレームをレンダリングする別のプロセスであるレンダリングサーバーに送信されます。

最後に、ディスプレイドライバは、レンダリングサーバーによって準備されたビットマップをピックアップし、それに応じて画面上のピクセルを更新します。

これがどのように機能するかについてもっと知りたい場合は、「アプリの応答性の向上」のドキュメントで説明します。私たちにとって、この大まかな概要は、何が起こっているのかを理解するのに十分です。

さて、この間に別のイベントが発生すると、通常は並行して処理できます。

しかし、単一のイベントがパイプラインをどのように通過するかを見ると、すべてのステップを順番に確認する必要があります。

メインスレッドにたどり着く前のイベント処理ステップと、レンダリングと更新の表示ステップは、通常、その期間がかなり予測可能です。

インタラクションの大幅な遅延が発生した場合、ほとんどの場合、メインスレッドの部分に時間がかかりすぎたか、イベントが届いたときにメインスレッドでまだ何かが実行されているため、イベントが処理される前に終了するのを待つ必要があります。

UI要素へのすべての更新がメインスレッドで時間を必要とし、これらの更新が100ミリ秒以内に行われることを考えると、理想的には、メインスレッドでの作業に100ミリ秒以上はかからないはずです。

あなたがより速く、さらに良くなることができれば。

メインスレッドでの長時間の作業もヒッチを引き起こす可能性があり、ヒッチを避けるためにより低いしきい値が適用されることに注意してください。

ヒッチの詳細については、テックトーク「UIアニメーションヒッチとレンダリングループの探索」と「アプリの応答性の向上」に関するドキュメントをご覧ください。

今日、私たちはハングアップに焦点を当てています。

私の同僚の一人は、新機能に取り組んでいる間、私たちのアプリの1つであるBackyard Birdsでハングしているのを見つけました。

インスツルメンツでアプリをプロファイリングしましょう。

ここにアプリ付きのXcodeプロジェクトがあります。

Instrumentsでアプリをプロファイリングするために必要なのは、製品メニューをクリックしてからプロファイリングするだけで、Xcodeがアプリを構築してデバイスにインストールしますが、起動しません。

Xcodeはまた、Instrumentsを開き、Xcodeで設定されたのと同じアプリとデバイスをターゲットにするように設定します。

Instrumentsのテンプレートセレクタでは、タイムプロファイラテンプレートを選択します。これは、探しているものをまだわからず、アプリが何をしているのかをよりよく理解したい場合は、しばしば良い出発点です。

これにより、タイムプロファイラテンプレートから新しいインスツルメンツドキュメントが作成されます。

とりわけ、この新しい文書にはタイムプロファイラー機器とハングス機器が含まれており、どちらも分析に役立ちます。

ツールバーの左上にある録画ボタンをクリックして録画を開始します。

インスツルメントは、設定されたアプリケーションを起動し、データのキャプチャを開始します。

だから、ここにBackyard Birdsアプリがあります。

最初の庭をタップすると、詳細ビューに移動します。

すぐに「背景を選択」ボタンをタップすると、一番下のシートが表示され、選択できる背景画像の選択が表示されます。

今それをやらせてください。

ボタンは押されていますが、詰まっているようです。

シートが表示されるまでにかなり時間がかかりました。

厳しいハング。

インスツルメンツはこれらすべてを記録しています。

ツールバーの停止ボタンをクリックして録音を停止します。

楽器もハングを検出しました。

ハング持続時間を測定し、重大度に応じて対応する間隔にラベルを付けます。

この場合、インスツルメンツは私たちに「深刻なハング」が起こったことを示しています。

これは、アプリの使用中に経験していることにも当てはまります。

機器は応答しないメインスレッドを検出し、対応する間隔を潜在的なハングとしてマークします。

私たちの場合、確かにハングが発生しました。

応答しないメインスレッドには、主に2つのケースがあります。

最も単純なケースは、メインスレッドがまだ他の仕事をするのに忙しいということです。

この場合、メインスレッドには大量のCPUアクティビティが表示されます。

もう1つのケースは、メインスレッドがブロックされていることです。

これは通常、メインスレッドが他の場所で他の作業が行われるのを待っているためです。

スレッドがブロックされると、メインスレッドにCPUアクティビティがほとんどまたはまったくありません。

どのケースが、何が起こっているのかを判断するために次にどのステップを踏むべきかを決定します。

インスツルメンツに戻って、メインスレッドを見つける必要があります。

ドキュメントの最後のトラックは、ターゲットプロセスのトラックを示しています。

サブトラックがあることを示すために、左側に小さな開示インジケーターがあります。

クリックすると、プロセス内のスレッドごとに個別のトラックが表示されます。

次に、ここでメインスレッドトラックを選択します。

これにより、詳細領域が更新され、プロファイルビューが表示され、記録時間中にメインスレッドで実行されたすべての関数のコールツリーが表示されます。

しかし、ハング中に起こったことにしか興味がないので、タイムラインのハング間隔をセカンダリクリックしてコンテキストメニューを表示します。

ここで検査範囲の設定を選択できますが、オプションキーも長押しして、代わりに検査範囲の設定とズームを取得します。

これにより、間隔の範囲にズームインし、詳細ビューに表示されるデータを選択した時間範囲にフィルタリングします。

CPU使用率はハング間隔全体で100%ではありませんが、それでもかなり高く、ほとんどの場合、60%から90%のCPU使用率です。

これは明らかに忙しいメインスレッドの場合です。

このCPU作業が何であるかを調べてみましょう。

これで、コールツリー内のすべての異なるノードを詳しく調べることができます。

しかし、右側には素晴らしい要約があります:最も重いスタックトレースビュー。

最も重いスタックトレースビューのフレームをクリックすると、コールツリービューが更新され、このノードが表示されます。

これはまた、このメソッド呼び出しがすでに呼び出しツリーのかなり深いことを示しています。

デフォルトでは、最も重いスタックトレースは、ソースコードに由来しない後続の関数呼び出しを隠し、ソースコードが関与している場所を簡単に確認できます。

下部バーの[コールツリー]ボタンをクリックし、[システムライブラリを隠す]チェックボックスを有効にすることで、コールツリービューに同様のフィルタを適用できます。

これにより、システムライブラリからすべての機能がフィルタリングされ、コードに集中しやすくなります。

コールツリービューは、ほぼすべてのバックトレースに「BackgroundThumbnailView.body.getter」コールが含まれていることを示しています。

体のゲッターを速くする必要があるように見えますよね?

そうでもない！

したがって、メインスレッドのケースが忙しいことはわかっています。つまり、CPUは多くの作業を行っています。

また、多くのCPU時間を費やす方法も見つけました。

しかし、今は2つの異なるケースがあります。

メソッド自体が長時間実行されるため、このメソッドでは多くのCPU時間を費やす可能性があります。

しかし、それは何度も呼ばれているだけかもしれません、それがここに現れる理由です。

メインスレッドの作業をどのように減らすべきかは、どのケースがあるかによって異なります。

典型的なコールスタックはこのように構成されています。

メイン関数からの呼び出しがあり、いくつかのUIフレームワークやその他のものを呼び出し、ある時点でコードが呼び出されます。

この関数が一度だけ呼び出され、その1つの呼び出しが長い時間がかかる場合、ここのタートル関数のように、それが呼び出すものを見てみたい。

たぶん、それは多くの仕事をします。そうすれば、私たちはそれをより少なくできるかもしれません。

しかし、私たちが調査している方法は、ここのユニコーンのように何度も呼ばれている可能性もあります。

そしてもちろん、それが行う作業も何度も何度も行われます。

これは通常、関数Unicornを何度も呼び出す発信者がいるためです。たとえば、ループから。

ここのユニコーンに焦点を当てた機能を最適化するのではなく、それをあまり頻繁に呼ぶ方法を調査する方が有益かもしれません。

つまり、次に見るべき方向は、私たちが持っているケースに依存するということです。

タートルケースのような長期的な機能については、その実装とその呼び出し先を見てみたい。

私たちはさらに下を見る必要があります。

しかし、ユニコーンのように関数が何度も呼び出された場合、それを呼んでいるものを見て、そうしない頻度でできるかどうかを判断する方が有益です。

私たちはさらに上に目を向ける必要があります。

しかし、タイムプロファイラは、どのケースを持っているかを教えてくれません。

ユニコーンとタートルへの電話が次々に起こったと仮定しましょう。

タイムプロファイラは、CPUで実行されているものを定期的にチェックしてデータを収集します。

また、サンプルごとに、どの機能が現在CPUで実行されているかをチェックします。

この例では、タートルとユニコーンの両方を4回取得します。

しかし、これは非常に速いタートルであり、ユニコーンははるかに時間がかかる、または他の組み合わせである可能性もあります。

これらのシナリオはすべて、タイムプロファイラで同じデータを作成します。

特定の関数の実行時間を測定するには、os_signpostsを使用します。

2019年のセッション「Instrumentsを使い始める」で、その方法について話しました。

また、何が起こっているのかを正確に伝えることができるさまざまな技術に特化した機器もあります。

そのうちの1つは、SwiftUI Viewボディインストゥルメントです。

SwiftUIボディインストゥルメントを追加するには、ツールバーの右上にあるプラスボタンをクリックします。

これはインストゥルメントライブラリを示しています。

これは、インスツルメンツアプリケーションが提供しなければならないすべての機器のリストです。

たくさんあります。

独自のカスタム楽器を書くこともできます。

フィルターフィールドに「SwiftUI」と入力すると、2つの楽器が表示されます。

「本文を表示」インストゥルメントを選択し、ドキュメントウィンドウにドラッグして追加します。

さて、この機器は最後に記録したときにドキュメントになかったため、表示するデータがありません。

でも問題ありません。もう一度録音します。

時間を節約するために、私はすでにそれをしました。

ドキュメントのSwiftUI View Bodyインストゥルメントで録音した後、View Bodyトラックにもいくつかのデータが表示されます。

SwiftUIビューボディトラックには多くの間隔があります。

少し窮屈なので、Ctrl+Plusを押して高さを上げます。

SwiftUI View Bodyトラックは、実装されているライブラリによって間隔をグループ化します。

各インターバルは1つのビューボディ実行です。

もう一度ハングアップしましょう。

2番目の車線には、すべて「BackgroundThumbnailView」というラベルの付いたオレンジ色の間隔がたくさんあります。

これは、いくつのボディ処刑があったか、それぞれにどれくらいの時間がかかったかを正確に教えてくれます。

オレンジ色は、その特定のボディ実行の実行時間が、SwiftUIで目指しているものよりも少し時間がかかったことを示しています。

しかし、より大きな問題は、間隔がいくつあるかのようです。

詳細ビューには、すべてのボディ間隔の要約があります。

Backyard Birdsの横にある開示インジケーターをクリックすると、Backyard Birdsの個々のビュータイプを表示できます。

これは、BackgroundThumbnailViewのボディが平均持続時間約50ミリ秒で70回実行され、合計持続時間が3秒以上になったことを示しています。

これは、私たちのハング期間のほとんどすべてを説明しています。

しかし、前もって6つの画像を表示するだけで、70倍は過剰に思えます。

これは、体があまり頻繁に呼ばれるべきケースなので、なぜこれが頻繁に呼ばれるのかを調べ、それを減らす方法を調べるために、私たちのボディゲッターの発信者を見る必要があります。

関連するコードに簡単に移動するには、メインスレッドトラックを再度選択し、コールツリーのBackgroundThumbnailView.body.getterノードをセカンダリクリックしてコンテキストメニューを表示し、「Xcodeで表示」を選択します。

これにより、Xcodeで本体の実装が開きます。

タイプをセカンダリクリックして「検索」、「ワークスペースで選択したシンボルを検索」を選択して、このビューがどのように使用されるかを調べてみましょう。

検索ナビゲーターの最初の結果は、すでに私たちが探しているものです。

ここでは、「BackgroundThumbnailView」は、グリッド内の別のForEach内のGridRow内のForEach内で使用されます。

グリッドは、作成時にコンテンツ全体を熱心に計算するので、最初のいくつかしか必要でなくても、すべての背景のサムネイルを計算します。

しかし、代替案があります:LazyVGrid。

1つの画面を埋めるために必要なビューの数だけを計算します。

SwiftUIの多くのビューには、必要な数のビューしか計算しない怠惰なバリアントがあり、これは多くの場合、より少ない作業を行う簡単な方法になります。

しかし、熱心なバリアントは、同じコンテンツをレンダリングする必要があるときにはるかに少ないメモリを使用します。

デフォルトで通常の熱心なバリアントを使用し、事前に作業が多すぎることに関連するパフォーマンスの問題を見つけた場合は、怠惰なバリアントに切り替えます。

「SwiftUIのスタック、グリッド、アウトライン」に関するWWDC 2020のWWDCセッションでは、これらの怠惰なバリアントを紹介し、より詳細に説明しています。

この更新されたコードをプロファイリングしましょう。

もう一度「背景を選択」ボタンをタップして、録音を開始し、ハングを再現します。

さて、これははるかに良いです。

まだ少し遅れがありましたが、以前ほど悪くはありません。

楽器はこれを確認します。

私たちが記録したハングは400ミリ秒未満でした。

それはマイクロハングです。

「View Body」トラックはまた、私たちの期待に合った8つのBackgroundThumbnailボディ実行しか得られないことを示しています。

たぶんこれで十分です。

マイクロハングはあまり目立たない。

iPadでBackyard Birdsをプロファイリングすることで、他のデバイスタイプでもうまく機能することを確認しましょう。

ここで、私はiPadでBackyard Birdsを走らせています。

私はすでに詳細ビューにいます。

「背景を選択」ボタンをタップすると、シートが表示されるまでに長い時間がかかります。

それが現れたら、その理由がわかります。

画面が大きくなり、スペースが多いため、サムネイルが増えました。

楽器もこのハングを記録した。

検査範囲をハング間隔に焦点を合わせると、より多くのBackgroundThumbnailViewボディが再び表示されます。

それは理にかなっています。

今、私たちはより多くの多くが画面に収まるように、フルスクリーンのためにそれらの約40をレンダリングする必要があります。

したがって、同じコードはiPhoneではほとんど問題ありませんでしたが、画面が大きかったという理由だけで、iPadでは遅くなりました。

これは、マイクロハングも修正する必要がある理由の1つです。

デスクでのテスト中にマイクロハングとして見るものは、さまざまな条件下で一部のユーザーにとって大きなハングになるかもしれません。

私たちは今、画面を埋めるために必要な数のビューしかレンダリングしないので、これをあまり頻繁に呼び出すという点で最適化の可能性を使い果たしました。

個々の実行をより速くするために何ができるかを見つけましょう。

検査範囲を単一のBackgroundThumbnailView間隔に設定し、「メインスレッド」トラックに切り替えます。

楽器は、最も重いバックトレースビューでビューボディゲッターを示し、「BackyardBackground.thumbnail」プロパティゲッターと呼ばれることを示しています。

これは、ビューに表示するサムネイル画像を提供するモデルオブジェクトです。

このサムネイルゲッターは「UIImage imageByPreparingThumbnailOfSize:」と呼びます。

だから、私たちはここでその場でサムネイルを計算しているようです。

それには時間がかかることがあります。この場合、約150ミリ秒。

これは、メインスレッドを忙しくさせないように、むしろバックグラウンドで行うべき作業です。

どのような変更を加えることができるかをよりよく理解するために、サムネイルゲッターがどのように呼ばれるかを文脈で見てみたい。

最も重いスタックトレースビューの「BackgroundThumbnailView.body.getter」フレームをセカンダリクリックし、「ソースビューアで開く」を選択します。

これは、コールツリービューをソースビューアに置き換え、ボディゲッターの実装を表示し、タイムプロファイラサンプルで実装の行に注釈を付けて、コードがどのくらいの時間を費やしたかを示します。

私たちの体の実装はここで本当に簡単です。背景から返されたサムネイルで新しい画像ビューを作るだけです。

しかし、このサムネイルコールには長い時間がかかります。

私はそれを違う方法で書く方法のアイデアがあります。

Xcodeにジャンプするには、右上のメニューボタンをクリックし、「Xcodeでファイルを開く」を選択します。

以前と同様に、これはXcodeのソースコードを示し、変更を加える準備ができています。

今やりたいことは、サムネイルをバックグラウンドでロードし、ロード中に進行状況インジケーターを表示することです。

まず、ロードされたサムネイルを保持するための状態変数が必要です。

次に、本文で、ロードされた画像がすでにある場合は、画像ビューで使用します。

それ以外の場合は、進捗ビューを表示します。

今残っているのは、実際のサムネイルを読み込むことだけです。

ビューが表示されたら、読み込みを開始したいです。

それが「.task」修飾子のためです。

登場すると、SwiftUIは「サムネイル」ゲッターを呼び出すタスクを開始し、結果を「画像」に割り当て、ビューを更新します。

やってみよう！

だから、ここで、楽器の録音で、「背景を選択」ボタンをタップすると、シートがすぐに出てきます!

すごい！

進捗指標を見て、数秒後にサムネイルが表示されました。

これはうまくいった。いいね！

しかし、待って、楽器はまだほぼ2秒のハングを示しています。

ここで起こったことは、ハングが少し遅れて起こるということです。

裏庭の鳥アプリでどこで起こるかをお見せしましょう。

私はすでに詳細ビューにいます。

しばらくしたら、「背景を選択」ボタンをもう一度タップし、完了ボタンをタップしてすぐにシートを閉じようとします。

OK、「背景を選択」と「完了」。

私は何度もタップしましたが、読み込みが行われている間、私のタップは無視されました。

これはインスツルメンツが私たちに語ったハングです。

シートが表示された後に発生します。

これは少し違うタイプのハングです。

メインスレッドがビジーであるかブロックされているかの違いについてはすでに話しました。

ハングを見る別の方法があります。それらが何によって引き起こされるのか、いつ発生するのか。

私たちはこれらを同期および非同期ハングと呼びます。

ここでは、いくつかの作業を行うメインスレッドがあります。

イベントが入ってくると、そのイベントを処理するのに長い時間がかかる場合、それはハングです。

それをコントロールし、イベントが迅速に処理されるようにしましょう。

しかし、おそらく、メインスレッドで後で行われる作業を遅らせたり、他のメインスレッド作業が発生したりして、イベントが入ってくるかもしれません。

その後、そのイベントは、処理する前に、以前の作業が完了するのを待たなければなりません。

その後、個々のイベント処理のコードがすぐに終了しても、これはハングを引き起こします。

私たちのプラットフォームでハング検出が機能する方法は、メインスレッド上のすべての作業項目を見て、それらが長すぎるかどうかを確認することです。

もしそうなら、それは潜在的なハングとしてそれらをマークします。

そして、ユーザー入力があったかどうかに関係なく、ユーザー入力はいつでも入ってくる可能性があり、実際のハングが発生する可能性があるため、それを行います。

これは、ハング検出がこれらの非同期または遅延ケースも検出することを意味しますが、実際に経験した遅延ではなく、潜在的な遅延のみを測定します。

非同期ハングを非同期と呼びます。これは、多くの場合、メインキューでの「dispatch_async」作業、またはメインアクターで非同期に実行されるSwift Concurrencyタスクによって引き起こされるためです。

しかし、それらはメインスレッドでの作業を引き起こすものによって引き起こされる可能性があります。

私たちが最初に見たハングは同期ハングでした。

ボタンをタップすると、そのボタンをタップすると長時間作業が発生するため、結果が遅れて表示されます。

この最新のハングは、非同期または遅延ハングです。

完了ボタンをタップしても、実際には高価な作業自体は引き起こされません。

しかし、タップが処理されるのを防ぐメインスレッドにはまだ作業がありました。

したがって、アプリを使用している人は、この期間中にアプリと対話しない場合に気付かないかもしれませんが、万が一に備えて、これらのケースを修正する必要があります。

今それをやりましょう。

だから、ここで私はInstrumentsに戻り、すでに選択範囲を非同期ハングに設定し、ズームインしました。

ビューボディトラックのサマリービューで、Instrumentsは、BackgroundThumbnailViewのボディゲッターに75回の呼び出しがあったことを示しています。

これは、ほとんどのサムネイルボディゲッターが2回実行されるためです。

SwiftUIは、グリッドを埋めるための進捗インジケータで40のビューを作成します。

しかし、実際には35のみが表示され、それらの35については、画像の読み込みを開始し、画像が読み込まれると、ビューが更新され、ボディが再び呼び出され、合計75のボディゲッターの実行が与えられます。

合計で75人のボディゲッター全員でさえ、1ミリ秒未満しかかかりませんでした。

だから、私たちのボディゲッターは今速いです。その部分はうまくいった。

しかし、私たちにはまだハングがあります。

「メインスレッド」トラックをもう一度選択し、最も重いスタックトレースビューで、インスツルメンツはそれがまだメインスレッドで長い時間がかかるサムネイルゲッターであることを示しています。

今回は、ボディゲッターではなく、「BackgroundThumbnailView.body.getter」内のクロージャによって呼び出されます。

私はそれをダブルクリックします。これは、ソースビューアを開くためのショートカットです。

さて、これはまさに、タスク修飾子のクロージャにあるため、バックグラウンドで実行すると予想されるコードです。

このコードはこの時点で実行する必要がありますが、メインスレッドでは実行しないでください。

このような問題では、Swift並行性タスクが期待どおりに実行されない場合は、別の便利なツールがあります。Swift並行性タスクツールです。

私はすでにSwift並行性タスクインストゥルメントを追加して同じ動作を記録しました。

Swift Tasksインストゥルメントは、ドキュメントにサマリートラックを追加しますが、私たちのケースにとってより興味深いのは、各スレッドトラックに貢献するデータです。

ここでは、メインスレッドトラックに、Swift Tasksインストゥルメントからの新しいグラフがあります。

1つのトラックに複数のグラフを表示できます。

スレッドトラックヘッダーの小さな下向き矢印をクリックすると、表示するグラフを設定できます。

タイムプロファイラーのCPU使用率グラフのような別のグラフを選択するか、Commandキーを押しながらクリックして複数を選択できます。

だから今、Instrumentsは、このスレッドのCPU使用率とSwiftタスクグラフの両方を一緒に表示しています。

もう一度ハング間隔にズームインします。

「スウィフトタスク」レーンは、メインスレッドに多数のタスク実行があることを明確に表示するようになりました。

検査範囲をそのうちの1つに設定し、プロファイルビューで最も重いスタックトレースをチェックすると、このタスクがサムネイル計算作業をラップしていることを確認します。

だから、この仕事は私たちが望んでいたようなタスクに正しくラップされています。

しかし、タスクはメインスレッドで実行されており、これは予想外です。

ここで何が起こっているのか説明しましょう。 

まず、ボディゲッターはSwiftUIのViewプロトコルから@MainActorアノテーションを継承します。

「body」は「View」プロトコルで「@MainActor」として注釈が付けられているため、実装すると、body getterも@MainActorとして暗黙的に注釈が付けられます。

第二に、「.task」修飾子のクロージャは、周囲のコンテキストのアクター分離を継承するために注釈付けされます。

したがって、ボディゲッターはMainActorに隔離されているため、タスクの閉鎖も同様になります。

したがって、このクロージャで実行されているすべてのコードは、デフォルトでメインアクターで実行され、「サムネイル」ゲッターは同期しているため、メインスレッドで同期的に実行されます。

Swift並行性タスクは、デフォルトでは、周囲のコンテキストのアクター分離を継承します。

同じ動作がSwiftUIの.task修飾子にも当てはまります。

主役から離れるには2つの方法があります。

メインアクターにバインドされていない関数を非同期に呼び出すと、タスクがメインアクターからオフになります。

これが実現不可能な場合があるかもしれません。

次に、「Task.detached」を使用して、周囲のアクターコンテキストからタスクを明示的に切り離すことができますが、これは重いアプローチであり、別のタスクを作成することは、既存のタスクを一時停止するよりも高価です。

SwiftUIは、対応するビューが消えると、タスク修飾子を介して作成されたタスクを自動的にキャンセルしますが、このキャンセルはTask.detachedのような新しい非構造化タスクに伝播しません。

詳細については、WWDC22の「Swift並行性の視覚化と最適化」と、アプリの応答性の向上に関するドキュメントをご覧ください。

私たちの場合、私たちはすでに非同期のコンテキストにあり、サムネイル関数を非分離して非同期にするのは簡単なので、オプション1を選択します。

ここに、サムネイルの読み込みコードがあります。

問題は、ボディゲッターのメインアクター分離を継承するため、このタスクがメインアクターで実行され、サムネイルゲッターが同期しているため、メインアクターにもとどまることです。

修正は簡単です。

サムネイルゲッターの定義にジャンプし、ゲッターを非同期にしてから、ビュー構造体に戻ります...

そして、私たちのゲッターは現在非同期であるため、その前に待機を追加する必要があります。

これにより、「サムネイル」ゲッターは、メインスレッドではなく、Swift Concurrencyの同時スレッドプールで実行できるはずです。

やってみよう。

再び詳細ビューに移動し、「背景を選択」をタップします。

うわー。速かった！

ハングがなかっただけでなく、全体的な読み込みが速かったようにも見えました。

進捗の見方をほとんど見なかった。

楽器は、今ハングがなかったことを確認します。

ここには高いCPU使用率があります。

それをズームインさせてください。

これは、サムネイルの読み込みが今行われている場所です。

メインスレッドをチェックすると、メインスレッドのすべてのタスク間隔が非常に短いことが確認できます。

他のスレッドトラックまでスクロールすると、Swiftタスクが順番に実行されるのではなく、他のスレッドで並行して実行されていることがわかり、マルチコアCPUをはるかにうまく活用できます。

これにより、ほぼ1.5秒ではなく、数百ミリ秒ですべてのサムネイルを計算できます。

そして、この間ずっと、メインスレッドは応答性を維持しているので、私たちは今これを永久に修正しました。

私たちは今、メインスレッドがビジーであることによって引き起こされた応答しないメインスレッドを調査し、修正しました。これは、ハング中に多くのCPUを使用してメインスレッドで識別することができました。

また、ユーザーインタラクションまたは非同期の一部として直接発生するときにハングが同期になる方法、以前にメインスレッドでスケジュールされた作業により、着信イベントが遅れて処理され、Instrumentsが両方のケースを検出する方法も経験しました。

そして、作業を少なくして、他の作業をすることで、バックグラウンドではあまりできず、メインスレッドに戻ってUIを更新するだけで、ハングアップを修正しました。

しかし、私たちがまだ見ていないケースが1つあります。ブロックされたメインスレッドです。その場合、メインスレッドはCPUをほとんど使用しません。

他の次元はブロックされたメインスレッドにも同じように適用されますが、そのようなケースを分析するには他の機器が必要です。

では、例を見てみましょう。

ここに別のハングからのトレースファイルがあります。

私はすでにハングにズームインしました。それは長いものです。数秒。

「メインスレッド」トラックでは、CPU使用率グラフは、初期CPU使用率があることを示していますが、その後は何もありません。

これは、ブロックされたメインスレッドの明確なケースです。

タイムプロファイラがCPUで実行されているものをサンプリングしてデータを収集する方法について話しました。

ズームインすると、CPU使用率グラフには個々のサンプルも表示されます。

したがって、これらのマーカーのそれぞれは、タイムプロファイラが取ったサンプルです。

右側にはさらにいくつかのサンプルがありますが、何もありません。

しかし、サンプルのない時間範囲を選択すると、タイムプロファイラは、この間にデータを記録しなかったため、何が起こっているのかを伝えることができません。

そのため、別のツールであるスレッドステート機器が必要です。

以前の他の楽器と同様に、楽器ライブラリから追加できます。

今回は「スレッドステートトレース」機器を追加して、すでに同じハングを再び録音しました。

今、この楽器のための新しいトラックがあります。

しかし、「Swift Concurrency」機器のように、私たちにとって興味深いデータは実際には「スレッド」トラックにあります。

だから、メインスレッドには6秒以上のこの本当に長い「ブロックされた」間隔があり、これは私たちのハング時間のほとんどを説明しています。

真ん中をクリックすると、Instrumentsのタイムカーソルがそこに移動し、詳細領域のナラティブビューも更新され、このブロック状態のエントリが表示されます。

物語の見解は、スレッドの物語を教えてくれます。それが何をしていたのか、いつ、なぜ。

選択した時間では、スレッドが6.64秒間ブロックされ、syscallであるmach_msg2_trapを呼び出していたためにブロックされたことがわかります。

右側には、再びバックトレースビューがあります。

しかし、このバックトレースは最も重いバックトレースではありません-それはいくつかの集約ではありません。

スレッドがブロックされたのは、mach_msg2_trap syscallの正確なバックトレースです。

関数呼び出しは下部にリーフノードとして表示され、そのコールスタックは上に表示されます。

コールスタックは、システムコールがMLModelを割り当てた結果として発生したことを示しています。これは、そのカラー化サービスで「共有」と呼ばれるシングルトンプロパティの一部として呼び出されたタイプ「ColorizingService」のオブジェクトを割り当てたために発生し、ボディゲッターのクロージャによって呼び出されました。

そのクロージャをダブルクリックすると、再びソースビューアにジャンプし、これが呼び出されたコードを見つけることができます。

このラインは無害に見えますよね?

詳しく見てみましょう。 

ColorizingServiceの共有プロパティにアクセスし、ローカル変数に保存しています。

ただし、共有プロパティは、初めてアクセスされたときに共有ColorizingServiceインスタンスを作成し、スレッドをブロックするモデルローディング機械全体をキックオフするため、無害ではありません。

だから、「待つ」の後にこれを非同期部分の中に移動させましょう」と言いたくなるかもしれません。

しかし、直感に反して、これは問題を解決しません。

「Await」キーワードは、後続のコードの非同期関数呼び出しにのみ適用されます。

この例では、「colorize」関数は「async」です。

しかし、「共有」財産はそうではありません。

静的letプロパティであるため、初めてアクセスされたときに遅延して初期化され、それは同期的に行われます。

Awaitキーワードは変更されないため、同期呼び出しはメインスレッドで引き続き発生します。

共有プロパティを「非同期」にすることで、前の例と同じようにこれを修正して、メインアクターから降りることができます。

これは一般的に、前方の進捗状況が達成される他の場所でスレッドに代わって作業を待っているときにOKです。

しかし、ブロックされたスレッドのもう1つの一般的な理由は、ロックまたはセマフォです。

ベストプラクティスを心に留めておくべきことと、Swift並行性でロックとセマフォを使用する際の避けるべきことについては、WWDC 21のセッション「Swift並行性：舞台裏」をご覧ください。

締めくくる前に、ブロックされたメインスレッドに関連するもう1つのケースについて話したいと思います。

これが私たちが先ほど見た痕跡です。

右側は、ブロックされたメインスレッドで調査したハングです。

しかし、その左側には、メインスレッドが数秒間ブロックされる他のケースがいくつかありますが、Instrumentsはこれを潜在的なハングとしてフラグを立てません。

ここでは、ユーザー入力がなかったため、メインスレッドはちょうどスリープ状態です。

オペレーティングシステムの観点から見ると、それはブロックされていますが、何もすることがないときに実行しないことでリソースを節約しているだけです。

入力が入ってくるとすぐに、それは目を覚まし、それを処理します。

したがって、ブロックされたスレッドが応答性の問題であるかどうかを判断するには、スレッド状態のインストゥルメントではなく、ハングストゥルメントを見てください。

したがって、ブロックされたメインスレッドは、応答しないメインスレッドを意味するものではありません。

同様に、高いCPU使用率も、メインスレッドが応答しないことを意味するものではありません。

しかし、メインスレッドが応答しない場合、それはブロックされたか、メインスレッドがビジーだったことを意味します。

当社のハング検出は、これらすべての詳細を考慮に入れ、メインスレッドが実際に応答しなかった間隔にのみラベルを付け、潜在的なハングとして表示します。

このセッションから1つだけ覚えている場合は、メインスレッドで行っている作業が何であれ、イベント処理のためにメインスレッドを解放するために100ミリ秒未満で完了する必要があります。

短ければ短いほど良い。

ハングを詳細に分析するために、インスツルメンツはあなたの親友です。

ビジーメインスレッドとブロックされたメインスレッドの区別を覚えておいてください。また、ハングはメインスレッドの非同期作業によって引き起こされる可能性があることを忘れないでください。

ハングを修正するには、作業を減らすか、作業をバックグラウンドに移動したいと考えています。

時には、両方でさえも。

そして、多くの場合、より少ない仕事をするということは、その仕事に適したAPIを使用することを意味します。

一般的に、最適化する前に、最初に測定し、実際にハングがあるかどうかを確認してください。

確かにいくつかのベストプラクティスがありますが、並行および非同期コードもデバッグがはるかに困難です。

あなたはしばしば、実際に非常に速く、実際に遅くなるすべてのものに驚くでしょう。

すべてのハングを見つけて、分析して、修正して楽しんでください。

ご覧いただきありがとうございます。

♪ ♪