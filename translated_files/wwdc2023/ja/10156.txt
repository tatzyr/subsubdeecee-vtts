10156

♪ ♪

カイル：こんにちは、私はKyleです。SwiftUIチームのメンバーです。

アニメーションは、現代のアプリデザインの重要な要素です。

上品に適用すると、UIに明快さと生命の両方をもたらすことができます。

アプリにアニメーションを簡単に追加することは、SwiftUIの開発を始めたとき、私たちの中核的な動機の1つでした。

SwiftUIがそのように形作られている大きな理由です。

このセッションは、SwiftUIの強力なアニメーション機能と、それらがどのように連携して印象的な視覚効果を生み出すかの概要です。

SwiftUIがビューのレンダリングを更新し、Animatableを使用してアニメーション化するものを決定し、アニメーションを使用して時間の経過とともに値を補間し、トランザクションを使用して現在の更新のコンテキストを伝播する方法について説明します。

近年、私の同僚の間で、誰が最高の毛皮を作るか、またはそれほど毛皮ではない仲間を作るかについて議論がありました。

合意に達することができるかどうか気になったので、世論調査を行うためのアプリを作りました。

各ペットに投票するボタンがあります。

タップすると、投票数が変更され、アバターがスライドして現在の順位を反映します。

前回の世論調査では、適切なように、猫が1位になりましたが、狭かっただけです。

この次の投票を純粋に偶然に任せるには賭け金が高すぎるので、新しい機能を追加します。

タップすると、私が選んだアバターは、適切なペットに投票するように人々を後押しするためにスケールアップします。

そして、もう一度タップして縮小することができます。

これはすでにかなりうまく機能していますが、アニメーションの方がずっと良いでしょう。

それを追加する前に、SwiftUIがビューのレンダリングをどのように更新するかをトレースして、ビューの更新の解剖学をよりよく理解します。

この演習では、孤立してペットのアバタービューに焦点を当てます。

SwiftUIは、この選択された状態変数のように、ビューの依存関係を追跡します。

タップのようなイベントが入ってくると、更新トランザクションが開かれます。

依存関係のいずれかが変更された場合、ビューは無効になり、トランザクションの終了時に、フレームワークはレンダリングを更新するために新しい値を生成するためにボディを呼び出します。

このビューの本体は、タップジェスチャー、スケール効果、画像で構成されています。

舞台裏では、SwiftUIは、ビューとそのデータの寿命を管理する長寿命の依存関係グラフを維持しています。

属性と呼ばれるこのグラフの各ノードは、UIのきめ細かい部分にマップされます。

選択した状態がtrueに変更されると、これらのダウンストリーム属性のそれぞれの値が古くなりました。

新しいビュー値を一度に1層ずつラッピングすることで更新されます。

対応するグラフ属性が更新されると、ビューの本文値は破棄されます。

最後に、グラフはあなたに代わって描画コマンドを発行してレンダリングを更新します。

属性の寿命を視覚化するために、グラフだけを拡大します。

属性は初期値で生まれます。

イベントが入り、更新トランザクションが開きます。

上流の依存関係が変わります。

フレームワークはボディを呼び出します。

属性の値が更新されます。

取引は終了します。

このようにして、グラフ内の各属性の現在の値は時間の経過とともに進化します。

だから、それはビューの更新の解剖学です。

では、アニメーションを追加します。

状態変更を中心にアニメーションでラップすると、タップジェスチャーのクロージャが起動すると、トランザクションのアニメーションが設定されます。

次に、選択がトグルされ、下流の属性が無効になります。

以前と同様に、ボディは新しい属性値を提供するために呼び出されます。

そして、これが面白くなるところです。

scaleEffectは特別な属性であり、「animatable属性」です。

Animatable属性の値が変更されると、トランザクションにアニメーションが設定されているかどうかをチェックします。

もしそうなら、コピーを作り、アニメーションを使用して、時間が経つにつれて古い値から新しい値に補間します。

scaleEffect animatable属性を拡大して、これがどのように展開されるかを調べます。

最初に気づくべきことは、アニメーション可能な属性は概念的にモデル値とプレゼンテーション値の両方を持っているということです。

今、彼らは同じです。

その後、イベントが入り、トランザクションが開かれ、今回はアニメーションで開かれます。

状態が変更され、bodyが呼び出されて古い属性値が更新されます。

値が変更されたため、属性はアニメーションのローカルコピーを作り、現在のプレゼンテーション値を計算します。

SwiftUIは、属性グラフに実行中のアニメーションが含まれている場合を知っており、適切なアニメーション可能な属性を呼び込んで次のフレームを生成します。

scaleEffectのような組み込みのアニメーション可能な属性の場合、SwiftUIは非常に効率的です。

ビューコードを呼び出すことなく、メインスレッドからこの作業を行うことができます。

これが動作中のアニメーションです。

いいね。

誰かが「アニメーション」という言葉を使うとき、彼らはおそらくビューが時間の経過とともに変化する方法の全体的な視覚体験を指しているでしょう。

これまでに取り上げたことは、SwiftUIでは、全体的な視覚体験に貢献する2つの直交側面があるということです。

scaleEffectのようなアニメーション可能な属性は、アニメーション化されるデータを決定し、アニメーションはそのデータが時間の経過とともにどのように変化するかを決定します。

アニメーション化するものを決定するAnimatableから始めて、これらのそれぞれを順番に深く掘り下げます。

SwiftUIは、Animatableプロトコルに準拠したすべてのビューのanimatable属性を構築します。

唯一の要件は、ビューがアニメーション化したいデータの読み取り書き込みベクトルを定義することです。

データはVectorArithmeticに準拠している必要があります。

VectorArithmeticは、数学のクラスのベクトルの教科書の定義と一致します。

ベクトル加算とスカラー乗算をサポートしています。

錆びているか、ベクトルに精通していない場合は、落胆しないでください。

ベクトルは基本的に固定長の数字のリストであり、SwiftUIアニメーションの場合、ベクトルを扱う目的は、主にそのリストの長さを抽象化することです。

たとえば、CGFloatとDoubleは1次元ベクトルであり、CGPointとCGSizeは2次元ベクトルを定義し、CGRectは4次元ベクトルを定義します。

ベクトルを扱うことで、SwiftUIは単一の汎用実装でこれらすべてのタイプなどをアニメーション化することができます。

これまでのところ、シンプルにするために、私はスケールエフェクトを1次元スケールファクターであるかのように表現しました。

1次元スケールエフェクトのアニメーション可能な適合性は簡単です。

そのanimatableDataは単なるCGFloatです。

実際には、scaleEffectを使用すると、変換の幅、高さ、および相対的なアンカーポイントを個別に設定できます。

したがって、scaleEffectは実際にアニメーション可能なデータの4次元ベクトル、幅と高さのスケールのCGSizeを定義し、相対アンカーのUnitPointとペアになっています。

AnimatablePairは、2つのベクトルを1つの大きなベクトルに融合させます。

それはパブリックタイプで、あなたも使うことができます。

あなた自身の見解の1つをAnimatableに適合させている場合、それは役に立つかもしれません。

scaleEffectは、SwiftUIに組み込まれている多くのアニメーション可能な視覚効果の1つにすぎないため、ほとんどの場合、Animatableは直接使用する必要があるAPIではありません。

しかし、まれに、高度なユースケースでは、あなた自身の見解の1つをAnimatableに適合させる必要があります。

カスタムRadialLayoutを使用して円の弧に沿ってサブビューを分散するペットのポディウムビューを考えてみましょう。

デフォルトでは、アニメーション内のオフセット角度を変更すると、ペットのアバターが直線に沿って新しい位置にアニメーション化されます。

ペットが近道を取り、円の内部に不法侵入していることに注目してください。

それは私が望んでいることではありません。

代わりに、私のアバターを円の周囲に沿ってアニメーション化したい。

Podiumをアニメーション化可能に適合させ、オフセット角度をアニメーション化可能なデータとして使用することで、この効果を得ることができます。

なぜこれがそのような異なる効果をもたらすのですか?

説明するために、直線に沿ってアバターをアニメーション化するデフォルトの動作から始めて、ポディウムビューの各バージョンのアニメーションアップデートを順を追って説明します。

表彰台の体はRadialLayoutと3つのアバターで構成されています。

トランザクションが開くと、オフセット角度が変更された場合、ボディが呼び出され、古いダウンストリーム属性値が更新されます。

次に、レイアウトが実行され、各サブビューの位置が更新されます。

したがって、これはデフォルトバージョンのアニメーションアップデートのようなものです。

アクティブなアニメーション可能なデータは、カルテシアン座標空間に補間するビュー位置CGPointであり、各アバターが直線に沿って移動することを意味します。

カスタムバージョンでは、PodiumをAnimatableに適合させると、そのボディがアクティブanitable属性になり、オフセット角度をanimatableデータとして変更されます。

その結果、各アバターはどのように円弧に沿って移動しますか?

このカスタムバージョンでは、アニメーションのすべてのフレームに対して、ボディは新しいオフセット角度でSwiftUIによって呼び出され、レイアウトが再実行されます。

これは非常に強力で、時には、カスタムレイアウトや描画コードをアニメーション化しているときのように、それはあなたがしようとしている効果を達成する唯一の方法かもしれません。

カスタムアニメーションの適合性は、アニメーションのすべてのフレームでボディを実行するため、組み込みの効果よりもアニメーションにはるかに高価になる可能性があることに注意してください。

したがって、組み込みエフェクトを使用する効果を達成できない場合にのみ、このツールを使用してください。

次に、アニメーション、時間の経過とともにアニメーション可能なデータを補間する一般的なアルゴリズムについて説明します。

以前、withAnimationで状態の変化をラップして、ペットアバタービューにアニメーションを追加しました。

弾力のあるスプリングのような明示的なアニメーションを渡すことで、これをカスタマイズできます。

SwiftUIには、たくさんの強力なアニメーションが組み込まれています。

それらは大まかに3つのバケットに分類できます。タイミングカーブアニメーション、スプリングアニメーション、および基本アニメーションを変更する高次アニメーションです。

タイミングカーブアニメーションは、おそらくあなたが最もよく知っているアニメーションのカテゴリです。

例えば、easeInOutはタイミングカーブアニメーションです。

すべてのタイミングカーブアニメーションは、アニメーションの速度と持続時間を定義する曲線を取ります。

タイミング曲線は、ベジェ制御ポイントを使用して作成できます。

開始と終了のコントロールポイントを調整することで、アニメーションの初期速度と最終速度を変更します。

UnitCurveタイプは、スタンドアロンを使用して、0から1の間の相対的な点で値と速度を計算できます。

SwiftUIには、リニア、イージーイン、イージーアウト、イージーインアウトなど、多くのタイミングカーブプリセットが組み込まれています。

すべてのタイミングカーブアニメーションは、カスタム期間を指定することもできます。

アニメーションの次のカテゴリであるスプリングは、スプリングシミュレーションを実行して、特定の時点での値を決定します。

質量、剛性、減衰など、スプリングを指定する伝統的な方法に精通しているかもしれません。

しかし、私たちはこれらの方法が特に直感的であることを発見したことがないので、私たちは新しい方法を発明しました。

アニメーションの知覚された持続時間と、スプリングの弾力性を指定するだけです。

それははるかに親しみやすいです。

UnitCurveと同様に、スプリングタイプはスタンドアロンで使用して、特定の時間におけるスプリングの値と速度を計算できます。

SwiftUIには、バウンスのないスムース、少量のバウンス、大量のバウンスを持つバウンシーの3つのスプリングプリセットが組み込まれています。

春のアニメーションをパラメータ化するのが不快な場合、これらのプリセットは、気分の良いものを得るための信頼できる方法です。

各プリセットを調整して、持続時間を調整したり、弾力性を微調整したりすることもできます。

速度を維持し、自然に休むことで、UIに有機的な感触を与えるため、春のアニメーションを使用することを強くお勧めします。

実際、私たちは春のアニメーションの利点について非常に強く感じているので、iOS 17と整列されたリリースで裸のアニメーションを使用すると、スムーズな春を新しいデフォルトにしました。

アニメーションの最後のカテゴリ、より高い順序は、基本アニメーションを変更します。

彼らはそれを遅くしたり、スピードアップしたりすることができます。

基本アニメーションが始まる前に遅延を追加できます。

そして、彼らはベースアニメーションを何回でも繰り返すことができ、オプションでフォワードプレイとリバースプレイの間で切り替えることができます。

そして今、私たちはアニメーションの全く新しいカテゴリを導入しています:カスタムアニメーション。

CustomAnimationプロトコルを使用すると、SwiftUIに組み込まれているすべてのアニメーションを実装するために使用するのと同じ低レベルの汎用エントリポイントにアクセスできます。

CustomAnimationプロトコルには、animate、shouldMerge、速度の3つの要件があります。

アニメーションに焦点を当てることから始めます。

shouldMergeと速度はオプションの要件です。

後で彼らに戻ります。

Animateは、アニメーション化するためのベクトル、アニメーションが始まってから経過した時間、および追加のアニメーション状態を含むコンテキストに渡されます。

Animateはアニメーションの現在の値を返します。アニメーションが終了した場合はnilを返します。

この値ベクトルはどこから来たのですか?

それはビューのアニメーション可能なデータから来ています。

ペットアバタービューでは、それがスケール効果です。

scaleEffectのアニメーション可能なデータは、2次元の幅と高さのスケールを含む4次元ベクトルであることを思い出してください。

アバターを選択すると、1×1のスケールファクターから1.5×1.5のスケールファクターにアニメーション化されます。

ベクトル加算とスカラー乗算操作により、SwiftUIはこれら2つのベクトルを互いに減算して、それらの間のデルタを計算することができます。

このデルタは実際にアニメーション化されているものです。

これは、実際には、scaleEffect animatable属性で実行されているアニメーションは、1から1.5ではなく、0から0.5に補間していることを意味します。

とりわけ、これにより、アニメーションメソッドを実装するのがより便利になります。

お見せしましょう。

補間する期間によって設定された線形タイミング曲線アニメーションを実装します。

アニメーションは、アニメーション化するためにデルタベクトルを渡されたことを思い出してください。

スカラー乗算を使用して、経過した期間の割合でベクトルをスケーリングできます。

そして、完全な期間が経過したら、アニメーションが終了し、削除できることを示すためにnilを返します。

それでおそれ。

そして、この実装は一般的であるため、任意の数の次元のアニメーション可能なデータで動作します。

それが、AnimatableとAnimationが連携して、UIに表示される印象的な視覚効果を生み出す方法です。

次に、CustomAnimationの2つのオプション要件に戻ります：shouldMergeと速度。

それらは何のためですか?

あなたがscaleEffect animatable属性であることを一瞬想像してみてください。

ユーザーがタップダウンし、トランザクションが開き、値が変更され、アニメーションのローカルコピーを作成し、デルタベクトルを喜んでアニメーション化し始めます。

すべてがうまくいっています。

つまり、アニメーションが終了する前に厄介なユーザーが再びタップするまでです。

何をされていますか？

新しいアニメーションを設定し、shouldMergeを呼び出します。

デフォルトの実装はfalseを返します--これはタイミングカーブアニメーションが行うことです--その場合、両方のアニメーションが一緒に実行され、その結果はシステムによって結合されます。

これは、SwiftUIアニメーションがデルタベクトルの観点から扱うもう一つの理由です。

複数のアニメーションが実行されているときに、正しい結合されたプレゼンテーション値を簡単に計算できます。

しかし、タイミングカーブアニメーションではなく、春のアニメーションを選んだらどうなりますか?

春のアニメーションは、trueを返し、以前のアニメーションの状態を組み込むためにshouldMergeをオーバーライドします。

これにより、速度を維持し、タイミング曲線アニメーションのように、付加的に組み合わせるよりも自然に感じることができる新しい値にリターゲットすることができます。

そして、それがこの最終的な速度要件のためのものです。

それを実装すると、実行中のアニメーションが新しいアニメーションとマージされたときにベロシティを維持できます。

そこで、ベロシティの実装を追加して、線形タイミング曲線アニメーションを終了します。

この講演では、UIの特定の更新に対して実行される一連の作業を参照するために、「トランザクション」という用語を使用しました。

SwiftUIコードでは、トランザクションは関連する強力なデータフロー構造とAPIのファミリも指します。

あなたはすでに環境と環境設定に精通しているかもしれません、辞書SwiftUIはそれぞれ暗黙的にビュー階層を上下に渡します。

取引は似ています。

これは、SwiftUIが現在の更新、特にアニメーションのすべてのコンテキストを暗黙的に伝播するために使用する辞書です。

アニメーション可能な属性が現在のアニメーションをどのように読み取るかについての私の以前の説明は少し曖昧でした。

だから、私はアバタービューの別のアニメーションアップデートをトレースするつもりです。

今回は、もっと具体的にします。

タップジェスチャークロージャが起動すると、withAnimationはルートトランザクション辞書にアニメーションを設定します。

ボディは属性値を更新するために呼び出されます。

トランザクション辞書は、属性グラフ全体に伝播されます。

アニメーション可能な属性に達すると、属性はアニメーションが設定されているかどうかをチェックします。

そして、もしそうなら、それはそのプレゼンテーション価値を高めるためにコピーを作ります。

トランザクションは特定の更新にのみ関連しているため、古い属性が更新されると破棄されます。

トランザクション辞書内のビュー階層にアニメーションを流すと、アニメーションがビューにいつ、どのように適用されるかを制御するための多くの強力なAPIが可能になります。

現在、ペットアバタービューはタップでのみ選択できます。

選択した状態変数をバインディングに変更します。

そうすれば、プログラムで選択することもできます。

しかし、ビュープロパティへのプログラマティックな変更をアニメーション化するにはどうすればよいですか?

トランザクション修飾子を使用して、トランザクション辞書内のビュー階層を流れるアニメーションにアクセスできます。

この修飾子内からアニメーションを設定すると、ボディが呼び出されるたびに、トランザクションにアニメーションや別のアニメーションがなくても、属性はアニメーションを上書きします。

そして、スケール効果に達すると、このアニメーションはスケール係数を補間するために使用されます。

かなりかっこいい。

しかし、このパターンには問題があります。

SwiftUIがビューを更新するたびに、すべての子孫のアニメーションを無差別に上書きすると、偶発的なアニメーションにつながる可能性があります。

代わりに、このようなユースケースでは、SwiftUIはアニメーションビュー修飾子を提供します。

追加の値の引数が必要なため、効果をより正確にスコープできます。

値が変更された場合にのみ、トランザクションにアニメーションが書き込まれます。

それが接続されているので、このwithAnimationは何も達成していないので、削除できます。

アニメーションビュー修飾子は、ビューのさまざまな部分に異なるアニメーションを適用したい状況のための強力なツールでもあります。

たとえば、ペットのアバターには影がありますが、シンプルさのために例からこれまで省略しました。

アバターが背景の上に上昇しているという錯覚を強調するためにアバターを選択すると、影の半径が増加します。

遊んだ後、シャドウのアニメーションをスケール効果よりも抑えたいと決めました。

これを達成するために、scaleEffectとシャドウの間に別のアニメーションビュー修飾子を挿入できます。

今、トランザクションはスケール効果をアニメーション化するための弾力のある春を拾います。

そして、影の半径をアニメーション化するために、より微妙な滑らかなスプリングを拾います。

アニメーション修飾子は値が変更された場合にのみアクティブであるため、偶発的なアニメーションの確率は大幅に低下します。

しかし、アバターの画像が選択したのと同じトランザクションでたまたま変更された場合、コンテンツの移行のために影の滑らかな春のアニメーションを継承していたでしょう。

これは長引く価値のあるポイントです。

このアニメーションビュー修飾子は、サブ階層全体が制御下にあるリーフコンポーネントでうまく機能します。

しかし、任意の子コンテンツを含む非リーフコンポーネントの場合、偶発的なアニメーションが発生する可能性がはるかに高くなります。

たとえば、ペットとは関係のない別のアプリでアバターを再利用したい場合は、任意の子コンテンツを受け入れることで、より一般的なものにすることができます。

このシナリオでは、変更を選択したときに、子コンテンツも変更されないという保証はあまりありません。

これにより、偶発的なアニメーションが発生する可能性があります。

おっと。

良いニュースです。

このようなユースケース用に特別に設計されたアニメーションビュー修飾子の新しいバージョンがあります。

アニメーションを、ボディクロージャで指定されたアニメーション可能な属性に絞り込みます。

これがその仕組みです。

トランザクションにアニメーションがないと想像してみてください。

トランザクションがアニメーションビュー修飾子の属性に達すると、指定されたアニメーションが入力されたコピーが作成されます。

コピーは下流に伝播されますが、スコープされたアニメーション可能な属性にのみ伝播されます。

作業が完了すると、コピーは破棄され、元のトランザクションは中断したところから再開されます。

したがって、トランザクションが子コンテンツに到達すると、元のトランザクションは中間アニメーションビュー修飾子の影響を受けないため、偶発的なアニメーションのリスクはありません。

SwiftUIの最初のバージョン以降、限られたトランザクションAPIが利用可能になりました。

現在、カスタムトランザクションキーを定義する機能を導入しているので、トランザクション辞書を活用して、独自の更新固有のデータを暗黙的に伝播することができます。

カスタム環境キーを宣言したことがある場合は、カスタムトランザクションキーを宣言することはよく知られています。

パターンは、TransactionKeyプロトコルに準拠した一意の型を作成することです。

唯一の要件は、defaultValueを提供することです。

次に、キーを使用してトランザクション辞書から読み書きするトランザクションの拡張として計算されたプロパティを宣言します。

ここでは、指定された更新に対して、アバターがタップされたかどうかを追跡するためのブールキーを定義しました。

その価値に基づいて、どのアニメーションを使用するかを決めます。

アバターがインタラクティブに選択された場合は、より活気のあるスプリングを使用してスケールアップまたはスケールダウンします。

しかし、アバターがプログラムで選択された場合は、より落ち着いたスプリングを使用してスケーリングします。

状態変更を中心にwithTransactionをラップすることで、指定された更新のトランザクション辞書で値を設定できます。

これは見覚えがあるはずです。

withAnimationは、withTransactionの薄いラッパーです。

withTransactionに渡される引数は、トランザクションの計算されたプロパティと設定する値へのキーパスです。

トランザクションは、すべての更新の最後に破棄されるため、SwiftUIの暗黙のデータフロー構造の中で一意です。

これは、現在の更新に明示的に設定されない限り、トランザクション辞書のすべての値は、そのキーのデフォルト値に戻ることを意味します。

アバタービューでは、タップジェスチャーのクロージャが起動すると、現在の更新に対してavatarTappedがtrueに設定されます。

トランザクションには、アニメーションキーのデフォルト値（nil）も含まれています。

トランザクションは、トランザクション修飾子に到達するまで、ビュー階層全体に伝播します。

ここでは、アバタービューはavatarTappedを読み取り、その値に基づいて適切なアニメーションを設定します...

これはビュー階層を伝播します。

これはかなりうまく機能しますが、以前と同じように、偶発的なアニメーションが発生する可能性があります。

トランザクションの変更をきめ細かく制御するために、トランザクション修飾子の2つの新しいバリアントを導入しています。

1つは、値引数を使用してスコープすることができます。

もう1つは、ボディクロージャで定義されたサブ階層にスコープすることができます。

これらのバリアントは、先に説明したスコープ付きアニメーションビュー修飾子を反映しています。

このセッションでは、SwiftUIの強力なアニメーションプリミティブ、アニメーション、アニメーション、トランザクションについて説明しました。

次のステップとして、2つの関連セッションをチェックすることをお勧めします。

「Animate with springs」は、アプリで春のアニメーションを効果的に使用する理由と方法について、より多くのガイダンスを提供します。

そして、「SwiftUIで高度なアニメーションを駆け抜ける」は、マルチステップアニメーションを構築するための強力な新しいツールを紹介します。

このコンテンツにより、SwiftUIアニメーションの仕組みをよりよく理解し、アプリでアニメーションをより巧みに活用できることを願っています。

ありがとう。

♪ ♪