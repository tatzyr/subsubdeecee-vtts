10186

♪ ♪

David: こんにちは、「コアデータの新機能」へようこそ。私の名前はDavid Stitesで、Core Dataチームのエンジニアです。

このセッションでは、アプリでCore Dataデータモデルをより迅速かつ簡単に設計、クエリ、更新、移行するのに役立つCore Dataの新技術について学びます。

まず、アプリのモデルで構造化データを整理する素晴らしい新しい方法である複合属性について話してから、最も複雑なモデル移行を「ステージング」して軽量移行を使用できるようにする方法について話し、アプリの応答性を維持するためにモデルの移行を延期する方法で締めくくります。

複合属性は新しいタイプの属性です。

複合属性は、単一の属性内の複雑なカスタムデータ型をカプセル化できます。

各複合属性は、String、Float、Int、Dataなど、すでに慣れ親しんでいる組み込みコアデータタイプの属性で構成されています。

複合属性は互いにネストされる可能性があるため、トップレベルの複合属性には追加の複合属性を含めることができます。

Xcode Core Dataモデルエディタが更新され、モデルの複合属性の定義と管理が容易になりました。

複合属性は、変換可能な型属性を使用して耐久性のあるカスタムデータ型を作成するための魅力的な代替手段です。

属性の値を変換するコードを書く必要はありません。

変換可能な属性とは異なり、複合属性は、複合属性の名前空間キーパスで設定されたNSPredicatesを持つNSFetchRequestsを許可します。

複合属性を使用して、平坦化された属性の増殖をカプセル化し、より保守的で読みやすいコードにつながります。

複合属性は、アプリのパフォーマンスを向上させるために使用できます。

データモデルが、1つのエンティティを取得すると、ほとんどの場合、別のエンティティへの関係にアクセスできるように構成されている場合、その関係を複合属性を使用してリファクタリングできます。

最初のエンティティに複合属性を埋め込む効果は、関係全体のオブジェクトのフォールトを防ぐことです。

複合属性クラスはNSCompositeAttributeDescriptionです。

NSCompositeAttributeDescriptionの属性タイプはNSCompositeAttributeTypeです。

NSCompositeAttributeDescriptionクラスには、NSAttributeDescriptionまたは他のネストされたNSCompositeAttributeDescriptionで構成される配列、要素が含まれています。

要素配列には、NSRelationshipDescriptionなど、他のタイプのプロパティ記述を含めることはできません。

無効な要素を設定しようとすると、NSInvalidArgumentExceptionが発生します。

デモで複合属性を採用する方法を説明します。

航空機エンティティで、この基本的なデータモデルを検討してください。

変換可能なタイプであるcolors属性を含む多くの属性があります。

そのタイプのトランスフォーマーは、航空機の一次色、二次色、三次色を記述するフォーマットされた文字列を格納し、解析します。

航空機のペイントカラーを保存するために、colors属性を複合属性colorSchemeに置き換えることで、このエンティティを改善します。

colorSchemeは、プライマリ、セカンダリ、三次の要素を持つ複合属性で、それぞれが文字列属性です。

Xcodeで、飛行時間を追跡するために使用するアプリであるプロジェクトを開きます。

そのアプリのデータモデルは、先ほど話した航空機エンティティと、他のいくつかのエンティティで構成されています。

変換を開始するには、Core Dataモデルエディタで、colorSchemeという名前の新しい複合属性を追加します。

そのコンポジットの中に、一次、二次、三次の3つの文字列属性を追加します。

航空機エンティティでは、複合属性を追加し、その属性のタイプをcolorSchemeに設定します。

モデルの作業が完了し、コードを更新する時が来ました。

私の航空機の実装では、新しいプロパティ、@NSManaged var colorSchemeを追加しています。そのタイプはStringキーとAnyオブジェクトを持つ辞書です。

コード全体でこの複合属性を使用するため、属性の名前をキーとして辞書表記を使用して値にアクセスしています。

ここでは、プライマリ、セカンダリ、および三次のストリングキーを使用して、航空機のcolorScheme属性を設定しています。

同様に、NSPredicateでNSFetchRequestを設定すると、複合属性の要素は名前空間のキーパスを介してアクセスされます。

ここでは、colorScheme.primaryがその属性をフィルタリングするために使用されます。

アプリケーションが進化するにつれて、データモデルを変更する必要があるかもしれません。

データモデルを更新するには、これらの変更が基礎となるストレージスキーマで具体化される必要があります。

numPassengers属性がモデルに追加された場合は、対応するストレージを更新する必要があります。

スキーマの変更を実行するプロセスは移行と呼ばれます。

移行後、変更は基盤となるストレージに完全に反映されます。

Core Dataには、現在のデータモデルでアプリのデータストレージを最新の状態に保つのに役立つ移行ツールセットが組み込まれています。

総称して、これらのツールは「軽量移行」と呼ばれます。軽量移行の詳細については、WWDC 2022の「アプリのスキーマを進化させる」をご覧ください。

場合によっては、データモデルへの複合変更は、軽量移行の機能を超えています。

この問題の解決策は、段階的な移行です。

段階的な移行APIは、いくつかの目標を念頭に置いて設計されました。不適合の軽量スキーマ変更を持つ複雑なデータモデルを移行し、移行と移行インフラストラクチャに関連する数千行のコードを削除してアプリを簡素化し、移行プロセス中にアプリが実行制御を獲得してさまざまなタスクを実行する機会を提供します。

このAPIを使用するには、いくつかの手順を踏む必要があります。モデルへの変更が軽量移行でサポートされている操作に準拠していないかどうかを判断し、不適合モデル変更を軽量移行でサポートされている一連の適合モデル変更に分解し、新しい段階的な移行APIを使用してNSManagedObjectModelのコアデータへの総順序を説明し、Core Dataに各未処理モデルをシリアルオーダーで反復的にステップするイベント

移行中の特定の時点で、その移行に関連する必要なタスクを実行するために、実行制御がアプリに与えられます。

モデルに不適合の軽量変更がある場合を判断するには、いくつかのオプションがあります。

最初のオプションは、スキーマの変更を手動で確認し、各変更が軽量移行の対象となることを確認することです。

2番目のオプションは、新しいモデルと軽量移行オプション、NSMigratePersistentStores AutomaticallyOptionとNSInferMappingModelAutomaticallyOptionをtrueに設定して永続ストアを開くことです。

変更が軽量適格でない場合、NSPersistentStore IncompatibleVersionHashErrorが表示されます。

最後のオプションは、NSMappingModel.inferredMappingModel(forSourceModel:destinationModel:)を使用することです。

このメソッドは、Core Dataが作成できた場合、推論されたモデルを返します。

それ以外の場合は、nilを返します。

航空機モデルを再度考えると、データをバイナリ形式で保存する新しい属性であるflightDataがあります。

既存のデータとそれが生成された航空機との関係を維持しながら、このモデルを非正規化し、すべての飛行データを独自のエンティティタイプに分離する必要があるとします。

これは非常に複雑なモデル変更であり、それ自体では軽量移行の対象にはなりません。

これらの変更は、段階的な移行を使用するために分解する必要があります。

非軽量の変更を分解する場合、目標は、軽量移行の対象とならない移行タスクを、軽量移行の対象となる最小限の一連の移行に変換することです。

導入された各モデルには、不適合な変更を構成する軽量移行の機能の範囲内にある1つ以上の操作があります。

その結果、各モデルが軽量で移行可能ですが、不適合の移行と同等の一連の移行が発生します。

例に戻ると、元のモデルModelV1にラベルを付けました。

このモデルの移行は、ModelV2とModelV3の2つの新しいモデルバージョンを導入することで分解されます。

ModelV2では、航空機エンティティは、新しく作成されたFlightDataエンティティのコレクションであるflightParametersと呼ばれる関係を取得します。

FlightDataエンティティには、バイナリタイプの属性データと航空機との関係があります。

既存のデータを保存するために、移行段階では、航空機エンティティからデータを新しいFlightDataエンティティにコピーし、航空機に関連付けます。

私たちの最終モデルは、ModelV2から作成されたModelV3です。

ModelV3では、古いflightData属性が航空機エンティティから削除され、モデルが正常に非正規化され、既存のデータがすべて保存されます。

説明されている各ステップは、軽量移行の機能の範囲内です。

モデルの総順序を記述するために、Core Dataフレームワークレベルのサポートは、NSStagedMigrationManager、NSCustomMigrationStage、NSLightweightMigrationStage、およびNSManagedObjectModelReferenceのクラスで構成されています。

NSStagedMigrationManagerクラスは、NSCustomMigrationStageとあなたが説明した補足NSLightweightMigrationStageの合計順序をカプセル化します。

段階的な移行マネージャーはまた、移行イベントループを管理し、NSPersistentContainerを介して移行ストアへのアクセスを提供します。

マネージャーは、キーNSPersistentStoreStagedMigrationManager OptionKeyを使用してストアオプションに追加されます。

移行段階は、モデルのバージョン間で移行するための基礎を形成します。

段階的な移行を採用すると、NSCustomMigrationStageまたはNSLightweightMigrationStageのいずれかを使用して、各モデルバージョンをコアデータに記述します。

NSLightweightMigrationStageクラスは、分解を必要とせず、軽量移行の対象となる一連のモデルについて説明しています。

これはおそらくあなたのモデルの大半になるでしょう。

これらの軽量移行段階は、コアデータに記述されたモデルの総順序を補完するために使用されます。

すべての軽量モデルバージョンは、1つ以上のNSLightweightMigrationStageで表現する必要があります。

作成したモデルの分解された各バージョンは、NSCustomMigrationStageを使用して表現され、ソースモデル参照と宛先モデル参照が含まれます。

NSCustomMigrationStageは、移行段階の直前と直後に実行されるオプションのハンドラを提供します。

これらのハンドラを使用すると、移行プロセス中にカスタムコードを実行できます。

段階的な移行は、NSManagedObjectModelReferenceクラスを利用します。

このクラスは、NSManagedObjectModelの約束を表します。

移行中、コアデータはこの約束を果たします。

NSManagedObjectModelReferenceは柔軟性があり、さまざまな方法で作成できます。

すべてのNSManagedObjectModelReferenceは、バージョンチェックサムで初期化する必要があります。

これは、モデルが誤って変更されていないことを検証するためのものです。

チェックサムは、NSManagedObjectModel .versionChecksumメソッドを使用して取得できます。

または、「データモデルのコンパイル」の下にあるXcodeビルドログからバージョンのチェックサムを取得することもできます。「バージョンチェックサム」という文字列を検索します。バージョン管理されたモデルの場合、チェックサムはNSManagedObjectModelバンドルのVersionInfo.plistでも利用できます。

例に戻ると、段階的な移行の使用を開始するには、3つのモデルのそれぞれにモデル参照を作成することから始めます。

モデル名とバンドル参照を受け入れるイニシャライザを使用していますが、他のオプションもあります。

次のステップは、必要な移行段階を説明することです。

最初のステージではflightData属性のみが追加されたので、属性の追加は軽量な変更であるため、軽量ステージで表現できます。

ただし、モデルの変更が2つのモデルバージョンに分解され、既存のデータを保存するためにカスタムコードを実行する必要があるため、次の段階はカスタム段階になります。

カスタム移行ステージは、ModelV2とModelV3で初期化されます。

willMigrateHandlerでは、コードはflightDataがnilではないエンティティ行を取得します。

移行中に航空機クラスが期待どおりに存在しない可能性があるため、航空機管理オブジェクトサブクラスの代わりに、一般的なNSManagedObjectおよびNSFetchRequestResultタイプが使用されています。

フェッチされた航空機エンティティごとに、データはFlightDataの新しいインスタンスにコピーされ、2つのエンティティは関連付けられ、永続化されます。

この移行段階の実行終了時に、ストアスキーマが最新のモデルに更新され、既存のデータが保存されます。

段階的な移行を完了するには、軽量移行ステージとカスタム移行ステージを備えたNSStagedMigrationManagerを作成します。

NSStagedMigrationManagerは、キーNSPersistentStore StagedMigrationManagerOptionKeyを使用してNSPersistentStoreDescriptionオプションに追加されます。

その後、永続ストアがロードされ、移行プロセスが開始され、ストアスキーマに影響します。

そして、それだけです。

コアデータは自動的に必要なステージを適用し、ストアスキーマを移行します。

一部の軽量移行では、アプリがフォアグラウンドで提供できない可能性のある追加のランタイムが必要です。

軽量移行中にユーザーデータを変換するプロセスは瞬間的ではありません。

たとえば、移行に、ある列から別の列へのデータのコピー、またはあるテーブルから別のテーブルへのデータのコピーが含まれる場合、時間がかかる場合があります。

これは、特に移行が起動時に行われる場合、イライラするユーザーエクスペリエンスをもたらす可能性があります。

遅延移行は、この問題を解決するのに役立ちます。

このAPIを使用すると、軽量移行中に行われた作業の一部を延期することができ、後日延期された作業を終了することができます。

軽量移行中、エンティティにインデックスの更新やテーブルコピーを実行した後に列をドロップするなど、クリーンアップが必要な移行変換がある場合、リソースがテーブル変換を実行できると判断されるまで、このテーブル変換が遅れる可能性があります。

軽量移行はまだ同期しており、正常に行われます。

スキーマのクリーンアップのみが延期されます。

あなたのアプリは通常通り最新のスキーマを使用します。

遅延移行を選択するには、ストアオプションのNSPersistentStore DeferredLightweightMigrationOptionKeyをtrueに設定します。

延期された移行APIは、macOS Big SurとiOS 14にまでさかのぼってランタイム互換性があります。

遅延移行は、SQLiteストアタイプでのみ利用可能です。

延期された移行が役立つ場合の例には、エンティティから属性または関係の削除、エンティティ階層がもはや存在しない関係の変更、順序付きから順序なしへの関係の変更などがあります。

延期された移行タスクを完了するには、永続的なストアのメタデータを確認してください。

キーNSPersistentStore DeferredLightweightMigrationOptionKeyが含まれている場合、それは完了する必要がある遅延移行作業があるというシグナルです。

遅延移行は、NSPersistentStoreCoordinator .finishDeferredLightweightMigrationを呼び出すことで処理できます。

アプリの軽量移行を延期するには、永続ストアをコーディネーターに追加するときに、ストアオプションでNSPersistentStoreDeferred LightweightMigrationOptionKeyをtrueに設定します。

延期された移行を完了するのに良い時期になったら、ストアのメタデータをチェックして、保留中の延期された作業があるかどうかを確認できます。

NSPersistentStoreDeferredLightweight MigrationOptionKey が true に設定されている場合は、finishDeferredLightweightMigration() を呼び出します。

延期された移行タスクをスケジュールするには、バックグラウンドタスクAPIの使用を検討してください。

BGProcessingTaskは、長いデータ更新やアプリのメンテナンスなど、時間のかかる操作を目的としています。

システムは、タスクを実行するのに最適な時間を決定します。

ただし、通常、処理タスクはデバイスがアイドル状態のときにのみ実行され、ユーザーがデバイスの使用を開始するとバックグラウンド処理タスクが終了します。

延期された移行と段階的な移行を組み合わせることができます。

時間がかかる可能性のある一連の複雑な移行がある場合は、両方のAPI機能を利用するステージの設計を検討してください。

ModelV3のサンプルモデルに戻ると、属性flightDataを削除すると、これは良い遅延移行候補になるかもしれません。

コアデータには3つの素晴らしい新技術があります。

複合属性を使用してネスト可能な構造化された方法でカスタムデータ型をカプセル化し、モデル変更を分解して段階的な移行を使用して複雑なモデル移行を実行し、遅延移行を使用していくつかの移行作業を遅らせることでアプリのパフォーマンスをターボチャージします。

3つの技術はすべて、アプリを改善するために調和して機能します。

私たちのチームは、あなたがこれらの新技術をどのように使用しているかを聞いて興奮しています。

見てくれてありがとう、そして素晴らしいWWDCをお過ごしください。

♪ ♪