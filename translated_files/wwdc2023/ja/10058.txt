10058

♪ ♪

ジェームズ:こんにちは。私はUIKitのJames Magahernです。テキストとテキストのインタラクションに関する新機能のガイドになります。

テキストはすべてのアプリケーションで重要な役割を果たします。

これは、情報を消費し、コミュニケーションをとるための主要な方法です。

今、私たちは、ゼロから始めるか、高レベルの抽象化から始めるかにかかわらず、アプリで強力なテキスト体験を作成するためのさらに多くのツールを提供しています。

システム選択UIへのいくつかの変更、UITextViewsへのテキストアイテムアクションとメニューの追加、TextKit 2のリストと箇条書き、macOSのディクテーションUI、国際化のためのいくつかの重要なアップデートなど、テキストエクスペリエンスの作成とアプリでそれらを活用する方法に関する多くの大きな改善について説明します。

まず、選択UIのいくつかの変更について話します。

すべてのプラットフォームで新しくなったのは、完全に再設計されたテキストカーソルです。

入力言語を変更するときにインラインでインタラクティブなスイッチャーを表示し、範囲選択を行うときにより人間工学に基づいた選択ハンドルを表示し、大きなテキストにカーソルを簡単に配置できるように、まったく新しいルーペもあります。

アプリがUITextViewsまたはUITextFieldsを使用している場合は、この新しいUIがすべて自動的に取得されます。

さらに、UITextInteractionのクライアントも新しい選択UIを取得することを確認しました。

ただし、テキストを表示するための高度にカスタマイズされたUIがある場合、特にUITextInteractionを採用できない場合は、独自の実装でこれらの変更に追いつくのは難しい場合があります。

そのため、iOS 17では、UITextInteractionに含まれるジェスチャーなしで選択UIを提供するUITextSelectionDisplayInteractionを追加しました。

UITextSelectionDisplayInteractionは、任意のUIViewにインストールできる新しいタイプのUIInteractionです。

また、ビューから選択状態を取得するためのインタラクションのさまざまなメソッドを定義するUITextInputプロトコルを実装するオブジェクトも提供する必要があります。

UITextSelectionDisplayInteractionは、カーソルビューとカーソルアクセサリー、および範囲のハイライトと選択ハンドルを提供し、すべての重い作業を行います。

これらのビューはすべて交換可能なので、必要に応じて動作をカスタマイズできます。

ここでは、コードでこれを行う方法の例を簡単に見てみましょう。

まず、選択表示インタラクションを作成し、UITextInputプロトコルを実装するドキュメントオブジェクトを提供します。

該当する場合、これはあなたの見解と同じにすることができます。

次に、内部に選択UIを表示するビューにインタラクションを追加するだけです。

これは、コンテナビューでも、ドキュメントをレンダリングするビューでもかまです。

選択状態が変更されるたびに、インタラクションでsetNeedsSelectionUpdateを呼び出すだけで、インタラクションは新しい選択状態を反映するようにすべてのビューを更新します。

UITextSelectionDisplayInteractionに加えて、ルーペを表示するための新しいAPIも追加しました。

どのビューでも使用でき、UITextSelectionDisplayInteractionまたはUITextInputを使用する必要はありません。

ルーペの更新を推進するには、UIPanGestureRecognizerなどのジェスチャーリコグナイザを使用することをお勧めします。

ルーペセッションをコードで管理する方法は次のとおりです。

パンジェスチャーリコグナイザを使用する場合は、コールバックで、ジェスチャーの場所と選択ウィジェット、この場合はカーソルビューをつかみます。

次に、ジェスチャーが開始されている場合は、 begin(at:) を呼び出して新しい UITextLoupeSession を作成し、ルーペの開始場所、選択ウィジェット、および座標空間を提供します。

次に、ジェスチャーが移動したら、既存のルーペセッションでmove(to:)を呼び出すと、その場所を更新します。

最後に、ジェスチャーリコグナイザが終了したら、ルーペセッションで無効を呼び出すようにしてください。

次に、テキストアイテムのアクションと、それらを使用してテキストビュー内のメニューを表示する方法について説明します。

UITextViewのテキストアイテムのインタラクションは、UITextViewDelegateの新しいAPIを使用して、はるかにカスタマイズ可能になりました。

これらの新しい追加により、テキスト項目のプライマリアクションを変更したり、翻訳アプリでここに表示されている候補メニューのようなメニューを表示したりすることができます。

以前は、UITextViewでは、開発者はリンクと添付ファイルのUITextViewDelegateのshouldInteractWith APIを介してアイテムインタラクションを無効にすることができます。

iOS 17では、テキストビューのテキストアイテムのアイテムインタラクションをカスタマイズできるようになりました。

UITextViewDelegateは、プライマリアクションの両方をカスタマイズしたり、特定のテキスト項目のメニューを提供したりする新しいメソッドを獲得しました。

ここでは、テキストアイテムが実際に何であり、それらがアプリとどのように統合されるかを簡単に確認します。

テキストアイテムは、アイテムのインタラクションをサポートするコンテンツを表します。

これには、NSTextAttachmentで表されるテキスト添付ファイルと、NSLinkAttributeNameで表されるリンクが含まれます。

UITextItemは、インタラクションのためのテキストのカスタム範囲のタグ付けもサポートするようになりました。

インタラクションの範囲にタグを付けるには、インタラクティブにしたいテキストの範囲を表す属性文字列にUITextItemTagAttributeNameを使用します。

これらの新しいAPIを使用すると、テキスト項目が操作されているときのデフォルトのタップまたはメニューの動作を変更できるようになりました。

たとえば、既知のリンクをアプリ内の既存のビューにリダイレクトしたり、テキストの一部にカスタムメニューを追加したりできます。

プライマリアクションまたはメニューを抑制または無効にし続けるには、menuConfigurationまたはprimaryActionデリゲートメソッドのnilを返すだけです。

これは、ユーザーがUITextView内のリンクをタップしたことに応じてメニューを表示する方法を示す小さなコード例です。

UITextViewDelegateからmenuConfigurationFor:defaultMenu:メソッドを実装し、表示したいメニューを含むメニュー設定を返すだけです。

メニュー設定の一部としてプレビューを提供して、コンテキストメニューの残りの部分とインラインで表示することもできます。

リストと箇条書きのサポートもTextKit 2に追加されました。

アプリケーションでこれを利用する方法について説明します。 

複数の異なる種類の箇条書きアイテムをサポートすることに加えて、ローマ数字、アルファベット順、小数順もサポートされています。

それぞれは、デバイスまたはアプリの設定されたロケールに基づいて自動的にローカライズされるため、世界的な国際化が組み込まれています。

以下は、属性文字列を使用してテキストリストを使い始める方法の簡単な例です。

NSParagraphStyleのtextListsプロパティを使用して、どの段落に順序付きリストが適用されているかを定義します。

システムは、改行などの行終端文字に基づいてアイテムに自動的に番号を付け、UITextViewは入力属性に基づいて段落スタイルを自動的に伝播します。

macOS Sonomaでのディクテーションの仕組みにはいくつかの大きな変化があります。

カスタムテキスト要素が新しいデザインでうまく機能することを確認するのに役立つ新しいAPIがいくつかあります。

これは、新しいディクテーションインジケーターがmacOS 14でどのように動作するかです。

iOSと同様に、ディクテーションは話している間に後続のグロー効果があり、静止時にはマイクインジケーターが表示されます。

スクロール後、カーソルの横にあるインジケーターがスクロールビューの端にくっつき、ドキュメントの現在の位置に戻るボタンを提供することに注意してください。

NSTextViewのようなAppKitで標準のテキストコントロールを使用している場合、この動作は箱から出してすぐに得るでしょう。

アプリが挿入ポイントを表示するためのカスタマイズされた実装を提供している場合、この新しい動作をサポートするために少し作業する必要があります。

iOS用のUITextSelectionDisplayInteractionと同様に、システムの選択UIとの一貫性を保つことができるmacOS用の新しいAPIがあります。

独自のカーソルを描画する代わりに、ドキュメントのビュー内に配置してカーソルの位置を示すことができるカスタマイズ可能なNSViewサブクラスであるNSTextInsertionIndicatorを採用してください。

その外観はカスタマイズ可能です。

色とサイズを変更できます。

デフォルトでは、現在のアクセントカラーに従います。

ディクテーション効果のサポートが本当に簡単になります。

システムが適切なビューを階層に挿入できるようにするには、ほんの少しの設定が必要です。

macOSでNSTextInsertionIndicatorを使い始める方法は次のとおりです。

NSTextInsertionIndicatorビューを作成し、ドキュメントの内容を表示しているビューにサブビューとして追加するだけです。

完了したら、effectsViewInserterを、システムが提供するビューをドキュメントのビュー階層に挿入するブロックに設定します。

システムは自動的にエフェクトビューを配置し、挿入インジケーターが移動するにつれて更新されるようにします。

カスタムテキストビューがレスポンダーステータスを辞任するときは、displayModeを非表示に設定してカーソルを非表示にしてください。

テキストが挿入されると、ディクテーションが入力ソースとして使用されている場合、フレームの更新は自動的にグロー効果でアニメーション化されます。

グロー効果を無効にする必要がある場合は、automaticModeOptionsからshowEffectsViewオプションを削除してください。

ユーザーが入力モードを変更すると、効果ビューが水平テキストでカーソルの下に表示され、言語選択UIが表示されます。

このUIの配置を上書きする必要がある場合は、NSTextInputClientの実装でpreferredTextAccessoryPlacementを指定できます。

システムは、このプロパティの値をチェックして、アクセサリを描画する場所を決定します。

ディクテーション中にテキストカーソルが画面外にスクロールされると、システムにはスクロールアウェイインジケーターも表示され、カーソルの相対的な位置を示し、ディクテーションポイントに戻るためのアフォーダンスを提供します。

この動作がカスタムテキストビューでサポートされていることを確認するには、NSTextInputClientを採用し、selectionRectとdocumentVisibleRectプロパティを実装してください。

textInputClientWillStartScrollingOrZoomingとwillEndScrollingOrZoomingを呼び出して、スクロールの開始と終了についてシステムに通知します。

アプリがすべての言語でうまく機能することを確認することは、優れたテキスト体験を提供するために不可欠です。

標準のテキストコントロールにいくつかの重要な変更を加え、より幅広い言語で読みやすさと人間工学を強化しました。

アプリのダイナミックタイプをサポートすることは、すべての言語でUIのレイアウトを改善するのに大いに役立ちます。

アプリでテキスト要素をレイアウトする際に考慮すべき重要なことは、レイアウト方向やフォントスタイルに加えて、多くの言語が可変行の高さを持つことができるという事実です。

言語間の可変行の高さを扱うときに発生する一般的な問題は、クリップされたテキストの問題です。

これは見た目が悪いだけでなく、読みやすさに大きな影響を与え、アプリの全体的なユーザーエクスペリエンスを著しく妨げる可能性があります。

これらの問題は、特にすべての言語でアプリをテストできない場合は、気づくのが難しいかもしれません。

ほとんどの場合、この問題に自動的に対処するために、UITextFieldやUILabelなどの標準テキスト要素にいくつかの改善を加えました。

ただし、システムがこれらの要素のクリッピングを防ぐことができることを確認するために、確実に従うべきベストプラクティスがいくつかあります。

これらの一般的なクリッピングの問題を防ぐために、すべてのプラットフォームは、非常にダイナミックな行の高さを持つ言語に対応するために、UILabelまたはUITextFieldの行の高さを自動的に調整します。

この新しい動作は、特定の場合にのみ行われます。

まず、線の高さは、デバイスが設定した優先言語に依存することを覚えておいてください。

第二に、この調整はユーザーインターフェイス全体に影響し、英語などの固定行の高さのスクリプトを表示するものでも、すべてのテキスト要素の行の高さが増加し、通常は余分なスペースを必要としません。

これは、すべてのテキスト要素にわたって視覚的な一貫性を確保するために意図的です。

最後に、この自動調整は、テキストスタイルを使用するテキスト要素にのみ適用されます。

カスタムフォントは、固定行の高さを引き続き使用します。

この動作は、いくつかのリリースで有効になっているため、まったく新しいものではありません。

しかし、iOS 17でははるかにダイナミックで、正確な調整はテキストスタイルと使用される言語の両方に依存します。

この動作を利用するには、preferredFont(forTextStyle:)メソッドでUIFontを明示的に作成し、UILabelのようなテキスト要素に割り当てることでテキストスタイルを採用します。

次に、テキスト要素にclipsToBoundsを設定しないでください。

タイ語やヒンディー語などの言語のアセンダとディセンダーは、しばしばラインの高さの境界を越えて突き出ます。

これは通常、隣接する要素の周りに余分なスペースがあるため、ほとんどのレイアウトで一般的に許容されますが、clipsToBoundsを設定すると、それらのテキスト要素がクリップされることを意味します。

UIKitは、以前にデフォルトで有効になっていたこの設定の不要な使用を防ぐためにも更新されました。

最後に、テキスト要素が垂直に成長できるようになったため、UIが高さの変化に反応し、他のすべてのコントロールが整列したままであることを確認してください。

また、中国語、ドイツ語、日本語、韓国語などの言語の改行行動を大幅に強化しました。

これらの改善は、UIで使用しているテキストスタイルの種類と表示されている言語に基づいて、異なるルールを適用します。

たとえば、以前は、韓国語のテキスト内の単語が行間で分割されていた可能性があります。

これで、UIKitはタイトルテキストスタイルの分割を防ぎ、よりシームレスな読書体験を保証します。

アプリでこの新しい動作の恩恵を受けるには、同様にテキストスタイルを採用してください。

iOS 17のアプリで強力なテキスト体験を作成するために知っておくべきことはすべてです。

アプリでカスタムテキストビューを使用している場合は、システム選択UIを使用して、OSのすべての新機能を活用してください。

テキストアイテムを使用して、テキストビュー内のリンクとのより良いインタラクションを作成します。

TextKit 2の強力な新機能を活用して、より豊かなテキスト編集体験を提供します。

また、一般的なテキスト要素にテキストスタイルを採用して、言語や優先テキストサイズに関係なく、すべての人に優れたユーザーエクスペリエンスを提供します。

今のところはこれで全部です。

見てくれてありがとう。

必ず5つ星を評価し、下にコメントを残してください。

♪ ♪