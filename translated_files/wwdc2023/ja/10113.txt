10113

♪まろやかなインストゥルメンタルヒップホップ♪

♪

こんにちは、私の名前はマークで、SwiftUIのエンジニアです。

SwiftUIを使って、飛行機から宇宙への旅にあなたを招待できることを嬉しく思います。

SwiftUIが新しい次元でどのように機能するかを実証し、SwiftUIとRealityKitがシステムでどのように連携して信じられないほどの体験を可能にするかを示すために、Worldと呼ばれる私たちが構築したサンプルアプリに電力を供給する一握りのAPIについて話します。

世界は、使い慣れたウィンドウから新しいボリュームまで、アプリケーションがシステムで取ることができるいくつかの異なるフォームを示し、制限された3D体験とフルスペースを可能にし、無制限の仮想コンテンツの表示を可能にします。

このトークで議論するAPIのほとんどは、主に2Dウィンドウアプリに3Dのダッシュを追加するか、フルスペースを活用して没入型の3Dエクスペリエンスを作成するかにかかわらず、ボリュームをコンテナとして使用することに焦点を当てます。これは、アプリでSwiftUIを使用して3Dの領域を探索する素晴らしい方法を提供するからです。

SwiftUIコンテンツの他のコンテナの詳細については、「空間コンピューティングのためにウィンドウアプリを昇格する」トークと「SwiftUIでウィンドウを超えて」トークを参照してください。

ボリュームの基本をカバーしたら、ボリュームビューとレイアウトで3Dコンテンツを作成して配置する方法、SwiftUIビューを新しいRealityViewに統合する方法、そして最後に3Dジェスチャーですべてをまとめる方法について説明します。

しかし、私たちが自分自身を先取りしすぎる前に、ボリュームが何であるか、そしてそれらが3Dの領域への第一歩を踏み出すのにどのように役立つかについて話しましょう。

世界はボリュームを使用して3Dコンテンツを強調しています。

このシーンにはメインのガラス窓がありません。

代わりに、3Dコンテンツをシーンに直接配置し、前面にコントロールパネルを配置します。

しかし、3Dコンテンツはここでのショーのスターです。

ボリュームは固定スケールのコンテナを提供します。

あなたから配置された距離に基づいて動的にスケーリングするウィンドウとは異なり、ボリュームはどの距離でも同じサイズを維持します。

ボリュームは水平に整列されており、あらゆる角度からの視聴をサポートします。

ボリュームは、スペース全体を引き継ぐことなく、アプリに3Dコンテンツを表示するのに最適な方法であり、作成は非常に簡単です。

ウィンドウグループなどの新しいシーンを作成するときに、新しい体積ウィンドウスタイルを使用するだけで、これらすべての機能が自動的に取得されます。

ボリュームを設定したので、その中にコンテンツを入れましょう。

それを支援するために、RealityKitはModel3Dと呼ばれる新しいAPIを提供しています。これは、USDZなどの豊富な3Dアセットを簡単にロードできるSwiftUIビューであり、アセットの読み込みライフサイクルのさまざまな部分を処理するフェーズを提供します。

Model3DはAsyncImageのカウンターパートと考えてください。

アプリをスムーズに実行しながら、複雑なジオメトリをロードするすべての作業を処理します。

Model3Dを使って、ワールドアプリの他のモデルの1つである月を表示しましょう。

今、私はすでに私のプロジェクトにmoon USDZファイルを追加し、その名前をModel3Dイニシャライザに渡すことができます。

これで、モデルのフェーズを処理できます。

さて、これは月の位相ではありません。

実際には資産のロードステータスを示しており、切り替えることができるいくつかの異なる状態があります。

モデルが読み込まれる前に、コンテンツがまだ準備ができていないことをユーザーに示すテキストまたは別のUIを表示できます。

ここで進行状況ビューを使用します。

モデルの読み込みに失敗した場合、エラーのローカライズされた説明を使用してエラーメッセージを表示できます。

そして、モデルが成功すれば、私のUIでそれを使用することができます。

画像と同様に、サイズ変更可能な修飾子を使用して、モデルが利用可能なスペースに応じてサイズ変更できることをレイアウトシステムに伝える必要があります。

そして、モデルを利用可能なスペースに収めたいので、scaledToFit修飾子を使用します。

今、私のアプリに非同期に読み込まれる月があります。

SwiftUIでより多くの3D機能を探求するために、この例に基づいて構築し続けましょう。

Worldアプリに登場する他のモデルのいくつかを調べてみましょう。

私はそれらをすべて一度に一種のディスプレイで見せたい。

USDZファイルの表示を処理するために書いたばかりのMoonViewを再利用することができます。

名前を変更しましょう。

そして、読み込むためにUSDZファイルの名前を渡します。

これで、ハードコードされたムーンストリングを置き換えることができます。

では、天体を表すデータ構造を作りましょう。

それぞれに名前とサイズを付けます。

私のプロジェクトにあるいくつかの異なるオブジェクトをリストアップします：地球、月、太陽。

これで、ForEachでHStackに各オブジェクトを表示できます。

オブジェクトごとに、オブジェクトの名前を使用して作成した新しいCelestialObjectViewを使用できます。

オブジェクトサイズを使用してフレーム修飾子を使用して、各モデルのサイズを変更しましょう。

私たちのモデルは正面から見ると素晴らしく見えますが、私たちは3Dであることを覚えておいてください。

視点の変化は、私たちのオブジェクトが後ろ向きに整列していることを明らかにし、まるでバウンディングボックスが3つすべての背後にある平面にフラッシュされているかのように。

これは、SwiftUIの3Dコンテンツのデフォルトのアライメントです。

それを変更したい場合は、このようにフレーム深度修飾子で使用する深度アライメントを指定できます。

深さに使用するオブジェクトのサイズを渡し、モデルの前面を背面ではなく整列するように指定できます。

今では、すべてのビューが代わりに前面を揃えています。

今、私は各オブジェクトにラベルを付けたい。

各Model3Dにオーバーレイを与えることで、それを行うことができます。

内部では、常に読みやすいように、ガラスの背景効果でテキストラベルを作ります。

また、これらのラベルをモデルの下部に揃えるようにするので、コンテンツをブロックしません。

ディスプレイは今のところ素晴らしく見えますが、少し静的な感じがします。

最後に、ジオメトリ効果へのSwiftUIの新しい追加のいくつかを探りましょう。

TimelineViewを使用して、時間の変更をアニメーション化できます。

今、私は新しいRotation3DEffectを使用して私たちのビューにいくつかのスピンを与えます。

私は1つを作り、スケールファクターで現在の日付に基づいて角度を与えます。

そして、オブジェクトをy軸の周りを回転させます。

そして、ちょうどそのように、私たちはオブジェクトを回転させています。

Model3Dは、ビュー階層に単純なアセットをロードして表示するのに最適です。

しかし、より複雑な3Dモデル、シーン、または経験のために、RealityViewはアプリでRealityKitの力を解き放つSwiftUIのエントリーポイントです。

そして実際、WorldアプリはRealityViewを使用して、RealityKit Entity-Componentシステムを使用して、より複雑な視覚化を分解します。

これにより、個々のモデルや、照明や軌道パスなどの高度なレンダリング効果をレンダリングできます。

新しいRealityViewのおかげで、SwiftUIとRealityKitはプラットフォーム上で密接に関連しています。

RealityViewとRealityKitの新しい機能の詳細については、「RealityKitで空間体験を構築する」と「RealityKitで空間コンピューティングアプリを強化する」を参照してください。

とりあえず、新しい添付ファイルAPIを使用して、RealityView内のSwiftUIを最大限に活用する方法について話しましょう。

添付ファイルを使用すると、タグ付きSwiftUIビューをRealityView内で使用できるエンティティとペアリングできます。

添付ファイルは、注釈を追加したり、特定のエンティティに関連するアフォーダンスを編集したりするのに最適です。

SwiftUIでCanvas APIを使用したことがあるなら、添付ファイルはおそらく身近に感じるでしょう。

添付ファイルとの主な違いは、スナップショットだけでなく、ライブビューであることです。

これは、状態の変更に応答し、アニメーションを実行し、ジェスチャーを処理できることを意味します。

世界中の私のお気に入りの場所を追跡するいくつかのマーカーを配置できる追加機能を追加して、ワールドアプリ内の添付ファイルを探索しましょう。

地球ビューでは、私のお気に入りの場所の配列を追跡する州を作成し、それぞれに名前と場所があります。

場所ごとに、その名前のテキストを作成できます。

そして、私はそれが常に読みやすいようにガラスの背景効果を与えることができます。

そして今、後でRealityViewで参照できるようにタグを付けます。

このタグは任意のハッシュ可能な値にすることができますが、各場所に追加した一意の識別子を使用します。

これで、私が指定したタグを使用して、各添付ファイルビューをホストするエンティティを検索できます。

このエンティティをRealityViewコンテンツに追加できます。

そして、lookAt関数を使用して、地球の表面に沿ってラベルを配置し、方向付けすることができます。

私たちは今、いくつかの興味深い場所を特定しました。

しかし、まだこのアプリにあまり執着しないようにしましょう。

それを次のレベルに引き上げる方法について、もう少しアイデアがあります。

だから、今、私たちは3Dコンテンツを配置し、添付ファイルを使用してRealityView内でSwiftUIを最大限に活用する方法を知っています。

それでは、このすべてのコンテンツと対話する方法について話しましょう。

このプラットフォームは、あなたがすでに慣れ親しんでいるジェスチャーを、手と目をサポートし、新しいトラックパッドの仕組みを備えた3次元にもたらします。

これらの新機能を使って、ワールドアプリの進捗状況を拡張しましょう。

私たちは「お気に入りの場所」の拡張機能でかなり良いことをしています。

しかし、私たちが計画した場所の数に満足していないと思います。

地球上のタップジェスチャーを使って、もう少し追加する方法を作りましょう。

しかし、それに飛び込む前に、入力用にエンティティを設定する方法について話しましょう。

RealityViewをコンテンツで設定しているとしましょう。

ここに私はすでに地球のモデルを追加しました。 

エンティティ階層には、RealityView内で入力を受信するためにInputTargetComponentが必要です。

コンポーネントがエンティティに追加されている場合、特に指定がない限り、そのエンティティのすべての子孫も入力を受け取ることができます。

RealityKitでは、CollisionComponentはエンティティのインタラクティブ領域の形状を定義するために使用されます。

地球モデルに球体を使用して、その表面に正確な相互作用点を取得しましょう。

これは、エンティティがRealityView内でSwiftUIジェスチャーを処理できるようにするために必要なすべてです。

この時点で、RealityViewにSpatialTapGestureを追加できます。

しかし、RealityKitのコンテンツでSwiftUIジェスチャーをさらに簡単に使用できるように、特にearthEntityをターゲットにするために使用できるtargetedToEntityという新しいジェスチャー修飾子を追加しました。

このエンティティまたはその子孫の1つでタップが発生しない場合、ジェスチャーは失敗します。

では、ジェスチャー値を処理しましょう。

SpatialTapGestureには新しいlocation3Dプロパティがあり、地球の表面に正確なタップポイントを取得できます。

3Dの場所は、RealityViewのローカルSwiftUI座標空間にあり、メートルではありません。

新しいラベルを配置する場所を把握するには、その場所をRealityViewのシーンに変換する必要があります。

targetedToEntity修飾子は、ジェスチャーの値自体にいくつかの座標空間変換ヘルパーを追加することで、これを非常に簡単にします。

それを使用して、SwiftUIローカル空間からシーンの座標空間に変換できます。

最後に、先ほど計算した場所を使用して、新しい場所のデータを追加できます。

また、ラベルが地球の表面の少し上に浮かぶように、場所を少しだけ拡大します。

私たちは今、タップするだけで、より多くのお気に入りの場所を地球に追加する方法があります。

しかし、今、私たちは問題を抱えています:私たちはより多くの場所を発見する必要があります!

これを行うには、世界中のよりエキサイティングなスポットを選ぶのに役立つ衛星を打ち上げましょう。

地球に衛星モデルを追加する1つの方法は、RealityKitを使用してモデルをロードすることですが、私たちが学んだ他のテクニックのいくつかを使ってみましょう。

Model3Dを添付ファイルとして追加できます。

フレームを指定すると、衛星モデルのサイズを合理的なサイズに簡単に変更できます。

また、RealityViewで参照できるように、モデルにタグを付けます。

ラベルと同じように、RealityViewにモデルを追加する必要があります。

それでは、衛星のスケール、回転、ポジショニングを定義できる3D変換を返すジェスチャーを定義しましょう。

DragGestureを使ってドラッグすることから始めます。

ドラッグジェスチャーから変換するには、マップを使用します。

DragGestureには、3Dで操作を処理するためのいくつかの新しいプロパティがあります。

DragGestureの新しいtranslation3Dプロパティを使用して、開始してからドラッグがどれだけ移動したかを取得できます。

今、私は変換を作成します。

翻訳を初期化子に渡して、地図から返すことができます。

今、私はちょうど私の衛星を変換するために書いた私たちの操作ジェスチャーを使用することができます。

更新修飾子を使用して、ジェスチャーがアクティブな時期を追跡します。

この状態を使用して、相互作用中にすべてのラベルを縮小して、地球の視界を遮らないようにすることができます。

ジェスチャーが失敗した場合、私のジェスチャー状態が自動的にリセットされることを保証するので、私が持っている一時的なジェスチャー状態を追跡するために更新を使用することが重要です。

ジェスチャー値が変更されたら、状態の新しい変換を設定し、オフセット修飾子を使用して衛星モデルを配置できます。

また、春のアニメーションを使用して変換の変更をアニメーション化して、衛星を手放すと元の場所に戻します。

今、私たちは衛星をドラッグすることができます。

これは素晴らしいスタートですが、これをもっと詳しく見る必要があります。

すべてが接続されたので、スケーリングアクションを追加しましょう。

このために、ドラッグと同時に認識するMagnifyGestureを追加します。

また、ユーザーの手の制約のない3D回転を測定できる新しいRoateGesture3Dも追加します。

これらの新しい値を変換に接続し、最後にエンティティの回転とスケールを更新する必要があります。

これにはrotation3DEffectとscaleEffectを使用します。

そして、私たちはそれを持っています!

衛星エンティティを自由にドラッグ、スケーリング、回転できるようになりました。

私たちの衛星は航海の準備ができているように見えます。

私たちが追加したジェスチャーは、手との直接的な相互作用、間接的なピンチ、トラックパッド、アクセシビリティ機能など、あなたが期待するすべての入力デバイスとモードで動作します。

使い慣れたSwiftUIジェスチャーと、新しいターゲットToEntity修飾子を使用すると、複雑なエンティティ階層内でインタラクションをすばやく構築できます。

私たちは今、私たちの衛星で地球を探索する準備ができていますが、今、あなたのアプリでSwiftUIの新しい3D機能を探索する時が来ました。

ボリュームやフルスペースなどの新しいシーンタイプでは、アプリケーションがまったく新しい方法で何になるかを検討できます。

SwiftUIの強力なレイアウトとレンダリングシステムは、SwiftUIをiOS、macOS、tvOS、watchOSだけでなく、このまったく新しいプラットフォームでアプリを構築する強力な方法にするために拡張されました。

新しい添付ファイルAPIは、SwiftUIビューを3Dシーンに統合する素晴らしい新しい機会を開きます。

そして最後に、SwiftUIでおなじみの強力なジェスチャーを使用して、人々に伝える物語を手のひらにまとめる方法を模索しました。

SwiftUIとRealityKitのおかげで、2D飛行機の境界を越えてエキサイティングな旅をすることができます。

そして、私たちはまだ始まったばかりです。

プラットフォームへようこそ!

♪