10124

♪ ♪

こんにちは、ようこそ。

私はAppleのGPU、グラフィックス、ディスプレイソフトウェアグループのエンジニアであるVarun Subramanianです。

このセッションは、ハイエンドゲームをMacに持ち込むための3部構成のシリーズの第2部です。

最初のセッションでは、ゲームを評価し、「ゲームプランを作成する」方法について説明します。

このセッションでは、シェーダーと、シェーダーをMetal中間表現に変換する新しい方法や、ゲームのビルド時間中にGPUバイナリを確定してデバイス上のコンパイルを回避する方法など、新しいMetalコンパイラツールのいくつかを使用して柔軟性と速度を向上させる方法に焦点を当てます。

メタルコンパイラツールチェーンは、ゲームを強化するシェーダーをコンパイルするのに役立ち、メタルはそれをこれまで以上に簡単にします。

デバイス上のMetal IRの作成は、GPUが必要な作業を行う前にコンパイルオーバーヘッドを追加するため、最適ではありません。

Metalは、事前にMetal Shading LanguageからMetal IRを生成するために必要なツールを提供します。

その金属IRは金属ライブラリの一部として保存されています。

事前にMetalコンパイラツールチェーンを使用して、常にMetalライブラリを生成することを目指す必要があります。

ただし、別のAPIとシェーディング言語から来る場合は、それらをMetalに取得する方法が必要です。

Macに新しく来た人なら、メタルシェーダーコンバーターがあります。

これにより、シェーダーパイプラインが簡素化され、生成されたMetalライブラリをバンドルに直接パッケージ化できるため、デバイス上のMetal IRの生成を回避できます。

生成されたMetalライブラリは、Metalコンパイラから生成されたものと同じで、変換されたシェーダーをMetal APIとネイティブに統合できます。

新しいツールを使用して、既存のシェーダーをMetalライブラリに変換し、ゲームに同梱します。

Metal Shader Converterは、シェーダーをMetalに変換するエクスペリエンスを向上させるための堅牢な機能セットを提供します。

金属IRを生産するためにDXILを消費します。

オープンソースのDXCコンパイラツールと一緒に使用して、エンドツーエンドのシェーダーパイプラインを構築します。

メタルシェーダーコンバータがバイナリレベルで変換を実行するため、DXILからメタルIRへの変換は非常に高速です。

その結果、シェーダーアセットのビルド時間が短縮されます。

また、Apple GPUの高度な機能を活用することもできます。

既存のDXILシェーダーのすべての伝統的および現代的なシェーダーステージをサポートするメタルシェーダーコンバータの豊富な機能セットのためにこれを行うことができます。

メタルシェーダーコンバーターを使用すると、テッセレーションやジオメトリシェーダーを含む従来のグラフィックパイプラインのシェーダーをメタルライブラリに変換できます。

また、コンピューティングシェーダーだけでなく、最近導入されたレイトレーシングステージとシェーダー、増幅とメッシュシェーダーもサポートしています。

では、メタルシェーダーコンバーターの使い方を説明します。

コマンドラインでシェーダーを変換したいシナリオは2つあります。

ターミナル経由でコマンドラインツールを使用することは、一度に1つのシェーダーを変換する良いメカニズムです。

複数のシェーダーがある場合は、メタルシェーダーコンバータを呼び出して複数のシェーダーを自動的に変換するシェルスクリプトを作成できます。

コマンドラインツールを使用してシェーダーを変換するのはとても簡単です。

DXCとシェーダーコンバータを設定したら、HLSLシェーダーをDXILにコンパイルすることから始めます。

DXCでは、コンパイルするエントリポイント、シェーダーのタイプ、および出力ファイルを指定する必要があります。

次に、作成したDXILファイルでシェーダーコンバータを呼び出し、作成する出力Metalライブラリを指定します。

デフォルトでは、シェーダーコンバーターは最新バージョンのmacOS用のMetalライブラリと、便利な反射データを含むJSONファイルを生成します。

実行時に、このMetalライブラリをMetalデバイスに渡してロードし、パイプライン状態オブジェクトを構築します。

コマンドラインインターフェイスがワークフローにとって最良の選択ではないかもしれない他の2つのシナリオがあります。

一部のゲームエンジンには、シェーダーをコンパイルしてゲーム固有の形式にパッケージ化するカスタムアセットビルドプログラムがあります。

また、状況によっては、Metalのゲームをブートストラップする際に、事前にMetalライブラリに完全に転換する前に、シェーダーがプラットフォームでどれだけうまく機能しているかを確認したいと思うかもしれません。

これらの最後の2つのケースでは、メタルシェーダーコンバータをワークフローによりよく統合する方法が必要です。

これを実現するには、メタルシェーダーコンバータのダイナミックライブラリを使用します。

CLIツールと同じ機能をすべて公開し、Metalライブラリの生成を支援します。

ライブラリは純粋なCインターフェイスを提供し、CLIと同様に、macOSとWindowsの両方で利用できるため、既存のワークフローに簡単に統合できます。

シェーダーをMetal IRに変換した後、それらをゲームに統合するために、パイプライン状態を作成し、リソースをそれらにバインドします。

シェーダーでは、通常、リソースをグローバル変数として定義し、それらに「登録」宣言を割り当てます。

API側から、ゲームはリソースをこれらのスロットに直接バインドするか、「ルートシグネチャ」を介して明示的なメモリレイアウトを定義します。

メタルは非常に柔軟なバインディングモデルを持っているので、シェーダーコンバータは、このモデルを持ち込むのに役立ちます。

このツールは、これらのリソースを引数バッファにレイアウトします。

このモデルでは、1つの引数バッファをパイプラインに直接バインドし、それを介してリソースを参照します。

この「トップレベル」の引数バッファには、ゲームに最も合うように選択できる2つのレイアウトモードがあります。

作成できる最も簡単なレイアウトは、シェーダーコンバーターがリソースを次々に配置する自動レイアウトです。

シェーダーを含むパイプライン状態を作成したら、単一の引数バッファをバインドし、それを介してすべてのリソースを参照します。

あるいは、シェーダーコンバーターは、ルート署名に一致するレイアウトを明示的に定義することをサポートします。

ゲームが別々のテクスチャとサンプラーを独自のリソーステーブルに指定する必要がある場合、またはゲームがバインドレスリソースを使用する場合は、このモードを使用します。

また、生のバッファと32ビット定数を、この図で0と1として表示されているトップレベルの引数バッファに直接埋め込むこともできます。

現在、トップレベルの引数バッファは、CPUとGPUの間で共有されるリソースであるため、書き込み中に、視覚的な破損を引き起こす可能性のある競合状態を避けるために、メモリへのアクセスを調整する必要があります。

この競合状態を避けるために、CPUとGPUの作業をシリアル化する必要はありません。

これを回避する1つの方法は、バンプアロケータを使用することです。

これは、フレームごとに異なるリソースをサブ割り当てする大きなメタルバッファーにすることができます。

次に、ゲームが処理する飛行中の各フレームのバッキングバッファをシャドウイングします。

バンプアロケータの実装の詳細については、サンプルコードをご覧ください。

最良の引数バッファ管理プラクティスについては、昨年のバインドレスセッションとMetalドキュメントをチェックしてください。

バインディングモデルは、メタルシェーダーコンバーターがシェーダーをMacに持ち込むのに役立つ唯一の場所ではありません。

特定のシェーダーステージのマッピングは、グラフィックAPIの違いにより難しい場合があります。

たとえば、従来のジオメトリとテッセレーションステージを活用するパイプラインがあるかもしれません。

Metalは最新のAPIであり、他のグラフィックスAPIからの古くて効率の低いステージを不要にするビューポートIDや増幅などの機能を提供します。

しかし、あなたのゲームがこの画像でレンダリングされた草のようないくつかの表面を強化する伝統的な効果のためにこれらのパイプラインに依存している場合、それらを手で変換することはコストがかかります。

メタルシェーダーコンバータは、モダンでより効率的なグラフィックAPI構造であるメッシュシェーダーにマッピングすることで、これらのパイプラインをメタルに持ち込むのに役立ちます。

このツールは、各ステージをMetal IR表現にマッピングすることで、これらの複雑なパイプラインを簡単にMetalに持ち込むために重い作業を行います。

これには、伝統的に固定機能操作であるテッセレーターが含まれます。

このワークフローをサポートするために、今年Metalは目に見える機能をメッシュシェーダーの「オブジェクトとメッシュ」ステージにリンクする機能を追加します。

シェーダーをコンパイルしたら、それらを使用して「Metal Mesh RenderPipeline Descriptor」を構築し、「Metal Render Pipeline状態」にコンパイルします。

Metalは、このパイプライン状態を構築する要求を受信すると、すべてのMetal IRをコンパイルしてリンクし、すべての機能を単一のパイプラインに焼き込み、関数呼び出しのオーバーヘッドを完全に回避し、実行時のパフォーマンスを最大化します。

補足機能でこれらのシェーディングステージを含むこの精巧なレンダリングパイプラインを構築できるMetal可視機能のパワーと柔軟性に注目してください。

これらのメッシュパイプラインの構築は簡単ですが、すべてのパイプラインは正確な順序で一連の手順に従わなければなりません。

シェーダーコンバータのランタイムは、これらの複雑なパイプラインを構築するのに役立ちます。

メッシュシェーディング作業をディスパッチすることで、ドローコールをエミュレートします。

詳細については、Metal Shader Converterのドキュメントを参照してください。

シェーダーがMetal上にあり、パイプラインの状態を実行している今、優れたパフォーマンスと視覚的な正確性を得るのに役立つヒントをいくつか紹介します。

シェーダーコンバータ参照金属リソース間接的にコンパイルされたシェーダー。

リソースレジデンシーをMetalにフラグを付けるには、「useResource」と呼びます。

ただし、useResourceは、過剰に使用すると高価な通話です。

複数のuseResourcesを使用して、一度に複数のリソースを提供するか、useHeapを介してMetalヒープを使用して、1回の呼び出しで複数のリソースのレジデンシーにフラグを付けることを検討してください。

パイプラインオブジェクトは、Metalが初めてコンパイルしたときにキャッシュされ、ゲームのその後の実行時にコンパイルベースのヒッチングが自動的に減少します。

バイナリアーカイブもここであなたを助けることができます。

GPUをさらに得、より高いパフォーマンスのためにMetal IRをカスタマイズするために、シェーダーコンバータはオプションを提供します。

互換性、GPUファミリ、頂点フェッチ動作、エントリポイントの命名、反射などのカスタマイズがあります。

ここに1つの追加の最適化の機会があります。

先ほど、シェーダーコンバータは、既存のシェーダーIRから「メタルライブラリ」を生成する別のメカニズムとしてメタルコンパイラに参加すると述べました。

金属はこれらを使用して、さまざまなグラフィックパイプラインのステージを供給します。

すべてがメタルIRであるため、メタルシェーダーコンバータとメタルコンパイラからの「メタルライブラリ」を1つのアプリ、さらには1つのパイプラインで組み合わせることができます。

メタルシェーディング言語では、プログラム可能なブレンドなどのユニークな機能にもアクセスできます。

このアプローチを使用して、AppleのGPUを最大限に活用してください。

タイルシェーディングなどのユニークなシェーディング機能を利用することもできます。

これにより、ゲームをメタルに持ち込む方法に大きな柔軟性が得られます。

パフォーマンスは重要ですが、ゲームの視覚的な正確性が最も重要です。

HLSLを使用すると、テクスチャを1つの要素の配列としてシームレスに処理できます。

この動作に依存するシェーダーを持ち込むには、テクスチャをテクスチャ配列として作成するか、テクスチャに「テクスチャ配列ビュー」を作成します。

「MetalKit Texture Loader」を使用している場合は、ファイルをテクスチャ配列として読み込むのにも役立ちます。

サンプラーオブジェクトを設定し、これらのテクスチャから読み取るには、MTLサンプラー記述子のプロパティsupportsArgumentBuffersを使用して、引数バッファでサンプラーを参照する予定であることを事前にMetalに知らせてください。

ワークフローでのシェーダーコンバーターの統合に精通したので、入手方法は次のとおりです。

メタルシェーダーコンバーターはdeveloper.apple.comからダウンロードできます。

Macで作業している場合は、Macパッケージ用のメタルシェーダーコンバーターを入手してください。

Windowsで作業している場合は、Metal Developer Tools for Windowsパッケージの一部です。

このツールのベータ版は現在入手可能です。

どちらのパッケージにも、スタンドアロンおよびライブラリ形式のメタルシェーダーコンバータと、ランタイムコンパニオンヘッダーが含まれています。

完全なドキュメントとMetal C++コードのサンプルが利用可能になりました。

サンプルコードを使用して、ジオメトリとテッセレーションエミュレーション、インスタンスドローイング、およびコンピューティングシェーダーを探索します。

シェーダーをゲームに同梱するメタルライブラリに変換すると、ゲームランタイムでこれらのライブラリの生成を避けることができます。

実行できる追加の最適化が1つあります。それは、GPUバイナリを事前にコンパイルすることです。

ゲームを構築するときは、シェーダーをMetalライブラリにコンパイルし、まだGPUバイナリにファイナライズする必要があります。

通常、あなたのゲームは起動時にこれを行うため、読み込み画面が長くなります。

実行時にGPUバイナリの完成を延期すると、ゲームがオンデマンドで新しいパイプラインをコンパイルするため、フレームがドロップされる可能性があります。

Metal GPUバイナリコンパイラは、ゲームビルド時にシェーダーバイナリを生成できるようにすることで、これを解決するのに役立ちます。

ゲームプレイ中にシェーダーバイナリを生成する必要性を取り除くことで、プレイヤーは追加のGPUヒッチが発生することなく、アプリの読み込み時間を短縮することで利益を得ることができます。

これを利用するには、ワークフローに別のステップを追加して、ビルド時にMetalライブラリをMetalバイナリアーカイブに完成させることができます。

デバイス上のGPUバイナリコンパイルは、記述子からパイプライン状態を作成するときに発生します。

この記述子は、Metalライブラリから関数を参照するだけでなく、レンダリング添付ファイルの色形式や頂点レイアウト記述子など、Metalに他の重要な情報も提供します。

GPUバイナリは、PSO作成の一部としてちょうど間リーに生成されます。

バイナリアーカイブを使用すると、そのコンパイルがいつ行われるかを制御できます。

GPUバイナリを事前に作成するには、既存のメタルライブラリと、それらのライブラリを参照するパイプライン構成スクリプトの両方を提供します。

次に、両方をmetal-ttに提供し、GPUバイナリでバイナリアーカイブを生成します。

パイプラインスクリプトを開発するには、Metal APIに似たパイプライン構成のJSONスクリプトを作成します。

このMetalコードは、レンダリングパイプライン記述子を生成し、そのJSONと同等の表現です。

パイプラインスクリプトには、Metalライブラリパスとそのフラグメントと頂点関数名を追加します。

また、他のパイプライン状態の設定も指定します。

それでおそれ、あなたは今、あなたが使用できるメタルスクリプトを持っています。

JSONスキーマに関する追加情報は、Metalの開発者ドキュメントで見つけることができます。

事前のシェーダーコンパイルワークフローは、パイプラインスクリプトファイルを生成するように調整されていない可能性があります。

これらのケースでは、それらを生産する別の方法があります。

デバイスでゲームを実行している間、メタルバイナリアーカイブを記録できます。

これらのアーカイブには、対応するパイプラインスクリプトが含まれています。

デバイスからこれらのアーカイブを収集する場合は、「メタルソース」を使用して、埋め込まれたパイプラインスクリプトを抽出できます。

次に、抽出されたスクリプトでMetalライブラリへのパスを更新します。

詳細については、「GPUバイナリの構築」と「コンパイルワークフローの発見」に関する講演を参照してください。

GPUバイナリは各GPUに合わせて調整されているため、「metal-tt」は、デバイスに基づいてプレイヤーに配布するための異なるバージョンのバイナリを生成します。

Metal-ttは、すべての異なるGPUバイナリをMetalバイナリアーカイブにきれいにカプセル化することで、この複雑さを管理するのに役立ちます。

このようにして、アプリがそのバイナリアーカイブをロードすると、Metalは自動的にプレイヤーに適したバイナリを選択します。

複数のバイナリセットを1つのバイナリアーカイブにカプセル化することもできます。

バイナリアーカイブを事前に作成できるようになったので、ここにいくつかのベストプラクティスがあります。

プレイヤーが事前にコンパイルされたGPUバイナリでMetalアプリを実行すると、Metalはパッケージ化されたバイナリアーカイブで必要なGPUバイナリを検索します。

メタルがアーカイブで一致しない場合、自動的にデバイス上のコンパイルにフォールバックします。

アプリはまだ正しく見えますが、GPUへの提出が遅れる可能性があります。

「FailOnBinaryArchiveMiss」オプションを使用して、バイナリアーカイブに期待するパイプラインが含まれているかどうかをテストできます。

Metalパイプライン状態オブジェクトを作成するときに、FailOnBinaryArchiveMissオプションを簡単に指定できます。

バイナリアーカイブミスの場合、このオプションを設定すると、Metalはデバイス上のコンパイルをスキップし、nilパイプライン状態を返します。

バイナリアーカイブがすべてのターゲットデバイスをサポートする準備ができたら、展開の準備が整いました。

すべてのプレイヤーが最新のOSを使用しているわけではありません。

すべてのユーザーがバイナリアーカイブの恩恵を受けるように、主要なOSバージョンごとにアーカイブを生成し、アプリに保存します。

これを達成するには、プレイヤーのデバイスのOSバージョンを確認し、パイプライン記述子に関連付ける適切なバイナリアーカイブを選択します。

プレイヤーがOSを更新すると、バイナリアーカイブは前方互換性のために再コンパイルが必要になる場合がありますが、Metalはあなたをカバーしています。

Metalは、プレイヤーのデバイス上のアプリバンドル内のパッケージ化されていないバイナリアーカイブを識別し、OSの更新またはゲームのインストール後にバックグラウンドで自動的にアップグレードします。

要約すると、「メタル」コンパイラと「メタルシェーダーコンバーター」は、ゲームと一緒に出荷できるメタルライブラリを事前に作成するための頼りになるツールです。

MSLソースをコンパイルするときは「metal compiler」を使用し、シェーダーがHLSLにあるときは「metal-shaderconverter」を使用します。

metal-ttを使用すると、MetalエコシステムのさまざまなGPUに合わせたMetalライブラリをGPUバイナリにファイナライズできます。

最後に、金属ソースは、既存のMacOSゲームからパイプラインスクリプトを収穫するのに役立ちます。

これらのツールの大部分は、残りのGPUバイナリコンパイラツールチェーンと同様に、macOSに加えてWindowsをサポートしているため、既存のワークフローにこれまで以上に簡単に統合できます。

まとめ：Metal Shader Converterは、別のシェーディング言語で開発されたシェーダーをMetalに持ち込むのに役立つ新しいツールです。

Windowsで利用可能になったGPUバイナリコンパイラとそのツールチェーンは、MetalライブラリをGPUバイナリに仕上げることができます。

これらのツールを使用すると、シェーダーをメタルに持ち込むために必要なものがすべて揃っています。

あなたと共有することはまだたくさんあります。

シリーズのパート3は、ハイエンドの金属アプリケーションの最適化に焦点を当てています。

必ずチェックしてください。

見てくれてありがとう。

♪ ♪