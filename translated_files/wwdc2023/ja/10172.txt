10172

♪ ♪

ゾーイ：こんにちは、私はアップルのコンパイラチームのエンジニア、ゾーイです。

今日は、SwiftとC++を一緒に使用できるXcode 15の新機能であるSwiftとC++の相互運用性を紹介します。

この講演は2つの部分に分かれます。

まず、相互運用性の基本を説明します。

次に、SwiftでC++ APIを自然で安全に感じさせる方法を紹介します。

Swiftは、Objective-Cで書かれた多くの大きなアプリやコードベースがある世界に参入しました。

Swiftがこの既存のコードを活用し、これらのコードベースに段階的に採用することが不可欠でした。

今日、Swiftはこの相互運用性を次のレベルに引き上げ、さらに多くの場所でSwiftを採用することができます。

大規模なC ++コードベースをお持ちの場合は、双方向の相互運用性を利用してSwiftを段階的に採用できるようになりました。

また、アプリのC++ライブラリにアクセスする必要がある場合は、Objective-Cブリッジングレイヤーを書く必要がなくなります。

サンプルアプリを見て、C++コードベースにSwiftを採用するのがどれほど簡単か見てみましょう。

私は写真編集アプリに取り組んでいます。

カメラロールから写真を選択したり、色を反転させたり、明るさを変更したりできます。

コードに入る前に、私のアプリの構造を見てみましょう。

アプリは、画像処理フレームワークとユーザーインターフェイスコードの2つの部分に分けることができます。

私のアプリが基づいている画像処理フレームワークは、C++で書かれています。

ユーザーインターフェイスレイヤーがC ++フレームワークと簡単に通信できるようにしたかったので、Objective-C ++を使用して、ViewControllerなどのユーザーインターフェイスのほとんどを実装しました。

今、私のアプリのユーザーがカメラロールから数枚の写真を選んで編集できるようにしたい。

SwiftUIにはこれを簡単にする新しいPhotoPickerビューがあると聞いたので、アプリでSwiftの採用を始めたいと思います。

幸いなことに、Xcode 15から始めて、Objective-C++コードベースにSwiftを簡単に採用でき、すべてのC ++ APIにアクセスできます。

では、プロジェクトにSwiftファイルを追加することから始めましょう。

C++フレームワークを使用しているため、XcodeはC++ APIを自動的にインポートするので、ブリッジングヘッダーは必要ありません。

次に、プロジェクトのビルド設定でC++の相互運用性を有効にする必要があります。

ご存知のように、SwiftはすでにCおよびObjective-C APIを呼び出すことができるため、ビルド設定は現在CおよびObjective-Cモードに設定されています。

しかし、私はこれをC++に変更することができます。

設定がC++とObjective-C++を読み取るようになったので、C++イメージキットフレームワークからAPIを直接呼び出すことができます。

Swiftファイルに戻ると、他のSwiftモジュールと同じようにフレームワークをインポートでき、コマンドでモジュール名をクリックしてその内容を表示できます。

さて、これらはSwift APIのように見えるかもしれませんが、実際には私のC ++ ImageKitライブラリからのものです。これはSwiftコンパイラがそれらを見る方法です。

今日使用するAPIをいくつか見てみましょう。 いくつか見てみましょう。

下部から、CxxImageEngineタイプの静的メンバーが表示されます。

これは現在、安全でないポインタとしてインポートされていますが、後で詳しく説明します。

CxxImageEngineには、loadImageとgetImagesという他のメンバーがいくつかあり、すぐに使用します。

今、私は先に進み、C ++と話す2つの方法に集中できるように、私のフォトピッカーのすべてのUIをドロップします。

共有されたCxxImageEngineをつかみ、選択した各画像のloadImageを呼び出すと、エンジンに読み込むことができます。

うわー、SwiftでC++メソッドを呼び出すのはとても簡単です。

SwiftUIビューが完成したので、Objective-C++ ViewControllerで使いたいです。

これを行うには、Objective-C++コードからアクセスできるように、構造体を公開する必要があります。

すごい！私のSwiftコードはすべて正常に構築されました。

これで、ViewControllerファイルに移動して、Swiftが生成したヘッダーをインポートできます。

このヘッダーには、私のすべてのパブリックSwift APIが含まれています。

生成されたヘッダーをインポートしたので、C++でSwiftコードを呼び出すことができます。

まず、SwiftUIビューを構築します。

その後、現在のメソッドを呼び出すことができます。

そして、Xcodeはコードの完成に役立ちます。

これをデバイス上でテストしましょう。

アプリを構築して実行した後、Objective-C++アプリに直接インポートされた新しいSwiftUIビューを見ることができます。

これは、真の双方向の相互運用性の例でした。

私はSwiftでC++の型と関数をシームレスに使用することができ、その逆も同様でした。

C++では、ビューの本体がC++フレームワークに呼び戻されるSwiftUIビューを構築して使用することができました。

すべての統合はSwiftコンパイラによって自動的に行われたので、ブリッジングレイヤーを書く必要はありませんでした。

そして、すべてのAPIは直接的でネイティブだったので、相互運用する他のほとんどの言語とは異なり、Swiftまたはその逆でC ++ APIを呼び出すときにオーバーヘッドはありません。

今日はかなり小さなアプリで作業していますが、Swiftコンパイラは大規模で複雑なコードベースでの相互運用性をサポートできます。

Swiftは、標準ライブラリと他の場所の両方から、ほとんどのC++コレクションをインポートできます。

Swiftは、関数テンプレートとクラステンプレートの専門分野を処理できます。

また、共有ポインタや同様のユーザー定義型を使用してメモリの管理をサポートしています。

Swiftは、これらのインポートされたAPIを高いレベルで理解できます。

たとえば、共有ポインタの保持およびリリース操作について知っており、この高レベルの知識を使用して一連の強力な最適化を適用できます。

他の方向では、構造体、クラス、そのメソッド、その他のメンバーなど、ほとんどのSwift APIをC++に公開することができます。

時間の経過とともに進化する配列や回復力のあるタイプなどのジェネリックタイプを公開することもできます。

また、C++の相互運用性はXcodeで完全にサポートされているため、両方の言語でコード補完、定義へのジャンプ、デバッガのサポートを受けることができます。

これらは、C++の相互運用性でサポートされているAPIのほんの一部です。

Swiftコンパイラは、これらすべてのAPIなどを使用する大規模なコードベース間の相互運用性をサポートし、言語間でまとまりのある体験を促進し、さらに多くの場所でSwiftを採用できるようにします。

相互運用性の基本を網羅したので、この機能について詳しく掘り下げ、SwiftでC ++ APIを自然で安全に感じさせる方法をいくつか探りましょう。

Swiftコンパイラは、ほとんどのC++ APIを自動的にインポートし、安全なSwift APIとして表現することができます。

たとえば、デフォルトでは、C ++タイプはSwift構造体としてインポートされ、C ++演算子は同様のSwift演算子にマッピングされ、コンテナは自動的にコレクションとしてインポートされます。

しかし、コンパイラでは、APIのインポート方法を微調整し、さらに自然に感じるAPIを公開することもできます。

アノテーションを使用して、APIに関する詳細情報をコンパイラに提供することで、これを行うことができます。

たとえば、関数やメソッドは、Swiftでは自然に感じられないC++の命名規則を使用するかもしれません。

このような場合、アノテーションを使用して、インポートされた関数の名前を変更したり、引数ラベルを追加したり、ゲッターとセッターを計算されたプロパティとしてインポートしたりできます。

注釈は、参照セマンティクスなどの高レベルのパターンを説明し、いくつかのタイプをSwiftクラスとしてインポートするのにも役立ちます。

または、実際に問題ないのにAPIが安全ではないと思われる場合は、Swiftを修正してください。

これらの注釈は、SwiftがインポートしているAPIに関する情報を伝える強力な方法です。

サンプルアプリで使用しているいくつかの異なるAPIを特定し、これらの注釈を使用して、Swiftが安全で直感的に感じる方法でAPIをインポートする方法を探りましょう。

フォトピッカーが完成したので、編集した写真をフォトライブラリに保存するための保存ボタンも追加したいです。

Swiftに戻ると、インポートしたすべてのAPIをもう一度見ることができます。

まず、保存する写真を集める必要があります。 保存する必要があります。

そして、私はgetImages関数を使ってそれを行うことができます。

getImages関数はC++ベクトルを返します。

このメソッドを呼び出す前に、ベクトルがSwiftでどのように動作するかの詳細を理解しましょう。

Swiftタイプは、値タイプと参照タイプの2つのカテゴリに分類されます。

Swiftでは、構造体は値型を表し、クラスは参照型を表します。

デフォルトでは、C++タイプはSwiftで値タイプとしてインポートされます。

したがって、SwiftはSwift構造体のように振る舞う値型としてベクトルをインポートします。

ベクトルと他のSwift構造体の唯一の違いは、Swiftがコピーコンストラクタなどのタイプの特別なメンバーを使用してライフタイムを管理することです。

これらのコピーコンストラクタは、多くの場合、ディープコピーを実行します。

したがって、変更されたときにのみコピーされるSwift配列とは異なり、Swiftがベクトルをコピーすると、すべての要素がコピーされます。

画像のベクトルがわかったので、フォアループでベクトルを反復して各画像を取得し、画像をuiImageに戻し、画像をフォトライブラリに保存することができます。

このforループは、ベクトルには開始メソッドと終了メソッドがあるため、Swiftは自動的にコレクションとしてインポートします。

このコレクションへの自動適合により、ベクトルをSwift配列に簡単に変換でき、マップやフィルターなどのメソッドにアクセスできます。

安全のために、Swiftの安全モデルに適合しないC++イテレータAPIではなく、これらのSwift Collection APIを使用することが重要です。

これらのC ++イテレータを使用すると、生涯の問題や無効なメモリアクセスなどのバグを簡単に導入できます。

一方、SwiftコレクションAPIは、C++コレクションで動作する場合でも、完全に安全です。

Swiftコンパイラは、安全でないC++ APIを利用できないとマークし、より安全な代替案を提案することで、これらのより安全なAPIに向けてあなたを導くのに役立ちます。

私のSwiftアプリに戻りましょう。

私を悩ませている何かがあります。 

C++ImageEngineを使用するたびに、それが安全でないポインタであることを思い出します。

実際、このタイプは常にSwiftとC++の両方でポインタとして使用されます。

これは、このタイプが「参照セマンティクス」と呼ばれるものを持っているためです。

これは、タイプがオブジェクトアイデンティティを持つことを意図していることを意味し、コピーは個別の値ではなく、同じメモリへの参照を共有します。

前に述べたように、Swiftタイプは値タイプと参照タイプの2つのカテゴリに分類されます。

Objective-Cはまた、値型と参照型を明確に区別できるため、Objective-C型を構造体やクラスに簡単にマッピングできます。

C ++の場合、SwiftやObjective-Cとは異なり、C ++は値型と参照型の間に強い区別がないため、どの型がどのカテゴリに分類されるかは明らかではありません。

したがって、デフォルトでは、コンパイラはすべてを値型としてインポートします。

しかし、Swiftは、C++コードに注釈を追加することで、参照型またはクラス型としていくつかのものをインポートするオプションも提供します。

そのため、SWIFT_SHARED_REFERENCE属性を使用して、CxxImageEngineをSwiftクラスにマッピングできます。

この属性は、Swiftが型が常にポインタまたは参照として渡されることを強制し、Swiftの安全でないポインタではなく、単に型でこの間接を表すことを意味します。

コードを安全にするために、Swiftは必要に応じて参照を保持および解放することで、参照の寿命を自動的に管理します。

この種の参照カウントを有効にするには、これらの保持機能とリリース機能の両方をSwiftに提供する必要があります。

C++ ImageKitヘッダーを掘り下げてみましょう。

SWIFT_SHARED_REFERENCEのような注釈にアクセスするためにswift/bridgingをインポートできます。

これで、Swiftが呼び出すことができる保持関数とリリース関数の両方を指定して、この注釈をタイプに適用できます。

すごい！

今、私がもはやポインタを逆参照する必要がないことを私に伝えているいくつかのSwiftコンパイラエラーがあります。

このC++ APIをSwiftでくつろげるために、最後にできることが1つあります。

ここfor-loopでは、getImagesと呼んでいます。

このようにゲッターとセッターを定義することは、C++ではかなり一般的なパターンですが、Swiftではあまり自然とは感じません。

これをSwiftでもう少しネイティブに感じさせるために、私はswift/bridgingから別の注釈を使用することができます。

SWIFT_COMPUTED_PROPERTY属性は、ゲッターとセッターに適用して、ペアをSwiftの計算プロパティにマッピングできます。

もう一度C++ヘッダーに移動して、この注釈を適用しましょう。

これで、定義をセカンダリクリックしてSwift呼び出し元を選択することで、getImagesメソッドの呼び出し元を検索できます。これにより、単に「画像」に名前を変更できます。

美しい！

では、最後にもう一度アプリを試してみましょう。

いくつかの写真を選択して、カメラロールに保存することができます。

すごい！

この講演では、APIのインポート方法を改善するために、わずか2つの注釈を使用しました。

しかし、C++ヘッダーで使用できる注釈は他にもたくさんあります。

それらにアクセスするために必要なのは、スウィフト/ブリッジングをインポートすることだけです。

Xcode 15でC++の相互運用性を有効にするには、C++とObjective-Cの相互運用性モードをCとObjective-CからC++とObjective-C++に変更します。

また、SwiftとC++の相互運用性は、LinuxやWindowsだけでなく、すべてのAppleプラットフォームでサポートされています。

C++は大規模で複雑な言語であり、C++ APIをインポートし、フィードバックでSwift APIを公開する方法を改善したいと考えています。

C++ APIのインポート方法を変更すると、新しいバージョンの相互運用性が作成されます。

これは、これらの新機能を引き受けたいときに選択できることを意味し、今日あなたの開発で自信を持ってC ++ APIを使い始めることができます。

問題に気付いたり、何か提案があれば、ぜひご意見をお聞かせください。

フィードバックアシスタントを使って教えてください。

C++の相互運用性は、完全にオープンソースのSwiftコンパイラワークグループによって設計されました。

ワークグループは、12以上の企業や学校のエンジニアと学生で構成されています。

ワークグループは、SwiftとC++の相互運用性の将来のビジョンを定義する2つの文書を開発し、時間の経過とともにこの機能の進化を導きます。

ワークグループに参加して、フォーラムに参加できます。

Swift.orgに向かうだけです。

Swift 5.9では、オーバーヘッドなしでC++ APIを自動的かつ安全に使用できます。

新しいSwiftコードをC++に戻すことで、Swiftを段階的に採用できます。

また、コンパイラに詳細情報を提供することで、インポートされたAPIを改善し、微調整することができます。

見てくれてありがとう、そしてすべてのC++コードベースでSwiftを採用して楽しんでください。