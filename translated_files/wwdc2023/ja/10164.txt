10164

♪ ♪

ベン：こんにちは、「Swift 5.9の新機能」へようこそ。

私はベンです。同僚のダグと一緒に、今年はスウィフト言語の改善点をいくつかお連れします。

Swiftのクリーンな構文を使用して意味をより簡単に表現できるいくつかの方法、フレームワーク作成者が新しいAPIをより自然に使用できるようにするための強力な新機能、および低レベルのコードでパフォーマンスと安全性をより詳細に制御するためのいくつかの新しい方法について説明します。

しかし、Swiftオープンソースプロジェクトについて話すことから始めましょう。

これはSwiftにとって素晴らしいアップデートであり、Swiftコミュニティ、swift.orgに集まる言語の貢献者とユーザーが言語を進化させ、新しいイニシアチブをサポートするために協力していなければ実現できませんでした。

スウィフトは、言語進化のためのオープンなプロセスに従います。

新機能や重要な行動の変化は、Swiftフォーラムのオープンで提案され、レビューされます。

フォローしたい場合は、Swiftのウェブサイトですべての言語提案のダッシュボードを見つけることができます。

1年前、私たちはスウィフトプロジェクトのガバナンスの大幅な再編を見ました。

コアチームは、Swift言語と標準ライブラリの進化を監督する主な責任を負った言語運営グループの設立を発表しました。

それ以来、言語グループは40の新しい言語提案を監督しており、今日はそのうちのいくつかについて話します。

しかし、時には、個々の言語の提案は、10の別々の提案を通じて導入されたSwift並行性の追加など、より広いテーマの一部としてまとめられています。

このような場合、言語運営グループは、ビジョン文書を通じて、これらの提案を結びつける新しい方法を導入しました。

これらの文書は、言語のより大きな変更のための提案を示しています。

言語運営グループに最初に受け入れられたのは、この講演の後半で取り上げるSwift 5.9の新機能であるSwiftマクロのビジョンでした。

もちろん、言語の進化はスウィフトコミュニティの仕事の一部にすぎません。

成功した言語には、これよりもはるかに多くのものが必要です。

優れたツール、複数のプラットフォームに対する堅牢なサポート、豊富なドキュメントが必要です。

この分野の進捗状況を監督するために、コアチームは言語ステアリンググループと並行してエコシステムステアリンググループを作成しています。

この新しい構造は、最近、Swift.orgのブログ記事でレイアウトされました。この新しいグループの形成に関するさらなる発表については、すぐに探してください。

それでは、コードで自分を表現するより良い方法から始めて、今年のSwift言語の変更について話しましょう。

Swift 5.9には、おそらく最も一般的に要求される言語強化が含まれており、if/elseとswitchステートメントを式として使用でき、コードをクリーンアップする良い方法を提供します。

たとえば、いくつかの複雑な条件に基づいてlet変数を初期化したい場合は、この読みにくい複合三項式のようなトリックに頼る必要がありました。

If式では、代わりに、より身近で読みやすいifステートメントのチェーンを使用できます。

これが役立つもう1つの場所は、グローバル変数またはストアドプロパティを初期化する場合です。

単一の式はここではうまく機能しますが、条件が欲しい場合は、すぐに実行したクロージャでそれをラップするトリックを使用する必要がありました。

Ifステートメントが式になることができるようになったので、その混乱を落とすだけで、よりきちんとしたコードを残すことができます。

SwiftUIのような機能を推進する宣言型構文である結果ビルダーは、今年、最適化された型チェックのパフォーマンス、コード補完、エラーメッセージの改善など、大幅な改善が見られました。

この改善は、特に無効なコードに焦点を当てていました。

以前は、タイプチェッカーが多くの可能な無効なパスを調査したため、エラーのある結果ビルダーコードは失敗するのに長い時間がかかりました。

Swift 5.8以降、無効なコードタイプのチェックがはるかに速くなり、無効なコードのエラーメッセージがより正確になりました。

たとえば、以前は、一部の無効なコードは、結果ビルダーのまったく異なる部分で誤解を招くエラーにつながる可能性があります。

Swift 5.7では、間違いが実際にここにあるとき、このようなエラーが表示されます。

最新のリリースでは、実際の問題を特定するより正確なコンパイラ診断を受け取ります。

次に、ジェネリックシステムへの追加により、毎日使用するフレームワークがどのように大幅に改善されるかについて話しましょう。

あなたが書くほとんどすべてのSwiftは、何らかの形でジェネリックを使用しています。

型推論を使用すると、構築された高度な機能を理解することなく、これらの型を使用できます。

たとえば、標準ライブラリ配列タイプは、ジェネリックを使用して、保存したい任意のタイプのデータで動作する配列を提供します。

配列を使用する場合、必要なのは要素を提供することだけです。

要素値から推測できるため、要素タイプの明示的な引数を指定する必要はありません。

Swiftのジェネリックシステムは、あなたが提供する具体的なタイプでコードがシームレスに動作するように、タイプ情報を保持する自然なAPIを可能にします。

Swiftコンパイラ独自のコードベースに触発された例を次に示します。リクエストタイプを取り、それを評価して強く型付けされた値を生成するAPIです。

したがって、ブール値を要求し、ブール値の結果を取り戻すことができます。

現在、一部のAPIは、具体的なタイプだけでなく、渡す引数の数も抽象化したいと考えています。

したがって、関数は1つの要求を取り、1つの結果または2つの要求を返し、2つの結果を返すか、3つの結果を返すか、3つの結果を返す可能性があります。

これをサポートするには、ジェネリックシステムは、渡したすべてのタイプが取得したタイプにリンクされるように、複数の引数の長さを処理するメカニズムと一緒に使用する必要があります。

Swift 5.9以前は、このパターンを達成する唯一の方法は、APIがサポートする特定の引数の長さごとにオーバーロードを追加することでした。

しかし、このアプローチには限界があります。

渡すことができる引数の数に人為的な上限を強制し、合格が多すぎるとコンパイラエラーが発生します。

この場合、6つ以上の引数を処理できるオーバーロードはありませんが、7つに合格しました。

このオーバーロードパターンとその制限は、概念的に任意の引数の長さを処理するAPI全体に浸透しています。

Swift 5.9では、ジェネリックシステムは、引数の長さに対するジェネリック抽象化を有効にすることで、このAPIパターンのファーストクラスのサポートを得ています。

これは、一緒に「パック」されている複数の個々のタイプパラメータを表すことができる新しい言語概念で行われます。

この新しい概念は、型パラメータパックと呼ばれます。

パラメータパックを使用すると、現在固定引数長ごとに個別のオーバーロードを持つAPIを1つの関数に折りたたむことができます。

単一の要求の結果タイプを表す単一の型パラメータResultを受け入れる代わりに、評価関数は各結果タイプに対して個別の要求を受け入れるようになりました。

この関数は、括弧内の各結果インスタンスを返します。これは、単一の値または各値を含むタプルのいずれかになります。

評価関数は、人工的な制限なしですべての引数の長さを処理するようになりました。

型推論は、APIがそれらを使用していることを知ることなく、パラメータパックを使用するAPIを自然に使用できるようにします。

任意の数の引数を処理できる新しい評価関数を呼び出すことは、固定長のオーバーロードを呼び出すのと似ています。

Swiftは、関数の呼び出し方法に基づいて、各引数のタイプと総数を推測します。

このような汎用ライブラリAPIの書き方については、パラメータパックを使用してAPIを一般化してください。

一般的なAPIを自然な方法で呼び出すことは、Swiftの基本的な設計目標の1つであり、簡潔なコードによる明確な表現を示しています。

Swiftの高度な言語機能は、あなたの言いたいことをより簡単に言うことができる美しいAPIを可能にします。

配列や辞書を介してジェネリックを使用するか、SwiftUIでUIを設計するかどうかにかかわらず、これまでに書いたSwiftの最初の行からこれらの高度な言語機能の恩恵を受けることができます。

スウィフトの漸進的な開示の受け入れは、準備ができたら、より高度な機能について学ぶことができることを意味します。

Swift 5.9は、新しいマクロシステムを使用して、ライブラリ作成者に表現力豊かなAPI設計のための新しいツールボックスを提供することで、このデザインアプローチを次のレベルに引き上げます。

ダグがあなたにもっと話します。

ダグ：マクロを使用すると、言語自体の機能を拡張し、定型文を排除し、Swiftの表現力をさらに解き放つことができます。

条件が真であるかどうかをチェックする常に存在するアサート関数を考えてみましょう。

条件が偽の場合、アサートはプログラムを停止しますが、それが起こると、何がうまくいかなかったのかについての情報はほとんど得られません。ファイルと行番号だけです。

詳細については、ロギングを追加するか、デバッガにプログラムをトラップする必要があります。

これを改善する試みがありました。

XCTestは、2つの値を別々に取るアサート等しい操作を提供するので、物事が失敗した場合、少なくとも等しくない2つの値を見ることができます。

しかし、ここでどの価値が間違っているのかはまだわかりません。

それはa、b、それともマックスの結果でしたか?

そして、このアプローチは、アサートで実行するあらゆる種類のチェックに対して本当に拡張されません。

元のアサーションに戻ると、ソースコードには非常に多くの情報があり、アサーションが失敗したときにログで見たいです。

コードは何でしたか?

A、b、cの値は何ですか?

マックスは何を生産しましたか?

以前はカスタム機能がなければ、Swiftでこれを改善できませんでしたが、マクロはそれを可能にします。

この例では、「hash-assert」構文は「assert」と呼ばれるマクロを拡張しています。

ハッシュ構文は、Swiftがすでにハッシュファイル、ハッシュセレクタ、ハッシュ警告など、この同じスペルを持ついくつかのものを持っているので、見覚えがあるかもしれません。

アサートマクロは関数バージョンのように見えますが、マクロであるため、アサーションが失敗したときにより豊かな体験を提供できます。

現在、プログラムは、結果に貢献した各値とともに、失敗したアサーションのコードを表示しています。

Swiftでは、マクロは型や関数と同じようにAPIであるため、それらを定義するモジュールをインポートしてアクセスできます。

他の多くのAPIと同様に、マクロはパッケージとして配布されます。

ここでのアサートマクロは、GitHubで利用可能なオープンソースのSwiftパッケージであるpower assertsライブラリから来ています。

マクロパッケージを調べると、アサートのマクロ宣言が見つかります。

「マクロ」キーワードで導入されますが、それ以外は関数によく似ています。

チェックする条件には、ラベルのないブールパラメータが1つあります。

このマクロが値を生成した場合、その結果型は通常の矢印構文で書かれます。

マクロの使用は、パラメータに対してタイプチェックされます。

つまり、最大値を何かと比較するのを忘れるなど、マクロの使用を間違えた場合、マクロが展開される前に、すぐに有用なエラーメッセージが表示されます。

これにより、マクロは適切に型付けされた入力で動作し、予測可能な方法でプログラムを拡張するコードを生成するため、Swiftはマクロを使用する際に優れた開発体験を提供することができます。

ほとんどのマクロは「外部マクロ」として定義され、文字列を介してマクロ実装のモジュールとタイプを指定します。

外部マクロタイプは、コンパイラプラグインとして機能する別々のプログラムで定義されています。

Swiftコンパイラは、マクロを使用するためのソースコードをプラグインに渡します。

プラグインは新しいソースコードを生成し、それがSwiftプログラムに統合されます。

ここでは、マクロはアサーションを個々の値をキャプチャし、ソースコードのどこに表示すべきかに拡張しています。

あなたは自分でボイラープレートを書きたくないでしょうが、マクロはあなたのためにそれを行います。

マクロ宣言には、その役割という1つの追加情報があります。

ここでのアサートマクロは、独立した式マクロです。

「ハッシュ」構文を使用し、その構文で直接動作して新しいコードを生成するため、フリースタンディングと呼ばれています。

これは、値を生成することができる場所ならどこでも使用できるため、式マクロです。

新しいFoundation Predicate APIは、式マクロの素晴らしい例を提供します。

述語マクロを使用すると、クロージャを使用して型安全な方法で述語を書くことができます。

結果の述語値は、Swiftコレクション操作SwiftUIやSwiftDataなど、他の多くのAPIで使用できます。

マクロ自体は、入力タイプのセットに対して一般的です。

これらの入力型の値で動作する関数であるクロージャ引数を受け入れ、ブール結果を生成しますが、入力のセットは一致しますか？

そして、マクロは、プログラムの他の場所で使用できる新しい述語型のインスタンスを返します。

しかし、マクロにはもっと多くのものがあります。なぜなら、私たちが最終的に書くことになる定型文の多くは、そこから派生した他のもので書いたコードを拡張する必要があるからです。

例を挙げてみましょう。

相対パスまたは絶対パスをキャプチャするこのパス列挙型のように、自分のコードで列挙型を頻繁に使用していることがわかります。

しかし、コレクションからすべての絶対パスをフィルタリングすることで、特定のケースを確認する必要があることがよくあります。

もちろん、このisAbsoluteチェックを計算されたプロパティとして書くことができます。

しかし、遅かれ早かれ、私は別のものを書かなければならないでしょう。

これは少し退屈になってきています。

マクロは、私たちのためにボイラープレートを生成することによって、ここで助けることができます。

ケース検出は、プロパティラッパーと同じカスタム属性構文を使用して書かれた添付マクロです。

添付されたマクロは、適用される宣言の構文を入力として取り、ここでは列挙型宣言自体であり、新しいコードを生成します。

このマクロ拡張コードは、コンパイラがプログラムに統合する通常のSwiftコードです。

エディタでマクロで生成されたコードを検査したり、デバッグしたり、さらにカスタマイズしたい場合はコピーしたりできます。

添付されたマクロは、添付されている宣言をどのように増強するかに基づいて、5つの異なる役割に分類されます。

先ほど説明したケース検出マクロは、「メンバー」アタッチマクロです。つまり、タイプまたは拡張で新しいメンバーを作成します。

ピアマクロは、アシンクロメソッドの完了ハンドラーバージョンを作成するなど、添付されている宣言と一緒に新しい宣言を追加します。

アクセサマクロは、保存されたプロパティを計算されたプロパティに変換し、プロパティアクセスに関する特定のアクションを実行したり、プロパティラッパーと同様の方法で実際のストレージを抽象化したりするために使用できますが、プロパティラッパーよりも柔軟です。

また、添付されたマクロは、タイプの特定のメンバーに属性を導入したり、新しいプロトコルの適合性を追加したりできます。

有用な効果を達成するために、いくつかの添付されたマクロロールを一緒に構成することができます。

これの重要な例の1つは観察です。

観察は常にSwiftUIの一部でした。

クラスのプロパティの変更を観察できるようにするには、タイプをObservableObjectに準拠させ、すべてのプロパティを[公開済み]にマークし、ビューで ObservedObjectプロパティラッパーを使用するだけです。

それはたくさんのステップであり、ステップを欠落とすると、UIが期待どおりに更新されない可能性があります。

マクロベースの観察でもっとうまくやれる。

Observableマクロをクラスにアタッチすると、その保存されたすべてのプロパティのオブザベーションが提供されます。

保存された各プロパティに注釈を付けたり、Observableマクロがすべてを処理するため、そうでない場合に何が起こるかを心配する必要はありません。

観測可能なマクロは、3つのマクロロールの構成を通じて機能します。

これらの役割がどのように連携するかを掘り下げてみましょう。

各マクロロールは、PersonクラスがObservableマクロによって拡張される特定の方法に対応します。

メンバーの役割は、新しいプロパティとメソッドを導入します。

メンバー属性ロールは、観測されたクラスの保存されたプロパティに@ObservationTrackedマクロを追加し、ゲッターとセッターに拡張して観測イベントをトリガーします。

最後に、適合性の役割は、Observableプロトコルへの適合性を導入します。

これは多くのコードのように見えるかもしれませんが、それはすべて通常のSwiftコードであり、Observableマクロの後ろにきれいに折り畳まれています。

プログラムへの影響をよりよく理解するためにマクロがどのように展開するかを確認する必要があるときはいつでも、Xcodeの指先にあります。

「マクロを展開」アクションを使用して、エディタでマクロ展開されたソースコードを確認します。

マクロで生成されたコード内のエラーメッセージは自動的に展開されたコードを表示し、デバッガでそれに出入りすることができます。

Swiftマクロは、より表現力豊かなAPIを可能にし、Swiftコードから定型文を排除するための新しいツールを提供し、Swiftの表現力を引き出すのに役立ちます。

マクロは入力をタイプチェックし、通常のSwiftコードを生成し、プログラムの定義されたポイントで統合するので、その効果は簡単に推論できます。

そして、マクロが何をしたかを理解する必要があるときはいつでも、その拡張されたソースコードはエディタにあります。

マクロの表面を引っ掻いたところです。

「Expand on Swiftマクロ」は、あなたが持っている必要があるすべての質問に答えるために、Swiftマクロの設計を深く掘り下げます。

また、「Write Swiftマクロ」を使用して、独自のマクロを実際に実装できます。

Swiftコミュニティがどのような新しいマクロを構築するかを見るのが待ちきれません。

ベン：最初から、Swiftはスケーラブルな言語になるように設計されていました。

スウィフトのデザインは、儀式が少なく、読み書きが簡単な明確で簡潔なコードで表現力を強調しています。

ジェネリックやネイティブ並行性サポートなどのSwiftの強力な機能を活用することで、SwiftUIやSwiftDataなどのフレームワークにより、必要な結果をすばやく達成でき、重要なことに集中する時間を増やすことができます。

しかし、これらの高レベルの機能にもかかわらず、Swiftも効率的です。

ネイティブにコンパイルされ、ガベージコレクションの代わりに値タイプと参照カウントを使用することで、低いメモリフットプリントを達成できることを意味します。

このスケーラビリティは、SwiftをObjective-Cで以前よりも多くの場所に、以前はCまたはC ++を使用する必要があると予想されていた低レベルのシステムにプッシュできることを意味します。

これは、Swiftのより明確なコードと重要な安全保証をより多くの場所にもたらすことを意味します。

私たちは最近、SwiftでFoundationフレームワークの書き換えの開始をオープンソース化しました。

このイニシアチブは、AppleプラットフォームとApple以外のプラットフォームの両方でFoundationの単一の共有実装につながります。

しかし、それはまた、Swiftで大量のObjective-CとCコードを書き換えることを意味しました。

MacOS SonomaとiOS 17では、日付やカレンダーなどの必須タイプの新しいSwiftバックアップ実装、ロケールやAttributedStringなどの書式設定と国際化の必須要素、JSONエンコーディングとデコードの新しいSwift実装があります。

そして、パフォーマンスの勝利は重要でした。

重要な日付を計算するカレンダーの能力は、Swiftの値セマンティクスをよりよく活用して中間割り当てを回避し、一部のベンチマークで20%以上の改善をもたらします。

FormatStyleを使用した日付書式設定も大幅に改善され、標準的な日付と時刻のテンプレートを使用した書式設定のベンチマークが大幅に150%向上しました。

さらにエキサイティングなのは、新しいパッケージでのJSONデコードの改善です。

Foundationには、JSONDecoderとJSONEncoder用のまったく新しいSwift実装があり、Objective-Cコレクションタイプとの間のコストのかかるラウンドトリップを排除します。

Codable型を初期化するためのSwiftでのJSONの解析の緊密な統合により、パフォーマンスも向上します。

テストデータを解析するベンチマークでは、新しい実装は2倍から5倍高速です。

これらの改善は、古いObjective-C実装からSwiftへのブリッジングコストを削減するだけでなく、新しいSwiftベースの実装が高速になることによっても実現されました。

例として1つのベンチマークを見てみましょう。

ベンチュラでは、ブリッジングコストのため、Objective-CからenumerateDatesを呼び出すよりもわずかに速かった。

MacOS Sonomaでは、Swiftから同じ機能を呼び出す方が20%高速です。

そのスピードアップの一部は、ブリッジングコストを排除することから来ていますが、Objective-Cから呼び出すときに見られるように、新しい関数の実装自体も高速です。

この特定の日付の計算は過度に複雑ではないので、これは2つの言語間のオーバーヘッドの減少を見るのに最適な方法です。

さて、システムの下位レベルで動作している場合、必要なレベルのパフォーマンスを達成するために、よりきめ細かな制御が必要になることがあります。

Swift 5.9では、このレベルのコントロールを達成するのに役立つ新しいオプトイン機能が導入されています。

これらの機能は、所有権の概念、つまり、コードのどの部分がアプリケーションの周りを通過する際に値を「所有」するかに焦点を当てています。

これらの機能をいつ使用したいかを確認するには、まずコードの例を見てみましょう。

ここでは、低レベルのシステムコールにより素敵なSwiftインターフェイスを与えることを可能にするファイル記述子のための非常にシンプルなラッパーがあります。

しかし、このAPIで間違いを犯す簡単な方法はまだいくつかあります。

たとえば、closeを呼び出した後にファイルに書き込もうとします。

また、タイプがスコープ外になる前にcloseメソッドを呼び出すことで、常に手動で閉じるように注意する必要があります。

さもなければ、リソースがリークされます。

1つの解決策は、タイプがスコープ外になったときに自動的に閉じるdeinitを持つクラスにすることです。

しかし、追加のメモリ割り当てを行うなど、さまざまな欠点がありますが、これは通常、非常に制約されたシステムコンテキストを除いて、大きな問題ではありません。

クラスには参照セマンティクスもあります。

意図せずにファイル記述子タイプをスレッド間で共有したり、競合状態になったり、意図せずに保存したりする可能性があります。

しかし、戻って構造体のバージョンを見てみましょう。

本当に、この構造体も参照型のように振る舞います。

これは、開いているファイルである真の値を参照する整数を保持します。

このタイプのコピーを作成すると、バグにつながる可能性のある方法で、アプリ全体で変更可能な状態を意図せずに共有することもできます。

あなたが欲しいのは、この構造体のコピーを作成する能力を抑制することです。

構造体であろうとクラスであろうと、Swift型はデフォルトでコピー可能です。

これはほとんどの場合正しい選択です。 ほとんどの場合。

過剰な不要なコピーは、コードのボトルネックになることがありますが、それらのコピーについて明示する必要があるコンパイラに常に悩まされるよりも、時折楽器でそれらのボトルネックを見つけるのに時間を費やす方が良いです。

しかし、暗黙のコピーはあなたが望むものではないことがあります。特に、値のコピーを作成すると、ファイル記述子ラッパーのように、正確性の問題につながる可能性があります。

Swift 5.9では、構造体と列挙型宣言に適用でき、型をコピーする暗黙の機能を抑制するこの新しい構文でそれを行うことができます。

タイプがコピーできなくなったら、クラスのように、タイプの値がスコープ外になったときに実行されるデイニットを与えることができます。

コピー不可能なタイプは、closeを呼び出し、他のメソッドを使用する問題を解決するためにも使用できます。

クローズ操作は消費としてマークすることができます。

消費メソッドまたは引数を呼び出すと、呼び出すメソッドに値の所有権が与えられます。

私たちのタイプはコピーできないので、所有権を放棄することは、もはや値を使用できないことを意味します。

デフォルトでは、Swiftのメソッドはselfを含む引数を借ります。

したがって、ファイル記述子を借りてバッファに書き出すwriteメソッドを呼び出すことができ、その後、値の所有権が呼び出し元に戻り、closeのような別のメソッドを呼び出すことができます。

しかし、クローズは借入のデフォルトではなく、消費としてマークされているので、それは最終的な使用でなければなりません。

つまり、最初にファイルを閉じてから、writeなどの別のメソッドを呼び出そうとすると、実行時の失敗ではなく、コンパイル時にエラーメッセージが表示されます。

コンパイラは、消費使用が発生した場所も示します。

コピー不可能なタイプは、Swiftでのシステムレベルのプログラミングのための強力な新機能です。

彼らはまだ進化の初期段階にいます。

後のバージョンのSwiftは、ジェネリックコードでコピー不可能なタイプを拡張します。

この作品と一緒にフォローすることに興味があるなら、Swiftフォーラムで積極的に議論されています。

ダグ：Swiftの成功の鍵は、Objective-Cとの相互運用性です。

最初から、開発者は既存のコードベースでSwiftの採用に向けて段階的なステップを踏むことができ、Swiftで一度に単一のファイルまたはモジュールをミックスすることができました。

しかし、私たちはあなたの多くがObjective-Cで書かれたコードだけではないことを知っています。

多くのアプリには、C ++で実装されたコアビジネスロジックもあり、それへのインターフェースはそれほど簡単ではありませんでした。

多くの場合、SwiftからObjective-Cを経て、C ++、そしてずっと戻って、追加の手動ブリッジングレイヤーを追加することを意味しました。

Swift 5.9では、Swiftから直接C++の型や関数と対話する機能が導入されています。

C ++の相互運用性は、Objective-Cの相互運用性が常に持っているように機能し、C++ APIをSwiftコードから直接使用できる同等のSwiftにマッピングします。

C++は、クラス、メソッド、コンテナなどのアイデアの独自の概念を持つ大きな言語です。

Swiftコンパイラは一般的なC++イディオムを理解しているため、多くのタイプを直接使用できます。

たとえば、この Person 型は、C++ 値型に期待される 5 つの特別なメンバー関数を定義します。コンストラクタのコピーと移動、代入演算子、およびデストラクタ。

Swiftコンパイラはこれを値型として扱い、適切なタイミングで適切な特別なメンバー関数を自動的に呼び出します。

さらに、ベクトルやマップなどのC++コンテナは、Swiftコレクションとしてアクセスできます。

その結果、C++の関数と型を直接使用する簡単なSwiftコードを書くことができます。

Personインスタンスのベクトルをフィルタリングし、C++メンバー関数を呼び出し、データメンバーに直接アクセスできます。

一方、C++のSwiftコードの使用は、Objective-Cと同じメカニズムに基づいています。

Swiftコンパイラは、Swift APIのC++ビューを含む「生成ヘッダー」を生成します。

ただし、Objective-Cとは異なり、objc属性で注釈付けされたSwiftクラスのみを使用することを制限する必要はありません。

C ++は、ブリッジオーバーヘッドなしで、ほとんどのSwiftタイプと、プロパティ、メソッド、初期化子を含む完全なAPIを直接使用できます。

ここでは、C++がポイント構造体をどのように活用できるかを確認できます。

生成されたヘッダーを含めた後、C ++はSwiftの初期化子を呼び出して、Swiftコード自体を変更することなく、ポイントインスタンスを作成し、ミューテーションメソッドを呼び出し、保存されたプロパティと計算されたプロパティの両方にアクセスできます。

SwiftのC++相互運用性により、Swiftを既存のC++コードベースと統合することがこれまで以上に簡単になります。

多くのC ++イディオムは、しばしば自動的にSwiftで直接表現できますが、時折、目的のセマンティクスを示すためにいくつかの注釈を必要とします。

また、Swift APIはC ++から直接アクセスでき、注釈やコードの変更は必要なく、C、C ++、Objective-Cの任意の組み合わせを使用して、コードベース全体でSwiftを段階的に採用することができます。

C++の相互運用性は、C++の相互運用性ワークグループによって導かれる進化する物語です。

詳細については、「SwiftとC++のミックス」トークを参照するか、Swiftフォーラムのディスカッションに参加してください。

言語レベルでの相互運用性は本当に重要ですが、コードも構築できる必要があります。

また、Swiftを使い始めるために、既存のビルドシステムをXcodeまたはSwift Package Managerに置き換えなければならないことは、大量のコードを書き換えるのと同じくらい大きな障壁になる可能性があります。

そのため、CMakeコミュニティと協力して、CMakeのSwiftサポートを改善しました。

Swiftをプロジェクトの言語の1つとして宣言し、Swiftファイルをターゲットに入れることで、SwiftコードをCMakeビルドに統合できます。

さらに重要なことに、C ++とSwiftを1つのターゲット内で混在させることができ、CMakeはそれぞれを別々にコンパイルし、両方の言語の適切なサポートライブラリとランタイムをすべてリンクします。

これは、今日、クロスプラットフォームのC ++プロジェクトで、ファイルごとに、またはターゲットごとにSwiftを採用し始めることができることを意味します。

また、ブリッジングと生成されたヘッダーの使用など、Swiftと混合C++/Swiftターゲットを含むCMakeプロジェクトを含むサンプルリポジトリも提供しています。

数年前、async/await、構造化並行性、およびアクターの構成要素に基づいて、新しい並行性モデルをSwiftに導入しました。

Swiftの並行性モデルは抽象的なモデルであり、さまざまな環境やライブラリに適応できます。

抽象的なモデルには、タスクと俳優の2つの主要な部分があります。

タスクは、概念的にどこでも実行できる作業の連続した単位を表します。

プログラムに「待機」があるときはいつでもタスクを一時停止し、タスクが続行できたら再開できます。

アクターは、隔離された状態への相互に排他的なアクセスを提供する同期メカニズムです。

外部から俳優を入力するには、タスクを一時停止する可能性があるため、「待機」が必要です。

タスクとアクターは抽象言語モデルに統合されていますが、そのモデル内では、異なる環境に合わせてさまざまな方法で実装できます。

タスクはグローバル同時プールで実行されます。

グローバル同時プールがどのように作業をスケジュールするかは、環境次第です。

Appleのプラットフォームの場合、ディスパッチライブラリはオペレーティングシステム全体に最適化されたスケジューリングを提供し、各プラットフォーム向けに広範囲に調整されています。

より制限的な環境では、マルチスレッドスケジューラのオーバーヘッドは受け入れられない場合があります。

Swiftの並行性モデルは、シングルスレッドの協力キューで実装されています。

抽象モデルは多様なランタイム環境にマッピングするのに十分な柔軟性があるため、同じSwiftコードは両方の環境で機能します。

さらに、コールバックベースのライブラリとの相互運用性は、最初からSwiftのasync/awaitサポートに組み込まれていました。

withCheckedContinuation操作を使用すると、タスクを一時停止し、コールバックに応答して後で再開できます。

これにより、タスク自体を管理する既存のライブラリとの統合が可能になります。

Swift並行性ランタイムにおけるアクターの標準実装は、アクターで実行するタスクのロックフリーキューですが、可能な実装はそれだけではありません。

より制限された環境では、アトミックを持っていない可能性があり、代わりにスピンロックなどの別の並行性プリミティブを使用できます。

その環境がシングルスレッドの場合、同期は必要ありませんが、アクターモデルは関係なくプログラムの抽象並行性モデルを維持します。

同じコードをマルチスレッドの別の環境に持っていくことができます。

Swift 5.9では、カスタムアクターエグゼキュータにより、特定のアクターが独自の同期メカニズムを実装できます。

これにより、アクターはより柔軟になり、既存の環境に適応しやすくなります。

例を挙げてみましょう。

ここでは、データベース接続を管理するアクターを検討します。

Swiftは、このアクターのストレージへの相互に排他的なアクセスを保証するため、データベースへの同時アクセスはありません。

ただし、同期が行われる特定の方法をより詳細に制御する必要がある場合はどうなりますか?

たとえば、そのキューがアクターを採用していない他のコードと共有されているため、データベース接続に特定のディスパッチキューを使用する場合はどうなりますか?

カスタム俳優の執行者があれば、できます。

ここでは、アクターにシリアルディスパッチキューを追加し、そのディスパッチキューに対応するexecututorを生成するunowned executorプロパティの実装を追加しました。

この変更により、アクターインスタンスのすべての同期は、そのキューを介して行われます。

アクターの外部からpruneOldEntriesへの呼び出しを「待機」すると、対応するキューでディスパッチ非同期が実行されます。

これにより、個々のアクターがどのように同期を提供するかをより詳細に制御でき、おそらくObjective-CまたはC ++で書かれているため、アクターをまだ使用していない他のコードとアクターを同期させることもできます。

ディスパッチキューが新しいSerialExecutorプロトコルに準拠しているため、ディスパッチキューを介したアクターの同期が可能になります。

コア操作がほとんどないこのプロトコルに準拠した新しいタイプを定義することで、アクターで使用する独自の同期メカニズムを提供できます。コードが実行者のコンテキストですでに実行されているかどうかを確認します。

例えば、私たちはメインスレッドで実行していますか?

執行者への未所有の参照を抽出して、過剰な参照カウントトラフィックなしでアクセスできるようにします。

そして、最も中核的な操作であるエンキューは、執行者の「仕事」の所有権を取ります。

ジョブは、実行者で同期的に実行する必要がある非同期タスクの一部です。

エンキューが呼び出される時点で、シリアルエグゼキュータで他のコードが実行されていないときに、ある時点でそのジョブを実行するのはエグゼキュータの責任です。

たとえば、ディスパッチキューのエンキューは、そのキューでディスパッチ非同期を呼び出します。

Swift Concurrencyは数年前から使用されており、タスクとアクターで構成される抽象モデルは、幅広い同時プログラミングタスクをカバーしています。

抽象的なモデル自体は非常に柔軟で、iPhoneからApple Watch、サーバーなど、さまざまな実行環境に適応できます。

また、重要なポイントでのカスタマイズを可能にし、まだSwift Concurrencyを完全に採用していないコードと相互運用できるようにしました。

詳細については、「舞台裏」トークと「構造化並行性の基本を超えて」を参照してください。

私たちが見慣れているiOSやMacOSアプリとは大きく異なる環境で動作するSwiftのケーススタディを少し締めくくりたいと思います。

FoundationDBは分散データベースであり、コモディティハードウェアで実行され、MacOS、Linux、Windowsなどのさまざまなプラットフォームをサポートする非常に大規模なキーバリューストアにスケーラブルなソリューションを提供します。

FoundationDBは、C++で書かれた大規模なコードベースを持つオープンソースプロジェクトです。

コードは非常に非同期であり、独自の形式の分散アクターとランタイムがあり、テスト目的で非常に重要な決定論的シミュレーション環境を提供します。

FoundationDBはコードベースを近代化しようとしており、Swiftはパフォーマンス、安全性、コードの明確さに適していることがわかりました。

完全な書き換えは、大きくて危険な努力になるだろう。

代わりに、Swiftの相互運用性を活用して、既存のコードベースに統合しました。

たとえば、これはFoundationDBの「マスターデータ」アクターのC++実装の一部です。

ここでは多くのことが起こっており、このC++のすべてを理解する必要はありません。

しかし、私はコードのいくつかの重要な側面を指摘したいと思います。

まず、C++にはasync/awaitがないため、FoundationDBはそれをエミュレートするための独自のプリプロセッサのようなアプローチを持っています。

多くのC++コードベースと同様に、彼らは非同期タスクを管理するために独自のC++フューチャータイプを実装しています。

これらは、要求に応答を送信するための明示的なメッセージングとペアになります。

返信の送信と関数からの返却の慎重なペアリングに注意してください。

最後に、FoundationDBには、メモリを自動的に管理するための独自の参照カウントスマートポインタがあります。

Swiftでは、この全体をはるかにきれいに実装できます。

その方がいい。

この関数は、Swiftで非同期関数として直接実装できます。

この要求に応答するための通常のリターンタイプと通常のリターンステートメントがありますので、同期を外すことはありません。

他のすべてのSwift非同期コードと同じ方法でサスペンションポイントを示す「待機」があります。

そして、このSwiftコードは、継続を使用して適応されたC++ Futureタイプと結びついています。

ここでは、いくつかのC++タイプを使用しています。

C++のMasterDataタイプは、参照カウントされたスマートポインタを使用していました。

C++で型に注釈を付けることで、Swiftコンパイラは他のクラスと同様にこの型を使用し、参照数を自動的に管理できます。

リクエストタイプや返信タイプなどの他のタイプは、Swiftで直接使用されているC++値タイプです。

そして、相互運用性は両方向です。

この非同期関数、そして実際、Swift並行性モデルによって導入されたすべての作業は、FoundationDBの既存の決定論的ランタイムで実行されます。

そのため、既存のC++とインターフェースして、Swiftのメリットを必要な場所で得ることができます。

このセッションでは、多くの分野をカバーしました。

より表現力豊かなAPIを可能にし、より良いコードをより速く書くのに役立つパラメータパックやマクロなどの機能について説明しました。

パフォーマンスに敏感なコードでのSwiftの使用と、参照カウントのオーバーヘッドなしでリソース管理を提供するためのコピー不可能な型の導入について話しました。

次に、SwiftでC ++ APIを使用するためのサポートを提供するC ++の相互運用性に飛び込み、Swiftの利点をより多くのコードに簡単にもたらすことができます。

最後に、Swiftの柔軟な並行性モデルがデバイスや言語間の無数の環境に適応し、並行性をより簡単かつ安全にする方法について話しました。

Swift 5.9のパラメータパック、マクロ、コピー不可能なタイプ、および他のすべての言語強化は、Swift Evolutionプロセスを通じてオープンに設計および開発され、コミュニティのフィードバックはこれらの機能を形作る上で非常に重要でした。

Swift 5.9は、アクティブなデザインディスカッション、バグレポート、プルリクエスト、教育コンテンツなど、Swiftコミュニティのメンバーからの数え切れないほどの貢献の集大成です。

Swift 5.9を素晴らしいリリースにしてくれてありがとう。

♪ ♪