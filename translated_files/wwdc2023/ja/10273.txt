10273

♪まろやかなインストゥルメンタルヒップホップ♪

♪

こんにちは、私の名前はアマンダで、RealityKitとReality Composer Proに取り組んでいるエンジニアです。

このセッションでは、Reality Composer Proで組み立てた3Dコンテンツを使用して空間体験を作る方法を学びます。

Reality Composer Proは、空間コンピューティングアプリで使用するRealityKitコンテンツを準備するための開発者ツールです。

このセッションでは、同僚のエリックとニールスがセッションで作成したプロジェクトを反復し続け、コードでインタラクティブにする方法を学びます。

まだセッションを見ていない場合は、セッションで取り上げられているエディタUIとReality Composer Proの機能に慣れておくことをお勧めします。

まず、私たちが作った完成品を見てみましょう。その後、各部分をどのように作成したかを説明します。

ヨセミテ国立公園の地形図を見ています。

ヘッドセットでそれを見ると、実際にそこに行かずに以前は不可能だった広大さの感覚が本当に与えられます。

前回のReality Composer Proセッションでは、エリックがこのシーンを組み立て、ニールスが地形で使用している素材を作成しました。

ここでは、2つの異なるカリフォルニアのランドマークの間をモーフィングするスライダーを追加しました。

今、私たちはロサンゼルス沖のカタリナ島を見ています。

また、3D空間に配置されたホバリング2D SwiftUIボタンがあり、そのマップのさまざまな興味のあるポイントについて詳しく知ることができます。

このセッションでは、エクスペリエンスを推進できるように、Reality Composer Proでこのコンテンツをどのように配置したかを探ります。

Reality Composer Proで作成したシーンに影響を与えるように、このスライダーとポイントオブインタレストボタンをどのように接続したかをお見せします。

Reality Composer Proプロジェクトから3Dコンテンツをプログラムでロードすることから始めます。

RealityKitコンポーネントがどのように機能し、独自のカスタムコンポーネントを作成するなど、それらをコードでどのように活用できるかを探ります。

SwiftUIの新しいRealityView APIについて学び、Attachments APIを使用してシーンにユーザーインターフェイス要素を追加する方法を発見します。

そして、Reality Composer Proで設定したオーディオの操作方法を学びます。

次に、Shader Graphを使用して作成したカスタムマテリアルを接続し、コードから要素を駆動することで、Nielsが中断したところから再開します。

始めましょう。

エリックのセッションでは、私たちが望むように配置されたジオラマのすべての資産を含むReality Composer Proプロジェクトを作成しました。

上部にあるこれらのタブは、それぞれ実行時にロードできる1つのルートエンティティを表しています。

私たちは多くのものをシーンに入れて、それを完全に組み立てられたシーンとして扱うことができます。

または、ほんの少し置いて、そのシーンを少し再利用可能な集合体のように扱うこともできます。

私たちは好きなだけ作ることができます。

実行時にDioramaAssembledという名前のこのシーンをどのようにロードするか見てみましょう。

エンティティの非同期初期化子を使用して、Reality Composer Proパッケージのコンテンツを持つエンティティにします。

文字列名を使用してロードするエンティティを指定し、パッケージが生成するバンドルを指定します。

その名前のReality Composer Proプロジェクトで何も見つからない場合は、スローされます。

realityKitContentBundleは、Reality Composer Proパッケージで自動生成する一定の値です。

これはRealityViewで終了します。

RealityViewは、新しい種類のSwiftUIビューです。

それはRealityKitへのあなたの入り口です。

SwiftUIとRealityKitの世界の架け橋です。

このセッションの後半で、このRealityViewをより深く掘り下げます。

Xcodeプロジェクトで使用していて、Reality Composer Proプロジェクトに追加していないUSDアセットがある場合は、これらのアセットをこのように.rkassetsディレクトリを含むSwiftパッケージに入れることを強くお勧めします。

Xcodeは、.rkassetsフォルダを、実行時に読み込むのが速い形式にコンパイルします。

ロードしたばかりのエンティティは、実際にはより大きなエンティティ階層のルートです。

それは子エンティティを持っており、彼らは順番に子エンティティを持っています。

それは私たちがReality Composer Proのシーンで手配したすべてです。

階層の下位にあるエンティティの1つに対処したい場合は、Reality Composer Proで名前を付け、実行時にシーンにそのエンティティをその名前で見つけるように依頼することができます。

エンティティは、エンティティコンポーネントシステムの略であるECSの一部です。

ECSは、RealityKitとReality Composer Proに力を与えるものです。

一歩下がってECSを理解しましょう。

ECSは、オブジェクト指向プログラミングといくつかの密接な類似点がありますが、いくつかの重要な点で異なります。

オブジェクト指向プログラミングの世界では、オブジェクトには、その性質を定義する属性であるプロパティがあり、独自の機能があります。

これらのプロパティと関数は、オブジェクトを定義するクラスに記述します。

ECSの世界では、エンティティはシーンで見られるあらゆるものです。

彼らはまた、目に見えないことができます。

しかし、彼らは属性やデータを保持していません。

代わりに、データをコンポーネントに入れます。

コンポーネントは、アプリの実行中にいつでもエンティティに追加または削除することができ、エンティティの性質を動的に変更する方法を提供します。

システムは、私たちの行動が住んでいる場所です。

フレームごとに1回呼び出される更新機能があります。

それはあなたが継続的な論理を置く場所です。

システムでは、特定のコンポーネントを持つすべてのエンティティ、またはコンポーネントの構成を照会し、いくつかのアクションを実行し、更新されたデータをそれらのコンポーネントに保存します。

ECSに関するより詳細な議論については、2021年の「Dive into RealityKit 2」セッションと今年の「RealityKitで空間体験を構築する」をチェックしてください。

では、コンポーネントについて学びましょう。

Reality Composer Proプロジェクトのエンティティにコンポーネントを追加する方法を確認し、ジオラマでロケーションマーカーを作成するためのカスタムコンポーネントを作成する方法を学びます。

Swift でエンティティにコンポーネントを追加するには、entity.components.set() と言い、コンポーネントの値を指定します。

Reality Composer Proでも同じことをするには、ビューポートまたは階層で必要なエンティティを選択します。

次に、インスペクタパネルの下部にある[コンポーネントの追加]ボタンをクリックして、RealityKitで利用可能なすべてのコンポーネントのリストを表示します。

エンティティに好きなだけコンポーネントを追加でき、各タイプの1つしか追加できません。それはセットです。

また、このリストで作成したカスタムコンポーネントも表示されます。

Reality Composer Proを使用して独自のカスタムコンポーネントを作成する方法を見てみましょう。

地形の特定のポイントにカーソルを合わせるフローティングボタンを作成し、それらを選択してその場所に関する詳細情報を見ることができます。

コードでそのUIと機能の多くを準備しますが、Reality Composer Proでこれらのエンティティを、それらのフローティングボタンを表示したい位置としてマークする方法を紹介したいと思います。

これを行うには、地形マップの上の場所にエンティティを追加します。これは、これらがフローティングボタンを表示したい場所であることをアプリに意味します。

次に、各場所に関する情報を格納するためのポイントオブインタレストコンポーネントを作成します。

次に、XcodeでPointOfInterestComponent.swiftを開いて編集し、名前や説明などのプロパティを追加します。

Reality Composer Proでは、新しいPointOfInterestComponentを新しいエンティティのそれぞれに追加し、プロパティの値を入力します。

カタリナ島にある最初のロケーションマーカーエンティティ、リボンビーチを作りましょう。

プラスメニューをクリックし、[トランスフォーム]を選択して、新しい目に見えないエンティティにします。

エンティティにRibbon_Beachという名前を付けることができます。

リボンビーチが実際に島にある場所にこのエンティティを置きましょう。

[コンポーネントの追加]ボタンをクリックしますが、今回は独自のコンポーネントを作成するため、新しいコンポーネントを選択します。

PointOfInterestという名前を付けましょう。

これで、他のコンポーネントと同じようにインスペクタパネルに表示されます。

しかし、このカウントプロパティは何ですか?

Xcodeで新しいコンポーネントを開きましょう。

Xcodeでは、Reality Composer Proが私たちのためにPointOfInterestComponent.swiftを作成したことがわかります。

Reality Composer ProプロジェクトはSwiftパッケージであり、生成したばかりのSwiftコードはパッケージの中に住んでいます。

テンプレートコードを見ると、カウントプロパティがそこから来たことがわかります。

代わりに別の物件を持ちましょう。

地図を変更するときに、古い興味のあるポイントをフェードアウトし、適切なポイントでフェードインできるように、各興味のあるポイントがどのマップに関連付けられているかを知ってもらいたいです。

したがって、列挙プロパティ、var領域を追加します。

列挙領域をここに作りましょう...

...そして、私たちは今2つの地図しか構築していないので、それに2つのケースを与えます:カタリナとヨセミテ。

文字列としてシリアライズできます。

また、Reality Composer Proがそれを見て、そのインスタンスをシリアライズできるように、Codableプロトコルに準拠しています。

Reality Composer Proに戻ると、カウントプロパティがなくなり、新しい地域のプロパティが表示されます。

コードで初期化したものであるため、デフォルト値はyosemiteですが、この特定のエンティティに対してここでオーバーライドできます。

それを上書きすると、この値はこの特定のエンティティに対してのみ有効になります。

残りのポイントオブインタレストコンポーネントは、それらをオーバーライドしない限り、ヨセミテのデフォルト値になります。

PointOfInterestComponentを記号、これらのエンティティに貼り付けるマーカーのように使用しています。

これらのエンティティは、実行時にSwiftUIボタンを配置する場所のプレースホルダのように機能します。

リボンビーチを追加したのと同じ方法で、他のカタリナ島の興味のあるポイントを追加します。

アプリを実行して、新しいカスタムコンポーネントが何をするか見てみましょう。

ああ！それは何もしません。

それは、これらのポイントオブインタレストコンポーネントを処理するためのコードをまだ書いていないからです。

そうしましょう。そうしましょう。

SwiftUIのコンテンツをRealityKitのシーンに入れる新しい方法があります。

これは添付ファイルAPIと呼ばれます。 は添付ファイルAPIと呼ばれます。

添付ファイルをPointOfInterestComponentと組み合わせて、実行時にカスタムデータでホバリングボタンを作成します。

まずこれをコードで見てから、データフローを順を追って説明します。

添付ファイルはRealityViewの一部です。

まず、RealityViewの構造を示す簡略化された例を見て、SwiftUIビューがどのようにRealityKitシーンに入るかを見てみましょう。

使用するRealityView初期化子には、makeクロージャ、更新クロージャ、添付ファイルViewBuilderの3つのパラメータが必要です。

これを少し広げて、アタッチメントビュー、緑色のSwiftUIボタンを作成し、RealityKitシーンに追加するという最低限の実装を追加しましょう。

Attachments ViewBuilderでは、通常のSwiftUIビューを作成します。ビュー修飾子とジェスチャー、およびSwiftUIが提供する残りのすべてを使用できます。

ビューにユニークなハッシュ可能なタグを付けます。

このボタンビューに魚の絵文字をタグ付けすることを選択しました。

その後、SwiftUIがアップデートクロージャを呼び出すと、ボタンビューがエンティティになります。

このクロージャの添付ファイルパラメータに保存され、以前に与えたタグを使用してそれを釣り出します。

その後、他のエンティティと同じように扱うことができます。

シーン内の既存のエンティティの子として追加することも、コンテンツのエンティティコレクションに新しいトップレベルのエンティティとして追加することもできます。

そして、それが通常のエンティティになったので、その位置を設定して、3Dで必要な場所を表示し、必要なコンポーネントを追加することもできます。

RealityViewのある部分から別の部分へのデータの流れは次のとおりです。

このRealityView初期化子の3つのパラメータを見てみましょう。

1つ目はmakeで、Reality Composer Proバンドルから最初のセットアップシーンをエンティティとしてロードし、RealityKitシーンに追加します。

2つ目は更新です。これは、ビューの状態が変更されたときに呼び出されるクロージャです。

ここでは、コンポーネントのプロパティや位置など、エンティティに関するものを変更したり、シーンからエンティティを追加または削除したりすることもできます。

この更新プログラムのクロージャは、すべてのフレームで実行されるわけではありません。

SwiftUIビューの状態が変わるたびに呼び出されます。

3つ目は添付ファイルViewBuilderです。

これは、SwiftUIビューを作成してRealityKitシーンに入れることができる場所です。

SwiftUIビューは、添付ファイルViewBuilderで始まり、添付ファイルパラメータの更新クロージャで配信されます。

ここでは、添付ファイルViewBuilderのボタンに与えたのと同じタグを使用してエンティティがあるかどうかを添付ファイルパラメータに尋ねます。

もしあれば、それはあなたにRealityKitエンティティを提供します。

アップデートのクロージャでは、その3D位置を設定し、RealityKitシーンに追加して、好きな場所に宇宙に浮かんでいるのを見ることができます。

ここでは、ボタンエンティティを球体エンティティの子として追加しました。

私はそれを親の0.2メートル上に配置しました。

Makeクロージャには添付ファイルパラメータもあります。

これは、makeクロージャが一度しか実行されないため、このビューが最初に評価された時点で準備ができている添付ファイルを追加するためのものです。

RealityViewの一般的な流れを理解したので、アップデートの終了についてさらに詳しく説明しましょう。

makeとupdateのクロージャのパラメータはRealityKitContentです。

RealityKitコンテンツにエンティティを追加すると、シーンのトップレベルのエンティティになります。

同様に、更新機能から、コンテンツにエンティティを追加すると、シーンに新しいトップレベルのエンティティが表示されます。

Makeクロージャは1回のみ呼び出されますが、更新のクロージャは複数回呼び出されます。

アップデートクロージャで新しいエンティティを作成し、そこでコンテンツに追加すると、そのエンティティの重複を取得しますが、これはあなたが望むものではない可能性があります。

それを防ぐには、一度しか実行されていない場所で作成されたコンテンツにエンティティのみを追加する必要があります。

Content.entitiesにすでにエンティティが含まれているかどうかを確認する必要はありません。

セットのように、同じエンティティでaddを2回呼び出すと、no-opです。

シーン内の既存のエンティティにエンティティを親にするときも同じです - それは2回追加されません。

添付ファイルエンティティはあなたによって作成されるのではなく、添付ファイルViewBuilderで提供する添付ファイルビューごとにRealityViewによって作成されます。

つまり、すでにそこにあるかどうかを確認せずに、アップデートクロージャのコンテンツに追加しても安全です。

だから、添付ファイルViewBuilderで興味のあるポイントをハードコードしたい場合、それが添付ファイルコードを書く方法でした。

しかし、Reality Composer Proプロジェクトのデータが体験を駆動させたいので、より柔軟にしましょう。

そうすれば、デザイナーやプロデューサーはReality Composer Proプロジェクトで興味のあるポイントを作成することができ、私たちのコードは彼らが追加するどんなデータにも対応できます。

データドリブンにするには、Reality Composer Proシーンで設定したデータを読み取るためのコードが必要です。

添付ファイルビューを動的に作成します。

高レベル、これが私たちがやろうとしていることです。

Reality Composer Proでは、すでにリボンビーチのプレースホルダーエンティティを設定しており、ジオラマで強調したい他の興味のあるポイントにも同じことをします。

名前やどの地図に属しているかなど、それぞれが必要とするすべての情報を記入します。

さて、コードでは、これらのエンティティを照会し、それぞれに新しいSwiftUIボタンを作成します。

コレクションに新しいボタンを追加するたびにSwiftUIが添付ファイルViewBuilderを呼び出すために、このコレクションに@Stateプロパティラッパーを追加します。

これらのボタンを添付ファイルViewBuilderまで提供します。

そして最後に、RealityViewの更新終了で、ボタンをエンティティとして受け取り、それらの新しいボタンエンティティをシーンに追加します。

それぞれをReality Composer Proで設定したマーカーエンティティの子として追加します。

より詳細な図を通してこれらの6つのステップを理解し、コードを見てみましょう。

まず、Reality Composer Proのシーンに目に見えないエンティティを追加します。

目に見えないエンティティを、ボタンを表示したい場所に、x軸、y軸、z軸に配置します。

ここでは、すべてのエンティティがデフォルトで持っているトランスフォームコンポーネントを利用しています。

次に、それぞれにPointOfInterestComponentを追加します。

コードでは、PointOfInterestComponentを持つシーン内のすべてのエンティティを照会することで、これらのエンティティへの参照を取得します。

このクエリは、Reality Composer Proで設定した3つの目に見えないエンティティを返します。

それぞれに新しいSwiftUIビューを作成し、コレクションに保存します。

ボタンをRealityViewに取り込むには、SwiftUIビュー更新フローを利用します。

これは、ビューのボタンのコレクションにプロパティラッパー@Stateを追加することを意味します。

@Stateプロパティラッパーは、このコレクションにアイテムを追加すると、SwiftUIがImmersiveViewでビューの更新をトリガーする必要があることをSwiftUIに伝えます。

これにより、SwiftUIは添付ファイルViewBuilderとアップデートの閉鎖を再び評価します。

RealityViewの添付ファイルViewBuilderは、これらのボタンをエンティティにしたいことをSwiftUIに宣言する場所です。

RealityViewのアップデートクロージャは次に呼び出され、ボタンはエンティティとして配信されます。

彼らはもはやSwiftUIビューではありません。

そのため、それらをエンティティ階層に追加できます。

アップデートクロージャでは、目に見えない各エンティティの上に浮かぶ位置にあるアタッチメントエンティティをシーンに追加します。

今、私たちがジオラマのシーンを見るとき、彼らは視覚的に現れるでしょう。

これらの各ステップがどのように行われるか見てみましょう。

まず、Reality Composer Proのシーンで目に見えないエンティティをマークします。

マークしたエンティティを見つけるために、EntityQueryを作ります。

それを使用して、PointOfInterestComponentを持つすべてのエンティティを尋ねます。

次に、QueryResultを反復し、PointOfInterestComponentを持つシーン内の各エンティティに対して新しいSwiftUIビューを作成します。

コンポーネントから取得した情報、Reality Composer Proに入力したデータを記入します。

そのビューは私たちの添付ファイルの1つになるので、タグを付けます。

この場合、私たちは真剣になっているので、魚の絵文字ではなくObjectIdentifierを使用します。

SwiftUIビューのコレクションを作る部分はこちらです。

RealityViewの添付ファイルViewBuilderに添付ファイルを提供するため、添付ファイルプロバイダーと呼びます。

次に、ビューをattachmentsProviderに保存します。

そのコレクションの種類を見てみましょう。 

AttachmentsProviderには、ビューへの添付タグの辞書があります。

ビューをタイプ消去したので、LearnMoreView以外にも他の種類のビューを入れることができます。

sortedTagViewPairsという計算されたプロパティがあり、タプルの配列（タグと対応するビュー）を毎回同じ順序で返します。

次に、添付ファイルViewBuilderで、作成した添付ファイルのコレクションをForEachします。

これは、私たちが与えたペアごとに1つのビューが欲しいことをSwiftUIに伝え、コレクションからビューを提供します。

ここでは、ObjectIdentifierに、ビューの添付ファイルタグとForEach構造の識別子の両方として二重の義務を負わせています。

では、代わりにPointOfInterestComponentにタグプロパティを追加してみませんか？

添付ファイルタグは、ForEach構造体と添付ファイルメカニズムの両方が機能するために、一意である必要があります。

また、コンポーネントをエンティティに追加すると、カスタムコンポーネントのすべてのプロパティがReality Composer Proのインスペクタパネルに表示されるため、attachTagもそこに表示されます。

Reality Composer Proに関心のある各ポイントを追加するときに、すべてのタグを統一することを覚えておくことに負担をかけたくありません。

しかし、私たちにとって便利なことに、エンティティは識別可能なプロトコルに準拠しているため、自動的に一意の識別子を持っています。

Reality Composer Proでシーンを設計する際に、事前に知ることなく、実行時にエンティティからこの識別子を取得できます。

Reality Composer ProにattachTagプロパティが表示されないようにするには、「デザインタイムとランタイムコンポーネント」と呼ばれるテクニックを使用します。

データを2つの異なるコンポーネントに分割します。1つはReality Composer Proで配置する設計時データ用、もう1つは実行時に同じエンティティに動的にアタッチするランタイムデータ用です。

これは、Reality Composer Proのインスペクタパネルに表示したくないプロパティ用です。

そこで、新しいコンポーネントPointOfInterestRuntimeComponentを定義し、その中に添付ファイルタグを移動します。

Reality Composer Proは、Swiftパッケージで読んだ内容に基づいて、コンポーネントUIを自動的に構築します。

パッケージ内のSwiftコードを検査し、見つけたコード可能なコンポーネントをシーンで使用できるようにします。

ここでは、4つのコンポーネントを示しています。

コンポーネントAとBはXcodeプロジェクトにありますが、Reality Composer Proパッケージ内にないため、Reality Composer Proのエンティティに添付することはできません。

コンポーネントCはパッケージ内にありますが、体系化できないため、Reality Composer Proはそれを無視します。

ここに示されている4つのコンポーネントのうち、コンポーネントDのみがSwiftパッケージ内にあり、コーディング可能なコンポーネントであるため、Reality Composer Proのリストに表示されます。

それは私たちの設計時コンポーネントですが、他のものはすべてランタイムコンポーネントとして使用できます。

デザインタイムコンポーネントは、3Dアーティストやデザイナーが利用するint、文字列、SIMD値などのより単純なデータを格納するためのものです。

Reality Composer Proがシリアライズしないタイプのプロパティをカスタムコンポーネントに追加すると、Xcodeプロジェクトにエラーが表示されます。

では、私たちのコードに戻りましょう。

まず、PointOfInterestランタイムコンポーネントをエンティティに追加し、ランタイムコンポーネントを使用して、添付ファイルエンティティとジオラマの対応するポイントを照合します。

ここでランタイムコンポーネントの出番です。

私たちは、PointOfInterestエンティティで読み、添付ファイルビューを作成している部分にいます。

すべての設計時コンポーネントを照会し、それぞれに対応する新しいランタイムコンポーネントを作ります。

attachmentTagをランタイムコンポーネントに保存し、ランタイムコンポーネントを同じエンティティに保存します。

このようにして、デザインタイムコンポーネントは記号のようなものです。

それは私たちのアプリに、それのために作られた添付ファイルを望んでいることを伝えます。

ランタイムコンポーネントは、アプリの実行中に必要な他の種類のデータを処理しますが、設計時コンポーネントに保存したくありません。

RealityViewでは、アタッチメントエンティティがシーンに表示される前に、もう1つのステップがあります。

添付ファイルViewBuilderでSwiftUIビューを提供すると、SwiftUIはRealityViewのアップデートクロージャを呼び、RealityKitエンティティとして添付ファイルを提供します。

しかし、それらを配置せずにコンテンツに追加するだけで、それらはすべてシーンの原点、位置0、0、0に座って表示されます。

それは私たちがそれらが欲しい場所ではありません。

私たちは、彼らが地形上の各興味のあるポイントの上に浮かんでほしい。

アタッチメントエンティティを、Reality Composer Proで設定した目に見えないポイントオブインタレストエンティティと照合する必要があります。

目に見えないエンティティに配置したランタイムコンポーネントには、タグが入っています。

それが、どのattachmentEntityが各ポイントオブインタレストエンティティと一致させる方法です。

すべてのPointOf InterestRuntimeComponentsをクエリし、クエリによって返された各エンティティからそのランタイムコンポーネントを取得し、コンポーネントのattachTagプロパティを使用して、attachmentmentsパラメータから更新クロージャにattachEntityを取得します。

次に、attachEntityをコンテンツに追加し、ポイントオブインタレストエンティティの半メートル上に配置します。

アプリをもう一度実行して、これらがどのように見えるか見てみましょう。

ねえ、彼らは素晴らしく見えます!

それぞれの場所の名前が、Reality Composer Proプロジェクトに入れた場所の上に浮かんでいるのを見ることができます。

次に、Reality Composer Proで設定したオーディオの再生方法を調べてみましょう。

Reality Composer Proでオーディオを再生するものを設定するには、プラスボタンをクリックしてオーディオを選択し、アンビエントオーディオを選択することで、オーディオエンティティを持ち込むことができます。

これにより、AmbientAudioComponentが付いた通常の目に見えないエンティティが作成されます。

カタリナ島のオーシャンサウンドを再生するために使用するので、エンティティOceanEmitterに名前を付けましょう。

シーンにもオーディオファイルを追加する必要があります。

私たちの海の音を持ち込みましょう。

インスペクタパネルのコンポーネントのプレビューメニューでサウンドを選択することで、オーディオコンポーネントをプレビューできますが、エンティティがアプリに読み込まれると、選択したサウンドは自動的に再生されません。

そのために、オーディオリソースをロードして再生するように指示する必要があります。

このサウンドを再生するには、オーディオコンポーネントを配置したエンティティへの参照を取得します。

エンティティをOceanEmitterと名付けたので、その名前でエンティティを見つけます。

AudioFileResource初期化子を使用してサウンドファイルをロードし、シーン内のオーディオファイルリソースプリムへのフルパスを渡します。

Reality Composer Proプロジェクトに含まれている.usdaファイルの名前を付けます。

私たちの場合、それはDioramaAssembled.usdaという名前のメインシーンです。

entity.prepareAudioを呼び出してaudioPlaybackControllerを作成し、このサウンドを再生、一時停止、停止することができます。

今、私たちはそれで遊びを呼び出す準備ができています。

これは私たちのアプリで流れている海の音です。

私たちのアプリのスライダーは、ヨセミテとカタリナ島の2つの異なる地形マップの間でモーフィングします。

シーンにオーディオを導入したので、2つのオーディオソースの間でクロスフェードします。

オーシャンエミッターエンティティを追加したのと同じ方法で、フォレストオーディオエミッターを追加します。

スライダーを使用して地形をどのようにモーフィングしているかを見てみましょう。このトランジションにはオーディオも含めます。

シェーダーグラフ素材のプロパティを使用して、2つの地形の間でモーフィングします。

それをどうするか見てみましょう。

ニールスのセッションでは、Reality Composer Proのシェーダーグラフを使用して、この美しいジオメトリ修飾子を作成しました。

これで、それをシーンに接続して、実行時にパラメータの一部を駆動することができます。

このシェーダーグラフ素材をスライダーで接続したい。

そのためにには、入力ノードを宣伝する必要があります。

ノードをCommandキーを押しながらクリックし、プロモートを選択します。

これは、材料のこの部分に実行時にデータを提供する予定であることをプロジェクトに伝えます。

この昇格されたノードProgressに名前を付けるので、実行時にその名前で対処できます。

コードでこの値を動的に変更できるようになりました。

私たちは、私たちの材料がオンになっているエンティティへの参照を取得します。

次に、材料を収容するRealityKitコンポーネントであるModelComponentを取得します。

ModelComponentから、最初の材料を入手します。

この特定のエンティティには1つしかありません。

ShaderGraphMaterialと入力するようにキャストします。

これで、Progressという名前でパラメータの新しい値を設定できます。

最後に、マテリアルをModelComponentに格納し、ModelComponentを地形エンティティに戻します。

次に、それをSwiftUIスライダーに接続します。

スライダーの値が変わるたびに、0から1の範囲にあるその値を取得し、ShaderGraphMaterialにフィードします。

次に、2つの地形のアンビエントオーディオトラックをクロスフェードしましょう。

また、海と森の2つのオーディオエンティティにAmbientAudioComponentを入れたため、ゲインプロパティを使用して音の再生音量を調整できます。

この時点で、AmbientAudioComponentを持つすべてのエンティティ（この時点で2つすべて、海と森林）を照会します。

さらに、ある地域または別の地域に行くエンティティをマークできるように、RegionSpecificComponentと呼ばれる別のカスタムコンポーネントを追加しました。

変更してエンティティに保存するため、audioComponentの可変コピーを取得します。

リージョンとスライダー値を与えるゲインを計算する関数を呼び出します。

ゲイン値をAmbientAudioComponentに設定し、コンポーネントをエンティティに保存します。

それを実際に見てみましょう。

すごい！

スライダーを動かすと、シェーダーグラフの素材が地形マップのジオメトリを変更し、森の音がフェードアウトし、海の音が入ってくるのが聞こえます。

今日は多くの情報を取り上げました。

要約しましょう。

Reality Composer ProのコンテンツをXcodeのアプリに読み込む方法を学びました。

Reality Composer Proで独自のカスタムコンポーネントを作成する方法を検討しました。

SwiftUIアタッチメントAPIがどのように機能し、エンティティとしてどのように配信されるかを調査しました。

オーディオを設定し、そのオーディオをコードで再生する方法を見ました。

そして最後に、プロモーションされたマテリアルプロパティを取得し、コードからそれを駆動する方法を見ました。

これらのワークフローは、空間体験に命を吹き込むのに役立ちます。

私はあなたが私たちの新しいプラットフォームで構築するすべての素晴らしいものを見るのを楽しみにしています。

ありがとうございます。

♪