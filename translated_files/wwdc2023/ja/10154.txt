10154

ジュリア：こんにちは！私の名前はジュリアです。

私はSwiftUIエンジニアです。

最近、Swiftでモデルレイヤーを永続化する新しい方法であるSwiftDataを導入しました。

今日のセッションでは、SwiftUIアプリにSwiftDataをシームレスに統合する方法を見てみましょう。SwiftDataモデルとのスムーズな統合を可能にする新しいSwiftUI機能について説明します。

基本をカバーするために、まだ見ていない場合は、まず「Meet SwiftData」セッションをご覧ください。

SwiftDataとSwiftUIがどのように一緒にプレイするかを見るために、フラッシュカードアプリを作りましょう。

しばらくの間、私は偉大な発明の日付や著者を覚えるのに役立つツールを作りたいと思っていましたが、SwiftDataはこのタスクに最適です。

フラッシュカードデッキを永続化するのに役立ちますので、時間があるときにいつでも開いてクリックすることができます。

このアプリをどこでも動作させたい：Mac、iPhone、Watch、TV、そしてSwiftDataが私の背中を持っています。

それはすべてのプラットフォームで利用可能です。

これはコードアロングです。

このセッションでは、あなたと一緒にアプリを構築します。

今すぐ一時停止を押して、コンパニオンXcodeプロジェクトをダウンロードしてください：準備された開始点と完成したアーカイブ。

スタータープロジェクトを開き、ContentViewファイルに移動します。

このセッションでは、新しいXcode機能、Mac用の埋め込みインタラクティブライブプレビューを活用します。

プレビューセクションには、いくつかのフラッシュカードが入ったグリッドがあります。

任意のカードをクリックすると、カードを1つずつスクロールできるビューに移行します。

誰がコンパイラを発明したか覚えていますか？

カードをクリックします。それはひっくり返って答えを与えます!

アプリにはメモリに保存されているサンプルカードが入力されており、アプリを実行して新しいカードを追加すると、アプリを閉じると消えます。

ここでSwiftDataの出番です。

作成したフラッシュカードを永続化するために使用します。

今日は、SwiftDataの使用を開始するために知っておくべきことすべてについて話し、私が私たちのためにまとめたこのtodoリストで次々とチェックします。

あなたは私たちが構築するアプリに会ったばかりです。

次に、スタータープロジェクトとそのモデルクラスを見ていきます。

その後、段階的に、SwiftDataをストレージとして使用するように変換して修正します。

モデルクラスを拡張してSwiftDataモデルになる方法、データを照会し、モデルレイヤーのすべての変更のビューを更新する方法、モデルを作成して保存し、UI要素を便利にバインドする方法を学びます。

そして最後に、ボーナスとして、SwiftDataがストレージの世話をするときに、ドキュメントベースのアプリを作成するのがいかに簡単かを確認します。

スタータープロジェクトでは、時間を節約するために、単一のフラッシュカード、いくつかのビュー、およびサポートファイルを表すカードモデルを定義しました。

すべてのカードは、前面と背面のテキストと作成日を保存します。

それはかなり典型的なモデルです。

SwiftDataが保存できるように更新しましょう。

まず、SwiftDataをこのファイルにインポートします。

そして次に、私たちが行う必要がある主な変更は、定義に@Modelマクロを追加することです。

そして今、クラスはSwiftDataで完全に永続化可能です。

もうタイピングはしない。それでおそれ！

さらに、@Modelを使用すると、カードはObservableプロトコルに準拠し、ObservableObjectの代わりに使用します。

Observableオブジェクトと@Publishedプロパティラッパーへの適合性を削除します。

以前は、ObservedObjectコンフォーマンスを使用して、CardEditorViewファイルのUIから直接カードを編集しました。

ここでObservableを採用するために、「ObservedObject」プロパティラッパーを「Bindable」に置き換えます。

これにより、テキストフィールドをカードの前面に直接バインドできます。

そしてバックテキスト。

完了！

新しいObservableマクロとBindableプロパティラッパーを使用すると、以前よりもさらに少ないコードでアプリケーション内のデータフローを簡単に設定できます。

ビューが本体でObservableタイプのプロパティを使用する場合、指定されたプロパティが変更されると自動的に更新されます。

そして、モデルの可変状態をUI要素にバインドすることはそれほど簡単ではありませんでした!

WWDC23セッション「SwiftUIで観察を発見する」を見ることをお勧めします。

ObservableがSwiftDataの有無にかかわらず、データフローコードを簡素化する方法に驚かれることでしょう。

そして、モデルについて知っておくべきことはそれだけです。

これ以上何もない。それはどれくらいかっこいいですか?

次に、SwiftDataからモデルを照会してUIに表示するには、ContentViewに切り替えましょう。

SampleDeck.contentsの代わりに、SwiftDataが持っているカードを表示します。

そして、カード配列をSwiftDataストレージにバインドするために必要な1つの変更があります。@Stateプロパティラッパーを@Queryに置き換えます。

それでおそれ！

プレビューでわかるように、おそらく保存していないため、表示するカードはもうありません。

SwiftDataが管理するモデルをUIに表示したいときはいつでも@Queryを使用してください。

@Queryは、SwiftDataからモデルを照会する新しいプロパティラッパーです。

また、@Stateがそれを行う方法と同様に、モデルの変更ごとに更新されたビューをトリガーします。

すべてのビューは、必要なだけ多くのクエリプロパティを持つことができます。

クエリは、ソート、順序付け、フィルタリング、さらには変更のアニメーション化を設定するための軽量な構文を提供します。

ボンネットの下では、ビューのモデルコンテキストをデータソースとして使用します。

@Queryにモデルコンテキストを提供するにはどうすればよいですか?

モデルコンテナから1つを取得します。

SwiftUIは、ビューのModelContainerの便利なセットアップのために、新しいビューとシーンの修飾子を販売します。

SwiftDataを使用するには、どのアプリケーションでも少なくとも1つのModelContainerを設定する必要があります。

@Queryが使用するコンテキストを含む、ストレージスタック全体を作成します。

ビューには単一のモデルコンテナがありますが、アプリケーションは異なるビュー階層に必要な数のコンテナを作成して使用できます。

アプリケーションがmodelContainerを設定しない場合、そのウィンドウと作成したビューは、SwiftDataを介してモデルを保存またはクエリすることはできません。

多くのアプリケーションには、単一のモデルコンテナが必要です。

この場合、ウィンドウグループシーン全体に設定できます。

ウィンドウとそのビューは、同じグループから作成された他のウィンドウと同様に、コンテナを継承します。

これらのビューはすべて、単一のコンテナから書き込みおよび読み取ります。

一部のアプリはいくつかのストレージスタックを必要とし、異なるウィンドウ用にいくつかのモデルコンテナを設定できます。

SwiftUIでは、ビューレベルでの詳細な設定も可能です。

同じウィンドウの異なるビューは別々のコンテナを持つことができ、あるコンテナに保存しても別のコンテナには影響しません。

では、クエリにデータソースを提供するようにmodelContainerを設定しましょう。

アプリの定義を開きます...

そして、アプリのウィンドウのモデルコンテナを設定します。

サブビューは、ビュー修飾子にリストされているモデルタイプのみを作成、読み取り、更新、削除できることに注意してください。

そして、セットアップは終わりました!

しかし、私は1つの余分なステップを踏み出したいと思います:私のプレビューにサンプルデータを提供します。

アプリでは、サンプルカードでインメモリコンテナを定義しました。

「PreviewSampleData」ファイルを開いて、ターゲットに含めましょう。

このファイルには、サンプルデータを含むコンテナの定義が含まれています。

ContentViewでそれを使用して、プレビューをサンプルカードで塗りつぶします。

@Queryにデータソースが表示されたので、プレビューにはカードが表示されます!

そして、これはSwiftDataスタックを準備してプレビューを生成するために必要なすべてのセットアップです。

次に、SwiftDataが作成した新しいカードと既存のカードに加えられた変更を追跡して保存することを確認したいと思います。

これを行うには、ビューのモデルコンテキストを使用します。

モデルコンテキストにアクセスするために、SwiftUIは新しい環境変数を提供します。

モデルコンテナと同様に、各ビューには単一のコンテキストがありますが、一般的に、アプリケーションは必要な数だけ持つことができます。

私たちのアプリでは、コンテキストはすでに設定されています。

この環境変数は、モデルコンテナを以前に設定したときに自動的に入力されました。

Xcodeに戻りましょう。 

カードを保存および更新するには、modelContextにアクセスする必要があります。

新しく作成したカードをモデルのコンテキストに挿入して、SwiftDataに保存したいモデルを認識させます。

モデルを挿入した後、「modelContext.save()」を呼び出してコンテキストを保存する必要があると思うかもしれませんが、それを行う必要はありません。

SwiftDataの素晴らしい詳細は、モデルのコンテキストを自動保存することです。

自動保存は、UI関連のイベントとユーザー入力によってトリガーされます。

SwiftDataが私たちのためにそれを行うので、私たちは保存について心配する必要はありません。

SwiftDataストレージを共有したり送信したりする前に、すべての変更がすぐに保持されていることを確認したいケースはごくわずかです。

このような場合は、「save()」を明示的に呼び出します。

私たちのアプリはカードを保存して照会できるので、カードを作成しましょう!

私はアプリを実行します...

プラスボタンを押してカードを作成します。

前に見たコンパイラカードを追加しましょう。

では、アプリを終了して、もう一度起動して、新しいカードがあるかどうか見てみましょう。

そして、ここにあります!

これで、ビューのモデルコンテキストにアクセスしてカードを追加する方法がわかりました。

完了！

新しいウィンドウを開きましょう。

最初のデッキと同じデッキを表示しますが、両方のウィンドウが同じモデルコンテナを使用し、同じデータにアクセスするため、理にかなっています。

しかし、アプリが異なるウィンドウで異なるフラッシュカードデッキを開くことができればいいのですが。

本質的には、すべてのデッキを別々の文書として扱いたいということです。

その後、これらの文書を友達と共有できます。

ドキュメントベースのアプリは、macOS、iOS、iPadOSで使用される概念です。

ユーザーがさまざまな種類のドキュメントを作成、オープン、表示、または編集できる特定の種類のアプリケーションについて説明します。

すべての文書はファイルであり、ユーザーはそれらを保存、コピー、共有することができます。

そして、SwiftUIがSwiftDataに裏打ちされたドキュメントアプリをサポートしていることをお知らせできることを嬉しく思います。

このアプローチを試してみましょう。

FlashCardAppファイルを開きます。

ドキュメントベースのアプリはiOSとmacOSに存在し、これらのプラットフォームでは、DocumentGroup初期化子の使用に切り替えます。

モデルタイプCard.self、コンテンツタイプ、ビュービルダーを渡します。

少し回り道をして、2番目のパラメータ、コンテンツタイプについてより詳細に話しましょう!

SwiftDataドキュメントベースのアプリは、カスタムコンテンツタイプを宣言する必要があります。

各SwiftDataドキュメントは、ユニークなモデルセットから構築されているため、ディスク上にユニークな表現があります。

ドキュメントのコンテキストでは、コンテンツタイプをJPEGのようなバイナリファイル形式と考えることができます。

別のタイプのドキュメントであるパッケージは、Xcodeプロジェクトのように、ディスク上の固定構造を持つディレクトリです。

たとえば、すべてのJPEG画像は同じバイナリ構造です。

そうでなければ、写真編集者はそれらを読む方法を知らないだろう。

同様に、すべてのXcodeプロジェクトには特定のディレクトリとファイルが含まれています。

ユーザーがデッキを開くと、デッキの形式とファイル拡張子をアプリに関連付けるオペレーティングシステムが必要です。

そのため、コンテンツタイプを宣言する必要があります。

SwiftDataドキュメントはパッケージです。SwiftDataモデルのいくつかのプロパティを「externalStorage」属性でマークすると、外部に保存されたすべてのアイテムがドキュメントパッケージの一部になります。

UTType+FlashCardsファイルには、新しいコンテンツタイプの定義があるので、コードで便利に使用できます。

Info.plistに同じ定義を入れます。

オペレーティングシステムで新しいコンテンツタイプを宣言しようとしています。

アプリによって作成されたカードデッキを他のドキュメントと区別するために、ファイル拡張子を指定する必要があります。

このサンプルアプリでは、拡張機能として「sampledeck」を使用します。

また、フラッシュカードデッキのような簡単な説明を追加します。

識別子は、コード内のものとまったく同じである必要があります。

SwiftDataドキュメントはパッケージであるため、タイプがcom.apple.packageに準拠していることを確認する必要があります。

では、宣言したコンテンツタイプを使ってみましょう。

アプリ定義に戻り、コンテンツタイプをDocumentGroupに渡します。

ビュービルダーは同じように見えます。

特に、私たちはモデルコンテナを設定していません。

ドキュメントインフラストラクチャは、ドキュメントごとに1つずつ設定されます。

アプリケーションを実行して、それが今どのように見えるか見てみましょう!

アプリはパネルを開いた状態で起動します。

ドキュメントベースのアプリケーションの標準的な動作。

新しい文書を作成し、そこにカードを追加します。

ドキュメントには、未保存の変更があることを示すツールバーのサブタイトルが追加されました。

Command+Sを押すと、保存ダイアログが表示されます。

デッキは、先ほどInfo.plistに入れたのと同じファイル拡張子で保存されることに注意してください。

私は新しいデッキを保存し、これが私の最初のフラッシュカードデッキをデスクトップにあります。

Command+Nを押して新しいデッキを作成したり、Command+Oを押して新しいデッキを開くこともできます。

これらのショートカットは、他の多くの機能と同様に、ドキュメントベースのアプリケーションが自動的に取得されます。

要約すると、今日はSwiftUIアプリでSwiftDataストレージを使用する方法を学びました。

新しい@Modelマクロ、@Queryプロパティラッパー、モデルコンテキスト用の新しい環境変数について話し、SwiftDataをドキュメントのストレージとして使用するのがいかに簡単かを見ました。

今日は参加してくれてありがとう、アプリを作って楽しんでください！

♪ ♪