10006

♪ ♪

ジョナサン：こんにちは、私はジョナサンで、インターネットテクノロジーチームのエンジニアです。

今日は、URLSessionを使用して堅牢で再開可能なファイル転送を構築する方法を探ります。

大規模なファイル転送は、小さな中断でもユーザーの進捗状況をすべて捨て、最初から強制的に開始させる可能性があるため、大きな課題になる可能性があります。

さらに、転送が大きければ大きいほど、時間がかかり、時間がかかるほど、何かがうまくいかない機会が増えます。

その間に、ユーザーはアプリから離れたり、Wi-Fiの範囲を離れたり、制御できないほど多くのネットワーク問題の1つを経験したりする可能性があります。

このセッションでは、これらの課題を解決し、ユーザーに堅牢なネットワーキング体験を提供する方法を探ります。

最初の停止は再開可能なHTTPプロトコルで、接続が中断されたときにユーザーが進行状況を維持できます。

これにより、時間と帯域幅の無駄を防ぎ、これらのプロトコルは大量のデータを転送する際の強力なツールになります。

再開可能なアップロードタスクのためのまったく新しいAPIを含む、URLSessionでダウンロードとアップロードの両方を再開する方法を実演します。

これらのAPIの背後にあるメカニズムを理解することは、アプリをデバッグしたり、独自のサーバーサポートを構築したりするのに本当に役立ちます。

そのため、再開可能なプロトコル自体もカバーするので、アプリとサーバーがHTTPを介してこれを達成する方法を正確に知ることができます。

次に、サーバーといえば、SwiftNIOを使用するサーバーに再開可能なアップロードサポートを提供する方法を学びます。

最後に、バックグラウンドURLSessionsがシステムリソースを効率的に利用しながら、ユーザーとネットワークの中断を適切に処理する方法を確認します。

URLSessionでのダウンロードとアップロードの再開について詳しく学びましょう。

だから私は最新のXcodeをダウンロードしていますが、7ギガバイトのダウンロードはほぼ終了しています。

すぐ最後に、私のWi-Fiが切れます。

しかし、待って、ダウンロードは一時停止され、Wi-Fiがオンラインに戻ったら、中断したところからダウンロードを再開できます。

私はちょうど多くの時間といくつかのギグの帯域幅を節約しました。

再開可能なダウンロードは素晴らしいです。

しかし、それらはどのように機能しますか?

まず、クライアントはサーバーからダウンロードを取得するためにGETリクエストを送信します。

応答では、サーバーはAccept-Rangesヘッダーを使用して再開可能なダウンロードのサポートをアドバタイズします。

Accept-Ranges: バイトは、サーバーがこのリソースの特定のバイトの範囲要求をサポートすることを意味します。

サーバー応答には、現時点でリソースを一意に識別するETagと呼ばれるものも含まれています。

サーバー上のコンテンツが変更された場合、ETagも変更されます。

では、このダウンロードが中断された場合はどうなりますか?

クライアントは部分的なダウンロードデータを保存しているので、最後の部分だけが必要です。

これを達成するために、ダウンロードの不足しているバイトを取得するための範囲要求を送信できます。

リクエストは、Rangeフィールドを使用するバイトを示します。

しかし、クライアントはまた、リソースが変更されていないことを確認する必要があります。そうしないと、保存されている古いリソースに新しいリソースからデータを追加します。

これを防ぐために、If-Rangeフィールドには、以前の応答から受信したETagが含まれており、ETagが同じ場合にのみ部分的なデータを送信するようにサーバーに指示します。

ETagが同じ場合、サーバーは206の部分コンテンツで応答します。

ここのContent-Rangeフィールドは、この応答に含まれるバイトの範囲を示し、ダウンロードを完了します。

当初から、URLSessionはRangeリクエストを使用してダウンロードタスクを一時停止および再開するAPIを提供してきました。

これで、アップロードを一時停止して再開することもできます。

これにより、進行中のタスクを手動で一時停止できるだけでなく、エラー処理を実行して予期しない接続の問題から回復し、中断したところから転送を再開することもできます。

まず、これがダウンロードのためにどのように機能するかを確認しましょう。

ユーザーが手動でダウンロードを一時停止して再開できるUIを作成していると想像してみてください。

Safariの例のように、アプリはこのUIを所有していますが、内部では、URLSessionを使用して、部分的なダウンロードデータ、ETag、リクエストヘッダーの追跡など、すべての詳細を処理できます。

ダウンロードを開始するには、通常どおりダウンロードタスクを作成し、resumeを呼び出して開始します。

ユーザーが一時停止ボタンをタップしたときなど、ダウンロードを一時停止するには、cancelByProducingResumeDataを呼び出すことができます。

後でこのダウンロードを再開するには、URLSessionには、ETag、現在のサイズ、ディスク上の場所など、部分的なダウンロードに関する情報が必要になります。

これと他のメタデータは、この関数から返された履歴書データオブジェクトに便利に保存されます。

繰り返しますが、この履歴書データは部分的なダウンロードデータではないことに注意することが重要です。

履歴書データがゼロの場合、これは再開可能なダウンロードの1つ以上の要件が満たされていないことを意味し、すぐに説明します。

一方、履歴書データがゼロでない場合は、後で使用するために保存する必要があります。

これは、ユーザーが再開ボタンをタップしたときのように、ダウンロードを再開するには、この保存されたデータをdownloadTask withResumeDataメソッドに渡すためです。

それはそれと同じくらい簡単です!

このパターンは手動でダウンロードを一時停止するのに最適ですが、URLSessionは予測されない接続の中断から回復する方法も提供します。

ネットワークの問題でダウンロードタスクが失敗した場合は、エラー自体で再開データを確認できます。

ダウンロードを再開できる場合、エラーのuserInfo辞書にはその再開データが含まれます。

URLErrorのdownloadTaskResumeDataプロパティを使用して、このデータに便利にアクセスできます。

URLSessionで再開可能なダウンロードにはいくつかの要件があります。

ダウンロードは本質的にデータを取得し、繰り返しても安全である必要があるため、URLSessionではダウンロードタスクにHTTP GETリクエストが必要です。

他のスキームや方法はサポートされていません。

次に、サーバーはバイト範囲の要求をサポートし、Accept-Rangesヘッダーを使用してこれをアドバタイズする必要があります。

サーバーは、応答のリソースにETagまたはLast-Modifiedフィールドを提供する必要がありますが、ETagが優先されます。

そして最後に、一時的なダウンロードファイルは、ディスク容量の圧力に応じてシステムによって削除されてはなりません。

これらの要件があれば、手動でダウンロードを一時停止して再開したり、接続の中断から回復したりできます。

再開プロトコルがなければ、小さな中断でも最初から転送を再起動することを余儀なくされます。

これはアップロードにとってさらに大きな問題です。

アップロード速度は多くの場合、ダウンロード速度よりもはるかに遅いため、再起動すると、時間とリソースがさらに失われます。

iOS 17では、再開可能なアップロードタスクに対するまったく新しいサポートが導入されています。

私はこれらにとても興奮しています。

現在、サーバーが最新のプロトコルドラフトをサポートしている場合、アップロードタスクは自動的に再開できます。

まず新しいAPIを調べてから、再開可能なアップロードプロトコルの詳細に飛び込みましょう。

ダウンロードタスクと同様に、アップロードタスクを作成し、履歴書を呼び出して開始するだけです。

一時停止するには、アップロードタスクがダウンロードタスクと同じcancelByProducingResumeDataメソッドをサポートするようになりました。

このタスクは、サーバーが最新の再開可能なアップロードプロトコルをサポートしているかどうかを自動的に検出します。

サーバーがそれをサポートしている場合は、後で使用するために履歴書データを保存できます。

そして最後に、一時停止したアップロードを再開するには、新しいuploadTask withResumeDataメソッドを使用します。

ここに示されているパターンがダウンロードタスクと同じであることに気付くでしょう。

つまり、アプリでダウンロードを一時停止および再開するための素晴らしいエクスペリエンスをすでに作成している場合は、ユーザーの再開可能なアップロードも簡単に実装できます。

一時的なネットワークの中断があるだけで、サーバーにまだ到達可能な場合、URLSessionは自動的にアップロードを再開しようとします。

追加のコードは必要ありません。

しかし、ネットワークやサーバーが完全にダウンした場合など、他のより広範な接続の問題が発生した場合は、ダウンロードタスクと同様に、再開データのエラーを確認できます。

URLSessionで再開可能なアップロードを見て非常にうれしく思います。あなたもそれらを愛することを願っています。

しかし、この機能を利用するには、サーバーが最新の再開可能なアップロードプロトコルもサポートしている必要があります。

このプロトコルは現在開発中であり、IETFで標準化するための業界全体の取り組みがあります。

プロトコルでは、クライアントはサーバーのサポートを自動的に検出できます。

これは、URLSessionが最初のリクエストですべてのアップロードを再開可能にできることを意味します。

サーバーが再開可能なアップロードをサポートしていない場合、リクエストは単に通常のアップロードとして継続されます。

ワイヤーでどのように機能するか見てみましょう。

クライアントは最初にアップロードエンドポイントにリクエストを送信します。

Upload-Incompleteフィールドは、このクライアントが再開可能なアップロードをサポートしていることを示します。

疑問符ゼロは、構造化フィールドブール値と呼ばれるもので、値falseを表します。

これは、すべてのアップロードデータがこのリクエストの本文に含まれていることを意味します。

サーバーが再開可能なアップロードをサポートしている場合、クライアントのヘッダーを検出し、104情報応答を使用して独自のサポートをアドバタイズします。

104レスポンスには、履歴書URL付きのロケーションフィールドが含まれています。

この再開URLは、アップロードを一意に識別するために使用されるため、接続が中断された場合、クライアントはアップロードを再開する場所を知っています。

サーバーは、受信したアップロードデータをこの一意の再開URLに関連付けます。

アップロードが中断することなく終了すれば、素晴らしいことです。

サーバーは201を送信し、完了です。

ただし、アップロードが中断された場合、クライアントとサーバーは再開可能なアップロード手順を実行します。

サーバーは履歴書URLの部分的なアップロードを保存しましたが、クライアントはサーバーが実際に取得したデータ量を判断する方法が必要です。

これを行うには、クライアントは履歴書URLにHEADリクエストを送信し、サーバーにアップロードオフセットを要求します。

このオフセットは、サーバーが受信した真のバイト数です。

次に、サーバーはクライアントの特定のアップロードのアップロードオフセットで応答します。

そして最後に、クライアントはサーバーのオフセットを確認し、残りのデータを送信する必要があります。

これを行うには、クライアントは一致するアップロードオフセットで履歴書URLにPATCHリクエストを送信します。

このリクエストの本文には、指定されたオフセットから始まるアップロードデータが含まれています。

これで、クライアントは最終的にすべてのデータをサーバーに送信し、アップロードを完了しました。

あなたのアプリは、URLSessionのアップロードタスクを使用して、これらすべてを無料で入手できます。

それでは、サーバー側に簡単に移動して、SwiftNIOを使用して独自の再開可能なアップロードサーバーを構築する方法を探りましょう。

すでにサーバーでSwiftNIOを使用している方のために、このセクションはあなたのためです。

再開可能なアップロードはどのサーバーでも実装できますが、サーバーがすでにSwiftNIOを使用している場合は、サポートを簡単に追加できる新しいパッケージがあります。

簡単な例を見てみましょう。

馴染みがない場合は、SwiftNIOはアプリとサーバーで動作する非同期ネットワークアプリケーションフレームワークです。

このサンプルコードでは、HTTP/2サーバーを設定しています。

サーバーに2つのハンドラーを追加しました。

コーデックは、HTTP/2フレームをハンドラーの例が理解できる要求に変換します。

他の方向では、サンプルハンドラからの応答を受け取り、それらをHTTP/2フレームにコード化します。

ExampleChannelHandlerは、サーバーの基本的なルーティングとロジックを実行します。

最初は、定期的なアップロードのみをサポートしています。

再開可能なアップロードをサポートするためにサーバーを変換するのがどれほど簡単か調べてみましょう。

まず、NIOResumableUploadプロジェクトをダウンロードし、依存関係として追加し、コードにインポートします。

次に、再開可能なアップロードコンテキストを定義します。

これは、再開URLを生成するときに使用するエンドポイントをアップロードするハンドラーに指示します。

そして最後に、現在のハンドラをHTTPResumableUploadHandlerでラップします。

これは、現在のロジックの上に再開可能なアップロード手順を実行します。

アップロードごとに、ランダムで安全な履歴書URLを生成し、これをアップロードデータに関連付けます。

接続が中断された場合、ハンドラーは部分的なデータを保持し、すべての再開可能なアップロード手順に応答します。

うわー！

わずか数行のコードで、再開可能なアップロードをサポートするためにサーバーをスーパーチャージしました。

すでにサーバーでSwiftを使用している方は、これを試してみてください!

そして、すべての人のために、説明のリンクからオープンソースのサンプルコードを必ずチェックしてください。

サンプルコードでは、新しいHTTPタイプも使用します。これにより、アプリとSwift on Serverプロジェクトで同じタイプを使用できます。

これらのデータタイプは、SwiftNIOと共同でオープンソースパッケージとしてリリースされたので、Swiftブログをチェックして詳細を確認し、フィードバックを提供してください。

再開可能なアップロードプロトコルが104ステータスコードを使用して情報応答を使用していることに気づいたかもしれません。

新しいHTTPタイプにより、サーバー側でこれらの応答を簡単にサポートできます。

アプリでは、URLSessionは再開可能なアップロードの104応答を自動的に処理します。

しかし、それに加えて、URLSessionはデリゲートメソッドdidReceiveInformationalResponseを提供するようになりました。

これにより、アプリは102 Processingや103 Early Hintsなどの他の中間応答を処理できます。

再開可能なプロトコルは、ネットワークの中断を軽減し、帯域幅を節約するための素晴らしい方法です。

バックグラウンドURLSessionは、大規模なファイル転送を処理する場合にも役立ちます。

ユーザーが最新のスキー旅行から巨大な4Kビデオをアップロードしたいと想像してみてください。

接続が中断された場合は、可能であればアップロードを再開してください。

すべてのエラー処理は自分で行うことができます。

または、バックグラウンドセッションに任せることもできます。

実際、バックグラウンドセッションは、サーバーがサポートしている場合、ダウンロードとアップロードの両方のタスクの再開を自動的に処理します。

タスクが中断された場合、システムは増加する時間間隔でタスクを再開しようとします。

タスクを再開できない場合、システムは自動的に最初からタスクを再試行します。

おそらく、あなたのユーザーはスキー山で携帯電話のカバレッジを失うか、吹雪が彼らのWi-Fiを取り出しました。

バックグラウンドセッションは常に接続を待つため、デバイスが再びインターネットに接続した後、ある時点でタスクがスケジュールされます。

ユーザーがビデオをアップロードしている間、彼らはあなたのアプリを離れるか、デバイスを片付けるかもしれません。

たぶん、彼らはより多くの粉末を細断する準備をしていて、彼らはまだ彼らのアップロードが続くことを期待しています。

これは特にバックグラウンドセッションを必要とします。

バックグラウンドタスクはシステムによってスケジュールされるため、アプリのプロセスの外で実行されます。

これは、アプリがシステムによって一時停止または終了された場合でも、ネットワークタスクは確実に継続することを意味します。

長い時間がかかり、ユーザーがアプリを離れるときに持続する必要がある大きなファイル転送には、バックグラウンドセッションを使用します。

最後に、あなたのユーザーはアプリにいるときに最高の経験に値し、それは後で発生する緊急の少ないタスクをスケジュールすることを意味するかもしれません。

バックグラウンドセッションを使用すると、ネットワークアクティビティを効率的にスケジュールし、ユーザーのリソースを節約する方法がいくつかあります。

すぐに実行する必要のないタスクについては、バックグラウンド設定でisDiscretionaryプロパティをtrueに設定することを検討してください。

これにより、システムは「ユーザーはWi-Fiに接続していますか」、「デバイスは電源に接続されていますか」、「ネットワークは制限されていますか」などの要因を考慮して、タスクをインテリジェントにスケジュールすることができます。

これは、後で使用するためにアセットをダウンロードしたり、毎晩のバックアップや分析をアップロードしたりするときに素晴らしいオプションになります。

低データモードで帯域幅を使いすぎないようにするには、allowsConstrainedNetworkAccessプロパティをfalseに設定することを検討してください。

アプリで低データモードをサポートするためのヒントについては、Advances in Networkingセッションをご覧ください。

また、バックグラウンドタスク自体を、人がシステムリソースを使用する可能性が低いときに、後で開始するようにスケジュールすることもできます。

深夜は、多くの場合、大規模なバックアップなどのタスクをスケジュールするのに最適な時間です。

システムのスケジューリングをさらに支援するために、countOfBytesClientExpectsToSendとReceiveのプロパティを設定できます。

これらのプロパティを利用することで、システムにリソースを最適に割り当て、それらの利点をユーザーに渡すことができます。

バックグラウンドセッションは、すぐに行う必要のない大規模なファイル転送や、アプリが一時停止されたときに継続すべき転送に最適なツールです。

小規模なタスク、またはできるだけ早く実行する必要があるタスクには、標準のURLSessionを使用できます。

アプリに再開の力をもたらすことで、ユーザーにとってネットワークを信頼できるものにします。

SwiftNIOとHTTPタイプをチェックして、Swiftで最高のHTTPエクスペリエンスを作成するために協力しましょう。

そして最後に、大規模または裁量的なファイル転送にバックグラウンドセッションを使用してみてください。

ユーザーが最も必要とするときにリソースを節約する方法はたくさんあります。

ご覧いただきありがとうございます。以下の他の素晴らしいネットワーキングセッションを必ずチェックしてください。

そして、それはラップです!

♪ ♪