10189

♪ ♪

ルベナ:みなさん、こんにちは!

私の名前はLuvenaです。Core DataアプリケーションをCore Dataと共存できるSwiftネイティブ永続性フレームワークであるSwiftDataに移行する方法を皆さんと共有できることを嬉しく思います。

Core DataからSwiftDataへの完全な移行の準備ができているかどうか、またはSwiftDataを段階的に採用してCore Dataと共存したいかどうか、Core DataアプリにSwiftDataを採用する方法の一般的なユースケースについて説明します。

まず、マネージドオブジェクトモデルエディタアシスタントを使用してSwiftDataモデルクラスを生成する方法を説明します。

次に、既存のCore Dataアプリケーションの完全なSwiftData採用の流れを実演します。

そして最後に、SwiftDataへの完全な移行がユースケースにとって実現可能な解決策ではない可能性がある場合に備えて、Core DataとSwiftDataの共存を紹介します。

まず、モデルクラスを生成する方法の流れを見てみましょう。

SwiftDataでは、スキーマを設定するためにコードでモデルを使用することに移行しています。

これを行う簡単な方法の1つは、Core Data管理オブジェクトモデルを使用してSwiftDataモデルを生成することです。

この移行を行う方法をお見せしましょう。

私はここでSampleTripsと呼ばれるコアデータアプリケーションを作成しました。これは、ユーザーが今後の旅行の旅程を計画するのに役立ちます。

これは、私のデータとその組織に関する情報を含むモデルファイルです。

私はエンティティTrip、LivingAccommodation、およびBucketListItemを持っており、各旅行が希望する旅行活動を表す1つの対応する生活宿泊施設とバケットリストアイテムを持つように整理されています。

ここから、この同じ情報をキャプチャするSwiftDataクラスを生成します。

これらのSwiftDataクラスを作成するには、Core Data管理オブジェクトモデルは必要ありませんが、既存のCore Dataモデルがある場合は、既存のモデルにすでに持っている組織に基づいてSwiftDataクラスを生成するために使用できます。このユースケースで実演します。

これを行うには、マネージドオブジェクトモデルエディタアシスタントを通過します。

モデルファイルを選択した後、メニューバーに移動し、[エディタ]を選択し、[SwiftDataコードの作成]をクリックします。

これで、既存の3つのエンティティのファイルを生成できます。

SwiftDataモデルをゼロから作成することも、新しいSwiftアプリを作成する場合のオプションであり、このアシスタントは必要ありません。

これは私が作成したばかりのファイルです。

Swiftタイプはモデルに準拠する必要があり、それぞれがエンティティの情報を変数としてキャプチャします。その属性は、Tripの名前、宛先、開始日と終了日、他のエンティティとの関係、LivingAccommodationとBucketListItemです。

では、SwiftDataの完全な採用プロセスを紹介しましょう。

アプリケーションをSwiftDataに完全に移行する場合、SwiftDataでSwiftネイティブ言語機能を活用するために、Core DataスタックをSwiftDataスタックに置き換えます。

これにより、データを永続化するためのより読みやすいコードが可能になり、一部の機能を暗黙的に管理できます。

ただし、この移行を行う前に、既存のコアデータモデル設計がどのように構成されているかを検討する必要があります。

コアデータモデルの設計は、エンティティとそのプロパティと関係を含むスキーマを参照します。

コアデータモデルの設計がSwiftDataでもサポートされていることを確認する必要があります。

これは、コアデータで定義された各エンティティについて、SwiftDataのエンティティ名とプロパティの完全一致を持つ対応するモデルタイプが必要であることを意味します。

モデルを徹底的にテストして、すべての機能がSwiftDataでサポートされていることを確認してください。

Core Dataアプリからの完全なSwiftData採用プロセスのハイライトをもう少し詳しく説明しましょう。

私はすでに以前にモデルをキャプチャするためにSwiftタイプを生成しました。

これらのファイルの準備ができたら、以前に使用されていたCore Data管理オブジェクトモデルファイルを削除し、代わりにこれらのSwiftファイルを使用してモデルを管理できます。

さらに、以前にCore Dataスタックの設定に役立ったPersistenceファイルを削除することもできます。

これで、SwiftDataスタックのmodelContainerを設定できます。

modelContainerは、グループ内のすべてのウィンドウが同じ永続コンテナにアクセスするように構成されていることを保証する修飾子です。

このコンテナをTripsAppに追加することで、modelContainerも環境にデフォルトのModelContextを作成して設定するため、コンテナとコンテキストの両方を設定しています。

ModelContextは、アプリのタイプのインスタンスへの変更を追跡するために使用されます。

この環境プロパティを使用して、任意のシーンまたはビュー内から読み取ることができます。

SampleTrips用のSwiftData永続スタックが設定されましたが、さらにいくつかの変更が必要です。

まず、オブジェクトの作成がどのように機能するかを実演します。

以前は、コアデータでは、新しい旅行を作成すると、このようなものに似ていました。

属性を設定する前に、管理対象オブジェクトコンテキストを渡すTripのインスタンスを作成します。

SwiftDataでは、すでに比較的読みやすいこのコード行でTripの新しいインスタンスを作成できます。

この新しい旅行をしたら、それをモデルコンテキストに挿入して、それが持続していることを確認します。

私の旅行が持続している今、私はそれを保存する方法と私がそれに加える将来の変更を見てみたいと思います。

SwiftDataには、可能であればコンテキストが変更された後のUIライフサイクルイベントとタイマーのセーブをトリガーする暗黙の保存機能があります。

したがって、コンテキストで呼び出されるCore Dataの明示的な保存を削除し、コンテキストが変更されたときにデータを永続化するために暗黙の保存に頼ることができます。

では、データを取得する方法を説明します。

コアデータで持っていたようなフェッチ要求を使用する代わりに、クエリを使用して、クエリで旅行の配列をラップすることで、今後の旅行の完全なリストを取得できます。

これにより、SwiftDataコンテナからこれらのTripオブジェクトを取得できます。

また、クエリのソート順を定義しています。

最も近い今後の旅行が一番上になるように、旅行の開始日を順に並べ替えたいです。

クエリは、述語を含める必要があるユースケースにも使用できます。

Core DataアプリをSwiftDataに完全に移行する方法がわかったので、Core DataとSwiftDataの共存をしたいケースを案内します。

完全な移行は必ずしも実現可能または実用的では限りません。その場合、SwiftDataへの部分的な変換を検討できます。

共存とは、2つの完全に別々の永続スタック、1つのCore Dataスタックと1つのSwiftDataスタックがあり、同じ永続ストアと通信することです。

これは、SwiftDataコードの追加を開始するために、既存のコアデータコードを完全に書き換える必要がないことを意味します。

このオプションは、SwiftDataをアプリケーションに採用する際に、Core Dataにすでにデータがある場合でも、SwiftDataに完全に移行できない他の制約に直面している場合でも、より柔軟性を提供します。

これは、同じストアと話すように両方のスタックを設定する方法です。

永続ストアをロードする前に、コンテナの説明の永続ストアURLを設定して、両方のスタックが同じURLに書き込まれていることを確認する必要があります。

さらに、永続的な履歴追跡をオンにする必要があります。

SwiftDataは自動的に永続的な履歴追跡をオンにしますが、Core Dataはオンにしません。

永続的な履歴を設定せずに、同じアプリケーションでCore DataとSwiftDataの両方が共存しているときに永続的なストアを開こうとすると、ストアは読み取り専用モードになります。

共存がユースケースに最適な選択肢であると感じるシナリオがいくつかあります。

1つのシナリオは、既存のクライアントとの下位互換性を可能にすることです。

SwiftDataはiOS 17とmacOS Sonomaでのみ利用可能であるため、現在のCore DataアプリケーションはSwiftDataへのフルスイッチによって影響を受ける可能性があります。

あるいは、SwiftDataへの完全な変換を困難にするリソースの制約に直面しているかもしれません。

このような場合、SwiftDataを使用して新しい開発を行うか、アプリケーションの一部のみをSwiftDataに変換することで、SwiftDataを部分的に組み込むことは理にかなっています。

この移行を行う前に考慮すべき、Core DataとSwiftDataを共存するためのいくつかの要件があります。

まず、既存のNSManagedObjectベースのエンティティサブクラスまたはSwiftDataクラスが衝突しないように名前空間にする必要があります。

これは、2つのクラスを同じものと呼ぶことができず、少なくとも1つを変更する必要があることを意味します。

クラス名を変更しても、エンティティ名は同じままであることを覚えておいてください。

たとえば、ここでは以前と同じSampleTripsプロジェクトがありますが、今回はCore DataとSwiftDataと共存したいです。

2つのクラス名が衝突する。

SwiftDataとCore Data名Tripの両方を区別するために、代わりにCore Dataトリップクラス名をCDTripに変更しました。

マネージドオブジェクトモデルエディタでもこれを行うことができます。

さらに、Core DataとSwiftDataスキーマを同期させる必要があります。SwiftDataスキーマの新しい部分はNSManagedObjectModelとして具体化する必要があり、2つのスキーマは分岐できません。

これは、プロパティと関係をまったく同じ方法でモデルに追加する必要があることを意味します。

これは、不一致のハッシュが移行を引き起こし、削除したくない情報を削除する可能性があるため、エンティティバージョンのハッシュがすべてのステップに一致するようにするためです。

最後に、共存を組み込むときにスキーマバージョンを追跡する必要があります。

複数のバージョンのSwiftDataモデルを操作する場合は、SwiftDataが違いを評価できるように、変更が正しく表現されていることを確認する必要があります。

これを行う方法はいくつかあります。 これを行うにはいくつかあります。

「SwiftDataでスキーマをモデル化」トークをチェックして、バージョン管理されたスキーマの使い方を理解してください。

UIKitまたはAppKitに依存するSwiftアプリには、SwiftDataを使用するための実行可能なオプションがまだあります。

最初のアプローチは共存の解決策です。

UIKitコードをCore Dataにバインドすることができ、SwiftDataと並行して動作する可能性があります。

あるいは、SwiftDataクラスをSwiftクラスとして扱い、代わりにUIKitコードでSwiftコードをラップすることもできます。

それはすべて私からです!

次に、Core Dataアプリケーションを完全または段階的にSwiftDataに柔軟に移行する方法を発見してください。

それまでの間、SwiftDataに関するこれらの他のクールな話をチェックして、より深く掘り下げてください。

参加してくれてありがとう!私はあなたが何を作るかを見るのが楽しみです!

♪ ♪