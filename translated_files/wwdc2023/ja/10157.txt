10157

♪ ♪

人物：こんにちは、SwiftUIの高度なアニメーションへようこそ。

私はSwiftUIチームのメンバーであるティムです。

SwiftUIには、アプリを輝かせる強力なアニメーションツールセットが付属しており、中断可能で、信頼できる動きのための物理ベースで、フレームワーク全体に深く統合されています。

今日は、アプリのアニメーションを次のレベルに引き上げることができるエキサイティングな新しいツールについて話します。

始める前に、SwiftUIですでに知っているアニメーションツールを簡単に確認しましょう。

他のセッションでお気に入りのペットに投票できるこのアプリを見たことがあるかもしれません。

このデモを簡素化するために、猫は明らかに最良の選択なので、私は先に進み、他のすべてのオプションを削除しました。

アプリにアニメーションを追加するのは、「withAnimation」を使用したり、「アニメーション」モディファイアを追加したりするのと同じくらい簡単で、箱から出して素晴らしい動作を提供します。

アプリケーションの状態が変更された後、SwiftUIは前の状態から新しい状態に補間するアニメーションを適用します。

しかし、アニメーションでは、人生と同様に、どこから来たのか、どこに行くのかに集中していないときに、最もやりがいのある経験が見つかることがあります。

時には、人里離れた道を降りて、何か特別なものを作るために旅そのものに集中する必要があります。

また、一部のアニメーションは、単に以前の状態から新しい状態にアニメーション化しません。

今日は、複雑でマルチステップのアニメーションを構築するための強力な新しいツールについて話します。

これらのアニメーションは、2つの状態間でアニメーション化するのではなく、順番に発生する複数のステップを定義できます。

そして、それらは2つの状況で特に素晴らしいです:アニメーションを繰り返し、ビューが見える間に連続的にループします...

そして、イベントが発生したときにパルスするビューなど、イベント駆動型のアニメーション。

この講演では、このようなアニメーションをさらに簡単に構築できる新しいAPIファミリーを紹介します。

SwiftUIがアニメーションを構成する一連の事前に計画された状態を自動的に進めることができるアニメーションフェーズを紹介することから始めます。

次に、キーフレームでアニメーションをさらに進める方法を実演します。

そして最後に、このAPIを最大限に活用するための高度なヒントとコツを紹介します。

私たちは行く準備ができていると思います。すぐに飛び込みましょう。

スウィフトを書いていないときは、トレイルランニングに出るのが好きです。

トレイルレースは非常に長くなることがあります。

ウルトラマラソンは終了するのに丸1日、あるいは数日かかることがあるので、私は今後のイベントを計画し、実行中に重要な詳細を覚えておくのに役立つアプリを構築しています。

あなたがトレイルにいるとき、栄養は非常に重要です。

残念ながら、疲労が始まると、レースの後半に食べるのを忘れがちです。

適切なタイミングで食べることを思い出させる機能をアプリに追加しました。

ここでは、画面の下部にあるリマインダーは、私が食事の期限を過ぎていることを私に知らせています。

しかし、問題があります。

レースの後半で、私はとても疲れてしまうので、このような微妙な指標を見逃す可能性があります。

私は本当に誤って食事をスキップしたくないので、このリマインダーを目立たせるためにいくつかの動きを追加します。

この1つの見解に焦点を当てましょう。

アニメーションのハイライト効果を与えて、さらに目立つようにしたい。

このビューをアニメーション化するには、「.phaseAnimator」修飾子を適用します。

フェーズアニメーター修飾子を使用すると、マルチパートアニメーションの個々のステップを定義する一連の状態を提供します。

SwiftUIは、これらの状態間で自動的にアニメーション化されます。

この場合、強調表示と強調表示されていない2つの状態の間でアニメーション化するので、単にブール値を使用できます。

次に、現在のフェーズに応じてビューの外観を変更するために、いくつかの修飾子を適用します。

不透明度修飾子から始めます。強調表示するとビューを完全に不透明にし、そうでない場合は50%透明にします。

そしてすぐに、景色がアニメーション化し始めます。

SwiftUIがあなたに代わって何をしているのかについて話しましょう。

私たちの見解では、フェーズアニメーター修飾子に2つのフェーズを提供しました：falseとtrue。

ビューが最初に表示されると、最初のフェーズがアクティブになり、ビューが50%透明になります。

SwiftUIはすぐに、ビューが完全に不透明な次のフェーズへのアニメーション化された移行を開始します。

そして、そのアニメーションが終了すると、SwiftUIは再び進みます。

フェーズは2つしかないので、最初からループします。

これにより、私たちのアニメーションは2つの状態の間で循環します。

もちろん、2つ以上のフェーズと、後で実演する任意の数の追加ビュー修飾子を含むアニメーションを定義することもできます。

今、ビューがアニメーション化している間、その効果は本当に微妙です。

不透明度を変更する代わりに、フォアグラウンドスタイルを変更してみましょう。

ハイライトされたときに赤を使用し、それ以外の場合は主要な前景スタイルにフォールバックします。

そして、それははるかに目立ちます。しかし、アニメーションは少し唐突です。

デフォルトでは、SwiftUIは春のアニメーションを使用します。

また、スプリングは動的な状態の変化を処理するのに最適ですが、この場合、よりスムーズで一貫性のあるアニメーションが必要です。

末尾の「アニメーション」クロージャを追加することで、アニメーションを変更できます。

フェーズごとに異なるアニメーションを使用したい場合に備えて、アニメーション化されているフェーズが渡されます。

しかし、この場合、私はいつも物事を遅くするために、カスタム期間のアニメーションで同じ使いやすさを使用したいと考えています。

さて、アニメーションが終了するのを人々に待たせたくないので、通常、インタラクティブな状態変更のために1秒の持続時間を持つアニメーションを使用しません。

しかし、この場合、私たちは周囲の効果を構築しているので、その食事を逃した場合の私のペースと同じように、物事が少し遅く動くのは大丈夫です。

人種半ばの栄養の緊急の問題を解決したので、アニメーションフェーズを使用するもう1つの方法を見てみましょう。イベントによって引き起こされるアニメーションです。

私はしばらくの間、自分のアプリに取り組んでいて、友達がどのレースを走ったかを見る機能を追加しました。

絵文字は他の人が残した反応を示しています。

すべてのランナーは時々自問します:なぜ私はこれをするのですか?

なぜ私はそんなに多くのマイルを走るためにサインアップしたのですか?

そして、私たちのアプリが少なくともできることは、他の誰かがレースが好きなときにいくつかの興奮を追加することによって、外部検証の必要性を満たすことです。

誰かがリアクションを追加するたびに再生されるアニメーションを追加します。

最初に行うことは、アニメーションのフェーズを定義することです。

単に2つの状態を交互にした前の例とは異なり、より複雑なアニメーションが必要です。

列挙型は、アニメーションのステップのリストを定義するのに最適な方法です。

3つのケースを追加しました。最初の外観のケース、次にビューを上に移動し、ビューをスケールアップするケースです。

ビュー本文を簡素化するために、適用するさまざまな効果を定義する計算されたプロパティをこの列挙型に追加します。

アニメーション中にビューをジャンプさせたいので、計算された垂直オフセットプロパティを追加しました。

列挙型を切り替えて、各ケースの正しいオフセットを返します。

同様に、ビューのスケールとフォアグラウンドスタイルを決定するために、2つの計算プロパティを追加しました。

ここでは実装を表示しませんが、垂直オフセットプロパティと同様にスイッチステートメントも使用します。

では、ビューに戻ってアニメーションを追加しましょう。

phaseAnimator修飾子を追加しますが、今回は「トリガー」値を与えます。

フェーズアニメーター修飾子にトリガー値を与えると、変更に指定した値が観察されます。

そして、変更が発生すると、指定したフェーズを通じてアニメーション化が開始されます。

フェーズタイプで定義した計算されたプロパティを使用して、ビューに修飾子を適用します。

そして、このアニメーションは技術的には正しいことをしますが、気分が良くありません。

それは少し遅いです。

いくつかの異なる春のアニメーションを含め、必要な効果を得るために、各トランジションのアニメーションをカスタマイズします。

そして、これははるかに良く見えます!

しかし、このアニメーションをさらに進めたい場合はどうなりますか?

誰かがトレイルで50または100マイルを終えたとき、私たちは彼らがいくつかの当然の賞賛を受け取ったとき、それらのマイルのすべてがそれだけの価値があったことを彼らの心に疑いの余地のないアニメーションを与えたいと思います。

さらに多くの制御が必要な場合は、もう1つの強力なツールがあります。キーフレームです。

次に、キーフレームを使用して、タイミングと動きを完全に制御して複雑で調整されたアニメーションを定義する方法を紹介します。

まず、キーフレームがこれまで使用したフェーズとどのように異なるかについて話しましょう。

フェーズは、一度に1つずつビューに提供される離散状態を定義します。

そして、SwiftUIは、あなたがすでに知っているのと同じアニメーションタイプを使用して、これらの状態間でアニメーション化し、これは離散状態としてモデル化できるアニメーションで本当にうまく機能します。

状態遷移が発生すると、すべてのプロパティが同時にアニメーション化されます。

そして、そのアニメーションが終了すると、SwiftUIは次の状態にアニメーション化されます。

そして、これはアニメーションのすべての段階で続きます。

しかし、各プロパティを個別にアニメーション化したい場合はどうなりますか?

そこでキーフレームの出番です。

キーフレームを使用すると、アニメーション内の特定の時間に値を定義できます。

実演するために、回転効果から始めて、このビューをアニメーション化します。

ここの点は、アニメーション中に各ポイントで使用する角度であるキーフレームを示しています。

アニメーションが再生されると、SwiftUIはこれらのキーフレーム間の値を補間し、ビューに修飾子を適用するために使用できます。

また、キーフレームを使用すると、それぞれに独自のタイミングを持つ別々のトラックを定義することで、複数のエフェクトを同時に独立してアニメーション化できます。

キーフレームを使用してSwiftUIで任意の修飾子を駆動できるため、これは本当に強力です。

この例では、キーフレームを使用して、垂直ストレッチ、スケール、翻訳など、他のいくつかのトラックを駆動しています。

私たちの見解に戻って、これがコードでどのように見えるか見てみましょう。

私はすでに構築したいアニメーションのアイデアを持っているので、私の最初のステップは、アニメーションを駆動するプロパティを定義することです。

これを行うには、独立してアニメーション化されるすべての異なるプロパティを含む新しい構造体を作成します。

キーフレームは、「Animatable」プロトコルに準拠した任意の値をアニメーション化できます。

いくつかのプロパティが「Animatable」に準拠している「Double」を使用していることに注意してください。

別々の離散状態をモデル化するフェーズとは異なり、キーフレームは指定したタイプの補間値を生成します。

アニメーションが進行中の間、SwiftUIはビューを更新できるように、すべてのフレームにこのタイプの値を提供します。

次に、キーフレームアニメーター修飾子を追加します。

この修飾子は、以前に使用したフェーズアニメーターに似ていますが、キーフレームを受け入れます。

初期値として使用する構造体のインスタンスを提供していることに注意してください。

定義するキーフレームは、この値にアニメーションを適用します。

次に、構造体上の各プロパティのビューに修飾子を適用します。

そして最後に、キーフレームの定義を開始します。

前述したように、キーフレームを使用すると、異なるプロパティに対して異なるキーフレームで洗練されたアニメーションを構築できます。

これを可能にするために、キーフレームはトラックに編成されています。

各トラックは、アニメーション化しているタイプの異なるプロパティを制御します。これは、トラックの作成時に提供するキーパスによって指定されます。

ここでは、スケールプロパティのキーフレームを追加しています。

まず、リニアキーフレームを追加し、初期スケール値を繰り返して0.36秒間保持します。

そして、私が0.36にどのように落ち着いたのか疑問に思っているなら、私はアニメーションの感触を変えるために異なる値を試すことによってその期間を見つけました、そしてそれはキーフレームに関する重要なポイントです。

あなたのアプリに合ったアニメーションを作るには、いくつかの実験が必要です。

Xcodeのプレビューは、アニメーションを微調整するのに最適な方法です。

次に、「SpringKeyframe」を追加します。

これは、スプリング関数を使用して値をターゲットに引き寄せます。

そして、私たちは期間を指定しました。

期間が設定されたスプリングキーフレームの場合、これはスプリング関数がその期間の値のみをアニメーション化することを意味します。

その後、次のキーフレームへの補間が始まります。

最後に、スケールを1.0に戻す別のスプリングキーフレームを追加します。

さまざまな種類のキーフレームは、値の補間方法を制御します。

さて、私たちはLinearKeyframeとSpringKeyframeを見ました。

実際には4種類のキーフレームがあります。

それらがどのように異なるかを説明します。LinearKeyframeは、前のキーフレームからベクトル空間を直線的に補間します。

SpringKeyframeは、その名前が示すように、spring関数を使用して、以前のキーフレームのターゲット値に補間します。

CubicKeyframeは、キュービックベジエ曲線を使用してキーフレーム間を補間します。

複数のキュービックキーフレームを順番に組み合わせると、結果の曲線はCatmull-Romスプラインに相当します。

そして最後に、MoveKeyframeはすぐに補間なしで値にジャンプします。

各種類のキーフレームは、完全な制御を提供するためにカスタマイズをサポートし、アニメーション内でさまざまな種類のキーフレームをミックスして一致させることができます。

SwiftUIは、アニメーションが連続していることを確認するために、キーフレーム間の速度を維持します。

私たちの見解に戻ると、次のトラックを追加する準備が整いました。

ここでは、リニアキーフレームとスプリングキーフレームを使用して垂直変換をアニメーション化しました。

景色が飛び上がる直前に、それは期待して後退します。

私たちは、ビューが上がる前にビューを一時的に引き下げるスプリングキーフレームでそれをモデル化しました。

これは良さそうですが、まだアニメーション化する2つのプロパティがあります。垂直ストレッチと回転です。

垂直ストレッチから始めて、このためにキュービックキーフレームを使用します。

繰り返しますが、これは正しくなるためにいくつかの試行錯誤を取ることができますが、キーフレームを使用してアニメーションをモデル化するさまざまな方法を試してみることを躊躇しないでください。

スカッシュとストレッチは本当にこのアニメーションにもっと多くのエネルギーを与えます。

最後に、ローテーションもアニメーション化します。

そして、これは素晴らしく見えます。

そして、私たちが以前に見たそれらの曲線?

これらは、私たちが構築したばかりのアニメーションの視覚化です。

追加のトラックを追加して、SwiftUI修飾子を適用できます。

さまざまな組み合わせを探るのはとても楽しかったです。

少し時間を取って、キーフレームのモデルを確認しましょう。

キーフレームは事前定義されたアニメーションです。

つまり、UIが流動的でインタラクティブであるべき状況では、通常のSwiftUIアニメーションに代わるものではありません。

代わりに、再生できるビデオクリップのようなキーフレームを考えてください。

彼らはあなたにたくさんのコントロールを与えますが、トレードオフがあります。

アニメーションの進行方法を正確に指定しているため、キーフレームアニメーションはスプリングのように優雅にリターゲティングできないため、一般的にアニメーションの途中でキーフレームの変更を避けるのが最善です。

キーフレームは、定義したタイプの値をアニメーション化し、ビューに修飾子を適用するために使用します。

単一のキーフレームトラックを使用して、単一の修飾子、または異なる修飾子の組み合わせを駆動できます。

それはあなた次第です。

また、アニメーションは定義した値の観点から行われるため、更新はすべてのフレームで行われるため、キーフレームアニメーションをビューに適用している間は、高価な操作の実行を避ける必要があります。

最後に、キーフレームでさらに多くのことができる方法を紹介します。

私のアプリには、各脚のルートを示すレースマップが含まれています。

自動的にズームインしてコースをたどるアニメーションを追加したい。

ありがたいことに、MapKitでキーフレームを使ってカメラを動かすことができるようになりました。

ここでは、コースを表示するために「マップ」ビューを使用しています。

私の見解にはすでにルートがあり、これはレースの1つの脚に沿ったすべての座標を含むモデルです。

ツアーを構築するには、州のプロパティとそれを変更するボタンを追加します。

最後に、新しい「mapCameraKeyframeAnimator」修飾子を使用します。

前の例でハートアイコンに使用したように、トリガー値を与え、キーフレームを追加します。

トリガー値が変更されるたびに、マップはこれらのキーフレームを使用してアニメーション化します。

キーフレームの最終値は、アニメーションの最後に使用されるカメラ値を決定します。

最後に、ボタンを押すと、ツアーが始まります。

ユーザーがアニメーション中にジェスチャーを実行すると、アニメーションは削除され、ユーザーはカメラを完全に制御できます。

中心座標、方向、距離を独立してアニメーション化することで、このコースに沿ってスムーズにアニメーション化し、ズームアウトして俯瞰することができます。

最後に、あなたが考えることができるあらゆる種類の効果をもたらすために、キーフレームを手動で評価する方法を実証したいと思います。

「keyframeAnimator」の修飾子を見ました。

修飾子以外では、「KeyframeTimeline」タイプを使用して、キーフレームとトラックのセットをキャプチャできます。

このタイプを初期値で初期化し、ビュー修飾子と同様に、アニメーションを定義するキーフレームトラックを初期化します。

KeyframeTimelineは、最も長いトラックの持続時間に等しい持続時間を与えるAPIを提供します。

また、アニメーションの範囲内でいつでも値を計算できます。

これにより、先ほど示した曲線の視覚化に使用したSwiftチャートでキーフレームを簡単に視覚化できます。

これはまた、キーフレーム定義の曲線を好きなように使用したり、キーフレームを他のAPIと創造的に組み合わせたりできることを意味します。たとえば、ジオメトリプロキシを使用してスクロール位置を使用してキーフレーム駆動効果をスクラブしたり、「TimelineView」を使用して時間に基づいて更新したりできます。

そして、いつこれを使用するかわからない場合、それは大丈夫です、それは高度なツールであり、ほとんどの開発者はビュー修飾子に固執したいと思うでしょう。

しかし、それはビルディングブロックとしてここにあり、私はそれをあなたのアプリに統合するための創造的な方法を見つけることに興奮しています。

それは私たちの旅を完成させます。

この新しいAPIファミリーを使用することに興奮していることを願っています。

覚えておいてください：連鎖アニメーションにはフェーズを使用してください。

彼らはあなたがすでに知っている既存のアニメーションタイプをすべて使用しているので、すぐに起動して実行することができます。

完全な制御が必要な、より複雑なアニメーションにキーフレームを使用してください。

そして最後に、探検を楽しんでください。

アニメーションの世界はエキサイティングで、これらの新しいツールがあなたとあなたのアプリをどこか新しい場所に導くことを願っています。

ありがとう！

♪ ♪