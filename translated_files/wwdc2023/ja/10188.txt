10188

♪ ♪

ティム：こんにちは、私はティムです。CloudKitチームのエンジニアです。

同僚のAamerと私は、CKSyncEngineと呼ばれる新しいCloudKit APIについて話すためにここにいます。

CKSyncEngineは、デバイスとクラウド間でデータを同期するのに役立つように設計されています。

まず、AppleプラットフォームでのCloudKitへの同期の状態について説明します。

次に、CKSyncEngineとは何か、どのように機能するかの概要を説明します。

その後、自分のプロジェクトでCKSyncEngineを使い始める方法について学びます。

設定が完了したら、同期エンジンを使用してデバイス間でデータを同期する方法を学びます。

最後に、CKSyncEngineとの統合をテストおよびデバッグするためのベストプラクティスについて学びます。

まず、CloudKitへの同期の状態。

新しいアプリを構築するとき、人々は自分のデータが同期することを期待するだけです。

彼らはiPhoneで何かを作り、Macを開くと、それもそこにあることを期待しています。

外から見ると、これは魔法のように見えます。

彼らのデータは1か所にあり、どこにでもある。

あなたと私にとって、それはそれほど簡単ではありません。

CloudKit自体はそれほど複雑ではありませんが、一般的に同期は難しいです。

複数のデバイスをシナリオに持ち込むと、うまくいかないことがたくさんあります。

したがって、同期コードをシンプルにすればするほど良いです。

そして、同期コードを簡素化する最善の方法は、できるだけ少なく書くことです。

ありがたいことに、CloudKitと同期するためのいくつかの素晴らしいAPIの選択肢があり、これらのAPIはあなたのために多くの重労働をします。

ローカル永続性を含むフルスタックソリューションが必要な場合は、NSPersistentCloudKitContainerを使用できます。

独自のローカル永続性を持参したい場合は、新しいCKSyncEngine APIを使用できます。

それでもよりきめ細かな制御が必要だと思われる場合は、CKDatabaseとCKOperationsを使用できます。

しかし、CloudKitと同期したい場合、NSPersistentCloudKitContainerを使用していない場合は、CKSyncEngineを使用する必要があります。

同期には多くの可動部分が含まれており、CKSyncEngineのようなより高いレベルのAPIを使用すると、複雑さを軽減し、アプリの同期体験を向上させるのに役立ちます。

そのコアでは、同期は主に、あるデバイスから変更を送信し、別のデバイスで取得し、必要に応じてCloudKitレコードとの間で変換することです。

それは単独で行うのはかなり簡単ですが、それ以上のものがあります。

すべての異なる操作とエラーについて学び、システムの状態を監視し、アカウントの変更をリッスンし、プッシュ通知を処理し、サブスクリプションを管理し、多くの状態を追跡する必要があります。

CKSyncEngineを使用すると、書かなければならない同期コードの量がはるかに小さくなり、より集中的になります。

アプリに固有のものを処理するだけで、同期エンジンが残りを処理します。

適切な同期エンジンを書くには、おそらく数千行のコードが必要で、テストでその量を2倍にする必要があります。

私は実際にNSPersistentCloudKitContainerが70,000行以上のテストに裏打ちされているという噂を聞きました。

CKSyncEngineにもかなりの数のテストがあり、それはあなたのためにこのようなものの多くを処理するからです。

では、この新しいCKSyncEngine APIとは何ですか?

CKSyncEngineは、CloudKitデータベースと同期するための一般的なロジックをカプセル化します。

必要に応じて柔軟性を与えながら、便利なAPIを提供することを目的としています。

独自のカスタム同期エンジンを作成するほとんどのアプリのニーズを満たすように設計されています。

一般的に、アプリのプライベートデータや共有データを同期したい場合、CKSyncEngineは素晴らしい選択です。

同期エンジンで使用するデータモデルは、CloudKitの残りの部分で使用されるデータと同じタイプのレコードとゾーンで構成されています。

既存のCloudKit APIを使用して、このデータにアクセスできます。

このため、既存のCloudKit同期実装がすでにある場合、CKSyncEngineもそれと同期できます。

同期エンジンは、Freeformアプリを含むシステム全体のいくつかのアプリやサービスで使用されています。

もう1つの例は、同期エンジンの上に書き換えられたNSUbiquitousKeyValueStoreです。

これは、下位互換性のあるユースケースの良い例です。

新しいOSでは同期エンジンを使用しますが、以前のバージョンと同期します。

したがって、すでにカスタムCloudKit同期実装がある場合は、CKSyncEngineに切り替えるオプションがあります。

利点が十分に魅力的に聞こえる場合は、切り替えを検討する必要がありますが、必須ではありません。

時には、維持するコードが少ないのはいいことです。

また、CKSyncEngineが新しい機能強化を受けるたびに恩恵を受けることができます。

プラットフォームが進化するにつれて、同期エンジンも進化し、時間が経つにつれて同期がより簡単かつ効率的になります。

また、CKSyncEngineのより小さなAPIサーフェスの恩恵を受けるかもしれません。

これにより、アプリの特定のデータモデルとユースケースに集中できます。

CKSyncEngineの使用を検討しているが、サポートしていない特定のニーズがある場合は、必要に応じていつでも独自のニーズを構築できます。

ただし、CKSyncEngineの新機能によってニーズが満たされると思われる場合は、ユースケースにフィードバックを提出することを検討してください。

結局のところ、同期エンジンの最高のアイデアのいくつかは、あなたのような開発者から来ています。

では、同期エンジンは実際にどのように機能しますか?

一般的に、同期エンジンはアプリとCloudKitサーバー間のデータの導管として機能します。

アプリは、レコードとゾーンの観点から同期エンジンと通信します。

保存する変更がある場合、アプリはそれらを同期エンジンに提供します。

これらの変更を別のデバイスでフェッチすると、アプリに渡されます。

そうは言っても、同期エンジンがやるべき仕事があるとき、それは必ずしもすぐにそれを行うとは限りません。

サーバーと通信する必要がある場合は、まずシステムタスクスケジューラに相談します。

これは、バックグラウンドタスク管理のためにOS全体で使用されているのと同じスケジューラであり、デバイスが同期する準備ができていることを確認します。

デバイスの準備が整うと、スケジューラはタスクを実行し、同期エンジンはサーバーと通信します。

これは、同期エンジンの基本的な操作フローです。

具体的には、同期エンジンがサーバーに変更を送信すると、どのように見えますか?

まず、誰かがデータに変更を加えます。

たぶん、彼らは何かを入力したり、スイッチを切り替えたり、オブジェクトを削除したりしました。

その後、アプリはサーバーに送信する保留中の変更があることを同期エンジンに伝えます。

これにより、同期エンジンにはやるべき仕事があることを知らせます。

次に、同期エンジンはスケジューラにタスクを送信します。

デバイスの準備ができたら、スケジューラがタスクを実行します。

タスクが実行されると、同期エンジンはサーバーに変更を送信するプロセスを開始します。

そのために、送信する変更の次のバッチをアプリに要求します。

誰かが1つの変更を行った場合、保留中の変更は1つしかないかもしれません。

しかし、誰かが新しいデータの巨大なデータベースをインポートすると、何百、何千もの変更があるかもしれません。

1回のリクエストでサーバーに送信できる量に制限があるため、同期エンジンはこれらの変更をバッチで要求します。

これは、実際に必要になるまでレコードをメモリに持ち込まないようにすることで、メモリのオーバーヘッドを減らすのにも役立ちます。

次のバッチを提供すると、同期エンジンはそれをサーバーに送信します。

サーバーは、これらの変更の成功または失敗に関する情報を含め、操作の結果に応答します。

リクエストが終了すると、同期エンジンは結果をアプリで呼び戻します。

これは、操作の成功または失敗に反応する機会です。

これ以上保留中の変更がある場合、同期エンジンは送信するものがなくなるまでバッチを要求し続けます。

1つのデバイスがサーバーにデータを送信したので、他のデバイスはそのデータを取得します。

サーバーが新しい変更を受信すると、そのデータにアクセスできる他のデバイスにプッシュ通知を送信します。

CKSyncEngineは、アプリでこれらのプッシュ通知を自動的にリッスンします。

通知を受け取ると、タスクをスケジューラに送信します。

スケジューラタスクが実行されると、同期エンジンはサーバーからフェッチします。

新しい変更を取得すると、アプリにそれらが提供されます。

これは、これらの変更をローカルに保持し、UIに表示するチャンスです。

そして、それが同期エンジンを使用するときの基本的な操作の流れです。

これらのフローに共通していることの1つは、システムスケジューラです。

一般的に、CKSyncEngineは何かをする前にスケジューラに相談します。

これは、あなたに代わって自動的に同期する方法です。

スケジューラは、ネットワーク接続、バッテリー残量、リソース使用量などのシステム状態を監視します。

同期を試みる前に、デバイスが前提条件条件を満たしていることを確認します。

スケジューラを尊重することで、同期エンジンはユーザーエクスペリエンスとデバイスリソースの適切なバランスを確保することができます。

通常の状況では、同期はかなり速く、通常は数秒かそこら以内になります。

ただし、ネットワーク接続がない場合、またはデバイスのバッテリー残量が少ない場合は、同期が遅延または延期される可能性があります。

デバイスが負荷が高い場合は、同期メカニズムがアプリ内の他のより緊急なタスクに干渉したくありません。

同期エンジンの自動スケジューリングに頼ることで、すべきでない時ではなく、すべき時に同期することを確信できます。

より効率的であるだけでなく、より使いやすいです。

いつ同期するかを心配する必要がなければ、他のすべてに集中できます。

とはいえ、同期を手動で実行するための正当なユースケースがあります。

すぐにフェッチするプルツーリフレッシュUIがあるかもしれません。

または、保留中の変更をサーバーにすぐに送信するバックアップボタンがあるかもしれません。

手動同期は、自動テストを書くときにも役立ちます。

イベントの順序を制御する必要がある複数のデバイス間で特定の同期シナリオをシミュレートするのに役立ちます。

一般的に、自動同期スケジューリングに頼ることをお勧めします。

しかし、手動同期には有効なユースケースがあり、同期エンジンには必要に応じてそれを行うためのAPIがあることを理解しています。

そして今、AamerはCKSyncEngineの使用を開始する方法について話します。

Aamer: 紹介してくれてありがとう、ティム。

私の名前はAamerです。

私はCloudKitクライアントチームのエンジニアです。

CKSyncEngineを使い始めることについて説明します。

CKSyncEngineを使用する前に、プロジェクトを設定するために行う必要があることがいくつかあります。

これらの要件は、CKSyncEngineを使用している場合でも、独自のカスタムCloudKit実装を構築している場合でも、同じです。

まず、CloudKitの基本的なデータタイプであるCKRecordとCKRecordZoneの基本的な知識が必要です。

同期エンジンAPIは、レコードとゾーンの面で多くを扱うので、飛び込む前にそれらが何であるかを理解する必要があります。

次に、XcodeでプロジェクトのCloudKit機能を有効にする必要があります。

最後に、同期エンジンは最新の状態に保つためにプッシュ通知に依存しているため、リモート通知機能も有効にする必要があります。

そのすべてを手に入れたら、同期エンジンを初期化する準備が整いました。

アプリの起動後すぐにCKSyncEngineを初期化する必要があります。

同期エンジンを初期化すると、バックグラウンドでプッシュ通知とスケジューラタスクのリスニングが自動的に開始されます。

これらの通知とタスクはいつでも発生する可能性があり、それらを処理するために同期エンジンを初期化する必要があります。

アプリとCKSyncEngineの間の主な通信手段は、CKSyncEngineDelegateと呼ばれるプロトコルです。

同期エンジンを初期化するときは、このプロトコルに準拠したオブジェクトを提供する必要があります。

適切かつ効率的に機能するために、同期エンジンはいくつかの内部状態を追跡します。

また、同期エンジンの状態の最後の既知のバージョンも提供する必要があります。

同期操作の実行中に、状態更新イベントの形でこの状態の更新バージョンをデリゲートに渡すことがあります。

同期エンジンが新しい状態のシリアル化を提供するときはいつでも、それをローカルに保持する必要があります。

このようにして、次回プロセスが起動し、同期エンジンを初期化するときに提供できます。

これを理解するために、いくつかのコード例を使って説明します。

同期エンジンを初期化するには、設定オブジェクトを渡します。

設定では、同期するデータベース、同期エンジン状態の最後の既知のバージョン、およびデリゲートを提供する必要があります。

デリゲートプロトコルの機能の1つは、ハンドルイベント関数です。

この機能は、同期エンジンが通常の同期操作中に発生するさまざまなイベントについてアプリに通知する方法です。

たとえば、サーバーから新しいデータを取得したとき、またはアカウントが変更されたときにイベントを投稿します。

これらのイベントの1つは、状態更新イベントです。

同期エンジンが内部状態を更新するとき、または自分で状態を更新すると、同期エンジンは状態更新イベントを投稿します。

このイベントに対応して、この新しいシリアル化されたバージョンの状態をローカルに保持する必要があります。

この例では、次回同期エンジンを初期化するときに、この状態のシリアル化を使用します。

基礎が設定されたので、同期エンジンとの同期について説明します。

サーバーに変更を送信できる簡単な手順がいくつかあります。

まず、保留中のレコードゾーンの変更と保留中のデータベースの変更を同期エンジンの状態に追加します。

これは、同期をスケジュールする必要があることを同期エンジンに警告します。

同期エンジンは一貫性を確保し、これらの変更を重複排除します。

次に、デリゲートメソッドnextRecordZoneChangeBatchを実装します。

同期エンジンはこれを呼び出して、次のレコードゾーンの変更をサーバーに送信します。

最後に、sonsDDatabaseChangesとsandRecordZoneChangesのイベントを処理します。

これらのイベントは、変更がサーバーに送信されると投稿されます。

以下は、サーバーに変更を送信する例です。

このアプリケーションはデータを編集し、新しいレコードの変更を同期したいと考えています。

これを行うには、同期エンジンの状態に保留中のレコードゾーンの変更を追加して、そのレコードを保存する必要があることを同期エンジンに伝えます。

同期エンジンがレコードを同期する準備ができたら、デリゲートメソッドnextRecordZoneChangeBatchを呼び出します。

ここでは、サーバーに送信する変更の次のバッチを返します。

保留中の変更のリストとレコードプロバイダーを提供することで、RecordZoneChangeBatchを初期化します。

保留中の変更のリストには、保存または削除するレコードIDと、実際の同期が発生したときにそれらのIDをレコードにマッピングするレコードプロバイダーが含まれています。

アプリケーションがサーバーから変更を取得する方法は次のとおりです。

同期エンジンは、サーバーから自動的に変更を取得します。

その場合、イベント fetchedDatabaseChanges と fetchedRecordZoneChanges が投稿されます。

ユースケースによっては、willFetchChangesとdidFetchChangesのイベントをリッスンしたい場合があります。

たとえば、これらのイベントを渡すと、変更を取得する前または後にセットアップまたはクリーンアップタスクを実行する場合に便利です。

これは、アプリがサーバーから変更を取得する例です。

同期エンジンがレコードゾーン内で変更を取得すると、fetchedRecordZoneChangesイベントが投稿されます。

このイベントには、別のデバイスによって実行された変更と削除が含まれています。

これを聞くときは、フェッチされた変更とフェッチされた削除を確認する必要があります。

変更を受け取ったら、データをローカルに保持する必要があります。

削除を受け取ったら、ローカルでデータを削除する必要があります。

データベースの変更の取得は非常に同様に機能し、同じアプローチで処理できます。

エラーの処理は難しい場合があります。

同期エンジンもこれに役立ちます。

同期エンジンは、ネットワークの問題、スロットリング、アカウントの問題などの一時的なエラーを自動的に処理します。

同期エンジンは、これらのエラーの影響を受ける作業を自動的に再試行します。

他のエラーについては、アプリがそれらを処理する必要があります。

これらのエラーを解決したら、必要に応じて作業のスケジュールを変更する必要があります。

これは、レコードゾーンの変更を送信する際のエラーハンドリングの例です。

sentRecordZoneChangesイベントが投稿されたら、failedRecordSavesをチェックして、保存に失敗したレコードがあるかどうかを確認する必要があります。

serverRecordChangedは、レコードがサーバー上で変更されたことを示します。

これは、別のデバイスがアプリケーションがまだ取得していない新しいバージョンを保存したことを意味します。

競合を解決し、作業のスケジュールを変更する必要があります。

zoneNotFoundは、ゾーンがサーバーにまだ存在しないことを示します。

これを解決するには、ゾーンを作成し、作業のスケジュールを変更する必要があるかもしれません。

同期エンジンは常に最初にゾーンを保存し、次に記録しようとします。

networkFailure、networkUnavailable、serviceUnavailable、およびrequestRateLimitedは、同期エンジンが処理する一時的なエラーの例です。

あなたはまだあなたの認識のためにこれらのエラーを受け取りますが、それらに応じて行動を起こす必要はありません。

システム条件が許せば、同期エンジンは自動的にこれらのエラーを再試行します。

同期エンジンが役立つもう1つのことは、アカウントの変更です。

iCloudアカウントの変更は、デバイス上でいつでも発生する可能性があります。

同期エンジンは、これらを管理し、反応するのに役立ちます。

同期エンジンは変更をリッスンし、accountChangeイベントを使用して、サインイン、サインアウト、またはアカウントが切り替えられたことを示します。

申請書は、タイプに応じて変更に備える必要があります。

デバイスにアカウントが存在するまで、同期エンジンはiCloudとの同期を開始しません。

同期エンジンはいつでも初期化でき、アカウントの変更があると自動的に更新されます。

他のユーザーとデータを共有することは、CloudKitの重要な部分です。

同期エンジンはここでも生活を楽にします。

同期エンジンはCloudKit共有データベースで動作します。

アプリケーションが動作するデータベースごとに同期エンジンを作成するだけです。

たとえば、プライベートデータベースの同期エンジンと、共有データベースの別の同期エンジンを作成できます。

CloudKitとの共有の詳細については、「CloudKit共有を最大限に活用する」テックトークをチェックしてください。

それはCKSyncEngineの使用をカバーしています。

今、私はそれを使用するときにテストする方法について説明します。

自動テストは、急速に発展しながらコードベースの安定性を確保するための最良の方法です。

同期エンジンを使用すると、複数のCKSyncEngineインスタンスを使用してデバイス間ユーザーフローをシミュレートできます。

アプリが遭遇する可能性のあるエッジケースをシミュレートする必要があります。

これを行うには、automaticSyncをfalseに設定することで、同期エンジンフローに介入できます。

これは、2つのデバイスとサーバー間のデータ競合をシミュレートするテストケースです。

このテストの目的は、複数のデバイスで作業するときにユーザーが取るフルフローをシミュレートすることです。

また、紛争解決を検証します。

まず、MySyncManagerを使用して2つのデバイスをシミュレートします。

この例では、MySyncManagerはローカルデータベースと同期エンジンを作成します。

デバイスAは値をAに設定し、その変更をサーバーに送信します。

デバイスBがサーバーから変更を取得する前に、その変更もサーバーに送信するように依頼します。

デバイスAが最初にサーバーに保存されたため、デバイスBの保存は失敗すると予想されます。

これにより、サーバーレコードの変更エラーが発生し、ローカル競合解決コードが実行されます。

このサンプルは、競合解決がサーバーからのデータを好むことを期待しているため、デバイスBの新しい値は、デバイスAからサーバーに最近送信された値になります。

テストとデバッグをスピードアップするのに役立つ重要なポイントをいくつか紹介します。

各デバイス上の一連のイベントを理解することは、フローのどこにアプリケーションに問題がある可能性があるかを特定するのに役立ちます。

開発時に可能な限りロギングすることは、これらのフローを追跡し、複数のデバイス間でログを比較するのに役立ちます。

CloudKitは受信した各イベントをログに記録しますが、それらを取り巻くアクションもアプリケーションに記録する必要があります。

レコードIDとゾーンIDのロギングは、同期エンジン、サーバー、および同期している可能性のある他のデバイス間で流れているデータをデバッグするのに役立ちます。

各ユーザーフローをシミュレートするテストを書くことは、コードベースを成長させるにつれて安定性を維持するのに役立ちます。

パズルをつなぎ合わせるときは、タイムスタンプを見てください。

同期操作は数回しか行われていないか、短時間で多くの同期操作が行われる可能性があります。

正しいものをトレースしていることを確認することは、複数のデバイス間でデバッグするための鍵です。

これらのステップは、CKSyncEngineを使用して信頼性が高く、長持ちするアプリケーションを作成し、維持するのに役立ちます。

これで、CKSyncEngineに関する講演は終了です。

同期エンジンのサンプルコードを見て、アプリの完全な作業例を確認してください。

より深く掘り下げるには、CKSyncEngineのドキュメントをご覧ください。

同期エンジンを改善するための提案がある場合は、CloudKitチームにフィードバックを提出してください。

私たちはあなたがそれで作るものを見ることに興奮しています。

見てくれてありがとう。素晴らしいWWDCを！

♪ ♪