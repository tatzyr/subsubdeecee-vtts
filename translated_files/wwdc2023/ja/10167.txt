10167

♪ ♪

ベッカ：こんにちは、私はスウィフトチームのベッカです。

今日は、ニーズに合わせてSwift言語をカスタマイズできるエキサイティングな新機能であるSwiftマクロについて話します。

マクロが何のためにあるのかについて話すことから始めます。

次に、Swiftマクロを設計する際に念頭に置いていた原則のいくつかについて話します。

次に、Swiftマクロの仕組みと、プロジェクト内の他のコードと対話する具体的な方法について説明します。

その後、マクロを実装する方法について話し、マクロが正しく機能することを確認する方法について話し合います。

それでは、Swiftがマクロをサポートする理由について話しましょう。

Swiftは、ユーザーが表現力豊かなコードとAPIを書くのが大好きです。

そのため、派生コンフォーマンスや結果ビルダーなどの機能を提供し、ユーザーが反復的なボイラープレートを書くのを避けるのに役立ちます。

これらの機能はすべて基本的に同じように機能します。

たとえば、メンバーに実装を提供せずにCodableに準拠すると、Swiftはプログラムに挿入するメンバーのセットに自動的にコンフォーマンスを拡張します。

灰色のボックスに適合性のための拡張を示しました。

このコードを作成すると、どのように機能するかを正確に知ることなくCodableを使用できるため、Codableサポートを追加すると、画面いっぱいのコードを書く価値があるかどうかを判断する必要はありません。

Swiftには、このように機能する多くの機能があります。

簡単な構文を書くと、コンパイラはそれをより複雑なコードに自動的に展開します。

しかし、既存の機能があなたが望むことができない場合はどうなりますか?

さて、オープンソースなので、Swiftコンパイラに機能を追加できます。

しかし、それは文字通り、私が個人的にビデオ会議に参加し、他のSwiftプロジェクトリーダーとあなたの機能について話し合うことを含むので、それは正確にスケールするプロセスではありません。

それが私たちがマクロを導入している理由です。

独自の言語機能をSwiftに追加し、退屈さと定型文を排除し、コンパイラを変更せずにSwiftパッケージで配布できます。

他の言語でマクロを使ったことがない人もいます。

しかし、あなたが持っているなら、あなたはそれらについて複雑な感情を持っているかもしれません。

これは、多くのSwift開発者がObjective-CまたはCプリプロセッサを使用する他の言語に精通しており、Cマクロの制限と落とし穴について知っているためです。

しかし、Swiftマクロは、これらの問題の多くを回避する方法が大きく異なります。

私たちは4つの目標を念頭に置いてそれらを設計しました。

最初の目標は、マクロを使用しているときにかなり明白であるべきだということです。

マクロには2種類あります。自立型マクロは、コード内の他の何かの代わりに立っています。

彼らはいつもポンド(#)の記号で始まります。

また、添付されたマクロは、コード内の宣言の属性として使用されます。

彼らはいつもat(@)のサインで始まります。

スウィフトはすでにポンド(#)とアット(@)記号を使用して、特別なコンパイラの動作を示します。

マクロはそれを拡張可能にするだけです。

そして、#や@が表示されない場合は、マクロが関与していないと確信できます。

2番目の目標は、マクロに渡されたコードとそこから送り返されたコードの両方が完了し、間違いがないかチェックすることです。

引数は完全な式でなければならないため、マクロに「1 +」を渡すことはできません。

関数の引数と同じように、マクロ引数と結果が型チェックされるため、間違った型で引数を渡すこともできません。

また、マクロの実装は、入力を検証し、何か問題が発生した場合にコンパイラの警告やエラーを発行することができるため、マクロを正しく使用していることを確認する方が簡単です。

3番目の目標は、マクロ拡張を予測可能で追加的な方法でプログラムに組み込むことです。

マクロは、プログラムの目に見えるコードにのみ追加できます。

削除したり変更したりすることはできません。

したがって、「someUnknownMacro」が何をしているのかわからなくても、「finishDoingThingy」の呼び出しを削除したり、新しい機能に移動したりしないことを確認できます。

これにより、マクロを使用するコードが読みやすくなります。

そして、最終的な目標は、マクロが不可解な魔法であってはならないということです。

マクロはプログラムにコードを追加するだけで、Xcodeですぐに見ることができます。

マクロの使用サイトを右クリックして、それが何に展開するかを尋ねることができます。

拡張にブレークポイントを設定したり、デバッガで介入したりできます。

マクロ展開内のコードがコンパイルされない場合、エラーが展開のどこにあるかと、その展開がソースコードのどこにあるかの両方が表示されます。

そして、これらのツールはすべて、マクロがクローズドソースライブラリによって提供されていても機能します。

マクロ作成者は、期待どおりに機能することを確認するために、マクロの単体テストを書くことさえできます。

これらの目標は、開発者がSwiftマクロを理解し、維持しやすくすると考えています。

Swiftマクロが何を達成しようとしているのかを理解したので、その方法について話しましょう。

細部に迷う前に、基本的な概念を書き留めましょう。

Swiftは、Xcodeマクロパッケージテンプレートから「stringify」マクロのように、コード内のマクロを呼び出すのを見ると、コードから使用を抽出し、そのマクロの実装を含む特別なコンパイラプラグインに送信します。

プラグインは安全なサンドボックスで別のプロセスとして実行され、マクロの作成者によって書かれたカスタムSwiftコードが含まれています。

マクロの使用を処理し、マクロによって作成された新しいコードの断片である「拡張」を返します。

その後、Swiftコンパイラは、その拡張をプログラムに追加し、コードと拡張を一緒にコンパイルします。

したがって、プログラムを実行すると、マクロを呼び出すのではなく、自分で展開を書いたかのように機能します。

さて、私がここで隠した重要なポイントがあります。

スウィフトは「ストリンジ化」マクロが存在することをどうやって知りましたか?

そして答えは、それはマクロ宣言から来ています。

マクロ宣言は、マクロのAPIを提供します。

独自のモジュールで宣言を書くことも、ライブラリやフレームワークからインポートすることもできます。

関数宣言と同様に、マクロの名前と署名、パラメータの数、ラベルとタイプ、およびマクロに1つがある場合の結果のタイプを指定します。

また、マクロの役割を指定する1つ以上の属性もあります。

その役割が何であるかを考えずにマクロを書くことは不可能です。

それでは、役割とは何か、異なる役割を使用して異なる種類のマクロを書く方法について話しましょう。

役割は、マクロの一連のルールです。

マクロを適用する場所と方法、展開するコードの種類、その展開がコードに挿入される場所を管理します。

最終的には、予測可能で追加的な方法で拡張を挿入するという目標を達成する責任を負うのは、マクロの役割です。

自立型マクロを作成するには、式と宣言の2つの役割があります。

また、アタッチされたマクロを作成する5つの役割があります。ピア、アクセサ、メンバー属性、メンバー、コンフォーマンスです。

これらの役割と、いつ使うかを見てみましょう。

「自立表現」の役割から始めます。

「式」という用語がベルを鳴らさない場合、式は、実行して結果を生成するコードの単位と呼ばれるものです。

この「let」ステートメントでは、等号の後の算術は式です。

しかし、式は再帰的な構造を持っています - それらはしばしば小さな式で構成されています。

したがって、「x + width」だけでも表現です。

そして、ちょうど「幅」という言葉です。

「自立式」マクロは、式に展開するマクロです。

どうやって使うの？

オプションを強制的に開封する必要があると想像してみてください。

Swiftはforce-unwrap演算子を提供しますが、一部のチームは、安全性を考えずにforce-unwrapを投げるのは少し簡単すぎると感じているので、彼らのスタイルガイドは、値がゼロであってはならない理由を示す、より複雑なものを書くように開発者に指示します。

しかし、「guard let」を使用し、「else」ブランチで「preconditionFailure」を呼び出すなど、これらの選択肢のほとんどは、少しあまりにも多くの儀式です。

これらの極端の間でより良いバランスを取るマクロを設計しましょう。

このマクロに値を計算して返してもらいたいので、「フリースタンディング(式)」マクロにします。

「Unwrap」という名前と、渡された値がオプションですが、返される値が非オプションである汎用型を与えます。

また、アンラップが失敗した場合に印刷されたメッセージの一部である文字列も渡します。

したがって、関数のように呼び出すマクロで終わりますが、クロージャに包まれた「guard let」を含む式に展開されます。

エラーメッセージには変数名も含まれており、通常の関数では不可能です。

自立型表現の役割を見たので、自立型宣言の役割を見てみましょう。

関数、変数、型など、1つ以上の宣言に展開されます。

あなたはそれを何に使うことができますか?

2D配列タイプを必要とするある種の統計分析を書いていると想像してみてください。

配列内のすべての行が同じ数の列を持つようにしたいので、配列の配列は必要ありません。

代わりに、要素をフラットな1次元配列に格納し、開発者が渡した2次元インデックスから1次元インデックスを計算します。

これを行うには、このようなタイプを書くかもしれません。

「makeIndex」関数は、2Dインデックスに必要な2つの整数を受け取り、それらを1Dインデックスに変えるために少し算術を行います。

しかし、プログラムの別の部分では、3次元配列が必要であることがわかります。

2Dアレイとほぼ同じです。

もう少しインデックスがあるだけで、計算はもう少し複雑です。

そして、4Dアレイと5Dアレイが必要で、すぐにほぼ同一の配列タイプで泳いでいますが、ジェネリック、プロトコル拡張、サブクラス、またはSwiftがこの種のもののために提供する他の機能を使用するのに十分なほど近くはありません。

幸いなことに、これらの構造体のそれぞれは宣言であるため、宣言マクロを使用して作成できます。

では、N次元配列タイプを作成するので、「makeArrayND」という名前の自立型宣言マクロを宣言しましょう。

次元の数をIntパラメータとして渡し、このマクロは他のコードで使用される結果を計算するのではなく、プログラムに宣言を追加するため、結果タイプを宣言しません。

これで、2次元、3次元、4次元、5次元でマクロを4回呼び出すことができ、これらの呼び出しのそれぞれは、適切な数の引数とそのサイズに適した計算を持つ多次元配列タイプ全体に展開されます。

これまでのところ、私たちは自立型マクロしか見ていません。

それでは、添付されたマクロのロールに移りましょう。

添付されたマクロは、名前が示すように、特定の宣言に添付されています。

それは、彼らが作業するより多くの情報を持っていることを意味します。

自立型マクロには、渡された引数のみが与えられますが、添付されたマクロは、添付されている宣言にアクセスすることもできます。

彼らはしばしばその宣言を検査し、内部から名前、種類、その他の情報を引き出します。

添付のピアロールから始めます。

ピアマクロは、変数、関数、型だけでなく、インポート宣言や演算子宣言など、任意の宣言に添付でき、それと一緒に新しい宣言を挿入できます。

したがって、メソッドまたはプロパティで使用すると、タイプのメンバーが作成されますが、トップレベルの関数またはタイプで使用すると、新しいトップレベルの宣言が作成されます。

それは彼らを信じられないほど柔軟にします。

ここにあなたがそれらを使うかもしれない1つの方法があります。

Swiftの並行性を使用するライブラリを書いているが、一部のクライアントがまだ古い並行性技術を使用していることを知っているので、完了ハンドラを使用するAPIのバージョンを提供したいとします。

これらの方法を書くのは難しくありません。

「Async」キーワードを削除し、完了ハンドラパラメータを追加し、結果タイプをパラメータリストに移動し、切り離されたタスクで非同期バージョンを呼び出すだけです。

しかし、あなたはこれをたくさんやっていて、手で書く必要はありません。

それは添付されたピアマクロにとって素晴らしい仕事です。

「AddCompletionHandler」と呼ばれるものを宣言し、完了ハンドラーの引数ラベルのパラメータを与え、そのマクロをメソッドの非同期バージョンに添付します。

マクロは、オリジナルと同等の完了ハンドラベースの署名を作成し、メソッド本文を書き、完了ハンドラ用の余分なテキストを含むドキュメントコメントを添付します。

かなりかっこいい。

次に、添付のアクセサの役割を見てみましょう。

これらは変数や添字に添付でき、「get」、「set」、「willSet」、または「didSet」などのアクセサをそれらにインストールできます。

では、それはどのように役に立つのでしょうか?

基本的に辞書をラップし、プロパティでそのコンテンツにアクセスできるタイプの束があるとします。

たとえば、この「Person」構造体を使用すると、「name」、「height」、「birth_date」フィールドにアクセスできますが、これらの3つのフィールド以外に辞書に他の情報がある場合は、プログラムによって保存され、無視されます。

これらの3つのプロパティには計算されたゲッターとセッターが必要ですが、手で書くのは面倒で、プロパティラッパーは使用されているタイプの他の保存されたプロパティにアクセスできないため、プロパティラッパーを使用できません。

それでは、これに役立つ付属のアクセサマクロを書いてみましょう。

私たちはそれを「DictionaryStorage」と呼びます。

辞書は「birth_date」をアンダースコアで綴るため、「キー」パラメータを与えますが、キーを除外することもできます。デフォルトはnilになり、マクロはプロパティの名前をキーとして使用します。

だから今、その大きなアクセサブロックを書く代わりに、各プロパティの前に「@DictionaryStorage」を置くだけで、マクロがあなたのためにアクセサを生成します。

それは素晴らしい改善ですが、ここにはまだいくつかのボイラープレートがあります:同一の「DictionaryStorage」属性。

それらはより少ない定型板ですが、それでも定型板です。

一部の組み込み属性を使用すると、タイプまたは拡張機能全体に適用することで、この種の状況に対処できます。

「アタッチメンバー属性」の役割は、マクロもそのように振る舞うことができます。

マクロは型または拡張子にアタッチされ、アタッチされているもののメンバーに属性を追加できます。

それがどのように行われるか見てみましょう。

私たちはここで少し違うことをするつもりです。

新しいマクロを宣言するのではなく、すでに持っている「アタッチされたアクセサー」ロールと一緒に、「DictionaryStorage」マクロに別のロール属性を追加します。

これはマクロを作成するための本当に便利なテクニックです。

スウィフトがどちらを使用すべきかわからない場所があるため、2つの自立型の役割を除いて、役割の任意の組み合わせを構成することができます。

Swiftは、どこに適用しても意味のあるすべての役割を拡大しますが、少なくとも1つの役割はそこで働かなければなりません。

したがって、タイプに「DictionaryStorage」をアタッチすると、Swiftは「メンバー属性」の役割を展開します。

プロパティにアタッチすると、Swiftは「アクセサー」の役割を拡張します。

しかし、関数にアタッチすると、「DictionaryStorage」には関数にアタッチできるロールがないため、コンパイルエラーが発生します。

この2番目の役割を「DictionaryStorage」に追加すると、すべてのプロパティに個別に添付する代わりに、タイプ全体に添付できます。

マクロには、初期化子、「dictionary」プロパティ、およびすでに「DictionaryStorage」属性を持つ「birth_date」などのプロパティなど、特定のメンバーをスキップするロジックがあります。

しかし、他の保存されたプロパティに「DictionaryStorage」属性を追加し、それらの属性は私たちがすでに見たアクセサに展開されます。

それは素晴らしい改善ですが、排除できる定型文はまだあります。初期化子と保存されたプロパティです。

これらは「DictionaryRepresentable」プロトコルで必要とされ、プロパティはアクセサによって使用されますが、DictionaryStorageを使用するどのタイプでもまったく同じです。

DictionaryStorageマクロに自動的に追加して、手で書く必要がないようにしましょう。

「アタッチメンバー」の役割を使ってそれを行うことができます。

メンバー属性マクロと同様に、これらのマクロをタイプと拡張に適用できますが、既存のメンバーに属性を追加する代わりに、まったく新しいメンバーを追加します。

そのため、メソッド、プロパティ、初期化子などを追加できます。

保存されたプロパティをクラスや構造体に追加したり、ケースを列挙に追加したりすることもできます。

もう一度、DictionaryStorageマクロに新しい「アタッチメンバー」ロールを追加し、他の2つと一緒に構成します。

この新しいロールは、初期化子と「辞書」というプロパティを追加します。

2つの異なるマクロが同じコードに適用されると、どちらが最初に展開されるのか疑問に思うかもしれません。

答えは、それは本当に問題ではないということです。

それぞれが、他の人から提供された拡張なしで宣言のオリジナルバージョンを見るでしょう。

だから、注文について心配する必要はありません。

コンパイラがいつマクロを展開しても、同じものが表示されます。

添付のメンバーの役割が追加されると、その2人のメンバーを書く必要さえありません。

タイプでDictionaryStorageを使用するだけで、自動的に追加されます。

そして、他の役割はプロパティにDictionaryStorage属性を追加し、それらの属性はアクセサに展開されます。

しかし、排除すべき定型文の最後のビットがまだ1つあります。DictionaryRepresentableプロトコルへの適合性です。

「アタッチコンフォーマンス」の役割は、これに最適です。

タイプまたは拡張機能に適合性を追加できます。

「DictionaryStorage」マクロに最後の「添付コンフォーマンス」ロールを追加し、他の3つと一緒に構成します。

この新しい役割は、「DictionaryRepresentation」への適合性を追加します。

だから今、私たちは手動で適合性を書く必要はありません。

アクセサと生成されたメンバーにすでに追加したDictionaryStorage属性は、すでに行っていた他のすべてのものとともに、適合性も自動的に追加されます。

出発点を見てから長い時間が経っているので、あなたに思い出させるために、私たちは反復的なコードでいっぱいの大きな、手に負えないタイプを取り、そのコードのほとんどを超強力なマクロのいくつかの役割に移動して、この特定のタイプの特別なものだけを簡潔に指定しました。

DictionaryStorageを使用できる10種類または20種類があると想像してみてください。

それらすべてと一緒に仕事をするのはどれくらい簡単ですか?

私たちは今、宣言と役割について話すのに多くの時間を費やしてきましたが、これまでのところ、彼らが拡張するコードは魔法のように現れているように見えました。

今、そのギャップを埋めて、マクロの実装方法について話しましょう。

これまでにマクロ宣言を見せたとき、私は非常に重要なことを省略しました：実装。

それは等号の後であり、常に別のマクロです。

時には、パラメータを再配置したり、リテラルとして指定された余分なパラメータで、あなたが書いた別のマクロです。

しかし、通常、外部マクロを使用します。

外部マクロは、コンパイラプラグインによって実装されるものです。

先ほどコンパイラプラグインについて話したことを覚えているかもしれません。

私は、コンパイラがマクロが使用されているのを見ると、別のプロセスでプラグインを開始し、マクロを展開するように要求すると言いました。

「#externalMacro」は、その関係を定義するものです。

コンパイラが起動するプラグインと、そのプラグイン内の型の名前を指定します。

したがって、Swiftがこのマクロを拡張すると、「MyLibMacros」というプラグインを起動し、「StringifyMacro」というタイプに展開を依頼します。

したがって、マクロ宣言は他のAPIと一緒に通常のライブラリに入りますが、マクロの実装は別のコンパイラプラグインモジュールに入ります。

そして、「#externalMacro」は、宣言とそれを実装するタイプの間のリンクを作成します。

マクロの実装はどのようなものですか?

さて、DictionaryStorageがどのように実装されるかを見てみましょう。

思い出せば、「DictionaryStorage」マクロには、格納されたプロパティと初期化子をタイプに追加した「添付メンバー」ロールがありました。

これがその役割の簡単な実装です。

私たちはそれを一歩ずつ歩き、それがどのように機能するかを学びます。

一番上で、SwiftSyntaxというライブラリをインポートすることから始めます。

SwiftSyntaxは、Swiftソースコードの解析、検査、操作、生成に役立つSwiftプロジェクトによって維持されているパッケージです。

Swiftコントリビューターは、言語が進化するにつれてSwiftSyntaxを最新の状態に保つため、Swiftコンパイラが行うすべての機能をサポートします。

SwiftSyntaxは、ソースコードを特別なツリー構造として表します。

たとえば、このコードサンプルの「Person」構造体は、「StructDeclSyntax」と呼ばれる型のインスタンスとして表されます。

しかし、そのインスタンスにはプロパティがあり、それらのプロパティのそれぞれは構造体宣言の一部を表します。

属性のリストは「属性」プロパティにあります。

実際のキーワード「struct」は「structKeyword」プロパティにあります。

構造体の名前は「識別子」プロパティにあります。

そして、波括弧と構造体のメンバーを持つ体は「memberBlock」プロパティにあります。

一部の構造体宣言が持つものを表す「修飾子」のようなプロパティもあります。

しかし、これはそうではありません。これらはゼロです。

これらのプロパティの構文ノードのいくつかは「トークン」と呼ばれています。

これらは、名前、キーワード、または少しの句読点など、ソースファイル内の特定のテキストを表し、そのテキストとスペースやコメントなどの周囲のトリビアが含まれています。

構文ツリーを十分に掘り下げると、ソースファイルのすべてのバイトをカバーするトークンノードが見つかります。

しかし、「attributes」プロパティの「AttributeListSyntax」ノードや「memberBlock」プロパティの「MemberDeclBlockSyntax」ノードなど、これらのノードのいくつかはトークンではありません。

これらは、独自のプロパティに子ノードを持っています。

たとえば、「memberBlock」プロパティ内を調べると、開始中括弧のトークン、メンバーリストの「MemberDeclListSyntax」ノード、および終了中括弧のトークンが見つかります。

そして、その「MemberDeclListSyntax」ノードの内容を探索し続けると、最終的に各プロパティのノードなどを見つけることができます。

SwiftSyntaxでの作業はそれ自体が大きなトピックなので、このビデオを2倍長くするのではなく、他の2つのリソースを紹介します。

1つは、コンパニオン「Write Swift Macros」セッションで、特定のソースコードが構文ツリーとしてどのように表現されるかを理解するための実用的なヒントが含まれています。

もう1つは、SwiftSyntaxパッケージのドキュメントです。

オンラインで見つけるか、マクロパッケージでXcodeのBuild Documentationコマンドを使用すると、SwiftSyntaxドキュメントが開発者ドキュメントウィンドウに表示されます。

メインのSwiftSyntaxライブラリに加えて、他の2つのモジュールもインポートします。

1つは、マクロを書くために必要なプロトコルとタイプを提供する「SwiftSyntaxMacros」です。

もう1つは「SwiftSyntaxBuilder」と呼ばれています。

このライブラリは、新しく生成されたコードを表す構文ツリーを構築するための便利なAPIを提供します。

マクロは使用せずに書くことができますが、非常に便利で、それを利用することを強くお勧めします。

これらのライブラリをインポートしたので、プラグインが提供するはずの「DictionaryStorageMacro」タイプを実際に書き始めます。

「MemberMacro」と呼ばれるプロトコルに準拠していることに注意してください。

各ロールには対応するプロトコルがあり、実装はマクロが提供する各ロールのプロトコルに準拠している必要があります。

「DictionaryStorage」マクロにはこれらの役割の4つがあるため、「DictionaryStorageMacro」タイプは、対応する4つのプロトコルに準拠する必要があります。

しかし、物事をシンプルにするために、私たちは今のところ「MemberMacro」の適合性を心配しているだけです。

このタイプの本体に移動すると、「expansion of, providingMembersOf, in」という方法が見られます。

このメソッドはMemberMacroプロトコルによって必要であり、マクロが使用されるときにメンバーの役割を展開するためにSwiftコンパイラが呼び出すものです。

私たちはまだ議論を使用していませんが、後でそれらについて話します。

今のところ、それが静的な方法であることに注目してください。

すべての拡張メソッドは静的であるため、Swiftは実際にDictionaryStorageMacroタイプのインスタンスを作成しません。

メソッドのコンテナとして使用するだけです。

各拡張メソッドは、ソースコードに挿入されたSwiftSyntaxノードを返します。

メンバーマクロは、タイプにメンバーとして追加する宣言のリストに展開されるため、メンバーマクロの展開メソッドは「DeclSyntax」ノードの配列を返します。

体の中を見ると、その配列が作成されていることがわかります。

このマクロを追加したい初期化子と保存されたプロパティがあります。

さて、ここの「var辞書」ビットは普通の文字列のように見えますが、実際にはそうではありません。

この文字列リテラルはDeclSyntaxが期待される場所に書かれているので、Swiftは実際にそれをソースコードの断片として扱い、SwiftパーサーにDeclSyntaxノードに変えるように依頼します。

これは、SwiftSyntaxBuilderライブラリが提供する便利な機能の1つです。

もっと早く輸入してよかった。

そのため、他の3つの役割のプロトコルに準拠して、DictionaryStorageマクロの実用的な実装があります。

しかし、このマクロは正しく使用すると機能しますが、間違って使用するとどうなりますか?

たとえば、構造体ではなく列挙型に適用しようとするとどうなりますか?

さて、「アタッチメンバー」ロールは、保存された「辞書」プロパティを追加しようとします。

しかし、列挙型は保存されたプロパティを持つことができないので、Swiftは「Enumsは保存されたプロパティを含んではならない」というエラーを生成します。

Swiftがこのコードのコンパイルを停止するのは素晴らしいことですが、エラーメッセージは少し混乱していますね。

なぜDictionaryStorageマクロがストアドプロパティを作成しようとしたのか、または何を違う方法で行うべきだったのかは明らかではありません。

先ほど、Swiftの目標の1つは、マクロが入力の間違いを検出し、カスタムエラーを発生させることだと言いました。

では、マクロの実装を変更して、より明確なエラーメッセージを生成しましょう。「@DictionaryStorageは構造体にのみ適用できます。」

これにより、開発者は何が間違ったのかをよりよく知ることができるでしょう。

これを行うための鍵は、これまで無視してきた拡張メソッドのパラメータです。

正確な議論は役割によってわずかに異なりますが、メンバーマクロには3つあります。

1つ目は「属性」と呼ばれ、その型はAttributeSyntaxです。

これは、開発者がマクロを使用するために書いた実際のDictionaryStorage属性です。

2番目の引数は「宣言」と呼ばれ、「DeclGroupSyntax」に準拠した型です。

DeclGroupSyntaxは、構造体、列挙型、クラス、アクター、プロトコル、および拡張機能のノードがすべて準拠するプロトコルです。

したがって、このパラメータは、開発者が属性を添付した宣言を提供します。

そして、最後のパラメータは「context」と呼ばれ、「MacroExpansionContext」に準拠したタイプです。

コンテキストオブジェクトは、マクロ実装がコンパイラと通信したいときに使用されます。

エラーや警告の発行など、いくつかの異なることを行うことができます。

これら3つのパラメータすべてを使用してエラーを発行します。

それがどのように行われるか見てみましょう。

まず、問題を検出する必要があります。

これを行うには、「宣言」パラメータのタイプをチェックします。

宣言の種類ごとに異なる型があるので、それが構造体であれば、その型は「StructDeclSyntax」、列挙型であれば「EnumDeclSyntax」などになります。

そこで、「宣言」パラメータの「is」メソッドを呼び出し、「StructDeclSyntax」を渡すguard-elseを書きます。

宣言が構造体でない場合は、「else」ブロックになります。

今のところ、空の配列を返すので、マクロはプロジェクトにコードを追加しませんが、私たちが本当にやりたいことはエラーを出すことです。

さて、それを行う簡単な方法は、通常のSwiftエラーをスローすることですが、それは出力をあまり制御することはできません。

代わりに、より洗練されたエラーを作成できる、より複雑な方法を紹介します。

最初のステップは、「診断」というタイプのインスタンスを作成することです。

これはちょっとしたコンパイラの専門用語です。

壊れた足のX線を見ている医師が骨折を診断するように、壊れたコードの構文ツリーを見ているコンパイラまたはマクロはエラーまたは警告を診断します。

したがって、エラーを表すインスタンスを「診断」と呼びます。

診断には少なくとも2つの情報が含まれています。

1つ目は、エラーが発生した構文ノードなので、コンパイラはどの行を不正確としてマークするかを知っています。

ここでは、ユーザーが書いたDictionaryStorage属性を指摘したいと思います。これは、幸いなことに、メソッドが渡された「属性」パラメータによって提供されます。

2つ目は、コンパイラに生成させたい実際のメッセージです。

カスタムタイプを作成し、そのインスタンスを渡すことで、これを提供します。

ざっと見てみましょう。 

「MyLibDiagnostic」タイプは、このモジュールが生成できるすべての診断を定義します。

列挙型を使用し、各診断にケースを提供することを選択しましたが、必要に応じて別の種類のタイプを使用できます。

このタイプは、スロー可能なSwiftエラーのように機能します。

「DiagnosticMessage」プロトコルに準拠しており、診断に関する情報を提供する多くのプロパティがあります。

最も重要なものの1つは「重大度」の特性です。

診断がエラーか警告かを指定します。

次に、実際のエラーメッセージを生成する「message」プロパティと「diagnosticID」プロパティがあります。

ドメインにはプラグインのモジュール名を使用し、IDには何らかの一意の文字列を使用する必要があります。

この列挙型に文字列の生値を使用することを選択しましたが、それは単なる利便性です。

したがって、メッセージを手にして、診断を作成できます。

その後、それを診断するためにコンテキストを指示し、完了です。

それはかなり基本的な診断ですが、あなたが望むなら、あなたは彼らと一緒に多くのファンシーを得ることができます。

たとえば、Xcode Fixボタンによって自動的に適用される診断にFix-Itsを追加できます。

ハイライトを追加したり、コード内の他の場所を指すメモを添付したりすることもできます。

そのため、開発者に一流のエラー体験を提供できます。

しかし、マクロが正しく適用されていることを確認したら、実際に展開を作成する必要があります。

SwiftSyntaxは、それを行うためのいくつかの異なるツールを提供します。

構文ノードは不変ですが、新しいノードを作成するか、既存のノードの修正バージョンを返すAPIがたくさんあります。

SwiftSyntaxBuilderライブラリは、子ノードの一部が末尾のクロージャによって指定されるSwiftUIスタイルの構文ビルダーを追加します。

たとえば、多次元配列マクロは、構文ビルダーを使用して、作成するタイプに適した数のパラメータを生成できます。

また、DictionaryStorageプロパティと初期化子を作成するために使用した文字列リテラル機能も補間をサポートしています。

これらの機能はすべてさまざまな状況で有用であり、おそらく特に複雑なマクロでいくつかを組み合わせることに気付くでしょう。

しかし、文字列リテラル機能は、大量のコードの構文ツリーを生成するのに特に得意であり、その補間機能について学ぶべき点が少しあります。

では、それらを使用してコードを生成する方法を見てみましょう。

先ほど、「アンラップ」マクロについて話しました。

オプションの値とメッセージ文字列を受け取り、クロージャでラップされた「ガードレット」に展開されます。

このコードの一般的な形状は常に同じですが、多くのコンテンツは特定の使用サイトに合わせてカスタマイズされています。

「Guard let」ステートメントに焦点を当てて、そのステートメントだけを生成する関数を書く方法を見てみましょう。

まず、先ほど見た正確なコードサンプルを取り、ステートメント構文ノードを返す「makeGuardStatement」と呼ばれるヘルパーメソッドに入れます。

次に、使用場所に応じて異なる必要があるすべてのものを置き換えるために、ゆっくりと補間を追加します。

最初に行うことは、正しいメッセージ文字列を追加することです。

メッセージ文字列は任意の式なので、ExprSyntaxノードとして渡してから補間します。

このような通常の補間では、コードに構文ノードを追加できますが、プレーンな文字列を追加することはできません。

これは、誤って無効なコードを挿入するのを防ぐための安全機能です。

Guard-letの条件は似ていますが、単なる変数名なので、式ではなくトークンです。

関係なく、式を補間したのと同じように、TokenSyntaxパラメータを追加して補間します。

ラップされていない式をエラーメッセージに追加すると、よりトリッキーなケースがあります。

マクロの特徴の1つは、失敗すると、解明しようとしていたコードが出力されることです。

つまり、構文ノードの文字列化されたバージョンを含む文字列リテラルを作成する必要があります。

まず、プレフィックスをステートメント構文のリテラルから引き出して、単なる文字列である変数にしましょう。

その文字列を補間しますが、「リテラル:」で始まる特別な補間を使用します。

これを行うと、SwiftSyntaxは文字列の内容を文字列リテラルとして追加します。

これは、マクロ、数値、ブール値、配列、辞書、さらにはオプションによって計算された他の種類の情報からリテラルを作成するためにも機能します。

変数に文字列を構築したので、メッセージに適切なコードを持つように変更できます。

元の式のパラメータを追加し、その「説明」プロパティを文字列に補間するだけです。

あなたはそれを逃れるために特別なことをする必要はありません。

「リテラル:」補間は、文字列に特殊文字が含まれているかどうかを自動的に検出し、エスケープを追加するか、コードが有効であることを確認するために生のリテラルに切り替えます。

したがって、「リテラル」補間により、正しいことを非常に簡単に行うことができます。

最後に対処すべきことは、ファイルと行番号です。

コンパイラは、展開しているソースの場所をマクロに伝えないため、これらは少しトリッキーです。

ただし、マクロ拡張コンテキストには、コンパイラがソース位置情報を持つリテラルに変わる特別な構文ノードを生成するために使用できるAPIがあります。

では、それがどのように行われるか見てみましょう。

マクロ展開コンテキストに別の引数を追加し、その「場所」メソッドを使用します。

これは、提供するノードの場所の構文ノードを生成できるオブジェクトを返します。

ノードがコンパイラがあなたに渡したノードではなく、マクロが作成したノードである場合はnilを返しますが、「originalWrapped」はユーザーが書いた引数の1つであることを知っているので、その場所は決してnilではなく、結果を安全に強制解除できます。

今、あなたがしなければならないのは、ファイルと行番号の構文ノードを補間することだけで完了です。

私たちは今、正しい「ガード」ステートメントを生成しています。

これまでのところ、マクロを機能させる方法について議論しました。

しかし、先に進んで、それらをうまく機能させる方法について話しましょう。

そして、名前の衝突について話すことから始めます。

前に「アンラップ」マクロを見たとき、単純な変数名をアンラップした例を見ました。

しかし、より複雑な表現を展開しようとすると、マクロは異なる方法で展開する必要があります。

式の結果を「wrappedValue」と呼ばれる変数にキャプチャするコードを生成し、それをアンラップします。

しかし、メッセージで「wrappedValue」という変数を使用しようとするとどうなりますか?

コンパイラが「wrappedValue」を探しに行くと、より近いものを見つけることになるので、実際に意味したものの代わりにそれを使用します。

ユーザーがおそらく偶然に使用しないと思う名前を選んで、これを修正しようとすることができますが、これを不可能にした方が良いのではないでしょうか?

それが、マクロ展開コンテキストの「makeUniqueName」メソッドが行うことです。

ユーザーコードやその他のマクロ展開で使用されないことが保証されている変数名を返すので、メッセージ文字列が誤って参照されないことを確認できます。

なぜスウィフトは自動的にそれが起こるのを止めないのか、疑問に思う人もいるかもしれません。

一部の言語には、いわゆる「衛生的な」マクロシステムがあり、マクロ内の名前は外部の名前とは異なるため、互いに競合することはできません。

Swiftは、多くのマクロが外部からの名前を使用する必要があることがわかったので、そうではありません。

タイプに「辞書」プロパティを使用するDictionaryStorageマクロを考えてみてください。

マクロ内の「辞書」が外部の「辞書」とは異なることを意味する場合、それを機能させるのはかなり難しいでしょう。

また、非マクロコードがアクセスできるまったく新しい名前を導入したい場合もあります。

ピアマクロ、メンバーマクロ、および宣言マクロは、基本的にこれを行うために完全に存在します。

しかし、彼らがそうするとき、彼らは追加している名前を宣言する必要があるので、コンパイラはそれらについて知っています。

そして、彼らは彼らの役割属性の中でそれを行います。

あなたは以前にそれに気付かなかったかもしれませんが、私たちは実際にこれらの宣言をずっと見てきました。

DictionaryStorageマクロの「メンバー」ロールには、「dictionary」と「init」という名前を指定する「names:」パラメータがありました。

実際、このセッションで見たマクロのほとんどは、「名前」の引数を持つ少なくとも1つの役割を持っています。

使用できる5つの名前指定子があります。「オーバーロード」とは、マクロがマクロが添付されているのとまったく同じ基本名で宣言を追加することを意味します。

「プレフィックス」とは、指定されたプレフィックスが追加された場合を除き、マクロが同じベース名の宣言を追加することを意味します。

「接尾辞付き」は、接頭辞の代わりに接尾辞を除いて、同じものです。

「Named」とは、マクロが特定の固定基本名で宣言を追加することを意味します。

そして、「任意」とは、マクロがこれらのルールのいずれを使用しても記述できない他の名前で宣言を追加することを意味します。

「恣意的」を使うのは本当に一般的です。

たとえば、多次元配列マクロは、そのパラメータの1つから計算された名前を持つ型を宣言するので、「任意」を指定する必要があります。

しかし、他の指定子の1つを使用できる場合は、そうしてください。

コンパイラとコード補完などの他のツールの両方が速くなります。

さて、セッションのこの時点で、皆さんは最初のマクロを書きたがっていると思います。

そして、あなたは始める方法の素晴らしいアイデアを持っているかもしれません:それが展開された日付と時刻を挿入するマクロを書くだけです。

いい考えだよね？

間違っています。

結局のところ、このマクロを書いてはいけません。

理由を説明させてください。

マクロは、コンパイラが提供する情報のみを使用する必要があります。

コンパイラは、マクロ実装は純粋な関数であり、提供したデータが変更されていない場合、展開も変更できないことを前提としています。

それを回避すると、一貫性のない行動が見られるかもしれません。

現在、マクロシステムは、このルールに違反する可能性のあるある種の行動を防ぐように設計されています。

コンパイラプラグインは、マクロ実装がディスク上のファイルを読んだり、ネットワークにアクセスしたりするのを停止するサンドボックスで実行されます。

しかし、サンドボックスはすべての悪い行動をブロックするわけではありません。

APIを使用して日付や乱数などの情報を取得することも、ある展開からの情報をグローバル変数に保存して別の展開で使用することもできます。

しかし、これらのことをすると、マクロが誤動作する可能性があります。

だから、しないでください。

最後になりましたが、テストについて話しましょう。

あなたのマクロプラグインは普通のSwiftモジュールです。つまり、通常の単体テストを書くことができ、間違いなく書くべきです。

テスト駆動開発は、Swiftマクロを開発するための非常に効果的なアプローチです。

SwiftSyntaxMacrosTestSupportの「assertMacroExpansion」ヘルパーは、マクロが適切な展開を生成することを確認します。

マクロと展開すべきコードの例を挙げるだけで、それらが一致することを確認します。

だから、私たちは今日、Swiftマクロについて多くのことを学びました。

マクロを使用すると、小規模な使用サイトをより複雑なコードに「拡張」する新しい言語機能を設計することで、定型文を減らすことができます。

通常、ライブラリで他のAPIと一緒にマクロを宣言しますが、実際には安全なサンドボックスでSwiftコードを実行する別のプラグインで実装します。

マクロの役割は、それを使用できる場所と、その拡張がプログラムの残りの部分にどのように統合されているかを表します。

そして、期待どおりに機能することを確認するために、マクロの単体テストを書くことができますし、間違いなく書くべきです。

まだ見ていない場合は、「Write Swift Macros」セッションが次の目的地になるはずです。

Xcodeのマクロ開発ツールとマクロパッケージテンプレートの操作方法、SwiftSyntaxツリーを検査して情報を引き出す方法、ユニットテストを中心にマクロ開発ワークフローを構築する方法を紹介します。

だから、見てくれてありがとう、そして幸せなコーディング。

♪ ♪