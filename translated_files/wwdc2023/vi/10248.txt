10248

♪ ♪

Joachim Kurz: Chào mừng đến với "Phân tích treo bằng nhạc cụ."

Tên tôi là Joachim, và tôi là một kỹ sư làm việc trong nhóm Nhạc cụ.

Hôm nay, chúng tôi muốn xem xét kỹ hơn về Hangs.

Đầu tiên, tôi sẽ cung cấp cho bạn một cái nhìn tổng quan về hang là gì, và để làm như vậy, chúng ta sẽ cần nói về nhận thức của con người.

Sau đó, tôi sẽ nói ngắn gọn về vòng lặp xử lý sự kiện và kết xuất, vì nó tạo thành cơ sở để hiểu cách treo được gây ra.

Được trang bị kiến thức lý thuyết này, chúng ta sẽ nhảy vào Dụng cụ và xem xét ba ví dụ treo khác nhau: treo chủ đề chính bận rộn, treo không đồng bộ và treo chủ đề chính bị chặn.

Đối với mỗi thứ này, tôi sẽ chỉ cho bạn cách nhận ra chúng, những gì cần tìm khi phân tích chúng và cách biết khi nào nên thêm các công cụ khác vào tài liệu của bạn để tìm hiểu thêm.

Trước khi chúng ta bắt đầu: đối với một phần của phiên này, thật hữu ích khi làm quen với Dụng cụ.

Nếu bạn đã từng lập hồ sơ ứng dụng với Instruments, bạn nên sử dụng.

Nếu không, hãy xem phiên 2019 của chúng tôi, "Bắt đầu với các công cụ." Khi xử lý treo: thường có ba bước.

Bạn tìm thấy một cái treo, sau đó bạn phân tích một cái treo để hiểu nó xảy ra như thế nào, và sau đó bạn sửa nó, (và xác minh nó thực sự đã được sửa).

Hôm nay chúng tôi sẽ cho rằng bạn đã tìm thấy một hang và tập trung vào phần phân tích, cũng như thảo luận về một số bản sửa lỗi.

Nếu bạn muốn biết thêm về việc tìm kiếm hangs, hãy xem phiên của chúng tôi, "Theo dõi hangs với Xcode và phát hiện trên thiết bị" từ WWDC22.

Nó bao gồm tất cả các công cụ của chúng tôi để tìm treo, bao gồm: Dụng cụ, Phát hiện treo trên thiết bị, mà bạn có thể bật trong cài đặt Nhà phát triển iOS và Trình tổ chức Xcode.

Hôm nay, chúng tôi sẽ sử dụng Dụng cụ để phân tích một hang mà chúng tôi đã tìm thấy.

Để hiểu rõ hơn về treo, hãy nói về nhận thức của con người và bật đèn lên.

Chúng ta cần một bóng đèn và một dây cáp.

À, tốt hơn nhiều.

Giống như một chiếc đèn, nó bật lên khi tôi cắm cáp.

Và khi tôi kéo nó ra một lần nữa, nó tắt. Ngay lập tức.

Nhưng nếu có sự chậm trễ thì sao?

Tôi cắm nó vào.

Và ở đây phải mất một chút thời gian để bật lên.

Thậm chí còn kỳ lạ hơn, điều tương tự cũng xảy ra khi tôi rút cáp ra một lần nữa.

Độ trễ giữa cáp được cắm vào và đèn bật chỉ là 500 mili giây.

Nhưng nó đã khiến bạn tự hỏi chuyện gì đang xảy ra bên trong chiếc hộp này.

Cảm giác không ổn khi đèn không bật và tắt trực tiếp.

Tuy nhiên, trong một số trường hợp khác, độ trễ 500 mili giây có thể ổn.

Loại chậm trễ nào có thể chấp nhận được tùy thuộc vào hoàn cảnh.

Giả sử bạn tình cờ nghe được một cuộc trò chuyện như thế này: "Rùa giao tiếp như thế nào?"

"Điện thoại vỏ.

Ở đây, chúng tôi đã có độ trễ một giây giữa câu hỏi và câu trả lời.

Và điều đó cảm thấy hoàn toàn tự nhiên.

Nhưng điều này không xảy ra: Tại sao vậy?

Cuộc trò chuyện giữa con rùa và con kỳ lân là một sự tương tác theo phong cách yêu cầu-phản hồi, nhưng cắm đèn trực tiếp thao tác với một vật thể thực.

Các đối tượng thực phản ứng ngay lập tức.

Nếu chúng ta mô phỏng một thứ có thật, nó cũng cần phản ứng ngay lập tức.

Nếu không, nó sẽ phá vỡ ảo ảnh.

Bạn không có vấn đề gì với việc tôi tuyên bố rằng tôi có một chiếc đèn thực sự ở đây khi không có độ trễ giữa cáp được cắm và đèn bật.

Nhưng khi có một sự chậm trễ đáng kể, bộ não của bạn đột nhiên nói, "Chờ một chút, đó không phải là cách thức hoạt động của thứ này."

Nhưng tức thì nhanh như thế nào?

Sự chậm trễ nào đủ nhỏ để chúng ta không nhận ra?

Đây là đường cơ sở của chúng tôi mà không có sự chậm trễ.

100 ms thì sao?

Đối với tôi, có cảm giác như tôi nhận thấy một sự chậm trễ nhỏ trong việc bật nó lên, nhưng không phải khi tắt nó đi, và chỉ khi tôi nhìn kỹ.

Trải nghiệm của bạn có thể khác.

100 ms phần nào là ngưỡng.

Sự chậm trễ nhỏ hơn đáng kể không thực sự có thể cảm nhận được nữa.

Hãy thử 250 ms.

250 ms không còn cảm thấy tức thì nữa.

Nó không chậm, nhưng sự chậm trễ chắc chắn là đáng chú ý.

Những loại ngưỡng nhận thức này cũng thông báo cho báo cáo treo của chúng tôi.

Độ trễ dưới khoảng 100 ms cho một tương tác rời rạc, như nhấn vào một nút, thường sẽ cảm thấy tức thì.

Có một số trường hợp đặc biệt mà bạn có thể muốn đi ngay cả dưới mức đó, nhưng đó là một mục tiêu tốt để nhắm đến.

Trên hết, nó phụ thuộc vào hoàn cảnh.

Cho đến 250 ms, bạn có thể thoát khỏi nó.

Lâu hơn thế và nó trở nên đáng chú ý, ít nhất là trong tiềm thức.

Đó là một thang đo liên tục, nhưng trên 250 ms, nó chắc chắn không còn cảm thấy tức thì nữa.

Vì vậy, hầu hết các công cụ của chúng tôi bắt đầu báo cáo treo theo mặc định bắt đầu từ 250 ms, nhưng chúng tôi gọi những "hang vi mô" này vì chúng rất dễ bỏ qua.

Tùy thuộc vào ngữ cảnh, những thứ đó có thể ổn, nhưng thường thì không.

Mọi thứ trên 500 ms chúng tôi coi là một hang thích hợp.

Dựa trên điều này, chúng ta có thể sử dụng đại khái các ngưỡng này: Nếu bạn muốn thứ gì đó cảm thấy tức thì, hãy nhắm đến độ trễ 100 ms hoặc ít hơn.

Nếu bạn có tương tác kiểu yêu cầu-phản hồi, 500 ms mà không có bất kỳ phản hồi bổ sung nào có thể ổn.

Nhưng thực ra, chúng ta thường có cả hai trong một tương tác.

Hãy xem xét một ví dụ.

Tôi vừa viết xong email này cho tất cả các đồng nghiệp đã giúp chuẩn bị phiên này và tôi đã sẵn sàng gửi nó.

Tôi di chuyển chuột qua nút Gửi và nhấp vào nút đó và một lát sau, cửa sổ email hoạt hình để cho biết nó đang được gửi.

Điều đã xảy ra ở đây là bạn thực sự đã thấy hai điều xảy ra.

Đầu tiên, nút được tô sáng, sau đó có độ trễ nhỏ 500 ms, sau đó là cửa sổ email hoạt hình.

Nhưng sự chậm trễ này cảm thấy ổn vì chúng tôi đã biết yêu cầu của mình đã được nhận do nút tô sáng.

Chúng tôi coi nút này là một thứ "thực" và chúng tôi hy vọng nó sẽ cập nhật trong thời gian "thực", ngay lập tức.

Vì vậy, đối với các yếu tố giao diện người dùng thực tế trong giao diện của chúng tôi, chúng tôi thường muốn nhắm đến bản cập nhật "tức thì" này.

Để cho phép các yếu tố giao diện người dùng của chúng tôi phản ứng "ngay lập tức", điều quan trọng là phải giữ cho luồng chính không hoạt động không phải giao diện người dùng.

Để xem tại sao lại như vậy, chúng ta hãy xem xét kỹ hơn vòng lặp xử lý và kết xuất sự kiện để xem các sự kiện được xử lý như thế nào trên nền tảng Apple và cách đầu vào của người dùng dẫn đến cập nhật màn hình.

Tại một thời điểm nào đó, ai đó sẽ tương tác với thiết bị.

Chúng tôi không kiểm soát được khi điều đó xảy ra.

Đầu tiên, thường có một số phần cứng liên quan, như chuột hoặc màn hình cảm ứng.

Nó phát hiện sự tương tác, tạo ra một sự kiện và gửi nó đến hệ điều hành.

Hệ điều hành tìm ra quy trình nào cần xử lý sự kiện và chuyển tiếp nó đến quy trình đó, ví dụ, ứng dụng của bạn.

Trong ứng dụng, trách nhiệm của chuỗi chính của ứng dụng là xử lý các sự kiện.

Đây là nơi hầu hết mã giao diện người dùng của bạn chạy.

Nó đưa ra quyết định cách cập nhật giao diện người dùng.

Sau đó, bản cập nhật giao diện người dùng này được gửi đến máy chủ kết xuất, đây là một quy trình riêng biệt chịu trách nhiệm tổng hợp các lớp giao diện người dùng riêng lẻ và kết xuất khung tiếp theo.

Cuối cùng, trình điều khiển hiển thị chọn bitmap được chuẩn bị bởi máy chủ kết xuất và cập nhật các pixel trên màn hình cho phù hợp.

Nếu bạn muốn biết thêm về cách thức hoạt động của nó, chúng tôi sẽ đề cập đến điều này trong tài liệu trong phần "Cải thiện khả năng phản hồi của ứng dụng". Đối với chúng tôi, cái nhìn tổng quan sơ bộ này đủ để hiểu chuyện gì đang xảy ra.

Bây giờ, khi một sự kiện khác xảy ra trong thời gian này, nó thường có thể được xử lý song song.

Nhưng, nếu chúng ta nhìn vào cách một sự kiện duy nhất đi qua đường ống, chúng ta vẫn cần xem xét tất cả các bước theo trình tự.

Các bước xử lý sự kiện trước khi chúng tôi đến chuỗi chính và các bước hiển thị kết xuất và cập nhật SAU thường khá dễ đoán trong thời lượng của chúng.

Khi chúng ta gặp phải sự chậm trễ đáng kể trong tương tác, hầu như luôn luôn là do phần trên luồng chính mất quá nhiều thời gian hoặc vì một cái gì đó khác vẫn đang thực hiện trên luồng chính khi sự kiện đến nên chúng ta cần đợi nó kết thúc trước khi sự kiện có thể được xử lý.

Cho rằng mọi bản cập nhật cho phần tử giao diện người dùng cần một chút thời gian trên luồng chính và chúng tôi muốn các bản cập nhật này diễn ra trong vòng 100 ms để cảm thấy thực tế, lý tưởng nhất là không có công việc nào trên luồng chính sẽ mất nhiều thời gian hơn 100 ms.

Nếu bạn có thể nhanh hơn, thậm chí còn tốt hơn.

Lưu ý rằng công việc kéo dài trên luồng chính cũng có thể gây ra trở ngại và các ngưỡng thấp hơn được áp dụng để tránh trở ngại.

Bạn có thể tìm thêm thông tin chi tiết về các trở ngại trong Tech Talk của chúng tôi "Khám phá các trở ngại hoạt hình giao diện người dùng và vòng lặp kết xuất" và tài liệu của chúng tôi về "Cải thiện khả năng phản hồi của ứng dụng".

Hôm nay, chúng tôi tập trung vào hangs.

Một trong những đồng nghiệp của tôi vừa tìm thấy một trong những ứng dụng của chúng tôi, Backyard Birds, trong khi làm việc trên một tính năng mới.

Hãy lập hồ sơ ứng dụng với Instruments.

Tôi có dự án Xcode với ứng dụng ở đây.

Tất cả những gì tôi cần làm để lập hồ sơ ứng dụng trong Công cụ là nhấp vào menu Sản phẩm và sau đó Hồ sơ và sau đó Xcode sẽ xây dựng ứng dụng và cài đặt nó trên thiết bị, nhưng không khởi chạy nó.

Xcode cũng sẽ mở Công cụ và định cấu hình để nhắm mục tiêu cùng một ứng dụng và thiết bị đã được định cấu hình trong Xcode.

Trong trình chọn mẫu của Instruments, tôi sẽ chọn mẫu Time Profiler, đây thường là điểm khởi đầu tốt nếu bạn chưa biết mình đang tìm kiếm gì và muốn hiểu rõ hơn về những gì ứng dụng của mình đang làm.

Điều này tạo ra một tài liệu Công cụ mới từ mẫu Time Profiler.

Trong số những tài liệu khác, tài liệu mới này chứa công cụ Time Profiler và công cụ Hangs, cả hai đều sẽ hữu ích cho phân tích của chúng tôi.

Tôi nhấp vào nút Ghi âm ở trên cùng bên trái của thanh công cụ để bắt đầu ghi âm.

Các công cụ khởi chạy ứng dụng được cấu hình và bắt đầu thu thập dữ liệu.

Vì vậy, ở đây tôi có ứng dụng Backyard Birds.

Tôi nhấn vào khu vườn đầu tiên để đi đến chế độ xem chi tiết.

Khi tôi nhấn vào nút "Chọn nền" trong giây lát, một tờ dưới cùng sẽ xuất hiện, hiển thị cho tôi một lựa chọn các hình nền để lựa chọn.

Hãy để tôi làm điều đó ngay bây giờ.

Nút được nhấn nhưng có vẻ bị kẹt.

Phải mất khá nhiều thời gian để tờ giấy xuất hiện.

Một sự treo cổ nghiêm trọng.

Các nhạc cụ đã ghi lại tất cả những điều này.

Tôi sẽ dừng ghi âm bằng cách nhấp vào nút Dừng trên thanh công cụ.

Các dụng cụ cũng đã phát hiện ra sự treo cổ.

Nó đo thời gian treo và gắn nhãn các khoảng tương ứng theo mức độ nghiêm trọng.

Trong trường hợp này, Instruments cho chúng ta thấy một "Severe Hang" đã xảy ra.

Điều này cũng phù hợp với những gì chúng tôi đang trải qua khi sử dụng ứng dụng.

Các thiết bị đã phát hiện ra một sợi chính không phản hồi và đánh dấu khoảng tương ứng là một lỗ treo tiềm năng.

Trong trường hợp của chúng tôi, một vụ treo cổ đã thực sự xảy ra.

Có hai trường hợp chính cho một luồng chính không phản hồi.

Trường hợp đơn giản nhất là chủ đề chính đơn giản là vẫn đang bận làm công việc khác.

Trong trường hợp này, luồng chính sẽ hiển thị một loạt các hoạt động của CPU.

Trường hợp khác là chủ đề chính bị chặn.

Điều này thường là do chủ đề chính đang chờ đợi một số công việc khác được thực hiện ở nơi khác.

Khi luồng bị chặn, sẽ có rất ít hoặc không có hoạt động CPU trên luồng chính.

Trường hợp nào bạn đã xác định bước nào bạn nên thực hiện tiếp theo để xác định điều gì đang xảy ra.

Quay lại Instruments, chúng ta sẽ cần tìm Chủ đề chính.

Bản nhạc cuối cùng trong tài liệu hiển thị bản nhạc cho quy trình mục tiêu của chúng tôi.

Nó có một chỉ báo tiết lộ nhỏ ở bên trái để chỉ ra rằng có các dấu vết phụ.

Tôi nhấp vào nó để hiển thị một bản nhạc riêng biệt cho từng chủ đề trong quy trình.

Sau đó, tôi sẽ chọn bản nhạc Chủ đề Chính ở đây.

Điều này cũng cập nhật khu vực chi tiết để hiển thị chế độ xem Hồ sơ, hiển thị cho chúng ta cây cuộc gọi của tất cả các chức năng được thực hiện trên luồng chính trong toàn bộ thời gian ghi.

Nhưng chúng tôi chỉ quan tâm đến những gì đã xảy ra trong quá trình treo, vì vậy tôi nhấp vào thứ cấp vào khoảng thời gian treo trong dòng thời gian để hiển thị menu ngữ cảnh.

Tôi có thể chọn Đặt Phạm vi Kiểm tra ở đây, nhưng thay vào đó tôi cũng sẽ giữ phím tùy chọn để lấy Đặt Phạm vi Kiểm tra và Thu phóng.

Điều này phóng to phạm vi của khoảng thời gian và lọc dữ liệu được hiển thị trong chế độ xem chi tiết đến phạm vi thời gian đã chọn.

Mặc dù mức sử dụng CPU không phải là 100% trong toàn bộ khoảng thời gian treo, nhưng nó vẫn khá cao, với mức sử dụng CPU từ 60% đến 90% hầu hết thời gian.

Đây rõ ràng là trường hợp của một chủ đề chính bận rộn.

Hãy cùng tìm hiểu xem tất cả CPU này hoạt động là gì.

Chúng ta có thể xem xét kỹ hơn tất cả các nút khác nhau trong cây cuộc gọi ngay bây giờ.

Nhưng có một bản tóm tắt tuyệt vời ở phía bên phải: chế độ xem dấu vết ngăn xếp nặng nhất.

Khi tôi nhấp vào một khung trong chế độ xem theo dõi ngăn xếp nặng nhất, chế độ xem cây cuộc gọi sẽ cập nhật để hiển thị nút này.

Điều này cũng cho chúng ta thấy rằng cuộc gọi phương thức này đã khá sâu trong cây cuộc gọi.

Dấu vết ngăn xếp nặng nhất theo mặc định ẩn các lệnh gọi hàm tiếp theo không bắt nguồn từ mã nguồn của bạn để dễ dàng xem mã nguồn của bạn có liên quan đến đâu.

Chúng ta có thể áp dụng một bộ lọc tương tự cho chế độ xem cây cuộc gọi bằng cách nhấp vào nút Cây cuộc gọi ở thanh dưới cùng và bật hộp kiểm Ẩn Thư viện Hệ thống.

Điều này sẽ lọc ra tất cả các chức năng từ các thư viện hệ thống và giúp việc tập trung vào mã của chúng tôi dễ dàng hơn.

Chế độ xem cây cuộc gọi cho chúng ta thấy rằng hầu như tất cả các dấu vết ngược của chúng ta đều chứa cuộc gọi "BackgroundThumbnailView.body.getter".

Có vẻ như chúng ta nên làm cho cơ thể mình nhanh hơn, phải không?

Không hoàn toàn!

Vì vậy, chúng tôi biết rằng chúng tôi có một trường hợp luồng chính bận rộn, có nghĩa là CPU đang làm rất nhiều việc.

Chúng tôi cũng đã tìm ra một phương pháp sử dụng rất nhiều thời gian CPU.

Nhưng bây giờ có hai trường hợp khác nhau.

Chúng ta có thể dành rất nhiều thời gian CPU cho phương pháp này vì bản thân phương thức này chạy trong một thời gian dài.

Nhưng nó cũng có thể là nó chỉ được gọi rất nhiều lần, đó là lý do tại sao nó xuất hiện ở đây.

Cách chúng ta nên giảm công việc trên chủ đề chính phụ thuộc vào trường hợp chúng ta có.

Một ngăn xếp cuộc gọi điển hình được cấu trúc như thế này.

Có một cuộc gọi từ hàm chính, gọi ra một số khung giao diện người dùng và một loạt các thứ khác, và sau đó, tại một số điểm, mã của bạn được gọi.

Nếu hàm này chỉ được gọi một lần và một lần gọi mất nhiều thời gian, như hàm Rùa của chúng ta ở đây, thì chúng ta muốn xem nó gọi gì.

Có lẽ nó làm rất nhiều việc. Sau đó chúng ta có thể làm ít hơn.

Nhưng cũng có thể là phương pháp mà chúng tôi đang điều tra được gọi rất nhiều lần, như Unicorn ở đây.

Và sau đó, tất nhiên, công việc nó làm cũng được thực hiện lặp đi lặp lại.

Điều này thường là do có một số người gọi gọi hàm, Unicorn, rất nhiều lần - ví dụ, từ một vòng lặp.

Thay vì tối ưu hóa những gì chức năng tập trung, Unicorn ở đây, làm, có thể có lợi hơn khi điều tra cách chúng ta có thể gọi nó ít thường xuyên hơn.

Điều đó có nghĩa là hướng chúng ta cần xem xét tiếp theo phụ thuộc vào trường hợp chúng ta có.

Đối với một chức năng tồn tại lâu dài, như trường hợp Rùa của chúng tôi, chúng tôi muốn xem xét việc triển khai và các cuộc gọi của nó.

Chúng ta cần nhìn xa hơn.

Tuy nhiên, nếu một hàm được gọi nhiều lần, như Unicorn, sẽ có lợi hơn khi nhìn vào những gì đang gọi nó và xác định xem liệu chúng ta có thể làm như vậy ít thường xuyên hơn hay không.

Chúng ta cần nhìn xa hơn.

Nhưng Time Profiler không thể cho chúng tôi biết chúng tôi có trường hợp nào.

Giả sử các cuộc gọi đến Unicorn and Turtle xảy ra ngay sau đó.

Time Profiler thu thập dữ liệu bằng cách kiểm tra những gì đang chạy trên CPU đều đặn.

Và đối với mỗi mẫu, nó kiểm tra chức năng nào hiện đang chạy trên CPU.

Đối với ví dụ này, chúng tôi sẽ nhận được cả Rùa và Kỳ lân bốn lần.

Nhưng cũng có thể đây là một con Rùa rất nhanh, và Kỳ lân mất nhiều thời gian hơn, hoặc các kết hợp khác.

Tất cả các tình huống này sẽ tạo ra cùng một dữ liệu trong Time Profiler.

Để đo thời gian thực thi của một hàm cụ thể, hãy sử dụng os_signposts.

Chúng tôi đã nói về cách làm như vậy trong phiên năm 2019 của chúng tôi, "Bắt đầu với các công cụ".

Ngoài ra còn có các công cụ chuyên dụng cho các công nghệ khác nhau có thể cho bạn biết chính xác những gì đang xảy ra.

Một trong số đó là nhạc cụ cơ thể SwiftUI View.

Để thêm nhạc cụ cơ thể SwiftUI, tôi nhấp vào nút dấu cộng ở trên cùng bên phải của thanh công cụ.

Điều này cho thấy thư viện Nhạc cụ.

Đây là danh sách tất cả các nhạc cụ mà ứng dụng Dụng cụ phải cung cấp.

Có rất nhiều.

Bạn thậm chí có thể viết các nhạc cụ tùy chỉnh của riêng mình.

Tôi sẽ nhập "SwiftUI" vào trường lọc và hai nhạc cụ sẽ hiển thị.

Tôi sẽ chọn nhạc cụ "Xem nội dung" và kéo nó vào cửa sổ tài liệu để thêm nó.

Bây giờ, vì công cụ này không có trong tài liệu khi chúng tôi ghi lại lần cuối, nó không có dữ liệu để hiển thị.

Nhưng không vấn đề gì. Chúng tôi sẽ ghi lại lần nữa.

Để tiết kiệm thời gian, tôi đã làm điều đó rồi.

Sau khi tôi ghi lại bằng nhạc cụ SwiftUI View Body trong tài liệu, bản nhạc View Body cũng hiển thị một số dữ liệu ngay bây giờ.

Có rất nhiều khoảng thời gian trong bản nhạc cơ thể chế độ xem SwiftUI.

Nó hơi chật chội, vì vậy tôi nhấn Ctrl+Plus để tăng chiều cao của nó.

SwiftUI View Body theo dõi nhóm các khoảng thời gian theo thư viện mà chúng được triển khai.

Mỗi khoảng thời gian là một lần thực hiện nội dung chế độ xem.

Hãy phóng to hang của chúng ta một lần nữa.

Trong làn đường thứ hai, có rất nhiều khoảng màu cam được gắn nhãn "BackgroundThumbnailView".

Điều này cho chúng ta biết chính xác có bao nhiêu vụ hành quyết cơ thể và mỗi lần mất bao lâu.

Màu cam chỉ ra rằng thời gian chạy của việc thực hiện cơ thể cụ thể đó mất nhiều thời gian hơn một chút so với những gì chúng tôi đang hướng tới với SwiftUI.

Nhưng vấn đề lớn hơn dường như là có bao nhiêu khoảng thời gian.

Trong chế độ xem chi tiết, có một bản tóm tắt về tất cả các khoảng thời gian cơ thể.

Bằng cách nhấp vào chỉ báo tiết lộ bên cạnh Backyard Birds, tôi có thể tiết lộ các loại chế độ xem riêng lẻ trong Backyard Birds.

Điều này cho tôi thấy rằng phần thân của BackgroundThumbnailView đã được thực hiện 70 lần với thời lượng trung bình khoảng 50 mili giây, dẫn đến tổng thời lượng hơn ba giây.

Điều này giải thích gần như tất cả thời gian treo của chúng tôi.

Nhưng 70 lần có vẻ quá đáng khi chúng ta chỉ cần hiển thị sáu hình ảnh ở phía trước.

Đây là trường hợp cơ thể nên được gọi ít thường xuyên hơn, vì vậy chúng ta cần xem xét những người gọi cơ thể của chúng ta để tìm hiểu lý do tại sao nó được gọi như vậy thường xuyên và xem cách giảm bớt nó.

Để dễ dàng điều hướng đến mã có liên quan, tôi chọn lại theo dõi luồng chính, nhấp chuột thứ cấp vào nút BackgroundThumbnailView.body.getter trong cây cuộc gọi để hiển thị menu ngữ cảnh và chọn "Tham khảo trong Xcode".

Điều này mở ra việc triển khai cơ thể của chúng tôi ngay trong Xcode.

Hãy cùng tìm hiểu xem chế độ xem này được sử dụng như thế nào bằng cách nhấp vào loại thứ cấp và chọn "Tìm", "Tìm biểu tượng đã chọn trong không gian làm việc".

Kết quả đầu tiên trong Find navigator đã là những gì chúng tôi đang tìm kiếm.

Ở đây, "BackgroundThumbnailView" của chúng tôi được sử dụng bên trong ForEach bên trong GridRow bên trong một ForEach khác bên trong Grid.

Grid háo hức tính toán toàn bộ nội dung của nó khi nó được tạo, vì vậy nó sẽ tính toán tất cả các hình thu nhỏ nền mặc dù chúng ta chỉ cần một số ít đầu tiên.

Nhưng có một giải pháp thay thế: LazyVGrid.

Nó chỉ tính toán nhiều chế độ xem khi cần thiết để lấp đầy một màn hình.

Rất nhiều lượt xem trong SwiftUI có các biến thể lười biếng, chỉ tính toán nhiều chế độ xem khi cần thiết và đây thường có thể là một cách dễ dàng để thực hiện ít công việc hơn.

Tuy nhiên, các biến thể háo hức sử dụng ít bộ nhớ hơn nhiều khi chúng cần hiển thị cùng một nội dung.

Sử dụng các biến thể háo hức thông thường theo mặc định và chuyển sang các biến thể lười biếng khi bạn thấy vấn đề về hiệu suất liên quan đến việc trả trước quá nhiều công việc.

Phiên WWDC của chúng tôi từ WWDC 2020 về "Các phụ đề, lưới và phác thảo trong SwiftUI" giới thiệu các biến thể lười biếng này và mô tả chúng chi tiết hơn.

Hãy lập hồ sơ mã cập nhật này.

Tôi bắt đầu ghi âm và tái tạo hang của chúng tôi bằng cách nhấn lại vào nút Chọn Nền.

Bây giờ, điều này tốt hơn nhiều.

Vẫn còn một chút chậm trễ, nhưng gần như không tệ như trước.

Các công cụ xác nhận điều này.

Việc treo mà chúng tôi ghi lại bây giờ mất ít hơn 400 mili giây.

Đó là một sự treo vi mô.

Bản nhạc "View Body" cũng cho chúng ta thấy rằng bây giờ chúng ta chỉ có tám lần thực hiện nội dung BackgroundThumbnail, phù hợp với mong đợi của chúng ta.

Có lẽ điều này là đủ tốt.

Microhang không đáng chú ý lắm.

Hãy đảm bảo rằng nó cũng hoạt động tốt trên các loại thiết bị khác bằng cách lập hồ sơ Backyard Birds trên iPad.

Ở đây, tôi đang chạy Backyard Birds trên iPad.

Tôi đã ở trong chế độ xem chi tiết.

Tôi nhấn vào nút "Chọn nền" và phải mất nhiều thời gian để trang tính xuất hiện.

Một khi nó xuất hiện, chúng ta có thể hiểu tại sao.

Hiện tại có nhiều hình thu nhỏ hơn vì màn hình của chúng tôi lớn hơn và có nhiều không gian hơn.

Các nhạc cụ cũng đã ghi lại sự treo cổ này.

Tập trung phạm vi kiểm tra vào khoảng thời gian treo của chúng tôi, chúng tôi sẽ thấy nhiều nội dung BackgroundThumbnailView hơn.

Nó có ý nghĩa.

Bây giờ chúng ta cần hiển thị khoảng 40 trong số chúng cho toàn màn hình khi nhiều cái phù hợp hơn trên màn hình.

Vì vậy, cùng một mã hoạt động hầu như OK trên iPhone nhưng chậm trên iPad, đơn giản vì màn hình lớn hơn.

Đây là một trong những lý do tại sao bạn cũng nên sửa micro hangs.

Những gì bạn có thể thấy là treo vi mô trong quá trình thử nghiệm tại bàn làm việc của mình có thể là một sự treo lớn đối với một số người dùng của bạn trong các điều kiện khác nhau.

Bây giờ chúng tôi chỉ hiển thị nhiều chế độ xem như chúng tôi cần để lấp đầy màn hình, vì vậy chúng tôi đã cạn kiệt tiềm năng tối ưu hóa của mình về mặt gọi điều này ít thường xuyên hơn.

Hãy cùng tìm hiểu xem chúng ta có thể làm gì để giúp mỗi cá nhân thực hiện nhanh hơn.

Tôi sẽ đặt phạm vi kiểm tra thành một khoảng thời gian BackgroundThumbnailView duy nhất và chuyển trở lại theo dõi "Chủ đề chính".

Các công cụ hiển thị getter cơ thể chế độ xem của chúng tôi trong chế độ xem backtrace nặng nhất và cho thấy rằng nó gọi getter thuộc tính "BackyardBackground.thumbnail".

Đây là đối tượng mô hình cung cấp hình ảnh thu nhỏ để hiển thị trong chế độ xem của chúng tôi.

Trình nhận hình thu nhỏ này gọi là "UIImage imageByPreparingThumbnailOfSize:".

Vì vậy, chúng tôi dường như đang tính toán một hình thu nhỏ một cách nhanh chóng ở đây.

Điều đó có thể mất một chút thời gian. Trong trường hợp này, khoảng 150 mili giây.

Đây là công việc chúng ta nên làm trong nền và không làm cho chủ đề chính bận rộn.

Để hiểu rõ hơn về những thay đổi mà chúng ta có thể thực hiện, tôi muốn xem xét bối cảnh cách gọi của getter hình thu nhỏ.

Tôi nhấp thứ hai vào khung "BackgroundThumbnailView.body.getter" trong chế độ xem theo dõi ngăn xếp nặng nhất và chọn "Mở trong Trình xem Nguồn".

Điều này thay thế chế độ xem cây cuộc gọi bằng trình xem nguồn hiển thị việc triển khai trình lấy cơ thể của chúng tôi và chú thích các dòng triển khai bằng các mẫu Time Profiler để hiển thị nơi mã của chúng tôi đã dành bao nhiêu thời gian.

Việc triển khai cơ thể của chúng tôi thực sự đơn giản ở đây; nó chỉ tạo ra một chế độ xem Hình ảnh mới với hình thu nhỏ được trả về bởi nền.

Nhưng cuộc gọi thu nhỏ này mất nhiều thời gian.

Tôi có một ý tưởng làm thế nào để viết nó khác đi.

Để chuyển đến Xcode, tôi nhấp vào nút menu ở trên cùng bên phải và chọn "Mở tệp trong Xcode".

Như trước đây, điều này hiển thị mã nguồn của chúng tôi trong Xcode, sẵn sàng thực hiện các thay đổi.

Những gì tôi muốn làm bây giờ là tải hình thu nhỏ trong nền và trong khi tải đang diễn ra, hãy hiển thị chỉ báo tiến độ.

Đầu tiên, chúng ta cần một biến trạng thái để giữ hình thu nhỏ đã tải.

Sau đó, trong phần thân, nếu chúng ta đã tải hình ảnh, chúng ta sẽ sử dụng nó trong chế độ xem Hình ảnh.

Nếu không, chúng tôi sẽ hiển thị chế độ xem tiến độ.

Bây giờ tất cả những gì còn lại là tải hình thu nhỏ thực tế.

Chúng tôi muốn bắt đầu tải nó khi chế độ xem của chúng tôi xuất hiện.

Đó là mục đích của công cụ sửa đổi ".task".

Khi xuất hiện, SwiftUI sẽ bắt đầu một nhiệm vụ cho chúng tôi sẽ gọi trình nhận "hình thu nhỏ" và gán kết quả cho "hình ảnh" của chúng tôi, điều này sẽ cập nhật chế độ xem của chúng tôi.

Hãy thử nó đi!

Vì vậy, ở đây, với tính năng ghi nhạc cụ, tôi nhấn vào nút "Chọn nền" và trang tính xuất hiện ngay!

Tuyệt vời!

Chúng tôi đã thấy các chỉ số tiến độ của mình và vài giây sau, hình thu nhỏ của chúng tôi đã được hiển thị.

Điều này đã hiệu quả. Tuyệt vời!

Nhưng khoan đã, Instruments vẫn đang hiển thị một khoảng thời gian dài gần hai giây.

Điều đã xảy ra ở đây là việc treo cổ xảy ra muộn hơn một chút bây giờ.

Hãy để tôi chỉ cho bạn nơi nó xảy ra trong ứng dụng Backyard Birds.

Tôi đã xem chi tiết rồi.

Trong giây lát, tôi sẽ nhấn vào nút "Chọn nền" một lần nữa và sau đó tôi sẽ cố gắng loại bỏ trang tính ngay sau đó bằng cách nhấn vào nút Xong.

Được rồi, "Chọn nền" và "Xong".

Tôi đã nhấn nhiều lần, nhưng trong khi quá trình tải đang diễn ra, các thao tác của tôi đã bị bỏ qua.

Đây là hang mà Instruments đã nói với chúng tôi.

Nó xảy ra sau khi trang tính được hiển thị.

Đây là một kiểu treo hơi khác một chút.

Chúng tôi đã nói về sự khác biệt giữa chủ đề chính đang bận hoặc bị chặn.

Có một cách khác để xem xét các vụ treo cổ; chúng gây ra bởi cái gì và khi nào chúng xảy ra.

Chúng tôi gọi những cái treo đồng bộ và không đồng bộ này.

Ở đây, chúng tôi có chủ đề chính đang làm một số công việc.

Nếu, khi một sự kiện xuất hiện, phải mất nhiều thời gian để xử lý sự kiện đó, thì đó là một sự cố.

Giả sử chúng tôi kiểm soát được điều đó và đảm bảo các sự kiện của chúng tôi được xử lý nhanh chóng.

Nhưng có lẽ chúng tôi chỉ trì hoãn một số công việc cần hoàn thành sau này trên chủ đề chính, hoặc một số công việc chủ đề chính khác xảy ra, và sau đó một sự kiện xảy ra.

Sau đó, sự kiện đó phải đợi công việc trước đó được hoàn thành trước khi nó có thể được xử lý.

Sau đó, điều này vẫn gây ra sự cố treo, mặc dù mã cho từng sự kiện riêng lẻ xử lý kết thúc nhanh chóng.

Cách phát hiện treo hoạt động trên nền tảng của chúng tôi là nó xem xét tất cả các mục công việc trên luồng chính và kiểm tra xem chúng có quá dài hay không.

Nếu vậy, nó đánh dấu họ là một sự treo cổ tiềm năng.

Và nó làm điều đó bất kể có đầu vào của người dùng hay không vì đầu vào của người dùng có thể đến bất cứ lúc nào và sau đó chúng tôi sẽ có một sự cố thực sự.

Điều này có nghĩa là phát hiện treo cũng phát hiện các trường hợp không đồng bộ hoặc bị trì hoãn này, nhưng nó chỉ đo lường độ trễ tiềm ẩn, không phải độ trễ thực sự đã trải qua.

Chúng tôi gọi treo không đồng bộ là không đồng bộ vì chúng thường được gây ra bởi công việc "dispatch_async" trên hàng đợi chính hoặc bởi tác vụ Swift Concurrency chạy không đồng bộ trên diễn viên chính.

Nhưng chúng có thể được gây ra bởi bất cứ điều gì gây ra công việc trên chủ đề chính.

Lần treo đầu tiên chúng tôi thấy là treo đồng bộ.

Chúng tôi đã nhấn vào một nút, lần nhấn nút đó gây ra công việc kéo dài, vì vậy kết quả được hiển thị muộn.

Lần treo gần đây nhất này là một lần treo không đồng bộ hoặc bị trì hoãn.

Nhấn vào nút Xong không thực sự gây ra bất kỳ công việc tốn kém nào.

Nhưng vẫn có công việc trên luồng chính ngăn không cho vòi được xử lý.

Vì vậy, trong khi ai đó sử dụng ứng dụng thậm chí có thể không nhận thấy nếu họ không tương tác với ứng dụng trong thời gian này, chúng ta vẫn nên khắc phục những trường hợp này, trong trường hợp họ làm vậy.

Hãy làm điều đó ngay bây giờ.

Vì vậy, ở đây tôi đã trở lại Công cụ và tôi đã đặt phạm vi lựa chọn thành treo và phóng to không đồng bộ của chúng tôi.

Trong chế độ xem tóm tắt của bản nhạc cơ thể chế độ xem, Instruments cho chúng ta thấy rằng hiện đã có 75 cuộc gọi đến trình lấy cơ thể của BackgroundThumbnailView của chúng tôi.

Điều này là do hầu hết các getter cơ thể hình thu nhỏ được thực hiện hai lần.

SwiftUI tạo ra 40 chế độ xem với các chỉ báo tiến độ để lấp đầy lưới.

Nhưng sau đó chỉ có 35 thực sự được hiển thị và đối với 35 người đó, chúng tôi bắt đầu tải hình ảnh và một khi hình ảnh được tải, chế độ xem sẽ cập nhật và nội dung được gọi lại, cho chúng tôi tổng cộng 75 lần thực hiện nhận cơ thể.

Ngay cả tất cả tổng cộng 75 người lấy cơ thể cũng mất ít hơn một phần nghìn giây.

Vì vậy, những người nhận được cơ thể của chúng ta bây giờ đang nhanh chóng. Phần đó đã hoạt động.

Nhưng chúng tôi vẫn còn hàng.

Tôi sẽ chọn lại bản nhạc "Chủ đề chính" và trong chế độ xem stacktrace nặng nhất, Instruments cho chúng ta thấy rằng đó vẫn là trình lấy hình thu nhỏ mất nhiều thời gian trên chủ đề chính.

Lần này, nó được gọi bằng cách đóng cửa bên trong "BackgroundThumbnailView.body.getter" của chúng tôi, không phải là người nhận cơ thể trực tiếp.

Tôi nhấp đúp vào nó, đây là một phím tắt để mở trình xem nguồn.

Bây giờ đây chính xác là mã mà chúng tôi dự kiến sẽ thực thi trong nền do đang đóng công cụ sửa đổi nhiệm vụ.

Mã này nên chạy vào lúc này, nhưng nó không nên chạy trên luồng chính.

Đối với các vấn đề như thế này, trong đó các tác vụ Swift Concurrency không thực hiện theo cách bạn mong đợi, chúng tôi có một công cụ hữu ích khác: công cụ Swift Concurrency Tasks.

Tôi đã ghi lại hành vi tương tự với công cụ tác vụ Swift Concurrency được thêm vào.

Công cụ Swift Tasks thêm một bản nhạc tóm tắt vào tài liệu nhưng điều thú vị hơn đối với trường hợp của chúng tôi là dữ liệu mà nó đóng góp cho mỗi bản nhạc luồng.

Ở đây, trong bản nhạc chủ đề chính, có một biểu đồ mới từ công cụ Swift Tasks.

Một bản nhạc duy nhất có thể hiển thị nhiều biểu đồ.

Bằng cách nhấp vào mũi tên nhỏ hướng xuống trong tiêu đề theo dõi luồng, tôi có thể định cấu hình biểu đồ nào sẽ hiển thị.

Tôi có thể chọn một biểu đồ khác, như biểu đồ Sử dụng CPU của Time Profiler hoặc giữ phím Command trong khi nhấp để chọn nhiều.

Vì vậy, bây giờ các Công cụ đang hiển thị cả Biểu đồ Sử dụng CPU và Nhiệm vụ Nhanh cho luồng này cùng nhau.

Tôi sẽ phóng to khoảng thời gian treo của chúng ta một lần nữa.

Làn đường "Nhiệm vụ nhanh" hiện hiển thị rõ ràng rằng có một loạt các thực thi nhiệm vụ trên luồng chính.

Đặt phạm vi kiểm tra thành một trong số chúng và kiểm tra dấu vết ngăn xếp nặng nhất trong chế độ xem Hồ sơ xác nhận rằng nhiệm vụ này đang kết thúc công việc tính toán hình thu nhỏ của chúng tôi.

Vì vậy, công việc này được gói gọn trong một nhiệm vụ như chúng tôi muốn.

Nhưng nhiệm vụ đang được thực hiện trên chủ đề chính, điều này thật bất ngờ.

Hãy để tôi giải thích chuyện gì đang xảy ra ở đây.

Đầu tiên, getter nội dung kế thừa chú thích @MainActor từ giao thức View của SwiftUI.

Bởi vì "body" được chú thích là "@MainActor" trong giao thức "View", khi chúng tôi triển khai nó, body getter cũng được chú thích ngầm là @MainActor.

Thứ hai, việc đóng cửa của công cụ sửa đổi ".task" được chú thích để kế thừa sự cô lập của diễn viên trong bối cảnh xung quanh.

Vì vậy, bởi vì người nhận cơ thể bị cô lập với MainActor, việc đóng nhiệm vụ cũng sẽ như vậy.

Vì vậy, tất cả mã chạy trong lần đóng này sẽ chạy trên diễn viên chính theo mặc định và vì getter "hình thu nhỏ" là đồng bộ, giờ đây nó chạy đồng bộ trên luồng chính.

Nhiệm vụ đồng thời Swift, theo mặc định, kế thừa sự cô lập của diễn viên trong bối cảnh xung quanh.

Hành vi tương tự cũng đúng với công cụ sửa đổi .task của SwiftUI.

Có hai cách để thoát khỏi diễn viên chính.

Gọi không đồng bộ một hàm không bị ràng buộc với diễn viên chính cho phép tác vụ tắt tác nhân chính.

Có thể có những trường hợp điều này không khả thi.

Sau đó, bạn có thể tách nhiệm vụ khỏi bối cảnh diễn viên xung quanh một cách rõ ràng bằng cách sử dụng "Task.detached", nhưng đó là một cách tiếp cận nặng tay và việc tạo một nhiệm vụ riêng biệt tốn kém hơn là chỉ đơn giản là đình chỉ một nhiệm vụ hiện có.

SwiftUI cũng sẽ tự động hủy nhiệm vụ được tạo thông qua công cụ sửa đổi tác vụ khi chế độ xem tương ứng biến mất, nhưng việc hủy bỏ này sẽ không lan truyền sang một tác vụ phi cấu trúc mới, như Task.detached.

Để tìm hiểu thêm, hãy xem "Trực quan hóa và tối ưu hóa đồng thời Swift" từ WWDC22 và tài liệu của chúng tôi về cải thiện khả năng phản hồi của ứng dụng.

Bởi vì trong trường hợp của chúng tôi, chúng tôi đã ở trong một ngữ cảnh không đồng bộ và thật dễ dàng để làm cho hàm hình thu nhỏ không bị cô lập và không đồng bộ, chúng tôi sẽ chọn tùy chọn một.

Ở đây, chúng tôi có mã tải hình thu nhỏ của mình.

Vấn đề là nhiệm vụ này sẽ thực hiện trên diễn viên chính do kế thừa sự cô lập diễn viên chính của getter cơ thể và vì getter hình thu nhỏ là đồng bộ, nó cũng sẽ ở trên diễn viên chính.

Việc sửa chữa rất đơn giản.

Chúng tôi chuyển đến định nghĩa của getter hình thu nhỏ, chúng tôi làm cho getter không đồng bộ, sau đó chúng tôi quay lại cấu trúc chế độ xem của mình...

Và bởi vì getter của chúng tôi hiện không đồng bộ, chúng tôi cần thêm await ở phía trước nó.

Điều này sẽ cho phép getter "hình thu nhỏ" thực thi trên nhóm luồng đồng thời của Swift Concurrency thay vì luồng chính.

Hãy thử nó.

Tôi đang ở chế độ xem chi tiết một lần nữa và nhấn vào "Chọn nền".

Ồ. Điều đó thật nhanh!

Không chỉ không có treo, mà còn có vẻ như tải tổng thể nhanh hơn.

Tôi hầu như không thấy quan điểm tiến độ.

Các công cụ xác nhận bây giờ không có treo.

Có một số mức sử dụng CPU cao ngay tại đây.

Hãy để tôi phóng to điều đó.

Đây là nơi tải hình thu nhỏ bây giờ xảy ra.

Kiểm tra luồng chính, chúng tôi có thể xác nhận rằng tất cả các khoảng nhiệm vụ trên luồng chính hiện rất ngắn.

Cuộn xuống các bản nhạc luồng khác cho thấy rằng các tác vụ Swift của chúng tôi hiện đang thực hiện song song trên các luồng khác thay vì tuần tự, điều này giúp sử dụng tốt hơn nhiều CPU đa lõi của chúng tôi.

Điều này cho phép chúng tôi tính toán tất cả các hình thu nhỏ trong vài trăm mili giây thay vì gần 1,5 giây.

Và trong suốt thời gian này, chủ đề chính vẫn phản hồi, vì vậy chúng tôi đã sửa lỗi này ngay bây giờ.

Bây giờ chúng tôi đã điều tra và sửa chữa một luồng chính không phản hồi do luồng chính bị bận, mà chúng tôi có thể xác định bằng luồng chính bằng cách sử dụng nhiều CPU trong quá trình treo.

Chúng tôi cũng đã trải nghiệm cách treo có thể đồng bộ khi nó xảy ra trực tiếp như một phần của tương tác người dùng hoặc không đồng bộ, trong đó công việc đã được lên lịch trên luồng chính trước đó khiến một sự kiện đến được xử lý muộn và cách Công cụ có thể phát hiện cả hai trường hợp.

Và chúng tôi đã khắc phục sự cố treo bằng cách làm ít công việc hơn và bằng cách làm các công việc khác, chúng tôi không thể làm ít hơn trong nền và chỉ quay lại chuỗi chính để cập nhật giao diện người dùng.

Nhưng có một trường hợp chúng tôi chưa xem xét, một luồng chính bị chặn, trong trường hợp đó luồng chính sẽ sử dụng rất ít CPU.

Các kích thước khác áp dụng cho một luồng chính bị chặn theo cùng một cách, nhưng các Công cụ khác là cần thiết để phân tích trường hợp như vậy.

Hãy xem xét một ví dụ ngay bây giờ.

Ở đây tôi có một tệp theo dõi từ một hang khác.

Tôi đã phóng to hang rồi. Đó là một cái dài; vài giây.

Trong bản nhạc "Chủ đề chính", biểu đồ Sử dụng CPU cho chúng ta thấy rằng có một số cách sử dụng CPU ban đầu, nhưng sau đó, không có gì.

Đây là một trường hợp rõ ràng của một chủ đề chính bị chặn.

Chúng tôi đã nói về cách Time Profiler thu thập dữ liệu của nó bằng cách lấy mẫu những gì đang chạy trên CPU.

Khi chúng tôi phóng to, biểu đồ Sử dụng CPU thậm chí còn hiển thị các mẫu riêng lẻ.

Vì vậy, mỗi điểm đánh dấu này ở đây là một mẫu mà Time Profiler đã lấy.

Có một vài mẫu nữa ở bên phải, nhưng sau đó không có gì.

Nhưng khi tôi chọn một khoảng thời gian không có mẫu, Time Profiler không thể cho chúng tôi biết chuyện gì đang xảy ra, vì nó không ghi lại bất kỳ dữ liệu nào trong thời gian này.

Vì vậy, chúng ta cần một công cụ khác: công cụ Thread States.

Giống như các nhạc cụ khác trước đây, bạn có thể thêm nó từ thư viện Nhạc cụ.

Tôi đã thu âm lại cùng một lần nữa, lần này với nhạc cụ "Thread State Trace" được thêm vào.

Hiện tại có một bản nhạc mới cho nhạc cụ này.

Nhưng giống như công cụ "Swift Concurrency", dữ liệu thú vị đối với chúng tôi thực sự nằm trong các bản nhạc "chủ đề".

Vì vậy, có khoảng thời gian "bị chặn" thực sự dài ở đây trong chuỗi chính, hơn sáu giây, điều này giải thích hầu hết thời lượng treo của chúng tôi.

Khi tôi nhấp vào giữa nó, con trỏ thời gian của Instruments di chuyển đến đó, con trỏ này cũng cập nhật chế độ xem Tường thuật trong khu vực chi tiết để hiển thị mục nhập cho trạng thái bị chặn này.

Quan điểm tường thuật cho chúng ta biết câu chuyện của chủ đề; nó đang làm gì, khi nào và tại sao.

Trong thời gian đã chọn, nó cho chúng ta biết rằng luồng đã bị chặn trong 6,64 giây và nó đã bị chặn vì nó đang gọi mach_msg2_trap, một cuộc gọi hệ thống.

Ở bên phải, lại có một chế độ xem ngược.

Nhưng dấu vết ngược này không phải là dấu vết ngược nặng nhất-- nó không phải là một tập hợp nào đó.

Đó là dấu vết ngược chính xác của cuộc gọi hệ thống mach_msg2_trap đã khiến luồng bị chặn.

Cuộc gọi hàm được hiển thị dưới dạng nút lá ở dưới cùng và ngăn xếp cuộc gọi của nó được hiển thị ở trên.

Ngăn xếp cuộc gọi cho chúng ta biết rằng cuộc gọi hệ thống xảy ra do kết quả của việc phân bổ Mô hình ML, do đó xảy ra do phân bổ một đối tượng thuộc loại "Dịch vụ tô màu", được gọi là một phần của thuộc tính singleton được gọi là "chia sẻ" trên dịch vụ tô màu đó, đến lượt nó, được gọi bằng cách đóng trong trình nhận

Nếu chúng ta nhấp đúp vào đóng cửa đó, chúng ta sẽ chuyển đến Trình xem Nguồn một lần nữa và có thể tìm thấy mã nơi điều này được gọi.

Dòng này trông vô hại, phải không?

Chúng ta hãy xem xét kỹ hơn.

Chúng tôi đang truy cập thuộc tính được chia sẻ của ColorizingService và lưu trữ nó trong một biến cục bộ.

Ngoại trừ nó không vô hại vì thuộc tính được chia sẻ tạo phiên bản ColorizingService được chia sẻ lần đầu tiên nó được truy cập và đến lượt nó, khởi động toàn bộ máy móc tải mô hình, chặn luồng.

Vì vậy, bạn có thể bị cám dỗ để nói, "Hãy di chuyển cái này vào bên trong phần không đồng bộ sau khi 'chờ đợi'."

Tuy nhiên, ngược lại trực giác, điều này không giải quyết được vấn đề.

Từ khóa "chờ" chỉ áp dụng cho các lệnh gọi hàm không đồng bộ trong mã tiếp theo.

Trong ví dụ của chúng tôi, hàm "tô màu" là "không đồng bộ".

Nhưng tài sản "chia sẻ" thì không.

Bởi vì nó là một thuộc tính cho phép tĩnh, nó sẽ được khởi tạo một cách lười biếng ngay lần đầu tiên nó được truy cập và điều đó xảy ra đồng bộ.

Từ khóa await không thay đổi điều đó, vì vậy cuộc gọi đồng bộ vẫn sẽ xảy ra trên chuỗi chính.

Chúng ta có thể khắc phục điều này giống như cách chúng ta đã làm trong ví dụ trước của mình, bằng cách làm cho tài sản được chia sẻ trở nên "không đồng bộ" để thoát khỏi diễn viên chính.

Điều này nói chung là OK khi bạn đang chờ đợi công việc thay mặt cho chủ đề của mình ở nơi khác, nơi tiến độ chuyển tiếp được thực hiện.

Tuy nhiên, một lý do phổ biến khác cho các chủ đề bị chặn là khóa hoặc semaphores.

Để biết các phương pháp hay nhất cần ghi nhớ và những điều cần tránh khi sử dụng khóa và semaphores với Swift concurrency, hãy xem phiên của chúng tôi "Swift concurrency: Behind the scenes" từ WWDC 21.

Trước khi chúng ta kết thúc, tôi muốn nói về một trường hợp khác liên quan đến các chủ đề chính bị chặn.

Đây là dấu vết mà chúng tôi đã xem xét một lúc trước.

Bên phải là hang mà chúng tôi vừa điều tra với chủ đề chính bị chặn.

Nhưng ở bên trái của nó, có một số trường hợp khác mà luồng chính bị chặn trong nhiều giây, nhưng Instruments không gắn cờ đây là một lỗ treo tiềm năng.

Ở đây, chủ đề chính chỉ đang ngủ vì không có đầu vào của người dùng.

Từ quan điểm của hệ điều hành, nó bị chặn, nhưng nó chỉ tiết kiệm tài nguyên bằng cách không chạy khi không có gì để làm.

Ngay khi đầu vào đến, nó sẽ thức dậy và xử lý nó.

Vì vậy, để xác định xem luồng bị chặn có phải là vấn đề phản hồi hay không, hãy tìm đến công cụ Hangs, không phải công cụ trạng thái luồng.

Vì vậy, một chủ đề chính bị chặn không ngụ ý một chủ đề chính không phản hồi.

Tương tự, Mức sử dụng CPU cao cũng không ngụ ý rằng luồng chính không phản hồi.

Nhưng nếu chủ đề chính không phản hồi, điều đó có nghĩa là nó đã bị chặn hoặc chủ đề chính đang bận.

Phát hiện treo của chúng tôi tính đến tất cả các chi tiết này và sẽ chỉ gắn nhãn các khoảng thời gian mà luồng chính thực sự không phản hồi và hiển thị chúng là các lỗ treo tiềm năng.

Nếu bạn chỉ nhớ một điều từ phiên này, hãy để nó là: bất cứ công việc nào bạn đang làm trên luồng chính, nó sẽ được thực hiện trong vòng chưa đầy 100 mili giây để giải phóng luồng chính để xử lý lại sự kiện.

Càng ngắn, càng tốt.

Để phân tích chi tiết, Instruments là người bạn tốt nhất của bạn.

Hãy nhớ sự phân biệt giữa luồng chính bận và luồng chính bị chặn và hãy nhớ rằng việc treo cũng có thể được gây ra bởi công việc không đồng bộ trên luồng chính.

Để sửa lỗi treo, bạn muốn làm ít công việc hơn hoặc chuyển công việc sang nền.

Đôi khi, thậm chí cả hai.

Và làm ít công việc hơn thường chỉ có nghĩa là sử dụng API phù hợp cho công việc.

Nói chung, hãy đo lường trước và kiểm tra xem có thực sự treo hay không trước khi tối ưu hóa.

Chắc chắn có một số phương pháp hay nhất, nhưng mã đồng thời và không đồng bộ cũng khó gỡ lỗi hơn nhiều.

Bạn sẽ thường ngạc nhiên bởi tất cả những thứ thực sự rất nhanh và những gì thực sự kết thúc là chậm.

Hãy vui vẻ tìm kiếm, phân tích và sửa chữa tất cả các hàng treo của bạn.

Cảm ơn bạn đã xem.

♪ ♪