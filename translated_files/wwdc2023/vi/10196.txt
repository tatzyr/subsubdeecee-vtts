10196

♪ ♪

Nick Gillett: Xin chào, tôi là Nick Gillett, một Kỹ sư ở đây tại Apple trong nhóm SwiftData.

Trong phiên này, tôi sẽ xem xét chi tiết cách các ứng dụng được xây dựng với SwiftData phát triển để tận dụng khuôn khổ mới phong phú, mạnh mẽ này.

Đầu tiên, tôi sẽ kiểm tra cách định cấu hình sự kiên trì trong một ứng dụng.

Tiếp theo, tôi sẽ nói về cách sử dụng ModelContext để theo dõi và duy trì các thay đổi.

Cuối cùng, tôi sẽ kiểm tra cách tận dụng tối đa SwiftData khi làm việc với các đối tượng trong mã của bạn.

Tôi muốn lưu ý rằng phiên này được xây dựng dựa trên các khái niệm và API được giới thiệu trong "Gặp gỡ dữ liệu Swift" và "Mô hình hóa lược đồ của bạn với SwiftData".

Tôi thực sự khuyên bạn nên xem lại các phiên đó trước khi tiếp tục với phiên này.

Trong buổi nói chuyện này, tôi sẽ tham khảo một ứng dụng mẫu mới, SampleTrips, mà chúng tôi đã xây dựng trong năm nay để chứng minh việc xây dựng các ứng dụng với SwiftData dễ dàng như thế nào.

SampleTrips giúp tôi dễ dàng sắp xếp các ý tưởng của mình về nơi và thời điểm tôi muốn đi du lịch.

SwiftData cũng giúp dễ dàng thực hiện các phương pháp nền tảng tiêu chuẩn như hoàn tác và tự động lưu khi người dùng chuyển đổi ứng dụng.

SwiftData là một cách mới để duy trì dữ liệu trong các ứng dụng sử dụng Swift.

Nó được thiết kế để hoạt động với các loại bạn đang sử dụng trong mã của mình như Lớp học và Cấu trúc.

Cốt lõi của khái niệm này là Mô hình, được mô tả bởi một macro mới, @Model, cho SwiftData biết về các loại bạn muốn duy trì.

Đây là lớp Trip từ ứng dụng SampleTrips.

Nó có một vài thuộc tính để nắm bắt thông tin về một chuyến đi và một số tham chiếu đến các đối tượng khác được sử dụng trong SampleTrips.

Chúng tôi đã thiết kế SwiftData để cung cấp khoảng cách tối thiểu giữa mã bạn thường viết mà không cần kiên trì, như tôi có ở đây và mã bạn phải viết một cách kiên trì.

Chỉ với một vài thay đổi, tôi đã nói với SwiftData rằng Chuyến đi này là một Mô hình mà tôi muốn duy trì và mô tả mối quan hệ của nó với BucketListItem và LivingAccommodations nên hoạt động như thế nào.

Nếu có thể, SwiftData sẽ tự động suy ra cấu trúc bạn muốn sử dụng từ mã bạn viết.

Nhưng SwiftData cũng cung cấp một bộ tùy chỉnh mạnh mẽ để giúp bạn mô tả chính xác cách bạn muốn dữ liệu của mình được lưu trữ.

Bạn có thể tìm hiểu tất cả về sức mạnh của Mô hình trong "Mô hình lược đồ của bạn với SwiftData".

Những chú thích này cho lớp Trip cho phép nó đóng hai vai trò quan trọng trong SwiftData.

Đầu tiên là mô tả biểu đồ đối tượng của ứng dụng, được gọi là Lược đồ, và thứ hai là lớp Trip sẽ là một giao diện mà tôi có thể viết mã dựa trên đó.

Tính hai mặt này, khả năng chơi cả hai phần, làm cho các lớp được chú thích với macro @Model trở thành điểm liên hệ trung tâm trong các ứng dụng sử dụng SwiftData và có một khái niệm API được căn chỉnh để hỗ trợ từng vai trò này.

Lược đồ được áp dụng cho một lớp được gọi là ModelContainer để mô tả cách dữ liệu nên được duy trì.

ModelContainer sử dụng Lược đồ để tạo ra một cơ sở dữ liệu có thể chứa các trường hợp của các lớp Mô hình.

Khi làm việc với các trường hợp của một lớp Mô hình trong mã, những trường hợp đó được liên kết với một ModelContext theo dõi và quản lý trạng thái của chúng trong bộ nhớ.

Tính hai mặt này là cốt lõi của SwiftData và trong phần này, tôi sẽ xem xét chi tiết vai trò đầu tiên của mô hình, để mô tả cấu trúc của sự bền bỉ và cách thức hoạt động với ModelContainer.

ModelContainer là nơi bạn mô tả cách dữ liệu được lưu trữ hoặc tồn tại trên một thiết bị.

Chúng ta có thể nghĩ về ModelContainer là cầu nối giữa Lược đồ và sự bền bỉ của nó.

Đó là nơi các mô tả về cách các đối tượng được lưu trữ, như chúng nằm trong bộ nhớ hay trên đĩa, đáp ứng ngữ nghĩa hoạt động và tiến hóa của bộ lưu trữ đó như lập phiên bản, di chuyển và tách đồ thị.

Khởi tạo một vùng chứa bằng Lược đồ thật dễ dàng.

Tôi chỉ có thể cung cấp loại mà tôi muốn làm việc và SwiftData sẽ tìm ra phần còn lại của Lược đồ cho tôi.

Ví dụ, vì lớp Trip có liên quan đến các loại mô hình khác, ModelContainer thực sự suy ra Lược đồ này, mặc dù tôi chỉ chuyển nó một loại duy nhất.

ModelContainer có một số trình khởi tạo mạnh mẽ khác được thiết kế để phát triển cùng với mã của bạn để cho phép các cấu hình ngày càng phức tạp bằng cách sử dụng một lớp gọi là ModelConfiguration.

Cấu hình mô hình mô tả sự tồn tại của một lược đồ.

Nó kiểm soát nơi dữ liệu được lưu trữ, như trong bộ nhớ cho dữ liệu tạm thời hoặc trên đĩa cho dữ liệu liên tục.

ModelConfiguration có thể sử dụng một URL tệp cụ thể do bạn chọn hoặc nó có thể tự động tạo một URL bằng cách sử dụng các quyền của ứng dụng của bạn như quyền vùng chứa nhóm.

Cấu hình cũng có thể mô tả rằng một tệp bền bỉ nên được tải ở chế độ chỉ đọc, ngăn chặn việc ghi vào dữ liệu nhạy cảm hoặc mẫu.

Và cuối cùng, các ứng dụng sử dụng nhiều hơn một vùng chứa CloudKit có thể chỉ định nó như một phần của Cấu hình mô hình cho Lược đồ.

Hãy tưởng tượng tôi muốn thêm một số thông tin liên hệ vào SampleTrips bằng cách sử dụng các lớp Người và Địa chỉ mới.

Đầu tiên, lược đồ tổng được khai báo chứa tất cả các loại tôi muốn sử dụng.

Tiếp theo, một Cấu hình được khai báo cho dữ liệu SampleTrips chứa các mô hình Trip, BucketListItem và LivingAccommodations.

Nó khai báo URL cho tệp tôi muốn sử dụng để lưu trữ dữ liệu của biểu đồ đối tượng cụ thể này và mã định danh vùng chứa cho vùng chứa CloudKit mà tôi muốn sử dụng khi đồng bộ hóa dữ liệu SampleTrips với CloudKit.

Sau đó, các mô hình cho Lược đồ mới với Người và Địa chỉ được khai báo trong cấu hình riêng của chúng với URL tệp duy nhất và mã định danh vùng chứa CloudKit để giữ dữ liệu này tách biệt với biểu đồ Chuyến đi.

Cuối cùng, Lược đồ và cấu hình được kết hợp để tạo thành ModelContainer.

Với sức mạnh của ModelConfiguration, thật dễ dàng để mô tả các yêu cầu bền bỉ của ứng dụng của bạn, bất kể chúng có phức tạp đến đâu.

Ngoài việc khởi tạo vùng chứa bằng tay, các ứng dụng SwiftUI có thể sử dụng công cụ sửa đổi modelContainer mới để tạo vùng chứa mà chúng muốn làm việc.

Công cụ sửa đổi modelContainer có thể được thêm vào bất kỳ Chế độ xem hoặc Cảnh nào trong một ứng dụng và nó hỗ trợ ModelContainers từ đơn giản đến mạnh mẽ và mọi thứ ở giữa.

Trong phần này, tôi đã kiểm tra cách kết hợp Lược đồ với sự kiên trì bằng cách sử dụng ModelContainer.

Nó phát triển cùng với ứng dụng của bạn khi bạn xây dựng các tính năng và biểu đồ đối tượng mạnh mẽ hơn bao giờ hết.

Và tôi đã chứng minh cách bạn có thể sử dụng ModelConfiguration để mở khóa các khả năng bền bỉ mạnh mẽ.

Như chúng ta đã học trong "Gặp gỡ SwiftData", Model và ModelContext là hai trong số những khái niệm được sử dụng thường xuyên nhất khi viết giao diện người dùng hoặc hoạt động trên các đối tượng mô hình.

Trong phần này, tôi sẽ đi sâu vào cách ModelContext theo dõi các thay đổi và tiếp tục chỉnh sửa thông qua ModelContainer.

Khi chúng tôi sử dụng công cụ sửa đổi modelContainer trong mã chế độ xem hoặc cảnh, nó sẽ chuẩn bị môi trường của ứng dụng theo một cách cụ thể.

Công cụ sửa đổi liên kết khóa modelContext mới trong môi trường với mainContext của vùng chứa.

Bối cảnh chính là bối cảnh mô hình liên kết MainActor đặc biệt dành cho việc làm việc với ModelObjects trong các cảnh và chế độ xem.

Bằng cách sử dụng ngữ cảnh mô hình từ môi trường, mã xem có thể dễ dàng truy cập vào ngữ cảnh được sử dụng bởi Truy vấn ở đây để nó có thể thực hiện các hành động như xóa ở đây.

Vì vậy, bối cảnh mô hình rất dễ sử dụng và truy cập nhưng chúng thực sự làm gì?

Chúng ta có thể nghĩ về ModelContext như một cái nhìn về dữ liệu mà một ứng dụng quản lý.

Dữ liệu chúng tôi muốn làm việc được tìm nạp vào bối cảnh mô hình khi nó được sử dụng.

Trong SampleTrips, khi chế độ xem các chuyến đi sắp tới tải dữ liệu cho danh sách, mỗi đối tượng chuyến đi sẽ được tìm nạp vào ngữ cảnh chính.

Nếu một chuyến đi được chỉnh sửa, thay đổi đó sẽ được ghi lại bởi ngữ cảnh mô hình dưới dạng ảnh chụp nhanh.

Khi các thay đổi khác được thực hiện, như chèn một Chuyến đi mới hoặc xóa một Chuyến đi hiện có, ngữ cảnh sẽ theo dõi và duy trì trạng thái về những thay đổi này cho đến khi bạn gọi "context.save()".

Điều này có nghĩa là mặc dù chuyến đi đã xóa không còn hiển thị trong danh sách, nhưng nó vẫn tồn tại trong ModelContext cho đến khi việc xóa đó được duy trì bằng cách gọi lưu.

Khi lưu được gọi, ngữ cảnh vẫn tiếp tục thay đổi đối với ModelContainer và xóa trạng thái của nó.

Nếu bạn vẫn đang tham khảo các đối tượng trong ngữ cảnh, như hiển thị chúng trong danh sách, chúng sẽ tồn tại trong ngữ cảnh cho đến khi bạn hoàn thành chúng.

Tại thời điểm đó họ sẽ được giải phóng và bối cảnh trống rỗng.

ModelContext hoạt động phối hợp với ModelContainer mà nó bị ràng buộc.

Nó theo dõi các đối tượng bạn tìm nạp trong chế độ xem của mình và sau đó truyền bá bất kỳ thay đổi nào khi lưu thực hiện.

ModelContext cũng hỗ trợ các tính năng như khôi phục hoặc đặt lại để xóa trạng thái được lưu trong bộ nhớ cache khi cần thiết.

Điều này làm cho nó trở thành nơi lý tưởng để hỗ trợ các tính năng nền tảng như hoàn tác và tự động lưu.

Trong các ứng dụng SwiftUI, công cụ sửa đổi modelContainer có đối số isUndoEnabled này, liên kết trình quản lý hoàn tác của cửa sổ với bối cảnh chính của vùng chứa.

Điều đó có nghĩa là khi các thay đổi được thực hiện trong ngữ cảnh chính, các cử chỉ hệ thống như vuốt và lắc ba ngón tay có thể được sử dụng để hoàn tác hoặc làm lại các thay đổi mà không cần thêm mã.

ModelContext tự động đăng ký hoàn tác và làm lại các hành động khi các thay đổi được thực hiện đối với các đối tượng mô hình hóa.

Công cụ sửa đổi modelContainer sử dụng undoManager của môi trường thường được cung cấp bởi hệ thống như một phần của cửa sổ hoặc nhóm cửa sổ.

Và vì điều này, các cử chỉ hệ thống như vuốt và lắc ba ngón tay sẽ tự động hoạt động trong các ứng dụng của bạn.

Một tính năng hệ thống tiêu chuẩn khác được hỗ trợ bởi ModelContext là Autosave.

Khi tự động lưu được bật, ngữ cảnh mô hình sẽ lưu để phản hồi các sự kiện hệ thống như ứng dụng vào tiền cảnh hoặc nền sau.

Bối cảnh chính cũng sẽ lưu định kỳ khi một ứng dụng được sử dụng.

Tự động lưu được bật theo mặc định trong các ứng dụng và có thể bị vô hiệu hóa nếu muốn bằng cách sử dụng đối số isAutosaveEnabled của công cụ sửa đổi modelContainer.

Tự động lưu bị vô hiệu hóa cho các ngữ cảnh mô hình được tạo bằng tay.

Trong "Gặp gỡ SwiftData", chúng tôi đã học được rất nhiều về cách làm việc với ModelContext trong một ứng dụng và mức độ kết hợp của nó với SwiftUI.

Nhưng giao diện người dùng không phải là nơi duy nhất mà các ứng dụng cần làm việc với các đối tượng mô hình.

Trong phần này, tôi sẽ xem xét cách SwiftData làm cho việc viết mã mạnh mẽ, có thể mở rộng trở nên dễ dàng và an toàn hơn bao giờ hết.

Các tác vụ như làm việc với dữ liệu trên hàng đợi nền, đồng bộ hóa với máy chủ từ xa hoặc cơ chế bền bỉ khác và xử lý hàng loạt đều hoạt động với các đối tượng mô hình, thường xuyên trong các tập hợp hoặc đồ thị.

Nhiều tác vụ trong số này sẽ bắt đầu bằng cách tìm nạp một tập hợp các đối tượng để làm việc thông qua phương thức tìm nạp trên ModelContext.

Trong ví dụ này, FetchDescriptor cho mô hình Trip cho Swift biết rằng mảng trips sẽ là một tập hợp các đối tượng Trip.

Không có bộ đúc hoặc kết quả phức tạp nào phải lo lắng.

FetchDescriptor giúp dễ dàng tạo các truy vấn phức tạp bằng cách sử dụng macro Predicate mới.

Ví dụ, tất cả các chuyến đi liên quan đến việc ở tại một khách sạn cụ thể là gì?

Hoặc những chuyến đi nào vẫn có một số hoạt động mà tôi cần đặt chỗ trước?

Trong SwiftData, các truy vấn phức tạp hỗ trợ các truy vấn con và tham gia đều có thể được viết bằng swift thuần túy.

Predicate sử dụng các Mô hình bạn tạo và SwiftData sử dụng Lược đồ được tạo từ các mô hình đó để dịch các vị ngữ này thành các truy vấn cơ sở dữ liệu.

FetchDescriptor kết hợp sức mạnh của macro Foundation Predicate mới với Schema để lần đầu tiên đưa các truy vấn được xác thực trình biên dịch vào sự tồn tại trên các nền tảng của Apple.

FetchDescriptor và các lớp liên quan, như SortDescriptor, sử dụng generics để tạo thành loại kết quả và cho trình biên dịch biết về các thuộc tính của mô hình bạn có thể sử dụng.

Có một số tùy chọn điều chỉnh mà bạn đã biết và yêu thích, như bù đắp và giới hạn, cũng như các thông số cho lỗi và tìm nạp trước.

Tất cả sức mạnh này kết hợp trong hàm liệt kê mới trên ModelContext.

Nó được thiết kế để giúp làm cho mô hình dễ dàng của việc di chuyển hàng loạt và liệt kê ngầm hiệu quả bằng cách gói gọn các phương pháp hay nhất của nền tảng tại một trang web cuộc gọi duy nhất.

Enumerate hoạt động tuyệt vời với FetchDescriptors bất kể độ phức tạp của chúng, từ đơn giản đến mạnh mẽ và mọi thứ ở giữa.

Enumerate tự động triển khai các phương pháp hay nhất trên nền tảng cho các chuyến đi như bảo vệ hàng loạt và đột biến.

Những thứ này có thể tùy chỉnh để đáp ứng nhu cầu của trường hợp sử dụng cụ thể của bạn.

Ví dụ, kích thước lô được liệt kê sử dụng mặc định là 5.000 đối tượng.

Nhưng tôi có thể thay đổi nó thành 10.000 để giảm các hoạt động I/O trong quá trình di chuyển với chi phí tăng trưởng bộ nhớ.

Các biểu đồ đối tượng nặng hơn, như những biểu đồ bao gồm hình ảnh, phim hoặc các đốm màu dữ liệu lớn khác, có thể chọn sử dụng kích thước lô nhỏ hơn.

Giảm kích thước lô làm giảm tăng trưởng bộ nhớ nhưng tăng I/O trong quá trình liệt kê.

Liệt kê cũng bao gồm bảo vệ đột biến theo mặc định.

Một trong những nguyên nhân thường gặp nhất của các vấn đề về hiệu suất với các chuyến đi lớn là các đột biến bị mắc kẹt trong bối cảnh trong quá trình liệt kê.

allowEscapingMutations cho enumerate biết rằng đây là cố ý, khi không được đặt, enumerate sẽ ném nếu nó phát hiện ra rằng ModelContext thực hiện liệt kê là bẩn, ngăn nó giải phóng các đối tượng đã được duyệt qua.

Trong phiên này, chúng tôi đã học cách tạo các cấu hình bền vững mạnh mẽ với Schema và ModelConfiguration.

Chúng tôi cũng đã học được cách dễ dàng áp dụng các thực hành hệ thống tiêu chuẩn như hoàn tác và làm lại với ModelContainer và ModelContext.

Và bạn có thể sử dụng SwiftData ngay hôm nay để viết mã an toàn, hiệu quả trong dự án của mình hơn bao giờ hết với FetchDescriptor, vị ngữ và liệt kê.

Tôi nóng lòng muốn xem cách bạn đẩy giới hạn của những gì có thể với khuôn khổ mới này trong những tháng và năm tới.

Cảm ơn vì đã xem và viết mã vui vẻ.