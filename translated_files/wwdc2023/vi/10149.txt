10149

♪ ♪

Philippe: Xin chào, tên tôi là Philippe.

Tôi thực sự vui mừng được giới thiệu một tính năng mới kỳ diệu trong Swift: Quan sát.

Tính năng này cho phép bạn xác định các mô hình của mình bằng cú pháp Swift tiêu chuẩn và sử dụng các loại đó để giao diện người dùng phản hồi các thay đổi đối với mô hình đó.

Điều này làm cho việc phát triển với SwiftUI trở nên liền mạch và trực quan.

Hôm nay chúng tôi sẽ đề cập đến một vài chủ đề: Tổng quan về Quan sát là gì, một bộ quy tắc tiện dụng về thời điểm sử dụng trình bao bọc thuộc tính từ SwiftUI, sau đó chúng tôi sẽ đề cập đến một số cách sử dụng nâng cao hơn của có thể quan sát được.

Và chúng ta sẽ kết thúc với một số ví dụ về cách cập nhật mã từ việc sử dụng ObservableObject lên macro @Observable mới.

Quan sát là một tính năng Swift mới để theo dõi các thay đổi đối với các thuộc tính.

Nó hoạt động với các loại Swift bình thường và biến đổi chúng với phép thuật của macro.

Chúng tôi thường viết các kiểu mô hình dữ liệu và chúng có một số thuộc tính mà cuối cùng, chúng tôi sẽ muốn sử dụng trong SwiftUI.

Điều gì sẽ xảy ra nếu tôi nói với bạn rằng việc thêm @Observable là tất cả những gì bạn cần để làm cho giao diện người dùng phản hồi với những thay đổi trong mô hình dữ liệu của bạn?

Mới trong Swift 5.9 bạn có thể tạo ra các mô hình đơn giản hơn bao giờ hết.

Cái này sử dụng hệ thống macro mới trong Swift.

"@Observable" yêu cầu trình biên dịch Swift chuyển đổi mã của bạn từ những gì bạn đã viết sang một dạng mở rộng giúp loại có thể được quan sát.

Bạn có thể sử dụng các loại có thể quan sát được để cung cấp năng lượng cho chế độ xem SwiftUI của mình.

Và điều tuyệt vời là họ không cần bất kỳ loại trình bao bọc tài sản nào để hoạt động.

Tôi có một số mẫu ngon từ ứng dụng xe bán đồ ăn bánh rán của chúng tôi, vì vậy chúng ta hãy đi sâu vào ngay.

Ở đây chúng tôi có một cái nhìn đơn giản cho thấy bánh rán.

SwiftUI biết rằng mô hình truy cập các thuộc tính cụ thể khi thực hiện cuộc gọi nội dung.

Trong trường hợp này, nó có thể phát hiện ra rằng thuộc tính 'donuts' được truy cập khi thực hiện phần thân của chế độ xem menu bánh rán.

Khi nội dung được thực thi, SwiftUI theo dõi tất cả quyền truy cập vào các thuộc tính được sử dụng từ các loại 'Có thể quan sát được'.

Sau đó, nó lấy thông tin theo dõi đó và sử dụng nó để xác định khi nào thay đổi tiếp theo đối với bất kỳ thuộc tính nào trên các trường hợp cụ thể đó sẽ thay đổi.

Ở đây, nếu chúng ta thay đổi mảng bánh rán bằng cách nhấp vào nút thêm bánh rán, nó sẽ làm mất hiệu lực chế độ xem menu bánh rán và giao diện người dùng được cập nhật tương ứng.

Điều gọn gàng là nếu, giả sử một thứ tự được thêm vào, chế độ xem sẽ không bị vô hiệu vì thuộc tính đó không phải là một phần của các thuộc tính được theo dõi mà nó đã xác định khi thực hiện nội dung của chế độ xem.

Hãy trình bày tiếp theo những gì xảy ra khi bạn sử dụng một thuộc tính được tính toán.

Thêm vào một thuộc tính được tính toán tuân theo các quy tắc tương tự như trước đây.

Khi một thuộc tính được sử dụng thay đổi, giao diện người dùng sẽ cập nhật.

Trong nội dung mới được thêm vào, orderCount của mô hình được gọi, truy cập thuộc tính đơn hàng.

Vì vậy, điều đó có nghĩa là, trong ví dụ này nếu đơn đặt hàng thay đổi, văn bản đó sẽ được cập nhật vì orderCount truy cập thuộc tính của đơn đặt hàng.

Sử dụng macro "@Observable" sẽ mở rộng các loại của bạn để chúng có thể hỗ trợ Quan sát.

Điều này cho phép SwiftUI theo dõi quyền truy cập vào các thuộc tính đó và quan sát khi nào thuộc tính tiếp theo sẽ thay đổi khỏi Quan sát đó.

Theo dõi những thứ như vậy cho phép giao diện người dùng của bạn chỉ tính toán lại nội dung của các chế độ xem khi các thuộc tính cụ thể đó thay đổi, điều mà chúng tôi đã thấy một số cải tiến hiệu suất thực sự tuyệt vời từ đó.

Nếu bạn muốn đi sâu vào macro, hãy đảm bảo kiểm tra các phiên "Viết macro Swift" và "Mở rộng trên macro Swift".

Với Observable, các trình bao bọc thuộc tính cho SwiftUI thậm chí còn dễ dàng hơn bao giờ hết.

Trạng thái, môi trường và ràng buộc là ba trình bao bọc thuộc tính chính để làm việc với SwiftUI.

Chúng tôi đã đề cập đến trường hợp bạn không cần bất kỳ trình bao bọc thuộc tính nào để giao tiếp với các loại có thể quan sát được với SwiftUI, nhưng hãy đi sâu vào các trường hợp mà bạn làm.

Bắt đầu với @State.

Khi chế độ xem cần có trạng thái riêng được lưu trữ trong một mô hình, hãy sử dụng thuộc tính @State.

Ở đây chúng tôi có đối tượng mô hình có thể quan sát được Donut đang được sử dụng trong bản trình bày trang tính.

Khi trang tính được trình bày, biến trạng thái donutToAdd được sử dụng để liên kết các giá trị với các trường có thể chỉnh sửa.

Thuộc tính "donutToAdd" được quản lý bởi thời gian tồn tại của chế độ xem mà nó chứa trong đó.

Tiếp theo, @Environment.

Môi trường cho phép các giá trị được truyền bá dưới dạng các giá trị có thể truy cập trên toàn cầu.

Điều này cho phép mọi thứ được chia sẻ ở nhiều nơi.

Các loại có thể quan sát được hoạt động tuyệt vời ở đây vì các bản cập nhật do chúng tạo ra dựa trên quyền truy cập.

Khi gọi nội dung của chế độ xem menu xe tải thực phẩm, tên người dùng thuộc tính của đối tượng tài khoản được truy cập.

Vì vậy, khi Tên người dùng sẽ thay đổi, chế độ xem menu sẽ cập nhật.

Sản phẩm mới nhất của gia đình giấy gói tài sản là “@Bindable”.

Trình bao bọc tài sản có thể liên kết thực sự nhẹ.

Tất cả những gì nó làm là cho phép các ràng buộc được tạo ra từ loại đó.

Lấy ràng buộc ra khỏi một tài sản được bọc có thể ràng buộc thực sự dễ dàng.

Chỉ cần sử dụng cú pháp $ để có được sự ràng buộc với thuộc tính đó.

Thông thường, đây sẽ là ràng buộc với các loại có thể quan sát được.

Đối với chế độ xem bánh rán, chúng tôi có tên được hiển thị cùng với Văn bản.

Nhưng trên thực tế, chúng tôi muốn có thể chỉnh sửa cái tên đó.

Vì vậy, thay vì Văn bản, chúng ta có thể sử dụng TextField.

TextField đó có một ràng buộc.

Nó đọc từ ràng buộc để điền vào giá trị của TextField, nhưng nó cũng ghi lại vào ràng buộc khi người dùng thay đổi giá trị.

Để tạo ràng buộc với bánh rán, tất cả những gì chúng ta cần làm là sử dụng trình bao bọc thuộc tính '@Bindable' trên thuộc tính bánh rán.

Chú thích trình bao bọc thuộc tính cho phép chúng tôi sử dụng cú pháp '$donut.name' và tạo liên kết khi được sử dụng.

Để kết thúc các trình bao bọc, chỉ có ba câu hỏi bạn cần trả lời để sử dụng các mô hình có thể quan sát được trong SwiftUI.

Mô hình này có cần phải là trạng thái của chính chế độ xem không?

Nếu vậy, hãy sử dụng “@State”.

Mô hình này có cần phải là một phần của môi trường toàn cầu của ứng dụng không?

Nếu vậy, hãy sử dụng “@Môi trường”.

Có phải mô hình này chỉ cần ràng buộc?

Nếu vậy, hãy sử dụng '@Bindable' mới.

Và nếu không có câu hỏi nào trong số này có câu trả lời là có, chỉ cần sử dụng mô hình làm thuộc tính trong quan điểm của bạn.

Cho đến nay, chúng tôi đã đề cập đến các thuộc tính bắt đầu trong mô hình của bạn như được lưu trữ.

Có thể quan sát được có thể làm được nhiều hơn thế.

Bởi vì SwiftUI theo dõi quyền truy cập vào các trường cho mỗi trường hợp, điều đó có nghĩa là bạn có thể sử dụng mảng, tùy chọn hoặc cho vấn đề đó, bất kỳ loại nào có chứa các mô hình có thể quan sát được của bạn.

Chế độ xem danh sách bánh rán có một loạt các mô hình bánh rán.

Bản thân mỗi mô hình là “@Có thể quan sát được”.

Khi bất kỳ tên nào của những chiếc bánh rán đó thay đổi, SwiftUI sẽ phát hiện quyền truy cập vào thuộc tính đó trên phiên bản cụ thể đó và theo dõi nó để biết khi nào nên vô hiệu hóa chế độ xem.

Vì vậy, ở đây, khi tên bánh rán được thay đổi thông qua nút ngẫu nhiên hóa, chế độ xem sẽ cập nhật tương ứng.

Điều này cho phép bạn xây dựng các mô hình của mình theo cách bạn muốn.

Bạn có thể có các mảng mô hình đang được quan sát, hoặc thậm chí các loại mô hình có chứa các loại mô hình có thể quan sát được khác.

Nguyên tắc chung dành cho Observable, nếu một thuộc tính được sử dụng thay đổi, chế độ xem sẽ cập nhật.

Có một trường hợp quy tắc đó không được áp dụng đầy đủ.

Nếu một thuộc tính được tính toán không có bất kỳ thuộc tính được lưu trữ nào mà nó bao gồm, thì cần phải thực hiện thêm hai bước để làm cho nó hoạt động với Quan sát.

Điều này chỉ cần được thực hiện khi thuộc tính sẽ được quan sát không bị thay đổi thông qua một số loại thành phần của các thuộc tính được lưu trữ trong loại có thể quan sát được.

Trong trường hợp này, tất cả những gì cần làm là cho Quan sát biết khi nào tài sản được truy cập và khi nào tài sản thay đổi.

Đây là cách Observation tổng hợp quyền truy cập vào các thuộc tính một cách bình thường, ngoại trừ ở đây chúng tôi đã viết lại các điểm truy cập tùy chỉnh đó theo cách thủ công để vị trí không thể quan sát được có thể được đọc và lưu trữ tên.

Hầu hết thời gian, các loại trường hợp thủ công này là không cần thiết, bởi vì hầu hết thời gian, các thuộc tính của các mô hình được đề cập được cấu tạo từ các thuộc tính được lưu trữ khác.

Nhưng trong những trường hợp hiếm hoi mà bạn cần khả năng tiên tiến đó, Quan sát đủ linh hoạt nhưng đủ dễ dàng để tự mình thực hiện.

SwiftUI có thể xác định những thay đổi trong bố cục vì nó theo dõi các loại có thể quan sát được bằng cách truy cập vào các thuộc tính đó.

Điều này có nghĩa là nếu một thuộc tính được tính toán được cấu tạo từ các thuộc tính được lưu trữ khác, thì Quan sát sẽ chỉ hoạt động.

Tuy nhiên, trong một vài trường hợp điều đó không đúng, bạn có thể sử dụng Quan sát trực tiếp để thêm thủ công các cuộc gọi đó vào cờ truy cập và đột biến.

Trước đây trong ứng dụng Food Truck, chúng tôi đã sử dụng ObservableObject để đạt được một số điều tương tự như chúng tôi đã làm với macro @Observable mới.

Nếu bạn có một ứng dụng sử dụng SwiftUI ngày hôm nay, bạn có thể đang ở trong một tình huống rất giống nhau.

Macro Observable có thể đơn giản hóa mã của bạn và rất có thể, bạn cũng có thể thấy hiệu suất tăng lên tốt.

Trước khi thay đổi, loại FoodTruckModel có sự phù hợp ObservableObject và nó có một số thuộc tính được đánh dấu bằng trình bao bọc thuộc tính @Published.

Việc chuyển sang macro @Observable khá dễ dàng.

Tất cả những gì chúng tôi cần làm là xóa sự phù hợp với ObservableObject, xóa '@Published' và đánh dấu nó bằng macro '@Observable'.

Khi nói đến các chế độ xem, có một số trình bao bọc thuộc tính '@ObservedObject' và '@EnvironmentObject'.

Trong tất cả các trường hợp của trình bao bọc '@ObservedObject', hoặc biến mất hoặc chỉ cần các ràng buộc và thay đổi thành '@Bindable' mới.

Các trình bao bọc '@EnvironmentObject' đã được chuyển đổi thành chỉ '@Environment'.

Thay đổi từ ObservableObject sang macro '@Observable' mới chủ yếu chỉ là xóa các chú thích.

Hoặc đơn giản hóa chúng thành ba trình bao bọc thuộc tính chính; @State, @Environment và @Bindable.

Điều này làm cho việc viết các tính năng mới dễ suy luận hơn vì có ít lựa chọn hơn cần được xem xét.

Quan sát có mức độ ma thuật phù hợp.

Nó cho phép bạn bắt đầu dễ dàng và cho phép bạn làm việc trực tiếp với các mô hình dữ liệu của mình bằng cách sử dụng macro @Observable.

Khi bạn cần, nó cho phép bạn viết các phiên bản thủ công cho các trường hợp sử dụng nâng cao.

Đối với sự phát triển mới, sử dụng Observable là cách dễ nhất để bắt đầu.

Và đối với các ứng dụng hiện có, sử dụng Observable có thể đơn giản hóa các mô hình của bạn và cải thiện hiệu suất khi thêm các tính năng mới.

Tôi khuyến khích bạn thử nó và tự khai thác phép thuật đó.

♪ ♪