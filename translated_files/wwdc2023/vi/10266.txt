10266

♪ ♪

Robert: Xin chào Tên tôi là Robert Kendall-Kuppe và hôm nay tôi sẽ nói chuyện với bạn về một tính năng macOS mới mà chúng tôi gọi là "những hạn chế về môi trường".

Các ứng dụng Mac giàu tính năng thường không chỉ là một quy trình hoặc tệp.

Các khung và thư viện cho phép bạn sử dụng lại mã trên các ứng dụng của mình hoặc từ các nhà phát triển khác.

Các công cụ trợ giúp, ứng dụng trợ giúp và dịch vụ XPC cho phép bạn phân chia công việc để giảm bề mặt tấn công.

Khởi chạy các tác nhân, khởi chạy trình nền và các mục đăng nhập cho phép bạn thực hiện công việc trong nền hoặc khi đăng nhập người dùng.

Và các tiện ích mở rộng ứng dụng cho phép bạn cung cấp chức năng hữu ích trong các ứng dụng khác.

Nhưng các ứng dụng của bạn chạy trong một môi trường có khả năng thù địch.

Các kiến trúc sư ứng dụng cần xem xét các tác động tiềm tàng của phần mềm chưa biết chạy cùng với phần mềm của họ hoặc sử dụng các khuôn khổ của họ.

Việc thực thi công cụ trợ giúp hoặc dịch vụ XPC của bạn có thể cung cấp cho kẻ tấn công quyền truy cập vào dữ liệu chuỗi khóa của bạn không?

Còn dữ liệu iCloud của bạn hoặc một số đặc quyền khác thì sao?

Điều gì có thể xảy ra nếu mã bất ngờ được đưa vào quy trình của bạn?

Cũng giống như trong các mối quan hệ cha mẹ-con cái thực sự, các quy trình cha mẹ có ảnh hưởng rất lớn đến cách con cư xử.

Trên macOS, sức mạnh để posix_spawn một quy trình khác mang lại cho cha mẹ khả năng kiểm soát gần như tất cả đầu vào cho con.

Quá trình phụ huynh cũng có thể hạn chế quyền truy cập của trẻ vào tài nguyên hệ thống.

Mức độ kiểm soát này có thể khiến đứa trẻ tải mã bất ngờ, chạy các tính năng không mong muốn hoặc hoạt động theo những cách khiến quá trình dễ bị tấn công hơn.

Tuy nhiên, ngoài mối quan hệ cha-con, các quy trình đặt niềm tin vào bố cục đĩa mà chúng sinh ra.

Các quy trình độc hại có thể sửa đổi các tệp trên đĩa có thể cung cấp dữ liệu không mong muốn cho quy trình nạn nhân, xóa các biện pháp bảo vệ thời gian chạy khỏi quy trình nạn nhân, thực thi liên tục trên hệ thống hoặc đánh cắp các đặc quyền của quy trình.

Đối mặt với tất cả những mối đe dọa đó, macOS cung cấp cho bạn các công cụ để bảo mật các ứng dụng của bạn.

Đặc biệt, bạn có thể áp dụng Hộp cát ứng dụng để hạn chế tác động nếu ứng dụng của bạn bị xâm phạm.

Và bạn có thể áp dụng Hardened Runtime và xác thực thư viện để bảo vệ tính toàn vẹn của các quy trình của bạn trong thời gian chạy.

Gatekeeper và Notarization cũng giúp giữ cho hệ thống khách hàng không có mã độc đã biết.

Suy nghĩ về các mối đe dọa mà tôi đã đề cập trước đây, chúng tôi nhận ra rằng các biện pháp bảo vệ hiện tại của chúng tôi tập trung vào các quy trình đang chạy hơn là môi trường thực thi của chúng.

Đó là lý do tại sao chúng tôi giới thiệu những hạn chế về môi trường.

Các ràng buộc về môi trường cung cấp cho bạn một cấp độ kiểm soát mới đối với các trường hợp mà các quy trình của bạn có thể chạy và các cách bạn có thể trộn mã trong một quy trình.

Trong phần còn lại của bài nói chuyện này, chúng ta sẽ thảo luận về cách các ràng buộc môi trường phù hợp với kiến trúc bảo mật của macOS, cách các ràng buộc môi trường được cấu trúc và cách bạn có thể áp dụng các ràng buộc môi trường trong ứng dụng của mình.

Hãy lùi lại một chút và nói về ngăn xếp bảo mật macOS.

Theo mặc định, macOS tận dụng tất cả các công nghệ này để bảo mật chuỗi khởi động, đảm bảo tính toàn vẹn của hệ điều hành, thực thi tách đặc quyền và bảo vệ người dùng khỏi phần mềm độc hại.

Trong macOS Ventura, chúng tôi bắt đầu sử dụng các ràng buộc môi trường để bảo vệ tốt hơn các mối quan hệ giữa các quy trình hệ điều hành.

Họ cung cấp một chiều hướng bảo mật mới cho hệ điều hành.

Trong macOS Sonoma, chúng tôi đã mở rộng việc sử dụng các ràng buộc môi trường và mở chúng ra để bạn sử dụng trong các ứng dụng của mình.

Vậy những hạn chế về môi trường là gì?

Về cơ bản, chúng là một cách để mô tả mã, không chỉ mã là gì, mà còn là cách mã được kỳ vọng sẽ tồn tại và chạy trên hệ thống.

Trong macOS, chúng tôi sử dụng các ràng buộc môi trường cho nhiều mục đích khác nhau.

Ví dụ, để giúp đảm bảo các quy trình đang sử dụng tài nguyên gói đáng tin cậy, chúng tôi yêu cầu các quy trình hệ điều hành chạy từ Khối lượng hệ thống đã ký.

Để đảm bảo rằng các trình nền đặc quyền không chạy với các đối số bất ngờ hoặc cổng Mach, chúng tôi yêu cầu các trình nền hệ thống chỉ được chạy dựa trên launchd.plist được bảo vệ của chúng.

Để giảm bề mặt tấn công của các ứng dụng hệ thống, chúng tôi yêu cầu chúng được chạy từ Dịch vụ Khởi chạy dưới dạng ứng dụng và để đảm bảo rằng sự chấp thuận của người dùng đối với các mục nền có răng, chúng tôi sử dụng các ràng buộc môi trường để phát hiện các thay đổi.

Bây giờ bạn có thể đang hỏi. "Ứng dụng của tôi có cần áp dụng các ràng buộc về môi trường không?

Tôi muốn nhấn mạnh rằng các ràng buộc môi trường là hoàn toàn tùy chọn, nhưng chúng có thể làm giảm bề mặt tấn công của bất kỳ ứng dụng nào.

Chúng ta sẽ thảo luận về một số trường hợp sử dụng ví dụ cụ thể hơn sau trong buổi nói chuyện này.

Tuy nhiên, tôi sẽ lưu ý rằng các ràng buộc môi trường có thể đặc biệt hữu ích nếu ứng dụng của bạn có nhiều quy trình hoặc tải mã được ký bởi các nhóm nhà phát triển khác nhau.

Có một vài loại ràng buộc môi trường khác nhau, vì vậy trước tiên hãy nói về các ràng buộc khởi chạy.

Các ràng buộc khởi chạy được nhúng vào một tệp nhị phân cụ thể và xác định các thuộc tính của quy trình đó, các thuộc tính của các quy trình có thể là cha mẹ của nó hoặc các thuộc tính của các quy trình có thể chịu trách nhiệm về nó.

Chúng tôi sẽ gọi các thuộc tính này là "tự ràng buộc", "hạn chế quy trình mẹ" và "hạn chế quy trình có trách nhiệm".

Bạn có thể áp dụng cả ba vào nhị phân của mình hoặc chọn những cái có ý nghĩa nhất.

Một quy trình có ràng buộc khởi chạy nhúng sẽ không chạy nếu bất kỳ thuộc tính được yêu cầu nào không được thỏa mãn.

Bây giờ chúng ta hãy xem qua một số mối quan hệ quy trình và nói về cách bạn có thể sử dụng các ràng buộc khởi chạy để bảo mật chúng.

Đầu tiên hãy giả sử rằng MyDemo.app là ứng dụng của bạn.

Bạn có thể đặt tự ràng buộc trên ứng dụng MyDemo.app của tôi để yêu cầu nó khởi chạy dưới dạng ứng dụng từ Dịch vụ Khởi chạy.

Khi ứng dụng của bạn yêu cầu kết nối với dịch vụ XPC của bạn, launchd sẽ sinh ra dịch vụ XPC và là cha mẹ của dịch vụ XPC đó nhưng ứng dụng của bạn "chịu trách nhiệm" cho dịch vụ XPC đó.

Bạn có thể đặt một ràng buộc quy trình có trách nhiệm trên MyXPCDemo.xpc để chỉ ra rằng chỉ MyDemo.app mới phải chịu trách nhiệm về nó.

Nếu ứng dụng của bạn sau này sử dụng NSTask hoặc posix_spawn để khởi chạy trình trợ giúp, thì nó vừa là cha mẹ vừa chịu trách nhiệm về trình trợ giúp đó.

Bạn có thể đặt ràng buộc quy trình mẹ trên MyFirstHelper để yêu cầu chỉ MyDemo.app mới có thể là cha mẹ của nó.

Sau đó, nếu người trợ giúp đầu tiên posix_spawns người trợ giúp thứ hai, người trợ giúp đầu tiên là cha mẹ của người trợ giúp thứ hai, nhưng ứng dụng chịu trách nhiệm cho người trợ giúp thứ hai.

Đối với MySecondHelper, bạn có thể đặt ràng buộc quy trình mẹ để yêu cầu nó chỉ được khởi chạy bởi MyFirstHelper và bạn có thể đặt ràng buộc quy trình có trách nhiệm để yêu cầu chỉ MyDemo.app chịu trách nhiệm về nó.

Bạn cũng có thể chỉ định một ràng buộc môi trường trong danh sách đã khởi chạy của mình cho các tác nhân khởi chạy và trình nền khởi chạy.

Khi bạn đăng ký plist của mình bằng cách sử dụng SMAppService API, hệ điều hành sẽ thực thi rằng chỉ một quy trình đáp ứng ràng buộc sẽ được khởi chạy thay mặt cho plist của bạn.

Tính năng này rất hữu ích để đảm bảo rằng mã độc không được thực thi liên tục dựa trên sự chấp thuận của người dùng đối với các hoạt động nền của ứng dụng của bạn.

Cuối cùng, bạn có thể sử dụng các ràng buộc tải thư viện để kiểm soát cụ thể mã có thể tải trong không gian địa chỉ của bạn.

Trước khi hạn chế tải thư viện, bạn có thể áp dụng xác thực thư viện hoặc không.

Xác thực thư viện cho phép quy trình của bạn tải mã mà bạn đã ký hoặc mã được Apple ký.

Với các ràng buộc tải thư viện, bạn có thể mô tả một bộ mã ít hạn chế hơn so với xác thực thư viện sẽ cho phép trong khi ngăn mã tùy ý được tải vào quy trình của bạn.

Tuy nhiên, lưu ý rằng bạn không thể loại trừ mã do Apple ký khỏi việc tải trong quy trình của mình và bạn cần chỉ định một hoặc nhiều thuộc tính để cho phép mã của riêng bạn.

Bây giờ bạn đã biết những hạn chế về môi trường là gì và chúng có thể được sử dụng như thế nào, hãy thảo luận về cách chúng được xác định.

Các ràng buộc về môi trường mô tả một tập hợp các điều kiện mà mã phải đáp ứng.

Chúng được mã hóa dưới dạng từ điển trong đó các khóa đại diện cho các sự kiện phải đúng về mã hoặc toán tử chỉ ra mối quan hệ bắt buộc giữa các sự kiện hoặc vị ngữ.

Ở cấp cao nhất, ngầm, kết quả của mỗi cặp khóa-giá trị được ANDed cùng nhau để quyết định xem ràng buộc có được thỏa mãn hay không.

Lưu ý rằng vì đây là từ điển, mỗi khóa chỉ có thể xuất hiện một lần cho mỗi cấp độ từ điển.

Hãy cùng xem một số sự thật mà bạn có thể muốn sử dụng.

Bên trái là các phím ràng buộc môi trường có liên quan và bên phải là đầu ra từ lệnh đồng thiết kế.

Khóa ký-định danh cho phép bạn chỉ định một chuỗi phải là duy nhất cho một đoạn mã nhất định, nhưng vẫn giữ nguyên trên các phiên bản của mã đó.

Khóa ký-định danh đề cập đến trường định danh trong đầu ra đồng thiết kế.

Khóa cdhash cho phép bạn chỉ định một hàm băm duy nhất cho mã nên được cho phép và khóa nhận dạng nhóm cho phép bạn chỉ định mã được ký bởi một nhóm phát triển cụ thể.

Trong khi các sự kiện chỉ ra các thuộc tính cụ thể của mã, các toán tử có thể được sử dụng để kết hợp hợp lý các tập hợp các sự kiện hoặc để xác định các tập hợp các giá trị chấp nhận được cho các sự kiện.

Như bạn có thể mong đợi, toán tử $and và $or cho phép bạn chỉ định từ điển của các vị ngữ sẽ được kết hợp một cách hợp lý sau khi chúng được quyết định.

Các toán tử $and-array và $or-array tồn tại để giới hạn việc lồng từ điển trong trường hợp bạn có thể muốn AND nhiều vị ngữ $ hoặc hoặc HOẶC nhiều $and vị ngữ.

Và cuối cùng, toán tử $in cho phép bạn chỉ định một mảng các giá trị sẽ đáp ứng một thực tế.

Hãy xem qua ràng buộc ví dụ này.

Ở bên trái, chúng tôi có một đại diện plist của ràng buộc.

Ở bên phải là mã giả hiển thị ý nghĩa của XML.

Ở cấp cao nhất của plist, có một phím, $ hoặc mảng.

Giá trị là một mảng gồm ba bộ.

Mỗi bộ chứa một toán tử và một từ điển mà toán tử đó sẽ được áp dụng, vì vậy điều đó có nghĩa là ràng buộc này cho phép tất cả mã được ký bởi mã định danh nhóm của bạn hoặc thư viện B được ký bởi mã định danh nhóm thứ hai hoặc thư viện C được ký bởi mã định danh nhóm thứ ba.

Đối với bộ đầu tiên, vì nó là một phần tử duy nhất, chúng ta cũng có thể đã sử dụng toán tử $ hoặc.

Bây giờ chúng ta có thể xác định các ràng buộc, hãy xem cách bạn có thể áp dụng chúng trong dự án của mình.

Với mục đích của cuộc thảo luận này, hãy xem xét một ứng dụng chính có chứa tác nhân khởi chạy, công cụ trợ giúp, khuôn khổ bao gồm dịch vụ XPC và thư viện được ký bởi một nhóm phát triển khác.

Bây giờ hãy xem xét một số vấn đề tiềm ẩn mà các hạn chế về môi trường có thể giảm thiểu.

Có lẽ bạn đã chỉ định một số đặc quyền cho một công cụ trợ giúp, như quyền truy cập vào dữ liệu chuỗi khóa hoặc quyền truy cập vào vùng chứa iCloud của bạn.

Bạn có thể muốn đảm bảo rằng công cụ trợ giúp chỉ có thể được khởi chạy bởi ứng dụng của bạn chứ không phải bất kỳ thứ gì khác.

Bạn có thể đảm bảo rằng chỉ có ứng dụng của bạn mới có thể khởi chạy công cụ trợ giúp của bạn bằng cách đặt ràng buộc quy trình mẹ trên công cụ trợ giúp.

Để làm điều này, hãy tạo một tệp plist yêu cầu mã yêu cầu mã định danh nhóm của bạn và mã định danh ký của ứng dụng chính của bạn.

Sau đó thêm ràng buộc vào cấu hình ký của công cụ trợ giúp của bạn trong cài đặt "Khởi chạy Plist Quy trình Phụ huynh Ràng buộc".

Chúng ta hãy xem xét kỹ hơn.

Ở đây tôi có một dự án demo trong Xcode với các thuộc tính mà tôi đã đề cập.

MyDemo.app là mục tiêu ứng dụng chính và demohelper là một công cụ trợ giúp.

Hãy khởi chạy ứng dụng.

Khi tôi nhấn nút này, ứng dụng sẽ tạo ra công cụ trợ giúp, sau đó công cụ trợ giúp thực hiện một số công việc và cung cấp phản hồi cho ứng dụng.

Hãy xem chữ ký của demohelper trong Terminal.

Chúng ta có thể thấy rằng nó không có ràng buộc khởi chạy nào được đặt ra và chúng ta có thể chạy demohelper.

Nhưng hãy nhìn vào đó.

Nếu chúng ta chạy demohelper với đối số --cloud, thì demohelper có thể truy cập dữ liệu iCloud của ứng dụng.

Chúng tôi không muốn một quy trình tùy ý có thể chạy demohelper và thay đổi dữ liệu iCloud của chúng tôi.

Hãy quay lại Xcode và đặt ràng buộc cha mẹ trên demohelper.

Ở đây tôi có một tệp plist ràng buộc đã được điền để xác định ứng dụng chính MyDemo.

Hãy thêm ràng buộc vào cấu hình ký kết của chúng tôi.

Bây giờ hãy xây dựng lại ứng dụng.

Chúng ta có thể khởi chạy lại ứng dụng...

Và ứng dụng chính vẫn có thể sinh ra người trợ giúp.

Nhưng khi chúng ta quay trở lại Terminal...

Chúng ta có thể thấy rằng bây giờ demohelper có một ràng buộc khởi chạy...

Và nó không còn có thể chạy từ Terminal nữa.

Khi một lần khởi chạy bị chặn vì vi phạm ràng buộc khởi chạy, một báo cáo sự cố được tạo ra cho thấy rằng ràng buộc đã bị vi phạm.

Bây giờ hãy nói về một vài vấn đề nữa mà những hạn chế về môi trường có thể giảm thiểu.

Chúng tôi khuyến khích bạn sử dụng các dịch vụ XPC để tách các đặc quyền giữa các quy trình khác nhau.

Nhưng khi bạn xây dựng các dịch vụ XPC, có thể trích xuất các dịch vụ đó từ gói của bạn và gọi chúng từ mã khác.

Nếu bạn đã chỉ định một số đặc quyền cho dịch vụ XPC của mình, bạn cần đảm bảo rằng chỉ các quy trình dự kiến mới có thể có quyền truy cập vào đặc quyền đó.

Một cách để đảm bảo rằng chỉ mã của bạn mới có thể truy cập dịch vụ XPC đó là đặt ràng buộc khởi chạy quy trình có trách nhiệm.

Ở đây chúng tôi hiển thị một plist ràng buộc khởi chạy cho phép mã được nhóm của bạn ký với danh sách các số nhận dạng ký cho từng quy trình trong gói có thể truy cập dịch vụ XPC.

Bạn có thể thêm ràng buộc vào cấu hình ký của mình trong cài đặt "Khởi chạy Plist quy trình có trách nhiệm ràng buộc".

Một vấn đề khác cần xem xét.

Bắt đầu từ macOS Ventura, người dùng được yêu cầu phê duyệt các tác vụ nền được cài đặt thay mặt cho ứng dụng của bạn.

Điều này có nghĩa là người dùng mong đợi rằng công việc chỉ diễn ra thay mặt cho ứng dụng của bạn.

Nếu kẻ tấn công có thể thay thế mã mà plist của bạn mong đợi chạy, kẻ tấn công có thể được thực thi nền liên tục thay mặt cho ứng dụng của bạn.

Để đảm bảo rằng plist đã đăng ký của bạn chỉ có thể được sử dụng để chạy mã mà bạn mong đợi, bạn có thể đặt ràng buộc plist đã khởi chạy bằng khóa SpawnConstraint.

Tại đây bạn có thể thấy một plist đã khởi chạy hoàn chỉnh với khóa SpawnConstraint.

Ràng buộc này xác định nhóm của chúng tôi và đại lý DemoMenuBar.

Cuối cùng, hãy nói về việc tải thư viện.

Nếu bạn có nghĩa vụ liên kết một thư viện từ một nhóm phát triển khác mà không cần sửa đổi, thì để ứng dụng của bạn được công chứng với thời gian chạy cứng, bạn sẽ phải áp dụng quyền xác thực thư viện vô hiệu hóa.

Thật không may, điều đó có nghĩa là ứng dụng của bạn hiện có thể tải mã có chữ ký của bất kỳ ai, không chỉ nhà phát triển đáng tin cậy mà bạn nhận được thư viện.

Để giải quyết vấn đề này, bạn có thể áp dụng ràng buộc tải thư viện.

Ở đây chúng tôi hiển thị một ràng buộc sẽ cho phép bạn tải bất kỳ mã nào được ký bởi nhóm của bạn hoặc nhà cung cấp thư viện đáng tin cậy.

Bạn cũng có thể hạn chế điều này hơn nữa đối với một thư viện hoặc tập hợp thư viện cụ thể bằng cách sử dụng một hoặc nhiều sự kiện nhận dạng ký tên.

Như với các ràng buộc khởi chạy, các ràng buộc tải thư viện được đăng nhập vào quy trình của bạn khi bạn đặt cài đặt "Danh sách ràng buộc tải thư viện" trong cấu hình ký Xcode của mình.

Vậy những hạn chế về môi trường có sẵn ở đâu?

Các ràng buộc tải thư viện và các ràng buộc plist đã khởi chạy có thể được bao gồm trong các ứng dụng nhắm mục tiêu đến bất kỳ phiên bản macOS nào.

Chúng được thực thi bắt đầu từ macOS Sonoma.

Các ràng buộc khởi chạy có thể được thêm vào các ứng dụng nhắm mục tiêu macOS 13.3 trở lên và chúng được thực thi bắt đầu từ macOS 13.3.

Lưu ý rằng bộ khóa và giá trị được hỗ trợ có thể được sử dụng trong các ràng buộc môi trường có thể thay đổi trên các phiên bản macOS.

Tham khảo tài liệu để biết thông tin đầy đủ về tình trạng sẵn có.

Hãy xem các mối quan hệ quy trình, danh sách đã khởi chạy và thư viện trong ứng dụng của bạn để xem liệu bạn có thể sử dụng các ràng buộc về môi trường để làm cho ứng dụng của mình an toàn hơn hay không.

Cảm ơn vì đã xem.

♪ ♪