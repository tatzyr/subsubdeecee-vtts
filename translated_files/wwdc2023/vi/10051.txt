10051

♪ ♪

David: Xin chào, tôi là David Ilenwabor, một Kỹ sư trong nhóm ShazamKit.

ShazamKit là một khuôn khổ cho phép bạn mang lại nhận dạng âm thanh cho các ứng dụng của mình.

Bạn có thể kết hợp âm thanh với danh mục âm nhạc rộng lớn của Shazam hoặc kết hợp với âm thanh được ghi sẵn của riêng bạn bằng cách sử dụng danh mục tùy chỉnh.

Năm 2022 đã chứng kiến một số cập nhật tuyệt vời cho ShazamKit đã cải thiện hoạt động với các danh mục tùy chỉnh trên quy mô lớn.

Đã có sự ra đời của Shazam CLI để xử lý quy trình làm việc nặng nề khi sử dụng danh mục tùy chỉnh, các mục phương tiện bị giới hạn thời gian để đồng bộ hóa tốt hơn và sai lệch tần số để phân biệt giữa hai bit âm thanh tương tự nhau.

Nếu bạn chưa quen thuộc với cách hoạt động của những thứ này, hãy xem Tạo danh mục Tùy chỉnh ở quy mô lớn với video ShazamKit.

Nhưng để cung cấp một cái nhìn tổng quan nhanh chóng, ShazamKit cho phép bạn thực hiện kết hợp bằng cách chuyển đổi âm thanh sang một định dạng đặc biệt được gọi là Chữ ký.

Bạn có thể chuyển một luồng bộ đệm âm thanh hoặc dữ liệu chữ ký vào phiên ShazamKit.

Phiên sau đó sử dụng chữ ký để tìm kết quả phù hợp trong Danh mục Shazam hoặc Danh mục Tùy chỉnh.

Nếu có một trận đấu, phiên sẽ trả về một đối tượng trận đấu với các mục phương tiện đại diện cho siêu dữ liệu của trận đấu.

Sau đó, bạn có thể hiển thị các mục phương tiện trong ứng dụng của mình.

ShazamKit có thể thực hiện kết hợp bằng cách tạo chữ ký từ luồng bộ đệm âm thanh hoặc sử dụng tệp chữ ký có thể được lưu trữ trên đĩa.

Chữ ký không thể đảo ngược, điều đó có nghĩa là không thể tái tạo lại bản ghi gốc từ chữ ký.

Điều này bảo vệ quyền riêng tư của khách hàng của chúng tôi.

Danh mục là một nhóm chữ ký với các mục phương tiện liên quan của chúng và kết quả khớp xảy ra khi chữ ký truy vấn khớp đủ với một phần của chữ ký tham chiếu trong danh mục.

Các trận đấu có thể xảy ra ngay cả khi chữ ký truy vấn ồn ào, chẳng hạn như nhạc đang phát trong nhà hàng.

Bây giờ tôi đã đề cập đến điều đó, tôi sẽ chuyển sang các bản cập nhật mới thú vị trong ShazamKit trong năm nay.

Trong phiên này, tôi sẽ trải qua những thay đổi mới để nhận dạng âm thanh với ShazamKit, sau đó tôi sẽ nói về API Thư viện Shazam, đã được xác định lại với chức năng mới thú vị.

Cuối cùng, tôi sẽ đưa bạn qua một số phương pháp hay nhất để tạo trải nghiệm ứng dụng tốt hơn với ShazamKit.

Trước khi tôi bắt đầu, tôi đề nghị bạn tải xuống dự án mã mẫu đính kèm trên cổng thông tin dành cho nhà phát triển.

Tôi sẽ tận dụng dự án này trong suốt video này.

Có rất nhiều thứ để giải quyết, vì vậy tôi sẽ bắt đầu.

Trước hết, nhận dạng âm thanh.

Quá trình sử dụng ShazamKit để nhận dạng âm thanh từ micrô có thể được tóm tắt trong các bước sau.

Đầu tiên, yêu cầu quyền micrô từ người dùng.

Sau đó, bắt đầu ghi âm sau khi quyền đã được cấp.

Tiếp theo, chuyển bộ đệm âm thanh đã ghi vào ShazamKit và cuối cùng, xử lý kết quả.

Để chứng minh điều này, tôi đã xây dựng một ứng dụng demo mà bạn có thể tìm thấy trong dự án mẫu.

Tôi thích khiêu vũ, và để theo kịp các xu hướng mới nhất, tôi đã xây dựng một ứng dụng để giúp tôi khám phá các bước nhảy thịnh hành cho một bài hát.

Ứng dụng hoạt động bằng cách nghe âm thanh bằng micrô và tiến hành tìm video khiêu vũ.

Vì vậy, ví dụ, tôi có thể nhờ Siri giúp tôi tìm một bài hát.

Này, Siri, chơi "Push It" của Dukes.

Siri: Đang phát "Push It" của Dukes.

David: Sau đó, tôi có thể nhấn vào nút Learn The Dance để bắt đầu ghi âm.

♪ ♪

ShazamKit nhận ra bài hát và ứng dụng tìm kiếm một video khiêu vũ thích hợp đi kèm với nó.

Có vẻ như tôi có một cái. Hừm!

Có vẻ như anh em sinh đôi Dancing Dave của tôi đang chỉ cho tôi một số động tác.

Điều này có vẻ thú vị.

Vậy điều này được thực hiện như thế nào?

Để tôi đưa bạn qua mã.

Ở đây tôi có dự án mẫu được mở trong Xcode.

Tôi đã thêm mô tả sử dụng micrô vào tệp info.plist của mình được sử dụng để yêu cầu quyền truy cập micrô.

Tôi cũng có một loạt các chế độ xem SwiftUI cho màn hình chính và màn hình video khiêu vũ.

Tuy nhiên, lớp Matcher này là nơi xảy ra tất cả sự kỳ diệu của nhận dạng âm thanh.

Khi khởi tạo, tôi có một phương pháp để cấu hình và thiết lập công cụ âm thanh.

Trong phương pháp này, tôi cài đặt một cú chạm để nhận PCMbuffers và chuẩn bị công cụ âm thanh.

Ngoài ra, tôi có một phương pháp kết hợp được gọi khi tôi nhấn vào nút Learn The Dance.

Tôi yêu cầu quyền ghi âm và nếu điều này được cấp, tôi gọi start trên công cụ âm thanh để bắt đầu ghi âm.

Tiếp theo, tôi nói rằng việc khớp giao diện người dùng đã bắt đầu, sau đó tôi gọi session.results và đợi một chuỗi kết quả kết quả kết hợp không đồng bộ.

Sau khi nhận được kết quả, tôi đặt đối tượng khớp nếu nó khớp và tôi xử lý các trường hợp không khớp và lỗi.

Lớp này cũng có chức năng stopRecording trong đó tôi dừng công cụ âm thanh.

Điều này hoạt động tốt, nhưng hãy chú ý cách tôi có rất nhiều mã thiết lập để định cấu hình công cụ âm thanh trước khi tôi có thể nhận bộ đệm âm thanh.

Điều này có thể là một thách thức để làm đúng, đặc biệt nếu bạn không quen với lập trình âm thanh.

Và vì vậy, để ghi và kết hợp dễ dàng hơn, chúng tôi đã giới thiệu một API mới có tên SHManagedSession.

Phiên được quản lý tự động đảm nhận việc bắt đầu ghi âm cho bạn mà không gặp rắc rối khi thiết lập bộ đệm âm thanh.

Điều này làm cho nó rất dễ cài đặt và sử dụng.

Cần có sự cho phép của micrô để sử dụng Phiên được quản lý.

Nếu không có sự cho phép này, phiên không thể bắt đầu ghi âm.

Do đó, điều quan trọng là bạn thêm mục mô tả sử dụng Micrô vào tệp info.plist của ứng dụng của bạn.

Phiên được quản lý sẽ sử dụng mô tả này khi yêu cầu quyền truy cập micrô từ người dùng.

Vậy làm thế nào tôi có thể sử dụng API này trong mã?

Đầu tiên, tôi sẽ tạo một phiên bản của SHManagedSession, sau đó tôi có thể đợi kết quả bằng cách gọi phương thức kết quả.

Phương thức này trả về một enum có ba trạng thái có thể là khớp, NoMatch hoặc lỗi.

Tiếp theo, tôi có thể chuyển đổi kết quả, sử dụng các mục phương tiện được trả về trong trường hợp khớp và xử lý các trường hợp không khớp và lỗi.

Và điều gì sẽ xảy ra nếu tôi muốn có một phiên ghi âm dài hơn có thể trả về nhiều kết quả theo thời gian?

Chà, tôi có thể làm điều này bằng cách sử dụng thuộc tính kết quả chuỗi không đồng bộ trên managedSession.

Tôi có thể sử dụng từng kết quả nhận được từ chuỗi giống như trước đây.

Điều này đảm bảo tôi có thể tiếp tục ghi âm thanh trong thời gian dài.

Cuối cùng, tôi có thể ngừng khớp bằng cách gọi hủy trên managedSession.

Điều này hủy bỏ mọi nỗ lực trận đấu hiện đang chạy và dừng ghi âm.

Và thế là xong.

Với Phiên được quản lý, chỉ cần một vài dòng mã để bắt đầu ghi và nhận kết quả sau khi khớp.

Quay trở lại ứng dụng của mình, tôi sẽ cập nhật triển khai Matcher để sử dụng managedSession.

Tôi có thể thay thế tất cả các trường hợp của SHSession bằng SHManagedSession.

Sau đó, tôi có thể xóa phương pháp cấu hình công cụ âm thanh và cách sử dụng nó.

Và trong phương pháp khớp, tôi có thể xóa các cuộc gọi để yêu cầu quyền ghi âm và khởi động công cụ âm thanh.

Cuối cùng, trong phương pháp stopRecording, tôi có thể thay thế mã hiện có để dừng công cụ âm thanh chỉ bằng một cuộc gọi đến phương thức hủy của managedSession.

Bây giờ, tôi sẽ chạy ứng dụng để đảm bảo mọi thứ vẫn hoạt động như mong đợi.

Này, Siri, chơi "Push It" của Dukes.

Siri: Đây là "Push It" của Dukes.

♪ ♪

Thật thú vị!

Mọi thứ vẫn hoạt động tốt, nhưng lần này, mã thậm chí còn tốt hơn và sạch hơn với Phiên được quản lý.

Đó không phải là tất cả.

Thậm chí còn có nhiều điều hơn để Quản lý Phiên để nói về.

Tùy thuộc vào trường hợp sử dụng của bạn, bạn có thể muốn managedSession chuẩn bị trước cho một nỗ lực trận đấu.

Chuẩn bị một Phiên được Quản lý làm cho phiên phản hồi nhanh hơn khi khớp.

Nó cũng phân bổ trước các nguồn lực cần thiết cho một trận đấu và, nó bắt đầu ghi âm trước với dự đoán về một nỗ lực trận đấu.

Để cung cấp cho bạn ý tưởng về lợi ích của việc sử dụng chuẩn bị, đây là dòng thời gian đại diện cho hành vi của phiên mà không cần gọi chuẩn bị.

Khi bạn yêu cầu kết quả, phiên phân bổ tài nguyên cho nỗ lực trận đấu, sau đó bắt đầu ghi âm, cuối cùng, nó trả về một trận đấu.

Tuy nhiên, khi bạn gọi chuẩn bị, phiên ngay lập tức phân bổ trước các tài nguyên và bắt đầu ghi âm trước.

Sau đó, khi bạn yêu cầu kết quả, phiên trả về một trận đấu nhanh hơn trước.

Để làm điều này bằng mã, tôi có thể chỉ cần gọi phương thức chuẩn bị trước khi yêu cầu kết quả.

Việc gọi phương thức này hoàn toàn tùy thuộc vào bạn và ShazamKit sẽ thay mặt bạn gọi nếu cần thiết.

Bây giờ, bạn có thể tự hỏi, "Làm cách nào để theo dõi hành vi hiện tại của phiên?

"Ví dụ, trong một phiên chạy dài, "làm thế nào để tôi biết nó đang ghi âm hoặc kết hợp hoặc làm điều gì đó khác?"

Để giải quyết vấn đề này, Phiên được quản lý có một thuộc tính được gọi là trạng thái đại diện cho trạng thái hiện tại của phiên.

Ba trạng thái là nhàn rỗi, ghi âm trước và khớp.

Ở trạng thái nhàn rỗi, phiên không ghi âm cũng như không thực hiện nỗ lực trận đấu.

Đây là trường hợp nếu phiên vừa hoàn thành một lần thử khớp duy nhất hoặc bạn gọi hủy, hoặc phiên kết thúc chuỗi kết quả không đồng bộ khi thực hiện nhiều kết quả.

Ghi âm trước đại diện cho trạng thái sau khi phiên đã được chuẩn bị.

Ở trạng thái này, tất cả các tài nguyên cần thiết để kết hợp đã sẵn sàng và phiên đang được ghi lại trước cho một nỗ lực kết hợp.

Sau đó bạn có thể tiến hành khớp hoặc hủy ghi âm trước.

Phù hợp là trạng thái có thể thứ ba cho thấy phiên đang thực hiện ít nhất một lần thử kết hợp.

Cuộc gọi chuẩn bị ở trạng thái này sẽ bị bỏ qua bởi phiên họp.

Đây là một ví dụ về cách trạng thái managedSession có thể được sử dụng trong SwiftUI để thúc đẩy hành vi xem.

Ở đây, tôi có triển khai mẫu của chế độ xem phụ từ ứng dụng demo.

Tôi đã thực hiện các hành vi khác nhau cho chế độ xem này nếu trạng thái không hoạt động hoặc phù hợp.

Hiện tại, trạng thái của phiên không hoạt động và chế độ xem văn bản được đặt thành Nghe nhạc.

Ngoài ra, tôi có một điều kiện kiểm tra xem trạng thái có khớp hay không.

Nếu có, tôi sẽ hiển thị chế độ xem tiến trình và nếu không, tôi sẽ hiển thị nút Tìm hiểu Khiêu vũ.

Vì trạng thái hiện không hoạt động, nút Tìm hiểu Khiêu vũ được hiển thị.

Khi tôi nhấn vào nút, trạng thái thay đổi thành khớp và giao diện người dùng của tôi sẽ tự động làm mới.

Lần này văn bản được đặt thành Khớp và chế độ xem tiến trình sẽ thay thế nút kể từ khi quá trình khớp đã bắt đầu.

Bất cứ khi nào trạng thái của phiên thay đổi, SwiftUI sẽ tự động làm mới chế độ xem của bạn để phản hồi những thay đổi đó mà không cần làm thêm bất kỳ công việc nào.

Và điều này là do managedSession phù hợp với Observable, đây là một loại Swift mới giúp các đối tượng tự động truyền đạt các thay đổi của họ cho người quan sát.

Do đó, SwiftUI có thể dễ dàng phản hồi bất kỳ thay đổi trạng thái nào của managedSession.

Để tìm hiểu thêm về Observable, hãy xem video Khám phá Quan sát SwiftUI.

Bây giờ tôi đã đề cập đến nhận dạng âm thanh, tôi sẽ nói về thư viện Shazam.

Vào năm 2021, ShazamKit đã cung cấp một API cho phép các nhà phát triển viết kết quả khớp với Thư viện Shazam, miễn là nó có ID Shazam hợp lệ.

Điều này có nghĩa là nó tương ứng với một bài hát trong Danh mục Shazam.

Mục được thêm vào hiển thị trong mô-đun Nhận dạng Âm nhạc Trung tâm Điều khiển và ứng dụng Shazam nếu được cài đặt.

Nó cũng được đồng bộ hóa trên các thiết bị.

Không cần sự cho phép đặc biệt để ghi vào thư viện Shazam, nhưng tôi khuyên bạn nên tránh lưu trữ nội dung trong đó mà không làm cho khách hàng biết, vì tất cả các bài hát được lưu trong thư viện sẽ được quy cho ứng dụng đã thêm chúng.

Ở đây, bài hát thứ hai trong danh sách được quy cho ứng dụng ShazamKit Dance Finder.

Trong những năm qua, việc sử dụng API này đã trình bày các trường hợp sử dụng khác nhau và dẫn đến một số nhược điểm.

Ví dụ, điều gì sẽ xảy ra nếu bạn muốn xem các mục bạn đã thêm vào ứng dụng của riêng mình?

Giải pháp cần thiết sẽ là quản lý bộ nhớ cục bộ của riêng bạn có thể tẻ nhạt để xử lý và dễ bị lỗi.

Vì những nhược điểm này, một lớp học mới đã được giới thiệu có tên là SHLibrary.

Tôi khuyên bạn nên áp dụng SHLibrary, vì nó cung cấp các tính năng mở rộng hơn so với lớp SHMediaLibrary trước đó.

Một số tính năng cốt lõi của SHLibrary bao gồm thêm các mục phương tiện vào Thư viện Shazam, hoạt động giống như phương pháp tương ứng trong SHMediaLibrary; đọc các mục phương tiện; và xóa các mục phương tiện khỏi thư viện.

Lưu ý rằng ứng dụng của bạn chỉ có thể đọc và xóa những gì nó đã thêm vào thư viện.

Các mục được trả lại khi bạn đọc dành riêng cho ứng dụng của bạn và không đại diện cho toàn bộ thư viện.

Ngoài ra, cố gắng xóa một mục phương tiện mà ứng dụng của bạn chưa thêm vào sẽ gây ra lỗi.

Tiếp theo, tôi sẽ giải thích cách sử dụng SHLibrary.

Thêm với SHLibrary cũng đơn giản như gọi phương thức addItems của đối tượng thư viện mặc định.

Phương pháp này lấy một loạt các mục phương tiện được thêm vào.

Đọc từ thư viện cũng đơn giản không kém.

Ví dụ, đây là cách bạn có thể đọc các mục từ thư viện và điền chế độ xem Danh sách vào SwiftUI.

Bạn chỉ cần chuyển thuộc tính mục của đối tượng thư viện vào trình khởi tạo danh sách.

SHLibrary cũng phù hợp với loại Swift Observable mới, do đó, chế độ xem SwiftUI của bạn sẽ tự động tải lại khi có thay đổi.

Bạn cũng có thể đọc từ thư viện trong ngữ cảnh không phải giao diện người dùng.

Ví dụ: nếu tôi muốn truy xuất thể loại phổ biến nhất của người dùng từ Shazams được đồng bộ hóa của họ, tôi có thể yêu cầu các mục hiện tại của thư viện.

Sau đó, một khi tôi có cái này, tôi có thể lọc qua mảng các mục để có được tất cả các thể loại được trả về và đếm thể loại có tần suất cao nhất.

Cuối cùng, tôi có thể xóa các mục khỏi thư viện bằng cách gọi removeItems trên đối tượng thư viện, chuyển vào mảng các mục phương tiện cần xóa.

Quay trở lại ứng dụng của mình, vì tôi đã thêm các bài hát được nhận dạng vào thư viện của mình, tôi có thể sử dụng SHLibrary mới để đọc những bài hát này.

Trong RecentDancesView, tôi có một Danh sách chứa một mảng trống của mediaItems trong trình khởi tạo.

Tôi sẽ thay thế mảng trống bằng các mục từ SHLibrary để tự động đọc các mục thư viện của tôi.

Tôi sẽ chạy ứng dụng với những thay đổi này.

Ngay sau khi ứng dụng tải, tôi nhận được danh sách các bài hát mà ứng dụng đã thêm vào Thư viện Shazam.

Với SHLibrary, tôi nhận được chức năng này miễn phí và tôi không cần duy trì cơ sở dữ liệu các bài hát phù hợp.

Tiếp theo, tôi sẽ thêm thao tác Vuốt để xóa trên mỗi hàng, vì vậy tôi có thể xóa một bài hát khỏi thư viện.

Tôi có thể thêm swipeAction vào chế độ xem hàng.

Sau đó, khi nhấn nút vuốt, tôi có thể gọi phương thức removeItems của SHLibrary, chuyển vào mục phương tiện sẽ bị xóa.

Bây giờ đã xong, tôi sẽ chạy ứng dụng với những thay đổi này.

Tôi cũng đã mở ứng dụng trên iPad của mình.

Tôi có thể vuốt vào một mục trên iPhone của mình và nhấn vào nút xóa.

Các thay đổi được đồng bộ hóa và mục đã xóa cũng bị xóa khỏi danh sách trên iPad.

Điều này thật tuyệt vời.

Bây giờ bạn đã học được cách sử dụng API thư viện mới và cách bạn có thể sử dụng Phiên được quản lý để xử lý ghi âm, tôi sẽ hướng dẫn bạn một số phương pháp hay nhất và đưa ra một số mẹo khi sử dụng một số tính năng mới được giới thiệu trong năm nay.

SHManagedSession và SHSession có liên quan chặt chẽ với nhau.

Họ có thể đạt được gần như cùng một điều, mặc dù theo những cách khác nhau.

Sử dụng managedSession khi bạn muốn để ShazamKit xử lý bản ghi cho bạn.

Sử dụng SHSession khi bạn đang tạo bộ đệm âm thanh và chuyển chúng vào khung.

Sử dụng managedSession để nhận dạng âm thanh phát ra từ micrô hoặc AirPod.

Sử dụng SHSession khi bạn chỉ muốn nhận ra âm thanh phát trực tuyến từ micrô.

Việc khớp chữ ký tùy ý với managedSession không được hỗ trợ.

Do đó, nếu bạn có tệp chữ ký hoặc dữ liệu chữ ký được tải trong bộ nhớ, hãy sử dụng SHSession để khớp với nó.

Cuối cùng, managedSsession tự động xử lý các định dạng âm thanh để kết hợp, trong khi SHSession cho phép kết hợp với nhiều định dạng âm thanh PCM.

Nói về các định dạng âm thanh trong SHSession, trước đây, phương pháp matchStreamingBuffer chỉ cho phép khớp bộ đệm âm thanh PCM với các cài đặt định dạng cụ thể ở các tốc độ mẫu này.

Bộ đệm âm thanh với các cài đặt không được hỗ trợ dẫn đến NoMatch.

Với bản phát hành này, SHSession hiện hỗ trợ bộ đệm PCM với hầu hết các cài đặt định dạng, được lấy mẫu ở một loạt các mức giá.

Bạn có thể chuyển các bộ đệm này và SHSession sẽ xử lý việc chuyển đổi định dạng cho bạn.

Cuối cùng, nếu bạn có hai hoặc nhiều bit âm thanh nghe giống nhau trong một danh mục tùy chỉnh, ShazamKit hiện có thể trả về tất cả các kết quả phù hợp từ danh mục tùy chỉnh khi bạn chuyển chữ ký truy vấn khớp với nhiều chữ ký tham chiếu.

Các trận đấu được trả về, được sắp xếp theo chất lượng trận đấu tốt nhất và bạn có thể lọc cho kết quả trận đấu phù hợp mà bạn muốn.

Như một mẹo, chú thích đúng các chữ ký tham chiếu nghe giống nhau trong siêu dữ liệu tương ứng của chúng, vì vậy bạn có thể phân biệt giữa kết quả bạn muốn.

Đây là một ví dụ về cách bạn có thể đạt được điều này.

Giả sử tôi có một chương trình truyền hình trong đó mỗi tập phim đều có âm thanh giới thiệu giống nhau.

Tôi có thể tạo một TVShowCatalog với chữ ký tham khảo đại diện cho mỗi tập.

Tôi có thể tạo một phiên bằng cách sử dụng danh mục này và khi khớp với phần giới thiệu, ShazamKit sẽ trả về kết quả khớp với mediaItems của mỗi tập.

Sau đó, tôi có thể lọc qua mediaItems và chỉ trả lại mediaItems cho một tập cụ thể, ví dụ như Tập 2.

Đây là cách chú thích thích hợp giúp ích.

Bây giờ tôi đã trải qua tất cả các bản cập nhật thú vị trong năm nay, tôi sẽ kết thúc bằng cách chuyển trở lại ứng dụng tuyệt vời của mình và cố gắng học thêm một điệu nhảy nữa.

Tôi sẽ chuyển sang AirPods của mình và phát một bài hát.

Vì tôi đang sử dụng Managed Session trong ứng dụng, nó có thể nghe âm thanh đang phát trong AirPod và tìm một video khiêu vũ cho tôi.

Tôi sẽ nhấn vào điều khiển cảm ứng của AirPods để phát một bài hát và đợi ứng dụng phát hiện âm thanh.

Ngọt ngào!

Có vẻ như Dancing Dave đang thể hiện một vài động tác Afrobeat, mà tôi sẽ cố gắng hết sức để học sau buổi nói chuyện này.

Tôi hy vọng bạn cũng hào hứng như chúng tôi với những cập nhật mới này.

Cảm ơn bạn đã tham gia, và chúc bạn có một WWDC tuyệt vời.

♪ ♪