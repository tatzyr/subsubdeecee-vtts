10226

♪ ♪

Nathan: Xin chào mọi người. Tên tôi là Nathan.

Và tôi là một kỹ sư trong nhóm Xcode Debugger UI.

Hôm nay, tôi rất vui được giới thiệu với bạn Bảng điều khiển gỡ lỗi hoàn toàn mới sắp ra mắt trên Xcode 15.

Trong phiên này, tôi sẽ nhanh chóng cung cấp cho bạn một chuyến tham quan Bảng điều khiển gỡ lỗi.

Tiếp theo, tôi sẽ chỉ ra Bảng điều khiển gỡ lỗi có thể hữu ích như thế nào bằng cách chẩn đoán một lỗi thực sự trong ứng dụng của riêng tôi.

Sau đó, tôi sẽ giới thiệu cho bạn một số cải tiến sắp tới với LLDB.

Và cuối cùng, tôi sẽ chia sẻ các mẹo về cách bạn có thể tận dụng các API Ghi nhật ký Hợp nhất của Apple để cải thiện trải nghiệm chẩn đoán của mình.

Hãy cùng tìm hiểu và xem xét những gì mới trong Bảng điều khiển gỡ lỗi.

Trên thiết bị của tôi, tôi đã khởi chạy ứng dụng Backyard Birds.

Ứng dụng này cho phép người dùng quản lý sân sau và chăm sóc chim ảo.

Sau khi khởi chạy ứng dụng, Bảng điều khiển gỡ lỗi đã được điền với nhiều nhật ký.

Ngay lập tức, tôi nhận thấy bảng điều khiển không còn tiền tố mỗi nhật ký với siêu dữ liệu mà tôi đã quen.

Thay vào đó, sự chú ý tập trung vào thông điệp cơ bản mà nhà phát triển dự định cho tôi xem.

Tất nhiên, tôi vẫn có thể muốn xem thông tin bổ sung được liên kết với các nhật ký này, vì vậy chúng tôi cung cấp khả năng xem thông tin này bằng cách chọn nút tùy chọn siêu dữ liệu ở phía dưới bên trái của Bảng điều khiển gỡ lỗi và chọn các loại phù hợp nhất với nhu cầu hiện tại.

Trong trường hợp này tôi sẽ chọn, Loại, Thư viện, Hệ thống con và Danh mục.

Với điều này hiện được bật, siêu dữ liệu được đặt bên dưới mỗi nhật ký trong bảng điều khiển và được làm nhỏ hơn và tinh tế hơn để không lấy đi đầu ra dự định.

Tôi cũng có thể bắt gặp những khúc gỗ có nền màu vàng hoặc đỏ.

Điều này chỉ ra rằng những nhật ký này có tầm quan trọng cao hơn và đại diện cho lỗi và lỗi tương ứng.

Nếu tôi không muốn xem siêu dữ liệu của tất cả các nhật ký cùng một lúc, bảng điều khiển cho phép tôi kiểm tra siêu dữ liệu của một nhật ký duy nhất bằng cách chọn nhật ký được đề cập và sau đó xem nhanh nó bằng cách nhấn dấu cách.

Với điều này, một cửa sổ bật lên xuất hiện cung cấp cho tôi tất cả siêu dữ liệu có sẵn.

Điều này thậm chí còn bao gồm thông tin như trang web cuộc gọi nơi tên của hàm ban đầu phát ra nhật ký được hiển thị.

Mặc dù xem siêu dữ liệu bổ sung này rất tuyệt, nhưng nơi Bảng điều khiển gỡ lỗi mới thực sự tỏa sáng là khả năng lọc của nó.

Bảng điều khiển dễ dàng lấp đầy các bản ghi mà tôi không quan tâm, nhưng với Xcode 15, việc lọc chúng ra dễ dàng hơn bao giờ hết.

Giờ đây, bảng điều khiển có thể thực hiện lọc phức tạp, được mã hóa để dễ dàng xác định vị trí các bản ghi phù hợp nhất với nhu cầu của tôi.

Bảng điều khiển cũng cung cấp nhiều cách khác nhau để tạo ra các bộ lọc này.

Tất nhiên, bộ lọc có thể được nhập trực tiếp vào thanh bộ lọc, như thế này.

Trong khi làm như vậy, một cửa sổ bật lên tự động hoàn thành sẽ xuất hiện, cung cấp cho tôi sự hỗ trợ trong việc tạo bộ lọc mà tôi đang cố gắng nhập.

Ngoài ra, menu bộ lọc cung cấp quyền truy cập nhanh vào các bộ lọc cho các loại nhật ký cụ thể, cho phép tôi chọn các loại tôi muốn xem.

Và cuối cùng, khi tôi nhấp vào nhật ký thứ cấp mà tôi ít nhiều quan tâm, bảng điều khiển cung cấp các tùy chọn để ẩn và hiển thị các nhật ký tương tự để nhanh chóng tập trung vào hoặc loại trừ một bộ nhật ký cụ thể khỏi chế độ xem của tôi, như thế này.

Tất cả các phương pháp lọc này cho phép tôi cắt giảm nhanh chóng và hiệu quả tất cả các đầu ra mà tôi có, cho phép tôi xác định vị trí các bản ghi phù hợp nhất với nhu cầu gỡ lỗi hiện tại của mình.

Bây giờ, hãy sử dụng Bảng điều khiển gỡ lỗi mới để tìm và khắc phục sự cố thực sự với ứng dụng của tôi.

Tôi đã nhận được báo cáo rằng một số người dùng đã nhận thấy, sau khi cập nhật hồ sơ của họ, rằng nội dung dường như không được lưu.

Hãy cùng khám phá cách, bằng cách tận dụng các phương pháp ghi nhật ký tốt và một chút trợ giúp từ Bảng điều khiển gỡ lỗi mới, tôi có thể nhanh chóng và dễ dàng xác định nguyên nhân của lỗi này.

Đầu tiên, tôi sẽ cố gắng tạo lại vấn đề bằng cách chọn Tài khoản trong thanh tab.

Bây giờ tôi sẽ chọn bút chì để chỉnh sửa tài khoản của mình.

Cuối cùng, tôi sẽ thử thay đổi tên hiển thị của mình.

Sau đó, nó dường như đã hoạt động, nhưng nếu tôi thoát khỏi trang và xem lại tài khoản của mình, thay đổi dường như bị mất.

Bây giờ, một vài điều xuất hiện trong đầu có thể đã sai, nhưng hãy khám phá cách Bảng điều khiển gỡ lỗi mới có thể giúp tôi thu hẹp điều này để tìm ra gốc rễ của vấn đề này.

Trong khi thực hiện các bước này, một lượng lớn đầu ra đã được tạo ra trong Bảng điều khiển gỡ lỗi.

Rất may, với bảng điều khiển mới, thật tuyệt khi tìm thấy quá nhiều nhật ký, vì các bộ lọc có thể được đặt để tìm những gì tôi quan tâm nhất.

Trong trường hợp này, tôi có một vài danh mục chỉ dành riêng cho quản lý tài khoản.

Để tập trung vào những điều này, tôi sẽ lọc tất cả các danh mục trong dự án của mình có chứa "tài khoản" bằng cách nhập nó vào trường bộ lọc và chọn bộ lọc danh mục từ cửa sổ bật lên.

Điều này bây giờ để lại cho tôi tất cả các ghi nhật ký từ các phần liên quan đến tài khoản trong mã của tôi.

Với bộ lọc này, đầu ra trở nên dễ quản lý hơn nhiều.

Một vài trong số những nhật ký này dường như chỉ ra rằng tôi đã yêu cầu đặt thuộc tính "displayName".

Hãy điều tra sâu hơn để tìm hiểu lý do tại sao ứng dụng của tôi không hoạt động như tôi mong đợi.

Bây giờ, tôi không thể nhớ chính xác mã này nằm ở đâu, vì vậy bằng cách di chuột qua nhật ký, tôi quan tâm nhiều hơn và chọn vị trí nguồn ở góc dưới bên phải...

Xcode sẽ chuyển đến nguồn của nhật ký, trong trường hợp này, tôi đã yêu cầu đặt tên hiển thị.

Sau khi xem lại mã nguồn, tôi dường như gọi hàm setDisplayName trên tài khoản hiện tại để thực sự thực hiện thao tác này.

Hãy nhảy vào chức năng chịu trách nhiệm cập nhật thông tin tài khoản để điều tra sâu hơn về vấn đề này.

Sau khi xem xét mã này nhiều hơn, tôi đã phát hiện ra rằng trong khi tôi đang gửi những thay đổi này đến cơ sở dữ liệu tài khoản trung tâm của mình, tôi dường như đã quên cập nhật bộ nhớ cache tài khoản cục bộ.

Sau khi cập nhật cơ sở dữ liệu, tôi nên đặt tên hiển thị cục bộ thành tên mới, như thế này.

Trong khi tôi đang ở đó, tôi nhận thấy lỗi tương tự cho địa chỉ email.

Rất may, điều này có thể được khắc phục theo cùng một cách.

Bây giờ chúng ta hãy đặt một điểm dừng trên đường dây để xác minh sự nghi ngờ của tôi và kiểm tra xem điều này đã giải quyết được vấn đề của tôi chưa.

Bây giờ tôi sẽ xây dựng lại ứng dụng của mình và tạo lại các bước trước đó để tạm dừng tại vị trí này.

Sau khi đến địa điểm này, tôi muốn xác minh rằng sự nghi ngờ của tôi là đúng.

Để làm điều đó, tôi sẽ "po" trạng thái hiện tại của Tài khoản và kiểm tra xem tôi có nhận được dữ liệu cũ mà tôi đang mong đợi hay không.

Ồ, không. Có vẻ như tôi chỉ nhận được địa chỉ của đối tượng này.

Chà, tại sao vậy?

Hóa ra "po", mặc dù rất phổ biến, không phải là loại biểu thức tôi muốn chạy, vì tôi chưa khai báo mô tả gỡ lỗi tùy chỉnh của riêng mình cho lớp này.

Trên thực tế, trong trường hợp này, tôi chỉ muốn chạy "p", vì vậy hãy để tôi làm điều đó ngay bây giờ.

Bây giờ, đây là những gì tôi muốn, và điều này xác nhận sự nghi ngờ của tôi rằng tên hiển thị không được đặt một mình bằng cách cập nhật cơ sở dữ liệu.

Bây giờ chúng ta hãy bước qua dòng tôi đã thêm và xác nhận rằng tên hiển thị đã được cập nhật.

Hoàn hảo - có vẻ như bản cập nhật của tôi đã giải quyết được vấn đề này.

Bây giờ tôi có thể quay lại cho chim ăn.

Bây giờ chúng ta hãy "bước vào" LLDB bên trong Xcode 15, nơi chúng ta đã làm cho biểu thức LLDB đơn giản nhất thậm chí còn tốt hơn.

Nghĩ lại khi tôi đang giải quyết lỗi đó, tôi thấy mình đang sử dụng "po" ở một nơi không đúng.

Tốt nhất, điều này có thể làm cho biểu thức mất nhiều thời gian hơn để thực hiện, nhưng tệ nhất, nó có thể chỉ cần trả lại địa chỉ của thuộc tính khi tôi không triển khai CustomStringConvertible, như trường hợp của tôi.

Điều này khiến tôi thất vọng, khiến tôi ước rằng có một lựa chọn tốt hơn.

Sau đó tôi theo dõi điều này bằng cách chạy "p" trên tài sản, nơi tôi nhận được kết quả chính xác.

Tuy nhiên, có nhiều lệnh khác, như "biểu thức", "v", "vo", "biến khung", và nhiều lệnh khác mà tôi có thể cần phải nhớ.

Điều này có thể khó thực hiện, vì vậy để hỗ trợ các nhà phát triển, chúng tôi đang giới thiệu Do What I Mean Print.

Do What I Mean Print cho phép bạn tiết kiệm thời gian bằng cách sử dụng một lệnh duy nhất để đánh giá nhiều biểu thức khác nhau trong mã của bạn, tất cả trong khi trả lại cho bạn kết quả theo cách nhanh nhất có thể.

Tất nhiên, bạn không muốn nhập lệnh dài này mỗi khi bạn muốn kiểm tra một biến.

Do đó, chúng tôi đã thay thế bí danh "p" trước đó để bây giờ thực hiện Do What I Mean Print.

Điều này sẽ cho phép bạn chỉ cần chạy "p" cho phần lớn các trường hợp sử dụng.

Ngoài ra, đối với những lúc bạn thực sự muốn in mô tả đối tượng tùy chỉnh cho một biến, bạn có thể chạy lệnh Do What I Mean Print với cờ mô tả đối tượng tùy chọn.

Tuy nhiên, chúng tôi cũng đã thay thế bí danh "po" trước đó để bây giờ thực hiện Do What I Mean Print bằng mô tả đối tượng tùy chỉnh.

Bằng cách sử dụng các hàm Do What I Mean Print mới, giờ đây bạn có thể chạy một trong hai lệnh cho nhiều biểu thức khác nhau, trước đây, sẽ yêu cầu nhiều lệnh khác nhau để có được đầu ra dự định theo cách nhanh nhất có thể.

Cuối cùng, hãy xem xét các cách để đảm bảo mọi người đang tận dụng tối đa việc ghi nhật ký của họ, do đó cải thiện trải nghiệm gỡ lỗi của một người và cho phép bạn xác định vị trí và giải quyết hiệu quả hơn các vấn đề có thể khó tạo lại hoặc có thể dựa vào các báo cáo mà người dùng nhận được.

Đầu tiên, tôi sẽ nhắc nhở mọi người rằng I/O tiêu chuẩn dành cho giao diện người dùng dòng lệnh và OSLog dành cho gỡ lỗi.

Do đó, "in" hiếm khi được sử dụng để ghi lại các sự kiện trong quá trình thực thi chương trình của bạn.

Sẽ tốt hơn nhiều nếu sử dụng OSLog để có được ghi nhật ký có cấu trúc từ người dùng cuối cũng như giữ lại cấu trúc trong Bảng điều khiển gỡ lỗi.

Bây giờ chúng ta hãy dành một chút thời gian để làm việc thông qua một vài ví dụ về việc chuyển đổi từ I/O tiêu chuẩn sang OSLog dễ dàng như thế nào.

Đây là một chức năng đơn giản mà tôi muốn thêm một số ghi nhật ký bổ sung vào.

Thực hành tốt là ghi lại bất kỳ nhiệm vụ nào đang được thực hiện cũng như kết quả của việc thực hiện các nhiệm vụ đó.

Hãy để tôi dành một chút thời gian để thêm điều này theo cách tốt nhất mà tôi biết.

Tuyệt vời - Bây giờ tôi đã thêm một vài câu lệnh "in" đơn giản để giúp tôi làm theo mã này.

Bây giờ tôi đang in hành động tôi đang làm trong chức năng này cũng như in khi nhiệm vụ đã được hoàn thành với kết quả của nó.

Tuy nhiên, sau khi làm điều này đến nhiều nơi hơn trong dự án của tôi, thật khó để tìm thấy tất cả đầu ra này đến từ đâu.

Điều này đã khiến tôi bắt đầu thêm các điểm đánh dấu vào bản in của mình như nhiều người cần phải làm.

Tuy nhiên, cảm giác như nó đang vượt khỏi tầm kiểm soát.

Sau khi thêm tất cả đầu ra bổ sung này, nó đã làm lộn xộn bảng điều khiển của tôi hơn nữa.

Tôi chỉ ước có một cách tốt hơn để tôi có được tất cả siêu dữ liệu này mà không cần phải làm thêm tất cả công việc.

Chà, hóa ra OSLog chỉ làm những gì tôi cần.

Bây giờ, tôi muốn cập nhật chức năng này để tận dụng lợi thế của Ghi nhật ký hợp nhất.

Để bắt đầu, trước tiên tôi sẽ cần nhập OSLog vào dự án của mình, sau đó cho phép tôi tạo một trình xử lý nhật ký.

Đây là nơi tôi sẽ chỉ định hệ thống con và danh mục mà tôi muốn nhật ký của mình đại diện.

Đây có thể là bất kỳ chuỗi nào giúp việc lọc gỡ lỗi của tôi dễ dàng hơn, nhưng người ta thường sử dụng mã định danh gói cho hệ thống con và tên lớp hoặc thành phần cho danh mục.

Khi tôi đã tạo trình ghi nhật ký của mình, tất cả những gì tôi phải làm là gọi các chức năng được cung cấp trên đối tượng trình ghi nhật ký để chỉ định mức độ nhật ký và cung cấp thông báo tôi muốn hiển thị.

Điều này đọc tốt hơn nhiều và dẫn đến ít mã hơn đáng kể về lâu dài.

Bây giờ hãy để tôi có ý tưởng về cái này sẽ trông như thế nào trong bảng điều khiển khi tôi chạy nó.

Đối với điều này, hãy cô lập hai trong số các bản ghi này để chúng ta có thể kiểm tra tất cả siêu dữ liệu này sẽ đến từ đâu.

Trong đầu ra nhật ký, tôi sẽ tìm thấy thông báo mà tôi dự định xuất ra với siêu dữ liệu bổ sung mà tôi đã chỉ định cho nhật ký ngay bên dưới nó, nếu được bật.

Một số siêu dữ liệu này được thu thập từ vị trí nơi tôi đã viết nhật ký ban đầu, như tin nhắn và cấp độ.

Những cái khác được thu thập từ khi tôi tạo tay cầm nhật ký để lưu sự lặp lại, như hệ thống con và danh mục.

Và một số được xử lý trong nền.

Chúng bao gồm dấu thời gian, tên thư viện, ID quy trình, ID luồng và vị trí nguồn, chỉ để kể tên một số.

Tất cả thông tin này có thể hỗ trợ rất nhiều khi cần thiết nhưng chiếm rất nhiều không gian khi được in ra trên tất cả các bản ghi bất kể nhu cầu của một người.

Rất may, Bảng điều khiển gỡ lỗi mới cho phép bạn tùy chỉnh chế độ xem của nó để cung cấp đúng những gì bạn muốn.

Cuối cùng, để tận dụng tối đa việc ghi nhật ký của bạn, vui lòng cân nhắc điều này khi xây dựng các ứng dụng của bạn.

Đầu tiên, bạn nên luôn tạo các xử lý nhật ký riêng biệt cho các thành phần khác nhau trong ứng dụng của mình, do đó cho phép bạn đặt các cụm từ tìm kiếm có ý nghĩa trên siêu dữ liệu cơ bản để có thể nhanh chóng xác định vị trí nhật ký phù hợp nhất đến một phần của ứng dụng của bạn.

Ngoài ra, hãy tận dụng OSLogStore để thu thập các chẩn đoán có giá trị khi sự cố xảy ra với ứng dụng của bạn tại hiện trường.

Và cuối cùng, hãy nhớ rằng OSLog là một cơ sở truy tìm.

Điều này có nghĩa là nó có khả năng cung cấp cho bạn phân tích hiệu suất phức tạp của ứng dụng của bạn bằng cách sử dụng các công cụ như Công cụ.

Trong ví dụ này, tôi đang sử dụng mẫu hồ sơ ghi nhật ký để phân tích hiệu suất của ứng dụng của mình bằng OSLogs và biển chỉ dẫn.

Bây giờ, hãy tóm tắt lại những gì chúng ta vừa xem qua và những gì bạn có thể làm để cải thiện trải nghiệm lập trình của riêng mình.

Đầu tiên, bạn nên khám phá Bảng điều khiển gỡ lỗi mới trong Xcode 15, nơi chúng tôi đã cung cấp rất nhiều cải tiến cho tất cả các nhu cầu ghi nhật ký của bạn.

Tiếp theo, bạn nên làm việc để di chuyển mã của mình từ I/O tiêu chuẩn sang OSLog, cung cấp cho bạn tất cả các tính năng mới mà Bảng điều khiển gỡ lỗi mới cung cấp.

Sau đó, hãy thử lệnh Do What I Mean Print hoặc "p" mới của LLDB và đảm bảo sử dụng lệnh này khi thực hiện kiểm tra biến trước.

Và cuối cùng, để biết thêm thông tin về API Ghi nhật ký hợp nhất của Apple, vui lòng xem các phiên trước của chúng tôi, "Đo hiệu suất bằng cách sử dụng ghi nhật ký" và "Khám phá đăng nhập Swift".

Đăng nhập vui vẻ, và cảm ơn vì đã xem.