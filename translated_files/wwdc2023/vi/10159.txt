10159

♪ ♪

Harry: Xin chào, tôi là Harry, một kỹ sư trong nhóm SwiftUI.

Chào mừng bạn đến với Beyond Scroll Views, nơi tôi sẽ nói về một số cải tiến mới đối với chế độ xem cuộn trong SwiftUI.

Những thứ mà thiết bị của chúng tôi muốn làm hiếm khi có thể được chứa trong kích thước màn hình cố định của chúng.

Một cách họ xử lý sự phức tạp này là giới thiệu cuộn.

Điều này cho phép họ hiển thị cho chúng ta mọi thứ không vừa với màn hình.

SwiftUI cung cấp một vài thành phần khác nhau cho phép bạn tích hợp cuộn vào các ứng dụng của riêng mình.

Hôm nay, tôi sẽ nói về một trong những thành phần đó.

Chế độ xem cuộn.

ScrollView là một khối xây dựng cho phép nội dung của bạn cuộn.

Chế độ xem cuộn có các trục xác định các hướng mà chúng có thể cuộn được.

Chế độ xem cuộn có nội dung.

Khi nội dung đó vượt quá kích thước của ScrollView, một số nội dung đó sẽ bị cắt và mọi người sẽ cần cuộn để hiển thị nó.

Chế độ xem cuộn đảm bảo rằng nội dung được đặt trong khu vực an toàn bằng cách phân giải khu vực an toàn thành các lề vượt trội hơn nội dung của nó.

ScrollView đánh giá nội dung của nó một cách háo hức theo mặc định.

Bạn có thể thay đổi hành vi này bằng cách sử dụng một ngăn xếp lười biếng.

Vị trí chính xác của nơi ScrollView được cuộn trong nội dung được gọi là độ lệch nội dung.

SwiftUI đã cung cấp ScrollViewReader API như một cách để kiểm soát độ lệch nội dung.

Năm nay, SwiftUI đang giới thiệu nhiều cách hơn để vừa ảnh hưởng vừa phản ứng với độ lệch nội dung được quản lý bởi ScrollView.

Trong buổi nói chuyện này, tôi sẽ bắt đầu bằng cách thảo luận về các cách để tác động đến lề của ScrollView và cách chúng liên quan đến các khu vực an toàn.

Sau đó tôi sẽ nói về việc quản lý độ lệch nội dung của ScrollView thông qua các mục tiêu cuộn và vị trí cuộn.

Cuối cùng, tôi sẽ giới thiệu cách bạn có thể thêm một số sự tinh tế thực sự vào ứng dụng của mình với chuyển tiếp cuộn.

Kể từ khi tôi bắt đầu tạo ứng dụng Colors của mình, người dùng của tôi đã thực sự thích hiển thị cho tôi một số kết hợp màu sắc yêu thích của họ.

Tôi muốn giới thiệu một số kết hợp này để những người khác có thể thưởng thức chúng.

Để làm điều này, tôi đã làm việc để thêm tính năng thư viện vào ứng dụng Màu sắc của mình.

Tôi đã đạt được một số tiến bộ trong việc triển khai phòng trưng bày của mình.

Trong suốt buổi nói chuyện này, tôi sẽ đánh bóng cả tiêu đề và nội dung của phần nổi bật trong thư viện của mình.

Trong thư viện của tôi, tôi có một ScrollView ngang bao bọc một ngăn xếp lười biếng.

Đầu tiên tôi sẽ làm cho khung cảnh này trông đẹp hơn một chút với một số lề.

Bản năng đầu tiên của bạn có thể là thêm một số phần đệm vào ScrollView và điều này sẽ chèn ScrollView, nhưng lưu ý rằng bây giờ nội dung của nó bị cắt khi cuộn.

Thay vì cài đặt ScrollView, tôi muốn mở rộng lề nội dung của ScrollView.

Tôi có thể làm điều đó với công cụ sửa đổi đệm khu vực an toàn mới.

Điều này hoạt động giống như công cụ sửa đổi đệm thông thường, nhưng thay vì đệm nội dung, nó thêm đệm vào khu vực an toàn.

Bây giờ ScrollView của tôi mở rộng toàn bộ chiều rộng, cho phép mục tiếp theo nhìn ra ngoài.

Trước khi tôi đi xa hơn, tôi sẽ nói một chút về các khu vực an toàn liên quan đến ScrollView.

Các khu vực an toàn thường đến từ thiết bị mà ứng dụng của bạn đang chạy.

Cũng có thể đến từ các API như đệm khu vực an toàn hoặc công cụ sửa đổi bên trong khu vực an toàn.

ScrollView giải quyết khu vực an toàn vào lề mà nó áp dụng cho nội dung của nó.

Điều này bao gồm nội dung bạn chịu trách nhiệm, nhưng cũng có nội dung bổ sung mà ScrollView chịu trách nhiệm như các chỉ báo cuộn.

Điều này có nghĩa là không thể định cấu hình các cài đặt khác nhau cho các loại nội dung khác nhau bằng cách sửa đổi khu vực an toàn.

Nếu bạn muốn áp dụng các nội dung khác nhau, bạn có thể sử dụng API contentMargins mới.

API này cho phép bạn chèn nội dung của ScrollView riêng biệt với các chỉ báo cuộn.

Hoặc chèn các chỉ số riêng biệt với nội dung.

Quay trở lại thư viện của mình, tôi sẽ cập nhật công cụ sửa đổi đệm khu vực an toàn của mình để sử dụng API lề nội dung.

Bây giờ quan điểm của tôi đã được áp dụng một chút lề, một trong những điều tôi muốn làm là kiểm soát nội dung bù đắp mà ScrollView sẽ cuộn đến khi ai đó nhấc ngón tay lên.

Theo mặc định, ScrollView sử dụng tốc độ giảm tốc tiêu chuẩn cùng với vận tốc của cuộn để tính toán độ lệch nội dung mục tiêu mà cuộn sẽ kết thúc tại.

Nó không tính đến những thứ như kích thước của ScrollView hoặc nội dung của nó.

Nhưng đôi khi những thứ đó quan trọng.

Mới trong SwiftUI, bạn có thể thay đổi cách ScrollView tính toán độ lệch nội dung mục tiêu này bằng công cụ sửa đổi scrollTargetBehavior.

Công cụ sửa đổi này có một loại phù hợp với giao thức scrollTargetBehavior.

Ở đây tôi đã chỉ định hành vi phân trang.

Bây giờ ScrollView của tôi vuốt từng trang một.

Hành vi phân trang rất đặc biệt.

Nó có tốc độ giảm tốc tùy chỉnh và chọn nơi cuộn dựa trên kích thước chứa của chính ScrollView.

Điều này hoạt động tốt cho iOS, nhưng trở nên hơi nhiều trên màn hình lớn hơn của iPadOS.

Thay vì căn chỉnh theo kích thước chứa của ScrollView, tôi muốn căn chỉnh theo các chế độ xem riêng lẻ.

Hành vi căn chỉnh chế độ xem căn chỉnh ScrollView với chế độ xem, vì vậy ScrollView cần biết chế độ xem nào nên xem xét để căn chỉnh.

Những chế độ xem này được gọi là mục tiêu cuộn và có một họ công cụ sửa đổi mới cho phép tôi chỉ định chế độ xem nào là mục tiêu cuộn.

Ở đây tôi sẽ sử dụng công cụ sửa đổi bố cục mục tiêu cuộn để mỗi chế độ xem anh hùng trong ngăn xếp lười biếng được coi là mục tiêu cuộn.

Bạn cũng có thể đánh dấu các chế độ xem riêng lẻ là mục tiêu bằng cách sử dụng công cụ sửa đổi mục tiêu cuộn.

Nhưng khi sử dụng các ngăn xếp lười biếng, điều quan trọng là sử dụng công cụ sửa đổi bố cục mục tiêu cuộn.

Các chế độ xem bên ngoài khu vực có thể nhìn thấy vẫn chưa được tạo.

Tuy nhiên, bố cục biết nó sẽ tạo ra những chế độ xem nào, vì vậy nó có thể đảm bảo ScrollView cuộn đến đúng vị trí.

Bây giờ ScrollView của tôi trông đẹp hơn rất nhiều trên iPad.

Các hành vi phân trang và xem được căn chỉnh được xây dựng dựa trên giao thức ScrollTargetBehavior mới.

Mặc dù SwiftUI cung cấp các hành vi phổ biến này cho bạn, nhưng nó cũng cho phép bạn tuân thủ các loại của riêng mình với giao thức này và thực hiện hành vi tùy chỉnh của riêng bạn, giống như bạn sẽ áp dụng giao thức bố cục được giới thiệu trước đó.

Tuân thủ các loại của riêng bạn với ScrollTargetBehavior bằng cách triển khai một phương pháp bắt buộc: updateTarget.

SwiftUI gọi phương thức này khi tính toán nơi cuộn sẽ kết thúc, nhưng cũng trong các ngữ cảnh khác như khi ScrollView thay đổi kích thước.

Tùy chỉnh hành vi thật dễ dàng.

Ở đây nếu mục tiêu ở gần đầu ScrollView và cuộn được vuốt lên, tôi sẽ thích cuộn đến đầu chính xác của ScrollView bằng cách sửa đổi mục tiêu được cung cấp.

Điều này sẽ dẫn đến việc ScrollView chọn một độ lệch nội dung khác làm điểm cuối của cuộn.

Và đó là tất cả những gì cần thiết để chèn mã tùy chỉnh của riêng tôi để ảnh hưởng đến nơi ScrollView chọn cuộn.

Hãy quay lại chế độ xem phòng trưng bày của tôi.

Tôi muốn nói về bố cục.

Lưu ý rằng chế độ xem anh hùng của tôi có kích thước liên quan đến chiều rộng tổng thể của thiết bị.

Và nếu chúng ta nhìn vào iPad, hai chế độ xem vừa khít với chiều rộng của thiết bị.

Trước đây bạn sẽ phải sử dụng GeometryReader để thực hiện điều này, nhưng năm nay SwiftUI làm cho điều này dễ dàng hơn nhiều với một API mới được gọi là công cụ sửa đổi containerRelativeFrame.

Tôi sẽ chỉ cho bạn cách chế độ xem anh hùng của tôi sử dụng API này.

Tôi sẽ bắt đầu với một chồng chế độ xem màu, cùng với công cụ sửa đổi khung chỉ định chiều cao cố định.

Tôi sẽ thêm công cụ sửa đổi containerRelativeFrame vào chế độ xem của mình.

Ở đây tôi chỉ định trục ngang, cho phép chế độ xem chỉ chiếm chiều rộng của vùng chứa của nó.

Trong trường hợp của tôi, vùng chứa sẽ là ScrollView xung quanh, nhưng nó cũng có thể là cột gần nhất của chế độ xem phân chia điều hướng hoặc cửa sổ ứng dụng của bạn.

Khi chiều rộng vùng chứa của tôi thay đổi, kích thước chế độ xem của tôi sẽ tự động cập nhật.

Tôi có thể tạo bố cục giống như lưới của các chế độ xem này bằng cách cung cấp số lượng và khoảng cách.

Tôi có thể điều kiện hóa số lượng dựa trên sizeClass nằm ngang để có hai cột trên iPad và một cột trên điện thoại.

Điều tuyệt vời hơn nữa là tôi có thể loại bỏ các điều kiện hệ điều hành vì thuộc tính môi trường sizeClass nằm ngang hiện có sẵn trên tất cả các nền tảng.

Cuối cùng, tôi sẽ sử dụng công cụ sửa đổi aspectRatio để có chiều cao so với chiều rộng, thay vì mã hóa cứng chiều cao cố định.

Vì vậy, tôi đã hoàn thành bố cục và hành vi cuộn của thư viện của mình.

Có một số thay đổi khác mà tôi muốn thực hiện.

Một điều bạn sẽ nhận thấy là các chỉ báo cuộn.

Tôi muốn loại bỏ những thứ đó.

Tôi có thể sử dụng scrollIndicators API hiện có để thực hiện việc này.

Điều này trông thật tuyệt khi vuốt ngón tay của tôi trên iPad, nhưng tôi thường sử dụng thư viện của mình trên máy Mac.

Và trên máy Mac, tôi có thể không thể dễ dàng thực hiện cử chỉ vuốt ngang như khi sử dụng chuột hoặc các thiết bị đầu vào khác.

Và khi tôi kết nối một con chuột, các chỉ báo sẽ hiển thị, mặc dù tôi đã yêu cầu chúng được ẩn.

Sử dụng chuột có thể khiến việc cuộn trở nên khó khăn hoặc không thể thực hiện được nếu không có các chỉ báo cuộn.

Vì lý do này, hành vi mặc định của công cụ sửa đổi scrollIndicators là ẩn các chỉ báo khi sử dụng các thiết bị đầu vào linh hoạt hơn, như bàn di chuột, nhưng cho phép các chỉ báo hiển thị khi kết nối chuột.

Bạn có thể cung cấp giá trị không bao giờ cho công cụ sửa đổi scrollIndicators để luôn ẩn các chỉ báo bất kể thiết bị đầu vào.

Nhưng ứng dụng của tôi vẫn cần hỗ trợ những người sử dụng chuột.

Vì vậy, tôi sẽ cần cung cấp một phương tiện thay thế để cuộn thư viện của mình cho họ.

Thay vì chỉ báo cuộn, tôi sẽ hiển thị một số chế độ xem cho phép người dùng cuộn đến chế độ xem trước đó hoặc chế độ xem tiếp theo chỉ bằng một cú nhấp chuột.

Để bắt đầu xây dựng nó, hãy dọn dẹp ScrollView của tôi một chút.

Tôi sẽ di chuyển ScrollView của mình sang VStack với chế độ xem tiêu đề của mình.

Bây giờ tôi sẽ tập trung vào chế độ xem tiêu đề.

Tôi sẽ thêm một số chế độ xem mái chèo tùy chỉnh vào chế độ xem tiêu đề.

Trong các phiên bản trước của SwiftUI, tôi sẽ tiếp cận ScrollViewReader để chuyển sang mái chèo của mình và cuộn đến chế độ xem thích hợp.

Tuy nhiên, tính mới trong SwiftUI là công cụ sửa đổi scrollPosition.

Công cụ sửa đổi này liên kết một liên kết với một trạng thái bao bọc một mã định danh.

Tôi sẽ chuyển nó cho công cụ sửa đổi scrollPosition của mình mà ScrollView sẽ đọc từ và đến chế độ xem tiêu đề của tôi.

Trong các mái chèo của chế độ xem tiêu đề của tôi, tôi có thể viết vào ràng buộc giống như bất kỳ phần nào khác của trạng thái.

Khi ràng buộc được ghi vào, ScrollView sẽ cuộn đến chế độ xem có ID đó.

Cũng giống như chế độ xem được căn chỉnh ScrollTargetBehavior, công cụ sửa đổi vị trí cuộn sử dụng công cụ sửa đổi bố cục mục tiêu cuộn để biết chế độ xem nào cần xem xét để truy vấn các giá trị nhận dạng của chúng.

Công cụ sửa đổi vị trí cuộn cũng cho phép tôi biết danh tính của chế độ xem hiện đang được cuộn.

Vì vậy, tôi có thể thêm vào chế độ xem tiêu đề của mình một số văn bản hiển thị giá trị của hình ảnh anh hùng hiện đang được cuộn.

Khi chế độ xem hàng đầu nhất trong ScrollView của tôi thay đổi, ràng buộc sẽ tự động cập nhật.

Bây giờ người dùng chuột của tôi có thể cuộn qua thư viện của tôi.

Có một chút đánh bóng cuối cùng mà tôi muốn thêm vào chế độ xem này.

Cũng giống như việc biết chế độ xem nào hiện đang được cuộn, đôi khi tôi muốn thay đổi chế độ xem một cách trực quan dựa trên vị trí của nó trong ScrollView.

Có một API mới được gọi là ScrollTransitions trong SwiftUI giúp việc này thực sự dễ dàng.

ScrollTransition rất giống một quá trình chuyển đổi bình thường.

Quá trình chuyển đổi mô tả những thay đổi mà một chế độ xem nên trải qua khi nó xuất hiện hoặc biến mất.

Khi một chế độ xem đã xuất hiện, nó đang trong giai đoạn nhận dạng mà không nên áp dụng các tùy chỉnh.

ScrollTransition mô tả một tập hợp các thay đổi tương tự như một quá trình chuyển đổi nhưng thay vào đó áp dụng chúng khi chế độ xem đi vào vùng hiển thị của ScrollView và sau đó rời khỏi vùng hiển thị.

Theo mặc định, khi chế độ xem nằm ở trung tâm của vùng hiển thị, nó đang trong giai đoạn nhận dạng của ScrollTransition.

Hãy nhìn vào điều này trong bối cảnh quan điểm anh hùng của tôi.

Tôi sẽ dọn dẹp cái này một chút để tập trung vào ScrollTransitions.

Khi chế độ xem đến gần các cạnh của ScrollView, tôi muốn nó thu nhỏ kích thước một chút.

Tôi sẽ bắt đầu bằng cách thêm công cụ sửa đổi scrollTransition.

API này lấy nội dung và một giai đoạn và cho phép bạn chỉ định các thay đổi trực quan đối với nội dung dựa trên giai đoạn.

Ở đây tôi sẽ chỉ định giảm tỷ lệ khi chế độ xem không ở giai đoạn nhận dạng của nó.

Trông thật tuyệt!

ScrollTransitions hoạt động với một giao thức mới được gọi là VisualEffect.

Giao thức này cung cấp một tập hợp các tùy chỉnh để xem nội dung an toàn để sử dụng làm chức năng bố cục như độ lệch nội dung của ScrollView.

Nhiều người trong số họ có thể trông quen thuộc với bạn.

Bạn đã biết về hiệu ứng thang đo.

Bạn cũng có thể tùy chỉnh vòng quay hoặc độ lệch giống như bạn làm với các công cụ sửa đổi chế độ xem.

Tuy nhiên, không phải tất cả các công cụ sửa đổi chế độ xem đều có thể được sử dụng một cách an toàn bên trong scrollTransition.

Ví dụ, tùy chỉnh phông chữ không được hỗ trợ và sẽ không được xây dựng.

Bất cứ điều gì sẽ thay đổi kích thước nội dung tổng thể của ScrollView đều không thể được sử dụng trong công cụ sửa đổi scrollTransition.

Chà, chúng tôi đã đề cập rất nhiều nên hãy xem lại nhanh.

Chúng tôi đã nói về sự khác biệt giữa các khu vực an toàn và nội dungMargins và mối quan hệ của chúng với ScrollViews.

Tôi đã chỉ cho bạn cách bạn có thể sử dụng phân trang và xem scrollTargetBehaviors được căn chỉnh để ảnh hưởng đến cách ScrollView hoạt động và cách bạn có thể viết các tuân thủ của riêng mình với giao thức scrollTargetBehavior.

Bạn đã tìm hiểu về việc tạo bố cục liên quan đến vùng chứa của họ dễ dàng hơn bao nhiêu bằng cách sử dụng công cụ sửa đổi containerRelativeFrame.

Tôi đã kết nối với trạng thái của ScrollView bằng cách sử dụng công cụ sửa đổi scrollPosition, cho phép tôi vừa cuộn theo chương trình vừa được thông báo về chế độ xem nào hiện đang được cuộn.

Và cuối cùng, tôi đã tạo ra các hiệu ứng hình ảnh dựa trên độ lệch nội dung của ScrollView của tôi với scrollTransition API.

Tôi hy vọng bạn thích tìm hiểu về những cải tiến này đối với ScrollViews.

Cảm ơn, và chúc bạn có một WWDC tuyệt vời.

♪ ♪