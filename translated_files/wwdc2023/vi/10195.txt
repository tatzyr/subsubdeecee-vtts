10195

♪ ♪

Rishi: Xin chào, tên tôi là Rishi Verma, và phiên này bao gồm cách mã hóa các mô hình của bạn để xây dựng lược đồ cho SwiftData.

Tôi sẽ bắt đầu bằng cách đề cập đến cách bạn có thể sử dụng các macro lược đồ với tiềm năng tối đa của chúng và cách bạn có thể phát triển lược đồ của mình với việc di chuyển lược đồ khi ứng dụng của bạn thay đổi.

Trước khi bắt đầu, vui lòng xem "Gặp gỡ SwiftData" và "Xây dựng ứng dụng với SwiftData", vì nội dung này sẽ phát triển dựa trên các khái niệm được giới thiệu trong các video đó.

SwiftData là một khuôn khổ mạnh mẽ để mô hình hóa và quản lý dữ liệu và nâng cao ứng dụng Swift hiện đại của bạn.

Giống như SwiftUI, nó tập trung hoàn toàn vào mã, không có định dạng tệp bên ngoài và sử dụng hệ thống macro mới của Swift để tạo ra trải nghiệm API liền mạch.

Tôi đang làm việc trên ứng dụng SampleTrips, cho phép người dùng lên kế hoạch cho một số chuyến đi sắp tới.

Mỗi chuyến đi sẽ được tạo ra với một cái tên, một điểm đến, cũng như ngày bắt đầu và ngày kết thúc.

Một chuyến đi cũng có thể chứa các mối quan hệ cho các mục trong danh sách nhóm và nơi khách du lịch sẽ ở lại.

Thêm SwiftData cũng đơn giản như thêm nhập và trang trí Chuyến đi với @Model.

Thế là xong.

Macro @Model phù hợp với lớp Trip của tôi với PersistentModel và tạo ra một lược đồ mô tả.

Mã xác định mô hình của tôi bây giờ là nguồn gốc của sự thật cho lược đồ ứng dụng của tôi.

Hành vi mặc định của mô hình chuyến đi của tôi là tốt, nhưng tôi nghĩ tôi có thể tinh chỉnh nó một chút.

Các macro lược đồ của SwiftData cho phép tôi tùy chỉnh hành vi của trải nghiệm bền bỉ để hoạt động hoàn hảo cho ứng dụng của mình.

Khi tôi xuất bản ứng dụng của mình với lược đồ ban đầu, tôi không đảm bảo mỗi tên chuyến đi là duy nhất.

Điều này đã gây ra một vài xung đột giữa các chuyến đi cùng tên mà bây giờ tôi cần giải quyết.

Điều này có thể được khắc phục bằng macro lược đồ @Attribute và sử dụng tùy chọn duy nhất.

SwiftData sẽ tạo ra một lược đồ cho mô hình chuyến đi của tôi, giờ đây đảm bảo bất kỳ chuyến đi nào mà tôi lưu vào back end liên tục sẽ có một tên duy nhất.

Nếu một chuyến đi đã tồn tại với tên đó, thì back end liên tục sẽ cập nhật lên các giá trị mới nhất.

Điều này được gọi là upsert.

Một upsert bắt đầu như một phần chèn.

Nếu phần chèn va chạm với dữ liệu hiện có, nó sẽ trở thành bản cập nhật và cập nhật các thuộc tính của dữ liệu hiện có.

Tôi cũng có thể áp dụng các ràng buộc duy nhất trên các thuộc tính khác, miễn là chúng là các loại giá trị nguyên thủy như số, chuỗi hoặc UUID, hoặc thậm chí tôi có thể trang trí mối quan hệ 1-1.

Lược đồ của tôi cần thêm một chút công việc.

Tôi muốn loại bỏ những dấu gạch dưới phiền phức này khỏi ngày bắt đầu và ngày kết thúc mà tôi đã chỉ định ban đầu.

Nếu tôi chỉ đổi tên các biến, đây sẽ được coi là một thuộc tính mới trong lược đồ được tạo của tôi.

Tôi không muốn SwiftData tạo ra những thuộc tính mới này.

Thay vào đó, tôi muốn giữ nguyên dữ liệu hiện có.

Tôi có thể làm như vậy bằng cách đơn giản ánh xạ tên gốc đến tên thuộc tính bằng cách sử dụng @Attribute và chỉ định tham số originalName:.

Bằng cách ánh xạ những thứ này từ tên gốc, tôi có thể tránh mất dữ liệu.

Điều này cũng đảm bảo bản cập nhật lược đồ của tôi sẽ là một quá trình di chuyển đơn giản cho bản phát hành tiếp theo của ứng dụng SampleTrips.

Và macro @Attribute có thể làm được nhiều hơn thế, bao gồm lưu trữ dữ liệu lớn bên ngoài và cung cấp hỗ trợ cho các khả năng chuyển đổi.

Các chuyến đi của tôi đang hình thành tốt đẹp, nhưng bây giờ tôi muốn làm việc trên các mối quan hệ.

Khi tôi thêm một mục danh sách nhóm mới hoặc chỗ ở vào chuyến đi của mình, SwiftData sẽ ngầm khám phá các nghịch đảo giữa các mô hình của tôi và đặt chúng cho tôi.

Nghịch đảo ngầm không yêu cầu bất kỳ chú thích nào.

Họ chỉ làm việc.

Nghịch đảo ngầm sử dụng quy tắc xóa mặc định sẽ vô hiệu hóa các mục trong danh sách nhóm và thuộc tính chỗ ở khi chuyến đi bị xóa.

Tuy nhiên, tôi muốn các mục trong danh sách nhóm và chỗ ở của mình bị xóa cùng với chuyến đi.

Tôi có thể dễ dàng làm điều đó bằng cách thêm macro @Relationship với quy tắc xóa theo tầng.

Bây giờ khi tôi xóa chuyến đi của mình, nó cũng sẽ xóa những mối quan hệ đó.

Và macro @Relationship làm được nhiều việc hơn thế, bao gồm công cụ sửa đổi originalName và khả năng chỉ định số lượng tối thiểu và tối đa trên mối quan hệ nhiều người.

Ứng dụng SampleTrips đang hình thành tốt, nhưng tôi vẫn còn một bản cập nhật cần làm.

Bây giờ, tôi muốn thêm một cách để theo dõi số lần tôi xem một chuyến đi.

Bằng cách này tôi có thể đánh giá mức độ phấn khích của tôi khi đi nghỉ.

Tôi không thể chờ đợi!

Tuy nhiên, tôi không muốn SwiftData duy trì số lượt xem này và tôi có thể dễ dàng làm điều đó với macro @Transient.

Tôi chỉ đơn giản là trang trí tài sản của mình bằng @Transient, và tài sản cụ thể này sẽ không được duy trì.

Nó thật dễ dàng.

Macro @Transient giúp bạn tránh tồn tại dữ liệu không cần thiết.

Đảm bảo rằng bạn cung cấp một giá trị mặc định cho các thuộc tính tạm thời.

Điều này đảm bảo chúng có các giá trị logic khi được tìm nạp từ SwiftData.

Để biết thêm thông tin về việc sử dụng các macro lược đồ này, hãy xem tài liệu SwiftData.

Lược đồ ứng dụng SampleTrips đã trải qua một số tiến hóa khi tôi điều chỉnh trải nghiệm bền bỉ.

Tôi cần đảm bảo rằng ứng dụng của tôi có thể xử lý các bản cập nhật đó từ khi phát hành đến khi phát hành.

Và khi bạn thực hiện thay đổi đối với lược đồ của mình, như thêm hoặc xóa một thuộc tính, việc di chuyển dữ liệu sẽ xảy ra.

Những di chuyển này có thể là những tình huống khó khăn, nhưng SwiftData làm cho nó dễ dàng.

VersionedSchema và SchemaMigrationPlan ở đây để giúp bạn điều đó.

Bất cứ khi nào bạn chuẩn bị phát hành phiên bản mới của ứng dụng với những thay đổi đối với mô hình SwiftData của bạn, hãy xác định VersionedSchema gói gọn lược đồ đã phát hành trước đó của bạn.

Mỗi phiên bản riêng biệt của lược đồ của bạn nên được định nghĩa là VersionedSchema để SwiftData biết những thay đổi nào đã xảy ra giữa chúng.

Sau đó, sử dụng tổng thứ tự VersionedSchemas của bạn để tạo SchemaMigrationPlan.

Điều này sẽ cho phép SwiftData thực hiện các thao tác di chuyển cần thiết theo thứ tự.

Khi bạn đã đặt ra các lược đồ đã đặt hàng của mình trong kế hoạch di chuyển, bạn có thể bắt đầu xác định từng giai đoạn di chuyển.

Có hai loại giai đoạn di chuyển khác nhau có sẵn cho bạn.

Đầu tiên là một giai đoạn di chuyển nhẹ.

Di chuyển nhẹ không yêu cầu bất kỳ mã bổ sung nào để di chuyển dữ liệu hiện có cho bản phát hành ứng dụng tiếp theo của tôi.

Các sửa đổi như thêm originalName vào thuộc tính ngày của tôi hoặc chỉ định các quy tắc xóa trên các mối quan hệ của tôi đủ điều kiện di chuyển nhẹ.

Tuy nhiên, việc đặt tên cho một chuyến đi trở nên độc đáo không đủ điều kiện để di chuyển nhẹ.

Tôi cần tạo một giai đoạn di chuyển tùy chỉnh cho sự thay đổi này, trong đó tôi có thể sao chép các chuyến đi của mình, trước khi tên của chúng được làm duy nhất.

Tôi bắt đầu bằng cách lấy lược đồ gốc từ bản phát hành đầu tiên của mình và gói gọn nó trong VersionedSchema.

Tôi đặt tên cho lược đồ phiên bản này là SampleTripsSchemaV1.

Mỗi lược đồ phiên bản của tôi liệt kê các lớp mô hình mà chúng xác định.

Phiên bản 2 của lược đồ của tôi là nơi tôi đã thêm ràng buộc tính độc đáo vào tên chuyến đi.

Tôi tạo một lược đồ có phiên bản khác cũng gói gọn những thay đổi tôi đã thực hiện đối với lớp mô hình Trip.

Tôi cũng làm như vậy đối với phiên bản 3 của lược đồ của mình, nắm bắt các thay đổi tên được thực hiện để bắt đầu và ngày kết thúc.

Bây giờ tôi đã có tất cả các VersionedSchemas của mình, tôi xây dựng SchemaMigrationPlan để mô tả cách xử lý việc di chuyển từ bản phát hành này sang bản phát hành khác.

Nó khá đơn giản.

Tôi chỉ cung cấp tổng thứ tự của các lược đồ ứng dụng của tôi.

Sau đó, tôi cần chú thích di chuyển nào là nhẹ hoặc tùy chỉnh.

Đối với V1 đến V2, tôi cần một giai đoạn tùy chỉnh nơi tôi có thể thực hiện một thao tác trước khi dữ liệu được di chuyển.

Trong việc đóng cửa willMigrate, tôi có thể hủy trùng lặp các chuyến đi của mình trước khi quá trình di chuyển xảy ra.

SwiftData sẽ phát hiện khi nào việc di chuyển từ V1 sang V2 sẽ xảy ra và sẽ thực hiện việc đóng cửa này cho tôi.

Việc di chuyển khác cho originalName rất nhẹ, vì vậy tôi cũng có thể thêm giai đoạn đó vào.

Bây giờ tôi đã xác định tất cả các chi tiết về kế hoạch di chuyển của mình, đã đến lúc thực hiện di chuyển.

Tôi thiết lập ModelContainer của mình với lược đồ hiện tại và kế hoạch di chuyển, và tôi đã hoàn tất.

Người dùng của tôi có thể nâng cấp từ bất kỳ phiên bản nào lên bản phát hành mới nhất và tôi đã đảm bảo dữ liệu sẽ được giữ nguyên.

Tôi nóng lòng muốn sử dụng ứng dụng SampleTrips để lên kế hoạch cho kỳ nghỉ sắp tới của mình.

Khai thác các macro lược đồ để truyền tải siêu dữ liệu bổ sung cho lược đồ của bạn và khi ứng dụng của bạn phát triển, hãy nắm bắt những tiến hóa đó trong VersionedSchema để ứng dụng của bạn có thể di chuyển từ bất kỳ bản phát hành nào trước đó.

Hãy xem những cuộc nói chuyện khác này và chúng tôi mong muốn được thấy những điều tuyệt vời mà tất cả các bạn thực hiện với SwiftData.

Đó là một vinh dự.